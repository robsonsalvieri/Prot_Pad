#include "tlpp-core.th"
#include "backoffice.reconciliation.accessdefinitions.data.protheus.ch"

namespace totvs.protheus.backoffice.reconciliation.accessdefinitions

/*/{Protheus.doc} AccessDefinitionsProtheusData
    (long_description)
    @author Totvs
    @since 04/04/2022
    @version 12.1.33
    /*/
class AccessDefinitionsProtheusData from FWAdapterBaseV2
    Public  method new()
    Public  method getData() as Object
    Public  method postSaveAccessDefinitions() as Array
    Public  method deleteAccessDefinitions()
    Public  method getAccessDefinitions()
    Public  method getAll()
    Private method validAccessDefinitions() as Array
    Private method execDelete()
    Private method deleteRemoved()
    Private method getCodDef() as Character
    Private method searchInfoAccessDefinitions()
    Private method returnAsJson()
    
endClass

/*/{Protheus.doc} new
    Método construtor
    @author Totvs
    @since 05/04/2022
    @version version
    /*/
method new() class AccessDefinitionsProtheusData
return

method getData() class AccessDefinitionsProtheusData as Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := AccessDefinitionsProtheusData():new()
    EndIf

return __oActiveData

/*/{Protheus.doc} postSaveAccessDefinitions
    Método que grava o JSON na tabela QLB
    @author Totvs
    @since 05/04/2022
    @version 12.1.33
    @param jBody
    @return aValid[2], return_type: character,
    return_description: aValid contém as mensagens de validação negativas,
    caso esteja vazio a validação está ok
/*/
Method postSaveAccessDefinitions(jBody) class AccessDefinitionsProtheusData
    Local cCodDef       as Character
    Local cDescription  as Character
    Local cStatus       as Character
    Local cType         as Character
    Local cProgram      as Character
    Local cUserGrp      as Character
    Local nI            as Numeric
    Local lAlter        as Logical
    Local lInclude      as Logical
    Local aValid        as Array
    Local nTamCpoRotina as Numeric 
    
    cCodDef         := ""
    cDescription    := ""
    cStatus         := ""
    cType           := ""
    cUserGrp        := ""
    nI              := 0
    lAlter          := .T.
    lInclude        := .F.
    aValid          := ::validAccessDefinitions()
    nTamCpoRotina   := TamSx3('QLM_ROTINA')[1]        

    If aValid[1]
        lAlter :=  (jBody:hasProperty('code')) //Se o código for enviado, é uma alteração, caso contrário é uma alteração
                    
        If lAlter // Se for alteração
            cCodDef := jBody["code"]
            If jBody:hasProperty('remove')
                ::deleteRemoved(cCodDef, jBody, @aValid)
            EndIf
        Else 
            cCodDef := ::getCodDef()
        EndIf
        
        If aValid[1] //Em caso de alteração o aValid pode ter sido alterado

            cDescription    := jBody["descri"]
            cStatus         := jBody["status"]
            cType           := jBody["type"]
            cProgram        := PadR(jBody["program"],nTamCpoRotina)
            cConfigs        := jBody["save"]:toJson()
            
            QLM->(DbSetOrder(2)) //QLM_FILIAL+QLM_ROTINA+QLM_TIPO+QLM_USRGRP+QLM_STATUS             
            For nI := 1 to Len(jBody["usersgroups"])
            
                cUserGrp := jBody["usersgroups"][nI]    
                If(QLM->(dbSeek(xFilial("QLM")+cProgram+cType+cUserGrp)))
                    lInclude := .F.
                Else
                    lInclude := .T. 
                EndIf

                QLM->(RecLock("QLM", lInclude))
                QLM->QLM_FILIAL := xFilial("QLM")
                QLM->QLM_CODIGO := cCodDef
                QLM->QLM_DESCRI := cDescription
                QLM->QLM_TIPO   := cType
                QLM->QLM_ROTINA := cProgram
                QLM->QLM_STATUS := cStatus
                QLM->QLM_USRGRP := cUserGrp    
                QLM->QLM_CONFIG := cConfigs
                QLM->(MsUnlock())
            Next nI

            aValid[2] := cCodDef
        EndIf
    EndIf

Return aValid

/*/{Protheus.doc} postSaveAccessDefinitions
    Método que realiza a validação JSON recebido
    @author Totvs
    @since 05/04/2022
    @version 12.1.33
    @param jBody
/*/

Method validAccessDefinitions() class AccessDefinitionsProtheusData as Array
    Local aValid := {} as Array

    aAdd(aValid, .F.)
    aAdd(aValid, STR0001) //"A tabela de Definições de Acesso do Conciliador Backoffice não existe no banco de dados"

    If ChkFile("QLM")
        aValid[1] := .T.
        aValid[2] := ""
    EndIf
    
Return aValid

/*/{Protheus.doc} deleteRemoved
    Executa os updates para deletar os Matchsetting (Arquivos QLB)
    @author user
/*/
Method deleteRemoved(cCodDef as Character, jBody as JSON, aValid as Array) class AccessDefinitionsProtheusData
    Local cType         as Character
    Local cProgram      as Character
    Local nI            as Numeric
    Local nTamCpoRotina as Numeric 

    nTamCpoRotina   := TamSx3("QLM_ROTINA")[1]
    cProgram        := PadR(jBody["program"],nTamCpoRotina)
    cType           := jBody["type"]
    nI              := 0

    QLM->(DBSetOrder(1)) //QLM_FILIAL+QLM_CODIGO+QLM_ROTINA+QLM_TIPO+QLM_USRGRP+QLM_STATUS

    //Posiciono em um registro do código alterado
    If(QLM->(dbSeek(xFilial("QLM")+cCodDef+cProgram)))
        //Se o tipo excluído for do mesmo tipo já presente no código, devo excluir apenas itens específicos 
        If cType == QLM->QLM_TIPO
            For nI := 1 to Len(jBody["remove"]["usersgroups"])
                If(QLM->(dbSeek(xFilial("QLM")+cCodDef+cProgram+cType+jBody["remove"]["usersgroups"][nI])))
                    QLM->(RecLock("QLM", .F.))
                    QLM->(DbDelete())
                    QLM->(MsUnlock())
                EndIf
            Next nI
        Else //Se o tipo excluído for diferente, todos os itens abaixo deste código serão excluídos
            ::execDelete(cCodDef,@aValid)
        EndIf
    EndIf
Return aValid

/*/{Protheus.doc} execDelete
    Executa os updates para deletar os Matchsetting (Arquivos QLB)
    @author user
/*/
Method execDelete(cCodDef as Character, aValid as Array) class AccessDefinitionsProtheusData
    Local cQryUpd as Character

    cQryUpd := "UPDATE "+RetSQLName("QLM")+" SET D_E_L_E_T_ = '*', R_E_C_D_E_L_ = R_E_C_N_O_  "+;
    " WHERE QLM_FILIAL = '"+xFilial("QLM")+"' AND QLM_CODIGO = '"+cCodDef+"' " +;
    " AND D_E_L_E_T_ = ' ' "

    IIf(TcSqlExec(cQryUpd) <> 0, ;
        (Conout(TCSqlError()), ;
        aValid[1] := .F., ;
        aValid[2] := STR0003), ) //"Erro: Nao foi possivel remover os itens selecionados"

Return

/*/{Protheus.doc} getCodCfg
    Função que retorna o código de Configuração de conciliação a ser utilizado
    @author Totvs
    @since 11/04/2022
    @version 12.1.33
    @param jBody, Json enviado pelo front-end com as informações a serem gravadas na QLB
    @return cCustomCodCfg
/*/
Method getCodDef() class AccessDefinitionsProtheusData
    Local cQuery        as Character
    Local cCodDef       as Character
    Local cAliasTmp     as Character

    cQuery        := ""
    cCodDef       := ""
    cAliasTmp     := GetNextAlias()

    cQuery := "SELECT COALESCE(MAX(QLM_CODIGO), '0000') CODDEF"
    cQuery += " FROM " + RetSQLName("QLM")
    cQuery += " WHERE QLM_FILIAL = '" + xFilial("QLM") + "' "

    dbUseArea(.T., "TOPCONN", TcGenQry(,, cQuery), cAliasTmp, .T., .F.)

    If (cAliasTmp)->(!EOF())
        cCodDef := (cAliasTmp)->CODDEF //Pega ultimo utilizado
        cCodDef:=  Soma1(cCodDef)
    EndIf

    (cAliasTmp)->(dbCloseArea())

Return cCodDef

/*/{Protheus.doc} deleteAccessDefinitions
    Método que grava o JSON na tabela QLB
    @author Totvs
    @since 05/04/2022
    @version 12.1.33
    @param jBody
    @return aValid[2], return_type: character,
    return_description: aValid contém as mensagens de validação negativas,
    caso esteja vazio a validação está ok
/*/
Method deleteAccessDefinitions(cCod as Character) class AccessDefinitionsProtheusData
    Local aValid    As Array
    
    aValid := {}

    aValid := ::validAccessDefinitions()

    If aValid[1]
        ::execDelete(cCod, aValid)
        aValid[2] := cCod
    EndIf

Return aValid

/*/{Protheus.doc} getAccessDefinitions
    Método que grava o JSON na tabela QLB
    @author Totvs
    @since 05/04/2022
    @version 12.1.33
    @param jBody
    @return aValid[2], return_type: character,
    return_description: aValid contém as mensagens de validação negativas,
    caso esteja vazio a validação está ok
/*/
Method getAccessDefinitions(cCod as Character) class AccessDefinitionsProtheusData
    
    Local aArea         As Array
    Local aValid        As Array
    Local aUsrGrp       As Array    
    Local aConfigs      As Array
    Local aJsonRet      As Array
    
    Local jAccessDef    As JSON
    Local jConfig       As JSON

    Local cWhere        As Character
    Local cAliasTmp     As Character
    Local cCode         As Character
    Local cDesc         As Character
    Local cCodOld       As Character
    Local cType         As Character
    Local cStatus       As Character

    Local lHeaderOK     As Logical

    cWhere      := ""
    lHeaderOK   := .F.
    cCode       := ""
    cDesc       := ""
    cType       := ""
    cStatus     := ""
    
    aJsonRet := {}
    aValid   := {}
    aUsrGrp  := {}
    aArea    := GetArea()
    
    aValid := ::validAccessDefinitions()

    If aValid[1]       

        If !Empty(cCod)            
            cWhere := " QLM_CODIGO = '" + cCod + "' AND "
        EndIf

        cWhere	:= "%" + cWhere + "%"

        cAliasTmp    := GetNextAlias()

        BeginSql Alias cAliasTmp  
            SELECT
                QLM_CODIGO, QLM_DESCRI, QLM_TIPO, QLM_USRGRP, QLM_STATUS, QLM_CONFIG 
                FROM 
                    %TABLE:QLM% (NOLOCK) QLM
                    WHERE 
                        QLM_FILIAL = %xFilial:QLM% AND
                        %Exp:cWhere%
                        %notdel%
        EndSql

        cCodOld := ""
        While (cAliasTmp)->(!EOF())

            If Empty(cCodOld)
                cCodOld := (cAliasTmp)->QLM_CODIGO
            EndIf

            If cCodOld <> (cAliasTmp)->QLM_CODIGO
                cCodOld := (cAliasTmp)->QLM_CODIGO
                
                aAdd(aJsonRet,JsonObject():New())
                nLinJson := Len(aJsonRet)                                
                aJsonRet[nLinJson]["code"]          := cCode
                aJsonRet[nLinJson]["description"]   := cDesc
                aJsonRet[nLinJson]["type"]          := cType
                aJsonRet[nLinJson]["status"]        := cStatus
                aJsonRet[nLinJson]["usrgrp"]        := ::returnAsJson(aUsrGrp, 'usrgrp', cType)        
                aJsonRet[nLinJson]["configs"]       := ::returnAsJson(jConfig['configs'], 'config') 
                
                aUsrGrp := {}
                jConfig := Nil                
            EndIf            
            
            cCode   := (cAliasTmp)->QLM_CODIGO
            cDesc   := (cAliasTmp)->QLM_DESCRI
            cType   := (cAliasTmp)->QLM_TIPO
            cStatus := (cAliasTmp)->QLM_STATUS

            If jConfig == Nil .And. !Empty((cAliasTmp)->QLM_CONFIG)
                jConfig  := JsonObject():New()                            
                jConfig:FromJson((cAliasTmp)->QLM_CONFIG)
            EndIf

            aAdd(aUsrGrp, (cAliasTmp)->QLM_USRGRP)

            (cAliasTmp)->(dbSkip())
        EndDo

        If !Empty(cCodOld)
            aAdd(aJsonRet,JsonObject():New())
            nLinJson := Len(aJsonRet)                                
            aJsonRet[nLinJson]["code"]          := cCode
            aJsonRet[nLinJson]["description"]   := cDesc
            aJsonRet[nLinJson]["type"]          := cType
            aJsonRet[nLinJson]["status"]        := cStatus
            aJsonRet[nLinJson]["usrgrp"]        := ::returnAsJson(aUsrGrp, 'usrgrp', cType)        
            aJsonRet[nLinJson]["configs"]       := ::returnAsJson(jConfig['configs'], 'config')

            jAccessDef := JsonObject():New() 

            If Empty(cCod)
                jAccessDef['items'] := aJsonRet            
            Else
                jAccessDef := aJsonRet[Len(aJsonRet)]
            EndIf
        
            aValid[2] := jAccessDef:toJson() 
        EndIf

    EndIf

    RestArea(aArea)
    FwFreeArray(aArea)
    FwFreeArray(aUsrGrp)
    FwFreeArray(aConfigs)
    
Return aValid

/*/{Protheus.doc} returnAsJson
    Método recebe um array com os itens a serem retornados em formato JSON
    @author Totvs
    @since 05/04/2022
    @version 12.1.33
/*/
Method returnAsJson(aArray, cList, cType) class AccessDefinitionsProtheusData
    Local JReturn := JsonObject():New()
    Local cJson   := ""
    Local nI      := 0
    Local uRet

    DEFAULT cType := ""
    
    If cType == "2"
        For nI := 1 to Len(aArray)
            If Empty(cJson)
                cJson += '{"items":[{"value": "' + aArray[nI] + '","label": "' + AllTrim(PswChave(aArray[nI])) + '"}' 
            Else
                cJson += ',' + '{"value":"' + aArray[nI] + '","label":"' + AllTrim(PswChave(aArray[nI])) + '"}'
            EndIf
        Next nI
    ElseIf cType == "1"
        For nI := 1 to Len(aArray)
            If Empty(cJson)
                cJson += '{"items":[{"value":"' + aArray[nI] + '","label": "' + AllTrim(GrpRetName(aArray[nI])) + '"}'
            Else
                cJson += ',' + '{"value":"' + aArray[nI] + '", "label":"' + AllTrim(GrpRetName(aArray[nI])) + '"}'
            EndIf
        Next nI
    ElseIf cList == 'config'
        For nI := 1 to Len(aArray)
            If Empty(cJson)
                cJson += '{"items":[{"value":"' + aArray[nI] + '", "label": "'+ AllTrim(getConfigName(aArray[nI])) +'"}'
            Else
                cJson += ',' + '{"value":"' + aArray[nI] + '", "label": "'+ AllTrim(getConfigName(aArray[nI])) +'"}'
            EndIf
        Next nI
    EndIF

    IIF(!Empty(cJson), cJson += ']}', cJson := '{"items":[]}' )

    uRet := jReturn:FromJson(cJson)
Return jReturn["items"]

/*/{Protheus.doc} getConfigName
    Função que retorna o nome da QLB
    @author Totvs
    @since 05/04/2022
    @version 12.1.33
/*/
Static Function getConfigName(cCodCfg as Character)
    Local cCfgName as Character
    cCfgName := ""

    If (QLB->(dbSeek(xFilial("QLB")+cCodCfg)))
       cCfgName := QLB->QLB_DESCFG 
    EndIf

Return cCfgName

