#include "tlpp-core.th"

namespace totvs.protheus.backoffice.reconciliation.lookup
using namespace totvs.protheus.backoffice.reconciliation.util

//-------------------------------------------------------------------
/*/{Protheus.doc} LookUpProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class LookUpProtheusData from FWAdapterBaseV2
    Public method new()
    Public method getAll()
    Public data aGetStruct as Array
    Public data aChave as Array
    Public data cValor as Character
    Static method getData() As object
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} LookUpProtheusData
Metodo construtor

@author Totvs
/*/
//-------------------------------------------------------------------
method new(cVerbo as Character, lList as Logical) Class LookUpProtheusData
    Default cVerbo := "GET"
    Default lList  := .T.
    _Super:New(cVerbo, lList)
    
    //Liberado em LIB superior a 20230127 manter ate final do release 2210
    If MethIsMemberOf( self, "setUseSpaces", .T. ) 
		::setUseSpaces(.T.)
	Endif
return

//-------------------------------------------------------------------
/*/{Protheus.doc} LookUpProtheusData
Método para chamada e validação do tratamento de dados

@author Totvs
/*/
//-------------------------------------------------------------------
method getData() class LookUpProtheusData As Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := LookUpProtheusData():new()
    EndIf
return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} getAll
Metodo responsável pela busca das configuracoes do conciliador

@author Totvs
/*/
//-------------------------------------------------------------------
method getAll(cTable as Character,aFilters as Array, nPage as Numeric, nPageSize as Numeric, cSearch as Character) class LookUpProtheusData
    Local aArea   := GetArea() as Array
    Local cWhere  := ""        as Character
    Local nX      := 0         as Numeric
    Local cAlias  := ""        as Character
    Local aFields := {}        as Array
    
    Default cTable := ""
    Default nPage     := 1
    Default nPageSize := 10

    cAlias := cTable
    cTable := getTable(cTable)
    If !Empty(cTable)
        cWhere := ' AND '+ GetBranchiesForConditional(cTable)

        //Aplica filtros
        If !Empty(aFilters)
            ::SetUrlFilter(aFilters)
        EndIf        
        
        aFields := getFields(cAlias)
        If Len(aFields) > 0
            ::aChave := aFields
        Else
            ::aChave := FWSX3Util():GetAllFields( cTable , .F. )
        EndIf
        addFields(self, cTable)

        If !Empty(cSearch)
            cWhere += ' AND ('
            For nX := 2 to Len(::aChave)
                If nX > 2
                    cWhere += ' OR '
                Endif
                cWhere += Upper(::aChave[nX]) + " LIKE '%"+ cSearch + "%'" 
            Next
            cWhere += ')'
        Endif 

        cWhere += getWhere(cAlias)
        ::setPage(nPage)
        ::setPageSize(nPageSize)
        ::SetQuery(getQuery(cTable))

        ::SetWhere(cWhere)
        ::SetOrder((cTable)->(StrTran(IndexKey(1),"+",",")))

        If ::Execute()
            ::FillGetResponse()
        EndIf
    Endif
    RestArea(aArea)
    FwFreeArray(aArea)
return


//-------------------------------------------------------------------
/*/
{Protheus.doc} addFields
adiconar os campos que serão utilizados na query e retorno do objeto

@Input  oSelf As Object, oSelf
        fields as Array, campos para retorno
        cTable as Character, tabela
        fieldStruct as Array, array para retorno do struct da api
        allFields as Logical as Array, array para retorno do struct da api

@author Alison Kaique
@since mar|2021
/*/
//-------------------------------------------------------------------
Static Function addFields(oSelf as Object, cTable as Character)
    Local cX3Title                                as Character
    Local cX3Descri                               as Character
    Local nItem                                   as Numeric
    Local aStruct                                 as Array
    Local cModeAccess                             as Character
    Local aFieldStruct := {}                      as Array
    Local jObject      := JsonObject():New()      as Json
    Local cUpperField  := ""                      as Character
    Local cField       := ""                      as Character
    Local cIndexTable  := (cTable)->(IndexKey(1)) as Character
    Local nLen         := 5                       as Numeric
    
    cModeAccess := FWModeAccess(cTable, 1) // COMPARTILHAMENTO EMPRESA
    oSelf:cValor := NIL

    // adiciona os campos enviados
    For nItem := 1 To nLen //Len(oSelf:aChave)
        cX3Title := AllTrim(FwX3Titulo(oSelf:aChave[nItem]))
        cX3Descri := AllTrim(FWSX3Util():GetDescription(oSelf:aChave[nItem]))
        aStruct := FWSX3Util():GetFieldStruct(oSelf:aChave[nItem])
        cUpperField := Upper(oSelf:aChave[nItem])
        // Validando compartilhamento de tabela
        If (( cModeAccess=='C' .AND. !('_FILIAL' $ cUpperField)) .OR. !cModeAccess=='C' )  
            If oSelf:aChave[nItem] $ cIndexTable .or. (("DESC" $ oSelf:aChave[nItem] .OR. "NOME" $ oSelf:aChave[nItem]) .and. GetSx3Cache(oSelf:aChave[nItem], "X3_BROWSE") == 'S')
                oSelf:AddMapFields(oSelf:aChave[nItem], oSelf:aChave[nItem], .T., .F., {oSelf:aChave[nItem], aStruct[2], aStruct[3], aStruct[4]})
                jObject := JsonObject():new()
                cField := lower(oSelf:aChave[nItem])
                jObject:fromJson('{"field":"'+ cField +'","title":"'+ cX3Title+'" }')
                aAdd(aFieldStruct, jObject)
                If !cModeAccess=='C' .and. !('_FILIAL' $ cUpperField) .and. Empty(oSelf:cValor)
                    oSelf:cValor := cField
                Endif
            Endif
        EndIf
    Next
    oSelf:aGetStruct := aFieldStruct

Return 

//-------------------------------------------------------------------
/*/{Protheus.doc} getQuery
Realiza a query para busca de informações

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getQuery(cTable As Character) As Character
    Local cQuery := "" As Character

    cQuery := " SELECT #QueryFields# "
    cQuery += " FROM " + RetSqlName(cTable) + " " + cTable
    cQuery += " WHERE  " + cTable + ".D_E_L_E_T_ = ' ' "
    cQuery += " #QueryWhere# "

Return cQuery


//-------------------------------------------------------------------
/*/{Protheus.doc} getFields
    Obtém os campos a serem apresentados na consulta do lookup

@author Totvs
/*/
//-------------------------------------------------------------------
Function getFields(cConsulta)
    Local aCampos := {} as Array

    Default cConsulta := ""

    Do Case
        Case cConsulta == "SA6001"
            aCampos := {"A6_FILIAL", "A6_COD", "A6_AGENCIA", "A6_NUMCON", "A6_NOME"}
    ENDCASE

Return aCampos

//-------------------------------------------------------------------
/*/{Protheus.doc} getWhere
    Obtém where da query da consulta para lookup

@author Totvs
/*/
//-------------------------------------------------------------------
Function getWhere(cConsulta)
    Local cWhere := "" as Character
    
    Default cConsulta := ""

    Do Case
        Case cConsulta == "SA6001"
            cWhere := " AND ((SA6.A6_BLOCKED = '2') OR (SA6.A6_DTBLOQ = ' ') OR (SA6.A6_BLOCKED = '1' AND SA6.A6_DTBLOQ > '" + DTOS(dDataBase) + "') "
            If SA6->(ColumnPos("A6_MSBLQL")) > 0
                cWhere += " OR (A6_MSBLQL = '2' ) )"
            Else
                cWhere += " )"
            Endif
    ENDCASE

Return cWhere

//-------------------------------------------------------------------
/*/{Protheus.doc} getTable
    Obtém a tabela a ser demonstrado no Lookup de acordo com a 
    consulta configurada

@author Totvs
/*/
//-------------------------------------------------------------------
Function getTable(cConsulta)
    Local cTable := cConsulta as Character
    Do Case
        Case cConsulta == "SA6001"
            cTable := "SA6"
    ENDCASE

Return cTable
