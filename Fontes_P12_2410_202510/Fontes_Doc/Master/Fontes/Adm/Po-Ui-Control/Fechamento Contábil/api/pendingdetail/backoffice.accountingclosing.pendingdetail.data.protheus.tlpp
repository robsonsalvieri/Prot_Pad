#include "tlpp-core.th"

namespace totvs.protheus.backoffice.accountingclosing.pendingdetail
using namespace totvs.protheus.backoffice.accountingclosing.util
using namespace totvs.protheus.backoffice.reconciliation.util

//-------------------------------------------------------------------
/*/{Protheus.doc} PendingDetailProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class PendingDetailProtheusData from FWAdapterBaseV2
    Public method new()
    Public method getAll()
    Public method getType3()
    static method getData() As object
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} PendingDetailProtheusData
Metodo construtor

@author Totvs
/*/
//-------------------------------------------------------------------
method new(cVerbo as Character, lList as Logical) Class PendingDetailProtheusData
    Default cVerbo := "GET"
    Default lList  := .T.
    _Super:New(cVerbo, lList)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} PendingDetailProtheusData
Método para chamada e validação do tratamento de dados

@author Totvs
/*/
//-------------------------------------------------------------------
method getData() class PendingDetailProtheusData As Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := PendingDetailProtheusData():new()
    EndIf
return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} getAll
Metodo responsável pela busca dos itens pendentes de integração
cType = 1 - Verifica itens pendentes na tabela QLH 
cType = 2 - Verifica flag na origem

@author Totvs
/*/
//-------------------------------------------------------------------
method getAll(nPage as Numeric, nPageSize as Numeric, aFieldsApi as Array, cModule, cTable as Character,;
    cDateFrom as Character, cDateTo as Character, cType as Character, cResponse as Character) class PendingDetailProtheusData

    cReturn := ::getType3(nPage, nPageSize, aFieldsApi, cModule, cTable, cDateFrom, cDateTo, cResponse)    
return

//-------------------------------------------------------------------
/*/{Protheus.doc} getType2
Metodo responsável pela busca dos itens pendentes de integração de
 acordo com os filtros informados flag na origem

@author Totvs
/*/
//-------------------------------------------------------------------
method getType3(nPage as Numeric, nPageSize as Numeric, aFieldsApi as Array, cModule as Character, cTable as Character,;
                    cDateFrom as Character, cDateTo as Character, cResponse as Character) class PendingDetailProtheusData
    Local aArea     := GetArea() As Array
    Local nI        := 0
    Local cWhere    := "" As Character
    Local cBranches := "" As Character
    Local jTables   := JsonObject():New()
    Local lProgress := .T. as Logical
    Local aStruct   := {}  as Array    
    Local fieldList := {}  as Array
   
    Default nPage     := 1
    Default nPageSize := 10

    QLF->(dbSetOrder(1))
    If QLF->(dbSeek(xFilial("QLF")+cModule)) .And. !Empty(QLF->QLF_ITENS)
        jTables:FromJson(QLF->QLF_ITENS)
    EndIf

    For nI:=1 to Len(jTables['tables'])
        If cTable == jTables['tables'][nI]['alias']
            fieldList := {  jTables['tables'][nI]['flagfield'],;
                            jTables["tables"][nI]["uuidfield"],;
                            jTables["tables"][nI]["datefield"],;
                            jTables["tables"][nI]["branchfield"],;
                            jTables["tables"][nI]["aditionalcondition"]}
            exit
        EndIf
    Next nI

    cBranches := getBranchiesForConditional(cTable, "CTBA960")

    lProgress := ValType(cTable) == "C" .And. !Empty(cTable)
    If lProgress
        cTable := Upper(cTable) // Converte para maiúsculo para evitar problemas com o mapeamento de campos

        //Retorna os campos da tabela
        aStruct := FWSX3Util():GetAllFields(cTable,.F.)

        addMapFields(self,aStruct,aFieldsApi,cTable)

        ::setPage(nPage)
        ::setPageSize(nPageSize)
        ::SetQuery(getQuery(cTable, fieldList[2]))

        cWhere := " "+fieldList[1]+" = ' ' "+;
                  " AND "+cBranches+" "+;
                  " AND "+fieldList[3]+" BETWEEN '"+cDateFrom+"' AND '"+cDateTo+"' "
        cWhere += " "+fieldList[5]+" "  // Condição where adicional
        cWhere += " AND QLI.QLI_FILIAL IS NULL"
        cWhere += " AND "+cTable+".D_E_L_E_T_ = ' ' "

        ::SetWhere(cWhere)
        ::SetOrder(""+fieldList[1]+"")  

        If ::Execute()
            ::FillGetResponse()
        EndIf

        TcRefresh(cTable) // Resetar tempo de timeout
    EndIf

    RestArea(aArea)
    FwFreeArray(aArea)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} addMapFields 
Realiza o mapeamento dos campos que serão retornados

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function addMapFields(oSelf as Object, aStruct as Array, aFieldsApi as Array, cTable as Character)
    Local nI         := 0  As Numeric
    Local cOrdem     := "00" As Character
    Local cTipo      := "" As Character
    Local cWidth     := "" As Character
    Local nTamanho   := 0  As Numeric
    Local nDecimal   := 0  As Numeric   
    Local aStructSX3 := {}  As Array 
      
    For nI := 1 to 15//Len(aStruct)                   
        cField := aStruct[nI]        
        If GetSx3Cache(cField, "X3_BROWSE") == "S"	.And. X3Uso(GetSX3Cache(cField, "X3_USADO"))
            cOrdem  := Soma1(cOrdem)
            aStructSX3 := FWSX3Util():GetFieldStruct(cField) // Retorna um array com os dados da estrutura do campo na SX3
            cTitulo := FWX3Titulo(cField) //Adiciona informacoes do dicionario - SX3 dos campos             
            cTipo   := FWSX3Util():GetFieldType(aStruct[nI]) //Retorna o tipo do campo no SX3  
            nTamTit := Len(AllTrim(FWX3Titulo(cField)))
            nTamanho:= aStructSX3[3]
            nDecimal:= aStructSX3[4]

            oSelf:AddMapFields(cField, cField, .T., .F., {cField, cTipo, nTamanho, nDecimal}, cTable+"."+cField)

            If nTamTit < 10 .And. nTamanho < 10
                //DEFAULT - Tratamento para campos pequenos
                cWidth := "100px"
            Else
                If nTamTit > nTamanho
                    cWidth := CValToChar(nTamTit * 12) + "px"
                Else
                    cWidth := CValToChar(nTamanho * 12) + "px"
                EndIf            
            EndIf                    

            aAdd(aFieldsApi, { cOrdem,;
                            AllTrim(Lower(cField)),;
                            AllTrim(If(Empty(cTitulo), Lower(cField), cTitulo)),;
                            cTipo,;
                            nTamanho,;
                            nDecimal,;
                            AllTrim(X3Picture(cField)),;
                            cWidth}) 
        EndIf
    Next

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} getQuery
Realiza a query para busca de informações

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getQuery(cTable, cCpoId) As Character
    Local cQuery  := "" as Character
    Local cNameDB := Alltrim(TcGetDB()) as Character

	Default cTable := ""
    Default cCpoId := ""
    
    cQuery := " SELECT #QueryFields#"
    cQuery += " FROM " + RetSqlName(cTable) +" "+ cTable
    
    If !Empty(cCpoId)  

        cQuery += " LEFT JOIN "+RetSQLName("QLI")+" QLI ON "
        cQuery += "   QLI_FILIAL = '"+xFilial("QLI")+"' AND "
        cQuery += "   QLI_TABELA = '"+cTable+"' AND "
        
        If cNameDB $ "POSTGRES"
            cQuery += " QLI_UUID = CAST("+cTable+"."+Alltrim(cCpoId)+" AS VARCHAR) AND"
        ElseIf cNameDB $ "ORACLE"        
            cQuery += "RTRIM(QLI_UUID) = COALESCE("+cTable+"."+Alltrim(cCpoId)+", SYS_GUID()) AND"
        Else
            cQuery += "RTRIM(QLI_UUID) = "+cTable+"."+Alltrim(cCpoId)+" AND"
        EndIf
        
        cQuery += "	  QLI.D_E_L_E_T_ = ' ' "

    EndIf

    cQuery += " WHERE #QueryWhere#"
Return cQuery
