
#include 'tlpp-core.th'
#include 'gfin.orders.service.ch'

NAMESPACE gfin.api.orders
USING NAMESPACE gfin.util
USING NAMESPACE totvs.protheus.backoffice.ngf.util

Static __lF76BLQLIB := F76->(FieldPos("F76_BLQLIB")) > 0
Static __oAdvances  As Object
Static __oMinSeq  As Object

Class GfinOrdersService FROM FWAdapterBaseV2
  Public Method new()
  Public Method getOrders()
EndClass

Method new() Class GfinOrdersService
  _Super:new('GET')
  If MethIsMemberOf( self, "setUseSpaces", .T. )
    ::setUseSpaces(.T.)
  Endif
Return Self

//-------------------------------------------------------------------
/*/{Protheus.doc} getOrders
retorna os Pedidos de Venda e Compra

@Input
    tableNick As Character, SC6 ou SC7
    queryRequestParams As Json, parâmetros recebidos

@Return response As Json, retorno da lista de pedidos

@author Alison Kaique
@since mar|2021
/*/
//-------------------------------------------------------------------
Method getOrders(tableNick As Character, queryRequestParams As Json, headers As Json) Class GfinOrdersService
  Local response      as Json
  Local filter        as Array
  Local allFields     as Logical
  Local fields        as Array
  Local struct        as Array
  Local branches      as Array
  Local queryWhere    as Character
  Local cCustomSearch as Character
  Local lBlqLib       as Logical

  cCustomSearch := ''
  If FindFunction("gfin.util.profileToFilter")
    cCustomSearch := gfin.util.profileToFilter(__cUserId, 'NGF', 'CS' + tableNick, 'Filter')
  Endif

  filter    := {}
  fields    := {}
  struct    := {}
  branches  := {}
  allFields := .F.
  lBlqLib   := .F.

  // indica qual página devemos retornar
  If !(Empty(queryRequestParams['page']))
    ::setPage(Val(queryRequestParams['page']))
  EndIf

  // indica o tamanho da página
  If !(Empty(queryRequestParams['pagesize']))
    ::setPageSize(Val(queryRequestParams['pagesize']))
  EndIf

  // indica se considera pedidos bloqueados e não liberados
  If queryRequestParams:hasProperty('blqLib') .And. !(Empty(queryRequestParams['blqLib']))
    lBlqLib := Alltrim(queryRequestParams['blqLib']) == "true"
  EndIf
  // indica a ordem definida por querystring
  ::setOrderQuery(queryRequestParams['order'])

    // indica o filtro querystring recebido (pode se utilizar um filtro oData)
  If !(Empty(queryRequestParams['filter']))
    AAdd(filter, {"FILTER", queryRequestParams['filter']})
    ::SetUrlFilter(filter)
  EndIf
  // trata as filiais encaminhadas no header para o filtro
  If !(Empty(headers['branches']))
    branches := STRtokARR(headers['branches'], ',')
  EndIf

    // Regra para definir os campos para o retorno
    // Se encaminhar allfields lista todos os campos da tabela
  If !(Empty(queryRequestParams['allfields']))
    If ValType(queryRequestParams['allfields']) <> "L"
      If "true" $ queryRequestParams['allfields']
        allFields := .T.
      EndIf
    Else
      allFields := queryRequestParams['allfields']
    EndIf
  EndIf

  If !allFields
    If !(Empty(queryRequestParams['fields']))
      ::SetFields(UPPER(queryRequestParams['fields']))
      fields := apiOrdersFields(tableNick, STRtoArray(::OJSONOBJ:CFIELDS, ','))
    else
      fields := apiOrdersFields(tableNick, {})
    EndIf
    mapFieldsBaseV2(Self, @struct, fields)
  Else
    mapTableFieldsBaseV2(Self, @struct, tableNick, FWModeAccess(tableNick, 1) <> 'C')
    mapTableFieldsBaseV2(Self, @struct, 'F76', FWModeAccess('F76', 1) <> 'C')
    if tableNick == 'SC6'
      mapFieldsBaseV2(Self, @struct, {'C6_NUM'})
    endif
  EndIf

  // Informa a Query a ser utilizada pela API
  ::SetQuery(apiOrdersQuery(tableNick))

  // configura o filtro de query padrão
  queryWhere := " " + tableNick + ".D_E_L_E_T_ = ' ' "
  
  If !Empty(branches)
    If 'SC7' $ tableNick
        queryWhere += "AND SC7.C7_FILIAL IN (" + gfin.util.branchesFormatToIn(branches, tableNick) + ")"
    Else
        queryWhere += "AND SC6.C6_FILIAL IN (" + gfin.util.branchesFormatToIn(branches, tableNick) + ")"
    EndIf
  EndIf

  // Valida pedidos bloqueados
  If !lBlqLib .And. __lF76BLQLIB
    queryWhere += " AND F76.F76_BLQLIB = 1 "
  EndIf

  // filtros personalizados
  If !(Empty(cCustomSearch))
    queryWhere += " AND " + cCustomSearch
  EndIf

  ::SetWhere(queryWhere)

  // Informa a ordenação a ser Utilizada pela Query
  ::SetOrder(apiOrdersOrder(tableNick))

  //Executa a consulta, se retornar .T. tudo ocorreu conforme esperado
  If ::Execute()
    // Gera o arquivo Json com o retorno da Query
    ::FillGetResponse()
  EndIf

  mapFieldsBaseV2(Self, @struct, {'FIE_VALOR'})
  response := JsonObject():New()

  If ::lOk
    response["result"] := .T.
    response["response"] := JsonObject():New()
    response["response"]:FromJson(::getJSONResponse())
    response["response"]["struct"]  := ConfigStructOrders(struct)
    AddAdvances(response["response"]["items"], tableNick == 'SC7')
  Else
    response := answerErrorFormat(::GetCode(), ::GetMessage(), ::GetMessage())
  EndIf

  //faz a desalocação de objetos e arrays utilizados
  ::DeActivate()
Return response

//-------------------------------------------------------------------
/*/{Protheus.doc} ConfigStructOrders
Ajusta o nome da coluna FIE_VALOR

@Input
    struct As Array, SC6 ou SC7
    
@Return jRet As Json, retorno da Struct ajustada

@author Rodrigo Oliveira
@since ago|2023
/*/
//-------------------------------------------------------------------
Static Function ConfigStructOrders(struct As Array) As jSon
  Local jRet  As jSon
  Local nPos  As Numeric

  nPos := 0

  jRet  := gfin.util.arrayToJson(struct)
  
  If ( nPos := aScan(struct, {|x| x[1][2] == 'fie_valor'} ) ) > 0
    jRet[nPos]["title"] := STR0001 //'Vlr Adiantamento'
  EndIf

Return jRet

//-------------------------------------------------------------------
/*/{Protheus.doc} AddAdvances
Adiciona o valor do adiantamento do pedido

@Input
    aAdvance As Array, array com os itens de pedidos
    lSC7 As Logical, .T. se for PC e .F. se PV

@author Rodrigo Oliveira
@since ago|2023
/*/
//-------------------------------------------------------------------
Static Function AddAdvances(aAdvances As Array, lSC7 As Logical)
  Local nQtde As Numeric
  Local nI    As Numeric
  Local nAdv  As Numeric

  nQtde := Len(aAdvances)

  For nI := 1 to nQtde
    aAdvances[nI]['fie_valor'] := 0    
    If lSC7      
      If aAdvances[nI]['f76_seq'] == minSeqOrder(aAdvances[nI]['c7_filial'], aAdvances[nI]['c7_num'], lSC7)
        nAdv                       := VlrAdvance(aAdvances[nI]['c7_filial'], aAdvances[nI]['c7_num'], lSC7)
        aAdvances[nI]['fie_valor'] := Min(aAdvances[nI]['f76_vlorig'], nAdv)
      EndIf
    Else
      If aAdvances[nI]['f76_seq'] == minSeqOrder(aAdvances[nI]['c6_filial'], aAdvances[nI]['c6_num'], lSC7)
        nAdv                       := VlrAdvance(aAdvances[nI]['c6_filial'], aAdvances[nI]['c6_num'], lSC7)
        aAdvances[nI]['fie_valor'] := Min(aAdvances[nI]['f76_vlorig'], nAdv)
      EndIf
    EndIf    
  Next
  
Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} VlrAdvance
Soma o valor dos adiantamentos para cada pedido

@Input
    cFil As Character, Filial do pedido
    cOrder As Character, Número do pedido
    lSC7 As Logical, Indica que o pedido é de compra (.T.)

@author Rodrigo Oliveira
@since ago|2023
/*/
//-------------------------------------------------------------------
Static Function VlrAdvance(cFil As Character, cOrder As Character, lSC7 As Logical) As Numeric
  Local nRet    As Numeric
  Local cQuery  As Character
  
  If __oAdvances == Nil
    cQuery  := "SELECT SUM(FIE_VALOR) ADVANCE "
    cQuery  += " FROM " + RetSQLName("FIE") + " FIE "
    cQuery  += " WHERE FIE_FILIAL = ? "
    cQuery  += " AND FIE.FIE_PEDIDO = ? "
    cQuery  += " AND FIE.FIE_CART = ? "
    cQuery  += " AND FIE.D_E_L_E_T_ =' '"

    cQuery 		  := ChangeQuery(cQuery)
  	__oAdvances := FWPreparedStatement():New(cQuery)
  EndIf

  __oAdvances:SetString(1,FWxFilial("FIE", cFil))
  __oAdvances:SetString(2,cOrder)
  If lSC7
    __oAdvances:SetString(3,'P')
  Else
    __oAdvances:SetString(3,'R')
  EndIf
	
  cQuery := __oAdvances:GetFixQuery()
		
  nRet  := MpSysExecScalar(cQuery, 'ADVANCE')

Return nRet

//-------------------------------------------------------------------
/*/{Protheus.doc} minSeqOrder
Retorna a menor sequencia do pedido na F76 (F76_SEQ).

@Input
    cFil As Character, Filial do pedido
    cOrder As Character, Número do pedido
    lSC7 As Logical, Indica que o pedido é de compra (.T.)

@author Rodrigo Oliveira
@since ago|2023
/*/
//-------------------------------------------------------------------
Static Function minSeqOrder(cFil As Character, cOrder As Character, lSC7 As Logical) As Character
  Local cRet    As Character
  Local cQuery  As Character
  
  If __oMinSeq == Nil
    cQuery  := "SELECT MIN(F76_SEQ) MINSEQ "
    cQuery  += " FROM " + RetSQLName("F76") + " F76 "
    cQuery  += " WHERE F76.F76_FILORI = ? "
    cQuery  += " AND F76.F76_PEDIDO = ? "
    cQuery  += " AND F76.F76_TIPO = ? "
    cQuery  += " AND F76.D_E_L_E_T_ = ' '"

    cQuery 		  := ChangeQuery(cQuery)
  	__oMinSeq := FWPreparedStatement():New(cQuery)
  EndIf

  __oMinSeq:SetString(1,cFil)
  __oMinSeq:SetString(2,cOrder)
  If lSC7
    __oMinSeq:SetString(3,'2')
  Else
    __oMinSeq:SetString(3,'1')
  EndIf
	
  cQuery := __oMinSeq:GetFixQuery()
		
  cRet  := MpSysExecScalar(cQuery, 'MINSEQ')

Return cRet
