#INCLUDE 'tlpp-core.th'
#INCLUDE 'tlpp-rest.th'
#include 'totvs.ch'
#include 'backoffice.gfin.billstechfin.ch'

NAMESPACE totvs.protheus.backoffice.gfin.billstechfin

Static __cErrorF79  As Character

/*/{Protheus.doc} BillsTechfin
  Classe para transmissão de boletos Techfin
  @type class
  @version 12.1.2410
  @author fabio.zanchim
  @since 25/01/2025
/*/
Class BillsTechfin
	// Transmissão
	Data oBody       As Json      // Dados para Transmissão
	Data cError      As Character // Erros
	Data cResult     As Character // Resultado
	// Configurações SYS_APP_PARAM
	Data cTenant     As Character
	Data cUser       As Character
	Data cPass       As Character
	Data cPosId      As Character
	Data cExtBusId   As Character
	Data cBusId      As Character
	// Dados para conexão
	Data cClientID   As Character
	Data cCliSecret  As Character
	Data cUrlRaas    As Character
	Data cUrlRAC     As Character
	Data cEnvHomolog As Character
	//-- Controle do token
	Data cToken      As Character
	Data cTimeExpi   As Character
	Data dExpDate    As Date

	Public Method new()        As Object    // Novo
	Public Method send()       As Logical   // Transmitir
    Public Method patch()       As Logical   // Alteração do boleto
    Public Method sendCanc()   As Logical   // Cancelamento do boleto
	Public Method getError()   As Character // Mensagem do erro
	Public Method getResult()  As Character // Retorna o resultado da transmissão
	Public Method loadConfig()
  	Public Method setBody()
	Public Method loadSysAppParam()                  // Retorna dados das credenciais
	Public Method validateCredentials() As Logical   // Validação das Credenciais
	Public Method getBillsPdf()         As Character // Retorna o Boleto em PDF
	Public Method getSettlement()       As Logical   // Retorna os dados para concilicação (baixa dos títulos)
	Public Method formatEmailTechFin()  As Object    // Retorna os dados que serão utilizados no corpo do e-mail
	//Geração/Manutenão do Token.
	Private Method getToken()         As Character
	Private Method expirationDate()
	Private Method outOfDate()        As Logical
    Private Method catchRestError()   As Character //Captura e trata erros do Rest
    Private Method processaBaixaSE1()
    Private Method gravaF79()
    Private Method gravaF7A()
    Private Method setParamRecurrence()
	Private Method setResponse() As Character

EndClass

/*/{Protheus.doc} BillsTechfin::new
  Método para criação da instância da classe
  @type method
  @version 12.1.2410
  @author fabio.zanchim
  @since 08/02/2025  
/*/
Method new() Class BillsTechfin
Return Self

/*/{Protheus.doc} BillsTechfin::getError
  Método para obter a mensagem de erro
  @type method
  @version 12.1.2410
  @author fabio.zanchim
  @since 08/02/2025  
  @return character, messagem de erro
/*/
Method getError() Class BillsTechfin As Character
Return ::cError

/*/{Protheus.doc} BillsTechfin::catchRestError
    Metodo que seta erro originado pela integração através do objeto FwRest.

    @type       Method
    @author     fabio.zanchim
    @since      06/02/2025
    @version    12.1.2410
    @param      oRest, object, classe FwRest
    @return     character, mensagem de erro da execução de integração
/*/
Method catchRestError( oRest As Object ) As Character Class BillsTechfin
    Local cErrorMsg As Character
    
    Default oRest := Nil

    cErrorMsg := ""

    If oRest != Nil
        cErrorMsg := oRest:GetHTTPCode()
        
        If !(Empty(oRest:cResult))
            cErrorMsg += CRLF + STR0004 + oRest:cResult // "Retorno da API: "
        EndIf
        
        cErrorMsg += CRLF + STR0005 + oRest:GetLastError() // "ERROR: "
    EndIf

Return cErrorMsg

/*/{Protheus.doc} BillsTechfin::getResult
  Método para obter o resultado
  @type method
  @version 12.1.2410
  @author fabio.zanchim
  @since 08/02/2025  
  @return character, resultado da transmissão
/*/
Method getResult() Class BillsTechfin As Character
Return ::cResult

/*/{Protheus.doc} BillsTechfin::send
  Método para transmissão de boletos
  @type method
  @version  12.1.2410
  @author fabio.zanchim
  @since 10/02/2025
  @return logical, transmissão realizada com sucesso (.T. - Sim, .F. - Não)
/*/
Method send() Class BillsTechfin As Logical

	Local lResponse   := .F. As Logical
	Local cBodyPost   := ""	 As Character
	Local oPostBolPix 		 As Object
	Local oBolPixRet  		 As Object
	Local aHeadStr    := {}  As Array
	Local nX		  := 0   As Numeric
	Local nLimit	  := 5   As Numeric
	
	For nX := 1 To nLimit
		aHeadStr  := {}
		::cError  := ""

		AAdd(aHeadStr, "Content-Type: application/json")
		AAdd(aHeadStr, "Authorization: Bearer " + Self:GetToken())

		oBolPixRet  := JSONObject():New()
		oPostBolPix := FwRest():New(Self:cUrlRaas)
		cBodyPost   := EncodeUTF8( FwJsonSerialize( self:oBody ) )
		oPostBolPix:SetPath("/pay-hub/transacting/api/v3/payment/bolepix")
		oPostBolPix:SetPostParams( cBodyPost )

		If oPostBolPix:Post(aHeadStr)
			::cResult := oPostBolPix:getResult()
			lResponse := .T.
			Exit
		Else
			::cError := Self:catchRestError(oPostBolPix)
			Sleep(1500)			
		EndIf
	Next

	oBolPixRet:FromJSON( "{}" )
	ASize( aHeadStr, 0 )
	FwFreeArray( aHeadStr )
	FwFreeObj( oPostBolPix )
	FwFreeObj( oBolPixRet )

Return lResponse

/*/{Protheus.doc} BillsTechfin::loadSysAppParam
  Método para buscar os valores da SYS_APP_PARAM utilizados para a conexão
  @type method
  @version  12.1.2410
  @author fabio.zanchim
  @since 10/02/2025
/*/
Method loadSysAppParam() Class BillsTechfin

	Local oConfig    As Object
	Local cChaveConf As Character

	oConfig    := FwTFConfig()
	cChaveConf := cEmpAnt + Alltrim( cFilAnt )
	//-- Configuração de autenticação/conexão
	If ValType(self:cTenant := oConfig["fin_tenant_techfin_" + cChaveConf]) == "U"
		Self:cTenant := ""
	EndIf

	If ValType(self:cUser := oConfig["fin_user_techfin_" + cChaveConf]) == "U"
		Self:cUser := ""
	EndIf

	If ValType(self:cPass := oConfig["fin_password_techfin_" + cChaveConf]) == "U"
		Self:cPass := ""
	EndIf

	If ValType(self:cPosId := oConfig["fin_idpos_techfin_" + cChaveConf]) == "U"
		Self:cPosId := ""
	EndIf

	If ValType(self:cExtBusId := oConfig["fin_extBusId_techfin_" + cChaveConf]) == "U"
		Self:cExtBusId := ""
	EndIf

	If ValType(self:cBusId := oConfig["fin_busId_techfin_" + cChaveConf]) == "U"
		Self:cBusId := ""
	EndIF

  	If Empty(self:cUser) .Or. Empty(self:cPass) .Or. Empty(self:cTenant) .Or. Empty(self:cExtBusId) .Or. Empty(self:cPosId)
		Self:cError := STR0015 //"Configurações de conexão inválidas (SYS_APP_PARARM)"
	EndIF

	FreeObj(oConfig)

Return

/*/{Protheus.doc} BillsTechfin::loadConfig
  Carrega configuraçãoes utilzados na transmissão do boleto
  @type method
  @version  12.1.2410
  @author fabio.zanchim
  @since 10/02/2025
/*/
Method loadConfig( lLoadSAParam As Logical ) Class BillsTechfin

Default lLoadSAParam := .T.

	If lLoadSAParam
		Self:loadSysAppParam()
	EndIf
	::cEnvHomolog := GetSrvProfString("FinPixHomologacao", "")
	::cUrlRAC     := GetSrvProfString("fw-tf-rac-endpoint", "")
	::cUrlRaas    := GetSrvProfString("fw-tf-raas-endpoint", "")
	//-- ClientID e ClientSecret
	::cClientId   := 'totvs_pagamento_digital_protheus_ro'
	If ::cEnvHomolog == "1"
		::cCliSecret := "39f56c0d-1a0d-48e9-94de-eb32f4e8877c"
	Else
		::cCliSecret := "2fbdf0a3-8777-4045-8503-031bcae6af1e"
	EndIF

Return

/*/{Protheus.doc} BillsTechfin::setBody
  Método para definir os dados para a transmissão
  @type method
  @version  12.1.2410
  @author fabio.zanchim
  @since 10/02/2025
  @param jSonNGF, Json, parametrização do leiaute dentro do NGF
  @param lAltera, logical, define o envio de alteração do boleto híbrido
/*/
Method setBody(jSonNGF As Json, lAltera As Logical) Class BillsTechfin

	Local jJsonTF           As Json
	Local jFixedDate        As Json
	Local cInterestModality As Character
	Local cValueInterest    As Character
	Local cFineModality     As Character
	Local cValueFine        As Character
	Local cModality         As Character
	Local cVlrPercDiscount  As Character
	Local cChavePix         As Character
	Local cChaveBanco       As Character
	Local cWallet           As Character

	DEFAULT lAltera	:= .F.

	cChavePix   := ""
	cWallet     := "pix"
	cChaveBanco := xFilial( "F70" ) + SA6->A6_COD + SA6->A6_AGENCIA + SA6->A6_DVAGE + SA6->A6_NUMCON + SA6->A6_DVCTA
	F70->( DbSetOrder( 1 ) ) // F70_FILIAL + F70_COD + F70_AGENCI + F70_DVAGE + F70_NUMCON + F70_DVCTA
	If F70->( MsSeek( cChaveBanco ) )
		While cChaveBanco == F70->F70_FILIAL + F70->F70_COD + F70->F70_AGENCI + F70->F70_DVAGE + F70->F70_NUMCON + F70->F70_DVCTA
			If F70->F70_ACTIVE == "1"
				cChavePix := AllTrim( F70->F70_CHVPIX )
				Exit
			EndIf
			F70->( DbSkip() )
		EndDo
	EndIf
		
	jJsonTF := JsonObject():New()
	If lAltera
		//-- Vencimento
		jJsonTF['due'] := JsonObject():New()
		jJsonTF['due']['dueDate'] := jSonNGF['boleto']['titulo']['dataVencimento']
		If !Empty(jSonNGF['boleto']['titulo']['diasAposVencimento'])
			jJsonTF['due']['dayValidAfterDue'] := jSonNGF['boleto']['titulo']['diasAposVencimento']
		EndIF
	Else
		If self:cEnvHomolog == "1"
			cWallet := 'shipaypagador'
		EndIf
		jJsonTF['externalPosId']		  := Self:cPosId //Nao envia na Aleracao
		jJsonTF['externalBusinessUnitId'] := Self:cExtBusId //Nao envia na Aleracao
		jJsonTF['externalTransactionId']  := SE1->E1_IDCNAB //Nao envia na Aleracao
		jJsonTF['bankSlipClientNumber']   := jSonNGF['titulo']['numTitBenef'] //Nao envia na Aleracao
		jJsonTF['wallet']	              := cWallet //Nao envia na Aleracao
		jJsonTF['currency']               := 'BRL' //Nao envia na Aleracao
		jJsonTF['pixDictKey']             := cChavePix //Nao envia na Aleracao
		jJsonTF['amount'] 				  := jSonNGF['titulo']['valorOriginal']
		jJsonTF['messageToPayer']         := ''
		If !Empty(jSonNGF['titulo']['msgPagador'])
			jJsonTF['messageToPayer'] := jSonNGF['titulo']['msgPagador']
		EndIF
		If !Empty(jSonNGF['protestoNegativacao']['diasNegativacaoAutomatico'])
			jJsonTF['daysToNegativeReport']	:= jSonNGF['protestoNegativacao']['diasNegativacaoAutomatico']
		EndIF
		If !Empty(jSonNGF['protestoNegativacao']['diasProtestoAutomatico'])
			jJsonTF['daysToProtest'] := jSonNGF['protestoNegativacao']['diasProtestoAutomatico']
		EndIf
		//-- Dados do sacado
		jJsonTF['customer'] := JsonObject():New()	
		jJsonTF['customer']['email']			:= ''
		jJsonTF['customer']['locale']			:= 'PT-BR'
		jJsonTF['customer']['ssn']				:= SA1->A1_CGC
		jJsonTF['customer']['name']				:= jSonNGF['pagador']['nome']	
		jJsonTF['customer']['street']			:= jSonNGF['pagador']['logradouro']	
		jJsonTF['customer']['addressComplement']:= SA1->A1_COMPLEM
		jJsonTF['customer']['city']				:= jSonNGF['pagador']['municipio']	
		jJsonTF['customer']['postalCode']		:= jSonNGF['pagador']['cep']	
		jJsonTF['customer']['neighborhood']		:= jSonNGF['pagador']['bairro']
		jJsonTF['customer']['state']			:= jSonNGF['pagador']['uf']
		If AI0->(msSeek(xFilial('AI0') + SA1->A1_COD + SA1->A1_LOJA))
			If AI0->AI0_RECBOL =='1'
				jJsonTF['customer']['email'] := AllTrim( AI0->AI0_EMABOL )
			EndIF
		EndIF				
		//-- Vencimento
		jJsonTF['due'] := JsonObject():New()
		jJsonTF['due']['dueDate'] := jSonNGF['titulo']['dataVencimento']
		If !Empty(jSonNGF['titulo']['diasAposVencimento'])
			jJsonTF['due']['dayValidAfterDue'] := jSonNGF['titulo']['diasAposVencimento']
		EndIF
		// Detalhes de multa, juros, desconto e abatimento (tudo dentro do atributo 'due')
		If !Empty(jSonNGF['titulo']['valorAbatimento']) .Or. !Empty(jSonNGF['jurosMora']['tipo']) .Or. !Empty(jSonNGF['multa']['tipo']) .Or. !Empty(jSonNGF['desconto']['tipo'])
			jJsonTF['due']['amountDetails'] := JsonObject():New()	
			//-- Abatimento
			If !Empty(jSonNGF['titulo']['valorAbatimento'])
				jJsonTF['due']['amountDetails']['rebate']             := JsonObject():New()
				jJsonTF['due']['amountDetails']['rebate']['value']    := jSonNGF['titulo']['valorAbatimento']
				jJsonTF['due']['amountDetails']['rebate']['modality'] := "FixedAmount"
			EndIF
			//-- Juros
			If !Empty(jSonNGF['jurosMora']['tipo'])
				cInterestModality := cValToChar(jSonNGF['jurosMora']['tipo'])
				cValueInterest    := jSonNGF['jurosMora']['valor']
				If !cInterestModality $ "1|5"
					cValueInterest := jSonNGF['jurosMora']['percentual']
				EndIf
				
				jJsonTF['due']['amountDetails']['interest'] := JsonObject():New()
				jJsonTF['due']['amountDetails']['interest']['value'] := cValueInterest
				If cInterestModality == "1"
					jJsonTF['due']['amountDetails']['interest']['modality'] := "AmountCalendarDay" 
				ElseIf cInterestModality == "2"
					jJsonTF['due']['amountDetails']['interest']['modality'] := "PercentagePerCalendarDay"
				ElseIf cInterestModality == "3"
					jJsonTF['due']['amountDetails']['interest']['modality'] := "PercentagePerCalendarMonth"
				ElseIf cInterestModality == "4"
					jJsonTF['due']['amountDetails']['interest']['modality'] := "PercentagePerCalendarYear"
				ElseIf cInterestModality == "5"
					jJsonTF['due']['amountDetails']['interest']['modality'] := "AmountBusinessDay"
				ElseIf cInterestModality == "6"
					jJsonTF['due']['amountDetails']['interest']['modality'] := "PercentagePerBusinessDay"
				ElseIf cInterestModality == "7"
					jJsonTF['due']['amountDetails']['interest']['modality'] := "PercentagePerBusinessMonth"
				ElseIf cInterestModality == "8"
					jJsonTF['due']['amountDetails']['interest']['modality'] := "PercentagePerBusinessYear"
				EndIf
			EndIF
			//-- Multa
			If !Empty(jSonNGF['multa']['tipo'])
				cFineModality := "FixedAmount"
				cValueFine    := jSonNGF['multa']['valor']
				If cValToChar(jSonNGF['multa']['tipo']) == "2"
					cFineModality := "Percentage"
					cValueFine    := jSonNGF['multa']['percentual']
				EndIf
				jJsonTF['due']['amountDetails']['fine']             := JsonObject():New()
				jJsonTF['due']['amountDetails']['fine']['value']    := cValueFine
				jJsonTF['due']['amountDetails']['fine']['modality'] := cFineModality
			EndIF
			//-- Desconto
			If !Empty(jSonNGF['desconto']['tipo'])
				//-- Dependendo do Tipo de desconto direciona pro atributo 'discount' ou 'discountByDay'
				cDiscountModality := cValToChar(jSonNGF['desconto']['tipo'])
				If cDiscountModality $ "1|2" // '1 - Valor Fixo até a[s] data[s] informada[s]' ou '2 - Percentual até a data informada'
					// Descrição Domínio
					// Valor Fixo até a[s] data[s] informada[s] 1 Percentual até a data informada 2
					cModality        := "FixedValueUntilInformedDate"
					cVlrPercDiscount := jSonNGF['desconto']['valor']
					If cDiscountModality == "2"
						cModality        := "PercentageUntilTheDateInformed"
						cVlrPercDiscount := jSonNGF['desconto']['percentual']
					EndIf
					jJsonTF['due']['amountDetails']['discount']              := JsonObject():New()
					jJsonTF['due']['amountDetails']['discount']['modality']  := cModality 
					jJsonTF['due']['amountDetails']['discount']['fixedDate'] := JsonObject():New()

					jFixedDate := JsonObject():New()
					jFixedDate['value']                                      := cVlrPercDiscount
					jFixedDate['date']                                       := jSonNGF['desconto']['dataLimite']
					jJsonTF['due']['amountDetails']['discount']['fixedDate'] := {jFixedDate}
				Else
					// Descrição Domínio
					// Valor por antecipação dia corrido 3 Valor por antecipação dia útil 4 Percentual por antecipação dia corrido 5 Percentual por antecipação dia útil 6
					cVlrPercDiscount := jSonNGF['desconto']['valor']
					If cDiscountModality $ "5|6"
						cVlrPercDiscount := jSonNGF['desconto']['percentual']
					EndIf			
					jJsonTF['due']['amountDetails']['discountByDay'] := JsonObject():New()
					If cDiscountModality == "3"
						jJsonTF['due']['amountDetails']['discountByDay']['modality'] := "AmountInAdvanceCalendarDay"
					ElseIf cDiscountModality == "4"
						jJsonTF['due']['amountDetails']['discountByDay']['modality'] := "AmountInAdvanceBusinessDay"
					ElseIf cDiscountModality == "5"
						jJsonTF['due']['amountDetails']['discountByDay']['modality'] := "PercentageInAdvanceCalendarDay"
					ElseIf cDiscountModality == "6"
						jJsonTF['due']['amountDetails']['discountByDay']['modality'] := "PercentageInAdvanceBusinessDay"
					EndIf
					jJsonTF['due']['amountDetails']['discountByDay']['value'] := cVlrPercDiscount
				EndIf
			EndIf
		EndIf
		If jSonNGF['titulo']:hasProperty('nossoNumero') .And. jSonNGF['titulo']['nossoNumero'] == 2
			jJsonTF['bankSlipId'] := SE1->E1_NUMBCO
		EndIf
	EndIf

	::oBody := jJsonTF

Return

/*/{Protheus.doc} BillsTechfin::getToken
  Metodo responsavel por pegar o token de acesso ao RAC
  @type method
  @version  12.1.2410
  @author fabio.zanchim
  @since 10/02/2025  
  @return cToken, character, token de acesso ao Rac
/*/
Method getToken() As Character Class BillsTechfin

	Local aHeadStr   As Array
	Local cParams    As Character
	Local nTokenExpi As Numeric
	Local oRestClien As Object
	Local oJSON      As Object

	cParams    := ""
	aHeadStr   := {}
	nTokenExpi := 0
	oRestClien := FwRest():New(Self:cURLRAC)
	oJSON      := JSONObject():new()

	If Self:OutOfDate()
		AAdd(aHeadStr, "Content-Type: application/x-www-form-urlencoded")
		AAdd(aHeadStr, "charset: UTF-8")
		AAdd(aHeadStr, "User-Agent: Protheus " + GetBuild())

		cParams := "grant_type=password"
		cParams += "&username=" + Self:cUser
		cParams += "&password=" + Self:cPass
		cParams += "&scope=authorization_api"
		cParams += "&client_id=" + Self:cClientId
		cParams += "&client_secret="+ Self:cCliSecret

		oRestClien:SetPath("/totvs.rac/connect/token")
		oRestClien:SetPostParams(cParams)

		If oRestClien:Post(aHeadStr)
			oJSON:FromJSON(oRestClien:getResult())
			Self:cToken := oJSON["access_token"]      //Chave de acesso
			nTokenExpi  := oJSON["expires_in"] / 60   //Expiração do token em minutos
			Self:expirationDate(nTokenExpi)
		Else
			Self:cToken := ""
			::cError := Self:catchRestError(oRestClien)
		EndIf
	EndIf

	oJSON:FromJSon("{}")
	ASize( aHeadStr, 0 )

	FreeObj(oRestClien)
	FreeObj(oJSON)
	FwFreeArray(aHeadStr)

Return Self:cToken

/*/{Protheus.doc} BillsTechfin::expirationDate
    Controle de expiração do Token

    @type       Method
    @author     Edson Melo
    @since      10/08/2020
    @version    12.1.27
    @param      nTime, Numerico, tempo para conversão
    @param      cTipo, Caracter, tipo da conversão
/*/
Method expirationDate(nTime As Numeric, cTipo As Character) Class BillsTechfin

	Local cTime     As Character
	Local nDias     As Numeric
	Local nHora     As Numeric
	Local cTipoConv As Character

	Default nTime := 1
	Default cTipo := "M"
	//Inicializa variáveis
	cTime     := ""
	nDias     := 0
	nHora     := 0
	cTipoConv := Upper(cTipo)

	nTime := IIf(cTipoConv == "H", (nTime * 60), (nTime / 60))
	cTime := IncTime(Time(),, nTime)
	nHora := Val(SubStr(cTime, 1, 2))

	While nHora > 24
		nHora := nHora - 24
		nDias ++
	EndDo

	Self:cTimeExpi := StrZero(nHora, 2) + SubStr(cTime, 3, Len(cTime))
	Self:dExpDate  := Date() + nDias
Return

/*/{Protheus.doc} BillsTechfin::OutOfDate
    Metodo responsavel verificar se o token esta vencido.

    @type       Method
    @author     Edson Melo/Rafael Riego
    @since      10/08/2020
    @version    12.1.27
    @Return     Logico, Indica se o token esta vencido.
/*/
Method outOfDate() Class BillsTechfin As Logical

	Local lRet  As Logical
	Local dData As Date

	lRet  := .F.
	dData := Date()

	lRet := ((Empty(Self:dExpDate) .And. Empty(Self:cTimeExpi)) .Or.;
		(Self:dExpDate == dData .And. Time() >= Self:cTimeExpi) .Or.;
		(Self:dExpDate < dData))
Return lRet

/*/{Protheus.doc} BillsTechfin::validateCredentials
    Valida o Código Externo da Unidade de Negócio no TOTVS PD.

    @type       Method
    @author     Daniel Moda
    @since      10/03/2025
    @version    12.1.2410
    @param      cExtBusIdValidate, character, Identificador da Unidade de Negócio/Loja.
    @param      cPosIdValidate, character, Identificador do PDV.
    @param      cPDTenant, character, tenant ID.
    @param      cPDUser, character, usuário.
    @param      cPDPss, character, senha.
    @Return     Logico, verdadeiro caso as credenciais sejam validadas
/*/
Method validateCredentials( cExtBusIdValidate As Character, cPosIdValidate As Character, cPDTenant As Character, cPDUser As Character, cPDPss As Character ) As Logical Class BillsTechfin

    Local aHeadStr   As Array
    Local cParams    As Character
    Local cResult    As Character
    Local oJSON      As Object
    Local oJSONExtId As Object
    Local oRestExtId As Object
    Local oRestClien As Object
    Local lResult    As Logical
	Local cBusId     As Character

    ::cTenant   := cPDTenant
	::cPosId    := cPosIdValidate
	::cExtBusId := cExtBusIdValidate
	::cUser     := cPDUser
	::cPass     := cPDPss

	self:loadConfig( .F. )
    aHeadStr := {"Authorization: Bearer " + Self:getToken()}
    cParams  := ""
    cResult  := ""
    lResult  := .F.
	cBusId   := ""
    
    oJSONExtId  := JSONObject():New()
    oRestExtId  := FwRest():New(Self:cUrlRaas)
    oRestExtId:SetPath("/api/pay-hub/configuring/api/v1/business-units/?externalId=" + Self:cExtBusId)
    
    If oRestExtId:Get(aHeadStr)
        cResult := oJSONExtId:FromJSON(oRestExtId:getResult())
        
		If ValType(cResult) == "U" .And. Len(oJSONExtId["items"]) >= 1
			lResult := .T.
			cBusId := oJSONExtId["items"][1]["id"]
        EndIf
    EndIf

	If lResult
		oJSON      := JSONObject():New()
		oRestClien := FwRest():New(Self:cUrlRaas)
		lResult    := .F.

		oRestClien:SetPath("/api/pay-hub/configuring/api/v1/pos/?externalIdValue=" + Self:cPosId + IIf(Empty(cBusId), "", "&businessUnitId=" + cBusId))
		
		If oRestClien:Get(aHeadStr)
			cResult  := oJSON:FromJSON(oRestClien:getResult())
			
			If ValType(cResult) == "U" .And. Len(oJSON["items"]) >= 1
				lResult := .T.
			EndIf
		EndIf

		oJSON:FromJSon("{}")

		FreeObj(oRestClien)
		FreeObj(oJSON)
	EndIf

	ASize( aHeadStr, 0 )
	oJSONExtId:FromJSon("{}")

	FwFreeArray( aHeadStr )
    FreeObj(oRestExtId)
    FreeObj(oJSONExtId)

Return lResult

/*/{Protheus.doc} BillsTechfin::getBillsPdf
  Método para retornar o boleto TechFin na URL informada.
  @type method
  @version  12.1.2410
  @author daniel.moda
  @since 19/03/2025
  @param jBody, Json, objeto com os dados do título para baixa.
  @param cLocal, Character, caminho para a geração do arquivo.
  @param aGetError, Array, erros apresentados durante o processamento.
  @return character, boleto gerado
/*/
Method getBillsPdf( jBody As Json, cLocal As Character, aGetError As Array ) As Character Class BillsTechfin

	Local oGetBills          As Object
	Local aHeader      := {} As Array
	Local aAreaSA1     := {} As Array
	Local cPath        := "" As Character
	Local cURL         := "" As Character
	Local nHandle      := 0  As Numeric
	Local nE1Cliente   := 0  As Numeric
	Local nE1Loja      := 0  As Numeric
	Local cFilePDFTF   := "" As Character
	Local cErrorDetail := "" As Character

	aAreaSA1   := SA1->(GetArea())
	nE1Cliente := TamSX3('E1_CLIENTE')[1]
	nE1Loja    := TamSX3('E1_LOJA')[1]
	cURL       := jBody['pdfUrl']
	oGetBills  := FwRest():New(cURL)
	oGetBills:SetPath(cPath)

	If (oGetBills:Get(aHeader))
		If !Empty(jBody['a6_bcoofi'])
			cFilePDFTF := AllTrim(jBody['a6_bcoofi'])
		Else
			cFilePDFTF := AllTrim(jBody['ea_portado'])
		EndIf
		If SA1->(MsSeek(xFilial("SA1", jBody['ea_filorig']) + PadR(jBody['e1_cliente'], nE1Cliente) + PadR(jBody['e1_loja'], nE1Loja)))
			cFilePDFTF += AllTrim(SA1->A1_CGC)
		EndIf
		cFilePDFTF += StrZero(Randomize(1, 999), 3)
		cFilePDFTF += StrTran(Time(), ':', '') + ".pdf"
		nHandle := FCreate(cLocal + cFilePDFTF)
		FWrite(nHandle, oGetBills:GetResult())
		FClose(nHandle)
	Else
		cErrorDetail := I18N( STR0013, { jBody['ea_filial'] + '|' + jBody['ea_prefixo'] + '|' + jBody['ea_num'] + '|' + jBody['ea_parcela'] + '|' + jBody['ea_tipo'] } ) // "Título: "
		cErrorDetail += CRLF + I18N(STR0007, { oGetBills:GetLastError() } ) // "Erro no processamento: "
		AADD( aGetError, Val(oGetBills:GetHTTPCode()) )
		AADD( aGetError, STR0014 ) // "Falha no download do boleto"
		AADD( aGetError, cErrorDetail )
	EndIf

	RestArea( aAreaSA1 )
	aSize( aHeader, 0 )
	aSize( aAreaSA1, 0 )
	FreeObj( oGetBills )

Return cFilePDFTF

/*/{Protheus.doc} BillsTechfin::getSettlement
  Método para verificar se existem boletos para conciliação.
  @type method
  @version  12.1.2410
  @author daniel.moda
  @since 19/03/2025
  @return logical, transmissão realizada com sucesso (.T. - Sim, .F. - Não)
/*/
Method getSettlement() Class BillsTechfin As Logical

	Local lResponse   As Logical
	Local oGetBolPix  As Object
	Local aHeadStr    As Array
	Local cPath       As Character
	Local aIniUTC     As Array
	Local aFimUTC     As Array
	Local cDtHrParam  As Character
	Local dDataLocal  As Date

	lResponse  := .F.
	aHeadStr   := {}
	aIniUTC    := {}
	aFimUTC    := {}
	dDataLocal := Date()
    cDtHrParam := SuperGetMV("MV_BHTDTHR", .F., "")
    //Caso nenhuma execução tenha sido realizada ainda
    If Empty(cDtHrParam)
		cIniUTC := FwTimeStamp(6, dDataLocal - 10)
	Else
		cDtHrParam := StrTran( cDtHrParam, "-", "" )
		cDtHrParam := StrTran( cDtHrParam, "T", "" )
		aIniUTC    := UTCToLocal( SubStr( cDtHrParam, 1, 8 ), SubStr(cDtHrParam, 9, 8) )
		cIniUTC    := FwTimeStamp(3, SToD(aIniUTC[1]), aIniUTC[2])
    EndIf
	aFimUTC := LocalToUTC(DToS(dDataLocal), Time())
	cFimUTC := FwTimeStamp(3, SToD(aFimUTC[1]), aFimUTC[2])

    cPath := "/pay-hub/reporting/api/v1/settlement"
    cPath += "?externalBusinessUnitId="   + Self:cExtBusId
    cPath += "&startDateMov="             + cIniUTC
    cPath += "&endDateMov="               + cFimUTC
    cPath += "&externalPosId="            + Self:cPosId
	cPath += "&PixModality=2" //Boleto Híbrido
	AAdd(aHeadStr, "Content-Type: application/json")
	AAdd(aHeadStr, "charset: UTF-8")
	AAdd(aHeadStr, "Authorization: Bearer " + Self:GetToken())
	oGetBolPix := FwRest():New(Self:cUrlRaas)
	oGetBolPix:SetPath( cPath )

	If oGetBolPix:Get(aHeadStr)
		::cResult := oGetBolPix:getResult( "transactions" )
		self:processaBaixaSE1()
    	PutMV("MV_BHTDTHR",  FwTimeStamp(6, dDataLocal))
		lResponse := .T.
	Else
		::cError := Self:catchRestError(oGetBolPix)
	EndIf

	aSize( aHeadStr, 0 )
	aSize( aIniUTC, 0 )
	aSize( aFimUTC, 0 ) 

	FwFreeArray( aHeadStr )
	FwFreeArray( aIniUTC )
	FwFreeArray( aFimUTC )
	FwFreeObj( oGetBolPix )

Return lResponse

/*/{Protheus.doc} BillsTechfin::sendCanc
  Método para cancelamento do registro da cobrança
  @type method
  @version  12.1.2410
  @author fabio.zanchim
  @since 20/03/2025
  @return logical, transmissão realizada com sucesso (.T. - Sim, .F. - Não)
/*/
Method sendCanc() Class BillsTechfin As Logical

	Local lResponse  As Logical
	Local oCancBol   As Object
	Local aHeadStr   As Array
    Local jBody      As Json
    Local jSeaApiMsg As Json
    Local cBody      As Character
	
	lResponse := .F.
	aHeadStr  := {}    

    jSeaApiMsg := JSonObject():New()
	jSeaApiMsg:FromJson(FI2->FI2_HISTOR)
    jBody := JSonObject():New()
    jBody['transactionId']          := jSeaApiMsg['response']['transactionId']
    jBody['processorTransactionId'] := jSeaApiMsg['response']['processorTransactionId']
    jBody['externalBusinessUnitId'] := Self:cExtBusId    
    jBody['externalTransactionId']  := jSeaApiMsg['response']['externalTransactionId']
    jBody['amount']                 := cValTochar( jSeaApiMsg['response']['amount'] )
    jBody['externalPosId']          := Self:cPosId
    jBody['currency']               := jSeaApiMsg['response']['currency']

	cBody := EncodeUTF8( FwJsonSerialize(jBody) )

	AAdd(aHeadStr, "Content-Type: application/json")	
	AAdd(aHeadStr, "Authorization: Bearer " + Self:GetToken())	
	oCancBol := FwRest():New(Self:cUrlRaas)
	oCancBol:SetPath( "/pay-hub/transacting/api/v3/payment/refund" )  	
	oCancBol:SetPostParams( cBody )

	If oCancBol:Post(aHeadStr)
		::cResult := oCancBol:getResult()
		lResponse := .T.
	Else
        ::cError := Self:catchRestError(oCancBol)
	EndIf
 	
	ASize( aHeadStr, 0 )
	FwFreeArray( aHeadStr )
	jBody:FromJSON( '{}' )
	FwFreeObj( jBody )
	jSeaApiMsg:FromJSON( '{}' )
	FwFreeObj( jSeaApiMsg )
	FwFreeObj( oCancBol )	

Return lResponse

/*/{Protheus.doc} BillsTechfin::processaBaixaSE1
    Efetua o processamento de um título Boleto Híbrido.
    @type       method
    @author     daniel.moda
    @since      19/03/2025
    @return     logical, retorno verdadeiro em caso de sucesso
/*/
Method processaBaixaSE1() Class BillsTechfin

	Local jTitulo	    := JsonObject():New() As Json
	Local jGravarF7A	:= JsonObject():New() As Json
	Local oTransactions := JsonObject():New() As Object
	Local oLayoutCfgBol := JsonObject():new() As Object
	Local bError							  As CodeBlock
	Local dDataBaixa                          As Date
	Local dDataCred                           As Date
	Local nX			:= 0				  As Numeric
	Local lBaixou		:= .F.				  As Logical
	Local cFilbkp		:= cFilAnt 			  As Character
	Local cF7ANum		:= ''	 			  As Character
	Local nTotalBoletos := 0                  As Numeric
	Local aAreaSA6      := {}                 As Array
	Local aBaixaSE1     := {}                 As Array
	Local cHistoricoBx  := STR0008            As Character
	Local cBanco        := ""                 As Character
	Local cAgencia      := ""                 As Character
	Local cConta        := ""                 As Character
	Local lAtuF79       := .F.                As Logical

	Private lMsErroAuto    := .F. As Logical
	Private lMsHelpAuto    := .T. As Logical
	Private lAutoErrNoFile := .T. As Logical

	aAreaSA6 := SA6->( GetArea() )
	bError   := Errorblock({|e| errorF79(e), Break(e) })
	oTransactions:FromJSON( ::cResult )

	SA6->( DbSetOrder(01) ) // A6_FILIAL + A6_COD + A6_AGENCIA + A6_NUMCON
	F79->( DbSetOrder(01) ) // F79_FILIAL + F79_BANCO + F79_AGENCI + F79_CONTA + F79_DTPROC
	F7A->( DbSetOrder(02) ) // F7A_FILIAL + F7A_PREFIX + F7A_NUMERO + F7A_PARCEL + F7A_TIPO + F7A_CLIENT + F7A_LOJA

	If oTransactions:hasProperty('transactions')
		cF7ANum       := Space(Len(F7A->F7A_NUMERO))
		nTotalBoletos := Len(oTransactions['transactions'])

		For nX := 01 To nTotalBoletos
			jTitulo      := oTransactions['transactions'][nX]
			cHistoricoBx := STR0008 // "Baixa por processo automático (On-Line)"
			lBaixou	     := .F.
			aBaixaSE1    := {}

			If !Empty(jTitulo['paymentDate']) .And. FINA715SE1( jTitulo['externalTransactionId'] )
				BEGIN SEQUENCE
					SA6->( MsSeek( FWxFilial('SA6') + SE1->E1_PORTADO + SE1->E1_AGEDEP + SE1->E1_CONTA ) )
					cBanco   := SA6->A6_COD
					cAgencia := SA6->A6_AGENCIA
					cConta   := SA6->A6_NUMCON
					self:gravaF79(cBanco, cAgencia, cConta, nTotalBoletos)

					jGravarF7A['filial']		 := F79->F79_FILIAL
					jGravarF7A['codigo']         := F79->F79_CODIGO
					jGravarF7A['filori']		 := SE1->E1_FILORIG
					jGravarF7A['prefixo']		 := SE1->E1_PREFIXO
					jGravarF7A['numero']		 := SE1->E1_NUM
					jGravarF7A['parcela']		 := SE1->E1_PARCELA
					jGravarF7A['tipo']			 := SE1->E1_TIPO
					jGravarF7A['cliente']		 := SE1->E1_CLIENTE
					jGravarF7A['loja']			 := SE1->E1_LOJA
					jGravarF7A['emissao']		 := SE1->E1_EMISSAO
					jGravarF7A['valor']			 := SE1->E1_VALOR
					jGravarF7A['bordero']		 := SE1->E1_NUMBOR
					jGravarF7A['status']		 := "1"  // 1 = Pendente ; 2 = Resolvido
					jGravarF7A['estadocobranca'] := 6 // Liquidação
					jGravarF7A['consultaTitulo'] := jTitulo
					If jTitulo['amount']:hasProperty('discountPaid')
						jGravarF7A['multa']	   := jTitulo['amount']['finePaid']
						jGravarF7A['desconto'] := jTitulo['amount']['discountPaid']
						jGravarF7A['juros']	   := jTitulo['amount']['interestPaid']
					EndIf
					cFilAnt := SE1->E1_FILORIG
					If SE1->E1_SALDO > 0
						lMsErroAuto := .F.
						dDataBaixa  := FwDateTimeToLocal(jTitulo["paymentDate"])[1]
						dDataCred   := dDataBaixa
						oLayoutCfgBol:FromJSON( SA6->A6_CFGBOL )
						If oLayoutCfgBol:HasProperty('retornoBancario')
							Self:setParamRecurrence( oLayoutCfgBol )
							cHistoricoBx := oLayoutCfgBol['retornoBancario']['historicoBaixa']
						EndIf
						AAdd(aBaixaSE1, { "E1_PREFIXO"  , PadR(SE1->E1_PREFIXO, TamSX3("E1_PREFIXO")[1]), Nil })
						AAdd(aBaixaSE1, { "E1_NUM"      , PadR(SE1->E1_NUM    , TamSX3("E1_NUM")[1])    , Nil })
						AAdd(aBaixaSE1, { "E1_PARCELA"  , PadR(SE1->E1_PARCELA, TamSX3("E1_PARCELA")[1]), Nil })
						AAdd(aBaixaSE1, { "E1_TIPO"     , PadR(SE1->E1_TIPO   , TamSX3("E1_TIPO")[1])   , Nil })
						AAdd(aBaixaSE1, { "E1_CLIENTE"  , PadR(SE1->E1_CLIENTE, TamSX3("E1_CLIENTE")[1]), Nil })
						AAdd(aBaixaSE1, { "E1_LOJA"     , PadR(SE1->E1_LOJA   , TamSX3("E1_LOJA")[1])   , Nil })
						AAdd(aBaixaSE1, { "AUTHIST"     , cHistoricoBx, Nil })
						AAdd(aBaixaSE1, { "AUTMOTBX"    , "NOR"       , Nil })
						AAdd(aBaixaSE1, { "AUTDTBAIXA"  , dDataBaixa  , Nil })
						AAdd(aBaixaSE1, { "AUTDTCREDITO", dDataCred   , Nil })
						If jTitulo['amount']:hasProperty('discountPaid')
							AAdd(aBaixaSE1, { "AUTDESCONT", jTitulo['amount']['discountPaid'], Nil,	.T.}) // Desconto
							AAdd(aBaixaSE1, { "AUTMULTA"  , jTitulo['amount']['finePaid'] 	 , Nil,	.T.}) // Multa
							AAdd(aBaixaSE1, { "AUTJUROS"  , jTitulo['amount']['interestPaid'], Nil,	.T.}) // Juros
						EndIf
						AAdd(aBaixaSE1, { "AUTVALREC" , jTitulo['amount']['transaction']       , Nil })
						AAdd(aBaixaSE1, { "AUTBANCO"  , PadR(cBanco  , TamSX3("EA_PORTADO")[1]), Nil })
						AAdd(aBaixaSE1, { "AUTAGENCIA", PadR(cAgencia, TamSX3("EA_AGEDEP")[1]) , Nil })
						AAdd(aBaixaSE1, { "AUTCONTA"  , PadR(cConta  , TamSX3("EA_NUMCON")[1]) , Nil })
						AAdd(aBaixaSE1, { "AUTOUTGAS" , 0, Nil })
						AAdd(aBaixaSE1, { "AUTVLRPG"  , 0, Nil })
						AAdd(aBaixaSE1, { "AUTVLRME"  , 0, Nil })

						MSExecAuto({|x,y| Fina070(x,y)}, aBaixaSE1, 3)
						//Em caso de erro na baixa
						If lMsErroAuto
							jGravarF7A['estadocobranca'] := 0
							jGravarF7A['msgexecauto']	 := totvs.protheus.backoffice.ngf.util.GetError()
						Else
							lBaixou := .T.
							jGravarF7A['status']		 := "2"
							jGravarF7A['estadocobranca'] := 6
							jGravarF7A['msgexecauto']	 := ''
						EndIf
						lAtuF79 := Self:gravaF7A(jGravarF7A)
					Else
						// Título baixado por outro meio.
						jGravarF7A['msgexecauto'] := STR0009 // "O título não possui saldo"
						lAtuF79 := Self:gravaF7A(jGravarF7A)
					Endif

					If lAtuF79
						RecLock('F79', .F.)
							F79->F79_QTPROC := cValToChar( Val(F79->F79_QTPROC) + 1 )
							If !lBaixou
								F79->F79_NBAIXA := cValToChar( Val(F79->F79_NBAIXA) + 1 )
							EndIf
						F79->(MsUnlock())
					EndIf
				RECOVER
					// Logar caso ocorra erro no processamento
					jGravarF7A['msgexecauto'] := STR0007 //'Erro no processamento: '
					jGravarF7A['msgexecauto'] += __cErrorF79
					FwLogMsg('ERROR',, "BILLSTECHFIN", "processaBaixaSE1", "", 'ErrorF79', jGravarF7A['msgexecauto'] )
					lAtuF79 := Self:gravaF7A(jGravarF7A, .F.)
					If lAtuF79
						RecLock('F79', .F.)
							F79->F79_QTPROC := cValToChar( Val(F79->F79_QTPROC) + 1 )
							If !lBaixou
								F79->F79_NBAIXA := cValToChar( Val(F79->F79_NBAIXA) + 1 )
							EndIf
						F79->(MsUnlock())
					EndIf
				END SEQUENCE
				ErrorBlock( bError )
			EndIf
		Next nX
	EndIf

	cFilAnt := cFilbkp

	jTitulo:FromJSON( '{}' )
	jGravarF7A:FromJSON( '{}' )
	oTransactions:FromJSON( '{}' )
	oLayoutCfgBol:FromJSON( '{}' )

	RestArea( aAreaSA6 )

	ASize( aBaixaSE1, 0 )
	ASize( aAreaSA6, 0 )

	FwFreeArray( aBaixaSE1 )
	FwFreeArray( aAreaSA6 )
	FwFreeObj( oTransactions )
	FwFreeObj( oLayoutCfgBol )
	FwFreeObj( jTitulo )
	FwFreeObj( jGravarF7A )

Return

/*/{Protheus.doc} ErrorF79

	Bloco executado quando ocorre erro no processamento da F79
	
	@type function
	@version 12.1.2410
	@author daniel.moda
	@since 29/08/2022
	@return Nil
/*/
Static Function ErrorF79(e)

	__cErrorF79 := e:Description + e:ErrorStack

Return

/*/{Protheus.doc} BillsTechfin::gravaF79
  Grava F79 (Log retorno boleto API Cabeçalho)
  @type method
  @version  12.1.2410
  @author daniel.moda
  @since 19/03/2025
  @param cBanco, character, Código do Banco.
  @param cAgencia, character, Código do Banco.
  @param cConta, character, Código do Banco.
  @param nTotalBoletos, numeric, total de títulos do retorno da API.
/*/
Method gravaF79(cBanco As Character, cAgencia As Character, cConta As Character, nTotalBoletos As Numeric) Class BillsTechfin

    If !F79->( MsSeek( xFilial("F79") + cBanco + cAgencia + cConta + DToS( dDataBase ) ) )
		RecLock('F79', .T.)
			F79->F79_FILIAL := xFilial('F79')
			F79->F79_CODIGO := GetSxENum("F79", "F79_CODIGO",,3)
			F79->F79_ESTCOB	:= ''
			F79->F79_BANCO  := cBanco
			F79->F79_AGENCI := cAgencia
			F79->F79_CONTA  := cConta
			F79->F79_DTPROC := Date()
			F79->F79_HRPROC := Time()
			F79->F79_QTDTIT := cValToChar( nTotalBoletos )
			F79->F79_NBAIXA := '0'
			F79->F79_QTPROC := '0'
			F79->F79_RECPAG := 'R'
			F79->F79_JSON   := ::cResult
		F79->(MsUnLock())
		ConfirmSX8()
	EndIf

Return

/*/{Protheus.doc} BillsTechfin::gravaF7A
	Grava F79
	@type method
	@version 12.1.33
	@author daniel.moda
	@since 29/08/2022
	@param jDadosLog - Json - dados a serem gravados
	@param lGrvFull - Logico - define se serão gravados os detalhes do título
/*/
Method gravaF7A( jDadosLog As Json, lGrvFull As Logical ) Class BillsTechfin

	Local lInclui := .F. As Logical

	Default lGrvFull := .T.

	If !F7A->( MsSeek( xFilial( "F7A" ) + jDadosLog['prefixo'] + jDadosLog['numero'] + jDadosLog['parcela'] + jDadosLog['tipo'] + jDadosLog['cliente'] + jDadosLog['loja'] ) )
		lInclui := .T.
	EndIf
	RecLock('F7A', lInclui)
		F7A->F7A_FILIAL := jDadosLog['filial']
		F7A->F7A_CODIGO := jDadosLog['codigo']
		F7A->F7A_NUMERO := jDadosLog['numero']
		F7A->F7A_STATUS := jDadosLog['status']
		F7A->F7A_ERREXE := jDadosLog['msgexecauto']
		F7A->F7A_JSON	:= jDadosLog['consultaTitulo']:ToJson()
		If lGrvFull
			F7A->F7A_PREFIX := jDadosLog['prefixo']
			F7A->F7A_PARCEL := jDadosLog['parcela']
			F7A->F7A_TIPO   := jDadosLog['tipo']
			F7A->F7A_CLIENT := jDadosLog['cliente']
			F7A->F7A_LOJA   := jDadosLog['loja']
			F7A->F7A_BORDER := jDadosLog['bordero']
			F7A->F7A_FILORI := jDadosLog['filori']
			F7A->F7A_EMISSA := jDadosLog['emissao']
			F7A->F7A_VALOR  := jDadosLog['valor']
			F7A->F7A_MULTA  := jDadosLog['multa']
			F7A->F7A_DESCON := jDadosLog['desconto']
			F7A->F7A_JUROS  := jDadosLog['juros']
			F7A->F7A_ESTCOB := StrZero(jDadosLog['estadocobranca'], 2)
		EndIf
	F7A->(MsUnLock())

Return lInclui

/*/{Protheus.doc} BillsTechfin::setParamRecurrence
	Seta as variaveis publicas MV_PAR conforme layout - FINA070.
	@type method
	@version 12.1.2410
	@author daniel.moda
	@since 25/03/2025
	@param jLayout (json) - Layout do banco A6_CFGBOL
	@return Nil
/*/
Method setParamRecurrence(jLayout As Json) Class BillsTechfin

	SetMVValue("FIN070","MV_PAR03",jLayout['retornoBancario']['abateDescontoComissao'])
	SetMVValue("FIN070","MV_PAR04",jLayout['retornoBancario']['contabilizaOnline'])
	SetMVValue("FIN070","MV_PAR05",jLayout['retornoBancario']['consideraJurosComissao'])

	PERGUNTE("FIN070", .F.)

Return

/*/{Protheus.doc} BillsTechfin::formatEmailTechFin
    Carrega as informações no objeto do e-mail
    @type method
    @version 12.1.2410
    @author daniel.moda
    @since 25/03/2025
    @param oAPIMSG, Json, boleto transmitido ao banco
    @return oDataEmail, Object, objeto com as informações do layout do boleto
/*/
Method formatEmailTechFin(oAPIMSG As Json) As Object Class BillsTechfin

	Local oDataEMail := JsonObject():new() As Object

	If oAPIMSG:hasProperty('response')
		oDataEMail['boleto'] := JsonObject():new()
		oDataEMail['boleto']['bankSlipId']            := oAPIMSG['response']['bankSlipId']
		oDataEMail['boleto']['externalTransactionId'] := oAPIMSG['response']['externalTransactionId']
		oDataEMail['boleto']['digitableLine']         := AllTrim(Transform(oAPIMSG['response']['digitableLine'], "@R 99999.99999 99999.999999 99999.999999 9 99999999999999"))
		oDataEMail['boleto']['barcode']               := oAPIMSG['response']['barcode']
		oDataEMail['boleto']['qrCodeText']            := oAPIMSG['response']['qrCodeText']
		oDataEMail['boleto']['qrCode']                := oAPIMSG['response']['qrCode']
		oDataEMail['boleto']['urlPdf']                := oAPIMSG['response']['urlPdf']
	EndIf

Return oDataEmail

/*/{Protheus.doc} BillsTechfin::patch
  Método para transmissão de alteração do boletos PIX
  @type method
  @version  12.1.2410
  @author renato.paiva
  @since 23/07/2025
  @return logical, transmissão realizada com sucesso (.T. - Sim, .F. - Não)
/*/
Method patch() Class BillsTechfin As Logical

	Local lResponse  As Logical
	Local oBolPixRet As Object
	Local aHeadStr   As Array
	Local jSeaApiMsg As Json
	Local cUrl		 As Character
	Local cPOSTParms As Character
	Local cHeaderRet As Character
	Local cResponse	 As Character
	Local nHttpCode	 As Numeric

	lResponse  := .F.
	aHeadStr   := {}
	cUrl	   := ""
	cPOSTParms := ""
	cHeaderRet := ""
	cResponse  := ""
	nHttpCode  := 0

	jSeaApiMsg := JSonObject():New()
	jSeaApiMsg:FromJson(FI2->FI2_HISTOR)

	If jSeaApiMsg:hasProperty('response')

		AAdd(aHeadStr, "Content-Type: application/json")
		AAdd(aHeadStr, "Authorization: Bearer " + Self:GetToken())

		oBolPixRet := JSONObject():New()
		cPOSTParms := EncodeUTF8(self:oBody:toJson())
		cUrl	   := Self:cUrlRaas + "/pay-hub/transacting/api/v3/payment/bolepix/" + jSeaApiMsg['response']['processorTransactionId']
		cResponse  := HTTPQuote( cUrl,;		    //Corresponde ao endereço HTTP, juntamente com a pasta e o documento solicitados.
								"PATCH",;		//Define o HTTP Method que será utilizado, permitindo outros além de POST/GET.
								"",;		    //Corresponde ao endereço HTTP, juntamente com a pasta e o documento solicitados.
								cPOSTParms,;	//Corresponde à StringList de parâmetros a serem enviados ao servidor HTTP através do pacote HTTP. Caso não especificado, este parâmetro é considerado vazio ("")
								120,;	    	//Especificamos o tempo em segundos (máximo) de inatividade permitido durante a recepção do documento. Caso não especificado, o valor padrão assumido é 120 segundos (2 minutos).
								aHeadStr,;		//Permite especificar um array com strings a serem acrescentadas ao Header da requisição HTTP a ser realizada.
								@cHeaderRet)	//Retorna através de referência o header de resposta HTTP enviado pelo servidor requisitado. Variável deve ser declarada antes da chamada da função.
								
		nHttpCode := HTTPGetStatus(Nil,Nil)

		oBolPixRet:FromJSon(Self:setResponse(cResponse,nHttpCode))

		If oBolPixRet:HasProperty('response')
			::cResult := oBolPixRet:ToJson()
			lResponse := .T.
		Else
			::cError := oBolPixRet:ToJson()
		EndIf
		
		oBolPixRet:FromJSON( "{}" )
		
		ASize( aHeadStr, 0 )
		
		FwFreeArray( aHeadStr )
		FwFreeObj( oBolPixRet )

	EndIf

	jSeaApiMsg:FromJSON("{}")
	FwFreeObj(jSeaApiMsg)
	
Return lResponse

/*/{Protheus.doc} setResponse
	Trata o response das alterações do boleto 
	@type  Function
	@author renato.mpaiva
	@since 25/07/2025
	@version 1.0
	@param cResult, Character, Json de resposta do banco no formato caractere
	@param nHttpCode, Numeric, Codigo HTTP da requisição que sera tratado
	@return jResponse:ToJson(), Character, Json com tratamento para sucesso e erro no formato caractere
/*/
Method setResponse(cResult As Character, nHttpCode As Numeric) As Character Class BillsTechfin 
	Local jResponse As Json

	Default cResult := ""

	jResponse := JsonObject():new()

	If nHttpCode == 204 .Or. nHttpCode == 201 .Or. nHttpCode == 200
		jResponse['response'] := JsonObject():new()
		jResponse['response']:FromJSON(DecodeUTF8(cResult))
	Else
		jResponse['error']  := nHttpCode
		jResponse['message']:= JsonObject():new()
		jResponse['message']:FromJSON(DecodeUTF8(cResult))
	EndIf
	
Return jResponse:ToJson()

