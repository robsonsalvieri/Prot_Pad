#INCLUDE 'msobject.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.fin.exchangeratedifferenceCXC.ch'

namespace custom.financeiro.exchangeratedifferenceCXC.integratedprovider

//-------------------------------------------------------------------------------
/*{Protheus.doc} backoffice.sv.fin.exchangeratedifferenceCXC
@description Classe para creación del Objeto de Negocio de Diferencia en cambio Cuentas por Pagar para SMARTVIEW
@author Leonardo Pereira
@since 10/12/2024
@version 1.1
*/
//-------------------------------------------------------------------------------
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGAFIN', tables='SE1,SFR,SA1', name='Diferencia en cambio Cuentas por Cobrar', country='ALL', initialRelease='12.1.2410', customTables='SE1,SA1' )
class exchangeratedifferenceCXCTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array
	protected data jItems as json

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe 
@Return object: self
@author Leonardo Pereira
@since 31/10/2024
@version 1.0
*/
//-------------------------------------------------------------------
Method new() class exchangeratedifferenceCXCTReportsBusinessObject

	Local aCpos := { } as array

	_Super:new( )

	// Define o nome do Objeto de Negócio
	self:setDisplayName( STR0001 )  // 'Diferencia en cambio Cuentas por Cobrar'

	// Define a descrição do Objeto de Negócio
	self:setDescription( STR0001 )  // 'Diferencia en cambio Cuentas por Cobrar'

	// Define a Área
	self:appendArea( STR0002 ) // 'Financeiro'

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'FINSV507' )
		IIf( !self:setErrorStatus( 400, STR0003, STR0004 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0005,,, ),'' ) // 'Sin Preguntas' // '¡Verifique el grupo de preguntas dado!' // 'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0006,,, ) // 'Grupo de preguntas no encontrado!'
	EndIf

	// campos que no existen en SX3
	//aAdd( aCpos, { 'CU_DESMOT' , STR0007, 'string', STR0007 } ) // 'Descripción del motivo'

	// demais campos
	self:aFields := { 'A1_COD', 'A1_LOJA', 'E1_VENCREA', 'E1_EMISSAO', 'E1_EMIS1', 'E1_NATUREZ', 'E1_PREFIXO', 'E1_NUM', 'E1_PARCELA', 'E1_TIPO', 'E1_VLCRUZ', 'E1_VALOR', 'E1_MOEDA', 'E1_TXMOEDA', 'E1_HIST', 'FR_DATADI', 'FR_CHAVDE', 'FR_CHAVOR', 'FR_VALOR', 'FR_MOEDA', 'FR_TXORI', 'FR_TXATU', 'FR_CORANT' }

	self:aStruct := getStrutObj( self:aFields, aCpos )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna los datos del objeto de negócio
@param nPage, numérico, indica la pagina actual del relatório
@param oFilter, objeto, contiene el filtro del TReports
@return object: self:oData
@author Leonardo Pereira
@since 31/10/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object) as object class exchangeratedifferenceCXCTReportsBusinessObject

	// Declaracao de variaveis
	Local cQuery		  as character
	Local cFiltro 		  as character
	Local cExp 			  as character
	Local cCpoSE1		  as character
	Local cCpoSA1 		  as character
	Local cAliasA       as character
	Local cAliasB       as character

	Local nX			     as numeric
	Local n1			     as numeric
	Local nTamChav 	  as numeric
	Local nSeq			  as numeric

	Local jParams 		  as json

	Local aPDFields	  as array
	Local aFiltro		  as array
	Local aCustomFields as array

	Local lObfuscated	  as logical

	Local oExecA		  as object
	Local oExecB		  as object

	Local cFilialSFR      as character

	cFilialSFR := FWxFilial( "SFR" )

	cFiltro 			:= ''
	cExp 				:= ''
	cAliasA			:= ''
	cAliasB			:= ''

	nX 				:= 0
	n1				   := 0
	nTamChav  		:= TamSX3( 'FR_CHAVOR' )[1]

	aPDFields		:= { }
	aFiltro			:= { }
	aCustomFields	:= { }

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )
	cCpoSE1 := getCpoUser( aCustomFields, 'SE1', 'E1', ',' )
	cCpoSA1 := getCpoUser( aCustomFields, 'SA1', 'A1', ',' )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	If oFilter:hasFilter( )
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )
		aFiltro := getParamToArr( cFiltro )
		// Ordena os parametros
		aSort( aFiltro,,, { | x, y | x[1] + x[3] < y[1] + y[3] } )
	EndIf

	// Realiza a montagem da QUERY que será enviada para o banco de dados
	cQuery := "SELECT "
	cQuery += " SA1.A1_COD, SA1.A1_LOJA, SA1.A1_NOME, " + cCpoSA1 + cCpoSE1 + "SE1.E1_VENCREA, SE1.E1_EMISSAO, SE1.E1_EMIS1, SE1.E1_NATUREZ, SE1.E1_PREFIXO, SE1.E1_NUM, SE1.E1_PARCELA, SE1.E1_TIPO, SE1.E1_VLCRUZ, SE1.E1_VALOR, SE1.E1_MOEDA, SE1.E1_TXMOEDA "
	cQuery += "FROM " + RetSqlName( 'SE1' ) + " SE1 "
	cQuery += "INNER JOIN " + RetSqlName( "SA1" ) + " SA1 "
	cQuery += "   ON SA1.A1_FILIAL = ? "
	cQuery += "      AND SA1.A1_COD = SE1.E1_CLIENTE "
	cQuery += "      AND SA1.A1_LOJA = SE1.E1_LOJA "
	cQuery += "      AND SA1.D_E_L_E_T_ = ? "

	cQuery += "WHERE SE1.E1_FILIAL = ? "
	cQuery += "   AND SE1.E1_PREFIXO BETWEEN ? AND ? "
	cQuery += "   AND SE1.E1_NUM BETWEEN ? AND ? "
	cQuery += "   AND SE1.E1_CLIENTE BETWEEN ? AND ? "
	cQuery += "   AND SE1.E1_NATUREZ BETWEEN ? AND ? "
	cQuery += "   AND SE1.E1_EMISSAO BETWEEN ? AND ? "
	cQuery += "   AND SE1.E1_VENCREA BETWEEN ? AND ? "
	cQuery += "   AND SE1.E1_EMIS1 BETWEEN ? AND ? "

	If ( jParams['MV_PAR15'][1] == 1 )
		cQuery += "   AND SE1.E1_MOEDA > ?  "
	Else
		cQuery += "   AND SE1.E1_MOEDA <= ?  "
		cQuery += "   AND SE1.E1_CONVERT = ? "
	EndIf

	// Agrega os filtros na QUERY
	For nX := 1 To Len( aFiltro )
		cQuery += "   AND " + aFiltro[nX, 1] + ' ' + aFiltro[nX, 2] + " " + aFiltro[nX, 3] + " "
	Next

	cQuery += "   AND SE1.D_E_L_E_T_ = ? "
	cQuery += " ORDER BY ? "

	cQuery := ChangeQuery( cQuery )

	oExecA := FwExecStatement( ):New( cQuery )

	nSeq := 0

	oExecA:SetString( nSeq += 1, FWxFilial( "SA1" ) )
	oExecA:SetString( nSeq += 1, ' ' )
	oExecA:SetString( nSeq += 1, FWxFilial( "SE1" ) )
	oExecA:SetString( nSeq += 1, jParams['MV_PAR03'][1] )
	oExecA:SetString( nSeq += 1, jParams['MV_PAR04'][1] )
	oExecA:SetString( nSeq += 1, jParams['MV_PAR05'][1] )
	oExecA:SetString( nSeq += 1, jParams['MV_PAR06'][1] )
	oExecA:SetString( nSeq += 1, jParams['MV_PAR01'][1] )
	oExecA:SetString( nSeq += 1, jParams['MV_PAR02'][1] )
	oExecA:SetString( nSeq += 1, jParams['MV_PAR07'][1] )
	oExecA:SetString( nSeq += 1, jParams['MV_PAR08'][1] )
	oExecA:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR09'][1] )[1] ) )
	oExecA:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR10'][1] )[1] ) )
	oExecA:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR11'][1] )[1] ) )
	oExecA:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR12'][1] )[1] ) )
	oExecA:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR13'][1] )[1] ) )
	oExecA:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR14'][1] )[1] ) )

	If ( jParams['MV_PAR15'][1] == 1 )
		oExecA:SetNumeric( nSeq += 1, 1 )
	Else
		oExecA:SetNumeric( nSeq += 1, 1 )
		oExecA:SetString( nSeq += 1, 'N' )
	EndIf

	oExecA:SetString( nSeq += 1, ' ' )
	oExecA:SetUnsafe( nSeq += 1, 'SE1.E1_FILIAL, SE1.E1_PREFIXO, SE1.E1_NUM, SE1.E1_PARCELA' )

	cQuery := oExecA:getFixQuery( )

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	cAliasA := oExecA:OpenAlias( )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	While !( cAliasA )->( EOF( ) )
		self:jItems := JsonObject():new( )

		For nX := 1 To Len( self:aStruct )
			If ( SubStr( self:aStruct[nx][5], 1, 2 ) $ "A1,E1" )
				If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
					self:jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
				ElseIf ( self:aStruct[nX][3] == 'date' )
					self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
				Else
					If ( self:aStruct[nx][5] == 'E1_HIST' )
						If ( jParams['MV_PAR15'][1] == 1 )
							self:jItems[self:aStruct[nX][1]] := STR0007
						Else
							self:jItems[self:aStruct[nX][1]] := STR0008
						Endif
					Else
						self:jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
					Endif
				Endif
			Endif
		Next

		// Inclui os dados no objeto paea retorno ao SmartView
		self:oData:appendData( self:jItems )

		// Realiza a montagem da QUERY que será enviada para o banco de dados
		cQuery := "SELECT "

		cQuery += "SFR.FR_DATADI, SFR.FR_CHAVDE, SFR.FR_CHAVOR, SFR.FR_VALOR, SFR.FR_MOEDA, SFR.FR_TXORI, SFR.FR_TXATU, SFR.FR_CORANT "

		cQuery += "FROM " + RetSQLName( 'SFR' ) + " SFR "

		cQuery += "WHERE SFR.FR_FILIAL = ? "
		cQuery += "   AND SFR.FR_CARTEI = ? "

		If ( jParams['MV_PAR15'][1] == 1 )
			cQuery += "   AND SFR.FR_CHAVOR = ? "
		Else
			cQuery += "   AND SFR.FR_CHAVDE = ? "
		EndIf

		cQuery	+=	"   AND SFR.D_E_L_E_T_ = ? "

		cQuery := ChangeQuery( cQuery )

		oExecB := FwExecStatement( ):New( cQuery )

		oExecB:SetString( 1, cFilialSFR )
		oExecB:SetString( 2, '1' )
		oExecB:SetString( 3, SubStr( ( cAliasA )->E1_PREFIXO + ( cAliasA )->E1_NUM + ( cAliasA )->E1_PARCELA + ( cAliasA )->E1_TIPO + ( cAliasA )->A1_COD + ( cAliasA )->A1_LOJA, 1, nTamChav ) )
		oExecB:SetString( 4, ' ' )

		cQuery := oExecB:getFixQuery( )

		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		cAliasB := oExecB:OpenAlias( )

		// Alimenta o objeto de dados da classe para retornar ao SmartView
		While !( cAliasB )->( EOF( ) )
			self:jItems := JsonObject():new( )

			For nX := 1 To Len( self:aStruct )
				If ( SubStr( self:aStruct[nx][5], 1, 2 ) $ "FR" )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						self:jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasB )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasB )->&( self:aStruct[nX][5] ) ) )
					Else
						self:jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
					Endif
				Endif
			Next

			// Inclui os dados no objeto paea retorno ao SmartView
			self:oData:appendData( self:jItems )

			( cAliasB )->( DbSkip( ) )
		End
		( cAliasB )->( DbCloseArea( ) )

		( cAliasA )->( DbSkip( ) )
	End

	( cAliasA )->( DbCloseArea( ) )

	If oExecA <> Nil
		oExecA:Destroy( )
		oExecA := Nil
	Endif
	If oExecB <> Nil
		oExecB:Destroy( )
		oExecB := Nil
	Endif

Return( self:oData )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
@description Retorna la estructura de los campos
@return object: self:oSchema
@author Leonardo Pereira
@since 31/10/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema() as object class exchangeratedifferenceCXCTReportsBusinessObject

	Local nX as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTView
	For nX := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5] )
	Next

Return( self:oSchema )
