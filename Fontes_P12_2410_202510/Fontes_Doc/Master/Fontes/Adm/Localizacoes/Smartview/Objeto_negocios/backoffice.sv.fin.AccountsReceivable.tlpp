#INCLUDE 'msobject.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'tlpp-core.th'
#INCLUDE 'tlpp-rest.th'
#INCLUDE 'backoffice.sv.fin.AccountsReceivable.ch'

namespace custom.financeiro.cuentasporcobrar.integratedprovider

//-------------------------------------------------------------------------------
/*{Protheus.doc} AccountsReceivableTReportsBusinessObject
Classe para creación del Objeto de Negocio de compras para TReports
@author Cristian Gustavo
@since 03/10/2023
@version 1.0
*/
//-------------------------------------------------------------------------------
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGAFIN', name='Cuentas por Cobrar', tables='SA1,SE1,SED', country='ALL', initialRelease='12.1.2310', customTables='SA1,SE1,SED' )
class AccountsReceivableTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	Public Method new() 		   	as Object
	Public Method getData() 	   as Object
	Public Method getSchema() 	   as Object

	Protected data aFields 			as Array
	Protected data aStruct 			as Array

	Protected data jItems			as Json

endclass

//-------------------------------------------------------------------
	/*{Protheus.doc} new
	Método de instância da classe 
	@Return object: self
	@author Cristian Gustavo
	@since 03/10/2023
	@version 1.0
	*/
//-------------------------------------------------------------------
Method new(oFilter as object) as object class AccountsReceivableTReportsBusinessObject

	Local aCpos	as Array

	aCpos	 := { }

	_Super:new( )

	// Define a Área
	self:appendArea(STR0001) //"Financiero"

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0037 ) //"Cuentas por Cobrar"

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0037 ) //"Cuentas por Cobrar"

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte('FINSV13') // Indica o pergunte que será utilizado
		IIf(!self:setErrorStatus( 400, STR0002, STR0003 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0004,,, ),'') //'Sin Preguntas' //'¡Verifique el grupo de preguntas dado!' //'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0005 ,,, ) //'¡Grupo de preguntas no encontrado!'
	EndIf

	aAdd( aCpos, {'E1_DEBITO' , STR0006 , 'number', STR0006 } ) // 'Débitos'
	aAdd( aCpos, {'E1_DEBDIA' , STR0007 , 'number', STR0007 } ) // 'Débitos Tx. Día.'
	aAdd( aCpos, {'E1_DEBMOV' , STR0008 , 'number', STR0008 } ) // 'Débitos Tx. Mov.'
	aAdd( aCpos, {'E1_CREDITO', STR0009 , 'number', STR0009 } ) // 'Créditos'
	aAdd( aCpos, {'E1_CREDIA' , STR0010 , 'number', STR0010 } ) // 'Créditos Tx. Día.'
	aAdd( aCpos, {'E1_CREMOV' , STR0011 , 'number', STR0011 } ) // 'Créditos Tx. Mov.'
	aAdd( aCpos, {'E1_SALDO'  , STR0012 , 'number', STR0012 } ) // 'Saldo'

	// Ambas visões de dados
	aAdd( aCpos, {'E1_TAXADIA' , STR0013 , 'number', STR0013 } ) // 'Tasa del Día'
	aAdd( aCpos, {'E1_SALDO1'  , STR0014 , 'number', STR0014 } ) // 'Saldo Moneda 1'
	aAdd( aCpos, {'E1_SALDO2'  , STR0015 , 'number', STR0015 } ) // 'Saldo Tx. Dia'
	aAdd( aCpos, {'E1_TAXMOV'  , STR0016 , 'number', STR0016 } ) // 'Saldo Tx. Dia'
	aAdd( aCpos, {'E1_SALDO3'  , STR0017 , 'number', STR0017 } ) // 'Saldo Tx. Mov.'
	aAdd( aCpos, {'EF_FLTVSD'  , STR0018 , 'string', STR0018 } ) // 'Filtro visiones de datos'
	aAdd( aCpos, {'E1_DESMOE'  , STR0019 , 'string', STR0019 } ) // 'Desc. Moneda'
	aAdd( aCpos, {'E1_DESTPO'  , STR0020 , 'string', STR0020 } ) // 'Desc. Tipo'
	aAdd( aCpos, {'E1_VALORI'  , STR0021 , 'number', STR0021 } ) // 'Valor Original'
	aAdd( aCpos, {'E1_VLORID'  , STR0022 , 'number', STR0022 } ) // 'Valor Original Tx. Día.'
	aAdd( aCpos, {'E1_VLORIM'  , STR0023 , 'number', STR0023 } ) // 'Valor Original Tx. Mov.'
	aAdd( aCpos, {'E1_ATRASO'  , STR0024 , 'number', STR0024 } ) // 'Atraso'
	aAdd( aCpos, {'E1_QTDTIT'  , STR0025 , 'number', STR0025 } ) // 'Cant. Títulos'
	aAdd( aCpos, {'E1_VEVLNO1' , STR0026 , 'number', STR0026 } ) // 'Vencidos Vlr Nominal (Tasa Día)'
	aAdd( aCpos, {'E1_VEVLNO2' , STR0027 , 'number', STR0027 } ) // 'Vencidos Vlr Nominal (Tasa Mov.)'
	aAdd( aCpos, {'E1_VEVLCO1' , STR0028 , 'number', STR0028 } ) // 'Vencidos Vlr Corregido (Tasa Día)'
	aAdd( aCpos, {'E1_VEVLCO2' , STR0029 , 'number', STR0029 } ) // 'Vencidos Vlr Corregido (Tasa Mov.)'
	aAdd( aCpos, {'E1_TITVEN1' , STR0030 , 'number', STR0030 } ) // 'Títulos a Vencer-Val (Tasa Día). Nominal'
	aAdd( aCpos, {'E1_TITVEN2' , STR0031 , 'number', STR0031 } ) // 'Títulos a Vencer-Val. Nominal (Tasa Mov.)'
	aAdd( aCpos, {'E1_VLRINTE' , STR0032 , 'number', STR0032 } ) // 'Valor Inter/Permanencia'
	aAdd( aCpos, {'E1_SALDOFIN', STR0033 , 'number', STR0033 } ) // 'Saldo Final'
	aAdd( aCpos, {'ED_DESCRIC' , STR0034 , 'string', STR0034 } ) // 'Descripción'

	self:aFields := { 'E1_FILIAL', 'A1_COD', 'E1_LOJA', 'A1_NOME', 'E1_PREFIXO', 'E1_NUM', 'E1_MOEDA', 'E1_DESMOE', 'E1_PARCELA', 'E1_DESTPO', 'E1_TIPO', 'E1_NATUREZ', 'E1_EMISSAO', 'E1_VENCTO','E1_VENCREA', 'E1_DEBITO', 'E1_DEBDIA', 'E1_DEBMOV', 'E1_CREDITO', 'E1_CREDIA', 'E1_CREMOV', 'E1_SALDO', 'E1_SALDO1', 'E1_TAXADIA', 'E1_SALDO2', 'E1_TAXMOV', 'E1_SALDO3',  'EF_FLTVSD', 'E1_TXMOEDA', 'E1_VALOR', 'E1_NUMLIQ', 'E1_ATRASO', 'E1_VALORI', 'E1_VLORID', 'E1_VLORIM', 'E1_QTDTIT', 'E1_VEVLNO1','E1_VEVLNO2', 'E1_VEVLCO1', 'E1_VEVLCO2','E1_TITVEN1','E1_TITVEN2','E1_VLRINTE', 'E1_SALDOFIN', 'ED_DESCRIC', 'E1_CLIENTE', 'E1_ACRESC', 'E1_NUMBCO', 'E1_BAIXA'}

	self:aStruct := getStrutObj( self:aFields, aCpos, .F. )

Return(self)

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna los datos del objeto de negócio	
@param oFilter, objeto, contiene el filtro del TReports	
@Return object: self:oData	
@author Cristian Gustavo
@since 03/10/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method getData( nPage as numeric, oFilter as object ) as object class AccountsReceivableTReportsBusinessObject

	Local aPDFields 	as Array
	Local aFiltro		as Array
	Local aCpos			as Array
	Local aTipDoc		as Array
	Local aNomeMoed     as Array
	Local aCRNEGTW 		as Array
	Local aCRNEG        as Array
	Local aSepara 		as Array
	Local aMoedaD       as Array
	Local aCustomFields	as Array

	Local lObfuscated	as Logical

	Local jItems 		as Json
	Local jParams       as Json

	Local cAlias 		:= GetNextAlias() as character
	Local oQuery		as object
	Local cFiltro		as Character
	Local cExp			as Character
	Local cQuery		as Character
	Local cCpoSA1 		as Character
	Local cCpoSE1 		as Character
	Local cCampo		as Character
	Local cCodBanco		as Character
	Local cCodPostal	as Character
	Local cCodAgenc		as Character
	Local cCodCuenta	as Character
	Local cOpcQuerry 	as Character
	Local cTipo 		as Character
	Local cNeg   		as Character
	Local cDescMon      as Character
	Local cFilSE1       as Character

	Local nSigno 		as Numeric
	Local nSaldo 		as Numeric
	Local nCount 		as Numeric
	Local nX 			as Numeric
	Local n1			as Numeric
	Local nPosExp       as Numeric
	Local nPosMon       as Numeric
	Local nPosVld       as Numeric
	Local nPosTp        as Numeric
	Local nMoedaD       as Numeric
	Local nMoedaM       as Numeric
	Local nQtMoedas     as Numeric
	Local nTxMoeConv    as Numeric
	Local nDecs		    as Numeric
	Local nMoeda       	as Numeric
	Local nTOTCon1      as Numeric
	Local nVlrDeb       as Numeric
	Local nVlrCre       as Numeric
	Local nMVPAR11 		as Numeric
	Local nJuros        as Numeric
	Local nSalTitD      as Numeric
	Local nSalTitM      as Numeric
	Local nSeq      	as Numeric
	Local cSimbM1       as character

	cSimbM1         := SuperGetMv("MV_SIMB1", .F., "$")

	aPDFields 		:= {}
	aFiltro			:= {}
	aCpos			:= {}
	aTipDoc 		:= {{ "FT ", "FT" }, { "NF ", "FT" }, { "NCC", "NC" }, { "NDC", "ND" }}
	aNomeMoed       := {}
	aSepara 		:= {'|', ',', '-'}
	aCRNEGTW		:= fSeparaMV(MV_CRNEG + "," + SuperGetMv("MV_CRNEG", .F., "NCC,NDE,RA"), aSepara)
	aCRNEG          := fSeparaMV(MV_CRNEG +"|"+MVRECANT, aSepara)
	aMoedaD         := {}
	aCustomFields	:= {}

	lObfuscated		:= Len( aPDFields ) != Len( self:aFields )

	cExp			:= ''
	cQuery			:= ''
	cCampo			:= ''
	cCodBanco		:= ''
	cCodAgenc		:= ''
	cCodCuenta		:= ''
	cCodPostal		:= ''
	cOpcQuerry		:= ''
	cTipo			:= ''
	cNeg			:= SuperGetMv("MV_CRNEG", .F., "NCC,NDE,RA") + "/RA "
	cDescMon        := ''
	cCpoSA1 		:= ''
	cCpoSE1 		:= ''
	cFilSE1         := xFilial("SE1")

	nSigno 			:= 0
	nSaldo 			:= 0
	nCount 			:= 0
	nX 				:= 0
	n1 				:= 0
	nPosExp         := 0
	nPosMon         := 0
	nPosVld         := 0
	nPosTp          := 0
	nMoedaD         := 0
	nMoedaM         := 0
	nQtMoedas       := Moedfin()
	nTxMoeConv      := 0
	nDecs 			:= MsDecimais(1)
	nMoeda          := 0
	nTOTCon1        := 0
	nVlrDeb         := 0
	nVlrCre         := 0
	nJuros          := 0
	nSalTitD        := 0
	nSalTitM        := 0

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	nMVPAR11 := IIf( ( ValType( jParams['MV_PAR11'][1] ) == 'C' ), Val( jParams['MV_PAR11'][1] ), jParams['MV_PAR11'][1] )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	// Coleta os campos personalizados pra agregar na query
	cCpoSA1 := getCpoUser( aCustomFields, 'SA1', 'A1', ',' )
	cCpoSE1 := getCpoUser( aCustomFields, 'SE1', 'E1', ',' )
	cCpoSED := getCpoUser( aCustomFields, 'SED', 'ED', ',' )

	// Atribuição moeda conversão valores
	nMoeda  := nMVPAR11

	// Lista as moedas e suas descrições
	For nX := 1 To nQtMoedas
		aAdd( aNomeMoed, { AllTrim( Str( nX ) ), SuperGetMv( 'MV_MOEDA' + AllTrim( Str( nX ) ) ) } )
	Next

	// Pesquisa a taxa do dia
	If (nMVPAR11 > 0 )
		DbSelectArea( 'SM2' )
		SM2->( DbSetOrder( 1 ))
		If SM2->( DbSeek(DtoS(dDataBase))) // M2_DATA
			For nX := 1 To nQtMoedas
				aAdd( aMoedaD, SM2->&(('M2_MOEDA' + StrZero(nX,1))) )
			Next nX
		EndIf
	EndIf

	If oFilter:hasFilter()
		cFiltro := oFilter:getSQLExpression( )

		// Converte string de parametros em array
		aFiltro := getParamToArr( cFiltro )

		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )

		//Filtro visões de dados
		nPosExp := aScan( aFiltro, { | x | AllTrim( x[1] ) == 'EF_FLTVSD' } )// Campo virtual a ser localizado
		If ( nPosExp > 0 )
			cOpcQuerry := SubStr( aFiltro[nPosExp, 3], 2, 1 )
		EndIf

		// Realiza tratamento de filtro para limpar os que não serão utilizados na query
		If ( nPosExp > 0 )
			// Exclui o elemento do Array
			aDel( aFiltro, nPosExp )

			// Redimensiona o Array
			aSize( aFiltro, ( Len( aFiltro ) - 1 ) )
		EndIf
	EndIf

	cQuery += " SELECT "
	cQuery += " SE1.E1_FILIAL,"
	cQuery += " SA1.A1_COD, "
	cQuery += " SE1.E1_CLIENTE, "
	cQuery += " SA1.A1_NOME, "
	cQuery += " SA1.A1_LOJA, "
	cQuery += " ? " //cCpoSA1
	cQuery += " SE1.E1_NATUREZ, "
	cQuery += " SED.ED_DESCRIC, "
	cQuery += " SE1.E1_PREFIXO, "
	cQuery += " SE1.E1_PARCELA, "
	cQuery += " '' E1_DESMOE, "
	cQuery += " SE1.E1_LOJA , "
	cQuery += " SE1.E1_TIPO , "
	cQuery += " ''  E1_DESTPO, "
	cQuery += " 0  E1_CREDIA, "
	cQuery += " 0  E1_CREMOV, "
	cQuery += " 0  E1_QTDTIT, "
	cQuery += " SE1.E1_EMISSAO , "
	cQuery += " SE1.E1_VENCTO , "
	cQuery += " SE1.E1_VENCREA , "
	cQuery += " SE1.E1_VLCRUZ ,
	cQuery += " 0  E1_SALDO2, "
	cQuery += " 0  E1_TAXMOV, "
	cQuery += " 0  E1_DEBITO, "
	cQuery += " 0  E1_CREDITO, "
	cQuery += " 0  E1_DEBDIA, "
	cQuery += " 0  E1_DEBMOV, "
	cQuery += " 0  E1_SALDO3, "
	cQuery += " 0  E1_SALDO1, "
	cQuery += " 0  E1_TAXADIA, "
	cQuery += " ''  EF_FLTVSD, "
	cQuery += " SE1.E1_TXMOEDA , "
	cQuery += " SE1.E1_NUMLIQ , "
	cQuery += " 0  E1_SALTIT, "
	cQuery += " 0  E1_ATRASO, "
	cQuery += " 0  E1_VALORI, "
	cQuery += " 0  E1_VLORID, "
	cQuery += " 0  E1_VLORIM, "
	cQuery += " SE1.E1_SALDO, "
	cQuery += " SE1.E1_JUROS, "
	cQuery += " SE1.E1_NUM, "
	cQuery += " SE1.E1_VALOR, "
	cQuery += " SE1.E1_VENCTO, "
	cQuery += " SE1.E1_NUMBCO, "
	cQuery += " SE1.E1_ACRESC, "
	cQuery += " SE1.E1_DECRESC,"
	cQuery += "  SE1.E1_MOEDA, "
	cQuery += "  SE1.E1_BAIXA, "
	cQuery += "  0 E1_CREDITO, "
	cQuery += " ? " //cCpoSE1
	cQuery += " ? " //cCpoSED
	cQuery += " 0 E1_SALDOFIN "
	cQuery += "FROM " + RetSqlName("SE1") + " SE1 "
	cQuery += "LEFT JOIN " + RetSqlName("SA1") + " SA1 ON SA1.A1_FILIAL  = ? AND SA1.A1_COD = SE1.E1_CLIENTE AND SA1.A1_LOJA = SE1.E1_LOJA AND SA1.D_E_L_E_T_ = ? "
	cQuery += "LEFT JOIN " + RetSqlName("SED") + " SED ON SED.ED_FILIAL  = ? AND SED.ED_CODIGO = SE1.E1_NATUREZ AND SED.D_E_L_E_T_ = ? "
	cQuery += "WHERE SE1.E1_CLIENTE BETWEEN ? AND ? "
	cQuery += "   AND SE1.E1_LOJA BETWEEN ? AND ? "
	cQuery += "   AND SE1.E1_EMISSAO BETWEEN ? AND ? "
	cQuery += "   AND SE1.E1_VENCREA BETWEEN ? AND ? "
	cQuery += "   AND SE1.E1_NATUREZ BETWEEN ? AND ? "
	cQuery += "   AND SE1.D_E_L_E_T_ = ? "

	// Agrega os filtros na QUERY
	For nX := 1 To Len( aFiltro )
		cQuery += " AND ? " + ' ' + " ? ? "
	Next

	If cOpcQuerry == "1" //Cuenta corriente por cliente (FINR13X).
		cQuery += " AND SUBSTRING(SE1.E1_TIPO, 1, 2) NOT IN(?) "
		cQuery += " ORDER BY ? "
	ElseIf cOpcQuerry == "2" //Titulos por cobrar (FINR13H)
		cQuery += " ORDER BY ? "
	ElseIf cOpcQuerry == "3" //Titulos por cobrar (FIN13A)
		cQuery += " AND SE1.E1_TIPO NOT IN (?)"
		cQuery += " ORDER BY ? "
	EndIf

	If !Empty( cQuery )
		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		cQuery := ChangeQuery( cQuery )

		oQuery := FwExecStatement():New()

		//Define a consulta e os parâmetros
		oQuery:SetQuery( cQuery )

		oQuery:SetUnSafe( 01, cCpoSA1 )
		oQuery:SetUnSafe( 02, cCpoSE1 )
		oQuery:SetUnSafe( 03, cCpoSED )

		oQuery:SetString( 04, FWxFilial( "SA1" ) )
		oQuery:SetString( 05, ' ' )
		oQuery:SetString( 06, FWxFilial( "SED" ) )
		oQuery:SetString( 07, ' ' )

		oQuery:SetString( 08, jParams['MV_PAR05'][1] )
		oQuery:SetString( 09, jParams['MV_PAR06'][1] )
		oQuery:SetString( 10, jParams['MV_PAR07'][1] )
		oQuery:SetString( 11, jParams['MV_PAR08'][1] )

		oQuery:SetString( 12, DtoS( FwDateTimeToLocal( jParams['MV_PAR01'][1] )[1] ) )
		oQuery:SetString( 13, DtoS( FwDateTimeToLocal( jParams['MV_PAR02'][1] )[1] ) )
		oQuery:SetString( 14, DtoS( FwDateTimeToLocal( jParams['MV_PAR03'][1] )[1] ) )
		oQuery:SetString( 15, DtoS( FwDateTimeToLocal( jParams['MV_PAR04'][1] )[1] ) )

		oQuery:SetString( 16, jParams['MV_PAR09'][1] )
		oQuery:SetString( 17, jParams['MV_PAR10'][1] )
		oQuery:SetString( 18, ' ' )

		nSeq := 18

		For nX := 1 To Len( aFiltro )
			oQuery:SetUnSafe ( nSeq += 1, aFiltro[nX, 1] )
			oQuery:SetUnSafe ( nSeq += 1, aFiltro[nX, 2] )
			oQuery:SetUnSafe ( nSeq += 1, aFiltro[nX, 3] )
		Next

		If cOpcQuerry == "1" //Cuenta corriente por cliente (FINR13X).
			oQuery:SetIn( ( nSeq += 1 ), { 'TF', 'CH', 'EF' } )
			oQuery:SetUnsafe( ( nSeq += 1 ), 'SE1.E1_FILIAL,SE1.E1_PREFIXO,SE1.E1_NUM,SE1.E1_PARCELA,SE1.E1_TIPO' )
		ElseIf cOpcQuerry == "2" //Titulos por cobrar (FINR13H)
			oQuery:SetUnsafe( ( nSeq += 1 ), 'SE1.E1_FILIAL,SE1.E1_PREFIXO,SE1.E1_NUM,SE1.E1_PARCELA,SE1.E1_TIPO' )
		ElseIf cOpcQuerry == "3" //Titulos por cobrar (FIN13A)
			oQuery:SetIn( ( nSeq += 1 ), { 'TF', 'CH' } )
			oQuery:SetUnsafe( ( nSeq += 1 ), 'SE1.E1_FILIAL,SE1.E1_PREFIXO,SE1.E1_NUM,SE1.E1_PARCELA,SE1.E1_TIPO' )
		EndIf

		// cria alias
		oQuery:OpenAlias( cAlias )

		While !( ( cAlias ) )->( Eof( ) )
			jItems := JsonObject():new()

			// Verifica se precisa fazer o tratamento para LGPD
			aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
			lObfuscated := Len( aPDFields ) != Len( self:aFields )

			nPosVld := aScan(aCRNEGTW, { | x | AllTrim( x ) == Alltrim((cAlias)->E1_TIPO)})
			lTipoNg := IIf(nPosVld > 0, .T., .F.)
			nPosTp  := aScan(aCRNEG, { | x | AllTrim( x ) == Alltrim((cAlias)->E1_TIPO)})
			lTipoIn := IIf(nPosTp > 0, .T., .F.)
			nSigno  := IIf(lTipoNg .OR. SubStr((cAlias)->E1_TIPO, 3, 1 ) == "-",-1,1)

			nVlrCre := 0
			If (!Empty(jParams['MV_PAR01'][1]) .And. sTod((cAlias)->E1_EMISSAO) <= Min(FwDateTimeToLocal( jParams['MV_PAR01'][1] )[1],dDatabase) ) .OR. (!Empty(jParams['MV_PAR03'][1]) .And. sTod((cAlias)->E1_VENCREA) <= FwDateTimeToLocal( jParams['MV_PAR03'][1] )[1])
				nVlrCre := IIf(lTipoNg .OR. SubStr( (cAlias)->E1_TIPO, 3, 1 ) == "-",(cAlias)->E1_CREDITO,0)
			ElseIf (Alltrim((cAlias)->E1_TIPO) <> Alltrim(cSimbM1))
				If ( !Empty(jParams['MV_PAR02'][1]) .AND. sTod((cAlias)->E1_EMISSAO) <= FwDateTimeToLocal( jParams['MV_PAR02'][1] )[1]) .OR. ( !Empty(jParams['MV_PAR04'][1]) .AND. sTod((cAlias)->E1_VENCREA) <= FwDateTimeToLocal( jParams['MV_PAR04'][1] )[1])
					nVlrCre := IIf(lTipoNg .OR. SubStr( (cAlias)->E1_TIPO, 3, 1 ) == "-",(cAlias)->E1_CREDITO,0)
				EndIf
			EndIf

			//Tasa del Día - Tasa del Movimiento
			If (cAlias)->E1_MOEDA == nMVPAR11
				nMoedaD := 1
				nMoedaM := 1
			ElseIf nMVPAR11 == 1 .And. (cAlias)->E1_MOEDA <> 1
				nMoedaD := RecMoeda(dDataBase, (cAlias)->E1_MOEDA)
				nMoedaM := RecMoeda((cAlias)->E1_EMISSAO, (cAlias)->E1_MOEDA)
			Else
				nMoedaD := RecMoeda(dDataBase, nMVPAR11)
				nMoedaM := RecMoeda((cAlias)->E1_EMISSAO, nMVPAR11)
			EndIf

			RecMoeda((cAlias)->E1_EMISSAO,IIf((cAlias)->E1_MOEDA==nMVPAR11,(cAlias)->E1_MOEDA,nMVPAR11))

			IF cOpcQuerry == "1" //Cuenta corriente por cliente (FINR13X).
				nSigno := IIf((cAlias)->E1_TIPO $ "RA" + MV_CRNEG,-1,1)
				dbSelectAre("SE1")
				SE1->(DbSetOrder(1)) //E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO
				nJuros   := FA070Juros(nMVPAR11)
				If SE1->(MsSeek(cFilSE1+(cAlias)->E1_PREFIXO+(cAlias)->E1_NUM+(cAlias)->E1_PARCELA+(cAlias)->E1_TIPO))
					nSalTitD := SaldoTit((cAlias)->E1_PREFIXO,(cAlias)->E1_NUM,(cAlias)->E1_PARCELA,(cAlias)->E1_TIPO,(cAlias)->E1_NATUREZ,"R",(cAlias)->A1_COD,nMVPAR11,,dDataBase,(cAlias)->A1_LOJA,,0)
					nSalTitM := SaldoTit((cAlias)->E1_PREFIXO,(cAlias)->E1_NUM,(cAlias)->E1_PARCELA,(cAlias)->E1_TIPO,(cAlias)->E1_NATUREZ,"R",(cAlias)->A1_COD,nMVPAR11,,dDataBase,(cAlias)->A1_LOJA,,IIf(!Empty((cAlias)->E1_TXMOEDA),(cAlias)->E1_TXMOEDA,RecMoeda((cAlias)->E1_EMISSAO,(cAlias)->E1_MOEDA)))
				EndIf
				For nX := 1 To Len(self:aStruct)
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize(((cAlias))->& (self:aStruct[nX][5]))
					Else
						If ( self:aStruct[nx][3] == 'date' )
							jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAlias )->&( self:aStruct[nX][5] ) ) )
						ElseIf ( self:aStruct[nx][5] == 'E1_TIPO' )
							nPosTp	:=	AScan( aTipDoc, { |a| a[1] == (cAlias)->E1_TIPO })
							cTipo	:=	IIf(nPosTp	>	0, aTipDoc[nPosTp][2],cTipo)
							jItems[self:aStruct[nX][1]] := cTipo
						ElseIf ( self:aStruct[nx][5] == 'E1_DESMOE' )
							//Moneda
							nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == AllTrim( Str( ( cAlias )->E1_MOEDA ) ) } )
							cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )
							jItems[self:aStruct[nX][1]] := cDescMon
						ElseIf ( self:aStruct[nx][5] == 'E1_DESTPO' )
							jItems[self:aStruct[nX][1]] := IIf((cAlias)->E1_TIPO == "CH", STR0035 ,"") // "Cheque Cartera"
						ElseIf ( self:aStruct[nx][5] == 'E1_SALDO1' )
							nTOTCon1 := xMoeda((cAlias)->E1_SALDO, (cAlias)->E1_MOEDA, 1, dDataBase,,(cAlias)->E1_TXMOEDA)
							jItems[self:aStruct[nX][1]] := (nTOTCon1 * nSigno)
						ElseIf ( self:aStruct[nx][5] == 'E1_VALORI' )
							jItems[self:aStruct[nX][1]] := ((cAlias)->E1_VLCRUZ * nSigno)
						ElseIf ( self:aStruct[nx][5] == 'E1_VLORID' )
							jItems[self:aStruct[nX][1]] := xMoeda((cAlias)->E1_VLCRUZ, 1, nMVPAR11, dDataBase,,(cAlias)->E1_TXMOEDA) * nSigno
						ElseIf ( self:aStruct[nx][5] == 'E1_VLORIM' )
							jItems[self:aStruct[nX][1]] := xMoeda((cAlias)->E1_VLCRUZ, 1, nMVPAR11,(cAlias)->E1_EMISSAO,,IIf((cAlias)->E1_TXMOEDA>0,(cAlias)->E1_TXMOEDA,RecMoeda((cAlias)->E1_EMISSAO,(cAlias)->E1_MOEDA)))
						ElseIf ( self:aStruct[nx][5] == 'E1_SALDO2' )
							jItems[self:aStruct[nX][1]] := IIf(nMoedaD > 0,Round( xMoeda((cAlias)->E1_SALDO, (cAlias)->E1_MOEDA, nMVPAR11, dDataBase,,RecMoeda(dDataBase,(cAlias)->E1_MOEDA)), nDecs ) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_SALDO3' )
							jItems[self:aStruct[nX][1]] := IIf(nMoedaM > 0,Round( xMoeda((cAlias)->E1_SALDO, (cAlias)->E1_MOEDA, nMVPAR11,(cAlias)->E1_EMISSAO,,IIf((cAlias)->E1_TXMOEDA>0,(cAlias)->E1_TXMOEDA,RecMoeda((cAlias)->E1_EMISSAO,(cAlias)->E1_MOEDA))), nDecs ) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_DEBITO' ) .AND. (Alltrim((cAlias)->E1_TIPO) <> Alltrim(cSimbM1)) .and. Empty((cAlias)->E1_NUMLIQ)
							jItems[self:aStruct[nX][1]] := IIf(lTipoNg .OR. SubStr((cAlias)->E1_TIPO, 3, 1 ) == "-", 0, (cAlias)->E1_DEBITO)
						ElseIf ( self:aStruct[nx][5] == 'E1_DEBDIA' ) .AND. (Alltrim((cAlias)->E1_TIPO) <> Alltrim(cSimbM1)) .and. Empty((cAlias)->E1_NUMLIQ)
							nVlrDeb := IIf(nMoedaD > 0,Round( xMoeda((cAlias)->E1_DEBITO, (cAlias)->E1_MOEDA, nMVPAR11, dDataBase,,RecMoeda(dDataBase,(cAlias)->E1_MOEDA)), nDecs ),0)
							jItems[self:aStruct[nX][1]] := IIf(lTipoNg .OR. SubStr((cAlias)->E1_TIPO, 3, 1 ) == "-", 0, nVlrDeb)
						ElseIf ( self:aStruct[nx][5] == 'E1_DEBMOV' ) .AND. (Alltrim((cAlias)->E1_TIPO) <> Alltrim(cSimbM1)) .and. Empty((cAlias)->E1_NUMLIQ)
							nVlrDeb := IIf(nMoedaM > 0,Round( xMoeda((cAlias)->E1_DEBITO, (cAlias)->E1_MOEDA, nMVPAR11,(cAlias)->E1_EMISSAO,,IIf((cAlias)->E1_TXMOEDA>0,(cAlias)->E1_TXMOEDA,RecMoeda((cAlias)->E1_EMISSAO,(cAlias)->E1_MOEDA))), nDecs ),0)
							jItems[self:aStruct[nX][1]] := IIf(lTipoNg .OR. SubStr((cAlias)->E1_TIPO, 3, 1 ) == "-", 0, nVlrDeb)
						ElseIf ( self:aStruct[nx][5] == 'E1_VEVLNO1' ) //Vencidos Vlr Nominal (Tasa Día)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase >= StoD((cAlias)->E1_VENCREA) .And. nMoedaD > 0,nSalTitD * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_VEVLNO2' ) //Vencidos Vlr Nominal (Tasa Moviemiento)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase >= StoD((cAlias)->E1_VENCREA),nSalTitM * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_VEVLCO1' ) //Vencidos Vlr Corregido (Tasa Día)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase >= StoD((cAlias)->E1_VENCREA) .And. nMoedaD > 0,(nSalTitD + nJuros) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_VEVLCO2' ) //Vencidos Vlr Corregido (Tasa Movimiento)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase >= StoD((cAlias)->E1_VENCREA),(nSalTitM + nJuros) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_TITVEN1' ) //Títulos a Vencer-Val. Nominal (Tasa Día)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase < StoD((cAlias)->E1_VENCREA) .And. nMoedaD > 0,(nSalTitD + nJuros) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_TITVEN2' ) //Títulos a Vencer-Val. Nominal (Tasa Movimiento)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase < StoD((cAlias)->E1_VENCREA),(nSalTitM + nJuros) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_SALDOFIN' )
							jItems[self:aStruct[nX][1]] := IIf((cAlias)->E1_TIPO $ "RA " + MV_CRNEG, ((cAlias)->E1_SALTIT + (cAlias)->E1_JUROS) *-1, (cAlias)->E1_SALTIT + (cAlias)->E1_JUROS)
						ElseIf ( self:aStruct[nx][5] ==	'E1_VLRINTE')
							jItems[self:aStruct[nX][1]] := nJuros
						ElseIf ( self:aStruct[nx][5] == 'E1_CREDITO' )
							jItems[self:aStruct[nX][1]] := nVlrCre
						ElseIf ( self:aStruct[nx][5] == 'E1_CREDIA' )
							jItems[self:aStruct[nX][1]] := IIf(nMoedaD > 0,Round( xMoeda(nVlrCre, (cAlias)->E1_MOEDA, nMVPAR11, dDataBase,,RecMoeda(dDataBase,(cAlias)->E1_MOEDA)), nDecs ),0)
						ElseIf ( self:aStruct[nx][5] == 'E1_CREMOV' )
							jItems[self:aStruct[nX][1]] := IIf(nMoedaM > 0, Round( xMoeda(nVlrCre, (cAlias)->E1_MOEDA, nMVPAR11,(cAlias)->E1_EMISSAO,,IIf((cAlias)->E1_TXMOEDA>0,(cAlias)->E1_TXMOEDA,RecMoeda((cAlias)->E1_EMISSAO,(cAlias)->E1_MOEDA))), nDecs ),0)
						ElseIf ( self:aStruct[nx][5] == 'E1_SALDO' )
							jItems[self:aStruct[nX][1]] := ((cAlias)->E1_SALDO * nSigno)
						ElseIf ( self:aStruct[nx][5] == 'E1_TAXADIA') //Tasa del Día
							jItems[self:aStruct[nX][1]] := nMoedaD
						ElseIf ( self:aStruct[nx][5] == 'E1_ATRASO') //Atraso
							jItems[self:aStruct[nX][1]] := dDatabase - StoD((cAlias)->E1_VENCREA)
						ElseIf ( self:aStruct[nx][5] == 'E1_TAXMOV' )
							jItems[self:aStruct[nX][1]] := nMoedaM
						Else
							jItems[self:aStruct[nX][1]] := (((cAlias)))->&(self:aStruct[nX][5])
						EndIf
					EndIf
				Next
			ElseIf cOpcQuerry == "2" //Titulos por cobrar (FINR13H)
				nSigno := IIf((cAlias)->E1_TIPO $ cNeg,-1,1)
				dbSelectAre("SE1")
				SE1->(DbSetOrder(1)) //E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO
				nJuros   := FA070Juros(nMVPAR11)
				If SE1->(MsSeek(cFilSE1+(cAlias)->E1_PREFIXO+(cAlias)->E1_NUM+(cAlias)->E1_PARCELA+(cAlias)->E1_TIPO))
					nSalTitD := SaldoTit((cAlias)->E1_PREFIXO,(cAlias)->E1_NUM,(cAlias)->E1_PARCELA,(cAlias)->E1_TIPO,(cAlias)->E1_NATUREZ,"R",(cAlias)->A1_COD,nMVPAR11,,dDataBase,(cAlias)->A1_LOJA,,0)
					nSalTitM := SaldoTit((cAlias)->E1_PREFIXO,(cAlias)->E1_NUM,(cAlias)->E1_PARCELA,(cAlias)->E1_TIPO,(cAlias)->E1_NATUREZ,"R",(cAlias)->A1_COD,nMVPAR11,,dDataBase,(cAlias)->A1_LOJA,,IIf(!Empty((cAlias)->E1_TXMOEDA),(cAlias)->E1_TXMOEDA,RecMoeda((cAlias)->E1_EMISSAO,(cAlias)->E1_MOEDA)))
				EndIf
				For nX := 1 To Len(self:aStruct)
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize(((cAlias))->& (self:aStruct[nX][5]))
					Else
						If ( self:aStruct[nx][3] == 'date' )
							jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAlias )->&( self:aStruct[nX][5] ) ) )
						ElseIf ( self:aStruct[nx][5] == 'E1_SALDO' )
							nSaldo   := ( cAlias )->E1_VALOR + ( cAlias )->E1_ACRESC - ( cAlias )->E1_DECRESC
							If nSaldo <= 0
								DbSkip()
								Loop
							EndIf
							jItems[self:aStruct[nX][1]] := (nSaldo * nSigno)
						ElseIf ( self:aStruct[nx][5] == 'E1_DESMOE' )
							//Moneda
							nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == AllTrim( Str( ( cAlias )->E1_MOEDA ) ) } )
							cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )
							jItems[self:aStruct[nX][1]] := cDescMon
						ElseIf ( self:aStruct[nx][5] == 'E1_DESTPO' )
							jItems[self:aStruct[nX][1]] := IIf(Alltrim((cAlias)->E1_TIPO) == "CH",STR0035,"") // "Cheque Cartera"
						ElseIf ( self:aStruct[nx][5] == 'E1_SALDO1' )
							nTOTCon1 := xMoeda((cAlias)->E1_SALDO, (cAlias)->E1_MOEDA, 1, dDataBase,,(cAlias)->E1_TXMOEDA)
							jItems[self:aStruct[nX][1]] := (nTOTCon1 * nSigno)
						ElseIf ( self:aStruct[nx][5] == 'E1_VALORI' )
							jItems[self:aStruct[nX][1]] := ((cAlias)->E1_VLCRUZ * nSigno)
						ElseIf ( self:aStruct[nx][5] == 'E1_VLORID' )
							jItems[self:aStruct[nX][1]] := xMoeda((cAlias)->E1_VLCRUZ, 1, nMVPAR11, dDataBase,,(cAlias)->E1_TXMOEDA) * nSigno
						ElseIf ( self:aStruct[nx][5] == 'E1_VLORIM' )
							jItems[self:aStruct[nX][1]] := xMoeda((cAlias)->E1_VLCRUZ, 1, nMVPAR11,(cAlias)->E1_EMISSAO,,IIf((cAlias)->E1_TXMOEDA>0,(cAlias)->E1_TXMOEDA,RecMoeda((cAlias)->E1_EMISSAO,(cAlias)->E1_MOEDA)))
						ElseIf ( self:aStruct[nx][5] == 'E1_SALDO2' )
							jItems[self:aStruct[nX][1]] := IIf(nMoedaD > 0,Round( xMoeda( nTOTCon1, 1, nMVPAR11, dDataBase,,,, ), nDecs ),0) * nSigno
						ElseIf ( self:aStruct[nx][5] == 'E1_DEBITO' ) .AND. (Alltrim((cAlias)->E1_TIPO) <> Alltrim(cSimbM1)) .and. Empty((cAlias)->E1_NUMLIQ)
							jItems[self:aStruct[nX][1]] := IIf(lTipoNg .OR. SubStr((cAlias)->E1_TIPO, 3, 1 ) == "-", 0, (cAlias)->E1_DEBITO)
						ElseIf ( self:aStruct[nx][5] == 'E1_DEBDIA' ) .AND. (Alltrim((cAlias)->E1_TIPO) <> Alltrim(cSimbM1)) .and. Empty((cAlias)->E1_NUMLIQ)
							nVlrDeb := IIf(nMoedaD > 0,Round( xMoeda((cAlias)->E1_DEBITO, (cAlias)->E1_MOEDA, nMVPAR11, dDataBase,,RecMoeda(dDataBase,(cAlias)->E1_MOEDA)), nDecs ),0)
							jItems[self:aStruct[nX][1]] := IIf(lTipoNg .OR. SubStr((cAlias)->E1_TIPO, 3, 1 ) == "-", 0, nVlrDeb)
						ElseIf ( self:aStruct[nx][5] == 'E1_DEBMOV' ) .AND. (Alltrim((cAlias)->E1_TIPO) <> Alltrim(cSimbM1)) .and. Empty((cAlias)->E1_NUMLIQ)
							nVlrDeb := If(nMoedaM > 0,Round( xMoeda((cAlias)->E1_DEBITO, (cAlias)->E1_MOEDA, nMVPAR11,(cAlias)->E1_EMISSAO,,IIf((cAlias)->E1_TXMOEDA>0,(cAlias)->E1_TXMOEDA,RecMoeda((cAlias)->E1_EMISSAO,(cAlias)->E1_MOEDA))), nDecs ),0)
							jItems[self:aStruct[nX][1]] := IIf(lTipoNg .OR. SubStr((cAlias)->E1_TIPO, 3, 1 ) == "-", 0, nVlrDeb)
						ElseIf ( self:aStruct[nx][5] == 'E1_VEVLNO1' ) //Vencidos Vlr Nominal (Tasa Día)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase >= StoD((cAlias)->E1_VENCREA) .And. nMoedaD > 0,nSalTitD * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_VEVLNO2' ) //Vencidos Vlr Nominal (Tasa Moviemiento)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase >= StoD((cAlias)->E1_VENCREA),nSalTitM * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_VEVLCO1' ) //Vencidos Vlr Corregido (Tasa Día)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase >= StoD((cAlias)->E1_VENCREA) .And. nMoedaD > 0,(nSalTitD + nJuros) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_VEVLCO2' ) //Vencidos Vlr Corregido (Tasa Movimiento)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase >= StoD((cAlias)->E1_VENCREA),(nSalTitM + nJuros) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_TITVEN1' ) //Títulos a Vencer-Val. Nominal (Tasa Día)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase < StoD((cAlias)->E1_VENCREA) .And. nMoedaD > 0,(nSalTitD + nJuros) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_TITVEN2' ) //Títulos a Vencer-Val. Nominal (Tasa Movimiento)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase < StoD((cAlias)->E1_VENCREA),(nSalTitM + nJuros) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_SALDOFIN' )
							jItems[self:aStruct[nX][1]] := IIf((cAlias)->E1_TIPO $ "RA " + MV_CRNEG, ((cAlias)->E1_SALTIT + (cAlias)->E1_JUROS) *-1, (cAlias)->E1_SALTIT + (cAlias)->E1_JUROS)
						ElseIf ( self:aStruct[nx][5] ==	'E1_VLRINTE')
							jItems[self:aStruct[nX][1]] := nJuros
						ElseIf ( self:aStruct[nx][5] == 'E1_CREDITO' )
							jItems[self:aStruct[nX][1]] := nVlrCre
						ElseIf ( self:aStruct[nx][5] == 'E1_CREDIA' )
							jItems[self:aStruct[nX][1]] := IIf(nMoedaD > 0,Round( xMoeda(nVlrCre, (cAlias)->E1_MOEDA, nMVPAR11, dDataBase,,RecMoeda(dDataBase,(cAlias)->E1_MOEDA)), nDecs ),0)
						ElseIf ( self:aStruct[nx][5] == 'E1_CREMOV' )
							jItems[self:aStruct[nX][1]] := IIf(nMoedaM > 0,Round( xMoeda(nVlrCre, (cAlias)->E1_MOEDA, nMVPAR11,(cAlias)->E1_EMISSAO,,IIf((cAlias)->E1_TXMOEDA>0,(cAlias)->E1_TXMOEDA,RecMoeda((cAlias)->E1_EMISSAO,(cAlias)->E1_MOEDA))), nDecs ),0)
						ElseIf ( self:aStruct[nx][5] == 'E1_TAXADIA') //Tasa del Día
							jItems[self:aStruct[nX][1]] := nMoedaD
						ElseIf ( self:aStruct[nx][5] == 'E1_TAXMOV' )
							jItems[self:aStruct[nX][1]] := nMoedaM
						ElseIf ( self:aStruct[nx][5] == 'E1_ATRASO') //Atraso
							jItems[self:aStruct[nX][1]] := dDatabase - StoD((cAlias)->E1_VENCREA)
						ElseIf ( self:aStruct[nx][5] == 'E1_SALDO3' )
							jItems[self:aStruct[nX][1]] := IIf(nMoedaM > 0,Round( xMoeda((cAlias)->E1_SALDO, (cAlias)->E1_MOEDA, nMVPAR11,(cAlias)->E1_EMISSAO,,IIf((cAlias)->E1_TXMOEDA>0,(cAlias)->E1_TXMOEDA,RecMoeda((cAlias)->E1_EMISSAO,(cAlias)->E1_MOEDA))), nDecs ) * nSigno,0)
						Else
							jItems[self:aStruct[nX][1]] := (((cAlias)))->&(self:aStruct[nX][5])
						EndIf
					EndIf
				Next nX
			ElseIf cOpcQuerry == "3" //Situacion de Titulos por Cobrar (FINR13A).
				nSigno := IIf((cAlias)->E1_TIPO $ "RA" + MV_CRNEG,-1,1)
				dbSelectAre("SE1")
				SE1->(DbSetOrder(1)) //E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO
				nJuros   := FA070Juros(nMVPAR11)
				If SE1->(MsSeek(cFilSE1+(cAlias)->E1_PREFIXO+(cAlias)->E1_NUM+(cAlias)->E1_PARCELA+(cAlias)->E1_TIPO))
					nSalTitD := SaldoTit((cAlias)->E1_PREFIXO,(cAlias)->E1_NUM,(cAlias)->E1_PARCELA,(cAlias)->E1_TIPO,(cAlias)->E1_NATUREZ,"R",(cAlias)->E1_CLIENTE,nMVPAR11,,dDataBase,(cAlias)->E1_LOJA,,0)
					nSalTitM := SaldoTit((cAlias)->E1_PREFIXO,(cAlias)->E1_NUM,(cAlias)->E1_PARCELA,(cAlias)->E1_TIPO,(cAlias)->E1_NATUREZ,"R",(cAlias)->E1_CLIENTE,nMVPAR11,,dDataBase,(cAlias)->E1_LOJA,,IIf(!Empty((cAlias)->E1_TXMOEDA),(cAlias)->E1_TXMOEDA,RecMoeda((cAlias)->E1_EMISSAO,(cAlias)->E1_MOEDA)))
				EndIf

				For nX := 1 To Len(self:aStruct)
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize(((cAlias))->& (self:aStruct[nX][5]))
					Else
						If ( self:aStruct[nx][5] == 'E1_CLIENTE' )
							jItems[self:aStruct[nX][1]] :=  AllTrim((cAlias)->E1_CLIENTE + " " + (cAlias)->A1_LOJA)
						ElseIf ( self:aStruct[nx][5] == 'A1_NOME' )
							jItems[self:aStruct[nX][1]] :=  AllTrim((cAlias)->E1_CLIENTE)
						ElseIf ( self:aStruct[nx][5] == 'E1_NATUREZ' )
							jItems[self:aStruct[nX][1]] :=  AllTrim(MascNat((cAlias)->E1_NATUREZ))
						ElseIf ( self:aStruct[nx][5] == 'ED_DESCRIC' )
							jItems[self:aStruct[nX][1]] :=  AllTrim((cAlias)->ED_DESCRIC)
						ElseIf ( self:aStruct[nx][5] == 'E1_PREFIXO' )
							jItems[self:aStruct[nX][1]] :=  AllTrim((cAlias)->E1_PREFIXO + Trans((cAlias)->E1_NUM, "@R /99999999999999") + " " + (cAlias)->E1_PARCELA)
						ElseIf ( self:aStruct[nx][5] == 'E1_TIPO' )
							jItems[self:aStruct[nX][1]] := AllTrim(If(Alltrim((cAlias)->E1_TIPO)$"NF","FT ",(cAlias)->E1_TIPO))
						ElseIf ( self:aStruct[nx][5] == 'E1_QTDTIT' )
							jItems[self:aStruct[nX][1]] := 1
						ElseIf ( self:aStruct[nx][5] == 'E1_SALDO' )
							jItems[self:aStruct[nX][1]] := (cAlias)->E1_VALOR * nSigno
						ElseIf ( self:aStruct[nx][5] == 'E1_VEVLNO1' ) //Vencidos Vlr Nominal (Tasa Día)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase >= StoD((cAlias)->E1_VENCREA) .And. nMoedaD > 0,nSalTitD * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_VEVLNO2' ) //Vencidos Vlr Nominal (Tasa Moviemiento)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase >= StoD((cAlias)->E1_VENCREA),nSalTitM * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_VEVLCO1' ) //Vencidos Vlr Corregido (Tasa Día)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase >= StoD((cAlias)->E1_VENCREA) .And. nMoedaD > 0,(nSalTitD + nJuros) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_VEVLCO2' ) //Vencidos Vlr Corregido (Tasa Movimiento)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase >= StoD((cAlias)->E1_VENCREA),(nSalTitM + nJuros) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_TITVEN1' ) //Títulos a Vencer-Val. Nominal (Tasa Día)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase < StoD((cAlias)->E1_VENCREA) .And. nMoedaD > 0,(nSalTitD + nJuros) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] == 'E1_TITVEN2' ) //Títulos a Vencer-Val. Nominal (Tasa Movimiento)
							jItems[self:aStruct[nX][1]] := IIf(dDataBase < StoD((cAlias)->E1_VENCREA),(nSalTitM + nJuros) * nSigno,0)
						ElseIf ( self:aStruct[nx][5] ==	'E1_VLRINTE')
							jItems[self:aStruct[nX][1]] := nJuros
						ElseIf ( self:aStruct[nx][5] == 'E1_VALOR' )
							jItems[self:aStruct[nX][1]] := IIf(dDataBase >= StoD((cAlias)->E1_VENCREA), IIf((cAlias)->E1_TIPO $ "RA " + MV_CRNEG, ((cAlias)->E1_SALTIT + (cAlias)->E1_JUROS)*-1, (cAlias)->E1_SALTIT + (cAlias)->E1_JUROS), 0)
						ElseIf ( self:aStruct[nx][5] == 'E1_NUMBCO' )
							jItems[self:aStruct[nX][1]] := (cAlias)->E1_NUMBCO
						ElseIf ( self:aStruct[nx][5] == 'E1_ACRESC' )
							jItems[self:aStruct[nX][1]] := (cAlias)->E1_JUROS
						ElseIf ( self:aStruct[nx][5] == 'E1_TAXADIA') //Tasa del Día
							jItems[self:aStruct[nX][1]] := nMoedaD
						ElseIf ( self:aStruct[nx][5] == 'E1_ATRASO' )
							jItems[self:aStruct[nX][1]] := dDatabase - StoD((cAlias)->E1_VENCREA)
						ElseIf ( self:aStruct[nx][5] == 'E1_SALDOFIN' )
							jItems[self:aStruct[nX][1]] := IIf((cAlias)->E1_TIPO $ "RA " + MV_CRNEG, ((cAlias)->E1_SALTIT + (cAlias)->E1_JUROS) *-1, (cAlias)->E1_SALTIT + (cAlias)->E1_JUROS)
						ElseIf ( self:aStruct[nx][5] == 'E1_VALORI' )
							jItems[self:aStruct[nX][1]] := ((cAlias)->E1_VALOR * nSigno)
						ElseIf ( self:aStruct[nx][5] == 'E1_VLORID' )
							If nMVPAR11 > 0
								jItems[self:aStruct[nX][1]] := (xMoeda((cAlias)->E1_VALOR,(cAlias)->E1_MOEDA,nMVPAR11,dDataBase,,0) * nSigno)
							EndIf
						ElseIf ( self:aStruct[nx][5] == 'E1_VLORIM' )
							If nMVPAR11 > 0
								jItems[self:aStruct[nX][1]] := (xMoeda((cAlias)->E1_VALOR,(cAlias)->E1_MOEDA,nMVPAR11,dDataBase,,IIf(!Empty((cAlias)->E1_TXMOEDA),(cAlias)->E1_TXMOEDA,RecMoeda((cAlias)->E1_EMISSAO,(cAlias)->E1_MOEDA))) * nSigno)
							EndIf
						ElseIf (self:aStruct[nx][5] == 'E1_BAIXA' )
							If ! Empty((cAlias)->E1_BAIXA)
								dbSkip()
								Loop
							EndIf
						ElseIf ( self:aStruct[nx][5] == 'E1_DESMOE' )
							//Moneda
							nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == AllTrim( Str( ( cAlias )->E1_MOEDA ) ) } )
							cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )
							jItems[self:aStruct[nX][1]] := cDescMon
						ElseIf ( self:aStruct[nx][3] == 'date' )
							jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAlias )->&( self:aStruct[nX][5] ) ) )
						Else
							jItems[self:aStruct[nX][1]] := (((cAlias)))->&(self:aStruct[nX][5])
						EndIf
					EndIf
				Next nX
			EndIf

			// Inclui os dados no objeto paea retorno ao SmartView
			self:oData:appendData( jItems )

			( cAlias )->( DbSkip( ) )
			nCount++
		End

		// Se não for o último registro indica que terá próxima página
		self:setHasNext( !( ( cAlias ) )->( EOF( ) ) )

		// Checa se o arquivo já esta aberto
		If ( SELECT( cAlias ) > 0 )
			( cAlias )->( DbCloseArea( ) )
		EndIf
	EndIf

	// fecha objeto
	If oQuery <> Nil
		oQuery:Destroy()
		oQuery := NIL
		FwFreeObj(oQuery)
	EndIf

Return( self:oData )


//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna la estructura de los campos
	
@Return object: self:oSchema
	
@author Cristian Gustavo
@since 03/10/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method getSchema() as object class AccountsReceivableTReportsBusinessObject
	Local nX as numeric

	//Estructura con los campos para el objeto de negocios.
	For nX:=1 To Len(self:aStruct)
		self:addProperty(self:aStruct[nX][1],self:aStruct[nX][2],self:aStruct[nX][3],self:aStruct[nX][4],self:aStruct[nX][5])
	Next nX

Return self:oSchema

//-------------------------------------------------------------------------------
/*{Protheus.doc} fSeparaMV
@description Función para separar y agregar a array los tipos de documentos
@author Cristian Días
@since 24/10/2023
@params cParaMV, Cadena con los tipos de documentos ejemplo 'NCC|RA'
@params aSepara, Array con los separadores ejemplo {'|','-',','}
@return jParams, Array, Arreglo con parámetros del grupo de preguntas
@return cQryPar, Character, Query con filtros de acuerdo al grupo de preguntas 
@version 1.0
*/
//-------------------------------------------------------------------------------
Static Function fSeparaMV(cParaMV, aSepara)

	Local nX 			as Numeric
	Local nY			as Numeric
	Local nJ			as Numeric
	Local lSepara		as Logical
	Local aCRNEG 		as Array

	nX 				:= 0
	nY				:= 0
	nJ				:= 0
	lSepara			:= .F.
	aCRNEG 			:= {}

	Default cParaMV	:= ''
	Default aSepara := {'|', ',', '-'}

	For nX = 1 to Len(aSepara)
		If lSepara
			For nY := 1 to Len(aCRNEG)
				If AT(aSepara[nX], aCRNEG[nY])
					aRCANT := STRTOKARR(aCRNEG[nY], aSepara[nX])
					ADEL(aCRNEG, nY)
					For nJ := 1 To Len(aRCANT)
						IIf(nJ == 1,aCRNEG[Len(aCRNEG)] := aRCANT[nJ], AADD(aCRNEG, aRCANT[nJ]))
					Next
				EndIf
			Next
		Else
			If AT(aSepara[nX], cParaMV)
				aCRNEG := STRTOKARR(cParaMV, aSepara[nX])
				lSepara:= .T.
			EndIf
		EndIf
	Next

Return aCRNEG
