#include 'tlpp-core.th'
#include 'catalogsdata.ch'

namespace tr.Catalogs
using namespace tr.util

/*/{Protheus.doc} CatalogsData
Definicion de los metodos de la clase
@type class
@version  1
@author José González
@since 23/03/2021
/*/
Class CatalogsData
	Data tableNick As Character

	Public Method new()
	Public Method getCatalogsAdapter()
EndClass

/*/{Protheus.doc} CatalogsData::new
Constructor de la clase
@type method
@version  1
@author José González
@since 23/03/2021
/*/
Method new() class CatalogsData
return

/*/{Protheus.doc} CatalogsData::getCatalogsAdapter
Prepara y retorna el detalle del titulo seleccionado
@type method
@version  1
@author José González
@since 23/03/2021
/*/
method getCatalogsAdapter(cTable,aCampos,cFilter,aCpos,cTipo,cSpecif,cFiltroq,cCatalogo,cfilterA,cTitle) class CatalogsData
	Local oCatalogs := JsonObject():New()
	Local oError	:= JsonObject():New()
	local nPos := 1 As Numeric
	local nI := 1 As Numeric
	local nJ := 1 As Numeric
	Local aValues:= {} As Array
	Local lItems  := .F.
	Local cFilF3H :=  ""
	local nUsado := 0 As Numeric
	local aSXBHeader := {} As Array
	Local cFiltro := "" As Character
	local nCnt := 1	As Numeric
	local cFilF3I As Character
	local aSXBCols := {} As Array
	local lPesqComp := .F. As Logical
	local nCpo2 :=1 as numeric
	local nCpo1 :=1 as numeric
	local nValor As Numeric
	local nCont:= 1 As Numeric
	local aArea  := GetArea()
	local afjo := {} As Array
	local cValue := "" As Character
	local cLabel := "" As Character
	local lFiltro := .T.
	Local nX := 1 As Numeric
	Local aItems	:= {} As Array
	Local aColumns	:= {} As Array
	Local cColFil 	:= IIF(Substr(cTable,1,1) == "S",Substr(cTable,2,3),Substr(cTable,1,3))
	Local cFilial   := xFilial(cTable)
	Local n5 := 1 As Numeric
	Local aSX5 := IIF(!Empty(cFilter) .And. cTable == "SX5" .And. Substr(cFilter,12,2) == cCatalogo, FWGetSX5(Substr(cFilter,12,2)), {}) As Array
	Local nTamSec := 0

	Default cfilterA := ""
	
	If cFilter == ""
		cFilter:= ".T."
	EndIf

	IF cTipo == "DB"
		If EMPTY(cfiltroq) .and.  (!EMPTY(cfilterA))
			lFiltro := .F.
		ENDIF

		If Len(aSX5) > 0
			For n5 := 1 To Len(aSX5)
				If aSX5[n5][1] == cFilial
					cValue := alltrim(aSX5[n5][3])
					cLabel := Alltrim(aSX5[n5][3]+ " -") + Alltrim(aSX5[n5][4])
					If lFiltro
						If EMPTY(cfiltroq) .or. (!EMPTY(cfiltroq) .AND. UPPER(cfiltroq) $ UPPER(clabel)  ) 
							Aadd(aValues,JsonObject():new())
							nPos := Len(aValues)
							aValues[nPos]['value']	:= cValue
							aValues[nPos]['label']	:= cLabel
						EndIf
					Else
						IF 	cfilterA $ cvalue
							oCatalogs['value']	:= cValue
							oCatalogs['label']	:= cLabel
							Exit
						EndIf
					EndIf
					IF !VAZIO(cLabel) .OR. !VAZIO(cValue) //Esta bandera es declarada por default como falsa .F., y solamente es activada cuando existe el catalogo a ser buscado y/o no se obtienen un registro igual al aplicado a la variable cfilterA (Texto escrito en el campo por el cliente), estoy ayuda en el control de los mensajes de advertencia (warning)
						lItems := .T.
					ENDIF
				EndIf
			Next 
		Else
			dbSelectArea(cTable)
			(cTable)->(dbSetOrder(1))
			IF cTable == "SX5"
				IF !(cTable)->(MsSeek(xfilial("SX5")+cCatalogo))
					(cTable)->(dbGoTop())
					(cTable)->(MsSeek(xfilial("SX5")))
				ENDIF
			ELSE
				(cTable)->(dbGoTop())
				(cTable)->(MsSeek(cFilial))
			EndIf
			While (cTable)->(!Eof()) .And. (&(cTable+"->"+ cColFil + "_FILIAL") == cFilial)
				If &(cFilter) 
					cValue :=  &(aCampos[1])
					If LEN(aCampos) > 1
						for nJ:= 2 to LEN(aCampos)
							cValue += "-" + &(aCampos[nJ])
						Next
					EndIf
					cLabel:= ""

					If cTable == "SX5" 
						cValue := alltrim(&(aCampos[1]))
						IF 	!VAZIO(cfilterA)
							IF cfilterA == cvalue
								For nI:= 1 to len(aCpos)
									cLabel+=alltrim(Iif( nI == LEN(aCpos),&(aCpos[nI]),&(aCpos[nI])+" - "))
								Next
								oCatalogs['value']	:= cvalue
								oCatalogs['label']	:= clabel
								Exit
							EndIf
						Else
							For nI:= 1 to len(aCpos)
								cLabel+=alltrim(Iif( nI == LEN(aCpos),&(aCpos[nI]),&(aCpos[nI])+" - "))
							Next
						EndIF
					ElseIf cTable =="FJS"
						cValue := alltrim(&(aCampos[1]))
						IF 	!VAZIO(cfilterA)
							IF alltrim(cfilterA) $ alltrim(cvalue)
								For nI:= 1 to len(aCpos)
									cLabel+= Iif( nI == LEN(aCpos),alltrim(&(aCpos[nI])),alltrim(&(aCpos[nI]))+"-")
								Next
							EndIF
						Else
							For nI:= 1 to len(aCpos)
								cLabel+=Iif( nI == LEN(aCpos),alltrim(&(aCpos[nI])),alltrim(&(aCpos[nI]))+"-")
							Next
						EndIF								
					Else
						For nI:= 1 to len(aCpos)
								cLabel  += alltrim ( &(cTable+"->"+aCpos[nI]) )+"-"
						Next	
					endif
					If lFiltro
						If EMPTY(cfiltroq) .or. (!EMPTY(cfiltroq) .AND. UPPER(cfiltroq) $ UPPER(clabel)  ) 
							Aadd(aValues,JsonObject():new())
							nPos := Len(aValues)
							aValues[nPos]['value']	:= cvalue
							aValues[nPos]['label']	:= clabel
						EndIf
					Else
						IF 	cfilterA $ cvalue
							oCatalogs['value']	:= cvalue
							oCatalogs['label']	:= clabel
							Exit
						EndIf
					EndIf
					IF !VAZIO(clabel) .OR. !VAZIO(cvalue) //Esta bandera es declarada por default como falsa .F., y solamente es activada cuando existe el catalogo a ser buscado y/o no se obtienen un registro igual al aplicado a la variable cfilterA (Texto escrito en el campo por el cliente), estoy ayuda en el control de los mensajes de advertencia (warning)
						lItems := .T.
					ENDIF
				EndIf
				(cTable)->(dbSkip())

			EndDo
		EndIf
	ElseIF cTipo == "RE" .And.  cSpecif == "FJNCON()"
		If EMPTY(cfiltroq) .and.  (!EMPTY(cfilterA))
			lFiltro := .f.
		EndIF
		dbSelectArea(cTable)
		(cTable)->(dbSetOrder(1))
		(cTable)->(dbGoTop())
		While (cTable)->(!Eof())
		IF xFilial(cTable) == FJN->FJN_FILIAL 
			If &(cFilter)
				aFjo :=	GetAdvFVal("FJO",{"FJO_BLOCK","FJO_NOME"},xFilial("FJO")+&(aCampos[1]),1,"")
				If afjo[1] == "1"
					LOOP
					(cTable)->(dbSkip())
				endif
				cValue := alltrim(&(aCampos[1]))
				If LEN(aCampos) > 1
					for nJ:= 2 to LEN(aCampos)
						cvalue	+= "|" + alltrim( &(aCampos[nJ]) )
					Next
				EndIf
				cLabel := ""
				For nI:= 1 to LEN(aCampos)
					cLabel	+=  alltrim(&(aCampos[nI])) +"-"
				Next
				cLabel	+=  afjo[2]
				If lFiltro
					If EMPTY(cfiltroq) .or. (!EMPTY(cfiltroq) .AND. ( UPPER(cfiltroq) $ UPPER(cvalue) .OR. UPPER(cfiltroq) $ UPPER(clabel)) )
						Aadd(aValues,JsonObject():new())
						nPos := Len(aValues)
						aValues[nPos]['value']	:= cvalue
						aValues[nPos]['label']	:= alltrim(clabel)
					EndIf
				Else
					IF 	cfilterA == cvalue
						oCatalogs['value']	:= cvalue
						oCatalogs['label']	:= alltrim(clabel)
						Exit
					EndIf
				EndIf
			EndIf
		ENDIF
		(cTable)->(dbSkip())
		EndDo
	ELSEIF cTipo == "RE" .And. cSpecif == "F087ACEC" //Obtener las compensaciones por medio de consulta estandar
		If !EMPTY(cfiltroq) .OR. !EMPTY(cfilterA)
			lFiltro := .f.
		EndIF

		If lFiltro
			aItems := F087ACEC(lFiltro,cfiltroq,cfilterA)
			FOR nX := 1 TO LEN(aItems)
				AADD(aColumns,JsonObject():new())
				nPos := LEN(aColumns)
				aColumns[nPos]["filial"]		:= aItems[nX][1]
				aColumns[nPos]["date"]			:= aItems[nX][2]
				aColumns[nPos]["compen"]		:= aItems[nX][3]
				aColumns[nPos]["coinCompen"]	:= aItems[nX][4]
				aColumns[nPos]["valueCompen"]	:= aItems[nX][5]
				aColumns[nPos]["value"]			:= aItems[nX][3]+"-"+DTOS(aItems[nX][2])+"-"+ALLTRIM(STR(aItems[nX][5]))+"-"+ALLTRIM(STR(aItems[nX][4]))+"-"+ALLTRIM(STR(aItems[nX][6]))
				aColumns[nPos]["label"]			:= aItems[nX][3]
			NEXT nX
		ELSE	
			aItems := F087ACEC(lFiltro,cfiltroq,cfilterA)
			IF !VAZIO(cfiltroq) .or. !VAZIO(cfilterA)
				FOR nX := 1 TO LEN(aItems)
					AADD(aColumns,JsonObject():new())
					nPos := LEN(aColumns)
					aColumns[nPos]["filial"]		:= aItems[nX][1]
					aColumns[nPos]["date"]			:= aItems[nX][2]
					aColumns[nPos]["compen"]		:= aItems[nX][3]
					aColumns[nPos]["coinCompen"]	:= aItems[nX][4]
					aColumns[nPos]["valueCompen"]	:= aItems[nX][5]
					aColumns[nPos]["value"]			:= aItems[nX][3]+"-"+DTOS(aItems[nX][2])+"-"+ALLTRIM(STR(aItems[nX][5]))+"-"+ALLTRIM(STR(aItems[nX][4]))+"-"+ALLTRIM(STR(aItems[nX][6]))
					aColumns[nPos]["label"]			:= aItems[nX][3]
				NEXT nX
			ENDIF
			if !VAZIO(cfilterA) .and. LEN(aItems) == 1
					oCatalogs['value']	:= cfilterA
					oCatalogs['label']	:= aColumns[LEN(aItems)]["label"]
					return oCatalogs
			ENDIF
		EndIf
		oCatalogs['items']:= aColumns
		Return oCatalogs
	ElseIF cTipo == "RE"
		If EMPTY(cfiltroq) .and.  (!EMPTY(cfilterA))
			lFiltro := .f.
		EndIF
		cFilF3H  := xFilial("F3H")
		dbSelectArea("F3H")
		F3H->(dbGoTop())

		While !Eof()
			If !F3H->(F3H_FILIAL+F3H_CODIGO) == (cFilF3H+cTable)
				dbSkip()
				loop
			Else 
				nUsado += 1
				aAdd(aSXBHeader,{Alltrim(Capital(F3H_DESCPO)), ; //# 01
				Alltrim(F3H_CAMPOS), ; //# 02
				Alltrim(F3H_PICTUR), ; //# 03
				F3H_TAMAN, ; //# 04
				F3H_DECIMA, ; //# 05
				NIL, ; //# 06
				NIL, ; //# 07
				F3H_TIPO, ; //# 08
				NIL, ; //# 09
				"R", ; //# 10 Real ou Virtual
				NIL, ; //# 11 cbox
				NIL, ; //# 12 relacao
				NIL, ; //# 13 when
				"V" } ) //# 14 visual ou altera
				dbSkip()
			EndIf
		EndDo
		dbSelectArea( "F3I" )
		F3I->(dbSetOrder(1))
		// Pesquisa se ha tabela com F3I_FIL preenchida conforme cFOrigem
		nTamSec := GetSx3Cache("F3I_SEQUEN","X3_TAMANHO")
		If ! F3I->( dbSeek( xFilial( "F3I" ) + cTable  + STRZERO(1,IIF(nTamSec <> Nil,nTamSec,5)) ) )
			F3I->( dbSeek( xFilial( "F3I" ) + cTable ) )
		EndIf
		cFilF3I := xFilial("F3I")
		While ! Eof() .And. F3I->(F3I_FILIAL+F3I_CODIGO) == ( cFilF3I + cTable )
			If Empty( cFiltro ) .Or. Eval( cFiltro )
				AADD(aSXBCols,Array(Len(aSXBHeader)+1))
				For nCnt := 1 To Len(aSXBHeader)
					cCampo := Alltrim(aSXBHeader[nCnt,02])
					If aSXBHeader[nCnt,10] == "R" .And. cCampo == "F3I_SEQUEN"
						aSXBCols[Len(aSXBCols)][nCnt] := FieldGet(FieldPos(cCampo))
					ElseIf lPesqComp .And. At("+", cCampo) > 0
						aSXBCols[Len(aSXBCols)][nCnt] := cCpoPesq
					Else
						nCpo2 := (aSXBHeader[nCnt,04] )
						If aSXBHeader[nCnt,08] == "N"
							nValor := Val( SubStr(F3I_CONTEU,nCpo1,nCpo2) )
						ElseIf aSXBHeader[nCnt,08] == "D"
							nValor := Ctod( SubStr(F3I_CONTEU,nCpo1,nCpo2) )
						Else
							nValor := SubStr(F3I_CONTEU,nCpo1,nCpo2)
						EndIf
						aSXBCols[Len(aSXBCols)][nCnt] := nValor
						nCpo1 += nCpo2
					EndIf
				Next nCnt
				aSXBCols[Len(aSXBCols)][nUsado+1] := .F.
				nCont += 1
				nCpo1 := 1
			Endif
			dbSkip()
		EndDo
		RestArea( aArea )
		For nI := 1 to len(aSXBCols)
			cValue	:= aSXBCols[nI][1]
			cLabel := ""
			For nJ:=1 to (len(aSXBCols[nI])-1)
				If alltrim(aSXBCols[nI][nJ]) <> ""
					cLabel	+= alltrim(aSXBCols[nI][nJ]) + " - "
				EndIf
			Next
			If lFiltro
				If EMPTY(cFiltroq) .or. (!EMPTY(cFiltroq) .AND. UPPER(cFiltroq) $ UPPER(cLabel)   )
					Aadd(aValues,JsonObject():new())
					nPos := Len(aValues)
					aValues[nPos]['value']	:= cValue
					aValues[nPos]['label']	:= cLabel
				EndIf
			Else
				IF 	cfilterA == cvalue
					oCatalogs['value']	:= cvalue
					oCatalogs['label']	:= clabel
					Exit
				EndIf
			EndIF
		Next
	EndIf
	If lFiltro
		oCatalogs ['items' ]:= aValues
		IF VAZIO(aValues) .and. !lItems //Habilitar un mensaje de error cuando exista el catalogo pero no se obtenga datos
			oError["type"] := "warning"
			oError["message"] := STR0001+" "+IIF(cTipo=="DB",STR0003+" "+IIF(!VAZIO(cTable),ALLTRIM(cTitle)+" - "+cTable,cTable),STR0004+" "+IIF(!VAZIO(cTable),ALLTRIM(cTitle)+" - "+cTable,cTable)) //STR0001 - No se encontraron items , STR0003 -para la tabla , STR0004 - para el catalogo
			oError["detailedMessage"] := ""

			oCatalogs["hasInformation"] :=.T.
			oCatalogs["formatError"] := oError
		ENDIF
	EndIf
	IF oCatalogs:tojson() == '{}' //Habilitar un mensaje cuando no exista un catalogo
		oError["type"] := "warning"
		IF ALLTRIM(cTable)=="SX5"
			DbSelectArea("SX5")
			SX5->(DbSetOrder(1))//X5_FILIAL+X5_TABELA
			MsSeek(xFilial('SX5') + '00'+ALLTRIM(cCatalogo))
			oError["message"] := STR0002+": "+IIF(!VAZIO(cTable),RTRIM(X5Descri())+" - "+cTable+" .",+cTable+" .") //STR0002 - El valor no existe en el catálogo
		ELSEIF ALLTRIM(cTable)==ALLTRIM(cCatalogo)
			oError["message"] := STR0002+": "+IIF(!VAZIO(cTable),ALLTRIM(cTitle)+" - "+cCatalogo+" .",+cCatalogo+" .") //STR0002 - El valor no existe en el catálogo
		ELSE
			oError["message"] := STR0002+": "+cCatalogo+" ." //STR0002 - El valor no existe en el catálogo
		ENDIF
			
		oError["detailedMessage"] := ""

		oCatalogs["hasInformation"] :=.T.
		oCatalogs["formatError"] := oError
	ENDIF
Return oCatalogs

/*/{Protheus.doc} F087ACEC
Retorna las compensaciones , este metodo es una copia del metodo F087ACEC de la FINA087A 
@type function
@version  1
@author luis.aboytes
@since 29/9/2022
/*/
Static Function F087ACEC(lFiltro,cfiltroq,cfilterA)
	Local aItems    	:= {}  	AS ARRAY
	Local aControl  	:= {}	AS ARRAY
	Local cTemp			:= GetNextAlias() AS CHARACTER
	Local cTmp			:= "" 	AS CHARACTER
	Local nCont			:= 0	AS NUMERIC
	Local cFiltro		:= "" 	As CHARACTER
	Local aFiltro       := STRTOKARR(cfilterA,"-")

	DEFAULT lFiltro := .T.
	DEFAULT cfiltroq:= ""
	DEFAULT cfilterA:= ""

	cFiltro += "% SE5.E5_FILIAL ='"+xFilial("SE5")+"' "
	cFiltro += " AND SE5.E5_RECPAG  ='R' "
	cFiltro += " AND SE5.E5_TIPODOC = 'BA' "
	cFiltro += " AND SE5.E5_MOTBX   = 'CEC' "
	cFiltro += " AND SE5.E5_SITUACA = ' ' "
	cFiltro += " AND SE5.E5_ORIGEM  = 'FINA450' "
	cFiltro += " AND SE5.E5_RECCMP  = ' ' "
	cFiltro += " AND SE5.D_E_L_E_T_ = ''"

	IF !lFiltro .AND. !VAZIO(cfiltroq)
		cFiltro += " AND (SE5.E5_IDENTEE LIKE '%"+ALLTRIM(cfiltroq)+"%') %"
	elseif !VAZIO(cfilterA)
		cFiltro += " AND (SE5.R_E_C_N_O_ = '"+ALLTRIM(aFiltro[LEN(aFiltro)])+"') %"
	ELSE
		cFiltro += '%'
	ENDIF

	BEGINSQL ALIAS cTemp
		SELECT
			SE5.E5_FILIAL, SE5.E5_DATA, SE5.E5_IDENTEE, SE5.E5_MOEDA, SE5.E5_VALOR, SE5.R_E_C_N_O_
		FROM
			%Table:SE5% SE5
		WHERE %exp:cFiltro%
			AND NOT EXISTS(SELECT NULL
				FROM %Table:SEL% SEL
				WHERE SEL.EL_IDENTEE = SE5.E5_IDENTEE
				AND SEL.EL_FCHIDEN = SE5.E5_DATA
				AND SEL.EL_CANCEL <> 'T'
				AND SEL.%notdel%)
		GROUP BY  
			SE5.E5_FILIAL, SE5.E5_DATA, SE5.E5_IDENTEE, SE5.E5_MOEDA, SE5.E5_VALOR, SE5.R_E_C_N_O_
		ORDER BY
			SE5.E5_FILIAL, SE5.E5_DATA, SE5.E5_IDENTEE, SE5.E5_MOEDA
	ENDSQL

	(cTemp)->(dbGoTop())
				
	//-- Genera arreglo con los registros filtrados
	Do While (cTemp)->(!EOF())
		If cTmp <> (cTemp)->(E5_FILIAL + E5_DATA + E5_IDENTEE + E5_MOEDA)
			aAdd(aItems,{(cTemp)->E5_FILIAL, STOD((cTemp)->E5_DATA), (cTemp)->E5_IDENTEE, Val((cTemp)->E5_MOEDA), (cTemp)->E5_VALOR, (cTemp)->R_E_C_N_O_})
			aAdd(aControl,{(cTemp)->E5_FILIAL, STOD((cTemp)->E5_DATA), (cTemp)->E5_IDENTEE, Val((cTemp)->E5_MOEDA), (cTemp)->E5_VALOR, (cTemp)->R_E_C_N_O_})
			cTmp := (cTemp)->(E5_FILIAL + E5_DATA + E5_IDENTEE + E5_MOEDA)
			nCont++
		Else
			aItems[nCont][5] += (cTemp)->E5_VALOR
			aControl[nCont][5] += (cTemp)->E5_VALOR
		EndIf
		(cTemp)->(DbSkip())
	EndDo

	(cTemp)->(dbCloseArea())

Return aItems
