#Include "PROTHEUS.CH"
#Include "AP5MAIL.CH"
#include "FINA475.ch"

Static __aStruct  := NIL
Static __l475Aut  := NIL
Static __lFstStru := NIL
Static __oFinA475 := NIL
Static __oPrepSt1 := NIL
Static __oPrepSt2 := NIL
Static __oPrepSt3 := NIL
Static __oPrepSt4 := NIL
Static __oPrepSt5 := NIL
Static __oPrepSt6 := NIL
Static __oPrepSt7 := NIL
Static __oPrepSt8 := NIL
Static __oPrepSt9 := NIL
Static __oPrepStA := NIL
Static __oPrepStB := NIL
Static __oPrepStC := NIL
Static __oPrepStD := NIL
Static __oPrepStE := NIL
Static __oPrepStF := NIL
Static __oPrepStG := NIL
Static __oPrepStH := NIL
Static __oPrepStI := NIL
Static __oPrepStJ := NIL
Static __oPrepStK := NIL
Static __oPreStL  := NIL
Static __oSE5     := NIL
Static __oSE5C    := NIL
Static __oSE5Chq  := NIL
Static __oEstBl	  := NIL
Static __oGrOri	  := NIL
Static __oBlkOri  := NIL
Static __cUUIDFK5 := NIL
Static __nTamRgMt := NIL
Static __oMdlMov  := NIL
Static __lTipMat  := NIL
Static __lF475AGR := NIL
Static __lF475PGR := NIL
Static __nTamSqMt := NIL
Static __lF475Nat := NIL
Static __lExtAPI  := NIL
Static __lCposCD  := NIL
Static __lHasAPI  := NIL		 // Define se existiu algum banco que processou via API para atualizar o parâmetro
Static __cSeqMatc := ""
Static __lFGrvSEF := Nil
Static __l475PCan := Nil
Static __nTDcExt  := NIL

//----------------------------------------------------------------------
/*/{Protheus.doc} Fina475

	Job de importação de extratos

	@type  Function
	@author pequim
	@since 25/08/2022
	@version 12.1.2310

/*/
//----------------------------------------------------------------------
Function Fina475(aParam, lAutomato, lAutoDic, lAutoLock)
	
	Local nX as Numeric
	Local lRet as Logical
	Local cJobTime as Character

	// Executa apenas se for chamado pelo Schedule
	// a variavel abaixo e util para debug da rotina via execucao normal
	Private aFA205R   as Array
	Private aMsgSch   as Array
	Private cCadastro as Character
	Private lExecJob  as Logical

	DEFAULT aParam    := {}
	DEFAULT lAutomato := .F.
	DEFAULT lAutoDic  := .F.
	DEFAULT lAutoLock := .F.

	lRet := .T.
	nX := 0

	aFA205R  := {}
	aMsgSch  := {}
	lExecJob := .F.
	cCadastro  := STR0001	//"Importação automática de extratos bancários."
	__l475Aut  := lAutomato
	__lAutoDic := lAutoDic
	__lAutLock := lAutoLock
	cJobTime   := ""
	__lHasAPI  := .F.

	If lRet
		lRet := F475Process(aParam)		//Verifica as subcontas com processo de importação
	Endif	

	// Grava a data da execução do Job para controle do processo de importação por API
	If lRet	.and. __lExtAPI .and. __lHasAPI
		cJobTime := FWTimeStamp(5, DATE(), TIME())
	 	cJobTime := StrTran(cJobTime, 'T', ' ')
	 	cJobTime := StrTran(cJobTime, 'Z', '')
	 	PUTMV('MV_FNEXTDT', cJobTime)
	EndIf

	F475Clean()

Return lRet


//------------------------------------------------------------------------
/*/{Protheus.doc} F475Process
	Processo para execução do JOB

	@author pequim
	@since 26/08/2022
	@version 12.1.2310

	@param aparam, Array, Informações de Empresa, Filial e usuário

	@return lRet, Logical, Informa se o processo foi bem sucedido ou não

/*/
//------------------------------------------------------------------------
Function F475Process(aParam as Array)

	Local nX as Numeric
	Local lRet as Logical

	nX := 0
	lRet := .T.

	// ao passar parametros considera que foi chamado pelo schedule
	lExecJob := .T.

	DbSelectArea("QLC")
	DbSelectArea("QLD")

	If __lExtAPI == NIL
		__lExtAPI := SEE->(ColumnPos("EE_EXTAPI")) > 0 .And. FindClass('totvs.protheus.backoffice.fin.banks.BanksStatement')
	EndIf

 	If F474DicOk() .and. !__lAutoDic
		If  LockByName( "FINA475", .T., .T. ) .and. !__lAutLock
			// Executa o processo
			BatchProcess(cCadastro, cCadastro , "FA475JOB" , { || FA475JOB(aParam) } , { || .F. } )
		Else
			FwLogMsg("INFO", /*cTransactionId*/, "FINA475", FunName(), "", "FINA475", STR0008 + cFilant + STR0009) //"Importação automática de extratos bancários da filial "### " está executando em outra thread "
			lRet := .F.
		EndIf
	else
		aadd(aMsgSch,{" ", STR0004})	//"Dicionário desatualizado."
		aadd(aMsgSch,{" ", STR0005})	//"Seu dicionário se encontra desatualizado, não contando com a nova estrutura criada para Importação de Extratos para Conciliação."
		aadd(aMsgSch,{" ", STR0006})	//"Favor verificar atualizações do cadastro de Comunicação Remota (SEE)"

		FwLogMsg("INFO", "LAST", "FINA475" , FunName(), "01", "FINA475", STR0037,,,aMsgSch) 	//"IMPORTACAO DE EXTRATO VIA JOB"
		lRet := .F.
	Endif

Return lRet


//------------------------------------------------------------------------
/*/{Protheus.doc} FA475JOB
	Processo para execução do JOB

	@author pequim
	@since 26/08/2022
	@version 12.1.2310

	@param aparam, Array, Informações de Empresa, Filial e usuário
	
	@return lRet, Logical, Informa se o processo foi bem sucedido ou não

/*/
//------------------------------------------------------------------------
Static Function FA475JOB(aParam as Array)

	Local aArq      as Array
	Local aConfig1  as Array
	Local aConfig2  as Array
	Local aProcExt  as Array
	Local aRotAuto  as Array
	Local cAgencia  as Character
	Local cAliasSEE as Character
	Local cBanco    as Character
	Local cConta    as Character
	Local cDirArq   as Character
	Local cDirBkp   as Character
	Local cDirCfg   as Character
	Local cDirInc   as Character
	Local cFilAtu   as Character
	Local cFilProc  as Character
	Local cIdProc   as Character
	Local cItem     as Character
	Local cQuery    as Character
	Local cRetorno  as Character
	Local cSubCta   as Character
	Local cTipoCon  as Character
	Local cErroProc as Character
	Local lA6MsBlql as Logical
	Local lBarra    as Logical
	Local lOk       as Logical
	Local nA        as Numeric
	Local nArquivo  as Numeric
	Local nC        as Numeric
	Local nX        as Numeric
	Local cDescFail	as Character
	Local lErroImp	as Logical
	Local cErroImp	as Character

	aArq      := {}
	aConfig1  := {}
	aConfig2  := {}
	aProcExt  := {}
	aRotAuto  := {}
	cAgencia  := ""
	cAliasSEE := "" //Alias temporario dos banco que serao executados
	cBanco    := ""
	cConta    := ""
	cDirArq   := "" //Diretório do arquivo a ser processado (extrato)
	cDirBkp   := "" //Diretório de backup dos arquivos processados com sucesso (extrato)
	cDirCfg   := "" //Diretório do arquivo de configuração do extrato (extrato)
	cDirInc   := "" //Diretório dos arquivos não processados por inconsistencia (extrato)
	cFilAtu   := cFilAnt
	cFilProc  := ""
	cIdProc   := ""
	cItem     := Replicate("0",TamSx3("IG_ITEM")[1])
	cMsg      := ""
	cQuery    := "" // query de bancos que serao executados automaticamente
	cRetorno  := ""
	cSubCta   := ""
	cErroProc := ""
	lA6MsBlql := SA6->(ColumnPos("A6_MSBLQL")) > 0
	lBarra    := isSrvUnix()
	nA        := 0
	nArquivo  := 0
	nC        := 0
	nX        := 0
	cDescFail := ""
	lErroImp  := SIF->(ColumnPos("IF_ERROIMP")) > 0
	cErroImp  := ""


	If Type('aProcAuto') == 'U'
		aProcAuto := {}
	Endif

	DbSelectArea("SA6")
	SA6->( Dbsetorder(1))
	DbSelectArea("SEE")
	SEE->( Dbsetorder(1))

	//Contas programadas para recebimento automatico ou ambos
	cQuery := "SELECT SEE.R_E_C_N_O_ REGSEE "
	cQuery += "FROM " + RetSqlName("SEE") + " SEE "
	cQuery += "INNER JOIN "+ RetSqlName("SA6") + " SA6 "
	cQuery += "ON SA6.A6_FILIAL = '" + xFilial("SA6") + "' "
	cQuery += "AND SA6.A6_COD = SEE.EE_CODIGO "
	cQuery += "AND SA6.A6_AGENCIA = SEE.EE_AGENCIA "
	cQuery += "AND SA6.A6_NUMCON = SEE.EE_CONTA "
	cQuery += "WHERE EE_FILIAL = '" + xFilial("SEE") + "' "
	cQuery += "AND (EE_EXTJOB = '1' OR EE_EXTCONA IN ('1','2')) AND SEE.D_E_L_E_T_ = ' '  "

	If lA6MsBlql
		cQuery += "AND (SA6.A6_BLOCKED = '2' OR SA6.A6_MSBLQL <> '1') "
	Else
		cQuery += "AND SA6.A6_BLOCKED = '2' "
	Endif
	cQuery += "AND SA6.D_E_L_E_T_ = ' ' "

	If __l475Aut		//Automato
		If __oPrepSt9 == Nil
			cQuery += "AND SEE.EE_CODIGO = ? "
			cQuery += "AND SEE.EE_AGENCIA = ? "
			cQuery += "AND SEE.EE_CONTA = ? "
			cQuery += "AND SEE.EE_SUBCTA = ? "

			cQuery := ChangeQuery(cQuery)
			__oPrepSt9 := FwPreparedStatement():New(cQuery)
		Endif

		__oPrepSt9:SetString(1,	aParam[3])
		__oPrepSt9:SetString(2,	aParam[4])
		__oPrepSt9:SetString(3,	aParam[5])	
		__oPrepSt9:SetString(4,	aParam[6])	

		cQuery	:= __oPrepSt9:GetFixQuery()
	Else
		cQuery := ChangeQuery(cQuery)
	Endif

	cAliasSEE := GetNextAlias()
	
	MPSysOpenQuery( cQuery, cAliasSEE )
	
	While (cAliasSEE)->(!Eof())

		SEE->(Dbgoto((cAliasSEE)->REGSEE))

		cFilProc := SEE->EE_EXTFPRC
		cBanco   := SEE->EE_CODIGO
		cAgencia := SEE->EE_AGENCIA
		cConta   := SEE->EE_CONTA
		cSubCta  := SEE->EE_SUBCTA
		cTipoCon := SEE->EE_EXTCONA

		//---------------------------------------------------------------
		// IMPORTAÇÃO DOS AQUIVOS DE EXTRATO
		//---------------------------------------------------------------
		If SEE->EE_EXTJOB == '1' 		
			//verifica se todos os parametros necessarios foram preechindos e grava no log
			If !FA475OK()
				(cAliasSEE)->( Dbskip())
				Loop
			Endif

			cErroProc := ""
			
			If __lExtAPI .And. SEE->EE_EXTAPI == '2' // Conciliação por API
				__lHasAPI := .T.
				aMsgSch  := {}
				cFilAtu  := cFilAnt
				cRetorno := ""
				cErroProc := STR0050 // Erro ao processar extrato por API
				cIdProc  := F474ProxNum("SIF")
				lRet 	 := getApiExtrato(cFilProc, cBanco, cAgencia, cConta, cSubCta, cIdProc, aMsgSch)
				
				If lRet
					aAdd(aProcExt, cIdProc)
					nOpca := 1
					cErroProc := ""
				EndIf
			ElseIf __lExtAPI .And. SEE->EE_EXTAPI != '2' // Conciliação por Arquivo
				/*
				EE_EXTJOB 	Ativa Import. Automática 
				EE_EXTCONA	Conciliação Automática   
				EE_EXTFPRC	Filial de Processamento  
				EE_EXTARQR	Extensao Arquivo Extrato 
				EE_EXTARQC	Arquivo Config. Extrato  
				EE_EXTDIRC	Dir. Arquivo Configuração
				EE_EXTDIRA	Dir. Extrato a Processar 
				EE_EXTDIRB	Dir. Extratos Processados
				EE_EXTDIRF	Dir. Falha Processamento 
				*/
				//Lê os arquivos do diretorio configurado
				cDirCfg	 := StrTran(Alltrim(SEE->EE_EXTDIRC), "\", "/")
				cDirArq	 := StrTran(Alltrim(SEE->EE_EXTDIRA), "\", "/")
				cDirBkp  := StrTran(Alltrim(SEE->EE_EXTDIRB), "\", "/")
				cDirInc	 := StrTran(Alltrim(SEE->EE_EXTDIRF), "\", "/")
				If !lBarra
					cDirCfg	 := StrTran(Alltrim(SEE->EE_EXTDIRC), "/", "\")
					cDirArq	 := StrTran(Alltrim(SEE->EE_EXTDIRA), "/", "\")
					cDirBkp  := StrTran(Alltrim(SEE->EE_EXTDIRB), "/", "\")
					cDirInc	 := StrTran(Alltrim(SEE->EE_EXTDIRF), "/", "\")			
				Endif
				
				cFilAtu  := cFilAnt
				cFilAnt  := cFilProc
				
				If __l475Aut		//Automato
					aArq := Directory(cDirArq + aParam[7])
				Else
					aArq := Directory(cDirArq + "*." + SEE->EE_EXTARQR)
				Endif
			
				If (nArquivo := Len(aArq)) > 0
					For nA := 1 to nArquivo
						//Armazena o nome do arquivo nos parametros
						cRetorno := cDirArq+aArq[nA,1]
						
						//Controle de mensagens de erro
						aMsgSch := {}
						
						//controle de titulos baixados
						aRotAuto := {}

						cDirCfg := ALLTRIM(SEE->EE_EXTDIRC) + ALLTRIM(SEE->(EE_EXTARQC))
						cDirExt := ALLTRIM(SEE->EE_EXTDIRA) + aArq[nA,1]
						cMsg	:= STR0039 + " - " + aArq[nA,1]			//"EXTRATO VIA JOB"

						AADD(aRotAuto, cBanco )
						AADD(aRotAuto, cAgencia )
						AADD(aRotAuto, cConta )
						AADD(aRotAuto, cSubCta )
						AADD(aRotAuto, cMsg )
						AADD(aRotAuto, cDirCfg )
						AADD(aRotAuto, cDirExt )
						AADD(aRotAuto, SEE->EE_FILIAL )

						//Realiza a importação do extrato
						FINA474(aRotAuto,3)

						If (lOk := Len(aMsgSch) == 0) .OR. (STR0020 $ aMsgSch[1])		//"Arquivo de Extrato já importado"

							If lOk
								aadd(aProcExt,SIG->IG_IDPROC)
							Endif

							cArq := aArq[nA,1]
							
							If !_CopyFile(cRetorno, cDirBkp + cArq) //copia o arquivo para o diretorio de backup
								Aadd(aMsgSch, STR0021 + cRetorno + STR0022 + cDirBkp + STR0023)	//"Não foi possivel copiar o arquivo "###" para o diretorio "###"Verifique se o diretorio existe e se ha permissao de escrita."
							Else
								Ferase(cRetorno)
								if File(cRetorno)
									Aadd(aMsgSch,STR0024 + cRetorno + STR0025 + cDirBkp)		//"Não foi possivel apagar o arquivo "###"O arquivo deve ser movido manualmente para o diretorio "
								Endif
							Endif
						Else 					
							cArq := aArq[nA,1]
							
							If !_CopyFile(cRetorno, cDirInc+cArq) //copia o arquivo para o diretorio de Inconsistencia.
								Aadd(aMsgSch, STR0021 + cRetorno + STR0022 + cDirBkp + STR0023)	//"Não foi possivel copiar o arquivo "###" para o diretorio "###"Verifique se o diretorio existe e se ha permissao de escrita."
							Else
								Aadd(aMsgSch, STR0012 + cRetorno + STR0026 + cDirInc + STR0027)	//"Arquivo: "###" foi movido para o diretorio "###". Verifique o movimento da inconsistência gerada."
								Ferase(cRetorno)
								
								If File(cRetorno)
									Aadd(aMsgSch,STR0024 + cRetorno + STR0025 + cDirInc)		//"Não foi possivel apagar o arquivo "###"O arquivo deve ser movido manualmente para o diretorio "
								Endif
							Endif	
						Endif
						F475MAIL( cRetorno, aMsgSch)
						Sleep(3000)
						//Processos de importação - APENAS PARA ADVPR
						If __l475Aut
							aadd(aProcAuto, SIF->IF_IDPROC)
						Endif
					Next nArquivo
				EndIf
			EndIf

			// Gravação da SIF e SIG em caso de erro na importação (Arquivo com erro ou API)
			If Len(aMsgSch) > 0 .and. nArquivo == 0

				F475MAIL( cRetorno, aMsgSch)
				Sleep(3000)

				cIdProc  := F474ProxNum("SIF")
				cItem    := Replicate("0",TamSx3("IG_ITEM")[1])
				aConfig1  := { cIdProc, cBanco, cAgencia, cConta, cSubCta, cErroProc }
				aConfig2  := {"", ""}

				For nX := 1 to Len(aMsgSch)
					cDescFail := "[ERRO] " + aMsgSch[nX] + CRLF
					cErroImp += cDescFail
					If !lErroImp
						cItem := Soma1(cItem)
						F474GRVSIG(aConfig1[1], cItem, '4', dDataBase, "", 0, "", "", aConfig1[2], aConfig1[3], aConfig1[4], "", cDescFail)
					Endif
				Next nX	

				F474GRVSIF(aConfig1, aConfig2 , dDataBase , '4', "", cErroImp)

				//Processos de importação - APENAS PARA ADVPR
				If __l475Aut
					aadd(aProcAuto,SIF->IF_IDPROC)
				Endif
			EndIf
		Endif

		//---------------------------------------------------------------
		// PRÉ CONCILIAÇÃO
		//---------------------------------------------------------------
		If Len(aMsgSch) == 0 .and. cTipoCon $ '1|2'
			F475Concil(cTipoCon,cBanco,cAgencia,cConta,aProcExt)
		EndIf

		cFilAnt := cFilAtu
		(cAliasSEE)->( Dbskip())
		aMsgSch  := {}

	Enddo
	
	(cAliasSEE)->(DbcloseArea())
	
	FwFreeArray(aArq)
	FwFreeArray(aRotAuto)
	FwFreeArray(aConfig1)
	FwFreeArray(aConfig2)

Return

//----------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA475OK
	
	Validação dos dados para a importação do extrato

	@type  Function
	@author pequim
	@since 26/08/2022
	@version 12.1.2310

	@return lRet, Logical, Retorna se as informações necessárias para a importação
							do extrato estão corretas ou não

/*/
//----------------------------------------------------------------------------------------------
Function FA475OK()
	
	Local aVldExt as Array //vetor com as validacoes dos campos necessários para o processamento
	Local lRet    as Logical
	Local nX      as Numeric

	aVldExt := {}
	lRet    := .T.
	nX      := 0

	AADD(aVldExt, {"EE_EXTCONA",SEE->EE_EXTCONA})
	AADD(aVldExt, {"EE_EXTDIRC",SEE->EE_EXTDIRC})
	AADD(aVldExt, {"EE_EXTDIRA",SEE->EE_EXTDIRA})
	AADD(aVldExt, {"EE_EXTDIRB",SEE->EE_EXTDIRB})
	AADD(aVldExt, {"EE_EXTDIRF",SEE->EE_EXTDIRF})
	AADD(aVldExt, {"EE_EXTARQC",SEE->EE_EXTARQC})
	AADD(aVldExt, {"EE_EXTARQR",SEE->EE_EXTARQR})
	AADD(aVldExt, {"EE_EXTFPRC",SEE->EE_EXTFPRC})

	RegToMemory("SEE",,,.F.)
	ALTERA := .T.

	If SEE->EE_EXTJOB == '1' .And. (!__lExtAPI .or.  (__lExtAPI .And.  M->EE_EXTAPI != '2')) 
		For nX := 1 to Len(aVldExt)
			cCampo := aVldExt[nX,1]
			cDado  := aVldExt[nX,2]
			lRet := FA474OK(cCampo,cDado, .T., .T.)
			If !lRet
				Exit
			Endif
		Next
	Endif

Return( lRet )

//----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475MAIL
	Prepara os dados para envio de email 

	@type  Function
	@author pequim
	@since 30/08/2022
	@version 12.1.2310

	@param cArq   , Character, Nome do arquivo de extrato a ser processado
	@param aMsgSch, Array    , Array que conterá as mensagens das ocorrências

/*/
//----------------------------------------------------------------------------------------------------
Function F475MAIL(cArq as Character, aMsgSch as Array)

	Local aArea      as Array
	Local aDestE     as Array
	Local cBody      as Character
	Local cDestE     as Character
	Local cMsgError  as Character
	Local cSubject   as Character
	Local cTitulo    as Character
	Local lRet       as Logical
	Local lSendMail  as Logical
	Local nAux       as Numeric
	Local nX         as Numeric

	aArea      := GetArea()
	aDestE     := {}
	cBody      := ""
	cDestE     := GetMv("MV_RETMAIL",, "") // destinatarios do email de retorno automatico via schedule
	cMsgError  := ""
	cSubject   := ""
	cTitulo    := STR0041		//"Importacao automatica de extratos bancarios."
	lRet       := .T.
	lSendMail  := .F.
	nAux       := 0
	nX         := 0

	Default cArq     := STR0011		//"ARQUIVO.NAO.INFORMADO"

	// se o parametro de destinatarios de envio de email estiver vazio ignora o envio
	If ValType(cDestE) <> "C" .or. Empty(cDestE)
		// se o parametro nao esta definido, envia as mensagens para o console
		If Len(aMsgSch) > 0
			For nX := 1 to Len(aMsgSch)
				FWLogMsg("INFO", "LAST", "FINA475", "FINA475IMP", cValToChar(nX +1) , "FINA475", aMsgSch[nX])
			Next
		Endif
		lRet := .F.
	EndIf

	If lRet
		aDestE := StrTokArr(cDestE,";")
		If Len(aDestE) > 0
			cSubject := cTitulo
			cTitle := cTitulo
			If !Empty(cArq)
				cSubject += ' - ' + STR0012 + cArq
				cTitle += ' - ' + STR0012 + cArq  
			Endif
			cSubject += ' - ' + STR0013 +Dtoc(dDataBase) + ' - ' + Time()	//'Arquivo: '###'  Processamento: '

			// corpo principal do email com o resumo do emvio
			cBody	:= '<HTML>'
			cBody	+= ' <HEAD>'
			cBody	+= '  <TITLE>'+cTitle+'</TITLE>'	//'Arquivo: '
			cBody	+= ' </HEAD>'
			cBody	+= ' <BODY>'
			cBody	+= '  <H1>'
			cBody	+= '   <FONT SIZE="4" COLOR="#000099">'
			cBody	+= '    <B>'+cTitulo+'</B>'									//'Arquivo: '
			cBody	+= '   </FONT>'
			cBody	+= '  </H1>'
			If !Empty(cArq)
				cBody 	+= '  <BR> '
				cBody	+= '   <FONT SIZE="3" COLOR="#000099">'
				cBody	+= '    <B>' + STR0012 + cArq +'</B>'						//'Arquivo: '
				cBody	+= '   </FONT>'
			Endif
			cBody	+= '  <H1><HR></H1>'

			// adiciona as mensagens contidas no vetor
			If Len(aMsgSch) >= 0
				cBody	+= '  <H1>'
				cBody	+= '   <FONT SIZE="3" COLOR="#000000">'
				cBody	+= '    ' + STR0014										//'Mensagens do Processamento : '
				cBody	+= '   </FONT>'
				cBody	+= '  </H1>'

				// MONTAGEM DO E-MAIL
				if Len(aMsgSch) == 0
					cBody += '<BR>&nbsp;&nbsp;-&nbsp;' + STR0015				//'Processamento sem inconsistencias'
				Else
					For nAux := 1 To Len(aMsgSch)
						cBody += '<BR>&nbsp;&nbsp;-&nbsp;' + aMsgSch[nAux]
					Next
				Endif	
				cBody	+= '  <H1><HR></H1>'
			EndIf

			cBody	+= '  <H1>'
			cBody	+= '   <FONT SIZE="2" COLOR="#FF0000">'
			cBody	+= '    '+cSubject
			cBody	+= '   </FONT>'
			cBody	+= '  </H1>'
			cBody	+= ' </BODY>'
			cBody	+= '</HTML>'

			// se nao tem assunto, ou corpo, ou destinatario - nao envia email para nao dar erro
			If ! Empty(cSubject) .and. !Empty(cBody) .and. !Empty(aDestE)
				lSendMail 	:= FA475SEND(aDestE, cSubject, cBody, @cMsgError)

				If !lSendMail .And. !Empty(cMsgError)
					FWLogMsg("INFO", /*cTransactionId*/, "FINA475", FunName(), "" , "FINA475", cMsgError)
				EndIf
			EndIf
		Endif
	Endif

	RestArea(aArea)

Return Nil


//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA475SEND
	Função que faz o envio do email
	
	@type  Function
	@author pequim
	@since 30/08/2022
	@version 12.1.2310

	@param aDest    , Array    , Lista de emails dos destinatários
	@param cAssunto , Character, Assunto do email
	@param cMensagem, Character, Mensagem do email
	@param cMsgError, Character, Mensagem de erro no envio do email

	@return lResult , Logical  , Informa o envio ou não do email

/*/
//---------------------------------------------------------------------------------------------
Static Function FA475SEND( aDest as Array , cAssunto as Character, cMensagem as Character, cMsgError as Character ) as Logical

	Local aArea      as Array
	Local cAttach    as Character
	Local cEmailBcc  as Character // E-mail de copia
	Local cEmailTo   as Character // E-mail de destino
	Local cError     as Character // String de erro
	Local cFrom      as Character // E-mail utilizado no campo FROM no envio do e-mail;
	Local cPass      as Character // Senha da conta de e-mail;
	Local cServer    as Character // Nome do servidor de envio de e-mail - Ex.: smtp.ig.com.br ou 200.181.100.51
	Local cUser      as Character // Conta a ser utilizada no envio de e-mail - Ex.: fuladetal@fulano.com.br
	Local lAutentica as Logical // Determina se o servidor exige autenticação
	Local lResult    as Logical // Se a conexao com o SMPT esta ok
	Local lRet       as Logical // Se tem autorizacao para o envio de e-mail
	Local nCntFor    as Numeric

	DEFAULT cMsgError := ""

	aArea      := GetArea()
	cAttach    := ""
	cEmailBcc  := "" // E-mail de copia
	cEmailTo   := "" // E-mail de destino
	cError     := "" // String de erro
	cFrom      := Trim(GetMV( 'MV_RELFROM' )) // E-mail utilizado no campo FROM no envio do e-mail;
	cPass      := Trim(SuperGetMV( 'MV_RELPSW' , .T., ' ' )) // Senha da conta de e-mail;
	cServer    := Trim(GetMV( 'MV_RELSERV' )) // Nome do servidor de envio de e-mail - Ex.: smtp.ig.com.br ou 200.181.100.51
	cUser      := Trim(SuperGetMV( 'MV_RELACNT' , .T., ' ' )) // Conta a ser utilizada no envio de e-mail - Ex.: fuladetal@fulano.com.br
	lAutentica := SuperGetMv( "MV_RELAUTH",, .F.) // Determina se o servidor exige autenticação
	lResult    := .F. // Se a conexao com o SMPT esta ok
	lRet       := .F. // Se tem autorizacao para o envio de e-mail
	nCntFor    := 0
	
  	If Empty(cServer)
    	cMsgError := STR0033 + " "  //"Necessario configurar o Servidor de e-mail SMTP"
  	EndIf

	// remonta os destinatarios utilizando o vetor
	If Empty(cUser) .And. Empty(cPass)
		cMsgError := STR0034	//"Necessario configurar a conta de e-mail (MV_RELACNT) e senha (MV_RELPSW) para envio de emails"
	ElseIf Empty(cUser) .And. !Empty(cPass)
		cMsgError := STR0035 	//"Necessario informar a conta de e-mail atraves do MV_RELACNT"
	ElseIf !Empty(cUser) .And. Empty(cPass)
		cMsgError := STR0036	//"Necessario informar a senha da conta de e-mail atraves do MV_RELPSW"
	EndIf

	If Empty(cMsgError)
		cEmail := ""
		For nCntFor := 1 To Len(aDest)
			If !Empty(cEmail)
				cEmail += ';'
			EndIf
			cEmail += aDest[nCntFor]
		Next

		// Envia o mail para a lista selecionada. Envia como BCC para que a pessoa pense 
		cEmailTo := cEmail

		CONNECT SMTP SERVER cServer ACCOUNT cUser PASSWORD cPass RESULT lResult

		// Se a conexao com o SMPT esta ok
		If lResult
			
			// Se existe autenticacao para envio valida pela funcao MAILAUTH
			If lAutentica
				lRet := Mailauth( cUser, cPass )
			Else
				lRet := .T.
			Endif
			
			If lRet
				SEND MAIL; 
				FROM 		cFrom;
				TO      	cEmailTo;
				BCC     	cEmailBcc;
				SUBJECT 	cAssunto;
				BODY    	cMensagem;
				RESULT 		lResult
				
				If !lResult
					//Erro no envio do email
					GET MAIL ERROR cError
					cMsgError :=  "01 - " + STR0016 + " " + cError + " " + cEmailTo			//"ATENCAO"
				Endif
			Else
				GET MAIL ERROR cError
				cMsgError :=  "02 - " + STR0018 +". "+ STR0019 	//"Erro de Autenticacao"###"Verifique a conta e a senha para envio."
			EndIf
			
			DISCONNECT SMTP SERVER
		Else
			//Erro na conexao com o SMTP Server
			GET MAIL ERROR cError
			cMsgError :=  "03 - " + STR0016 + " " + cError 	//"ATENCAO"
		EndIf
	Endif	
	RestArea( aArea )

Return( lResult )


//==========================================================================================
// PRE CONCILIACAO
//==========================================================================================
//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475Concil
	Função que faz o envio do email
	
	@type  Function
	@author Pequim
	@since 30/08/2022
	@version 12.1.2310

	@param cTipoCon , Character, Tipo de processamento (1=Todos;2=Novos;3=Não Concilia)
	@param cBanco   , Character, Mensagem do email
	@param cAgencia , Character, Mensagem de erro no envio do email
	@param cConta   , Character, Mensagem de erro no envio do email
	@param aProcExt , Array    , Lista de ids processados (SIG)

	@return lResult , Logical  , Informa o envio ou não do email

/*/
//---------------------------------------------------------------------------------------------
Function F475Concil(cTipoCon as Character,cBanco as Character,cAgencia as Character,cConta as Character,aProcExt as Array) as Logical

	Local cArqSIG  := ""   as Character
	Local lRet     := .T.  as Logical

	If (cTipoCon == '2' .and. Len(aProcExt) > 0) .or. cTipoCon == '1'

		If __aStruct == NIL
			F475GetCpos()	//Preenche array de campos para criação de tabela temporaria.
		Endif

		cArqSIG	:= f475QryA(cTipoCon,cBanco,cAgencia,cConta,aProcExt)		//Seleciona os registro do Extrato

		If cArqSIG == "NOACESS"  // Caso o usuario não tenha nenhuma permissão aborta o processo do bordero
			lRet := .F.
		EndIf

		If !Empty( cArqSIG )
			dbSelectArea(cArqSIG)
			dbGoTop()
		EndIf

		If (cArqSIG)->(Bof()) .And. (cArqSIG)->(Eof())
			lRet := .F.
		EndIf

		If lRet
			If FI475CFK5(cArqSIG, cBanco, cAgencia, cConta, cTipoCon, aProcExt)
				FI475GRV(cArqSIG)
			Endif
		Endif
	Endif

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} F475GetCpos
	Preenche array de campos para criação de tabela temporaria.
	@author  Pequim
	@since   20/09/2022
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
STATIC FUNCTION F475GetCpos( )

	Local aFields   as Array
	Local cCampoSX3 as Character
	Local cIndex    as Character
	Local nX        as Numeric

	//Campos do indice do browse
	aFields   := SIG->(dbStruct())
	cCampoSX3 := ""
	cIndex    := SIG->(INDEXKEY())
	nX        := 0
	__aStruct := {}
	
	If __lTipMat == NIL
		__lTipMat := QLD->(ColumnPos("QLD_TIPMAT")) > 0
	Endif

	// Sempre adiciona o campo IG_FILIAL na estrutura
	AADD(__aStruct,{"IG_FILIAL",GetSx3Cache("IG_FILIAL","X3_TIPO"),GetSx3Cache("IG_FILIAL","X3_TAMANHO"),GetSx3Cache("IG_FILIAL","X3_DECIMAL")})

	// Apenas adiciona o campo IG_FILIAL se SIG estiver exclusiva.

	For nX := 1 to Len(aFields)

		cCampoSX3 := AllTrim(Upper(aFields[nX,1]))

		//Campo IG_FILIAL já inserido anteriormente garantindo que fique na primeira posição após o IG_OK
		If cCampoSX3 != "IG_FILIAL"
			// Processa o restante das colunas adicionando aquelas que passam pela regra.
			If ( (aFields[nX,2] != "M" .And. X3USO(GetSx3Cache(aFields[nX,1],"X3_USADO")) .AND. ;
				cNivel >= GetSx3Cache(aFields[nX,1],"X3_NIVEL") .And. GetSx3Cache(aFields[nX,1],"X3_CONTEXT") != "V" ))

				AADD(__aStruct,{aFields[nX,1],aFields[nX,2],aFields[nX,3],aFields[nX,4]})
			Endif
		Endif	
	Next nX 

	If __lTipMat
		AADD(__aStruct,{"TIPMAT", "C", GetSx3Cache("QLD_TIPMAT","X3_TAMANHO"), GetSx3Cache("QLD_TIPMAT","X3_DECIMAL")})
	Endif
	
	AADD(__aStruct,{"REGMAT", "C", GetSx3Cache("QLD_REGMAT","X3_TAMANHO"), GetSx3Cache("QLD_REGMAT","X3_DECIMAL")})
	AADD(__aStruct,{"DESMAT", "C", GetSx3Cache("QLD_DESMAT","X3_TAMANHO"), GetSx3Cache("QLD_DESMAT","X3_DECIMAL")})

RETURN NIL


//-------------------------------------------------------------------
/*/{Protheus.doc} f475QryA

	Faz a query de filtro dos titulos

	@author pequim
	@since 22/09/2022
	@version 12.1.2310

	@param cTipoCon , Character, Tipo de processamento (1=Todos;2=Novos;3=Não Concilia)
	@param cBanco   , Character, Mensagem do email
	@param cAgencia , Character, Mensagem de erro no envio do email
	@param cConta   , Character, Mensagem de erro no envio do email
	@param aProcExt , Array    , Lista de ids processados (SIG)

/*/
//-------------------------------------------------------------------
Static Function f475QryA(cTipoCon as Character,cBanco as Character,cAgencia as Character,cConta as Character,aProcExt as Array)

	Local cQuery  as Character
	Local cFiltro as Character
	Local cArqNew as Character

	cQuery  := ''
	cFiltro := ''
	cArqNew := ''

	If Len(__aStruct) > 0
		// Constroi a clausula de filtro da seleção
		cFiltro := FA475ChecF(cTipoCon,cBanco,cAgencia,cConta,aProcExt)
		cQuery  := "SELECT "
		aEval(__aStruct,{|x| cQuery += If( 'IG_' $ x[1] , ALLTRIM(x[1]) + ',', '')})
		cQuery += "R_E_C_N_O_ RECSIG "
		cQuery += "FROM " + RetSqlName("SIG") + " "
		cQuery += "WHERE ? "
		cQuery += "ORDER BY IG_DTEXTR, IG_BCOEXT, IG_AGEEXT, IG_CONEXT, IG_DOCEXT , IG_VLREXT , IG_CARTER "
		cQuery := ChangeQuery(cQuery)
		__oPrepStA := FwPreparedStatement():New(cQuery)
		__oPrepStA:SetUnsafe(1,	cFiltro)
		cQuery	:= __oPrepStA:GetFixQuery()

		cArqNew := F475MTTMP(cQuery)
	EndIF

Return cArqNew


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa475ChecF
Funcao para montar e processar a query	

	@author  Mauricio Pequim Jr
	@since   06/10/2021
	@version P12

	@param cTipoCon , Character, Tipo de processamento (1=Todos;2=Novos;3=Não Concilia)
	@param cBanco   , Character, Mensagem do email
	@param cAgencia , Character, Mensagem de erro no envio do email
	@param cConta   , Character, Mensagem de erro no envio do email
	@param aProcExt , Array    , Lista de ids processados (SIG)

	@return cFiltro	, Character , Texto da Query

/*/
//---------------------------------------------------------------------------------------------------------
Function FA475ChecF(cTipoCon as Character,cBanco as Character,cAgencia as Character,cConta as Character,aProcExt as Array)

	Local cFiltro   as Character
	Local cProcExt  as Character
	Local nLenPrExt as Numeric
	Local nX        as Numeric

	cFiltro   := ""
	cProcExt  := ""
	nLenPrExt := 0
	nX        := 0

	DEFAULT cTipoCon := "0"
	DEFAULT cBanco   := ""
	DEFAULT cAgencia := ""
	DEFAULT cConta   := ""
	DEFAULT aProcExt := {}

	If cTipoCon == '2'			//Conciliacao usando os novos registros importados

		cFiltro := "IG_FILIAL = '" + xFilial("SIG") + "' AND "

		nLenPrExt := Len(aProcExt)
		If nLenPrExt == 1
			cFiltro += "IG_IDPROC = '" + aProcExt[1] + "' AND "
		Else 
			For nX := 1 to nLenPrExt
				cProcExt += aProcExt[nX]
				If nX != nLenPrExt
					cProcExt+= "|"
				Endif
			Next
			cFiltro += "IG_IDPROC IN " + FormatIn(cProcExt, "|") + " AND "
		Endif	

		cFiltro += " IG_STATUS = '1' AND "
		cFiltro += " D_E_L_E_T_ = ' ' "

	Else						//Conciliacao usando registros não conciliados anteriormente.

		cFiltro += " IG_BCOEXT = '"+ cBanco + "' AND "
		cFiltro += " IG_AGEEXT = '"+ cAgencia + "' AND "
		cFiltro += " IG_CONEXT = '"+ cConta + "' AND "
		cFiltro += " IG_STATUS = '1' AND "
		cFiltro += " D_E_L_E_T_ = ' ' "

	Endif

Return cFiltro
 

//-------------------------------------------------------------------
/*/{Protheus.doc} F475MTTMP

Monta a temporaria da query

@author pequim
@since 22/09/2022
@version P12
/*/
//-------------------------------------------------------------------
Static Function F475MTTMP(cQuery as Character)

	Local aArea     as Array
	Local cAliasSIG as Character
	Local cCampos   as Character
	Local cQuery2   as Character
	Local nTcSql    as Numeric

	aArea    := GetArea()
	cAliasSG := ''
	cCampos  := ''
	cQuery2  := ''
	nTcSql   := 0

	//Inclui campos complementares - apenas no primeiro processamento
	If __lFstStru == NIL
		AADD(__aStruct,{"RECSIG","N",10,0})
		AADD(__aStruct,{"RECFK5","N",10,0})
		__lFstStru := .T.
	Endif

	If __oFinA475 <> Nil
		//-- Limpa registros para nova execução
		cAliasSIG := __oFinA475:GetAlias()		
		nTcSql := TcSQLExec("DELETE FROM "+__oFinA475:GetRealName())
		If nTcSql < 0
			//-- Se ocorrer algum problema refaz a temporaria
			__oFinA475:Delete()
			__oFinA475 := Nil
		else
			(cAliasSIG)->(dbGoTo(1))
		Endif
	EndIF	
	IF __oFinA475 == Nil
		// Criação da Tabela Temporária 
		cAliasSIG 	:= GetNextAlias()
		__oFinA475 := FWTemporaryTable():New( cAliasSIG )
		__oFinA475:SetFields(__aStruct)
		__oFinA475:AddIndex("1", {"IG_DTEXTR", "IG_BCOEXT", "IG_AGEEXT", "IG_CONEXT", "IG_DOCEXT", "IG_VLREXT", "IG_CARTER"})
		__oFinA475:AddIndex("2", {"IG_IDPROC", "IG_DTEXTR", "IG_BCOEXT", "IG_AGEEXT", "IG_CONEXT"})	
		__oFinA475:Create()
	EndIF

	cQuery2 := " INSERT "

	aEval(__aStruct,{|x| cCampos += If( 'IG_' $ x[1] , ALLTRIM(x[1]) + ',', '')})

	cCampos += ' RECSIG '

	cQuery2 += " INTO " + __oFinA475:GetRealName() + " (" + cCampos + " ) " + cQuery

	Processa({|| nTcSql := TcSQLExec(cQuery2)})

	If nTcSql < 0   
		FwLogMsg("INFO", /*cTransactionId*/, "FINA475","F475MTTMP", "", "FINA475", " >>>> " + STR0038 + CRLF + TCSQLError() + " <<<<")	//"Não foi possivel montar a tabela temporaria, favor verificar o seu ambiente Protheus."+ CRLF + TCSQLError()
	EndIf

	(cAliasSIG)->(DBGOTOP())

	RestArea(aArea)

Return cAliasSIG


//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475Qry1
	Busca na tabela temporaria um registro do extrato que seja equivalente com o movimento
	considerando a chave Data + Agencia + Conta + Numero + Valor + Tipo

	@type		Function
	@author		Pequim
	@since		27/09/2022
	@param		cTableName, character, nome real da tabela temporária
	@param		aValores, array, valores a serem atribuidos no bind da query
	@return		numeric, recno da tabela temporária que representa a posição do array
/*/
//---------------------------------------------------------------------------------------------
Static Function F475Qry1(cTableName as Character, aValores as Array) As Numeric
	Local cQuery as Character
	Local nRecno as Numeric
	Local lCtaDig as Logical
	Local nX as Numeric
	Local nParam as Numeric

	DEFAULT cTableName := ""
	DEFAULT aValores := {}

	cQuery := ""
	nRecno := 0
	lCtaDig := (aValores[8] > 1)
	nParam := 1

	For nX := 1 to aValores[8]

		nParam := 1

		If lCtaDIg .and. __oPrepSt1 <> Nil
			__oPrepSt1:Destroy()
			__oPrepSt1 := Nil
		EndIf

		If lCtaDIg .and. nX < 3

			//Caso seja conta digital e o Codbar ou CodPix vazio, não processa as 2 primeiras chaves
			If (nX == 1 .and. Empty(aValores[9])) .or. (nX == 2 .and. Empty(aValores[10]))
				Loop
			Endif

			If __oPrepSt1 == Nil
				cQuery := "SELECT R_E_C_N_O_ TRBRECNO "
				cQuery += "FROM ? "
				cQuery += "WHERE ? = ? "
				cQuery +=  " AND IG_CARTER = ? "
				cQuery +=  " AND RECFK5 = ? "
				cQuery +=  " AND D_E_L_E_T_ = ? "
				cQuery := ChangeQuery(cQuery)
				__oPrepSt1 := FwExecStatement():New(cQuery)
			EndIf
			__oPrepSt1:SetUnsafe(nParam++, cTableName)

			If nX == 1		//CodBar
				__oPrepSt1:SetUnsafe(nParam++,	 "IG_CODBAR"  )
				__oPrepSt1:SetString(nParam++,	 aValores[9]  )
			ElseIf nX == 2	//CodPix
				__oPrepSt1:SetUnsafe(nParam++,	 "IG_IDTPIX"  )
				__oPrepSt1:SetString(nParam++,	 aValores[10] )
			Endif

			__oPrepSt1:SetString(nParam++, aValores[7]) //IG_CARTER
			__oPrepSt1:SetNumeric(nParam++, 0) //RECFK5
			__oPrepSt1:SetString(nParam++, " ") //D_E_L_E_T_
		Else
			If __oPrepSt1 == Nil	//Banco + Agencia + Conta + Documento + Valor + Carteira
				cQuery := "SELECT R_E_C_N_O_ TRBRECNO "
				cQuery += "FROM ? "
				cQuery += "WHERE IG_DTEXTR = ? "
				cQuery +=  " AND IG_BCOEXT = ? "
				cQuery +=  " AND IG_AGEEXT = ? "
				cQuery +=  " AND IG_CONEXT = ? "
				cQuery +=  " AND IG_DOCEXT = ? "
				cQuery +=  " AND IG_VLREXT = ? "
				cQuery +=  " AND IG_CARTER = ? "
				cQuery +=  " AND RECFK5 = ? "

				If __lCposCD
					cQuery +=  " AND IG_CODBAR = ? " 
					cQuery +=  " AND IG_IDTPIX = ? "
				Endif

				cQuery +=  " AND D_E_L_E_T_ = ? "
				cQuery := ChangeQuery(cQuery)
				__oPrepSt1 := FwExecStatement():New(cQuery)
			EndIf

			__oPrepSt1:SetUnsafe(nParam++, cTableName)
			__oPrepSt1:SetString(nParam++, aValores[1]) //IG_DTEXTR
			__oPrepSt1:SetString(nParam++, aValores[2]) //IG_BCOEXT
			__oPrepSt1:SetString(nParam++, aValores[3]) //IG_AGEEXT
			__oPrepSt1:SetString(nParam++, aValores[4]) //IG_CONEXT
			__oPrepSt1:SetString(nParam++, aValores[5]) //IG_DOCEXT
			__oPrepSt1:SetNumeric(nParam++, aValores[6]) //IG_VLREXT
			__oPrepSt1:SetString(nParam++, aValores[7]) //IG_CARTER
			__oPrepSt1:SetNumeric(nParam++, 0) //RECFK5

			If __lCposCD
				__oPrepSt1:SetString(nParam++, " ") //IG_CODBAR
				__oPrepSt1:SetString(nParam++, " ") //IG_IDTPIX
			Endif

			__oPrepSt1:SetString(nParam++, " ") //D_E_L_E_T_
		EndIf

		nRecno	:= __oPrepSt1:ExecScalar("TRBRECNO")

		If nRecno > 0
			Exit
		Endif
	Next

Return nRecno


//----------------------------------------------------------------------------------------
/*/{Protheus.doc} F475Qry2
Obtém a data inicial e final dos extratos importados recentemente

@type		Function
@author		Pequim
@since		14/12/2021
@param		cTableName, character, nome real da tabela temporária
@return		Array, {Data Inicial, Data Final}
/*/
//----------------------------------------------------------------------------------------
Static Function F475Qry2(cTableName As Character) 

	Local cQuery as Character
	Local cDtFin as Character
	Local cDtIni as Character

	If __oPrepSt8 == Nil
		cQuery := "SELECT MIN(IG_DTEXTR) DATAINI, MAX(IG_DTEXTR) DATAFIN "
		cQuery += "FROM ? "
		cQuery := ChangeQuery(cQuery)
		__oPrepSt8 := FwPreparedStatement():New(cQuery)
	EndIf

	__oPrepSt8:SetUnsafe(1,	 	cTableName)

	cQuery	:= __oPrepSt8:GetFixQuery()

	cDtIni := MpSysExecScalar(cQuery, "DATAINI")
	cDtFin := MpSysExecScalar(cQuery, "DATAFIN")

Return {cDtIni,cDtFin}

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475Qry3
	Busca na tabela temporaria um registro do extrato que seja equivalente com o movimento
	considerando a chave Data + Banco + Agencia + Conta  + Valor + Carteira

	@type		Function
	@author		Vitor Duca
	@since		27/09/2022
	@param		cTableName, character, nome real da tabela temporária
	@param		aValores, array, valores a serem atribuidos no bind da query
	@return		numeric, recno da tabela temporária que representa a posição do array
/*/
//---------------------------------------------------------------------------------------------
Static Function F475Qry3(cTableName as Character, aValores as Array) As Numeric
	Local cQuery as Character
	Local nRecno as Numeric
	Local nParam as Numeric

	DEFAULT cTableName := ""
	DEFAULT aValores := {}

	cQuery := ""
	nRecno := 0
	nParam := 1

	If __oPreStL == Nil	//Data + Banco + Agencia + Conta  + Valor + Carteira
		cQuery := "SELECT R_E_C_N_O_ TRBRECNO "
		cQuery += "FROM ? "
		cQuery += "WHERE IG_DTEXTR = ? "
		cQuery +=  " AND IG_BCOEXT = ? "
		cQuery +=  " AND IG_AGEEXT = ? "
		cQuery +=  " AND IG_CONEXT = ? "
		cQuery +=  " AND IG_VLREXT = ? "
		cQuery +=  " AND IG_CARTER = ? "
		cQuery +=  " AND RECFK5 = ? "

		If __lCposCD
			cQuery +=  " AND IG_CODBAR = ? " 
			cQuery +=  " AND IG_IDTPIX = ? "
		Endif

		cQuery +=  " AND D_E_L_E_T_ = ? "
		cQuery := ChangeQuery(cQuery)
		__oPreStL := FwExecStatement():New(cQuery)
	EndIf

	__oPreStL:SetUnsafe(nParam++, cTableName)
	__oPreStL:SetString(nParam++, aValores[1]) //IG_DTEXTR
	__oPreStL:SetString(nParam++, aValores[2]) //IG_BCOEXT
	__oPreStL:SetString(nParam++, aValores[3]) //IG_AGEEXT
	__oPreStL:SetString(nParam++, aValores[4]) //IG_CONEXT
	__oPreStL:SetNumeric(nParam++, aValores[6]) //IG_VLREXT
	__oPreStL:SetString(nParam++, aValores[7]) //IG_CARTER
	__oPreStL:SetNumeric(nParam++, 0) //RECFK5

	If __lCposCD
		__oPreStL:SetString(nParam++, " ") //IG_CODBAR
		__oPreStL:SetString(nParam++, " ") //IG_IDTPIX
	Endif

	__oPreStL:SetString(nParam++, " ") //D_E_L_E_T_


	nRecno	:= __oPreStL:ExecScalar("TRBRECNO")


Return nRecno

//----------------------------------------------------------------------------------------
/*/{Protheus.doc} FI475CFK5
	Função que busca os dados do Extrato e dos registros já conciliados

	@type  Function
	@author Pequim
	@since 30/08/2022
	@version 12.1.2310

	@param cTipoCon , Character, Tipo de processamento (1=Todos;2=Novos;3=Não Concilia)
	@param cBanco   , Character, Mensagem do email
	@param cAgencia , Character, Mensagem de erro no envio do email
	@param cConta   , Character, Mensagem de erro no envio do email
	@param aProcExt , Array    , Lista de ids processados (SIG)
/*/
//----------------------------------------------------------------------------------------
Static Function FI475CFK5(cArqSIG as Character, cBanco as Character, cAgencia as Character, cConta as Character, cTipoCon as Character, aProcExt as Array)

	Local aArea      as Array
	Local aDatas     as Array
	Local aValores   as Array
	Local cAliasTMP  as Character
	Local cChave     as Character
	Local cDatB1     as Character
	Local cDatB2     as Character
	Local cNewCpos   as Character
	Local cQuery     as Character
	Local cTabFK5    as Character
	Local cTableName as Character
	Local lFina476   as Logical //Conta Digital
	Local lInsert    as Logical
	Local nPosSIG    as Numeric
	Local nTimes     as Numeric
	Local nX         as Numeric
	Local aFiliais	 as Array
	Local nParam	 as Numeric
	Local cTipMatch	 as Character
	Local cRegMatch	 as Character
	Local cDesMatch	 as Character

	aArea      	:= GetArea()
	aValores   	:= {}
	cAliasTMP  	:= __oFinA475:GetAlias()
	cChave     	:= ""
	cChave     	:= "FK5.FK5_BANCO+FK5.FK5_AGENCI+FK5.FK5_CONTA+DTOS(FK5.FK5_DTDISP)"
	cNewCpos   	:= ""
	cQuery     	:= ""
	cTabFK5    	:= GetNextAlias()
	cTableName	:= __oFinA475:GetRealName()
	lFina476   	:= FwIsInCallStack( 'FINA476' )
	lInsert    	:= .F.
	nPosSIG    	:= 0
	nTimes     	:= 1
	aFiliais	:= FinRetFil()
	nParam		:= 1
	cTipMatch   := "MC"
	cRegMatch	:= "001"
	cDesMatch	:= 'regra_001'

	If cTipoCon == '1'
		cDatB1 := DTOS(dDataBase - 30)						//Conciliacao usando registros não conciliados anteriormente.
		cDatB2 := DTOS(dDataBase)
	ElseIf cTipoCon == "2" .and. Len(aProcExt) > 0			//Conciliação pelo extrato importado pelo Job
		aDatas := F475Qry2(cTableName)
		cDatB1 := aDatas[1]
		cDatB2 := aDatas[2]
	Endif

	If __lCposCD == NIL
		__lCposCD := FK5->(ColumnPos("FK5_CODBAR")) > 0 .and. FK5->(ColumnPos("FK5_CODPIX")) > 0 .and. SIG->(ColumnPos("IG_IDTPIX")) > 0 .and. SIG->(ColumnPos("IG_CODBAR")) > 0
	Endif

	If lFina476 .and. __lCposCD		//Conta Digital
		nTimes := 3
		cNewCpos := ", FK5.FK5_CODBAR, FK5.FK5_CODPIX "
		cCodBar := '(cTabFK5)->FK5_CODBAR' 
		cCodPix := '(cTabFK5)->FK5_CODPIX'
	Endif	

	If __oPrepStB == NIL
		cQuery += "SELECT FK5_FILIAL, FK5_DTDISP, FK5_BANCO, FK5_AGENCI,FK5_CONTA ,FK5_NUMCH, FK5_VALOR , FK5_RECPAG , FK5_IDMOV, R_E_C_N_O_ RECONFK5 "
		cQuery += " ? "
		cQuery += "FROM " + RetSqlName("FK5") + " FK5 "
		cQuery += "WHERE FK5.FK5_FILIAL ? "
		cQuery += "AND FK5.FK5_DTDISP BETWEEN ? AND ? "
		cQuery += "AND FK5.FK5_BANCO = ? "
		cQuery += "AND FK5.FK5_AGENCI = ? "
		cQuery += "AND FK5.FK5_CONTA = ? "
		cQuery += "AND FK5.FK5_DTCONC = ? "
		cQuery += "AND FK5.FK5_VALOR > ? "
		cQuery += "AND FK5.D_E_L_E_T_ = ? "
		cQuery += "AND EXISTS ( "
		cQuery += 	"SELECT FKA.FKA_IDFKA "
		cQuery += 	"FROM " + RetSqlName("FKA") + " FKA "
		cQuery += 	"WHERE FKA.FKA_FILIAL = FK5.FK5_FILIAL "
		cQuery += 		"AND FKA.FKA_TABORI = ? "
		cQuery += 		"AND FKA.FKA_IDORIG = FK5.FK5_IDMOV "
		cQuery += 		"AND FKA.D_E_L_E_T_ = ? "
		cQuery += 		"AND NOT EXISTS ( SELECT FKAEST.R_E_C_N_O_ , FKAEST.D_E_L_E_T_ "
		cQuery += 			"FROM " + RetSqlName("FKA") + " FKAEST "
		cQuery += 			"WHERE FKAEST.FKA_FILIAL = FKA.FKA_FILIAL "
		cQuery += 				" AND FKAEST.FKA_IDORIG <> FK5.FK5_IDMOV "
		cQuery += 				" AND FKAEST.FKA_IDPROC = FKA.FKA_IDPROC "
		cQuery += 				" AND FKAEST.FKA_TABORI = FKA.FKA_TABORI "
		cQuery += 				" AND FKAEST.D_E_L_E_T_ = ? ) "
		cQuery += 		" ) "
		cQuery += "ORDER BY ? "

		cQuery := ChangeQuery(cQuery)
		__oPrepStB := FWExecStatement():New(cQuery)
	Endif

	__oPrepStB:SetUnsafe(nParam++,	cNewCpos) //SELECT
	__oPrepStB:SetUnsafe(nParam++,	FinSelFil(aFiliais, "FK5", .F., .T., 250)) //FK5.FK5_FILIAL
	__oPrepStB:SetString(nParam++,	cDatB1) //FK5.FK5_DTDISP
	__oPrepStB:SetString(nParam++,	cDatB2) //FK5.FK5_DTDISP
	__oPrepStB:SetString(nParam++,	cBanco) //FK5.FK5_BANCO
	__oPrepStB:SetString(nParam++,	cAgencia) //FK5.FK5_AGENCI
	__oPrepStB:SetString(nParam++,	cConta) //FK5.FK5_CONTA
	__oPrepStB:SetString(nParam++,	" ") //FK5.FK5_DTCONC
	__oPrepStB:SetNumeric(nParam++, 0) //FK5.FK5_VALOR
	__oPrepStB:SetString(nParam++,	" ") //FK5.D_E_L_E_T_

	__oPrepStB:SetString(nParam++,	"FK5") //FKA.FKA_TABORI
	__oPrepStB:SetString(nParam++, " ") //FKA.D_E_L_E_T_

	__oPrepStB:SetString(nParam++, " ") //FKAEST.D_E_L_E_T_

	__oPrepStB:SetUnsafe(nParam++, SqlOrder(cChave)) //ORDER BY
	
    cTabFK5 := __oPrepStB:OpenAlias()

	//Inicia a leitura do arquivo de movimentacao do SE5
	While (cTabFK5)->(!(EoF()))
		cTipMatch   := "MC"
		cRegMatch	:= "001"
		cDesMatch	:= "regra_001"

		cRecPag := If((cTabFK5)->FK5_RECPAG == "R", "1","2")

		If cRecPag == "2"
			cRegMatch	:= "004"
			cDesMatch	:= "regra_004"
		Endif

		FwFreeArray(aValores)
		aValores := {}

		AADD(aValores , (cTabFK5)->FK5_DTDISP) 
		AADD(aValores ,	(cTabFK5)->FK5_BANCO) 
		AADD(aValores ,	(cTabFK5)->FK5_AGENCI) 
		AADD(aValores ,	(cTabFK5)->FK5_CONTA) 
		AADD(aValores ,	(cTabFK5)->FK5_NUMCH) 
		AADD(aValores ,	(cTabFK5)->FK5_VALOR) 
		AADD(aValores ,	cRecPag) 
		AADD(aValores ,	nTimes) 
		AADD(aValores ,	"") 	//CodBar
		AADD(aValores ,	"") //CodPix

		For nX := 1 to nTimes
			If __lCposCD .and. lFina476
				If (nX == 1 .and. Empty((cTabFK5)->FK5_CODBAR)) .OR. (nX == 2 .and. Empty((cTabFK5)->FK5_CODPIX))
					Loop
				Else
					aValores[9]  := (cTabFK5)->FK5_CODBAR
					aValores[10] := (cTabFK5)->FK5_CODPIX
				EndIf
			Endif
			
			//Realiza match completo
			nPosSIG := F475Qry1(cTableName, aValores)

			//Realiza match parcial
			If nPosSIG == 0 .and. !lFina476
				cTipMatch   := "MP"
				cRegMatch	:= "003"
				cDesMatch	:= "regra_003"
				
				If cRecPag == "2"
					cRegMatch	:= "006"
					cDesMatch	:= "regra_006"
				Endif
				
				nPosSIG := F475Qry3(cTableName, aValores)
			Endif

			If nPosSIG > 0
				(cAliasTMP)->(DbGoTo(nPosSIG))
				Reclock(cAliasTMP, .F.)
					(cAliasTMP)->RECFK5    := (cTabFK5)->RECONFK5
					(cAliasTMP)->IG_STATUS := "3"
					If __lTipMat
						(cAliasTMP)->TIPMAT := cTipMatch
					Endif
					(cAliasTMP)->REGMAT := cRegMatch
					(cAliasTMP)->DESMAT := cDesMatch
				(cAliasTMP)->(MsUnlock())
				lInsert		:= .T.
				Exit
			EndIf
		Next

		(cTabFK5)->(DbSkip())
	EndDo

	(cTabFK5)->(DbCloseArea())

	RestArea(aArea)

Return lInsert


//-------------------------------------------------------------------
/*/{Protheus.doc} FI475Grv
	Realiza a gravação da conciliação

	@type  Function
	@author Pequim
	@since 30/08/2022
	@version 12.1.2310

	@param cArqSIG , Character, alias do arquivo SIG

/*/
//-------------------------------------------------------------------
Static Function FI475Grv(cArqSIG as Character)

	Local aArea     as Array
	Local aProcesso as Array
	Local aSalBco   as Array
	Local cChaveBco as Character
	Local cChaveSld as Character
	Local cCodConc  as Character
	Local cFilX     as Character
	Local cProcesso as Character
	Local cSeqMat   as Character
	Local nValor    as Numeric
	Local nX        as Numeric
	Local nTamSld   as Numeric
	Local cTipMatch as Character

	aArea     := GetArea()
	aProcesso := {}
	aSalBco   := {}
	cChaveBco := ""
	cChaveSld := ""
	cCodConc  := ""
	cFilX     := cFilAnt
	cProcesso := ""
	cSeqMat   := Replicate("0",GetSx3Cache("QLD_SEQMAT","X3_TAMANHO"))
	nValor    := 0
	nX        := 0
	nTamSld   := 0
	cTipMatch := ""

	If Type("aConcAuto") == "U"
		aConcAuto := {}
	EndIf

	DbSelectArea("QLC")
	DbSelectArea("QLD")
	DbSelectArea("FKA")
	DbSelectArea("FK5")
	
	SE5->( DbSetOrder(21))	//E5_FILIAL, E5_IDORIG, E5_TIPODOC
	FK5->( DbSetOrder(1) )
	SIF->( DbSetOrder(1) )	//IF_FILIAL+IF_IDPROC
	SIG->( DbSetOrder(2) )	//IG_SEQMOV
	SA6->( DbSetOrder(1) )
	QLC->( DbSetOrder(1) )
	QLD->( DbSetOrder(1) )	

	(cArqSIG)->(dbSetOrder(2))	//IG_IDPROC + IG_DTEXTR + IG_BCOEXT + IG_AGEEXT + IG_CONEXT
	(cArqSIG)->(dbGoTop())

	BEGIN TRANSACTION

		//Atualização da SIG apenas dos movimentos conciliados
		While !((cArqSIG)->(Eof()))
		
			If (cArqSIG)->RECFK5 > 0

				SIG->(dbGoTo((cArqSIG)->RECSIG))
				FK5->(dbGoTo((cArqSIG)->RECFK5))

				If cProcesso != SIG->IG_IDPROC
					cProcesso := SIG->IG_IDPROC
					aadd(aProcesso, {SIG->IG_FILIAL,SIG->IG_IDPROC})
				Endif

				If cChaveBco != FK5->(FK5_BANCO+FK5_AGENCI+FK5_CONTA)
					cChaveBco := FK5->(FK5_BANCO+FK5_AGENCI+FK5_CONTA)
					cCodConc  := FINFKSID('QLC','QLC_CODCON')
					FGrvQLC(cCodConc)
				Endif

				If cChaveSld != FK5->(DTOS(FK5_DTDISP)+FK5_BANCO+FK5_AGENCI+FK5_CONTA)
					cChaveSld := FK5->(DTOS(FK5_DTDISP)+FK5_BANCO+FK5_AGENCI+FK5_CONTA)
					nValor := 0
					AADD(aSalBco, {FK5->FK5_BANCO, FK5->FK5_AGENCI, FK5->FK5_CONTA, FK5->FK5_DTDISP, nValor})
					nTamSld := Len(aSalBco)
				Endif

				aSalBco[nTamSld,5] += (FK5->FK5_VALOR * IF(FK5->FK5_RECPAG == "R", 1, -1 ))

				FGrvFK5(.T., FK5->FK5_DTDISP)

				cSeqMat := Soma1(cSeqMat)
				FGrvSIG()

				If __lTipMat
					cTipMatch := (cArqSIG)->TIPMAT
				Endif

				FGrvQLD(cCodConc, cSeqMat, cTipMatch, (cArqSIG)->REGMAT, (cArqSIG)->DESMAT)

				//Processos de conciliacção - APENAS PARA ADVPR
				If __l475Aut
					aadd(aConcAuto, { (cArqSIG)->RECSIG, (cArqSIG)->RECFK5, cTipMatch, (cArqSIG)->REGMAT, (cArqSIG)->DESMAT})
				Endif

			EndIf
			(cArqSIG)->(dbSkip())
		EndDo

		FGrvSIF(aProcesso)

	END TRANSACTION

	For nX := 1 to nTamSld
		AtuSalBco(aSalBco[nX,1], aSalBco[nX,2], aSalBco[nX,3], aSalBco[nX,4], aSalBco[nX,5], "+",.T., .F.)
	Next

	cFilAnt := cFilX

	RestArea(aArea)
	FwFreeArray(aArea)
	FwFreeArray(aSalBco)
	FwFreeArray(aProcesso)

Return .T.


//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGrvSIF
	Atualiza os status de conciliação de cada processo na SIF
	
	@type  Function
	@author pequim
	@since 28/09/2022
	@version 12.1.2310
	@param aProcesso, Array, array contendo os códigos de processos a serem atualizados
/*/
//--------------------------------------------------------------------------------------------
Static Function FGrvSIF(aProcesso as Array)

	Local nLinha As Numeric
	Local nLenPrc As Numeric
	Local cStatus As Character

	nLinha := 0
	nLenPrc := Len(aProcesso)
	cStatus := ""

	//Atualiza os Status da tabela SIF
	For nLinha := 1 to nLenPrc
		If SIF->(dbSeek(aProcesso[nLinha][1] + aProcesso[nLinha][2] ))
			cStatus := FSIFStatus(aProcesso[nLinha][1],aProcesso[nLinha][2])
			RecLock("SIF",.F.)
				SIF->IF_STATUS := cStatus
			SIF->(MsUnLock())
		EndIf
	Next nLinha

Return


//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGrvSIG
	Atualiza os dados de conciliação de cada registro da SIG
	
	@type  Function
	@author pequim
	@since 28/09/2022
	@version 12.1.2310
/*/
//--------------------------------------------------------------------------------------------
Static Function FGrvSIG(cCodConc as Character)

	Local cStatus As Character

	Default cCodConc := "999"

	If cCodConc == "998"
		cStatus := "5" 
	Else
		cStatus := "3" 
	Endif

	RecLock("SIG", .F. )
		SIG->IG_VLRMOV  := FK5->FK5_VALOR
		SIG->IG_DTMOVI	:= FK5->FK5_DTDISP
		SIG->IG_DOCMOV	:= FK5->FK5_NUMCH
		SIG->IG_AGEMOV	:= FK5->FK5_AGENCI
		SIG->IG_CONMOV	:= FK5->FK5_CONTA
		SIG->IG_STATUS	:= cStatus
		SIG->IG_HISMOV	:= FK5->FK5_HISTOR
		SIG->IG_NATMOV	:= FK5->FK5_NATURE
	SIG->( MsUnLock() )

Return

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGrvFK5
	Atualiza os dados de conciliação de cada registro da FK5/SE5
	
	@type  Function
	@author pequim
	@since 28/09/2022
	@version 12.1.2310
/*/
//--------------------------------------------------------------------------------------------
Static Function FGrvFK5(lConcil as Logical, dDtDispo as Date, lDtDispo as Logical)
	Local cQry     	as Character
	Local nRecnoSE5 as Numeric
	Local nParam	as Numeric
	Local nParEstBl as Numeric
	Local cAliasFK  as Character

	DEFAULT lConcil	 := .T.
	DEFAULT dDtDispo := FK5->FK5_DTDISP
	DEFAULT lDtDispo := .F.

	cQry      	:= "" 
	nRecnoSE5 	:= 0  
	nParam		:= 1
	nParEstBl   := 1
	cAliasFK    := "FK2"

	If __lFGrvSEF == Nil // Regra cheques emitido - "M.I"
		__lFGrvSEF := cPaisLoc $ "ARG|DOM|EQU" .And. FindFunction("FGrvSEF")
	EndIf
	
	Reclock("FK5", .F.)
		If lConcil 
			If lDtDispo
				FK5->FK5_DTDISP := dDtDIspo
			Else
				FK5->FK5_DTCONC	:= dDataBase
				FK5->FK5_SEQCON	:= SIG->IG_SEQMOV
			EndIf
		Else
			FK5->FK5_DTCONC	:= CTOD('//')
			FK5->FK5_SEQCON	:= ""
		EndIf
	FK5->(MsUnLock())

	SE5->(DbSetOrder(21))//E5_FILIAL+E5_IDORIG

	Do Case
		Case SE5->(MsSeeK(FK5->(xFilial("FK5",FK5_FILORI)+FK5_IDMOV)))
			FGrvSE5(lConcil, dDtDispo, lDtDispo)
		
			If lDtDispo .and. FK5->FK5_TPDOC $ "CH "
				F475grvCom(SE5->(Recno()), dDtDIspo)
			EndIf
			
			// Regra cheques emitido - "M.I"
			If __lFGrvSEF
				FGrvSEF(lConcil)
			Endif
		Case !Empty(FK5->FK5_LOTE) .and. FK5->FK5_TPDOC == "ES" .and. !Empty(FK5->FK5_IDFK7)
			If __oEstBl == NIL
				cQry := " SELECT SE5.R_E_C_N_O_ RECNO " 
				cQry += " FROM ? "
				cQry += " INNER JOIN " +  RetSqlName("SE5") + " SE5 ON "
				cQry += " SE5.E5_FILIAL = ? "
				cQry += " AND SE5.E5_IDORIG = ? "
				cQry += " AND SE5.D_E_L_E_T_ = ? "
				cQry += " WHERE ? = ? "
				cQry += " AND ? = ? "
				cQry += " AND ? = ? "
				cQry += " AND ? = ? "
				cQry += " AND ? = ? "
				__oEstBl := FWExecStatement():New(cQry)
			Endif
			
			If FK5->FK5_RECPAG == "P"
				cAliasFK := "FK1"
			Endif

			__oEstBl:SetUnsafe(nParEstBl++, RetSqlName(cAliasFK) + " " + cAliasFK)

			//INNER JOIN
			__oEstBl:SetUnsafe(nParEstBl++, cAliasFK + "." + cAliasFK + "_FILIAL")
			__oEstBl:SetUnsafe(nParEstBl++, cAliasFK + "." + cAliasFK + "_ID" + cAliasFK)
			__oEstBl:SetString(nParEstBl++, " ")

			//WHERE
			__oEstBl:SetUnsafe(nParEstBl++, cAliasFK + "." + cAliasFK + "_FILIAL")
			__oEstBl:SetString(nParEstBl++, FK5->FK5_FILIAL)
			__oEstBl:SetUnsafe(nParEstBl++, cAliasFK + "." + cAliasFK + "_IDDOC")
			__oEstBl:SetString(nParEstBl++, FK5->FK5_IDFK7)
			__oEstBl:SetUnsafe(nParEstBl++, cAliasFK + "." + cAliasFK + "_TPDOC")
			__oEstBl:SetString(nParEstBl++, FK5->FK5_TPDOC)
			__oEstBl:SetUnsafe(nParEstBl++, cAliasFK + "." + cAliasFK + "_LOTE")
			__oEstBl:SetString(nParEstBl++, FK5->FK5_LOTE)
			__oEstBl:SetUnsafe(nParEstBl++, cAliasFK + "." + "D_E_L_E_T_")
			__oEstBl:SetString(nParEstBl++, " ")

			nRecnoSE5 := __oEstBl:ExecScalar("RECNO")

			If !Empty(nRecnoSE5)
				SE5->(DbGoTo(nRecnoSE5))
				FGrvSE5(lConcil, dDtDispo, lDtDispo)
			Endif
		OtherWise
			FKA->(DbSetOrder(3))	//FKA_FILIAL+FKA_TABORI+FKA_IDORIG
			If FKA->(MsSeeK(FK5->(FK5_FILIAL+"FK5"+FK5_IDMOV)))	
				//Movimento bancário de baixa													
				If __oSE5 == NIL
					cQry := " SELECT TRBSE5.R_E_C_N_O_ RECNO " 
					cQry += " FROM " +  RetSqlName("SE5") + " TRBSE5 "
					cQry += " INNER JOIN " +  RetSqlName("FKA") + " FKAT ON "
					cQry += " FKAT.FKA_FILIAL = ? "
					cQry += " AND FKAT.FKA_IDPROC = ? "
					cQry += " AND FKAT.FKA_TABORI IN (?) "
					cQry += " AND FKAT.D_E_L_E_T_ = ? "
					cQry += " WHERE TRBSE5.E5_FILIAL = ? "
					cQry += " AND TRBSE5.E5_IDORIG = FKAT.FKA_IDORIG "
					cQry += " AND TRBSE5.E5_DATA = ? "
					cQry += " AND TRBSE5.E5_VALOR = ? "
					cQry += " AND TRBSE5.E5_TIPODOC = ? "
					cQry += " AND TRBSE5.E5_RECPAG = ? "
					cQry += " AND TRBSE5.D_E_L_E_T_ = ? "

					cQry := ChangeQuery(cQry)
					__oSE5 := FWExecStatement():New(cQry)
				Endif

				__oSE5:SetString(nParam++, FKA->FKA_FILIAL)
				__oSE5:SetString(nParam++, FKA->FKA_IDPROC)
				__oSE5:SetIn(nParam++, { 'FK1', 'FK2' })
				__oSE5:SetString(nParam++, " ")
				__oSE5:SetString(nParam++, FK5->FK5_FILIAL)
				__oSE5:SetDate(nParam++, FK5->FK5_DATA)
				__oSE5:SetNumeric(nParam++, FK5->FK5_VALOR)
				__oSE5:SetString(nParam++, FK5->FK5_TPDOC)
				__oSE5:SetString(nParam++, FK5->FK5_RECPAG)
				__oSE5:SetString(nParam++, " ")

				nRecnoSE5 := __oSE5:ExecScalar("RECNO")

				If !Empty(nRecnoSE5)
					SE5->(DbGoTo(nRecnoSE5))
					FGrvSE5(lConcil, dDtDispo, lDtDispo)
				Endif
			Endif
	EndCase
Return

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGrvSE5
	Atualiza os dados de conciliação de cada registro na SE5
	
	@type  Function
	@author Vitor Duca
	@since 05/03/2025
	@version 1.0
	@param lConcil, Logical, Define se esta sendo chamado pelo processo de conciliação
	@param dDtDispo, Date, Data de disponibilidade que foi alterada
	@param lDtDispo, Logical, Define se esta sendo chamado pelo processo de alteração da data de disponibilidade
/*/
//--------------------------------------------------------------------------------------------
Static Function FGrvSE5(lConcil as Logical, dDtDispo as Date, lDtDispo as Logical)
	Local cAliasFK	as character

	Default lConcil := .F.
	Default dDtDispo := FK5->FK5_DTDISP
	Default lDtDispo := .F.

	cAliasFK := SE5->E5_TABORI

	Reclock("SE5", .F.)
		If lConcil
			If lDtDispo
				SE5->E5_DTDISPO := dDtDIspo
			Else
				SE5->E5_RECONC := 'x'
				SE5->E5_SEQCON := SIG->IG_SEQMOV
			Endif
		Else
			SE5->E5_RECONC := ' '
			SE5->E5_SEQCON := ' '
		Endif
	SE5->( MsUnLock() )

	// Atualiza tabela de baixa - FK1 ou FK2
	If lDtDispo .and. (cAliasFK)->(dbseek(SE5->E5_FILIAL + SE5->E5_IDORIG))
		Reclock(cAliasFK,.F.)
			(cAliasFK)->&(cAliasFK + "_DTDISP") := dDtDispo
		(cAliasFK)->(MsUnlock())
	EndIf
	
Return

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGrvQLC
	Atualiza os dados de conciliação - Cabeçalho da Conciliação (QLC)
	
	@type  Function
	@author pequim
	@since 28/09/2022
	@version 12.1.2310
	@param cCodConc, Character, Código do processo de conciliação
/*/
//--------------------------------------------------------------------------------------------
Static Function FGrvQLC(cCodConc)

    RecLock("QLC", .T.)
		QLC->QLC_FILIAL := xFilial("QLC")
		QLC->QLC_CODCON := cCodConc
		QLC->QLC_CODCFG := '0023'		//Código da configuração de Conciliação de Movimentos Bancários Automática dentro do Conciliador
		QLC->QLC_TABORI := "SIG"
		QLC->QLC_TABDES := "FK5"
		QLC->QLC_DATCON := dDataBase
		QLC->QLC_HORCON := Time()
		QLC->QLC_CODUSR := RetCodUsr()
    QLC->(MsUnlock())

Return


//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGrvQLD
	Atualiza os dados de conciliação - Itens da Conciliação (QLD)
	
	@type  Function
	@author pequim
	@since 28/09/2022
	@version 12.1.2310
	@param cCodConc, Character, Código do processo de conciliação
	@param cSeqMat , Character, Sequência do Match da conciliação
/*/
//--------------------------------------------------------------------------------------------
Static Function FGrvQLD(cCodConc as Character, cSeqMat as Character,;
					cTipMatch as Character, cRegMatch as Character, cDesMatch as Character)

Local cInsert 	 := "" as Character
Local cCpoInsert := "" as Character
Local cCposTemp  := "" as Character
Local cSQL       := "" as Character
Local cReturn    := "" as Character
Local cBDName 	 := ALLTRIM(tcGetdb()) As Character

If __lTipMat == NIL
	__lTipMat := QLD->(ColumnPos("QLD_TIPMAT")) > 0
Endif

cCpoInsert := "QLD_FILIAL, QLD_CODCON, QLD_IDITEM, QLD_TPITEM, QLD_REGMAT, QLD_DESMAT, QLD_SEQMAT, QLD_CODCFG"
cCposTemp  := "'"+xFilial('QLD')+"','"+cCodConc+"',IG_MSUIDT,'1','"+cRegMatch+"','"+cDesMatch+"','"+cSeqMat+"','0023'"

If __lTipMat
	cCpoInsert += ",QLD_TIPMAT"
	cCposTemp += ",'" + cTipMatch + "'"
Endif

cInsert := totvs.protheus.backoffice.ngf.util.FunctionToDb(cBDName, "INSERT")

cSQL := cInsert +' INTO '+ RetSQLName("QLD")
cSQL += " ("+cCpoInsert+") "
cSQL += " SELECT "+cCposTemp
cSQL += " FROM "+ RetSqlName("SIG")
cSQL += " WHERE R_E_C_N_O_ = " + cValToChar(SIG->(RECNO()))
cSQL += " AND D_E_L_E_T_ = ' '"

IIf(TCSQLExec(cSQL) <> 0,;
    (Conout(TCSqlError()),;
        cReturn := STR0052,;  //"matchReconciliate Error: Nao foi possivel inserir dados na tabela QLD. "
        cReturn += STR0053),; //"Para mais detalhes, verificar arquivo console.log"
    cReturn := "")

If Empty(cReturn)
	cCpoInsert := "QLD_FILIAL, QLD_CODCON, QLD_IDITEM, QLD_TPITEM, QLD_REGMAT, QLD_DESMAT, QLD_SEQMAT, QLD_CODCFG"
	cCposTemp  := "'"+xFilial('QLD')+"','"+cCodConc+"',FK5_MSUIDT,'2','"+cRegMatch+"','"+cDesMatch+"','"+cSeqMat+"','0023'"
	If __lTipMat
		cCpoInsert += ",QLD_TIPMAT"
		cCposTemp += ",'" + cTipMatch + "'"
	Endif	

	cSQL := cInsert +' INTO '+ RetSQLName("QLD")
	cSQL += " ("+cCpoInsert+") "
	cSQL += " SELECT "+cCposTemp
	cSQL += " FROM "+ RetSqlName("FK5")
	cSQL += " WHERE R_E_C_N_O_ = "+ cValToChar(FK5->(RECNO()))
	cSQL += " AND D_E_L_E_T_ = ' '"

	IIf(TCSQLExec(cSQL) <> 0,;
		(Conout(TCSqlError()),;
			cReturn := STR0052,;  //"Nao foi possivel inserir dados na tabela QLD. "
			cReturn += STR0053),; //"Para mais detalhes, verificar arquivo console.log"
		cReturn := "")
Endif

Return cReturn


//-------------------------------------------------------------------
/*/{Protheus.doc} FSIFStatus
	Verifica o status de conciliação do extrato (SIF)

	@type  Function
	@author pequim
	@since 28/09/2022
	@version 12.1.2310
	@param cFilSIG, Character, Filial da tabela SIG
	@param cSeqMat , Character, Sequência do Match da conciliação

/*/
//-------------------------------------------------------------------
Static Function FSIFStatus(cFilSIG as Character, cProcesso as Character)

	Local cQuery     as Character
	Local cStatus    as Character
	Local cTableName as Character
	Local nNaoConc   as Numeric
	Local nTotal     as Numeric

	Default cFilSIG := xFilial("SIG")

	cQuery     := ""
	cStatus    := "1"
	cTableName := IF(__oFinA475 != NIL, __oFinA475:GetRealName(), RetSqlName("SIG") )
	nNaoConc   := 0
	nTotal     := 0

	If __oPrepSt2 == NIL
		cQuery := "SELECT COUNT(*) SIGCONT "
		cQuery += "FROM ? "
		cQuery += " WHERE "
		cQuery += 		"IG_FILIAL = ?  AND "
		cQuery += 		"IG_IDPROC = ?  AND "
		cQuery +=  		"D_E_L_E_T_ = ' '"
		cQuery := ChangeQuery(cQuery)
		__oPrepSt2 := FwPreparedStatement():New(cQuery)
	EndIf

	__oPrepSt2:SetUnsafe(1,	 cTableName)
	__oPrepSt2:SetString(2,	 cFilSIG)
	__oPrepSt2:SetString(3,	 cProcesso)

	cQuery	:= __oPrepSt2:GetFixQuery()
	nTotal	:= MpSysExecScalar(cQuery, "SIGCONT")

	If __oPrepSt3 == NIL
		cQuery := "SELECT COUNT(*) SIGCONTNC "
		cQuery += "FROM ? "
		cQuery += " WHERE "
		cQuery += 		"IG_FILIAL = ? AND "
		cQuery += 		"IG_IDPROC = ? AND "
		cQuery += 		"IG_STATUS = '1' AND "
		cQuery +=  		"D_E_L_E_T_ = ' '"
		cQuery := ChangeQuery(cQuery)
		__oPrepSt3 := FwPreparedStatement():New(cQuery)
	EndIf

	__oPrepSt3:SetUnsafe(1,	 cTableName)
	__oPrepSt3:SetString(2,	 cFilSIG)
	__oPrepSt3:SetString(3,	 cProcesso)

	cQuery	 := __oPrepSt3:GetFixQuery()
	nNaoConc := MpSysExecScalar(cQuery, "SIGCONTNC")

	If nNaoConc == 0 // Totalmente conciliado
		cStatus := '3'
	ElseIf nNaoConc < nTotal // Conciliado Parcialmente
		cStatus := '2'
	EndIf

Return cStatus


//--------------------------------------------------------------------
/*/{Protheus.doc} F475Clean
	
	Limpa as variáveis Static 

	@type  Function
	@author pequim
	@since 28/09/2022
	@version 12.1.2310

/*/
//--------------------------------------------------------------------
Function F475Clean()

	If __oFinA475 <> Nil
		__oFinA475:Delete()
		__oFinA475 := Nil
	EndIf

	If __oPrepSt1 <> Nil
		__oPrepSt1:Destroy()
		__oPrepSt1 := Nil
	EndIf

	If __oPrepSt2 <> Nil
		__oPrepSt2:Destroy()
		__oPrepSt2 := Nil
	EndIf

	If __oPrepSt3 <> Nil
		__oPrepSt3:Destroy()
		__oPrepSt3 := Nil
	EndIf

	If __oPrepSt4 <> Nil
		__oPrepSt4:Destroy()
		__oPrepSt4 := Nil
	EndIf

	If __oPrepSt5 <> Nil
		__oPrepSt5:Destroy()
		__oPrepSt5 := Nil
	EndIf

	If __oPrepSt6 <> Nil
		__oPrepSt6:Destroy()
		__oPrepSt6 := Nil
	EndIf

	If __oPrepSt7 <> Nil
		__oPrepSt7:Destroy()
		__oPrepSt7 := Nil
	EndIf

	If __oPrepSt8 <> Nil
		__oPrepSt8:Destroy()
		__oPrepSt8 := Nil
	EndIf

	If __oPrepSt9 <> Nil
		__oPrepSt9:Destroy()
		__oPrepSt9 := Nil
	EndIf

	If __oPrepStA <> Nil
		__oPrepStA:Destroy()
		__oPrepStA := Nil
	EndIf

	If __oPrepStB <> Nil
		__oPrepStB:Destroy()
		__oPrepStB := Nil
	EndIf

	If __oPrepStC <> Nil
		__oPrepStC:Destroy()
		__oPrepStC := Nil
	EndIf

	If __oPrepStD <> Nil
		__oPrepStD:Destroy()
		__oPrepStD := Nil
	EndIf

	If __oPrepStE <> Nil
		__oPrepStE:Destroy()
		__oPrepStE := Nil
	EndIf

	If __oPrepStF <> Nil
		__oPrepStF:Destroy()
		__oPrepStF := Nil
	EndIf		

	If __oPrepStG <> Nil
		__oPrepStG:Destroy()
		__oPrepStG := Nil
	EndIf	

	If __oPrepStH <> Nil
		__oPrepStH:Destroy()
		__oPrepStH := Nil
	EndIf

	If __oPrepStI <> Nil
		__oPrepStI:Destroy()
		__oPrepStI := Nil
	EndIf

	If __oPreStL <> Nil
		__oPreStL:Destroy()
		__oPreStL := Nil
	EndIf	

	If __aStruct <> NIL
		FwFreeArray(__aStruct)
	Endif

Return

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475PosGrv
	Complemento de gravação do processo Conciliação Automática realizado 
	no TOTVS Conciliador (QLC/QLD)
	
	@type  Function
	@author Pequim
	@since 07/11/2022

	@param cCodConc , Character, Processo de Conciliação no TOTVS Conciliador (QLC/QLD)
	@param cTableDes, Character, Tabela de Destino (TRBFK5) para ajuste de saldo por mudança de DtDispo
/*/
//--------------------------------------------------------------------------------------------
Function F475PosGrv(cCodConc as Character, cTableDes as Character, cCodCfg as Character,; 
					cCfgOri as Character, aUUID As Array)
	Local aProcesso	as Array
	Local aRecnos	as Array
	Local aSldCon   as Array
	Local aSeqMat	as Array
	Local cChaveSld as Character
	Local cProcesso as Character
	Local nTamSlCon as Numeric
	Local nValor    as Numeric
	Local nX        as Numeric
	Local jRecnos	as json
	Local nFK5		as Numeric
	Local nSIG		as Numeric
	Local cFilBkp	as Character
	Local jSaldoBco	as Json
	Local aSaldoBco	as Array
	Local lIsConAut as Logical

	Default cCodConc := ""
	Default cTableDes := ""
	Default cCodCfg := ""
	Default cCfgOri := ""
	Default aUUID := {}

	aProcesso 	:= {}
	aRecnos   	:= {}
	aSldCon   	:= {}
	cChaveSld 	:= ""
	cProcesso 	:= ""
	nTamSlCon	:= 0
	nValor    	:= 0
	nX        	:= 0
	jSaldoBco	:= JsonObject():new()
	aSaldoBco	:= {}
	jRecnos 	:= JsonObject():new()
	aSeqMat		:= {}
	nFK5		:= 0
	nSIG		:= 0
	lIsConAut	:= cCodCfg == "0023" .or. cCfgOri == "0023"

	If __lF475PGr == NIL
		__lF475PGr := Existblock("F475PGRV")
	Endif

	If __lFGrvSEF == Nil // Regra cheques emitido - "M.I"
		__lFGrvSEF := cPaisLoc $ "ARG|DOM|EQU" .And. FindFunction("FGrvSEF")
	EndIf

	jRecnos	:= F475RecPrc(cCodConc)
	aSeqMat := jRecnos:GetNames()

	For nX := 1 to Len(aSeqMat)

		For nFK5 := 1 to Len(jRecnos[aSeqMat[nX]]["FK5"])
			FK5->(dbGoto(jRecnos[aSeqMat[nX]]["FK5"][nFK5]))

			For nSIG := 1 to Len(jRecnos[aSeqMat[nX]]["SIG"])
				SIG->(dbGoto(jRecnos[aSeqMat[nX]]["SIG"][nSIG]))

				If Empty(SIG->IG_DTMOVI)
					If cProcesso != SIG->IG_IDPROC
						cProcesso := SIG->IG_IDPROC
						aadd(aProcesso, {SIG->IG_FILIAL,SIG->IG_IDPROC})
					Endif
					FGrvSIG(cCodConc)
				Endif

			Next nSIG

			If Empty(FK5->FK5_DTCONC)

				If __lFGrvSEF .or. lIsConAut .or. Len(aUUID) == 0
					FGrvFK5(.T.)
				Endif

				//Valores a atualizar no saldo conciliado e no saldo com alteração de Dt Dispo
				cChaveSld := FK5->(FK5->FK5_FILORI+DTOS(FK5_DTDISP)+FK5_BANCO+FK5_AGENCI+FK5_CONTA)
				If !jSaldoBco:hasProperty(cChaveSld)
					jSaldoBco[cChaveSld] := JsonObject():new()

					jSaldoBco[cChaveSld]["banco"]	:= FK5->FK5_BANCO
					jSaldoBco[cChaveSld]["agencia"]	:= FK5->FK5_AGENCI
					jSaldoBco[cChaveSld]["conta"]	:= FK5->FK5_CONTA
					jSaldoBco[cChaveSld]["dtdisp"]	:= FK5->FK5_DTDISP
					jSaldoBco[cChaveSld]["valor"]	:= 0
					jSaldoBco[cChaveSld]["filori"]	:= FK5->FK5_FILORI
				Endif

				jSaldoBco[cChaveSld]["valor"] += (FK5->FK5_VALOR * IF(FK5->FK5_RECPAG == "R", 1, -1 ))
			Endif
		Next nFK5

		//Gravações complementares atrave do Ponto de entrada F475PGRV
		If __lF475PGr
			ExecBlock( "F475PGRV", .F., .F.,{SIG->(Recno()), FK5->(Recno())})
		EndIf

	Next nX

	If !__lFGrvSEF .and. !lIsConAut
		FUpdateFK5(aUUID, Alltrim(tcGetdb()))
	Endif
	
	//Atualiza saldos Conciliados
	cFilBkp	:= cFilAnt
	aSaldoBco := jSaldoBco:getNames()
	nTamSlCon := Len(aSaldoBco)
	
	For nX := 1 to nTamSlCon
		If jSaldoBco[aSaldoBco[nX]]["valor"] != 0
			cFilAnt := jSaldoBco[aSaldoBco[nX]]["filori"]

			AtuSalBco(	jSaldoBco[aSaldoBco[nX]]["banco"],;		//cBanco
						jSaldoBco[aSaldoBco[nX]]["agencia"],;	//cAgencia
						jSaldoBco[aSaldoBco[nX]]["conta"],; 	//cConta
						jSaldoBco[aSaldoBco[nX]]["dtdisp"],;	//dData
						jSaldoBco[aSaldoBco[nX]]["valor"],; 	//nValor
						"+",;									//cSinal
						.T.,; 									//lReconc
						.F.;									//lSalatu
					)
		Endif
	Next
	cFilAnt := cFilBkp

	
	FGrvSIF(aProcesso)
	F475Clean()

Return .T.

/*/{Protheus.doc} FUpdateFK5
	Realiza alteração em massa da FK5 que esta dentro da conciliação em questão
	@type  Static Function
	@author Vitor Duca
	@since 03/06/2025
	@version 1.0
	@param aUUID, Array, Matriz contendo os ID's dos movimentos (FK5)
	@param cNameDB, Character, Nome do banco de dados conectado na aplicação (TcGetDb)
/*/
Static Function FUpdateFK5(aUUID as Array, cNameDB as Character)
	Local cUpdate	as Character
	Local cWhere	as Character
	Local nX		as Numeric
	Local nY		as Numeric
	Local aMSUIDT	as Array
	Local cUUIDTMP	as Character
	Local cInFK5Id	as Character
	Local cDataBase	as Character
	Local cTamLote	as Character
	Local cTamIDk7	as Character
	Local cAliasTmp	as Character

	Default aUUID 		:= {}
	Default cNameDB 	:= ""

	cUpdate		:= ""
	nX			:= 0
	nY			:= 0
	aMSUIDT		:= {}
	cUUIDTMP	:= ""
	cInFK5Id	:= ""
	cWhere		:= ""
	cDataBase	:= Dtos(dDataBase)
	cTamLote    := Space(TamSx3("FK5_LOTE")[1])
	cTamIDk7    := Space(TamSx3("FK5_IDFK7")[1])
	cAliasTmp   := IIF( cNameDB $ "POSTGRES", "", retSqlName("SE5") + "." ) 

	For nX := 1 to Len(aUUID)
		cUUIDTMP := aUUID[nX]

		cUpdate := " UPDATE " + retSqlName("FK5")
   		cUpdate += " SET FK5_DTCONC = '" + cDataBase + "' "
		cUpdate += " WHERE "

		If "ORACLE" $ cNameDB
			aMSUIDT := STRtokARR2(cUUIDTMP, ",", .T.) // Converto a string em um array de strings

			cInFK5Id := "FK5_MSUIDT IN ("
			For nY := 1 to LEN(aMSUIDT)
				cInFK5Id += "HEXTORAW(" + aMSUIDT[nY] + ")"
				cInFK5Id += IIf(nY < LEN(aMSUIDT),", ","")
			next nY
			cInFK5Id += ") "
		Else
			cInFK5Id := "FK5_MSUIDT IN("+cUUIDTMP+") "
		EndIf

		cWhere := " AND FK5_DTCONC = '        ' "
		cWhere += " AND D_E_L_E_T_ = ' ' "

		If FindClass('totvs.protheus.backoffice.fin.general.FlowControl')
			totvs.protheus.backoffice.fin.general.FlowControl():execSql(cUpdate + cInFK5Id + cWhere)
		Endif
		
		//Movimento direto (FINA100)
		FUpdE5Mov(cInFK5Id, cNameDB, cAliasTmp)

		//Movimento de baixa em um titulo
		FUpdE5Tit(cInFK5Id, cNameDB, cAliasTmp)

		//Movimento de estorno em uma baixa em lote
		FUpdE5Lote(cInFK5Id, cNameDB, cTamLote, cTamIDk7, cAliasTmp)

	Next nX

Return

/*/{Protheus.doc} FUpdE5Mov
	Realiza alteração em massa da SE5 que foram geradas pelo movimento direto (FINA100)
	e possuem relacionamento direto com a FK5
	@type  Static Function
	@author Vitor Duca
	@since 03/06/2025
	@version 1.0
/*/
Static Function FUpdE5Mov(cInFK5Id As Character, cNameDB As Character, cAliasTmp As Character)
	Local cUpdate	As Character

	Default cInFK5Id 	:= ""

	If cNameDB $ "ORACLE"
		cUpdate := "MERGE INTO " + retSqlName("SE5") + " SE5A "
		cUpdate += "USING ( "
		cUpdate += 	"SELECT SE5B.E5_FILIAL, SE5B.E5_IDORIG "
		cUpdate += 	"FROM " + retSqlName("FK5") + " FK5 "
		cUpdate += 	"INNER JOIN " + retSqlName("SE5") + " SE5B "
		cUpdate += 		"ON SE5B.E5_FILIAL = FK5.FK5_FILIAL "
		cUpdate += 				"AND SE5B.E5_IDORIG = FK5.FK5_IDMOV "
		cUpdate += 				"AND SE5B.E5_RECONC = ' ' "
		cUpdate += 				"AND SE5B.D_E_L_E_T_ = ' ' "
		cUpdate += 	"WHERE " + cInFK5Id + " " 
		cUpdate += 	"AND FK5.D_E_L_E_T_ = ' ' "
		cUpdate += ") SE5B "
		cUpdate += "ON (SE5A.E5_FILIAL = SE5B.E5_FILIAL AND SE5A.E5_IDORIG = SE5B.E5_IDORIG) "
		cUpdate += "WHEN MATCHED THEN "
		cUpdate += "UPDATE SET "
		cUpdate += 	"SE5A.E5_RECONC = 'x' "
	Else
		cUpdate := "UPDATE  " + retSqlName("SE5") + " "
		cUpdate += "SET " + cAliasTmp + "E5_RECONC = 'x' "
		cUpdate += "FROM  " + retSqlName("FK5") + "  FK5 "
		cUpdate += 		"INNER JOIN " + retSqlName("SE5") + "  SE5 "
		cUpdate += 				"ON SE5.E5_FILIAL = FK5.FK5_FILIAL "
		cUpdate += 					"AND SE5.E5_IDORIG = FK5.FK5_IDMOV "
		cUpdate += 					"AND SE5.E5_RECONC = ' ' "
		cUpdate += 					"AND SE5.D_E_L_E_T_ = ' ' "
		cUpdate += "WHERE " + cInFK5Id + " "

		If cNameDB $ "POSTGRES"
			cUpdate += 	"AND SE5.R_E_C_N_O_ = " + retSqlName("SE5") + "." + "R_E_C_N_O_ "
		Endif

		cUpdate += 		"AND FK5.D_E_L_E_T_ = ' ' "
	Endif

	If FindClass('totvs.protheus.backoffice.fin.general.FlowControl')
		totvs.protheus.backoffice.fin.general.FlowControl():execSql(cUpdate)
	Endif

Return 

/*/{Protheus.doc} FUpdE5Tit
	Realiza alteração em massa da SE5 que foi gerada pela baixa de titulo
	@type  Static Function
	@author Vitor Duca
	@since 03/06/2025
	@version 1.0
/*/
Static Function FUpdE5Tit(cInFK5Id As Character, cNameDB As Character, cAliasTmp As Character)
	Local cUpdate	As Character
	Local cJoinFKs	As Character
	Local cWhere 	As Character

	Default cInFK5Id 	:= ""

	cJoinFKs := 	"INNER JOIN " + retSqlName("FKA") + " FKA1 "
	cJoinFKs += 			"ON FKA1.FKA_FILIAL = FK5.FK5_FILIAL "
	cJoinFKs += 				"AND FKA1.FKA_IDORIG = FK5.FK5_IDMOV "
	cJoinFKs += 				"AND FKA1.D_E_L_E_T_ = ' ' "

	cJoinFKs += 	"LEFT JOIN " + retSqlName("FKA") + " FKA2 "
	cJoinFKs += 			"ON FKA2.FKA_FILIAL = FKA1.FKA_FILIAL "
	cJoinFKs += 				"AND FKA2.FKA_IDPROC = FKA1.FKA_IDPROC "
	cJoinFKs += 				"AND FKA2.FKA_TABORI IN ('FK2', 'FK1') "
	cJoinFKs += 				"AND FKA2.D_E_L_E_T_ = ' ' "

	cJoinFKs += 	"INNER JOIN " + retSqlName("SE5") + "  SE5 "
	cJoinFKs += 			"ON SE5.E5_FILIAL = FKA2.FKA_FILIAL "
	cJoinFKs += 				"AND SE5.E5_IDORIG = FKA2.FKA_IDORIG "
	cJoinFKs += 				"AND SE5.E5_DATA = FK5.FK5_DATA "
	cJoinFKs += 				"AND SE5.E5_VALOR = FK5.FK5_VALOR "
	cJoinFKs += 				"AND SE5.E5_TIPODOC = FK5.FK5_TPDOC "
	cJoinFKs += 				"AND SE5.E5_RECPAG = FK5.FK5_RECPAG "
	cJoinFKs += 				"AND SE5.E5_RECONC = ' ' "
	cJoinFKs += 				"AND SE5.D_E_L_E_T_ = ' ' "

	If cNameDB $ "ORACLE"
		cUpdate := "MERGE INTO " + retSqlName("SE5") + " SE5A "
		cUpdate += "USING ( "
		cUpdate += 	"SELECT SE5.R_E_C_N_O_ "
		cUpdate += 	"FROM " + retSqlName("FK5") + " FK5 "

		cWhere  := 	"WHERE " + cInFK5Id + " "
		cWhere  += 	"AND FK5.D_E_L_E_T_ = ' ' "
		cWhere  += ") TIT "
		cWhere  += "ON ( SE5A.R_E_C_N_O_ = TIT.R_E_C_N_O_ ) "
		cWhere  += "WHEN MATCHED THEN "
		cWhere  += "UPDATE SET "
		cWhere  += 	"SE5A.E5_RECONC = 'x' "
	Else
		cUpdate := "UPDATE  " + retSqlName("SE5") + " " 
		cUpdate += "SET " + cAliasTmp + "E5_RECONC = 'x' "
		cUpdate += "FROM " + retSqlName("FK5") + " FK5 "

		cWhere  := 	"WHERE " + cInFK5Id + " "

		If cNameDB $ "POSTGRES"
			cWhere += 	"AND SE5.R_E_C_N_O_ = " + retSqlName("SE5") + "." + "R_E_C_N_O_ "
		Endif

		cWhere  += 		"AND FK5.D_E_L_E_T_ = ' ' "
	Endif

	If FindClass('totvs.protheus.backoffice.fin.general.FlowControl')
		totvs.protheus.backoffice.fin.general.FlowControl():execSql(cUpdate + cJoinFKs + cWhere)
	Endif

Return 

/*/{Protheus.doc} FUpdE5Lote
	Realiza alteração em massa da SE5 que foi gerada pelo estorno da baixa em lote
	@type  Static Function
	@author Vitor Duca
	@since 03/06/2025
	@version 1.0
/*/
Static Function FUpdE5Lote(cInFK5Id As Character, cNameDB As Character, cTamLote As Character, cTamIDk7 As Character, cAliasTmp As Character)
	Local cUpdate	As Character
	Local cJoinFK2	As Character
	Local cJoinFK1	As Character
	Local cWhere 	As Character

	Default cInFK5Id 	:= ""
	Default cNameDB 	:= ""

	cJoinFK2 := 	"INNER JOIN " + retSqlName("FK2") + " FK2 "
	cJoinFK2 += 			"ON FK2.FK2_FILIAL = FK5.FK5_FILIAL "
	cJoinFK2 += 				"AND FK2.FK2_IDDOC = FK5.FK5_IDFK7 "
	cJoinFK2 += 				"AND FK2.FK2_TPDOC = FK5.FK5_TPDOC "
	cJoinFK2 += 				"AND FK2.FK2_LOTE = FK5.FK5_LOTE "
	cJoinFK2 += 				"AND FK2.D_E_L_E_T_ = ' ' "
	cJoinFK2 += 	"INNER JOIN " + retSqlName("SE5") + "  SE5 "
	cJoinFK2 += 			"ON SE5.E5_FILIAL = FK2.FK2_FILIAL "
	cJoinFK2 += 				"AND SE5.E5_IDORIG = FK2.FK2_IDFK2 "
	cJoinFK2 += 				"AND SE5.E5_TIPODOC = FK2.FK2_TPDOC "
	cJoinFK2 += 				"AND SE5.E5_SEQ = FK2.FK2_SEQ "
	cJoinFK2 += 				"AND SE5.E5_RECONC = ' ' "
	cJoinFK2 += 				"AND SE5.D_E_L_E_T_ = ' ' "

	cJoinFK1 := 	"INNER JOIN " + retSqlName("FK1") + " FK1 "
	cJoinFK1 += 			"ON FK1.FK1_FILIAL = FK5.FK5_FILIAL "
	cJoinFK1 += 				"AND FK1.FK1_IDDOC = FK5.FK5_IDFK7 "
	cJoinFK1 += 				"AND FK1.FK1_TPDOC = FK5.FK5_TPDOC "
	cJoinFK1 += 				"AND FK1.FK1_LOTE = FK5.FK5_LOTE "
	cJoinFK1 += 				"AND FK1.D_E_L_E_T_ = ' ' "
	cJoinFK1 += 	"INNER JOIN " + retSqlName("SE5") + "  SE5 "
	cJoinFK1 += 			"ON SE5.E5_FILIAL = FK1.FK1_FILIAL "
	cJoinFK1 += 				"AND SE5.E5_IDORIG = FK1.FK1_IDFK1 "
	cJoinFK1 += 				"AND SE5.E5_TIPODOC = FK1.FK1_TPDOC "
	cJoinFK1 += 				"AND SE5.E5_SEQ = FK1.FK1_SEQ "
	cJoinFK1 += 				"AND SE5.E5_RECONC = ' ' "
	cJoinFK1 += 				"AND SE5.D_E_L_E_T_ = ' ' "

	If cNameDB $ "ORACLE"
		cUpdate := "MERGE INTO " + retSqlName("SE5") + " SE5A "
		cUpdate += "USING ( "
		cUpdate += 	"SELECT SE5.E5_FILIAL, SE5.E5_IDORIG "
		cUpdate += 	"FROM " + retSqlName("FK5") + " FK5 "
		
		cWhere := 	"WHERE  " + cInFK5Id + " "
		cWhere += 	"AND FK5.FK5_IDFK7 <> '" + cTamIDk7 +  "' "
		cWhere += 	"AND FK5.FK5_LOTE <> '" + cTamLote +  "' "
		cWhere += 	"AND FK5.FK5_TPDOC = 'ES' "
		cWhere += 	"AND FK5.D_E_L_E_T_ = ' ' "

		cWhere  += ") SE5 "
		cWhere  += "ON (SE5A.E5_FILIAL = SE5.E5_FILIAL AND SE5A.E5_IDORIG = SE5.E5_IDORIG) "
		cWhere  += "WHEN MATCHED THEN "
		cWhere  += "UPDATE SET "
		cWhere  += 	"SE5A.E5_RECONC = 'x' "
	Else
		cUpdate := "UPDATE  " + retSqlName("SE5") + " " 
		cUpdate += "SET " + cAliasTmp + "E5_RECONC = 'x' "
		cUpdate += "FROM  " + retSqlName("FK5") + "  FK5 "
		
		cWhere := 	"WHERE  " + cInFK5Id + " "
		cWhere += 		"AND FK5.FK5_IDFK7 <> '" + cTamIDk7 +  "' "
		cWhere += 		"AND FK5.FK5_LOTE <> '" + cTamLote +  "' "
		cWhere += 		"AND FK5.FK5_TPDOC = 'ES' "

		If cNameDB $ "POSTGRES"
			cWhere += 	"AND SE5.R_E_C_N_O_ = " + retSqlName("SE5") + "." + "R_E_C_N_O_ "
		Endif

		cWhere += 		"AND FK5.D_E_L_E_T_ = ' ' "
	Endif

	If FindClass('totvs.protheus.backoffice.fin.general.FlowControl')
		totvs.protheus.backoffice.fin.general.FlowControl():execSql(cUpdate + cJoinFK1 + cWhere)
		totvs.protheus.backoffice.fin.general.FlowControl():execSql(cUpdate + cJoinFK2 + cWhere)
	Endif

Return 

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475RecPrc
	Retorna os Recno dos registros SIG e FK5 que compõem o processo de
	Conciliação no TOTVS Conciliador (QLC/QLD)
	
	@type  Function
	@author Pequim
	@since 07/11/2022

	@param cCodConc  , Character, Processo de Conciliação no TOTVS Conciliador (QLC/QLD)

	@return jRecnos, Json , Objeto Json contendo os recnos por Sequencia de match
	{
		"0000000001": {
			"SIG": [1,2,3,4,5],
			"FK5": [7]
		},
		"0000000002": {
			"SIG": [10],
			"FK5": [75]
		}
	}
	/*/
//--------------------------------------------------------------------------------------------
Function F475RecPrc(cCodConc as Character) as json

	Local cQuery	as Character
	Local nRecSIG 	as Numeric
	Local nRecFK5 	as Numeric
	Local jRecnos 	as Json
	Local cAliasTmp as Character

	Default cCodConc := ""

	cQuery  	:= ""
	nRecSIG 	:= 0
	nRecFK5 	:= 0
	jRecnos 	:= JsonObject():new()
	cAliasTmp	:= ""

	If __oPrepSt4 == Nil
		cQuery := "SELECT QLD_SEQMAT, QLD_TPITEM, QLD_IDITEM "
		cQuery += "FROM " + RetSqlName("QLD") + " "
		cQuery += "WHERE QLD_FILIAL = ? "
		cQuery +=  " AND QLD_CODCON = ? "
		cQuery +=  " AND D_E_L_E_T_ = ' '"
		cQuery +=  " ORDER BY QLD_REGMAT,QLD_SEQMAT,QLD_TPITEM"
		cQuery := ChangeQuery(cQuery)
		__oPrepSt4 := FwPreparedStatement():New(cQuery)
	EndIf

	__oPrepSt4:SetString(1,	xFilial("QLD"))
	__oPrepSt4:SetString(2,	cCodConc)

	cQuery	:= __oPrepSt4:GetFixQuery()
    cAliasTmp := MpSysOpenQuery(cQuery)
	nRecSIG := 0
	nRecFK5 := 0

    While (cAliasTmp)->(!Eof())

		If !jRecnos:hasProperty((cAliasTmp)->QLD_SEQMAT)
			jRecnos[(cAliasTmp)->QLD_SEQMAT] := JsonObject():new()
			jRecnos[(cAliasTmp)->QLD_SEQMAT]["SIG"] := {}
			jRecnos[(cAliasTmp)->QLD_SEQMAT]["FK5"] := {}
		Endif

		If (cAliasTmp)->QLD_TPITEM == '1'
			nRecSIG := F475GetRec("SIG",(cAliasTmp)->QLD_IDITEM)
			aAdd(jRecnos[(cAliasTmp)->QLD_SEQMAT]["SIG"], nRecSIG)
		Endif

		If (cAliasTmp)->QLD_TPITEM == '2' 
			nRecFK5 := F475GetRec("FK5",(cAliasTmp)->QLD_IDITEM)
			aAdd(jRecnos[(cAliasTmp)->QLD_SEQMAT]["FK5"], nRecFK5)
        EndIf

		(cAliasTmp)->(DbSkip())
    EndDo	
    (cAliasTmp)->(DbCloseArea())

Return jRecnos

//------------------------------------------------------------------------
/*/{Protheus.doc} F475GetRec
	Retorna o Recno do alias informado 
	
	@type  Function
	@author Pequim
	@since 07/11/2022

	@param cAlias , Character, Alias do qual se deseja obter o recno
	@param cIdItem, Character, IdItem da conciliação (MSUIDT)
	@return nRecno, Numeric  , Recno da tabela
	/*/
//------------------------------------------------------------------------
Function F475GetRec(cAlias as Character, cIdItem as Character)
	Local cQuery  	as Character
	Local nRecno  	as Numeric
	Local cMSUIDT	as Character
	Local cNameDB	as Character

	DEFAULT cAlias  := ""
	DEFAULT cIdItem := ""

	cQuery  := ""
	nRecno  := 0
	cMSUIDT := RTrim(cIdItem)
	cNameDB	:= Alltrim(TcGetDB())

	If cAlias == "SIG"
		If __oPrepSt5 == Nil
			cQuery := "SELECT R_E_C_N_O_ SIGRECNO "
			cQuery += "FROM " + RetSqlName("SIG") + " "

			If "ORACLE" $ cNameDB
				cQuery += " WHERE IG_MSUIDT = HEXTORAW(?) "
			Else
				cQuery += " WHERE IG_MSUIDT = ? "
			Endif

			cQuery +=  " AND D_E_L_E_T_ = ? "
			cQuery := ChangeQuery(cQuery)
			__oPrepSt5 := FWExecStatement():New(cQuery)
		EndIf

		__oPrepSt5:SetString(1, cMSUIDT)
		__oPrepSt5:SetString(2, " ")
		nRecno	:= __oPrepSt5:ExecScalar("SIGRECNO")
	Endif

	If cAlias == "FK5"
		If __oPrepSt6 == Nil
			cQuery := "SELECT R_E_C_N_O_ FK5RECNO "
			cQuery += "FROM " + RetSqlName("FK5") + " "

			If "ORACLE" $ cNameDB
				cQuery += " WHERE FK5_MSUIDT = HEXTORAW(?) "
			Else
				cQuery += " WHERE FK5_MSUIDT = ? "
			Endif

			cQuery +=  " AND D_E_L_E_T_ = ? "
			cQuery := ChangeQuery(cQuery)
			__oPrepSt6 := FWExecStatement():New(cQuery)
		EndIf

		__oPrepSt6:SetString(1, cMSUIDT)
		__oPrepSt6:SetString(2, " ")
		nRecno	:= __oPrepSt6:ExecScalar("FK5RECNO")
	Endif

Return nRecno


//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475PosCan
	Complemento de gravação do processo Conciliação Automática realizado 
	no TOTVS Conciliador (QLC/QLD) - Cancelamento
	
	@type  Function
	@author Pequim
	@since 01/12/2022

	@param cCodConc, Character, Processo de Conciliação no TOTVS Conciliador (QLC/QLD)
	@param cCodCfg , Character, Código da regra de conciliação (0023/0024)
	@param cRegMatch, Character, Codigo identificador do match (QLD_REGMAT)
	@param cSeqMatch, Character, Sequencial no identificador do match (QLD_SEQMAT)
	@param cTabOri  , Character, RealName da tabela temporária que contém os registros FK5 (DESTINO) ou SIG (ORIGEM)
	@param cUuid   , Character, UUID do registro para cancelamento match (0024)
	@param cErro   , Character, Utilizado para devolver ao FRONT o erro caso ocorra.
	@param lCalledGer, Logical, Define se quem esta chamando é o gerenciar conciliações
	@param aRecFK5, Array, Recnos dos movimentos que serão utilizados no cancelamento da conciliação
	@param aRecSIG, Array, Recnos dos itens do extrato que serão utilizados no cancelamento da conciliação
/*/
//--------------------------------------------------------------------------------------------
Function F475PosCan(cCodCon as character, cCodCfg as character, cRegMatch as character, cSeqMatch as character, cTabori as character, ;
					cUuid as character, cError as character, lCalledGer as logical, aRecFK5 as array, aRecSIG as array)

	Local aProcesso := {} 		As Array
	Local aSalBco   := {} 		As Array
	Local cChaveSld := "" 		As Character
	Local cProcesso := "" 		As Character
	Local nTamSld   := 0  		As Numeric
	Local nValor    := 0  		As Numeric
	Local nX        := 0  		As Numeric
	Local cFilBkp	:= "" 		As Character
	Local lCfgFin 	:= .F. 		As Logical

	Default cCodCon   	:= ""
	Default cCodCfg   	:= ""
	Default cRegMatch 	:= ""
	Default cSeqMatch 	:= ""
	Default cTabori	  	:= ""
	Default cUuid	  	:= ""
	Default cError	  	:= ""
	Default lCalledGer	:= .F.
	Default aRecFK5		:= {}
	Default aRecSIG		:= {}

	lCfgFin := (cCodCfg == '0024') .Or. ((QLB->(FieldPos("QLB_CFGORI")) > 0) .And. (QLB->QLB_CFGORI == "0024"))

	If __l475PCan == NIL
		__l475PCan := Existblock("F475PCAN")
	Endif

	If Empty(cCodCon) .and.  lCfgFin
		F475CanTRB(cCodCfg, cTabori, cUuid, @cError)
	Else
		If Empty(aRecFK5) .and. Empty(aRecSIG)
			F475RecCan(cCodCon, cCodCfg, cRegMatch, cSeqMatch, @aRecSIG, @aRecFK5)
		Endif

		For nX := 1 to Len(aRecSIG)
			If aRecSIG[nX] > 0
				SIG->(dbGoto(aRecSIG[nX]))
				If cProcesso != SIG->IG_IDPROC
					cProcesso := SIG->IG_IDPROC
					aadd(aProcesso, {SIG->IG_FILIAL,SIG->IG_IDPROC})
				Endif		
				FGrvSIGCan(cCodCfg)
			Endif
			If lCfgFin .And. !Empty(cTabori) .And. !lCalledGer	//Conciliacao Manual deleta os registros da SIG e do TRB
				F475CanTRB(cCodCfg ,cTabori, cUuid, @cError)
			Endif
		Next

		For nX := 1 to Len(aRecFK5)
			If aRecFK5[nX] > 0
				FK5->(dbGoto(aRecFK5[nX]))
				If cChaveSld != FK5->(FK5->FK5_FILORI+DTOS(FK5_DTDISP)+FK5_BANCO+FK5_AGENCI+FK5_CONTA)
					cChaveSld := FK5->(FK5->FK5_FILORI+DTOS(FK5_DTDISP)+FK5_BANCO+FK5_AGENCI+FK5_CONTA)
					nValor := 0
					AADD(aSalBco, {FK5->FK5_BANCO, FK5->FK5_AGENCI, FK5->FK5_CONTA, FK5->FK5_DTDISP, nValor, FK5->FK5_FILORI})
					nTamSld := Len(aSalBco)
				Endif
				aSalBco[nTamSld,5] += (FK5->FK5_VALOR * IF(FK5->FK5_RECPAG == "R", -1, 1 ))
				FGrvFK5(.F.)
			Endif
		Next	
		
		//Atualiza saldos Conciliados
		cFilBkp	:= cFilAnt
		For nX := 1 to nTamSld
			cFilAnt := aSalBco[nX,6]
			AtuSalBco(aSalBco[nX,1], aSalBco[nX,2], aSalBco[nX,3], aSalBco[nX,4], aSalBco[nX,5], "+",.T., .F.)
		Next

		cFilAnt := cFilBkp
	Endif

	FGrvSIF(aProcesso)

	//Gravações complementares atraves do Ponto de entrada F475PCAN
	If __l475PCan .and. !lCalledGer
		ExecBlock( "F475PCAN", .F., .F.,{ aRecSIG, aRecFK5 })
	Endif

	F475Clean()

	FwFreeArray(aRecFK5)
	FwFreeArray(aRecSIG)

Return .T.


//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475RecCan
	Retorna os Recno dos registros SIG e FK5 que compõem o processo de
	Conciliação no TOTVS Conciliador (QLC/QLD) - Cancelamento
	
	@type  Function
	@author Pequim
	@since 01/12/2022

	@param cCodConc , Character, Processo de Conciliação no TOTVS Conciliador (QLC/QLD)
	@param cIdMatch , Character, Processo de Conciliação no TOTVS Conciliador (QLC/QLD)
	@param cCodCfg , Character, Processo de Conciliação no TOTVS Conciliador (QLC/QLD)
	@param cSeqMatch , Character, Processo de Conciliação no TOTVS Conciliador (QLC/QLD)
	@param aRecSIG, Array , Array de Recnos SIG do processo de Conciliação - Cancelamento
	@param aRecFK5, Array , Array de Recnos FK5 do processo de Conciliação - Cancelamento

	/*/
//--------------------------------------------------------------------------------------------
Function F475RecCan(cCodCon as Character,cCodCfg as Character,cRegMatch as Character,cSeqMatch as Character,aRecSIG as Array,aRecFK5 as Array)

	Local cQuery as Character
	Local nRecSIG as Numeric
	Local nRecFK5 as Numeric

	cQuery := ""
	nRecno := 0

	If __oPrepSt7 == Nil
		cQuery := "SELECT QLD_TPITEM, QLD_IDITEM "
		cQuery += "FROM " + RetSqlName("QLD") + " "
		cQuery += "WHERE QLD_FILIAL = ? "
		cQuery +=  " AND QLD_CODCON = ? "
		cQuery +=  " AND QLD_CODCFG = ? "
		cQuery +=  " AND QLD_REGMAT = ? "
		cQuery +=  " AND QLD_SEQMAT = ? "
		cQuery +=  " AND D_E_L_E_T_ = ' '"
		cQuery +=  " ORDER BY QLD_REGMAT,QLD_SEQMAT,QLD_TPITEM"
		cQuery := ChangeQuery(cQuery)
		__oPrepSt7 := FwPreparedStatement():New(cQuery)
	EndIf

	__oPrepSt7:SetString(1,	xFilial("QLD"))
	__oPrepSt7:SetString(2,	cCodCon)
	__oPrepSt7:SetString(3,	cCodCfg)
	__oPrepSt7:SetString(4,	cRegMatch)
	__oPrepSt7:SetString(5,	cSeqMatch)

	cQuery	:= __oPrepSt7:GetFixQuery()
    cAliasTmp := MpSysOpenQuery(cQuery)

    While (cAliasTmp)->(!Eof())
        nRecSIG := 0
		nRecFK5 := 0
		If (cAliasTmp)->QLD_TPITEM == '1' 
			nRecSIG := F475GetRec("SIG",(cAliasTmp)->QLD_IDITEM)
			aadd(aRecSIG, nRecSIG)
		Endif
		If (cAliasTmp)->QLD_TPITEM == '2'
			nRecFK5 := F475GetRec("FK5",(cAliasTmp)->QLD_IDITEM)
			aadd(aRecFK5, nRecFK5)
		Endif
		(cAliasTmp)->(DbSkip())
    EndDo	
    (cAliasTmp)->(DbCloseArea())

Return 


//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGrvSIGCan
	Atualiza os dados de conciliação de cada registro da SIG - Cancelamento
	
	@type  Function
	@author pequim
	@since 01/12/2022
	@version 12.1.2310
/*/
//--------------------------------------------------------------------------------------------
Static Function FGrvSIGCan(cCodCfg)

	Default cCodCfg := ''

	If (cCodCfg == '0024' .Or. ((QLB->(FieldPos("QLB_CFGORI")) > 0) .And. (QLB->QLB_CFGORI == "0024")))	//Conciliacao Manual
		RecLock("SIG", .F. )
		SIG->( dbDelete() )
		SIG->( MsUnLock() )
	Else
		RecLock("SIG", .F. )
			SIG->IG_VLRMOV	:= 0
			SIG->IG_DTMOVI	:= CTOD("//")
			SIG->IG_DOCMOV	:= ""
			SIG->IG_AGEMOV	:= ""
			SIG->IG_CONMOV	:= ""
			SIG->IG_STATUS	:= "1"
			SIG->IG_HISMOV	:= ""
			SIG->IG_NATMOV	:= ""
		SIG->( MsUnLock() )
	Endif
Return


//------------------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475Efetiv
	Efetiva a gravação de movimentos bancários existentes no extrato (SIG) 
	nas tabelas FK5/SE5  - Efetivar

	@type  Function
	@author Pequim
	@since 31/01/2023
	@version 12.1.2310

	@param aUUID	, Array    , array contendo os IG_MSUIDT da TRB Origem
	@param cTableOri, Character, RealName da tabela temporária que contém os registros SIG (ORIGEM)
	@param cTableDes, Character, RealName da tabela temporária que contém os registros FK5 (DESTINO)
	@param cOriDes  , Character, Informa se a ação partiu da tabela de origem ou destino
			cOriDes = tabori => Efetivando o registro do extrato (SIG) no movimento bancário do Protheus (FK5) (Efetivar Registro)
			cOriDes = tabdes => Efetivando o registro do movimento bancário do Protheus (FK5) no extrato (SIG) (Conciliação Manual)
	@param cIdMatch , Character, Informa o código da configuração usada no processo (
	@param oData	, Json		, Informações da tela da efetivação com os dados contábeis, histórico e natureza
	@param cErro    , Character , Utilizado para devolver ao FRONT o erro caso ocorra.

	@return lRet, Logical, Retorna se a gravação foi realizada em sucesso

/*/
//------------------------------------------------------------------------------------------------------------------------------
Function F475Efetiv(aUUID as Array,cTableOri as Character,cTableDes as Character,cOriDes as Character, ;
					cIdMatch as Character, cCodCfg as Character, oData as Json, cErro as Character )

	Local cTable 	as Character
	Local lRet   	as Logical
	Local nRecno 	as Numeric
	Local nX     	as Numeric
	Local cNameDB	as Character

	Default aUUID     := {}
	Default cTableOri := ''
	Default cTableDes := ''
	Default cOriDes   := ''
	
	lRet := .T.
	nX := 0
	cNameDB := AllTrim(Upper(TCGetDB()))

	If __nTamRgMt == NIL
		__nTamRgMt := Space(TamSx3("QLD_REGMAT")[1])
		__nTamSqMt := TamSx3("QLD_SEQMAT")[1]
	Endif

	__cSeqMatc := ""

	If cOriDes == 'tabori'
		cTable := 'SIG'
	ElseIf cOriDes == 'tabdes'
		cTable := 'FK5'
	Endif

	// Conciliacao total - FK5
	If Empty(aUUID) .And. cOriDes == 'tabdes'
		aUUID := F475EFTAll(cTableDes)
	EndIf

	SEE->(DbSetOrder(1))//EE_FILIAL,EE_CODIGO,EE_AGENCIA,EE_CONTA,EE_SUBCTA

	Begin Transaction
		For nX := 1 to Len(aUUID)
			If cOriDes == 'tabori'
				nRecno := F475GetRec(cTable,aUUID[nX])
				If nRecno > 0
					(cTable)->(dbgoto(nRecno))
					lRet := F475GrDes(oData,@cErro)	//Efetivaçao de registros da SIG na FK5
				Endif
			Else	
				F475GrOri(cTableDes, aUUID[nX], cTableOri, cNameDB, cIdMatch, cCodCfg)	//Efetivaçao de registros da FK5 na SIG (MANUAL)
			Endif
			
			If lRet
				lRet := F475GrvTRB(aUUID[nX], cTableOri, cTableDes, cOriDes, cIdMatch, cCodCfg)
			Endif

			If !lRet
				DisarmTransaction()
				Break
			Endif
		Next

		If __oBlkOri <> NIL
			__oBlkOri:Commit()
			__oBlkOri:Destroy()
			__oBlkOri := NIL
		Endif	
	End Transaction

	If __oMdlMov != NIL
		__oMdlMov:Destroy()
		__oMdlMov:= Nil
	Endif

	__cSeqMatc := ""

Return lRet

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475EftAll
	Efetiva a gravação de todos movimentos bancários existentes nas tabelas FK5/SE5.

	@type Function
	@author vinicius.prado
	@since 13/01/2024

	@param cTable, Character, tabela em que será obtido os ids - FK5.
	@return aUUID, Array, lista com todos os ids disponiveis para conciliacao.
/*/
//--------------------------------------------------------------------------------------------
Function F475EFTAll(cTable as Character) as Array
	Local oExecQry 	:= Nil	as Object
	Local aUUID		:= {}	as Array
	Local cQuery 	:= ""	as Character
	Local cAliasTMP := ""	as Character

	cQuery := "SELECT FK5_MSUIDT IDEFET FROM ? WHERE IDMATCH = ? AND D_E_L_E_T_ = ? "

	oExecQry := FWExecStatement():New( ChangeQuery(cQuery) )
	oExecQry:SetUnsafe(1, cTable)
	oExecQry:SetString(2, '')
	oExecQry:SetString(3, ' ')

	cAliasTMP := oExecQry:OpenAlias()

	While (cAliasTMP)->(!Eof())
		aAdd(aUUID, (cAliasTMP)->IDEFET)
		(cAliasTMP)->(DbSkip())
	EndDo

	(cAliasTMP)->(dbCloseArea())

Return aUUID

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475GrOri
	Gravação dos movimentos na tabela Origem (SIG)

	@type  Function
	@author Pequim
	@since 07/02/2023
	@version 12.1.2210
	
	@param cOriDes  , Character, Informa se a ação partiu da tabela de origem ou destino
			cOriDes = tabori => Efetivando o registro do extrato (SIG) no movimento bancário do Protheus (FK5) (Efetivar Registro)
			cOriDes = tabdes => Efetivando o registro do movimento bancário do Protheus (FK5) no extrato (SIG) (Conciliação Manual)
	@param cErro    , Character , Utilizado para devolver ao FRONT o erro caso ocorra.

	@return lRet, Logical, Retorna se a gravação foi realizada em sucesso

/*/
//--------------------------------------------------------------------------------------------
Function F475GrOri(cTableDes as Character, cUUID as Character, cTableOri as Character,; 
					cNameDB as Character, cIdMatch as Character, cCodCfg as Character)
	Local cDebCred 	as Character
	Local cFilBkp	as Character
	Local cRegMatch as Character
	Local cSeqMatch as Character
	Local cQuery	as Character
	Local cAlsTmp	as Character
	Local cMsUIDT	as character

	cRegMatch := Substr(cIdMatch,1,3)
	cSeqMatch := Substr(cIdMatch,4)
	cFilBkp	:= cFilAnt
	cQuery := ""
	cAlsTmp := ""
	cMsUIDT := ""
	
	If __nTDcExt == NIL
		__nTDcExt := TamSx3("IG_DOCEXT")[1]
	Endif

	If __oGrOri == NIL
		cQuery := "SELECT FK5_FILORI, FK5_RECPAG, FK5_DTDISP, FK5_NUMCH, FK5_VALOR, "
		cQuery += "FK5_BANCO, FK5_AGENCI, FK5_CONTA, FK5_HISTOR "
		cQuery += "FROM ? "
		cQuery += "WHERE FK5_MSUIDT = ? "
		cQuery += "AND D_E_L_E_T_ = ? "

		__oGrOri := FWExecStatement():New(cQuery)
	Endif

	__oGrOri:SetUnsafe(1, cTableDes)
	__oGrOri:SetString(2, cUUID)
	__oGrOri:SetString(3, " ")

	cAlsTmp := __oGrOri:OpenAlias()

	If (cAlsTmp)->(!Eof())
		cFilAnt := (cAlsTmp)->FK5_FILORI

		If (cAlsTmp)->FK5_RECPAG == "R"
			cDebCred := "1"
		else
			cDebCred := "2"	
		Endif		

		If Empty(__cSeqMatc)
			//Ajusto a sequencia e o IdMatch para que seja gravado 1 sequencia para cada SIG:FK5 da conciliação manual
			totvs.protheus.backoffice.reconciliation.util.tcNextSeqMatch(cTableOri, @__cSeqMatc, cRegMatch, cCodCfg)
		Else
			__cSeqMatc := Soma1(__cSeqMatc)
		Endif

		cIdMatch  := cRegMatch + __cSeqMatc
		
		If __oBlkOri == NIL
			__oBlkOri := FINDTCRECORD():New(cTableOri, 900)
		Endif

		cMsUIDT := FWUUIDV4( !(cNameDB == "ORACLE") )

		If cNameDB $ "POSTGRES"
			cMsUIDT := Lower(cMsUIDT)
		Endif

		__oBlkOri:SetValue("IG_FILIAL"  , FwXFilial("SIG"))
		__oBlkOri:SetValue("IG_DTEXTR"	, (cAlsTmp)->FK5_DTDISP)
		__oBlkOri:SetValue("IG_DOCEXT"	, SubStr((cAlsTmp)->FK5_NUMCH, 1, __nTDcExt))
		__oBlkOri:SetValue("IG_CARTER"	, cDebCred)
		__oBlkOri:SetValue("IG_BCOEXT"  , (cAlsTmp)->FK5_BANCO)
		__oBlkOri:SetValue("IG_AGEEXT"  , (cAlsTmp)->FK5_AGENCI)
		__oBlkOri:SetValue("IG_CONEXT"  , (cAlsTmp)->FK5_CONTA)
		__oBlkOri:SetValue("IG_MSUIDT"	, cMsUIDT)
		__oBlkOri:SetValue("TABELA" 	, "SIG")
		__oBlkOri:SetValue("REGMATCH"	, cRegMatch)
		__oBlkOri:SetValue("DESMATCH" 	, 'manual')
		__oBlkOri:SetValue("SEQMATCH" 	, __cSeqMatc)
		__oBlkOri:SetValue("RECONCILED" , 'N')
		__oBlkOri:SetValue("IDMATCH" 	, cIdMatch)
		__oBlkOri:SetValue("TYPEMATCH" 	, "M")
		__oBlkOri:AddBulk()

		cFilAnt := cFilBkp
	Endif

	(cAlsTmp)->(DbCloseArea())
Return

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475GrDes
	Grava a Efetivação do movimento bancário (SIG -> FK5/SE5)

	@type  Function
	@author Pequim
	@since 31/01/2023
	@version 12.1.2310

	@param oData  , Json	  , Informações para a efetivação do registro
	@param cErro  , Character , Utilizado para devolver ao FRONT o erro caso ocorra.
	@param lIsJob , Logical   , Informa se a chamada está sendo feita via Job

	@return lRet, Logical, Retorna se a gravação foi realizada em sucesso
/*/
//--------------------------------------------------------------------------------------------
Function F475GrDes(oData as Json, cErro As character, lIsJob As Logical)

	Local aArea      := {}  as Array
	Local cCamposE5  := ""  as Character
	Local cDC        := "0" as Character
	Local cLog       := ""  as Character
	Local cSinal     := ""  as Character
	Local cTipoSist  := ""  as Character
	Local cTipoFK5   := ""  as Character
	Local cNaturEfet := ""  as Character
	Local cCDeb      := ""  as Character
	Local cCCrd      := ""  as Character
	Local cCCD       := ""  as Character
	Local cCCC       := ""  as Character
	Local cItemD     := ""  as Character
	Local cItemC     := ""  as Character
	Local cClVlDb    := ""  as Character
	Local cClVlCr    := ""  as Character
	Local cHistor    := ""  as Character
	Local lAtuSldNat := .T. as Logical
	Local lIntPFS    := .F. as Logical
	Local lRet       := .T. as Logical
	Local nRecno     := 0   as Numeric
	Local oSubFK5    := NIL as Object
	Local oSubFK8    := NIL as Object
	Local oSubFKA    := NIL as Object
	Local oAPIExt    := NIL as Object
	Local cCodOcor   := ""  as Character
	Local cFilBkp	 := cFilAnt as Character

	DEFAULT cErro  := ""
	DEFAULT lIsJob := .F.

	aArea 	   	:= GetArea()
	cDataExt   	:= DToS(SIG->IG_DTEXTR)
	cTipoSist  	:= GetAdvFVal("SEJ","EJ_OCORSIS", xFilial("SEJ",SIG->IG_FILORIG) + SIG->IG_BCOEXT + SIG->IG_TIPEXT ,1)
	lIntPFS    	:= SuperGetMV("MV_JURXFIN",,.F.) // Integração SIGAPFS x SIGAFIN
	cHistor    	:= SIG->IG_HISTEXT
	cCodOcor   	:= SIG->IG_TIPEXT
	cFilAnt 	:= SIG->IG_FILORIG

	// Caso o extrato tenha sido importado por API olhar a classe para pegar a ocorrencia (Não olha SEJ).
	If SEE->(dbSeek(xFilial("SEE", SIF->IF_FILIAL) + SIF->IF_BANCO + SIF->IF_AGENCIA + SIF->IF_CONTA + SIF->IF_SUBCTA))
		If __lExtAPI .And. SEE->EE_EXTAPI == "2"
			oAPIExt := &("totvs.protheus.backoffice.fin.banks.BanksStatement():new()")
	 		cTipoSist := oAPIExt:getStatementType(SIF->IF_BANCO, Val(SIG->IG_TIPEXT))
		EndIf
	EndIf
	
	If cTipoSist $ "CHQ"
		cTipoFK5 := "C1"
	Else	
		cTipoFK5 := "M1"
	Endif

	If SIG->IG_CARTER == "1"
		cDC := "R"
	Else
		cDC := "P"
	Endif

	If !DtMovFin(SIG->IG_DTEXTR)
		cErro := replace(Ap5GetHelp("DTMOVFIN"), CRLF, ' ')
		lRet := .F.
	Endif
	
	If lRet
		If !lIsJob
			If oData:hasProperty("naturefet")
				cNaturEfet := oData['naturefet']
				lRet := (!Empty(cNaturEfet) .and. ExistCpo("SED",cNaturEfet) .And. FinVldNat(.T.,cNaturEfet))
				If !lRet
					cErro := STR0047	//"Natureza inválida para o processo de efetivação"
				Endif
			Endif

			If lRet
				If oData:hasProperty("histor") .and. oData['histor'] != NIL
					cHistor := oData['histor']
					cHistor := DecodeUTF8(cHistor)
				Endif

				If oData:hasProperty("cdeb") .and. oData['cdeb'] != NIL
					cCDeb := oData['cdeb']
				Endif

				If oData:hasProperty("ccrd") .and. oData['ccrd'] != NIL
					cCCrd := oData['ccrd']
				Endif

				If oData:hasProperty("ccd") .and. oData['ccd'] != NIL
					cCCD := oData['ccd']
				Endif

				If oData:hasProperty("ccc") .and. oData['ccc'] != NIL
					cCCC := oData['ccc']
				Endif

				If oData:hasProperty("itemd") .and. oData['itemd'] != NIL
					cItemD := oData['itemd']
				EndIf

				If oData:hasProperty("itemc") .and. oData['itemc'] != NIL
					cItemC := oData['itemc']
				Endif

				If oData:hasProperty("clvldb") .and. oData['clvldb'] != NIL
					cClVlDb := oData['clvldb']
				Endif

				If oData:hasProperty("clvlcr") .and. oData['clvlcr'] != NIL
					cClVlCr := oData['clvlcr']
				Endif

				If Empty(cHistor)
					cHistor    := SIG->IG_HISTEXT
				Endif
			Endif
		Else
			cNaturEfet := SuperGetMV("MV_FNATCON",,.F.)

			If __lF475Nat == NIL
				__lF475Nat := ExistBlock("F475NAT")
			Endif

			If __lF475Nat
				cNaturEfet := ExecBlock( "F475NAT", .F., .F.,{cCodOcor})
			EndIf

			lRet := (!Empty(cNaturEfet) .and. ExistCpo("SED",cNaturEfet) .And. FinVldNat(.T.,cNaturEfet))
			If !lRet
				cErro := STR0047	//"Natureza inválida para o processo de efetivação"
			Endif		
		Endif
	Endif

	If lRet
		If SIG->IG_STATUS == "1"
			//Grava Movimentacao da efetivacao no SE5
			//Define os campos que não existem na FK5 e que serão gravados apenas na E5, para que a gravação da E5 continue igual
			cCamposE5 := "{"
			cCamposE5 += "{'E5_VENCTO'  , STOD('" + cDataExt + "')}"
			cCamposE5 += ",{'E5_DTDIGIT', STOD('" + cDataExt + "')}"
			cCamposE5 += ",{'E5_TIPODOC', 'DH'}"
			cCamposE5 += "}"

			//Model de Movimento bancario
			If __oMdlMov == NIL
				__oMdlMov  := FWLoadModel("FINM030")
			EndIf 

			__oMdlMov:SetOperation( 3 ) //Inclusao
			__oMdlMov:Activate()
			__oMdlMov:SetValue( "MASTER", "E5_GRV", .T. )
			__oMdlMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
			__oMdlMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Informa que a inclusão será feita com um novo número de processo

			//Dados do Processo
			oSubFKA := __oMdlMov:GetModel("FKADETAIL")
			oSubFKA:SetValue( "FKA_IDORIG", FWUUIDV4() )
			oSubFKA:SetValue( "FKA_TABORI", "FK5" )

			//Dados do Movimento
			oSubFK5 := __oMdlMov:GetModel("FK5DETAIL")
			oSubFK5:SetValue( "FK5_BANCO" , SIG->IG_BCOEXT  )
			oSubFK5:SetValue( "FK5_AGENCI", SIG->IG_AGEEXT  )
			oSubFK5:SetValue( "FK5_CONTA" , SIG->IG_CONEXT  )
			oSubFK5:SetValue( "FK5_DATA"  , SIG->IG_DTEXTR  )
			oSubFK5:SetValue( "FK5_TPDOC" , "DH"            ) 
			oSubFK5:SetValue( "FK5_DTDISP", SIG->IG_DTEXTR  )
			oSubFK5:SetValue( "FK5_HISTOR", cHistor         )
			oSubFK5:SetValue( "FK5_VALOR" , SIG->IG_VLREXT  )
			oSubFK5:SetValue( "FK5_NATURE", cNaturEfet      )
			oSubFK5:SetValue( "FK5_MOEDA" , cTipoFK5        )
			oSubFK5:SetValue( "FK5_RECPAG", cDC             )
			oSubFK5:SetValue( "FK5_FILORI", cFilAnt         )
			oSubFK5:SetValue( "FK5_ORIGEM", "FINA475"       )

			If cTipoSist == 'CHQ'
				oSubFK5:SetValue( "FK5_NUMCH", SIG->IG_DOCEXT )
			Endif

			//Dados Contábeis
			oSubFK8 := __oMdlMov:GetModel("FK8DETAIL")
			oSubFK8:SetValue( "FK8_DEBITO", cCDeb    )
			oSubFK8:SetValue( "FK8_CREDIT", cCCrd    )
			oSubFK8:SetValue( "FK8_CCD"   , cCCD     )
			oSubFK8:SetValue( "FK8_CCC"   , cCCC     )
			oSubFK8:SetValue( "FK8_ITEMD" , cItemD   )
			oSubFK8:SetValue( "FK8_ITEMC" , cItemC   )
			oSubFK8:SetValue( "FK8_CLVLDB", cClVlDb  )
			oSubFK8:SetValue( "FK8_CLVLCR", cClVlCr  )

			If __oMdlMov:VldData()
				__oMdlMov:CommitData()
			Else
				lRet := .F.
				cLog := cValToChar(__oMdlMov:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(__oMdlMov:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(__oMdlMov:GetErrorMessage()[6])
				Help( ,,"MF475GRVEF",,cLog, 1, 0 )
				cErro := cLog
			EndIf
			__oMdlMov:DeActivate()

			If lRet
				nRecno := SE5->(Recno())

				If FK5->FK5_RECPAG == "R"
					cSinal := "+"
				Else	
					cSinal := "-"
				Endif

				If __lF475AGR == NIL
					__lF475AGR := Existblock("F475AGRV")
				Endif

				// Complemento de Gravação na SE5/FK5 do processo de Actions (Efetivação)
				If __lF475AGR
			 		ExecBlock( "F475AGRV", .F., .F. ,{nRecno,'E'}) 	
					SE5->(DBGoTo(nRecno))
				EndIf

				//Integração com SIGAPFS x SIGAFIN
				If lIntPFS .And. FindFunction("JurConBco")
					JurConBco(nRecno, cNaturEfet, SIG->IG_SEQMOV, FK5->FK5_BANCO,FK5->FK5_AGENCI,FK5->FK5_CONTA, cDC, FK5->FK5_DATA,FK5->FK5_VALOR,SIG->IG_HISTEXT)
				EndIf

				//Atualiza saldo bancario quando da efetivação de movimento
				AtuSalBco( FK5->FK5_BANCO,FK5->FK5_AGENCI,FK5->FK5_CONTA,FK5->FK5_DATA,FK5->FK5_VALOR,cSinal)

				If lAtuSldNat	//definir uma natureza padrão para os movimentos (um novo MV_?)
					AtuSldNat(FK5->FK5_NATURE, FK5->FK5_DATA, "01", "3", FK5->FK5_RECPAG, FK5->FK5_VALOR, 0, "+",,FunName(),"SE5", nRecno,0)
				EndIf

			EndIf
		Endif
	Endif

	cFilAnt := cFilBkp
	RestArea(aArea)

Return lRet

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475GrvTRB
	Gravação do registro no TRB de destino no conciliador.
	
	@type  Function
	@author pequim
	@since 02/02/2023
	@version 12.1.2310

	@param cIdItem  , Character, conteúdo do campo IG_MSUIDT
	@param cTableDes, Character, RealName da tabela temporária que contém os registros FK5 (DESTINO)

	@return lRet, Logical, Retorna se a gravação foi realizada em sucesso
/*/
//--------------------------------------------------------------------------------------------
Function F475GrvTRB(cUUID as character, cTableOri as character, cTableDes  as character, cOriDes as character, ;
					cIdMatch as Character, cCodCfg as Character, lCancel as Logical)
	Local cCpoIdDes  as Character
	Local cCpoIdOri  as Character
	Local cCpoInsert as Character
	Local cDesMatch  as Character
	Local cError     as Character
	Local cRegMatch  as Character
	Local cSeqMatch  as Character
	Local cSQL       as Character
	Local cTable     as Character
	Local lRet       as Logical

	cCpoIdDes := 'FK5_MSUIDT'
	cCpoIdOri := 'IG_MSUIDT'
	cDesMatch := 'manual' //NÃO TRADUZIR
	cError    := ""
	cRegMatch := Substr(cIdMatch,1,3)
	cSeqMatch := Substr(cIdMatch,4)
	cSQL      := ""
	lRet := .T.

	Default lCancel := .F.

	If cOriDes == 'tabori'	//Origem
		//Açao originada da tabela Origem (SIG) e vai atualizar a tabela Destino (FK5)
		cTable := "FK5"
		cCpoId := 'FK5_MSUIDT'
		cTableTmp := cTableDes

		cCpoInsert := " FK5_DTDISP,FK5_VALOR,FK5_HISTOR,FK5_NUMCH,FK5_RECPAG,FK5_BANCO, "
		cCpoInsert += " FK5_AGENCI,FK5_CONTA,FK5_IDMOV,FK5_MSUIDT, FK5_NATURE, FK5_FILORI, "
		cCpoInsert += " TABELA, REGMATCH, DESMATCH, SEQMATCH, CODCON, IDDELETE, RECONCILED, IDMATCH, TYPEMATCH "

		cCposTemp  := "FK5_DTDISP,FK5_VALOR,FK5_HISTOR,FK5_NUMCH,FK5_RECPAG,FK5_BANCO,FK5_AGENCI,FK5_CONTA,FK5_IDMOV,FK5_MSUIDT,FK5_NATURE,FK5_FILORI,"
		cCposTemp  += "'"+cTable+"','999','manual','"+cSeqMatch+"',' ',' ','N','999"+cSeqMatch+"','M'"
		
		cSQL := "INSERT INTO "+ cTableTmp
		cSQL += " ("+cCpoInsert+") "
		cSQL += " SELECT "+cCposTemp
		cSQL += " FROM "+RetSqlName(cTable)
		cSQL += " WHERE R_E_C_N_O_ = " + cValToChar(FK5->(Recno())) + " "
		cSQL += " AND D_E_L_E_T_ = ' '"

		If TCSQLExec(cSQL) < 0
			cError := STR0042 + STR0043 //"matchProcessing Error: " "Nao foi possivel inserir dados na tabela temporaria: "
			cError += cTableTmp + STR0044	//". Para mais detalhes, verificar arquivo console.log"    
			lRet := .F.
		Else
			//Atualiza tabela temporaria de origem
			cQryUpdt := "UPDATE " + cTableOri
			cQryUpdt += " SET REGMATCH = '" + cRegMatch + "', DESMATCH = '" + cDesMatch + "', SEQMATCH = '" + cSeqMatch + "'," 
			cQryUpdt += " IDMATCH = '"+ cIdMatch + "', "     
			cQryUpdt += " TYPEMATCH = 'M'"    
			cQryUpdt += " WHERE " + cCpoIdOri + " = '" + cUUID + "'"
			cQryUpdt += " AND REGMATCH = '"+__nTamRgMt+"'"
			cQryUpdt += " AND RECONCILED = 'N' "          
			cQryUpdt += " AND D_E_L_E_T_ = ' ' "

			If TcSqlExec(cQryUpdt) < 0
				cError := STR0045	//"matchManual Error: Nao foi possivel atualizar a tabela temporaria: "
				cError += cTableOri + STR0044	//". Para mais detalhes, verificar arquivo console.log"
				lRet := .F.
			EndIf
		Endif
	Else
		//Atualiza tabela temporaria de origem
		cQryUpdt := "UPDATE " + cTableDes
		cQryUpdt += " SET REGMATCH = '" + cRegMatch + "', DESMATCH = '" + cDesMatch + "', SEQMATCH = '" + __cSeqMatc + "'," 
		cQryUpdt += " IDMATCH = '"+ cRegMatch + __cSeqMatc + "', "     
		cQryUpdt += " TYPEMATCH = 'M'"    
		cQryUpdt += " WHERE " + cCpoIdDes + " = '" + cUUID + "'"
		cQryUpdt += " AND REGMATCH = '"+__nTamRgMt+"'"
		cQryUpdt += " AND RECONCILED = 'N' "          
		cQryUpdt += " AND D_E_L_E_T_ = ' ' "

		If TcSqlExec(cQryUpdt) < 0
			cError := STR0045 //"matchManual Error: Nao foi possivel atualizar a tabela temporaria: "
			cError += cTableDes + STR0044	//". Para mais detalhes, verificar arquivo console.log"
			lRet := .F.
		EndIf
	Endif

Return lRet


//------------------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475CanEft
	Cancela a Efetivação de movimentos bancários existentes no extrato (SIG) e efetivadas nas tabelas FK5/SE5 
	através da opção Efetivar

	@type  Function
	@author Pequim
	@since 06/03/2023
	@version 12.1.2310

	@param aUUID	, Array    , array contendo os IG_MSUIDT da TRB Origem
	@param cTableOri, Character, RealName da tabela temporária que contém os registros SIG (ORIGEM)
	@param cTableDes, Character, RealName da tabela temporária que contém os registros FK5 (DESTINO)
	@param cOriDes  , Character, Informa se a ação partiu da tabela de origem ou destino
			cOriDes = tabori => Cancelando o registro efetivado a partir do registro do extrato (SIG) (Efetivar Registro)
	@param cIdMatch , Character, Informa o código da configuração usada no processo (
	@param oData	, Json		, Informações para o cancelamento do processo (não utilizado nesse processo)
	@param cErro    , Character , Utilizado para devolver ao FRONT o erro caso ocorra.

	@return lRet    , Logical, Retorna se a gravação foi realizada em sucesso

/*/
//------------------------------------------------------------------------------------------------------------------------------
Function F475CanEft(aUUID as Array,cTableOri as Character,cTableDes as Character,cOriDes as Character, ;
					cIdMatch as Character, cCodCfg as Character, oData as Json, cErro as Character )

	Local lRet   as Logical
	Local cTable as Character
	Local nRecno as Numeric
	Local nX     as Numeric

	Default aUUID     := {}
	Default cTableOri := ''
	Default cTableDes := ''
	Default cOriDes   := ''
	Default cErro     := ''

	lRet := .T.
	nX := 0

	If cOriDes == 'tabori'
		cTable := 'SIG'
	Endif	

	For nX := 1 to Len(aUUID)
		nRecno := F475GetRec(cTable,aUUID[nX])
		If nRecno > 0
			(cTable)->(dbgoto(nRecno))
			__cUUIDFK5 := ""
			If cOriDes == 'tabori'
				lRet := F475GrvCan(@cErro)					//Cancelar a efetivaçao de registros da SIG na FK5
			Endif

			If lRet
				lRet := F475CanTRB(cCodCfg,cTableDes,,@cErro)
			Endif
		Endif
	Next

Return lRet

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475GrvCan
	Grava o cancelamento da Efetivação do movimento bancário (SIG -> FK5/SE5)

	@type  Function
	@author Pequim
	@since 06/03/2023
	@version 12.1.2310

	@param cErro    , Character , Utilizado para devolver ao FRONT o erro caso ocorra.

	@return lRet, Logical, Retorna se a gravação foi realizada em sucesso

/*/
//--------------------------------------------------------------------------------------------
Function F475GrvCan(cErro as Character )

	Local aArea      	as Array
	Local aRecnos    	as Array
	Local cCamposE5  	as Character
	Local cDC        	as Character
	Local cLog       	as Character
	Local cSinal     	as Character
	Local cNaturEfet 	as Character
	Local cHistor    	as Character
	Local lAtuSldNat 	as Logical
	Local lIntPFS    	as Logical
	Local lRet       	as Logical
	Local nRecSE5    	as Numeric
	Local dDtBaseOld	as Date
	Local oModelDet  	as Object
	Local oSubFK5    	as Object
	Local oSubFK8    	as Object
	Local oSubFKA    	as Object
	Local cFilBkp		as Character

	aArea      	:= GetArea()
	aRecnos    	:= {}
	cCamposE5  	:= ""
	cDataExt   	:= DToS(SIG->IG_DTEXTR)
	cDC        	:= "0"
	cLog       	:= ""
	cNaturEfet 	:= ""
	lAtuSldNat 	:= .T.
	lIntPFS    	:= SuperGetMV("MV_JURXFIN",,.F.) // Integração SIGAPFS x SIGAFIN
	lRet       	:= .T.
	nRecSE5    	:= 0
	oModelDet  	:= NIL
	oSubFK5    	:= NIL
	oSubFK8    	:= NIL
	oSubFKA    	:= NIL
	cHistor    	:= SIG->IG_HISTEXT
	dDtBaseOld 	:= dDataBase
	cFilBkp		:= cFilAnt
	
	If SIG->IG_CARTER == "1"
		cDC := "R"
	Else
		cDC := "P"
	Endif

	cFilAnt := SIG->IG_FILORIG

	If __lF475AGR == NIL
		__lF475AGR := Existblock("F475AGRV")
	Endif

	F475RegCan(cDC,aRecnos)

	If Len(aRecnos) == 2
		FK5->(DbGoto(aRecnos[1]))
		__cUUIDFK5 := FK5->FK5_MSUIDT
		dDataBase := FK5->FK5_DTDISP

		nRecSE5 := aRecnos[2]
		SE5->(DbGoto(nRecSE5))

		cSeqCon := SE5->E5_SEQCON // Armazena sequência antes da exclusão
		cCamposE5 := "{ {'E5_RECONC', ''} }"

 		//Model de Movimento bancario
		oModelDet  := FWLoadModel("FINM030")
		oModelDet:SetOperation( 4 ) //Alteração
		oModelDet:Activate()
		oModelDet:SetValue("MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
		oModelDet:SetValue("MASTER", "E5_OPERACAO", 1 ) //E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
		oModelDet:SetValue("MASTER", "E5_CAMPOS", cCamposE5) //Informa os campos da SE5 que serão gravados indepentes de FK5

		//Posiciona a FKA com base no IDORIG da SE5 posicionada
		oSubFKA := oModelDet:GetModel("FKADETAIL")
		oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )

		//Dados do movimento
		oSubFK5 := oModelDet:GetModel( "FK5DETAIL" )
		oSubFK5:SetValue( "FK5_DTCONC", CTOD("") )
		oSubFK5:SetValue( "FK5_SEQCON", "" )

		//A inclusão deste trecho se deve somente para correção de erro em base historica de clientes que realizaram a conciliação
		//automatica e ficaram com o campo FK5_TPDOC vazio por ter realizado a alteração do campo FK5_TPDOC igual ao E5_TIPODOC
		If Empty(oSubFK5:GetValue("FK5_TPDOC"))
			oSubFK5:SetValue("FK5_TPDOC", "DH")
		EndIf

		If oModelDet:VldData()
	       	oModelDet:CommitData()
		Else
			lRet := .F.
		    cErro := cValToChar(oModelDet:GetErrorMessage()[4]) + ' - '
		    cErro += cValToChar(oModelDet:GetErrorMessage()[5]) + ' - '
		    cErro += cValToChar(oModelDet:GetErrorMessage()[6])
		EndIf

	    oModelDet:DeActivate()
		oModelDet:Destroy()
		
		dDataBase := dDtBaseOld
		
		If lRet
			nRecSE5 := SE5->(Recno())

			If FK5->FK5_RECPAG == "R"
				cSinal := "-"
			Else	
				cSinal := "+"
			Endif
			
			// Complemento de Gravação na SE5/FK5 do processo de Actions (Cancelar Efetivação)
			If __lF475AGR
			 	ExecBlock( "F475AGRV", .F., .F. ,{nRecSE5,'C'}) 
				SE5->(DBGoTo(nRecSE5))
			EndIf

			//Integração com SIGAPFS x SIGAFIN
			If lIntPFS .And. FindFunction("JurEstConc")
				JurEstConc(nRecSE5, cSeqCon)
			EndIf

			//Atualiza saldo bancario quando da efetivação de movimento
			AtuSalBco( FK5->FK5_BANCO,FK5->FK5_AGENCI,FK5->FK5_CONTA,FK5->FK5_DTDISP,FK5->FK5_VALOR,cSinal)

			//Atualiza saldo das naturezas
			AtuSldNat(FK5->FK5_NATURE, FK5->FK5_DTDISP, "01", "3", FK5->FK5_RECPAG, FK5->FK5_VALOR, 0, "-",,FunName(),"SE5", nRecSE5,0)

		EndIf
	else
		cErro := STR0048 //"Este registro não possui efetivação realizada."
		lRet := .F.
	Endif

	cFilAnt := cFilBkp
	FwFreeArray(aRecnos)
	aRecnos := {}
	RestArea(aArea)

Return lRet

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475CanTRB
	Grava o cancelamento da Efetivação do movimento bancário (SIG -> FK5/SE5)

	@type  Function
	@author Pequim
	@since 06/03/2023
	@version 12.1.2310


	@param cCodCfg, Character, Código da regra de conciliação (0023/0024)
	@param cTable , Character, RealName da tabela temporária que contém os registros FK5 (DESTINO) ou SIG (ORIGEM)
	@param cUuid  , Character, UUID do registro para cancelamento match (0024)
	@param cErro  , Character, Utilizado para devolver ao FRONT o erro caso ocorra.

	@return lRet, Logical, Retorna se a gravação foi realizada em sucesso

/*/
//--------------------------------------------------------------------------------------------
Function F475CanTRB(cCodCfg as Character, cTable as Character, cUuid as Character, cError as Character)

	Local cMsg      := ''  	as Character
	Local cQryUpdt  := ''  	as Character
	Local cQueryUpd := ''  	as Character
	Local lRet      := .F. 	as Logical
	Local cMSUIDT   := '' 	as Character

	Default cCodCfg := ''
	Default cTable  := ''
	Default cUuid  := ''

	cMSUIDT   := RTrim(cUuid)

	If (cCodCfg == '0024' .Or. ((QLB->(FieldPos("QLB_CFGORI")) > 0) .And. (QLB->QLB_CFGORI == "0024")))	//Conciliacao Manual
		If __oPrepStH == NIL
			//Atualiza tabela temporaria de origem
			cQryUpdt := "DELETE FROM ? "
			cQryUpdt += "WHERE IG_MSUIDT = ? AND "
			cQryUpdt += "D_E_L_E_T_ = ' ' "
			__oPrepStH := FwPreparedStatement():New(cQryUpdt)
		EndIf
		__oPrepStH:SetUnsafe(1, cTable)
		__oPrepStH:SetString(2, cMSUIDT)
		cQryUpdt := __oPrepStH:GetFixQuery()
		cMsg := ' [TRB] '	

		If TcSqlExec(cQryUpdt) == 0
			If __oPrepStI == NIL
				cQueryUpd :=  " UPDATE ? "
				cQueryUpd +=  " SET D_E_L_E_T_ = '*' , " 
				cQueryUpd +=  " R_E_C_D_E_L_ = R_E_C_N_O_ "  
				cQueryUpd +=  " WHERE IG_MSUIDT = ? AND "
				cQueryUpd +=  " D_E_L_E_T_ = ' ' "
				__oPrepStI := FwPreparedStatement():New(cQueryUpd)
			EndIf
			__oPrepStI:SetUnsafe(1, RetSQLName("SIG"))
			__oPrepStI:SetString(2, cMSUIDT)
			cQueryUpd := __oPrepStI:GetFixQuery()
			cMsg := ' [SIG] '	
			If TcSqlExec(cQueryUpd) == 0
				lRet := .T.
			Endif	
		EndIf
	Else
		If __oPrepStD == NIL
			//Atualiza tabela temporaria de origem
			cQryUpdt := "DELETE FROM ? "
			cQryUpdt += " WHERE FK5_MSUIDT = ? "
			__oPrepStD := FwPreparedStatement():New(cQryUpdt)
		EndIf
		__oPrepStD:SetUnsafe(1,cTable)
		__oPrepStD:SetString(2,__cUUIDFK5 )
		cQryUpdt	:= __oPrepStD:GetFixQuery()
		cMsg := ' [FK5] '
		If TcSqlExec(cQryUpdt) == 0
			lRet := .T.
		Endif
	Endif

	If !lRet
		cError := STR0049 + cMsg	//"cancel effectiveness Error: Nao foi possivel excluir o registro da tabela temporaria: "
		cError += cTable + STR0044	//". Para mais detalhes, verificar arquivo console.log"
	EndIf

Return lRet


//------------------------------------------------------------------------
/*/{Protheus.doc} F475RegCan
	Retorna o Recno para o cancelamento dos registros efetivados 
	
	@type  Function
	@author Pequim
	@since 07/11/2022

	@param cDC    , Character, Indica a carteira do registro (Pagar ou Receber)
	@param aRecnos, Array    , Recnos dos registros a serem cancelados

	/*/
//------------------------------------------------------------------------
Function F475RegCan(cDC as Character, aRecnos as Array )
	Local cQuery    as Character
	Local nRecno    as Numeric
	Local cTableFKA as Character
	Local cTipoSist as Character
	Local cNumCh	as Character
	Local nParam	as Numeric

	cQuery 		:= ""
	nRecno 		:= 0
	cTableFKA	:= RetSqlName("FKA")
	cTipoSist  	:= GetAdvFVal("SEJ","EJ_OCORSIS", xFilial("SEJ",SIG->IG_FILORIG) + SIG->IG_BCOEXT + SIG->IG_TIPEXT ,1)
	cNumCh 		:= Space(TamSX3("FK5_NUMCH")[1])
	nParam		:= 1

	If __oPrepStE == Nil
		cQuery := "SELECT R_E_C_N_O_ FK5RECNO "
		cQuery += "FROM ? "
		cQuery += "WHERE FK5_FILIAL = ? "
		cQuery += 	"AND FK5_BANCO = ? "
		cQuery +=   "AND FK5_AGENCI = ? "
		cQuery +=   "AND FK5_CONTA = ? "
		cQuery +=   "AND FK5_DTDISP = ? "
		cQuery +=   "AND FK5_NUMCH = ? "
		cQuery +=   "AND FK5_VALOR = ? "
		cQuery +=   "AND FK5_RECPAG = ? "
		cQuery +=   "AND FK5_ORIGEM = ? "
		cQuery +=   "AND FK5_TPDOC = ? "
		cQuery +=   "AND D_E_L_E_T_ = ? AND "
		cQuery +=   	"EXISTS ("
		cQuery +=   	"SELECT FKA.FKA_IDFKA "
		cQuery +=   	"FROM ? FKA "
		cQuery +=   	"WHERE FKA.FKA_FILIAL = FK5_FILIAL "
		cQuery +=   		"AND FKA.FKA_TABORI = ? "
		cQuery +=   		"AND FKA.FKA_IDORIG = FK5_IDMOV "
		cQuery +=   		"AND FKA.D_E_L_E_T_ = ? AND "
		cQuery +=   		"NOT EXISTS ( "
		cQuery +=   		  "SELECT FKAEST.R_E_C_N_O_ ,  FKAEST.D_E_L_E_T_ "
		cQuery +=   		  "FROM ? FKAEST "
		cQuery +=   		  "WHERE FKAEST.FKA_FILIAL = FKA.FKA_FILIAL "
		cQuery +=   		  "AND FKAEST.FKA_IDORIG <> FK5_IDMOV "
		cQuery +=   		  "AND FKAEST.FKA_IDPROC = FKA.FKA_IDPROC "
		cQuery +=   		  "AND FKAEST.FKA_TABORI = FKA.FKA_TABORI "
		cQuery +=   		  "AND FKAEST.D_E_L_E_T_ = ?)  )"
		cQuery := ChangeQuery(cQuery)
		__oPrepStE := FWExecStatement():New(cQuery)
	EndIf

	If cTipoSist == 'CHQ'
		cNumCh := SIG->IG_DOCEXT
	Endif

	__oPrepStE:SetUnsafe(nParam++ , RetSqlName("FK5")) //FROM FK5T10
	__oPrepStE:SetString(nParam++ , FwXFilial("FK5", SIG->IG_FILORIG)) //FK5_FILIAL
	__oPrepStE:SetString(nParam++ , SIG->IG_BCOEXT) //FK5_BANCO
	__oPrepStE:SetString(nParam++ , SIG->IG_AGEEXT) //FK5_AGENCI
	__oPrepStE:SetString(nParam++ , SIG->IG_CONEXT) //FK5_CONTA
	__oPrepStE:SetDate(nParam++ , SIG->IG_DTEXTR) //FK5_DTDISP
	__oPrepStE:SetString(nParam++ , cNumCh ) //FK5_NUMCH
	__oPrepStE:SetNumeric(nParam++ , SIG->IG_VLREXT) //FK5_VALOR
	__oPrepStE:SetString(nParam++ , cDC) //FK5_RECPAG
	__oPrepStE:SetString(nParam++ , "FINA475") //FK5_ORIGEM
	__oPrepStE:SetString(nParam++ , "DH") //FK5_TPDOC
	__oPrepStE:SetString(nParam++ , " ") //FK5.D_E_L_E_T_

	__oPrepStE:SetUnsafe(nParam++ , cTableFKA) //FROM FKAT10 FKA
	__oPrepStE:SetString(nParam++ , "FK5") //FKA.FKA_TABORI
	__oPrepStE:SetString(nParam++ , " ") //FKA.D_E_L_E_T_

	__oPrepStE:SetUnsafe(nParam++, cTableFKA) //FROM FKAT10 FKAEST
	__oPrepStE:SetString(nParam++ , " ") //FKAEST.D_E_L_E_T_

	nRecno	:= __oPrepStE:ExecScalar("FK5RECNO")

	If nRecno > 0
		AADD(aRecnos, nRecno)
		FK5->(dbGoto(nRecno))	

		If __oPrepStF == Nil
			cQuery := "SELECT R_E_C_N_O_ SE5RECNO "
			cQuery += "FROM " + RetSqlName("SE5") + " "
			cQuery += "WHERE E5_FILIAL = ? "
			cQuery +=  " AND E5_IDORIG = ? "
			cQuery +=  " AND D_E_L_E_T_ = ? "
			cQuery := ChangeQuery(cQuery)
			__oPrepStF := FWExecStatement():New(cQuery)
		EndIf

		__oPrepStF:SetString(1,	 FK5->FK5_FILIAL)
		__oPrepStF:SetString(2,	 FK5->FK5_IDMOV)
		__oPrepStF:SetString(3,	 " ")

		nRecno	:= __oPrepStF:ExecScalar("SE5RECNO")

		If nRecno > 0
			AADD(aRecnos, nRecno)
		Endif
	Endif
Return

//------------------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F475Dispo
	Efetiva a gravação de data de disponibilidade informada pelo usuário

	@type  Function
	@author Pequim
	@since 31/01/2023
	@version 12.1.2310

	@param aUUID	, Array    , array contendo os IG_MSUIDT da TRB Origem
	@param cTableOri, Character, RealName da tabela temporária que contém os registros SIG (ORIGEM)
	@param cTableDes, Character, RealName da tabela temporária que contém os registros FK5 (DESTINO)
	@param cOriDes  , Character, Informa se a ação partiu da tabela de origem ou destino
			cOriDes = tabori => Efetivando o registro do extrato (SIG) no movimento bancário do Protheus (FK5) (Efetivar Registro)
			cOriDes = tabdes => Efetivando o registro do movimento bancário do Protheus (FK5) no extrato (SIG) (Conciliação Manual)
	@param cIdMatch , Character, Informa o código da configuração usada no processo (
	@param oData	, Json		, Informações da tela da efetivação com os dados contábeis, histórico e natureza
	@param cErro    , Character , Utilizado para devolver ao FRONT o erro caso ocorra.

	@return lRet, Logical, Retorna se a gravação foi realizada em sucesso

/*/
//------------------------------------------------------------------------------------------------------------------------------
Function F475Dispo(aUUID as Array,cTableOri as Character,cTableDes as Character,cOriDes as Character, ;
					cIdMatch as Character, cCodCfg as Character, oData as Json, cErro as Character )

	Local aSaldo    := {}         as Array
	Local dAuxDispo := CTOD("//") as Date
	Local dNewDispo := CTOD("//") as Date
	Local dOldDispo := CTOD("//") as Date
	Local lRet      := .T.        as Logical
	Local nOpcao    := 0          as Numeric
	Local nX        := 0          as Numeric
	Local lUnicoMov := .F.		  as Logical

	Default aUUID     := {}
	Default cTableOri := ''
	Default cTableDes := ''
	Default cOriDes   := ''
	
	If __nTamSqMt == NIL
		__nTamSqMt := TamSx3("QLD_SEQMAT")[1]
	Endif

	lUnicoMov := Len(aUUID) == 1

	If cOriDes == 'tabdes'
		FK5->(DbSetOrder(1))	//FK5_FILIAL+FK5_IDMOV
		For nX := 1 to Len(aUUID)
			If cOriDes == 'tabdes'
				If oData:hasProperty("dtdispo") .and. oData['dtdispo'] != NIL
					dOldDispo := GetDtDisp(aUUID[nX], cTableDes)
					dNewDispo  := CTOD(oData[ 'dtdispo' ])

					If !DtMovFin(dNewDispo)
						cErro := replace(Ap5GetHelp("DTMOVFIN"), CRLF, ' ')
						return .F.
					Endif

					If oData:hasProperty("aplicdispo") .and. oData['aplicdispo'] != NIL
						nOpcao := oData['aplicdispo']
						If dOldDispo != dNewDispo .and. (nOpcao != 2 .or. (dOldDispo != dAuxDispo .and. nOpcao == 2))
							dAuxDispo := dOldDispo
							lRet := FGrvDtDis(aUUID[nX], cTableDes, cOriDes, dOldDispo, dNewDispo, nOpcao, @cErro, aSaldo, lUnicoMov )		//Grava Dt Dispo na TRBFK5
							If nOpcao == 3		//Todos
								Exit
							Endif
						Endif
					Endif
				Endif
			Endif
		Next
	Endif

	If __oSE5Chq <> Nil
		__oSE5Chq:Destroy()
		__oSE5Chq := Nil
	EndIf

	If Len(aSaldo)	> 0
		lRet := FAtuSlBc(aSaldo)
	Endif

Return lRet


//------------------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGrvDtDis
	Efetiva a gravação da nova data de disponibilidade na FK5

	@type  Function
	@author Pequim
	@since 264/10/2023
	@version 12.1.2310

	@param cUUID	, Character , ID do registro
	@param cTable	, Character , RealName da tabela temporária 
	@param cOriDes  , Character , Informa se a ação partiu da tabela de origem ou destino
			cOriDes = tabori => Efetivando o registro do extrato (SIG) no movimento bancário do Protheus (FK5) (Efetivar Registro)
			cOriDes = tabdes => Efetivando o registro do movimento bancário do Protheus (FK5) no extrato (SIG) (Conciliação Manual)
	@param dOldDispo, Date		, Data de disponibilidade do registro antes da alteração
	@param dNewDispo, Date		, Data de disponibilidade a ser atualizada no registro
	@param nOpcao	, Numeric   , Informações da tela da efetivação com os dados contábeis, histórico e natureza
	@param cErro    , Character , Utilizado para devolver ao FRONT o erro caso ocorra.

	@return lRet, Logical, Retorna se a gravação foi realizada em sucesso

/*/
//------------------------------------------------------------------------------------------------------------------------------
Static Function FGrvDtDis(cUUID as Character, cTable as Character, cOriDes as Character,;
							dOldDispo as Date, dNewDispo as Date, nOpcao as Numeric,;
							cErro as Character, aSaldo as Array, lUnicoMov as Logical)

	Local cMsg     := ""  as Character
	Local cQryUpdt := ""  as Character
	Local cWhere   := ""  as Character
	Local lRet     := .T. as Logical
	Local lUpdate  := .T. as Logical

	If nOpcao == 1
		cWhere := " WHERE FK5_MSUIDT = '" + cUUID + "' AND D_E_L_E_T_ = ' ' "
	ElseIf nOpcao == 2
		cWhere := " WHERE FK5_DTDISP = '" + DTOS(dOldDispo) + "' AND SEQMATCH = '"+ Space(__nTamSqMt) + "' AND D_E_L_E_T_ = ' ' "
	Else
		cWhere := " WHERE SEQMATCH = '"+ Space(__nTamSqMt) + "' AND D_E_L_E_T_ = ' ' "
	Endif	

	If __oPrepStJ == NIL
		cQryUpdt := "SELECT FK5_FILORI, FK5_DTDISP, FK5_BANCO, FK5_AGENCI, FK5_CONTA, FK5_IDMOV FROM ? "
		cQryUpdt += "?"
		
		cQryUpdt := ChangeQuery(cQryUpdt)
		__oPrepStJ:=FWPreparedStatement():New(cQryUpdt)
	Endif
	cMsg := "[FK5]"		
	__oPrepStJ:SetUnsafe(1,cTable)
	__oPrepStJ:SetUnsafe(2,cWhere)
	cQryUpdt := __oPrepStJ:GetFixQuery()
	cAliasTmp := MpSysOpenQuery(cQryUpdt)

	//Obtém dados para atualização da SE5/FK5
	While (cAliasTmp)->(!Eof())
		If FK5->(dbSeek(xFilial("FK5",(cAliasTmp)->FK5_FILORI)+(cAliasTmp)->FK5_IDMOV))
			If (lUpdate := dNewDispo >= FK5->FK5_DATA)
				aadd(aSaldo, {(cAliasTmp)->FK5_DTDISP, (cAliasTmp)->FK5_BANCO, (cAliasTmp)->FK5_AGENCIA, (cAliasTmp)->FK5_CONTA, FK5->(Recno())} )
				FGrvFK5(.T., dNewDispo,.T.)
			Endif

			//Quando existe somente um registro selecionado e só para ele será aplicado
			//a alteração, sendo assim, exibe mensagem ao usuario
			If !lUpdate .and. nOpcao == 1 .and. lUnicoMov
				cErro := STR0054 //"Data de disponibilidade não pode ser anterior a data de inclusão do movimento. Verifique o movimento selecionado e tente novamente!"
				lRet := .F.
			Endif
		Endif
		(cAliasTmp)->(DbSkip())
	EndDo

    (cAliasTmp)->(DbCloseArea())

	If lUpdate
		//Atualiza a tabela do conciliador (TRB)
		cQryUpdt := "UPDATE " + cTable
		cQryUpdt += " SET FK5_DTDISP = '" + DTOS(dNewDispo) + "' "  
		cQryUpdt += cWhere 
		cMsg := "[TRB]"
		lRet := TcSqlExec(cQryUpdt) == 0

		If !lRet
			cErro := STR0045 + cMsg	//"Error: Nao foi possivel atualizar a tabela temporaria: "
			cErro += cTableOri + STR0044	//". Para mais detalhes, verificar arquivo console.log"
		EndIf
	Endif

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} GetDtDisp
	(long_description)
	@type  Function
	@author Pequim
	@since 31/10/2023
	@version version
	@param cUUID	, Character , ID do registro
	@param cTable	, Character , RealName da tabela temporária 

	@return dOldDispo, Date, Data de disponibilidade atual (TRB)
/*/
//---------------------------------------------------------------------
Static Function GetDtDisp(cUUID as Character, cTable as Character)
	Local dOldDispo as Date
	Local cQuery 	as Character

	dOldDispo := CTOD("//")
	cQuery := ""

	If __oPrepStG == NIL
		cQuery := "SELECT FK5_DTDISP DTDISPO "
		cQuery += " FROM ? "
		cQuery += " WHERE "
		cQuery += " FK5_MSUIDT = ? AND "
		cQuery += " D_E_L_E_T_ = ? "
		
		cQuery := ChangeQuery(cQuery)
		__oPrepStG := FWExecStatement():New(cQuery)
	Endif
		
	__oPrepStG:SetUnsafe(1, cTable)
	__oPrepStG:SetString(2, cUUID)
	__oPrepStG:SetString(3, " ")
	
	dOldDispo := STOD(__oPrepStG:ExecScalar("DTDISPO"))

Return dOldDispo


//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FAtuSlBc
	Atualização de saldos bancários para registros com ajuste de Data de Disponibilidade
	
	@type  Pequim
	@since 15/12/2023
	@version 12
	@param aSaldo, Array, Informações para atualização de saldo
	@return lRet, Logical, Identifica o resultado do processo
/*/
//-------------------------------------------------------------------------------------------------
Function FAtuSlBc(aSaldo as Array)

	Local aSldAtu   := {}       as Array
	Local aSldOld   := {}       as Array
	Local cChaveOld := ""       as Character
	Local cChaveSld := ""       as Character
	Local cNewDisp  := ""       as Character
	Local cOldDisp  := ""       as Character
	Local dOldDisp  := CTOD("") as Date
	Local lNewDispo := .F.      as Logical
	Local lRet      := .T.      as Logical
	Local nTamSlAtu := 0        as Numeric
	Local nTamSlOld := 0        as Numeric
	Local nX        := 0        as Numeric
	Local cFilBkp	:= ""		as Character

	For nX := 1 to Len(aSaldo)
		FK5->(DBGoTo(aSaldo[nX,5]))

		cOldDisp := aSaldo[nX,1]
		dOldDisp := STOD(cOldDisp)
		cNewDisp := DTOS(FK5->FK5_DTDISP)
		lNewDispo := .F.
		If cOldDisp != cNewDisp
			lNewDispo := .T.
		Endif
		//Valores a atualizar no saldo conciliado e no saldo com alteração de Dt Dispo
		If cChaveSld !=  FK5->(FK5->FK5_FILORI+cNewDisp+FK5_BANCO+FK5_AGENCI+FK5_CONTA)
			cChaveSld := FK5->(FK5->FK5_FILORI+cNewDisp+FK5_BANCO+FK5_AGENCI+FK5_CONTA)
			nValor := 0
			AADD(aSldAtu , {FK5->FK5_BANCO, FK5->FK5_AGENCI, FK5->FK5_CONTA, FK5->FK5_DTDISP, nValor, FK5->FK5_FILORI})
			nTamSlAtu := Len(aSldAtu)
		Endif
		If lNewDispo
			aSldAtu[nTamSlAtu,5] += (FK5->FK5_VALOR * IF(FK5->FK5_RECPAG == "R", 1, -1 ))
		Endif

		//Valores a atualizar no saldo atual das datas originais, quando houve troca de Dt Dispo
		If cChaveOld !=  FK5->(FK5->FK5_FILORI+cOldDisp+FK5_BANCO+FK5_AGENCI+FK5_CONTA)
			cChaveOld := FK5->(FK5->FK5_FILORI+cOldDisp+FK5_BANCO+FK5_AGENCI+FK5_CONTA)
			nValor := 0
			AADD(aSldOld, {FK5->FK5_BANCO, FK5->FK5_AGENCI, FK5->FK5_CONTA, dOldDisp, nValor, FK5->FK5_FILORI})
			nTamSlOld := Len(aSldOld)
		Endif			
		If lNewDispo
			aSldOld[nTamSlOld,5] += (FK5->FK5_VALOR * IF(FK5->FK5_RECPAG == "R", 1, -1 ))
		Endif
	Next

	//Atualiza saldos Originais (mudança de DtDispo - Nova data)
	cFilBkp	:= cFilAnt
	For nX := 1 to nTamSlAtu
		If  aSldAtu[nX,5] != 0
			cFilAnt := aSldAtu[nX,6]
			AtuSalBco(aSldAtu[nX,1], aSldAtu[nX,2], aSldAtu[nX,3], aSldAtu[nX,4], aSldAtu[nX,5], "+",.F., .T.)
		Endif
	Next

	//Atualiza saldos Originais (mudança de DtDispo - velha data)
	For nX := 1 to nTamSlOld
		If  aSldOld[nX,5] != 0
			cFilAnt := aSldOld[nX,6]
			AtuSalBco(aSldOld[nX,1], aSldOld[nX,2], aSldOld[nX,3], aSldOld[nX,4], aSldOld[nX,5], "-",.F., .T.)
		Endif
	Next

	cFilAnt := cFilBkp	

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} getApiExtrato
	Realiza a gravação da SIF/SIG através da integração por API.

	@type  Function
	@author vincius.prado
	@since 26/12/2023
	@version 1.0
	@param cFilProc	, Character , Filial do processamento
	@param cBanco	, Character , Banco do processamento 
	@param cAgencia	, Character , Agencia do processamento 
	@param cConta	, Character , Conta do processamento 
	@param cSubCta	, Character , SubConta do processamento 
	@param cIdProc	, Character , ID do processamento
	@return lProcOk, Logical, Indica se foi possivel realizar a integração
/*/
//---------------------------------------------------------------------
Function getApiExtrato(cFilProc, cBanco, cAgencia, cConta, cSubCta, cIdProc, aMsgSch)
	Local jResponse := JsonObject():New() as Json
	Local oAPIExt 	:= Nil as Object
	Local lProcOk 	:= .F. as Logical

	cFilAnt := cFilProc

	If SA6->(DbSeek(xFilial("SA6") + cBanco + cAgencia + cConta))
		oAPIExt := &("totvs.protheus.backoffice.fin.banks.BanksStatement():new()")
		oAPIExt:setConfig(SA6->(RECNO()), SEE->(RECNO()))
		oAPIExt:setOperation("api_extrato_bancario_conciliacao")

		jResponse := oAPIExt:recordsBanksStatement(cIdProc, cBanco, cAgencia, cConta, cSubCta)
		lProcOk := jResponse['transmitted']

		If !lProcOk
			Aadd(aMsgSch, STR0028 + cBanco + STR0029 + cAgencia + STR0030 + cConta + STR0031 + cSubCta)		//"Banco: "###" Agência: "###" Conta: "###" SubConta: "
			AAdd(aMsgSch, STR0051 + jResponse['errors'][1]['message'])										// 'Erro ao processar API de importação: '
		EndIf
	EndIf

Return lProcOk

//---------------------------------------------------------------------
/*/{Protheus.doc} F475grvCom
	Realiza as gravacoes dos movimentos complementares da FK5/SE5.

	@type Static Function
	@author vincius.prado
	@since 26/02/2025
	@version 1.0
/*/
//---------------------------------------------------------------------
Static Function F475grvCom(nRecSE5 as Numeric, dDtDispo as Date)
	Local aAreaSE5	as Array
	Local cQuery	as Character
	Local cAliasChq	as Character
	Local nParam	as Numeric
	Local cAliasFK	as Character
	Local cTPDoc	as Character

	aAreaSE5 	:= SE5->(GetArea())
	SE5->(dbGoTo(nRecSE5))
	nParam		:= 1
	cAliasChq	:= ""
	cAliasFK	:= "FK2"
	cTPDoc		:= "BA "

	If __oSE5Chq == Nil
		cQuery := "SELECT SE5.R_E_C_N_O_ RECNOBA "
		cQuery += "FROM	" + RetSqlName('SE5') + " SE5 "
		cQuery += " WHERE "
		cQuery += 	" SE5.E5_FILIAL = ? AND "
		cQuery += 	" SE5.E5_DATA = ? AND "
		cQuery += 	" SE5.E5_BANCO 	= ? AND "
		cQuery += 	" SE5.E5_AGENCIA = ? AND "
		cQuery += 	" SE5.E5_CONTA 	= ? AND "
		cQuery += 	" SE5.E5_NUMCHEQ = ? AND "
		cQuery += 	" SE5.E5_TIPODOC = ? AND "
		cQuery += 	" SE5.D_E_L_E_T_ = ? "

		cQuery := ChangeQuery(cQuery)
		__oSE5Chq := FWExecStatement():New(cQuery)
	EndIf

	__oSE5Chq:SetString(nParam++, SE5->E5_FILIAL)
	__oSE5Chq:SetDate(nParam++, SE5->E5_DATA)
	__oSE5Chq:SetString(nParam++, SE5->E5_BANCO)
	__oSE5Chq:SetString(nParam++, SE5->E5_AGENCIA)
	__oSE5Chq:SetString(nParam++, SE5->E5_CONTA)
	__oSE5Chq:SetString(nParam++, SE5->E5_NUMCHEQ)
	__oSE5Chq:SetString(nParam++, cTPDoc)
	__oSE5Chq:SetString(nParam++, " ")
	
	cAliasChq := __oSE5Chq:OpenAlias()

	While (cAliasChq)->(!Eof())
		// Atualiza linha BA - SE5
		SE5->(dbGoto((cAliasChq)->RECNOBA))
		RecLock("SE5",.F.)
			SE5->E5_DTDISPO := dDtDispo
		SE5->(MsUnLock())

		cAliasFK := SE5->E5_TABORI

		// Atualiza linha BA - FK1 ou FK2
		If (cAliasFK)->(dbseek(SE5->E5_FILIAL+SE5->E5_IDORIG))
			Reclock(cAliasFK,.F.)
				(cAliasFK)->&(cAliasFK + "_DTDISP") := dDtDispo
			(cAliasFK)->(MsUnlock())
		EndIf
		(cAliasChq)->(DbSkip())
	EndDo

	(cAliasChq)->(dbCloseArea())
	RestArea(aAreaSE5)

Return Nil

/*/{Protheus.doc} F475GrvSIG
	Grava os dados fake do extrato para conciliação dos movimentos quando efetuado pela
	Conciliação Manual - 0024, a função irá verificar quais registros existem so na temporaria
	que precisam ser incluidos na tabela fisica
	@type  Function
	@author Vitor Duca
	@since 11/03/2025
	@version 1.0
	@param cTmpSIG, Character, Tabela temporaria contendo os registros do extrato SIG
	@param cTmpFK5, Character, Tabela temporaria contendo os registros do movimento FK5
/*/
Function F475GrvSIG(cTmpSIG as character, cTmpFK5 as Character)
	Local cQuery	as character
	Local cAlsTmp	as character
	Local cFilBkp	as character
	Local cIdProc	as character
	Local cItem		as character
	Local cNameDB	as Character
	Local oBulk		as Object
	Local nTamDocMV as numeric
	
	Default cTmpSIG := ""
	Default cTmpFK5 := ""

	cFilBkp	:= cFilAnt
	cIdProc := ""
	cItem := ""
	cNameDB := ALLTRIM(tcGetdb())
	oBulk := FINDTCRECORD():New(RetSqlName("SIG"), 900)
	nTamDocMV := TamSx3("IG_DOCMOV")[1]

	cQuery := "SELECT TMPSIG.IG_FILIAL, TMPSIG.IG_DTEXTR, TMPSIG.IG_DOCEXT, TMPSIG.IG_VLREXT, TMPSIG.IG_CARTER, "
	cQuery += "TMPSIG.IG_BCOEXT, TMPSIG.IG_AGEEXT, TMPSIG.IG_CONEXT, TMPSIG.IG_HISTEXT, TMPSIG.IG_MSUIDT, TMPFK5.FK5_FILORI, "
	cQuery += "TMPFK5.FK5_VALOR, TMPFK5.FK5_DTDISP, TMPFK5.FK5_NUMCH, TMPFK5.FK5_AGENCI, TMPFK5.FK5_CONTA, "
	cQuery += "TMPFK5.FK5_HISTOR, TMPFK5.FK5_NATURE "
	cQuery += "FROM " + cTmpSIG + " TMPSIG "
	cQuery += "INNER JOIN " + cTmpFK5 + " TMPFK5 "
	cQuery += "ON TMPFK5.REGMATCH = TMPSIG.REGMATCH "
	cQuery += "AND TMPFK5.DESMATCH = TMPSIG.DESMATCH "
	cQuery += "AND TMPFK5.SEQMATCH = TMPSIG.SEQMATCH "
	cQuery += "AND TMPFK5.IDMATCH = TMPSIG.IDMATCH "
	cQuery += "WHERE NOT EXISTS "
	cQuery += 				"(SELECT 1 "
	cQuery +=					"FROM " + RetSqlName("SIG") + " SIG "

	If cNameDB $ "POSTGRES"
        cQuery += 				"WHERE CAST(SIG.IG_MSUIDT AS VARCHAR) = TMPSIG.IG_MSUIDT "
    Else
		cQuery +=				"WHERE SIG.IG_MSUIDT = RTRIM(TMPSIG.IG_MSUIDT) "
	Endif

	cQuery +=					"AND SIG.D_E_L_E_T_ = ' ') "

	cAlsTmp := MpSysOpenQuery(cQuery)

	While (cAlsTmp)->(!Eof())

		cFilAnt := (cAlsTmp)->FK5_FILORI

		If Empty(cIdProc)
			cIdProc  := F474ProxNum("SIF")

			RecLock("SIF", .T.)
				SIF->IF_FILIAL 	:= FwXFilial("SIF")
				SIF->IF_IDPROC  := cIdProc
				SIF->IF_DTPROC  := dDataBase
				SIF->IF_BANCO	:= (cAlsTmp)->IG_BCOEXT
				SIF->IF_AGENCIA	:= (cAlsTmp)->IG_AGEEXT
				SIF->IF_CONTA	:= (cAlsTmp)->IG_CONEXT
				SIF->IF_DESC	:= STR0046
				SIF->IF_STATUS 	:= "3"
				SIF->IF_HORA	:= SubStr(Time(), 1, TamSx3("IF_HORA")[1])
			SIF->(MsUnlock())
		Endif

		If Empty(cItem)
			cItem    := Replicate("0",TamSx3("IG_ITEM")[1])
		Endif

		cItem := Soma1(cItem)

		oBulk:setValue("IG_FILIAL", 	(cAlsTmp)->IG_FILIAL)
		oBulk:setValue("IG_IDPROC", 	cIdProc)
		oBulk:setValue("IG_ITEM",		cItem)
		oBulk:setValue("IG_STATUS", 	"3")
		oBulk:setValue("IG_DTEXTR", 	Stod((cAlsTmp)->IG_DTEXTR))
		oBulk:setValue("IG_DOCEXT", 	(cAlsTmp)->IG_DOCEXT)
		oBulk:setValue("IG_VLREXT", 	(cAlsTmp)->FK5_VALOR)
		oBulk:setValue("IG_TIPEXT", 	"999")
		oBulk:setValue("IG_CARTER", 	(cAlsTmp)->IG_CARTER)
		oBulk:setValue("IG_BCOEXT", 	(cAlsTmp)->IG_BCOEXT)
		oBulk:setValue("IG_AGEEXT", 	(cAlsTmp)->IG_AGEEXT)
		oBulk:setValue("IG_CONEXT", 	(cAlsTmp)->IG_CONEXT)
		oBulk:setValue("IG_FILORIG",	(cAlsTmp)->FK5_FILORI)
		oBulk:setValue("IG_MSUIDT", 	Alltrim((cAlsTmp)->IG_MSUIDT))
		oBulk:setValue("IG_VLRMOV", 	(cAlsTmp)->FK5_VALOR)
		oBulk:setValue("IG_DTMOVI",		Stod((cAlsTmp)->FK5_DTDISP))
		oBulk:setValue("IG_DOCMOV",		SubStr((cAlsTmp)->FK5_NUMCH, 1, nTamDocMV))
		oBulk:setValue("IG_AGEMOV",		(cAlsTmp)->FK5_AGENCI)
		oBulk:setValue("IG_CONMOV",		(cAlsTmp)->FK5_CONTA)
		oBulk:setValue("IG_HISMOV",		(cAlsTmp)->FK5_HISTOR)
		oBulk:setValue("IG_NATMOV",		(cAlsTmp)->FK5_NATURE)
		oBulk:AddBulk()

		cFilAnt := cFilBkp

		(cAlsTmp)->(DbSkip())
	EndDo

	oBulk:Commit()
	oBulk:Destroy()
	
	(cAlsTmp)->(DbCloseArea())
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} SchedDef
	Execucao da rotina via Schedule.
	@return  aParam
/*/
//-------------------------------------------------------------------
Static Function SchedDef()
	Local aParam := {}

	aParam := 	{"P"			,;	//Tipo R para relatorio P para processo
				'PARAMDEF'		,;	//Nome do grupo de perguntas (SX1)
				Nil				,;	//cAlias (para Relatorio)
				Nil				,;	//aArray (para Relatorio)
				Nil				}	//Titulo (para Relatorio)
Return aParam
