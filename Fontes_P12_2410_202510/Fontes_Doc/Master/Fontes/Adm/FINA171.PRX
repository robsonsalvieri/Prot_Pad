#Include 'TOTVS.CH'
#INCLUDE "FINA171.CH"
#INCLUDE "FWMVCDEF.CH"

#DEFINE DECIMALDECALCULO 12

Static _oFINA171		:= NIL
Static __cBanco         := ""
Static __cAgBco       	:= ""
Static __cCntBco        := ""
Static __cNomeBco       := ""
Static lMovEnt05		:= NIL
Static lMovEnt06		:= NIL
Static lMovEnt07		:= NIL
Static lMovEnt08		:= NIL
Static lMovEnt09		:= NIL
Static __nMaxParc     	:= 0
Static __cMaxParc     	:= ""
Static __nTamParc     	:= 0
Static __nLastPar     	:= 0
Static __nTamPraz     	:= 0
Static __cTblname 		:= ""
Static __cAlsTmp		:= ""
Static __cIdCtb       	:= ""
Static __lMovBco 		as Logical
Static __nOpcMVC		:= 0
Static __lSwitch		As Logical

/*/{Protheus.doc} FINA171EMP
	Função auxiliar para execução do FINA171, permitindo o acesso ao formulario
	no contexto de emprestimos
	@type  Function
	@author Vitor Duca
	@since 21/05/2024
	@version version
	@param nPosArotina, Numeric, Permite a execução de uma opção de menu sem passar pelo menu
/*/
Function FINA171EMP(nPosArotina As Numeric)
	Local aParam	As Array

	aParam := {}

	Default nPosArotina := 3
	SetFunName("FINA171")

	aParam := FMontaPerg()

	FINA171(nPosArotina,,, aParam)
Return

/*/{Protheus.doc} FINA171APL
	Função auxiliar para execução do FINA171, permitindo o acesso ao formulario
	no contexto de aplicações
	@type  Function
	@author Vitor Duca
	@since 21/05/2024
	@version version
	@param nPosArotina, Numeric, Permite a execução de uma opção de menu sem passar pelo menu
/*/
Function FINA171APL(nPosArotina As Numeric)
	Local aParam	As Array

	aParam := {}

	Default nPosArotina := 3
	SetFunName("FINA171")

	aParam := FMontaPerg()

	FINA171(nPosArotina,,, aParam)
Return

/*/{Protheus.doc} FMontaPerg
	Cria uma matriz contendo os pergunte do FINA181, pois o front (APL EMP novo)
	altera esse pergunte e deve ser refletido para todas as operações efetuadas
	em aplicações ou emprestimos
	@type  Static Function
	@author Vitor Duca
	@since 28/05/2024
	@version 1.0
	@param param_name, param_type, param_descr
	@return aParam, Array, Matriz contendo os perguntes da rotina
/*/
Static Function FMontaPerg() As Array
	Local aParam	As Array

	aParam := {}
	//O Front altera o grupo de perguntas do FINA181, devido ao pergunte de tolerancia
	Pergunte("AFI181",.F.)

	Aadd(aParam, {"MV_PAR01", MV_PAR01})
	Aadd(aParam, {"MV_PAR02", MV_PAR02})

Return AClone(aParam)

/*/{Protheus.doc} FinA171
	Programa de atualização de Aplicacoes/Emprestimos
	@type  Function
	@author Eduardo Riera
	@since 28/03/1998
	@version 1.0
	@param nPosArotina, Numeric, Permite a execução de uma opção de menu sem passar pelo menu
	@param aRotAuto, Array, Array que será considerado para a execução automatica da rotina
	@param nOpcAuto, Numeric, Opção utilizada na execução automatica
	@param aParam, Array, Pergunte F12 que devem ser alterados
	@param cIdContab, Character, Passa o id da contabilização que sera gravado na CT2
/*/
Function FinA171(nPosArotina As Numeric, aRotAuto As Array, nOpcAuto As Numeric, aParam As Array, cIdContab As Character) As Logical
	Local nA 		As Numeric
	Local nC		As Numeric
	Local cMoedaTx	As Character
	Local cRelease	As Character
	Local oBrowse	As Object
	Local cTitulo	As Character
	Local cMVMoeda	As Character
	Local lPiloto   As Logical
	Private aTxMoedas	:=	{}
	Private lF171Auto   := ( aRotAuto <> NIL )
	Private aAutoCab    := {}
	Private aRotina 	:= MenuDef()
	PRIVATE cCadastro 	:= OemToAnsi(STR0006)  //"Atual.Aplicaçoes/Emprest."
	PRIVATE cLote
	LoteCont("FIN")

	DEFAULT aRotAuto 	:= {}
	DEFAULT nOpcAuto 	:= 3
	DEFAULT aParam   	:= {}
	DEFAULT cIdContab 	:= ""
	DEFAULT nPosArotina := 0

	nA 			:= 0
	nC			:= MoedFin()
	cMoedaTx	:= ""
	cRelease	:= GetRpoRelease()
	aAutoCab 	:= aClone(aRotAuto)
	lF171Auto   := Len(aAutoCab) > 0
	cTitulo		:= STR0096 //"INCLUIR"
	cMVMoeda	:= ""
	lPiloto     := GetPvProfString(GetEnvServer(), "PILOTMIFINA716", "0", GetSrvIniName()) == '1'
	FinIniVar()

	F171NewTmp()

	if (!lF171Auto)
		if Empty(nPosArotina) .and. ((cRelease >= "12.1.2510") .Or. cPaisLoc == "BRA" .Or. (lPiloto .And. cPaisLoc != "BRA"))
			FINA716()
			return
		endIf
	endIf

	Aadd(aTxMoedas,{"",1,PesqPict("SM2","M2_MOEDA1")})
	For nA	:=	2	To nC
		cMoedaTx	:= Str(nA,IIf(nA <= 9,1,2))
		cMVMoeda	:= FnGetMoeda(cMoedaTx)
		If !Empty(cMVMoeda)
			Aadd(aTxMoedas,{cMVMoeda, RecMoeda(dDataBase,nA), PesqPict("SM2","M2_MOEDA"+cMoedaTx) })
		Else
			Exit
		Endif
	Next

	Pergunte("AFI171",.F.)

	If Len(aParam) > 0
		F171PerAut(aParam)
	Endif

	__cIdCtb := cIdContab

	If lF171Auto
		F171OrdCab()
		__nOpcMVC := nOpcAuto
		FWMVCRotAuto(ModelDef(), "SEH", nOpcAuto, aAutoCab)
	Else
		If nPosArotina > 0
			if nPosArotina == 4
				cTitulo := STR0097 //"ALTERAR"
			Endif

			If nPosArotina == 5
				cTitulo := STR0098 //"EXCLUIR"
			Endif

			If nPosArotina == 1
				cTitulo := STR0099 //"VISUALIZAR"
			Endif

			__nOpcMVC := nPosArotina
			FwExecView(cTitulo, "FINA171", nPosArotina)
		Else
			oBrowse := BrowseDef()
			oBrowse:Activate()
		Endif
	Endif

Return(.T.)

/*/{Protheus.doc} BrowseDef
	Definição da browse

	@author Vitor Duca
	@since 06/05/2024
	@version 1.0
	@return oBrowse, Object, Objeto contendo a browse
/*/
Static Function BrowseDef() As Object
	Local oBrowse as object
	oBrowse := FWMBrowse():New()
	oBrowse:SetAlias("SEH")
	oBrowse:AddLegend( "EH_SALDO <= 0 " , "RED", STR0091 )  //"Aplicação Resgatada"
	oBrowse:AddLegend( "EH_SALDO > 0 " , "GREEN", STR0090 )  //"Aplicação com Saldo"
	oBrowse:SetDescription(cCadastro)
	oBrowse:SetMenuDef('FINA171')
Return oBrowse

/*/{Protheus.doc} Fa171Alt
	Gravações complementares na alteração
	@type  Function
	@author Vitor Duca
	@since 20/05/2024
	@version 1.0
	@param oModel, Object, Modelo de dados contendo as informações para commit
	@return lRet, Logical, Define se conseguiu realizar a operação definida
/*/
Function Fa171Alt(oModel As Object) As Logical
	Local aArea	As Array
	Local lRet	As Logical

	aArea	:= GetArea()
	lRet	:= .T.

	Begin Transaction
		If (lRet := FWFormCommit( oModel ))
			PcoDetLan("000008","01","FINA171")
		Endif
	End Transaction

	RestArea(aArea)
Return lRet

/*/{Protheus.doc} A171Exclui
	Gravações complementares na exclusão
	@type  Function
	@author Vitor Duca
	@since 20/05/2024
	@version 1.0
	@param oModel, Object, Modelo de dados contendo as informações para commit
	@return lRet, Logical, Define se conseguiu realizar a operação definida
/*/
Function A171Exclui(oModel As Object) As Logical
	LOCAL cPadrao    	As Character
	Local lDigita    	As Logical
	Local nHdlPrv    	As Numeric
	LOCAL lPadrao    	As Logical
	LOCAL nTotal     	As Numeric
	LOCAL cArquivo   	As Character
	LOCAL lContabil  	As Logical
	LOCAL cHistorico 	As Character
	Local aFlagCTB		As Array
	Local lUsaFlag		As Logical
	Local lAtuSldNat 	As Logical
	Local nBcoMoeda		As Numeric
	Local lFA171Bco		As Logical
	Local lMovBco		As Logical
	Local oModelMov 	As Object
	Local oSubFK5		As Object
	Local oSubFKA		As Object
	Local cLog 			As Character
	Local lRet 			As Logical
	Local cCamposE5		As Character
	Local nValor		As Numeric
	Local nE5Recno		As Numeric
	Local cTpDoc 		As Character
	Local lSEHBase		As Logical
	Local aArea			As Array
	Local aAreaSA6 		As Array

	cPadrao    	:= "581"
	lDigita    	:= If(ValType(MV_PAR01) == "N" .and. MV_PAR01 == 1,.T.,.F.)
	nHdlPrv    	:= 0
	lPadrao    	:= VerPadrao(cPadrao)
	nTotal     	:= 0
	cArquivo   	:= ""
	lContabil  	:= .F.
	cHistorico 	:= ""
	aFlagCTB	:= {}
	lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	lAtuSldNat 	:= .T.
	nBcoMoeda	:= 1
	lFA171Bco	:= ExistBlock("FA171BCO")
	lMovBco		:= .T.
	oModelMov 	:= Nil //Model de Movimento Bancário
	oSubFK5		:= NIL
	oSubFKA		:= NIL
	cLog 		:= ""
	lRet 		:= .T.
	cCamposE5 	:= ""
	nValor 		:= 0
	nE5Recno 	:= 0
	cTpDoc 		:= ""
	lSEHBase   	:= SEH->(ColumnPos("EH_BASEDES")) > 0
	aArea		:= {}
	aAreaSA6 	:= {}

	SA6->(DBSetOrder(1))
	SA6->(MsSeek(xFilial("SA6")+SEH->EH_BANCO+SEH->EH_AGENCIA+SEH->EH_CONTA))

	If ( SubStr(SEH->EH_LA,1,1) == "S" )
		lContabil := .T.
	EndIf
	If ( SEH->EH_APLEMP == "APL" )
		cHistorico := STR0014+" "+SEH->EH_TIPO //"Estorno de Aplicacao"
	Else
		cHistorico := STR0015+" "+SEH->EH_TIPO //"Estorno de Emprestimo"
	EndIf

	If lFA171Bco
		//Ponto de entrada que indica se deve movimentar ou nao banco
		lMovBco := ExecBlock("FA171Bco", .F., .F.,{MODEL_OPERATION_DELETE} )
		If Valtype(lMovBco) <> "L"
			lMovBco := .T.
		EndIf
	EndIf

	Begin Transaction
		If SEH->EH_GERPARC == "1"
			MsgRun( STR0100,, { || FCExcluiE2() }  ) //"Excluindo parcelas, por favor aguarde..."
		Endif

		If lMovBco

			//Pega o registro da SE5 correspondente ao movimento da aplicação ou empreéstimo posicionado
			cTpDoc := Iif( SEH->EH_APLEMP=="EMP", "EP", "AP" )
			nE5Recno := FN171SE5( cTpDoc )
			If nE5Recno > 0
				SE5->( dbGoto( nE5Recno ) )
			Else
				lRet := .F.
				Help( ,,"MF171EXC",,STR0094, 1, 0,,,,,,{STR0095} ) // "Não foi possível encontrar o movimento de inclusão do contrato." # "Favor verificar a mov. bancária (FK5)"
			Endif

			/*
			--- Formas de gravacao da movimentacao bancaria na exclusao de aplicacoes/emprestimos (a passar por revisao) ---
			FK5_MOEDA: Moeda definida no EH_MOEDA (na inclusao é gravada a moeda do cadastro do banco)
			FK5_VALOR: Grava o valor do EH_VLCRUZ, onde o mesmo possui 2 formas de gravacao (Gatilho - SX7) dependendo da operacao:
					- Aplicacao: Mesmo valor do EH_VALOR;
					- Emprestimo: Converte para a moeda forte (taxa do SM2);
					Obs: Na inclusao, em países diferente de Brasil há outro padrao de gravacao;
			FK5_VLMOE2: Faz a conversao do FK5_VALOR partindo da moeda forte para a moeda do EH_MOEDA (taxa do SM2);
					Obs: Na inclusao, em países diferente de Brasil há outro padrao de gravacao;
			FK5_TXMOED: Nao é gravado;
			*/

			If lRet
				//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
				cCamposE5	:= Fa171CpSE5(lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)

				oModelMov := FWLoadModel("FINM030") //Recarrega o Model de movimentos para pegar o campo do relacionamento
				oModelMov:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
				oModelMov:Activate()
				oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou não
				oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
				oModelMov:SetValue( "MASTER", "NOVOPROC", .F. ) //Informa que a inclusão não será feita com um novo número de processo

				//Dados do Processo
				oSubFKA := oModelMov:GetModel("FKADETAIL")
				oSubFKA:SetValue( "FKA_IDORIG", FWUUIDV4() )
				oSubFKA:SetValue( "FKA_TABORI", "FK5" )

				//Informacoes do movimento
				oSubFK5 := oModelMov:GetModel( "FK5DETAIL" )
				If cPaisLoc <> "BRA"
					aAreaSA6 := SA6->(GetArea())
					dbSelectArea('SA6')
					dbSetOrder(1)
					If SA6->(MsSeek(xFilial("SA6")+SEH->EH_BANCO+SEH->EH_AGENCIA+SEH->EH_CONTA))
						nBcoMoeda := Max(SA6->A6_MOEDA,1)
					EndIf
					RestArea(aAreaSA6)
					nValor := xMoeda( SEH->EH_VALOR,SEH->EH_MOEDA,nBcoMoeda,,,aTxMoedas[SEH->EH_MOEDA][2],aTxMoedas[nBcoMoeda][2] )
					oSubFK5:SetValue( "FK5_VLMOE2", SEH->EH_VALOR * aTxMoedas[SEH->EH_MOEDA][2] )
					oSubFK5:SetValue( "FK5_MOEDA", PADL(nBcoMoeda,TamSX3("CTO_MOEDA")[1],"0") )
				Else
					nValor := SEH->EH_VLCRUZ
					oSubFK5:SetValue( "FK5_VLMOE2", xMoeda( nValor,1,SEH->EH_MOEDA ) )
					oSubFK5:SetValue( "FK5_MOEDA", PADL(SEH->EH_MOEDA,TamSX3("CTO_MOEDA")[1],"0") )
				EndIf

				oSubFK5:SetValue( "FK5_DATA", dDataBase )
				oSubFK5:SetValue( "FK5_BANCO", SEH->EH_BANCO )
				oSubFK5:SetValue( "FK5_AGENCI", SEH->EH_AGENCIA )
				oSubFK5:SetValue( "FK5_CONTA", SEH->EH_CONTA )
				oSubFK5:SetValue( "FK5_VALOR", nValor )
				oSubFK5:SetValue( "FK5_RECPAG", If(SEH->EH_APLEMP=="EMP","P","R") )
				oSubFK5:SetValue( "FK5_TPDOC", cTpDoc )
				oSubFK5:SetValue( "FK5_HISTOR", cHistorico )
				oSubFK5:SetValue( "FK5_DTDISP", dDataBase )
				oSubFK5:SetValue( "FK5_FILORI", cFilAnt )
				oSubFK5:SetValue( "FK5_DOC", SEH->EH_NUMERO+SEH->EH_REVISAO )
				oSubFK5:SetValue( "FK5_ORIGEM", FunName() )
				oSubFK5:SetValue( "FK5_CCUSTO", SEH->EH_CCUSTO )
				oSubFK5:SetValue( "FK5_NATURE", SEH->EH_NATUREZ )

				If !lUsaFlag
					oSubFK5:SetValue( "FK5_LA", "S" )
				Endif

				//Gravação da tabela FK8 - Dados Contábeis
				Fa171GrFK8(oModelMov,lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)

				If oModelMov:VldData()
					oModelMov:CommitData()
					oModelMov:DeActivate()
				Else
					lRet := .F.
					cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[6])

					Help( ,,"MF171EXC",,cLog, 1, 0 )
				Endif

				If lRet
					AtuSalBco( SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA, SE5->E5_DATA, SE5->E5_VALOR,;
						IIf(SE5->E5_RECPAG == "R", "+", "-") )
					/*
					* Atualiza os saldos do fluxo de caixa por natureza financeira - AtuSldNat()
					*/
					If lAtuSldNat
						AtuSldNat(SE5->E5_NATUREZ, SE5->E5_DATA, SE5->E5_MOEDA, "3", If(SEH->EH_APLEMP=="EMP","R","P"), SEH->EH_VLCRUZ, 0, "-",,FunName(),"SE5", SE5->(Recno()),0)
					EndIf
				Endif
			Endif

			If  lRet .and. !Empty(SEH->EH_DESPESA) .And. ( !lSEHBase .OR. (lSEHBase .And. SEH->EH_BASEDES <> "1" ) )
				If !lF171Auto
					MsgRun( STR0045,, { || lRet := FCGrvE5(.T.) }  ) //"Aguarde, gravando as despesas do contrato..."
				Else
					lRet := FCGrvE5(.T.)
				Endif
			EndIf
		EndIf

		If lRet
			aArea	:= GetArea()
			DbSelectArea("SED")
			DbSetOrder(1)
			SED->(DbSeek(xFilial("SED") + SEH->EH_NATUREZ))
			RestArea(aArea)
			FwFreeArray(aArea)

			If ( lPadrao .And. lContabil )
				nHdlPrv := HeadProva( cLote, "FINA171" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )

				If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
					aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
					aAdd( aFlagCTB, {"FK5_LA", "S", "FK5", FK5->( Recno() ), 0, 0, 0} )
				EndIf
				nTotal += DetProva( nHdlPrv, cPadrao, "FINA171" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/,;
									/*cCriterio*/, /*lRateio*/, /*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/,;
					@aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )

				RodaProva( nHdlPrv, nTotal )

				cA100Incl( 	cArquivo,;
					nHdlPrv,;
					3 /*nOpcx*/,;
					cLote,;
					lDigita,;
					.F. /*lAglut*/,;
						/*cOnLine*/,;
						/*dData*/,;
						/*dReproc*/,;
					@aFlagCTB,;
						/*aDadosProva*/,;
						/*aSeqDiario*/,;
						/*aTpSaldo*/,;
						/*lSimula*/,;
						/*cTabCTK*/,;
						/*cTabCT2*/,;
					__cIdCtb )

				aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
			EndIf

			If ExistBlock("F171EXCL")
				Execblock("F171EXCL",.F.,.F.)
			Endif

			dbSelectArea("SEH")
			PcoDetLan('000008',"01","FINA171",.T.)
			lRet := FWFormCommit(oModel)
		Endif
	End Transaction
Return lRet

/*/{Protheus.doc} Fa171Grv
	Função auxiliar para gravação do movimento bancario e contabilização
	@type  Function
	@author Vitor Duca
	@since 21/05/2024
	@version 1.0
	@param oModel, Object, Modelo de dados contendo as informações para commit
	@return lRet, Logical, Define se conseguiu realizar a operação definida
/*/
Function Fa171Grv(oModel As Object) As Logical
	Local nOpc	As Numeric
	Local lRet	As Logical

	nOpc :=  oModel:GetOperation()
	lRet := .T.

	Do Case
		Case nOpc == MODEL_OPERATION_INSERT
			lRet := F171Inclui(oModel)
		Case nOpc == MODEL_OPERATION_UPDATE
			lRet := Fa171Alt(oModel)
		Case nOpc == MODEL_OPERATION_DELETE
			lRet := A171Exclui(oModel)
	End Case
Return lRet

/*/{Protheus.doc} F171Inclui
	Gravações complementares na inclusão de um contrato
	@type  Static Function
	@author Vitor Duca
	@since 23/05/2024
	@version 1.0
	@param oModel, Object, Modelo de dados do MVC onde será feito o commit
/*/
Static Function F171Inclui(oModel As Object) As Logical
	Local cPadrao    	As Character
	Local lDigita    	As Logical
	Local nHdlPrv    	As Numeric
	Local lPadrao    	As Logical
	Local nTotal     	As Numeric
	Local cArquivo   	As Character
	Local cHistorico 	As Character
	Local lFin171    	As Logical
	Local nBcoMoeda  	As Numeric
	Local aFlagCTB   	As Array
	Local lUsaFlag   	As Logical
	Local lAtuSldNat 	As Logical
	Local lFA171Bco  	As Logical
	Local lMovBco    	As Logical
	Local oModelMov  	As Object
	Local oSubFK5		As Object
	Local oSubFKA		As Object
	Local cLog 			As Character
	Local lRet 			As Logical
	Local cCamposE5		As Character
	Local nValor		As Numeric
	Local lSEHBase 		As Logical

	F171ModVlr(oModel)

	Begin Transaction
		If (lRet := FWFormCommit( oModel ))
			cPadrao    	:= "580"
			lDigita    	:= If(ValType(MV_PAR01) == "N" .and. MV_PAR01 == 1,.T.,.F.)
			nHdlPrv    	:= 0
			lPadrao    	:= VerPadrao(cPadrao)
			nTotal     	:= 0
			cArquivo   	:= ""
			cHistorico 	:= ""
			lFin171    	:= ExistBlock("FIN171")
			nBcoMoeda  	:= 1
			aFlagCTB   	:= {}
			lUsaFlag   	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
			lAtuSldNat 	:= .T.
			lFA171Bco  	:= ExistBlock("FA171BCO")
			lMovBco    	:= .T.
			oModelMov  	:= FWLoadModel("FINM030") //Model de Movimento Bancário
			cLog 		:= ""
			lRet 		:= .T.
			cCamposE5 	:= ""
			nValor 		:= 0
			lSEHBase	:= SEH->(ColumnPos("EH_BASEDES")) > 0

			If ( SEH->EH_APLEMP=="APL" )
				cHistorico := STR0016+" "+SEH->EH_TIPO //"Aplicacao Financeira"
			Else
				cHistorico := STR0017+" "+SEH->EH_TIPO //"Emprestimo Financeiro"
			EndIf
			dbSelectArea('SA6')
			dbSetOrder(1)
			If dbSeek(xFilial()+SEH->EH_BANCO+SEH->EH_AGENCIA+SEH->EH_CONTA)
				nBcoMoeda := Max(SA6->A6_MOEDA,1)
			EndIf

			dbSelectArea("SEH")
			RecLock("SEH",.F.)
			If !lUsaFlag .and. (ValType(MV_PAR02) == "N" .and. MV_PAR02 == 1 )
				SEH->EH_LA := "S"
			ElseIf ( lPadrao .and. ValType(MV_PAR02) == "N" .and. MV_PAR02 == 1 )
				aAdd( aFlagCTB, {"EH_LA", "S", "SEH", SEH->( Recno() ), 0, 0, 0} )
			Endif

			SEH->EH_STATUS := If( SEH->EH_SALDO < 0.01, "B", "A" )

			If SEH->(FieldPos("EH_FILORIG")) > 0
				SEH->EH_FILORIG := cFilAnt
			Endif

			If lFA171Bco
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Ponto de entrada que indica se deve movimentar ou nao banco³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				lMovBco := ExecBlock("FA171Bco", .F., .F., )
				If Valtype(lMovBco) <> "L"
					lMovBco := .T.
				EndIf
			EndIf

			/*
			--- Formas de gravacao da movimentacao bancaria na exclusao de aplicacoes/emprestimos (a passar por revisao) ---
			FK5_MOEDA: Moeda do cadastro do banco (A6_MOEDA)
			FK5_VALOR:
				- Localização Brasil: Grava o valor do EH_VLCRUZ, onde o mesmo possui 2 formas de gravacao (Gatilho - SX7) dependendo da operacao:
					- Aplicacao: Mesmo valor do EH_VALOR;
					- Emprestimo: Converte para a moeda forte (taxa do SM2);
				- Outras localizações: Faz a conversão partindo da moeda do EH_MOEDA para a moeda do banco (taxa do SM2);
			FK5_VLMOE2:
				- Localização Brasil: Faz a conversao do FK5_VALOR partindo da moeda forte para a moeda do EH_MOEDA (taxa do SM2);
				- Outras localizações: Faz a conversão do EH_VALOR para a moeda do EH_MOEDA (taxa do SM2);
			FK5_TXMOED: Nao é gravado;
			*/

			If lMovBco
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Gera movimentacao bancaria - Aplicacao                            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

				//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
				cCamposE5	:= Fa171CpSE5(lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)

				oModelMov:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
				oModelMov:Activate()
				oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou não
				oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
				oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Informa que a inclusão será feita com um novo número de processo

				//Dados do Processo
				oSubFKA := oModelMov:GetModel("FKADETAIL")
				oSubFKA:SetValue( "FKA_IDORIG", FWUUIDV4() )
				oSubFKA:SetValue( "FKA_TABORI", "FK5" )

				//Informacoes do movimento
				oSubFK5 := oModelMov:GetModel( "FK5DETAIL" )
				nValor := If( cPaisLoc=="BRA", SEH->EH_VLCRUZ, xMoeda( SEH->EH_VALOR,SEH->EH_MOEDA,nBcoMoeda,,,aTxMoedas[SEH->EH_MOEDA][2],aTxMoedas[nBcoMoeda][2] ) )
				oSubFK5:SetValue( "FK5_DATA", SEH->EH_DATA )
				oSubFK5:SetValue( "FK5_BANCO", SEH->EH_BANCO )
				oSubFK5:SetValue( "FK5_AGENCI", SEH->EH_AGENCIA )
				oSubFK5:SetValue( "FK5_CONTA", SEH->EH_CONTA )
				oSubFK5:SetValue( "FK5_VALOR", nValor )
				oSubFK5:SetValue( "FK5_VLMOE2", If( cPaisLoc=="BRA", xMoeda( nValor,1,SEH->EH_MOEDA ), SEH->EH_VALOR * aTxMoedas[SEH->EH_MOEDA][2] ) )
				oSubFK5:SetValue( "FK5_RECPAG", Iif(SEH->EH_APLEMP=="EMP","R","P") )
				oSubFK5:SetValue( "FK5_TPDOC", Iif(SEH->EH_APLEMP=="EMP","EP","AP") )
				oSubFK5:SetValue( "FK5_HISTOR", cHistorico )
				oSubFK5:SetValue( "FK5_DTDISP", SEH->EH_DATA )
				oSubFK5:SetValue( "FK5_MOEDA", PADL(nBcoMoeda,TamSX3("CTO_MOEDA")[1],"0") )
				oSubFK5:SetValue( "FK5_FILORI", cFilAnt )
				oSubFK5:SetValue( "FK5_DOC", SEH->EH_NUMERO+SEH->EH_REVISAO )
				oSubFK5:SetValue( "FK5_NATURE", SEH->EH_NATUREZ )
				oSubFK5:SetValue( "FK5_ORIGEM", FunName() )
				oSubFK5:SetValue( "FK5_CCUSTO", SEH->EH_CCUSTO)
				If ! lUsaFlag .and. ( ValType(MV_PAR02) == "N" .and. MV_PAR02 == 1 )
					oSubFK5:SetValue( "FK5_LA", "S" )
				Endif

				//Gravação da tabela FK8 - Dados Contábeis
				Fa171GrFK8(oModelMov,lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)

				If oModelMov:VldData()
					oModelMov:CommitData()
					oModelMov:DeActivate()
				Else
					__lMovBco := lRet := .F.
					cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[6])

					DisarmTransaction()
					Break
				EndIf

				AtuSalBco( SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA, SE5->E5_DATA, SE5->E5_VALOR,;
					Iif( SE5->E5_RECPAG=="R", "+", "-") )

				If lAtuSldNat
					/*
					* Atualiza os saldos do fluxo de caixa por natureza financeira - AtuSldNat()
					*/
					AtuSldNat(SE5->E5_NATUREZ, SE5->E5_DATA, SE5->E5_MOEDA, "3", If(SEH->EH_APLEMP=="EMP","R","P"), SEH->EH_VLCRUZ, 0, "+",,FunName(),"SE5", SE5->(Recno()),0)
				EndIf
			EndIf

			Fa171AtuNat(SE5->E5_NATUREZ,SEH->EH_APLEMP,"FINA171")

			If UsaSeqCor()
				aDiario := {{"SEH",SEH->(Recno()), SEH->EH_DIACTB, "EH_NODIA","EH_DIACTB"}}
			Else
				aDiario := {}
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Lancamento Contabil                                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( lPadrao .and. ValType(MV_PAR02) == "N" .and. MV_PAR02 == 1 )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Inicializa Lancamento Contabil                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nHdlPrv := HeadProva( cLote,;
					"FINA171" /*cPrograma*/,;
					Substr( cUsuario, 7, 6 ),;
					@cArquivo )

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Prepara Lancamento Contabil                                      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
					aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
					aAdd( aFlagCTB, {"FK5_LA", "S", "FK5", FK5->( Recno() ), 0, 0, 0} )
				Endif
				nTotal += DetProva( nHdlPrv,;
					cPadrao,;
					"FINA171" /*cPrograma*/,;
					cLote,;
										/*nLinha*/,;
										/*lExecuta*/,;
										/*cCriterio*/,;
										/*lRateio*/,;
										/*cChaveBusca*/,;
										/*aCT5*/,;
										/*lPosiciona*/,;
					@aFlagCTB,;
										/*aTabRecOri*/,;
										/*aDadosProva*/ )

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Efetiva Lan‡amento Contabil                                      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				RodaProva( nHdlPrv,;
					nTotal)

				cA100Incl( 	cArquivo,;
					nHdlPrv,;
					3 /*nOpcx*/,;
					cLote,;
					lDigita,;
					.F. /*lAglut*/,;
								/*cOnLine*/,;
								/*dData*/,;
								/*dReproc*/,;
					@aFlagCTB,;
								/*aDadosProva*/,;
					aDiario,;
								/*aTpSaldo*/,;
								/*lSimula*/,;
								/*cTabCTK*/,;
								/*cTabCT2*/,;
					__cIdCtb )

				aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gera os lancamentos do SIGAPCO                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			PcoDetLan("000008","01","FINA171")
			DbSelectArea( "SEH" )

			If lFin171
				Execblock("FIN171",.F.,.F.)
			EndIf

			If SEH->EH_TIPO $ "EMP|TEM" .and. SEH->EH_GERPARC == "1"
				Processa({||lRet := FCGrvE2(oModel)}, STR0044) //"Aguarde, gravando as parcelas no contas a pagar..."
				If lRet .and. !Empty(SEH->EH_DESPESA) .And. ( !lSEHBase .OR. (lSEHBase .And. SEH->EH_BASEDES <> "1" ) )
					MsgRun( STR0045,, { || lRet := FCGrvE5(.F.) }  ) //"Aguarde, gravando as despesas do contrato..."
				EndIf

				PUTMV("MV_FOREMPR", oModel:GetModel("SEHMASTER"):getValue("AUTCODFOR") )
			Endif
		Endif
	End Transaction

	PcoFinLan("000008")
	PcoFreeBlq("000008")
Return lRet

/*/{Protheus.doc} Fa171Perg
	Ativa funcao pergunte
	@type  Static Function
	@author Eduardo Riera
	@since 28/03/1998
	@version 1.0
/*/
Static Function Fa171Perg()

	pergunte("AFI171",.T.)

Return(.T.)

/*/{Protheus.doc} Fa171TudOk
	Validacao da Inclusao da Aplicacao ou Emprestimo
	@type  Function
	@author Eduardo Riera
	@since 28/03/1998
	@version 1.0
	@param nOpc, Numeric, Operação que esta sendo executada no modelo
	@return lRetorna, Logical, Retorna se a inclusão/Alteração pode ser concluida
/*/
Function Fa171TudOk(oModel As Object) As Logical
	LOCAL aArea    		As Array
	LOCAL lRetorna 		As Logical
	Local lF171OK  		As Logical
	Local lContrOK 		As Logical
	Local lBcoBloq 		As Logical
	Local lTemResgat	As Logical
	Local nOpc			As Numeric
	Local oSubSE2		As Object
	Local oSubSEH		As Object
	Local oSubTotal		As Object
	Local oSubCalc		As Object

	aArea    	:= GetArea()
	lRetorna 	:= .F.
	lF171OK  	:= ExistBlock("F171OK")
	lContrOK 	:= .T.
	lBcoBloq	:= .F.
	nOpc		:= oModel:GetOperation()
	oSubSE2		:= oModel:GetModel("SE2DETAIL")
	oSubSEH		:= oModel:GetModel("SEHMASTER")
	oSubTotal 	:= oModel:GetModel("SE2TOTAL")
	oSubCalc	:= oModel:GetModel("CALCPARC")
	lTemResgat	:= .T.

	If nOpc <> MODEL_OPERATION_DELETE
		If UsaSeqCor()
			Private cCodDiario := SEH->EH_DIACTB
		Endif

		If ( M->EH_APLEMP=="APL" )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Validacao das Aplicacoes baseadas em contratos               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If M->EH_TIPO $(GetMv("MV_APLCAL4"))
				If !Empty(M->EH_QUOTAS) .And. !Empty(M->EH_CONTRAT)
					lRetorna := .T.
				Endif
				If lRetorna .And. nOpc == 3
					lContrOK := V181Contrat(M->EH_CONTRAT)
					lRetorna := lContrOK
				EndIf
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Validacao das Aplicacoes baseadas em Taxa Pr‚-Fixada ou      ³
				//³ correcao monetaria.                                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( !Empty(M->EH_VALOR) )
					lRetorna := .T.
				EndIf
			EndIf
		Else
			If ( M->EH_TAXA >= 0 .And. M->EH_VALOR != 0 .And.;
					M->EH_SALDO != 0 .And. M->EH_VLCRUZ != 0 )
				lRetorna := .T.
			EndIf
		EndIf

		If CCBLOCKED(M->EH_BANCO,M->EH_AGENCIA,M->EH_CONTA) //Verifica bloqueio de conta corrente
			lRetorna := .F.
			lBcoBloq := .T.
		EndIf

		If ( lRetorna )
			lRetorna := ExistCpo("SA6",M->EH_BANCO+M->EH_AGENCIA+M->EH_CONTA)
		EndIf
		If ( lRetorna .And. M->EH_VLCRUZ==0 )
			lRetorna := .F.
		EndIf

		//Valida a moeda enviada
		If ( lRetorna .And. !Fa171AtuVl(.T.) )
			lRetorna := .F.
		EndIf

		If ( !lRetorna .And. !lBcoBloq )
			If lContrOK
				Help(" ",1,"FA171TUDOK")
			EndIf
		EndIf

		If lRetorna
			lRetorna	:=	PcoVldLan('000008','01','FINA171')
		Endif

		If lRetorna .AND. UsaSeqCor()
			If !CTBvldDiario( M->EH_DIACTB, dDataBase )
				lRetorna := .F.
			EndIf
		Endif

		If lRetorna .And. M->EH_APLEMP == "EMP"
			If (M->EH_GERPARC == "1" .And. Empty(M->EH_AMORTIZ))
				lRetorna := .F.
				Aviso(STR0017,STR0052) // Emprestimo Financeiro //Para o modelo Empréstimo optante por geração de parcelas, deve-se utilizar uma tabela de Amortização!"
			EndIf
		EndIf

		If lRetorna .And. M->EH_APLEMP == "EMP"
			If (!Empty(M->EH_AMORTIZ) .And. M->EH_GERPARC == "1" .And. M->EH_PRAZO == 0 .And. M->EH_VLAMORP == 0)
				lRetorna := .F.
				MsgInfo(STR0053, STR0017)// Emprestimo Financeiro //"Para o modelo Empréstimo optante por geração de parcelas vinculadas a uma tabela de Amortização, o Prazo ou Valor Amortização/Parcela deve ser maior que zero !"
			EndIf
		EndIf

		If lRetorna .And. M->EH_APLEMP == "EMP"
			If !Empty(M->EH_AMORTIZ) .And. M->EH_GERPARC == "1" .And. M->EH_PRAZO == 0 .And. M->EH_VLAMORP >= 0
				nParcelas := INT(M->EH_VALOR / M->EH_VLAMORP)	//número aproximado de parcelas a serem gerados
				If nParcelas > __nMaxParc
					lRetorna := .F.
					//###"O número de parcelas a serem geradas para o empréstimo não é suportado."###""Número máximo de parcelas permitido: ""###"Emprestimo Financeiro"
					HELP(' ',1,STR0017,,STR0081 + CRLF + STR0082 + __cMaxParc,2,0,,,,,,{STR0021})
				Endif
			EndIf
		EndIf

		If lRetorna .And. M->EH_APLEMP == "EMP" .and. oSubSE2 <> NIL 
			If !Empty(M->EH_AMORTIZ) .And. M->EH_GERPARC == "1" .And. (M->EH_PRAZO <> 0 .Or. M->EH_VLAMORP >= 0 )
				If Len(oSubSE2:GetLinesChanged()) == 0
					lRetorna := .F.
					//###"O empréstimo esta configurado para gerar parcelas, porém não existem parcelas calculadas"###""Acesse a aba Projeção das parcelas e realize o calculo para a correta geração do empréstimo.""###"Emprestimo Financeiro"
					HELP('',1,STR0017,, STR0127, 2, 0,,,,,, {STR0128})
				Endif
			EndIf
		EndIf

		If lRetorna .And. oSubSEH:getValue('EH_APLEMP') == "EMP" .And. oSubSEH:getValue('EH_GERPARC') == "1" .And. oSubCalc <> Nil .And. oSubCalc:getValue('AUTCUSTOMVLR') == '1'
			nVlContrat := oSubSEH:getValue('EH_SALDO')

			If oSubSEH:getValue('EH_BASEDES') == "1"
				nVlContrat := oSubSEH:getValue('EH_SALDO')+oSubSEH:getValue('EH_VALIOF')+oSubSEH:getValue('EH_TARIFA')+oSubSEH:getValue('EH_DESPESA')+oSubSEH:getValue('EH_SPREAD')
			EndIf

			If nVlContrat != oSubTotal:getValue('AMORTIZTOT')
				HELP('',1,STR0017,, STR0126, 1, 0,,,,,, {STR0129}) // O total de amortização das parcelas não corresponde ao valor do contrato." // Emprestimo Financeiro // Verifique o valor de amortização das parcelas
				lRetorna := .F.
			EndIf
		EndIf

		RestArea(aArea)

		If lF171OK .And. lRetorna
			lRetorna := Execblock("F171OK",.F.,.F.)
		Endif

		If ( M->EH_APLEMP=="APL" )
			If !CtbValiDt(,M->EH_DATA,,,,{"FIN001"},)
				lRetorna := .F.
			Endif
		Else
			If !CtbValiDt(,M->EH_DATA,,,,{"FIN002"},)
				lRetorna := .F.
			EndIf
		EndIf

		If (nOpc == 3 .or. nOpc == 4) .And. lRetorna .And. !Empty(M->EH_CCUSTO)
			// Inclusão da validação por não estar no dicionário
			If !CTB105CC(M->EH_CCUSTO)
				lRetorna	:= .F.
			EndIf
		EndIf

		// Não permite alterar as parcelas já gravadas no contas a pagar
		If nOpc == 4
			dbSelectArea("SE2")
			If SE2->(dbseek(xFilial("SE2")+M->EH_TIPO+M->EH_NUMERO))
				iF !lF171Auto
					MsgInfo(STR0019,STR0017) //"Não será alterada as parcelas já gravadas no contas a pagar!" // "Emprestimo Financeiro"
				Endif
			EndIf
		EndIf
	Else
		If ( lRetorna := !CCBLOCKED(SEH->EH_BANCO,SEH->EH_AGENCIA,SEH->EH_CONTA) )//Verifica bloqueio de conta corrente
			lTemResgat := TemResgate()

			If !lTemResgat .And. Empty(SEH->EH_ULTAPR)
				lRetorna := DtMovFin(,,IIF(SEH->EH_APLEMP=="APL","1","2"))
			Else
				Help(" ",,"A171DELETA")
				lRetorna := .F.
			Endif
		Endif
	Endif
Return(lRetorna)

/*/{Protheus.doc} fa171Opera
	Verifica a Operacao efetuada
	@type  Function
	@author Eduardo Riera
	@since 28/03/1998
	@version 1.0
/*/
Function Fa171OPera() As Logical
	Local aArea		As Array
	Local lRetorna 	As Logical
	Local cFiltro	As Character
	Local lConPad	As Logical
	Local aRecF7C	As Array
	Local jTemplate	As Json

	aArea    	:= GetArea()
	lRetorna 	:= .T.
	cFiltro  	:= "F7B->F7B_APLEMP == '" + M->EH_APLEMP + "' .And. F7B->F7B_FILIAL == '" + xFilial("F7B") + "'"
	lConPad		:= .T.
	aRecF7C		:= {}
	jTemplate	:= JsonObject():new()

	dbSelectArea("SX5")
	dbSetOrder(1)
	dbSeek(xFilial()+"11"+M->EH_TIPO)
	IF ( !Found() )
		Help(" ",1,"NOTIPOAPL")
		lRetorna := .F.
	EndIf

	If M->EH_TIPO == "TEM"
		If !lF171Auto
			FwMsgRun(,{|| lConPad := ConPad1(,,,"F7B",,,.F.,,,,,, cFiltro)}, STR0115, STR0116) //"Aguarde.." "Carregando templates de fórmulas"

			If lConPad
				FwMsgRun(,{|| jTemplate := FINA171TEM(F7B->(Recno()))}, STR0115, STR0117)// "Aguarde.." "Abrindo fórmulas do template"
				If jTemplate <> NIL
					M->EH_TEMPLT := jTemplate:ToJson()
				Endif
			Endif
		EndIf
	Else
		If !Empty(M->EH_TEMPLT)
			M->EH_TEMPLT := ""
		Endif
		lRetorna := F171VldTip(M->EH_APLEMP, M->EH_TIPO)
	Endif

	RestArea(aArea)
Return( lRetorna )

/*/{Protheus.doc} Fa171Nat
	Inicializador Padrao da Natureza Finaceira
	@type  Function
	@author Eduardo Riera
	@since 30/03/1998
	@version 1.0
/*/
Function Fa171Nat() As Logical
	M->EH_NATUREZ := F171IniNat()
Return .T.

/*/{Protheus.doc} F171IniNat
	Inicializador padrão para o campo EH_NATUREZ
	(Não é possivel usar a Fa171Nat pois ela esta sendo usada no valid do EH_APLEMP)
	@type  Function
	@author Vitor Duca
	@since 06/06/2024
	@version 1.0
	@param param_name, param_type, param_descr
	@return cNatureza, Character, Codigo da natureza
/*/
Function F171IniNat() As Character
	Local cNatureza	As Character

	cNatureza := PadR(&(GetMv("MV_NATAPLI")),TamSX3("EH_NATUREZ")[1])

	If M->EH_APLEMP == "EMP"
		cNatureza := PadR(&(GetMv("MV_NATEMP")),TamSX3("EH_NATUREZ")[1])
	Endif

	Fa171AtuNat(cNatureza, M->EH_APLEMP, "FINA171")

Return cNatureza

/*/{Protheus.doc} Fa171AtuNat
	Verifica se a Natureza foi cadastrada, se nao, cria.
	@type  Function
	@author Eduardo Riera
	@since 31/03/1998
	@version 1.0
/*/
Function Fa171AtuNat(cNat As Character, cTipo As Character, cFonte As Character)
	Local cAlias	As Character
	cAlias := Alias()
	dbSelectArea("SED")
	dbSetOrder(1)
	If !dbSeek(xFilial("SED")+cNat) .And. !Empty(cNat)
		RecLock("SED",.T.)
		Replace ED_FILIAL    With xFilial("SED")
		Replace ED_CODIGO    With cNat
		If cTipo == "EMP"
			If cFonte=="FINA171"
				Replace ED_DESCRIC   With STR0010  //"NATUREZA EMPRESTIMOS"
			Else
				Replace ED_DESCRIC   With STR0012  //"NATUREZA PGT.EMPRESTIMOS"
			Endif
		Else
			If cFonte=="FINA171"
				Replace ED_DESCRIC   With STR0011  //"NATUREZA APLICACOES"
			Else
				Replace ED_DESCRIC   With STR0013  //"NATUREZA RESG.APLICACOES"
			Endif
		EndIF
		Replace ED_CALCIRF   With "N"
		Replace ED_CALCISS   With "N"
		Replace ED_PERCIRF   With 0
		Replace ED_TIPO		 With "2"
		MsUnlock()
	EndIf
	dbSelectArea(cAlias)
Return

/*/{Protheus.doc} Fa171Cdi
	Validação de campos quando EH_CLSIOF == 1
	@type  Function
	@author André Luiz B. Silva
	@since 24/05/2024
	@version 1.0
/*/
Function Fa171Cdi() As Logical
	Local lRetorna	As Logical
	Local lClsIof  	As Logical

	lRetorna := .T.
	lClsIof  := .T.

	If lClsIof
		If (INCLUI .AND. ALLTRIM(M->EH_TIPO) == 'CDI' .And. ALLTRIM(M->EH_CLSIOF) == '1' )
			lRetorna := .F.
		EndIf
	Endif

Return( lRetorna )

/*/{Protheus.doc} fa171Apl
	Valicacao dos campos pertencentes a aplicacao
	@type  Function
	@author Eduardo Riera
	@since 12/04/1998
	@version 1.0
/*/
Function Fa171Apl() As Logical
	LOCAL lRetorna 	As Logical

	lRetorna := .F.

	If ( INCLUI .And. M->EH_APLEMP=="APL" )
		lRetorna := .T.
	EndIf

Return( lRetorna )

/*/{Protheus.doc} Fa171Emp
	Valicacao dos campos pertencentes ao emprestimo
	@type  Function
	@author Eduardo Riera
	@since 12/04/1998
	@version 1.0
/*/
Function Fa171Emp() As Logical
	LOCAL lRetorna	As Logical

	lRetorna := .F.
	If ( INCLUI .And. M->EH_APLEMP=="EMP" )
		lRetorna := .T.
	EndIf

Return( lRetorna )

/*/{Protheus.doc} Fa171AtuVl
	Faz a conversao do valor para Multi-Moedas,baseado no array
	aTxMoeda, que contem o valor da moeda na contacao atual, ou digitada
	pelo usuario
	@type  Function
	@author Alexandre Silva
	@since 10/01/2002
	@version 1.0
/*/
Function Fa171AtuVl(lValid As Logical)
	Local uRetorno  := 0

	DEFAULT lValid := .F. // Sera utilizada para validar ou para obter o valor da operacao ?

	If M->EH_MOEDA >= 1 .And. M->EH_MOEDA <= MoedFin()
		If lValid
			uRetorno := .T.
		Else
			uRetorno := M->EH_VALOR * aTxMoedas[M->EH_MOEDA][2]
		Endif
	Else
		Help( " ",1,"SEMMOEDA" )
		If lValid
			uRetorno := .F.
		Else
			uRetorno := M->EH_VALOR
		Endif
	EndIf

Return uRetorno

/*/{Protheus.doc} MenuDef
	Utilizacao de menu Funcional
	@type  Static Function
	@author Ana Paula N. Silva
	@since 23/11/2006
	@version 1.0
	@return aRotina, Array, Array com opcoes da rotina.
/*/
Static Function MenuDef() As Array
	Local aRotina As Array

	aRotina := {}

	ADD OPTION aRotina TITLE STR0002 ACTION "FINA171M(1)" OPERATION MODEL_OPERATION_VIEW    ACCESS 0 //Visualizar
	ADD OPTION aRotina TITLE STR0003 ACTION "FINA171M(3)" OPERATION MODEL_OPERATION_INSERT  ACCESS 0 //Incluir
	ADD OPTION aRotina TITLE STR0004 ACTION "FINA171M(4)" OPERATION MODEL_OPERATION_UPDATE  ACCESS 0 //Alterar
	ADD OPTION aRotina TITLE STR0005 ACTION "FINA171M(5)" OPERATION MODEL_OPERATION_DELETE  ACCESS 0 //Excluir
	ADD OPTION aRotina TITLE STR0066 ACTION "Fa171Idx"    OPERATION MODEL_OPERATION_VIEW    ACCESS 0 //Taxas dos Ýndices

Return aRotina

/*/{Protheus.doc} FINA171M
	Chamdada do menu de opcoes da rotina
	@since 30/05/2025
	@version 1.0
/*/
Function FINA171M(nOpc as Numeric)
	FINA171(nOpc)
Return

/*/{Protheus.doc} FN171SE5
	Função para encontrar o registro de SE5 correspondente ao movimento
	da aplicação ou empréstimo posicionado (SEH)

	@param cTpDoc, Tipo Doc que será considerado na busca ("AP" ou "EP")
	@return nRecno, identificação do registro na SE5
	@author Pedro Alencar
	@since 08/05/2014
	@version P12
/*/
Static Function FN171SE5(cTpDoc As Character) As Numeric
	Local nRecno	As Numeric
	Local cQuery	As Character
	Local cDocumen	As Character
	Local cAliasTMP	As Character

	Default cTpDoc := "AP"

	nRecno := 0
	cQuery := ""
	cDocumen := ""
	cAliasTMP := ""

	//Concatena o número e a revisão da aplicação (SEH) para buscar na SE5 (E5_DOCUMEN)
	cDocumen := SEH->EH_NUMERO + SEH->EH_REVISAO

	cQuery := "SELECT R_E_C_N_O_ "
	cQuery += "FROM " + RetSqlName("SE5") + " SE5 "
	cQuery += "WHERE SE5.E5_DOCUMEN = ? "
	cQuery += "AND SE5.E5_TIPODOC = ? "
	cQuery += "AND SE5.E5_DATA = ? "

	cQuery := ChangeQuery(cQuery)
	cAliasTMP := GetNextAlias()
	dbUseArea( .T., "TOPCONN", TcGenQry2(,,cQuery, {cDocumen, cTpDoc, DTOS(SEH->EH_DATA)}), cAliasTMP, .T., .F. )

	//Pega o recno da SE5 referente a aplicação
	( cAliasTMP )->( dbGoTop() )
	nRecno := ( cAliasTMP )->R_E_C_N_O_

	(cAliasTMP)->( dbCloseArea() )
	FErase( cAliasTMP + GetDBExtension() )

Return nRecno

/*/{Protheus.doc} ModelDef
	Definição do modelo de dados, contendo as regras de negocio da rotina
	@type  Static Function
	@author Vitor Duca
	@since 07/05/2024
	@version 1.0
/*/
Static Function ModelDef() As Object
	Local oStruSEH  As Object
	Local oModel	As Object
	Local oStruSE2	As Object
	Local cAplEmp	As Character
	Local lModelEmp	As Logical
	Local lModelAPL	As Logical
	Local oStruCml	As Object
	Local lLegado   As Logical
	Local lExecAut  As Logical

	lExecAut	:= .F.

	If Type("lF171Auto") <> "U"
		lExecAut := lF171Auto
	Endif

	oStruSEH 	:= FWFormStruct(1, 'SEH')
	oStruSE2 	:= MontaSCab()
	oStruCml	:= CmpCalcPc()
	cAplEmp	 	:= "APL"
	lModelEmp	:= ( FwIsInCallStack("FINA171EMP") ) .or. ( lExecAut .and. aAutoCab[1][2][ascan(aAutoCab[1][2],{|x| x[1]='EH_APLEMP'})][2] == "EMP" )
	lModelAPL	:= ( FwIsInCallStack("FINA171APL") ) .or. ( lExecAut .and. aAutoCab[1][2][ascan(aAutoCab[1][2],{|x| x[1]='EH_APLEMP'})][2] == "APL" )
	lLegado		:= !lModelEmp .and. !lModelAPL .and. !lExecAut
	oStruSEH:SetProperty("EH_DATALIB", MODEL_FIELD_INIT, FWBuildFeature( STRUCT_FEATURE_INIPAD, "dDataBase"))

	If lModelEmp
		cAplEmp	 := "EMP"
	Endif

	If lExecAut
		oStruSEH:SetProperty("EH_NUMERO", MODEL_FIELD_INIT, FWBuildFeature( STRUCT_FEATURE_INIPAD, ""))
	EndIf

	oStruSEH:SetProperty("EH_APLEMP", MODEL_FIELD_INIT, FWBuildFeature( STRUCT_FEATURE_INIPAD, '"'+cAplEmp+'"'))
	oStruSEH:SetProperty("EH_APLEMP", MODEL_FIELD_WHEN, {||Iif((lModelEmp .or. lModelAPL) .and. !lExecAut, .F., .T.)})

	oStruSEH:SetProperty("EH_NATUREZ", MODEL_FIELD_INIT, FWBuildFeature( STRUCT_FEATURE_INIPAD, "F171IniNat()"))

	oStruSEH:SetProperty("EH_BANCO", 	MODEL_FIELD_VALID, 	{|| Vazio() .OR. A171Banco() })
	oStruSEH:SetProperty("EH_AGENCIA", 	MODEL_FIELD_VALID, 	{|| Vazio() .OR. A171Banco() })
	oStruSEH:SetProperty("EH_CONTA", 	MODEL_FIELD_VALID , {|| Vazio() .OR. A171Banco() })

	If lModelEmp .or. lLegado
		oStruSEH:AddField( STR0105												,; 	// [01] C Titulo do campo // "Fornecedor"
		STR0105																	,; 	// [02] C ToolTip do campo // "Fornecedor"
		"AUTCODFOR"	 															,; 	// [03] C identificador (ID) do Field
		"C" 																	,; 	// [04] C Tipo do campo
		TamSx3("A2_COD")[1]														,; 	// [05] N Tamanho do campo
		0 																		,; 	// [06] N Decimal do campo
		{||.T.}																	,; 	// [07] B Code-block de validação do campo
		{||.T.}																	,; 	// [08] B Code-block de validação When do campo
		Nil 																	,; 	// [09] A Lista de valores permitido do campo
		.F. 																	,;	// [10] L Indica se o campo tem preenchimento obrigatório
		{|| PadR(SuperGetMV("MV_FOREMPR",.F.,"000001"), TamSx3("A2_COD")[1]) }	,; 	// [11] B Code-block de inicializacao do campo
		Nil 																	,;	// [12] L Indica se trata de um campo chave
		.F.		 																,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
		.T. )  	            														// [14] L Indica se o campo é virtual

		oStruSEH:AddField( STR0106												,; 	// [01] C Titulo do campo // "Loja"
		STR0106																	,; 	// [02] C ToolTip do campo // "Loja"
		"AUTFORLOJA"	 														,; 	// [03] C identificador (ID) do Field
		"C" 																	,; 	// [04] C Tipo do campo
		TamSx3("A2_LOJA")[1]													,; 	// [05] N Tamanho do campo
		0 																		,; 	// [06] N Decimal do campo
		{||.T.}																	,; 	// [07] B Code-block de validação do campo
		{||.T.}																	,; 	// [08] B Code-block de validação When do campo
		Nil 																	,; 	// [09] A Lista de valores permitido do campo
		.F. 																	,;	// [10] L Indica se o campo tem preenchimento obrigatório
		{|| Posicione("SA2", 1, xFilial("SA2") + PadR(SuperGetMV("MV_FOREMPR",.F.,"000001"), TamSx3("A2_COD")[1]), "A2_LOJA" )},; // [11] B Code-block de inicializacao do campo
		Nil 																	,;	// [12] L Indica se trata de um campo chave
		.F.		 																,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
		.T. )  	            														// [14] L Indica se o campo é virtual

		oStruSEH:AddTrigger('AUTCODFOR', 'AUTFORLOJA', {|| .T. }, {||Posicione("SA2", 1, xFilial("SA2")+FWFldGet("AUTCODFOR") , "A2_LOJA" )})
		oStruSEH:AddTrigger('EH_GERPARC', 'EH_PERCPLP', {|| M->EH_GERPARC == '1' }, {|| 0})
		oStruSEH:SetProperty("EH_PERCPLP", MODEL_FIELD_WHEN, {|| Fa171PerPl(oModel) })
		oStruSEH:SetProperty("EH_GERPARC", MODEL_FIELD_WHEN, {|| F171VlGerP(oModel) })
		oStruSEH:SetProperty("EH_GERPARC", MODEL_FIELD_VALID , {|| F171VlGerP(oModel) })
		
	EndIf

	If !X3USO(GetSx3Cache("EH_REVISAO", "X3_USADO"))
		oStruSEH:AddField( "Revisao"	,; 	// [01] C Titulo do campo // "Fornecedor"
		"Revisao"						,; 	// [02] C ToolTip do campo // "Fornecedor"
		"EH_REVISAO"	 				,; 	// [03] C identificador (ID) do Field
		"C" 							,; 	// [04] C Tipo do campo
		TamSx3("EH_REVISAO")[1]			,; 	// [05] N Tamanho do campo
		0 								,; 	// [06] N Decimal do campo
		{||.T.}							,; 	// [07] B Code-block de validação do campo
		{||.T.}							,; 	// [08] B Code-block de validação When do campo
		Nil 							,; 	// [09] A Lista de valores permitido do campo
		.F. 							,;	// [10] L Indica se o campo tem preenchimento obrigatório
		{|| "01" }						,; 	// [11] B Code-block de inicializacao do campo
		Nil 							,;	// [12] L Indica se trata de um campo chave
		.F.		 						,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
		.F. )  	            				// [14] L Indica se o campo é virtual
	Endif

	oModel := MPFormModel():New('FINA171', {|oMdl| Fa171Pre(oMdl)} /*bPreValidacao*/, {|oMdl| Fa171TudOk(oMdl)} /*bPosValidacao*/,  {|oMdl| Fa171Grv(oMdl)} /*bCommit*/, /*bCancel*/ )
	oModel:AddFields( 'SEHMASTER', /*cOwner*/, oStruSEH )

	If ((lModelEmp .or. lExecAut .or. lLegado) .and. __nOpcMVC == MODEL_OPERATION_INSERT) 
		oModel:AddFields("CALCPARC", "SEHMASTER", oStruCml)
		oModel:SetOnlyQuery("CALCPARC", .T.)
		
		oModel:AddGrid( 'SE2DETAIL', 'SEHMASTER', oStruSE2)
		oModel:SetOptional("SE2DETAIL", .T.)

		oModel:AddCalc( 'SE2TOTAL', 'SEHMASTER', 'SE2DETAIL', 'PARCELA', 'PARCTOT', 'COUNT', { || .T. },,'Total parcelas' )
		oModel:AddCalc( 'SE2TOTAL', 'SEHMASTER', 'SE2DETAIL', 'JUROS', 'JUROSTOT', 'SUM', { || .T. },,'Total juros' )
		oModel:AddCalc( 'SE2TOTAL', 'SEHMASTER', 'SE2DETAIL', 'AMORTIZA', 'AMORTIZTOT', 'SUM', { || .T. },,'Total amortizações' )
		oModel:AddCalc( 'SE2TOTAL', 'SEHMASTER', 'SE2DETAIL', 'PRESTACAO', 'PRESTTOT', 'SUM', { || .T. },,'Total prestações' )
	Endif

	oModel:SetPrimaryKey( {"EH_FILIAL", "EH_NUMERO", "EH_REVISAO"} )

Return oModel

/*/{Protheus.doc} ViewDef
	Definição da visualização dos modelos MVC
	@type  Static Function
	@author Vitor Duca
	@since 07/05/2024
	@version 1.0
/*/
Static Function ViewDef() As Object
	Local oStruSEH  As Object
	Local oView		As Object
	Local oStruSE2	As Object
	Local oCalcPc	As Object
	Local cTitulo	As Character
	Local oStruTot	As Object
	Local lViewEmp	As Logical
	Local lViewApl	As Logical
	Local lLegado	As Logical
	Local lExecAut  As Logical

	lExecAut	:= .F.

	If Type("lF171Auto") <> "U"
		lExecAut := lF171Auto
	Endif

	oStruSEH 	:= FWFormStruct(2, 'SEH')
	oStruSE2 	:= MontaSView()
	oCalcPc		:= CalcPcView()
	oView 		:= FWFormView():New()
	oModel 		:= FWLoadModel( 'FINA171' )
	cTitulo 	:= STR0101 //"Aplicação/Empréstimo"
	lViewEmp	:= ( FwIsInCallStack("FINA171EMP") ) .or. ( lExecAut .and. aAutoCab[1][2][ascan(aAutoCab[1][2],{|x| x[1]='EH_APLEMP'})][2] == "EMP" )
	lViewApl	:= ( FwIsInCallStack("FINA171APL") ) .or. ( lExecAut .and. aAutoCab[1][2][ascan(aAutoCab[1][2],{|x| x[1]='EH_APLEMP'})][2] == "APL" )
	lLegado		:= !lViewApl .and. !lViewEmp .and. !lExecAut
	oView:SetModel( oModel )

	oStruSEH:RemoveField( 'EH_TEMPLT' )

	If SEH->(FieldPos("EH_CALCUSR")) > 0
		oStruSEH:RemoveField( 'EH_CALCUSR' )
	Endif

	oStruSEH:RemoveField( 'EH_REVISAO' )

	If !(SuperGetMV("MV_PLSATIV", .F., .F.))
		oStruSEH:RemoveField( 'EH_TPBEM' )
		oStruSEH:RemoveField( 'EH_TPCUSTD' )
		oStruSEH:RemoveField( 'EH_VINCANS' )
		oStruSEH:RemoveField( 'EH_TPOUTR' )
	Endif

	If lViewEmp
		cTitulo := STR0102 //"Empréstimo"

		oStruSEH:RemoveField( "EH_QUOTAS" )
		oStruSEH:RemoveField( "EH_SLDCOTA" )
		oStruSEH:RemoveField( "EH_VLRCOTA" )
		oStruSEH:RemoveField( "EH_CONTRAT" )
		oStruSEH:RemoveField( "EH_BCOCONT" )
		oStruSEH:RemoveField( "EH_AGECONT" )
		oStruSEH:RemoveField( "EH_CTACONT" )
		oStruSEH:RemoveField( "EH_TXIRSWP" )
		oStruSEH:RemoveField( "EH_GARANTE" )
		oStruSEH:RemoveField( "EH_VIOFSWP" )
	Endif

	If lViewApl
		oStruSEH:RemoveField( "EH_TARIFA" )
		oStruSEH:RemoveField( "EH_AMORTIZ" )
		oStruSEH:RemoveField( "EH_SPREAD" )
		oStruSEH:RemoveField( "EH_DESPESA" )
		oStruSEH:RemoveField( "EH_DSPREAD" )
		oStruSEH:RemoveField( "EH_ENTRADA" )
		oStruSEH:RemoveField( "EH_VLAMORP" )
		oStruSEH:RemoveField( "EH_PRAZO" )
		oStruSEH:RemoveField( "EH_GERPARC" )
		oStruSEH:RemoveField( "EH_FINANC" )
		oStruSEH:RemoveField( "EH_CARENCI" )
		oStruSEH:RemoveField( "EH_JURCAR" )
		oStruSEH:RemoveField( "EH_PSPREAD" )
		oStruSEH:RemoveField( "EH_BASEDES" )
		oStruSEH:RemoveField( "EH_TXEFETI" )
	Endif

	If lViewEmp .or. lLegado
		oStruSEH:AddField("AUTCODFOR", "9I", STR0105, STR0105, {}, "C", "@!"	, /*bPictVar*/, "SA2", .T.,,"004",,,,.T.) //Fornecedor
		oStruSEH:AddField("AUTFORLOJA", "9J", STR0106, STR0106, {}, "C", "@!"	, /*bPictVar*/, /*cLookUp*/, .T.,,"004",,,,.T.) //Loja
	Endif

	oView:AddField( 'VIEW_SEH', oStruSEH, 'SEHMASTER' )

	If (lViewEmp .or. lLegado) .and. __nOpcMVC == MODEL_OPERATION_INSERT
		oStruTot := FWCalcStruct( oModel:GetModel('SE2TOTAL') )
		oView:AddGrid( 'VIEW_SE2', oStruSE2, 'SE2DETAIL' )
		oView:AddField( 'VIEW_TOT', oStruTot, 'SE2TOTAL' )
		oView:EnableTitleView('VIEW_TOT', 'Totais')

		oView:AddField( "VIEW_CMP", oCalcPc, "CALCPARC")

		oView:CreateHorizontalBox('GERAL',100)

		oView:CreateFolder('PASTAS','GERAL')
		oView:AddSheet('PASTAS','PASTA1', cTitulo )
		oView:CreateHorizontalBox('ID_PASTA_MASTERSEH',100,,,'PASTAS', 'PASTA1' )
		oView:SetOwnerView( 'VIEW_SEH', 'ID_PASTA_MASTERSEH' )

		oView:AddSheet('PASTAS','PASTA2', STR0103 ) //"Projeção das parcelas"
		oView:CreateHorizontalBox('CAMPOS_CALCULO',20,,,'PASTAS', 'PASTA2' )
		oView:CreateHorizontalBox('ID_PASTA_PARCELAS',60,,,'PASTAS', 'PASTA2' )
		oView:CreateHorizontalBox('TOTALIZADOR',20,,,'PASTAS', 'PASTA2' )

		oView:AddOtherObject("btnCalculaParc", {| oPanel | F171Botao(oPanel)})
		oView:SetOwnerView("btnCalculaParc",'CAMPOS_CALCULO')

		oView:SetOwnerView('VIEW_CMP', 'CAMPOS_CALCULO')
		oView:SetOwnerView("VIEW_TOT",'TOTALIZADOR')
		oView:SetOwnerView('VIEW_SE2', 'ID_PASTA_PARCELAS')

		oView:SetVldFolder({|cFolderID, nOldSheet, nSelSheet| F171VldFld(cFolderID, nOldSheet, nSelSheet)})

	Else
		oView:CreateHorizontalBox('SUPERIOR', 100)
		oView:SetOwnerView( 'VIEW_SEH', 'SUPERIOR' )
	Endif

Return oView

/*/{Protheus.doc} F171Botao
	Função para inclusão do botão Calcular parcelas
	@type  Static Function
	@author Vitor Duca
	@since 21/05/2024
	@version 1.0
	@param param_name, param_type, param_descr
/*/
Static Function F171Botao(oPanel As Object)
	Local oButton		As Object
	Local aObjCoords	As Array

	aObjCoords		:= {}
	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4], 0, 0 }
	aAdd( aObjCoords , { 100 , 100 , .T. , .F. } )
	aObjSize := MsObjSize( aInfoAdvSize , aObjCoords )

	@10,(aObjSize[1,4] - 75) BUTTON oButton PROMPT STR0104 /*"Calcular"*/  SIZE 50,10 FONT oPanel:oFont ACTION MsgRun( STR0043,, { || lRet := FC171Par() }  ) OF oPanel PIXEL //"Aguarde, realizando o calculo das parcelas...

Return

/*/{Protheus.doc} F171VldFld
	Validação dos campos obrigatorios para que aba projeção das parcelas
	possa ser acessada pelo usuario
	@type  Static Function
	@author Vitor Duca
	@since 05/06/2024
	@version 1.0
	@param cFolderID, Character, ID do folder(quando for criado pelo desenvolvedor através do método AddFolder)
	@param nOldSheet, Numeric, Sheet que estava selecionada
	@param cFolderID, Character, Sheet que o usuário clicou
	@return lRet, Logical, Retorna se o usuario pode acessar a aba
/*/
Static Function F171VldFld(cFolderID As Character, nOldSheet As Numeric, nSelSheet As Numeric) As Logical
	Local lRet	As Logical
	Local lVlZero := .F. As Logical
	lRet := .T.

	lVlZero := M->EH_PRAZO == 0 .and. M->EH_VLAMORP == 0

	If nOldSheet == 1 .And. nSelSheet == 2 .and. ( M->EH_GERPARC <> "1" .or. lVlZero .or. Empty(M->EH_AMORTIZ) )
		FWAlertError(STR0120+Alltrim(FWX3Titulo("EH_GERPARC"))+", "+Alltrim(FWX3Titulo("EH_PRAZO"))+", "+Alltrim(FWX3Titulo("EH_VLAMORP"))+STR0122+Alltrim(FWX3Titulo("EH_AMORTIZ")), STR0121) //"Verifique o conteúdo dos campos "#" e "#"Conteúdo inválido"
		lRet := .F.
	Endif
Return lRet

/*/{Protheus.doc} MontaSCab()
	Retorna estrutura do tipo FWformModelStruct.

	@author Ronaldo Tapia

	@since 27/06/2016
	@version 1.0
/*/
Static function MontaSCab() As Object
	Local aArea		As Array
	Local oStruct 	As Object

	If __lSwitch == Nil
		__lSwitch	:= .F. // Opção disponível para o operador editar os valores do emprestimo em tela (Default .F.)
	EndIf

	aArea := GetArea()
	oStruct := FWFormModelStruct():New()

	oStruct:AddTable(__cAlsTmp, {'PARCELA','VENCTO','VALOR','JUROS','VCORRIGIDO','AMORTIZA','PRESTACAO'}, "Cabeçalho do TRB", {|| __cTblname})

	oStruct:AddField( STR0068	,; 	// [01] C Titulo do campo // "Parcela"
	STR0068						,; 	// [02] C ToolTip do campo // "Parcela"
	"PARCELA"	 				,; 	// [03] C identificador (ID) do Field
	"C" 						,; 	// [04] C Tipo do campo
	__nTamParc					,; 	// [05] N Tamanho do campo
	0 							,; 	// [06] N Decimal do campo
	NIL							,; 	// [07] B Code-block de validação do campo
	{||lF171Auto}				,; 	// [08] B Code-block de validação When do campo
	Nil 						,; 	// [09] A Lista de valores permitido do campo
	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatório
	Nil							,; 	// [11] B Code-block de inicializacao do campo
	Nil 						,;	// [12] L Indica se trata de um campo chave
	.T.		 					,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
	.F. )  	            			// [14] L Indica se o campo é virtual

	oStruct:AddField( STR0069	,; 	// [01] C Titulo do campo // "Vencimento"
	STR0069						,; 	// [02] C ToolTip do campo // "Vencimento"
	"VENCTO" 						,; 	// [03] C identificador (ID) do Field
	"D" 						,; 	// [04] C Tipo do campo
	8							,; 	// [05] N Tamanho do campo
	0 							,; 	// [06] N Decimal do campo
	{|| Fc171Recal()}			,; 	// [07] B Code-block de validação do campo
	{||lF171Auto .or. FWFldGet("EH_AMORTIZ") == "2"}	,; 	// [08] B Code-block de validação When do campo
	Nil 						,; 	// [09] A Lista de valores permitido do campo
	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatório
	Nil							,; 	// [11] B Code-block de inicializacao do campo
	Nil 						,;	// [12] L Indica se trata de um campo chave
	.T.		 					,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
	.F. )  	            		// [14] L Indica se o campo é virtual

	oStruct:AddField( STR0070	,; 	// [01] C Titulo do campo // "Valor do Débito"
	STR0070						,; 	// [02] C ToolTip do campo // "Valor do Débito"
	"VALOR" 					,; 	// [03] C identificador (ID) do Field
	"N" 						,; 	// [04] C Tipo do campo
	14							,; 	// [05] N Tamanho do campo
	2							,; 	// [06] N Decimal do campo
	Nil							,; 	// [07] B Code-block de validação do campo
	{||lF171Auto}				,; 	// [08] B Code-block de validação When do campo
	Nil 						,; 	// [09] A Lista de valores permitido do campo
	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatório
	Nil							,; 	// [11] B Code-block de inicializacao do campo
	Nil 						,;	// [12] L Indica se trata de um campo chave
	.T.		 					,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
	.F. )  	            		// [14] L Indica se o campo é virtual

	oStruct:AddField( STR0071	,; 	// [01] C Titulo do campo // "Juros"
	STR0071						,; 	// [02] C ToolTip do campo // "Juros"
	"JUROS" 					,; 	// [03] C identificador (ID) do Field
	"N" 						,; 	// [04] C Tipo do campo
	14							,; 	// [05] N Tamanho do campo
	2							,; 	// [06] N Decimal do campo
	{|| F171AltJur() }			,; 	// [07] B Code-block de validação do campo
	{|| F171WhAltP() }			,; // [08] B Code-block de validação When do campo
	Nil 						,; 	// [09] A Lista de valores permitido do campo
	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatório
	Nil							,; 	// [11] B Code-block de inicializacao do campo
	Nil 						,;	// [12] L Indica se trata de um campo chave
	.T.		 					,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
	.F. )  	            		// [14] L Indica se o campo é virtual

	oStruct:AddField( STR0072	,; 	// [01] C Titulo do campo // "Valor Corrigido"
	STR0072						,; 	// [02] C ToolTip do campo // "Valor Corrigido"
	"VCORRIGIDO"				,; 	// [03] C identificador (ID) do Field
	"N" 						,; 	// [04] C Tipo do campo
	14							,; 	// [05] N Tamanho do campo
	2							,; 	// [06] N Decimal do campo
	Nil 						,; 	// [07] B Code-block de validação do campo
	{||lF171Auto}				,; 	// [08] B Code-block de validação When do campo
	Nil 						,; 	// [09] A Lista de valores permitido do campo
	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatório
	Nil							,; 	// [11] B Code-block de inicializacao do campo
	Nil 						,;	// [12] L Indica se trata de um campo chave
	.F.		 					,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
	.F. )  	            		// [14] L Indica se o campo é virtual

	oStruct:AddField( STR0073	,; 	// [01] C Titulo do campo // "Amortização"
	STR0073						,; 	// [02] C ToolTip do campo // "Amortização"
	"AMORTIZA" 					,; 	// [03] C identificador (ID) do Field
	"N" 						,; 	// [04] C Tipo do campo
	14							,; 	// [05] N Tamanho do campo
	2 							,; 	// [06] N Decimal do campo
	{|| f171AltAmo()}			,; 	// [07] B Code-block de validação do campo
	{|| F171WhAltP()}			,; 	// [08] B Code-block de validação When do campo
	Nil 						,; 	// [09] A Lista de valores permitido do campo
	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatório
	Nil							,; 	// [11] B Code-block de inicializacao do campo
	Nil 						,;	// [12] L Indica se trata de um campo chave
	.T.		 					,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
	.F. )  	            		// [14] L Indica se o campo é virtual

	oStruct:AddField( STR0074	,; 	// [01] C Titulo do campo // "Prestação"
	STR0074						,; 	// [02] C ToolTip do campo // "Prestação"
	"PRESTACAO"					,; 	// [03] C identificador (ID) do Field
	"N" 						,; 	// [04] C Tipo do campo
	14							,; 	// [05] N Tamanho do campo
	2							,; 	// [06] N Decimal do campo
	Nil 						,; 	// [07] B Code-block de validação do campo
	{||lF171Auto}				,; 	// [08] B Code-block de validação When do campo
	Nil 						,; 	// [09] A Lista de valores permitido do campo
	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatório
	Nil							,; 	// [11] B Code-block de inicializacao do campo
	Nil 						,;	// [12] L Indica se trata de um campo chave
	.T.		 					,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
	.F. )  	            		// [14] L Indica se o campo é virtual

	oStruct:AddIndex( 	1	      	, ;     // [01] Ordem do indice
	"01"   							, ;     // [02] ID
	"PARCELA"				  		, ;		// [03] Chave do indice
	"Indice 1" + " + " + "Parcela"	, ;     // [04] Descrição do indice
	""       						, ;		// [05] Expressão de lookUp dos campos de indice (SIX_F3)
	"" 								, ;		// [06] Nickname do indice
	.T. )      								// [07] Indica se o indice pode ser utilizado pela interface

	oStruct:AddIndex( 	2	      	, ;     // [01] Ordem do indice
	"02"   							, ;     // [02] ID
	"VENCTO"				  		, ; 	// [03] Chave do indice
	"Indice 2" + " + " + "Data"		, ;     // [04] Descrição do indice
	""       						, ;		// [05] Expressão de lookUp dos campos de indice (SIX_F3)
	"" 								, ;		// [06] Nickname do indice
	.T. )

	RestArea( aArea )

Return oStruct

/*/{Protheus.doc} CmpCalcPc
	Retorna a estrutura dos campos complementares para calculo das parcelas
	@type  Static Function
	@author Vitor Duca
	@since 23/05/2024
	@version 1.0
	@return oStruct, Objeto, FWFormModelStruct contendo os campos necessarios
/*/
Static function CmpCalcPc() As Object
	Local aArea		As Array
	Local oStruct 	As Object

	aArea := GetArea()
	oStruct := FWFormModelStruct():New()

	oStruct:AddTable("FAKE", {'dataPrimeiroVencimento','AUTFIXEDDUE', 'AUTNEXTDUE', 'AUTQTDDIAS',  'AUTCUSTOMVLR'}, "Campos adicionais para calculo")

	oStruct:AddField( STR0107	,; 	// [01] C Titulo do campo // ""Primeiro vencimento""
	STR0107						,; 	// [02] C ToolTip do campo // ""Primeiro vencimento""
	"dataPrimeiroVencimento"	,; 	// [03] C identificador (ID) do Field
	"D" 						,; 	// [04] C Tipo do campo
	8							,; 	// [05] N Tamanho do campo
	0 							,; 	// [06] N Decimal do campo
	{||F171PrVenc()}			,; 	// [07] B Code-block de validação do campo
	{||.T.}						,; 	// [08] B Code-block de validação When do campo
	Nil 						,; 	// [09] A Lista de valores permitido do campo
	.F. 						,;	// [10] L Indica se o campo tem preenchimento obrigatório
	NIL 						,; 	// [11] B Code-block de inicializacao do campo
	Nil 						,;	// [12] L Indica se trata de um campo chave
	.T.		 					,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
	.F. )  	            			// [14] L Indica se o campo é virtual

	oStruct:AddField( STR0108	,; 	// [01] C Titulo do campo // ""Dia Fixo para vencimento""
	STR0108						,; 	// [02] C ToolTip do campo // ""Dia Fixo para vencimento""
	"AUTFIXEDDUE"				,; 	// [03] C identificador (ID) do Field
	"N" 						,; 	// [04] C Tipo do campo
	2							,; 	// [05] N Tamanho do campo
	0 							,; 	// [06] N Decimal do campo
	NIL							,; 	// [07] B Code-block de validação do campo
	{||.T.}						,; 	// [08] B Code-block de validação When do campo
	Nil 						,; 	// [09] A Lista de valores permitido do campo
	.F. 						,;	// [10] L Indica se o campo tem preenchimento obrigatório
	NIL 						,; 	// [11] B Code-block de inicializacao do campo
	Nil 						,;	// [12] L Indica se trata de um campo chave
	.T.		 					,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
	.F. )  	            			// [14] L Indica se o campo é virtual

	oStruct:AddField( STR0109	,; 	// [01] C Titulo do campo // ""Vencimento em dia não util""
	STR0109						,; 	// [02] C ToolTip do campo // ""Vencimento em dia não util""
	"AUTNEXTDUE"				,; 	// [03] C identificador (ID) do Field
	"C" 						,; 	// [04] C Tipo do campo
	1							,; 	// [05] N Tamanho do campo
	0 							,; 	// [06] N Decimal do campo
	NIL							,; 	// [07] B Code-block de validação do campo
	{||.T.}						,; 	// [08] B Code-block de validação When do campo
	{"", "N="+STR0110, "S="+STR0111, "M="+STR0112 } ,; 	// [09] A Lista de valores permitido do campo
	.F. 						,;	// [10] L Indica se o campo tem preenchimento obrigatório
	NIL 						,; 	// [11] B Code-block de inicializacao do campo
	Nil 						,;	// [12] L Indica se trata de um campo chave
	.T.		 					,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
	.F. )  	            			// [14] L Indica se o campo é virtual

	oStruct:AddField( STR0118	,; 	// [01] C Titulo do campo // "Qtd. dias entre parcelas"
	STR0118						,; 	// [02] C ToolTip do campo // "Qtd. dias entre parcelas"
	"AUTQTDDIAS"				,; 	// [03] C identificador (ID) do Field
	"N" 						,; 	// [04] C Tipo do campo
	3							,; 	// [05] N Tamanho do campo
	0 							,; 	// [06] N Decimal do campo
	NIL							,; 	// [07] B Code-block de validação do campo
	{||.T.}						,; 	// [08] B Code-block de validação When do campo
	NIL 						,; 	// [09] A Lista de valores permitido do campo
	.F. 						,;	// [10] L Indica se o campo tem preenchimento obrigatório
	NIL 						,; 	// [11] B Code-block de inicializacao do campo
	Nil 						,;	// [12] L Indica se trata de um campo chave
	.T.		 					,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
	.F. )  	            			// [14] L Indica se o campo é virtual

	oStruct:AddField( STR0123	,; 	// [01] C Titulo do campo // ""Alt. Vlr Manual""
	STR0123						,; 	// [02] C ToolTip do campo // ""Alt. Vlr Manual""
	"AUTCUSTOMVLR"				,; 	// [03] C identificador (ID) do Field
	"C" 						,; 	// [04] C Tipo do campo
	1							,; 	// [05] N Tamanho do campo
	0 							,; 	// [06] N Decimal do campo
	{||F171CstVlr()}			,; 	// [07] B Code-block de validação do campo
	{||.T.}						,; 	// [08] B Code-block de validação When do campo
	{"1="+STR0124, "2="+STR0125 } 	,; 	// [09] A Lista de valores permitido do campo
	.F. 						,;	// [10] L Indica se o campo tem preenchimento obrigatório
	{||'2'}	 					,; 	// [11] B Code-block de inicializacao do campo
	Nil 						,;	// [12] L Indica se trata de um campo chave
	.T.		 					,; 	// [13] L Indica se o campo não pode receber valor em uma operação de update.
	.F. )  	            			// [14] L Indica se o campo é virtual

	RestArea( aArea )

Return oStruct

/*/{Protheus.doc} MontaSView()
	Retorna estrutura do tipo FWFormViewStruct.

	@author Ronaldo Tapia

	@since 27/06/2016
	@version 1.0
/*/
Static function MontaSView() As Object
	Local oStruct  	As Object
	Local cPicture	As Character

	oStruct := FWFormViewStruct():New()
	cPicture := "@R " + CValToChar(__nLastPar)

	/* Estutura para a criação de campos na view

		[01] C Nome do Campo
		[02] C Ordem
		[03] C Titulo do campo
		[04] C Descrição do campo
		[05] A Array com Help
		[06] C Tipo do campo
		[07] C Picture
		[08] B Bloco de Picture Var
		[09] C Consulta F3
		[10] L Indica se o campo é editável
		[11] C Pasta do campo
		[12] C Agrupamento do campo
		[13] A Lista de valores permitido do campo (Combo)
		[14] N Tamanho Maximo da maior opção do combo
		[15] C Inicializador de Browse
		[16] L Indica se o campo é virtual
		[17] C Picture Variável

	*/
	oStruct:AddField("PARCELA",    "01", STR0068, STR0068, {}, "C", cPicture		   , /*bPictVar*/, /*cLookUp*/, .T.)
	oStruct:AddField("VENCTO",     "02", STR0069, STR0069, {}, "D", "@!"			   , /*bPictVar*/, /*cLookUp*/, .T.)
	oStruct:AddField("VALOR",      "03", STR0070, STR0070, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.)
	oStruct:AddField("JUROS",      "04", STR0071, STR0071, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.)
	oStruct:AddField("VCORRIGIDO", "05", STR0072, STR0072, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.)
	oStruct:AddField("AMORTIZA",   "06", STR0073, STR0073, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.)
	oStruct:AddField("PRESTACAO",  "07", STR0074, STR0074, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.)

Return oStruct

/*/{Protheus.doc} CalcPcView
	Retorna a estrutura dos campos utilizado para calculo da parcela,
	estrutura que sera utilizada na view
	@type  Static Function
	@author Vitor Duca
	@since 23/05/2024
	@version 1.0
	@return oStruct, Object, FWFormViewStruct contendo as informações dos campos
/*/
Static Function CalcPcView()
	Local oStruct  	As Object

	oStruct := FWFormViewStruct():New()

	/* Estutura para a criação de campos na view

		[01] C Nome do Campo
		[02] C Ordem
		[03] C Titulo do campo
		[04] C Descrição do campo
		[05] A Array com Help
		[06] C Tipo do campo
		[07] C Picture
		[08] B Bloco de Picture Var
		[09] C Consulta F3
		[10] L Indica se o campo é editável
		[11] C Pasta do campo
		[12] C Agrupamento do campo
		[13] A Lista de valores permitido do campo (Combo)
		[14] N Tamanho Maximo da maior opção do combo
		[15] C Inicializador de Browse
		[16] L Indica se o campo é virtual
		[17] C Picture Variável

	*/
	oStruct:AddField("dataPrimeiroVencimento", "01", STR0107, STR0107, {}, "D", , /*bPictVar*/, /*cLookUp*/, .T.) //Primeiro vencimento
	oStruct:AddField("AUTFIXEDDUE", "02", STR0108, STR0108, {}, "N", "99", /*bPictVar*/, /*cLookUp*/, .T.) //Dia fixo para vencimento
	oStruct:AddField("AUTNEXTDUE", "03", STR0109, STR0109, {}, "C", "@!", /*bPictVar*/, /*cLookUp*/, .T.,,,{"", "N="+STR0110 /*Antecipar*/, "S="+STR0111 /*Postergar*/, "M="+STR0112/*"Manter"*/ }) //Vencimento em dia não util
	oStruct:AddField("AUTQTDDIAS", "04", STR0118, STR0118, {}, "N", "999", /*bPictVar*/, /*cLookUp*/, .T.) //"Qtd. dias entre parcelas"
	oStruct:AddField("AUTCUSTOMVLR", "05", STR0123, STR0123, {}, "C", "@!", /*bPictVar*/, /*cLookUp*/, .T.,,,{"1="+STR0124, "2="+STR0125}) // Altera valores da parcela manualmente

Return oStruct

/*/{Protheus.doc} FC171Par
	Realiza o calculo das parcelas para exibir em tela ao usuario
	Utilizado na inclusão de um emprestimo com parcela
	@type  Static Function
	@author Vitor Duca
	@since 21/05/2024
	@version 1.0
/*/
Static Function FC171Par() As Logical
	Local nX       		As Numeric
	Local nY			As Numeric
	Local oView    		As Object
	Local oModel   		As Object
	Local jModel		As Json
	Local jCampos		As Json
	Local jParcelas		As Json
	Local cCampo		As Character
	Local oSubSE2		As Object
	Local jModView		As Json
	Local nLines		As Numeric

	nX       	:= 0
	nY			:= 0
	jModView	:= FnGetModel()
	oView    	:= jModView["view"]
	oModel   	:= jModView["model"]
	jModel		:= JsonObject():new()
	jCampos		:= JsonObject():new()
	jParcelas	:= JsonObject():new()
	cCampo		:= ""
	oSubSE2		:= oModel:GetModel("SE2DETAIL")
	nLines		:= oSubSE2:Length()

	For nX := 1 to nLines
		oSubSE2:GoLine(nX)
		oSubSE2:DeleteLine()
	Next nX

	oSubSE2:ClearData()

	oSubSE2:GoLine(1)

	If Empty(jModel:fromJson(oModel:GetJSONData()))
		For nX := 1 to Len(jModel["models"][1]["fields"])
			cCampo := jModel["models"][1]["fields"][nX]["id"]

			If !(jModel["models"][1]["fields"][nX]["id"] $ "AUTCODFOR|AUTFORLOJA")
				cCampo := Lower(cCampo)
			Endif

			jCampos[cCampo] := jModel["models"][1]["fields"][nX]["value"]

			If GetSx3Cache(jModel["models"][1]["fields"][nX]["id"], "X3_TIPO") == "N"
				jCampos[cCampo] := Val(jCampos[cCampo])
			Endif
		Next nX

		For nX := 1 to Len(jModel["models"][1]["models"])
			If jModel["models"][1]["models"][nX]["id"] == "CALCPARC"
				For nY := 1 to Len(jModel["models"][1]["models"][nX]["fields"])
					cCampo := jModel["models"][1]["models"][nX]["fields"][nY]["id"]
					jCampos[cCampo] := jModel["models"][1]["models"][nX]["fields"][nY]["value"]
				Next nY
				Exit
			Endif
		Next nX

		F171SetTpl(@jCampos)

		jParcelas := CalculateParcels(jCampos)

		If !jParcelas["result"]
			FWAlertError(jParcelas["response"]["detailedMessage"], jParcelas["response"]["message"])
		Else
			For nX := 1 to Len(jParcelas["response"]["items"])
				If nX > 1
					oSubSE2:AddLine()
				Endif

				oSubSE2:LoadValue("PARCELA", cValToChar(jParcelas["response"]["items"][nX]["parcela"]))
				oSubSE2:LoadValue("VENCTO", jParcelas["response"]["items"][nX]["datax"])
				oSubSE2:LoadValue("VALOR", jParcelas["response"]["items"][nX]["valor_value"])
				oSubSE2:LoadValue("JUROS", jParcelas["response"]["items"][nX]["juros_value"])
				oSubSE2:LoadValue("VCORRIGIDO", jParcelas["response"]["items"][nX]["vcorrigido_value"])
				oSubSE2:LoadValue("AMORTIZA", jParcelas["response"]["items"][nX]["amortiza_value"])
				oSubSE2:LoadValue("PRESTACAO", jParcelas["response"]["items"][nX]["prestacao_value"])

			Next nX
		Endif
	Endif

	oSubSE2:GoLine(1)
	oView:Refresh()
Return .T.

/*/{Protheus.doc} F171NewTmp
	Função responsavel por criar a tabela temporaria das parcelas que serão geradas pelo
	empréstimo
	@type  Static Function
	@author Vitor Duca
	@since 21/05/2024
	@version 1.0
/*/
Static Function F171NewTmp()
	Local aCampos	As array

	aCampos	:= {;
				{"PARCELA   ", "C",  __nTamParc, 0},;
				{"VENCTO    ", "D",           8, 0},;
				{"VALOR     ", "N",          14, 2},;
				{"JUROS     ", "N",          14, 2},;
				{"VCORRIGIDO", "N",          14, 2},;
				{"AMORTIZA  ", "N",          14, 2},;
				{"PRESTACAO ", "N",          14, 2} }

	If _oFINA171 <> NIL .and. FindFunction("totvs.protheus.backoffice.fin.queryutil.FinExecSql")
		totvs.protheus.backoffice.fin.queryutil.FinExecSql("DELETE FROM " + __cTblname, {|| F171DelTmp()})
	EndIf

	If _oFINA171 == Nil

		_oFINA171 := FwTemporaryTable():New()
		_oFINA171:SetFields(aCampos)
		_oFINA171:AddIndex("1",{"PARCELA"})
		_oFINA171:Create()

		__cAlsTmp := _oFINA171:GetAlias()
		__cTblname := _oFINA171:GetRealName()
	EndIf

Return

/* {Protheus.doc} FCGrvE2
	Função para gravação das parcelas no contas a pagar (SE2)

	@author    Ronaldo Tapia
	@version   11.80
	@since     04/07/2016
	@protected
*/
Static Function FCGrvE2(oModel As Object) As Logical
	Local aArray		As Array
	Local cParcela		As Character
	Local dData			As Date
	Local dDataOri 		As Date
	Local nValor		As Numeric
	Local nJuros		As Numeric
	Local aArea			As Array
	Local nNumReg		As Numeric
	Local nTotVal		As Numeric
	Local cUltPar   	As Character
	Local lRet			As Logical
	Local cPostVencP	As Character
	Local cFornece		As Character
	Local cLoja			As Character

	aArray		:= {}
	cParcela	:= ""
	dData		:= STOD("")
	dDataOri 	:= STOD("")
	nValor		:= 0
	nJuros		:= 0
	aArea		:= GetArea()
	nNumReg		:= CONTAR(__cAlsTmp, '!EOF()')
	nTotVal		:= 0
	cUltPar   	:= ""
	lRet		:= .T.
	cPostVencP	:= oModel:GetModel("CALCPARC"):getValue("AUTNEXTDUE")
	cFornece	:= oModel:GetModel("SEHMASTER"):getValue("AUTCODFOR")
	cLoja		:= oModel:GetModel("SEHMASTER"):getValue("AUTFORLOJA")

	//Caso venha de execauto a variavel ja esta declarada
	If !lF171Auto
		Private lMsErroAuto := .F.
	Endif

	cUltPar := PadR(cValtoChar(nNumReg), __nTamParc)

	If !lF171Auto
		ProcRegua(nNumReg)
	Endif

	(__cAlsTmp)->(dbGoTop())
	While (__cAlsTmp)->(!EOF()) .and. lRet

		If !lF171Auto
			// Alimenta barra de progresso
			IncProc(STR0032+cParcela) //"Gravando Parcela: "
		Endif

		cParcela	:= (__cAlsTmp)->PARCELA
		dData		:= (__cAlsTmp)->VENCTO
		nValor		:= (__cAlsTmp)->PRESTACAO
		nJuros		:= (__cAlsTmp)->JUROS

		// Tratamento para gravar o VENCORI como data usada no calculo
		If cPostVencP $ 'S|N' .And. !IsInCallStack("TOTVS.PROTHEUS.BACKOFFICE.NGF.APPLICATIONSLOANS.POSTAPPLICATIONSLOANS")
			dDataOri := dData
			dData 	 := dataValida(dDataOri, cPostVencP == "S")
		EndIf

		// Tratamento para parcelas com carência, grava somente o valor dos juros
		If (__cAlsTmp)->AMORTIZA == 0 .And. SEH->EH_JURCAR == "1" .And. (__cAlsTmp)->JUROS > 0
			nValor := nJuros
		EndIf

		// Ajusta valor da última parcela
		If cParcela == cUltPar
			If nTotVal + (__cAlsTmp)->AMORTIZA < SEH->EH_FINANC
				nValor := Round(SEH->EH_FINANC - nTotVal,2) + (__cAlsTmp)->JUROS
			EndIf
		EndIf

		aArray := {	{ "E2_PREFIXO"		, SEH->EH_TIPO      , NIL },;
			{ "E2_NUM"      , SEH->EH_NUMERO    , NIL },;
			{ "E2_PARCELA"  , cParcela          , NIL },;
			{ "E2_TIPO"     , "PR"              , NIL },;
			{ "E2_NATUREZ"  , SEH->EH_NATUREZA  , NIL },;
			{ "E2_FORNECE"  , cFornece          , NIL },;
			{ "E2_LOJA"		, cLoja             , NIL },;
			{ "E2_EMISSAO"  , SEH->EH_DATA		, NIL },;
			{ "E2_VENCTO"   , dData				, NIL },;
			{ "E2_JUROS"    , nJuros			, NIL },;
			{ "E2_MOEDA"    , SEH->EH_MOEDA		, NIL },;
			{ "E2_VALOR"    , nValor			, NIL },;
			{ "E2_DEBITO"   , SEH->EH_DEBITO	, NIL },;
			{ "E2_CREDIT"   , SEH->EH_CREDIT	, NIL },;
			{ "E2_CCUSTO"   , SEH->EH_CCUSTO	, NIL },;
			{ "E2_CCD"   	, SEH->EH_CCD		, NIL },;
			{ "E2_CCC"   	, SEH->EH_CCC		, NIL },;
			{ "E2_ITEMD"   	, SEH->EH_ITEMD		, NIL },;
			{ "E2_ITEMC"   	, SEH->EH_ITEMC		, NIL },;
			{ "E2_CLVLDB"  	, SEH->EH_CLVLDB	, NIL },;
			{ "E2_CLVLCR"  	, SEH->EH_CLVLCR	, NIL },;
			{ "E2_ORIGEM"   , "FINA171"			, NIL } }

		If lMovEnt05
			AADD(aArray,{ "E2_EC05DB"  	, SEH->EH_EC05DB	, NIL })
			AADD(aArray,{ "E2_EC05CR"  	, SEH->EH_EC05CR	, NIL })
		EndIf

		If lMovEnt06
			AADD(aArray,{ "E2_EC06DB"  	, SEH->EH_EC06DB	, NIL })
			AADD(aArray,{ "E2_EC06CR"  	, SEH->EH_EC06CR	, NIL })
		EndIf

		If lMovEnt07
			AADD(aArray,{ "E2_EC07DB"  	, SEH->EH_EC07DB	, NIL })
			AADD(aArray,{ "E2_EC07CR"  	, SEH->EH_EC07CR	, NIL })
		EndIf

		If lMovEnt08
			AADD(aArray,{ "E2_EC08DB"  	, SEH->EH_EC08DB	, NIL })
			AADD(aArray,{ "E2_EC08CR"  	, SEH->EH_EC08CR	, NIL })
		EndIf

		If lMovEnt09
			AADD(aArray,{ "E2_EC09DB"  	, SEH->EH_EC09DB	, NIL })
			AADD(aArray,{ "E2_EC09CR"  	, SEH->EH_EC09CR	, NIL })
		EndIf

		nTotVal += (__cAlsTmp)->AMORTIZA

		// Só grava a parcela se for diferente de 999 e maior que zero
		If cParcela <> CValToChar(__nLastPar) .And. nValor > 0
			// Grava os valores no SE2
			MsExecAuto( { |x,y,z| FINA050(x,y,z)}, aArray,, 3)  // 3 - Inclusao, 4 - Alteração, 5 - Exclusão
			If lMsErroAuto
				If !lF171Auto
					MostraErro()
				Endif
				DisarmTransaction()
				lRet := .F.
			Endif
		EndIf

		If lMsErroAuto
			Exit
		Else
			If !Empty(dDataOri)
				RecLock("SE2",.F.)
				SE2->E2_VENCORI := dDataOri // Vencimento utilizado no calculo do juros.
				SE2->( MsUnlock() )
			EndIf
		Endif

		(__cAlsTmp)->(dbSkip())
	EndDo

	// Mostra erro
	If !lMsErroAuto
		If !lF171Auto
			FWAlertSuccess(STR0031, STR0102) //"Parcelas incluídas com sucesso!" # "Empréstimo"
		Endif
	Endif

	RestArea(aArea)

Return lRet

/* {Protheus.doc} FCGrvE5
	Função para gravação das despesas do contrato na SE5

	@author    Ronaldo Tapia
	@version   11.80
	@since     04/07/2016
	@protected
*/
Static Function FCGrvE5(lEstorno As Logical) As Logical
	Local nValor     	As Numeric
	Local cHistorico 	As Character
	Local lUsaFlag   	As Logical
	Local lAtuSldNat 	As Logical
	Local nMoedaBco  	As Numeric
	Local oModelMov  	As Object
	Local oSubFK5	 	As Object
	Local oSubFKA	 	As Object
	Local cLog       	As Character
	Local lRet       	As Logical
	Local cCamposE5  	As Character
	Local cSinal     	As Character
	Local lContabiliza	As Logical

	nValor     		:= 0
	cHistorico 		:= ""
	lUsaFlag   		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	lAtuSldNat 		:= FindFunction("AtuSldNat") .AND. AliasInDic("FIV") .AND. AliasInDic("FIW")
	nMoedaBco  		:= 1
	oModelMov  		:= FWLoadModel("FINM030") //Model de Movimento Bancário
	oSubFK5			:= NIL
	oSubFKA			:= NIL
	cLog       		:= ""
	lRet       		:= .T.
	cCamposE5  		:= ""
	cSinal     		:= ""
	lContabiliza	:= .F.

	If ValType(MV_PAR02) == "N"
		lContabiliza := MV_PAR02 == 1
	Endif

	DEFAULT lEstorno	:= .F.

	If lEstorno
		cHistorico := STR0075 //"Estorno Desp.Emprestimo/Financ."
	Else
		cHistorico := STR0030 //"Despesas Emprestimos/Financiamentos"
	EndIf

	dbSelectArea('SA6')
	dbSetOrder(1)
	If dbSeek(xFilial()+SEH->EH_BANCO+SEH->EH_AGENCIA+SEH->EH_CONTA)
		nMoedaBco := Max(SA6->A6_MOEDA,1)
	EndIf

	/*
	--- Formas de gravacao da movimentacao bancaria das despesas do contrato (a passar por revisao) ---
	FK5_MOEDA: Fixado na moeda forte;
	FK5_VALOR: Converte as despesas partindo da moeda do EH_MOEDA para a moeda do banco (A6_MOEDA);
	FK5_VLMOE2: Faz a conversao do FK5_VALOR partindo da moeda forte para a moeda do EH_MOEDA (taxa do SM2);
	FK5_TXMOED: Nao é gravado;
	*/
	If !Empty(SEH->EH_SPREAD)
		If SEH->EH_MOEDA > 1
			nValor := xMoeda(SEH->EH_DESPESA + SEH->EH_SPREAD,SEH->EH_MOEDA,nMoedaBco)
		Else
			nValor := SEH->EH_DESPESA + SEH->EH_SPREAD
		EndIf
	Else
		If SEH->EH_MOEDA > 1
			nValor := 	xMoeda(((SEH->EH_FINANC*SEH->EH_PSPREAD)/100) + SEH->EH_DESPESA,SEH->EH_MOEDA,nMoedaBco)
		Else
			nValor := ((SEH->EH_FINANC*SEH->EH_PSPREAD)/100) + SEH->EH_DESPESA
		EndIf
	EndIf

	If nValor > 0
		//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
		cCamposE5	:= Fa171CpSE5(lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)

		oModelMov := FWLoadModel("FINM030") //Recarrega o Model de movimentos para pegar o campo do relacionamento
		oModelMov:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
		oModelMov:Activate()
		oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou não
		oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
		oModelMov:SetValue( "MASTER", "NOVOPROC", .F. ) //Informa que a inclusão não será feita com um novo número de processo

		//Dados do Processo
		oSubFKA := oModelMov:GetModel("FKADETAIL")
		oSubFKA:SetValue( "FKA_IDORIG", FWUUIDV4() )
		oSubFKA:SetValue( "FKA_TABORI", "FK5" )

		//Informacoes do movimento
		oSubFK5 := oModelMov:GetModel( "FK5DETAIL" )
		If lEstorno
			oSubFK5:SetValue( "FK5_DATA", dDataBase )
			oSubFK5:SetValue( "FK5_RECPAG","R" )
			oSubFK5:SetValue( "FK5_DTDISP", dDataBase )
		Else
			oSubFK5:SetValue( "FK5_DATA", SEH->EH_DATA )
			oSubFK5:SetValue( "FK5_RECPAG","P" )
			If !Empty(SEH->EH_DSPREAD)
				oSubFK5:SetValue( "FK5_DTDISP", SEH->EH_DSPREAD )
			Else
				oSubFK5:SetValue( "FK5_DTDISP", dDataBase )
			Endif
		EndIf
		oSubFK5:SetValue( "FK5_BANCO", SEH->EH_BANCO )
		oSubFK5:SetValue( "FK5_AGENCI", SEH->EH_AGENCIA )
		oSubFK5:SetValue( "FK5_CONTA", SEH->EH_CONTA )
		oSubFK5:SetValue( "FK5_VALOR", nValor )
		If SEH->EH_MOEDA <> 1
			oSubFK5:SetValue( "FK5_VLMOE2", xMoeda( nValor, 1, SEH->EH_MOEDA ) )
		EndIf
		oSubFK5:SetValue( "FK5_TPDOC", "DB" )
		oSubFK5:SetValue( "FK5_HISTOR", cHistorico )
		oSubFK5:SetValue( "FK5_MOEDA", "01" )
		oSubFK5:SetValue( "FK5_FILORI", cFilAnt )
		oSubFK5:SetValue( "FK5_DOC", SEH->EH_NUMERO+SEH->EH_REVISAO )
		oSubFK5:SetValue( "FK5_ORIGEM", FunName() )
		If !lUsaFlag .and. ( lContabiliza .Or. lEstorno )
			oSubFK5:SetValue( "FK5_LA", "S" )
		Endif
		oSubFK5:SetValue( "FK5_NATURE", SEH->EH_NATUREZ )
		oSubFK5:SetValue( "FK5_CCUSTO", SEH->EH_CCUSTO)

		//Gravação da tabela FK8 - Dados Contábeis
		Fa171GrFK8(oModelMov,lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)

		If oModelMov:VldData()
			oModelMov:CommitData()
			oModelMov:DeActivate()
		Else
			lRet := .F.
			cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
			cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
			cLog += cValToChar(oModelMov:GetErrorMessage()[6])

			Help( ,,"MF171EXC",,cLog, 1, 0 )
		Endif

		If lRet
			cSinal	:= IIf(SE5->E5_RECPAG == "R", "+", "-")
			AtuSalBco( SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA, SE5->E5_DATA, SE5->E5_VALOR,cSinal)

			// Atualiza os saldos do fluxo de caixa por natureza financeira - AtuSldNat()
			If lAtuSldNat
				AtuSldNat(SE5->E5_NATUREZ, SE5->E5_DATA, SE5->E5_MOEDA, "3", "P", SEH->EH_DESPESA, 0, Iif(lEstorno,"-","+"),,FunName(),"SE5", SE5->(Recno()),0)
			EndIf
		Endif
	EndIf

Return lRet

/* {Protheus.doc} FC171VPAR
	Faz verificacao do numero de parcelas do contrato de emprestimo/Financiamento

	@author    Ronaldo Tapia
	@version   11.80
	@since     04/07/2016
	@protected
*/
Function FC171VPAR(nParceEmp As Numeric) As Logical
	Local lRet	As Logical

	Default nParceEmp := M->EH_PRAZO

	lRet := .T.
	//Validações do tamanho do campo E2_PARCELA
	If nParceEmp > __nMaxParc
		If !lF171Auto
			//###"O número de parcelas a serem geradas para o empréstimo não é suportado."###""Número máximo de parcelas permitido: "###" Para aumentar altere o grupo de campos PARCELA."###"Emprestimo Financeiro"
			HELP(' ',1,STR0017,,STR0081 + CRLF + STR0082 + CValToChar(__nMaxParc),2,0,,,,,,{STR0021})
		Else
			AutoGRLog(STR0020+STR(nMaxParc)+STR0021)
			lMsErroAuto := .T.
		Endif

		lRet := .F.
	Endif

	If lRet .and. !Empty(M->EH_PRAZO) .And. !Empty(M->EH_VLAMORP)
		If !lF171Auto
			MsgInfo(STR0022,STR0017) //"Se o valor de parcela/amortização estiver preenchido não é possível definir o campo Prazo!" //"Emprestimo Financeiro"
		Else
			AutoGRLog(STR0022)
		Endif

		lRet := .F.
	EndIf

Return lRet

/* {Protheus.doc} FC171VEnt
	Validação no valor da entrada (EH_ENTRADA)

	@author    Ronaldo Tapia
	@version   11.80
	@since     07/07/2016
	@protected
*/
Function FC171VEnt()

	//Validações do tamanho do campo EH_ENTRADA
	If M->EH_ENTRADA > M->EH_VALOR
		MsgInfo(STR0023,STR0017) //"Valor da entrada não pode ser maior que o valor da operação!" //"Emprestimo Financeiro"
	Endif

Return .T.

/* {Protheus.doc} FC171VAm
	Validação no valor da parcela/amortizacao (EH_PRAZO)

	@author    Ronaldo Tapia
	@version   11.80
	@since     07/07/2016
	@protected
*/
Function FC171VAm(nValAmor As Numeric)

	Default nValAmor := M->EH_VLAMORP

	//Validações do tamanho do campo EH_VLAMORP
	If !Empty(M->EH_VLAMORP) .And. !Empty(M->EH_PRAZO)
		MsgInfo(STR0024,STR0017) //"Se o Prazo estiver preenchido não é possível definir um valor de parcela/amortização!"  //"Emprestimo Financeiro"
		Return .F.
	EndIf

Return .T.

/*/{Protheus.doc} FCExcluiE2
	Função para exclusão dos titulos a pagar gerados pelo emprestimo
	@type  Static Function
	@author Vitor Duca
	@since 22/05/2024
	@version 1.0
/*/
Static Function FCExcluiE2()
	Local aArea		As Array
	Local cQuery	As Character
	Local cAliasTMP As Character
	Local aAreaSE2	As Array
	Local oExecQry	As Object

	aArea		:= GetArea()
	cQuery		:= ""
	cAliasTMP 	:= ""
	aAreaSE2	:= SE2->(getArea())

	cQuery := "SELECT R_E_C_N_O_ RECNOSE2 "
	cQuery += "FROM " + RetSqlName("SE2") + " "
	cQuery += "WHERE E2_FILIAL = ? "
	cQuery += "AND E2_PREFIXO = ? "
	cQuery += "AND E2_NUM = ? "
	cQuery += "AND E2_NATUREZ = ? "
	cQuery += "AND E2_ORIGEM IN ? "
	cQuery += "AND D_E_L_E_T_ = ? "

	oExecQry := FWExecStatement():New( ChangeQuery(cQuery) )

	oExecQry:SetString(1, xFilial("SE2"))
	oExecQry:SetString(2, SEH->EH_TIPO)
	oExecQry:SetString(3, SEH->EH_NUMERO)
	oExecQry:SetString(4, SEH->EH_NATUREZ)
	oExecQry:SetUnsafe(5, "('FINA171', 'FINA050')")
	oExecQry:SetString(6, " ")
	cAliasTMP := oExecQry:OpenAlias()

	While (cAliasTMP)->(!Eof())
		SE2->(dbGoto((cAliasTMP)->RECNOSE2))
		RecLock("SE2",.F.)
			SE2->(dbDelete())
		SE2->(MsUnLock())
		(cAliasTMP)->(DbSkip())
	End Do

	(cAliasTMP)->(dbCloseArea())

	RestArea(aAreaSE2)
	RestArea(aArea)
Return

/* {Protheus.doc} FCl171Emp
	Valicacao dos campos pertencentes a aplicacao

	@author    Ronaldo Tapia
	@version   11.80
	@since     19/07/2016
	@protected
*/
Function FCl171Emp() As Logical
	Local lRetorna	As Logical

	lRetorna := .F.
	If ( INCLUI .And. M->EH_APLEMP=="EMP" .And. M->EH_GERPARC == "1")
		lRetorna := .T.
	EndIf

Return( lRetorna )

/* {Protheus.doc} Fa171ETx
	Valicacao nos campos EH_NBANCO e EH_TAXA

	@author    Ronaldo Tapia
	@version   11.80
	@since     19/07/2016
	@protected
*/
Function Fa171ETx() As Logical
	Local lRetorna As Logical

	lRetorna := .F.

	If ( ALTERA .And. M->EH_APLEMP=="EMP" .And. M->EH_GERPARC == "1")
		lRetorna := .F.
	Else
		lRetorna := .T.
	EndIf

Return( lRetorna )

/*/{Protheus.doc} Fa171Idx()
	Função para cadastro dos índices que serão considerados para cálculo do
	rendimento da caderneta de poupança. (futuramente, para outras aplicações)

	@author Pedro Pereira Lima
	@since 17/12/2018
	@version 12.1.17
/*/
Function Fa171Idx()
	Local oBrowse	As Object

	Private cCadastro 	:= STR0119 //"Atual.Taxas dos índices"

	Private aRotina := {{ STR0001	,"AxPesqui"	, 0, 1, 0, .F.},;
						{ STR0002	,"AxVisual"	, 0, 2, 0, NIL},;
						{ STR0003	,"AxInclui"	, 0, 3, 0, NIL},;
						{ STR0004	,"AxAltera"	, 0, 4, 2, NIL},;
						{ STR0005	,"AxDeleta"	, 0, 5, 3, NIL}}

	oBrowse := FwMBrowse():New()
	oBrowse:SetAlias( 'FO3' )
	oBrowse:SetDescription( STR0066 )
	oBrowse:Activate()

Return

/*/{Protheus.doc} Fa171RetPc()
	Função de inicialização do campo FO3_PERC (Percentual da Meta Selic)

	@author Pedro Pereira Lima
	@since 21/12/2018
	@version 12.1.17
/*/
Function Fa171RetPc() As Numeric
	Local nPerc As Numeric

	nPerc := SuperGetMV( 'MV_PERCSLM', .F., 70 )

Return nPerc

/* {Protheus.doc} FinIniVar
	Inicia as varíaveis estáticas da rotina FINA171.
	@author    Simone Mie Sato Kakinoana
	@version   12.1.27
	@since     02/09/2020
*/
Static Function FinIniVar()

	If TYPE("lMovEnt05") == 'U' .or. lMovEnt05 == Nil
		lMovEnt05	:= CtbMovSaldo("CT0",,'05')
	EndIf

	If TYPE("lMovEnt06") == 'U' .or. lMovEnt06 == Nil
		lMovEnt06	:= CtbMovSaldo("CT0",,'06')
	EndIf

	If TYPE("lMovEnt07") == 'U' .or. lMovEnt07 == Nil
		lMovEnt07	:= CtbMovSaldo("CT0",,'07')
	EndIf

	If TYPE("lMovEnt08") == 'U' .or. lMovEnt08 == Nil
		lMovEnt08	:= CtbMovSaldo("CT0",,'08')
	EndIf

	If TYPE("lMovEnt09") == 'U' .or. lMovEnt09 == Nil
		lMovEnt09	:= CtbMovSaldo("CT0",,'09')
	EndIf

	If __nMaxParc == 0
		__nTamParc := TAMSX3("E2_PARCELA")[1]
		__cMaxParc := PADR("9",__nTamParc,"9")
		__nMaxParc := Val(__cMaxParc)	//Valor máximo de parcelas permitidos pelo tamanho do campo E2_PARCELA
		__nTamPraz := TamSx3("EH_PRAZO")[1]
		__nLastPar := Val(PADR("9",__nTamPraz,"9"))
	Endif
	__nOpcMVC := 0
	__cIdCtb := ""

Return

/* {Protheus.doc} Fa171CpSE5
	Atualiza cCamposE5 com os campos específicos da tabela SE5.
	@author    Simone Mie Sato Kakinoana
	@version   12.1.27
	@since     03/09/2020
*/
Function Fa171CpSE5(lMovEnt05 As Logical, lMovEnt06 As Logical, lMovEnt07 As Logical, lMovEnt08 As Logical, lMovEnt09 As Logical)
	Local cCamposE5	As Character

	DEFAULT lMovent05	:= .F.
	DEFAULT lMovent06	:= .F.
	DEFAULT lMovent07	:= .F.
	DEFAULT lMovent08	:= .F.
	DEFAULT lMovent09	:= .F.

	cCamposE5 := ""
	cCamposE5 += "{"
	cCamposE5 += "{'E5_DTDIGIT', dDataBase}"
	cCamposE5 += ",{'E5_DEBITO' , SEH->EH_DEBITO  }"
	cCamposE5 += ",{'E5_CREDITO', SEH->EH_CREDIT  }"
	cCamposE5 += ",{'E5_CCD'    , SEH->EH_CCD     }"
	cCamposE5 += ",{'E5_CCC'    , SEH->EH_CCC     }"
	cCamposE5 += ",{'E5_ITEMD'  , SEH->EH_ITEMD   }"
	cCamposE5 += ",{'E5_ITEMC'  , SEH->EH_ITEMC   }"
	cCamposE5 += ",{'E5_CLVLDB' , SEH->EH_CLVLDB  }"
	cCamposE5 += ",{'E5_CLVLCR' , SEH->EH_CLVLCR  }"
	cCamposE5 += ",{'E5_CCUSTO' , SEH->EH_CCUSTO  }"

	If lMovEnt05
		cCamposE5 += ",{'E5_EC05DB'  	, SEH->EH_EC05DB}"
		cCamposE5 += ",{'E5_EC05CR'  	, SEH->EH_EC05CR}"
	EndIf

	If lMovEnt06
		cCamposE5 += ",{'E5_EC06DB'  	, SEH->EH_EC06DB}"
		cCamposE5 += ",{'E5_EC06CR'  	, SEH->EH_EC06CR}"
	EndIf

	If lMovEnt07
		cCamposE5 += ",{'E5_EC07DB'  	, SEH->EH_EC07DB}"
		cCamposE5 += ",{'E5_EC07CR'  	, SEH->EH_EC07CR}"
	EndIf

	If lMovEnt08
		cCamposE5 += ",{'E5_EC08DB'  	, SEH->EH_EC08DB}"
		cCamposE5 += ",{'E5_EC08CR'  	, SEH->EH_EC08CR}"
	EndIf

	If lMovEnt09
		cCamposE5 += ",{'E5_EC09DB'  	, SEH->EH_EC09DB}"
		cCamposE5 += ",{'E5_EC09CR'  	, SEH->EH_EC09CR}"
	EndIf

	cCamposE5 += "}"

Return(cCamposE5)

/* {Protheus.doc} Fa171GrFK8
	Gravar tabela FK8 (Dados Contábeis)
	@author    Simone Mie Sato Kakinoana
	@version   12.1.27
	@since     03/09/2020
*/
Function Fa171GrFK8(oModelMov As Object, lMovEnt05 As Logical, lMovEnt06 As Logical, lMovEnt07 As Logical, lMovEnt08 As Logical, lMovEnt09 As Logical)
	Local oSubFK8	As Object

	DEFAULT lMovent05	:= .F.
	DEFAULT lMovent06	:= .F.
	DEFAULT lMovent07	:= .F.
	DEFAULT lMovent08	:= .F.
	DEFAULT lMovent09	:= .F.

	oSubFK8 := oModelMov:GetModel("FK8DETAIL")
	oSubFK8:SetValue( "FK8_DEBITO", SEH->EH_DEBITO )
	oSubFK8:SetValue( "FK8_CREDIT", SEH->EH_CREDIT )
	oSubFK8:SetValue( "FK8_CCD", SEH->EH_CCD )
	oSubFK8:SetValue( "FK8_CCC", SEH->EH_CCC )
	oSubFK8:SetValue( "FK8_ITEMD", SEH->EH_ITEMD )
	oSubFK8:SetValue( "FK8_ITEMC", SEH->EH_ITEMC )
	oSubFK8:SetValue( "FK8_CLVLDB", SEH->EH_CLVLDB )
	oSubFK8:SetValue( "FK8_CLVLCR", SEH->EH_CLVLCR )

	If lMovEnt05
		oSubFK8:SetValue( "FK8_EC05DB", SEH->EH_EC05DB)
		oSubFK8:SetValue( "FK8_EC05CR", SEH->EH_EC05CR)
	EndIf

	If lMovEnt06
		oSubFK8:SetValue( "FK8_EC06DB", SEH->EH_EC06DB)
		oSubFK8:SetValue( "FK8_EC06CR", SEH->EH_EC06CR)
	EndIf

	If lMovEnt07
		oSubFK8:SetValue( "FK8_EC07DB", SEH->EH_EC07DB)
		oSubFK8:SetValue( "FK8_EC07CR", SEH->EH_EC07CR)
	EndIf

	If lMovEnt08
		oSubFK8:SetValue( "FK8_EC08DB", SEH->EH_EC08DB)
		oSubFK8:SetValue( "FK8_EC08CR", SEH->EH_EC08CR)
	EndIf

	If lMovEnt09
		oSubFK8:SetValue( "FK8_EC09DB", SEH->EH_EC09DB)
		oSubFK8:SetValue( "FK8_EC09CR", SEH->EH_EC09CR)
	EndIf

Return

/* {Protheus.doc} A171Banco
	Gatilha dados bancários
	@author    Jose Gavetti
	@version   12.1.27
	@since     12/05/2021
*/
Function A171Banco() As Logical
	Local nPos 		As Numeric
	Local lRet 		As Logical
	Local lExecAut 	As Logical
	Local jModView 	As Json
	Local oSubSEH 	As Object

	nPos 	 := 0
	lRet	 := .T.
	lExecAut := .F.
	oSubSEH	 := Nil

	If Type("lF171Auto") <> "U"
		lExecAut := lF171Auto
	Endif

	If lExecAut .And. Len(aAutoCab) > 0 .And. Len(aAutoCab[1]) > 1 .And. ValType(aAutoCab[1][2]) == "A"
		If (nPos := aScan(aAutoCab[1][2], { |x| x[1] == "EH_AGENCIA" })) > 0
			M->EH_AGENCIA := aAutoCab[1][2][nPos][2]
		EndIf

		If (nPos := aScan(aAutoCab[1][2], { |x| x[1] == "EH_CONTA" })) > 0
			M->EH_CONTA := aAutoCab[1][2][nPos][2]
		EndIf
	EndIf

	If !lExecAut
		jModView := JsonObject():New()
		jModView := FnGetModel()
		oSubSEH  := jModView["model"]:GetModel("SEHMASTER")
	EndIf

	If !FwIsInCallStack("CONPAD1") .And. SA6->((DbSeek(xfilial("SA6") + M->EH_BANCO)))
		If __cBanco <> M->EH_BANCO .Or. (Empty(M->EH_AGENCIA) .And. Empty(M->EH_CONTA)) // Validação do código bancário.
			If !Empty(M->EH_AGENCIA) .and. !Empty(M->EH_CONTA) .and. SA6->((DbSeek(xfilial("SA6")+ M->EH_BANCO + M->EH_AGENCIA + M->EH_CONTA)))
				M->EH_NBANCO  := SubStr(SA6->A6_NOME, 1, TamSx3("EH_NBANCO")[1])
			ElseiF SA6->((DbSeek(xfilial("SA6") + M->EH_BANCO)))
				M->EH_AGENCIA := SA6->A6_AGENCIA
				M->EH_CONTA	  := SA6->A6_NUMCON
				M->EH_NBANCO  := SubStr(SA6->A6_NOME, 1, TamSx3("EH_NBANCO")[1])
			Endif
		ElseIF __cAgBco <> M->EH_AGENCIA .and. SA6->((DbSeek(xfilial("SA6")+ M->EH_BANCO + M->EH_AGENCIA)))//Validação da Agência bancária.
			M->EH_AGENCIA := SA6->A6_AGENCIA
			M->EH_CONTA	  := SA6->A6_NUMCON
			M->EH_NBANCO  := SubStr(SA6->A6_NOME, 1, TamSx3("EH_NBANCO")[1])
		ElseIF __cCntBco <> M->EH_CONTA .and. SA6->((DbSeek(xfilial("SA6")+ M->EH_BANCO + M->EH_AGENCIA + M->EH_CONTA)))//Validação da Conta bancária.
			M->EH_CONTA	  := SA6->A6_NUMCON
			M->EH_NBANCO  := SubStr(SA6->A6_NOME, 1, TamSx3("EH_NBANCO")[1])
		Endif
	EndIf

	__cBanco	:=  M->EH_BANCO
	__cAgBco	:=  M->EH_AGENCIA
	__cCntBco	:=  M->EH_CONTA
	__cNomeBco	:=  M->EH_NBANCO

	lRet := SA6->((DbSeek(xfilial("SA6") + M->EH_BANCO + M->EH_AGENCIA + M->EH_CONTA)))

	If lRet .And. !lExecAut
		oSubSEH:LoadValue("EH_BANCO", 	__cBanco)
		oSubSEH:LoadValue("EH_AGENCIA", __cAgBco)
		oSubSEH:LoadValue("EH_CONTA", 	__cCntBco)
		oSubSEH:LoadValue("EH_NBANCO", 	__cNomeBco)
	EndIf

Return lRet

/*/{Protheus.doc} F171PerAut
	Altera os perguntes da rotina, para execuções automaticas
	@type  Static Function
	@author Vitor Duca
	@since 16/11/2021
	@version 1.0
	@param aParam, Array, Matriz contendo a ordem do SX1 e seu conteudo
/*/
Static Function F171PerAut(aParam As Array)
	Local nX As Numeric
	Local cVarParam As Character

	nX := 0
	cVarParam := ""

	For nX := 1 to Len(aParam)
		cVarParam := Alltrim(Upper(aParam[nX][1]))
		If "MV_PAR" $ cVarParam
			&(cVarParam) := aParam[nX][2]
		EndIf
	Next nX

Return

/*/{Protheus.doc} Fa171Pre
	Pré validação do modelo
	@type  Function
	@author Vitor Duca
	@since 20/05/2024
	@version 1.0
	@param oModel, Object, Modelo de dados da rotina que será pre validado
	@return return_var, return_type, return_description
/*/
Function Fa171Pre(oModel As Object) As Logical
	Local nOperation	As Numeric
	Local lOk			As Logical

	lOk 		:= .T.
	nOperation 	:= oModel:GetOperation()

	If (lOk := DtMovFin())
		If nOperation == MODEL_OPERATION_UPDATE
			lOk := SEH->EH_SALDO != 0
		Endif
	Endif

	If lOk
		PcoIniLan("000008")
	Endif
Return lOk

/*/{Protheus.doc} TemResgate
	Verifica se o contrato em questão possui pagamento\resgate
	@type  Static Function
	@author Vitor Duca
	@since 20/05/2024
	@version 1.0
	@return lTemResgate, Logical, Contrato possui resgate
/*/
Static Function TemResgate() As Logical
	Local lTemResgate As Logical

	If SEH->EH_TIPO $ GetMv("MV_APLCAL4")
		lTemResgate := SEH->EH_SLDCOTA <> SEH->EH_QUOTAS
		If lTemResgate .And. Empty( SEH->EH_SLDCOTA ) .And. SEH->EH_SALDO > 0
			lTemResgate := SEH->EH_SALDO <> SEH->EH_QUOTAS
		EndIf
	Else
		lTemResgate := Round(SEH->EH_SALDO, TamSx3('EH_VALOR')[2]) <> SEH->EH_VALOR
	EndIf

	// Verifica se emprestimo teve algum valor de entrada
	If SEH->EH_SALDO == SEH->EH_FINANC .And. !Empty(SEH->EH_ENTRADA)
		lTemResgate := .F.
	EndIf

Return lTemResgate

/*/{Protheus.doc} Fc171Recal
	Função de recalculo das parcelas na alteração do vencimento/juros
	@type  Function
	@author Vitor Duca
	@since 26/05/2024
	@version 1.0
	@param param_name, param_type, param_descr
	@return .T. ou .F., Logical, Define se o recalculo aconteceu com sucesso
/*/
Function Fc171Recal() As Logical
	Local oView		As Object
	Local oModel	As Object
	Local oSubSE2	As Object
	Local oMstSEH	As Object
	Local jCampos	As Json
	Local aCampos	As Array
	Local nX		As Numeric
	Local nLinhaPos	As Numeric
	Local jParcelas	As Json
	Local jModView	As Json

	If !lF171Auto
		aCampos := {;
			'eh_tipo',;
			'eh_formula',;
			'eh_moeda',;
			'eh_taxa',;
			'eh_carenci',;
			'eh_jurcar';
		}

		jModView	:= FnGetModel()
		oView    	:= jModView["view"]
		oModel   	:= jModView["model"]
		oSubSE2		:= oModel:GetModel("SE2DETAIL")
		oMstSEH		:= oModel:GetModel("SEHMASTER")
		nLinhaPos	:= oSubSE2:getLine()
		jCampos		:= JsonObject():new()
		nX			:= 0
		jParcelas	:= JsonObject():new()

		jCampos["contrato"] := JsonObject():new()

		For nX := 1 to Len(aCampos)
			jCampos["contrato"][aCampos[nX]] := oMstSEH:getValue(Upper(aCampos[nX]))
		Next nX

		jCampos["contrato"]["parcela"] := JsonObject():new()

		jCampos["contrato"]["parcela"]["parcela"] := Val(oSubSE2:getValue("PARCELA"))
		jCampos["contrato"]["parcela"]["datax"] := Dtos(oSubSE2:getValue("VENCTO"))
		jCampos["contrato"]["parcela"]["valor_value"] := oSubSE2:getValue("VALOR")
		jCampos["contrato"]["parcela"]["vcorrigido_value"] := oSubSE2:getValue("VCORRIGIDO")
		jCampos["contrato"]["parcela"]["amortiza_value"] := oSubSE2:getValue("AMORTIZA")
		jCampos["contrato"]["parcela"]["prestacao_value"] := oSubSE2:getValue("PRESTACAO")
		jCampos["contrato"]["parcela"]["data_base"] := Dtos(oMstSEH:getValue("EH_DATA"))

		If nLinhaPos > 1
			oSubSE2:GoLine(nLinhaPos - 1)
			jCampos["contrato"]["parcela"]["data_base"] := Dtos(oSubSE2:getValue("VENCTO"))
		Endif

		If jCampos["contrato"]["parcela"]["datax"] < jCampos["contrato"]["parcela"]["data_base"]
			FWAlertError(STR0113, STR0114) //"Informe uma data válida para recalcular a parcela" # "Data inválida"
			Return .F.
		Endif

		oSubSE2:GoLine(nLinhaPos)

		F171SetTpl(@jCampos["contrato"])

		jParcelas := recalculateSAC(jCampos)

		If jParcelas["result"]
			oSubSE2:LoadValue("VALOR", jParcelas["response"]["items"][1]["valor_value"])
			oSubSE2:LoadValue("JUROS", jParcelas["response"]["items"][1]["juros_value"])
			oSubSE2:LoadValue("VCORRIGIDO", jParcelas["response"]["items"][1]["vcorrigido_value"])
			oSubSE2:LoadValue("AMORTIZA", jParcelas["response"]["items"][1]["amortiza_value"])
			oSubSE2:LoadValue("PRESTACAO", jParcelas["response"]["items"][1]["prestacao_value"])
		Endif

		oView:Refresh()
	Endif
Return .T.

/*/{Protheus.doc} F171AltJur
	Realiza o ajuste nos valores conforme alteração no valor de juros
	@type  Function
	@author Vitor Duca
	@since 25/06/2024
	@version 1.0
/*/
Function F171AltJur() As Logical
	Local oView		As Object
	Local oModel	As Object
	Local oSubSE2	As Object
	Local jModView	As Json

	If !lF171Auto

		jModView	:= FnGetModel()
		oView    	:= jModView["view"]
		oModel   	:= jModView["model"]
		oSubSE2		:= oModel:GetModel("SE2DETAIL")

		oSubSE2:LoadValue("VCORRIGIDO", oSubSE2:getValue("VALOR") + oSubSE2:getValue("JUROS"))
		oSubSE2:LoadValue("PRESTACAO", oSubSE2:getValue("AMORTIZA") + oSubSE2:getValue("JUROS"))

		oView:Refresh()
	Endif
Return .T.

/*/{Protheus.doc} f171AltAmo
	Realiza o ajuste nos valores conforme alteração no valor de Amortizacao.
	@type  Function
	@author Vinicius do Prado
	@since 18/11/2024
	@version 1.0
/*/
Function f171AltAmo() As Logical
	Local oView			As Object
	Local oModel		As Object
	Local oSubSE2		As Object
	Local jModView		As Json
	Local nLinesTot		As Numeric
	Local nLine			As Numeric
	Local nCurrLine		As Numeric
	Local nVlDebAnt 	As Numeric
	Local nVlAmorAnt 	As Numeric
	Local nValAmor		As Numeric
	Local nValJur		As Numeric
	Local nValDeb		As Numeric

	If !lF171Auto

		jModView	:= FnGetModel()
		oView    	:= jModView["view"]
		oModel   	:= jModView["model"]
		oSubSE2		:= oModel:GetModel("SE2DETAIL")
		nLinesTot	:= oSubSE2:Length()
		nVlDebAnt	:= 0
		nVlAmorAnt	:= 0
		nValAmor	:= oSubSE2:getValue("AMORTIZA")
		nValJur		:= oSubSE2:getValue("JUROS")
		nValDeb		:= oSubSE2:getValue("VALOR")
		nCurrLine	:= oSubSE2:getLine()

		oSubSE2:LoadValue("VCORRIGIDO", nValDeb + nValJur)
		oSubSE2:LoadValue("PRESTACAO", nValAmor + nValJur)

		// Atualiza o valor de debitos das parcelas.
		For nLine := 1 to nLinesTot
			oSubSE2:GoLine(nLine)

			If nLine > 1
				oSubSE2:LoadValue("VALOR", nVlDebAnt - nVlAmorAnt)
			EndIf

			nVlDebAnt 	:= oSubSE2:getValue("VALOR")
			nVlAmorAnt 	:= oSubSE2:getValue("AMORTIZA")
		Next nLine

		oSubSE2:GoLine(nCurrLine)
		oView:Refresh()
	Endif
Return .T.

/*/{Protheus.doc} F171WhAltP
	Valida When do campo juros na projeção das parcelas
	@type  Function
	@author Vitor Duca
	@since 27/06/2024
	@version 1.0
	@return lRet, logical, Se pode alterar o valor de juros na geração das parcelas
/*/
Function F171WhAltP() As Logical
Return lF171Auto .Or. __lSwitch

/*/{Protheus.doc} F171VlGerP
	Validacao do campo gera parcela. EH_GERPARC.
	@type  Function
	@author Vinicius do Prado
	@since 16/06/2025
	@version 1.0
	@return lRet, logical, Valida se é o valor do campos é valido.
/*/
Function F171VlGerP(oModel As Object) As Logical
	Local lRet		As Logical
	Local oSubMod	As Object

	lRet	:= .F.
	oSubMod	:= oModel:GetModel("SEHMASTER")
	If oSubMod <> Nil
		lRet	:= oSubMod:GetValue('EH_APLEMP') == 'EMP' .And. (oSubMod:GetValue('EH_TIPO') == 'EMP' .Or. oSubMod:GetValue('EH_TIPO') == 'TEM')
	EndIf
Return lRet

/*/{Protheus.doc} F171DelTmp
	Realiza o delete da tabela temporaria criada no banco de dados
	@type  Function
	@author Vitor Duca
	@since 27/05/2024
	@version 1.0
/*/
Function F171DelTmp()
	If _oFINA171 <> NIL
		_oFINA171:Delete()
		_oFINA171 := Nil
	Endif
Return

/*/{Protheus.doc} FnGetModel
	Retorna o objeto do model e view que estão ativos no momento
	@type  Static Function
	@author Vitor Duca
	@since 29/05/2024
	@version 1.0
	@return jModView, Json, FwViewActive e model contendo as informações ativas no momento
/*/
Static Function FnGetModel() As Json
	Local jModView	As Json

	jModView := JsonObject():new()
	jModView["view"]	:= FwViewActive()
	jModView["model"]   := jModView["view"]:GetModel()

Return jModView

/*/{Protheus.doc} FnGetMoeda
	Recupera a moeda informada no MV
	@type  Static Function
	@author Vitor Duca
	@since 29/05/2024
	@version 1.0
	@param cMoeda, Character, Codigo da moeda que sera validada
	@return SuperGetMV( "MV_MOEDA" + cMoeda, .F., "" ), Character, Conteudo do parametro MV_MOEDA
/*/
Static Function FnGetMoeda(cMoeda As Character) As Character
	Default cMoeda := ""
Return SuperGetMV( "MV_MOEDA" + cMoeda, .F., "" )

/*/{Protheus.doc} F171SetTpl
	Seta o campo do template EH_TEMPLT em formato json na estrutura json
	passada por parametro
	@type  Static Function
	@author Vitor Duca
	@since 21/06/2024
	@version 1.0
	@param jCampos, Json, Json contendo os campos que serão enviados no calculo (Passado por referencia)
/*/
Static Function F171SetTpl(jCampos As Json)
	If !Empty(M->EH_TEMPLT)
		jCampos["eh_templt"] := JsonObject():new()
		jCampos["eh_templt"]:FromJson(M->EH_TEMPLT)
	Endif
Return

/*/{Protheus.doc} Fa171PerPl
	Função responsável pelo When do campo EH_PERCPLP
	@type  Static Function
	@author Rodrigo Oliveira
	@since 05/11/2024
	@version 1.0
	@param lRet, Logical, retorna a informação se o campo estará editável ou não
/*/
Function Fa171PerPl(oModel As Object) As Logical
	Local lRet		As Logical
	Local oSubMod	As Object

	lRet	:= .F.
	oSubMod	:= oModel:GetModel("SEHMASTER")
	lRet	:= oModel:GetOperation() == MODEL_OPERATION_INSERT .And. !(oSubMod:GetValue('EH_GERPARC') == '1')

Return lRet

/*/{Protheus.doc} F171ModVlr
	Função responsável ajustar valores no model SEH antes do commit.
	@type  Static Function
	@author Vinicius do Prado
	@since 18/11/2024
	@version 1.0
	@param oModel, Object, modelo e dados.
/*/
Function F171ModVlr(oModel As Object)
	Local oSubSEH	As Object
	Local oSubCalc	As Object

	oSubSEH		:= oModel:GetModel("SEHMASTER")
	oSubCalc	:= oModel:GetModel("CALCPARC")

	// Replica o valor do campo AUTCUSTOMVLR para  o campo da SEH

	If SEH->(FieldPos("EH_CALCUSR")) > 0 .AND. oSubCalc <> Nil
		oSubSEH:LoadValue("EH_CALCUSR", oSubCalc:GetValue('AUTCUSTOMVLR'))
	Endif

	// Limpa os valores dos campos quando alterado GERAPARC
	If oSubSEH:getValue('EH_GERPARC') == '2'
		oSubSEH:LoadValue("EH_AMORTIZ", '')
		oSubSEH:LoadValue("EH_SPREAD", 0)
		oSubSEH:LoadValue("EH_DESPESA", 0)
		oSubSEH:LoadValue("EH_VLAMORP", 0)
		oSubSEH:LoadValue("EH_PRAZO", 0)
		oSubSEH:LoadValue("EH_CARENCI", 0)
		oSubSEH:LoadValue("EH_JURCAR", '')
		oSubSEH:LoadValue("EH_PSPREAD", 0)
	EndIf
Return Nil


/*/{Protheus.doc} F171CstVlr
	Função responsável pela validacao do campos AUTCUSTOMVLR.
	@type  Static Function
	@author Vinicius do Prado
	@since 18/11/2024
	@version 1.0
/*/
Function F171CstVlr()
	Local oSubMod	As Object
	Local oSubSE2	As Object
	Local oView		As Object
	Local oModel	As Object
	Local jModView	As Json

	If !lF171Auto
		jModView	:= FnGetModel()
		oView    	:= jModView["view"]
		oModel		:= jModView["model"]
		oSubMod		:= oModel:GetModel("CALCPARC")
		oSubSE2		:= oModel:GetModel("SE2DETAIL")
		__lSwitch 	:= oSubMod:getValue('AUTCUSTOMVLR') == '1'

		If !__lSwitch
			FC171Par()
		EndIf

		oView:Refresh()
	EndIf
Return .T.

/*/{Protheus.doc} F171VldTip
	Função responsável pela validacao do tipo do contrato de acordo com o campo EH_APLEMP.
	@type  Static Function
	@author Vinicius do Prado
	@since 26/11/2024
	@version 1.0
	@param cAplEmp, Character, informa se o contrato é de APL ou EMP.
	@param cType, Character, tipo de contrato.
/*/
Static Function F171VldTip(cAplEmp as Character, cType as Character) As Logical
	Local lRet 		:= .T. 	As Logical
	Local cTypesSX6 := '' 	As Character

	cTypesSX6 := SuperGetMV("MV_EMPCAL1",.F.,"") + "|"
	cTypesSX6 += SuperGetMV("MV_EMPCAL2",.F.,"") + "|"
	cTypesSX6 += SuperGetMV("MV_EMPCAL3",.F.,"") + "|"
	cTypesSX6 += SuperGetMV("MV_EMPCAL4",.F.,"")

	If cAplEmp == 'APL'
		cTypesSX6 := SuperGetMV("MV_APLCAL1",.F.,"") + "|"
		cTypesSX6 += SuperGetMV("MV_APLCAL2",.F.,"") + "|"
		cTypesSX6 += SuperGetMV("MV_APLCAL3",.F.,"") + "|"
		cTypesSX6 += SuperGetMV("MV_APLCAL4",.F.,"") + "|"
		cTypesSX6 += SuperGetMV("MV_APLCAL5",.F.,"")
	Endif

	lRet := cType $ cTypesSX6
	
Return lRet

/*/{Protheus.doc} F171OrdCab
	Ajuste de ordenação do array da execauto, garantindo que os campos EH_CONTRAT, EH_BCOCONT
	EH_AGECONT e EH_CTACONT sejam executados em seguida, pois, o campo EH_QUOTAS possui um gatilho que limpa
	o EH_CONTRAT
	@type  Static Function
	@author user
	@since 29/04/2025
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
/*/
Static Function F171OrdCab()
	Local aAuxCmp	as Array
	Local nX		as Numeric
	Local cCmpSkip	as Character

	aAuxCmp := aClone(aAutoCab[1][2])
	aAutoCab[1][2] := {}
	nX := 0
	cCmpSkip := "EH_AGECONT|EH_BCOCONT|EH_CTACONT|EH_CONTRAT|EH_PRAZO|EH_AMORTIZ|EH_SALDO|EH_VLCRUZ|EH_SPREAD|EH_DESPESA|EH_VLAMORP"
	cCmpSkip += "|EH_CARENCI|EH_JURCAR|EH_PSPREAD|EH_FINANC|EH_VLRCOTA|EH_DSPREAD"

	If aScan(aAuxCmp,{|x| x[1] == "EH_QUOTAS"}) == 0 .And. aScan(aAuxCmp,{|x| x[1] == "EH_CONTRAT"}) > 0
		Aadd(aAuxCmp, {"EH_QUOTAS", 0, NIL})
	Endif

	If (nPos := aScan(aAuxCmp, {|x| x[1] == "EH_GERPARC"})) > 0 .and. aAuxCmp[nPos][2] == "2" .and. Len(aAutoCab) > 1
		aAutoCab := {}
		Aadd(aAutoCab, {"SEHMASTER", {}})
	Endif

	For nX := 1 to Len(aAuxCmp)
		Do Case
			Case aAuxCmp[nX][1] == "EH_QUOTAS"
				Aadd(aAutoCab[1][2], aAuxCmp[nX])
				If (nPos := aScan(aAuxCmp,{|x| x[1] == "EH_CONTRAT"})) > 0
					Aadd(aAutoCab[1][2], aAuxCmp[nPos])
				EndIf
				If (nPos := aScan(aAuxCmp,{|x| x[1] == "EH_BCOCONT"})) > 0
					Aadd(aAutoCab[1][2], aAuxCmp[nPos])
				EndIf
				If (nPos := aScan(aAuxCmp,{|x| x[1] == "EH_AGECONT"})) > 0
					Aadd(aAutoCab[1][2], aAuxCmp[nPos])
				EndIf
				If (nPos := aScan(aAuxCmp,{|x| x[1] == "EH_CTACONT"})) > 0
					Aadd(aAutoCab[1][2], aAuxCmp[nPos])
				EndIf
			Case aAuxCmp[nX][1] == "EH_GERPARC"
				Aadd(aAutoCab[1][2], aAuxCmp[nX])
				If aAuxCmp[nX][2] == "1"
					If (nPos := aScan(aAuxCmp,{|x| x[1] == "EH_AMORTIZ"})) > 0
						Aadd(aAutoCab[1][2], aAuxCmp[nPos])
					EndIf

					If (nPos := aScan(aAuxCmp,{|x| x[1] == "EH_PRAZO"})) > 0
						Aadd(aAutoCab[1][2], aAuxCmp[nPos])
					EndIf

					If (nPos := aScan(aAuxCmp,{|x| x[1] == "EH_SPREAD"})) > 0
						Aadd(aAutoCab[1][2], aAuxCmp[nPos])
					EndIf

					If (nPos := aScan(aAuxCmp,{|x| x[1] == "EH_DESPESA"})) > 0
						Aadd(aAutoCab[1][2], aAuxCmp[nPos])
					EndIf

					If (nPos := aScan(aAuxCmp,{|x| x[1] == "EH_VLAMORP"})) > 0
						Aadd(aAutoCab[1][2], aAuxCmp[nPos])
					EndIf

					If (nPos := aScan(aAuxCmp,{|x| x[1] == "EH_CARENCI"})) > 0
						Aadd(aAutoCab[1][2], aAuxCmp[nPos])
					EndIf

					If (nPos := aScan(aAuxCmp,{|x| x[1] == "EH_JURCAR"})) > 0
						Aadd(aAutoCab[1][2], aAuxCmp[nPos])
					EndIf

					If (nPos := aScan(aAuxCmp,{|x| x[1] == "EH_PSPREAD"})) > 0
						Aadd(aAutoCab[1][2], aAuxCmp[nPos])
					EndIf

					If (nPos := aScan(aAuxCmp,{|x| x[1] == "EH_DSPREAD"})) > 0
						Aadd(aAutoCab[1][2], aAuxCmp[nPos])
					EndIf
				Endif
			Case aAuxCmp[nX][1] $ cCmpSkip
				Loop
			OtherWise
				Aadd(aAutoCab[1][2], aAuxCmp[nX])
		EndCase
	Next nX
Return

/*/{Protheus.doc} F171PrVenc
	Validação do campo primeiro vencimento
	@type  Static Function
	@author Vitor Duca
	@since 06/08/2025
	@version 1.0
	@param lRet, Logical, retorna a informação se o valor do campo é valido
/*/
Function F171PrVenc() As Logical
	Local lRet		As Logical
	Local oSubMod	As Object
	Local oSubCalc	As Object
	Local oModel	As Object
	Local jModView	As Json

	lRet := .T.

	If !lF171Auto
		jModView	:= FnGetModel()
		oModel		:= jModView["model"]
		oSubMod		:= oModel:GetModel("SEHMASTER")
		oSubCalc	:= oModel:GetModel("CALCPARC")
		lRet		:= oSubMod:GetValue('EH_DATA') <= oSubCalc:getValue('dataPrimeiroVencimento')
	EndIf

Return lRet
