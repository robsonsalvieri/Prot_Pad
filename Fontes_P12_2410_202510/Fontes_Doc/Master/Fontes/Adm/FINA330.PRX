#INCLUDE "FINA330.CH"
#INCLUDE "PROTHEUS.CH"
#Include "FWMVCDEF.CH"
#INCLUDE "FWLIBVERSION.CH"

Static __PesqList
Static aRLocks
Static l330Auto  	:= .F.
Static __lDizPer	:= .F.
Static lFWCodFil 	:= .T.
Static __lCredNCC	:= .F.
Static __cRmProd	:= Nil
Static lRatFields
Static dLastPcc  	:= CTOD("22/06/2015")
Static nReg330 		:= 20
Static _oFina3301
Static __nTamPref	:= Nil
Static __nTamNum	:= Nil
Static __nTamParc	:= Nil
Static __nTamTipo	:= Nil
Static __nTamLoja	:= Nil
Static __nTamSeq	:= Nil
Static __nTamFil	:= Nil
Static __nTamPrf	:= Nil
Static __nTamSOri	:= Nil
Static __nTamE2Pr	:= Nil
Static __nTamValM	:= Nil	
Static __nTxMoedP 	:= 0 //Taxa de partida da compensação - Deve conter a taxa do título que partiu a compensação
Static __nTxMoedD	:= 0 //Taxa do título destino
Static __lTxConP	:= .F. // Indica se o título de partida possui taxa contratada
Static __nTxTiBrw 	:= 0
Static __nTxContr 	:= 0
Static __lCmTxCon 	:= .T.
Static __lCalcCM  	:= .T.
Static __nCasDec  	:= 2
Static __nPosTit  	:= 0
Static __lTxMoed  	:= .F.
Static __lNoTxMov 	:= .F.
Static __oMovRA   	:= Nil
Static __oMovCnb  	:= Nil
Static __aTxMoed0 	:= {}
Static __aTitCalc 	:= {}
Static __cFk1IdOri 	:= ""
Static __nProp		:= 0
Static __cPiE1Sld   := ""
Static __cToler		:= ""
Static __lMotRet 	:= .F.
Static __lImpMR 	:= .F.
Static __lImpBxMR
Static __lPccMR 	:= .F.
Static __lPccBxMR 	:= .F.
Static __lRaRtPcc 	:= .F.
Static __lIrfMR 	:= .F.
Static __lIrfBxMR 	:= .F.
Static __lRaRtIrf 	:= .F.
Static __lIssMR 	:= .F.
Static __lIssBxMR 	:= .F.
Static __lRaRtIss 	:= .F.
Static __aImpos 	:= {}
Static __aOutImp 	:= {}
Static __nPisCaMR 	:= 0
Static __nCofCaMR 	:= 0
Static __nCslCaMR 	:= 0
Static __nIrfCaMR 	:= 0
Static __nIssCaMR 	:= 0
Static __nImpMR		:= 0
Static __cOldMRCf 	:= ""
Static __cOldMRCl 	:= ""
Static __nBaseMR	:= 0
Static __lImpEmis	:= .F.
Static __nImpEst	:= 0
Static __aImpAnt	:= {}
Static __oHshTMrk
Static __aHshTMrk
Static __oHNatPCC	:= Nil
Static __aNatPCC	:= Nil
Static __lTCnfgMR	:= .F.
Static __l330Va		:= .F.
Static __lRaTxMov	:= .T.
Static __lPIXCanc   := NIL
Static __cIdFk4IR   := ""
Static __lMetric	:= .F.
Static __cFunBkp    := ""
Static __cFunMet	:= ""
Static __lBq10925	:= Nil
Static __nSldConv	:= 0
Static __nTotCtb	:= 0
Static __lCmpM460	:= .F.
Static __lGetParA 	:= .F.
Static __oPccBsRt	:= NIL
Static __lExcImpo   := Nil
Static __lCNABImp   := Nil
Static __TpGerPix   := .T.
Static __lNExbMsg	:= .F.
Static __lMaTiPix   := .F.
Static __nValVa		:= 0
Static __nMoedSA6	:= 0
Static __lNTitFIE	:= .F.
Static __cRelease	As Character
Static __cCompSE1	As Character
Static __lUsaFil 	As Logical
Static __aFil330	As Array
Static __nQtdTitu   As Numeric
Static __lTPIConf	As Logical
Static __nFINPIX9   As Numeric
Static __lAltPix    As Logical
Static __aRecF71    As Array
Static __lMVGlosa   As Logical
Static __lCachQry   As Logical
Static __oImposto   As Object
Static __QryFk1     As Object 
Static __QryFk7     As Object
Static __oPrepCP	As Object
Static __oQryFKQ	As Object
Static __lNumBor 	As Logical
Static __nRecPart   As Numeric
Static __nMoePart   As Numeric
Static __nMovRA 	As Numeric
Static __nMovNF 	As Numeric
Static __lCalcImp	As Logical
Static __lLoaded    := IniStatic() //Deve ser sempre a última variável estática declarada

//-----------------------------------------------
/*/{Protheus.doc} IniStatic
	Inicialização das variaveis estáticas de dicionário de dados

	@author  Vinicius Nascimento
	@since   15/07/2022
	@version 12.1.33
/*/
//-----------------------------------------------

Static Function IniStatic()
	Default __lLoaded := .F.

	If Select("SX3") > 0 .and. !__lLoaded

		Default __nTamPref	:= TamSX3("E1_PREFIXO")[1]
		Default __nTamNum	:= TamSX3("E1_NUM")[1]
		Default __nTamParc	:= TamSX3("E1_PARCELA")[1]
		Default __nTamTipo	:= TamSX3("E1_TIPO")[1]
		Default __nTamLoja	:= TamSX3("E1_LOJA")[1]
		Default __nTamSeq	:= TamSX3("E5_SEQ")[1]
		Default __nTamFil	:= TamSX3("E2_FILIAL")[1]
		Default __nTamPrf	:= TamSX3("E5_PREFIXO")[1] //O campo E5_PREFIXO não está no mesmo grupo de campos do campo E1_PREFIXO, por isso mantive esse esse campo no TamSX3
		Default __nTamSOri	:= TamSX3("FQ_SEQORI")[1]
		Default __nTamE2Pr	:= TamSX3("E2_PREFIXO")[1] //O campo E2_PREFIXO não está no mesmo grupo de campos do campo E1_PREFIXO, por isso mantive esse esse campo no TamSX3
		Default __nTamValM	:= TamSX3("FK6_VALMOV")[2]

		Default __cRelease := getRPORelease()

		Default __cCompSE1 := getComp("SE1")

		__nMovRA := 0
		__nMovNF := 0
		__lCalcImp := .T.	
		__lLoaded := .T.
	EndIf 

Return __lLoaded

//------------------------------------
/*/{Protheus.doc}Fina330
Compensação entre títulos e adiantamentos

@author Mauricio Pequim Jr
@since  22/09/97
@version 8
/*/
//------------------------------------
Function Fina330(nPosArotina, lExecAuto, aRetXAPI, lAutMrkPix, aFil330 As Array)
	Local nSavRec	:= Recno()
	Local cBrwExp	:= NIL
	Local cMoedaTx  := ""
	Local nA        := 0
	Local nVlMoeda  := 0
	Local cDescMoed := "" 
	Local cFunName	:= Funname()
	Local aArea740	:= {}
	
	IniStatic()

	Private aRotina 	:= MenuDef()
	Private cCadastro 	:= STR0005  //Compensação de Titulos a Receber
	Private cLote		:= ""		//Utilizado para Contabilizacao
	Private VALOR 		:= 0 		//Utilizada para Contabilizacao - Valor em Real
	Private VALORMF		:= 0	 	//Utilizada para Contabilizacao - Valor na moeda do título
	Private VALOR7 		:= 0 		//Utilizada para Contabilizacao - Decréscimo
	Private VALOR8 		:= 0 		//Utilizada para Contabilizacao - Acréscimo
	Private VALOR9 		:= 0 		//Utilizada para Contabilizacao
	Private REGVALOR	:= 0	    //Utilizada para Contabilizacao
	Private lOracle		:= "ORACLE" $ Upper(TCGetDB())
	Private nTamTit		:= __nTamPref + __nTamNum + __nTamParc
	Private nTamTip		:= __nTamTipo
	Private nTamLoj		:= __nTamLoja
	Private aTxMoedas	:=	{}
	Private cCodDiario	:= ""
	
	Default nPosArotina := 0
	Default lExecAuto	:= .F.
	Default lRatFields 	:= cPaisLoc == "BRA"
	Default aRetXAPI	:= {}
	Default lAutMrkPix	:= .T.
	Default aFil330		:= {}
	
	__cPiE1Sld := PesqPict("SE1","E1_SALDO")
	__lMetric  := FwLibVersion() >= "20210517"	
	
	If AllTrim(cFunName) == "FINA460"
		Help(" ",1, "FROTORIG",, STR0118 + ; // "Não foi possível identificar a Função de origem, "
			STR0119 + CRLF + CRLF + ; 		// "o que impossibilitará a Compensação."
			STR0120 + CRLF + ; 				// "Por favor, retorne ao menu principal e acesse"
			STR0121,1,0) 					// "a rotina de Compensação novamente."
			
		Return .F.
	EndIf

	FCadMotBx("CMP", Padr("COMPENSA", 10), "ANSN") //Inclusao motivo de baixa
	
	l330Auto := lExecAuto
	__aFil330 := aFil330
	LoteCont( "FIN" )
	SetKey (VK_F12,{|a,b| AcessaPerg("FIN330",.T.)})
	
	If ExistBlock("FA330FLT")
		ExecBlock("FA330FLT",.F.,.F.)
	EndIf
	
	Pergunte("FIN330",.F.)
	
	//MV_PAR01 : Considera Loja  Sim/Nao          	 
	//MV_PAR02 : Considera Cliente     Original/Outros 
	//MV_PAR03 : Do Cliente                            
	//MV_PAR04 : Ate Cliente                           
	//MV_PAR05 : Compensa Titulos Transferidos S/[N]   
	//MV_PAR06 : Calcula Comissao sobre valores de NCC 
	//MV_PAR07 : Mostra Lancto Contabil                
	//MV_PAR08 : Considera abatimentos para compensar  
	//MV_PAR09 : Contabiliza On-Line                   
	//MV_PAR10 : Considera Filiais abaixo //Descontinuado em 09/12/2022              
	//MV_PAR11 : Filial De //Descontinuado em 09/12/2022                             
	//MV_PAR12 : Filial Ate //Descontinuado em 09/12/2022                            
	//MV_PAR13 : Calcula Comissao sobre valores de RA  
	//MV_PAR14 : Reutiliza taxas informadas
	
	__lMotRet	:= ExistFunc("FTemMotor") .And. FTemMotor()
	__l330Va	:= ExistFunc("FA330VACAL") .And. TableInDic("FKD") .And. TableInDic("FKC") .And. cPaisLoc $ "BRA"
	//Estrutura aTxMoedas [1] = Nome Moeda, [2] = Taxa a Ser Utilizada, [3] = Picture, [4] = Taxa do dia atual
	Aadd(aTxMoedas, {"", 1, PesqPict("SM2","M2_MOEDA1"), 1})
	
	For nA := 2	To MoedFin()
		cMoedaTx  :=	Str(nA, IIf(nA <= 9, 1, 2))
		cDescMoed := GetMv("MV_MOEDA" + cMoedaTx) 
		
		If Empty(cDescMoed)
			Exit
		Else
			nVlMoeda := RecMoeda(dDataBase, nA)
			Aadd(aTxMoedas, {cDescMoed, nVlMoeda, PesqPict("SM2","M2_MOEDA" + cMoedaTx), nVlMoeda} )
		Endif
	Next nA
	
	__lTxMoed	:= Len(aTxMoedas) > 0
	__aTxMoed0	:= aClone(aTxMoedas)

	dbSelectArea('SFQ')
	dbSelectArea('SE1')
	
	If cFunName == "FINA740"
		aArea740 := GetArea()
	EndIf
	
	If nPosArotina > 0
		bBlock := &( "{ |a,b,c,d,e,f,g,h,i,j| " + aRotina[ nPosArotina,2 ] + "(a,b,c,d,e,f,g,h,i,j) }" )
		Eval( bBlock, Alias(), (Alias())->(Recno()),nPosArotina,/*oDlgPae*/,/*cLoteFat*/,/*cOrigem*/,/*aNumLay*/,l330Auto,aRetXAPI, lAutMrkPix)
	Else
		dbSetOrder(1)
		dbSeek(xFilial())
		
		//Ponto de entrada para incluir botoes na rotina
		If ExistBlock( "FA330MNU" )
			aRotina := ExecBlock( "FA330MNU", .F., .F., { aRotina } )
		EndIf
		
		//P.E retorna uma expressao SQL para filtro no mBrowse sem que a opcao de filtro do usuario seja desabilitado.
		cBrwExp	:= NIL
		
		If ExistBlock( "FA330FBRW" )
			cBrwExp := ExecBlock( "FA330FBRW", .F., .F. )
		EndIf
		
		mBrowse( 6, 1,22,75,"SE1",,,,,,Fa330Leg(),,,,,,,, cBrwExp)
	EndIf
	
	//Restaura o ambiente
	SetKey (VK_F12)
	dbSelectArea("SE1")
	If cFunName == "FINA740"
		RestArea(aArea740)
	Else
		dbSetOrder(1)
	EndIf
	dbGoTo( nSavRec )
	
	If __oHNatPCC <> Nil
		__oHNatPCC:Clean()
		__oHNatPCC 	:= NIL
	EndIf
	FwFreeArray(__aNatPCC)
	__aNatPCC	:= {}

	FinEraseTmpFil()

	//Limpa as variáveis estáticas utilizadas para o motor de retenções
	LimpaVarMR()
Return(.T.)

//------------------------------------
/*/{Protheus.doc}fA330Comp
Marcação dos titulos para compensação

@author Mauricio Pequim Jr
@since  18/04/94
@version 8
/*/
//------------------------------------
Function fA330Comp(cAlias,cCampo,nOpcE,oDlgPae,cLoteFat,cOrigem,aNumLay, lAutomato,aRetXAPI, lAutMrkPix)
	Local lPanelFin		:= IsPanelFin()
	Local nTotal		:= 0
	Local nHdlPrv		:= 0
	Local nValorComp	:= 0
	Local nVlrCmpAux	:= 0
	Local nSeq			:= 0
	Local nValBX		:= 0			// Valor da baixa na moeda 1
	Local nValBX2		:= 0			// Valor da baixa na moeda do tit principal
	Local nX
	Local nI
	Local cAdiantamento
	Local cDadosTitulo
	Local cArquivo
	Local cPadrao		:= "596"
	Local lContabil		:= .F.
	Local lPadrao		:= .F.
	Local lDigita		:= .F.
	Local dEmissao		:= SE1->E1_EMISSAO
	Local aBaixas		:= {}
	Local nTotAbat		:= 0
	Local nTotAbtIni	:= 0
	Local nTitIni		:= SE1->(Recno())
	Local nDecs			:= 2
	Local nSalTit		:= 0
	Local nDecs1		:= MsDecimais(1)
	Local oOk			:= LoadBitmap( GetResources(), "LBOK" )
	Local oNo			:= LoadBitmap( GetResources(), "LBNO" )
	Local cVarQ			:= "  "
	Local oTitulo
	Local oDlg
	Local lFa330Cmp		:= ExistBlock( "FA330CMP" )
	Local nSldReal		:= 0
	Local oGet01
	Local nLinha		:= 0
	Local nTit			:= 0
	Local cKeyAbt		:= ""
	Local nSe1Rec		:= 0
	Local nAcresc		:= 0
	Local nDecres		:= 0
	Local nAcrescNF		:= 0
	Local nDecresNF		:= 0
	Local nValVa		:= 0
	Local nValVaTitP	:= 0
	Local nIndexAtu		:= SE1->(IndexOrd())
	Local nVlrCompe 	// Criada para exibir o conteudo do Help correto quando o usuario pressionar F1 sobre o campo
	Local aSize			:= {}
	Local lDeleted		:= .F.
	Local lfa330Bx		:= Existblock("FA330BX")
	Local oPanel
	Local oChkBox
	Local aArea			:= {}
	Local lVldDtFin		:= .T.
	Local aDiario		:= {}
	Local lPccBxCr		:= FPccBxCr()
	Local lIrPjBxCr		:= FIrPjBxCr()
	Local nPropIR		:= 1
	Local nVlMinImp 	:= GetNewPar("MV_VL10925",5000)
	Local nTotCsAbt		:= 0
	Local nTotPisAbt	:= 0
	Local nTotCofAbt	:= 0
	Local aImpPcc		:= {0,0,0}
	Local nTotIssAbt	:= 0
	Local lCalcIssBx 	:= !Empty( SE5->( FieldPos( "E5_VRETISS" ) ) ) .and. !Empty( SE1->( FieldPos( "E1_SEQBX"   ) ) ) .and. ;
							!Empty( SE1->( FieldPos( "E1_TRETISS" ) ) ) .and. GetNewPar("MV_MRETISS","1") == "2"
	Local nTotAdto		:= 0
	Local lBaixaAbat	:= .F.
	Local nVlrBaixa		:= 0
	Local lBxCec		:= .F.
	Local lBxLiq		:= .F.
	Local nTamSeq		:= __nTamSeq
	Local cSequencia	:= Replicate("0",nTamSeq)
	Local nRecnoRA		:= 0
	Local lF330BOTON 	:= ExistBlock("F330BOTON")
	Local lF330ATLIS	:= ExistBlock("F330ATLIS")
	Local lCompRa		:= .F.
	Local nPropPcc		:= 0
	Local nRegRa		:= 0
	Local nPos			:= 0
	Local lComisCR		:= SuperGetMv("MV_COMISCR",.F.,"S") == "S" // Verifica se permite o cálculo da comissão para vendedor na Compensação CR..
	Local lComisOn		:= SuperGetMv("MV_TPCOMIS",.F.,"O") == "O" // Verifica se o cálculo da comissão é On Line ou Batch.
	Local lTipBxCP  	:= .F.
	Local lSigaLoja 	:= .F.
	Local lTitpaiSE1 	:= .T.
	Local nOrdTitPai	:= 0
	Local cTipo	 		:= ""
	Local bWhile 		:= {|| !EOF() .And. E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA==xFilSE1+cKeyAbt}
	Local nPisFin061	:= 0
	Local nCofFin061	:= 0
	Local nCslFin061	:= 0
	Local nIrfFin061	:= 0  
	Local nOrdSE5		:= 0
	Local nRegSE5		:= 0
	Local nPropImp		:= 0
	Local nProp			:= 0
	Local nIrrfParc		:= 0
	Local nRecTit		:= 0
	Local nOldVal		:= 0
	Local nPosVa		:= 0
	Local oBtFilial		:= Nil
	Local aAlt     		:= {}
	Local aPcc			:= {.F.,0,0,0,{}}
	Local nValIrf		:= 0
	Local lJurMulDes    := SuperGetMv("MV_IMPBAIX", .T., "2") == "1" //Considera juros, multa e desconto 1= Sim/2=Não
	Local nTotalTit		:= 0
	Local nAltVal		:= 0
	Local nVTit			:= 0
	Local nBasePcc 		:= 0
	Local lMata460		:= .F.
	Local nRegFK1		:=	0
	Local aBxInteg		:= {}
	Local nInt			:= 0
	Local lEnvMU070		:= FWHasEAI( "FINA070", .T.,, .T. )
	Local lEnvMU330		:= FWHasEAI( "FINA330", .T.,, .T. )
	Local aRetInteg		:= {}
	Local lRet			:= .T.
	Local lOpcAux		:= .F.
	Local lJuros		:= .T.
	Local lIntPFS       := SuperGetMV("MV_JURXFIN",,.F.) // Habilita a integracao entre os módulos SIGAFIN - Financeiro e SIGAPFS - Juridico
	Local lRetImp		:= .T.
	Local lRaRtImpMR 	:= .F.
	Local nValImpAux 	:= 0
	Local nValTitAux 	:= 0
	Local nValorAux 	:= 0
	Local cSeqAux 		:= ""
	Local nIssAux 		:= 0
	Local nInssAux 		:= 0
	Local lNccAux 		:= .F.
	Local lRetMinAux 	:= .F.
	Local lIrfBxAux 	:= lIrPjBxCr
	Local lPccBxAux 	:= lPccBxCr
	Local lIssBxAux	 	:= lCalcIssBx
	Local aAuxTitMR 	:= {}
	Local dDtEmis		:= CTOD("  /  /  ")
	Local lFinTp01		:= FindFunction("FINTP01")
	Local lSelAuto		:= .F.
	Local cPicE5Val   	:= PesqPict("SE5","E5_VALOR")
	Local nOdlgLen	 	as Numeric
	Local nFrameLen 	as Numeric
	Local nWidthRus		as Numeric
	Local oNumCont 		as Object
	Local oChkFltCnt	as Object
	Local nFilialPos 	as Numeric
	Local nOkPos	 	as Numeric
	Local nCancelPos 	as Numeric
	Local nMoedaHght 	as Numeric
	Local nN			as Numeric
	Local oModelVA		as Object
	Local cFilOld		As Character
	Local nRegSe5Ori 	:= 0 
	Local nInicio		:= 0
	Local nFim			:= 0
	Local nGravados		:= 0
	Local nRegistros	:= 0 
	Local nVlTotConv	:= 0
	Local nValImp		:= 0
	Local nImpCalc		:= 0
	Local nCntCent		:= 0
	Local nMVToler		:= SuperGetMv("MV_TOLERPG",,0.01)
	Local nToler		:= 0.01 
	Local cChaveTit     := ""
	Local lRetorno      := .T.
	Local cIdDocFK7     := ""
	Local nAcumIRF 		As Numeric
	Local nAcumPIS 		As Numeric
	Local nAcumCOF 		As Numeric
	Local nAcumCSL 		As Numeric
	Local lSumPcc		As Logical
	Local nBaseImpos    As Numeric
	Local nVarAux		As Numeric
	Local nImposRet     As Numeric
	Local lMVRARTIMP    As Logical
	Local lCondicao     As Logical
	Local nValorReal    As Numeric
	Local nValorEstr    As Numeric
	Local nSldAdiant    As Numeric
	Local nImposPen     As Numeric
	Local lVMd2ImpRA    As Logical
	Local nRecnTitRA    As Numeric
	Local nRecnTitNF    As Numeric
	Local lVldSEQ	  	As Logical

	Default cOrigem 	:= ""
	DEFAULT aNumLay 	:= {}
	Default lAutomato 	:= .F.
	Default aRetXAPI	:= {}
	Default lAutMrkPix	:= .T.

	PRIVATE lCheck		As Logical
	PRIVATE nPosPis		:= 14		//Posicao Pis na Tela
	PRIVATE nPosCof		:= 15		//Posicao Cofins na Tela
	PRIVATE nPosCsl		:= 16		//Posicao Csll na Tela
	PRIVATE nPosIrf		:= 17		//Posicao IRRF na Tela
	PRIVATE cTipoOr		:= SE1->E1_TIPO
	PRIVATE nPosBPCC 	:= 24
	PRIVATE nPosBPCR 	:= 25
	PRIVATE nPosBIRF 	:= 26
	PRIVATE aTitulos	:= {}
	PRIVATE aRecNo 		:= {}
	PRIVATE aRegSE1 	:= {}
	PRIVATE aBaixaSE5 	:= {}
	PRIVATE	cPrefixo 	:= SE1->E1_PREFIXO
	PRIVATE	cNum		:= SE1->E1_NUM
	PRIVATE	cTipoTit 	:= SE1->E1_TIPO
	PRIVATE	cCliente 	:= SE1->E1_CLIENTE
	PRIVATE	cLoja 		:= SE1->E1_LOJA
	PRIVATE	cSaldo		:= CriaVar("E1_SALDO")
	PRIVATE	nValor		:= CriaVar("E1_SALDO")
	PRIVATE	cParcela 	:= SE1->E1_PARCELA
	PRIVATE	nMoeda		:= SE1->E1_MOEDA
	PRIVATE	dBaixa		:= dDataBase
	PRIVATE	nTxMoeda	:= SE1->E1_TXMOEDA
	PRIVATE	nValTot		:= 0
	PRIVATE	nSeqBx 		:= 0
	PRIVATE	nPosSaldo	:= 0
	PRIVATE	nPosValor	:= 0
	PRIVATE	cBanco		:= Criavar("E1_PORTADO")
	Private lCredito 	:= .F.
	Private nPosATit 	:= 0
	Private aFlagCTB 	:= {}
	Private lUsaFlag 	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	Private aImpIR		:= {}     //array que armazena o IR na baixa
	PRIVATE nPis 		:= 0
	PRIVATE nCofins   	:= 0
	PRIVATE nCsll		:= 0
	PRIVATE nIss		:= 0
	PRIVATE nInss		:= 0
	PRIVATE aDadosRef 	:= {0,0,0,0,0,0,0} //Array(7)
	PRIVATE aDadosRet 	:= {0,0,0,0,0,0,0} //Array(7)
	PRIVATE nVlRetPis	:= 0
	PRIVATE nVlRetCof	:= 0
	PRIVATE nVlRetCsl	:= 0
	PRIVATE nDiferImp	:= 0
	PRIVATE nValRec		:= 0
	PRIVATE nOldValRec	:= 0
	PRIVATE lRetParc  	:= .T.
	PRIVATE nIrrf 	  	:= 0
	PRIVATE ntotIrbx  	:= 0
	PRIVATE nIndVld   	:= 0
	PRIVATE nRecVld   	:= 0
	PRIVATE nValCorCM 	:= 0
	PRIVATE nTotImpbx  	:= 0 //Total de impostos calculados na baixa, quando posiciona !lCredito
	Private aDadosRA1 	:= {{},{},{},{},{},{},{},{},{},{},{},{}}
	Private lRaRtImp  	:= FRaRtImp()       //Define se ha retencao de impostos PCC/IRPJ no R.A
	Private nValAbat	:= 0
	PRIVATE lNcc		:= SE1->E1_TIPO $ MV_CRNEG
	PRIVATE lF330SE5    := Existblock("F330SE5")
	PRIVATE aRecSe5     := {}
	PRIVATE nValPis		:= 0
	PRIVATE nValCofins	:= 0
	PRIVATE nValCsll	:= 0
	PRIVATE nAbatRa		:= 0
	Private nSldNF		:= 0
	Private nAbatNf		:= 0
	PRIVATE nValorNf	:= 0
	PRIVATE lF330DESC	:= ExistBlock("F330DESC")
	PRIVATE lDESC		:= .F.
	PRIVATE nDesFin 	:= 0
	PRIVATE nDescP		:= 0
	PRIVATE nDescD		:= 0
	Private nValorRa	:= 0
	Private nSldRa		:= 0
	Private nParciais	:= 0
	Private nPisBaseR 	:= 0
	Private nCofBaseR	:= 0
	Private nCslBaseR 	:= 0
	Private nPisBaseC 	:= 0
	Private nCofBaseC 	:= 0
	Private nCslBaseC 	:= 0
	Private nIrfBase	:= 0
	Private aSelFil		:= {}
	PRIVATE lFilterMark	:= .F.
	PRIVATE cTitFilt	as Character
	PRIVATE cPayType  	as Character
	PRIVATE cSortField	as Character
	PRIVATE cSortType	as Character
	PRIVATE nSel		as Numeric
	PRIVATE nRadio		as Numeric
	PRIVATE cNumCont	as Character
	Private nPisCalc	:= 0
	Private nCofCalc	:= 0
	Private nCslCalc	:= 0
	Private nIrfCalc	:= 0
	Private nIssCalc	:= 0
	Private nIrfBaseR 	:= 0
	Private nIssBaseR 	:= 0
	Private nIrfBaseC 	:= 0
	Private nIssBaseC 	:= 0
	
	nAcumIRF   := 0
	nAcumPIS   := 0
	nAcumCOF   := 0
	nAcumCSL   := 0
	lCheck     := .T.
	lVldSEQ    := .F.
	__cFunBkp  := FunName()
	__cFunMet  := Iif(AllTrim(__cFunBkp)=='RPC',"RPCFINA330",__cFunBkp)
	cFilOld	   := ""
	__lCredNCC := lCredito
	__lMaTiPix := lAutMrkPix
	
	If __lMetric
		SetFunName(__cFunMet)
		// Metrica de controle de acessos 
		FwCustomMetrics():setSumMetric(Alltrim(ProcName()), "financeiro-protheus_qtd-por-acesso_total", 1)
		SetFunName(__cFunBkp)
	EndIf
	
	If __cRmProd == Nil
		__cRmProd := SuperGetMv('MV_RMORIG',, "E|U|S")
	EndIf
	
	If cPaisLoc == "RUS"
		cTitFilt  := ''
		cPayType  := ''
		cSortField:= ''
		cSortType := ''
		nSel	  := 0
		nRadio 	  := 1	
		cNumCont  := SE1->E1_F5QCODE
		nOdlgLen  :=0
		nFrameLen :=0
		nOkPos	  :=0
		nFilialPos:=0
		nCancelPos:=0
		oNumCont  := Nil
		oChkFltCnt:= Nil
		nMoedaHght:= Nil
	EndIf
	
	If __lBq10925 == Nil
		__lBq10925 := SuperGetMV("MV_BQ10925",,"2") == "1"
	Endif	
	
	If Empty(__cPiE1Sld) 
		__cPiE1Sld := PesqPict("SE1","E1_SALDO")
	EndIf 
	
	If SE1->E1_MOEDA <> 1 .And. dDataBase < CTOD("29/11/2018")
		Help(" ",1, "FA330MOED",, STR0111 + AllTrim(Str(SE1->E1_MOEDA,2)) +"," + STR0112 +CRLF+CRLF+STR0113 ,1,0)
		Return
	EndIf
	
	If cOrigem == "LOJA800"
		nValor   :=  nVlrComp
	EndIf
	
	nVlrCompe	:= nValor
	
	If dDataBase > dLastPcc
		nVlMinImp	:= 0
	EndIf
	
	If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG .or. cOrigem =="MATA465"
		lCredito 	:= .T.
		__lCredNCC	:= SE1->E1_TIPO $ MV_CRNEG
		__nMoedSA6	:= GetAdvFVal("SA6", "A6_MOEDA", xFilial("SA6") + SE1->(E1_PORTADO + E1_AGEDEP + E1_CONTA), 1 )
	EndIf
	
	If !FA330Lock(, SE1->(Recno()))
		Return
	EndIf
	
	aArea := GetArea()
	
	//Se vier do mata465 ou da LOCXNF, forca os valores dos parametros
	If cOrigem == "MATA465"
		MV_PAR07 := mv_par03		// Mostra Lancto Contabil
		MV_PAR09 := mv_par05		// Contabiliza On-Line
		MV_PAR01 := 1 				// Considera Loja  Sim/Nao
		MV_PAR02 := 1 				// Considera Cliente Original/Outros
		MV_PAR03 :=	SE1->E1_CLIENTE // Do Cliente
		MV_PAR04 :=	SE1->E1_CLIENTE // Ate Cliente
		MV_PAR05 := 2				// Compensa Titulos Transferidos S/[N]
		MV_PAR06 := 2				// Calcula Comissao sobre valores de NCC
		MV_PAR08 := 2				//Considera abatimentos para compensar
		MV_PAR10 := 2				//Considera Filiais abaixo
		MV_PAR11 := Space( __nTamFil )	    //Filial De
		MV_PAR12 := Replicate("Z",__nTamFil)  //Filial Ate
		MV_PAR13 := 1				// Calcula Comissao sobre valores de RA
		MV_PAR14 := 2				// Reutiliza taxas informadas
		// obs.: nao eh necessario voltar aos valores originais no final, pois a
		// propria MATA465 recompoe os valores dos mv_parxx depois da chamada fa330comp()
	ElseIf cOrigem == "COMPENSANCC"
		Pergunte("FIN330",.F.)
		MV_PAR03 := SE1->E1_CLIENTE  		// Do Cliente
		MV_PAR04 := SE1->E1_CLIENTE 		// Ate Cliente

		dbSelectArea("SE1")
	EndIf
	
	If Type("MV_PAR02")<>'N'
		MV_PAR02 := 1 				// Considera Cliente Original/Outros
	EndIf

	//Caso considere diferentes clientes
	nPosVa := IIf(__lMotRet, 28, 27)
	
	If MV_PAR02 == 2
		nPosPis		:= 17
		nPosCof		:= 18
		nPosCsl		:= 19
		nPosIrf		:= 20
		nPosBPCC	:= 27
		nPosBPCR	:= 28
		nPosBIRF	:= 29
		nPosVa		:= If(__lMotRet,31,30)
	EndIf

	RestArea(aArea)

	If ExistBlock("F330DTFIN")
		lVldDtFin := ExecBlock("F330DTFIN",.F.,.F.)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se data do movimento n„o ‚ menor que data limite de ³
	//³ movimentacao no financeiro    										  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lVldDtFin .and. !DtMovFin(,,"2")
		Return
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ N„o permite que t¡tulos j  baixados possam ser acessados. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SE1->E1_SALDO <= 0
		Help(" ",1,"FA330JABAI")
		Return (.T.)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Caso titulos originados pelo SIGALOJA estejam nas carteiras :  ³
	//³I = Carteira Caixa Loja                                        ³
	//³J = Carteira Caixa Geral                                       ³
	//³Nao permitir esta operacao, pois ele precisa ser transferido   ³
	//³antes pelas rotinas do SIGALOJA.                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Upper(AllTrim(SE1->E1_SITUACA)) $ "I|J" .AND. Upper(AllTrim(SE1->E1_ORIGEM)) $ "LOJA010|LOJA701|FATA701"
		Help(" ",1,"NOUSACLJ")
		Return
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Titulos provisorios nao sao compensaveis como titulo principal.        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cTipoTit $ MVPROVIS
		Help(" ",1,"NOCMPPROV",,STR0042+chr(13)+STR0043,1,0 )   //"Nao é permitida a compensacao a partir de"###"um titulo provisorio"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Recupera a Integridade dos dados     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SE1")
		dbSetOrder(nIndexAtu)
		DeleteObject(oOk)
		DeleteObject(oNo)
		FA330aUnlock()
		Return (.T.)
	EndIf

	//ANGOLA|BRASIL|RUSSIA - Nao permitir compensar titulos de adiantamento relacionados a pedido
	If cPaisLoc $ "ANG|BRA|RUS" .And. !__lCmpM460 .And. FinAdtSld( "R", SE1->( E1_CLIENTE + E1_LOJA + E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO ) )
		Help(" ",1,"ADTXPED",,STR0062,1,0)		//"Adiantamento relacionado a um pedido somente poderá ser utilizado no relacionamento com pedidos"
		Return (.T.)
	EndIf

	//-----------------------------------------------------------
	// Nao permite compensar recebimentos antecipados originados
	// de faturas de adiantamentos. Req. Manejo de Anticipo
	//-----------------------------------------------------------
	If cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT")
		If SE1->E1_TIPO == Substr(MVRECANT,1,3) .And.;
			Upper(Alltrim(SE1->E1_ORIGEM)) $ ("FINA087A|"+IIF(FindFunction('OriCobrDiv'),OriCobrDiv(),"")) .And.;
			GetAdvFVal("SED","ED_OPERADT",xFilial("SED")+SE1->E1_NATUREZ,1,"") == "1"

			Help(" ",1,"VLDTITRA",,STR0065,1,0) //"Processo não permitido para recebimento antecipado gerado de fatura de adiantamento."
			Return (.T.)

		EndIf
	EndIf

	//PCREQ-3782 - Bloqueio por situação de cobrança
	If !(F023VerBlq("1","0007",SE1->E1_SITUACA,.T.))
		Return (.T.)
	EndIf

	// SIGAPFS - Valida se o RA que foi gerado a partir de um adiantamento do SIGAPFS pode ser compensado.
	// Caso tenha sido gerado a partir de um adiantamento exclusivo não poderá ser compensado.
	If lIntPFS .And. AllTrim(SE1->E1_ORIGEM) == 'JURA069'
		If FindFunction("JVldCompAd") .And. !JVldCompAd()
			Return (.T.)
		EndIf
	EndIf

	//Validação quando utiliza módulo do agro
	If !l330Auto .And. SuperGetMv("MV_SIGAAGR",,.F.)
		If FindFunction("AGRTITFIN")
			If !AGRTITFIN()
				return .F.
			EndIf
		EndIf  
	EndIf

	//Validação de mensagem de titulo RM Classis
	If(AllTrim(SE1->E1_ORIGEM) $ __cRMProd .And. !l330Auto)
		HELP(" ",1,STR0132 ,, STR0133,2,0,,,,,, {STR0134})//"Título gerado pela Integração Protheus X Classis não Pode ser compensado pelo Protheus" ## "Efetue o processo através do sistema RM Classis"
		Return .F.
	EndIf

	If Type("mv_par15") == 'N' .And. mv_par15 == 2
		lJuros := .F.
	EndIf

	//Motor de retenções
	If __lMotRet
		//Verifica as configurações de impostos pelo motor de retenção
		__lTCnfgMR	:= F330VldImp()		
		
		lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
		lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
		lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
		lCalcIssBx 	:= ( __lIssMR .And. __lIssBxMR ) .Or. ( !__lIssMR .And. lIssBxAux )
		
		//Calcula os impostos pelo motor de retenções
		If __lTCnfgMR
			F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, SE1->E1_SALDO, dDataBase, SE1->E1_TIPO )
			__lTCnfgMR	:= .F.
		EndIf
	EndIf

	//Inicializa a gravacao dos lancamentos do SIGAPCO
	PcoIniLan("000016")
	
	//Inicializa as variáveis estáticas
	F330Static()
	
	If cPaisLoc == "BRA" .And. TipoGerPix(SE1->E1_TIPO) .And. __lExcImpo .And. !__lCNABImp
		lRetorno := ExcImpoPix(nTitIni)
		__TpGerPix	:= .F.
	EndIf
	
	While lRetorno
		If lFinTp01 .And. FINTP01(.T.)	// Restringe o uso do programa Financeiro Quando a origem do titulo for de origem Totvs Incorporação RM
			Exit
		EndIf		
		
		nInicio		:= 0
		nFim		:= 0
		nGravados	:= 0
		nRegistros	:= 0
		nOpca       := 0
		nSldTitIni  := 0
		nBaseImpos  := 0
		nVarAux		:= 0
		__nRecPart  := SE1->(Recno())
		__nMoePart  := SE1->E1_MOEDA
		
		If !lCredito	
			nSldTitIni:= SE1->E1_SALDO
		Endif
		
		If cPaisLoc == "ARG"		
			__nTxMoedP := RecMoeda(dDatabase,SE1->E1_MOEDA)
		ElseIf SE1->E1_MOEDA != 1 .And. __nTxMoedP == 0
			__nTxMoedP := RecMoeda(If(SE1->E1_TIPO $ MVRECANT .And. __lRaTxMov, F330MovRA(Nil, "SE1", .T.)[2], dDatabase), SE1->E1_MOEDA)
		EndIf	
		
		//a taxa não pode atualizar o array aTxMoedas senão perdemos a referencia de alteração pelo usuário		
		__lNoTxMov := Empty(__nTxMoedP)
		
		If SE1->E1_MOEDA > 1 .And. lCredito .And. __lRaTxMov
			aTxMoedas[SE1->E1_MOEDA,2] := __nTxMoedP
		EndIf
		
		If !lCredito 
			nDescP := nDesFin := getDesc(nSldTitIni)
		endIf
		
		//VA: Calcula o valor acessório
		If __l330Va .And. !lCredito
			nMoedaBco	:= SE1->E1_MOEDA
			oModelVA	:= FWLoadModel("FINA070VA")
			nValVa		:= FA330VACAL(oModelVA)
			nValVaTitP	:= nValVa
			oModelVa:Destroy()
			oModelVa 	:= NIL
		EndIf
		
		__nValVa := nValVa
		nSaldo   := SE1->E1_SALDO + SE1->E1_SDACRES - SE1->E1_SDDECRE - nDesFin + nValVa - __nImpMR
		
		If (mv_par08 == 1 .Or. lRaRtImp .Or. lRaRtImpMR)
			If !lCredito
				nTotAbtIni 	:= SumAbatRec(cPrefixo, cNum, cParcela, SE1->E1_MOEDA, "S", dBaixa,,, @nTotCsAbt, @nTotPisAbt, @nTotCofAbt,,,, @nTotIssAbt )			
				
				If __lIrfMR .And. __lIrfBxMR .And. !__lRaRtIrf 
					nIrrf := __nIrfCaMR
				EndIf 
				
				If cPaisLoc == "BRA" .And. !__lIrfMR .And. lIrPjBxCr .And. !lRaRtImp .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
					nIrrf := FCaIrBxCR(IIf(nBaseImpos > 0, nBaseImpos, nValRec))
				EndIf	
				
				If !lCalcIssBx
					nTotIssAbt := 0
				EndIf
			EndIf
			
			If nTotAbtIni != 0 .And. (!lRaRtImp .And. !lRaRtImpMR) .Or. (!lNcc .And. mv_par08 == 1)
				nSaldo := nSaldo - nTotAbtIni
			EndIf
		EndIf
		
		If SE1->E1_MOEDA > 1
			__nSldConv := SE1->E1_VLCRUZ
		EndIf
		
		nPisFin061	:= 0
		nCofFin061	:= 0
		nCslFin061	:= 0
		nIrfFin061	:= 0
		VALOR7 		:= 0
		VALOR8 		:= 0
		
		If cPaisLoc == "BRA" .And. lPccBxCr .And. lIrPjBxCr
			nRegSE5 := SE5->(Recno())
			
			DbSelectArea("SE5")
			SE5->(DbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
			
			If SE5->(dbSeek(xFilial("SE5") + "BA" + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO))
				While !SE5->( Eof() ) .And. SE5->E5_FILIAL == xFilial("SE5") .And. SE5->E5_TIPODOC + SE5->E5_PREFIXO + SE5->E5_NUMERO + SE5->E5_PARCELA + SE5->E5_TIPO == "BA" + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO				
					If ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
						If Alltrim(SE5->E5_MOTBX) == "PCC"
							nPisFin061	+= SE5->E5_VRETPIS
							nCofFin061	+= SE5->E5_VRETCOF
							nCslFin061	+= SE5->E5_VRETCSL
						ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
							nIrfFin061	+= SE5->E5_VRETIRF
						EndIf
					EndIf					
					
					SE5->( DbSkip() )
				EndDo
			EndIf
			
			SE5->(DbGoTo(nRegSE5))
		EndIf
		
		If ( nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061 ) > 0 .And. mv_par08 == 2
			nSaldo	+= nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061
		EndIf
		
		If !lCredito
			nAcrescNF := SE1->E1_SDACRES
			nDecresNF := SE1->E1_SDDECRE
		EndIf
		
		nRecno       := SE1->(Recno())		
		cDadostitulo := SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO
		
		If (lPccBxCR .Or. lIRPJBxCr) .And. ( lRaRtImp .Or. lRaRtImpMR ) .And. !lNcc
			AAdd(aDadosRA1[IIf(lCredito, 1, 2)], nRecno)
		ElseIf lCredito .And. __lMotRet
			AAdd(aDadosRA1[1], nRecno)
		EndIf
		
		If __lMotRet
			aAdd(aDadosRA1, {__nImpMR})
		EndIf
		
		//Se PCC Baixa CR e nao houver abatimento de impostos
		If cPaisLoc == "BRA" .And. (lPccBxCr .Or. lIrPjBxCr) .And. ( nTotCsAbt + nTotPisAbt + nTotCofAbt == 0 )
			If (SE1->E1_VALOR > SE1->E1_SALDO) .And. Empty(SE1->E1_TIPOLIQ)
				//Procura pelas baixas deste titulo
				lTipBxCP := lRaRtImp .Or. lRaRtImpMR
				aBaixa   := Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, ;
									@nTotAdto, @lBaixaAbat, SE1->E1_CLIENTE, SE1->E1_LOJA, @nVlrBaixa,, @lBxCec, @lBxLiq, @lSigaLoja, @lTipBxCP )

				For nX := 1 To Len(aBaixaSE5)
					nParciais += aBaixaSE5[nX][8]				
					
					If lPccBxCR .And. ( lRaRtImp .Or. lRaRtImpMR ) //somar impostos PCC
						nParciais += aBaixaSE5[nX][18] + aBaixaSE5[nX][19] + aBaixaSE5[nX][20] + aBaixaSE5[nX][30] + aBaixaSE5[nX][32] + aBaixaSE5[nX][33]
					Endif
					
					nIss += aBaixaSE5[nX][32]
					nInss += aBaixaSE5[nX][33]
				Next
				
				nParciais += nTotAdto
			Else
				nParciais := SE1->E1_VALOR - SE1->E1_SALDO
			EndIf
			
			If MVRECANT $ SE1->E1_TIPO
				nParciais := SE1->E1_VALOR - SE1->E1_SALDO
			EndIf
			
			If ( !lRartImp .And. !lRaRtImpMR .And. mv_par08 == 1 .And. SE1->E1_TIPO == MVNOTAFIS .And. !__lBq10925 )
				nParciais := SE1->E1_VALOR - SE1->E1_SALDO
			EndIf

			If SE1->E1_SDDECRE <> SE1->E1_DECRESC .And. SE1->E1_SDDECRE > 0
				nParciais += ( SE1->E1_DECRESC - SE1->E1_SDDECRE )
			EndIf

			nValRec := SE1->E1_VALOR - nParciais
			nOldVal	:= nValrec
			
			If __lPccMR
				nPis 	:= __nPisCaMR
				nCofins := __nCofCaMR
				nCsll	:= __nCslCaMR
			Else
				If dDataBase <= dLastPcc
					//chama a f070TotMes para preencher o array aDadosRet
					f070TotMes(dBaixa,.T.)
				Else
					If SE1->E1_TIPO <> MVRECANT 
						If ("MATA" $ SE1->E1_ORIGEM) .Or. (SE1->E1_VLCRUZ <> SE1->E1_BASEIRF)
							nBasePcc 	:= FBaseRPCC(nValRec)
							nBasePcc 	:= Iif(ValType(nBasePcc) != "N", nValRec, nBasePcc)
							lMata460	:= .T.
						EndIf
						
						If !Empty(SE1->E1_NUMBOR)
							lRetImp:= VLDBOR(SE1->E1_NUMBOR,"R")
						EndIf
						
						If lRetImp .And. FNatPCC(SE1->E1_FILORIG, SE1->E1_NATUREZ) .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
							nBaseImpos := IIf(nBaseImpos > 0, nBaseImpos, Iif(lMata460, nBasePcc, nValRec))
							aPcc       := newMinPcc(dBaixa, nBaseImpos, SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)						
							nPis       := aPcc[2]
							nCofins    := aPcc[3]
							nCsll	   := aPcc[4]
							
							If Len(aPcc) > 4 
								__aTitCalc := aPcc[5]
							EndIf
						EndIf			
					EndIf
					
					aPcc[1]		:= .T.
				EndIf			
			EndIf
			
			If lRartImp .Or. lRaRtImpMR
				//Se lRartImp, retoma o valor de nValRec, alterado pela TotMes
				nValRec := SE1->E1_VALOR - nParciais
			ElseIf !__lPccMR .And. aDadosRet[1] < nVlMinImp .And. ( aDadosRet[1] + nSaldo > nVlMinImp ) .And. lPccBxCr
				nValRec := nSaldo
			EndIf
			
			If !__lPccMR			
				If lRartImp .And. lPccBxCr .and. SE1->E1_TIPO <> MVRECANT
					nPropPCC	:= SE1->E1_SALDO/SE1->E1_BASEPIS
					If dDataBase <= dLastPcc
						nPis		:= SE1->E1_PIS * nPropPCC
						nCofins		:= SE1->E1_COFINS * nPropPCC
						nCsll		:= SE1->E1_CSLL * nPropPCC
					EndIf
					If MV_PAR08==1
						nIss		:= SE1->E1_ISS - nIss
						nInss		:= SE1->E1_INSS - nInss
					Else
						nIss		:= SE1->E1_ISS * nPropPCC
						nInss		:= SE1->E1_INSS * nPropPCC
					Endif
				EndIf
			Endif
			
			If !lCredito
				If __lIrfMR
					nIrrf := __nIrfCaMR
				Else
					If !Empty(SE1->E1_NUMBOR)
						lRetImp:= VLDBOR(SE1->E1_NUMBOR,"R")
					EndIf
					
					If lRetImp .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
						nBaseImpos := IIf(nBaseImpos > 0, nBaseImpos,  (nValRec + Iif(lRaRtImp .And. SE1->E1_TIPO $ MVRECANT, (nPis+nCofins+nCsll+nIrrf), 0)))
						nIrrf      := FCaIrBxCR(nBaseImpos, Nil, lRaRtImp )
					EndIf
				EndIf
			EndIf
					
			If ( nPosIr := aScan( aImpIR, {|x| x[2] = SE1->(REcno())} ) ) = 0
				aAdd(aImpIR,{nIrrf,SE1->(Recno())})
				nPosIr := Len( aImpIR )
			Else
				aImpIR[nPosIr][1] := nIrrf
			EndIf
			
			If !__lIrfMR .And. ( lIrPjBxCr .And. lCredito )
				nIrrf := nIrrf * (nValRec / SE1->E1_BASEIRF)
			EndIf
			
			If !__lPccMR .And. !aPcc[1]
				If aDadosRet[1] <= nVlMinImp .and. ( aDadosRet[1] + nSaldo > nVlMinImp ) .and. !lRaRtImp .and. lPccBxCr .and. SE1->E1_TIPO <> MVRECANT
					nValPis		:= SE1->E1_PIS
					nValCofins 	:= SE1->E1_COFINS
					nValCsll	:= SE1->E1_CSLL
					nValorNf	:= SE1->E1_VALOR
				Elseif aDadosRet[1] <= nVlMinImp .and. ( aDadosRet[1] + nSaldo <= nVlMinImp ) .and. !lRaRtImp .and. lPccBxCr .and. SE1->E1_TIPO <> MVRECANT
					nProp	:= (aDadosRet[1] + SE1->E1_SALDO) / SE1->E1_VALOR
					nValPis	:= SE1->E1_PIS * nProp
					nValCofins := SE1->E1_COFINS * nProp
					nValCsll	:= SE1->E1_CSLL * nProp
					nValorNf	:= SE1->E1_VALOR
				ElseIf aDadosRet[1] > nVlMinImp .and. ( aDadosRet[1] + nSaldo > nVlMinImp ) .and. !lRaRtImp .and. lPccBxCr .and. SE1->E1_TIPO <> MVRECANT
					nValPis	:= SE1->E1_PIS
					nValCofins := SE1->E1_COFINS
					nValCsll	:= SE1->E1_CSLL
					nValorNf	:= SE1->E1_VALOR
					nSldNF		:= SE1->E1_SALDO
				EndIf
			EndIf
			
			If SE1->E1_TIPO == MVRECANT
				nValorRa	:= SE1->E1_VALOR
				nSldRa		:= SE1->E1_SALDO
			EndIf
					
			//Caso o titulo de partida possua PCC, diminuo do saldo a compensar
			If nPis + nCofins + nCsll + nIrrf > 0  .And. SE1->E1_TIPO <> MV_CRNEG .And. SE1->E1_TIPO <> MVRECANT
				aImpPcc [1] := nPis
				aImpPcc [2] := nCofins
				aImpPcc [3] := nCsll
							
				//Somente abate o imposto se teve retenção minima
				lRetMinAux := ( ( __nPisCaMR + __nCofCaMR + __nCslCaMR + __nIrfCaMR > 0 ) .Or. ( aDadosRet[1] + nSaldo > nVlMinImp ) )
				
				If MV_PAR08 == 1 .And. lRetMinAux
					If lRaRtImp .Or. lRaRtImpMR
						nSaldo -= ( nPis + nCofins + nCsll + nIrrf )
					Else
						If lPccBxCr
							nSaldo -= nPis + nCofins + nCsll
						EndIf
						
						If lIrPjBxCr
							nSaldo -= nIrrf
						EndIf
					EndIf
				ElseIf MV_PAR08 == 2 .And. ( ( lRaRtImp .And. ( !__lPccMR .And. aPcc[1] ) ) .Or. ( lRaRtImpMR .And. __lPccMR ) )
					nSaldo -= ( nPis + nCofins + nCsll + nIrrf )
				EndIf
							
				If !__lIrfMR .And. nIrrf > 0
					If ( nPosIr := aScan( aImpIR, {|x| x[2] = SE1->(Recno())} ) ) = 0
						aAdd( aImpIR, {nIrrf,SE1->(Recno())} )
						nPosIr := Len( aImpIR )
					Else
						aImpIR[nPosIr][1] := nIrrf
					EndIf
				EndIf
				
			EndIf	
		ElseIf lIrPjBxCr .And. ( !lRaRtImp .And. !lRaRtImpMR )
			nSaldo -= nIrrf
		EndIf

		If nPis + nCofins + nCsll + nIrrf > 0 .And. SE1->E1_TIPO <> MV_CRNEG .And. SE1->E1_TIPO <> MVRECANT
			lRetMinAux := ( ( lRaRtImpMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR + __nIrfCaMR > 0 ) .Or. ( lRaRtImp .And. aDadosRet[1] > nVlMinImp ) )
			If ( !lRartImp .And. !lRaRtImpMR ) .Or. lRetMinAux .AND. MV_PAR08 == 2
				nValRec -= ( nPis + nCofins + nCsll + nIrrf + nIss + nInss )  
				nTotImpbx += ( nPis + nCofins + nCsll + nIrrf + nIss + nInss )
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se for chamada da mata465 , nao mostrar a janela de parametros   ³
		//³ e forçar o valor de nOpca con valor 1. (Loc. Arg.).              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cOrigem != "MATA465"
			nWidthRus	:= 0 	
			If !lAutomato
				If lPanelFin  //Chamado pelo Painel Financeiro
					oPanelDados := FinWindow:GetVisPanel()
					oPanelDados:FreeChildren()
					aDim := DLGinPANEL(oPanelDados)
					DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0,0 To 0,0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )
					oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])
					nEspLarg := ((DlgWidthPanel(oPanelDados)/2) - 225) /2
					nEspLin  := 0
				Else
					nEspLarg := 0
					nEspLin  := 0
					If cPaisLoc == "RUS"
						nOdlgLen	:= 534
						nFrameLen 	:= 249
						nWidthRus	:= 10 	
						nVlrCompe 	:= nSaldo
					Else
						nOdlgLen	:= 525
						nFrameLen 	:= 245
					EndIf

					DEFINE MSDIALOG oDlg FROM	88,	31 TO 275,nOdlgLen TITLE STR0036 PIXEL //"Compensação de Adiantamentos"
				EndIf
		
				oDlg:lMaximized := .F.
				oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20)
				oPanel:Align := CONTROL_ALIGN_ALLCLIENT

				@ 000+nEspLin, 002+nEspLarg TO 030+nEspLin, 245+nEspLarg OF oPanel	PIXEL
				@ 031+nEspLin, 002+nEspLarg TO 062+nEspLin, 245+nEspLarg OF oPanel	PIXEL

				@ 015+nEspLin, 006+nEspLarg MSGET cPrefixo                SIZE 19, 10 OF oPanel PIXEL
				@ 015+nEspLin, 032+nEspLarg MSGET cNum VALID !EMPTY(cNum) SIZE 70, 10 OF oPanel PIXEL
				@ 015+nEspLin, 105+nEspLarg MSGET cParcela                SIZE 20, 10 OF oPanel PIXEL

				If !lCredito
					@ 015+nEspLin, 129+nEspLarg MSGET cTipoTit PICTURE "@!" VALID !Empty(cTipoTit) .AND.;
						!cTipoTit $ MVABATIM .AND. ;
						!(cTipoTit $ MVRECANT+"/"+MV_CRNEG) SIZE 12, 10 OF oPanel PIXEL
				Else
					@ 015+nEspLin, 129+nEspLarg MSGET cTipoTit PICTURE "@!" VALID !Empty(cTipoTit) .AND.;
						!cTipoTit $ MVABATIM .AND. ;
						(cTipoTit $ MVRECANT+"/"+MV_CRNEG) SIZE 12, 10 OF oPanel PIXEL
				EndIf
				
				@ 015+nEspLin, 155+nEspLarg MSGET cCliente F3 "SA1" Valid fa330Cli()	SIZE 70, 10 OF oPanel PIXEL HASBUTTON
				@ 015+nEspLin, 226+nEspLarg MSGET cLoja	 Valid Fa330Loja() SIZE 16, 10 OF oPanel PIXEL
		
				@ 047+nEspLin, 006+nEspLarg 			MSGET nSaldo When .F. 	Picture "@E 9999,999,999.99" SIZE (60-nWidthRus), 10 OF oPanel PIXEL HASBUTTON
				@ 047+nEspLin, (070+nEspLarg-nWidthRus) MSGET nMoeda when .F.	SIZE 18, 10 OF oPanel PIXEL
				@ 047+nEspLin, (095+nEspLarg-nWidthRus) MSGET nVlrCompe			Picture "@E 9999,999,999.99";
					Valid nVlrCompe >= 0 .AND. STR(nVlrCompe,17,2) <= STR(nSaldo,17,2) ;
					SIZE 52, 10 OF oPanel PIXEL HASBUTTON
				@ 047+nEspLin, (152+nEspLarg-nWidthRus) MSGET dBaixa Valid dBaixa >= SE1->E1_EMISSAO  .And. (If( lVldDtFin, DtMovFin(dBaixa,,"2"), .T.)) ;
					SIZE 48, 10 OF oPanel PIXEL HASBUTTON
				@ (037+nEspLin+nWidthRus), 194+nEspLarg CHECKBOX oChkBox VAR lCheck PROMPT STR0117 ; // "Tit. Marcados"
					SIZE 60,15 OF oPanel PIXEL
				If cPaisLoc == "RUS"
					@ 47+nEspLin, 190+nEspLarg MSGET oNumCont VAR cNumCont SIZE 50, 10 Picture "@!" OF oPanel PIXEL
					oNumCont:lVisible := .T.
				EndIf
				@ 007+nEspLin, 006+nEspLarg 			SAY STR0006  SIZE 21, 7 OF oPanel PIXEL  //"Prefixo"
				@ 007+nEspLin, 032+nEspLarg 			SAY STR0007  SIZE 22, 7 OF oPanel PIXEL  //"N£mero"
				@ 006+nEspLin, 105+nEspLarg 			SAY STR0008  SIZE 23, 7 OF oPanel PIXEL  //"Parcela"
				@ 006+nEspLin, 129+nEspLarg 			SAY STR0009  SIZE 14, 7 OF oPanel PIXEL  //"Tipo"
				@ 006+nEspLin, 155+nEspLarg 			SAY STR0010  SIZE 34, 7 OF oPanel PIXEL  //"Cliente   "
				@ 006+nEspLin, 226+nEspLarg 			SAY STR0011  SIZE 14, 7 OF oPanel PIXEL  //"Loja"
				@ 038+nEspLin, 006+nEspLarg 			SAY STR0012  SIZE 34, 7 OF oPanel PIXEL  //"Saldo"
				@ 038+nEspLin, (070+nEspLarg-nWidthRus) SAY STR0013  SIZE 21, 7 OF oPanel PIXEL  //"Moeda"
				@ 038+nEspLin, (095+nEspLarg-nWidthRus)	SAY STR0014  SIZE 55, 7 OF oPanel PIXEL  //"Valor a compensar"
				@ 038+nEspLin, (152+nEspLarg-nWidthRus)	SAY STR0015  SIZE 45, 7 OF oPanel PIXEL  //"Data da Baixa"
				If cPaisLoc == "RUS"
					@ 38+nEspLin, 190+nEspLarg CHECKBOX oChkFltCnt VAR lCheck PROMPT OemToAnsi(STR0102) SIZE 80,7 PIXEL OF oPanel ON CLICK(oNumCont:lActive := lCheck, IIf(!lCheck, cNumCont := Space(TamSX3("E1_F5QCODE")[1]), cNumCont := SE1->E1_F5QCODE) ,oNumCont:Refresh()) //Filter for Contracts
				EndIf			   
				If UsaSeqCor()
					SX3->(DbSetorder(2))
					SX3->(DbSeek("E5_DIACTB"))
					cCodDiario  := Criavar("E5_DIACTB",.T.)
					cTitDiar :=  AllTrim(X3TITULO())
					@ 038+nEspLin, 195+nEspLarg SAY cTitDiar SIZE 45, 7 OF oPanel PIXEL
					@ 047+nEspLin, 195+nEspLarg MSGET cCodDiario F3 "CVL" SIZE 20, 10 OF oPanel Valid VldCodSeq( cCodDiario ) When CtbWdia() PIXEL HASBUTTON
					SX3->(DbSetorder(1))
				EndIf
			
				If lPanelFin  //Chamado pelo Painel Financeiro
					aButtonTxt := {}
					AADD(aButtonTxt,{STR0037,STR0037, {||Fa330SetMo()}})

					ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,;
					{|| If(Fa330TudOk(nVlrCompe),(nOpca:=1,oDLg:End()),)},;
					{|| oDlg:End()},,aButtonTxt)

				Else
					If cPaisLoc == "RUS"
						nFilialPos		:= 158
						nOkPos			:= 186
						nCancelPos		:= 214
						nMoedaHght		:= 11
					Else
						nFilialPos		:= 162
						nOkPos			:= 190
						nCancelPos		:= 218
						nMoedaHght		:= 18
					EndIf
					@ 068+nEspLin, 005+nEspLarg BUTTON STR0037 SIZE 50,nMoedaHght ACTION (Fa330SetMo()) OF oPanel PIXEL //Taxas Moedas

					/* GESTAO - inicio */
					DEFINE SBUTTON Var oBtFilial FROM 68,162 TYPE 05 ACTION { || aSelFil := Fa330Fil() } ENABLE OF oPanel
					oBtFilial:cCaption := STR0070		//"Filiais"
					oBtFilial:cToolTip := STR0071		//"Seleciona filiais"
					/* GESTAO - fim */
				
					DEFINE SBUTTON FROM 68, 190 TYPE 1 ENABLE ACTION (If(Fa330TudOk(nVlrCompe),(nOpca:=1,oDLg:End()),)) OF oPanel
					DEFINE SBUTTON FROM 68, 218 TYPE 2 ENABLE ACTION oDlg:End() OF oPanel
				
					ACTIVATE MSDIALOG oDlg CENTERED
				Endif 	
			Else
				If __lGetParA .or. __lCmpM460
					nLenAuto := Len(aRetXAPI)

					If __lCmpM460 .And. nLenAuto > 0
						aRetAuto := aClone(aRetXAPI)
					Else
						If __lGetParA .and. nLenAuto == 0
							aRetAuto := GetParAuto("FINA330TestCase")
							If ValType(aRetAuto) == "A"
								If len(aRetAuto) == 0 .And. Type("lAutoCFGTRIB") == "L" .And. lAutoCFGTRIB
									aRetAuto := GetParAuto("FINA330CFGTRIBTestCase")
								EndIf
								nLenAuto := Len(aRetAuto)
							EndIf
						EndIf

						If (ValType(aRetAuto) != "A" .Or. nLenAuto == 0) .and. !__lCmpM460
							aRetAuto := GetParAuto("JURBXRTestCase") // Casos de testes - Módulo SIGAPFS
						EndIf
					EndIf
					
					If aRetAuto[1,1,2]
						cPrefixo   := aRetAuto[1,1,1]
					EndIf
					
					If aRetAuto[1,2,2]
						cNum       := aRetAuto[1,2,1]
					EndIf
					
					If aRetAuto[1,3,2]
						cParcela   := aRetAuto[1,3,1]
					EndIf
					
					If aRetAuto[1,4,2]
						cTipoTit   := aRetAuto[1,4,1]
					EndIf
					
					If aRetAuto[1,5,2]
						cCliente   := aRetAuto[1,5,1]
					EndIf
					
					If aRetAuto[1,6,2]
						cLoja      := aRetAuto[1,6,1]
					EndIf
					
					If aRetAuto[1,7,2]
						nVlrCompe  := aRetAuto[1,7,1]
					EndIf
					
					If aRetAuto[1,8,2]
						dBaixa     := aRetAuto[1,8,1] 
					EndIf
					If Len(aRetAuto[1]) > 8 //array com as taxas das moedas {nMoeda, nTaxa} (Simulando a alteração pelo botão de taxas)
						For nN := 1 to Len(aRetAuto[1,9])
							aTxMoedas[aRetAuto[1,9,1,nN][1], 2] := aRetAuto[1,9,1,nN][2]
						Next
						Fa330SetMo(lAutomato)
					EndIf
					If Fa330TudOk(nVlrCompe)
						nOpca := 1
					EndIf	
				EndIf
			EndIf

		Else
			nOpca	:=	1
		EndIf
		
		If nOpca == 0
			If cPaisLoc == "BRA" .And. __lAltPix .And. !__lTPIConf .And. __nFINPIX9 == 2
				GeraMonPix()
			EndIf

			dbSelectArea(cAlias)
			dbSetOrder(nIndexAtu)
			deleteObject(oOk)
			deleteObject(oNo)
			FA330aUnlock()
			Return
		EndIf
		
		//Metricas - Carregamento da tela de seleção
		If __lMetric
			nInicio := Seconds()
		Endif

		DbSelectArea("SE1")
		
		//Os valores exibidos em tela o serao na Moeda 1	
		If lPccBxCr
			If !__lPccMR
				nPropImp := nVlrCompe / SE1->E1_BASEPIS
				
				If dDataBase <= dLastPcc
					nPis		:= SE1->E1_PIS * nPropImp
					nCofins		:= SE1->E1_COFINS * nPropImp
					nCsll		:= SE1->E1_CSLL * nPropImp
					nIrrf		:= SE1->E1_IRRF * nPropImp
				Else
					If FNatPCC(SE1->E1_FILORIG, SE1->E1_NATUREZ)
						If VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
							If nVlrCompe > 0							
								aPcc := newMinPcc(dBaixa, IIf(nBaseImpos > 0, nBaseImpos, nVlrCompe), SE1->E1_NATUREZ, "R", SE1->(E1_CLIENTE+E1_LOJA))
							ElseIf dBaixa <> dDatabase .and. SE1->E1_TIPO <> MVRECANT //Alterou a data de baixa e nao alterou o valor
								nBaseImpos := IIf(nBaseImpos > 0, nBaseImpos, IIf(lMata460, nBasePcc, nOldVal))
								aPcc := newMinPcc(dBaixa, nBaseImpos, SE1->E1_NATUREZ, "R", SE1->(E1_CLIENTE+E1_LOJA))
							EndIf
							
							If Len(aPcc) > 2	
								nPis		:= 	aPcc[2]
								nCofins		:=	aPcc[3]
								nCsll		:=  aPcc[4]
								
								If Len(aPcc) > 4 
									__aTitCalc := aPcc[5]
								EndIf
							EndIf
						EndIf
					EndIf
					
					If cPaisLoc == "BRA"
						If SE1->E1_BASEIRF < SE1->E1_VALOR
							nIrrf := Iif(nVlrCompe	> 0,nVlrCompe ,nOldVal)*(nIrrf/SE1->E1_VALOR)
						Else
							IF nIrrf == SE1->E1_IRRF 
								nIrrf := nIrrf * (Iif(nVlrCompe	> 0,nVlrCompe ,nOldVal) / SE1->E1_BASEIRF)
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
			
			If dBaixa <> dDatabase .And. SE1->E1_TIPO <> MVRECANT //Alterou a data de baixa e nao alterou o valor
				If nPis + nCofins + nCsll + nIrrf > 0  .And. SE1->E1_TIPO <> MV_CRNEG .And. SE1->E1_TIPO <> MVRECANT
					lRetMinAux := ( ( lRaRtImpMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR + __nIrfCaMR > 0 ) .Or. ( lRaRtImp .And. aDadosRet[1] > nVlMinImp ) )
					If ( !lRartImp .And. !lRaRtImpMR ) .Or. lRetMinAux .And. MV_PAR08 == 2
						nValRec	:= nOldVal
						nValRec -= ( nPis + nCofins + nCsll + nIrrf + nIss + nInss )
						nTotImpbx := ( nPis + nCofins + nCsll + nIrrf + nIss + nInss )
						nSaldo := SE1->E1_SALDO - nPis - nCofins - nCsll
						If nVlrCompe == 0 .and. !lIrPjBxCr
							nSaldo := nSaldo - SE1->E1_IRRF
						EndIf
					EndIf
				Endif
			EndIf
		EndIf
		
		nValor 		:= nVlrCompe
		nValComp 	:= nValor
		nValIrf		:= nIrrf
		
		Processa({||Fa330Tit(dEmissao, cOrigem, lCredito, aNumLay, lAutomato)})  // Monta a Matriz com as compensacoes validas
		
		If Len(aTitulos) == 0
			If __lNTitFIE
				Help(" ",1,"ADTXPED",,STR0062,1,0)		//"Adiantamento relacionado a um pedido somente poderá ser utilizado no relacionamento com pedidos"
			Else
				Help(" ",1,"NOTITSEL",,"",1,0,,,,,,{STR0129})
			EndIf
			DeleteObject(oOk)
			DeleteObject(oNo)
			FA330aUnlock()
			Exit
		EndIf
		
		nQtdTit := 0
		nOpca := 0
		
		If cOrigem $ "MATA465#COMPENSANCC"
			cLote	:=	cLoteFat
		EndIf
		
		If !lAutomato
			aSize := MsAdvSize(,.F.,400)
			DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 to aSize[6],aSize[5] of oMainWnd PIXEL
			oDLg:lMaximized := .T.
			oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20,.T.,.T. )
			oPanel:Align := CONTROL_ALIGN_TOP
			
			If cPaisLoc != "RUS"
				@003,005 Say STR0073 + Pad(Getmv("MV_SIMB"+Alltrim(STR(nMoeda))),4)  PIXEL Of oPanel  // "Compensaçäo de Titulos - Valores expressos em "
			Else
				@003,005 Say STR0109 + SE1->E1_PREFIXO + " - " + SE1->E1_NUM + STR0110 + SE1->E1_NOMCLI PIXEL Of oPanel
			EndIf
			
			//Montando cabecalho do list box³
			If cPaisLoc == "BRA"
				If mv_par02 == 2 // Considera Cliente == Não
					nPosPis 	:= 17
					nPosCof 	:= 18
					nPosCsl 	:= 19
					nPosIrf 	:= 20
					nPosBPCC 	:= 27
					nPosBPCR 	:= 28
					nPosBIRF 	:= 29
					nPosxRet	:= 30
					nPosVa		:= If(__lMotRet,31,30)
					If __lMotRet
						@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
							HEADER "",;						//01
							STR0006,;						//02"Prefixo"
							STR0007,;						//03"Número"
							STR0008,;						//04"Parcela"
							STR0009,;						//05"Tipo"
							STR0011,;						//06"Loja"
							STR0016,;						//07"Saldo do t¡tulo"
							STR0017,;						//08"Valor compensado"
							STR0064,;						//09"Limite de compensação"
							STR0049,;						//10"Acréscimos"
							STR0050,;						//11"Decréscimos"
							STR0125,;						//12"Valores Acessórios"
							STR0046,;						//13"Cliente/Loja"
							STR0041,;						//14"Nome do Cliente"
							Rtrim(RetTitle("A1_CGC")),;		//15"CGC do Cliente"
							Rtrim(RetTitle("E1_HIST")),;	//16"Historico"
							RetTitle("E1_FILIAL"),; 		//17"FILIAL"
							RetTitle("E1_PIS"),;			//18
							RetTitle("E1_COFINS"),;			//19
							RetTitle("E1_CSLL"),; 			//20
							RetTitle("E1_IRRF"),;			//21
							STR0126;						//22"Retenções"
							COLSIZES 12,;															//01
							GetTextWidth(0,"BBBBB"),;												//02
							GetTextWidth(0,"BBBBBBB"),;												//03
							GetTextWidth(0,"BBBB"),;												//04
							GetTextWidth(0,"BBB"),;													//05
							GetTextWidth(0,"BBB"),;													//06
							GetTextWidth(0,"BBBBBBBBB"),;											//07
							GetTextWidth(0,"BBBBBBBBB"),;											//08
							GetTextWidth(0,"BBBBBBBBBB"),;											//09
							GetTextWidth(0,"BBBBBBBBB"),;											//10
							GetTextWidth(0,"BBBBBBBBB"),;											//11
							GetTextWidth(0,"BBBBBBBBB"),;											//12
							GetTextWidth(0,"BBBBBBBBB"),;											//13
							GetTextWidth(0,"BBBBBBBBBBB"),;											//14
							GetTextWidth(0,"BBBBBBBBBBBBBBBBBB"),;									//15
							GetTextWidth(0,"BBBBBB"),;												//16
							GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 ))),;	//17
							GetTextWidth(0,"BBBBBB"),;												//18
							GetTextWidth(0,"BBBBBB"),;												//19
							GetTextWidth(0,"BBBBBB"),;												//20
							GetTextWidth(0,"BBBBBB"),;												//21
							GetTextWidth(0,"BBBBBB");												//22
							SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
					Else
						@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
							HEADER "",;					//01
							STR0006,;					//02"Prefixo"
							STR0007,;					//03"N£mero"
							STR0008,;					//04"Parcela"
							STR0009,;					//05"Tipo"
							STR0011,;					//06"Loja"
							STR0016,;					//07"Saldo do t¡tulo"
							STR0017,;					//08"Valor compensado"
							STR0064,;					//09"Limite de compensação"
							STR0049,;					//10"Acréscimos"
							STR0050,;					//11"Decréscimos"
							STR0125,;					//12"Valores Acessórios"
							STR0046,;					//13"Cliente/Loja"
							STR0041,;					//14"Nome do Cliente"
							Rtrim(RetTitle("A1_CGC")),; //15"CGC do Cliente"
							Rtrim(RetTitle("E1_HIST")),;//16Historico
							RetTitle("E1_FILIAL"),;		//17FILIAL
							RetTitle("E1_PIS"),;		//18
							RetTitle("E1_COFINS"),;		//19
							RetTitle("E1_CSLL"),;		//20
							RetTitle("E1_IRRF");		//21
							COLSIZES 12,;															//01
							GetTextWidth(0,"BBBBB"),;												//02
							GetTextWidth(0,"BBBBBBB"),;												//03
							GetTextWidth(0,"BBBB"),;												//04
							GetTextWidth(0,"BBB"),;													//05
							GetTextWidth(0,"BBB"),;													//06
							GetTextWidth(0,"BBBBBBBBB"),;											//07
							GetTextWidth(0,"BBBBBBBBB"),;											//08
							GetTextWidth(0,"BBBBBBBBBB"),;											//09
							GetTextWidth(0,"BBBBBBBBB"),;											//10
							GetTextWidth(0,"BBBBBBBBB"),;											//11
							GetTextWidth(0,"BBBBBBBBB"),;											//12
							GetTextWidth(0,"BBBBBBBBB"),;											//13
							GetTextWidth(0,"BBBBBBBBBBB"),;											//14
							GetTextWidth(0,"BBBBBBBBBBBBBBBBBB"),;									//15
							GetTextWidth(0,"BBBBBB"),;												//16
							GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 ))),;	//17
							GetTextWidth(0,"BBBBBB"),;												//18
							GetTextWidth(0,"BBBBBB"),;												//19
							GetTextWidth(0,"BBBBBB"),;												//20
							GetTextWidth(0,"BBBBBB");												//21
							SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
					EndIf
					If GetFinLGPD()
						oTitulo:aObfuscatedCols := {	.F., ;
														.F., ;
														.F., ;
														.F., ;
														.F., ; // 5
														.F., ;
														.F., ;
														.F., ;
														.F., ;
														.F., ; // 10
														.F., ;
														.F., ;
														.F., ;
														RetGlbLGPD('E1_NOMCLI') , ;
														RetGlbLGPD('A1_CGC') , ; // 15
														RetGlbLGPD('E1_HIST'), ;
														.F., ;
														.F., ;
														.F., ;
														.F., ; // 20
														.F., ;
														.F., }
					EndIf													
					
					oTitulo:SetArray(aTitulos)
					oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;
						aTitulos[oTitulo:nAt,1],;//Prefixo
						aTitulos[oTitulo:nAt,2],;//Numero
						aTitulos[oTitulo:nAt,3],;//Parcela
						aTitulos[oTitulo:nAt,4],;//Tipo
						aTitulos[oTitulo:nAt,5],;//Loja
						aTitulos[oTitulo:nAt,6],;//Saldo do Titulo
						If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,__cPiE1Sld)),;//Saldo Compensar
						aTitulos[oTitulo:nAt,25],;//Limite de Compensacao
						aTitulos[oTitulo:nAt,13],;//Acréscimos
						aTitulos[oTitulo:nAt,14],;//Decréscimos
						aTitulos[oTitulo:nAt,nPosVa],;//Valores Acessórios
						aTitulos[oTitulo:nAt,10],;//CLiente+Loja
						aTitulos[oTitulo:nAt,11],;//Nome CLiente
						aTitulos[oTitulo:nAt,12],;//CGC
						aTitulos[oTitulo:nAt,15],;//Historico
						aTitulos[oTitulo:nAt,16],;//Filial
						aTitulos[oTitulo:nAt,17],;//Pis
						aTitulos[oTitulo:nAt,18],;//Cofins
						aTitulos[oTitulo:nAt,19],;//Csll
						aTitulos[oTitulo:nAt,20],;//Irrf
						If(__lMotRet,aTitulos[oTitulo:nAt,30],Nil)}}//Motor de Retenções
		
				Else // Considera Cliente == Sim
					nPosPis		:= 14
					nPosCof		:= 15
					nPosCsl		:= 16
					nPosIrf		:= 17
					nPosBPCC 	:= 24
					nPosBPCR 	:= 25
					nPosBIRF 	:= 26
					nPosxRet	:= 27
					nPosVa		:= If(__lMotRet,28,27)
					If __lMotRet
						@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
							HEADER "",;					//01
							STR0006,;					//02"Prefixo"
							STR0007,;					//03"N£mero"
							STR0008,;					//04"Parcela"
							STR0009,;					//05"Tipo"
							STR0011,;					//06"Loja"
							STR0016,;					//07"Saldo do t¡tulo"
							STR0017,;					//08"Valor compensado"
							STR0064,;					//09"Limite de compensação"
							STR0049,;					//10"Acréscimos"
							STR0050,;					//11"Decréscimos"
							STR0125,;					//12"Valores Acessórios"
							Rtrim(RetTitle("E1_HIST")),;//13Historico
							RetTitle("E1_FILIAL"),; 	//14FILIAL
							RetTitle("E1_PIS"),; 		//15
							RetTitle("E1_COFINS"),; 	//16
							RetTitle("E1_CSLL"),; 		//17
							RetTitle("E1_IRRF"),; 		//18
							STR0126;					//19"Retenções"
							COLSIZES 12,;															//01
							GetTextWidth(0,"BBBBB"),;												//02
							GetTextWidth(0,"BBBBBBB"),;												//03
							GetTextWidth(0,"BBBB"),;												//04
							GetTextWidth(0,"BBB"),;													//05
							GetTextWidth(0,"BBB"),;													//06
							GetTextWidth(0,"BBBBBBBBB"),;											//07
							GetTextWidth(0,"BBBBBBBBB"),;											//08
							GetTextWidth(0,"BBBBBBBBBB"),;											//09
							GetTextWidth(0,"BBBBBBBBB"),;											//10
							GetTextWidth(0,"BBBBBBBBB"),;											//11
							GetTextWidth(0,"BBBBBBBBB"),;											//12
							GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB"),;								//13
							GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 ))),;	//14
							GetTextWidth(0,"BBBBBB"),;												//15
							GetTextWidth(0,"BBBBBB"),;												//16
							GetTextWidth(0,"BBBBBB"),;												//17
							GetTextWidth(0,"BBBBBB"),;												//18
							GetTextWidth(0,"BBBBBB");												//19
							SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
					Else
						@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
							HEADER "",;					//01
							STR0006,;					//02"Prefixo"
							STR0007,;					//03"N£mero"
							STR0008,;					//04"Parcela"
							STR0009,;					//05"Tipo"
							STR0011,;					//06"Loja"
							STR0016,;					//07"Saldo do t¡tulo"
							STR0017,;					//08"Valor compensado"
							STR0064,;					//09"Limite de compensação"
							STR0049,;					//10"Acréscimos"
							STR0050,;					//11"Decréscimos"
							STR0125,;					//12"Valores Acessórios"
							Rtrim(RetTitle("E1_HIST")),;//13Historico
							RetTitle("E1_FILIAL"),; 	//14FILIAL
							RetTitle("E1_PIS"),; 		//15
							RetTitle("E1_COFINS"),; 	//16
							RetTitle("E1_CSLL"),; 		//17
							RetTitle("E1_IRRF"); 		//18
							COLSIZES 12,;															//01
							GetTextWidth(0,"BBBBB"),;												//02
							GetTextWidth(0,"BBBBBBB"),;												//03
							GetTextWidth(0,"BBBB"),;												//04
							GetTextWidth(0,"BBB"),;													//05
							GetTextWidth(0,"BBB"),;													//06
							GetTextWidth(0,"BBBBBBBBB"),;											//07
							GetTextWidth(0,"BBBBBBBBB"),;											//08
							GetTextWidth(0,"BBBBBBBBBB"),;											//09
							GetTextWidth(0,"BBBBBBBBB"),;											//10
							GetTextWidth(0,"BBBBBBBBB"),;											//11
							GetTextWidth(0,"BBBBBBBBB"),;											//12
							GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB"),;								//13
							GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 ))),;	//14
							GetTextWidth(0,"BBBBBB"),;												//15
							GetTextWidth(0,"BBBBBB"),;												//16
							GetTextWidth(0,"BBBBBB"),;												//17
							GetTextWidth(0,"BBBBBB");												//18
							SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
					EndIf
					
					oTitulo:SetArray(aTitulos)
					oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;//Flag
						aTitulos[oTitulo:nAt,1],;//Prefixo
						aTitulos[oTitulo:nAt,2],;//Numero
						aTitulos[oTitulo:nAt,3],;//Parcela
						aTitulos[oTitulo:nAt,4],;//Tipo
						aTitulos[oTitulo:nAt,5],;//Loja
						aTitulos[oTitulo:nAt,6],;//Saldo do Titulo
						If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,__cPiE1Sld)),;//Valor Compensado
						aTitulos[oTitulo:nAt,22],;//Limite de Compensacao
						aTitulos[oTitulo:nAt,10],;//Acrescimos
						aTitulos[oTitulo:nAt,11],;//Decréscimos
						aTitulos[oTitulo:nAt,nPosVa],;//Valores Acessórios
						aTitulos[oTitulo:nAt,12],;//Historico
						aTitulos[oTitulo:nAt,13],;//Filial
						aTitulos[oTitulo:nAt,14],;//Pis
						aTitulos[oTitulo:nAt,15],;//Cofins
						aTitulos[oTitulo:nAt,16],;//Csll
						aTitulos[oTitulo:nAt,17],;//Irrf
						If(__lMotRet,aTitulos[oTitulo:nAt,27],Nil)}}//Motor de Retenções
				EndIf
			ElseIf cPaisLoc == "EUA"

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se na listagem de titulos nao considerar o cliente original do titulo selecionado, mostra o cgc |
				//|e o nome dos clientes referentes a cada titulo (MV_PAR02==2)                                    |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If MV_PAR02 == 2
					//Adiciona Nome e CGC do cliente ao cabecalho
					nPosPis 	:= 17
					nPosCof 	:= 18
					nPosCsl 	:= 19
					nPosIrf 	:= 20
					nPosBPCC 	:= 27
					nPosBPCR 	:= 28
					nPosBIRF 	:= 29
					@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
						HEADER "",STR0006,;  //"Prefixo"
						STR0007,;  //"N£mero"
						STR0008,;  //"Parcela"
						STR0009,;  //"Tipo"
						STR0011,;  //"Loja"
						STR0016,;  //"Saldo do t¡tulo"
						STR0017,;  //"Valor compensado"
						STR0048,;  //"Acréscimos"
						STR0049,;  //"Decréscimos"
						STR0038,;  //"Moeda"
						STR0039,;  //"Emissao"
						STR0041,;  //"Nome do Cliente"
						Rtrim(RetTitle("A1_CGC")),;  //"CGC do Cliente"
						Rtrim(RetTitle("E1_HIST")),; //Historico
						RetTitle("E1_FILIAL"); //FILIAL
						COLSIZES 12,GetTextWidth(0,"BBBBB"),GetTextWidth(0,"BBBBBBB"),;
						GetTextWidth(0,"BBBB"),GetTextWidth(0,"BBB"),;
						GetTextWidth(0,"BBB"), GetTextWidth(0,"BBBBBBBBB"),;
						GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBB"),;
						GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
						GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBB"), GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB"),GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 )));
						SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
						oTitulo:SetArray(aTitulos)
						oTitulo:bLine := { || {If(	aTitulos[oTitulo:nAt,8],oOk,oNo),;
													aTitulos[oTitulo:nAt,1],;
													aTitulos[oTitulo:nAt,2],;
													aTitulos[oTitulo:nAt,3],;
													aTitulos[oTitulo:nAt,4],;
													aTitulos[oTitulo:nAt,5],;
													aTitulos[oTitulo:nAt,6],;
													If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,__cPiE1Sld)),;
													aTitulos[oTitulo:nAt,13],;
													aTitulos[oTitulo:nAt,14],;
													aTitulos[oTitulo:nAt,9],;
													aTitulos[oTitulo:nAt,10],;
													aTitulos[oTitulo:nAt,11],;
													aTitulos[oTitulo:nAt,12],;
													aTitulos[oTitulo:nAt,15],;
													aTitulos[oTitulo:nAt,16]}}
					//---
				Else
					//Considera o cliente original do titulo seleionado, nao mostra o nome do cliente
					nPosPis		:= 14
					nPosCof		:= 15
					nPosCsl		:= 16
					nPosIrf		:= 17
					nPosBPCC 	:= 24
					nPosBPCR 	:= 25
					nPosBIRF 	:= 26
					@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
						HEADER "",STR0006,;  //"Prefixo"
						STR0007,;  //"N£mero"
						STR0008,;  //"Parcela"
						STR0009,;  //"Tipo"
						STR0011,;  //"Loja"
						STR0016,;  //"Saldo do t¡tulo"
						STR0017,;   //"Valor compensado"
						STR0048,; //"Acréscimos"
						STR0049,; //"Decréscimos"
						STR0038,;   //"Moeda"
						STR0039,;   //"Emissao"
						RetTitle("E1_FILIAL"); //FILIAL
						COLSIZES 12,GetTextWidth(0,"BBBBB"),GetTextWidth(0,"BBBBBBB"),;
						GetTextWidth(0,"BBBB"),GetTextWidth(0,"BBB"),GetTextWidth(0,"BBB"),;
						GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
						GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
						GetTextWidth(0,"BBBBB"),GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 )));
						SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
						oTitulo:SetArray(aTitulos)
						oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;
						aTitulos[oTitulo:nAt,1],;
						aTitulos[oTitulo:nAt,2],;
						aTitulos[oTitulo:nAt,3],;
						aTitulos[oTitulo:nAt,4],;
						aTitulos[oTitulo:nAt,5],;
						aTitulos[oTitulo:nAt,6],;
						If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,__cPiE1Sld)),;
						aTitulos[oTitulo:nAt,11],;
						aTitulos[oTitulo:nAt,12],;
						aTitulos[oTitulo:nAt,9],;
						aTitulos[oTitulo:nAt,10],;
						aTitulos[oTitulo:nAt,13]}}

				EndIf
			ElseIf cPaisLoc == "RUS"
				If MV_PAR02 == 2
					@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
						HEADER "",RetTitle("E1_FILIAL"),; //FILIAL
						STR0006,;   //"Prefixo"
						STR0007,;   //"N?mero"
						STR0008,;   //"Parcela"
						STR0009,;   //"Tipo"
						STR0038,;   //"Moeda"
						STR0103,;	//Moeda code
						STR0016,;   //"Saldo do t?tulo"
						STR0017,;   //"Valor compensado"
						STR0104,;	//Cust. code
						STR0011,;   //"Loja"
						STR0041,;   //"Nome do Cliente"
						Rtrim(RetTitle("E1_HIST")),; //Historico
						STR0105,;	//Contr. code
						STR0039,;   //"Emissao"
						STR0106,;	// Bill Value
						STR0107,;	//Vl R$
						STR0108;	// Conv. unit
						COLSIZES 12,GetTextWidth(0,"BBBBBB"),GetTextWidth(0,"BBB"),;
						GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,"BB"),GetTextWidth(0,"BBB"),;
						GetTextWidth(0,"BB"),GetTextWidth(0,"BBB"),;
						GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
						GetTextWidth(0,"BBBBBB"),GetTextWidth(0,"BB"),GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"),;
						GetTextWidth(0,"BBBBBBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBBB"),;
						GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBBBB"),;
						GetTextWidth(0,"B"),;
						SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
						oTitulo:SetArray(aTitulos)
						oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;
						aTitulos[oTitulo:nAt,16],aTitulos[oTitulo:nAt,1],;
						aTitulos[oTitulo:nAt,2],aTitulos[oTitulo:nAt,3],;
						aTitulos[oTitulo:nAt,4],aTitulos[oTitulo:nAt,9],;
						aTitulos[oTitulo:nAt,23],aTitulos[oTitulo:nAt,6],;
						If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,PesqPict("SE1","E1_SALDO"))),aTitulos[oTitulo:nAt,18],;
						aTitulos[oTitulo:nAt,5],aTitulos[oTitulo:nAt,11],;
						aTitulos[oTitulo:nAt,15],aTitulos[oTitulo:nAt,19],;
						aTitulos[oTitulo:nAt,10],aTitulos[oTitulo:nAt,20],;
						aTitulos[oTitulo:nAt,21],aTitulos[oTitulo:nAt,22]}}
				Else
					@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
						HEADER "",RetTitle("E1_FILIAL"),; //FILIAL
						STR0006,;   //"Prefixo"
						STR0007,;   //"N?mero"
						STR0008,;   //"Parcela"
						STR0009,;   //"Tipo"
						STR0038,;   //"Moeda"
						STR0103,;   //Moeda code
						STR0016,;   //"Saldo do t?tulo"
						STR0017,;   //"Valor compensado"
						STR0104,;	//Cust. code
						STR0011,;   //"Loja"
						STR0105,;	//Contr. code
						STR0039,;   //"Emissao"
						STR0106,;   // Bill Value
						STR0107,;   //Vl R$
						STR0108;    // Conv. unit
						COLSIZES 12,GetTextWidth(0,"BBBBBB"),GetTextWidth(0,"BBB"),;
						GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,"BB"),GetTextWidth(0,"BBB"),;
						GetTextWidth(0,"BB"),GetTextWidth(0,"BBB"),;
						GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
						GetTextWidth(0,"BBBBBB"),GetTextWidth(0,"BB"),GetTextWidth(0,"BBBBBBBBBBBBBBB"),;
						GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBBBB"),;
						GetTextWidth(0,"B"),;
						SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
						oTitulo:SetArray(aTitulos)
						oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;
						aTitulos[oTitulo:nAt,13],aTitulos[oTitulo:nAt,1],;
						aTitulos[oTitulo:nAt,2],aTitulos[oTitulo:nAt,3],;
						aTitulos[oTitulo:nAt,4],aTitulos[oTitulo:nAt,9],;
						aTitulos[oTitulo:nAt,20],aTitulos[oTitulo:nAt,6],;
						If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,PesqPict("SE1","E1_SALDO"))),aTitulos[oTitulo:nAt,15],;
						aTitulos[oTitulo:nAt,5],aTitulos[oTitulo:nAt,16],;
						aTitulos[oTitulo:nAt,10],aTitulos[oTitulo:nAt,17],;
						aTitulos[oTitulo:nAt,18],aTitulos[oTitulo:nAt,19]}}
				EndIf
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se na listagem de titulos nao considerar o cliente original do titulo selecionado, mostra o cgc |
				//|e o nome dos clientes referentes a cada titulo (MV_PAR02==2)                                    |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If MV_PAR02 == 2
					//Adiciona Nome e CGC do cliente ao cabecalho
					nPosPis 	:= 17
					nPosCof 	:= 18
					nPosCsl 	:= 19
					nPosIrf 	:= 20
					nPosBPCC 	:= 27
					nPosBPCR 	:= 28
					nPosBIRF 	:= 29
					@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
						HEADER "",STR0006,;  //"Prefixo"
						STR0007,;  //"N£mero"
						STR0008,;  //"Parcela"
						STR0009,;  //"Tipo"
						STR0011,;  //"Loja"
						STR0016,;  //"Saldo do t¡tulo"
						STR0017,;   //"Valor compensado"
						STR0048,; //"Acréscimos"
						STR0049,; //"Decréscimos"
						STR0038,;   //"Moeda"
						STR0039,;   //"Emissao"
						STR0041,;  //"Nome do Cliente"
						Rtrim(RetTitle("A1_CGC")),; //"CGC do Cliente"
						Rtrim(RetTitle("E1_HIST")),; //Historico
						RetTitle("E1_FILIAL"); //FILIAL
						COLSIZES 12,GetTextWidth(0,"BBBBB"),GetTextWidth(0,"BBBBBBB"),;
						GetTextWidth(0,"BBBB"),GetTextWidth(0,"BBB"),;
						GetTextWidth(0,"BBB"), GetTextWidth(0,"BBBBBBBBB"),;
						GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBB"),;
						GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
						GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBB"), GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB"),GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 )));
						SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
						oTitulo:SetArray(aTitulos)
						oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;
						aTitulos[oTitulo:nAt,1],aTitulos[oTitulo:nAt,2],;
						aTitulos[oTitulo:nAt,3],aTitulos[oTitulo:nAt,4],;
						aTitulos[oTitulo:nAt,5],aTitulos[oTitulo:nAt,6],;
						If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,__cPiE1Sld)),aTitulos[oTitulo:nAt,13],;
						aTitulos[oTitulo:nAt,14],aTitulos[oTitulo:nAt,9],;
						aTitulos[oTitulo:nAt,10],aTitulos[oTitulo:nAt,11],;
						aTitulos[oTitulo:nAt,12], aTitulos[oTitulo:nAt,15],aTitulos[oTitulo:nAt,16]}}
					//---
				Else
					//Considera o cliente original do titulo seleionado, nao mostra o nome do cliente
					nPosPis		:= 14
					nPosCof		:= 15
					nPosCsl		:= 16
					nPosIrf		:= 17
					nPosBPCC 	:= 24
					nPosBPCR 	:= 25
					nPosBIRF 	:= 26
					@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
						HEADER "",STR0006,;  //"Prefixo"
						STR0007,;  //"N£mero"
						STR0008,;  //"Parcela"
						STR0009,;  //"Tipo"
						STR0011,;  //"Loja"
						STR0016,;  //"Saldo do t¡tulo"
						STR0017,;   //"Valor compensado"
						STR0048,; //"Acréscimos"
						STR0049,; //"Decréscimos"
						STR0038,;   //"Moeda"
						STR0039,;   //"Emissao"
						RetTitle("E1_FILIAL"); //FILIAL
						COLSIZES 12,GetTextWidth(0,"BBBBB"),GetTextWidth(0,"BBBBBBB"),;
						GetTextWidth(0,"BBBB"),GetTextWidth(0,"BBB"),GetTextWidth(0,"BBB"),;
						GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
						GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
						GetTextWidth(0,"BBBBB"),GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 )));
						SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
						oTitulo:SetArray(aTitulos)
						oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;
						aTitulos[oTitulo:nAt,1],aTitulos[oTitulo:nAt,2],;
						aTitulos[oTitulo:nAt,3],aTitulos[oTitulo:nAt,4],;
						aTitulos[oTitulo:nAt,5],aTitulos[oTitulo:nAt,6],;
						If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,__cPiE1Sld)),aTitulos[oTitulo:nAt,11],;
						aTitulos[oTitulo:nAt,12],aTitulos[oTitulo:nAt,9],;
						aTitulos[oTitulo:nAt,10],aTitulos[oTitulo:nAt,13]}}
					//---
				EndIf
				//----
			EndIf
		EndIf
		
		If !lAutomato
			If !cPaisLoc $ "BRA|RUS"
				oTitulo:bHeaderClick := {|oObj,nCol| Iif( nCol == 1, fMarkAll( @aTitulos, @nValTot ), Nil ), oTitulo:Refresh(), oGet01:Refresh()}
			EndIf
			
			oTitulo:Align := CONTROL_ALIGN_ALLCLIENT
			//---
			If cPaisLoc == "RUS"
				@ 4, 353 SAY STR0092 PIXEL OF oPanel SIZE 70,7
				@ 4, 403 MSGET nVlrCompe PICTURE "@E 999,999,999.99" WHEN .F.	PIXEL OF oPanel SIZE 70,7
				@ 4, 503 SAY STR0045 PIXEL OF oPanel SIZE 70,7
				@ 4, 553 MSGET oGet01 VAR nValTot PICTURE "@E 999,999,999.99" WHEN .F. PIXEL OF oPanel SIZE 70,7
			Else			
				@  4, 353 SAY STR0045 PIXEL OF oPanel SIZE 70,7
				@  4, 403 MSGET oGet01 VAR nValTot PICTURE "@E 999,999,999.99" HASBUTTON WHEN .F. PIXEL OF oPanel SIZE 70,7
			EndIf

			If lF330ATLIS
				ExecBlock("F330ATLIS",.F.,.F., { @oPanel , 1, nValTot , nValor } )
			EndIf
		EndIf
		
		If !lPanelFin  //Chamado pelo Painel Financeiro
			If !lAutomato
				oPanel2 := TPanel():New(0,0,'',oDlg, oDlg:oFont, .T., .T.,, ,20,20,.T.,.T. )
				oPanel2:Align := CONTROL_ALIGN_BOTTOM

				@  4, 08   BUTTON STR0124 SIZE 50,11 ACTION (F330Button(lPccBxCr,oTitulo,oGet01,.T.)) OF oPanel2 PIXEL
				@  4, 65   BUTTON STR0044 SIZE 50,11 ACTION (F330Button(lPccBxCr,oTitulo,oGet01,.F.)) OF oPanel2 PIXEL
				@  4, 122  BUTTON STR0001 SIZE 50,11 ACTION PesqListBox(@oTitulo,aTitulos) OF oPanel2 PIXEL
				//VA: Adiciona a consulta do VA
				If __l330Va
					@  4, 179  BUTTON STR0125 SIZE 50,11 ACTION FA330VACON(aTitulos[oTitulo:nAt]) OF oPanel2 PIXEL
				EndIf
				
				If cPaisLoc == "RUS"
					If FindFunction("FA330Filt")
						@  4, 179 BUTTON STR0098 SIZE 50,11 ACTION FA330Filt(@oTitulo,@aTitulos,cNumCont,lAutomato,@oOk,@oNo,cVarQ,oPanel,dEmissao,cOrigem,lCredito,aNumLay,cNumCont) OF oPanel2 PIXEL
					EndIf	
					If FindFunction("FA330Unfil")
						@  4, 236 BUTTON STR0100 SIZE 50,11 ACTION FA330Unfil(@oTitulo,@aTitulos,lAutomato,@oOk,@oNo,dEmissao,cOrigem,lCredito,aNumLay,cNumCont) OF oPanel2 PIXEL
					EndIf
					If FindFunction("FA330AutMk")
						@  4, 293 BUTTON STR0091 SIZE 50,11 ACTION FA330AutMk(@oTitulo,@aTitulos,lAutomato,@oOk,@oNo,dEmissao,cOrigem,lCredito,aNumLay,cNumCont) OF oPanel2 PIXEL
					EndIf	
					If FindFunction("FA330Sort")
						@  4, 350 BUTTON STR0094 SIZE 50,11 ACTION FA330Sort(@oTitulo,@aTitulos,cNumCont,lAutomato,@oOk,@oNo,@oPanel,@nValTot,dEmissao,cOrigem,lCredito,aNumLay) OF oPanel2 PIXEL	
					EndIf	
					If FindFunction("FA330Unch")
						@  4, 407 BUTTON STR0138 SIZE 50,11 ACTION FA330Unch(@oTitulo,@aTitulos,oGet01,@oOk,@oNo) OF oPanel2 PIXEL	
					EndIf	
				EndIf

				If lF330BOTON
					ExecBlock("F330BOTON",.F.,.F.)
				EndIf

				DEFINE SBUTTON FROM 4,Iif(cPaisLoc != "RUS",325,482) TYPE 1 ACTION (nValor := nVlrCompe,nOpca := 1,IF(Fa330OK(@nValTot,.F.,lPccBxCR),oDlg:End(),nOpca:=0)) ENABLE OF oPanel2 PIXEL
				If cOrigem != "LOJA800"
					DEFINE SBUTTON FROM 4,Iif(cPaisLoc != "RUS",360,517) TYPE 2 ACTION oDlg:End() ENABLE OF oPanel2 PIXEL
				EndIf
			EndIf

		Else
			If !lAutomato
				aButtonTxt := {}
				AADD(aButtonTxt,{STR0124,STR0124, {||F330Button(lPccBxCr,oTitulo,oGet01,.T.)}})
				AADD(aButtonTxt,{STR0061,STR0044, {||F330Button(lPccBxCr,oTitulo,oGet01,.F.)}})
				AADD(aButtonTxt,{STR0001,STR0001, {||PesqListBox(@oTitulo,aTitulos)}})
			EndIf
		EndIf
		
		//Metricas - Carregamento da tela de seleção
		If !lAutomato .and. __lMetric
			nRegistros := Len(aTitulos)

			If nRegistros > 0
				nFim := Seconds() - nInicio
				nFim := nFim / nRegistros

				SetFunName(__cFunMet)
				FwCustomMetrics():setAverageMetric(Alltrim(ProcName())+" - TempoEntrada", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
				SetFunName(__cFunBkp)
			Endif
		Endif
		
		If lPanelFin  //Chamado pelo Painel Financeiro
			If cOrigem != "LOJA800"
			ACTIVATE MSDIALOG oDlg ON INIT (oTitulo:Refresh(), FaMyBar(oDlg,;
				{||nValor := nVlrCompe,nOpca := 1,IF(Fa330OK(@nValTot,.F.,lPccBxCR),oDlg:End(),nOpca:=0)},;
					{||oDlg:End()},,aButtonTxt))
			Else
			ACTIVATE MSDIALOG oDlg ON INIT (oTitulo:Refresh(), FaMyBar(oDlg,;
				{||nValor := nVlrCompe,nOpca := 1,IF(Fa330OK(@nValTot,.F.,lPccBxCR),oDlg:End(),nOpca:=0)},;
					,,aButtonTxt))
			EndIf
		Else
			If !lAutomato
				If !lCheck
					fDsMarkAll(@aTitulos, @nValTot)
				EndIf
				ACTIVATE MSDIALOG oDlg CENTERED ON INIT (oTitulo:Refresh())
			Else

				If __lGetParA .or. __lCmpM460
					nLenAuto := Len(aRetAuto)

					If __lCmpM460 .and. nLenAuto > 0
						aRetAuto := aClone(aRetAuto)
					Else
						If __lGetParA .and. nLenAuto == 0
							aRetAuto := GetParAuto("FINA330TestCase")
							If ValType(aRetAuto) == "A"
								nLenAuto := Len(aRetAuto)
							EndIf
						Endif

						If (ValType(aRetAuto) != "A" .Or. nLenAuto == 0) .and. !__lCmpM460
							aRetAuto := GetParAuto("JURBXRTestCase") // Casos de testes - Módulo SIGAPFS
						EndIf
					EndIf

					AEval(aTitulos,{|x| x[8] := .F.})

					For nX := 1 to Len(aTitulos)
						For nI := 1 to Len (aRetAuto[2])
							If aTitulos[nX,1] == Padr(aRetAuto[2,nI,1],Len(aTitulos[nX,1])) .AND. ;//Prefixo
								aTitulos[nX,2] == Padr(aRetAuto[2,nI,2],Len(aTitulos[nX,2])) .AND. ;//Titulo
								aTitulos[nX,3] == Padr(aRetAuto[2,nI,3],Len(aTitulos[nX,3])) .AND. ;//Parcela
								aTitulos[nX,4] == Padr(aRetAuto[2,nI,4],Len(aTitulos[nX,4]))        //Tipo
					
								aTitulos[nX,8] := .T.
								If !lSelAuto
									lSelAuto := aTitulos[nX,8]
								EndIf
							EndIf
						Next nI
					Next nX
				
					If lSelAuto
						If Fa330OK(@nValTot,lAutomato,lPccBxCR) 
							nOpcA 		:= 1
							lSelAuto	:= .F.
						EndIf
					EndIf
				EndIf
			EndIf    
		EndIf
		
		//Metricas - Carregamento da tela de seleção
		If lAutomato .and. __lMetric
			nRegistros := Len(aTitulos)
			If nRegistros > 0
				nFim := Seconds() - nInicio
				nFim := nFim / nRegistros

				SetFunName(__cFunMet)
				FwCustomMetrics():setAverageMetric(Alltrim(ProcName())+" - TempoEntrada", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
				SetFunName(__cFunBkp)
			Endif
		Endif
		
		If nOpcA == 1
			//Metricas - Gravação da compensação
			If __lMetric
				nInicio := Seconds()
			Endif
			
			If __lMotRet .And. ( ( nValTot < nSaldo ) .Or. ( lCredito .And. MV_PAR08 == 1 ) )
				aSize( aAuxTitMR, 5 ) 
				aAuxTitMR[1] := SE1->E1_NATUREZ
				aAuxTitMR[2] := SE1->E1_CLIENTE
				aAuxTitMR[3] := SE1->E1_LOJA
				aAuxTitMR[4] := SE1->E1_FILORIG
				aAuxTitMR[5] := SE1->E1_TIPO
			EndIf
			
			If lFa330Cmp
				ExecBlock("FA330Cmp",.F.,.F.)
			EndIf
			
			dDtEmis	:= SE1->E1_EMISSAO
			
			DbSelectArea("SE1")
			nOrdSE1		:= SE1->(IndexOrd())
			SE1->(DbGotop())
			lPadrao		:= VerPadrao(cPadrao)
			VALOR 		:= 0
			ABATIMENTO 	:= 0		//Contabilização do Abatimento
			VARIACAO	:= 0 		//Contabilização da Variação Monetária
			aRegSE1 	:= {}
			aBaixaSE5 	:= {}
			__nQtdTitu  := 0
			lMVRARTIMP  := .F.
			lCondicao   := .F.
			nValorReal  := 0
			nValorEstr  := 0
			nSldAdiant  := 0
			nRecnTitRA  := 0
			nRecnTitNF  := 0
			
			If cPaisLoc == "BRA"
				lMVRARTIMP := SuperGetMv("MV_RARTIMP", .F., "1") == "2"
				
				For nX := 1 To Len( aTitulos )
					If	aTitulos[nX,8] 
						nVTit += Fa330VTit( aTitulos[ nX , 7 ] )
						__nQtdTitu += 1
					EndIf
				Next nX
			EndIf
			
			BEGIN TRANSACTION
				nGravados := 0
				
				For nTit := 1 to Len(aTitulos)
					__nTxMoedD	:= 0
					__nPosTit	:= nTit
					nPos		:= 22
					lCalcIrf    := .F.
					nImposRet   := 0
					nValorReal  := 0
					nValorEstr  := 0
					nSldAdiant  := 0
					__lCalcImp  := .T.
					nImposPen   := 0
					lVMd2ImpRA  := .F.
					
					If MV_PAR02 == 2
						nPos := 25
					Endif
					
					//Caso o titulo esteja selecionado para compensação
					If aTitulos[nTit,8]
						__nQtdTitu := IIf(__nQtdTitu > 1, (__nQtdTitu - 1), __nQtdTitu)
						nGravados  += 1
						
						If lPadrao .And. !lContabil .And. mv_par09 == 1
							nTotal 		:= 0
							lContabil 	:= .t.
							nHdlPrv   	:= HeadProva(cLote, "FINA330", Substr( cUsuario, 7, 6 ), @cArquivo )
						EndIf
						
						DbSelectArea("SE1")
						SE1->(DbGoTo(aRecNo[nTit])) //Posiciona no título de destino

						//Tratamentos para compensação envolvendo moeda estrangeira
						If cPaisLoc == "BRA" .And. (lPccBxCr .Or. lIrPjBxCr) .And. __nMoePart != SE1->E1_MOEDA .And. !cTipoTit $ MV_CRNEG .And. !SE1->E1_TIPO $ MV_CRNEG .And. ((__nMoePart == 1) .Or. (SE1->E1_MOEDA ==1))
							nRecnTitRA := IIf(SE1->E1_TIPO $ MVRECANT, aRecNo[nTit], __nRecPart)
							nRecnTitNF := IIf(SE1->E1_TIPO $ MVRECANT, __nRecPart, aRecNo[nTit])
							lVMd2ImpRA := !lMVRARTIMP
							GetVlrMov(nRecnTitRA, nRecnTitNF, aTitulos[nTit,9], lPccBxCr, lIrPjBxCr)
							SE1->(DbGoTo(aRecNo[nTit])) //Posiciona no título de destino
						EndIf
						
						If __lMotRet .And. ( ( nValTot + Iif(lIrPjBxCr .And. __lIrfMR, Fa330VTit( aTitulos[nTit,nPosIrf] ), 0) + Iif( lPccBxCR , (nPis + nCofins + nCsll), 0) < nSaldo ) .Or. ( SE1->E1_SALDO < nSaldo ) ) .And. Len( aAuxTitMR ) >= 5
							If (__lTCnfgMR := F330VldImp())
								F330CalImp( aAuxTitMR[1], aAuxTitMR[2], aAuxTitMR[3], aAuxTitMR[4], Fa330VTit( aTitulos[nTit,7] ) + Iif( !__lImpEmis, __nImpMR, 0 )+ Iif( lPccBxCR , (nPis + nCofins + nCsll),0) + Iif(lIrPjBxCr .And. __lIrfMR, Fa330VTit( aTitulos[nTit,nPosIrf] ), 0), dDataBase, SE1->E1_TIPO )
								__lTCnfgMR := .F.

								lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
								lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
								lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
								lCalcIssBx 	:= ( __lIssMR .And. __lIssBxMR ) .Or. ( !__lIssMR .And. lIssBxAux )
							EndIf 
						EndIf
						
						AAdd(aRegSE1, aRecNo[nTit])
						cAdiantamento := SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_LOJA)
						lCondicao     :=  MV_PAR08 == 2 .And. SE1->E1_TIPO == MV_CRNEG .And. (nTotCsAbt+nTotPisAbt+nTotCofAbt) != 0
						
						If lCondicao .And. SE1->E1_SALDO > aTitulos[nTit,9] .And. (aTitulos[nTit,9]+nTotAbtIni == F330SldPri(nRecNo))
							//Se o abatimento for composto por algo alem do PCC por ex. um AB-
							If Str(nTotAbtIni,17,2) # Str((nTotCsAbt + nTotPisAbt + nTotCofAbt),17,2)
								//Somar apenas o abatimento a ser desconsiderado (PCC) na compensacao
								aTitulos[nTit,9] := aTitulos[nTit,9] + (nTotCsAbt + nTotPisAbt + nTotCofAbt)
							Else
								//Somar todo o abatimento (formado pelo PCC)
								aTitulos[nTit,9] := aTitulos[nTit,9] + nTotAbtIni
							Endif
						EndIf
						
						//Valor da baixa na moeda 1
						If cPaisLoc == "BRA"
							nValBx := nValRec := aTitulos[nTit,9]
							
							If !__lBq10925 .And. !(__lCredNCC .Or. (aTitulos[nTit,4] $ MV_CRNEG))
								lBxTotal := (nSldTitIni == nValRec)
								
								If !lCredito .And. lRarTimp .And. !(lCredito .Or. (!lCredito .And. !lRarTimp .And. (l330Auto .Or. lBxTotal .Or. (Fa330VTit(aTitulos[nTit,9]) != nValor)))) 
									aTitulos[nTit,9] := nValRec + nTotImpbx
								Endif
							EndIf
							
							If mv_par02 == 1
								nAcresc := Fa330VTit(aTitulos[nTit,10])
								nDecres := Fa330VTit(aTitulos[nTit,11])
							Else
								nAcresc := Fa330VTit(aTitulos[nTit,13])
								nDecres := Fa330VTit(aTitulos[nTit,14])
							EndIf
						Else
							nValBx := Fa330VTit(aTitulos[nTit,7])

							If cPaisLoc != "RUS"
								If mv_par02 == 1
									nAcresc := Fa330VTit(aTitulos[nTit,11])
									nDecres := Fa330VTit(aTitulos[nTit,12])
								Else
									nAcresc := Fa330VTit(aTitulos[nTit,13])
									nDecres := Fa330VTit(aTitulos[nTit,14])
								EndIf
							EndIf						
						EndIf
						
						If lPadrao
							nVlrCmpAux := nValorComp
							If cPaisLoc == "BRA"
								If __nSldConv > 0 .And. (Fa330VTit(aTitulos[nTit,6]) - aTitulos[nTit,9]) == 0.01
									If ((nValorComp + Round(NoRound(xMoeda(Fa330VTit(aTitulos[nTit,6]),nMoeda,1,,3,Fa330Tx2(nMoeda,nTxMoeda)),3),2)) - NoRound(nCntCent,2) ) == __nSldConv
										nValBX := Fa330VTit(aTitulos[nTit,6])
									EndIf
									nValorComp 	+= Round(Round(NoRound(xMoeda(nValBX,nMoeda,1,,3,Fa330Tx2(nMoeda,nTxMoeda)),3),2) - nCntCent, 2 )
								Else
									nValorComp 	+= Round(NoRound(xMoeda(nValBX,nMoeda,1,,3,Fa330Tx2(nMoeda,nTxMoeda)),3),2)
									nCntCent	+= nValBX - NoRound(nValBX,2)
								EndIf
							Else
								nValorComp += xMoeda(nValBX,nMoeda,1,aTitulos[nTit,10],,Fa330Tx2(nMoeda,nTxMoeda))
							EndIf
						EndIf
						
						If lCredito
							nAbatNf := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
						EndIf
						
						nIrrfParc 	:= 0
						
						If __lCalcImp .And. cPaisLoc == "BRA"
							If dDatabase >= dLastPcc
								nValRec := Fa330VTit(aTitulos[nTit,9])
								nValRec := If(__lDizPer .Or. Decimal(nValRec) > 0, FVlDiz(nValRec, nTit, @nValBx), nValRec )
								
								If (!lRartImp .And. !lRaRtImpMR) .And. MV_PAR08 == 1 .And. (((!__lPccMR .And. (aPcc[2] == 0 .Or. aPcc[2] == Nil)) .Or. (__lPccMR .And. __nPisCaMR == 0)) .Or. (SE1->E1_TIPO == MVRECANT .And. SE1->E1_SALDO < nValRec))
									nRecTit := Recno()
									
									If nRecTit == aTitulos[nTit][IIf(mv_par02 == 1, 20, 23)] .And. Val(StrTran(aTitulos[nTit][IIf(mv_par02 == 1, 14, 17)], ",", ".")) != 0										
										If (nValRec + SE1->(E1_PIS+SE1->E1_COFINS+SE1->E1_CSLL) + IIf(lIrPjBxCr, nIrrf, 0) + nAbatNf == SE1->E1_VALOR) .Or. ;
											(nValRec + nPis + nCofins + nCsll + IIf(lIrPjBxCr, nIrrf, 0) + nAbatNf + __nImpMR == SE1->E1_SALDO) .or. ;
											(nValRec == Val(StrTran(StrTran(aTitulos[nTit][25],".", ""),",","."))) // Baixa Total - (Sem BX parciais)
											
											If ValType(aTitulos[nTit,nPosPis]) == "C"
												If FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
													nBasePCC := FBaseImp(nValRec)
													
													If VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
														aPcc := newMinPcc(dBaixa, IIf(nBaseImpos > 0, nBaseImpos, nBasePCC), SE1->E1_NATUREZ, "R", SE1->(E1_CLIENTE+E1_LOJA))
														
														If Len(aPcc) > 4
															__aTitCalc := aPcc[5]
														EndIf
													EndIf
													
													If mv_par02 == 1
														nPis		:= Val(StrTran(StrTran(aTitulos[nTit][14],".", ""),",","."))		  				
														nCofins		:= Val(StrTran(StrTran(aTitulos[nTit][15],".", ""),",","."))
														nCsll		:= Val(StrTran(StrTran(aTitulos[nTit][16],".", ""),",","."))
													Else
														nPis		:= Val(StrTran(StrTran(aTitulos[nTit][17],".", ""),",","."))		  				
														nCofins		:= Val(StrTran(StrTran(aTitulos[nTit][18],".", ""),",","."))
														nCsll		:= Val(StrTran(StrTran(aTitulos[nTit][19],".", ""),",","."))
													EndIf
												EndIf							
											Else
												nPis		:= 	aTitulos[nTit][14]
												nCofins		:=	aTitulos[nTit][15]
												nCsll		:=  aTitulos[nTit][16]
											EndIf
										ElseIf !__lPccMR .And. FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
											nValRec  := xMoeda(nValRec, nMoeda, 1, dDataBase, __nCasDec, __nTxMoedP, 0)
											nBasePCC := FBaseImp(nValRec)
											
											If VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
												aPcc		:= newMinPcc(dBaixa, IIf(nBaseImpos > 0, nBaseImpos, nBasePCC), SE1->E1_NATUREZ, "R", SE1->E1_CLIENTE+SE1->E1_LOJA)
												nPis		:= aPcc[2]
												nCofins		:= aPcc[3]
												nCsll		:= aPcc[4]
												
												If Len(aPcc) > 4 
													__aTitCalc := aPcc[5]
												EndIf
											EndIf
										EndIf
									Else
										nVTit := 0
										
										For nX:=1 to Len(aTitulos) // verifica todos os títulos ja marcados
											If aTitulos[nX,8] 
												nVTit += Fa330VTit(aTitulos[nX,7])
											EndIf
										Next
										
										aAreaParc	:= GetArea()
										SE1->(DbGoto(nRecno))
										
										If !lCredito
											nAltVal := FbaseImp(aTitulos[nTit,9])
											
											If !__lPccMR
												If !Empty(SE1->E1_NUMBOR)
													lRetImp:= VLDBOR(SE1->E1_NUMBOR,"R")
												EndIf
												
												nTotalTit 	+= nValBx
												
												If lRetImp .And. lPccBxCr .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
													If nBaseImpos <= 0 .And. lMVRARTIMP .And. lPccBxCr .And. SE1->E1_MOEDA > 1
														lCalcIrf   := .T.
														nBaseImpos := nValBx
														
														If nSaldo == nTotalTit .And. (nImposRet  := ImposRetid(FinBuscaFK7(SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), "SE1", SE1->E1_FILORIG))) > 0														
															nBaseImpos += nImposRet
														EndIf
														
														nBaseImpos := Round(xMoeda(nBaseImpos, SE1->E1_MOEDA, 1, dBaixa, __nCasDec, SE1->E1_TXMOEDA), 2)
													EndIf
													
													aPcc		:= newMinPcc(dBaixa, IIf(nBaseImpos > 0, nBaseImpos, nAltVal), SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
													nPis		:= aPcc[2]
													nCofins		:= aPcc[3]
													nCsll		:= aPcc[4]
													
													If lCalcIrf
														nIrrf := FCaIrBxCR(nBaseImpos)
													EndIf
												EndIf
											EndIf
										ElseIf lPccBxCr .And. lCredito .And. ( ( !__lPccMR .and. !lRartimp ) .Or. ( __lPccMR .And. !__lRarTPcc) ) .And. (nBaseImpos > 0) .Or. (nBaseImpos == 0 .And. (nPis+nCofins+nCsll) == 0)
											If !__lPccMR .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
												aPcc		:= newMinPcc(dBaixa, IIf(nBaseImpos > 0, nBaseImpos, nValRec), SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
												nPis		:= 	aPcc[2]
												nCofins		:=	aPcc[3]
												nCsll		:=  aPcc[4]
											EndIf
											
											nValBx 		:= aTitulos[nTit,9] -= ( nPis + nCofins + nCsll )								
										EndIf
										
										If Len(aPcc) > 4
											__aTitCalc := aPcc[5]
										EndIf
										
										RestArea(aAreaParc)
									EndIf
									
									If !lIrPjBxCr
										nIrrf := SE1->E1_IRRF
									EndIf
								
									If !__lBq10925	//Baixa liquida
										nValRec := nValRec - nPis - nCofins - nCsll - IiF(lIrPjBxCr,nIrrf,0)
									Endif							
									
									If nMoeda > 1
										nValRec := xMoeda(nValRec, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, IIF(SE1->E1_MOEDA > 1,__nTxMoedD,0), __nTxMoedP)
									EndIf
								ElseIf ( !lRartImp .And. !lRaRtImpMR ) .And. MV_PAR08 == 1 .And. SE1->E1_TIPO $ MVRECANT							
									aAreaParc := GetArea()
									dbGoto( nRecno )
									
									If !SE1->E1_TIPO $  MVRECANT + "|" + MV_CRNEG 									
										nValImpAux := 0
										nValImpAux += Iif( !lPccBxCr, 0, SE1->(E1_PIS + E1_COFINS + SE1->E1_CSLL) )
										nValImpAux += Iif( !lIrPjBxCr, 0, SE1->E1_IRRF )
										nValImpAux += Iif( !lCalcIssBx, 0, SE1->E1_ISS )
										nValImpAux += SE1->E1_INSS
										
										If __lMotRet .And. Len(aDadosRA1) > 12 //Recupera o valor do imposto do configurador de tributos
											nValImpAux += aDadosRA1[13][1]
										EndIf
										
										nValTitAux := SE1->E1_VALOR - nValImpAux - nTotAbtIni
										
										If nVtit == nValTitAux .And. ( nTotalTit + aTitulos[nTit,9] ) == nValTitAux
											nAltVal := SE1->E1_VALOR - nTotalTit //se os titulos ja marcados + o titulo do momento for igual o liquido, deve calcular pelo restante do saldo.
										ElseIf nPosIr > 0
											nAltVal	:= Iif(MV_PAR08==1,(nValTot+ Iif(!lIrPjBxCr,0,aImpIR[nPosIr][1])+aImpPcc[1]+aImpPcc[2]+aImpPcc[3]+nTotAbtIni) + SE1->E1_DECRESC ,aTitulos[nTit,9])
										Else
											nAltVal	:= Iif( MV_PAR08==1, ( nValTot + aImpPcc[1] + aImpPcc[2] + aImpPcc[3] + nTotAbtIni ), aTitulos[nTit,9] )
										EndIf
																		
										nTotalTit += nValBx
										
										If ( SE1->E1_SALDO - ( nValRec + nPis + nCofins + nCsll + Iif( lIrPjBxCr, 0, SE1->E1_IRRF ) + If( lCalcIssBx, 0, SE1->E1_ISS ) + SE1->E1_INSS + ValorMR() )) <> 0 
											If lPccBxCr .And. nAltVal > nValBx .And. nValBx < nSaldo .And. ( nParciais == 0 .Or. NoRound( Abs( nSaldo - nValBx ) , 2 ) <> 0.01 )
												nAltVal := Iif( nValRec > nValBx , nValRec , nValBx )
											ElseIf lPccBxCr .And. nParciais > 0 .And. ( nValBx == nSaldo .Or. NoRound( Abs( nSaldo - nValBx ) , 2 ) == 0.01 )
												nAltVal := SE1->E1_VALOR - nParciais
											EndIf
											
											If !__lPccMR
												//nAltVal = valor cheio
												If !lJurMulDes // se não considera retira o acrescimo
													nAltVal -= SE1->E1_SDACRES	
												Else //se considera, retira o decrecimo
													nAltVal -= SE1->E1_SDDECRE
												EndIf

												If !Empty(SE1->E1_NUMBOR)
													lRetImp:= VLDBOR(SE1->E1_NUMBOR,"R")
												EndIf

												If lRetImp .And. FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)											
													If VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)																																																				
														If nBaseImpos <= 0
															nBaseImpos := IIf(SE1->E1_VLCRUZ > Round(xMoeda(SE1->E1_BASEIRF, SE1->E1_MOEDA, 1, SE1->E1_EMISSAO, __nCasDec, SE1->E1_TXMOEDA), 2), FBaseRPCC(nAltVal), nAltVal)
														EndIf													
														
														If lMVRARTIMP .And. SE1->E1_MOEDA > 1
															nBaseImpos := Round(xMoeda(nBaseImpos, SE1->E1_MOEDA, 1, dBaixa, __nCasDec, SE1->E1_TXMOEDA), 2)
														EndIf
														
														aPcc := newMinPcc(dBaixa, nBaseImpos, SE1->E1_NATUREZ , "R" , SE1->E1_CLIENTE + SE1->E1_LOJA )
														
														nPis     := aPcc[2]
														nCofins  := aPcc[3]
														nCsll    := aPcc[4]
														
														If Len(aPcc) > 4 
															__aTitCalc := aPcc[5]
														EndIf												
														
														If (lCalcIrf := (lMVRARTIMP .And. lIrPjBxCr .And. nIrrf > 0 .And. SE1->E1_MOEDA > 1))
															nIrrf := FCaIrBxCR(nBaseImpos)
														EndIf
													EndIf
												ElseIf nPis + nCofins + nCsll > 0
													nPis 	:= 0
													nCofins := 0
													nCsll 	:= 0
												EndIf
											EndIf
										EndIf
									EndIf
									
									RestArea(aAreaParc)
									
									If !lIrPjBxCr
										nIrrf := SE1->E1_IRRF
									EndIf
								ElseIf !__lPccMR .and. lPccBxCr .And. !lRartimp
									if lCredito
										If FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
											if lAutomato
												nValRec := FBaseImp(nValRec)
												
												If VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
													aPcc		:= newMinPcc(dBaixa, IIf(nBaseImpos > 0, nBaseImpos, nValRec), SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
													nPis		:= 	aPcc[2]
													nCofins		:=	aPcc[3]
													nCsll		:=  aPcc[4]
													
													If Len(aPcc) > 4 
														__aTitCalc := aPcc[5]
													EndIf
												EndIf
											endif
										EndIf
										nValBx 		:= aTitulos[nTit,9]
									else
										aAreaParc	:= GetArea()
										dbGoto(nRecno)								
										nAltVal := FbaseImp(aTitulos[nTit,9])
										
										If !Empty(SE1->E1_NUMBOR)
											lRetImp:= VLDBOR(SE1->E1_NUMBOR,"R")
										EndIf										
										
										If lRetImp .And. lPccBxCr .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
											If nBaseImpos <= 0 .And. nAltVal > 0 .And. lMVRARTIMP .And. SE1->E1_MOEDA > 1 .And. !SE1->E1_TIPO $ MVRECANT+"|"+MV_CRNEG
												nBaseImpos := nAltVal 
												
												If SE1->E1_SALDO == nAltVal .And. (nImposRet  := ImposRetid(FinBuscaFK7(SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), "SE1", SE1->E1_FILORIG))) > 0
													nBaseImpos := (nBaseImpos + nImposRet)
												EndIf
												
												nBaseImpos := Round(xMoeda(nBaseImpos, SE1->E1_MOEDA, 1, dBaixa, __nCasDec, SE1->E1_TXMOEDA), 2)
												lCalcIrf   := lIrPjBxCr 
											EndIf										

											If lMata460
												nAltVal := FBaseRPCC(nAltVal)
											EndIf

											aPcc		:= newMinPcc(dBaixa, IIf(nBaseImpos > 0, nBaseImpos, nAltVal), SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
											nPis		:= aPcc[2]
											nCofins		:= aPcc[3]
											nCsll		:= aPcc[4]
										EndIf
										
										If Len(aPcc) > 4
											__aTitCalc := aPcc[5]
										EndIf
										
										If lCalcIrf
											nIrrf := FCaIrBxCR(nBaseImpos)
										EndIf
										
										RestArea(aAreaParc)
									EndIf
								ElseIf !__lPccMR .and. lPccBxCr .And. lRartimp .And. lCredito .And. nValRec < Fa330VTit(aTitulos[nTit,nPos])
									aAreaParc := GetArea()
									dbGoto( nRecno )
										
									nValImpAux := 0
									nValImpAux += Iif( !lPccBxCr, 0, SE1->(E1_PIS + E1_COFINS + SE1->E1_CSLL) )
									nValImpAux += Iif( !lIrPjBxCr, 0, SE1->E1_IRRF )
									nValImpAux += Iif( !lCalcIssBx, 0, SE1->E1_ISS )
									nValImpAux += SE1->E1_INSS
									If __lMotRet .And. Len(aDadosRA1) > 12 //Recupera o valor do imposto do configurador de tributos
										nValImpAux += aDadosRA1[13][1]
									EndIf
									nValImpAux := nValImpAux*(nValRec/SE1->E1_VALOR)
									nAltVal := Round(nValRec + nValImpAux,2)

									RestArea(aAreaParc)	
										
									If VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
										If FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
											aPcc		:= newMinPcc(dBaixa, IIf(nBaseImpos > 0, nBaseImpos, nAltVal), SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
											nPis		:= 	aPcc[2]
											nCofins		:=	aPcc[3]
											nCsll		:=  aPcc[4]
													
											aDadosRA1[3][nTit]	:= nPis
											aDadosRA1[4][nTit]	:= nCofins
											aDadosRA1[5][nTit]	:= nCsll	

											aTitulos[nTit,nPosPis]:=Transf(aDadosRA1[3][nTit], PesqPict("SE1","E1_PIS"))
											aTitulos[nTit,nPosCof]:=Transf(aDadosRA1[4][nTit], PesqPict("SE1","E1_COFINS"))
											aTitulos[nTit,nPosCsl]:=Transf(aDadosRA1[5][nTit], PesqPict("SE1","E1_CSLL"))		
										EndIf													

										If !__lIrfMR .And. lIrPjBxCr .And. cPaisLoc == "BRA"
											nIrrf := FCaIrBxCR(IIf(nBaseImpos > 0, nBaseImpos, nAltVal))
											aDadosRA1[6][nTit]	:= nIrrf
											aTitulos[nTit,nPosIrf] := Transf( nIrrf, PesqPict("SE1","E1_IRRF"))
										EndIf
									EndIf																				
								EndIf
							Else
								If !__lPccMR
									//Se for RA
									If !lCredito .And. !lRartImp .And. nValRec <> nOldValRec .And. aDadosret[1] <= nVlMinImp .And. (nValRec + aDadosret[1]) <= nVlMinImp .And. nValPis > 0
										nPis		:= (nValPis * (nValrec/ SE1->E1_VALOR))
										nCofins		:= (nValCofins * (nValrec/ SE1->E1_VALOR))
										nCsll		:= (nValCsll * (nValrec/ SE1->E1_VALOR))
									ElseIf !lCredito .And. !lRartImp .And. nValRec <> nOldValRec .And. (nValRec + aDadosret[1]) > nVlMinImp .And. nValPis > 0
										nPis		:= aDadosRet[2] + (nValPis * (nValrec/nValorNf)) //SE1->E1_VALOR))
										nCofins		:= aDadosRet[3] + (nValCofins * (nValrec/nValorNf))// SE1->E1_VALOR))
										nCsll		:= aDadosRet[4] + (nValCsll * (nValrec/nValorNf))// SE1->E1_VALOR))
									EndIf
								
									//Se for NF				
									If lCredito .and. !lRartImp .AND. aDadosret[1] <= nVlMinImp .and. (nValRec + aDadosret[1]) <= nVlMinImp
										If nValRec + nAbatNf == nOldValRec
											nPis		:= (SE1->E1_PIS * ((nValrec + nAbatNf)/ SE1->E1_VALOR))
											nCofins		:= (SE1->E1_COFINS * ((nValrec + nAbatNf)/ SE1->E1_VALOR))
											nCsll		:= (SE1->E1_CSLL * ((nValrec + nAbatNf)/ SE1->E1_VALOR))
										Else
											nPis		:= (SE1->E1_PIS * (nValrec/ SE1->E1_VALOR))
											nCofins		:= (SE1->E1_COFINS * (nValrec/ SE1->E1_VALOR))
											nCsll		:= (SE1->E1_CSLL * (nValrec/ SE1->E1_VALOR))
										EndIf
									ElseIf 	lCredito .and. !lRartImp .and. lPccBxCr .and. mv_par08 == 1 .and. aDadosret[1] <= nVlMinImp .and. aDadosret[1] + nValRec > nVlMinImp .and. SE1->E1_SALDO <> nValRec +nAbatNf + nPis + nCofins + nCsll
										nPis		:= aDadosRet[2] + nPis
										nCofins		:= aDadosRet[3] + nCofins
										nCsll		:= aDadosRet[4] + nCsll
									ElseIf lCredito .and. !lRaRtImp .and. mv_par08 == 1 .and. lPccBxCr .and. nPis+nCofins+nCsll+nIrrf > 0 .AND. aDadosret[1] > nVlMinImp .and. SE1->E1_SALDO <> SE1->E1_VALOR .and. nValPis > 0
										If (mv_par02 == 2 .AND. AllTrim(atitulos[1][7]) == Alltrim(atitulos[1][25])) .or. (mv_par02 == 1 .AND. nPisFin061 == 0 .and. AllTrim(atitulos[1][7]) == Alltrim(atitulos[1][22])) 
											nPis		:= (nValPis * (SE1->E1_SALDO/ SE1->E1_VALOR))
											nCofins		:= (nValCofins * (SE1->E1_SALDO/ SE1->E1_VALOR))
											nCsll		:= (nValCsll * (SE1->E1_SALDO/ SE1->E1_VALOR))
										EndIf
									ElseIf lCredito .and. !lRartImp .and. lPccBxCr .and. mv_par08 == 2 .and. aDadosret[1] <= nVlMinImp .and. aDadosret[1] + nValRec > nVlMinImp .and. SE1->E1_SALDO <> nValRec +nAbatNf + nPis + nCofins + nCsll
										nPis		:= aDadosRet[2] + (SE1->E1_PIS * (nValrec/ SE1->E1_VALOR))
										nCofins		:= aDadosRet[3] + (SE1->E1_COFINS * (nValrec/ SE1->E1_VALOR))
										nCsll		:= aDadosRet[4] + (SE1->E1_CSLL * (nValrec/ SE1->E1_VALOR))
									ElseIf lCredito .and. !lRartImp .and. lPccBxCr .and. mv_par08 == 2 .and. aDadosret[1] > nVlMinImp .and. SE1->E1_SALDO <> nValRec +nAbatNf + nPis + nCofins + nCsll
										nPis		:= (SE1->E1_PIS * (nValrec/ SE1->E1_VALOR))
										nCofins		:= (SE1->E1_COFINS * (nValrec/ SE1->E1_VALOR))
										nCsll		:= (SE1->E1_CSLL * (nValrec/ SE1->E1_VALOR))
									EndIf
								EndIf
							EndIf
						EndIf
						
						//Definindo o conteudo que sera gravado no campo E1_TITPAI do abatimento, caso exista e a baixa seja integral
						cDadosTitulo := cPrefixo + cNum + cParcela + cTipoOr + cCliente + cLoja
						
						If lCredito
							cDadosTitulo := SE1->(E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA)
						Endif
						
						DbSelectArea("SE1")
						SE1->(DbGoTo(nRecNo))
						
						//Guardo dados do titulo principal para utilizar no historico da contabiliza‡Æo
						STRLCTPAD := SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO
						
						//Valor da Baixa na moeda do titulo principal
						If cPaisLoc == "BRA"
							nValBX2 := aTitulos[nTit,9]					
							__nTxMoedD := iif(__lRaTxMov ,aTitulos[nTit][len(aTitulos[nTit])], atxmoedas[SE1->E1_MOEDA][2] )
							
							If lPccBxCr .And. nValor <> nSaldo .And. nPis > 0 .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. mv_par08 == 1  .And.;
								(nValBx2 + (nPis + nCofins + nCsll) + nIrrf <> Iif(MV_PAR02==1, aTitulos[nTit,21], aTitulos[nTit][24]) .Or.;
								(nValBx2 + nAbatNf == Iif(MV_PAR02==1, aTitulos[nTit][21], aTitulos[nTit][24])))

								nValBx	:= nValBx2
								
								If nSaldo - aTitulos[nTit,9] - nPis - nCofins - nCsll - Iif( lIrPjBxCr, nIrrf, nAbatNf ) == 0
									nValBx2 := aTitulos[nTit,9]
									nValBx	:= nValBx2
								ElseIf nValor - nIrrf == nValBx
									nValBx2 := aTitulos[nTit,9]
									nValBx	:= nValBx2
								EndIf
							Endif
							
							If mv_par02 == 1
								nAcresc := Fa330VTit(aTitulos[nTit,10])
								nDecres := Fa330VTit(aTitulos[nTit,11])
							Else
								nAcresc := Fa330VTit(aTitulos[nTit,13])
								nDecres := Fa330VTit(aTitulos[nTit,14])
							EndIf
							
							If lCredito
								VALOR7 :=  nDecres
								VALOR8 :=  nAcresc
							Endif
							
							nTotAbat := 0

							If mv_par08 == 1 .And. ( !lRaRtImp .And. !lRaRtImpMR ) .and. !lCredito
								nTotAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
							Endif
							
							nPropPcc	:=	nRegRa	:=	0
							
							//PCC Baixa CR
							If __lCalcImp .And.  lCredito .And. lPccBxCr .And. ( lRaRtImp .Or. lRaRtImpMR )
								nPis 	:= Fa330VTit(aTitulos[nTit,nPosPis])
								nCofins := Fa330VTit(aTitulos[nTit,nPosCof])
								nCsll 	:= Fa330VTit(aTitulos[nTit,nPosCsl])
							Endif
						Else
							nValBx2 := Fa330VTit(aTitulos[nTit,7])
							
							If lCredito .and. cPaisLoc != "RUS"
								If mv_par02 == 1
									nAcresc := Fa330VTit(aTitulos[nTit,11])
									nDecres := Fa330VTit(aTitulos[nTit,12])
								Else
									nAcresc := Fa330VTit(aTitulos[nTit,13])
									nDecres := Fa330VTit(aTitulos[nTit,14])
								EndIf
							EndIf
						EndIf
						
						nValIrf	:= nIrrf
						
						//Efetiva gravacao da compensacao SE1/SE5
						If lCredito .And. ( !lRaRtImp .And. !lRaRtImpMR )
							If __lCalcImp
								If lIrPjBxCr .And. Len(aImpIr) >= 1
									nPosIr := aScan( aImpIR, {|x| x[2] = aTitulos[nTit,nReg330]} )    
									
									If nPosIr > 0 .And. aImpIR[nPosIr][1] > 0
										nIrrf := aImpIR[nPosIr][1]
										nVlTotConv := xMoeda(nValTot, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, IIF(SE1->E1_MOEDA > 1,__nTxMoedD,0), __nTxMoedP)
										
										If VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)									
											nBaseImpos := IIf(nBaseImpos > 0, nBaseImpos, Iif(MV_PAR08 == 1, (nVlTotConv+aImpIR[nPosIr][1]+aImpPcc[1]+aImpPcc[2]+aImpPcc[3]+nTotAbtIni), nVlTotConv))									
											FCaIrBxCR(nBaseImpos, nRecTit)
										EndIf
									ElseIf Len(aImpIr) > 1 .And. nTit <= len(aImpIr) .And. nPosIr > 0 .And. !__lIrfMR
										nIrrf 	:= FReCalIRB( aImpIr, If(lAutomato, nValRec, nValBx2), nPosIr, lAutomato)
									EndIf
								Else
									nIrrf := 0
								EndIf
							EndIf
							
							If cPaisLoc == "BRA" .And. !__lIrfMR .And. MV_PAR08 == 1
								If MV_PAR02 <> 2
									nValComp := xMoeda(aTitulos[nTit,9], nMoeda, 1, dDataBase, __nCasDec, __nTxMoedP, 0)
									nValImp  := xMoeda(( nPis + nCofins + nCsll + nIrrf ), 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
									nImpCalc := xMoeda(( nPisCalc + nCofCalc + nCslCalc + nIrrf ), 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)

									If Val(StrTran(StrTran(aTitulos[nTit,22],".",""),",",".")) != aTitulos[nTit,9]  + nValImp .And. ;
										Val(StrTran(StrTran(aTitulos[nTit,22],".",""),",",".")) != aTitulos[nTit,9]  + nImpCalc
										
										nPropIr :=  nValComp/ aTitulos[nTit,(nPos-1)]
									Else
										nPropIr := 1
									EndIf
								Else
									nPropIr := nValComp / aTitulos[nTit,24]
								EndIf
								If !lCredito					
									nIrrf := nIrrf * nPropIr					
								EndIf
							EndIf					
							
							ntotIrbx := nIrrf						
						ElseIf lIrPjBxCr .And. Len(aImpIr) >= 1 .And. ( !lRaRtImp .And. !lRaRtImpMR )						
							If __lCalcImp .And. !__lIrfMR
								If !Empty(SE1->E1_NUMBOR)
									lRetImp:= VLDBOR(SE1->E1_NUMBOR,"R")
								EndIf

								nPosIr := aScan(aImpIR,{|x| x[2]=SE1->(REcno())})
								
								If nPosIr > 0 .And. !lCalcIrf
									If lPccBxCr .And. nValTot == SE1->E1_SALDO
										If lRetImp
											nIrrf := FReCalIRB(aImpIr,Iif(MV_PAR08==1,(nValTot+aImpIR[nPosIr][1]+aImpPcc[1]+aImpPcc[2]+aImpPcc[3]+nTotAbtIni),nValTot),nPosIr, lAutomato)
										EndIf
									Elseif lPccBxCr .and. nSaldo == nValTot
										nIrrf := FReCalIRB(aImpIr,Iif(MV_PAR08==1,(nValTot+aImpIR[nPosIr][1]+aImpPcc[1]+aImpPcc[2]+aImpPcc[3]+nTotAbtIni),nValTot),nPosIr, lAutomato)
									Elseif nSaldo == nValTot
										nIrrf := FReCalIRB(aImpIr,Iif(MV_PAR08==1,(nValTot+aImpIR[nPosIr][1]+nTotAbtIni),nValTot),nPosIr, lAutomato)
									Else //indica que o valor foi digitado
										nIrrf := FReCalIRB(aImpIr,nValTot,nPosIr, lAutomato)
									EndIF
								EndIf				   	
							EndIf
							
							ntotIrbx := nIrrf
						Else					
							If lIrPjBxCr .And. !(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG )
								If __lCalcImp .And. !__lIrfMR .And. SE1->E1_IRRF > 0 .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
									nIrrf := FCaIrBxCR(SE1->E1_SALDO)
								EndIf
								ntotIrbx := nIrrf
							Else
								nAbatNf := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
								nIrrf 	:= If(__lCalcImp, 0, nIrrf)
								ntotIrbx := If(__lCalcImp, 0, ntotIrbx)		
							EndIf
						EndIf
										
						If ( !__lPccMR .And. aPcc[1] ) .And. ( !lIrPjBxCr .And. nValIrf <> nIrrf )
							nIrrf	:= nValIrf
						EndIf
						
						If cPaisLoc != "RUS" .And. ( lRartImp .Or. lRaRtImpMR ) .And. lPccBxCr .And. !lNcc
							
							If __lCalcImp
								nPis	:= Fa330VTit(aTitulos[nTit,nPosPis])
								nCofins	:= Fa330VTit(aTitulos[nTit,nPosCof])
								nCsll	:= Fa330VTit(aTitulos[nTit,nPosCsl])
								nIrrf	:= Fa330VTit(aTitulos[nTit,nPosIrf])
							EndIf
							
							If !Empty(aDadosRA1[10])
								nIss	:= aDadosRA1[10,nTit]
							EndIf
							If !Empty(aDadosRA1[11])
								nInss	:= aDadosRA1[11,nTit]
							EndIf						
							If __lMotRet .And. !Empty(aDadosRA1[12])
								aAdd(aDadosRA1[12,nTit], {__nImpMR})
							EndIf
						EndIf
						
						If (!lRartImp .And. !lRaRtImpMR ) .And. lPccBxCr .And. !lCredito .And. aImpPcc[1] <> nPis .And. MV_PAR08==2
							aImpPcc [1] := nPis
							aImpPcc [2] := nCofins
							aImpPcc [3] := nCsll
						EndIf
										
						If !(cPaisLoc $ "RUS|EUA|BRA") .And. lCredito .And. !lNCC
							nPisBaseR 	:= Fa330VTit(aTitulos[nTit,nPosBPCR])
							nPisBaseC 	:= Fa330VTit(aTitulos[nTit,nPosBPCC])
							nCofBaseR 	:= Fa330VTit(aTitulos[nTit,nPosBPCR])
							nCofBaseC 	:= Fa330VTit(aTitulos[nTit,nPosBPCC])
							nCslBaseR 	:= Fa330VTit(aTitulos[nTit,nPosBPCR])
							nCslBaseC 	:= Fa330VTit(aTitulos[nTit,nPosBPCC])
							nIrfBase	:= Fa330VTit(aTitulos[nTit,nPosBIRF])
							If nPis > 0 .And. nPisBaseR == 0
								nPisCalc	:= nPis
								nPisBaseC	:= nValBx+nPis+nCofins+nCsll
								nPisBaseR 	:= nPisBaseC
								nCofCalc	:= nCofins	
								nCofBaseC	:= nPisBaseC
								nCofBaseR 	:= nPisBaseC
								nCslCalc	:= nCsll	
								nCslBaseC	:= nPisBaseC
								nCslBaseR 	:= nPisBaseC
							EndIf
						EndIf

						nValorAux 	:= Iif( cPaisLoc == "BRA" .And. lCredito .And. aTitulos[nTit,9] < aTitulos[nTit,(nPos - 1)], nValBx, nValBx2 ) //Valor a compensar
						nVlAuxConv	:= Round(xMoeda(nValorAux,nMoeda,1,,nDecs1+1,__nTxMoedP),2) //Valor a compensar convertido para a moeda forte
						nSldPosCmp  := ABS( __nSldConv - ( nVlAuxConv + nVlrCmpAux ) ) //__nSldConv = Valor do titulo de partida - vlr a compensar acumulado (convertido na moeda forte)
						
						If nSldPosCmp <= If(nMoeda > 1 .And. nMVToler == 0, nToler, nMVToler) //Verifica se o saldo do titulo de partida ficará igual ou menor a margem de tolerancia (MV_TOLERPG)
							If ( nVlAuxConv + nToler ) <= Round(xMoeda(Fa330VTit(aTitulos[nTit,6]),nMoeda,1,,nDecs1+1,__nTxMoedP),2)  //Verifica se é compensacao parcial
								nValorAux := xMoeda((__nSldConv - nVlrCmpAux),1,nMoeda,,nDecs1+1,,__nTxMoedP) //Ajusta valor a compensar com o decimal correto
							EndIf
						EndIf
						
						cSeqAux := StrZero( nSeq, nTamSeq )				
							
						nIssAux  := 0
						nInssAux := 0
							
						If (lRaRtImp .Or. lRaRtImpMR)
							nIssAux := nIss
							nInssAux := nInss
						EndIf

						lNccAux	:= aTitulos[nTit,4] $ MV_CRNEG .Or. lNcc
						
						Fa330Grv( lPadrao, nValorAux, cAdiantamento, cSeqAux, aRecNo[nTit], @aBaixas, cOrigem, lCredito, mv_par09, @nAcresc, @nDecres, aBaixaSE5, ;
								nTotAbtIni, aImpPcc, @cSequencia, cDadosTitulo, nIrrf, ntotIrbx, nIssAux, nInssAux, lNccAux, nDescP, nDescD, @nIrrfParc, nOldValRec, nValVa, @nRegSe5Ori, lVMd2ImpRA, @lVldSEQ)
			
						If lVldSEQ
							Help( ,,"FANXTSEQBX",,STR0122, 1, 0,,,,,, { STR0123 }  ) //"O sequencial para o campo E5_SEQ chegou ao seu limite de tamanho. Esta compensação será abortada." #  "Necessario aumentar o tamanho do campo E5_SEQ"
							lRetorno := .F.
							DisarmTransaction()
							Break
						EndIf
						If cPaisLoc == "RUS" .And. SE1->E1_MOEDA == 1
							FaGrvFR3("R", "", SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, ;
									SE1->E1_CLIENTE, SE1->E1_LOJA, M->(Recno()), aTitulos[nTit][2], aTitulos[nTit][1])
						EndIf
						
													
						//Acerta o saldo do título, somente para compensações parciais
						lRetMinAux := ( ( !__lPccMR .And. aDadosRet[1] + nValRec > nVlMinImp ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) )
						If !lCredito .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. MV_PAR08 == 1 .And. SE1->E1_TIPO <> MV_CRNEG .And. SE1->E1_TIPO <> MVRECANT
							If lPccBxCr .And. ( nPis + nCofins + nCsll > 0 ) .And. ( SE1->E1_SALDO - ( nPis + nCofins + nCsll ) > 0 )
								lRetMinAux := ( ( !__lPccMR .And. aDadosret[1] <= nVlMinImp .And. aDadosRet[1] + nValRec > nVlMinImp ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) )
								If lRetMinAux .And. nValRec == nOldValRec .And. nValrec == nValBx						     
									Reclock("SE1")
									SE1->E1_SALDO -= nPis + nCofins + nCsll
									MsUnlock()
								EndIf
							EndIf
						ElseIf lCredito .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. MV_PAR08 == 1 .And. SE1->E1_TIPO <> MV_CRNEG .And. lRetMinAux
							If lPccBxCr .And. ( nPis + nCofins + nCsll > 0 ) .And. nValRec + nPis + nCofins + nCsll + nAbatRa <> nSldNF
								If SE1->E1_SALDO <> 0
									If nAbatNf > 0 .And. SE1->E1_SALDO - nAbatNf == 0
										Reclock("SE1")
										SE1->E1_SALDO -= SE1->E1_SALDO
										MsUnlock()
									EndIf							
								EndIf
							EndIf
						EndIf
						
						If SE1->E1_SALDO == 0
							nValorNf	:= 0
						EndIf
										
						If lCredito .And. ( lRartImp .And. lRaRtImpMR ) .And. nIrrf > 0 .And. lIrPjBxCr .And. SE1->E1_SALDO > 0 //lRartImp, indica que já houve a retenção no RA, não deve calcular novamente!
							SE1->E1_SALDO -= nIrrf
						EndIf
						
						aAlt := {}				
						AAdd(aAlt,{STR0080,'','','',STR0081 + Alltrim(Transform(nValBx2,cPicE5Val))}) 
						//chamada da Função que cria o Histórico de Cobrança
						cFilOld := cFilAnt
						cFilAnt := SE1->E1_FILORIG
						FinaCONC(aAlt)
						cFilAnt	:= cFilOld
						
						//Atualiza o status do titulo no SERASA
						If cPaisLoc == "BRA" .And. !SE1->E1_TIPO $ MVRECANT+"|"+MV_CRNEG .And. SE1->E1_SALDO <= 0
							cChaveTit := SE1->E1_FILIAL + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
							cChaveFK7 := FINGRVFK7("SE1",cChaveTit,SE1->E1_FILORIG)
							F770BxRen("1","CMP1",cChaveFK7,,SE1->E1_FILORIG)
						Endif
						
						For nX:= 1 To len(aBaixas)
							If aBaixas[nX][1][4] $ MVRECANT + "/" + MV_CRNEG
								nRecnoRA := aBaixas[nX][1][3]
								lCompRa	:= .T.
							EndIf
							
							If lUsaFlag
								aAdd( aFlagCTB, {"E5_LA", "S", "SE5", aBaixas[nX][1][3], 0, 0, 0} )
							EndIf
						Next nX

						// Posiciona no titulo de destino para contabilização
						dbSelectArea("SE1")
						dbGoTo(aRecNo[nTit])
						
						nTotAbat := 0
						
						If mv_par08 == 1 .And. ( !lRaRtImp .And. !lRaRtImpMR ) .and. lCredito
							nTotAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
						Endif
						
						//Acerta o saldo do titulo de destino
						Reclock("SE1")
							
						If cPaisLoc == "BRA"
							lSumPcc	:= .F.
							SE1->E1_DESCONT := nDescD
							
							If nValBx == Fa330VTit(aTitulos[nTit,6]) .Or. ABS(nValBx - Fa330VTit(aTitulos[nTit,6])) <= If(nMoeda > 1 .And. nMVToler == 0, nToler, nMVToler)
								SE1->E1_SALDO := 0
								SE1->E1_SDACRES := 0
								SE1->E1_SDDECRE := 0

								If !lCredito .And. ( !lRartImp .And. !lRaRtImpMR ) .and. !__lBq10925 .and. !(aTitulos[nTit,4] $ MV_CRNEG)
									If lPccBxCr
										SE1->E1_SALDO += nPis + nCofins + nCsll
										lSumPcc	:= .T.
									Endif
									If lIrPjBxCr
										SE1->E1_SALDO += nTotIrbx
									Endif
									If !__lImpEmis
										SE1->E1_SALDO += __nImpMR
									Endif
								Endif
							Else
								//Na Compensacao de RA para NF posso ter impostos gerados e devem ser abatidos no valor do SALDO.
								If SE1->E1_TIPO = 'NF ' .AND. lCompRa .and. !lNcc
									nTotAbat += (nPis + nCofins + nCsll+ Iif(!lIrPjBxCr,0,nTotIrBx) + Iif( !__lImpEmis, __nImpMR, 0 ) )
								Endif
								//Valor do VA para ajuste do saldo
								nValVa := Fa330VTit(aTitulos[nTit,nPosVa])
								// Verifica se o titulo já possui impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
								nPisFin061	:=	0
								nCofFin061	:=	0
								nCslFin061	:=	0
								nIrfFin061	:=	0
								nRegSE5	:=	SE5->(Recno())
								nOrdSE5	:=	SE5->(IndexOrd())		
								If lPccBxCr .And. lIrPjBxCr 
									dbSelectArea("SE5")
									SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
									If SE5->(DBSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
										While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
											SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
										
											If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
												If Alltrim(SE5->E5_MOTBX) == "PCC"
												nPisFin061	+= SE5->E5_VRETPIS
												nCofFin061	+=	SE5->E5_VRETCOF
												nCslFin061	+= SE5->E5_VRETCSL
												ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
												nIrfFin061	+= SE5->E5_VRETIRF
												EndIf
											EndIf				
											SE5->(DbSkip())		
									Enddo
									EndIf
								Endif
								SE5->(Dbgoto(nRegSE5))
								SE5->(Dbsetorder(nOrdSE5))										
								
								If ( nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061 ) > 0 .And. mv_par08 = 2 .And. SE1->E1_TIPO <> MV_CRNEG .And. SE1->E1_TIPO <> MVRECANT 
									SE1->E1_SALDO	+=	( nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061 )
								Else
									nPisFin061	:=	0
									nCofFin061	:=	0
									nCslFin061	:=	0
									nIrfFin061	:=	0
								EndIf

								If SE1->E1_DECRESC >0 .OR. SE1->E1_ACRESC >0
									If SE1->E1_SDACRES >= nValBx
										SE1->E1_SDACRES -= nValBx
									Else
										SE1->E1_SALDO 	-= Round(Noround(xMoeda(nValBx-nAcresc+nDecres-nValVa+nDescD,nMoeda,SE1->E1_MOEDA,,3,Fa330Tx2(nMoeda,nTxMoeda),Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)),3),2)
										SE1->E1_SDACRES	-= Round(Noround(xMoeda(nAcresc,nMoeda,SE1->E1_MOEDA,,3,Fa330Tx2(nMoeda,nTxMoeda),Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)),3),2)
									EndIf
									SE1->E1_SDDECRE	-= Round(Noround(xMoeda(nDecres,nMoeda,SE1->E1_MOEDA,,3,Fa330Tx2(nMoeda,nTxMoeda),Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)),3),2)
								Else							
									lRetMinAux := ( ( !__lPccMR .And. aDadosret[1] < nVlMinImp .And. aDadosRet[1] + nValor > nVlMinImp ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) )
									If lPccBxCr .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. lRetMinAux .And. lCredito
										If nTotAbat > 0
											SE1->E1_SALDO	-= Round(Noround(xMoeda(nValBx+nTotAbat-nValVa,nMoeda,SE1->E1_MOEDA,,3,Fa330Tx2(nMoeda,nTxMoeda),Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)),3),2)
										Else
											SE1->E1_SALDO	-= Round(Noround(xMoeda(nValBx+nPis+nCofins+nCsll+nIrrf+nIss+nTotAbat-nValVa,nMoeda,SE1->E1_MOEDA,,3,Fa330Tx2(nMoeda,nTxMoeda),Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)),3),2)
										EndIf
									Else
										SE1->E1_SALDO	-= SE5->E5_VALOR + nDescD - nValVa //E5_VALOR é gravado com a moeda do título na compensação
										lSumPcc	:= .T.
									EndIf
								EndIf
							EndIf
							
							SE1->E1_VALLIQ := Iif(SE1->E1_MOEDA ==  VAL(SE5->E5_MOEDA), SE5->E5_VALOR, SE5->E5_VLMOED2)
							
							If STR(SE1->E1_SALDO,17,2) == STR(nTotAbat,17,2)
								SE1->E1_SALDO := 0
							EndIf
							
							SE1->E1_MOVIMEN:= dDatabase
												
							//PCC Baixa CR
							If nMoeda == 1 .Or. SE1->E1_MOEDA == 1
								lRetMinAux := ( ( !__lPccMR .And. aDadosret[1] <= nVlMinImp .And. aDadosRet[1] + nValRec > nVlMinImp ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) ) 
								If lCredito .And. lPccBxCr .And. SE1->E1_SALDO > 0 .And. lRetMinAux
									If ( nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061 ) == 0 								
										lRetMinAux := ( ( !__lPccMR .And. aDadosret[1] <= nVlMinImp ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) ) 
										
										If lRetMinAux .And. ( ( ( !lRaRtImp .And. !lRaRtImpMR ) .And. mv_par08 == 1 .And. !__lBq10925 ) .Or. ( ( lRartimp .Or. lRaRtImpMR ) .And. mv_par08==1 ) )
											If nValRec + nPis + nCofins + nCsll + nIrrf >= nValBx + If (__lBq10925, nPis + nCofins + nCsll + nIrrf, 0 )
												SE1->E1_SALDO -= xMoeda( nPis + nCofins + nCsll + nIrrf,  1, SE1->E1_MOEDA, dDataBase, __nCasDec, 1, Iif(SE1->E1_TXMOEDA > 0, SE1->E1_TXMOEDA, __nTxMoedD ))
											Else
												SE1->E1_SALDO += nPis + nCofins + nCsll
											EndIf
										ElseIf ( !lRaRtImp .And. !lRaRtImpMR ) .And. mv_par08 == 1 .And. __lBq10925 .And. !lNCC
											If !__lCalcImp
												If lPCCBxCR .And. (nPis+nCofins+nCsll) > 0
													SE1->E1_SALDO -= IIf(SE1->E1_MOEDA == 1, nPis,    Round(xMoeda(nPis,    1, SE1->E1_MOEDA, dBaixa, __nCasDec, 0, __nTxMoedP), 2))
													SE1->E1_SALDO -= IIf(SE1->E1_MOEDA == 1, nCofins, Round(xMoeda(nCofins, 1, SE1->E1_MOEDA, dBaixa, __nCasDec, 0, __nTxMoedP), 2))
													SE1->E1_SALDO -= IIf(SE1->E1_MOEDA == 1, nCsll,   Round(xMoeda(nCsll,   1, SE1->E1_MOEDA, dBaixa, __nCasDec, 0, __nTxMoedP), 2))
												EndIf											
												
												If lIrPjBxCr .And. nIrrf > 0
													SE1->E1_SALDO -= IIf(SE1->E1_MOEDA == 1, nIrrf, Round(xMoeda(nIrrf, 1, SE1->E1_MOEDA, dBaixa, __nCasDec, 0, __nTxMoedP), 2))
												EndIf   
											EndIf 
											
											SE1->E1_SALDO -= IIf(__lCalcImp, (nPis+nCofins+nCsll) + Iif(!lIrPjBxCr, 0, nTotIrBx) + Iif( !__lImpEmis, __nImpMR, 0), 0)											
											
											If SE1->E1_SALDO < 0
												SE1->E1_SALDO := 0
											EndIf
											
											If __lCalcImp .And. !lIrPjBxCr .And. (SE1->E1_SALDO - nIrrf == 0 .Or. SE1->E1_SALDO - nIrrf == 0.01) //problemas de arredondamento 
												SE1->E1_SALDO -= nIrrf
												
												If nIrrf > 0
													SE1->E1_SALDO := Iif(SE1->E1_SALDO = 0.01,0,SE1->E1_SALDO)
												EndIf
											EndIf
											
											If	nAbatNf > 0 .And. (SE1->E1_SALDO - nAbatNf) == 0
												SE1->E1_SALDO -= nAbatNf
											EndIf
										ElseIf ( ( !__lPccMR .And. aDadosret[1] <= nVlMinImp ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) ) .And. ( lRartimp .Or. lRaRtImpMR )
											SE1->E1_SALDO -= nPis + nCofins + nCsll								
											SE1->E1_SALDO -= nIss + nInss										
											
											If lIrPjBxCr
												SE1->E1_SALDO -= xMoeda( nIrrf,  1, SE1->E1_MOEDA, dDataBase, __nCasDec, 1, Iif(SE1->E1_TXMOEDA > 0, SE1->E1_TXMOEDA, __nTxMoedD ))
											EndIf
										Endif
									Endif						
								ElseIf !lCredito .And. lPccBxCr .And. SE1->E1_SALDO > 0 .And. lRetMinAux	
									If ( nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061 ) == 0
										If nPis + nCofins + nCsll > 0 .And. nValorNf <> 0 .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. mv_par08 == 1
											SE1->E1_SALDO += ( nPis + nCofins + nCsll )
										Endif
										
										If nPis + nCofins + nCsll > 0 .And. ( !lRartImp .And. !lRaRtImpMR ) .And. mv_par08 == 1 .And. !SE1->E1_TIPO $ MV_CRNEG   
											If !lIrPjBxCr .And. nAbatNf > 0 .And. (SE1->E1_SALDO - nAbatNf) == 0
												SE1->E1_SALDO -= nAbatNf
											EndIf
										ElseIf nPis + nCofins + nCsll > 0 .And. ( !lRartImp .And. !lRaRtImpMR ) .And. mv_par08 == 2
											If !lSumPcc .And. !(lMVRARTIMP .And. !__lCalcImp .And. SE1->E1_TIPO $ MVRECANT)
												SE1->E1_SALDO += (nPis + nCofins + nCsll )
											EndIf
											
											If lIrPjBxCr
												SE1->E1_SALDO += IIf(lMVRARTIMP .And. !__lCalcImp .And. SE1->E1_TIPO $ MVRECANT, 0, nIrrf)
											ElseIf nAbatNf > 0 .And. nOldValRec == nValRec .And. !lSumPcc
												SE1->E1_SALDO += nAbatNf
											EndIf
										EndIf								
										
										If ( lRaRtImp .Or. lRaRtImpMR ) 
											SE1->E1_SALDO -= ( nIss + nInss )
										EndIf	
									EndIf						
								ElseIf !lCalcIrf .And. !lCredito .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. MV_PAR08 == 2 .And. ( nPis + nCofins + nCsll > 0 ) .And. !SE1->E1_TIPO $ MV_CRNEG  
									If lIrPjBxCr
										SE1->E1_SALDO += IIf(__lCalcImp, nIrrf, 0)
									ElseIf SE1->E1_SALDO - nPis - nCofins - nCsll == 0
										SE1->E1_SALDO += nAbatNf
									EndIf
								EndIf
							EndIf
						Else
							If nValBx == Fa330VTit(aTitulos[nTit,6])
								SE1->E1_SALDO := 0
								SE1->E1_SDACRES := 0
								SE1->E1_SDDECRE := 0
							Else
								nDecs := MsDecimais(SE1->E1_MOEDA)
								nSalTit := SE1->E1_SALDO - Round(xMoeda(nValBx-nAcresc+nDecres,nMoeda,SE1->E1_MOEDA,dDatabase,nDecs+1,aTxMoedas[nMoeda][2],aTxMoedas[SE1->E1_MOEDA][2]),nDecs)
								SE1->E1_SALDO := Iif(nSalTit <= 0,0,nSalTit)
							EndIf
							SE1->E1_MOVIMEN := dDatabase
							SE1->E1_VALLIQ  += nValBx
						EndIf
										
						SE1->E1_BAIXA := dBaixa
						SE1->E1_STATUS:= IIF(SE1->E1_STATUS != "R",Iif(SE1->E1_SALDO > 0.01,"A","B"),"R")
						If cPaisLoc == "EUA" .And. SE1->(ColumnPos("E1_SLPLAID")) > 0
							SE1->E1_SLPLAID := SE1->E1_SALDO
						EndIf

						MsUnlock()

						nSE1Rec := SE1->(Recno())
						cKeyAbt := SE1->(E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA)
						cTipo	:= SE1->E1_TIPO
						xFilSE1 := SE1->E1_FILIAL

						//Efetua a baixa dos titulos de abatimento
						If lCredito .AND. SE1->E1_SALDO - nTotAbat <= 0   //Se nao for titulo de adiantamento
							//atualiza status do adiantamento de viagem
							If (ALLTRIM(SE1->E1_ORIGEM) == "FINA677")
								FINATURES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),.T.,SE1->E1_ORIGEM,"R")
							Endif
							If Select("__SE1") == 0
								SumAbatRec("","","",1,"")
							Endif
							dbSelectArea("__SE1")
							__SE1->(dbSetOrder(2))
							__SE1->(dbSeek(xFilSE1+cKeyAbt))
							If lTitpaiSE1
								If (nOrdTitPai:= OrdTitpai()) > 0
									DbSetOrder(nOrdTitPai)
									If	DbSeek(xFilSE1+Subs(cAdiantamento,1,nTamTit+nTamTip)+__SE1->E1_CLIENTE+__SE1->E1_LOJA)
										bWhile := {|| !Eof() .And. E1_FILIAL + ALLTRIM(E1_TITPAI) == xFilSE1 + Alltrim(Subs(cAdiantamento,1,nTamTit+nTamTip)+__SE1->E1_CLIENTE+__SE1->E1_LOJA)}
									Else
										__SE1->(dbSetOrder(2))
										__SE1->(dbSeek(xFilSE1+cKeyAbt))
									Endif
								Endif
							Endif

							While Eval(bWhile)
								If lTitpaiSE1
									If (  alltrim(E1_TITPAI)!=Alltrim(Subs(cAdiantamento,1,nTamTit+nTamTip)+__SE1->E1_CLIENTE+__SE1->E1_LOJA )) .and. !Empty(E1_TITPAI)
										DbSkip()
										Loop
									EndIf
								EndIf
									IF E1_TIPO $ MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+ MVCFABT+"/"+MVCSABT

										RecLock("__SE1")
										E1_SALDO   := 0
										E1_BAIXA   := If(E1_BAIXA <= dBaixa, dBaixa, E1_BAIXA)
										E1_STATUS  := "B"
										E1_MOVIMEN := dDataBase
										E1_TITPAI  := cDadosTitulo
										MsUnlock()

										cChaveTit := __SE1->E1_FILIAL + "|" + __SE1->E1_PREFIXO + "|" + __SE1->E1_NUM + "|" + __SE1->E1_PARCELA + "|" +;
											__SE1->E1_TIPO + "|" + __SE1->E1_CLIENTE + "|" + __SE1->E1_LOJA
										FINGRVFK7("SE1", cChaveTit,, cDadosTitulo)

									EndIf
								dbSkip()
							EndDo
							__SE1->(dbSetOrder(1))
						EndIf

						dbSelectArea("SE1")
						SE1->(dbGoto(nSE1Rec))

						If cPaisLoc == "BRA" .And. __TpGerPix .And. __nQtdTitu == 1 .And. __lExcImpo .And. ( F71Ativa(nSE1Rec) > 0 )					
							cChaveTit := SE1->E1_FILIAL+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA
							
							If __lAltPix .And. !__lTPIConf .And. __nFINPIX9 == 2 .And. SE1->E1_SALDO > 0
								F986AltPix(cChaveTit, SE1->E1_FILORIG, .F.)
							Else
								cIdDocFK7 := FINBuscaFK7(cChaveTit, "SE1", SE1->E1_FILORIG)
								
								If !Empty(cIdDocFK7)
									PIXCancel(xFilial("SE1", SE1->E1_FILORIG), cIdDocFK7, (__lTPIConf .Or. (SE1->E1_SALDO == 0)))
								EndIf
							EndIf
						EndIf

						// Integração SIGAPFS x SIGAFIN
						// Quando a compensação for posicionada no RA deve executar por aqui
						If lRet .And. FindFunction("JGrvBaixa")
							lRet := JGrvBaixa(SE1->(Recno()), SE5->(Recno()), nRecno)
						EndIf
						
						//Atualiza o status do titulo no SERASA
						If cPaisLoc == "BRA"
							If !(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG)
								If SE1->E1_SALDO <= 0
									cChaveTit := SE1->E1_FILIAL + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
									cChaveFK7 := FINGRVFK7("SE1",cChaveTit,SE1->E1_FILORIG)
									F770BxRen("1","CMP1",cChaveFK7,,SE1->E1_FILORIG)
								EndIf
							EndIf
						EndIf
										
						VALOR2 := 0
						VALOR3 := 0
						VALOR4 := 0
						VALOR5 := 0
						VALOR6 := 0
						ABATIMENTO  := 0

						If lCredito
							If cPaisLoc == "BRA" .And. lPccBxCr
								If EMPTY(SE5->E5_PRETPIS)
									VALOR3 := SE5->E5_VRETPIS
								EndIf
								If EMPTY(SE5->E5_PRETCOF)
									VALOR4 := SE5->E5_VRETCOF
								EndIf
								If EMPTY(SE5->E5_PRETCSL)
									VALOR5 := SE5->E5_VRETCSL
								EndIf
							EndIf

							If 	lIrPjBxCr
								VALOR2 := SE5->E5_VRETIRF
							EndIf  

							dbSelectArea("SE1")
							dbGoto(nSE1Rec)
						EndIf
						
						If cPaisLoc == "BRA" .And. !lCredito
							//IRRF Baixa CR
							If lIrPjBxCr
								nAcumIRF += nIrrf
							EndIf	
							//PCC Baixa CR
							If lPccBxCr
								If Empty(SE5->E5_PRETPIS)
									nAcumPIS += nPis
								EndIf
								If Empty(SE5->E5_PRETCOF)
									nAcumCOF += nCofins
								EndIf	
								If Empty(SE5->E5_PRETCSL)				
									nAcumCSL += nCsll
								EndIf
							EndIf
						EndIf
						
						If SE5->E5_TIPODOC == "CM" .And. SE1->E1_MOEDA > 1 //Posicionar SE5 caso registro posicionado seja de correção monetária					
							Variacao := SE5->E5_VALOR
							dbSelectArea("SE5")
							DbSetOrder(2)
							//E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+DtoS(E5_DATA)+E5_CLIFOR+E5_LOJA+E5_SEQ
							dBSeek(xFilial("SE5")+IiF(lCredito,"CP","BA")+ SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO + DTOS(dBaixa)+ SE1->E1_CLIENTE + SE1->E1_LOJA )
						Else
							Variacao := Iif( SE5->E5_TIPODOC == 'BA' , SE5->E5_VLCORRE, nValCorCM)
						EndIf 

						If lCredito .and. SE1->E1_SALDO == 0
							ABATIMENTO := nTotAbat
						Endif

						If lPadrao .and. mv_par09 == 1

							If __l330VA .And. !lCredito .And. nValVaTitP <> 0 
								//Posiciono no registro
								SE1->(dbGoTo(nRecNo))
								nRecSE5Ant := SE5->(Recno())
								SE5->(dbGoto(nRegSE5Ori))						
								nTotal += DetProva( nHdlPrv, cPadrao, "FINA330", cLote,,,,,,,, @aFlagCTB, {"SE5",nRecnoRA} )
								SE1->(dbGoTo(nSE1Rec))
								SE5->(dbGoto(nRecSe5Ant))						
							Else
								nTotal += DetProva( nHdlPrv, cPadrao, "FINA330", cLote,,,,,,,, @aFlagCTB, {"SE5",nRecnoRA} )
							EndIf
						EndIf

						VALOR2 := 0
						VALOR3 := 0
						VALOR4 := 0
						VALOR5 := 0
						VALOR6 := 0
						VALOR7 := 0
						VALOR8 := 0
						Variacao := 0
						ABATIMENTO  := 0
						aPcc := {}
						aPcc := {.F.,0,0,0,{}}
						nValVa	:= 0
						nValVaTitP := 0
						__nMovRA := 0
						__nMovNF := 0
						dbSelectArea ("SE1")
						dbSetOrder(1)

						If lfa330Bx
							Execblock("FA330BX",.f.,.f.)
						Endif
					Endif
				Next
				
				aBxInteg := aClone( aBaixas )
				
				If lF330SE5 
					ExecBlock("F330SE5",.F.,.F.,{aRecSe5})
				EndIf     						
				nRegSE5 := SE5->(Recno())
				nRegSE1 := SE1->(Recno())
				nRegFK1 := FK1->(Recno())
				
				If lComisCR .and. lComisOn
					dbSelectArea("SE1")
					dbSetOrder(2)
					dbGoto(nRecNo)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Verifica se calcula comissao sobre valores       ³
					//³ de NCC ou RA que compuseram a compencação Receb. ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If mv_par06 == 2 .Or. mv_par13 == 2
						For nLinha:= Len(aBaixas) to 1 Step -1
							lDeleted := .F.
							// Verifica se ha a 6 dimensao na matriz de valores baixados 
							If Len(aBaixas[nLinha][1]) >= 6
								If mv_par06 == 2
									If MV_CRNEG $ SubStr(aBaixas[nLinha][1][6],nTamTit+1,nTamTip)
										ADEL(aBaixas,nLinha)
										ASIZE(aBaixas,Len(aBaixas)-1)
										lDeleted := .T.
									Endif
								Endif
								If mv_par13 == 2 .And. !lDeleted
									If MVRECANT $ SubStr(aBaixas[nLinha][1][6],nTamTit+1,nTamTip)
										ADEL(aBaixas,nLinha)
										ASIZE(aBaixas,Len(aBaixas)-1)
									Endif
								Endif
							Endif
						Next
					Endif
								
					// Nunca calcular comissão sobre títulos de Crédito (NCC/RA)
					For nLinha:= Len(aBaixas) to 1 Step -1	
						If aBaixas[nLinha][1][4] $ MV_CRNEG +"\"+ MVRECANT
							ADEL(aBaixas,nLinha)
							ASIZE(aBaixas,Len(aBaixas)-1)
						EndIf
					Next
					
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Calcula comissao, se houver vendedor		  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If Len(aBaixas) > 0
						SaveInter()
						AeVal( aBaixas, { |x| Fa440CalcB( x, lJuros, .T., "FINA330" ) } )
						RestInter()
					EndIf
				EndIf

				If cPaisLoc == "BRA"  .and. !lCredito
					//IRRF Baixa CR
					If lIrPjBxCr
						VALOR2 := nAcumIRF
					EndIf	
					//PCC Baixa CR
					If lPccBxCr
						If EMPTY(SE5->E5_PRETPIS)
							VALOR3 := nAcumPIS
						ENDIF
						If EMPTY(SE5->E5_PRETCOF)
							VALOR4 := nAcumCOF
						EndIf	
						If EMPTY(SE5->E5_PRETCSL)				
							VALOR5 := nAcumCSL
						EndIf
					EndIf	

					VALOR7  := nDecresNF
					VALOR8  := nAcrescNF

				EndIf

				If lPadrao .and. mv_par09 == 1
					SE5->(dbGoBottom())
					SE5->(dbSkip())
					SE1->(dbGoBottom())
					SE1->(dbSkip())
					FK1->(dbGoBottom())
					FK1->(dbSkip())
					VALOR := If( nValorComp <> __nTotCtb, __nTotCtb, nValorComp ) //"__nTotCtb" tem precisao de mais casas decimais que a "nValorComp"
					IF nMoeda>1
						VALORMF := xMoeda(nValorComp,1,nMoeda,,nDecs1+1,aTxMoedas[nMoeda][2],aTxMoedas[nMoeda][2])
					Endif
					Variacao := nValCorCM
					nSldReal := Round(NoRound(xMoeda(nSaldo,nMoeda,1,,3,Fa330TxMd(nMoeda,0)),3),2)

					ABATIMENTO := 0
					IF !lCredito .and. STR(nSldReal,17,2) == STR(nValorComp,17,2)
						ABATIMENTO := nAbatNf
					Endif

					REGVALOR := nRecno		// Variavel para reposicionar o registro de partida

					nTotal += DetProva( nHdlPrv, cPadrao, "FINA330",cLote,,,,,,,, @aFlagCTB,, )
					RodaProva(  nHdlPrv, nTotal )

					If UsaSeqCor()
						For nX := 1 To Len(aBaixaSE5)
							AAdd(aDiario,{"SE5",aBaixaSE5[nX],cCodDiario,"E5_NODIA","E5_DIACTB"})
						Next nX
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Envia para Lan‡amento Cont bil							  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					lDigita := IIF( mv_par07 == 1,.t., .f. )
					cA100Incl( cArquivo, nHdlPrv, 3, cLote, lDigita, .F.,,,, @aFlagCTB,, aDiario )
					aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

					VALORMF:= 0
					VALOR  := 0
					VALOR2 := 0
					VALOR3 := 0
					VALOR4 := 0
					VALOR5 := 0
					VALOR6 := 0
					VALOR7 := 0
					VALOR8 := 0
					REGVALOR := 0
					Variacao := 0
					ABATIMENTO := 0

				EndIf
				
				//Integração TIN x PROTHEUS
				If lEnvMU070 .And. Len( aBxInteg ) > 0 .And. !lEnvMU330 //Se o adapter de compensação estiver ativado para envio, então não manda a mensagem de baixa
					For nInt := 1 To Len( aBxInteg )
						If AllTrim( aBxInteg[nInt][1][7] ) == "FINI055"
							SE5->( dbGoTo( aBxInteg[nInt][1][3] ) )
							SE1->( dbGoTo( aBxInteg[nInt][1][8] ) )
							
							lOpcAux := ALTERA
							ALTERA := .T.					
							aRetInteg := FwIntegDef( "FINA070", , , , "FINA070" )
							ALTERA := lOpcAux
							
							//Se der erro no envio da integração, então faz rollback e apresenta mensagem em tela para o usuário
							If ValType( aRetInteg ) == "A" .And. Len( aRetInteg ) >= 2 .And. !aRetInteg[1]
								lRet := .F.
								Help( ,, "FINA330INTEGTIN",, STR0087 + AllTrim( aRetInteg[2] ), 1, 0,,,,,, {STR0088} ) //"A compensação não será concluída, pois ocorreu um erro na integração: ", "Verifique se a integração está configurada corretamente."
								DisarmTransaction()
								Exit
							Endif
							
						EndIf
					Next nInt
				EndIf
				
				If lRet
					SE5->(dbGoTo(nRegSE5))
					SE1->(dbGoTo(nRegSE1))
					FK1->(dbGoTo(nRegFK1))
			
					//integracao com modulo PCO
					Fa330IntPco(nRecno, aRegSE1, aBaixaSE5)
			
					If AllTrim(SE1->E1_TIPO) $ "RA"
						If !(Len(aAlt) > 0)
							aadd( aAlt,{ STR0080,'','','',STR0081 +  Alltrim(Transform(nValBx2,cPicE5Val)) })
						EndIf			   
						///chamada da Função que cria o Histórico de Cobrança
						cFilOld := cFilAnt
						cFilAnt := SE1->E1_FILORIG
						FinaCONC(aAlt)                     
						cFilAnt := cFilOld
					EndIf
				EndIf
			
				//Final  da protecao via TTS			
			End Transaction
		ElseIf cPaisLoc == "BRA" .And. __lAltPix .And. !__lTPIConf .And. __nFINPIX9 == 2
			GeraMonPix()
		EndIf

		//Metricas - Gravação da compensação
		If __lMetric .and. nGravados > 0
			nFim := Seconds() - nInicio
			nFim := nFim / nGravados

			SetFunName(__cFunMet)
			FwCustomMetrics():setAverageMetric(Alltrim(ProcName())+" - TempoGravacao", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
			SetFunName(__cFunBkp)
		Endif

		Exit
	EndDo

	If lRetorno
		cPrefixo := CriaVar("E1_PREFIXO")
		cNum	 := CriaVar("E1_NUM")
		cTipoTit := CriaVar("E1_TIPO")
		cCliente := CriaVar("E1_CLIENTE")
		cLoja 	 := CriaVar("E1_LOJA")
		cSaldo	 := CriaVar("E1_SALDO")
		nValor	 := CriaVar("E1_SALDO")
		cParcela := CriaVar("E1_PARCELA")
		nMoeda	 := 1
		nValor	 := 0
		nValTot	 := 0

		// Finaliza a gravacao dos lancamentos do SIGAPCO
		PcoFinLan("000016")

		// Recupera a Integridade dos dados
		dbSelectArea("SE1")
		dbSetOrder(nIndexAtu)
		dbGoTo(nTitIni)

		DeleteObject(oOk)
		DeleteObject(oNo)
		FA330aUnlock()
	EndIf
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ fa330Cli ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 21/03/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica validade do Cliente								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fa330Cli()												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA330													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fa330Cli( )
Local cAlias := Alias( )
dbSelectArea("SA1")
dbSeek(xFilial("SA1")+cCliente)
IF !Found()
	Help(" ",1,"A330CLI")
	Return .F.
Else
	cLoja:=Iif(Empty(cLoja),SA1->A1_LOJA,cLoja)
EndIF
dbSelectArea(cAlias)
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ fa330Loja³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 21/03/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica validade da Loja do Cliente						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fa330Loja() 												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA330													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static FuncTion fa330Loja()
LOCAL cAlias:=Alias()
LOCAL nOrdSe1 := 0
LOCAL lRet := .T.

//PCREQ-3782 - Bloqueio por situação de cobrança
Local cLstCart := FN022LSTCB(1,'0007')	//Lista das situacoes de cobranca (Carteira)
Local cLstNoBlq := FN022LSTCB(6,'0007')	//Lista das situacoes de cobranca (Não bloqueadas para determinado processo)

dbSelectArea("SA1")
dbSeek(xFilial()+cCliente+cLoja)
IF !Found()
	Help(" ",1,"A330LOJA")
	lRet := .F.
Endif
If lRet
	dbSelectArea("SE1")
	nOrdSe1 := IndexOrd()
	dbSetOrder(2)
	If dbSeek(xFilial()+cCliente+cLoja+cPrefixo+cNum+cParcela+cTipoTit)
		If mv_par05 == 2 .and. !(E1_SITUACA $ cLstCart)
			Help(" ",1,"F330CARTE")
			lRet := .F.

		//PCREQ-3782 - Bloqueio por situação de cobrança
		ElseIf !(E1_SITUACA $ cLstNoBlq)
			Help(" ",1,"F330BLOQD",,STR0079,1,0)	//"Não é possível realizar a operação pois o título se encontra em situação de cobrança que não permite manutenção ou movimento financeiro do titulo."
			lRet := .F.
		Endif
	Else
		Help(" ",1,"NOTIT")
		lRet := .F.
	Endif
	dbSetOrder(nOrdSe1)
Endif

dbSelectArea(cAlias)

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³Fa330Tit	³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 22/09/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gera Tabela com os titulos 								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fina330													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function Fa330Tit(dEmissao,cOrigem,lCredito,aNumLay,lAutomato)
//Salva a Integridade dos dados de Entrada
LOCAL cSavArea 	:= alias()
Local cAliasSE1	:= "SE1"
LOCAL lMarca	:= .T.
LOCAL lF330RIO  := ExistBlock("F330RIO")
LOCAL lF330CMP  := ExistBlock("F330CMP")
Local lFI330ALT	:= ExistBlock("FI330ALT")
LOCAL nSavOrd	:= IndexOrd()
LOCAL nRecNo	:= RecNo()
LOCAL nTotComp	:= 0
LOCAL nVlBasico := 0
Local nDecs     := MsDecimais(nMoeda)
Local bWhile    := {|| .T.}
LOCAL nRecEmp  	:= SM0->(RecNo())
Local cCgcClie
Local cNomClie
Local nX 		:= 0
Local nPosNumLay:= 0
Local lFa330Qry := Existblock("FA330QRY")
Local cOrdemSE1
Local lTitRAMex	:= cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT") //Define se o titulo de RA esta disponivel - Manejo de Anticipo
Local lPccBxCr	:= FPccBxCr()								    	//Controla o Pis Cofins e Csll na baixa  (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default) )
Local lIrPjBxCr	:= FIrPjBxCr()									   //Controla IRPJ na baixa
Local aOldBaixaSE5
Local aBxSE5		:= {}
LOCAL nTotAdto		:= 0
Local lBaixaAbat	:= .F.
Local nVlrBaixa		:= 0
Local lBxCec		:= .F.
Local lBxLiq		:= .F.
Local x				:= 0
Local aImpPccIr		:= { SE5->E5_VRETPIS, SE5->E5_VRETCOF, SE5->E5_VRETCSL, SE5->E5_VRETIRF }
Local nSaldoNF		:= 0
Local nTotIrAbt		:= 0
Local nVlMinImp		:= GetNewPar("MV_VL10925",5000)
Local nTotCsAbt		:= 0
Local nTotPisAbt	:= 0
Local nTotCofAbt	:= 0
Local lAplVlMin		:= .T.
Local nValorPcc		:= 0
Local aCamposKey	:= {}
Local nValLim 		:= 0 //Limite de Compensacao
Local nImp          := 0 //Valor dos Imposto (proporcao)
Local nProp         := 0 //proporcao da baixa
Local nValVa		:= 0 //valor acessório
Local nLin			as Numeric

//--- Tratamento Gestao Corporativa
Local lGestao   	:= Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa
//
Local cFilFwSE1 	:= IIF( lGestao, FwFilial("SE1") , xFilial("SE1") )
Local lSE1Exclusivo := .F.
Local nMoedaP		:= 1
Local nMoedaD		:= 1
Local nTaxaP		:= 0
Local nTaxaD		:= 0
Local cSep			:= IIf("|"$MV_CRNEG,"|",",")
Local lNcc			:= SE1->E1_TIPO $ MV_CRNEG 
Local lNcc2			:= .F.
//Impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
Local nPisFin061	:= 0
Local nCofFin061	:= 0
Local nCslFin061	:= 0
Local nIrfFin061	:= 0     
Local nOrdSE5		:= 0
Local nRegSE5		:= 0
Local nOrdSE1		:= 0
Local aDadRetAux	:= {}
/* GESTAO - inicio */

Local cTmpSE1Fil	:= ""
Local aTmpSE1Fil	:= {}
Local aAreaSIX		:= {}
Local aAreaSED		As Array
Local aIndexPE		:= {}
Local lSE1Comp 		:= Empty(FWxFilial("SE1"))
/* GESTAO - fim */
Local aPcc			:= {.F.,0,0,0,{}}
Local aArea			:= {}
Local nValRec2		:= 0
Local nNumAT1		:= 0
Local nNumAT2		:= 0
Local nNumAT3		:= 0
Local nNumAT4		:= 0

//PCREQ-3782 - Bloqueio por situação de cobrança
Local cLstCart 		:= FN022LSTCB(1,'0007')	//Lista das situacoes de cobranca (Carteira)
Local cLstNoBlq 	:= FN022LSTCB(6,'0007')	//Lista das situacoes de cobranca (Não bloqueadas para determinado processo)

Local cQuery   		:= ""
Local cFils			:= ""
Local aStruQry 		:= {}
Local cUserKey		:= SE1->(IndexKey())
Local cSelect		:= " E1_FILIAL, E1_PREFIXO, E1_NUM, E1_PARCELA, E1_IRRF, E1_MOEDA, E1_TIPO, E1_SALDO, E1_EMISSAO, " 
Local cSelect		+= " E1_CLIENTE, E1_LOJA, E1_NOMCLI, E1_SDACRES, E1_SDDECRE, E1_HIST, E1_PIS, E1_COFINS, E1_CSLL, "
Local cSelect		+= " E1_TXMOEDA, E1_VLCRUZ, E1_BASEPIS, E1_BASECOF, E1_BASECSL, E1_VALOR, E1_FILORIG, E1_TXMDCOR, E1_NATUREZ  "
Local lExclus       := NWF->(ColumnPos("NWF_EXCLUS")) > 0 .And. SuperGetMV("MV_JURXFIN",,.F.) // Integração SIGAPFS x SIGAFIN
Local lRaRtImpMR 	:= .F.
Local aImpMRBrw 	:= PegaVarMR()
Local lIrfBxAux 	:= lIrPjBxCr
Local lPccBxAux 	:= lPccBxCr
Local lRetMinAux 	:= .F.
Local lFinLOTab		:= FindFunction("FinLOTab")
Local nPosxRet		:= 0
Local nTaxaMov      := 0
Local dDtMov		:= dDataBase
Local oModelVA		:= Nil
Local nTitSemTx		:= 0
Local aAdianta      := ProtCfgAdt()
Local bFilFIE       := Iif(aAdianta[1,4],{|| FIE_FILORI==cFilAnt .Or. Empty(FIE_FILORI)},{||.T.}) //FIE_FILOI vazio para o legado
Local lAdtPed       := .F.
Local cChaveFIE     := ''
Local cVlAux		:= ''
Local nlimite       := 0
Local nSldConv		:= 0
Local nTotAbtCon	:= 0
Local nPosPnt		:= 0
Local nTamFilA1		:= Len(RTrim(FwxFilial("SA1")))
Local nTamFilE1		:= Len(RTrim(FwxFilial("SE1")))
Local nTamFilED		:= Len(RTrim(FwxFilial("SED")))
Local cTamFilED		:= ""
Local nRecnoF71     := 0
Local nRecnoSE1     := 0
Local lTemImpPix    := .F.
Local lRetorno		:= .T.
Local lFirst        := .T.
Local lContrato		:= .F.
Local cIdDocFK7     := ""
Local nBaseImpos    := 0
Local nValRecOld    := 0
Local cQueryFil		As Character
Local cOriSql   	As Character
Local nPosRetTit	As Numeric
Local lVldSelTit 	As Logical

cQueryFil := ""
cOriSql := iif( !(cPaisLoc $ "BRA") .and. FindFunction('OriSqlCob'),OriSqlCob(),"")
nPosRetTit	:= 0
nLin		:= 0
lVldSelTit	:= .F.	
Default lAutomato   := .F.

aAreaSED		:= {}

cTamFilED	:= AllTrim(STR(nTamFilED))
If lFinLOTab
	cTamFilED	:= FinLOTab("SED")
EndIf

If lExclus
	lExclus := !IsInCallStack("MaIntBxCR")
EndIf

If __cRmProd == Nil
	__cRmProd		:= SuperGetMv('MV_RMORIG',, "E|U|S")
EndIf

If cPaisLoc == "RUS"
	cSelect += ",E1_F5QCODE,E1_CONUNI"
EndIf 
aCamposKey 	:= STRTOKARR(cUserKey,"+")

lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxCr )
lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrPjBxCr )

If ValType(nPis) <> "N"
	nPis	:= 0
EndIf

If ValType(nCofins) <> "N"
	nCofins	:= 0
EndIf

If ValType(nCsll) <> "N"
	nCsll	:= 0
EndIf

If ValType(nIrrf) <> "N"
	nIrrf	:= 0
EndIf
	
//Se o SE1 não for Compartilhado entre todas as Empresas
If !lSE1Comp
	If lGestao
		If !Empty(cFilFwSE1)
			lSE1Exclusivo := .T.
	    EndIf
	Else
		If !Empty(xFilial("SE1"))
			lSE1Exclusivo := .T.
		EndIf
	EndIf
EndIf

aPcc[1]	:= .F.

If dDataBase >= dLastPcc
	nVlMinImp	:= 0
EndIf

If MV_PAR08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR )
	nTotAbat := If(Type("nTotAbat") != "N",SumAbatRec( SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_MOEDA, "S"  ,dBaixa,,@nTotIrAbt,@nTotCsAbt,@nTotPisAbt,@nTotCofAbt,),nTotAbat)
Else
	nTotAbat :=If(Type("nTotAbat") != "N",0,nTotAbat)
EndIf

nValComp := If(Type("nValComp") != "N",0,nValComp)

For nX := 1 to Len(aCamposKey)
	If AT("STR(",UPPER(aCamposKey[nX])) > 0
		aCamposKey[nX] := Substr(aCamposKey[nX], AT("(",aCamposKey[nX])+1, AT(",",aCamposKey[nX])-AT("(",aCamposKey[nX])-1)
	ElseIf AT("(",aCamposKey[nX]) > 0 .Or. AT(")",aCamposKey[nX]) > 0 //Removo da String potenciais chamadas de funcao
		aCamposKey[nX] := Substr(aCamposKey[nX], AT("(",aCamposKey[nX])+1, AT(")",aCamposKey[nX])-AT("(",aCamposKey[nX])-1)
	EndIf
	If !(aCamposKey[nX] $ cSelect)
		cSelect += ","+aCamposKey[nX]
	Endif
Next

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada permite alterar o indice que sera aplicado no Markbrowse ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("FA330ORD")
	nOrdSE1 := ExecBlock("FA330ORD",.F.,.F.)
	If ValType(nOrdSE1) == "N"
		aAreaSIX := SIX->(GetArea())
		If SIX->(DbSeek("SE1" + RetAsc(nOrdSE1,1,.T.))) 
			SE1->(DbSetOrder(nOrdSE1))
			aIndexPE := StrToKarr2(SE1->(IndexKey()),"+",.T.)
			If Len(aIndexPE) > 0
				For nX := 1 to Len(aIndexPE)
				
					nNumAT1	:= AT("STR(",UPPER(aIndexPE[nX]))
					nNumAT2	:= AT("(",aIndexPE[nX])
					nNumAT3 := AT(",",aIndexPE[nX])
					nNumAT4	:= AT(")",aIndexPE[nX])
				
					If nNumAT1 > 0
						aIndexPE[nX] := Substr(aIndexPE[nX], nNumAT2 + 1, nNumAT3 - nNumAT2 - 1)
					ElseIf nNumAT2 > 0 .Or. nNumAT3 > 0 
						aIndexPE[nX] := Substr(aIndexPE[nX], nNumAT2 + 1, nNumAT4 - nNumAT2 - 1)
					EndIf
					If !(aIndexPE[nX] $ cSelect)
						cSelect += "," + aIndexPE[nX]
					Endif
				Next nX
			Else
				If !l330Auto
					Help(" ",1, "FA330ORD",,STR0090,1,0) //"O retorno do Ponto de Entrada 'FA330ORD' esta incorreto. O indice do P.E. não será utilizado."
				Endif
			Endif
		Else
			If !l330Auto
				Help(" ",1, "FA330ORD",,STR0090,1,0) //"O retorno do Ponto de Entrada 'FA330ORD' esta incorreto. O indice do P.E. não será utilizado."
			Endif
		Endif
		RestArea(aAreaSIX)
	Else
		If !l330Auto
			Help(" ",1, "FA330ORD",,STR0090,1,0) //"O retorno do Ponto de Entrada 'FA330ORD' esta incorreto. O indice do P.E. não será utilizado."
		Endif
	Endif
Endif

dBaixa := If (Type("dBaixa") != "D",dDataBase,dBaixa)

//Verificar ou nao o limite de 5000 para Pis cofins Csll
// 1 = Verifica o valor minimo de retencao
// 2 = Nao verifica o valor minimo de retencao
If SE1->E1_APLVLMN == "2"
	lAplVlMin := .F.
Endif

cOrdemSE1 := SE1->(IndexKey())
SE1->(dbSetOrder(1))

dbSelectArea("SX3")
dbSetOrder(2)

MsSeek("E1_SALDO")
aadd(aStruQry,{"E1_SALDO",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})

MsSeek("E1_EMISSAO")
aadd(aStruQry,{"E1_EMISSAO",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})

MsSeek("E1_MOEDA")
aadd(aStruQry, {"E1_MOEDA", SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})

aAreaSED := SED->(GetArea())

SED->(DbSetOrder(1))
SED->(DbSeek(xFilial("SED", SE1->E1_FILORIG) + SE1->E1_NATUREZ))
SA1->(DbSetOrder(1))
SA1->(DbSeek(xFilial("SA1", SE1->E1_FILORIG) + SE1->(E1_CLIENTE+E1_LOJA)))

DbSelectArea("SE1")
SE1->(dbSetOrder(2))

cAliasSE1 := "QRYSE1"

cQuery := "SELECT DISTINCT " + cSelect + ","
cQuery += "SE1.R_E_C_N_O_ RECSE1, A1_CGC "

If lCredito
	cQuery += ", SEDBRW.ED_CALCIRF, SEDBRW.ED_CALCPIS, SEDBRW.ED_CALCCOF, SEDBRW.ED_CALCCSL FROM "
Else
	cQuery += "FROM "
EndIf

cQuery += RetSqlName("SE1") + " SE1 LEFT JOIN "
cQuery += RetSqlName("SA1") + " SA1 ON (SE1.E1_LOJA = SA1.A1_LOJA) AND (SE1.E1_CLIENTE = SA1.A1_COD) "

If nTamFilA1 == nTamFilE1
	cQuery	+= " AND SA1.A1_FILIAL = SE1.E1_FILIAL "
Else
	If nTamFilA1 == 0
		cQuery	+= " AND SA1.A1_FILIAL = ' ' "
	Else
		If lOracle
			cQuery	+= " AND RTRIM(SA1.A1_FILIAL) = SUBSTRING(SE1.E1_FILORIG,1, " + AllTrim(Str(nTamFilA1)) + ") "
		Else
			cQuery	+= " AND SA1.A1_FILIAL = SUBSTRING(SE1.E1_FILORIG,1, " + AllTrim(Str(nTamFilA1)) + ") "
		EndIf
	EndIf
EndIf

If lTitRAMex //Manejo de Anticipo - Mexico
	cQuery += " LEFT JOIN " + RetSqlName("SED") + " SED ON SE1.E1_NATUREZ = SED.ED_CODIGO "
EndIf

If lCredito
	cQuery += " LEFT JOIN " + RetSqlName("SED") + " SEDBRW ON SE1.E1_NATUREZ = SEDBRW.ED_CODIGO AND "
	If nTamFilED == 0
		cQuery += " SEDBRW.ED_FILIAL = '" + FwxFilial("SED") + "' "
	Else
		cQuery += " SEDBRW.ED_FILIAL = SUBSTRING(E1_FILORIG,1," + cTamFilED + ") "
	EndIf
	cQuery += " AND SEDBRW.D_E_L_E_T_ = ' ' "
EndIf

If lExclus // Integração SIGAPFS x SIGAFIN
	cQuery += " LEFT JOIN " + RetSqlName("NWF") + " NWF ON NWF.NWF_TITULO = SE1.E1_NUM AND SE1.E1_ORIGEM = 'JURA069' "
EndIf

cQuery += " WHERE "

If dDatabase >= dLastPcc .And. (lRaRtImp  .Or. lRaRtImpMR) .And. lRatFields .And. !SE1->E1_TIPO $ MV_CRNEG .And. lPccBxCr
	cQuery += "EXISTS (SELECT ED_CODIGO, ED_DESCRIC ,ED_CALCCSL , ED_CALCCOF, "
	cQuery += "ED_CALCPIS, ED_PERCCSL, ED_PERCCOF, ED_PERCPIS FROM " + RetSqlName("SED") + " WHERE D_E_L_E_T_ = ' ' "
	
	If (SED->ED_CALCPIS == "S" .And. SED->ED_PERCPIS > 0 .And. SA1->A1_RECPIS $ "S|P") .Or. (SED->ED_CALCCOF == "S" .And. SED->ED_PERCCOF > 0 .And. SA1->A1_RECCOFI $ "S|P") .Or. (SED->ED_CALCCSL == "S" .And. SED->ED_PERCCSL > 0 .And. SA1->A1_RECCSLL $ "S|P")
		If (SED->ED_CALCPIS == "S" .And. SED->ED_PERCPIS > 0 .And. SA1->A1_RECPIS $ "S|P")
			cQuery += "AND ED_CALCPIS = 'S' AND ED_PERCPIS > 0 "
		EndIf
		
		If (SED->ED_CALCCOF == "S" .And. SED->ED_PERCCOF > 0 .And. SA1->A1_RECCOFI $ "S|P")
			cQuery += "AND ED_CALCCOF = 'S' AND ED_PERCCOF > 0"
		EndIf
		
		If (SED->ED_CALCCSL == "S" .And. SED->ED_PERCCSL > 0 .And. SA1->A1_RECCSLL $ "S|P")
			cQuery += "AND ED_CALCCSL = 'S' AND ED_PERCCSL > 0 "
		EndIf
	Else
		cQuery += "AND ED_CALCCSL = 'S' AND ED_PERCCSL > 0 AND ED_CALCCOF = 'S' AND ED_PERCCOF > 0 "
		cQuery += "AND ED_CALCPIS = 'S' AND ED_PERCPIS > 0 "
	EndIf
	
	cQuery += ") AND "
EndIf

If !Empty(__aFil330) //Array de filiais proveniente da execução automática
	aSelFil := aClone(__aFil330)
	__lUsaFil := .T.
EndIf

If ( __cCompSE1 == "CCC" ) .And. !__lUsaFil	//Caso seja compartilhado e não tenha selecionado nenhuma Filial - Será considerado E2_FILIAL e não E2_FILORIG
	cQuery += "SE1.E1_FILIAL = '" + FWxFilial("SE1") + "' AND "
Else

	If Empty(aSelFil)
		aSelFil := { cFilAnt }
	EndIf

	cQueryFil := FinSelFil(aSelFil, "SE1", __cCompSE1<>"EEE", .T.) + " AND "
	
	If __cRelease <= "12.1.2210" .And. ( __cCompSE1 == "EEC" .Or. __cCompSE1 == "ECC" )//Remover esse trecho após expiração da release 12.1.2210 (DFINCOM-14797)
		cFils	:= GetRngFil( aSelFil, "SE1", .T., @cTmpSE1Fil)

		If !lSE1Exclusivo
			If len(aSelFil) == 1 .And. aSelFil[1] == cFilAnt
				cQueryFil := "SE1.E1_FILORIG = '" + cFilAnt + "' AND "  
			Else
				cQueryFil := "SE1.E1_FILIAL " + cFils  + " AND "  
			EndIf
		EndIf
	EndIf

	cQuery += cQueryFil
EndIf

If mv_par02 == 1
	cQuery += "SE1.E1_CLIENTE = '"+cCliente+"' AND "
Else
	cQuery += "SE1.E1_CLIENTE >= '"+mv_par03+"' AND "
	cQuery += "SE1.E1_CLIENTE <= '"+mv_par04+"' AND "
EndIf

If mv_par01 == 1 .And. mv_par02 == 1
	cQuery += "SE1.E1_LOJA = '"+cLoja+"' AND "
EndIf

If ( lRaRtImp .Or. lRaRtImpMR ) .And. lRatFields .and. !(SE1->E1_TIPO $ MV_CRNEG)
	If !lCredito
		cQuery +="( ( "
	EndIf
	
	If lPccBxCr
		If !__lPccMR .Or. ( !__lPccMR .And. __lRaRtPcc )
			If lCredito
				cQuery += " SEDBRW.ED_CALCPIS = '" + SED->ED_CALCPIS + "' AND "
			Else
				If SE1->E1_PIS > 0
					cQuery += " E1_PIS > 0 AND "
				Else
					cQuery += " E1_PIS = 0 AND "
				EndIf
			EndIf
			If lCredito
				cQuery += " SEDBRW.ED_CALCCOF = '" + SED->ED_CALCCOF + "' AND "
			Else
				If SE1->E1_COFINS > 0
					cQuery += " E1_COFINS > 0 AND "
				Else
					cQuery += " E1_COFINS = 0 AND "
				EndIf
			EndIf
			If lCredito
				cQuery += " SEDBRW.ED_CALCCSL = '" + SED->ED_CALCCSL + "' AND "
			Else
				If SE1->E1_CSLL > 0
					cQuery += " E1_CSLL > 0 AND "
				Else
					cQuery += " E1_CSLL = 0 AND "
				EndIf
			EndIf
		EndIf
	EndIf
	
	If lIrPjBxCr
		If !__lIrfMR .Or. ( !__lIrfMR .And. __lRaRtIrf )
			If lCredito
				cQuery += " SEDBRW.ED_CALCIRF = '" + SED->ED_CALCIRF + "' AND "
			Else
				If SE1->E1_IRRF > 0
					cQuery += " ( E1_IRRF > 0 OR A1_RECIRRF = '1' ) AND "
				Else
					cQuery +=" E1_IRRF = 0 AND "
				EndIf
			EndIf
		EndIf
	EndIf
	
	If !lCredito .And. cPaisLoc == "BRA"
		If !__lIssMR .Or. ( !__lIssMR .And. __lRaRtIss )
			If SE1->E1_ISS>0
				cQuery += " E1_PRISS > 0 AND "
			Else
				cQuery += " E1_PRISS = 0 AND "
			EndIf
		EndIf
		If SE1->E1_INSS>0
			cQuery += " E1_PRINSS > 0 AND "
		Else
			cQuery += " E1_PRINSS = 0 AND "
		EndIf
	ElseIf cPaisLoc == "BRA"
		If !__lIssMR .Or. ( !__lIssMR .And. __lRaRtIss )
			If SE1->E1_PRISS>0
				cQuery += " E1_ISS > 0 AND "
			Else
				cQuery += " E1_ISS = 0 AND "
			EndIf
		EndIf
		If SE1->E1_PRINSS>0
			cQuery += " E1_INSS > 0 AND "
		Else
			cQuery += " E1_INSS = 0 AND "
		EndIf
	EndIf
	
	If !lCredito
		cQuery +=  " E1_TIPO IN "+ FormatIn(MVRECANT,",") + ") OR "
		cQuery +=  " E1_TIPO IN "+ FormatIn(MV_CRNEG,",") + ") AND "
	EndIf

EndIf

If mv_par05 == 2
	cQuery += " SE1.E1_SITUACA IN "+FormatIN(cLstCart,"|")+" AND "
Else
	//PCREQ-3782 - Bloqueio por situação de cobrança
	cQuery += " SE1.E1_SITUACA IN "+FormatIn(cLstNoBlq,'|')+" AND "
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Caso titulos originados pelo SIGALOJA estejam nas carteiras :  ³
//³I = Carteira Caixa Loja                                        ³
//³J = Carteira Caixa Geral                                       ³
//³Nao permitir a selecao destes titulos                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cQuery += "SE1.E1_SITUACA NOT IN ('I','J') AND "
cQuery += "SE1.E1_ORIGEM NOT IN " + FormatIN(__cRmProd, "|" ) + " AND "

If cPaisLoc <> "BRA"
	If lCredito
		cQuery += "SE1.E1_TIPO NOT IN " + FormatIn( MV_CRNEG+cSep+MVRECANT,cSep) + " AND "
	Else
		cQuery += "SE1.E1_TIPO IN " + FormatIn( MV_CRNEG+cSep+MVRECANT,cSep) + " AND "
	EndIf
Else
	If lCredito
		cQuery += "SE1.E1_TIPO NOT IN " + FormatIn( MV_CRNEG+cSep+MVRECANT+cSep+MVPROVIS,cSep) + " AND "
	Else
		If (cTipoTit $ MVRECANT .And. cTipoTit $ MV_CRNEG )
			cQuery += " (SE1.E1_TIPO NOT IN " + FormatIn(MVRECANT,",") + " OR  "
			cQuery += "SE1.E1_TIPO NOT IN " + FormatIn( MV_CRNEG,cSep) + ") AND "
		ElseIf !(cTipoTit $ MVRECANT) .And. !(cTipoTit $ MV_CRNEG )
			cQuery += " ( SE1.E1_TIPO IN " + FormatIn(MVRECANT,",") + " OR  "
			cQuery += "SE1.E1_TIPO IN " + FormatIn( MV_CRNEG,cSep) + ") AND "
		EndIf
	EndIf
EndIf

If cPaisLoc == "RUS"
	lContrato := IIf(Empty(cNumCont), .F., .T.)
	If lContrato
		cQuery += "SE1.E1_F5QCODE = '" + cNumCont + "' AND "
	EndIF
	If lFilterMark .Or. (!EMPTY(cTitFilt))
		cQuery += cTitFilt
	EndIf
EndIf

cQuery += "SE1.E1_TIPO NOT IN " + FormatIn(MVABATIM,"|") + " AND "
cQuery += "SE1.E1_SALDO > 0 AND "
cQuery += "SE1.E1_EMISSAO <= '"+DtoS(dDatabase)+ "' AND "
cQuery += "SE1.D_E_L_E_T_ = ' ' AND "

If !Empty(aSelFil)
	cQuery += "SA1.A1_FILIAL " + GetRngFil( aSelFil, "SA1", .T., @cTmpSE1Fil) + " AND "
	Aadd(aTmpSE1Fil,cTmpSE1Fil)
Else
	cQuery += "SA1.A1_FILIAL = '"+ xFilial("SA1")+"' AND "
EndIf

cQuery += "SA1.D_E_L_E_T_ = ' ' "

If lTitRAMex //Manejo de Anticipo - Mexico. Tratamento para nao exibir titulo de RA provenientes de notas de adiantamento.

	/* GESTAO - inicio */
	If !Empty(aSelFil)
		cQuery += " AND SED.ED_FILIAL " + GetRngFil( aSelFil, "SED", .T., @cTmpSE1Fil)
		Aadd(aTmpSE1Fil,cTmpSE1Fil)
	Else
		cQuery += "	AND SED.ED_FILIAL = '" + XFilial("SED") + "'"
	EndIf
	/* GESTAO - fim */
	cQuery += " AND SED.D_E_L_E_T_	= '' "
	cQuery += "	AND SE1.E1_TIPO		<> '" + Substr(MVRECANT,1,3) + "'" //"RA" no Mexico
	cQuery += "	AND SE1.E1_ORIGEM	<> 'FINA087A'  " + cOriSql +" AND "
	cQuery += " SE1.D_E_L_E_T_ = ' ' "
	cQuery += "	AND SED.ED_OPERADT	<> '1' AND " //Operacao de adiantamento igual a SIM
	cQuery += " SE1.E1_SALDO > 0 AND "
	cQuery += " SE1.D_E_L_E_T_ = ' ' AND "
	If mv_par02 == 2
   		cQuery += "SE1.E1_CLIENTE = '"+cCliente+"'"
	Else
   		cQuery += "SE1.E1_CLIENTE >= '"+mv_par03+"' AND "
   		cQuery += "SE1.E1_CLIENTE <= '"+mv_par04+"'"
	EndIf
EndIf

If lExclus // Integração SIGAPFS x SIGAFIN
	cQuery += " AND ((NWF.NWF_EXCLUS = '2' AND NWF.D_E_L_E_T_ = ' ') OR NWF.NWF_EXCLUS IS NULL) "
EndIf

If FindFunction('FINTP02')
	cQuery += FINTP02() // retornar o filtro de bloqueio do titulo do TIN  AND E1_ORIGEM <> 'FINI055'
EndIf
If cPaisLoc == "RUS" .and. !Empty(cSortType) .and. !Empty(cSortField) //changes to use order set by user on screen
	cQuery += "ORDER BY " + cSortField + ' ' + cSortType
Else
	cQuery += "ORDER BY " + SqlOrder(cOrdemSE1)
EndIf
	

If lFa330Qry
	cQuery := Execblock("FA330QRY",.f.,.f.,{ cQuery }  )			// permite manipualção das query
EndIf

cQuery := ChangeQuery(cQuery)
dbUseArea(.T., "TOPCONN", TCGENQRY(Nil, Nil, cQuery), cAliasSE1, .F., .T.)
(cAliasSE1)->(DbGotop())
RestArea(aAreaSED)

If !(cAliasSE1)->(Eof()) 
	For nX := 1 To Len(aStruQry)
		If ( aStruQry[nX][2] <> "C" )
			TcSetField(cAliasSE1,aStruQry[nX][1],aStruQry[nX][2],aStruQry[nX][3],aStruQry[nX][4])
		EndIf
	Next nX
EndIf

bWhile := {|| (cAliasSE1)->(!Eof()) }

ProcRegua((cAliasSE1)->(Reccount()), STR0032)

aTitulos := {}
aRecNo 	 := {}

lVldSelTit := lAutomato .And. Type("aRetAuto") == "A"  .And. Type("aRetAuto[2]") == "A" .And. Len(aRetAuto[2]) > 0 .And. Len(aRetAuto[2][1]) >= 5 

While .T.
	dbSelectArea(cAliasSE1)
	
	cFilAnt := IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL )
	nIndVld := IndexOrd()
	nRecVld := SE1->(Recno())
	
	If __l330Va
		oModelVA	:= FWLoadModel("FINA070VA")
	EndIf
	
	While Eval(bWhile)
	   	IncProc()
		cFilAnt := (cAliasSE1)->E1_FILIAL
		
		If !Empty((cAliasSE1)->E1_FILORIG)
			cFilAnt := (cAliasSE1)->E1_FILORIG
		EndIf
		
		If lVldSelTit .And. (nPosRetTit := Ascan(aRetAuto[2],{|x|x[5] == (cAliasSE1)->(E1_FILIAL + E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO )} )) == 0 
		 	(cAliasSE1)->(dbSkip())
			Loop
		EndIf
		
		//PONTO DE ENTRADA F330RIO Tratamento de "filtragem" de titulos de adiantamento a serem
		//considerados ou nÆo no array dos adiantamentos a serem compen sados. Retorno l¢gico
		If lF330RIO .And. !(ExecBlock("F330RIO",.F.,.F.))
			dbSkip()
			Loop
		EndIf
		
		dbselectArea("SE1")
		SE1->( dbSetOrder( 1 ) ) //E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO
		SE1->( dbSeek( (cAliasSE1)->(E1_FILIAL) + (cAliasSE1)->(E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO) ) )
		dbselectArea(cAliasSE1)
		
		//Na finalizacao do Lay-Away, seleciona somente os titulos gerados pela emissao do mesmo - Loc. EUA|POR
		If cOrigem == "LOJA800"
		   nPosNumLay  := Ascan(aNumLay,AllTrim((cAliasSE1)->E1_NUM))
		   
		   If nPosNumLay == 0 .And. Len(aNumLay) > 0
		       dbSkip()
			   Loop
		   EndIf
		EndIf
		
		nRecnoF71  := 0
		nRecnoSE1  := 0
		lTemImpPix := .F.
		
		If cPaisLoc == "BRA" .And. __lExcImpo .And. __TpGerPix .And. !__lCNABImp .And. SE1->E1_SITUACA != "0"
			nRecnoSE1 := SE1->(Recno())
			nRecnoF71 := F71Ativa(nRecnoSE1)
			
			If nRecnoF71 > 0 .And. TtBxImpPix(nRecnoSE1)
				lTemImpPix := !BorderoImp(SE1->E1_FILORIG, SE1->E1_NUMBOR, "R", SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA)
				
				If lTemImpPix
					If lFirst
						lFirst   := .F.
						lRetorno := IIf(lAutomato, __lMaTiPix, MsgTtBxPix(.T., .T., .F., .F.))
					EndIf
					
					If lAutomato .And. !lRetorno
						(cAliasSE1)->(DbSkip())
						Loop
					ElseIf lRetorno .And. ExcluiImpo(SE1->E1_FILIAL, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, nRecnoF71)
						lTemImpPix := .F.
						cIdDocFK7  := FINBuscaFK7(SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), "SE1", SE1->E1_FILORIG)					
						
						If PIXCancel(SE1->E1_FILIAL, cIdDocFK7, .T.)
							AAdd(__aRecF71, {nRecnoF71, (SE1->E1_FILIAL+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA), SE1->E1_FILORIG})
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		
		//ANGOLA|BRASIL|RUSSIA - Nao permitir compensar titulos de adiantamento relacionado a pedido
		If cPaisLoc $ "ANG|BRA|RUS" .And. !__lCmpM460
			FIE->(dbSetOrder(2))
			cChaveFIE := xFilial("FIE")+"R"+(cAliasSE1)->(E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)
			If FIE->(MsSeek(cChaveFIE))
				While FIE->(! Eof() .And. FIE_FILIAL+FIE_CART+FIE_CLIENT+FIE_LOJA+FIE_PREFIX+FIE_NUM+FIE_PARCEL+FIE_TIPO) == cChaveFIE
					lAdtPed := FIE->(Eval(bFilFIE))
					iF lAdtPed 
						Exit
					EndIf	
					FIE->(dbSkip())
				EndDo
				If lAdtPed
					__lNTitFIE	:= .T.
					(cAliasSE1)->(dbSkip())
					Loop
				EndIf	
			EndIf
		EndIf
		
		//Motor de retenções
		If __lMotRet
			ClrVarMRCl()
			//Verifica as configurações de impostos pelo motor de retenção
			__lTCnfgMR  := F330VldImp()	
			lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
			lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
			lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
			
			//Calcula os impostos pelo motor de retenções
			If __lTCnfgMR .And. !lTemImpPix
				F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, IIf(nSaldo > SE1->E1_SALDO, SE1->E1_SALDO, nSaldo) , dDataBase, SE1->E1_TIPO, .T. )
				__lTCnfgMR	:= .F.
			EndIf
		EndIf 
		
		nDesFin := 0
		
		if lCredito
			nDescD := nDesFin := getDesc()
		endIf
		
		nVlBasico 	:= IIf (nValor = 0 , nSaldo , nValor)
		nValRec		:= IIf (nValor = 0 , nSaldo , nValor)
		nOldValRec	:= nSaldo
		lMarca		:=	.F.
		
		//VA: Calcula o valor acessório
		If __l330Va
			nMoedaBco	:= SE1->E1_MOEDA
			nValVa		:= FA330VACAL(oModelVA)
		EndIf
		
		//Verifica RA se tem movimento no SE5 para obter a data do movimento
		If (cAliasSE1)->E1_TIPO $ MVRECANT .And. (cAliasSE1)->E1_MOEDA > 1 .And. __lRaTxMov
			aMovRA := F330MovRA(Nil, cAliasSE1, .T.)
					
			If aMovRA[1]
				dDtMov	:= aMovRA[2]
			EndIf
		Else
			dDtMov := dDatabase
		EndIf
		
		//Definição da taxa do movimento
		If cPaisLoc == "BRA"
			//Cenários com taxa contratada
			If (cAliasSE1)->E1_MOEDA != 1 
				If !Empty((cAliasSE1)->E1_TXMOEDA)	// Verifica se existe taxa contratada
					If __lTxConP .And. __lCmTxCon	//Verifica se o título da partida possui taxa contratada e se gera variação
						If !(cAliasSE1)->E1_TIPO $  MVRECANT + "|" + MV_CRNEG
							nTaxaMov := __nTxMoedP
						Else
							nTaxaMov := (cAliasSE1)->E1_TXMOEDA
						EndIf
					Else
						If !lFa330Qry .And. !Empty((cAliasSE1)->E1_TXMDCOR) .And. !__lCmTxCon 	//Se já sofreu variação(FINA350) e nao gera vairiação a taxa utilizada é a da variação
							nTaxaMov := (cAliasSE1)->E1_TXMDCOR
						Else
							nTaxaMov := Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA)
						Endif
					EndIf
				Else
					If __lTxMoed .And. ((!lCredito .And. !__lRaTxMov) .Or. lCredito) // Se o título de partida não é adiantamento (lCredito) e não utiliza a taxa do movimento, pego a taxa digitada
						nTaxaMov := aTxMoedas[(cAliasSE1)->E1_MOEDA][2]
					Else
						nTaxaMov := RecMoeda(dDtMov, (cAliasSE1)->E1_MOEDA)
					EndIf
				EndIf
					
			ElseIf __lTxConP 	//Verifica se o título da partida possui taxa contratada
				nTaxaMov := __nTxMoedP
			Else
				If __lRaTxMov .And. __nMoePart == (cAliasSE1)->E1_MOEDA
					nTaxaMov := RecMoeda(dDtMov, nMoeda) //obs pegando por padrão a taxa do dia do movimento
				Else
					nTaxaMov := __nTxMoedP 
				Endif
			EndIf
			
			If (cAliasSE1)->E1_MOEDA != 1 .And. Empty(nTaxaMov) //Não lista títulos sem conseguir defifinir sua taxa
				nTitSemTx ++
				(cAliasSE1)->(DbSkip())
				Loop
			EndIf
		EndIf
		
		If (nVlBasico > nTotComp .or. nTotComp == 0)  .And. Fa330Lock(Nil, (cAliasSE1)->RECSE1, .F.) .and.  !((cAliasSE1)->E1_TIPO $ MV_CRNEG) 
	    	lMarca  := !lTemImpPix
			nValPre := IIF (nTotComp == 0 , nVlBasico, nVlBasico - nTotComp)
			
			If cPaisLoc == "BRA"				
				If (mv_par08 == 1 .Or. ((lRaRtImp .Or. lRaRtImpMR) .And. !lNcc)) .And. !((cAliasSE1)->E1_TIPO $ MVRECANT+"/"+MV_CRNEG )
					nTotCsAbt	:= 0
					nTotPisAbt	:= 0
					nTotCofAbt	:= 0
					nTotIrAbt	:= 0
					nTotAbat 	:= SumAbatRec((cAliasSE1)->E1_PREFIXO,(cAliasSE1)->E1_NUM,(cAliasSE1)->E1_PARCELA,(cAliasSE1)->E1_MOEDA,"S",dBaixa,,@nTotIrAbt,@nTotCsAbt,@nTotPisAbt,@nTotCofAbt)
					
					If lIrPjBxCr .And. lCredito .And. (cAliasSE1)->E1_IRRF > 0 .And. !lNcc
						If __lIrfMR
							nIrrf := __nIrfCaMR
						Else
							aArea := SE1->(GetArea())
							
							If !( SE1->E1_TIPO $ MVRECANT )
								SE1->(DbGoTo(nRecno))
							EndIf
							
							If !lTemImpPix .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
								nIrrf := FCaIrBxCR(SE1->E1_SALDO)
							EndIf
							
							RestArea(aArea)
						EndIf
						
						If (nPosIr := ascan( aImpIR, {|x| x[2] = SE1->(REcno())} ) ) = 0
							aAdd(aImpIR,{nIrrf,SE1->(Recno())})
							nPosIr := Len( aImpIR )
						Else
							aImpIR[nPosIr][1] := nIrrf
						EndIf
					EndIf
					
					//Se PCC Baixa CR e nao houver abatimento de impostos
					If cPaisLoc == "BRA" .And. !lAutomato .And. ( lPccBxCR .And. ( !lRartimp .And. !lRaRtImpMR ) .And. ( nTotCsAbt + nTotPisAbt + nTotCofAbt == 0 ) ) .Or. ;
					( ( lRartimp .Or. lRaRtImpMR ) .And. (cAliasSE1)->(E1_PIS + E1_CSLL + E1_COFINS) == 0 )
						//Se PCC Baixa CR e a compensação partiu de um adiantamento
						//Os titulos nao serao pre-selecionados.
						//Isto se da para que a cada titulo marcado, seja realizado o cálculo do PCC
						lMarca := .F.
					EndIf
				Else
					If lIrPjBxCr .And. !((cAliasSE1)->E1_TIPO $ MVRECANT+"/"+MV_CRNEG )
                    	If lCredito .And. (cAliasSE1)->E1_IRRF > 0
							If __lIrfMR
								nIrrf := __nIrfCaMR
							ElseIf !lTemImpPix .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
								nIrrf := FCaIrBxCR(SE1->E1_SALDO)
							EndIf
							
							If ( nPosIr := ascan( aImpIR, {|x| x[2]=SE1->(REcno())} ) ) = 0
					  			aAdd(aImpIR,{nIrrf,SE1->(Recno())})
					  			nPosIr := Len( aImpIR )
				   			Else
					  			aImpIR[nPosIr][1] := nIrrf
			   				EndIf
						EndIf
	     			Else
	     		   		nTotAbat := 0
					EndIf
				EndIf
				
				//Se PCC Baixa CR e nao houver abatimento de impostos
				If cPaisLoc == "BRA" .And. lPccBxCR .And. (nTotCsAbt + nTotPisAbt + nTotCofAbt == 0) .And. (!lRartimp .And. !lRaRtImpMR) .And. (lCredito .And. !lAutomato)
					//Se PCC Baixa CR e a compensação partiu de um adiantamento
					//Os titulos nao serao pre-selecionados.
					//Isto se da para que a cada titulo marcado, seja realizado o cálculo do PCC
					lMarca := .F.
				ElseIf lAutomato .And. TitNMarca(cAliasSE1)
					lMarca	:= .F.
				EndIf
				
				If dDataBase < dLastPcc .And. nPis <> E1_PIS .And. nCofins <> E1_COFINS .and. nCsll <> E1_CSLL .and. nIrrf <> E1_IRRF
					nPis    := aImpPccIr[1]
					nCofins := aImpPccIr[2]
					nCsll   := aImpPccIr[3]
					nIrrf   := aImpPccIr[4]
				EndIf
				
				nValComp := 0
				
				//Valores Acessórios
				If !FA330Msg(lAutomato,If(lCredito,nValVa,__nValVa),(cAliasSE1)->E1_SDACRES)
					lMarca := .F.
				Endif
				
				If lMarca
					nValComp := Iif(nValPre > xMoeda((cAliasSE1)->E1_SALDO - nDescD - nTotAbat +(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE + nValVa - __nImpMR,(cAliasSE1)->E1_MOEDA,nMoeda,,__nCasDec,nTaxaMov,Fa330Tx2(nMoeda,nTxMoeda)),;
									xMoeda((cAliasSE1)->E1_SALDO - nDescD - nTotAbat+(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE + nValVa - __nImpMR,(cAliasSE1)->E1_MOEDA,nMoeda,,__nCasDec,nTaxaMov,Fa330Tx2(nMoeda,nTxMoeda)), nVlBasico-nTotComp)

					If nPosRetTit > 0 .And. aRetAuto[2][nPosRetTit][6] > 0 .And. aRetAuto[2][nPosRetTit][6] < nValComp																		
						nValComp := aRetAuto[2][nPosRetTit][6]						
					EndIf
				EndIf
			Else
	 	       nValComp := Iif (nValPre > xMoeda((cAliasSE1)->E1_SALDO+(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,dDatabase,,aTxMoedas[E1_MOEDA][2],aTxMoedas[nMoeda][2]),;
			                Round(xMoeda((cAliasSE1)->E1_SALDO+(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,dDatabase,nDecs+1,aTxMoedas[E1_MOEDA][2],aTxMoedas[nMoeda][2]),nDecs), nVlBasico-nTotComp)
			EndIf
			
			//PONTO DE ENTRADA F330CMP
			//Tratamento de valor a ser compensado em determinado titulo permitindo que o usuario possa calcular o valor do titulo NDF ou PA a ser compensado
			IF lF330CMP
				nValComp:= ExecBlock("F330CMP",.F.,.F.)
			EndIf
			
			nTotComp += If( nMoeda > 1, Round(nValComp,2), nValComp)
		Else
			If lAutomato
				nValPre := IIF (nTotComp == 0 , nVlBasico, nVlBasico - nTotComp)
				nValComp := Iif (nValPre > Round(NoRound(xMoeda((cAliasSE1)->E1_SALDO - nTotAbat +(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE+nValVa,(cAliasSE1)->E1_MOEDA,nMoeda,,3,Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA),Fa330Tx2(nMoeda,nTxMoeda)),3),2) , ;
							xMoeda((cAliasSE1)->E1_SALDO - nTotAbat+(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE+nValVa,(cAliasSE1)->E1_MOEDA,nMoeda,,5,Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA),Fa330Tx2(nMoeda,nTxMoeda)),;
							nVlBasico-nTotComp)
			EndIf
			
			If cPaisLoc == "BRA"
				If (mv_par08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR ) ) .And. !((cAliasSE1)->E1_TIPO $ MVRECANT+"/"+MV_CRNEG )
					nTotCsAbt	:= 0
					nTotPisAbt	:= 0
					nTotCofAbt	:= 0
					nTotIrAbt   := 0
					nTotAbat := SumAbatRec((cAliasSE1)->E1_PREFIXO,(cAliasSE1)->E1_NUM,(cAliasSE1)->E1_PARCELA,(cAliasSE1)->E1_MOEDA,"S",dBaixa,,@nTotIrAbt,@nTotCsAbt,@nTotPisAbt,@nTotCofAbt)
					If lNcc .And. ( lRaRtImp .Or. lRaRtImpMR ) .And. ((cAliasSE1)->E1_VALOR > (cAliasSE1)->E1_SALDO)
						aOldBaixaSE5 := aClone(aBaixaSE5)
						aBaixaSE5:= {}

						// Soma a proporcionalização de iss e inss ao nValrec 
						aBxSE5 := Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /"+MV_CRNEG,(cAliasSE1)->E1_PREFIXO,(cAliasSE1)->E1_NUM,(cAliasSE1)->E1_PARCELA,;
					   							(cAliasSE1)->E1_TIPO,@nTotAdto,@lBaixaAbat,(cAliasSE1)->E1_CLIENTE,;
												(cAliasSE1)->E1_LOJA,@nVlrBaixa,,@lBxCEC,@lBxLiq,,.T.)
						For x := 1 To Len(aBaixaSE5)
					 		nTotAbat -= aBaixaSE5[x][32]+aBaixaSE5[x][33]
						Next
						aBaixaSE5 := aClone(aOldBaixaSE5)
					EndIf
				Else
					nTotAbat := 0
				EndIf
			EndIf
			
			If !lAutomato
				lMarca 		:= .F.		// desmarca para vers„o WIN
				nValComp 	:= 0
				nValPre 	:= nVlBasico
			EndIf
		EndIf
		
		If !__lDizPer .And. !lPccBxCR .And. lCredito
			cVlAux		:= AllTrim(Str(nValComp) )
			nPosPnt		:= AT(".", cVlAux)
			__lDizPer 	:= Iif(nPosPnt > 0, Len( SubStr(cVlAux, nPosPnt + 1, 5 ) ) >= 4, .F.)
		EndIf
		
		nValLim    := 0
		nSldConv   := xMoeda(SE1->E1_SALDO,  SE1->E1_MOEDA, nMoeda , dDtMov, __nCasDec, IIF(SE1->E1_MOEDA > 1,nTaxaMov,0), __nTxMoedP)
		nTotAbtCon := xMoeda(nTotAbat,  SE1->E1_MOEDA, nMoeda , dDtMov, __nCasDec, IIF(SE1->E1_MOEDA > 1,nTaxaMov,0), __nTxMoedP)

		If cPaisLoc == "BRA"
			nMoedaP := (cAliasSE1)->E1_MOEDA
			If nMoedaP > 1
				If __lRaTxMov
					nTaxaP	:= (cAliasSE1)->E1_TXMOEDA
					If Empty(nTaxaP)
						nTaxaP := nTaxaMov
					EndIf
				Else
					nTaxaP  :=  Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA) 
				Endif
			EndIf
			
			// Moeda de Destino
			nMoedaD := nMoeda		
			nTaxaD	:= __nTxMoedP			
			nVAlSld := (cAliasSE1)->(E1_SALDO+E1_SDACRES-E1_SDDECRE) - nDesFin + nValVa
			nValSld := FA330Valor(nValSld, (cAliasSE1)->E1_MOEDA, nMoeda, dDataBase, nTaxaMov, .F.)
			
			If (lPccBxCr .Or. lIRPJBxCr) .And. ( lRaRtImp .Or. lRaRtImpMR ) .And. !lNcc

				If lCredito
					aAdd(aDadosRA1[2],(cAliasSE1)->RecSe1)
				Else
					aAdd(aDadosRA1[1],(cAliasSE1)->RecSe1)
				EndIf
				
				If !lCheck .And. ( lRaRtImp .Or. lRaRtImpMR ) 
					lMarca := .F. // Desmarca caso selecionado para trazer os títulos desmarcados, para que não ocorra erro no cálculo dos impostos quandos os títulos forem marcados
				EndIf

				aAdd(aDadosRA1[9],lMarca)
								
				If !__lPccMR .And. !lTemImpPix .And. dDatabase >= dLastPcc .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
					If lRartImp .And. lCredito .And. FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
						aPcc := newMinPcc(dBaixa,SE1->E1_SALDO,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
					EndIf
				EndIf
			
				If lAutomato .And. TitNMarca(cAliasSE1)
					lMarca := .F.
				EndIf
	
				If F330RaRtIm(@aDadosRA1)
					If !lAutomato .Or. ( lAutomato .And. lMarca )					
						nValLim 	:= If(aDadosRA1[7][len(aDadosRA1[7])]>nVlBasico,nVlBasico,aDadosRA1[7][len(aDadosRA1[7])])
						nTotComp	-= nValComp
						If !(nTotComp + If(aDadosRA1[8][len(aDadosRA1[8])]>nVlBasico,nVlBasico,aDadosRA1[8][len(aDadosRA1[8])]) > nVlBasico) 
							nValComp 	:= If(aDadosRA1[8][len(aDadosRA1[8])]>nVlBasico,nVlBasico,aDadosRA1[8][len(aDadosRA1[8])])
						EndIf
						
						If mv_par08 == 2 .And. !lCredito .And. lRartImp
							nValComp:= Iif( SE1->E1_SALDO > nValLim, nValComp, SE1->E1_SALDO)
						EndIf 
						
						nTotComp	+= nValComp
					ElseIf lAutomato
						nTotComp	:= 0
					EndIf
				EndIf
								
				If dDatabase >= dLastPcc .And. ( lRartImp .Or. lRaRtImpMR ) .And. lCredito
					nLin := len(aDadosRA1[7])
					If aDadosRA1[7][nLin] < nVlBasico 
						If nValLim + nPis + nCofins + nCsll <> SE1->E1_SALDO ;	//somente deve descontar os impostos quando o valor estiver bruto
							.And. ( (nValLim + aDadosRA1[3][nLin] + aDadosRA1[4][nLin] + aDadosRA1[5][nLin] + aDadosRA1[6][nLin]) <> SE1->E1_SALDO ) 		// e quando impostos calculados pelo Cfg + Limite seja diferente do Saldo
							nValLim		:= nValLim - nPis - nCofins - nCsll
							nValComp	:= nValLim
						EndIf
					EndIf
				EndIf
				
				If nMoedaP <> nMoedaD
					nValLim	:= Iif(nSaldo>nVAlSld,nVAlSld,nSaldo) 					    
					nTotComp	-= nValComp
					nValComp 	:= nValLim
					nTotComp	+= nValComp
				EndIf
			Else				
				If __lPccMR
					nPis 	:= __nPisCaMR
					nCofins := __nCofCaMR
					nCsll 	:= __nCslCaMR
					
					If !lCredito .Or. ( lCredito .And. MV_PAR08 == 1 )
						If nSaldo > ( nVAlSld - Iif( lPccBxCr, ( nPis + nCofins + nCsll), 0) - nTotAbat - __nImpMR - nIrrf)
							nValLim := nVAlSld - Iif( lPccBxCr, ( nPis + nCofins + nCsll), 0) - nTotAbat - __nImpMR - nIrrf
						Else
							nValLim := nSaldo - Iif( lPccBxCr, ( nPis + nCofins + nCsll), 0) - nTotAbat - __nImpMR - nIrrf
						EndIf
					Else
						nValLim := SE1->E1_SALDO - nTotAbat
					EndIf
					If !lRaRtImpMR .And. lPccBxCr .And. (cAliasSE1)->E1_TIPO <> MVRECANT .And. nPis + nCofins + nCsll + nIrrf > 0 .And. SE1->E1_SALDO <> SE1->E1_VALOR
						nAbatRa := nTotAbat
						nSldNF := SE1->E1_SALDO
					EndIf
				Else				
					If ( !lRaRtImp .And. mv_par08 == 1 .And. lPccBxCr .And. SE1->E1_TIPO <> MVRECANT )
						If dDataBase < dLastPcc
							f070TotMes( dBaixa , .T. )
						EndIf
					EndIf
								
					If dDataBase < dLastPcc
			  			If !lRaRtImp .and. lPccBxCr .and. (cAliasSE1)->E1_TIPO <> MVRECANT .and. nPis+nCofins+nCsll+nIrrf > 0 .And. aDadosret[1] <= nVlMinImp 
			  				If nSldRa > SE1->E1_SALDO 
			  					nProp		:= (SE1->E1_SALDO) / SE1->E1_VALOR
			  				Else
			  					nProp		:= nSldRa/SE1->E1_VALOR
			  				EndIf
			  				If nProp <> 0
								nValPis		:= SE1->E1_PIS * nProp
								nValCofins	:= SE1->E1_COFINS * nProp
								nValCsll	:= SE1->E1_CSLL * nProp
								If (nSldRa >= SE1->E1_SALDO .and. aDadosRet[1]+SE1->E1_SALDO > nVlMinImp) .or. (nSldRa <= SE1->E1_SALDO .and. aDadosRet[1]+nSldRa > nVlMinImp)  
									nPis		:= aDadosRet[2] + nValPis 
									nCofins		:= aDadosRet[3] + nValCofins
									nCsll		:= aDadosRet[4] + nValCsll
								Else
									nPis		:= nValPis 
									nCofins		:= nValCofins
									nCsll		:= nValCsll
								EndIf
							EndIf 	
							nValLim 	:= Iif( nSaldo > (nVAlSld - nPis - nCofins - nCsll - nTotAbat), (nVAlSld - nPis - nCofins - nCsll - nTotAbat) , Iif (aDadosRet[1]+nSaldo <= nVlMinImp, nSaldo, (nSaldo - nPis - nCofins - nCsll - nTotAbat)) )
						ElseIf !lRaRtImp .and. lPccBxCr .and. (cAliasSE1)->E1_TIPO <> MVRECANT .and. nPis+nCofins+nCsll+nIrrf > 0 .AND. aDadosret[1] > nVlMinImp .and. SE1->E1_SALDO <> SE1->E1_VALOR
							nValPis		:= nPis
							nValCofins	:= nCofins
							nValCsll	:= nCsll
							nPis		:= (nValPis * (SE1->E1_SALDO/ SE1->E1_VALOR))
							nCofins		:= (nValCofins * (SE1->E1_SALDO/ SE1->E1_VALOR))
							nCsll		:= (nValCsll * (SE1->E1_SALDO/ SE1->E1_VALOR))	
							nValLim 	:= Iif( nSaldo > (nVAlSld -nPis - nCofins - nCsll-nTotAbat) , (nVAlSld - nPis - nCofins - nCsll - nTotAbat) , (nSaldo - nPis - nCofins - nCsll - nTotAbat) )
							nAbatRa		:= nTotAbat
							nSldNF		:= SE1->E1_SALDO
						ElseIf !lRaRtImp .or. (lRaRtImp .and. (cAliasSE1)->(E1_PIS + E1_CSLL + E1_COFINS) == 0)
							If nValComp > 0 .and. (nSaldo <> nValComp)
								nPis	:= aDadosRet[2] + ((nValComp * nValPis)/nValorNf) 
								nCofins	:= aDadosRet[3] + ((nValComp * nValCofins)/nValorNf)
								nCsll	:= aDadosRet[4] + ((nValComp * nValCsll)/nValorNf)
			  					nValLim := Iif(!lRartImp,Max(nVAlSld , nValComp),Iif( nValComp > nVAlSld , nVAlSld , nValComp ))
			  				Else
			  					If nValPis > 0 .AND. aDadosret[1] <= nVlMinImp .and. aDadosRet[1]+nValComp <= nVlMinImp
			  						nPis	:= nValPis
			  						nCofins	:= nValCofins
			  						nCsll	:= nValCsll
			  					EndIf
			  					If lCredito
			  						nAbatNf	:= nTotAbat
			  					EndIf
			  					nValLim := Iif( nSaldo > nVAlSld , nVAlSld , nSaldo )
			  				EndIf
			  			EndIf
			  		Else
		  				If lCredito .and. mv_par08 == 2 .and. !lRartImp .and. nValSld+nPis+nCofins+nCsll <= SE1->E1_SALDO
		  					nValSld	+= nPis+nCofins+nCsll
		  				EndIf
		  				
						nValRec2 := Iif(nValRec < SE1->E1_SALDO,nValRec,SE1->E1_SALDO)
		  				
						If !(!lCredito .and. !lRartImp)
							If !lTemImpPix .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG) 
								nValRecOld := nValRec2
								nValRec2   := IIf(nBaseImpos > 0, nBaseImpos, nValRec2)
								
								If FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
									aPcc		:= newMinPcc(dBaixa,nValRec2,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
									nPis		:= aPcc[2]
									nCofins		:= aPcc[3]
									nCsll		:= aPcc[4]
								EndIf
								
								nValRec2 := nValRecOld
							EndIf									
							
							If !lIrPjBxCr
								nIrrf	:= SE1->E1_IRRF
							ElseIf !__lIrfMR
								aArea := SE1->(GetArea())
								
								If !( SE1->E1_TIPO $ MVRECANT )
									SE1->(DbGoTo(nRecno))
								EndIf
								
								If !lTemImpPix .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
									nIrrf := FCaIrBxCR(IIf(nBaseImpos > 0, nBaseImpos, nValRec2))
								EndIf
								
								RestArea(aArea)
							EndIf
		  				EndIf
		  				nValLim := Iif(nSaldo>nVAlSld,nVAlSld,nSaldo)
			  		EndIf
					
					If lMarca
		  				nValLim -= __nImpMR 	//Retira o valor calculado pelo configurador de tributos do valor limite para compensação	
					EndIf
		  			
					If SE1->E1_TIPO <> MVRECANT .And. nValLim > nSldConv - nTotAbtCon .And. MV_PAR08 == 1
					    // Só faz a subtração do nValLim se o mesmo não ficar negativo
						If nValLim - nTotAbtCon >= 0
							nValLim -= nTotAbtCon
							If ( nSldConv - nTotAbtCon - iif(lPccBxCr,nPis + nCofins + nCsll, 0 ) ) > nValLim
								nValLim := ( nSldConv - nTotAbtCon )
							EndIf
						// Se não subtrair o valor em nTotBat, verifica se o saldo atual do titulo esta inferior ao nValLim
						ElseIf ( nSldConv - nTotAbtCon ) < nValLim
							nValLim := ( nSldConv - nTotAbtCon )
						EndIf

						If nValComp > nValLim .And. SE1->E1_SDACRES > 0
							nValLim	+= SE1->E1_SDACRES
							If nValLim > nValComp
								nValLim := nValComp
							EndIf
						EndIf

						If !lRaRtImp
							If !aPcc[1]
								If ValType( aDadosRet ) == "A" 
									aDadRetAux := aClone( aDadosRet )
								EndIf
	
								If dDataBase < dLastPcc
									f070TotMes( dBaixa , .T. )
								EndIf
								//Retorna os valores originais
								aDadosRet  := aClone( aDadRetAux )
			
								nPis       := aImpPccIr[1]
								nCofins    := aImpPccIr[2]
								nCsll      := aImpPccIr[3]
								nIrrf      := aImpPccIr[4]
													
								aDadRetAux := {}
							EndIf
	
						EndIf
					
					EndIf
			
				EndIf

			EndIf

			//Verifica se o titulo já possui impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
			nPisFin061	:=	0
			nCofFin061	:=	0
			nCslFin061	:=	0
			nIrfFin061	:=	0
			nRegSE5		:=	SE5->(Recno())
			nOrdSE5		:=	SE5->(IndexOrd())		
			If lPccBxCr .Or. lIrPjBxCr                                                                                               			
				dbSelectArea("SE5")
				SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
				If SE5->(DBSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
					While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
						SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
				
						If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
							If Alltrim(SE5->E5_MOTBX) == "PCC"
							   nPisFin061	+= SE5->E5_VRETPIS
							   nCofFin061	+= SE5->E5_VRETCOF
							   nCslFin061	+= SE5->E5_VRETCSL
							ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
							   nIrfFin061	+= SE5->E5_VRETIRF
							EndIf
						EndIf				
						SE5->(DbSkip())		
			   		EndDo
				EndIf
			EndIf
	   		SE5->(Dbgoto(nRegSE5))
			SE5->(Dbsetorder(nOrdSE5))													                  

			If ( nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061 ) > 0
				//Caso o titulo possua bordero de recebimento de imposto gerado na rotina FINA061 devo recompor base no caso de não abater os impostos
				//ou  abater os impostos e tiver compensando de RA para NF. Senão devo zerar as variaveis para não afetar o processamento. 
			  	If  mv_par08 == 1 
					nPisFin061	:=	0
					nCofFin061	:=	0
					nCslFin061	:=	0
					nIrfFin061	:=	0
				EndIf		
			EndIf					
			lNcc2 := (cAliasSE1)->E1_TIPO $ MV_CRNEG

			If ( lRaRtImp .Or. lRaRtImpMR ) .And. !lNcc .And. lCredito
				nSaldoNF := (cAliasSE1)->E1_SALDO
				If lPccBxCr
					nSaldoNF -= If(SE1->E1_MOEDA > 1, Round(xMoeda(aDadosRA1[3][Len(aDadosRA1[3])], nMoeda, SE1->E1_MOEDA, dDtMov, __nCasDec, Fa330Tx2(nMoedaD,nTaxaD), Fa330Tx2(nMoedaP,nTaxaP)), nDecs), aDadosRA1[3][Len(aDadosRA1[3])])
					nSaldoNF -= If(SE1->E1_MOEDA > 1, Round(xMoeda(aDadosRA1[4][Len(aDadosRA1[4])], nMoeda, SE1->E1_MOEDA, dDtMov, __nCasDec, Fa330Tx2(nMoedaD,nTaxaD), Fa330Tx2(nMoedaP,nTaxaP)), nDecs), aDadosRA1[4][Len(aDadosRA1[4])])
					nSaldoNF -= If(SE1->E1_MOEDA > 1, Round(xMoeda(aDadosRA1[5][Len(aDadosRA1[5])], nMoeda, SE1->E1_MOEDA, dDtMov, __nCasDec, Fa330Tx2(nMoedaD,nTaxaD), Fa330Tx2(nMoedaP,nTaxaP)), nDecs), aDadosRA1[5][Len(aDadosRA1[5])])
				EndIf
				If lIRPJBxCr
					nSaldoNF -= If(SE1->E1_MOEDA > 1, Round(xMoeda(aDadosRA1[6][Len(aDadosRA1[6])], nMoeda, SE1->E1_MOEDA, dDtMov, __nCasDec, Fa330Tx2(nMoedaD,nTaxaD), Fa330Tx2(nMoedaP,nTaxaP)), nDecs), aDadosRA1[6][Len(aDadosRA1[6])])
				EndIf
			Else
				nSaldoNF := (cAliasSE1)->E1_SALDO
			EndIf

			If cPaisLoc != "EUA" .And. nValComp <> nValRec .And. !lRaRtImp
				nValRec	:= nValComp
			EndIf
	        
			If MV_PAR02 == 2 // Considera Cliente == Não
				DBSelectArea("SA1")
				nIndexSA1 := IndexOrd()
				nPosSA1   := Recno()
				DBSetOrder(1)
				DBSeek(xFilial()+(cAliasSE1)->E1_CLIENTE+(cAliasSE1)->E1_LOJA)
				dbSelectArea(cAliasSE1)				
				nDesFin := getDesc(nValComp)
				
				If __lMotRet
				    nlimite:= Iif (nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061 > nValorPcc, nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061, nValorPcc)

					AADD(aTitulos,{;
					(cAliasSE1)->E1_PREFIXO,;
					(cAliasSE1)->E1_NUM,;
					(cAliasSE1)->E1_PARCELA,;
					(cAliasSE1)->E1_TIPO,;
					(cAliasSE1)->E1_LOJA,;
					Transform(xMoeda((nSaldoNF+ nPisFin061+nCofFin061+nCslFin061+nIrfFin061)+(cAliasSE1)->E1_SDACRES-Iif(nProp>0,(nImp*nProp),0)-(cAliasSE1)->E1_SDDECRE- Iif(  Type("nTotAbat") <> "N" .OR. MV_PAR08== 2 ,0,nTotAbat) - nDesFin + nValVa,(cAliasSE1)->E1_MOEDA,nMoeda,,5,Fa330Tx2(nMoedaP,nTaxaP),Fa330Tx2(nMoedaD,nTaxaD)),"@E 9999,999,999.99"),; //06
					Transform(nlimite + nPisFin061+nCofFin061+nCslFin061+nIrfFin061, "@E 9999,999,999.99"),; //07
					lMarca,;
					nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,; //09
					(cAliasSE1)->(E1_CLIENTE)+"-"+(cAliasSE1)->(E1_LOJA),;
					(cAliasSE1)->E1_NOMCLI,;
					Transform(SA1->A1_CGC,Substr(PicPes(SA1->A1_PESSOA),1,at("%",PicPes(SA1->A1_PESSOA))-1)),;
					Transform((cAliasSE1)->E1_SDACRES,"@E 9999,999,999.99"),;
					Transform((cAliasSE1)->E1_SDDECRE,"@E 9999,999,999.99"),;
					(cAliasSE1)->E1_HIST,;
					(cAliasSE1)->E1_FILIAL,;
					Transform(nValorPcc,"@E 9999,999,999.99"),;
					Transform(nValorPcc,"@E 9999,999,999.99"),;
					Transform(nValorPcc,"@E 9999,999,999.99"),;
					Transform(nValorPcc,"@E 9999,999,999.99"),;
					Transform(nValorPcc,"@E 9999,999,999.99"),;
					Transform(nValorPcc,"@E 9999,999,999.99"),;
					(cAliasSE1)->RECSE1,;
					(cAliasSE1)->E1_SALDO + nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061,; 
					Transform(nValLim,"@E 9999,999,999.99"),;
					(cAliasSE1)->E1_VALOR,; //26
					Transform(nValorPcc,"@E 9999,999,999.99"),;//27 base calculo PCC
					Transform(nValorPcc,"@E 9999,999,999.99"),;//28 Base Retenção PCC
					Transform(nValorPcc,"@E 9999,999,999.99"),;//29 Base de calculo e retenção do IRF
					Transform(nValorPcc,"@E 9999,999,999.99"),; //30 Motor
					Transform(nValVa,"@E 9999,999,999.99"),;	//31 Valor acessório	
					nTaxaMov}) //32 Taxa do título
					
					
				Else
					AADD(aTitulos,{;
						(cAliasSE1)->E1_PREFIXO,;
						(cAliasSE1)->E1_NUM,;
						(cAliasSE1)->E1_PARCELA,;
						(cAliasSE1)->E1_TIPO,;
						(cAliasSE1)->E1_LOJA,;
						Transform(xMoeda((nSaldoNF+ nPisFin061+nCofFin061+nCslFin061+nIrfFin061)+(cAliasSE1)->E1_SDACRES-Iif(nProp>0,(nImp*nProp),0)-(cAliasSE1)->E1_SDDECRE- Iif(  Type("nTotAbat") <> "N" .OR. MV_PAR08== 2 ,0,nTotAbat) - nDesFin + nValVa,(cAliasSE1)->E1_MOEDA,nMoeda,,5,Fa330Tx2(nMoedaP,nTaxaP),Fa330Tx2(nMoedaD,nTaxaD)),"@E 9999,999,999.99"),; //06
						Transform(nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061, "@E 9999,999,999.99"),; //07
						lMarca,;
						nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,; //09
						(cAliasSE1)->(E1_CLIENTE)+"-"+(cAliasSE1)->(E1_LOJA),;
						(cAliasSE1)->E1_NOMCLI,;
						Transform(SA1->A1_CGC,Substr(PicPes(SA1->A1_PESSOA),1,at("%",PicPes(SA1->A1_PESSOA))-1)),;
						Transform((cAliasSE1)->E1_SDACRES,"@E 9999,999,999.99"),;
						Transform((cAliasSE1)->E1_SDDECRE,"@E 9999,999,999.99"),;
						(cAliasSE1)->E1_HIST,;
						(cAliasSE1)->E1_FILIAL,;
						Transform(nValorPcc,"@E 9999,999,999.99"),;
						Transform(nValorPcc,"@E 9999,999,999.99"),;
						Transform(nValorPcc,"@E 9999,999,999.99"),;
						Transform(nValorPcc,"@E 9999,999,999.99"),;
						Transform(nValorPcc,"@E 9999,999,999.99"),;
						Transform(nValorPcc,"@E 9999,999,999.99"),;
						(cAliasSE1)->RECSE1,;
						(cAliasSE1)->E1_SALDO + nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061,; 
						Transform(nValLim,"@E 9999,999,999.99"),;
						(cAliasSE1)->E1_VALOR,; //26
						Transform(nValorPcc,"@E 9999,999,999.99"),;//27 base calculo PCC
						Transform(nValorPcc,"@E 9999,999,999.99"),;//28 Base Retenção PCC
						Transform(nValorPcc,"@E 9999,999,999.99"),;//29 Base de calculo e retenção do IRF
						Transform(nValVa,"@E 9999,999,999.99"),;//30 Valor acessório	
						nTaxaMov}) //31 Taxa do título
					
				EndIf

				nLin := Len(aTitulos)
				If lCredito .And. lRaRtImpMR .And. nLin > Len(aDadosRA1[2])
					nLin := Len(aDadosRA1[2])
				EndIf
				nPosxRet := 30
				nReg330 := 23 // Posição 23 do aTitulos				 
				
				If ( lRaRtImp .Or. lRaRtImpMR ) .And. ( lPccBxCr .Or. lIRPJBxCr ) .And. !lNcc
					lRetMinAux := ( ( !__lPccMR .And. (aDadosRet[1] > nVlMinImp) .OR. ((cAliasSE1)->E1_PIS > 0 .OR. (cAliasSE1)->E1_COFINS  > 0 .OR. (cAliasSE1)->E1_CSLL > 0 .OR. (cAliasSE1)->E1_IRRF > 0) ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) )
					
					If lRetMinAux
						aTitulos[nLin][nPosPis]:= Transform(aDadosRA1[3][nLin]   ,X3Picture("E1_PIS"))
						aTitulos[nLin][nPosCof]:= Transform(aDadosRA1[4][nLin]   ,X3Picture("E1_COFINS"))
						aTitulos[nLin][nPosCsl]:= Transform(aDadosRA1[5][nLin]   ,X3Picture("E1_CSLL"))
						aTitulos[nLin][nPosIrf]:= Transform(aDadosRA1[6][nLin]   ,X3Picture("E1_IRRF"))
						If __lMotRet .And. !Empty(aDadosRA1[12])
							aTitulos[nLin][nPosxRet]:= Transform(aDadosRA1[12][nLin]   ,X3Picture("E1_IRRF"))
						EndIf
					EndIf
					
					aTitulos[nLin][nPosBPCC]:= Transform(aDadosRA1[7][nLin]   ,X3Picture("E1_VALOR"))
					aTitulos[nLin][nPosBPCR]:= Transform(aDadosRA1[8][nLin]   ,X3Picture("E1_VALOR"))

					If Type("oTitulo") == "O"
						oTitulo:aArray:=aTitulos
  						oTitulo:Refresh()
					Endif
				Endif

				SA1->(DBSetOrder(nIndexSA1))
				SA1->(DBGoto(nPosSA1))
				
			Else	// MV_PAR02 <> 2 // Considera Cliente == Sim
				nPosxRet	:= 27

				If __lMotRet
					nlimite:= Iif (nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061 > nValLim  + nPisFin061+nCofFin061+nCslFin061+nIrfFin061, nValLim  + nPisFin061+nCofFin061+nCslFin061+nIrfFin061, nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061)

			    	aAdd(aTitulos,{(cAliasSE1)->E1_PREFIXO,;		//01
					(cAliasSE1)->E1_NUM,;						//02
					(cAliasSE1)->E1_PARCELA,;					//03
					(cAliasSE1)->E1_TIPO,;						//04
					(cAliasSE1)->E1_LOJA,;						//05
					Transform(xMoeda(nSaldoNF+(cAliasSE1)->E1_SDACRES-Iif(nProp>0,(nImp*nProp),0)-(cAliasSE1)->E1_SDDECRE- Iif(  Type("nTotAbat") <> "N" .OR. MV_PAR08== 2,0,nTotAbat) - nDesFin + nValVa,(cAliasSE1)->E1_MOEDA,nMoeda,,5,Fa330Tx2(nMoedaP,nTaxaP),Fa330Tx2(nMoedaD,nTaxaD)),"@E 9999,999,999.99"),; //06
					Transform(nlimite,"@E 9999,999,999.99"),;//07
					lMarca,;										//08
					nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,;										//09
					Transform((cAliasSE1)->E1_SDACRES,"@E 9999,999,999.99"),;
					Transform((cAliasSE1)->E1_SDDECRE,"@E 9999,999,999.99"),;
					(cAliasSE1)->E1_HIST,;						//12
					(cAliasSE1)->E1_FILIAL,;						//13
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Pis 		//14	
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Cofins	 	//15
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Csll		//16
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Irrf		//17	
					Transform(nValorPcc,"@E 9999,999,999.99"),;								//18
					Transform(nValorPcc,"@E 9999,999,999.99"),;								//19
					(cAliasSE1)->RECSE1,;													//20
					(cAliasSE1)->E1_SALDO + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,;														//21
					Transform(nValLim  + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,"@E 9999,999,999.99"),;//Limite de Compensacao  //22
					(cAliasSE1)->E1_VALOR,;//23
					Transform(nValorPcc,"@E 9999,999,999.99"),;//24 base calculo PCC
					Transform(nValorPcc,"@E 9999,999,999.99"),;//25 Base Retenção PCC
					Transform(nValorPcc,"@E 9999,999,999.99"),;//26 Base de calculo e retenção do IRF
					Transform(nValorPcc,"@E 9999,999,999.99"),; //27 PCC Baixa CR - Irrf		//18
					Transform(nValVa,"@E 9999,999,999.99"),;//28 Valor acessório	
					nTaxaMov}) //29 Taxa do título
					
				Else
				
				aAdd(aTitulos,{(cAliasSE1)->E1_PREFIXO,;		//01
					(cAliasSE1)->E1_NUM,;						//02
					(cAliasSE1)->E1_PARCELA,;					//03
					(cAliasSE1)->E1_TIPO,;						//04
					(cAliasSE1)->E1_LOJA,;						//05
					Transform(xMoeda(nSaldoNF+(cAliasSE1)->E1_SDACRES-Iif(nProp>0,(nImp*nProp),0)-(cAliasSE1)->E1_SDDECRE- Iif(  Type("nTotAbat") <> "N" .OR. MV_PAR08== 2,0,nTotAbat) - nDesFin + nValVa,(cAliasSE1)->E1_MOEDA,nMoeda,,5,Fa330Tx2(nMoedaP,nTaxaP),Fa330Tx2(nMoedaD,nTaxaD)),"@E 9999,999,999.99"),; //06
					Transform(nValComp,"@E 9999,999,999.99"),;//07
					lMarca,;										//08
					nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,;										//09		
					Transform((cAliasSE1)->E1_SDACRES,"@E 9999,999,999.99"),;
					Transform((cAliasSE1)->E1_SDDECRE,"@E 9999,999,999.99"),;
					(cAliasSE1)->E1_HIST,;						//12
					(cAliasSE1)->E1_FILIAL,;						//13
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Pis 		//14	
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Cofins	 	//15
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Csll		//16
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Irrf		//17	
					Transform(nValorPcc,"@E 9999,999,999.99"),;								//18
					Transform(nValorPcc,"@E 9999,999,999.99"),;								//19
					(cAliasSE1)->RECSE1,;													//20
					(cAliasSE1)->E1_SALDO + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,;														//21
					Transform(nValLim  + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,"@E 9999,999,999.99"),;//Limite de Compensacao  //22
					(cAliasSE1)->E1_VALOR,;//23
					Transform(nValorPcc,"@E 9999,999,999.99"),;//24 base calculo PCC
					Transform(nValorPcc,"@E 9999,999,999.99"),;//25 Base Retenção PCC
					Transform(nValorPcc,"@E 9999,999,999.99"),;//26 Base de calculo e retenção do IRF
					Transform(nValVa,"@E 9999,999,999.99"),; //27 Valor acessório
					nTaxaMov})//28 Taxa do título
				EndIf

				nlin := Len(aTitulos)
				If lCredito .And. lRaRtImpMR .And. nLin > Len(aDadosRA1[2])
					nLin := Len(aDadosRA1[2])
				EndIf

				nReg330 := 20 // Posição 20 do aTitulos				
				
				If ( lRaRtImp .Or. lRaRtImpMR ) .And. (lPccBxCr .Or. lIRPJBxCr) .And. !lNcc .And. ((cAliasSE1)->E1_PIS > 0 .OR. (cAliasSE1)->E1_COFINS  > 0 .OR. (cAliasSE1)->E1_CSLL > 0 .OR. (cAliasSE1)->E1_IRRF > 0)
					aTitulos[nLin][nPosPis]:= Transform(aDadosRA1[3][nLin]   ,X3Picture("E1_PIS"))
					aTitulos[nLin][nPosCof]:= Transform(aDadosRA1[4][nLin]   ,X3Picture("E1_COFINS"))
					aTitulos[nLin][nPosCsl]:= Transform(aDadosRA1[5][nLin]   ,X3Picture("E1_CSLL"))
					aTitulos[nLin][nPosIrf]:= Transform(aDadosRA1[6][nLin]   ,X3Picture("E1_IRRF"))
					If __lMotRet .And. !Empty(aDadosRA1[12])
						aTitulos[nLin][nPosxRet]:= Transform(aDadosRA1[12][nLin]   ,X3Picture("E1_IRRF"))
					EndIf
					aTitulos[nLin][6] := Transform(xMoeda(aDadosRA1[7][nLin],(cAliasSE1)->E1_MOEDA,nMoeda,,5,Fa330Tx2(nMoedaP,nTaxaP),Fa330Tx2(nMoedaD,nTaxaD)),"@E 9999,999,999.99")
				EndIf
			EndIf
			
			If __lMotRet .and. lMarca
				aTitulos[nLin][nPosxRet]:= Transform(__nImpMR   ,X3Picture("E1_IRRF"))
			EndIf
					
			If lFI330ALT
				aTitulos:=ExecBlock("FI330ALT",.F.,.F.,{aTitulos})
			EndIF
		Else
	      	//Quando considerar o cliente original do titulo selecionado, mostra o cgc e o nome dos clientes refrentes a cada titulo (MV_PAR02==2)
	      	If MV_PAR02 == 2
	      		DBSelectArea("SA1")
	      		nIndexSA1 := IndexOrd()
	      		nPosSA1   := Recno()
	      		DBSetOrder(1)
	      		DBSeek(xFilial()+(cAliasSE1)->E1_CLIENTE+(cAliasSE1)->E1_LOJA)
	      		cCgcClie := SA1->A1_CGC
	      		cNomClie := SA1->A1_NOME

	      		DBSetOrder(nIndexSA1)
	      		DBGoto(nPosSA1)
	     	   
	      		DBSelectArea(cAliasSE1)
	      		
				If nValLim==0
					If (cAliasSE1)->E1_SALDO>=nSaldo
						nValLim:= nSaldo
						If cPaisLoc != "RUS"
							nValComp:= If(lMarca,nSaldo,nValComp)
						Else
							nValComp:= If(lMarca,nValComp,nSaldo)
						EndIf
					Else
						nValLim:= (cAliasSE1)->E1_SALDO
						nValComp:= If(lMarca,nValComp,(cAliasSE1)->E1_SALDO)
					Endif
				Endif
				
				If cPaisLoc != "RUS"		
					aAdd(aTitulos,{(cAliasSE1)->E1_PREFIXO,;
										(cAliasSE1)->E1_NUM,;
										(cAliasSE1)->E1_PARCELA,;
										(cAliasSE1)->E1_TIPO,;
										(cAliasSE1)->E1_LOJA,;
										Transform(Round(xMoeda((cAliasSE1)->E1_SALDO+(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,(cAliasSE1)->E1_EMISSAO,nDecs+1,aTxMoedas[(cAliasSE1)->E1_MOEDA][2],aTxMoedas[nMoeda][2]),nDecs),__cPiE1Sld),;
										Transform(nValComp,__cPiE1Sld),;
										lMarca,;
										(cAliasSE1)->E1_MOEDA,;
										(cAliasSE1)->E1_EMISSAO,;
										cNomClie,;
										Transform(cCgcClie,PesqPict("SA1","A1_CGC")),;
										Transform(xMoeda((cAliasSE1)->E1_SDACRES,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
										Transform(xMoeda((cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
										(cAliasSE1)->E1_HIST,;
										(cAliasSE1)->E1_FILIAL,;
										Transform(xMoeda(nValLim,nMoeda,nMoeda,,5,Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA),Fa330Tx2(nMoeda, nTxMoeda)),"@E 9999,999,999.99")})//Limite de Compensacao
				Else
						aAdd(aTitulos,{(cAliasSE1)->E1_PREFIXO,;
							(cAliasSE1)->E1_NUM,;
							(cAliasSE1)->E1_PARCELA,;
							(cAliasSE1)->E1_TIPO,;
							(cAliasSE1)->E1_LOJA,;
							Transform(Round(xMoeda((cAliasSE1)->E1_SALDO+(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,(cAliasSE1)->E1_EMISSAO,nDecs+1,aTxMoedas[(cAliasSE1)->E1_MOEDA][2],aTxMoedas[nMoeda][2]),nDecs),PesqPict("SE1","E1_SALDO")),;
							Transform(nValComp,PesqPict("SE1","E1_SALDO")),;
							lMarca,;
							(cAliasSE1)->E1_MOEDA,;
							(cAliasSE1)->E1_EMISSAO,;
							cNomClie,;
							Transform(cCgcClie,PesqPict("SA1","A1_CGC")),;
							Transform(xMoeda((cAliasSE1)->E1_SDACRES,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
							Transform(xMoeda((cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
								(cAliasSE1)->E1_HIST,;
							(cAliasSE1)->E1_FILIAL,;
							Transform(xMoeda(nValLim,nMoeda,nMoeda,,5,Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA),Fa330Tx2(nMoeda, nTxMoeda)),"@E 9999,999,999.99"),;//Limite de Compensacao
							(cAliasSE1)->E1_CLIENTE,;
							(cAliasSE1)->E1_F5QCODE,;
							(cAliasSE1)->E1_VALOR,;
							(cAliasSE1)->E1_VLCRUZ,;
							(cAliasSE1)->E1_CONUNI,;
							AllTrim(Posicione("CTO",1,xFilial("CTO") + StrZero((cAliasSE1)->E1_MOEDA, GetSX3Cache("CTO_MOEDA", "X3_TAMANHO")), "CTO_SIMB"))})
				EndIf			
	       Else
	       
	       		// Moeda de Partida
				nMoedaP := (cAliasSE1)->E1_MOEDA
				// Moeda de Destino
				nMoedaD := nMoeda
				
   				If nValLim == 0
					If (cAliasSE1)->E1_SALDO>=nSaldo
						nValLim:= nSaldo
						nValComp:= If(lMarca,nValComp,nSaldo)

					Else
						nValLim:= (cAliasSE1)->E1_SALDO
						nValComp:= If(lMarca,nValComp,(cAliasSE1)->E1_SALDO)

					Endif
				Endif

				nVAlSld := (cAliasSE1)->(E1_SALDO+E1_SDACRES-E1_SDDECRE) - nDesFin  
				
				If cPaisLoc != "RUS"
					aAdd(aTitulos,{(cAliasSE1)->E1_PREFIXO,;
								(cAliasSE1)->E1_NUM,;
								(cAliasSE1)->E1_PARCELA,;
								(cAliasSE1)->E1_TIPO,;
								(cAliasSE1)->E1_LOJA,;
								Transform(Round(xMoeda((cAliasSE1)->E1_SALDO,(cAliasSE1)->E1_MOEDA,nMoeda,(cAliasSE1)->E1_EMISSAO,nDecs+1,aTxMoedas[(cAliasSE1)->E1_MOEDA][2],aTxMoedas[nMoeda][2]),nDecs),__cPiE1Sld),;
								Transform(nValComp,__cPiE1Sld),;
								lMarca,;
								(cAliasSE1)->E1_MOEDA,;
								(cAliasSE1)->E1_EMISSAO,;
								Transform(xMoeda((cAliasSE1)->E1_SDACRES,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
								Transform(xMoeda((cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
								(cAliasSE1)->E1_FILIAL,;
								Transform(xMoeda(nValLim,nMoeda,nMoeda,,5,Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA),Fa330Tx2(nMoeda, nTxMoeda)),"@E 9999,999,999.99")})//Limite de Compensacao
				Else
					aAdd(aTitulos,{(cAliasSE1)->E1_PREFIXO,;
									(cAliasSE1)->E1_NUM,;
									(cAliasSE1)->E1_PARCELA,;
									(cAliasSE1)->E1_TIPO,;
									(cAliasSE1)->E1_LOJA,;
									Transform(Round(xMoeda((cAliasSE1)->E1_SALDO,(cAliasSE1)->E1_MOEDA,nMoeda,(cAliasSE1)->E1_EMISSAO,nDecs+1,aTxMoedas[(cAliasSE1)->E1_MOEDA][2],aTxMoedas[nMoeda][2]),nDecs),__cPiE1Sld),;
									Transform(nValComp,__cPiE1Sld),;
									lMarca,;
									(cAliasSE1)->E1_MOEDA,;
									(cAliasSE1)->E1_EMISSAO,;
								Transform(xMoeda((cAliasSE1)->E1_SDACRES,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
								Transform(xMoeda((cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
										(cAliasSE1)->E1_FILIAL,;
									Transform(xMoeda(nValLim,nMoeda,nMoeda,,5,Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA),Fa330Tx2(nMoeda, nTxMoeda)),"@E 9999,999,999.99"),; //Limite de Compensacao
								(cAliasSE1)->E1_CLIENTE,;
								(cAliasSE1)->E1_F5QCODE,;
								(cAliasSE1)->E1_VALOR,;
								(cAliasSE1)->E1_VLCRUZ,;
								(cAliasSE1)->E1_CONUNI,;
								AllTrim(Posicione("CTO",1,xFilial("CTO") + StrZero((cAliasSE1)->E1_MOEDA, GetSX3Cache("CTO_MOEDA", "X3_TAMANHO")), "CTO_SIMB"))})
				EndIf

			EndIf

		EndIf
		
		AAdd(aRecNo, (cAliasSE1)->RECSE1)
		
		If lFa330Qry
			aAreaSED	:= SED->(GetArea())
			DbSelectArea("SED")
			DbSetOrder(1)
			DbSeek(xFilial("SED", SE1->E1_FILORIG) + SE1->E1_NATUREZ)
			If !lNcc2 .And. ( ( lCredito .And. ( SED->ED_CALCPIS == 'S' .Or. SED->ED_CALCCOF == 'S' ;
				.Or. SED->ED_CALCCSL == 'S' ) ) .Or. ( !lCredito .And. FNatPCC((cAliasSE1)->E1_FILORIG, SE1->E1_NATUREZ) ) )
				If ( aScan(__aNatPCC, { |x| x[1] = (cAliasSE1)->E1_FILORIG + SE1->E1_NATUREZ } )) == 0
					aAdd(__aNatPCC, {(cAliasSE1)->E1_FILORIG + SE1->E1_NATUREZ})
				EndIf
			EndIf
			RestArea(aAreaSED)
		ElseIf !lNcc2 .And. ( ( lCredito .And. ( (cAliasSE1)->ED_CALCPIS == 'S' .Or. (cAliasSE1)->ED_CALCCOF == 'S' ;
			.Or. (cAliasSE1)->ED_CALCCSL == 'S' ) ) .Or. ( !lCredito .And. FNatPCC((cAliasSE1)->E1_FILORIG, (cAliasSE1)->E1_NATUREZ) ) )
			If ( aScan(__aNatPCC, { |x| x[1] = (cAliasSE1)->E1_FILORIG + (cAliasSE1)->E1_NATUREZ } )) == 0
				aAdd(__aNatPCC, {(cAliasSE1)->E1_FILORIG + (cAliasSE1)->E1_NATUREZ})
			EndIf
		EndIf
		
		(cAliasSE1)->(dbSkip())
	EndDo
	
	Exit
EndDo

__oHNatPCC := AtoHM(__aNatPCC, 1)

If __lMotRet
	FMRGetArr(,.T.) // Destrói o Model do MR
EndIf
If __l330Va
	oModelVa:Destroy()
	oModelVa := NIL
EndIf

If !Empty(nTitSemTx) .And. !IsBlind()
	MsgAlert(STR(nTitSemTx,4) + STR0127, 'NOTXTITD') // título(s) com problema de taxa cambial. Não serão listados títulos sem taxa!
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Recupera a Integridade dos dados	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SM0")
dbGoto(nRecEmp)
cFilAnt := IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza valor total dos t¡tulos - Windows	 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nValTot := 0
For nX := 1 to Len(aTitulos)
	If aTitulos[nX,8]
		nValtot += Fa330VTit(aTitulos[nX,7])
	Endif
Next

/* GESTAO - inicio */
If !Empty(aTmpSE1Fil)
	For nX := 1 TO Len(aTmpSE1Fil)
		CtbTmpErase(aTmpSE1Fil[nX])
    Next
Endif
/* GESTAO - fim */
dbSelectArea(cAliasSE1)
dbCloseArea()
dbSelectArea("SE1")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Recupera a Integridade dos dados	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea(cSavArea)
dbSetOrder(nSavOrd)
dbGoto(nRecNo)
RestVarMR( aImpMRBrw )

Return( aTitulos )
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³Fa330VTit ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 22/09/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna o saldo ou valor do titulo a ser compensado		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fina330													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa330VTit(aTitulo,cTipoTit,cValor)
LOCAL nValor
cValor := IIF (cValor == NIL,aTitulo,cValor)
If ValType(cValor)=="N"
	nValor := cValor
Else
	nValor := DesTrans(cValor)
EndIf
Return nValor

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ FA330Desc³ Autor ³ Wagner Xavier 		³ Data ³ 01/09/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Cancelar a Compensa‡„o de Adiantamentos.					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FA330Desc() 												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA330													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FA330Desc( cAlias, nReg, nOpc )
Local lPanelFin 	:= IsPanelFin()
Local nOpcA 		:= 0         		// Indica se a Compesa‡ao sera efetuada
Local dBaixa		:= SE1->E1_BAIXA	// Data da Baixa
Local lCancelou 	:= .F.				// Indica se foi realmente cancelado
Local aRegistros 	:= {}             // Guarda os registros do SE5 a serem cancelados
Local cDocumento  	:= ""             // Guarda o RA/NCC que efetuou a Bx.
local cArquivo    	:= ""             // Utilizado na Contabilizacao
local nTotal		:= 0               // Utilizado na Contabilizacao
local nHdlPrv		:= 0               // Utilizado na Contabilizacao
local cPadrao		:= "588"           // Utilizado na Contabilizacao
local lPadrao		:= .F.					// Utilizado na Contabilizacao
Local lFirst		:= .F.					// Utilizado na Contabilizacao
Local cLojaCmp		:= ""             // Util. para Comp. de Lojas diferentes
local nOrdSE1		:= SE1->(IndexOrd())
Local nOrdFilter    := SE1->(IndexOrd())
local nRegSE1     	:= 0              // Guarda o Registro do SE1
local nRegSE5     	:= 0              // Guarda o Registro do SE5
Local lMarcado		:= .F.             // Indica se o item foi marcado
Local nMoeda      	:= 0              // Moeda do Titulo Principal (SE1)
Local cAdiantamento						// Guarda o RA/NCC que efetuou a Bx.
Local nVlrAbat    	:= 0
Local aBaixas     	:= {}             // Guarda as baixas do SE5 para cancelar comissao
Local oDlg
Local oOk		  	:= LoadBitmap( GetResources(), "LBOK" )
Local oNo		  	:= LoadBitmap( GetResources(), "LBNO" )
Local oTitulo
Local nDecs       	:= 2
Local nTxMoeda    	:= 0
Local nDecs1      	:= MsDecimais(1)
Local aDoctosSE5  	:= {}
Local nSaldoComp  	:= 0
Local aArea		  	:= {}
Local cChaveSE1
Local nValCtb     	:= 0		// Valor total a ser contabilizado (VALOR)
Local nI 		  	:= 0
Local nLaco 		:= 0
Local nTotAbat 		:= 0
Local nSE1Rec 		:= 0
Local cKeyAbt 		:= 0
Local nAcresc		:= 0		//Acrescimo do titulo de adiantamento
Local nDecres 		:= 0		//Decrescimo do titulo de adiantamento
Local nTitAcres 	:= 0		//Acrescimo do titulo principal
Local nTitDecre 	:= 0		//Decrescimo do titulo principal
Local nX 			:= 0
Local nY 			:= 0
Local nT 			:= 0
Local lAchou  		:= .F.
Local cCliAdt 		:= ""
Local cLojAdt 		:= ""
Local lF330FLTC 	:= ExistBlock("F330FLTC")
Local lF330AE5E		:= ExistBlock("F330AE5E")
Local lF330VEEX		:= ExistBlock("F330VEEX")
Local lFA330EAC		:= ExistBlock("FA330EAC")
Local nRecnoSE1 	:= SE1->(RECNO())
Local lImpComp 		:= SuperGetMv("MV_IMPCMP",,"2") == "1"
Local lIsNcc		:= .F.

//Compensacao de contas a receber, nao necessita verificar o parametro MV_BX10925
Local lPCCBaixa 	:= (cPaisLoc == "BRA")

Local lRaRtImp  	:= FRaRtImp()     //Define se ha retencao de impostos PCC/IRPJ no R.A
Local aSize			:= {}
Local oPanel
Local lDigita

Local aDiario		:=	{}
Local lVldDtFin		:= .T.
Local aFlagCTB		:= {}
Local lUsaFlag		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
Local lAtusalImp	:= .F.
Local nRecE1Dest	:= 0		// Recno SE1 do título destino da exclusão.  (partida é o título que inicia o processo posicionado)
Local nRecE5Dest	:= 0		// Recno SE5 do título destino da exclusão.  (partida é o título que inicia o processo posicionado)

//Controla o Pis Cofins e Csll na baixa  (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default) )
Local lPccBxCr		:= FPccBxCr()
//Controla IRPJ na baixa
Local lIrPjBxCr		:= FIrPjBxCr()
Local nIrrf			:= 0
Local nPis			:= 0
Local nCofins		:= 0
Local nCsll			:= 0
Local nInss			:= 0
Local nCtbInss		:= 0
Local aTitulosTMP	:= {}
Local aTamChav		:= {}
Local cREGAnt 		:= ""
Local cREG 			:= ""
Local aLstDOC		:= {}
Local cChaveE1Adt 	:= ""
Local cChaveE5Adt 	:= ""
Local aAreaE5Adt
Local aAreaE1Adt
Local aAdtVen  		:= {}
Local lAdtVen  		:= .F.
Local aTipos   		:= {}
Local cTipos   		:= ""
Local cTipoAux 		:= ""
Local lVinculo 		:= .F.
Local lF330Exclui
Local lF330ESE5  	:= ExistBlock( "F330ESE5" )
Local lF330ExComp 	:= ExistBlock( "F330EXCOMP" )
Local lFi330Est   	:= ExistBlock( "FI330EST" )
Local l330DESC    	:= ExistBlock("F330DESC")
Local lDESC       	:= .F.
Local lRetAuto		:= .T.
Local cChavePai		:= ''
Local aDtMov		:=	{}
Local lPccComp 		:= .T.
Local aAreaSE5		:=	{}
Local cChaveSE5		:=	''
Local lBxCanc		:= .T.
Local nDescP		:= 0
Local nDescD		:= 0
Local nIrrfPac 		:= 0
Local nValPcc		:= 0  
Local nSaldoBx		:= 0
Local nVlNewPis 	:= nVlNewCof := nVlNewCsl := nPosTit := nVlNewIrf := 0
Local nValAux		:= 0

//--- Tratamento Gestao Corporativa
Local lGestao   	:= Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa
Local cFilFwSE1 	:= lGestao .And. FwFilial("SE1")
Local cAliasCmp		:= GetNextAlias()
Local aDadosX		:=  {}
Local cFilCred		:=  ""
Local cFilSe1		:=	xFilial("SE1")
Local cTrabalho 	:=""
Local lLjOrigem 	:= Alltrim(Upper(FunName())) $ "LOJA140|LOJA701" .OR. Alltrim(SE1->E1_ORIGEM) $ "LOJA701|FRTA010|LOJA720" //indica se eh executada por alguma rotina do SIGALOJA/FRT

//Controle de abatimento
Local nOrdTitPai	:= 0
Local lTitpaiSE1 	:= (nOrdTitPai:= OrdTitpai()) > 0
Local cTipo 		:= ""
Local bWhile 		:= {|| !EOF() .And. E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA==cFilSE1+cKeyAbt}
Local bWhile2 		:= {|| (cFilSE1+cPrefixo+cNum+cParcela == SE1->E1_FILIAL+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA ) .OR. (Alltrim(SE1->E1_TITPAI) == Alltrim(cChavePai))}
Local lSE1Exclusivo := .F.
Local cFilOld 		:= cFilAnt
// Variaveis para o Novo Modelo de Gravacao do Movimento Bancario
Local aAreaAnt 		:= {}
Local cLog 			:= ""
Local lRet 			:= .T.
Local cCamposE5 	:= ""
//Impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
Local nPisFin061	:= 0
Local nCofFin061	:= 0
Local nCslFin061	:= 0
Local nIrfFin061	:= 0  
Local nOrdSE5		:= 0
Local nVlPis		:= 0
Local nVlCof		:= 0
Local nVlCsll		:= 0
Local nVlIrrf		:= 0
Local nVlNf			:= 0
Local lBQ10925		:= SuperGetMV("MV_BQ10925",,"2") == "1" .And. !lRaRtImp
Local aBaixa 		:= {}
LOCAL nTotAdto		:= 0
Local lBaixaAbat	:= .F.
Local nVlrBaixa		:= 0
Local lBxCec		:= .F.
Local lBxLiq		:= .F.
Local lbxPos		:= .F.
Local lExistFJU 	:= FindFunction("FinGrvEx")
Local lF070TRAVA	:= ExistBlock("F070TRAVA")
Local lGrvSa1		:= .T.
Local cCliLoja 		:= ""
Local nRegFK1		:= 0
Local aBxInteg 		:= {}
Local nRecNf 		:= 0
Local cSE1Orig 		:= ""
Local nInt 			:= 0
Local lOpcAux 		:= .F. 
Local lEnvMU070 	:= FWHasEAI( "FINA070", .T.,, .T. )
Local lEnvMU330 	:= FWHasEAI( "FINA330", .T.,, .T. )
Local aRetInteg 	:= {}
Local nCMEst		:= 0
Local lEstFdif		:= .F.
Local cFilPai		:= cFilAnt
Local cChvCrPai		:= ""		
Local cCliLjPai		:= ""

// Integração SIGAPFS x SIGAFIN
Local nSE5PFS    	:= 0
Local nSE5PFSTMP 	:= 0
Local nSE5PFSRA  	:= 0
Local nSE1PFS    	:= 0
Local nSE1PFSRA  	:= 0
Local nMovPFS    	:= 0
Local nValHist	 	:= 0
Local aMovPFS    	:= {}
Local aAlt			:= {}
Local lAcrDecr 		:= .F.

Local lIrfBxAux 	:= lIrPjBxCr
Local lPccBxAux 	:= lPccBxCr
Local lRaRtImpMR 	:= .F.
Local aAreaFK7		:= {}
Local cIdOrig 		:= ""
Local lSE5ModExc  	:= FWModeAccess("SE5",3)== "E" // Verifica se SE5 é exclusiva
Local lFinTp01		:= FindFunction("FINTP01")
Local cPrefCred 	:= ""
Local cNumCred		:= ""
Local cParcCred		:= ""
Local cTpCred		:= ""
Local nPosAcum		:= 0
Local cPicE5Val     := PesqPict("SE5","E5_VALOR")

Local lAtuSldImp As Logical
Local lIntPFS As Logical

Local nRecAntSe5	:= 0
Local nRecAntSe1	:= 0
Local nValVa 		:= 0

Local nInicio		:= 0
Local nFim			:= 0
Local nGravados		:= 0
Local nRegistros	:= 0

Local lPCO01605		:= PcoExistLc("000016","05","1")
Local lUsaAbat		:= .F.

Local nMVToler		:= SuperGetMv("MV_TOLERPG",,0.01)
Local nToler		:= 0.01 
Local nSaldoTit		:= 0
Local cFilAux		:= ""

PRIVATE aTitulos	:= {}
PRIVATE cPrefixo	:= SE1->E1_PREFIXO
PRIVATE cNum		:= SE1->E1_NUM
PRIVATE cTipoTit	:= SE1->E1_TIPO
PRIVATE cCliente	:= SE1->E1_CLIENTE
PRIVATE cLoja		:= SE1->E1_LOJA
PRIVATE cParcela	:= SE1->E1_PARCELA
PRIVATE cTipodoc	:= "  "
PRIVATE lCredito	:= .F.
PRIVATE cTipodc		:= " "
PRIVATE nValTit		:= 0
PRIVATE aBaixaSE5 	:= {}

If __cRmProd == Nil
	__cRmProd		:= SuperGetMv('MV_RMORIG',, "E|U|S")
EndIf

If lFinTp01 .And. FINTP01(.T.) // Restringe o uso do programa Financeiro quando a origem do titulo for de origem Totvs Incorporação RM
	Return
EndIf

lIntPFS := SuperGetMV("MV_JURXFIN",, .F.) .Or. SuperGetMV("MV_JESCJUR",, .F.) //Integração SIGAPFS

//Não deixa efetuar o Cancelamento da Baixa de um titulo vindo de integração
If(Alltrim(SE1->E1_ORIGEM)  $ __cRmProd .And. !l330Auto)
	HELP(" ",1,STR0132 ,,STR0135,2,0,,,,,, {STR0134})//"Titulo gerado e compensado pela Integração RM Classis X Protheus, não pode ser cancelado" ## "Efetue o processo através do sistema RM Classis"
	Return
EndIf

// Metrica de controle de acessos - Cancelamento da Compensação
__cFunBkp   := FunName()
__cFunMet	:= Iif(AllTrim(__cFunBkp)=='RPC',"RPCFINA330",__cFunBkp)

If __lMetric
	SetFunName(__cFunMet)
	FwCustomMetrics():setSumMetric(Alltrim(ProcName()), "financeiro-protheus_qtd-por-acesso_total", 1)
	SetFunName(__cFunBkp)
EndIf

//Guardando a chave do titulo pai.
cChavePai	:= TRIM(SE1->(E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA))

If lGestao
	If !Empty(cFilFwSE1)
		lSE1Exclusivo := .T.
    EndIf
Else
	If !Empty(xFilial("SE1"))
		lSE1Exclusivo := .T.
	EndIf
EndIf

If !FA330Lock(,SE1->(Recno()))
	Return
EndIf

If (ALLTRIM(SE1->E1_ORIGEM) == "FINA677") .and. !(FINVERRES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),SE1->E1_ORIGEM, "R"))
	Help(" " , 1 , "FAVIAGEM")
	Return
EndIf

//Validação quando utiliza módulo do agro
If !l330Auto .And. SuperGetMv("MV_SIGAAGR",,.F.)
	If FindFunction("AGRTITFIN")
		If !AGRTITFIN()
			return .F.
		EndIf
	EndIf  
EndIf

If ExistBlock("F330DTFIN")
	lVldDtFin := ExecBlock("F330DTFIN",.F.,.F.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se data do movimento n„o ‚ menor que data limite de ³
//³ movimentacao no financeiro    										  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lVldDtFin .and. !DtMovFin(,,"2")
	Return(.F.)
EndIf

If lF070TRAVA
   	lGrvSa1 := ExecBlock("F070TRAVA", .F., .F.)
EndIf

If SE1->E1_TIPO $ MV_CRNEG+"/"+MVRECANT
	cTipodoc 	:= "BA"
	lCredito	:= .T.
	cTipodc		:="CP"
	lIsNcc 		:= SE1->E1_TIPO $ MV_CRNEG
Else
	cTipodoc 	:= "CP"
	cTipodc		:="BA"
EndIf
If Substr(SE1->E1_TIPO,3,1) == "-"
	If !l330Auto
		Help(" ",1,"FA030INVAL")
  	EndIf
  	lRetAuto := .F.
  	Return lRetAuto
EndIf

//-----------------------------------------------------------
// Nao permite compensar recebimentos antecipados originados
// de faturas de adiantamentos. Req. Manejo de Anticipo
//-----------------------------------------------------------
If cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT")
	If SE1->E1_TIPO == Substr(MVRECANT,1,3) .And.;
		Upper(Alltrim(SE1->E1_ORIGEM)) $ ("FINA087A|"+IIF(FindFunction('OriCobrDiv'),OriCobrDiv(),"")) .And.;
		GetAdvFVal("SED","ED_OPERADT",xFilial("SED")+SE1->E1_NATUREZ,1,"") == "1"

		Help(" ",1,"VLDTITRA",,STR0065,1,0) //"Processo não permitido para recebimento antecipado gerado de fatura de adiantamento."
		Return (.F.)

	EndIf
EndIf

If cPaisLoc == 'BRA' .And. lRarTimp .And. lCredito .And. !lIrpjBxCr
	dbSelectArea("SE5")
	dbSetOrder(2)
	dbSeek( SE5->E5_FILIAL + cTipoDoc + cPrefixo + cNum + cParcela + cTipoTit )
	cPrefCred 	:= Left(SE5->E5_DOCUMEN,Len(cPrefixo))
	cNumCred	:= SubStr(SE5->E5_DOCUMEN, ( nPosAcum := Len(cPrefixo) + 1 ), Len(cNum))
	cParcCred	:= SubStr(SE5->E5_DOCUMEN,( nPosAcum := ( nPosAcum + Len(cNum)) ), Len(cParcela))
	cTpCred		:= SubStr(SE5->E5_DOCUMEN, nPosAcum + Len(cParcela), Len(cTipoTit))
	Help(" ",1,"PARTEST",,STR0114 + CRLF + cTpCred + STR0115 + CRLF + cPrefCred + '/ ' + cNumCred + '/ ' + cParcCred + STR0116,1,0) //"Estornar esse processo a partir do título XXX para não comprometer saldo do abatimento do IR."
	Return ( .F. )
EndIf

If Select("__SE1") == 0
	SumAbatRec("","","",1,"")
EndIf

While ( .T. )
	aTitulos   := {}
	aRegistros := {}
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Titulo a ser cancelado a compensa‡„o		 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nOpca := 0

	If !l330Auto
		If lPanelfin
			oPanelDados := FinWindow:GetVisPanel()
			oPanelDados:FreeChildren()
			aDim := DLGinPANEL(oPanelDados)
			DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0,0 To 0,0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Observacao Importante quanto as coordenadas calculadas abaixo: ³
			//³ -------------------------------------------------------------- ³
			//³ a funcao DlgWidthPanel() retorna o dobro do valor da area do	 ³
			//³ painel, sendo assim este deve ser dividido por 2 antes da sub- ³
			//³ tracao e redivisao por 2 para a centralizacao. 					 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nEspLarg := ((DlgWidthPanel(oPanelDados)/2) - 225) /2
			nEspLin  := 20
		Else
	   		nEspLarg := 0
	   		nEspLin  := 2
			DEFINE MSDIALOG oDlg FROM	88,31 TO 187,525 TITLE STR0019 PIXEL  //"Compensa‡„o CR"
		EndIf
		
		oDlg:lMaximized := .F.
		oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20)
		oPanel:Align := CONTROL_ALIGN_ALLCLIENT

		@ 000+nEspLin, 002+nEspLarg TO 030+nEspLin, 245+nEspLarg OF oPanel	PIXEL

		@ 014+nEspLin, 006+nEspLarg MSGET cPrefixo							SIZE 19, 10 OF oPanel PIXEL
		@ 014+nEspLin, 032+nEspLarg MSGET cNum 	 Valid !Empty(cNum)	SIZE 70, 10 OF oPanel PIXEL
		@ 014+nEspLin, 105+nEspLarg MSGET cParcela							SIZE 20, 10 OF oPanel PIXEL
		@ 014+nEspLin, 129+nEspLarg MSGET cTipoTit  Picture "@!" Valid  !Empty(cTipoTit) .And.;
			Subs(cTipoTit,3)!="-" SIZE 16, 10 OF oPanel PIXEL
		@ 014+nEspLin, 155+nEspLarg MSGET cCliente F3 "SA1" Valid fa330Cli() SIZE 70, 10 OF oPanel Hasbutton PIXEL
		@ 014+nEspLin, 226+nEspLarg MSGET cLoja	Valid Fa330Loja() 	SIZE 16, 10 OF oPanel PIXEL

		@ 006+nEspLin, 006+nEspLarg SAY STR0006  SIZE 21, 7 OF oPanel PIXEL  //"Prefixo"
		@ 006+nEspLin, 032+nEspLarg SAY STR0007  SIZE 22, 7 OF oPanel PIXEL  //"N£mero"
		@ 006+nEspLin, 105+nEspLarg SAY STR0008  SIZE 23, 7 OF oPanel PIXEL  //"Parcela"
		@ 006+nEspLin, 129+nEspLarg SAY STR0009  SIZE 14, 7 OF oPanel PIXEL  //"Tipo"
		@ 006+nEspLin, 155+nEspLarg SAY STR0025  SIZE 34, 7 OF oPanel PIXEL  //"Cliente   "
		@ 006+nEspLin, 226+nEspLarg SAY STR0011  SIZE 14, 7 OF oPanel PIXEL  //"Loja"

		If lPanelFin  //Chamado pelo Painel Financeiro
			oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])
			ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,;
			{||nOpca:=1,oDLg:End()},;
			{||nOpca:=0,oDlg:End()})

		Else
			DEFINE SBUTTON FROM 34, 190 TYPE 1 ENABLE ACTION (nOpca:=1,oDLg:End()) OF oDlg
			DEFINE SBUTTON FROM 34, 218 TYPE 2 ENABLE ACTION oDlg:End() OF oDlg
			ACTIVATE MSDIALOG oDlg CENTERED

		EndIf

		If lFi330Est .And. nOpca == 1
			nOpca := ExecBlock("FI330EST",.F.,.F.,{ nOpc, { cPrefixo, cNum, cParcela, cTipoTit, cCliente, cLoja }})
			If ValType(nOpca) != "N"
				nOpca := 0
			EndIf
		EndIf

		If ( nOpca == 0 )
			DeleteObject(oOk)
			DeleteObject(oNo)
			Exit
		EndIf

	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o t¡tulo existe. 	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE1")
	dbSetOrder(2)
	dbSeek(xFilial("SE1")+cCliente+cLoja+cPrefixo+cNum+cParcela+cTipoTit)
	If !Found()
		If !l330Auto
			Help(" ",1,"NOTIT")
	  	Endif
		DeleteObject(oOk)
		DeleteObject(oNo)
		FA330aUnlock()
		lRetAuto := .F.
		Exit
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o t¡tulo nao foi compensado.  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( SE1->E1_SALDO == SE1->E1_VALOR ) .and. ;
		(SE1->E1_ACRESC == SE1->E1_SDACRES) .and. ;
		(SE1->E1_DECRESC == SE1->E1_SDDECRE)

		If ! l330Auto
		  Help(" ",1,"A330NAOCOMP")
		Endif

		DeleteObject(oOk)
		DeleteObject(oNo)
		lRetAuto := .F.
		Exit //Loop

	EndIf

	//ANGOLA - Nao permitir compensar titulos de adiantamento relacionado a pedido
	If cPaisLoc == "ANG"
		FIE->(dbSetOrder(2))
		If FIE->(MsSeek(xFilial("FIE")+"R"+SE1->(E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)))
			Help(" ",1,"NOCANCMP",,STR0063,1,0)
			DeleteObject(oOk)
			DeleteObject(oNo)
			Loop
		Endif
	Endif

	//Metricas - Tela do cancelamento da compensação - INICIO
	If __lMetric
		nInicio := Seconds()
	Endif

	nMoeda 		:= SE1->E1_MOEDA 				// Moeda do tit original
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Guardo dados do titulo principal para utilizar   ³
	//³ no historico da contabiliza‡Æo                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	STRLCTPAD := SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Procura a filial em que este titulo foi compensado ³
	//³ quando compensacao multifiliais                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	F330PsqFil(SE1->E1_FILORIG,cPrefixo,cNum,cParcela,SE1->E1_CLIENTE,SE1->E1_LOJA,cTipoTit,"R",cTipoDoc,cAliasCmp,@cTrabalho)

	__cFk1IdOri := ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Procura adiantamentos do titulo original para      ³
	//³ montar lista de titulos compensados para apresentar³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea(cAliasCmp)
	While (cAliasCmp)->( !EOF() )
		dbSelectArea("SE5")
		dbSetOrder(2)
		If lSE5ModExc .Or. (!lSE5ModExc .And. lSE1Exclusivo)
			VerSE5((cAliasCmp)->( E5_FILIAL ), cTipoDoc, cPrefixo, cNum, cParcela, cTipoTit, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG)
		Else
			dbSeek( (cAliasCmp)->( E5_FILIAL ) + cTipoDoc+cPrefixo+cNum+cParcela+cTipoTit)
		EndIf		

		nValVa		:= FxLoadFK6("FK1",SE5->E5_IDORIG,"VA")[1,2]	//Pego o valor Informado

		While ( SE5->(!Eof()) .and. (cAliasCmp)->( E5_FILIAL ) == SE5->E5_FILIAL .And.	;
				SE5->E5_TIPODOC == cTipoDoc .And. 				;
				SE5->E5_PREFIXO == cPrefixo .And.				;
				SE5->E5_NUMERO == cNum .And.					;
				SE5->E5_PARCELA == cParcela )

			If (!lSE5ModExc .And. lSE1Exclusivo) .and. SE5->E5_FILORIG <> SE1->E1_FILORIG
				SE5->(DbSkip())
				Loop
			EndIf 

			VerFk1(SE5->E5_IDORIG, @__cFk1IdOri)
			
			If (SE5->E5_MOTBX != "CMP" .Or. SE5->E5_RECPAG != "R" )
				dbSkip()
				Loop
			Endif

			//Verifica se tem baixa cancelada
			If TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T.,SE5->E5_FILIAL,,,SE5->E5_FILORIG)
				SE5->(dbskip())
				Loop
			EndIf

			aBaixaSE5 := {}
			lbxPos := .F.
			//verifica se houve baixa posteriores
			aBaixa := Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, SE5->E5_PREFIXO,SE5->E5_NUMERO, SE5->E5_PARCELA, SE5->E5_TIPO,;
			                       @nTotAdto, @lBaixaAbat, SE5->E5_CLIFOR, SE5->E5_LOJA, @nVlrBaixa, , @lBxCec, @lBxLiq , ,.T.)

			For nX := 1 to len(aBaixaSE5)
				If aBaixaSE5[nX][29] == "CMP"
					Loop
				ElseIf aBaixaSE5[nX][9] > SE5->E5_SEQ
					If aBaixaSE5[nX][18]+aBaixaSE5[nX][19]+aBaixaSE5[nX][20]+aBaixaSE5[nX][30] > 0
						HELP(" ",1, "FINIMPBX" )
						lbxPos := .T.
						Exit						
					EndIf 
				EndIf
			Next nXad
			
			If lbxPos
				SE5->(DbSkip())
				Loop
			EndIf	
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica Cliente se considerar Cliente Original 		³
			//³ na selecao de titulos 									³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If mv_par02 == 1 .and.  SE5->E5_CLIFOR != SE1->E1_CLIENTE
				dbSkip( )
				Loop
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica loja caso considere loja na selecao de titulos	  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If mv_par01 == 1 .and. mv_par02 == 1 .and.  SE5->E5_LOJA != SE1->E1_LOJA
				dbSkip( )
				Loop
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se a baixa e anterior a data do sistema    	  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SE5->E5_DATA > dDatabase
				dbSkip( )
				Loop
			EndIf

			//ANGOLA - Nao permitir compensar titulos de adiantamento relacionado a pedido
			If cPaisLoc == "ANG"
				FIE->(dbSetOrder(2))
				If FIE->(MsSeek(xFilial("FIE")+"R"+SE5->(E5_CLIFOR+E5_LOJA+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO)))
					dbSkip()
					Loop
				EndIf
			EndIf

			If cPaisLoc == "BRA"
				// se estorno da compensacao nao estah partindo do titulo de credito
				If !lCredito
					If AllTrim(SE1->E1_ORIGEM) == "MATA460"
						// checa se condicao de pagamento eh relacionado com adiantamento
						If FaNfsRAdt(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_CLIENTE,SE1->E1_LOJA,SE1->E1_EMISSAO)
							lAdtVen := .T.
							// checa se eh a primeira baixa para o titulo principal, pois a primeira baixa eh realizada no momento da geracao do documento de saida, quando hah adiantamento relacionado ao documento.
							If FaBxEmisDoc(SE5->E5_FILIAL,SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_TIPO,SE5->E5_DATA,SE5->E5_SEQ,"R",SE5->E5_DOCUMEN)
								dbSelectArea("SE5")
								aAdd(aAdtVen,{SE5->E5_DATA,SE5->E5_VALOR,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ}) // grava array com registros que foram compensados no momento da geracao do documento de saida e que nao podem ser excluidos na compensacao do Fina330. Grava campos que sao iguais entre o registro principal da baixa e o do adiantamento.
								dbSkip()
								Loop
							Endif
						Endif
					Endif
				// se estorno da compensacao estah partindo do titulo de credito
				Else
					// posiciona no titulo principal e na baixa principal para checar se eh adiantamento e se esta baixa foi gerada no momento da emissao do documento de saida.
					aAreaE5Adt := SE5->(GetArea())
					If lLjOrigem .Or. Empty(SE5->E5_FORNADT)	//executada por alguma rotina do SIGALOJA/FRT
						cChaveE5Adt := SE5->E5_FILIAL+cTipoDc+Subs(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)+dTos(SE5->E5_DATA)+IIf(Empty(SE5->E5_FORNADT),SE5->(E5_CLIFOR+E5_LOJA+E5_SEQ),SE5->(E5_FORNADT+E5_LOJAADT+E5_SEQ))
					Else
						cChaveE5Adt := SE5->E5_FILIAL+cTipoDc+Subs(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)+dTos(SE5->E5_DATA)+SE5->(E5_FORNADT+E5_LOJAADT+E5_SEQ)
					EndIf
					aAreaE1Adt := SE1->(GetArea())
					If lLjOrigem .Or. Empty(SE5->E5_FORNADT)	//executada por alguma rotina do SIGALOJA/FRT
						cChaveE1Adt := SE5->E5_FILIAL+IIf(Empty(SE5->E5_FORNADT),SE5->(E5_CLIFOR+E5_LOJA), SE5->(E5_FORNADT+E5_LOJAADT))+Subs(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)
					Else
						cChaveE1Adt := SE5->E5_FILIAL+SE5->(E5_FORNADT+E5_LOJAADT)+Subs(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)
					EndIf
					// posiciona no titulo principal
					SE1->(dbSetOrder(2)) // E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO                                                                                               
					If SE1->(dbSeek(cChaveE1Adt))

						If (ALLTRIM(SE1->E1_ORIGEM) == "FINA677") .and. !(FINVERRES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),SE1->E1_ORIGEM, "R"))
							SE5->(dbskip())
							Loop
					 	Endif
						// posiciona na baixa principal
						SE5->(dbSetOrder(2)) // E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+DtoS(E5_DATA)+E5_CLIFOR+E5_LOJA+E5_SEQ                                                             
						If SE5->(dbSeek(cChaveE5Adt))
							If AllTrim(SE1->E1_ORIGEM) = "MATA460"
								// checa se condicao de pagamento eh relacionado com adiantamento
								If FaNfsRAdt(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_CLIENTE,SE1->E1_LOJA,SE1->E1_EMISSAO)
									lAdtVen := .T.
									// checa se eh a primeira baixa para o titulo principal, pois a primeira baixa eh realizada no momento da geracao do documento de saida, quando hah adiantamento relacionado ao documento.
									If FaBxEmisDoc(SE5->E5_FILIAL,SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_TIPO,SE5->E5_DATA,SE5->E5_SEQ,"R",SE5->E5_DOCUMEN)
										RestArea(aAreaE1Adt)
										RestArea(aAreaE5Adt)
										dbSelectArea("SE5")
										aAdd(aAdtVen,{SE5->E5_DATA,SE5->E5_VALOR,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ}) // grava array com registros que foram compensados no momento da geracao do documento de saida e que nao podem ser excluidos na compensacao do Fina330.
										dbSkip()
										Loop
									Endif
								Endif
							Endif
																				
							aBaixaSE5 := {}
							lbxPos := .F.
							//verifica se houve baixa posteriores
							aBaixa := Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, SE5->E5_PREFIXO,SE5->E5_NUMERO, SE5->E5_PARCELA, SE5->E5_TIPO,;
								@nTotAdto, @lBaixaAbat, SE5->E5_CLIFOR, SE5->E5_LOJA, @nVlrBaixa, , @lBxCec, @lBxLiq , ,.T.)
				
							For nX := 1 to len(aBaixaSE5)
								If aBaixaSE5[nX][29] == "CMP"
										Loop						
								ElseIf aBaixaSE5[nX][9] > SE5->E5_SEQ
									If aBaixaSE5[nX][18]+aBaixaSE5[nX][19]+aBaixaSE5[nX][20]+aBaixaSE5[nX][30] > 0
										HELP(" ",1, "FINIMPBX" )
										lbxPos := .T.
										
										Exit						
									EndIf 
								EndIf
							Next nX
							If lbxPos
								SE5->(DBskip())
								Loop
							EndIf
													
						Endif
					Endif
					RestArea(aAreaE1Adt)
					RestArea(aAreaE5Adt)
					dbSelectArea("SE5")
				Endif
			Endif

			//Ponto de entrada para dispensar do cancelamento
			If lF330FLTC .and. ExecBlock("F330FLTC",.F.,.F.)
				dbSkip( )
				Loop
			Endif

			If lLjOrigem 	//executada por alguma rotina do SIGALOJA/FRT
				If Empty(SE5->E5_FORNADT)
					aAdd(aLstDOC,{xFilial("SE5"),SE5->E5_DOCUMEN,DTOS(SE5->E5_DATA) })
				Else
					aAdd(aLstDOC,{SE5->E5_FILIAL,SE5->E5_DOCUMEN,DTOS(SE5->E5_DATA)+SE5->E5_FORNADT+SE5->E5_LOJAADT+SE5->E5_SEQ })
				EndIf
			ElseIf 	Empty(SE5->E5_FORNADT)
				aAdd(aLstDOC,{xFilial("SE5"),SE5->E5_DOCUMEN,DTOS(SE5->E5_DATA)+SE5->E5_CLIFOR+SE5->E5_LOJA+SE5->E5_SEQ, SE5->E5_FILORIG })
			Else
				aAdd(aLstDOC,{SE5->E5_FILIAL,SE5->E5_DOCUMEN,DTOS(SE5->E5_DATA)+SE5->E5_FORNADT+SE5->E5_LOJAADT+SE5->E5_SEQ, SE5->E5_FILORIG })
			EndIf

			dbSelectArea( "SE5" )
			dbSkip()
		Enddo

		dbSelectArea( cAliasCmp )
		(cAliasCmp)->( dbSkip() )

	EndDo
	
	If Len(aLstDOC) == 0
		If !l330Auto
			If Len(aAdtVen) > 0	//	Único movimento de compensação foi o do faturamento
				Help( ,,"COMPFAT",,STR0082, 1, 0 )	// "Compensação gerada na inclusão do documento de saída com adiantamento, não pode ser excluída na compensação Contas a Receber(FINA330)."
			Else
				Help(" ",1,"NOTITSEL",,"" ,1,0,,,,,,{STR0130})
			EndIf
		Endif
		DeleteObject(oOk)
		DeleteObject(oNo)
		FA330aUnlock()
		lRetAuto := .F.
		Exit
	EndIf

	If SE1->E1_TIPO $ MV_CRNEG+"/"+MVRECANT
		cTipodoc := "CP"
	Else
		cTipodoc := "BA"
	EndIf

	//Motor de retenções
	If __lMotRet
		//Verifica as configurações de impostos pelo motor de retenção
		F330VldImp()		
		
		lRaRtImpMR := ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
		lPccBxCr := ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
		lIrPjBxCr := ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Procura adiantamentos do titulo original para      ³
	//³ montar lista de apresentacao                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
	dbSelectArea("SE5")
	SE5->(dbSetOrder(2))	//E5_FILIAL, E5_TIPODOC, E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_DATA, E5_CLIFOR, E5_LOJA, E5_SEQ
	For nI := 1 to Len(aLstDOC)
		SE5->(dbSeek(aLstDoc[nI][1] + cTipoDoc + Substr(aLstDoc[nI][2],1,nTamTit+nTamTip) + Iif(!lLjOrigem .or. Len(aLstDoc[nI][3]) > 10,aLstDoc[nI][3],"") ))
		If (lF330ESE5)
			//-- Ponto de entrada para que o registro na SE5 seja posicionado corretamente
			//-- quando existir diferenças no tamanho dos campos envolvidos no indice do SEEK.
			ExecBlock("F330ESE5",.F.,.F.,{aLstDOC,cTipoDoc,nTamTit,nTamTip,nI})
		EndIf
		While SE5->(! Eof() .AND. SE5->E5_FILIAL == aLstDoc[nI][1] .AND.	;
					E5_TIPODOC + E5_PREFIXO + E5_NUMERO + E5_PARCELA+E5_TIPO == cTipoDoc + Substr(aLstDoc[nI][2],1,nTamTit+nTamTip) .AND. ;
					SubStr(DTOS(SE5->E5_DATA)+SE5->(E5_CLIFOR+E5_LOJA+E5_SEQ), 1, Len(aLstDoc[nI][3]) ) == aLstDoc[nI][3] )

			// se for compensacao gerado no momento da geracao do documento de saida, nao pode ser excluido na compensacao do Fina330.

			If lAdtVen
				If aScan(aAdtVen,{|x| x[1] = SE5->E5_DATA .and. ;
				x[2] = SE5->E5_VALOR .and. ;
				x[3] = SE5->E5_CLIFOR .and. ;
				x[4] = SE5->E5_LOJA.and. ;
				x[5] = SE5->E5_SEQ}) > 0
					dbSkip()
					Loop
				EndIf
			EndIf

			If (SE5->E5_MOTBX != "CMP" .Or. SE5->E5_RECPAG != "R")
				dbSkip( )
				Loop
			EndIf

			If lSE5ModExc .And. !Empty(__cFk1IdOri) .And. !VerFK1(SE5->E5_IDORIG) 
				dbSkip( )
				Loop
			EndIf

			If (!lSE5ModExc .And. lSE1Exclusivo) .and. Len(aLstDoc[nI]) >= 4 .and. SE5->E5_FILORIG <> aLstDoc[nI][4] .And. SE5->E5_FILORIG == SE5->E5_FILIAL
				SE5->(DbSkip())
				Loop
			EndIf 

			//Verifica se tem baixa cancelada-
			If TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T.,SE5->E5_FILIAL,,,SE5->E5_FILORIG)
				SE5->(dbskip())
				Loop
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica Cliente se considerar Cliente Original 			³
			//³ na selecao de titulos 												³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If mv_par02 == 1 .and.  SE5->E5_CLIFOR != SE1->E1_CLIENTE
				dbSkip( )
				Loop
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica loja caso considere loja na selecao de titulos	  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If mv_par01 == 1 .and. mv_par02 == 1 .and.  SE5->E5_LOJA != SE1->E1_LOJA
				dbSkip( )
				Loop
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se a baixa e posterior a data do sistema    	  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SE5->E5_DATA > dDatabase
				dbSkip( )
				Loop
			EndIf

			//ANGOLA - Nao permitir compensar titulos de adiantamento relacionado a pedido

			If cPaisLoc == "ANG"
				FIE->(dbSetOrder(2))
				If FIE->(MsSeek(xFilial("FIE")+"R"+SE5->(E5_CLIFOR+E5_LOJA+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO)))
					dbSkip()
					Loop
				EndIf
			EndIf

			//Ponto de entrada para dispensar do cancelamento
			If lF330FLTC .and. ExecBlock("F330FLTC",.F.,.F.)
				dbSkip( )
				Loop
			EndIf

			If cTipoTit $ MV_CRNEG + "/" + MVRECANT
				If (lIsNCC .AND. !Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MV_CRNEG) .OR. (!lIsNCC .AND. !Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MVRECANT)
			 		SE5->(dbSkip())
					Loop
				Else
					If Substr(SE5->E5_DOCUMEN,1,nTamTit) # SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA)
						SE5->(dbSkip())
						Loop
					EndIf
				EndIf
			EndIf

			If !(cTipoTit $ MV_CRNEG + "/" + MVRECANT)
				If Substr(SE5->E5_DOCUMEN,1,nTamTit+nTamTip+nTamLoj) != cPrefixo+cNum+cParcela+cTipoTit+cLoja
					SE5->(dbSkip())
					Loop
				EndIf
			EndIf

			nOrdSE1	:= SE1->(IndexOrd())
			nRegSE1	:= SE1->(Recno())
			nTAbat 	:= SumAbatRec(cPrefixo,cNum,cParcela,SE1->E1_MOEDA,"V",dBaixa)
			
			If lPccBxCr
				nTAbat += FA330RetPCC(cPrefixo,cNum,cParcela,SE1->E1_MOEDA,dBaixa)
			EndIf

			SE1->(dbSetOrder(nOrdSE1))
			SE1->(dbGoto(nRegSE1))
			
			If lIrPjBxCr .And. ( !lRartimp .And. !lRaRtImpMR )
				nTAbat += SE1->E1_IRRF
			EndIf

			nVlLiqTit:= SE1->E1_VALOR - nTAbat		// Valor do titulo - Abatimentos
			Aadd( aTitulos,{ SE5->E5_PREFIXO,;
				SE5->E5_NUMERO,;
				SE5->E5_PARCELA,;
				SE5->E5_TIPO,;
				SE5->E5_LOJA,;
				DtoC(SE5->E5_DATA),;
				Substr(SE5->E5_DOCUMEN,1,nTamTit),;
				SE5->E5_SEQ,;
				Transform(nVlLiqTit,"@E 9999,999,999.99"),;
				Transform(SE5->E5_VLMOED2,"@E 9999,999,999.99"),;
				.T.,;
		    	SE1->E1_FILIAL,;
		    	SE5->E5_FILIAL,;
				if(lCredito,SomaAbat(SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA, "R", SE1->E1_MOEDA, dDataBase, SE5->E5_CLIFOR, SE5->E5_LOJA, Nil, Nil, SE5->E5_TIPO),0),;
				SE5->E5_FILORIG,;
				SE5->(Recno())})
			dbSelectArea( "SE5" )
			dbSkip()
		Enddo
	Next nI
	
	If Len(aTitulos) == 0
		If !l330Auto
			If Len(aAdtVen) > 0	//	Único movimento de compensação foi o do faturamento
				Help( ,,"COMPFAT",,STR0082, 1, 0 )	// "Compensação gerada na inclusão do documento de saída com adiantamento, não pode ser excluída na compensação Contas a Receber(FINA330)."
			Else
				Help(" ",1,"NOTITSEL",,"" ,1,0,,,,,,{STR0130})
			EndIf		
		Endif
		DeleteObject(oOk)
		DeleteObject(oNo)
		FA330aUnlock()
		lRetAuto := .F.
		Exit
	Else
		//Remove titulos duplicados, caso existam
		// Primeiro ordena o array para que a lógica faça mais sentido
		aSort( aTitulos , , , { |a,b| a[1]+a[2]+a[3]+a[4]+a[6]+a[8] > b[1]+b[2]+b[3]+b[4]+b[6]+b[8] } )
		If Len(aTitulos) > 1
			For nI := Len(aTitulos) to 1 Step -1
				For nX := 1 to Len(aTitulos[nI])
					cREG += IIf(!cValtoChar(nX) $ "6,11",IIf(ValType(aTitulos[nI,nX]) # "C",cValtoChar(aTitulos[nI,nX]),aTitulos[nI,nX]),"")
				Next nX
				If cREGAnt == cREG
					aTitulos[nI,11] := .F.
				Endif
    			cREGAnt := cREG
       			cREG := ""
			Next nI
			For nI := 1 to Len(aTitulos)
				If aTitulos[nI,11]
					aAdd(aTitulosTMP,aTitulos[nI])
					If !DtMovFin(CtoD(aTitulosTMP[Len(aTitulosTMP)][06]),.F.,"2")
						aTitulosTMP[Len(aTitulosTMP)][11] := .F.
					Endif
				Endif
			Next nI
			aTitulos := aClone(aTitulosTMP)
			aTitulosTMP := Array(0)
		Else
			If !DtMovFin(CtoD(aTitulos[Len(aTitulos)][06]),.F.,"2")
				aTitulos[Len(aTitulos)][11] := .F.
			EndIf
		EndIf
	EndIf

	nOpcA := 0

	//Metricas - Tela do cancelamento da compensação - FIM
	If __lMetric
		nRegistros := Len(aTitulos)

		If nRegistros > 0
			nFim := Seconds() - nInicio
			nFim := nFim / nRegistros

			SetFunName(__cFunMet)
			FwCustomMetrics():setAverageMetric(Alltrim(ProcName())+" - TempoEntrada", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
			SetFunName(__cFunBkp)
		Endif
	Endif

	If !l330Auto

		//------------------------------------------
		// Mostra Titulos Compensados
		//------------------------------------------
		aSize := MsAdvSize(,.F.,400)
		DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 to aSize[6],aSize[5] of oMainWnd PIXEL
		oDLg:lMaximized := .T.

		@ 01.0,.5 LISTBOX oTitulo VAR cVarQ Fields;
			HEADER "",	STR0006,;  //"Prefixo"
			STR0007,;  //"N£mero"
			STR0008,;  //"Parcela"
			STR0009,;  //"Tipo"
			STR0011,;  //"Loja"
			STR0020,;  //"Data"
			STR0021,;  //"Documento"
			STR0022,;  //"Seq"
			STR0023,;  //"Valor do t¡tulo"
			STR0017,;  //"Valor compensado"
			RetTitle("E1_FILIAL") ;  //"Filial"
			COLSIZES 12,GetTextWidth(0,"BBBBB")	,;
			GetTextWidth(0,"BBBBBBBBB")		   ,;
			GetTextWidth(0,"BBBBB")					,;
			GetTextWidth(0,"BBB")					,;
			GetTextWidth(0,"BBB")					,;
			GetTextWidth(0,"BBBBBB")				,;
			GetTextWidth(0,"BBBBBBBBBB")  		,;
			GetTextWidth(0,"BBB")					,;
			GetTextWidth(0,"BBBBBBBBBB")			,;
			GetTextWidth(0,"BBBBBBBBBB")			,;
			GetTextWidth(0,"BBBBBBBBBB")			;
			SIZE 293,54.5 ON DBLCLICK (aTitulos := FA330marca(oTitulo:nAt,aTitulos,nOpc),oTitulo:Refresh())NOSCROLL

		oTitulo:bHeaderClick := {|oObj,nCol| If( nCol==1, fMarkAll(@aTitulos,,.T.),Nil), oTitulo:Refresh()}

		oTitulo:SetArray(aTitulos)
		oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,11],oOk,oNo),;
			aTitulos[oTitulo:nAt,1],aTitulos[oTitulo:nAt,2],;
			aTitulos[oTitulo:nAt,3],aTitulos[oTitulo:nAt,4],;
			aTitulos[oTitulo:nAt,5],aTitulos[oTitulo:nAt,6],;
			aTitulos[oTitulo:nAt,7],aTitulos[oTitulo:nAt,8],;
			aTitulos[oTitulo:nAt,9],aTitulos[oTitulo:nAt,10],;
			aTitulos[oTitulo:nAt,15]}}

		oTitulo:Align := CONTROL_ALIGN_ALLCLIENT
		//---
		oPanel := TPanel():New(0,0,'',oDlg, oDlg:oFont, .T., .T.,, ,20,20,.T.,.T. )
		oPanel:Align := CONTROL_ALIGN_BOTTOM

		If lPanelFin  //Chamado pelo Painel Financeiro
			ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,;
			{||nOpca := 1, oDlg:End() },;
			{||nOpca := 0, oDlg:End() })
	   Else
			DEFINE SBUTTON FROM 4,325 TYPE 1 ACTION (nOpca := 1, oDlg:End()) ENABLE OF oPanel PIXEL
			DEFINE SBUTTON FROM 4,360 TYPE 2 ACTION (nOpca := 0, oDlg:End())  ENABLE OF oPanel PIXEL
			ACTIVATE MSDIALOG oDlg CENTERED ON INIT (oTitulo:Refresh())
			If ( nOpca == 0 )
				DeleteObject(oOk)
				DeleteObject(oNo)
				Exit
			EndIf
		EndIf
	Else
		nOpca := 1
	EndIf

	if l330Auto .AND. nOpcA == 0
		lRetAuto := .F.
		Exit
	endif

	If ( nOpcA == 1 )

		//Metricas - Gravação do cancelamento - INICIO
		If __lMetric
			nInicio := Seconds()
		Endif

		//Desinvertendo a selecao NF-Antecipacao
		If SE1->E1_TIPO $ MV_CRNEG+"/"+MVRECANT
			cTipodoc := "BA"
		Else
			cTipodoc := "CP"
		EndIf
		aTitulosTMP := aClone(aTitulos)
		aTitulos := Array(0)
		aAdd(aTamChav,__nTamPrf)
		aAdd(aTamChav,__nTamNum)
		aAdd(aTamChav,__nTamParc)

		(cAliasCmp)->(DbGoTop())
		DbSelectArea(cAliasCmp)		
		While (cAliasCmp)->( !EOF() )
			dbSelectArea("SE5")
			SE5->(dbSetOrder(2))
			SE5->(dbSeek((cAliasCmp)->( E5_FILIAL ) + cTipoDoc + cPrefixo + cNum + cParcela + cTipoTit))
	       	While !SE5->(Eof()) .AND. (cAliasCmp)->( E5_FILIAL ) == SE5->E5_FILIAL .AND.	;
				SE5->E5_TIPODOC == cTipoDoc .AND. ;
				SE5->E5_PREFIXO == cPrefixo .AND. ;
				SE5->E5_NUMERO == cNum .AND. ;
				SE5->E5_PARCELA == cParcela

				// se for compensacao gerado no momento da geracao do documento de saida, nao pode ser excluido na compensacao do Fina330.
				If lAdtVen
					If aScan(aAdtVen,{|x| x[1] = SE5->E5_DATA .and. ;
					x[2] = SE5->E5_VALOR .and. ;
					x[3] = SE5->E5_CLIFOR .and. ;
					x[4] = SE5->E5_LOJA.and. ;
					x[5] = SE5->E5_SEQ}) > 0
						dbSkip()
						Loop
					EndIf
				EndIf

				If (!lSE5ModExc .And. lSE1Exclusivo) .and. SE5->E5_FILORIG <> SE1->E1_FILORIG
					SE5->(DbSkip())
					Loop
				EndIf 

				If (SE5->E5_MOTBX != "CMP" .Or. SE5->E5_RECPAG != "R")
					dbSkip( )
					Loop
				EndIf
				
				//Verifica se tem baixa cancelada
				If TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T.,SE5->E5_FILIAL,,,SE5->E5_FILORIG)
					SE5->(dbskip())
					Loop
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica Cliente se considerar Cliente Original 			³
				//³ na selecao de titulos 												³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If mv_par02 == 1 .and.  SE5->E5_CLIFOR != SE1->E1_CLIENTE
					dbSkip()
					Loop
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica loja caso considere loja na selecao de titulos	  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If mv_par01 == 1 .and. mv_par02 == 1 .and.  SE5->E5_LOJA != SE1->E1_LOJA
					dbSkip( )
					Loop
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se a baixa e anterior a data do sistema    	  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SE5->E5_DATA >dDatabase
					dbSkip( )
					Loop
				EndIf

				//Lista de tipos de Adiantamento e Notas de Crédito
				cTipos 	:= MV_CRNEG + "," + MVRECANT
				nT 		:= 0 //Step do nX

				For nX := 1 To Len(cTipos)

					For nY := nX to Len(cTipos)
						If IsAlpha(SubStr(cTipos,nY,1))
							cTipoAux += SubStr(cTipos,nY,1)
							nT++
						Else
							Exit
						Endif
					Next nY

					If Len(aTipos) == 0 .Or. aScan(aTipos,{|x| x == cTipoAux}) == 0
						aAdd(aTipos, cTipoAux)
					Endif

					cTipoAux := ""
					nX += nT
					nT := 0

				Next nX

				If !cTipoTit $ cTipos	//Nota fiscal
					//Caso seja uma NF vinculada a uma NCC ou RA
					For nX := 1 to Len(aTipos)
						If aTipos[nX] $ SE5->E5_DOCUMEN
							lVinculo := .T.
							Exit
						Endif
					Next nX

					If lVinculo
						If aScan(aTitulosTMP,{|x|(AllTrim(x[4]) $ cTipos) .AND. ;		//Tipo
							x[1] == Substr(SE5->E5_DOCUMEN,1,aTamChav[1]) .AND. ;				//Prefixo
							x[2] == Substr(SE5->E5_DOCUMEN,aTamChav[1]+1,aTamChav[2]) .AND. ;	//Numero
							x[3] == Substr(SE5->E5_DOCUMEN,aTamChav[1]+aTamChav[2]+1,aTamChav[3]) .AND. ;	//Parcela
							x[8] == SE5->E5_SEQ .AND. x[11] == .T. .and. x[13]==SE5->E5_FILIAL}) == 0												//Selecionado
							SE5->(dbSkip())
							Loop
						Endif
					Endif
				Else        //Antecipacao
					//Caso o titulo original seja de atencipacao e o tipo do registro atual seja diferente, sair
					If SE5->E5_TIPO # cTipoTit
						SE5->(dbSkip())
						Loop
					Else
						If aScan(aTitulosTMP,{|x| 	x[1] == Substr(SE5->E5_DOCUMEN,1,aTamChav[1]) .AND.;
							 x[2] == Substr(SE5->E5_DOCUMEN,aTamChav[1]+1,aTamChav[2]) .AND.;
							 x[3] == Substr(SE5->E5_DOCUMEN,aTamChav[1]+aTamChav[2]+1,aTamChav[3]) .AND.;
	 						 x[8] == SE5->E5_SEQ .AND. x[11]==.T. .and. x[13]==SE5->E5_FILIAL}) == 0
							SE5->(dbSkip())
							Loop
						EndIf
					EndIf
				EndIf
				nOrdSE1	:= SE1->(IndexOrd())
				nRegSE1	:= SE1->(Recno())
				nTAbat 	:= SumAbatRec(cPrefixo,cNum,cParcela,SE1->E1_MOEDA,"V",dBaixa)
				nTAbat 	+= Iif(lIrPjBxCr, SE5->E5_VRETIRF,0)
				SE1->(dbSetOrder(nOrdSE1))
				SE1->(dbGoto(nRegSE1))
				nVlLiqTit := SE1->E1_VALOR - nTAbat		// Valor do titulo - Abatimentos
				aDtMov	:=	{}
				aDtMov	:= {'','','','','',Dtoc(SE5->E5_DATA)}

				aAdd(aTitulos,{SE5->E5_PREFIXO,;
					SE5->E5_NUMERO,;
					SE5->E5_PARCELA,;
					SE5->E5_TIPO,;
					SE5->E5_LOJA,;
					DtoC(SE5->E5_DATA),;
					Substr(SE5->E5_DOCUMEN,1,nTamTit),;
					SE5->E5_SEQ,;
					Transform(nVlLiqTit,"@E 9999,999,999.99"),;
					Transform(SE5->E5_VLMOED2,"@E 9999,999,999.99"),;
					Iif(Fa330VldDt(aDtMov,nOpc),.T.,.F.),;
	 				    SE1->E1_FILIAL,;
	 				    SE5->E5_FILIAL})
				aAdd(aRegistros, SE5->(Recno()))
				SE5->(dbSkip())
			Enddo
			(cAliasCmp)->(dbSkip())
		Enddo

  		(cAliasCmp)->(DbCloseArea())

  		IF lF330ExComp
			lF330Exclui := (ExecBlock( "F330EXCOMP", .F., .F.,{aTitulos,aRegistros,nOpc}))
			If lF330Exclui = .F.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Recupera a Integridade dos dados           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea( "SE1" )
				dbSetOrder( 1 )
				dbSelectArea( "SE5" )
				dbSetOrder( 1 )
				dbGoTo( nReg )
				DeleteObject(oOk)
				DeleteObject(oNo)
				FA330aUnlock()
				Return
			Endif
		Endif

		Begin Transaction
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			PcoIniLan("000016")

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Volta o valor aos RAs/NCCs	³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SE5")
			dbSetOrder( 2 )
			nRegSE1 := SE1->(Recno())
			nValorBaix := 0
			nValBaix2 := 0
			nValCtb	:= 0
			lPadrao := VerPadrao(cPadrao)
			If lPadrao
				lFirst := .T.
			EndIf
			
			For nLaco := 1 to Len(aRegistros)
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Para saber se o titulo foi selecionado para estorno eh  |
				//³ necessario analisar o titulo no vetor aTitulosTMP pois a|
				//| flag do vetor aTitulos foi refeita e somente o vetor    |
				//| aTitulosTMP possui a flag informada pelo operador na    |
				//| interface grafica.(Projeto MPE)-Correcao Estorno Parcial|
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nPosTit := aScan(aTitulosTMP,{ |x| Alltrim(x[7]) + Alltrim(x[8]) ==  Alltrim(aTitulos[nLaco,1]+aTitulos[nLaco,2]+aTitulos[nLaco,3]) + Alltrim(aTitulos[nLaco,8]) .and. x[1]+x[2]+x[3] == aTitulos[nLaco,7] .AND. x[13] == aTitulos[nLaco,13]})
				If nPosTit > 0
					lMarcado :=  ( aTitulosTMP[nPosTit,11] .And. aTitulos[nLaco,11] )
				Endif

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Caso o titulo esteja selecionado para compensa‡„o...    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( lMarcado )
					lMarcado := .F.

					//Metricas - Gravação do cancelamento - Registros
					nGravados += 1

					//So monta o cabecalho do LP se acha pelo menos um egistro marcado 										 ³
					If lFirst
						nHdlPrv := HeadProva( cLote,;
											"FINA330",;
											Substr( cUsuario, 7, 6 ),;
											@cArquivo )

						VALOR := 0
						lFirst:= .F.
					EndIf

					//Posiciono na baixa do titulo de partida do cancelamento
					dbSelectArea("SE5")
					dbGoTo(aRegistros[nLaco])
					cDocumento	:= SubStr(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)
					cSeq		:= SE5->E5_SEQ
					
					//Array usado para integração TIN
					If !lCredito 
						If nRecNf == 0 //grava no array as informações da NF
							nRecNf := SE1->( Recno() )
							cSE1Orig := SE1->E1_ORIGEM
							aAdd( aBxInteg, { SE5->E5_SEQ, SE5->( Recno() ), nRecNf, cSE1Orig } )
						Else
							aAdd( aBxInteg, { SE5->E5_SEQ, SE5->( Recno() ), nRecNf, cSE1Orig } )
						EndIf
					EndIf
					
					If lLjOrigem .Or. Empty(SE5->E5_FORNADT)	//executada por alguma rotina do SIGALOJA/FRT
						cCliAdt		:= Iif(Empty(SE5->E5_FORNADT) ,SE5->E5_CLIFOR,SE5->E5_FORNADT)
						cLojAdt		:= Iif(Empty(SE5->E5_LOJAADT), SE5->E5_LOJA, SE5->E5_LOJAADT)
					Else
						cCliAdt		:= SE5->E5_FORNADT
						cLojAdt		:= SE5->E5_LOJAADT
					EndIf
					//Acrescimos e Decrescimos do titulo principal
					If SE5->E5_VLJUROS > 0 .And. SE1->E1_ACRESC > 0
						nTitAcres	+= Round(NoRound(xMoeda(SE5->E5_VLJUROS,1,nMoeda,SE5->E5_DATA,3,,Fa330TxMd(nMoeda,SE5->E5_TXMOEDA,.T.)),3),2)
					Endif
					If SE5->E5_VLDESCO > 0 .And. SE1->E1_DECRESC > 0
						nTitDecre	+= Round(NoRound(xMoeda(SE5->E5_VLDESCO,1,nMoeda,SE5->E5_DATA,3,,Fa330TxMd(nMoeda,SE5->E5_TXMOEDA,.T.)),3),2)
					Endif
					
					//Desconto Financeiro do titulo principal
					If l330DESC
						lDESC := ExecBlock("F330DESC",.F.,.F.)
						If SE5->E5_VLDESCO > 0 .And. lDESC
							nDescP := IIf(SE1->E1_DESCFIN > 0 .And. SE1->E1_VENCREA-SE5->E5_DATA >= SE1->E1_DIADESC .and. SE1->E1_DESCONT != 0,SE1->E1_VALOR * (SE1->E1_DESCFIN/100),0)
						EndIf
					EndIf
					
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Localiza o t¡tulo RA/NCC correspondente			 ³
					//³ Para cancelar a baixa									 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Inicializa a chave de pesquisa com  ³
					//³ a filial padrÆo. Caso seja utilizada³
					//³ compensa‡Æo em outras filiais, ir   ³
					//³ utilizar-se do campo E5_FILORIG.    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ										
					cChaveSe1 := xFilial("SE1")+SubStr( SE5->E5_DOCUMEN ,1,nTamTit+nTamTip )					
					If !Empty(SE5->E5_FILORIG) .And. ( !Empty( cFilFwSE1 ) .OR. !Empty( xFilial("SE1") ) )
						aDadosX := GetInfSE5(SE5->E5_DOCUMEN)						
						If (cTipoTit != aDadosX[4] .And. aDadosX[4] $ MV_CRNEG+"/"+MVRECANT) .OR. (cTipoTit $ MV_CRNEG+"/"+MVRECANT)
							cFilCred := FaPesqBx2(SE5->E5_FILIAL,aDadosX[1],aDadosX[2],aDadosX[3],cCliAdt,cLojAdt,aDadosX[4],SE5->E5_DATA,SE5->E5_SEQ,"R",SE5->E5_DOCUMEN,cTipoDc,SE5->E5_IDORIG)
						Else
							cFilCred := FaPesqBx2(SE5->E5_FILIAL,aDadosX[1],aDadosX[2],aDadosX[3],SE5->E5_CLIFOR,aDadosX[5],aDadosX[4],SE5->E5_DATA,SE5->E5_SEQ,"R",SE5->E5_DOCUMEN,cTipoDc)
						EndIf						
						If !Empty( cFilFwSE1 )
							cChaveSe1 := cFilCred+SubStr( SE5->E5_DOCUMEN ,1,nTamTit+nTamTip )
						Else
							cFilOld := cFilAnt
							cFilAnt := cFilCred
							cFilCred := xFilial("SE1")
							cChaveSe1 := cFilCred+SubStr( SE5->E5_DOCUMEN ,1,nTamTit+nTamTip )
							cFilAnt := cFilOld
						EndIf
					EndIf					
					
					aDoctosSE5 := {}
					dbSelectArea("SE1")
					dbSetOrder(1)
					SE1->(dbSeek(cChaveSe1))
					nRecE1Dest := SE1->(Recno())
					lAchou := .F.
					
					//Motor de retenções
					If __lMotRet
						//Verifica as configurações de impostos pelo motor de retenção
						F330VldImp()		
						
						lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
						lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
						lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
					EndIf
					
					// Localiza titulo referente ao cliente correto
					While !Eof() .And. Left(&(IndexKey()), Len(cChaveSe1)) == cChaveSe1
						// Encontrou o titulo do cliente
						If !Empty(cCliAdt) .and. mv_par02 == 1
							If (cCliAdt == SE1->E1_CLIENTE .And. ;
									cLojAdt == SE1->E1_LOJA)
								lAchou := .T.
								Exit
							EndIf
						Else
							lAchou := .T.
							Exit
						Endif
						DbSkip()
					Enddo

					// Se encontrou o titulo referente ao cliente correto, desfaz a compensacao
					If lAchou
						lUsaAbat := usaAbat(nReg)
						nSaldoBx := SE1->E1_SALDO
						cAdiantamento := Substr(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)
						cLojaCmp      := If( Empty(Substr(SE5->E5_DOCUMEN,nTamTit+nTamTip+1,nTamLoj)),;
													SE5->E5_LOJA,Substr(SE5->E5_DOCUMEN,nTamTit+nTamTip+1,nTamLoj))

						lAtuSldImp := !(VMd2ImpRA((lRaRtImp.Or.lRaRtImpMR), cTipoTit, SE1->E1_TIPO, nMoeda, SE1->E1_MOEDA, lIrPjBxCr, lPccBxCR))

						If ( !lRartImp .Or. ( __lIrfMR .And. !lRaRtImpMR) ) .And. !lCredito .And. ( lUsaAbat .Or. lBq10925 ) .And. lIrPjBxCr 
							nIrrfPac += SE5->E5_VRETIRF
						EndIf

						RecLock("SE1", .F.)
						//----------------------------------------------------------------
						// a Verificacao da moeda ‚ feita para que caso o RA tenha moeda
						// diferente do titulo principal, volte o valor correto ao saldo.
						//----------------------------------------------------------------
						nSe5Rec := SE5->( RECNO() )

						If ( !lRartImp .Or. ( __lPccMR .And. !lRaRtImpMR) )  .And. !lCredito .And. ( lUsaAbat .Or. lBq10925 ) .And. lPccBaixa
							nValPcc := 0
							nValPcc := SE5->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
						Endif
						
						cIdOrig := SE5->E5_IDORIG
						//Posiciono no título compensado (NF -> RA ou RA -> NF )
						SE5->( dbSetOrder(7) ) //E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ
						SE5->(dbGoto(aTitulosTmp[nPosTit][16]))
						
						If lCredito //Grava no array as informações da NF
							aAdd( aBxInteg, { SE5->E5_SEQ, SE5->( Recno() ), SE1->( Recno() ), SE1->E1_ORIGEM } )
						EndIf

						//Motor de retenções - Exclui os títulos de impostos para o título principal, selecionado na browse
						If __lMotRet
							__nImpEst	:= FinRetBxMR("R", SE5->E5_IDORIG)
							aAreaFK7	:= FK7->(GetArea())
							FMRDelImp( "FK1", SE5->E5_IDORIG, 3 )
							RestArea(aAreaFK7)
						EndIf
			
						//Desconto Financeiro do titulo principal
						nDescD := 0
						If l330DESC
							lDESC := ExecBlock("F330DESC",.F.,.F.)
							If SE5->E5_VLDESCO > 0 .And. lDESC
								nDescD := IIf(SE1->E1_DESCFIN > 0 .And. SE1->E1_VENCREA-SE5->E5_DATA >= SE1->E1_DIADESC .and. SE1->E1_DESCONT != 0,SE1->E1_VALOR * (SE1->E1_DESCFIN/100),0)
							EndIf
						EndIf

						VALOR2 := 0
						VALOR3 := 0
						VALOR4 := 0
						VALOR5 := 0
						VALOR6 := 0
						VALOR7 := 0
						VALOR8 := 0
						VARIACAO := 0
						
						If cPaisLoc == "BRA"
							//Se o cancelamento da compensacao NAO partiu do Titulo de Credito
							If !lCredito
								lIsNcc := SE5->E5_TIPO $ MV_CRNEG
							Else
								// Desfaz comissoes calculadas para adiantamentos ou notas de credito
								If (MV_PAR06 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MV_CRNEG) .Or.;
									(MV_PAR13 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MVRECANT)
									aadd(aBaixas,{SE5->E5_MOTBX,SE5->E5_SEQ,SE5->(Recno())})
								EndIf
							EndIf

							//Cancelamento partiu de um adiantamento
							If lImpComp .and. lIsNcc .and. lPccBaixa
								nRecnoSE1 := IIF(!lCredito, nRecnoSE1,SE1->(RECNO()))
								//Acerto valor dos impostos - Tecnofibras
								F330ActImp(nRecnoSE1,SE5->E5_VALOR,0,0,.F.,lCredito,0)
							EndIf

							//-------------------------------------------------------------
							//ATUALIZO O SALDO DO TITULO COMPENSADO (aTitulos)				
							//-------------------------------------------------------------		
							RecLock("SE1", .F.)

							// Caso o titulo esteja totalmente baixado recupera os impostos para o saldo.
							nTotAbat 	:= 0
							cFilOld 	:= cFilAnt
							If lCredito .and. SE1->E1_SALDO == 0
								If lSE1Exclusivo
									cFilAnt := SE1->E1_FILIAL
								Else
									If lGestao
										nRecSM0 := SM0->(Recno())
										If "E" $ FWSM0Layout() .Or. "U" $ FWSM0Layout()  //se tem empresa ou unidade de negocio no layout
											If ! ( Alltrim( SE1->E1_FILIAL ) $ cFilAnt )
												SM0->( dbGoTop() )
												While SM0->(!Eof() .and. M0_CODIGO == cEmpAnt .and. IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ) <= "ZZZZZZ")
													cFilAnt := IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL )
													If Alltrim(SE1->E1_FILIAL) $ cFilAnt
														Exit
													EndIf
													SM0->( dbSkip() )
												EndDo
											EndIf
										EndIf
										SM0->( dbGoto(nRecSM0) )
									EndIf
								EndIf
								//Tratamento de retorno do Pis Cofins - Tecnofibras
								If (( !lRaRtImp .Or. ( __lPccMR .And. !lRaRtImpMR) ) .Or. lIsNCC)
									nTotAbat := SumAbatRec(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_MOEDA,"V",dBaixa)
									If !lIrPjBxCr  .and. nTotAbat > 0 .and. SE5->E5_VRETIRF > 0
										nTotAbat -= SE5->E5_VRETIRF
									Endif
								Else
									nTotAbat := 0
								Endif
							EndIf
							cFilAnt := cFilOld
							If !__lIrfMR .And. (lIrPjBxCr .and. SE1->E1_SALDO == 0) .or. SE5->E5_VRETIRF > 0
								nTotAbat+= SE5->E5_VRETIRF
							EndIf
							
							If lPccBaixa .And. !__lPccMR
								If !(SE5->E5_TIPO $ MVRECANT +'|'+ MV_CRNEG) .AND. ( lRaRtImp .Or. lRaRtImpMR .Or. lBQ10925 .or. lCredito )
									nTotAbat += SE5->E5_VRETPIS + SE5->E5_VRETCOF + SE5->E5_VRETCSL
								Endif
							EndIf
							If ( lRaRtImp .Or. lRaRtImpMR ) .And. lCredito
								nTotAbat+= SE5->E5_PRISS + SE5->E5_PRINSS
							EndIf
							If ( lRartimp .Or. lRaRtImpMR ) .And. lPccBxCr .And. !__lPccMR
								nVlNewPis += SE5->E5_VRETPIS
								nVlNewCof += SE5->E5_VRETCOF
								nVlNewCsl += SE5->E5_VRETCSL
								nVlNewIrf += SE5->E5_VRETIRF
							EndIf
							
							nAcresc := Round(NoRound(xMoeda(SE5->E5_VLACRES,1,SE1->E1_MOEDA,SE5->E5_DATA,3,,Fa330TxMd(SE1->E1_MOEDA,SE5->E5_TXMOEDA,.T.)),3),2)
							nDecres := Round(NoRound(xMoeda(SE5->E5_VLDECRE,1,SE1->E1_MOEDA,SE5->E5_DATA,3,,Fa330TxMd(SE1->E1_MOEDA,SE5->E5_TXMOEDA,.T.)),3),2)
							nTotAbat := If(SE1->E1_MOEDA > 1 .And. nTotAbat > 0, xMoeda(nTotAbat,1,SE1->E1_MOEDA,SE5->E5_DATA,__nCasDec,0,SE5->E5_TXMOEDA), nTotAbat)
							
							If (SE1->E1_MOEDA > 1 .AND. nMoeda == 1) .or. (SE1->E1_MOEDA == 1 .AND. nMoeda > 1) .or. (SE1->E1_MOEDA > 1 .AND. nMoeda > 1) // nMoeda > 1
								SE1->E1_SALDO += SE5->E5_VALOR + nTotAbat
							ElseIf ( ( !lRartImp .Or. ( (__lIrfMR .Or. __lPccMR ) .And. !lRaRtImpMR ) ) .and. (!lUsaAbat .and. !lCredito ))
								SE1->E1_SALDO += SE5->E5_VALOR
							ElseIf SE1->E1_VALOR <> SE1->E1_SALDO
								SE1->E1_SALDO += SE5->E5_VALOR + nTotAbat
							EndIf
							IF __lMotRet  .and. __nImpEst > 0
								SE1->E1_SALDO += __nImpEst
							EndIf
	
							If !lCredito .and. lUsaAbat .and. lImpComp
								SE1->E1_SALDO += nValPcc + nIrrfPac
							EndiF

							nTotAbat := 0
							//Verifica se o titulo já possui impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
							nPisFin061	:=	0
							nCofFin061	:=	0
							nCslFin061	:=	0
							nIrfFin061	:=	0
							nVAbat		:=  0
							nRegSE5	:=	SE5->(Recno())
							nOrdSE5	:=	SE5->(IndexOrd())		
						
							If SE1->E1_TIPO <> MVRECANT .AND. SE1->E1_TIPO <> MV_CRNEG .And. (lPccBxCr .Or. lIrPjBxCr)
								dbSelectArea("SE5")
								SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
								If SE5->(DBSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
									While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
										SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
									
										If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
											If Alltrim(SE5->E5_MOTBX) == "PCC"
												nPisFin061	+= SE5->E5_VRETPIS
												nCofFin061	+=	SE5->E5_VRETCOF
												nCslFin061	+= SE5->E5_VRETCSL
											ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
												nIrfFin061	+= SE5->E5_VRETIRF
											EndIf
										EndIf
										SE5->(DbSkip())		
									EndDo
								EndIf
							EndIf
							SE5->(Dbgoto(nRegSE5))
							SE5->(Dbsetorder(nOrdSE5))
							
							//Cancelamento partiu de um adiantamento
							If lCredito
								If cPaisLoc == "BRA"
									nVlNf	:= SE1->E1_VALOR
									If lIrPjBxCr 
										If EMPTY(SE5->E5_PRETIRF)
											VALOR2 := SE5->E5_VRETIRF
											nVlIrrf	+= SE5->E5_VRETIRF
										EndIf							
									EndIf
									/////////////////////
									//PCC Baixa CR          
									//Retorna para o saldo do titulo o valor retido do PCC
									If lPccBxCr .and. !lIsNcc
										If SE5->E5_PRETPIS $ ' |7'
											If !( !lUsaAbat .and. ( !lRartImp .And. !lRaRtImpMR ) ) .and. !lBQ10925 .And. lAtuSldImp
												SE1->E1_SALDO += SE5->E5_VRETPIS
											EndIf
											VALOR3 := SE5->E5_VRETPIS
											nVlPis	+= SE5->E5_VRETPIS
										EndIf
										If SE5->E5_PRETCOF $ ' |7'
											If !( !lUsaAbat .and. ( !lRartImp .And. !lRaRtImpMR )) .and. !lBQ10925 .And. lAtuSldImp
												SE1->E1_SALDO += SE5->E5_VRETCOF
											EndIf
											VALOR4 := SE5->E5_VRETCOF
											nVlCof	+= SE5->E5_VRETCOF
										EndIf
										If SE5->E5_PRETCSL $ ' |7'
											If !( !lUsaAbat .and. ( !lRartImp .And. !lRaRtImpMR ) )  .and. !lBQ10925 .And. lAtuSldImp
												SE1->E1_SALDO += SE5->E5_VRETCSL
											EndIf
											VALOR5 := SE5->E5_VRETCSL
											nVlCsll	+= SE5->E5_VRETCSL
										EndIf				
										VALOR6 := SE1->E1_INSS
										//cancelar SFQ
										//Escluir titulos PCC
										If !__lPccMR
											FaDelSFQCR()
										EndIf
									Endif
								
									//Atualiza o status do titulo no SERASA
									If nSaldoBx == 0
										cChaveTit := SE1->E1_FILIAL + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
										cChaveFK7 := FINGRVFK7("SE1",cChaveTit,SE1->E1_FILORIG)
										F770BxRen("3","",cChaveFK7)
									EndIf
								EndIf

							EndIf
							//QUESTAO DE ARREDONDAMENTO
							If ABS(SE1->E1_VALOR - xMoeda(SE5->E5_VLMOED2,nMoeda,SE1->E1_MOEDA,SE5->E5_DATA,3) - (nTotAbat + nDecres - nAcresc + nDescD)) > 0  ;
							.and. ABS(SE1->E1_VALOR - xMoeda(SE5->E5_VLMOED2,nMoeda,SE1->E1_MOEDA,SE5->E5_DATA,3) - (nTotAbat + nDecres - nAcresc + nDescD)) <= 0.0099999
								SE1->E1_SALDO := SE1->E1_VALOR
							EndIf
							SE1->E1_VALLIQ:= 0
							If (nPisFin061+nCofFin061+nCslFin061+nIrfFin061)> 0 
								//O Pcc neste momento já foi subtraido do valor do saldo faltando somente o IR.
								If !lUsaAbat
									SE1->E1_SALDO	-= (nIrfFin061+nPisFin061+nCofFin061+nCslFin061)
								EndIf
								SE1->E1_VALLIQ	+= nPisFin061+nCofFin061+nCslFin061+nIrfFin061		
							EndIf																																		
						Else
							If (MV_PAR06 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MV_CRNEG) .Or.;
								(MV_PAR13 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MVRECANT)
								aadd(aBaixas,{{SE5->E5_MOTBX,SE5->E5_SEQ,SE5->(Recno())}})
							EndIf
							RecLock("SE1", .F.)
							nDecs := MsDecimais(nMoeda)
							nTxMoeda := Round(SE5->E5_VALOR/SE5->E5_VLMOED2,2)
							If  Empty(SE5->E5_MOEDA)
								SE1->E1_SALDO  += Round(xMoeda(SE5->E5_VLMOED2,nMoeda,SE1->E1_MOEDA,SE5->E5_DATA,nDecs+1,nTxMoeda),nDecs)
								SE1->E1_VALLIQ -= Round(xMoeda(SE5->E5_VLMOED2,nMoeda,1,SE5->E5_DATA,nDecs1+1,nTxMoeda),nDecs1)
							Else
								SE1->E1_VALLIQ:= 0
								If (SE1->E1_MOEDA > 1 .AND. nMoeda == 1) .or. (SE1->E1_MOEDA == 1 .AND. nMoeda > 1) .or. (SE1->E1_MOEDA > 1 .AND. nMoeda > 1) // nMoeda > 1
									SE1->E1_SALDO += SE5->E5_VLMOED2
								Else
									SE1->E1_SALDO += SE5->E5_VALOR
								EndIf
							EndIf
							If  nMoeda <> SE1->E1_MOEDA   .And.  Abs(SE1->E1_SALDO - SE1->E1_VALOR) <= 0.01
								SE1->E1_SALDO := SE1->E1_VALOR
							EndIf
						EndIf
						
						SE5->( dbGoto(nSE5Rec) )
						If SUBSTR(SE5->E5_LA,1,1) == "S"
							If SE5->E5_MOEDA == '01'
								nValCtb += SE5->E5_VALOR 
							Else
								nValCtb += SE5->E5_VLMOED2
							EndIf
						EndIf
						nValorBaix	+= SE5->E5_VALOR + nTitDecre - nTitAcres + nDescD
						lAcrDecr 	:= Iif(nTitAcres <> 0 .or. nTitDecre <> 0,.T.,.F.) 						
						nValBaix2	+= SE5->E5_VALOR + Round(NoRound(xMoeda(SE5->E5_VLDESCO - SE5->E5_VLJUROS,1,nMoeda,SE5->E5_DATA,3,,Fa330TxMd(nMoeda,SE5->E5_VLMOED2/SE5->E5_VALOR,lAcrDecr)),3),2)
						nValHist	:= SE5->E5_VALOR

						If lImpComp .and. lPccBaixa .And. !__lPccMR
							If !lCredito .and. SE1->E1_SALDO == 0
								nValorBaix	+= SE5->E5_VRETPIS + SE5->E5_VRETCOF + SE5->E5_VRETCSL
								nValBaix2	+= SE5->E5_VRETPIS + SE5->E5_VRETCOF + SE5->E5_VRETCSL
							EndIf
						EndIf

						If lIrPjBxCr .and. SE5->E5_VRETIRF > 0
							If !(SE5->E5_TIPO $ MVRECANT +'|'+ MV_CRNEG).AND. (lUsaAbat .or. ( lRaRtImp .Or. lRaRtImpMR ) )
								nVlrAbat	+= Iif( __lIrfMR .And. __nIrfCaMR > 0, __nIrfCaMR, SE5->E5_VRETIRF )
								nVAbat :=  SE5->E5_VRETIRF
							EndIf
						EndIf
						If lPccBaixa
							If !(SE5->E5_TIPO $ MVRECANT +'|'+ MV_CRNEG) .AND. ( lRaRtImp .Or. lRaRtImpMR .Or. lBq10925 .or. !lCredito) .And. !__lPccMR
								nVlrAbat	+= SE5->E5_VRETPIS + SE5->E5_VRETCOF + SE5->E5_VRETCSL
								nVAbat 		+= SE5->E5_VRETPIS + SE5->E5_VRETCOF + SE5->E5_VRETCSL	
								If lCredito
									SE1->E1_SALDO += nVAbat
								Endif
								If ( !lRartImp .And. !lRaRtImpMR ) .and. lUsaAbat .and. SE1->E1_SALDO <> SE1->E1_VALOR
									If !lIrPjBxCr .and. nTabat > 0 .and. (SE1->E1_SALDO - SE5->E5_VALOR - nVlrAbat - nTabat == 0 .or. SE1->E1_SALDO + nTabat == SE1->E1_VALOR)
										SE1->E1_SALDO += nTabat
									EndIf
								EndIf
							ElseIf ( !lRartImp .And. !lRaRtImpMR ) .and. lUsaAbat .and. SE1->E1_SALDO <> SE1->E1_VALOR .and. !__lIrfMR
								SE1->E1_SALDO += nVAbat
								If !lIrPjBxCr .and. nTabat > 0 .and. (SE1->E1_SALDO - SE5->E5_VALOR - nVlrAbat - nTabat == 0 .or. SE1->E1_SALDO + nTabat == SE1->E1_VALOR)
									SE1->E1_SALDO += nTabat
								EndIf
							EndIf

							If ( lRaRtImp .Or. lRaRtImpMR )
								nVlrAbat	+= SE5->E5_PRISS + SE5->E5_PRINSS
							EndIf
						
							If cPaisLoc == "EUA" .And. SE1->(ColumnPos("E1_SLPLAID")) > 0
								SE1->E1_SLPLAID := SE1->E1_SALDO
							EndIf
						Endif
						SE1->(MsUnlock())
						
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Grava lançamento no PCO ref titulo compensado apos canc. da compensacao   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						PCODetLan("000016","02","FINA330") //alteracao do titulo compensado

						nSe1Rec := SE1->(RECNO())
						//Se o cancelamento partiu do titulo de adiantamento, posiciono no titulo marcado na grid (titulos normais)
						If lCredito .AND. nRecE1Dest > 0
							SE1->(dbGoTo(nRecE1Dest))
						Endif
						cKeyAbt := SE1->(E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA)
						cFilSe1 := SE1->E1_FILIAL
						cTipo	:= SE1->E1_TIPO
						//Atualiza o status de viagem
						If (ALLTRIM(SE1->E1_ORIGEM) == "FINA677")
							FINATURES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),.F.,SE1->E1_ORIGEM,"R")
						EndIf
						aAreaSE5 := SE5->(GetArea())
						aAreaSE1 := SE1->(GetArea())
						
						//Cancelamento da baixa dos abatimentos do titulo principal
						//quando cancelamento partiu do titulo de adiantamento
						If lCredito   //Se nao for titulo de adiantamento
							dbSelectArea("__SE1")
							__SE1->(dbSetOrder(2))
							__SE1->(dbSeek(cFilSE1+cKeyAbt))
							If lTitpaiSE1
								__SE1->(DbSetOrder(nOrdTitPai))
								If	DbSeek(cChaveSe1+__SE1->E1_CLIENTE+__SE1->E1_LOJA)
									bWhile := {|| !Eof() .And. E1_FILIAL + Trim(E1_TITPAI) == Trim(cChaveSe1+__SE1->E1_CLIENTE+__SE1->E1_LOJA) }
								Else
									__SE1->(dbSetOrder(2))
									__SE1->(dbSeek(cFilSe1+cKeyAbt))
								Endif
							EndIf

							While Eval(bWhile)
								If lTitpaiSE1
									If !Empty(E1_TITPAI) .and.  (  trim(E1_TITPAI)!=trim(cAdiantamento+__SE1->E1_CLIENTE+__SE1->E1_LOJA) )
										DbSkip()
										Loop
									EndIf
								EndIf

								lPccComp := .T. //Verificando IR,INSS e ISS gerados na emissao ou PCC gerado na compensacao.
								If lPccBaixa
									aAreaSE5 	:= SE5->(GetArea())
									aAreaSE1	:= SE1->(GetArea())

									cChaveSE5	:= xFilial("SE5") + If(SE1->E1_TIPO $ "COF/CSL/PIS","CP",Subst(SE1->E1_TITPAI,14,2)) + Subst(SE1->E1_TITPAI,1,3) + Subst(SE1->E1_TITPAI,4,9) +Subst(SE1->E1_TITPAI,13,1)
									If SE5->(dbSeek(cChaveSE5))
										If SE1->E1_TIPO $ "IR-/IN-/IS-" .AND. Alltrim(SE1->E1_SEQBX) <> Alltrim(SE5->E5_SEQ)
											lPccComp := .F.
										ElseIf SE1->E1_TIPO $ "COF/CSL/PIS" .AND. lPccBaixa //PCC gerado na compensacao.
											lBxCanc	:= TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T.,SE5->E5_FILIAL)
											If (lBxCanc .AND. Alltrim(SE1->E1_SEQBX) == Alltrim(SE5->E5_SEQ)) //.OR. (!lBxCanc .AND. Alltrim(SE1->E1_SEQBX) <> Alltrim(SE5->E5_SEQ))
												lPccComp := .F.
											EndIf
										EndIf
									EndIf

									SE5->(RestArea(aAreaSE5))
									SE1->(RestArea(aAreaSE1))
								EndIf

								If (((__SE1->E1_TIPO $ "IR-|IN-|IS-|CF-|CS-|PI-" .AND. lPccBaixa .AND. lPccComp) .OR. __SE1->E1_TIPO $ MVABATIM ) .And. Alltrim(__SE1->E1_CLIENTE+__SE1->E1_LOJA) == Alltrim(SE1->E1_CLIENTE+SE1->E1_LOJA))
									//Tornar o abatimento aberto novamente somente caso o abatimento tenha sido baixado pela rotina
									nVlrAbat += E1_VALOR
									RecLock("__SE1")								
									Replace E1_SALDO	With E1_VALOR		
									Replace E1_BAIXA	With CtoD("  /  /  ")
									Replace E1_STATUS	With "A"
									Replace E1_VALLIQ  With 0
									MsUnlock()
								EndIf
								dbSkip()
							EndDo
							__SE1->(dbSetOrder(1))
						EndIf
						dbSelectArea("SE1")
						dbGoto(nSE1Rec)
						
						If !__lIrfMR
							// Trecho irá deletar o titulo do IRF quando selecionada os titulos de adianamento para estorno					
							If lIrPjBxCr .And. !lRartImp
								FaDelSFQCR()
							Endif
						EndIf
						
						dbSelectArea("SE1")
						SE1->(dbSeek(cChaveSe1))

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Deleta a baixa do SE5	-  RA		³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						dbSelectArea("SE5")
						dbSetOrder(2)

						SE5->(dbGoto(aTitulosTmp[nPosTit][16]))
						While ( !Eof() .And. SE5->E5_FILIAL == aTitulos[nLaco][13] .And. ;
								cDocumento ==	SE5->E5_PREFIXO+SE5->E5_NUMERO+;
								SE5->E5_PARCELA+SE5->E5_TIPO )
							If (  cSeq == SE5->E5_SEQ .And. cLojaCmp == SE1->E1_LOJA .And. ;
									SE1->E1_CLIENTE == SE5->E5_CLIFOR .and. ;
									Substr(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)==cPrefixo+cNum+cParcela+cTipoTit ) .And. ;
									SE5->E5_TIPODOC <> "VA"

								AADD(aDoctosSE5,{SE5->E5_DOCUMEN,SE1->E1_CLIENTE,SE1->E1_LOJA,SE5->E5_SEQ})

								//Atualiza dados do Cliente - Adiantamento
								dbSelectArea("SA1")
								DbSetOrder(1)
								If dbSeek(xFilial("SA1")+SE5->E5_CLIFOR+SE5->E5_LOJA)
									If lGrvSa1	
										RecLock("SA1")
										nSaldoComp:=Round(xMoeda(SE5->E5_VLMOED2,nMoeda,SE1->E1_MOEDA,SE5->E5_DATA,nDecs+1,Fa330TxMd(nMoeda,nTxMoeda),Fa330TxMd(SE1->E1_MOEDA,nTxMoeda)),nDecs)
										If SE1->E1_TIPO $ MVRECANT +"/"+ MV_CRNEG
											AtuSalDup("-",nSaldoComp,nMoeda,SE1->E1_TIPO,,SE1->E1_EMISSAO)
										Else
											AtuSalDup("+",nSaldoComp,nMoeda,SE1->E1_TIPO,,SE1->E1_EMISSAO)
										EndIf
									EndIf
								EndIf

								nRecE1Dest := SE1->(Recno())
								nRecE5Dest := SE5->(Recno())

								RecLock("SE1")
								nAcresc := Round(NoRound(xMoeda(SE5->E5_VLACRES,1,SE1->E1_MOEDA,SE5->E5_DATA,3,,Fa330TxMd(SE1->E1_MOEDA,SE5->E5_TXMOEDA,.T.)),3),2)
								nDecres := Round(NoRound(xMoeda(SE5->E5_VLDECRE,1,SE1->E1_MOEDA,SE5->E5_DATA,3,,Fa330TxMd(SE1->E1_MOEDA,SE5->E5_TXMOEDA,.T.)),3),2)

								SE1->E1_STATUS:= IIF(SE1->E1_STATUS != "R",Iif(SE1->E1_SALDO > 0.01,"A","B"),"R")

								//E1_SALDO somou E5_VALOR no começo da rotina, desconsiderando acrescimo e decrescimo.
								If nAcresc > nSaldoComp //Caso o Acrescimo da NF seja maior que o valor compensado "RA", E1_SALDO do RA deve subtrair o valor compensado.
									SE1->E1_SALDO -= nSaldoComp
								Else
									SE1->E1_SALDO -= nAcresc
								Endif

								SE1->E1_SDDECRE += nDecres
								If SE1->E1_SDDECRE > SE1->E1_DECRESC
									SE1->E1_SDDECRE	:= SE1->E1_DECRESC
								EndIf

								SE1->E1_SALDO += nDecres
								
								If nAcresc > nSaldoComp //Caso o Acrescimo da NF seja maior que o valor compensado "RA", E1_SDACRES do RA deve voltar ao seu valor original.
									SE1->E1_SDACRES += nSaldoComp
								Else 
									SE1->E1_SDACRES += nAcresc
								Endif
								
								// Desconto Financeiro
								If nDescD > 0 .and. (nDecres - nDescD) != 0
									SE1->E1_SALDO += nDescD
									SE1->E1_DESCONT -= nDescD
								Endif

								//Atualiza a variavel de acordo com o titulo posicionado
								lIrPjBxCr := FIrPjBxCr()

								If !__lIrfMR .And. lIrPjBxCr
									FaDelSFQCR()
								EndIf
								If cPaisLoc == "EUA" .And. SE1->(ColumnPos("E1_SLPLAID")) > 0
									SE1->E1_SLPLAID := SE1->E1_SALDO
								EndIf
								MsUnlock()

								// Desfaz comissoes calculadas para adiantamentos ou notas de credito
								If (MV_PAR06 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MV_CRNEG) .Or.;
									(MV_PAR13 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MVRECANT) 
									If cPaisLoc<>"BRA"
										aadd(aBaixas,{{SE5->E5_MOTBX,SE5->E5_SEQ,SE5->(Recno())}})
									Else
										aadd(aBaixas,{SE5->E5_MOTBX,SE5->E5_SEQ,SE5->(Recno())})
									EndIf
								EndIf
								
								VARIACAO := SE5->E5_VLCORRE
								
								If nOpc == 4  //Exclusao
									SE5->(DbSelectarea("SE5"))
									Fin330ExCM(SE5->E5_FILIAL, SE5->E5_SEQ)
								EndIf

								//Caso o registro posicionado do estorno seja de filial diferente da compensação, ajusto para correta gravação. 
								If cFilAnt # cFilCred .and. cFilAnt # SE5->E5_FILIAL
									lEstFdif := .T.
									If cPaisLoc == 'BRA' .And. cFilCred # SE5->E5_FILIAL
										cFilCred	:= SE5->E5_FILIAL
									EndIf
								EndIf
								
								//VA: Ajusta a SE5 e saldo do título para o movimento do VA
								If __l330Va
									FA330VACAN(SE5->E5_FILIAL, SE5->E5_IDORIG, SE1->(RECNO()), nOpc)
								EndIf

								//Ajusta o saldo do título caso fique maior que o valor.
								If (SE1->E1_VALOR+SE1->E1_ACRESC-SE1->E1_DECRESC) < (SE1->E1_SALDO+SE1->E1_SDACRES-SE1->E1_SDDECRE)
									RecLock("SE1", .F.)
									SE1->E1_SALDO := SE1->E1_VALOR
									SE1->(MsUnlock())
								EndIf

								//QUESTAO DE ARREDONDAMENTO
								nValAux :=  ABS(SE1->E1_VALOR - xMoeda(SE5->E5_VLMOED2,nMoeda,SE1->E1_MOEDA,SE5->E5_DATA,3) - (nTotAbat + nDecres - nAcresc + nDescD))
								If  ( nValAux <= 0.0099999 .And. nValAux > 0 ) .AND. !lLjOrigem
									If (nPisFin061+nCofFin061+nCslFin061+nIrfFin061) == 0
										SE1->E1_SALDO := SE1->E1_VALOR
									EndIf
								EndIf

								//QUESTÃO DE TOLERÂNCIA - MV_TOLERPG
								If nValAux <= If(nMoeda > 1 .And. nMVToler == 0, nToler, nMVToler)
									SE1->E1_SALDO := SE1->E1_VALOR
								Endif

								// So limpa a data da baixa se nao houver mais nenhum movimento para este titulo
								If NoRound( SE1->E1_VALOR, 2 ) == NoRound( SE1->E1_SALDO, 2 )
									RecLock("SE1", .F.)	
									SE1->E1_BAIXA := CtoD("  /  /  ")
									SE1->E1_CORREC := 0
									SE1->(MsUnlock())
								EndIf
								
								//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
								If AllTrim( SE5->E5_TABORI ) == "FK1"
									If lEstFdif
										cFilOld := cFilAnt
										cFilAnt := cFilCred
									EndIf
									dbSelectArea( "FK1" )
									FK1->( DbSetOrder( 1 ) )
									If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
										oModelBA := FWLoadModel("FINM010")
										oModelBA:SetOperation( 4 ) //Alteração
										oModelBA:Activate()
										oSubFKA := oModelBA:GetModel( "FKADETAIL" )
										oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
										oModelBA:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
										
										//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK1
										//E5_OPERACAO 2 = Altera E5_TIPODOC da SE5 para 'ES' e gera estorno na FK1
										//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK1
										
										//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
										cCamposE5 := '{'
										
										If !Empty( SE5->( FieldPos( "E5_MSEXP" ) ) ) 
											cCamposE5 += ",{'E5_MSEXP', ''}"
										EndIf
										
										If MV_PAR09 == 1 .and. !lUsaFlag
											oModelBA:SetValue( "MASTER", "E5_LA", "S " )
										EndIf

										If UsaSeqCor()
											cCamposE5 += ",{'E5_NODIA', ''}"
										EndIf
										cCamposE5 += "}"
											
										oModelBA:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1
										oModelBA:SetValue( "MASTER", "E5_OPERACAO",If(nOpc == 4, 3, 2) ) //E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK1
										oModelBA:SetValue( "MASTER", "HISTMOV" , STR0055 )
			
										//Integração PFS
										nSE5PFSTMP := SE5->(Recno())
										
										If oModelBA:VldData()
											oModelBA:CommitData()
											SE5->(dbGoto(oModelBA:GetValue( "MASTER", "E5_RECNO" )))
											
											If nOpc <> 4
												If MV_PAR09 == 1 .and. lUsaFlag
													aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->(RECNO()), 0, 0, 0} )
												EndIf

												If UsaSeqCor()
													AAdd(aDiario,{"SE5",SE5->(RECNO()),SE5->E5_DIACTB,"E5_NODIA","E5_DIACTB"})
												EndIf
											Endif
										Else
											lRet := .F.
											cLog := cValToChar(oModelBA:GetErrorMessage()[4]) + ' - '
											cLog += cValToChar(oModelBA:GetErrorMessage()[5]) + ' - '
											cLog += cValToChar(oModelBA:GetErrorMessage()[6])
											Help( ,,"M330VALID",,cLog, 1, 0 )
										EndIf	
										
										oModelBA:DeActivate()
										oModelBA:Destroy()
										oModelBA:= nil
									EndIf
									If lEstFdif
										cFilAnt := cFilOld
									EndIf
									
								EndIf
								
								// Grava lançamento no PCO ref canc. baixa do titulo compensado (Mov.Bancaria-SE5)
								PCODetLan("000016","06","FINA330")
							EndIf
							dbSelectArea("SE5")
							dbSkip()
						EndDo

						DbSelectArea("SE1")
						SE1->(DbSetOrder(1))
						
						If SE1->E1_TIPO $ MVRECANT
							aAlt :={}
							aadd( aAlt,{ STR0085,'','','',STR0086 +  Alltrim(Transform(nValHist,cPicE5Val)) })
							cFilOld := cFilAnt
							cFilAnt := SE1->E1_FILORIG
							FinaCONC(aAlt)
							cFilAnt	:= cFilOld
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Restaura o t¡tulo abatimento qdo houver    ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						cFilPai 	:= SE1->E1_FILIAL
						cChvCrPai 	:= TRIM(cFilPai + SE1->(E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA) )
						cCliLjPai 	:= SE1->E1_CLIENTE+SE1->E1_LOJA
						If SE1->(dbSeek(xFilial("SE1")+cPrefixo+cNum+cParcela,.F.))
							//Atualiza o status do titulo no SERASA
							If cPaisLoc == "BRA"
								If !lCredito
									If SE1->E1_SALDO == 0
										cChaveTit := SE1->E1_FILIAL + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
										cChaveFK7 := FINGRVFK7("SE1",cChaveTit,SE1->E1_FILORIG)
										F770BxRen("3","",cChaveFK7)
									EndIf
								EndIf
							EndIf
							
							cCliLoja 	:= Iif( lCredito, __SE1->E1_CLIENTE + __SE1->E1_LOJA, cCliente + cLoja )
							cChavePai 	:= Iif( lCredito, cChvCrPai, cChavePai )						
							aAlt 		:= {}
							aadd( aAlt,{ STR0085,'','','',STR0086 +  Alltrim(Transform(nValHist,cPicE5Val)) })
							///chamada da Função que cria o Histórico de Cobrança
							cFilOld := cFilAnt
							cFilAnt := SE1->E1_FILORIG
							FinaCONC(aAlt)
							cFilAnt	:= cFilOld
							If lTitpaiSE1
								If (nOrdTitPai:= OrdTitpai()) > 0
									SE1->(DbSetOrder(nOrdTitPai))
									If	SE1->( DbSeek( IIf(lCredito,cChavePai,FWxFilial("SE1") + cChavePai ) ))
										If lCredito 
											bWhile2 := {|| !Eof() .And. E1_FILIAL + Trim(E1_TITPAI) == cChavePai }
										Else 
											bWhile2 := {|| !Eof() .And. E1_FILIAL + Trim(E1_TITPAI) == FWxFilial("SE1") + cChavePai }
										EndIf
									Else
										SE1->(DbSetOrder(1))
									EndIf
								EndIf
							Else
								cFilSE1 := xFilial("SE1")
							EndIf
							
							DbSelectArea("SE1")
							While Eval(bWhile2)

								If lTitpaiSE1
									If !Empty(E1_TITPAI) .And. IF(lCredito, (cFilPai + E1_TITPAI != Trim(cChavePai)), (FWxFilial("SE1") + Trim(E1_TITPAI) != E1_FILIAL + Trim(cChavePai)))
										SE1->(DbSkip())
										Loop
									EndIf
								EndIf

								lPccComp := .T. //Verificando IR,INSS e ISS gerados na emissao ou PCC gerado na compensacao.
								If lPccBaixa
									aAreaSE5 	:= SE5->(GetArea())
									aAreaSE1	:=	SE1->(GetArea())

									cChaveSE5	:= xFilial("SE5") + If(SE1->E1_TIPO $ "COF/CSL/PIS","CP",Subst(SE1->E1_TITPAI,14,2)) + Subst(SE1->E1_TITPAI,1,3) + Subst(SE1->E1_TITPAI,4,9) +Subst(SE1->E1_TITPAI,13,1)
									If SE5->(dbSeek(cChaveSE5))
										If SE1->E1_TIPO $ "IR-/IN-/IS-" .AND. Alltrim(SE1->E1_SEQBX) <> Alltrim(SE5->E5_SEQ)
											lPccComp := .F.
										ElseIf SE1->E1_TIPO $ "COF/CSL/PIS" .AND. lPccBaixa //PCC gerado na compensacao.
											lBxCanc	:= TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T.,SE5->E5_FILIAL,,,SE5->E5_FILORIG)
											If (lBxCanc .AND. Alltrim(SE1->E1_SEQBX) == Alltrim(SE5->E5_SEQ))
												lPccComp := .F.
											EndIf
										EndIf
									EndIf

									SE5->(RestArea(aAreaSE5))
									SE1->(RestArea(aAreaSE1))
								EndIf
								
								If (((SE1->E1_TIPO $ "COF/CSL/PIS/IR-/IN-/IS-/CF-/CS-/PI-/" .AND. lPccBaixa .AND. lPccComp) .OR. SE1->E1_TIPO $ MVABATIM ) .And.iIf(lCredito , Alltrim(cCliLjPai),AllTrim( cCliLoja )) == Alltrim(SE1->E1_CLIENTE+SE1->E1_LOJA))
									//Tornar o abatimento aberto novamente somente caso o abatimento tenha sido baixado pela rotina
									If cSeq <> SE1->E1_SEQBX .and. !Empty(SE1->E1_SEQBX)
										SE1->(dbSkip())
										Loop
									EndIf

									//Caso os impostos do PCC e IR sejam gerados na baixa devo exclui-los.
									If SE1->E1_TIPO $ ("COF/CSL/PIS") .AND. lPccBxCr
										If lExistFJU .AND. Alltrim(SE1->E1_ORIGEM) <> "FINA061"
											FingrvEx("R")
										EndIf	
										
										If !__lPccMR .AND. Alltrim(SE1->E1_ORIGEM) <> "FINA061"
											RecLock("SE1")
											dbDelete()
											MsUnlock()
										EndIf
									ElseIf SE1->E1_TIPO $ MVABATIM
										If !lCredito
											nVlrAbat += SE1->E1_VALOR
										Endif
										RecLock("SE1")
										SE1->E1_SALDO  := SE1->E1_VALOR
										SE1->E1_VALLIQ := 0
										SE1->E1_BAIXA  := CtoD(" / / ")
										SE1->E1_CORREC := 0
										SE1->E1_STATUS := "A"
										MsUnlock()
									EndIf
								EndIf
								dbSelectArea("SE1")
								dbSkip()
							EndDo
						EndIf
					Else
						Exit
					EndIf

					If __l330VA .And. !lCredito .And. nValVA <> 0 

						nRecAntSe5:= SE5->(recno())
						nRecAntSe1:= SE1->(recno())

						SE5->(dbGoto(nSE5Rec))
						SE1->(dbGoto(nRegSE1))

					Else
						dbSelectArea("SE1")
						dbGoto(nRecE1Dest)

						dbSelectArea("SE5")
						dbGoTo(nRecE5Dest)
					EndIf

					If lPadrao .and. SUBSTR(SE5->E5_LA,1,1) == "S"  .and.  ( mv_par09 == 1 .Or. nOpc==4 ) // Contabilizar a exclusão mesmo que esteja para não contabilizar, pois não haverá registros para posicionar no modo off-line
						nTotal += DetProva( nHdlPrv,;
											cPadrao,;
											"FINA330",;
											cLote,;
											/*nLinha*/,;
											/*lExecuta*/,;
											/*cCriterio*/,;
											/*lRateio*/,;
											/*cChaveBusca*/,;
											/*aCT5*/,;
											/*lPosiciona*/,;
											@aFlagCTB,;
											/*aTabRecOri*/,;
											/*aDadosProva*/ )
					EndIf

					If __l330VA .And. !lCredito .And. nValVA <> 0 
						SE5->(dbGoto(nRecAntSe5))
						SE1->(dbGoto(nRecAntSe1))
					EndIf
					
					//Integração PFS
					If AllTrim(SE1->E1_TIPO) == "RA"
						nSE1PFSRA := SE1->(Recno())
						nSE1PFS   := nRegSE1
					Else
						nSE1PFSRA := nRegSE1
						nSE1PFS   := SE1->(Recno())
					EndIf

					dbSelectArea("SE1")
					dbGoto(nSE1Rec)

					dbSelectArea("SE5")
					dbGoTo(aRegistros[nLaco])
					
					nCMEst += SE5->E5_VLCORRE
					
					// Desfaz comissoes calculadas para adiantamentos ou notas de credito
					If (MV_PAR06 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MV_CRNEG) .Or.;
						(MV_PAR13 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MVRECANT)
						If cPaisLoc<>"BRA"
							aadd(aBaixas,{{SE5->E5_MOTBX,SE5->E5_SEQ,SE5->(Recno())}})
						Else
							aadd(aBaixas,{SE5->E5_MOTBX,SE5->E5_SEQ,SE5->(Recno())})
						EndIf
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³  Apaga registro da movimenta‡„o  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					DbSelectArea("SE5")

					If E5_TIPO == "NF "
						AADD(aDoctosSE5,{SE5->E5_DOCUMEN,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ})
					EndIf

					If cPaisLoc == "BRA" .And. lIrPjBxCr .And. !lCredito
						If EMPTY(SE5->E5_PRETIRF) .And. !__lIrfMR
							nIrrf += SE5->E5_VRETIRF
						EndIf
					EndIf
					/////////////////////
					//PCC Baixa CR
					//Obtem valor dos impostos PCC retidos na compensacao
					If cPaisLoc == "BRA" .and. lPccBxCr .and. !lIsNcc .and. !lCredito .And. !__lPccMR
						If SE5->E5_PRETPIS $ ' |7'
							nPis += SE5->E5_VRETPIS
						EndIf
						If SE5->E5_PRETCOF $ ' |7'
							nCofins += SE5->E5_VRETCOF
						EndIf
						If SE5->E5_PRETCSL $ ' |7'
							nCsll += SE5->E5_VRETCSL
						EndIf
						nInss += SE1->E1_INSS
						nCtbInss += SE1->E1_INSS
						//Excluir relacionamentos SFP
						//Exclui titulos gerados
						If !__lPccMR
							FaDelSFQCR()
						EndIf
					EndIf

					If nOpc == 4  //Exclusao 
						Fin330ExCM(SE5->E5_FILIAL, SE5->E5_SEQ)
					EndIf								
							
					//Motor de retenções - Exclui os títulos de impostos gerados para os títulos compensados
					If __lMotRet .And. !lIntPFS
						__nImpEst := FinRetBxMR("R", SE5->E5_IDORIG)
						FMRDelImp( "FK1", SE5->E5_IDORIG, 3 )
					EndIf
					
					//VA: Ajusta a SE5 e saldo do título para o movimento do VA
					If __l330Va
						FA330VACAN(SE5->E5_FILIAL, SE5->E5_IDORIG, nReg, nOpc)
					EndIf
					//Ajusta o saldo do título caso fique maior que o valor.
					If (SE1->E1_VALOR+SE1->E1_ACRESC-SE1->E1_DECRESC) < (SE1->E1_SALDO+SE1->E1_SDACRES-SE1->E1_SDDECRE)
						RecLock("SE1", .F.)
						SE1->E1_SALDO := SE1->E1_VALOR
						SE1->(MsUnlock())
					EndIf
					//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
					
					If AllTrim( SE5->E5_TABORI ) == "FK1"
						aAreaAnt := GetArea()
						If lEstFdif
							cFilOld := cFilAnt
							cFilAnt := cFilCred
						EndIf
						dbSelectArea( "FK1" )
						FK1->( DbSetOrder( 1 ) )
						If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
							oModelCP := FWLoadModel("FINM010")
							oModelCP:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
							oModelCP:Activate()
							//Posiciona a FKA com base no IDORIG da SE5 posicionada
							oSubFKA := oModelCP:GetModel( "FKADETAIL" )
							oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } }) 

							oModelCP:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
							//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK1
							//E5_OPERACAO 2 = Altera E5_TIPODOC da SE5 para 'ES' e gera estorno na FK1
							//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK1
							If nOpc <> 4
								//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
								cCamposE5 := '{'  
								
								If !Empty( SE5->( FieldPos( "E5_MSEXP" ) ) ) 
									cCamposE5 += ",{'E5_MSEXP', ''}"
								EndIf
															
								If MV_PAR09 == 1 .and. !lUsaFlag
									oModelCP:SetValue( "MASTER", "E5_LA", "S " )
								EndIf

								If UsaSeqCor()
									cCamposE5 += ",{'E5_NODIA', ''}"
								EndIf          
								cCamposE5 += '}'
								
							EndIf
							oModelCP:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1
							oModelCP:SetValue( "MASTER", "E5_OPERACAO",If(nOpc == 4, 3, 2) ) //E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK1
							oModelCP:SetValue( "MASTER", "HISTMOV" , STR0055 )

							//Integração PFS
							If AllTrim(SE5->E5_TIPO) == "RA"
								nSE5PFSRA := SE5->(Recno())
								nSE5PFS   := nSE5PFSTMP
							Else
								nSE5PFSRA := nSE5PFSTMP
								nSE5PFS   := SE5->(Recno())
							EndIf
							
							If oModelCP:VldData()
								oModelCP:CommitData()
							
								// Integração PFS
								Aadd(aMovPFS, {nSE1PFS, nSE5PFS, nSE1PFSRA}) // SE1 e SE5 do título que está sendo estornado.
								Aadd(aMovPFS, {nSE1PFSRA, nSE5PFSRA, 0})
								
								SE5->(dbGoto(oModelCP:GetValue( "MASTER", "E5_RECNO" )))

								If nOpc <> 4
									If MV_PAR09 == 1 .and. lUsaFlag                          
										aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->(RECNO()) , 0, 0, 0} )
									EndIf
			
									If UsaSeqCor()
										AAdd(aDiario,{"SE5",SE5->(RECNO()),SE5->E5_DIACTB,"E5_NODIA","E5_DIACTB"})
									EndIf

									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ PONTO DE ENTRADA NA ALTERACAO DO HISTORICO NA SE5 NO ESTORNO         ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									If lF330AE5E
									ExecBlock("F330AE5E",.F.,.F.)
									EndIf

								EndIf
							Else
								lRet := .F.
								cLog := cValToChar(oModelCP:GetErrorMessage()[4]) + ' - '
								cLog += cValToChar(oModelCP:GetErrorMessage()[5]) + ' - '
								cLog += cValToChar(oModelCP:GetErrorMessage()[6])
								Help( ,,"M330VALID",,cLog, 1, 0 )
							EndIf

							oModelCP:DeActivate()
							oModelCP:Destroy()
							oModelCP := nil
						
						EndIf
						If lEstFdif
							cFilAnt := cFilOld
						EndIf
						RestArea(aAreaAnt)
									
					EndIf
					
					// Grava lançamento no PCO ref canc. baixa do titulo compensado (Mov.Bancaria-SE5)
					If lPCO01605
						//Lançamento no PCO ref canc. baixa do titulo principal
						PCODetLan("000016", "05", "FINA330")
					Else
						//Lançamento no PCO ref canc. baixa do titulo compensado
						PCODetLan("000016", "06", "FINA330")											
					EndIf				

					// PONTO DE ENTRADA DE VALIDACAO DE EXCLUSAO/ESTORNO
					If lF330VEEX
						ExecBlock("F330VEEX",.F.,.F.,{nOpc})
					EndIf
					lCancelou := .T.
				EndIf

			Next nLaco				
					
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica se foi gerado comiss„o e caso tenha sido, exclui     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cPaisLoc<>"BRA"
				AeVal(aBaixas,{|x|Fa440DeleB(x,.F.,.F.,"FINA330")})
			Else
				cFilAux := cFilAnt
				Fa440DeleB(aBaixas,.F.,.F.,"FINA330")
				cFilAnt := cFilAux
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ PONTO DE ENTRADA NA EXCLUSAO ANTES DA CONTABILIZACAO         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lFA330EAC
				ExecBlock("FA330EAC",.F.,.F.)
			EndIf
			
			nRegFK1	:=	FK1->(Recno())
			
			If lPadrao .and. lCancelou .and. !lFirst .and. nValCtb > 0
				VALOR  := nValCtb
				VALOR2 := nIrrf
				VALOR3 := nPis
				VALOR4 := nCofins
				VALOR5 := nCsll
				VALOR6 := nInss
				VALOR6 := nCtbInss
				VALOR7 := nTitDecre
				VALOR8 := nTitAcres
				VARIACAO := nCMEst 
				REGVALOR := nRegSE1

				dbSelectArea("SE1")
				SE1->(dbGoBottom())
				SE1->(dbSkip())
				SE5->(dbGoBottom())
				SE5->(dbSkip())
				dbSelectArea("FK1")
				FK1->(dbGoBottom())
				FK1->(dbSkip())
				
				nTotal += DetProva( nHdlPrv,;
									cPadrao,;
									"FINA330",;
									cLote,;
									/*nLinha*/,;
									/*lExecuta*/,;
									/*cCriterio*/,;
									/*lRateio*/,;
									/*cChaveBusca*/,;
									/*aCT5*/,;
									/*lPosiciona*/,;
									@aFlagCTB,;
									/*aTabRecOri*/,;
									/*aDadosProva*/ )

				RodaProva(  nHdlPrv,;
							nTotal)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Envia para Lan‡amento Cont bil                      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				lDigita := IIF( mv_par07 == 1,.t., .f. )
				cA100Incl( cArquivo,;
						nHdlPrv,;
						3,;
						cLote,;
						lDigita,;
						.F.,;
						/*cOnLine*/,;
						/*dData*/,;
						/*dReproc*/,;
						@aFlagCTB,;
						/*aDadosProva*/,;
						aDiario )
				aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

				VALOR  := 0
				VALOR2 := 0
				VALOR3 := 0
				VALOR4 := 0
				VALOR5 := 0
				VALOR6 := 0
				VALOR6 := 0
				VALOR7 := 0
				VALOR8 := 0
				VARIACAO := 0 
				REGVALOR := 0

				SE1->(dbSelectArea("SE1"))
				SE1->(dbGoTo(nRegSE1))
				SE5->(dbSelectArea("SE5"))
				SE5->(dbGoTo(nRegSE5))
				FK1->(dbSelectArea("FK1"))
				FK1->(dbGoTo(nRegFK1))
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Volta valor do titulo.		 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nValorBaix # 0 .or. nTitDecre # 0 .or. nTitAcres # 0 .or. nDescP # 0
				SE5->(dbGoTo(nRegSE5))
				SE1->(dbGoTo(nRegSE1))
				//Verifica se o titulo já possui impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
				nPisFin061	:=	0
				nCofFin061	:=	0
				nCslFin061	:=	0
				nIrfFin061	:=	0
				nRegSE5	:=	SE5->(Recno())
				nOrdSE5	:=	SE5->(IndexOrd())		
						
				If SE1->E1_TIPO <> MVRECANT .AND. SE1->E1_TIPO <> MV_CRNEG .And. (lPccBxCr .Or. lIrPjBxCr)
					aAreaSE5 	:= SE5->(GetArea())
					dbSelectArea("SE5")
					SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
					If SE5->(DBSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
						While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
								SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
									
							If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
								If Alltrim(SE5->E5_MOTBX) == "PCC"
								nPisFin061	+= SE5->E5_VRETPIS
								nCofFin061	+= SE5->E5_VRETCOF
								nCslFin061	+= SE5->E5_VRETCSL
								ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
								nIrfFin061	+= SE5->E5_VRETIRF
								EndIf
							EndIf
							SE5->(DbSkip())		
						EndDo
					EndIf
					RestArea(aAreaSE5)
				EndIf						

				If cPaisLoc == "RUS"
					DBSelectArea("FR3")
					DBSetOrder(1)
					If FR3->(MsSeek(xFilial("FR3") + IIf(cTipoDoc == "CP", "R", "P") + aTitulosTMP[1][2] + AllTrim(aTitulosTMP[1][1]), .T.))
						Reclock("FR3")
						DBDelete()
						MsUnLock()
					EndIf
				EndIf

				//--------------------------------------------------------
				//ATUALIZA SALDO DO TITULO DE PARTIDA DO CANCELAMENTO
				//--------------------------------------------------------
				SE5->(DBGoto(aRegistros[1]))

				Reclock("SE1")

				//Converte os impostos para a moeda do título para recalcular o saldo corretamente
				nVlrAbat := If(SE1->E1_MOEDA > 1 .And. nVlrAbat > 0, xMoeda(nVlrAbat, 1, SE1->E1_MOEDA, SE5->E5_DATA, __nCasDec, 0, SE5->E5_TXMOEDA), nVlrAbat)

				If !lCredito .And. SE1->E1_SALDO == 0
					SE1->E1_SALDO += Iif((lUsaAbat .Or. ( lRaRtImp .Or. lRaRtImpMR ) ),nVlrAbat,0) 
					If !( ( !lRartImp .And. !lRaRtImpMR ) .And. lUsaAbat .and. !lBq10925)
						lAtusalImp := .T.
					EndIf
				EndIf

				If !lCredito .and. SE1->E1_SALDO == 0
					nTotAbat := SumAbatRec(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_MOEDA,"V",dBaixa)
				Endif

				If SE1->E1_VALOR <> SE1->E1_SALDO				
					SE1->E1_SALDO  += nValBaix2 + __nImpEst
				EndIf

				SE1->E1_VALLIQ := 0

				SE1->E1_SDDECRE := Iif (nTitDecre > 0, nTitDecre - nDescP, 0) 
				If nTitAcres > nSaldoComp //Caso o Acrescimo da NF seja maior que o valor compensado "RA", E1_SDACRES da NF deve voltar com o saldo que foi compensado ao invés de voltar com o valor do Acréscimo.
					SE1->E1_SDACRES += Iif (nTitAcres > 0, nSaldoComp - nDescP, 0)
				Else
					SE1->E1_SDACRES += Iif (nTitAcres > 0, nTitAcres - nDescP, 0)
				Endif 			
				SE1->E1_DESCONT -= nDescP
			
				If STR(SE1->(E1_VALOR - E1_SALDO),17,2) == STR(nTotAbat,17,2) .And. ( ( !lRaRtImp .And. !lRaRtImpMR ) .Or. (!lCredito .And. (lRaRtImp .And. !lRaRtImpMR ) ) )
					SE1->E1_SALDO += nTotAbat
				EndIf

				If !lRartImp .And. !lRaRtImpMR
                    //Caso o cancelamento tenha partido de um titulo de crédito, o imposto somente deverá ser restaurado quando:
                    //- Imposto + saldo = Valor do titulo
                    //- Houve retenção no titulo de adiantamento
                    nSaldoTit := 0 
                    
                    If SE5->(E5_VRETPIS + E5_VRETCOF + E5_VRETCSL + E5_VRETIRF) > 0
                        nSaldoTit += IIf((nValBaix2+nVlPis+nVlCof+nVlCsll == nVlNf), (nVlPis+nVlCof+nVlCsll), 0)
                        nSaldoTit += IIf(nSaldoTit == 0 .And. ((nValBaix2+nVlPis+nVlCof+nVlCsll+nVlrAbat) == nVlNf), (nVlPis+nVlCof+nVlCsll+nVlrAbat), 0)
                        nSaldoTit += IIf(nSaldoTit == 0 .And. lUsaAbat .And. lBq10925 .And. !SE1->E1_TIPO $ MVRECANT+"|"+MV_CRNEG, (nVlPis+nVlCof+nVlCsll), 0)
                        SE1->E1_SALDO += nSaldoTit
                    Endif
                    
                    If lUsaAbat .And. SE1->E1_SALDO + nVlPis + nVlCof + nVlCsll + nVlIrrf == SE1->E1_VALOR
                        SE1->E1_SALDO += (nVlPis + nVlCof + nVlCsll + nVlIrrf)
                    EndIf
                Endif

				If __lMotRet  .and. __nImpEst > 0
					SE1->E1_SALDO += __nImpEst
				EndIf 	

				/////////////////////
				//PCC Baixa CR
				//Retorna para o saldo do titulo o valor retido do PCC
				If lPccBaixa .and. !lIsNcc .and. !lCredito .AND. !lAtusalImp .and. lUsaAbat .And. !lRartImp .and. !lBq10925
					If nPis + nCofins + nCsll > 0
						SE1->E1_SALDO += nPis+nCofins+nCsll
					ElseIf nVlrAbat > 0
						SE1->E1_SALDO += nVlrAbat
					EndIf
				EndIf
				
				If (lIrPjBxCr .or. lPccBaixa) .AND. ( lRartImp .Or. lRaRtImpMR  .Or. lBQ10925 ) .and. !lCredito .AND. !lAtusalImp
					
					If lPccBaixa .And. nPis+nCofins+nCsll > 0
						SE1->E1_SALDO += If(SE1->E1_MOEDA > 1 .And. nPis > 0, Round(xMoeda(nPis, nMoeda, SE1->E1_MOEDA, SE5->E5_DATA, __nCasDec, 0, SE5->E5_TXMOEDA), nDecs), nPis)
						SE1->E1_SALDO += If(SE1->E1_MOEDA > 1 .And. nCofins > 0, Round(xMoeda(nCofins, nMoeda, SE1->E1_MOEDA, SE5->E5_DATA, __nCasDec, 0, SE5->E5_TXMOEDA), nDecs), nCofins)
						SE1->E1_SALDO += If(SE1->E1_MOEDA > 1 .And. nCsll > 0, Round(xMoeda(nCsll, nMoeda, SE1->E1_MOEDA, SE5->E5_DATA, __nCasDec, 0, SE5->E5_TXMOEDA), nDecs), nCsll)
					EndIf	

					If lIrPjBxCr .And. nIrrf > 0
						SE1->E1_SALDO += If(SE1->E1_MOEDA > 1 .And. nIrrf > 0, Round(xMoeda(nIrrf, nMoeda, SE1->E1_MOEDA, SE5->E5_DATA, __nCasDec, 0, SE5->E5_TXMOEDA), nDecs), nIrrf)
					EndIf
			
					If nPis+nCofins+nCsll+nIrrf > 0 .And. nPis+nCofins+nCsll+nIrrf <> nVlrAbat // gravo apenas a diferença
						SE1->E1_SALDO += (nVlrAbat  - (nPis+nCofins+nCsll+nIrrf)) 
					EndIF

				ElseIf !lIrPjBxCr .and. lPccBaixa .and. ( !lRartImp .And. !lRaRtImpMR ) .and. lBQ10925 .and. lCredito .and. !lAtusalImp .and. SE1->E1_SALDO < SE1->E1_VALOR
					If SE1->E1_TIPO == MVRECANT .And. SE1->E1_VALOR < SE1->E1_SALDO+nVlrAbat+RABxAnt()
						SE1->E1_SALDO := SE1->E1_SALDO
					Else
						SE1->E1_SALDO += nVlrAbat
					EndIf
				EndIf

				If (nPisFin061+nCofFin061+nCslFin061+nIrfFin061)> 0 
					If !lUsaAbat
						SE1->E1_SALDO	-= nPisFin061+nCofFin061+nCslFin061+nIrfFin061		
					Endif  	
					SE1->E1_VALLIQ	+= nPisFin061+nCofFin061+nCslFin061+nIrfFin061		
				EndIf																				

				If !lAtusalImp
					SE1->E1_SALDO += nIrrfPac
				EndIf

				SE1->E1_STATUS:= IIF(SE1->E1_STATUS != "R",Iif(SE1->E1_SALDO > 0.01,"A","B"),"R")
				If SE1->E1_SALDO > SE1->E1_VALOR		// garantir que o saldo nao seja maior
					Replace E1_SALDO With E1_VALOR
				EndIf
				If NoRound( SE1->E1_VALOR, 2 ) == NoRound( SE1->E1_SALDO, 2 )
					SE1->E1_CORREC 	:= 0	
					SE1->E1_BAIXA 	:= CtoD("  /  /  ")
				EndIf

				If cPaisLoc == "EUA" .And. SE1->(ColumnPos("E1_SLPLAID")) > 0
					SE1->E1_SLPLAID := SE1->E1_SALDO
				EndIf

				MsUnlock()
				If (ALLTRIM(SE1->E1_ORIGEM) == "FINA677")
					FINATURES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),.F.,SE1->E1_ORIGEM,"R")
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava lançamento no PCO ref titulo principal apos a cancelamento   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				PCODetLan("000016","01","FINA330")

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza Saldo do Cliente /  DP/NF  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aArea:=GetArea()
				dbSelectArea("SA1")
				DbSetOrder(1)
				If dbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA)
					If lGrvSa1
						RecLock("SA1")
						nSaldoComp:=Round(xMoeda(nValBaix2,nMoeda,SE1->E1_MOEDA,SE5->E5_DATA,nDecs+1,Fa330TxMd(nMoeda,nTxMoeda),Fa330TxMd(SE1->E1_MOEDA,nTxMoeda)),nDecs)
						If lCredito
							AtuSalDup("-",nSaldoComp,nMoeda,SE1->E1_TIPO,,SE1->E1_EMISSAO)
						Else
							AtuSalDup("+",nSaldoComp,nMoeda,SE1->E1_TIPO,,SE1->E1_EMISSAO)
						EndIf
						MsUnlock()
					EndIf
				EndIf
				
				//Integração TIN x PROTHEUS
				If lEnvMU070 .And. Len( aBxInteg ) > 0 .And. !lEnvMU330 //Se o adapter de compensação estiver ativado para envio, então não manda a mensagem de baixa
					For nInt := 1 To Len( aBxInteg )
						If AllTrim( aBxInteg[nInt][4] ) == "FINI055"
							SE5->( dbGoTo( aBxInteg[nInt][2] ) )
							SE1->( dbGoTo( aBxInteg[nInt][3] ) )
						
							lOpcAux := ALTERA
							ALTERA := .F.
							cIntegSeq := SE5->E5_SEQ //Variável private que será utilizada no FINI070
							aRetInteg := FwIntegDef( "FINA070", , , , "FINA070" )
							ALTERA := lOpcAux
						
							//Se der erro no envio da integração, então faz rollback e apresenta mensagem em tela para o usuário
							If ValType( aRetInteg ) == "A" .And. Len( aRetInteg ) >= 2 .And. !aRetInteg[1]
								lRet := .F.
								Help( ,, "FINA330INTEGTIN",, STR0089 + AllTrim( aRetInteg[2] ), 1, 0,,,,,, {STR0088} ) //"O estorno da compensação não será concluído, pois ocorreu um erro na integração: ", "Verifique se a integração está configurada corretamente."
								DisarmTransaction()
								Exit
							Endif
							
						EndIf
					Next nInt
				EndIf
				
				RestArea( aArea )
				SE1->( dbGoTo( nRegSE1 ) )

			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ PONTO DE ENTRADA 															 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (ExistBlock( "FA330EXC" ) )
				ExecBlock("FA330EXC",.F.,.F.)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Finaliza a gravacao dos lancamentos do SIGAPCO            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			PcoFinLan("000016")
			
			// Integração SIGAPFS x SIGAFIN
			If lRet .And. FindFunction("JCancBaixa") .And. FindFunction("JurDtBxCR") .And. lIntPFS
				For nMovPFS := 1 To Len(aMovPFS)
					JCancBaixa( aMovPFS[nMovPFS][1]/*Recno SE1*/ , aMovPFS[nMovPFS][2]/*RECNO SE5*/,  JurDtBxCR(aMovPFS[nMovPFS][2])/*E5_DTDISPO*/, aMovPFS[nMovPFS][3] /*RECNO RA*/, nOpc == 5 )
				Next nMovPFS
				If __lMotRet
					__nImpEst := FinRetBxMR("R", SE5->E5_IDORIG)
					FMRDelImp( "FK1", SE5->E5_IDORIG, 3 )
				EndIf
			EndIf
		
		End Transaction
		
		//Metricas - Gravação do cancelamento - FIM
		If __lMetric .and. nGravados > 0
			nFim := Seconds() - nInicio
			nFim := nFim / nGravados

			SetFunName(__cFunMet)
			FwCustomMetrics():setAverageMetric(Alltrim(ProcName())+" - TempoGravacao", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
			SetFunName(__cFunBkp)
		Endif

		Exit
	
	EndIf
EndDo

l330Auto := .F.

dbSelectArea( "SE1" )
SE1->(dbSetOrder(nOrdFilter)) // Devolvo para a ordem selecionada pelo cliente na Browser.
dbSelectArea( "SE5" ) 
dbSetOrder( 1 )
dbGoTo( nReg )
DeleteObject(oOk)
DeleteObject(oNo)
FA330aUnlock()

Return lRetAuto

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³Fa330Marca³ Autor ³ Alice Y Yamamoto 	    ³ Data ³ 08/04/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Marca os itens a serem excluidos 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fa330Marca												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fa330Marca(nIt,aArray,nOpc)

If (aArray[nIt,11] )
	aArray[nIt,11] := .F.
Else
	If Fa330VldDt(aArray[nIt],nOpc)
		aArray[nIt,11] := .T.
	EndIf
EndIf

Return aArray

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³Fa330OK	³ Autor ³ Marcos Patricio		³ Data ³ 19/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Confirma a marcacao dos titulos para compensacao.		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fa330OK													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FA330OK(nValTot As Numeric, lAutomato As Logical, lPccBxCR As Logical) As Logical
Local lMarcado 	As Logical 
Local nX	 	As Numeric
Local lRet		As Logical 
Local aAreaSE1 	As Array 

Default nValTot		 := 0 
Default lAutomato	 := .F.
Default lPccBxCR	 := FPccBxCr()

lMarcado	:= .T.
lRet		:=	.F.
aAreaSE1	:= {}

//Quando chamada da MATA465 se nao existe nada marcado da erro
If cPaisLoc <> "BRA"
	lMarcado	:=	.F.
	For nX	:=1 	To Len(aTitulos)
		If aTitulos[nX][8]
			//Forcar a saida do FOR
			lMarcado	:=	.T.
			nX	:=	Len(aTitulos)+1
		EndIf
	Next
EndIf

If !cPaisLoc $ "EUA|RUS"
	If !FA330SIT(aTitulos)
		Return(.F.)
	EndIf
EndIf

If !lAutomato
	If lMarcado
		lRet	:=	MsgYesNo(STR0024,STR0018)
	Else
		MsgAlert(STR0040,STR0018)
		lRet	:=	.F.
	EndIf
Else 
	lRet	:=	.T.
EndIf

If lRet  // Valida se o Saldo esta de acordo com o titulo. 
	nValTot := 0
	nValor  := IIf( nValor !=0 , 0 , nValor )

	For nX:=1 to Len(aTitulos)
		If aTitulos[nX,8]
			nValtot += Fa330VTit(aTitulos[nX,7])
			If lCredito .and. lRartImp .and. lPccBxCr 
				nValTot	-= Fa330VTit(aTitulos[nX,14])
				nValTot	-= Fa330VTit(aTitulos[nX,15])
				nValTot	-= Fa330VTit(aTitulos[nX,16])
			EndIf
		EndIf
	Next nX

	If nValTot == 0
		Help(" ",1,"NOTITSEL",,"" ,1,0,,,,,,{STR0131})
		lRet :=	.F.
	EndIf

	// Verifica se o Vlr. Informado e'igual ao calculado. 
	If Str(nValtot,17,2) != Str(nValor,17,2) .and. nValor != 0 .And. nOpca == 1
		Help(" ",1,"FA330COMP")
		lRet	:=	.F.
	EndIf

	// Verifica se o Vlr. Informado e'compativel com o Saldo. 
	nValor := nValTot
	If Str(nValor,17,2) > Str(nSaldo,17,2)
		Help(, , "FA330IVAL", , STR0141, 1, 0, , , , , , {STR0142}) 
		lRet	:=	.F.
	EndIf

EndIf 

If ExistBlock("Fa330Vld") .and. lRet
	aAreaSE1 := SE1->(GetArea())
	SE1->(DbSetOrder(nIndVld))
	SE1->(DbGoTo(nRecVld))
	lRet := ExecBlock("Fa330Vld")
	RestArea(aAreaSE1)
EndIf

If UsaSeqCor()
	If !CTBvldDiario(cCodDiario,dDataBase)
		Return(.f.)
	EndIf
EndIf

Return lRet  //"Confirma marca‡„o de T¡tulos ?"###"Aten‡„o"
/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³Fa330Troca³ Autor ³ Marcos Patricio		³ Data ³ 19/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Troca o flag para marcado ou nao,aceitando valor.		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fa330Troca												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FA330Troca(nIt,aArray,oGet,lTodos,oTitulo,lMarkAll)
Local oDlg
Local nMinLim	:= 0
Local nOpca   	:= 0
Local nX       	:= 0
Local nAcresc  	:= 0
Local nY	   	:= 0
Local xy       	:= 0
Local nVezes   	:= 1
Local nOldIt   	:= nIt
Local lIrPjBxCr	:= FIrPjBxCr()
Local lPccBxCr	:= FPccBxCr()
Local nPosIr	:= 0
Local cLimite  	:= ''
Local cFilOld	:= ''
Local nValOld  	:= 0
Local nPos 	   	:= 0
LOCAL nTotAbat 	:= 0
Local aAreaSE1 	:= SE1->(GetArea())
Local nItemRA	:= 0
Local nItemOu	:= 0
Local lNcc		:= .F.
Local nVlMinImp := GetNewPar("MV_VL10925",5000)
Local nAltVal	:= 0
Local lBq10925	:= SuperGetMV("MV_BQ10925",,"2") == "1"
Local nVTit		:= 0
Local aArrAux	:= {}
Local nVlAbt	:= 0
Local lMSal		:= .F.
Local cOldVl	:= 0
Local nVlrSldPcc := 0
Local lRaRtImpMR := .F.
Local lIrfBxAux := lIrPjBxCr
Local lPccBxAux := lPccBxCr
Local aImpMRBrw := PegaVarMR()
Local nPosRec	:= 20
Local bEval		:= {|| ValType(aArray[nIt,26]) == 'C' }
Local cPicE1IRRF	:= PesqPict("SE1","E1_IRRF")
Local cPicE1PIS		:= PesqPict("SE1","E1_PIS")
Local cPicE1COF		:= PesqPict("SE1","E1_COFINS")
Local cPicE1CSL		:= PesqPict("SE1","E1_CSLL")
Local nValVa		:= 0
Local nBaseImp		:= 0
Local nVlRecAua		:= nValRec
Local nOldIr		:= 0
Local nOldBsIr		:= 0
Local nOldCalIr		:= 0
Local nVlConvPcc	:= 0
Local nParcNf		:= 0
Local nBasIRConv	:= 0
Local nVlIrConv		:= 0
Local nValImp		:= 0
Local nIrrfCon  	:= 0 
Local nTtPccCon 	:= 0 
Local nVlPccCon 	:= 0 
Local nSaldoCon 	:= 0 
Local nValorCon 	:= 0 
Local nSldConv		:= 0
Local nVlCruzCon 	:= 0 
Local nVlAltAnt  	:= 0 
Local nVlAltCmp		:= 0
Local nTotAbtCon	:= 0
Local oModelVA		:= Nil
Local lRetorno      := .F.
Local lMarca        := .T.
Local lTemImpPix    := .F.
Local nRecnoF71     := 0
Local cIdDocFK7     := ""
Local nTxMCon		:= 0
Local nPropBx		As Numeric
Local nValLimCp		As Numeric
Local lRecRaRtIm	As Logical
Local nBaseImpos    As Numeric
Local aPcc          As Array

DEFAULT lMarkAll 	:= .F.
DEFAULT lTodos  	:= .F.

//Inicializa variáveis
nValLimCp		:= 0
lRecRaRtIm		:= .F.
nBaseImpos      := 0
aPcc            := {.F.,0,0,0,{}}

If cPaisLoc == "BRA" .And. !lTodos
	If MV_PAR02 == 2
		nPosRec	:= 23
	EndIf
	SE1->( dbGoTo( aArray[nIt, nPosRec] ) )
	lNcc	:= SE1->E1_TIPO $ MV_CRNEG .Or. __lCredNCC
EndIf

//Motor de retenções
If __lMotRet
	//Verifica as configurações de impostos pelo motor de retenção
	F330VldImp()
	
	lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
	lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
	lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
EndIf

If dDataBase >= dLastPcc
	nVlMinImp	:= 0
EndIf

If MV_PAR02 == 2
	nPos := 25
    bEval := {|| ValType(aArray[nIt,29]) == 'C' }
Else
	nPos := 22
EndIf

If cPaisLoc == "BRA"
	cValor  := Fa330VTit(aTitulos[nIt,6 ])
	cSaldo  := Fa330VTit(aTitulos[nIt,nPos ])//Limite de Compensação
	cSalTit := Fa330VTit(aTitulos[nIt,6 ])
	cLimite := Fa330VTit(aTitulos[nIt,nPos]) //Limite de Compensação
	nVezes  := If(lTodos,Len(aArray),1)
	If mv_par02 == 1
		nAcresc := Fa330VTit(aTitulos[nIt,10])
		nValVa	:= Fa330VTit(aTitulos[nIt,If(__lMotRet,28,27)])
	Else
		nAcresc := Fa330VTit(aTitulos[nIt,13])
		nValVa	:= Fa330VTit(aTitulos[nIt,If(__lMotRet,31,30)])
	Endif
	If ( lPccBxCr .Or. lIRPJBxCr ) .And. ( lRaRtImp .Or. lRaRtImpMR )
		cValor  := Fa330VTit(aTitulos[nIt,Iif(MV_PAR02== 2, 25,22)])
	EndIf
Else
	cValor  := Fa330VTit(aTitulos[nIt,6 ])
	If mv_par02 == 1
		cSaldo  := Fa330VTit(aTitulos[nIt,14])
	Else
		cSaldo  := Fa330VTit(aTitulos[nIt,17])
	EndIf
	cSalTit := Fa330VTit(aTitulos[nIt,6 ])
	nVezes  := If(lTodos,Len(aArray),1)
EndIf

nValtot := 0
nVlComp := 0

For xy := 1 to Len(aTitulos)
	If aTitulos[xy,8] .And. xy <> nIt
		nVlComp += Fa330VTit(aTitulos[xy,7])
	EndIf
Next

nMinLim := Iif(nValor == 0, nSaldo, Min(nSaldo, nValor) )

cSaldo := Iif(cSaldo > (nMinLim - nVlComp), (nMinLim - nVlComp),cSaldo)
nValOld	:= cSaldo

For nY := 1 to nVezes
	nBaseImp   := 0
	lTemImpPix := .F.
	nRecnoF71  := 0		
	lMarca     := .T.
	nIt        := IIf(nVezes > 1, nY, nIt)
	nPropBx		:= 0

	If cPaisLoc == "BRA" .And. !aArray[nIt,8] .And. __lExcImpo .And. !__lCNABImp
		If lTodos
			nPosRec := IIf(MV_PAR02 == 2, 23, 20)
			SE1->(MsGoto(aArray[nIt,nPosRec]))
		EndIf
		
		If SE1->E1_SITUACA != "0"
			nRecnoF71 := F71Ativa(aArray[nIt,nPosRec])
			
			If nRecnoF71 > 0 .And. TtBxImpPix(aArray[nIt,nPosRec])
				lTemImpPix := !BorderoImp(SE1->E1_FILORIG, SE1->E1_NUMBOR, "R", SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA)
				
				If lTemImpPix
					If !__lNexbMsg
						lRetorno := IIf(l330Auto, __lMaTiPix, MsgTtBxPix(.F., lTodos, .T., @__lNexbMsg))
					EndIf
					
					If (lMarca := lRetorno)
						lTemImpPix := .F.

						If ExcluiImpo(SE1->E1_FILIAL, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, nRecnoF71)
							cIdDocFK7  := FINBuscaFK7(SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), "SE1", SE1->E1_FILORIG)						
						
							If !Empty(cIdDocFK7) .And. PIXCancel(SE1->E1_FILIAL, cIdDocFK7, .T.)
								AAdd(__aRecF71, {nRecnoF71, (SE1->E1_FILIAL+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA), SE1->E1_FILORIG})
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	
	If nVezes > 1
		If !(cPaisLoc $ "RUS|EUA")
			cValor  := Fa330VTit(aTitulos[nIt,6])
			cSaldo  := Fa330VTit(aTitulos[nIt, If( cPaisLoc == "BRA", nPos, 14 ) ])
			cLimite := Fa330VTit(aTitulos[nIt,nPos])
			If ( lPccBxCr .Or. lIRPJBxCr ) .And. ( lRaRtImp .Or. lRaRtImpMR )
				cValor  := Fa330VTit(aTitulos[nIt,22])
			EndIf
		Else
			cValor  := Fa330VTit(aTitulos[nIt, 6])
			cSaldo  := Fa330VTit(aTitulos[nIt, 14])
			cLimite := Fa330VTit(aTitulos[nIt, 14])
		EndIf
	Endif

	If lMarkAll .And. lTodos
		aArray[nIt,8] := lMarca
	Else
		aArray[nIt,8] := IIf(!lTemImpPix, !aArray[nIt,8], .F.)
	EndIf

	If ( lPccBxCr .Or. lIRPJBxCr ) .And. ( lRaRtImp .Or. lRaRtImpMR ) .And. !lNcc
		aDadosRA1[9][nIt] := aArray[nIt,8]
	Endif

	If aArray[nIt,8]
		If FA330Lock(aArray[nIt,1]+aArray[nIt,2]+aArray[nIt,3]+aArray[nIt,4],,,aArray[nIt,Iif(MV_PAR02== 2, 16,13)])
			If !lTodos
				If cPaisLoc == "BRA"
					If aArray[nIt,4] $ MV_CRNEG .And. (mv_par08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR ) )
						F330VALNCC(@aArray,nIt, cValor < cLimite, .T.)
						cSaldo  := nSaldo - nVlComp
					EndIf
					If cSaldo >= aArray[nIt,(nPos-1)]
						cLimite := Fa330VTit(aArray[nIt,nPos]) //Limite de Compensação
						cValor	:= Fa330VTit(aArray[nIt,nPos]) //Limite de Compensação
					Else
						If !lNcc .or. (lNCC .and. cValor > cSaldo)
							cLimite := cSaldo
							cValor	:= cSaldo
						EndIf
					EndIf
					If cLimite < cValor
						cValor	:= cLimite
					EndIf
					
					If __lMotRet
					
						If cPaisLoc == "BRA" .And. MV_PAR02 == 2
							nPosRec	:= 23
						EndIf
						SE1->( dbGoTo( aArray[nIt, nPosRec] ) )
						//Verifica as configurações de impostos pelo motor de retenção
						__lTCnfgMR := F330VldImp()
	
						lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
						lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
						lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
	
						//Calcula os impostos pelo motor de retenções
						If __lTCnfgMR
							F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, IIF(cSaldo == cLimite, FBaseImp(If(cSalTit > cLimite, cLimite, cSalTit)), cSaldo) , dDataBase, SE1->E1_TIPO )
							__lTCnfgMR	:= .F.
						EndIf
					EndIf

					If !lNcc
						cFilOld	:= ''
						If cFilAnt <> SE1->E1_FILORIG
							cFilOld	:= cFilAnt
							cFilAnt	:= SE1->E1_FILORIG
						EndIf
						If !__lPccMR
							If lPccBxCr
								If (!lRartimp .And. !SE1->E1_TIPO $ MVRECANT) 
									aArrAux 	:= aClone(aArray)
									nVlAbt 		:= SomaAbat(aArray[nIt][1],aArray[nIt][2],aArray[nIt][3],"R",,,SE1->E1_CLIENTE,,aArray[nIt][13])
									nVlrSldPcc  := DesTrans( aArrAux[nIt][nPos] ) 
									
									F330CalcPCC(nIt,aArrAux,@nVlrSldPcc,cValor < cLimite)
									
									If ( nVlAbt == 0 .Or. nVlAbt <> ( DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl])) )
										If lBq10925 //Pcc Bruto
											nVlConvPcc := xMoeda((DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl])),  1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
											If ( cValor + ( DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl]) ) ) > Val(Replace(Replace(aArrAux[nIt][6],".", "" ), ",", ".")) //Verifica se é maior que Saldo do titulo							
												cValor     := ( nVlrSldPcc - nVlConvPcc )
												lMSal      := .T.
												nVlrSldPcc := DesTrans( aArray[nIt][nPos] )
											EndIf  
										Else //Pcc Liquido
											nVlConvPcc := xMoeda((DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl])),  1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
											If cValor > ( nVlrSldPcc - nVlConvPcc )
												cValor     := ( nVlrSldPcc -  nVlConvPcc)
												lMSal      := .T.
												nVlrSldPcc := DesTrans( aArray[nIt][nPos] )
											EndIf
										EndIf
									EndIf
								ElseIf (lRartimp .And. SE1->E1_TIPO $ MVRECANT)
									nVlrSldPcc  := DesTrans( aArray[nIt][nPos] )
								EndIf
							EndIf	
							If lIrPjBxCr
								If !__lIrfMR
									nOldIr		:= nIrrf
									nOldBsIr	:= nIrfBase
									nOldCalIr	:= nIrfCalc
									
									If MV_PAR02 == 1
										If (!lRartimp .And. !SE1->E1_TIPO $ MVRECANT) 
											If lCredito .And. !lBq10925
												nParcNf := SE1->E1_VALOR - SE1->E1_SALDO
											Else
												nParcNf := nParciais
											EndIf

											nParcNf := xMoeda(nParcNf, IIF(!lBq10925, SE1->E1_MOEDA, nMoeda), 1, dDataBase, __nCasDec,  IIF(!lBq10925, __nTxMoedD, __nTxMoedP), 0)
											aArray[nIt,26] := Iif( Eval(bEval), Val(StrTran(Replace(aArray[nIt,26],".",""),",",".")), aArray[nIt,26])
											nBasIRConv := xMoeda(If(MV_PAR08 == 1 .And. aArray[nIt,26] > 0, aArray[nIt,26], nVlrSldPcc), nMoeda, 1, dDataBase, __nCasDec,  __nTxMoedP, 0)
											
											If VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
												nIrrf := FCaIrBxCR(IIf(nBaseImpos > 0, nBaseImpos, nBasIRConv), Nil, (SE1->E1_VALOR <> SE1->E1_SALDO .And. lRaRtImp ),,,,nParcNf)
											EndIf
										EndIf
									Else
										aArray[nIt,29] := Iif( Eval(bEval), Val(StrTran(Replace(aArray[nIt,29],".",""),",",".")), aArray[nIt,29])
										
										If VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
											nBaseImpos := IIf(nBaseImpos > 0, nBaseImpos, If(MV_PAR08 == 1 .And. aArray[nIt,29] > 0, aArray[nIt,29], nVlrSldPcc)) 
											nIrrf := FCaIrBxCR(nBaseImpos, Nil, (SE1->E1_VALOR <> SE1->E1_SALDO .And. lRaRtImp ) )
										EndIf
									EndIf
									
									If lCredito .And. !lNcc .And. !(SE1->E1_TIPO $ MVRECANT) .And. ( nIrrf != 0 .And. nOldIr > nIrrf )
										nIrrf		:= nOldIr
										nIrfBase	:= nOldBsIr 
										nIrfCalc	:= nOldCalIr
									EndIf
									
									aArray[nIt,nPosIrf] := Transf(nIrrf,cPicE1IRRF)
									aTitulos[nIt,nPosIrf]:= Transf(nIrrf,cPicE1IRRF)
									
									If (!lRartimp .And. !SE1->E1_TIPO $ MVRECANT) .And. (cValor + nPis + nCofins + nCsll + nIrrf >  Val(StrTran(Replace(aArray[nIt][6],".",""),",",".")) )
										nVlIrConv :=  xMoeda(Val(StrTran(Replace(aArray[nIt][nPosIrf],".",""),",",".")),  1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
										cValor := cValor - nVlIrConv
									EndIf
								EndIf
								aArray[nIt,nPosBIRF] := Transform(nVlrSldPcc,"@E 99,999,999.99")
							EndIf
						ElseIf MV_PAR08 == 1
							If lPccBxCr .And. ( !lRaRtImpMR ) // .And. SE1->E1_TIPO $ MVRECANT
								aArrAux 	:= aClone(aArray)
								nVlAbt 		:= SomaAbat(aArray[nIt][1],aArray[nIt][2],aArray[nIt][3],"R",,,SE1->E1_CLIENTE,,aArray[nIt][13])
								nVlrSldPcc  := DesTrans( aArrAux[nIt][nPos] ) 
								
								F330CalcPCC(nIt,aArrAux,@nVlrSldPcc,cValor < cLimite)
									
								If lBq10925 //Pcc Bruto
									If ( cValor + ( DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl]) ) ) > Val(Replace(Replace(aArrAux[nIt][6],".", "" ), ",", ".")) //Verifica se é maior que Saldo do titulo							
										cValor     := ( nVlrSldPcc - ( DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl]) ) )
										lMSal      := .T.
										nVlrSldPcc := DesTrans( aArray[nIt][nPos] )
									EndIf  
								Else //Pcc Liquido
									If cValor > ( nVlrSldPcc - ( DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl]) ) )
										cValor     := ( nVlrSldPcc - ( DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl]) ) )
										lMSal      := .T.
										nVlrSldPcc := DesTrans( aArray[nIt][nPos] )
									EndIf
								EndIf
							EndIf
						EndIf
						
						If !Empty(cFilOld)
							cFilAnt	:= cFilOld
						EndIf
						If __lMotRet
							aArray	[nIt,nPosxRet] := Transf(__nImpMR,cPicE1IRRF)
							aTitulos[nIt,nPosxRet] := Transf(__nImpMR,cPicE1IRRF)
							If __lIrfMR .And. lIrPjBxCr .And. MV_PAR08 == 1
								nIrrf := __nIrfCaMR
								aArray[nIt,nPosIrf] := Transf(nIrrf,cPicE1IRRF)
								aTitulos[nIt,nPosIrf]:= Transf(nIrrf,cPicE1IRRF)
							EndIf
							nValImp := xMoeda(nPis+nCofins+nCsll+nIrrf+__nImpMR,  1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
							If ( ( !lRartimp .And. !lRarTimpMR ) .And. !SE1->E1_TIPO $ MVRECANT) .And. (cValor + nValImp >  Val(StrTran(Replace(aArray[nIt][6],".",""),",",".")) )
								cValor := cValor - ( Val(StrTran(Replace(aArray[nIt][nPosIrf],".",""),",",".")) + __nImpMR )
							EndIf
						EndIf
					EndIf
				EndIf
				
				If !cPaisLoc $ "EUA|RUS"
					If !FA330SIT(aTitulos,Iif(MV_PAR02 == 2, aTitulos[nIt,23],aTitulos[nIt,20]))
						aTitulos[nIt][8] := .F.
						Return(aTitulos)
					EndIf
				EndIf

				If cPaisLoc == "RUS" .and. cValor > cSaldo //change amount to available balance, alterar o valor maximo para o saldo existente da operacao
					cValor := cSaldo
				Endif
				
				
				DEFINE MSDIALOG oDlg FROM  80,100 TO 183,393 TITLE STR0048 PIXEL Style DS_MODALFRAME //"Compensação CR"

				@ -3, 2 TO 22, 148 OF oDlg	PIXEL
				@ 6, 68 MSGET cValor Picture "@E 9999,999,999.99" VALID cValor <= cSaldo  .And. cValor > 0 SIZE 80, 10 OF oDlg PIXEL hasbutton
				@ 7, 9 SAY STR0014  SIZE 54, 7 OF oDlg PIXEL  //"Valor a compensar"

				If aArray[nIt,4] $ MV_CRNEG .Or. lNcc

					@ 22, 2 SAY STR0072  SIZE 140, 60 OF oDlg PIXEL //"Ao selecionar esse titulo os impostos calculados na baixa serão desconsiderados"

				EndIf

				DEFINE SBUTTON FROM 38, 094 TYPE 1 ENABLE ACTION (nOpca:=1,If((cValor <= cSaldo  .AND. cValor > 0 .AND. ;
																 If(cPaisLoc== "BRA", cValor<=cLimite, cValor <= cSalTit) .AND. ;
																 FA330Msg(.T.,If(lCredito,nValVa,__nValVa),nAcresc)),oDLg:End(),nOpca:=0)) OF oDlg // Quando a NF tenha Valor Acessório, apenas será possivel compensar caso o valor compesado seja maior ou igual a soma do Acréscimo e Valor Acessório.
				DEFINE SBUTTON FROM 38, 121 TYPE 2 ENABLE ACTION oDlg:End() OF oDlg

				ACTIVATE MSDIALOG oDlg
			Else
				nOpca := 1
			EndIf
			
			//retorna decimais do cValor caso ntxmoeda maior que tamanho padrao 
			If cValor == Fa330VTit(aTitulos[nIt,6]) .and. SE1->E1_MOEDA <> nMoeda
				If aTxMoedas[SE1->E1_MOEDA][2] <> aTxMoedas[SE1->E1_MOEDA][4]
					nTxMCon := aTxMoedas[SE1->E1_MOEDA][2]
				ElseIf __lRaTxMov .And. SE1->E1_TXMOEDA == 0 .And. !lCredito
					nTxMCon :=RecMoeda(F330MovRA(Nil, "SE1", .T.)[2], SE1->E1_MOEDA)
				Else
					nTxMCon := SE1->E1_TXMOEDA
				EndIf
				
				nValVa		:= 0
				//VA: Calcula o valor acessório
				If __l330Va
					oModelVA	:= FWLoadModel("FINA070VA")
					nValVa		:= FA330VACAL(oModelVA)
				EndIf
			
				nDesFin := 0
				nAcresTit 	:= SE1->E1_SDACRES
				nDecresTit 	:= SE1->E1_SDDECRES
				nTitAbt		:= SumAbatRec(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA, SE1->E1_MOEDA, "V" )
				nVlTit		:= Iif(mv_par02 == 1,aTitulos[nIt,21], aTitulos[nIt,24])

				cValor  := xMoeda( nVlTit - nTitAbt + nAcresTit - nDecresTit - nDesFin + nValVa, SE1->E1_MOEDA,nMoeda,,5,nTxMCon,Fa330Tx2(nMoeda,nTxMoeda))

				If cValor > cLimite
					cValor := cLimite
				Else 
					cLimite := cValor
				EndIf

				If __l330Va
					oModelVa:Destroy()
					oModelVa := NIL
				EndIf

			EndIf

			If lMSal
				cOldVl := cValor
				cValor := nVlrSldPcc
			EndIf
			
			If 	nOpca == 0
				aArray[nIt,8] := .F.
				If ( lRaRtImp .Or. lRaRtImpMR ) .And. !lNcc .And. Type("aDadosRA1[9][nIt]") == "A"
					aDadosRA1[9][nIt] := .F.
				EndIf
				If aArray[nIt,4] $ MV_CRNEG .And. (mv_par08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR ) ) .And. !Empty( cLimite )
					F330VALNCC(@aArray,nIt, cValor < cLimite, .F.)
					cSaldo  := nSaldo - nVlComp
					cLimite := Fa330VTit(aTitulos[nIt,Iif(cPaisLoc != "RUS",nPos,14)]) //Limite de Compensação
				EndIf
			EndIf
			
			If nOpca == 1
			
				If lCredito .And. SE1->E1_TIPO == MV_CRNEG
					If !cPaisLoc $ "EUA|RUS"
						dbSelectArea("SE1")
						If MV_PAR02 == 2
							dbGoTo(aArray[nIt,23])
						Else
							dbGoTo(aArray[nIt,20])
					    EndIf
				    EndIf
					nValAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
					RestArea(aAreaSE1)
				EndIf
							
				//Pcc Baixa CR
				//Caso a compensacao tenha partido de um Adiantamento
				If lCredito .And. (SE1->E1_TIPO <> MV_CRNEG) .And. ( !lRaRtImp .And. !lRaRtImpMRt ) .And. cPaisLoc == "BRA"
					dbSelectArea("SE1")					 				
					If MV_PAR02 == 2
						dbGoTo(aArray[nIt,23])
					Else
				   		dbGoTo(aArray[nIt,20])
				    Endif
				    
					If mv_par08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR )
						nTotAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
						nValAbat := nTotAbat
					Else
						nTotAbat := 0
					Endif
					
					nOldValRec	:= nValOld
					If cValor > cLimite
						cValor := cLimite
					EndIf

					nBaseImp := FBaseImp(cValor)

					//Motor de retenções
					If __lMotRet
						//Verifica as configurações de impostos pelo motor de retenção

						lRaRtImpMR	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
						lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
						lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
						
						//Calcula os impostos pelo motor de retenções

						F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, nBaseImp, dDataBase, SE1->E1_TIPO, .T. )
						
						If nY == nVezes // Destrói o Model do MR
							FMRGetArr(,.T.)
						EndIf
						
						aArray	[nIt,nPosxRet] := Transf(__nImpMR,cPicE1IRRF)
						aTitulos[nIt,nPosxRet] := Transf(__nImpMR,cPicE1IRRF)
						If __lIrfMR .And. lIrPjBxCr
							nIrrf := __nIrfCaMR
							aArray[nIt,nPosIrf] := Transf(nIrrf,cPicE1IRRF)
							aTitulos[nIt,nPosIrf]:= Transf(nIrrf,cPicE1IRRF)
						EndIf								
					EndIf
					
					If ( lRartimp .Or. lRaRtImpMR ) .And. ( !( cValor + nPis + nCofins + nCsll == SE1->E1_SALDO ) )
						F330CalcPCC( nIt, aArray, @cValor + Iif( cValor == cSalTit, nTotAbat, 0 ), cValor < cLimite )
					EndIf

					If !__lPccMR .And. dDatabase <= dLastPcc
						If !lRaRtImp .and. mv_par08 == 1 .and. lPccBxCr .and. SE1->E1_TIPO <> MVRECANT .and. nPis+nCofins+nCsll+nIrrf > 0 .AND. aDadosret[1] < nVlMinImp .and. aDadosRet[1]+nValRec > nVlMinImp
		  					nProp	:= (aDadosret[1]+ nValRec) / nSaldo
							nPis	:= SE1->E1_PIS * nProp
							nCofins := SE1->E1_COFINS * nProp
							nCsll	:= SE1->E1_CSLL * nProp
						EndIf
					EndIf
				EndIf
								
				If cPaisLoc == "BRA"
					If !__lDizPer .Or. ( (cValor < cLimite) .Or. aArray[nIt,9] == 0 )
						If nMoeda <> SE1->E1_MOEDA .And. cValor == NoRound(xMoeda(SE1->E1_SALDO,SE1->E1_MOEDA,nMoeda,SE1->E1_EMISSAO,5,Fa330Tx2(nMoeda,nTxMoeda)),2) 
							aArray[nIt,9] := xMoeda(SE1->E1_SALDO,SE1->E1_MOEDA,nMoeda,SE1->E1_EMISSAO,5,Fa330Tx2(nMoeda,nTxMoeda))
						Else
							aArray[nIt,9] := Iif(lMSal .And. cValor > cOldVl,cOldVl,cValor)
						EndIf
					EndIf
					
					If lIrPjBxCr .And. lCredito .And. (SE1->E1_TIPO <> MV_CRNEG) 
						
						If MV_PAR02 == 2
							If !__lIrfMR
								nIrrf := Val(StrTran(Replace(aArray[nIt][nPosIrf],".",""),",",".")) //FCaIrBxCR(aArray[nIt,9],aArray[nIt,23])
							EndIf
							
							If ( nPosIr := aScan(aImpIR,{|x| x[2] == aArray[nIt,23]}) ) == 0
								aAdd( aImpIR, {nIrrf,aArray[nIt,23]} )
								nPosIr := Len( aImpIR )
							Else
								aImpIR[nPosIr][1] := nIrrf
							EndIf
						Else
							If !__lIrfMR
								nIrrf := Val(StrTran(Replace(aArray[nIt][nPosIrf],".",""),",","."))//FCaIrBxCR(aArray[nIt,9],aArray[nIt,20])
							EndIf
							
							If ( nPosIr := aScan(aImpIR,{|x| x[2] == aArray[nIt,20]}) ) == 0
								aAdd( aImpIR, {nIrrf,aArray[nIt,20]} )
								nPosIr := Len( aImpIR )
							Else
								aImpIR[nPosIr][1] := nIrrf
							EndIf
						EndIf
							
					EndIf

					If (lPccBxCr .Or. lIRPJBxCr) .And. ( lRaRtImp .Or. lRaRtImpMR ) .And. !lNcc
						dbSelectArea("SE1")
						If MV_PAR02 == 2
							dbGoTo(aArray[nIt,23])
						Else
				   			dbGoTo(aArray[nIt,20])
				    	Endif
				    	
						If lCredito
							nItemOU := aScan(aDadosRA1[2],{|x| x==SE1->(Recno())})
						Else
							nItemRA := aScan(aDadosRA1[1],{|x| x==SE1->(Recno())})
						EndIf
												
				        If !__lPccMR .And. !(aArray[nIt,4] $ MV_CRNEG)
							If F330RaRtIm(@aDadosRA1,cValor,nItemRA,nItemOu, cValor < cLimite )
								If lCredito
									nAltVal	:= xMoeda(cValor, nMoeda, SE1->E1_MOEDA, dbaixa, __nCasDec, __nTxMoedP, __nTxMoedD)
									nValLimCp 	:= Fa330VTit(aArray[nIt,nPos])
									If nAltVal+nPis+nCofins+nCsll == SE1->E1_SALDO 
										nAltVal	:= nAltVal+nPis+nCofins+nCsll
									ElseIf nAltVal+aDadosRA1[3][nItemOU]+aDadosRA1[4][nItemOU]+aDadosRA1[5][nItemOU] == SE1->E1_SALDO
										nAltVal	:= nAltVal+aDadosRA1[3][nItemOU]+aDadosRA1[4][nItemOU]+aDadosRA1[5][nItemOU]
									ElseIf ( lRaRtImp .Or. lRaRtImpMR ) .And. cValor < nValLimCp .And. cValor == cLimite
										aAreaParc := GetArea()
										dbGoto( nRecno )
										nValImpAux := 0
										nValImpAux += Iif( !lPccBxCr, 0, SE1->(E1_PIS + E1_COFINS + SE1->E1_CSLL) )
										nValImpAux += Iif( !lIrPjBxCr, 0, SE1->E1_IRRF )
										If __lMotRet .And. Len(aDadosRA1) > 12 //Recupera o valor do imposto do configurador de tributos
											nValImpAux += aDadosRA1[13][1]
										EndIf									
										nValImpAux := nValImpAux*(cValor/SE1->E1_VALOR)
										nAltVal := Round(cValor + nValImpAux,2)
										RestArea(aAreaParc)	
										lRecRaRtIm := .T.
									EndIf
									
									If dDataBase >= dLastPcc .And. (cValor <> cLimite .Or. lRecRaRtIm)
										nAltVal	:= If(nMoeda == 1, cValor, nAltVal)
										If FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ) .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
											aPcc	:= newMinPcc(dbaixa, IIf(nBaseImpos > 0, nBaseImpos, nAltVal), SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
											nPis	:= 	aPcc[2]
											nCofins	:=	aPcc[3]
											nCsll	:=  aPcc[4]
											If Len(aPcc) > 4 
												__aTitCalc := aPcc[5]
											EndIf
										EndIf
										
										If !__lIrfMR .And. lIrPjBxCr .And. cPaisLoc == "BRA" .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
											nIrrf := FCaIrBxCR(IIf(nBaseImpos > 0, nBaseImpos, nAltVal))
										EndIf
										
										aDadosRA1[3][nItemOu]	:= nPis
										aDadosRA1[4][nItemOu]	:= nCofins
										aDadosRA1[5][nItemOu]	:= nCsll
										aDadosRA1[6][nItemOu]	:= nIrrf											
									EndIf
									
									aArray[nIt,nPosPis]:=Transf(aDadosRA1[3][nItemOu],cPicE1PIS)
									aArray[nIt,nPosCof]:=Transf(aDadosRA1[4][nItemOu],cPicE1COF)
									aArray[nIt,nPosCsl]:=Transf(aDadosRA1[5][nItemOu],cPicE1CSL)
									If !__lIrfMR
										aArray[nIt,nPosIrf] := Transf(aDadosRA1[6][nItemOu],cPicE1IRRF)
									Else
										aArray[nIt,nPosIrf] := Transf( nIrrf, cPicE1IRRF)
									EndIf
									If dDataBase < dLastPcc
										If cValor < cLimite
											cValor := cValor - (aDadosRA1[3][nItemOu]+aDadosRA1[4][nItemOu]+aDadosRA1[5][nItemOu]+aDadosRA1[6][nItemOu];
													  +aDadosRA1[10][nItemOu]+aDadosRA1[11][nItemOu])
										EndIf
									Else
										If cValor < cLimite
											If nMoeda > 1 .And. SE1->E1_MOEDA <> nMoeda
												cValor -= xMoeda(nPis, 1, SE1->E1_MOEDA, dDataBase, __nCasDec, __nTxMoedP)
												cValor -= xMoeda(nCofins, 1, SE1->E1_MOEDA, dDataBase, __nCasDec, 0, __nTxMoedP)
												cValor -= xMoeda(nCsll, 1, SE1->E1_MOEDA, dDataBase, __nCasDec, __nTxMoedP, __nTxMoedP)
												If !__lIrfMR .And. lIrPjBxCr
													cValor	-= xMoeda(nIrrf, 1, SE1->E1_MOEDA, dDataBase, __nCasDec, __nTxMoedP)
												EndIf
											Else
												cValor := cValor - (nPis+nCofins+nCsll)
												If !__lIrfMR .And. lIrPjBxCr
													cValor	:= cValor - nIrrf
												EndIf
											EndIf
										EndIf
									EndIf
								Else
									nAltVal	:= xMoeda(cValor, nMoeda, SE1->E1_MOEDA, dbaixa, __nCasDec,  __nTxMoedP, 0)
									If nAltVal+nPis+nCofins+nCsll == SE1->E1_SALDO 
										nAltVal	:= nAltVal+nPis+nCofins+nCsll
									ElseIf nAltVal+aDadosRA1[3][nItemRA]+aDadosRA1[4][nItemRA]+aDadosRA1[5][nItemRA] == SE1->E1_SALDO
										nAltVal	:= nAltVal+aDadosRA1[3][nItemRA]+aDadosRA1[4][nItemRA]+aDadosRA1[5][nItemRA]
									EndIf
									
									If dDataBase >= dLastPcc .And. (cValor <> cLimite)
										nAltVal	:= If(nMoeda == 1, cValor, nAltVal)
										If FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ) .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)											
											aPcc	:= newMinPcc(dbaixa, IIf(nBaseImpos > 0, nBaseImpos, nAltVal), SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
											nPis	:= 	aPcc[2]
											nCofins	:=	aPcc[3]
											nCsll	:=  aPcc[4]
											If Len(aPcc) > 4 
												__aTitCalc := aPcc[5]
											EndIf
										EndIf
										
										If !__lIrfMR .And. lIrPjBxCr .And. cPaisLoc == "BRA"
											nIrrf	:= aDadosRA1[6][nItemRA]
										EndIf
											
										aDadosRA1[3][nItemRA]	:= nPis
										aDadosRA1[4][nItemRA]	:= nCofins
										aDadosRA1[5][nItemRA]	:= nCsll
									Else
										nPis 	:= aDadosRA1[3][nItemRA]
										nCofins	:= aDadosRA1[4][nItemRA]
										nCsll	:= aDadosRA1[5][nItemRA]			
									EndIf
									
									aArray[nIt,nPosPis]:=Transf(aDadosRA1[3][nItemRA],cPicE1PIS)
									aArray[nIt,nPosCof]:=Transf(aDadosRA1[4][nItemRA],cPicE1COF)
									aArray[nIt,nPosCsl]:=Transf(aDadosRA1[5][nItemRA],cPicE1CSL)
									
									If !__lIrfMR
										aArray[nIt,nPosIrf] := Transf(aDadosRA1[6][nItemRA],cPicE1IRRF)
										nIrrf := aDadosRA1[6][nItemRA]										
									Else
										aArray[nIt,nPosIrf] := Transf( nIrrf, cPicE1IRRF)
									EndIf
									
									If dDataBase < dLastPcc
										If cValor < cLimite
									   		cValor := cValor - (aDadosRA1[3][nItemRA]+aDadosRA1[4][nItemRA]+aDadosRA1[5][nItemRA]+aDadosRA1[6][nItemRA];
																+aDadosRA1[10][nItemRA]+aDadosRA1[11][nItemRA])
										Endif
									Else
										If cValor < cLimite
											If nMoeda > 1 .And. SE1->E1_MOEDA <> nMoeda
												cValor -= xMoeda(nPis, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
												cValor -= xMoeda(nCofins, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
												cValor -= xMoeda(nCsll, 1, nMoeda, dDataBase, __nCasDec, __nTxMoedP, __nTxMoedP)
												If !__lIrfMR .And. lIrPjBxCr
													cValor	-= xMoeda(nIrrf, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
												EndIf
											Else
												cValor := cValor - (nPis+nCofins+nCsll)
												If !__lIrfMR .And. lIrPjBxCr
													cValor	:= cValor - nIrrf
												EndIf
											EndIf
										EndIf
									EndIf
								EndIf
								If !( nMoeda <> SE1->E1_MOEDA .And. cValor == NoRound(aArray[nIt,9], 2) )
									If !__lDizPer .Or. ( (cValor < cLimite) .Or. aArray[nIt,9] == 0 )
										aArray[nIt,9]	 := cValor
									EndIf
								EndIf
							EndIf
						ElseIf !(aArray[nIt,4] $ MV_CRNEG) // Pcc pelo Motor
							nPropBx := FBaseImp(aArray[nIt,9]) / nSaldo
							aArray[nIt,nPosPis] := Transf(nPis * nPropBx,	cPicE1PIS)
							aArray[nIt,nPosCof] := Transf(nCofins * nPropBx, cPicE1COF)
							aArray[nIt,nPosCsl] := Transf(nCsll * nPropBx,	cPicE1CSL)
							If __lIrfMR
								aArray[nIt,nPosIrf] := Transf( nIrrf * nPropBx, cPicE1IRRF)
							EndIf
						EndIf
					EndIf
				EndIf
								
				If cPaisLoc != "RUS" .And. lPccBxCr .And. (( !lRartimp .And. !SE1->E1_TIPO $ MVRECANT) .Or. (lRartimp .And. SE1->E1_TIPO $ MVRECANT))
					nTotAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
					If ((cValor <= cLimite .and. IIf(lRartimp .And. SE1->E1_TIPO $ MVRECANT,SE1->E1_SALDO,SE1->E1_SALDO - nPis -nCofins - nCsll - nTotAbat - __nImpMR ) <> cValor) .Or.;
					(SE1->(E1_PIS+E1_CSLL+E1_COFINS) > 0 .And. (nPis+nCofins+nCsll) == 0 .And. cValor <= cLimite .And. mv_par08 == 1)) //essa cond ocorre quando os tít são marca indiv, removido a seleç e depois selec todos.
						For nX:=1 to Len(aArray) // verifica todos os títulos ja marcados
							If	aArray[nX,8] 
								nVTit += Fa330VTit(aArray[nX,7])
							EndIf
						Next
						If lMSal
							cValor	:= cOldVl
						EndIf

						//Conversao dos valores para moeda do processo
						nIrrfCon  := xMoeda(Iif(lIrPjBxCr, nIrrf, 0), 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
						nTtPccCon := xMoeda(SE1->(E1_PIS + E1_COFINS + E1_CSLL), 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
						nVlPccCon := xMoeda(nPis + nCofins + nCsll, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
						nSaldoCon := Round(NoRound(xMoeda(SE1->E1_SALDO, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, __nTxMoedD, __nTxMoedP), __nCasDec), 2)
						nValorCon := Round(NoRound(xMoeda(SE1->E1_VALOR, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, __nTxMoedD, __nTxMoedP), __nCasDec), 2)

						__nProp := Round((cValor + nIrrfCon + nVlPccCon + SE1->E1_DECRESC + nTotAbat) / nSaldoCon, 2)
						If ( nVtit + cValor ==  nValorCon - nTtPccCon - nTotAbat ) .Or. ( nVtit + cValor == nValorCon - nVlPccCon - nTotAbat - __nImpMR )
							nAltVal := nSaldoCon - nVtit // se os titulos ja marcados + o titulo do momento for igual o liquido, deve calcular pelo restante do saldo.
						Else
							nAltVal := Iif(MV_PAR08==1 .Or. ( cPaisLoc == 'BRA' .And. __nProp == 1 ), (cValor + nIrrfCon + If(cPaisLoc == 'BRA' .And. __nProp == 1, nVlPccCon, 0 ) + SE1->E1_DECRESC + nTotAbat), cValor)
						EndIf
						
						If (aArray[nIt,4] $ MV_CRNEG .and.  nSaldoCon - nTotAbat == cValor) .or. (lNCC .and.  nSaldoCon - nValAbat == cValor ) .Or. ( nAltVal > nSaldoCon ) 
							//baixa total
							nAltVal := nSaldoCon
						EndIf
					
						nBaseImp := cValor + Iif(lRartimp, nVlPccCon+nIrrfCon,0)
					
						If cPaisLoc == 'BRA' 
							nAltVal := nBaseImp
						EndIf

						If dDataBase >= dLastPcc
							If !__lPccMR .And. FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
								If SE1->E1_VLCRUZ > SE1->E1_BASEIRF
									nAltVal := xMoeda(nAltVal, nMoeda, 1, dDataBase, __nCasDec, __nTxMoedP, 0)
									
									If VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)										
										aPcc := newMinPcc(dBaixa, IIf(nBaseImpos > 0, nBaseImpos, FBaseRPCC(nAltVal)), SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
									EndIf
							    Else
									nVlCruzCon := Round(NoRound(xMoeda(SE1->E1_VLCRUZ, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, __nTxMoedD, __nTxMoedP), __nCasDec), 2)
									nVlAltAnt  := nAltVal
									nAltVal    := Round(NoRound(xMoeda(nAltVal, nMoeda, 1, dDataBase, __nCasDec, __nTxMoedP, 0), __nCasDec), 2)
									nSldConv   := Round(NoRound(xMoeda(SE1->E1_SALDO, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, __nTxMoedD, __nTxMoedP), __nCasDec), 2)
									nTotAbtCon := Round(NoRound(xMoeda(nTotAbat, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP), __nCasDec), 2)
									
									If ( nVlCruzCon == ( nVlAltAnt + nVlPccCon+nIrrfCon )) .Or. ((nSldConv - nTotAbtCon) ==  ( nVlAltAnt + nVlPccCon+nIrrfCon ))
										nAltVal := FBaseRPCC(nAltVal)
									EndIf
								   	
									If VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
										aPcc := newMinPcc(dBaixa, IIf(nBaseImpos > 0, nBaseImpos, nAltVal), SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
									EndIf
								EndIf
								
								If Len(aPcc) >= 4
									nPis	:= 	aPcc[2]
									nCofins	:=	aPcc[3]
									nCsll	:=  aPcc[4]
									
									If Len(aPcc) > 4 
										__aTitCalc := aPcc[5]
									EndIf
								EndIf
							EndIf
														
							If !__lIrfMR .And. lIrPjBxCr .And. cPaisLoc == "BRA"
								nVlAltCmp	:= cValor
								If !lBq10925
									nVlAltCmp := cValor + xMoeda(nPis + nCofins + nCsll + IIf( lIrPjBxCr, nIrrf, 0 ), 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
								EndIf
								nIrrf	:= Iif(nVlAltCmp <> cLimite .And. !lRartimp , FCaIrBxCR( nAltVal ),nIrrf)
								aArray[nIt,nPosIrf]	:= Transf(nIrrf,cPicE1IRRF)
							EndIf
						EndIf
						
						If !lBq10925
							If !__lPccMR .Or. !__lIrfMR
								cValor := nAltVal
							
								If !__lPccMR .And. !lNCC
									cValor := cValor - nPis - nCofins - nCsll
								EndIf
								If !__lIrfMR .And. !lNCC
									cValor := cValor - Iif ( lIrPjBxCr, nIrrf, 0 )
								EndIf

								If MV_PAR08 == 1 //Considera abatimentos
									cValor := cValor - nTotAbat
								EndIf

								cValor := Round(NoRound(xMoeda(cValor, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP),3),2)
							EndIf
						EndIf

						If cValor > cLimite
							cValor := cLimite
						EndIf						
						
						If !__lPccMR
							aArray[nIt,nPosPis]	:= Transf(nPis, cPicE1PIS)
							aArray[nIt,nPosCof]	:= Transf(nCofins, cPicE1COF)
							aArray[nIt,nPosCsl]	:= Transf(nCsll, cPicE1CSL)
						EndIf
					EndIf
				EndIf
				
				If lTodos .And. lPccBxCr .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. mv_par08 == 1
					aArray[nIt,7] := Transf((cValor-nPis-nCofins-nCsll),__cPiE1Sld)
					//Vld para ñ gerar mov.diferentes
					cValor := If(lBq10925, Val(StrTran(StrTran(aArray[nIt][7],".", ""),",",".")), cValor)
					If !( nMoeda <> SE1->E1_MOEDA .And. cValor == NoRound(aArray[nIt,9], 2) )
						If !__lDizPer .Or. ( (cValor < cLimite) .Or. aArray[nIt,9] == 0 )
							aArray[nIt,9]	 := cValor
						EndIf
					EndIf
				Else				
					If cPaisLoc == "EUA"
						If cValor >= nVlRecAua
							aArray[nIt,7] := Transf(nVlRecAua,__cPiE1Sld)
							nVlRecAua := 0
						Else
							aArray[nIt,7] := Transf(cValor,__cPiE1Sld)
							nVlRecAua := nVlRecAua - cValor
						EndIf
					Else
						aArray[nIt,7] := Transf(cValor,__cPiE1Sld)
					EndIf
				EndIf
				
				If cPaisLoc != "RUS" .And. ( !lRaRtImp .Or. ( (__lIrfMR .Or. __lPccMR) .And. !lRaRtImpMR ) )
					If cPaisLoc != "EUA" .And. !( nMoeda <> SE1->E1_MOEDA .And. cValor == NoRound(aArray[nIt,9], 2) )
						If !__lDizPer .Or. ( (cValor < cLimite) .Or. aArray[nIt,9] == 0 )
							aArray[nIt,9]	 := cValor
						EndIf
					EndIf
				EndIf
				
				If cPaisLoc != "EUA" .And. cValor <> nValRec // cvalor é uma variavel numerica
					nValRec	:= cValor
				EndIf
			EndIf
	    Else
			aArray[nIt,8] := !aArray[nIt,8]
			If aArray[nIt,4] $ MV_CRNEG
				F330VALNCC(@aArray,nIt, cValor < cLimite, .F.)
			EndIf
		EndIf
	Else
		If !aArray[nIt,8]
			aArray[nIt,7] := Transf(0,__cPiE1Sld)
			
			If cPaisLoc == "BRA"
				aArray[nIt,9] := 0
				
				If lCredito
					dbSelectArea("SE1")
					If MV_PAR02 == 2
						dbGoTo(aArray[nIt,23])
					Else
				   		dbGoTo(aArray[nIt,20])
				    EndIf
				    
				    //Motor de retenções
					If __lMotRet
						//Verifica as configurações de impostos pelo motor de retenção
						F330VldImp()
											
						lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
						lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
						lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
					EndIf
				    
					If mv_par08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR )
						nTotAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE)
					Else
						nTotAbat := 0
					EndIf
					
					If !lTemImpPix
						F330CalcPCC(nIt,aArray,@cValor+If(cValor==cSalTit,nTotAbat,0),cValor < cLimite)
					EndIf
					
					If lIrPjBxCr
						nIrrf := 0
						
						If !__lIrfMR .And. !lTemImpPix .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
							nIrrf := FCaIrBxCR(IIf(nBaseImpos > 0, nBaseImpos, aArray[nIt,9]))
						EndIf
						
						If ( nPosIr := ascan(aImpIR,{|x| x[2]=SE1->(REcno())}) ) = 0
							aAdd(aImpIR,{nIrrf,SE1->(Recno())})
							nPosIr := Len( aImpIR )
						Else
							aImpIR[nPosIr][1] := nIrrf
						EndIf
					EndIf				
				Endif
			EndIf
		EndIf
		
		FA330UnLock(aArray[nIt,1]+aArray[nIt,2]+aArray[nIt,3]+aArray[nIt,4],,aArray[nIt,Iif(MV_PAR02== 2, 16,13)])
	EndIf	
Next nVezes

For nX:=1 to Len(aArray)
	If	aArray[nX,8]
		nValtot += Fa330VTit(aArray[nX,7])
	Endif
Next

nIt := nOldIt

If oGet != Nil
	oGet:Refresh()
EndIf

If ExistBlock("F330ATLIS")
	ExecBlock("F330ATLIS",.F.,.F., {  , 2 , nValTot, nValor } )
EndIf  

RestArea(aAreaSE1)
RestVarMR( aImpMRBrw )

Return aArray

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³Fa330SetMo³ Autor ³ Fernando Machima      ³ Data ³ 19/02/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Tela de taxas de moedas                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fa330SetMo												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Fa330SetMo(lAutomato)
Local oDlg
Local nLenMoedas	:= Len(aTxMoedas)
Local nI            := 1
Local nLinTelaF
Local nLinTelaD
Local nLinButton
Local aSay := {}
Local aGet := {}
Local cBlKMoeda
Local lExistM := Type("nMoeda") == "N" .And. nMoeda > 1
Default lAutomato := .F.

nLinTelaD	:=  05 + ((nLenMoedas-1) * 16)
nLinTelaF  	:= 200 + ((nLenMoedas-1) * 30.5) + 50
nLinButton  :=  03 + nLinTelaD

If nLenMoedas > 1
	If !lAutomato
		DEFINE MSDIALOG oDlg From 200,0 TO nLinTelaF,230 TITLE STR0037 PIXEL
			@ 005,005  To nLinTelaD,110 OF oDlg PIXEL

			For nI := 1 To nLenMoedas-1
				cBlKMoeda := "{|| aTxMoedas["+AllTrim(Str(ni+1))+",1]}"
				aAdd(aSay, TSay():New(1+(ni*12),010,&cBlKMoeda,oDlg,,, .F., .F., .T.,.T.,,,,, .F., .F., .F., .F.))
				aAdd(aGet, TGet():New((ni*12)-2,060,&("{|x| If(x <> NIL,aTxMoedas["+AllTRim(Str(ni+1))+",2] := x,aTxMoedas["+Str(ni+1)+",2])}"),oDlg,45,,aTxMoedas[nI+1,3],,,,,,,.T.,,,,.F.,.T.,,.F.,.F.,,,,.F.,,.T.))
			Next nI

		DEFINE  SButton FROM (nLinTelaD + 5),80 TYPE 1 Action (oDlg:End() ) ENABLE OF oDlg  PIXEL
		ACTIVATE MSDIALOG oDlg CENTERED
	EndIf
	If lExistM .And. (nI >= nMoeda .Or. lAutomato)
		If __lTxConP // validação para taxa contratada no título de partida
			If __lCmTxCon //se possui taxa contratada e não gera variação, a taxa de partida não se altera.
				__nTxMoedP := aTxMoedas[nMoeda, 2]
				__nTxContr := __nTxMoedP 
				nTxMoeda   := __nTxMoedP
			EndIf
		Else // validação para taxa do adiantamento na partida
			If (lCredito .And. !__lRaTxMov) .Or. !lCredito //se é crédito e utiliza a taxa do movimento, a taxa de partida não se altera
				__nTxMoedP := aTxMoedas[nMoeda, 2]
				__nTxContr := __nTxMoedP 
				nTxMoeda   := __nTxMoedP
			EndIf
		EndIf
	EndIf
Else
	Help("",1,"NoMoneda")
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºRotina    ³Fa330TudOkºAutor  ³Claudio D. de Souza º Data ³  29/11/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Validar os campos informados na compensacao                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Fina330                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa330TudOk(nVlrCompe)

Local lRet := .T.
Default nVlrCompe := 0

Do Case
Case EMPTY(cNum)
	lRet := .F.
Case !fa330Cli()
	lRet := .F.
Case !Fa330Loja()
	lRet := .F.
Case !(nValor >= 0 .AND. STR(nValor,17,2) <= STR(nSaldo,17,2))
	lRet := .F.
Case !(dBaixa >= SE1->E1_EMISSAO)
	lRet := .F.
Case !lCredito
	If Empty(cTipoTit) .Or.	!(!cTipoTit $ MVABATIM .AND. 	!(cTipoTit $ MVRECANT+"/"+MV_CRNEG))
		lRet := .F.
	EndIf
Case lCredito
	If Empty(cTipoTit) .Or. !(!cTipoTit $ MVABATIM .AND. (cTipoTit $ MVRECANT+"/"+MV_CRNEG))
		lRet := .F.
	EndIf

EndCase

If SE1->E1_MOEDA > 1 .And. Empty(__nTxMoedP)
	Help( ,,"NOTXTITP",,STR0128, 1, 0 ) //"Não existe taxa cambial para o título!"
	lRet := .F.
EndIf

//Possibilita novas validacoes
If ExistBlock("F300VALID")
	lRet := ExecBlock	("F300VALID",.F.,.F.,nVlrCompe)
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}fMarkAll

Marcar todos os títulos da tela

@author Totvs
@since  11/06/2019
@version 12
/*/
//-------------------------------------------------------------------

Static Function fMarkAll(aTit As Array, nValor As Numeric, lEstorno As Logical) As Logical

	Local nI 		As Numeric
	Local nPosMarca As Numeric
	Local lRet 		As Logical
	
	nI 			:= 0
	nPosMarca 	:= 8
	lRet 		:= .T.
	
	Default lEstorno := .F.

	nPosMarca := Iif( lEstorno, 11, nPosMarca )

	If Len(aTit) > 0
		For nI := 1 to Len(aTit)
			If !aTit[nI,nPosMarca]
				lRet := .F.
				If !lEstorno
					If cPaisLoc == "EUA"
						aTit[nI][7] := aTit[nI][14]
					Else
						aTit[nI][7] := aTit[nI][22]
					EndIf
				EndIf
			EndIf
		Next
	EndIf
	
	If lEstorno
		aEval(@aTit, {|e| e[nPosMarca] := !lRet } )
	Else
		nValTot := 0
		aEval( @aTit, {|e| e[nPosMarca] := !lRet, ;
						   Iif( e[nPosMarca], ( Iif( Fa330VTit(e[7]) = 0, e[7] := e[6], Nil ), nValTot += Fa330VTit(e[7]),;
						   Iif( cPaisLoc=="BRA", e[9] := DesTrans(e[7]), IIf( MV_PAR02 == 02, e[12] := DesTrans(e[7]), .T. ) ) ),;
						   ( e[7] := Transf(0,"@E 9999,999,999.99"), Iif( cPaisloc=="BRA", e[9] := DesTrans(e[7]), IIf( MV_PAR02 == 02, e[12] := e[7], e[11] := e[7] ) ) ) ) } )
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}fDsMarkAll

Desmarcar todos os títulos da tela

@author Rodrigo Oliveira
@since  26/06/2019
@version 12
/*/
//-------------------------------------------------------------------

Static Function fDsMarkAll(aTit As Array, nValor As Numeric) As Logical

	Local nI 		As Numeric
	Local nPosMarca As Numeric
	Local lRet 		As Logical
	
	nI 			:= 0
	nPosMarca 	:= 8
	lRet 		:= .T.
	
	nValTot := 0
	aEval( @aTit, {|e| e[nPosMarca] := .F., ;
					   Iif( e[nPosMarca], ( Iif( Fa330VTit(e[7]) = 0, e[7] := e[6], Nil ), nValTot += Fa330VTit(e[7]),;
					   Iif( cPaisLoc=="BRA", e[9] := DesTrans(e[7]), IIf( MV_PAR02 == 02, e[12] := DesTrans(e[7]), .T. ) ) ),;
					   ( e[7] := Transf(0,"@E 9999,999,999.99"), Iif( cPaisloc=="BRA" .And. !__lDizPer, e[9] := DesTrans(e[7]), IIf( MV_PAR02 == 02, e[12] := e[7], e[11] := e[7] ) ) ) ) } )

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Fa330Leg   ³ Autor ³ Mauricio Pequim Jr   ³ Data ³ 20.07.04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria uma janela contendo a legenda da mBrowse              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa330Leg(nReg)
Local uRetorno := .T.
Local aLegenda := {	{"ENABLE"		, 	STR0051	},; //"Titulo nao Compensado"
				   	{"DISABLE"		, 	STR0052	},; //"Titulo Compensado Totalmente"
					{"BR_AZUL"		,  STR0053	}} //"Titulo Compensado Parcialmente"

If nReg = Nil	// Chamada direta da funcao onde nao passa, via menu Recno eh passado
	uRetorno := {}
	Aadd(uRetorno, {'E1_SALDO =  0', aLegenda[2][1]})			// Titulo Compensado Totalmente
	Aadd(uRetorno, {'E1_SALDO =  E1_VALOR', aLegenda[1][1]}) // Titulo nao Compensado
	Aadd(uRetorno, {'E1_SALDO <> 0', aLegenda[3][1]})			// Titulo Compensado Parcialmente
Else
	BrwLegenda(cCadastro,STR0047,aLegenda)  //"Legenda"
EndIf

Return uRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³PesqListBox³ Autor ³ Edson Maricate       ³ Data ³ 09.02.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta uma pesquisa de texto em um listBox.                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Geral                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function PesqListBox(oListBox,aListBox)

Local nFound
Local aParam	:= {}

PRIVATE mv_par01 // Declara as variaveis private para não conflitar com as variaveis da pergunte
PRIVATE mv_par02
PRIVATE mv_par03

If ParamBox( { { 1,STR0001 ,Padr(__PesqList,200),"@" 	 ,""  ,""    ,"" ,120 ,.T. },;
				{5,STR0056,.F.,90,,.F.},;
				{5,STR0057,.F.,90,,.F.} }, STR0001 , aParam, , , , , , , , .F. )

	__PesqList := aParam[1]
	If aParam[2]
		If aParam[3]
			nFound := aScan(aListBox,{|x| aScan(x,{|x| AllTrim(aParam[1])$AllTrim(x) } )>0 },oListBox:nAt+1)
		Else
			nFound := aScan(aListBox,{|x| aScan(x,{|x| AllTrim(aParam[1])$AllTrim(x) } )>0 })
		EndIf
	Else
		If aParam[3]
			nFound := aScan(aListBox,{|x| aScan(x,{|x| UPPER(AllTrim(aParam[1]))$UPPER(AllTrim(x)) } )>0 },oListBox:nAt+1)
		Else
			nFound := aScan(aListBox,{|x| aScan(x,{|x| UPPER(AllTrim(aParam[1]))$UPPER(AllTrim(x)) } )>0 })
		EndIf
	EndIf
	If nFound <= 0
		Aviso(STR0058, STR0059,{"Ok"},2)
	Else
		oListBox:nAt := nFound
		oListBox:Refresh()
	EndIf

EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Fa330IntPco ºAutor ³Paulo Carnelossi    º Data ³  22/11/06  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³funcao que gera os lancamentos no sigapco (PcoDetLan())     º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function Fa330IntPco(nRecSE1, aRecnoSE1, aBaixasSE5)
Local aArea := GetArea()
Local aAreaSE1 := SE1->(GetArea())
Local aAreaSE5 := SE5->(GetArea())
Local nX

If SuperGetMV("MV_PCOINTE",.F.,"2")=="1"

	dbSelectArea("SE1")
	dbGoto(nRecSE1) //titulo principal apos a compensacao

	// Grava lançamento no PCO ref titulo principal apos a compensacao
	PCODetLan("000016","01","FINA330")

	For nX := 1 TO Len(aRecnoSE1) // ARRAY COM REGISTROS TITULOS COMPENSADOS

		//grava lcto ref. titulo compensado
		dbSelectArea("SE1")
		dbGoto(aRecnoSE1[nX])

		//Grava lançamento no PCO ref titulo compensado apos a compensacao 
		PCODetLan("000016","02","FINA330")

		//grava lctos das baixas referente titulo principal e titulo compensado
		dbSelectArea("SE5")
		If Len(aBaixasSE5) > 0
			If valtype(aBaixasSE5[(nX*2)-1]) == "N" .and. Valtype(aBaixasSE5[(nX*2)]) == "N"
				
				dbGoto(aBaixasSE5[(nX*2)-1])
				// Grava lançamento no PCO ref baixa (Mov.Bancaria-SE5) do titulo principal apos a compensacao
				PCODetLan("000016","03","FINA330")

				dbGoto(aBaixasSE5[(nX*2)])
				// Grava lançamento no PCO ref baixa do titulo compensado (Mov.Bancaria-SE5)
				PCODetLan("000016","04","FINA330")
			Else
				Loop
			EndiF
		EndIf

	Next

EndIf

RestArea(aAreaSE5)
RestArea(aAreaSE1)
RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³MenuDef   ³ Autor ³ Ana Paula N. Silva     ³ Data ³23/11/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Utilizacao de menu Funcional                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array com opcoes da rotina.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Parametros do array a Rotina:                               ³±±
±±³          ³1. Nome a aparecer no cabecalho                             ³±±
±±³          ³2. Nome da Rotina associada                                 ³±±
±±³          ³3. Reservado                                                ³±±
±±³          ³4. Tipo de Transa‡„o a ser efetuada:                        ³±±
±±³          ³		1 - Pesquisa e Posiciona em um Banco de Dados     ³±±
±±³          ³    2 - Simplesmente Mostra os Campos                       ³±±
±±³          ³    3 - Inclui registros no Bancos de Dados                 ³±±
±±³          ³    4 - Altera o registro corrente                          ³±±
±±³          ³    5 - Remove o registro corrente do Banco de Dados        ³±±
±±³          ³5. Nivel de acesso                                          ³±±
±±³          ³6. Habilita Menu Funcional                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MenuDef()
Local lFA330LIB := Existblock("FA330LIB")
Local aRetorno  := {}
Local aRotina   := {  {STR0001, "AxPesqui"  , 0, 1,, .F. },;  //"Pesquisar"
	                  {STR0002, "AxVisual"  , 0, 2 },;        //"Visualizar"
	                  {STR0003, "Fa330Comp" , 0, 4 },;        //"Compensar"
 	                  {STR0004, "Fa330Desc" , 0, 4 },;        //"Excluir"
 	                  {STR0054, "Fa330Desc" , 0, 4 },;        //"Estornar"
 	                  {STR0047, "Fa330Leg"  , 0, 2,, .F.} }   //"Legenda"

If lFA330LIB
	aRetorno := ExecBlock("FA330LIB",.F.,.F.,{aRotina})
	aRotina := AClone(aRetorno)
Endif

Return(aRotina)

//------------------------------------------------------------------------------------------------------------------------------------------------

Static Function FA330aUnlock()
Local aArea := GetArea()
If aRLocks == Nil
	aRLocks:={}
Endif
//**********************************************
// Retirado para permitir utilizacao de rotina *
// automatica dentro de transacao no banco     *
//**********************************************
//AEval(aRLocks,{|x,y| SE1->(MsRUnlock(x))})
AEval(aRLocks,{|x,y| SE1->(DbGoTo(x)),MsUnLock() })
aRLocks:={}
RestArea(aArea)
Return

//------------------------------------------------------------------------------------------------------------------------------------------------

Static Function FA330Unlock(cChave,nRecno,cfilorig)
Local aArea
Local nPosRec

If aRLocks == Nil
	aRLocks:={}
EndIf
If nRecno <> Nil
	SE1->(MsGoto(nRecno))
Else
	aArea	:=	getArea()
	SE1->(DbSetOrder(1))
	SE1->(MsSeek(cfilorig+cChave))
EndIf

//**********************************************
// Retirado para permitir utilizacao de rotina *
// automatica dentro de transacao no banco     *
// **********************************************
//SE1->(MsRUnlock(SE1->(Recno())))
SE1->(MsUnlock())

If (nPosRec:=Ascan(aRLocks,SE1->(REcno()))) > 0
	Adel(aRlocks,nPosRec)
	aSize(aRlocks,Len(aRlocks)-1)
EndIf

If aArea <> Nil
	RestArea(aArea)
EndIf

Return

//------------------------------------------------------------------------------------------------------------------------------------------------

Static Function FA330Lock(cChave,nRecno,lHelp,cfilOrig)
Local aArea
Local lRet	:=	.F.
DEFAULT lHelp	:=	.T.

If aRLocks == Nil
	aRLocks:={}
Endif

If nRecno <> Nil
	SE1->(MsGoto(nRecno))
Else
	aArea	:=	SE1->(getArea())
	SE1->(DbSetOrder(1))
	SE1->(MsSeek(cfilorig+cChave))
Endif

If  SE1->(RecLock("SE1",.F.))
	AAdd(aRLocks, SE1->(Recno()))
	lRet	:=	.T.
ElseIf lHelp
	MsgAlert(STR0060)
Endif

If aArea <> Nil
	RestArea(aArea)
Endif

Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³FinA330T   ³ Autor ³ Marcelo Celi Marques ³ Data ³ 27.03.08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Chamada semi-automatica utilizado pelo gestor financeiro   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FinA330T(aParam)

	cRotinaExec := "FINA330"
	ReCreateBrow("SE1",FinWindow)
	FinA330(aParam[1])
	FinVisual(FinWindow:cAliasFile,FinWindow,(FinWindow:cAliasFile)->(Recno()),.T.)
	ReCreateBrow("SE1",FinWindow)
	dbSelectArea("SE1")

	INCLUI := .F.
	ALTERA := .F.

Return .T.

//------------------------------------------------------------------------------------------------------------------------------------------------

Function F330SldPri(nRecNo)
Local aArea := SE1->(GetArea())
Local nSaldo := 0

SE1->(DbGoTo(nRecNo))
nSaldo := SE1->E1_SALDO

RestArea(aArea)

Return nSaldo

//------------------------------------------------------------------------------------------------------------------------------------------------

Function F330CalcPCC( nIt, aArray, cValor, lAltValor )

Local nPosPis 	:= 14		//Posicao Pis na Tela
Local nPosCof 	:= 15		//Posicao Cofins na Tela
Local nPosCsl 	:= 16		//Posicao Csll na Tela
Local nPVRPis 	:= 17		//Posicao Valor Retido Pis na Tela
Local nPVRCof 	:= 18		//Posicao Valor Retido Cofins na Tela
Local nPVRCsl 	:= 19		//Posicao Valor Retido Csll na Tela
Local nPosRec 	:= 20		//Posicao Recno na Tela
Local nPisJaRet := 0
Local nPisARet 	:= 0
Local nCofJaRet := 0
Local nCofARet 	:= 0
Local nCslJaRet := 0
Local nCslARet 	:= 0
Local nX		:= 0
Local cRetCli 	:= "1"
Local lPccBxCr	:= FPccBxCr()
Local nPropPcc	:= 0
Local nVlrTitSel	:= 0  
Local nValPcc	:= 0  
Local ni		:= 0    
Local nRecTit	:= 0
Local nTotAdto	:= 0
Local lBaixaAbat	:= .F.
Local nVlrBaixa	:= 0
Local lBxCec	:= .F.
Local lBxLiq	:= .F.
Local lSigaloja	:= .F.
Local lTipBxCP  := .F.
Local nTAbt		:= 0
Local nBaseImpos := 0

Default lAltValor := .F.

lPccBxCr := ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxCr )

If cPaisLoc == "BRA" .And. lPccBxCr
	//Caso considere diferentes clientes
	If MV_PAR02 == 2
		nPosPis := 17
		nPosCof := 18
		nPosCsl := 19
		nPVRPis := 20		//Posicao Valor Retido Pis na Tela
		nPVRCof := 21		//Posicao Valor Retido Cofins na Tela
		nPVRCsl := 22		//Posicao Valor Retido Csll na Tela
		nPosRec := 23
		nPosBPCC := 27
		nPosBPCR := 28
	Endif

	SE1->( dbGoTo( aArray[nIt, nPosRec] ) )
	nValrec 	:= cValor 	//Esta variavel esta numerica apesar da notacao.
	nOldValRec 	:= nValRec

	If !__lPccMR
	
		cRetCli := Iif(Empty(SA1->A1_ABATIMP),"1",SA1->A1_ABATIMP)
	
		If aArray[nIt,8]
			If cRetCli == "1"  //Calculo do sistema
				nValRecAtu := nValRec
				For nX := nIt To Len(aArray)
					If	aArray[nX,8]
						nValRec   += Fa330VTit(aArray[nX,7])
						If mv_par08 == 2
							nValRec   += Fa330VTit(aArray[nX,nPosPis])
							nValRec   += Fa330VTit(aArray[nX,nPosCof])
							nValRec   += Fa330VTit(aArray[nX,nPosCsl])
							nPisJaRet += Fa330VTit(aArray[nX,nPosPis])
							nPisARet  += Fa330VTit(aArray[nX,nPVRPis])
							nCofJaRet += Fa330VTit(aArray[nX,nPosCof])
							nCofARet  += Fa330VTit(aArray[nX,nPVRCof])
							nCslJaRet += Fa330VTit(aArray[nX,nPosCsl])
							nCslARet  += Fa330VTit(aArray[nX,nPVRCsl])
						EndIf
					EndIf
				
					If (Len(aArray) > nX)
						If aArray[(nX+1),8]
							Exit
						EndIf
					EndIf			
				Next
	
				nVlrTitSel := nValRec
				If ( nPisJaRet + nCofJaRet + nCslJaRet ) > 0
					nValRec    := nOldValRec
				EndIf
				
				aBaixa := Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, SE1->E1_PREFIXO,SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO,;
					                   @nTotAdto, @lBaixaAbat, SE1->E1_CLIENTE, SE1->E1_LOJA, @nVlrBaixa, , @lBxCec, @lBxLiq ,@lSigaloja ,@lTipBxCP)
				
				nTAbt	:= SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
				
				If dDataBase < dLastPcc
					f070TotMes(dBaixa,.T.)
				Else
					If lAltValor
						nValPcc	:= nValRec
					Else
						If !__lBq10925 .And. lCredito
							nValPcc	:= SE1->E1_SALDO
						Else
							nValPcc	:= SE1->E1_VALOR - nTotAdto
						EndIf
					EndIf

					If 	FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ) .And. VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
						If SE1->E1_VLCRUZ > SE1->E1_BASEIRF
					   		aPcc := newMinPcc(dBaixa, IIf(nBaseImpos > 0, nBaseImpos, FBaseRPCC(nValPcc)), SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
						Else
					   		aPcc := newMinPcc(dBaixa, IIf(nBaseImpos > 0, nBaseImpos, nValPcc), SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
				    	EndIf	

						nPis	:= aPcc[2]
						nCofins	:= aPcc[3]
						nCsll	:= aPcc[4]
						If !lAltValor .and. !lRartimp .and. mv_par08 == 1 .and. !lCredito /*SE1->E1_TIPO == MVNOTAFIS*/ .and. (SE1->E1_SALDO - Iif(!lPccBxCr,0,nPis + nCofins + nCsll) - nTAbt <> nValRec )//.and. SE1->E1_SALDO - nPis - nCofins - nCsll - nTAbt == SE1->E1_SALDO) // compensado pelo valor liquido 
							nValPcc	:= nValRec
							aPcc	:= newMinPcc(dBaixa,nValPcc,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
							nPis	:= aPcc[2]
							nCofins	:= aPcc[3]
							nCsll	:= aPcc[4]
						EndIf
						If Len(aPcc) > 4 
							__aTitCalc := aPcc[5]
						EndIf
					EndIf
				EndIf
				nValRec    	:= nVlrTitSel
				nOldvalRec	:= nVlrTitSel
	
				If dDataBase < dLastPcc
					If ( MV_PAR08 == 1 .Or. lRaRtImp ) .And. ( lAltValor .Or. nValRecAtu < SE1->E1_SALDO );
					.And. (!lRaRtImp .And. (nValRecAtu+(nCofins+nCsll+nPis+nIrrf+nTAbt))< SE1->E1_SALDO)
						
						nPropPcc 	:= (nValRecAtu*(nCofins+nCsll+nPis))/SE1->E1_VLCRUZ
						nPropPcc 	:= (nPropPcc/ (nCofins+nCsll+nPis) )
						nPis		:= Round(NoRound(SE1->E1_PIS * nPropPCC,3),2)
						nCofins		:= Round(NoRound(SE1->E1_COFINS * nPropPCC,3),2)
						nCsll		:= Round(NoRound(SE1->E1_CSLL * nPropPCC,3),2)
						nPisBaseR 	:= Round(NoRound(SE1->E1_BASEPIS * nPropPCC,3),2)
						nPisBaseC 	:= Round(NoRound(SE1->E1_BASEPIS * nPropPCC,3),2)
		
						nValRec := nValRecAtu
					Else
						nValRec := nValRecAtu
						nPis 	:= nPis + nPisARet - nPisJaRet
						nCofins := nCofins + nCofARet - nCofJaRet
						nCsll 	:= nCsll + nCslARet - nCslJaRet
					EndIf
				EndIf
	
			ElseIf cRetCli == "2"	//Sempre calcula
				nPropPcc 	:= nValrec/SE1->E1_VLCRUZ
				nPis		:= Round(NoRound(SE1->E1_PIS * nPropPCC,3),2)
				nCofins		:= Round(NoRound(SE1->E1_COFINS * nPropPCC,3),2)
				nCsll		:= Round(NoRound(SE1->E1_CSLL * nPropPCC,3),2)
				nPisBaseR 	:= Round(NoRound(SE1->E1_BASEPIS * nPropPCC,3),2)
				nPisBaseC 	:= Round(NoRound(SE1->E1_BASEPIS * nPropPCC,3),2)
				nVlRetPis	:= nPis
				nVlRetCof	:= nCofins
				nVlRetCsl	:= nCsll
				nValRec		-= (nPis+nCofins+nCsll)
			Else
				nPis		:= 0
				nCofins		:= 0
				nCsll		:= 0
				nVlRetPis	:= 0
				nVlRetCof	:= 0
				nVlRetCsl	:= 0
			Endif
		Else
			nPis		:= 0
			nCofins		:= 0
			nCsll		:= 0
			nVlRetPis	:= 0
			nVlRetCof	:= 0
			nVlRetCsl	:= 0
		EndIf

		cValor	:= nValRec
	Else
		
		If !aArray[nIt,8]
			nPis 	:= 0
			nCofins	:= 0
			nCsll 	:= 0
		EndIf
		
	EndIf
	
	If mv_par08 == 1
		aArray[nIt,nPosPis] := Transform(nPis,"@E 99,999,999.99")
		aArray[nIt,nPosCof] := Transform(nCofins,"@E 99,999,999.99")
		aArray[nIt,nPosCsl] := Transform(nCsll,"@E 99,999,999.99")
	EndIf
	
	If !__lPccMR
		aArray[nIt,nPosBPCC] := Transform(nPisBaseC,"@E 99,999,999.99")
		aArray[nIt,nPosBPCR] := Transform(nPisBaseR,"@E 99,999,999.99")
	Endif
	
	If MV_PAR02 == 2
		If !__lPccMR
			aArray[nIt,nPVRPis] := Transform(nVlRetPis,"@E 99,999,999.99")
			aArray[nIt,nPVRCof] := Transform(nVlRetCof,"@E 99,999,999.99")
			aArray[nIt,nPVRCsl] := Transform(nVlRetCsl,"@E 99,999,999.99")
		Else
			aArray[nIt,nPVRPis] := Transform(nPis,"@E 99,999,999.99")
			aArray[nIt,nPVRCof] := Transform(nCofins,"@E 99,999,999.99")
			aArray[nIt,nPVRCsl] := Transform(nCsll,"@E 99,999,999.99")
		EndIf
	Endif
	
	For ni := 1 To Len(aTitulos)
		nRecTit	:= SE1->(Recno())
		If ValType(aTitulos[ni,20]) <> "C"
			If nRecTit == aTitulos[ni][20]
				aTitulos[ni][14]	:= aArray[nIt,nPosPis]
				aTitulos[ni][15]	:= aArray[nIt,nPosCof]
				aTitulos[ni][16]	:= aArray[nIt,nPosCsl]
			EndIf
		EndIf
	Next		
EndIf

Return

//------------------------------------------------------------------------------------------------------------------------------------------------

Function F330GrvSFQ(cSequencia,nRecnoSE1)
Local aAreaSFQ	 	:= Getarea() 
Local nLoop		 	:= 0
Local nVlMinImp	 	:= GetNewPar("MV_VL10925",5000)
Local aRecnos	 	:= {}
Local cModRetPIS 	:= SA1->A1_ABATIMP
Local nBaseRet	 	:= 0
Local lAplVlMin	 	:= .T.
Local nTamSeq	 	:= TamSX3("FQ_SEQORI")[1]
Local lPccBxCr	 	:= FPccBxCr()
Local nTit		 	:= 0
Local lIrPjBxCr	 	:= FIrPjBxCr()
Local lRaRtImp   	:= FRaRtImp()
// Variaveis para o Model de Alteração do SE5
Local aAreaFKs 	 	:= {}
Local oSubFK3
Local oSubFK4
Local cCamposE5  	:= ""
Local lRet 		 	:= .T.
Local lGrvFK3		:= .T.
Local aImpostos  	:= {}
Local nX
Local nSalvRec 	 	:= SE1->(Recno())
Local oModelMov  	:= Nil
Local cIDFK1 	 	:= ""
Local cFilOld	 	:= ""

DEFAULT cSequencia 	:= Replicate("0",nTamSeq)
DEFAULT nRecnoSE1	:= 0

nIss     := If(Type("nIss") != "N",0,nIss)
nIrrf    := If(Type("nIrrf") != "N",0,nIrrf)
nValComp := If(Type("nValComp") != "N",0,nValComp)
nValLiq  := If(Type("nValLiq") != "N",0,nValLiq)
dBaixa	 := If(Type("dBaixa") != "D",dDataBase,dBaixa)
nTotAbat := If(Type("nTotAbat") != "N",SumAbatRec( SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_MOEDA, "S"  ,dBaixa,,@nTotIrAbt,@nTotCsAbt,@nTotPisAbt,@nTotCofAbt,),nTotAbat)
nDescont := If(Type("nDescont") != "N",0,nDescont)
nMulta   := If(Type("nMulta") != "N",0,nMulta)
nJuros   := If(Type("nJuros") != "N",0,nJuros)
nAcresc  := If(Type("nAcresc") != "N",0,nAcresc)
nDecresc := If(Type("nDecresc") != "N",0,nDecresc)
lRetParc := If(Type("lRetParc") != "L",.T.,lRetParc)

nBaseRet		:= nValRec+nDescont+nTotAbat-nJuros-nMulta

If dDatabase >= dLastPcc
	nVlMinImp	:= 0
EndIf

//Verificar ou nao o limite de 5000 para Pis cofins Csll
// 1 = Verifica o valor minimo de retencao
// 2 = Nao verifica o valor minimo de retencao
If SE1->E1_APLVLMN == "2"
	lAplVlMin := .F.
EndIf

If nRecnoSE1 > 0 .AND. AllTrim(cSequencia) != Replicate("0",nTamSeq)

	//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
	If AllTrim( SE5->E5_TABORI ) == "FK1"
		aAreaFKs := GetArea()
		dbSelectArea( "FK1" )
		FK1->( DbSetOrder( 1 ) )
		If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
			//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
			SE1->(dbGoto(nRecnoSE1))
	   		cCamposE5:= "{"
   			cCamposE5+= "{'E5_VRETPIS', "+cValtoChar(nPis)+"}"
   			cCamposE5+= ",{'E5_VRETCOF', "+cValtoChar(nCofins)+"}"
    		cCamposE5+= ",{'E5_VRETCSL', "+cValtoChar(nCsll)+"}"
    		cCamposE5+= ",{'E5_VRETIRF', "+cValtoChar(nIrrf)+"}"
	   		cCamposE5+= "}"

			oModelMov := FWLoadModel("FINM010")
			oModelMov:SetOperation( 4 ) //Alteração
			oModelMov:Activate()
			oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
			oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1

			//Dados Contábeis
   			oSubFK3 := oModelMov:GetModel("FK3DETAIL")
   			oSubFK4 := oModelMov:GetModel("FK4DETAIL")
   			      
   			cIDFK1 := FWUUIDV4()
			//------------------------------------------------------
			// Grava os valores agregados ao titulo no totalizador 
			//------------------------------------------------------
			//Reestruturacao SE5
			//aImpostos[1] = codigo imposto
			//aImpostos[2] = imposto calculado
			//aImpostos[3] = natureza
			//aImpostos[4] = cIdFK4															
			//aImpostos[5] = imposto retido
			//aImpostos[6] = base calculado
			//aImpostos[7] = base retencao
			aadd(aImpostos,{"PIS" ,nPisCalc ,		SuperGetMV("MV_PISNAT")		,"", nPis    , nPisBaseC, nPisBaseR, ""	})
			aadd(aImpostos,{"COF" ,nCofCalc ,		SuperGetMV("MV_COFINS")		,"", nCofins , nCofBaseC, nCofBaseR, ""	})
			aadd(aImpostos,{"CSL" ,nCslCalc ,		SuperGetMV("MV_CSLL")  		,"", nCsll   , nCslBaseC, nCslBaseR, ""	})
			aadd(aImpostos,{"IRF" ,nIrfCalc ,		&(SuperGetMV("MV_IRF"))		,"", nIrrf   , nIrfBase , nIrfBaseR, ""	})
			
			//Grava FK3 E/OU FK4
			For nX := 1 to Len(aImpostos)
				lGrvFk3	:= .T.
				//Gravar FK4 se os valores de PCC forem maiores que zero IMPOSTOS
				If aImpostos[nX][2] > 0 .And. aImpostos[nX][6] > 0
                       
					cIdFK4 := ""
					If aImpostos[nX][5] > 0 .And. aImpostos[nX][7] > 0   //Houve retencao
						If aImpostos[nX,1] == "IRF"
							cIdFK4 := __cIdFk4IR
						Else
							cIdFK4:= FINFKSID('FK4', 'FK4_IDFK4')
						EndIf

						aImpostos[nX,4] := cIdFK4

						//Guardo o IDFK4 do IRF para usar posteriormente
						
					EndIf
	                        
					If !oSubFK3:IsEmpty()
						If aImpostos[nX,1] == "IRF"
							If nIrrf > 0 .Or. FXBuscaIRF(oModelMov) // No caso de IR retido, a gravação é feita pela FGSFQIRCR (FINXIMP)
								lGrvFK3	:= .F.
							EndIf
						EndIf
						If lGrvFK3
							//Inclui a quantidade de linhas necessárias
							oSubFK3:AddLine()		
						
							//Vai para linha criada
							oSubFK3:GoLine( oSubFK3:Length() )
						EndIf
					EndIf	
		
					//---------------------------------------------
					// Grava Imposto calculado
					//---------------------------------------------
					If lGrvFK3
						oSubFK3:SetValue( "FK3_IDFK3" , FINFKSID('FK3', 'FK3_IDFK3'))
						oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
						oSubFK3:SetValue( "FK3_ORIGEM", FunName() )
						oSubFK3:SetValue( "FK3_IMPOS" , aImpostos[nX][1] )
						oSubFK3:SetValue( "FK3_RECPAG", "R" )
						oSubFK3:SetValue( "FK3_MOEDA" , "01" )
						oSubFK3:SetValue( "FK3_VALOR" , aImpostos[nX][2] )
						oSubFK3:LoadValue( "FK3_NATURE", aImpostos[nX][3])
						oSubFK3:SetValue( "FK3_FILORI", SE1->E1_FILORIG  )
						oSubFK3:SetValue( "FK3_BASIMP", aImpostos[nX][6] )
						oSubFK3:SetValue( "FK3_IDORIG", cIdFK1 )
						oSubFK3:SetValue( "FK3_TABORI", "FK1") 
						oSubFK3:SetValue( "FK3_IDRET" , aImpostos[nx,4] )
						If __lMotRet
							oSubFK3:SetValue( "FK3_CODFKM", aImpostos[nX,8] )
							oSubFK3:SetValue( "FK3_CLIFOR", SA1->A1_COD )
							oSubFK3:SetValue( "FK3_LOJA"  , SA1->A1_LOJA )
							oSubFK3:SetValue( "FK3_CGC"   , SA1->A1_CGC )
							oSubFK3:SetValue( "FK3_RAICGC", Substr(SA1->A1_CGC, 1, 8) )
						EndIf
					EndIf
		
					//---------------------------------------------
					// Grava Imposto Retido
					//---------------------------------------------
					If aImpostos[nX][5] > 0 .And. aImpostos[nX][1] != "IRF"  //Houve retencao
						If !oSubFK4:IsEmpty()
							//Inclui a quantidade de linhas necessárias
							oSubFK4:AddLine()		
						
							//Vai para linha criada
							oSubFK4:GoLine( oSubFK4:Length() )	
						EndIf		
	
						oSubFK4:SetValue( "FK4_IDFK4" , aImpostos[nx,4])
						oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
						oSubFK4:SetValue( "FK4_ORIGEM", FunName() )
						oSubFK4:LoadValue( "FK4_IMPOS" , aImpostos[nx,1] )
						oSubFK4:SetValue( "FK4_RECPAG", "R" )
						oSubFK4:SetValue( "FK4_MOEDA" , "01" )
						oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nX,5] )
						oSubFK4:LoadValue( "FK4_NATURE", aImpostos[nX,3])
						oSubFK4:SetValue( "FK4_FILORI", SE1->E1_FILORIG )
						oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nX,7])
						If __lMotRet
							oSubFK4:SetValue( "FK4_CODFKM", aImpostos[nX,8] )
							oSubFK4:SetValue( "FK4_CLIFOR", SA1->A1_COD )
							oSubFK4:SetValue( "FK4_LOJA"  , SA1->A1_LOJA )
							oSubFK4:SetValue( "FK4_CGC"   , SA1->A1_CGC )
							oSubFK4:SetValue( "FK4_RAICGC", Substr(SA1->A1_CGC, 1, 8) )
						EndIf

					EndIf
				EndIf
			Next nX

			If oModelMov:VldData()
				oModelMov:CommitData()
				SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
			Else
				lRet := .F.
				cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[6])
				Help( ,,"M010VALID",,cLog, 1, 0 )
 			EndIf
			oModelMov:DeActivate()
			oModelMov:Destroy()
			oModelMov:= nil

			If lRet
				//Gravo o relacionamento de retenção dos títulos que tiveram impostos retidos na baixa atual
				FinFk3BCR(__aTitCalc, aImpostos)
				AjustBsPCC(aImpostos)
			EndIf

		Else //Se não achou o registro na FK1
			lRet := .F.
		EndIf
		RestArea(aAreaFKs)
	Else //Se a origem do registro posicionado não for FK1
		lRet := .F.
	EndIf

	Do Case
	Case cModRetPIS == "1"
		If (aDadosRet[ 1 ] + nValRec > nVlMinImp) .or. !lAplVlMin
			If (!lRaRtImp .and. !(SE5->E5_TIPO == MVRECANT) .and. aDadosRet[ 1 ] + nValRec > nVlMinImp)
				nSalvRec := SE5->( Recno() )
				lRetParc := .T.
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If aDadosRet[1] > 0
					aRecnos := aClone( aDadosRet[ 6 ] )
	
					cPrefOri  := SE5->E5_PREFIXO
					cNumOri   := SE5->E5_NUMERO
					cParcOri  := SE5->E5_PARCELA
					cTipoOri  := SE5->E5_TIPO
					cCfOri    := SE5->E5_CLIFOR
					cLojaOri  := SE5->E5_LOJA
	
					For nLoop := 1 to Len( aRecnos )
	
						SE5->( dbGoto( aRecnos[ nLoop ] ) )
	
						RecLock( "SE5", .F. )
	
						If !Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)
							SE5->E5_PRETPIS := "2"
							SE5->E5_PRETCOF := "2"
							SE5->E5_PRETCSL := "2"
						EndIf
	
						SE5->( MsUnlock() )
	
						If nSalvRec <> aRecnos[ nLoop ]
							dbSelectArea("SFQ")
							RecLock("SFQ",.T.)
							SFQ->FQ_FILIAL  := xFilial("SFQ")
							SFQ->FQ_ENTORI  := "E1B"
							SFQ->FQ_PREFORI := cPrefOri
							SFQ->FQ_NUMORI  := cNumOri
							SFQ->FQ_PARCORI := cParcOri
							SFQ->FQ_TIPOORI := cTipoOri
							SFQ->FQ_CFORI   := cCfOri
							SFQ->FQ_LOJAORI := cLojaOri
							SFQ->FQ_SEQORI  := cSequencia
	
							SFQ->FQ_ENTDES  := "E1B"
							SFQ->FQ_PREFDES := SE5->E5_PREFIXO
							SFQ->FQ_NUMDES  := SE5->E5_NUMERO
							SFQ->FQ_PARCDES := SE5->E5_PARCELA
							SFQ->FQ_TIPODES := SE5->E5_TIPO
							SFQ->FQ_CFDES   := SE5->E5_CLIFOR
							SFQ->FQ_LOJADES := SE5->E5_LOJA
							SFQ->FQ_SEQDES  := SE5->E5_SEQ
	
							//Grava a filial de destino
							SFQ->FQ_FILDES := SE5->E5_FILIAL
	
							MsUnlock()
						Endif
	 				Next nLoop
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Retorna do ponteiro do SE1 para a parcela         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SE5->( MsGoto( nSalvRec ) )
		Else
			If nVlRetPis + nVlRetCof + nVlRetCsl > 0
				//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
				If AllTrim( SE5->E5_TABORI ) == "FK1"
					aAreaFKs := GetArea()
					dbSelectArea( "FK1" )
					FK1->( DbSetOrder( 1 ) )
					If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
						//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
						cCamposE5:= "{"
						cCamposE5+= "{'E5_VRETPIS',"+Str(nVlRetPis)+"}"
						cCamposE5+= ",{'E5_VRETCOF',"+Str(nVlRetCof)+"}"
						cCamposE5+= ",{'E5_VRETCSL',"+Str(nVlRetCsl)+"}"
						cCamposE5+= ",{'E5_PRETPIS', '1'}"
						cCamposE5+= ",{'E5_PRETCOF', '1'}"
						cCamposE5+= ",{'E5_PRETCSL', '1'}"
						cCamposE5+= "}"
						oModelMov:SetOperation( 4 ) //Alteração
						oModelMov:Activate()
						oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
						oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1
						
						
  						If oModelMov:VldData()
      	   					oModelMov:CommitData()
							SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
						Else
       						lRet := .F.
	   				 		cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
	   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
	   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[6])
   							Help( ,,"M030VALID",,cLog, 1, 0 )
						Endif
						
						oModelMov:DeActivate()
						oModelMov:Destroy()
						oModelMov:= nil
					Else //Se não achou o registro na FK1
						lRet := .F.
					Endif
					RestArea(aAreaFKs)
				Else //Se a origem do registro posicionado não for FK1
					lRet := .F.
				Endif
	
			EndIf
			lRetParc := .F.

		EndIf

	Case cModRetPIS == "2"
		lRetParc := .T.

	Case cModRetPIS == "3"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava a Marca de "pendente recolhimento" dos demais registros    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nVlRetPis + nVlRetCof + nVlRetCsl > 0
			//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
			If AllTrim( SE5->E5_TABORI ) == "FK1"
				aAreaFKs := GetArea()
				dbSelectArea( "FK1" )
				FK1->( DbSetOrder( 1 ) )
				If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
					//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
					cCamposE5:= "{"
					cCamposE5+= "{'E5_VRETPIS',"+Str(nVlRetPis)+"}"
					cCamposE5+= ",{'E5_VRETCOF',"+Str(nVlRetCof)+"}"
					cCamposE5+= ",{'E5_VRETCSL',"+Str(nVlRetCsl)+"}"
					cCamposE5+= ",{'E5_PRETPIS', '1'}"
					cCamposE5+= ",{'E5_PRETCOF', '1'}"
					cCamposE5+= ",{'E5_PRETCSL', '1'}"
					cCamposE5+= "}"
					oModelMov:SetOperation( 4 ) //Alteração
					oModelMov:Activate()
					oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
					oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1
					
					
					If oModelMov:VldData()
   	   					oModelMov:CommitData()
						SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))

					Else
   						lRet := .F.
   				 		cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[6])
						Help( ,,"M030VALID",,cLog, 1, 0 )
					Endif
					oModelMov:DeActivate()
					oModelMov:Destroy()
					oModelMov:= nil
				Else //Se não achou o registro na FK1
					lRet := .F.
				Endif
				RestArea(aAreaFKs)
			Else //Se a origem do registro posicionado não for FK1
				lRet := .F.
			Endif

		EndIf
		lRetParc := .F.
	EndCase

	//Grava os titulos de PCC Baixa CR
	//Gravo os titulos de impostos Pis Cofins Csll quando controlados pela baixa
	If lRetParc .And. !lRaRtImp .And. ((nPis+nCofins+nCsll) > 0)
		cFilOld	:= cFilAnt
		
		If lCredito			
			cFilAnt := SE1->E1_FILORIG
		EndIf
		
		FGrvPccRec(@nPis, @nCofins, @nCsll, nRecnoSE1, .F., lRetParc ,@cSequencia, "FINA070", 1)
		cFilAnt	:= cFilOld
	EndIf

    If lRaRtImp .And. !SE5->E5_TIPO $ MVRECANT .And. (lPccBxCr  .or. lIRPJBxCr)
		nTit := 0
		
		If Len(aDadosRA1[2]) != 1
			nTit := aScan(aDadosRA1[2],{|x| x=nRecnoSE1})
		EndIf
		
		If nTit == 0
			For nTit := 1 to Len(aDadosRA1[1])
				If aDadosRA1[9][nTit]
					//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
					If AllTrim( SE5->E5_TABORI ) == "FK1"
						aAreaFKs := GetArea()
						dbSelectArea( "FK1" )
						FK1->( DbSetOrder( 1 ) )
						If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
							//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
							cCamposE5:= "{"
   							cCamposE5+= "{'E5_VRETPIS', "+Str(aDadosRA1[3][nTit])+"}"
   							cCamposE5+= ",{'E5_VRETCOF', "+Str(aDadosRA1[4][nTit])+"}"
    						cCamposE5+= ",{'E5_VRETCSL', "+Str(aDadosRA1[5][nTit])+"}"
    						cCamposE5+= ",{'E5_VRETIRF', "+Str(aDadosRA1[6][nTit])+"}"

    						If aDadosRA1[3][nTit]+aDadosRA1[4][nTit]+aDadosRA1[5][nTit]>0
					  			cCamposE5+= ",{'E5_PRETPIS', '7'}"
    							cCamposE5+= ",{'E5_PRETCOF', '7'}" //Retido no RA
					  			cCamposE5+= ",{'E5_PRETCSL', '7'}" //Retido no RA
							Endif
							If aDadosRA1[6][nTit]>0
						   		cCamposE5+= ",{'E5_PRETIRF', '7'}"//Retido no RA
				 			Endif
				 			If lRaRtImp .And. cPaisLoc == "BRA"
				 				cCamposE5+= ",{'E5_PRISS', "+Str(aDadosRA1[10][nTit])+"}"
				 				cCamposE5+= ",{'E5_PRINSS', "+Str(aDadosRA1[11][nTit])+"}"
				 			Endif          
				 			cCamposE5+= "}"
				 			
							oModelMov := FWLoadModel("FINM010")
							oModelMov:SetOperation( 4 ) //Alteração
							oModelMov:Activate()
							oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
							oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1

							If oModelMov:VldData()
       	   					oModelMov:CommitData()
							   	SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
	       					oModelMov:DeActivate()
							Else
	       					lRet := .F.
		   				 		cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
		   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
		   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[6])

	       					If !lF330Auto  //Se não for rotina automatica
	       						Help( ,,"M030VALID",,cLog, 1, 0 )
       						Endif
							Endif
							oModelMov:DeActivate()
							oModelMov:Destroy()
							oModelMov:= nil
						Else //Se não achou o registro na FK1
							lRet := .F.
						Endif
						RestArea(aAreaFKs)
					Else //Se a origem do registro posicionado não for FK1
						lRet := .F.
					Endif
					aDadosRA1[9][nTit]:= .F.
					Exit
				Endif
			Next nTit
		Else
			If aDadosRA1[9][nTit]

				If AllTrim( SE5->E5_TABORI ) == "FK1"
					aAreaFKs := GetArea()
					dbSelectArea( "FK1" )
					FK1->( DbSetOrder( 1 ) )
					If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
						//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
						cCamposE5:= "{"
						cCamposE5+= "{'E5_VRETPIS', "+Str(aDadosRA1[3][nTit])+"}"
						cCamposE5+= ",{'E5_VRETCOF', "+Str(aDadosRA1[4][nTit])+"}"
   						cCamposE5+= ",{'E5_VRETCSL', "+Str(aDadosRA1[5][nTit])+"}"
   						cCamposE5+= ",{'E5_VRETIRF', "+Str(aDadosRA1[6][nTit])+"}"
   						If aDadosRA1[3][nTit]+aDadosRA1[4][nTit]+aDadosRA1[5][nTit]>0
				  			cCamposE5+= ",{'E5_PRETPIS', '7'}"
   							cCamposE5+= ",{'E5_PRETCOF', '7'}" //Retido no RA
				  			cCamposE5+= ",{'E5_PRETCSL, '7'}" //Retido no RA
						Endif
						If aDadosRA1[6][nTit]>0
					   		cCamposE5+= ",{'E5_PRETIRF', '7'}"//Retido no RA
			 			Endif
			 			If lRaRtImp .And. cPaisLoc == "BRA"
			 				cCamposE5+= ",{'E5_PRISS', "+Str(aDadosRA1[10][nTit])+"}"
			 				cCamposE5+= ",{'E5_PRINSS', "+Str(aDadosRA1[11][nTit])+"}"
			 			Endif
						cCamposE5+= "}"

						oModelMov := FWLoadModel("FINM010")
						oModelMov:SetOperation( 4 ) //Alteração
						oModelMov:Activate()
						oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
						oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1

						If oModelMov:VldData()
   	   						oModelMov:CommitData()
						   	SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
						Else
       					lRet := .F.
	   				 		cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
	   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
	   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[6])

       					If !lF330Auto  //Se não for rotina automatica
       						Help( ,,"M030VALID",,cLog, 1, 0 )
      						Endif
						Endif
						oModelMov:DeActivate()
						oModelMov:Destroy()
						oModelMov:= nil
					Else //Se não achou o registro na FK1
						lRet := .F.
					EndIf
					RestArea(aAreaFKs)
				Else //Se a origem do registro posicionado não for FK1
					lRet := .F.
				EndIf

			EndIf
		EndIf
	EndIf

EndIf

RestArea(aAreaSFQ)

Return

//--------------------------------------------------------------------------

Function FaDelSFQCR()

Local nI := 0
Local aRecSE5 := {}
Local lPccBxCr	:= FPccBxCr()
//Controla IRPJ na baixa
Local lIrPjBxCr		:= FIrPjBxCr()
Local aArea := GetArea()
Local nRecSE5 := 0
Local aSE1Area := SE1->(GetArea())
//  Variaveis de Uso do Model
Local aAreaFKs := {}
Local oModelMov := nil
Local cCamposE5 := ""
Local lRet := .T.

Private lRaRtImp  	:= FRaRtImp()       //Define se ha retencao de impostos PCC/IRPJ no R.A

If cPaisLoc == "BRA" .and. lPccBxCR
	nRecSe5  := SE5->(RecNo())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclui os registros de relacionamentos do SFQ                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRecSE5 := FImpDelTit("E1B",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)
	For nI := 1 to Len(aRecSE5)
		SE5->(MSGoto(aRecSE5[nI]))

		If AllTrim( SE5->E5_TABORI ) == "FK1"
			aAreaFKs := GetArea()
			dbSelectArea( "FK1" )
			FK1->( DbSetOrder( 1 ) )
			If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
				//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
				cCamposE5 := "{"
				cCamposE5 += "{'E5_PRETPIS', '1'}"
				cCamposE5 += ",{'E5_PRETCOF', '1'}"
				cCamposE5 := ",{'E5_PRETCSL', '1'} }"
				oModelMov := FWLoadModel("FINM010")
				oModelMov:SetOperation( 4 ) //Alteração
				oModelMov:Activate()
				oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
				oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1

				If oModelMov:VldData()
					oModelMov:CommitData()
				Else
					lRet := .F.
					cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[6])       			
       			
					Help( ,,"M100VALID",,cLog, 1, 0 )
				Endif
				oModelMov:DeActivate()
				oModelMov:Destroy()
				oModelMov:= Nil
			Else //Se não achou o registro na FK1
				lRet := .F.
			EndIf
			RestArea(aAreaFKs)
		Else //Se a origem do registro posicionado não for FK1
			lRet := .F.
		EndIf

	Next
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclui os registros de relacionamentos do SFQ                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SE5->(dbGoto(nRecSe5))
	FImpDelSFQ("E1B",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Apaga os registros de impostos gerados na Baixa                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lIrPjBxCr .And. !lRartimp
		F070DelTxBx(SE1->E1_FILIAL)
	EndIf

EndIf
If cPaisLoc == "BRA" .and. lIrPjBxCr
	nRecSe5  := SE5->(RecNo())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclui os registros de relacionamentos do SFQ                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRecSE5 := FImpDelTit("E5B",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)
	For nI := 1 to Len(aRecSE5)
		SE5->(MSGoto(aRecSE5[nI]))

		If AllTrim( SE5->E5_TABORI ) == "FK1"
			aAreaFKs := GetArea()
			dbSelectArea( "FK1" )
			FK1->( DbSetOrder( 1 ) )
			If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
				//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
				cCamposE5 := "{{'E5_PRETIRF', '1'}}"
				oModelMov := FWLoadModel("FINM010")
				oModelMov:SetOperation( 4 ) //Alteração
				oModelMov:Activate()
				oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
				oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1

				If oModelMov:VldData()
					oModelMov:CommitData()
				Else
					lRet := .F.
					cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[6])
					Help( ,,"M100VALID",,cLog, 1, 0 )
				Endif
				oModelMov:DeActivate()
				oModelMov:Destroy()
				oModelMov:= Nil
			Else //Se não achou o registro na FK1
				lRet := .F.
			Endif
			RestArea(aAreaFKs)
		Else //Se a origem do registro posicionado não for FK1
			lRet := .F.
		Endif

	Next
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclui os registros de relacionamentos do SFQ                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SE5->(dbGoto(nRecSe5))
	FImpDelSFQ("E5B",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Apaga os registros de impostos gerados na Baixa                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SE1->E1_TIPO == MVRECANT .OR. SE1->E1_TIPO == MV_CRNEG .And. !lRartImp
			dbSelectArea("SE1")
			dbSetorder(1)
			Seek(xfilial("SE1")+SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO))
			F070DelTxBx(SE1->E1_FILIAL)
	Else
			If !lRartimp
			 F070DelTxBx(SE1->E1_FILIAL)
			Endif
	EndIf
EndIf
RestArea(aArea)
RestArea(aSE1Area)

Return

/*/{Protheus.doc}F330Button
	Função responsável por selecionar/marcar e inverter/inversão
	da marcação do(s) título(s)

	@author Sivaldo Oliveira
/*/
Function F330Button(lPccBxCr As Logical, oTitulo As Object, oGet01 As Object, lMarkAll As Logical)
	Local lTipoChar  AS Logical
	Local nTitulo    As Numeric
	Local nArray     As Numeric
	Local nTotMarcad As Numeric
	Local nVlrTotCmp As Numeric
	Local nValorMov  As Numeric
	Local nColuna    As Numeric
	
	//Parâmetros de entrada
	Default lPccBxCr := .F.
	Default oTitulo  := Nil
	Default oGet01   := Nil
	Default lMarkAll := .F. 
	
	//Inicializa variáveis
	lTipoChar  := .F.
	nTitulo    := 0
	nArray     := 1
	nTotMarcad := nValTot
	nValTot    := 0
	nVlrTotCmp := 0
	nValorMov  := 0
	nColuna    := 22
	
	If cPaisLoc <> "BRA"
		aTitulos := FA330Troca(oTitulo:nAt,aTitulos,oGet01,.T.,,lMarkAll)
	ElseIf aTitulos != Nil .And. Type("aTitulos") == "A" .And. (nTitulo := Len(aTitulos)) > 0
		nVlrTotCmp := IIf(nValor != Nil .And. Type("nValor") == "N" .And. nValor > 0, nValor, nSaldo)		
		
		If MV_PAR02 == 2
			nColuna := 25
		EndIf
		
		If !lMarkAll
			nTotMarcad := 0
		EndIf 
		
		lTipoChar  := ValType(aTitulos[nArray,nColuna]) !=  "N"
		
		For nArray := 1 To nTitulo
			If lMarkAll
				If nTotMarcad >= nVlrTotCmp
					Exit
				ElseIf aTitulos[nArray,8]
					Loop
				EndIf
			ElseIf aTitulos[nArray,8]
				aTitulos[nArray,7] := Transf(0, __cPiE1Sld)
				aTitulos[nArray,9] := 0
				aTitulos[nArray,8] := .F.
				Loop
			EndIf
			
			If nTotMarcad < nVlrTotCmp
				nValorMov := aTitulos[nArray,nColuna]			
				
				If lTipoChar
					nValorMov := DesTrans(nValorMov)
				EndIf			
				
				If (nTotMarcad + nValorMov) >= nVlrTotCmp
					nValorMov := (nVlrTotCmp - nTotMarcad)
				EndIf
				
				nTotMarcad += nValorMov
				aTitulos[nArray,8] := .T.
				aTitulos[nArray,7] := Transf(nValorMov, __cPiE1Sld)			
				aTitulos[nArray,9] := nValorMov
			EndIf
		Next nArray
		
		nValTot := nTotMarcad
	EndIf
	
	If oTitulo != Nil .And. Valtype(oTitulo) == "O"  
		oTitulo:Refresh()
	EndIf
	
	If oGet01 != Nil .And. Valtype(oGet01) == "O" 
		oGet01:Refresh()
	EndIf
Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³FaNfsRAdt   ³ Autor ³Totvs                ³ Data ³10.05.2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Checa se condicao de pagamento do documento de saida usa    ³±±
±±³          ³adiantamento.                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se Condicao de Pagamento gera Adiantamento    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Prefixo do titulo                                    ³±±
±±³          ³ExpC2: Numero do titulo                                     ³±±
±±³          ³ExpC3: Codigo do cliente                                    ³±±
±±³          ³ExpC4: Loja do cliente                                      ³±±
±±³          ³ExpD5: Data de Emissao do Documento                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function FaNfsRAdt(cPrefixo,cNum,cCliente,cLoja,dDataEmis)

Local aArea := GetArea()
Local cQ := ""
Local lRet := .F.

cQ	:= "SELECT F2_COND "
cQ += "FROM "+RetSqlName("SF2")+" "
cQ += "WHERE F2_FILIAL = '"+xFilial("SF2")+"' "
cQ += "AND F2_PREFIXO = '"+cPrefixo+"' "
cQ += "AND F2_DUPL = '"+cNum+"' "
cQ += "AND F2_CLIENTE = '"+cCliente+"' "
cQ += "AND F2_LOJA = '"+cLoja+"' "
cQ += "AND F2_EMISSAO = '"+dTos(dDataEmis)+"' "
cQ += "AND D_E_L_E_T_= ' ' "

cQ := ChangeQuery(cQ)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQ),"TRBSF2",.T.,.T.)

If !Eof()
	If A410UsaAdi(TRBSF2->F2_COND)
		lRet := .T.
	Endif
Endif

TRBSF2->(dbCloseArea())

RestArea(aArea)

Return(lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³FaBxEmisDoc ³ Autor ³Totvs                ³ Data ³10.05.2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Checa se a compensacao do titulo foi gerada no momento da   ³±±
±±³          ³emissao do documento.Parametros devem ser o do titulo       ³±±
±±³          ³principal (Tipo de titulo = MVNOTAFIS).                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a Compensacao foi realizada na geracao do  ³±±
±±³          ³Documento                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Filial do SE5                                        ³±±
±±³          ³ExpC2: Prefixo do titulo                                    ³±±
±±³          ³ExpC3: Numero do titulo                                     ³±±
±±³          ³ExpC4: Parcela do titulo                                    ³±±
±±³          ³ExpC5: Cliente/Fornecedor do titulo                         ³±±
±±³          ³ExpC6: Loja do titulo                                       ³±±
±±³          ³ExpC7: Tipo da baixa                                        ³±±
±±³          ³ExpD8: Data de emissao do titulo                            ³±±
±±³          ³ExpC9: Sequencia da baixa                                   ³±±
±±³          ³ExpC10: Carteira da baixa "R"/"P"                           ³±±
±±³          ³ExpC11: Numero do documento                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Esta rotina eh usada no contas a receber a pagar.           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FaBxEmisDoc(cFilSE5,cPrefixo,cNum,cParcela,cCliFor,cLoja,cTipo,dDataE,cSeq,cCarteira,cDocumen)

Local aArea 	:= GetArea()
Local cQ 		:= ""
Local lRet 		:= .F.
Local nCountFR3 := 0
Local nTamPref 	:= IIf(cCarteira = "R",__nTamPref,IIf(cCarteira = "P",__nTamE2Pr,0))
Local nTamNum 	:= __nTamNum
Local nTamParc 	:= __nTamParc
Local aAdianta	:= ProtCfgAdt()
Local lAdComPart:= aAdianta[1,5] .And. 'C' $ aAdianta[1,1]+aAdianta[1,2]+aAdianta[1,3]

// localiza quantas vezes o adiantamento foi utilizado neste documento de saida
cQ	:= "SELECT COUNT(*) AS NREG "
cQ += "FROM "+RetSqlName("FR3")+" "
cQ += "WHERE FR3_FILIAL = '"+xFilial("FR3")+"' "
cQ += "AND FR3_CART = '"+cCarteira+"' "
If cCarteira = "R"
	cQ += "AND FR3_CLIENT = '"+cCliFor+"' "
Elseif cCarteira = "P"
	cQ += "AND FR3_FORNEC = '"+cCliFor+"' "
Endif
cQ += "AND FR3_LOJA = '"+cLoja+"' "
cQ += "AND FR3_PREFIX = '"+Subs(cDocumen,1,nTamPref)+"' "
cQ += "AND FR3_NUM = '"+Subs(cDocumen,nTamPref+1,nTamNum)+"' "
cQ += "AND FR3_PARCEL = '"+Subs(cDocumen,nTamPref+nTamNum+1,nTamParc)+"' "
If cCarteira = "R"
	cQ += "AND FR3_TIPO IN "+FormatIn(MVRECANT,"/")+" "
Elseif cCarteira = "P"
	cQ += "AND FR3_TIPO IN "+FormatIn(MVPAGANT,"/")+" "
Endif
cQ += "AND FR3_DOC = '"+cNum+"' "

If lAdComPart
	cQ += " AND ( FR3_FILORI = '"+cFilAnt+"' OR FR3_FILORI = ' ') "
EndIf

cQ += "AND FR3_DATAE = '"+dTos(dDataE)+"' "
cQ += "AND EXISTS( SELECT 1 " // busca somente os registros que tenham o mesmo documento que estah sendo comparado, para evitar problema de titulos com mais de uma parcela, gerando divergencia na comparacao entre as parcelas.
cQ += "	FROM "+RetSqlName("FR3")+" "
cQ += "	WHERE FR3_FILIAL = '"+xFilial("FR3")+"' "
cQ += "	AND FR3_CART = '"+cCarteira+"' "
If cCarteira = "R"
	cQ += "	AND FR3_CLIENT = '"+cCliFor+"' "
Elseif cCarteira = "P"
	cQ += "	AND FR3_FORNEC = '"+cCliFor+"' "
Endif
cQ += "	AND FR3_LOJA = '"+cLoja+"' "

cQ += "	AND FR3_PREFIX = '"+cPrefixo+"' "
cQ += "	AND FR3_NUM = '"+cNum+"' "
cQ += "	AND FR3_PARCEL = '"+cParcela+"' "

cQ += "	AND FR3_TIPO = '"+MVNOTAFIS+"' "
cQ += "	AND FR3_DOC = '"+cNum+"' "

If lAdComPart
	cQ += " AND ( FR3_FILORI = '"+cFilAnt+"' OR FR3_FILORI = ' ') "
EndIf

cQ += "	AND FR3_DATAE = '"+dTos(dDataE)+"' "

cQ += "	AND D_E_L_E_T_= ' ') "
cQ += "AND D_E_L_E_T_= ' ' "

cQ := ChangeQuery(cQ)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQ),"TRBFR3",.T.,.T.)

nCountFR3 := TRBFR3->NREG

TRBFR3->(dbCloseArea())

If !Empty(nCountFR3)
	// localiza as baixa para o titulo principal por ordem de sequencia, para comparar com a quantidade de baixas ocorridas no momento da geracao do documento
	cQ	:= "SELECT R_E_C_N_O_ AS SE5RECNO,E5_PREFIXO,E5_NUMERO,E5_PARCELA,E5_TIPO,E5_CLIFOR,E5_LOJA,E5_SEQ "
	cQ += "FROM "+RetSqlName("SE5")+" "
	cQ += "WHERE E5_FILIAL = '"+cFilSE5+"' "
	cQ += "AND E5_RECPAG = '"+cCarteira+"' "
	cQ += "AND E5_SITUACA <> 'C' "
	cQ += "AND E5_DATA = '"+dTos(dDataE)+"' "
	cQ += "AND E5_NUMERO = '"+cNum+"' "
	cQ += "AND E5_PREFIXO = '"+cPrefixo+"' "
	cQ += "AND E5_PARCELA = '"+cParcela+"' "
	cQ += "AND E5_CLIFOR = '"+cCliFor+"' "
	cQ += "AND E5_LOJA = '"+cLoja+"' "
	cQ += "AND E5_TIPO = '"+cTipo+"' "
	cQ += "AND E5_MOTBX = 'CMP' "
	cQ += "AND E5_TIPODOC = 'CP' "
	cQ += "AND D_E_L_E_T_= ' ' "
	cQ += "AND E5_DOCUMEN = '"+cDocumen+"' " // considera somente as baixas que usaram este mesmo documento, ou seja, as baixas deste adiantamento
	cQ += "ORDER BY E5_FILIAL,E5_SEQ "

	cQ := ChangeQuery(cQ)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQ),"TRBSE5",.T.,.T.)

	While !Eof()
		If Empty(nCountFR3)
			Exit
		Endif
		If TemBxCanc(TRBSE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T.)
			dbSkip()
			Loop
		Endif
		nCountFR3--
		// se sequencia da baixa for igual a do parametro, esta baixa foi efetuado junto com a emissao do documento
		If TRBSE5->E5_SEQ = cSeq
			lRet := .T.
		Endif
		dbSkip()
	Enddo

	TRBSE5->(dbCloseArea())
EndIf

RestArea(aArea)

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Fa330VldDtºAutor  ³ Clovis Magenta     º Data ³  13/01/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Consiste MV_DATAFIN antes de cancelar baixa/compensação    º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Fa330VldDt(aArray, nOpc)
Local lRet := .T.
DEFAULT nOpc := 5

If lRet .and. SuperGetMv("MV_BXDTFIN",,"1") == "2"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ A data da baixa deve ser passada como parametro, pois tanto ³
	//³ o cancelamento como a exclusao devem ser validados pela     ³
	//³ data de baixa e nao pela data base do sistema.              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF nOpc == 4  //Exclusao
		lRet := DtMovFin(CtoD(aArray[06]),!l330Auto,"2")
	Else
		lRet := DtMovFin( ,!l330Auto,"2")
	EndIf

EndIf

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Fa330TxMd  ³ Autor ³ Cristiano Denardi    ³ Data ³ 05.04.05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Busca Taxa em aTxMoedas e verifica se foi trocada          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa330TxMd( nMoeda2, nTx ,lAcrDes)

Local lExistTxMd	:= Type("aTxMoedas")#"U" .And. Len(aTxMoedas) > 0

Default nTx			:= 0
Default nMoeda2 	:= 0
Default lAcrDes		:= .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Estrutura aTxMoedas         ³
//³ [1] -> Nome Moeda          	³
//³ [2] -> Taxa a Ser Utilizada	³
//³ [3] -> Picture          	³
//³ [4] -> Taxa do dia atual    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If nMoeda2 > 0 .And. lExistTxMd .AND. (nMoeda2<>SE1->E1_MOEDA)
	If aTxMoedas[nMoeda2][2] <> aTxMoedas[nMoeda2][4] .and. (aTxMoedas[nMoeda2][2]<>0)
		nTx := aTxMoedas[nMoeda2][2]
	Elseif (nTx <> aTxMoedas[nMoeda2][4]) .and. (aTxMoedas[nMoeda2][4]<>0)
		nTx := aTxMoedas[nMoeda2][4]
	Endif
ELSEIF (nMoeda2==SE1->E1_MOEDA)
	// se a moeda do titulo principal é 2 e a do titulo posicionado tb, nao convertemos pois os valores serao expressos em U$
	If !lAcrDes
		nTx := 1
	Endif
Endif

Return( nTx )


/*/{Protheus.doc} Fa330Tx2
	Busca Taxa em aTxMoedas e verifica se foi trocada.
	Funcao copiada da Fa340TxMd pois a Fa330TxMd() não obtém
	resultado satisfatório para alguns casos de conversão.
	@type function
	@author Clovis Magenta
	@since 31.08.11
/*/
Static Function Fa330Tx2( nMoeda2 as Numeric, nTx as Numeric ) as Numeric

	Local lExistTxMd as Logical
	

	lExistTxMd := Type("aTxMoedas") != "U" .And. Len(aTxMoedas) > 0

	Default nTx := 0
	Default nMoeda2 := 0

	// Estrutura aTxMoedas         
	// [1] -> Nome Moeda          	
	// [2] -> Taxa a Ser Utilizada	
	// [3] -> Picture          	
	// [4] -> Taxa do dia atual    

	If nMoeda2 > 0 .And. lExistTxMd .And. (SE1->E1_TXMOEDA == 0 .Or. (__lCmTxCon .And. SE1->E1_TXMOEDA > 0)) 
		If aTxMoedas[nMoeda2][2] <> aTxMoedas[nMoeda2][4] .and. (aTxMoedas[nMoeda2][2]<>0)
			nTx := aTxMoedas[nMoeda2][2]
		ElseIf (nTx == 0)
			nTx := aTxMoedas[nMoeda2][4]
		EndIf
	EndIf

	If SE1->E1_TXMOEDA == 0 .And. nMoeda2 > 1
		If nTx <> __nTxMoedP .And. __nTxMoedP > 0
			nTx := __nTxMoedP
		EndIf
	EndIf 

Return( nTx )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Fin330ExCMºAutor  ³Clovis Magenta      º Data ³  07/02/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função que excluirá o registro de correção monetaria na SE5 º±±
±±º          ³ ao excluir uma compensacao                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fin330ExCM(cFilCmp, cSequen)
Local aArea 	:= GetArea()
Local aAreaSE5 	:= SE5->( GetArea() )
Local cChave	:= ""

DEFAULT cFilCmp := xFilial("SE5")
DEFAULT cSequen := SE5->E5_SEQ

SE5->(DbSetorder(7))
If SE5->( DbSeek(cFilCmp+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO) )
	cChave := cFilCmp+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO

	While cChave == SE5->(E5_FILIAL + E5_PREFIXO + E5_NUMERO + E5_PARCELA + E5_TIPO )
		If SE5->E5_TIPODOC $ "VM|CM" .AND. cSequen == SE5->E5_SEQ
			RecLock("SE5")
			DbDelete()
			MsUnLock()
		EndIf
		SE5->(DbSkip())
	EndDo
Endif

RestArea(aAreaSE5)
RestArea(aArea)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FINA330   ºAutor  ³Pâmela Bernardo     º Data ³  03/20/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função para recalcular o IR antes da geração do titulo de IRFº±±
±±º          ³na compensaçãdo de contas a receber                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Fina330                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FReCalIRB (aImpIr As Array, nValTot As Numeric, nTit As Numeric, lAutomato As Logical)
	Local lIrPjBxCr		As Logical
	Local nPropIR		As Numeric
	Local aAreaSE1 		As Array
	Local lAplMinIR		As Logical
	Local lIrfRetAnt	As Logical
	Local nBaseImpos    As Numeric
	
	//Inicializa variáveis.
	lIrPjBxCr	:= FIrPjBxCr(.T.)
	nPropIR		:= 0
	aAreaSE1 	:= SE1->(GetArea())
	lAplMinIR	:= SA1->A1_MINIRF == "2"
	lIrfRetAnt	:= .F.
	nBaseImpos  := 0
	
	If cPaisLoc == "BRA" .and. lIrPjBxCr .and. (!lCredito .or. (lCredito .and. lAutomato ))	
		If VldCalcImp(SE1->E1_BAIXA, SE1->E1_VALOR, SE1->E1_SALDO, @nBaseImpos, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), SE1->E1_FILORIG)
			nBaseImpos := IIf(nBaseImpos > 0, nBaseImpos, nValTot)
			nIrrf      := FCaIrBxCR(nBaseImpos)
		EndIf
		
		If (nPosIr:=ascan(aImpIR,{|x| x[2]=SE1->(REcno())}))=0
			aAdd(aImpIR,{nIrrf,SE1->(Recno())})
			nPosIr := Len( aImpIR )
		Else
			If lIrPjBxCr .And. nIrrf == 0 .And. nBaseImpos > 0 .And. aImpIR[nPosIr][1] > 0
				nIrrf := aImpIR[nPosIr][1] *(nBaseImpos/SE1->E1_VLCRUZ) 
			EndIf
			aImpIR[nPosIr][1]:= nIrrf
		EndIf

	Endif
	
	If cPaisLoc == "BRA" .and. lIrPjBxCr .and. lCredito .and. Valtype(aImpIr) == "A" .and. !(lCredito .and. lAutomato .and. !__lBq10925) //porporciona o calculo do IR quando não alcança o valor minimo de retenção 
		SE1->(MSGoto(aImpIr[nTit][2]))
		nPropIR 	:= nValTot/SE1->E1_VLCRUZ
		nIrrf		:= Round(NoRound(SE1->E1_IRRF * nPropIR,3),2)
		nIRFBase 	:= Round(NoRound(SE1->E1_BASEIRF * nPropIR,3),2)
		nIrfBaseC	:= nIRFBase
		nIrfCalc	:= nIrrf
	EndIf
	
	//Controle de retencao anterior no mesmo periodo
	lIrfRetAnt := Iif(nIrrf > GetMv("MV_VLRETIR"), .T., .F.)

	If lAplMinIR .and. !lIrfRetAnt .and. lIrPjBxCr
		nIrrf := 0
	Endif

	RestArea(aAreaSE1)
Return nIrrf

//-------------------------------------------------------------------
/*/{Protheus.doc}F330PsqFil

@author Totvs
@since  11/06/2019
@version 12
/*/
//-------------------------------------------------------------------

Function F330PsqFil(cFilSE1 As Character,cPrefixo As Character,cNum As Character,cParcela As Character,cCliFor As Character,cLoja As Character,cTipo As Character,cCarteira As Character,cTipoDoc As Character, cAliasCmp As Character,cTrabalho As Character)

	Local aArea 	As Array
	Local cQryAux 	As Character

	aArea 	:= GetArea()

	if Select(cAliasCmp) > 0
		(cAliasCmp)->(dbCloseArea())
	endif
	cQryAux := ""
	
	cQryAux	:= "SELECT DISTINCT E5_FILIAL "
	cQryAux += "FROM "+RetSqlName("SE5")+" "
	cQryAux += "WHERE E5_RECPAG = '"+cCarteira+"' "
	cQryAux += "AND E5_SITUACA <> 'C' "
	cQryAux += "AND E5_NUMERO   = '"+cNum+"' "
	cQryAux += "AND E5_PREFIXO  = '"+cPrefixo+"' "
	cQryAux += "AND E5_PARCELA  = '"+cParcela+"' "
	cQryAux += "AND E5_CLIFOR   = '"+cCliFor+"' "
	cQryAux += "AND E5_LOJA     = '"+cLoja+"' "
	If !Empty(cFilSE1) .And. cPaisLoc == "BRA"
		cQryAux += "AND E5_FILORIG  = '"+cFilSE1+"' "
	EndIf
	cQryAux += "AND E5_MOTBX    = 'CMP' "
	cQryAux += "AND E5_TIPODOC  = '"+cTipoDoc+"' "
	cQryAux += "AND D_E_L_E_T_  = ' ' "
	cQryAux += "ORDER BY E5_FILIAL "
	
	cQryAux := ChangeQuery(cQryAux)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQryAux),cAliasCmp,.T.,.T.)
	
	(cAliasCmp)->( dbGoTop() )
	
	RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³GetInfSE5 ³ Autor ³Clovis Magenta         ³ Data ³26.10.2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Pega as informações da SE5->E5_DOCUMEN e divide em partes   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aSE5: Array com as informações do SE5->E5_DOCUMEN           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cDoc: SE5->E5_DOCUMEN                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function GetInfSE5(cDoc)
Local nPrefixo 	:= __nTamPref
Local nNum		:= __nTamNum
Local nParcel	:= __nTamParc
Local nTipo		:= __nTamTipo
Local nLoja		:= __nTamLoja
Local nCont		:= 1
Local aSE5		:= {}
Local nx		:= 0

Default cDoc := ""

For nX:=1 to 6
    Do Case
    	Case nX == 1
			Aadd(aSE5,substr(cDoc,1,nPrefixo ) )
			nCont += nPrefixo
    	Case nX == 2
			Aadd(aSE5,substr(cDoc,nCont,nNum ) )
			nCont += nNum
    	Case nX == 3
			Aadd(aSE5,substr(cDoc,nCont,nParcel ) )
			nCont += nParcel
    	Case nX == 4
			Aadd(aSE5,substr(cDoc,nCont,nTipo ) )
			nCont += nTipo
     	Case nX == 5
			Aadd(aSE5,substr(cDoc,nCont,nLoja ) )
	EndCase

Next nX

Return aSE5

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³FaPesqBx2 ³ Autor ³Felipe Cunha            ³ Data ³19.10.2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Checa se a compensacao do titulo foi gerada no momento da   ³±±
±±³          ³emissao do documento.Parametros devem ser o do titulo       ³±±
±±³          ³principal (Tipo de titulo = MVNOTAFIS).                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a Compensacao foi realizada na geracao do  ³±±
±±³          ³Documento                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Filial do SE5                                        ³±±
±±³          ³ExpC2: Prefixo do titulo                                    ³±±
±±³          ³ExpC3: Numero do titulo                                     ³±±
±±³          ³ExpC4: Parcela do titulo                                    ³±±
±±³          ³ExpC5: Cliente/Fornecedor do titulo                         ³±±
±±³          ³ExpC6: Loja do titulo                                       ³±±
±±³          ³ExpC7: Tipo da baixa                                        ³±±
±±³          ³ExpD8: Data de emissao do titulo                            ³±±
±±³          ³ExpC9: Sequencia da baixa                                   ³±±
±±³          ³ExpC10: Carteira da baixa "R"/"P"                           ³±±
±±³          ³ExpC11: Numero do documento                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Esta rotina eh usada no contas a receber a pagar.           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function FaPesqBx2(cFilSE5,cPrefixo,cNum,cParcela,cCliFor,cLoja,cTipo,dDataE,cSeq,cCarteira,cDocumen,cTipoDoc,cIdOgE5)

Local aArea 	:= GetArea()
Local cQryAux 	:= ""
Local cQryFk1   := ""
Local cQryFK7   := ""
Local cFilorig 	:= ''
Local cTrabalho	:= ""
Local cSecFk1   := ""
Local cSecFk7   := ""
Default cIdOgE5 := ""

if cPaisLoc != "MEX" .And. !Empty(cIdOgE5) 
    
    if __QryFk1 == Nil
		cQryFk1  := "SELECT FK1_IDCOMP "
		cQryFk1  += "FROM "+RetSqlName("FK1")+" "
		cQryFk1  += "WHERE FK1_IDFK1 = ? "
		cQryFk1  += "AND D_E_L_E_T_  = ' '  "
		cQryFk1  += "ORDER BY FK1_FILIAL,FK1_SEQ"
		cQryFk1  := ChangeQuery(cQryFk1)
		__QryFk1 := FWPreparedStatement():New(cQryFk1)
    endif 

    __QryFk1:SetString(1, cIdOgE5)

	cQryFk1  := __QryFk1:GetFixQuery()
	cSecFk1 := MpSysExecScalar(cQryFk1, "FK1_IDCOMP")
	

	If !Empty(cSecFk1)
		
		if __QryFk7 == Nil 
			cQryFK7  := "SELECT FK7_FILTIT "
			cQryFk7  += "FROM "+RetSqlName("FK7")+" "
			cQryFk7  += "WHERE FK7_IDDOC = ? "
			cQryFk7  += "AND D_E_L_E_T_  = ' '  "
			cQryFk7  := ChangeQuery(cQryFk7)
			__QryFk7 := FWPreparedStatement():New(cQryFk7)
        endif

		__QryFk7:SetString(1,cSecFk1)

		cQryFk7  := __QryFk7:GetFixQuery()
	    cSecFk7 := MpSysExecScalar(cQryFk7, "FK7_FILTIT")

		cFilOrig := cSecFk7
		
	EndIf

	RestArea(aArea)

else 
	// localiza as baixa para o titulo principal por ordem de sequencia, para comparar com a quantidade de baixas ocorridas no momento da geracao do documento
	cQryAux	:= "SELECT E5_FILORIG, E5_FILIAL "
	cQryAux += "FROM "+RetSqlName("SE5")+" "
	cQryAux += "WHERE E5_SEQ = '"+cSeq+"' "
	cQryAux += "AND E5_RECPAG   = '"+cCarteira+"' "
	cQryAux += "AND E5_SITUACA <> 'C' "
	cQryAux += "AND E5_DATA 	= '"+dTos(dDataE)+"' "
	cQryAux += "AND E5_NUMERO   = '"+cNum+"' "
	cQryAux += "AND E5_PREFIXO  = '"+cPrefixo+"' "
	cQryAux += "AND E5_PARCELA  = '"+cParcela+"' "
	cQryAux += "AND E5_CLIFOR   = '"+cCliFor+"' "
	cQryAux += "AND E5_LOJA     = '"+cLoja+"' "
	cQryAux += "AND E5_MOTBX    = 'CMP' "
	cQryAux += "AND E5_TIPODOC  = '"+cTipoDoc+"' "
	cQryAux += "AND D_E_L_E_T_  = ' ' "
	cQryAux += "ORDER BY E5_FILIAL,E5_SEQ "
	cQryAux := ChangeQuery(cQryAux)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQryAux),"__TRBSE5",.T.,.T.)

	If __TRBSE5->(!EOF())
		If Empty( __TRBSE5->E5_FILORIG ) .And. cPaisLoc == "MEX"
			cFilorig := __TRBSE5->E5_FILIAL
		Else
			cFilorig := __TRBSE5->E5_FILORIG
		EndIF
	EndIf

	__TRBSE5->(DbCloseArea())
	RestArea(aArea)
endif 

If cTrabalho <> Nil .and. !Empty(cTrabalho)
	Ferase(cTrabalho+GetDBExtension())
	Ferase(cTrabalho+OrdBagExt())
EndIf

Return(cFilorig)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FINA330   ºAutor  ³TOTVS          º Data ³  05/15/13  	 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³  Acumula os impostos para compor o aTitulos                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA330                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function F330RaRtIm(aDadosRA1,cValDig,nItemRA,nItemOU, lAltValor)

Local aArea	  		:= GetArea()
Local lRet			:= .T.
Local nBaseRA  		:= 0
Local nSaldoRA 		:= 0
Local nPisRA		:= 0
Local nCofRA		:= 0
Local nCslRA		:= 0
Local nIrfRA		:= 0
Local nBasOUIr		:= 0
Local nBasOUPis 	:= 0
Local nBasOUCof 	:= 0
Local nBasOUCsl 	:= 0
Local nBasOUIns 	:= 0
Local nBasOUIss 	:= 0
Local nSaldoOU 		:= 0
Local nPisOU		:= 0
Local nCofOU		:= 0
Local nCslOU		:= 0
Local nIrfOU		:= 0
Local nPrIsRA		:= 0     // Provisionamento de ISS e INSS
Local nPrIsOU		:= 0     // Provisionamento de ISS e INSS
Local nPrInRA		:= 0     // Provisionamento de ISS e INSS
Local nPrInOU		:= 0     // Provisionamento de ISS e INSS
Local nTxIr 		:= 1
Local nTxPis 		:= 1
Local nTxCof		:= 1
Local nTxCsl		:= 1
Local nTxIns		:= 1
Local nTxIss		:= 1
Local nTxSaldo		:= 1
Local ni 			:= 0
Local nItLcRA		:= 0
Local nItLcOU		:= 0
Local nSaldoCMP		:= 0
Local nProp			:= 1
Local nPropPis		:= 1
Local nPropCof		:= 1
Local nPropCsl		:= 1
Local nPropIr		:= 1
Local nPropIss		:= 1
Local nPropIns		:= 1
Local nMoedaRA		:= 0
Local nTxConv       := 0

Default cValDig	:= 0
Default nItemRA	:= 0
Default nItemOU	:= 0
Default lAltValor := .F.

If nItemRA <> 0
	nItLcRA := nItemRA
Else
	nItLcRA := Len(aDadosRA1[1])
EndIf

If aDadosRA1[1][nItLcRA] <> 0
	SE1->(dbGoto(aDadosRA1[1][nItLcRA]))
	If SE1->E1_SALDO <> SE1->E1_VALOR //indica que houve baixa parcial
		nProp := SE1->E1_SALDO/SE1->E1_VALOR
	EndIf
	nBaseRA 	:= SE1->E1_BASEIRF * nProp
	nSaldoRA 	:= SE1->E1_SALDO
	nMoedaRA	:= SE1->E1_MOEDA
	If lRaRtImp .And. cPaisLoc == "BRA"
		nSaldoRA += (SE1->E1_PRISS * nProp)+ (SE1->E1_PRINSS* nProp)
		nPrIsRA  := SE1->E1_PRISS * nProp
		nPrInRA	 := SE1->E1_PRINSS * nProp
	EndIf

	If lCredito
		nSaldoCMP := SE1->E1_SALDO
	EndIf

	If cValDig <> 0 .and. cValDig <> nSaldoRA .and. lAltValor
		nSaldoRA := xMoeda(cValdig,nMoeda,nMoedaRA,dBaixa,__nCasDec,nTxMoeda)
	EndIf

	SE5->(dbSetOrder(2))
	SE5->(dbSeek( xFilial("SE5")+"RA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
	While (SE5->(!Eof()) .and. xFilial("SE5") == SE5->E5_FILIAL .And.	;
			SE5->E5_TIPODOC == "RA" .And. 				;
			SE5->E5_PREFIXO == SE1->E1_PREFIXO .And.				;
			SE5->E5_NUMERO == SE1->E1_NUM .And.					;
			SE5->E5_PARCELA == SE1->E1_PARCELA )

		If SE5->E5_RECPAG != "R"
			SE5->(dbSkip())
			Loop
		EndIf

		//Verifica se tem baixa cancelada
		If TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T.,SE5->E5_FILIAL,,,SE5->E5_FILORIG)
			SE5->(dbskip())
			Loop
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica Cliente 	³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SE5->E5_CLIFOR != SE1->E1_CLIENTE
			SE5->(dbSkip( ))
			Loop
		EndIf

		If SE5->E5_PRETPIS <> " "
			nPisRA		:= 0
		Else
			nPisRA		:= SE5->E5_VRETPIS * nProp
		EndIf
		If SE5->E5_PRETCSL <> " "
			nCslRA		:= 0
		Else
			nCslRA		:= SE5->E5_VRETCSL* nProp
		EndIf
		If SE5->E5_PRETCOF <> " "
			nCofRA		:= 0
		Else
			nCofRA		:= SE5->E5_VRETCOF* nProp
		EndIf
		If SE5->E5_PRETIRF <> " "
			nIrfRA		:= 0
		Else
			nIrfRA		:= SE5->E5_VRETIRF	* nProp
		EndIf

		Exit

	Enddo

	If Len(aDadosRA1[8]) > 0 .and. lCredito
		For ni := 1 to Len(aDadosRA1[8])
			nSaldoCMP -= aDadosRA1[8][ni]
		Next ni
	EndIf

	If Round(nSaldoRa+nPisRA+nCofRA+nCslRA+nIrfRA,2) <> Round(nBaseRA,2) .and. nBaseRA <> 0
		nTxSaldo	:= nSaldoRA/nBaseRA//-(nPisRA+nCofRA+nCslRA+nIrfRA)))
		nPisRA		:= Round(nPisRA*nTxSaldo,2)
		nCofRA		:= Round(nCofRA*nTxSaldo,2)
		nCslRA		:= Round(nCslRA*nTxSaldo,2)
		nIrfRA		:= Round(nIrfRA*nTxSaldo,2)
		nPrIsRA		:= Round(nPrIsRA*nTxSaldo,2)
		nPrInRA		:= Round(nPrInRA*nTxSaldo,2)
		nBaseRA		:= nSaldoRa//+nPisRA+nCofRA+nCslRA+nIrfRA+nPrIsRA+nPrInRA)
	EndIf

	If nItemOU <> 0
		nItLcOU := nItemOU
	Else
		nItLcOU := Len(aDadosRA1[2])
	EndIf

	If lRaRtImp .and. !lAltValor .And. cPaisLoc == "BRA"
		nSaldoRA -= (SE1->E1_PRISS*nProp)+ (SE1->E1_PRINSS *nProp)
	EndIf
	nProp:=1
	If aDadosRA1[2][nItLcOU] <> 0 
		SE1->(dbGoto(aDadosRA1[2][nItLcOU]))
		If SE1->E1_SALDO <> SE1->E1_VALOR .And. nItemRA <> 0 //indica que houve baixa parcial			
			nPropPis	:= SE1->E1_SALDO/SE1->E1_BASEPIS
			nPropCof	:= SE1->E1_SALDO/SE1->E1_BASECOF
			nPropCsl	:= SE1->E1_SALDO/SE1->E1_BASECSL
			nPropIr		:= SE1->E1_SALDO/SE1->E1_BASEIRF
			nPropIss	:= SE1->E1_SALDO/SE1->E1_BASEISS
			nPropIns	:= SE1->E1_SALDO/SE1->E1_BASEINS
		EndIf

		nTxConv     := Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)
		nBasOUPis 	:= xMoeda(SE1->E1_BASEPIS,SE1->E1_MOEDA,1,dBaixa,__nCasDec,nTxConv) * nPropPis
		nBasOUCof 	:= xMoeda(SE1->E1_BASECOF,SE1->E1_MOEDA,1,dBaixa,__nCasDec,nTxConv) * nPropCof
		nBasOUCsl 	:= xMoeda(SE1->E1_BASECSL,SE1->E1_MOEDA,1,dBaixa,__nCasDec,nTxConv) * nPropCsl
		nBasOUIr 	:= xMoeda(SE1->E1_BASEIRF,SE1->E1_MOEDA,1,dBaixa,__nCasDec,nTxConv) * nPropIr		
		nBasOUIss 	:= xMoeda(SE1->E1_BASEISS,SE1->E1_MOEDA,1,dBaixa,__nCasDec,nTxConv) * nPropIss
		nBasOUIns 	:= xMoeda(SE1->E1_BASEINS,SE1->E1_MOEDA,1,dBaixa,__nCasDec,nTxConv) * nPropIns

		If MV_PAR08 == 1
			If !lRaRtImp .And. !__lRaRtPcc .And. !__lRaRtIrf
				nSaldoOU	:= SE1->E1_SALDO-(SE1->(E1_PIS+E1_COFINS+E1_CSLL+E1_IRRF)*nProp)
			Else
				nSaldoOU	:= SE1->E1_SALDO	
			EndIf
		Else
			nSaldoOU	:= SE1->E1_SALDO
		EndIf
		nPisOU		:= SE1->E1_PIS * nPropPis
		nCofOU		:= SE1->E1_COFINS * nPropCof
		nCslOU		:= SE1->E1_CSLL * nPropCsl
		nIrfOU		:= SE1->E1_IRRF * nPropIr
		
		If lRaRtImp
			If !lCredito
				nSaldoOU -= ((SE1->E1_ISS* nProp)+ (SE1->E1_INSS* nProp))
			EndIf
			nPrIsOU	 := SE1->E1_ISS * nProp
			nPrInOU	 := SE1->E1_INSS* nProp
		EndIf

		If !lCredito .And. !lRaRtImp .And. !IsInCallStack("FA330Troca")
			nSaldoCMP := SE1->E1_SALDO-SE1->(E1_PIS+E1_COFINS+E1_CSLL+E1_IRRF)
		ElseIf !lCredito
		 	nSaldoCMP := SE1->E1_SALDO
		EndIf

		If cValDig <> 0 .and. cValDig <> nSaldoOU .and. lAltValor
			nSaldoOU := xMoeda(cValdig,nMoeda,nMoedaRA,dBaixa,__nCasDec,SE1->E1_TXMOEDA)
		EndIf

		If Len(aDadosRA1[8]) > 0 .and. !lCredito
			For ni := 1 to Len(aDadosRA1[8])
				If aDadosRA1[1][nItLcRA] <> aDadosRA1[1][ni] .And. aDadosRA1[9][ni]
					If aTitulos[ni][9] == aDadosRA1[8][ni]
						nSaldoCMP -= aDadosRA1[8][ni] + aDadosRA1[3][ni] + aDadosRA1[4][ni] + aDadosRA1[5][ni] + aDadosRA1[6][ni] + aDadosRA1[10][ni] + aDadosRA1[11][ni]
					Else
						nSaldoCMP -= aDadosRA1[8][ni]
					EndIf 	
				EndIf 		 
			Next ni
		EndIf
		
		If cValDig <> 0 .and. cValDig <> nSaldoRA .And. lRaRtImp .And. IsInCallStack("FA330Troca") .and. !lCredito .and. lAltValor
			nBaseRA:= xMoeda(cValdig,nMoeda,nMoedaRA,dBaixa,__nCasDec,SE1->E1_TXMOEDA)
		EndIf 	

		If lCredito
			nTxPis 		:= IIF( (nBasOUPis/nBaseRA) > 1 , 1 , (nBasOUPis/nBaseRA) )
			nTxCof		:= IIF( (nBasOUCof/nBaseRA) > 1 , 1 , (nBasOUCof/nBaseRA) )
			nTxCsl		:= IIF( (nBasOUCsl/nBaseRA) > 1 , 1 , (nBasOUCsl/nBaseRA) )
			nTxIr 		:= IIF( (nBasOUIr/nBaseRA)  > 1 , 1 , (nBasOUIr/nBaseRA)  )
			nTxIss		:= IIF( (nBasOUIss/nBaseRA) > 1 , 1 , (nBasOUIss/nBaseRA) )
			nTxIns		:= IIF( (nBasOUIns/nBaseRA) > 1 , 1 , (nBasOUIns/nBaseRA) )				
		Else
			nTxPis 		:= IIF( (nBaseRA/nBasOUPis) > 1 , 1 , (nBaseRA/nBasOUPis) )
			nTxCof		:= IIF( (nBaseRA/nBasOUCof) > 1 , 1 , (nBaseRA/nBasOUCof) )
			nTxCsl		:= IIF( (nBaseRA/nBasOUCsl) > 1 , 1 , (nBaseRA/nBasOUCsl) )
			nTxIr 		:= IIF( (nBaseRA/nBasOUIr)  > 1 , 1 , (nBaseRA/nBasOUIr)  )
			nTxIss		:= IIF( (nBaseRA/nBasOUIss) > 1 , 1 , (nBaseRA/nBasOUIss) )
			nTxIns		:= IIF( (nBaseRA/nBasOUIns) > 1 , 1 , (nBaseRA/nBasOUIns) )			
		EndIf

		If lCredito
			nPisOU		:= If(nPisRA<>0,Round(nPisRA*nTxPis,2),Round(nPisOU*nTxPis,2))
			nCofOU		:= If(nCofRA<>0,Round(nCofRA*nTxCof,2),Round(nCofOU*nTxCof,2))
			nCslOU		:= If(nCslRA<>0,Round(nCslRA*nTxCsl,2),Round(nCslOU*nTxCsl,2))
			nIrfOU		:= If(nIrfRa<>0 .Or. ( !__lIrfMR .And. lCredito .And. nBaseRA <= SE1->E1_SALDO ),Round(nIrfRA*nTxIr,2),Round(nIrfOU*nTxIr,2))
			nPrIsOU		:= If(nPrIsRA<>0,Round(nPrIsRA*nTxIss,2),Round(nPrIsOU*nTxIss,2))
			nPrInOU		:= If(nPrInRA<>0,Round(nPrInRA*nTxIns,2),Round(nPrInOU*nTxIns,2))
			If !__lIrfMR .Or. ( __lIrfMR .And. nIrfOU < 0 )
				If (SA1->A1_MINIRF == "2" .And. (nIrfOU <= SuperGetMv("MV_VLRETIR",.T.,10)) ) .OR. nIrfOU < 0
					nIrfOU	:= 0
				EndIf
			EndIf
		Else
			nPisRA		:= If(nPisOU<>0,Round(nPisOU*nTxPis,2),Round(nPisRA*nTxPis,2)) 
			nCofRA		:= If(nCofOU<>0,Round(nCofOU*nTxCof,2),Round(nCofRA*nTxCof,2))
			nCslRA		:= If(nCslOU<>0,Round(nCslOU*nTxCsl,2),Round(nCslRA*nTxCsl,2))
			nIrfRA		:= If(nIrfOU<>0,Round(nIrfOU*nTxIr,2),Round(nIrfRA*nTxIr,2))
			nPrIsRA		:= If(nPrIsOU<>0,Round(nPrIsOU*nTxIss,2),Round(nPrIsRA*nTxIss,2))
			nPrInRA		:= If(nPrInOU<>0,Round(nPrInOU*nTxIns,2),Round(nPrInRA*nTxIns,2))
			If (SA1->A1_MINIRF == "2" .And. (nIrfRA <= SuperGetMv("MV_VLRETIR",.T.,10)) ) .OR. nIrfRA < 0
				nIrfRA	:= 0
			EndIf
			
		EndIf
	Else
		lRet := .F.
	EndIf
Else
	lRet := .F.
EndIf

If lCredito
	nTxConv  := Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)
	nSaldoOU -= xMoeda(nPisOU, 1, SE1->E1_MOEDA, dBaixa, __nCasDec, 0, nTxConv)
	nSaldoOU -= xMoeda(nCofOU, 1, SE1->E1_MOEDA, dBaixa, __nCasDec, 0, nTxConv)
	nSaldoOU -= xMoeda(nCslOU, 1, SE1->E1_MOEDA, dBaixa, __nCasDec, 0, nTxConv)
	nSaldoOU -= xMoeda(nIrfOU, 1, SE1->E1_MOEDA, dBaixa, __nCasDec, 0, nTxConv)
	nSaldoOU -= xMoeda(nPrIsOU, 1, SE1->E1_MOEDA, dBaixa, __nCasDec, 0, nTxConv)
	nSaldoOU -= xMoeda(nPrInOU, 1, SE1->E1_MOEDA, dBaixa, __nCasDec, 0, nTxConv)
ElseIf !(lRaRtImp .And. cValDig <> 0 .and. cValDig == nSaldoOU)
	nSaldoOU -= (nPisRA+nCofRA+nCslRA+nIrfRA+nPrIsRA+nPrInRA) 
EndIf

If lRet

	If lCredito
		If nItemOU <> 0
			aDadosRA1[3][nItLcOU] := nPisOU
			aDadosRA1[4][nItLcOU] := nCofOU
			aDadosRA1[5][nItLcOU] := nCslOU
			aDadosRA1[6][nItLcOU] := nIrfOU
			aDadosRA1[7][nItLcOU] := nSaldoOU
			aDadosRA1[8][nItLcOU] := If(aDadosRA1[7][nItLcOU]>nSaldoRA,nSaldoRA,aDadosRA1[7][nItLcOU])
			aDadosRA1[10][nItLcOU]:= nPrIsRA
			aDadosRA1[11][nItLcOU]:= nPrInRA

		Else
			aAdd(aDadosRA1[3],nPisOU)
			aAdd(aDadosRA1[4],nCofOU)
			aAdd(aDadosRA1[5],nCslOU)
			aAdd(aDadosRA1[6],nIrfOU)
			aAdd(aDadosRA1[7],nSaldoOU)
			aAdd(aDadosRA1[8],If(aDadosRA1[7][Len(aDadosRA1[7])]>nSaldoRA,nSaldoRA,aDadosRA1[7][Len(aDadosRA1[7])]))
			aAdd(aDadosRA1[10],nPrIsRA)
			aAdd(aDadosRA1[11],nPrInRA)
		EndIf
	Else
		If nItemRA <> 0
			aDadosRA1[3][nItLcRA] := nPisRA
			aDadosRA1[4][nItLcRA] := nCofRA
			aDadosRA1[5][nItLcRA] := nCslRA
			aDadosRA1[6][nItLcRA] := nIrfRA
			aDadosRA1[7][nItLcRA] := nSaldoRA
			aDadosRA1[8][nItLcRA] := If(aDadosRA1[7][nItLcRA]>nSaldoOU,nSaldoOU,aDadosRA1[7][nItLcRA])
			aDadosRA1[10][nItLcRA]:= nPrIsRA
			aDadosRA1[11][nItLcRA]:= nPrInRA

		Else
			aAdd(aDadosRA1[3],nPisRA)
			aAdd(aDadosRA1[4],nCofRA)
			aAdd(aDadosRA1[5],nCslRA)
			aAdd(aDadosRA1[6],nIrfRA)
			aAdd(aDadosRA1[7],nSaldoRA)
			aAdd(aDadosRA1[8],If(aDadosRA1[7][Len(aDadosRA1[7])]>nSaldoOU,nSaldoOU,aDadosRA1[7][Len(aDadosRA1[7])]))
			aAdd(aDadosRA1[10],nPrIsRA)
			aAdd(aDadosRA1[11],nPrInRA)

		EndIf
	EndIf

EndIf

RestArea(aArea)

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FA330Fil  ºAutor  ³Microsiga           ºFecha ³ 08/07/2013  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Permite determinar as filias para selecao dos titulos       º±±
±±º          ³para liquidacao.                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Fa330Fil() As Array
	Local aRet	As Array
	Local lTudoComp As Logical

	lTudoComp := AllTrim(FwXFilial("SE2")) == ""
	__lUsaFil := .F.
	
	aRet	:= {}

	If MsgYesNo(STR0066 + " " + STR0067 + CRLF + CRLF + STR0068 + CRLF + CRLF + STR0069,STR0018)
		//"Serão selecionados somente os títulos das filiais escolhidas." + " " + "Se nenhuma for escolhida serão considerados somente os da filial corrente." + CRLF + CRLF + "Importante: Algumas entidades, como clientes, bancos etc, podem possuir um código na filial A, porém na filial B, esse mesmo código não necessariamente representa a mesma entidade." + CRLF + CRLF + "Deseja continuar com a seleção de filiais?"
		aRet := AdmGetFil(.F.,.T., "SE1", /*lSohFilUn*/, /*lHlp*/, /*lExibTela*/, lTudoComp)
		__lUsaFil := !Empty(aRet)
	Else
		aRet := {}
	EndIf

Return(Aclone(aRet))

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FINA330   ºAutor  TOTVS		         º Data ³  07/23/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Recompor Valor de compensação, nSaldo, limite de compensaçãoº±±
±±º          ³ quando marcado uma NCC para compensação                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA330                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function F330VALNCC(aArray As Array, nX As Numeric, lAltValor As Logical, lSoma As Logical)

	Local nProp		As Numeric
	Local nLim 		As Numeric
	Local nPos 		As Numeric
	Local nImpBx 	As Numeric
	
	nProp	:= 0
	nLim 	:= 0
	nPos 	:= 0
	nImpBx 	:= 0
	
	nPis	:= 0
	nCofins	:= 0
	nCsll	:= 0
	nIrrf	:= 0

	DEFAULT nX 			:= 1
	DEFAULT lAltValor 	:= .F.
	DEFAULT aArray		:= {}
	DEFAULT lSoma		:= .F.
	
	If MV_PAR02 == 2
		nPos := 25
	Else
		nPos := 22
	EndIf
	If MV_PAR08 == 1
		nImpBx := nTotImpbx-nIss-nInss
	Else
		nImpBx := nTotImpbx
	EndIf
	
	If lAltValor
		nProp:=  aTitulos[nX,9]/SE1->E1_VALOR
	Else
	    If aArray[nX,(nPos+1)]< SE1->E1_VALOR
			nProp:= aTitulos[nX,(nPos+1)]/SE1->E1_VALOR
		Else
			nProp:=  1
		EndIf
	EndIf
	If lSoma
		nLim := Fa330VTit(aArray[nX,Iif(cPaisLoc != "RUS",nPos,6)])
		nSaldo+= nImpBx*nProp
		nLim += nImpBx *nProp
		If nLim <= aArray[nX,(nPos-1)]
			aArray[nX,nPos]:= Transf(nLim,__cPiE1Sld)
		Endif
	
	Else
		nLim := Fa330VTit(aArray[nX,Iif(cPaisLoc != "RUS",nPos,6)])
		nSaldo-= nImpBx *nProp
		nLim -= nImpBx *nProp
		If nLim <= aArray[nX,(nPos-1)]
			aArray[nX,nPos]:= Transf(nLim,__cPiE1Sld)
		EndIf
	EndIf

Return

//------------------------------------------------------------------------------------------------------------------------
//	Função	| FA330RetPCC()
//	Autor	| Pedro Pereira Lima
//	Data	| 21/01/2014
//	Uso		| Utilizada para retornar o valor total dos títulos de impostos PIS, COFINS e CSLL gerados na baixa
//	-		| e que estão com o campo E1_TIPO preenchido como "COF", "CSL" e "PIS", ao invés de "CF-", "CS-" e "PI-"
//------------------------------------------------------------------------------------------------------------------------
Function FA330RetPCC(cPrefixo,cNum,cParcela,nMoeda,dData)

Local cFilAbat		:= xFilial("SE1")
Local bWhile		:= {|| !Eof() .And. E1_FILIAL == cFilAbat .And. E1_PREFIXO == cPrefixo .And. E1_NUM == cNum .And. E1_PARCELA == cParcela}
Local nTotImp		:= 0
Local cCliLj		:= SE1->(E1_CLIENTE+E1_LOJA)
Local cTipo			:= SE1->E1_TIPO
Local aArea			:= GetArea()
Local lRaRtImp  	:= FRaRtImp()

Default cPrefixo	:= ""
Default cNum		:= ""
Default cParcela	:= ""
Default nMoeda		:= 0
Default dData		:= dDataBase

If Empty(cPrefixo) .And. Empty(cNum) .And. Empty(cParcela)
	RestArea(aArea)
	Return nTotImp
EndIf

DbSelectArea("SE1")

If  (nOrdTitPai:= OrdTitpai()) > 0
	DbSetOrder(nOrdTitPai)
	If	DbSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+cTipo+cCliLj)   
		bWhile := {|| !Eof() .And. E1_FILIAL + AllTrim(E1_TITPAI) ==  cFilAbat+Alltrim(cPrefixo+cNum+cParcela+cTipo+cCliLj)}
	Else
		DbSetOrder(1)
		DbSeek(cFilAbat+cPrefixo+cNum+cParcela)
	Endif
Endif

While Eval(bWhile)
	If !Empty(E1_TITPAI) .And. (Alltrim(E1_TITPAI) != Alltrim(cPrefixo+cNum+cParcela+cTipo+cCliLj))
		DbSkip()
		Loop
	EndIf
	
	If E1_CLIENTE+E1_LOJA == cCliLj .And. !(lRartimp .And. cTipo $ MVRECANT)
		If E1_TIPO $ "COF|CSL|PIS"
			nTotImp += xMoeda(E1_VALOR,E1_MOEDA,nMoeda,dData,,,0)
		EndIf
	EndIf
	
	DbSkip()
	
EndDo

RestArea(aArea)
Return nTotImp  

/*/{Protheus.doc} fA330Grv
	Responsável por atualizar a baixa efetuada
	
	@author Valter G. Nogueira Jr
	@since 21/03/94)
/*/
Function fA330Grv(lPadrao,nValor,cAdiantamento,cSeq,nRegCmp,aBaixas,cOrigem,lCredito,nContab,;
					nAcresc,nDecres,aBaixaSE5,nTotAbto,aImpPcc,cSequencia,cDadosTitulo,nIrrf,ntotIrbx,;
					nPrIss, nPrInss, lNcc, nDescP, nDescD, nIrrfParc, nValLim, nValVa, nRegSe5Ori, lVMd2ImpRA, lVldSeq)
	Local nSaldo		:= 0
	Local nSalvRec		:= 0
	Local nAtraso		:= 0
	Local nTitAcres		:= SE1->E1_SDACRES		//Acrescimo do titulo principal
	Local nTitDecre		:= SE1->E1_SDDECRE		//Decrescimo do titulo principal
	Local nVlMinImp 	:= GetNewPar("MV_VL10925",5000)
	Local lRaRtImp		:= FRaRtImp()
	Local lPccBxCr		:= FPccBxCr()
	Local lIrPjBxCr		:= FIrPjBxCr()
	Local cCliente		:= ""
	Local cLoja			:= ""
	Local nTamSeq		:= __nTamSeq
	Local nDecs1 		:= MsDecimais(1)
	Local nVrAbat		:= 0
	Local lFina330  	:= IsInCallStack("FINA330")
	Local lCompRa		:=	.F.
	Local lTitpaiSE1	:= .T.
	Local cTipo 		:= ""
	Local nOrdTitPai	:= 0
	Local bWhile		:= {|| !EOF() .And. E1_FILIAL==xFilial("SE1") .And. E1_PREFIXO=cPrefixo	.And.	E1_NUM==cNum .And. E1_PARCELA==cParcela .And. E1_CLIENTE==cCliente .And. E1_LOJA==cLoja}
	Local cTipoAux		:= ""
	Local xFilSE1		:= SE1->E1_FILIAL
	Local nPisFin061	:=	0
	Local nCofFin061	:=	0
	Local nCslFin061	:=	0
	Local nIrfFin061	:=	0
	Local nRegSE5		:=	0
	Local nOrdSE5		:=	0
	Local nX			:=	0
	Local nPosRec     	:= 0
	Local aPcc			:= {.F.,0,0,0,{}}
	Local ntitulo1		:= 0
	Local nI			:= 0
	Local aAreaSE		:= {}
	Local cChave
	Local nPropPCC		:= 0
	Local lCalcIssBx 	:=  GetNewPar("MV_MRETISS","1") == "2"
	Local lRaRtImpMR 	:= .F.
	Local lIrfBxAux 	:= lIrPjBxCr
	Local lPccBxAux 	:= lPccBxCr
	Local cSaldoAux 	:= ""
	Local nBaseImp		:= 0
	Local nSaldoVa		:= 0
	Local nMVToler		:= SuperGetMv("MV_TOLERPG",,0.01)
	Local nToler		:= IF(nMVToler==0,0.01,nMVToler)
	Local lAjstSld		:= .F.
	Local cIdDocFK7     := ""
	Local cChaveTit     := ""

	DEFAULT cOrigem		:= "  "
	DEFAULT lCredito	:= .F.
	DEFAULT nContab		:= 1			//1=Sim, 2=Nao
	DEFAULT nAcresc		:= 0
	DEFAULT nDecres		:= 0
	DEFAULT aBaixaSE5	:= {}
	DEFAULT nTotAbto	:= SumAbatRec(cPrefixo,cNum,cParcela,SE1->E1_MOEDA,"S",dBaixa)
	DEFAULT aImpPcc		:= {0,0,0}
	DEFAULT cSequencia	:= Replicate("0",nTamSeq)
	DEFAULT nIrrf		:= 0     
	DEFAULT ntotIrbx	:= 0    
	DEFAULT nPrIss		:= 0 // Provisionamento do INSS e ISS no RA
	DEFAULT nPrInss		:= 0 // Provisionamento do INSS e ISS no RA
	DEFAULT lNcc		:= .F.
	DEFAULT nDescP  	:= 0
	DEFAULT nDescD  	:= 0
	DEFAULT nIrrfParc 	:= 0
	Default nValLim 	:= 0
	Default nValVa	  	:= 0
	Default nRegSe5Ori	:= 0 
	Default lVMd2ImpRA 	:= .F.
	Default lVldSEQ		:= .F.
	
	//Motor de retenções
	If __lMotRet
		//Verifica as configurações de impostos pelo motor de retenção
		__cOldMRCf  := "" 
		__lTCnfgMR := F330VldImp()
		
		lRaRtImpMR := ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
		lPccBxCr := ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
		lIrPjBxCr := ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
		
		//Calcula os impostos pelo motor de retenções
		If __lTCnfgMR
			nBaseImp := FBaseImp(nValor)
			F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, nBaseImp, dDataBase, SE1->E1_TIPO )
			__lTCnfgMR	:= .F.
		EndIf
	EndIf
	
	__cToler	:= ""
	aPcc[1]		:= .F.

	If dDataBase >= dLastPcc
		nVlMinImp	:= 0
	EndIf
	
	nDescP  := If(Type("nDescP") != "N",0,nDescP)
	nDescD  := If(Type("nDescD") != "N",0,nDescD)
	nValor 	:= xMoeda(nValor,nMoeda,SE1->E1_MOEDA,,nDecs1+1,__nTxMoedP)
	nVrAbat	:=	nTotAbto
	
	If !lNcc
		nTotAbto += iif( lPccBxCr, nPis + nCofins + nCsll, 0 )
		nTotAbto -= iif( ( lRartImp  .Or. lRaRtImpMR ) .And. lCredito, nPis + nCofins + nCsll, 0 )
		nTotAbto += iif( lIrPjBxCr .And. !lCredito, nIrrf, 0 )
	Endif

	nRegSE5	:=	SE5->(Recno())
	nOrdSE5	:=	SE5->(IndexOrd())		
	
	If SE1->E1_TIPO <> MVRECANT .And. SE1->E1_TIPO <> MV_CRNEG .And. (lPccBxCr .Or. lIrPjBxCr)
		dbSelectArea("SE5")
		SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
		If SE5->(dbSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
			While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
				SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
			
				If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
					If Alltrim(SE5->E5_MOTBX) == "PCC"
					nPisFin061	+= SE5->E5_VRETPIS
					nCofFin061	+= SE5->E5_VRETCOF
					nCslFin061	+= SE5->E5_VRETCSL
					ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
					nIrfFin061	+= SE5->E5_VRETIRF
					EndIf
				Endif					
				SE5->(DbSkip())		
		EndDo
		EndIf
	EndIf
	
	SE5->(Dbgoto(nRegSE5))
	SE5->(Dbsetorder(nOrdSE5))
	
	If ((SE1->E1_SALDO + nTitAcres - nTitDecre - If((mv_par08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR ) ) .And. !lCredito,nTotAbto,0)) - nValor) <= nToler
		nSaldo := (SE1->E1_SALDO + nTitAcres - nTitDecre - nDescP - If(((mv_par08 == 1 .AND. !lPccBxCr) .Or. ( lRaRtImp .Or. lRaRtImpMR ) ),nTotAbto,0) ) - nValor	// moeda do tit principal
		If nTotAbto <> 0
			nSaldo 		:= 0
			lAjstSld	:= .T.
		EndIf
	Else
		If (nPisFin061+nCofFin061+nCslFin061+nIrfFin061) > 0 .And. mv_par08 == 2 .And. Alltrim(Upper(FunName())) == "FINA330"
			nSaldo := SE1->E1_SALDO - (nValor - nTitAcres + nTitDecre) - nDescP   	// moeda do tit principal  
			If nSaldo > 0.009999
				nSaldo += (nPisFin061+nCofFin061+nCslFin061+nIrfFin061)
			EndIf
		Else
			nSaldo:= SE1->E1_SALDO - (nValor - nTitAcres + nTitDecre) - nDescP	// moeda do tit principal
		EndIf
	EndIf
	
	If !lCredito
		nSaldo += nValVa 
	EndIf
	
	If !lCredito .And. !lRartimp .And. !lRaRtImpMR .And. !lNcc .And. Abs(nSaldo) > nMVToler
		nSaldo := SE1->E1_SALDO - (nValor - nTitAcres + nTitDecre + nPrIss + nPrInss) - nDescP + nValVa
		
		If __lBq10925
			If lIrPjBxCr .And. nSaldo > 0 .And. nIrrf > 0 
				nSaldo -= IIf(__nMoePart == 1, nIrrf, xMoeda(nIrrf, 1, __nMoePart, dBaixa, __nCasDec, 0, __nTxMoedP))
			EndIf
			
			If nSaldo > 0 .And. lPccBxCr .And. (nPis+nCofins+nCsll) > 0
				nSaldo -= IIf(__nMoePart == 1, nPis,    xMoeda(nPis,    1, __nMoePart, dBaixa, __nCasDec, 0, __nTxMoedP))
				nSaldo -= IIf(__nMoePart == 1, nCofins, xMoeda(nCofins, 1, __nMoePart, dBaixa, __nCasDec, 0, __nTxMoedP))
				nSaldo -= IIf(__nMoePart == 1, nCsll,   xMoeda(nCsll,   1, __nMoePart, dBaixa, __nCasDec, 0, __nTxMoedP))
			EndIf
			
			If nSaldo > 0 .And. lCalcIssBx .And. nIss > 0
				nSaldo -= IIf(__nMoePart == 1, nIss,   xMoeda(nIss,   1, __nMoePart, dBaixa, __nCasDec, 0, __nTxMoedP))
			EndIf
			
			nSaldo -= __nImpMR
		EndIf
	ElseIf lCredito .And. ( ( !lRartimp .And. !lRaRtImpMR ) ) .And. !lNcc

		nSaldo := SE1->E1_SALDO - (nValor - nTitAcres + nTitDecre + nPrIss + nPrInss) - nDescP + nValVa

		If !__lBq10925 
			If lIrPjBxCr
				nSaldo += xMoeda(nIrrf, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
			EndIf
			
			If lPccBxCr
				nSaldo += xMoeda(nPis, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
				nSaldo += xMoeda(nCofins, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
				nSaldo += xMoeda(nCsll, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
			EndIf
			
			If lCalcIssBx
				nSaldo += xMoeda(nIss, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
			EndIf
			// Não será usado o nTotAbto, pois o valor do ISS e INSS deverá ser considerado em todas as compensações devido ao provisionamento
			nSaldo -= __nImpMR
		EndIf
ElseIf ((lRartimp .Or. lRaRtImpMR ) .And. !lNcc .And. !lVMd2ImpRA) .Or. (lVMd2ImpRA .And. !lCredito)
		If (nSaldo > 0 .And. lIrPjBxCr)
			nSaldo -= xMoeda(nIrrf, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
		EndIf
		
		If (nSaldo > 0 .And. lPccBxCr)
			nSaldo -= xMoeda(nPis, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
			nSaldo -= xMoeda(nCofins, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
			nSaldo -= xMoeda(nCsll, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
		EndIf
	EndIf

	If nMoeda > 1 .And. nSaldo < nToler
		nSaldo := 0
	EndIf	
	
	//Tolerância de Recebimento
	If nSaldo <> 0

		//Valor recebido a menor
		If nMVToler > 0
			If nSaldo > 0
				If nSaldo <= nMVToler
					nTitDecre	+= nSaldo	
					nSaldo		:= 0
					__cToler	:= "D"
				EndIf
			EndIf
		ElseIf lAjstSld
			nTitDecre	+= nSaldo
			__cToler	:= "D"
		ElseIf nSaldo < 0
			nSaldo := 0
		EndIf
	EndIf
	
	cSeq := IIf( cSeq == Nil, PadL("1",nTamSeq,"0"), cSeq )
	
	If SE1->E1_SDACRES >= nValor
		nSaldo 	  := SE1->E1_SALDO
		nTitAcres := nValor
	Endif
	
	RecLock("SE1")
	SE1->E1_SALDO   := nSaldo
	SE1->E1_BAIXA   := Iif(SE1->E1_BAIXA <= dBaixa, dBaixa, SE1->E1_BAIXA)
	SE1->E1_LOTE    := cLote
	SE1->E1_MOVIMEN := dBaixa
	SE1->E1_DESCONT := nDescP
	SE1->E1_MULTA   := 0
	SE1->E1_JUROS   := nTitAcres
	SE1->E1_CORREC  := 0
	
	If cPaisLoc == "BRA"
		SE1->E1_VALLIQ := xMoeda(nValor, nMoeda, SE1->E1_MOEDA, , nDecs1+1, __nTxMoedP)
	Else
		E1_VALLIQ   += nValor 
	EndIf
	
	SE1->E1_STATUS  := IIF(SE1->E1_STATUS != "R",Iif(SE1->E1_SALDO >= 0.01,"A","B"),"R")
	SE1->E1_SDDECRE := SE1->E1_SDDECRE - nTitDecre
	SE1->E1_SDACRES := IIF(SE1->E1_SDACRES >= nValor, (SE1->E1_SDACRES - nValor), (SE1->E1_SDACRES - nTitAcres))
	SE1->(MsUnlock())
	
	//PONTO DE ENTRADA NA ALTERACAO DO HISTORICO NA SE1
	If ExistBlock( "F330AHE1" )
		ExecBlock("F330AHE1",.F.,.F.)
	EndIf
	
	//Verifica se h  ponto de entrada
	If ExistBlock("FA330SE1")
		Execblock("FA330SE1",.F.,.F.)
	EndIf
	
	cNumero	:= E1_NUM
	cPrefixo := E1_PREFIXO
	cParcela := E1_PARCELA
	cCliente := E1_CLIENTE
	cLoja	 := E1_LOJA
	cTipoTit := ""
	nSalvRec := SE1->(RecNo())
	nTotAbat := 0
	
	If !SE1->E1_TIPO $ MVRECANT+"|"+MV_CRNEG .And. nSaldo > 0
		nTotAbat := SumAbatRec(cPrefixo, cNumero, cParcela, 1, "S")
	EndIf
	
	RecLock("SE1")
	
	If cPaisLoc == "BRA" .And. lPccBxCr .And. !lCredito	
		
		If !__lPccMR
			
			If dDataBase < dLastPcc
				If (if(nSaldo==0 .and. nTotAbto > nVrAbat,Str(nTotAbto-nVrAbat,16,2),Str(nSaldo,16,2))=Str(aImpPcc[1]+aImpPcc[2]+aImpPcc[3],16,2));
					.or. (nSaldo==0 .and. (Str(nTotAbto-nVrAbat,16,2))>(Str(aImpPcc[1]+aImpPcc[2]+aImpPcc[3],16,2))) ;
					.or. (nSaldo == nTotAbat)
					
					nPis 	:= aImpPcc[1] //entra aki para gravar na baixa total não proporcionaliza
					nCofins := aImpPcc[2]
					nCsll	:= aImpPcc[3]
					nPisBaseR 	:= Round(NoRound(nCsll * 100,3),2) //trecho retirado do FA070TOTMES
					nPisBaseC 	:= Round(NoRound(nCsll * 100,3),2) // no calculo do PCC na função F330CalcPCC não considera cumulatividade, portanto a mesma base de calculo é a de retenção
					nCofBaseR 	:= Round(NoRound(nCsll * 100,3),2)
					nCofBaseC 	:= Round(NoRound(nCsll * 100,3),2)
					nCslBaseR 	:= Round(NoRound(nCsll * 100,3),2)
					nCslBaseC 	:= Round(NoRound(nCsll * 100,3),2)			
				Else	
					If (MV_PAR08==1 .Or. lRaRtImp) .And. !lNcc
						If lRaRtImp .And. !lNcc
							If Len(aTitulos) > 0
								ntitulo1 += nValor+nPis+nCofins+nCsll+nIrrf+nIss+nInss
								nPropPcc := (ntitulo1 / SE1->E1_VALOR)
							Else
								nPropPcc := nPis/SE1->E1_PIS
							EndIf
						ElseIf !lRaRtImp .And. !lNcc
							If aDadosret[1] <= nVlMinImp .And. aDadosret[1] + nValor > nVlMinImp .And. lPccBxCr .And. (!lIrPjBxCr .Or. SE1->E1_ISS > 0)
								If nValPis > 0 
									nPropPcc := nPis/SE1->E1_PIS
								Else
									nPropPcc	:= (aDadosRet[1] + nValor + nPis + nCofins + nCsll)/(nValor + nPis + nCofins + nCsll)
								EndIf
							ElseIf aDadosret[1] < nVlMinImp .and. aDadosret[1] + nValor > nVlMinImp .and. lPccBxCr 
								nPropPcc	:=  (aDadosret[1] + nValor + nTotAbto)/(nValor + nTotAbto)	
							ElseIf nValor > nVlMinImp
								nPropPcc := nValor/SE1->E1_VLCRUZ
							ElseIf aDadosret[1] <= nVlMinImp .and. aDadosret[1] + nValor <= nVlMinImp .and. lPccBxCr .and. (!lIrPjBxCr .or. SE1->E1_ISS > 0)
								nPropPcc	:= nPis/SE1->E1_PIS
							ElseIf (aDadosret[1] > nVlMinImp .and. aDadosret[1] + nValor > nVlMinImp) .and. lPccBxCr .and. (!lIrPjBxCr .or. SE1->E1_ISS > 0)
								nPropPcc := nValor/SE1->E1_VLCRUZ
							Else
								nPropPcc := 0
							EndIf
						Else
							nPropPcc := (nValor*nTotAbto)/SE1->E1_VLCRUZ //é aqui o ntotabto está 0 pq é NCC
							nPropPcc := (nPropPcc/nTotAbto)
						EndIf
					Else
						If !lRARtImp .and. mv_par08 == 2 .and. aDadosret[1] <= nVlMinImp .and. aDadosret[1] + nValor > nVlMinImp .and. lPccBxCr .and. (!lIrPjBxCr .or. SE1->E1_ISS > 0)
							nPropPcc := (aDadosret[1] + nValor )/(SE1->E1_VLCRUZ)
						ElseIf nValor > nVlMinImp .or. aDadosret[1] + nValor > nVlMinImp 
							nPropPcc := nValor/SE1->E1_VLCRUZ
						Else 
							nPropPcc := 0
						Endif
					Endif
					
					If Str(nSaldo,16,2)<>Str(nPis+nCofins+nCsll+nTotAbat,16,2)
						nPis		:= Round(NoRound(SE1->E1_PIS * nPropPCC,3),2)
						nCofins		:= Round(NoRound(SE1->E1_COFINS * nPropPCC,3),2)
						nCsll		:= Round(NoRound(SE1->E1_CSLL * nPropPCC,3),2)
						nPisBaseR	:= Round(NoRound(SE1->E1_BASEPIS * nPropPCC,3),2)
						nPisBaseC	:= Round(NoRound(SE1->E1_BASEPIS * nPropPCC,3),2)
						nCofBaseR	:= Round(NoRound(SE1->E1_BASECOF * nPropPCC,3),2)
						nCofBaseC	:= Round(NoRound(SE1->E1_BASECOF * nPropPCC,3),2)
						nCslBaseR	:= Round(NoRound(SE1->E1_BASECSL * nPropPCC,3),2)
						nCslBaseC	:= Round(NoRound(SE1->E1_BASECSL * nPropPCC,3),2)
						
						aImpPcc[1]	-= nPis
						aImpPcc[2]	-= nCofins
						aImpPcc[3]	-= nCsll							
					Endif
					
					If lIrPjBxCr
						If MV_PAR08 == 1 .And. !lRaRtImp .And. nIrrf == nSaldo //Ultima baixa considera o restante de IRRF
							nIRFBase  	:= Round(NoRound(SE1->E1_BASEIRF * nPropPCC,3),2)
						Else 
							nIrrf		:= Round(NoRound(SE1->E1_IRRF * nPropPCC,3),2)
							nIRFBase  	:= Round(NoRound(SE1->E1_BASEIRF * nPropPCC,3),2)
						EndIf
					Endif
					
					aAreaSE := GetArea()
					DbSelectArea("SFQ")
					SFQ->(dbSetOrder(1))
					For ni := 1 to Len(aTitulos)
						cChave := aTitulos[ni,1]+aTitulos[ni,2]+aTitulos[ni,3]+aTitulos[ni,4] // prefixo+numero+parcela+tipo
						If SFQ->(DbSeek(xFilial("SFQ")+'E1B'+cChave))
							While !SFQ->(Eof()) .and. FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI == cChave
								nPis	:= nPis + SFQ->FQ_SABTPIS
								nCofins	:= nCofins + SFQ->FQ_SABTCOF
								nCsll	:= nCsll + SFQ->FQ_SABTCSL
								SFQ->(DbSkip())
							EndDo
						EndIf
					Next ni
					
					RestArea(aAreaSE)
					aImpPcc[1] -= nPis
					aImpPcc[2] -= nCofins
					aImpPcc[3] -= nCsll			
				Endif
			
			EndIf
		
		EndIf
			
		E1_STATUS := IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")		
	EndIf
	
	cSaldoAux := Str( nSaldo, 16, 2 ) 
	
	If ( cSaldoAux = Str(nTotAbat,16,2) .Or. cSaldoAux = Str(nPis+nCofins+nCsll+nTotAbat,16,2) .And. mv_par08 == 1 .And. ( ( (!lRaRtImp .And. !lRaRtImpMR) .And. !lCredito ) .Or. (lRaRtImp .Or. lRaRtImpMR) ) ) .Or.;
	( cSaldoAux = Str(SE1->(E1_PIS+E1_COFINS+E1_CSLL),16,2) .And. mv_par08 == 2 .And. (lRaRtImp .Or. lRaRtImpMR) )
		Replace E1_SALDO  With 0 
		Replace E1_STATUS With Iif( E1_STATUS != "R", "B", "R" )
	EndIf

	SE1->(MsUnlock())

	//atualiza status do adiantamento de viagem
	If SE1->E1_SALDO==0 .AND. (ALLTRIM(SE1->E1_ORIGEM) == "FINA677")
		FINATURES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),.T.,SE1->E1_ORIGEM,"R")
	EndIf

	If cPaisLoc == "BRA" .And. !__TpGerPix .And. __nQtdTitu == 1 .And. __lExcImpo .And. ( F71Ativa(nSalvRec) > 0 )
		cChaveTit := SE1->E1_FILIAL+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA
		
		If __lAltPix .And. !__lTPIConf .And. __nFINPIX9 == 2 .And. SE1->E1_SALDO > 0
			F986AltPix(cChaveTit, SE1->E1_FILORIG, .F.)
		Else
			cIdDocFK7 := FINBuscaFK7(cChaveTit, "SE1", SE1->E1_FILORIG)
			
			If !Empty(cIdDocFK7)
				PIXCancel(xFilial("SE1", SE1->E1_FILORIG), cIdDocFK7, (__lTPIConf .Or. (SE1->E1_SALDO == 0)))
			EndIf
		EndIf
	EndIf

	SE1->(dbGoTo(nSalvRec))

	If !lCredito
		nSaldoVa:= FValAcess(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_CLIENTE,SE1->E1_LOJA, SE1->E1_NATUREZ,!Empty(SE1->E1_BAIXA),,"R",SE1->E1_BAIXA,,SE1->E1_MOEDA)	
	EndIf
	
	FA330Mov(lPadrao,nValor,cAdiantamento,cSeq,nRegCmp,@abaixas,cOrigem,lCredito,nContab,@nAcresc,@nDecres,nTitAcres,nTitDecre,aBaixaSE5,nTotAbto,@cSequencia, lNcc, nValLim,@nRegSe5Ori,nSaldoVa, @lVldSEQ)

	SE1->(dbGoTo(nSalvRec))

	If SE1->E1_TIPO $ MVRECANT .AND. lFina330
		lCompRa	:=	.T.
	EndIf

	If !( SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG ) .OR. (lCompRa .AND. SE1->E1_TIPO $ MVRECANT)
		dbSelectArea("SE1")
		If E1_SALDO = 0
			cTipo := If( lCompRA .And. lCredito, cTipoAux, SE1->E1_TIPO )
			SE1->(dbSetOrder(2))
			SE1->(dbSeek(xFilSE1+cCliente+cLoja+cPrefixo+cNum+cParcela))
			If lTitpaiSE1
				If (nOrdTitPai:= OrdTitpai()) > 0
					SE1->(DbSetOrder(nOrdTitPai))
					If	DbSeek(xFilSE1+cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja)
						bWhile := {|| !Eof() .And. E1_FILIAL + Trim(E1_TITPAI) == xFilSE1+Trim(cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja) }
					Else
						SE1->(dbSetOrder(2))
						SE1->(dbSeek(xFilial("SE1")+cCliente+cLoja+cPrefixo+cNum+cParcela))
					Endif
				Endif
			Endif
					
			While Eval(bWhile)
				If lTitpaiSE1
					If !Empty(SE1->E1_TITPAI) .and. (Alltrim(SE1->E1_TITPAI) != Alltrim(cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja) )
						SE1->(DbSkip())
						Loop
					EndIf
				EndIf

				IF If(lCompRa,E1_TIPO,SE1->E1_TIPO) $ If(lPccBxCr,"CSL/FB-/"+MVCOFINS+"/"+MVPIS+"/"+MVABATIM+"/"+MVIRABT+"/"+MVINABT,;
					(MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+MVCFABT+"/"+MVCSABT))

					RecLock("SE1")
					E1_SALDO   := 0
					E1_BAIXA   := If(E1_BAIXA <= dBaixa, dBaixa, E1_BAIXA)
					E1_LOTE    := cLote
					E1_MOVIMEN := dBaixa
					E1_PORTADO := cBanco
					E1_STATUS  := IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")
					E1_TITPAI  := cDadosTitulo
					SE1->(MsUnlock())

					cChaveTit := SE1->E1_FILIAL + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" +;
						SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
					FINGRVFK7("SE1", cChaveTit,, cDadosTitulo)
					
				EndIf
				SE1->(dbSkip())
			EndDo
			SE1->(DbSetOrder(1))
		EndIf
		SE1->(dbGoto( nSalvRec ))

		If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG 
			SE1->(dbGoto( nRegCmp ))
		EndIf	
		
		dbSelectArea("SED")
		dbSelectArea("SA1")
		SED->(dbSeek(xFilial("SED")+SE1->E1_NATUREZ))
		SA1->(DbSetOrder(1))
		If SA1->(dbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA))

			RecLock("SA1")
			nAtraso := dBaixa-SE1->E1_VENCTO

			If nAtraso > 1
				IF Dow(SE1->E1_VENCTO) == 1 .Or. Dow(SE1->E1_VENCTO) == 7
					IF Dow(dBaixa) == 2 .and. nAtraso <= 2
						nAtraso := 0
					EndIF
				EndIF
				nAtraso:=IIF(nAtraso<0,0,nAtraso)
				If SA1->A1_MATR < nAtraso
					Replace A1_MATR With nAtraso
				EndIf
			EndIf	

			SA1->(MsUnlock())
		EndIf
		SE1->(dbGoto( nSalvRec ))
	ElseIf cPaisLoc == "BRA"
		//Baixar titulos de abatimento se for baixa total do(s) título(s) selecionado(s) no array aTitulos
		dbSelectArea("SE1")
		If Funname() == "FINA330" .Or. Funname() == "FINA740"
			If MV_PAR02 == 1
				nPosRec := 20
			Else
				nPosRec := 23
			EndIf	 
		EndIf	
		For nX := 1 To Len(aTitulos)
			DbSelectArea("SE1")
			SE1->(DbGoTo(aTitulos[nX][nPosRec]))		
			xFilSE1		:= SE1->E1_FILIAL
			cNumero		:= SE1->E1_NUM
			cPrefixo 	:= SE1->E1_PREFIXO
			cParcela 	:= SE1->E1_PARCELA
			cCliente 	:= SE1->E1_CLIENTE
			cLoja	 	:= SE1->E1_LOJA
					
			If (SE1->E1_SALDO - aTitulos[nX][09]) == 0 //Baixa total	
				cTipo:= If( lCompRA .And. lCredito, cTipoAux, SE1->E1_TIPO )
				dbSetOrder(2)
				dbSeek(xFilSE1+cCliente+cLoja+cPrefixo+cNumero+cParcela) 
				If lTitpaiSE1 
					If FindFunction("OrdTitpai") .and. (nOrdTitPai:= OrdTitpai()) > 0
						DbSetOrder(nOrdTitPai)
						If	DbSeek(xFilSE1+cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja)
							bWhile := {|| !Eof() .And. E1_FILIAL + Trim(E1_TITPAI) == xFilSE1+Trim(cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja) }
						Else
							dbSetOrder(2)		
							dbSeek(xFilial("SE1")+cCliente+cLoja+cPrefixo+cNumero+cParcela)
						Endif
					Endif
				Endif
				
				While Eval(bWhile)                         
					If lTitpaiSE1
						If !Empty(E1_TITPAI) .and. (Alltrim(E1_TITPAI)!=Alltrim(cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja) )
							DbSkip()
							Loop
						EndIf
					EndIf        
					
					IF If(lCompRa,E1_TIPO,SE1->E1_TIPO) $ If(lPccBxCr,"CSL/FB-/"+MVCOFINS+"/"+MVPIS+"/"+MVABATIM+"/"+MVIRABT+"/"+MVINABT,;
						(MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+MVCFABT+"/"+MVCSABT))								
		
						RecLock("SE1")
						E1_SALDO   := 0
						E1_BAIXA   := If(E1_BAIXA <= dBaixa, dBaixa, E1_BAIXA)
						E1_LOTE    := cLote
						E1_MOVIMEN := dBaixa
						E1_PORTADO := cBanco
						E1_STATUS  := IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")
						E1_TITPAI  := cDadosTitulo 
						MsUnlock()

						cChaveTit := SE1->E1_FILIAL + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" +;
							SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
						FINGRVFK7("SE1", cChaveTit,, cDadosTitulo)
		
					EndIf
					dbSelectArea( "SE1" )
					dbSkip( )
				EndDo
				DbSetOrder(1)
			Else
				Loop
			EndIf
			dbGoto( nSalvRec )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no registro de natureza 	 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SED")
			dbSeek(xFilial("SED")+SE1->E1_NATUREZ)
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza campo de maior atrazo no Cadastro de Clientes     		  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SA1")
			DbSetOrder(1)
			dbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA)
			RecLock("SA1")
			nAtraso:=dBaixa-SE1->E1_VENCTO
			If nAtraso > 1
				If Dow(SE1->E1_VENCTO) == 1 .Or. Dow(SE1->E1_VENCTO) == 7
					If Dow(dBaixa) == 2 .and. nAtraso <= 2
						nAtraso := 0
					EndIf
				EndIf
				nAtraso:=IIF(nAtraso<0,0,nAtraso)
				If SA1->A1_MATR < nAtraso
					Replace A1_MATR With nAtraso
				EndIf
			EndIf
			MsUnlock()
		Next nX
		SE1->(dbGoto(nSalvRec))	
	EndIf

	dbSelectArea("SE1")
	SE1->(dbSetOrder(1))
Return

/*/{Protheus.doc} FA330Mov
	Grava registros referentes a compensacao de titulos
	
	@author Valter G. Nogueira Jr
	@since 21/03/94)
/*/
Static Function FA330Mov(lPadrao,nValor,cAdiantamento,cSeq,nRegCmp,aBaixas,cOrigem,lCredito,nContab,nAcresc,nDecres,;
							nTitAcres,nTitDecre,aBaixaSE5,nTotAbto,cSequencia, lNcc, nValLim, nRegSe5Ori,nSaldoVa, lVldSEQ)

	Local nTamSeq		As Numeric
	Local cAlias		As Character
	LOCAL cDocOriginal	As Character
	LOCAL nRecSe1		As Numeric
	LOCAL nValorReal	As Numeric
	Local cSeqPrc 		As Character
	Local cSeqAdt 		As Character
	LOCAL nDecs1		As Numeric
	LOCAL aArea			As Array
	LOCAL cFilOrig		As Character
	LOCAL cCliOri		As Character
	LOCAL cLojaOri		As Character
	LOCAL cCliAdt		As Character
	LOCAL cLojaAdt		As Character
	Local lImpComp		As Logical
	Local lIsNcc		As Logical
	Local nValPis		As Numeric
	Local nValCof		As Numeric
	Local nValCSL		As Numeric
	local nRecImp		As Numeric
	//Compensacao de contas a receber, nao necessita verificar o parametro MV_BX10925
	Local lPCCBaixa		As Logical
	//Controla o Pis Cofins e Csll na baixa (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default))
	Local lPccBxCr		As Logical
	Local lRaRtImp		As Logical
	//Controla IRPJ na baixa
	Local lIrPjBxCr		As Logical
	Local lMultFil  	As Logical // CRIADO PARA MANIPULAR A FILIAL NO MOVIMENTO BANCARIO
	Local aAreaSE5		As Array
	Local nVlReal		As Numeric

	//Impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
	Local nPisFin061	As Numeric
	Local nCofFin061	As Numeric
	Local nCslFin061	As Numeric
	Local nIrfFin061	As Numeric
	Local nRegSE5		As Numeric
	Local nOrdSE5		As Numeric
	Local oModelBxR		As Object
	Local oSubFK1		As Object
	Local oSubFK6		As Object
	Local cLog 			As Character
	Local cChaveFK7		As Character
	Local cChvFK7out	As Character
	Local cCamposE5		As Character
	Local lRet 			As Logical
	Local oSubFKA		As Object
	Local cChaveTit		As Character
	Local cFilSE5		As Character
	Local cIdFK1		As Character
	Local cTpDoc		As Character
	Local nDecValFK6 	As Numeric //Quantidade de decimais do campo FK6_VALMOV
	Local lIrfBxAux 	As Logical
	Local lPccBxAux 	As Logical
	Local aImpMRBrw 	As Array //Guarda os dados de imposto do motor para o título posicionado na browse
	Local aImpMRSel 	As Array //Vetor que irá guardar os impostos calculado para o título selecionado na markbrowse  
	Local aAuxImpGrv 	As Array
	Local nJ 			As Numeric
	Local nBaseImpMR 	As Numeric
	Local nImpMR		As Numeric
	Local nVlrEstr      As Numeric
	Local nVlrNF        As Numeric
	Local nCM           As Numeric
	Local lTxC          As Logical
	Local nMoedTiBrw    As Numeric
	Local aAreaFK1		As Array
	Local nRecFK1		As Numeric
	Local cFilOld		As Character
	Local cIdDoc		As Character
	Local nCntFK6		As Numeric
	Local lIdFkd		As Logical
	Local nTxCompP		As Numeric
	Local nValImp		As Numeric
	Local lFina330  	As Logical
	Local nMVToler		As Numeric
	Local nDiff			As Numeric
	Local lDescToler	As Logical

	nTamSeq		:= __nTamSeq
	cAlias		:= Alias()
	cDocOriginal	:= SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO+SE1->E1_LOJA
	nRecSe1		:= SE1->(RecNo())
	nValorReal	:= 0
	cSeqPrc 	:= Replicate("0",nTamSeq)
	cSeqAdt 	:= Replicate("0",nTamSeq)
	nDecs1		:= MsDecimais(1)
	aArea		:= {}
	cFilOrig	:= ''
	cCliOri		:= ''
	cLojaOri	:= ''
	cCliAdt		:= ''
	cLojaAdt	:= ''
	lImpComp	:= SuperGetMv("MV_IMPCMP",,"2") == "1"
	lIsNcc		:= .F.
	nValPis		:= 0
	nValCof		:= 0
	nValCSL		:= 0
	nRecImp		:= 0
	//Compensacao de contas a receber, nao necessita verificar o parametro MV_BX10925
	lPCCBaixa	:= (cPaisLoc == "BRA")
	//Controla o Pis Cofins e Csll na baixa (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default))
	lPccBxCr	:= FPccBxCr()
	lRaRtImp	:= FRaRtImp()
	//Controla IRPJ na baixa
	lIrPjBxCr	:= FIrPjBxCr() 
	lMultFil  	:= ExistBlock("SE5MTFIL") // CRIADO PARA MANIPULAR A FILIAL NO MOVIMENTO BANCARIO
	aAreaSE5	:= {}
	nVlReal		:= 0

	//Impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
	nPisFin061	:=	0
	nCofFin061	:=	0
	nCslFin061	:=	0
	nIrfFin061	:=	0
	nRegSE5		:=	0
	nOrdSE5		:=	0
	oModelBxR	:= Nil
	oSubFK1		:= Nil
	oSubFK6		:= Nil
	cLog 		:= ""
	cChaveFK7	:= ""
	cChvFK7out	:= ""
	cCamposE5	:= ""
	lRet 		:= .T.
	oSubFKA		:= Nil
	cChaveTit	:= SE1->E1_FILIAL + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
	cFilSE5		:= FWxFilial('SE5')
	cIdFK1		:= ''
	cTpDoc		:= ''
	nDecValFK6 	:= __nTamValM //Quantidade de decimais do campo FK6_VALMOV
	lIrfBxAux 	:= lIrPjBxCr
	lPccBxAux 	:= lPccBxCr
	aImpMRBrw 	:= PegaVarMR() //Guarda os dados de imposto do motor para o título posicionado na browse
	aImpMRSel 	:= {} //Vetor que irá guardar os impostos calculado para o título selecionado na markbrowse  
	aAuxImpGrv 	:= {}
	nJ 			:= 0
	nBaseImpMR 	:= 0
	nImpMR		:= 0
	nVlrEstr 	:= 0
	nVlrNF      := 0
	nCM         := 0
	lTxC        := If(cPaisLoc == "BRA", !Empty(SE1->E1_TXMOEDA), .F.)
	nMoedTiBrw  := 0
	aAreaFK1	:= {}
	nRecFK1		:= 0
	cFilOld		:= ""
	cIdDoc		:= ""
	nCntFK6		:= 0
	lIdFkd		:= .F.
	nTxCompP	:= 0
	nValImp		:= 0
	lFina330  	:= IsInCallStack("FINA330") .OR. IsInCallStack("FINA740")
	nMVToler	:= SuperGetMv("MV_TOLERPG",,0.01)
	nDiff		:= 0
	lDescToler	:= .F.

	DEFAULT lCredito	:= .F.
	DEFAULT nContab		:= 1
	DEFAULT nAcresc		:= 0
	DEFAULT nDecres		:= 0
	DEFAULT aBaixaSE5	:= {}
	DEFAULT nTotAbto	:= 0
	DEFAULT cSequencia	:= Replicate("0",nTamSeq)
	DEFAULT lNcc		:= .F.
	Default nValLim 	:= 0
	Default __nPosTit   := 0
	Default nRegSe5Ori	:= 0 
	Default nSaldoVA	:= 0
	Default lVldSEQ		:= .F.

	PRIVATE cMotBx		:= "CMP"
	PRIVATE l330Mov1	:= ExistBlock("SE5FI330")
	PRIVATE l330Mov2	:= ExistBlock("SE5FI331")

	If __lBq10925 == Nil
		__lBq10925 := SuperGetMV("MV_BQ10925",,"2") == "1"
	Endif

	If __lNumBor == Nil
		__lNumBor := FK1->(FieldPos("FK1_NUMBOR")) > 0
	EndIf

	//Posiciono no titulo de destino (selecionado na markbrowse)
	dbSelectArea("SE1")
	SE1->(dbSetOrder(1))
	SE1->(dbGoTo(nRegCmp))
	cFilOrig	 	:= SE1->E1_FILORIG
	cCliAdt			:= SE1->E1_CLIENTE
	cLojaAdt		:= SE1->E1_LOJA
	nMoedTiBrw 		:= SE1->E1_MOEDA

	//Vld se ambos os títulos possuem taxa contratada 
	If __nPosTit > 0 .And. cPaisLoc == "BRA" .And. Len(aTitulos) > 0
		__nTxTiBrw := aTitulos[__nPosTit, Len(aTitulos[__nPosTit])]
		lTxC       := (lTxC .And. !Empty(SE1->E1_TXMOEDA))
	Else
		__nTxTiBrw := Fa330Tx2(nMoeda,nTxMoeda)
	EndIf
	// Taxa a ser considerada para o título de partida
	If nMoeda > 1
		If !Empty(SE1->E1_TXMOEDA) .And. __lCmTxCon 
			nTxCompP := __nTxMoedD
		Else
			nTxCompP := __nTxMoedP
		EndIf
	Else // Se o título de partida for moeda 1, a taxa é a do movimento
		nTxCompP := __nTxMoedD
	EndIf

	if lCredito	
		nDescD := getDesc()
	endIf

	If !lCredito
		lIsNcc := SE1->E1_TIPO $ MV_CRNEG   //Verifico se o titulo de adiantamento é um NCC
	EndIf

	If cPaisLoc <> "BRA" .And. Type("aTxMoedas")#"U" .And. FunName() <> "FINA330"
		If __lDizPer
			nValorReal := Round(xMoeda(nValor,nMoeda,1,dDatabase,nDecs1+1,aTxMoedas[nMoeda][2],nDecs1), nDecs1 )
		Else
			nValorReal := xMoeda(nValor,nMoeda,1,dDatabase,nDecs1+1,aTxMoedas[nMoeda][2],nDecs1)
		EndIf
	ElseIf nMoeda <> 1
		If __lDizPer
			nValorReal := Round(xMoeda(nValor,nMoeda,1,dDatabase,nDecs1+1,nTxCompP), nDecs1 )
		Else
			nValorReal := xMoeda(nValor,nMoeda,1,dDatabase,nDecs1+1,nTxCompP)
		EndIf
	Else
		nValorReal := nValor
	EndIf

	If lCredito
		cFilOld	:= cFilAnt
		cFilAnt	:= cFilOrig
	EndIf

	cSeqAdt := FaNxtSeqBx("SE1",.T., Nil, Nil, Nil, Nil , @lVldSEQ)

	If lVldSEQ
		Return .F.
	EndIf

	If lCredito
		cFilAnt	:= cFilOld
	EndIf

	SE1->(dbGoTo(nRecSe1)) //posiciona no titulo de partida (selecionado na browse)
	cSeqPrc	:= FaNxtSeqBx("SE1",.T., Nil, Nil, Nil, Nil , @lVldSEQ)

	If lVldSEQ
		Return .F.
	EndIf

	cCliOri	:= SE1->E1_CLIENTE
	cLojaOri := SE1->E1_LOJA

	//Motor de retenções
	If __lMotRet
		//Verifica as configurações de impostos pelo motor de retenção
		__lTCnfgMR := F330VldImp()
		
		If lCredito
			lPccBxCr := ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
			lIrPjBxCr := ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
			
			//Se for a baixa total do saldo do título e houver imposto, então passa o valor do saldo como base de cálculo para o motor
			If nValorReal + SE1->E1_SALDO == SE1->E1_VALOR
				nBaseImpMR := SE1->E1_VALOR
			ElseIf !lIrPjBxCr //Se for baixa parcial, então passa o valor da baixa
				nBaseImpMR := nValorReal + nTotAbto
			Else
				nBaseImpMR := Iif( SE1->E1_VALOR <> ( nValorReal + nTotAbto ), nValorReal, SE1->E1_VALOR )
			EndIf
			
			If !__lImpEmis
				nImpMR	:= __nImpMR
			EndIf
			
			//Calcula os impostos pelo motor de retenções
			If __lTCnfgMR
				F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, nBaseImpMR, dDataBase, SE1->E1_TIPO )
				__lTCnfgMR	:= .F.
			EndIf
		EndIf
	EndIf

	If lCredito
		lIsNcc := SE1->E1_TIPO $ MV_CRNEG   //Verifico se o titulo de adiantamento é um NCC
	Endif

	cSequencia := IIf(cSeqAdt > cSeqPrc,cSeqAdt,cSeqPrc)

	dbSelectArea("SE5")
	SE5->(dbSetOrder(1))

	If nValor != 0
		//Define valor das movimentações do título de partida
		If !Empty(__nMovRA) .And. !Empty(__nMovNF)
			nValorReal := If(lCredito , __nMovRA,__nMovNF )
			nVlrEstr := If(lCredito,  __nMovNF,__nMovRA)
		ElseIf nMoeda == 1
			nValorReal := nValor
			If (!__lBq10925 .and. !lIsNcc) .AND. (!lRaRtImp)
				nValorReal := nValor - nPis - nCofins - nCsll - IiF(lIrPjBxCr,nIrrf,0)
			Endif
			nVlrEstr   := xMoeda(nValorReal, nMoeda, nMoedTiBrw, dDataBase, __nCasDec, 0, IIf(cPaisLoc == "BRA", __nTxTiBrw, __nTxMoedP))
		Else
			nVlrEstr   := nValor
			If (!__lBq10925 .and. !lIsNcc) .AND. (!lRaRtImp)
				nValImp := xMoeda((nPis+nCofins+nCsll+IiF(lIrPjBxCr,nIrrf,0)), 1, nMoeda, Ddatabase, __nCasDec, 0, __nTxMoedP)
				nVlrEstr := nValor - nValImp
			Endif
			nValorReal := xMoeda(nVlrEstr, nMoeda, 1, dDataBase, __nCasDec, nTxCompP)
		EndIf
		
		If cPaisLoc == "BRA" .And. __lCmTxCon .And. lTxC
			If !SE1->E1_TIPO $ MVRECANT+"|"+MV_CRNEG
				nVlrNF := Round(nValorReal,__nCasDec)
			Else
				SE1->(dbGoTo(nRegCmp))
				nVlrNF := Round(xMoeda(nValor, If(nMoedTiBrw != 1, nMoedTiBrw, nMoeda), 1, SE1->E1_EMISSAO, __nCasDec, __nTxTiBrw),__nCasDec)
				SE1->(dbGoTo(nRecSe1))
			EndIf
		EndIf
		
		oModelBxR := FWLoadModel("FINM010") 
		oModelBxR:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
		oModelBxR:Activate()		
		lIdFkd := oModelBxR:GetModel("FK6DETAIL"):HasField("FK6_IDFKD")
		oModelBxR:SetValue("MASTER", "E5_GRV", .T. )
		oModelBxR:SetValue("MASTER", "NOVOPROC", .T. ) 
		
		cCamposE5:="{"
		cCamposE5 += "{'E5_FILIAL'		,'" + cFilSE5 			+ "'}"
		cCamposE5 += ",{'E5_PREFIXO'	,'" +  SE1->E1_PREFIXO	+ "'}"
		cCamposE5 += ",{'E5_NUMERO'		,'" +  SE1->E1_NUM		+ "'}"
		cCamposE5 += ",{'E5_PARCELA'	,'" +  SE1->E1_PARCELA	+ "'}"
		cCamposE5 += ",{'E5_CLIENTE'	,'" +  SE1->E1_CLIENTE	+ "'}"
		cCamposE5 += ",{'E5_CLIFOR'		,'" +  SE1->E1_CLIENTE	+ "'}"
		cCamposE5 += ",{'E5_LOJA'		,'" +  SE1->E1_LOJA		+ "'}"
		cCamposE5 += ",{'E5_BENEF'		,'" + StrTran(SE1->E1_NOMCLI,"'","")+ "'}"
		cCamposE5 += ",{'E5_TIPO'		,'" +  SE1->E1_TIPO		+ "'}"
		cCamposE5 += ",{'E5_DTDIGIT'	, STOD('" + DTOS(dDataBase) + "')}"
		cCamposE5 += ",{'E5_DTDISPO'	, STOD('" + DTOS(dBaixa) + "')}"
		cCamposE5 += ",{'E5_SITCOB'		,'" + SE1->E1_SITUACA + "' }"
		cCamposE5 += ",{'E5_LA'			,'" +  IIF(lPadrao .and. nContab == 1,"S","N") + "'}"

		If ! lMultFil
			cCamposE5 += ",{'E5_FILIAL'		,'" + xFilial("SE5") + "' } "
		Else
			cCamposE5 += ",{'E5_FILIAL'		,'" + ExecBlock("SE5MTFIL",.F.,.F.,cFilAnt) + "' } "
		EndIf

		cChaveFK7	:= FINGRVFK7("SE1", cChaveTit, SE1->E1_FILORIG)
		cChvFK7out	:= cChaveFK7
		cIdFK1		:= FWUUIDV4()
		oSubFK1 := oModelBxR:GetModel( "FK1DETAIL" )
		oSubFKA := oModelBxR:GetModel( "FKADETAIL" )
		oSubFK6 := oModelBxR:GetModel( "FK6DETAIL" )

		If !oSubFKA:IsEmpty()
			oSubFKA:AddLine()
		EndIf
		
		oSubFKA:SetValue( "FKA_IDORIG"	, cIdFK1 )
		oSubFKA:SetValue( "FKA_TABORI"	, 'FK1')
		
		If !oSubFK1:IsEmpty()
			oSubFK1:AddLine()
		EndIf

		oSubFK1:SetValue( "FK1_DATA"	, dBaixa )		
		oSubFK1:SetValue( "FK1_NATURE"	, SE1->E1_NATUREZ )
		oSubFK1:SetValue( "FK1_RECPAG"	, "R" )
		oSubFK1:SetValue( "FK1_MOTBX"	, "CMP")
		oSubFK1:SetValue( "FK1_ORIGEM"	, FunName() )
		oSubFK1:SetValue( "FK1_SEQ"		, cSequencia )
		oSubFK1:SetValue( "FK1_IDDOC"	, cChaveFK7 )
		oSubFK1:SetValue( "FK1_TPDOC"	, cTpDoc )	
		oSubFK1:SetValue( "FK1_CCUSTO"	, SE1->E1_CCUSTO )	
		oSubFK1:SetValue( "FK1_FILORI"	, SE1->E1_FILORIG )
		oSubFK1:SetValue( "FK1_VALOR"	, Iif(!Empty(__nMovRA) .And. !Empty(__nMovNF),Round(nValorReal, 2),If(SE1->E1_MOEDA == 1, Round(nValorReal, 2), Round(nVlrEstr, 2))))
		oSubFK1:SetValue( "FK1_VLMOE2"	, Iif(!Empty(__nMovRA) .And. !Empty(__nMovNF),Round(nVlrEstr, 2),If(SE1->E1_MOEDA == 1, Round(nVlrEstr, 2), Round(nValorReal, 2))))
		oSubFK1:SetValue( "FK1_SITCOB"	, SE1->E1_SITUACA )
		oSubFK1:SetValue( "FK1_MOEDA"	,  StrZero(SE1->E1_MOEDA, 2))
		oSubFK1:SetValue( "FK1_LOTE"	, cLote )
		oSubFK1:SetValue( "FK1_DOC"		, cAdiantamento )
		oSubFK1:SetValue( "FK1_LA"		, IIF(lPadrao .and. nContab == 1,"S","N") )
		If __lNumBor
			oSubFK1:SetValue( "FK1_NUMBOR",SE1->E1_NUMBOR)
		EndIF
		
		If nTitAcres <> 0
			If !oSubFK6:IsEmpty()
				oSubFK6:AddLine()
			EndIf
			
			nTitAcres 	:= Round(xMoeda(nTitAcres, nMoeda, 1, Nil, __nCasDec, nTxCompP), 2)

			oSubFK6:SetValue( 'FK6_GRVSE5'  , .F. )		
			oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
			oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
			oSubFK6:SetValue( 'FK6_TPDOC'	, 'JR' )
			oSubFK6:SetValue( 'FK6_VALCAL'	, nTitAcres )	
			oSubFK6:SetValue( 'FK6_VALMOV'	, nTitAcres )
			oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
			oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
			oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0049) ) //ACRESCIMO
			
			cCamposE5 += ",{'E5_VLACRES'," + Str(nTitAcres) + " }"
			cCamposE5 += ",{'E5_VLJUROS'," + Str(nTitAcres) + " }"
		EndIf
		
		If nTitDecre+nDescP <> 0
			If !oSubFK6:IsEmpty()
				oSubFK6:AddLine()
			EndIf
			
			nTitDecre		:= Round(xMoeda(nTitDecre+nDescP, nMoeda, 1, Nil, __nCasDec, nTxCompP), 2)

			oSubFK6:SetValue( 'FK6_GRVSE5'  , __cToler == "D" )		
			oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
			oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
			oSubFK6:SetValue( 'FK6_TPDOC'	, 'DC' )
			oSubFK6:SetValue( 'FK6_VALCAL'	, nTitDecre )	
			oSubFK6:SetValue( 'FK6_VALMOV'	, nTitDecre )
			oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
			oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
			oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0050) ) //DECRESCIMO
			oSubFK6:SetValue( 'FK6_TPDESC'	, Iif(SE1->E1_TPDESC == 'C', '1', '2') )
			
			cCamposE5 += ",{'E5_VLDESCO'," + Str(nTitDecre) + " }"
			cCamposE5 += ",{'E5_VLDECRE'," + Str(nTitDecre) + " }"
		EndIf
		//VA: Adiciona os valores da FKD ao model
		If __l330Va .And. (nSaldoVA <> 0 .Or. __nValVa <> 0)
			cIdDoc := oSubFK1:GetValue("FK1_IDDOC")
			FSetFK6FKD( oSubFK6, cIdDoc, cIdFK1, "R" )
		EndIf

		If nMoeda > 1 .Or. cPaisLoc != "BRA"
			
			nCM := FA330Corr(IIf(!Empty(__nMovRA) .And. !Empty(__nMovNF),nValorReal,nVlrEstr), nVlrNF, "SE1", nTxCompP)		
		EndIf
		
		nTxMoed1 := nTxMoed2 := nValEmis := nValBax := nValCm := 0
		nValCorCM += nCM

		// Grava o valor de correção monetária no SE5 para ser visualizado na consulta
		If cPaisLoc == "MEX" .And. SE5->E5_MOEDA <> "1" .And. FunName() == "FINA330"
			nTxCor		:= Iif(SE1->E1_TXMOEDA > 0, SE1->E1_TXMOEDA, RecMoeda(SE1->E1_EMISSAO, SE1->E1_MOEDA))
			nValOrig	:= Round(xMoeda(nValorReal,nMoeda,1,,,nTxCor),2)
			nValAtu	:= Round(xMoeda(nValorReal,nMoeda,1,,,aTxMoedas[nMoeda][2]),2)
			
			If nValAtu - nValOrig <> 0
				If !oSubFK6:IsEmpty()
					oSubFK6:AddLine()
				EndIf	
				oSubFK6:SetValue( 'FK6_GRVSE5'  , .F.)			
				oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
				oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
				oSubFK6:SetValue( 'FK6_TPDOC'	, 'CM' )
				oSubFK6:SetValue( 'FK6_VALCAL'	, nValAtu - nValOrig )	
				oSubFK6:SetValue( 'FK6_VALMOV'	, nValAtu - nValOrig )
				oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
				oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
				
				If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0075) ) //CORREC.DE ADIANTAMENTO
				Else
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0076) ) //"Correcao Monet s/Receb.Titulo" 
				EndIf
				cCamposE5 += ",{'E5_VLCORRE'," + Str(nValAtu - nValOrig )+ " }"
			EndIf
		Else
			If cPaisLoc == "BRA" .And. SE1->E1_MOEDA > 1 .And. nValCm != 0 .And. (lFina330 .OR. __lCmpM460)
				If !oSubFK6:IsEmpty()
					oSubFK6:AddLine()
				EndIf
				
				oSubFK6:SetValue( 'FK6_GRVSE5'  , .F.)		
				oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
				oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
				oSubFK6:SetValue( 'FK6_TPDOC'	, 'CM' )
				oSubFK6:SetValue( 'FK6_VALCAL'	, Round(nValCm, 2))	
				oSubFK6:SetValue( 'FK6_VALMOV'	, Round(nValCm, 2))
				oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
				oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
				
				If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0075) ) //CORREC.DE ADIANTAMENTO
				Else
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0076) ) //CORREC. MONET S/ RECEBTO
				EndIf
				cCamposE5 += ",{'E5_VLCORRE'," + Str(Round(nValCm, 2)) + " }"

			ElseIf Round( nCm, nDecValFK6 ) <> 0
				If !oSubFK6:IsEmpty()
					oSubFK6:AddLine()
				EndIf
				
				oSubFK6:SetValue( 'FK6_GRVSE5'  , .T.)		
				oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
				oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
				oSubFK6:SetValue( 'FK6_TPDOC'	, 'CM' )
				oSubFK6:SetValue( 'FK6_VALCAL'	, nCm)	
				oSubFK6:SetValue( 'FK6_VALMOV'	, nCm)
				oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
				oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
				
				If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0075) ) //CORREC.DE ADIANTAMENTO
				Else
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0076) ) //CORREC. MONET S/ RECEBTO
				EndIf
				
				cCamposE5 += ",{'E5_VLCORRE'," + Str(nCm) + " }"
			Endif
		EndIf

		If lCredito
			oSubFK1:SetValue( "FK1_HISTOR"	, OemToAnsi(STR0077)) //"Baixa por Compensação"
			oSubFK1:SetValue( "FK1_TPDOC"	, "BA" )
		Else
			oSubFK1:SetValue( "FK1_HISTOR"	, OemToAnsi(If(lIsNcc,STR0078,STR0036)) ) //"Compensação Nota de Crédito" //"Compensaçäo de Adiantamentos"
			oSubFK1:SetValue( "FK1_TPDOC"	, "CP" )
		EndIf

		If !lPccBxCr
			//Acerto valor dos impostos - Tecnofibras
			If lImpComp .and. lIsNcc .and. lPccBaixa
				nRecImp := IIF(lCredito,nRegCmp,nRecSE1)
				F330ActImp(nRecImp,nValorReal,@nValPis,@nValCof,.T.,lCredito,@nValCSL,nTotAbto)
				//Gravo Valores dos impostos no SE5 (ja locado)
				cCamposE5 += ",{'E5_VRETPIS' ,  "+cValToChar(nValPis)+"}"																		
				cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nValCof)+"}"
				cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nValCSL)+" }"
			EndIf			
		EndIf

		//Alimenta o VRET do pcc na compensacao contra NCC ou RA. Mas nao gera o 
		//titulo dos impostos, para que este valor nao seja calculado na baixa do restante.
		If !lCredito 
			If lPccBaixa
				cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nPis)+"}"																		
				cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nCofins)+"}"
				cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nCsll)+"}"		
				If lIsNcc
					cCamposE5 += ",{'E5_PRETPIS' , '7' }"
					cCamposE5 += ",{'E5_PRETCOF' , '7' }"
					cCamposE5 += ",{'E5_PRETCSL' , '7' }"
				EndIf  
			EndIf

			If lIrPjBxCr
				cCamposE5 += ",{'E5_VRETIRF' , "+cValToChar(nIrrf)+"}"		
				If lIsNcc			
					cCamposE5 += ",{'E5_PRETIRF' , '7' }"
				EndIf	
			EndIf	

		EndIf	
		
		cCamposE5 += ",{'E5_FORNADT' , '" + cCliAdt + "' } "
		cCamposE5 += ",{'E5_LOJAADT' , '" + cLojaAdt + "' } "

		If l330Mov1
			ExecBlock("SE5FI330",.f.,.f.)
		EndIf

		If nMoeda > 1 
			If cPaisLoc == "BRA"
				oSubFK1:SetValue("FK1_TXMOED", nTxCompP)
			ElseIf cPaisLoc == "MEX" .And.  Type("aTxMoedas") # "U"
				oSubFK1:SetValue( "FK1_TXMOED" , aTxMoedas[nMoeda][2] )
			EndIf
		EndIf

		cCamposE5 += " } "
		oModelBxR:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )

		If oModelBxR:VldData()
			oModelBxR:CommitData()
			
			//VA: Atualiza a FKD com as informações da baixa
			If __l330Va .And. !oSubFK6:IsEmpty()
				For nCntFK6 := 1 to oSubFK6:Length()
					oSubFK6:GoLine(nCntFK6)
					If oSubFK6:GetValue("FK6_TPDOC",nCntFK6) $ "VA"
						FA330VAFKD(cIdDoc, oSubFK6:GetValue("FK6_CODVAL"), If(lIdFkd, oSubFK6:GetValue("FK6_IDFKD"),""), dBaixa, oSubFK6:GetValue("FK6_VALMOV")) 
					EndIf
				Next
			EndIf
			
			nRecFk1	:= FK1->(Recno())
			SE5->(DbGoto(oModelBxR:GetValue("MASTER","E5_RECNO")))	//posicionando o movimento de compensação recém-gravado
			aAdd( aBaixas, { { "CMP", cSequencia, SE5->(Recno()), SE1->E1_TIPO, cAdiantamento, SE5->E5_DOCUMEN, SE1->E1_ORIGEM, SE1->(Recno()) } } )
			
			aAdd(aRecSE5, FIM010RSE5()[Len(FIM010RSE5())])
		Else
			lRet := .F.
			cLog := cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_IDFIELDERR]) + ' - '
			cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_ID]) + ' - '
			cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_MESSAGE])         	
			Help( ,,"FA330MOV01",,cLog, 1, 0 )   
		EndIf

		If !Empty(nCm)
			F330MoedCm()
		EndIf
		
		oSubFK1 := Nil
		oSubFKA := Nil
		oSubFK6 := Nil
		
		oModelBxR:DeActivate()
		oModelBxR:Destroy()
		oModelBxR := Nil

		//Carregando dados bancarios caso seja necessario gravar o registro da diferenca cambial.
		cBcoSE5  := SE5->E5_BANCO
		cAgSE5   := SE5->E5_AGENCIA
		cCtSE5   := SE5->E5_CONTA
		cLoteSE5 := SE5->E5_LOTE
		
		//Verifica se o titulo já possui impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
		nPisFin061	:=	0
		nCofFin061	:=	0
		nCslFin061	:=	0
		nIrfFin061	:=	0
		nRegSE5	:=	SE5->(Recno())
		nOrdSE5	:=	SE5->(IndexOrd())		

		If !lCredito
			nRegSe5Ori := SE5->(Recno())
		EndIf	
		
		If SE1->E1_TIPO <> MVRECANT .AND. SE1->E1_TIPO <> MV_CRNEG .And. (lPccBxCr .Or. lIrPjBxCr) 
			dbSelectArea("SE5")
			SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
			If SE5->(DBSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
				While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
					SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
				
					If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
						If Alltrim(SE5->E5_MOTBX) == "PCC"
						nPisFin061	+= SE5->E5_VRETPIS
						nCofFin061	+= SE5->E5_VRETCOF
						nCslFin061	+= SE5->E5_VRETCSL
						ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
						nIrfFin061	+= SE5->E5_VRETIRF
						EndIf
					EndIf					
					SE5->(DbSkip())		
			EndDo
			EndIf
		EndIf
		
		SE5->(Dbgoto(nRegSE5))
		SE5->(Dbsetorder(nOrdSE5))
		
		If lCredito .and. !(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG)
			nIrfBaseC := nIrfBaseR := FBaseImp(nValorReal)
		EndIf
		
		If !__lIrfMR
			If cPaisLoc == "BRA" .and. lIrPjBxCr .and. !lCredito .And. !lNcc .And. nIrfFin061 == 0	 .And. !lRaRtImp
				FGrvIrRec(@nIrrf, nRecSe1, .F., cSequencia, "FINA070", 1)
				
				SE1->(dbGoTo(nRecSe1))
				FGSFQIRCR(nIrrf,nIRFBase,cSequencia)
				__cIdFk4IR := FK4->FK4_IDFK4
			EndIf
		EndIf
		
		SE5->(Dbgoto(nRegSE5))
		
		If !__lPccMR
			If cPaisLoc == "BRA" .And. lPccBxCr .And. !lCredito .And. !lNcc .And. !lRartImp
				F330GrvSFQ(cSequencia,nRecSe1)
			EndIf
		EndIf
		
		//Se houver impostos calculados pelo motor, então chama a função de gravação dos títulos de impostos pelo motor de retenções 
		If Len( __aImpos ) > 0
			aImpMRSel := aClone ( __aImpos )
		EndIf
		
		RestVarMR( aImpMRBrw ) //Volta as variáveis do motor com os dados do título posicionado na browse 
		
		If Len( aImpMRSel ) > 0
			If lCredito .And. __lTCnfgMR //Se estiver posicionado no RA, só manda gerar os título de impostos da NF caso o mesmo tipo de imposto já não tenha sido gerado na emissão do RA
				For nJ := 1 To Len( aImpMRSel )
					If aImpMRSel[nJ][8] $ "PIS|COF|CSL" .And. !__lRaRtPcc
						aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
					ElseIf aImpMRSel[nJ][8] == "IRF" .And. !__lRaRtIrf
						aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
					ElseIf aImpMRSel[nJ][8] == "ISS" .And. !__lRaRtIss
						aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
					Else
						aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
					EndIf
				Next nJ
			ElseIf __lTCnfgMR
				aAuxImpGrv := aClone( aImpMRSel )
			Endif
		EndIf
		
		//Chama a função de gravação do motor de retenções
		IF Len( aAuxImpGrv ) > 0
			F330GrvFKs( nRecSe1, aAuxImpGrv ) //Grava as tabelas FK3 e FK4
			FinGrvImp( "2", SE1->(Recno()), aAuxImpGrv, "FINA330", .F., {}, {}, .F., .F., .T., dBaixa, "FK1", cSequencia, .T. )
		EndIf

		//PONTO DE ENTRADA NA ALTERACAO DO HISTORICO NA SE5 NA INCLUSAO
		If ExistBlock( "F330AE5I" )
		ExecBlock("F330AE5I",.F.,.F.)
		EndIf

		// Integração SIGAPFS x SIGAFIN
		// Quando a compensação for posicionada no Tìtulo deve executar por aqui
		If lRet .And. FindFunction("JGrvBaixa")
			lRet := JGrvBaixa(SE1->(Recno()), SE5->(Recno()), nRegCmp)
		EndIf
			
		//Ajusto o E1_VALLIQ de acordo com o movimento do SE5
		RecLock("SE1")
			SE1->E1_VALLIQ := Iif(!Empty(__nMovRA) .And. !Empty(__nMovNF),Round(nValorReal, 2),If(SE1->E1_MOEDA == 1, Round(nValorReal, 2), Round(nVlrEstr, 2)))
			
			// Grava valor da correcao no titulo, para contabilizacao
			If (nValCm + nCm) != 0  
				If cPaisLoc == "BRA" .And. SE1->E1_MOEDA > 1 .And. nValCm != 0 .And. (lFina330 .OR. __lCmpM460)
					SE1->E1_CORREC := Round(nValCm, 2)
				Else
					SE1->E1_CORREC := nCm
				EndIf
			EndIf
		SE1->(MsUnlock())	

		// Atualizar saldo do cliente
		aArea	:= GetArea()
		nVlReal	:= nValorReal - nTitAcres + nTitDecre
		dbSelectArea("SA1")
		SA1->(DbSetOrder(1))
		
		If dbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA)
			RecLock("SA1")
			If lCredito
				AtuSalDup("+",nVlReal,1,SE1->E1_TIPO,,SE1->E1_EMISSAO)
			Else
				AtuSalDup("-",nVlReal,1,SE1->E1_TIPO,,SE1->E1_EMISSAO)
			EndIf
			SA1->(MsUnlock())
		EndIf
		
		RestArea(aArea)

		If lRet .And. !Empty(cAdiantamento)
			nCM := 0
			dbSelectArea("SE1")
			SE1->(dbSetOrder(1))
			SE1->(dbGoto(nRegCmp))
			
			//Motor de retenções - base
			If __lMotRet
				//Verifica as configurações de impostos pelo motor de retenção
				__lTCnfgMR	:= F330VldImp()
				
				lPccBxCr := ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
				lIrPjBxCr := ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )

				nBaseImpMR := FBaseImp(nValorReal)
			EndIf

			//Define valor das movimentações do título de destino
			If !Empty(__nMovRA) .And. !Empty(__nMovNF)
				nValorReal := If(lCredito , __nMovNF, __nMovRA)
				nVlrEstr := If(lCredito , __nMovRA, __nMovNF)
			ElseIf nMoeda == 1
				nValorReal := nValor
				If (!__lBq10925 .and. !lIsNcc) .AND. (!lRaRtImp)
					nValorReal := nValor - nPis - nCofins - nCsll - IiF(lIrPjBxCr,nIrrf,0)
				EndIf							
				nVlrEstr   := xMoeda(nValorReal, nMoeda, SE1->E1_MOEDA, dDataBase, __nCasDec, 0, Iif( lCredito .Or. !__lRaTxMov, __nTxTiBrw, __nTxMoedD) )
			ElseIf SE1->E1_MOEDA > 1 .And.  SE1->E1_MOEDA <> nMoeda // Compensação sem envolver moeda real
				nVlrEstr	:= xMoeda(nValor, nMoeda, SE1->E1_MOEDA, dDataBase, __nCasDec, __nTxmoedp, __nTxMoedD) //Transforma na moeda do título
				nValorReal	:= xMoeda(nVlrEstr, SE1->E1_MOEDA, 1, dDataBase, __nCasDec, __nTxMoedD)
			Else
				nVlrEstr   := nValor
				If (!__lBq10925 .and. !lIsNcc) .AND. (!lRaRtImp)
					nValImp := xMoeda((nPis+nCofins+nCsll+IiF(lIrPjBxCr,nIrrf,0)), 1, nMoeda, Ddatabase, __nCasDec, 0, __nTxMoedP)
					nVlrEstr := nValor - nValImp
				EndIf	
				nValorReal := xMoeda(nVlrEstr, nMoeda, 1, dDataBase, __nCasDec, __nTxTiBrw)
			EndIf		
			
			__nTotCtb	+= Round(nValorReal, 2) //Auxilia na contabilizacao posteriormente (deve estar na moeda forte)

			oModelBxR 	:= FWLoadModel("FINM010") 
			oModelBxR:SetOperation( MODEL_OPERATION_INSERT )
			oModelBxR:Activate()
			oModelBxR:SetValue( "MASTER", "E5_GRV", .T. )
			oModelBxR:SetValue( "MASTER", "NOVOPROC", .T. )
			oSubFK1 := oModelBxR:GetModel( "FK1DETAIL" )
			oSubFKA := oModelBxR:GetModel( "FKADETAIL" )
			oSubFK6 := oModelBxR:GetModel( "FK6DETAIL" )
			
			cCamposE5 := " { "
			cCamposE5 += "{'E5_FILIAL'		,'" +  cFilSE5 + "'}"
			cCamposE5 += ",{'E5_PREFIXO'	,'" +  SE1->E1_PREFIXO+ "'}"
			cCamposE5 += ",{'E5_NUMERO'		,'" +  SE1->E1_NUM + "'}"
			cCamposE5 += ",{'E5_PARCELA'	,'" +  SE1->E1_PARCELA + "'}"
			cCamposE5 += ",{'E5_CLIENTE'	,'" +  SE1->E1_CLIENTE + "'}"
			cCamposE5 += ",{'E5_CLIFOR'		,'" +  SE1->E1_CLIENTE + "'}"
			cCamposE5 += ",{'E5_LOJA'		,'" +  SE1->E1_LOJA + "'}"
			cCamposE5 += ",{'E5_BENEF'		,'" +  StrTran(SE1->E1_NOMCLI,"'","")+ "'}"
			cCamposE5 += ",{'E5_TIPO'		,'" +  SE1->E1_TIPO + "'}"
			cCamposE5 += ",{'E5_DTDIGIT'	, STOD('" + DTOS(dDataBase) + "')}"
			cCamposE5 += ",{'E5_DTDISPO'	, STOD('" + DTOS(dBaixa) + "')}"
			
			cChaveTit 	:= xFilial("SE1", SE1->E1_FILORIG)+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA
			cChaveFK7	:= FINGRVFK7("SE1", cChaveTit, SE1->E1_FILORIG)
			cIdFK1		:= FWUUIDV4()
			
			If !oSubFKA:IsEmpty()
				oSubFKA:AddLine()
			EndIf
		
			oSubFKA:SetValue( "FKA_IDORIG"	, cIdFK1 )
			oSubFKA:SetValue( "FKA_TABORI"	, 'FK1')

			If !oSubFK1:IsEmpty()
				oSubFK1:AddLine()
			EndIf
					
			oSubFK1:SetValue( "FK1_DATA"	, dBaixa )
			oSubFK1:SetValue( "FK1_NATURE"	, SE1->E1_NATUREZ )
			oSubFK1:SetValue( "FK1_RECPAG"	, "R" )
			oSubFK1:SetValue( "FK1_MOTBX"	, "CMP")
			oSubFK1:SetValue( "FK1_ORIGEM"	, FunName() )
			oSubFK1:SetValue( "FK1_SEQ"		, cSequencia )
			oSubFK1:SetValue( "FK1_DOC"		, cDocOriginal )
			oSubFK1:SetValue( "FK1_IDDOC"	, cChaveFK7 )
			oSubFK1:SetValue( "FK1_TPDOC"	, cTpDoc )
			oSubFK1:SetValue( "FK1_CCUSTO"	, SE1->E1_CCUSTO )	
			oSubFK1:SetValue( "FK1_FILORI"	, SE1->E1_FILORIG )
			oSubFK1:SetValue( "FK1_VALOR",  Iif(!Empty(__nMovRA) .And. !Empty(__nMovNF), Round(nValorReal, 2),If(SE1->E1_MOEDA == 1, Round(nValorReal, 2), Round(nVlrEstr, 2))))
			oSubFK1:SetValue( "FK1_VLMOE2", Iif(!Empty(__nMovRA) .And. !Empty(__nMovNF), Round(nVlrEstr, 2),If(SE1->E1_MOEDA == 1, Round(nVlrEstr, 2), Round(nValorReal, 2))))
			oSubFK1:SetValue( "FK1_SITCOB"	, SE1->E1_SITUACA )
			oSubFK1:SetValue( "FK1_MOEDA",  StrZero(SE1->E1_MOEDA, 2))
			oSubFK1:SetValue( "FK1_LA"		, IIF(lPadrao .and. nContab == 1,"S","N") )
			oSubFK1:SetValue( "FK1_IDCOMP"	, cChvFK7out )
			If __lNumBor
				oSubFK1:SetValue( "FK1_NUMBOR",SE1->E1_NUMBOR)
			EndIF			
					
			If lCredito
				oSubFK1:SetValue( "FK1_HISTOR"	, OemToAnsi(If(lIsNcc,STR0078,STR0036)) ) //"Compensação Nota de Crédito" //"Compensaçäo de Adiantamentos"
				oSubFK1:SetValue( "FK1_TPDOC"	, "CP" )
			Else
				oSubFK1:SetValue( "FK1_HISTOR"	, OemToAnsi(STR0077) ) //"Baixa por Compensação"
				oSubFK1:SetValue( "FK1_TPDOC"	, "BA" )
			EndIf
			
			oSubFK1:SetValue( "FK1_LOTE"  , cLote )
			
			//Ponto de Entrada para permitir a manipulação da filial no movimento bancario
			If ! lMultFil
				cCamposE5 += ",{'E5_FILIAL'		,'" + xFilial("SE5") + "' } "
			Else
				cCamposE5 += ",{'E5_FILIAL'		,'" + ExecBlock("SE5MTFIL",.F.,.F.,cFilAnt)+"' } "
			EndIf
		
			cCamposE5 += ",{'E5_LA'		,'" +  IIF(lPadrao .and. nContab == 1,"S","N") + "'}"

			If !lPccBxCr
				//Acerto valor dos impostos - Tecnofibras
				If lImpComp .and. lIsNcc .and. lPccBaixa
					//Gravo Valores dos impostos no SE5 (ja locado)
					cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nValPis)+"}"																		
					cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nValCof)+"}"
					cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nValCsl)+"}"  
				EndIf
			EndIf

			// alimenta o VRET do pcc na compensacao NCC mas nao gera o titulo, para
			//que este valor nao seja calculado na baixa do restante.
			If lCredito .And. ( lIsNcc .Or. !(SE1->E1_TIPO $ MVRECANT) ) 
				If lPccBaixa
					cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nPis)+"}"
					cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nCofins)+"}"
					cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nCsll)+"}"
					cCamposE5 += ",{'E5_PRETPIS' , '7' }"
					cCamposE5 += ",{'E5_PRETCOF' , '7' }"
					cCamposE5 += ",{'E5_PRETCSL' , '7' }"
				ElseIf !(SE1->E1_TIPO $ MVRECANT)
					cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nPisCalc)+"}"
					cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nCofCalc)+"}"
					cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nCslCalc)+"}"
					cCamposE5 += ",{'E5_PRETPIS' , '1' }"
					cCamposE5 += ",{'E5_PRETCOF' , '1' }"
					cCamposE5 += ",{'E5_PRETCSL' , '1' }"
				EndIf

				If lIrPjBxCr
					cCamposE5 += ",{'E5_VRETIRF' , "+cValToChar(nIrrf)+"}"
					cCamposE5 += ",{'E5_PRETIRF' , '7' }"			
				EndIf

			EndIf
			
			If nAcresc <> 0
				If !oSubFK6:IsEmpty()
					oSubFK6:AddLine()
				EndIf
				
				nAcresc		:=	Round(xMoeda(nAcresc, SE1->E1_MOEDA, 1, Nil, __nCasDec, __nTxTiBrw), 2)

				oSubFK6:SetValue( 'FK6_GRVSE5'  , .F.)		
				oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
				oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
				oSubFK6:SetValue( 'FK6_TPDOC'	, 'JR' )
				oSubFK6:SetValue( 'FK6_VALCAL'	, nAcresc )	
				oSubFK6:SetValue( 'FK6_VALMOV'	, nAcresc )
				oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
				oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
				oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0049) ) //ACRESCIMO
				
				cCamposE5 += ",{'E5_VLJUROS'," + Str(nAcresc) + " }"
				cCamposE5 += ",{'E5_VLACRES'," + Str(nAcresc) + " }"
			EndIf
			
			nDiff := (SE1->E1_SALDO - FK1->FK1_VALOR)
			lDescToler := ( nDiff > 0 .And. nDiff <= nMVToler )
			If nDecres+nDescD <> 0 .Or. lDescToler
				If !oSubFK6:IsEmpty()
					oSubFK6:AddLine()
				EndIf
				
				nDecres := Round(xMoeda(nDecres + nDescD + if(lDescToler, nDiff ,0), SE1->E1_MOEDA, 1, Nil, __nCasDec, __nTxTiBrw), 2)
				
				oSubFK6:SetValue( 'FK6_GRVSE5'  , .F.)		
				oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
				oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
				oSubFK6:SetValue( 'FK6_TPDOC'	, 'DC' )
				oSubFK6:SetValue( 'FK6_VALCAL'	, nDecres )
				oSubFK6:SetValue( 'FK6_VALMOV'	, nDecres )
				oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
				oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
				oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0050) ) //DECRESCIMO
				oSubFK6:SetValue( 'FK6_TPDESC'	, Iif(SE1->E1_TPDESC == 'C', '1', '2') )
			
				cCamposE5 += ",{'E5_VLDESCO'," + Str(nDecres) + " }"
				cCamposE5 += ",{'E5_VLDECRE'," + Str(nDecres) + " }"
			EndIf

			If lDescToler
				RecLock("SE1", .F.)
					Replace E1_SDDECRE With E1_SDDECRE -= Round(xMoeda(nDiff, nMoeda, 1, Nil, __nCasDec, __nTxTiBrw), 2)
				SE1->(MsUnLock())
			EndIf

			If !lCredito
				nAcresc := nTitAcres
				nDecres := nTitDecre
			EndIf

			//VA: Adiciona os valores da FKD ao model
			If __l330Va .And. (lCredito .Or. (!lCredito .And. nSaldoVA <> 0 ))
				cIdDoc := oSubFK1:GetValue("FK1_IDDOC")
				FSetFK6FKD( oSubFK6, cIdDoc, cIdFK1, "R" )
			EndIf
			
			If SE1->E1_MOEDA > 1 .Or. cPaisLoc != "BRA"
				nCM := FA330Corr(nVlrEstr, nVlrNF, "SE1", __nTxTiBrw)
			EndIf

			// Grava o valor de correção monetária no SE5 para ser visualizado na consulta
			If SE1->E1_MOEDA <> 1 .And. nCm != 0 .and. (lFina330 .OR. __lCmpM460)
				If !oSubFK6:IsEmpty()
					oSubFK6:AddLine()
				EndIf
				
				oSubFK6:SetValue( 'FK6_GRVSE5'  , .T.)		
				oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )
				oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
				oSubFK6:SetValue( 'FK6_TPDOC'	, 'CM' )
				oSubFK6:SetValue( 'FK6_VALCAL'	, nCm)	
				oSubFK6:SetValue( 'FK6_VALMOV'	, nCm)
				oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
				oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
				
				If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0075) ) //CORREC.DE ADIANTAMENTO
				Else
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0076) ) //CORREC. MONET S/ RECEBTO
				EndIf
				
				cCamposE5 += ",{'E5_VLCORRE'," + Str(nCm) + " }"	
			EndIf
			
			// Grava fornecedor do titulo no movimento do PA, para ser utilizado no
			//cancelamento da compensacao, quando se utiliza PA de outros fornecedores para compensar.
			cCamposE5 += ",{'E5_FORNADT' , '" + cCliOri + "' } "
			cCamposE5 += ",{'E5_LOJAADT' , '" + cLojaOri + "' } "

			If l330Mov2
				ExecBlock("SE5FI331",.f.,.f.)
			EndIf
			
			If SE1->E1_MOEDA > 1
				If cPaisLoc == "BRA"
					oSubFK1:SetValue("FK1_TXMOED", Iif( !lCredito .And. nMoeda == 1 .And. __lRaTxMov, __nTxMoedD, __nTxTiBrw) )
				ElseIf cPaisLoc == "MEX" .And.  Type("aTxMoedas") # "U"
					oSubFK1:SetValue( "FK1_TXMOED" , aTxMoedas[nMoeda][2] )
				EndIf
			EndIf
			
			cCamposE5 += " } "
			oModelBxR:SetValue("MASTER", "E5_CAMPOS", cCamposE5 )
		
			If oModelBxR:VldData()
				oModelBxR:CommitData()
				
				//VA: Atualiza a FKD com as informações da baixa
				If __l330Va .And. !oSubFK6:IsEmpty()
					For nCntFK6 := 1 to oSubFK6:Length()
						oSubFK6:GoLine(nCntFK6)
						If oSubFK6:GetValue("FK6_TPDOC",nCntFK6) $ "VA"
							FA330VAFKD(cIdDoc, oSubFK6:GetValue("FK6_CODVAL"), If(lIdFkd, oSubFK6:GetValue("FK6_IDFKD"),""), dBaixa, oSubFK6:GetValue("FK6_VALMOV")) 
						EndIf
					Next
				EndIf
			
				SE5->(DbGoto(oModelBxR:GetValue("MASTER","E5_RECNO")))	//posicionando o movimento de compensação recém-gravado
				aAdd( aBaixas, { { "CMP", cSequencia, SE5->(Recno()), SE1->E1_TIPO, cAdiantamento, SE5->E5_DOCUMEN, SE1->E1_ORIGEM, SE1->(Recno()) } } )
		
				aAdd(aRecSE5, FIM010RSE5()[Len(FIM010RSE5())])
				
				aArea		:= GetArea()
				aAreaFK1 	:= FK1->(GetArea())
				
				DbSelectArea("FK1")
				DbGoTo(nRecFk1)
				
				RecLock("FK1", .F.)
					FK1->FK1_IDCOMP := cChaveFK7
				MsUnLock()
				
				RestArea(aAreaFK1)
				RestArea(aArea)
			Else
				lRet := .F.
				cLog := cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_IDFIELDERR]) + ' - '
				cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_ID]) + ' - '
				cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_MESSAGE])
				Help( ,,"FA330MOV02",,cLog, 1, 0 )   
			EndIf
			
			If !Empty(nCm)
				F330MoedCm()
			EndIf		
			
			oSubFK1 := Nil
			oSubFKA := Nil
			oSubFK6 := Nil

			oModelBxR:DeActivate()
			oModelBxR:Destroy()
			oModelBxR:= Nil

			nTxMoed1	:=	nTxMoed2	:=	nValEmis	:=	nValBax	:=	nValCm:=	0

			//Carregando dados bancarios caso seja necessario gravar o registro da diferenca cambial.
			cBcoSE5		:=	SE5->E5_BANCO
			cAgSE5		:=	SE5->E5_AGENCIA
			cCtSE5		:=	SE5->E5_CONTA
			cLoteSE5	:=	SE5->E5_LOTE

			//Verifica se o titulo já possui impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
			nPisFin061	:=	0
			nCofFin061	:=	0
			nCslFin061	:=	0
			nIrfFin061	:=	0
			nRegSE5	:=	SE5->(Recno())
			nOrdSE5	:=	SE5->(IndexOrd())
			If SE1->E1_TIPO <> MVRECANT .AND. SE1->E1_TIPO <> MV_CRNEG .And. lPccBxCr .And. lIrPjBxCr                                                                                               			
				dbSelectArea("SE5")
				SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
				If SE5->(DBSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
					While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
						SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
					
						If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
							If Alltrim(SE5->E5_MOTBX) == "PCC"
							nPisFin061	+= SE5->E5_VRETPIS
							nCofFin061	+= SE5->E5_VRETCOF
							nCslFin061	+= SE5->E5_VRETCSL
							ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
							nIrfFin061	+= SE5->E5_VRETIRF
							EndIf
						EndIf
						SE5->(DbSkip())
						
				EndDo
				EndIf
			EndIf
			SE5->(Dbgoto(nRegSE5))
			SE5->(Dbsetorder(nOrdSE5))				
			
			If !__lIrfMR .And. lIrPjBxCr .And. lCredito .And. !lRaRtImp .and. !lNcc .And. nIrfFin061 == 0 	
				FGrvIrRec(@nIrrf, nRegCmp, .F., cSequencia, "FINA070", 1)
				
				FGSFQIRCR(nIrrf,nIRFBase,cSequencia)
				__cIdFk4IR := FK4->FK4_IDFK4
			EndIf

			aAreaSE5 := SE5->(GetArea()) //para efeito de acerto no posicio. da SE5 na contabil.		
			//Gravando diferenca cambial		
			aBaixaSE5 := FIM010RSE5()		
			RestArea(aAreaSE5)
			
			//Motor de retenções - Calcula os impostos pelo motor de retenções
			If __lMotRet .And. __lTCnfgMR
				F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, nBaseImpMR, dDataBase, SE1->E1_TIPO )
			EndIf
			
			//Se houver impostos calculados pelo motor, então chama a função de gravação dos títulos de impostos pelo motor de retenções 
			aSize( aImpMRSel, 0 )
			aImpMRSel := {}
			aSize( aAuxImpGrv, 0 )
			aAuxImpGrv := {}
			If Len( __aImpos ) > 0
				aImpMRSel := aClone ( __aImpos )
			EndIf		 
			If Len( aImpMRSel ) > 0
				If lCredito //Se estiver posicionado no RA, só manda gerar os título de impostos da NF caso o mesmo tipo de imposto já não tenha sido gerado na emissão do RA
					For nJ := 1 To Len( aImpMRSel )
						If aImpMRSel[nJ][8] $ "PIS|COF|CSL" .And. !__lRaRtPcc
							aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
						ElseIf aImpMRSel[nJ][8] == "IRF" .And. !__lRaRtIrf
							aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
						ElseIf aImpMRSel[nJ][8] == "ISS" .And. !__lRaRtIss
							aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
						Else
							aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
						EndIf
					Next nJ
				ElseIf __lTCnfgMR
					aAuxImpGrv := aClone( aImpMRSel )
				EndIf
			EndIf
			__lTCnfgMR := .F.
			//Chama a função de gravação do motor de retenções
			If Len( aAuxImpGrv ) > 0
				F330GrvFKs( nRegCmp, aAuxImpGrv ) //Grava as tabelas FK3 e FK4
				FinGrvImp( "2", SE1->(Recno()), aAuxImpGrv, "FINA330", .F., {}, {}, .F., .F., .T., dBaixa, "FK1", cSequencia, .T. )
			EndIf
					
			/////////////////////
			// PCC Baixa CR
			// Grava relacionamento no SFQ
			// Grava titulos PIS/COF/CSL no SE1
			If !__lPccMR .And. cPaisLoc == "BRA" .and. (lPccBxCr .or. lIrPjBxCr) .and. lCredito .and. !lNcc .And. !lRartImp
				F330GrvSFQ(cSequencia,nRegCmp)
			EndIf
			
			RestVarMR( aImpMRBrw ) //Volta as variáveis do motor com os dados do título posicionado na browse
			
			// Grava valor da correcao no titulo, para contabilizacao
			If (nValCm+nCm) != 0
				SE1->(RecLock("SE1"))
				If cPaisLoc == "BRA" .And. SE1->E1_MOEDA > 1 .And. nValCm <>0 .And. FUNNAME() $ "FINA330#FINA740"
					SE1->E1_CORREC := Round(nValCm, nDecs1)
				Else
					SE1->E1_CORREC := nCm
				Endif
				SE1->(MsUnlock())
			EndIf
			
			// Atualizar saldo do cliente
			nVlReal	:= nValorReal - nAcresc + nDecres
			aArea		:= GetArea()
			dbSelectArea("SA1")
			SA1->(DbSetOrder(1))
			If SA1->(dbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA))
				SA1->(RecLock("SA1"))
				If lCredito
					AtuSalDup("-",nVlReal,1,SE1->E1_TIPO,,SE1->E1_EMISSAO)
				Else
					AtuSalDup("+",nVlReal,1,SE1->E1_TIPO,,SE1->E1_EMISSAO)
				EndIf
				SA1->(MsUnlock())
			EndIf
			RestArea(aArea)
		EndIf
	EndIf
	
	FZerSFQIr()
	dbSelectArea(cAlias)
Return .T.

/*/{Protheus.doc} F330ActImp
	Acerta valores dos impostos na compensacao CR com NCC
	
	@author  Mauricio Pequim Jr
	@since   11.11.05
/*/
Function F330ActImp(nRecSE1,nValorReal,nValPis,nValCof,lBaixa,lCredito,nValCsl,nTotAbto)
	Local nProporcao := 0
	Local cKeySe1 := ""
	Local aArea  := GetArea()
	Local nTotAbt := 0
	Local nTotAbImp := 0
	Local nSe5Rec := 0   

	//Controle de abatimento
	Local lTitpaiSE1 := .T.
	Local nOrdTitPai:=0
	Local cTitPai	:=""
	Local bWhile:= {||!EOF() .And.MsSeek(xFilial("SE1")+cKeySe1)}  

	Default nValPis := 0
	Default nValCof := 0
	Default nValCsl := 0
	Default lBaixa  := .T.

	If Select("__SE1") == 0
		SumAbatRec("","","",1,"")
	Endif

	DbSelectArea("__SE1")
	dbSetOrder(2)
	dbGoto(nRecSe1)  //posiciono no titulo pai no SE1

	//Verifico valor dos abatimentos antes de proporcionalizar
	nTotAbImp := 0
	nTotAbt  := SumAbatRec(__SE1->E1_PREFIXO,__SE1->E1_NUM,__SE1->E1_PARCELA,__SE1->E1_MOEDA,"V",dDataBase,@nTotAbImp) 
	nTotAbt	 -= nTotAbImp 	

	DbSelectArea("__SE1")
	dbSetOrder(2)
	dbGoto(nRecSe1)  //posiciono no titulo pai no SE1

	nSe5Rec := SE5->( RECNO() )

	aValor:=Baixas(__SE1->E1_NATUREZ,__SE1->E1_PREFIXO,__SE1->E1_NUM,__SE1->E1_PARCELA,__SE1->E1_TIPO,__SE1->E1_MOEDA,"R",__SE1->E1_CLIENTE,dDataBase,__SE1->E1_LOJA)

	SE5->( dbGoto(nSE5Rec) )

	nProporcao := nValorReal / (__SE1->E1_SALDO-nTotAbt+aValor[5] )

	cKeySe1 := __SE1->(E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA)	  
	cTitPai	:= __SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA)	 

	If lBaixa
		//Se for a baixa que zera o saldo, a proporcao do imposto deverá ser igual a 1 para que seja
		//feita a compensacao correta
		If __SE1->E1_SALDO == 0
			nProporcao := 1
			nValPis := __SE1->E1_PIS
			nValCof := __SE1->E1_COFINS
			nValCsl := __SE1->E1_CSLL
		Else
			nValPis := ((__SE1->E1_PIS+aValor[14]) * nProporcao)
			nValCof := ((__SE1->E1_COFINS+aValor[15]) * nProporcao)
			nValCsl := ((__SE1->E1_CSLL+aValor[18]) * nProporcao)
		EndIf
	Else
		nValPis := se5->e5_vretpis
		nValCof := se5->e5_vretcof
		nValCsl := se5->e5_vretcsl
	EndIf

	If nValPis+nValCof+nValCsl > 0
		//Acerto o valor dos impostos no titulo principal
		RecLock("__SE1")
		If lBaixa
			__SE1->E1_PIS -= nValPis
			__SE1->E1_COFINS -= nValCof
			__SE1->E1_CSLL -= nValCsl
		Else
			__SE1->E1_PIS += nValPis
			__SE1->E1_COFINS += nValCof
			__SE1->E1_CSLL += nValCsl
		Endif
		MsUnLock()
		
		//Acerto os valores dos titulos de impostos
		If lTitpaiSE1
			If (nOrdTitPai:= OrdTitpai()) > 0
				DbSetOrder(nOrdTitPai)
				If	DbSeek(xFilial("SE1")+cTitPai)    
					bWhile  := {|| !Eof() .And. Alltrim(__SE1->E1_TITPAI) == Alltrim(cTitPai)}   
				Else
						__SE1->(dbSetOrder(2))    
				Endif
			Endif
		Endif
		
		While Eval(bWhile)
		
			//Pis
			If __SE1->E1_TIPO $ MVPIABT
				If lBaixa
					RecLock("__SE1")
					__SE1->E1_VALOR -= nValPis
					__SE1->E1_SALDO := __SE1->E1_VALOR
					__SE1->E1_VLCRUZ := __SE1->E1_VALOR
					MsUnlock()
				Else
					RecLock("__SE1")
					__SE1->E1_VALOR += nValPis
					__SE1->E1_SALDO := __SE1->E1_VALOR
					__SE1->E1_VLCRUZ := __SE1->E1_VALOR
					MsUnlock()
				Endif
			Endif
		
			//Cofins
			If __SE1->E1_TIPO $ MVCFABT
				If lBaixa
					RecLock("__SE1")
					__SE1->E1_VALOR -= nValCof
					__SE1->E1_SALDO := __SE1->E1_VALOR
					__SE1->E1_VLCRUZ := __SE1->E1_VALOR
					MsUnlock()
				Else
					RecLock("__SE1")
					__SE1->E1_VALOR += nValCof
					__SE1->E1_SALDO := __SE1->E1_VALOR
					__SE1->E1_VLCRUZ := __SE1->E1_VALOR
					MsUnlock()
				Endif
			Endif
			
			//CSLL
			If __SE1->E1_TIPO $ MVCSABT
				If lBaixa
					RecLock("__SE1")
					__SE1->E1_VALOR -= nValCsl
					__SE1->E1_SALDO := __SE1->E1_VALOR
					__SE1->E1_VLCRUZ := __SE1->E1_VALOR
					MsUnlock()
				Else
					RecLock("__SE1")
					__SE1->E1_VALOR += nValCsl
					__SE1->E1_SALDO := __SE1->E1_VALOR
					__SE1->E1_VLCRUZ := __SE1->E1_VALOR
					MsUnlock()
				Endif
			Endif  
			__SE1->( DbSkip() )
		Enddo
	EndIf

	RestArea(aArea)

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} IntegDef
	Funcao de integracao com o adapter EAI para o recebimento de compensacao
	de titulos a receber.

	@param   Caracter, cXML, Variavel com conteudo xml para envio/recebimento.
	@param   Caracter, cTypeTrans, Tipo de transacao. (Envio/Recebimento)
	@param   Caracter, cTypeMsg, Tipo de mensagem. (Business Type, WhoIs, etc)
	@param   Caracter, cVersion, Versão da mensagem.

	@author  TOTVS
	@version P12
	@since   03/02/2017
	@return  Array, Array contendo o resultado da execucao e a mensagem Xml de retorno.
			aRet[1] - (boolean) Indica o resultado da execução da função
			aRet[2] - (caracter) Mensagem Xml para envio

	@obs
	O método irá retornar um objeto do tipo TOTVSBusinessEvent caso
	o tipo da mensagem seja EAI_BUSINESS_EVENT ou um tipo
	TOTVSBusinessRequest caso a mensagem seja do tipo TOTVSBusinessRequest.
	O tipo da classe pode ser definido com a função EAI_BUSINESS_REQUEST.
/*/
//-------------------------------------------------------------------
Static Function IntegDef( cXML, nTypeTrans, cTypeMessage, cVersion )
	Local aRet := {}

	aRet := FINI330( cXML, nTypeTrans, cTypeMessage, cVersion )
Return aRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RABxAnt
	Função para verificação do valor já compensado do RA

	@author    Rodrigo Oliveira
	@version   12
	@since     18/08/2017

	@return nTotCmp - retorna o total já compensado desse RA 
/*/
//-----------------------------------------------------------------------------------------------------

Static Function RABxAnt() As Numeric
	Local aArea 	As Array
	Local aAreaSE5 	As Array
	Local cQuery	As Character
	Local nSld		As Numeric
	Local nI		As Numeric
	
	aArea 		:= GetArea()
	aAreaSE5 	:= GetArea()
	cQuery		:= ""
	nSld		:= 0
	nI			:= 0

	cQuery := " SELECT SUM(SE5.E5_VALOR) TOTAL, 'COMP' AS SITUA "
	cQuery += " FROM " + RetSqlName("SE5") + " SE5 "
	cQuery += " WHERE SE5.E5_FILIAL = '" + xFilial("SE5") + "' " 
	cQuery += " AND SE5.E5_NUMERO = '" + SE1->E1_NUM + "' " 
	cQuery += " AND SE5.E5_TIPO = '" + SE1->E1_TIPO + "' " 
	cQuery += " AND SE5.E5_MOTBX = 'CMP' " 
	cQuery += " AND SE5.E5_TIPODOC != 'ES' "
	cQuery += " AND SE5.D_E_L_E_T_ = '' "
	
	cQuery += " UNION "
	
	cQuery += " SELECT SUM(E5EST.E5_VALOR) TOTAL, 'ESTORNO' AS SITUA 
	cQuery += " FROM " + RetSqlName("SE5") + " E5EST "
	cQuery += " WHERE E5EST.E5_FILIAL = '" + xFilial("SE5") + "' " 
	cQuery += " AND E5EST.E5_NUMERO = '" + SE1->E1_NUM + "' " 
	cQuery += " AND E5EST.E5_TIPO = '" + SE1->E1_TIPO + "' " 
	cQuery += " AND E5EST.E5_MOTBX = 'CMP' " 
	cQuery += " AND E5EST.E5_TIPODOC = 'ES' "
	cQuery += " AND E5EST.D_E_L_E_T_ = '' "
	
	cQuery := ChangeQuery(cQuery)
	
	dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBEST",.f.,.t.)
	
	("TRBEST")->(DbGoTop())
	
	For nI := 1 to 2
		If AllTrim(("TRBEST")->SITUA) == 'COMP'
			nSld	+= ("TRBEST")->TOTAL
		Else
			nSld	-= ("TRBEST")->TOTAL
		EndIf
		("TRBEST")->(DbSkip())
	Next 
	
	("TRBEST")->(DbCloseArea())
	
	RestArea(aAreaSE5)
	RestArea(aArea)

Return nSld

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F330VldImp()
	Função para retornar as configurações de impostos através do motor de retenções

	@author Pedro Alencar
	@since 08/01/2018
	@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function F330VldImp()
	Local nZ As Numeric
	Local lPisMR As Logical
	Local lCofMR As Logical
	Local lCslMR As Logical
	Local lPisBxMR As Logical
	Local lCofBxMR As Logical
	Local lCslBxMR As Logical
	Local lRaRtPis As Logical
	Local lRaRtCof As Logical
	Local lRaRtCsl As Logical
	Local aImpConf As Array
	Local cTitPosic As Char
	Local cChaveTit As Character
	Local cIdDocFK7 As Character
	//Local lCfgAdto	As Logical
	
	lPisMR := .F.
	lCofMR := .F.
	lCslMR := .F.
	lPisBxMR := .F.
	lCofBxMR := .F.
	lCslBxMR := .F.
	lRaRtPis := .F.
	lRaRtCof := .F.
	lRaRtCsl := .F.
	//lCfgAdto := .F.
	aImpConf := {}
	cTitPosic := SE1->E1_FILORIG + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO + SE1->E1_CLIENTE + SE1->E1_LOJA
	
	/*---------------------------------------------------------------------------
	Estrutura do aImpConf
	[1] = Codigo do tipo de imposto (cCodFOO)
	[2] = Fato gerador ( 1=Competência; 2=Caixa ) 
	[3] = Código FOI
	[4] = Tipo de Movimento (FKM_TPMVEM)
	[5] = Valor da nota (FKM_VLNOTE)
	[6] = Ação para antecipações (FKM_ANTEBX: 1= Retém; 2=Provisiona; 3=Sem ação)
	----------------------------------------------------------------------------*/
	If __cOldMRCf <> cTitPosic //Chama a função para ver os impostos configurados pelo motor de retenções, caso já não tenha sido chamada para o título posicionado 
		ClrVarMRCf()
		__cOldMRCf := cTitPosic

		cChaveTit 	:= SE1->E1_FILIAL + "|" +  SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" +SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
		cIdDocFK7 	:= FinBuscaFK7(cChaveTit, "SE1",SE1->E1_FILORIG)
		aImpConf 	:= FinImpConf( "2", SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_NATUREZ, cIdDocFK7,, @__oPrepCP, @__oQryFKQ )
  		__lTCnfgMR	:= Len(aImpConf) > 0 
		For nZ := 1 To Len( aImpConf )
			Do Case
				
				Case aImpConf[nZ,1] == "PIS" //.And. ( !lCfgAdto .Or. ( lCfgAdto .And. aImpConf[nZ,6] == '1'))
					lPisMR 		:= .T.
					lPisBxMR 	:= ( aImpConf[nZ,2] == "2" )
					lRaRtPis 	:= ( aImpConf[nZ,6] == "1" )
				
				Case aImpConf[nZ,1] == "COF" //.And. ( !lCfgAdto .Or. ( lCfgAdto .And. aImpConf[nZ,6] == '1'))
					lCofMR 		:= .T.
					lCofBxMR 	:= ( aImpConf[nZ,2] == "2" )
					lRaRtCof 	:= ( aImpConf[nZ,6] == "1" )
				
				Case aImpConf[nZ,1] == "CSL" //.And. ( !lCfgAdto .Or. ( lCfgAdto .And. aImpConf[nZ,6] == '1'))
					lCslMR 		:= .T.
					lCslBxMR 	:= ( aImpConf[nZ,2] == "2" )
					lRaRtCsl 	:= ( aImpConf[nZ,6] == "1" )
				
				Case aImpConf[nZ,1] == "IRF" //.And. ( !lCfgAdto .Or. ( lCfgAdto .And. aImpConf[nZ,6] == '1'))
					__lIrfMR 	:= .T.
					__lIrfBxMR 	:= ( aImpConf[nZ,2] == "2" )
					__lRaRtIrf 	:= ( aImpConf[nZ,6] == "1" )
				
				Case aImpConf[nZ,1] == "ISS" //.And. ( !lCfgAdto .Or. ( lCfgAdto .And. aImpConf[nZ,6] == '1'))
					__lIssMR 	:= .T.
					__lIssBxMR 	:= ( aImpConf[nZ,2] == "2" )
					__lRaRtIss 	:= ( aImpConf[nZ,6] == "1" )
				OtherWise
					__lImpMR 	:= .T.
					__lImpBxMR	:= ( aImpConf[nZ,2] == "2" )
			EndCase
		Next nZ
		
		__lPccMR := lPisMR .Or. lCofMR .Or. lCslMR
		__lPccBxMR := lPisBxMR .Or. lCofBxMR .Or. lCslBxMR
		__lRaRtPcc := lRaRtPis .Or. lRaRtCof .Or. lRaRtCsl

		__aImpAnt := aClone(aImpConf)

		FWFreeArray(aImpConf)
		aImpConf := {}

	Else
		__lTCnfgMR	:= Len(__aImpAnt) > 0 
		For nZ := 1 To Len(__aImpAnt)
			Do Case
				
				Case __aImpAnt[nZ,1] == "IRF"
					__lIrfMR 	:= .T.
					__lIrfBxMR 	:= ( __aImpAnt[nZ,2] == "2" )
					__lRaRtIrf 	:= ( __aImpAnt[nZ,6] == "1" )
				
				Case __aImpAnt[nZ,1] == "ISS"
					__lIssMR 	:= .T.
					__lIssBxMR 	:= ( __aImpAnt[nZ,2] == "2" )
					__lRaRtIss 	:= ( __aImpAnt[nZ,6] == "1" )
				OtherWise
					__lImpMR 	:= .T.
					__lImpBxMR	:= ( __aImpAnt[nZ,2] == "2" )
			EndCase
		Next nZ
		
	EndIf	
	
Return __lTCnfgMR

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F330CalImp()
	Função para realizar o cálculo de imposto através do motor de retenções

	@param cNatMR, Natureza para cálculo do imposto pelo motor de retenções
	@param cCliMR, Cliente para cálculo do imposto pelo motor de retenções
	@param cLojaMR, Loja para cálculo do imposto pelo motor de retenções
	@param cFilMR, Filial de origem para cálculo do imposto pelo motor de retenções
	@param nBaseMR, Valor base para cálculo do imposto pelo motor de retenções
	@param dDataMR, Data para cálculo do imposto pelo motor de retenções
	@param cTipoTitMR, Tipo do tíutlo para cálculo do imposto pelo motor de retenções 
	@author Pedro Alencar
	@since 12/01/2018
	@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function F330CalImp( cNatMR As Char, cCliMR As Char, cLojaMR As Char, cFilMR As Char, nBaseMR As Numeric, dDataMR As Date, cTipoTitMR As Char, lTroca As Logical )
	Local nZ 		As Numeric
	Local cTitPosic As Char
	Local nI 		As Numeric
	Local nX 		As Numeric
	Local cChaveAux As Char
	Local aImposE 	As Array
	Local nTotAdto	As Numeric
	Local lPccBxCr 	As Logical
	Local lMRVrTimp As Logical
	Local nVlParcl	As Numeric
	Local aArea     As Array
	
	Default cNatMR 		:= ""
	Default cCliMR 		:= ""
	Default cLojaMR 	:= ""
	Default cFilMR 		:= ""
	Default nBaseMR 	:= 0
	Default dDataMR		:= CtoD("//")
	Default cTipoTitMR 	:= ""
	Default lTroca		:= .F.
	
	lMRVrTimp	:= Type('lRarTimpMR') != "U"
	
	lPccBxCr := ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. FPccBxCr() )
	
	aImposE		:= {}
	nVlParcl	:= 0
	aArea 		:= GetArea()
	
	cTitPosic := SE1->E1_FILORIG + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO + SE1->E1_CLIENTE + SE1->E1_LOJA
	cChaveAux := FWxFilial( "SE1", SE1->E1_FILIAL ) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA	
	
	If __lPccMR 
		nPis 	:= 0
		nCofins := 0
		nCsll 	:= 0
	EndIf
	If __lIrfMR																						
		nIrrf 	:= 0
	EndIf
	
	ClrVarMRCl()
	__cOldMRCl := cTitPosic

	/*-------------------------------------------
	Estrutura da aImpos
	[1] = Codigo do tipo de imposto (FKM_CODIGO)
	[2] = Base do imposto
	[3] = Valor calculado do imposto
	[4] = Base de retenção do imposto
	[5] = Valor a reter do imposto
	[6] = IDRET FK4
	[7] = Array contendo os Recnos FK3 das pendências de retenção	
	[8] = Tipo do Imposto (SX5 - 0C )
	[9] = Fato gerador ( 1=Competência; 2=Caixa )
	[10] = Natureza do imposto
	[11] = Tabela onde foi gerado o imposto
	[12] = Recno do titulo de imposto gerado
	[13] = Ação aplicada no valor da nota na emissão(1 = subtrai, 2 = soma, 3 = sem ação) 
	[14] = Carteira de movimento na emissão (1 = Pagar, 2 = Receber)
	[15] = Tipo de movimento na emissão (1 = Abtimento, 2 = Provisão, 3 = Retenção, 4 = Não Gerar)
	[16] = Ação aplicada no valor da nota na baixa(1 = subtrai, 2 = soma, 3 = sem ação)
	[17] = Carteira de movimento na baixa (1 = Pagar, 2 = Receber)
	[18] = Tipo de movimento na baixa (1 = Abtimento, 2 = Provisão, 3 = Retenção, 4 = Não Gerar) 
	[19] = Ação sobre títulos de antecipação pagamento/recebimento: 1 = Retém, 2 = Provisiona, 3 = sem ação
	--------------------------------------------*/
	
	If lTroca
		aImposE := FMRGetArr('2', .F.)
		For nI := 1 To Len( aImposE )
			Do Case
				Case aImposE[nI,8] == "PIS" .And. aImposE[nI,9] == '1'
					__nPisCaMR += aImposE[nI,5]
				Case aImposE[nI,8] == "COF" .And. aImposE[nI,9] == '1'
					__nCofCaMR += aImposE[nI,5]
				Case aImposE[nI,8] == "CSL" .And. aImposE[nI,9] == '1'
					__nCslCaMR += aImposE[nI,5]
				Case aImposE[nI,8] == "IRF" .And. aImposE[nI,9] == '1'
					__nIrfCaMR += aImposE[nI,5]
				Case aImposE[nI,8] == "ISS" .And. aImposE[nI,9] == '1'
					__nIssCaMR += aImposE[nI,5]
				OtherWise
					If aImposE[nI,9] == '1'
						// aAdd(__aOutImp, nI)
						__nImpMR	+= aImposE[nI,5]
						__lImpMR	:= .T.
						__lImpEmis	:= .T.
					EndIf			
			EndCase
		Next nI
	EndIf

	If SE1->E1_SALDO <> SE1->E1_VALOR
		If Len(aBaixaSE5) == 0
			If Empty(SE1->E1_TIPOLIQ)
				//Procura pelas baixas deste titulo
				Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, ;
					@nTotAdto, /*@lBaixaAbat*/, SE1->E1_CLIENTE, SE1->E1_LOJA) //, /*@nVlrBaixa*/,, @lBxCec, @lBxLiq, @lSigaLoja, @lTipBxCP )

				For nX := 1 To Len(aBaixaSE5)
					nVlParcl += aBaixaSE5[nX][8]				
					If lPccBxCR .And. ( lRaRtImp .Or. ( lMRVrTimp  .And. lRaRtImpMR ) ) //somar impostos PCC
						nVlParcl += aBaixaSE5[nX][18] + aBaixaSE5[nX][19] + aBaixaSE5[nX][20] + aBaixaSE5[nX][30] + aBaixaSE5[nX][32] + aBaixaSE5[nX][33]
					EndIf
					nIss += aBaixaSE5[nX][32]
					nInss += aBaixaSE5[nX][33]
				Next
				nVlParcl := nTotAdto
			Else
				nVlParcl := SE1->E1_VALOR - SE1->E1_SALDO
			EndIf
		EndIf
			
		__nBaseMR	:= SE1->E1_VALOR - nVlParcl
		nBaseMR 	:= Iif( nVlParcl > 0, __nBaseMR, nBaseMR )
	EndIf

	__aImpos := FINCalImp( "2", cNatMR, cCliMR, cLojaMR, cFilMR, nBaseMR, dDataMR, .T., {}, cTipoTitMR, cChaveAux,,,,, .T.)
	For nZ := 1 To Len( __aImpos )
		Do Case
			Case __aImpos[nZ,8] == "PIS"
				__nPisCaMR += __aImpos[nZ,5]
			Case __aImpos[nZ,8] == "COF"
				__nCofCaMR += __aImpos[nZ,5]
			Case __aImpos[nZ,8] == "CSL"
				__nCslCaMR += __aImpos[nZ,5]
			Case __aImpos[nZ,8] == "IRF"
				__nIrfCaMR += __aImpos[nZ,5]
			Case __aImpos[nZ,8] == "ISS"
				__nIssCaMR += __aImpos[nZ,5]
			OtherWise
				aAdd(__aOutImp, nZ)
				__nImpMR	+= __aImpos[nZ,5]
				__lImpMR	:= .T.
		EndCase
	Next nZ
	
	If __lPccMR
		nPis 	:= __nPisCaMR 
		nCofins := __nCofCaMR
		nCsll 	:= __nCslCaMR
	EndIf
	
	If __lIrfMR
		nIrrf := __nIrfCaMR
	EndIf
	RestArea(aArea)
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} LimpaVarMR()
	Função para limpar as variáveis estáticas utilizadas para o motor de retenções

	@author Pedro Alencar
	@since 08/01/2018
	@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function LimpaVarMR()	
	
	ClrVarMRCf() //Limpa as variáveis de configuração
	ClrVarMRCl() //Limpa as variáveis de cálculo	
	__cOldMRCf := ""
	__cOldMRCl := ""
	__lMotRet := .F.
	FwFreeArray(__aImpAnt)
	__aImpAnt	:= {}
	__oPrepCP	:= Nil
	__oQryFKQ	:= Nil
	
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ClrVarMRCf()
	Função para limpar as variáveis estáticas utilizadas para AS CONFIGURAÇÔES do motor de retenções

	@author Pedro Alencar
	@since 08/01/2018
	@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function ClrVarMRCf()
	__lPccMR 	:= .F.
	__lPccBxMR 	:= .F.
	__lRaRtPcc 	:= .F.
	__lIrfMR 	:= .F.
	__lIrfBxMR 	:= .F.
	__lRaRtIrf 	:= .F.
	__lIssMR 	:= .F.
	__lIssBxMR 	:= .F.
	__lRaRtIss 	:= .F.
	__lImpEmis	:= .F.
	__nImpEst	:= 0
	
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ClrVarMRCl()
	Função para limpar as variáveis estáticas utilizadas para OS CÁLCULOS do motor de retenções

	@author Pedro Alencar
	@since 08/01/2018
	@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function ClrVarMRCl()	
	
	__nPisCaMR 	:= 0
	__nCofCaMR 	:= 0
	__nCslCaMR 	:= 0
	__nIrfCaMR 	:= 0
	__nIssCaMR 	:= 0
	__nImpMR	:= 0
	__nBaseMR	:= 0
	
	aSize ( __aImpos, 0 )
	__aImpos := {}	
	
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PegaVarMR()
	Função para guardar os valores das variáveis estáticas utilizadas para o motor de retenções, 
	para poder restaurá-los sem precisar realizar o cáluclo do motor novamente.

	@return aRet, vetor com os dados das variáveis estáticas usadas para o motor de retenções.

	@author Pedro Alencar
	@since 26/01/2018
	@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function PegaVarMR() As Array
	Local aRet As Array
	
	aRet := {}
	If __lMotRet
		aAdd( aRet, __lPccMR )
		aAdd( aRet, __lPccBxMR )
		aAdd( aRet, __lRaRtPcc )
		aAdd( aRet, __lIrfMR )
		aAdd( aRet, __lIrfBxMR )
		aAdd( aRet, __lRaRtIrf )
		aAdd( aRet, __lIssMR )
		aAdd( aRet, __lIssBxMR )
		aAdd( aRet, __lRaRtIss )
		aAdd( aRet, __nPisCaMR )
		aAdd( aRet, __nCofCaMR )
		aAdd( aRet, __nCslCaMR )
		aAdd( aRet, __nIrfCaMR )
		aAdd( aRet, __nIssCaMR )
		aAdd( aRet, aClone( __aImpos ) )
		aAdd( aRet, __cOldMRCf )
		aAdd( aRet, __cOldMRCl )
	EndIf
Return aRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RestVarMR()
	Função para restaurar os valores das variáveis estáticas utilizadas para o motor de retenções.

	@param aVarMR, vetor com a estrutura retornada pela função PegaVarMR.

	@author Pedro Alencar
	@since 26/01/2018
	@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function RestVarMR( aVarMR As Array )
	Default aVarMR := {}
	
	If __lMotRet .And. Len( aVarMR ) >= 17
		__lPccMR 	:= aVarMR[1]
		__lPccBxMR 	:= aVarMR[2]
		__lRaRtPcc 	:= aVarMR[3]
		__lIrfMR 	:= aVarMR[4]
		__lIrfBxMR 	:= aVarMR[5]
		__lRaRtIrf 	:= aVarMR[6]
		__lIssMR 	:= aVarMR[7]
		__lIssBxMR 	:= aVarMR[8]
		__lRaRtIss 	:= aVarMR[9]
		__nPisCaMR 	:= aVarMR[10]
		__nCofCaMR 	:= aVarMR[11]
		__nCslCaMR 	:= aVarMR[12]
		__nIrfCaMR 	:= aVarMR[13]
		__nIssCaMR 	:= aVarMR[14]
		__aImpos 	:= aClone( aVarMR[15] )
		__cOldMRCf 	:= aVarMR[16]
		__cOldMRCl 	:= aVarMR[17]
		
		If __lPccMR .And. ( __nCofCaMR > 0 .Or. !lCredito )
			nPis 	:= __nPisCaMR 
			nCofins := __nCofCaMR
			nCsll 	:= __nCslCaMR
		EndIf
		
		If __lIrfMR
			nIrrf := __nIrfCaMR
		EndIf
	EndIf	
	
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F330GrvFKs()
	Função para gravar a FK3 e FK4 pelo motor de retenções.

	@param nRecnoSE1, Registro posicionado para a geração dos impostos
	@param aImposMR, Contem as informações de impostos do motor a serem gerados
	@return lRet, Indica se a gravação ocorreu sem erros

	@author Rodrigo Oliveira
	@since 24/04/2018
	@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Function F330GrvFKs( nRecnoSE1 As Numeric, aImposMR As Array ) As Logical
	Local aAreaFKs 	As Array
	Local oSubFK3 	As Object
	Local oSubFK4 	As Object
	Local cCamposE5 As Char
	Local lRet 		As Logical
	Local nX 		As Numeric
	Local oModelMov As Object
	Local cIDFK1 	As Char
	
	Default nRecnoSE1 	:= 0
	Default aImposMR 	:= {}

	aAreaFKs 	:= {}
	oSubFK3 	:= Nil
	oSubFK4 	:= Nil
	cCamposE5 	:= ""
	lRet 		:= .T.
	nX 			:= 0
	oModelMov 	:= Nil
	cIDFK1 		:= ""
	
	If nRecnoSE1 > 0	
		//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
		If AllTrim( SE5->E5_TABORI ) == "FK1"
			aAreaFKs := GetArea()
			FK1->( dbSetOrder( 1 ) ) //FK1_FILIAL+FK1_IDFK1
			If FK1->( MsSeek( FWxFilial("FK1") + SE5->E5_IDORIG ) )
				SE1->( dbGoto( nRecnoSE1 ) )
				
				oModelMov := FWLoadModel("FINM010")
				oModelMov:SetOperation( 4 ) //Alteração
				oModelMov:Activate()
				oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5				

	   			oSubFK3 := oModelMov:GetModel("FK3DETAIL")
	   			oSubFK4 := oModelMov:GetModel("FK4DETAIL")
	   			      
	   			cIDFK1 := FWUUIDV4()
	   			
	   			//Estrutura do aImposMR
				//aImposMR[1] = codigo FKM - motor de retenção
				//aImposMR[2] = base calculado
				//aImposMR[3] = imposto calculado
				//aImposMR[4] = base retencao
				//aImposMR[5] = imposto retido
				//aImposMR[6] = cIdFK4															
				//aImposMR[8] = codigo imposto
				//aImposMR[10] = natureza
				
				cCamposE5 := "{"
				//Grava FK3 e/ou FK4
				For nX := 1 to Len( aImposMR )
					
					//Verifica se houve imposto calculado
					If aImposMR[nX][3] > 0
						
						//Se já houver uma linha de FK3 preenchida, adiciona uma nova
						If !oSubFK3:IsEmpty()
							oSubFK3:AddLine()
							//Garante que a grid estará posicionada na linha adicionada 
							oSubFK3:GoLine( oSubFK3:Length() )	
						EndIf
			
						//Grava o imposto calculado
						oSubFK3:SetValue( "FK3_IDFK3" , GetSx8Num( "FK3", "FK3_IDFK3" ) )
						oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
						oSubFK3:SetValue( "FK3_ORIGEM", FunName() )
						oSubFK3:SetValue( "FK3_IMPOS" , aImposMR[nX][8] )
						oSubFK3:SetValue( "FK3_RECPAG", "R" )
						oSubFK3:SetValue( "FK3_MOEDA" , "01" )
						oSubFK3:SetValue( "FK3_VALOR" , aImposMR[nX][3] )
						oSubFK3:LoadValue( "FK3_NATURE",  aImposMR[nX][10] )
						oSubFK3:SetValue( "FK3_FILORI", SE1->E1_FILORIG  )
						oSubFK3:SetValue( "FK3_BASIMP", aImposMR[nX][2] )
						oSubFK3:SetValue( "FK3_IDORIG", cIdFK1 )
						oSubFK3:SetValue( "FK3_TABORI", "FK1" ) 						   
						oSubFK3:SetValue( "FK3_CODFKM", aImposMR[nX,1] )
						oSubFK3:SetValue( "FK3_CLIFOR", SA1->A1_COD )
						oSubFK3:SetValue( "FK3_LOJA"  , SA1->A1_LOJA )
						oSubFK3:SetValue( "FK3_CGC"   , SA1->A1_CGC )
						oSubFK3:SetValue( "FK3_RAICGC", Substr( SA1->A1_CGC, 1, 8 ) )
						
						//Grava imposto retido
						cIdFK4 := ""
						If aImposMR[nX][5] > 0 //Verifica se houve retenção
							cIdFK4 			:= GetSx8Num( "FK4", "FK4_IDFK4" )
							aImposMR[nX,6] 	:= cIdFK4
							oSubFK3:SetValue( "FK3_IDRET" , cIdFK4 )
							
							//Se já houver uma linha de FK4 preenchida, adiciona uma nova
							If !oSubFK4:IsEmpty()
								oSubFK4:AddLine()
								//Garante que a grid estará posicionada na linha adicionada
								oSubFK4:GoLine( oSubFK4:Length() )
							EndIf
		
							oSubFK4:SetValue( "FK4_IDFK4" , aImposMR[nx,6] )
							oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
							oSubFK4:SetValue( "FK4_ORIGEM", FunName() )
							oSubFK4:SetValue( "FK4_IMPOS" , aImposMR[nx,8] )
							oSubFK4:SetValue( "FK4_RECPAG", "R" )
							oSubFK4:SetValue( "FK4_MOEDA" , "01" )
							oSubFK4:SetValue( "FK4_VALOR" , aImposMR[nX,5] )
							oSubFK4:LoadValue( "FK4_NATURE", aImposMR[nX][10] )
							oSubFK4:SetValue( "FK4_FILORI", SE1->E1_FILORIG )
							oSubFK4:SetValue( "FK4_BASIMP", aImposMR[nX][4] )
							oSubFK4:SetValue( "FK4_CODFKM", aImposMR[nX,1] )
							oSubFK4:SetValue( "FK4_CLIFOR", SA1->A1_COD )
							oSubFK4:SetValue( "FK4_LOJA"  , SA1->A1_LOJA )
							oSubFK4:SetValue( "FK4_CGC"   , SA1->A1_CGC )
							oSubFK4:SetValue( "FK4_RAICGC", Substr( SA1->A1_CGC, 1, 8 ) )
						
							If aImposMR[nx,8] == "PIS"
								cCamposE5 += "{'E5_VRETPIS', " + cValtoChar(nPis) + "}"
							ElseIf aImposMR[nx,8] == "COF"
								cCamposE5 += ",{'E5_VRETCOF', " + cValtoChar(nCofins) + "}"
							ElseIf aImposMR[nx,8] == "CSL"
								cCamposE5 += ",{'E5_VRETCSL', " + cValtoChar(nCsll) + "}"
							ElseIf aImposMR[nx,8] == "IRF"
								cCamposE5 += ",{'E5_VRETIRF', " + cValtoChar(nIrrf) + "}"
							EndIf
						EndIf
					EndIf
					
				Next nX
				
				//Se houver alguma informação informada no cCamposE5, então passa os dados para o model
				If cCamposE5 <> "{"
					cCamposE5 += "}"
					oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1
				EndIf
				
				If oModelMov:VldData()
					oModelMov:CommitData()
				Else
					lRet := .F.
					cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[6])
					Help( ,, "M010VALID",, cLog, 1, 0 )
	 			Endif
				oModelMov:DeActivate()
				oModelMov:Destroy()
				oModelMov := Nil
			Else //Se não achou o registro na FK1
				lRet := .F.
			Endif
			
			RestArea(aAreaFKs)
		Else //Se a origem do registro posicionado não for FK1
			lRet := .F.
		Endif
	EndIf

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA330SIT
	Função para verificação do campo E1_SITUACA do titulo

	@author    Francisco Oliveira
	@version   12
	@since     02/02/2018

	@return cSituac - retorna a situação do titulo 
/*/
//-----------------------------------------------------------------------------------------------------

Static Function FA330SIT(aTitulos,nRecE1)
	Local nX
	Local aAreaE1		:= SE1->(GetArea())
	Local cLstCart		:= FN022LSTCB(1,'0007')	//Lista das situacoes de cobranca (Carteira)
	Local lRet			:= .T.
	
	Default nRecE1	:= 0
	
	If nRecE1 == 0
		For nX := 1  To Len(aTitulos)
			If MV_PAR02 == 2
				SE1->(DbGoTo(aTitulos[nX][23]))
			Else
				SE1->(DbGoTo(aTitulos[nX][20]))
			Endif
			
			If MV_PAR05 == 2 .And. !(SE1->E1_SITUACA $ cLstCart) .And. aTitulos[nX][8]
				Help(" ",1,"F330CARTE")
				lRet := .F.
				Exit
			Endif
		Next nX
	Else
		SE1->(DbGoTo(nRecE1))
		If MV_PAR05 == 2 .And. !(SE1->E1_SITUACA $ cLstCart)
			Help(" ",1,"F330CARTE")
			lRet := .F.
		Endif
	Endif
	
	RestArea(aAreaE1)
Return lRet

//--------------------------------------------------------------------------
/*/{Protheus.doc}FA330Corr
	Calcula a correção monetária

	@author Sivaldo Oliveira
	@since  22/11/2018
	@version 12
/*/
//--------------------------------------------------------------------------
Static Function FA330Corr(nBasCorr As Numeric, nVlrNF As Numeric, cTbl As Character, nTaxaMov As Numeric)
	Local nVlrCm    As Numeric 
	Local nVlrAtual As Numeric
	Local nVlrEmiss As Numeric
	Local dDtVaria  As Date
	Local dDtMov	As Date
	Local lGerCm    As Logical
	
	Default nBasCorr := 0
	Default nVlrNF   := 0
	Default cTbl     := "SE1"
	Default nTaxaMov := 0
	
	//Inicializa variáveis
	nVlrCm := 0
	dDtMov := dDataBase
	lGerCm := .T.
	
	If cPaisLoc == "BRA"
		If (cTbl)->E1_TXMOEDA > 0 .And. __lTxConP .And. nVlrNF > 0	// Se for Tx contratada x Tx contratada 
			If __lCmTxCon 							//verifica se está parametrizado para gerar VM.
				nVlrAtual := Round(xMoeda(nBasCorr, (cTbl)->E1_MOEDA, 1, dDtMov, __nCasDec, IIF((cTbl)->E1_TXMDCOR > 0, (cTbl)->E1_TXMDCOR , (cTbl)->E1_TXMOEDA)),__nCasDec)
				nVlrCm    := Round((nVlrNF - nVlrAtual), 2)
				lGerCm := .F.
			Else
				lGerCm := .F.
			EndIf
		ElseIf __lCmTxCon .And. (cTbl)->E1_TXMOEDA > 0
			lGerCm := .T.
		Else 
			lGerCm := ((cTbl)->E1_TXMOEDA == 0 .Or. (__nTxContr != 0 .And. __nTxContr != (cTbl)->E1_TXMOEDA))  
		EndIf  
	EndIf
	
	If __lCalcCM .And. lGerCm .And. (cTbl)->E1_MOEDA > 1 .And. !Empty(nBasCorr) 
		nVlrAtual := 0
		nVlrEmiss := 0
		dDtVaria  := If(Empty((cTbl)->E1_DTVARIA), (cTbl)->E1_EMISSAO, (cTbl)->E1_DTVARIA)
		
		//A variação da NF ocorre em relação a RA
		If __lCmTxCon .And. nVlrNF != 0
			nVlrAtual := xMoeda(nBasCorr, (cTbl)->E1_MOEDA, 1, dDtMov, __nCasDec, nTaxaMov)
			nVlrCm    := Round((nVlrAtual - nVlrNF), 2)
		Else //Variação ocorre em realçao a moeda do dia(SM2)
			If (cTbl)->E1_TIPO $ MVRECANT
				dDtMov := F330MovRA(Nil, cTbl, .T.)[2]
			EndIf
			
			If Empty((cTbl)->E1_DTVARIA) .And. STR(nBasCorr, 17, 2) == STR((cTbl)->E1_VALOR, 17, 2)
				nVlrEmiss := (cTbl)->E1_VLCRUZ
			Else
				If !Empty((cTbl)->E1_TXMDCOR)
					nVlrEmiss := xMoeda(nBasCorr, (cTbl)->E1_MOEDA, 1, dDtVaria, __nCasDec, (cTbl)->E1_TXMDCOR)
				Else
					If (cTbl)->E1_TIPO $ MVRECANT
						dDtVaria := dDtMov
					EndIf
					nVlrEmiss := xMoeda(nBasCorr, (cTbl)->E1_MOEDA, 1, dDtVaria, __nCasDec, (cTbl)->E1_TXMOEDA)
				EndIf
			EndIf
			
			nVlrAtual := xMoeda(nBasCorr, (cTbl)->E1_MOEDA, 1, dDtMov, __nCasDec, nTaxaMov)
			nVlrCm    := Round((nVlrAtual - nVlrEmiss), 2)
		EndIf
	EndIf
Return nVlrCm

//------------------------------
/*/{Protheus.doc} F330MoedCm
	Atualiza a moeda do registro de correção monetária
	@author Sivaldo Oliveira
	@since 22/11/2018
	@version P12
/*/
//------------------------------
Static Function F330MoedCm()
	Local aArea As Array
	
	//Inicializa variáveis.
	aArea := SE5->(GetArea())
	SE5->(DbSetOrder(2))		
	
	If SE5->(MsSeek(xFilial("SE5") + "CM" + SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)+DTOS(dDataBase)+SE1->(E1_CLIENTE+E1_LOJA)+FK1->FK1_SEQ))
		If SE5->E5_MOEDA  != "01"
			RecLock("SE5", .F.)
			SE5->E5_MOEDA   :=  "01"
			If cPaisLoc != "BRA"  //Mantenho a taxa utilizada na VM
				SE5->E5_TXMOEDA := 0
			EndIf
			SE5->(MsUnlock())
		EndIf
	EndIf
	
	RestArea(aArea)
Return Nil

//------------------------------
/*/{Protheus.doc}FA330Valor
	Define os valores a serem enviado para conversão da moeda

	@author Sivaldo Oliveira
	@since  23/11/2018
	@version 12
/*/
//------------------------------
Static Function FA330Valor(nVlr, nMoedP, nMoedD, dDtMov, nTaxaMov, lRound)
	Default nVlr     := 0
	Default nMoedP   := 0
	Default nMoedD   := 0
	Default dDtMov   := dDataBase
	Default nTaxaMov := 0
	Default lRound   := .F.
	
	If nMoedP != nMoedD .And. nVlr != 0 .And. nMoedP != 0 .And. nMoedD != 0
		If (nMoedD > 1 .And. nMoedP > 1) .And. (nMoedD <> nMoedP)
			nVlr := xMoeda(nVlr, nMoedP, nMoedD, dDtMov, __nCasDec,  nTaxaMov, __nTxMoedP)
		ElseIf (nMoedD == 1 .Or. nMoedP != 1)
			nVlr := xMoeda(nVlr, nMoedP, nMoedD, dDtMov, __nCasDec, nTaxaMov)
		Else
			nVlr := xMoeda(nVlr, nMoedP, nMoedD, dDtMov, __nCasDec, Nil, nTaxaMov)
		EndIf
	EndIf
	
	If lRound
		nVlr := Round(NoRound(nVlr, __nCasDec), 2)	
	EndIf
Return nVlr

//------------------------------
/*/{Protheus.doc}F330Static
	Inicializa as variáveis estáticas.

	@author Sivaldo Oliveira
	@since  23/11/2018
	@version 12
/*/
//------------------------------
Static Function F330Static() 	
	
	__nTxMoedP 	:= 0 //Necessário limpar, pois a ultima taxa pode ser de um título de outra moeda
	__lTxConP 	:= .F.
	__lDizPer	:= .F.
	If SE1->E1_MOEDA != 1  //Tratamento para taxa contratada do título de partida
		If SE1->E1_TXMOEDA > 0  
			If SE1->E1_TXMDCOR > 0
				__nTxMoedP := SE1->E1_TXMDCOR
				__lTxConP	:= .T.
			Else
				__nTxMoedP := SE1->E1_TXMOEDA
				__lTxConP	:= .T.
			EndIf
		EndIf
	EndIf 
	
	IF mv_par14 == 2
		aTxMoedas := aClone(__aTxMoed0)
	Else
		If SE1->E1_MOEDA != 1 .And. Empty(__nTxMoedP) .And. ((lCredito .And. !__lRaTxMov) .Or. !lCredito)
			__nTxMoedP := aTxMoedas[nMoeda, 2]
		EndIf
	EndIf
	
	__nTxMoedD 	:= 0
	__nTxContr 	:= 0
	__lCmTxCon 	:= .T.
	__lCalcCM  	:= .T.
	__nPosTit  	:= 0
	__lNoTxMov 	:= .F.
	__oMovRA    := Nil
	__oMovCnb	:= Nil
	__lMVGlosa  := .F.
	__QryFk1:= Nil
	__QryFk7:= Nil 

	
	If __oHshTMrk <> Nil
		__oHshTMrk:Clean()
		__oHshTMrk	:= Nil
	EndIf
	If __aHshTMrk <> Nil
		aSize(__aHshTMrk, 0)
		__aHshTMrk	:= Nil
	EndIf
	
	If __oHNatPCC <> Nil
		__oHNatPCC:Clean()
		__oHNatPCC := Nil
	EndIf
	__oHNatPCC := tHashMap():New()
	FwFreeArray(__aNatPCC)
	__aNatPCC	:= {}

	If cPaisLoc == "BRA"
		__lCmTxCon	:= SuperGetMv("MV_CMTXCON", .F., .F.) //Gera VM para TXCANTRATADA
		__lCalcCM	:= SuperGetMv("MV_CALCCM", .F., "N") == "S"
		__lRaTxMov	:= SuperGetMv("MV_RATXMOV", .F., .T.)
		__nQtdTitu  := 0
		__nFINPIX9  := SuperGetMv("MV_FINPIX9", .F., 1)
		
		If __lTPIConf == Nil
			__lTPIConf := FindFunction("APIPIXOn") .And. APIPIXOn()
		EndIf
		
		If __lAltPix == Nil
			__lAltPix := FindFunction("F986AltPix")
		EndIf
		
		__aRecF71  := {}
		__lMVGlosa := SuperGetMv("MV_GLOSA", .F., .F.)
	EndIf

	__nCasDec  	:= TamSx3("E1_TXMOEDA")[2]
	__aTitCalc	:= {}
	__cIdFk4IR	:= ""
	__lCmpM460  := IsInCallStack('MaIntBxCR') 
	__lGetParA  := FindFunction("GetParAuto")
	__nSldConv	:= 0
	__nTotCtb	:= 0
	If lCredito .And. ( !lRaRtImp .And. !__lRaRtIrf .And. !__lRaRtPcc )
		__nImpMR	:= 0
	EndIf
	__cToler	:= ""
	__lExcImpo	:= IIf(__lExcImpo == Nil, FindFunction("ExcluiImpo"), __lExcImpo)	
	__lCNABImp	:= IIf(__lCNABImp == Nil, SuperGetMV("MV_CNABIMP", .F., .F.), __lCNABImp)
	__TpGerPix	:= .T.
	__lNExbMsg	:= .F.
	__nValVa	:= 0
	__nMoedSA6	:= 0
	__lNTitFIE	:= .F.	
	__nRecPart  := 0
	__nMoePart  := 0
Return Nil

//--------------------------------------------------------------------------
/*/{Protheus.doc}F330MovRA
	Verifica se o RA possui movimento bancário

	@author Rodrigo Oliveira
	@since  17/01/2019
	@version 12
/*/
//--------------------------------------------------------------------------
Function F330MovRA(aMovRA As Array, cTbl As Character, lVerMov As Logical) As Array
	Local cQry      As Character
	Local cTblTmp   As Character
	Local aArea     As Array
	Local cCampoChq As Character
	Local dDtMov	As Date 

	Default aMovRA  := {.F., dDataBase, ""}
	Default cTbl    := "SE2"
	Default lVerMov := .T.

	//Inicializa variáveis
	cQry 	  := ""
	cTblTmp   := ""
	cCampoChq := Padr("", TamSX3("E5_NUMCHEQ")[1])
	aArea     := GetArea()

	If lVerMov
		If __oMovRA == Nil
			cQry := "SELECT E5_DATA, E5_TIPODOC FROM " + RetSqlName("SE5") + " "
			cQry += "WHERE E5_FILIAL = ? AND E5_PREFIXO = ? AND "
			cQry += "E5_NUMERO = ? AND E5_PARCELA = ? AND "
			cQry += "E5_TIPO = ? AND E5_CLIFOR = ? AND E5_LOJA = ? AND "
			cQry += "((E5_TIPODOC = 'RA' ) OR (E5_TIPODOC = 'BA' AND E5_NUMCHEQ <> '" + cCampoChq + "' ) OR "
			cQry += "(E5_TIPODOC = 'CH' AND E5_NUMCHEQ <> '" + cCampoChq + "')) AND "
			cQry += "E5_RECPAG = 'R' AND E5_SITUACA = ' ' AND D_E_L_E_T_ = ' ' "
			cQry := ChangeQuery(cQry)
			__oMovRA := FWPreparedStatement():New(cQry)
		EndIf

		__oMovRA:SetString(1, xFilial("SE5", (cTbl)->E1_FILORIG))
		__oMovRA:SetString(2, (cTbl)->E1_PREFIXO)
		__oMovRA:SetString(3, (cTbl)->E1_NUM)
		__oMovRA:SetString(4, (cTbl)->E1_PARCELA)
		__oMovRA:SetString(5, (cTbl)->E1_TIPO)
		__oMovRA:SetString(6, (cTbl)->E1_CLIENTE)
		__oMovRA:SetString(7, (cTbl)->E1_LOJA)

		cQry := __oMovRA:GetFixQuery()
		cTblTmp := MpSysOpenQuery(cQry)
	Else
		If __oMovCnb == Nil
			cQry := "SELECT E5_DATA, E5_TIPODOC FROM " + RetSqlName("SE5") + " "
			cQry += "WHERE E5_FILIAL = ? AND E5_PREFIXO = ? AND "
			cQry += "E5_NUMERO = ? AND E5_PARCELA = ? AND "
			cQry += "E5_TIPO = ? AND E5_CLIFOR = ? AND E5_LOJA = ? AND "
			cQry += "E5_RECPAG = 'R' AND E5_SITUACA = ' ' AND D_E_L_E_T_ = ' ' "
			cQry := ChangeQuery(cQry)
			__oMovCnb := FWPreparedStatement():New(cQry)
		EndIf

		__oMovCnb:SetString(1, xFilial("SE5", (cTbl)->E1_FILORIG))
		__oMovCnb:SetString(2, (cTbl)->E1_PREFIXO)
		__oMovCnb:SetString(3, (cTbl)->E1_NUM)
		__oMovCnb:SetString(4, (cTbl)->E1_PARCELA)
		__oMovCnb:SetString(5, (cTbl)->E1_TIPO)
		__oMovCnb:SetString(6, (cTbl)->E1_CLIENTE)
		__oMovCnb:SetString(7, (cTbl)->E1_LOJA)

		cQry := __oMovCnb:GetFixQuery()
		cTblTmp := MpSysOpenQuery(cQry)
	EndIf

	(cTblTmp)->(DbGotop())

	If (cTblTmp)->(!Eof())
		dDtMov := If(Empty((cTblTmp)->E5_DATA), dDataBase, STOD((cTblTmp)->E5_DATA))
		aMovRA := {.T., dDtMov, (cTblTmp)->E5_TIPODOC}
	EndIf

	(cTblTmp)->(DbCloseArea())
	RestArea(aArea)
Return aMovRA

//--------------------------------------------------------------------------
/*/{Protheus.doc}VerSE5
	Posiciona na baixa relativa ao título selecionado

	@author Rodrigo Oliveira
	@since  25/03/2019
	@version 12
/*/
//--------------------------------------------------------------------------

Static Function VerSE5(cFil As Character, cTipoDoc As Character, cPrefixo As Character, cNum As Character, cParcela As Character, cTipoTit As Character, cCliente As Character, cLoja As Character, cFilOrig As Character)
	Local cAliasQry	:= GetNextAlias()

	BeginSql Alias cAliasQry

		Select R_E_C_N_O_ RECNO
		From %Table:SE5%	
		Where E5_FILIAL = %Exp:cFil%
		And E5_TIPODOC 	= %Exp:cTipoDoc%
		And E5_PREFIXO 	= %Exp:cPrefixo% 
		And E5_NUMERO  	= %Exp:cNum%
		And E5_PARCELA 	= %Exp:cParcela%
		And E5_TIPO 	= %Exp:cTipoTit%
		And E5_FILORIG	= %Exp:cFilOrig%
		And E5_CLIFOR	= %Exp:cCliente%
		And E5_LOJA 	= %Exp:cLoja%
		And %NotDel%

	EndSql

	SE5->(DbGoTo((cAliasQry)->(RECNO)))

	(cAliasQry)->(DbCloseArea())

	dbSelectArea("SE5")
Return Nil

//--------------------------------------------------------------------------
/*/{Protheus.doc}VerFK1
	Verifica se o IDCOMP é referente ao mesmo processo de compensação

	@author Rodrigo Oliveira
	@since  25/03/2019
	@version 12
/*/
//--------------------------------------------------------------------------

Static Function VerFK1(cSE5IdOri As Character, cIdDoc As Character) As Logical
	Local lRet 		:= .T.
	Local aAreaSE5	:= SE5->(GetArea())
	Local cAliasQry	:= GetNextAlias()
	Local aAliasFK1 := FK1->(GetArea())

	BeginSql Alias cAliasQry
	
		Select FK1_IDDOC, FK1_IDCOMP
		From %Table:FK1%	
		Where FK1_IDFK1 = %Exp:cSE5IdOri%
			And %NotDel%
	EndSql

	If !Empty((cAliasQry)->FK1_IDCOMP) .And. (cAliasQry)->FK1_IDCOMP != __cFk1IdOri
		lRet := .F.
	EndIf

	cIdDoc := (cAliasQry)->FK1_IDDOC

	RestArea(aAliasFK1)
	(cAliasQry)->(DbCloseArea())
	RestArea(aAreaSE5)
Return lRet

//--------------------------------------------------------------------------
/*/{Protheus.doc}TitNMarc
	Verificar se determinado título da rotina automática deve ser marcado ou
	não.

	@author Rodrigo Oliveira
	@since  23/05/2019
	@version 12
/*/
//--------------------------------------------------------------------------
Static Function TitNMarca(cAliasSE1 As Character) As Logical

	Local lTitNMarc As Logical
	Local nI		As Numeric
	Local nPos		As Numeric
	// Local lFlag		As Logical
	
	lTitNMarc	:= .F.
	nI			:= 0
	nPos		:= 0
	
	If ValType(aRetAuto) == 'A'
		If __aHshTMrk == Nil // __oHshTMrk == Nil
			__aHshTMrk := {}
			For nI := 1 To Len(aRetAuto[2])
				aAdd(__aHshTMrk, aRetAuto[2][nI][1] + aRetAuto[2][nI][2] + aRetAuto[2][nI][3] + aRetAuto[2][nI][4])
			Next nI
			If ( nPos	:= aScan(__aHshTMrk, (cAliasSE1)->E1_PREFIXO + (cAliasSE1)->E1_NUM + (cAliasSE1)->E1_PARCELA + (cAliasSE1)->E1_TIPO) ) == 0
				lTitNMarc := .T.
			EndIf
		Else
			If ( nPos	:= aScan(__aHshTMrk, (cAliasSE1)->E1_PREFIXO + (cAliasSE1)->E1_NUM + (cAliasSE1)->E1_PARCELA + (cAliasSE1)->E1_TIPO) ) == 0
				lTitNMarc := .T.
			EndIf
		EndIf
	EndIf

Return lTitNMarc

//-------------------------------------------------------------------
/*/{Protheus.doc}FBaseRPCC
	Consiste valor base de calculo do PCC.
	@author Rodrigo Oliveira
	@since  28/05/2019
	@version 12
/*/
//-------------------------------------------------------------------
Static Function FBaseRPCC(nValorRec As Numeric, lCalcPCC As Logical) As Numeric
	Local nValBase	As Numeric
	Local nBaseRet	As Numeric
	Local aBase 	As Array
	Local nX 		As Numeric
	Local cChaveAux As Character
	Local nBase	 	As Numeric
	Local nParc		As Numeric
	
	nValBase	:= 0
	nBaseRet	:= 0
	aBase 		:= {}
	nX 			:= 0
	cChaveAux 	:= ""
	nBase	 	:= If(SE1->E1_BASEPIS > 0, SE1->E1_BASEPIS, If(SE1->E1_BASECOF > 0, SE1->E1_BASECOF, If(SE1->E1_BASECSL > 0, SE1->E1_BASECSL, 0)))
	nParc		:= 0
	
	DEFAULT nValorRec	:= nBase
	DEFAULT lCalcPcc	:= .T.
	
	If __lMotRet .And. __lPccMR .And. nBase == 0
		cChaveAux := FWxFilial( "SE1", SE1->E1_FILORIG ) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
	
		aBase := FinImpFis(cChaveAux,SE1->E1_FILORIG,"SE1")
		For nX := 1 to Len(aBase)
			nBase := aBase[nX][2]
		Next
	Endif
	
	nParc 		:= IF(Type("nParciais") != "N", 0, nParciais)// real
	IF nValorRec >= nBase
		nValorRec := nBase
	EndIf
	nValBase 	:= nBase

	If !__lBq10925 .And. lCredito
		nParc := SE1->E1_VALOR - SE1->E1_SALDO
	EndIf

	If SE1->E1_MOEDA > 1
		nParc	:= xMoeda(nParc,nMoeda,SE1->E1_MOEDA,dDatabase,3,,nTxMoeda)
	EndIf
	
	If nParc < nValBase // Se o valor das baixas parciais nao atingiram o valor da base.
		nValBase := nValBase - nParc
		If nValorRec < nValBase
			nValBase := nValorRec
		EndIf
	Else // Se ja alcançou a base de calculo.
		nBaseRet	:= 0
		lCalcPcc	:= .F.
	EndIf
	
	nBaseRet := nValBase

Return nBaseRet

//-------------------------------------------------------------------
/*/{Protheus.doc}ValorMR
	Recupera o valor de retenção do configurador de tributos do título origem
	@author Renato Ito
	@since  24/01/2020
	@version 12
/*/
//-------------------------------------------------------------------

Static Function ValorMR()

	Local nZ		As Numeric
	Local nTotal	As Numeric
	nTotal := 0
	For nZ := 1 To Len( __aImpos )
		If !(AllTrim(__aImpos[nZ,8]) $ "PIS|COF|CSL|IRF|ISS")
			nTotal	+= __aImpos[nZ,5]
		EndIf
	Next nZ

Return nTotal

//-------------------------------------------------------------------
/*/{Protheus.doc}FBaseImp
	Consiste o valor base para os impostos
	@author Renato Ito
	@since  24/01/2020
	@version 12
/*/
//-------------------------------------------------------------------
Static Function FBaseImp(nVlBase As Numeric) As Numeric

	Local nParcVl	As Numeric
	Local nVlBaixa	As Numeric
	Local nBase		As Numeric
	Local nX		As Numeric
	Local cChaveAux	As Character
	Local aBase		As Array
	Local nValMR	As Numeric
	Local nSaldoCon As Numeric
	Local nVlBseCon As Numeric
	Local lBxTot	As Logical
	
	nValMR		:= 0
	nParcVl		:= 0 //baixas por adiantamento
	nVlBaixa    := 0 //baixas parciais
	nBase		:= 0
	nX			:= 0
	nSaldoCon   := SE1->E1_SALDO
	nVlBseCon   := nVlBase
	lBxTot		:= .T.

	If __lMotRet
		cChaveAux := FWxFilial( "SE1", SE1->E1_FILORIG ) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
		aBase := FINCalImp( "2", SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, SE1->E1_VALOR, dDataBase, .T., {}, SE1->E1_TIPO, cChaveAux)

		For nX := 1 to Len(aBase)
			nValMR += aBase[nX][3]
		Next
	EndIf
	
	If SE1->E1_VALOR <> SE1->E1_SALDO
		Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, @nParcVl, /*@lBaixaAbat*/, SE1->E1_CLIENTE, SE1->E1_LOJA, @nVlBaixa)
	EndIf

	If nMoeda > 1
		nSaldoCon :=  Round(NoRound(xMoeda(SE1->E1_SALDO, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP),3),2)
		nVlBseCon :=  Round(NoRound(xMoeda(nVlBase, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP),3),2)
	EndIf

	lBxTot := nSaldoCon <> nVlBseCon

	If FxIsBxTotal(nVlBase + Iif( MV_PAR08 == 1, SE1->E1_SDDECRE, 0), nParcVl + nVlBaixa , nValMR) .And. lBxTot
		nBase := SE1->E1_VALOR - ( nParcVl + nVlBaixa )
	Else
		nBase := nVlBase
	EndIf

Return nBase
//------------------------------
/*/{Protheus.doc}ProtCfgAdt
	Retorna a configuração de compartilhamento das tabelas de adiantamento

	@param 
	@return aRet, Array
				[1,1]=Empresa - Modo de compartilhamento FIE
				[1,2]=Unidade de Negócio - Modo de compartilhamento FIE 
				[1,3]=Filial - Modo de compartilhamento FIE
				[1,4]Existe Indice 4-Cliente na tabela FIE
				[1,5]Existe Indice 5-fornecedor na tabela FIE
				[2,1]=Empresa - Modo de compartilhamento FR3
				[2,2]=Unidade de Negócio - Modo de compartilhamento FR3
				[2,3]=Filial - Modo de compartilhamento FR3
				[2,4]Existe Indice 8-Cliente na tabela FR3
				[2,5]Existe Indice 9-Fornecedor na tabela FR3
	@author Vitor Pires
	@since  29/08/2019
	@version 12
	@type static function
/*/
//------------------------------
Static Function ProtCfgAdt() As Array 
	Local aRet As Array 
	aRet := {;
			{FwModeAccess('FIE',1),;
			FwModeAccess('FIE',2),;
			FwModeAccess('FIE',3),;
			FWSIXUtil():ExistIndex( 'FIE', '4' ),;
			FWSIXUtil():ExistIndex( 'FIE', '5' )},;
			{FwModeAccess('FR3',1),;
			FwModeAccess('FR3',2),;
			FwModeAccess('FR3',3),;
			FWSIXUtil():ExistIndex( 'FR3' , '8' ),;
			FWSIXUtil():ExistIndex( 'FR3' , '9' )},;
			{FwModeAccess('SE1',3),;
			FwModeAccess('SE2',3)} }
Return (aRet)

//--------------------------------------------------------------------------
/*/{Protheus.doc}FHCliPCC
	Verificar se determinado cliente do título da browse tem PCC ou não.

	@author Rodrigo Oliveira
	@since  11/01/2021
	@version 12
/*/
//--------------------------------------------------------------------------
Static Function FHCliPCC(cFil As Character, cCli As Character, ;
	cNat As Character, cLoj As Character) As Logical

	Local lCliPCC	As Logical
	Local aAreaSA1	As Array
	Local aVal		As Array
	
	Default cLoj := SE1->E1_LOJA	

	aVal := {}
	
	If SE1->E1_TIPO $ MV_CRNEG
		lCliPCC := .F.
	Else
		lCliPCC	:= HMGet(__oHNatPCC, cFil + cNat,aVal)

		If lCliPCC
			aAreaSA1	:= SA1->(GetArea())
			
			DbSelectArea("SA1")
			DbSetOrder(1)
			If SA1->(DbSeek(FwxFilial("SA1", cFil) + cCli + cLoj) )
				lCliPCC := SA1->A1_PESSOA == 'J' .And. ((SA1->A1_RECCOFI $ 'S|P') .Or. (SA1->A1_RECCSLL $ 'S|P') .Or. (SA1->A1_RECPIS $ 'S|P'))
			EndIf
			RestArea(aAreaSA1)
		EndIf
	EndIf

	If !lCliPCC
		__aTitCalc	:= {}
		nPis := nCofins := nCsll := 0
		nPisBaseC := nCofBaseC 	:= nCslBaseC :=	0 
		nPisBaseR := nCofBaseR	:= nCslBaseR := 0
		nPisCalc  := nCofCalc	:= nCslCalc	:= 0
	EndIf
Return lCliPCC

//--------------------------------------------------------------------------
/*/{Protheus.doc}FNatPCC
	Verificar se determinada natureza do título da browse tem PCC ou não.

	@author Rodrigo Oliveira
	@since  11/01/2021
	@version 12
/*/
//--------------------------------------------------------------------------
Static Function FNatPCC(cFil As Character, cNat As Character) As Logical

	Local lNatPCC	As Logical
	Local aAreaSED	As Array
	
	lNatPCC	:= .F.
	
	aAreaSED	:= SED->(GetArea())
	
	DbSelectArea("SED")
	DbSetOrder(1)
	If SED->(DbSeek(FwxFilial("SED", cFil) + cNat) )
		lNatPCC := (SED->ED_CALCPIS == 'S' .Or. SED->ED_CALCCOF == 'S' .Or. SED->ED_CALCCSL == 'S' )
	EndIf
	If lNatPCC .And. !(SE1->E1_TIPO $ MV_CRNEG) .And. !lCredito
		If ( aScan(__aNatPCC, { |x| x[1] = SE1->E1_FILORIG + SE1->E1_NATUREZ } )) == 0
			aAdd(__aNatPCC, {SE1->E1_FILORIG + SE1->E1_NATUREZ})
		EndIf
	EndIf

	RestArea(aAreaSED)

Return lNatPCC

//--------------------------------------------------------------------------
/*/{Protheus.doc}AjustBsIRF
	Função que ajusta a base real do IR retido

	@author Rodrigo Oliveira
	@since  16/03/2021
	@version 12
/*/
//--------------------------------------------------------------------------
Function AjustBsIRF(cIdFK4)
	Local cAlias 	As Character
	Local aArea 	As Array
	Local aAreaFK4 	As Array
	Local nBaseIr	As Numeric

	aArea		:= GetArea()
	aAreaFK4	:= FK4->(GetArea())
	cAlias 		:= GetNextAlias()

	BeginSql Alias cAlias
		Select Sum(FK3_BASIMP) As BASEIR
		From %Table:FK3% FK3
		Where FK3_IDRET = %Exp:cIdFK4%
			And FK3_IMPOS = 'IRF'
			And FK3.%NotDel%
	EndSql

	If !(cAlias)->(Eof())
		nBaseIr := (cAlias)->BASEIR
	EndIf

	FK4->(DbSetOrder(1))
	If FK4->(DbSeek(xFilial("FK4") + cIdFK4) ) .And. nBaseIr > 0
		RecLock("FK4")
		FK4->FK4_BASIMP := nBaseIr
		MsUnlock()
	EndIf

	(cAlias)->(DbCloseArea())
	RestArea(aAreaFK4)
	RestArea(aArea)
Return

//--------------------------------------------------------------------------
/*/{Protheus.doc}AjustBsPCC
Função que ajusta a base real do IR retido

@author Pequim
@since  22/09/2021
@version 12
/*/
//--------------------------------------------------------------------------
Function AjustBsPCC(aImpostos As Array)
	Local cDelete    As Character
	Local cFilialFK3 As Character
	Local cFilialFK4 As Character
	Local cQuery	 As Character
	Local nX		 As Numeric
	Local nQtdLinha  As Numeric	
	Local aAreaAtual As Array
	Local aAreaFK4 	 As Array	
	
	//Parâmetros de entrada.
	Default aImpostos := {}
	
	//Inicializa variáveis
	cDelete   := " "
	nX        := 0	
	nQtdLinha := Len(aImpostos)	
	
	If nQtdLinha > 0
		aAreaAtual := FWGetArea()
		aAreaFK4   := FK4->(FWGetArea())		
		cFilialFK3 := FWxFilial("FK3")
		cFilialFK4 := FWxFilial("FK4") 
		
		If __lCachQry == Nil
			__lCachQry := (FwLibVersion() >= "20211116")
		EndIf 
		
		For nX := 1 to nQtdLinha
			If !Empty(aImpostos[nX,4])
				If __oPccBsRt == Nil
					cQuery := "SELECT ISNULL(SUM(FK3_BASIMP), 0) As BASEIMP FROM ? FK3 WHERE "
					cQuery += "FK3_FILIAL = ? "
					cQuery += "AND FK3.FK3_IDRET = ? "
					cQuery += "AND FK3.FK3_IMPOS = ? "
					cQuery += "AND FK3.D_E_L_E_T_ = ? "
					cQuery := ChangeQuery(cQuery)
					__oPccBsRt := IIf(__lCachQry, FwExecStatement():New(cQuery), FWPreparedStatement():New(cQuery))
				EndIf
				
				__oPccBsRt:SetUnsafe(1, RetSqlName("FK3"))
				__oPccBsRt:SetString(2, cFilialFK3)
				__oPccBsRt:SetString(3, aImpostos[nX,4])
				__oPccBsRt:SetString(4, aImpostos[nX,1])
				__oPccBsRt:SetString(5, cDelete)
				
				nBaseImp := IIf(__lCachQry, __oPccBsRt:ExecScalar("BASEIMP", "600", "15"), MpSysExecScalar(__oPccBsRt:GetFixQuery(), "BASEIMP"))
				
				If nBaseImp > 0
					FK4->(DbSetOrder(1))
					
					If FK4->(DbSeek(cFilialFK4+aImpostos[nX,4])) .And. FK4->FK4_BASIMP != nBaseImp 
						RecLock("FK4")
						FK4->FK4_BASIMP := nBaseImp
						MsUnlock()
					EndIf
				EndIf
			Endif
		Next nX
		
		FWRestArea(aAreaFK4)
		FWRestArea(aAreaAtual)
		FwFreeArray(aAreaFK4)
		FwFreeArray(aAreaAtual)
	EndIf
Return Nil

//--------------------------------------------------------------------------
/*/{Protheus.doc} FVlDiz
Função que ajusta o valor da baixa quanto a dizima periódica

@author totvs
@since  16/03/2021
@version 12
/*/
//--------------------------------------------------------------------------
Static Function FVlDiz(nValSel, nIt, nValBx)
	Local nVlRet	:= 0
	Local nTAbatim	:= 0
	Local nValVA	:= 0

	If mv_par02 == 1
		nValVa	:= Fa330VTit(aTitulos[nIt,If(__lMotRet,28,27)])
	Else
		nValVa	:= Fa330VTit(aTitulos[nIt,If(__lMotRet,31,30)])
	EndIf

	nTAbatim 	:= SumAbatRec(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_MOEDA,"S",dBaixa ) // ,,@nTotIrAbt,@nTotCsAbt,@nTotPisAbt,@nTotCofAbt)

	nVlRet 		:= xMoeda(SE1->E1_SALDO - nDescD + SE1->E1_SDACRES - SE1->E1_SDDECRE + nValVa - __nImpMR - nTAbatim,SE1->E1_MOEDA,nMoeda,,5, __nTxMoedP,Fa330Tx2(nMoeda,nTxMoeda))
	
	If nValSel == NoRound(nVlRet, 2)
		nValBx				:= nVlRet
		aTitulos[nIt, 9] 	:= nVlRet
	Else
		nVlRet	:= nValSel
	EndIf

Return nVlRet

/*/{Protheus.doc} Fa330TitEx
Funcao responsavel por retornar a funcao Fa330Tit externamente devido a filtros utlizados por localizacao 
Function responsible for returning the Fa330Tit function externally due to filters used by location
@type function
@version  P12
@author eduardo.Flima
@since 6/16/2021
@param dExEmiss, date, Emission Date
@param cExOrig, character, origin function of the compensation
@param lExCredi, logical, If it is a credit
@param aExNum, array, Layout Number
@param lExAutoma, logical, If it is automation
@param cNCnt, character, Numeber of the contract
@return aTitulos_array, list with bills avaliable for compensation
/*/
Function Fa330TitEx(dExEmiss,cExOrig,lExCredi,aExNum,lExAutoma,cNCnt)
	Local aTitulos as Array

	Default cNCnt := ""

	If !empty(cNCnt)
		cNumCont:=cNCnt
	Endif 

	aTitulos := {}
	aTitulos := Fa330Tit(dExEmiss,cExOrig,lExCredi,aExNum,lExAutoma)	

Return aTitulos


/*/{Protheus.doc} getDesc
@description Verifica se será aplicado desconto financeiro na baixa por compensação
@type function
@version 12.1.33
@author guilherme.sordi
@since 06/05/2022
@param nValor, numeric, valor da baixa
@return nDesc, numeric, valor do desconto
/*/
static function getDesc(nValor as numeric) as numeric
	local nDesc as Numeric
	local dDtBaixa as date
	local nMoeda as Numeric
	Default nValor := 0
	
	nDesc := 0
	dDtBaixa := dDataBase
	nMoeda := SE1->E1_MOEDA

	If lF330DESC 
		if ExecBlock("F330DESC",.F.,.F.)			
			nDesc := FaDescFin("SE1",dDtBaixa,nValor,nMoeda,/*lVerBxado*/,/*lTemGEM*/)
		endIf
	EndIf

	//nDesc:= IIf(SE1->E1_DESCFIN > 0 .And. SE1->E1_VENCREA-dBaixa >= SE1->E1_DIADESC .and. SE1->E1_DESCONT == 0,SE1->E1_VALOR * (SE1->E1_DESCFIN/100),0)
return nDesc

/*/{Protheus.doc} usaAbat
	@description Verifica se a compensação foi realizada considerando abatimento.
	@type  Static Function
	@author guilhermed.santos
	@since 04/08/2022
	@version 12.1.33
	@param nReg, numeric, RECNO do título de partida no estorno
	@return lRet, logical, Retorna .T. se a compensação foi realizada com abatimento
/*/
Static Function usaAbat(nReg as Numeric) as Logical
	Local aAreaSE1 as Array
	Local aAreaFK6 as Array
	Local aAreaFK1 as Array
	Local cChave as Character
	Local cFK1RA as Character
	Local cIdDocNF as Character
	Local nVlrCmp as Numeric
	Local lRet	as Logical
	
	aAreaSE1	:= SE1->(GetArea())
	aAreaFK6	:= FK6->(GetArea())
	aAreaFK1	:= FK1->(GetArea())
	cChave 		:= ''
	cFK1RA		:= ''
	cIdDocNF	:= ''
	nVlrCmp		:= 0
	lRet		:= .F.

	If lCredito		
		cChave := SE1->E1_FILIAL + "|" +  SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" +SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
		cIdDocNF := FinBuscaFK7(cChave,"SE1")
	Else
		SE1->(DbGoTo(nReg))
		cChave := SE1->E1_FILIAL + "|" +  SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" +SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
		cIdDocNF := FinBuscaFK7(cChave,"SE1")
	EndIf

	If SE1->E1_SALDO == 0
		DbSelectArea("FK1")
		FK1->(DbSetOrder(5)) //FK1_IDDOC+FK1_SEQ
		FK6->(DbSetOrder(2)) //FK6_FILIAL+FK6_IDORIG+FK6_TABORI+FK6_IDFK6
		FK1->(DbSeek(cIdDocNF))
		While !EOF() .and. FK1->FK1_IDDOC == cIdDocNF
			If FK1->FK1_RECPAG = 'R'
				nVlrCmp += FK1->FK1_VALOR
			Else
				nVlrCmp -= FK1->FK1_VALOR
			EndIf
			If FK6->(DbSeek(FK1->FK1_FILIAL+FK1->FK1_IDFK1+"FK1"))
				While !FK6->(EOF()) .and. FK6->FK6_FILIAL+FK6->FK6_IDORIG+FK6->FK6_TABORI == FK1->FK1_FILIAL+FK1->FK1_IDFK1+"FK1"
					If FK6->FK6_RECPAG = 'R'
						If FK6->FK6_TPDOC $ 'DC/VA'
							nVlrCmp += FK6->FK6_VALMOV
						ElseIf FK6->FK6_TPDOC == 'JR'
							nVlrCmp -= FK6->FK6_VALMOV
						EndIf
					EndIf
					FK6->(dbSkip())
				EndDo
			EndIf
			FK1->(dbSkip())
		EndDo

		lRet := SE1->E1_VALOR > nVlrCmp
	EndIf

	RestArea(aAreaSE1)
	RestArea(aAreaFK6)
	RestArea(aAreaFK1)
Return lRet

/*/{Protheus.doc} TipoGerPix
    Valida se um determinado tipo de título
    pode gerar registro no monitor pix

    @author Sivaldo Oliveira
    @since 30/06/2022
    @return lRet, Logical, retorna verdadeiro (.T.) ou falso (.F.),
    (.T.) = Pode gerar registro no monitor pix
    (.F.) = Não pode gerar no monitor pix
/*/
Static Function TipoGerPix(cTipoTit As Char) As Logical
    Local lRet   As Logical
    Local cLista As Char
    
    Default cTipoTit := ""
    
    If (lRet   := !Empty(cTipoTit))
        cLista := MVABATIM+"|"+MV_CRNEG+"|"+MVTXA+"|"+MV_CPNEG+"|"+MVPROVIS+"|"+MVINSS+"|"+MVPAGANT
        cLista += "|"+MVISS+"|"+MVIRF+"|"+MVRECANT+"|TX |SES|CID|INA|PIS|CSL|COF"
        
        lRet := !cTipoTit $ cLista 
    EndIf	

Return lRet	

/*/{Protheus.doc} ExcImpoPix
	Valida se o título está em situação de cobrança
	pix, para que seja excluído os impostos destacados
	na geração da remessa de cobrança/integração PIX
	
	@author Sivaldo Oliveira
	@since 21/06/2022
	@version P12
	
	@Param nRecnoSE1, Numeric, Recno do cadastro do título
	@Return lRetorno, Logical, Retorna um Verdadeiro ou Falso que indica se o 
	usuário confirmou ou não a marcação/seleção do título
/*/
Static Function ExcImpoPix(nRecnoSE1 As Numeric) As Logical
	Local lRetorno   As Logical
	Local lTemImpPix As Logical
	Local aAreaAtual As Array
	Local aAreaSE1   As Array
	
	Default nRecnoSE1 := 0
	
	//Inicializa variáveis
	lRetorno   := .T.
	lTemImpPix := .F.	
	
	If nRecnoSE1 > 0 .And. cPaisLoc == "BRA" .And. __lExcImpo .And. !__lCNABImp .And. __TpGerPix
		aAreaAtual := GetArea()
		aAreaSE1   := SE1->(GetArea())
		SE1->(DbGoto(nRecnoSE1))
		
		If SE1->E1_SITUACA != "0" .And. TtBxImpPix(nRecnoSE1)
			lTemImpPix := !BorderoImp(SE1->E1_FILORIG, SE1->E1_NUMBOR, "R", SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA)
			
			If lTemImpPix
				nRecnoF71 := F71Ativa(nRecnoSE1)
				
				If nRecnoF71 > 0
					lRetorno := IIf(l330Auto, __lMaTiPix, MsgTtBxPix(.F., .F., .F., .F.))						
					
					If lRetorno .And. ExcluiImpo(SE1->E1_FILIAL, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, nRecnoF71)
						
						cIdDocFK7 := FINBuscaFK7(xFilial("SE1", SE1->E1_FILORIG)+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA, "SE1", SE1->E1_FILORIG)					
						
						If !Empty(cIdDocFK7) .And. PIXCancel(SE1->E1_FILIAL, cIdDocFK7, .T.)
							AAdd(__aRecF71, {nRecnoF71, (SE1->E1_FILIAL+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA), SE1->E1_FILORIG})							
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		
		RestArea(aAreaSE1)		
		RestArea(aAreaAtual)
		FwFreeArray(aAreaSE1)
		FwFreeArray(aAreaAtual)		
	EndIf
Return lRetorno

/*/{Protheus.doc} F71Ativa
	Verifica se há registro monitor pix
	ativo, e retorna o recno do registro
	
	@author Sivaldo Oliveira
	@since 01/07/2022
	@Param nRecnoSE1, Numeric, Recno do cadastro do título
	@return nRecnoF71, numeric, Renco do registro ativo no 
	monitor pix (F71)
/*/
Static Function F71Ativa(nRecnoSE1 As Numeric) As Numeric
	Local cChaveF71  As Char	
	Local nRecnoF71  As Numeric
	Local aAreaAtual As Array
	Local aAreaSE1   As Array
	
	Default nRecnoSE1 := 0
	
	//Inicializa variáveis
	cChaveF71 := ""
	nRecnoF71 := 0
	
	If nRecnoSE1 > 0
		aAreaAtual := GetArea()
		aAreaSE1   := SE1->(GetArea())
		DbSelectArea("F71")
		SE1->(DbGoto(nRecnoSE1))
		
		F71->(DbSetOrder(2))
		If F71->(DbSeek(SE1->(E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA)))
			cChaveF71 := F71->(F71_FILIAL+F71_IDDOC) 
			
			While F71->(F71_FILIAL+F71_IDDOC) == cChaveF71
				If F71->F71_STATUS $ "1|5|6|7|8"
					F71->(DbSkip())
					Loop
				EndIf
				
				nRecnoF71 := F71->(Recno())
				Exit
			EndDo			
		EndIf
		
		RestArea(aAreaSE1)
		RestArea(aAreaAtual)
		FwFreeArray(aAreaSE1)
		FwFreeArray(aAreaAtual)
	EndIf	
Return nRecnoF71

//-------------------------------------------------------------------
/*/{Protheus.doc}FA330Msg

Valida se o valor a ser compensado é superior ao valor do Valor Acessório. 
lHelp quando passada como .T. irá mostrar o Help na tela.

@author Vinicius Nascimento
@since  23/09/2022
@version 12
/*/
//-------------------------------------------------------------------

Static Function FA330Msg(lHelp as Logical, nValVa as Numeric, nAcresc as Numeric) as Logical
	Local lRet as Logical
	Local nValor as Numeric

	Default nAcresc 	:= 0
	Default nValVa 		:= 0

	nValor := If(FwIsInCallStack("FA330TROCA"),cValor,If(!lCredito,SE1->E1_SALDO,nSaldo)) 
	lRet := .T.

	If nValVa > 0 
	   	If (nAcresc + nValVa) > nValor 
	   	  	If lHelp
			   Help(" ",1,"CMPMENORQVA",,STR0139,1,0,,,,,,{STR0140}) //O valor efetivamente compensado é menor que os Valores Acessórios, "Por favor, ajuste o valor Compensado.
			Endif
			lRet := .F.
		Endif
	Endif

Return lRet

 /*/{Protheus.doc} getComp
	Retorna string de três posições indicando o comportilhamento da tabela em questão, 
	sendo as posições na ordem: EMPRESA, UNIDADE, FILIAL
	@type  Function
	@author guilherme.sordi
	@since 03/03/2022
	@version 12.1.33
	@param cAlias, character, Alias da tabela em questão
	@return cComp, character, String indicando o compartilhamento. Exemplos: EEE, EEC, CCC
/*/
Static Function getComp(cAlias as character) as character
	Local cComp as character
	Local lQuery as logical

	If cAlias == NIL
		return ""
	EndIf

	lQuery := .T.
	aComp := FwSX2Util():GetSX2Data(cAlias, {"X2_MODOEMP", "X2_MODOUN", "X2_MODO"}, lQuery)

	If Left(AllTrim(FWSM0Layout()),1) == "F"
		cComp := Replicate(aComp[3][2], 3)
	Else
		cComp := aComp[1][2] + aComp[2][2] + aComp[3][2]
	EndIf

Return cComp

/*/{Protheus.doc} GeraMonPix
	Gera novo registro no Monitor Pix
	
	@author Sivaldo Oliveira
	@since 23/12/2022
/*/
Static Function GeraMonPix()
	Local nArray As Numeric
	Local nQuant As Numeric
	
	//Inicializa variáveis
	nArray := 0
	nQuant := Len(__aRecF71)
	
	If nQuant > 0
		For nArray := 1 To nQuant
			F71->(DbGoto(__aRecF71[nArray,1]))
			F986AltPix(__aRecF71[nArray,2], __aRecF71[nArray,3], .F.)
		Next nArray
	EndIf
Return Nil

/*/{Protheus.doc} VldCalcImp
	Valida se já houve retenção total dos impostos, na primeira baixa do título.
	
	@author Sivaldo Oliveira
	@since 02/08/2023

	@param dDataBaixa, Date, Data da baixa
	@param nVlrTitulo, Numeric, Valor de inclusão do título
	@param nSldTitulo, Nunmeric, Saldo do título
	@param nBaseImpos, Numeric, Base de cálculo do imposto
	@Param cChaveTitu, Char, Chave do título separada cada campo por |
	@param FilialOrig, Char, Filial origem de inclusão do título.
	@Return lRetorno, Logical, Define haverá cálculo de imposto para o título
/*/
Static Function VldCalcImp(dDataBaixa As Date, nVlrTitulo As Numeric, nSldTitulo, nBaseImpos As Numeric, cChaveTitu As Char, FilialOrig As Char) As Logical
	Local lRetorno   As Logical
	Local cIdDocFK7  As Char
	Local nVlrRetido As Numeric
	
	//Parâmetros de entrada da função.
	Default dDataBaixa := Ctod("  /  /    ")
	Default nVlrTitulo := 0 
	Default nSldTitulo := 0
	Default cChaveTitu := "" 
	Default FilialOrig := cFilAnt
	
	//Inicializa variáveis
	lRetorno   := .T.
	cIdDocFK7  := ""
	nVlrRetido := 0
	nBaseImpos := 0
	
	If cPaisLoc == "BRA" .And. __lMVGlosa .And. nVlrTitulo > 0
		lRetorno := (Empty(dDataBaixa) .And. nVlrTitulo == nSldTitulo)
		
		If !lRetorno .And. nVlrTitulo != nSldTitulo .And. !Empty(cChaveTitu)
			cIdDocFK7  := FinBuscaFK7(cChaveTitu, "SE1", FilialOrig) 
			lRetorno := (ImposRetid(cIdDocFK7) <= 0)
		EndIf
		
		If lRetorno
			nBaseImpos := nSldTitulo
		EndIf
	EndIf
Return lRetorno

/*/{Protheus.doc} ImposRetid
	Retorna o somatório de impostos retidos
	
	@author Sivaldo Oliveira
	@since 04/08/2023
	
	@param cIdDocFK7, Char, Identificador do registro de inclusão do título
	@return nVlrRetido, Numeric, Total de impostos retidos
/*/
Static Function ImposRetid(cIdDocFK7 As Char) As Numeric
	Local cQryRetido As Char	
	Local cTabelaFK1 As Char
	Local cTabelaFK4 As Char
	Local nVlrRetido As Numeric
	
	//Parâmetros de entrada
	Default cIdDocFK7 := ""
	
	//Inicializa variáveis
	cQryRetido := ""
	cTabelaFK1 := ""
	cTabelaFK4 := ""
	nVlrRetido := 0
    
	If !Empty(cIdDocFK7)		
		If __lCachQry == Nil
			__lCachQry := (FwLibVersion() >= "20211116")
		EndIf 	
		
		If __oImposto == Nil
			cTabelaFK1 := RetSqlName("FK1")
			cTabelaFK4 := RetSqlName("FK4")			
			
			cQryRetido := "SELECT ISNULL(SUM(FK4.FK4_VALOR), 0) FK4_VALOR FROM " + cTabelaFK4 + " FK4 "
			cQryRetido += "INNER JOIN " + cTabelaFK1 + " FK1 "
			cQryRetido += "ON (FK4.FK4_FILIAL = FK1.FK1_FILIAL " 
			cQryRetido += "AND FK4.FK4_IDORIG = FK1.FK1_IDFK1 "
			cQryRetido += "AND FK4.D_E_L_E_T_ = FK1.D_E_L_E_T_) "
			cQryRetido += "WHERE FK4.FK4_RECPAG = 'R' AND FK4.FK4_STATUS = '1' "
			cQryRetido += "AND FK1.FK1_IDDOC = ? AND FK4.D_E_L_E_T_ = ' ' "
			cQryRetido += "AND FK1_SEQ NOT IN ("
			cQryRetido += "SELECT FK1ES.FK1_SEQ FROM " + cTabelaFK4 + " FK4ES "
			cQryRetido += "INNER JOIN " + cTabelaFK1 + " FK1ES "
			cQryRetido += "ON (FK4ES.FK4_FILIAL = FK1ES.FK1_FILIAL " 
			cQryRetido += "AND FK4ES.FK4_IDORIG = FK1ES.FK1_IDFK1 "
			cQryRetido += "AND FK4ES.D_E_L_E_T_ = FK1ES.D_E_L_E_T_) "
			cQryRetido += "WHERE FK4ES.FK4_RECPAG = 'P' AND FK4ES.FK4_STATUS = '2' "	
			cQryRetido += "AND FK1ES.FK1_IDDOC = ? AND FK4ES.D_E_L_E_T_ = ' ')"
			cQryRetido := ChangeQuery(cQryRetido)
			__oImposto := IIf(__lCachQry, FwExecStatement():New(cQryRetido), FWPreparedStatement():New(cQryRetido))
		EndIf
		
		__oImposto:SetString(1, cIdDocFK7)		
		__oImposto:SetString(2, cIdDocFK7)		
		nVlrRetido := IIf(__lCachQry, __oImposto:ExecScalar("FK4_VALOR", "600", "15"), MpSysExecScalar(__oImposto:GetFixQuery(), "FK4_VALOR"))
	EndIf
Return nVlrRetido

/*/{Protheus.doc} GetVlrMov
	Define os valores de movimentação (SE5/FK1) do RA e NF a serem gravados
	
	Cenários que atenderem os requisitos abaixo:
		1 - Retencao do PCC ou IRRF na baixa
		2 - Compensação entre moedas diferentes, um dos títulos esteja na moeda real
	
	Obs: Regra para atender o pacote de correções da compensacao CR ref. issue DSFIN-8689.

	@author Fabio Casagrande / Sivaldo Oliveira
	@since 24/07/2024
	
	@param nRecnTitRA, Numeric, Recno do título de adiantamento
	@param nRecnTitNF, Numeric, Recno do título de NF
	@param nVlrMovCmp, Numeric, Valor selecionado no título para compensação
	@Param lPccBxCr,   Logic,   Indica se há cálculo dos impostos pis, cofins, ou csll na baixa
	@Param lIrPjBxCr,  Logic,   Indica se há cálculo do imposto irrf na baixa
	@return Nil
/*/
Static Function GetVlrMov(nRecnTitRA As Numeric, nRecnTitNF As Numeric, nVlrMovCmp As Numeric, lPccBxCr As Logical, lIrPjBxCr As Logical)
	Local nBaCalReal As Numeric
	Local nBaCalEstr As Numeric
	Local nPosicao   As Numeric
	Local nPercenImp As Numeric
	Local nVlCmpReal As Numeric
	Local nVlCmpEstr As Numeric
	Local nMoedaEstr As Numeric
	Local nMoedTitNF As Numeric
	Local nImpRetNF  As Numeric
	Local nImRetReal As Numeric
	Local nImRetEstr As Numeric
	Local nSldRealNF As Numeric
	Local nSldEstrNF As Numeric
	Local nImpRealNF As Numeric
	Local nImpEstrNF As Numeric
	Local lBxTotalNF As Logical
	Local nMoedTitRA As Numeric
	Local nSldRealRA As Numeric	
	Local nSldEstrRA As Numeric
	Local aAreaAtual As Array
	Local aAreaSE1   As Array
	Local aPCC       As Array
	Local lMVRARTIMP As Logical
	
	//Parâmetros de entrada
	Default nRecnTitRA := 0
	Default nRecnTitNF := 0
	Default nVlrMovCmp := 0
	Default lPccBxCr   := .F.
	Default lIrPjBxCr  := .F.
	
	//Inicializa variáveis
	nBaCalReal := 0
	nBaCalEstr := 0
	nPosicao   := 0
	nPercenImp := 0
	nVlCmpReal := 0
	nVlCmpEstr := 0
	nMoedaEstr := 0
	nMoedTitNF := 0
	nImpRetNF  := 0
	nImRetReal := 0
	nImRetEstr := 0
	nSldRealNF := 0
	nSldEstrNF := 0
	nImpRealNF := 0
	nImpEstrNF := 0
	lBxTotalNF := .F.
	nMoedTitRA := 0
	nSldRealRA := 0
	nSldEstrRA := 0
	lMVRARTIMP := .F.
	aAreaAtual := Nil
	aAreaSE1   := Nil
	aPCC       := Nil
	
	If nRecnTitRA > 0 .And. nRecnTitNF > 0 .And. nVlrMovCmp > 0 .And. (lPccBxCr .Or. lIrPjBxCr) 		
		aAreaAtual := GetArea()
		aAreaSE1   := SE1->(GetArea())
		lMVRARTIMP := SuperGetMv("MV_RARTIMP", .F., "1") == "2"
		
		
		//Posiciona no título de adiantamento
		SE1->(DbGoTo(nRecnTitRA))
		
		//Dados do adiantamento (RA)
		nMoedTitRA := SE1->E1_MOEDA
		nSldRealRA := SE1->E1_SALDO
		If nMoedTitRA > 1  
			__nTxMoedP := Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)
		EndIf	

		
		//Posiciona no título de NF
		SE1->(DbGoTo(nRecnTitNF))
		nMoedTitNF := SE1->E1_MOEDA
		nMoedaEstr := IIf(nMoedTitRA == 1, nMoedTitNF, nMoedTitRA)
		If nMoedTitNF > 1 
			__nTxMoedP := Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)
		EndIf

		//Define os valores em moeda corrente e estrangeira do saldo do adiantamento (RA)
		nSldRealRA := IIf(nMoedTitRA == 1, nSldRealRA, Round(xMoeda(nSldRealRA, nMoedTitRA, 1, dBaixa, __nCasDec, __nTxMoedP), 2))
		nSldEstrRA := IIf(nMoedTitRA != 1, nSldRealRA, Round(xMoeda(nSldRealRA, 1, nMoedaEstr, dBaixa, __nCasDec, 0, __nTxMoedP), 2))
		
		//Define os valores de movimentos (SE5) compensados em moeda corrente e moeda estrangeira
		nVlCmpReal := IIf(__nMoePart == 1, nVlrMovCmp, Round(xMoeda(nVlrMovCmp, nMoedaEstr, 1, dBaixa, __nCasDec, __nTxMoedP), 2))
		nVlCmpEstr := IIf(__nMoePart != 1, nVlrMovCmp, Round(xMoeda(nVlrMovCmp, 1, nMoedaEstr, dBaixa, __nCasDec, 0, __nTxMoedP), 2))
		__nMovRA   := IIf(nMoedTitRA == 1, nVlCmpReal, nVlCmpEstr)
		__nMovNF   := IIf(nMoedTitNF == 1, nVlCmpReal, nVlCmpEstr)
		
		//Recomposição da base de cálculo dos impostos		
		If lMVRARTIMP .And. SE1->E1_VALOR != SE1->E1_SALDO
			nImpRetNF  := ImposRetid(FinBuscaFK7(SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), "SE1", SE1->E1_FILORIG))
			nImRetReal := nImpRetNF  			
			nImRetEstr := IIf((nImpRetNF > 0 .And. nMoedTitNF > 1), Round(xMoeda(nImpRetNF, 1, nMoedTitNF, dBaixa, __nCasDec, 0, __nTxMoedP), 2), nImpRetNF)
			nImpRetNF  := nImRetEstr
		EndIf
		
		nSldRealNF := IIf(nMoedTitNF == 1, (SE1->E1_SALDO + nImpRetNF), Round(xMoeda((SE1->E1_SALDO + nImpRetNF), nMoedTitNF, 1, dBaixa, __nCasDec, __nTxMoedP), 2))
		nSldEstrNF := IIf(nMoedTitNF != 1, (SE1->E1_SALDO + nImpRetNF), Round(xMoeda((SE1->E1_SALDO + nImpRetNF), 1, nMoedaEstr, dBaixa, __nCasDec, 0, __nTxMoedP), 2))
		nBaCalReal := nSldRealNF
		
		//Cálculo dos impostos PIS, COFINS e CSLL
		If lPccBxCr
			aPCC    := newMinPcc(dBaixa, nBaCalReal, SE1->E1_NATUREZ, "R", SE1->(E1_CLIENTE+E1_LOJA))
			nPis    := aPCC[2]
			nCofins := aPCC[3]
			nCsll   := aPCC[4]
		EndIf
		
		//Cálculo do imposto IRRF
		If lIrPjBxCr
			nIrrf := FCaIrBxCR(nBaCalReal)
		EndIf
		
		If (nImpRealNF := (nPis+nCofins+nCsll+nIrrf)) > 0
			If lPccBxCr .And. (nPis+nCofins+nCsll) > 0
				nImpEstrNF += IIf(nPis > 0,    Round(xMoeda(nPis,    1, nMoedaEstr, dBaixa, __nCasDec, 0, __nTxMoedP), 2), 0)
				nImpEstrNF += IIf(nCofins > 0, Round(xMoeda(nCofins, 1, nMoedaEstr, dBaixa, __nCasDec, 0, __nTxMoedP), 2), 0)
				nImpEstrNF += IIf(nCsll > 0,   Round(xMoeda(nCsll,   1, nMoedaEstr, dBaixa, __nCasDec, 0, __nTxMoedP), 2), 0)
			EndIf
			
			If lIrPjBxCr .And. nIrrf > 0
				nImpEstrNF += IIf(nIrrf > 0,   Round(xMoeda(nIrrf,   1, nMoedaEstr, dBaixa, __nCasDec, 0, __nTxMoedP), 2), 0)
			EndIf
			
			//Obtém o valor bruto da compensação, em moeda real e estrangeira
			If lMVRARTIMP
				lBxTotalNF := ((nVlCmpReal + nImRetReal + nImpRealNF) == nSldRealNF)
			Else
				nPercenImp := (nImpRealNF / nSldRealNF)
				nBaCalReal := (nVlCmpReal * 100) / (100 - (nPercenImp * 100))
				nBaCalEstr := (nVlCmpEstr * 100) / (100 - (nPercenImp * 100))
			EndIf
			
			//Refaz a base e o cálculo dos impostos, quando não for a compensação total do título NF			
			If !lBxTotalNF .And. (((nVlCmpReal + (nPercenImp * nBaCalReal) + nImRetReal) < nSldRealNF) .Or. ((nVlCmpEstr + (nPercenImp * nBaCalEstr) + nImRetEstr) < nSldEstrNF))
				nBaCalReal := IIf(lMVRARTIMP, nVlCmpReal, nBaCalReal) 
				
				If lPccBxCr
					aPCC    := newMinPcc(dBaixa, nBaCalReal, SE1->E1_NATUREZ, "R", SE1->(E1_CLIENTE+E1_LOJA))
					nPis    := aPCC[2]
					nCofins := aPCC[3]
					nCsll   := aPCC[4]
				EndIf
				
				If lIrPjBxCr 
					nIrrf := FCaIrBxCR(nBaCalReal)
				EndIf
				
				If (nImpRealNF := (nPis+nCofins+nCsll+nIrrf)) > 0
					If lPccBxCr .And. (nPis+nCofins+nCsll) > 0
						nImpEstrNF := IIf(nPis > 0,    Round(xMoeda(nPis,    1, nMoedaEstr, dBaixa, __nCasDec, 0, __nTxMoedP), 2), 0)
						nImpEstrNF += IIf(nCofins > 0, Round(xMoeda(nCofins, 1, nMoedaEstr, dBaixa, __nCasDec, 0, __nTxMoedP), 2), 0)
						nImpEstrNF += IIf(nCsll > 0,   Round(xMoeda(nCsll,   1, nMoedaEstr, dBaixa, __nCasDec, 0, __nTxMoedP), 2), 0)
					EndIf
					
					If lIrPjBxCr .And. nIrrf > 0
						nImpEstrNF += IIf(nIrrf > 0,   Round(xMoeda(nIrrf,   1, nMoedaEstr, dBaixa, __nCasDec, 0, __nTxMoedP), 2), 0)
					EndIf
				EndIf
				
				If !lMVRARTIMP
					__nMovNF := IIf(nMoedTitNF == 1, (nBaCalReal - nImpRealNF), (nBaCalEstr - nImpEstrNF))
				EndIf
			Else
				__nMovNF := SE1->E1_SALDO - IIf(nMoedTitNF == 1, nImpRealNF, nImpEstrNF)
			EndIf
			
			__nMovRA := Round(IIf(nMoedTitRA == 1, xMoeda(__nMovNF, nMoedaEstr, nMoedTitRA, dBaixa, __nCasDec, __nTxMoedP, 0), xMoeda(__nMovNF, 1, nMoedaEstr, dBaixa, __nCasDec, 0, __nTxMoedP)), 2)
			
			If lMVRARTIMP
				__nMovRA := Min(__nMovRA, IIf(nMoedTitRA == 1, nSldRealRA, nSldEstrRA)) 
			EndIf
		EndIf				
		
		If lPccBxCr .And. (nPis+nCofins+nCsll) > 0
			__aTitCalc := IIf(Len(aPCC) > 4 , aPCC[5], __aTitCalc)
		EndIf
		
		If lIrPjBxCr .And. nIrrf
			nPosicao   := AScan(aImpIR, {|x| x[2] == SE1->(Recno())})
			
			IIf(nPosicao == 0, AAdd(aImpIR, {nIrrf, SE1->(Recno())}), aImpIR[nPosicao][1] := nIrrf)
			nPosicao   := IIf(nPosicao == 0, Len(aImpIR), nPosicao)
		EndIf
		
		__lCalcImp := .F.
		
		RestArea(aAreaSE1)
		RestArea(aAreaAtual)
		FwFreeArray(aPCC)
		FwFreeArray(aAreaSE1)
		FwFreeArray(aAreaAtual)
	EndIf
Return Nil

/*/{Protheus.doc} VImpRAMd2
	Verifica se a compensação possui os requisitos abaixo:
		- Compensação utilizando adiantamento (RA);
		- Retencao de impostos PCC/IR pela baixa e pelo RA (MV_RARTIMP=1);
		- Se a moeda do titulo de partida e destino são diferentes;
		- Se o titulo de partida ou destino possui a moeda forte;
	
	Obs: Regra para atender o pacote de correções 
		da compensacao CR ref. issue DSFIN-8689.

	@author Fabio Casagrande
	@since 24/07/2024
	
	@param lMvRaRtImp, Logical, Posição do titulo no array aTitulos
	@param cTpPart, Char, Moeda do titulo de partida
	@param cTpDest, Char, Moeda do titulo de destino
	@param nMoedP, Numeric, Moeda do titulo de partida
	@param nMoedD, Numeric, Moeda do titulo de destino
	@param lIrBx, Logical, Identifica se o IR é calc. na baixa
	@param lPccBx, Logical, Identifica se o PCC é calc. na baixa
	
	@return lRet, Logical, Indica se a compensação atende os requisitos
/*/
Static Function VMd2ImpRA(lMvRaRtImp, cTpPart, cTpDest, nMoedP, nMoedD, lIrBx, lPccBx)

	Local lRet As Logical

	Default lMvRaRtImp := FRaRtImp() 
	Default cTpPart := ""
	Default cTpDest := ""
	Default nMoedP := "1"
	Default nMoedD := "1"
	Default lIrBx := .F.
	Default lPccBx := .F.

	lRet := .F.

	If lMvRaRtImp .And. !(cTpPart $ MV_CRNEG) .And. !(cTpDest $ MV_CRNEG) .And. nMoedP <> nMoedD .And. (nMoedP == 1 .Or. nMoedD == 1) .And. (lIrBx .Or. lPccBx)
		lRet := .T.
	EndIf

Return lRet
