#INCLUDE "MATA298.CH"
#INCLUDE "PROTHEUS.CH"
#DEFINE PULALINHA CHR(13) + CHR(10)

/*

Funo     MatA298   Autor  Ary Medeiros           Data  ***         
Ĵ
Descrio  Composicao Seletiva do Produto   ***                       
Ĵ
 Uso       Generico                                                   
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                   
Ĵ
 Aline C. Vale19/04/99PROTHEAjuste para compilacao Protheus         
ٱ




*/
Function MatA298
Private lSG1298 := (ExistBlock( "SG1298" ) )
//Ŀ
// Define Array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada                          
//    1 - Pesquisa e Posiciona em um Banco de Dados             
//    2 - Simplesmente Mostra os Campos                         
//    3 - Inclui registros no Bancos de Dados                   
//    4 - Altera o registro corrente                            
//    5 - Remove o registro corrente do Banco de Dados          
//
PRIVATE aRotina := MenuDef()

PRIVATE cCadastro := OemToAnsi(STR0006)	//"Composio Seletiva"
//Ŀ
// Fecha arquivos SD1/SD2 para poder abrir SG3/SG4          
//
dbSelectArea("SD1")
dbCloseArea()
dbSelectArea("SD2")
dbCloseArea()
ChkFile("SG3")
ChkFile("SG4")
mBrowse( 6, 1,22,75,"SG4" )
//Ŀ
// Fecha arquivos SG3/SG4 para poder abrir SD1/SD2          
//
dbSelectArea("SG3")
dbCloseArea()
dbSelectArea("SG4")
dbCloseArea()
ChkFile("SD1")
ChkFile("SD2")
Return .T.

/*


Ŀ
Funo    A298Inclui Autor  Ary Medeiros           Data           
Ĵ
Descrio  Programa de inclusao de estruturas                         
Ĵ
Sintaxe    A298Inclui(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Opcao selecionada                                  
Ĵ
 Uso       MATA298                                                    
ٱ


*/
FUNCTION A298Inclui(cAlias,nReg,nOpcx)
LOCAL bCampo,cSaveMenuh
LOCAL GetList	:={}
LOCAL aCRA		:=  { "Confirma","Redigita","Abandona" }
LOCAL nOPCa 	:= 0, cUni, cShow, cCodSel, cSufix, cPrefix
LOCAL nLin 		:= 0, cPrdPadrao,cRotPadrao
LOCAL oDlg,oGet				
LOCAL aDados	:={}
LOCAL i
Local aParam	:= {}
Local uRet
Local cAlert	:= ""
Local lRet		:= .T.

dbSelectArea(cAlias)
nSavRec := RecN()

//Ŀ
// Monta a entrada de dados do arquivo                          
//
PRIVATE aTELA[0][0],aGETS[0],aHeader[0],Continua,nUsado:=0


//Ŀ
// Salva a integridade dos campos de Bancos de Dados            
//
dbSelectArea("SX2")
dbSeek(cAlias)
dbSelectArea("SX3")
dbSeek(cAlias)
While !EOF() .And. (x3_arquivo == cAlias)
	If X3USO(x3_usado) .And. !Trim(x3_campo)$("G4_FILIAL/G4_FIXO");
			.And. cNivel >= x3_nivel
		nUsado++
		AADD(aHeader,{ TRIM(X3Titulo()), x3_campo, x3_picture,;
			x3_tamanho, x3_decimal, x3_valid,;
			x3_usado, x3_tipo, x3_arquivo, x3_context } )
	ENDIF
	dbSkip()
EndDO
PRIVATE aCOLS[1][nUsado+1]
dbSelectArea("SX3")
dbSeek(cAlias)
nUsado:=0
While !EOF() .And. (x3_arquivo == cAlias)
	IF X3USO(x3_usado) .And. !Trim(x3_campo)$("G4_FILIAL/G4_FIXO");
			.And. cNivel >= x3_nivel
		nUsado++
		//Ŀ
		// Monta Array de 1 elemento 
		// vazio. Se incluso.       
		//
		IF x3_tipo == "C"
			aCOLS[1][nUsado] := SPACE(x3_tamanho)
		ELSEIF x3_tipo == "N"
			aCOLS[1][nUsado] := 0
		ELSEIF x3_tipo == "D"
			aCOLS[1][nUsado] := dDataBase
		ELSEIF x3_tipo == "M"
			aCOLS[1][nUsado] := ""
		ELSE
			aCOLS[1][nUsado] := .F.
		ENDIF
		If x3_context == "V"
			aCOLS[1][nUsado] := CriaVar(AllTrim(x3_campo))
		Endif
	ENDIF
	dbSkip()
EndDo
aCOLS[1][nUsado+1] := .F.

Continua	:= .F.
cCodSel		:= SuperGetMV("MV_CODSEL",.F.,"111.111111111111")
cSufix		:= Substr(cCodSel,1,At(".",cCodSel)-1)
cPrefix		:= Substr(cCodSel,At(".",cCodSel)+1,Len(cCodSel))
nLin		:= 6
cUni		:= ""
cShow		:= ""

For i:= 1 to Len(cSufix)
	uRet := SuperGetMV("MV_GS"+Str(i,1),.F.,"")
	If "" == uRet
		aParam	:= {}
		cAlert	+= PULALINHA + "- MV_GS" + Str(i,1) 
		lRet 	:= .F. //se algum dos parmetros estiver em branco no permite que o usurio prossiga
	ElseIf lRet
		aAdd(aParam,uRet)
	EndIf
Next i           

If !Empty(cAlert)
	MsgAlert(STR0018 + cAlert,"Aviso!!!")
EndIf

If Len(aParam) > 0
	DbSelectArea("SG3")
	nOpca 	:= 0
	For i:= 1 to Len(cSufix)
		DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0007) From 9,5 To 15,55 OF oMainWnd	//"Entre com os dados:"
		cUni := Space(Val(Substr(cSufix,i,1)))
		@ 1,01 SAY	 Substr(aParam[i],1,15)
		@ 1,07 MSGET cUni 	PICTURE "@!"	 Valid A298Fix(cUni,@cShow)
		@ 1,12 SAY	 Substr(SG3->G3_DESCEXT,1,32)
		DEFINE SBUTTON FROM 30,110  		TYPE 1 ACTION (nOpca:=1,oDlg:End())	ENABLE OF oDlg
		DEFINE SBUTTON FROM 30,137.5  	TYPE 2 ACTION oDlg:End()   		 	ENABLE OF oDlg
		ACTIVATE MSDIALOG oDlg
	Next i
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0008) From 9,0 To 28,80 OF oMainWnd	//"Roteiro Padro"
	dbSelectArea(cAlias)
	//Ŀ
	// Solicitar digitacao do Roteiro Padrao.           				  
	//
	cPrdPadrao := Space(15)
	cRotPadrao  := Space(2)
	@ 18,007 SAY OemToAnsi(STR0009) SIZE 40,7 OF oDlg PIXEL	//"Produto Padro"
	@ 18,049 MSGET cPrdPadrao F3 "SB1" Picture "@!" Valid (Vazio(cPrdPadrao) .Or. ExistCpo("SB1",cPrdPadrao)) .And. IniRot(cPrdPadrao,@cRotPadrao) SIZE 50,10 OF oDlg PIXEL
	@ 18,111 SAY OemToAnsi(STR0008) SIZE 40,7 OF oDlg PIXEL	//"Roteiro Padro"
	@ 18,154 MSGET cRotPadrao F3 "SG2" Picture "@!" Valid Vazio(cRotPadrao) .Or. ExistCpo("SG2",cPrdPadrao+cRotPadrao) SIZE 13,10 OF oDlg PIXEL
	cCod := cShow
	dbSelectArea(cAlias)
	oGet := MSGetDados():New(35,5,120,315,nOpcx,"A298LinOK","A298TudOK","",.T.,,,,200)
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(oGet:TudoOk(),oDlg:End(),nOpca := 0)},{||oDlg:End()})
	If nOpcA == 1
		Begin Transaction
			A298Grava(cAlias,cCod,cPrdPadrao,cRotPadrao)
			//Processa Gatilhos
			EvalTrigger()
		End Transaction
	EndIf
EndIf

//Ŀ
// Restaura a integridade da janela                             
//
dbSelectArea(cAlias)
dbGoTo(nSavRec)
Return nOpca

/*


Ŀ
Funo    A298Altera Autor  Ary Medeiros           Data           
Ĵ
Descrio  Programa de alteracao de estruturas                        
Ĵ
Sintaxe    A298Altera(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Opcao selecionada no menu                          
Ĵ
 Uso       MATA298                                                    
ٱ


*/
FUNCTION A298Altera(cAlias,nReg,nOpcx)
LOCAL bCampo,cSaveMenuh,nCnt,cUni,cShow,nLin,cVarTemp,cGS := ""
LOCAL GetList	:= {},nSavRec,cPrdPadrao,cRotPadrao
LOCAL aCRA		:= { "Confirma","Redigita","Abandona" }
Local uRet
Local aParam	:= {}
Local cAlert	:= ""
Local lRet		:= .T.
LOCAL oDlg, oGet,i

//Ŀ
// Verifica se existe algum dado no arquivo                     
//
dbSelectArea(cAlias)
If RecCount() == 0
	Return .T.
EndIf

//Ŀ
// Verifica se esta' na filial correta                          
//
If xFilial() != G4_FILIAL
	Help(" ",1,"A000FI")
	Return .T.
EndIf

PRIVATE nOpcA ,cCod := G4_FIXO

nSavRec := RecNo()
dbSeek(xFilial()+cCod)

nSavLock:= RecNo()
SoftLock(cAlias)

//Ŀ
// Monta a entrada de dados do arquivo                          
//
PRIVATE aTELA[0][0],aGETS[0],aHeader[0],Continua:=.F.,nUsado:=0
bCampo := {|nCPO| Field(nCPO) }

//Ŀ
// Monta o cabecalho                                            
//
dbSelectArea("SX2")
dbSeek(cAlias)

dbSelectArea("SX3")
dbSeek(cAlias)
While !EOF() .And. (x3_arquivo == cAlias)
	IF X3USO(x3_usado) .And. !Trim(x3_campo)$("G4_FILIAL/G4_FIXO");
			.And. cNivel >= x3_nivel
		nUsado++
		AADD(aHeader,{ TRIM(X3Titulo()), x3_campo, x3_picture,;
			x3_tamanho, x3_decimal, x3_valid,;
			x3_usado, x3_tipo, x3_arquivo, x3_context } )
	ENDIF
	dbSkip()
EndDO

//Ŀ
// Posiciona ponteiros dos arquivos utilizados                  
//
dbSelectArea(cAlias)
dbSeek(xFilial()+cCod)

nCnt := 0
While !EOF() .And. G4_FILIAL+G4_FIXO == xFilial()+cCod
	nCnt++
	dbSkip()
EndDo
If nCnt == 0
	dbGoTo(nSavLock)
	MsUnlock()
	dbGoTo(nSavRec)
	Return .T.
EndIf

PRIVATE aCOLS[nCnt][nUsado+1]

dbSelectArea(cAlias)
dbSeek(xFilial()+cCod)

nCnt := 0
While !EOF() .And. G4_FILIAL+G4_FIXO == xFilial()+cCod
	nCnt++
	nUsado:=0
	dbSelectArea("SX3")
	dbSeek(cAlias)
	While !EOF() .And. x3_arquivo == cAlias
		IF X3USO(x3_usado) .And. !Trim(x3_campo)$("G4_FILIAL/G4_FIXO");
				.And. cNivel >= x3_nivel
			nUsado++
			cVarTemp := cAlias+"->"+(x3_campo)
			If x3_context # "V"
				aCOLS[nCnt][nUsado] := &cVarTemp
			ElseIf x3_context == "V"
				aCOLS[nCnt][nUsado] := CriaVar(AllTrim(x3_campo))
			Endif
		ENDIF
		dbSkip()
	EndDo
	aCOLS[nCnt][nUsado+1] := .F.
	dbSelectArea(cAlias)
	dbSkip()
EndDo

nOpca := 0
cStart := 1
Continua := .F.
cCodSel := SuperGetMV("MV_CODSEL",.F.,"111.111111111111")
cSufix  := Substr(cCodSel,1,At(".",cCodSel)-1)
cPrefix := Substr(cCodSel,At(".",cCodSel)+1,Len(cCodSel))
nLin  := 6
cShow := ""

For i:= 1 to Len(cSufix)
	uRet := SuperGetMV("MV_GS"+Str(i,1),.F.,"")
	If "" == uRet
		aParam	:= {}
		cAlert	+= PULALINHA + "- MV_GS" + Str(i,1) 
		lRet 	:= .F. //se algum dos parmetros estiver em branco no permite que o usurio prossiga
	ElseIf lRet
		aAdd(aParam,uRet)
	EndIf
Next i           

If !Empty(cAlert)
	MsgAlert(STR0018 + cAlert,"Aviso!!!")
EndIf

If Len(aParam) > 0
	For i:= 1 to Len(cSufix)
		If i > 4
			Exit
		Endif	
		cLen := Val(Substr(cSufix,i,1))
		cUni := Substr(cCod,cStart,cLen)
		cStart += cLen
		cShow += cUni
		cGS += Substr(aParam[i],1,15) +chr(9) +" - " +chr(9) +cUni
		dbSelectArea("SG3")
		If dbSeek(xFilial()+cShow)
			cGS += +chr(9) +" - " +chr(9) +Substr(SG3->G3_DESCEXT,1,32)
		EndIf
		cGS += chr(13) + chr(10)
	Next i
			
	dbSelectArea("SG3")
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0008) From 9,0 To 38,96 OF oMainWnd	//"Roteiro Padro"

	@ 15,007 SAY cGS SIZE 200,80 OF oDlg PIXEL
	dbSelectArea(cAlias)
	dbSeek(xFilial()+cCod)
	//Ŀ
	// Solicitar digitacao do Roteiro Padrao.                       
	//
	cPrdPadrao := Substr(SG4->G4_ROTPAD,1,15)
	cRotPadrao  := Substr(SG4->G4_ROTPAD,16,2)
	@ 58,007 SAY OemToAnsi(STR0009) SIZE 40,7 OF oDlg PIXEL	//"Produto Padro"
	@ 56,049 MSGET cPrdPadrao F3 "SB1" Picture "@!" Valid Vazio(cPrdPadrao) .Or. ExistCpo("SB1",cPrdPadrao) SIZE 50,10 OF oDlg PIXEL
	@ 58,111 SAY OemToAnsi(STR0008) SIZE 40,7 OF oDlg PIXEL	//"Roteiro Padro"
	@ 56,154 MSGET cRotPadrao F3 "SG2" Picture "@!" Valid Vazio(cRotPadrao) .Or. ExistCpo("SG2",cPrdPadrao+cRotPadrao) SIZE 13,10 OF oDlg PIXEL
	oGet := MSGetDados():New(74,5,215,375,nOpcx,"A298LinOK","A298TudOK","G4_QUANT",.T.,,,,200)
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(oGet:TudoOk(),oDlg:End(),nOpca := 0)},{||oDlg:End()})
	If nOpca == 1
		Begin Transaction
			A298Grava(cAlias,cCod,cPrdPadrao,cRotPadrao)
			//Processa Gatilhos
			EvalTrigger()
		End Transaction
	Else
		dbSelectArea(cAlias)
		dbGoto(nSavLock)
		MsUnLock()
	EndIf
	dbSelectArea(cAlias)
	DbGoto(nSavRec)
EndIf
Return nOpca

/*


Ŀ
Funo    A298Deleta Autor  Ary Medeiros           Data           
Ĵ
Descrio  Programa de exclusao de estruturas                         
Ĵ
Sintaxe    A298Deleta(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       MATA298                                                    
ٱ


*/
FUNCTION A298Deleta(cAlias,nReg,nOpcx)
LOCAL cSaveMenuh,cUni,cShow,cPrdPadrao,cRotPadrao,nLin,cGS :=""
LOCAL GetList	:={},nSavRec,nCntDel := 0,nCnt := 0
LOCAL aAC		:= { "Abandona","Confirma" }, oDlg, oGet,i
Local cVarTemp,nx
Local uRet
Local aParam	:= {}
Local cAlert	:= ""
Local lRet		:= .T.


//Ŀ
// Verifica se existe algum dado no arquivo                     
//
dbSelectArea(cAlias)
If LastRec() == 0
	Return .T.
EndIf

//Ŀ
// Verifica se esta' na filial correta                          
//
If xFilial() != G4_FILIAL
	Help(" ",1,"A000FI")
	Return .T.
EndIf

PRIVATE nOpcA ,cCod := G4_FIXO

nSavRec := RecNo()
dbSeek(xFilial()+cCod)

nSavLock:= Recno()
SoftLock(cAlias)

//Ŀ
// Monta a entrada de dados do arquivo                          
//
PRIVATE aTELA[0][0],aGETS[0],aHeader[0],nUsado:=0


//Ŀ
// Monta o cabecalho                                            
//
dbSelectArea("SX2")
dbSeek(cAlias)

dbSelectArea("SX3")
dbSeek(cAlias)
While !EOF() .And. (x3_arquivo == cAlias)
	IF X3USO(x3_usado) .And. !Trim(x3_campo)$("G4_FILIAL/G4_FIXO");
			.And. cNivel >= x3_nivel
		nUsado++
		AADD(aHeader,{ TRIM(X3Titulo()), x3_campo, x3_picture,;
			x3_tamanho, x3_decimal, x3_valid,;
			x3_usado, x3_tipo, x3_arquivo, x3_context } )
	ENDIF
	dbSkip()
EndDO

//Ŀ
// Posiciona ponteiros dos arquivos utilizados                  
//
dbSelectArea(cAlias)
dbSeek(xFilial()+cCod)

nCnt := 0
While !EOF() .And. G4_FILIAL+G4_FIXO == xFilial()+cCod
	nCnt++
	dbSkip()
EndDo
If nCnt == 0
	dbGoto(nSavRec)
	Return .T.
EndIf

PRIVATE aCOLS[nCnt][nUsado]

dbSelectArea(cAlias)
dbSeek(xFilial()+cCod)

nCnt := 0
While !EOF() .And. G4_FILIAL+G4_FIXO == xFilial()+cCod
	nCnt++
	nUsado:=0
	dbSelectArea("SX3")
	dbSeek(cAlias)
	While !EOF() .And. x3_arquivo == cAlias
		IF X3USO(x3_usado).And. !Trim(x3_campo)$("G4_FILIAL/G4_FIXO");
				.And. cNivel >= x3_nivel
			nUsado++
			cVarTemp := cAlias+"->"+(x3_campo)
			If x3_context # "V"
				aCOLS[nCnt][nUsado] := &cVarTemp
			ElseIf x3_context == "V"
				aCols[nCnt][nUsado] := CriaVar(AllTrim(x3_campo))
			Endif
		ENDIF
		dbSkip()
	EndDo
	dbSelectArea(cAlias)
	dbSkip()
EndDo

cCodSel := SuperGetMV("MV_CODSEL",.F.,"111.111111111111")
cSufix  := Substr(cCodSel,1,At(".",cCodSel)-1)
cPrefix := Substr(cCodSel,At(".",cCodSel)+1,Len(cCodSel))
nLin := 6
cUni := ""
cShow := ""
DbSelectArea("SG3")
cStart := 1
nOpca 	:= 0

For i:= 1 to Len(cSufix)
	uRet := SuperGetMV("MV_GS"+Str(i,1),.F.,"")
	If "" == uRet
		aParam	:= {}
		cAlert	+= PULALINHA + "- MV_GS" + Str(i,1) 
		lRet 	:= .F. //se algum dos parmetros estiver em branco no permite que o usurio prossiga
	ElseIf lRet
		aAdd(aParam,uRet)
	EndIf
Next i           

If !Empty(cAlert)
	MsgAlert(STR0018 + cAlert,"Aviso!!!")
EndIf

If Len(aParam) > 0
	For i:= 1 to Len(cSufix)
		If i > 4
			Exit
		Endif	
		cLen := Val(Substr(cSufix,i,1))
		cUni := Substr(cCod,cStart,cLen)
		cStart += cLen
		cShow += cUni
		cGS += Substr(aParam[i],1,15) +chr(9)+chr(9) +" - " +chr(9)+chr(9) +cUni
		dbSelectArea("SG3")
		If dbSeek(xFilial()+cShow)
			cGS += +chr(9)+chr(9) +" - " +chr(9)+chr(9) +Substr(SG3->G3_DESCEXT,1,32)
		EndIf
		cGS += chr(13) + chr(10)
	Next i
	dbGoTo(nReg)

	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0008) From 9,0 To 38,96 OF oMainWnd	//"Roteiro Padro"

	@ 15,007 SAY cGS SIZE 200,80 OF oDlg PIXEL
	//Ŀ
	// Solicitar digitacao do Roteiro Padrao.                  	  
	//
	cPrdPadrao := Substr(SG4->G4_ROTPAD,1,15)
	cRotPadrao  := Substr(SG4->G4_ROTPAD,16,2)
	@ 58,007 SAY OemToAnsi(STR0009) SIZE 40,7 OF oDlg PIXEL	//"Produto Padro"
	@ 56,049 MSGET cPrdPadrao F3 "SB1" Picture "@!" When .F. SIZE 50,10 OF oDlg PIXEL
	@ 58,111 SAY OemToAnsi(STR0008) SIZE 40,7 OF oDlg PIXEL	//"Roteiro Padro"
	@ 56,154 MSGET cRotPadrao F3 "SG2" Picture "@!" When .F. SIZE 13,10 OF oDlg PIXEL
	oGet := MSGetDados():New(74,5,215,375,nOpcx,"A298LinOK","A298TudOK","",,,,,200)
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(oGet:TudoOk(),oDlg:End(),nOpca := 0)},{||oDlg:End()})
	If nOpcA == 1
		Begin Transaction
			nCntDel := 0
			For nx = 1 to Len(aCols)
				dbSelectArea(cAlias)
				dbSeek(xFilial(cAlias)+cCod+aCols[nx][1])
				RecLock(cAlias,.F.)
				dbDelete()
				MsUnlock()
				nCntDel++
			Next nx
		End Transaction
	Else
		dbSelectArea(cAlias)
		dbGoto(nSavRec)
	EndIf
EndIf

Return

/*


Ŀ
                   ROTINAS DE CRITICA DE CAMPOS                        
ٱ



Ŀ
Funo    A298LinOk  Autor  Ary Medeiros           Data           
Ĵ
Descrio  Critica se a linha digitada esta' Ok                       
Ĵ
Parametros ExpC1 = Objeto a ser verificado.                           
Ĵ
 Uso       MatA298                                                    
ٱ


*/
Function A298LinOk(o)
LOCAL nx,lRet := .T.
LOCAL cComp := aCols[n][1]
LOCAL cColunas := ""
LOCAL aColunas := {},i,t

If aCols[n][Len(aCols[n])]   // caso tenha sido deletado
	Return .T.
EndIf
For i :=1 to Len(aCols)
	AADD(aColunas,"")
Next i
For i := 1 to Len(aHeader)
	If Subs(Trim(aHeader[i][2]),1,6) == "G4_COL"
		cColunas += aCols[n][i]
	Endif
Next i
For nx = 1 To Len(aHeader)
	If Empty(aCols[n][nx])
		If Trim(aHeader[nx][2]) == "G4_CODIGO" .AND. n == Len(aCols)
			Exit
		EndIf
		If Trim(aHeader[nx][2]) == "G4_CODIGO" .OR.;
				Trim(aHeader[nx][2]) == "G4_QUANT"
			Help(" ",1,"A29802")
			lRet := .F.
			Exit
		EndIf
	EndIf
Next nx
If lRet
	For nx := 1 To Len(aCols)
		For t:=1 to Len(aHeader)
			If Subs(Trim(aHeader[t][2]),1,6) == "G4_COL"
				aColunas[nx] += aCols[nx][t]
			Endif
		Next t
	Next nx
	For nx:= 1 to Len(aCols)
		If nx != n .And. cComp+cColunas == aCols[nx][1]+aColunas[nx] .And. !aCols[nx][Len(aCols[nx])]
			Help(" ",1,"A29803")
			lRet := .F.
			Exit
		EndIf
	Next nx
EndIf
Return lRet

/*

Ŀ
Funo    A298TudOk  Autor  Ary Medeiros           Data           
Ĵ
Descrio  Critica se a nota toda esta' Ok                            
Ĵ
Parametros ExpC1 = Objeto a ser verificado.                           
Ĵ
 Uso       MatA298                                                    
ٱ


*/
Function A298TudOk(o)
Return .T.

/*

Ŀ
Funo    A298Grava  Autor  Ary Medeiros           Data           
Ĵ
Descrio  Critica se a linha digitada esta ok                        
Ĵ
 Uso       MatA298                                                    
ٱ


*/
Static Function A298Grava(cAlias,cCod,cPrdPadrao,cRotPadrao)
LOCAL nx ,ny ,nMaxArray ,aAnterior := {} ,nCntDel := 0

dbSelectArea(cAlias)
//Ŀ
// verifica se o ultimo elemento do array esta em branco        
//
nMaxArray := Len(aCols)
For ny = 1 to Len(aHeader)
	If Empty(aCols[nMaxArray][ny])
		If Trim(aHeader[ny][2]) == "G4_CODIGO"   .OR.;
				Trim(aHeader[ny][2]) == "G4_QUANT"
			nMaxArray--
			Exit
		EndIf
	EndIf
Next ny
DbGoBottom()
dbSeek(xFilial()+cCod)
If Found()
	While !EOF() .And. G4_FILIAL+G4_FIXO == xFilial()+cCod
		AADD(aAnterior,RecN())
		dbSkip()
	EndDo
EndIf

For nx = 1 to nMaxArray
	If Len(aAnterior) >= nx
		dbGoto(aAnterior[nx])
		RecLock(cAlias,.F.)
	Else
		RecLock(cAlias,.T.)
	EndIf
	If aCols[nx][Len(aCols[nx])]  // verifica se tem marcacao para apagar
		dbDelete()
		nCntDel++
	Else
		//Ŀ
		// atualiza dados padroes                                   
		//
		Replace 	G4_FILIAL With xFilial(),G4_FIXO With cCod,;
			G4_ROTPAD With cPrdPadrao+cRotPadrao
		//Ŀ
		// ataualiza restante dos dados                                 
		//
		For ny = 1 to Len(aHeader)
			cVar := Trim(aHeader[ny][2])
			If aHeader[ny][10] # "V"
				Replace &cVar. With aCols[nx][ny]
			Endif
		Next ny
	EndIf
Next nx

Return .T.

/*

Ŀ
Funo     A298Fix   Autor  Ary Medeiros           Data           
Ĵ
Descrio  Critica a digitacao da parte fixa do codigo                
Ĵ
 Uso       MatA298                                                    
ٱ


*/
Static Function A298Fix(cUni, cShow)
Local cAlias := Alias()

cShow += cUni
DbSelectArea("SG3")
DbSeek(xFilial()+cShow)
If !Found()
	Help(" ",1,"A29801")
	cShow:=""
	Return .f.
EndIf

dbSelectArea(cAlias)


Return .t.

/*

Ŀ
Funo     A298Gera  Autor  Ary Medeiros           Data           
Ĵ
Descrio  Chamada da funcao de processamento.                        
Ĵ
 Uso       MatA298                                                    
ٱ


*/
Function A298Gera()
Processa({|lEnd| FA298Processa()})


/*

Ŀ
Funo    FA298Processa Autor  Ary Medeiros        Data           
Ĵ
Descrio  Corre SG1 para gerar a Composicao Seletiva.                
Ĵ
 Uso       MatA298                                                    
ٱ


*/
Function FA298Processa()
Local cCod, cTipSel
Private aLog:={{}}

cTipSel := GetMV("MV_TIPSEL")
DbSelectArea("SG1")
DbSetOrder(1)
DbSelectArea("SC6")
dbGoTop()
ProcRegua(SC6->(RecCount()),24,02)
DbGoTop()
While !Eof()
	
	IncProc()
	cCod := C6_PRODUTO
	DbSelectArea("SG1")
	DbSeek(xFilial()+cCod)
	If !Found()
		DbSelectArea("SB1")
		DbSeek(xFilial()+cCod)
		If !(SB1->B1_TIPO $ cTipSel)
			GeraSele(cCod)
		Endif
	EndIf
	DbSelectArea("SC6")
	DbSkip()
End
If !Empty(aLog[1])
	A298LstLog()
EndIf

If lSG1298
	ExecBlock( "SG1298" )
EndIf


Return nil

/*

Ŀ
Funo     GeraSele  Autor  Ary Medeiros           Data           
Ĵ
Descrio  Gerar a Composicao Seletiva.                               
Ĵ
 Uso       MatA298                                                    
ٱ


*/
Function GeraSele(cCod)
Local cCodSel, cFixo, nLenFix, cVar, cCodVar, cCondicao, lWrite
Local aCond, i, nLenVar, cNome, nSavRec, cFixSeek, cSeekCod, cPos
Local cPrdPadrao,cRotPadrao,cProduto
Local cTRT := Space(TamSX3("G1_TRT")[1])

cCodSel := SuperGetMV("MV_CODSEL",.F.,"111.111111111111")
cFixo := Substr(cCodSel,1,At(".",cCodSel)-1)
nLenFix := 0
For i:= 1 to Len(cFixo)
	nLenFix += Val(SubStr(cFixo,i,1))
Next
cVar := Substr(cCodSel,At(".",cCodSel)+1,Len(cCodSel))
cFixo := Substr(cCod,1,nLenFix)
cCodVar := Substr(cCod,Len(cFixo)+1,Len(cCod))
DbSelectArea("SG4")
DbSeek(xFilial()+cFixo)
If !Found()
	If Len(aLog[Len(aLog)]) > 4095
		AADD(aLog,{})
	EndIf	
	AADD(aLog[Len(alog)],{SC6->C6_NUM,SC6->C6_ITEM,cCod,cFixo})
Else
	cPrdPadrao := Substr(SG4->G4_ROTPAD,1,15)
	cRotPadrao  := Substr(SG4->G4_ROTPAD,16,2)
	Begin Transaction
		While Substr(G4_FIXO,1,nLenFix) == cFixo
			If "*"$G4_COL01
				DbSelectArea("SG1")
				dbSetOrder(1)
				dbSeek(xFilial("SG1")+cCod+SG4->G4_CODIGO+"ZZZ",.T.)
				dbSkip(-1)
				If SG1->(G1_FILIAL+G1_COD+G1_COMP) == xFilial("SG1")+cCod+SG4->G4_CODIGO
					cTRT := Soma1(SG1->G1_TRT)
				Else
					cTRT := Space(TamSX3("G1_TRT")[1])
				EndIf
				RecLock("SG1",.t.)
				Replace G1_FILIAL with xFilial()
				Replace G1_COD    with cCod
				Replace G1_COMP   with SG4->G4_CODIGO
				Replace G1_QUANT  with SG4->G4_QUANT
				Replace G1_PERDA  with SG4->G4_PERDA
				Replace G1_INI    with dDataBase
				Replace G1_FIM    with CtoD("31/12/49","ddmmyy")
				Replace G1_FIXVAR with SG4->G4_TIPO
				Replace G1_TRT		with cTRT
				MsUnLock()
				//Ŀ
				// Gerar roteiro de operacoes.                                  
				//
				GeraRot(cPrdPadrao,cRotPadrao,cCod)
				dbSelectArea("SG4")
			Else
				cCondicao := ""
				For i:= 1 to Len(cVar)
					cNome := "G4_COL"+StrZero(i,2)
					cCondicao += &(cNome)
				Next
				If Empty(cCondicao)
					lWrite := .f.
				Else
					lWrite := .t.
					For i:= 1 to Len(cCondicao)
						cPos := Substr(cCondicao,i,1)
						If !Empty(cPos)
							If !(Substr(cCodVar,i,1) == cPos)
								lWrite := .f.
								Exit
							Endif
						Endif
					Next
				EndIf
				If lWrite
					DbSelectArea("SG1")
					dbSetOrder(1)
					dbSeek(xFilial("SG1")+cCod+SG4->G4_CODIGO+"ZZZ",.T.)
					dbSkip(-1)
					If SG1->(G1_FILIAL+G1_COD+G1_COMP) == xFilial("SG1")+cCod+SG4->G4_CODIGO
						cTRT := Soma1(SG1->G1_TRT)
					Else
						cTRT := Space(TamSX3("G1_TRT")[1])
					EndIf
					RecLock("SG1",.t.)
					Replace G1_FILIAL with xFilial()
					Replace G1_COD    with cCod
					Replace G1_COMP   with SG4->G4_CODIGO
					Replace G1_QUANT  with SG4->G4_QUANT
					Replace G1_PERDA  with SG4->G4_PERDA
					Replace G1_INI    with dDataBase
					Replace G1_FIM    with CtoD("31/12/49","ddmmyy")
					Replace G1_FIXVAR with SG4->G4_TIPO
					Replace G1_TRT		with cTRT
					MsUnLock()
					//Ŀ
					// Gerar roteiro de operacoes.                                  
					//
					GeraRot(cPrdPadrao,cRotPadrao,cCod)
					dbSelectArea("SG4")
					nSavRec := Recno()
					cSeekCod := SG4->G4_CODIGO
					cFixSeek:= Substr(cSeekCod,1,nLenFix)
					dbSeek(xFilial()+cFixSeek)
					If Found()
						GeraSele(cSeekCod)
					Endif
					dbGoTo(nSavRec)	
				Endif
			Endif
			DbSkip()
		End
	End Transaction
Endif

/*


Ŀ
Funo     GeraRot   Autor  Jose Lucas             Data  11.10.93 
Ĵ
Descrio  Gera Roteiro de Opreacoes baseado em Roteiro Padrao.       
Ĵ
Sintaxe    GeraRot(ExpC1,ExpC2)                                       
Ĵ
Parametros ExpC1 = Codigo do Roteiro/Grupo Padro                     
           ExpC2 = Codigo do Produto                                  
Ĵ
 Uso       MATA298                                                    
ٱ


*/
Static Function GeraRot(cPrdPadrao,cRotPadrao,cProduto)
LOCAL nSavRecno := RecNo(), cSavArea := Alias()
LOCAL aRoteiro := {},nxi

If Empty(cPrdPadrao) .Or. Empty(cRotPadrao)
	Return Nil
EndIf

dbSelectArea("SG2")
If dbSeek(xFilial()+cPrdPadrao+cRotPadrao)
	//Ŀ
	// Le registros do Roteiro Padrao.         		                 
	//
	While !Eof() .And. G2_FILIAL+G2_PRODUTO+G2_CODIGO == xFilial()+cPrdPadrao+cRotPadrao
		AADD(aRoteiro,{ G2_FILIAL ,G2_PRODUTO,G2_OPERAC ,G2_FERRAM ,;
			G2_DESCRI ,G2_LINHAPR,G2_LOTEPAD,G2_MAOOBRA,;
			G2_RECURSO,G2_SETUP  ,G2_TEMPAD ,G2_TEMPDES,;
			G2_TEMPSOB,G2_TPOPER })
		dbSkip()
	End
	//Ŀ
	// Inclui novos registros baseados no Roteiro Padrao.           
	//
	Begin Transaction
		For nxi := 1 To Len(aRoteiro)
			dbSeek(xFilial()+cProduto+cPrdPadrao+aRoteiro[nxi,03])
			If !Found()
				RecLock("SG2",.T.)
				Replace G2_FILIAL With xFilial(),G2_CODIGO  With cRotPadrao,;
					G2_PRODUTO With cProduto,G2_OPERAC  With aRoteiro[nxi,03],;
					G2_FERRAM With aRoteiro[nxi,04],G2_DESCRI  With aRoteiro[nxi,05],;
					G2_LINHAPR With aRoteiro[nxi,06],G2_LOTEPAD With aRoteiro[nxi,07],;
					G2_MAOOBRA With aRoteiro[nxi,08],G2_RECURSO With aRoteiro[nxi,09],;
					G2_SETUP With aRoteiro[nxi,10],G2_TEMPAD  With aRoteiro[nxi,11],;
					G2_TEMPDES With aRoteiro[nxi,12],G2_TEMPSOB With aRoteiro[nxi,13],;
					G2_TPOPER With aRoteiro[nxi,14]
				MsUnLock()
			EndIf	
		Next nxi
	End Transaction
EndIf	
dbSelectArea(cSavArea)
dbGoTo(nSavRecno)
Return Nil

/*


Ŀ
Funo    A298LstLog Autor Rodrigo de A. Sartorio  Data  06.11.96 
Ĵ
Descrio  Lista Relatorio contendo itens que nao tem seletividade.   
Ĵ
Sintaxe    A298LstLog()                                               
Ĵ
 Uso       MATA298                                                    
ٱ


*/
Static Function A298LstLog()
LOCAL cTitulo	:=STR0010	//"PRODUTOS QUE NAO POSSUEM SELETIVIDADE"
LOCAL cDesc1	:=STR0011	//"Este programa ir listar os produtos que apresentaram "
LOCAL cDesc2	:=STR0012	//"divergncias, pois esto cadastrados em pedidos de venda,"
LOCAL cDesc3	:=STR0013	//"porm no tem Composio Seletiva cadastrada."
LOCAL wnrel		:="MATA298"
LOCAL cString	:="SB1"


PRIVATE cPerg		:= "      "
PRIVATE aReturn		:= {STR0014,1,STR0015, 1, 2, 1, "",1 }	//"Zebrado"###"Administracao"
PRIVATE nLastKey	:= 0
nOpc				:= 2
nOpcA				:= 2
wnRel				:= SetPrint(cString,wnrel,cPerg,cTitulo,cDesc1,cDesc2,cDesc3,.F.,"",,,,.F.)

If nLastKey = 27
	Return
Endif

SetDefault(aReturn,cString)

If nLastKey = 27
	Return
Endif


RptStatus({|lEnd| A298Imp(@lEnd,ctitulo,wnRel)},ctitulo)


Return .T.

/*


Ŀ
Funo     A298Imp   Autor Rodrigo de A. Sartorio  Data  06/11/96 
Ĵ
Descrio  Envia para funcao que faz a impressao do Log.	           
Ĵ
 Uso       MATA298                                                    
ٱ


*/
Static Function A298Imp(lEnd,ctitulo,wnRel)
Local cCabec1  :=STR0016	//"PEDIDO      ITEM PEDIDO     PRODUTO           COD    "
Local cCabec2  :=STR0017	//"DE VENDA    DE VENDA                          FIXO   "
Local cTamanho :="P"
Local cNomeProg:="MATA298"
Local cbtxt    := SPACE(10)
Local cbcont   := 0
Local i,j
li       := 80
m_pag    := 1

For i:=1	to Len(aLog)
	For j:=1 to Len(aLog[i])
		If Li > 62
			cabec(cTitulo,cCabec1,cCabec2,cNomeProg,cTamanho)
		EndIf
		@ li,00 PSay aLog[i,j,1]
		@ li,12 PSay aLog[i,j,2]
		@ li,28 PSay aLog[i,j,3]
		@ li,46 PSay aLog[i,j,4]
		li++
	Next j
Next i
IF li != 80
	li++
	roda(cbcont,cbtxt,"P")
EndIF

If aReturn[5] = 1
	Set Printer TO
	dbCommitAll()
	ourspool(wnrel)
Endif

Return (.T.)

/*


Ŀ
Funo     IniRot    Autor  Rodrigo de A. Sartorio Data  25/07/97 
Ĵ
Descrio  Inicializa o campo de Roteiro de Operacoes                 
Ĵ
 Uso       MATA298                                                    
ٱ


*/
Static Function IniRot(cPrdPadrao,cRotPadrao)
LOCAL cAlias:=Alias(),nRecno:=Recno(),nOrder:=IndexOrd()
dbSelectArea("SB1")
dbSetOrder(1)
If dbSeek(xFilial()+cPrdPadrao)
	cRotPadrao:=B1_OPERPAD
EndIf
dbSelectArea(cAlias)
dbSetOrder(nOrder)
dbGoto(nRecno)
RETURN .T.

/*/


Ŀ
Programa  MenuDef    Autor  Fabio Alves Silva      Data 04/10/2006
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          		1 - Pesquisa e Posiciona em um Banco de Dados     
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/              
Static Function MenuDef()     
Private aRotina	:= { {STR0001,"AxPesqui"  , 0 , 1,0,.F.},;	//"Pesquisar"
							{STR0002,"A298Gera"  , 0 , 2,0,nil},;	//"Gerar"
							{STR0003,"A298Inclui", 0 , 3,0,nil},;	//"Incluir"
							{STR0004,"A298Altera", 0 , 4,0,nil},;	//"Alterar"
							{STR0005,"A298Deleta", 0 , 5,3,nil}}	//"Excluir" 
If ExistBlock ("MTA298MNU")
	ExecBlock  ("MTA298MNU",.F.,.F.)							    
Endif	
return (aRotina)