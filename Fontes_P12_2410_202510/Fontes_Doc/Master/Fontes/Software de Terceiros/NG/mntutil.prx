#INCLUDE "MNTUTIL.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "TOPCONN.CH"
#INCLUDE "RWMAKE.CH"
#INCLUDE "Fileio.ch"
#INCLUDE "tbicONn.ch"
#INCLUDE "DBINFO.CH"
#INCLUDE "MSGRAPHI.CH"

Static cQryDescnt
Static cQryItemSA

//---------------------------------------------------------------------
/*/{Protheus.doc} GERAOP
Programa de Geracao de Ordem de Producao c/Acessorios

@author NG Informática
@since  12/06/98
@param cProd -> Cód. Produto
		nQtd  -> Quantidade
		cOs   -> Cód. da O.S
		dIni  -> Data Início
		dFim  -> Data Fim

@return NIL
@source SIGAMNT

/*/
//---------------------------------------------------------------------
Function GERAOP(cPROD,nQTD,cOS,dINI,dFIM,cVLOC)

	Local nX        := 0
	Local lGEROPINC := .F.
	Local INCLUIOLD := .F.
	Local nParCom   := GetMV("MV_NGMNTSC")

	Private aRetorOpc := {} // Usado no MATA650

	Qtdes := {}
	nQTD  := If(nQTD <= 0,1,nQTD)

	If Type("Inclui") <> "U"
		lGEROPINC := .T.
		INCLUIOLD := Inclui
	EndIf

	SB1->(dbSeek(xFilial("SB1")+cPROD))

	cNumOp   := SubSTr(cOS,1,6)
	cItemOp  := SubSTr(cOS,7,2)
	cSeqC2   := SubSTr(cOS,9,3)
	cPROD    := PADR(cPROD, Len(SB1->B1_COD))
	cLocal   := If(cVLOC == NIL .Or. Empty(cVLOC),SB1->B1_LOCPAD,cVLOC)
	nSeqC2   := 0
	Inclui   := .F.
	cROTEIRO := " "
	LMTA650I := .F.
	LPROJ711 := .F.

	//Verifica se o produto tem estrutura.
	dbSelectArea("SG1")
	lESTRU   := dbSeek(xFilial("SG1")+ cPROD)
	aQtdes   := CalcLote(cPROD, nQTD,"F")
	cItemGrd := Space(Len(SC2->C2_ITEMGRD))
	cGrade   := Space(Len(SC2->C2_GRADE))

	Pergunte("MTA650",.F.)
	MV_PAR06 := nParCom
	For nX := 1 TO Len(aQtdes)
		nSeqC2 := nSeqC2+1
		cOBS   := Space(10)
		A650GeraC2(cPROD,aQtdes[nX],dDATABASE,dINI,dFIM,NIL,"000",NIL,.F.,.F.,cLOCAL,,,,,cNumOp,cItemOp,cSeqc2,cRoteiro)
		MsUnLock()
	Next nX

	//Retornado o valor da variavel inclui, pois ocorre cONfliTO de variavel quando
	//e incluido uma nota fiscal de entrada no MATA103, ONde substitui o cabecalho de
	//nota fiscal anteriormente incluida ficando SD1 sem cabecalho da nota fiscal (SF1)
	If lGEROPINC
		Inclui := INCLUIOLD
	EndIf

Return NIL

//---------------------------------------------------------------------
/*/{Protheus.doc} A650GeraC1
Gera Solic. para produTO na quantidade informada via param.

@author Claudinei M. Benzi
@since  10.01.92
@param cProd -> Cód. ProduTO
		nQtd  -> Quantidade
		cOs   -> Cód. da O.S
		dIni  -> Data Início
		dFim  -> Data Fim

@return NIL
@use SIGAMNT

/*/
//---------------------------------------------------------------------
Function A330GeraC1(cProduTO,nQuant,cOp,dEntrega,cCpoProj,nx,nNecessid,cLocal)
Local lProj		  := .F.
Local cChaveSC3	  := ""
Local lQuant	  := .F.
Local lData		  := .F.
Local nQuantBaixa := 0
Private LMT650C1  := .F.

//Verifica se a rotina esta sendo chamada da Proj.EsTOques
If cCpoProj != Nil
   lProj := .T.
EndIf

//Verifica se o produTO tem cONtraTO de parceria
//Se nao, gera solic.Compra; Se sim, gera AuTOr. de Entrega
If SB1->B1_CONTRAT != "S"
   //Verifica se as SC's/CP's devem ser aglutinados ou se j devems ser gerados.
   A650GravC1(cProduTO,nQuant,cOp,dEntrega,cCpoProj,nx,nNecessid,,,cLocal, "F")
Else
   dbSelectArea("SC3")
   dbSeTOrder(5)
   If MatPesqCtr(.T.,SB1->B1_COD,SB1->B1_PROC,SB1->B1_LOJPROC,@cChaveSC3)
      While !EoF() .And. &(cChaveSC3)
         lData  := .F.
         lQuant := .F.
         lData  := !(IIF(lProj,aPeriodos[Val(a650DTOPer(dEntrega))],dEntrega) >= SC3->C3_DATPRI  .And. ;
         IIF(lProj,aPeriodos[Val(a650DTOPer(dEntrega))],dEntrega) <= SC3->C3_DATPRF)
         lQuant := (SC3->C3_QUANT <= SC3->C3_QUJE .And. SC3->C3_ENCER =="E")
         //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
         //³ Nao CONsidera CONtraTOs de Parceria Encerrados ou fora da data³
         //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
         If lData .Or. lQuant
            dbSkip()
            Loop
         EndIf
         Exit
      End
   EndIf
   If EoF() .Or. lData .Or. lQuant
      //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
      //³ Verifica se as SC's/CP's devem ser aglutinados ou se j     ³
      //³ devems ser gerados.                                        ³
      //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      A650GravC1(cProduTO,nQuant,cOp,dEntrega,cCpoProj,nx,nNecessid,.T.,,cLocal, "F")
   Else
      //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
      //³ Gera A.E. somente do saldo dispONivel no CONtraTO          ³
      //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      nQuantBaixa := If((SC3->C3_QUANT-SC3->C3_QUJE) <= nQuant,(SC3->C3_QUANT-SC3->C3_QUJE),nQuant)
      A650GravC7(cProduTO,nQuantBaixa,cOp,dEntrega,cCpoProj,nx,nNecessid,"F",SC3->(Recno()))
      //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
      //³ Atualiza Saldo de Quantidade Ja entregue no SC3            ³
      //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      dbSelectArea("SC3")
      RecLock("SC3",.F.)
      Replace C3_QUJE With C3_QUJE + nQuantBaixa
      If C3_QUANT <= C3_QUJE
         Replace C3_ENCER With "E"
      EndIf
      MsUnLock()
      //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
      //³ Gera S.C. da quantidade que nao foi atendida pelo CONtraTO ³
      //³ de Parceria                                                ³
      //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      If nQuantBaixa < nQuant
         A650GravC1(cProduTO,nQuant - nQuantBaixa,cOp,dEntrega,cCpoProj,nx,nNecessid,.T.,,cLocal, "F")
      EndIf
   EndIf
EndIf
Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NEXTOSMAN ³ AuTOr ³ Paulo Pego           ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao reTOrnar o Proximo numero de OS de manutencao       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ GENRICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NEXTOSMAN()

	Local nRecno, nOrd

	nRecno := STJ->(Recno())
	nOrd   := STJ->(IndexOrd())

	STJ->(dbSeTOrder(1))
	STS->(dbSeTOrder(1))

	cNUMOS := GetSxENum("STJ", "TJ_ORDEM")
	cONfirmSX8()

Return cNUMOS

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NEXTOSACOM³ AuTOr ³ Paulo Pego           ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao reTOrnar o Proximo numero de OS de acompanhamenTO   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ GENRICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NEXTOSACOM()
Local nRecno, nOrd, nRet, nRet2

nRecno := STP->(Recno())
nOrd   := STP->(IndexOrd())

STP->(dbSeTOrder(1))
STP->(dbSeek(xFilial('STP') + "999999"))

nRet := 1

If STP->(EoF())
   STP->(dbSkip(-1))
EndIf

While !EoF() .And. STP->TP_FILIAL == xFilial("STP") .And. !STP->(BoF())
   If STP->TP_SITUACA == "L"
      nRet := Val(STP->TP_ORDEM) + 1
      Exit
   EndIf

   STP->(dbSkip(-1))
End

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica o arquivo de HisTOrico - STW                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
STW->(dbSeTOrder(3))
STW->(dbSeek(xFilial('STW') + "999999"))

nRet2 := 1

If STW->(EoF())
   STW->(dbSkip(-1))
EndIf

While !EoF() .And. STW->TW_FILIAL == xFilial("STW") .And. !STW->(BoF())
   If STW->TW_SITUACA != "C"
      nRet2 := Val(STW->TW_ORDEM) + 1
      Exit
   EndIf
   STW->(dbSkip(-1))
End

STW->(dbSeTOrder(1))

STP->(dbSeTOrder(nOrd))
STP->(dbGoTO(nRecno))

nRET := MAX(nRet, nRet2)

Return Strzero(nRET, 06)

//---------------------------------------------------------------------------
/*/{Protheus.doc} FAMID08
Verifica se o código da familia ou tipo modelo digitado existe no ( TP9...)
@author Inacio Luiz Kolling
@param cFamPa , String, Familia enviado para valicao
@param cTipMod, String, Tipo Modelo enviado para valicao
/*/
//---------------------------------------------------------------------------
Function FAMID08(cFamPa, cTipMod)

Local lRet := .T.

Default cFamPa  := ''
Default cTipMod := ''

dbSelectArea("TP9")
dbSeTOrder(1) //TP9_FILIAL+TP9_CODFAM+TP9_TIPMOD

If Empty( cTipMod )

	If !MsSeek( FwxFilial( "TP9" ) + cFamPa )

		Help(" ",1,"NAOFAMIPAD")

		lRet := .F.

	EndIf

Else

	If !MsSeek( FwxFilial("TP9") + cFamPa + cTipMod )

		Help("", 1, STR0074, Nil,STR1488 , 1, 0) //"Atenção" # "Tipo Modelo não cadastrado na tabela de bens padrão"

	   	lRet := .F.

	EndIf

EndIf

Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³FAMID09   ³ AuTOr ³ Inacio Luiz Kolling   ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o c¢digo da familia digitado existe no ( TPF...)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Implantacao do SIGAMNT ( RDMAKE MNTAD09 )                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FAMID09(nfami)
dbSelectArea("TPF")
dbSeTOrder(1)
If !dbSeek(xFilial("TPF")+nfami)
   Help(" ",1,"NAOBEMPADR")
   Return .F.
EndIf
Return .T.
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GRUPD08   ³ AuTOr ³ Inacio Luiz Kolling   ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o c¢digo do grupo ja foi usado na importacao    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Implantacao do SIGAMNT ( RDMAKE MNTAD08)                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function grupd08(ngrupo)
Local nachou := .F.
dbSelectArea("SN1")
dbGoTOp()
While !EoF() .And. !nachou
   If SN1->N1_GRUPO == ngrupo
      nachou := .T.
      Exit
   EndIf
   dbSkip()
End
If !nachou
   Help(" ",1,"NAOEXGRUPO")
   Return .F.
EndIf
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³BEMD08    ³ AuTOr ³ Inacio Luiz Kolling   ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o c¢digo do bem digitado j  existe no ( TP9... )³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Implantacao do SIGAMNT ( RDMAKE MNTAD08 )                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function BEMD08(ncodbem)
dbSelectArea("ST9")
dbSeTOrder(1)
If dbSeek(xFilial("ST9")+ncodbem)
   Help(" ",1,"JAEXBEMPAD")
   Return .F.
EndIf
Return .T.
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MOSTRASN1 ³ AuTOr ³                       ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Mostra os dados do ativo fixo ( SN1 )                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MOSTRASN1()

Local bCampo, cSaveMenuh, nCnt
Local oEnchoice, nSavRec

Local LVar01  := 1, nLinhas := 0
Local GetList := {}, i := 0

// Dimensão da tela e seus compONentes
Local aSize    := MsAdvSize(,.F.,430)
Local aObjects := {{100, 100, .T., .T.}}
Local aInfo    := {aSize[1], aSize[2], aSize[3], aSize[4], 0, 0}
Local aPosObj  := MsObjSize(aInfo, aObjects, .T.)

Private oDlg, oGet, cCodAnt
Private aTELA[0][0], aGETS[0], aHeader[0], nUsado := 0

Private aRotina := { { STR0001 ,"AxPesqui" , 0 , 1},;	//"Pesquisar"
                     { STR0002 ,"NGCAD01"   , 0 , 2},;	//"Visualizar"
                     { STR0003 ,"NGCAD01"   , 0 , 3},;	//"Incluir"
                     { STR0004 ,"NGCAD01"   , 0 , 4},;	//"Alterar"
                     { STR0005 ,"MOSTRASN1" , 0 , 5} }	//"Importa"

cAlias := 'SN1'
nReg   := Recno()
nOpc   := 5
altera := .F.
inclui := .F.

dbSelectArea( cAlias )
nSavRec := Recno()
For i := 1 TO FCount()
   x   := "M->" + FieldName(i)
   &x. := FieldGet(i)
Next i

cCadastro := STR0010 //"Cadastro do Ativo Fixo    ( ATENCAO !!!  Este Bem ja existe no ST9, QuanTO a Importacao )"
nOpca     := 0


DEFINE MsDialog oDlg TITLE cCadastro FROM aSize[7],5 TO aSize[6],aSize[5] Of oMainWnd Pixel



oPanel := TPanel():New(0,0,,oDlg,,,,,,0,0,.F.,.F.)
oPanel:Align := CONTROL_ALIGN_ALLCLIENT

oEnchoice := Msmget():New( cAlias, nReg, nOpc, , , , ,aPosObj[1], , , , , , oPanel)
oEnchoice:oBox:Align := CONTROL_ALIGN_ALLCLIENT

ACTIVATE MsDialog oDlg ON INIT EnchoiceBar(oDlg,{|| nOpca := 1, oDlg:End() },{|| oDlg:End() })

If nOpca == 1
   nOpca := 2
EndIf

dbSelectArea( cAlias )

Return nOpca
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ PROXMANU ³ AuTOr ³ NG INFORMATICA         ³ Data ³   /  /   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula a data da proxima manutencao do bem                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Arg1 = Codigo do bem                                        ³±±
±±³          ³ Arg2 = Codigo do servico                                    ³±±
±±³          ³ Arg3 = Numero da sequencia                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SIGAMNT - MANUTENCAO                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function PROXMANU(VCODBEM,VSERVICO,VSEQ,nPERFIXO, lRestArea)
Local _DTPROX := CTOd(' /  /  ') , nINTEI := 0,nRESTO := 0
Local nPOSPO  := 0, cVALOR, nINCDAT := 0,nDDIAS
Local VSEQUENC := If(ValType(VSEQ) = "C",VSEQ,Str(VSEQ,3))

Local aArea    := GetArea()
Local aAreaSTF := STF->(GetArea())

Default lRestArea := .F.

If NGIFdbSeek("STF",VCODBEM+VSERVICO+VSEQUENC,1)
   NGIFdbSeek("ST9",VCODBEM,1)

   nIncMANL := STF->TF_INENMAN
   If STF->TF_TIPACOM == "C" .Or. STF->TF_TIPACOM == "P"
      nDDIAS := ((STF->TF_CONMANU + nIncMANL) - ST9->T9_CONTACU) / ST9->T9_VARDIA
      nINTEI  := Int(nDDIAS)
      nRESTO  := If(nINTEI < 0,nDDIAS*-1,nDDIAS) - If(nINTEI < 0,nINTEI*-1,nINTEI)

      If nRESTO > 0
         cVALOR := Alltrim(Str(nRESTO))
         nPOSPO := At('.',cVALOR)
      EndIf

      nRESTO := If (nPOSPO > 0,Val(Substr(cVALOR,nPOSPO+1,1)),0)
      nINCDAT := If(nRESTO > 5,If(nINTEI <= 0,nINTEI-1,nINTEI+1),nINTEI)
      _DTPROX := ST9->T9_DTULTAC + nINCDAT

   ElseIf STF->TF_TIPACOM = "S"

   	TPE->(dbSeek(xFilial("TPE")+vcodbem))
      nDDIAS := ((STF->TF_CONMANU + nIncMANL) - TPE->TPE_CONTAC) / TPE->TPE_VARDIA
      nINTEI  := Int(nDDIAS)
      nRESTO  := If(nINTEI < 0,nDDIAS*-1,nDDIAS) - If(nINTEI < 0,nINTEI*-1,nINTEI)

      If nRESTO > 0
         cVALOR := Alltrim(Str(nRESTO))
         nPOSPO := At('.',cVALOR)
      EndIf

      nRESTO := If (nPOSPO > 0,Val(Substr(cVALOR,nPOSPO+1,1)),0)
      nINCDAT := If(nRESTO > 5,If(nINTEI <= 0,nINTEI-1,nINTEI+1),nINTEI)
      _DTPROX := ST9->T9_DTULTAC + nINCDAT
   ElseIf STF->TF_TIPACOM = "F"
      nULTCON := If(STF->(FieldPos("TF_CONPREV")) == 0,STF->TF_CONMANU,STF->TF_CONPREV)
      dbSelectArea("CTT")
      If CTT->(FieldPos("CTT_PERCFI")) > 0    //Campo utilizado pela Galvao Engenharia
         cCENTROCB := NGSEEK("ST9",STF->TF_CODBEM,1,"T9_CCUSTO")
         nPERCCUST := NGSEEK("CTT",cCENTROCB,1,"CTT_PERCFI")
         If nPERCCUST  > 0
            nPERCCUST := nPERCCUST / 100
            nINCPERC  := nIncMANL * nPERCCUST
         Else
            nINCPERC := nIncMANL * nPERFIXO  // IncremenTO da manutencao com percentual
         EndIf
      Else
         nINCPERC := nIncMANL * nPERFIXO  // IncremenTO da manutencao com percentual
      EndIf

      nVEZMANU := Int(nULTCON / nIncMANL) // Numero de vezes que foi feiTO a manutencao
      nCONTFIX := nVEZMANU * nIncMANL     // CONtador fixo exaTO
      nCONTPAS := nULTCON - nCONTFIX             // Quantidade que passou da manutenção fixa

      If nCONTPAS < nINCPERC .Or. nINCPERC == 0
         _CONPROX := nCONTFIX + nIncMANL
      Else
         _CONPROX := nCONTFIX + nIncMANL
         _CONPROX += nIncMANL
      EndIf

      nDDIAS := (_CONPROX - ST9->T9_CONTACU) / ST9->T9_VARDIA
      nINTEI := Int(nDDIAS)
      nRESTO := If(nINTEI < 0,nDDIAS*-1,nDDIAS) - If(nINTEI < 0,nINTEI*-1,nINTEI)

      If nRESTO > 0
         cVALOR := Alltrim(Str(nRESTO))
         nPOSPO := At('.',cVALOR)
      EndIf

      nRESTO := If (nPOSPO > 0,Val(Substr(cVALOR,nPOSPO+1,1)),0)
      nINCDAT := If(nRESTO > 5,If(nINTEI <= 0,nINTEI-1,nINTEI+1),nINTEI)
       _DTPROX := ST9->T9_DTULTAC + nINCDAT
   ElseIF STF->TF_TIPACOM $ "T/A"
      _DTPROX := STF->TF_DTULTMA+NGINCMANUNI(STF->TF_CODBEM,STF->TF_SERVICO,STF->TF_SEQRELA)
   EndIf
EndIf

If lRestArea
	RestArea(aArea)
	RestArea(aAreaSTF)
EndIf

Return _DTPROX

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGMINCSUBS³ AuTOr ³In cio Luiz Kolling    ³ Data ³16/07/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Busca incremenTO a ser aplicado para o calculo da data da   ³±±
±±³          ³proxima manutencao quando tem o campo de substituicao (STF) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³VCODBEM  - Codigo do bem da manutencao        - ObrigaTOrio ³±±
±±³          ³VSERVICO - Codigo do servico da manutencao    - ObrigaTOrio ³±±
±±³          ³VSEQ     - Sequencia da manutencao            - ObrigaTOrio ³±±
±±³          ³nIncMANL - IncremenTO da manutencao           - ObrigaTOrio ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ReTOrna   ³nMainM   - IncremenTO a ser aplicado                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGMINCSUBS(VCODBEM,VSERVICO,VSEQ,nIncMANL)
Local nMaInM := nIncMANL,aAreaAntS := GetArea(),nRegUSTFL,nMTInC := 0
Local cSeqSu := Space(Len(STF->TF_SEQRELA)),nRegLSTF := 0,nIncVal := 0,nQtqOsF := 0
dbSelectArea('STF')
nRegUSTFL := Recno()
If NGCADICBASE("TF_SUBSTIT","A","STF",.F.)  .And.  NGCADICBASE("TF_MARGEM","A","STF",.F.)  // cONsistência especifica
   If NGIFdbSeek("STF",VCODBEM+VSERVICO+VSEQ,1)
      nRegLSTF := Recno()
      If NGIFdbSeek("STF",VCODBEM+VSERVICO,1)
         While !EoF() .And. STF->TF_FILIAL = Xfilial("STF") .And. STF->TF_CODBEM = VCODBEM;
            .And. STF->TF_SERVICO = VSERVICO
            If VSEQ $ STF->TF_SUBSTIT
               cSeqSu  := STF->TF_SEQRELA
               nIncVal := STF->TF_INENMAN
               nQtqOsF := STF->TF_QUANTOS
               Exit
            EndIf
            dbSkip()
         End
         If !Empty(cSeqSu)
            dbSelectArea('STF')
            dbGoTO(nRegLSTF)
            nMTInC := nIncVal
         EndIf
      EndIf
   EndIf
EndIf
dbSelectArea('STF')
dbGoTO(nRegUSTFL)
RestArea(aAreaAntS)
Return If(!Empty(nMTInC),nMTInC,nMaInM)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CALVARDIA³ AuTOr ³ NG INFORMATICA         ³ Data ³   /  /   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula a variacao dia do bem                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Arg1 = Codigo do bem                                        ³±±
±±³          ³ Arg2 = Data de leitura                                      ³±±
±±³          ³ Arg3 = Valor do cONtador                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SIGAMNT - MANUTENCAO                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CALVARDIA(cCODBEM,dDATALEI,nCONTADOR)
Local nVARDIA := 0, aVARDIA := {}

nMAX := GETMV("MV_VARDIA")

dbSelectArea('STP')
dbSeTOrder(5)
dbSeek(xFilial('STP')+cCODBEM+DTOS(dDATALEI),.T.)
If EoF() .Or. STP->TP_CODBEM <> ST9->T9_CODBEM
   dbSkip(-1)
EndIf

While !BoF() .And. STP->TP_CODBEM == cCODBEM .And. nMAX > 0
   If !Empty(STP->TP_DTLEITU)
      aadd(aVARDIA,{STP->TP_DTLEITU,STP->TP_ACUMCON,STP->TP_VIRACON})
      nMAX--
   EndIf
   dbSkip(-1)
End

dbSelectArea('STW')
dbSeTOrder(5)
dbSeek(xFilial('STW')+cCODBEM+DTOS(dDATALEI),.T.)
If EoF() .Or. STW->TW_CODBEM <> ST9->T9_CODBEM
   dbSkip(-1)
EndIf

While !bof() .And. STW->TW_CODBEM == cCODBEM .And. nMAX > 0
   If !Empty(STW->TW_DTLEITU)
      aadd(aVARDIA ,{STW->TW_DTLEITU,STW->TW_ACUMCON,STW->TW_VIRACON})
      nMAX--
   EndIf
   dbSkip(-1)
End

If Len(aVARDIA) > 0

   aVARDIA := aSort(aVARDIA,,,{|x,y| x[1] < y[1]})

   nmaiorvlr := If (aVARDIA[Len(aVARDIA)][3] = 0, aVARDIA[Len(aVARDIA)][2] , aVARDIA[Len(aVARDIA)][2] + 999999999 * aVARDIA[Len(aVARDIA)][3])
   nmenorvlr := If (aVARDIA[1][3] = 0, aVARDIA[1][2] , aVARDIA[1][2] + 999999999 * aVARDIA[1][3] )

   nVARDIA := Round ((nmaiorvlr - nmenorvlr ) / (aVARDIA[Len(aVARDIA)][1] - aVARDIA[1][1]),0)

EndIf

// ATUALIZA A NOVA POSICAO DO CONTADOR E ACUMULADOR

dbSelectArea('ST9')
dbSeTOrder(1)
If dbSeek(xFilial('ST9')+cCODBEM)

   RecLock("ST9",.F.)
   If nVARDIA > 0
      ST9->T9_VARDIA  := nVARDIA
   EndIf

	If ST9->T9_UNGARAN == 'K'
		nINCREM := ST9->T9_PRGARAN / ST9->T9_VARDIA
		ST9->T9_DTGARAN := NGPROXMDT(ST9->T9_DTCOMPR,'D',nINCREM)
	EndIf

   ST9->T9_DTULTAC := dDATALEI
   ST9->T9_POSCONT := nCONTADOR

   nacumul := ST9->T9_CONTACU + nCONTADOR

   If nacumul >= 999999999
      ST9->T9_VIRADAS := ST9->T9_VIRADAS + 1
      ST9->T9_CONTACU := nacumul - ST9->T9_CONTACU
   Else
      ST9->T9_CONTACU := ST9->T9_CONTACU + nCONTADOR
   EndIf
   MsUnLock("ST9")
EndIf

Return nVARDIA

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCHKBEM  ³ AuTOr ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ CONsite so campo DE BEM                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCHKBEM(cCODBEM,cBEMRET)
M->TJ_HORACO1 := Space(Len(M->TJ_HORACO1))
M->TJ_HORACO2 := Space(Len(M->TJ_HORACO2))
M->TJ_POSCONT := 0
m->TJ_POSCON2 := 0
cBEMRET       := Space(Len(cCODBEM))
lRefresh      := .T.

If !NGBEMATIV(cCODBEM)
   Return .F.
EndIf
TipoAcom  := .F.
TIPOACOM2 := .F.

cTIPOCON := " "
cBEMRET  := cCODBEM
cTIPOCON := NGSEEK("ST9",cBEMRET,1,"T9_TEMCONT")
TIPOACOM := If(cTIPOCON = "S",.T.,.F.)

dbSelectArea("TPE")
dbSeTOrder(01)
If dbSeek(xFilial("TPE")+cBEMRET)
   TIPOACOM2 := .T.
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGPROXMDT ³ AuTOr ³ NG INFORMATICA         ³ Data ³   /  /   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula a data da proxima: (manutencao,plano,data de        ³±±
±±³          ³ garantia do bem) baseado nos parametros abaixo.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Arg1 = Data da ultima manutencao                            ³±±
±±³          ³ Arg2 = Tipo (D=dia ,S=semana ,M=mes ,A=ano                  ³±±
±±³          ³ Arg3 = Valor do incremenTO                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SIGAMNT - MANUTENCAO                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGPROXMDT(Ddata,Ctipo,NincremenTO)
Local Dtprox := CTOD(' /  /  ')
Local i := 0

If (Ddata == Nil) .Or. Empty(Ddata)
	Ddata := dDataBase
EndIf

If Ctipo == "D"
   Dtprox := Ddata + NincremenTO

ElseIf Ctipo == "S"
   Dtprox := Ddata + (NincremenTO * 7)

ElseIf Ctipo == "M"
   Nmes := MONth(Ddata)
   Nano := YEAR(Ddata)
   Ndia := day(Ddata)
   For i := 1 TO NincremenTO

      Nmes := Nmes + 1

      If Nmes > 12
         Nano := Nano + 1
         Nmes := 1
      EndIf
   Next

   Dtprox := CTOD(Strzero(Ndia,2)+'/'+Strzero(Nmes,2)+'/'+Strzero(Nano,4))

   While Empty(Dtprox)
      Ndia--
      Dtprox := CTOD(Strzero(Ndia,2)+'/'+Strzero(Nmes,2)+'/'+Strzero(Nano,4))
   End

ElseIf Ctipo == "A"

   Nmes := MONth(Ddata)
   Nano := YEAR(Ddata)+ NincremenTO
   Ndia := day(Ddata)

   Dtprox := CTOD(Strzero(Ndia,2)+'/'+Strzero(Nmes,2)+'/'+Strzero(Nano,4))

   While Empty(Dtprox)

      Ndia--
      Dtprox := CTOD(Strzero(Ndia,2)+'/'+Strzero(Nmes,2)+'/'+Strzero(Nano,4))

   End
EndIf
Return Dtprox
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³  VSAY    ³ AuTOr ³ NG INFORMATICA         ³ Data ³   /  /   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Arg1 = Nome da variavel                                     ³±±
±±³          ³ Arg2 = Valor da variavel                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SIGAMNT - MANUTENCAO                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function VSAY(ARG1,ARG2)
Local cRet
Local lGFrota

If ARG1 == "01"                       //TG_NOMECOD
   If STG->TG_TIPOREG == "M"
      cRET := ST1->( VDISP(Substr(STG->TG_CODIGO,1,Len(ST1->T1_CODFUNC)),"T1_NOME") )
   ElseIf STG->TG_TIPOREG == "T"
      cRET := SA2->( VDISP(Substr(STG->TG_CODIGO,1,Len(SA2->A2_COD)),"A2_NOME") )
   ElseIf STG->TG_TIPOREG == "P"
      cRET := SB1->( VDISP(STG->TG_CODIGO,"B1_DESC") )
   ElseIf STG->TG_TIPOREG == "F"
      cRET := SH4->( VDISP(Substr(STG->TG_CODIGO,1,Len(SH4->H4_CODIGO)),"H4_DESCRI") )
   Else
      cRET := ST0->( VDISP(Substr(STG->TG_CODIGO,1,Len(ST0->T0_ESPECIA)),"T0_NOME") )
   EndIf

ElseIf ARG1 == "02"                       //TG_NOMETAR
   cRET := If(Alltrim(STG->TG_TAREFA) == "0",STR0017,ST5->( VDISP( STG->TG_CODBEM + STG->TG_SERVICO + STG->TG_SEQRELA + STG->TG_TAREFA, "T5_DESCRIC") ))

ElseIf ARG1 == "03"                       //TG_NOMEBEM
   cRET := If( ST9->(dbSeek(xFilial('ST9') + m->TS_CODBEM)),st9->t9_nome, Space(Len(ST9->T9_NOME)) )

ElseIf ARG1 == "04"                       //TA_NOMTAR
	lCORRET := If(Val(STJ->TJ_PLANO) = 0,.T.,.F.)
	If Alltrim(STA->TA_TAREFA) == "0"
		cRET := STR0017
	Else
		If Val(STJ->TJ_PLANO)==0
			cRET := NGNOMETAR(STJ->TJ_CODBEM + STJ->TJ_SERVICO + STJ->TJ_SEQRELA,STA->TA_TAREFA)
		Else
			cRET := ST5->( VDISP(STJ->TJ_CODBEM + STJ->TJ_SERVICO + STJ->TJ_SEQRELA + STA->TA_TAREFA, "T5_DESCRIC",20))
		EndIf
	EndIf
ElseIf ARG1 == "05"                       //TB_NOME
   cRET := TPR->( VDISP(STB->TB_CARACTE,"TPR_NOME",TamSX3("TPR_NOME")[1]) )

ElseIf ARG1 == "06"                       //TL_NOMTAR
   aArea06  := GetArea()
   lTemlCOR := .F.
   If Type("lCORRET") <> "U"
      lCORREOL := lCORRET
      lTemlCOR := .T.
   EndIf
   lCORRET := If(Val(stj->tj_plano) = 0,.T.,.F.)
   cRet := If("0" == Alltrim(STL->TL_TAREFA),STR0017,;
            If(FindFunction("NGNOMETAR"),NGNOMETAR(STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,STL->TL_TAREFA),;
              ST5->( VDISP(STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA+STL->TL_TAREFA,"T5_DESCRIC",20))))
   If lTemlCor
      lCORRET := LCORREOL
   EndIf
   RestArea(aArea06)

ElseIf ARG1 == "07"                       //TM_NOMETAR
   cRET := If(Alltrim(STM->TM_TAREFA) == "0",STR0017,ST5->( VDISP(STM->TM_CODBEM + STM->TM_SERVICO + STM->TM_SEQRELA + STM->TM_TAREFA,"T5_DESCRIC",20)))

ElseIf ARG1 == "08"                       //TM_NOMEDEP
   cRET := If(Alltrim(STM->TM_DEPENDE) == "0",STR0017,ST5->( VDISP(STM->TM_CODBEM + STM->TM_SERVICO + STM->TM_SEQRELA + STM->TM_DEPENDE,"T5_DESCRIC",20)))

ElseIf ARG1 == '09'

	lCORRET := If(Val(STJ->TJ_PLANO) = 0,.T.,.F.)
	
	If AllTrim( STN->TN_TAREFA ) == '0'
		
		cRET := STR0017

	Else
		
		cRET := NGNOMETAR( STJ->TJ_CODBEM + STJ->TJ_SERVICO + STJ->TJ_SEQRELA, STN->TN_TAREFA )
		
	EndIf

ElseIf ARG1 == "10"                       //TQ_NOMETARE
   aArea10  := GetArea()
   lTemlCOR := .F.
   If Type("lCORRET") <> "U"
      lCORREOL := lCORRET
      lTemlCOR := .T.
   EndIf
   lCORRET := If(Val(stj->tj_plano) = 0,.T.,.F.)
   cRet := If("0" == Alltrim(STQ->TQ_TAREFA),STR0017,;
           If (FindFunction("NGNOMETAR"),NGNOMETAR(STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,STQ->TQ_TAREFA),;
              ST5->( VDISP(STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA+STQ->TQ_TAREFA,"T5_DESCRIC",20))))
   If lTemlCor
      lCORRET := LCORREOL
   EndIf
   RestArea(aArea10)

ElseIf ARG1 == "14"                       //TS_NOMEBEM
   cRET := ST9->( VDISP(STS->TS_CODBEM,"T9_NOME") )

ElseIf ARG1 == "15"                       //TT_NOMTAR
   aArea15  := GetArea()
   lTemlCOR := .F.
   If Type("lCORRET") <> "U"
      lCORREOL := lCORRET
      lTemlCOR := .T.
   EndIf
   lCORRET := If(Val(sts->ts_plano) = 0,.T.,.F.)
   cRet := If("0" == Alltrim(STT->TT_TAREFA),STR0017,;
           If (FindFunction("NGNOMETAR"),NGNOMETAR(STS->TS_CODBEM+STS->TS_SERVICO+STS->TS_SEQRELA,STT->TT_TAREFA),;
              ST5->( VDISP(STS->TS_CODBEM+STS->TS_SERVICO+STS->TS_SEQRELA+STT->TT_TAREFA,"T5_DESCRIC",20))))
   If lTemlCor
      lCORRET := LCORREOL
   EndIf
   RestArea(aArea15)

ElseIf ARG1 == "16"                       //TU_NOMETAR
   cRET := If(Alltrim(STU->TU_TAREFA) == "0",STR0017,ST5->( VDISP(STS->TS_CODBEM + STS->TS_SERVICO + STS->TS_SEQRELA + STU->TU_TAREFA,"T5_DESCRIC",20)))

ElseIf ARG1 == "17"                       //TX_NOMETARE
   cRET := If(Alltrim(STX->TX_TAREFA) == "0",STR0017,ST5->( VDISP(STS->TS_CODBEM + STS->TS_SERVICO + STS->TS_SEQRELA + STX->TX_TAREFA,"T5_DESCRIC",20)))

ElseIf ARG1 == "21"                       //TPG_NOMETA
   cRET := TP5->( VDISP(TPF->TPF_CODFAM + TPF->TPF_SERVIC + TPF->TPF_SEQREL + TPG->TPG_TAREFA,"TP5_DESCRI",20))

ElseIf ARG1 == "22"                       //TPM_NOME
   lGFrota := MNTA180FR()

   If lGFrota
      cRET := NGSEEK("TP5",TPM->TPM_CODFAM + TPM->TPM_TIPMOD + TPM->TPM_SERVIC + TPM->TPM_SEQREL + TPM->TPM_DEPEND,3,"TP5_DESCRI")
   Else
      cRET := TP5->( VDISP(TPM->TPM_CODFAM + TPM->TPM_SERVIC + TPM->TPM_SEQREL + TPM->TPM_DEPEND,"TP5_DESCRI",20))
   EndIf

ElseIf ARG1 == "23"                       //TPB_NOMETT
   cRET := TPR->( VDISP(TPB->TPB_CARACT,"TPR_NOME"))
ElseIf ARG1 == "24"                       //TJ_NOMBEM
   cRET := ST9->T9_NOME
ElseIf ARG1 == "25"                       //TJ_NOMBEM
   cRET := ST9->( VDISP( STJ->TJ_CODBEM, "T9_NOME") )
Else
   cRET := VDISP(ARG1,ARG2)
EndIf

Return cRET
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NGCTETAP ³ AuTOr ³ Inacio Luiz Kolling   ³ Data ³ 01/06/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ ReTOrna as etapas,datas e cONtador                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCODBEM  - Codigo do Bem                                   ³±±
±±³          ³ cSERVICO - Codigo do Servico                               ³±±
±±³          ³ nSEQUENC - Numero da Sequencia                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³OBS       ³ ReTOrna um arquivo com a descricao ETAPA DATA CONTADOR     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAMNT - PlanejamenTO de Manutencao                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³DT.ALTERAC³ANLISTA/PROG.³ MOTIVO                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCTETAP(cCODBEM,cSERVICO,nSEQ)
Local aRET := {}, aSTH:= {},nh := 0, nRET := 0
Local nSEQUENC := If(ValType(nSEQ) = "C",nSEQ,Str(nSEQ,3))

dbSelectArea("STH")
dbSeTOrder(1)
dbSeek( xFilial("STH")+cCODBEM+cSERVICO+nSEQUENC)
While !EoF()                         .And.;
   STH->TH_FILIAL  == xFilial("STH") .And.;
   STH->TH_CODBEM  == cCODBEM        .And.;
   STH->TH_SERVICO == cSERVICO       .And.;
   STH->TH_SEQRELA == nSEQUENC

   AAdd(aSTH, {STH->Th_TAREFA,STH->TH_ETAPA})
   dbSkip()
End

dbSelectArea( "TPD" )
dbSeTOrder(1)
dULTMAN := STF->TF_DTULTMA
nCONTAD := ST9->T9_CONTACU

dXX     := dULTMAN
nXX     := nCONTAD

dDTMAN  := CTOD("31/12/2049")

For nH := 1 TO Len(aSTH)
   dXX := dULTMAN
   nXX := nCONTAD

   dbSeek( xFilial("TPD") + cCODBEM + aSTH[nH][2] + DTOS(dDTMAN), .T.)
   dbSkip(-1)

   If TPD->TPD_CODBEM == cCODBEM .And. TPD->TPD_ETAPA == aSTH[nH][2]
      dXX := TPD->TPD_DTULTM
      nXX := TPD->TPD_POSCON
   EndIf

   aXX := {}
   AAdd(aXX, {aSTH[nH][1], aSTH[nH][2]})

   If Empty(dXX)
      dXX := dULTMAN
   EndIf

   nPOS := aSCAN(aRET, {|x| x[1] == dXX})
   If nPOS == 0
      AAdd(aRET, {dXX,nXX,dXX,dXX,nXX,aXX })
   Else
      AAdd(aRET[nPOS][6], {aSTH[nH][1], aSTH[nH][2]})
   EndIf
Next

If Empty(aRET)
   AAdd(aRET, {dXX,nXX,dXX,dXX,nXX,aSTH})
EndIf

For nRET := 1 TO Len(aRET)

   dULTMAN := aRET[nRET][1]
   nCONTAD := aRET[nRET][2]

   If Empty(dULTMAN)
      dULTMAN := CTOD("01/01/1980")
   EndIf

   If STF->TF_TIPACOM == "T"
      dDTCONT := NGPROXMANT(dULTMAN,STF->TF_TEENMAN,STF->TF_UNENMAN)
   Else
      nNUMDIA := STF->TF_INENMAN/ST9->T9_VARDIA
      dDTCONT := dULTMAN + nNUMDIA
   EndIf

   dREAL := NGCHKDTMNT(dDTCONT, STF->TF_CALENDA, STF->TF_NAOUTIL)

   If STI->TI_ATRASAD == "S" .And. dDTCONT < STI->TI_DATAINI
      dREAL := NGCHKDTMNT(STI->TI_DATAINI, STF->TF_CALENDA, STF->TF_NAOUTIL)
   EndIf

   If STI->TI_ATRASAD == "N" .And. dDTCONT < STI->TI_DATAINI
      While dDTCONT < STI->TI_DATAINI

         If STF->TF_TIPACOM == "T"
            dDTCONT := NGPROXMANT(dDTCONT,STF->TF_TEENMAN,STF->TF_UNENMAN)
         Else
            nNUMDIA := STF->TF_INENMAN/ST9->T9_VARDIA
            dDTCONT := dDTCONT + nNUMDIA
         EndIf

         dREAL := NGCHKDTMNT(dDTCONT, STF->TF_CALENDA, STF->TF_NAOUTIL)
      End
   EndIf
   aRET[nRET][3] := dDTCONT
   aRET[nRET][4] := dREAL
   aRET[nRET][5] := nCONTAD
Next
dbSelectArea("ST9")
Return aRET

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NGCTETOS ³ AuTOr ³ Inacio Luiz Kolling   ³ Data ³ 01/06/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ ReTOrna as datas em que dever  ser feita as manutencoes    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCODBEM  - Codigo do Bem                                   ³±±
±±³          ³ cSERVICO - Codigo do Servico                               ³±±
±±³          ³ nSEQUENC - Numero da Sequencia                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³OBS       ³ ReTOrna um arquivo com a datas das proximas manutencoes    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAMNT - PlanejamenTO de Manutencao                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³DT.ALTERAC³ANLISTA/PROG.³ MOTIVO                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCTETOS(cCODBEM,cSERVICO,nSEQ,dDTINI)
Local aRET := {}, aSTH:= {}, nH := 0, nRET := 0
Local nSEQUENC := If(ValType(nSEQ) = "C",nSEQ,Str(nSEQ,3))

dbSelectArea( "STH" )
dbSeTOrder(1)
dbSeek( xFilial("STH") + cCODBEM + cSERVICO + nSEQUENC)
While !EoF()                        .And.;
   STH->TH_FILIAL == xFilial("STH") .And.;
   STH->TH_CODBEM == cCODBEM        .And.;
   STH->TH_SERVICO == cSERVICO      .And.;
   STH->TH_SEQRELA == nSEQUENC

   AAdd(aSTH, {STH->Th_TAREFA,STH->TH_ETAPA})
   dbSkip()
End

dbSelectArea( "TPD" )
dbSeTOrder(1)

dULTMAN := STF->TF_DTULTMA
nCONTAD := ST9->T9_CONTACU

dXX     := dULTMAN
nXX     := nCONTAD

dDTMAN  := CTOD("31/12/2049")

For nH := 1 TO Len(aSTH)
   dXX := dULTMAN
   nXX := nCONTAD

   dbSeek( xFilial("TPD") + cCODBEM + aSTH[nH][2] + DTOS(dDTMAN), .T.)
   dbSkip(-1)

   If TPD->TPD_CODBEM == cCODBEM .And. TPD->TPD_ETAPA == aSTH[nH][2]
      dXX := TPD->TPD_DTULTM
      nXX := TPD->TPD_POSCON
   EndIf

   aXX := {}
   AAdd(aXX, {aSTH[nH][1], aSTH[nH][2]})

   If Empty(dXX)
      dXX := dULTMAN
   EndIf

   nPOS := aSCAN(aRET, {|x| x[1] == dXX})
   If nPOS == 0
      AAdd(aRET, {dXX,nXX,dXX,dXX,nXX,aXX })
   Else
      AAdd(aRET[nPOS][6], {aSTH[nH][1], aSTH[nH][2]})
   EndIf
Next

If Empty(aRET)
   AAdd(aRET, {dXX,nXX,dXX,dXX,nXX,aSTH})
EndIf

For nRET := 1 TO Len(aRET)

   dULTMAN := aRET[nRET][1]
   nCONTAD := aRET[nRET][2]

   If Empty(dULTMAN)
      dULTMAN := CTOD("01/01/1980")
   EndIf

   If STF->TF_TIPACOM == "T"
      dDTCONT := NGPROXMANT(dULTMAN,STF->TF_TEENMAN,STF->TF_UNENMAN)
   Else
      nNUMDIA := STF->TF_INENMAN/ST9->T9_VARDIA
      dDTCONT := dULTMAN + nNUMDIA
   EndIf

   dREAL := NGCHKDTMNT(dDTCONT, STF->TF_CALENDA, STF->TF_NAOUTIL)

   If dDTCONT < dDTINI
      While dDTCONT < dDTINI

         If STF->TF_TIPACOM == "T"
            dDTCONT := NGPROXMANT(dDTCONT,STF->TF_TEENMAN,STF->TF_UNENMAN)
         Else
            nNUMDIA := STF->TF_INENMAN/ST9->T9_VARDIA
            dDTCONT := dDTCONT + nNUMDIA
         EndIf

         dREAL := NGCHKDTMNT(dDTCONT, STF->TF_CALENDA, STF->TF_NAOUTIL)
      End
   EndIf

   aRET[nRET][3] := dDTCONT
   aRET[nRET][4] := dREAL
   aRET[nRET][5] := nCONTAD
Next
dbSelectArea("ST9")
Return aRET

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} MntGeraD3
Gera Movimento de Requisição e/ou Devolução nos na tabela de mov. Interna (SD3).
@type function

@author Ng Informática
@since 13/10/1998

@sample MntGeraD3( 'RE0', .F., .F., .T., .F., .T. )

@param 	cCod	  , Caracter, Código da movimentação (RE0/DE0).
@param 	lGRAVCAMP , Lógico  , Define se será gravado campos de usuário.
@param 	lOkInteg  , Lógico  , Garante que a integração BackOffice foi realizado corretamente.
@param 	[lAtuCust], Lógico  , Define se o custo da SD3 deve ser atualizado conforme STL.
@param  [lShowMsg], Lógico  , Define se deve apresentar mensagem em tela.
@param  [lRetArr] , Lógico  , Define o tipo de retorno da função deve ser array.
@return cNumSeqD  , Caracter, Número da sequência gerada na SD3.
@return	Array[1]  , Caracter, Número da sequência gerada na SD3.
		Array[2]  , Lógico  , Define se o processo foi realizado com sucesso.
		Array[3]  , Caracter, Mensagem de erro, caso ocorra.
/*/
//---------------------------------------------------------------------------------------------
Function MntGeraD3( cCod, lGRAVCAMP, lOkInteg, lAtuCust, lShowMsg, lRetArr, aInfoSTL )

	Local aCm        := {}
	Local aCusTO     := {}
	Local cProduTO   := ''
	Local cAlmoxa    := CriaVar('D3_LOCAL')
	Local cLoteCtl   := CriaVar('D3_LOTECTL')
	Local cNumLote   := CriaVar('D3_NUMLOTE')
	Local cLocaliz   := CriaVar('D3_LOCALIZ')
	Local cNumSeri   := CriaVar('D3_NUMSERI')
	Local cnumSeqD   := CriaVar('D3_NUMSEQ')
	Local dDatVal    := CriaVar('D3_DTVALID')
	Local nMultiplic := 0
	Local nQtdStl    := 0
	Local cLOCSTL    := " "//Space(Len(sb1->b1_locpad))
	Local nRegloSd3
	Local lGRAVCAMPU := If(lGRAVCAMP <> Nil,lGRAVCAMP,.T.)
    Local nz, nX
	Local cDocumSD3
	Local nDecSD4 := TamSX3('D4_QUANT')[2]
	Local nQtdeSD4 := 0 , lUsaPotenc, cCodOP, nSaldoSD4, nQtdSD3
	Local xRetMU    := {}
	Local lPCriaSDC := .F. //Verifica se o produto possui localização
	Local cTrt := "" // Usado para identificar o trt do SD4 e gravar no SD3 relaciONado

	Default lShowMsg := .T.
	Default lRetArr  := .F.
	Default lAtuCust := .F.
	Default aInfoSTL := { STL->TL_ORDEM  , STL->TL_PLANO  , STL->TL_TIPOREG, STL->TL_CODIGO , STL->TL_QUANTID,;
						  STL->TL_LOCAL  , STL->TL_LOTECTL, STL->TL_NUMLOTE, STL->TL_LOCALIZ, STL->TL_NUMSERI,;
						  STL->TL_DTVALID, STL->TL_HREXTRA, STL->TL_PCTHREX, STL->TL_NUMSEQ , STL->TL_UNIDADE,;
						  STL->TL_DTINICI, STL->TL_TIPOHOR, STL->TL_CUSTO  , STL->( RecNo() ) }

	// INICIO BLOCO USADO NO MATA250
	PRIVATE cCusMed := GetMv("mv_CusMed")


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o cusTO medio e' calculado ON-Line               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cCusMed == "O"

		PRIVATE nHdlPrv // Endereco do arquivo de cONtra prova dos lancTOs cONt.

		PRIVATE lCriaHeader := .F. // Para criar o header do arquivo CONtra Prova

		PRIVATE cLoteEst    // Numero do lote para lancamenTOs do esTOque
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ PosiciONa numero do Lote para LancamenTOs do FaturamenTO     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SX5")
		dbSeek(xFilial()+"09EST")
		cLoteEst:=IIF(Found(),Trim(X5Descri()),"EST ")

		PRIVATE nTOtal := 0     // TOtal dos lancamenTOs cONtabeis

		PRIVATE cArquivo    // Nome do arquivo cONtra prova

		Private aCtbDia := {}

	EndIf
	// FIM BLOCO USADO NO MATA250

	If SubStr(cCOD,1,2) == "RE"
		nMULTIPLIC := -1
	Else
		nMULTIPLIC := 1
	EndIf

	dbSelectArea("STL")

	cORDEMSTL := aInfoSTL[1]
	cPLANOSTL := aInfoSTL[2]
	cLocPad   := Padr( GetMv("MV_NGLOCPA"), TamSx3("NNR_CODIGO")[1] )
	cLOCSTL   := IIf( Empty( aInfoSTL[6] ), cLocPad, aInfoSTL[6] )

	If aInfoSTL[3] == 'P'
		cProduTO   := aInfoSTL[4]
		nMultiplic := 0
	ElseIf aInfoSTL[3] == 'T'
		cProdutx := If(FindFunction("NGProdMNT"), NGProdMNT("T")[1], GetMv("MV_PRODTER")) //Ira movimentar apenas o primeiro ProduTO Terceiro do parametro
		cProduTO := cProdutx+Space(Len(sb1->b1_cod)-Len(cProdutx))
		nMultiplic := 0
	ElseIf aInfoSTL[3] == 'M'
		If ST1->( dbSeek( xFilial('ST1') + Trim( aInfoSTL[4] ), .F. ) )
			cProduTO   := IIf( FindFunction( 'MntGetPrdM' ), MntGetPrdM(), PadR( 'MOD' + ST1->T1_CCUSTO, TamSX3( 'B1_COD' )[1] ) )
			nMultiplic := IIf( NGCADICBASE( 'TL_PCTHREX', 'A', 'STL', .F.), aInfoSTL[13], IIf( aInfoSTL[12] <> '000.00', Val( aInfoSTL[12] )/100, 1) )
		Else
			Return IIf( lRetArr, { cNumSeqD, .T., '' }, cNumSeqD )
		EndIf
	Else
		Return IIf( lRetArr, { cNumSeqD, .T., '' }, cNumSeqD )
	EndIf

	If !Empty( cProduTO )

		aInfoSTL[ 4 ] := cProduTO

	EndIf

	SB1->( dbSeTOrder( 1 ) )
	SB1->( dbSeek( xFilial( 'SB1' ) + cProduTO ) )
	cB1APROP := SB1->B1_APROPRI

	SB2->(dbSeTOrder(1))
	If !SB2->(dbSeek(xFilial('SB2')+SubStr(cProduTO,1,Len(SB1->B1_COD))+cLOCSTL))
		CriaSB2(cProduTO,cLOCSTL)

		RecLock("SB2",.F.)
		If aInfoSTL[3] == 'M'
			SB2->B2_CM1 := ST1->t1_salario
		EndIf
		MsUnLock("SB2")
	EndIf

	nQTEMP := SB2->B2_QEMP

	dbSelectArea("STL")
	cAlmoxa  := aInfoSTL[6]
	cLoteCtl := aInfoSTL[7]
	cNumLote := aInfoSTL[8]
	cLocaliz := aInfoSTL[9]
	cNumSeri := aInfoSTL[10]
	dDatVal  := aInfoSTL[11]
	nQtdStl  := ( aInfoSTL[5] + ( aInfoSTL[5] * nMultiplic ) )

	cAlmoxa := If (Empty(cAlmoxa),cLocPad,cAlmoxa)
	
	If ( FwIsInCallStack( 'MNTA435' ) .Or. FwIsInCallStack( 'MNTA400' ) .Or. FwIsInCallStack( 'MNTA510' ) .Or. FWIsInCallStack( 'MNTA656' ) .Or.;
		FwIsInCallStack( 'MNT720IN' ) .Or. FwIsInCallStack( 'MNTNGInput' ) ) .And. !Empty( SuperGetMV( 'MV_MNTREQ', .F., '' ) )

		/*---------------------------------------------------+
		| Chamada do ExecAuto MARA241 para baixa de estoque. |
		+---------------------------------------------------*/
		xRet := MntExecSD3( SubStr( cCod, 1, 1 ) == 'R', Nil, Nil, aInfoSTL, lShowMsg )

	Else

		nQuantEs := 0.00
		If Substr(cCod,1,1) = "D"
			cFilSD3 := xFilial("SD3")
			dbSelectArea("SD3")
			dbSeTOrder(4)
			If dbSeek( cFilSD3 + aInfoSTL[14] )
				cnumSeqd := sd3->d3_numseq
				RecLock('SD3', .F.)
				SD3->D3_ESTORNO := "S"
				MsUnLock("SD3")

				aCampEsTOrno:={}
				For nz := 1 TO FCount()
					aAdd(aCampEsTOrno,FieldGet(nz))
				Next nz

				//Grava Registro de Devolucao
				dbSelectArea("SD3")
				RecLock("SD3",.T.)
				For nz := 1 TO FCount()
					FieldPut(nz,aCampEsTOrno[nz])
				Next nz

				nQuantEs := SD3->D3_QUANT
				nQSTLAt  := aInfoSTL[5]

				SD3->D3_TM := "499"
				SD3->D3_CF := cCod
				SD3->D3_CHAVE   := SubStr(D3_CF,2,1)+If(D3_CF $ 'RE4|DE4','9','0')
				SD3->D3_USUARIO := If(Len(SD3->D3_USUARIO) > 15,cUsername,Substr(cUsuario,7,15))
				If cB1APROP = "I"
					SD3->D3_CHAVE := Substr(sd3->d3_chave,1,1)+"3"
				EndIf
				SD3->(MsUnLock())

				M->D3_COD := SD3->D3_COD
				M->D3_DOC := SD3->D3_DOC
				M->D3_OP  := SD3->D3_OP

			EndIf
		Else

			// Recupera o trt do empenho (SD4) relaciONado ao movimenTO interno (SD3)
			cTrt := NGSEEK("SD4",PadR((aInfoSTL[1] + "OS001"),TAMSX3("D4_OP")[1]) + PadR(cProduTO,TAMSX3("D4_COD")[1])+;
				PadR( If( Empty( cAlmoxa ),SB1->B1_LOCPAD, cAlmoxa ),TAMSX3( "D4_LOCAL" )[1] ),02,"SD4->D4_TRT" ) // D4_FILIAL+D4_OP+D4_COD+D4_LOCAL

			cNumSeqD := ProxNum()

			//Pega o proximo numero sequencial do documenTO do SD3
			cDocumSD3 := NextNumero("SD3",2,"D3_DOC",.T.)
			cDocumSD3 := A261RetINV(cDocumSD3)

			dbSelectArea("SD3")
			RecLock('SD3', .T.)
			Replace D3_FILIAL  With xFilial('SD3')
			Replace D3_TM      With If(cCod=='RE0', '999', '499')
			Replace D3_COD     With cProduTO
			Replace D3_UM      With aInfoSTL[15]
			Replace D3_CF      With cCod
			Replace D3_CONTA   With SB1->B1_CONTA
			Replace D3_OP      With aInfoSTL[1] + 'OS001'
			Replace D3_LOCAL   With If(Empty(cAlmoxa), SB1->B1_LOCPAD, cAlmoxa)
			Replace D3_DOC     With cDocumSD3
			Replace D3_EMISSAO With aInfoSTL[16]
			Replace D3_NUMSEQ  With cnumSeqD
			Replace D3_SEGUM   With SB1->B1_SEGUM
			Replace D3_QTSEGUM With CONvUm(SB1->B1_COD,nQtdStl,0,2)
			Replace D3_GRUPO   With SB1->B1_GRUPO
			Replace D3_TIPO    With SB1->B1_TIPO
			Replace D3_CHAVE   With SubStr(D3_CF,2,1)+If(D3_CF $ 'RE4|DE4','9','0')
			Replace D3_USUARIO With If(Len(SD3->D3_USUARIO) > 15,cUsername,Substr(cUsuario,7,15))
			Replace D3_CC      With STJ->TJ_CCUSTO
			Replace D3_ORDEM   With STJ->TJ_ORDEM
			Replace D3_TRT     With cTrt // Str(1,3)
			SD3->D3_ESTORNO    := If(Substr(cCod,1,1) = "D","S",SD3->D3_ESTORNO)

			SD3->D3_QUANT      := IIf( aInfoSTL[3] == 'P', aInfoSTL[5], IIf( aInfoSTL[17] == 'D', aInfoSTL[5], NGCONVERHORA( aInfoSTL[5], 'S', 'D' ) ) )

			If cB1APROP = "I"
				SD3->D3_CHAVE   := Substr(sd3->d3_chave,1,1)+"3"
			EndIf

			//-- Grava a Localizacao F¡sica e Numero de S‚rie em movimenTOs de Saida
			If Localiza(cProduTO) .And. D3_TM>'500'
				Replace D3_LOCALIZ  With cLocaliz
				Replace D3_NUMSERI  With cNumSeri
			EndIf

			//-- Grava o Lote e SubLote
			If Rastro(cProduTO)
				Replace D3_LOTECTL With cLoteCtl
				If Rastro(cProduTO, 'S')
					Replace D3_NUMLOTE With cNumLote
				EndIf
				Replace D3_DTVALID With dDatVal
			EndIf

			If NGCADICBASE("T9_ITEMCTA","A","ST9",.F.)
				SD3->D3_ITEMCTA := NGSEEK("ST9",STJ->TJ_CODBEM,1,"T9_ITEMCTA")
			EndIf
			dbSelectArea("SD3")
			MsUnLock()

			M->D3_COD := SD3->D3_COD
			M->D3_DOC := SD3->D3_DOC
			M->D3_OP  := SD3->D3_OP

		EndIf

		dbSelectArea( "SD3" )
		nRegloSd3 := Recno()

		// Pega os 5 custos médios atuais
		aCM := PegaCMAtu(SD3->D3_COD,SD3->D3_LOCAL)

		// Atualiza e grava o custo da mmovimentação conforme o custo do insumo.
		If lAtuCust .And. ExistBlock( 'NGCALCUSTI' )

			aCM[1] := aInfoSTL[18]
			aCusTO := GravaCusD3( aCM, .T. )

		Else

			aCusTO := GravaCusD3( aCM )

		EndIf

		//Aterado para passar o parametro 7 para indicar que nao baixa
		//empenho de saldos por lote. Se nao passar este parametro nao faz
		//a baixa de saldos por lote(SB8) quando o produTO e cONtrolado por rastreabilidade e
		//nao gera SD5
		dbSelectArea("SD3")

		B2AtuComD3( aCusTO, Nil, Nil, ( SD3->D3_TM > '500' ), Nil, .T., .T., , , , , , , cLocaliz, , , , , , , , , , .F. )

		dbSelectArea("SB2")
		MsUnLock("SB2")
		//ADICIONADO O MsUnLock ACIMA PORQUE A FUNCAO ACIMA DA MICROSIGA NAO LIBERA
		//O REGISTRO ALTERADO NO SB2 POR CONSEQUENCIA NAO ATUALIZA O SALDO NO ESTOQUE
		//ONLINE (FICA PRESO NA MEMORIA)

		//-------------------------------------
		//INTEGRACAO POR MENSAGEM UNICA
		//-------------------------------------
		If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"  //Mensagem Unica
			If SubStr(SD3->D3_CF,1,2) == "RE"  .And. SD3->D3_TM > '500'//
				If Type("oXmlMU:_TOTVSMessage:_BusinessMessage:_BusinessEvent:_Entity:Text") <> "U" .And. ; //Alterado de Nil para Undefined
					oXmlMU:_TOTVSMessage:_BusinessMessage:_BusinessEvent:_Entity:Text   <> "STOCKTURNOVER"
					If !NGMUSTOTuO(nRegloSd3,"SD3")
						Return IIf( lRetArr, { '', .F., '' }, '' )
					EndIf
				ElseIf Type("oXmlMU:_TOTVSMessage:_BusinessMessage:_BusinessEvent:_Entity:Text") == "U"
					If !NGMUSTOTuO(nRegloSd3,"SD3")
						Return IIf( lRetArr, { '', .F., '' }, '' )
					EndIf
				EndIf
			Else

				xRetMU := NGMUCanReq( SD3->( Recno() ), 'SD3', lShowMsg, .T. )

				lOkInteg := IIf( ValType( xRetMU ) == 'A', xRetMU[1], xRetMU )

				If !lOkInteg

					If SubStr( cCod, 1, 1 ) == 'D'

						//Exclui o estorno
						RecLock("SD3",.F.)
						SD3->(dbDelete())
						MsUnLock("SD3")

						//Restaura a SD3 original
						cFilSD3 := xFilial("SD3")
						dbSelectArea("SD3")
						dbSeTOrder(4)
						If dbSeek( cFilSD3 + aInfoSTL[14] )
							RecLock('SD3', .F.)
							SD3->D3_ESTORNO := " "
							MsUnLock("SD3")
						EndIf

						Return IIf( ValType( xRetMU ) == 'A' .And. lRetArr, { '', xRetMU[1], xRetMU[2] }, '' )

					EndIf

				EndIf

			EndIf
		EndIf

		//ESTORNO DO EMPENHO
		dbSelectArea("SD4")
		dbSeTOrder(2) // D4_FILIAL+D4_OP+D4_COD+D4_LOCAL
		If !dbSeek(xFilial("SD4")+SD3->D3_OP+SD3->D3_COD+SD3->D3_LOCAL)
			dbSelectArea("SB2")
			dbSeTOrder(1)
			If dbSeek(xFilial('SB2')+cProduTO+cLOCSTL)
				RecLock("SB2",.F.)
				SB2->B2_QEMP := nQTEMP
				MsUnLock("SB2")
			EndIf
		Else
			
			If SubStr(cCOD,1,2) == "DE"  .And. SD3->D3_TM <= '500'
				
				nUTILIZ := 0.00
				dbSelectArea("STL")
				nRECNOSTL := Recno()
				dbSeTOrder(1)
				nQuantSTL := aInfoSTL[5]
				
				If dbSeek(xFilial('STL')+cORDEMSTL+cPLANOSTL)
					While !EoF() .And. STL->TL_FILIAL == xFilial("STL") .And.;
							STL->TL_ORDEM == cORDEMSTL .And. STL->TL_PLANO == cPLANOSTL
						If Alltrim(stl->tl_seqrela) <> "0" .And. stl->tl_tiporeg == 'P' .And.;
								stl->tl_codigo == SD3->D3_COD
							nUTILIZ := nUTILIZ + STL->TL_QUANTID
						EndIf
						dbSkip()
					End
				EndIf

				nDVolve := 0.00
				If Altera
					If nQSTLAt <= nQuantEs
						If SD4->D4_QUANT <> 0
							nDVolve := (nQuantEs - nQSTLAt) + nQSTLAt
						Else
							If SD4->D4_QTDEORI >= nUTILIZ
								nDVolve := (SD4->D4_QTDEORI - nUTILIZ)+nQSTLAt
							Else
								nDVole := nQSTLAt
							EndIf
						EndIf
					Else
						If SD4->D4_QUANT <> 0
							nDVolve := nQuantEs
						EndIf
					EndIf
				Else
					If SD4->D4_QUANT = 0
						If SD4->D4_QTDEORI >= nUTILIZ
							nDVolve := SD4->D4_QTDEORI - nUTILIZ
						Else
							nDVole := SD3->D3_QUANT
						EndIf
					Else
						If SD4->D4_QTDEORI >= nUTILIZ
							nDVolve := (SD4->D4_QTDEORI - nUTILIZ) - SD4->D4_QUANT
						Else
							nDVole := SD3->D3_QUANT
						EndIf
					EndIf
				EndIf
				dbSelectArea("SB2")
				dbSeTOrder(1)
				If dbSeek(xFilial('SB2')+cProduTO+cLOCSTL)
					RecLock("SB2",.F.)
					SB2->B2_QEMP := SB2->B2_QEMP + nDVolve
					MsUnLock("SB2")
				EndIf
				dbSelectArea("STL")
				dbGoTO(nRECNOSTL)
			EndIf
		EndIf

		//REQUISICAO ATUALIZA SALDO ATUAL DO EMPENHO SE HOUVER
		nDecSD4  := TamSX3('D4_QUANT')[2]
		nQtdeSD4 :=0
		lUsaPotenc := PotencLote(SD3->D3_COD)
		If SubStr(cCOD,1,2) == "RE"  .And. SD3->D3_TM > '500'

			//-------------------------------------------------------------
			// A forma de posiciONamenTO foi alterada para usar o índice 2
			//-------------------------------------------------------------
			dbSelectArea("SD4")
			dbSeTOrder(2) // D4_FILIAL+D4_OP+D4_COD+D4_LOCAL
			If dbSeek(xFilial("SD4")+SD3->D3_OP+SD3->D3_COD+SD3->D3_LOCAL)//+If(lBxEmpb8,SD3->D3_LOTECTL+SD3->D3_NUMLOTE,CriaVar("D3_LOTECTL")+CriaVar("D3_NUMLOTE")))
				If lUsaPotenc
					nQtdeSD4:=Round(SD3->D3_QUANT*(SD3->D3_POTENCI/100),nDecSD4)
				Else
					nQtdeSD4:=SD3->D3_QUANT
				EndIf
				nDevolve := SD4->D4_QTDEORI - SD4->D4_QUANT
				If SD4->D4_QUANT >= nQtdeSD4
					RecLock("SD4",.F.)
					Replace D4_QUANT   With D4_QUANT - nQtdeSD4
					Replace D4_QTSEGUM With D4_QTSEGUM - CONvUM(SD4->D4_COD, nQtdeSD4, 0, 2)
					MsUnLock("SD4")
				Else
					cCodOP := SD4->D4_FILIAL+SD4->D4_COD+SD4->D4_OP
					While !EoF() .And. cCodOP == D4_FILIAL+D4_COD+D4_OP
						nSaldoSD4 := IIf( nQtdeSD4 > D4_QUANT, D4_QUANT, nQtdeSD4 )
						nQtdeSD4 -= nSaldoSD4
						RecLock("SD4",.F.)
						Replace D4_QUANT   With D4_QUANT - nSaldoSD4
						Replace D4_QTSEGUM With D4_QTSEGUM - CONvUM(SD4->D4_COD, nSaldoSD4, 0, 2)
						MsUnLock("SD4")
						If nQtdeSD4 <= 0
							Exit
						EndIf
						dbSelectArea("SD4")
						dbSkip()
					End
				EndIf

				If SB1->(dbSeek(xFilial('SB1')+SD4->D4_COD))
					If SB1->B1_LOCALIZ == "S"
						//Verifica lote/endereço
						dbSelectArea("SDC")
						dbSetOrder(2) //DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE+DC_LOCALIZ+DC_NUMSERI
						If dbSeek( xFilial("SDC") + SD4->D4_COD + SD4->D4_LOCAL + SD4->D4_OP )
							RecLock("SDC",.F.)
							If SD4->D4_QUANT == 0
								dbDelete()
							Else
								SDC->DC_QUANT := SD4->D4_QUANT
							EndIf
							MsUnlock("SDC")
						Else
							Reclock("SDC",.T.)
							Replace DC_FILIAL   With xFilial()
							Replace DC_ORIGEM   With "SC2"
							Replace DC_PRODUTO  With SD4->D4_COD
							Replace DC_LOCAL    With SD4->D4_LOCAL
							Replace DC_LOCALIZ  With SD3->D3_LOCALIZ
							Replace DC_QTDORIG  With SD4->D4_QTDEORI
							Replace DC_QUANT    With SD4->D4_QUANT
							Replace DC_OP       With SD4->D4_OP
							Replace DC_TRT      With SD4->D4_TRT

							MsUnlock()

						EndIf

						//Retira o saldo empenhado da tabela SBF
						dbSelectArea("SBF")
						dbSetOrder(02)
						If dbSeek( xFilial("SBF") + SD4->D4_COD + SD4->D4_LOCAL)
							RecLock("SBF",.F.)
							SBF->BF_EMPENHO -= nQtdeSD4
							MsUnlock("SBF")
						EndIf

					EndIf

				EndIf

			EndIf

		EndIf

		//ESTORNA O SALDO ATUAL DO EMPENHO
		nQtBxSD4 := 0
		If SubStr(cCOD,1,2) == "DE"  .And. SD3->D3_TM <= '500'

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza arq. de empenhos e B2_QEMP se for movimenTO de mat. dir. ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nQtdSD3 := SD3->D3_QUANT
			dbSelectArea("SD4")
			dbSeTOrder(2)// D4_FILIAL+D4_OP+D4_COD+D4_LOCAL
			If dbSeek(xFilial("SD4")+SD3->D3_OP+SD3->D3_COD+SD3->D3_LOCAL)
				If lUsaPotenc
					nQtdSD3 := Round(SD3->D3_QUANT*(SD3->D3_POTENCI/100),nDecSD4)
				EndIf

				dbSelectArea("SD4")
				While !EoF() .And. SD4->(D4_FILIAL+D4_OP+D4_COD+D4_LOCAL)  == xFilial("SD4")+SD3->D3_OP+SD3->D3_COD+SD3->D3_LOCAL ;
						.And. nQtBxSD4 < nQtdSD3

					RecLock("SD4",.F.)
					nQtBxSD4 += nQtdeSD4
					Replace D4_QUANT   With D4_QUANT + nDVolve
					Replace D4_QTSEGUM With D4_QTSEGUM + CONvUM(SD4->D4_COD, nQtdeSD4, 0, 2)
					MsUnLock("SD4")

					If SB1->(dbSeek(xFilial('SB1')+SD4->D4_COD))

						If SB1->B1_LOCALIZ == "S"
							lPCriaSDC := .T.
						Else
							lPCriaSDC := .F.
						EndIf

						//Recria o registro de SDC se o produto estiver localização
						If lPCriaSDC

							dbSelectArea("SDC")
							dbSetOrder(2) //DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE+DC_LOCALIZ+DC_NUMSERI
							If !dbSeek( xFilial("SDC") + SD4->D4_COD + SD4->D4_LOCAL + SD4->D4_OP )

								Reclock("SDC",.T.)
								Replace DC_FILIAL   With xFilial()
								Replace DC_ORIGEM   With "SC2"
								Replace DC_PRODUTO  With SD4->D4_COD
								Replace DC_LOCAL    With SD4->D4_LOCAL
								Replace DC_LOCALIZ  With SD3->D3_LOCALIZ
								Replace DC_QTDORIG  With SD4->D4_QTDEORI
								Replace DC_QUANT    With SD4->D4_QTDEORI
								Replace DC_OP       With SD4->D4_OP
								Replace DC_TRT      With SD4->D4_TRT

								MsUnlock()

							Else
								Reclock("SDC",.F.)
								If SD4->D4_QUANT == 0
									dbDelete()
								Else
									SDC->DC_QUANT := SD4->D4_QUANT
								EndIf
								MsUnlock()

							EndIf

							//Retira o saldo empenhado da tabela SBF
							dbSelectArea("SBF")
							dbSetOrder(02)
							If dbSeek( xFilial("SBF") + SD4->D4_COD + SD4->D4_LOCAL)
								RecLock("SBF",.F.)
								SBF->BF_EMPENHO += nDVolve
								MsUnlock("SBF")
							EndIf

						EndIf
					EndIf


					dbSelectArea("SD4")
					dbSkip()

				End

			EndIf
		EndIf

		If cCod == "RE0"  .And. lGRAVCAMPU

			dbSelectArea("SD3")
			dbGoTO(nRegloSd3)

			//Verifica os campos de usuario no STL e grava os campos relaciONados no
			//SD3 se existir
			NGGRACUSD3()

		EndIf

		If aInfoSTL[3] == 'P'

			//----------------------------------------------------------------
			//³ Verifica se o custo medio e' calculado On-Line               ³
			//----------------------------------------------------------------
			If cCusMed == "O"

				nHdlPrv := HeadProva(cLoteEst,"MATA240",Subs(cUsuario,7,6),@cArquivo)


				If !lCriaHeader //.And. nTotal > 0
					//----------------------------------------------------------------
					//³ Inicializa perguntas deste programa                          ³
					//----------------------------------------------------------------
					//----------------------------------------------------------------
					//³ mv_par01 - Se mostra e permite digitar lancamentos contabeis   ³
					//³ mv_par02 - Se deve aglutinar os lancamentos contabeis          ³
					//----------------------------------------------------------------
					pergunte("MTA240",.F.)
					lDigita   := Iif(mv_par01 == 1,.T.,.F.)
					lAglutina := Iif(mv_par02 == 1,.T.,.F.)

					nTotal+=DetProva(nHdlPrv,"666","MATA240",cLoteEst)

					//----------------------------------------------------------------
					//³ Se ele criou o arquivo de prova ele deve gravar o rodape'    ³
					//----------------------------------------------------------------
					RodaProva(nHdlPrv,nTotal)

					If !Empty(aCtbDia)
						cCodDiario := CtbaVerdia()
						For nX := 1 to Len(aCtbDia)
							aCtbDia[nX][3] := cCodDiario
						Next nX
					EndIf

					If cA100Incl(cArquivo,nHdlPrv,3,cLoteEst,lDigita,lAglutina,,,,,,aCtbDia)
						lCriaHeader := .T.
						nTotal      := 0 // Total dos lancamentos contabeis
						KeyBoard Chr(27)

						RecLock("SD3",.F.)
						Replace D3_DTLANC With dDataBase
						MsUnLock()
					EndIf
				EndIf
			EndIf

		EndIf

		dbSelectArea( 'SD3' )
		dbGoTo( nRegloSd3 )

		xRet := IIf( lRetArr, { SD3->D3_NUMSEQ, .T., '' }, SD3->D3_NUMSEQ )

	EndIf
	
	If ExistBlock( 'NGMNTSD3' )
		ExecBlock( 'NGMNTSD3', .F., .F. )
	EndIf

	dbSelectArea( 'STL' )

Return xRet

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} MntExecSF5
ExecAuto que gera os Solicitação de Compras.
@type function

@author Alexandre Santos
@since 01/08/2022

@param 	aInfoSF5, array , Detalhes do cadastro.
							[1] F5_CODIGO  - Código do Movimento
							[2] F5_TIPO    - Tipo de Movimento
							[3] F5_TEXTO   - Descrição
							[4] F5_APROPR  - Habilita Apropriação Indireta
							[5] F5_ATUEMP  - Habilita Atualização de Empenho
							[6] F5_TRANMOD - Habilita Transferencia de MDO como empenho
							[7] F5_VAL     - Habilita custo na movimentação
							[8] F5_QTDZERO - Habilita movimentação com quant. zero

@return	boolean , Define se o processo foi realizado com sucesso.
/*/
//---------------------------------------------------------------------------------------------
Function MntExecSF5( aInfo )

	Local aItemSF5      := {}
	Local nOptSF5       := 3
	Local lRet          := .T.

	Private lMsHelpAuto := .T.
	Private lMsErroAuto := .F.

	/*-------------------------------+
	| Detalhes do tipo de movimento. |
	+-------------------------------*/
	aAdd( aItemSF5, { 'F5_CODIGO' , aInfo[1], Nil } )
	aAdd( aItemSF5, { 'F5_TIPO'   , aInfo[2], Nil } )
	aAdd( aItemSF5, { 'F5_TEXTO'  , aInfo[3], Nil } )
	aAdd( aItemSF5, { 'F5_APROPR' , aInfo[4], Nil } )
	aAdd( aItemSF5, { 'F5_ATUEMP' , aInfo[5], Nil } )
	aAdd( aItemSF5, { 'F5_TRANMOD', aInfo[6], Nil } )
	aAdd( aItemSF5, { 'F5_VAL'    , aInfo[7], Nil } )
	aAdd( aItemSF5, { 'F5_QTDZERO', aInfo[8], Nil } )

	MSExecAuto( { |x,y| MATA230( x, y ) }, aItemSF5, nOptSF5 )

	If lMsErroAuto
		
		MostraErro()
		
		lRet := .F.

	EndIf

Return lRet
//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} MNTExecSD3
ExecAuto que gera os movimentos de Requisição e/ou Devolução nos na tabela de movimentação
interna (SD3).
@type function

@author Alexandre Santos
@since 01/12/2021

@param 	lReq	   , boolean, Código da movimentação (RE0/DE0).
@param 	[cProduto] , string , OBSOLETO.
@param 	[cAlmoxa]  , string , OBSOLETO.
@param  aInfoSTL   , array  , Informarções do insumo para movimento.
@param  [lMsgError], boolean, Define se deve apresentar mensagem em tela.

@return	Array[1]   , string , Número da sequência gerada na SD3.
		Array[2]   , boolean, Define se o processo foi realizado com sucesso.
		Array[3]   , string , Mensagem de erro, caso ocorra.
/*/
//---------------------------------------------------------------------------------------------
Function MNTExecSD3( lReq, cProduTO, cAlmoxa, aInfoSTL, lMsgError )

	Local aAreaSTL      := STL->( GetArea() )
	Local aAreaSTJ      := STJ->( GetArea() )
	Local aCab241       := {}
	Local aIt241        := {}
	Local aRetSD3       := {}
	Local aItem         := {}
	Local cTRT          := ''
	Local cError        := ''
	Local cNumSeq       := ''
	Local lRetSDB       := .T.
	Local lDevSD3       := .F. // Indica que o processo trata-se de um movimento de devolução.
	Local lIntegRM      := SuperGetMV( 'MV_NGINTER', .F., 'N' ) == 'M' .And. !FWIsInCallStack( 'INTEGDEF' )
	Local nOpt241       := 0
	Local nInd1         := 0

	Private lMsHelpAuto := .T.
	Private lMsErroAuto := .F.

	Default lMsgError   := .F.
	Default aInfoSTL    := { STL->TL_ORDEM  , STL->TL_PLANO  , STL->TL_TIPOREG, STL->TL_CODIGO , STL->TL_QUANTID,;
						  	 STL->TL_LOCAL  , STL->TL_LOTECTL, STL->TL_NUMLOTE, STL->TL_LOCALIZ, STL->TL_NUMSERI,;
						  	 STL->TL_DTVALID, STL->TL_HREXTRA, STL->TL_PCTHREX, STL->TL_NUMSEQ , STL->TL_UNIDADE,;
						  	 STL->TL_DTINICI, STL->TL_TIPOHOR, STL->TL_CUSTO  , STL->( RecNo() ) }
	
	dbSelectArea( 'STJ' )
	dbSetOrder( 1 )

	If !lReq

		If Empty( aInfoSTL[14] )

			/*-----------------------+
			| Devolução de Movimento |
			+-----------------------*/
			cDocD3  := A261RetINV( NextNumero( 'SD3', 2, 'D3_DOC', .T. ) )
			cCodTM  := SuperGetMV( 'MV_MNTDEV', .F., '' )
			nOpt241 := 3
			lDevSD3 := .T.
		
		Else

			/*---------------------+
			| Estorno de Movimento |
			+---------------------*/
			dbSelectArea( 'SD3' )
			dbSetOrder( 4 ) // D3_FILIAL + D3_NUMSEQ
			If msSeek( FWxFilial( 'SD3' ) + aInfoSTL[14] )
			
				cDocD3  := SD3->D3_DOC
				cNumSeq := SD3->D3_NUMSEQ
				cCodTM  := '499'
				nOpt241 := 6

				If lIntegRM .And. Posicione( 'SB2', 1, FWxFilial( 'SB2' ) + SD3->D3_COD + SD3->D3_LOCAL,  'B2_QATU' ) < 0

					NGMUStoLvl( SD3->D3_COD, SD3->D3_LOCAL )

				EndIf
				
			EndIf
	
		EndIf

	Else

		/*------------------------+
		| Requisição de Movimento |
		+------------------------*/
		cDocD3  := A261RetINV( NextNumero( 'SD3', 2, 'D3_DOC', .T. ) )
		cCodTM  := SuperGetMV( 'MV_MNTREQ', .F., '' )
		nOpt241 := 3

	EndIf
	
	If ValType( aInfoSTL[1] ) == 'A'

		aCab241 := { { 'D3_DOC'    , cDocD3         , NIL },;
          		 	 { 'D3_TM'     , cCodTM         , Nil },;
         		 	 { 'D3_CC'     , STJ->TJ_CCUSTO , NIL },;
          		 	 { 'D3_EMISSAO', aInfoSTL[1,16] , NIL } }

		For nInd1 := 1 To Len( aInfoSTL )

			cTRT := NGSEEK( 'SD4', PadR( ( aInfoSTL[nInd1,1] + 'OS001' ), FWTamSX3( 'D4_OP' )[1] ) + PadR( aInfoSTL[nInd1,4], FWTamSX3( 'D4_COD' )[1] ) +;
				PadR( If( Empty( aInfoSTL[nInd1,6] ),SB1->B1_LOCPAD, aInfoSTL[nInd1,6] ), FWTamSX3( 'D4_LOCAL' )[1] ), 02, 'SD4->D4_TRT' )

			aItem := {}

			aAdd( aItem, { 'D3_COD'    , PadR( aInfoSTL[nInd1,4], FWTamSX3( 'D4_COD' )[1] )             , Nil } )
			aAdd( aItem, { 'D3_OP'     , PadR( ( aInfoSTL[nInd1,1] + 'OS001' ), FWTamSX3( 'D4_OP' )[1] ), Nil } )
			aAdd( aItem, { 'D3_TRT'    , cTRT                                                           , Nil } )
			aAdd( aItem, { 'D3_QUANT'  , aInfoSTL[nInd1,5]                                              , Nil } )
			aAdd( aItem, { 'D3_LOCAL'  , PadR( aInfoSTL[nInd1,6], FWTamSX3( 'D4_LOCAL' )[1] )           , Nil } )
			aAdd( aItem, { 'D3_LOTECTL', aInfoSTL[nInd1,7]                                              , Nil } )
			aAdd( aItem, { 'D3_NUMLOTE', aInfoSTL[nInd1,8]                                              , Nil } )
			aAdd( aItem, { 'D3_DTVALID', aInfoSTL[nInd1,11]                                             , Nil } )
			aAdd( aItem, { 'D3_LOCALIZ', PadR( aInfoSTL[nInd1,9] , FWTamSX3( 'D3_LOCALIZ' )[1] )        , Nil } )
			aAdd( aItem, { 'D3_NUMSERI', PadR( aInfoSTL[nInd1,10], FWTamSX3( 'D3_NUMSERI' )[1] )        , Nil } )
			aAdd( aItem, { 'D3_ORDEM'  , aInfoSTL[nInd1,1]                                              , Nil } )
			aAdd( aItem, { 'D3_ITEMCTA', NGSEEK("ST9",STJ->TJ_CODBEM,1,"T9_ITEMCTA")                    , Nil } )
			aAdd( aItem, { 'D3_NUMSEQ' , cNumSeq    , Nil } )
			
			aAdd( aIt241, aItem )                                                    

		Next nInd1

	Else

		cTRT := NGSEEK( 'SD4', PadR( ( aInfoSTL[1] + 'OS001' ), FWTamSX3( 'D4_OP' )[1] ) + PadR( aInfoSTL[4], FWTamSX3( 'D4_COD' )[1] ) +;
				PadR( If( Empty( aInfoSTL[6] ),SB1->B1_LOCPAD, aInfoSTL[6] ), FWTamSX3( 'D4_LOCAL' )[1] ), 02, 'SD4->D4_TRT' )

		aCab241 := { { 'D3_DOC'    , cDocD3         , NIL },;
          		 	 { 'D3_TM'     , cCodTM         , Nil },;
         		 	 { 'D3_CC'     , STJ->TJ_CCUSTO , NIL },;
          		 	 { 'D3_EMISSAO', aInfoSTL[16]   , NIL } }

		aAdd( aIt241, {	{ 'D3_COD'    , PadR( aInfoSTL[4], FWTamSX3( 'D4_COD' )[1] ), NIL },;
						{ 'D3_OP'     , PadR((aInfoSTL[1] + "OS001"),TAMSX3("D4_OP")[1]), Nil},;
						{ 'D3_TRT'    , cTrt, NIL},;
						{ 'D3_QUANT'  , IIf( aInfoSTL[3] == "P", aInfoSTL[5], IIf( aInfoSTL[17] == 'D', aInfoSTL[5], NGCONVERHORA( aInfoSTL[5], 'S', 'D' ) ) ), NIL },;
						{ 'D3_LOCAL'  , PadR( If( Empty( aInfoSTL[6] ),SB1->B1_LOCPAD, aInfoSTL[6] ), FWTamSX3( 'D4_LOCAL' )[1] ), NIL },;
						{ 'D3_LOTECTL', aInfoSTL[7], NIL},;
						{ 'D3_NUMLOTE', aInfoSTL[8], NIL},;
						{ 'D3_DTVALID', aInfoSTL[11], NIL},;
						{ 'D3_LOCALIZ', PadR( aInfoSTL[9] , TAmSX3( 'D3_LOCALIZ' )[1]),NIL},;
						{ 'D3_NUMSERI', PadR( aInfoSTL[10], TAmSX3( 'D3_NUMSERI' )[1]),NIL},;
						{ 'D3_ORDEM'  , aInfoSTL[1], Nil},;
						{ 'D3_ITEMCTA', NGSEEK("ST9",STJ->TJ_CODBEM,1,"T9_ITEMCTA"), Nil},;
						{ 'D3_NUMSEQ' , cNumSeq, Nil} } )

	EndIf

	If nOpt241 == 6 // estorno por item
		aAdd( aCab241, {'AUTOESTORN', 'ITEM',  Nil} )
	EndIf

	If ExistBlock( 'NGMOVSD3' )
		
		/*-----------------------------------------------------------------------------------+
        | P.E. para inclusão/alteração de campos passados na geração de Movimentos Internos. |
        +-----------------------------------------------------------------------------------*/
		aIt241 := ExecBlock( 'NGMOVSD3', .F., .F., aIt241 )

	EndIf

	MSExecAuto( { |x,y,z| MATA241(x,y,z) }, aCab241, aIt241, nOpt241 )

	If lMsErroAuto

		If lMsgError
			MostraErro()
		Else
			cError := MostraErro( GetSrvProfString( 'Startpath', '' ) )
		EndIf

		aRetSD3 := { '', .F., cError }

	Else

		/*---------------------------------------------------------+
		| Processo exclusivo para devolução de produto endereçado. |
		+---------------------------------------------------------*/
		If lDevSD3 .And. !Empty( aInfoSTL[9] ) .And. SuperGetMV( 'MV_LOCALIZ', .F., '' ) == 'S' .And.;
			NGSeek( 'SB1', SD3->D3_COD, 1, 'B1_LOCALIZ' ) == 'S'

			lRetSDB := MntExecSDB( SD3->D3_COD, SD3->D3_NUMSEQ, PadR( aInfoSTL[9], TamSX3( 'D3_LOCALIZ' )[1] ),;
				SD3->D3_EMISSAO, SD3->D3_QUANT )

		EndIf

		If lRetSDB

			aRetSD3 := { SD3->D3_NUMSEQ, .T., '' }

			If lIntegRM

				If lReq .And. FwIsInCallStack( 'MNTA720' )

					RecLock( 'SD3', .F. )
						SD3->D3_CUSTO1 := aInfoSTL[18]
					MsUnLock()

				EndIf

				If lReq .Or. lDevSD3
					
					/*----------------------------------------------------------------------------+
					| Realiza o processo de inclusão de um movimento de estoque no BackOffice RM. |
					+----------------------------------------------------------------------------*/
					If !NGMUStoTuO( SD3->( RecNo() ), 'SD3' )

						aRetSD3 := { '', .F., '' }
					
					EndIf

				Else
					
					/*---------------------------------------------------------------------------+
					| Realiza o processo de estorno de um movimento de estoque no BackOffice RM. |
					+---------------------------------------------------------------------------*/
					xRetMU := NGMUCanReq( SD3->( Recno() ), 'SD3', lMsgError, .T. )

					If !xRetMU[1]

						aRetSD3 := { '', xRetMU[1], xRetMU[2] }

					EndIf

				EndIf

			EndIf

		Else

			aRetSD3 := { '', .F., '' }

		EndIf

	EndIf

	RestArea( aAreaSTJ )
	RestArea( aAreaSTL )
	
Return aRetSD3

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} MntExecSDB
ExecAuto que gera os movimentos de endereçamento de produto.
@type function

@author Alexandre Santos
@since 15/02/2022

@param 	cCodPrd, string , Código do produto.
@param 	cNumSEQ, string , Número de sequência do movimento.
@param 	cLocSDB, string , Endereço de destino do produto.
@param  dDtaSDB, date   , Data do endereçamento.
@param  nQntSDB, numeric, Quantidade endereçada.

@return	boolean, Define se o processo foi realizado com sucesso.
/*/
//---------------------------------------------------------------------------------------------
Function MntExecSDB( cCodPrd, cNumSEQ, cLocSDB, dDtaSDB, nQntSDB )
	
	Local aCabecSDA     := {}
    Local aItem         := {}
    Local aItensSDB     := {}
	Local lRet          := .T.
 
    Private lMsHelpAuto := .T.
	Private lMsErroAuto := .F.
 
    /*-----------------------------------------------------------------------+
	| Cabeçalho com a informação do PRODUTO e SEQUENCIA que será endereçado. |
	+-----------------------------------------------------------------------*/
    aAdd( aCabecSDA, { 'DA_PRODUTO', cCodPrd, Nil } )
	aAdd( aCabecSDA, { 'DA_NUMSEQ' , cNumSEQ, Nil } )
	
	/*--------------------------------------+
	| Detalhes do endereçamento de um item. |
	+--------------------------------------*/
	aAdd( aItem, { 'DB_ITEM'   , '0001' , Nil } )
	aAdd( aItem, { 'DB_ESTORNO', ' '    , Nil } )
	aAdd( aItem, { 'DB_LOCALIZ', cLocSDB, Nil } )
	aAdd( aItem, { 'DB_DATA'   , dDtaSDB, Nil } )
	aAdd( aItem, { 'DB_QUANT'  , nQntSDB, Nil } )
    
	/*-----------------------------------------------------+
	| Inclui um intem na listagem de itens para endereçar. |
	+-----------------------------------------------------*/
    aAdd( aItensSDB, aItem )
 
	MSExecAuto( { |x,y,z| MATA265( x, y, z ) }, aCabecSDA, aItensSDB, 3 )
    
	If lMsErroAuto

        MostraErro()
		lRet := .F.

    EndIf

Return lRet

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} MntExecSC1
ExecAuto que gera os Solicitação de Compras.
@type function

@author Alexandre Santos
@since 23/03/2022

@param 	cNumSC  , string , Número da S.C.
@param 	cItemSC , string , Item da S.C.
@param 	aUpdInfo, array  , Detalhes da S.C.
							[1] C1_QUANT   - Quantidade
							[2] C1_PRODUTO - Produto
							[3] C1_LOCAL   - Local de Estoque
							[4] C1_OP      - O.P.
							[5] C1_DATPRF  - Data de Emissão
							[6] C1_CC      - Centro de Custos
							[7] C1_ITEMCTA - Item Contábil
							[8] C1_FORNECE - Fornecedor
							[9] C1_LOJA    - Loja
							[10] C1_OBS    - Observação
@param  nOption , numeric, Operação em processo.

@return	array   , Define se o processo foi realizado com sucesso.
/*/
//---------------------------------------------------------------------------------------------
Function MntExecSC1( cNumSC, cItemSC, aInfo, nOption )

	Local aCabecSC1     := {}
	Local aItensSC1     := {}
	Local aItem         := {}
	Local aHeadBkp      := {}
	Local aRetPE        := {}
	Local aRet          := { .T., '' }
	Local nOptSC1       := nOption

	Private lMsErroAuto := .F.

	If Type( 'aHeader' ) == 'A'
								
		/*-----------------------------------------------------------------------------------------------+
		| A variavél aHeader é utilizada pelo ExecAuto MATA110, como ela encontra-se com escopo private, |
		| seu conteúdo deve ser salvo e a variável zerada.                                               |
		+-----------------------------------------------------------------------------------------------*/
		aHeadBkp := aClone( aHeader )
		aHeader  := {}

	EndIf

	aAdd( aCabecSC1, { 'C1_NUM'    , cNumSC   , Nil } )
	aAdd( aCabecSC1, { 'C1_SOLICIT', cUserName, Nil } )
	aAdd( aCabecSC1, { 'C1_EMISSAO', dDataBase, Nil } )
	
	Do Case

		/*-----------------+
		| Inclusão de S.C. |
		+-----------------*/
		Case nOption == 3

			aAdd( aItem, { 'C1_ITEM'   , cItemSC  , Nil } )
			aAdd( aItem, { 'C1_PRODUTO', aInfo[2] , Nil } )
			aAdd( aItem, { 'C1_QUANT'  , aInfo[1] , Nil } )
			aAdd( aItem, { 'C1_LOCAL'  , aInfo[3] , Nil } )
			aAdd( aItem, { 'C1_OP'     , aInfo[4] , Nil } )
			aAdd( aItem, { 'C1_DATPRF' , aInfo[5] , Nil } )
			aAdd( aItem, { 'C1_CC'     , aInfo[6] , Nil } )
			aAdd( aItem, { 'C1_ITEMCTA', aInfo[7] , Nil } )
			aAdd( aItem, { 'C1_FORNECE', aInfo[8] , Nil } )
			aAdd( aItem, { 'C1_LOJA'   , aInfo[9] , Nil } )
			aAdd( aItem, { 'C1_OBS'    , aInfo[10], Nil } )
			aAdd( aItem, { 'C1_DESCRI' , aInfo[11], Nil } )
			aAdd( aItem, { 'C1_ORIGEM' , FunName(), Nil } )

			dbSelectArea( 'SC1' )
			dbSetOrder( 1 ) // C1_FILIAL + C1_NUM + C1_ITEM + C1_ITEMGRD
			If dbSeek( xFilial( 'SC1' ) + cNumSC )
				
				/*--------------------------------------------------+
				| Carrega no array itens que pertencem a mesma S.C. |
				+--------------------------------------------------*/
				fGetItens( cNumSC, , @aItensSC1 )

				/*-------------------------------------------------------------------------------------+
				| Caso a S.C. já existe, sendo inclusão de um novo item, a operação será de alteração. |
				+-------------------------------------------------------------------------------------*/
				nOptSC1 := 4

			EndIf

		/*------------------+
		| Alteração de S.C. |
		+------------------*/
		Case nOption == 4

			dbSelectArea( 'SC1' )
			dbSetOrder( 1 ) // C1_FILIAL + C1_NUM + C1_ITEM + C1_ITEMGRD
			dbSeek( xFilial( 'SC1' ) + cNumSC + cItemSC )

			aAdd( aItem, { 'C1_ITEM'   , SC1->C1_ITEM   , Nil } )
			aAdd( aItem, { 'C1_PRODUTO', aInfo[2]       , Nil } )
			aAdd( aItem, { 'C1_QUANT'  , aInfo[1]       , Nil } )
			aAdd( aItem, { 'C1_LOCAL'  , aInfo[3]       , Nil } )
			aAdd( aItem, { 'C1_OP'     , SC1->C1_OP     , Nil } )
			aAdd( aItem, { 'C1_DATPRF' , aInfo[5]       , Nil } )
			aAdd( aItem, { 'C1_CC'     , aInfo[6]       , Nil } )
			aAdd( aItem, { 'C1_ITEMCTA', aInfo[7]       , Nil } )
			aAdd( aItem, { 'C1_FORNECE', aInfo[8]       , Nil } )
			aAdd( aItem, { 'C1_LOJA'   , aInfo[9]       , Nil } )
			aAdd( aItem, { 'C1_OBS'    , SC1->C1_OBS    , Nil } )
			aAdd( aItem, { 'C1_DESCRI' , aInfo[11]      , Nil } )
			aAdd( aItem, { 'C1_QTDORIG', SC1->C1_QTDORIG, Nil } )
			aAdd( aItem, { 'C1_ORIGEM' , SC1->C1_ORIGEM , Nil } )
			
			/*--------------------------------------------------+
			| Carrega no array itens que pertencem a mesma S.C. |
			+--------------------------------------------------*/
			fGetItens( SC1->C1_NUM, SC1->C1_ITEM, @aItensSC1 )

		/*----------------+
		| Deleção de S.C. |
		+----------------*/
		Case nOption == 5

			dbSelectArea( 'SC1' )
			dbSetOrder( 1 ) // C1_FILIAL + C1_NUM + C1_ITEM + C1_ITEMGRD
			dbSeek( xFilial( 'SC1' ) + cNumSC + cItemSC )

			NGAtuErp( 'SC1', 'DELETE', SC1->C1_ITEM )

			aAdd( aItem, { 'LINPOS'	   , 'C1_ITEM'    	, SC1->C1_ITEM	} )
			aAdd( aItem, { 'AUTDELETA' , 'S'			, Nil			} )
			aAdd( aItem, { 'C1_PRODUTO', SC1->C1_PRODUTO, Nil			} )
			aAdd( aItem, { 'C1_LOCAL'  , SC1->C1_LOCAL  , Nil			} )
			aAdd( aItem, { 'C1_QUANT'  , SC1->C1_QUANT 	, Nil			} )

			/*-------------------------------------------------------+
			| Deleção por item será interpretada como uma alteração. |
			+-------------------------------------------------------*/
			nOptSC1 := 4

	End Case

	/*-----------------------------------------------------------------+
	| P.E. que permite adicionar campos de usuario na S.C.			   |
	+-----------------------------------------------------------------*/

	If ExistBlock( 'NGALTSC1' )

		aRetPE := ExecBlock( 'NGALTSC1', .F., .F., { aItem, aCabecSC1 } )

		If Len( aRetPE ) != 2

			aItem := aClone( aRetPE )
		
		Else

			aItem     := aClone( aRetPE[1] )

			aCabecSC1 := aClone( aRetPE[2] )

		EndIf

	EndIf

	If aRet[1]
	
		/*-----------------------------------------+
		| Inclui um item na lista de itens da S.C. |
		+-----------------------------------------*/
		aAdd( aItensSC1, aItem )

		/*----------------------------------+
		| Ordena o array pelo campo C1_ITEM |
		+----------------------------------*/
		aSort( aItensSC1, , , { |x,y| x[1,2] < y[1,2] } )

		MSExecAuto( { |x,y,z| MATA110( x, y, z ) }, aCabecSC1, aItensSC1, nOptSC1 )

		If lMsErroAuto

			MostraErro()
			aRet := { .F., '' }

		ElseIf nOption != 5
			
			dbSelectArea( 'SC1' )
			dbSetOrder( 1 ) // C1_FILIAL + C1_NUM + C1_ITEM + C1_ITEMGRD
			dbSeek( xFilial( 'SC1' ) + cNumSC + cItemSC )

		EndIf

	EndIf

	If !Empty( aHeadBkp )

		/*---------------------------------------+
		| Restaura conteúdo da variavél aHeader. |
		+---------------------------------------*/
		aHeader := aClone( aHeadBkp )

	EndIf

	FWFreeArray( aRetPE )
	
Return aRet

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} MntExecSCP
ExecAuto que gera os Solicitação de Armazém.
@type function

@author Alexandre Santos
@since 23/08/2024

@param 	cNumSA  , string , Número da S.A.
@param 	cItemSA , string , Item da S.A.
@param 	aInfoSA , array  , Detalhes da S.A.
							[1] CP_QUANT   - Quantidade
							[2] CP_PRODUTO - Produto
							[3] CP_LOCAL   - Local de Estoque
							[4] CP_OP      - O.P.
							[5] CP_DATPRF  - Data de Emissão
							[6] CP_CC      - Centro de Custos
							[7] CP_ITEMCTA - Item Contábil
							[8] CP_FORNECE - Fornecedor
							[9] CP_LOJA    - Loja
							[10] CP_OBS    - Observação
							[11] CP_DESCRI - Desc. Produto
							[12] CP_UM     - Unidade de Medida
@param  nOption , numeric, Operação em processo.

@return	array   , Define se o processo foi realizado com sucesso.
/*/
//---------------------------------------------------------------------------------------------
Function MntExecSCP( cNumSA, cItemSA, aInfoSA, nOption )

	Local aCabecSCP     := {}
	Local aItensSCP     := {}
	Local aItem         := {}
	Local aRetPE        := {}
	Local aRet          := { .T., '' }
	Local cError        := ''
	Local nOptSCP       := nOption
	Local lOk           := .T.

	Private lMsErroAuto := .F.

	aAdd( aCabecSCP, { 'CP_NUM'    , cNumSA   , Nil } )
	
	Do Case

		/*-----------------+
		| Inclusão de S.A. |
		+-----------------*/
		Case nOption == 3

			dbSelectArea( 'SCP' )
			dbSetOrder( 1 ) // CP_FILIAL + CP_NUM + CP_ITEM
			If msSeek( FWxFilial( 'SCP' ) + cNumSA )
				
				/*--------------------------------------------------+
				| Carrega no array itens que pertencem a mesma S.A. |
				+--------------------------------------------------*/
				fGetItsSA( SCP->CP_NUM, , @aItensSCP )

				/*----------------------------------------------------+
				| Quando a S.A. existir utiliza o CP_EMISSÃO gravado. |
				+----------------------------------------------------*/
				aAdd( aCabecSCP, { 'CP_EMISSAO', SCP->CP_EMISSAO, Nil } )

				/*-------------------------------------------------------------------------------------+
				| Caso a S.A. já existe, sendo inclusão de um novo item, a operação será de alteração. |
				+-------------------------------------------------------------------------------------*/
				nOptSCP := 4

				/*--------------------------------------------+
				| Quando alteração deve enviar o campo CP_NUM |
				+--------------------------------------------*/
				aAdd( aItem, { 'CP_NUM', SCP->CP_NUM, Nil } )

			Else
				
				/*---------------------------------------------------------+
				| Para uma nova S.A. utiliza data de sistema para emissão. |
				+---------------------------------------------------------*/
				aAdd( aCabecSCP, { 'CP_EMISSAO', dDataBase, Nil } )

			EndIf

			aAdd( aCabecSCP, { 'CP_SOLICIT', cUserName, Nil } )

			aAdd( aItem, { 'CP_ITEM'   , cItemSA    , Nil } )
			aAdd( aItem, { 'CP_PRODUTO', aInfoSA[2] , Nil } )
			aAdd( aItem, { 'CP_UM'     , aInfoSA[12], Nil } )
			aAdd( aItem, { 'CP_QUANT'  , aInfoSA[1] , Nil } )
			aAdd( aItem, { 'CP_LOCAL'  , aInfoSA[3] , Nil } )
			aAdd( aItem, { 'CP_OP'     , aInfoSA[4] , Nil } )
			aAdd( aItem, { 'CP_DATPRF' , aInfoSA[5] , Nil } )
			aAdd( aItem, { 'CP_CC'     , aInfoSA[6] , Nil } )
			aAdd( aItem, { 'CP_ITEMCTA', aInfoSA[7] , Nil } )
			aAdd( aItem, { 'CP_OBS'    , aInfoSA[10], Nil } )
			aAdd( aItem, { 'CP_DESCRI' , aInfoSA[11], Nil } )

		/*------------------+
		| Alteração de S.A. |
		+------------------*/
		Case nOption == 4

			dbSelectArea( 'SCP' )
			dbSetOrder( 1 ) // CP_FILIAL + CP_NUM + CP_ITEM
			If msSeek( FWxFilial( 'SCP' ) + cNumSA + cItemSA )

				aAdd( aCabecSCP, { 'CP_EMISSAO', SCP->CP_EMISSAO, Nil } )
				aAdd( aCabecSCP, { 'CP_SOLICIT', SCP->CP_SOLICIT, Nil } )

				aAdd( aItem, { 'CP_NUM'    , SCP->CP_NUM , Nil } )
				aAdd( aItem, { 'CP_ITEM'   , SCP->CP_ITEM, Nil } )
				aAdd( aItem, { 'CP_PRODUTO', aInfoSA[2]  , Nil } )
				aAdd( aItem, { 'CP_UM'     , aInfoSA[12] , Nil } )
				aAdd( aItem, { 'CP_QUANT'  , aInfoSA[1]  , Nil } )
				aAdd( aItem, { 'CP_LOCAL'  , aInfoSA[3]  , Nil } )
				aAdd( aItem, { 'CP_OP'     , SCP->CP_OP  , Nil } )
				aAdd( aItem, { 'CP_DATPRF' , aInfoSA[5]  , Nil } )
				aAdd( aItem, { 'CP_CC'     , aInfoSA[6]  , Nil } )
				aAdd( aItem, { 'CP_ITEMCTA', aInfoSA[7]  , Nil } )
				aAdd( aItem, { 'CP_OBS'    , aInfoSA[10] , Nil } )
				aAdd( aItem, { 'CP_DESCRI' , aInfoSA[11] , Nil } )
				
				/*--------------------------------------------------+
				| Carrega no array itens que pertencem a mesma S.A. |
				+--------------------------------------------------*/
				fGetItsSA( SCP->CP_NUM, SCP->CP_ITEM, @aItensSCP )

			EndIf

		/*----------------+
		| Deleção de S.A. |
		+----------------*/
		Case nOption == 5

			dbSelectArea( 'SCP' )
			dbSetOrder( 1 ) // CP_FILIAL + CP_NUM + CP_ITEM
			msSeek( FWxFilial( 'SCP' ) + cNumSA + cItemSA )

			aAdd( aCabecSCP, { 'CP_EMISSAO', SCP->CP_EMISSAO, Nil } )

			aAdd( aItem, { 'CP_NUM'    , SCP->CP_NUM    , Nil } )
			aAdd( aItem, { 'CP_ITEM'   , SCP->CP_ITEM   , Nil } )
			aAdd( aItem, { 'CP_PRODUTO', SCP->CP_PRODUTO, Nil } )
			aAdd( aItem, { 'CP_LOCAL'  , SCP->CP_LOCAL  , Nil } )
			aAdd( aItem, { 'CP_QUANT'  , SCP->CP_QUANT 	, Nil } )
			aAdd( aItem, { 'CP_OP'     , SCP->CP_OP     , Nil } )
			aAdd( aItem, { 'CP_DATPRF' , SCP->CP_DATPRF , Nil } )
			aAdd( aItem, { 'AUTDELETA' , 'S'			, Nil } )

			nOptSCP := 4

	End Case

	If ExistBlock( 'NGALTSCP' )

		aRetPE := ExecBlock( 'NGALTSCP', .F., .F., { aItem, aCabecSCP } )

		If !Empty( aRetPE )

			aItem     := aClone( aRetPE[1] )
			aCabecSCP := aClone( aRetPE[2] )

		EndIf

	EndIf

	If aRet[1]

		/*-----------------------------------------+
		| Inclui um item na lista de itens da S.A. |
		+-----------------------------------------*/
		aAdd( aItensSCP, aItem )

		/*----------------------------------+
		| Ordena o array pelo campo CP_ITEM |
		+----------------------------------*/
		aSort( aItensSCP, , , { |x,y| x[1,2] < y[1,2] } )

		MSExecAuto( { |x,y,z| MATA105( x, y, z ) }, aCabecSCP, aItensSCP, nOptSCP )

		If lMsErroAuto

			If !IsBlind()
				
				MostraErro()

			Else

				cError := MostraErro( GetSrvProfString( 'Startpath', '' ) )

			EndIf
			
			aRet := { .F., cError }

		ElseIf nOption != 5
			
			dbSelectArea( 'SCP' )
			dbSetOrder( 1 ) // CP_FILIAL + CP_NUM + CP_ITEM
			msSeek( FWxFilial( 'SCP' ) + cNumSA + cItemSA )

			If SuperGetMV( 'MV_NGINTER', .F., 'N' ) == 'M'

				If !NGMUReques( SCP->( RecNo() ), 'SCP', .F., nOptSCP )

					aRet := { .F., STR1490 } // Falha ao integrar com BackOffice RM

				EndIf

			EndIf

		EndIf

	EndIf

	FWFreeArray( aCabecSCP )
	FWFreeArray( aItensSCP )
	FWFreeArray( aItem )
	FWFreeArray( aRetPE )
	
Return aRet

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} MntExecSD4
ExecAuto que manipula empenhos da tabela SD4 e seus relacionamentos.
@type function

@author Alexandre Santos
@since 03/02/2022

@param 	cOP	    , string , Código da Ordem de Produção relacionada aos empenhos.
@param 	aEmpAuto, array  , Matriz com detalhes do empenho
							[1] - D4_COD     
							[2] - D4_LOCAL 	 
							[3] - D4_DATA	 
							[4] - D4_QTDEORI 
							[5] - D4_QUANT	
							[6] - D4_TRT	 
							[7] - Matriz com detalhes de endereço 
								[7,1] - DC_LOCALIZ
								[7,2] - DC_QUANT
@param 	nOptSD4 , numeric, Operação acionada ( 3 - Inclusão, 4 - Alterção e 5 - Exclusão )

@return	array  , [1] - Define se o processo foi realizado com sucesso.
				 [2] - Mensagem de Erro(ainda não implementado, deixado preparado para o MNTNG)
/*/
//---------------------------------------------------------------------------------------------
Function MntExecSD4( cOP, aEmpAuto, nOptSD4 )

	Local aAreaSD4  := SD4->( GetArea() )
	Local aCabecSD4 := {}
	Local aLine     := {}
	Local aLocaliz  := {}
	Local aLineLoc  := {}
	Local aLinesSD4 := {}
	Local cError    := ''
	Local nInd1     := 0
	Local nInd2     := 0
	Local lDelAll   := !FwIsInCallStack( 'NGDELETOS' )
	Local lRet      := .T.

	Private lMsHelpAuto := .T.
	Private lMsErroAuto := .F.
	
	/*-------------------------------------------------------------+
	| Cabeçalho do empenho, identificando a O.P que será vinculada |
	+-------------------------------------------------------------*/
	aAdd( aCabecSD4, { 'D4_OP', cOP, Nil } )

	Do Case
		
		/*---------+
		| Inclusão |
		+---------*/
		Case nOptSD4 == 3

			For nInd1 := 1 To Len( aEmpAuto )

				aLine := {}

				aAdd( aLine, { 'D4_OP'     , cOP              , Nil } )
				aAdd( aLine, { 'D4_COD'    , aEmpAuto[nInd1,1], Nil } )
				aAdd( aLine, { 'D4_LOCAL'  , aEmpAuto[nInd1,2], Nil } )
				aAdd( aLine, { 'D4_DATA'   , aEmpAuto[nInd1,3], Nil } )
				aAdd( aLine, { 'D4_QTDEORI', aEmpAuto[nInd1,4], Nil } )
				aAdd( aLine, { 'D4_QUANT'  , aEmpAuto[nInd1,5], Nil } )
				aAdd( aLine, { 'D4_TRT'    , aEmpAuto[nInd1,6], Nil } )

				/*---------------------------------+
				| Processo de empenho por endereço |
				+---------------------------------*/
				If !Empty( aEmpAuto[nInd1,7] )

					aLocaliz := {}

					For nInd2 := 1 To Len( aEmpAuto[nInd1,7] )

						aLineLoc := {}

						aAdd( aLineLoc, { 'DC_LOCALIZ', aEmpAuto[nInd1,7,nInd2,1], Nil } )
    					aAdd( aLineLoc, { 'DC_QUANT'  , aEmpAuto[nInd1,7,nInd2,2], Nil } )

						aAdd( aLocaliz, aLineLoc )

					Next nInd2

					/*-------------------------------------------------------------------------+
					| Adiciona o identificador AUT_D4_END para listas os endereços de empenho. |
					+-------------------------------------------------------------------------*/
					aAdd( aLine, { 'AUT_D4_END', aLocaliz, Nil } )

				EndIf

				/*-----------------------------------------------------------+
				| Incluir as informações do empenho no listagem de empenhos. |
				+-----------------------------------------------------------*/
				aAdd( aLinesSD4, aLine )
				
			Next nInd1

		/*----------+
		| Alteração |
		+----------*/
		Case nOptSD4 == 4
			
			/*----------------------------------------------+
			| Utilizar o índice 2 para efetuar a alteração. |
			+----------------------------------------------*/
			aAdd( aCabecSD4, { 'INDEX', 2, Nil } )

			For nInd1 := 1 To Len( aEmpAuto )

				aLine := {}

				dbSelectArea( 'SD4' )
				dbSetOrder( 2 ) // D4_FILIAL + D4_OP + D4_COD + D4_LOCAL
				If msSeek( FWxFilial( 'SD4' ) + cOP + aEmpAuto[nInd1,1] + aEmpAuto[nInd1,2] )

					/*--------------------------------------------------+
					| Carrega as informações do empenho conforme a SD4. |
					+--------------------------------------------------*/
					For nInd2 := 1 To SD4->( FCount() )

						If SD4->( Field( nInd2 ) ) == 'D4_QUANT' .Or.;
							SD4->( Field( nInd2 ) ) == 'D4_QTDEORI'

							Loop

						EndIf
						
						aAdd( aLine, { SD4->( Field( nInd2 ) ), SD4->( FieldGet( nInd2 ) ), Nil } )
					
					Next nInd2

					/*--------------------------------------------+
					| Preenche array com as informações alteradas |
					+--------------------------------------------*/
					aAdd( aLine, { 'D4_QTDEORI', aEmpAuto[nInd1,4], Nil } )
					aAdd( aLine, { 'D4_QUANT'  , aEmpAuto[nInd1,5], Nil } )

					/*-------------------------------------------------------------------------+
					| Adiciona o identificador LINPOS para posicionar registro correto na SD4. |
					+-------------------------------------------------------------------------*/
					aAdd( aLine, { 	'LINPOS',;
									'D4_COD+D4_TRT+D4_LOTECTL+D4_NUMLOTE+D4_LOCAL+D4_OPORIG+D4_SEQ',;
									SD4->D4_COD    ,;
									SD4->D4_TRT    ,;
									SD4->D4_LOTECTL,;
									SD4->D4_NUMLOTE,;
									SD4->D4_LOCAL  ,;
									SD4->D4_OPORIG ,;
									SD4->D4_SEQ } )

					/*---------------------------------+
					| Processo de empenho por endereço |
					+---------------------------------*/
					If !Empty( aEmpAuto[nInd1,7] )

						aLocaliz := {}

						For nInd2 := 1 To Len( aEmpAuto[nInd1,7] )

							aLineLoc := {}

							dbSelectArea( 'SDC' )
							dbSetOrder( 2 ) // DC_FILIAL + DC_PRODUTO + DC_LOCAL + DC_OP + DC_TRT + DC_LOTECTL + DC_NUMLOTE + DC_LOCALIZ + DC_NUMSERI
							If msSeek( FWxFilial( 'SDC' ) + SD4->D4_COD + SD4->D4_LOCAL + SD4->D4_OP + SD4->D4_TRT + SD4->D4_LOTECTL + SD4->D4_NUMLOTE + aEmpAuto[nInd1,7,nInd2,1] )
								
								/*---------------------------------------------------------------------------+
								| Adiciona o identificador LINPOS para posicionar o registro correto na SDC. |
								+---------------------------------------------------------------------------*/
								aAdd( aLineLoc, { 	'LINPOS'               ,;
													'DC_LOCALIZ+DC_NUMSERI',;
													SDC->DC_LOCALIZ        ,;
													SDC->DC_NUMSERI } )
							
							EndIf

							aAdd( aLineLoc, { 'DC_LOCALIZ', aEmpAuto[nInd1,7,nInd2,1], Nil } )
							aAdd( aLineLoc, { 'DC_QUANT'  , aEmpAuto[nInd1,7,nInd2,2], Nil } )
							
							aAdd( aLocaliz, aLineLoc )

						Next nInd2
						
						/*-------------------------------------------------------------------------+
						| Adiciona o identificador AUT_D4_END para listas os endereços de empenho. |
						+-------------------------------------------------------------------------*/
						aAdd( aLine, { 'AUT_D4_END', aLocaliz, Nil } )

					EndIf

				Else

					aAdd( aLine, { 'D4_OP'     , cOP              , Nil } )
					aAdd( aLine, { 'D4_COD'    , aEmpAuto[nInd1,1], Nil } )
					aAdd( aLine, { 'D4_LOCAL'  , aEmpAuto[nInd1,2], Nil } )
					aAdd( aLine, { 'D4_DATA'   , aEmpAuto[nInd1,3], Nil } )
					aAdd( aLine, { 'D4_QTDEORI', aEmpAuto[nInd1,4], Nil } )
					aAdd( aLine, { 'D4_QUANT'  , aEmpAuto[nInd1,5], Nil } )
					aAdd( aLine, { 'D4_TRT'    , aEmpAuto[nInd1,6], Nil } )

					/*---------------------------------+
					| Processo de empenho por endereço |
					+---------------------------------*/
					If !Empty( aEmpAuto[nInd1,7] )

						aLocaliz := {}

						For nInd2 := 1 To Len( aEmpAuto[nInd1,7] )

							aLineLoc := {}

							aAdd( aLineLoc, { 'DC_LOCALIZ', aEmpAuto[nInd1,7,nInd2,1], Nil } )
							aAdd( aLineLoc, { 'DC_QUANT'  , aEmpAuto[nInd1,7,nInd2,2], Nil } )

							aAdd( aLocaliz, aLineLoc )

						Next nInd2

						/*-------------------------------------------------------------------------+
						| Adiciona o identificador AUT_D4_END para listas os endereços de empenho. |
						+-------------------------------------------------------------------------*/
						aAdd( aLine, { 'AUT_D4_END', aLocaliz, Nil } )

					EndIf

				EndIf

				/*-----------------------------------------------------------+
				| Incluir as informações do empenho no listagem de empenhos. |
				+-----------------------------------------------------------*/
				aAdd( aLinesSD4, aLine )

			Next nInd1
		
		/*---------+
		| Exclusão |
		+---------*/
		Case nOptSD4 == 5
		
			/*----------------------------------------------+
			| Utilizar o índice 2 para efetuar a alteração. |
			+----------------------------------------------*/
			aAdd( aCabecSD4, { 'INDEX', 2  , Nil } )

			/*-----------------------------------------------------------------------------------------+
			| Valida se deleta todos os empenhos da O.P. ou se está possui mais de um produto distinto |
			| empenhado, neste caso será acionado o ExecAuto em modo alteração deletando pontualmente  |
			| o produto recebido por parâmetro.                                                        |
			+-----------------------------------------------------------------------------------------*/
			If lDelAll .And. fQntSD4( cOP ) 

				dbSelectArea( 'SD4' )
				dbSetOrder( 2 ) // D4_FILIAL + D4_OP + D4_COD + D4_LOCAL
				If dbSeek( xFilial( 'SD4' ) + cOP + aEmpAuto[1,1] + aEmpAuto[1,2] )

					If Trim( SuperGetMv( 'MV_NGINTER', .F., 'N') ) == 'L'

						/*-----------------+
						| Integração LOGIX |
						+-----------------*/
						NGAtuErp( 'SD4', 'DELETE' )

					EndIf


					nOptSD4 := 4

					/*--------------------------------------------------+
					| Carrega as informações do empenho conforme a SD4. |
					+--------------------------------------------------*/
					For nInd1 := 1 To SD4->( FCount() )
						aAdd( aLine, { SD4->( Field( nInd1 ) ), SD4->( FieldGet( nInd1 ) ), Nil } )
					Next nInd1

					/*---------------------------------------------------------------------------+
					| Adiciona o identificador LINPOS para posicionar o registro correto na SD4. |
					+---------------------------------------------------------------------------*/
					aAdd( aLine, { 	'LINPOS',;
									'D4_COD+D4_TRT+D4_LOTECTL+D4_NUMLOTE+D4_LOCAL+D4_OPORIG+D4_SEQ',;
									SD4->D4_COD    ,;
									SD4->D4_TRT    ,;
									SD4->D4_LOTECTL,;
									SD4->D4_NUMLOTE,;
									SD4->D4_LOCAL  ,;
									SD4->D4_OPORIG ,;
									SD4->D4_SEQ } )

					/*---------------------------------------------------------------------------------+
					| Adiciona o identificador AUTDELETA para definir que este registro será deletado. |
					+---------------------------------------------------------------------------------*/
					aAdd( aLine,{ 'AUTDELETA', 'S', Nil } )

					/*-----------------------------------------------------------+
					| Incluir as informações do empenho no listagem de empenhos. |
					+-----------------------------------------------------------*/
					aAdd( aLinesSD4, aLine )

				EndIf

			EndIf

		/*-----------------------------------+
		| Zera Empenho - Finalização de O.S. |
		+-----------------------------------*/
		Case nOptSD4 == 0

			nOptSD4 := 4

			/*-----------------------------------------------------------------------------------+
			| Adiciona o identificador AUTZERAEMP para que seja zerado todos os empenhos da O.P. |
			+-----------------------------------------------------------------------------------*/
            aAdd( aCabecSD4, { 'AUTZERAEMP', .T., Nil } )

			/*----------------------------------------------+
			| Utilizar o índice 2 para efetuar a alteração. |
			+----------------------------------------------*/
			aAdd( aCabecSD4, { 'INDEX', 2  , Nil } )

	End Case

	MSExecAuto( { |x,y,z| MATA381( x, y, z ) }, aCabecSD4, aLinesSD4, nOptSD4 )

	If lMsErroAuto

		MostraErro()

		lRet := .F.

	EndIf

	RestArea( aAreaSD4 )

	/*--------------------------------------------------+
	| Desaloca consumo de memória p/ melhor performance |
	+--------------------------------------------------*/
	aSize( aAreaSD4, 0 )
	aAreaSD4 := Nil

	aSize( aCabecSD4, 0 )
	aCabecSD4 := Nil

	aSize( aLine, 0 )
	aLine := Nil

	aSize( aLocaliz, 0 )
	aLocaliz := Nil

	aSize( aLineLoc, 0 )
	aLineLoc := Nil

	aSize( aLinesSD4, 0 )
	aLinesSD4 := Nil

Return { lRet, cError }

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} MntUseExec
Verifica se é possivel utilizar o ExecAuto MATA381, devido a inconsistências no dicionário.
@type function

@author Alexandre Santos
@since 03/02/2022

@param 	
@return	boolean, Define se pode ser utilizado o ExecAuto.

@ToDo pode ser descontinuada após a realese 12.1.37, pois o SIGAPCP deve alterar estes campos
no dicionário.
/*/
//---------------------------------------------------------------------------------------------
Function MntUseExec( cAlias )

	Local lRet     := .T.
	Local nInd1    := 0
	Local aFields  := {}

	Default cAlias := ''
	
	/*----------------------------------------------------------------+
	| Adiciona campos de empenho(SD4) no valid. de USO no dicionário. |
	+----------------------------------------------------------------*/
	If Empty( cAlias ) .Or. cAlias == 'SD4'

		aAdd( aFields, 'D4_COD' )
		aAdd( aFields, 'D4_TRT' )
		aAdd( aFields, 'D4_LOTECTL' )
		aAdd( aFields, 'D4_NUMLOTE' )
		aAdd( aFields, 'D4_LOCAL' )
		aAdd( aFields, 'D4_OPORIG' )
		aAdd( aFields, 'D4_SEQ' )
		aAdd( aFields, 'D4_DTVALID' )

	EndIf

	/*--------------------------------------------------------------------------+
	| Adiciona campos de empenho por endereço(SDC) no valid. USO no dicionário. |
	+--------------------------------------------------------------------------*/
	If Empty( cAlias ) .Or. cAlias == 'SDC'

		aAdd( aFields, 'DC_ORIGEM' )
		aAdd( aFields, 'DC_PRODUTO' )
		aAdd( aFields, 'DC_LOCAL' )
		aAdd( aFields, 'DC_LOCALIZ' )
		aAdd( aFields, 'DC_NUMSERI' )
		aAdd( aFields, 'DC_LOTECTL' )
		aAdd( aFields, 'DC_NUMLOTE' )
		aAdd( aFields, 'DC_QUANT' )
		aAdd( aFields, 'DC_OP' )
		aAdd( aFields, 'DC_TRT' )
		aAdd( aFields, 'DC_PEDIDO' )
		aAdd( aFields, 'DC_ITEM' )
		aAdd( aFields, 'DC_QTDORIG' )
		aAdd( aFields, 'DC_SEQ' )

	EndIf

	If ( FwIsInCallStack( 'NG420INC' ) .Or. FwIsInCallStack( 'MNTA435' ) .Or. FwIsInCallStack( 'MNTA420' ) .Or.;
		 FwIsInCallStack( 'NG410INC' ) .Or. FwIsInCallStack( 'MNTA265' ) ) .And. NgVldRpo( { { 'MNTUTIL_OS.prw', SToD( '20221018' ), '16:00' } } )

		For nInd1 := 1 To Len( aFields )

			If !X3Uso( Posicione( 'SX3', 2, aFields[nInd1], 'X3_USADO' ) )
				lRet := .F.
				Exit
			EndIf
			
		Next nInd1

	Else

		lRet := .F.

	EndIf
	
Return lRet

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} fQntSD4
Verifica a quantidade de produtos empenhados para uma determinada O.P.
@type function

@author Alexandre Santos
@since 03/02/2022

@param 	cOP	   , string , Código da Ordem de Produção relacionada aos empenhos.
@return	boolean, Define se a quantidade é superior a 1.
/*/
//---------------------------------------------------------------------------------------------
Static Function fQntSD4( cOP )

	Local cAlsSD4 := GetNextAlias()
	Local lRet    := .T.

	BeginSQL Alias cAlsSD4

		SELECT
			COUNT( SD4.D4_OP ) AS QTDE_REG
		FROM
			%table:SD4% SD4
		WHERE
			SD4.D4_FILIAL = %xFilial:SD4% AND
			SD4.D4_OP     = %exp:cOP%     AND
			SD4.%NotDel%

	EndSQL

	// Existem mais de um registro associado a está O.P.
	lRet := (cAlsSD4)->QTDE_REG > 1

	(cAlsSD4)->( dbCloseArea() ) 
	
Return lRet

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} fGetItens
Carrega itens da mesma S.C.
@type function

@author Alexandre Santos
@since 26/05/2022

@param 	cNumSC	 , string, Código da S.C.
@param 	cItemSC	 , string, Item da S.C.
@param 	aItensSC1, array , Lista dos itens da S.C.
@return	
/*/
//---------------------------------------------------------------------------------------------
Static Function fGetItens( cNumSC, cItemSC, aItensSC1 )

	Local aItem   := {}
	Local cAlsSC1 := GetNextAlias()
	Local cWhere  := '%' + IIf( !Empty( cItemSC ), 'AND SC1.C1_ITEM <> ' + ValToSQL( cItemSC ), '' ) + '%'

	BeginSQL Alias cAlsSC1

		SELECT
			SC1.C1_ITEM   ,  
			SC1.C1_QUANT  ,
			SC1.C1_PRODUTO,
			SC1.C1_LOCAL  ,
			SC1.C1_OP     ,
			SC1.C1_DATPRF ,
			SC1.C1_CC     ,
			SC1.C1_ITEMCTA,
			SC1.C1_FORNECE,
			SC1.C1_LOJA   ,
			SC1.C1_OBS    ,
			SC1.C1_DESCRI ,
			SC1.C1_QTDORIG,
			SC1.C1_ORIGEM
		FROM
			%table:SC1% SC1
		WHERE
			SC1.C1_FILIAL  = %xFilial:SC1% AND
			SC1.C1_NUM     = %exp:cNumSC%  AND
			SC1.C1_PEDIDO  = ' '           AND
			SC1.C1_COTACAO = ' '           AND
			SC1.%NotDel%
			%exp:cWhere%

	EndSQL 

	While (cAlsSC1)->( !EoF() )

		aItem := {}

		aAdd( aItem, { 'C1_ITEM'   , (cAlsSC1)->C1_ITEM          , Nil } )
		aAdd( aItem, { 'C1_QUANT'  , (cAlsSC1)->C1_QUANT         , Nil } )
		aAdd( aItem, { 'C1_PRODUTO', (cAlsSC1)->C1_PRODUTO       , Nil } )
		aAdd( aItem, { 'C1_LOCAL'  , (cAlsSC1)->C1_LOCAL         , Nil } )
		aAdd( aItem, { 'C1_OP'     , (cAlsSC1)->C1_OP            , Nil } )
		aAdd( aItem, { 'C1_DATPRF' , SToD( (cAlsSC1)->C1_DATPRF ), Nil } )
		aAdd( aItem, { 'C1_CC'     , (cAlsSC1)->C1_CC            , Nil } )
		aAdd( aItem, { 'C1_ITEMCTA', (cAlsSC1)->C1_ITEMCTA       , Nil } )
		aAdd( aItem, { 'C1_FORNECE', (cAlsSC1)->C1_FORNECE       , Nil } )
		aAdd( aItem, { 'C1_LOJA'   , (cAlsSC1)->C1_LOJA          , Nil } )
		aAdd( aItem, { 'C1_OBS'    , (cAlsSC1)->C1_OBS           , Nil } )
		aAdd( aItem, { 'C1_DESCRI' , (cAlsSC1)->C1_DESCRI        , Nil } )
		aAdd( aItem, { 'C1_QTDORIG', (cAlsSC1)->C1_QTDORIG       , Nil } )
		aAdd( aItem, { 'C1_ORIGEM' , (cAlsSC1)->C1_ORIGEM        , Nil } )

		If ExistBlock( 'NGALTSC1' )
			aItem := ExecBlock( 'NGALTSC1', .F., .F., { aItem, {} } )[ 1 ]
		EndIf

		aAdd( aItensSC1, aItem )

		(cAlsSC1)->( dbSkip() )

	End

	(cAlsSC1)->( dbCloseArea() )
	
Return

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} fGetItsSA
Carrega itens da mesma S.A.
@type function

@author Alexandre Santos
@since 23/08/2024

@param 	cNumSA	 , string, Código da S.A.
@param 	[cItemSA], string, Item da S.A.
@param 	aItensSCP, array , Lista dos itens da S.A.
@return	
/*/
//---------------------------------------------------------------------------------------------
Static Function fGetItsSA( cNumSA, cItemSA, aItensSCP )

	Local aItem     := {}
	Local cAlsSCP   := GetNextAlias()

	Default cItemSA := ' '

	If Empty( cQryItemSA )

		cQryItemSA := "SELECT "
		cQryItemSA +=	"SCP.CP_NUM    , "  
		cQryItemSA +=	"SCP.CP_ITEM   , "  
		cQryItemSA +=	"SCP.CP_PRODUTO, "
		cQryItemSA +=	"SCP.CP_UM     , "
		cQryItemSA +=	"SCP.CP_QUANT  , "
		cQryItemSA +=	"SCP.CP_LOCAL  , "
		cQryItemSA +=	"SCP.CP_OP     , "
		cQryItemSA +=	"SCP.CP_DATPRF , "
		cQryItemSA +=	"SCP.CP_CC     , "
		cQryItemSA +=	"SCP.CP_ITEMCTA, "
		cQryItemSA +=	"SCP.CP_OBS    , "
		cQryItemSA +=	"SCP.CP_DESCRI   "
		cQryItemSA += "FROM "
		cQryItemSA +=	RetSQLName( 'SCP' ) + " SCP "
		cQryItemSA += "WHERE "
		cQryItemSA +=	"SCP.CP_FILIAL   = ?   AND "
		cQryItemSA +=	"SCP.CP_NUM      = ?   AND "
		cQryItemSA +=	"SCP.CP_ITEM    <> ?   AND "
		cQryItemSA +=	"SCP.CP_STATUS   = ' ' AND "
		cQryItemSA +=	"SCP.CP_PREREQU <> 'S' AND "
		cQryItemSA +=	"SCP.D_E_L_E_T_ = ' ' "

		cQryItemSA := ChangeQuery( cQryItemSA )

	EndIf

	aBind := {}
	aAdd( aBind, FWxFilial( 'SCP' ) )
	aAdd( aBind, cNumSA )
	aAdd( aBind, cItemSA )

	dbUseArea( .T., 'TOPCONN', TcGenQry2( , , cQryItemSA, aBind ), cAlsSCP, .T., .T. )

	While (cAlsSCP)->( !EoF() )

		aItem := {}

		aAdd( aItem, { 'CP_NUM'    , (cAlsSCP)->CP_NUM           , Nil } )
		aAdd( aItem, { 'CP_ITEM'   , (cAlsSCP)->CP_ITEM          , Nil } )
		aAdd( aItem, { 'CP_PRODUTO', (cAlsSCP)->CP_PRODUTO       , Nil } )
		aAdd( aItem, { 'CP_UM'     , (cAlsSCP)->CP_UM            , Nil } )
		aAdd( aItem, { 'CP_QUANT'  , (cAlsSCP)->CP_QUANT         , Nil } )
		aAdd( aItem, { 'CP_LOCAL'  , (cAlsSCP)->CP_LOCAL         , Nil } )
		aAdd( aItem, { 'CP_OP'     , (cAlsSCP)->CP_OP            , Nil } )
		aAdd( aItem, { 'CP_DATPRF' , SToD( (cAlsSCP)->CP_DATPRF ), Nil } )
		aAdd( aItem, { 'CP_CC'     , (cAlsSCP)->CP_CC            , Nil } )
		aAdd( aItem, { 'CP_ITEMCTA', (cAlsSCP)->CP_ITEMCTA       , Nil } )
		aAdd( aItem, { 'CP_OBS'    , (cAlsSCP)->CP_OBS           , Nil } )
		aAdd( aItem, { 'CP_DESCRI' , (cAlsSCP)->CP_DESCRI        , Nil } )

		aAdd( aItensSCP, aClone( aItem ) )

		(cAlsSCP)->( dbSkip() )

	End

	(cAlsSCP)->( dbCloseArea() )

	FWFreeArray( aItem )
	
Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NGNIVELSTC
ReTOrna o Nível na Estrutura do bem

@author Paulo Pego
@since 06/07/99

@return boolean

@use GERAL
/*/
//---------------------------------------------------------------------
Function NGNIVELSTC(CXX)
Local NYY := 0, cFilho := CXX

If Empty(CXX)
   Return " "
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se e um bem filho e em que nivel ele esta                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
STC->(dbSeTOrder(3))
WHile .T.
   If !STC->( dbSeek(xFilial('STC') + cFILHO) )
      Exit
   EndIf

   NYY := NYY + 1
   cFILHO := STC->TC_CODBEM
End

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se Nivel for igual a 0 verifica se o bem esta na estrutura           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
STC->(dbSeTOrder(1))
If NYY == 0
   If !STC->( dbSeek(xFilial('STC') + CXX) )
      NYY := -1
   EndIf
EndIf

CYY := If(NYY == -1, " ", Str(NYY,1) )

Return CYY

//---------------------------------------------------------------------
/*/{Protheus.doc} NGPROCETA
Inclui/Exclui Uma etapa

@author Paulo Pego
@since 17/09/99

@return boolean

@use GERAL
/*/
//---------------------------------------------------------------------
Function NGPROCETA(cALIAS,nREG,nOPCX)

	Local lRet		:= .T.
	Local nOPCA     := 0

	Private lUSATARL := If(FindFunction("NGUSATARPAD"),NGUSATARPAD(),.F.)
	Private cCadastro := OemTOAnsi(STR0014) //"Etapas da O.S."
	Private cVALIDTAR, cVALIDETA


	aCOLS   := {}
	lCORRET := If(Val(stj->tj_plano) = 0,.T.,.F.)

	M->TQ_TAREFA  := Space(TAMSX3("TQ_TAREFA")[1])
	M->TQ_NOMTARE := Space(TAMSX3("TQ_NOMTARE")[1])
	M->TQ_ETAPA   := Space(TAMSX3("TQ_ETAPA")[1])
	M->TQ_NOMETAP := Space(TAMSX3("TQ_NOMETAP")[1])
	M->TQ_SEQETA  := Space(TAMSX3("TQ_SEQETA")[1])

	If nOPCX == 2
		M->TQ_TAREFA  := (cTRBQ400)->TQ_TAREFA
		M->TQ_NOMTARE := NGNOMETAR(STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,M->TQ_TAREFA)

		TPA->( dbSeek(xFilial("TPA") + (cTRBQ400)->TQ_ETAPA) )
		M->TQ_ETAPA   := (cTRBQ400)->TQ_ETAPA
		M->TQ_NOMETAP := TPA->TPA_DESCRI
		M->TQ_SEQETA  := (cTRBQ400)->TQ_SEQETA
	EndIf

	If nOPCx <> 1
		If Empty(M->TQ_ETAPA)
			Return
		EndIf
	EndIf

	If ExistBlock("NGPROETA")
		If !ExecBlock("NGPROETA",.F.,.F.,{nOPCX})
			Return
		EndIf
	Else

		cF3T := "ST5"

		If lUSATARL .And. lCORRET
			cF3T := "TT9"
		EndIf

		cVALIDTAR := "If(!Empty(M->TQ_TAREFA),NGSTLTAR(STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,M->TQ_TAREFA),.F.)"

		DEFINE MSDIALOG oDlg5 TITLE cCADASTRO+'  '+Alltrim(stj->tj_ordem)+' - '+If(nOPCX = 1,STR0003,STR0067) FROM 16,17 TO 35,76 OF oMainWnd

			oPainel01 := TPanel():New(00,00,,oDLG5,,,,,,0,115,.F.,.F.)
			oPainel01:Align := CONTROL_ALIGN_ALLCLIENT
			@ 10.5,05 SAY OemTOAnsi(STR0015) SIZE 37,7 OF oPainel01 COLOR CLR_HBLUE PIXEL //"Tarefa"
			@ 25.5,05 SAY OemTOAnsi(STR0016) SIZE 37,7 OF oPainel01 COLOR CLR_HBLUE PIXEL //"Etapa"
			@ 40.5,05 SAY OemTOAnsi(STR0102) SIZE 37,7 OF oPainel01 PIXEL //"Seq.Etapa"

			@ 10,030 MSGET M->TQ_TAREFA  SIZE 025,7 OF oPainel01 PIXEL F3 cF3T PICTURE "@!" VALID If(!Empty(M->TQ_TAREFA) .And. AllTrim( M->TQ_TAREFA) != '0',ExistCpo("TT9",M->TQ_TAREFA), .T.) .And. NGPROCEF3(cF3T,M->TQ_TAREFA) WHEN (nOPCX == 1) HASBUTTON
			@ 10,069 MSGET M->TQ_NOMTARE SIZE 150,7 OF oPainel01 PIXEL When .F.

			@ 25,030 MSGET M->TQ_ETAPA   SIZE 025,7 OF oPainel01 PIXEL F3 "MNTTAR" VALID If(!Empty(M->TQ_ETAPA),ExistCpo('TPA',M->TQ_ETAPA),.T.) .And. NGPROCEF3("TPA",M->TQ_ETAPA) PICTURE "@!" WHEN (nOPCX == 1) HASBUTTON
			@ 25,069 MSGET M->TQ_NOMETAP SIZE 150,7 OF oPainel01 PIXEL When .F.
			@ 40,030 MSGET M->TQ_SEQETA  SIZE 025,7 OF oPainel01 PIXEL WHEN (nOPCX == 1)

		ACTIVATE MSDIALOG oDlg5 ON INIT EnchoiceBar(oDlg5,	{||nOpca:=1,If( nOPCx==2 .Or. (nOPCx==1 .And. &(cVALIDTAR) .And. fValidEta()) ,;
			oDlg5:End(),nOpca:=0)},	{||oDlg5:End()})
	EndIf

	If nOPCA == 1 .And. lRet
		If nOPCx == 1
			dbSelectArea("STQ")
			dbSetOrder(1)
			If !dbSeek(xFilial('STQ') + STJ->TJ_ORDEM + STJ->TJ_PLANO + M->TQ_TAREFA + M->TQ_ETAPA)
				RecLock("STQ",.T.)
				STQ->TQ_FILIAL 	:= xFilial("STQ")
				STQ->TQ_ORDEM	:= STJ->TJ_ORDEM
				STQ->TQ_PLANO	:= STJ->TJ_PLANO
				STQ->TQ_TAREFA	:= M->TQ_TAREFA
				STQ->TQ_ETAPA	:= M->TQ_ETAPA
				STQ->TQ_SEQETA	:= M->TQ_SEQETA
				MsUnLock("STQ")

				dbSelectArea(cTRBQ400)
				RecLock(cTRBQ400,.T.)
				(cTRBQ400)->TQ_ORDEM   := STJ->TJ_ORDEM
				(cTRBQ400)->TQ_PLANO   := STJ->TJ_PLANO
				(cTRBQ400)->TQ_TAREFA  := M->TQ_TAREFA
				(cTRBQ400)->TQ_ETAPA   := M->TQ_ETAPA
				(cTRBQ400)->TQ_DESCRIC := M->TQ_NOMETAP
				(cTRBQ400)->TQ_SEQETA  := M->TQ_SEQETA
				MsUnLock(cTRBQ400)
			EndIf
		Else
			dbSelectArea("STQ")
			dbSeTOrder(01)
			cChSTQD := (cTRBQ400)->TQ_ORDEM + (cTRBQ400)->TQ_PLANO + (cTRBQ400)->TQ_TAREFA + (cTRBQ400)->TQ_ETAPA

			If dbSeek(xFilial("STQ")+cChSTQD)
				RecLock("STQ",.F.)
				dbDelete()
				MsUnLock("STQ")
			EndIf

			dbSelectArea(cTRBQ400)
			RecLock(cTRBQ400,.F.)
			dbDelete()
			MsUnLock(cTRBQ400)
			Pack
		EndIf

	EndIf
	oMark:oBrowse:Refresh()
	(cTRBQ400)->(dbGoTop())
	oMark:oBrowse:GoTop()

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NGSTQTAR
CONsiste o campo Tarefa

@author Paulo Pego
@since 17/09/99

@return boolean

@use GERAL
/*/
//---------------------------------------------------------------------
Function NGSTQTAR(cTAREFA)

	Local lRet := .T., OldAli := Alias()
	Local cCHAVST5 := ""

	cCHAVST5 := If(Type("lTAREFA") = 'L',;
				'STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA',;
				'STF->TF_CODBEM+STF->TF_SERVICO+STF->TF_SEQRELA')

	dbSelectArea("ST5")
	dbSeTOrder(01)
	If cTAREFA != "0     "
	If !dbSeek(xFilial("ST5")+&(cCHAVST5)+cTAREFA)
		Help(" ",1,"REGNOIS")
		lRet := .F.
	EndIf
	Else
	If !dbSeek(xFilial("ST5")+STJ->TJ_CODBEM + STJ->TJ_SERVICO + STJ->TJ_SEQRELA + cTAREFA)
		RecLock("ST5",.T.)
		st5->t5_filial  := xFilial("ST5")
		st5->t5_codbem  := stj->tj_codbem
		st5->t5_servico := stj->tj_servico
		st5->t5_seqrela := stj->tj_seqrela
		st5->t5_tarefa  := "0"
		st5->t5_descric := STR0017 //"SEM ESPECIFICACAO DE TAREFA"
		MsUnLock("ST5")
	EndIf
	EndIf

	dbSelectArea(OLDALI)
	M->TQ_NOMTARE := ST5->T5_DESCRIC
	If ValType( M->TQ_SEQTARE ) == 'C'
		If Empty( ST5->T5_SEQUENC )
			M->TQ_SEQTARE := Space( TamSx3('TQ_SEQTARE')[1] )
		Else
			M->TQ_SEQTARE := cValtoChar( ST5->T5_SEQUENC )
		EndIf
	EndIf

	lRefresh := .T.

Return lRET

//----------------------------------------------------------------
/*/{Protheus.doc} NGSTQETA()
CONsiste o campo Etapa.

@author Paulo Pego
@since		17-09-99

@return	lRET
/*/
//----------------------------------------------------------------
Function NGSTQETA( cETAPA,l400 )

	Local nPosChave := 0
	Local lRet      := .T.
	Local OldAli    := Alias()
	Local nDesEta   := 0
	Local lUSATARL  := If(FindFunction("NGUSATARPAD"),NGUSATARPAD(),.F.)
	Local lExistHead := .F.

	Local lTarefa   := GetNewPar("MV_NGTARGE","2") == "1"
	Local cTarefa   := ""
	Local cOrdemETA := ""
	Local cPlanoETA := ""

	Default l400 := .F.

	If NGEXISTVARIA("aHeader","A")
		nDesEta := GDFIELDPOS("TQ_NOMETAP",aHEADER)
		nTAREFA := GDFIELDPOS("TQ_TAREFA",aHEADER)
		nETAPA  := GDFIELDPOS("TQ_ETAPA",aHEADER)
		lExistHead := .T.
	EndIf

	If FunName() == "MNTA420" .Or. FunName() == "MNTA902"
		cOrdemETA := M->TJ_ORDEM
		cPlanoETA := M->TJ_PLANO
		If lTarefa .And. lExistHead
			cTarefa := aCols[n][nTAREFA]
		EndIf
	Else
		cOrdemETA := STJ->TJ_ORDEM
		cPlanoETA := STJ->TJ_PLANO
	EndIf

	//Valida se o registro existe na TPA ou se está bloquado
	If !ExistCpo('TPA',cETAPA)
		Return .F.
	EndIf

	If Len(aCOLS) > 0 .And. lRET
		If FunName() $ "MNTA420/MNTA902" .And. lTarefa

			While ( nPosChave := aScan(aCols, {|x| x[nTAREFA]+x[nETAPA] == cTarefa + cETAPA  .And. !ATail(x)}, nPosChave+1 )) > 0
				If n <> nPosChave
					Help(" ",1,"JAGRAVADO")
					lRet := .F.
					Exit
				EndIf
			End While

		Else
			//Se encontrar o registro inseriddo no acols.
			While ( nPosChave := aScan(aCols, {|x| x[nEtapa] == cETAPA .And. !ATail(x)}, nPosChave+1 )) > 0
				If n <> nPosChave
					Help(" ",1,"JAGRAVADO")
					lRet := .F.
					Exit
				EndIf
			End While
		EndIf

		If !l400 .And. nPosChave == 0
			If !Empty(nDesEta)
				aCols[n][nDesEta] := NGSEEK("TPA",cETAPA,1,"TPA_DESCRI")
			EndIf
		EndIf
	EndIf

    dbSelectArea("TPA")
    dbSetOrder(1)
    If dbSeek(xFilial("TPA")+cETAPA)
        If !Empty(cETAPA) .And. nPosChave == 0
            M->TQ_NOMETAP := TPA->TPA_DESCRI
        EndIf
    EndIf

    dbSelectArea(OLDALI)

	lRefresh := .T.

Return lRET

//---------------------------------------------------------------------
/*/{Protheus.doc} OCORMOSTRA
Verifica se o Bem é cONtrolado por cONtador.

@author NG INFORMÁTICA
@since /  /

@return boolean

@use SIGAMNT
/*/
//---------------------------------------------------------------------
Function OCORMOSTRA(cCOD)
Local cMens := STR0062 //"Codigo invalido para "
Local cCabT := STR0063 //"NAO CONFORMIDADE"
Local cTipo := STR0064 //"problema"
Local nDesO := GDFIELDPOS("TN_NOMOCOR",aHEADER)
Local nDesC := GDFIELDPOS("TN_NOMCAUS",aHEADER)
Local nDesS := GDFIELDPOS("TN_NOMSOLU",aHEADER)
lret := .T.

If !ST8->(dbSeek(XFILIAL("ST8") + cCOD))
   lRet := .F.
ElseIf readvar() == 'M->TN_CODOCOR'
   If ST8->T8_TIPO <> "P"
      MsgInfo(cMens+cTipo,cCabT)
      lRet := .F.
   Else
      If nDesO > 0
         aCols[n][nDesO] := SubStr(ST8->T8_NOME,1,20)
      EndIf
   EndIf
ElseIf readvar() == 'M->TN_CAUSA'
   If ST8->T8_TIPO <> "C"
      cTipo := STR0065 //"causa"
      MsgInfo(cMens+cTipo,cCabT)
      lRet := .F.
   Else
      If nDesC > 0
         aCols[n][nDesC] := SubStr(ST8->T8_NOME,1,20)
      EndIf
   EndIf
ElseIf readvar() == 'M->TN_SOLUCAO'
   If ST8->T8_TIPO <> "S"
      cTipo := STR0066 //"solucao"
      MsgInfo(cMens+cTipo,cCabT)
      lRet := .F.
   Else
      If nDesS > 0
         aCols[n][nDesS] := SubStr(ST8->T8_NOME,1,20)
      EndIf
   EndIf
EndIf
dbSelectArea("STN")
dbGoBottom()
dbSkip()
Return lRET

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCHKTIPO
Verifica se o Bem é cONtrolado por cONtador.

@author Paulo Pego
@since 04/11/99

@return boolean

@use SIGAMNT
/*/
//---------------------------------------------------------------------
Function NGCHKTIPO()
If ST9->T9_TEMCONT <> "N"
   TIPOACOM := .T.
Else
   TIPOACOM := .F.
EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCALENBEM
Cria as Variáveis de Ambientes de verifica os Arquivos do SIGAMNT

@author Paulo Pego
@since 04/11/99
@param DINI - Data Inicio
		HINI - Horario Inicio
		DFIM - Data termino
		HFIM - Horario termino
		cBEM - COdigo do Bem
		cFIL - Filial (OpciONal)
		cEMP - Empresa (OpciONal)

@return ReTOrna a quantidade em Horas   (CHAR 99:99 )

@use GERAL
/*/
//---------------------------------------------------------------------
Function NGCALEBEM(dINI,hINI,dFIM,hFIM,cBEM,cFIL,cEMP)
Local cALI := alias(), nORD := IndexOrd()
Local dATU := dINI, nSEM, nHORA
Local nTEMPO := 0, ni

If cFil = Nil
   cFil := NGTROCAFILI("ST9",cFIL,cEMP)
EndIf

If Empty(dINI) .Or. Empty(dFIM)
   Return "00:00"
EndIf

hINI := HTOm(hINI)
hFIM := HTOm(hFIM)

dbSelectArea("ST9")
dbSeek(cFIL + cBEM)

aDIAMAN := NG_H7(st9->t9_calenda)
If Empty(aDIAMAN)
   Return "00:00"
EndIf

For ni := 1 TO ( (dFIM - dINI)+1 )

    nFINI  := 0.00
    nFFIM  := 0.00
    nFTOT  := 0.00

    lFOLGA := .F.
    aFOLGA := NG_H9(dATU)

    If !Empty(aFOLGA)
       nFINI  := HTOM(aFOLGA[1])
       nFFIM  := HTOM(aFOLGA[2])
       nFTOT  := HTOM(aFOLGA[3])
       aFFOL  := aFOLGA[4]
       lFOLGA := .T.
    EndIf

    nSEM := If(DOW(dATU)==1,7,DOW(dATU)-1)

    nINI := HTOM(aDIAMAN[nSEM][1])
    nFIM := HTOM(aDIAMAN[nSEM][2])

    If dATU == dINI
       nINI := If(hINI <= nINI, nINI, hINI)
    EndIf

    If dATU == dFIM
       nFIM := If(hFIM > nFIM, nFIM, hFIM)
    EndIf

    nHORA  := nFIM - nINI
    nHORA  := nHORA - Intervalo( MTOH(nINI), MTOH(nFIM), nSEM)
    nHora  := nHora - (nFFIM - nFINI)
    nHORA  := If(nHORA < 0.00, 0.00, nHORA)

    nTEMPO := nTEMPO + nHORA
    dATU   := dATU + 1
Next

dbSelectArea(cALI)
dbSeTOrder(nORD)

Return MTOH(nTEMPO)

//---------------------------------------------------------------------
/*/{Protheus.doc} AbreMNT
Cria as Variáveis de Ambientes de verifica os Arquivos do SIGAMNT

@author Paulo Pego
@since 13/06/97

@return NIL

@use GERAL
/*/
//---------------------------------------------------------------------
Function AbreMNT()

	Local cQuerySB2    := ''
	Local cAliasSB2    := GetNextAlias()
	Local cProdMnt     := AllTrim(GetMv("MV_PRODMNT"))
	Local cProdTer     := AllTrim(GetMv("MV_PRODTER"))
	Local cProdFer     := AllTrim(GetMv("MV_PRODFER"))
	Local cMNTReq      := SuperGetMv( 'MV_MNTREQ', .F., '' )
	Local cMNTDev      := SuperGetMv( 'MV_MNTDEV', .F., '' )
	Local cCodProd     := ''   // Codigo do produto no Protheus
	Local cCodLocal    := ''   // Código do local de estoque no Protheus
	Local cValLocal    := ''   // Valor do produto no RM
	Local cValProduto  := '' // Valor do local de estoque no RM
	
	Private cUsuLogged := ""
	Private cPergKit   := ""
	Private cTRBAP     := GetNextAlias()
	
	Public MV_VARDIA   := GetMV("MV_VARDIA")

	//Inicializa variaveis padroes do sistema
	Public MV_RELT     := __RELDIR
	Public MV_CENT     := GetMV("MV_CENT")
	Public MV_MILHAR   := GetMV("MV_MILHAR")

	//Inicializa o simbolo das moedas
	Public MV_SIMB1    := GetMV("MV_SIMB1")
	Public MV_SIMB2    := GetMV("MV_SIMB2")
	Public MV_SIMB3    := GetMV("MV_SIMB3")
	Public MV_SIMB4    := GetMV("MV_SIMB4")
	Public MV_SIMB5    := GetMV("MV_SIMB5")

	Public MV_PRECISAO := GetMV("MV_PRECISA")   // Precisao da carga de maquinas

	Public ShowButtONDcto
	Public cPrograma

	//-- P.E. para atualizações específicas de diciONário
	If ExistBlock("MNTUTILATU")
		ExecBlock("MNTUTILATU",.F.,.F.)
	EndIf

	/*------------------------------------------------------------------------------------------------------------+
	| Validação dos parâmetros de movimentação de estoque, obrigatório a partir da atualização da rotina MATA240. |
	+------------------------------------------------------------------------------------------------------------*/
	If Trim( SuperGetMv( 'MV_NGMNTES', .F., 'N' ) ) == 'S'

		If Empty( cMNTReq ) .Or. Empty( cMNTDev )

			NGMSGMEMO( STR0063,; // Não Conformidade
				STR1483 +; // Para utilização da integração com o módulo Estoque/Custos - SIGAEST,
				STR1484 +; // deve-se informar os parâmetros MV_MNTREQ e MV_MNTDEV. Conforme a documentação:
				'https://tdn.totvs.com/x/JgSHK' ) 

		Else

			If SuperGetMv( 'MV_NGINTER', .F., 'N' ) == 'M'

				/*----------------------------------------------------------+
				| Inclusão automática dos tipos de movimentação de estoque. |
				+----------------------------------------------------------*/
				fInsSF5( cMNTReq, cMNTDev )

			EndIf

			dbSelectArea( 'SF5' )
			dbSetOrder( 1 ) // F5_FILIAL + F5_CODIGO
			If msSeek( FwxFilial( 'SF5' ) + cMNTReq )

				If SF5->F5_ATUEMP == 'N'

					NGMSGMEMO( STR0063,; // Não Conformidade
						STR1485 + cMNTReq +; // O tipo de movimento para requisição XXX
						STR1486 +; // foi definido para NÃO atualizar empenho.
						STR1487 +; // Está configuração pode ocasionar inconsitência no controle de estoque. Conforme a documentação:
						'https://tdn.totvs.com/x/JgSHK' ) 

				EndIf

			EndIf

		EndIf

	EndIf

	//Verifica se o de integracão com PCP esta correto
	If AllTrim(GetNewPar("MV_NGMNTPC","N")) == "N"  //Integração Estoque

		If AllTrim(GetNewPar("MV_NGMNTES","N")) == "S"  .And. AllTrim(GetNewPar("MV_NGMNTCM","N")) == "S" //Integração Estoque ## Integracao Compras
			Final(STR0576,; //"Há integração com o módulo de SIGAEST / SIGACOM. Deve ser habilitado "
			STR0577) //" parâmetro de integração com o modulo SIGAPCP (MV_NGMNTPC)"

		ElseIf AllTrim(GetNewPar("MV_NGMNTES","N")) == "S"  //Integração Estoque
			Final(STR0578,; //"A empresa esta integrada ao módulo de SIGAEST. Deve ser habilitado o"
			STR0577)  //" parâmetro de integração com o modulo SIGAPCP (MV_NGMNTPC)"
		ElseIf AllTrim(GetNewPar("MV_NGMNTCM","N")) == "S"  //Integração Compras
			Final(STR0579,;  //"A empresa esta integrada ao módulo de SIGACOM. Deve ser habilitado o"
			STR0577) //" parâmetro de integração com o modulo SIGAPCP (MV_NGMNTPC)"
		EndIf

	EndIf

	//-----------------------------------------------------------------------------------
	// Job responsável por chamar TODAS funções de correção base via um UNICA Thread
	//-----------------------------------------------------------------------------------
	//Realiza o processamento do workflow em thread separada
	StartJob( "NGAJUSBASE", GetEnvserver(), .F., cEmpAnt, cFilAnt, RetCodUsr(), cModulo )

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} MOSTRAGET
Mostra o Campo descritivo

@author Paulo Pego
@since   /  /

@return .T. - Sempre

@use GERAL
/*/
//---------------------------------------------------------------------
Function MOSTRAGET(cCod,cField)
Local nPos := o:colpos + 1, nC

nC := aScan(aCols, {|x| x[1] == cCod})

If nC > 0
   Help(" ",1,"MOSTRAGET")
   Return .F.
EndIf

dbSeek(xFilial()+cCod)
aCOLS[n][nPos] := Left(&cFIELD., Len(aCOLS[n][nPos]))

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} CRIAPLANO
Função que cria um plano para as O.S. corretivas e Manual

@author Inácio Luiz Kolling
@since 13/06/97

@return .T. - Sempre

@use GERAL
/*/
//---------------------------------------------------------------------
Function CRIAPLANO(nplano,descricao)
dbSelectArea( "STI" )
dbSetOrder(1)
If !dbSeek( xFilial('STI') + nplano)
   RecLock('STI',.T.)
   STI->TI_FILIAL  := xFilial('STI')
   STI->TI_PLANO   := nplano
   STI->TI_DATAPLA := ddatabase
   STI->TI_DESCRIC := descricao
   STI->TI_DATAINI := ctod('01/01/1990')
   STI->TI_DATAFIM := ctod('30/12/2999')
   STI->TI_CCUSFIM := NGPREENCH("Z","TI_CCUSFIM")
   STI->TI_SERVFIM := NGPREENCH("Z","TI_SERVFIM")
   STI->TI_AREAFIM := NGPREENCH("Z","TI_AREAFIM")
   STI->TI_TIPOFIM := NGPREENCH("Z","TI_TIPOFIM")
   STI->TI_FAMIFIM := NGPREENCH("Z","TI_FAMIFIM")
   STI->TI_CTRAFIM := NGPREENCH("Z","TI_CTRAFIM")
   STI->TI_BEMFIM  := NGPREENCH("Z","TI_BEMFIM")
   STI->TI_BLOQITE := 'S'
   STI->TI_BLOQFUN := 'S'
   STI->TI_BLOQFER := 'S'
   STI->TI_ATRASAD := 'S'
   STI->TI_SITUACA := 'L'
   STI->TI_TERMINO := 'N'
   STI->TI_USUARIO :=  If(Len(STI->TI_USUARIO) > 15,cUsername,Substr(cUsuario,7,15))
   STI->TI_LUBRIFI := 'N'

   If FieldPos("TI_TIPMODF") > 0
      STI->TI_TIPMODF := NGPREENCH("Z","TI_TIPMODF")
   EndIf

   MsUnLock("STI")
EndIf
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} CRIAPROD
Função que cria um produto MANUTENCAO

@author Paulo Pego
@since 17/08/1997

@param nVerOld - Versão antiga da execução da função
	   nVerAtu - Versão atual da função

@return .T. - Sempre

@use SIGAMNT
/*/
//---------------------------------------------------------------------
Function CRIAPROD(nVerOld,nVerAtu)

	Local aCab      := {}
	Local aProdutos := {}
	Local cLOCPAMNT := Padr( SuperGetMV("MV_NGLOCPA",.F.,""), TamSx3("NNR_CODIGO")[1] )
	Local cProduto  := ""
	Local cFieldIni := &( Posicione( 'SX3', 2, 'B1_MRP', 'X3_RELACAO' ) )
	// Tratativa para não gerar inconsistencia ao incluir registro (cDesc)
	Local cDesc     := SubStr( STR0013, 1, TamSx3( 'B1_DESC' )[1] )
	Local nX

	Default nVerOld := 0
	Default nVerAtu := 1

	// Cria local de estoque (NNR) para local padrão.
	If !Empty( cLocPaMNT )
		dbSelectArea( 'NNR' )
		dbSetOrder( 1 )
		If !dbSeek( xFilial( 'NNR' ) + cLocPaMNT )
			// Tratativa para não gerar inconsistencia ao incluir registro
			cDesc := SubStr( STR0606, 1, TamSx3( 'NNR_DESCRI' )[ 1 ] ) // "LOCAL PADRÃO MNT"

			aCab := { { 'NNR_FILIAL', xFilial( 'NNR' ), NIL },;
						{ 'NNR_CODIGO', cLocPaMNT       , NIL },;
						{ 'NNR_DESCRI', cDesc           , NIL },;
						{ 'NNR_TIPO'  , '1'             , NIL },;
						{ 'NNR_INTP'  , '3'             , NIL },;
						{ 'NNR_MRP'   , '1'             , NIL } }

			lMsErroAuto := .F.
			MSExecAuto( { |x,y| AGRA045( x, y ) }, aCab, 3 ) // Inclusão
		EndIf
	EndIf

	dbSelectArea( 'SB1' )
	dbSetOrder( 1 )
	// Mão de Obra
	aProdutos := aClone( NGProdMNT( 'M' ) )
	For nX := 1 To Len(aProdutos)
		cProduto := aProdutos[nX]
		If Upper( SubStr( cProduto, 1, 3 ) ) <> 'MOD'

			aCab := { { 'B1_FILIAL', xFilial( 'SB1' ), NIL },;
						{ 'B1_COD'   , cProduto        , NIL },;
						{ 'B1_DESC'  , cDesc           , NIL },;
						{ 'B1_TIPO'  , 'MC'            , NIL },;
						{ 'B1_UM'    , 'UN'            , NIL },;
						{ 'B1_LOCPAD', cLOCPAMNT       , NIL } }

			lMsErroAuto := .F.
			If dbSeek( xFilial( 'SB1' ) + cProduto )
				// Tratativa para preencher o campo B1_MRP, pois anteriormente era realizado reclock e não era preenchido
				If Empty( SB1->B1_MRP )
					RecLock( 'SB1', .F. )
					SB1->B1_MRP := cFieldIni
					SB1->( MsUnLock() )
				EndIf
			Else
				MSExecAuto( { |x,y| MATA010( x, y ) }, aCab, 3 ) // Inclusão
			EndIf
		EndIf
	Next nX

	// Terceiros
	aProdutos := aClONe( NGProdMNT( 'T' ) )
	For nX := 1 To Len(aProdutos)
		cProduto := aProdutos[nX]

		If Upper( SubStr( cProduto, 1, 3 ) ) <> 'MOD'

			aCab := { { 'B1_FILIAL', xFilial( 'SB1' ), NIL },;
						{ 'B1_COD'   , cProduto        , NIL },;
						{ 'B1_DESC'  , cDesc           , NIL },;
						{ 'B1_TIPO'  , 'MC'            , NIL },;
						{ 'B1_UM'    , 'H'             , NIL },;
						{ 'B1_LOCPAD', cLOCPAMNT       , NIL } }

			lMsErroAuto := .F.
			If dbSeek( xFilial( 'SB1' ) + cProduto )
				// Tratativa para preencher o campo B1_MRP, pois anteriormente era realizado reclock e não era preenchido
				If Empty( SB1->B1_MRP )
					RecLock( 'SB1', .F. )
					SB1->B1_MRP := cFieldIni
					SB1->( MsUnLock() )
				EndIf
			Else
				MSExecAuto( { |x,y| MATA010( x, y ) }, aCab, 3 ) // Inclusão
			EndIf
		EndIf
	Next nX

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} OSRETROA
VERIFICA SE A O.S. ? RETROATIVA E SE CALCULA A VARIACAO DIA E ALTERA
DADOS DO BEM ( ST9 ),MANUTENCAO (STF) E HISTORICO ( STP )

ESPECIFICAÇÃO PARA REALIZAR OU NÃO A DESCRIÇÃO ACIMA:
 1 - SE FOR UMA O.S. PREVENTIVA E A DATA DE RETORNO ( MAIOR DATA DOS
 INSUMOS )  FOR MENOR A DÁ ÚLTIMA MANUTENÇÃO ( TF_DTULTMA ) CALCULA E
 ATUALIZA DADOS
 	 SENAO
 	 	RETORNA
 	 FIM
 2 - SE FOR UMA O.S. CORRETIVA E A DATA DE RETORNO ( MAIOR DATA DOS
  INSUMOS FOR MENOR A DO ULTIMO ACOMPANHAMENTO ( T9_DTULACO ) CALCULA E
  ATUALIZA DADOS
  	 SENAO
  	 	RETORNA
  	 FIM

@author Inácio Luiz Kolling
@since 17/08/2000
@param PLANO
		BEM
		SERVIÇO
		SEQUENC
		DATA DE FECHAMENTO DA O.S

@return boolean - lCALVARDIA ( .T. OU .F. )

@use SIGAMNT
/*/
//---------------------------------------------------------------------
Function OSRETROA(cPLANO,cCODBEM,cSERVICO,nSEQ,dFECHA)
LOCAL lCALVARDIA := .T.
Local ccALIAS    := ALIAS()
Local nORDEM     := IndexOrd()
Local nSEQUENC   := If(ValType(nSEQ) = "C",nSEQ,Str(nSEQ,3))

dbSelectArea("ST9")
dbSetOrder(1)
dbSeek(xFilial("ST9") + cCODBEM)

If Val(cPLANO) = 0

   If ST9->T9_DTULTAC >= dFECHA
      lCALVARDIA := .F.
   EndIf
Else
   dbSelectArea("STF")
   dbSetOrder(1)
   If !dbSeek( xFilial("STF") + cCODBEM+cSERVICO+nSEQUENC)
      Help(" ",1,"NOMAMUTECAN")
      dbSelectArea(ccALIAS)
      dbSetOrder(nORDEM)
      return .F.
   EndIf

   If STF->TF_DTULTMA >= dFECHA
      lCALVARDIA := .F.
   Else
      RecLock("STF",.F.)
      STF->TF_DTULTMA := dFECHA
      STF->TF_CONMANU := ST9->T9_CONTACU
      MsUnLock('STF')
   EndIf
EndIf

dbSelectArea(ccALIAS)
dbSetOrder(nORDEM)
Return lCALVARDIA

//---------------------------------------------------------------------
/*/{Protheus.doc} CHKPOSLIM
Consistência da posição do cONtador com o limite.

@author Inácio Luiz Kolling
@since 30/08/2000
@param cCODBEM  - Codigo do bem
		nPOSCON  - Valor do cONtador
		nIndCONt - Indicacao de qual cONtador 1 ou 2
		cFilTroc - Filial de troca de acesso (Ñ Obrigat)
		lShowMsg - indica se apresenta mensagem em tela (retorno bool) ou nao (retorno array)

@return boolean

@use SIGAMNT
/*/
//---------------------------------------------------------------------
Function CHKPOSLIM(cCodBem,nPoscON,nIndCONt,cFilTroc,lShowMsg)

    Local aArea   := GetArea()
	Local lTemCON := .F.
	Local nIndCON := IIf(nIndCONt = Nil,1,nIndCONt)
	Local aVetCON := IIf(nIndCON = 1,{"ST9","ST9->T9_LIMICON"},{"TPE","TPE->TPE_LIMICO"})
	Local cFilCON := NGTROCAFILI(aVetCON[1],cFilTroc)
	Local xRet

	Default lShowMsg := .T.

	xRet := IIf(lShowMsg, .T. , {.T.,''})

	dbSelectArea(aVetCON[1])
	dbSetOrder(1)
	dbSeek(cFilCON+cCodBem)

	lTemCON := IIf(nIndCON=1,ST9->T9_TEMCONT<>'N',.T.)
	If lTemCON
		If nPoscON > &(aVetCON[2])
			If lShowMsg
				MsgInfo(STR0045+STR(nPOSCON,9)+CHR(13)+CHR(13)+STR0046+STR(&(aVetCON[2]),9),STR0047+" "+Str(nIndCONt,1)+" "+STR0061) //"CONtador Informado  -> "###"Limite do CONtador  -> "###"CONtador informado e maior do que o Limite do CONtador"
				xRet := .F.
			Else
				xRet := {.F., STR0045+STR(nPOSCON,9)+CHR(13)+CHR(13)+STR0046+STR(&(aVetCON[2]),9) +;
							  CHR(13)+CHR(13)+STR0047+" "+Str(nIndCONt,1)+" "+STR0061 }
			EndIf
		EndIf
	EndIf

	RestArea(aArea)

Return xRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NGNOMINSUM
Busca o nome do insumo

@author Inácio Luiz Kolling
@since  21/02/2001
@param  cTIPO, Caracter, TIPO DE INSUMO
@param  cCOD,  Caracter, CODIGO DA INSUMO
@param  nTAM,  Numérico, TAMANHO DO NOME DO INSUMO
@param  cLoja, Caracter, Loja do Fornecedor (A2_LOJA)


@return cARRAY -> [1][1] NOME TIPO INSUMO
			      [1][2] NOME DO INSUMO

@use SIGAMNT
/*/
//---------------------------------------------------------------------
Function NGNOMINSUM(cTIPO,cCOD,nTAM, cLoja)

	Local aArea    := SA2->( GetArea() )
	Local Oldalias := alias()
	Local nOrd     := IndexOrd()
	Local cNOMINS  := Space(nTAM)
	Local cDESCTI  := Space(11)
	Local cARRAY   := { }

	Default cLoja    := ''

	If cTIPO == "P"
		dbSelectArea( "SB1" )
		dbSetOrder(1)
		If dbSeek(xFilial('SB1')+cCOD)
			cNOMINS := SUBSTR(SB1->B1_DESC,1,nTAM)
		EndIf
		cDESCTI := STR0055 //"PRODUTO"

	ElseIf cTIPO == "M"

		dbSelectArea( 'ST1' )
		dbSetOrder( 1 ) // T1_FILIAL+T1_CODFUNC
		If dbSeek( FWxFilial( 'ST1' ) + SubStr( cCOD, 1, TAMSX3( 'T1_CODFUNC' )[ 1 ] ) )

			cNOMINS := Substr( ST1->T1_NOME, 1, nTAM )

		EndIf

		cDESCTI := STR0056 //"FUNCIONARIO"

	ElseIf cTIPO == "F"

		dbSelectArea( 'SH4' )
		dbSetOrder( 1 ) // H4_FILIAL+H4_CODIGO
		If dbSeek( FWxFilial( 'SH4' ) + SubStr( cCOD, 1, TAMSX3( 'H4_CODIGO' )[ 1 ] ) )

			cNOMINS := SUBSTR(SH4->H4_DESCRI,1,nTAM)

		EndIf

		cDESCTI := STR0057 //"FERRAMENTA"

	ElseIf cTIPO == "T"
		dbSelectArea( "SA2" )
		cCOD  := Left( cCOD, Len( SA2->A2_COD ) )
		// para consulta f3, buscará o código da loja correta
		If cCod == SA2->A2_COD
			cLoja := Left( cLoja, Len( SA2->A2_LOJA ) )
		Else
			// para quando digita, como não há campo para loja validará pelo primeiro cadastro sempre
			cLoja := ""
		EndIf
		dbSetOrder(1)
		If dbSeek( xFilial( 'SA2' ) + cCOD + cLoja )
			cNOMINS := SUBSTR(SA2->A2_NOME,1,nTAM)
		EndIf
		cDESCTI := STR0058 //"TERCEIRO"
	Else
	
		dbSelectArea( 'ST0' )
		dbSetOrder(1) // T0_FILIAL+T0_ESPECIA
		If dbSeek( FWxFilial( 'ST0' ) + SubStr( cCOD, 1, TAMSX3( 'T0_ESPECIA' )[ 1 ] ) )

			cNOMINS := Substr( ST0->T0_NOME, 1, nTAM )

		EndIf

		cDESCTI := STR0059 //"ESPECIALIDADE"

	EndIf

	aAdd (cARRAY,{cDESCTI,cNOMINS})

	dbSelectArea(Oldalias)
	dbSetOrder(nOrd)

	RestArea(aArea)

Return cARRAY

//---------------------------------------------------------------------
/*/{Protheus.doc} NGPROJCONT
Projeto a posicao de cONtador  ( ACUMULADO )

@author Inácio Luiz Kolling
@since 26/02/2001
@param cCODBEM - CODIGO DO BEM
		dLEITU  - DATA DE LEITURA
		cTIPP   - TIPO DE PROJECAO ( I-INICIAL,F-FINAL )
		cTIPC   - TIPO DE CONTADOR ( P-PRIMEIRO,S-SEGUNDO )
		dDTPI   - DATA INFORMADA DO INTERVALO DE PROJECAO
		lPROJ   - PROJETO CONTADOR ( .T. , .F. )

@return aARCONT -> [1] CONTADOR
                  	 [2] ACUMULADO

@use SIGAMNT
/*/
//---------------------------------------------------------------------
Function NGPROJCONT(cCODBEM,dLEITU,cTIPP,cTIPC,dDTPI,lPROJ)
Local nCONT1    := 0
Local nACUM1    := 0
Local Oldalias  := alias()
Local nOrd      := IndexOrd()
Local nACUMULA  := 0
Local nPOSCONA  := 0
Local dDTALEIA  := CTOD(' /  /  ')
Local nVARDIAA  := 0
Local nACUMULH  := 0
Local nPOSCONH  := 0
Local dDTALEIH  := CTOD(' /  /  ')
Local nVARDIAH  := 0
Local aARCONT   := {}

dbSelectArea( "ST9" )
dbSetOrder(1)
If !dbSeek(xFilial('ST9')+cCODBEM)
   aAdd (aARCONT,{nCONT1,nACUM1})
   Return aARCONT
EndIf

// VERIFICA O TIPO DE CONTADOR

If cTIPC == "P" // PRIMEIRO

   // PROCURA NA MOVIMENTACAO DO BEM NORMAL ( STP )
   dbSelectArea("STP")
   dbSetOrder(5)
   dbSeek(xFilial('STP')+cCODBEM+DTOS(dLEITU),.T.)

   If STP->TP_FILIAL == XFILIAL("STP") .And. STP->TP_CODBEM == cCODBEM ;
      .And. STP->TP_DTLEITU == dLEITU
      nACUMULA := STP->TP_ACUMCON
      nPOSCONA := STP->TP_POSCONT
      dDTALEIA := STP->TP_DTLEITU
      nVARDIAA := STP->TP_VARDIA
   Else
      If EoF() .Or. STP->TP_CODBEM <> ST9->T9_CODBEM
         dbSkip(-1)
      EndIf

      While !BoF() .And. STP->TP_FILIAL == XFILIAL("STP") .And. STP->TP_CODBEM == cCODBEM
         If !Empty(STP->TP_DTLEITU)
            nACUMULA := STP->TP_ACUMCON
            nPOSCONA := STP->TP_POSCONT
            dDTALEIA := STP->TP_DTLEITU
            nVARDIAA := STP->TP_VARDIA
            Exit
         EndIf
         dbSkip(-1)

      End

   EndIf

   // PROCURA NA MOVIMENTACAO DO BEM HISTORICO ( STW )

   dbSelectArea( "STW" )
   dbSetOrder(5)
   dbSeek(xFilial('STW')+cCODBEM+DTOS(dLEITU),.T.)

   If STW->TW_FILIAL == XFILIAL("STW") .And. STW->TW_CODBEM == cCODBEM ;
      .And. STW->TW_DTLEITU == dLEITU
      nACUMULH := STW->TW_ACUMCON
      nPOSCONH := STW->TW_POSCONT
      dDTALEIH := STW->TW_DTLEITU
      nVARDIAH := STW->TW_VARDIA
   Else

      If EoF() .Or. STW->TW_CODBEM <> ST9->T9_CODBEM
         dbSkip(-1)
      EndIf

      While !BoF() .And. STW->TW_FILIAL == XFILIAL("STW") .And. STW->TW_CODBEM == cCODBEM
         If !Empty(STW->TW_DTLEITU)
            nACUMULH := STW->TW_ACUMCON
            nPOSCONH := STW->TW_POSCONT
            dDTALEIH := STW->TW_DTLEITU
            nVARDIAH := STW->TW_VARDIA
            Exit
         EndIf
         dbSkip(-1)
      End
   EndIf

   If Empty(nACUMULA) .And. Empty(nPOSCONA) .And. Empty(nACUMULH) .And. Empty(nPOSCONH)
      aAdd (aARCONT,{nCONT1,nACUM1})
      Return aARCONT
   EndIf

   nPOSCON := nPOSCONA
   dDTALEI := dDTALEIA
   nACUMUL := nACUMULA
   nVARDIA := nVARDIAA

   If !Empty(dDTALEIA) .And. !Empty(dDTALEIH)

      If dDTALEIH < dDTALEIA
         nPOSCON := nPOSCONH
         dDTALEI := dDTALEIH
         nACUMUL := nACUMULH
         nVARDIA := nVARDIAH
      EndIf

   ElseIf !Empty(dDTALEIH)
      nPOSCON := nPOSCONH
      dDTALEI := dDTALEIH
      nACUMUL := nACUMULH
      nVARDIA := nVARDIAH
   EndIf

   If lPROJ

      nDIAS := dDTALEI - dDTPI

      // VERIFICA O TIPO DE PROJECAO

      If cTIPP == "F"

        nDIAS := If(dDTALEI > dDTPI,(dDTALEI - dDTPI),(dDTPI - dDTALEI))

      EndIf

      nQTD  := nVARDIA * nDIAS

      If cTIPP == "I"
         nCONT1 := nPOSCON - nQTD
         nACUM1 := nACUMUL - nQTD
      Else
         nCONT1 := If (dDTALEI > dDTPI,(nPOSCON - nQTD),(nPOSCON + nQTD))
         nACUM1 := If (dDTALEI > dDTPI,(nACUMUL - nQTD),(nACUMUL + nQTD))
      EndIf

   Else

      nCONT1 := nPOSCON
      nACUM1 := nACUMUL

   EndIf

Else  // SEGUNDO CONTADOR

   dbSelectArea( "TPE" )
   dbSetOrder(1)
   If !dbSeek(xFilial('TPE')+cCODBEM)
      aAdd (aARCONT,{nCONT1,nACUM1})
      Return aARCONT
   EndIf

   dbSelectArea( "TPP" )
   dbSetOrder(5)
   dbSeek(xFilial('TPP')+cCODBEM+DTOS(dLEITU),.T.)
   If TPP->TPP_FILIAL == XFILIAL("TPP") .And. TPP->TPP_CODBEM == cCODBEM ;
      .And. TPP->TPP_DTLEIT == dLEITU

      nACUMULA := TPP->TPP_ACUMCO
      nPOSCONA := TPP->TPP_POSCON
      dDTALEIA := TPP->TPP_DTLEIT
      nVARDIAA := TPP->TPP_VARDIA
   Else
      If EoF() .Or. TPP->TPP_CODBEM <> ST9->T9_CODBEM
         dbSkip(-1)
      EndIf

      While !BoF() .And. TPP->TPP_FILIAL == XFILIAL("TPP") .And. TPP->TPP_CODBEM == cCODBEM
         If !Empty(TPP->TPP_DTLEIT)
            nACUMULA := TPP->TPP_ACUMCO
            nPOSCONA := TPP->TPP_POSCON
            dDTALEIA := TPP->TPP_DTLEIT
            nVARDIAA := TPP->TPP_VARDIA
            Exit
         EndIf
         dbSkip(-1)
      End

   EndIf

   // PROCURA NA MOVIMENTACAO DO BEM HISTORICO ( TPW )
   dbSelectArea( "TPW" )
   dbSetOrder(5)
   dbSeek(xFilial('TPW')+cCODBEM+DTOS(dLEITU),.T.)
   If TPW->TPW_FILIAL == XFILIAL("TPW") .And. TPW->TPW_CODBEM == cCODBEM ;
      .And. TPW->TPW_DTLEIT == dLEITU

      nACUMULH := TPW->TPW_ACUMCO
      nPOSCONH := TPW->TPW_POSCON
      dDTALEIH := TPW->TPW_DTLEIT
      nVARDIAH := TPW->TPW_VARDIA
   Else
      If EoF() .Or. TPW->TPW_CODBEM <> ST9->T9_CODBEM
         dbSkip(-1)
      EndIf

      While !BoF() .And. TPW->TPW_FILIAL == XFILIAL("TPW") .And. TPW->TPW_CODBEM == cCODBEM
         If !Empty(TPW->TPW_DTLEIT)
            nACUMULH := TPW->TPW_ACUMCO
            nPOSCONH := TPW->TPW_POSCON
            dDTALEIH := TPW->TPW_DTLEIT
            nVARDIAH := TPW->TPW_VARDIA
            Exit
         EndIf
         dbSkip(-1)
      End

   EndIf

   If Empty(nACUMULA) .And. Empty(nPOSCONA) .And. Empty(nACUMULH) .And. Empty(nPOSCONH)
      aAdd (aARCONT,{nCONT1,nACUM1})
      Return aARCONT
   EndIf

   nPOSCON := nPOSCONA
   dDTALEI := dDTALEIA
   nACUMUL := nACUMULA
   nVARDIA := nVARDIAA

   If !Empty(dDTALEIA) .And. !Empty(dDTALEIH)
      If dDTALEIH < dDTALEIA
         nPOSCON := nPOSCONH
         dDTALEI := dDTALEIH
         nACUMUL := nACUMULH
         nVARDIA := nVARDIAH
      EndIf
   ElseIf !Empty(dDTALEIH)
      nPOSCON := nPOSCONH
      dDTALEI := dDTALEIH
      nACUMUL := nACUMULH
      nVARDIA := nVARDIAH
   EndIf

   If lPROJ

      nDIAS := dDTALEI - dDTPI

      // VERIFICA O TIPO DE PROJECAO

      If cTIPP == "F"

        nDIAS := If(dDTALEI > dDTPI,(dDTALEI - dDTPI),(dDTPI - dDTALEI))

      EndIf

      nQTD  := nVARDIA * nDIAS

      If cTIPP == "I"
         nCONT1 := nPOSCON - nQTD
         nACUM1 := nACUMUL - nQTD
      Else
         nCONT1 := If (dDTALEI > dDTPI,(nPOSCON - nQTD),(nPOSCON + nQTD))
         nACUM1 := If (dDTALEI > dDTPI,(nACUMUL - nQTD),(nACUMUL + nQTD))
      EndIf

   Else

      nCONT1 := nPOSCON
      nACUM1 := nACUMUL

   EndIf

EndIf

dbSelectArea(Oldalias)
dbSetOrder(nOrd)

nCONT1 := If(nCONT1 < 0,0,nCONT1)
nACUM1 := If(nACUM1 < 0,0,nACUM1)

aAdd (aARCONT,{nCONT1,nACUM1})

Return aARCONT

//---------------------------------------------------------------------
/*/{Protheus.doc} NGBEMPAI
Procura o bem pai da estrutura

@param cVBEM	- Codigo do bem
		dDATAV	- Data a ser verifcada
		cHORAV	- Hora a ser verifcada

@author Inacio Luiz Kolling
@since 09/07/2001
@versiON MP11
@return cBEMPAI - Codigo do bem Pai da Estrutura
                  - Vazio bem sem Estrutura
/*/
//---------------------------------------------------------------------
Function NGBEMPAI(cVBEM,dDATAV,cHORAV)
    
    Local cOldBem   := cVBEM
    Local cVBEMAUX  := space(len(cVBEM))
	Local cCodBem   := ''
    Local lImediato := .F.
    Local lPaiEstru := .F.
	Local aArea     := FWGetArea()
    Local aAreaST9  := STZ->( FWGetArea() )
    Local aAreaSTZ  := ST9->( FWGetArea() )
	Local lOK       := .F.
	Local lBemPai   := .F.

    //-------------------------------------------------
    // Busca o bem pai que tenha cONtador proprio
    // pelo historico da estrutura realizando
    // uma cascata inversa
    //-------------------------------------------------
    If dDATAV <> nil .And. cHORAV <> nil

    	dbSelectArea("STZ")
    	dbSetOrder(01)
    	If dbSeek(xFilial('STZ')+cVBEM)

    		//Verifica cONtador do bem em questao
    		If STZ->TZ_TEMCONT == "I"
    			lImediato := .T.
    		Else
    			lPaiEstru := .T.
    		EndIf

    		While !EoF() .And. STZ->TZ_FILIAL == xFilial('STZ') .And. STZ->TZ_CODBEM == cVBEM
    			lOK := .F.
    			If Empty(STZ->TZ_DATASAI)
    				If STZ->TZ_DATAMOV <= dDATAV
    					If STZ->TZ_DATAMOV < dDATAV
    						lOK := .T.
    					Else
    						If cHORAV >= STZ->TZ_HORAENT
    							lOK := .T.
    						EndIf
    					EndIf
    				EndIf
    			Else
    				If STZ->TZ_DATAMOV <= dDATAV .And. STZ->TZ_DATASAI >= dDATAV
    					If STZ->TZ_DATAMOV == dDATAV .And. STZ->TZ_DATASAI == dDATAV
    						If STZ->TZ_HORAENT <= cHORAV .And. STZ->TZ_HORASAI >= cHORAV
    							lOK := .T.
    						EndIf
    					ElseIf STZ->TZ_DATAMOV < dDATAV .And. STZ->TZ_DATASAI > dDATAV
    						lOK := .T.
    					ElseIf STZ->TZ_DATAMOV == dDATAV
    						If STZ->TZ_HORAENT <= cHORAV
    							lOK := .T.
    						EndIf
    					ElseIf STZ->TZ_DATASAI == dDATAV
    						If STZ->TZ_HORASAI >= cHORAV
    							lOK := .T.
    						EndIf
    					EndIf
    				EndIf
    			EndIf

    			If lOK
    				
					//Possui cONtador imediato ou pelo pai da estrutura
    				If lImediato .Or. lPaiEstru
    					
						dbSelectArea( 'ST9' )
    					dbSetOrder( 1 )
    					If msSeek( FWxFilial( 'ST9' ) + STZ->TZ_BEMPAI )
    						
							//Bem pai possui cONtador proprio
    						If ST9->T9_TEMCONT == 'S'
    							
								cVBEMAUX := STZ->TZ_BEMPAI
    							
								//Caso for cONtador imediato sai do loop
    							If !lImediato

									lBemPai    := .T.

									cCodBemPai := cVBEMAUX

    							EndIf

								Exit

							//Busca o Pai da estrutura
							ElseIf ST9->T9_TEMCONT $ "P/I/N"

								lBemPai := .T.

								cCodBemPai := ST9->T9_CODBEM

								Exit

    						EndIf
    						
    					Else

    						STZ->( dbSkip() )

    					EndIf

    				Else

    					Exit

    				EndIf

    			Else

    				STZ->( dbSkip() )

    			EndIf

    		End

    		//Verifica se pesquisa foi realizada referente a um bem
    		//que possui cONtador cONtrolado pelo pai da estrutura
    		If lPaiEstru .And. cOldBem != cVBEM  .And. !lBemPai
    			dbSelectArea("ST9")
    			dbSetOrder(1)
    			//PosiciONa no pai do bem
    			If dbSeek(xFilial("ST9")+cVBEM)
    				If ST9->T9_TEMCONT == "S"
    					cVBEMAUX := If(!Empty(STZ->TZ_BEMPAI),STZ->TZ_BEMPAI,cVBEMAUX)
    				Else
    					cVBEMAUX := ""
    				EndIf
    			EndIf
    		EndIf

    	EndIf

    	FWRestArea( aAreaST9 )
    	FWRestArea( aAreaSTZ )

    //-------------------------------------------------
    // Busca o bem pai pela estrutura corrente
    //-------------------------------------------------
    Else
    	dbSelectArea("STC")
    	dbSetOrder(03)

    	If dbSeek(xFilial('STC')+cVBEM)
    	   cVBEMAUX := cVBEM
    	   While !EoF() .And. stc->tc_filial = xFilial("STC")
    	      dbSeek(xFilial('STC')+cVBEMAUX)
    	      If Found() .And. stc->tc_tipoest = "B"
    	         cVBEMAUX := STC->TC_CODBEM
    	         dbSkip()
    	         Loop
    	      Else
    	         Exit
    	      EndIf
    	   End
    	EndIf

    	dbSelectArea("STC")
    	dbSetOrder(01)
    EndIf

	If lBemPai

		cCodBem := NGBEMPAI( cCodBemPai, dDATAV, cHORAV )

		If !Empty( cCodBem )

			cVBEMAUX := cCodBem

		EndIf

	EndIf

    FWRestArea( aArea )

	FWFreeArray( aArea )
	FWFreeArray( aAreaST9 )
	FWFreeArray( aAreaSTZ )

Return cVBEMAUX

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGBEMIME  ³ Autor ³ In cio Luiz Kolling   ³ Data ³09/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Procura o bem pai IMEDIATO da estrutura                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cVBEM - Codigo do bem                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³cBEMPAI - Codigo do bem Pai Imediato                        ³±±
±±³          ³        - Vazio bem Pai Imediato                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGBEMIME(cVBEM)
Local ccalias  := alias()
Local nvordem  := INDEXORD()
Local cVBEMAUX := space(len(cVBEM))

dbSelectArea("STC")
dbSetOrder(03)

If dbSeek(xFilial('STC')+cVBEM)
   cVBEMAUX := STC->TC_CODBEM
EndIf

dbSelectArea("STC")
dbSetOrder(01)

dbSelectArea(ccalias)
dbSetOrder(nvordem)
Return cVBEMAUX


//---------------------------------------------------------------------
/*/{Protheus.doc} NGATUSIX
Funcao que permite alterar o diciONario SINDEX bem como suas
propriedades.

@author Inácio Luiz Kolling
@since 24/06/2002
@use SIGAMNT
@return .T.
/*/
//---------------------------------------------------------------------
Function NGATUSIX()

	dbSelectArea("SIX")
	dbSetOrder(1)

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} NGATUSX1
Funcao que permite alterar o diciONario SX1 bem como suas
propriedades.

@author Elisangela Costa
@since 07/01/2005
@use SIGAMNT
@return .T.
/*/
//---------------------------------------------------------------------
Function NGATUSX1()

	Local nTAMATQ4   := TamSX3("TQ4_CDEXEC")[1]
	Local aMuda := {}, nSX
	Local cCampo, cField, cMuda

	NGDBAREAORDE("SX1")

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGATUSX2
Funcao que permite alterar o diciONario SX2 bem como suas
propriedades.

@author Elisangela Costa
@since 31/10/2006
@use SIGAMNT
@return .T.
/*/
//---------------------------------------------------------------------
Function NGATUSX2()

	Local lFROTASMNT := NGVERUTFR()
	Local cChTQ1Un := If(!lFROTASMNT,'TQ1_FILIAL+TQ1_DESENH+TQ1_SEQREL','TQ1_FILIAL+TQ1_DESENH+TQ1_TIPMOD+TQ1_SEQREL')
	Local cKeyTmp

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGATUSX3
Funcao que permite alterar o diciONario SX3 bem como suas
propriedades.

@author Inácio Luiz Kolling
@since 24/06/2002
@use SIGAMNT
@return .T.
/*/
//---------------------------------------------------------------------
Function NGATUSX3()

	Local cCUsado
	Local cCAMPO, cFIELD, cMUDA , cNGETAGE

	Local aMUDA		 := {}, nSX
	Local cUsdNor	 := Space(Len(Posicione("SX3",2,"T9_CODBEM","X3_USADO")))  //Usado Campo Normal
	Local cRsvNor	 := Space(Len(Posicione("SX3",2,"T9_CODBEM","X3_RESERV"))) //Reserva Campo Normal
	Local cUsdFil	 := Space(Len(Posicione("SX3",2,"T9_CODBEM","X3_USADO")))  //Usado Campo Normal
	Local cRsvFil	 := Space(Len(Posicione("SX3",2,"T9_CODBEM","X3_RESERV"))) //Reserva Campo Normal
	Local cRsvObrig	 := Space(Len(Posicione("SX3",2,"T9_CODBEM","X3_RESERV"))) //Obrigatório
	Local cUsdObrig	 := Space(Len(Posicione("SX3",2,"T9_CODBEM","X3_USADO")))  //Obrigatório
	Local cNaoAltera := "€€€€€€€€€€€€€€°"
	Local cNaoAltRs	 := "€"
	Local cNAOUSADO  := Space(Len(Posicione("SX3",2,"T9_CODBEM","X3_USADO")))
	Local aSx3Alter  := {}, i
	Local lFROTASMNT := NGVERUTFR()
	Local lConsComb	 := IIf(SuperGetMv("MV_NGIMPOR",.F.,"1") == "2",.T.,.F.)
	Local cTitulo	 := IIf(lConsComb,STR0801,STR0806) // "Combustível"###"Convênio"

	_SetOwnerPrvt("X3_OBRIGATORIO","€")
	_SetOwnerPrvt("X3_X3OBRIG","€")
	_SetOwnerPrvt("X3_OBRIGAT_RESERV","A€")
	_SetOwnerPrvt("X3_NAOUSADO_RESERV","€€")
	_SetOwnerPrvt("X3_USADO_RESERV","şÀ")
	_SetOwnerPrvt("X3_EMUSO_USADO","€€€€€€€€€€€€€€ ")
	_SetOwnerPrvt("X3_NAOUSADO_USADO","€€€€€€€€€€€€€€€")
	_SetOwnerPrvt("X3_NAOALTERA_USADO","€€€€€€€€€€€€€€°")

	cOBRIG := "€"
	If dbSeek("T9_CODBEM")
		cOBRIG := Posicione("SX3",2,"T9_CODBEM","X3_RESERV")
	EndIf

	dbSelectArea("SX3")
	dbSetOrder(2)
	If dbSeek("T9_FILIAL")
		cNAOUSADO := Posicione("SX3",2,"T9_FILIAL","X3_USADO")
		cUsdFil   := Posicione("SX3",2,"T9_FILIAL","X3_USADO")
		cRsvFil   := Posicione("SX3",2,"T9_FILIAL","X3_RESERV")
	EndIf

	If dbSeek("T9_POSCONT")
		cUsdCONt := Posicione("SX3",2,"T9_POSCONT","X3_USADO")
		cRsvCONt := Posicione("SX3",2,"T9_POSCONT","X3_RESERV")
	EndIf

	If dbSeek("TJ_NOMBEM")
		cNAOOBRIG := Posicione("SX3",2,"TJ_NOMBEM","X3_RESERV")
	EndIf

	If dbSeek("T1_CODFUNC")
		cRsvObrig := Posicione("SX3",2,"T1_CODFUNC","X3_RESERV")
		cUsdObrig := Posicione("SX3",2,"T1_CODFUNC","X3_USADO")
	EndIf

	If dbSeek("T9_SERIE")
		cUsdNor := Posicione("SX3",2,"T9_SERIE","X3_USADO")
		cRsvNor := Posicione("SX3",2,"T9_SERIE","X3_RESERV")
	EndIf
	If dbSeek("TTF_POSCON") .And. AllTrim(Posicione("SX3",2,"TTF_POSCON","X3_VALID")) <> 'If(M->TTF_POSCON > 0, CHKPOSLIM(M->TTF_CODBEM, M->TTF_POSCON, 1), .T.) .And. POSITIVO(M->TTF_POSCON)'
		aAdd( aMuda, {'TTF_POSCON', 'X3_VALID'	, 'IIf(M->TTF_POSCON > 0, ChkPosLim(M->TTF_CODBEM, M->TTF_POSCON, 1), .T.) .And. Positivo(M->TTF_POSCON)'} )
		aAdd( aMuda, {'TTF_POSCON', 'X3_WHEN'	, 'lCONT1 .And. NGBlCont()'} )
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGBEMATIV
CONsite se o bem está ativo.

cCOD - Codigo do Bem
cFIL - Filial do Bem  ( Ñ obrigatório )

@author Inácio Luiz Kolling
@since 17/09/2001
@versiON MP11
@return
/*/
//---------------------------------------------------------------------
Function NGBEMATIV(cCOD,cFIL)

	Default cFil := cFilAnt

	lUsouF7 := If(ValType("lUsouF7") <> "U",.F.,lUsouF7)

	dbSelectArea("ST9")
	dbSetOrder(1)

	If !dbSeek(xFilial('ST9',cFIL)+cCOD)
		If lUsouF7
			dbSelectArea("SN1")
			dbSetOrder(1)
			If !dbSeek(xFilial('SN1')+cCOD)
				Help(" ",1,"BEMNEXIST")
				Return .F.
			EndIf
		Else
			Help(" ",1,"BEMNEXIST")
			Return .F.
		EndIf
	Else
		If ST9->T9_SITBEM = 'I'
		   Help(" ",1,"NGBEMINATI")
		   Return .F.
		EndIf
		If ST9->T9_SITBEM = 'T'
			Help(" ",1,"NGBEMTRANSF",,STR0214,3,1) //"Este Bem foi TRANSFERIDO."
			Return .F.
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGMANATIV
Consite se a manutencao para aquele bem esta inativa e se
todas as manutencoes estao inativas

@author Inácio Luiz Kolling
@since 29/01/2002
@return boolean
/*/
//---------------------------------------------------------------------
Function NGMANATIV(cCod,cServ,Seq)

//Testado se ta vindo numerico ou caracter em funcao
//dos campos de sequencia (numerico ou caracter)
Local nSeq

If ExistBlock("NGMANATIV")
   If !ExecBlock("NGMANATIV",.F.,.F.,{cCod,cServ,Seq})
		Return .F.
   EndIf
Else
	nSeq := If(ValType(Seq)="N",Str(Seq,3),Seq)

	dbSelectArea("ST9")
	dbSetOrder(1)
	If !dbSeek(xFilial('ST9')+cCOD)
	   Help(" ",1,"BEMNEXIST")
	   Return .F.
	EndIf

	If ST9->T9_SITMAN = 'I'
	   Help(" ",1,"NGMABEMINA")
	   Return .F.
	EndIf

	dbSelectArea("STF")
	dbSetOrder(1)
	If dbSeek(xFilial("STF")+cCod+cServ+nSeq)
	   If STF->TF_ATIVO == "N"
	      Help(" ",1,"NGMANINATI")
		  Return .F.
	   EndIf
	EndIf
EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGMANATIV
Filtra o arquivo de servico por tipo

@author Inácio Luiz Kolling
@since 13/08/2002
@return boolean
/*/
//---------------------------------------------------------------------
Function NGSERVFIL()

	Local cTIPSERV

	If Type("lCORRET") <> "L" .Or. ( Type( 'STJ->TJ_ORDEM' ) == 'C' .And. !Empty( STJ->TJ_ORDEM ) )//F3 -> visualizar em MNTC790
		lCORRET := NGSEEK("STE",STJ->TJ_TIPO,1,"TE_CARACTE") == "C"
	EndIf

	cTIPSERV := If(lCORRET,'C','P')
	dbSelectArea("STE")
	dbSetOrder(1)
	If dbSeek(xFilial('STE')+st4->t4_tipoman)
		If (ste->te_caracte = cTIPSERV)
			dbSelectArea("ST4")
			Return .T.
		EndIf
		dbSelectArea("ST4")
	EndIf
	dbSelectArea("ST4")

Return .F.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNTLOAD   ³ Autor ³In cio Luiz Kolling    ³ Data ³25/03/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao de inicial do SIGAMNT                                |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTLOAD()
	AbreMNT()
Return .T.

//------------------------------------------------------------------------------------
/*/{Protheus.doc} GFRLOAD
Função acionada no carregamento inicial do módulo Gestão de Frotas (SIGAGFR).

@author Eduardo Mussi
@since  30/06/2021
/*/
//-------------------------------------------------------------------------------------
Function GFRLOAD()
   AbreMNT()
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGSX3TAM  ³ Autor ³ Inacio Luiz Kolling   ³ Data ³23/08/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Tamanho do campo no diciONario de dados                     |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cVCAMPO - Codigo do campo                                   |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSX3TAM(cVCAMPO)

	Local cALVELHO := Alias(),nORDVELHO := Indexord(),nSX3TAM := 0

	dbSelectArea("SX3")
	dbSetOrder(2)
	If dbSeek(cVCAMPO)
		nSX3TAM := TAMSX3(cVCAMPO)[1]
	EndIf
	dbSetOrder(1)

	dbSelectArea(cALVELHO)
	If nORDVELHO > 0
		dbSetOrder(nORDVELHO)
	EndIf

Return nSX3TAM

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGPREENCH ³ Autor ³ Inacio Luiz Kolling   ³ Data ³23/08/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Preenche campo cONforme especificao dos parametros          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cCARAC  - Caracter para ser preenchido    - Obrigatorio     ³±±
±±³          ³cVCAMPO - Codigo do campo do diciONario   *                 ³±±
±±³          ³nVEZ    - Quantidade de replicacoes       *                 ³±±
±±³          ³        * Um dos dois obrigotorios                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGPREENCH(cCARAC,cVCAMPO,nVEZ)
Local nVEZES := If(cVCAMPO <> Nil,NGSX3TAM(cVCAMPO),nVEZ)
Return Replicate(cCARAC,nVEZES)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGSEQETA  ³ Autor ³ Inacio Luiz Kolling   ³ Data ³10/11/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o indice de ordenacao da sequencia existe no    ³±±
±±³          ³diciONario, se houver retorna este indice                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³vALIAS - Alias do arquivo para ser verificado - obrigatorio ³±±
±±³          ³nVINDP - Indice Primario da tabela            - obrigatorio ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSEQETA(vALIAS,nVINDP)
Local aALIARQ := {{"STH",3},;
                  {"STQ",3},;
                  {"STX",3},;
                  {"TPH",5}}

Local nRETIND := nVINDP
Local nPOSIND := Ascan(aALIARQ, {|x| x[1] == vALIAS})
If nPOSIND > 0
   dbSelectArea("SIX")
   dbSetOrder(01)
   If dbSeek(vALIAS+Alltrim(STR(aALIARQ[nPOSIND,2])))
      nRETIND := aALIARQ[nPOSIND,2]
   EndIf
EndIf
Return nRETIND

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGVerify  ³ Autor ³ Lucas                 ³ Data ³27/04/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica a existencia do ind. com campo caractcer _SEQRELA.³±±
±±³          ³ ou _SEQREL                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ cALIAS  --> Alias da tabela  EX: "ST5"                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGVerify(cALIAS)
Local aArea := GetArea()
Local lRefy := .F.
Local aFiles := {{"ST5","1","T5_SEQRELA"},;
				 {"STC","2","TC_SEQRELA"},;
				 {"STF","1","TF_SEQRELA"},;
				 {"STG","1","TG_SEQRELA"},;
				 {"STH","1","TH_SEQRELA"},;
				 {"STJ","2","TJ_SEQRELA"},;
				 {"STL","1","TL_SEQRELA"},;
				 {"STM","1","TM_SEQRELA"},;
				 {"STN","1","TN_SEQRELA"},;
				 {"STS","1","TS_SEQRELA"},;
				 {"STT","1","TT_SEQRELA"},;
 				 {"STU","1","TU_SEQRELA"},;
				 {"TP1","1","TP1_SEQREL"},;
				 {"TP2","1","TP2_SEQREL"},;
				 {"TP5","1","TP5_SEQREL"},;
				 {"TPF","1","TPF_SEQREL"},;
 				 {"TPG","1","TPG_SEQREL"},;
 				 {"TPH","1","TPH_SEQREL"},;
 				 {"TPI","1","TPI_SEQREL"},;
 				 {"TPM","1","TPM_SEQREL"},;
 				 {"TPP","1","TPP_SEQREL"},;
 				 {"TPV","1","TPV_SEQREL"},;
 				 {"TPW","1","TPW_SEQREL"},;
 				 {"TPZ","1","TPZ_SEQREL"},;
 				 {"TQ1","1","TQ1_SEQREL"},;
 				 {"TQD","1","TQD_SEQREL"}}

nPosAlias := Ascan(aFiles,{|x| x[1] == cALIAS})
If nPosAlias > 0
   cINDXYZ := aFiles[nPosAlias][2]
   cCAMPOX := aFiles[nPosAlias][3]
   dbSelectArea("SIX")
   dbSetOrder(1)
   If dbSeek(cALIAS+cINDXYZ)
      If cCAMPOX $ SIX->CHAVE
     	 lRefy := .T.
   	  EndIf
   EndIf
EndIf
RestArea(aArea)
Return(lRefy)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGDTAINSUIN³ Autor ³ In cio Luiz Kolling   ³ Data ³04/07/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Validacao da data inicio do insumos (Prveisto/Realizado)    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ Data inicio                                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGDTAINSUIN(vdDATAI)
Local lRETDTA := .T.
If Vazio(vdDATAI)
   Return .F.
EndIf
If Type("cINSPREV") <> "U"
   If cINSPREV = "P"
   Else
      If vdDATAI > dDataBase
         lRETDTA := .F.
      EndIf
   EndIf
Else
   If vdDATAI > dDataBase
      lRETDTA := .F.
   EndIf
EndIf

If !lRETDTA
   Chkhelp("DATAINVAL")
EndIf
Return lRETDTA

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCHKSEQCN³ Autor ³ In cio Luiz Kolling   ³ Data ³01/07/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se ha problemas na base dos campos _SEQUENC,      ³±±
±±³          ³ _SEQRELA, _SEQREL                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ NIL                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCHKSEQCN()
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGVALTERC  ³ Autor ³Elisangela Costa       ³ Data ³11/07/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Validacao do tipo de insumo terceiro                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cTIPOINS   = Tipo do insumo                                  ³±±
±±³          ³nNGINTEST  = Integracao com estoque(S - Integrado com esto-  ³±±
±±³          ³             que, N - Nao integrado com estoque) nao obri-   ³±±
±±³          ³             gatorio                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGVALTERC(cTIPOINS,cNGINTEST)

Local lTIPOINS := .T.

If Vazio(cTIPOINS)
   Return .F.
EndIf

cINTEST := If(cNGINTEST = Nil,AllTrim(GetMv("MV_NGMNTES")),cNGINTEST)

If Type("cNGINSPREA") <> "U"  //Indica se o insumo e previsto ou realizado
   If cNGINSPREA = "R"
      If cTIPOINS = "T" .And. cINTEST = "S" .And. AllTrim(GetNewPar("MV_NGINTER","N")) <> "L"
         lTIPOINS := .F.
      EndIf
   EndIf
EndIf

If !lTIPOINS
   MSGINFO(STR0078+CHR(13);//"Nao e permitido informar insumo do tipo terceiro quando integrado"
          +STR0079,STR0063) //"com estoque no SIGAMNT. Somente por nota fiscal de entrada."  #"NAO CONFORMIDADE"
EndIf

Return lTIPOINS

//-------------------------------------------------------------------
/*/{Protheus.doc} NGSDCHKORDEM
Verifica a situacao da ordem de servico e se pode receber insumo

@author  Inacio Luiz Kolling
@since   03/08/2005
@version P12

@param vSDORDEM, caracter, Numero da ordem de serviço
@param nItem   , numérico, Posição da getdados

@return  lógico
/*/
//-------------------------------------------------------------------
Function NGSDCHKORDEM(vSDORDEM,nItem)

	Local aArea     := GetArea()
	Local aAreaSC7  := SC7->(GetArea())
	Local cMENSA    := Space(1)
	Local lIntEst   := (SuperGetMV("MV_NGMNTES",.F.,"N") == "S")
	Local lIntPCP   := (SuperGetMV("MV_NGMNTPC",.F.,"N") == "S")
	Local nPosCod   := aSCAN( aHEADER, { |x| TRIM( UPPER( x[ 2 ] ) ) == 'D1_COD' } )
	Local nPosQuant := aSCAN( aHEADER, { |x| TRIM( UPPER( x[ 2 ] ) ) == 'D1_QUANT' } )
	Local nPosOp    := aSCAN( aHEADER, { |x| TRIM( UPPER( x[ 2 ] ) ) == 'D1_OP' } )

	Local nPosPc  	:= aScan( aHeader, { |x| AllTrim( x[ 2 ] ) == 'D1_PEDIDO'} )
	Local nPosItPc	:= aScan( aHeader, { |x| AllTrim( x[ 2 ] ) == 'D1_ITEMPC'} )
	Local nPosNfOri := aScan( aHeader, { |x| AllTrim( x[ 2 ] ) == 'D1_NFORI' } )
	Local aPosDhn   := {}

	Local lRet 		:= .T.
	Local lOrdem 	:= .T.
	Local cAliasQry := GetNextAlias()

	Default nItem := n

	dbSelectArea("STJ")
	dbSetOrder(1)
	If dbSeek(xFilial("STJ")+vSDORDEM)
		If stj->tj_situaca = "C"
			cMENSA := STR0082+" "+STR0083
		ElseIf stj->tj_situaca = "P"
			cMENSA := STR0082+" "+STR0084
		EndIf

		If !Empty(cMENSA)
			MsgInfo(cMENSA,STR0063)
			lRet := .F.
		EndIf

		If lRet .And. ( lIntEst .Or. lIntPCP )
			dbSelectArea("SC2")
			dbSetOrder(1)
			If !dbSeek(xFilial("SC2")+vSDORDEM+'OS001')
				Help(" ",1,"REGNOIS",,NGSX2NOME('SC2'),3,1)
				lRet := .F.
			EndIf

		EndIf

		//Verifica se o produto ainda tem garantia
		If lRet .And. !Empty(acols[nItem][nPosCod])
			NGCHKGASD1(.F.,STJ->TJ_CODBEM,acols[nItem][nPosCod],"P")
		EndIf

		If lRet .And. nPosCod > 0 .And. nPosQuant > 0 .And. nPosOp > 0
			If !NGAPAGD1OR(vSDORDEM,aCols[nItem,nPosOp],aCols[nItem,nPosCod],aCols[nItem,nPosQuant])
				lRet := .F.
			EndIf
		EndIf

		If lRet
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Analisa se existe PC's amarrado a uma SC'a onde a SC's foi gerada |
			//| pela rotina de solicitacao ao armazem e ja foi informado o numero |
			//| da Ordem de Producao na Solicitacao ao Armazem.					  |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nPosPc > 0 .And. nPosItPc > 0
				If !Empty(aCols[nItem,nPosPC])
					dbSelectArea("SC7")
					dbSetOrder(1) //C7_FILIAL+C7_NUM+C7_ITEM+C7_SEQUEN
					If dbSeek(xFilial("SC7")+aCols[nItem,nPosPC]+aCols[nItem,nPosItPC])
						If !Empty(SC7->C7_NUMSC)
							aPosDhn := COMPosDHN({3,{'1',xFilial("DHN"),SC7->C7_NUMSC,SC7->C7_ITEMSC}})
							If aPosDhn[1]
								Do While !((aPosDhn[2])->(Eof()))
									SCQ->(DbSetOrder(1))
									If SCQ->(DbSeek((aPosDhn[2])->(DHN_FILORI + DHN_DOCORI +  AllTrim(DHN_ITORI))))
										Do While !(DHN->(EoF())) .And. DHN->(DHN_FILORI + DHN_DOCORI +  AllTrim(DHN_ITORI)) == (aPosDhn[2])->(DHN_FILORI + DHN_DOCORI +  AllTrim(DHN_ITORI))
											If !Empty(SCQ->CQ_OP)
												Aviso(STR1445,; //"Atenção"
												STR1451,; //"Este documento de entrada esta amarrado a uma solicitação de compras que foi criada por uma solicitação ao armazém, onde não é possivel informar o número da ordem de serviço."
												{},2)
												lRet := .F.
												Exit
											EndIf
											DHN->(DbSkip())
										EndDo
									EndIf
									(aPosDhn[2])->(dbSkip())
								EndDo
								(aPosDhn[2])->(DbCloseArea())
							EndIf

						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		// Trecho necessário para impedir o vinculo de um Conhecimento de Frete com um Insumo que não foi vinculado com a Nota Fiscal (O.s. não vinculada ao Documento de Entrada da NF)

		If lRet .And. FWIsInCallStack( 'MATA116' )

			BeginSQL Alias cAliasQry

				SELECT COUNT( STL.TL_ORDEM ) AS COUNT
				FROM %table:STL% STL
					WHERE	STL.TL_FILIAL = %xFilial:STL%
						AND STL.TL_ORDEM = %exp:vSDORDEM%
						AND STL.TL_CODIGO = %exp:aCols[ nItem, nPosCod ]%
						AND ( STL.TL_DOC <> ' '
							AND STL.TL_DOC = %exp:aCols[ nItem, nPosNfOri ]%)
						AND STL.%NotDel%
			EndSQL

			If (cAliasQry)->COUNT == 0

				Help( NIL, 1, STR0041, NIL, STR1489, 1, 0 ) //"Atenção"###"Para que o processo de Conhecimento de Frete seja vinculado a uma Ordem de Serviço, é necessário que a Nota Fiscal também esteja associada à O.S."
				lRet := .F.

			EndIf

			(cAliasQry)->(DbCloseArea())
			cAliasQry := GetNextAlias()

		EndIf

		//Verifica se o documento de entrada veio de uma S.A., caso sim n? ?feito o gatilho da O.P.
		BeginSQL Alias cAliasQry

			SELECT CP_NUM
			FROM %table:SCP%
				WHERE	CP_FILIAL = %xFilial:SCP%
					AND CP_OP = %exp:vSDORDEM + 'OS001'%
					AND %NotDel%
		EndSQL

		If (cAliasQry)->( !EoF() )
			lOrdem := .F.
		EndIf
		If lRet
			If lOrdem
				acols[nItem][nPosOp] := vSDORDEM+'OS001'
			Else
				acols[nItem][nPosOp] := Space(TAMSX3("D1_OP")[1])
			Endif
		EndIf

		(cAliasQry)->( dbCloseArea() )

	EndIf
	RestArea(aArea)
	RestArea(aAreaSC7)

Return lRet


//---------------------------------------------------------------------
/*/{Protheus.doc} NGSDCHKSS
Verifica se a Solicitação de Serviço pode receber insumos.
(função utilizad no Módulo de Estoques - Nota Fiscal de Entrada)

@author Wagner Sobral de Lacerda
@since 14/11/2012

@param cCodSS
	Código da S.S. para vaidar/verificar * Obrigatório

@return lRetorno
/*/
//---------------------------------------------------------------------
Function NGSDCHKSS(cCodSS)

	// Salva as áreas atuais
	Local aAreaOld := GetArea()
	Local aAreaSC2 := SC2->( GetArea() )
	Local aAreaTQB := TQB->( GetArea() )

	// Variáveis de Parâmetros SX6
	Local lIntEst := ( SuperGetMV("MV_NGMNTES", .F., "N") == "S" )
	Local lIntPCP := ( SuperGetMV("MV_NGMNTPC", .F., "N") == "S" )

	// Variável do Retorno
	Local lRetorno := .T.

	// Variáveis auxiliares
	Local nSD1OP := If(Type("aHeader") == "A", aScan(aHeader, {|x| Upper(AllTrim(x[2])) == "D1_OP" }), 0)
	Local cCodOP := ""

	//--------------------
	// Valida S.S.
	//--------------------
	If Empty(cCodSS)
		lRetorno := .T.
	ElseIf !ExistCpo("TQB", cCodSS, 1)
		lRetorno := .F.
	EndIf
	If NGIFdbSeek("TQB", cCodSS, 1)
		If TQB->TQB_SOLUCA <> "D" // D=Distribuída
			Help(Nil, Nil, "Atenção", Nil, "A S.S. selecinada não está distribuída.", 1, 0)
		EndIf
	EndIf

	//----------------------------------------
	// Verifica se pode receber Insumos
	//----------------------------------------
	If lRetorno .And. !Empty(cCodSS)
		If lIntEst .Or. lIntPCP
			dbSelectArea("SC2")
			dbSetOrder(1)
			If !dbSeek(xFilial("SC2") + cCodSS + "SS001")
				Help(" ", 1, "REGNOIS", , NGSX2NOME("SC2"), 3, 1)
				lRetorno := .F.
			EndIf

			// Atualiza a OP
			If lRetorno
				cCodOP := SC2->C2_NUM + SC2->C2_ITEM + SC2->C2_SEQUEN
				If nSD1OP > 0
					aCols[n][nSD1OP] := cCodOP
				EndIf
				If Type("M->D3_OP") <> "U"
					M->D3_OP := cCodOP
				EndIf
				If Type("M->CP_OP") <> "U"
					M->CP_OP := cCodOP
				EndIf
			EndIf
		EndIf
	EndIf

	// Devolve as áreas
	RestArea(aAreaSC2)
	RestArea(aAreaTQB)
	RestArea(aAreaOld)

Return lRetorno

//----------------------------------------------------------------
/*/{Protheus.doc} ³NGCRIAUNID
Cria unidade de medida hora utilizada para insumo do tipo mao
de obra, se a integridade referencial estiver ligada senao
encONtrar esta unidade da erro de integridade

@author Elisangela Costa
@since 07/12/2005

@param nVerOld - Versão antiga da execução da função
	   nVerAtu - Versão atual da função

@versiON MP11
/*/
//----------------------------------------------------------------
Function NGCRIAUNID(nVerOld,nVerAtu)

	Local lNAOACHOU := .F.

	Default nVerOld := 0
	Default nVerAtu := 1

	dbSelectArea("SAH")
	dbSetOrder(01)
	If !dbSeek(xFilial("SAH")+"H")
	Else
		While !EoF() .And. xFilial( "SAH" ) = SAH->AH_FILIAL
			If Alltrim( SAH->AH_UNIMED ) == "H"
			lNAOACHOU := .T.
			Exit
		EndIf
			dbSkip()
		End While
	EndIf
	If !lNAOACHOU
		RecLock("SAH",.T.)
		SAH->AH_FILIAL := xFilial("SAH")
		SAH->AH_UNIMED := "H"
		SAH->AH_UMRES  := "HORA"
		SAH->AH_DESCPO := "HORA"
		SAH->AH_DESCIN := "TIME"
		SAH->AH_DESCES := "HORA"
		MsUnLock("SAH")
	EndIf

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGVALPRASTRE³ Autor ³Elisangela Costa       ³ Data ³10/03/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida parametro de rastriabilidade e tipo do insumo.         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGVALPRASTRE()
If FunName() == "MNTA656"
	If Type("oBrw1") != "U"
		Return If(Alltrim(GetMv("MV_RASTRO"))="S" .And. Alltrim(GetMv("MV_NGMNTES"))="S" .And. If(FunName()=="MNTA656",If(!Empty(oBrw1:aCols[n][nPOSLUBRI]),.T.,.F.),If(M->TL_TIPOREG == "P",.T.,.F.)),.T.,.F.)
	Else
		Return .T.
	EndIf
Else
	Return If(Alltrim(GetMv("MV_RASTRO"))="S" .And. Alltrim(GetMv("MV_NGMNTES"))="S" .And. M->TL_TIPOREG == "P",.T.,.F.)
EndIf
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGVCONLOC   ³ Autor ³Elisangela Costa       ³ Data ³10/03/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida parametro de cONtrole de localizacao.                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGVCONLOC()
If FunName() == "MNTA656"
	If Type("oBrw1") != "U"
		Return If(Alltrim(GetMv("MV_LOCALIZ"))="S" .And. Alltrim(GetMv("MV_NGMNTES"))="S" .And. If(FunName()=="MNTA656",If(!Empty(oBrw1:aCols[n][nPOSLUBRI]),.T.,.F.),If(M->TL_TIPOREG == "P",.T.,.F.)),.T.,.F.)
	Else
		Return .T.
	EndIf
Else
	Return If(Alltrim(GetMv("MV_LOCALIZ")) ="S" .And. Alltrim(GetMv("MV_NGMNTES"))="S" .And. M->TL_TIPOREG == "P",.T.,.F.)
EndIf
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NgCONnDB  ³ Autor ³ Thiago Olis Machado    ³ Data ³27 /01/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ CONecta a um outro banco de dados existente no TOP.         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aFiles -> Array cONtendo:                                   ³±±
±±³          ³           Nome da Tabela a ser aberta.                      ³±±
±±³          ³           Nome do Alias desejado.                           ³±±
±±³          ³ cDbAlias  Nome do Alias do Banco de Dados                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ <= 0 Nao cONseguiu cONectar a tabela desejada               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NgCONnDB(aFiles,cDbAlias,cSelect)

Local cDriver := "DBFCDX" , i

#IFDEF TOP
	Local cAlias
	Local cServer
	Local cCONType
	Local cHasMapper
	Local cProtect
	Local nPort
	Local __nCONecta
	Local __cLastCONn
	Local xCONnect
	Local cDataBase
	Local cIniFile := GetAdv97()
#EndIf

#IFDEF TOP
	cDataBase  := GetPvProfString("TopCONnect","DataBase","ERROR",cInIfile )
	cAlias	   := GetPvProfString("TopCONnect","Alias","ERROR",cInIfile )
	cServer	   := GetPvProfString("TopCONnect","Server","ERROR",cInIfile )
	cCONType   := Upper(GetPvProfString("TopCONnect","CONtype","TCPIP",cInIfile ))
	cHasMapper := Upper(GetPvProfString("TopCONnect","Mapper","ON",cInIfile ))
	cProtect   := GetPvProfString("TopCONnect","ProtheusONly","0",cInIfile )
	nPort      := Val(GetPvProfString("TopCONnect","Port","0",cInIfile ))

	// Ajuste pelo EnvirONment do Server
	cDataBase  := GetSrvProfString("TopDataBase",cDataBase)
	cAlias	   := cDbAlias
	cServer	   := GetSrvProfString("TopServer",cServer)
	cCONType   := Upper(GetSrvProfString("TopCONtype",cCONType))
	cHasMapper := Upper(GetSrvProfString("TopMapper",cHasMapper))
	cProtect   := GetSrvProfString("TopProtheusONly",cProtect)
	nPort      := Val(GetSrvProfString("TopPort",StrZero(nPort,4,0)))   //Soh Para CONexao TCPIP

	xCONnect   := AllTrim(cDataBase) + "#" + AllTrim(cAlias) + "#" + AllTrim(cServer) + "#" + ;
				     AllTrim(cCONType) + "#" + AllTrim(cHasMapper) + "#" + AllTrim(cProtect) + "#" + ;
					  StrZero(nPort,4,0)

	PutGlbValue("MYTOPCONNECT",xCONnect)

	If !(AllTrim(cCONtype)$"TCPIP/NPIPE")
		UserExceptiON("Invalid CONType")
	EndIf

	If "ERROR" $ cDataBase+cAlias+cServer
		UserExceptiON("CONfiguratiON Error in .INI File")
	EndIf

	If cProtect == "1"
		cProtect := "@@__@@"    //Assinatura para o TOP
	Else
		cProtect := ""
	EndIf

	__cLastCONn := cDatabase+";"+cAlias+";"+cServer

	TCCONType(cCONType)
	If (("AS" $ cAlias) .And. ("400" $ cAlias))
		__nCONecta := TCLink(cDataBase,cServer,nPort)
	Else
		__nCONecta := TCLink(cProtect+"@!!@"+AllTrim(cDataBase)+"/"+AllTrim(cAlias),cServer,nPort)  // Nao Comer Licenca do Top

		If __nCONecta < 0
			__nCONecta := TCLink(cProtect+cDataBase+"/"+cAlias,cServer,nPort)
		EndIf
	EndIf

	If (__nCONecta < 0)
		If Empty(cProtect)
			UserExceptiON("TOPCONN CONnectiON Failed - Error ("+Str(__nCONecta,4,0)+")"+__cLastCONn)
		Else
			UserExceptiON("TOPProtect CONnectiON Failed - Error ("+Str(__nCONecta,4,0)+")"+__cLastCONn)
		EndIf
	EndIf
	TcInternal( 8, "RPC->"+cFuncao )
	cDriver := "TOPCONN"
	TcSetDummy(.T.)
#EndIf

#ifdef TOP
	TcSetDummy(.F.)
#EndIf

#IFDEF AXS
	cDriver := "DBFCDXAX"
#EndIf
#IFDEF CTREE
	cDriver := "CTREECDX"
#EndIf
#IFDEF BTV
	cDriver := "BTVCDX"
#EndIf

For i := 1 To Len(aFiles)
	NgOpenFile(aFiles[i][1],aFiles[i][2], cDriver,cSelect)
Next

Return .T.

Static Function NgOpenFile(cTabela, cAlias, cDriver, cSelect)

cQuery := cSelect+cTabela

TCQUERY cQuery NEW ALIAS &(cAlias)
If NetErr()
	UserExceptiON(cAlias + " Open Failed")
EndIf

TcSetCONn(AdvCONnectiON())
Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VALDT     ³ Autor ³HeversON Vitoreti      ³ Data ³ 13/03/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Validaçao de data                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³VALDT                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function VALDT(dDataC)
Local dDataH := dDatabase
If dDataH < dDataC
   Help(" ",1,STR0101,"DATAINVAL",,3,1) //"ATENCAO"
   Return .F.
EndIf
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³NgMovEstoque³ Autor ³ Evaldo Cevinscki Jr.  ³ Data ³14/03/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gera Movimento de Requisicao e/ou Devolucao nos Arquivos de  ³±±
±±³          ³ Movimentacao Interna (SD3).                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ NgMovEstoque(cCod,cComb)                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCod  = PRO ou RE0                                           ³±±
±±³          ³ cAlm  = Almoxerifado                                         ³±±
±±³          ³ cProd = Produto                                              ³±±
±±³          ³ cSeq  = Sequencia                                            ³±±
±±³          ³ cUM   = Unidade de Medida                                    ³±±
±±³          ³ nQuant= Quantidade                                           ³±±
±±³          ³ dData = Data                                                 ³±±
±±³          ³ cCeCusto = Centro de Custo                                   ³±±
±±³          ³ cFilMov  = Filial do Movimento (SD3)                         ³±±
±±³          ³ cFilBem  = Filial do Bem                                     ³±±
±±³          ³ lDevTrP  = Indica se e uma devolucao com troca de produto    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SigaMNT                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NgMovEstoque(cCod,cAlm,cProd,cSeq,cUM,nQuant,dData,cDocEst,cCeCusto,cFilMov,;
                      cBem,cFilBem,lDevTrP,vRastro)
Local cAlmoxa    := CriaVar( 'D3_LOCAL' )
Local cLoteCtl   := CriaVar( 'D3_LOTECTL' )
Local cNumLote   := CriaVar( 'D3_NUMLOTE' )
Local cLocaliz   := CriaVar( 'D3_LOCALIZ' )
Local cNumSeri   := CriaVar( 'D3_NUMSERI' )
Local cnumSeqD   := CriaVar( 'D3_NUMSEQ' )
Local cItemCta   := CriaVar( 'D3_ITEMCTA' )
Local nQtdOco    := 0
Local cLocOco    := cAlm
Local _FilialAnt := cFilAnt //Salva filial corrente
Local cDoc       := ""
Local cNumSeq    := ""
Local cCTTSI3
Local lTrProD    := If(lDevTrP = Nil,.F.,lDevTrP)
Local vRastr	 := If(vRastro = Nil,{},vRastro)
Local cRet       := ""
Local aAreaTQN   := TQN->( GetArea() ) // Armazena o ambiente do arquivo TQN.

Private nOpc     := 0

If ValType(cFilMov) == "C"
	If !Empty(cFilMov) .And. Len(cFilMov) == Len(cFilAnt)
		cFilAnt := cFilMov //Troca a filial para a que será gerada a movimentação
	EndIf
EndIf

dbSelectArea('TQN')

cLocOco  := If(Empty(cLocOco),'01',cLocOco)
cProduto := cProd

SB1->(dbSetOrder(1))
If SB1->(dbSeek(xFilial('SB1')+cProduto))
	cB1Aprop := SB1->B1_APROPRI
EndIf

dbSelectArea("SBF")
dbSetOrder(2)
dbSeek(xFilial("SBF")+cProduto+cLocOco)
cAlmoxa  := cLocOco
cLoteCtl := If(Empty('BF_LOTECTL'), '', SBF->BF_LOTECTL)
cNumLote := If(Empty('BF_NUMLOTE'), '', SBF->BF_NUMLOTE)
cLocaliz := If(Empty('BF_LOCALIZ'), '', SBF->BF_LOCALIZ)
cNumSeri := If(Empty('BF_NUMSERI'), '', SBF->BF_NUMSERI)

If Len(vRastr) <> 0
	//cLocalEs,cSubLote,cLoTecTl,cNumSeri,cLocaliz,dDtvalid
	cAlmoxa  := vRastr[1]
	cLoteCtl := vRastr[3]
	cNumLote := vRastr[2]
	cLocaliz := vRastr[5]
	cNumSeri := vRastr[4]
EndIf
If Substr(cCod,1,1) = "D"
   nOpc := If(lTrProD,3,5) // Manipulação na devolução do rodados com troca de código
                           // do produto na saída do Pneus da estrutura.
Else
	nOpc := 3
	dbSelectArea("SD3")
	dbSetOrder(8)
	If dbSeek(xFilial("SD3")+cDocEst+cNumSeq)
		cDocEst := NextNumero("SD3",2,"D3_DOC",.T.)
	EndIf
EndIf

aAutoItens := 			{	{"D3_TM"      , If(cCod=='RE0', '999', '499') 				 			, '.T.'},;
								{"D3_COD"     , cProduto							  					 		, Nil},;
								{"D3_UM"      , cUM                                         	   		, Nil},;
								{"D3_QUANT"   , nQuant					  							    	, Nil},;
								{"D3_CF"	     , cCod								     					, Nil},;
								{"D3_CONTA"   , SB1->B1_CONTA					    					 	, Nil},;
								{"D3_LOCAL"   , If(Empty(cAlmoxa), SB1->B1_LOCPAD, cAlmoxa) 			, Nil},;
								{"D3_EMISSAO" , dData								   		 				, Nil},;
								{"D3_SEGUM"   , SB1->B1_SEGUM					  						 	, Nil},;
								{"D3_QTSEGUM" , CONvUm(SB1->B1_COD,nQtdOco,0,2)							, Nil},;
								{"D3_GRUPO"   , SB1->B1_GRUPO									  	    	, Nil},;
								{"D3_TIPO"    , SB1->B1_TIPO					  						  	, Nil},;
								{"D3_NUMSERI" , cNumSeri				  								 	 	, Nil},;
								{"D3_CHAVE"   , SubStr(SD3->D3_CF,2,1)+If(SD3->D3_CF $ 'RE4|DE4','9','0')     , Nil},;
								{"D3_USUARIO" , If(Len(SD3->D3_USUARIO) > 15,cUsername,Substr(cUsuario,7,15)) , Nil},;
							    {"D3_ESTORNO" , If(Substr(cCod,1,1) == "D","S",Space(Len(SD3->D3_ESTORNO)))	 , Nil},;
								{"D3_DOC"     , cDocEst				  								 	 	, Nil}}

If NGCADICBASE("T9_ITEMCTA","A","ST9",.F.)
	cFiliBem := NGTROCAFILI("ST9",cFilBem)
	If cBem != Nil
		cItemCta := NGSEEK("ST9",cBem,1,"T9_ITEMCTA",cFiliBem)
		If !Empty(cItemCta) .And. NGIFdbSeek("CTD",cItemCta,1)
			aAdd( aAutoItens , {"D3_ITEMCTA",cItemCta,Nil} )
		EndIf
	EndIf
EndIf

If ValType(cCeCusto) == "C"
	If !Empty(cCeCusto)

		cCTTSI3 := If(CtbInUse(), "CTT", "SI3")

		dbSelectArea(cCTTSI3)
		dbSetOrder(1)
		If dbSeek(xFilial(cCTTSI3)+cCeCusto)
			aAdd( aAutoItens , {"D3_CC",cCeCusto,Nil} )
		EndIf

	EndIf
EndIf

If Len(vRastr) <> 0
	//cLocalEs,cSubLote,cLoTecTl,cNumSeri,cLocaliz,dDtvalid
	aAdd( aAutoItens , {"D3_LOTECTL",cLoteCtl,Nil} )
	aAdd( aAutoItens , {"D3_NUMLOTE",cNumLote,Nil} )
	aAdd( aAutoItens , {"D3_LOCALIZ",cLocaliz,Nil} )
	aAdd( aAutoItens , {"D3_NUMSERI",cNumSeri,Nil} )
EndIf
aAdd( aAutoItens , {"INDEX",2,Nil} ) //A coluna INDEX deve SEMPRE ser adiciONada por ultimo no array

lMsErroAuto := .F.

dbSelectArea("SB2")
dbSetOrder(01)
If !dbSeek(xFilial("SB2")+cProduto+If(Empty(cAlmoxa), SB1->B1_LOCPAD, cAlmoxa))
   CriaSB2(cProduto,If(Empty(cAlmoxa), SB1->B1_LOCPAD, cAlmoxa))
EndIf

lOldInclui := If(Type('Inclui') == 'L',Inclui,.T.)
Inclui := .T.
__lSx8 := .F.

MSExecAuto({|x,y| MATA240(x,y)},aAutoItens,nOpc)
cRet := SD3->D3_NUMSEQ
//Alterado ponto do restarea devido a utilização dos dados do abastecimento na Função de Integração
RestArea( aAreaTQN ) // Restaura o ambiente do arquivo TQN.

Inclui := lOldInclui

If lMsErroAuto
	If !IsBlind()
		Mostraerro()
	EndIf
	cRet := ""
Else
	//-------------------------------------
	//INTEGRACAO POR MENSAGEM UNICA
	//-------------------------------------
	If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"  //Mensagem Unica
		If AllTrim(SD3->D3_ESTORNO) == "S"
			NGMUCanReq(SD3->(RecNo()),"SD3")
		Else
			If !NGMUStoTuO(SD3->(RecNo()),"SD3")
			aadd(aAutoItens,{"D3_NUMSEQ",cRet,})
			aadd(aAutoItens,{"INDEX",3,})
			MSExecAuto({|x,y| MATA240(x,y)},aAutoItens,5)
			cRet := ""
			EndIf
		EndIf
	EndIf
EndIf

cFilAnt := _FilialAnt //Retorna a filial salva

Return cRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGWHENLOCA  ³ Autor ³Elisangela Costa       ³ Data ³02/06/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida X3_WHEN do campo TL_LOCAL                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGWHENLOCA()
Local nTipo := Ascan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_TIPOREG"})

If FunName() == "MNTA656"
	If Type("oBrw1") != "U"
		Return If(Alltrim(GetMv("MV_NGMNTES"))="S" .And. Inclui .And. !Empty(oBrw1:aCols[n][nPOSLUBRI]),.T.,.F.)
	Else
		Return .T.
	EndIf
ElseIf nTipo > 0
	If aCols[n][nTipo] == "P" .Or. aCols[n][nTipo] == "T"
		Return SuperGetMv("MV_NGMNTES",.F.,"N")=="S"
	EndIf
Else
	Return If(M->TL_TIPOREG == "P" .And. Alltrim(GetMv("MV_NGMNTES"))="S",.T.,.F.)
EndIf

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGGRACUSD3  ³ Autor ³Elisangela Costa       ³ Data ³11/09/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava os campos de usuaruio do STL relaciONados no SD3        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGGRACUSD3()
Local aAREATU    := GetArea()
Local aCposAlter := {} //Grava campos de usuario do STL
Local aNgHeader  := {}
Local nI         := 0
Local nTamTot    := 0
Local nInd       := 0

//Buscar os campos das tabela.
aNgHeader := NGHeader("STL")
nTamTot := Len(aNgHeader)
For nInd := 1 To nTamTot
	If Posicione("SX3",2,aNgHeader[nInd,2],"X3_PROPRI") == "U"
		Aadd(aCposAlter,aNgHeader[nInd,2])
	EndIf
Next nInd

If Len(aCposAlter) > 0
   dbSelectArea("SD3")
   For nI := 1 To Len(aCposAlter)
      nONDERL := At("_",aCposAlter[nI])
      If nONDERL > 0
         cCAMIGUA := Alltrim(Substr(aCposAlter[nI],nONDERL+1,Len(aCposAlter[nI])))
         cCAMPSTL := "STL->TL_"+cCAMIGUA
         cCAMPSD3 := "SD3->D3_"+cCAMIGUA
         cFILPOS3 := "D3_"+cCAMIGUA
         If FieldPos(cFILPOS3) > 0
            RecLock("SD3",.F.)
            &cCAMPSD3 := &cCAMPSTL
            MsUnLock("SD3")
         EndIf
      EndIf
   Next nI
EndIf

RestArea(aAREATU)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGVWHENHDT³ Autor ³ Elisangela Costa      ³ Data ³ 06/11/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Abre ou fecha os campos de data\hora de aplicacao do insumo ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA420                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGVWHENHDT()
	
	Local lRet := .T., nDtIni  := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTINICI" })

	If Type("cPROGRAMA") <> "U"

		If cPROGRAMA = "MNTA420" .Or. cPROGRAMA = "MNTA090" .Or. cPROGRAMA = "MNTA450" .Or. cPROGRAMA = "MNTA295" .Or. cPROGRAMA = "MNTA490"
			
			lRet := .F.
			
			If aCOLS[n,nTIPHEA] = "M" .And. aCOLS[n,nUSACAL] = "S"
				lRet := .T.
			EndIf

		EndIf

	EndIf

	If IsInCallStack( 'NG410INC' )

		lRet := .F.

		If GDFieldGet( 'TL_TIPOREG', oGet:nAt, .F., oGet:aHeader, oGet:aCols ) == 'M' .And.;
		 GDFieldGet( 'TL_USACALE', oGet:nAt, .F., oGet:aHeader, oGet:aCols ) == 'S'

			lRet := .T.

		EndIf

	EndIF

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NGTAFMNT2
CONsistencia de cONsulta especial (F3) estrutura organizaciONal

@param cTRB - Tabela temporaria da estrtura organizaciONal
@param cNivel - Nivel superior do nivel seleciONado na tree
@param cTRBGeral - Tabela que cONtem toda a estrutura organizaciONal, utilizado
					  quando se usa subtree
@author Elisangela Costa
@since 05/06/2007
@versiON MP10
@return aIntEsOg[1][1]
/*/
//---------------------------------------------------------------------
Function NGTAFMNT2(cTRB,cNivel,cTRBGeral)
	
	Local nMod := IIf( nModulo == 19 .Or. nModulo == 95, 4, IIf( nModulo == 35, 5, 6 ) )

	Default cNivel	:= ""
	Default cTRBGeral	:= ""

	aINTESOG := SGESTMOD(nMod,"L",cTRB,cNivel) //MONta a estrutura organizaciONal do SIGAMNT e valida licalizacao

	If Len(aINTESOG) = 0
	Return .F.
	EndIf

	If aINTESOG[1,1]
		If nMod == 4 .And. ( INCLUI .Or. ALTERA )
			If !NGCHKCODORG(aINTESOG[1,2])
				Return .F.
			EndIf
		EndIf

		If (cTRB) == Nil

			dbSelectArea("TAF")
			dbSetOrder(2)
			dbSeek(xFilial("TAF")+'001'+SubStr( aIntEsOg[1,2],4,6 ))

		Else
			//Verifica se a cTRB é a mesma a ser preenchida no retorno
			If Empty(cTRBGeral)
				dbSelectArea(cTRB)
			Else
				dbSelectArea(cTRBGeral)
			EndIf
			
			dbSetOrder(2)
			dbSeek( aIntEsOg[1,2] )

		EndIf

	EndIf

Return aIntEsOg[1][1]

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGChkEstOr  ³ Autor ³ Elisangela Costa      ³ Data ³05/06/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³CONsiste se o codigo da localizacao na estrutura organizac.   ³±±
±±³          ³e valida                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³MV01 -> Parametro De ?                                        ³±±
±±³          ³MV02 -> Parametro Ate?                                        ³±±
±±³          ³cValLBem -> Indica qual tipo de validacao deve fazer          ³±±
±±³          ³            Nil - Nao faz validacao                           ³±±
±±³          ³            L   - Valida se o que foi seleciONando e local.   ³±±
±±³          ³            B   - Valida se o que foi seleciONando e Bem      ³±±
±±³          ³nIndParm -> Indica qual parametro deve ser validado(De ou Ate)³±±
±±³          ³            1 - Indica parametro De?                          ³±±
±±³          ³            2 - Indica parametro Ate?                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³SIGAMNT                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGChkEstOr(MV01,MV02,cValLBem,nIndParm)
Local lRet := .T.
If nIndParm = 1
   If Empty(MV01)
      lRet := .T.
   Else
      dbSelectArea("TAF")
      dbSetOrder(2)
      dbSeek(xFilial("TAF")+'001'+MV01)
      If Existcpo('TAF','001'+MV01)
         If cValLBem <> Nil
		      dbSelectArea("TAF")
  		      dbSetOrder(2)
		      dbSeek(xFilial("TAF")+'001'+MV01)
	         If cValLBem == "L"  //Localizacao
	            If TAF->TAF_INDCON <> "2"
	               MsgStop(STR0112,STR0101) //"SeleciONe uma localização." # "ATENCAO"
	               lRet := .F.
	            EndIf
	         Else
		      	If TAF->TAF_INDCON <> "1"
	               MsgStop(STR0113,STR0101) //"SeleciONe um bem." # "ATENCAO"
	               lRet := .F.
	            EndIf
	         EndIf
			EndIf
      Else
         lRet := .F.
      EndIf
   EndIf
Else
	If MV02 <> "ZZZ"
		dbSelectArea("TAF")
		dbSetOrder(2)
		dbSeek(xFilial("TAF")+'001'+MV02)
		If cValLBem <> Nil
			dbSelectArea("TAF")
			dbSetOrder(2)
			dbSeek(xFilial("TAF")+'001'+MV02)
			If cValLBem == "L"  //Localizacao
				If TAF->TAF_INDCON <> "2"
					MsgStop(STR0112,STR0101) //"SeleciONe uma localização." # "ATENCAO"
					lRet := .F.
				EndIf
			Else
				If TAF->TAF_INDCON <> "1"
					MsgStop(STR0113,STR0101) //"SeleciONe um bem." # "ATENCAO"
					lRet := .F.
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ NGCHKGASD1 | Autor ³Elisangela Costa     ³ Data ³22/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Checa se o insumo informado esta em garantia pelo documento³±±
±±³          ³ de entrada (Estoque SD1)                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Paramtros ³ lChkLoc  --> .T. ou .F. (Indica se valida apenas quando    ³±±
±±³          ³             a localizacao for igual)                       ³±±
±±³          ³ cCODBEM  --> Codigo do bem                                 ³±±
±±³          ³ cCODPROD --> Codigo do produto                             ³±±
±±³          ³ cTIPOINS --> Tipo do Insumo                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCHKGASD1(lChkLoc,cCODBEM,cCODPROD,cTIPOINS)
Local lGarDt := .F.,lGarCON := .F.
Local cLoc   := Space(1)
Local dDtVal := CtoD("  /  /  ")
Local dIniGar:= CtoD("  /  /  ")
Local dFimGar:= CtoD("  /  /  ")
Local cOSGar := Space(1)
Local nIniGar:= 0
Local nFimGar:= 0
Local nCONAtu:= 0, nPosCON := 0
nCONAtu := STJ->TJ_POSCONT
nCONAt2 := STJ->TJ_POSCON2
cBem := STJ->TJ_CODBEM

dbSelectArea("TPZ")
dbSetOrder(1)
dbSeek(xFilial("TPZ")+cCODBEM+cTIPOINS+cCODPROD)
While !EoF() .And. TPZ->TPZ_FILIAL == xFilial("TPZ") .And. TPZ->TPZ_CODBEM == cCODBEM .And. ;
	TPZ->TPZ_TIPORE == cTIPOINS .And. TPZ->TPZ_CODIGO == cCODPROD

	If TPZ->TPZ_UNIGAR = "D"
   	dDtVal := TPZ->TPZ_DTGARA + TPZ->TPZ_QTDGAR
   ElseIf TPZ->TPZ_UNIGAR = "S"
   	dDtVal := TPZ->TPZ_DTGARA + (TPZ->TPZ_QTDGAR * 7)
   ElseIf TPZ->TPZ_UNIGAR = "M"
   	dDtVal := TPZ->TPZ_DTGARA + (TPZ->TPZ_QTDGAR * 30)
   EndIf

   If dDtVal > dDataBase
      lGarDt := .T.
   	cLoc := TPZ->TPZ_LOCGAR
   	dIniGar := TPZ->TPZ_DTGARA
   	dFimGar := dDtVal
   	cOSGar := TPZ->TPZ_ORDEM
   EndIf
   If lGarDt
   	If lChkLoc
   		If cLoc == cLocaliz
   			lMens := .T.
   		Else
   			lMens := .F.
   		EndIf
   	Else
   		lMens := .T.
   	EndIf
   	If lMens
   	   MsgAlert(STR0134+CHR(13); //"Insumo substituido no prazo de Garantia"
		           +STR0135+" "+AllTrim(Str(Day(dIniGar)))+"/"+AllTrim(Str(MONth(dIniGar)))+"/"+AllTrim(Str(Year(dIniGar)))+"    "+STR0136+" "+cOSGar+CHR(13); //"Data de Inicio de uso :"#"O.S.:"
		           +STR0137+"..............: "+AllTrim(Str(Day(dFimGar))+"/"+AllTrim(Str(MONth(dFimGar)))+"/"+AllTrim(Str(Year(dFimGar))))+CHR(13); //"Garantia Ate"
		           +If(Empty(cLoc)," ",STR0138+"..........: "+cLoc))  //"Na Localização"
	   EndIf
		lGarDt := .F.
	EndIf
	If NGCADICBASE("TPZ_QTDCON","A","TPZ",.F.)
   If !Empty(TPZ->TPZ_QTDCON)
   	If TPZ->TPZ_CONGAR == '1'
	   	dbSelectArea("STJ")
			dbSetOrder(1)
			If dbSeek(xFilial("STJ")+TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO)
				If nCONAtu < (STJ->TJ_POSCONT + TPZ->TPZ_QTDCON)
					lGarCON := .T.
					cLoc    := TPZ->TPZ_LOCGAR
					nIniGar := STJ->TJ_POSCONT
					nFimGar := STJ->TJ_POSCONT + TPZ->TPZ_QTDCON
					cOSGar  := TPZ->TPZ_ORDEM
					nPosCON := nCONAtu
				EndIf
			EndIf
		ElseIf TPZ->TPZ_CONGAR == '2'
	   	dbSelectArea("STJ")
			dbSetOrder(1)
			If dbSeek(xFilial("STJ")+TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO)
				If nCONAt2 < (STJ->TJ_POSCON2 + TPZ->TPZ_QTDCON)
					lGarCON := .T.
					cLoc    := TPZ->TPZ_LOCGAR
					nIniGar := STJ->TJ_POSCON2
					nFimGar := STJ->TJ_POSCON2 + TPZ->TPZ_QTDCON
					cOSGar  := TPZ->TPZ_ORDEM
					nPosCON := nCONAt2
				EndIf
			EndIf
		EndIf
		If lGarCON
			If lChkLoc
	   		If cLoc == cLocaliz
	   			lMens := .T.
	   		Else
	   			lMens := .F.
	   		EndIf
	   	Else
	   		lMens := .T.
	   	EndIf
	   	If lMens
				MsgAlert(STR0134+CHR(13)+CHR(13);  //"Insumo substituido no prazo de Garantia"
			           +STR0139+AllTrim(Str(nIniGar))+CHR(13); //"CONtador no inicio do uso: "
			           + STR0136+cOSGar+CHR(13); //"O.S.:"
			           +STR0140+AllTrim(Str(nPosCON))+CHR(13); //"CONtador atual: "
			           +STR0137+": "+AllTrim(Str(nFimGar))+CHR(13); //"Garantia Ate"
			           +If(Empty(cLoc)," ",STR0138+": "+cLoc)) //"Na Localização"
				lGarCON := .F.
			EndIf
		EndIf
	EndIf
	EndIf
	dbSelectArea("TPZ")
	dbSkip()
End
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NgReplic ³ Autor ³ Inacio Luiz Kolling   ³ Data ³ 31/03/05   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza os novos campos da base                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ NGATUSEQ                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NgReplic(cALI,cASERAP,cCAMPV,nIND)

Local cCAMP := cALI+"->"+cASERAP
Local cCAMV := cALI+"->"+cCAMPV
Local vENDF := {},xy := 0
Local cCAMPO := ""
Local cCampo2 := ""
Local cQuery := ""
If Substr(cALI,1,1) == "S"
   cCampo  := cALI + "->" + SUBSTR(cALI,2,2) + "_FILIAL"
   cCampo2 := SUBSTR(cALI,2,2) + "_FILIAL"
Else
   cCampo  := cALI + "->" + cALI + "_FILIAL"
   cCampo2 := cALI + "_FILIAL"
EndIf
dbSelectArea(cALI)
If cAli $ "STG|STM|TPM|STU|TPI"
	cIndex := CriaTrab(Nil, .F.)
	IndRegua(cAli,cIndex,cCampo2,,,"Indexando Arquivo de Trabalho")
EndIf

dbSelectArea(cALI)
If cALI = "ST5"
   dbSetOrder(2)
ElseIf cALI = "STC"
   dbSetOrder(1)
ElseIf cALI = "STF"
   dbSetOrder(3)
ElseIf cALI = "STH"
	dbSetOrder(2)
ElseIf cALI = "STJ"
	dbSetOrder(5)
ElseIf cALI = "STL"
	dbSetOrder(4)
ElseIf cALI = "STN"
	dbSetOrder(2)
ElseIf cALI = "STS"
   dbSetOrder(3)
ElseIf cALI = "STT"
	dbSetOrder(2)
ElseIf cALI = "TP1"
	dbSetOrder(2)
ElseIf cALI = "TP2"
	dbSetOrder(2)
ElseIf cALI = "TP5"
	dbSetOrder(2)
ElseIf cALI = "TPF"
	dbSetOrder(2)
ElseIf cALI = "TPG"
	dbSetOrder(2)
ElseIf cALI = "TPH"
	dbSetOrder(2)
ElseIf cALI = "TPP"
	dbSetOrder(2)
ElseIf cALI = "TPV"
	dbSetOrder(2)
ElseIf cALI = "TPW"
	dbSetOrder(3)
ElseIf cALI = "TPZ"
	dbSetOrder(3)
ElseIf cALI = "TQ1"
	dbSetOrder(2)
EndIf

dbGoTop()
While !EoF()

   RecLock(cALI,.F.)
   If Empty(&cCAMP)
      If cALI == "TPV"
         &cCAMP := Alltrim(STR(&cCAMV,5))
      ElseIf cALI == "TQ1"
         &cCAMP := Alltrim(STR(&cCAMV,4))
      ElseIf cALI == "STL"
         STL->TL_SEQRELA := Alltrim(STR(STL->TL_SEQUENC,3))
         STL->TL_SEQRMAN := Alltrim(STR(STL->TL_SEQMAN,3))
      ElseIf cALI == "STT"
         STT->TT_SEQRELA := Alltrim(STR(STT->TT_SEQUENC,3))
         STT->TT_SEQRMAN := Alltrim(STR(STT->TT_SEQMAN,3))
      ElseIf cALI == "TP1"
         TP1->TP1_SEQREL := Alltrim(STR(TP1->TP1_SEQUEN,3))
         TP1->TP1_SEQRMN := Alltrim(STR(TP1->TP1_SEQUMN,3))
      Else
         &cCAMP := Alltrim(STR(&cCAMV,3))
      EndIf
   EndIf

   If cALI = "STJ"
      If Empty(stj->tj_tipoos)
         STJ->TJ_TIPOOS := "B"
      EndIf
   ElseIf cALI = "STS"
      If Empty(sts->ts_tipoos)
         STS->TS_TIPOOS := "B"
      EndIf
   EndIf
   (cALI)->(MsUnLock())
   dbSkip()

End
dbSetOrder(1)
If cAli $ "STG|STM|TPM|STU|TPI"
	Ferase(cIndex + OrdBagExt() )
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGUSQLSEQP³ Autor ³ Inacio Luiz Kolling   ³ Data ³ 31/03/05   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Atualiza os novos campos da base                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NGATUSEQ                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGUSQLSEQP()

Local _cGetDB := TcGetDb()
Local vETALI  := {"ST5","STC","STF","STG","STH","STJ","STL","STM","STN","STS",;
                  "STT","STU","TP1","TP2","TP5","TPF","TPG","TPH","TPI","TPM",;
                  "TPP","TPV","TPW","TPZ","TQ1"},xl := 0

For xl := 1 To Len(vETALI)

   dbSelectArea(vETALI[xl])
   dbGoTop()

   cQuery := "UPDATE "
   cQuery += RetSqlName(vETALI[XL])+" "

   If Upper(_cGetDB) == "ORACLE"
	   If vETALI[XL] = "ST5"
	      cQuery +="SET T5_SEQRELA = Trim(T5_SEQUENC) "
	      cQuery +="WHERE T5_SEQRELA = '   '"

	   ElseIf vETALI[XL] = "STC"
	      cQuery +="SET TC_SEQRELA = Trim(TC_SEQUENC) "
	      cQuery +="WHERE TC_SEQRELA = '   '"

	   ElseIf vETALI[XL] = "STF"
	      cQuery +="SET TF_SEQRELA = Trim(TF_SEQUENC) "
	      cQuery +="WHERE TF_SEQRELA = '   '"

	   ElseIf vETALI[XL] = "STG"
	      cQuery +="SET TG_SEQRELA = Trim(TG_SEQUENC) "
	      cQuery +="WHERE TG_SEQRELA = '   '"

	   ElseIf vETALI[XL] = "STH"
	      cQuery +="SET TH_SEQRELA = Trim(TH_SEQUENC) "
	      cQuery +="WHERE TH_SEQRELA = '   '"

	   ElseIf vETALI[XL] = "STJ"
	      cQuery +="SET TJ_SEQRELA = Trim(TJ_SEQUENC),TJ_TIPOOS = 'B' "
	      cQuery +="WHERE TJ_SEQRELA = '   '"

	   ElseIf vETALI[XL] = "STL"
	      cQuery +="SET TL_SEQRELA = Trim(TL_SEQUENC),TL_SEQRMAN = Trim(TL_SEQMAN) "
	      cQuery +="WHERE TL_SEQRELA = '   '"

	   ElseIf vETALI[XL] = "STM"
	      cQuery +="SET TM_SEQRELA = Trim(TM_SEQUENC) "
	      cQuery +="WHERE TM_SEQRELA = '   '"

	   ElseIf vETALI[XL] ="STN"
	      cQuery +="SET TN_SEQRELA = Trim(TN_SEQUENC) "
	      cQuery +="WHERE TN_SEQRELA = '   '"

	   ElseIf vETALI[XL] = "STS"
	      cQuery +="SET TS_SEQRELA = Trim(TS_SEQUENC),TS_TIPOOS = 'B' "
	      cQuery +="WHERE TS_SEQRELA = '   '"

	   ElseIf vETALI[XL] = "STT"
	      cQuery +="SET TT_SEQRELA = Trim(TT_SEQUENC),TT_SEQRMAN = Trim(TT_SEQMAN) "
	      cQuery +="WHERE TT_SEQRELA = '   '"

	   ElseIf vETALI[XL] = "STU"
	      cQuery +="SET TU_SEQRELA = Trim(TU_SEQUENC) "
	      cQuery +="WHERE TU_SEQRELA = '   '"

	   ElseIf vETALI[XL] = "TP1"
	      cQuery +="SET TP1_SEQREL = Trim(TP1_SEQUEN),TP1_SEQRMN = Trim(TP1_SEQUMN) "
	      cQuery +="WHERE TP1_SEQREL = '   '"

	   ElseIf vETALI[XL] = "TP2"
	      cQuery +="SET TP2_SEQREL = Trim(TP2_SEQUEN) "
	      cQuery +="WHERE TP2_SEQREL = '   '"

	   ElseIf vETALI[XL] = "TP5"
	      cQuery +="SET TP5_SEQREL = Trim(TP5_SEQUEN) "
	      cQuery +="WHERE TP5_SEQREL = '   '"

	   ElseIf vETALI[XL] = "TPF"
	      cQuery +="SET TPF_SEQREL = Trim(TPF_SEQUEN) "
	      cQuery +="WHERE TPF_SEQREL = '   '"

	   ElseIf vETALI[XL] = "TPG"
	      cQuery +="SET TPG_SEQREL = Trim(TPG_SEQUEN) "
	      cQuery +="WHERE TPG_SEQREL = '   '"

	   ElseIf vETALI[XL] = "TPH"
	      cQuery +="SET TPH_SEQREL = Trim(TPH_SEQUEN) "
	      cQuery +="WHERE TPH_SEQREL = '   '"

	   ElseIf vETALI[XL] = "TPI"
	      cQuery +="SET TPI_SEQREL = Trim(TPI_SEQUEN) "
	      cQuery +="WHERE TPI_SEQREL = '   '"

	   ElseIf vETALI[XL] = "TPM"
	      cQuery +="SET TPM_SEQREL = Trim(TPM_SEQUEN) "
	      cQuery +="WHERE TPM_SEQREL = '   '"

	   ElseIf vETALI[XL] = "TPP"
	      cQuery +="SET TPP_SEQREL = Trim(TPP_SEQUEN) "
	      cQuery +="WHERE TPP_SEQREL = '   '"

	   ElseIf vETALI[XL] = "TPV"
	      cQuery +="SET TPV_SEQREL = Trim(TPV_SEQUEN) "
	      cQuery +="WHERE TPV_SEQREL = '     '"

	   ElseIf vETALI[XL] = "TPW"
	      cQuery +="SET TPW_SEQREL = Trim(TPW_SEQUEN) "
	      cQuery +=" WHERE TPW_SEQREL = '   '"

	   ElseIf vETALI[XL] = "TPZ"
	      cQuery +="SET TPZ_SEQREL = Trim(TPZ_SEQUEN) "
	      cQuery +="WHERE TPZ_SEQREL = '   '"

	   ElseIf vETALI[XL] = "TQ1"
	      cQuery +="SET TQ1_SEQREL = Trim(TQ1_SEQUEN) "
	      cQuery +="WHERE TQ1_SEQREL = '    '"
	   EndIf
	ElseIf Upper(_cGetDB) == "INFORMIX"
	   If vETALI[XL] = "ST5"
	      cQuery +="SET T5_SEQRELA = Cast(Round(T5_SEQUENC,0) AS Varchar(3,0)) "
	      cQuery +="WHERE T5_SEQRELA = '   ' "

      ElseIf vETALI[XL] = "STC"
	      cQuery +="SET TC_SEQRELA = Cast(Round(TC_SEQUENC,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TC_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STF"
	      cQuery +="SET TF_SEQRELA = Cast(Round(TF_SEQUENC,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TF_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STG"
	      cQuery +="SET TG_SEQRELA = Cast(Round(TG_SEQUENC,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TG_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STH"
	      cQuery +="SET TH_SEQRELA = Cast(Round(TH_SEQUENC,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TH_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STJ"
	      cQuery +="SET TJ_SEQRELA = Cast(Round(TJ_SEQUENC,0) AS Varchar(3,0)) ,TJ_TIPOOS = 'B' "
	      cQuery +="WHERE TJ_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STL"
	      cQuery +="SET TL_SEQRELA = Cast(Round(TL_SEQUENC,0) AS Varchar(3,0)) ,TL_SEQRMAN = Cast(Round(TL_SEQMAN,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TL_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STM"
	      cQuery +="SET TM_SEQRELA = Cast(Round(TM_SEQUENC,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TM_SEQRELA = '   ' "

	   ElseIf vETALI[XL] ="STN"
	      cQuery +="SET TN_SEQRELA = Cast(Round(TN_SEQUENC,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TN_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STS"
	      cQuery +="SET TS_SEQRELA = Cast(Round(TS_SEQUENC,0) AS Varchar(3,0)) ,TS_TIPOOS = 'B' "
	      cQuery +="WHERE TS_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STT"
	      cQuery +="SET TT_SEQRELA = Cast(Round(TT_SEQUENC,0) AS Varchar(3,0)) ,TT_SEQRMAN = Cast(Round(TT_SEQMAN,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TT_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STU"
	      cQuery +="SET TU_SEQRELA = Cast(Round(TU_SEQUENC,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TU_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "TP1"
	      cQuery +="SET TP1_SEQREL = Cast(Round(TP1_SEQUEN,0) AS Varchar(3,0)) ,TP1_SEQRMN = Cast(Round(TP1_SEQUMN,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TP1_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TP2"
	      cQuery +="SET TP2_SEQREL = Cast(Round(TP2_SEQUEN,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TP2_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TP5"
	      cQuery +="SET TP5_SEQREL = Cast(Round(TP5_SEQUEN,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TP5_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPF"
	      cQuery +="SET TPF_SEQREL = Cast(Round(TPF_SEQUEN,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TPF_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPG"
	      cQuery +="SET TPG_SEQREL = Cast(Round(TPG_SEQUEN,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TPG_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPH"
	      cQuery +="SET TPH_SEQREL = Cast(Round(TPH_SEQUEN,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TPH_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPI"
	      cQuery +="SET TPI_SEQREL = Cast(Round(TPI_SEQUEN,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TPI_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPM"
	      cQuery +="SET TPM_SEQREL = Cast(Round(TPM_SEQUEN,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TPM_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPP"
	      cQuery +="SET TPP_SEQREL = Cast(Round(TPP_SEQUEN,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TPP_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPV"
	      cQuery +="SET TPV_SEQREL = Cast(Round(TPV_SEQUEN,0) AS Varchar(5,0)) "
	      cQuery +="WHERE TPV_SEQREL = '     ' "

	   ElseIf vETALI[XL] = "TPW"
	      cQuery +="SET TPW_SEQREL = Cast(Round(TPW_SEQUEN,0) AS Varchar(3,0)) "
	      cQuery +=" WHERE TPW_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPZ"
	      cQuery +="SET TPZ_SEQREL = Cast(Round(TPZ_SEQUEN,0) AS Varchar(3,0)) "
	      cQuery +="WHERE TPZ_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TQ1"
	      cQuery +="SET TQ1_SEQREL = Cast(Round(TQ1_SEQUEN,0) AS Varchar(4,0)) "
	      cQuery +="WHERE TQ1_SEQREL = '    ' "
	   EndIf
   ElseIf Upper(_cGetDB) $ "DB2"
	   If vETALI[XL] = "ST5"
	      cQuery +="SET T5_SEQRELA =  Substr(Cast(Int(T5_SEQUENC) As Char(3)),1,3)"
	      cQuery +="WHERE T5_SEQRELA = '   ' "

      ElseIf vETALI[XL] = "STC"
	      cQuery +="SET TC_SEQRELA = Substr(Cast(Int(TC_SEQUENC) As Char(3)),1,3)"
	      cQuery +="WHERE TC_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STF"
	      cQuery +="SET TF_SEQRELA = Substr(Cast(Int(TF_SEQUENC) As Char(3)),1,3)"
	      cQuery +="WHERE TF_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STG"
	      cQuery +="SET TG_SEQRELA = Substr(Cast(Int(TG_SEQUENC) As Char(3)),1,3)"
	      cQuery +="WHERE TG_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STH"
	      cQuery +="SET TH_SEQRELA = Substr(Cast(Int(TH_SEQUENC) As Char(3)),1,3)"
	      cQuery +="WHERE TH_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STJ"
	      cQuery +="SET TJ_SEQRELA = Substr(Cast(Int(TJ_SEQUENC) As Char(3)),1,3),TJ_TIPOOS = 'B' "
	      cQuery +="WHERE TJ_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STL"
	      cQuery +="SET TL_SEQRELA = Substr(Cast(Int(TL_SEQUENC) As Char(3)),1,3),TL_SEQRMAN = Substr(Cast(Int(TL_SEQMAN) As Char(3)),1,3)"
	      cQuery +="WHERE TL_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STM"
	      cQuery +="SET TM_SEQRELA = Substr(Cast(Int(TM_SEQUENC) As Char(3)),1,3)"
	      cQuery +="WHERE TM_SEQRELA = '   ' "

	   ElseIf vETALI[XL] ="STN"
	      cQuery +="SET TN_SEQRELA = Substr(Cast(Int(TN_SEQUENC) As Char(3)),1,3)"
	      cQuery +="WHERE TN_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STS"
	      cQuery +="SET TS_SEQRELA = Substr(Cast(Int(TS_SEQUENC) As Char(3)),1,3) ,TS_TIPOOS = 'B' "
	      cQuery +="WHERE TS_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STT"
	      cQuery +="SET TT_SEQRELA = Substr(Cast(Int(TT_SEQUENC) As Char(3)),1,3) ,TT_SEQRMAN = Substr(Cast(Int(TT_SEQMAN) As Char(3)),1,3) "
	      cQuery +="WHERE TT_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STU"
	      cQuery +="SET TU_SEQRELA = Substr(Cast(Int(TU_SEQUENC) As Char(3)),1,3) "
	      cQuery +="WHERE TU_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "TP1"
	      cQuery +="SET TP1_SEQREL = Substr(Cast(Int(TP1_SEQUEN) As Char(3)),1,3),TP1_SEQRMN = Substr(Cast(Int(TP1_SEQUMN) As Char(3)),1,3) "
	      cQuery +="WHERE TP1_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TP2"
	      cQuery +="SET TP2_SEQREL = Substr(Cast(Int(TP2_SEQUEN) As Char(3)),1,3) "
	      cQuery +="WHERE TP2_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TP5"
	      cQuery +="SET TP5_SEQREL = Substr(Cast(Int(TP5_SEQUEN) As Char(3)),1,3) "
	      cQuery +="WHERE TP5_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPF"
	      cQuery +="SET TPF_SEQREL = Substr(Cast(Int(TPF_SEQUEN) As Char(3)),1,3)"
	      cQuery +="WHERE TPF_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPG"
	      cQuery +="SET TPG_SEQREL = Substr(Cast(Int(TPG_SEQUEN) As Char(3)),1,3)"
	      cQuery +="WHERE TPG_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPH"
	      cQuery +="SET TPH_SEQREL = Substr(Cast(Int(TPH_SEQUEN) As Char(3)),1,3)"
	      cQuery +="WHERE TPH_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPI"
	      cQuery +="SET TPI_SEQREL = Substr(Cast(Int(TPI_SEQUEN) As Char(3)),1,3)"
	      cQuery +="WHERE TPI_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPM"
	      cQuery +="SET TPM_SEQREL = Substr(Cast(Int(TPM_SEQUEN) As Char(3)),1,3)"
	      cQuery +="WHERE TPM_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPP"
	      cQuery +="SET TPP_SEQREL = Substr(Cast(Int(TPP_SEQUEN) As Char(3)),1,3)"
	      cQuery +="WHERE TPP_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPV"
	      cQuery +="SET TPV_SEQREL = Substr(Cast(Int(TPV_SEQUEN) As Char(5)),1,5)"
	      cQuery +="WHERE TPV_SEQREL = '     ' "

	   ElseIf vETALI[XL] = "TPW"
	      cQuery +="SET TPW_SEQREL = Substr(Cast(Int(TPW_SEQUEN) As Char(3)),1,3)"
	      cQuery +=" WHERE TPW_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPZ"
	      cQuery +="SET TPZ_SEQREL = Substr(Cast(Int(TPZ_SEQUEN) As Char(3)),1,3)"
	      cQuery +="WHERE TPZ_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TQ1"
	      cQuery +="SET TQ1_SEQREL = Substr(Cast(Int(TQ1_SEQUEN) As Char(4)),1,4)"
	      cQuery +="WHERE TQ1_SEQREL = '    ' "
	   EndIf
   Else
		If vETALI[XL] = "ST5"
	      cQuery +="SET T5_SEQRELA = cONvert(integer,T5_SEQUENC) "
         cQuery +="WHERE T5_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STC"
	      cQuery +="SET TC_SEQRELA = cONvert(integer,TC_SEQUENC) "
	      cQuery +="WHERE TC_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STF"
	      cQuery +="SET TF_SEQRELA = cONvert(integer,TF_SEQUENC) "
         cQuery +="WHERE TF_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STG"
	      cQuery +="SET TG_SEQRELA = cONvert(integer,TG_SEQUENC) "
	      cQuery +="WHERE TG_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STH"
	      cQuery +="SET TH_SEQRELA = cONvert(integer,TH_SEQUENC) "
	      cQuery +="WHERE TH_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STJ"
	      cQuery +="SET TJ_SEQRELA = cONvert(integer,TJ_SEQUENC),TJ_TIPOOS = 'B' "
	      cQuery +="WHERE TJ_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STL"
	      cQuery +="SET TL_SEQRELA = cONvert(integer,TL_SEQUENC),TL_SEQRMAN = cONvert(integer,TL_SEQMAN) "
	      cQuery +="WHERE TL_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STM"
	      cQuery +="SET TM_SEQRELA = cONvert(integer,TM_SEQUENC) "
	      cQuery +="WHERE TM_SEQRELA = '   ' "

	   ElseIf vETALI[XL] ="STN"
	      cQuery +="SET TN_SEQRELA = cONvert(integer,TN_SEQUENC) "
	      cQuery +="WHERE TN_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STS"
	      cQuery +="SET TS_SEQRELA = cONvert(integer,TS_SEQUENC),TS_TIPOOS = 'B' "
	      cQuery +="WHERE TS_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STT"
	      cQuery +="SET TT_SEQRELA = cONvert(integer,TT_SEQUENC),TT_SEQRMAN = cONvert(integer,TT_SEQMAN) "
	      cQuery +="WHERE TT_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "STU"
	      cQuery +="SET TU_SEQRELA = cONvert(integer,TU_SEQUENC) "
	      cQuery +="WHERE TU_SEQRELA = '   ' "

	   ElseIf vETALI[XL] = "TP1"
	      cQuery +="SET TP1_SEQREL = cONvert(integer,TP1_SEQUEN),TP1_SEQRMN = cONvert(integer,TP1_SEQUMN) "
	      cQuery +="WHERE TP1_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TP2"
	      cQuery +="SET TP2_SEQREL = cONvert(integer,TP2_SEQUEN) "
	      cQuery +="WHERE TP2_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TP5"
	      cQuery +="SET TP5_SEQREL = cONvert(integer,TP5_SEQUEN) "
	      cQuery +="WHERE TP5_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPF"
	      cQuery +="SET TPF_SEQREL = cONvert(integer,TPF_SEQUEN) "
	      cQuery +="WHERE TPF_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPG"
	      cQuery +="SET TPG_SEQREL = cONvert(integer,TPG_SEQUEN) "
	      cQuery +="WHERE TPG_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPH"
	      cQuery +="SET TPH_SEQREL = cONvert(integer,TPH_SEQUEN) "
	      cQuery +="WHERE TPH_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPI"
	      cQuery +="SET TPI_SEQREL = cONvert(integer,TPI_SEQUEN) "
	      cQuery +="WHERE TPI_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPM"
	      cQuery +="SET TPM_SEQREL = cONvert(integer,TPM_SEQUEN) "
	      cQuery +="WHERE TPM_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPP"
	      cQuery +="SET TPP_SEQREL = cONvert(integer,TPP_SEQUEN) "
	      cQuery +="WHERE TPP_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPV"
	      cQuery +="SET TPV_SEQREL = cONvert(integer,TPV_SEQUEN) "
	      cQuery +="WHERE TPV_SEQREL = '     ' "

	   ElseIf vETALI[XL] = "TPW"
	      cQuery +="SET TPW_SEQREL = cONvert(integer,TPW_SEQUEN) "
	      cQuery +=" WHERE TPW_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TPZ"
	      cQuery +="SET TPZ_SEQREL = cONvert(integer,TPZ_SEQUEN) "
	      cQuery +="WHERE TPZ_SEQREL = '   ' "

	   ElseIf vETALI[XL] = "TQ1"
	      cQuery +="SET TQ1_SEQREL = cONvert(integer,TQ1_SEQUEN) "
	      cQuery +="WHERE TQ1_SEQREL = '    ' "
	   EndIf
	EndIf

	If vETALI[XL] = "STL" .And. Upper(_cGetDB) == "INFORMIX"
	   NgReplic("STL","TL_SEQRELA","TL_SEQUENC",4)
	ElseIf vETALI[XL] = "STJ" .And. Upper(_cGetDB) == "INFORMIX"
	   NgReplic("STJ","TJ_SEQRELA","TJ_SEQUENC",5)
	ElseIf vETALI[XL] = "STT" .And. Upper(_cGetDB) == "INFORMIX"
		NgReplic("STT","TT_SEQRELA","TT_SEQUENC",2)
   ElseIf vETALI[XL] = "STS" .And. Upper(_cGetDB) == "INFORMIX"
		NgReplic("STS","TS_SEQRELA","TS_SEQUENC",3)
   Else
	   TcSqlExec(cQuery)
   EndIf

Next xl
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ NGOSABELIB | Autor ³Vitor Emanuel Batista³ Data ³15/07/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida se a O.S digitada esta Aberta e Liberada.           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGOSABELIB(cOrdem,lPerg)
Local lRet := .F.

dbSelectArea("STJ")
dbSetOrder(1)
If dbSeek(xFilial("STJ")+cOrdem)
	lRet := .F.
	//Se for movimentos internos permite O.S. Finalizada
	If IsInCallStack("MATA240") .Or. IsInCallStack("MATA241")
		If STJ->TJ_SITUACA <> "P" .And. STJ->TJ_SITUACA <> "C"
			lRet := .T.
		EndIf
	Else
		If STJ->TJ_SITUACA == "L" .And. STJ->TJ_TERMINO == "N"
			lRet := .T.
		EndIf
	EndIf
	If !lRet
		If lPerg
			MsgAlert(STR0180,STR0074)//"Ordem de Serviço informada não está Aberta e/ou Liberada" ##Atencao
		EndIf
		lRet := .F.
	EndIf
Else
	If lPerg
		Help(" ",1,"REGNOIS")
	EndIf
	lRet := .F.
EndIf

If __READVAR = 'M->D3_ORDEM'
	//Verifica se existe O.P. para a O.S.
	dbSelectArea("SC2")
	dbSetOrder(1)
	If !dbSeek(xFilial("SC2")+cOrdem+"OS001")
		Help(" ",1,"REGNOIS",,NGSX2NOME("SC2"),3,1)
		lRet := .F.
	EndIf
	//Verifica se a OP finalizada está fora do periodo do ultimo calculo do custo médio
	If lRet .And. !Empty(SC2->C2_DATRF)
		lRet := .F.
		If SuperGetMV("MV_NGMNTES",.F.,"N") == "S" .And. SuperGetMV("MV_NGMNTPC",.F.,"N") == "S"
			dDTULMES := SuperGetMV("MV_ULMES",.F.,STOD(""))
			If !Empty(dDTULMES) .And. SC2->C2_DATRF <= dDTULMES
				lRet := .F.
			Else
				lRet := .T.
			EndIf
		EndIf
		If !lRet
			Help(" ",1,"A100OPEND")
			lRet := .F.
		EndIf
	EndIf
EndIf

Return lRet

//------------------------------------------------------------------------------
/*/{Protheus.doc} NGVERUTFR
Verifica se o cliente esta utilizando frotas

@author	 Elisangela Costa
@since	 17/10/2015
@version P12

@return	 lRets, Define se o ambiente utilizará frotas ou superior ao release 12.1.033
/*/
//------------------------------------------------------------------------------
Function NGVERUTFR()

	Local lRetS := MNTFrotas()
	Local vRetS := {}

	If lRetS .And. GetRPORelease() < '12.1.033'

		vRetS := NGCADICBASE("T9_TIPMOD","A","ST9")
		lRetS := If(!vRetS[1],.F.,.T.)

		If lRetS
			vRetS := NGCADICBASE("T9_CATBEM","A","ST9")
			lRetS := If(!vRetS[1],.F.,.T.)
		EndIf

		If lRetS
			vRetS := NGCADICBASE("TC_TIPMOD","A","STC")
			lRetS := If(!vRetS[1],.F.,.T.)
		EndIf

		If lRetS
			vRetS := NGCADICBASE("TPF_TIPMOD","A","TPF")
			lRetS := If(!vRetS[1],.F.,.T.)
		EndIf

		If lRetS
			vRetS := NGCADICBASE("TC_SEQSUP","A","STC")
			If vRetS[1]
				lRetS := If(NGRETORDEM("STC","TC_FILIAL+TC_CODBEM+TC_TIPMOD+TC_COMPONE+TC_TIPOEST+TC_LOCALIZ+TC_SEQRELA",.T.) = 0,.F.,.T.)
			Else
				lRetS := If(NGRETORDEM("STC","TC_FILIAL+TC_CODBEM+TC_TIPMOD+TC_COMPONE+TC_TIPOEST+TC_LOCALIZ",.T.) = 0,.F.,.T.)
			EndIf
		EndIf

		If lRetS
			lRetS := If(NGRETORDEM("ST9","T9_CODBEM+T9_SITBEM",.T.) = 0,.F.,.T.)
		EndIf

	EndIf

Return lRetS

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGSENHAVER³ Autor ³ Inacio Luiz Kolling   ³ Data ³18/08/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³CONsistencia da senha para liberacao do sistema             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTUTIL                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSENHAVER(cVsenha,nTam)

If Len(Alltrim(cVsenha)) <> nTam
   MsgInfo(STR0167,STR0063)
   Return lRetOk
EndIf

Private cSenha := NGUNCRIPTO(cVsenha)
Private nHoras := 0 , cHoraAt := SubStr(Time(),1,5)
Private nMinAt := Val(SubStr(cHoraAt,4,2))

cDATA    := SubStr(cSenha,1,6)
cHora    := SubStr(cSenha,7,4)
nHoras   := Val(SubStr(cSenha,11,2))

cDIA     := SubStr(cData,1,2)
cMES     := SubStr(cData,3,2)
cANO     := SubStr(cData,5,2)
cHOR     := SubStr(cHora,1,2)
cMIN     := SubStr(cHora,3,2)

dDATAINI := Ctod(cDIA+"/"+cMES+"/"+cANO)
dDATAFIM := dDATAINI
cHORAINI := cHOR+":"+cMIN
nSomaHor := Val(cHor) + nHoras

If nSomaHor > 24
   dDATAFIM += 1

   cHORAFIM := StrZero(nSomaHor-24,2)
   nMINUTOS := If(nMinAt <> 0,60-Val(cMIN)+nMinAt,Val(cMIN))
   If nMINUTOS > 60
      cHORAFIM := StrZero(Val(cHORAFIM)+1,2)
      nMINUTOS := nMINUTOS - 60
   EndIf
   cHORAFIM := cHORAFIM+":"+StrZero(nMINUTOS,2)
Else
   cHORAFIM := StrZero(Val(cHor) + nHoras,2)+":"+cMIN
EndIf

If dDataBase >= dDATAINI .And. dDataBase <= dDATAFIM
   If dDATAINI = dDATAFIM
      If cHoraAt <= cHORAFIM
         lRetOk := .T.
      EndIf
   Else
      lRetOk := .T.
   EndIf
EndIf

If !lRetOk
   MsgInfo(STR0168,STR0063)
EndIf
Return lRetOk

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCRIPTO  ³ Autor ³ Inacio Luiz Kolling   ³ Data ³17/08/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Leitura de uma variavel (caracter a caracter)              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³ Manter uma relacao com a funca MGUNCRIPTO                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ INTERNO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCRIPTO(cValue,nLen)
local cRet := "", nAux,nInd

acValue := padr(cValue, nLen, " ")
For nInd := 1 To Len(cValue)
   nAux := asc(substr(cValue, nInd, 1)) + 3
   If nAux > 255
      nAux := 32
   EndIf
   cRet += NGIIN2HEX(nAux,2)
Next

Return cRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGIINEHEX ³ Autor ³ Inacio Luiz Kolling   ³ Data ³17/08/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Criptografica um caracter                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ NGCRIPTO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NGIIN2HEX(cValue,cSize)
	Local nValue := int(cValue), nResto := '', cResto := ''
	While nValue > 0
		nResto := nValue % 16
		Do Case
			Case nResto == 10
				cResto := 'A' + cResto
			Case nResto == 11
				cResto := 'B' + cResto
			Case nResto == 12
				cResto := 'C' + cResto
			Case nResto == 13
				cResto := 'D' + cResto
			Case nResto == 14
				cResto := 'E' + cResto
			Case nResto == 15
				cResto := 'F' + cResto
			Otherwise
				cResto := str(nResto, 1) + cResto
		EndCase
		nValue := int(nValue / 16)
	End
Return (padl(cResto,cSize,"0"))

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGUNCRIPTO³ Autor ³ Inacio Luiz Kolling   ³ Data ³18/08/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Descriptografa senha para liberacao do sistema              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³ Manter uma relacao com a funca NGCRIPTO                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NGSENHAVER                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGUNCRIPTO(acValue)
	Local cRet := "", nAux, nInd

	For nInd := 1 to len(acValue) step 2
	nAux := NGHEX2INT(substr(acValue, nInd, 2)) - 3 //DESLOCAMENTO
	If nAux < 32
		nAux := 255
	EndIf
	cRet += chr(nAux)
	Next

Return cRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGHEX2INT ³ Autor ³ Inacio Luiz Kolling   ³ Data ³18/08/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Subdivisao do caracter                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NGUNCRIPTO                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NGHEX2INT(AValue)
Local nInd, nPotencia := 0, nVal, nRet := 0, cDig

For nInd := len(AValue) to 1 step -1
	cDig := substr(AValue, nInd, 1)
    Do Case
		Case cDig == "A"
			nVal := 10
		Case cDig == "B"
			nVal := 11
		Case cDig == "C"
			nVal := 12
		Case cDig == "D"
			nVal := 13
		Case cDig == "E"
			nVal := 14
		Case cDig == "F"
			nVal := 15
		otherwise
			nVal := val(cDig)
    Endcase
	nRet += nVal * (16 ** nPotencia)
	nPotencia++
End

Return (nRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ NGCOQPR  | Autor ³Vitor Emanuel Batista  ³ Data ³18/08/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ CONsiste a quantidade de pecas de reposicao do bem no      ³±±
±±³          ³ retorno de insumos da OS.                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cOS - Ordem de Servico                        - obrigatorio ³±±
±±³          ³cProduto - Produto                            - obrigatorio ³±±
±±³          ³nQuant    - Quantidade                        - obrigatorio ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCOQPR(cProduto,nQuant,cOS)

	Local lCOQPR  := SuperGetMv("MV_NGCOQPR",.F.,"N") == "S"
	Local nPosTRT := 0

	If (ValType(cProduto) <> "C")
		If Type("M->D3_COD") == "C"
			cProduto  := M->D3_COD
		Else
			nPosProd  := aSCAN(aHEADER, {|x| AllTrim(Upper(x[2])) == "D3_COD" })
			cProduto  := If(nPosProd > 0,aCols[n][nPosProd]," ")
		EndIf
	EndIf

	If (ValType(nQuant) <> "N")
		If Type("M->D3_QUANT") == "N"
			nQuant 	  := M->D3_QUANT
		Else
			nPosQuant := aSCAN(aHEADER, {|x| AllTrim(Upper(x[2])) == "D3_QUANT" })
			nQuant    := If(nPosQuant > 0,aCols[n][nPosQuant],0)
		EndIf
	EndIf
	If (ValType(cOS) <> "C")
		If Type("M->D3_ORDEM") == "C"
			cOS		  := M->D3_ORDEM
		Else
			nPosOS    := aSCAN(aHEADER, {|x| AllTrim(Upper(x[2])) == "D3_ORDEM" })
			cOS       := If(nPosOS > 0,aCols[n][nPosOS]," ")
		EndIf
	EndIf

	If lCOQPR
		dbSelectArea("STJ")
		dbSetOrder(1)
		If dbSeek(xFilial("STJ")+cOS)
			dbSelectArea("TPY")
			dbSetOrder(1)
			If dbSeek(xFilial("TPY")+STJ->TJ_CODBEM+cProduto)
				If TPY->TPY_QUANTI < nQuant
					MsgAlert(STR0184+CHR(13)+;//"A quantidade do produto informado é maior que a quantidade"
					   		 STR0185+STJ->TJ_CODBEM+CHR(13)+CHR(13)+; //"de peças de reposição para o bem "
							 STR0186+Str(TPY->TPY_QUANTI)+CHR(13)+;//"Quantidade Máxima:...."
							 STR0187+Str(nQuant),STR0041)  //"Quantidade Informada:" ## "Atenção"
					Return .F.
				EndIf
			EndIf
		EndIf
	EndIf

	//Preenche o campo D3_TRT
	If !Empty(cProduto) .And. !Empty(cOS) .And. Type("aHEADER") <> "U"

		nPosTRT := aSCAN(aHEADER, {|x| AllTrim(Upper(x[2])) == "D3_TRT" })
		nPosLocal := aSCAN(aHEADER, {|x| AllTrim(Upper(x[2])) == "D3_LOCAL" })

		If nPosTRT > 0 .And. nPosLocal > 0

			dbSelectArea("SD4")
			dbSetOrder(2) //D4_FILIAL+D4_OP+D4_COD+D4_LOCAL
			If dbSeek(xFilial("SD4") + cOS + "OS001  " + cProduto + aCols[n][nPosLocal])
				aCols[n][nPosTRT] := SD4->D4_TRT
			EndIf
		EndIf

	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ NGDUPST9 | Autor ³Vitor Emanuel Batista  ³ Data ³29/09/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se podera duplicar codigo de Bem ou Tag em filial ³±±
±±³          ³ ou empresas diferentes, quando o ST9 for exclusivo         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGDUPST9()

Local aAreaSM0  := SM0->(GetArea())
Local aAreaST9  := ST9->(GetArea())
Local cDPST9    := AllTrim(SuperGetMv("MV_NGDPST9",.F.,"0"))
Local lTag      := NGCADICBASE("T9_TAG","D","TAG",.F.)
Local vIndL     := {"A","B","C","D","E","F","G","H","I"}
Local nInd      := 0
Local cEmpresa  := SM0->M0_CODIGO
Local cModo     := "E"
Local lEmpresa  := .F.
Local lErro     := .F.
Local nTamTable := Len(cArqTab)
Local nRecno    := ST9->(Recno())
Local cSMCOD    := If(FindFunction("FWGrpCompany"),FWGrpCompany(),SM0->M0_CODIGO)
Local cSMFIL    := If(FindFunction("FWCodFil"),FWCodFil(),SM0->M0_CODFIL)

//MV_NGDPST9 :
//0 Nao verifica
//1 Por Empresa
//2 Por Filial
//3 Por Empresa ou Filial
If cDPST9 <> '0'

	//Pega a ordem do indice TAG
	If lTag
		dbSelectArea("SIX")
		dbSetOrder(1)
		If dbSeek('ST9')
		   While !EoF() .And. SIX->INDICE = "ST9"
		      If Alltrim(SIX->CHAVE) = "T9_FILIAL+T9_TAG"
		         If SIX->ORDEM <= "9"
		            nInd := Val(SIX->ORDEM)
		         Else
		            nIndL := aScan(vIndL,{|x| x = SIX->ORDEM})
		            nInd  := 9+nIndL
		         EndIf
		         Exit
		      EndIf
		      dbSkip()
		   End
		EndIf
	EndIf

	If FWModeAccess("ST9",3) == cModo
		dbSelectArea("SM0")
		dbGoTop()
		While !EoF()
			Store .F. to lEmpresa, lErro
			cSMFIL := If(FindFunction("FWCodFil"),FWCodFil(),SM0->M0_CODFIL)
			cSMCOD := If(FindFunction("FWGrpCompany"),FWGrpCompany(),SM0->M0_CODIGO)
			If (cSMCOD <> cEmpresa)
				If (cDPST9 $ "1/3")
					NGEMPOPEN("ST9","ST9",1,cSMCOD,nTamTable,@cModo)
					lEmpresa := .T.
				Else
					dbSelectArea("SM0")
					dbSkip()
					Loop
				EndIf
			Else
				If  (cDPST9 == "1")
					dbSelectArea("SM0")
					dbSkip()
					Loop
				EndIf
			EndIf

			If (nInd > 0)
				dbSelectArea("ST9")
				dbSetOrder(nInd)
				If !Empty(M->T9_TAG)
					If dbSeek(cSMFIL+M->T9_TAG)
						Help(" ",1,"JAGRAVADO")
						lErro := .T.
					EndIf
				EndIf
			EndIf

			dbSelectArea("ST9")
			dbSetOrder(1)
			If !Empty(M->T9_CODBEM)
				If ALTERA
					If dbSeek(cSMFIL+M->T9_CODBEM)
						While !EoF() .And. cSMFIL+M->T9_CODBEM == ST9->T9_FILIAL + ST9->T9_CODBEM

							If nRecno <> ST9->(Recno()) .And. ((cDPST9 $ '2/3' .And. xFilial("ST9") == ST9->T9_FILIAL) .Or. (cDPST9 == '3' .And. cSMCOD == cEmpresa))
								Help(" ",1,"JAGRAVADO")
								lErro := .T.
							EndIf
							dbSelectArea("ST9")
							dbSkip()
						End
					EndIf
				Else
					If dbSeek(cSMFIL+M->T9_CODBEM)
						If  ((cDPST9 $ '2/3' .And. xFilial("ST9") == ST9->T9_FILIAL) .Or. (cDPST9 == '3' .And. cSMCOD == cEmpresa))
							Help(" ",1,"JAGRAVADO")
							lErro := .T.
						EndIf
					EndIf
				EndIf
			EndIf


			If lErro
				If lEmpresa
					NGEMPOPEN("ST9","ST9",1,cEmpresa,nTamTable,@cModo)
				EndIf
				RestArea(aAreaSM0)
				RestArea(aAreaST9)
				Return .F.
			EndIf


			If lEmpresa
				NGEMPOPEN("ST9","ST9",1,cEmpresa,nTamTable,@cModo)
			EndIf

			dbSelectArea("SM0")
			dbSkip()
		End
	EndIf
EndIf

RestArea(aAreaSM0)
RestArea(aAreaST9)
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NGCLEARSTL| Autor ³Vitor Emanuel Batista  ³ Data ³03/11/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Limpa campos no STL                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCLEARSTL()

	Local lPctHrExt := NGCADICBASE('TL_PCTHREX','A','STL',.F.)
	Local lPossuiAC := .F. //lPossui aCols
	Local aINS      := {}
	Local yk        := n
	Local y         := n
	Local x         := 0
	Local yx        := 0
	Local nCODIG    := 0
	Local nTIPOI    := 0
	Local nUSACA    := 0
	Local nDESTI    := 0
	Local nLOCAL    := 0
	Local nLOTEC    := 0
	Local nNUMLO    := 0
	Local nLOCALI   := 0
	Local nNUMSE    := 0
	Local nGARAN    := 0
	Local nHREXT    := 0
	Local nDTVAL    := 0
	Local nQTREC    := 0
	Local nNOCOD    := 0
	Local nPERM     := 0
	Local nMOEDA    := 0
	Local cUsacale  := ""

	If Type ("aHEADER") == "A"

		nCODIG := GDFIELDPOS("TL_CODIGO" )
		nUSACA := GDFIELDPOS("TL_USACALE")
		nDESTI := GDFIELDPOS("TL_DESTINO") //Destino
		nLOCAL := GDFIELDPOS("TL_LOCAL"  ) //Almoxarifado
		nLOTEC := GDFIELDPOS("TL_LOTECTL") //Lote
		nNUMLO := GDFIELDPOS("TL_NUMLOTE") //SubLote
		nLOCALI:= GDFIELDPOS("TL_LOCALIZ") //Localizacao
		nNUMSE := GDFIELDPOS("TL_NUMSERI") //Numero de Serie
		nGARAN := GDFIELDPOS("TL_GARANTI") //Garantia
		nHREXT := If(lPctHrExt,GDFIELDPOS("TL_PCTHREX"),GDFIELDPOS("TL_HREXTRA"))   //Hora Extra
		nDTVAL := GDFIELDPOS("TL_DTVALID") //Data Validade
		nQTREC := GDFIELDPOS("TL_QUANREC") //Data Validade
		nNOCOD := GDFIELDPOS("TL_NOMCODI")
		nPERM  := GDFIELDPOS("TL_PERMDOE")
		nTIPOI := GDFIELDPOS("TL_TIPOREG")
		nMOEDA := GDFIELDPOS("TL_MOEDA")
		nDTFIM := GDFieldPos( 'TL_DTFIM' )
		nHOFIM := GDFieldPos( 'TL_HOFIM' )
		nQUANT := GDFieldPos( 'TL_QUANTID' )

	EndIf

	aAdd(aINS,{nCODIG ,"M->TL_CODIGO"  , Space(Len(STL->TL_CODIGO))  })
	aAdd(aINS,{nUSACA ,"M->TL_USACALE" , "N"})
	aAdd(aINS,{nDESTI ,"M->TL_DESTINO" , Space(Len(STL->TL_DESTINO)) })
	aAdd(aINS,{nLOCAL ,"M->TL_LOCAL"   , Space(Len(STL->TL_LOCAL))   })
	aAdd(aINS,{nLOTEC ,"M->TL_LOTECTL" , Space(Len(STL->TL_LOTECTL)) })
	aAdd(aINS,{nNUMLO ,"M->TL_NUMLOTE" , Space(Len(STL->TL_NUMLOTE)) })
	aAdd(aINS,{nLOCALI,"M->TL_LOCALIZ" , Space(Len(STL->TL_LOCALIZ)) })
	aAdd(aINS,{nNUMSE ,"M->TL_NUMSERI" , Space(Len(STL->TL_NUMSERI)) })
	aAdd(aINS,{nGARAN ,"M->TL_GARANTI" , Criavar( 'TL_GARANTI' ) })
	aAdd(aINS,{nHREXT ,If(lPctHrExt,"M->TL_PCTHREX","M->TL_HREXTRA") , If(lPctHrExt,0,"000.00") })
	aAdd(aINS,{nDTVAL ,"M->TL_DTVALID" , CtoD("  /  /  ") })
	aAdd(aINS,{nQTREC ,"M->TL_QUANREC" , 0 })
	aAdd(aINS,{nNOCOD ,"M->TL_NOMCODI" , "" })
	aAdd( aINS, { nDTFIM, 'M->TL_DTFIM'  , CToD( '' ) } )
	aAdd( aINS, { nHOFIM, 'M->TL_HOFIM'  , Space( 5 ) } )
	aAdd( aINS, { nQUANT, 'M->TL_QUANTID', 0 } )

	If nPERM > 0 .And. NGFUNCRPO("NGMDOEXECU",.F.) .And.  aCOLS[n,nTIPOI] <> "M"
		Aadd(aINS,{nPERM,"M->TL_PERMDOE",0.00})
	EndIf

	If nMoeda > 0
		Aadd(aINS,{nMoeda,"M->TL_MOEDA","1"})
	EndIf

	If ValType(cPrograma) == "C"
		If cPrograma == "MNTA401"
			y  := 1
			yk := Len(aCols)
		EndIf
	EndIf

	lPossuiAC := Type("aCOLS") == "A"
	For x := 1 to Len(aINS)
		If aINS[x][1] > 0
			If lPossuiAC
				For yx := y to yk
					aCOLS[yx][ aINS[x][1] ] := aINS[x][3]
				Next
			EndIf
		Else
			&(aINS[x][2]) := aINS[x][3]
		EndIf
	Next

	If IsInCallStack("MNTA435")

		If M->TL_TIPOREG == "M"
			cUsacale := Alltrim( &(Posicione("SX3",2,"TL_USACALE","X3_RELACAO")) )
			If !Empty( cUsacale )
				aCOLS[n,nUSACA] := cUsacale // busca inic. padrão do campo usa calendário quando é MDO
				M->TL_USACALE   := cUsacale
			EndIf
		EndIf

		If M->TL_TIPOREG $("P\M")
			If STJ->TJ_SERVICO == "HISTOR"
				If cUIntHis == "N" .And. cUsaInt3 == 'S'
					lCusto := .T.
				Else
					lCusto := .F.
				EndIf
			ElseIf cUsaInt3 == 'S'
				lCusto := .F.
			EndIf
		ELseIf M->TL_TIPOREG == "T" .And. AllTrim(GetNewPar("MV_NGINTER","N")) == "L"
			lCusto := .T.
		EndIf

	EndIf

	lRefresh := .T.

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡Æo    ³ NGVDTINS ³ Autor ³ Vitor Emanuel Batista ³ Data ³29/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica data e hora para nao permitir mais de um insumo no³±±
±±³          ³ intervalo de tempo                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGVDTINS(cCodigo,dINICI,cHOINICI,dFIM,cHOFIM,cTIPOREG,cOrdem,cPlano)
Local lPROPLSTL := .F.
Local nQUATSH4   := 0
Local aRETVALINT := {}, nQUANTFERR := 0

If cTIPOREG == "M"
	aRETVALINT := NGVALDATIN(cCodigo,cOrdem,cPlano,dINICI,cHOINICI,dFIM,cHOFIM,"M", ,"STL")
	If !aRETVALINT[1]
		lPROPLSTL := .T.
	EndIf

	If !lPROPLSTL
		aRETVALINT := NGVALDATIN(cCodigo,cOrdem,cPlano,dINICI,cHOINICI,dFIM,cHOFIM,"M", ,"STT")
		If !aRETVALINT[1]
			lPROPLSTL := .T.
		EndIf
	EndIf

ElseIf cTIPOREG == "F"

	dbSelectArea("SH4")
	dbSeek(xFilial("SH4")+SubStr(cCodigo,1,6))
	nQUATSH4 := SH4->H4_QUANT

	//STL
	aRETVALINT := NGVALDATIN(cCodigo,cOrdem,cPlano,dINICI,cHOINICI,dFIM,cHOFIM,"F", ,"STL")
	nQUANTFERR := aRETVALINT[2]
	nRESTQUA   := nQUATSH4 - nQUANTFERR

	If nRESTQUA >= 0
		//STT
		aRETVALINT := NGVALDATIN(cCodigo,cOrdem,cPlano,dINICI,cHOINICI,dFIM,cHOFIM,"F", ,"STT")
		nQUANTFERR += aRETVALINT[2]
		nRESTQUA   := nQUATSH4 - nQUANTFERR
	EndIf

	If nRESTQUA <= 0 .And. nQUANTFERR > 0
		MsgInfo(STR0197 + CHR(13)+CHR(13); //"Não há dispONibilidade da ferramenta no intervalo:"
		+ STR0199 + ".....: " + cHOINICI + CHR(13); //"Data Inicio"
		+ STR0198 + ".....: " + DtoC(dINICI) + CHR(13); //"Hora Inicio"
		+ STR0200 + "........: " + DtoC(dFIM) + CHR(13); //"Data Fim"
		+ STR0201 + "........: " + cHOFIM,STR0074) 	//"Hora Fim"
		lPROPLSTL := .T.
	EndIf
ElseIf cTIPOREG == "T"
	aRETVALINT := NGVALDATIN(cCodigo,cOrdem,cPlano,dINICI,cHOINICI,dFIM,cHOFIM,"T", ,"STL")
	If !aRETVALINT[1]
		lPROPLSTL := .T.
	EndIf

	If !lPROPLSTL
		aRETVALINT := NGVALDATIN(cCodigo,cOrdem,cPlano,dINICI,cHOINICI,dFIM,cHOFIM,"T", ,"STT")
		If !aRETVALINT[1]
			lPROPLSTL := .T.
		EndIf
	EndIf
EndIf

Return !lPROPLSTL

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGSXBST5   ³ Autor ³Evaldo Cevinscki Jr.   ³ Data ³01/10/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Troca filtro da cONsulta ST5 cONforme programa que esta sendo³±±
±±³          ³usado.                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTUTIL                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSXBST5()
Local cRetST5

If FunName() == "MNTC790"
	cRetST5 := "@#'"+STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA+"'@#"
Else
	cRetST5 := "@#'"+STF->TF_CODBEM+STF->TF_SERVICO+STF->TF_SEQRELA+"'@#"
EndIf

Return cRetST5

//---------------------------------------------------------------------
/*/{Protheus.doc} MntMovEst
Realiza movimentação do estoque e
integracao com mensagem unica (quando é baixa de estoque)

@param cCod         , Caractere, DE0 (devolucao), RE0 (requisicao), PR0 (Produção), etc.
@param [cLocal]     , Carctere , Local de estoque do produto
@param cProd        , Caractere, Codigo do produto
@param nQuant       , Numérico , Quantidade para baixa
@param dData        , Data     , Data de emissão
@param cDocEst      , Caractere, Numero do documento
@param [cFilMov]    , Caractere, Filial para movimentacao na SD3
@param [cCusto]     , Caractere, Centro de custo
@param [lTemEstorno], Lógico   , Indica se e' um estorno de outra movimentacao (cNumSeq)
@param [cNumeroSeq] , Caractere, NUMSEQ da movimentacao a estornar
@param [cOrdem]     , Caractere, Numero da Ordem de Serviço
@param [cBemMov]    , Caractere, Código do Bem
@param [cFilBemMov] , Caractere, Filial do Bem
@param [cOP]        , Caracter , Numero da Ordem de Produção
@param [cItemCTA]   , Caractere, Item da Conta contábil
@param [aRastro]    , Array    , Array com os campos de rastreabilidade
@param [cCodLocMov] , Caractere, Local de movimentação do estoque
@param [lRetArray]  , Lógico   , se retorno da função é array
@param [nCustoMov]  , Numerico , custo da movimentação
@author Felipe Nathan Welter
@since 04/04/2013
@obs o tipo de retorno vai depender do parâmetro lRetArray
para retorno caracter: sucesso:retorna código NUMSEQ), Problema: retorna vazio
para retorno array: [1] se houve sucesso, [2] código NUMSEQ ou descrição do erro
@return caracter ou array

/*/
//---------------------------------------------------------------------
Function MntMovEst( cCod, cLocal, cProd, nQuant, dData, cDocEst, cFilMov, cCusto, lTemEstorno,;
	cNumeroSeq, cOrdem, cBemMov, cFilBemMov, cOP, cItemCTA, aRastro, cCodLocMov, lRetArray, nCustoMov)

	Local aRetArray := { .T., "" }
	Local aAutoItens := {}
	Local lSbf := .F.
	Local cRet := Space(6)
	Local nOpc := 0
	Local _FilialAnt := cFilAnt //Salva filial corrente
	Local nIndex := IIf(IsInCallStack("MNTA600") .Or. IsInCallStack("MNTA656"), 2, 3)

	Local nTanSBF   := TamSX3("BF_LOCALIZ")[1]
	Local cLocalSbf := ""
	Local cCodTM    := "" // Código numérico do campo D3_TM

	Local cLoteCtl := CriaVar('D3_LOTECTL')
	Local cNumLote := CriaVar('D3_NUMLOTE')
	Local cLocaliz := CriaVar('D3_LOCALIZ')
	Local cNumSeri := CriaVar('D3_NUMSERI')
	Local cCodCta  := ""

	Default nCustoMov   := 0
	Default lTemEstorno := .F.
	Default cNumeroSeq  := " "
	Default cLocal      := ''
	Default aRastro     := {}
	Default cBemMov     := ""
	Default cFilBemMov  := ""
	Default cCodLocMov  := ""
	Default lRetArray   := .F.

	Private lMsErroAuto := .F. //Indica se houve erro ao executar rotina automática
	Private lMSHelpAuto := .T. // para nao mostrar os erro na tela

	cLocal    := IIf( Empty( cLocal ), Padr( GetMv("MV_NGLOCPA"), TamSx3("NNR_CODIGO")[1] ), cLocal )
	cLocalSbf := If(!Empty(cCodLocMov),PADR(Alltrim(cCodLocMov),nTanSBF),"")

	// Validacoes
	If lTemEstorno .And. !Empty(cNumeroSeq)
		dbSelectArea("SD3")
		dbSetOrder(04)
		If dbSeek(xFilial("SD3")+cNumeroSeq)
			If SD3->D3_ESTORNO == "S"
				aRetArray[1] := .F.
				aRetArray[2] := STR1452 // 'O estorno da movimentação já foi realizado.'
			EndIf
		EndIf
	EndIf

	If aRetArray[1] .And. nQuant <= 0
		aRetArray[1] := .F.
		aRetArray[2] := STR1453// 'A quantidade para movimentação é inválida.'
	EndIf

	// Gera movimentacao
	If aRetArray[1]

		//garante que __lSX8 seja .F.
		__lSx8 := .F.

		If ValType( cFilMov ) == 'C' .And. !Empty( cFilMov ) .And. Len( cFilMov ) == Len( cFilAnt )

			// Troca a filial para a que será gerada a movimentação
			cFilAnt := cFilMov

		EndIf

		//identifica o tipo de operacao (baixa ou estorno)
		If lTemEstorno .And. !Empty(cNumeroSeq)
			nOpc := 5  //estorno
		Else

			nOpc := 3  // Baixa

			/*-------------------------------------------------------------------------------------+
			| Busca novo número para o documento após a alteração do cFilAnt, para que corresponda |
			| a filial que será realizado o movimento.                                             |
			+-------------------------------------------------------------------------------------*/
			cDocEst := A261RetINV( NextNumero( 'SD3', 2, 'D3_DOC', .T. ) )
			
		EndIf

		/*--------------------------------------------------------------+
		| Busca o TM conforme a parÂmetrização e o processo em excução. |
		+--------------------------------------------------------------*/
		cCodTM := MNTMOVTM( cCod, ( nOpc == 5 ) )

		//posiciONa no cadastro do produto
		dbSelectArea("SB1")
		dbSetOrder(01)
		dbSeek(xFilial('SB1')+cProd)

		If Len(aRastro) <> 0

			cLocal   := aRastro[1]
			cLoteCtl := aRastro[3]
			cNumLote := aRastro[2]
			cLocaliz := aRastro[5]
			cNumSeri := aRastro[4]

		Else // Carrega campos da SBF (saldos por endereco)

			dbSelectArea("SBF")
			If Empty(cLocalSbf)
				dbSetOrder(02)
				lSbf := dbSeek(xFilial("SBF") + cProd + cLocal)
			Else
				dbSetOrder(1)
				lSbf := dbSeek(xFilial("SBF") + cLocal + cLocalSbf  + cProd)
			EndIf

			If lSbf
				cLoteCtl := If(Empty('BF_LOTECTL'), '', SBF->BF_LOTECTL)
				cNumLote := If(Empty('BF_NUMLOTE'), '', SBF->BF_NUMLOTE)
				cLocaliz := If(Empty('BF_LOCALIZ'), '', SBF->BF_LOCALIZ)
				cNumSeri := If(Empty('BF_NUMSERI'), '', SBF->BF_NUMSERI)
			EndIf

		EndIf

		//--------------------------------------------------
		// busca dados do próprio item
		//--------------------------------------------------
		If nOpc == 5 .And. !Empty( cNumeroSeq ) // estorno
			
			dbSelectArea( 'SD3' )
			dbSetOrder( 4 ) // D3_FILIAL + D3_NUMSEQ
			If dbSeek( xFilial( 'SD3' ) + cNumeroSeq )
				
				cLocaliz := SD3->D3_LOCALIZ
				cNumSeri := SD3->D3_NUMSERI
				cDocEst  := SD3->D3_DOC

			EndIf

		EndIf

		aAutoItens := {{"D3_TM"     , cCodTM                                        , '.T.'},;
					   {"D3_COD"    , cProd                                         , Nil},;
					   {"D3_UM"     , SB1->B1_UM                                    , Nil},;
					   {"D3_QUANT"  , nQuant                                        , Nil},;
					   {"D3_CF"     , cCod                                          , Nil},;
					   {"D3_CONTA"  , SB1->B1_CONTA                                 , Nil},;
					   {"D3_LOCAL"  , If(Empty(cLocal), SB1->B1_LOCPAD, cLocal)     , Nil},;
					   {"D3_EMISSAO", dData                                         , Nil},;
					   {"D3_SEGUM"  , SB1->B1_SEGUM,                                , Nil},;
					   {"D3_QTSEGUM", CONvUm(SB1->B1_COD,0/*qtdOco*/,0,2)           , Nil},;
					   {"D3_GRUPO"  , SB1->B1_GRUPO                                 , Nil},;
					   {"D3_TIPO"   , SB1->B1_TIPO                                  , Nil},;
					   {"D3_NUMSERI", cNumSeri                                      , Nil},;
					   {"D3_CHAVE"  , SubStr(cCod,2,1)+If(cCod $ 'RE4|DE4','9','0') , Nil},;
					   {"D3_DOC"    , cDocEst                                       , Nil},;
					   {"D3_USUARIO", cUserName                                     , Nil},;
					   {"D3_LOCALIZ", cLocaliz                                      , Nil},;
					   {"D3_NUMSEQ" , cNumeroSeq                                    , Nil},;
					   {"D3_ESTORNO", If(lTemEstorno ,"S"," ")                      , Nil}}

		If cCusto != Nil
			aAdd(aAutoItens, {"D3_CC", cCusto, Nil})
		EndIf

		If nCustoMov > 0
			aAdd(aAutoItens,{"D3_CUSTO1", nCustoMov, Nil})
		EndIf

		// Código da Ordem.
		If cOrdem != Nil
			aAdd(aAutoItens, {"D3_ORDEM", cOrdem, Nil})
		EndIf

		// Ordem de Produção.
		If cOP != Nil
			aAdd(aAutoItens, {"D3_OP", cOP, Nil})
		EndIf

		//------------------------------------------------
		//Carrega campo D3_ITEMCTA quando for passado bem
		//------------------------------------------------
		If !Empty( cBemMov )
			cCodCta := NGSEEK( "ST9", cBemMov, 1, "T9_ITEMCTA", xFilial( "ST9", cFilBemMov ) )
			If !Empty( cCodCta ) .And. NGIFdbSeek( "CTD", cCodCta, 1 )
				aAdd( aAutoItens, { "D3_ITEMCTA", cCodCta, Nil } )
			EndIf
		Else
			If cItemCTA != Nil
				aAdd(aAutoItens, {"D3_ITEMCTA", cItemCTA, Nil})
			EndIf
		EndIf

		aAdd(aAutoItens, {"INDEX", nIndex, Nil})

		//+---------------------------------------------------------------+
        //| Ponto de Entrada para inclusão e alteração de campos passados |
        //| na geração de Movimentos Internos.                            |
        //+---------------------------------------------------------------+
		If ExistBlock("NGMOVSD3")
			aAutoItens := ExecBlock("NGMOVSD3", .F., .F., aAutoItens)
		EndIf

		dbSelectArea("SB2")
		dbSetOrder(01)
		If !dbSeek(xFilial("SB2")+cProd+If(Empty(cLocal), SB1->B1_LOCPAD, cLocal))
			CriaSB2(cProd, If(Empty(cLocal), SB1->B1_LOCPAD, cLocal))
		EndIf

		lMsErroAuto := .F.

		// MSExecAuto (SD3)
		If Substr(cCod,1,2)=='PR' // Produção.
			MsExecAuto({|x,y| MATA250(x,y)},aAutoItens,nOpc) // Produção Simples.
		Else
			MSExecAuto({|x,y| MATA240(x,y)},aAutoItens,nOpc)
		EndIf

		If lMsErroAuto
			aRetArray[1] := .F.

			If lRetArray
				aRetArray[2] := MostraErro( GetSrvProfString("Startpath","") , ) // Não apresenta tela de erro
			ElseIf !IsBlind()
				MostraErro()// Apresenta MostraErro() em tela somente quando há interface com o usuário
			EndIf

		Else

			aRetArray := { .T., SD3->D3_NUMSEQ }
			//-------------------------------------
			//INTEGRACAO POR MENSAGEM UNICA
			//-------------------------------------
			If AllTrim(GetNewPar("MV_NGINTER","N")) == "M" // Mensagem Unica

				If AllTrim(SD3->D3_ESTORNO) == "S"
					NGMUCanReq(SD3->( RecNo() ), "SD3")
				Else

					If !NGMUStoTuO( SD3->( RecNo() ), 'SD3' )

						aRetArray := { .F., STR1454 } // Houve um problema ao realizar integração por mensagem única.

					Else

						If nOpc == 3 .And. Type( 'aRBackRM' ) == 'A'
					
							/*------------------------------------------------------------------+
							| Salva registros gravados durante a transação para rollback no RM. |
							+------------------------------------------------------------------*/
							aAdd( aRBackRM,;
								{ 	SD3->D3_FILIAL  ,;
									SD3->D3_DOC     ,;
									SD3->D3_NUMSEQ  ,;
									SD3->D3_CHAVE   ,;
									SD3->D3_COD     ,;
									SD3->D3_CF      ,;
									SD3->D3_ORDEM   ,;
									SD3->D3_EMISSAO ,;
									SD3->D3_UM      ,;
									SD3->D3_CC      ,;
									SD3->D3_CUSTO1  ,;
									SD3->D3_QUANT   ,;
									SD3->D3_LOCAL  } )

						EndIf

					EndIf

				EndIf

			EndIf

		EndIf

	EndIf

	cFilAnt := _FilialAnt // Retorna a filial salva

	//---------------------------------------
	//Ajuste para retorno tipo caracter
	//Sucesso : retorna código NUMSEQ
	//Problema: retorna vazio
	//---------------------------------------
	If !lRetArray
		If aRetArray[1]
			cRet := aRetArray[2]
		Else
			cRet := ''
		EndIf
	EndIf

Return IIf( lRetArray, aRetArray, cRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCHKIRREG ³ Autor ³Evaldo Cevinscki Jr.   ³ Data ³23/02/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Checa se o parametro de cONtrole de irregularidade esta      ³±±
±±³          ³ligado.                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Rotinas que usam tabelas TP7 e TP8.                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
 Function NGCHKIRREG(nOpcWor)

	Local lChkPar   := SuperGetMv("MV_NGTNDFL",.F.,"N") == "N"
	Local lChkWor   := SuperGetMv("MV_NGTNDFL",.F.,"N") == "S"

	Default nOpcWor := 1

	If lChkPar
		MsgAlert(STR0262,STR0101)//"Para utilização dessa rotina o parâmetro de controle de Irregularidade(MV_NGTNDFL) deverá estar ligado."
		Return .F.
	Else
		If nOpcWor = 2 .And. !lChkWor
			//Após a alteração do funcionamento do parametro MV_NGTNDFL, os programas que verificam se o parametro está ligado, consideram que
			//P(parcial) também é ligado, com exceção do programa de WorkFlow. Que só considera quando for S. Para isso foi criado um parametro
			//não obrigatorio, que quando existir irá consistir também se o parametro é S.
			MsgAlert(STR0262,STR0101)//"Para utilização dessa rotina o parâmetro de controle de Irregularidade(MV_NGTNDFL) deverá estar ligado."
			Return .F.
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MNTFAST  ³ Autor ³ Evaldo Cevinscki Jr.  ³ Data ³ 26/02/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Inclusao de dados genericos basicos para utilizacao rapida ³±±
±±³          ³ do Manutencao atraves dos bens do Ativo Fixo.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Objetivo  ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTFAST()
Local i

//MONta Array com Calendario
aCAL	:= {"24H","24 HORAS"} //"24 HORAS"
Private c780Cod := aCAL[1], c780Desc := aCAL[2]

//MONta Array com Familia
aFAM	:= {"GENERI",STR0264,"1","S"} //"FAMILIA GENERICA"

//MONta Array com Especialidades
aESP	:= {{"E01",STR0265},; //"ELETRICISTA"
			 {"ELE",STR0266},; //"ELETRONICO"
			 {"H01",STR0267},; //"HIDRAULICO"
			 {"M01",STR0268}}  //"MECANICO"

//MONta Array com Tipos de Manutancao
aTIP	:= {{"C00",STR0269,"C"},; //"CORRETIVA GENERICA"
			 {"P00",STR0270,"P"}}  //"PREVENTIVA GENERICA"

//MONta Array com Areas Manutencao
aARE	:= {{"ELETRI",STR0271},; //"ELETRICA"
			 {"EXTERN",STR0272},; //"SERVICOS EXTERNOS"
			 {"GENERI",STR0273},; //"GENERICA"
			 {"HIDRAU",STR0274},; //"HIDRAULICA"
			 {"MECANI",STR0275},; //"MECANICA"
			 {"MECARC",STR0276},; //"MECANICA DE AR CONDICIONADO"
			 {"MECMIC",STR0277},; //"MECANICA DE MICROCOMPUTADOR"
			 {"MECPRO",STR0278},; //"MECANICA DE MAQUINAS PRODUCAO"
			 {"MICELE",STR0279}}  //"ELETRICA/ELETRONICA DE MICROCOMPUTADOR"

//MONta Array com Servicos
aSER	:= {{"CORELE",STR0280,"ELETRI","C00"},; //"CORRETIVO ELETRICO"
			 {"CORGEN",STR0269,"GENERI","C00"},; //"CORRETIVA GENERICA"
			 {"CORHID",STR0281,"HIDRAU","C00"},; //"CORRETIVO HIDRAULICO"
			 {"CORMEC",STR0282,"MECANI","C00"},; //"CORRETIVO MECANICO"
			 {"PREELE",STR0283,"GENERI","P00"},; //"PREVENTIVO ELETRICO"
			 {"PREGEN",STR0284,"GENERI","P00"},; //"PREVENTIVO GENERICO"
			 {"PREHID",STR0285,"HIDRAU","P00"},; //"PREVENTIVO HIDRAULICO"
			 {"PREMEC",STR0286,"MECANI","P00"}}  //"PREVENTIVO MECANICO"

//MONta Array com Centro de Custo
aCC	:= {"CCGENERI",STR0287,"2","2"}  //"CC GENERICO - BENS ATIVO FIXO"

//Grava Calendario
If !NGIFdbSeek("SH7",aCAL[1],1)
	a780Calend := {"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",;
					   "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",;
					   "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",;
					   "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",;
					   "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",;
					   "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",;
					   "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"}
	A780Grava(3,a780Calend)
EndIf

//Grava familia
If !NGIFdbSeek("ST6",aFAM[1],1)
	RecLock("ST6",.T.)
	ST6->T6_FILIAL := xFilial("ST6")
	ST6->T6_CODFAMI:= aFAM[1]
	ST6->T6_NOME   := aFAM[2]
	ST6->T6_PERLOCA:= aFAM[3]
	ST6->T6_MOVIBEM:= aFAM[4]
	ST6->(MsUnLock())
EndIf

//Grava especialidades
For i:= 1 to Len(aESP)
	If !NGIFdbSeek("ST0",aESP[i][1],1)
		RecLock("ST0",.T.)
		ST0->T0_FILIAL := xFilial("ST0")
		ST0->T0_ESPECIA:= aESP[i][1]
		ST0->T0_NOME	:= aESP[i][2]
	   ST0->(MsUnLock())
   EndIf
Next i

//Grava tipos
For i:= 1 to Len(aTIP)
	If !NGIFdbSeek("STE",aTIP[i][1],1)
		RecLock("STE",.T.)
		STE->TE_FILIAL := xFilial("STE")
		STE->TE_TIPOMAN:= aTIP[i][1]
		STE->TE_NOME	:= aTIP[i][2]
		STE->TE_CARACTE:= aTIP[i][3]
	   STE->(MsUnLock())
   EndIf
Next i

//Grava areas
For i:= 1 to Len(aARE)
	If !NGIFdbSeek("STD",aARE[i][1],1)
		RecLock("STD",.T.)
		STD->TD_FILIAL := xFilial("STD")
		STD->TD_CODAREA:= aARE[i][1]
		STD->TD_NOME	:= aARE[i][2]
	   STD->(MsUnLock())
   EndIf
Next i

//Grava servicos
For i:= 1 to Len(aSER)
	If !NGIFdbSeek("ST4",aSER[i][1],1)
		RecLock("ST4",.T.)
		ST4->T4_FILIAL := xFilial("ST4")
		ST4->T4_SERVICO:= aSER[i][1]
		ST4->T4_NOME	:= aSER[i][2]
		ST4->T4_CODAREA:= aSER[i][3]
		ST4->T4_TIPOMAN:= aSER[i][4]
		ST4->T4_VIDAUTI:= "N"
		ST4->T4_GERAATF:= "N"
		ST4->T4_NAOCONF:= "N"
		ST4->T4_LUBRIFI:= "N"
		ST4->T4_FOLLOWU:= "N"
		ST4->T4_GARANTI:= "N"
	   ST4->(MsUnLock())
   EndIf
Next i

//Grava centro de custo
If !NGIFdbSeek("CTT",aCC[1],1)
	RecLock("CTT",.T.)
	CTT->CTT_FILIAL := xFilial("CTT")
	CTT->CTT_CUSTO  := aCC[1]
	CTT->CTT_DESC01 := aCC[2]
	CTT->CTT_CLASSE := aCC[3]
	CTT->CTT_BLOQ   := aCC[4]
	CTT->CTT_DTEXIS := CtoD("01/01/80")
	CTT->CTT_ITOBRG := "2"
	CTT->CTT_CLOBRG := "2"
	CTT->CTT_ACITEM := "1"
	CTT->CTT_ACCLVL := "1"
	CTT->(MsUnLock())
EndIf
If !NGIFdbSeek("SI3",aCC[1],1)
	RecLock("SI3",.T.)
	SI3->I3_FILIAL := xFilial("SI3")
	SI3->I3_CUSTO  := aCC[1]
	SI3->I3_DESC   := aCC[2]
	SI3->(MsUnLock())
EndIf
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCONPSTJ  ³ Autor ³ Inacio Luiz Kolling   ³ Data ³16/03/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³CONsulta especifica do STJ                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³DICIONARIO                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³           ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³   Data     ³ Descricao                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sobral     ³ 12/07/2011 ³ Alterada para tambem cONsultar as Ordens de  ³±±
±±³            ³            ³ Servio do Historico (CONsulta SXB - MNTOS)   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCONPSTJ(nTipo)
Local vSTJInd   := {NGRETTITULO("TJ_ORDEM"),NGRETTITULO("TJ_PLANO"),NGRETTITULO("TJ_CODBEM")}
Local oPnlTop, oPnlMid, oPnlBot
Local cReadVar := ReadVar()

Private nTipCONsul := If(nTipo <> Nil, nTipo, 1), cTblCONsul := "STJ"
Private cChaSTJ := Space(16),nChaSTJ := 1,aLSTJ := {},aSTJLN := {}, aSTJLT := {}
Private oOrdPla,oChaSTJ,cSTJIx,cOrdemR ,lCheck1 := If(nTipo <> Nil, .T., .F.),lCheck2 := .F.

NGCONPFIL(1)
aSTJLN := AclONe(aLSTJ)

DEFINE MSDIALOG oDlgCE TITLE OemToAnsi(STR0288+" - "+ Alltrim(FwX2Nome("STJ"))) COLOR CLR_BLACK,CLR_WHITE FROM 0,0 To 400,500 OF oMainWnd PIXEL

	//Painel TOP
	oPnlTop := TPanel():New(01, 01, , oDlgCE, , , , CLR_BLACK, CLR_WHITE, 50, 40)
	oPnlTop:Align := CONTROL_ALIGN_TOP

		@ 02,005 Combobox oOrdPla Var cSTJIx Items vSTJInd Size 200,08 Pixel Of oPnlTop ON Change NGCONPSTJT()
		@ 02,220 ButtON oBtnBuscar Prompt STR0001 Of oPnlTop Size 30,11 Pixel ActiON NGCONPSTJP()
		@ 15,005 MsGet oChvSTJ Var cChaSTJ Picture "@!" Size 200,08 Of oPnlTop Pixel

		oCheck1 := TCheckBox():New(27,07,STR0289,,oPnlTop, 100,10,,,,,,,,.T.,,,)
		oCheck1:bSetGet     := {|| lCheck1 }
		oCheck1:bLClicked   := {|| lCheck1:=!lCheck1 }
		oCheck1:bWhen       := {|| .T. }

		If nTipCONsul == 1
			oCheck2 := TCheckBox():New(27,130,STR0290,,oPnlTop, 100,10,,,,,,,,.T.,,,)
			oCheck2:bSetGet     := {|| lCheck2 }
			oCheck2:bLClicked   := {|| NGCONPTER()}
			oCheck2:bWhen       := {|| .T. }
		Else
			oCheck2 := TCheckBox():New(27,130,STR0346,,oPnlTop, 100,10,,,,,,,,.T.,,,) //"Incluir as Ordens do Histórico"
			oCheck2:bSetGet     := {|| lCheck2 }
			oCheck2:bLClicked   := {|| NGCONPHIST()}
			oCheck2:bWhen       := {|| .T. }
		EndIf

	//Painel MID
	oPnlMid := TPanel():New(01, 01, , oDlgCE, , , , CLR_BLACK, CLR_WHITE, 50, 35)
	oPnlMid:Align := CONTROL_ALIGN_ALLCLIENT

		@ 40,005 ListBox oLSTJ Var cList4;
		Fields Header;
		NGRETTITULO("TJ_ORDEM"),;
		NGRETTITULO("TJ_PLANO"),;
		NGRETTITULO("TJ_SERVICO"),;
		NGRETTITULO("TJ_CODBEM"),;
		ColSizes 40,40,40,50;
		Size 210,100 Of oPnlMid Pixel;

		bListj := { || {aLSTJ[oLSTJ:nAt,1],aLSTJ[oLSTJ:nAt,2],aLSTJ[oLSTJ:nAt,3],aLSTJ[oLSTJ:nAt,4]}}

		oLSTJ:SetArray(aLSTJ)
		oLSTJ:bLine:= bListJ
		If nTipCONsul == 2
			oLSTJ:bLDblClick := {|| cOrdemR := aLSTJ[oLSTJ:nAt,1],cTblCONsul := aLSTJ[oLSTJ:nAt,Len(aLSTJ[oLSTJ:nAt])], oDlgCE:End()}
		EndIf
		oLSTJ:GoTop()
		oLSTJ:Align := CONTROL_ALIGN_ALLCLIENT

		If nTipCONsul == 2
			oLSTJ:SetFocus()
			If !Empty( &(cReadVar) )
				cChaSTJ := AllTrim( &(cReadVar) )
				cChaSTJ := cChaSTJ + Space( 16 - Len(cChaSTJ) )
				NGCONPSTJP(.F.)
			EndIf
		EndIf

	//Painel BOT
	oPnlBot := TPanel():New(01, 01, , oDlgCE, , , , CLR_BLACK, CLR_WHITE, 50, 20)
	oPnlBot:Align := CONTROL_ALIGN_BOTTOM

		DEFINE SBUTTON oBtn1 FROM 005,005 TYPE  1 ENABLE OF oPnlBot ACTION (cOrdemR := aLSTJ[oLSTJ:nAt,1],cTblCONsul := aLSTJ[oLSTJ:nAt,Len(aLSTJ[oLSTJ:nAt])],oDlgCE:End())
		DEFINE SBUTTON oBtn2 FROM 005,035 TYPE  2 ENABLE OF oPnlBot ACTION (oDlgCE:End())
		DEFINE SBUTTON oBtn3 FROM 005,065 TYPE 15 ENABLE OF oPnlBot ACTION ( If(nTipCONsul == 1,;
																									NGVISUESPE("STJ",aLSTJ[oLSTJ:nAt,1]),;
																									NGVISUESPE(aLSTJ[oLSTJ:nAt,Len(aLSTJ[oLSTJ:nAt])],aLSTJ[oLSTJ:nAt,1])) )

ACTIVATE MSDIALOG oDlgCE CENTERED
If cOrdemR <> Nil
	If nTipCONsul == 1
	   NGIFdbSeek("STJ",cOrdemR,1)
	Else
		NGIFdbSeek(cTblCONsul,cOrdemR,1)
		If cTblCONsul == "STJ"
			PutFileInEof("STS")
		Else
			PutFileInEof("STJ")
		EndIf
	EndIf
ElseIf nTipCONsul == 2
	PutFileInEof("STS")
	PutFileInEof("STJ")
EndIf
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCONPSTJR ³ Autor ³ Inacio Luiz Kolling   ³ Data ³16/03/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorno da cONsluta especifica do STJ                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³DICIONARIO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCONSTJR(nTipo)


Local cReadVar := ReadVar()

Default nTipo := 1

If nTipo == 1
	Return STJ->TJ_ORDEM
Else
	dbSelectArea("STJ")
	If !EoF()
		Return STJ->TJ_ORDEM
	Else
		dbSelectArea("STS")
		If !EoF()
			Return STS->TS_ORDEM
		EndIf
	EndIf
EndIf

Return If(!Empty(&(cReadVar)),&(cReadVar),Space(Len(STJ->TJ_ORDEM)))

//-------------------------------------------------------------------
/*/{Protheus.doc} NGCONPFIL
Filtro da consulta especifica do STJ

Sobral  12/07/2011  Alterada para tambem consultar as Ordens de
	                Servio do Historico (Consulta SXB - MNTOS)
Mussi	06/05/2018	Alterado tipo de busca para query

@author  Inacio Luiz Kolling
@since   16/03/2010
@version P11/P12
@param	 nTip, Númerico, 1 - O.S. Finalizadas/2 - O.S. não Finalizadas
/*/
//-------------------------------------------------------------------
Function NGCONPFIL(nTip)

	Local cAliasQry := GetNextAlias()
	Local cCondSql	:= ""

	aLSTJ := {}

	If nTipCONsul == 1
		If Empty(aSTJLN) .Or. Empty(aSTJLT)

			cCondSql  := "% TJ_SITUACA = 'L' "
			If nTip <> 2
				cCondSql += " AND TJ_TERMINO = 'N' "
			EndIf
			cCondSql += "%"

			BeginSQL Alias cAliasQry

			SELECT TJ_ORDEM, TJ_PLANO, TJ_SERVICO, TJ_CODBEM
				FROM %table:STJ%
					WHERE	TJ_FILIAL = %exp:xFilial("STJ")%
						AND %exp:cCondSql%
						AND %NotDel%
					ORDER BY TJ_ORDEM, TJ_PLANO
			EndSQL

			While (cAliasQry)->( !EoF() )
				aAdd(aLSTJ, { (cAliasQry)->TJ_ORDEM, (cAliasQry)->TJ_PLANO, (cAliasQry)->TJ_SERVICO, (cAliasQry)->TJ_CODBEM } )
				(cAliasQry)->( dbSkip() )
			EndDo
			(cAliasQry)->( dbCloseArea() )

			If Empty(aLSTJ)
				aAdd(aLSTJ, { Space(TAMSX3("TJ_ORDEM")[1]), Space(TAMSX3("TJ_PLANO")[1]), Space(TAMSX3("TJ_SERVICO")[1]), Space(TAMSX3("TJ_CODBEM")[1]) })
			EndIf
		EndIf
	Else

		BeginSQL Alias cAliasQry

		SELECT TJ_ORDEM, TJ_PLANO, TJ_SERVICO, TJ_CODBEM
			FROM %table:STJ%
				WHERE	TJ_FILIAL = %exp:xFilial("STJ")%
					AND %NotDel%
				ORDER BY TJ_ORDEM, TJ_PLANO
		EndSQL

		While (cAliasQry)->( !EoF() )
			aAdd(aLSTJ, { (cAliasQry)->TJ_ORDEM, (cAliasQry)->TJ_PLANO, (cAliasQry)->TJ_SERVICO, (cAliasQry)->TJ_CODBEM, "STJ" } )
			(cAliasQry)->( dbSkip() )
		EndDo
		(cAliasQry)->( dbCloseArea() )

		If nTip == 2 //STS

			cAliasQry := GetNextAlias()

			BeginSQL Alias cAliasQry

			SELECT TS_ORDEM, TS_PLANO, TS_SERVICO, TS_CODBEM
				FROM %table:STS%
					WHERE	TS_FILIAL = %exp:xFilial("STS")%
						AND %NotDel%
					ORDER BY TS_ORDEM, TS_PLANO
			EndSQL

			While (cAliasQry)->( !EoF() )
				aAdd(aLSTJ, { (cAliasQry)->TS_ORDEM, (cAliasQry)->TS_PLANO, (cAliasQry)->TS_SERVICO, (cAliasQry)->TS_CODBEM, "STS" } )
				(cAliasQry)->( dbSkip() )
			EndDo
			(cAliasQry)->( dbCloseArea() )

		EndIf

		If Empty(aLSTJ)
			aAdd(aLSTJ, { Space(TAMSX3("TJ_ORDEM")[1]), Space(TAMSX3("TJ_PLANO")[1]), Space(TAMSX3("TJ_SERVICO")[1]), Space(TAMSX3("TJ_CODBEM")[1]) })
		Else
			Do Case
				Case nChaSTJ == 1
					aSort(aLSTJ , , , {|x,y| x[1] < y[1] })
				Case nChaSTJ == 2
					aSort(aLSTJ , , , {|x,y| x[2] < y[2] })
				Case nChaSTJ == 3
					aSort(aLSTJ , , , {|x,y| x[4] < y[4] })
			EndCase
		EndIf
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCONPTER  ³ Autor ³ Inacio Luiz Kolling   ³ Data ³16/03/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Filtro da matriz com as ordens de servico                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NGCONPSTJ                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCONPTER()
aLSTJ := {}
lCheck2 := !lCheck2
If lCheck2
   If Empty(aSTJLT)
      NGCONPFIL(2)
      aSTJLT := AclONe(aLSTJ)
   Else
      aLSTJ := AclONe(aSTJLT)
   EndIf
Else
   aLSTJ := AclONe(aSTJLN)
EndIf
bListj := { || {aLSTJ[oLSTJ:nAt,1],aLSTJ[oLSTJ:nAt,2],aLSTJ[oLSTJ:nAt,3],aLSTJ[oLSTJ:nAt,4]}}
oLSTJ:SetArray(aLSTJ)
oLSTJ:bLine:= bListJ
oLSTJ:GoTop()
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³NGCONPHISTºAutor  ³Wagner S. de Lacerdaº Data ³  12/07/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Atualiza o Browse com as Orden de Servico, seja com a STJ  º±±
±±º          ³ ou com ambas (STJ e STS), dependendo da flag.              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ .T.                                                        º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MNTC755                                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º           ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºProgramador ³   Data     ³ Descricao                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º            ³ xx/xx/xxxx ³                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGCONPHIST()

aLSTJ := {}
lCheck2 := !lCheck2
If lCheck2
   If Empty(aSTJLT)
      NGCONPFIL(2)
      aSTJLT := AclONe(aLSTJ)
   Else
      aLSTJ := AclONe(aSTJLT)
   EndIf
Else
   aLSTJ := AclONe(aSTJLN)
EndIf
bListj := { || {aLSTJ[oLSTJ:nAt,1],aLSTJ[oLSTJ:nAt,2],aLSTJ[oLSTJ:nAt,3],aLSTJ[oLSTJ:nAt,4]}}
oLSTJ:SetArray(aLSTJ)
oLSTJ:bLine:= bListJ
oLSTJ:GoTop()

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCONPSTJT ³ Autor ³ Inacio Luiz Kolling   ³ Data ³16/03/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Ordenacao das orden de servico                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NGCONPSTJ                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCONPSTJT()
nChaSTJ := oOrdPla:nAt
aLSTJ := If(nChaSTJ = 1,Asort(aLSTJ,,,{|x,y| x[1] < y[1]}),;
                        If(nChaSTJ = 2,Asort(aLSTJ,,,{|x,y| x[2] < y[2]}), Asort(aLSTJ,,,{|x,y| x[4] < y[4]})))
bListr  := {}
bListr  := { || {aLSTJ[oLSTJ:nAt,1],aLSTJ[oLSTJ:nAt,2],aLSTJ[oLSTJ:nAt,3],aLSTJ[oLSTJ:nAt,4]}}
oLSTJ:SetArray(aLSTJ)
oLSTJ:bLine:= bListr
oLSTJ:GoTop()
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCONPSTJP ³ Autor ³ Inacio Luiz Kolling   ³ Data ³16/03/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³PosiciONamente na ordem na pesqusa das ordens de servico     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NGCONPSTJ                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCONPSTJP(lShowMsg)

Default lShowMsg := .T.

nPostj := If(nChaSTJ = 1,aSCAN(aLSTJ,{|x|Alltrim(x[1]) == Alltrim(cChaSTJ)}),;
                        If(nChaSTJ = 2, aSCAN(aLSTJ,{|x| Alltrim(x[2]) == Alltrim(cChaSTJ)}),aSCAN(aLSTJ,{|x| Alltrim(x[4]) == Alltrim(cChaSTJ)})))
If nPostj > 0
  oLSTJ:nAt := nPostj
  oLSTJ:REFRESH()
ElseIf lShowMsg
  Help(" ",1,"PESQ01")
EndIf
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCHKCUSF ³ Autor ³ Inacio Luiz Kolling    ³ Data ³17/03/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³CONsiste se atualiza o saldo do custo FIFO                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro   cCodPro -  Codigo do produto               Obrigatorio      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³SIGACUSB                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCHKCUSF(cCodPro)
Local lRetCusF  := .T.

lRetCusF := NGPRODESP(cCodPro,.F.)

Return lRetCusF

//-------------------------------------------------------------------
/*/{Protheus.doc} NGAPAGD1OR
Valida o relacionamento de uma O.S. em um documento de entrada.

@param	 cOrdem,  Caracter, Numero da ordem de serviço
@param	 cOp,     Caracter, Numero da Ordem de produção
@param	 cCodIns, Caracter, Código do produto
@param	 nQuant,  Numérico, quantidade do produto

@author  Inacio Luiz Kolling
@since   11/05/2010
@version P12

@return  Lógico
/*/
//-------------------------------------------------------------------
Function NGAPAGD1OR(cOrdem,cOp,cCodIns,nQuant)

	Local aArea := GetArea()
	Local lRet := .T.

	Default cOrdem  := Space(Len(STJ->TJ_ORDEM))
	Default cCodIns := Space(Len(SD1->D1_COD))
	Default cOp     := Space(Len(SD1->D1_OP))
	Default nQuant  := 0


	If ( SuperGetMV("MV_NGMNTES",.F.,"N") == "S" .OR. SuperGetMV("MV_NGMNTCM",.F.,"N") == "S" ) .And. ;
		SuperGetMV("MV_NGCOQPR",.F.,"N") == "S"

		If Empty(cOrdem) .And. !Empty(cOp)
			dbSelectArea("SC2")
			dbSetOrder(1)
			If dbSeek(xFilial("SC2")+Substr(cOp,1,Len(STJ->TJ_ORDEM))) .And. SC2->(C2_ITEM+C2_SEQUEN) == "OS001";
																	   .And. ("OS001"$cOp .Or. "  001" $ cOp)
				cOrdem := Substr(cOp,1,Len(STJ->TJ_ORDEM))
			EndIf
		EndIf

		If NGIFdbSeek("STJ",cOrdem,1)
			If !NGCHKLIMP(STJ->TJ_CODBEM,cCodIns,nQuant)
				lRet := .F.
			EndIf
		EndIf
	EndIf

	RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MntGar    ºAutor  ³Taina A. Cardoso    º Data ³  19/08/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se esta violando a garantia do produto             º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA110                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MNTGGAR()

Local i, j
Local cOP := ""
Local cCodBem := ""
Local nPProd    := aScan(aHeader,{|x| Trim(x[2])=="C1_PRODUTO"})
Local nPDtin    := aScan(aHeader,{|x| Trim(x[2])=="C1_DATPRF"})
Local nPop      := aScan(aHeader,{|x| Trim(x[2])=="C1_OP"})
Local nPObs     := aScan(aHeader,{|x| Trim(x[2])=="C1_OBS"})
Local nPQuat    := aScan(aHeader,{|x| Trim(x[2])=="C1_QUANT"})
Local lGarant   := .F.
Local cGarant   := " ",cTPZOrdem := ""
Local aGarant := {}
Local dDtVal := CtoD("  /  /  ")

If SuperGetMV("MV_NGMNTCM",.F.,"") == "S"
   For i := 1 to Len(acols)
		If nPop > 0
		   cOp := AT("O",aCols[i][nPop])
		EndIf
	   If SubStr(aCols[i][nPop],cOp,5)== "OS001" .And. !aCols[i][Len(aCols[i])]
	   	If nPop > 0
				cOrdem := SubStr(aCols[i][nPop],1,6)
			EndIf
			cProduto := aCols[i][nPProd]
			dDtIni := aCols[i][nPDtin]
			dbSelectArea("STJ")
			dbSetOrder(1)
			If dbSeek(xFilial("STJ")+cOrdem)
				cCodBem := STJ->TJ_CODBEM
			EndIf
			dbSelectArea("TPZ")
			dbSetOrder(1)
			If dbSeek(xFilial("TPZ")+cCodBem+"P"+cProduto)
				While !EoF() .And. xFilial("TPZ")+cCodBem+"P"+cProduto == TPZ->TPZ_FILIAL+TPZ->TPZ_CODBEM+"P"+TPZ->TPZ_CODIGO
					If TPZ->TPZ_UNIGAR = "D"
		   			dDtVal := TPZ->TPZ_DTGARA + TPZ->TPZ_QTDGAR
				   ElseIf TPZ->TPZ_UNIGAR = "S"
		   			dDtVal := TPZ->TPZ_DTGARA + (TPZ->TPZ_QTDGAR * 7)
		   		ElseIf TPZ->TPZ_UNIGAR = "M"
				   	dDtVal := TPZ->TPZ_DTGARA + (TPZ->TPZ_QTDGAR * 30)
				   EndIf
				   If dDtIni <= dDtVal .And. dDtIni >= TPZ->TPZ_DTGARA .And. !Empty(dDtVal)
				   	cProduto := NGSEEK("SB1",aCols[i][nPProd],1,"B1_DESC")
				   	If TPZ->TPZ_UNIGAR == "D"
				   		cTipoGar := STR0351  //"dias."
				   	ElseIf TPZ->TPZ_UNIGAR == "S"
				   		cTipoGar := STR0352//"semanas."
				   	ElseIf TPZ->TPZ_UNIGAR == "M"
				   		cTipoGar := STR0353 //"meses."
				   	EndIf
				   	AAdd(aGarant,{TPZ->TPZ_ORDEM,+Chr(13)+Chr(10)+Alltrim(Str(acols[i][nPQuat]))+" - "+Alltrim(cProduto)+" ("+Alltrim(aCols[i][nPProd])+")"+;
		   		        STR0360+dToc(TPZ->TPZ_DTGARA)+STR0354+Alltrim(Str(TPZ->TPZ_QTDGAR))+" "+Alltrim(cTipoGar)+Chr(13)+Chr(10)+Chr(13)+Chr(10)}) //"no dia" ## " que possuia a garantia de "
				   	lGarant := .T.
				   	Exit
				   ElseIf Alltrim(aCols[i][nPObs]) == STR0355 //"Verificar violacao de garantia"
						aCols[i][nPObs] := ""
				   EndIf
				   dbSelectArea("TPZ")
				   dbSkip()
				End
				If lGarant
					aCols[i][nPObs] := STR0355 //"Verificar violação de garantia"
					lRet := .T.
				EndIf
			EndIf
		EndIf
	Next i
EndIf

If lGarant
	aSort(aGarant,,,{|x,y| x[1] < y[1]})
	cGarant := STR0350+aGarant[1][1]+":"+Chr(13)+Chr(10)
	cTPZOrdem := aGarant[1][1]
	For j := 1 to len(aGarant)
		If cTPZOrdem <> aGarant[j][1]
			cGarant := cGarant + STR0350+aGarant[j][1]+":"+Chr(13)+Chr(10)
		EndIf
		cGarant := cGarant +  aGarant[j][2]
		cTPZOrdem := aGarant[j][1]
	Next j
	cGarant := cGarant +Chr(13)+Chr(10) + STR0356 //"Dessa forma a troca desse(s) produto(s) poderá violar a garantia."
	MntVerLog(cGarant,1)
EndIf
lRet := .T.

Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MntVerLog ³ Autor ³Taina Alberto Cardoso  ³ Data ³16/08/2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Exibe o arquivo de log da quebra de garantia                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA420                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MntVerLog(cArq,nRecno)

Local cTexto := ""
Local oFONt, oDlgl
Local cMask  := STR0357 //"Arquivos Texto (*.TXT) |*.txt|"

	Private aLog   := Array(1)

	If !Empty(cArq)
		cTexto := cArq
		aLog[1] := {cTexto}
		cLog := STR0358 //"Atualizacao de Dados"
		DEFINE FONT oFONt NAME "Courier New" SIZE 5,0
		DEFINE MSDIALOG oDlgl TITLE STR0355 FROM 3,0 to 340,417 COLOR CLR_BLACK,CLR_WHITE PIXEL //"Verificar violação de garantia"
			@ 5,5 GET oMemo  VAR cTexto MEMO SIZE 200,145 OF oDlgl PIXEL
				oMemo:bRClicked := {||AllwaysTrue()}
				oMemo:oFONt := oFONt
				oMemo:lReadONly := .T.

			DEFINE SBUTTON FROM 153,175 TYPE 1 ACTION oDlgl:End() ENABLE OF oDlgl PIXEL
			DEFINE SBUTTON  FROM 153,145 TYPE 13 ACTION (cFile:=cGetFile(cMask,OemToAnsi(STR0359)),If(cFile="",.T.,MemoWrite(cFile,cTexto)),) ENABLE OF oDlgl PIXEL  //"Salvar Como..."
		ACTIVATE MSDIALOG oDlgl CENTERED
	EndIf
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    |fWhileFil | Autor ³JacksON Machado		³ Data ³13/01/2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Função de While genérica para CodeBase ONde percorre a STL  ³±±
±±³          ³cONforme chave do Seek.									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTUTIL                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fWhileFil(cKey)
Local nX
Local aAlter := {}
Local nInd := NGRETORDEM("STL","TL_FILIAL+TL_TIPOREG+TL_CODIGO",.F.)
If nInd == 0
	nInd := 8
EndIf

While !EoF() .And. STL->TL_FILIAL+STL->TL_TIPOREG+SubStr(STL->TL_SEQRELA,1,1) == cKey
	cSeqRela := ""
	If Empty(STL->TL_SEQRELA)
		STL->(dbSkip())
		Loop
	EndIf
    nQtd := 0
    nRec := STL->(Recno())
    cChave := STL->TL_FILIAL+STL->TL_ORDEM+STL->TL_PLANO
    cSeqSal := AllTrim(STL->TL_SEQRELA)
    dbSelectArea("STL")
	dbSetOrder(1)
    If dbSeek(cChave)
    	While !EoF() .And. STL->TL_FILIAL+STL->TL_ORDEM+STL->TL_PLANO == cChave
    		If AllTrim(STL->TL_SEQRELA) == cSeqSal
    	 		nQtd++
    	 	EndIf
    	 	STL->(dbSkip())
    	End
    EndIf
    dbSelectArea("STL")
	dbSetOrder(nInd)
	dbGoTo(nRec)
	If nQtd > 1
		cSeqRela := fRetSeq(STL->TL_FILIAL+STL->TL_ORDEM+STL->TL_PLANO,.F.)
		dbSelectArea("STL")
		dbSetOrder(nInd)
		dbGoTo(nRec)
	Else
		cSeqRela := STL->TL_SEQRELA
	EndIf
	aAdd(aAlter,{nRec,cSeqRela})
	STL->(dbSkip())
End
//For necessario pois ao dar o RecLock como o registro não estava mais com espaços em branco, ocupava outra posição dentro da tabela.
For nX := 1 To Len(aAlter)
	dbSelectArea("STL")
	dbGoTo(aAlter[nX][1])
	RecLock("STL")
	STL->TL_SEQRELA := PADR(AllTrim(aAlter[nX][2]),3)
	STL->(MsUnLock())
Next nX

Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    |fRetSeq   | Autor ³JacksON Machado		³ Data ³13/01/2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Retorna proxima sequencia									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTUTIL                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fRetSeq(cKey,lHist)
Local cSequen := ""
Local cTable := If(lHist,"STT","STL")
Local cWhile := If(lHist,"STT->TT_FILIAL+STT->TT_ORDEM+STT->TT_PLANO","STL->TL_FILIAL+STL->TL_ORDEM+STL->TL_PLANO")
Local cSeq   := If(lHist,"STT->TT_SEQRELA","STL->TL_SEQRELA")
dbSelectArea(cTable)
dbSetOrder(1)
If dbSeek(cKey)
	While !EoF() .And. &(cWhile) == cKey
		If Val(&(cSeq)) > 0
			If Val(&(cSeq)) > Val(cSequen)
				cSequen := &(cSeq)
			EndIf
		EndIf
		dbSelectArea(cTable)
		dbSkip()
	End
EndIf
cSequen := AllTrim(cSequen)

Return If(FindFunction("Soma1Old"),PADR(Soma1Old(cSequen),3),PADR(Soma1(cSequen),3))
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    |fWhileHFil| Autor ³JacksON Machado		³ Data ³13/01/2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Função de While genérica para CodeBase ONde percorre a STT  ³±±
±±³          ³cONforme chave do Seek.									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTUTIL                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fWhileHFil(cKey)
Local nX
Local aAlter := {}
Local nInd := NGRETORDEM("STT","TT_FILIAL+TT_TIPOREG+TT_CODIGO",.F.)
If nInd == 0
	nInd := 3
EndIf
While !EoF() .And. STT->TT_FILIAL+STT->TT_TIPOREG+SubStr(STT->TT_SEQRELA,1,1) == cKey
	cSeqRela := ""
	If Empty(STT->TT_SEQRELA) //.Or. !Empty(SubStr(STT->TT_SEQRELA,1,1))
		STT->(dbSkip())
		Loop
	EndIf
    nQtd := 0
    nRec := STT->(Recno())
    cChave := STT->TT_FILIAL+STT->TT_ORDEM+STT->TT_PLANO
    cSeqSal := AllTrim(STT->TT_SEQRELA)
    dbSelectArea("STT")
	dbSetOrder(1)
    If dbSeek(cChave)
    	While !EoF() .And. STT->TT_FILIAL+STT->TT_ORDEM+STT->TT_PLANO == cChave
    		If AllTrim(STT->TT_SEQRELA) == cSeqSal
    	 		nQtd++
    	 	EndIf
    	 	STT->(dbSkip())
    	End
    EndIf
    dbSelectArea("STT")
	dbSetOrder(nInd)
	dbGoTo(nRec)
	If nQtd > 1
		cSeqRela := fRetSeq(STT->TT_FILIAL+STT->TT_ORDEM+STT->TT_PLANO,.T.)
		dbSelectArea("STT")
		dbSetOrder(nInd)
		dbGoTo(nRec)
	Else
		cSeqRela := STT->TT_SEQRELA
	EndIf
	aAdd(aAlter,{nRec,cSeqRela})
	STT->(dbSkip())
End
//For necessario pois ao dar o RecLock como o registro não estava mais com espaços em branco, ocupava outra posição dentro da tabela.
For nX := 1 To Len(aAlter)
	dbSelectArea("STT")
	dbGoTo(aAlter[nX][1])
	RecLock("STT")
	STT->TT_SEQRELA := PADR(AllTrim(aAlter[nX][2]),3)
	STT->(MsUnLock())
Next nX

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MNTWHENDF ºAutor  ³RobsON Cristian     º Data ³  26/04/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ When dos campos TL_DTFIM e TL_HOFIM                        º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAMNT                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MNTWHENDF()

	Local lRet    := .T.
	Local nTipReg := 0 // Variável que cONtrola a qtd de insumos na getdados.

	Do Case

		Case FwIsInCallStack( 'NG400FIM' )

			// Verifica a existência das variaveis aCols e aHeader
			If Type( 'aCols' ) == 'A' .And. Type( 'aHeader' ) == 'A'

				// Se existir o campo "TL_TIPOREG" no aHeader, atribui a variável.
				nTipReg := aScan( aHeader, { |x| Trim( Upper( x[2] ) ) == 'TL_TIPOREG' } )

				/*
					Se o campo existir no aHeader ( E ) a memória do item for diferente da linha da getdados ( E ) a
					memória do campo for igual a produto ( OU ) a linha da getdados for do tipo produto.
				*/
				lRet := !( nTipReg > 0 .And. ( M->TL_TIPOREG == aCols[n,nTipReg] .And. M->TL_TIPOREG == 'P' ) .Or.;
					aCols[n,nTipReg] == 'P' )


			EndIf

		Case FwIsInCallStack( 'MNTA990' )

			// Caso utilize calendário os campos TL_DTFIM e TL_HOFIM ficam abertos.
			lRet := NgVldRpo( { { 'MNTA990.prx', cToD( '19/08/2020' ), '09:10' } } ) .And.;
				GDFieldGet( 'TL_USACALE', oGet:nAt, .F., oGet:aHeader, oGet:aCols ) == 'S'

		OtherWise

			// Se o tipo de insumo for igual a produto, bloqueio o WHEN dos campos TL_DTFIM e TL_HOFIM.
			lRet := M->TL_TIPOREG != 'P'

	End Case

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} NGFIV1DUP
Verifica possivel incONsistencia entre o parametro MV_1DUP (parametro inicial para a geracao de parcelas),
em relacao ao tamanho do grupo de campos de parcela.

@author Hugo R. Pereira
@since 28/05/2012
@versiON MP10
@return lReturn Indica se o parametro MV_1DUP esta definido corretamente.
/*/
//---------------------------------------------------------------------
Function NGFIV1DUP()
Local cIniPar  := SuperGetMV("MV_1DUP",.F.,"")
Local nTamParc := TAMSX3("TS2_PARCEL")[1]

// Verifica divergencia no tamanho do fator parcela entre seu inicializado e seu grupo de campo
If !Empty(cIniPar) .And. nTamParc < Len(cIniPar)
	ShowHelpDlg(STR0074,; // "Atencao"
				{STR0399},1,; // "Verifique o cONteúdo do parâmetro MV_1DUP em relação ao tamanho do grupo de campos de parcela."
				{STR0400},1) // "Informe o corretamente o parâmetro MV_1DUP."
	Return .F.
EndIf

// Verifica caracteres minusculos no cONteudo informado para o parametro
If cIniPar <> Upper(cIniPar)
	ShowHelpDlg(STR0074,; // "Atencao"
				{STR0401},1,; // "O cONteúdo do parâmetro MV_1DUP não deve possuir caracteres minúsculos."
				{STR0400},1) // "Informe o corretamente o parâmetro MV_1DUP."
	Return .F.
EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGFI1DUP
Retorna cONteudo do parametro MV_1DUP.
Deve ser utilizada juntamente da funcao NGFI1DUP(), cONsistindo o cONteudo informado e o tamanho do grupo
de campo de Parcela. Caso o parametro nao exista, o retorno será cONdizente com o tamanho do campo TS2_PARCEL,
utilizando como padrao o valor "1" acrescentado de zeros cONforme o tamanho do campo de parcela menciONado acima.

@author Hugo R. Pereira
@since 28/05/2012
@versiON MP10
@return cReturn CONteudo do campo MV_1DUP (Inicio da sequencia das parcelas),
		formatado cONforme tamanho do grupo de campo Parcela.
/*/
//---------------------------------------------------------------------
Function NGFI1DUP()
Local nTamParc := TAMSX3("TS2_PARCEL")[1]
Return Padr( Upper( SuperGetMV("MV_1DUP",.F.,StrZero( 1, nTamParc) ) ), nTamParc )

//---------------------------------------------------------------------
/*/{Protheus.doc} NGFICONDP
Verifica possivel incONsistencia na cONdicao de pagamento.

@param lVerPar  Define se deve verificar a existencia parcelas ja estabelecidas.
@param lShowMsg Permite a apresentacao da mensagem de erro em tela.
@param nValor   Valor total informado utilizado para definição das parcelas.
@param cCONdPag Codigo da cONdicao de pagamento a ser utilizado para geracao das parcelas.
@param dDtEmiss Data de emissao da geracao das parcelas.
                Utilizado pela funcao CONdicao() como base para definicao das datas de vencimento.

@author Hugo R. Pereira
@since 28/05/2012
@versiON MP10
@return lCONdicao Indica se a cONdicao de pagamento e' valida [.T.].
/*/
//---------------------------------------------------------------------
Function NGFICONDP(lVerPar, lShowMsg, nValor, cCONdPag, dDtEmiss)
Local nNrParc, cParSe2

Local lCONdicao  := .T.
Local aArea      := GetArea()

Default lVerPar  := .T.
Default lShowMsg := .T.

// Verifica se deve atualizar o array Parcelas
If lVerPar .And. Len(aParcelas) > 0
	Return .T.
EndIf

aParcelas := CONdicao(nValor,cCONdPag,,dDtEmiss) // Define novo array de parcelas cONforme parametros
lCONdicao := Len(aParcelas) > 0 // Verifica se as parcelas foram definidas corretamente

If !lCONdicao .And. lShowMsg // Caso nao hajam parcelas estabelecidas, e seja requisitado a apresentacao de erro

	ShowHelpDlg(STR0074,;		// "Atencao"
				{STR0397},1,;	// "CONdição de pagamento inválida para a geração das parcelas."
				{STR0398},1) 	// "Informe outra cONdição de pagamento."

ElseIf lCONdicao // Se as parcelas foram geradas corretamente

	// Define indicador da parcela cONforme parametro MV_1DUP
	cParSe2 := Padr(NGFI1DUP(),TAMSX3("TS2_PARCEL")[1])

	// Inclui indicador da parcela ao retorno da funcao CONdicao() respONsavel pela geracao das parcelas
	For nNrParc := 1 To Len(aParcelas)

		aAdd(aParcelas[nNrParc],cParSe2) // AdiciONa linha em branco para ordenacao
		cParSe2 := MNTPARCELA(cParSe2) // Soma indicador da parcela

	Next nNrParc
EndIf

RestArea(aArea)

Return lCONdicao

//---------------------------------------------------------------------
/*/{Protheus.doc} NGVALALMOX
Função que valida o almoxarifado informado no campo TL_LOCAL.

@param cTipReg Indica o tipo do insumo (Prod. ou Terc.)
@param cCodIns Indica o código do insumo

@return lRet Indica se o almoxarifado é ou não válido.

@author Cezar Augusto Padilha
@since 21/11/2012


/*/
//---------------------------------------------------------------------
Function NGValAlmox( cTipReg, cCodIns )

	Local cLocEst, lRet

	Local nTipReg := aScan(aHeader, {|x| Trim( Upper(x[2]) ) == "TL_TIPOREG"})
	Local nCodIns := aScan(aHeader, {|x| Trim( Upper(x[2]) ) == "TL_CODIGO" })
	Local nLocliz := aScan( aHeader, { |x| Trim( Upper( x[2] ) ) == 'TL_LOCALIZ' } )

	//Verifica utilização da tabela de locais de estoque (NNR)
	Local lNNR	:= NGCADICBASE( "NNR_CODIGO", "A", "NNR", .F. ) .And.;
						Alltrim( Posicione("SX3",2,"B1_LOCPAD","X3_F3") ) == "NNR"

	//Atribui valor padrão às variáveis de parâmetro
	Default cTipReg := cCodIns := ''

	cTipReg := IIf( nTipReg > 0, aCols[n, nTipReg], IIf( !Empty(cTipReg), cTipReg, M->TL_TIPOREG ) )
	cCodIns := IIf( nCodIns > 0, aCols[n, nCodIns], IIf( !Empty(cCodIns), cCodIns, M->TL_CODIGO ) )
	cLocEst := IIf( !Empty( M->TL_LOCAL ), M->TL_LOCAL, &( ReadVar() ) )

	If ( lRet := !Empty(cTipReg) )
		If lNNR
			lRet := ExistCpo("NNR", cLocEst)
		Else
			If cTipReg == "T"
				cCodIns := IIf(FindFunction("NGProdMNT"), NGProdMNT("T")[1], PadR(SuperGetMv("MV_PRODTER"), Len(STL->TL_CODIGO)))
			EndIf
			lRet := IIf(!Empty(cCodIns), ExistCpo("SB2", cCodIns + cLocEst), .F.)
		EndIf
	EndIf

	If lRet .And. nLocliz > 0
		aCols[n, nLocliz] := Space(TamSX3("TL_LOCALIZ")[1])
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTTRANST1
Tranfere centro de custo junto através do módulo de transferência de
funciONário do módulo de gestão de pessoas

@author Pedro Henrique Soares de Souza
@since 12/09/2013
@versiON MP11
/*/
//---------------------------------------------------------------------
Function MNTTRANST1(cOemp,cDemp,cOfil,cDfil,cOmat,cDmat,cOcc,cDcc)

Local aAreaXXX := GetArea()
Local aAreaST1 := ST1->(GetArea())

If SuperGetMv("MV_NGMNTRH",.F.,"N") == "S" .Or. SuperGetMv("MV_NGMNTRH",.F.,"N") == "X"
	If cOemp == cDemp .And. cOcc <> cDcc
		//Atualiza  Centro de Custo
		dbSelectArea("ST1")
		dbSetOrder(1)
		If dbSeek(xFilial("SRA",cOfil)+cOmat)
			Reclock("ST1",.F.)
			ST1->T1_CCUSTO  := cDcc
			MsUnLock("ST1")
		EndIf
	EndIf
EndIf
RestArea(aAreaST1)
RestArea(aAreaXXX)

Return .T.

//---------------------------------------------------------- -----------
/*/{Protheus.doc} NGRECGRAVA
Funcao chamada para gravas as alterações feitas no cadastro de Recurso
Utilizada no fONte MATA610

@param cCodRec  Codigo do recurso utilizado para o cadastro do bem

@author Tainã Alberto Cardoso
@since 02/10/13
/*/
//---------------------------------------------------------------------
Function NGRECGRAVA(cCodRec)

	dbSelectArea("ST9")
	dbSetOrder(13)
	If dbSeek(xFilial("ST9")+"R"+SH1->H1_CODIGO)
		Reclock("ST9",.F.)
		ST9->T9_CCUSTO  := SH1->H1_CCUSTO
      	ST9->T9_CENTRAB := SH1->H1_CTRAB
      	ST9->T9_CALENDA := SH1->H1_CALEND
      	ST9->T9_NOME    := SH1->H1_DESCRI
		MsUnLock("ST9")
	EndIf
Return

//---------------------------------------------------------- -----------
/*/{Protheus.doc} MntViewSB2()
Função para mostrar tela de estoque de produto SB2
@param cTipo : tipo de insumo,
@param cCodigo: codigo do produto
@author Maria Elisandra de Paula
@since 11/02/2014
/*/
//---------------------------------------------------------------------
Function MntViewSB2(cTipo,cCodigo)

	If cTipo <> "P"

		ShowHelpDLG(STR0586,{STR0587},2,{STR0588},2)
		Return .F.

	Else

		If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"

			dbSelectArea( 'SB1' )
			dbSetOrder( 1 ) // B1_FILIAL + B1_COD
			If MsSeek( xFilial( 'SB1' ) + cCodigo )

				// Inclui/Atualiza saldo em estoque para todos locais.
				NGMUStoLvl( cCodigo, , .F., , , .T. )

			EndIf

		EndIf

		MaViewSB2( cCodigo )

	EndIf

Return .T.
//---------------------------------------------------------------
/*/{Protheus.doc} VISRELMNT
Função que chama a verificação dos fontes que foram alterados
para MVC

@author Pablo Servin
@since 17/04/2014

@param nVerOld - Versão antiga da execução da função
	   nVerAtu - Versão atual da função

@versiON MP11
@return Nil
/*/
//----------------------------------------------------------------
Function VISRELMNT(nVerOld,nVerAtu)

	Local aRotMVC
	Local cParam := ""

	Default nVerOld := 0
	Default nVerAtu := 1

	If FindFunction( "INIARRMOD" )
		dbSelectArea("TQD")
		dbSetOrder(1)
		cParam := "OVIEW:GETVALUE( 'MNTA100_STD','TD_CODAREA' )"
		If dbSeek(xFilial("TQD") + 'MNTA100 ' +  "MNTC100" ) .And. Alltrim(TQD->TQD_PARAM) <> cParam
			RecLock("TQD",.F.)
			TQD->TQD_PARAM := "OVIEW:GETVALUE( 'MNTA100_STD','TD_CODAREA' )"
			MsUnLock("TQD")
		EndIf
		cParam := "OVIEW:GETVALUE( 'MNTA100_STD','TD_CODAREA' )"
		If dbSeek(xFilial("TQD") + 'MNTA100 ' +  "MNTC105" ) .And. Alltrim(TQD->TQD_PARAM) <> cParam
			RecLock("TQD",.F.)
			TQD->TQD_PARAM := cParam
			MsUnLock("TQD")
		EndIf
		cParam := "oView:GetValue( 'MNTA110_STE','TE_TIPOMAN' )"
		If dbSeek(xFilial("TQD") + 'MNTA110 ' + "MNTC110") .And. Alltrim(TQD->TQD_PARAM) <> cParam
			RecLock("TQD",.F.)
			TQD->TQD_PARAM := cParam
			MsUnLock("TQD")
		EndIf
		aRotMVC := INIARRMOD() // Esta função está no MNTR991.prw
		If !VERMVCMNT(aRotMVC)
			If MsgYesNo( STR0591 ) // "Deseja visualizar o relatório de incONsistências que devem ser corrigidas?"
				MNTR991( aRotMVC ) // Chamada do relatório com as incONsistências.
			EndIf
		EndIf
	EndIf


Return Nil

//----------------------------------------------------------------
/*/{Protheus.doc} VERMVCMNT
Verifica se as rotinas cONvertidas para MVC utilizam campo de
memória na TQD. Se houver, pergunta para o usuário se ele deseja
ver o relatório com as rotinas cONvertidas e soluções, na entrada
do sistema.

@param aRotMVC: array com as rotinas que foram cONvertidas e
precisam ser verificadas.

@author Pablo Servin
@since 11/04/2014
@versiON MP11
@return .T. Se não há mais correções a serem realizadas, ou seja,
                não pergunta.

         .F. Se há correções a serem realizadas, ou seja, pergunta
         se o usuário deseja visualizar o relatório.
/*/
//----------------------------------------------------------------
Function VERMVCMNT(aRotMVC)

	Local nG

	For nG := 1 to Len( aRotMVC )
		dbSelectArea( "TQD" )
		dbSetOrder( 01 ) // TQD_FILIAL + TQD_PROGRA + TQD_FUNCAO
		// Verifica se encONtra o registro de acordo com a função que está no array.
		If ( dbSeek( xFilial( "TQD" ) + aRotMVC[nG][1] ) )
			// Verifica se alguma variável de memória(M->) está cONtida no campo TQD_PARAM.
			If ( "M->" $ TQD->TQD_PARAM .Or. "m->" $ TQD->TQD_PARAM )
				Return .F.
			EndIf
		EndIf
	Next nG

Return .T.

//----------------------------------------------------------------
/*/{Protheus.doc} MNTTRANALM
Grava histórico na TQZ quando é feito transferencia
de almoxarifado no modulo de estoque( MATA260 ).

@param cCodPord:   Código do produto
@param cAlmox:     Código do almoxeficado
@param nQuant:     Quantidade transferida
@param dEmis260:   Data da Transferencia de almoxarifado

@author Tainã Alberto Cardoso
@since 18/06/2014
@versiON MP11
@return .T. Se não há mais correções a serem realizadas, ou seja,
                não pergunta.

         .F. Se há correções a serem realizadas, ou seja, pergunta
         se o usuário deseja visualizar o relatório.
/*/
//----------------------------------------------------------------
Function MNTTRANALM(cCodpro,cAlmox,nQuant,dEmis260)

	//A funcção foi retirada da rotina MATA260 na versão 12, é possível que
	//seja inserida novamente, para tal deverá ser testada novamente e decomentada.

/*	Local oTmpTbl	:= ""
	Local cQryST9	:= ""
	Local aDBF2		:= {}
	Local cAliasQry	:= GetNextAlias()
	Local lInverte	:= .F.

	Private oPanelAlmox
	Private oMarkAlmox
	Private cMarca 	:= GetMark()
	Private cTRBBEM := GetNextAlias()

	aAdd(aDBF2, {"OK"    , "C", 02, 0})
	aAdd(aDBF2, {"BEM"	 , "C", 16, 0})
	aAdd(aDBF2, {"NOMBEM", "C", 40, 0})
	aAdd(aDBF2, {"STATUS", "C", 02, 0})

	//Cria TRB
	oTmpTbl := FwTemporaryTable(cTRBBEM, aDBF2)
	oTempTable:AddIndex( "Ind01" , {"BEM"} )
	oTempTable:Create()

	aTRB1 := {}
	aAdd(aTRB1,{"OK"  , NIL, " "	   ,	 })
	aAdd(aTRB1,{"BEM"	, NIL, STR0595 ,"@!" }) //"Bem"
	aAdd(aTRB1,{"NOMBEM", NIL, STR0418 ,"@!" }) //"Nome "


	//Verifica os bens deste almoxarifado
	cQryST9 := " SELECT ST9.T9_CODBEM,ST9.T9_NOME, T9_STATUS "
	cQryST9 += " 	FROM "+RetSqlName("ST9")+" ST9 "
 	cQryST9 += " 	WHERE ST9.T9_CODESTO = '" +cCodpro+ "' AND "
 	cQryST9 += "  ST9.T9_FILIAL = "+ValToSql(xFilial("ST9")) + " "
 	cQryST9 += "  AND ST9.D_E_L_E_T_ <> '*' "
 	cQryST9 := ChangeQuery(cQryST9)
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQryST9),cAliasQry, .F., .T.)

	dbSelectArea(cAliasQry)
	dbGoTop()

	If !EoF() .And. !BoF()
		If !MsgYesNo(STR0596) //"Deseja alterar o almoxarifado para os bens que possuem relaciONamento com o produto?"
			oTmpTbl:Delete()
			Return .T.
		EndIf
	EndIf

	While !EoF()

		dbSelectArea(cTRBBEM)
		RecLock(cTRBBEM,.T.)
		(cTRBBEM)->BEM 	:= (cAliasQry)->T9_CODBEM
		(cTRBBEM)->NOMBEM := (cAliasQry)->T9_NOME
		(cTRBBEM)->STATUS := (cAliasQry)->T9_STATUS
		MsUnLock(cTRBBEM)

		dbSelectArea(cAliasQry)
		dbSkip()
	EndDo

	dbSelectArea( cTRBBEM )
	dbGoTop()

	DEFINE MSDIALOG oDlg FROM 0,0 To 400,680 TITLE STR0597 OF oMainWnd PIXEL //"Transferencia de Almoxerifado"

	//Painel de Campos
	oPanelAlmox := TPanel():New(00,00,,oDlg,,,,,,200,080,.F.,.F.)
	oPanelAlmox:Align := CONTROL_ALIGN_ALLCLIENT
	oPanelAlmox:nHeight := 100

	//MONta o objeto gráfico tipo "Grid" cONtemplando a opção de  marcação.
	oMarkAlmox := MsSelect():NEW(cTRBBEM,"OK",,aTRB1,@lInverte,@cMarca,{030,00,189,343},,,oPanelAlmox,,)
	oMarkAlmox:bMARK := {|| } //Grava marca em todos os registros validos.
	oMarkAlmox:oBrowse:lHASMARK	 := .T.
	oMarkAlmox:oBrowse:lCANALLMARK := .T.
	oMarkAlmox:oBrowse:bALLMARK	 := {|| MNTALMOXIN( cMarca ) } // Chamada da função que executa no duplo clique em um elemento no browse.
	oMarkAlmox:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	ACTIVATE MsDialog oDlg ON INIT EnchoiceBar( oDlg, {||  If(MNTVALAMOX(nQuant,cAlmox,dEmis260,cCodpro) ,oDlg:End(),nil) }, {|| oDlg:End() }) Centered

	oTmpTbl:Delete()*/

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTALMOXIN( cMarca )
Inverte a marcação do browse, ao clicar em todos os bens do markbrowse.

@author Tainã Alberto Cardoso
@since 18/06/2014
@return .T.
/*/
//---------------------------------------------------------------------
Static Function MNTALMOXIN( cMarca )

	Local aArea := GetArea()

	dbSelectArea( cTRBBEM )
	dbGoTop()
	While !EoF()
		(cTRBBEM)->OK := If( (cTRBBEM)->OK == "  ", cMarca, "  " )
		dbSelectArea( cTRBBEM )
		dbSkip()
	End While

	oMarkAlmox:oBrowse:Refresh( .T. ) // Atualiza o objeto.

	RestArea( aArea )

Return .T.

//----------------------------------------------------------------
/*/{Protheus.doc} MNTVALAMOX
Verifica a quantidade do produto com a quantidade de Bens
seleciONados

@param nQuant: Quantidade transferida
@param cAlmox:     Código do almoxeficado
@param dEmis260:   Data da Transferencia de almoxarifado

@author Tainã Alberto Cardoso
@since 18/06/2014
@versiON MP11
@return .T.
/*/
//----------------------------------------------------------------
Static Function MNTVALAMOX(nQuant,cAlmox,dEmis260,cCodpro)

	Local nCount := 0

	//Verifica se há mais bens seleciONado que a quantidade de do produto
	dbSelectArea(cTRBBEM)
	dbGoTop()
	While !EoF()
		If !Empty((cTRBBEM)->OK)
			nCount++
		EndIf
		dbSelectArea(cTRBBEM)
		dbSkip()
	End

	If nCount > nQuant
		MsgInfo(STR0598)  //"A quantidade de bens é maior que a quantidade de produto"
		dbSelectArea(cTRBBEM)
		dbGoTop()
		Return .F.
	EndIf

	//Se a quantidade dos bens foi igual ou menor que a quantidade
	//do produto grava um registro na tabela TQZ com o almoxarifado novo
	dbSelectArea(cTRBBEM)
	dbGoTop()
	While !EoF()

		If !Empty((cTRBBEM)->OK)

			dbSelectArea("TQZ")
			dbSetOrder(1)
			If !dbSeek(xFilial("TQZ") + (cTRBBEM)->BEM + DtoS(dEmis260) + SubStr(Time(),1,5))
				RecLock("TQZ",.T.)
		  		TQZ->TQZ_FILIAL  := xFilial("TQZ")
		  		TQZ->TQZ_CODBEM  := (cTRBBEM)->BEM
		  		TQZ->TQZ_DTSTAT  := dEmis260
		  		TQZ->TQZ_HRSTAT  := SubStr(Time(),1,5)
		  		TQZ->TQZ_STATUS  := (cTRBBEM)->STATUS
		  		TQZ->TQZ_PRODUT  := cCodpro
		  		TQZ->TQZ_ALMOX   := cAlmox
				MsUnLock("TQZ")
			EndIf
		EndIf

		dbSelectArea(cTRBBEM)
		dbSkip()
	End

	dbSelectArea(cTRBBEM)
	dbGoTop()

Return .T.

//----------------------------------------------------------------
/*/{Protheus.doc} MNTCALFLU
Verifica qual é o calendário do funciONário quando usa turno
flutuante "MV_NGFLUT"

@param cCodFun: 	Código do FunciONário	| Obrigatório
@param dIni	: 	Data inicio do insumo	| Obrigatório
@param dFim	: 	Data fim do insumo	| Obrigatório

@author Tainã Alberto Cardoso
@since 24/06/2014
@versiON MP11
@return .T.
/*/
//----------------------------------------------------------------
Function MNTCALFLU( cCodFun, dIni, dFim )

	Local cCalend  := ''
	Local cAlsFlut := GetNextAlias()

	BeginSQL Alias cAlsFlut

		SELECT
			TP6.TP6_CALEND
		FROM
			%table:ST1% ST1
		INNER JOIN
			%table:TP4% TP4 ON
				TP4.TP4_FILIAL = %xFilial:TP4%  AND
				TP4.TP4_CODIGO = ST1.T1_EQUIPE AND
				TP4.%NotDel%
		INNER JOIN
			%table:TP6% TP6 ON
				TP6.TP6_FILIAL = %xFilial:TP6%  AND
				TP6.TP6_EQUIPE = TP4.TP4_CODIGO AND
				%exp:dIni% BETWEEN TP6.TP6_DTINI AND TP6.TP6_DTFIM AND
				%exp:dFim% BETWEEN TP6.TP6_DTINI AND TP6.TP6_DTFIM AND
				TP6.%NotDel%
		WHERE
			ST1.T1_FILIAL  = %xFilial:ST1% AND
			ST1.T1_CODFUNC = %exp:cCodFun% AND
			ST1.%NotDel%

	EndSQL

	If (cAlsFlut)->( !EoF() )

		cCalend := (cAlsFlut)->TP6_CALEND

	EndIf

	(cAlsFlut)->( dbCloseArea() )

Return cCalend

//----------------------------------------------------------------
/*/{Protheus.doc} MNTTRACCAT
Transfere C.C. na rotina ATFA060 do bem quando integrado ao
Ativo Fixo

@param cFilialCC 	: 	Código da Filial     	| Obrigatório
@param cCodBem    	: 	Codigo do bem        	| Obrigatório
@param dDataTrans	: 	Data da transferencia 	| Obrigatório
@param aVar       	:	Array com as seguintes informações
						[1] Centro de Custo
						[2] Correção MONetária
						[3] Depreciação
						[4] Correção MONetária depreciada
@param cHoraTrans   :   Hora da transferencia
@param [aFldExec], Array, [1] - Centro de Trabalho
						  [2] - Contador 1
						  [3] - Contador 2

@author Tainã Alberto Cardoso
@since 24/06/2014
@versiON MP11
@return .T.
/*/
//----------------------------------------------------------------
Function MNTTRACCAT(cFilialCC,cCodBem,dDataTrans,aVar,cHoraTrans, aFldExec )

	Local aArea 	:= GetArea()
	Local cFilOrig  := cFilialCC
	Local oDlg2
	Local oPainel01
	Local nOpcaX	:= 0
	Local lATFIntRM := IsInCallStack("ATFI012")
	Local lReturn   := .T.
	Local nFields   := 0

	Private aCusto
	Private nCONt1	   := 0
	Private nCONt2	   := 0
	Private nOpcx 	   := 0
	Private cCCUSTOQ   := aVar[1]
	Private cCTrab	   := Space( TamSx3( 'HB_CC' )[ 1 ] )
	Private lTIPOACOM  := .F.
	Private lTIPOACOM2 := .F.

	Default cHoraTrans := Time()
	Default aFldExec   := {}

	If !IsInCallStack("MNTA470") .And. !IsInCallStack("MNTA090")

		aCusto := NgFilTPN(cCodBem,dDataTrans,SubStr(Time(),1,5)) //Buscar o C.C. do bem na TPN

		// Se não houver alteração no centro de custo, não grava TPN
		If aCusto[2] != cCCUSTOQ 

			//Buscar os registro de cONtador
			dbSelectArea("ST9")
			dbSetOrder(1) // T9_FILIAL+T9_CODBEM
			If dbSeek(xFilial("ST9") + cCodbem )

				//Caso bem 'pertença' ao CONstrução Civil não transfere pelo ATF.
				If ST9->T9_CATBEM == "4" .And. GetNewPar( "MV_NGMNTCC", "N" ) == "S"
					MsgInfo(STR0825 + " " + STR0826, STR0074 )
					Return .F.
				EndIf

				If lReturn
					cDescBem := ST9->T9_NOME
					If ST9->T9_TEMCONT == "S"
						lTIPOACOM := .T.
					EndIf

					//Verica se o bem utiliza segundo contador
					dbSelectArea("TPE")
					dbSetOrder(1) // TPE_FILIAL+TPE_CODBEM
					If dbSeek(xFilial("ST9") + cCodbem )
						lTIPOACOM2 := TPE->TPE_SITUAC == "1"
					EndIf
				EndIf

			EndIf

			If lReturn
				If !lATFIntRM
					
					// Valida se o processo não é automatizado(ExecAuto)
					If !IsBlind()
						DEFINE MSDIALOG oDlg2 TITLE STR0599  FROM 0 , 0 To 160 , 360 Of oMainWnd Pixel //"Transferencia de Bens"

							oPainel01 := TPanel():New(00,00,,oDlg2,,,,,,0,100,.F.,.F.)
							oPainel01:Align := CONTROL_ALIGN_ALLCLIENT

							@ 10,05 SAY OemToAnsi(STR0471) SIZE 50,7 OF oPainel01 PIXEL //"Centro de Trabalho"
							@ 10,55 MSGET cCTrab SIZE 60,7 OF oPainel01 PIXEL F3 "SHBA" Valid fValCTrab() HASBUTTON

							@ 25,05 SAY OemToAnsi(STR0233) SIZE 37,7 OF oPainel01 PIXEL //"CONtador 1"
							@ 25,55 MSGET nCONt1 SIZE 040,7 OF oPainel01 PIXEL  Picture "@E 999,999,999" Valid CHKPOSLIM(cCodBem,nCONt1,1) .And. Positivo() When lTIPOACOM

							@ 40,05 SAY OemToAnsi(STR0600) SIZE 37,7 OF oPainel01 PIXEL //"CONtador 2"
							@ 40,55 MSGET nCONt2  SIZE 040,7 OF oPainel01 PIXEL Picture "@E 999,999,999" Valid CHKPOSLIM(cCodBem,nCONt2,2) .And. Positivo() when lTIPOACOM2

						ACTIVATE MSDIALOG oDlg2 Centered ON INIT EnchoiceBar(oDlg2,	{||nOpcaX := 1,If(fValCONt(cCodBem,dDataTrans),oDlg2:End() ,.F.)},{|| oDlg2:End()})

						If nOpcaX == 0
							cCTrab := ""
							nCONt1 := 0
							nCONt2 := 0
						EndIf

					Else

						nOpcaX := 1

						// Realiza inserção dos dados recebidos do ExecAuto(ATFA060) nos campos TPN_CTRAB, TPN_POSCON e TPN_POSCO2
						For nFields := 1 To Len( aFldExec )
							If nFields == 1
								If !Empty( aFldExec[ nFields, 1 ] )
									cCustTrab := Posicione( 'SHB', 1, xFilial( 'SHB' ) + aFldExec[ nFields, 1 ], 'HB_CC' )
									If !Empty( cCustTrab ) 
										If AllTrim( cCustTrab ) != AllTrim( cCCUSTOQ )
											AutoGrLog( STR1481 ) // "Centro de Trabalho nao pertence ao Centro de Custo."
											lReturn := .F.
											Exit
										Else
											cCTrab := aFldExec[ nFields, 1 ]
										EndIf
									Else
										AutoGrLog( STR1482 ) // "Centro de trabalho informado não existe."
										lReturn := .F.
										Exit
									EndIf
								Else
									AutoGrLog( STR1482 ) // "Centro de trabalho informado não existe."
									lReturn := .F.
									Exit
								EndIf

							ElseIf nFields == 2
								
								If lTIPOACOM .And. aFldExec[ nFields, 1 ] >= 0
								
									aReturn := CHKPOSLIM( cCodBem, aFldExec[ nFields, 1 ], 1,, .F. )
									
									If aReturn[ 1 ]
										nCONt1 := aFldExec[ nFields, 1 ]
									Else
										AutoGrLog( aReturn[ 2 ] )
										lReturn := .F.
										Exit
									EndIf

								EndIf

							Else
								If lTIPOACOM2 .And. aFldExec[ nFields, 1 ] >= 0
							
									aReturn := CHKPOSLIM( cCodBem, aFldExec[ nFields, 1 ], 2,, .F. )

									If aReturn[ 1 ]
										nCONt2 := aFldExec[ nFields, 1 ]
									Else
										AutoGrLog( aReturn[ 2 ] )
										lReturn := .F.
										Exit
									EndIf

								EndIf

							EndIf

						Next nFields
						
						If lReturn .And. ( lTIPOACOM .Or. lTIPOACOM2 )
							
							// Consistência contador 1
							If lTIPOACOM .And. nCONt1 > 0
								
								aReturn := NGCHKHISTO(cCodBem,dDataTrans,nCONt1,SubStr(Time(),1,5),1,,.F.)
								
								If !aReturn[ 1 ]
									AutoGrLog( aReturn[ 2 ] )
									lReturn := .F.
								EndIf
								
								If lReturn 
									
									aReturn := NGVALIVARD(cCodBem,nCONt1,dDataTrans,SubStr(Time(),1,5),1,.F.)
									
									If !aReturn[ 1 ]
										AutoGrLog( aReturn[ 2 ] )
										lReturn := .F.
									EndIf

								EndIf

							EndIf

							// Consistência contador 2
							If lReturn .And. lTIPOACOM2 .And. nCONt2 > 0
								
								aReturn := NGCHKHISTO(cCodBem,dDataTrans,nCONt2,SubStr(Time(),1,5),2,,.F.)
								
								If !aReturn[ 1 ]
									AutoGrLog( aReturn[ 2 ] )
									lReturn := .F.
								EndIf
								
								If lReturn 
									
									aReturn := NGVALIVARD(cCodBem,nCONt2,dDataTrans,SubStr(Time(),1,5),2,.F.)
									
									If !aReturn[ 1 ]
										AutoGrLog( aReturn[ 2 ] )
										lReturn := .F.
									EndIf

								EndIf

							EndIf

						EndIf

					EndIf
				Else
					If lTIPOACOM
						nCONt1 := NGACUMEHIS(ST9->T9_CODBEM,dDataTrans,SubStr(cHoraTrans,1,5),1,"E",,,.F.)[1]
					EndIf
					If lTIPOACOM2
						nCONt2 := NGACUMEHIS(ST9->T9_CODBEM,dDataTrans,SubStr(cHoraTrans,1,5),2,"E",,,.F.)[1]
					EndIf
				EndIf

				// Transfere o Centro de Custo do Bem se houver integracao
				If lReturn .And. GetMv("MV_NGMNTAT") $ "1#3"
				
					//----------------------------------------------------------------------
					// Implementação da classe NGMovBem para processo de movimentação de
					// Bem por Centro de Custo/Centro de Trabalho
					//----------------------------------------------------------------------
					oTPN := NGMovBem():New()
					oTPN:setOperatiON( 03 ) // Seta como operação do objeto: Inclusão
					If nOpcaX == 0
						oTPN:ableCONtador( .F. )
					Else
						If lTIPOACOM .And. nCONt1 > 0
							oTPN:ableCONtador( .T. )
						ELseIf lTIPOACOM2 .And. nCONt2 > 0
							oTPN:ableCONtador( .T. )
						Else
							oTPN:ableCONtador( .F. )
						EndIf
					EndIf

					//Atualiza a filial de Origem para criar nova TPN quando alterado o Ativo
					If IsInCallStack("AF012AGRV")
						cFilOrig := xFilial("SN3")
					EndIf

					// Atribuo valores para os campos do registro que será carregado (incluido)
					oTPN:setValue( "TPN_FILIAL",cFilOrig )
					oTPN:setValue( "TPN_CODBEM",cCodBem)
					oTPN:setValue( "TPN_DTINIC",dDataTrans)
					oTPN:setValue( "TPN_HRINIC",cHoraTrans)
					oTPN:setValue( "TPN_CCUSTO",aVar[1]   )
					oTPN:setValue( "TPN_CTRAB" ,cCTrab    )
					oTPN:setValue( "TPN_UTILIZ","U"       )
					oTPN:setValue( "TPN_POSCON",nCONt1	  )
					oTPN:setValue( "TPN_POSCO2",nCONt2	  )

					If !oTPN:valid()
						Help( " ",1,"NAO CONFORMIDADE",,oTPN:getErrorList()[1],3,1 )
						Return .F.
					Else
						oTPN:upsert() // Persiste os dados na base
					EndIf

					oTPN:Free()

				EndIf
			EndIf
		EndIf
	EndIf

	RestArea(aArea)

Return lReturn

//---------------------------------------------------------------------
/*{Protheus.doc} fValCONt
Valida a variação dia e o histórico dos cONtadores.(Teoricamente)

@param cCodBem - Cód. do Bem.
       dDataTrans - Dt. da Transferência.

@author NG Informática
@since
@use	 SIGAMNT
@return .T. - .F.
//---------------------------------------------------------------------
*/
Static Function fValCONt(cCodBem,dDataTrans)

	//CONsiste o reporter de cONtador1 e 2
	//CONtador 1
	If lTIPOACOM
		If nCONt1 > 0
		   If !NGCHKHISTO(cCodBem,dDataTrans,nCONt1,SubStr(Time(),1,5),1,,.T.)
		      Return .F.
		   EndIf
		   If !NGVALIVARD(cCodBem,nCONt1,dDataTrans,SubStr(Time(),1,5),1,.T.)
				Return .F.
	   		EndIf
		EndIf
	EndIf

	//CONtador 2
	If lTIPOACOM2
		If nCONt2 > 0
			If !NGCHKHISTO(cCodBem,dDataTrans,nCONt2,SubStr(Time(),1,5),2,,.T.)
				Return .F.
			EndIf
			If !NGVALIVARD(cCodBem,nCONt2,dDataTrans,SubStr(Time(),1,5),2,.T.)
				Return .F.
	   		EndIf
	   	EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*{Protheus.doc} fValCTrab
Valida o

@author NG Informática
@since
@use	 SIGAMNT
@return .T. - .F.
//---------------------------------------------------------------------
*/
Static Function fValCTrab()

	If !EMpty(cCTrab) .And. !EXISTCPO("SHB",cCTrab)
		Return .F.
	Else
		dbSelectArea("SHB")
		dbSetOrder(1)
		If dbSeek(xFilial("SHB")+cCTrab)
			If SHB->HB_CC <> cCCUSTOQ
				MsgInfo("Centro de trabalho nao pertence ao Centro de Custo.")
				Return .F.
			EndIf
		EndIf
	EndIf

Return .T.

//----------------------------------------------------------------
/*/{Protheus.doc} NGVALPGTS1()
Função que atualiza o valor do campo "TS1_VALPAG", pelo pagamento
de documentos obrigatórios por veículos pelo SIGAFIN;
@param:	cPrefxo	- Prefixo do Título.
			cNumTit	- Número do Título.
			cParcTit	- Parcela do Título.
			cTipoTit	- Tipo do Título.
			cVencto	- Data de Vencimento do Título.
			nValor		- Valor do Título.

@author:	ElyntON Fellipe Bazzo
@since:	27/09/2014
@versiON:	MP11
@return:	.T.
/*/
//----------------------------------------------------------------
Function NGVALPGTS1( cPrefxo,cNumTit,cParcTit,cTipoTit,cVencto,nValor )

	Local aArea := GetArea() //Salva o ambiente ativo.
	Local cDocumento //Variável utilizada no Seek.
	Local cAliasQr1 := GetNextAlias() //Cria o alias cAliasQr1, para carregar o resultado da query.
	Local cAliasQr2 := GetNextAlias() //Cria o alias cAliasQr2, para carregar o resultado da query.

	Local cPrefix1 := ""

	//Query que retorna Data/Prefixo/Tipo do título.
	cQuery := " SELECT E2_VENCTO,E2_PREFIXO,E2_TIPO FROM " + RetSQLName( "SE2" )
	cQuery += " WHERE E2_FATPREF = '"+cPrefxo+"'"
	cQuery += " AND E2_NUM = '"+cNumTit+"'"
	cQuery += " AND E2_PARCELA = '"+cParcTit+"'"
	cQuery += " AND E2_TIPO = '"+cTipoTit+"'"
	cQuery += " AND E2_VALOR = '"+cValToChar( nValor )+"'"
	cQuery += " AND D_E_L_E_T_ <> '*' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasQr1,.F.,.T. )

	cPrefix1	:= (cAliasQr1)->E2_PREFIXO //Prefixo.
	cTipoTit	:= (cAliasQr1)->E2_TIPO //Tipo do Título.
	(cAliasQr1)->(dbCloseArea()) //Fecha a área de trabalho corrente.

	//Query que retorna o código e número do documento, para verificar no Seek.
	cQuery := " SELECT TS1_DOCTO,TS1_NUMSE2 FROM " + RetSQLName( "TS1" )
	cQuery += " WHERE TS1_TIPO = '"+cTipoTit+"'"
	cQuery += " AND TS1_PREFIX = '"+cPrefix1+"'"
	cQuery += " AND TS1_NUMSE2 = '"+cNumTit+"'"
	cQuery += " AND D_E_L_E_T_ <> '*' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasQr2,.F.,.T. )

	cDocumento	:= (cAliasQr2)->TS1_DOCTO //Documento.
	cNumSE2	:= (cAliasQr2)->TS1_NUMSE2 //Número.
	(cAliasQr2)->(dbCloseArea()) //Fecha a área de trabalho corrente.

	dbSelectArea( "TS1" )
	dbSetOrder( 04 ) //"TS1_FILIAL+TS1_DOCTO+TS1_NUMSE2"
	If dbSeek( xFilial( "TS1" )+cDocumento+cNumSE2 )
		RecLock( "TS1",.F. )
		TS1->TS1_VALPAG += nValor
		MsUnLock( "TS1" )
	EndIf

	RestArea( aArea ) //Retorna o ambiente ativo.

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGINTMOB
Verifica se ha integracao com processo de Mobilidade.

@author Hugo R. Pereira
@since 30/11/2013
@versiON MP10
@return Boolean
/*/
//---------------------------------------------------------------------
Function NGINTMOB(cFntInteg)
Return FindFunction( cFntInteg ) .And. AllTrim( SuperGetMV( "MV_NGINTMB",.F.,"2" ) ) == "1"
//----------------------------------------------------------------
/*/{Protheus.doc} MntCheckCC()
Verifica se poderá ou não utilizar o Template CONstrução Civil

@author Pedro Henrique Soares de Souza
@since 01/07/2015

@return lRet Indica se poderá ou não utilizar o CONstrução Civil
/*/
//----------------------------------------------------------------
Function MntCheckCC(cRotina)

	Local lRet		:= .F.

	Default cRotina	:= ''
	
	If GetNewPar("MV_NGMNTCC","N") <> "S"
		ApMsgInfo( STR0641 ) //"Para utilizar esta rotina ?necess?io cONfigurar o par?etro MV_NGMNTCC - Template de CONstru?o Civil"
	Else
		lRet := .T.
	EndIf

Return lRet

//----------------------------------------------------------------
/*/{Protheus.doc} GERAOP
Função de geração de Ordem de Produção

@param cPROD     , Caracter, Código do produto.
@param nQTD      , Numérico, Quantidade do produto
@param cOs       , Caracter, Ordem de Serviço
@param dINI      , Data    , Data Inicio da O.P.
@param dFIM      , Data    , Data Fim da O.P.
@param cVLOC     , Caracter, Localização do Produto
@param cFil      , Caracter, Filial da O.P.
@param cCusto    , Caracter, Centro de Custo da O.P.
@param cObs      , Caracter, Observação da O.P.
@param lRetArray , Lógico  , Retorno via Array ou Lógico

@author	Tainã Alberto Cardoso ( Refeito )
@since 30/06/2016
@return Lógico/Array, conforme chamada com ou sem interface gráfica
/*/
//----------------------------------------------------------------
Function GERAOPNEW(cPROD,nQTD,cOS,dINI,dFIM,cVLOC,cFil,cCusto,cObs,nOpc,lRetArray)

	Local aMATA650      := {} //Array com os campos
	Local cUnidade := "", cSequenc := ""
	Local lDelSC2 := .F.
	//Variável para mudança do retorno quando chamado via JOB
	Local aTypeRet  := { .T., '' }
	Local lSX8BKP   := __lSX8
	Local cParam05  := ''
	Local lUsaPar05 := Type( 'MV_PAR05' ) != 'U'

	Private lMsErroAuto     := .F.

	Default cFil := xFilial("SC2")
	Default cVLOC := "", cObs := "", cCusto := ""
	Default nOpc := 3
	//Variável que define se apresentará mensagem de erro (com interface gráfica).
	Default lRetArray := .F.
	Default dFIM      := dDataBase

	__lSX8 := .F. //Travativa para nao confirmar SXE ou SXF de outra tabela

	//Busca Local e Unidade do Produto
	dbSelectArea("SB1")
	dbSetOrder(1)
	If dbSeek( xFilial("SB1") + cProd )
		If Empty(cVLOC)
			cVLOC := SB1->B1_LOCPAD
		EndIf
		cUnidade := SB1->B1_UM
	EndIf

	//Busca a Sequencia da O.P.
	dbSelectArea("SC2")
	dbSetOrder(1) //C2_FILIAL+C2_NUM+C2_ITEM
	If dbSeek( xFilial("SC2") + cOS + "OS" )

		While !EoF() .And. xFilial("SC2") == SC2->C2_FILIAL  .And. SC2->C2_NUM == cOS .And. SC2->C2_ITEM == "OS"

			If Alltrim(cPROD) == Alltrim(SC2->C2_PRODUTO) .And. Alltrim(SC2->C2_PRODUTO) == Alltrim(NGProdMNT("M")[1])
				Return IIf( !lRetArray, aTypeRet[1], aTypeRet )
			ElseIf nOpc == 5 .And. Alltrim(cPROD) == Alltrim(SC2->C2_PRODUTO)
				lDelSC2 := .T.
				cSequenc := SC2->C2_SEQUEN
				Exit
			EndIf

			cSequenc := SC2->C2_SEQUEN
			dbSelectArea("SC2")
			dbSkip()
		End

	EndIf

	If Empty(cSequenc)
		cSequenc := "001"
	ElseIf nOpc == 3
		cSequenc := PADR(Soma1(cSequenc),3)
	EndIf

	//Inclusao
	If nOpc == 3
		aMata650  := {  {'C2_FILIAL'   ,cFil      ,NIL},;  //Filial
		                {'C2_PRODUTO'  ,cPROD     ,NIL},;  //Produto
		                {'C2_QUANT'    ,nQTD      ,NIL},;  //Quantidade
		                {'C2_ITEM'     ,"OS"      ,NIL},;  //Item - Default "OS" para Ordem de Serviço do MNT
		                {'C2_NUM'      ,cOS       ,NIL},;  //Numero da O.S.
		                {'C2_SEQUEN'   ,cSequenc  ,NIL},;  //Sequencia - Default "001" para Ordem de Serviço do MNT
		                {'C2_LOCAL'    ,cVLOC     ,NIL},;  //Local do Produto
		                {'C2_UM'       ,cUnidade  ,NIL},;  //Unidade Produto
		                {'C2_DATPRI'   ,dINI      ,NIL},;  //Data Inicio
		                {'C2_DATPRF'   ,dDataBase ,NIL},;  //Data Fim
		                {'C2_EMISSAO'  ,dINI      ,NIL},;  //Data de Emissão
		                {'C2_PRIOR'    ,"500"     ,NIL},;  //Prioridade - Default "500" para Ordem de Serviço do MNT
		                {'C2_DESTINA'  ,"E"       ,NIL},;  //Destinação da O.P. - Default "E" = Estoque
		                {'C2_DATAJI'   ,dINI      ,NIL},;  //Data Ajustada Inicial
		                {'C2_DATAJF'   ,dFIM      ,NIL},;  //Data Ajustada Final
		                {'C2_SEQPAI'   ,"000"     ,NIL},;  //Sequencia da O.P. pai - Default "000"
		                {'C2_BATCH'    ,"S"       ,NIL},;  //Flag do proc. batch - Default "S"
		                {'C2_CC'       ,cCusto    ,NIL},;  //Centro de custo
		                {'C2_OBS'      ,cObs      ,NIL},;  //Observação da O.P.
		                {'C2_STATUS'   ,"U"       ,NIL},;  //Status da O.P. - Default "U" = Suspendida
						{'AUTBACKX8'   ,.F.		  ,Nil}}   //Utilizado para não dar RollBack

		                //+---------------------------------------------------------------+
		                //| Ponto de Entrada para inclusão e alteração de campos passados |
		                //| na geração de Ordem de Produção                               |
		                //+---------------------------------------------------------------+
		                If ExistBlock("NGMNTOP")
		                	aMata650 := ExecBlock("NGMNTOP",.F.,.F.,aMata650)
		                EndIf

		If lUsaPar05

			cParam05 := MV_PAR05

		EndIf

		msExecAuto({|x,Y| Mata650(x,Y)},aMata650,nOpc)

		If lUsaPar05

			MV_PAR05 := cParam05

		EndIf

	ElseIf nOpc == 5 .And. lDelSC2

		dbSelectArea("SC2")
		dbSetOrder(1)
		If dbSeek( xFilial("SC2") + cOs + "OS" + cSequenc )

			aMata650 :=  {  {'C2_SEQUEN' 	, C2_SEQUEN , NIL},;
				            {'C2_ITEM'   	, C2_ITEM    , NIL},;
				            {'C2_NUM'	  	, C2_NUM     , NIL},;
				            {'C2_PRODUTO'   , C2_PRODUTO ,NIL}}

			msExecAuto({|x,Y| Mata650(x,Y)},aMata650,nOpc)
		EndIf

	EndIf

	If lMsErroAuto
		// Apresenta MostraErro() em tela somente quando o retorno for lógico
		// e haja interface com o usuário
		If !(lRetArray .And. IsBlind())
			MostraErro()
			aTypeRet[1] := .F.
		Else
			cError := MostraErro( GetSrvProfString("Startpath","") , ) // Armazena mensagem de erro na raíz.
			//Array contendo o resultado do MostraErro
			aTypeRet := { .F. , cError }
		EndIf
	EndIf

	__lSX8 := lSX8BKP  //Travativa para nao confirmar SXE ou SXF de outra tabela

Return IIf( lRetArray, aTypeRet, aTypeRet[1] )


//--inicio--SS 027441 //
//---------------------------------------------------------------------
/*/{Protheus.doc} NGVERINCBA
Função para verificação de inconsistências de base.

@author Maicon André Pinheiro
@since  13/05/2016
@version MP11 e MP12
@Return Nil
/*/
//---------------------------------------------------------------------
 Function NGVERINCBA(aParam)

	Local cQrySTC    := ""
	Local cQrySTZ    := ""
	Local cQryST9    := ""
	Local cQrySTC2   := ""
	Local cQryST92   := ""
	Local cLineTxt   := ""
	Local cAliasQry  := ""
	Local cAmbiente  := ""
	Local cCntEmail  := ""

	Local lInconSTC1 := .F.
	Local lInconSTZ  := .F.
	Local lInconST91 := .F.
	Local lInconSTC2 := .F.
	Local lInconST92 := .F.
	Local lIncons    := .F.

	Local aCampoTab  := {}

	Local cBarras    := IIf(isSRVunix(), '/', '\')
	Local cRootPath  := AllTrim(GetSrvProfString("RootPath", cBarras))
	Local cStartPath := AllTrim(GetSrvProfString("StartPath", cBarras))

	Private cMailMsg   := ""
	Private nVersaoINC := "1" // Incrementar a cada alteração de validação das Query.
	Private cArqDiag   := cStartPath + 'diagnostico.ngi'
	Private cCamiCompl := cRootPath  + cStartPath + 'diagnostico.ngi'
	Private cCodEmp    := aParam[1]
	Private cCodFil    := aParam[2]

	//Abre tabelas necessarias
	If !(Type("oMainWnd")=="O")

		If cCodEmp == '-1' .Or. cCodFil == '-1'
			Help("",1,STR0041,,STR0690 + CRLF + STR0691 ,3,0) //"Atenção" ## "Configuração invalida de Filial"###"Verificar Empresa/Filial nos Jobs"
			Return .F.
		EndIf

		RPCSetType(3)

		//Abre empresa/filial
		WfPrepENV(cCodEmp,cCodFil)
	EndIf

	cAliasQry := GetNextAlias()
	cCntEmail := GetNewPar("MV_RELACNT","")
	cAmbiente := "19 - " + STR0695 //"Manutenção de Ativos"

	If !File(cArqDiag) 	//Verifica se o arquivo de diagnostico existe, caso não exista cria o mesmo.
		nArqDiag := fCreate('diagnostico.ngi', FC_NORMAL)
	Else
		nArqDiag := fOpen(cArqDiag, FO_READWRITE + FO_SHARED)
		fSeek(nArqDiag, 0, FS_END)         // Posiciona no fim do arquivo
	EndIf

	//Escreve o cabeçalho de abertura do arquivo.
	fWritDiag(nArqDiag,"Abertura","")

	//Inicio validação STC_X_STZ
	cQrySTC := fMntaQuery("STC_X_STZ")
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQrySTC),cAliasQry, .F., .T.)

	dbSelectArea(cAliasQry)
	dbGoTop()
	While !EoF()

		lInconSTC1 := .T.
		cLineTxt   += "[STC - STZ] " + STR0696 + "|" + AllTrim((cAliasQry)->TC_CODBEM) + "|" +; // "Registro "
					  AllTrim((cAliasQry)->TC_COMPONE) + " " + STR0697 + Chr(13) // "não possui registro correspondente na tabela STZ."

		dbSelectArea(cAliasQry)
		dbSkip()
	End

	If lInconSTC1
		lIncons   := .T.
		aCampoTab := {cCodEmp,cCodFil,cAmbiente,"STC",STR0698} // "Há registros que não correspondem na tabela STZ."
		fWritDiag(nArqDiag,"Email",cLineTxt,aCampoTab)         //Escreve as linhas das tabela do email, informando o erro.
	EndIf

	(cAliasQry)->(dbCloseArea())
	//Fim validação STC_X_STZ

	//Inicio validação STZ_X_STC
	cAliasQry := GetNextAlias()
	cQrySTZ   := fMntaQuery("STZ_X_STC")
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQrySTZ),cAliasQry, .F., .T.)

	dbSelectArea(cAliasQry)
	dbGoTop()
	While !EoF()

		lInconSTZ := .T.
		cLineTxt  += "[STZ - STC] " + STR0696 + "|" + AllTrim((cAliasQry)->TZ_CODBEM) + "|" +; // "Registro "
			          AllTrim((cAliasQry)->TZ_BEMPAI) + STR0699 + Chr(13)                      // " o registro da tabela STZ não foi encontrado na STC."

		dbSelectArea(cAliasQry)
		dbSkip()
	End

	If lInconSTZ
		lIncons   := .T.
		aCampoTab := {cCodEmp,cCodFil,cAmbiente,"STZ",STR0700} // "Há registros que não correspondem na tabela STC."
		fWritDiag(nArqDiag,"Email",cLineTxt,aCampoTab)         // Escreve as linhas das tabela do email, informando o erro.
	EndIf

	(cAliasQry)->(dbCloseArea())
	//Fim validação STC_X_STZ

	//Inicio validação ST9_X_STC
	cAliasQry := GetNextAlias()
	cQryST9   := fMntaQuery("ST9_X_STC")
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQryST9),cAliasQry, .F., .T.)

	dbSelectArea(cAliasQry)
	dbGoTop()
	While !EoF()

		lInconST91 := .T.
		cLineTxt   += "[ST9 - STC] " + STR0696 + "|" + AllTrim((cAliasQry)->T9_CODBEM) +; // "Registro "
			          STR0701 + Chr(13) // " o cadastro do bem indica que o mesmo está contido em uma estrutura, porém o registro não foi encontrado na STC "

		dbSelectArea(cAliasQry)
		dbSkip()
	End

	If lInconST91
		lIncons   := .T.
		aCampoTab := {cCodEmp,cCodFil,cAmbiente,"ST9",STR0702} // "Há registros que não correspondem na tabela STC."
		fWritDiag(nArqDiag,"Email",cLineTxt,aCampoTab)         // Escreve as linhas das tabela do email, informando o erro.
	EndIf

	(cAliasQry)->(dbCloseArea())
	//Fim validação ST9_X_STC

	//Inicio validação STC_X_ST9
	cAliasQry := GetNextAlias()
	cQrySTC2  := fMntaQuery("STC_X_ST9")
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQrySTC2),cAliasQry, .F., .T.)

	dbSelectArea(cAliasQry)
	dbGoTop()
	While !EoF()

		lInconSTC2 := .T.
		cLineTxt   += "[STC - ST9] " + STR0696 + "|" + AllTrim((cAliasQry)->TC_CODBEM) + "|" +; // "Registro"
					  AllTrim((cAliasQry)->TC_COMPONE) + STR0703 + Chr(13) // " Registro da tabela STC, não encontrado ou não informado com estrutura na ST9 "

		dbSelectArea(cAliasQry)
		dbSkip()
	End

	If lInconSTC2
		lIncons   := .T.
		aCampoTab := {cCodEmp,cCodFil,cAmbiente,"STC",STR0704} // "Há registros que não correspondem na tabela ST9."
		fWritDiag(nArqDiag,"Email",cLineTxt,aCampoTab)         // Escreve as linhas das tabela do email, informando o erro.
	EndIf

	(cAliasQry)->(dbCloseArea())
	//Fim validação STC_X_ST9

	//Inicio validação ST9_X_SN3
	cAliasQry := GetNextAlias()
	cQryST92  := fMntaQuery("ST9_X_SN3")
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQryST92),cAliasQry, .F., .T.)

	dbSelectArea(cAliasQry)
	dbGoTop()
	While !EoF()

		lInconST92 := .T.
		cLineTxt   += "[ST9 - SN1] " + STR0696 + "|" + AllTrim((cAliasQry)->T9_CODIMOB) +; // "Registro"
			           STR0705 + Chr(13)                                                   // " Centro de Custo da tabela ST9 incompativel com o da SN1 "

		dbSelectArea(cAliasQry)
		dbSkip()
	End

	If lInconST92
		lIncons   := .T.
		aCampoTab := {cCodEmp,cCodFil,cAmbiente,"STC",STR0706} // "Há registros que não correspondem na tabela SN1."
		fWritDiag(nArqDiag,"Email",cLineTxt,aCampoTab)         // Escreve as linhas das tabela do email, informando o erro.
	EndIf

	(cAliasQry)->(dbCloseArea())
	//Fim validação ST9_X_SN3

	If !lIncons
		cLineTxt := STR0707 + Chr(13) // "Nenhuma inconformidade."
	EndIf

	fWritDiag(nArqDiag,"Corpo",cLineTxt)
	fWritDiag(nArqDiag,"Encerramento",STR0708) // "Diagnóstico concluído com sucesso. "
	fClose(nArqDiag)

	If lIncons //Caso exista inconsistencia envia email ao cliente.
		lEmailRet := NGSendMail(,cCntEmail + Chr(59),,,OemToAnsi(STR0709),,cMailMsg) // "Inconformidades na Base"
	EndIf
 Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fMntaQuery
Monta as Query que fazem as consultas de inconsistências.

@author Maicon André Pinheiro
@since  13/05/2016
@version MP11 e MP12
@Return Nil
/*/
//---------------------------------------------------------------------
 Function fMntaQuery(cTipSQL)

	Local cQuery := ""

	Do Case
		Case cTipSQL == "STC_X_STZ"

			cQuery := "	SELECT STC.TC_FILIAL,  STC.TC_CODBEM, STC.TC_COMPONE "
			cQuery += "	  FROM " + RetSqlName("STC") + " STC "
			cQuery += "	 WHERE STC.TC_FILIAL = "     + ValToSql(cCodFil)
			cQuery += "	   AND D_E_L_E_T_    = '' "
			cQuery += "	   AND NOT EXISTS "
			cQuery += "	   ( "
			cQuery += "	       SELECT DISTINCT 1 "
			cQuery += "	         FROM " + RetSqlName("STZ") + " STZ "
			cQuery += "	        WHERE STZ.TZ_FILIAL  = STC.TC_FILIAL  "
			cQuery += "	   		  AND STZ.TZ_CODBEM  = STC.TC_COMPONE "
			cQuery += "	   		  AND STZ.TZ_BEMPAI  = STC.TC_CODBEM  "
			cQuery += "	   		  AND STZ.TZ_LOCALIZ = STC.TC_LOCALIZ "
			cQuery += "	   		  AND STZ.TZ_TIPOMOV = 'E' "
			cQuery += "	          AND D_E_L_E_T_     = '' "
			cQuery += "	   ) "
			cQuery := ChangeQuery(cQuery)

		Case cTipSQL == "STZ_X_STC"

			cQuery := " SELECT STZ.TZ_FILIAL, STZ.TZ_CODBEM, STZ.TZ_BEMPAI "
			cQuery += "   FROM " + RetSqlName("STZ") + " STZ "
			cQuery += "  WHERE STZ.TZ_FILIAL  = "    + ValToSql(cCodFil)
			cQuery += "    AND STZ.TZ_TIPOMOV = 'E' "
			cQuery += "	   AND D_E_L_E_T_     = '' "
			cQuery += "    AND NOT EXISTS "
			cQuery += "    ( "
			cQuery += "        SELECT DISTINCT 1 "
			cQuery += "          FROM " + RetSqlName("STC") + " STC "
			cQuery += "         WHERE STC.TC_FILIAL  = STZ.TZ_FILIAL  "
			cQuery += "		      AND STC.TC_COMPONE = STZ.TZ_CODBEM  "
			cQuery += "    		  AND STC.TC_CODBEM  = STZ.TZ_BEMPAI  "
			cQuery += "    		  AND STC.TC_LOCALIZ = STZ.TZ_LOCALIZ "
			cQuery += "	          AND D_E_L_E_T_     = '' "
			cQuery += "    ) "
			cQuery := ChangeQuery(cQuery)

		Case cTipSQL == "ST9_X_STC"

			cQuery += " SELECT ST9.T9_FILIAL, ST9.T9_CODBEM "
			cQuery += "   FROM " + RetSqlName("ST9") + " ST9 "
			cQuery += "  WHERE T9_FILIAL  = "        + ValToSql(cCodFil)
			cQuery += "    AND T9_ESTRUTU = 'S' "
			cQuery += "	   AND D_E_L_E_T_ = '' "
			cQuery += "    AND NOT EXISTS "
			cQuery += "    ( "
			cQuery += "        SELECT DISTINCT 1 "
			cQuery += "          FROM " + RetSqlName("STC") + " STC "
			cQuery += "         WHERE STC.TC_FILIAL  = ST9.T9_FILIAL "
			cQuery += "    		  AND STC.TC_COMPONE = ST9.T9_CODBEM "
			cQuery += "	          AND D_E_L_E_T_     = '' "
			cQuery += "    ) "
			cQuery := ChangeQuery(cQuery)

		Case cTipSQL == "STC_X_ST9"

			cQuery += " SELECT STC.TC_FILIAL, STC.TC_CODBEM, STC.TC_COMPONE "
			cQuery += "   FROM " + RetSqlName("STC") + " STC "
			cQuery += "  WHERE STC.TC_FILIAL  = "    + ValToSql(cCodFil)
			cQuery += "	   AND D_E_L_E_T_     = '' "
			cQuery += "    AND NOT EXISTS "
			cQuery += "    ( "
			cQuery += " 		SELECT DISTINCT 1 "
			cQuery += " 		  FROM " + RetSqlName("ST9") + " ST9 "
			cQuery += " 		 WHERE ST9.T9_FILIAL  = STC.TC_FILIAL "
			cQuery += " 		   AND ST9.T9_CODBEM  = STC.TC_COMPONE "
			cQuery += " 		   AND ST9.T9_ESTRUTU = 'S' "
			cQuery += "	           AND D_E_L_E_T_     = '' "
			cQuery += "    ) "
			cQuery := ChangeQuery(cQuery)

		Case cTipSQL == "ST9_X_SN3"

			cQuery += " SELECT ST9.T9_FILIAL, ST9.T9_CODIMOB "
			cQuery += "   FROM " + RetSqlName("ST9") + " ST9 "
			cQuery += "  WHERE ST9.T9_FILIAL  = " + ValToSql(cCodFil)
			cQuery += "    AND ST9.T9_CODIMOB <> '' "
			cQuery += "	   AND D_E_L_E_T_     = '' "
			cQuery += "    AND NOT EXISTS "
			cQuery += "    ( "
			cQuery += "     SELECT DISTINCT 1 "
			cQuery += "       FROM " + RetSqlName("SN3") + " SN3 "
			cQuery += "      WHERE SN3.N3_FILIAL+SN3.N3_CBASE+SN3.N3_ITEM+SN3.N3_CUSTBEM = ST9.T9_FILIAL+ST9.T9_CODIMOB+ST9.T9_CCUSTO "
			cQuery += "	       AND D_E_L_E_T_ = '' "
			cQuery += "    ) "
			cQuery := ChangeQuery(cQuery)

	EndCase

 Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} fWritDiag
Função para fazer as validações de escrita do arquivo de Diagnostico.

@author Maicon André Pinheiro
@since  13/05/2016
@version MP11 e MP12
@Return Nil
/*/
//---------------------------------------------------------------------
 Function fWritDiag(nArqDiag,cTipo,cLineTxt,aCampoTab)

	Local cStartTime := dToC( Date() ) + ' - ' + Time()
	Local cLineWri   := cLineTxt

	Default aCampoTab := {}

	Do Case
		Case cTipo == "Abertura"

			// Abertura do arquivo de diagnostico
			cLineWri := "[" + STR0711 + nVersaoINC + "] " + STR0712 + AllTrim(Upper(cCodEmp)) + " - " + STR0713 + ": " + AllTrim(Upper(cCodFil)) + STR0714 + cStartTime + Chr(13) // "Diagnóstico NG "##"Processo iniciado no Grupo: "##"Empresa"##" em "

			//Abertura do Arquivo HTML/Email
			cMailMsg := "<html>"
			cMailMsg += "<head>"
			cMailMsg += "<meta http-equiv='Content-Language' content='pt-br'>"
			cMailMsg += "<meta http-equiv='Content-Type' content='text/html; charset=iso-8859-1'>"
			cMailMsg += "<title>" + STR0715 + "</title>" // "Inconsistência"
			cMailMsg += "</head>"
			cMailMsg += "<body bgcolor='#FFFFFF'>"
			cMailMsg += "<p><b><font face='Arial'> " + STR0716 + "</font></b></p>" // "Inconsistência na Base de dados"
			cMailMsg += STR0717 + cCamiCompl + "<br> <br>"                         // "Foram encontrados registros inconsistentes na base de dados. Para melhor conferência, foi criado o arquivo de diagnostico que se encontra em: "
			cMailMsg += "<div align='left'>"
			cMailMsg += "<table border=0 WIDTH=100% cellpadding='2'>"
			cMailMsg += "<tr>"
			cMailMsg += "   <td bgcolor='#C0C0C0' align='left' width='10%' ><b><font face='Arial' size='2'>" + STR0718 + " </font></b></td>" //"Grupo de Empresa"
			cMailMsg += "   <td bgcolor='#C0C0C0' align='left' width='10%' ><b><font face='Arial' size='2'>" + STR0719 + " </font></b></td>" //"Filial"
			cMailMsg += "   <td bgcolor='#C0C0C0' align='left' width='20%' ><b><font face='Arial' size='2'>" + STR0720 + " </font></b></td>" //"Ambiente"
			cMailMsg += "   <td bgcolor='#C0C0C0' align='left' width='15%' ><b><font face='Arial' size='2'>" + STR0721 + " </font></b></td>" //"Tabela"
			cMailMsg += "   <td bgcolor='#C0C0C0' align='left' width='45%' ><b><font face='Arial' size='2'>" + STR0722 + " </font></b></td>" //"Descrição"
			cMailMsg += "</tr>"

		Case cTipo == "Encerramento"
			cLineWri := STR0723 + Chr(13) + Chr(13) // "Diagnóstico concluído com sucesso."

			//Encerramento do Arquivo HTML/Email
			cMailMsg += "</body>"
			cMailMsg += "</html>"

		Case cTipo == "Email"
			cMailMsg += "<tr>"
			cMailMsg += "    <td bgcolor='#EEEEEE' align='left' width='10%' ><font face='Arial' size='1'>" + aCampoTab[1] + "</font></td>" // Grupo de Empresa.
			cMailMsg += "    <td bgcolor='#EEEEEE' align='left' width='10%' ><font face='Arial' size='1'>" + aCampoTab[2] + "</font></td>" // Filial.
			cMailMsg += "    <td bgcolor='#EEEEEE' align='left' width='20%' ><font face='Arial' size='1'>" + aCampoTab[3] + "</font></td>" // Ambiente.
			cMailMsg += "    <td bgcolor='#EEEEEE' align='left' width='15%' ><font face='Arial' size='1'>" + aCampoTab[4] + "</font></td>" // Tabela.
			cMailMsg += "    <td bgcolor='#EEEEEE' align='left' width='45%' ><font face='Arial' size='1'>" + aCampoTab[5] + "</font></td>" // Descrição.
			cMailMsg += "</tr>"

	EndCase

	If cTipo != "Email"
		fWrite(nArqDiag,cLineWri)
	EndIf

 Return .T.
//---fim----SS 027441 //

//---------------------------------------------------------------------
/*/{Protheus.doc} fRetCondOp
Verifica a operação a partir do código do Operador.

@author Pedro Henrique Soares de Souza
@since 26/08/2014
@version 1.0

@param cCondOp Opção do Operador

@return cRet Operação
/*/
//---------------------------------------------------------------------
Static Function fRetCondOp( cCondOp )

	Local cRet := Space(TAMSX3('TPC_CONDOP')[1])

	Do Case
		Case cCondOp == "I "
			cRet := ' == '

		Case cCondOp == "< "
			cRet := ' < '

		Case cCondOp == "> "
			cRet := ' > '

		Case cCondOp == "<I"
			cRet := ' <= '

		Case cCondOp == ">I"
			cRet := ' >= '

		Case cCondOp == "<>"
			cRet := ' <> '
	EndCase

Return cRet

//--------------------------------------------------------------------
/*/{Protheus.doc} NGCRIALAPD()

Cria os layouts padrões para a importação de abastecimento unificado.

@author Maicon André Pinheiro
@since 28/06/2016

@param nVerOld - Versão antiga da execução da função
	   nVerAtu - Versão atual da função

@return
/*/
//--------------------------------------------------------------------
Function NGCRIALAPD(nVerOld,nVerAtu)

	Local cFilTQ7 := xFilial("TQ7")
	Local cFilTQ8 := xFilial("TQ8")

	Default nVerOld := 0
	Default nVerAtu := 1

	If AliasInDic('TQ7') .And. AliasInDic('TQ8') .And. nVerOld < nVerAtu

		//Cria Layout Conv. CTF
		//Cabeçalho
		fMNTCITQ7(cFilTQ7,'000001',STR0812,'TR6','2','4','1','2','1','2','2')

		//Corpo
		dbSelectArea("TQ8")
		dbSetOrder(1)
		If !dbSeek(cFilTQ8 + '000001')
			fMNTCITQ8(cFilTQ8,'000001', 1,'INDICE'    ,'N',0,9 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001', 2,'TR6_NUMABA','C',0,12,0,'')
			fMNTCITQ8(cFilTQ8,'000001', 3,'VEICODIGO' ,'N',0,9 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001', 4,'TPREG'     ,'N',0,5 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001', 5,'BOMBA'     ,'N',0,5 ,0,'fGrvCpoGen("TR6_BOMBA","C")')
			fMNTCITQ8(cFilTQ8,'000001', 6,'REDE'      ,'N',0,5 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001', 7,'TR6_POSTO' ,'C',0,5 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001', 8,'FROTA'     ,'N',0,5 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001', 9,'TR6_TIPCOM','C',0,1 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001',10,'UVE'       ,'N',0,4 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001',11,'TR6_PLACA' ,'C',0,7 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001',12,'MOTORISTA' ,'C',0,20,0,'fGrvCpoGen("TR6_CPFMOT","C")')
			fMNTCITQ8(cFilTQ8,'000001',13,'TR6_KMABAS','N',0,7 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001',14,'QUANTIDADE','N',0,10,0,'fGrvCpoGen("TR6_QTDCOM","N")')
			fMNTCITQ8(cFilTQ8,'000001',15,'PU'        ,'N',0,9 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001',16,'TR6_VLCOMB','N',0,9 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001',17,'TR6_VLTOT' ,'N',0,14,0,'')
			fMNTCITQ8(cFilTQ8,'000001',18,'DTHR_ABAST','C',0,20,0,'fMontaDTHR()')
			fMNTCITQ8(cFilTQ8,'000001',19,'DATADEB'   ,'D',0,10,0,'')
			fMNTCITQ8(cFilTQ8,'000001',20,'ABTDATACRE','D',0,10,0,'')
			fMNTCITQ8(cFilTQ8,'000001',21,'ABTARQUIVO','C',0,15,0,'')
			fMNTCITQ8(cFilTQ8,'000001',22,'DIST_PERC_','N',0,9 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001',23,'COMB_TOTAL','N',0,10,0,'')
			fMNTCITQ8(cFilTQ8,'000001',24,'STAT_AB_VE','C',0,1 ,0,'')
			fMNTCITQ8(cFilTQ8,'000001',25,'TR6_NABANT','C',0,15,0,'')
			fMNTCITQ8(cFilTQ8,'000001',26,'POSTOFANTA','C',0,18,0,'')
			fMNTCITQ8(cFilTQ8,'000001',27,'POSTOCIDAD','C',0,40,0,'')
			fMNTCITQ8(cFilTQ8,'000001',28,'CGC'       ,'C',0,20,0,'fGrvCpoGen("TR6_CNPJ","C")')
		EndIf

		//Cria Layout Conv. Ticket
		//Cabeçalho
		fMNTCITQ7(cFilTQ7,'000002',STR0813,'TR6','1','','1','2','2','2','2')

		//Corpo
		dbSelectArea("TQ8")
		dbSetOrder(1)
		If !dbSeek(cFilTQ8 + '000002')
			fMNTCITQ8(cFilTQ8,'000002', 1,'NUMERO'    ,'N',  1,10, 10,'f716BsAbst()')
			fMNTCITQ8(cFilTQ8,'000002', 2,'NOM_MERC'  ,'C', 11,30, 40,'f716COM()')
			fMNTCITQ8(cFilTQ8,'000002', 3,'TR6_PLACA' ,'C', 41, 8, 48,'')
			fMNTCITQ8(cFilTQ8,'000002', 4,'NOM_MOT'   ,'C', 49,40, 88,'fBscMot(1)')
			fMNTCITQ8(cFilTQ8,'000002', 5,'TR6_KMABAS','N', 89,10, 98,'')
			fMNTCITQ8(cFilTQ8,'000002', 6,'QUANTIDADE','N', 99,11,109,'fGrvCpoGen("TR6_QTDCOM","N")')
			fMNTCITQ8(cFilTQ8,'000002', 7,'TR6_VLCOMB','N',110,15,124,'')
			fMNTCITQ8(cFilTQ8,'000002', 8,'VAL_TOTAL' ,'N',125,18,142,'fGrvCpoGen("TR6_VLTOT","N")')
			fMNTCITQ8(cFilTQ8,'000002', 9,'TR6_DTABAS','D',143,10,152,'')
			fMNTCITQ8(cFilTQ8,'000002',10,'NOM_FANTAS','C',153,24,176,'')
			fMNTCITQ8(cFilTQ8,'000002',11,'CID_ESTAB ','C',177,25,201,'')
			fMNTCITQ8(cFilTQ8,'000002',12,'TR6_CNPJ'  ,'C',202,14,215,'')
			fMNTCITQ8(cFilTQ8,'000002',13,'TR6_HRABAS','C',216, 5,220,'')
		EndIf

		//Cria Layout Conv. GoodCard
		//Cabeçalho
		fMNTCITQ7(cFilTQ7,'000003',STR0814,'TR6','1','','2','2','1','1','2')

		//Corpo
		dbSelectArea("TQ8")
		dbSetOrder(1)
		If !dbSeek(cFilTQ8 + '000003')
			fMNTCITQ8(cFilTQ8,'000003', 1,'ID_REG'    ,'C',  1,  3,   3 ,'f716BsAbst()')
			fMNTCITQ8(cFilTQ8,'000003', 2,'NUM_SEQ'   ,'N',  4,  4,   7 ,''            )
			fMNTCITQ8(cFilTQ8,'000003', 3,'TR6_DTABAS','D',  8,  8,  15 ,''            )
			fMNTCITQ8(cFilTQ8,'000003', 4,'TR6_VLTOT' ,'N', 16, 11,  26 ,''            )
			fMNTCITQ8(cFilTQ8,'000003', 5,'NUM_CART'  ,'C', 27, 16,  42 ,''            )
			fMNTCITQ8(cFilTQ8,'000003', 6,'TR6_QTDCOM','N', 43,  6,  48 ,''            )
			fMNTCITQ8(cFilTQ8,'000003', 7,'TR6_TIPCOM','C', 49,  2,  50 ,''            )
			fMNTCITQ8(cFilTQ8,'000003', 8,'SERVICO'   ,'C', 51, 30,  80 ,''            )
			fMNTCITQ8(cFilTQ8,'000003', 9,'TP_ABAST'  ,'N', 81, 11,  91 ,''            )
			fMNTCITQ8(cFilTQ8,'000003',10,'TR6_PLACA' ,'C', 92,  7,  98 ,''            )
			fMNTCITQ8(cFilTQ8,'000003',11,'TR6_KMABAS','N', 99,  7, 105 ,''            )
			fMNTCITQ8(cFilTQ8,'000003',12,'TR6_CNPJ'  ,'C',106, 14, 119 ,''            )
			fMNTCITQ8(cFilTQ8,'000003',13,'NOME_ESTAB','C',120, 50, 169 ,''            )
			fMNTCITQ8(cFilTQ8,'000003',14,'INFO_AD01' ,'C',170, 30, 199 ,''            )
			fMNTCITQ8(cFilTQ8,'000003',15,'INFO_AD02' ,'C',200, 30, 229 ,''            )
			fMNTCITQ8(cFilTQ8,'000003',16,'INFO_AD03' ,'C',230, 30, 259 ,''            )
			fMNTCITQ8(cFilTQ8,'000003',17,'MATRIC'    ,'C',260, 10, 269 ,'fBscMot(2)'  )
			fMNTCITQ8(cFilTQ8,'000003',18,'TR6_HRABAS','C',270,  5, 274 ,''            )
			fMNTCITQ8(cFilTQ8,'000003',19,'TR6_VLCOMB','N',275, 10, 284 ,''            )
		EndIf

		//Cria Layout GTFrota Abast
		//Cabeçalho
		fMNTCITQ7(cFilTQ7,'000004', STR0815,'TR6','1','','1','2','1','2','2',.T.)

		//Corpo
		fMNTCITQ8( cFilTQ8,'000004', 1,'TR6_DTABAS','D', 1,  10, 10, '', .T.)
		fMNTCITQ8( cFilTQ8,'000004', 2,'HORA'      ,'C', 12, 8,  19, 'fGrvCpoGen("TR6_HRABAS","H")', .T.)
		fMNTCITQ8( cFilTQ8,'000004', 3,'USUARIO'   ,'C', 21, 14, 34, '', .T.)
		fMNTCITQ8( cFilTQ8,'000004', 4,'TR6_PLACA' ,'C', 36, 14, 49, '', .T.)
		fMNTCITQ8( cFilTQ8,'000004', 5,'TR6_KMABAS','N', 51,  7, 57, '', .T.)
		fMNTCITQ8( cFilTQ8,'000004', 6,'TR6_QTDCOM','N', 59, 10, 68, '', .T.)
		fMNTCITQ8( cFilTQ8,'000004', 7,'KM_PER'    ,'C', 70, 10, 79, '', .T.)
		fMNTCITQ8( cFilTQ8,'000004', 8,'OBSERVACAO','C', 81, 10, 90, 'fGrvCpoGen("TR6_CODOBS","C")', .T.)
		fMNTCITQ8( cFilTQ8,'000004', 9,'TERMINAL'  ,'C', 92,  4, 95, '', .T.)
		fMNTCITQ8( cFilTQ8,'000004',10,'BOMBA'	   ,'C', 97,  1, 97, 'f716VldGTF(.T.)', .T.)
		fMNTCITQ8( cFilTQ8,'000004',11,'EXTRA1'    ,'N', 99,  7,110, '', .T.)
		fMNTCITQ8( cFilTQ8,'000004',12,'EXTRA2'    ,'C',112, 40,142, '', .T.)

		//Cria Layout GTFrota Transferencia
		
		// Cabeçalho
		fMNTCITQ7( cFilTQ7, '000005', STR0816, 'TR6', '2', '4', '1', '2', '1', '2', '2', .T. )

		// Corpo
		fMNTCITQ8( cFilTQ8, '000005', 1 , 'TR6_DTABAS', 'D', 0, 10, 0, ''                               , .T. )
		fMNTCITQ8( cFilTQ8, '000005', 2 , 'HORA'      , 'C', 0, 8 , 0, 'fGrvCpoGen( "TR6_HRABAS", "H" )', .T. )
		fMNTCITQ8( cFilTQ8, '000005', 3 , 'USUARIO'   , 'C', 0, 14, 0, ''                               , .T. )
		fMNTCITQ8( cFilTQ8, '000005', 4 , 'TR6_PLACA' , 'C', 0, 8 , 0, ''                               , .T. ) 
		fMNTCITQ8( cFilTQ8, '000005', 5 , 'TR6_KMABAS', 'N', 0, 10, 0, ''                               , .T. )
		fMNTCITQ8( cFilTQ8, '000005', 6 , 'TR6_QTDCOM', 'N', 0, 7 , 0, ''                               , .T. )
		fMNTCITQ8( cFilTQ8, '000005', 7 , 'KM_PER'    , 'C', 0, 10, 0, ''                               , .T. )
		fMNTCITQ8( cFilTQ8, '000005', 8 , 'OBSERVACAO', 'C', 0, 10, 0, 'fGrvCpoGen( "TR6_CODOBS", "C" )', .T. )
		fMNTCITQ8( cFilTQ8, '000005', 9 , 'TERMINAL'  , 'C', 0, 2 , 0, ''                               , .T. )
		fMNTCITQ8( cFilTQ8, '000005', 10, 'BOMBA'	  , 'C', 0, 1 , 0, 'f716VldGTF(.T.)'                , .T. )
		fMNTCITQ8( cFilTQ8, '000005', 11, 'HORIMETRO' , 'C', 0, 7 , 0, ''                               , .T. )
		fMNTCITQ8( cFilTQ8, '000005', 12, 'INFO_EXT_1', 'C', 0, 7 , 0, ''                               , .T. )
		fMNTCITQ8( cFilTQ8, '000005', 13, 'INFO_EXT_2', 'C', 0, 7 , 0, ''                               , .T. )
		fMNTCITQ8( cFilTQ8, '000005', 14, 'INFO_EXT_3', 'C', 0, 7 , 0, ''                               , .T. )
		fMNTCITQ8( cFilTQ8, '000005', 15, 'INFO_EXT_4', 'C', 0, 7 , 0, ''                               , .T. )
		fMNTCITQ8( cFilTQ8, '000005', 16, 'INFO_EXT_5', 'C', 0, 7 , 0, ''                               , .T. )
		fMNTCITQ8( cFilTQ8, '000005', 17, 'SITUACAO'  , 'C', 0, 1 , 0, 'fVldGTFTrn()'                   , .T. )

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fMNTCITQ7

Faz a inclusão na TQ7 dos valores padrões.

@author Maicon André Pinheiro
@since 13/06/2016
@version 1.0
@return .T.
/*/
//---------------------------------------------------------------------
Function fMNTCITQ7(cFilTQ7,cCodLay,cDesLay,cTabela,cTipArq,cSepard,cForDta,cSepDec,cIndCab,cIndRod,cBloq,lCanModify)

	Local lCanRecord := .T.

	Default lCanModify := .F.

	dbSelectArea("TQ7")
	dbSetOrder(1)
	If !dbSeek(cFilTQ7 + cCodLay)
		RecLock("TQ7",.T.) // vai incluir
	ElseIf lCanModify
		RecLock("TQ7",.F.) // vai modificar 
	Else
		lCanRecord := .F. // não deve fazer nada pois o registro já existe e não pode ser modificado
	EndIf

	If lCanRecord
		TQ7->TQ7_FILIAL := cFilTQ7
		TQ7->TQ7_CODLAY := cCodLay
		TQ7->TQ7_DESLAY := cDesLay
		TQ7->TQ7_TABELA := cTabela
		TQ7->TQ7_TIPARQ := cTipArq
		TQ7->TQ7_SEPARD := cSepard
		TQ7->TQ7_FORDTA := cForDta
		TQ7->TQ7_SEPDEC := cSepDec
		TQ7->TQ7_INDCAB := cIndCab
		TQ7->TQ7_INDROD := cIndRod
		TQ7->TQ7_MSBLQL := cBloq
		MsUnLock("TQ7")
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fMNTCITQ8

Faz a inclusão na TQ8 dos valores padrões.

@author Maicon André Pinheiro
@since 13/06/2016
@version 1.0
@return .T.
/*/
//---------------------------------------------------------------------
Function fMNTCITQ8(cFilTQ8,cCodLay,nSeq,cCpoTab,cTipo,nPosIni,nPosTam,nPosFim,cFuncao, lCanModify)

	Default lCanModify := .F.

	dbSelectArea("TQ8")
	dbSetOrder(1)
	If !dbSeek(cFilTQ8 + cCodLay + cValToChar(nSeq))
			RecLock("TQ8",.T.) // vai incluir novo registro
	Else 
		RecLock("TQ8",.F.) // vai modificar o registro
	EndIf
	
	TQ8->TQ8_FILIAL := cFilTQ8
	TQ8->TQ8_CODLAY := cCodLay
	TQ8->TQ8_SEQUEN := nSeq
	TQ8->TQ8_CPOTAB := cCpoTab
	TQ8->TQ8_TIPO   := cTipo
	TQ8->TQ8_POSINI := nPosIni
	TQ8->TQ8_TAMARQ := nPosTam
	TQ8->TQ8_POSFIM := nPosFim
	TQ8->TQ8_FUNCAO := cFuncao
	MsUnLock("TQ8")

Return .T.

//------------------------------------------------------------------------------
/*/{Protheus.doc} MNTRemovBtn
Indica quais botões devem ser removidos do ações relacionadas

@param cRotina
@author NG Informática Ltda.
@since 01/01/2015
@version P12
@return Array - aRemoveBtn
/*/
//------------------------------------------------------------------------------
Function MNTRemovBtn(cRotina)

	Local aRemoveBtn := {}

	If cRotina == 'MNTA080'

		aAdd( aRemoveBtn , 'MNTSEGU' )
		aAdd( aRemoveBtn , 'MNTA080SUH' )
		aAdd( aRemoveBtn , 'MNTA080HST' )
		aAdd( aRemoveBtn , 'NGACOPLAD' )

		If .Not. AliasInDic("TV5")
			aAdd( aRemoveBtn , 'MNTA688' )
		EndIf

	EndIf

Return aRemoveBtn

//-------------------------------------------------------------------------
/*/{Protheus.doc} NGAJUSBASE
Função responsável por inicar uma Thread para realizar ajustes ao entrar
no modulo de manutenção de ativos.

Funções com Versão igual a 0 é que devem sempre ser executadas.

@author  Tainã Cardoso
@since   31/08/2017
@version undefined

@param cEmpAnt,    Caractér, Código Empresa
@param cFilAnt,    Caractér, Código Filial
@param cCodUser,   Caractér, Código Usuário
@param cModMntGfr, Caractér, Modulo MNT ou GFR

@type function
/*/
//-------------------------------------------------------------------------
Function NGAJUSBASE(cEmpAnt,cFilAnt,cCodUser,cModMntGfr)

	Local cVerOld   := "0"
	Local cVerAtu   := "0"
	Local nX        := 0
	Local nArqAtu   := 0
	Local nPosit    := 0
	Local nPos      := 0
	Local nOk       := 0
	Local lGravArq  := .F.
	Local cString   := ""
	Local cArqFun   := 'mntatu.ngi'
	Local aAux      := {}
	Local aFunctOld := {}
	Local aFunction := { { 'NGTQCTQD', '3' }, { 'CriaProd', '2' }, { 'NGCRIALAPD', '2' }, { 'NGCRIAUNID', '0' }, { 'fCriaPlano', '0' }, { 'MNTINDIC', '0' }, {'fSEQRELAJST', '0'}  }

	Default cCodUser := ""

	RPCSetType(3) //Nao utiliza licensa

	//Abre empresa/filial/modulo/arquivos
	RPCSetEnv( cEmpAnt, cFilAnt, "", "", cModMntGfr )

	While nOk == 0
		// Caso exista arquivo, porém esteja no modelo antigo, realiza a sua exclusão.
		fMntAtu(cArqFun, Len(aAux), Len(aFunction))

		If !File(cArqFun) 	//Verifica se o arquivo de atualização existe, caso não exista cria o mesmo.

			nArqAtu := fCreate(cArqFun) // Cria arquivo.

			fWrite(nArqAtu,cEmpAnt + cFilAnt )
			For nX := 1 To Len(aFunction)
				fWrite(nArqAtu, "#" + aFunction[nX,1] + "-" + "0" )
			Next nX

			fWrite(nArqAtu,chr(13)+chr(10))

			fClose(nArqAtu) // Fecha arquivo.

		EndIf

		// Abre o arquivo
		nArqAtu := FT_FUse(cArqFun)

		// Posiciona na primeira linha
		FT_FGoTop()

		While !FT_FEOF()
			cLine  := FT_FReadLn()

			// Salva na primeira posição do array a Empresa e Filial, na segunda posição as funções.
			aAdd( aFunctOld , {SubStr(cLine,1,At( "#", cLine )-1), SubStr(cLine,At( "#", cLine ),Len(cLine))})

			FT_FSKIP()
		End
		// Fecha o arquivo
		FT_FUSE()

		// Busca a empresa e filial.
		nPosit := aScan( aFunctOld,{ |x| AllTrim( x[1] ) == AllTrim( cEmpAnt+cFilAnt ) } )

		If nPosit == 0 // Caso ainda não possua a Empresa e Filial no arquivo.

			For nX := 1 To Len(aFunction)
				cString += "#" + aFunction[nX,1] + "-" + "0"
			Next nX

			aAdd( aFunctOld , {cEmpAnt + cFilAnt,cString})

			lGravArq := .T. // Determina que ocorrerá gravação no TXT.
			cString  := "" // Limpa variável.

			nPosit := aScan( aFunctOld,{ |x| AllTrim( x[1] ) == AllTrim( cEmpAnt+cFilAnt ) } )

		EndIf

		If nPosit > 0 // Caso ja encontrou no arquivo a Empresa e Filial.
			aAux := StrTokArr(aFunctOld[nPosit,2],'#') // Quebra o valor conforme os marcadores.

			// Adiciona as novas funções 
			For nX := 1 To Len( aFunction )
				If aScan( aAux, {|x| aFunction[ nX, 1 ]  $ x } )  == 0
					aAdd( aAux, aFunction[ nX, 1 ] + "-0")
				EndIf
			Next nX

			For nX := 1 To Len(aAux)

				If Len(aAux) < Len(aFunction)
					Loop
				Else
					nOk := 1

					cFuncao := SubStr( aAux[nX],1,At("-", aAux[nX] ) - 1 )
					cVerOld := SubStr( aAux[nX],At("-", aAux[nX] )+1,Len(aAux[nX]) )

					nPos := aScan( aFunction,{ |x| AllTrim( x[1] ) == AllTrim( cFuncao ) } )

					If nPos > 0
						cVerAtu := aFunction[nPos,2] // Busca versão atual.

						If aFunction[nPos,1] == "MNTINDIC"
							&( aFunction[nPos,1] + '(' + cVerOld + ',' + cVerAtu + ', "' + cCodUser + '")' )
						Else
							&( aFunction[nPos,1] + '(' + cVerOld + ',' + cVerAtu + ')' )
						EndIf

						cString += "#" + aFunction[nPos,1] + "-" + cVerAtu

						If !lGravArq .And. cVerOld < cVerAtu // Caso ocorreu alguma mudança de versão.
							lGravArq := .T. // Determina que será alterado o arquivo.
						EndIf
					EndIf
				EndIf

			Next nX

			If !Empty(cString) .And. lGravArq
				aFunctOld[nPosit,2] := cString
			EndIf

		EndIf
	End

	If lGravArq // Determina que será gravado o arquivo novamente.

		fClose(nArqAtu) // Fecha arquivo.

		FErase(cArqFun) // Realiza a exclusão do arquivo.

		nArqAtu := fCreate(cArqFun) // Cria o arquivo novo.

		For nX := 1 To Len(aFunctOld)
			fWrite(nArqAtu, aFunctOld[nX,1] + aFunctOld[nX,2]  )
			fWrite(nArqAtu,chr(13)+chr(10))
		Next nX

	EndIf

	fClose(nArqAtu) // Fecha o arquivo.

	RpcClearEnv()

Return .T.

//-------------------------------------------------------------------------
/*/{Protheus.doc} fCriaPlano
Função responsável por inicarcriar os Planos padrao do MNT
@author Tainã Cardoso
@since 01/09/2017

@param nVerOld - Versão antiga da execução da função
	   nVerAtu - Versão atual da função

@version undefined
@type function
/*/
//-------------------------------------------------------------------------
Static Function fCriaPlano(nVerOld,nVerAtu)

	Default nVerOld := 0
	Default nVerAtu := 1

	CriaPlano('000000',STR0026) //"PLANO DE O.S. CORRETIVAS"
	CriaPlano('000001',STR0027) //"PLANO DE O.S. MANUAL"

	NGGTARPADRA("0",STR0017)

Return .T.

//------------------------------------------------------------------------------
/*/{Protheus.doc} MNTMinTwi
Gatilha valor inicial do campo TQS_TWI quando adicionado Desenho ao cadastro
do pneu.

@author  Eduardo Mussi
@since	 18/10/2017
@example Usado no Gatilho do campo TQS_DESENH. MNTA083/MNTA998
@version P12
@param 	 cDesenho - Desenho do Pneu - Obrigatório
@return	 Irá retornar valor TWI cadastrado no desenho, se não, irá retorna 0
/*/
//------------------------------------------------------------------------------
Function MNTMinTwi(cDesenho)

	//Variavel para retorno do TWI
	Local nTwi	  := 0

	//Valor TWI cadastrado no desenho do pneu
	Local nTwiTQU := 0

	Default cDesenho := ""

	If !Empty(cDesenho)
		//Busca Limite minimo do TWI definido no desenho do pneu.
		nTwiTQU := NGSEEK("TQU",cDesenho, 1, 'TQU_TWI')
		If nTwiTQU > 0
			nTwi := nTwiTQU
		EndIf
	EndIf

Return nTwi

//------------------------------------------------------------------------------
/*/{Protheus.doc} MNTAtuSX6
Função de Release para alterações de contéudo de parâmetros. (SX6)
Alterções centralizadas no MNTUtil, pois como a alteração é por release, e muda
a função a cada nova release, para que se mude apenas uma vez e replique em todos
os lugares.

@author  Maicon André Pinheiro
@since	 07/02/2018
@version P12
@param 	 cParam   - C - Nome do parâmetro
         cConteud - C - Novo conteúdo do parâmetro.
@return	 True
/*/
//------------------------------------------------------------------------------
Function MNTAtuSX6(cParam, cConteud)

	//Pega a release do protheus Ex: 12.1.017
	Local cVersRPO := GetRPORelease()
	Local cENGSX6  := ''

	If cVersRPO < '12.1.023'

		//Monta a função de engenharia que irá alterar o conteúdo do parâmetro. O padrão é ENGSX6+Release.
		//Ex: P12.1.17 == ENGSX6117
		cENGSX6  := "ENGSX6" + SubSTr(cVersRPO,4,1) + SubSTr(cVersRPO,7,2)

		&cENGSX6.(cParam,cConteud)

	EndIf

Return .T.
//------------------------------------------------------------------------------
/*/{Protheus.doc} fValidEta
Validações gerais de etapa

@author Alexandre Santos
@since 07/03/2018

@param 	nOPCx, Numerico , Opção selecionada em tela.
@return lRet , Lógico	, Valor que garante se o registro é válido.
/*/
//------------------------------------------------------------------------------
Static Function fValidEta()
	Local lRet := .T.

	If !Empty(M->TQ_ETAPA)
		lRet := NGSTQETA(M->TQ_ETAPA,.T.)
	Else
		MsgAlert(STR0857, STR1114) //Atenção##Favor informar o campo etapa.
		lRet := .F.
	EndIf

	If ExistBlock("MNTUTIL1")
		ExecBlock("MNTUTIL1",.F.,.F.)
	EndIf

	dbSelectArea("STQ")
	dbSetOrder(1)
	If dbSeek(xFilial("STQ") + STJ->TJ_ORDEM + STJ->TJ_PLANO + M->TQ_TAREFA + M->TQ_ETAPA) .And. lRet
		MsgAlert(STR0857, STR0074) //Atenção##Etapa já cadastrada, deve ser informado outra etapa.
		lRet := .F.
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} NGPROCEF3
Cria um gatilho no valid da tela de Etapas de O.S feita a mão

@author  Vitor Bonet
@since   15/05/2018
@version P12
@param   cAlias, caracter, nome da tabela de busca, Obrigatório
@param   cCampo, caracter, nome do campo que faz a busca, Obrigatório
/*/
//-------------------------------------------------------------------
Function NGPROCEF3( cAlias, cCampo )

	If ( cAlias == "ST5" .Or. cAlias == "TT9" ) .And. AllTrim( cCampo ) == '0'
		M->TQ_NOMTARE := STR0017 // "Sem Especificação de Tarefa"
	Else
		If cAlias == "ST5"
			M->TQ_NOMTARE := Posicione("ST5",1,xFilial("ST5")+cCampo,"T5_DESCRIC")

		ElseIf cAlias == "TT9"
			M->TQ_NOMTARE := Posicione("TT9",1,xFilial("TT9")+cCampo,"TT9_DESCRI")

		ElseIf cAlias == "TPA"
			M->TQ_NOMETAP := Posicione("TPA",1,xFilial("TPA")+cCampo,"TPA_DESCRI")
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTINDIC
Funcao que carregas o array com todos os indicadores do MNT
conforme parametro NGMNTFR

@author Guilherme Freudenburg
@since 31/08/2018

@param nVerOld,      Numérico, Versão antiga da execução da função
@param nVerAtu,      Numérico, Versão atual da função
@param [cCodUsrAtu], Caracter, Código do Usário

@version 1.0
@return Nil Nulo
/*/
//---------------------------------------------------------------------
Function MNTINDIC(nVerOld, nVerAtu, cCodUsrAtu)

	Local aIndTZ1 := {} // Classificação dos Indicadores.
	Local aIndTZ2 := {} // Varáveis.
	Local aIndTZ3 := {} // Parâmetros das Varáveis.
	Local aIndTZ4 := {} // Tipos de Parâmetro.
	Local aIndTZ5 := {} // Indicadores (Fórmulas).
	Local aIndTZ6 := {} // Variáveis por Fórmula.
	Local aIndTZ7 := {} // Parametros Fixos por Indicador.
	Local aIndSAH := {} // Unidades de Medida.
	Local aIndTZ9 := {} // Indicadores Gráficos.
	Local aIndTZB := {} // Painéis de Indicadores.
	Local aAltInd := {} // Nome de indicadores que serão alterados.

	Local aValores   := {} // Valores do indicador.
	Local aCores     := {} // Cores do indicador.
	Local aLegenda   := {} // Leganda padrão do indicador.
	Local aIndsRelac := {} // Relacionamento de indicadores com o modelo gráfico.
	Local dDataAtual := dDataBase // Data Atual.
	Local cHoraAtual := SubStr(Time(),1,5) // Hora Atual.
	Local cAuxPeriod := CRLF + STR1127 // "Adequado para período de 6 meses (180 dias)."

	// Parâmetros do Sistema
	Local lGFrotas  := NGVERUTFR() // Verifica a utilização de Frotas.
	Local lFacilit  := MNTINTFAC() // Verifica a utilização de Facilites.
	Local lRPORel17 := GetRPORelease() <= '12.1.017' // Verifica a versão do release atual.
	Local lRet      := .T.
	Local cMod   	:= CValToChar(nModulo)

	Default nVerOld := 0
	Default nVerAtu := 1
	Default cCodUsrAtu := If(Empty(RetCodUsr()),"000000",RetCodUsr())

	dbSelectArea("TZ1")
	dbSetOrder(1)
	If lRet .And. !dbSeek(xFilial("TZ1") + cMod )

		fWriteVer( '0' )

		If AliasInDic("TZ5")

			//--------------------------------------------------
			// TZ1 - Classificação dos Indicadores
			//--------------------------------------------------
			If lGFrotas
				aAdd(aIndTZ1,{cMod,"01",STR1128}) // "Abastecimento"
				aAdd(aIndTZ1,{cMod,"02",STR1129}) // "Pneus"
				aAdd(aIndTZ1,{cMod,"03",STR1130}) // "Multas"
				aAdd(aIndTZ1,{cMod,"04",STR1131}) // "Sinistros"
				aAdd(aIndTZ1,{cMod,"05",STR1132}) // "Documentos"
				aAdd(aIndTZ1,{cMod,"06",STR1133}) // "Frota Geral"
				aAdd(aIndTZ1,{cMod,"07",STR1134}) // "Oficina"
			Else
				aAdd(aIndTZ1,{cMod,"01",STR1135}) // "Desempenho"
				aAdd(aIndTZ1,{cMod,"02",STR1136}) // "Mão-de-Obra"
				aAdd(aIndTZ1,{cMod,"03",STR1137}) // "Custos/Controle Materiais"
			EndIf

			If lFacilit // Facilities
				aAdd(aIndTZ1,{cMod,If(!lGFrotas,"04","08"),STR1138}) // "Facilities"
			EndIf

			//--------------------------------------------------
			// TZ2 - Variáveis (Funções)
			//--------------------------------------------------
			aAdd(aIndTZ2,{cMod,"MNTV001","1","MNTV001",STR1139,STR1140+STR1141+STR1142+STR1143}) //"Tempo de Entre Falhas"
			aAdd(aIndTZ2,{cMod,"MNTV002","1","MNTV002",STR1144,STR1145}) //"Quant. Total de Corretivas"
			aAdd(aIndTZ2,{cMod,"MNTV003","1","MNTV003",STR1146,STR1167}) //"Tempo de Reparo das O.S. Corretivas"
			aAdd(aIndTZ2,{cMod,"MNTV006","1","MNTV006",STR1147,STR1168}) //"Número Total de Manut. Preventivas"
			aAdd(aIndTZ2,{cMod,"MNTV007","1","MNTV007",STR1148,STR1169}) //"Horas Tot. Manut. Preventivas"
			aAdd(aIndTZ2,{cMod,"MNTV008","1","MNTV008",STR1149,STR1170}) //"Homem Hora Trab. em Manutenção"
			aAdd(aIndTZ2,{cMod,"MNTV009","1","MNTV009",STR1150,STR1171}) //"Homem Hora da Manutenção"
			aAdd(aIndTZ2,{cMod,"MNTV010","1","MNTV010",STR1151,STR1172}) //"Homem Hora Estimada"
			aAdd(aIndTZ2,{cMod,"MNTV011","1","MNTV011",STR1152,STR1173}) //"Homem Hora Disponível no Período"
			aAdd(aIndTZ2,{cMod,"MNTV012","1","MNTV012",STR1153,STR1174}) //"Homem Hora Realizado"
			aAdd(aIndTZ2,{cMod,"MNTV013","1","MNTV013",STR1154,STR1175}) //"Homem Hora Prevista"
			aAdd(aIndTZ2,{cMod,"MNTV014","1","MNTV014",STR1155,STR1176}) //"Homem Hora em Preventiva"
			aAdd(aIndTZ2,{cMod,"MNTV015","1","MNTV015",STR1156,STR1177}) //"Homem Hora Trabalho em Manutenção"
			aAdd(aIndTZ2,{cMod,"MNTV016","1","MNTV016",STR1157,STR1178}) //"Homem Hora Trabalho Corretivas"
			aAdd(aIndTZ2,{cMod,"MNTV017","1","MNTV017",STR1158,STR1179+STR1180}) //"Custo de Manut. por Unid.Produção"
			aAdd(aIndTZ2,{cMod,"MNTV018","1","MNTV018",STR1159,STR1181}) //"Custo Homem Hora Tot. Manut. Preventiva"
			aAdd(aIndTZ2,{cMod,"MNTV019","1","MNTV019",STR1160,STR1182}) //"Custo Tot.das Manutenções"
			aAdd(aIndTZ2,{cMod,"MNTV031","1","MNTV031",STR1161,STR1183}) //"Etapas da Manutenção"
			aAdd(aIndTZ2,{cMod,"MNTV032","1","MNTV032",STR1162,STR1184}) //"Etapas Executadas"
			aAdd(aIndTZ2,{cMod,"MNTV033","1","MNTV033",STR1163,STR1185}) //"Quant. Total Corretivas entre Falhas"
			aAdd(aIndTZ2,{cMod,"MNTV034","1","MNTV034",STR1164,STR1186}) //"Qtde Solicitações de Serviço"
			aAdd(aIndTZ2,{cMod,"MNTV035","1","MNTV035",STR1165,STR1187}) //"Qtde Solicitações com OS Relacionadas"
			aAdd(aIndTZ2,{cMod,"MNTV036","1","MNTV036",STR1166,STR1188}) //"Quantidade de OS por Status"

			If !lRPORel17 // Caso seja uma versão superior a release 12.1.17
				// Indicadores Mundiais (NGKPI)
				aAdd(aIndTZ2,{cMod,"MNTV042","1","MNTV042",STR1189,STR1195})
				aAdd(aIndTZ2,{cMod,"MNTV043","1","MNTV043",STR1190,STR1196})
				aAdd(aIndTZ2,{cMod,"MNTV044","1","MNTV044",STR1191,STR1197})
				aAdd(aIndTZ2,{cMod,"MNTV045","1","MNTV045",STR1192,STR1198})
				aAdd(aIndTZ2,{cMod,"MNTV046","1","MNTV046",STR1193,STR1199})
				aAdd(aIndTZ2,{cMod,"MNTV047","1","MNTV047",STR1194,STR1200})
			EndIf

			If lGFrotas
				aAdd(aIndTZ2,{cMod,"MNTV020","1","MNTV020",STR1201                 ,STR1214                  }) //"Custo de Abastecimento"
				aAdd(aIndTZ2,{cMod,"MNTV021","1","MNTV021",STR1202                 ,STR1215                  }) //"Custo Total de Pneus"
				aAdd(aIndTZ2,{cMod,"MNTV022","1","MNTV022",STR1203                 ,STR1216                  }) //"Custo Total de Multas"
				aAdd(aIndTZ2,{cMod,"MNTV023","1","MNTV023",STR1204                 ,STR1217                  }) //"Custo Total com Sinistros"
				aAdd(aIndTZ2,{cMod,"MNTV024","1","MNTV024",STR1205                 ,STR1218                  }) //"Custo Total de Documentos"
				aAdd(aIndTZ2,{cMod,"MNTV025","1","MNTV025",STR1206                 ,STR1219+STR1220, STR1221 }) //"Custo Total com Reformas de Pneus"
				aAdd(aIndTZ2,{cMod,"MNTV026","1","MNTV026",STR1207                 ,STR1222                  }) //"Quantidade Total Rodada"
				aAdd(aIndTZ2,{cMod,"MNTV028","1","MNTV028",STR1208                 ,STR1223                  }) //"Quantidade Total de Litros Utilizada"
				aAdd(aIndTZ2,{cMod,"MNTV029","1","MNTV029",STR1209                 ,STR1224                  }) //"Pontos Totais Perdidos no Período"
				aAdd(aIndTZ2,{cMod,"MNTV030","1","MNTV030",STR1210                 ,STR1225                  }) //"Quantidade Total de Motoristas"
				aAdd(aIndTZ2,{cMod,"MNTV037","1","MNTV037",STR1211+" ("+STR1212+")",STR1226                  }) //"Quantidade Total Rodada"
				aAdd(aIndTZ2,{cMod,"MNTV041","1","MNTV041",STR1213                 ,STR1227                  }) //"Quantidade de Aditivo"
			EndIf

			If lFacilit // Facilities
				aAdd(aIndTZ2,{cMod,"MNTV038","1","MNTV038",STR1228,""}) //"Quant. S.S.'s Atendidas no Prazo"
				aAdd(aIndTZ2,{cMod,"MNTV039","1","MNTV039",STR1229,""}) //"Quant. S.S.'s Ecerr./Cance."
				aAdd(aIndTZ2,{cMod,"MNTV040","1","MNTV040",STR1230,""}) //"Quant. S.S.'s Dist. Fora do Prazo"
			EndIf

			//--------------------------------------------------
			// TZ3 - Parâmetros das Variáveis
			//--------------------------------------------------
			aAdd(aIndTZ3,{cMod,"MNTV001","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV001","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV001","003","DE_BEM"     })
			aAdd(aIndTZ3,{cMod,"MNTV001","004","ATE_BEM"    })
			aAdd(aIndTZ3,{cMod,"MNTV001","005","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV001","006","ATE_CCUSTO" })
			aAdd(aIndTZ3,{cMod,"MNTV001","007","DE_CENTRA"  })
			aAdd(aIndTZ3,{cMod,"MNTV001","008","ATE_CENTRA" })
			aAdd(aIndTZ3,{cMod,"MNTV001","009","CON_CALEND" })
			aAdd(aIndTZ3,{cMod,"MNTV001","010","CON_ANTDPS" })

			aAdd(aIndTZ3,{cMod,"MNTV002","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV002","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV002","003","DE_BEM"     })
			aAdd(aIndTZ3,{cMod,"MNTV002","004","ATE_BEM"    })
			aAdd(aIndTZ3,{cMod,"MNTV002","005","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV002","006","ATE_CCUSTO" })
			aAdd(aIndTZ3,{cMod,"MNTV002","007","DE_CENTRA"  })
			aAdd(aIndTZ3,{cMod,"MNTV002","008","ATE_CENTRA" })

			aAdd(aIndTZ3,{cMod,"MNTV003","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV003","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV003","003","DE_BEM"     })
			aAdd(aIndTZ3,{cMod,"MNTV003","004","ATE_BEM"    })
			aAdd(aIndTZ3,{cMod,"MNTV003","005","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV003","006","ATE_CCUSTO" })
			aAdd(aIndTZ3,{cMod,"MNTV003","007","DE_CENTRA"  })
			aAdd(aIndTZ3,{cMod,"MNTV003","008","ATE_CENTRA" })

			aAdd(aIndTZ3,{cMod,"MNTV006","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV006","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV006","003","DE_BEM"     })
			aAdd(aIndTZ3,{cMod,"MNTV006","004","ATE_BEM"    })
			aAdd(aIndTZ3,{cMod,"MNTV006","005","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV006","006","ATE_CCUSTO" })
			aAdd(aIndTZ3,{cMod,"MNTV006","007","DE_CENTRA"  })
			aAdd(aIndTZ3,{cMod,"MNTV006","008","ATE_CENTRA" })

			aAdd(aIndTZ3,{cMod,"MNTV007","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV007","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV007","003","DE_BEM"     })
			aAdd(aIndTZ3,{cMod,"MNTV007","004","ATE_BEM"    })
			aAdd(aIndTZ3,{cMod,"MNTV007","005","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV007","006","ATE_CCUSTO" })
			aAdd(aIndTZ3,{cMod,"MNTV007","007","DE_CENTRA"  })
			aAdd(aIndTZ3,{cMod,"MNTV007","008","ATE_CENTRA" })

			aAdd(aIndTZ3,{cMod,"MNTV008","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV008","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV008","003","DE_AREA"    })
			aAdd(aIndTZ3,{cMod,"MNTV008","004","ATE_AREA"   })

			aAdd(aIndTZ3,{cMod,"MNTV009","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV009","002","ATE_DATA"   })

			aAdd(aIndTZ3,{cMod,"MNTV010","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV010","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV010","003","DE_AREA"    })
			aAdd(aIndTZ3,{cMod,"MNTV010","004","ATE_AREA"   })
			aAdd(aIndTZ3,{cMod,"MNTV010","005","DE_FUNCI"   })
			aAdd(aIndTZ3,{cMod,"MNTV010","006","ATE_FUNCI"  })

			aAdd(aIndTZ3,{cMod,"MNTV011","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV011","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV011","003","DE_AREA"    })
			aAdd(aIndTZ3,{cMod,"MNTV011","004","ATE_AREA"   })
			aAdd(aIndTZ3,{cMod,"MNTV011","005","DE_FUNCI"   })
			aAdd(aIndTZ3,{cMod,"MNTV011","006","ATE_FUNCI"  })

			aAdd(aIndTZ3,{cMod,"MNTV012","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV012","002","ATE_DATA"   })

			aAdd(aIndTZ3,{cMod,"MNTV013","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV013","002","ATE_DATA"   })

			aAdd(aIndTZ3,{cMod,"MNTV014","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV014","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV014","003","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV014","004","ATE_CCUSTO" })

			aAdd(aIndTZ3,{cMod,"MNTV015","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV015","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV015","003","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV015","004","ATE_CCUSTO" })

			aAdd(aIndTZ3,{cMod,"MNTV016","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV016","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV016","003","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV016","004","ATE_CCUSTO" })

			aAdd(aIndTZ3,{cMod,"MNTV017","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV017","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV017","003","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV017","004","ATE_CCUSTO" })
			aAdd(aIndTZ3,{cMod,"MNTV017","005","TIP_ORDEM"  })

			aAdd(aIndTZ3,{cMod,"MNTV018","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV018","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV018","003","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV018","004","ATE_CCUSTO" })

			aAdd(aIndTZ3,{cMod,"MNTV019","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV019","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV019","003","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV019","004","ATE_CCUSTO" })

			aAdd(aIndTZ3,{cMod,"MNTV031","001","DE_PLANO"   })
			aAdd(aIndTZ3,{cMod,"MNTV031","002","ATE_PLANO"  })
			aAdd(aIndTZ3,{cMod,"MNTV031","003","DE_OS"      })
			aAdd(aIndTZ3,{cMod,"MNTV031","004","ATE_OS"     })
			aAdd(aIndTZ3,{cMod,"MNTV031","005","DE_BEM"     })
			aAdd(aIndTZ3,{cMod,"MNTV031","006","ATE_BEM"    })
			aAdd(aIndTZ3,{cMod,"MNTV031","007","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV031","008","ATE_CCUSTO" })
			aAdd(aIndTZ3,{cMod,"MNTV031","009","DE_CENTRA"  })
			aAdd(aIndTZ3,{cMod,"MNTV031","010","ATE_CENTRA" })

			aAdd(aIndTZ3,{cMod,"MNTV032","001","DE_PLANO"   })
			aAdd(aIndTZ3,{cMod,"MNTV032","002","ATE_PLANO"  })
			aAdd(aIndTZ3,{cMod,"MNTV032","003","DE_OS"      })
			aAdd(aIndTZ3,{cMod,"MNTV032","004","ATE_OS"     })
			aAdd(aIndTZ3,{cMod,"MNTV032","005","DE_BEM"     })
			aAdd(aIndTZ3,{cMod,"MNTV032","006","ATE_BEM"    })
			aAdd(aIndTZ3,{cMod,"MNTV032","007","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV032","008","ATE_CCUSTO" })
			aAdd(aIndTZ3,{cMod,"MNTV032","009","DE_CENTRA"  })
			aAdd(aIndTZ3,{cMod,"MNTV032","010","ATE_CENTRA" })

			aAdd(aIndTZ3,{cMod,"MNTV033","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV033","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV033","003","DE_BEM"     })
			aAdd(aIndTZ3,{cMod,"MNTV033","004","ATE_BEM"    })
			aAdd(aIndTZ3,{cMod,"MNTV033","005","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV033","006","ATE_CCUSTO" })
			aAdd(aIndTZ3,{cMod,"MNTV033","007","DE_CENTRA"  })
			aAdd(aIndTZ3,{cMod,"MNTV033","008","ATE_CENTRA" })

			aAdd(aIndTZ3,{cMod,"MNTV034","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV034","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV034","003","DE_BEM"     })
			aAdd(aIndTZ3,{cMod,"MNTV034","004","ATE_BEM"    })
			aAdd(aIndTZ3,{cMod,"MNTV034","005","DE_LOCALI"  })
			aAdd(aIndTZ3,{cMod,"MNTV034","006","ATE_LOCALI" })
			aAdd(aIndTZ3,{cMod,"MNTV034","007","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV034","008","ATE_CCUSTO" })
			aAdd(aIndTZ3,{cMod,"MNTV034","009","DE_CENTRA"  })
			aAdd(aIndTZ3,{cMod,"MNTV034","010","ATE_CENTRA" })
			aAdd(aIndTZ3,{cMod,"MNTV034","011","DE_SOLICI"  })
			aAdd(aIndTZ3,{cMod,"MNTV034","012","ATE_SOLICI" })
			aAdd(aIndTZ3,{cMod,"MNTV034","013","SIT_SOLICI" })

			aAdd(aIndTZ3,{cMod,"MNTV035","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV035","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV035","003","DE_BEM"     })
			aAdd(aIndTZ3,{cMod,"MNTV035","004","ATE_BEM"    })
			aAdd(aIndTZ3,{cMod,"MNTV035","005","DE_LOCALI"  })
			aAdd(aIndTZ3,{cMod,"MNTV035","006","ATE_LOCALI" })
			aAdd(aIndTZ3,{cMod,"MNTV035","007","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV035","008","ATE_CCUSTO" })
			aAdd(aIndTZ3,{cMod,"MNTV035","009","DE_AREA"    })
			aAdd(aIndTZ3,{cMod,"MNTV035","010","ATE_AREA"   })
			aAdd(aIndTZ3,{cMod,"MNTV035","011","DE_SERVICO" })
			aAdd(aIndTZ3,{cMod,"MNTV035","012","ATE_SERVICO"})
			aAdd(aIndTZ3,{cMod,"MNTV035","013","DE_CENTRA"  })
			aAdd(aIndTZ3,{cMod,"MNTV035","014","ATE_CENTRA" })

			aAdd(aIndTZ3,{cMod,"MNTV036","001","DE_DATA"    })
			aAdd(aIndTZ3,{cMod,"MNTV036","002","ATE_DATA"   })
			aAdd(aIndTZ3,{cMod,"MNTV036","003","DE_CCUSTO"  })
			aAdd(aIndTZ3,{cMod,"MNTV036","004","ATE_CCUSTO" })
			aAdd(aIndTZ3,{cMod,"MNTV036","005","DE_CENTRA"  })
			aAdd(aIndTZ3,{cMod,"MNTV036","006","ATE_CENTRA" })
			aAdd(aIndTZ3,{cMod,"MNTV036","007","DE_AREA"    })
			aAdd(aIndTZ3,{cMod,"MNTV036","008","ATE_AREA"   })
			aAdd(aIndTZ3,{cMod,"MNTV036","009","DE_BEM"     })
			aAdd(aIndTZ3,{cMod,"MNTV036","010","ATE_BEM"    })
			aAdd(aIndTZ3,{cMod,"MNTV036","011","DE_SERVICO" })
			aAdd(aIndTZ3,{cMod,"MNTV036","012","ATE_SERVICO"})
			aAdd(aIndTZ3,{cMod,"MNTV036","013","DE_PLANO"   })
			aAdd(aIndTZ3,{cMod,"MNTV036","014","ATE_PLANO"  })
			aAdd(aIndTZ3,{cMod,"MNTV036","015","DE_TPMNT"   })
			aAdd(aIndTZ3,{cMod,"MNTV036","016","ATE_TPMNT"  })
			aAdd(aIndTZ3,{cMod,"MNTV036","017","SIT_OS"     })
			aAdd(aIndTZ3,{cMod,"MNTV036","018","TIP_ORDEM"  })
			aAdd(aIndTZ3,{cMod,"MNTV036","019","TERMINO_OS" })

			If lGFrotas
				aAdd(aIndTZ3,{cMod,"MNTV020","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV020","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV020","003","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV020","004","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV020","005","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV020","006","ATE_CENTRA" })
				aAdd(aIndTZ3,{cMod,"MNTV020","007","DE_FAMILIA" })
				aAdd(aIndTZ3,{cMod,"MNTV020","008","ATE_FAMILIA"})

				aAdd(aIndTZ3,{cMod,"MNTV021","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV021","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV021","003","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV021","004","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV021","005","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV021","006","ATE_CENTRA" })
				aAdd(aIndTZ3,{cMod,"MNTV021","007","DE_FAMILIA" })
				aAdd(aIndTZ3,{cMod,"MNTV021","008","ATE_FAMILIA"})
				aAdd(aIndTZ3,{cMod,"MNTV021","009","CON_VAL"    })

				aAdd(aIndTZ3,{cMod,"MNTV022","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV022","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV022","003","DE_FAMILIA" })
				aAdd(aIndTZ3,{cMod,"MNTV022","004","ATE_FAMILIA"})
				aAdd(aIndTZ3,{cMod,"MNTV022","005","TIP_MUL"    })

				aAdd(aIndTZ3,{cMod,"MNTV023","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV023","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV023","003","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV023","004","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV023","005","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV023","006","ATE_CENTRA" })
				aAdd(aIndTZ3,{cMod,"MNTV023","007","DE_FAMILIA" })
				aAdd(aIndTZ3,{cMod,"MNTV023","008","ATE_FAMILIA"})

				aAdd(aIndTZ3,{cMod,"MNTV024","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV024","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV024","003","DE_FAMILIA" })
				aAdd(aIndTZ3,{cMod,"MNTV024","004","ATE_FAMILIA"})

				aAdd(aIndTZ3,{cMod,"MNTV025","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV025","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV025","003","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV025","004","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV025","005","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV025","006","ATE_CENTRA" })
				aAdd(aIndTZ3,{cMod,"MNTV025","007","DE_FAMILIA" })
				aAdd(aIndTZ3,{cMod,"MNTV025","008","ATE_FAMILIA"})
				aAdd(aIndTZ3,{cMod,"MNTV025","009","TIP_CUS"    })

				aAdd(aIndTZ3,{cMod,"MNTV026","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV026","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV026","003","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV026","004","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV026","005","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV026","006","ATE_CENTRA" })
				aAdd(aIndTZ3,{cMod,"MNTV026","007","DE_FAMILIA" })
				aAdd(aIndTZ3,{cMod,"MNTV026","008","ATE_FAMILIA"})
				aAdd(aIndTZ3,{cMod,"MNTV026","009","DE_MODELO"  })
				aAdd(aIndTZ3,{cMod,"MNTV026","010","ATE_MODELO" })
				aAdd(aIndTZ3,{cMod,"MNTV026","011","ADITIVO"    })

				aAdd(aIndTZ3,{cMod,"MNTV028","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV028","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV028","003","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV028","004","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV028","005","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV028","006","ATE_CENTRA" })
				aAdd(aIndTZ3,{cMod,"MNTV028","007","DE_FAMILIA" })
				aAdd(aIndTZ3,{cMod,"MNTV028","008","ATE_FAMILIA"})

				aAdd(aIndTZ3,{cMod,"MNTV029","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV029","002","ATE_DATA"   })

				aAdd(aIndTZ3,{cMod,"MNTV030","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV030","002","ATE_DATA"   })

				aAdd(aIndTZ3,{cMod,"MNTV037","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV037","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV037","003","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV037","004","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV037","005","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV037","006","ATE_CENTRA" })
				aAdd(aIndTZ3,{cMod,"MNTV037","007","DE_FAMILIA" })
				aAdd(aIndTZ3,{cMod,"MNTV037","008","ATE_FAMILIA"})

				aAdd(aIndTZ3,{cMod,"MNTV041","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV041","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV041","003","DE_FAMILIA" })
				aAdd(aIndTZ3,{cMod,"MNTV041","004","ATE_FAMILIA"})
				aAdd(aIndTZ3,{cMod,"MNTV041","005","DE_MODELO"  })
				aAdd(aIndTZ3,{cMod,"MNTV041","006","ATE_MODELO" })
				aAdd(aIndTZ3,{cMod,"MNTV041","007","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV041","008","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV041","009","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV041","010","ATE_CENTRA" })
				aAdd(aIndTZ3,{cMod,"MNTV041","011","ADITIVO"    })
			EndIf

			If lFacilit // Facilities
				aAdd(aIndTZ3,{cMod,"MNTV038","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV038","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV038","003","DE_BEM"     })
				aAdd(aIndTZ3,{cMod,"MNTV038","004","ATE_BEM"    })
				aAdd(aIndTZ3,{cMod,"MNTV038","005","DE_LOCALI"  })
				aAdd(aIndTZ3,{cMod,"MNTV038","006","ATE_LOCALI" })
				aAdd(aIndTZ3,{cMod,"MNTV038","007","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV038","008","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV038","009","DE_SERVICO" })
				aAdd(aIndTZ3,{cMod,"MNTV038","010","ATE_SERVICO"})
				aAdd(aIndTZ3,{cMod,"MNTV038","011","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV038","012","ATE_CENTRA" })

				aAdd(aIndTZ3,{cMod,"MNTV039","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV039","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV039","003","DE_BEM"     })
				aAdd(aIndTZ3,{cMod,"MNTV039","004","ATE_BEM"    })
				aAdd(aIndTZ3,{cMod,"MNTV039","005","DE_LOCALI"  })
				aAdd(aIndTZ3,{cMod,"MNTV039","006","ATE_LOCALI" })
				aAdd(aIndTZ3,{cMod,"MNTV039","007","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV039","008","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV039","009","DE_SERVICO" })
				aAdd(aIndTZ3,{cMod,"MNTV039","010","ATE_SERVICO"})
				aAdd(aIndTZ3,{cMod,"MNTV039","011","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV039","012","ATE_CENTRA" })

				aAdd(aIndTZ3,{cMod,"MNTV040","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV040","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV040","003","DE_BEM"     })
				aAdd(aIndTZ3,{cMod,"MNTV040","004","ATE_BEM"    })
				aAdd(aIndTZ3,{cMod,"MNTV040","005","DE_LOCALI"  })
				aAdd(aIndTZ3,{cMod,"MNTV040","006","ATE_LOCALI" })
				aAdd(aIndTZ3,{cMod,"MNTV040","007","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV040","008","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV040","009","DE_SERVICO" })
				aAdd(aIndTZ3,{cMod,"MNTV040","010","ATE_SERVICO"})
				aAdd(aIndTZ3,{cMod,"MNTV040","011","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV040","012","ATE_CENTRA" })
			EndIf

			If !lRPORel17 // Caso seja uma versão superior a release 12.1.17
				// Indicadores Mundiais (NGKPI)
				aAdd(aIndTZ3,{cMod,"MNTV001","011","CON_PARADA" })

				aAdd(aIndTZ3,{cMod,"MNTV002","009","CON_SOBOS"  })
				aAdd(aIndTZ3,{cMod,"MNTV002","010","CON_MINOS"  })
				aAdd(aIndTZ3,{cMod,"MNTV002","011","CON_PARADA" })

				aAdd(aIndTZ3,{cMod,"MNTV003","009","CON_SOBOS"  })
				aAdd(aIndTZ3,{cMod,"MNTV003","010","CON_PARADA" })

				aAdd(aIndTZ3,{cMod,"MNTV042","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV042","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV042","003","DE_BEM"     })
				aAdd(aIndTZ3,{cMod,"MNTV042","004","ATE_BEM"    })
				aAdd(aIndTZ3,{cMod,"MNTV042","005","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV042","006","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV042","007","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV042","008","ATE_CENTRA" })

				aAdd(aIndTZ3,{cMod,"MNTV043","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV043","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV043","003","DE_BEM"     })
				aAdd(aIndTZ3,{cMod,"MNTV043","004","ATE_BEM"    })
				aAdd(aIndTZ3,{cMod,"MNTV043","005","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV043","006","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV043","007","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV043","008","ATE_CENTRA" })
				aAdd(aIndTZ3,{cMod,"MNTV043","009","TIP_ORDEM"  })

				aAdd(aIndTZ3,{cMod,"MNTV044","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV044","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV044","003","DE_BEM"     })
				aAdd(aIndTZ3,{cMod,"MNTV044","004","ATE_BEM"    })
				aAdd(aIndTZ3,{cMod,"MNTV044","005","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV044","006","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV044","007","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV044","008","ATE_CENTRA" })
				aAdd(aIndTZ3,{cMod,"MNTV044","009","CON_SOBOS"  })
				aAdd(aIndTZ3,{cMod,"MNTV044","010","CON_PARADA" })

				aAdd(aIndTZ3,{cMod,"MNTV045","001","DE_BEM"     })
				aAdd(aIndTZ3,{cMod,"MNTV045","002","ATE_BEM"    })
				aAdd(aIndTZ3,{cMod,"MNTV045","003","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV045","004","ATE_CCUSTO" })

				aAdd(aIndTZ3,{cMod,"MNTV046","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV046","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV046","003","FAT_PERIOD" })

				aAdd(aIndTZ3,{cMod,"MNTV047","001","DE_DATA"    })
				aAdd(aIndTZ3,{cMod,"MNTV047","002","ATE_DATA"   })
				aAdd(aIndTZ3,{cMod,"MNTV047","003","DE_BEM"     })
				aAdd(aIndTZ3,{cMod,"MNTV047","004","ATE_BEM"    })
				aAdd(aIndTZ3,{cMod,"MNTV047","005","DE_CCUSTO"  })
				aAdd(aIndTZ3,{cMod,"MNTV047","006","ATE_CCUSTO" })
				aAdd(aIndTZ3,{cMod,"MNTV047","007","DE_CENTRA"  })
				aAdd(aIndTZ3,{cMod,"MNTV047","008","ATE_CENTRA" })
			EndIf

			//--------------------------------------------------
			// TZ4 - Tipos de Parâmetros
			//--------------------------------------------------
			aAdd(aIndTZ4,{cMod,"DE_PLANO"   ,STR1231,"5",0 ,0,""          ,"STI","TI_PLANO"  ,"STI"   ,""     ,"","IF(!EMPTY(M->DE_PLANO),EXISTCPO('STI',M->DE_PLANO),.T.)"    }) //"Plano Início"
			aAdd(aIndTZ4,{cMod,"ATE_PLANO"  ,STR1232,"5",0 ,0,""          ,"STI","TI_PLANO"  ,"STI"   ,""     ,"","IF(NGI6CODATE('STI',DE_PLANO,ATE_PLANO),.T.,.F.)"           }) //"Plano Fim"
			aAdd(aIndTZ4,{cMod,"DE_OS"      ,STR1233,"5",0 ,0,""          ,"STJ","TJ_ORDEM"  ,"STJ"   ,""     ,"","IF(!EMPTY(M->DE_OS),EXISTCPO('STJ',M->DE_OS),.T.)"          }) //"Ordem de Serviço Início"
			aAdd(aIndTZ4,{cMod,"ATE_OS"     ,STR1234,"5",0 ,0,""          ,"STJ","TJ_ORDEM"  ,"STJ"   ,""     ,"","IF(NGI6CODATE('STJ',DE_OS,ATE_OS),.T.,.F.)"                 }) //"Ordem de Serviço Final"
			aAdd(aIndTZ4,{cMod,"DE_DATA"    ,STR1235,"4",8 ,0,"99/99/9999",""   ,""          ,""      ,""     ,"","If(Empty(M->DE_DATA),.F.,.T.)"                              }) //"Data Início"
			aAdd(aIndTZ4,{cMod,"ATE_DATA"   ,STR1236,"4",8 ,0,"99/99/9999",""   ,""          ,""      ,""     ,"","NGI6VDTIND(M->DE_DATA,M->ATE_DATA)"                         }) //"Data Final"
			aAdd(aIndTZ4,{cMod,"DE_BEM"     ,STR1237,"5",0 ,0,""          ,"ST9","T9_CODBEM" ,"ST9"   ,""     ,"","IF(!EMPTY(M->DE_BEM),EXISTCPO('ST9',M->DE_BEM),.T.)"        }) //"Bem Início"
			aAdd(aIndTZ4,{cMod,"ATE_BEM"    ,STR1238,"5",0 ,0,""          ,"ST9","T9_CODBEM" ,"ST9"   ,""     ,"","IF(NGI6CODATE('ST9',DE_BEM,ATE_BEM),.T.,.F.)"               }) //"Bem Final"
			aAdd(aIndTZ4,{cMod,"DE_CENTRA"  ,STR1239,"5",0 ,0,""          ,"SHB","HB_COD"    ,"SHB"   ,""     ,"","IF(!EMPTY(M->DE_CENTRA),EXISTCPO('SHB',M->DE_CENTRA),.T.)"  }) //"Centro de Trabalho Início"
			aAdd(aIndTZ4,{cMod,"ATE_CENTRA" ,STR1240,"5",0 ,0,""          ,"SHB","HB_COD"    ,"SHB"   ,""     ,"","IF(NGI6CODATE('SHB',DE_CENTRA,ATE_CENTRA),.T.,.F.)"         }) //"Centro de Trabalho Final"
			aAdd(aIndTZ4,{cMod,"DE_CCUSTO"  ,STR1241,"5",0 ,0,""          ,"CTT","CTT_CUSTO" ,"CTT"   ,""     ,"","IF(!EMPTY(M->DE_CCUSTO),EXISTCPO('CTT',M->DE_CCUSTO),.T.)"  }) //"Centro de Custo Início"
			aAdd(aIndTZ4,{cMod,"ATE_CCUSTO" ,STR1242,"5",0 ,0,""          ,"CTT","CTT_CUSTO" ,"CTT"   ,""     ,"","IF(NGI6CODATE('CTT',DE_CCUSTO,ATE_CCUSTO),.T.,.F.)"         }) //"Centro de Custo Final"
			aAdd(aIndTZ4,{cMod,"DE_AREA"    ,STR1243,"5",0 ,0,""          ,"STD","TD_CODAREA","STD"   ,""     ,"","IF(!EMPTY(M->DE_AREA),EXISTCPO('STD',M->DE_AREA),.T.)"      }) //"Área Início"
			aAdd(aIndTZ4,{cMod,"ATE_AREA"   ,STR1244,"5",0 ,0,""          ,"STD","TD_CODAREA","STD"   ,""     ,"","IF(NGI6CODATE('STD',DE_AREA,ATE_AREA),.T.,.F.)"             }) //"Área Final"
			aAdd(aIndTZ4,{cMod,"DE_ESPEC"   ,STR1245,"5",0 ,0,""          ,"ST0","T0_ESPECIA","ST0"   ,""     ,"","IF(!EMPTY(M->DE_ESPEC),EXISTCPO('ST0',M->DE_ESPEC),.T.)"    }) //"Especialidade Início"
			aAdd(aIndTZ4,{cMod,"ATE_ESPEC"  ,STR1246,"5",0 ,0,""          ,"ST0","T0_ESPECIA","ST0"   ,""     ,"","IF(NGI6CODATE('ST0',DE_ESPEC,ATE_ESPEC),.T.,.F.)"           }) //"Especialidade Final"
			aAdd(aIndTZ4,{cMod,"DE_FUNCI"   ,STR1247,"5",0 ,0,"@!"        ,"ST1","T1_CODFUNC","ST1"   ,""     ,"","IF(!EMPTY(M->DE_FUNCI),EXISTCPO('ST1',M->DE_FUNCI),.T.)"    }) //"Funcionário Início"
			aAdd(aIndTZ4,{cMod,"ATE_FUNCI"  ,STR1248,"5",0 ,0,"@!"        ,"ST1","T1_CODFUNC","ST1"   ,""     ,"","IF(NGI6CODATE('ST1',DE_FUNCI,ATE_FUNCI),.T.,.F.)"           }) //"Funcionário Final"
			aAdd(aIndTZ4,{cMod,"DE_TERCE"   ,STR1249,"5",0 ,0,""          ,"SA2","A2_COD"    ,"SA2"   ,""     ,"","IF(!EMPTY(M->DE_TERCE),EXISTCPO('SA2',M->DE_TERCE),.T.)"    }) //"Terceiro Início"
			aAdd(aIndTZ4,{cMod,"ATE_TERCE"  ,STR1250,"5",0 ,0,""          ,"SA2","A2_COD"    ,"SA2"   ,""     ,"","IF(NGI6CODATE('SA2',DE_TERCE,ATE_TERCE),.T.,.F.)"           }) //"Terceiro Final"
			aAdd(aIndTZ4,{cMod,"DE_FERRA"   ,STR1251,"1",6 ,0,"@!"        ,""   ,""          ,""      ,""     ,"",""                                                           }) //"Ferramenta Início"
			aAdd(aIndTZ4,{cMod,"ATE_FERRA"  ,STR1252,"1",6 ,0,"@!"        ,""   ,""          ,""      ,""     ,"",""                                                           }) //"Ferramenta Final"
			aAdd(aIndTZ4,{cMod,"TIP_ORDEM"  ,STR1253,"6",1 ,0,""          ,""   ,""          ,""      ,STR1268,"",""                                                           }) //"Tipo da Ordem de Serviço"###"C=Corretiva;P=Preventiva;L=Lubrificacao;R=Reforma;O=Outras;T=Todas"
			aAdd(aIndTZ4,{cMod,"CON_CALEND" ,STR1254,"6",1 ,0,""          ,""   ,""          ,""      ,STR1269,"",""                                                           }) //"Considera Calendário do Bem"###"1=Sim;2=Nao"
			aAdd(aIndTZ4,{cMod,"CON_ANTDPS" ,STR1255,"6",1 ,0,""          ,""   ,""          ,""      ,STR1269,"",""                                                           }) //"Considera Tempo Antes/Depois"###"1=Sim;2=Nao"
			aAdd(aIndTZ4,{cMod,"DE_FAMILIA" ,STR1256,"5",0 ,0,""          ,"ST6","T6_CODFAMI","ST6"   ,""     ,"","IF(!EMPTY(M->DE_FAMILIA),EXISTCPO('ST6',M->DE_FAMILIA),.T.)"}) //"Família Início"
			aAdd(aIndTZ4,{cMod,"ATE_FAMILIA",STR1257,"5",0 ,0,""          ,"ST6","T6_CODFAMI","ST6"   ,""     ,"","IF(NGI6CODATE('ST6',DE_FAMILIA,ATE_FAMILIA),.T.,.F.)"       }) //"Família Fim"
			aAdd(aIndTZ4,{cMod,"SIT_SOLICI" ,STR1258,"6",1 ,0,""          ,""   ,""          ,""      ,STR1270,"",""                                                           }) //"Situação"###"1=Aguardando Analise;2=Distribuida;3=Fechamento por OS;4=Fechamento por SS"
			aAdd(aIndTZ4,{cMod,"SIT_OS"     ,STR1258,"6",1 ,0,""          ,""   ,""          ,""      ,STR1271,"",""                                                           }) //"Situação"###"1=Pendentes;2=Liberadas;3=Canceladas;4=Todas"
			aAdd(aIndTZ4,{cMod,"DE_SERVICO" ,STR1259,"5",0 ,0,""          ,"ST4","T4_SERVICO","ST4"   ,""     ,"","IF(!EMPTY(M->DE_SERVICO),EXISTCPO('ST4',M->DE_SERVICO),.T.)"}) //"Serviço Início"
			aAdd(aIndTZ4,{cMod,"ATE_SERVICO",STR1260,"5",0 ,0,""          ,"ST4","T4_SERVICO","ST4"   ,""     ,"","IF(NGI6CODATE('ST4',DE_SERVICO,ATE_SERVICO),.T.,.F.)"       }) //"Serviço Final"
			aAdd(aIndTZ4,{cMod,"DE_LOCALI"  ,STR1261,"5",0 ,0,""          ,"TAF","TAF_CODNIV","SGATAF",""     ,"","IF(!EMPTY(M->DE_LOCALI),EXISTCPO('TAF',M->DE_LOCALI),.T.)"  }) //"Localização Início"
			aAdd(aIndTZ4,{cMod,"ATE_LOCALI" ,STR1262,"5",0 ,0,""          ,"TAF","TAF_CODNIV","SGATAF",""     ,"","IF(NGI6CODATE('TAF',DE_LOCALI,ATE_LOCALI),.T.,.F.)"         }) //"Localização Final"
			aAdd(aIndTZ4,{cMod,"DE_SOLICI"  ,STR1263,"5",25,0,""          ,""   ,"QAA_LOGIN" ,"QUS"   ,""     ,"","NGI6VLDUSR(1,DE_SOLICI,ATE_SOLICI)"                                              }) //"Solicitante Início"
			aAdd(aIndTZ4,{cMod,"ATE_SOLICI" ,STR1264,"5",25,0,""          ,""   ,"QAA_LOGIN" ,"QUS"   ,""     ,"","NGI6VLDUSR(2,DE_SOLICI,ATE_SOLICI)"                                              }) //"Solicitante Final"
			aAdd(aIndTZ4,{cMod,"DE_TPMNT"   ,STR1265,"5",0 ,0,""          ,"STE","TE_TIPOMAN","STE"   ,""     ,"","IF(!EMPTY(M->DE_TPMNT),EXISTCPO('STE',M->DE_TPMNT),.T.)"    }) //"Tipo Manutenção Início"
			aAdd(aIndTZ4,{cMod,"ATE_TPMNT"  ,STR1266,"5",0 ,0,""          ,"STE","TE_TIPOMAN","STE"   ,""     ,"","IF(NGI6CODATE('STI',DE_TPMNT,ATE_TPMNT),.T.,.F.)"           }) //"Tipo Manutenção Final"
			aAdd(aIndTZ4,{cMod,"TERMINO_OS" ,STR1267,"6",1 ,0,""          ,""   ,""          ,""      ,STR1272,"",""                                                           }) //"Termino OS"###"1=Sim;2=Nao;3=Todas"

			If !lRPORel17 // Caso seja uma versão superior a release 12.1.17
				// Indicadores Mundiais (NGKPI)
				aAdd(aIndTZ4,{cMod,"CON_MINOS"  ,STR1273,"6",1  ,0,""               ,"","","",STR1269,"","" }) // "Considera número mínimo de O.S."
				aAdd(aIndTZ4,{cMod,"CON_PARADA" ,STR1274,"6",1  ,0,""               ,"","","",STR1464,"","" }) // "Considera Parada de OS"
				aAdd(aIndTZ4,{cMod,"CON_SOBOS"  ,STR1275,"6",1  ,0,""               ,"","","",STR1269,"","" }) // "Considera Sobreposição de OS"
				aAdd(aIndTZ4,{cMod,"FAT_PERIOD" ,STR1276,"2",10 ,2,"99999999999.99" ,"","","",""     ,"","" }) // "Faturamento do periodo"
			EndIf

			If lGFrotas
				aAdd(aIndTZ4,{cMod,"CON_VAL"   ,STR1277,"6",1,0,"","","","",STR1269,"",""}) //"Considera Valor de Aquisição"###"1=Sim;2=Nao"
				aAdd(aIndTZ4,{cMod,"TIP_CUS"   ,STR1278,"6",1,0,"","","","",STR1283,"",""}) //"Considerar Tipo Custo"###"1=Reforma;2=Concerto;3=Ambos;4=Todos"
				aAdd(aIndTZ4,{cMod,"TIP_MUL"   ,STR1279,"6",1,0,"","","","",STR1284,"",""}) //"Considera Multas"###"1=Internas;2=Terceiros;3=Ambos"
				aAdd(aIndTZ4,{cMod,"ADITIVO"   ,STR1280,"5",0,0,"","SB1","B1_COD","SB1","","",""}) //"Aditivo"
				aAdd(aIndTZ4,{cMod,"DE_MODELO" ,STR1281,"5",0,0,"@!","TQR","TQR_TIPMOD","TQR","","","IF(!EMPTY(M->DE_MODELO),EXISTCPO('TQR',M->DE_MODELO),.T.)"}) //"Modelo Início"
				aAdd(aIndTZ4,{cMod,"ATE_MODELO",STR1282,"5",0,0,"@!","TQR","TQR_TIPMOD","TQR","","","IF(NGI6CODATE('TQR',DE_MODELO,ATE_MODELO),.T.,.F.)"}) //"Modelo Fim"
			EndIf

			//--------------------------------------------------
			// TZ5 - Indicadores (Fórmulas)
			//--------------------------------------------------
			aAdd( aIndTZ5, { '19', 'BACK', STR1285, '( @MNTV010@ / @MNTV011@ ) * #100.000#', IIf( !lGFrotas, '02', '07' ),;
				STR1300 + STR1465, '%', 12, 0, '', '', '', '1', '', '1' } ) // Tempo p/ Atendimento de Serviço Manutenc
			aAdd(aIndTZ5,{cMod,"CHMC",STR1286,"@MNTV018@ - @MNTV019@"                ,If(!lGFrotas,"03","07"),STR1301                       ,"R$",12,2,"","","","1","","1"}) //"Custo das Horas Manut. Corretiva"
			aAdd(aIndTZ5,{cMod,"CHMP",STR1287,"@MNTV019@"                            ,If(!lGFrotas,"03","07"),STR1302                       ,"R$",12,2,"","","","1","","1"}) //"Custo Homem Hora Tot. Manut. Preventivas"
			aAdd(aIndTZ5,{cMod,"CMDM",STR1288,"@MNTV017@"                            ,If(!lGFrotas,"03","07"),STR1303+STR1304               ,"R$",12,2,"","","","1","","1"}) //"Custo Manut. Unid Prod. CMDM"
			aAdd(aIndTZ5,{cMod,"EPEP",STR1289,"( @MNTV013@ / @MNTV012@ ) * #100.000#",If(!lGFrotas,"02","07"),STR1305                       ,"%" ,12,2,"","","","1","","1"}) //"Eficiência da Equipe de Preventiva"
			aAdd(aIndTZ5,{cMod,"PEXE",STR1290,"@MNTV032@ * #100.000# / @MNTV031@"    ,If(!lGFrotas,"01","07"),STR1306                       ,"PR",06,2,"","","","1","","1"}) //"Porcentagem de Etapas Executadas"
			aAdd( aIndTZ5, { '19', 'PTMC', STR1291, '( @MNTV016@ / @MNTV015@ ) * #100.000#', IIf( !lGFrotas, '02', '07' ),;
				STR1307 + STR1466, '%', 12, 2, '', '', '', '1', '', '1' } ) // Perc. Utilização Trabalho Corretivas
			aAdd( aIndTZ5, { '19', 'PTMP', STR1292, '( @MNTV014@ / @MNTV015@ ) * #100.000#', IIf( !lGFrotas, '02', '07' ),;
				STR1308 + STR1467, '%', 12, 2, '', '', '', '1', '', '1' } ) // Perc. Utilização Manut. Preventiva
			aAdd( aIndTZ5, { '19', 'PTOT', STR1293, '( @MNTV008@ / @MNTV009@ ) * #100.000#', IIf( !lGFrotas, '02', '07' ),;
				STR1309 + STR1468 + STR1310, '%', 12, 2, '', '', '', '1', '', '1' } ) // Perc. Utilização Total em Manutenção

			If !lRPORel17
				aAdd(aIndTZ5,{cMod,"MTBF",STR1294,"@MNTV001@ / @MNTV002@"                ,If(!lGFrotas,"01","07"),STR1311+STR1438               ,"H" ,12,0,"","","","2","","1"}) //"Tempo Médio entre Falhas"
				aAdd(aIndTZ5,{cMod,"MTTR",STR1296,"@MNTV003@ / @MNTV002@"                ,If(!lGFrotas,"01","07"),STR1313+STR1440               ,"H" ,12,0,"","","","2","","1"}) //"Tempo Médio para Reparo"
			Else
				aAdd(aIndTZ5,{cMod,"TMEF",STR1294,"@MNTV001@ / @MNTV002@"                ,If(!lGFrotas,"01","07"),STR1311+STR1438               ,"H" ,12,0,"","","","2","","1"}) //"Tempo Médio entre Falhas"
				aAdd(aIndTZ5,{cMod,"TMPR",STR1296,"@MNTV003@ / @MNTV002@"                ,If(!lGFrotas,"01","07"),STR1313+STR1440               ,"H" ,12,0,"","","","2","","1"}) //"Tempo Médio para Reparo"
			Endif

			aAdd(aIndTZ5,{cMod,"TMMP",STR1295,"@MNTV007@ / @MNTV006@"                ,If(!lGFrotas,"01","07"),STR1312                       ,"H" ,12,0,"","","","2","","1"}) //"Tempo Médio para Manut. Preventivas"
			aAdd(aIndTZ5,{cMod,"QSOL",STR1297,"@MNTV034@"                            ,If(!lGFrotas,"01","07"),STR1314                       ,""  ,12,2,"","","","1","","1"}) //"Qtde Solicitações de Serviço"
			aAdd(aIndTZ5,{cMod,"SCSO",STR1298,"@MNTV035@"                            ,If(!lGFrotas,"01","07"),STR1315                       ,""  ,12,2,"","","","1","","1"}) //"Qtde Solicitações com OS Relacionadas"
			aAdd( aIndTZ5,{ '19', 'QTOS', STR1299, '@MNTV036@', IIf( !lGFrotas, '01', '07' ), STR1316 + STR1469, '', 12,;
				2, '', '', '', '1', '', '1' } ) // Quantidade de OS por Status

			If lGFrotas
				aAdd(aIndTZ5,{cMod,"CTAB" ,STR1317,"@MNTV020@"                                                                ,"01",STR1328            ,""  ,12,2,"","","","1","","1"}) //"Custo Total de Abastecimento"
				aAdd(aIndTZ5,{cMod,"MRPL" ,STR1318,"@MNTV026@ / @MNTV028@"                                                    ,"01",STR1329            ,""  ,12,2,"","","","1","","1"}) //"Média de Rodagem por Litro"
				aAdd( aIndTZ5, { cMod, 'CTPN', STR1319, '@MNTV021@', '02', STR1330 + STR1470 + STR1331, '', 12, 2, '', '',;
					'', '1', '', '1' } ) // Custo Total de Pneus
				aAdd( aIndTZ5, { cMod, 'CRPR', STR1320, '@MNTV025@ / @MNTV037@', '02', STR1332 + STR1333 + STR1471, '',;
					12, 2, '', '', '', '1', '', '1' } ) // Custo de Rodagem por Reforma
				aAdd(aIndTZ5,{cMod,"CTPSI",STR1321,"@MNTV023@"                                                                ,"04",STR1334            ,""  ,12,2,"","","","1","","1"}) //"Custo Total por Sinistro"
				aAdd(aIndTZ5,{cMod,"CPRO" ,STR1322,"@MNTV023@ / @MNTV026@"                                                    ,"04",STR1335            ,""  ,12,2,"","","","1","","1"}) //"Custo Médio Sinistro x KM"
				aAdd(aIndTZ5,{cMod,"CTMU" ,STR1323,"@MNTV022@"                                                                ,"03",STR1336+" "+STR1337,""  ,12,2,"","","","1","","1"}) //"Custo Total de Multas"
				aAdd(aIndTZ5,{cMod,"PMPM" ,STR1324,"@MNTV029@ / @MNTV030@"                                                    ,"03",STR1338            ,""  ,12,2,"","","","1","","1"}) //"MÉDIA DE PONTOS  POR MOTORISTA"
				aAdd(aIndTZ5,{cMod,"CTDO" ,STR1325,"@MNTV024@"                                                                ,"05",STR1339            ,""  ,12,2,"","","","1","","1"}) //"Custo Total com Documentos"
				aAdd(aIndTZ5,{cMod,"CTPR" ,STR1326,"( @MNTV020@ + @MNTV021@ + @MNTV022@ + @MNTV023@ + @MNTV024@ ) / @MNTV026@","06",STR1340            ,""  ,12,2,"","","","1","","1"}) //"Custo Total por Rodagem"
				aAdd(aIndTZ5,{cMod,"RMDA" ,STR1327,"@MNTV026@ / @MNTV041@"                                                    ,"01",STR1341            ,"KL",12,2,"","","","1","","1"}) //"Rendimento Médio de Aditivo"
			EndIf

			If lFacilit // Facilities
				aAdd(aIndTZ5,{cMod,"SSQPRAZO" ,STR1342,"@MNTV038@"                                           ,If(!lGFrotas,"04","08"),""," ",12,2,"","","","1","","1"}) //"Quant. S.S.'s Atendidas no Prazo"
				aAdd(aIndTZ5,{cMod,"SSQENCCAN",STR1343,"@MNTV039@"                                           ,If(!lGFrotas,"04","08"),""," ",12,2,"","","","1","","1"}) //"Quant. S.S.'s Ecerr./Cance."
				aAdd(aIndTZ5,{cMod,"SSQFORA"  ,STR1344,"@MNTV040@"                                           ,If(!lGFrotas,"04","08"),""," ",12,2,"","","","1","","1"}) //"Quant. S.S.'s Dist. Fora do Prazo"
				aAdd(aIndTZ5,{cMod,"SSPPRAZO" ,STR1345,"( @MNTV038@ / @MNTV039@ ) * #100.000#"               ,If(!lGFrotas,"04","08"),"","%",06,2,"","","","1","","1"}) //"Perc. S.S.'s Atendidas no Prazo"
				aAdd(aIndTZ5,{cMod,"SSPFORA"  ,STR1346,"( ( @MNTV038@ / @MNTV039@ ) - #1.000# ) * #-100.000#",If(!lGFrotas,"04","08"),"","%",06,2,"","","","1","","1"}) //"Perc. S.S.'s Fora do Prazo"
				aAdd(aIndTZ5,{cMod,"SSPDISTF" ,STR1347,"( @MNTV040@ / @MNTV039@ ) * #100.000#"               ,If(!lGFrotas,"04","08"),"","%",06,2,"","","","1","","1"}) //"Perc. S.S.'s Dist. Fora do Prazo"
			EndIf

			If !lRPORel17 // Caso seja uma versão superior a release 12.1.17
				// Indicadores Mundiais (NGKPI)
				aAdd(aIndTZ5,{cMod,"MTTF",STR1348,"@MNTV001@ / @MNTV047@"                                 ,If(!lGFrotas,"01","07"),STR1353+STR1355+STR1439        ,"H",12,2,"","","","2","","1"})
				aAdd(aIndTZ5,{cMod,"DISP",STR1349,"( ( @MNTV042@ - @MNTV044@ ) / @MNTV042@ ) * #100.000#" ,If(!lGFrotas,"01","07"),STR1354+STR1441                ,"%",12,2,"","","","1","","1"})
				aAdd(aIndTZ5,{cMod,"CONF",STR1350,"( ( @MNTV042@ - @MNTV003@ ) / @MNTV042@ ) * #100.000#" ,If(!lGFrotas,"01","07"),STR1357+STR1358+STR1444        ,"%",12,2,"","","","1","","1"})
				aAdd(aIndTZ5,{cMod,"CMFT",STR1351,"( @MNTV043@ / @MNTV046@ ) * #100.000#"                 ,If(!lGFrotas,"01","07"),STR1359+STR1442                ,"%",12,2,"","","","1","","1"})
				aAdd(aIndTZ5,{cMod,"CMVR",STR1352,"( @MNTV043@ / @MNTV045@ ) * #100.000#"                 ,If(!lGFrotas,"01","07"),STR1360+STR1443                ,"%",12,2,"","","","1","","1"})
			EndIf

			//--------------------------------------------------
			// TZ6 - Variáveis por Fórmula
			//--------------------------------------------------
			aAdd(aIndTZ6,{cMod,"PEXE","MNTV031"})
			aAdd(aIndTZ6,{cMod,"PEXE","MNTV032"})

			aAdd(aIndTZ6,{cMod,"BACK","MNTV010"})
			aAdd(aIndTZ6,{cMod,"BACK","MNTV011"})

			aAdd(aIndTZ6,{cMod,"CHMC","MNTV018"})
			aAdd(aIndTZ6,{cMod,"CHMC","MNTV019"})

			aAdd(aIndTZ6,{cMod,"CHMP","MNTV019"})

			aAdd(aIndTZ6,{cMod,"CMDM","MNTV017"})

			aAdd(aIndTZ6,{cMod,"EPEP","MNTV012"})
			aAdd(aIndTZ6,{cMod,"EPEP","MNTV013"})

			aAdd(aIndTZ6,{cMod,"PTMC","MNTV015"})
			aAdd(aIndTZ6,{cMod,"PTMC","MNTV016"})

			aAdd(aIndTZ6,{cMod,"PTMP","MNTV014"})
			aAdd(aIndTZ6,{cMod,"PTMP","MNTV015"})

			aAdd(aIndTZ6,{cMod,"PTOT","MNTV008"})
			aAdd(aIndTZ6,{cMod,"PTOT","MNTV009"})

			If !lRPORel17

				aAdd(aIndTZ6,{cMod,"MTBF","MNTV001"})
				aAdd(aIndTZ6,{cMod,"MTBF","MNTV002"})

				aAdd(aIndTZ6,{cMod,"MTTR","MNTV002"})
				aAdd(aIndTZ6,{cMod,"MTTR","MNTV003"})

			Else

				aAdd(aIndTZ6,{cMod,"TMEF","MNTV001"})
				aAdd(aIndTZ6,{cMod,"TMEF","MNTV002"})

				aAdd(aIndTZ6,{cMod,"TMPR","MNTV002"})
				aAdd(aIndTZ6,{cMod,"TMPR","MNTV003"})

			Endif

			aAdd(aIndTZ6,{cMod,"TMMP","MNTV006"})
			aAdd(aIndTZ6,{cMod,"TMMP","MNTV007"})

			aAdd(aIndTZ6,{cMod,"QSOL","MNTV034"})

			aAdd(aIndTZ6,{cMod,"SCSO","MNTV035"})

			aAdd(aIndTZ6,{cMod,"QTOS","MNTV036"})

			If lGFrotas
				aAdd(aIndTZ6,{cMod,"CTAB","MNTV020"})

				aAdd(aIndTZ6,{cMod,"MRPL","MNTV026"})
				aAdd(aIndTZ6,{cMod,"MRPL","MNTV028"})

				aAdd(aIndTZ6,{cMod,"CTPN","MNTV021"})

				aAdd(aIndTZ6,{cMod,"CRPR","MNTV025"})
				aAdd(aIndTZ6,{cMod,"CRPR","MNTV037"})

				aAdd(aIndTZ6,{cMod,"CTPSI","MNTV023"})

				aAdd(aIndTZ6,{cMod,"CPRO","MNTV023"})
				aAdd(aIndTZ6,{cMod,"CPRO","MNTV026"})

				aAdd(aIndTZ6,{cMod,"CTMU","MNTV022"})

				aAdd(aIndTZ6,{cMod,"PMPM","MNTV029"})
				aAdd(aIndTZ6,{cMod,"PMPM","MNTV030"})

				aAdd(aIndTZ6,{cMod,"CTDO","MNTV024"})

				aAdd(aIndTZ6,{cMod,"CTPR","MNTV020"})
				aAdd(aIndTZ6,{cMod,"CTPR","MNTV021"})
				aAdd(aIndTZ6,{cMod,"CTPR","MNTV022"})
				aAdd(aIndTZ6,{cMod,"CTPR","MNTV023"})
				aAdd(aIndTZ6,{cMod,"CTPR","MNTV024"})
				aAdd(aIndTZ6,{cMod,"CTPR","MNTV026"})
				aAdd(aIndTZ6,{cMod,"RMDA","MNTV026"})
				aAdd(aIndTZ6,{cMod,"RMDA","MNTV041"})
			EndIf

			If lFacilit // Facilities
				aAdd(aIndTZ6,{cMod,"SSQPRAZO" ,"MNTV038"})

				aAdd(aIndTZ6,{cMod,"SSQENCCAN","MNTV039"})

				aAdd(aIndTZ6,{cMod,"SSQFORA"  ,"MNTV040"})

				aAdd(aIndTZ6,{cMod,"SSPPRAZO" ,"MNTV038"})
				aAdd(aIndTZ6,{cMod,"SSPPRAZO" ,"MNTV039"})

				aAdd(aIndTZ6,{cMod,"SSPFORA"  ,"MNTV038"})
				aAdd(aIndTZ6,{cMod,"SSPFORA"  ,"MNTV039"})

				aAdd(aIndTZ6,{cMod,"SSPDISTF" ,"MNTV039"})
				aAdd(aIndTZ6,{cMod,"SSPDISTF" ,"MNTV040"})
			EndIf

			If !lRPORel17 // Caso seja uma versão superior a release 12.1.17
				// Indicadores Mundiais (NGKPI)
				aAdd(aIndTZ6,{cMod,"MTTF" ,"MNTV001"})
				aAdd(aIndTZ6,{cMod,"MTTF" ,"MNTV047"})

				aAdd(aIndTZ6,{cMod,"DISP" ,"MNTV042"})
				aAdd(aIndTZ6,{cMod,"DISP" ,"MNTV044"})

				aAdd(aIndTZ6,{cMod,"CONF" ,"MNTV003"})
				aAdd(aIndTZ6,{cMod,"CONF" ,"MNTV042"})

				aAdd(aIndTZ6,{cMod,"CMFT" ,"MNTV043"})
				aAdd(aIndTZ6,{cMod,"CMFT" ,"MNTV046"})

				aAdd(aIndTZ6,{cMod,"CMVR" ,"MNTV043"})
				aAdd(aIndTZ6,{cMod,"CMVR" ,"MNTV045"})
			EndIf

			//--------------------------------------------------
			// TZ7 - Parâmetros Fixos por Indicador (Obrigatórios)
			//--------------------------------------------------
			aAdd(aIndTZ7,{cMod,"BACK","2","ATE_AREA"   ,""})
			aAdd(aIndTZ7,{cMod,"BACK","2","ATE_DATA"   ,""})
			aAdd(aIndTZ7,{cMod,"BACK","2","ATE_ESPEC"  ,""})
			aAdd(aIndTZ7,{cMod,"BACK","2","ATE_FUNCI"  ,""})
			aAdd(aIndTZ7,{cMod,"BACK","2","DE_DATA"    ,""})

			aAdd(aIndTZ7,{cMod,"CHMC","2","ATE_CCUSTO" ,""})
			aAdd(aIndTZ7,{cMod,"CHMC","2","ATE_DATA"   ,""})
			aAdd(aIndTZ7,{cMod,"CHMC","2","DE_DATA"    ,""})

			aAdd(aIndTZ7,{cMod,"CHMP","2","ATE_DATA"   ,""})
			aAdd(aIndTZ7,{cMod,"CHMP","2","DE_DATA"    ,""})
			aAdd(aIndTZ7,{cMod,"CHMP","2","ATE_CCUSTO" ,""})

			aAdd(aIndTZ7,{cMod,"CMDM","2","ATE_CCUSTO" ,""})
			aAdd(aIndTZ7,{cMod,"CMDM","2","ATE_DATA"   ,""})
			aAdd(aIndTZ7,{cMod,"CMDM","2","DE_DATA"    ,""})
			aAdd(aIndTZ7,{cMod,"CMDM","2","TIP_ORDEM"  ,""})

			aAdd(aIndTZ7,{cMod,"EPEP","2","ATE_DATA"   ,""})
			aAdd(aIndTZ7,{cMod,"EPEP","2","DE_DATA"    ,""})

			aAdd(aIndTZ7,{cMod,"PEXE","2","ATE_BEM"    ,""})
			aAdd(aIndTZ7,{cMod,"PEXE","2","ATE_CCUSTO" ,""})
			aAdd(aIndTZ7,{cMod,"PEXE","2","ATE_CENTRA" ,""})
			aAdd(aIndTZ7,{cMod,"PEXE","2","ATE_OS"     ,""})
			aAdd(aIndTZ7,{cMod,"PEXE","2","ATE_PLANO"  ,""})

			aAdd(aIndTZ7,{cMod,"PTMP","2","ATE_CCUSTO" ,""})
			aAdd(aIndTZ7,{cMod,"PTMP","2","ATE_DATA"   ,""})
			aAdd(aIndTZ7,{cMod,"PTMP","2","DE_DATA"    ,""})

			aAdd(aIndTZ7,{cMod,"PTOT","2","ATE_AREA"   ,""})
			aAdd(aIndTZ7,{cMod,"PTOT","2","ATE_DATA"   ,""})
			aAdd(aIndTZ7,{cMod,"PTOT","2","DE_DATA"    ,""})

			If !lRPORel17
				aAdd(aIndTZ7,{cMod,"MTBF","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"MTBF","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"MTBF","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"MTBF","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"MTBF","2","ATE_CENTRA" ,""})
				aAdd(aIndTZ7,{cMod,"MTBF","2","CON_CALEND" ,""})
				aAdd(aIndTZ7,{cMod,"MTBF","2","CON_ANTDPS" ,""})
				aAdd(aIndTZ7,{cMod,"MTBF","2","CON_SOBOS"  ,""})
				aAdd(aIndTZ7,{cMod,"MTBF","2","CON_MINOS"  ,""})
				aAdd(aIndTZ7,{cMod,"MTBF","2","CON_PARADA" ,""})
			Else
				aAdd(aIndTZ7,{cMod,"TMEF","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"TMEF","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"TMEF","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"TMEF","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"TMEF","2","ATE_CENTRA" ,""})
				aAdd(aIndTZ7,{cMod,"TMEF","2","CON_CALEND" ,""})
				aAdd(aIndTZ7,{cMod,"TMEF","2","CON_ANTDPS" ,""})
			Endif

			aAdd(aIndTZ7,{cMod,"TMMP","2","ATE_BEM"    ,""})
			aAdd(aIndTZ7,{cMod,"TMMP","2","ATE_CCUSTO" ,""})
			aAdd(aIndTZ7,{cMod,"TMMP","2","ATE_CENTRA" ,""})
			aAdd(aIndTZ7,{cMod,"TMMP","2","ATE_DATA"   ,""})
			aAdd(aIndTZ7,{cMod,"TMMP","2","DE_DATA"    ,""})

			If !lRPORel17
				aAdd(aIndTZ7,{cMod,"MTTR","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"MTTR","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"MTTR","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"MTTR","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"MTTR","2","ATE_CENTRA" ,""})
				aAdd(aIndTZ7,{cMod,"MTTR","2","CON_SOBOS"  ,""})
				aAdd(aIndTZ7,{cMod,"MTTR","2","CON_MINOS"  ,""})
				aAdd(aIndTZ7,{cMod,"MTTR","2","CON_PARADA" ,""})
			Else
				aAdd(aIndTZ7,{cMod,"TMPR","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"TMPR","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"TMPR","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"TMPR","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"TMPR","2","ATE_CENTRA" ,""})
			Endif

			aAdd(aIndTZ7,{cMod,"QSOL","2","DE_DATA"    ,""})
			aAdd(aIndTZ7,{cMod,"QSOL","2","ATE_DATA"   ,""})
			aAdd(aIndTZ7,{cMod,"QSOL","2","ATE_BEM"    ,""})
			aAdd(aIndTZ7,{cMod,"QSOL","2","ATE_LOCALI" ,""})
			aAdd(aIndTZ7,{cMod,"QSOL","2","ATE_CCUSTO" ,""})
			aAdd(aIndTZ7,{cMod,"QSOL","2","ATE_CENTRA" ,""})
			aAdd(aIndTZ7,{cMod,"QSOL","2","ATE_SOLICI" ,""})
			aAdd(aIndTZ7,{cMod,"QSOL","2","SIT_SOLICI" ,""})

			aAdd(aIndTZ7,{cMod,"QTOS","2","DE_DATA"    ,""})
			aAdd(aIndTZ7,{cMod,"QTOS","2","ATE_DATA"   ,""})
			aAdd(aIndTZ7,{cMod,"QTOS","2","ATE_CCUSTO" ,""})
			aAdd(aIndTZ7,{cMod,"QTOS","2","ATE_CENTRA" ,""})
			aAdd(aIndTZ7,{cMod,"QTOS","2","ATE_AREA"   ,""})
			aAdd(aIndTZ7,{cMod,"QTOS","2","ATE_BEM"    ,""})
			aAdd(aIndTZ7,{cMod,"QTOS","2","ATE_SERVICO",""})
			aAdd(aIndTZ7,{cMod,"QTOS","2","ATE_PLANO"  ,""})
			aAdd(aIndTZ7,{cMod,"QTOS","2","ATE_TPMNT"  ,""})
			aAdd(aIndTZ7,{cMod,"QTOS","2","SIT_OS"     ,""})
			aAdd(aIndTZ7,{cMod,"QTOS","2","TIP_ORDEM"  ,""})
			aAdd(aIndTZ7,{cMod,"QTOS","2","TERMINO_OS" ,""})

			aAdd(aIndTZ7,{cMod,"SCSO","2","DE_DATA"    ,""})
			aAdd(aIndTZ7,{cMod,"SCSO","2","ATE_DATA"   ,""})
			aAdd(aIndTZ7,{cMod,"SCSO","2","ATE_BEM"    ,""})
			aAdd(aIndTZ7,{cMod,"SCSO","2","ATE_LOCALI" ,""})
			aAdd(aIndTZ7,{cMod,"SCSO","2","ATE_CCUSTO" ,""})
			aAdd(aIndTZ7,{cMod,"SCSO","2","ATE_AREA"   ,""})
			aAdd(aIndTZ7,{cMod,"SCSO","2","ATE_SERVICO",""})
			aAdd(aIndTZ7,{cMod,"SCSO","2","ATE_CENTRA" ,""})

			aAdd(aIndTZ7,{cMod,"PTMC","2","DE_DATA"    ,""})
			aAdd(aIndTZ7,{cMod,"PTMC","2","ATE_DATA"   ,""})
			aAdd(aIndTZ7,{cMod,"PTMC","2","ATE_CCUSTO" ,""})

			If lGFrotas
				aAdd(aIndTZ7,{cMod,"MRPL" ,"2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"MRPL" ,"2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"MRPL" ,"2","ATE_FAMILIA",""})
				aAdd(aIndTZ7,{cMod,"MRPL" ,"2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"MRPL" ,"2","ATE_CENTRA" ,""})

				aAdd(aIndTZ7,{cMod,"CPRO" ,"2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"CPRO" ,"2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"CPRO" ,"2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"CPRO" ,"2","ATE_CENTRA" ,""})
				aAdd(aIndTZ7,{cMod,"CPRO" ,"2","ATE_FAMILIA",""})

				aAdd(aIndTZ7,{cMod,"CRPR" ,"2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"CRPR" ,"2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"CRPR" ,"2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"CRPR" ,"2","ATE_CENTRA" ,""})
				aAdd(aIndTZ7,{cMod,"CRPR" ,"2","ATE_FAMILIA",""})
				aAdd(aIndTZ7,{cMod,"CRPR" ,"2","TIP_CUS"    ,""})

				aAdd(aIndTZ7,{cMod,"CTAB" ,"2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"CTAB" ,"2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"CTAB" ,"2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"CTAB" ,"2","ATE_CENTRA" ,""})
				aAdd(aIndTZ7,{cMod,"CTAB" ,"2","ATE_FAMILIA",""})

				aAdd(aIndTZ7,{cMod,"CTDO" ,"2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"CTDO" ,"2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"CTDO" ,"2","ATE_FAMILIA",""})

				aAdd(aIndTZ7,{cMod,"CTMU" ,"2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"CTMU" ,"2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"CTMU" ,"2","ATE_FAMILIA",""})
				aAdd(aIndTZ7,{cMod,"CTMU" ,"2","TIP_MUL"    ,""})

				aAdd(aIndTZ7,{cMod,"CTPN" ,"2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"CTPN" ,"2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"CTPN" ,"2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"CTPN" ,"2","ATE_CENTRA" ,""})
				aAdd(aIndTZ7,{cMod,"CTPN" ,"2","ATE_FAMILIA",""})
				aAdd(aIndTZ7,{cMod,"CTPN" ,"2","CON_VAL"    ,""})

				aAdd(aIndTZ7,{cMod,"CTPR" ,"2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"CTPR" ,"2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"CTPR" ,"2","ATE_FAMILIA",""})

				aAdd(aIndTZ7,{cMod,"CTPSI","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"CTPSI","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"CTPSI","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"CTPSI","2","ATE_CENTRA" ,""})
				aAdd(aIndTZ7,{cMod,"CTPSI","2","ATE_FAMILIA",""})

				aAdd(aIndTZ7,{cMod,"PMPM" ,"2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"PMPM" ,"2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"RMDA","2","DE_DATA"     ,""})
				aAdd(aIndTZ7,{cMod,"RMDA","2","ATE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"RMDA","2","ATE_FAMILIA" ,""})
				aAdd(aIndTZ7,{cMod,"RMDA","2","ATE_MODELO"  ,""})
				aAdd(aIndTZ7,{cMod,"RMDA","2","ATE_CCUSTO"  ,""})
				aAdd(aIndTZ7,{cMod,"RMDA","2","ATE_CENTRA"  ,""})
				aAdd(aIndTZ7,{cMod,"RMDA","2","ADITIVO"     ,""})
			EndIf

			If lFacilit // Facilities
				aAdd(aIndTZ7,{cMod,"SSQPRAZO","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"SSQPRAZO","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"SSQPRAZO","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"SSQPRAZO","2","ATE_LOCALI" ,""})
				aAdd(aIndTZ7,{cMod,"SSQPRAZO","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"SSQPRAZO","2","ATE_SERVICO",""})
				aAdd(aIndTZ7,{cMod,"SSQPRAZO","2","ATE_CENTRA" ,""})

				aAdd(aIndTZ7,{cMod,"SSQENCCAN","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"SSQENCCAN","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"SSQENCCAN","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"SSQENCCAN","2","ATE_LOCALI" ,""})
				aAdd(aIndTZ7,{cMod,"SSQENCCAN","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"SSQENCCAN","2","ATE_SERVICO",""})
				aAdd(aIndTZ7,{cMod,"SSQENCCAN","2","ATE_CENTRA" ,""})

				aAdd(aIndTZ7,{cMod,"SSQFORA","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"SSQFORA","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"SSQFORA","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"SSQFORA","2","ATE_LOCALI" ,""})
				aAdd(aIndTZ7,{cMod,"SSQFORA","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"SSQFORA","2","ATE_SERVICO",""})
				aAdd(aIndTZ7,{cMod,"SSQFORA","2","ATE_CENTRA" ,""})

				aAdd(aIndTZ7,{cMod,"SSPPRAZO","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"SSPPRAZO","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"SSPPRAZO","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"SSPPRAZO","2","ATE_LOCALI" ,""})
				aAdd(aIndTZ7,{cMod,"SSPPRAZO","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"SSPPRAZO","2","ATE_SERVICO",""})
				aAdd(aIndTZ7,{cMod,"SSPPRAZO","2","ATE_CENTRA" ,""})

				aAdd(aIndTZ7,{cMod,"SSPFORA","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"SSPFORA","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"SSPFORA","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"SSPFORA","2","ATE_LOCALI" ,""})
				aAdd(aIndTZ7,{cMod,"SSPFORA","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"SSPFORA","2","ATE_SERVICO",""})
				aAdd(aIndTZ7,{cMod,"SSPFORA","2","ATE_CENTRA" ,""})

				aAdd(aIndTZ7,{cMod,"SSPDISTF","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"SSPDISTF","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"SSPDISTF","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"SSPDISTF","2","ATE_LOCALI" ,""})
				aAdd(aIndTZ7,{cMod,"SSPDISTF","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"SSPDISTF","2","ATE_SERVICO",""})
				aAdd(aIndTZ7,{cMod,"SSPDISTF","2","ATE_CENTRA" ,""})
			EndIf

			If !lRPORel17 // Caso seja uma versão superior a release 12.1.17
				// Indicadores Mundiais.
				aAdd(aIndTZ7,{cMod,"MTTF","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"MTTF","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"MTTF","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"MTTF","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"MTTF","2","ATE_CENTRA" ,""})
				aAdd(aIndTZ7,{cMod,"MTTF","2","CON_CALEND" ,""})
				aAdd(aIndTZ7,{cMod,"MTTF","2","CON_ANTDPS" ,""})
				aAdd(aIndTZ7,{cMod,"MTTF","2","CON_PARADA" ,""})

				aAdd(aIndTZ7,{cMod,"DISP","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"DISP","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"DISP","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"DISP","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"DISP","2","ATE_CENTRA" ,""})
				aAdd(aIndTZ7,{cMod,"DISP","2","CON_SOBOS"  ,""})
				aAdd(aIndTZ7,{cMod,"DISP","2","CON_PARADA" ,""})

				aAdd(aIndTZ7,{cMod,"CONF","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"CONF","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"CONF","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"CONF","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"CONF","2","ATE_CENTRA" ,""})
				aAdd(aIndTZ7,{cMod,"CONF","2","CON_SOBOS"  ,""})
				aAdd(aIndTZ7,{cMod,"CONF","2","CON_PARADA" ,""})

				aAdd(aIndTZ7,{cMod,"CMFT","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"CMFT","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"CMFT","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"CMFT","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"CMFT","2","ATE_CENTRA" ,""})
				aAdd(aIndTZ7,{cMod,"CMFT","2","TIP_ORDEM"  ,""})
				aAdd(aIndTZ7,{cMod,"CMFT","2","FAT_PERIOD" ,""})

				aAdd(aIndTZ7,{cMod,"CMVR","2","DE_DATA"    ,""})
				aAdd(aIndTZ7,{cMod,"CMVR","2","ATE_DATA"   ,""})
				aAdd(aIndTZ7,{cMod,"CMVR","2","ATE_BEM"    ,""})
				aAdd(aIndTZ7,{cMod,"CMVR","2","ATE_CCUSTO" ,""})
				aAdd(aIndTZ7,{cMod,"CMVR","2","ATE_CENTRA" ,""})
				aAdd(aIndTZ7,{cMod,"CMVR","2","TIP_ORDEM"  ,""})
			EndIf

			If AliasInDic("TZ9")
				//--------------------------------------------------
				// TZ9 - Indicadores Gráficos
				//--------------------------------------------------
				//   1      ; 2      ; 3         ; 4            ; 5    ; 6    ; 7       ; 8      ; 9      ; 10     ; 11
				//-- Código ; Título ; Subtítulo ; Proprietário ; Data ; Hora ; Usuário ; Ativo? ; Módulo ; Modelo ; Tipo de Conteúdo ;
				//   12       ; 13       ; 14       ; 15       ; 16       ; 17       ; 18
				//-- Valor 01 ; Valor 02 ; Valor 03 ; Valor 04 ; Valor 05 ; Valor 06 ; Valor 07 ;
				//   19           ; 20           ; 21        ; 22        ; 23
				//-- Seção Mínima ; Seção Máxima ; Sombra 1? ; Sombra 2? ; Sombra 3? ;
				//   24     ; 25     ; 26     ; 27     ; 28     ; 29     ; 30     ; 31     ; 32     ; 33     ; 34     ; 35     ; 36     ; 37
				//-- Cor 01 ; Cor 02 ; Cor 03 ; Cor 04 ; Cor 05 ; Cor 06 ; Cor 07 ; Cor 08 ; Cor 09 ; Cor 10 ; Cor 11 ; Cor 12 ; Cor 13 ; Cor 14 ;
				//   38                      ; 39                             ; 40
				//-- Legenda da Seção Mínima ; Legenda da Seção Intermediária ; Legenda da Seção Máxima
				//  41
				//-- {Indicadores associados}
				aValores := {0, 1080, 2160, 3240, 4320, Nil, Nil}
				aCores   := {"#FFFFFF", "#C8C8C8", "#969696", "#646464", "#000000", "#000000", "#FFFFFF", "#B4B4B4", "#F5F5F5", "#000000", "#000000", "#FFFFFF", "#000000", "#FFFFFF"}
				aLegenda := {STR1361, STR1362, STR1363} //"Muito Bom" ## "Aceitável" ## "Inaceitável"
				aIndsRelac := {"BACK"}
				aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1364, "Horas", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "7", "2", ; //"Tempo Atend. Manutenção"
								aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
								50, 75, "1", "1", "1", ;
								aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
								aLegenda[1], aLegenda[2], aLegenda[3], ;
								aIndsRelac, ;
								STR1365 + cAuxPeriod}) //"Tempo para Atendimento de Manutenções."

				aValores := {0, 225000, 450000, 675000, 900000, Nil, Nil}
				aCores   := {"#FCFCFC", "#40FF40", "#FFFF40", "#FF4040", "#000000", "#000000", "#FFFFFF", "#B4B4B4", "#F5F5F5", "#000000", "#000000", "#FFFFFF", "#000000", "#FFFFFF"}
				aLegenda := {STR1366, STR1367, STR1368} //"Ideal" ## "Acima do Ideal" ## "Custo excessivo"
				aIndsRelac := {"CHMC", "CHMP", "CMUP"}
				aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1369 , "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "8", "1", ; //"Custo Total Manutenções"
								aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
								40, 80, "1", "1", "1", ;
								aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
								aLegenda[1], aLegenda[2], aLegenda[3], ;
								aIndsRelac, ;
								STR1370 + cAuxPeriod}) //"Custo Total com Manutenções."

				aValores := {0, 112500, 225000, 337500, 450000, Nil, Nil}
				aCores   := {"#F0F0F0", "#40FF40", "#FFFF40", "#FF4040", "#000000", "#000000", "#FFFFFF", "#404040", "#F5F5F5", "#000000", "#000000", "#FFFFFF", "#000000", "#FFFFFF"}
				aLegenda := {STR1366, STR1367, STR1368} //"Ideal" ## "Acima do ideal" ## "Custo excessivo"
				aIndsRelac := {"CMDM"}
				aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1371, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "5", "1", ; //"Custo Médio Manutenções"
								aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
								40, 80, "1", "1", "1", ;
								aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
								aLegenda[1], aLegenda[2], aLegenda[3], ;
								aIndsRelac, ;
								STR1372 + cAuxPeriod}) //"Custo Médio com Manutenções."

				If lGFrotas

					aValores := {0, 225000, 450000, 675000, 900000, Nil, Nil}
					aCores   := {"#F5F5F5", "#8CF0FF", "#50B4FF", "#1478FF", "#000000", "#000000", "#FFFFFF", "#808080", "#F5F5F5", "#000000", "#000000", "#FFFFFF", "#000000", "#FFFFFF"}
					aLegenda := {STR1375, STR1376, STR1368} //"Esperado" ## "Acima do esperado" ## "Custo excessivo"
					aIndsRelac := {"CTAB"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1373, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "4", "1", ; //"Custo Tot. Abastecimentos"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									35, 70, "1", "1", "1", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									+ cAuxPeriod}) //"Custo Total com Abastecimentos."

					aValores := {0, 225000, 450000, 675000, 900000, Nil, Nil}
					aCores   := {"#F5F5F5", "#8000FF", "#8040FF", "#8080FF", "#000000", "#000000", "#FFFFFF", "#808080", "#F5F5F5", "#000000", "#000000", "#FFFFFF", "#000000", "#FFFFFF"}
					aLegenda := {STR1375, STR1376, STR1368} //"Esperado" ## "Acima do esperado" ## "Custo excessivo"
					aIndsRelac := {"CTDO", "CTMU"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1377, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "8", "1", ; //"Custo Tot. Multas/Docs"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									40, 80, "1", "1", "1", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1378 + cAuxPeriod}) //"Custo Total com Multa/Documentos."

					aValores := {0, 150000, 300000, 450000, 600000, 750000, 900000}
					aCores   := {"#FFFFFF", "#629EE6", "#8CAEDD", "#BFD5F9", "#000000", "#000000", "#FFFFFF", "#404040", "#F5F5F5", "#000000", "#000000", "#000000", "#000000", "#000000"}
					aLegenda := {STR1375, STR1376, STR1368} //"Esperado" ## "Acima do esperado" ## "Custo excessivo"
					aIndsRelac := {"CTPN"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1379, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "1", "1", ; //"Custo Total Pneus"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									40, 80, "1", "1", "1", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1380 + cAuxPeriod}) //"Custo Total com Pneus."

					aValores := {0, 150000, 300000, 450000, 600000, 750000, 900000}
					aCores   := {"#FFFFFF", "#505050", "#787878", "#A0A0A0", "#808080", "#000000", "#FFFFFF", "#A0A0A0", "#FCFCFC", "#000000", "#000000", "#808080", "#000000", "#000000"}
					aLegenda := {STR1375, STR1376, STR1368} //"Esperado" ## "Acima do esperado" ## "Custo excessivo"
					aIndsRelac := {"CRPR"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1381, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "1", "1", ; //"Custo Total Rodagem"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									40, 80, "1", "1", "1", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1382 + cAuxPeriod}) //"Custo Total de Rodagem."

					aValores := {0, 60000, 120000, 180000, 240000, 300000, 360000}
					aCores   := {"#FFFFFF", "#FF4000", "#FF8040", "#FFB496", "#000000", "#000000", "#FFFFFF", "#808080", "#FFFFFF", "#000000", "#000000", "#000000", "#000000", "#000000"}
					aLegenda := {STR1375, STR1376, STR1368} //"Esperado" ## "Acima do esperado" ## "Custo excessivo"
					aIndsRelac := {"CTPR", "CTPSI"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1383, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "1", "1", ; //"Custo por Rodagem/Sinist."
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									33.33, 66.67, "1", "1", "1", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1384 + cAuxPeriod}) //"Custo Total por Rodagem/Sinistro."

					aValores := {0, 45000, 90000, 135000, 180000, Nil, Nil}
					aCores   := {"#FFFFFF", "#FA7800", "#DC5A00", "#BE3C00", "#FFF0F0", "#000000", "#FFFFFF", "#808080", "#FFFFFF", "#000000", "#000000", "#000000", "#000000", "#000000"}
					aLegenda := {STR1385, STR1386, STR1368} //"Dentro da média" ## "Acima da média" ## "Custo excessivo"
					aIndsRelac := {"CPRO"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1387, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "3", "1", ; //"Custo Sinist. x Rodagem"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									40, 80, "1", "1", "1", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1388 + cAuxPeriod}) //"Custo Médio Sinistros x Rodagem."

				EndIf

				aValores := {0, 25, 50, 75, 100, Nil, Nil}
				aCores   := {"#FFFFFF", "#40AA40", "#40D240", "#40FF40", "#FFF0F0", "#000000", "#FFFFFF", "#80C8C8", "#FFFFFF", "#000000", "#000000", "#FFF0F0", "#FFFFFF", "#000000"}
				aLegenda := {STR1389, STR1390, STR1361} //"Insatisfatório" ## "Satisfatório" ## "Muito Bom"
				aIndsRelac := {"EPEP"}
				aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1391, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "A", "1", ; //"Efic. Equipe Preventiva"
								aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
								50, 80, "1", "1", "2", ;
								aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
								aLegenda[1], aLegenda[2], aLegenda[3], ;
								aIndsRelac, ;
								STR1392 + cAuxPeriod}) //"Eficiência de Equipe Preventiva."

				If lGFrotas

					aValores := {0, 5, 10, 15, 20, Nil, Nil}
					aCores   := {"#FFFFFF", "#0000FF", "#40C8FF", "#40FFFF", "#FFF0F0", "#000000", "#FFFFFF", "#000000", "#FFFFFF", "#000000", "#000000", "#000000", "#202020", "#000000"}
					aLegenda := {STR1393, STR1385, STR1394} //"Consumo excessivo" ## "Dentro da média" ## "Econômico!"
					aIndsRelac := {"MRPL"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1395, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "9", "1", ; //"Média Rodagem x Litro"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									30, 60, "1", "1", "1", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1396 + cAuxPeriod}) //"Média de Rodagem por Litro."

				EndIf

				aValores := {0, 25, 50, 75, 100, Nil, Nil}
				aCores   := {"#FFFFFF", "#FF2020", "#FF8020", "#20FF20", "#FFF0F0", "#000000", "#FFFFFF", "#000000", "#FFFFFF", "#000000", "#000000", "#000000", "#202020", "#000000"}
				aLegenda := {STR1397, STR1385, STR1398} //"Abaixo do esperado" ## "Dentro da média" ## "Maioria, ou todas, as etapas foram executadas"
				aIndsRelac := {"PEXE"}
				aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1399, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "B", "1", ; //"Perc. Etapas Executadas"
								aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
								50, 80, "1", "1", "1", ;
								aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
								aLegenda[1], aLegenda[2], aLegenda[3], ;
								aIndsRelac, ;
								STR1400 + cAuxPeriod}) //"Percentual de Etapas Executadas."

				If lGFrotas

					aValores := {0, 5, 10, 15, 20, Nil, Nil}
					aCores   := {"#FFFFFF", "#00FF00", "#FFFF00", "#FF0000", "#FFF0F0", "#000000", "#FFFFFF", "#000000", "#FFFFFF", "#000000", "#000000", "#505050", "#C8C8C8", "#000000"}
					aLegenda := {STR1362, STR1363, STR1401} //"Aceitável" ## "Inaceitável" ## "Crítico! (Risco de perda de habilitação)"
					aIndsRelac := {"PMPM"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1402, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "9", "1", ; //"Média Pontos Motoristas"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									33.33, 66.67, "1", "1", "1", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1403 + cAuxPeriod}) //"Média de Pontos por Motorista."

				EndIf

				aValores := {0, 25, 50, 75, 100, Nil, Nil}
				aCores   := {"#FFFFFF", "#002096", "#0078C8", "#00C8FA", "#FFF0F0", "#000000", "#FFFFFF", "#000000", "#FFFFFF", "#000000", "#000000", "#FFFFFF", "#C8C8C8", "#000000"}
				aLegenda := {STR1404, STR1405, STR1406} //"Minoria das Horas em Manutenção" ## "Horas equilibradas" ## "Maioria das Horas em Manutenção"
				aIndsRelac := {"PTMC", "PTMP", "PTOT"}
				aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1407, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "3", "1", ; //"Perc. Utilizacao Manut."
								aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
								33.33, 66.67, "1", "1", "1", ;
								aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
								aLegenda[1], aLegenda[2], aLegenda[3], ;
								aIndsRelac, ;
								STR1408 + cAuxPeriod}) //"Percentual de Utilização de Mão-de-Obra em Manutenção."

				aValores := {0,   7200,  14400,  21600, 28800, 36000, 43200}
				aCores   := {"#F1F4F5", "#25578D", "#4A8BDB", "#7FC5EF", "#879AA6", "#000000", "#FFFFFF", "#000000", "#FFFFFF", "#000000", "#000000", "#000000", "#C8C8C8", "#000000"}
				aLegenda := {STR1409, STR1410, STR1411} //"Ruim (falhas muito frequentes)" ## "Razoável" ## "Bom (maior durabilidade)"}
				If !lRPORel17
					aIndsRelac := {"MTBF", "TMMP", "MTTF"}
				Else
					aIndsRelac := {"TMEF", "TMMP", "MTTF"}
				Endif
				aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1412, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "2", "2", ; //"Tempo para Manutenções"
								aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
								33.33, 66.67, "1", "1", "1", ;
								aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
								aLegenda[1], aLegenda[2], aLegenda[3], ;
								aIndsRelac, ;
								STR1413 + cAuxPeriod}) //"Tempo para efetuar Manutenções."

				aValores := {0,   7200,  14400,  21600, 28800, 36000, 43200}
				aCores   := {"#FFFFFF", "#25578D", "#4A8BDB", "#7FC5EF", "#DCDCDC", "#000000", "#FFFFFF", "#000000", "#FFFFFF", "#000000", "#000000", "#DCDCDC", "#C8C8C8", "#000000"}
				aLegenda := {STR1414, STR1410, STR1415} //"Bom (reparo rápido)" ## "Razoável" ## "Ruim (maior ociosidade)"
				aIndsRelac := {"MTTR"}
				aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1416, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "2", "2", ; //"Tempo para Reparos"
								aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
								33.33, 66.67, "1", "1", "1", ;
								aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
								aLegenda[1], aLegenda[2], aLegenda[3], ;
								aIndsRelac, ;
								STR1417 + cAuxPeriod}) //"Tempo para efetuar Reparos."

				aValores := {0, 450, 900, 1350, 1800, Nil, Nil}
				aCores   := {"#EBFFFF", "#00364A", "#00689C", "#00ADEB", "#000000", "#000000", "#FFFFFF", "#8A8AC8", "#F5F5F5", "#000000", "#000000", "#FFFFFF", "#6167FE", "#FFFFFF"}
				aLegenda := {STR1418, STR1419, STR1420} //"Quantidade Esperada" ## "Quantidade acima da média esperada" ## "Quantidade muito acima do esperado! (crítico)"
				aIndsRelac := {"QSOL", "QTOS", "SCSO"}
				If lFacilit // Facilities
					aAdd(aIndsRelac, "SSQENCCAN")
				EndIf
				aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1421, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "8", "1", ; //"Quantidade de S.S."
								aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
								10, 50, "1", "1", "1", ;
								aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
								aLegenda[1], aLegenda[2], aLegenda[3], ;
								aIndsRelac, ;
								STR1422 + cAuxPeriod}) //"Quantidade de Solicitações de Serviço."

				If lGFrotas

					aValores := {0,   400,  800,  1200, 1600, 2000, 2400}
					aCores   := {"#F1F4F5", "#25578D", "#4A8BDB", "#7FC5EF", "#879AA6", "#000000", "#FFFFFF", "#000000", "#FFFFFF", "#000000", "#000000", "#000000", "#C8C8C8", "#000000"}
					aLegenda := {STR1423, STR1390, STR1361}  //"Ruim" ## "Satisfatório" ## "Muito Bom"
					aIndsRelac := {"RMDA"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1424, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "2", "1", ; //"Rendimento Médio de Aditivo"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									33.33, 66.67, "1", "1", "1", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1424 + cAuxPeriod}) //"Rendimento Médio de Aditivo"

				EndIf

				If lFacilit // Facilities
					aValores := {0, 450, 900, 1350, 1800, Nil, Nil}
					aCores   := {"#FFFFFF", "#FF2020", "#FFFF40", "#40FF40", "#000000", "#1F2793", "#FFFFFF", "#8A8AC8", "#F5F5F5", "#000000", "#000000", "#FFFFFF", "#1F2793", "#FFFFFF"}
					aLegenda := {STR1423, STR1390, STR1361} //"Ruim" ## "Satisfatório" ## "Muito Bom"
					aIndsRelac := {"SSQPRAZO"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1425, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "7", "1", ; //"Quant. S.S. no Prazo"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									40, 70, "1", "1", "1", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1426 + cAuxPeriod}) //"Quantidade de Solicitações de Serviço atendidas dentro do prazo."

					aValores := {0, 450, 900, 1350, 1800, Nil, Nil}
					aCores   := {"#FFFFFF", "#40FF40", "#FFFF40", "#FF2020", "#000000", "#1F2793", "#FFFFFF", "#8A8AC8", "#F5F5F5", "#000000", "#000000", "#FFFFFF", "#1F2793", "#FFFFFF"}
					aLegenda := {STR1390, STR1423, STR1427} //"Satisfatório" ## "Ruim" ## "Muito Ruim"
					aIndsRelac := {"SSQFORA"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1428, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "7", "1", ; //"Quant. S.S. Fora Prazo"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									40, 70, "1", "1", "1", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1429+ cAuxPeriod}) //"Quantidade de Solicitações de Serviço atendidas ou distribuídas fora do prazo."

					aValores := {0, 25, 50, 75, 100, Nil, Nil}
					aCores   := {"#FFFFFF", "#FF2020", "#FFFF40", "#40FF40", "#000000", "#1F2793", "#FFFFFF", "#8A8AC8", "#F5F5F5", "#000000", "#000000", "#FFFFFF", "#FFFFFF", "#FFFFFF"}
					aLegenda := {STR1423, STR1390, STR1361} //"Ruim" ## "Satisfatório" ## "Muito Bom"
					aIndsRelac := {"SSPPRAZO"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1430, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "A", "1", ; //"Perc. S.S. no Prazo"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									40, 70, "1", "1", "1", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1431 + cAuxPeriod}) //"Percentual de Solicitações de Serviço atendidas dentro do Prazo."

					aValores := {0, 25, 50, 75, 100, Nil, Nil}
					aCores   := {"#F5F5F5", "#10C810", "#C8C810", "#C81010", "#000000", "#1F2793", "#FFFFFF", "#8A8AC8", "#F5F5F5", "#000000", "#000000", "#FFFFFF", "#FFFFFF", "#FFFFFF"}
					aLegenda := {STR1390, STR1423, STR1427} //"Satisfatório" ## "Ruim" ## "Muito Ruim"
					aIndsRelac := {"SSPFORA", "SSPDISTF"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"), STR1432, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "3", "1", ; //"Perc. S.S. Fora Prazo"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									40, 70, "1", "1", "1", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1433 + cAuxPeriod}) //"Percentual de Solicitações de Serviço atendidas ou distribuídas fora do prazo."
				EndIf

				If !lRPORel17 // Caso seja uma versão superior a release 12.1.17
					// Indicadores Mundiais (NGKPI)
					aValores := {0, 5, 50, 80, 100, nil, Nil}
					aCores   := {"#FFFFFF", "#EE0000", "#FFA500", "#00EE00", "#000000", "#000000", "#FFFFFF", "#000000", "#F5F5F5", "#000000", "#000000", "#000000", "#000000", "#000000"}
					aLegenda := {STR1390, STR1423, STR1427} //"Satisfatório" ## "Ruim" ## "Muito Ruim"
					aIndsRelac := {"CONF", "DISP"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"),STR1434, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "7", "1", ; // "Percentual do Equipamento"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									33, 66, "2", "2", "2", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1435 + cAuxPeriod}) //"Percentual Total do Equipamento."

					aValores := {0, 15, 50, 75, 100, Nil, Nil}
					aCores   := {"#FFFFFF", "#00EE00", "#FFA500", "#EE0000", "#000000", "#000000", "#FFFFFF", "#000000", "#F5F5F5", "#000000", "#000000", "#000000", "#000000", "#000000"}
					aLegenda := {STR1366, STR1367, STR1368} //"Ideal" ## "Acima do Ideal" ## "Custo excessivo"
					aIndsRelac := {"CMFT", "CMVR"}
					aAdd(aIndTZ9,{GETSXENUM("TZ9", "TZ9_CODIGO"),STR1436, "", "1", dDataAtual, cHoraAtual, cCodUsrAtu, "1", cMod, "A", "1", ; //"Custo Total Manutenções"
									aValores[1], aValores[2], aValores[3], aValores[4], aValores[5], aValores[6], aValores[7], ;
									33, 66, "2", "2", "2", ;
									aCores[1], aCores[2], aCores[3], aCores[4], aCores[5], aCores[6], aCores[7], aCores[8], aCores[9], aCores[10], aCores[11], aCores[12], aCores[13], aCores[14], ;
									aLegenda[1], aLegenda[2], aLegenda[3], ;
									aIndsRelac, ;
									STR1437 + cAuxPeriod}) //"Percentuais Total de Custo."

				EndIf

				//--------------------------------------------------
				// TZB - Painéis de Indicadores Gráficos
				//--------------------------------------------------
				//   1      ; 2    ; 3       ; 4      ; 5      ; 6
				//-- Código ; Nome ; Usuário ; Módulo ; Ativo? ; {Indicadores associados}
				If lGFrotas
					aAdd(aIndTZB, {"01", STR1128, cCodUsrAtu, cMod, "1", aClone( fRetArrTZC("01", aIndTZ5) )}) //"Abastecimento"
					aAdd(aIndTZB, {"02", STR1129, cCodUsrAtu, cMod, "1", aClone( fRetArrTZC("02", aIndTZ5) )}) //"Pneus"
					aAdd(aIndTZB, {"03", STR1130, cCodUsrAtu, cMod, "1", aClone( fRetArrTZC("03", aIndTZ5) )}) //"Multas"
					aAdd(aIndTZB, {"04", STR1131, cCodUsrAtu, cMod, "1", aClone( fRetArrTZC("04", aIndTZ5) )}) //"Sinistros"
					aAdd(aIndTZB, {"05", STR1132, cCodUsrAtu, cMod, "1", aClone( fRetArrTZC("05", aIndTZ5) )}) //"Documentos"
					aAdd(aIndTZB, {"06", STR1133, cCodUsrAtu, cMod, "1", aClone( fRetArrTZC("06", aIndTZ5) )}) //"Frota Geral"
					aAdd(aIndTZB, {"07", STR1134, cCodUsrAtu, cMod, "1", aClone( fRetArrTZC("07", aIndTZ5) )}) //"Oficina"
				Else
					aAdd(aIndTZB, {"01", STR1135, cCodUsrAtu, cMod, "1", aClone( fRetArrTZC("01", aIndTZ5) )}) //"Desempenho"
					aAdd(aIndTZB, {"02", STR1136, cCodUsrAtu, cMod, "1", aClone( fRetArrTZC("02", aIndTZ5) )}) //"Mão-de-Obra"
					aAdd(aIndTZB, {"03", STR1137, cCodUsrAtu, cMod, "1", aClone( fRetArrTZC("03", aIndTZ5) )}) //"Custos/Controle Materiais"
				EndIf

				If lFacilit // Facilities
					aAdd(aIndTZB, {If(!lGFrotas,"04","08"), STR1138, cCodUsrAtu, cMod, "1", aClone( fRetArrTZC(If(!lGFrotas,"04","08"), aIndTZ5) )})
				EndIf
			EndIf

			If !lRPORel17 // Caso seja uma versão superior a release 12.1.17
				// Nomes de indicadores que serão alterados, caso já possua-os em base.
				aAdd(aAltInd,{"TMEF","MTBF"})
				aAdd(aAltInd,{"TMPR","MTTR"})
			EndIf

			NGINDCARGA(aIndTZ1,aIndTZ2,aIndTZ3,aIndTZ4,aIndTZ5,aIndTZ6,aIndTZ7,aIndSAH,aIndTZ9,aIndTZB,aAltInd)
		Endif

		fWriteVer( '1' )

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fRetArrTZC
Retorna os Indicadores de acordo com a Classificação.

@author Wagner Sobral de Lacerda
@since 19/12/2012

@return aArrTZC
/*/
//---------------------------------------------------------------------
Static Function fRetArrTZC(cCodClass, aArrTZ5)

	// Variáveis auxiliares
	Local aArrTZC := {}
	Local nX := 0, nScan := 0

	// Defaults
	Default cCodClass := ""
	Default aArrTZ5   := {}

	// Busca
	aSort(aArrTZ5, , , {|x,y| x[5]+x[2] < y[5]+y[2] }) // Ordena por Classificação + Código
	nScan := aScan(aArrTZ5, {|x| AllTrim(x[5]) == AllTrim(cCodClass)  })
	If nScan > 0
		For nX := nScan To Len(aArrTZ5)
			If AllTrim(aArrTZ5[nX][5]) <> AllTrim(cCodClass)
				Exit
			EndIf
			aAdd(aArrTZC, aArrTZ5[nX][2])
		Next nX
	EndIf

Return aArrTZC

//-------------------------------------------------------------------
/*/{Protheus.doc} NGASX7OP
Gatilho do campo D1_OP para preencher o campo D1_ORDEM.
@type function

@author  Tainã Alberto Cardoso
@since   23/10/2018

@return  cOrdem, string, Retorno o código da O.S.
/*/
//-------------------------------------------------------------------
Function NGASX7OP()

	Local aArea  := GetArea()
	Local nTamOS := Len( STJ->TJ_ORDEM )
	Local cOrdem := Space( nTamOS )

	If SuperGetMV( 'MV_NGMNTNO', .F., '2' ) == '1' .And. ( SuperGetMV( 'MV_NGMNTES', .F., 'N' ) == 'S' .Or.;
		SuperGetMV( 'MV_NGMNTCM', .F., 'N' ) == 'S' )
		
		dbSelectArea( 'SC2' )
		dbSetOrder( 1 ) // C2_FILIAL + C2_NUM + C2_ITEM + C2_SEQUEN + C2_ITEMGRD
		If dbSeek( xFilial( 'SC2' ) + M->D1_OP ) .And. SC2->( C2_ITEM + C2_SEQUEN ) == 'OS001';
			.And. ( 'OS001' $ M->D1_OP .Or. '  001' $ M->D1_OP )

			cOrdem := SubStr( M->D1_OP, 1, nTamOS )

		EndIf

	EndIf

	RestArea( aArea )

Return cOrdem

//---------------------------------------------------------------------
/*/{Protheus.doc} NewIdentif
Gera um nome de arquivo baseado nos caracteres ASCII em um tamanho
específico com o objetivo de obter um código único em um contexto
limitado.

@author Vitor Bonet
@since  20/08/2018
@param  nSize, Numérico, Tamanho do identificador
@return Character
/*/
//---------------------------------------------------------------------
Function NewIdentif( nSize )
	Local cIdentifier := FWTimeStamp(1) //data e hora
	Local nIndex
	For nIndex := 1 To nSize
		cIdentifier += Chr( Randomize( /* A */ 65, /* Z */ 90 ) )
	Next
Return cIdentifier

//---------------------------------------------------------------------
/*/{Protheus.doc} NewIdentif
Verifica a existência do arquivo 'mntatu.ngi', não possua
a Empresa e Filial em seu conteúdo, realiza a sua exclusão
para que possa ser criado o novo arquivo 'mntatu.ngi', o qual
salvará a Empresa e Filial, assim controlando corretamente as funções
de atualizações.

@param cDir , Caracter, Diretório e nome do arquivo de atualização.
@param nFunctOld, Numérico, Tamanho do array das funções antigas.
@param nFunction, Numérico, Tamanho do array das novas funções.

@author Guilherme Freudenburg
@since  07/02/2019

@return Vazio.
/*/
//---------------------------------------------------------------------
Static Function fMntAtu(cDir, nFunctOld, nFunction)

	Local nArqDir  := 0
	Local cContLin := ""
	Local nSepar   := 0

	Default cDir      := ""
	Default nFunctOld := 0
	Default nFunction := 0

	If File(cDir) // Verifica se o arquivo existe no diretório.

		nArqDir := FT_FUse(cDir) // Abre o arquivo

		cContLin := FT_FReadLn() // Abre arquivo

		nSepar := At( "#", cContLin ) // Efetua a contagem de espaços até o primeiro separador.

		/* 
			Caso o separador esteja na primeira posição indica que o arquivo está desatualizado;
			Caso o separador seja 11, significa que deverão ser removidas algumas funcionalidades;
			Caso exista alguma função que deverá ser atualizada devido a versão antiga e a atual.
		*/	
		If nSepar == 1 .Or. nSepar == 11 .Or. nFunctOld != 0 .And. nFunctOld < nFunction

			FT_FUse() // Fecha arquivo.

			FErase(cDir) // Realiza a exclusão do arquivo.
		Else

			FT_FUse() // Fecha arquivo.

		Endif

	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTMOVTM
Função responsável por fazer a busca do valor do campo D3_TM.

@param cCodCF , Caracter, Valor do campo D3_CF.

@observação:
    - Função foi criada com o intuíto de ser um auxílio para identificação
	da atualização do fonte MNTUTIL, ao realizar a chamada da função
	MNTMOVEST.Conforme sugestão do FrameWork, para garantir a compatibilidade
	entre os fontes.
	- Está função deve ser removida na release 12.1.25.
	- Está função não deverá ser utilizada.

@author Guilherme Freudenburg
@since  29/04/2019

@return cCodTM, Caracter, Retorna o valor do campo D3_TM.
/*/
//---------------------------------------------------------------------
Function MNTMOVTM( cCodCF, lEstor )

	Local cCodTM := ''

	Do Case

		Case SubStr( cCodCF, 1, 2 ) == 'RE'
			cCodTM := SuperGetMV( 'MV_MNTREQ', .F., '999' )

		Case SubStr( cCodCF, 1, 2 ) == 'DE'
			cCodTM := IIf( lEstor, '499', SuperGetMV( 'MV_MNTDEV', .F., '499' ) )

		Case SubStr( cCodCF, 1, 2 ) == 'PR'
			cCodTM := "499"
		
		OtherWise
			cCodTM := cCodCF

	End Case

Return cCodTM

//------------------------------------------------------------------------------------
/*/{Protheus.doc} MNTSeekPad
Realiza a busca de um registros padrão, deixando posicionado no registro e retornando se encontrou ou não.
Aplicável à bens padrão (TP9), estrutura padrão (STC / TC_TIPOEST = 'F') e manutenção padrão (TPF).

Atenção:
A partir do release 12.1.33, o tipo modelo será utilizado
na busca de padrões, mesmo em ambientes sem Gestão de Frotas

@author Wexlei Silveira
@since 07/05/2020

@param cTabela    , Caracter, Nome da tabela
@param nIndice    , Numerico, Indice de pesquisa
@param cFamilia   , Caracter, Familia a ser utilizada na busca de um registro padrão.
@param cModelo    , Caracter, Modelo a ser utilizada na busca de um registro padrão.
@param [cComplem] , Caracter, Chave de pesquisa complementar, utilizada após o Tipo Modelo.

@return Lógico , Define se o padrão foi encontrado.
/*/
//-------------------------------------------------------------------------------------
Function MNTSeekPad( cTabela, nIndice, cFamilia, cModelo, cComplem )

    Local lTemPad := .F.
    Local cChave  := ''

    Default cComplem := ''

    dbSelectArea( cTabela )
	dbSetOrder( nIndice )

    cChave := xFilial( cTabela ) + cFamilia

    // Caso o bem possua o tipo modelo preenchido,
    // faz a busca pelo padrão com o tipo modelo
    If !Empty( cModelo )
        lTemPad := dbSeek( cChave + cModelo + cComplem )
    Endif

    // Caso o bem não possua o tipo modelo preenchido ou não tenha localizado
    // um padrão com o tipo modelo informado, faz a busca de padrão aplicável à
    // todos os tipos modelos (TIPMPOD = '*')
    If !lTemPad
        lTemPad := dbSeek( cChave + Padr( '*', GetSx3Cache( 'TQR_TIPMOD', 'X3_TAMANHO' ) ) + cComplem )
    EndIf

Return lTemPad

//------------------------------------------------------------------------------------
/*/{Protheus.doc} MNTDesTpMd
Realiza busca do tipo modelo e sua descrição.

@obs A partir do release 12.1.33, o tipo modelo será utilizado
na busca de padrões, mesmo em ambientes sem Gestão de Frotas, assim o * representa
TODOS.

@author Eduardo Mussi
@since  20/07/2020

@param  cTpModelo, Caracter, Tipo modelo a ser pesquisado
@return Caracter, Descrição tipo modelo
/*/
//-------------------------------------------------------------------------------------
Function MNTDesTpMd( cTpModelo )

	Local cDesTpMode := ''

	If Trim( cTpModelo ) == '*'
		cDesTpMode := STR1472 // TODOS
	Else
		cDesTpMode := Posicione( 'TQR', 1, xFilial( 'TQR' ) + cTpModelo,  'TQR_DESMOD' )
	EndIf

Return cDesTpMode

//----------------------------------------------------------------------------------------
/*/{Protheus.doc} MNTXATF
Realiza atualizações no módulo SIGAMNT devido a alterações em cadastros no módulo SIGAATF.
@type function

@author Alexandre Santos
@since 02/09/2020

@param cCode     , string , Código do bem vinculado ao ativo fixo.
@param [cAddress], string , Endereço físico do ativo/bem.
@param [aInfos]  , array  , Lista com informações para traferência.
								[1] - Filial de destino
								[2] - Data de traferência
								[3] - Centro de Custos do bem
								[4] - Horario da traferência
								[5] - Filial origem
								[6] - Centro de Trabalho
								[7] - Contador 1
								[8] - Contador 2
@param [aFldExec], array, [1] - Centro de Trabalho
						  [2] - Contador 1
						  [3] - Contador 2

@return boolean, Define se o processo foi executado com êxito.
/*/
//----------------------------------------------------------------------------------------
Function MNTXATF( cCode, cAddress, aInfos, aFldExec )

	Local aArea      := GetArea()
	Local lRet       := .T.
	Local cFilST9    := xFilial( 'ST9' )

	Default cAddress := ''
	Default aInfos   := {}
	Default aFldExec := {}

	// Quando o array de informações para tranferência não for enviado, não realiza o processo.
	If !Empty( aInfos )

		// Posição 5 somente é enviada preenchida quando é tranferência entre filiais.
		If !Empty( aInfos[5] )

			lRet    := MNTA550( { aInfos[2], aInfos[4], aInfos[1], cCode, aInfos[3], aInfos[5] } )
			cFilST9 := aInfos[1]

		Else

			lRet := MNTTRACCAT( aInfos[1], cCode, aInfos[2], aInfos[3], aInfos[4], aFldExec )

		EndIf

	EndIf

	If lRet

		dbSelectArea( 'ST9' )
		dbSetOrder( 1 )
		If dbSeek( cFilST9 + cCode )

			// Atualiza campo de localização física do bem.
			If ST9->T9_LOCAL != cAddress

				RecLock( 'ST9', .F. )
					ST9->T9_LOCAL := cAddress
				ST9->( MsUnLock() )

			EndIf

		EndIf

	EndIf

	RestArea( aArea )

Return lRet

//----------------------------------------------------------------------------------------
/*/{Protheus.doc} MNTAGFOGO
Validação de veículo com pneus na estrutura com status aguardando marcação de fogo

@type function

@author Maria Elisandra de Paula
@since 02/10/2020

@param cCodBem, string, código do veículo
@return string, descrição do erro ou vazio
/*/
//----------------------------------------------------------------------------------------
Function MNTAGFOGO( cCodBem, cPlaca, lShowMsg )

	Local cError     := ''
	Local cAliasQry  := ''
	Local cStFire    := ''
	Local cCondPlaca := '%%'
	Local cCondBem   := '%%'

	Default cCodBem  := ''
	Default cPlaca   := ''
	Default lShowMsg := .T.

	//------------------------------------------------------------------------
	// verifica se ambiente está configurado com nova rotina de classificação
	//------------------------------------------------------------------------
	If TQZ->( FieldPos("TQZ_NUMSEQ") ) > 0

		cAliasQry := GetNextAlias()
		cStFire   := Alltrim( SuperGetMv( 'MV_NGSTAFG', .F., '' ) )

		If !Empty( cCodBem )
			cCondBem :=  '%AND ST9_B.T9_CODBEM =' + ValToSql( cCodBem ) + '%'
		EndIf

		If !Empty( cPlaca )
			cCondPlaca :=  '%AND TQS.TQS_PLACA = ' + ValToSql( cPlaca ) + '%'
		EndIf

		BeginSQL Alias cAliasQry

			SELECT DISTINCT TQS.TQS_CODBEM, TQS.TQS_POSIC
			FROM %table:TQS% TQS
			JOIN %table:ST9% ST9
				ON ST9.T9_CODBEM = TQS.TQS_CODBEM
				AND ST9.T9_STATUS = %exp:cStFire%
				AND ST9.T9_CATBEM = '3'
				AND ST9.T9_FILIAL = %xFilial:ST9%
				AND ST9.%NotDel%
			JOIN %table:ST9% ST9_B
				ON ST9_B.T9_PLACA <> ' '
				AND ST9_B.T9_FILIAL = %xFilial:ST9%
				AND ST9_B.%NotDel%
				AND ST9_B.T9_PLACA = TQS.TQS_PLACA
				%exp:cCondBem%
			WHERE TQS.TQS_FILIAL = %xFilial:TQS%
				AND TQS.%NotDel%
				%exp:cCondPlaca%
		EndSQL

		If !(cAliasQry)->( Eof() )

			cError += STR1473  + ':' + CRLF + CRLF // 'A estrutura do veículo possui pneus com status aguardando marcação de fogo'

			While !(cAliasQry)->( Eof() )
				cError += Alltrim((cAliasQry)->TQS_CODBEM) + ' - ' + STR1474 + ': ' + Alltrim((cAliasQry)->TQS_POSIC) + CRLF // 'Posição'
				(cAliasQry)->( dbSkip() )
			EndDo
		EndIf

		If !Empty( cError ) .And. lShowMsg
			Help( ,, STR0063 , , cError , 2, 1, , , , , , { STR1475  } ) // "NÃO CONFORMIDADE" # 'É necessário realizar a classificação antes de prosseguir com esta operação.'
		EndIf

		(cAliasQry)->( dbCloseArea() )

	EndIf

Return cError

//-----------------------------------------------------------------------------
/*/{Protheus.doc} MNTXATF2
Grava os campos de integracão SIGAATF x SIGAMNT na tabela ST9 - Bens quando alterado
é realizada no lado do SIGAATF.
@type function

@author Alexandre Santos
@since 31/12/2020

@sample MNTXATF2( '0000', '00' )

@param  cKeyT98 , Caracter, Chave de pesquisa para indice 8 na tabela ST9.
@param  cKeyT91 , Caracter, Chave de pesquisa para indice 1 na tabela ST9.

@return
/*/
//-----------------------------------------------------------------------------
Function MNTXATF2( cKeyT98, cKeyT91 )

	Local nX       := 0
	Local lFound   := .F.
	Local lClean   := .F.
	Local aAreaAll := GetArea()
	Local aAreaSN1 := SN1->( GetArea() )
	Local aAreaST9 := ST9->( GetArea() )
	Local aFields  := { { 'SN1', 'N1_CBASE'  , 'T9_CODIMOB' },;
						{ 'SN1', 'N1_DESCRIC', 'T9_NOME' 	},;
						{ 'SN1', 'N1_AQUISIC', 'T9_DTCOMPR'	},;
						{ 'SN1', 'N1_CHAPA'  , 'T9_CHAPA' 	},;
						{ 'SN1', 'N1_LOCAL'	 , 'T9_LOCAL' 	},;
						{ 'SN1', 'N1_FORNEC' , 'T9_FORNECE'	},;
						{ 'SN1', 'N1_LOJA'   , 'T9_LOJA' 	},;
						{ 'SN1', 'N1_NFISCAL', 'T9_NFCOMPR' },;
						{ 'SN3', 'N3_CUSTBEM', 'T9_CCUSTO'	},;
						{ 'SN3', 'N3_VORIG1' , 'T9_VALCPA' 	} }

	Default cKeyT91 := ''
	Default cKeyT98 := ''

	dbSelectArea( 'ST9' )
	dbSetOrder( 8 ) // T9_FILIAL + T9_CODIMOB
	lFound := dbSeek( xFilial( 'ST9') + cKeyT98 )

	// Caso localize o bem pelo T9_CODIMOB, porém o bem vinculado no ativo é outro.
	If lFound .And. ST9->T9_CODBEM != cKeyT91

		RecLock( 'ST9', .F. )
			ST9->T9_CODIMOB := Space( TamSX3( 'T9_CODIMOB' )[1] )
		ST9->( MsUnlock() )

		// Indica que o campo T9_CODIMOB foi limpo.
		lClean := .T.

	EndIf

	// Caso não localize o bem pela chave T9_FILIAL + T9_CODIMOB ou o campo T9_CODIMOB tenha sido limpo anteriormente.
	If !lFound .Or. lClean

		dbSelectArea( 'ST9' )
		dbSetOrder( 1 ) // T9_FILIAL + T9_CODBEM
		lFound := dbSeek( xFilial( 'ST9') + cKeyT91 )

	EndIf

	If lFound

		RecLock( 'ST9', .F. )

			For nX := 1 To Len( aFields )

				Do Case

					Case aFields[nX,2] == 'N3_VORIG1'

						// Somente grava o conteudo na tabela ST9 se for o primeiro registro da tabela SN3.
						If SN3->N3_SEQ == '001'

							ST9->&( aFields[nX,3] ) := (aFields[nX,1])->&( aFields[nX,2] )

						EndIf

					Case aFields[nX,2] == 'N1_CBASE'

						ST9->&( aFields[nX,3] ) := (aFields[nX,1])->&( aFields[nX,2] ) + SN1->N1_ITEM

					OtherWise

						// Atualiza os campos do destino, com o conteudo do seu correspodente origem
						ST9->&( aFields[nX,3] ) := (aFields[nX,1])->&( aFields[nX,2] )

				End Case

			Next nX

		ST9->( MsUnlock() )

	EndIf

	RestArea( aAreaST9 )
	RestArea( aAreaSN1 )
	RestArea( aAreaAll )

Return

//-----------------------------------------------------------------------------
/*/{Protheus.doc} MNTIntFIN
Busca o valor de desconto na TRX para a baixa do titulo.
@type function

@author Alexandre Santos
@since 09/11/2022

@sample MNTIntFIN( '10.00', '10.00' )

@param  nDescont   , float, Valor do desconto.
@param  nOldDescont, float, Valor do desconto anterior.
/*/
//-----------------------------------------------------------------------------
Function MNTIntFIN( nDescont, nOldDescont )
	
	Local aBind   := {}
	Local cAlsMNT := GetNextAlias()

	//Caso exista o P.E. MNTA7655 já é realizado o desconto diretamente na SE2
	If !ExistBlock( 'MNTA7655' )
		
		/*----------------------------------------+
		| Verifica a existência da query em cache |
		+----------------------------------------*/
		If Empty( cQryDescnt )

			cQryDescnt := 'SELECT '
			cQryDescnt += 	'TRX.TRX_DESCON '
			cQryDescnt += 'FROM '
			cQryDescnt += 	RetSqlName( 'TRX' ) + ' TRX '
			cQryDescnt += 'WHERE '
			cQryDescnt += 	'TRX.TRX_NUMSE2 = ? AND '
			cQryDescnt += 	'TRX.D_E_L_E_T_ = ? '

			cQryDescnt := ChangeQuery( cQryDescnt )

		EndIf

		aBind := {}
		aAdd( aBind, SE2->E2_NUM )
		aAdd( aBind, Space( 1 ) )

		dbUseArea( .T., 'TOPCONN', TcGenQry2( , , cQryDescnt, aBind ), cAlsMNT, .T., .T. )

		nDescont    := (cAlsMNT)->TRX_DESCON
		nOldDescont := (cAlsMNT)->TRX_DESCON

	EndIf

Return	

//----------------------------------------------------------------------------------------
/*/{Protheus.doc} MNTAmIIn
Verifica se possui acesso às rotinas do Manutenção de Ativos e Gestão de Frotas.
@type function

@author Alexandre Santos
@since 01/01/2021

@param nModule1, numeric, Código do módulo a ser verificado.
@param nModule2, numeric, Código do módulo a ser verificado.
@param nModule3, numeric, Código do módulo a ser verificado.
@param nModule4, numeric, Código do módulo a ser verificado.
@param nModule5, numeric, Código do módulo a ser verificado.

@return boolean, Define se o acesso é permitido.

@obs Para as rotinas que permitem acesso por meio do módulo 88, este valor deve ser enviado
obrigatóriamente no segundo parâmetro devido ao tratamento realizado para versões inferiores
a 12.1.033
/*/
//----------------------------------------------------------------------------------------
Function MNTAmIIn( nModule1, nModule2, nModule3, nModule4, nModule5 )

	Local lRet := .T.

    If GetRpoRelease() < '12.1.033'
        lRet := AmIIn( 19, IIf( nModule2 != Nil .And. nModule2 == 88, 88, Nil ) )
    Else
        lRet := AmIIn( nModule1, nModule2, nModule3, nModule4, nModule5 )
    EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTFrotas
Verifica se o ambiente é Gestão de Frotas

@author  Wexlei Silveira
@since   20/10/2020

@return Lógico, verdadeiro se o ambiente for Gestão de Frotas
/*/
//---------------------------------------------------------------------
Function MNTFrotas()

/*---------------------------------------------------------------------------+
| Deve ser verificado o módulo 99, visto que acionamentos do configurador    |
| não distiguem entre SIGAMNT/SIGAGFR e devem ser tratados dento do produto. |
+---------------------------------------------------------------------------*/

Return nModulo == 95 .Or. ( GetRPORelease() >= '12.1.033' .And. nModulo == 99 ) .Or.;
	( GetRPORelease() < '12.1.033' .And. SuperGetMV('MV_NGMNTFR') == 'S' )

//---------------------------------------------------------------------
/*/{Protheus.doc} fInsSF5
Cadastra os TES padrão para movimentação de estoque geradas pelo MNT.

@author Alexandre Santos
@since  01/08/2022

@param  cMNTReq, string, Código TES para requisição(MV_MNTREQ).
@param  cMNTDev, string, Código TES para devolução(MV_MNTDEV).

@return
/*/
//---------------------------------------------------------------------
Static Function fInsSF5( cMNTReq, cMNTDev )

	Local lOk := .T.

	dbSelectArea( 'SF5' )
	dbSetOrder( 1 ) // F5_FILIAL + F5_CODIGO

	If !Empty( cMNTReq ) .And. !MsSeek( FwxFilial( 'SF5' ) + cMNTReq )

		/*--------------------------------------------------------------------+
		| Aciona o ExecAuto MATA230 para inclusão do tipo de movimento padrão |
		| de requisição utilizado pelo módulo SIGAMNT/SIGAGFR.                |
		+--------------------------------------------------------------------*/
		lOk := MNTExecSF5( { cMNTReq, 'R', 'Req. Padrão SIGAMNT', 'N', 'S', 'N', 'N', '2' } )

	EndIf

	If lOk .And. !Empty( cMNTDev ) .And. !MsSeek( FwxFilial( 'SF5' ) + cMNTDev )

		/*--------------------------------------------------------------------+
		| Aciona o ExecAuto MATA230 para inclusão do tipo de movimento padrão |
		| de devolução utilizado pelo módulo SIGAMNT/SIGAGFR.                 |
		+--------------------------------------------------------------------*/
		MNTExecSF5( { cMNTDev, 'D', 'Dev. Padrão SIGAMNT', 'N', 'S', 'N', 'N', '2' } )

	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MntCustDec
Consiste se existe decimais diferentes nos campos de custo.
@type function

@author Alexandre Santos
@since  14/02/2023

@param  aLogDec, array   , Lista com campos inconsitentes.
@param  lLogDec, booelean, Indica se existe algum campo inconsitente.
@param  nDecOld, integer , Quantidade de casas decimais validadas pelo 
estoque(MATA330).

@return
/*/
//---------------------------------------------------------------------
Function MntCustDec( aLogDec, lLogDec, nDecOld )

	Local aFields := {}
	Local nInd1   := 0
	Local nTamDec := 0

	If SuperGetMv( 'MV_NGMNTES', .F., 'N' ) == 'S'

		aAdd( aFields, { 'ST1', 'T1_SALARIO' } )
		aAdd( aFields, { 'STJ', 'TJ_CUSTMDO' } )
		aAdd( aFields, { 'STJ', 'TJ_CUSTMAT' } )
		aAdd( aFields, { 'STJ', 'TJ_CUSTTER' } )
		aAdd( aFields, { 'STJ', 'TJ_CUSTMAA' } )
		aAdd( aFields, { 'STL', 'TL_CUSTO'   } )
		aAdd( aFields, { 'TR6', 'TR6_VLCOMB' } )
		aAdd( aFields, { 'TR6', 'TR6_VLTOT'  } )
		aAdd( aFields, { 'TQN', 'TQN_VALUNI' } )
		aAdd( aFields, { 'TQN', 'TQN_VALTOT' } )

		For nInd1 := 1 To Len( aFields )

			nTamDec := FWTamSX3( aFields[nInd1,2] )[2]
			
			/*------------------------------------------------+
			| Guarda todos os campos para apresentação no LOG |
			+------------------------------------------------*/
			aAdd( aLogDec, { aFields[nInd1,1], aFields[nInd1,2], nTamDec } )
			
			/*----------------------------------------------------------------------+
			| Caso o campo atual possua qtd diferente de decimais do campo anterior |
			| o LOG deve ser apresentado.                                           |
			+----------------------------------------------------------------------*/
			If nTamDec != nDecOld

				lLogDec:=.T.

			EndIf

			nDecOld := nTamDec

		Next nInd1

	EndIf

	FWFreeArray( aFields )
	
Return 

//---------------------------------------------------------------------
/*/{Protheus.doc} fSEQRELAJST
Consulta os campos T5_SEQRELA, TF_SEQRELA, TG_SEQRELA, TH_SEQRELA
TJ_SEQRELA, TM_SEQRELA, TS_SEQRELA, TP1_SEQREL, TP2_SEQREL, TPF_SEQREL
busca lugares onde o campo de SEQRELA tenha caracteres vazios, e ajusta eles
para o formato '001'.

@author João Ricardo Santini Zandoná
@since  18/04/2023

@return
/*/
//---------------------------------------------------------------------
Static Function fSEQRELAJST()

	Local cAliasQry := ''
	Local lLenSQL   := .T.
	Local cSubst    := ''
	Local cQuery    := '' 
	Local cIsNull   := ''
	Local cBanco    := Upper(TCGetDB())
	Local nI        := 1
	Local nJ        := 0
	Local nPosVirg  := 0
	Local aLength   := {}
	Local aManut    := {}
	Local aRegs     := {{'ST5', 'T5_SEQRELA'}, {'STG', 'TG_SEQRELA'}, {'STH', 'TH_SEQRELA'},;
						{'STM', 'TM_SEQRELA'}, {'STS', 'TS_SEQRELA'}, {'TP1', 'TP1_SEQREL'},;
						{'TP2', 'TP2_SEQREL'}, {'TPF', 'TPF_SEQREL'}, {'TP5', 'TP5_SEQREL'},;
						{'TPG', 'TPG_SEQREL'}, {'TPH', 'TPH_SEQREL'}, {'TPM', 'TPM_SEQREL'}}

	If cBanco == "ORACLE"
		cIsNull := "NVL"
		lLenSQL := .F.
	Else 
		If cBanco == "POSTGRES"
			cIsNull := "COALESCE"
			lLenSQL := .F.
		Else
			cIsNull := "ISNULL"
		EndIf
	EndIf

	For nI := 1 to Len(aRegs) 
		
		cAliasQry := GetNextAlias()

		If lLenSQL
			
			aAdd( aLength, 'LEN(RTRIM(' + aRegs[ nI, 1 ] + '.' + aRegs[ nI, 2 ]+')) != 3' )

		Else

			aAdd( aLength, 'LENGTH(RTRIM(' + aRegs[ nI, 1 ] + '.' + aRegs[ nI, 2 ]+')) != 3' )

		EndIf

		cQuery := 'SELECT '
		cQuery += 'R_E_C_N_O_ ' 	
		cQuery += 'FROM ' + RetSqlName( aRegs[ nI, 1 ] ) + ' ' + aRegs[ nI, 1 ] + ' '
		cQuery += 'WHERE ' + aLength[ 1 ] + ' '
		cQuery += "AND " + aRegs[ nI, 1 ] + ".D_E_L_E_T_ = ' '"

		cQuery := ChangeQuery( cQuery )
		dbUseArea( .T., 'TOPCONN', TCGENQRY( , ,cQuery ), cAliasQry, .F., .T. )

		While ( cAliasQry )->( !Eof() )

			&( aRegs[ nI, 1 ] )->( dbGoTo( (cAliasQry)->R_E_C_N_O_ ) )

			Reclock( aRegs[ nI, 1 ], .F. )
			
			&( aRegs[ nI, 1 ] + '->' + aRegs[ nI, 2 ] ) := PadL( AllTrim( &( aRegs[ nI, 1 ] + '->' + aRegs[ nI, 2 ] ) ), 3, '0' )
			
			&( aRegs[ nI, 1 ] )->( MsUnlock() )

			( cAliasQry )->( DbSkip() )

		End

		( cAliasQry )->( DbCloseArea() )
		aLength := {}

	Next nI

	// STF e STJ possuem campos SUBSTIT que também devem ser alterados por isso seu ajuste é feito separadamente

	// Ajusta STF

	If lLenSQL
		
		aAdd( aLength, 'LEN(RTRIM(STF.TF_SEQRELA))' )
		aAdd( aLength, 'LEN(RTRIM(STF.TF_SUBSTIT))' )
		aAdd( aLength, 'LEN(RTRIM(STF.TF_SEQREPA))' )

	Else

		aAdd( aLength, 'LENGTH(RTRIM(STF.TF_SEQRELA))' )
		aAdd( aLength, 'LENGTH(RTRIM(STF.TF_SUBSTIT))' )
		aAdd( aLength, 'LENGTH(RTRIM(STF.TF_SEQREPA))' )

	EndIf

	cAliasQry := GetNextAlias()

	cQuery := 'SELECT * FROM ('
	cQuery += 	'SELECT '
	cQuery += 		'STF.R_E_C_N_O_ AS RECSTF, '
	cQuery +=		cIsNull + '(STJ.R_E_C_N_O_, 0) AS RECSTJ,'
	cQuery += 	'CASE ' + aLength[ 1 ] + ' '
	cQuery += 	'WHEN 3 THEN 0 '
	cQuery += 	'ELSE 1 '
	cQuery += 	'END AS AJUSTASEQ, '
	cQuery += 	'CASE ' + aLength[ 2 ] + ' '
	cQuery += 	'WHEN 0 THEN 0 '
	cQuery += 	'ELSE 1 '
	cQuery += 	'END AS AJUSTASUB, '
	cQuery += 	'CASE ' + aLength[ 3 ] + ' '
	cQuery += 	'WHEN 0 THEN 0 '
	cQuery += 	'ELSE 1 '
	cQuery += 	'END AS AJUSTAREP '
	cQuery += 	'FROM ' + RetSqlName( 'STF' ) + ' STF '
	cQuery += 	'LEFT JOIN ' + RetSqlName( 'STJ' ) + ' STJ ON '
	cQuery += 		NGMODCOMP('STJ','STF','=') + ' '
	cQuery +=		'AND STJ.TJ_CODBEM = STF.TF_CODBEM '
	cQuery += 		'AND STJ.TJ_SERVICO = STF.TF_SERVICO '
	cQuery +=		'AND STJ.TJ_SEQRELA = STF.TF_SEQRELA '
	cQuery +=		'AND STJ.TJ_DTMRFIM = STF.TF_DTULTMA '
	cQuery +=		"AND STJ.TJ_TERMINO = 'S' "
	cQuery +=		"AND STJ.TJ_SITUACA <> 'C' "
	cQuery +=		"AND STJ.TJ_PLANO <> '000000' "
	cQuery +=		"AND STJ.D_E_L_E_T_ = ' ' "
	cQuery += 	'WHERE '
	cQuery += 		"STF.D_E_L_E_T_= ' '"
	cQuery += ') '
	
	If cBanco != "ORACLE"
	
		cQuery +=	'AS MANUT '
	
	EndIf
	
	cQuery += 'WHERE '
	cQuery += 	'(AJUSTASEQ > 0 OR AJUSTASUB > 0 OR AJUSTAREP > 0)'

	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., 'TOPCONN', TCGENQRY( , ,cQuery ), cAliasQry, .F., .T. )

	While (cAliasQry)->(!Eof())

		nI := 1
		STF->(dbGoTo( (cAliasQry)->RECSTF ))

		Reclock('STF', .F.)

		If (cAliasQry)->AJUSTASEQ == 1
			STF->TF_SEQRELA := PadL( AllTrim( STF->TF_SEQRELA ), 3, '0' )
		EndIf

		If (cAliasQry)->AJUSTAREP == 1
			STF->TF_SEQREPA := PadL( AllTrim( STF->TF_SEQREPA ), 3, '0' )
		EndIf
		
		If (cAliasQry)->AJUSTASUB == 1

			// Este trecho valida as sequências da Substituição.
			While nI <= TAMSX3('TF_SUBSTIT')[1]
				
				nPosVirg := At( ',', (STF->TF_SUBSTIT + ','), nI )	
				cSubst := Substr( STF->TF_SUBSTIT, nI, nPosVirg - nI )
				
				If Empty( cSubst )
				
					Exit
				
				Else
				
					If Len( AllTrim( cSubst ) ) != 3
						STF->TF_SUBSTIT := SubStr( STF->TF_SUBSTIT, 1, nI - 1 ) + PadL( AllTrim( cSubst ), 3, '0' ) + SubStr( STF->TF_SUBSTIT, nPosVirg, len( STF->TF_SUBSTIT ) )
					EndIf
				
				EndIf

				nPosVirg := At( ',', STF->TF_SUBSTIT, nI )
				
				If nPosVirg == 0
				
					Exit
				
				EndIf

				nI := nPosVirg + 1

			End

		EndIf

		STF->(MsUnlock())

		If (cAliasQry)->AJUSTASUB == 1 .And. (cAliasQry)->RECSTJ <> 0
			
			// aManut: [1]:TF_SUBSTIT [2]:TF_DTULTMA [3]:TF_CODBEM [4]:TJ_FILIAL [5]:TJ_PLANO
			//		   [6]:TJ_TIPOOS [7]:TJ_DTMPINI
			aManut := { STF->TF_SUBSTIT, STF->TF_DTULTMA, STF->TF_CODBEM }

			STJ->(dbGoTo( (cAliasQry)->RECSTJ ))

			aAdd( aManut, STJ->TJ_FILIAL )
			aAdd( aManut, STJ->TJ_PLANO )
			aAdd( aManut, STJ->TJ_TIPOOS )
			aAdd( aManut, STJ->TJ_DTMPINI )

			nI := 1

			While nI <= len(aManut[1])

				nPosVirg := At( ',', aManut[1] + ',', nI )
				cSubst := Substr( aManut[1], nI, nPosVirg - nI )
				
				If Empty( cSubst )
				
					Exit
				
				EndIf

				DbSelectArea('STJ')
				DbSetOrder(9) // TJ_FILIAL+TJ_PLANO+TJ_TIPOOS+TJ_CODBEM+DTOS(TJ_DTMPINI)+TJ_SEQRELA			
				If DbSeek( aManut[4] + aManut[5] + aManut[6] + aManut[3] + DTOS( aManut[ 7 ] ) + cSubst )

					DbSelectArea('STF')
					DbSetOrder(1) //TF_FILIAL+TF_CODBEM+TF_SERVICO+TF_SEQRELA
					If DbSeek( STF->TF_FILIAL + STF->TF_CODBEM + STF->TF_SERVICO + cSubst ) .And. STF->TF_DTULTMA < aManut[2]

						RecLock('STF', .F.)

							STF->TF_DTULTMA := aManut[2]

						STF->( MsUnlock() )

					EndIf

				EndIf

				nPosVirg := At( ',', aManut[1], nI )
				
				If nPosVirg == 0
				
					Exit
				
				EndIf

				nI := nPosVirg + 1
			
			Enddo

		EndIf

		(cAliasQry)->(DbSkip())

	End

	(cAliasQry)->(DbCloseArea())

	// Ajusta STJ

	aLength := {}

	If lLenSQL
		
		aAdd( aLength, 'LEN(RTRIM(STJ.TJ_SEQRELA))' )
		aAdd( aLength, 'LEN(RTRIM(STJ.TJ_SUBSTIT))' )

	Else

		aAdd( aLength, 'LENGTH(RTRIM(STJ.TJ_SEQRELA))' )
		aAdd( aLength, 'LENGTH(RTRIM(STJ.TJ_SUBSTIT))' )

	EndIf

	cAliasQry := GetNextAlias()

	cQuery := 'SELECT '
	cQuery += 	'STJ.R_E_C_N_O_, '
	cQuery += 	'CASE ' + aLength[1] + ' '
	cQuery +=		'WHEN 3 THEN 0 '
	cQuery +=		'ELSE 1 '
	cQuery += 	'END AS AJUSTASEQ, '
	cQuery += 	'CASE ' + aLength[2] + ' '
	cQuery +=		'WHEN 0 THEN 0 '
	cQuery += 		'ELSE 1 '
	cQuery +=	'END AS AJUSTASUB '
	cQuery += 'FROM ' + RetSqlName( 'STJ' ) + ' STJ '
	cQuery += 'WHERE '
	cQuery += 	aLength[1] + ' != 3 ' 
	cQuery +=	'OR ' + aLength[2] + ' != 0 '
	cQuery +=	"AND STJ.D_E_L_E_T_ = ' '"

	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., 'TOPCONN', TCGENQRY( , ,cQuery ), cAliasQry, .F., .T. )

	While (cAliasQry)->(!Eof())

		nI := 1
		STJ->( dbGoTo( (cAliasQry)->R_E_C_N_O_ ) )
		Reclock( 'STJ', .F. )
		
		If (cAliasQry)->AJUSTASEQ == 1
		
			STJ->TJ_SEQRELA := PadL( AllTrim( STJ->TJ_SEQRELA ), 3, '0' )
		
		EndIf
		
		If (cAliasQry)->AJUSTASUB == 1

			While nI <= TAMSX3('TJ_SUBSTIT')[1]
				
				nPosVirg := At( ',', STJ->TJ_SUBSTIT + ',', nI )
				
				cSubst := Substr( STJ->TJ_SUBSTIT, nI, nPosVirg - nI )
				
				If Empty( cSubst )
				
					Exit
				
				Else
				
					If Len( AllTrim( cSubst ) ) != 3
						STJ->TJ_SUBSTIT := SubStr( STJ->TJ_SUBSTIT, 1, nI - 1 ) + PadL( AllTrim( cSubst ), 3, '0' ) + SubStr( STJ->TJ_SUBSTIT, nPosVirg, len(STJ->TJ_SUBSTIT) )
					EndIf
				
				EndIf

				nPosVirg := At( ',', STJ->TJ_SUBSTIT, nI )
				
				If nPosVirg == 0
				
					Exit
				
				EndIf

				nI := nPosVirg + 1
				
			End
		EndIf

		STJ->(MsUnlock())
		(cAliasQry)->(DbSkip())

	End

	(cAliasQry)->(DbCloseArea())

	// Ajusta AC9 (Banco de conhecimento de manutenções)

	aLength := {}

	nI := FWTamSX3( 'TF_CODBEM' )[ 1 ] + FWTamSX3( 'TF_SERVICO' )[ 1 ] + 1 // Posicao inicial do campo SEQRELA na chave (STF)
	nJ := FWTamSX3( 'TPF_CODFAM' )[ 1 ] + FWTamSX3( 'TPF_SERVIC' )[ 1 ] + 1 // Posicao inicial do campo SEQRELA na chave (TPF)

	If lLenSQL
		
		aAdd( aLength, 'LEN(LTRIM(RTRIM(SUBSTRING(AC9.AC9_CODENT, ' + cValToChar( nI ) + ', 3))))' )
		aAdd( aLength, 'LEN(LTRIM(RTRIM(SUBSTRING(AC9.AC9_CODENT, ' + cValToChar( nJ ) + ', 3))))' )

	Else

		If cBanco == 'ORACLE'

			aAdd( aLength, 'LENGTH(LTRIM(RTRIM(SUBSTR(AC9.AC9_CODENT, ' + cValToChar( nI ) + ', 3))))' )
			aAdd( aLength, 'LENGTH(LTRIM(RTRIM(SUBSTR(AC9.AC9_CODENT, ' + cValToChar( nJ ) + ', 3))))' )

		Else

			aAdd( aLength, 'LENGTH(LTRIM(RTRIM(SUBSTRING(AC9.AC9_CODENT, ' + cValToChar( nI ) + ', 3))))' )
			aAdd( aLength, 'LENGTH(LTRIM(RTRIM(SUBSTRING(AC9.AC9_CODENT, ' + cValToChar( nJ ) + ', 3))))' )

		EndIf

	EndIf


	cAliasQry := GetNextAlias()

	cQuery := 'SELECT '
	cQuery += 	'AC9.R_E_C_N_O_ AS REC '
	cQuery += 'FROM ' + RetSqlName( 'AC9' ) + ' AC9 '
	cQuery += 'WHERE '
	cQuery += 	"(AC9.AC9_ENTIDA = 'STF' AND " + aLength[ 1 ] + ' != 3) '
	cQuery +=	"OR (AC9.AC9_ENTIDA = 'TPF' AND " + aLength[ 2 ] + ' != 3) '
	cQuery += 	"AND AC9.AC9_ENTIDA IN ('STF', 'TPF') "
	cQuery +=	"AND AC9.D_E_L_E_T_ = ' ' "

	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., 'TOPCONN', TCGENQRY( , ,cQuery ), cAliasQry, .F., .T. )

	While (cAliasQry)->(!Eof())

		// Quando o campo AC9_ENTIDA for igual a STF ou TPF o SeqRela da manutenção é o último campo que integra o valor do campo AC9_CODENT
		AC9->( dbGoTo( (cAliasQry)->REC ) )
		Reclock( 'AC9', .F. )
		cSubst := AllTrim( AC9->AC9_CODENT )
		
		If AC9->AC9_ENTIDA == 'STF'
			
			AC9->AC9_CODENT := SubStr( cSubst, 1, nI - 1 ) + PADL( AllTrim( SubStr( cSubst, nI, 3 ) ), 3, '0' )

		Else

			AC9->AC9_CODENT := SubStr( cSubst, 1, nJ - 1 ) + PADL( AllTrim( SubStr( cSubst, nJ, 3 ) ), 3, '0' )

		EndIf

		AC9->(MsUnlock())
		(cAliasQry)->(DbSkip())

	End

	(cAliasQry)->(DbCloseArea())

	FWFreeArray(aLength)
	FWFreeArray(aManut)
	FWFreeArray(aRegs)

Return .T.

//--------------------------------------------------------------------------
/*/{Protheus.doc} fWriteVer
Função para escrever no basever.ngi se o processo foi realizado com sucesso

@author cauê Girardi Petri
@since 12/12/2024

@param cBaseVer , Caracter, só pode ser duas opções
[0] Significa que está em processamento
[1] Significa que o processo foi realizado com sucesso
/*/
//--------------------------------------------------------------------------
Static Function fWriteVer( cBaseVer )

	Local cFile    := 'basever.ngi'
	Local nBaseAtu := 0

	If File( cFile )
		FErase( cFile )
	EndIf

	nBaseAtu := fCreate( cFile ) // Cria arquivo.

	fWrite( nBaseAtu, cBaseVer + ',' + cFilAnt )

	fClose(nBaseAtu) // Fecha arquivo.

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTVldInd
Validacao do processamento dos indicadores,
se não foi concluido com sucesso re-faz todo o processo

@author Cauê Girardi Petri
@since 12/12/2024

/*/
//---------------------------------------------------------------------
Function MNTVldInd()

	Local cVerBase  := '0'
	Local aVerBase  := {}
	Local cFile     := 'basever.ngi'
	Local cQuery	:= ''
	Local nBaseAtu  := 0
	Local nX
	Local aTabelas   := {'TZ1', 'TZ2', 'TZ3', 'TZ4', 'TZ5', 'TZ6', 'TZ7', 'TZ9', 'TZB' }

	If !File(cFile) 	//Verifica se o arquivo de atualização existe, caso não exista cria o mesmo.

		nBaseAtu := fCreate( cFile ) // Cria arquivo.

		fWrite( nBaseAtu, '1,' + cFilAnt )

		fClose(nBaseAtu) // Fecha arquivo.

	EndIf

	// Abre o arquivo
	nBaseAtu := FT_FUse( cFile )

	// Posiciona na primeira linha
	FT_FGoTop()

	cVerBase  := FT_FReadLn()

	// Fecha o arquivo
	FT_FUSE()

	aVerBase := StrTokArr( cVerBase, ',' )

	If aVerBase[1] == '0'

		For nX := 1 To Len( aTabelas )

			cQuery := "DELETE FROM " + RetSqlName( aTabelas[ nX ] )
			cQuery += " WHERE " + aTabelas[ nX ] + "_FILIAL = '" + aVerBase[2] + "'"

			TcSqlExec( cQuery )

		Next

		MNTINDIC()
	
	EndIf

	FWFreeArray( aVerBase )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MntEspCar
Verifica se é necessário incluir o caractere de quebra de linha do windows
em valor do tipo memo, caso seja necessário faz a substituição

@author João Ricardo Santini Zandoná
@since 29/04/2025
@param cMemo, caractere, valor do campo memo

@return caractere, valor recebido via parâmetro com os ajustes necessários
de caracteres especiais
/*/
//---------------------------------------------------------------------
Function MntEspCar( cMemo )

	Local cReturn

	Default cMemo := ''

	cReturn := cMemo

	If At( Chr(10), cReturn ) > 0 .And. At( Chr(13), cReturn ) == 0

		cReturn := StrTran( cReturn, Chr( 10 ), Chr( 13 ) + Chr( 10 ) )

	EndIf

Return cReturn
