#INCLUDE "mdta691.ch"
#Include "Protheus.ch"

/*/


Ŀ
Funo     MDTA691   Autor  Andre E. Perez Alvarez Data 26/05/2006
Ĵ
Descrio  Programa Cadastros de Questionario Laudo Ambiental         
Ĵ
Objetivo                                                              
ٱ

/*/
Function MDTA691

//Ŀ
// Armazena variaveis p/ devolucao (NGRIGHTCLICK) 						  
//
Local aNGBEGINPRM := NGBEGINPRM()
Local cPerg :=  PADR( "MDT691" , 10 ) //Grupo de perguntas

If !NGCADICBASE("TOX_DESCRI","A","TOX",.F.)
	If !NGINCOMPDIC("UPDMDTD7","TIDFWT",.F.)
   //------------------------------------------------
   //  Devolve variaveis armazenadas (NGRIGHTCLICK)
   //------------------------------------------------
		NGRETURNPRM(aNGBEGINPRM)
	Return .F.
	EndIf
EndIf


PRIVATE aRotina := MenuDef()
Private lSigaMdtPS := If( SuperGetMv("MV_MDTPS",.F.,"N") == "S", .t. , .f. )

//Ŀ
// Define o cabecalho da tela de atualizacoes                   
//
PRIVATE cCadastro  := STR0011  //"Laudos x Quest."
PRIVATE aCHKDEL := {}, bNGGRAVA
PRIVATE nSizeCli,nSizeLoj
Private cPrograma := "MDTA691"
Private cCliMdtPs

//Efetua as perguntas.
Pergunte( cPerg , .F. )

//---------------------------------------
// Adiciona funcionalidade ao F12
//---------------------------------------
SetKey( VK_F12 , { | | MDT691OBD(cPerg)} )

//Se for prestador de servio
If lSigaMdtPS
	DbSelectArea("SA1")
	DbSetOrder(1)
	mBrowse( 6, 1,22,75,"SA1")
Else
	MDT691CAD()
Endif

//Ŀ
// Devolve variaveis armazenadas (NGRIGHTCLICK) 							  	  
//
NGRETURNPRM(aNGBEGINPRM)

Return .T.
//Ŀ
// MDT691CAD()
//
Function MDT691CAD()
Local aArea			:= GetArea()
Local oldROTINA := aCLONE(aROTINA)
LOCAL cFiltraSRJ			//Variavel para filtro
LOCAL aIndexSRJ	:= {}		//Variavel Para Filtro
Local uRet
Local oldCad := cCadastro

PRIVATE cCadastro  := STR0011  //"Laudos x Quest."
PRIVATE aTrocaF3   := {}, aNGFIELD := {}
Private aCHKDEL := {}, bNGGRAVA

If lSigaMdtPS
	aRotina := {{ STR0004	, "AxPesqui"  , 0 , 1}    ,; //"Pesquisar"
                { STR0005 	, "NGCAD01"  , 0 , 2}    ,; //"Visualisar"
                { STR0006 	, "MDTA691FUN"  , 0 , 3,0}}    //"Questionario"
Endif

aPos1 := {  15,  1, 95,315 }

DbSelectArea("TO0")
//Se for prestador de servio faz filtro de laudos por cliente
If lSigaMdtPS
	Set Filter To TO0->TO0_CLIENT+TO0->TO0_LOJA == SA1->A1_COD+SA1->A1_LOJA
	cCliMdtPs := SA1->A1_COD+SA1->A1_LOJA
Endif
DbSetOrder(1)
mBrowse( 6, 1,22,75,"TO0")

aROTINA := aCLONE(oldROTINA)
RestArea(aArea)
cCadastro := oldCad
Return uRet

/*/


Ŀ
Funo    NG691INC   Autor  Andre E. Perez Alvarez Data 26/05/2006
Ĵ
Descrio  Programa Cadastros de Questionario do Laudo                
Ĵ
Objetivo                                                              
ٱ

/*/
Function NG691INC(cAlias,nReg,nOpcx)

Local nx
Local aNoFields := {}
Private oDlg3, oGet, cCodAnt, oMenu
Private nCnt   := 0
Private nItens := 0
Private aHeader := {}
Private aCols := {}

dbSelectArea("TOX")
If lSigaMdtPS
	dbSetOrder(3)
Else
	dbSetOrder(1)
Endif

M->TOX_DTREAL := dDataBase
M->TOX_QUESTI := space(len(TOX->TOX_QUESTI))
cNOMQUE       := space(20)
M->TOX_CLIENT := SA1->A1_COD
M->TOX_LOJA   := SA1->A1_LOJA

If nOpcx <> 3

   M->TOX_DTREAL := TOX->TOX_DTREAL
   M->TOX_QUESTI := TOX->TOX_QUESTI
   QUESTI691(M->TOX_QUESTI)

Endif

//Ŀ
// Montando aHeader                                             
//
dbSelectArea("SX3")
dbSetOrder(2)
nUsado  := 0

aAdd(aNoFields, 'TOX_LAUDO')
aAdd(aNoFields, 'TOX_QUESTI')
aAdd(aNoFields, 'TOX_NOMQUE')
aAdd(aNoFields, 'TOX_DTREAL')
aAdd(aNoFields, 'TOX_DESRES')
If lSigaMdtPS
	aAdd(aNoFields, 'TOX_CLIENT')
	aAdd(aNoFields, 'TOX_LOJA')
Endif

#IFDEF TOP
	cQuery := "SELECT * FROM "+RetSqlName("TOX")+" TOX WHERE TOX.D_E_L_E_T_ = ' '"
	cSeekTOX  := xFilial("TOX")+M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI+TMH->TMH_QUESTA
	cWhileTOX := "TOX->TOX_FILIAL + TOX->TOX_LAUDO + DTOS(TOX->TOX_DTREAL) + TOX->TOX_QUESTI + TOX->TOX_QUESTA"
	If lSigaMdtPS
		cSeekTOX  := xFilial("TOX")+M->TOX_CLIENT+M->TOX_LOJA+M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+;
					 M->TOX_QUESTI+TMH->TMH_QUESTA
		cWhileTOX := "TOX->TOX_FILIAL + TOX->TOX_CLIENT + TOX->TOX_LOJA + TOX->TOX_LAUDO + "+;
					 "DTOS(TOX->TOX_DTREAL) + TOX->TOX_QUESTI + TOX->TOX_QUESTA"
	Endif
	FillGetDados( nOpcx, "TOX", 1, ;
				cSeekTOX,;
				{|| cWhileTOX},;
				{|| .T.},aNoFields,,,cQuery,{|| MACOL691(nOpcx)})
#ELSE
	If lSigaMdtPS
		cKEY := "M->TOX_CLIENT+M->TOX_LOJA+M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI"
		cGET := "TOX->TOX_FILIAL == '"+xFilial("TOX")+"' .and. TOX->TOX_CLIENT+TOX->TOX_LOJA+TOX->TOX_LAUDO+DTOS(TOX->TOX_DTREAL)+TOX->TOX_QUESTI == '" +cCliMdtps+M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI +"'"
	Else
		cKEY := "M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI"
		cGET := "TOX->TOX_FILIAL == '"+xFilial("TOX")+"' .and. TOX->TOX_LAUDO+DTOS(TOX->TOX_DTREAL)+TOX->TOX_QUESTI == '" +M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI +"'"
	Endif
	//FillGetDados( nOpcx, "TOX", 1, cKey, {|| }, {|| .T.},aNoFields,,,,{|| NGMontaAcols("TOX",&cKEY,cGET)})
	FillGetDados( nOpcx, "TOX", 1, cKey, {|| }, {|| .T.},aNoFields,,,,{|| MACOL691(nOpcx)})
#ENDIF

If Empty(aCols) .Or. nOpcx == 3
   aCols := BlankGetd(aHeader)
EndIf

nQUESTA := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TOX_QUESTA" })
nPERGUN := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TOX_PERGUN" })
nRESPOS := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TOX_RESPOS" })
nQTRESP := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TOX_QTRESP" })
nCOMRES := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TOX_COMRES" })

cTudoOk  :="A691TUDOK()"
cLinhaOk :="A691LINHOK()"
cChaveTOX := 'M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI'
nIndTox := 1
If lSigaMdtPS
	cChaveTOX := 'M->TOX_CLIENT+M->TOX_LOJA+M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI'
	nIndTox := 3
Endif


nopca := 0
DEFINE MSDIALOG oDlg3 TITLE OemToAnsi(cCadastro) From 9,0 To 35,116 OF oMainWnd

	@ 1.4,1   SAY OemToAnsi(STR0007) //"Laudo"
	@ 1.4,5   MSGET M->TOX_LAUDO Picture "@!" SIZE 41,10 when .f.

	@ 1.4,11  SAY OemToAnsi(STR0012) //"Descricao"
	@ 1.4,15  MSGET cLaudo  picture '@!' SIZE 180,10 When .f.

	@ 2.4,1   SAY OemToAnsi(STR0013) //"Realizacao"
	@ 2.4,5   MSGET M->TOX_DTREAL Picture "99/99/99" SIZE 43,10 when INCLUI HasButton

	@ 3.4,1   SAY OemToAnsi(STR0006) //"Questionario"
	@ 3.4,5   MSGET M->TOX_QUESTI Picture "@!" Valid CheckSX3("TOX_QUESTI");
	.AND. ExistChav("TOX",&(cChaveTOX),nIndTox);
	.AND. MACOL691(4) .AND. QUESTI691(M->TOX_QUESTI) F3 If(lSigaMdtps,"MDTTMG","TMG") SIZE 30,10 when INCLUI HasButton

	@ 3.4,11  SAY OemToAnsi(STR0014) //"Nome"
	@ 3.4,15  MSGET cNOMQUE picture '@!' SIZE 180,10 When .f.

	oGet := MSGetDados():New(60,6,195,455,nOpcx,"A691LINHOK","A691TUDOK","",.F.,,,,nItens)

	NGPOPUP(asMenu,@oMenu)
	oDlg3:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg3)}

ACTIVATE MSDIALOG oDlg3 ON INIT EnchoiceBar(oDlg3,{||nopca:=1,If(!A691TUDOK(),nopca := 0,oDlg3:End())},{||oDlg3:End()}) CENTERED


If nopca == 1

	dbSelectArea("TOX")
	If lSigaMdtPs
		dbSetOrder(3)
	Else
		dbSetOrder(1)
	Endif

	cSeekTemp := xFilial('TOX')+M->TOX_LAUDO
	If lSigaMdtPs
		cSeekTemp := xFilial('TOX')+M->TOX_CLIENT+M->TOX_LOJA+M->TOX_LAUDO
	Endif

	If nOpcx == 3 .or. nOpcx == 4

		For nx := 1 to nItens

			If aCols[nx][nRESPOS] <> '3' // BRANCO

				If !dbSeek(cSeekTemp+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI+aCols[nx][nQUESTA])
					RecLock("TOX",.T.)
					TOX->TOX_FILIAL := xFilial('TOX')
					If lSigaMdtPs
						TOX->TOX_CLIENT := M->TOX_CLIENT
						TOX->TOX_LOJA   := M->TOX_LOJA
					Endif
					TOX->TOX_LAUDO  := M->TOX_LAUDO
					TOX->TOX_DTREAL := M->TOX_DTREAL
					TOX->TOX_QUESTI := M->TOX_QUESTI
					TOX->TOX_QUESTA := aCols[nx][nQUESTA]
					TOX->TOX_RESPOS := aCols[nx][nRESPOS]
					TOX->TOX_QTRESP := aCols[nx][nQTRESP]
					TOX->TOX_COMRES := aCols[nx][nCOMRES]
				Else
					RecLock("TOX",.F.)
					TOX->TOX_QUESTA := aCols[nx][nQUESTA]
					TOX->TOX_RESPOS := aCols[nx][nRESPOS]
					TOX->TOX_QTRESP := aCols[nx][nQTRESP]
					TOX->TOX_COMRES := aCols[nx][nCOMRES]
				Endif

				MsUnLock('TOX')

			Else

				If dbSeek(cSeekTemp+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI+aCols[nx][nQUESTA])
					RecLock("TOX",.F.)
					dbDelete()
					MsUnLock('TOX')
				Endif

			Endif
		Next

	Elseif nOpcx == 5

		dbSeek(cSeekTemp+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI)

		Do While !EOF()                       .And.;
			TOX->TOX_FILIAL == xFilial('TOX') .And.;
			TOX->TOX_LAUDO == M->TOX_LAUDO  .And.;
			TOX->TOX_DTREAL == M->TOX_DTREAL  .And.;
			TOX->TOX_QUESTI == M->TOX_QUESTI .and. ;
			( IF(lSigaMdtPs,TOX->TOX_CLIENT+TOX->TOX_LOJA == M->TOX_CLIENT+M->TOX_LOJA,.t.) )

			RecLock("TOX",.F.)
			dbDelete()
			MsUnLock('TOX')

			dbSkip()
		End

	Endif

Endif

dbSelectArea("TOX")

Return
/*/


Ŀ
Funo     A691TUDOK Autor  Andre E. Perez Alvarez Data 26/05/2006
Ĵ
Descrio  Consistencia final                                         
Ĵ
Objetivo                                                              
ٱ

/*/
Function A691TUDOK

Return .t.
/*/


Ŀ
Funo    A691LINHOK Autor  Andre E. Perez Alvarez Data 26/05/2006
Ĵ
Descrio  Consistencia da linha                                      
Ĵ
Objetivo                                                              
ٱ

/*/
Function A691LINHOK

Return .t.
/*/


Ŀ
Funo    QUESTI691  Autor  Andre E. Perez Alvarez Data 26/05/2006
Ĵ
Descrio Consistencia do QUESTI e NOMQUE                             
Ĵ
Objetivo                                                              
ٱ

/*/
Function QUESTI691(vQUESTI)

   dbSelectArea("TMG")
   dbSetOrder(1)
   If dbSeek(xFilial('TMG')+vQUESTI)
      cNOMQUE := TMG->TMG_NOMQUE
   Else
      Help(" ",1,"MSG_QUEST")
      Return .f.
   Endif

Return .t.
/*/


Ŀ
Funo    MACOL691   Autor  Andre E. Perez Alvarez Data 26/05/2006
Ĵ
Descrio Monta ou remonta o GETDADOS                                 
Ĵ
Objetivo                                                              
ٱ

/*/
Function MACOL691(nOpcx)
Local aArea := GetArea()
If nOpcx == 3
	aCols := BlankGetd(aHeader)
	Return .T.
EndIf

If lSigaMdtps .and. Inclui .And. nOpcx == 4
	dbSelectArea("TMG")
	dbSetOrder(2)
	If !dbSeek(xFilial("TMG")+cCliMdtps+M->TOX_QUESTI)
		MsgStop(STR0016)//"Este Questionrio no pertence ao cliente."
		Return .F.
	Endif
	RestArea(aArea)
Endif
nQUESTA := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TOX_QUESTA" })
nPERGUN := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TOX_PERGUN" })
nRESPOS := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TOX_RESPOS" })
nQTRESP := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TOX_QTRESP" })
nCOMRES := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TOX_COMRES" })

dbSetOrder(1)
If lSigaMdtps
	nTMHi := NGRETORDEM("TMH","TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI+TMH_QUESTA",.T.)
	If nTMHi == 0
		nTMHi := 1
	Endif
	dbSelectArea("TMH")
	dbSetOrder(nTMHi)
	dbSeek( xFilial("TMH") + cCliMdtps + M->TOX_QUESTI)
Else
	dbSelectArea("TMH")
	dbSetOrder(1)
	dbSeek(xFilial('TMH')+M->TOX_QUESTI)
Endif

nCnt   := 0
nItens := 0

Do While !EOF()                           .And.;
	TMH->TMH_FILIAL == xFilial('TMH')   .And.;
	M->TOX_QUESTI == TMH->TMH_QUESTI

	If lSigaMdtps
		If TMH->(TMH_CLIENT+TMH_LOJA) <> cCliMdtps
			Exit
		Endif
	Endif

	If TMH->TMH_INDSEX <> '3'
		If (TMH->TMH_INDSEX == '1' .and. SRA->RA_SEXO == 'F') .OR.;
			(TMH->TMH_INDSEX == '2' .and. SRA->RA_SEXO == 'M')

			dbSelectArea( 'TMH' )
			dbSkip()
			loop
		Endif
	Endif

	nCnt := nCnt + 1

	Dbskip()
End

If nCnt > 0
	PRIVATE aNOME[nCNT][Len(aHeader)+1]
	aCOLS:=aCLONE(aNOME)

	If lSigaMdtps
		nTMHi := NGRETORDEM("TMH","TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI+TMH_QUESTA",.T.)
		If nTMHi == 0
			nTMHi := 1
		Endif
		dbSelectArea("TMH")
		dbSetOrder(nTMHi)
		dbSeek( xFilial("TMH") + cCliMdtps + M->TOX_QUESTI)
	Else
		dbSelectArea("TMH")
		dbSetOrder(1)
		dbSeek(xFilial('TMH')+M->TOX_QUESTI)
	Endif

	nCnt := 0
	Do While !EOF()                        .And.;
		TMH->TMH_FILIAL == xFilial('TMH')   .And.;
		M->TOX_QUESTI == TMH->TMH_QUESTI

		If lSigaMdtps
			If TMH->(TMH_CLIENT+TMH_LOJA) <> cCliMdtps
				Exit
			Endif
		Endif

		If TMH->TMH_INDSEX <> '3'
			If (TMH->TMH_INDSEX == '1' .and. SRA->RA_SEXO == 'F') .OR.;
				(TMH->TMH_INDSEX == '2' .and. SRA->RA_SEXO == 'M')

				dbSelectArea( 'TMH' )
				dbSkip()
				loop
			Endif

		Endif

		nCnt := nCnt + 1


		//Ŀ
		// Montando aCols                                               
		//

		aCOLS[nCnt][nQUESTA] := TMH->TMH_QUESTA
		aCOLS[nCnt][nPERGUN] := TMH->TMH_PERGUN

		dbSelectArea("TOX")
		If lSigaMdtPS
			dbSetOrder(3)
			If dbSeek(xFilial('TOX')+M->TOX_CLIENT+M->TOX_LOJA+M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI+TMH->TMH_QUESTA)
				aCOLS[nCnt][nQTRESP] := TOX->TOX_QTRESP
				aCOLS[nCnt][nCOMRES] := TOX->TOX_COMRES
				aCOLS[nCnt][nRESPOS] := TOX->TOX_RESPOS
			Else
				aCOLS[nCnt][nRESPOS] := '3'
				aCOLS[nCnt][nQTRESP] := 0.00
				aCOLS[nCnt][nCOMRES] := space(30)
			Endif
		Else
			dbSetOrder(1)
			If dbSeek(xFilial('TOX')+M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI+TMH->TMH_QUESTA)
				aCOLS[nCnt][nQTRESP] := TOX->TOX_QTRESP
				aCOLS[nCnt][nCOMRES] := TOX->TOX_COMRES
				aCOLS[nCnt][nRESPOS] := TOX->TOX_RESPOS
			Else
				aCOLS[nCnt][nRESPOS] := '3'
				aCOLS[nCnt][nQTRESP] := 0.00
				aCOLS[nCnt][nCOMRES] := space(30)
			Endif
		Endif

		aCols[nCnt][	Len(aHeader)-1		] := "TOX"
		aCols[nCnt][	Len(aHeader)		] := ("TOX")->(Recno())
		aCOLS[nCnt][	Len(aCOLS[nCnt])	] := .F.

		nItens := nItens + 1
		dbSelectArea( 'TMH' )
		dbSkip()

	End
Else
	HELP(" ",1,"NGSSEPERG")//'Nao existe pergunta cadastrada para este questionario'
	Return .f.
Endif

If INCLUI
	#IFDEF WINDOWS
		oGet:FORCEREFRE()
	#ENDIF
Endif

Return .t.

/*/


Ŀ
Funo     MenuDef   Autor  Rafael Diogo Richter   Data 29/11/2006
Ĵ
Descrio Utilizacao de Menu Funcional.                               
Ĵ
 Uso       SigaMDT                                                    
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          		1 - Pesquisa e Posiciona em um Banco de Dados           
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    F.O    Motivo da Alteracao                     
Ĵ
                                                                    
ٱ


/*/
Static Function MenuDef()
Local aRotina
Local lSigaMdtPS := If( SuperGetMv("MV_MDTPS",.F.,"N") == "S", .t. , .f. )

If lSigaMdtPS
	aRotina :=	{ { STR0004, "AxPesqui"  , 0 , 1},; //"Pesquisar"
                   { STR0005,  "NGCAD01"   , 0 , 2},; //"Visualizar"
                   { STR0015	,"MDT691CAD", 0 , 4}} //"Laudos"
Else
	aRotina := {{ STR0004	, "AxPesqui"  , 0 , 1}    ,; //"Pesquisar"
                { STR0005 	, "NGCAD01"  , 0 , 2}    ,; //"Visualizar"
                { STR0006 	, "MDTA691FUN"  , 0 , 3,0}}    //"Questionario"
Endif

Return aRotina


/*/


Ŀ
Funo    MDTA691FUN Autor  Denis Hyroshi de Souza Data 01/07/2008
Ĵ
Descrio  Filtra as fichas ocupacionais do funcionario               
Ĵ
 Uso       MDTA691                                                    
ٱ


/*/
Function MDTA691FUN(cAlias,nRecno,nOpcx)

Local aOld := aClone(aRotina)
Local cExprFilTop := " TOX_LAUDO = " + ValToSQL( TO0->TO0_LAUDO ) + " AND " + ;
						" TOX_FILIAL = " + ValToSQL( xFilial( "TOX" ) ) + " AND " + ;
						" TOX_QUESTA = " + ValToSQL( "001" )

aRotina := { { STR0005 , "MDTA691CAD"  , 0 , 2},;//"Visualizar"
             { STR0008 , "MDTA691CAD"  , 0 , 3},;//"Incluir"
             { STR0009 , "MDTA691CAD"  , 0 , 4},;//"Alterar"
             { STR0010 , "MDTA691CAD"  , 0 , 5} }//"Excluir"

//Ŀ
// Endereca a funcao de BROWSE                                  
//

mBrowse(6,1,22,75,"TOX",,,,,,,,,,,,,, cExprFilTop )

aRotina := aClone(aOld)

Return

/*/


Ŀ
Funo    MDTA691CAD Autor  Denis Hyroshi de Souza Data 01/07/2008
Ĵ
Descrio  Tela de cadastro da Ficha Ocupacional                      
Ĵ
 Uso       MDTA691                                                    
ٱ


/*/
Function MDTA691CAD(cAlias,nRecno,nOpcx,oParent,cAliasTrb,lTitulo)

Local oMainWnd
Local lVisual := .f.
Local nYY,nXX
Local aBtn_Topo := {}
Local aAreaTmp := GetArea()
Local nIndTMH, cSeekTMH, cCondTMH
Local aOldRot  := aClone(aRotina)
Local cMemoM6 := ""
Local cRespos := If ( NGCADICBASE( "TMH_RESPOS", "A", "TMH", .F. ) , "TMH->TMH_RESPOS" , "TMH->TMH_COMBO+TMH->TMH_COMBO2" )
Local lParent   := ValType(oParent) == "O"
Local nspca:=0
nOpcx := nOpcx + 1

If nOpcx == 2 .or. nOpcx == 5
	lVisual := .t.
Endif

Private oFont    := TFont():New("Arial",,-10,.F.,.F.)
Private oFont12  := TFont():New("Arial",,-12,.T.,.T.)
Private oFont16  := TFont():New("Arial",,-16,.T.,.T.)
Private cAliasCTT := "SI3"
Private oDlgInd, oFolder1
Private oMenu
Private aCadTipo := {}
Private oIndNG
Private cIndNG
Private lAccPag2 := .F.
Private aAC := {STR0001,STR0002},aCRA:= {STR0002,STR0003,STR0001}//"Abandona"##"Confirma"##"Confirma"##"Redigita"##"Abandona"
Private aHeader[0],Continua,nUsado:=0
Private aSize := MsAdvSize(,.f.,430), aObjects := {}
Default lTitulo   := .T.
//Private nOrdTMI := NGRETORDEM("TMI","TMI_FILIAL+TMI_NUMFIC+TMI_QUESTI+DTOS(TMI_DTREAL)+TMI_QUESTA+TMI_RESPOS",.F.)
Aadd(aObjects,{200,200,.t.,.f.})
aInfo := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
aPosObj := MsObjSize(aInfo, aObjects,.t.)
If aSize[6] > 900
	aPosObj[1,3] := aPosObj[1,3] * ( aSize[6] / 560 )
ElseIf aSize[6] > 650
	aPosObj[1,3] := aPosObj[1,3] * ( aSize[6] / 590 )
Else
	aPosObj[1,3] := aPosObj[1,3] * ( aSize[6] / 610 )
Endif

If Alltrim(GETMV("MV_MCONTAB")) == "CTB"
	cAliasCTT := "CTT"
Endif

Private cX_MF_Fun := Space(40)
Private cX_MF_Cus := Space(40)

dbSelectArea("TOX")
dbSetOrder(1) //TOX_FILIAL+TOX_LAUDO+DTOS(TOX_DTREAL)+TOX_QUESTI+TOX_QUESTA

aAreaTO0 := TO0->(GetArea())
dbSelectArea("TOX") //TO0->(VDISP(TOX->TOX_LAUDO,"TO0_DESLAU"))
RegToMemory("TOX",(nOpcx == 3))
RestArea(aAreaTO0)
//Inicializa grupo de perguntas
Pergunte( "MDT691" , .F. )

//Ŀ
//TELA INICIAL          
//
nOpcPar := 0
If nOpcx==3
	nOpcPar := MDTA691TOX(nOpcx==3,nOpcx)
	If nOpcPar == 1
		Begin Transaction
			MDTAGrv(nOpcx,1)
		End Transaction
	Endif
Endif

//Ŀ
//TELA INICIAL          
//
nOpca := 0

If lSigaMdtps
	nIndTMH := NGRETORDEM("TMH","TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI",.F.)
	cSeekTMH:= cCliMdtps+M->TOX_QUESTI
	cCondTMH:= "TMH->(TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI)"
Else
	nIndTMH := 1
	cSeekTMH:= M->TOX_QUESTI
	cCondTMH:= "TMH->(TMH_FILIAL+TMH_QUESTI)"
Endif

If nOpcPar == 1 .or. nOpcx != 3
	cTipoFic := M->TOX_QUESTI
	dbSelectArea("TMH")
	dbSetOrder(nIndTMH)
	dbSeek(xFilial("TMH")+cSeekTMH)
	While !Eof() .and. xFilial("TMH")+cSeekTMH == &(cCondTMH)
		//Verifica se usuario precisa responder a pergunta
		If TMH->TMH_INDSEX <> "3"
			If (TMH->TMH_INDSEX == "1" .and. TM0->TM0_SEXO == "2") .OR.;
				(TMH->TMH_INDSEX == "2" .and. TM0->TM0_SEXO == "1")

				dbSelectArea( 'TMH' )
				dbSkip()
				loop
			Endif
		Endif
		aTipoTMH := {}
		If !Empty( &cRespos )
			aTipoTMH := fRetCombo(Alltrim( &cRespos ))
		Endif
		aTemp    := Array(Len(aTipoTMH),3)
		For nXX := 1 To Len(aTemp)
			If (TMH->TMH_TPLIST=="1")
         		aTemp[nXX,1] := 0
         	Else
             	aTemp[nXX,1] := .F.
         	Endif
	         If nOpcx != 3
	         	dbSelectArea("TOX")
	            dbSetOrder(1)//TOX_FILIAL+TOX_LAUDO+DTOS(TOX_DTREAL)+TOX_QUESTI+TOX_QUESTA
	            If dbSeek( xFilial("TOX")+M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI+TMH->TMH_QUESTA+SubStr(aTipoTMH[nXX],1,1) )
	            	If (TMH->TMH_TPLIST=="1")
	               	aTemp[nXX,1] := If(TOX->TOX_RESPOS == Substr(aTipoTMH[nXX],1,1),1,0)
	               Else
	               	aTemp[nXX,1] := If(TOX->TOX_RESPOS == Substr(aTipoTMH[nXX],1,1),.T.,.F.)//.T.
	               Endif
					Endif
				Else
	         	If SubStr(aTipoTMH[nXX],1,1) == TMH->TMH_DEFAUL
	         		If (TMH->TMH_TPLIST=="1")
	            		aTemp[nXX,1] := 1
	            	Else
	            		aTemp[nXX,1] := .T.
	            	Endif
		         Endif
	         Endif
	      Next nXX

		//1 - Codigo Questo
		//2 - Descrio Questo
		//3 - Grupo
		//4 - Array de Opes
		//5 - Cbox
		//6 - Indica se  RADIO (.T.) ou CHECK (.F.)
		//7 - Indica se tem campo Memo
		//8 - Array (respostas,objeto)
		//9 - Ordem
		//10- Campo Memo
		aADD( aCadTipo , { TMH->TMH_QUESTA , Capital(TMH->TMH_PERGUN) ,;
								 TMH->TMH_CODGRU, aTipoTMH                    ,;
						   	 &cRespos, (TMH->TMH_TPLIST=="1")             ,;
						   	 (TMH->TMH_ONMEMO=="1"), aTemp                ,;
						   	 TMH->TMH_ORDEM, NGSEEK( "TOX", M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+TMH->( TMH_QUESTI + TMH_QUESTA ), 1 , "TOX_DESCRI" ) } )
		dbSelectArea("TMH")
		dbSkip()
	End

	aSort( aCadTipo ,,, { |x,y| x[9] < y[9] } )

	If Len(aCadTipo) > 0
		oIndNG:=Array(Len(aCadTipo),3)
		cIndNG:=Array(Len(aCadTipo))
	Endif

	aAreaTOX := {}
	cChvTmp  := xFilial("TOX") + M->TOX_LAUDO
	dbSelectArea("TOX")
	dbSetOrder(1)
	dbSeek( cChvTmp )
	While !Eof() .and. cChvTmp == TOX->TOX_FILIAL+TOX->TOX_LAUDO
		If Replicate("#",Len(TOX->TOX_QUESTA)) == TOX->TOX_QUESTA
			If aScan(aAreaTOX, {|x| x == TOX->TOX_DTREAL }) == 0
				aAdd( aAreaTOX , TOX->TOX_DTREAL )
			Endif
		Endif
		dbSelectArea("TOX")
		dbSkip()
	End
	aSort( aAreaTOX ,,, { |x,y| x > y } )
	For nXX := 1 To Len(aAreaTOX)
		If nXX == 1
			cObsAnt := ""
		Endif
		cObsAnt += DtoC(aAreaTOX[nXX]) + "  "
	Next nXX

	nFatMlt := 1.95
	If aPosObj[1,4] <= 410
		nFatMlt := 1.9
	ElseIf aPosObj[1,4] <= 550
		nFatMlt := 1.93
	Endif

	If !lParent
		DEFINE MSDIALOG oDlgInd TITLE OemToAnsi(cCadastro) From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL
		oDlgInd:LESCCLOSE := .f.
		oDlgInd:lMaximized := .T.
	Else
		oDlgInd := oParent
		oDlgInd:CoorsUpdate()
		aPosObj[1,4] := oDlgInd:nWidth/2
		aSize[5] := 0
	EndIf

	//
	// PAGINA 2 - TOX                                
	//
	nLinObj := 2
	nTam := 12
	@ 0,0 SCROLLBOX oScroll VERTICAL OF oDlgInd BORDER
	oScroll:Align := CONTROL_ALIGN_ALLCLIENT

	//
	//Titulo do Grupo                                
	//

	If lTitulo
		oPanelTmp := TPaintPanel():new(nLinObj-1,-4,aPosObj[1,4]+5,14,oScroll)
		oPanelTmp:addShape("id=2;type=1;left=0;top=0;width="+Alltrim(Str(aPosObj[1,4]*2.2,5))+";height=28;"+;
	                "gradient=1,0,-15,0,40,0.4,#C3DBF9,0.9,#83AAE2,0.0,#FFF6FF;pen-width=0;"+;
	                "pen-color=#B0C4DE;can-move=0;can-mark=0;is-blinker=1;")

		@ 2, 11 SAY oGrpNome Prompt TO0->TO0_NOME PIXEL OF oPanelTmp Font oFont16 COLOR CLR_WHITE
		@ 2, 10 SAY oGrpNome Prompt TO0->TO0_NOME PIXEL OF oPanelTmp Font oFont16 COLOR RGB(67,70,87)

		@ 2, (aPosObj[1,4]/2) SAY oGrpDtEx Prompt SubStr(DtoC(M->TOX_DTREAL),1,6)+StrZero(Year(M->TOX_DTREAL),4) PIXEL OF oPanelTmp Font oFont16 COLOR CLR_WHITE
		@ 2, (aPosObj[1,4]/2)-1 SAY oGrpDtEx Prompt SubStr(DtoC(M->TOX_DTREAL),1,6)+StrZero(Year(M->TOX_DTREAL),4) PIXEL OF oPanelTmp Font oFont16 COLOR RGB(67,70,87)
		@ 2, aPosObj[1,4]-120 SAY oGrpQues Prompt Space(20) PIXEL OF oPanelTmp Font oFont16 COLOR CLR_WHITE

		nLinObj += 25
	EndIf

	cOldGrupo := "#"
	For nYY := 1 to Len(aCadTipo)
		If cOldGrupo <> aCadTipo[nYY,3]
			cOldGrupo := aCadTipo[nYY,3]
			cDesGrupo := " "
			dbSelectArea("TK0")
			dbSetOrder(01)
			If dbSeek( xFilial("TK0") + cOldGrupo )
				If !Empty(TK0->TK0_DESCRI)
					cDesGrupo := Capital( Alltrim(TK0->TK0_DESCRI) )
				Endif
			Endif
			//
			//Titulo do Grupo                                
			//
			oPanelTmp := TPaintPanel():new(nLinObj-1,0,aPosObj[1,4],10,oScroll)
			oPanelTmp:addShape("id=1;type=1;left=0;top=0;width="+Alltrim(Str(aPosObj[1,4]*2,5))+";height=20;"+;
                "gradient=1,0,0,0,15,0.0,#FFFFFF,0.1,#FFFFFF,1.0,#FFFFFF;pen-width=1;"+;
                "pen-color=#FFFFFF;can-move=0;can-mark=0;is-blinker=1;")

   			oPanelTmp:addShape("id=2;type=2;left=10;top=0;width="+Alltrim(Str(aPosObj[1,4]*nFatMlt,5))+";height=20;"+;
                "gradient=1,0,0,0,15,0.0,#FFFFFF,0.1,#FDFBFD,1.0,#CDD1D4;pen-width=1;"+;
                "pen-color=#B0C4DE;can-move=0;can-mark=0;is-blinker=1;")

	 		@ 1, 11 SAY oIndNG[nYY,3] Prompt Space(40) PIXEL OF oPanelTmp Font oFont12
	 		oIndNG[nYY,3]:SetText(cDesGrupo)
			nLinObj += 13
		Endif

	    cStrYY := Alltrim( Str(nYY) )
		//
		//Titulo Questo                                 
		//
		nPosOld := nLinObj+7
 		@ nLinObj, 009 SAY oIndNG[nYY,1] Prompt Space(40) PIXEL OF oScroll Font oFont12
		oIndNG[nYY,1]:bSetGet := ;
			&("{|u| If(pCount() == 0, aCadTipo["+cStrYY+",2], aCadTipo["+cStrYY+",2]:=u)}")
    	oIndNG[nYY,1]:SetText(aCadTipo[nYY,2])

		//
		//Montando lista de opcoes (radio ou check)      
		//
		nLimCol := aSize[5]/8
		nAcumLi := 0
		For nXX := 1 To Len(aCadTipo[nYY,4])
			cStrXX := Alltrim( Str(nXX) )
			cDescBox := SubStr(aCadTipo[nYY,4,nXX],3)
			If (nAcumLi + Len(cDescBox) + 5) > nLimCol .or. nXX == 1
		   		nLinObj += 9
		   		nAcumLi := 0
			Endif
			nspca:=Len(cDescBox)*8

			If aCadTipo[nYY,6]
			    aCadTipo[nYY,8,nXX,2] := TBtnBmp2():New( nLinObj*2,26+(nAcumLi*7),14,14,;
			    If(aCadTipo[nYY,8,nXX,1]==0,"ngradiono","ngradiook"),,,,{||},oScroll,,,.T. )
			    @ nLinObj, 22+(nAcumLi*3.5) SAY aCadTipo[nYY,8,nXX,3] Prompt " " Size nspca,7 PIXEL OF oScroll
			    aCadTipo[nYY,8,nXX,3]:SetText(cDescBox)
				If lVisual
					aCadTipo[nYY,8,nXX,2]:lReadOnly := .T.
				Else
				   aCadTipo[nYY,8,nXX,3]:bLClicked := &("{|| fRadioMdt("+cStrYY+","+cStrXX+") }")
					aCadTipo[nYY,8,nXX,2]:bAction := &("{|| fRadioMdt("+cStrYY+","+cStrXX+") }")
				Endif
			Else
				aCadTipo[nYY,8,nXX,2] := TCheckBox():New(nLinObj-1,13+(nAcumLi*3.5),cDescBox,,oScroll,13+(Len(cDescBox)*3.9),7,,,,,,,,.T.)
				aCadTipo[nYY,8,nXX,2]:bSetGet := &("{|u| If(PCount()==0,aCadTipo["+cStrYY+",8,"+cStrXX+",1],aCadTipo["+cStrYY+",8,"+cStrXX+",1]:=u)}")
				If lVisual
					aCadTipo[nYY,8,nXX,2]:lReadOnly := .T.
				Endif
			Endif
	    	nAcumLi += Len(cDescBox) + 8
		Next nXX

		If aCadTipo[nYY,7]
			//
			//Campo Memo                                     
			//
			nLinObj += 10
			oIndNG[nYY,2] := TMultiget():New(nLinObj,12,,oScroll,aPosObj[1,4]-30,18,,,,,,.T.)
			oIndNG[nYY,2]:EnableHScroll(.T.)
			oIndNG[nYY,2]:EnableVScroll(.T.)
			oIndNG[nYY,2]:bWhen := &("{ || MDT691OBS("+ cStrYY +") }") //Funo para atualizar o When do campo Memo
			oIndNG[nYY,2]:bSetGet := ;
				&("{|u| If(pCount() == 0, aCadTipo["+cStrYY+",10], aCadTipo["+cStrYY+",10]:=u)}")
			nLinObj += 12
			If lVisual
				oIndNG[nYY,2]:lReadOnly := .T.
			Endif
		Endif
		nLinObj += 13
		@ nPosOld,09 TO nLinObj-3,aPosObj[1,4]-15 OF oScroll PIXEL

	Next nYY

//	nLinObj += 16
//	@ nLinObj, 082 BUTTON oBtnImASO Prompt STR0032 Size 65,10 Of oScroll Pixel Action fImpFicha()//"Imprimir Questionrio"
	nLinObj += 13
	@ nLinObj, 012 SAY " " PIXEL OF oScroll

	If !lParent
		ACTIVATE MSDIALOG oDlgInd ON INIT EnchoiceBar(oDlgInd,{|| nOpca := 1,if(MDTA691Ok(.f.),oDlgInd:End(),nOpca := 1)},{|| nOpca := 2,oDlgInd:End()},,aBtn_Topo)
		If nOpca == 1
			Begin Transaction
				MDTAGrv(nOpcx,2)
			End Transaction
		Endif
	EndIf
Endif

aRotina := aClone(aOldRot)

Return nil

/*/


Ŀ
Funo      fRetCombo Autor  Denis Hyroshi de Souza Data 07/07/2008
Ĵ
Descrio  Verifica se a formula esta correta e faz a gravacao         
Ĵ
 Uso                                                                   
Ĵ


/*/
Static Function fRetCombo(cVar)
Local aArray1 := RetSx3Box(cVar,,,1)
Local nCont,aArray2 := {}

For nCont := 1 To Len(aArray1)
	If !Empty(aArray1[nCont][1])
		AADD(aArray2,Alltrim(aArray1[nCont][1]))
	Endif
Next nCont

Return aClone(aArray2)

/*/


Ŀ
Funo     MDTAGrv   Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Funcao chamada para gravacao                               
Ĵ
 Uso      MDTA145                                                     
ٱ


/*/
Static Function MDTAGrv(nOpcx,nTipo)
Local ny,nx,cOrd,nXX,nYY,nZZ
Local aTOXs := {}

If nOpcx == 3 .or. nOpcx == 4
	If nTipo == 2
		For nYY := 1 to Len(aCadTipo)
			aRespost := {}
			For nXX := 1 To Len(aCadTipo[nYY,4])
				cStrXX := Alltrim( Str(nXX) )
				If aCadTipo[nYY,6] //Radio
					If ValType(aCadTipo[nYY,8,nXX,1]) == "N"
						If aCadTipo[nYY,8,nXX,1] == 1
							aAdd( aRespost , aCadTipo[nYY,4,nXX] )
						Endif
					Endif
				Else //Check
					If ValType(aCadTipo[nYY,8,nXX,1]) == "L"
						If aCadTipo[nYY,8,nXX,1]
							aAdd( aRespost , aCadTipo[nYY,4,nXX] )
						Endif
					Endif
				Endif
			Next nXX
			If ValType(aCadTipo[nYY,10]) == "C" //Adiciona campo memo para gravao
				If !Empty(aCadTipo[nYY,10])
					aAdd( aRespost , "#" )
				Endif
			Endif

			//Se encontrou informao para a pergunta, grava
			For nZZ := 1 To Len(aRespost)
				dbSelectArea("TOX")
				dbSetOrder(1)//TOX_FILIAL+TOX_LAUDO+DTOS(TOX_DTREAL)+TOX_QUESTI+TOX_QUESTA+TOX_RESPOS
				If dbSeek( xFilial("TOX")+TO0->TO0_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI+aCadTipo[nYY,1]+aRespost[nZZ])
					RecLock("TOX",.F.)
					TOX->TOX_RESPOS := aRespost[nZZ]
				Else
					RecLock("TOX",.T.)
					TOX->TOX_FILIAL := xFilial("TOX")
					TOX->TOX_LAUDO := TO0->TO0_LAUDO
					TOX->TOX_QUESTI := M->TOX_QUESTI
					TOX->TOX_DTREAL := M->TOX_DTREAL
					TOX->TOX_QUESTA := aCadTipo[nYY,1]
					TOX->TOX_RESPOS := aRespost[nZZ]
					If lSigaMdtps
						TOX->TOX_CLIENT := SA1->A1_COD
						TOX->TOX_LOJA   := SA1->A1_LOJA
					Endif
				Endif
				If aRespost[nZZ] == "#"
					TOX->TOX_DESCRI := aCadTipo[nYY,10]
				Endif
				TOX->(MsUnLock())
				aAdd(aTOXs , TOX->(Recno()) )
			Next nZZ
		Next nYY

		//Inclui ou altera o cadastro de itens do Tipo de Ficha
		dbSelectArea("TOX")
		dbSetOrder(1)
		If dbSeek( xFilial("TOX") + M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI)
			While !Eof() .and. xFilial("TOX") == TOX->TOX_FILIAL .and. ;
				M->TOX_LAUDO+M->TOX_QUESTI+DTOS(M->TOX_DTREAL) == TOX->TOX_LAUDO+TOX->TOX_QUESTI+DTOS(TOX->TOX_DTREAL)

				If TOX->TOX_QUESTA == Replicate("#",Len(TOX->TOX_QUESTA)) .Or. TOX->TOX_QUESTA == Replicate("@",Len(TOX->TOX_QUESTA))
					dbSelectArea("TOX")
					dbSkip()
					Loop
				Endif
				If aScan(aTOXs, {|x| x == TOX->(Recno()) }) == 0
					dbSelectArea("TOX")
					RecLock("TOX",.F.)
					dbDelete()
					TOX->(MsUnLock())
				Endif
				dbSelectArea("TOX")
				dbSkip()
			End
		Endif
	Endif

ElseIf nOpcx == 5

	dbSelectArea("TOX")
	dbSetOrder(1)
	If dbSeek( xFilial("TOX") + M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI)
		While !Eof() .and. xFilial("TOX") == TOX->TOX_FILIAL .and. ;
			M->TOX_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI == TOX->TOX_LAUDO+DTOS(TOX->TOX_DTREAL)+TOX->TOX_QUESTI
			dbSelectArea("TOX")
			RecLock("TOX",.F.)
			dbDelete()
			TOX->(MsUnLock())
			dbSkip()
		End
	Endif
Endif

Return .T.

/*/


Ŀ
Funo    MDTA691TOX Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Tela de cadastro da tabela TMI                             
Ĵ
 Uso      MDTA145                                                     
ٱ


/*/
Function MDTA691TOX(lWhenTOX,nOpcx__)
Local nOpTemp := 0
Local aSitExa := {STR0019,STR0020}//"1=Ativo"##"2=Inativo"

	DEFINE MSDIALOG oDlgPar TITLE OemToAnsi(cCadastro) From 0,0 To 200,550 OF oMainWnd PIXEL
	oDlgPar:LESCCLOSE := .f.

	//
	// PAGINA 1 - TOX                                
	//
	nLinObj := 2
	@ 0,0 SCROLLBOX oScroll2 VERTICAL OF oDlgPar BORDER
	oScroll2:Align := CONTROL_ALIGN_ALLCLIENT

	@ 28, 012 SAY oS_DtExa Prompt STR0021 PIXEL OF oScroll2 Font oFont12//"Data"
	@ 28, 085 MSGET oG_DtExa VAR M->TOX_DTREAL SIZE 60,9 VALID f691Data(M->TOX_DTREAL) WHEN lWhenTOX PIXEL OF oScroll2 HasButton
	@ 42, 012 SAY oS_TpExa Prompt STR0022 PIXEL OF oScroll2 Font oFont12//"Cdigo do Questionrio"
	@ 42, 085 MSGET oG_TpExa VAR M->TOX_QUESTI SIZE 60,8 WHEN lWhenTOX VALID VALRegis() F3 If(lSigaMdtps,"MDTTMG","TMG") PIXEL OF oScroll2 HasButton


	//
	//Titulo do Grupo                                
	//
	oPanelTmp := TPaintPanel():new(nLinObj-1,-4,aPosObj[1,4]+5,14,oScroll2)
	oPanelTmp:addShape("id=2;type=1;left=0;top=0;width="+Alltrim(Str(aPosObj[1,4]*2.2,5))+";height=28;"+;
                "gradient=1,0,-15,0,40,0.4,#C3DBF9,0.9,#83AAE2,0.0,#FFF6FF;pen-width=0;"+;
                "pen-color=#B0C4DE;can-move=0;can-mark=0;is-blinker=1;")
	@ 2, 11 SAY oGrpNome Prompt TO0->TO0_NOME PIXEL OF oPanelTmp Font oFont16 COLOR CLR_WHITE
	@ 2, 10 SAY oGrpNome Prompt TO0->TO0_NOME PIXEL OF oPanelTmp Font oFont16 COLOR RGB(67,70,87)

	oS_DtExa:SetFocus()
	ACTIVATE MSDIALOG oDlgPar ON INIT EnchoiceBar(oDlgPar,{|| If(fNextPnl(.T.) .and. f691Data(M->TOX_DTREAL) ,(nOpTemp := 1,oDlgPar:End()),nOpTemp := 0) },;
													{|| nOpTemp := 2,oDlgPar:End()}) CENTERED

Return nOpTemp

/*/


Ŀ
Funo     f691Data  Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Valida data do questionario                                
Ĵ
 Uso      MDTA145                                                     
ٱ


/*/
Static Function f691Data(dTMI_DTREAL)

If dTMI_DTREAL > dDataBase
	Help(" ",1,"NGATENCAO",,STR0023,3,1) //"A data do questionrio no pode ser maior que a data atual."
	Return .F.
Endif
If !NaoVazio(dTMI_DTREAL)
	Return .F.
Endif

Return .T.

/*


ͻ
Programa  VALRegis  Autor  Rodrigo Soledade     Data   23/08/12   
͹
Desc.     Validacao para nao ter duplicacao de registro.              
                                                                      
͹
Uso        MDTA691                                                    
ͼ


*/
Static Function VALRegis()

dbSelectArea("TOX")
dbSetOrder(1)
If dbSeek( xFilial("TOX")+TO0->TO0_LAUDO+DTOS(M->TOX_DTREAL)+M->TOX_QUESTI)
	MsgStop(STR0024)//"J existe um Questionrio para essa Data"
	Return .F.
EndIf

If !MDT691VQTI()
	Return .F.
EndIf

Return .T.

/*/


Ŀ
Funo    MDT691VQTI Autor  Denis                  Data  23/08/12 
Ĵ
Descrio  Valida campo TMI_QUESTI                                    
Ĵ
 Uso       Generico                                                   
ٱ


/*/
Static Function MDT691VQTI()
Local lPrest := .F.

If Type("cCliMdtPs") == "C"
	If !Empty(cCliMdtPs)
		lPrest := .T.
	Endif
Endif

If lPrest
	Return (EXISTCPO("TMG",cCliMdtps+M->TOX_QUESTI,2))
Else
	Return (EXISTCPO("TMG",M->TOX_QUESTI,1))
Endif

Return .t.

/*/


Ŀ
Funo      fNextPnl  Autor  Rodrigo Soledade       Data 23/08/2012
Ĵ
Descrio  Ir a proxima tela                                           
Ĵ
 Uso                                                                   
Ĵ


/*/
Static Function fNextPnl(lIncReg)
If Empty(M->TOX_DTREAL)
	MsgInfo(STR0025)//"O campo Data do exame  obrigatrio."
	Return .F.
Endif
If Empty(M->TOX_QUESTI)
	MsgInfo(STR0026)//"O campo Tipo de exame  obrigatrio."
	Return .F.
Endif
If !ExistChav( "TOX" , TOX->TOX_LAUDO + DTOS(M->TOX_DTREAL) + M->TOX_QUESTI )
	Return .F.
Endif
Return .T.

/*


ͻ
Programa  MDTA691Ok Autor  Microsiga            Data   09/04/12   
͹
Desc.      Fun~o que valida se respostas do questionario foram      
           respondidas.                                               
͹
Uso        MDTA691Ok                                                  
ͼ


*/
Static Function MDTA691Ok()
Local nRepost := 0
Local nXX := 0, nYY := 0
	For nYY := 1 to Len(aCadTipo)
		For nXX := 1 To Len(aCadTipo[nYY,4])
			cStrXX := Alltrim( Str(nXX) )
			If aCadTipo[nYY,6] //Radio
				If ValType(aCadTipo[nYY,8,nXX,1]) == "N"
					If aCadTipo[nYY,8,nXX,1] == 1
						nRepost += 1
					Endif
				Endif
			Else //Check
				If ValType(aCadTipo[nYY,8,nXX,1]) == "L"
					If aCadTipo[nYY,8,nXX,1]
						nRepost += 1
					Endif
				Endif
			Endif
		Next nXX
		If !Empty(aCadTipo[nYY,10])
			nRepost += 1
		Endif
	Next nYY
If nRepost < Len(aCadTipo)
	MsgInfo(STR0027,STR0028) //"H perguntas que ainda no foram respondidas!"###"ATENO"
	Return .F.
EndIf

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT691OBS
Habilita campo de observao se opo da Resposta for 'Sim' ou
se for varias opes para selecionar.

@Param nPosObj - Posio do Objeto

@author Jean Pytter da Costa
@since 27/07/2015
@return lRet
/*/
//---------------------------------------------------------------------
Static Function MDT691OBS( nPosObj )

	Local lRet := .F.
	Local nOpcoes := Len( aCadTipo[ nPosObj , 4 ] ) //Variavel para verificar se possui opes para escolher

	If nOpcoes > 0 .And. mv_par01 == 1
		nPosYes := aScan( aCadTipo[ nPosObj , 4 ] , { |x| UPPER( STR0029 ) $ AllTrim( UPPER( x ) ) } ) //"Sim"###Verifica se Sim esta nas opes
		If nPosYes > 0
			If ValType( aCadTipo[ nPosObj , 8 , nPosYes , 1 ] ) == "N" //Verifica se a posio  numrica
				lRet := aCadTipo[ nPosObj , 8 , nPosYes , 1 ] == 1
				If !lRet //Se for a opo No, vai limpar Memo
					aCadTipo[ nPosObj , 10] := ""
				EndIf
			EndIf
		EndIf
		If ValType( aCadTipo[ nPosObj , 8 , 1 , 1 ] ) == "L" //Verifica se a posio  Lgica
			lRet := .T. //Se for Opo Exclusiva, e a selecionada for diferente de 'Sim'.
		EndIf
	Else
		lRet := .T.
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT691OBD
Funo responsavel por habilitar o preenchimento do campo de Observao,
mesmo no existindo campos de perguntas.

@Param cPerg - Pergunta utilizada.

@author Guilherme Freudenburg
@since 09/05/2016
@return lRet
/*/
//---------------------------------------------------------------------
Static Function MDT691OBD(cPerg)

Local nBck := 0 //Backup para a opo selecionada
Local lPerg := .F. //Determina se foi alterado a opo

//Cria Backup da opo selecionada atualmente
nBck := mv_par01

lPerg:= Pergunte( cPerg , .T. )

If !lPerg
	mv_par01 := nBck //Caso no confirme ser retorna a opo anterior
Endif

Return