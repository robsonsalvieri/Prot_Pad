#INCLUDE "mnta990.ch"
#INCLUDE "SHELL.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FOLDER.CH"
#INCLUDE "FWPrintSetup.ch"

Static lMNTA9906 := ExistBlock( 'MNTA9906' )
Static cFieldQry := ''
Static lNGFlut   := SuperGetMV( 'MV_NGFLUT' , .F., 'N') == 'S'
Static lIntegGPE := Trim( SuperGetMV( 'MV_NGMNTRH', .F., 'N') ) $ 'S/X'

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA990
Programacao de Ordem de Serviço

@sample
MNTA990()

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Function MNTA990()

	//---------------------------------------------------------------------
	// Variaveis Temporarias do programa
	//---------------------------------------------------------------------
	Local _c990TRB1, _c990TRB2, _c990TRB3, _c990TRBF, _c990TRBB1, _c990TRBE, _c990TRBM, _c990TRBY, _c990STJTMP, _oList2, _oList3, _oList4, _oList5
	Local lRet     := .T.
	Local aVersion := 	{;
						   	{ 'MNTA420.prx'   , cToD( '09/11/2020' ), '14:30' },;
						   	{ 'MNTUTIL_OS.prw', cToD( '09/11/2020' ), '14:30' },;
						   	{ 'MNTUTIL.prx'   , cToD( '09/11/2020' ), '14:30' },;
							{ 'NGUTIL.prx'    , cToD( '09/11/2020' ), '14:30' };
					  	}


	//---------------------------------------------------------------------
	// Armazena variaveis para devolucao (NGRIGHTCLICK)
	//---------------------------------------------------------------------
	Local aNGBEGINPRM := NGBEGINPRM()

	If ( !FindFunction( 'MNTAmIIn' ) .Or. MNTAmIIn( 19 , 95 ) ) .And. FindFunction( 'NgVldRpo' ) .And. NgVldRpo( aVersion )

		Private lCervPetro := .F.,aIAglu := {}
		// Usado na funcao NGGERASA.. Nao mexer
		Private cNumSA   := Space(TAMSX3("CP_NUM")[1])
		Private lAltera
		Private lIntegRM := AllTrim( SuperGetMV( 'MV_NGINTER', .F., 'N' ) ) == 'M'

		//Deleta Opcoes do Click da direita - TQD
		cChavTQD := "MNTA990"+Space(Len(TQD->TQD_PROGRA)-7)+"fMarcaAll"+Space(Len(TQD->TQD_FUNCAO)-9)
		If NGIFdbSeek("TQD",cChavTQD,1)
			NGDELETAREG("TQD")
		EndIf
		If NGIFdbSeek("TQD",cChavTQD,1)
			NGDELETAREG("TQD")
		EndIf
		cChavTQD := "MNTA990"+Space(Len(TQD->TQD_PROGRA)-7)+"fDesmaAll"+Space(Len(TQD->TQD_FUNCAO)-9)
		If NGIFdbSeek("TQD",cChavTQD,1)
			NGDELETAREG("TQD")
		EndIf
		If NGIFdbSeek("TQD",cChavTQD,1)
			NGDELETAREG("TQD")
		EndIf

		//---------------------------------------------------------------------
		// Armazena variaveis de Tabelas Temporarias
		//---------------------------------------------------------------------
		If(Type("c990TRB1")  == "C",_c990TRB1  := c990TRB1,)
		If(Type("c990TRB2")  == "C",_c990TRB2  := c990TRB2,)
		If(Type("c990TRB3")  == "C",_c990TRB3  := c990TRB3,)
		If(Type("c990TRBF")  == "C",_c990TRBF  := c990TRBF,)
		If(Type("c990TRBB1") == "C",_c990TRBB1 := c990TRBB1,)
		If(Type("c990TRBM")  == "C",_c990TRBM  := c990TRBM,)
		If(Type("c990TRBE")  == "C",_c990TRBE  := c990TRBE,)
		If(Type("c990TRBY")  == "C",_c990TRBY  := c990TRBY,)
		If(Type("c990STJTMP")== "C",_c990STJTMP:= c990STJTMP,)
		If(Type("oList2")    == "O",_oList2    := oList2,)
		If(Type("oList3")    == "O",_oList3    := oList3,)
		If(Type("oList4")    == "O",_oList4    := oList4,)
		If(Type("oList5")    == "O",_oList5    := oList5,)

		Private aRotina     := MenuDef()
		Private aVETINR     := {}
		Private cARQTA990BE := ''
		Private c990TRB1    := ''
		Private c990TRB2    := ''
		Private c990TRB3    := ''
		Private c990TRBF    := ''
		Private c990TRBB1   := ''
		Private c990TRBE    := ''
		Private c990TRBM    := ''
		Private c990TRBY    := ''
		Private c990STJTMP  := ''
		Private cTempStl    := ''
		Private cTabStatus	:= "TQW"
		Private cTabEquipe	:= "TP4"
		Private oARQT9901
		Private oARQT9902
		Private oARQT9903
		Private oARQT990F
		Private oARQT990B1
		Private oARQT990E
		Private oARQT990M
		Private oARQT990Y
		Private oTmpSTL
		Private lCpoEquipe	:= .F.
		Private lCpoStatus	:= .F.
		Private lTJ_EQUIPE	:= .F.
		Private lTJ_XEQUIPE	:= .F.
		Private lTJ_STATUS	:= .F.
		Private lTJ_XMOTIVO	:= .F.
		Private lTJ_XSTATUS	:= .F.
		Private lTJ_STFOLUP	:= .F.
		Private nTamStatus	:= 2
		Private nIndSCP		:= 0

		Private lCpoLbLoc	:= .T.
		Private lCpoTrab	:= .T.
		Private lCpoFamB	:= .T.
		Private lCpoTipM	:= .T.
		Private lCpoAreM	:= .T.
		Private lCpoServ	:= .T.
		Private lCpoOrde	:= .T.
		Private lCpoPlan	:= .T.
		Private lCpoTT2Dt	:= .T.
		Private lCpoVerOs	:= .T.
		Private lCpoEvent	:= .T.
		Private lCpoContDt  := .T.
		Private lCpoContPr  := .T.
		Private nSizeSI3    := If((TAMSX3("I3_CUSTO")[1]) < 1,9,(TAMSX3("I3_CUSTO")[1])) //Tamanho Centro Custo
		Private nSizeSHB    := If((TAMSX3("HB_COD")[1]) < 1,6,(TAMSX3("HB_COD")[1])) //Tamanho Centro Trabalho
		Private nSizeST6    := 6 //Tamanho Familia
		Private nSizeSTE    := 3 //Tamanho Tipo MNT
		Private nSizeSTD    := 6 //Tamanho Area MNT
		Private nSizeST4    := 6 //Tamanho Servico
		Private nSizeSTJ    := 6 //Tamanho Ordem
		Private nSizeSTS    := 6 //Tamanho Plano
		Private nSizeEve    := 6 //Tamanho Evento
		Private lHorDia8    := .F.
		Private lProgIns    := .T.
		Private lFilOsPro   := .T.
		Private lWhenInc    := .F.

		//Verifica se Gera Solicit. ao Armazem em vez de Solic. Compras
		Private lGeraSA   := .F.
		Private aRetSA 	  :={}
		Private cUsaIntEs := AllTrim(GETMV("MV_NGMNTES"))
		Private nSixTT4x  := NGRETORDEM("TT4","TT4_FILIAL+TT4_NUMERO+TT4_ORDEM+TT4_PLANO+TT4_CODIGO+TT4_NUMSC+TT4_NUMSA+TT4_ITEMSA",.F.)

		Private aList2    := {{ 0 , " " , 0 , 0 , 0 , 0 , 0 , "00:00" , "00:00" , 0 , " " }}
		Private aList3    := {}
		Private aList3Def := { { ' ', ' ', ' ', 0 , 0, 0, ' ', SToD( '' ), ' ', ' ', ' ' } } // Conteúdo default da listagem 3
		Private aList4    := {{ " " , " " , " " , 0 }}
		Private aList5    := {{ 0 , " " , " " , " " , "00:00" , "00:00" , 0 , " "}}
		Private nTamParam := 510

		//Inicialização variáveis AEN
		If ExistBlock("MNTA420T")
			Private aLinhaProd := {}
			ExecBlock("MNTA420T", .F., .F.)
		EndIf

		dbSelectArea("TT1")

		If NGCADICBASE("ZZY_DTREPR","D","ZZY",.F.) .And. NGCADICBASE("ZZY_SEQUEN","D","ZZY",.F.);
		.And. NGCADICBASE("ZZY_SERVIC","D","ZZY",.F.) .And. NGCADICBASE("TJ_STATUS","D","STJ",.F.)
			lCervPetro := .T.
			cTabStatus := "TRD"
		EndIf
		nSizeEve := If((TAMSX3('TT1_EVEDE')[1]) < 1,6,(TAMSX3('TT1_EVEDE')[1]))

		If FindFunction("NGGERASA")
			If SuperGetMv("MV_NGGERSA",.F.,"N") == "S" .And. cUsaIntEs == "S"
				lGeraSA := .T.
			EndIf
		EndIf

		If ExistBlock("MNTPROG8HR")
			lHorDia8 := .T.
		EndIf
		If ExistBlock("MNTPROGINS")
			lProgIns := .T.
		EndIf

		dbSelectArea("STJ")
		If STJ->(FieldPos("TJ_EQUIPE")) > 0
			lTJ_EQUIPE := .T.
			lCpoEquipe := .T.
		EndIf
		If STJ->(FieldPos("TJ_XEQUIPE")) > 0
			lTJ_XEQUIPE := .T.
			lCpoEquipe := .T.
		EndIf
		dbSelectArea("SX2")
		dbSetOrder(1)
		If dbSeek(cTabStatus)
			If STJ->(FieldPos("TJ_STATUS")) > 0
				lTJ_STATUS := .T.
				lCpoStatus := .T.
				nTamStatus := Len(STJ->TJ_STATUS)
			EndIf
			If STJ->(FieldPos("TJ_XMOTIVO")) > 0
				lTJ_XMOTIVO := .T.
				lCpoStatus  := .T.
				nTamStatus  := Len(STJ->TJ_XMOTIVO)
			EndIf
			If STJ->(FieldPos("TJ_XSTATUS")) > 0
				lTJ_XSTATUS := .T.
				lCpoStatus  := .T.
				nTamStatus  := Len(STJ->TJ_XSTATUS)
			EndIf
			If STJ->(FieldPos("TJ_STFOLUP")) > 0
				lTJ_STFOLUP := .T.
				lCpoStatus  := .T.
				nTamStatus  := Len(STJ->TJ_STFOLUP)
			EndIf

			//Cervejaria Petropolis
			If lCervPetro
				nTamStatus := Len(TRD->TRD_STATUS)
				lTJ_STFOLUP := .F.
			EndIf
		EndIf

		dbSelectArea("SIX")
		dbSetOrder(1)
		dbSeek("SCP")
		While !EoF() .And. SIX->INDICE == "SCP"
			If "CP_FILIAL+CP_OP+CP_PRODUTO" $ SIX->CHAVE
				If SIX->ORDEM $ "ABCDEFGHIJ"
					If SIX->ORDEM == "A"
						nIndSCP := 10
					ElseIf SIX->ORDEM == "B"
						nIndSCP := 11
					ElseIf SIX->ORDEM == "C"
						nIndSCP := 12
					ElseIf SIX->ORDEM == "D"
						nIndSCP := 13
					ElseIf SIX->ORDEM == "E"
						nIndSCP := 14
					ElseIf SIX->ORDEM == "F"
						nIndSCP := 15
					ElseIf SIX->ORDEM == "G"
						nIndSCP := 16
					ElseIf SIX->ORDEM == "H"
						nIndSCP := 17
					ElseIf SIX->ORDEM == "I"
						nIndSCP := 18
					ElseIf SIX->ORDEM == "J"
						nIndSCP := 19
					EndIf
				Else
					nIndSCP := Val(SIX->ORDEM)
				EndIf

				Exit
			EndIf
			dbSkip()
		End

		//---------------------------------------------------------------------
		// Define o cabecalho da tela de atualizacoes
		//---------------------------------------------------------------------
		Private cCadastro := OemtoAnsi(STR0001) //"Programação de Ordem de Serviço"
		Private aCHKDEL := {}, bNGGRAVA

		//---------------------------------------------------------------------
		// Endereca a funcao de BROWSE
		//---------------------------------------------------------------------
		dbSelectArea("TT1")
		dbSetOrder(1)
		mBrowse( 6, 1,22,75,"TT1")

		//---------------------------------------------------------------------
		// Devolve variaveis armazenadas (NGRIGHTCLICK)
		//---------------------------------------------------------------------
		NGRETURNPRM(aNGBEGINPRM)

		//---------------------------------------------------------------------
		// Devolve variaveis temporaria do programa
		//---------------------------------------------------------------------
		c990TRB1  := _c990TRB1
		c990TRB2  := _c990TRB2
		c990TRB3  := _c990TRB3
		c990TRBF  := _c990TRBF
		c990TRBB1 := _c990TRBB1
		c990TRBE  := _c990TRBE
		c990TRBM  := _c990TRBM
		c990TRBY  := _c990TRBY
		c990STJTMP:= _c990STJTMP
		oList2    := _oList2
		oList3    := _oList3
		oList4    := _oList4

	Else

		ShowHelpDlg(  STR0247 ,;      // ATENÇÃO
					{ STR0343 }, 2,; // Essa rotina passou recentemente por uma atualização importante.
					{ STR0344 }, 2 ) // Favor verificar a documentação MP - MNT - Reestruturação da rotina Programação O.S. no módulo Manutenção de Ativos para maiores detalhes.
		lRet := .F.

	EndIf

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Utilizacao de menu Funcional

Parametros: Parametros do array a Rotina:
1. Nome a aparecer no cabecalho
2. Nome da Rotina associada
3. Reservado
4. Tipo de Transacao a ser efetuada:
1 - Pesquisa e Posiciona em um Banco de Dados
2 - Simplesmente Mostra os Campos
3 - Inclui registros no Bancos de Dados
4 - Altera o registro corrente
5 - Remove o registro corrente do Banco de Dados
5. Nivel de acesso
6. Habilita Menu Funcional

@sample
MenuDef()

@author Denis Hyroshi de Souza
@since 29/11/2006
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function MenuDef()
	Local aRotina :=  { {STR0002, "AxPesqui"  , 0, 1},;  //"Pesquisar"
						{STR0003, "MNTA990CAD", 0, 2},;  //"Visualizar"
						{STR0004, "MNTA990CAD", 0, 3},;  //"Incluir"
						{STR0005, "MNTA990CAD", 0, 4},;  //"Alterar"
						{STR0006, "MNTA990CAD", 0, 5, 3}}

	If AllTrim(GetNewPar("MV_NGPGEVE"," ")) == "S"
		aAdd( aRotina , {STR0191, "MNTA993", 0, 3}) //"Eventos"
	EndIf

	If ExistBlock("MNTA990F")
		aRotina := ExecBlock("MNTA990F", .F., .F., {aRotina})
	EndIf

Return(aRotina)
//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA990CAD
Programacao de Ordem de Serviço

@sample
MNTA990CAD(cAlias,nRecno,nOpcxx)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Function MNTA990CAD(cAlias,nRecno,nOpcxx)

	Local oDlg, oMenu, nForG
	Local nControl  := 0
	Local nInd1     := 0
	Local aPages    := {}
	Local aTitles   := {}
	Local aHead3    := {}
	Local aRetPE    := {}
	Local nOpcOS    := 0
	Local aAreaTT1  := TT1->(GetArea())
	Local oPnlOrdPr
	Local oCarga
	Local lMNTA9905	:= ExistBlock("MNTA9905")
	Local aMNTA9906 := {}
	Local aCpoCompl := {"Situacao", "Status"}
	Local xRet9902  := Nil
	Local aStruct   := {}
	Local dLastDay  := CToD( '' )
	Local nIndex    := 0
	Local cFields   := ''
	Local cFldMemo  := ''
	Local cCampos   := ''
	Local cAlsTL    := ''
	Local aTT1Usr   := {}

	// [LGPD] Caso o usuário não possua acesso ao(s) campo(s), deve-se ofuscá-lo(s)
	Local lOfuscar := FindFunction( 'FWPDCanUse' ) .And. FwPdCanUse( .T. );
						.And. Len( FwProtectedDataUtil():UsrAccessPDField( __CUSERID, { 'T1_NOME' } ) ) == 0

	Private lReplAll
	Private lDefRet
	lAltera := If(nOpcxx = 4,.T.,.F.)

	Private faltera := If(nOpcxx = 4,.T.,.F.) // USADO NA FUNÇÃO NGGERCOTAC
	PRIVATE cPathSiga := GetPvProfString( GetEnvServer(), "StartPath", "ERROR", GetADV97() )
	Private oVerde    := LoadBitmap(GetResources(),'br_verde')
	Private oVermelho := LoadBitmap(GetResources(),'br_vermelho')
	Private oPreto    := LoadBitmap(GetResources(),'br_preto')
	Private oAmarelo  := LoadBitmap(GetResources(),'br_amarelo')
	Private oBranco   := LoadBitmap(GetResources(),'br_branco')
	Private oPink     := LoadBitmap(GetResources(),'br_pink')
	Private oAzul     := LoadBitmap(GetResources(),'br_azul')
	Private oLaranja  := LoadBitmap(GetResources(),'br_laranja')
	Private oCinza    := LoadBitmap(GetResources(),'br_cinza')
	Private oMarron   := LoadBitmap(GetResources(),'br_marron')
	Private oMarkSim  := LoadBitmap(GetResources(),'LBOK')
	Private oMarkNao  := LoadBitmap(GetResources(),'LBNO')
	Private oNgSemInfo:= LoadBitmap(GetResources(),'NG_SEM_INFO')
	Private oPanelTop
	Private nPrimParam := 0
	Private oGet001,oGet002,oMenu1,oMenu2,oBoxObj,oBoxOSP
	Private vCalend       := {}
	Private aCalends      := {}
	Private aOldSA        := {}
	Private lPrgDiaria    := If(AllTrim(GetNewPar("MV_NGPGDIA"," "))=="S",.T.,.F.) //Indica se programacao é diaria
	Private lPrgEvento    := If(AllTrim(GetNewPar("MV_NGPGEVE"," "))=="S",.T.,.F.) //Indica se tem programacao por evento
	Private aCabecProg    := {} //Array com uma linha por dia programado
	Private lAltProg      := .T. //indica se pode alterar informacoes
	Private lEveProg      := .F. //indica se a programacao é para um evento
	Private lAltDtIni     := .T. //Indica se pode alterar a data inicio
	Private cSvTT1COD     := Space(06) //Codigo Programacao Salvo
	Private cSvTT1EVE     := Space(06) //Evento Salvo
	Private dSvTT1INI     := SToD("") //Data Inicio Salvo
	Private dSvTT1FIM     := SToD("") //Data Fim Salvo
	Private cTT1_CODIGO   := Space(06)
	Private dTT1_DTPROG   := dDataBase
	Private _dDiaAtu      := SToD("") //Data do Calendario da tela principal
	Private _dDia2Atu     := SToD("") //Data do Calendario da tela de filtro por data
	Private dTT1_DTFIM    := dDataBase
	Private cTT1_DESCRI   := Space(60)
	Private cTT1_RESPON   := Space(06)
	Private cTT1_NOMRES   := Space(30)
	Private cTT1_CDEVEN   := Space(06)
	Private M->TT1_INDLUB := "2"
	Private M->TT1_INCRE  := " "
	Private M->TT1_QTDDIA := 0
	Private M->TT1_INDLOC := "2"
	Private M->TT1_CONDTA := "1"
	Private M->TT1_PROGAU := "1"
	Private M->TT1_PRIDE  := Space(3)
	Private M->TT1_PRIATE := "ZZZ"
	Private M->TT1_CALEDE := Space(3)
	Private M->TT1_CALEAT := "ZZZ"
	Private M->TT1_ETADE  := Space(6)
	Private M->TT1_ETAAT  := "ZZZZZZ"
	Private M->TT1_BEMDE  := Space(16)
	Private M->TT1_BEMATE := Replicate("Z",16)
	Private M->TT1_EQUDE  := Space(6)
	Private M->TT1_EQUATE := Replicate("Z",6)
	Private M->TT1_STADE  := Space(nTamStatus)
	Private M->TT1_STAATE := Replicate("Z",nTamStatus)
	Private M->TT1_CCDE   := Space(nSizeSI3)
	Private M->TT1_CCATE  := Replicate("Z",nSizeSI3)
	Private M->TT1_TRADE  := Space(nSizeSHB)
	Private M->TT1_TRAATE := Replicate("Z",nSizeSHB)
	Private M->TT1_FAMDE  := Space(nSizeST6)
	Private M->TT1_FAMATE := Replicate("Z",nSizeST6)
	Private M->TT1_TIPDE  := Space(nSizeSTE)
	Private M->TT1_TIPATE := Replicate("Z",nSizeSTE)
	Private M->TT1_AREDE  := Space(nSizeSTD)
	Private M->TT1_AREATE := Replicate("Z",nSizeSTD)
	Private M->TT1_SERDE  := Space(nSizeST4)
	Private M->TT1_SERATE := Replicate("Z",nSizeST4)
	Private M->TT1_ORDDE  := Space(nSizeSTJ)
	Private M->TT1_ORDATE := Replicate("Z",nSizeSTJ)
	Private M->TT1_PLADE  := Space(nSizeSTS)
	Private M->TT1_PLAATE := Replicate("Z",nSizeSTS)
	Private M->TT1_EVEDE  := Space(nSizeEve)
	Private M->TT1_EVEATE := Replicate("Z",nSizeEve)
	Private M->TT1_DTDE   := CtoD(" /  /  ")
	Private M->TT1_DTATE  := CtoD(" /  /  ")
	Private M->TT1_ESTRUT := "2"
	Private cEventoOS     := Space(6)
	Private lIntSFC		  := FindFunction("NGINTSFC") .And. NGINTSFC() // Verifica se ha integracao com modulo Chao de Fabrica [SIGASFC]
	Private cTipoInd  	  := STR0192 //"Prioridade + Data"
	Private nOSPrInd  	  := 1
	Private nTipoInd  	  := 1
	Private aTipoInd  	  := {STR0192,STR0010,STR0193} //"Prioridade + Data"###"Ordem"###"Bem + Ordem"
	Private cStProg990	  := " " //Status OS Programada
	Private cStNaoP990	  := " " //Status OS Nao Programada
	Private cStExec990	  := " " //Status OS Execucao
	Private aIndLub  	  := {STR0301,STR0302} //"1=Sim" ## "2=Não"
	Private aIndInc  	  := {"",STR0303,STR0304,STR0305,STR0306,STR0307} //"1=Igual a" ## "2=Menor que" ## "3=Menor ou Igual a" ## "4=Maior que" ## "5=Maior ou igual a"
	Private aIndLoc  	  := {STR0301,STR0302} //"1=Sim" ## "2=Não"
	Private aIndDtAt 	  := {STR0301,STR0302} //"1=Sim" ## "2=Não"
	Private aIndPrAu 	  := {STR0308,STR0309,STR0310,STR0311} //"1=Corretiva" ## "2=Preventiva" ## "3=Ambas" ## "4=Nenhuma"
	Private lAltAteBem	  := .T. //Indica se pode alterar o parâmetro Até Bem

	If nOpcxx == 4 .Or. lGeraSA .And. nOpcxx == 3
		faltera := .T.
	EndIF

	If lCpoTT2Dt
		If ExistBlock("MNTPGR990") //Ponto de entrada para preencher o status automaticamente ao transferir para o grid direito
			cTemp := ExecBlock( 'MNTPGR990', .F., .F. )
			If Valtype(cTemp) == "C"
				If !Empty(cTemp)
					cStProg990 := cTemp
				EndIf
			EndIf
		EndIf
	EndIf
	If ExistBlock("MNTLIB990") //Ponto de entrada para preencher o status automaticamente ao transferir para o grid esquerdo
		cTemp := ExecBlock( 'MNTLIB990', .F., .F. )
		If Valtype(cTemp) == "C"
			If !Empty(cTemp)
				cStNaoP990 := cTemp
			EndIf
		EndIf
	EndIf
	If ExistBlock("MNTEXE990") //Ponto de entrada para preencher o status automaticamente ao clicar em imprimir
		cTemp := ExecBlock( 'MNTEXE990', .F., .F. )
		If Valtype(cTemp) == "C"
			If !Empty(cTemp)
				cStExec990 := cTemp
			EndIf
		EndIf
	EndIf

	If lCpoContDt

		M->TT1_CONDTA := Alltrim(Posicione("SX3",2, "TT1_CONDTA", "X3_RELACAO"))
		If M->TT1_CONDTA == "1"
			lAltDtIni := .F.
		Else
			lAltDtIni := .T.
		EndIf

		If INCLUI
			M->TT1_PROGAU := Alltrim(Posicione("SX3",2, "TT1_PROGAU", "X3_RELACAO"))
		EndIf
	EndIf

	If nOpcxx <> 3
		//Nao pode alterar se a Data Atual for maior ou igual a Data Inicio
		//Nao pode alterar se ao usuario for diferente
		If nOpcxx == 4
			If TT1->TT1_DTFIM < dDataBase
				MsgStop(STR0194) //"Não será possível alterar a Programação, pois a Data Fim da Programação é menor que a Data Atual."
				Return .F.
			EndIf
		EndIf
		//Nao pode excluir se a Data Atual for maior ou igual a Data Inicio
		//Nao pode excluir se ao usuario for diferente
		If nOpcxx == 5
			If TT1->TT1_DTPROG < dDataBase
				MsgStop(STR0195) //"Não será possível excluir a Programação, pois a Data Inicio é menor que a Data Atual."
				Return .F.
			EndIf
		EndIf
		cTT1_CODIGO   := TT1->TT1_CODIGO
		dTT1_DTPROG   := TT1->TT1_DTPROG
		dTT1_DTFIM    := TT1->TT1_DTFIM
		cTT1_DESCRI   := TT1->TT1_DESCRI
		cTT1_RESPON   := TT1->TT1_RESPON
		If lPrgEvento
			cTT1_CDEVEN   := TT1->TT1_CDEVEN
		EndIf
		cTT1_NOMRES   := NgSeek("ST1",TT1->TT1_RESPON,1,"T1_NOME")
		M->TT1_BEMDE  := TT1->TT1_BEMDE
		M->TT1_BEMATE := TT1->TT1_BEMATE
		M->TT1_EQUDE  := TT1->TT1_EQUDE
		M->TT1_EQUATE := TT1->TT1_EQUATE
		M->TT1_STADE  := Substr(TT1->TT1_STADE,1,nTamStatus)
		M->TT1_STAATE := Substr(TT1->TT1_STAATE,1,nTamStatus)
		M->TT1_CCDE   := Substr(TT1->TT1_CCDE,1,nSizeSI3)
		M->TT1_CCATE  := Substr(TT1->TT1_CCATE,1,nSizeSI3)
		If lCpoVerOs
			If Val(TT1->TT1_VEROSS) > 0 .And. !Empty(TT1->TT1_DTCALE)
				nOSPrInd := Val(TT1->TT1_VEROSS)
			Else
				nOSPrInd := 2
			EndIf
		EndIf
		If lCpoLbLoc
			If !Empty(TT1->TT1_INDLUB)
				M->TT1_INDLUB := TT1->TT1_INDLUB
			EndIf
			If !Empty(TT1->TT1_INDLOC)
				M->TT1_INDLOC := TT1->TT1_INDLOC
			EndIf
		EndIf
		If lCpoTrab
			M->TT1_TRADE  := Substr(TT1->TT1_TRADE,1,nSizeSHB)
			If !Empty(TT1->TT1_TRAATE)
				M->TT1_TRAATE := Substr(TT1->TT1_TRAATE,1,nSizeSHB)
			EndIf
		EndIf
		If lCpoFamB
			M->TT1_FAMDE  := Substr(TT1->TT1_FAMDE,1,nSizeST6)
			If !Empty(TT1->TT1_FAMATE)
				M->TT1_FAMATE := Substr(TT1->TT1_FAMATE,1,nSizeST6)
			EndIf
		EndIf
		If lCpoTipM
			M->TT1_TIPDE  := Substr(TT1->TT1_TIPDE,1,nSizeSTE)
			If !Empty(TT1->TT1_TIPATE)
				M->TT1_TIPATE := Substr(TT1->TT1_TIPATE,1,nSizeSTE)
			EndIf
		EndIf
		If lCpoAreM
			M->TT1_AREDE  := Substr(TT1->TT1_AREDE,1,nSizeSTD)
			If !Empty(TT1->TT1_AREATE)
				M->TT1_AREATE := Substr(TT1->TT1_AREATE,1,nSizeSTD)
			EndIf
		EndIf
		If lCpoServ
			M->TT1_SERDE  := Substr(TT1->TT1_SERDE,1,nSizeST4)
			If !Empty(TT1->TT1_SERATE)
				M->TT1_SERATE := Substr(TT1->TT1_SERATE,1,nSizeST4)
			EndIf
		EndIf
		If lCpoOrde
			M->TT1_ORDDE  := Substr(TT1->TT1_ORDDE,1,nSizeSTJ)
			If !Empty(TT1->TT1_ORDATE)
				M->TT1_ORDATE := Substr(TT1->TT1_ORDATE,1,nSizeSTJ)
			EndIf
		EndIf
		If lCpoPlan
			M->TT1_PLADE  := Substr(TT1->TT1_PLADE,1,nSizeSTS)
			If !Empty(TT1->TT1_PLAATE)
				M->TT1_PLAATE := Substr(TT1->TT1_PLAATE,1,nSizeSTS)
			EndIf
		EndIf
		If lCpoEvent .And. lPrgEvento
			M->TT1_EVEDE  := Substr(TT1->TT1_EVEDE,1,nSizeEve)
			If !Empty(TT1->TT1_EVEATE)
				M->TT1_EVEATE := Substr(TT1->TT1_EVEATE,1,nSizeEve)
			EndIf
		EndIf
		M->TT1_DTDE   := TT1->TT1_DTDE
		M->TT1_DTATE  := TT1->TT1_DTATE
		If Empty(TT1->TT1_DTCALE)
			_dDiaAtu := TT1->TT1_DTPROG
		Else
			_dDiaAtu := TT1->TT1_DTCALE
		EndIf

		M->TT1_PROGAU := TT1->TT1_PROGAU

		If nOpcxx == 2 .Or. nOpcxx == 5 .Or. TT1->TT1_DTFIM < dDataBase
			lAltProg := .F.
			lAltDtIni := .F.
		EndIf
	Else
		cTT1_CODIGO := GetSxeNum("TT1","TT1_CODIGO")

		If ExistBlock('MNTA990G')
			
			aTT1Usr := ExecBlock('MNTA990G',.F.,.F., {cTT1_CODIGO, dTT1_DTPROG, dTT1_DTFIM})
			
			If ValType(aTT1Usr) == 'A' .And. Len(aTT1Usr) == 4

				If ValType(aTT1Usr[1]) == 'C' .And. !Empty(aTT1Usr[1])
					cTT1_RESPON := aTT1Usr[1]
					cTT1_NOMRES := NgSeek('ST1',cTT1_RESPON,1,'T1_NOME')
				EndIf
				If ValType(aTT1Usr[2]) == 'D' .And. !Empty(aTT1Usr[2])
					dTT1_DTPROG := aTT1Usr[2]
				EndIf
				If ValType(aTT1Usr[3]) == 'D' .And. !Empty(aTT1Usr[3])
					dTT1_DTFIM := aTT1Usr[3]
				EndIf
				If ValType(aTT1Usr[4]) == 'C' .And. !Empty(aTT1Usr[4])
					cTT1_DESCRI := aTT1Usr[4]
				EndIf
			
			EndIf
		
		EndIf

		If ScreenProg(nOpcxx,1) == 0
			//cancelou a tela
			RollbackSx8()
			Return 0
		EndIf
		_dDiaAtu := dTT1_DTPROG
		If lCpoVerOs
			nOSPrInd := 2
		EndIf
	EndIf
	cSvTT1COD := cTT1_CODIGO
	dSvTT1INI := dTT1_DTPROG
	dSvTT1FIM := dTT1_DTFIM
	If !Empty(cTT1_CDEVEN) .And. lPrgEvento
		lEveProg  := .T.
		cEventoOS := cTT1_CDEVEN
		cSvTT1EVE := cTT1_CDEVEN
	EndIf

	Private aNgBtn  := {}
	Private cMARCA  := GetMark()
	Private oMARK1
	Private oMARK2
	Private oCalend
	Private aAltEvent  := {} //OS que foram alteradas de evento
	Private aOS_Evento := {} //Carrega as OS do evento na alteração
	Private aList2bkp  := {} //Carrega toda a carga disponivel das especialidades
	Private aList5bkp  := {} //Carrega toda a carga disponivel das especialidades
	Private aDisponBkp := {}
	Private aList2	   := {{ 0 , " " , 0 , 0 , 0 , 0 , 0 , "00:00" , "00:00" , 0 , " "}}
	Private aList4     := {{ " " , " " , " " , 0 }}
	Private aList5     := {{ 0 , " " , " " , " " , "00:00" , "00:00" , 0 , " " }}
	Private cCadastro  := STR0009 //"Programação de O.S."
	Private lInverte   := .F.
	Private lQuery     := .T.
	Private cBuscaOS   := Space(6)
	Private aInfoTQW   := {} //Informacoes da TQW - Legenda
	Private aListaSH9  := {} //Armazena as exceções de calendario
	Private oPanel1    

	//True  - Mostra todas as OS programadas
	//False - Mostra todas as OS programadas do dia selecionado no calendario
	Private lVisPrgOS := .T.

	Private aCores1 := {{"(c990TRB1)->REALIZA == '1'", 'BR_CINZA'  },;
						{"(c990TRB1)->SITUACA == 'L'", 'BR_VERDE'  },;
						{"(c990TRB1)->SITUACA == 'P'", 'BR_LARANJA'},;
						{"!((c990TRB1)->SITUACA $ 'LP')",'LBNO'} }

	Private aCores2 := {{"(c990TRB3)->LIBERA  == '1'", 'BR_AZUL'   },;
						{"(c990TRB3)->REALIZA == '1'", 'BR_CINZA'  },;
						{"(c990TRB3)->SITUACA == 'L'", 'BR_VERDE'  },;
						{"(c990TRB3)->SITUACA == 'P'", 'BR_LARANJA'},;
						{"!((c990TRB3)->SITUACA $ 'LP')",'LBNO'} }

	//---------------------------------------------------------------------
	//Tabela - Ordens de Servicos - Esquerda
	//---------------------------------------------------------------------
	aDBF := {}
		aAdd( aDbf, { 'MARCADO', 'C', 02, 0 } )
		aAdd( aDbf, { 'SEQUENC', 'C', 05, 0 } )
		aAdd( aDbf, { 'PRIORID', 'C', 03, 0 } )
		// Campo prioridade com o valor invertido, serve para que os campos sejam ordenados corretamente em tela
		aAdd( aDbf, { 'PRIOINV', 'N', 03, 0 } )
		aAdd( aDbf, { 'ORDEM'  , 'C', 06, 0 } )
		aAdd( aDbf, { 'PLANO'  , 'C', 06, 0 } )
		aAdd( aDbf, { 'CODBEM' , 'C', 16, 0 } )
		aAdd( aDbf, { 'DESCRIC', 'C', 50, 0 } )
		aAdd( aDbf, { 'CODSER' , 'C', 06, 0 } )
		aAdd( aDbf, { 'DESSER' , 'C', 40, 0 } )
		aAdd( aDbf, { 'EQUIPE' , 'C', 06, 0 } )
		aAdd( aDbf, { 'SEQRELA', 'C', 03, 0 } )
		aAdd( aDbf, { 'DTORIGI', 'D', 08, 0 } )
		aAdd( aDbf, { 'DTMPINI', 'D', 08, 0 } )
		aAdd( aDbf, { 'HOMPINI', 'C', 05, 0 } )
		aAdd( aDbf, { 'DTMPFIM', 'D', 08, 0 } )
		aAdd( aDbf, { 'HOMPFIM', 'C', 05, 0 } )
		aAdd( aDbf, { 'DTMPROG', 'D', 08, 0 } )
		aAdd( aDbf, { 'EVENTO' , 'C', 06, 0 } )
		aAdd( aDbf, { 'XSTATUS', 'C', nTamStatus, 0 } )
		aAdd( aDbf, { 'SITUACA', 'C', 01, 0 } )
		aAdd( aDbf, { 'REALIZA', 'C', 01, 0 } )

	aTRB1 := {}
	aAdd( aTRB1, { "ORDEM"  , NIL, STR0010, } ) //"Ordem"
	aAdd( aTRB1, { "CODBEM" , NIL, STR0011, } ) //"Bem"
	aAdd( aTRB1, { "DESCRIC", NIL, STR0012, } ) //"Descrição"
	aAdd( aTRB1, { "CODSER" , NIL, STR0159, } ) //"Serviço"
	aAdd( aTRB1, { "DESSER" , NIL, STR0263, } ) //"Desc. Serviço"
	If lCpoEquipe
		aAdd( aTRB1, { "EQUIPE", NIL, STR0013, } ) //"Equipe"
		cTipoInd := STR0196 //"Equipe + Bem"
		aAdd(aTipoInd,STR0196) //"Equipe + Bem"
		nTipoInd := 4
	EndIf
	aAdd( aTRB1, { "DTMPINI", NIL, STR0015, } ) //"Data Prevista"
	aAdd( aTRB1, { "PRIORID", NIL, STR0016, } ) //"Prior."
	If lCpoStatus
		aAdd( aTRB1, { "XSTATUS", NIL, STR0254, } ) //"Cód. Status"
	EndIf

	//---------------------------------------------------------------------
	//Tabela - Ordens de Servicos - Direito
	//---------------------------------------------------------------------
	aDBFa := {}
		aAdd( aDbfA, { 'MARCADO', 'C', 02, 0 } )
		aAdd( aDbfA, { 'SEQUENC', 'C', 05, 0 } )
		aAdd( aDbfA, { 'PRIORID', 'C', 03, 0 } )
		// Campo prioridade com o valor invertido, serve para que os campos sejam ordenados corretamente em tela
		aAdd( aDbfA, { 'PRIOINV', 'N', 03, 0 } )
		aAdd( aDbfA, { 'ORDEM'  , 'C', 06, 0 } )
		aAdd( aDbfA, { 'PLANO'  , 'C', 06, 0 } )
		aAdd( aDbfA, { 'CODBEM' , 'C', 16, 0 } )
		aAdd( aDbfA, { 'DESCRIC', 'C', 50, 0 } )
		aAdd( aDbfA, { 'CODSER' , 'C', 06, 0 } )
		aAdd( aDbfA, { 'DESSER' , 'C', 40, 0 } )
		aAdd( aDbfA, { 'EQUIPE' , 'C', 06, 0 } )
		aAdd( aDbfA, { 'SEQRELA', 'C', 03, 0 } )
		aAdd( aDbfA, { 'DTORIGI', 'D', 08, 0 } )
		aAdd( aDbfA, { 'DTMPINI', 'D', 08, 0 } )
		aAdd( aDbfA, { 'HOMPINI', 'C', 05, 0 } )
		aAdd( aDbfA, { 'DTMPFIM', 'D', 08, 0 } )
		aAdd( aDbfA, { 'HOMPFIM', 'C', 05, 0 } )
		aAdd( aDbfA, { 'DTMPROG', 'D', 08, 0 } )
		aAdd( aDbfA, { 'EVENTO' , 'C', 06, 0 } )
		aAdd( aDbfA, { 'XSTATUS', 'C', nTamStatus, 0 } )
		aAdd( aDbfA, { 'SITUACA', 'C', 01, 0 } )
		aAdd( aDbfA, { 'REALIZA', 'C', 01, 0 } )
		aAdd( aDbfA, { 'LIBERA' , 'C', 01, 0 } )


	aTRB2 := {}
	aAdd( aTRB2, { "ORDEM"    , NIL, STR0010, } ) //"Ordem"
	aAdd( aTRB2, { "CODBEM"   , NIL, STR0011, } ) //"Bem"
	aAdd( aTRB2, { "DESCRIC"  , NIL, STR0012, } ) //"Descrição"
	aAdd( aTRB2, { "CODSER"   , NIL, STR0159, } ) //"Serviço"
	aAdd( aTRB2, { "DESSER"   , NIL, STR0263, } ) //"Desc. Serviço"
	If lCpoEquipe
		aAdd( aTRB2, { "EQUIPE"   , NIL, STR0013, } ) //"Equipe"
	EndIf
	If lCpoTT2Dt
		aAdd( aTRB2, { "DTMPROG"  , NIL, STR0197, } ) //"Data Programada"
	EndIf
	aAdd( aTRB2, { "DTMPINI"  , NIL, STR0015, } ) //"Data Prevista"
	If lPrgEvento .And. lPrgDiaria
		aAdd( aTRB2, { "EVENTO"   , NIL, STR0198 } ) //"Evento"
	EndIf
	aAdd( aTRB2, { "PRIORID"  , NIL, STR0016, } ) //"Prior."
	If lCpoStatus
		aAdd( aTRB2, { "XSTATUS"  , NIL, STR0254, } ) //"Cód. Status"
	EndIf

	// Adiciona campos na TRB
	If ExistBlock("MNTA9902")
		xRet9902 := ExecBlock("MNTA9902",.F.,.F.,{@aTRB1, @aDBF, @aTRB2, @aDBFa, @aCpoCompl})
		If ValType(xRet9902) == "A"
			aTRB1     := xRet9902[1]
			aTRB2     := xRet9902[2]
			aDBF      := xRet9902[3]
			aDBFa     := xRet9902[4]
			aCpoCompl := xRet9902[5]
		EndIf
	EndIf

	c990TRB1   := GetNextAlias()
	//Instância classe FWTemporaryTable
	oARQT9901 := FWTemporaryTable():New(c990TRB1, aDBF)

	//Cria indices
	// Primeiro indice usa o campo Prioridade invertido pois ele é usado para fazer a ordenação das Ordens em tela
	oARQT9901:AddIndex("Ind01", {"PRIOINV","DTMPINI","ORDEM"}) 
	oARQT9901:AddIndex("Ind02", {"MARCADO"})
	oARQT9901:AddIndex("Ind03", {"ORDEM","PLANO"})
	oARQT9901:AddIndex("Ind04", {"EQUIPE","CODBEM","ORDEM"})
	oARQT9901:AddIndex("Ind05", {"CODBEM","ORDEM"})
	oARQT9901:AddIndex("Ind06", {"DTMPROG"})
	//Cria a tabela temporaria
	oARQT9901:Create()

	c990TRB2   := GetNextAlias()
	//Instância classe FWTemporaryTable
	oARQT9902 := FWTemporaryTable():New(c990TRB2, aDBFa)
	//Cria indices
	oARQT9902:AddIndex("Ind01", {"PRIORID","DTMPINI","ORDEM"})
	oARQT9902:AddIndex("Ind02", {"MARCADO"})
	oARQT9902:AddIndex("Ind03", {"ORDEM","PLANO"})
	oARQT9902:AddIndex("Ind04", {"EQUIPE","CODBEM","ORDEM"})
	oARQT9902:AddIndex("Ind05", {"CODBEM","ORDEM"})
	oARQT9902:AddIndex("Ind06", {"DTMPROG"})
	//Cria a tabela temporaria
	oARQT9902:Create()

	c990TRB3   := GetNextAlias()
	//Instância classe FWTemporaryTable
	oARQT9903 := FWTemporaryTable():New(c990TRB3, aDBFa)

	//Cria indices
	// Primeiro indice usa o campo Prioridade invertido pois ele é usado para fazer a ordenação das Ordens em tela
	oARQT9903:AddIndex("Ind01", {"PRIOINV","DTMPINI","ORDEM"})
	oARQT9903:AddIndex("Ind02", {"MARCADO"})
	oARQT9903:AddIndex("Ind03", {"ORDEM","PLANO"})
	oARQT9903:AddIndex("Ind04", {"EQUIPE","CODBEM","ORDEM"})
	oARQT9903:AddIndex("Ind05", {"CODBEM","ORDEM"})
	oARQT9903:AddIndex("Ind06", {"DTMPROG"})
	//Cria a tabela temporaria
	oARQT9903:Create()

	// Tabela temporária de insumos
	aStruct := STL->( dbStruct() )

	// Define status do registro como: ( 0-Não alterado, 1-Incluso, 2-Alterado, 3-Deletado )
	aAdd( aStruct, { 'STATUS', 'N', 01, 0 } )

	/*
		Campo para gravação do recno original da tabela de insumos STL. Necessário pois ao utilizar uma tabela temporária
		está possui um recno proprio assim divergindo de seu número original.
	*/
	aAdd( aStruct, { 'RECNO' , 'N', 16, 0 } )

	cTempStl := GetNextAlias()

	oTmpSTL  := FWTemporaryTable():New( cTempStl, aStruct )

	oTmpSTL:AddIndex( '1', { 'TL_ORDEM' , 'TL_PLANO', 'TL_SEQRELA', 'TL_TIPOREG', 'TL_CODIGO' } )
	oTmpSTL:AddIndex( '2', { 'TL_ORDEM' , 'TL_PLANO', 'TL_TAREFA', 'TL_TIPOREG', 'TL_CODIGO', 'TL_SEQRELA', 'TL_SEQTARE' } )
	oTmpSTL:AddIndex( '3', { 'TL_NUMSC', 'TL_ITEMSC' } )
	oTmpSTL:AddIndex( '4', { 'TL_NUMSA', 'TL_ITEMSA' } )
	oTmpSTL:AddIndex( '5', { 'TL_ORDEM', 'TL_PLANO', 'TL_TAREFA', 'TL_TIPOREG', 'TL_CODIGO', 'TL_SEQTARE', 'STATUS' } )
	oTmpSTL:AddIndex( '6', { 'STATUS' } )
	oTmpSTL:AddIndex( '7', { 'TL_ORDEM' , 'TL_PLANO', 'TL_SEQRELA', 'TL_TAREFA' } ) // Indice utilizado na impressão da O.S. nas rotinas MNTR676 e MNTR675.

	oTmpSTL:Create()

	// Gera ordenção dos campos selecionado na query utilizada para montagem do grid de insumos.
	For nIndex := 1 To Len( aStruct )

		If aStruct[nIndex,1] $ 'STATUS/RECNO' .Or. X3Uso( Posicione( 'SX3', 2, aStruct[nIndex,1], 'X3_USADO' ) )
			
			If aStruct[nIndex,2] != 'M' 
				
				cFields  += IIf( Empty( cFields ), aStruct[nIndex,1], ',' + aStruct[nIndex,1] )
				
			Else

				cFldMemo += ',' + aStruct[nIndex,1]

			EndIf
		
		EndIf
		
	Next nIndex

	// Campos do tipo MEMO devem ser os ultimos campos selecionados na query.
	cFieldQry := '%' + cFields + cFldMemo + '%'

	//Se não for inclusão, carrega informações de OS nos 2 'grids'
	If nOpcxx <> 3
		dbSelectArea("TT2")
		dbSetOrder(1)
		dbSeek(xFilial("TT2")+TT1->TT1_CODIGO)
		While !EoF() .And. xFilial("TT2")+TT1->TT1_CODIGO == TT2->(TT2_FILIAL+TT2_CODIGO)

			If TT2->TT2_TIPO == "2" .And. lEveProg .And. lPrgEvento
				aAdd( aOS_Evento , { TT2->TT2_ORDEM , TT2->TT2_PLANO } )
			EndIf

			cEquTmp := TT2->TT2_EQUIPE
			cStaTmp := Substr(TT2->TT2_STATUS,1,nTamStatus)
			cSituac := TT2->TT2_SITUAC

			dbSelectArea("STJ")
			dbSetOrder(1)
			If dbSeek(xFilial("STJ")+TT2->TT2_ORDEM+TT2->TT2_PLANO)
				
				If lTJ_EQUIPE
					cEquTmp := STJ->TJ_EQUIPE
				ElseIf lTJ_XEQUIPE
					cEquTmp := STJ->TJ_XEQUIPE
				EndIf

				If lTJ_STFOLUP
					cStaTmp := STJ->TJ_STFOLUP
				ElseIf lTJ_STATUS
					cStaTmp := STJ->TJ_STATUS
				ElseIf lTJ_XMOTIVO
					cStaTmp := STJ->TJ_XMOTIVO
				ElseIf lTJ_XSTATUS
					cStaTmp := STJ->TJ_XSTATUS
				EndIf

				cSituac := STJ->TJ_SITUACA
				cAlsTL  := GetNextAlias()

				BeginSQL Alias cAlsTL

					SELECT
						COUNT( TL_ORDEM ) AS QUANT
					FROM
						%table:STL% STL
					WHERE
						STL.TL_SEQRELA > '0'                 AND
						STL.TL_FILIAL  = %xFilial:STL%       AND
						STL.TL_ORDEM   = %exp:STJ->TJ_ORDEM% AND
						STL.TL_PLANO   = %exp:STJ->TJ_PLANO% AND
						STL.%NotDel%

				EndSQL

				cRealiz := IIf( (cAlsTL)->QUANT > 0, '1', '0' )

				(cAlsTL)->( dbCloseArea() )

			Else
				dbSelectArea("TT2")
				dbSkip()
				Loop
			EndIf

			If STJ->TJ_SITUACA == "C" .OR. STJ->TJ_TERMINO == "S"
				dbSelectArea("TT2")
				dbSkip()
				Loop
			EndIf
			If ( M->TT1_INDLUB == "2" .And. STJ->TJ_LUBRIFI == "S" ) .Or. ( M->TT1_INDLOC == "2" .And. STJ->TJ_TIPOOS != "B" )
				dbSelectArea("TT2")
				dbSkip()
				Loop
			EndIf

			If TT2->TT2_TIPO == "1"

				dbSelectArea(c990TRB1)
				(c990TRB1)->(dbAppend())
				If !Empty(TT2->TT2_MARCA)
					(c990TRB1)->MARCADO := cMarca
				EndIf
				(c990TRB1)->SEQUENC := TT2->TT2_SEQ
				(c990TRB1)->PRIORID := TT2->TT2_PRIORI
				If Type(TT2->TT2_PRIORI) == 'N'
					(c990TRB1)->PRIOINV := (Val(TT2->TT2_PRIORI) * -1)
				Else
					(c990TRB1)->PRIOINV := 0
				EndIf
				(c990TRB1)->ORDEM   := TT2->TT2_ORDEM
				(c990TRB1)->CODBEM  := TT2->TT2_CODBEM
				If STJ->TJ_TIPOOS == "B"
					(c990TRB1)->DESCRIC := NGSEEK("ST9", TT2->TT2_CODBEM ,1,"T9_NOME")
				Else
					(c990TRB1)->DESCRIC := NGSEEK("TAF","X2"+Substr(TT2->TT2_CODBEM,1,3),7,"TAF_NOMNIV")
				EndIf
				(c990TRB1)->CODSER  := STJ->TJ_SERVICO
				(c990TRB1)->SEQRELA := STJ->TJ_SEQRELA
				(c990TRB1)->DESSER  := NGSEEK("ST4", STJ->TJ_SERVICO ,1,"ST4->T4_NOME")
				(c990TRB1)->EQUIPE  := cEquTmp
				(c990TRB1)->XSTATUS := cStaTmp
				(c990TRB1)->PLANO   := TT2->TT2_PLANO
				(c990TRB1)->DTMPINI := TT2->TT2_DTINI
				(c990TRB1)->HOMPINI := STJ->TJ_HOMPINI
				(c990TRB1)->DTMPFIM := STJ->TJ_DTMPFIM
				(c990TRB1)->HOMPFIM := STJ->TJ_HOMPFIM
				(c990TRB1)->DTORIGI := If(Empty(TT2->TT2_DTORIG),STJ->TJ_DTORIGI,TT2->TT2_DTORIG)
				(c990TRB1)->DTMPROG := SToD("")
				(c990TRB1)->SITUACA := cSituac
				(c990TRB1)->REALIZA := cRealiz

				//Ponto de entrada para alimentar os campos criado pelo ponto de entrada MNTA9902
				If lMNTA9905
					ExecBlock("MNTA9905",.F.,.F.,{c990TRB1})
				EndIf

			ElseIf TT2->TT2_TIPO == "2"
				
				RecLock( c990TRB2, .T. )
				
				If !Empty(TT2->TT2_MARCA)
					(c990TRB2)->MARCADO := cMarca
				EndIf

				(c990TRB2)->SEQUENC := TT2->TT2_SEQ
				(c990TRB2)->PRIORID := TT2->TT2_PRIORI
				If Type(TT2->TT2_PRIORI) == 'N'
					(c990TRB2)->PRIOINV := (Val(TT2->TT2_PRIORI) * -1)
				Else
					(c990TRB2)->PRIOINV := 0
				EndIf
				(c990TRB2)->ORDEM   := TT2->TT2_ORDEM
				(c990TRB2)->CODBEM  := TT2->TT2_CODBEM
				If STJ->TJ_TIPOOS == "B"
					(c990TRB2)->DESCRIC := NGSEEK("ST9", TT2->TT2_CODBEM ,1,"T9_NOME")
				Else
					(c990TRB2)->DESCRIC := NGSEEK("TAF","X2"+Substr(TT2->TT2_CODBEM,1,3),7,"TAF_NOMNIV")
				EndIf
				(c990TRB2)->CODSER  := STJ->TJ_SERVICO
				(c990TRB2)->SEQRELA := STJ->TJ_SEQRELA
				(c990TRB2)->DESSER  := NGSEEK("ST4", STJ->TJ_SERVICO ,1,"ST4->T4_NOME")
				(c990TRB2)->EQUIPE  := cEquTmp
				(c990TRB2)->XSTATUS := cStaTmp
				(c990TRB2)->PLANO   := TT2->TT2_PLANO
				(c990TRB2)->DTMPINI := TT2->TT2_DTINI
				(c990TRB2)->HOMPINI := STJ->TJ_HOMPINI
				(c990TRB2)->DTMPFIM := STJ->TJ_DTMPFIM
				(c990TRB2)->HOMPFIM := STJ->TJ_HOMPFIM
				If Empty(TT2->TT2_DTPROG)
					(c990TRB2)->DTMPROG := TT1->TT1_DTPROG
				Else
					(c990TRB2)->DTMPROG := TT2->TT2_DTPROG
				EndIf
				(c990TRB2)->DTORIGI := If(Empty(TT2->TT2_DTORIG),STJ->TJ_DTORIGI,TT2->TT2_DTORIG)
				(c990TRB2)->SITUACA := cSituac
				(c990TRB2)->REALIZA := cRealiz
				(c990TRB2)->LIBERA  := TT2->TT2_LIBERA
				(c990TRB2)->EVENTO  := TT2->TT2_EVENTO

				// P.E. que atribui conteúdo aos campos de usuário criados pelo P.E. MNTA9902.
				If lMNTA9906 .And. ValType( aMNTA9906 := ExecBlock( 'MNTA9906', .F., .F., { c990TRB2, aDBFa } ) ) == 'A'

					For nIndex := 1 To Len( aMNTA9906 )
						
						// Valida a existência do campo na tabela temporária.
						If (c990TRB2)->( FieldPos( aMNTA9906[nIndex,1] ) ) > 0
							(c990TRB2)->&( aMNTA9906[nIndex,1] ) := aMNTA9906[nIndex,2]
						EndIf

					Next nIndex

				EndIf

				(c990TRB2)->( MsUnLock() )

				lVai := .F.
				If nOSPrInd == 1
					lVai := .T.
				Else
					If lCpoTT2Dt
						If Empty(TT2->TT2_DTPROG)
							If _dDiaAtu == TT1->TT1_DTPROG
								lVai := .T.
							EndIf
						Else
							If _dDiaAtu == TT2->TT2_DTPROG
								lVai := .T.
							EndIf
						EndIf
					EndIf
				EndIf

				If lVai //Se Ver todas OS ou a Data OS for a mesma do calendario

					RecLock( c990TRB3, .T. )
					
					If !Empty(TT2->TT2_MARCA)
						(c990TRB3)->MARCADO := cMarca
					EndIf
					(c990TRB3)->SEQUENC := TT2->TT2_SEQ
					(c990TRB3)->PRIORID := TT2->TT2_PRIORI
					If Type(TT2->TT2_PRIORI) == 'N'
						(c990TRB3)->PRIOINV := (Val(TT2->TT2_PRIORI) * -1)
					Else
						(c990TRB3)->PRIOINV := 0
					EndIf
					(c990TRB3)->ORDEM   := TT2->TT2_ORDEM
					(c990TRB3)->CODBEM  := TT2->TT2_CODBEM
					If STJ->TJ_TIPOOS == "B"
						(c990TRB3)->DESCRIC := NGSEEK("ST9", TT2->TT2_CODBEM ,1,"T9_NOME")
					Else
						(c990TRB3)->DESCRIC := NGSEEK("TAF","X2"+Substr(TT2->TT2_CODBEM,1,3),7,"TAF_NOMNIV")
					EndIf
					(c990TRB3)->CODSER  := STJ->TJ_SERVICO
					(c990TRB3)->SEQRELA := STJ->TJ_SEQRELA
					(c990TRB3)->DESSER  := NGSEEK("ST4", STJ->TJ_SERVICO ,1,"ST4->T4_NOME")
					(c990TRB3)->EQUIPE  := cEquTmp
					(c990TRB3)->XSTATUS := cStaTmp
					(c990TRB3)->PLANO   := TT2->TT2_PLANO
					(c990TRB3)->DTMPINI := TT2->TT2_DTINI
					(c990TRB3)->HOMPINI := STJ->TJ_HOMPINI
					(c990TRB3)->DTMPFIM := STJ->TJ_DTMPFIM
					(c990TRB3)->HOMPFIM := STJ->TJ_HOMPFIM
					If Empty(TT2->TT2_DTPROG)
						(c990TRB3)->DTMPROG := TT1->TT1_DTPROG
					Else
						(c990TRB3)->DTMPROG := TT2->TT2_DTPROG
					EndIf
					(c990TRB3)->DTORIGI := If(Empty(TT2->TT2_DTORIG),STJ->TJ_DTORIGI,TT2->TT2_DTORIG)
					(c990TRB3)->SITUACA := cSituac
					(c990TRB3)->REALIZA := cRealiz
					(c990TRB3)->LIBERA  := TT2->TT2_LIBERA
					(c990TRB3)->EVENTO  := TT2->TT2_EVENTO

					// P.E. que atribui conteúdo aos campos de usuário criados pelo P.E. MNTA9902.
					If lMNTA9906 .And. ValType( aMNTA9906 := ExecBlock( 'MNTA9906', .F., .F., { c990TRB3, aDBFa } ) ) == 'A'

						For nIndex := 1 To Len( aMNTA9906 )

							// Valida a existência do campo na tabela temporária.
							If (c990TRB3)->( FieldPos( aMNTA9906[nIndex,1] ) ) > 0
								(c990TRB3)->&( aMNTA9906[nIndex,1] ) := aMNTA9906[nIndex,2]
							EndIf

						Next nIndex

					EndIf

					(c990TRB3)->( MsUnLock() )

				EndIf

			EndIf

			// Inclui registros na tabela temporária de insumos
			dbSelectArea( 'STL' )
			dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
			If dbSeek( xFilial( 'STL' ) + TT2->TT2_ORDEM + TT2->TT2_PLANO )

				Do While STL->( !EoF() ) .And. TT2->TT2_ORDEM == STL->TL_ORDEM .And. TT2->TT2_PLANO == STL->TL_PLANO

					fInsertSTL( STL->TL_FILIAL + STL->TL_ORDEM + STL->TL_PLANO + STL->TL_TAREFA + STL->TL_TIPOREG +;
						STL->TL_CODIGO + STL->TL_SEQRELA + STL->TL_SEQTARE )

					STL->( dbSkip() )

				EndDo

			EndIf

			dbSelectArea("TT2")
			dbSkip()
		End
	EndIf

	oFont08	:= TFont():New("Arial",07,07,,.F.,,,,.F.,.F.)
	oFont12	:= TFont():New("Arial",09,09,,.T.,,,,.F.,.F.)
	oFont13	:= TFont():New("Arial",,-12,,.T.,,,,.T.,.F.)
	oFont14	:= TFont():New("Arial",,-14,,.T.,,,,.T.,.F.)
	oFont20	:= TFont():New("Arial",12,12,,.T.,,,,.F.,.F.)
	//---------------------------------------------------------------------
	//Tabela - Ferramentas
	//---------------------------------------------------------------------
	aDBFf := {}
		aAdd(aDBFf, { "ORDEM"  , "C" , 06, 0 } )
		aAdd(aDBFf, { "PLANO"  , "C" , 06, 0 } )
		aAdd(aDBFf, { "CODIGO" , "C" , 06, 0 } )
		aAdd(aDBFf, { "DESCRI" , "C" , 30, 0 } )
		aAdd(aDBFf, { "QUANTI" , "N" , 06, 2 } )

	c990TRBF   := GetNextAlias()
	//Instância classe FWTemporaryTable
	oARQT990F := FWTemporaryTable():New(c990TRBF, aDBFf)
	//Cria indices
	oARQT990F:AddIndex("Ind01", {"ORDEM","PLANO","CODIGO"})
	//Cria a tabela temporaria
	oARQT990F:Create()

	//---------------------------------------------------------------------
	//Tabela - Produtos
	//---------------------------------------------------------------------
	nTamSB1 := Len(SB1->B1_COD)
	aDBFp := {}
		aAdd(aDBFp, { "ORDEM"  , "C" , 06, 0 } )
		aAdd(aDBFp, { "PLANO"  , "C" , 06, 0 } )
		aAdd(aDBFp, { "CODIGO" , "C" , nTamSB1, 0 } )
		aAdd(aDBFp, { "DESCRI" , "C" , 30, 0 } )
		aAdd(aDBFp, { "QTDNEC" , "N" , 10, 2 } )
		aAdd(aDBFp, { "QTDEST" , "N" , 15, 2 } )
		aAdd(aDBFp, { "QTDFIS" , "N" , 15, 2 } )
		aAdd(aDBFp, { "NUMSC"  , "C" , 06, 0 } )
		aAdd(aDBFp, { "DTPREV" , "D" , 08, 0 } )
		aAdd(aDBFp, { "NUMSA"  , "C" , 06, 0 } )
		aAdd(aDBFp, { "ITEMSA" , "C" , 02, 0 } )
		aAdd(aDBFp, { "DTINIP" , "D" , 08, 0 } )

	c990TRBB1   := GetNextAlias()
	//Instância classe FWTemporaryTable
	oARQT990B1 := FWTemporaryTable():New(c990TRBB1, aDBFp)
	//Cria indices
	oARQT990B1:AddIndex( 'Ind01', {"ORDEM","PLANO","CODIGO","NUMSC","NUMSA","ITEMSA"})
	//Cria a tabela temporaria
	oARQT990B1:Create()

	//---------------------------------------------------------------------
	//Tabela - Especialidades
	//---------------------------------------------------------------------
	aDBFe := {}
		aAdd(aDBFe, { "ORDEM"  , "C" , 06, 0 } )
		aAdd(aDBFe, { "PLANO"  , "C" , 06, 0 } )
		aAdd(aDBFe, { "CODIGO" , "C" , 06, 0 } )
		aAdd(aDBFe, { "DESCRI" , "C" , 40, 0 } )
		aAdd(aDBFe, { "TOTTEC" , "N" , 06, 0 } )
		aAdd(aDBFe, { "QTDTEC" , "N" , 06, 0 } )
		aAdd(aDBFe, { "TECADD" , "N" , 03, 0 } )
		aAdd(aDBFe, { "DIAADD" , "N" , 04, 1 } )
		aAdd(aDBFe, { "TECAUS" , "N" , 03, 0 } )
		aAdd(aDBFe, { "DIAAUS" , "N" , 04, 1 } )
		aAdd(aDBFe, { "TEMPRO" , "C" , 08, 0 } )
		aAdd(aDBFe, { "TEMREA" , "C" , 08, 0 } )
		aAdd(aDBFe, { "OBS"    , "C" , 50, 0 } )
		aAdd(aDBFe, { "TEMDIS" , "C" , 08, 0 } )

	c990TRBE   := GetNextAlias()
	//Instância classe FWTemporaryTable
	oARQT990E := FWTemporaryTable():New(c990TRBE, aDBFe)
	//Cria indices
	oARQT990E:AddIndex("Ind01", {"ORDEM","PLANO","CODIGO"})
	oARQT990E:AddIndex("Ind02", {"ORDEM","PLANO","DESCRI"})
	oARQT990E:AddIndex("Ind03", {"DESCRI"})
	//Cria a tabela temporaria
	oARQT990E:Create()

	//---------------------------------------------------------------------
	//Tabela - Mao De Obra
	//---------------------------------------------------------------------
	aDBFm := {}
		aAdd(aDBFm, { "ORDEM"  , "C" , 06, 0 } )
		aAdd(aDBFm, { "PLANO"  , "C" , 06, 0 } )
		aAdd(aDBFm, { "CODIGO" , "C" , 06, 0 } )
		aAdd(aDBFm, { "DESCRI" , "C" , 40, 0 } )
		aAdd(aDBFm, { "CODESP" , "C" , 06, 0 } )
		aAdd(aDBFm, { "NOMESP" , "C" , 40, 0 } )
		aAdd(aDBFm, { "TEMPRO" , "C" , 08, 0 } )
		aAdd(aDBFm, { "TEMREA" , "C" , 08, 0 } )
		aAdd(aDBFm, { "TEMDIS" , "C" , 08, 0 } )

	c990TRBM   := GetNextAlias()
	//Instância classe FWTemporaryTable
	oARQT990M := FWTemporaryTable():New(c990TRBM, aDBFm)
	//Cria indices
	oARQT990M:AddIndex("Ind01", {"ORDEM","PLANO","CODIGO"})
	oARQT990M:AddIndex("Ind02", {"ORDEM","PLANO","DESCRI","CODIGO"})
	oARQT990M:AddIndex("Ind03", {"DESCRI","CODIGO"})
	//Cria a tabela temporaria
	oARQT990M:Create()

	If nOSPrInd == 2

		// Verificando Disponibilidade da Mão-de-Obra
		Processa( { |lEND| fDispoST1( .T., .F., _dDiaAtu, _dDiaAtu ) }, STR0020 )

	Else

		dLastDay := LastDay( dDataBase, 2 )

		// Verificando Disponibilidade da Mão-de-Obra
		Processa( { |lEND| fDispoST1( .T., .F., dDataBase, IIf( dTT1_DTFIM > dLastDay, dLastDay, dTT1_DTFIM ) ) }, STR0020 )

	EndIf

	//Tamanho da tela
	Private aAC := {STR0021,STR0022},aCRA:= {STR0022,STR0023,STR0021} //"Abandona"###"Confirma"###"Confirma"###"Redigita"###"Abandona"
	Private aTELA[0][0],aGETS[0],aHeader[0],Continua,nUsado:=0
	Private aSize := MsAdvSize(,.F.,430), aObjects := {}
	aAdd(aObjects,{050,050,.T.,.T.})
	aAdd(aObjects,{100,100,.T.,.F.})
	aAdd(aObjects,{100,100,.T.,.F.})
	aInfo := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
	aPosObj := MsObjSize(aInfo, aObjects,.T.)

	//Botao na barra superior
	aAdd(aNgBtn,{"BMPVISUAL" ,{|| ScreenProg(nOpcxx,2)},STR0024,STR0025}) //"Dados da Programacao"###"Program."
	aAdd(aNgBtn,{"SDUSETDEL" ,{|| MDOLegenda()},STR0027,STR0027}) //"Legenda Mão-de-Obra"###"Legenda"
	aAdd(aNgBtn,{"SUMARIO"   ,{|| fParMnt990(2)},"Parametros","Parametros"}) //"Parametros"###"Parametros"

	If ExistBlock("MNTA9901")
		_aNgBtn := ExecBlock("MNTA9901",.F.,.F.,{aNgBtn})
		If (ValType(_aNgBtn) == "A")
			aNgBtn := ACLONE(_aNgBtn)
		EndIf
	EndIf
	//menu botao 'click direita' tela esquerda
	aSMenu1 := { { STR0028, "fMarcaAll(1)"},; //"Marcar todos"
				 { STR0029, "fDesmaAll(1)"} } //"Desmarcar todos"
	//menu botao 'click direita' tela direita
	aSMenu2 := { { STR0028, "fMarcaAll(2)"},; //"Marcar todos"
				 { STR0029, "fDesmaAll(2)"} } //"Desmarcar todos"

	//Nomeando Folders
	aAdd(aTitles,Oemtoansi(STR0074))  //"Especialidade"
	aAdd(aPages,"HEADER 1")
	nControl++
	aAdd(aTitles,Oemtoansi(STR0031))  //"Produto"
	aAdd(aPages,"HEADER 2")
	nControl++
	aAdd(aTitles,Oemtoansi(STR0032))  //"Ferramenta"
	aAdd(aPages,"HEADER 3")
	nControl++
	aAdd(aTitles,Oemtoansi(STR0030))  //"Mão-de-Obra"
	aAdd(aPages,"HEADER 4")
	nControl++

	dbSelectArea(c990TRB1)
	dbSetOrder(nTipoInd)
	dbGoTop()
	dbSelectArea(c990TRB3)
	dbSetOrder(nTipoInd)
	dbGoTop()
	dbSelectArea("TT1")

	cTit990 := STR0009 + " Nº: " + cTT1_CODIGO //"Programação de O.S."
	If lEveProg
		cTit990 += STR0200 + cTT1_CDEVEN //" / Evento Nº: "
	EndIf

	lFlatMode := If(FindFunction("FLATMODE"),FlatMode(),SetMDIChild())

	nVertDif := aSize[6] - aSize[7]
	nVertTmp := If( nVertDif < 0570 , 0570 , nVertDif )
	nVertFim := aSize[7] + nVertTmp
	nHoriFim := If( aSize[5] < 1016 , 1016 , aSize[5] )

	//Define posicionamento dos objetos
	Private nwHorPar, nwHorCal, nwVerOS1, nwHorOS1, nwIniOS2, nwVerOS2, nwHorOS2, nwVerBt1
	Private nwVerBt2, nwHorBt2, nwIniFol, nwVerFol, nwHorFol, nwVerBt3, nwHorBt3, nwHorBt4
	fPosObjet()

	DEFINE MSDIALOG oDlg TITLE OemToAnsi(cTit990) From 0,0 To 0,0 OF oMainWnd COLOR CLR_BLACK,CLR_WHITE PIXEL

	// Tela maximizada
	oDlg:lMaximized := .T.

	oPanelAll := TPanel():New( 0, 0, , oDlg, , .T., .F., , , 0, 0, .T., .F. )
	oPanelAll:Align := CONTROL_ALIGN_ALLCLIENT

	oSplitter := tSplitter():New( 0, 0, oPanelAll, 0, 0, 1 )
	oSplitter:Align := CONTROL_ALIGN_ALLCLIENT

	oPanelTop := TPanel():New( 0, 0, , oSplitter, , .T., .F., , , 0, 110, .T., .F. )
	oPanelTop:Align := CONTROL_ALIGN_TOP

	oPnlOrdPr := TPanel():New(00,00,,oPanelTop,,,,,NGCOLOR("10")[2],13,13,.F.,.F.)
	oPnlOrdPr:Align := CONTROL_ALIGN_TOP

	oPanelBAll := TPanel():New(0, 0, Nil, oPanelTop, Nil, .T., .F., Nil, NGCOLOR("10")[2], 13, 13, .T., .F. )
	oPanelBAll:Align := CONTROL_ALIGN_LEFT
	@ 003,015 Say OemToAnsi(STR0274) Of oPnlOrdPr Color NGCOLOR("10")[1] Font oFont14 Pixel //"Ordens de serviço a programar"
	@ 003,388 Say OemToAnsi(STR0275) Of oPnlOrdPr Color NGCOLOR("10")[1] Font oFont14 Pixel //"Ordens de serviço em programação"

	oBtnAltSt := TBtnBmp():NewBar("ng_alteraratatus","ng_alteraratatus",,,,{|| AltStatus()},,oPanelBAll,,,STR0061,,,,,"") //"Alterar Status"
	oBtnAltSt:Align  := CONTROL_ALIGN_TOP
	oBtnAltSt:lVisible := .T.

	oBtnAltDt := TBtnBmp():NewBar( 'ng_alterardata', 'ng_alterardata', , , , { || fAlterDtOS( c990TRB1 ) }, ,;
		oPanelBAll, , , STR0062, , , , , '' ) // Alterar Data
	oBtnAltDt:Align	   := CONTROL_ALIGN_TOP
	oBtnAltDt:lVisible := .T.

	oBtnVis  := TBtnBmp():NewBar("ng_ico_visual","ng_ico_visual",,,,{|| fVisualOS(1) },,oPanelBAll,,,STR0063,,,,,"") //"Visualizar O.S."
	oBtnVis:Align  := CONTROL_ALIGN_TOP
	oBtnVis:lVisible := .T.

	oBtnInsuPr := TBtnBmp():NewBar("ng_insumos","ng_insumos",,,,{||fIncPvSTL(2) },,oPanelBAll,,,STR0276,,,,,"") //"Insumo Previsto"
	oBtnInsuPr:Align  := CONTROL_ALIGN_TOP
	oBtnInsuPr:lVisible := .T.

	oPanelTLeft := TPanel():New(0,0, Nil, oPanelTop, Nil, .T., .F., Nil, Nil, 0,0, .T., .F. )
	oPanelTLeft:Align := CONTROL_ALIGN_ALLCLIENT

	oPanelTRigh := TPanel():New(00,00,, oPanelTop, Nil, .T., .F., Nil, Nil,aSize[5]/4 ,aSize[6]/4, .T., .F. )
	oPanelTRigh:Align := CONTROL_ALIGN_RIGHT

	oPanelBtRi := TPanel():New(0, 0, Nil, oPanelTop, Nil, .T., .F., Nil, NGCOLOR("10")[2], 13, 13, .T., .F. )
	oPanelBtRi:Align := CONTROL_ALIGN_RIGHT

	oPanelTBtn := TPanel():New(0,0, Nil, oPanelTop, Nil, .T., .F., Nil, Nil, 20,20 , .T., .F. )
	oPanelTBtn:Align := CONTROL_ALIGN_RIGHT

	oBtnLibOs := TBtnBmp():NewBar("ng_liberaros","ng_liberaros",,,,{|| LiberarOS()},,oPanelBtRi,,,STR0277,,,,,"") //"Liberar O.S."
	oBtnLibOs:Align  := CONTROL_ALIGN_TOP
	oBtnLibOs:lVisible := .T.

	oBtnIOs := TBtnBmp():NewBar("ng_ico_imp","ng_ico_imp",,,,{|| ImprimirOS()},,oPanelBtRi,,,STR0065,,,,,"") //"Imprimir O.S."
	oBtnIOs:Align  := CONTROL_ALIGN_TOP
	oBtnIOs:lVisible := .T.

	oBtnVisOS  := TBtnBmp():NewBar("ng_ico_visual","ng_ico_visual",,,,{|| fVisualOS(2) },,oPanelBtRi,,,STR0063,,,,,"") //"Visualizar O.S."
	oBtnVisOS:Align  := CONTROL_ALIGN_TOP
	oBtnVisOS:lVisible := .T.

	oBtnInR := TBtnBmp():NewBar("ng_insumos","ng_insumos",,,,{|| fIncPvSTL(1)},,oPanelBtRi,,,STR0278,,,,,"") //"Insumo"
	oBtnInR:Align  := CONTROL_ALIGN_TOP
	oBtnInR:lVisible := .T.

	oBtnImpPr := TBtnBmp():NewBar("ng_impprog","ng_impprog",,,,{|| fImpProg()},,oPanelBtRi,,,STR0068,,,,,"") //"Imprimir Programação"
	oBtnImpPr:Align  := CONTROL_ALIGN_TOP
	oBtnImpPr:lVisible := .T.

	oBtnAlDtP := TBtnBmp():NewBar( 'ng_alterardata', 'ng_alterardata', , , , { || fAlterDtOS( c990TRB3, 1 ) }, ,;
		oPanelBtRi, , , STR0062, , , , , '' ) // Alterar Data
	oBtnAlDtP:Align    := CONTROL_ALIGN_TOP
	oBtnAlDtP:lVisible := .T.


	oPanelTRTop := TPanel():New(00,00,, oPanelTRigh, Nil, .T., .F., Nil, Nil, 80,80 , .T., .F. )
	oPanelTRTop:Align := CONTROL_ALIGN_TOP

	oPanelTRAll := TPanel():New(00,00,, oPanelTRigh, Nil, .T., .F., Nil, Nil, 0,0 , .T., .F. )
	oPanelTRAll:Align := CONTROL_ALIGN_ALLCLIENT

	If lAltProg
		oBtnAltDt:Enable()
		oBtnAlDtP:Enable()
		oBtnAltSt:Enable()
		oBtnLibOs:Enable()
	Else
		oBtnAltDt:Disable()
		oBtnAlDtP:Disable()
		oBtnAltSt:Disable()
		oBtnLibOs:Disable()
	EndIf

	//---------------------------------------------------------------------
	//Mark Browse - Ordens de Servicos - Esquerda
	//---------------------------------------------------------------------
	dbSelectArea(c990TRB1)
	oMARK1:=TCBrowse():New(18,009,nwHorOS1,nwVerOS1,,,,oPanelTLeft,,,,,{||},,,,,,,.F.,,.T.,,.F.,)
	oMARK1:lAdjustColSize := .F. //Adicionada conteúdo para garantir que permaneça no tamanho alterado da coluna
	oMARK1:Align := CONTROL_ALIGN_ALLCLIENT

	oCol:=TCColumn():New( " " , {|| fCorMark(1) } ,,,,,,.T.,.F.,,,,.T.,)
	oMARK1:ADDCOLUMN(oCol)

	If aScan(aCpoCompl, {|x|"SITUACAO" $ Upper(x)}) > 0
		oCol:=TCColumn():New( STR0135 , {|| fCor001() } ,,,,,,.T.,.F.,,,,.T.,) //"Situação"
		oCol:nWidth := 25
		oMARK1:ADDCOLUMN(oCol)
	EndIf

	If aScan(aCpoCompl, {|x|"STATUS" $ Upper(x)}) > 0
		oCol:=TCColumn():New( STR0014 , {|| fCor002(1) } ,,,,,,.T.,.F.,,,,.T.,) //"Status"
		oCol:nWidth := 20
		oMARK1:ADDCOLUMN(oCol)
	EndIf

	For nForG := 1 to Len(aTRB1)
		oCol:=TCColumn():New( aTRB1[nForG,3] , &("{|| (c990TRB1)->"+aTRB1[nForG,1]+" }") ,,,,,,.F.,.F.,,,,.F.,)
		oMARK1:ADDCOLUMN(oCol)
	Next nForG

	oCalend := MsCalend():New( 003, 3, oPanelTRigh, .F. )

	If !Empty(_dDiaAtu)
		oCalend:dDiaAtu := _dDiaAtu
		Processa({|lEND| fPrgChgMes(1,@oCalend)},STR0047) //"Processando..."
	Else
		oCalend:dDiaAtu := dDataBase
	EndIf

	oCalend:bChange    := { || fPrgChgDia(2) }
	oCalend:bChangeMes := { || Processa({|lEND| fPrgChgMes(1,@oCalend)},STR0046) } //"Atualizando Calendário..."

	@ 006,145  Say OemToAnsi(STR0052) Of oPanelTRTop Pixel //"Localizar O.S.:"
	@ 006,190  MsGet cBuscaOS Valid fLocalizOS() Picture '@!' Size 30,5 Of oPanelTRTop Pixel When lAltProg HASBUTTON

	@ 017,145  Say OemToAnsi(STR0053) Of oPanelTRTop Pixel //"Ordenar O.S. por:"
	@ 017,190  Combobox oBoxObj VAR cTipoInd ITEMS aTipoInd SIZE 60,10 Of oPanelTRTop PIXEL ON CHANGE (fAltBox(cTipoInd))

	If lCpoTT2Dt .And. lCpoVerOs
		@ 032,145 To 065, 243 LABEL Oemtoansi(STR0218) OF oPanelTRTop PIXEL //"Ver O.S. Programadas"
		@ 042,147 RADIO oBoxOSP VAR nOSPrInd ITEMS STR0219,STR0220 3D ; //"Todas"###"Data selecionada no calendário"
		ON CHANGE fAltBoxOS(nOSPrInd) SIZE 120,20 PIXEL OF oPanelTRTop// When lAltProg
	EndIf

	If lPrgEvento .And. lPrgDiaria
		@ 045,145  Say OemToAnsi(STR0221) Of oPanelTRTop Pixel //"Código do Evento:"
		@ 045,190  MsGet oCodEvento Var cEventoOS Valid VldCodEve() Picture '@!' F3 "TTQ" Size 30,5 Of oPanelTRTop Pixel When lAltProg HASBUTTON
		oCodEvento:cToolTip := STR0222 //"Ao transferir uma O.S. do lado esquerdo para o lado direito, automaticamente será atribuido este Código do Evento à ela."
	EndIf

	If lAltProg
		oMARK1:brClicked := { |o,x,y| oMenu1:Activate(250,280,oPanelTRTop)}
		NGPOPUP(aSMenu1,@oMenu1)
		oMARK1:bLDblClick := {|| MntMark1Os(cMarca,lInverte,1) }
		oMARK1:bHeaderClick := { |x,a| MntAllOS1(x,a,cMarca,1) }
	EndIf

	@ 135,07 BTNBMP oBtAllNext Resource 'PGNEXT' Size 22,22 Pixel Of oPanelTBtn Noborder Pixel Action Processa( {|lEND|;
		fPassRight( 2 ) }, STR0054) // Transferindo...
	oBtAllNext:cToolTip := OemToAnsi(STR0055) // Incluir Todos

	@ 180,07 BTNBMP oBtNext Resource 'NEXT' Size 22,22 Pixel Of oPanelTBtn Noborder Pixel Action Processa( { |lEND|;
		fPassRight( 1 )}, STR0054 ) // Transferindo...
	oBtNext:cToolTip := OemToAnsi(STR0004) // Incluir

	@ 220,07 BTNBMP oBtPrev    Resource "PREV"   Size 22,22 Pixel Of oPanelTBtn Noborder Pixel Action Processa({|lEND| fPassaEsq(1)},STR0054) //"Transferindo..."
	oBtPrev:cToolTip := OemToAnsi(STR0006) //"Excluir"
	@ 265,07 BTNBMP oBtAllPrev Resource "PGPREV" Size 22,22 Pixel Of oPanelTBtn Noborder Pixel Action Processa({|lEND| fPassaEsq(2)},STR0054) //"Transferindo..."
	oBtAllPrev:cToolTip := OemToAnsi(STR0056) //"Excluir Todos"

	//---------------------------------------------------------------------
	//Mark Browse - Ordens de Servicos - Direita
	//---------------------------------------------------------------------
	dbSelectArea(c990TRB3)
	oMARK2:=TCBrowse():New(090,nwHorCal,nwHorOS1,nwVerOS1,,,,oPanelTRAll,,,,,{||},,,,,,,.F.,,.T.,,.F.,)
	oMARK2:lAdjustColSize := .F. //Adicionada conteúdo para garantir que permaneça no tamanho alterado da coluna
	oMARK2:Align := CONTROL_ALIGN_ALLCLIENT
	oCol:=TCColumn():New( " " , {|| fCorMark(2) } ,,,,,,.T.,.F.,,,,.T.,)
	oMARK2:ADDCOLUMN(oCol)
	If aScan(aCpoCompl, {|x|"SITUACAO" $ Upper(x)}) > 0
		oCol:=TCColumn():New( STR0135 , {|| fCor003() } ,,,,,,.T.,.F.,,,,.T.,) //"Situação"
		oCol:nWidth := 25
		oMARK2:ADDCOLUMN(oCol)
	EndIf
	If aScan(aCpoCompl, {|x|"STATUS" $ Upper(x)}) > 0
		oCol:=TCColumn():New( STR0014 , {|| fCor002(2) } ,,,,,,.T.,.F.,,,,.T.,) //"Status"
		oCol:nWidth := 20
		oMARK2:ADDCOLUMN(oCol)
	EndIf
	For nForG := 1 to Len(aTRB2)
		oCol:=TCColumn():New( aTRB2[nForG,3] , &("{|| (c990TRB3)->"+aTRB2[nForG,1]+" }") ,,,,,,.F.,.F.,,,,.F.,)
		oMARK2:ADDCOLUMN(oCol)
	Next nForG

	If lAltProg
		oMARK2:brClicked := { |o,x,y| oMenu2:Activate(700,280,oPanelTRAll)}
		NGPOPUP(aSMenu2,@oMenu2)
		oMARK2:bLDblClick := {|| MntMark1Os(cMarca,lInverte,2) }
		oMARK2:bHeaderClick := { |x,a| MntAllOS1(x,a,cMarca,2) }
	EndIf

	dbSelectArea(c990TRB3)
	oMARK2:Refresh()

	dbSelectArea(c990TRB1)
	oMARK1:Refresh()

	oPanelBotton := TPanel():New( 0, 0, , oSplitter, , .T., .F., , , 0, 110, .T., .F. )
	oPanelBotton:Align := CONTROL_ALIGN_BOTTOM

	oPanelBTop := TPanel():New(0, 0, Nil, oPanelBotton, Nil, .T., .F., Nil, NGCOLOR("10")[2], 13, 13, .T., .F. )
	oPanelBTop:Align := CONTROL_ALIGN_TOP

	//Cria o Menu
	oMenu := TMenu():New(0,0,0,0,.T.)
	// Adiciona itens no Menu
	oTMItem1 := TMenuItem():New(oPanelBTop,STR0312,,,,{||fTrocaCarg(1,oCarga)},,,,,,,,,.T.) //"Programar"
	oTMItem2 := TMenuItem():New(oPanelBTop,STR0313,,,,{||fTrocaCarg(2,oCarga)},,,,,,,,,.T.) //"Em Programação"

	oTMItem1:lSelected := .T.
	oMenu:Add(oTMItem1)
	oMenu:Add(oTMItem2)

	oTBtnBmp1 := TBtnBmp():NewBar( "ng_ico_filtro1", , , , '', , .F., oPanelBTop, .T., { || .T. }, , .F., , , 1 , , , , , .T. )
	oTBtnBmp1:SetPopupMenu(oMenu)
	oTBtnBmp1:NHEIGHT := 25
	oTBtnBmp1:NWIDTH  := 27

	@ 003,015 Say oCarga Prompt IIf( lFilOsPro, STR0287, STR0286 ) Of oPanelBTop Color NGCOLOR("10")[1] Font oFont14 Pixel //"Carga em Programação"

	oPanelBRigth := TPanel():New(0, 0, Nil, oPanelBotton, Nil, .T., .F., Nil, Nil, 0, 0, .T., .F. )
	oPanelBRigth:Align := CONTROL_ALIGN_ALLCLIENT

	oPnlBAll := TPanel():New(0, 0, Nil, oPanelBotton, Nil, .T., .F., Nil, NGCOLOR("10")[2], 13, 13, .T., .F. )
	oPnlBAll:Align := CONTROL_ALIGN_LEFT

	oBtnImpOs := TBtnBmp():NewBar("ng_ico_imp","ng_ico_imp",,,,{|| fImpRecursos()()},,oPnlBAll,,,STR0070,,,,,"") //"Imprimir Insumos"
	oBtnImpOs:Align  := CONTROL_ALIGN_TOP
	oBtnImpOs:Show()

	oBtnVisCo := TBtnBmp():NewBar("ng_vissoliccom","ng_vissoliccom",,,,{|| fVisualSC()()},,oPnlBAll,,,STR0279,,,,,"") //"Visualizar Solicitação de Compras"
	oBtnVisCo:Align  := CONTROL_ALIGN_TOP
	oBtnVisCo:Hide()

	oBtnImpSA := TBtnBmp():NewBar("ng_imprSolAr","ng_imprSolAr",,,,{|| fImpSA()()},,oPnlBAll,,,STR0280,,,,,"") //"Imprimir Solicitação de Armazem"
	oBtnImpSA:Align  := CONTROL_ALIGN_TOP
	oBtnImpSA:Hide()

	If lIntegRM
		
		oBtnSldRM := TBtnBmp():NewBar( 'ng_atu_saldo','ng_atu_saldo', , , , { || fSaldoRM() }, , oPnlBAll, , , STR0356, , , , , "" ) // Atualizar Saldos
		oBtnSldRM:Align  := CONTROL_ALIGN_TOP
		oBtnSldRM:Hide()
	
	EndIf

	oBtnDeEsp := TBtnBmp():NewBar("ng_detespeci","ng_detespeci",,,,{|| fResumoMDO()()},,oPnlBAll,,,STR0281,,,,,"") //"Detalhar Especialidade"
	oBtnDeEsp:Align  := CONTROL_ALIGN_TOP
	oBtnDeEsp:Show()

	oDlg:LESCCLOSE := .F.
	oFolder := TFolder():New(0,0,aTitles,aPages,oPanelBRigth,,,,.F.,.F.,0,0,,)
	oFolder:bChange := {|| fTrocaFolder(oFolder:nOption) }
	oFolder:aDialogs[1]:oFont := oPanelBRigth:oFont
	oFolder:aDialogs[2]:oFont := oPanelBRigth:oFont
	oFolder:aDialogs[3]:oFont := oPanelBRigth:oFont
	oFolder:aDialogs[4]:oFont := oPanelBRigth:oFont
	oFolder:Align := CONTROL_ALIGN_ALLCLIENT

	//---------------------------------------------------------------------
	//List Box - Especialidade
	//---------------------------------------------------------------------
	oList2 := VCBrowse():New( 001 , 010, 0, 0,,;
	{'',STR0074,STR0075,STR0076,STR0077,; //"Especialidade"###"Total Técnicos"###"Técnicos Adicionais"###"Dias Adicionais"
	STR0078,STR0079,STR0080,STR0081,; //"Técnicos Ausentes"###"Dias Ausentes"###"Tempo Programado"###"Tempo Disponivel"
	STR0082},; //"% Utilizada"
	{20,60,40,48,45,48,40,50,45,40}, oFolder:aDialogs[1],,,,,;
	{||},,,,,,,.F.,,.T.,,.F.,,.T.,.T.)
	oList2:SetArray(aList2)
	oList2:Align := CONTROL_ALIGN_ALLCLIENT
	bList2 := { || { If(aList2[oList2:nAt,1]==1,oVermelho,If(aList2[oList2:nAt,1]==2,oAmarelo,;
	If(aList2[oList2:nAt,1]==3,oVerde,If(aList2[oList2:nAt,1]==4,oPreto,oNgSemInfo)))), ;
	aList2[oList2:nAt,2], aList2[oList2:nAt,3], ;
	aList2[oList2:nAt,4], aList2[oList2:nAt,5], aList2[oList2:nAt,6], ;
	aList2[oList2:nAt,7], aList2[oList2:nAt,8], aList2[oList2:nAt,9], ;
	If(HtoM(aList2[oList2:nAt,9])==0,"-",;
	Alltrim(Transform( (100 / HtoM(aList2[oList2:nAt,9]) ) * HtoM(aList2[oList2:nAt,8]) ,"@E 999,999.9")+" %")) } }
	oList2:bLine:= bList2
	oList2:bLDblClick := {|| fResumoMDO()}

	//---------------------------------------------------------------------
	//List Box - Produto
	//-------------------------------------------------------------------
	@001,010 ListBox oList3 FIELDS ON DBLCLICK () SIZE 000,000 OF oFolder:aDialogs[2] PIXEL

	aHead3 := { { "aList3[oList3:nAt,1]"                                     , STR0010, 030 },;
				{ "aList3[oList3:nAt,2]"                                     , STR0083, 040 },;
				{ "aList3[oList3:nAt,3]"                                     , STR0012, 100 },;
				{ "Transform( aList3[oList3:nAt,4], X3Picture( 'B2_QATU' ) )", STR0084, 045 },;
				{ "Transform( aList3[oList3:nAt,5], X3Picture( 'B2_QATU' ) )", STR0223, 045 },;
				{ "Transform( aList3[oList3:nAt,6], X3Picture( 'B2_QATU' ) )", STR0085, 045 },;
				{ "aList3[oList3:nAt,7]"                                     , STR0086, 045 },;
				{ "aList3[oList3:nAt,8]"                                     , STR0015, 000 },;
				{ "aList3[oList3:nAt,10]"                                    , STR0087, 000 } }

	If ExistBlock( 'MNTA9900' )

		aRetPE := ExecBlock( 'MNTA9900', .F., .F. )

		For nInd1 := 1 to Len( aRetPE[1] )

			aAdd( aHead3      , aRetPE[1,nInd1] )
			aAdd( aList3Def[1], aRetPE[2,nInd1] )
			
		Next nInd1

	EndIf

	aList3 := aList3Def

	//Define Cabeçalho e campos de acordo com os parametros informados
	aSize( oList3:aHeaders , Len( aHead3 ) )
	aSize( oList3:aColSizes, Len( aHead3 ) )

	For nInd1 := 1 To Len( aHead3 )

		oList3:aHeaders[nInd1] := aHead3[nInd1,2]

		If nInd1 != 1
			
			cCampos += ','

		Else

			cCampos += '{ '

		EndIf

		cCampos += aHead3[nInd1,1]

		oList3:aColSizes[nInd1] := aHead3[nInd1,3]

	Next nInd1

	cCampos += '}'
	bList3  := { || &cCampos }

	oList3:SetArray( aList3 )
	oList3:bLine := bList3
	oList3:GoTop()
	oList3:Align := CONTROL_ALIGN_ALLCLIENT
	oList3:bGotFocus := {|| SetKey(VK_F4, {||MntViewSB2('P',aList3[oList3:nAt,2])})}
	oList3:bLostFocus := {|| SETKEY( VK_F4,Nil) }

	//---------------------------------------------------------------------
	//List Box - Ferramenta
	//---------------------------------------------------------------------
	@ 001,010 ListBox oList4 Var cList4;
	Fields Header;
	STR0010,STR0083,STR0012,STR0084; //"Ordem"###"Código"###"Descrição"###"Necessidade"
	ColSizes 50,50,250,50;
	Size 0,0 Of oFolder:aDialogs[3] Pixel;

	bList4 := { || { aList4[oList4:nAt,1], aList4[oList4:nAt,2], aList4[oList4:nAt,3], aList4[oList4:nAt,4] } }
	oList4:SetArray( aList4 )
	oList4:bLine:= bList4
	oList4:GoTop()
	oList4:Align := CONTROL_ALIGN_ALLCLIENT

	//---------------------------------------------------------------------
	//List Box - Mão-de-obra
	//---------------------------------------------------------------------
	oList5 := VCBrowse():New( 001 , 010, nwHorFol-15, nwVerFol-15,,;
	{'',NGRETTITULO("T1_CODFUNC"),NGRETTITULO("T1_NOME"),STR0074,; //"Especialidade"
	STR0080,STR0081,STR0082},; //"Tempo Programado"###"Tempo Disponivel"###"% Utilizada"
	{20,30,200,150,50,50,40}, oFolder:aDialogs[4],,,,,;
	{||},,,,,,,.F.,,.T.,,.F.,,.T.,.T.)
	oList5:SetArray(aList5)
	bList5 := { || { If(aList5[oList5:nAt,1]==1,oVermelho,If(aList5[oList5:nAt,1]==2,oAmarelo,;
	If(aList5[oList5:nAt,1]==3,oVerde,If(aList5[oList5:nAt,1]==4,oPreto,oNgSemInfo)))), ;
	aList5[oList5:nAt,2], aList5[oList5:nAt,3], ;
	aList5[oList5:nAt,4], aList5[oList5:nAt,5], ;
	aList5[oList5:nAt,6],;
	If(HtoM(aList5[oList5:nAt,6])==0,"-",;
	Alltrim(Transform( (100 / HtoM(aList5[oList5:nAt,6]) ) * HtoM(aList5[oList5:nAt,5]) ,"@E 999,999.9")+" %")) } }
	oList5:bLine:= bList5
	oList5:Align := CONTROL_ALIGN_ALLCLIENT
	If lOfuscar
		oList5:aObfuscatedCols := {.F., .F., .T., .F., .F., .F., .F. }
	EndIf

	NGPOPUP(aSMenu,@oMenu)

	//Ponto de entrada para modificações da tela.
	If ExistBlock("MNTA990A")
		oPanelBAll := ExecBlock("MNTA990A",.F.,.F.,{oPanelBAll})
	EndIf

	Activate MsDialog oDlg On Init (EnchoiceBar(oDlg,{|| nOpcOS:=1,If(!fMPBA01CHK(1,nOpcxx),nOpcOS:=0,oDlg:End()) },;
	{|| nOpcOS:=0,If(!fMPBA01CHK(2,nOpcxx),nOpcOS:=0,oDlg:End()) },,aNgBtn),If(INCLUI,fParMnt990(1),fProgAuto(1,1)))

	If nOpcOS == 1

		aCabecProg := {}
		//Carrega na variavel aCabecProg as programacoes que serao geradas (diaria ou evento)
		If lPrgDiaria
			//Le as OS programadas e adiciona na aCabecProg
			dbSelectArea(c990TRB2)
			dbSetOrder(6)
			dbGoTop()
			While !EoF()
				If !Empty((c990TRB2)->EVENTO) .And. lPrgEvento
					dbSelectArea("TTQ")
					dbSetOrder(1)
					dbSeek(xFilial("TTQ")+(c990TRB2)->EVENTO)
					If aScan(aCabecProg ,{|x| x[5] == (c990TRB2)->EVENTO }) == 0
						aAdd( aCabecProg , { TTQ->TTQ_DTINI , TTQ->TTQ_DTFIM , cTT1_CODIGO , .T. , (c990TRB2)->EVENTO } )
					EndIf
				Else
					If aScan(aCabecProg ,{|x| x[1] == (c990TRB2)->DTMPROG .And. Empty(x[5]) }) == 0
						aAdd( aCabecProg , { (c990TRB2)->DTMPROG , (c990TRB2)->DTMPROG , cTT1_CODIGO , .T. , " " } )
					EndIf
				EndIf
				dbSelectArea(c990TRB2)
				dbSkip()
			End
			If Len(aCabecProg) == 0
				aAdd( aCabecProg , { dTT1_DTPROG , dTT1_DTFIM , cTT1_CODIGO , .F. , " " } )
			Else
				//Na alteracao, o numero da programacao será o mesmo para a programacao que está sendo alterada
				If nOpcxx == 4
					If !Empty(cSvTT1EVE)
						nPosTmp := aScan(aCabecProg ,{|x| x[5] == cSvTT1EVE })
						If nPosTmp > 0
							aCabecProg[nPosTmp,3] := cSvTT1COD
						EndIf
					ElseIf dSvTT1INI == dSvTT1FIM .And. !Empty(dSvTT1FIM)
						nPosTmp := aScan(aCabecProg ,{|x| x[1] == dSvTT1INI .And. Empty(x[5]) })
						If nPosTmp > 0
							aCabecProg[nPosTmp,3] := cSvTT1COD
						EndIf
					EndIf
				EndIf
			EndIf
		Else
			dbSelectArea(c990TRB2)
			dbSetOrder(6)
			(c990TRB2)->(dbGoTop())
			dInicioPrg := (c990TRB2)->DTMPROG
			(c990TRB2)->(dbGoBottom())
			dFimPrg := (c990TRB2)->DTMPROG
			If !Empty(dInicioPrg) .And. !Empty(dFimPrg) .And. !lPrgEvento
				If dTT1_DTPROG < dInicioPrg
					dInicioPrg := dTT1_DTPROG
				EndIf
				If dTT1_DTFIM > dFimPrg
					dFimPrg := dTT1_DTFIM
				EndIf
				aAdd( aCabecProg , { dInicioPrg , dFimPrg , Space(6) , .F. , " " } )
			Else
				aAdd( aCabecProg , { dTT1_DTPROG , dTT1_DTFIM , Space(6) , .F. , " " } )
			EndIf
		EndIf

		Begin Transaction

			If nOpcxx == 3

				nContProg := 1
				For nForG := 1 to Len(aCabecProg)

					If aCabecProg[nForG,4]
						lAchou := .F.
						If Empty(aCabecProg[nForG,5])
							dbSelectArea("TT1")
							dbSetOrder(1)
							dbSeek(xFilial("TT1")+aCabecProg[nForG,3])
							While !EoF() .And. xFilial("TT1") == TT1->TT1_FILIAL .And. aCabecProg[nForG,1] == TT1->TT1_DTPROG
								If aCabecProg[nForG,1] == TT1->TT1_DTFIM .And. Empty(TT1->TT1_CDEVEN) .And. TT1->TT1_CODIGO == aCabecProg[nForG,3]
									aCabecProg[nForG,3] := TT1->TT1_CODIGO
									lAchou := .T.
									Exit
								EndIf
								dbSkip()
							End
						Else
							dbSelectArea("TT1")
							dbSetOrder(5)
							If dbSeek(xFilial("TT1")+aCabecProg[nForG,5])
								aCabecProg[nForG,3] := TT1->TT1_CODIGO
								lAchou := .T.
							EndIf
						EndIf
						If lAchou
							Loop
						EndIf
					EndIf

					//confirma numero reservado
					If nContProg == 1
						ConfirmSX8()
					Else
						cTT1_CODIGO := GetSxeNum("TT1","TT1_CODIGO")
						ConfirmSX8()
					EndIf
					aCabecProg[nForG,3] := cTT1_CODIGO
					nContProg++
					RecLock("TT1",.T.)
					TT1->TT1_FILIAL := xFilial("TT1")
					TT1->TT1_CODIGO := cTT1_CODIGO
					TT1->TT1_DTPROG := aCabecProg[nForG,1] //dTT1_DTPROG
					TT1->TT1_DTFIM  := aCabecProg[nForG,2] //dTT1_DTFIM
					If aCabecProg[nForG,4]
						TT1->TT1_DTCALE := aCabecProg[nForG,1]
					Else
						TT1->TT1_DTCALE := _dDiaAtu
					EndIf
					If !Empty(aCabecProg[nForG,5]) .Or. lPrgDiaria
						fGravaTT1( aCabecProg[nForG,5] ) //Atualiza restante dos campos TT1
					Else
						fGravaTT1( cTT1_CDEVEN ) //Atualiza restante dos campos TT1
					EndIf
					TT1->(MsUnLock())

				Next nForG
				If nContProg == 1
					dbSelectArea("TT1")
					//nao precisou da programacao nova
					RollbackSx8()
				EndIf

				Processa({|lEND| fIncZX(nOpcxx)},STR0088) //"Gravando as Informações..."

			ElseIf nOpcxx == 4 .And. lAltProg

				nContProg := 1
				For nForG := 1 to Len(aCabecProg)

					If aCabecProg[nForG,4]
						lAchou := .F.
						If !Empty(aCabecProg[nForG,3])
							lAchou := .T.
						Else
							If Empty(aCabecProg[nForG,5])
								dbSelectArea("TT1")
								dbSetOrder(2)
								dbSeek(xFilial("TT1")+DtoS(aCabecProg[nForG,1]))
								While !EoF() .And. xFilial("TT1") == TT1->TT1_FILIAL .And. aCabecProg[nForG,1] == TT1->TT1_DTPROG
									If aCabecProg[nForG,1] == TT1->TT1_DTFIM .And. Empty(TT1->TT1_CDEVEN)
										aCabecProg[nForG,3] := TT1->TT1_CODIGO
										lAchou := .T.
										Exit
									EndIf
									dbSkip()
								End
							Else
								dbSelectArea("TT1")
								dbSetOrder(5)
								If dbSeek(xFilial("TT1")+aCabecProg[nForG,5])
									aCabecProg[nForG,3] := TT1->TT1_CODIGO
									lAchou := .T.
								EndIf
							EndIf
						EndIf
						If lAchou
							Loop
						EndIf
					EndIf

					//confirma numero reservado
					If nContProg == 1
						dbSelectArea("TT1")
						dbSetOrder(1)
						If dbSeek( xFilial("TT1") + cSvTT1COD ) .And. aScan(aCabecProg ,{|x| x[3] == cSvTT1COD }) == 0
							cTT1_CODIGO := cSvTT1COD
							RecLock("TT1",.F.)
							nContProg++
						Else
							cTT1_CODIGO := GetSxeNum("TT1","TT1_CODIGO")
							ConfirmSX8()
							RecLock("TT1",.T.)
						EndIf
					Else
						cTT1_CODIGO := GetSxeNum("TT1","TT1_CODIGO")
						ConfirmSX8()
						RecLock("TT1",.T.)
					EndIf
					aCabecProg[nForG,3] := cTT1_CODIGO
					TT1->TT1_FILIAL := xFilial("TT1")
					TT1->TT1_CODIGO := cTT1_CODIGO
					TT1->TT1_DTPROG := aCabecProg[nForG,1] //dTT1_DTPROG
					TT1->TT1_DTFIM  := aCabecProg[nForG,2] //dTT1_DTFIM
					If aCabecProg[nForG,4]
						TT1->TT1_DTCALE := aCabecProg[nForG,1]
					Else
						TT1->TT1_DTCALE := _dDiaAtu
					EndIf
					If !Empty(aCabecProg[nForG,5]) .Or. lPrgDiaria
						fGravaTT1( aCabecProg[nForG,5] ) //Atualiza restante dos campos TT1
					Else
						fGravaTT1( cTT1_CDEVEN ) //Atualiza restante dos campos TT1
					EndIf
					TT1->(MsUnLock())

				Next nForG

				Processa({|lEND| fIncZX(nOpcxx)},STR0088) //"Gravando as Informações..."

			ElseIf nOpcxx == 5

				Processa({|lEND| fIncZX(nOpcxx)},STR0089) //"Excluindo as Informações..."

				dbSelectArea("TT1")
				dbSetOrder(1)
				If dbSeek( xFilial("TT1") + cTT1_CODIGO )
					RecLock("TT1",.F.)
					dbDelete()
					TT1->(MsUnLock())
				EndIf

			EndIf

		End Transaction

		// Ponto de entrada para ser executado ao confirmar tela
		If ExistBlock("MNTA9907")
			ExecBlock("MNTA9907",.F.,.F.)
		EndIf
	Else
		//cancelou a tela
		RollbackSx8()
	EndIf

	TT1->(dbSetOrder(1))

	// Deleta arquivos temporarios fisicamente
	oARQT9901:Delete()
	oARQT9902:Delete()
	oARQT9903:Delete()
	oARQT990F:Delete()
	oARQT990B1:Delete()
	oARQT990E:Delete()
	oARQT990M:Delete()
	oTmpSTL:Delete()

	If nOpcxx == 2 .Or. nOpcxx == 4
		RestArea(aAreaTT1)
	EndIf

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} fGravaTT1
Atualiza campos TT1

@sample
fGravaTT1(cTemEven)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fGravaTT1(cTemEven)

	TT1->TT1_DESCRI := cTT1_DESCRI
	TT1->TT1_RESPON := cTT1_RESPON
	TT1->TT1_CDEVEN := cTemEven
	TT1->TT1_BEMDE  := M->TT1_BEMDE
	TT1->TT1_BEMATE := M->TT1_BEMATE
	TT1->TT1_EQUDE  := M->TT1_EQUDE
	TT1->TT1_EQUATE := M->TT1_EQUATE
	TT1->TT1_STADE  := M->TT1_STADE
	TT1->TT1_STAATE := M->TT1_STAATE
	TT1->TT1_CCDE   := M->TT1_CCDE
	TT1->TT1_CCATE  := M->TT1_CCATE
	TT1->TT1_DTDE   := M->TT1_DTDE
	TT1->TT1_DTATE  := M->TT1_DTATE
	TT1->TT1_ESTRUT := M->TT1_ESTRUT//MNTA990B
	If lCpoLbLoc
		TT1->TT1_INDLUB := M->TT1_INDLUB
		TT1->TT1_INDLOC := M->TT1_INDLOC
	EndIf
	If lCpoTrab
		TT1->TT1_TRADE  := M->TT1_TRADE
		TT1->TT1_TRAATE := M->TT1_TRAATE
	EndIf
	If lCpoFamB
		TT1->TT1_FAMDE  := M->TT1_FAMDE
		TT1->TT1_FAMATE := M->TT1_FAMATE
	EndIf
	If lCpoTipM
		TT1->TT1_TIPDE  := M->TT1_TIPDE
		TT1->TT1_TIPATE := M->TT1_TIPATE
	EndIf
	If lCpoAreM
		TT1->TT1_AREDE  := M->TT1_AREDE
		TT1->TT1_AREATE := M->TT1_AREATE
	EndIf
	If lCpoServ
		TT1->TT1_SERDE  := M->TT1_SERDE
		TT1->TT1_SERATE := M->TT1_SERATE
	EndIf
	If lCpoOrde
		TT1->TT1_ORDDE  := M->TT1_ORDDE
		TT1->TT1_ORDATE := M->TT1_ORDATE
	EndIf
	If lCpoPlan
		TT1->TT1_PLADE  := M->TT1_PLADE
		TT1->TT1_PLAATE := M->TT1_PLAATE
	EndIf
	If lCpoEvent
		TT1->TT1_EVEDE  := M->TT1_EVEDE
		TT1->TT1_EVEATE := M->TT1_EVEATE
	EndIf
	If lCpoVerOs
		TT1->TT1_VEROSS := If(nOSPrInd==2,"2","1")
	EndIf
	If lCpoContDt
		TT1->TT1_CONDTA := M->TT1_CONDTA
		TT1->TT1_PROGAU := M->TT1_PROGAU
		TT1->TT1_PRIDE  := M->TT1_PRIDE
		TT1->TT1_PRIATE := M->TT1_PRIATE
	EndIf

	//Ponto de entrada para gravação de campos na TT1.
	If ExistBlock("MNTA990B")
		ExecBlock("MNTA990B",.F.,.F.)
	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fIncZX
Inclui, altera e exclui a tabela TT2

@sample
fIncZX(nOpcxx)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fIncZX(nOpcxx)
	Local nTamRegua := 0

	Private a01GrvTT2 := {} //OS Disponiveis
	Private a02GrvTT2 := {} //OS Programadas
	Private aOsDelTT2 := {} //OS programadas na TT1 que está sendo alterada
	Private aOSRepro  := {} //OS reprogramadas

	Private lIntSFC   := FindFunction("NGINTSFC") .And. NGINTSFC() // Verifica se ha integracao com modulo Chao de Fabrica [SIGASFC]

	//---------------------------------------------------------------------
	//Tabela - O.S. liberadas
	//---------------------------------------------------------------------
	aDBFy := {}
	aAdd( aDBFy, { "ORDEM"   , "C" , 06, 0 } )
	aAdd( aDBFy, { "PLANO"   , "C" , 06, 0 } )
	aAdd( aDBFy, { "DTMPINI" , "D" , 08, 0 } )
	aAdd( aDBFy, { "NUMREC"  , "N" , 09, 0 } )
	aAdd( aDBFy, { 'DTMPOLD' , 'D' , 08, 0 } )

	c990TRBY   := GetNextAlias()
	//Instância classe FWTemporaryTable
	oARQT990Y := FWTemporaryTable():New(c990TRBY, aDBFy)
	//Cria indices
	oARQT990Y:AddIndex("Ind01", {"ORDEM","PLANO"})
	//Cria a tabela temporaria
	oARQT990Y:Create()

	dbSelectArea(c990TRB1)
	nTamRegua += RecCount()
	dbSelectArea(c990TRB2)
	nTamRegua += RecCount()
	dbSelectArea(c990TRBF)
	nTamRegua += RecCount()
	dbSelectArea(c990TRBB1)
	nTamRegua += RecCount()
	dbSelectArea(c990TRBE)
	nTamRegua += RecCount()
	dbSelectArea(c990TRBM)
	nTamRegua += RecCount()

	ProcRegua(nTamRegua)

	fAltSTJ() // Gravação de datas alteradas na tabela física de ordens de serviço
	fInsSTL() // Gravação de insumos na tabela física
	IncTT2(nOpcxx)
	IncTT3(nOpcxx)
	IncTT4(nOpcxx)
	IncTT5(nOpcxx)
	If Len(aAltEvent) > 0 //Se existir troca de evento
		DelTTX()
	EndIf

	fIncOSRep( aOSRepro ) //Incrementa o campo TJ_QTDREP

	//Alteracao da Situacao das OS (Bloqueios)
	dbSelectArea(c990TRBY)
	If RecCount() > 0
		fSituaca()
	EndIf

	//Deleta o arquivo temporario fisicamente
	oARQT990Y:Delete()

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} DelTTX
Exclui de outras programacoes OS que trocaram de evento

@sample
DelTTX()

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function DelTTX()
	Local nXYZ

	For nXYZ := 1 to Len(aAltEvent)
		cOrdPlano := aAltEvent[nXYZ,1] + aAltEvent[nXYZ,2]
		dbSelectArea("TTQ")
		dbSetOrder(1)
		If !dbSeek(xFilial("TTQ")+aAltEvent[nXYZ,3])
			Loop
		EndIf
		If TTQ->TTQ_DTFIM < dDataBase
			Loop
		EndIf
		dbSelectArea("TT1")
		dbSetOrder(5)
		If !dbSeek(xFilial("TT1")+TTQ->TTQ_CODIGO)
			Loop
		EndIf
		If TT1->TT1_DTFIM < dDataBase
			Loop
		EndIf
		dbSelectArea("TT2")
		dbSetOrder(1)
		dbSeek( xFilial("TT2") + TT1->TT1_CODIGO + "1" + cOrdPlano )
		While !EoF() .And. xFilial("TT2") + TT1->TT1_CODIGO + "1" + cOrdPlano == TT2->TT2_FILIAL + TT2->TT2_CODIGO + TT2->TT2_TIPO +;
		TT2->TT2_ORDEM + TT2->TT2_PLANO

			IncProc()
			RecLock("TT2",.F.)
			dbDelete()
			TT2->(MsUnLock())
			dbSkip()
		End
		dbSelectArea("TT2")
		dbSetOrder(1)
		dbSeek( xFilial("TT2") + TT1->TT1_CODIGO + "2" + cOrdPlano )
		While !EoF() .And. xFilial("TT2") + TT1->TT1_CODIGO + "2" + cOrdPlano == TT2->TT2_FILIAL + TT2->TT2_CODIGO + TT2->TT2_TIPO +;
		TT2->TT2_ORDEM + TT2->TT2_PLANO

			IncProc()
			RecLock("TT2",.F.)
			dbDelete()
			TT2->(MsUnLock())
			dbSkip()
		End
		dbSelectArea("TT3")
		dbSetOrder(1)
		dbSeek( xFilial("TT3") + TT1->TT1_CODIGO + cOrdPlano )
		While !EoF() .And. xFilial("TT3") + TT1->TT1_CODIGO + cOrdPlano == TT3->TT3_FILIAL + TT3->TT3_NUMERO + TT3->TT3_ORDEM + TT3->TT3_PLANO
			IncProc()
			RecLock("TT3",.F.)
			dbDelete()
			TT3->(MsUnLock())
			dbSkip()
		End
		dbSelectArea("TT4")
		dbSetOrder(1)
		dbSeek( xFilial("TT4") + TT1->TT1_CODIGO + cOrdPlano )
		While !EoF() .And. xFilial("TT4") + TT1->TT1_CODIGO + cOrdPlano == TT4->TT4_FILIAL + TT4->TT4_NUMERO + TT4->TT4_ORDEM + TT4->TT4_PLANO
			IncProc()
			RecLock("TT4",.F.)
			dbDelete()
			TT4->(MsUnLock())
			dbSkip()
		End
		dbSelectArea("TT5")
		dbSetOrder(1)
		dbSeek( xFilial("TT5") + TT1->TT1_CODIGO + cOrdPlano )
		While !EoF() .And. xFilial("TT5") + TT1->TT1_CODIGO + cOrdPlano == TT5->TT5_FILIAL + TT5->TT5_NUMERO + TT5->TT5_ORDEM + TT5->TT5_PLANO
			IncProc()
			RecLock("TT5",.F.)
			dbDelete()
			TT5->(MsUnLock())
			dbSkip()
		End
	Next nXYZ

Return .T.

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fAltSTJ
Realiza a alteração dos registros fisicos da ordem de serviço, gravando as novas datas programadas,
somente para as O.S. que não possuem insumos, ou seus insumos não tiveram alterações na programação.
@type function

@author Alexandre Santos
@since 03/10/2019

@sample fAltSTJ()
@return
/*/
//------------------------------------------------------------------------------------
Static Function fAltSTJ()

	Local cAlsSTJ := GetNextAlias()
	Local cTbl1   := '%' + oARQT9901:GetRealName() + '%'
	Local cTbl2   := '%' + oARQT9902:GetRealName() + '%'
	Local cTblI   := '%' + oTmpSTL:GetRealName() + '%'

	BeginSQL Alias cAlsSTJ

		SELECT // Consulta tabela de O.S. à programar ( Esquerda ).
			STJ.TJ_ORDEM,
			STJ.TJ_PLANO,
			TRB1.DTMPINI,
			TRB1.HOMPINI
		FROM
			%exp:cTbl1% TRB1
		INNER JOIN
			%table:STJ% STJ ON
				TRB1.ORDEM = STJ.TJ_ORDEM      AND
				TRB1.PLANO = STJ.TJ_PLANO      AND
				TRB1.DTMPINI <> STJ.TJ_DTMPINI AND
				%xFilial:STJ% = STJ.TJ_FILIAL  AND
				STJ.%NotDel%
		WHERE
			NOT EXISTS 	(	// Subquery que verifica a existência de insumos alterados na trb para a O.S.
							SELECT
								NULL
							FROM
								%exp:cTblI%
							WHERE
								TL_ORDEM = TRB1.ORDEM AND
								TL_PLANO = TRB1.PLANO AND
								STATUS = 0 // Status de registro que não sofreu alteração.
						) AND
			TRB1.%NotDel%

		UNION
			SELECT // Consulta tabela de O.S. em programação ( Direita ).
				STJ.TJ_ORDEM,
				STJ.TJ_PLANO,
				TRB2.DTMPINI,
				TRB2.HOMPINI
			FROM
				%exp:cTbl2% TRB2
			INNER JOIN
				%table:STJ% STJ ON
					TRB2.ORDEM = STJ.TJ_ORDEM      AND
					TRB2.PLANO = STJ.TJ_PLANO      AND
					TRB2.DTMPINI <> STJ.TJ_DTMPINI AND
					STJ.TJ_FILIAL = %xFilial:STJ%  AND
					STJ.%NotDel%
			WHERE
				NOT EXISTS 	(	// Subquery que verifica a existência de insumos alterados na trb para a O.S.
								SELECT
									NULL
								FROM
									%exp:cTblI%
								WHERE
									TL_ORDEM = TRB2.ORDEM AND
									TL_PLANO = TRB2.PLANO AND
									STATUS = 0 // Status de registro que não sofreu alteração.
							) AND
				TRB2.%NotDel%

	EndSQL

	Do While (cAlsSTJ)->( !EoF() )

		// Atualiza data e hora início da O.S. conforme os insumos.
		NGUpdDtOrd( (cAlsSTJ)->TJ_ORDEM, (cAlsSTJ)->TJ_PLANO, 0, { (cAlsSTJ)->DTMPINI, (cAlsSTJ)->HOMPINI } )

		(cAlsSTJ)->( dbSkip() )

	EndDo

	(cAlsSTJ)->( dbCloseArea() )

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fInsSTL
Grava insumos e tabelas relacionadas conforme registros alterados na tabela temporária
de insumos.
@type function

@author Alexandre Santos
@since 06/09/2019

@sample fInsSTL()

@return
/*/
//------------------------------------------------------------------------------------
Static Function fInsSTL()

	Local cAlsIns     := GetNextAlias()
	Local cAlsTmp     := '%' + oTmpSTL:GetRealName() + '%'
	Local cOldOrder   := ''
	Local cAlsDts     := ''

	Private aGetInSal := {}
	Private aGetIns   := {}
	Private aHeaIns   := {}

	// VARIAVEIS UILIZADAS NA FUNÇÃO NG420ALTE
	Private aHeaEta   := {}
	Private aDtSa     := {}
	Private nUsaCal   := 0
	Private nDataIn   := 0
	Private nHoraIn   := 0
	Private cPxSeq    := ''
	Private aBlo      := { {}, {}, {}, {}, {} }

	BeginSQL Alias cAlsIns

		SELECT
			TMP1.TL_ORDEM  ,
			TMP1.TL_PLANO  ,
			TMP1.TL_TAREFA ,
			TMP1.TL_DTINICI,
			TMP1.TL_HOINICI,
			TMP1.TL_DTFIM  ,
			TMP1.TL_HOFIM  ,
			TMP1.TL_SEQRELA,
			TMP1.TL_SEQTARE,
			TMP1.STATUS    ,
			( SELECT
				COUNT( TMP2.TL_ORDEM )
			  FROM
			  	%exp:cAlsTmp% TMP2
			  WHERE
			  	TMP2.TL_ORDEM   = TMP1.TL_ORDEM AND
				TMP2.TL_SEQRELA = '0  '         AND
				TMP2.STATUS <> 3 ) AS QTDNOTDEL // Define a quantidade de insumos que não encontram-se deletados a serem gravados por O.S.
		FROM
			%exp:cAlsTmp% TMP1
		WHERE
			TMP1.STATUS <> 0 // Filtrar somente por insumos que sofreram algum tipo de alteração.
		ORDER BY
			TMP1.TL_ORDEM,
			TMP1.TL_PLANO,
			TMP1.STATUS DESC

	EndSQL

	Do While (cAlsIns)->( !EoF() )

		// Aciona a gravação e integração dos insumos a partir da primeira ocorrência da O.S. retornada
		If (cAlsIns)->TL_ORDEM != cOldOrder

			dbSelectArea( 'STJ' )
			dbSetOrder( 1 )
			If dbSeek( xFilial( 'STJ' ) + (cAlsIns)->TL_ORDEM + (cAlsIns)->TL_PLANO )

				// CARREGA ARRAYS AGETINS E AGETINSAL CONFORME A O.S. POSICIONADA
				fGetCols( (cAlsIns)->TL_ORDEM, (cAlsIns)->TL_PLANO, .T. )

				dIni := STJ->TJ_DTMPINI
				hIni := STJ->TJ_HOMPINI
				dFim := STJ->TJ_DTMPFIM
				hFim := STJ->TJ_HOMPFIM

				// Inicialização das memórias necessarias nesse ponto para utilização da função NG420ALTE.
				RegtoMemory( 'STJ', .F., .F., .F. )

				// INICIALIZAÇÃO DAS VARIAVEIS UTILIZADAS NA FUNÇÃO NG420ALTE
				nDataIn := aScan( aHeaIns, { |x| AllTrim( Upper( x[2] ) ) == 'TL_DTINICI' } )
				nHoraIn := aScan( aHeaIns, { |x| AllTrim( Upper( x[2] ) ) == 'TL_HOINICI' } )
				nUsaCal := aScan( aHeaIns, { |x| AllTrim( Upper( x[2] ) ) == 'TL_USACALE' } )
				cPxSeq  := (cAlsIns)->TL_SEQTARE

				// Gravação dos insumos na tabela física e integração com tabelas relacionadas
				Processa( { |lEnd| NG420ALTE( ( STJ->TJ_SITUACA == 'L' ) ) }, STR0267 ) // Verificando alterações...

				// Processo para insumos não deletados, que tiveram alguma alteração na programação.
				If (cAlsIns)->QTDNOTDEL > 0

					cAlsDts := GetNextAlias()

					BeginSQL Alias cAlsDts

						SELECT
							MIN( TL_DTINICI || TL_HOINICI ) AS MINDTHR,
							MAX( TL_DTFIM || TL_HOFIM )     AS MAXDTHR
						FROM
							%exp:cAlsTmp%
						WHERE
							TL_ORDEM = %exp:(cAlsIns)->TL_ORDEM% AND
							TL_PLANO = %exp:(cAlsIns)->TL_PLANO% AND
							STATUS <> 3

					EndSQL

					If (cAlsDts)->( !EoF() )

						// Atualizando data e hora inicio da O.S. conforme insumos
						If (cAlsDts)->MINDTHR != DtoS( STJ->TJ_DTMPINI ) + STJ->TJ_HOMPINI

							NGUpdDtOrd( (cAlsIns)->TL_ORDEM, (cAlsIns)->TL_PLANO, 1, { SubStr( (cAlsDts)->MINDTHR, 1, 8 ),;
								SubStr( (cAlsDts)->MINDTHR, 9 ) } )

						EndIf

						// Atualizando data e hora fim da O.S. conforme insumos.
						If (cAlsDts)->MAXDTHR != DtoS( STJ->TJ_DTMPFIM ) + STJ->TJ_HOMPFIM

							NGUpdDtOrd( (cAlsIns)->TL_ORDEM, (cAlsIns)->TL_PLANO, 2, { SubStr( (cAlsDts)->MAXDTHR, 1, 8 ),;
								SubStr( (cAlsDts)->MAXDTHR, 9 ) } )

						EndIf

					EndIf

					(cAlsDts)->( dbCloseArea() )

				// Itens já deletados
				ElseIf (cAlsIns)->STATUS == 3

					NGUpdDtOrd( (cAlsIns)->TL_ORDEM, (cAlsIns)->TL_PLANO, 0, { dToS( STJ->TJ_DTMPINI ), STJ->TJ_HOMPINI } )

				EndIf

			EndIf

			cOldOrder := (cAlsIns)->TL_ORDEM

		EndIf

		(cAlsIns)->( dbSkip() )

	EndDo

	(cAlsIns)->( dbCloseArea() )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} IncTT2
Inclui, altera e exclui a tabela TT2

@sample
IncTT2(nOpcxx)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function IncTT2(nOpcxx)

	Local nXXX,nForG

	If nOpcxx == 5
		//Retira a OS do evento excluido
		If lEveProg
			For nXXX := 1 To Len(aOS_Evento)
				dbSelectArea("STJ")
				dbSetOrder(1)
				If dbSeek(xFilial("STJ")+aOS_Evento[nXXX,1]+aOS_Evento[nXXX,2])
					If cTT1_CDEVEN == STJ->TJ_CDEVENT
						RecLock("STJ",.F.)
						STJ->TJ_CDEVENT := " "
						STJ->(MsUnLock())
					EndIf
				EndIf
			Next nXXX
		EndIf
		//Delete OS programadas
		dbSelectArea("TT2")
		dbSetOrder(1)
		dbSeek( xFilial("TT2") + cTT1_CODIGO )
		While !EoF() .And. xFilial("TT2") + cTT1_CODIGO == TT2->TT2_FILIAL + TT2->TT2_CODIGO
			IncProc()
			RecLock("TT2",.F.)
			dbDelete()
			TT2->(MsUnLock())
			dbSkip()
		End
	Else

		//Retira a OS do evento
		If lEveProg
			For nXXX := 1 To Len(aOS_Evento)
				dbSelectArea(c990TRB2)
				dbSetOrder(3)
				dbGoTop()
				If !dbSeek( aOS_Evento[nXXX,1]+aOS_Evento[nXXX,2] ) .Or. cTT1_CDEVEN <> (c990TRB2)->EVENTO
					dbSelectArea("STJ")
					dbSetOrder(1)
					If dbSeek(xFilial("STJ")+aOS_Evento[nXXX,1]+aOS_Evento[nXXX,2])
						If cTT1_CDEVEN == STJ->TJ_CDEVENT
							RecLock("STJ",.F.)
							STJ->TJ_CDEVENT := " "
							STJ->(MsUnLock())
						EndIf
					EndIf
				EndIf
			Next nXXX
		EndIf

		//Se a OS estiver no lado esquerdo, grava em todas as Programacoes
		dbSelectArea(c990TRB1)
		dbSetOrder(nTipoInd)
		dbGoTop()
		While !EoF()
			IncProc()

			dbSelectArea("STJ")
			dbSetOrder(1)
			If dbSeek(xFilial("STJ")+(c990TRB1)->ORDEM+(c990TRB1)->PLANO)
				If lTJ_STFOLUP
					RecLock("STJ",.F.)
					STJ->TJ_STFOLUP := (c990TRB1)->XSTATUS
					STJ->(MsUnLock())
				ElseIf lTJ_STATUS
					RecLock("STJ",.F.)
					STJ->TJ_STATUS  := (c990TRB1)->XSTATUS
					STJ->(MsUnLock())
				ElseIf lTJ_XMOTIVO
					RecLock("STJ",.F.)
					STJ->TJ_XMOTIVO := (c990TRB1)->XSTATUS
					STJ->(MsUnLock())
				ElseIf lTJ_XSTATUS
					RecLock("STJ",.F.)
					STJ->TJ_XSTATUS := (c990TRB1)->XSTATUS
					STJ->(MsUnLock())
				EndIf

			EndIf

			aAdd( a01GrvTT2 , { (c990TRB1)->ORDEM , (c990TRB1)->PLANO }  )
			For nForG := 1 To Len(aCabecProg)
				If Empty(aCabecProg[nForG,3])
					Loop
				EndIf
				dbSelectArea("TT2")
				dbSetOrder(1)
				lIncluir := !dbSeek( xFilial("TT2") + aCabecProg[nForG,3] + "1" + (c990TRB1)->ORDEM + (c990TRB1)->PLANO )
				RecLock("TT2",lIncluir)
				TT2->TT2_FILIAL := xFilial("TT2")
				TT2->TT2_CODIGO := aCabecProg[nForG,3]
				TT2->TT2_TIPO   := "1"
				TT2->TT2_MARCA  := (c990TRB1)->MARCADO
				TT2->TT2_SEQ    := (c990TRB1)->SEQUENC
				TT2->TT2_PRIORI := (c990TRB1)->PRIORID
				TT2->TT2_ORDEM  := (c990TRB1)->ORDEM
				TT2->TT2_CODBEM := (c990TRB1)->CODBEM
				TT2->TT2_EQUIPE := (c990TRB1)->EQUIPE
				TT2->TT2_STATUS := (c990TRB1)->XSTATUS
				TT2->TT2_PLANO  := (c990TRB1)->PLANO
				TT2->TT2_DTINI  := (c990TRB1)->DTMPINI
				TT2->TT2_DTPROG := SToD("")
				TT2->TT2_DTORIG := (c990TRB1)->DTORIGI
				TT2->TT2_SITUAC := (c990TRB1)->SITUACA
				TT2->TT2_REALIZ := (c990TRB1)->REALIZA
				TT2->TT2_EVENTO := ""
				TT2->(MsUnLock())
			Next nForG

			dbSelectArea(c990TRB1)
			dbSkip()
		End

		//Se a OS estiver no lado direito, grava apenas na Programacao em que a OS foi gravada
		aOsDelTT2 := {}
		dbSelectArea(c990TRB2)
		dbSetOrder(nTipoInd)
		dbGoTop()
		While !EoF()
			IncProc()

			If (c990TRB2)->LIBERA == '1'
				(c990TRB2)->SITUACA := 'L'
			EndIf

			dbSelectArea("STJ")
			dbSetOrder(1)
			If dbSeek(xFilial("STJ")+(c990TRB2)->ORDEM+(c990TRB2)->PLANO)
				If lPrgEvento
					If !lPrgDiaria
						If STJ->TJ_CDEVENT <> cTT1_CDEVEN .And. !Empty(STJ->TJ_CDEVENT)
							aAdd(aAltEvent , { (c990TRB2)->ORDEM , (c990TRB2)->PLANO , STJ->TJ_CDEVENT } )
						EndIf
					Else
						If STJ->TJ_CDEVENT <> (c990TRB2)->EVENTO .And. !Empty(STJ->TJ_CDEVENT)
							aAdd(aAltEvent , { (c990TRB2)->ORDEM , (c990TRB2)->PLANO , STJ->TJ_CDEVENT } )
						EndIf
					EndIf
				EndIf
				If lTJ_STFOLUP
					RecLock("STJ",.F.)
					STJ->TJ_STFOLUP := (c990TRB2)->XSTATUS
					If lPrgEvento
						If !lPrgDiaria
							STJ->TJ_CDEVENT := cTT1_CDEVEN
						Else
							STJ->TJ_CDEVENT := (c990TRB2)->EVENTO
						EndIf
					EndIf
					STJ->(MsUnLock())
				ElseIf lTJ_STATUS
					RecLock("STJ",.F.)
					STJ->TJ_STATUS  := (c990TRB2)->XSTATUS
					If lPrgEvento
						If !lPrgDiaria
							STJ->TJ_CDEVENT := cTT1_CDEVEN
						Else
							STJ->TJ_CDEVENT := (c990TRB2)->EVENTO
						EndIf
					EndIf
					STJ->(MsUnLock())
				ElseIf lTJ_XMOTIVO
					RecLock("STJ",.F.)
					STJ->TJ_XMOTIVO := (c990TRB2)->XSTATUS
					If lPrgEvento
						If !lPrgDiaria
							STJ->TJ_CDEVENT := cTT1_CDEVEN
						Else
							STJ->TJ_CDEVENT := (c990TRB2)->EVENTO
						EndIf
					EndIf
					STJ->(MsUnLock())
				ElseIf lTJ_XSTATUS
					RecLock("STJ",.F.)
					STJ->TJ_XSTATUS := (c990TRB2)->XSTATUS
					If lPrgEvento
						If !lPrgDiaria
							STJ->TJ_CDEVENT := cTT1_CDEVEN
						Else
							STJ->TJ_CDEVENT := (c990TRB2)->EVENTO
						EndIf
					EndIf
					STJ->(MsUnLock())
				ElseIf lPrgEvento
					RecLock("STJ",.F.)
					If !lPrgDiaria
						STJ->TJ_CDEVENT := cTT1_CDEVEN
					Else
						STJ->TJ_CDEVENT := (c990TRB2)->EVENTO
					EndIf
					STJ->(MsUnLock())
				EndIf

				If (c990TRB2)->REALIZA == '0' .And. (c990TRB2)->LIBERA == '1'

					//Adicionando a OS no arquivo de OSs liberadas
					If STJ->TJ_SITUACA == 'P' .And. (c990TRB2)->SITUACA == 'L'
						dbSelectArea(c990TRBY)
						Reclock(c990TRBY,.T.)
						(c990TRBY)->ORDEM   := STJ->TJ_ORDEM
						(c990TRBY)->PLANO   := STJ->TJ_PLANO
						(c990TRBY)->DTMPINI := (c990TRB2)->DTMPINI
						(c990TRBY)->DTMPOLD := STJ->TJ_DTMPINI
						(c990TRBY)->NUMREC  := STJ->(Recno())
						(c990TRBY)->(MsUnlock())
					EndIf

				EndIf

			EndIf

			nPosPrg := 0
			If lPrgDiaria .And. !Empty((c990TRB2)->EVENTO) .And. lPrgEvento
				nPosPrg := aScan(aCabecProg ,{|x| x[5] == (c990TRB2)->EVENTO })
			Else
				nPosPrg := aScan(aCabecProg ,{|x| (c990TRB2)->DTMPROG >= x[1] .And. (c990TRB2)->DTMPROG <= x[2] .And. Empty(x[5]) })
			EndIf

			If !Empty( nPosPrg )
			
				If aCabecProg[nPosPrg,3] == cSvTT1COD
					aAdd( aOsDelTT2 , { (c990TRB2)->ORDEM , (c990TRB2)->PLANO }  )
				EndIf
				aAdd( a02GrvTT2 , { (c990TRB2)->ORDEM , (c990TRB2)->PLANO , aCabecProg[nPosPrg,3] }  )

				dbSelectArea("TT2")
				dbSetOrder(1)
				lIncluir := !dbSeek( xFilial("TT2") + aCabecProg[nPosPrg,3] + "2" + (c990TRB2)->ORDEM + (c990TRB2)->PLANO )
				RecLock("TT2",lIncluir)
				TT2->TT2_FILIAL := xFilial("TT2")
				TT2->TT2_CODIGO := aCabecProg[nPosPrg,3]
				TT2->TT2_TIPO   := "2"
				TT2->TT2_MARCA  := (c990TRB2)->MARCADO
				TT2->TT2_SEQ    := (c990TRB2)->SEQUENC
				TT2->TT2_PRIORI := (c990TRB2)->PRIORID
				TT2->TT2_ORDEM  := (c990TRB2)->ORDEM
				TT2->TT2_CODBEM := (c990TRB2)->CODBEM
				TT2->TT2_EQUIPE := (c990TRB2)->EQUIPE
				TT2->TT2_STATUS := (c990TRB2)->XSTATUS
				TT2->TT2_PLANO  := (c990TRB2)->PLANO
				TT2->TT2_DTINI  := (c990TRB2)->DTMPINI
				TT2->TT2_DTPROG := (c990TRB2)->DTMPROG
				TT2->TT2_DTORIG := (c990TRB2)->DTORIGI
				TT2->TT2_SITUAC := (c990TRB2)->SITUACA
				TT2->TT2_REALIZ := (c990TRB2)->REALIZA
				TT2->TT2_LIBERA := (c990TRB2)->LIBERA
				TT2->TT2_EVENTO := (c990TRB2)->EVENTO
				TT2->(MsUnLock())

			EndIf

			dbSelectArea(c990TRB2)
			dbSkip()

		End

		If nOpcxx == 4

			dbSelectArea("TT2")
			dbSetOrder(1)
			dbSeek(xFilial("TT2")+cSvTT1COD)
			While !EoF() .And. xFilial("TT2")+cSvTT1COD == TT2->(TT2_FILIAL+TT2_CODIGO)

				If TT2->TT2_TIPO == "1"
					dbSelectArea(c990TRB1)
					dbSetOrder(3)
					dbGoTop()
					If !dbSeek(TT2->TT2_ORDEM+TT2->TT2_PLANO)
						RecLock("TT2",.F.)
						dbDelete()
						TT2->(MsUnLock())
					EndIf
				ElseIf TT2->TT2_TIPO == "2"
					If aScan(aOsDelTT2 ,{|x| x[1]+x[2] == TT2->TT2_ORDEM+TT2->TT2_PLANO }) == 0
						RecLock("TT2",.F.)
						dbDelete()
						TT2->(MsUnLock())
					EndIf
				EndIf

				dbSelectArea("TT2")
				dbSkip()
			End
		EndIf

	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} IncTT3
Inclui, altera e exclui a tabela TT3

@sample
IncTT3(nOpcxx)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function IncTT3(nOpcxx)

	Local nPosPrg := 0
	Local nPos2   := 0

	If nOpcxx == 5 //Exclusao da Programacao
		dbSelectArea("TT3")
		dbSetOrder(1)
		dbSeek( xFilial("TT3") + cTT1_CODIGO )
		While !EoF() .And. xFilial("TT3") + cTT1_CODIGO == TT3->TT3_FILIAL + TT3->TT3_NUMERO
			IncProc()
			RecLock("TT3",.F.)
			dbDelete()
			TT3->(MsUnLock())
			dbSkip()
		End
	Else

		//Le arquivo temporario de ferramentas das OS
		dbSelectArea(c990TRBF)
		dbGoTop()
		While !EoF()
			IncProc()

			//Se a OS estiver no lado esquerdo, grava as ferramentas em todas as Programacoes
			nPosPrg := aScan(a01GrvTT2 ,{|x| x[1]+x[2] == (c990TRBF)->ORDEM + (c990TRBF)->PLANO })
			If nPosPrg == 0
				//Se a OS estiver no lado direito, grava as ferramentas apenas na Programacao em que a OS foi gravadas
				nPosPrg := aScan(a02GrvTT2 ,{|x| x[1]+x[2] == (c990TRBF)->ORDEM + (c990TRBF)->PLANO })
				If nPosPrg > 0
					dbSelectArea("TT3")
					dbSetOrder(1)
					lIncluir := !dbSeek( xFilial("TT3") + a02GrvTT2[nPosPrg,3] + (c990TRBF)->ORDEM + (c990TRBF)->PLANO + (c990TRBF)->CODIGO )
					RecLock("TT3",lIncluir)
					TT3->TT3_FILIAL := xFilial("TT3")
					TT3->TT3_NUMERO := a02GrvTT2[nPosPrg,3]
					TT3->TT3_ORDEM  := (c990TRBF)->ORDEM
					TT3->TT3_PLANO  := (c990TRBF)->PLANO
					TT3->TT3_CODIGO := (c990TRBF)->CODIGO
					TT3->TT3_QTDE   := (c990TRBF)->QUANTI
					TT3->(MsUnLock())
				EndIf
			EndIf

			dbSelectArea(c990TRBF)
			dbSkip()
		End

		If nOpcxx == 4

			dbSelectArea("TT3")
			dbSetOrder(1)
			dbSeek(xFilial("TT3")+cSvTT1COD)
			While !EoF() .And. xFilial("TT3")+cSvTT1COD == TT3->(TT3_FILIAL+TT3_NUMERO)

				nPos2 := aScan(aOsDelTT2 ,{|x| x[1]+x[2] == TT3->TT3_ORDEM + TT3->TT3_PLANO })

				//Deleta Ferramentas da Programacao Salva se, a OS nao estiver no lado esquerdo, nem no lado direito na Programacao Salva
				dbSelectArea(c990TRBF)
				dbGoTop()
				If !dbSeek( TT3->TT3_ORDEM + TT3->TT3_PLANO + TT3->TT3_CODIGO ) .Or. (nPos2 == 0)
					RecLock("TT3",.F.)
					dbDelete()
					TT3->(MsUnLock())
				EndIf

				dbSelectArea("TT3")
				dbSkip()
			End

		EndIf

	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} IncTT4
Inclui, altera e exclui a tabela TT4

@sample
IncTT4(nOpcxx)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function IncTT4(nOpcxx)

	Local nPosPrg   := 0
	Local nPos2     := 0
	Local cNumCP 	:= ""
	Local cNGMNTAS	:= SuperGetMV( "MV_NGMNTAS",.F.,"2" )
	Local cNGINTER  := AllTrim(GetNewPar("MV_NGINTER","N"))

	If nOpcxx == 5
		dbSelectArea("TT4")
		dbSetOrder(1)
		dbSeek( xFilial("TT4") + cTT1_CODIGO )
		While !EoF() .And. xFilial("TT4") + cTT1_CODIGO == TT4->TT4_FILIAL + TT4->TT4_NUMERO

			IncProc()

			//Excluindo Solicitacoes de Armazem
			dbSelectArea("SCP")
			dbSetOrder(1)
			If dbSeek( xFilial("SCP") + TT4->TT4_NUMSA + TT4->TT4_ITEMSA )
				If SCP->CP_PREREQU <> "S"

					If cNGINTER == "M"
						If cNGMNTAS == "1"
							cNumCP := SCP->CP_NUM
						Else
							NGMUReques( SCP->( RecNo()),"SCP",.F.,5 )
						EndIf
					EndIf

					If Empty(cNumCP)

						// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
						IIf( FindFunction( 'MntDelReq' ), MntDelReq( SCP->CP_NUM, SCP->CP_ITEM, 'SA' ), NGDELETAREG( 'SCP' ) )

					EndIf

				EndIf
			EndIf

			dbSelectArea("TT4")
			RecLock("TT4",.F.)
			dbDelete()
			TT4->(MsUnLock())
			dbSkip()

		End While

		If cNGMNTAS == "1"
			If !Empty(cNumCP) .And. NGIFDBSEEK( "SCP",cNumCP,01,.F. )
				If SCP->CP_PREREQU <> "S"
					If cNGINTER == "M"
						NGMUReques( SCP->( RecNo()),"SCP",.F.,5 )
					EndIf
					NGDBAREAORD( "SCP",01 )

					While SCP->( dbSeek( xFilial( "SCP" ) + cNumCP ) )

						// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
						IIf( FindFunction( 'MntDelReq' ), MntDelReq( SCP->CP_NUM, SCP->CP_ITEM, 'SA' ), NGDELETAREG( 'SCP' ) )

					End While

				EndIf
			EndIf
		EndIf
	Else

		dbSelectArea(c990TRBB1)
		dbGoTop()
		While !EoF()

			IncProc()

			//Se a OS estiver no lado esquerdo, grava os produtos em todas as Programacoes
			nPosPrg := aScan(a01GrvTT2 ,{|x| x[1]+x[2] == (c990TRBB1)->ORDEM + (c990TRBB1)->PLANO })
			If nPosPrg == 0
				//Se a OS estiver no lado direito, grava os produtos apenas na Programacao em que a OS foi gravadas
				nPosPrg := aScan(a02GrvTT2 ,{|x| x[1]+x[2] == (c990TRBB1)->ORDEM + (c990TRBB1)->PLANO })
				If nPosPrg > 0
					dbSelectArea("TT4")
					dbSetOrder(nSixTT4x)
					If !dbSeek( xFilial("TT4") + a02GrvTT2[nPosPrg,3] + (c990TRBB1)->ORDEM + (c990TRBB1)->PLANO + PadR(  (c990TRBB1)->CODIGO, Len(TT4->TT4_CODIGO) ) + ;
					(c990TRBB1)->NUMSC + (c990TRBB1)->NUMSA + (c990TRBB1)->ITEMSA )
						RecLock("TT4",.T.)
						TT4->TT4_FILIAL := xFilial("TT4")
						TT4->TT4_NUMERO := a02GrvTT2[nPosPrg,3]
						TT4->TT4_ORDEM  := (c990TRBB1)->ORDEM
						TT4->TT4_PLANO  := (c990TRBB1)->PLANO
						TT4->TT4_CODIGO := (c990TRBB1)->CODIGO
						TT4->TT4_NUMSC  := (c990TRBB1)->NUMSC
						TT4->TT4_NUMSA  := (c990TRBB1)->NUMSA
						TT4->TT4_ITEMSA := (c990TRBB1)->ITEMSA
					Else
						RecLock("TT4",.F.)
					EndIf

					TT4->TT4_QTDE   := (c990TRBB1)->QTDNEC
					TT4->TT4_DATASC := (c990TRBB1)->DTPREV
					TT4->(MsUnLock())
				EndIf
			EndIf

			dbSelectArea(c990TRBB1)
			dbSkip()
		End

		If nOpcxx == 4

			dbSelectArea("TT4")
			dbSetOrder(nSixTT4x)
			dbSeek(xFilial("TT4")+cSvTT1COD)
			While !EoF() .And. xFilial("TT4")+cSvTT1COD == TT4->(TT4_FILIAL+TT4_NUMERO)

				nPos2 := aScan(aOsDelTT2 ,{|x| x[1]+x[2] == TT4->TT4_ORDEM + TT4->TT4_PLANO })

				//Deleta Produtos da Programacao Salva se, a OS nao estiver no lado esquerdo, nem no lado direito na Programacao Salva
				dbSelectArea(c990TRBB1)
				dbGoTop()
				If !dbSeek( TT4->( TT4_ORDEM + TT4_PLANO + TT4_CODIGO + TT4_NUMSC + TT4_NUMSA + TT4_ITEMSA ) ) .Or. (nPos2 == 0)
					dbSelectArea("SCP")
					dbSetOrder(1)
					If dbSeek( xFilial("SCP") + TT4->TT4_NUMSA + TT4->TT4_ITEMSA )
						If SCP->CP_PREREQU <> "S"
							If cNGINTER == "M"
								If cNGMNTAS == "1"
									cNumCP := SCP->CP_NUM
								Else

									NGMUReques( SCP->( RecNo()),"SCP",.F.,5 )

									// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
									IIf( FindFunction( 'MntDelReq' ), MntDelReq( SCP->CP_NUM, SCP->CP_ITEM, 'SA' ), NGDELETAREG( 'SCP' ) )

								EndIf

							EndIf
						EndIf
					EndIf
					dbSelectArea("TT4")
					RecLock("TT4",.F.)
					dbDelete()
					TT4->(MsUnLock())
				EndIf

				dbSelectArea("TT4")
				dbSkip()
			End

			If cNGMNTAS == "1"
				If !Empty(cNumCP) .And. NGIFDBSEEK( "SCP",cNumCP,01,.F. )
					If SCP->CP_PREREQU <> "S"
						If cNGINTER == "M"
							NGMUReques( SCP->( RecNo()),"SCP",.F.,5 )
						EndIf
						NGDBAREAORD( "SCP",01 )

						While SCP->( dbSeek( xFilial( "SCP" ) + cNumCP ) )

							// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
							IIf( FindFunction( 'MntDelReq' ), MntDelReq( SCP->CP_NUM, SCP->CP_ITEM, 'SA' ), NGDELETAREG( 'SCP' ) )

						End While

					EndIf
				EndIf
			EndIf
		EndIf

	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} IncTT5
Inclui, altera e exclui a tabela TT5

@sample
IncTT5(nOpcxx)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function IncTT5(nOpcxx)

	Local nPosPrg := 0
	Local nPos2   := 0

	If nOpcxx == 5
		dbSelectArea("TT5")
		dbSetOrder(1)
		dbSeek( xFilial("TT5") + cTT1_CODIGO )
		While !EoF() .And. xFilial("TT5") + cTT1_CODIGO == TT5->TT5_FILIAL + TT5->TT5_NUMERO
			IncProc()
			RecLock("TT5",.F.)
			dbDelete()
			TT5->(MsUnLock())
			dbSkip()
		End
	Else
		dbSelectArea(c990TRBE)
		dbGoTop()
		While !EoF()
			IncProc()

			//Se a OS estiver no lado esquerdo, grava os produtos em todas as Programacoes
			nPosPrg := aScan(a01GrvTT2 ,{|x| x[1]+x[2] == (c990TRBE)->ORDEM + (c990TRBE)->PLANO })
			If nPosPrg == 0
				//Se a OS estiver no lado direito, grava os produtos apenas na Programacao em que a OS foi gravadas
				nPosPrg := aScan(a02GrvTT2 ,{|x| x[1]+x[2] == (c990TRBE)->ORDEM + (c990TRBE)->PLANO })
				If nPosPrg > 0
					dbSelectArea("TT5")
					dbSetOrder(1)
					lIncluir := !dbSeek( xFilial("TT5") + a02GrvTT2[nPosPrg,3] + (c990TRBE)->ORDEM + (c990TRBE)->PLANO + (c990TRBE)->CODIGO )
					RecLock("TT5",lIncluir)
					TT5->TT5_FILIAL := xFilial("TT5")
					TT5->TT5_NUMERO := a02GrvTT2[nPosPrg,3]
					TT5->TT5_ORDEM  := (c990TRBE)->ORDEM
					TT5->TT5_PLANO  := (c990TRBE)->PLANO
					TT5->TT5_CODIGO := (c990TRBE)->CODIGO
					TT5->TT5_TEMPRO := (c990TRBE)->TEMPRO
					TT5->TT5_QTDTEC := (c990TRBE)->QTDTEC
					TT5->TT5_TEMREA := (c990TRBE)->TEMREA
					TT5->TT5_TOTTEC := (c990TRBE)->TOTTEC
					TT5->TT5_TECADD := (c990TRBE)->TECADD
					TT5->TT5_DIAADD := (c990TRBE)->DIAADD
					TT5->TT5_TECAUS := (c990TRBE)->TECAUS
					TT5->TT5_DIAAUS := (c990TRBE)->DIAAUS
					TT5->TT5_TEMDIS := (c990TRBE)->TEMDIS
					TT5->TT5_OBS    := (c990TRBE)->OBS
					TT5->(MsUnLock())
				EndIf
			EndIf

			dbSelectArea(c990TRBE)
			dbSkip()
		End

		If nOpcxx == 4

			dbSelectArea("TT5")
			dbSetOrder(1)
			dbSeek(xFilial("TT5")+cSvTT1COD)
			While !EoF() .And. xFilial("TT5")+cSvTT1COD == TT5->(TT5_FILIAL+TT5_NUMERO)

				nPos2 := aScan(aOsDelTT2 ,{|x| x[1]+x[2] == TT5->TT5_ORDEM + TT5->TT5_PLANO })

				//Deleta Especialidades da Programacao Salva se, a OS nao estiver no lado esquerdo, nem no lado direito na Programacao Salva
				dbSelectArea(c990TRBE)
				dbSetOrder(1)
				dbGoTop()
				If !dbSeek( TT5->TT5_ORDEM + TT5->TT5_PLANO + TT5->TT5_CODIGO ) .Or. (nPos2 == 0)
					RecLock("TT5",.F.)
					dbDelete()
					TT5->(MsUnLock())
				EndIf

				dbSelectArea("TT5")
				dbSkip()
			End
		EndIf

	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fMPBA01CHK
Validacao da confirmacao de inclusao ou cancelamento da tela

@sample
fMPBA01CHK(nTipo,nOpcxx)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fMPBA01CHK(nTipo,nOpcxx)

	Local xPE9903 //Retorno do P.E.

	If nOpcxx == 2 .Or. !lAltProg
		Return .T.
	EndIf

	If nTipo == 1
		If nOpcxx == 5
			If !MsgYesNo(STR0090,STR0091) //"Confirma a exclusão da Programação de O.S.?"###"Exclusão"
				Return .F.
			EndIf
		Else
			lNaoLibera := .F.
			dbSelectArea(c990TRB2)
			dbGoTop()
			Do While (c990TRB2)->( !EoF() )

				If Empty( (c990TRB2)->LIBERA ) .And. (c990TRB2)->SITUACA == 'P'
					lNaoLibera := .T.
					Exit
				EndIf

				(c990TRB2)->( dbSkip() )

			EndDo

			dbGoTop()
			If lNaoLibera
				If !MsgYesNo(STR0092+; //"Existem O.S. que não foram liberadas. "
				STR0093,STR0094) //"Confirma a gravação das alterações realizadas nas Ordens de Serviços?"###"Confirmação"
					Return .F.
				EndIf
			Else
				If !MsgYesNo(STR0093,STR0094) //"Confirma a gravação das alterações realizadas nas Ordens de Serviços?"###"Confirmação"
					Return .F.
				EndIf
			EndIf
			If ExistBlock("MNTA9903")
				xPE9903 := ExecBlock("MNTA9903")
				If ValType(xPE9903) == "L" .And. !xPE9903
					Return .F.
				EndIf
			EndIf
		EndIf
	Else
		If nOpcxx != 5
			If !MsgYesNo(STR0095,STR0096) //"Confirma o cancelamento das alterações realizadas nas Ordens de Serviços?"###"Cancelamento"
				Return .F.
			EndIf
		EndIf
	EndIf

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} ScreenProg
Programacao de Ordem de Serviço

@sample
ScreenProg(nOpcxx,nTipo)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function ScreenProg(nOpcxx,nTipo)
	Local oDlgNew
	Local oPanel
	Local oGet1
	// [LGPD] Caso o usuário não possua acesso ao(s) campo(s), deve-se ofuscá-lo(s)
	Local lOfuscar := FindFunction( 'FWPDCanUse' ) .And. FwPdCanUse( .T. );
						.And. Len( FwProtectedDataUtil():UsrAccessPDField( __CUSERID, { 'TT1_NOMRES' } ) ) == 0

	M->TT1_CODIGO := cTT1_CODIGO
	M->TT1_DTPROG := dTT1_DTPROG
	M->TT1_DTFIM  := dTT1_DTFIM
	M->TT1_DESCRI := cTT1_DESCRI
	M->TT1_RESPON := cTT1_RESPON
	M->TT1_NOMRES := cTT1_NOMRES
	M->TT1_CDEVEN := cTT1_CDEVEN

	nOpcCad := 0
	Define MsDialog oDlgNew Title OemToAnsi(STR0097) From 0,0 To 12,75 OF oMainWnd  //"Dados da Programação"

	oDlgNew:LESCCLOSE := .F.

	oPanel := TPanel():New(0, 0, Nil, oDlgNew, Nil, .T., .F., Nil, Nil, 0, 0, .T., .F. )
	oPanel:Align := CONTROL_ALIGN_ALLCLIENT

	@ 010,008  Say Oemtoansi(STR0098) Color CLR_HBLUE Of oPanel Pixel //"Programação"
	@ 010,060  MsGet M->TT1_CODIGO  Picture '@!' Size 50,7 Of oPanel Pixel When .F.

	@ 010,120  Say Oemtoansi(STR0012) Of oPanel Pixel //"Descrição"
	@ 010,170  MsGet M->TT1_DESCRI Picture '@!' Size 120,7 Of oPanel Pixel When lAltProg

	@ 024,008  Say Oemtoansi(STR0099) Color CLR_HBLUE Of oPanel Pixel //"Planejador"
	@ 024,060  MsGet M->TT1_RESPON Valid fMPB001SRA("ST1",M->TT1_RESPON) F3 "ST1" Picture '@!' Size 50,7 Of oPanel Pixel When lAltProg HASBUTTON

	@ 024,120  Say Oemtoansi(STR0100) Of oPanel Pixel //"Nome Resp."
	@ 024,170  MsGet oGet1 Var M->TT1_NOMRES Picture '@!' Size 120,7 Of oPanel Pixel When .F.
	If lOfuscar
		oGet1:lObfuscate := .T.
		oGet1:bWhen := {|| .F. }
	EndIf

	lintmp := 038
	If lPrgEvento
		@ 038,008  Say Oemtoansi(STR0198) Of oPanel Pixel //"Evento"
		@ 038,060  MsGet M->TT1_CDEVEN Valid fVldEvento(M->TT1_CDEVEN) F3 "TTQ" Picture '@!' Size 50,7 Of oPanel Pixel When (lAltProg .And. nTipo == 1) HASBUTTON
		lintmp := 050
	EndIf

	@ lintmp,008  Say Oemtoansi(STR0101) Color CLR_HBLUE Of oPanel Pixel //"Data Inicio Prog."
	@ lintmp,060  MsGet M->TT1_DTPROG Valid VldDt990(1,M->TT1_DTPROG,M->TT1_DTFIM,nTipo) Picture '99/99/9999' Size 50,7 Of oPanel Pixel When (lAltProg .And. Empty(M->TT1_CDEVEN)) HASBUTTON

	@ lintmp,120  Say Oemtoansi(STR0102) Color CLR_HBLUE  Of oPanel Pixel //"Data Fim Prog."
	@ lintmp,170  MsGet M->TT1_DTFIM Valid VldDt990(2,M->TT1_DTPROG,M->TT1_DTFIM,nTipo) Picture '99/99/9999' Size 50,7 Of oPanel Pixel When (lAltProg .And. Empty(M->TT1_CDEVEN)) HASBUTTON

	Activate MsDialog oDlgNew On Init EnchoiceBar(oDlgNew,{|| nOpcCad:=1,If(!fValidTela(),nOpcCad:=0,oDlgNew:End()) },;
	{|| oDlgNew:End() }) Centered

	If nOpcCad == 1 .And. lAltProg
		cTT1_CODIGO := M->TT1_CODIGO
		cTT1_DESCRI := M->TT1_DESCRI
		cTT1_RESPON := M->TT1_RESPON
		cTT1_CDEVEN := M->TT1_CDEVEN
		cTT1_NOMRES := M->TT1_NOMRES
		If nTipo == 2 .And. !Empty(M->TT1_DTDE) .And. ( M->TT1_DTPROG <> dTT1_DTPROG .Or. M->TT1_DTFIM <> dTT1_DTFIM )
			dTT1_DTPROG := M->TT1_DTPROG
			dTT1_DTFIM  := M->TT1_DTFIM
			If nOSPrInd == 1
				//Carrega a disponibilidade por Especialidade
				Processa({|lEND| fDispoST1(.T.,.T.,dTT1_DTPROG,dTT1_DTFIM) },STR0020) //"Verificando Disponibilidade da Mão-de-Obra"
				//Carrega Folders (MDO, Produtos e Ferramentas)
				Processa({|lEND| fLoadTTXX(.T.) },STR0199) //"Carregando Insumos"
			EndIf
		Else
			dTT1_DTPROG := M->TT1_DTPROG
			dTT1_DTFIM  := M->TT1_DTFIM
		EndIf
	EndIf

Return nOpcCad
//---------------------------------------------------------------------
/*/{Protheus.doc} fValidTela
Valida tela Programacao

@sample
fValidTela()

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fValidTela()

	If Empty(M->TT1_DTPROG)
		MsgInfo(STR0103) //"O campo Data Inicio Prog. é obrigatório."
		Return .F.
	ElseIf Empty(M->TT1_DTFIM)
		MsgInfo(STR0104) //"O campo Data Fim Prog. é obrigatório."
		Return .F.
	ElseIf Empty(M->TT1_RESPON)
		MsgInfo(STR0105) //"O campo Planejador é obrigatório."
		Return .F.
	EndIf

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} fVldEvento
Valida tela Programacao

@sample
fVldEvento(CDEVEN)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fVldEvento(CDEVEN)
	If !Empty(CDEVEN)
		dbSelectArea("TTQ")
		dbSetOrder(1)
		If !dbSeek(xFilial("TTQ")+CDEVEN)
			Help(" ",1,"REGNOIS")
			Return .F.
		EndIf
		If TTQ->TTQ_DTFIM < dDataBase
			Help(" ",1,"NGATENCAO",,STR0224+Chr(13)+Chr(10)+; //"Este Evento não pode ser selecionado,"
			STR0225+DTOC(TTQ->TTQ_DTFIM),3,1) //"pois ele foi encerrado na data "
			Return .F.
		EndIf
		nCont := 0
		dbSelectArea("TT1")
		dbSetOrder(5)
		dbSeek(xFilial("TT1")+CDEVEN)
		While !EoF() .And. xFilial("TT1") == TT1->TT1_FILIAL .And. CDEVEN == TT1->TT1_CDEVEN
			If TT1->TT1_CODIGO <> M->TT1_CODIGO
				nCont++
				Exit
			EndIf
			dbSkip()
		End
		TT1->(dbSetOrder(1))
		If nCont > 0
			Help(" ",1,"NGATENCAO",,STR0224+Chr(13)+Chr(10)+; //"Este Evento não pode ser selecionado,"
			STR0226+Chr(13)+Chr(10)+TT1->TT1_CODIGO,3,1) //"pois está sendo utilizado na Programação: "
			Return .F.
		EndIf
		M->TT1_DTPROG := TTQ->TTQ_DTINI
		M->TT1_DTFIM  := TTQ->TTQ_DTFIM
	EndIf
Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} fMPB001SRA
Valida campo Responsavel (ST1)

@sample
fMPB001SRA(cTabResp,cCodResp)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fMPB001SRA(cTabResp,cCodResp)
	If !ExistCpo(cTabResp,cCodResp, 1)
		Return .F.
	EndIf
	M->TT1_NOMRES := NgSeek("ST1",cCodResp,1,"T1_NOME")
Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} VldDt990
Valida data programacao e data fim

@sample
VldDt990(nTpData,tmpDTPROG,tmpDTFIM,nTipo)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Function VldDt990(nTpData,tmpDTPROG,tmpDTFIM,nTipo)
	Local dInicioPrg := SToD("")
	Local dFimPrg    := SToD("")

	If nTipo == 2
		dbSelectArea(c990TRB2)
		dbSetOrder(6)
		(c990TRB2)->(dbGoTop())
		dInicioPrg := (c990TRB2)->DTMPROG
		(c990TRB2)->(dbGoBottom())
		dFimPrg := (c990TRB2)->DTMPROG
	EndIf

	If nTpData == 1
		If !NaoVazio(tmpDTPROG)
			Return .F.
		EndIf
		If tmpDTPROG < dDataBase
			Help(" ",1,"NGATENCAO",,STR0106+Chr(13)+Chr(10)+; //"A Data de Inicio não pode ser menor"
			STR0107,3,1) //"do que a Data Atual."
			Return .F.
		EndIf
		If !Empty(dInicioPrg)
			If tmpDTPROG > dInicioPrg
				Help(" ",1,"NGATENCAO",,STR0227+Chr(13)+Chr(10)+; //"A Data de Inicio não pode ser esta,"
				STR0228+Chr(13)+Chr(10)+; //"pois existe uma OS Programada na"
				STR0229+DtoC(dInicioPrg),3,1) //"data: "
				Return .F.
			EndIf
		EndIf
	Else
		If !NaoVazio(tmpDTPROG)
			Return .F.
		EndIf
		If tmpDTFIM < tmpDTPROG
			Help(" ",1,"DATA2INVAL")
			Return .F.
		EndIf
		If !Empty(dFimPrg)
			If tmpDTFIM < dFimPrg
				Help(" ",1,"NGATENCAO",,STR0230+Chr(13)+Chr(10)+; //"A Data Fim não pode ser esta,"
				STR0228+Chr(13)+Chr(10)+; //"pois existe uma OS Programada na"
				STR0229+DtoC(dFimPrg),3,1) //"data: "
				Return .F.
			EndIf
		EndIf
	EndIf

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} fBuscaOS
Busca as OS do filtro

@sample
fBuscaOS(nTipo)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fBuscaOS(nTipo)

	Local aArea 	:= GetArea()
	Local nVardiC 	:= 0
	Local lRefaz 	:= .T.
	Local lMNTA9909	:= Existblock("MNTA9909")
	Local lMNTA9904	:= ExistBlock("MNTA9904")

	If !lAltProg
		Return .F.
	EndIf

	If nTipo == 1
		dbSelectArea(c990TRB2)
		dbGoTop()
		If !(c990TRB2)->(EoF())
			If !MsgYesNo(STR0108) //"Já existem O.S. selecionadas para a programação. Confirma novo filtro?"
				Return .F.
			EndIf
		EndIf
	EndIf

	If lCpoContDt // verifica se existe o campo TT1->TT1_CONDTA
		If M->TT1_CONDTA == "2" .And. Empty(M->TT1_DTDE)
			Help(" ",1,"NGATENCAO",,STR0109) //"Campo Data Inicio é obrigatório."
			oGet001:SetFocus()
			return .F.
		EndIf
	ElseIf Empty(M->TT1_DTDE)
		Help(" ",1,"NGATENCAO",,STR0109) //"Campo Data Inicio é obrigatório."
		oGet001:SetFocus()
		return .F.
	EndIf
	If Empty(M->TT1_DTATE)
		Help(" ",1,"NGATENCAO",,STR0110) //"Campo Data Fim é obrigatório."
		oGet002:SetFocus()
		return .F.
	EndIf
	If lCpoContDt
		If M->TT1_CONDTA == "1" .And. M->TT1_DTATE < dDataBase
			MsgInfo(STR0290,STR0285) //"Quando o parametro 'Data Atrasada' estiver igual a 'Sim' a data fim deve ser igual ou maior que a data base." ## "ATENÇÃO"
			Return .F.
		EndIf
	EndIf
	If M->TT1_DTDE > M->TT1_DTATE
		Help(" ",1,"NGATENCAO",,STR0111+Chr(13)+Chr(10)+; //"A Data Inicio não pode ser maior"
		STR0112) //"que Data Fim"
		oGet002:SetFocus()
		return .F.
	EndIf

	cQuery := "SELECT STL.TL_FILIAL, STL.TL_ORDEM, STL.TL_PLANO, STL.TL_TAREFA, STL.TL_TIPOREG, STL.TL_CODIGO,"
	cQuery += "STL.TL_SEQRELA, STL.TL_SEQTARE, STJ.TJ_CODBEM,STJ.TJ_ORDEM,STJ.TJ_PLANO,STJ.TJ_DTMPINI,STJ.TJ_DTMPFIM,STJ.TJ_PRIORID,"
	cQuery += 'STL.TL_QUANREC, STL.TL_QUANTID, STL.TL_UNIDADE, STL.TL_TIPOHOR, STL.TL_DTINICI, STL.TL_HOINICI, STL.TL_DTFIM, STL.TL_HOFIM,'
	cQuery += "STJ.TJ_SERVICO, STJ.TJ_HOMPINI, STJ.TJ_HOMPFIM,"
	cQuery += "STJ.TJ_SITUACA,STJ.TJ_TIPOOS, TJ_DTORIGI"
	cQuery += If(NgVerify("STJ"),",STJ.TJ_SEQRELA",",STJ.TJ_SEQUENC")
	If lTJ_EQUIPE
		cQuery += ",STJ.TJ_EQUIPE"
	ElseIf lTJ_XEQUIPE
		cQuery += ",STJ.TJ_XEQUIPE"
	EndIf
	If lTJ_STFOLUP
		cQuery += ",STJ.TJ_STFOLUP"
	ElseIf lTJ_STATUS
		cQuery += ",STJ.TJ_STATUS"
	ElseIf lTJ_XMOTIVO
		cQuery += ",STJ.TJ_XMOTIVO"
	ElseIf lTJ_XSTATUS
		cQuery += ",STJ.TJ_XSTATUS"
	EndIf
	cQuery += " FROM " + RetSQLName("STJ") + " STJ"
	cQuery += " LEFT JOIN " + RetSQLName("STL") + " STL ON STJ.TJ_ORDEM = STL.TL_ORDEM AND STJ.TJ_PLANO = STL.TL_PLANO"
	cQuery += 		" AND STL.D_E_L_E_T_ = ' '"
	cQuery += 		" AND STL.TL_FILIAL = '" + xFilial("STL") + "'"
	If lCpoContDt
		If !(Empty(M->TT1_ETADE) .And. M->TT1_ETAAT == "ZZZZZZ")
			cQuery += " INNER JOIN " + RetSQLName("STQ") + " STQ ON STJ.TJ_ORDEM = STQ.TQ_ORDEM "
			cQuery += " AND (STQ.TQ_ETAPA >= '" + M->TT1_ETADE + "' AND STQ.TQ_ETAPA <= '" + M->TT1_ETAAT + "')"
			cQuery += " AND (STQ.TQ_FILIAL = '" + xFilial("STQ") + "')"
			cQuery += " AND (STQ.D_E_L_E_T_ = ' ' )"
		EndIf
		cQuery += " LEFT JOIN " + RetSQLName("STF") + " STF ON STJ.TJ_CODBEM = STF.TF_CODBEM "
		cQuery += " AND  STJ.TJ_SERVICO = STF.TF_SERVICO "
		cQuery += " AND  STJ.TJ_SEQRELA = STF.TF_SEQRELA "
	EndIf
	cQuery += " WHERE STJ.TJ_TERMINO <> 'S'"
	If lCpoContDt
		If M->TT1_CALEDE == "   " .And. M->TT1_CALEAT == "ZZZ"
			cQuery += " AND (STF.TF_CALENDA IS NULL OR (STF.TF_CALENDA >= '" + M->TT1_CALEDE + "' AND STF.TF_CALENDA <= '" + M->TT1_CALEAT + "'))"
			cQuery += " AND (STF.TF_FILIAL  IS NULL OR STF.TF_FILIAL = '" + xFilial("STF") + "')"
			cQuery += " AND (STF.D_E_L_E_T_ IS NULL OR STF.D_E_L_E_T_ = ' ') "
		Else
			cQuery += " AND STF.TF_CALENDA >= '" + M->TT1_CALEDE + "' AND STF.TF_CALENDA <= '" + M->TT1_CALEAT + "'"
			cQuery += " AND STF.TF_FILIAL = '" + xFilial("STF") + "'"
			cQuery += " AND STF.D_E_L_E_T_ = ' ' "
		EndIf
		If M->TT1_CONDTA == "1"
			cQuery += " AND STJ.TJ_DTMPFIM <= '" + Dtos(M->TT1_DTATE) + "'"
		Else
			cQuery += " AND STJ.TJ_DTMPINI <= '" + Dtos(M->TT1_DTATE) + "' AND STJ.TJ_DTMPFIM >= '" + Dtos(M->TT1_DTDE) + "'"
		EndIf
	Else
		cQuery += " AND STJ.TJ_DTMPINI <= '" + Dtos(M->TT1_DTATE) + "' AND STJ.TJ_DTMPFIM >= '" + Dtos(M->TT1_DTDE) + "'"
	EndIf
	If lTJ_EQUIPE
		If !Empty(M->TT1_EQUDE)
			cQuery += " AND STJ.TJ_EQUIPE >= '" + M->TT1_EQUDE + "'"
		EndIf
		If M->TT1_EQUATE <> Replicate("Z",6)
			cQuery += " AND STJ.TJ_EQUIPE <= '" + M->TT1_EQUATE + "'"
		EndIf
	ElseIf lTJ_XEQUIPE
		If !Empty(M->TT1_EQUDE)
			cQuery += " AND STJ.TJ_XEQUIPE >= '" + M->TT1_EQUDE + "'"
		EndIf
		If M->TT1_EQUATE <> Replicate("Z",6)
			cQuery += " AND STJ.TJ_XEQUIPE <= '" + M->TT1_EQUATE + "'"
		EndIf
	EndIf

	If lTJ_STFOLUP
		If !Empty(M->TT1_STADE)
			cQuery += " AND STJ.TJ_STFOLUP >= '" + M->TT1_STADE + "'"
		EndIf
		If M->TT1_STAATE <> Replicate("Z",nTamStatus)
			cQuery += " AND STJ.TJ_STFOLUP <= '" + M->TT1_STAATE + "'"
		EndIf
	ElseIf lTJ_STATUS
		If !Empty(M->TT1_STADE)
			cQuery += " AND STJ.TJ_STATUS >= '" + M->TT1_STADE + "'"
		EndIf
		If M->TT1_STAATE <> Replicate("Z",nTamStatus)
			cQuery += " AND STJ.TJ_STATUS <= '" + M->TT1_STAATE + "'"
		EndIf
	ElseIf lTJ_XMOTIVO
		If !Empty(M->TT1_STADE)
			cQuery += " AND STJ.TJ_XMOTIVO >= '" + M->TT1_STADE + "'"
		EndIf
		If M->TT1_STAATE <> Replicate("Z",nTamStatus)
			cQuery += " AND STJ.TJ_XMOTIVO <= '" + M->TT1_STAATE + "'"
		EndIf
	ElseIf lTJ_XSTATUS
		If !Empty(M->TT1_STADE)
			cQuery += " AND STJ.TJ_XSTATUS >= '" + M->TT1_STADE + "'"
		EndIf
		If M->TT1_STAATE <> Replicate("Z",nTamStatus)
			cQuery += " AND STJ.TJ_XSTATUS <= '" + M->TT1_STAATE + "'"
		EndIf
	EndIf
	If !Empty(M->TT1_BEMDE)
		cQuery += " AND STJ.TJ_CODBEM >= '" + M->TT1_BEMDE + "'"
	EndIf
	If M->TT1_BEMATE <> Replicate("Z",16)
		cQuery += " AND STJ.TJ_CODBEM <= '" + M->TT1_BEMATE + "'"
	EndIf
	If !Empty(M->TT1_CCDE)
		cQuery += " AND STJ.TJ_CCUSTO >= '" + M->TT1_CCDE + "'"
	EndIf
	If M->TT1_CCATE <> Replicate("Z",nSizeSI3)
		cQuery += " AND STJ.TJ_CCUSTO <= '" + M->TT1_CCATE + "'"
	EndIf
	If lCpoTrab
		If !Empty(M->TT1_TRADE)
			cQuery += " AND STJ.TJ_CENTRAB >= '" + M->TT1_TRADE + "'"
		EndIf
		If M->TT1_TRAATE <> Replicate("Z",nSizeSHB)
			cQuery += " AND STJ.TJ_CENTRAB <= '" + M->TT1_TRAATE + "'"
		EndIf
	EndIf
	If lCpoTipM
		If !Empty(M->TT1_TIPDE)
			cQuery += " AND STJ.TJ_TIPO >= '" + M->TT1_TIPDE + "'"
		EndIf
		If M->TT1_TIPATE <> Replicate("Z",nSizeSTE)
			cQuery += " AND STJ.TJ_TIPO <= '" + M->TT1_TIPATE + "'"
		EndIf
	EndIf
	If lCpoAreM
		If !Empty(M->TT1_AREDE)
			cQuery += " AND STJ.TJ_CODAREA >= '" + M->TT1_AREDE + "'"
		EndIf
		If M->TT1_AREATE <> Replicate("Z",nSizeSTD)
			cQuery += " AND STJ.TJ_CODAREA <= '" + M->TT1_AREATE + "'"
		EndIf
	EndIf
	If lCpoServ
		If !Empty(M->TT1_SERDE)
			cQuery += " AND STJ.TJ_SERVICO >= '" + M->TT1_SERDE + "'"
		EndIf
		If M->TT1_SERATE <> Replicate("Z",nSizeST4)
			cQuery += " AND STJ.TJ_SERVICO <= '" + M->TT1_SERATE + "'"
		EndIf
	EndIf
	If lCpoOrde
		If !Empty(M->TT1_ORDDE)
			cQuery += " AND STJ.TJ_ORDEM >= '" + M->TT1_ORDDE + "'"
		EndIf
		If M->TT1_ORDATE <> Replicate("Z",nSizeSTJ)
			cQuery += " AND STJ.TJ_ORDEM <= '" + M->TT1_ORDATE + "'"
		EndIf
	EndIf
	If lCpoPlan
		If !Empty(M->TT1_PLADE)
			cQuery += " AND STJ.TJ_PLANO >= '" + M->TT1_PLADE + "'"
		EndIf
		If M->TT1_PLAATE <> Replicate("Z",nSizeSTS)
			cQuery += " AND STJ.TJ_PLANO <= '" + M->TT1_PLAATE + "'"
		EndIf
	EndIf
	If lCpoEvent
		If !Empty(M->TT1_EVEDE)
			cQuery += " AND STJ.TJ_CDEVENT >= '" + M->TT1_EVEDE + "'"
		EndIf
		If M->TT1_EVEATE <> Replicate("Z",nSizeEve)
			cQuery += " AND STJ.TJ_CDEVENT <= '" + M->TT1_EVEATE + "'"
		EndIf
	EndIf
	If M->TT1_INDLUB == "2"
		cQuery += " AND STJ.TJ_LUBRIFI <> 'S'"
	EndIf
	If M->TT1_INDLOC == "2"
		cQuery += " AND STJ.TJ_TIPOOS = 'B'"
	EndIf
	cQuery += " AND (STJ.TJ_SITUACA = 'P' OR STJ.TJ_SITUACA = 'L')"
	cQuery += " AND STJ.D_E_L_E_T_ = ' '"
	cQuery += " AND STJ.TJ_FILIAL = '" + xFilial("STJ") + "'"

	//Alteração da Query do filtro de OS's para adicionar os filhos do bem no filtro.
	cQuery := fAddFBem(cQuery)

	//Ponto de entrada para alteração da Query do filtro de OS's.
	If lMNTA9909
		cQuery := ExecBlock("MNTA9909",.F.,.F.,{cQuery})
	EndIf

	cQuery += " ORDER BY STJ.TJ_PRIORID DESC, STJ.TJ_DTMPINI, STJ.TJ_ORDEM"
	cQuery := ChangeQuery(cQuery)
	c990STJTMP := GetNextAlias()
	dbUseArea( .T., "TOPCONN", TCGenQry(,,cQuery), c990STJTMP, .F., .T.)

	nSeqSTJ := 0
	cChaveSTJ := ""
	
	If ( INCLUI .And. nPrimParam > 0 ) .Or. ALTERA

		/*---------------------------------------------------------------------------------------+
		| Realiza deleção dos registros de tabelas temporárias para o processo de reprogramação. |
		+---------------------------------------------------------------------------------------*/
		fDelOSProg( lRefaz := MsgYesNo( STR0314 ) ) // Deseja reprogramar os O.S. ja programadas ?
		
	EndIf

	nPrimParam ++
	dbSelectArea(c990STJTMP)
	ProcRegua(LastRec())
	dbGoTop()
	While !EoF()
		If cChaveSTJ <> (c990STJTMP)->TJ_ORDEM + (c990STJTMP)->TJ_PLANO
			dbSelectArea(c990TRB2)
			dbSetOrder(3)
			dbGoTop()
			If dbSeek( (c990STJTMP)->TJ_ORDEM + (c990STJTMP)->TJ_PLANO )
				dbSelectArea(c990STJTMP)
				(c990STJTMP)->(dbSkip())
				Loop
			EndIf

			dbSelectArea("ST9")
			dbSetOrder(1)
			dbSeek(xFilial("ST9")+(c990STJTMP)->TJ_CODBEM)

			If lCpoFamB
				If ST9->T9_CODFAMI > M->TT1_FAMATE .OR. ST9->T9_CODFAMI < M->TT1_FAMDE
					dbSelectArea(c990STJTMP)
					(c990STJTMP)->(dbSkip())
					Loop
				EndIf
			EndIf
			If lCpoContPr
				If ST9->T9_PRIORID > M->TT1_PRIATE .Or. ST9->T9_PRIORID < M->TT1_PRIDE
					dbSelectArea(c990STJTMP)
					(c990STJTMP)->(dbSkip())
					Loop
				EndIf
			EndIf
			If (c990STJTMP)->TJ_PLANO <> "000000" .And. M->TT1_QTDDIA <>  9999
				dbSelectArea("ST9")
				dbSetOrder(1)
				If dbSeek(xFilial("ST9")+(c990STJTMP)->TJ_CODBEM)
					nVardiC := ST9->T9_VARDIA
				EndIf
				dbSelectArea("STF")
				dbSetOrder(1)
				If dbSeek(xFilial("STF")+(c990STJTMP)->TJ_CODBEM+(c990STJTMP)->TJ_SERVICO+(c990STJTMP)->TJ_SEQRELA)
					If STF->TF_TIPACOM $ "A/T"
						If STF->TF_UNENMAN == "H"
							nIncMan := STF->TF_TEENMAN/24
						ElseIf STF->TF_UNENMAN == "D"
							nIncMan := STF->TF_TEENMAN
						ElseIf STF->TF_UNENMAN == "S"
							nIncMan := STF->TF_TEENMAN * 7
						Else
							nIncMan := STF->TF_TEENMAN * 30
						EndIf
						If STF->TF_TIPACOM = "A"
							nIncMan := STF->TF_INENMAN/nVardiC
						EndIf
					ElseIf STF->TF_TIPACOM == "C"
						nIncMan := STF->TF_INENMAN/nVardiC
					EndIf
					If M->TT1_INCRE == "1" .And.  nIncMan <> M->TT1_QTDDIA
						dbSelectArea(c990STJTMP)
						(c990STJTMP)->(dbSkip())
						Loop
					ElseIf M->TT1_INCRE == "2" .And.  nIncMan >= M->TT1_QTDDIA
						dbSelectArea(c990STJTMP)
						(c990STJTMP)->(dbSkip())
						Loop
					ElseIf M->TT1_INCRE == "3" .And.  nIncMan >= M->TT1_QTDDIA
						dbSelectArea(c990STJTMP)
						(c990STJTMP)->(dbSkip())
						Loop
					ElseIf M->TT1_INCRE == "4" .And.  nIncMan <= M->TT1_QTDDIA
						dbSelectArea(c990STJTMP)
						(c990STJTMP)->(dbSkip())
						Loop
					ElseIf M->TT1_INCRE == "5" .And.  nIncMan < M->TT1_QTDDIA
						dbSelectArea(c990STJTMP)
						(c990STJTMP)->(dbSkip())
						Loop
					EndIf
				EndIf
			EndIf
			If !lRefaz
				dbSelectArea(c990TRB3)
				dbSetOrder(3)
				If dbSeek((c990STJTMP)->TJ_ORDEM+(c990STJTMP)->TJ_PLANO)
					dbSelectArea(c990STJTMP)
					(c990STJTMP)->(dbSkip())
					Loop
				EndIf

				dbSelectArea(c990TRB2)
				dbSetOrder(3)
				If dbSeek((c990STJTMP)->TJ_ORDEM+(c990STJTMP)->TJ_PLANO)
					dbSelectArea(c990STJTMP)
					(c990STJTMP)->(dbSkip())
					Loop
				EndIf
			EndIf

			nSeqSTJ++
			(c990TRB1)->(dbAppend())
			(c990TRB1)->SEQUENC := StrZero(nSeqSTJ,5)
			(c990TRB1)->PRIORID := (c990STJTMP)->TJ_PRIORID
			If Type((c990STJTMP)->TJ_PRIORID) == 'N'
				(c990TRB1)->PRIOINV := (Val((c990STJTMP)->TJ_PRIORID) * -1)
			Else
				(c990TRB1)->PRIOINV := 0
			EndIf
			(c990TRB1)->ORDEM   := (c990STJTMP)->TJ_ORDEM
			(c990TRB1)->PLANO   := (c990STJTMP)->TJ_PLANO
			(c990TRB1)->CODBEM  := (c990STJTMP)->TJ_CODBEM
			(c990TRB1)->SEQRELA := (c990STJTMP)->TJ_SEQRELA
			(c990TRB1)->DTORIGI := SToD( (c990STJTMP)->TJ_DTORIGI )
			(c990TRB1)->HOMPINI := (c990STJTMP)->TJ_HOMPINI
			(c990TRB1)->DTMPFIM := SToD( (c990STJTMP)->TJ_DTMPFIM )
			(c990TRB1)->HOMPFIM := (c990STJTMP)->TJ_HOMPFIM
			(c990TRB1)->REALIZA := '0'

			If (c990STJTMP)->TJ_TIPOOS == "B"
				(c990TRB1)->DESCRIC := ST9->T9_NOME
			Else
				(c990TRB1)->DESCRIC := NGSEEK("TAF","X2"+Substr((c990STJTMP)->TJ_CODBEM,1,3),7,"TAF_NOMNIV")
			EndIf
			(c990TRB1)->CODSER  := (c990STJTMP)->TJ_SERVICO
			(c990TRB1)->DESSER  := NGSEEK("ST4", (c990STJTMP)->TJ_SERVICO ,1,"ST4->T4_NOME")
			If lTJ_EQUIPE
				(c990TRB1)->EQUIPE := (c990STJTMP)->TJ_EQUIPE
			ElseIf lTJ_XEQUIPE
				(c990TRB1)->EQUIPE := (c990STJTMP)->TJ_XEQUIPE
			EndIf

			If lTJ_STFOLUP
				(c990TRB1)->XSTATUS := (c990STJTMP)->TJ_STFOLUP
			ElseIf lTJ_STATUS
				(c990TRB1)->XSTATUS := (c990STJTMP)->TJ_STATUS
			ElseIf lTJ_XMOTIVO
				(c990TRB1)->XSTATUS := (c990STJTMP)->TJ_XMOTIVO
			ElseIf lTJ_XSTATUS
				(c990TRB1)->XSTATUS := (c990STJTMP)->TJ_XSTATUS
			EndIf
			(c990TRB1)->DTMPINI := SToD((c990STJTMP)->TJ_DTMPINI)
			If lCpoTT2Dt
				(c990TRB1)->DTMPROG := SToD("")
			EndIf
			(c990TRB1)->SITUACA := (c990STJTMP)->TJ_SITUACA
			//Ponto de entrada para alimentar os campos criado pelo ponto de entrada MNTA9902
			If lMNTA9904
				ExecBlock("MNTA9904",.F.,.F.,{c990TRB1,c990STJTMP})
			EndIf

			cChaveSTJ := (c990STJTMP)->TJ_ORDEM + (c990STJTMP)->TJ_PLANO
		EndIf

		// Somente ordens de serviço que possuam insumos.
		If !Empty( (c990STJTMP)->TL_ORDEM )

			// Inclui registros na tabela temporária de insumos, resultantes da query.
			fInsertSTL( (c990STJTMP)->TL_FILIAL + (c990STJTMP)->TL_ORDEM + (c990STJTMP)->TL_PLANO + (c990STJTMP)->TL_TAREFA +;
				(c990STJTMP)->TL_TIPOREG + (c990STJTMP)->TL_CODIGO + (c990STJTMP)->TL_SEQRELA + (c990STJTMP)->TL_SEQTARE )

		EndIf

		nSeqSTJ := -1
		If NgVerify("STL")
			nSeqSTJ := Val((c990STJTMP)->TL_SEQRELA)
		Else
			nSeqSTJ := (c990STJTMP)->TL_SEQUENC
		EndIf

		If nSeqSTJ <> 0

			dbSelectArea(c990TRB1)
			dbSetOrder(3)
			dbGoTop()
			If dbSeek(cChaveSTJ)
				(c990TRB1)->REALIZA := "1"
			EndIf

			dbSelectArea(c990STJTMP)
			(c990STJTMP)->(dbSkip())
			Loop
		
		EndIf

		If (c990STJTMP)->TL_TIPOREG == "P"
			If SToD((c990STJTMP)->TL_DTINICI) > M->TT1_DTATE .OR. SToD((c990STJTMP)->TL_DTINICI) < M->TT1_DTDE
				dbSelectArea(c990STJTMP)
				(c990STJTMP)->(dbSkip())
				Loop
			EndIf
		Else
			If SToD((c990STJTMP)->TL_DTINICI) > M->TT1_DTATE .OR. SToD((c990STJTMP)->TL_DTFIM) < M->TT1_DTDE
				dbSelectArea(c990STJTMP)
				(c990STJTMP)->(dbSkip())
				Loop
			EndIf
		EndIf

		dbSelectArea(c990STJTMP)
		(c990STJTMP)->(dbSkip())
	End

	(c990STJTMP)->( dbCloseArea() )

	dbSelectArea(c990TRB1)
	dbSetOrder(nTipoInd)
	dbGoTop()
	dbSelectArea(c990TRB2)
	dbSetOrder(nTipoInd)
	dbGoTop()
	dbSelectArea(c990TRB3)
	dbSetOrder(nTipoInd)
	dbGoTop()

	oMARK1:Refresh()
	oMARK2:Refresh()

	//Verifica o parametro de progrmacao automatica.
	fProgAuto( 1, nOSPrInd )

	RestArea( aArea )

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MntMark1Os


@sample
MntMark1Os(cMarca,lInverte,nTipo)

@author Denis Hyroshi de Souza
@since 12/11/2007
@version 1.0
/*/
//---------------------------------------------------------------------
Function MntMark1Os(cMarca,lInverte,nTipo)
	Local aArea := GetArea()

	If nTipo == 1
		If (c990TRB1)->(RecCount()) > 0 .And. (c990TRB1)->(!EoF())
			RecLock((c990TRB1), .F.)
				(c990TRB1)->MARCADO := IF((c990TRB1)->MARCADO == "  ",cMARCA,"  ")
			MsUnlock()
		EndIf
	Else
		If (c990TRB3)->(RecCount()) > 0 .And. (c990TRB3)->(!EoF())
			RecLock((c990TRB3), .F.)
			(c990TRB3)->MARCADO := IF((c990TRB3)->MARCADO == "  ",cMARCA,"  ")
			MsUnlock()
			dbSelectArea(c990TRB2)
			dbSetOrder(3)
			dbGoTop()
			If dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO )
				RecLock((c990TRB2), .F.)
					(c990TRB2)->MARCADO := IF((c990TRB2)->MARCADO == "  ",cMARCA,"  ")
				MsUnlock()
			EndIf
		EndIf
	EndIf

	RestArea(aArea)
Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MntAllOS1
Inverte a marcacao do browse

@sample
MntAllOS1(_Objeto,_nColHead,cMarca,nTipo)

@author Denis Hyroshi de Souza
@since 12/11/2007
@version 1.0
/*/
//---------------------------------------------------------------------
Function MntAllOS1(_Objeto,_nColHead,cMarca,nTipo)
	Local aArea := GetArea()

	If _nColHead <> 1
		Return
	EndIf

	If nTipo == 1
		dbSelectArea(c990TRB1)
		dbSetOrder(nTipoInd)
		dbGoTop()
		While !EoF()
			If lAltProg
				(c990TRB1)->MARCADO := IF((c990TRB1)->MARCADO == "  ",cMARCA,"  ")
			Else
				(c990TRB1)->MARCADO := IF((c990TRB1)->MARCADO != "  ",cMARCA,"  ")
			EndIf
			dbSkip()
		End
		dbGoTop()
		oMARK1:Refresh()
	Else
		dbSelectArea(c990TRB3)
		dbSetOrder(nTipoInd)
		dbGoTop()
		While !EoF()
			If lAltProg
				(c990TRB3)->MARCADO := IF((c990TRB3)->MARCADO == "  ",cMARCA,"  ")
				dbSelectArea(c990TRB2)
				dbSetOrder(3)
				dbGoTop()
				If dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO )
					(c990TRB2)->MARCADO := IF((c990TRB2)->MARCADO == "  ",cMARCA,"  ")
				EndIf
			Else
				(c990TRB3)->MARCADO := IF((c990TRB3)->MARCADO != "  ",cMARCA,"  ")
				dbSelectArea(c990TRB2)
				dbSetOrder(3)
				dbGoTop()
				If dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO )
					(c990TRB2)->MARCADO := IF((c990TRB2)->MARCADO != "  ",cMARCA,"  ")
				EndIf
			EndIf
			dbSelectArea(c990TRB3)
			dbSkip()
		End
		dbGoTop()
		oMARK2:Refresh()
	EndIf

	RestArea(aArea)
Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} fVisualOS
Visualizar OS do markbrowse esquerdo

@sample
fVisualOS(nTipo)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fVisualOS(nTipo)
	Local aArea := GetArea()
	Local aOldNgBtn := IIf( Type( "aNgButton" ) == "A", aNgButton, {} )
	Local lBkpInclui := INCLUI
	Local lBkpAltera := ALTERA
	Private aNgButton := {}

	//Variaveis Usada para visualizar a O.S.
	Private TIPOACOM := .F.
	Private TIPOACOM2 := .F.
	Private lSITUACA  := .F.
	If nTipo == 1
		If (c990TRB1)->(EoF())
			If lAltProg
				Help(" ",1,"NGATENCAO",,STR0113,3,1) //"Arquivo vazio!"
			EndIf
			Return .F.
		EndIf
	Else
		If (c990TRB3)->(EoF())
			If lAltProg
				Help(" ",1,"NGATENCAO",,STR0113,3,1) //"Arquivo vazio!"
			EndIf
			Return .F.
		EndIf
	EndIf

	dbSelectArea("STJ")
	dbSetOrder(1)
	If dbSeek(xFilial("STJ")+ If( nTipo == 1, (c990TRB1)->ORDEM+(c990TRB1)->PLANO, (c990TRB3)->ORDEM+(c990TRB3)->PLANO ) )
		If ExistBlock("MNTA990E")
			aNgButton := ExecBlock( "MNTA990E", .F., .F. )
		EndIf
		NgCad01("STJ",STJ->(Recno()),2)
	EndIf

	aNgButton := aOldNgBtn
	
	//A visualzação de O.S. remove essas variaveis.
	INCLUI := lBkpInclui
	ALTERA := lBkpAltera

	RestArea(aArea)
Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fMsgSemSTL
Pergunta ao usuario se deseja utilizar a OS sem Insumo

@sample
fMsgSemSTL(cNumOS)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fMsgSemSTL(cNumOS)
	Local lRet    := .F.
	Local lUmaVez := .F., oCheck, oDLG11, oBtnNao, oBtnSim

	If ValType(lReplAll) == "L"
		lRet := lReplAll
	Else
		DEFINE MSDIALOG oDLG11 FROM  0,0 TO 130,430 TITLE OemtoAnsi(STR0247) PIXEL //"Atenção"
		oDLG11:LESCCLOSE := .F.

		@ 10,5 SAY STR0248 + cNumOS + STR0249 OF oDLG11 PIXEL //"A Ordem de Serviço "###" não possui insumo previsto."
		@ 19,5 SAY STR0250 OF oDLG11 PIXEL //"Deseja programá-la assim mesmo?"

		@ 35,135 Button oBtnSim PROMPT STR0251 Size 30,10 Action (lRet := .T.,oDLG11:END()) Of oDLG11 Pixel //"Sim"
		@ 35,170 Button oBtnNao PROMPT STR0252 Size 30,10 Action (lRet := .F.,oDLG11:END()) Of oDLG11 Pixel //"Não"

		@ 48,005 CheckBox oCheck Var lUmaVez Prompt ;
		STR0253 Size 220,7 Of oDLG11 Pixel //"Deseja aplicar esta resposta a todas as Ordens de Serviço sem insumo previsto?"

		ACTIVATE MSDIALOG oDLG11 CENTERED

		If lUmaVez
			lReplAll := .T.
			lDefRet := lRet
		EndIf

	EndIf

Return lRet

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fPassRight
Passa a O.S. do markBrowse de ordens à programar para ordens em programação.
@type function

@author Alexandre Santos
@since 25/09/2019
@sample fPassRight( 1 )

@param nType, Númerico, Tipo de operação: 1 - Ordens Marcadas / 2 - Todas as O.S.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fPassRight( nType )

	Local nIndex    := 0
	Local lExit     := .F.
	Local lReload   := .F.
	Local aDtOS     := {}
	Local aMNTA9906 := {}
	Local cError    := ''

	// Indica se a programação pode ser alterada
	If lAltProg

		If ( c990TRB1 )->( EoF() )

			Help( '', 1, 'NGATENCAO', , STR0113, 3, 1 ) // Arquivo vazio!

		Else

			If ( _dDiaAtu < dTT1_DTPROG .Or. _dDiaAtu > dTT1_DTFIM ) .And. lPrgDiaria

				Help( '', 1, 'NGATENCAO', , STR0136 + Chr( 13 ) + Chr( 10 ) +; // A data prevista deve estar no período da Programação.
					STR0240 + dToC( dTT1_DTPROG ) + ' à ' + dToC( dTT1_DTFIM ) , 3 , 1 ) // Período: De

			Else

				If !Empty( cEventoOS ) .And. lPrgEvento

					dbSelectArea( 'TTQ' )
					dbSetOrder( 1 ) // TTQ_FILIAL + TTQ_CODIGO
					If dbSeek( xFilial( 'TTQ' ) + cEventoOS )

						If _dDiaAtu < TTQ->TTQ_DTINI .Or. _dDiaAtu > TTQ->TTQ_DTFIM

							Help( '', 1, 'NGATENCAO', , STR0231 + Chr( 13 ) + ; // Não pode ser programada uma OS para
								STR0232 + Chr( 13 ) + ; // uma data diferente do período do Evento.
								STR0233 + dToC( TTQ->TTQ_DTINI ) + Chr( 13 ) + ; // Data Inicial do Evento:
								STR0234 + dToC( TTQ->TTQ_DTFIM ), 3, 1 ) // Data Final do Evento:

							lExit := .T.

						EndIf

					Else

						Help( '', 1, 'NGATENCAO', , STR0235, 3, 1 ) // Evento inválido.
						lExit := .T.

					EndIf

				EndIf

				If !lExit

					// Botão next
					If nType == 1

						dbSelectArea(c990TRB2)
						dbSetOrder(nTipoInd)
						dbGoBottom()
						cUltSeq := (c990TRB2)->SEQUENC

						dbSelectArea( c990TRB1 )
						dbSetOrder( 2 ) // MARCADO
						If dbSeek( cMARCA )

							Do While (c990TRB1)->( !EoF() ) .And. cMARCA == (c990TRB1)->MARCADO

								aDtOS := { cToD( '' ), '', cToD( '' ), '' }

								/*--------------------------------------------------+
								| Valida a alteração de datas referente aos insumos |
								+--------------------------------------------------*/
								If !fVldInsum( (c990TRB1)->ORDEM, (c990TRB1)->PLANO, _dDiaAtu, @cError )
								
									/*----------------------------------------------------------------+
									| Em caso de indisponibilidade de calendário, não programa a O.S. |
									+----------------------------------------------------------------*/
									(c990TRB1)->( dbSkip() )
									Loop

								EndIf

								lReload := .T.
							
								/*-------------------------------------------+
								| Atualização de datas referente aos insumos |
								+-------------------------------------------*/
								fUpdInsum( (c990TRB1)->ORDEM, (c990TRB1)->PLANO, _dDiaAtu, @aDtOS )

								// Caso não exista insumo na O.S. assume-se a nova data, já horarios da ordem se mantem
								If Empty( aDtOS[1] )

									aDtOS := { _dDiaAtu, (c990TRB1)->HOMPINI, _dDiaAtu, (c990TRB1)->HOMPFIM }

								EndIf

								dbSelectArea( 'STL' )
								dbSetOrder( 4 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TIPOREG + TL_CODIGO
								If !dbSeek( xFilial( 'STL' ) + (c990TRB1)->ORDEM + (c990TRB1)->PLANO )

									If !lReplAll//Pergunta ao usuario se deseja utilizar a OS sem Insumo
										If !fMsgSemSTL((c990TRB1)->ORDEM)
											dbSelectArea(c990TRB1)
											dbSkip()
											Loop
										EndIf
									Else //Não Pergunta ao usuario se deseja utilizar a OS sem Insumo e usa a resposta padrão
										If !lDefRet
											dbSelectArea(c990TRB1)
											dbSkip()
											Loop
										EndIf
									EndIf
								EndIf

								cUltSeq := Soma1( cUltSeq )
								dbSelectArea( c990TRB2 )
								RecLock( (c990TRB2), .T. )

								For nIndex := 1 To Len( aTRB1 )

									(c990TRB2)->&( aTRB1[nIndex,1] ) := (c990TRB1)->&( aTRB1[nIndex,1] )

								Next nIndex

								If Type((c990TRB1)->PRIORID) == 'N'
									(c990TRB2)->PRIOINV := (Val((c990TRB1)->PRIORID) * -1)
								Else
									(c990TRB2)->PRIOINV := 0
								EndIf

								(c990TRB2)->MARCADO := (c990TRB1)->MARCADO
								(c990TRB2)->SEQUENC := cUltSeq
								(c990TRB2)->SITUACA := (c990TRB1)->SITUACA
								(c990TRB2)->REALIZA := (c990TRB1)->REALIZA
								(c990TRB2)->PLANO   := (c990TRB1)->PLANO
								(c990TRB2)->SEQRELA := (c990TRB1)->SEQRELA
								(c990TRB2)->EQUIPE  := (c990TRB1)->EQUIPE
								(c990TRB2)->DTORIGI := aDtOS[1]
								(c990TRB2)->DTMPROG := aDtOS[1]
								(c990TRB2)->DTMPINI := aDtOS[1]
								(c990TRB2)->HOMPINI := aDtOS[2]
								(c990TRB2)->DTMPFIM := aDtOS[3]
								(c990TRB2)->HOMPFIM := aDtOS[4]

								If !Empty( cStProg990 )

									(c990TRB2)->XSTATUS := cStProg990
									(c990TRB2)->LIBERA  := '1'

								EndIf

								If !Empty( cEventoOS )

									(c990TRB2)->EVENTO  := cEventoOS

								EndIf

								// P.E. que atribui conteúdo aos campos de usuário criados pelo P.E. MNTA9902.
								If lMNTA9906 .And. ValType( aMNTA9906 := ExecBlock( 'MNTA9906', .F., .F., { c990TRB2, aDBFa } ) ) == 'A'

									For nIndex := 1 To Len( aMNTA9906 )

										// Valida a existência do campo na tabela temporária.
										If (c990TRB2)->( FieldPos( aMNTA9906[nIndex,1] ) ) > 0
											(c990TRB2)->&( aMNTA9906[nIndex,1] ) := aMNTA9906[nIndex,2]
										EndIf

									Next nIndex

								EndIf

								(c990TRB2)->( MsUnLock() )

								dbSelectArea( c990TRB3 )
								RecLock( (c990TRB3), .T. )

								For nIndex := 1 To Len( aTRB1 )

									(c990TRB3)->&( aTRB1[nIndex,1] ) := (c990TRB1)->&( aTRB1[nIndex,1] )

								Next nIndex

								If Type((c990TRB1)->PRIORID) == 'N'
									(c990TRB3)->PRIOINV := (Val((c990TRB1)->PRIORID) * -1)
								Else
									(c990TRB3)->PRIOINV := 0
								EndIf		
								(c990TRB3)->MARCADO := (c990TRB1)->MARCADO
								(c990TRB3)->SITUACA := (c990TRB1)->SITUACA
								(c990TRB3)->REALIZA := (c990TRB1)->REALIZA
								(c990TRB3)->PLANO   := (c990TRB1)->PLANO
								(c990TRB3)->SEQRELA := (c990TRB1)->SEQRELA
								(c990TRB3)->EQUIPE  := (c990TRB1)->EQUIPE
								(c990TRB3)->DTORIGI := aDtOS[1]
								(c990TRB3)->DTMPINI := aDtOS[1]
								(c990TRB3)->DTMPROG := aDtOS[1]
								(c990TRB3)->HOMPINI := aDtOS[2]
								(c990TRB3)->DTMPFIM := aDtOS[3]
								(c990TRB3)->HOMPFIM := aDtOS[4]

								If !Empty( cStProg990 )

									(c990TRB3)->XSTATUS := cStProg990
									(c990TRB3)->LIBERA  := '1'

									If _dDiaAtu < dTT1_DTPROG

										dTT1_DTPROG := _dDiaAtu

									EndIf

									If _dDiaAtu > dTT1_DTFIM

										dTT1_DTFIM := _dDiaAtu

									EndIf

								Else

									If lCpoTT2Dt

										If _dDiaAtu < dTT1_DTPROG

											dTT1_DTPROG := _dDiaAtu

										EndIf

										If _dDiaAtu > dTT1_DTFIM

											dTT1_DTFIM := _dDiaAtu

										EndIf

									EndIf

								EndIf

								If !Empty( cEventoOS )

									(c990TRB3)->EVENTO  := cEventoOS

								EndIf

								// P.E. que atribui conteúdo aos campos de usuário criados pelo P.E. MNTA9902.
								If lMNTA9906 .And. ValType( aMNTA9906 := ExecBlock( 'MNTA9906', .F., .F., { c990TRB3, aDBFa } ) ) == 'A'

									For nIndex := 1 To Len( aMNTA9906 )

										// Valida a existência do campo na tabela temporária.
										If (c990TRB3)->( FieldPos( aMNTA9906[nIndex,1] ) ) > 0
											(c990TRB3)->&( aMNTA9906[nIndex,1] ) := aMNTA9906[nIndex,2]
										EndIf

									Next nIndex

								EndIf

								(c990TRB3)->( MsUnLock() )

								// Deleta registro da tabela temporária de O.S. à programar.
								dbSelectArea( c990TRB1 )
								RecLock( c990TRB1, .F. )
								dbDelete()
								(c990TRB1)->( MsUnLock() )

								(c990TRB1)->( dbSkip() )

							EndDo

						EndIf

						dbSelectArea( c990TRB1 )
						dbSetOrder( nTipoInd )

					// Botão all next
					Else

						dbSelectArea( c990TRB2 )
						dbSetOrder( nTipoInd )
						dbGoBottom()
						cUltSeq := (c990TRB2)->SEQUENC

						dbSelectArea( c990TRB1 )
						dbSetOrder( nTipoInd )
						dbGoTop()
						Do While (c990TRB1)->( !EoF() )

							aDtOS := { cToD( '' ), '', cToD( '' ), '' }

							/*--------------------------------------------------+
							| Valida a alteração de datas referente aos insumos |
							+--------------------------------------------------*/
							If !fVldInsum( (c990TRB1)->ORDEM, (c990TRB1)->PLANO, _dDiaAtu, @cError )
								
								/*----------------------------------------------------------------+
								| Em caso de indisponibilidade de calendário, não programa a O.S. |
								+----------------------------------------------------------------*/
								(c990TRB1)->( dbSkip() )
								Loop

							EndIf

							lReload := .T.
							
							/*-------------------------------------------+
							| Atualização de datas referente aos insumos |
							+-------------------------------------------*/
							fUpdInsum( (c990TRB1)->ORDEM, (c990TRB1)->PLANO, _dDiaAtu, @aDtOS )

							// Caso não exista insumo na O.S. assume-se a nova data, já horarios da ordem se mantem
							If Empty( aDtOS[1] )

								aDtOS := { _dDiaAtu, (c990TRB1)->HOMPINI, _dDiaAtu, (c990TRB1)->HOMPFIM }

							EndIf

							dbSelectArea( 'STL' )
							dbSetOrder( 4 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TIPOREG + TL_CODIGO
							If !dbSeek( xFilial( 'STL' ) + (c990TRB1)->ORDEM + (c990TRB1)->PLANO )

								If !lReplAll//Pergunta ao usuario se deseja utilizar a OS sem Insumo
									If !fMsgSemSTL((c990TRB1)->ORDEM)
										dbSelectArea(c990TRB1)
										dbSkip()
										Loop
									EndIf
								Else //Não Pergunta ao usuario se deseja utilizar a OS sem Insumo e usa a resposta padrão
									If !lDefRet
										dbSelectArea(c990TRB1)
										dbSkip()
										Loop
									EndIf
								EndIf

							EndIf

							cUltSeq := Soma1( cUltSeq )
							dbSelectArea( c990TRB2 )
							RecLock( (c990TRB2), .T. )

							For nIndex := 1 To Len( aTRB1 )

								(c990TRB2)->&( aTRB1[nIndex,1] ) := (c990TRB1)->&( aTRB1[nIndex,1] )

							Next nIndex

							If Type((c990TRB1)->PRIORID) == 'N'
								(c990TRB2)->PRIOINV := (Val((c990TRB1)->PRIORID) * -1)
							Else
								(c990TRB2)->PRIOINV := 0
							EndIf
							(c990TRB2)->MARCADO := '  '
							(c990TRB2)->SEQUENC := cUltSeq
							(c990TRB2)->SITUACA := (c990TRB1)->SITUACA
							(c990TRB2)->REALIZA := (c990TRB1)->REALIZA
							(c990TRB2)->PLANO   := (c990TRB1)->PLANO
							(c990TRB2)->SEQRELA := (c990TRB1)->SEQRELA
							(c990TRB2)->EQUIPE  := (c990TRB1)->EQUIPE
							(c990TRB2)->DTORIGI := aDtOS[1]
							(c990TRB2)->DTMPROG := aDtOS[1]
							(c990TRB2)->DTMPINI := aDtOS[1]
							(c990TRB2)->HOMPINI := aDtOS[2]
							(c990TRB2)->DTMPFIM := aDtOS[3]
							(c990TRB2)->HOMPFIM := aDtOS[4]

							If !Empty( cStProg990 )

								(c990TRB2)->XSTATUS := cStProg990
								(c990TRB2)->LIBERA  := '1'

							EndIf

							If !Empty( cEventoOS )

								(c990TRB2)->EVENTO  := cEventoOS

							EndIf

							// P.E. que atribui conteúdo aos campos de usuário criados pelo P.E. MNTA9902.
							If lMNTA9906 .And. ValType( aMNTA9906 := ExecBlock( 'MNTA9906', .F., .F., { c990TRB2, aDBFa } ) ) == 'A'

								For nIndex := 1 To Len( aMNTA9906 )

									// Valida a existência do campo na tabela temporária.
									If (c990TRB2)->( FieldPos( aMNTA9906[nIndex,1] ) ) > 0
										(c990TRB2)->&( aMNTA9906[nIndex,1] ) := aMNTA9906[nIndex,2]
									EndIf

								Next nIndex

							EndIf

							(c990TRB2)->( MsUnLock() )

							dbSelectArea( c990TRB3 )
							RecLock( (c990TRB3), .T. )

							For nIndex := 1 To Len( aTRB1 )

								(c990TRB3)->&( aTRB1[nIndex,1] ) := (c990TRB1)->&( aTRB1[nIndex,1] )

							Next nIndex

							If Type((c990TRB1)->PRIORID) == 'N'
								(c990TRB3)->PRIOINV := (Val((c990TRB1)->PRIORID) * -1)
							Else
								(c990TRB3)->PRIOINV := 0
							EndIf
							(c990TRB3)->MARCADO := '  '
							(c990TRB3)->SITUACA := (c990TRB1)->SITUACA
							(c990TRB3)->SITUACA := (c990TRB1)->SITUACA
							(c990TRB3)->REALIZA := (c990TRB1)->REALIZA
							(c990TRB3)->PLANO   := (c990TRB1)->PLANO
							(c990TRB3)->SEQRELA := (c990TRB1)->SEQRELA
							(c990TRB3)->EQUIPE  := (c990TRB1)->EQUIPE
							(c990TRB3)->SEQUENC := cUltSeq
							(c990TRB3)->DTORIGI := aDtOS[1]
							(c990TRB3)->DTMPINI := aDtOS[1]
							(c990TRB3)->DTMPROG := aDtOS[1]
							(c990TRB3)->HOMPINI := aDtOS[2]
							(c990TRB3)->DTMPFIM := aDtOS[3]
							(c990TRB3)->HOMPFIM := aDtOS[4]

							If !Empty( cStProg990 )

								(c990TRB3)->XSTATUS := cStProg990
								(c990TRB3)->LIBERA  := '1'

								If _dDiaAtu < dTT1_DTPROG

									dTT1_DTPROG := _dDiaAtu

								EndIf

								If _dDiaAtu > dTT1_DTFIM

									dTT1_DTFIM := _dDiaAtu

								EndIf

							Else

								If lCpoTT2Dt


									If _dDiaAtu < dTT1_DTPROG

										dTT1_DTPROG := _dDiaAtu

									EndIf

									If _dDiaAtu > dTT1_DTFIM

										dTT1_DTFIM := _dDiaAtu

									EndIf

								EndIf

							EndIf

							If !Empty( cEventoOS )

								(c990TRB3)->EVENTO  := cEventoOS

							EndIf

							// P.E. que atribui conteúdo aos campos de usuário criados pelo P.E. MNTA9902.
							If lMNTA9906 .And. ValType( aMNTA9906 := ExecBlock( 'MNTA9906', .F., .F., { c990TRB3, aDBFa } ) ) == 'A'

								For nIndex := 1 To Len( aMNTA9906 )

									// Valida a existência do campo na tabela temporária.
									If (c990TRB3)->( FieldPos( aMNTA9906[nIndex,1] ) ) > 0
										(c990TRB3)->&( aMNTA9906[nIndex,1] ) := aMNTA9906[nIndex,2]
									EndIf

								Next nIndex

							EndIf

							(c990TRB3)->( MsUnLock() )

							// Deleta registro da tabela temporária de O.S. à programar
							dbSelectArea( c990TRB1 )
							RecLock( c990TRB1, .F. )
							dbDelete()
							(c990TRB1)->( MsUnLock() )

							(c990TRB1)->( dbSkip() )

						EndDo

					EndIf

					If !Empty( cError )

						NGMSGMEMO( STR0285,; // ATENÇÃO
							STR0355 + CRLF + CRLF + cError ) // Não existe disponibilidade de calendário para os funcionários listados abaixo: 

					EndIf

					If lReload

						// Atualiza registros da O.S. em folders e markbrowse para a nova data
						Processa( { |lEND| fPrgChgDia( 2 ) }, STR0046 ) // Atualizando Calendário...

						// Atualiza legenda do calendário
						Processa( { |lEND| fPrgChgMes( 1, @oCalend ) }, STR0046 ) // Atualizando Calendário...

					EndIf

				EndIf

			EndIf

		EndIf

	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fPassaEsq
Passa a OS para  markbrowse esquerdo

@sample fPassaEsq(nTipo)

@param nTipo, Numerico, Tipo de operação.
@return

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fPassaEsq(nTipo)

	Local nX        := 0
	Local nTRB      := 0
	Local dDtMaior  := SToD("")
	Local dDtMenor  := SToD("")
	Local lMNTA990D	:= ExistBlock("MNTA990D")
	Local lMNTA9905	:= ExistBlock( 'MNTA9905' )
	Local cAgruOS   := ''
	Local nLoop     := 1

	If lAltProg

		If (c990TRB3)->(EoF())
			Help(" ",1,"NGATENCAO",,STR0113,3,1) //"Arquivo vazio!"
			Return .F.
		EndIf

		//Se botao prev
		If nTipo == 1

			dbSelectArea(c990TRB3)
			dbSetOrder(2)
			dbGoTop()
			dbSeek(cMARCA)
			ProcRegua((c990TRB3)->(RecCount()))
			While !EoF() .And. cMARCA == (c990TRB3)->MARCADO
				IncProc()

				If lMNTA990D
					If !ExecBlock("MNTA990D",.F.,.F.,{(c990TRB3)->ORDEM,(c990TRB3)->DTMPINI})
						Alert( STR0317+AllTrim((c990TRB3)->ORDEM)+STR0318 ) //"A ordem de serviço: 'x' não pode ser alterada sua data, pois contém insumo(s) aplicado(s)."
						Return .F.
					EndIf
				Else
					If (c990TRB3)->REALIZA > "0" //Se insumo aplicado.
						Alert( STR0317+AllTrim((c990TRB3)->ORDEM)+STR0318 ) //"A ordem de serviço: 'x' não pode ser alterada sua data, pois contém insumo(s) aplicado(s)."
						Return .F.
					EndIf
				EndIf


				//Excluindo Produtos da Ordem
				nPosIni := aScan(aList3 ,{|x| x[1] == (c990TRB3)->ORDEM })
				If nPosIni > 0
					aExclui := {}
					For nX := nPosIni to Len(aList3)
						If (c990TRB3)->ORDEM <> aList3[nX,1]
							Exit
						EndIf
						aAdd(aExclui,nX)
					Next nX
					For nX := Len(aExclui) to 1 Step -1
						Adel(aList3,aExclui[nX])
						Asize(aList3,Len(aList3)-1)
					Next nX
				EndIf

				//Excluindo Ferramentas da Ordem
				nPosIni := aScan(aList4 ,{|x| x[1] == (c990TRB3)->ORDEM })
				If nPosIni > 0
					aExclui := {}
					For nX := nPosIni to Len(aList4)
						If (c990TRB3)->ORDEM <> aList4[nX,1]
							Exit
						EndIf
						aAdd(aExclui,nX)
					Next nX
					For nX := Len(aExclui) to 1 Step -1
						Adel(aList4,aExclui[nX])
						Asize(aList4,Len(aList4)-1)
					Next nX
				EndIf

				//Excluindo Especialidades da Ordem
				dbSelectArea(c990TRBE)
				dbSetOrder(01)
				dbGoTop()
				dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO  )
				While !EoF() .And. (c990TRB3)->ORDEM + (c990TRB3)->PLANO == (c990TRBE)->ORDEM + (c990TRBE)->PLANO
					xx := aScan(aList2 ,{|x| PadR(x[2],40) == PadR((c990TRBE)->DESCRI,40) })
					If xx > 0
						aList2[xx,8] := MtoH( HtoM(aList2[xx,8]) - HtoM((c990TRBE)->TEMPRO) )
						aList2[xx,1] := fRetLegend(aList2[xx,8],aList2[xx,9])
						If HtoM(aList2[xx,8]) <= 0
							Adel(aList2,xx)
							Asize(aList2,Len(aList2)-1)
						EndIf
					EndIf

					(c990TRBE)->TECADD := 0
					(c990TRBE)->DIAADD := 0
					(c990TRBE)->TECAUS := 0
					(c990TRBE)->DIAAUS := 0

					dbSelectArea(c990TRBE)
					dbSkip()
				End

				//Excluindo Mao-de-Obra da Ordem
				dbSelectArea(c990TRBM)
				dbSetOrder(01)
				dbGoTop()
				dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO  )
				While !EoF() .And. (c990TRB3)->ORDEM + (c990TRB3)->PLANO == (c990TRBM)->ORDEM + (c990TRBM)->PLANO
					xx := aScan(aList5 ,{|x| PadR(x[2],6) == PadR((c990TRBM)->CODIGO,6) })
					If xx > 0
						aList5[xx,5] := MtoH( HtoM(aList5[xx,5]) - HtoM((c990TRBM)->TEMPRO) )
						aList5[xx,1] := fRetLegend(aList5[xx,5],aList5[xx,6])
						If HtoM(aList5[xx,5]) <= 0
							Adel(aList5,xx)
							Asize(aList5,Len(aList5)-1)
						EndIf
					EndIf

					dbSelectArea(c990TRBM)
					dbSkip()
				End

				dbSelectArea(c990TRB1)
				(c990TRB1)->(dbAppend())
				For nTRB := 1 To Len(aTRB1)

					dbSelectArea( c990TRB3 )
					If FieldPos( aTRB1[nTRB,1] ) > 0

						(c990TRB1)->&(aTRB1[nTRB][1]) := (c990TRB3)->&(aTRB1[nTRB][1])

					// P.E. PARA ALIMENTAR OS CAMPOS CRIADOS PELO P.E. MNTA9902.
					ElseIf lMNTA9905

						ExecBlock( 'MNTA9905', .F., .F., { c990TRB1 } )	

					EndIf

				Next nTRB

				If Type((c990TRB3)->PRIORID) == 'N'
					(c990TRB1)->PRIOINV := (Val((c990TRB3)->PRIORID) * -1)
				Else
					(c990TRB1)->PRIOINV := 0
				EndIf

				(c990TRB1)->MARCADO := (c990TRB3)->MARCADO
				(c990TRB1)->PLANO   := (c990TRB3)->PLANO
				(c990TRB1)->SEQRELA := (c990TRB3)->SEQRELA
				(c990TRB1)->EQUIPE  := (c990TRB3)->EQUIPE
				If !Empty(cStNaoP990)
					(c990TRB1)->XSTATUS := cStNaoP990
				EndIf
				(c990TRB1)->DTMPINI := (c990TRB3)->DTORIGI
				If lCpoTT2Dt
					(c990TRB1)->DTMPROG := SToD("")
				EndIf
				(c990TRB1)->DTORIGI := (c990TRB3)->DTORIGI
				(c990TRB1)->SITUACA := (c990TRB3)->SITUACA
				(c990TRB1)->REALIZA := (c990TRB3)->REALIZA

				dbSelectArea(c990TRB2)
				dbSetOrder(3)
				dbGoTop()
				If dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO )
					dbSelectArea(c990TRB2)
					RecLock(c990TRB2,.F.)
					dbDelete()
					MsUnLock(c990TRB2)
				EndIf

				dbSelectArea(c990TRB3)
				RecLock(c990TRB3,.F.)
				dbDelete()
				MsUnLock(c990TRB3)

				dbSkip()
			End


		Else //Botao All Prev

			aList2 := {}
			aList3 := {}
			aList4 := {}
			aList5 := {}

			dbSelectArea(c990TRB3)
			dbSetOrder(nTipoInd)
			dbGoTop()
			ProcRegua((c990TRB3)->(RecCount()))
			While !EoF()
				IncProc()

				If (c990TRB3)->REALIZA > "0" //Se insumo aplicado.
					cAgruOS += IIF( nLoop == 1, (c990TRB3)->ORDEM, ',' + (c990TRB3)->ORDEM )
					(c990TRB3)->( dbSkip() )
					nLoop++
					Loop
				EndIf

				//Excluindo Especialidades da Ordem
				dbSelectArea(c990TRBE)
				dbSetOrder(01)
				dbGoTop()
				dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO  )
				While !EoF() .And. (c990TRB3)->ORDEM + (c990TRB3)->PLANO == (c990TRBE)->ORDEM + (c990TRBE)->PLANO

					(c990TRBE)->TECADD := 0
					(c990TRBE)->DIAADD := 0
					(c990TRBE)->TECAUS := 0
					(c990TRBE)->DIAAUS := 0

					dbSelectArea(c990TRBE)
					dbSkip()
				End

				dbSelectArea(c990TRB1)
				(c990TRB1)->(dbAppend())
				For nTRB := 1 To Len(aTRB1)

					dbSelectArea( c990TRB3 )
					If FieldPos( aTRB1[nTRB,1] ) > 0

						(c990TRB1)->&(aTRB1[nTRB][1]) := (c990TRB3)->&(aTRB1[nTRB][1])

					// P.E. PARA ALIMENTAR OS CAMPOS CRIADOS PELO P.E. MNTA9902.
					ElseIf lMNTA9905

						ExecBlock( 'MNTA9905', .F., .F., { c990TRB1 } )

					EndIf

				Next nTRB
				If Type((c990TRB3)->PRIORID) == 'N'
					(c990TRB1)->PRIOINV := (Val((c990TRB3)->PRIORID) * -1)
				Else
					(c990TRB1)->PRIOINV := 0
				EndIf
				(c990TRB1)->PLANO   := (c990TRB3)->PLANO
				(c990TRB1)->SITUACA := (c990TRB3)->SITUACA
				(c990TRB1)->MARCADO := "  "
				(c990TRB1)->SEQRELA := (c990TRB3)->SEQRELA
				(c990TRB1)->EQUIPE  := (c990TRB3)->EQUIPE
				(c990TRB1)->DTORIGI := (c990TRB3)->DTORIGI
				(c990TRB1)->REALIZA := (c990TRB3)->REALIZA
				If !Empty(cStNaoP990)
					(c990TRB1)->XSTATUS := cStNaoP990
				EndIf
				(c990TRB1)->DTMPINI := (c990TRB3)->DTORIGI
				If lCpoTT2Dt
					(c990TRB1)->DTMPROG := SToD("")
				EndIf
				(c990TRB1)->DTORIGI := (c990TRB3)->DTORIGI

				dbSelectArea(c990TRB2)
				dbSetOrder(3)
				dbGoTop()
				If dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO )
					dbSelectArea(c990TRB2)
					RecLock(c990TRB2,.F.)
					dbDelete()
					MsUnLock(c990TRB2)
				EndIf

				dbSelectArea(c990TRB3)
				RecLock(c990TRB3,.F.)
				dbDelete()
				MsUnLock(c990TRB3)

				dbSkip()
			End

			 If !Empty( cAgruOS )
				Alert( STR0327+AllTrim( cAgruOS )+STR0328 ) //"A(s) ordem(ns) de serviço: 'x' não pode(m) ser alterada(s) sua data, pois contém insumo(s) aplicado(s)."
			Endif

		EndIf

		lMudouDt := .F.
		If lCpoTT2Dt .And. (lPrgDiaria .Or. !lEveProg)
			dDtMaior := SToD("")
			dDtMenor := SToD("")
			lFirst := .T.
			dbSelectArea(c990TRB2)
			dbGoTop()
			While !EoF()
				If lFirst
					lFirst := .F.
					dDtMaior := (c990TRB2)->DTMPROG
					dDtMenor := (c990TRB2)->DTMPROG
				Else
					If (c990TRB2)->DTMPROG > dDtMaior
						dDtMaior := (c990TRB2)->DTMPROG
					EndIf
					If (c990TRB2)->DTMPROG < dDtMenor
						dDtMenor := (c990TRB2)->DTMPROG
					EndIf
				EndIf
				dbSkip()
			End
			If (dTT1_DTFIM <> dDtMaior .And. !Empty(dDtMaior)) .Or. (dTT1_DTPROG <> dDtMenor .And. !Empty(dDtMenor))
				If nOSPrInd == 1
					lMudouDt := .T.
				EndIf
			EndIf
		EndIf

		dbSelectArea(c990TRB1)
		dbSetOrder(nTipoInd)
		dbGoTop()
		dbSelectArea(c990TRB2)
		dbSetOrder(nTipoInd)
		dbGoTop()
		dbSelectArea(c990TRB3)
		dbSetOrder(nTipoInd)
		dbGoTop()

		oMARK1:Refresh()
		oMARK2:Refresh()

		If lMudouDt
			//Carrega a disponibilidade por Especialidade
			Processa({|lEND| fDispoST1(.T.,.T.,dTT1_DTPROG,dTT1_DTFIM) },STR0020) //"Verificando Disponibilidade da Mão-de-Obra"
			//Carrega Folders (MDO, Produtos e Ferramentas)
			Processa({|lEND| fLoadTTXX(.T.) },STR0199) //"Carregando Insumos"
		Else
			If Len(aList4) == 0
				aList4 := {{ " " , " " , " " , 0 }}
			EndIf
			aSORT(aList4,,,{|x,y| x[1] < y[1]})
			oList4:SetArray( aList4 )
			oList4:bLine:= bList4
			oList4:GoTop()
			oList4:REFRESH()

			If Len( aList3 ) == 0

				aList3 := aList3Def

			EndIf

			aSORT(aList3,,,{|x,y| x[1] < y[1]})
			oList3:SetArray( aList3 )
			oList3:bLine:= bList3
			oList3:GoTop()
			oList3:REFRESH()

			If Len(aList2) == 0
				aList2 := {{ 0 , " " , 0 , 0 , 0 , 0 , 0 , "00:00" , "00:00" ,0 , " "}}
			EndIf
			aSORT(aList2,,,{|x,y| x[2] < y[2]})
			oList2:SetArray( aList2 )
			oList2:bLine:= bList2
			oList2:GoTop()
			oList2:REFRESH()

			If Len(aList5) == 0
				aList5 := {{0, " ", " ", " ", "00:00", "00:00", 0 , " "}}
			EndIf
			aSORT(aList5,,,{|x,y| x[3] < y[3]})
			oList5:SetArray( aList5 )
			oList5:bLine:= bList5
			oList5:GoTop()
			oList5:REFRESH()
		EndIf

	EndIf

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fPrgChgMes
Função chamada ao alterar MÊS, atualizando as legendas do calendário.
@type function

@author Denis Hyroshi de Souza
@since 03/03/2008

@sample fPrgChgMes( 1, oCalend )

@param  nChamada, Númerico, Ponto de chamada da função.
@param  oCalend , Objeto  , Objeto de controle do calendário de O.S.
@return Lógico  , Define se o processo foi executado com êxito.
/*/
//------------------------------------------------------------------------------------
Static Function fPrgChgMes(nChamada,oCalend)

	Local cCodCalen  := ''
	Local cJoin      := '%'
	Local cTblTL     := '%' + oTmpSTL:GetRealName() + '%'
	Local cAliasTL   := GetNextAlias()
	Local cAlsST1    := GetNextAlias()
	Local cAlsTP6    := ''
	Local aInfoDay   := {}
	Local aTeamDay   := {}
	Local aFuncHora  := {}
	Local aDiaH9     := {}
	Local aSpecialty := {}
	Local aArea 	 := GetArea()
	Local nXXX,nYYY
	Local nIndex     := 0

	If nChamada == 1
		ProcRegua( ST1->(LastRec()) + 50 )
	EndIf

	cMesChar  := StrZero( Month(oCalend:dDiaAtu) ,2 )
	dDtIniCal := SToD( Substr( DtoS(oCalend:dDiaAtu) , 1 , 6 ) + "01" )
	dDtFimCal := SToD("")
	If cMesChar $ "01-03-05-07-08-10-12"
		dDtFimCal := SToD( Substr( DtoS(oCalend:dDiaAtu) , 1 , 6 ) + "31" )
	ElseIf cMesChar $ "04-06-09-11"
		dDtFimCal := SToD( Substr( DtoS(oCalend:dDiaAtu) , 1 , 6 ) + "30" )
	Else
		If AnoBissexto( Year(oCalend:dDiaAtu) )
			dDtFimCal := SToD( Substr( DtoS(oCalend:dDiaAtu) , 1 , 6 ) + "29" )
		Else
			dDtFimCal := SToD( Substr( DtoS(oCalend:dDiaAtu) , 1 , 6 ) + "28" )
		EndIf
	EndIf

	// Busca funcionário e especialidades
	BeginSQL Alias cAlsST1

		SELECT DISTINCT 
			ST1.T1_CODFUNC,
			ST1.T1_NOME   ,
			ST1.T1_TURNO  ,
			ST1.T1_EQUIPE ,
			ST2.T2_ESPECIA
		FROM
			%table:ST1% ST1
		RIGHT JOIN
			%table:ST2% ST2 ON
				ST2.T2_CODFUNC = ST1.T1_CODFUNC AND
				ST2.T2_FILIAL  = ST1.T1_FILIAL  AND
				ST2.%NotDel%
		WHERE
			ST1.T1_FILIAL  = %xFilial:ST1% AND
			ST1.T1_DISPONI = 'S'

	EndSQL
	
	While (cAlsST1)->( !EoF() )

		If nChamada == 1
			IncProc()
		EndIf

		aFuncHora := { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
		
		If ( nPosEsp := aScan( aInfoDay, { |x| x[1] == (cAlsST1)->T2_ESPECIA } ) ) == 0
			
			aAdd( aInfoDay, { (cAlsST1)->T2_ESPECIA, { { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 },;
				{ 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 },;
				{ 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 },;
				{ 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 } } } )
			
			nPosEsp := Len( aInfoDay )
			
		EndIf

		//Se mão-de-obra esta disponivel sempre 8h por dia
		If lHorDia8

			dDtAtu := dDtIniCal
			While dDtAtu <= dDtFimCal
				aInfoDay[nPosEsp][2][Day(dDtAtu),1] += (8 * 60)
				dDtAtu := dDtAtu + 1
			End

			//Se o turno for fixo
		ElseIf !lNGFlut
			aDispo := {}
			nPosC  := aScan(vCalend,{|x| x = (cAlsST1)->T1_TURNO})
			If nPosC = 0
				aAdd(vCalend,(cAlsST1)->T1_TURNO)
				aDispo := NG_H7((cAlsST1)->T1_TURNO)
				aAdd(aCalends,aDispo)
				nPosC := Len(vCalend)
			EndIf

			dDtAtu := dDtIniCal
			If !Empty(aCalends[nPosC])

				While dDtAtu <= dDtFimCal
					nSem   := If( DOW(dDtAtu) == 1, 7, DOW(dDtAtu)-1)
					nPosH9 := aScan( aListaSH9 , {|x| x[1] == dDtAtu })
					If nPosH9 == 0
						aAdd( aListaSH9 , { dDtAtu , NG_H9(dDtAtu) } )
						nPosH9 := Len(aListaSH9)
					EndIf
					aDiaH9 := aListaSH9[nPosH9,2]
					If Len(aDiaH9) > 0
						aInfoDay[nPosEsp][2][Day(dDtAtu),1] += HtoM(aDiaH9[3])
						aFuncHora[Day(dDtAtu)] += HtoM(aDiaH9[3])
					Else
						aInfoDay[nPosEsp][2][Day(dDtAtu),1] += HtoM(aCalends[nPosC,nSem,3])
						aFuncHora[Day(dDtAtu)] += HtoM(aCalends[nPosC,nSem,3])
					EndIf
					dDtAtu := dDtAtu + 1
				End

				If lIntegGPE

					dbSelectArea("SR8")
					dbSetOrder(1)
					dbSeek(xFilial("SR8")+ (cAlsST1)->T1_CODFUNC+DTOS(dDtIniCal),.T.)
					While !EoF() .And. SR8->R8_FILIAL = Xfilial("SR8") .And. (cAlsST1)->T1_CODFUNC == SR8->R8_MAT

						IF SR8->R8_DATAINI > dDtFimCal .Or. ( SR8->R8_DATAFIM < dDtIniCal .And. !Empty(SR8->R8_DATAFIM) )
							dbSelectArea("SR8")
							dbSkip()
							Loop
						EndIf

						dIniSTK := SR8->R8_DATAINI
						dFimSTK := SR8->R8_DATAFIM
						If SR8->R8_DATAINI < dDtIniCal
							dIniSTK := dDtIniCal
						EndIf
						If SR8->R8_DATAFIM > dDtFimCal
							dFimSTK := dDtFimCal
						EndIf

						dDtAtu := dIniSTK
						While dDtAtu <= dFimSTK
							nSem   := If( DOW(dDtAtu) == 1, 7, DOW(dDtAtu)-1)
							cHoraIni := "00:00"
							cHoraFim := "24:00"
							cDiasSem := NGCALCHCAR(dDtAtu,cHoraIni,dDtAtu,cHoraFim)
							nDiasSem := HTOM(cDiasSem)
							If nDiasSem > aFuncHora[Day(dDtAtu)]
								nDiasSem := aFuncHora[Day(dDtAtu)]
							EndIf
							aInfoDay[nPosEsp][2][Day(dDtAtu),2] += nDiasSem

							dDtAtu := dDtAtu + 1
						End

						SR8->(dbSkip())
					End
				EndIf

				dbSelectArea("STK")
				dbSetOrder(1)
				dbSeek(xFilial("STK")+Space(Len(STK->TK_ORDEM))+Space(Len(STK->TK_PLANO))+Space(Len(STK->TK_TAREFA))+(cAlsST1)->T1_CODFUNC)
				While !EoF() .And. xFilial("STK") == STK->TK_FILIAL .And.;
				STK->TK_ORDEM  == Space(Len(STK->TK_ORDEM)) .And.;
				STK->TK_PLANO  == Space(Len(STK->TK_PLANO)) .And.;
				STK->TK_TAREFA  == Space(Len(STK->TK_TAREFA)) .And.;
				STK->TK_CODFUNC == (cAlsST1)->T1_CODFUNC

					If Empty(STK->TK_ORDEM)

						IF STK->TK_DATAINI > dDtFimCal .Or. ( STK->TK_DATAFIM < dDtIniCal .And. !Empty(STK->TK_DATAFIM) )
							dbSelectArea("STK")
							dbSetOrder(2)
							dbSkip()
							Loop
						EndIf

						dIniSTK := STK->TK_DATAINI
						dFimSTK := STK->TK_DATAFIM
						If STK->TK_DATAINI < dDtIniCal
							dIniSTK := dDtIniCal
						EndIf
						If STK->TK_DATAFIM > dDtFimCal
							dFimSTK := dDtFimCal
						EndIf

						dDtAtu := dIniSTK
						While dDtAtu <= dFimSTK
							nSem   := If( DOW(dDtAtu) == 1, 7, DOW(dDtAtu)-1)
							cHoraIni := If( dDtAtu == STK->TK_DATAINI , STK->TK_HORAINI , "00:00" )
							cHoraFim := If( dDtAtu == STK->TK_DATAFIM , STK->TK_HORAFIM , "24:00" )
							cDiasSem := NGCALCHCAR(dDtAtu,cHoraIni,dDtAtu,cHoraFim)
							nDiasSem := HTOM(cDiasSem)
							If nDiasSem > aFuncHora[Day(dDtAtu)]
								nDiasSem := aFuncHora[Day(dDtAtu)]
							EndIf
							aInfoDay[nPosEsp][2][Day(dDtAtu),2] += nDiasSem

							dDtAtu := dDtAtu + 1
						End
					EndIf

					dbSelectArea("STK")
					dbSetOrder(2)
					dbSkip()
				End
			EndIf

		// Se o turno for flutuante
		Else

			dDtAtu  := dDtIniCal

			// Se ja carregou disponibilidade da Equipe nao precisa verificar novamente
			If ( nPosE := aScan( aTeamDay, { |x| x[1] == (cAlsST1)->T1_EQUIPE } ) ) == 0
			
				aAdd( aTeamDay, { (cAlsST1)->T1_EQUIPE, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,;
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } )
				
				nPosE   := Len( aTeamDay )
				cAlsTP6 := GetNextAlias()

				While dDtAtu <= dDtFimCal

					BeginSQL Alias cAlsTP6
						
						SELECT
							TP6.R_E_C_N_O_
						FROM
							%table:TP6% TP6
						WHERE
							TP6.TP6_FILIAL = %xFilial:TP6%              AND
							TP6.TP6_EQUIPE = %exp:(cAlsST1)->T1_EQUIPE% AND
							( %exp:dDtAtu% BETWEEN TP6.TP6_DTINI AND TP6.TP6_DTFIM ) AND
							TP6.%NotDel%
						ORDER BY
							TP6.TP6_DTINI

					EndSQL
					
					If (cAlsTP6)->( !EoF() )
					
						While (cAlsTP6)->( !EoF() )

							dbSelectArea( 'TP6' )
							dbGoTo( (cAlsTP6)->R_E_C_N_O_ )

							If dDtAtu <= dDtFimCal
							
								While dDtAtu <= dDtFimCal .And. ( dDtAtu >= TP6->TP6_DTINI .And. dDtAtu <= TP6->TP6_DTFIM )

									aDispo := {}

									If ( nPosC := aScan( vCalend, { |x| x == TP6->TP6_CALEND } ) ) == 0
										
										aAdd( vCalend, TP6->TP6_CALEND )
										aDispo := NG_H7( TP6->TP6_CALEND )
										aAdd( aCalends, aDispo )
										nPosC  := Len( vCalend )

									EndIf
									
									nSem := IIf( Dow( dDTATU ) == 1, 7, Dow( dDTATU ) - 1 )
									aTeamDay[nPosE,2,Day( dDtAtu )] += HToM( aCalends[nPosC,nSem,3] )
									
									dDtAtu++

								End
							
							Else
								
								dDtAtu++

							EndIf

							(cAlsTP6)->( dbSkip() )

						End

					Else
						
						dDtAtu++

					EndIf

					(cAlsTP6)->( dbCloseArea() )

				End
	
			EndIf

			/*--------------------------------------------------------+
			| Repassa disponibilidade da equipe para o array aInfoDay |
			+--------------------------------------------------------*/
			For nXXX := 1 to 31
				aInfoDay[nPosEsp][2][nXXX,1] += aTeamDay[nPosE,2,nXXX]
			Next nXXX

			If lIntegGPE

				dbSelectArea("SR8")
				dbSetOrder(1)
				dbSeek(xFilial("SR8")+(cAlsST1)->T1_CODFUNC+DTOS(dDtIniCal),.T.)
				While !EoF() .And. SR8->R8_FILIAL = Xfilial("SR8") .And. (cAlsST1)->T1_CODFUNC == SR8->R8_MAT

					IF SR8->R8_DATAINI > dDtFimCal .Or. ( SR8->R8_DATAFIM < dDtIniCal .And. !Empty(SR8->R8_DATAFIM) )
						dbSelectArea("SR8")
						dbSkip()
						Loop
					EndIf

					dIniSTK := SR8->R8_DATAINI
					dFimSTK := SR8->R8_DATAFIM
					If SR8->R8_DATAINI < dDtIniCal
						dIniSTK := dDtIniCal
					EndIf
					If SR8->R8_DATAFIM > dDtFimCal
						dFimSTK := dDtFimCal
					EndIf

					dDtAtu := dIniSTK
					While dDtAtu <= dFimSTK
						nSem   := If( DOW(dDtAtu) == 1, 7, DOW(dDtAtu)-1)
						cHoraIni := "00:00"
						cHoraFim := "24:00"
						cDiasSem := NGCALCHCAR(dDtAtu,cHoraIni,dDtAtu,cHoraFim)
						nDiasSem := HTOM(cDiasSem)
						nPosEq := aScan(aTeamDay ,{|x| x[1] == (cAlsST1)->T1_EQUIPE })
						If nPosEq > 0
							If nDiasSem > aTeamDay[nPosEq,2,Day(dDtAtu)]
								nDiasSem := aTeamDay[nPosEq,2,Day(dDtAtu)]
							EndIf
							aInfoDay[nPosEsp][2][Day(dDtAtu),2] += nDiasSem
						EndIf
						dDtAtu := dDtAtu + 1
					End

					SR8->(dbSkip())
				End
			EndIf

			dbSelectArea("STK")
			dbSetOrder(1)
			dbSeek(xFilial("STK")+Space(Len(STK->TK_ORDEM))+Space(Len(STK->TK_PLANO))+Space(Len(STK->TK_TAREFA))+(cAlsST1)->T1_CODFUNC)
			While !EoF() .And. xFilial("STK") == STK->TK_FILIAL .And.;
			STK->TK_ORDEM  == Space(Len(STK->TK_ORDEM)) .And.;
			STK->TK_PLANO  == Space(Len(STK->TK_PLANO)) .And.;
			STK->TK_TAREFA  == Space(Len(STK->TK_TAREFA)) .And.;
			STK->TK_CODFUNC == (cAlsST1)->T1_CODFUNC

				If Empty(STK->TK_ORDEM)

					IF STK->TK_DATAINI > dDtFimCal .Or. ( STK->TK_DATAFIM < dDtIniCal .And. !Empty(STK->TK_DATAFIM) )
						dbSelectArea("STK")
						dbSetOrder(2)
						dbSkip()
						Loop
					EndIf

					dIniSTK := STK->TK_DATAINI
					dFimSTK := STK->TK_DATAFIM
					If STK->TK_DATAINI < dDtIniCal
						dIniSTK := dDtIniCal
					EndIf
					If STK->TK_DATAFIM > dDtFimCal
						dFimSTK := dDtFimCal
					EndIf

					dDtAtu := dIniSTK
					While dDtAtu <= dFimSTK
						nSem   := If( DOW(dDtAtu) == 1, 7, DOW(dDtAtu)-1)
						cHoraIni := If( dDtAtu == STK->TK_DATAINI , STK->TK_HORAINI , "00:00" )
						cHoraFim := If( dDtAtu == STK->TK_DATAFIM , STK->TK_HORAFIM , "24:00" )
						cDiasSem := NGCALCHCAR(dDtAtu,cHoraIni,dDtAtu,cHoraFim)
						nDiasSem := HTOM(cDiasSem)
						nPosEq := aScan(aTeamDay ,{|x| x[1] == (cAlsST1)->T1_EQUIPE })
						If nPosEq > 0
							If nDiasSem > aTeamDay[nPosEq,2,Day(dDtAtu)]
								nDiasSem := aTeamDay[nPosEq,2,Day(dDtAtu)]
							EndIf
							aInfoDay[nPosEsp][2][Day(dDtAtu),2] += nDiasSem
						EndIf
						dDtAtu := dDtAtu + 1
					End
				EndIf

				dbSelectArea("STK")
				dbSetOrder(2)
				dbSkip()
			End

		EndIf

		(cAlsST1)->( dbSkip() )

	End

	(cAlsST1)->( dbCloseArea() )

	// Verifica se deve considerar O.S. de lubrificação
	cJoin += IIf( M->TT1_INDLUB == '2', " AND STJ.TJ_LUBRIFI <> 'S'", '' )

	// Verifica se deve considerar O.S. de localização
	cJoin += IIf( M->TT1_INDLOC == '2', " AND STJ.TJ_TIPOOS = 'B'"  , '' )

	// Fecha condição Embedded SQL
	cJoin += '%'

	BeginSQL Alias cAliasTL

		SELECT
			TL.TL_PLANO   ,
			TL.TL_ORDEM   ,
			TL.TL_TIPOREG ,
			TL.TL_CODIGO  ,
			TL.TL_QUANREC ,
			TL.TL_QUANTID ,
			TL.TL_UNIDADE ,
			TL.TL_TIPOHOR ,
			TL.TL_DTINICI ,
			TL.TL_HOINICI ,
			TL.TL_DTFIM   ,
			TL.TL_USACALE ,
			TL.TL_HOFIM   ,
			STJ.TJ_CODBEM ,
			STJ.TJ_SERVICO,
			STJ.TJ_SEQRELA
		FROM
			%exp:cTblTL% TL
		JOIN
			%table:STJ% STJ ON
				TL.TL_ORDEM = STJ.TJ_ORDEM    AND
				TL.TL_PLANO = STJ.TJ_PLANO    AND
				STJ.TJ_FILIAL = %xFilial:STJ% AND
				STJ.TJ_TERMINO <> 'S'         AND
				STJ.TJ_SITUACA <> 'C'         AND
				STJ.%NotDel%
				%exp:cJoin%
		WHERE
			( TL.TL_TIPOREG = 'M' OR TL.TL_TIPOREG = 'E' ) AND
			TL.TL_DTINICI <= %exp:dToS( dDtFimCal )%       AND
			TL.TL_DTFIM   >= %exp:dToS( dDtIniCal )%       AND
			TL.TL_SEQRELA = '0'                            AND
			TL.STATUS <> 3 // Status diferente de 3 - excluido

	EndSQL

	Do While (cAliasTL)->( !EoF() )

		// Atribui especialidades ao array, permitindo cálculos que considerem multi esecialidade em um mesmo func.
		aSpecialty := IIf( (cAliasTL)->TL_TIPOREG == 'M', aClone( fGetEspc( (cAliasTL)->TL_CODIGO ) ), { { Trim( (cAliasTL)->TL_CODIGO ),;
			Posicione( 'ST0', 1, xFilial( 'ST0' ) + (cAliasTL)->TL_CODIGO, 'T0_NOME' ), fCountST2( (cAliasTL)->TL_CODIGO ) } } )

		// Somente preenche as legendas de calendário considerando mão de obra que possuam calendário
		For nIndex := 1 to Len( aSpecialty )

			// Adiciona esecialidades que não possuem funcionários associados no array aInfoDay
			If ( nPosEsp := aScan( aInfoDay, { |x| x[1] == aSpecialty[nIndex,1] } ) ) == 0

				aAdd( aInfoDay, { aSpecialty[nIndex,1], {} } )
				nPosEsp := Len( aInfoDay )

				For nXXX := 1 to 31
					aAdd( aInfoDay[nPosEsp,2], { 0, 0, 0 } )
				Next nXXX

			EndIf

			_dDtInicio := SToD( (cAliasTL)->TL_DTINICI )
			_dDtTermin := SToD( (cAliasTL)->TL_DTFIM )
			_cHrInicio := (cAliasTL)->TL_HOINICI
			_cHrTermin := (cAliasTL)->TL_HOFIM

			If dDtIniCal > _dDtInicio
				_dDtInicio := dDtIniCal
				_cHrInicio := "00:00"
			EndIf

			If dDtFimCal < _dDtTermin
				_dDtTermin := dDtFimCal
				_cHrTermin := "24:00"
			EndIf

			dDtAtu := _dDtInicio

			While dDtAtu <= _dDtTermin

				nSem     := If( DOW(dDtAtu) == 1, 7, DOW(dDtAtu)-1)
				cHoraIni := If( dDtAtu == _dDtInicio , _cHrInicio , "00:00" )
				cHoraFim := If( dDtAtu == _dDtTermin , _cHrTermin , "24:00" )

				cCodCalen := ''

				// Somente insumos do tipo mão de obra podem considerar calendário
				If (cAliasTL)->TL_TIPOREG == 'M' .And. (cAliasTL)->TL_USACALE == 'S'

					// Para turno flutuante ou O.S. corretiva recupera o calendário vinculado ao funcionário
					If lNGFlut .Or. (cAliasTL)->TL_PLANO == '000000'

						cCodCalen := fGetCalen( (cAliasTL)->TL_CODIGO, dDtAtu, dDtAtu )

					// Para O.S. preventivas utiliza-se o calendário vinculado a manutenção
					Else

						cCodCalen := Posicione( 'STF', 1, xFilial( 'STF' ) + (cAliasTL)->TJ_CODBEM +;
							(cAliasTL)->TJ_SERVICO + (cAliasTL)->TJ_SEQRELA, 'TF_CALENDA' )

					EndIf

				EndIf

				// Cálcula o tempo decorrido na utilização do insumo no dia atual
				cHoraTmp := fTimeInput( aSpecialty[nIndex,1], cCodCalen, dDtAtu, cHoraIni, dDtAtu, cHoraFim, .F., dDtAtu )

				/*
					Somente realiza o calculo quando a especialida requisitar mais de um recurso. Pois para valores
					menores a quantidade de horas comprometidas se equivale a infomada no campo TL_QUANTID.
				*/
				If (cAliasTL)->TL_QUANREC > 1
					cHoraTmp := MtoH( HtoM(cHoraTmp) * (cAliasTL)->TL_QUANREC )
				EndIf

				nPosEsp := aScan(aInfoDay,{|x| x[1] == aSpecialty[nIndex,1] })
				nDiaTL := Day(dDtAtu)

				If nPosEsp > 0 .And. nDiaTL > 0 .And. nDiaTL <= 31
					aInfoDay[nPosEsp][2][nDiaTL,3] += HtoM( cHoraTmp )
				EndIf

				dDtAtu := dDtAtu + 1

			EndDo

		Next nIndex

		(cAliasTL)->( dbSkip() )

	EndDo

	(cAliasTL)->( dbCloseArea() )

	If nChamada == 1
		//Para incrementar a regua
		For nXXX := 1 to 19
			IncProc()
		Next nXXX
	EndIf

	oCalend:DelAllRestri()

	IncProc()

	For nXXX := 1 to 31
		For nYYY := 1 to Len(aInfoDay)
			nDispDia := aInfoDay[nYYY][2][nXXX,1] - aInfoDay[nYYY][2][nXXX,2]
			If nDispDia < aInfoDay[nYYY][2][nXXX,3]
				oCalend:addRestri(nXXX,CLR_HRED,CLR_HRED)
				Exit
			ElseIf nDispDia >= aInfoDay[nYYY][2][nXXX,3] .And. aInfoDay[nYYY][2][nXXX,3] > 0
				oCalend:addRestri(nXXX,CLR_HGREEN,CLR_HGREEN)
			EndIf
		Next nYYY
	Next nXXX

	oCalend:Refresh()

	RestArea(aArea)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fPrgChgDia
Funcao chamada ao alterar DIA

@sample
fPrgChgDia(nTipo)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fPrgChgDia( nTipo )

	Default nTipo := 1

	If nTipo == 1

		If MsgYesNo(STR0114+DtoC(oCalend:dDiaAtu)+"?") //"Deseja filtrar Ordens de Serviços apenas do dia "
			M->TT1_DTDE   := oCalend:dDiaAtu
			M->TT1_DTATE  := oCalend:dDiaAtu

			oGet001:Refresh()
			oGet002:Refresh()
			Processa({|lEND| fBuscaOS(2)},STR0045) //"Filtrando Ordens de Serviços"
		EndIf

		_dDiaAtu := oCalend:dDiaAtu

	ElseIf nTipo == 2

		// Filtrar informações do dia selecionado no calendário
		_dDiaAtu := oCalend:dDiaAtu

		If nOSPrInd == 2

			// Filtra as O.S. programadas na data selecionada no calendário
			fFilDataOS( _dDiaAtu, _dDiaAtu, .T. )

		Else

			// Filtra as O.S. programadas em todo periodo de programação
			fFilDataOS( dTT1_DTPROG, dTT1_DTFIM, .F. )

		EndIf

	ElseIf nTipo == 3

		If MsgYesNo(STR0114+DtoC(_dDia2Atu)+"?") //"Deseja filtrar Ordens de Serviços apenas do dia "
			M->TT1_DTDE   := _dDia2Atu
			M->TT1_DTATE  := _dDia2Atu

			oGet001:Refresh()
			oGet002:Refresh()
			Processa({|lEND| fBuscaOS(2)},STR0045) //"Filtrando Ordens de Serviços"

		EndIf

	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} AltStatus
Altera o status da OS

@sample
AltStatus()

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function AltStatus()

	Local oDlg2New
	Local lUmaVez  := .F.
	Local lSelec   := .F.
	Local nOpCheck := 0
	Local oPanel2

	If (c990TRB1)->(EoF())
		If lAltProg
			Help(" ",1,"NGATENCAO",,STR0113,3,1) //"Arquivo vazio!"
		EndIf
		Return .F.
	EndIf

	cDescStatus  := " "
	M->TJ_STATUS := (c990TRB1)->XSTATUS

	nOpc2Cad := 0
	Define MsDialog oDlg2New Title OemToAnsi(STR0061) From 0,0 To 13,65 OF oMainWnd  //"Alterar Status"

	oDlg2New:LESCCLOSE := .F.

	oPanel2 := TPanel():New(0, 0, Nil, oDlg2New, Nil, .T., .F., Nil, Nil, 0, 0, .T., .F. )
	oPanel2:Align := CONTROL_ALIGN_ALLCLIENT

	@ 010,008 Say Oemtoansi(STR0010) Of oPanel2 Pixel //"Ordem"
	@ 010,045 MsGet (c990TRB1)->ORDEM Size 50,7 Of oPanel2 Pixel When .F.

	@ 024,008  Say Oemtoansi(STR0014) Color CLR_HBLUE Of oPanel2 Pixel //"Status"
	@ 024,045  MsGet M->TJ_STATUS Valid ExistCpo(cTabStatus,M->TJ_STATUS) F3 cTabStatus Picture '@!' Size 30,7 Of oPanel2 Pixel When lAltProg HASBUTTON

	TRadMenu():New(42, 8, {STR0116, STR0351},{|u| IIf (PCount() == 0, nOpCheck, nOpCheck := u)}, oPanel2 ;
					,,{|| IIF(nOpCheck <> 0 .And. nOpCheck == 1, lUmaVez := .T., lSelec := .T.)},,,,, ;
					{|| lAltProg }, 235, 7,,,, .T., .F.) //"Aplicar as alterações em todas as O.S. listadas?" ## "Aplicar as alterações em todas as O.S. selecionadas?"

	Activate MsDialog oDlg2New On Init EnchoiceBar(oDlg2New,{|| ( oDlg2New:End() , nOpc2Cad := 1 ) },{|| oDlg2New:End() }) Centered

	If nOpc2Cad == 1 .And. lAltProg

		If lUmaVez .Or. lSelec
			dbSelectArea(c990TRB1)
			dbSetOrder(3)
			dbGoTop()
			While (c990TRB1)->(!EoF())

				If lSelec .And. Empty( (c990TRB1)->MARCADO )
					(c990TRB1)->( dbSkip() )
					Loop
				EndIf

				(c990TRB1)->XSTATUS := M->TJ_STATUS
				dbSelectArea(c990TRB1)
				dbSkip()
			End
			dbSelectArea(c990TRB1)
			dbSetOrder(nTipoInd)
			dbGoTop()
		Else
			(c990TRB1)->XSTATUS := M->TJ_STATUS
		EndIf

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fVisualSC
Visualizar SC

@sample
fVisualSC()

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fVisualSC()
	Local aArea := GetArea()//(c990TRB1)->(GetArea())

	oList3:SetFocus()

	dbSelectArea("SC1")
	dbSetOrder(1)
	If dbSeek(xFilial("SC1") + aList3[oList3:nAt,7] )
		A110Visual("SC1",SC1->(Recno()),2)
	Else
		MsgInfo(STR0117) //"Não tem Solicitação de Compra relacionada."
	EndIf

	RestArea(aArea)
Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fRetLegend
Verifica a especialidade e retorna a legenda

@sample
fRetLegend(cHoraProg,cHoraDisp)78

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fRetLegend(cHoraProg,cHoraDisp)

	Local nProg := HtoM(cHoraProg)
	Local nDisp := HtoM(cHoraDisp)
	Local nPerc := (100 / nDisp) * nProg

	If nProg > 0 .And. nDisp > 0
		If nPerc > 100
			Return 1
		ElseIf nPerc >= 90
			Return 2
		Else
			Return 3
		EndIf
	Else
		If nProg == 0
			Return 4
		Else
			Return 1
		EndIf
	EndIf

Return 4
//---------------------------------------------------------------------
/*/{Protheus.doc} fResumoMDO
Resumo da Especialidade

@sample
fResumoMDO()

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fResumoMDO()
	Local aDadosMDO := {}
	Local oList10,oDlgEsp,nXFor
	Local nMinAdd := 0
	Local nMinAus := 0
	Local cMinAdd := ""

	Private oPanel5
	If lFilOsPro
		If !Empty(aList2[oList2:nAt,2])
			dbSelectArea(c990TRB3)
			aArea2 := GetArea()
			dbSetOrder(nTipoInd)
			dbGoTop()
			While !EoF()
				dbSelectArea(c990TRBE)
				dbSetOrder(02)
				dbGoTop()
				dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO + aList2[oList2:nAt,2] )
				While !EoF() .And. (c990TRB3)->ORDEM + (c990TRB3)->PLANO == (c990TRBE)->ORDEM + (c990TRBE)->PLANO .And. ;
				Alltrim(aList2[oList2:nAt,2]) == Alltrim((c990TRBE)->DESCRI)

					aAdd(aDadosMDO , {(c990TRB3)->PRIORID, (c990TRB3)->ORDEM, (c990TRB3)->CODBEM, (c990TRB3)->DESCRIC, (c990TRBE)->TEMPRO, (c990TRB3)->EQUIPE, (c990TRB3)->PLANO, (c990TRBE)->DESCRI } )
					dbSkip()
				End
				dbSelectArea(c990TRB3)
				dbSkip()
			End
			dbSelectArea(c990TRB3)
			RestArea(aArea2)
			oMARK2:Refresh()
		EndIf
	Else
		If !Empty(aList2[oList2:nAt,2])
			dbSelectArea(c990TRB1)
			aArea2 := GetArea()
			dbSetOrder(nTipoInd)
			dbGoTop()
			While !EoF()
				dbSelectArea(c990TRBE)
				dbSetOrder(02)
				dbGoTop()
				dbSeek( (c990TRB1)->ORDEM + (c990TRB1)->PLANO + aList2[oList2:nAt,2] )
				While !EoF() .And. (c990TRB1)->ORDEM + (c990TRB1)->PLANO == (c990TRBE)->ORDEM + (c990TRBE)->PLANO .And. ;
				Alltrim(aList2[oList2:nAt,2]) == Alltrim((c990TRBE)->DESCRI)

					aAdd(aDadosMDO , {(c990TRB1)->PRIORID, (c990TRB1)->ORDEM, (c990TRB1)->CODBEM, (c990TRB1)->DESCRIC, (c990TRBE)->TEMPRO, (c990TRB1)->EQUIPE, (c990TRB1)->PLANO, (c990TRBE)->DESCRI } )
					dbSkip()
				End
				dbSelectArea(c990TRB1)
				dbSkip()
			End
			dbSelectArea(c990TRB1)
			RestArea(aArea2)
			oMARK2:Refresh()
		EndIf
	EndIf

	If Len(aDadosMDO) == 0
		aAdd(aDadosMDO , {" ", " ", " ", " ", " ", " ", " ", " " } )
	EndIf

	nPar01 := aList2[oList2:nAt,4]
	nPar02 := aList2[oList2:nAt,5]
	nPar03 := aList2[oList2:nAt,6]
	nPar04 := aList2[oList2:nAt,7]

	If nPar01 > 0 .And. nPar02 > 0
		nMinAdd := 8 * 60 * nPar01 * nPar02
	EndIf
	If nPar03 > 0 .And. nPar04 > 0
		nMinAus := 8 * 60 * nPar03 * nPar04
	EndIf
	nMinAdd := nMinAdd - nMinAus
	nMinBef := nMinAdd

	nOpc3Cad := 0
	Define MsDialog oDlgEsp Title OemToAnsi(STR0118) From 0,0 To 26.4,80 OF oMainWnd  //"Detalhes da Mão-de-Obra"

	oPanel5 := TPanel():New(0, 0, Nil, oDlgEsp, Nil, .T., .F., Nil, Nil, 0, 0, .T., .F. )
	oPanel5:Align := CONTROL_ALIGN_ALLCLIENT

	@ 007,008  Say Oemtoansi(STR0074) Of oPanel5 Pixel //"Especialidade"
	@ 007,060  MsGet aList2[oList2:nAt,2] Picture '@!' Size 100,7 Of oPanel5 Pixel When .F.

	@ 007,170  Say Oemtoansi(STR0075) Of oPanel5 Pixel //"Total Técnicos"
	@ 007,212  MsGet aList2[oList2:nAt,3] Picture '999999' Size 50,7 Of oPanel5 Pixel When .F.

	@ 022,008  Say Oemtoansi(STR0076) Of oPanel5 Pixel //"Técnicos Adicionais"
	@ 022,060  MsGet nPar01 Picture '@E 999' Valid Positivo(nPar01) Size 50,7 Of oPanel5 Pixel When lAltProg HASBUTTON

	@ 022,170  Say Oemtoansi(STR0077) Of oPanel5 Pixel //"Dias Adicionais"
	@ 022,212  MsGet nPar02 Picture '@E 99.9' Valid Positivo(nPar02) Size 50,7 Of oPanel5 Pixel When lAltProg HASBUTTON

	@ 036,008  Say Oemtoansi(STR0078) Of oPanel5 Pixel //"Técnicos Ausentes"
	@ 036,060  MsGet nPar03 Picture '@E 999' Valid Positivo(nPar03) Size 50,7 Of oPanel5 Pixel When lAltProg HASBUTTON

	@ 036,170  Say Oemtoansi(STR0079) Of oPanel5 Pixel //"Dias Ausentes"
	@ 036,212  MsGet nPar04 Picture '@E 99.9' Valid Positivo(nPar04) Size 50,7 Of oPanel5 Pixel When lAltProg HASBUTTON

	@ 053,010 ListBox oList10 Var cList10;
	Fields Header;
	STR0119,STR0010,STR0011,STR0012,STR0120,STR0013; //"Prioridade"###"Ordem"###"Bem"###"Descrição"###"Horas Previstas"###"Equipe"
	ColSizes 30,25,55,100,45,40;
	Size 300,110 Of oPanel5 Pixel;

	bList10 := { || { aDadosMDO[oList10:nAt,1], aDadosMDO[oList10:nAt,2], aDadosMDO[oList10:nAt,3], aDadosMDO[oList10:nAt,4],;
	aDadosMDO[oList10:nAt,5], aDadosMDO[oList10:nAt,6] } }
	oList10:SetArray( aDadosMDO )
	oList10:bLine:= bList10
	oList10:Refresh()

	Activate MsDialog oDlgEsp On Init EnchoiceBar(oDlgEsp,{|| (oDlgEsp:End(),nOpc3Cad := 1) },{|| oDlgEsp:End() }) Centered

	If nOpc3Cad == 1 .And. lAltProg
		nMinAdd := 0
		nMinAus := 0
		aList2[oList2:nAt,4] := nPar01
		aList2[oList2:nAt,5] := nPar02
		aList2[oList2:nAt,6] := nPar03
		aList2[oList2:nAt,7] := nPar04
		If nPar01 > 0 .And. nPar02 > 0
			nMinAdd := 8 * 60 * nPar01 * nPar02
		EndIf
		If nPar03 > 0 .And. nPar04 > 0
			nMinAus := 8 * 60 * nPar03 * nPar04
		EndIf
		nMinAdd := nMinAdd - nMinAus
		cMinAdd := ( HtoM(aList2[oList2:nAt,9]) - nMinBef ) + nMinAdd
		If cMinAdd < 0
			cMinAdd := 0
		EndIf
		aList2[oList2:nAt,9] := MtoH(cMinAdd)
		If nMinBef <> nMinAdd
			aList2[oList2:nAt,1] := fRetLegend(aList2[oList2:nAt,8],aList2[oList2:nAt,9])
		EndIf

		For nXFor := 1 To Len(aDadosMDO)

			dbSelectArea(c990TRBE)
			dbSetOrder(02)
			dbGoTop()
			dbSeek( aDadosMDO[nXFor,2] + aDadosMDO[nXFor,7] + aDadosMDO[nXFor,8] )
			While !EoF() .And. aDadosMDO[nXFor,2] + aDadosMDO[nXFor,7] == (c990TRBE)->ORDEM + (c990TRBE)->PLANO .And. ;
			Alltrim(aDadosMDO[nXFor,8]) == Alltrim((c990TRBE)->DESCRI)

				(c990TRBE)->TECADD := aList2[oList2:nAt,4]
				(c990TRBE)->DIAADD := aList2[oList2:nAt,5]
				(c990TRBE)->TECAUS := aList2[oList2:nAt,6]
				(c990TRBE)->DIAAUS := aList2[oList2:nAt,7]
				dbSkip()
			End

		Next nXFor

	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} MDOLegenda
Legenda mão de obra

@sample
MDOLegenda()

@author Denis Hyroshi de Souza
@since 05/04/2005
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function MDOLegenda()
	Local xt
	Local cDescSta := ""
	Local aDados   := {}
	Local oIndNG   := Array(1)

	If Len(aInfoTQW) > 0
		aDados := aClone(aInfoTQW)
	Else
		For xt := 1 To 7
			dbSelectArea("TQW")
			dbSetOrder(03)
			If dbSeek(xFilial("TQW")+Str(xt,1)+" ")
				If xt == 1
					cDescSta := STR0255 //"Programada com Alteração de Data"
				ElseIf xt == 2
					cDescSta := STR0256 //"Aguardando Material"
				ElseIf xt == 3
					cDescSta := STR0257 //"Aguardando Mão de Obra"
				ElseIf xt == 4
					cDescSta := STR0258 //"Aguardando Ferramenta"
				ElseIf xt == 5
					cDescSta := STR0259 //"Aguardando Equipamentos Auxiliares"
				ElseIf xt == 6
					cDescSta := STR0260 //"Aguardando Programação"
				Else
					cDescSta := STR0261 //"Execução"
				EndIf
				If TQW->TQW_CORSTA = "1 "
					aAdd(aDados,{"BR_PINK"		,cDescSta})
				ElseIf TQW->TQW_CORSTA = "2 "
					aAdd(aDados,{"BR_VERMELHO"	,cDescSta})
				ElseIf TQW->TQW_CORSTA = "3 "
					aAdd(aDados,{"BR_AMARELO"	,cDescSta})
				ElseIf TQW->TQW_CORSTA = "4 "
					aAdd(aDados,{"BR_AZUL"		,cDescSta})
				ElseIf TQW->TQW_CORSTA = "5 "
					aAdd(aDados,{"BR_VERDE"		,cDescSta})
				ElseIf TQW->TQW_CORSTA = "6 "
					aAdd(aDados,{"BR_PRETO"		,cDescSta})
				ElseIf TQW->TQW_CORSTA = "7 "
					aAdd(aDados,{"BR_LARANJA"	,cDescSta})
				ElseIf TQW->TQW_CORSTA = "8 "
					aAdd(aDados,{"BR_CINZA"		,cDescSta})
				ElseIf TQW->TQW_CORSTA = "9 "
					aAdd(aDados,{"BR_MARRON"	,cDescSta})
				Else
					aAdd(aDados,{"BR_BRANCO"	,cDescSta})
				EndIf
			EndIf
		Next xt
	EndIf

	If Len(aDados) > 0
		oIndNG := Array( Len(aDados) )
	EndIf

	Define MsDialog oDlg1New Title OemToAnsi(STR0121) From 0,0 To 25.5,78.5 OF oMainWnd  //"Legendas"

	//Legenda da Situação da O.S.
	@ 008,005 To 65,150 LABEL Oemtoansi(STR0122) OF oDlg1New PIXEL //"Legenda da Situação da O.S."
	@ 017,020 BitMap oBtnddd Resource "BR_AZUL"    Size 17,17 of oDlg1New Pixel Noborder Design
	@ 029,020 BitMap oBtnaaa Resource "BR_CINZA"   Size 17,17 of oDlg1New Pixel Noborder Design
	@ 041,020 BitMap oBtnbbb Resource "BR_VERDE"   Size 17,17 of oDlg1New Pixel Noborder Design
	@ 053,020 BitMap oBtnccc Resource "BR_LARANJA" Size 17,17 of oDlg1New Pixel Noborder Design

	@ 017,032  Say Oemtoansi(STR0123) Of oDlg1New Pixel //"O.S. Liberada na Programação Atual"
	@ 029,032  Say Oemtoansi(STR0124) Of oDlg1New Pixel //"O.S. Liberada C/ Insumos Realizados"
	@ 041,032  Say Oemtoansi(STR0125) Of oDlg1New Pixel //"O.S. Liberada S/ Insumos Realizados"
	@ 053,032  Say Oemtoansi(STR0126) Of oDlg1New Pixel //"O.S. Pendente"

	//Legenda do Status da O.S.
	@ 008,160 To (Len(aDados)*12)+17,305 LABEL Oemtoansi(STR0262) OF oDlg1New PIXEL //"Legenda do Status da O.S."
	For xt := 1 To Len(aDados)
		@ (12*xt)+5,175 BitMap oBtcor__ Resource aDados[xt,1] Size 17,17 of oDlg1New Pixel Noborder Design
		@ (12*xt)+5,187 Say oIndNG[xt] Prompt Space(40) Of oDlg1New Pixel
		oIndNG[xt]:SetText(aDados[xt,2])
	Next xt

	//Legenda da Mão-de-Obra
	@ 73,005 To 131, 150 LABEL Oemtoansi(STR0127) OF oDlg1New PIXEL //"Legenda da Mão-de-Obra"
	@ 082,020 BitMap oBtnaaa Resource "BR_VERDE"    Size 17,17 of oDlg1New Pixel Noborder Design
	@ 094,020 BitMap oBtnbbb Resource "BR_AMARELO"  Size 17,17 of oDlg1New Pixel Noborder Design
	@ 106,020 BitMap oBtnccc Resource "BR_VERMELHO" Size 17,17 of oDlg1New Pixel Noborder Design
	@ 118,020 BitMap oBtnccc Resource "BR_PRETO"    Size 17,17 of oDlg1New Pixel Noborder Design

	@ 082,032  Say Oemtoansi(STR0128) Of oDlg1New Pixel //"Mão-de-Obra alocada abaixo de 90%"
	@ 094,032  Say Oemtoansi(STR0129) Of oDlg1New Pixel //"Mão-de-Obra alocada de 90% a 100%"
	@ 106,032  Say Oemtoansi(STR0130) Of oDlg1New Pixel //"Mão-de-Obra insuficiente"
	@ 118,032  Say Oemtoansi(STR0131) Of oDlg1New Pixel //"Sem O.S. para a Especialidade"

	//Legenda do Calendario
	@ 138,005 To 184, 150 LABEL Oemtoansi(STR0236) OF oDlg1New PIXEL //"Legenda do Calendário"
	@ 147,020 BitMap oBtnaaa Resource 'PMSTASK3' Size 17,17 of oDlg1New Pixel Noborder Design
	@ 159,020 BitMap oBtnbbb Resource 'PMSTASK4' Size 17,17 of oDlg1New Pixel Noborder Design
	@ 171,020 BitMap oBtnccc Resource 'PMSTASK1' Size 17,17 of oDlg1New Pixel Noborder Design

	@ 146,032   Say Oemtoansi(STR0048) Of oDlg1New Pixel //"Sem O.S. no dia."
	cTxt1Tmp := STR0049+" "+STR0050 //"M.D.O. suficiente para realizar" //"a carga horária prevista."
	@ 158,032   Say MemoLine(cTxt1Tmp,45,1) Of oDlg1New Pixel
	@ 162.5,032 Say MemoLine(cTxt1Tmp,45,2) Of oDlg1New Pixel
	cTxt2Tmp := STR0051+" "+STR0050 //"M.D.O. insuficiente para realizar" //"a carga horária prevista."
	@ 170,032   Say MemoLine(cTxt2Tmp,45,1) Of oDlg1New Pixel
	@ 174.5,032 Say MemoLine(cTxt2Tmp,45,2) Of oDlg1New Pixel

	Activate MsDialog oDlg1New Centered

Return(.T.)
//---------------------------------------------------------------------
/*/{Protheus.doc} LiberarOS
Liberar OS

@sample
LiberarOS()

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function LiberarOS()

	Local oDlg3New,nX
	Local cUSACALE   := STR0237 //"L-Liberado"
	Local aUSACALE   := {STR0237,STR0238,STR0239} //"L-Liberado"###"P-Pendente"###"C-Cancelado"
 	Local lUmaVez    := .F.
	Local lSelec     := .F.
	Local lAltCpo    := lAltProg
	Local dDTTemp    := dTT1_DTPROG
	Local oPanel4
	Local nAjusteWin := 0
	Local nAjusteCol := 0
	Local nOpCheck   := 0
	Local cAliasSTL
	Local cTableSTL  := '%' + oTmpSTL:GetRealName() + '%'
	Local cTableSTJ  := '%' + oARQT9903:GetRealName() + '%'

	If lCpoTT2Dt
		If !Empty( (c990TRB3)->DTMPROG )
			dDTTemp := (c990TRB3)->DTMPROG
		EndIf
	EndIf

	If (c990TRB3)->( EoF() )
		If lAltProg
			Help(" ",1,"NGATENCAO",,STR0113,3,1) //"Arquivo vazio!"
		EndIf
		Return .F.
	EndIf

	If lAltProg
		For nX := 1 to Len(aList2)
			If HtoM(aList2[nX][08]) > HtoM(aList2[nX][09])	

					cAliasSTL  := GetNextAlias()

					BeginSQL Alias cAliasSTL

						SELECT COUNT(STJ.ORDEM) AS CONTSTJ 
							FROM %exp:cTableSTJ% STJ
							INNER JOIN %table:ST0% ST0 
								ON  ST0.T0_FILIAL  = %xFilial:ST0% 
								AND ST0.T0_NOME    = %exp:aList2[nX, 2]% 
								AND ST0.%NotDel%
							INNER JOIN %exp:cTableSTL% STL 
								ON  STL.TL_FILIAL  = %xFilial:STL% 
								AND STL.TL_ORDEM   = STJ.ORDEM 
								AND STL.TL_PLANO   = STJ.PLANO 
								AND STL.TL_TIPOREG = "E" 
								AND STL.TL_CODIGO  = ST0.T0_ESPECIA 
								AND STL.%NotDel%
						WHERE			
							STJ.MARCADO   <> ' ' 
							AND STJ.%NotDel%
					EndSQL

					If (cAliasSTL)->CONTSTJ > 0

						If !MsgYesNo(STR0132) //"Mão-de-Obra insuficiente para realizar esta programação. Confirma a liberação?"
							
							(cAliasSTL)->( dbCloseArea() )
							Return .F.	
							
						EndIf

					EndiF
					
					(cAliasSTL)->( dbCloseArea() )

			EndIf
			
		Next nX
	
	EndIf

	If lAltCpo
		If ExistBlock("MNTA990D")
			lAlteraDT := ExecBlock("MNTA990D",.F.,.F.,{(c990TRB1)->ORDEM,(c990TRB1)->DTMPINI})
			If !lAlteraDT
				lAltCpo := .F.
			EndIf
		Else
			If (c990TRB3)->REALIZA == "1"
				dDTTemp  := (c990TRB3)->DTMPINI
				lAltCpo := .F.
				MsgInfo(STR0133) //"A Ordem de Serviço já possui insumo(s) realizado(s), portanto, a data prevista continuará a mesma."
			EndIf
		EndIf
	EndIf

	M->TJ_STATUS := (c990TRB3)->XSTATUS

	If lCpoStatus
		nAjusteWin := 2
		nAjusteCol := 15
	EndIf

	nOpc4Cad := 0
	Define MsDialog oDlg3New Title OemToAnsi(STR0134) From 0,0 To 14+nAjusteWin,65 OF oMainWnd  //"Liberar Ordens de Serviços"

		oDlg3New:LESCCLOSE := .F.

		oPanel4 := TPanel():New(0, 0, Nil, oDlg3New, Nil, .T., .F., Nil, Nil, 0, 0, .T., .F. )
		oPanel4:Align := CONTROL_ALIGN_ALLCLIENT

		@ 010,008 Say Oemtoansi(STR0010) Of oPanel4 Pixel //"Ordem"
		@ 010,045 MsGet (c990TRB3)->ORDEM Size 50,7 Of oPanel4 Pixel When .F.

		@ 023,008 Say Oemtoansi(STR0135) Of oPanel4 Pixel //"Situação"
		@ 023,045 ComboBox cUSACALE ITEMS aUSACALE SIZE 50,7 Of oPanel4 Pixel When .F.

		@ 036,008 Say Oemtoansi(STR0015) Of oPanel4 Pixel //"Data Prevista"
		@ 036,045 MsGet dDTTemp Picture '99/99/9999' Valid fDataSTJ(dDTTemp) Size 50,7 Of oPanel4 Pixel When lAltCpo HASBUTTON

		If lCpoStatus
			@ 049,008 Say Oemtoansi(STR0014) Color CLR_HBLUE Of oPanel4 Pixel //"Status"
			@ 049,045 MsGet M->TJ_STATUS Valid ExistCpo(cTabStatus,M->TJ_STATUS) F3 cTabStatus Picture '@!' Size 50,7 Of oPanel4 Pixel When lAltCpo HASBUTTON
		EndIf

		TRadMenu():New(50+nAjusteCol, 8, {STR0116, STR0351},{|u| IIf (PCount() == 0, nOpCheck, nOpCheck := u)}, ;
						oPanel4,,{|| IIF(nOpCheck <> 0 .And. nOpCheck == 1, lUmaVez := .T., lSelec := .T.)},,,,, ;
						{|| lAltCpo }, 235, 7,,,, .T., .F.) // //"Aplicar as alterações em todas as O.S. listadas?"  ## "Aplicar as alterações em todas as O.S. selecionadas?"

	Activate MsDialog oDlg3New On Init EnchoiceBar(oDlg3New,{|| ( If(VerifLibe( lUmaVez, dDTTemp, lSelec ),(oDlg3New:End() , nOpc4Cad := 1),Nil) ) },{|| oDlg3New:End() }) Centered

	If nOpc4Cad == 1 .And. lAltProg

		If lUmaVez .Or. lSelec

			dbSelectArea( c990TRB3 )
			dbSetOrder( 3 ) // ORDEM + PLANO
			dbGoTop()
			Do While (c990TRB3)->( !EoF() )

				If lSelec .And. Empty( (c990TRB3)->MARCADO )
					(c990TRB3)->( dbSkip() )
					Loop
				EndIf

				If lAltCpo .And. (c990TRB3)->REALIZA == '0'
					fSaveDtOS( c990TRB3, 1, dDTTemp )
				EndIf

				RecLock( c990TRB3, .F. )

					If lCpoTT2Dt
						(c990TRB3)->DTMPROG := dDTTemp
					EndIf

					(c990TRB3)->LIBERA  := '1'
					(c990TRB3)->XSTATUS := M->TJ_STATUS

				(c990TRB3)->( MsUnLock() )

				dbSelectArea( c990TRB2 )
				dbSetOrder( 3 ) // ORDEM + PLANO
				dbGoTop()
				If dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO )

					RecLock( c990TRB2, .F. )

						If lCpoTT2Dt
							(c990TRB2)->DTMPROG := dDTTemp
						EndIf

						(c990TRB2)->LIBERA  := '1'
						(c990TRB2)->XSTATUS := M->TJ_STATUS

					(c990TRB2)->( MsUnLock() )

				EndIf

				(c990TRB3)->( dbSkip() )

			EndDo

			dbSelectArea( c990TRB3 )
			dbSetOrder( nTipoInd )
			dbGoTop()

		Else

			If lAltCpo .And. (c990TRB3)->REALIZA == '0'
				fSaveDtOS( c990TRB3, 1, dDTTemp )
			EndIf

			RecLock( c990TRB3, .F. )

				If lCpoTT2Dt .And. ( (c990TRB3)->REALIZA == '0' .Or. Empty( (c990TRB3)->DTMPROG ) )

					(c990TRB3)->DTMPROG := dDTTemp

				EndIf

				(c990TRB3)->LIBERA  := '1'
				(c990TRB3)->XSTATUS := M->TJ_STATUS

			(c990TRB3)->( MsUnLock() )

			dbSelectArea( c990TRB2 )
			dbSetOrder( 3 ) // ORDEM + PLANO
			dbGoTop()
			If dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO )

				RecLock( c990TRB2, .F. )

					If lCpoTT2Dt .And. ( (c990TRB2)->REALIZA == '0' .Or. Empty( (c990TRB2)->DTMPROG ) )
						(c990TRB2)->DTMPROG := dDTTemp
					EndIf

					(c990TRB2)->LIBERA  := '1'
					(c990TRB2)->XSTATUS := M->TJ_STATUS

				(c990TRB2)->( MsUnLock() )

			EndIf

			dbSelectArea(c990TRB3)

		EndIf

		If !Inclui

			If dDTTemp < dTT1_DTPROG
				dTT1_DTPROG := dDTTemp
				If nOSPrInd == 1
					lMudouDt := .T.
				EndIf
			EndIf
			If dDTTemp > dTT1_DTFIM
				dTT1_DTFIM := dDTTemp
				If nOSPrInd == 1
					lMudouDt := .T.
				EndIf
			EndIf

		Else
			If dDTTemp < dTT1_DTPROG
				dTT1_DTPROG := dDTTemp
				If nOSPrInd == 1
					lMudouDt := .T.
				EndIf
			EndIf
			If dDTTemp > dTT1_DTFIM
				dTT1_DTFIM := dDTTemp
				If nOSPrInd == 1
					lMudouDt := .T.
				EndIf
			EndIf
		EndIf

		Processa( { |lEND| fPrgChgMes( 1, @oCalend ) }, STR0047) // Processando...
		fPrgChgDia( 2 )                                          // Atualiza browse de OS programadas

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} VerifLibe
Valida dialog de liberação

@sample
VerifLibe(lUmaVez, dDtMPIni)

@author Denis Hyroshi de Souza
@since 13/10/2011
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function VerifLibe(lUmaVez, dDtMPIni, lSelec)

	Local aArea     := GetArea()
	Local aAreaTRB  := (c990TRB3)->(GetAreA())
	Local aAreaSTJ  := STJ->(GetArea())
	Local aProblem  := {}
	Local aRet      := {}
	Local nSize     := 0
	Local cPlanoCor := Replicate("0",TAMSX3("TJ_PLANO")[1])
	Local lRet      := .T.
	Local nData, aValuesCZ2

	If !Inclui .And. ( dDtMPIni < dTT1_DTPROG .Or. dDtMPIni > dTT1_DTFIM )

		Help( '', 1, 'NGATENCAO', , STR0136 + Chr( 13 ) + Chr( 10 )+; // A Data Prevista deve estar no período da Programação.
			STR0240 + dToC( dTT1_DTPROG ) + STR0345 + dToC( dTT1_DTFIM ) + '.', 3, 1 ) // Período: De XX/XX/XXXX à XX/XX/XXXX
		lRet := .F.

	Else

		If lUmaVez .Or. lSelec

			dbSelectArea(c990TRB3)
			dbSetOrder(3)
			dbGoTop()
			While (c990TRB3)->( !EoF() )

				If lSelec .And. Empty( (c990TRB3)->MARCADO )
					(c990TRB3)->( dbSkip() )
					Loop
				EndIf

				If (c990TRB3)->PLANO > "000001" .And. (c990TRB3)->SITUACA == "P"

					dbSelectArea("STJ")
					dbSetOrder(6)
					dbSeek(xFilial("STJ")+"B"+(c990TRB3)->CODBEM+(c990TRB3)->CODSER+(c990TRB3)->SEQRELA+DTOS((c990TRB3)->DTORIGI)+"L")
					While !EoF() .And. STJ->TJ_FILIAL == xFilial("STJ") .And. STJ->TJ_TIPOOS == 'B' .And. ;
					STJ->TJ_CODBEM == (c990TRB3)->CODBEM .And. STJ->TJ_SERVICO == (c990TRB3)->CODSER .And. ;
					STJ->TJ_SEQRELA == (c990TRB3)->SEQRELA .And. STJ->TJ_DTORIGI == (c990TRB3)->DTORIGI .And.;
					STJ->TJ_SITUACA == 'L'

						If (c990TRB3)->ORDEM <> STJ->TJ_ORDEM

							MsgStop(STR0271 + (c990TRB3)->ORDEM + STR0272 + STJ->TJ_ORDEM + ").") //"Não é possível liberar a O.S. " ### " pois já existe outra Ordem de Serviço liberada com as mesmas características (O.S. "
							lRet := .F.
							Exit

						EndIf
						dbSelectArea("STJ")
						dbSkip()
					EndDo

					/*----------------------------------------------------------------------------------------------+
					| Valida a existência de ordens com a mesma caracteristica em processo de liberação na prog. OS |
					+----------------------------------------------------------------------------------------------*/
					If fIsLib( (c990TRB3)->CODBEM, (c990TRB3)->CODSER, (c990TRB3)->SEQRELA,;
						(c990TRB3)->DTORIGI, (c990TRB3)->ORDEM, .T. )

						lRet := .F.
						Exit

					EndIf

					/*------------------------------------------------------------+
					| Validação referente a alteração de data nos insumos da O.S. |
					+------------------------------------------------------------*/
					If lRet

						aProblem := fVldAltDtI( (c990TRB3)->ORDEM, (c990TRB3)->PLANO, dDtMPIni )
						nSize    := Len( aRet )

						aSize( aRet, nSize + Len( aProblem ) )

						aCopy( aProblem, aRet, , , nSize + 1 )

					EndIf

				EndIf

				dbSelectArea(c990TRB3)
				dbSkip()

			EndDo

		Else

			If (c990TRB3)->PLANO > "000001" .And. (c990TRB3)->SITUACA == "P"

				dbSelectArea("STJ")
				dbSetOrder( 6 ) // TJ_FILIAL + TJ_TIPOOS + TJ_CODBEM + TJ_SERVICO + TJ_SEQRELA + TJ_DTORIGI + TJ_SITUACA
				dbSeek(xFilial("STJ")+"B"+(c990TRB3)->CODBEM+(c990TRB3)->CODSER+(c990TRB3)->SEQRELA+DTOS((c990TRB3)->DTORIGI) + 'L' )
				While !EoF() .And. STJ->TJ_FILIAL == xFilial("STJ") .And. STJ->TJ_TIPOOS == 'B' .And. ;
				STJ->TJ_CODBEM == (c990TRB3)->CODBEM .And. STJ->TJ_SERVICO == (c990TRB3)->CODSER .And. ;
				STJ->TJ_SEQRELA == (c990TRB3)->SEQRELA .And. STJ->TJ_DTORIGI == (c990TRB3)->DTORIGI .And.;
				STJ->TJ_SITUACA == 'L'

					If (c990TRB3)->ORDEM <> STJ->TJ_ORDEM

						MsgStop(STR0271 + (c990TRB3)->ORDEM + STR0272 + STJ->TJ_ORDEM + ").") //"Não é possível liberar a O.S. " ### " pois já existe outra Ordem de Serviço liberada com as mesmas características (O.S. "
						lRet := .F.
						Exit

					EndIf
					dbSelectArea("STJ")
					dbSkip()
				EndDo

				/*----------------------------------------------------------------------------------------------+
				| Valida a existência de ordens com a mesma caracteristica em processo de liberação na prog. OS |
				+----------------------------------------------------------------------------------------------*/
				If fIsLib( (c990TRB3)->CODBEM, (c990TRB3)->CODSER, (c990TRB3)->SEQRELA,;
					(c990TRB3)->DTORIGI, (c990TRB3)->ORDEM, .F. )

					lRet := .F.

				EndIf

				/*------------------------------------------------------------+
				| Validação referente a alteração de data nos insumos da O.S. |
				+------------------------------------------------------------*/
				If lRet

					aRet := fVldAltDtI( (c990TRB3)->ORDEM, (c990TRB3)->PLANO, dDtMPIni )

				EndIf

			EndIf

		EndIf

		If !Empty( aRet )

			lRet := fShowMsg( aRet )

		EndIf

		// Caso seja um plano preventivo
		If lRet .And. lIntSFC .And. (c990TRB3)->PLANO > cPlanoCor

			dbSelectArea("STJ")
			dbSetOrder(1)
			If dbSeek(xFilial("STJ")+(c990TRB3)->ORDEM+(c990TRB3)->PLANO) .And. ;
			!Empty(STJ->TJ_DTPPINI) .And. !Empty(NGVRFMAQ(STJ->TJ_CODBEM))

				nData := dDtMPIni - STJ->TJ_DTMPINI

				aValuesCZ2 := {}
				aAdd( aValuesCZ2 , {"CZ2_DTBGPL" , STJ->TJ_DTPPINI + nData} )
				aAdd( aValuesCZ2 , {"CZ2_HRBGPL" , Padr(Trim(Transform(STJ->TJ_HOPPINI,"99:99:99")),8,"0")} )
				aAdd( aValuesCZ2 , {"CZ2_DTEDPL" , STJ->TJ_DTPPFIM + nData} )
				aAdd( aValuesCZ2 , {"CZ2_HREDPL" , Padr(Trim(Transform(STJ->TJ_HOPPFIM,"99:99:99")),8,"0")} )
				aAdd( aValuesCZ2 , {"CZ2_TPSTSP" , "1"} )

				If !NGSFCATPRD(STJ->TJ_ORDEM,aValuesCZ2,.F.,.F.)
					NGSFCSNDML(2, {{STJ->TJ_ORDEM,,aValuesCZ2[1],aValuesCZ2[2],aValuesCZ2[3],aValuesCZ2[4]}})
					lRet := .F.
				EndIf
			EndIf
		EndIf

	EndIf

	RestArea(aAreaTRB)
	RestArea(aAreaSTJ)
	RestArea(aArea)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fIsLib
Válida se existem O.S. com as mesma caracteristicas em liberação.
@function

@author Alexandre Santps
@since 11/03/2022

@param cCodBem , string , Código do bem. 
@param cCodSer , string , Código do serviço.
@param cSequen , string , Sequência da manutenção.
@param cDateOr , string , Data origem da O.S.
@param cOrdem  , string , O.S. em validação.
@param lMulti  , boolean, Indica se a liberação é de multiplas O.S. 

@return boolena, Indica se existe O.S. iguais já liberadas.

/*/
//---------------------------------------------------------------------
Static Function fIsLib( cCodBem, cCodSer, cSequen, cDateOr, cOrdem, lMulti )

	Local cAlsTemp := GetNextAlias()
	Local cWhere   := "% AND ( TEMP.LIBERA <> ' ' "
	Local cTable   := "%" + oARQT9903:GetRealName() + "%"
	Local lReturn  := .F.

	If lMulti
		cWhere += " OR TEMP.MARCADO <> ' ' "
	EndIf
	
	cWhere += " ) %"

	BeginSQL Alias cAlsTemp

		SELECT
			TEMP.ORDEM
		FROM
			%exp:cTable% TEMP
		WHERE
			TEMP.CODBEM  = %exp:cCodBem% AND
			TEMP.CODSER  = %exp:cCodSer% AND
			TEMP.SEQRELA = %exp:cSequen% AND
			TEMP.DTORIGI = %exp:cDateOr% AND
			TEMP.ORDEM  <> %exp:cOrdem%  AND
			TEMP.PLANO   > '000001'      AND
			TEMP.SITUACA = 'P'
			%exp:cWhere%

	EndSQL

	If (cAlsTemp)->( !EoF() )

		// Não é possível liberar a O.S. ### pois já existe outra Ordem de Serviço liberada com as mesmas características (O.S.
		MsgStop( STR0271 + cOrdem + STR0272 + (cAlsTemp)->ORDEM + ")." )
		lReturn := .T.

	EndIf

	(cAlsTemp)->( dbCloseArea() )
	
Return lReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} fDataSTJ
Valida data da liberacao da OS

@sample
fDataSTJ(dDTTemp)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fDataSTJ(dDTTemp)

	If !INCLUI
		If dDTTemp < dTT1_DTPROG .Or. dDTTemp > dTT1_DTFIM
			Help(" ",1,"NGATENCAO",,STR0136+Chr(13)+Chr(10)+; //"A Data Prevista deve estar no período da Programação."
			STR0240+DtoC(dTT1_DTPROG)+" à "+DtoC(dTT1_DTFIM),3,1) //"Período: De "
			Return .F.
		EndIf
	EndIf

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} ImprimirOS
Imprimir OS

@sample
ImprimirOS()

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function ImprimirOS()

	Local aMatriOS 	:= {}
	Local ic		:= 0
	Local aMatSX1 	:= {}
	Local aSX1		:= {}
	Local dMENOR   	:= Ctod('  /  /  '),dMAIOR := dMENOR
	Local cMEORD 	:= Space(Len(stj->tj_ordem)), cMAORD := cMEORD
	Local cMEPLA 	:= Space(Len(stj->tj_plano)), cMAPLA := cMEPLA
	Local cBemMe 	:= ""
	Local cBemMa 	:= ""
	Local lIMPOSMNT := ExistBlock("IMPOSMNT")
	Local lMNTIMPOS	:= ExistBlock("MNTIMPOS")
	Local cPrograma := "MNTA990"

	Private aNGBEGINPRM := NGBEGINPRM(,cPrograma,, .F.)

	If (c990TRB3)->(EoF())
		Help(" ",1,"NGATENCAO",,STR0113,3,1) //"Arquivo vazio!"
		Return .F.
	EndIf

	dbSelectArea(c990TRB3)
	nRecTRB3 := Recno()
	dbGoTop()
	While !EoF()
		If !Empty((c990TRB3)->MARCADO)
			dbSelectArea("STJ")
			dbSetOrder(1)
			dbSeek(xFilial("STJ")+(c990TRB3)->ORDEM+(c990TRB3)->PLANO)
			nDiffDias := (c990TRB3)->DTMPROG - STJ->TJ_DTMPINI
			aAdd( aMatriOs , { (c990TRB3)->PLANO , (c990TRB3)->ORDEM , nDiffDias } )

			If Empty(dMENOR)
				dMENOR := (c990TRB3)->DTMPINI
				dMAIOR := dMENOR
				cMEORD := (c990TRB3)->ORDEM
				cMAORD := cMEORD
				cMEPLA := (c990TRB3)->PLANO
				cMAPLA := cMEPLA
				cBemMe := (c990TRB3)->CODBEM
				cBemMa := cBemMe
			Else

				dMENOR := Min(dMENOR,(c990TRB3)->DTMPINI)
				dMAIOR := Max(dMAIOR,(c990TRB3)->DTMPINI)

				If (c990TRB3)->ORDEM < cMEORD
					cMEORD := (c990TRB3)->ORDEM
				EndIf

				If (c990TRB3)->ORDEM > cMAORD
					cMAORD := (c990TRB3)->ORDEM
				EndIf

				If (c990TRB3)->PLANO < cMEPLA
					cMEPLA := (c990TRB3)->PLANO
				EndIf

				If (c990TRB3)->PLANO > cMAPLA
					cMAPLA := (c990TRB3)->PLANO
				EndIf

				If (c990TRB3)->CODBEM < cBemMe
					cBemMe := (c990TRB3)->CODBEM
				EndIf

				If (c990TRB3)->CODBEM > cBemMa
					cBemMa := (c990TRB3)->CODBEM
				EndIf

			EndIf

		EndIf
		dbSelectArea(c990TRB3)
		dbSkip()
	End

	If Empty(Len(aMatriOS))
		MsgInfo(STR0139+" "+STR0244,STR0190)
		dbSelectArea(c990TRB3)
		dbGoTo(nRecTRB3)
		Return
	EndIf

	If lIMPOSMNT

		aMatSX1 := {{'01','S'},{'02',"Z"},;
					{'03','S'},{'04','Z'},;
					{'05','S'},{'06','Z'},;
					{'07',cMEORD},{'08',cMAORD},;
					{'09',Dtoc(dMENOR)},{'10',Dtoc(dMAIOR)}}

		If Dtos(Ctod(aMatSX1[8,2])) < Dtos(Ctod(aMatSX1[7,2]))
			dTAUXI := aMatSX1[7,2]
			aMatSX1[7,2] := aMatSX1[8,2]
			aMatSX1[8,2] := dTAUXI
		EndIf

	ElseIf lMNTIMPOS //Ponto de entrada que realiza a impressão de Ordem de Serviço.
		ExecBlock( 'MNTIMPOS', .F., .F., { STJ->TJ_PLANO, STJ->TJ_ORDEM, STJ->TJ_DTMPINI, , , aMatriOs, cTempStl } )
	Else
		aMatSX1 := {{'01',cMEPLA},{'02',cMAPLA},;
					{'07',Space(Len(stj->tj_ccusto))},{'08',Replicate('Z',Len(stj->tj_ccusto))},;
					{'09',Space(Len(stj->tj_centrab))},{'10',Replicate('Z',Len(stj->tj_centrab))},;
					{'11',Space(Len(stj->tj_codarea))},{'12',Replicate('Z',Len(stj->tj_codarea))},;
					{'13',cMEORD},{'14',cMAORD},;
					{'15',Dtoc(dMENOR)},{'16',Dtoc(dMAIOR)}}


		//Array para o relatorio MNTR676
		aMatSX16 := {{'01',cMEPLA},{'02',cMAPLA},;
					 {'03',cBemMe},{'04',cBemMa},;
					 {'05',cMEORD},{'06',cMAORD},;
					 {'07',Dtoc(dMENOR)},{'08',Dtoc(dMAIOR)}}

		For ic := 1 To Len(aMatSX1)
			If ValType(aMatSX1[ic][2]) == "C"
				aMatSX1[ic][2] := If(aMatSX1[ic][2] = 'S',Space(Len(aMatSX1[ic][2])),;
				If(aMatSX1[ic][2] = 'Z',Replicate('Z',Len(aMatSX1[ic][2])),aMatSX1[ic][2]))
			EndIf
		Next ic

	EndIf

	If lIMPOSMNT // Ponto de entrada que realiza a impressão do Relatório Padrão ou Específico do Cliente.
		ExecBlock( 'IMPOSMNT', .F., .F., { .F., cMEPLA, cMAPLA, aMatriOS, cTempStl } )
	ElseIf !lMNTIMPOS //Ponto de entrada que realiza a impressão de Ordem de Serviço.

		aAdd( aSX1, aMatSX1  )
		aAdd( aSX1, aMatSX16 )
		
		nDiffData := 0
		NGIMP675( , , .F., , , aSX1, aMatriOS )

	EndIf

	dbSelectArea(c990TRB3)
	dbGoTo(nRecTRB3)
	While !EoF()
		If !Empty((c990TRB3)->MARCADO)
			If !Empty(cStExec990)
				RecLock(c990TRB3,.F.)
				(c990TRB3)->XSTATUS := cStExec990
				(c990TRB3)->(MsUnLock())
				dbSelectArea(c990TRB2)
				dbSetOrder(3)
				dbGoTop()
				If dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO )
					(c990TRB2)->XSTATUS := cStExec990
				EndIf
				dbSelectArea(c990TRB3)
			EndIf
		EndIf
		(c990TRB3)->(dbSkip())
	End
	dbGoTo(nRecTRB3)

	NGRETURNPRM(aNGBEGINPRM)

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fMarcaAll
Marca todos

@sample
fMarcaAll(nTipo)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Function fMarcaAll(nTipo)
	Local aArea
	If nTipo == 1
		aArea := (c990TRB1)->(GetArea())
		dbSelectArea(c990TRB1)
		dbSetOrder(nTipoInd)
		dbGoTop()
		While !EoF()
			(c990TRB1)->MARCADO := cMARCA
			dbSkip()
		End
		RestArea(aArea)
		oMARK1:Refresh()
	Else
		aArea := (c990TRB3)->(GetArea())
		dbSelectArea(c990TRB3)
		dbSetOrder(nTipoInd)
		dbGoTop()
		While !EoF()
			(c990TRB3)->MARCADO := cMARCA
			dbSelectArea(c990TRB2)
			dbSetOrder(3)
			dbGoTop()
			If dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO )
				(c990TRB2)->MARCADO := cMARCA
			EndIf
			dbSelectArea(c990TRB3)
			dbSkip()
		End
		RestArea(aArea)
		oMARK2:Refresh()
	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fDesmaAll
Desmarca todos

@sample
fDesmaAll(nTipo)

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Function fDesmaAll(nTipo)

	If nTipo == 1
		dbSelectArea(c990TRB1)
		dbSetOrder(nTipoInd)
		dbGoTop()
		While !EoF()
			(c990TRB1)->MARCADO := "  "
			dbSkip()
		End
		dbGoTop()
		oMARK1:Refresh()
	Else
		dbSelectArea(c990TRB3)
		dbSetOrder(nTipoInd)
		dbGoTop()
		While !EoF()
			(c990TRB3)->MARCADO := "  "
			dbSelectArea(c990TRB2)
			dbSetOrder(3)
			dbGoTop()
			If dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO )
				(c990TRB2)->MARCADO := "  "
			EndIf
			dbSelectArea(c990TRB3)
			dbSkip()
		End
		dbGoTop()
		oMARK2:Refresh()
	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fImpProg
Imprimir Programacao

@sample
fImpProg()

@author Denis Hyroshi de Souza
@since 17/04/2003
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fImpProg()

	Local nX
	Local aArea    := GetArea()
	Local nTot01   := 0
	Local nTot02   := 0
	Local nTot03   := 0
	Local nTotDisp := 0
	Local nTotProg := 0
	Local nTotTecn := 0
	Local cManut

	Private oPrint
	Private oFont12,oFont13,oFont20
	Private lin

	// Permite a impressão de relatório personalizado
	If ExistBlock("MNTA9908")
		Return ExecBlock("MNTA9908",.F.,.F.,{c990TRB3})
	EndIf

	oFont08	:= TFont():New("Arial",07,07,,.F.,,,,.F.,.F.)
	oFont12	:= TFont():New("Arial",09,09,,.T.,,,,.F.,.F.)
	oFont13	:= TFont():New("Arial",08,08,,.F.,,,,.F.,.F.)
	oFont20	:= TFont():New("Arial",12,12,,.T.,,,,.F.,.F.)

	If ExistBlock("MNTA9908")
		Return ExecBlock("MNTA9908",.F.,.F.,{c990TRB3})
	EndIf

	oPrint	:= TMSPrinter():New(OemToAnsi(STR0145)) //"Relatório da Programação de O.S."
	If !oPrint:Setup() //Apresenta Janela de Configuração da impressora
		Return .F.
	EndIf
	oPrint:SetLandscape()

	lin := 9999
	nPag1 := 0
	lNaoImpr := .T.
	dbSelectArea(c990TRB3)
	dbSetOrder(nTipoInd)
	dbGoTop()
	ProcRegua((c990TRB3)->(RecCount()))
	While !EoF()
		IncProc()

		dbSelectArea("STJ")
		dbSetOrder(1)
		dbSeek( xFilial("STJ") + (c990TRB3)->ORDEM + (c990TRB3)->PLANO )

		dbSelectArea("ST4")
		dbSetOrder(1)
		dbSeek( xFilial("ST4") + STJ->TJ_SERVICO )

		dbSelectArea("STF")
		dbSetOrder(1) //TF_FILIAL+TF_CODBEM+TF_SERVICO+TF_SEQRELA
		dbSeek( xFilial("STF") + STJ->TJ_CODBEM + STJ->TJ_SERVICO + STJ->TJ_SEQRELA)
		cManut := STF->TF_NOMEMAN //Retorna o Nome da Manutenção na STF.

		lTemEspec := .F.

		dbSelectArea(c990TRBE)
		dbSetOrder(02)
		dbGoTop()
		dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO )
		While !EoF() .And. (c990TRB3)->ORDEM + (c990TRB3)->PLANO == (c990TRBE)->ORDEM + (c990TRBE)->PLANO

			Somalin1(60,.T.)
			lTemEspec := .T.

			cHoraHomem := MtoH( HtoM((c990TRBE)->TEMPRO) / (c990TRBE)->QTDTEC )
			oPrint:Say(lin,0110,(c990TRB3)->EQUIPE,oFont13)
			oPrint:Say(lin,0260,(c990TRB3)->CODBEM,oFont13)
			oPrint:Say(lin,0520,(c990TRB3)->ORDEM,oFont13)
			oPrint:Say(lin,0660,Substr(Alltrim(ST4->T4_NOME),1,25),oFont13)
			oPrint:say(lin,1050,Substr(Alltrim(cManut),1,25),oFont13)
			oPrint:Say(lin,1600,Substr(Alltrim((c990TRBE)->DESCRI),1,30),oFont13)
			oPrint:Say(lin,2240,TransForm((c990TRBE)->QTDTEC,"9999"),oFont13,,,,1)
			oPrint:Say(lin,2280,cHoraHomem,oFont13)
			oPrint:Say(lin,2450,(c990TRBE)->TEMPRO,oFont13)
			//oPrint:Say(lin,2650,(c990TRBE)->OBS,oFont13)

			dbSelectArea(c990TRBE)
			dbSkip()
		End

		If !lTemEspec
			Somalin1(60,.T.)
			oPrint:Say(lin,0110,(c990TRB3)->EQUIPE,oFont13)
			oPrint:Say(lin,0260,(c990TRB3)->CODBEM,oFont13)
			oPrint:Say(lin,0520,(c990TRB3)->ORDEM,oFont13)
			oPrint:Say(lin,0660,Substr(Alltrim(ST4->T4_NOME),1,25),oFont13)
			oPrint:say(lin,1050,Substr(Alltrim(cManut),1,25),oFont13)
		EndIf

		dbSelectArea(c990TRB3)
		dbSkip()
	End

	dbSelectArea(c990TRB3)
	dbGoTop()

	If !lNaoImpr
		If lin + 310 + (Len(aList2) * 60) > 2350
			lin := 9999
		EndIf
		For nX := 1 to Len(aList2)
			If nX == 1
				Somalin1(150,.F.)
				oPrint:Say(lin,130,STR0146,oFont20) //"Resumo da Programação - Homem Hora Disponível x Programado"
				Somalin1(080,.F.)
				oPrint:Line(lin-10,100,lin-10,2300)
				oPrint:Line(lin+60,100,lin+60,2300)
				oPrint:Say(lin,0130,STR0074,oFont12) //"Especialidade"
				oPrint:Say(lin,0730,STR0147,oFont12) //"Qtde."
				oPrint:Say(lin,0850,STR0148,oFont12) //"HH Disponível"
				oPrint:Say(lin,1150,STR0149,oFont12) //"HH Programado"
				oPrint:Say(lin,1450,STR0150,oFont12) //"Diferença"
				oPrint:Say(lin,1700,STR0151,oFont12) //"Backlog (HH)"
				oPrint:Say(lin,1970,STR0152,oFont12) //"Backlog (Dias)"
				Somalin1(20,.F.)
			EndIf
			Somalin1(60,.F.)
			oPrint:Say(lin,0130,aList2[nX][02],oFont13)
			oPrint:Say(lin,0820,Alltrim(Str(aList2[nX][03]+aList2[nX][04]-aList2[nX][06],6)),oFont13,,,,1)
			oPrint:Say(lin,0850,aList2[nX][09],oFont13)
			oPrint:Say(lin,1150,aList2[nX][08],oFont13)
			nDiff := HtoM(aList2[nX][09])-HtoM(aList2[nX][08])
			If nDiff < 0
				nDiff := nDiff * -1
				oPrint:Say(lin,1440,"-"+MtoH( nDiff ),oFont13)
			Else
				oPrint:Say(lin,1450,MtoH( nDiff ),oFont13)
			EndIf

			nHrTRBE := 0
			dbSelectArea(c990TRBE)
			dbSetOrder(3)
			dbSeek(aList2[nX][02])
			While !EoF() .And. Alltrim(aList2[nX][02]) == Alltrim((c990TRBE)->DESCRI)
				nHrTRBE += HtoM((c990TRBE)->TEMREA)
				dbSkip()
			End
			nPart01  := nHrTRBE / 60
			nPart02  := HtoM(aList2[nX][09]) / 60
			nBackLog := nPart01 / ( nPart02 * 0.7 )
			oPrint:Say(lin,1700,MtoH(nHrTRBE),oFont13)
			oPrint:Say(lin,2220,Transform( nBackLog ,"@E 999,999.99"),oFont13,,,,1)

			nTot01   += nPart01
			nTot02   += nPart02
			nTot03   += nHrTRBE
			nTotDisp += HtoM(aList2[nX][09])
			nTotProg += HtoM(aList2[nX][08])
			nTotTecn += aList2[nX][03]+aList2[nX][04]-aList2[nX][06]

			If nX == Len(aList2)
				Somalin1(60,.F.)
				oPrint:Line(lin-10,100,lin-10,2300)
				oPrint:Say(lin,0130,STR0153,oFont13) //"Total"
				oPrint:Say(lin,0820,Alltrim(Str(nTotTecn,6)),oFont13,,,,1)
				oPrint:Say(lin,0850,MtoH(nTotDisp),oFont13)
				oPrint:Say(lin,1150,MtoH(nTotProg),oFont13)
				nDiff := nTotDisp-nTotProg
				nBackLog := nTot01 / ( nTot02 * 0.7 )
				If nDiff < 0
					nDiff := nDiff * -1
					oPrint:Say(lin,1440,"-"+MtoH( nDiff ),oFont13)
				Else
					oPrint:Say(lin,1450,MtoH( nDiff ),oFont13)
				EndIf
				oPrint:Say(lin,1700,MtoH(nTot03),oFont13)
				oPrint:Say(lin,2220,Transform( nBackLog ,"@E 999,999.99"),oFont13,,,,1)
			EndIf
		Next nX

		If lin > 2100
			lin := 9999
			Somalin1(60,.F.)
			lin := 500
		Else
			lin := 2200
		EndIf
		oPrint:Line(lin,100,lin,1000)
		oPrint:Say(lin+20,400,STR0154,oFont13) //"Aprovação Execução"
		oPrint:Line(lin,2000,lin,2900)
		oPrint:Say(lin+20,2300,STR0155,oFont13) //"Aprovação Planejamento"

		oPrint:EndPage()
	EndIf

	oPrint:Preview()
	RestArea(aArea)

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} Somalin1
Somalinha

@sample
Somalin1(nLinha,lCabec)

@author Denis Hyroshi de Souza
@since 17/04/2003
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function Somalin1(nLinha,lCabec)
	Local cSMCOD := IIf(FindFunction("FWGrpCompany"),FWGrpCompany(),SM0->M0_CODIGO)
	Local cSMFIL := IIf(FindFunction("FWCodFil"),FWCodFil(),SM0->M0_CODFIL)

	lin += nLinha
	If lin > 2300
		If !lNaoImpr
			oPrint:EndPage()
		EndIf
		nPag1++
		oPrint:StartPage()

		cFileLogo := cPathSiga+"lgrl"+cSMCOD+cSMFIL+".bmp"
		If File(cFileLogo)
			oPrint:sayBitMap(150,150,cFileLogo,370,120)
		Else
			cFileLogo := cPathSiga+"lgrl"+cSMCOD+".bmp"
			If File(cFileLogo)
				oPrint:sayBitMap(150,150,cFileLogo,370,120)
			EndIf
		EndIf

		lin := 200
		cDescTit := ""
		If !Empty(cTT1_DESCRI)
			cDescTit := Alltrim(cTT1_DESCRI)
		Else
			cDescTit := STR0098 //"PROGRAMAÇÃO"
		EndIf
		If nOSPrInd == 2
			cDescTit += STR0156 + DtoC(_dDiaAtu) //" - PERÍODO: "
		Else
			cDescTit += STR0156 + DtoC(dTT1_DTPROG) + " - " + DtoC(dTT1_DTFIM) //" - PERÍODO: "
		EndIf
		oPrint:Say(lin,800,cDescTit,oFont20)
		oPrint:Say(lin,2700,STR0157+cTT1_CODIGO,oFont20) //"NÚMERO: "

		lin := 320
		If lCabec
			oPrint:Line(lin-10,100,lin-10,3100)
			oPrint:Line(lin+60,100,lin+60,3100)
			oPrint:Say(lin,0110,STR0013,oFont12) //"Equipe"
			oPrint:Say(lin,0260,STR0158,oFont12) //"Equipamento"
			oPrint:Say(lin,0520,STR0010,oFont12) //"Ordem"
			oPrint:Say(lin,0660,STR0159,oFont12) //"Serviço"
			oPrint:Say(lin,1050,STR0316,oFont12) //"Nome da Manutenção"
			oPrint:Say(lin,1600,STR0074,oFont12) //"Especialidade"
			oPrint:Say(lin,2140,STR0147,oFont12) //"Qtde."
			oPrint:Say(lin,2280,STR0160,oFont12) //"Tempo"
			oPrint:Say(lin,2450,STR0161,oFont12) //"HH"
			//oPrint:Say(lin,2650,STR0144,oFont12) //"Executante"
			lin := 400
		EndIf

		lNaoImpr := .F.
	EndIf
Return .T.

//----------------------------------------------------------------
/*/{Protheus.doc} fImpRecursos
Imprimir Recursos das OS

@sample
fImpRecursos()

@author Denis Hyroshi de Souza
@since 17/04/2003
@version 1.0
/*/
//----------------------------------------------------------------
Static Function fImpRecursos()

	Local nX

	Local lImpProd := .F.
	Local lImpFer  := .F.
	Local lImpMDO  := .F.

	Private oPrint
	Private lImprime := .F.

	DEFINE FONT oFont08 NAME  "Arial"  SIZE 0,08 OF oPrint
	DEFINE FONT oFont12 NAME  "Arial"  SIZE 0,10 OF oPrint
	DEFINE FONT oFont13 NAME  "Arial"  SIZE 0,09 OF oPrint
	DEFINE FONT oFont20 NAME  "Arial"  SIZE 0,12 OF oPrint BOLD

	oPrint:= FWMsPrinter():New(STR0162,6,.T., ,.F., , , , ,.F., , .T., )

	// Validação para verificar se o caminho da impressão foi definido.
	// Caso o caminho seja vazio, significa que a impressão foi cancelada
	// na tela de setup. Dessa forma retorna false, cancelando o resto da impressão.
	// Essa validação é necessária, visto que, mesmo cancelando a impressão
	// a função continuava a utilizar o objeto oPrint, e gerava erro log por
	// não ser possível setar algumas condições.
	// OS 025396
	IF Empty(oPrint:cPathpdf)
		Return .F.
	EndIf

	oPrint:SetPaperSize(9)
	nPag1    := 0
	lNaoImpr := .T.
	ProcRegua(Len(aList2)+Len(aList3)+Len(aList4)+Len(aList5))

	nLin := 0

	For nX := 1 to Len( aList2 )
		IncProc()
		If Empty(aList2[nX][02])
			Loop
		EndIf

		// Como sempre será o primeiro insumo a ser impresso, não necessita de uma
		// variável que controle se foi ou não impresso, pois a única situação que
		// será impresso será na primeira linha
		If nLin == 0 .Or. nLin > 2100
			fImpCabec(1,.T.)
		EndIf

		oPrint:Say(nLin,0100,aList2[nX][11],oFont13) //Código
		oPrint:Say(nLin,0200,Substr( aList2[nX][02],1,23 ),oFont13) //Especialidade
		oPrint:Say(nLin,0490,Transform(aList2[nX][03],"999999"),oFont13) //Total Técnicos
		oPrint:Say(nLin,0915,Transform(aList2[nX][04],"999999"),oFont13) //Técnicos Adicionais
		oPrint:Say(nLin,1020,Transform(aList2[nX][05],"@E 999.9"),oFont13) //Dias Adicionais
		oPrint:Say(nLin,1365,Transform(aList2[nX][06],"999999"),oFont13) //Técnicos Ausentes
		oPrint:Say(nLin,1470,Transform(aList2[nX][07],"@E 999.9"),oFont13) //Dias Ausentes
		oPrint:Say(nLin,1645,aList2[nX][08],oFont13) //Tempo Programado
		oPrint:Say(nLin,1940,aList2[nX][09],oFont13) //Tempo Disponivel
		If HtoM(aList2[nX][09]) > 0
			nPerc := (100 / HtoM(aList2[nX,9]) ) * HtoM(aList2[nX,8])
			If nPerc < 0
				cPerc := "-"+Alltrim( Transform( nPerc ,"@E 999,999.9") )
			Else
				cPerc := Alltrim( Transform( nPerc ,"@E 999,999.9") )
			Endif
			oPrint:Say(nLin,2190,cPerc + " %",oFont13) //% Disponivel
		Else
			oPrint:Say(nLin,2190,"-",oFont13) //% Disponivel
		Endif
		nLin += 30

		If !lImprime
			lImprime := .T.
		EndIf

	Next nX

	For nX := 1 To Len( aList3 )
		IncProc()
		If Empty(aList3[nX][02])
			Loop
		EndIf

		If nLin == 0 .Or. nLin > 2100
			fImpCabec( 2, .T. )
			lImpProd := .T.
		ElseIf !lImpProd
			fImpCabec( 2, .F. )
			lImpProd := .T.
		EndIf

		oPrint:Say(nLin,0100,aList3[nX][01],oFont13) //Ordem
		oPrint:Say(nLin,0200,aList3[nX][02],oFont13) //Codigo
		oPrint:Say(nLin,0420,SubStr( aList3[nX][03],1,12 ),oFont13) //Produto
		oPrint:Say(nLin,0670,Transform(aList3[nX][04],"@E 999,999.99"),oFont13) //Qtd. Necessária
		oPrint:Say(nLin,0820,NGSEEK("SB1",aList3[nX][02],1,"B1_UM"),oFont13) //Unidade
		oPrint:Say(nLin,1010,Transform(aList3[nX][05],"@E 999,999,999.99"),oFont13) //Estoque Fisico
		oPrint:Say(nLin,1280,Transform(aList3[nX][06],"@E 999,999,999.99"),oFont13) //Qtd. em Estoque
		oPrint:Say(nLin,1440,aList3[nX][10],oFont13) //Numero SA
		oPrint:Say(nLin,1630,aList3[nX][11],oFont13) //Item
		oPrint:Say(nLin,1900,aList3[nX][07],oFont13) //Numero SC
		oPrint:Say(nLin,2180,DtoC(aList3[nX][08]),oFont13) //Data Prevista

		nLin += 30

		If !lImprime
			lImprime := .T.
		EndIf

	Next nX

	For nX := 1 To Len( aList4 )
		IncProc()
		If Empty(aList4[nX][02])
			Loop
		EndIf

		If nLin == 0 .Or. nLin > 2100
			fImpCabec( 3, .T. )
			lImpFer := .T.
		ElseIf !lImpFer
			fImpCabec( 3, .F. )
			lImpFer := .T.
		EndIf

		oPrint:Say(nLin,0100,aList4[nX][01],oFont13) //"Ordem"
		oPrint:Say(nLin,0230,aList4[nX][02],oFont13) //"Codigo"
		oPrint:Say(nLin,0430,aList4[nX][03],oFont13) //"Descrição"
		oPrint:Say(nLin,1380,aList4[nX][04],oFont13) //"Qtd. Necessária"

		nLin += 30

		If !lImprime
			lImprime := .T.
		EndIf

	Next nX


	For nX := 1 to Len(aList5)
		IncProc()
		If Empty(aList5[nX][02])
			Loop
		EndIf

		If nLin == 0 .Or. nLin > 2100
			fImpCabec( 4, .T. )
			lImpMDO := .T.
		ElseIf !lImpMDO
			fImpCabec( 4, .F. )
			lImpMDO := .T.
		EndIf

		oPrint:Say(nLin,0100,aList5[nX][02],oFont13) //Matricula
		oPrint:Say(nLin,0230,SubStr( aList5[nX][03],1,30 ),oFont13) //Nome
		oPrint:Say(nLin,0680,aList5[nX][08],oFont13) //Cód. Especialidade
		oPrint:Say(nLin,0840,aList5[nX][04],oFont13) //Especialidade
		oPrint:Say(nLin,1450,aList5[nX][05],oFont13) //Tempo Programado
		oPrint:Say(nLin,1750,aList5[nX][06],oFont13) //Tempo Disponivel
		If HtoM(aList5[nX][06]) > 0
			nPerc := (100 / HtoM(aList5[nX,6]) ) * HtoM(aList5[nX,5])
			If nPerc < 0
				cPerc := "-"+Alltrim( Transform( nPerc ,"@E 999,999.9") )
			Else
				cPerc := Alltrim( Transform( nPerc ,"@E 999,999.9") )
			Endif
			oPrint:Say(nLin,2180,cPerc + " %",oFont13) //% Disponivel
		Else
			oPrint:Say(nLin,2180,"-",oFont13) //% Disponivel
		Endif

		nLin += 30

		If !lImprime
			lImprime := .T.
		EndIf

	Next nX

	If !lImprime
		oPrint:Say(nlin,0100,STR0326,oFont13) //"Não há dados para impressão do relatório."
	Else
		If nlin > 2100
			fImpCabec(0,.T.)
		Else
			nlin := 2200
		Endif

		oPrint:Line(nlin,100,nlin,1000)
		oPrint:Line(nlin,1420,nlin,2320)

		nlin += 20
		oPrint:Say(nlin,400,STR0154,oFont13) //"Aprovação Execução"
		oPrint:Say(nlin,1720,STR0155,oFont13) //"Aprovação Planejamento"
		oPrint:EndPage()
	Endif

	oPrint:Preview()

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fImpSA
Imprimir Solicitacoes de Armazem

@sample
fImpSA()

@author Denis Hyroshi de Souza
@since 17/04/2003
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fImpSA()

	Local aArea := GetArea(),nX
	Private oPrint
	Private oFont12,oFont13,oFont20
	Private lin
	oFont08	:= TFont():New("Arial",08,08,,.F.,,,,.F.,.F.)
	oFont12	:= TFont():New("Arial",08,08,,.T.,,,,.F.,.F.)
	oFont13	:= TFont():New("Arial",09,09,,.F.,,,,.F.,.F.)
	oFont20	:= TFont():New("Arial",12,12,,.T.,,,,.F.,.F.)

	oPrint	:= TMSPrinter():New(OemToAnsi(STR0177)) //"Relatório de Solicitação ao Armazém"
	If !oPrint:Setup() //Apresenta Janela de Configuração da impressora
		Return .F.
	EndIf
	oPrint:SetLandScape() //paisagem

	lin   := 9999
	nPag1 := 0
	lNaoImpr := .T.
	ProcRegua(Len(aList3))
	aSORT(aList3,,,{|x,y| x[10]+x[11] < y[10]+y[11] })
	For nX := 1 to Len(aList3)
		IncProc()
		If Empty(aList3[nX][10]) .Or. Empty(aList3[nX][11])
			Loop
		EndIf

		dbSelectArea("SB1")
		dbSetOrder(1)
		dbSeek(xFilial("SB1")+aList3[nX][02])
		dbSelectArea("STJ")
		dbSetOrder(1)
		dbSeek(xFilial("STJ")+aList3[nX][01]+aList3[nX][09])
		dbSelectArea("SCP")
		dbSetOrder(1)
		dbSeek(xFilial("SCP")+aList3[nX][10]+aList3[nX][11])

		Somalin2()
		oPrint:Say(lin,0100,aList3[nX][01],oFont08) //Ordem Serviço
		oPrint:Say(lin,0250,STJ->TJ_CODBEM,oFont08) //Bem
		oPrint:Say(lin,0600,aList3[nX][10],oFont08) //Numero SA
		oPrint:Say(lin,0800,aList3[nX][11],oFont08) //Item
		oPrint:Say(lin,0900,Substr(aList3[nX][03],1,40),oFont08) //Produto
		oPrint:Say(lin,1730,Transform(aList3[nX][04],"@E 999,999.99"),oFont08,,,,1) //Quantidade
		oPrint:Say(lin,1950,Transform(aList3[nX][05],"@E 999,999.99"),oFont08,,,,1) //Estoque Fisico
		oPrint:Say(lin,2150,Transform(aList3[nX][06],"@E 999,999.99"),oFont08,,,,1) //Quantidade Estoque
		oPrint:Say(lin,2200,DtoC(SCP->CP_EMISSAO),oFont08) //Emissao
		oPrint:Say(lin,2350,SCP->CP_CC,oFont08) //Centro de Custo
		oPrint:Say(lin,2700,Upper(SCP->CP_SOLICIT),oFont08) //Solicitante

	Next nX

	If !lNaoImpr
		oPrint:EndPage()
	EndIf

	oPrint:Preview()

	aSORT(aList3,,,{|x,y| x[1] < y[1]})

	RestArea(aArea)
Return
//---------------------------------------------------------------------
/*/{Protheus.doc} Somalin2
Somalinha

@sample
Somalin2()

@author Denis Hyroshi de Souza
@since 17/04/2003
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function Somalin2()
	Local cSMCOD := IIf(FindFunction("FWGrpCompany"),FWGrpCompany(),SM0->M0_CODIGO)
	Local cSMFIL := IIf(FindFunction("FWCodFil"),FWCodFil(),SM0->M0_CODFIL)

	lin += 60
	If lin > 2300
		If !lNaoImpr
			oPrint:EndPage()
		EndIf
		nPag1++
		oPrint:StartPage()

		cFileLogo := cPathSiga+"lgrl"+cSMCOD+cSMFIL+".bmp"
		If File(cFileLogo)
			oPrint:sayBitMap(100,100,cFileLogo,370,120)
		Else
			cFileLogo := cPathSiga+"lgrl"+cSMCOD+".bmp"
			If File(cFileLogo)
				oPrint:sayBitMap(100,100,cFileLogo,370,120)
			EndIf
		EndIf

		lin := 150
		oPrint:Say(lin,1100,STR0177,oFont20) //"RELATÓRIO DE SOLICITAÇÃO AO ARMAZÉM"
		oPrint:Say(130,3050,Alltrim(Str(nPag1,6)),oFont08)
		lin := 250

		oPrint:Line(lin-10,100,lin-10,3170)
		oPrint:Line(lin+50,100,lin+50,3170)

		oPrint:Say(lin,0100,STR0010,oFont12) //"Ordem"
		oPrint:Say(lin,0250,STR0011,oFont12) //"Bem"
		oPrint:Say(lin,0600,STR0178,oFont12) //"Núm. S.A."
		oPrint:Say(lin,0800,STR0174,oFont12) //"Item"
		oPrint:Say(lin,0900,STR0031,oFont12) //"Produto"
		oPrint:Say(lin,1730,STR0179,oFont12,,,,1) //"Qtd. na S.A."
		oPrint:Say(lin,1950,STR0223,oFont12,,,,1) //"Estoque Físico"
		oPrint:Say(lin,2150,STR0241,oFont12,,,,1) //"Qtd. Estoque"
		oPrint:Say(lin,2200,STR0181,oFont12) //"Emissão"
		oPrint:Say(lin,2350,STR0182,oFont12) //"Centro de Custo"
		oPrint:Say(lin,2700,STR0183,oFont12) //"Solicitante"


		lin := 315
		lNaoImpr := .F.
	EndIf
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fDispoST1
Verifica a disponibilidade por Especialidade

@sample
fDispoST1(lProc,lAltList,dIniData,dFimData)

@author Denis Hyroshi de Souza
@since 17/04/2003
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fDispoST1(lProc,lAltList,dIniData,dFimData)

	Local nYYY      := 0
	Local nPosDisp  := 0
	Local nDiaSem   := 0
	Local aDiaH9 	:= {}
	Local lTemDispo := !lNGFlut
	Local lMltplEsp := .T.  // Define se a mão de obra possui multiplas especialidades
	Local cAliasST1 := GetNextAlias()
	Local cAliasTP6 := GetNextAlias()
	Local cCamQuery := '' //Campo a ser Adicionado na query
	Local nQntDias 	:= 0
	Local nCnt		:= 0
	Local dDiaInicio
	Local dDataFimD
	Local dDiaTp6

	aTurnoPer := {}
	aEquipDia := {}
	aDispon   := {}
	aDispFunc := {}

	nPosDisp := aScan(aDisponBkp,{|x| x[1] == dIniData   .And. x[2] == dFimData      .And.;
									x[3] == M->TT1_EQUDE .And. x[4] == M->TT1_EQUATE .And.;
									x[5] == M->TT1_CCDE  .And. x[6] == M->TT1_CCATE })
	If nPosDisp > 0
		aDispon   := aClone( aDisponBkp[nPosDisp,7] )
		aDispFunc := aClone( aDisponBkp[nPosDisp,8] )
	EndIf

	dbSelectArea("ST1")
	dbSetOrder(01)
	dbSeek(xFilial("ST1"))
	If lProc
		ProcRegua(LastRec())
	EndIf

	If nPosDisp == 0

		// Caso utilize turno flutuante aciona o campo T1_EQUIPE
		cCamQuery := IIf( lNGFlut, '%, ST1.T1_EQUIPE%', '%%' )

		BeginSQL Alias cAliasST1

			SELECT
				ST1.T1_FILIAL ,
				ST1.T1_CODFUNC,
				ST1.T1_EQUIPE ,
				ST1.T1_TURNO  ,
				ST1.T1_NOME   ,
				ISNULL( ST2.T2_ESPECIA, '' ) AS T2_ESPECIA
				%exp:cCamQuery%
			FROM
				%table:ST1% ST1
			LEFT JOIN
				%table:ST2% ST2 ON
					( ST2.T2_FILIAL  = %xFilial:ST2%  AND
		  			  ST2.T2_CODFUNC = ST1.T1_CODFUNC AND
					  ST2.%NotDel% )
			WHERE
				ST1.T1_EQUIPE BETWEEN %exp:M->TT1_EQUDE% AND %exp:M->TT1_EQUATE% AND
				ST1.T1_FILIAL  =  %xFilial:ST1% AND
				ST1.T1_DISPONI <> 'N'           AND
				ST1.%NotDel%

		EndSQL

		Do While (cAliasST1)->( !EoF() )

			IncProc()

			// Caso turno flutuante habilitado e campo T1_EQUIPE encontra-se preenchido para o funcionário
			If lNGFlut .And. !Empty( (cAliasST1)->T1_EQUIPE )

				lTemDispo := .F.

				cAliasTP6 := GetNextAlias()

				BeginSQL Alias cAliasTP6

					SELECT 
						TP6_CALEND,
						TP6_DTINI ,
						TP6_DTFIM

					FROM
						%table:TP6% 
					WHERE
						TP6_FILIAL = %xFilial:TP6%  AND
						TP6_EQUIPE = %exp:(cAliasST1)->T1_EQUIPE% AND
						TP6_DTFIM >= %exp:dIniData% AND
						TP6_DTINI <= %exp:dFimData% AND
						( ( TP6_DTINI <= %exp:dFimData% AND
						    TP6_DTFIM >= %exp:dIniData% ) OR
						  ( TP6_DTINI <= %exp:dFimData% AND
						    TP6_DTFIM >= %exp:dFimData% ) ) AND
					    %NotDel%

				EndSQL

				While (cAliasTP6)->( !EoF() )
					aDispo  := NG_H7((cAliasTP6)->TP6_CALEND)
					nDiaSem := IIf( DOW(dIniData) == 1, 7, DOW(dIniData) -1 )
					If !Empty(aDispo)
						If aDispo[nDiaSem][3] <> "00:00"
							lTemDispo := .T.
							exit
						EndIf
					EndIf
					dbSelectArea(cAliasTP6)
					(cAliasTP6)->( dbSkip() )
				EndDo

				(cAliasTP6)->( dbCloseArea() )

				If !lTemDispo
					dbSelectArea(cAliasST1)
					(cAliasST1)->( dbSkip() )
					Loop
				EndIf
			EndIf

			// Se o funcionário possui esecialidade, registra a disponibilidade desta
			If !Empty( (cAliasST1)->T2_ESPECIA )

				dbSelectArea("ST0")
				dbSetOrder(01)
				dbSeek(xFilial("ST0")+(cAliasST1)->T2_ESPECIA)

				nEspec := aScan(aDispon,{|x| x[1] == (cAliasST1)->T2_ESPECIA })

				If nEspec == 0
					aAdd( aDispon, { (cAliasST1)->T2_ESPECIA, ST0->T0_NOME, 0, 0, 1 } )
					nEspec := Len(aDispon)
				Else
					aDispon[nEspec,5]++
				EndIf

				// Não deve incluir um mesmo funcionário quando este tenha mais de uma especialidade
				nLenFunc  := aScan( aDispFunc, { |x| x[1] == (cAliasST1)->T1_CODFUNC } )
				lMltplEsp := .T.

				If nLenFunc == 0

					aAdd( aDispFunc, { (cAliasST1)->T1_CODFUNC, (cAliasST1)->T1_NOME, 0, 0, ST0->T0_NOME,;
					 (cAliasST1)->T2_ESPECIA } )
					nLenFunc := Len(aDispFunc)

				Else

					// Define que a mão de obra não possui multiplas especialidades
					lMltplEsp := .F.

				EndIf

			// Caso o funcionário não possua especialidade, contabiliza como "SEM ESPECIALIDADE DEFINIDA"
			Else

				// Busca por posição onde a especialidade esteja vazia
				nEspec := aScan( aDispon, { |x| x[1] == (cAliasST1)->T2_ESPECIA } )

				If nEspec == 0

					aAdd( aDispon, { (cAliasST1)->T2_ESPECIA, STR0346, 0, 0, 1, 0 } ) // SEM ESPECIALIDADE DEFINIDA
					nEspec := Len( aDispon )

				Else

					aDispon[nEspec,5]++

				EndIf

				// Não deve incluir um mesmo funcionário quando este tenha mais de uma especialidade
				nLenFunc  := aScan(aDispFunc,{|x| x[1] == (cAliasST1)->T1_CODFUNC .And. x[6] <> (cAliasST1)->T2_ESPECIA })
				lMltplEsp := .T.

				If nLenFunc == 0

					aAdd( aDispFunc, { (cAliasST1)->T1_CODFUNC , (cAliasST1)->T1_NOME, 0, 0, '', (cAliasST1)->T2_ESPECIA } )
					nLenFunc := Len( aDispFunc )

				Else

					// Define que a mão de obra não possui multiplas especialidades
					lMltplEsp := .F.

				EndIf

			EndIf

			//Se mão-de-obra esta disponivel sempre 8h por dia
			If lHorDia8

				nDias := (dFimData - dIniData) + 1

				If nDias > 0

					nFunDisp := (8 * 60) * nDias

					aDispon[nEspec,3] += nFunDisp

					If lMltplEsp

						aDispFunc[nLenFunc,3] += nFunDisp

					EndIf

				EndIf

			// Se o turno for fixo
			ElseIf !lNGFlut
				aDispo := {}
				nPosC  := aScan(vCalend,{|x| x == (cAliasST1)->T1_TURNO})
				If nPosC = 0
					aAdd(vCalend,(cAliasST1)->T1_TURNO)
					aDispo := NG_H7((cAliasST1)->T1_TURNO)
					aAdd(aCalends,aDispo)
					nPosC := Len(vCalend)
				EndIf

				If !Empty(dIniData)
					dDtAtu := dIniData
				Else
					dDtAtu := dFimData
				EndIf
				If !Empty(aCalends[nPosC])

					nPosD := aScan( aTurnoPer , {|x| x[1] == (cAliasST1)->T1_TURNO })
					If nPosD == 0
						nFunDisp := 0
						While dDtAtu <= dFimData
							nSem   := If( DOW(dDtAtu) == 1, 7, DOW(dDtAtu)-1)
							nPosH9 := aScan( aListaSH9 , {|x| x[1] == dDtAtu })
							If nPosH9 == 0
								aAdd( aListaSH9 , { dDtAtu , NG_H9(dDtAtu) } )
								nPosH9 := Len(aListaSH9)
							EndIf
							aDiaH9 := aListaSH9[nPosH9,2]
							If Len(aDiaH9) > 0
								nFunDisp += HtoM(aDiaH9[3])
							Else
								nFunDisp += HtoM(aCalends[nPosC,nSem,3])
							EndIf
							dDtAtu := dDtAtu + 1
						End

						aDispon[nEspec,3]     += nFunDisp
						aDispFunc[nLenFunc,3] += nFunDisp
						aAdd( aTurnoPer , { (cAliasST1)->T1_TURNO,nFunDisp } )

					Else
						aDispon[nEspec,3]     += aTurnoPer[nPosD,2]

						If lMltplEsp

							aDispFunc[nLenFunc,3] += aTurnoPer[nPosD,2]

						EndIf

					EndIf

					//Valida Bloqueio/Ausência do funcionário
					fValBloAus((cAliasST1)->T1_CODFUNC, dIniData, dFimData)

				EndIf

			// Se o turno flutuante estiver habilitado
			Else

				If !Empty(dIniData)
					dDtAtu := dIniData
				Else
					dDtAtu := dFimData
				EndIf
				nEquipDisp := 0

				nPosE := aScan(aEquipDia ,{|x| x[1] == (cAliasST1)->T1_EQUIPE })

				// Se ja carregou disponibilidade da Equipe nao precisa verificar novamente
				lEquipe := .T.
				If nPosE > 0
					
					lEquipe := .F.
					
					aDispon[nEspec,3] += aEquipDia[nPosE,2]

					If lMltplEsp
						aDispFunc[nLenFunc,3] += aEquipDia[nPosE,2]
					EndIF

				EndIf

				If lEquipe

					cAliasTP6 := GetNextAlias()

					BeginSQL Alias cAliasTP6
						SELECT  TP6_CALEND, TP6_DTINI, TP6_DTFIM
							FROM %table:TP6% 
						WHERE	TP6_FILIAL = %xFilial:TP6%  AND
								TP6_EQUIPE = %exp:(cAliasST1)->T1_EQUIPE% AND
								(( TP6_DTINI <= %exp:dFimData% AND TP6_DTFIM >= %exp:dDtAtu% ) OR
								 ( TP6_DTINI <= %exp:dFimData% AND TP6_DTFIM >= %exp:dFimData% )) AND
						    	D_E_L_E_T_ <> %exp:'*'%
					EndSQL

						While (cAliasTP6)->( !EoF() )

						aDispo := {}
						nPosC  := aScan(vCalend,{|x| x = (cAliasTP6)->TP6_CALEND})
						If nPosC == 0
							aAdd(vCalend,(cAliasTP6)->TP6_CALEND)
							//Adiciona calendário para verificação de disponibilidade
							aDispo := NG_H7((cAliasTP6)->TP6_CALEND)
							aAdd(aCalends,aDispo)
							nPosC := Len(vCalend)
						EndIf
						If !Empty(aCalends[nPosC])

							//Tratativa das datas se faz necessária para que o calcule corretamente a dispobilidade.
							dDiaTp6    := SToD((cAliasTP6)->TP6_DTINI)
							dDiaFim	   := SToD((cAliasTP6)->TP6_DTFIM)
							dDiaInicio := IIF( dDiaTp6 >= dDtAtu, dDiaTp6, dDtAtu)
							dDataFimD  := IIF( !Empty((cAliasTP6)->TP6_DTFIM) .And. dDiaFim <= dFimData, dDiaFim, dFimData)
							nQntDias   := (dDataFimD - dDiaInicio) + 1

							//Valida Bloqueio/Ausência do funcionário
							fValBloAus((cAliasST1)->T1_CODFUNC, dDiaInicio, dDataFimD)

							//Percorre os dias entre a data inicial e final do bloqueio de equipe
							//Incrementa disponibilidade
							For nCnt := 1 To nQntDias
								nSem := IIf( DOW(dDiaInicio) == 1, 7, DOW(dDiaInicio) -1 )
								nEquipDisp += HtoM(aCalends[nPosC,nSem,3])
								dDiaInicio += 1
							Next nCnt

						EndIf
						dbSelectArea(cAliasTP6)
						(cAliasTP6)->( dbSkip() )

					EndDo
					(cAliasTP6)->( dbCloseArea() )

					aAdd(aEquipDia, { (cAliasST1)->T1_EQUIPE , nEquipDisp } )
					aDispon[nEspec,3] 	  += nEquipDisp
					aDispFunc[nLenFunc,3] += nEquipDisp
				EndIf

			EndIf
			dbSelectArea(cAliasST1)
			(cAliasST1)->( dbSkip() )
		EndDo
		(cAliasST1)->( dbCloseArea() )
		aAdd(aDisponBkp, { dIniData , dFimData , M->TT1_EQUDE, M->TT1_EQUATE, M->TT1_CCDE, M->TT1_CCATE, aClone(aDispon), aClone(aDispFunc) } )

	EndIf

	If !lAltList
		aList2bkp := {}
		aList5bkp := {}
	Else
		If Len(aList2) == 1
			If Empty(aList2[1,2])
				aList2bkp := {}
			EndIf
		EndIf
		If Len(aList5) == 1
			If Empty(aList5[1,2])
				aList5bkp := {}
			EndIf
		EndIf
	EndIf

	//Especialidade
	For nYYY := 1 to Len(aDispon)
		nEspPos := aScan(aList2bkp,{|x| PadR(x[2],40) = PadR(aDispon[nYYY,2],40) })
		If nEspPos > 0
			nlist2Pos := aScan(aList2,{|x| PadR(x[2],40) = PadR(aDispon[nYYY,2],40) })
			If nlist2Pos > 0
				nDiff := aDispon[nYYY,3] - aDispon[nYYY,4]
				nMinAdd := 0
				nMinAus := 0
				If aList2[nlist2Pos][4] > 0 .And. aList2[nlist2Pos][5] > 0
					nMinAdd := 8 * 60 * aList2[nlist2Pos][4] * aList2[nlist2Pos][5]
				EndIf
				If aList2[nlist2Pos][6] > 0 .And. aList2[nlist2Pos][7] > 0
					nMinAus := 8 * 60 * aList2[nlist2Pos][6] * aList2[nlist2Pos][7]
				EndIf
				nMinAdd := nMinAdd - nMinAus
				nDiff   := nDiff + nMinAdd

				aList2bkp[nEspPos][3]  := aDispon[nYYY,5]
				aList2bkp[nEspPos][9]  := MtoH(nDiff)
				aList2bkp[nEspPos][1]  := fRetLegend(aList2bkp[nEspPos][8],MtoH(nDiff))
				aList2bkp[nEspPos][4]  := aList2[nlist2Pos][4]
				aList2bkp[nEspPos][5]  := aList2[nlist2Pos][5]
				aList2bkp[nEspPos][6]  := aList2[nlist2Pos][6]
				aList2bkp[nEspPos][7]  := aList2[nlist2Pos][7]
				aList2bkp[nEspPos][11] := aDispon[nYYY,1]
			EndIf
		Else
			nDiff := aDispon[nYYY,3] - aDispon[nYYY,4]
			aAdd(aList2bkp , { fRetLegend("00:00",MtoH(nDiff)), Alltrim(aDispon[nYYY,2]) , aDispon[nYYY,5] , 0 , 0 , 0 , 0 , ;
			"00:00" , MtoH(nDiff),0 ,aDispon[nYYY,1]} )
		EndIf
	Next nYYY

	//Mao de obra
	For nYYY := 1 to Len(aDispFunc)
		nEspPos := aScan(aList5bkp,{|x| PadR(x[2],6) = PadR(aDispFunc[nYYY,1],6) })
		If nEspPos > 0
			nlist2Pos := aScan(aList5,{|x| PadR(x[2],6) = PadR(aDispFunc[nYYY,1],6) })
			If nlist2Pos > 0
				nDiff := aDispFunc[nYYY,3] - aDispFunc[nYYY,4]
				aList5bkp[nEspPos][6] := MtoH(nDiff)
				aList5bkp[nEspPos][1] := fRetLegend(aList5bkp[nEspPos][5],MtoH(nDiff))
				aList5bkp[nEspPos][8] := aDispFunc[nYYY,6]
			EndIf
		Else
			nDiff := aDispFunc[nYYY,3] - aDispFunc[nYYY,4]
			aAdd(aList5bkp , { fRetLegend("00:00",MtoH(nDiff)), Alltrim(aDispFunc[nYYY,1]) , Alltrim(aDispFunc[nYYY,2]), ;
			Alltrim(aDispFunc[nYYY,5]) , "00:00" , MtoH(nDiff),0 , aDispFunc[nYYY,6]} )
		EndIf
	Next nYYY

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fSituaca
Altera a SITUACA das Ordens

@sample
fSituaca()

@author Denis Hyroshi de Souza
@since 17/04/2003
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fSituaca()

	Local aSIM := {}

	dbSelectArea(c990TRBY)
	dbGoTop()
	While !EoF()

		dbSelectArea("STJ")
		dbSetOrder(1)
		dbgoto((c990TRBY)->NUMREC)
		If !EoF()
			laSIM := .F.
			//---------------------------------------------------------------------
			//Se Manutencao e Unica verifica se ja foi confirmada em outros planos
			//---------------------------------------------------------------------
			If NGSEEK("STF",STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,1,"TF_PERIODO") = "U"
				vaSIM := NGJAMANUNICA(STJ->TJ_CODBEM,STJ->TJ_SERVICO,STJ->TJ_SEQRELA)
				laSIM := vaSIM[1]
			EndIf

			dbSelectArea("STJ")
			dbgoto((c990TRBY)->NUMREC)
			If !laSIM

				nDATA := STJ->TJ_DTMPINI - (c990TRBY)->DTMPOLD
				nHORA := 0
				RecLock("STJ",.F.)

				If !Empty(STJ->TJ_DTPPINI)
					STJ->TJ_DTPPINI := STJ->TJ_DTPPINI + nDATA
				EndIf

				If !Empty(STJ->TJ_DTPPFIM)
					STJ->TJ_DTPPFIM := STJ->TJ_DTPPFIM + nDATA
				EndIf

				STJ->TJ_USUARIO := If(Len(STJ->TJ_USUARIO) > 15,cUsername,Substr(cUsuario,7,15))
				STJ->TJ_TERMINO := "N"
				STJ->(MsUnLock())

				cSeqTJ := STR(STJ->TJ_SEQUENC,3)
				If NgVerify("STJ")
					cSeqTJ := STJ->TJ_SEQRELA
				EndIf

				//               01        02        03         04         05        06          07       08         09         10         11      12
				aAdd(aSIM,{STJ->TJ_ORDEM,STJ->TJ_CODBEM,STJ->TJ_CCUSTO,STJ->TJ_DTMPINI,0,0,STJ->TJ_ORDEM,STJ->TJ_DTMPFIM,STJ->TJ_SERVICO,cSeqTJ,STJ->TJ_DTORIGI," ",;
				STJ->TJ_TIPOOS,STJ->TJ_PLANO})

			Else

				//-----------------------------------------------------
				// Integração Mensagem Unica para Cancelamento de O.S.
				//-----------------------------------------------------
				If AllTrim(GetNewPar("MV_NGINTER","N")) == "M" .And. STJ->TJ_SITUACA == "L"
					If !NGMUCanMnO(STJ->(RecNo()))
						dbSelectArea(c990TRBY)
						dbSkip()
						Loop
					EndIf
				EndIf

				RecLock("STJ",.F.)
				STJ->TJ_SITUACA := "C"

				STJ->TJ_OBSERVA := STJ->TJ_OBSERVA + vaSIM[2]
				MsUnLock("STJ")

				// Caso integrado ao modulo de Chao de Fabrica (SIGASFC), cancela Parada Programada
				If lIntSFC .And. (!Empty(NGVRFMAQ(STJ->TJ_CODBEM)) .And. NGSFCDELPP(STJ->TJ_ORDEM,.F.,.F.))
					NGSFCDELPP(STJ->TJ_ORDEM)
				EndIf

			EndIf
			If STJ->TJ_PLANO > "000001"
				dbSelectArea("STI")
				dbSetOrder(01)
				If dbSeek(xFilial("STI")+STJ->TJ_PLANO)
					If STI->TI_SITUACA = "P" .And. STI->TI_TERMINO = "N"
						dbSelectArea("STI")
						RecLock("STI",.F.)
						STI->TI_SITUACA := "L"
						STI->(MsUnLock())
					EndIf
				EndIf
			EndIf

		EndIf

		dbSelectArea(c990TRBY)
		dbSkip()
	End

	If Len(aSIM) > 0
		fMNTLIB(aSIM)
	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fMNTLIB
Processa as OS confirmadas

@sample
fMNTLIB(aSIM)

@author Elisangela Costa
@since 27/11/2007
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fMNTLIB(aSIM)

	Local i,xv,nFER,nFUN,nESP,nTER
	Local lTemTTY 	:= .T.
	Local aWorkfOS 	:= {}
	Local cPRODMNT	:= GetMv("MV_PRODMNT")
	Local lNGTARGE  := SuperGetMV( 'MV_NGTARGE', .F., '2' ) == '1'
	Local lNGGERSA  := SuperGetMV( 'MV_NGGERSA', .F., 'N' ) $ 'S/P'
	Local lNGMNTAS  := SuperGetMV( 'MV_NGMNTAS', .F., '2' ) == '1'

	Local dNewDt := cToD( '' )
	Local aDtIns := {}

	Private nPRO, lPROBLEMA := .F.
	Private aBLO := { {},{},{},{},{} }

	// Usado na funcao NGGERASA.. Nao mexer
	Private cNumSA := Space(TAMSX3("CP_NUM")[1])

	cUsaIntPc  := AllTrim(GETMv("MV_NGMNTPC"))
	cUsaIntCm  := AllTrim(GetMv("MV_NGMNTCM"))
	cUsaIntEs  := AllTrim(GetMv("MV_NGMNTES"))
	cGerablCo  := AllTrim(GetMv("MV_NGCORPR"))

	ProcRegua(Len(aSIM))
	For i := 1 To Len(aSIM)

		// Usado na funcao NGGERASA.. Nao mexer
		cNumSA := Space(TAMSX3("CP_NUM")[1])

		If Empty(aSIM[i,12])
			aBLO := {{},{},{},{},{}}
			aIAglu := {}
			IncProc()

			//---------------------------------------------------------------------
			//Efetua o processamento no STJ
			//---------------------------------------------------------------------
			dbSelectArea("STJ")
			dbSetOrder(01)
			If dbSeek(xFilial("STJ")+aSIM[i][1]+aSIM[i][14])

				cORDEM := STJ->TJ_ORDEM
				aSIM[i][07] := STJ->TJ_ORDEM
				dbSelectArea("STJ")
				RecLock("STJ",.F.)
				STJ->TJ_SITUACA := "L"
				STJ->TJ_USUARIO := If(Len(STJ->TJ_USUARIO) > 15,cUsername,Substr(cUsuario,7,15))
				STJ->TJ_TERMINO := "N"
				MsUnLock("STJ")
				nSTJ := Recno()
				dbSelectArea("STJ")
				/*no caso de integracao, caso o backoffice nao consiga atualizar a OS, aborta a liberacao no MNT*/
				If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"  //Mensagem Unica
					NGMUMntOrd(STJ->(RecNo()),4)
				EndIf

				aAdd(aWorkfOS,STJ->TJ_ORDEM)
			EndIf
		EndIf

		fKillBloq( aSim[i,1], aSim[i,14] ) // DELETA BLOQUEIOS DOS INSUMOS, PARA GERAÇÃO COM NOVA DATA.

		// ATUALIZA BLOQUEIO DOS BENS REFERENTE A O.S.
		dbSelectArea( 'ST3' )
		dbSetOrder( 2 ) // T3_FILIAL + T3_ORDEM + T3_PLANO
		If dbSeek( xFilial( 'ST3' ) + aSim[i,1] + aSim[i,14] )

			Do While ST3->( !EoF() ) .And. ST3->T3_FILIAL == xFilial( 'ST3' ) .And.	ST3->T3_ORDEM == aSim[i,1] .And.;
					ST3->T3_PLANO == aSIM[i,14]

				dbSelectArea( 'STJ' )
				dbSetOrder( 1 )
				dbSeek( xFilial( 'STJ' ) + ST3->T3_ORDEM + ST3->T3_PLANO )

				RecLock( 'ST3', .F. )
					ST3->T3_DTINI := STJ->TJ_DTPPINI
					ST3->T3_DTFIM := STJ->TJ_DTPPFIM
				ST3->( MsUnLock() )

				ST3->( dbSkip() )

			EndDo

		EndIf
		//---------------------------------------------------------------------
		//Gera ordem de Producao para a OS
		//---------------------------------------------------------------------
		If cUsaIntPc == "S"         //INTEGRACAO COM O P.C.P.
			cCODPRO  := If(FindFunction("NGProdMNT"), NGProdMNT("M")[1], cPRODMNT) //Ira verificar apenas o primeiro Produto Manutencao do parametro
			cOP      := aSIM[i][7] + "OS001"
			DTPREINI := aSIM[i][4]
			DTPREFIM := aSIM[i][8]
			GERAOP(cCODPRO,1,cOP,DTPREINI,DTPREFIM)
			//-- Grava os Campos Especificos na OP
			dbSelectArea("SC2")
			RecLock('SC2',.F.)
			SC2->C2_CC      := aSIM[I][3]
			SC2->C2_STATUS  := 'U'
			SC2->C2_OBS     := 'PLANO '+aSIM[i,14]
			MsUnLock('SC2')
		EndIf

		dbSelectArea( 'STK' )
		dbSetOrder( 1 )

		dbSelectArea( 'STJ' )
		dbSetOrder( 1 )

		dNewDt := NgSeek( 'STJ', aSim[i,1] + aSim[i,14], 1, 'TJ_DTMPINI' )

		dbSelectArea( 'STL' )
		dbSetOrder( 1 )
		dbSeek( xFilial( 'STL' ) + aSim[i,1] + aSim[i,14] )
		Do While STL->( !EoF() ) .And. STL->TL_FILIAL + STL->TL_ORDEM + STL->TL_PLANO == xFilial( 'STL' ) + aSim[i,1] + aSim[i,14]

			If STL->TL_TIPOREG == 'P'
				aDtIns := { dNewDt, STL->TL_HOINICI, dNewDt, STL->TL_HOINICI }
			Else
				aDtIns := M420RETDAT( STL->TL_CODIGO, dNewDt, STL->TL_HOINICI, STL->TL_QUANTID, STL->TL_USACALE )
			EndIf

			// ATUALIZA DATA DOS INSUMOS, CONFORME A DATA DE LIBERAÇÃO DA O.S.
			RecLock( 'STL', .F. )

				STL->TL_DTINICI := aDtIns[1]
				STL->TL_DTFIM   := aDtIns[3]

			STL->( MsUnLock() )

			//---------------------------------------------------------------------
			//Monta Array para Ferramentas, Funcionarios , Especia-
			//listas e Produtos; contendo Codigo, quantidade e prazo
			//em que sera utilizado (Data e hora Inicio e Fim).
			//---------------------------------------------------------------------
			nTIP := 0
			_OK  := .F.
			lGeraBloq := .T.
			lGeraBloq := If(STL->TL_PLANO == "000000" .And. cGerablCo <> "S",.F.,lGeraBloq)
			cReserva := "S"
			If lGeraBloq

				If STL->TL_PLANO > "000001"
					STJ->(dbSeek(xFilial("STJ")+aSIM[i][01]+STL->TL_PLANO))
					STI->(dbSeek(xFilial("STI")+STL->TL_PLANO))

					STG->(dbSeek(xFilial('STG')+STJ->TJ_CODBEM + STJ->TJ_SERVICO+STJ->TJ_SEQRELA+STL->TL_TAREFA+STL->TL_TIPOREG+STL->TL_CODIGO))
					cReserva := STG->TG_RESERVA
					If STL->TL_TIPOREG == "F"
						_OK  := !(STI->TI_BLOQFER == "S" .And. STG->TG_RESERVA == "S")
						nTIP := If(STI->TI_BLOQITE == "S" .And. STG->TG_RESERVA == "S",0,1)
					ElseIf STL->TL_TIPOREG == "M"
						_OK  := !STK->(dbSeek(xFilial('STK')+STL->TL_ORDEM+STL->TL_PLANO+STL->TL_TAREFA+STL->TL_CODIGO))
						nTIP := If(_OK,2,0)
					ElseIf STL->TL_TIPOREG == "E"
						If lTemTTY
							_OK  := !TTY->(dbSeek(xFilial('TTY')+STL->TL_ORDEM+STL->TL_PLANO+STL->TL_TAREFA+Substr(STL->TL_CODIGO,1,3)))
							nTIP := If(_OK,3,0)
						Else
							_OK  := !STK->(dbSeek(xFilial('STK')+STL->TL_ORDEM+STL->TL_PLANO+STL->TL_TAREFA+STL->TL_CODIGO))
							nTIP := If(_OK,3,0)
						EndIf
					ElseIf STL->TL_TIPOREG == "P"
						_OK  := .T.
						nTIP := 4
					ElseIf STL->TL_TIPOREG == "T"
						_OK  := .T.
						nTIP := 5
					EndIf
				Else
					If STL->TL_TIPOREG == "F"
						_OK  := .T.
						nTIP := 1
					ElseIf STL->TL_TIPOREG == "M"
						_OK  := .T.
						nTIP := 2
					ElseIf STL->TL_TIPOREG == "E"
						_OK  := .T.
						nTIP := 3
					ElseIf STL->TL_TIPOREG == "P"
						_OK  := .T.
						nTIP := 4
					ElseIf STL->TL_TIPOREG == "T"
						_OK  := .T.
						nTIP := 5
					EndIf
				EndIf

				cALMOXA  := Space(len(sb1->b1_locpad))

				If FieldPos('TL_LOCAL') > 0 .And. STL->TL_TIPOREG = 'P'
					cALMOXA := STL->TL_LOCAL
				EndIf

				If nTIP > 0

					lGrvBLO := .T.
					
					If nTIP == 4

						If lNGTARGE .And. lNGGERSA .And. !lNGMNTAS

							nPosBlo := aScan( aBlo[nTip], { |aArray| aArray[1] + aArray[2] + aArray[18] == STL->TL_TAREFA + STL->TL_CODIGO + cAlmoxa } )

						Else

							nPosBlo := aScan( aBlo[nTip], { |aArray| aArray[2] + aArray[18] == STL->TL_CODIGO + cAlmoxa } )

						EndIf

						If nPosBlo > 0

							aBLO[nTIP][nPosBlo][3] += If(STL->TL_TIPOREG$"E/F",STL->TL_QUANREC,STL->TL_QUANTID)
							
							lGrvBLO := .F.

						Else

							lGrvBLO := .T.

						EndIf

					EndIf

					If lGrvBLO

						// Estrutura array aBlo
						aAdd( aBLO[nTIP],;
						                 {STL->TL_TAREFA           ,; //1  - Tarefa
							              STL->TL_CODIGO           ,; //2  - Código do Insumo
							              IIf(STL->TL_TIPOREG$"E/F",STL->TL_QUANREC,STL->TL_QUANTID),; //3 - Quant.
							              STL->TL_DTINICI          ,; //4  - Data Inicio
							              STL->TL_HOINICI          ,; //5  - Hora Inicio
							              STL->TL_DTFIM            ,; //6  - Data Fim
							              STL->TL_HOFIM            ,; //7  - Hora Fim
							              STL->TL_ORDEM            ,; //8  - Ordem de serviço
							              STL->TL_PLANO            ,; //9  - Plano da manutenção
							              _OK                      ,; //10 - Centro de Ccusto
							              Space(Len(SC1->C1_NUM))  ,; //11 - Número SC
							              Space(Len(SC1->C1_ITEM)) ,; //12 - Item SC
							              0.00                     ,; //13 - Qtde Estoque Op.           TL_QTDOPER
							              Space(Len(SB2->B2_LOCAL)),; //14 - Código Almoxarifado Op.    TL_ALMOPERA
							              0.00                     ,; //15 - Qtde Estoque Matriz        TL_QTDOMAT
							              Space(Len(SB2->B2_LOCAL)),; //16 - Código Almoxarifado Matriz TL_ALMOMAT
							              0.00					   ,; //17 - Qtde. SC                   TL_QTDSC1
							              STL->TL_LOCAL            ,; //18 - Local
							              STL->TL_UNIDADE          ,; //19 - Unidade de medida
							              ''                       ,; //20 - Observação do insumo
							              0.0                      ,; //21 - Qtde. SC                   TL_QTDSC1
							              STL->TL_FORNEC           ,; //22 - Fornecedor
							              STL->TL_LOJA             ,; //23 - Loja
										 };
							)
					EndIf
				EndIf
			EndIf
			STL->(dbSkip())
		End

		//---------------------------------------------------------------------
		//Efetua o bloqueio de Ferramentas
		//---------------------------------------------------------------------
		For nFER := 1 To Len(aBLO[1])
			M->TI_PLANO := aSIM[i][14]
			If aBLO[1][nFER][10]
				A330FER(aBLO[1][nFER])
			Else
				A340FER(aBLO[1][nFER])
			EndIf
		Next

		//---------------------------------------------------------------------
		//Efetua o bloqueio de Mao de Obras (FUNCIONARIO)
		//---------------------------------------------------------------------
		For nFUN := 1 TO Len(aBLO[2])
			If aBLO[2][nFUN][10]
				A330FUN(aBLO[2][nFUN])
			EndIf
		Next

		//---------------------------------------------------------------------
		//Efetua o bloqueio de Especialistas (FUNCIONARIO)
		//---------------------------------------------------------------------
		For nESP := 1 To Len(aBLO[3])
			If aBLO[3][nESP][10]
				A330ESP(aBLO[3][nESP])
			EndIf
		Next

		//---------------------------------------------------------------------
		//Efetua o bloqueio de Produtos
		//---------------------------------------------------------------------
		nPRO := 1
		While nPRO <= Len(aBLO[4])
			aOldBLO  := aClone(aBLO[4])
			cTAREFA  := aBLO[4][nPRO][1]
			nQTDCOMP := aBLO[4][nPRO][3]
			cOPrin   := AllTrim(aBLO[4][nPRO][8]) + "OS001"
			cCodPro  := Left(aBLO[4][nPRO][2], Len(SB1->B1_COD))
			cOP      := AllTrim(aBLO[4][nPRO][8]) + "OS001"
			cLOCSTL  := aBLO[4][nPRO][18]

			If lNGTARGE .And. lNGGERSA .And. !lNGMNTAS

				nPosSC := aScan( aIAglu, { |x| x[5] + x[1] + x[2] == cTarefa + cCodPro + cLocSTL } )

			Else
			
				nPosSC := aScan( aIAglu, { |x| x[1] + x[2] == cCodPro + cLocSTL } )

			EndIf

			If nPosSC > 0

				aIAglu[nPosSC][3] += nQTDCOMP

			Else

				aAdd( aIAglu, { cCodPro, cLOCSTL, nQTDCOMP, cOp, cTAREFA, STJ->TJ_CCUSTO,;
					aBLO[4][nPRO][4], aBLO[4][nPRO][22], STJ->TJ_ORDEM, STJ->TJ_PLANO } )

			EndIf

			For xv := 1 to Len(aBLO[4])
				If xv <= Len(aOldBLO)
					If (aBLO[4][xv][2] <> aOldBLO[xv][2]) .Or. (aBLO[4][xv][3] <> aOldBLO[xv][3])
						dbSelectArea("TT4")
						dbSetOrder(1)
						If dbSeek(xFilial("TT4")+cTT1_CODIGO+aBLO[4][xv][8]+aBLO[4][xv][9]+aOldBLO[xv][2])
							RecLock("TT4",.F.)
							TT4->TT4_CODIGO := aBLO[4][xv][2]
							TT4->TT4_QTDE   := aBLO[4][xv][3]
							TT4->(MsUnLock())
						EndIf
					EndIf
				Else
					RecLock("TT4",.T.)
					TT4->TT4_FILIAL := xFilial("TT4")
					TT4->TT4_NUMERO := cTT1_CODIGO
					TT4->TT4_ORDEM  := aBLO[4][xv][8]
					TT4->TT4_PLANO  := aBLO[4][xv][9]
					TT4->TT4_CODIGO := aBLO[4][xv][2]
					TT4->TT4_QTDE   := aBLO[4][xv][3]
					TT4->(MsUnLock())
				EndIf
			Next
			nPRO++
		EndDo

		If lAltera
			// RETIRA A QUANTIDADE JA SOLICITADA, ESTA NO NGUTIL02
			cOP := aSim[i][1] + "OS001" //Ordem de Serviço + "OS001"
			NGRETJACOMP(cOP)
		EndIf

		// ESTA FUNCAO ESTA NO FONTE NGUTIL02 UTILIZA A MATRIZ aIAglu
		NGINTCOMPEST(STJ->TJ_DTMPINI,STJ->TJ_DTMPFIM,"MNTA990")

		/*-------------------------------\
		| Efetua o bloqueio de TERCEIROS |
		\-------------------------------*/
		For nTer := 1 To Len(aBlo[5])
			If aBlo[5][nTer][10]
				a340Ter( aBlo[5][nTer], aBlo[5][nTer][18], aBlo[5][nTer][3], aBlo[5][nTer][19], .F., nTer )
			EndIf
		Next nTer

		//FIM DO NOVO PROCESSO DE GERACAO COMPRAS E EMPENHO

		If lIntSFC .And. !Empty(STJ->TJ_DTPPINI) .And. !Empty(NGVRFMAQ(STJ->TJ_CODBEM))
			aValuesCZ2 := {}
			aAdd( aValuesCZ2 , {"CZ2_DTBGPL" , STJ->TJ_DTPPINI} )
			aAdd( aValuesCZ2 , {"CZ2_HRBGPL" , Padr(Trim(Transform(STJ->TJ_HOPPINI,"99:99:99")),8,"0")} )
			aAdd( aValuesCZ2 , {"CZ2_DTEDPL" , STJ->TJ_DTPPFIM} )
			aAdd( aValuesCZ2 , {"CZ2_HREDPL" , Padr(Trim(Transform(STJ->TJ_HOPPFIM,"99:99:99")),8,"0")} )
			aAdd( aValuesCZ2 , {"CZ2_TPSTSP" , "1"} )
			NGSFCATPRD(STJ->TJ_ORDEM,aValuesCZ2)
		EndIf


	Next

	If FindFunction("MNTW215") .AND. Len(aWorkfOS) > 0
		MNTW215(,aWorkfOS)
	EndIf

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} fAltBox
Altera Combobox

@sample
fAltBox(cTipoInd)

@author Denis Hyroshi de Souza
@since 27/11/2007
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fAltBox(cTipoInd)

	nTipoInd := 1
	If cTipoInd == STR0010 //"Ordem"
		nTipoInd := 3
	ElseIf cTipoInd == STR0193 //"Bem + Ordem"
		nTipoInd := 5
	ElseIf cTipoInd == STR0196 //"Equipe + Bem"
		nTipoInd := 4
	EndIf

	dbSelectArea(c990TRB1)
	dbSetOrder(nTipoInd)
	dbSelectArea(c990TRB2)
	dbSetOrder(nTipoInd)
	dbSelectArea(c990TRB3)
	dbSetOrder(nTipoInd)
	oMARK1:Refresh()
	oMARK2:Refresh()

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} fLocalizOS
Localiza as Ordens nos GRIDS

@sample
fLocalizOS()

@author Denis Hyroshi de Souza
@since 27/11/07
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fLocalizOS()
	Local cOldTa := Alias()
	Local aArea1 := (c990TRB1)->(GetArea())
	Local aArea3 := (c990TRB3)->(GetArea())
	Local lAchou := .F.

	If Empty(cBuscaOS)
		Return .T.
	EndIf

	dbSelectArea(c990TRB1)
	dbSetOrder(3)
	dbGoTop()
	If dbSeek(cBuscaOS)
		dbSelectArea(c990TRB1)
		dbSetOrder(nTipoInd)
		oMARK1:Refresh()
		oMARK1:SetFocus()
		lAchou := .T.
	Else
		RestArea(aArea1)
	EndIf

	dbSelectArea(c990TRB3)
	dbSetOrder(3)
	dbGoTop()
	If dbSeek(cBuscaOS)
		dbSelectArea(c990TRB3)
		dbSetOrder(nTipoInd)
		oMARK2:Refresh()
		oMARK2:SetFocus()
		lAchou := .T.
	Else
		RestArea(aArea3)
	EndIf

	If !lAchou
		MsgInfo(STR0186) //"Não foi possível localizar este número de Ordem de Serviço."
		cBuscaOS := Space(6)
		Return .T.
	EndIf

	dbSelectArea(cOldTa)

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} fTQUATINS
Faz o tratamento da quantidade de insumo (tipo de unidade, tipo de hora,
tratamento do calendario quando mao de obra) para insumos do  tipo M=MAO DE OBRA,
E=ESPECIALIDADE, F=FERRAMENTA e T=TERCEIRO

Parametros:	cCODINS  = Codigo do Insumo           -Obrigatorio
cTIPOINS = Tipo do Insumo             -Obrigatorio
cUSACALE = Indicacao de utilizacaode calendario quando
mao de obra                -obrigatorio
nQUANTID = Quantidade aplicada        -obrigatorio
cTIPOHOR = Tipo de Hora               -obrigatorio
dDATAINI = Data Inicio aplicacao ins  -obrigatorio
cHORINIC = Hora Inicio aplicacao ins. -obrigatorio
dDATAFIM = Data Fim aplicacao ins.    -obrigatorio
cHORAFIM = Hora Fim aplicacao ins.    -obrigatorio
cUNIDADE = Unidade de medida          -obrigatorio

Retorno: aVETQUANT = [1] Hora decimal(Ex: 01:30 retorna 1,50) numer.
[2] Hora em formato decimal mais como hora
-(Ex: 1:30 retorna 1,30) em numerico
[3] Hora sexagesimal (Ex: 1,50 retorna 01:30) em caracter

@sample
fTQUATINS(cCODINS,cTIPOINS,cUSACALE,nQUANTID,cTIPOHOR,dDATAINI,cHORINIC,dDATAFIM,cHORAFIM,cUNIDADE,cCodCalen)

@author Elisangela Costa
@since 07/12/2006
@version 1.0
/*/
//---------------------------------------------------------------------
Function fTQUATINS(cCODINS,cTIPOINS,cUSACALE,nQUANTID,cTIPOHOR,dDATAINI,cHORINIC,dDATAFIM,cHORAFIM,cUNIDADE,cCodCalen)
	Local nHORDEC  := 0.0     //Hora em decimal 1,50  (numerico)
	Local nHORANUM := 0.0     //Hora em numerico 1,30 (numerico)
	Local cHORASE  := "00:00" //Hora em formato sexagesimal 01:30 (Caracter)
	Local vVETHODH := {}, aVETQUANT := {}
	Local cCALENDIN

	Default cTIPOHOR := "D"

	If cTIPOINS <> "P"
		If cUNIDADE = "H"
			If cTIPOHOR = "S"

				vVETHODH := NGRETHORDDH(nQUANTID)
				nHORDEC  := vVETHODH[2]
				nHORANUM := nQUANTID
				cHORASE  := vVETHODH[1]

			Else

				nHORDEC  := nQUANTID
				nHORANUM := NGRHODSEXN(nQUANTID,cTIPOHOR)
				cHORASE  := NTOH(nQUANTID)

			EndIf
		Else
			If cUSACALE == "S"  .And. cTIPOINS == "M"

				cCALENDIN := NGSEEK("ST1",Substr(cCODINS,1,6),1,"T1_TURNO")
				nHORA := NGCALENHORA(dDATAINI,cHORINIC,dDATAFIM,cHORAFIM,cCALENDIN)

				vVETHODH := NGRETHORDDH(nHORA)
				nHORDEC  := vVETHODH[2]
				nHORANUM := nHORA
				cHORASE  := vVETHODH[1]

			Else

				nHORA := NGCALCH100(dDATAINI,cHORINIC,dDATAFIM,cHORAFIM)
				nHORDEC  := nHORA
				nHORANUM := NGRHODSEXN(nHORA,"D")
				cHORASE  := NTOH(nHORA)

			EndIf
		EndIf
		aVETQUANT := {nHORDEC,nHORANUM,cHORASE}
	Else
		aVETQUANT := {nQUANTID,nQUANTID,nQUANTID}
	EndIf
Return aVETQUANT

//---------------------------------------------------------------------
/*/{Protheus.doc} fCalFiltro
Insumos da OS

@sample
fCalFiltro()

@author Denis Hyroshi de Souza
@since 03/03/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fCalFiltro()

	Local oDlgEsp
	Local nOpc5Cad := 0
	Local o2Calend
	Local dDataTmp := _dDia2Atu

	Define MsDialog oDlgEsp Title OemToAnsi( STR0201 ) From 0,0 To 15,69 OF oMainWnd // Filtrar O.S. por data

		o2Calend := MsCalend():New( 37, 10, oDlgEsp, .F. )

		If lAltProg
			o2Calend:bChangeMes := { || Processa( { |lEND| fPrgChgMes( 1, @o2Calend ) }, STR0046 ) } // Atualizando Calendário...
			o2Calend:bChange    := { || _dDia2Atu := o2Calend:dDiaAtu }
		EndIf

		_dDia2Atu := IIf( Empty( _dDia2Atu ), dDataBase, _dDia2Atu )

		o2Calend:dDiaAtu := _dDia2Atu

		Processa( { |lEND| fPrgChgMes( 1, @o2Calend ) }, STR0047 ) // Processando...

		@ 024,168 BitMap oBtnPre Resource 'PMSTASK3' Size 17,17 of oDlgEsp Pixel Noborder Design
		@ 039,168 BitMap oBtnVer Resource 'PMSTASK4' Size 17,17 of oDlgEsp Pixel Noborder Design
		@ 054,168 BitMap oBtnVer Resource 'PMSTASK1' Size 17,17 of oDlgEsp Pixel Noborder Design

		@ 024,180  Say Oemtoansi( STR0048 ) Of oDlgEsp Pixel // Sem O.S. no dia.
		@ 037,180  Say Oemtoansi( STR0049 ) Of oDlgEsp Pixel // M.D.O. suficiente para realizar
		@ 043,180  Say OemToAnsi( STR0050 ) Of oDlgEsp Pixel // a carga horária prevista.
		@ 052,180  Say Oemtoansi( STR0051 ) Of oDlgEsp Pixel // M.D.O. insuficiente para realizar
		@ 058,180  Say OemToAnsi( STR0050 ) Of oDlgEsp Pixel // a carga horária prevista.

	Activate MsDialog oDlgEsp On Init EnchoiceBar(oDlgEsp,{|| (oDlgEsp:End() , nOpc5Cad := 1 ) },{|| oDlgEsp:End() }) Centered

	If nOpc5Cad == 1 .And. lAltProg
		fPrgChgDia(3)
	Else
		_dDia2Atu := dDataTmp
	EndIf

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fAltBoxOS
Ação efetuada ao dar foco no objeto RADIO BUTTON.
@type function

@author Alexandre Santos
@since 21/02/2020

@sample fAltBoxOS( 2 )

@param  nOSPrInd, Númerico, 1 - Todas O.S. / 2 - Data selecionada no calendário.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fAltBoxOS( nOSPrInd )
Return IIf( lFilOsPro, ( IIf( nOSPrInd == 2, fPrgChgDia( 2 ), fFilDataOS( dTT1_DTPROG, dTT1_DTFIM, .F. ) ) ), Nil )

//---------------------------------------------------------------------
/*/{Protheus.doc} fFilDataOS
Filtra as OS programadas na data selecionada no calendario

@type static

@author Denis Hyroshi de Souza
@since 27/11/2007
@sample fFilDataOS( 02/04/2019, 03/04/2019, .T. )
@param varDTPROG, Data  , Data que foi selecionada no calendário.
@param varDTFIM , Data  , Data fim do filtro.
@param lVerData , Lógico, Consiste se deve ser veirifcado as data
@return Nil
/*/
//---------------------------------------------------------------------
Static Function fFilDataOS( varDTPROG, varDTFIM, lVerData )

	Local aMNTA9906 := {}
	Local cQueryIn  := ''
	Local nIndex    := 0

	dbSelectArea( c990TRB3 )
	dbSetOrder( 1 )
	If RecCount() > 0
		Zap
	EndIf

	If ExistBlock( 'MNTA9906' )
		
		// P.E. que atribui conteúdo aos campos de usuário criados pelo P.E. MNTA9902.
		aMNTA9906 := ExecBlock( 'MNTA9906', .F., .F., { c990TRB3, aDBFa } )

		If ValType( aMNTA9906 ) != 'A'
			aMNTA9906 := {}
		EndIf

	EndIf

	cQueryIn := 'INSERT INTO ' + oARQT9903:GetRealName() + ' ( '
	cQueryIn +=    'MARCADO, PRIORID, PRIOINV, ORDEM, PLANO, CODBEM, SEQRELA, DESCRIC, CODSER, DESSER, '
	cQueryIn +=    'EQUIPE, DTMPINI, HOMPINI, DTMPFIM, HOMPFIM, XSTATUS, LIBERA, DTMPROG, SEQUENC, DTORIGI, '
	cQueryIn +=    'SITUACA, REALIZA, EVENTO'

	For nIndex := 1 To Len( aMNTA9906 )
		
		// Valida a existência do campo na tabela temporária.
		If (c990TRB3)->( FieldPos( aMNTA9906[nIndex,1] ) ) > 0
			cQueryIn += ' ,' + aMNTA9906[nIndex,1]
		EndIf

	Next nIndex

	cQueryIn += ' ) '

	cQueryIn += 'SELECT '
	cQueryIn +=    'MARCADO, PRIORID, PRIOINV, ORDEM, PLANO, CODBEM, SEQRELA, DESCRIC, CODSER, DESSER, '
	cQueryIn +=    'EQUIPE, DTMPINI, HOMPINI, DTMPFIM, HOMPFIM, XSTATUS, LIBERA, DTMPROG, SEQUENC, DTORIGI, '
	cQueryIn +=    'SITUACA, REALIZA, EVENTO '

	For nIndex := 1 To Len( aMNTA9906 )
		
		// Valida a existência do campo na tabela temporária.
		If (c990TRB2)->( FieldPos( aMNTA9906[nIndex,1] ) ) > 0
			cQueryIn += ' ,' + aMNTA9906[nIndex,1]
		EndIf

	Next nIndex

	cQueryIn += ' FROM ' 
	cQueryIn +=     oARQT9902:GetRealName() + ' TRB '
	cQueryIn += 'WHERE '

	// Realiza o filtro na tabela temporária considerando as datas de inicio e fim da O.S.
	If lVerData

		cQueryIn += "( ( TRB.DTMPINI <= " + ValToSql( varDTFIM )  + " AND "
		cQueryIn +=     "TRB.DTMPFIM >= " + ValToSql( varDTPROG ) + " ) "
		cQueryIn += " OR "
		cQueryIn +=  "(  TRB.DTMPINI = "  + ValToSql( varDTPROG ) + " AND "
		cQueryIn +=    " TRB.DTMPFIM = '' ) ) AND "

	EndIf

	cQueryIn += " D_E_L_E_T_ = ' '"

	// Executa o comando INSERT INTO na tabela temporária.
	TcSQLExec( cQueryIn )

	dbSelectArea(c990TRB2)
	dbGoTop()

	// Carrega folders ( mão de obra, especialidade, produto e ferramenta )
	fLoadTTXX( .T., !lVerData )

	// Posiciona no primeiro registro da tabela temporária de O.S. em programação
	dbSelectArea( c990TRB3 )
	dbGoTop()

	// Atualiza objeto markbrowse de O.S. em programação
	oMARK2:GoTop()
	oMARK2:Refresh()

	// Posiciona no primeiro registro da tabela temporária de O.S. à programar
	dbSelectArea( c990TRB1 )
	dbGoTop()

	// Atualiza objeto markbrowse de O.S. à programar
	oMARK1:GoTop()
	oMARK1:Refresh()

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fLoadTTXX
Carrega Folders ( MDO, Produtos e Ferramentas ).
@type function

@author Denis Hyroshi de Souza
@since 27/11/2007

@sample fLoadTTXX( .T., .F. )

@param  lAtuTela, Lógico, Define se deve atualizar os objetos de tela.
@param  [lAll]  , Lógico, Define se deve considerar todas as O.S. da programação.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fLoadTTXX( lAtuTela, lAll, lCallInp )

	Default lAll     := .F.
	Default lCallInp := .F.

	If lFilOsPro

		// Carrega mão de obra e especialidade utilizadas nas O.S. em programação
		fUpdFolds( oARQT9903:GetRealName(), lAll, lAtuTela, lCallInp )

	Else

		// Carrega mão de obra e especialidade utilizadas nas O.S. à progamar
		fUpdFolds( oARQT9901:GetRealName(), .T. , lAtuTela, lCallInp )

	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} MNTCADTTQ
Funcao de alterar evento

@sample
MNTCADTTQ(cAlias,nRecno,nOpcxx)

@author Denis Hyroshi de Souza
@since 27/11/2007
@version 1.0
/*/
//---------------------------------------------------------------------
Function MNTCADTTQ(cAlias,nRecno,nOpcxx)
	Private dDtEvIni := TTQ->TTQ_DTINI
	Private dDtEvFim := TTQ->TTQ_DTFIM

	bNGGRAVA := {|| MNT990OKE() }

	dbSelectArea("TTQ")
	If NGCAD01(cAlias,nRecno,nOpcxx) == 1
		dbSelectArea("TT1")
		dbSetOrder(5)
		If dbSeek(xFilial("TT1")+TTQ->TTQ_CODIGO)
			RecLock("TT1",.F.)
			TT1->TT1_DTPROG := TTQ->TTQ_DTINI
			TT1->TT1_DTFIM  := TTQ->TTQ_DTFIM
			TT1->(MsUnLock())
		EndIf
		TT1->(dbSetOrder(1))
	EndIf

	bNGGRAVA := {|| }

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} WHENTTQDT
Verifica se a data deve ser editado ou nao

@sample
WHENTTQDT()

@author Denis Hyroshi de Souza
@since 27/11/2007
@version 1.0
/*/
//---------------------------------------------------------------------
Function WHENTTQDT()
	If Type("lTTQDATA") == "L"
		If !lTTQDATA
			Return .F.
		EndIf
	EndIf
Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MNT990OKE
Valida Confirmacao da tela de alteracao Evento

@sample
MNT990OKE()

@author Denis Hyroshi de Souza
@since 27/11/2007
@version 1.0
/*/
//---------------------------------------------------------------------
Function MNT990OKE()
	Local dDtMaior := SToD("")
	Local dDtMenor := SToD("")
	Local lFirst   := .T.,dDtTmp

	If M->TTQ_DTINI > dDtEvIni .Or. M->TTQ_DTFIM < dDtEvFim

		dbSelectArea("TT1")
		dbSetOrder(5)
		If dbSeek(xFilial("TT1")+M->TTQ_CODIGO)
			dbSelectArea("TT2")
			dbSetOrder(1)
			dbSeek(xFilial("TT2")+TT1->TT1_CODIGO+"2")
			While !EoF() .And. xFilial("TT2")+TT1->TT1_CODIGO+"2" == TT2->TT2_FILIAL+TT2->TT2_CODIGO+TT2->TT2_TIPO
				dDtTmp := TT2->TT2_DTPROG
				If Empty(TT2->TT2_DTPROG)
					dDtTmp := TT1->TT1_DTPROG
				EndIf
				If lFirst
					lFirst := .F.
					dDtMaior := dDtTmp
					dDtMenor := dDtTmp
				Else
					If dDtTmp > dDtMaior
						dDtMaior := dDtTmp
					EndIf
					If dDtTmp < dDtMenor
						dDtMenor := dDtTmp
					EndIf
				EndIf
				dbSelectArea("TT2")
				dbSkip()
			End
		EndIf

		If !lFirst
			If dDtMenor < M->TTQ_DTINI
				MsgInfo(STR0242+DtoC(dDtMenor)) //"Não pode alterar a Data Inicio, pois existe uma OS programada neste Evento para a data "
				Return .F.
			ElseIf dDtMaior > M->TTQ_DTFIM
				MsgInfo(STR0243+DtoC(dDtMaior)) //"Não pode alterar a Data Fim, pois existe uma OS programada neste Evento para a data "
				Return .F.
			EndIf
		EndIf

	EndIf

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} VldCodEve
Valida evento na tela de Programacao

@sample
VldCodEve()

@author Denis Hyroshi de Souza
@since 27/11/2007
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function VldCodEve()

	If !Empty(cEventoOS)
		dbSelectArea("TTQ")
		dbSetOrder(1)
		If !dbSeek(xFilial("TTQ")+cEventoOS)
			Help(" ",1,"REGNOIS")
			Return .F.
		EndIf
		If TTQ->TTQ_DTFIM < dDataBase
			Help(" ",1,"NGATENCAO",,STR0224+Chr(13)+Chr(10)+; //"Este Evento não pode ser selecionado,"
			STR0225+DTOC(TTQ->TTQ_DTFIM),3,1) //"pois ele foi encerrado na data "
			Return .F.
		EndIf
	EndIf

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} fCor001
Retorna a legenda da Situacao da OS

@sample
fCor001()

@author Denis Hyroshi de Souza
@since 27/11/2007
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fCor001()
	Local cRet := "  "

	If (c990TRB1)->REALIZA == '1'
		cRet := 'BR_CINZA'
	ElseIf (c990TRB1)->SITUACA == 'L'
		cRet := 'BR_VERDE'
	ElseIf (c990TRB1)->SITUACA == 'P'
		cRet := 'BR_LARANJA'
	EndIf

Return cRet
//---------------------------------------------------------------------
/*/{Protheus.doc} fCor002
Retorna a legenda do Status da OS

@sample
fCor002(nTipo)

@author Denis Hyroshi de Souza
@since 27/11/2007
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fCor002(nTipo)
	Local cRet := "  "
	Local cCod := If( nTipo == 1 , (c990TRB1)->XSTATUS , (c990TRB3)->XSTATUS )

	dbSelectArea("TQW")
	dbSetOrder(01)
	dbSeek(xFilial("TQW")+cCod)

	If TQW->TQW_CORSTA = "1 "
		cRet := "BR_PINK"
	ElseIf TQW->TQW_CORSTA = "2 "
		cRet := "BR_VERMELHO"
	ElseIf TQW->TQW_CORSTA = "3 "
		cRet := "BR_AMARELO"
	ElseIf TQW->TQW_CORSTA = "4 "
		cRet := "BR_AZUL"
	ElseIf TQW->TQW_CORSTA = "5 "
		cRet := "BR_VERDE"
	ElseIf TQW->TQW_CORSTA = "6 "
		cRet := "BR_PRETO"
	ElseIf TQW->TQW_CORSTA = "7 "
		cRet := "BR_LARANJA"
	ElseIf TQW->TQW_CORSTA = "8 "
		cRet := "BR_CINZA"
	ElseIf TQW->TQW_CORSTA = "9 "
		cRet := "BR_MARRON"
	ElseIf TQW->TQW_CORSTA = "10"
		cRet := "BR_BRANCO"
	EndIf

Return cRet
//---------------------------------------------------------------------
/*/{Protheus.doc} fCor003
Retorna a legenda da Situacao da OS

@sample
fCor003()

@author Denis Hyroshi de Souza
@since 27/11/2007
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fCor003()
	Local cRet := "  "

	If (c990TRB3)->LIBERA  == '1'
		cRet := 'BR_AZUL'
	ElseIf (c990TRB3)->REALIZA == '1'
		cRet := 'BR_CINZA'
	ElseIf (c990TRB3)->SITUACA == 'L'
		cRet := 'BR_VERDE'
	ElseIf (c990TRB3)->SITUACA == 'P'
		cRet := 'BR_LARANJA'
	EndIf

Return cRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fIncPvSTL
Tela de insumos previstos

@sample
fIncPvSTL(nTipo)

@author Denis Hyroshi de Souza
@since 26/05/2010
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fIncPvSTL(nTipo)

	Local oMenu
	Local nREGSTJ
	Local oDlg2
	Local aColsSv
	Local cAlsTrb    := IIf( nTipo == 2, c990TRB1, c990TRB3 )
	Local aAreaTrb   := (cAlsTrb)->( GetArea() )
	Local aAreaX     := GetArea()
	Local bKeyF4     := SetKey(VK_F4)
	Local nContAcols := 9999
	Local nOpcAcols  := 3
	Local cChaveStj  := ''
	Local cAlsDts    := GetNextAlias()
	Local cAlsTmp    := '%' + oTmpSTL:GetRealName() + '%'
	Local cTime      := ''
	Local nInd       := 0
	Local lAltInclui := .F. //Verifica se alterou a variavel lInclui
	Local lCancel    := .F.
	Local cUsaIntEs  := AllTrim( SuperGetMv( 'MV_NGMNTES', .F., 'N' ) )
	Local lUsePrAlt  := AllTrim( SuperGetMv( 'MV_MNTPRAL', .F., '2' ) ) == '1' .And. FindFunction( 'NGALTPROD' ) .And.;
						AllTrim( SuperGetMv( 'MV_NGGERSA', .F., 'N' ) ) == 'N'

	Private cINSPREV := "P"
	Private aUpdInp  := { {}, {}, {}, {} } 


	If (cAlsTrb)->(EoF())
		Help(" ",1,"NGATENCAO",,STR0113,3,1) //"Arquivo vazio!"
		RestArea(aAreaX)
		RestArea( aAreaTrb )
		Return .F.
	EndIf

	If nTipo == 1 .And. Inclui
		lAltInclui := .T.
		SetAltera()
	EndIf

	cChaveStj := xFilial("STJ")+ (cAlsTrb)->ORDEM + (cAlsTrb)->PLANO

	dbSelectArea("STJ")
	dbSetOrder(1)
	If !dbSeek(cChaveStj)
		RestArea(aAreaX)
		RestArea( aAreaTrb )
		Return .F.
	EndIf

	dbSelectArea("STF")
	dbSetOrder(1)
	dbSeek(xFilial("STF")+STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA)

	cPrograma := "MNTA420"
	nREGSTJ := STJ->(Recno())
	dbSelectArea("STJ")
	RegtoMemory("STJ",.F.)

	/* Posiciona o ponteiro da tabela STL em final de arquivo, a posição do ponteiro nesse momento afeta diretamente
	 a inicialização das memorias logo abaixo.*/
	PutFileInEoF( 'STL' )
	RegtoMemory( 'STL', .T. ) // inicializa as varíaveis de memória para o processo de inclusão

	Private nOpcai    := 0
	Private nOpcae    := 0
	Private nOpcas    := 0
	Private aTrocaF3  := {}, aNGFIELD := {}
	Private aDtSa	  := {}
	Private cPxSeq    := Space(3),cPxQSeq := cPxSeq
	Private dINI,hINI
	Private nCODINS   := 0, nUSACAL := 0 , nDATAIN := 0, nHORAIN := 0, nTIPHEA := 0
	Private lSEQTAR   := .T.
	Private lUSATARG  := If(FindFunction("NGUSATARPAD"),NGUSATARPAD(),.F.)
	Private lCORRET   := If(Val(M->TJ_PLANO) = 0,.T.,.F.)
	Private l990AGet := .F.
	Private aBLO := { {},{},{},{},{} }
	Private MV_PAR04   := Space(6),MV_PAR07 := Space(6),MV_PAR03 := Space(6)

	Private nPosNum	  := 0
	Private nPosItem  := 0
	Private aNgCadBtn := {}, aTempBut := {}
	Private aNewSc    := {}

	MV_PAR01  := M->TJ_CODBEM
	MV_PAR02  := M->TJ_SERVICO
	MV_PAR05  := M->TJ_SEQRELA

	// Inicializacao da mv_par03,mv_par04 e mv_par07 para resetar os parametros de perguntas
	nSEQUENC := "0  "
	lRETORNO := .F.
	aHEAINS  := {}
	aHEAETA  := {}
	aHEASIN  := {}
	aGETINS  := {}
	aGETETA  := {}
	aGETSIN  := {}
	aDATINS  := {}

	// Carrega aCols com registros da tabela temporária de insumos
	fGetCols( M->TJ_ORDEM, M->TJ_PLANO, .F. )

	aHEAINSAL := ACLONE(aHEAINS)
	aGETINSAL := ACLONE(aGETINS)

	dINI := M->TJ_DTORIGI
	hINI := If(!Empty(M->TJ_HOMPINI),M->TJ_HOMPINI,SubStr( Time(),1,5))

	aHEADER := aCLONE(aHEAINS)
	aCOLS   := aCLONE(aGETINS)
	aColsSv := aCLONE(aGETINS)
	cTUDOKI := "MNT990TOK()"
	cLINOKI := "MNT990LOK() .And. PutFileInEof('STL') "
	nPOSINS := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
	nQTDHEA := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID" })
	nPosCodI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
	nPosNum	 := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_NUMSA"})
	nPosItem := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_ITEMSA"})
	dINI    := M->TJ_DTORIGI

	SetKey(VK_F12,{||NGINSUF12("M->TL_CODIGO",M->tj_codbem,oGet:aCOLS[oGet:nAt,nPOSINS],.T.,,"TL_NOMCODI")})
	SetKey(VK_F4,{|| MntViewSB2(oGet:aCOLS[oGet:nAt,nPOSINS],oGet:aCOLS[oGet:nAT,nPosCodI]) })

	NGPONTOENTR("MNTA990B" )

	nOpcai := 0
	//verficar se e inclusao ou visualizacao
	If nTipo == 2 .Or. !lAltProg
		nContAcols := Len(aCols)
		nOpcAcols := 2
	EndIf

	// Somente quando integrado ao Backoffice RM, adiciona o botão ao ações relacionadas
	If SuperGetMv( 'MV_NGINTER', .F., '' ) == 'M' .And. FindFunction( 'MntUpdCost' )

		// Atualiza Saldo/Custo do Produto
		aAdd( aNgCadBtn, { Nil, { || MntUpdCost( oGet:aCols, oGet:aHeader ) }, STR0347 } )

	EndIf

	Define MsDialog oDlg2 Title STR0350 + IIf( nTipo == 2, (c990TRB1)->ORDEM, (c990TRB3)->ORDEM ) From 163,0 To 463,; // Insumos - O.S. 001234
		IIf( GetScreenRes()[1] <= 800,750, GetScreenRes()[1] * 0.73 ) Pixel Of oMainWnd

		oGet := MsNewGetDados():New( aPosObj[2,1], aPosObj[2,2], aPosObj[2,3], aPosObj[2,4], GD_INSERT + GD_UPDATE + GD_DELETE,;
		    cLINOKI, cTUDOKI, , , , 9999, , , 'NG420DELI( oGet:aCols, oGet:nAt )', oDlg2, aHeader, aCols )

		oGet:aInfo[nQTDHEA,4] := Space(Len(Posicione("SX3",2, "", "X3_WHEN"))) //Garante que o campo quantidade não tenha informações no WHEN

		NGPOPUP(aSMenu,@oMenu,oMainWnd)
		oDlg2:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg2)}

	ACTIVATE MSDIALOG oDlg2 ON INIT EnchoiceBar( oDlg2, { || IIf( ( Len( oGet:aLastEdit ) > 0 .Or. Len( aGetInsAl ) != Len( oGet:aCols ) ),;
		IIf( oGet:TudoOk(), oDlg2:End(), .F. ),	oDlg2:End() ) }, { || lCancel := .T., oDlg2:End() }, AlignObject( oDlg2, { oGet:oBrowse }, 1 ), aNgCadBtn )

	// Caso o objeto tenha sofrido alguma alteração libera o processo de gravação
	If Len( oGet:aLastEdit ) > 0 .And. !lCancel

		aHeaIns := aClone( oGet:aHeader )
		aGetIns := aClone( oGet:aCols )
		cTime   := SubStr( Time(), 1, 5 )

		If lUsePrAlt .And. cUsaIntEs == 'S' .And. M->TJ_SITUACA == 'L'
			aGetIns := NGALTPROD( aGetIns, aHeaIns, M->TJ_CODBEM, 'TL', 'MNTA990' ) // Realocar - Porduto alternativo
		EndIf

		// Verifica se o aCols sofreu alguma inclusão / alteração e grava na tabela temporária apenas os registros modificados.
		For nInd := 1 To Len( aGetIns )
		
			// Grava na tabela temporária registros novos que foram inclusos no aCols.
			If ( nInd > Len( aColsSv ) .Or. ( Empty( aColsSv[1,1] ) .And. !Empty( aGetIns[1,1] ) ) )

				fSave( , aGetIns[nInd] )

			Else
		
				/*----------------------------------------+
				| Valida os insumo que tiveram alteração. |
				+----------------------------------------*/
				If fDiffGetD( aColsSv, aGetIns, nInd )

					fCheckIns( aHeaIns, @aGetIns, nInd )

					fSave( aColsSv[nInd], aGetIns[nInd] )

				EndIf

			EndIf

		Next nInd

		// Processo de atualização de datas da ordem por meio dos insumos reportados.
		BeginSQL Alias cAlsDts

			SELECT
				ISNULL( MIN( TL_DTINICI || TL_HOINICI ), %exp:oCalend:dDiaAtu% || %exp:cTime% ) AS MINDTHR,
				ISNULL( MAX( TL_DTFIM || TL_HOFIM )    , %exp:oCalend:dDiaAtu% || %exp:cTime% ) AS MAXDTHR
			FROM
				%exp:cAlsTmp%
			WHERE
				TL_ORDEM = %exp:M->TJ_ORDEM% AND
				TL_PLANO = %exp:M->TJ_PLANO% AND
				STATUS <> 3

		EndSQL

		// Atualizando data e hora inicio da O.S. conforme insumos
		If (cAlsDts)->MINDTHR != DtoS( STJ->TJ_DTMPINI ) + STJ->TJ_HOMPINI

			RecLock( cAlsTrb, .F. )

				(cAlsTrb)->DTMPROG := sToD( SubStr( (cAlsDts)->MINDTHR, 1, 8 ) )
				(cAlsTrb)->DTMPINI := sToD( SubStr( (cAlsDts)->MINDTHR, 1, 8 ) )
				(cAlsTrb)->HOMPINI := SubStr( (cAlsDts)->MINDTHR, 9 )

			(cAlsTrb)->( MsUnLock() )

			If nTipo == 1

				// Repasse para tabela backup
				dbSelectArea( c990TRB2 )
				dbSetOrder( 3 ) // ORDEM + PLANO
				dbGoTop()
				If dbSeek( (cAlsTrb)->ORDEM + (cAlsTrb)->PLANO )

					RecLock( c990TRB2, .F. )

						(c990TRB2)->DTMPROG := (cAlsTrb)->DTMPROG
						(c990TRB2)->DTMPINI := (cAlsTrb)->DTMPINI
						(c990TRB2)->HOMPINI := (cAlsTrb)->HOMPINI

					(c990TRB2)->( MsUnLock() )

				EndIf

			EndIf

		EndIf

		// Atualizando data e hora fim da O.S. conforme insumos.
		If (cAlsDts)->MAXDTHR != DtoS( STJ->TJ_DTMPFIM ) + STJ->TJ_HOMPFIM

			RecLock( cAlsTrb, .F. )

				(cAlsTrb)->DTMPFIM := sToD( SubStr( (cAlsDts)->MAXDTHR, 1, 8 ) )
				(cAlsTrb)->HOMPFIM := SubStr( (cAlsDts)->MAXDTHR, 9 )

			(cAlsTrb)->( MsUnLock() )

			If nTipo == 1

				// Repasse para tabela backup
				dbSelectArea( c990TRB2 )
				dbSetOrder( 3 ) // ORDEM + PLANO
				dbGoTop()
				If dbSeek( (cAlsTrb)->ORDEM + (cAlsTrb)->PLANO )

					RecLock( c990TRB2, .F. )

						(c990TRB2)->DTMPFIM := (cAlsTrb)->DTMPFIM
						(c990TRB2)->HOMPFIM := (cAlsTrb)->HOMPFIM

					(c990TRB2)->( MsUnLock() )

				EndIf

			EndIf

		EndIf

		/*--------------------------------------------------------------------+
		| Realiza o reload dos folders conforme as definições da programação. |
		+--------------------------------------------------------------------*/
		fLoadTTXX( .T., ( nOSPrInd == 1 ), .T. )

		// Atualiza legenda do calendário
		Processa( { |lEND| fPrgChgMes( 1, @oCalend ) }, STR0046 ) // Atualizando Calendário...

	EndIf

	Set Key VK_F12 To
	SetKey(VK_F4,bKeyF4)

	cPrograma := "MNTA990"
	RestArea(aAreaX)
	RestArea( aAreaTrb )

	If lAltInclui
		SetInclui()
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT990DTPR
Valida Data do Insumo

@sample
MNT990DTPR()

@author Denis Hyroshi de Souza
@since 05/09/2011
@version 1.0
/*/
//---------------------------------------------------------------------
Function MNT990DTPR()

	If M->TL_DTINICI < dTT1_DTPROG .Or. M->TL_DTINICI > dTT1_DTFIM
		If !MsgYesNo(STR0291+Chr(13)+Chr(10)+;  //"A Data Inicio não está dentro do período da Programação."
		STR0240+DtoC(dTT1_DTPROG)+" à "+DtoC(dTT1_DTFIM)+Chr(13)+Chr(10)+; //"Período: De "
		STR0292)  //"Deseja continuar mesmo assim?"
			Return .F.
		EndIf
	EndIf

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MNT990ACHO
Limpa campos data e hora inicio

@sample
MNT990ACHO()

@author Denis Hyroshi de Souza
@since 05/09/2011
@version 1.0
/*/
//---------------------------------------------------------------------
Function MNT990ACHO()
	If Type("nHORAIN") == "N"
		If M->TL_TIPOREG == "M"
			oGet:aCols[oGet:nAt][nDATAIN] := CTOD("  /  /  ")
			oGet:aCols[oGet:nAt][nHORAIN] := "  :  "
		EndIf
	EndIf
Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MNT990TOK
Consiste a GETDADOS

@sample
MNT990TOK()

@author Denis Hyroshi de Souza
@since 26/05/2010
@version 1.0
/*/
//---------------------------------------------------------------------
Function MNT990TOK()

	Local lRet := .T.
	Local i
	Local lEmpenho := cUsaIntEs == "S" .And. GetNewPar("MV_NGGERSA","N") == "N"
	Local aArea    := GetArea()
	Local aProdEmp := {}
	Local nPosArr
	Local cTarZero := Padr( '0', TamSx3('TL_TAREFA')[1] )
	Local aRet     := {}

	If oGet:lModified
		l990AGet := .T.
	EndIf

	nTAR := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TAREFA" })
	nTIP := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
	nCOD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
	nQTR := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANREC" })
	nQTD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID" })
	nDES := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DESTINO" })
	nUND := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_UNIDADE" })
	nLOC := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_LOCAL" })
	nUSC := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_USACALE" })
	nDTI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTINICI" })
	nHOI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOINICI" })
	nDTF := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTFIM" })
	nHOF := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOFIM" })

	If nTAR == 0
		If nTIP == 0 .AND. nCOD == 0 .And. nQTR == 0 .And. nQTD == 0 .And. nDES == 0
			Return .T.
		EndIf
	Else
		If nTAR == 0 .And. nTIP == 0 .AND. nCOD == 0 .And. nQTR == 0 .And. nQTD == 0 .And. nDES == 0
			Return .T.
		EndIf
	EndIf

	If Len(aCOLS) == 1
		If !aCOLS[1][Len(aCOLS[1])]
			cCOD := aCOLS[1][nCOD]
			cTIP := aCOLS[1][nTIP]
			cQTR := aCOLS[1][nQTR]
			cQTD := aCOLS[1][nQTD]
			cDES := aCOLS[1][nDES]
			cUND := aCOLS[1][nUND]
			cLOC := aCOLS[1][nLOC]
			cTAR := If(nTAR > 0,aCOLS[1][nTAR],Space(Len(STL->TL_TAREFA)))
			If Empty(cTAR) .And. Empty(cCOD) .And. Empty(cTIP) .And. Empty(cQTR);
			.And. Empty(cQTD) .And. Empty(cDES) .And. Empty(cUND)

				Return .T.
			EndIf
		EndIf
	EndIf

	//------------------------------------------------------------------------------
	// Trecho abaixo valida bloqueio de MDO para cada linha dos insumos
	// Feito na conf. da tela para não ser apresentada msg repetidas vezes
	//------------------------------------------------------------------------------
	For i := 1 To Len( aCols )

		If !aCols[ i, Len( aCols[i]) ]

			If aCols[ I, nTIP ] $ 'M/E'

				aRet := fVldAltDtI( (c990TRB3)->ORDEM, (c990TRB3)->PLANO, aCols[ i, nDTI ],;
									{ aCols[I][nCOD], IIf( nTAR > 0, aCols[ i, nTAR ], cTarZero ),;
									aCols[ i, nTIP ], aCols[ i, nHOI ], aCols[ i, nQTD ],;
									aCols[ i, nUSC ], aCols[ i, nQTR ] }, .T., aRet  )

			EndIf

		EndIf
	
	Next i

	If Len( aRet ) > 0
		lRet := fShowMsg( aRet )
	EndIf

	If lRet

		For i := 1 To Len( oGet:aCols )
		
			If !aTail( oGet:aCols[I] )
				
				cCOD := oGet:aCols[I,nCOD]
				cTIP := oGet:aCols[I,nTIP]
				cQTR := oGet:aCols[I,nQTR]
				cQTD := oGet:aCols[I,nQTD]
				cDES := oGet:aCols[I,nDES]
				cUND := oGet:aCols[I,nUND]
				cLOC := oGet:aCols[I,nLOC]
				cUSC := oGet:aCols[I,nUSC]
				cDTI := oGet:aCols[I,nDTI]
				cHOI := oGet:aCols[I,nHOI]
				cDTF := oGet:aCols[I,nDTF]
				cHOF := oGet:aCols[I,nHOF]
				cTAR := IIf( nTAR > 0, oGet:aCols[I,nTAR], Space( Len( STL->TL_TAREFA ) ) )
				
				lRet := Mnt990ChkL( I, .F. )
				
				If !lRet
					Exit
				EndIf
			
			Else

				// Caso a linha atual esteja deletada, e não encontra-se no aLastEdit, deve ser inclusa.
				If aScan( oGet:aLastEdit, { |x| x == I} ) == 0

					// Inclui está linha no aLastEdit
					oGet:AddLastEdit( I )

				EndIf
		
			EndIf

			If lEmpenho .And. aCOLS[I][nTIP] == "P"
				If ( nPosArr := aScan( aProdEmp, {|x| x[1] + x[2] == aCOLS[I][nCOD] + aCOLS[I][nLOC] } ) ) == 0
					aAdd( aProdEmp, { aCOLS[I][nCOD], aCOLS[I][nLOC], 0 } )
					nPosArr := Len( aProdEmp )
				EndIf

				If !aCOLS[i][Len(aCOLS[i])]
					aProdEmp[nPosArr][3] += aCOLS[I][nQTD]
				EndIf
			EndIf

		Next

	EndIf

	If lRet .And. lEmpenho .And. FindFunction("MNT420VSD4")
		MNT420IND4( (c990TRB3)->ORDEM, (c990TRB3)->PLANO, aHeader, aCols, @aProdEmp )

		If !Empty(aProdEmp)
			lRet := MNT420VSD4( (c990TRB3)->ORDEM, aProdEmp )
		EndIf
	EndIf

	RestArea( aArea )

	If lRET
		M->TL_TIPOREG := ' '
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT990LOK
Consiste a Linha da GETDADOS

@sample
MNT990LOK()

@author Denis Hyroshi de Souza
@since 26/05/2010
@version 1.0
/*/
//---------------------------------------------------------------------
Function MNT990LOK()

	Local lRet     := .T.
	Local qtd      := 0
	Local nInsumos := 0
	Local nMAX
	lSEQTAR        := NGCADICBASE("TL_SEQTARE","A","STL",.F.)

	nTAR    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TAREFA" })
	nTIP    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
	nCOD    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
	nQTR    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANREC" })
	nQUTD   := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID" })
	nDES    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DESTINO" })
	nUND    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_UNIDADE" })
	nLOC    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_LOCAL" })
	nUSC    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_USACALE" })
	nDTI    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTINICI" })
	nHOI    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOINICI" })
	nDTF    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTFIM" })
	nHOF    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOFIM" })
	nSQT    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_SEQTARE" })
	nGAR    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_LOCAPLI" })
	nItemSA := aScan( aHEADER, { |x| AllTrim( Upper( X[2] ) ) == 'TL_ITEMSA' } )
	nNumSA  := aScan( aHEADER, { |x| AllTrim( Upper( X[2] ) ) == 'TL_NUMSA' } )

	If nTAR == 0
		If nTip == 0 .Or. nCOD == 0 .Or. nQUTD == 0 .Or. nDES == 0
			Return .T.
		EndIf
	Else
		If nTAR == 0 .Or. nTip == 0 .Or. nCOD == 0 .Or. nQUTD == 0 .Or. nDES == 0
			Return .T.
		EndIf
	EndIf

	nLIN := 1
	If Len(aCOLS) == 1
		If aCOLS[1][Len(aCOLS[1])]
			Return .T.
		EndIf
	Else
		nLIN := n
	EndIf

	cTAR := If(nTAR > 0,aCOLS[nLIN][nTAR],Space(Len(STL->TL_TAREFA)))
	cCOD := aCOLS[nLIN][nCOD]
	cTIP := aCOLS[nLIN][nTIP]
	cQTR := aCOLS[nLIN][nQTR]
	cQTD := aCOLS[nLIN][nQUTD]
	cDES := aCOLS[nLIN][nDES]
	cUND := aCOLS[nLIN][nUND]
	cLOC := aCOLS[nLIN][nLOC]
	cUSC := aCOLS[nLIN][nUSC]
	cDTI := aCOLS[nLIN][nDTI]
	cHOI := aCOLS[nLIN][nHOI]
	cDTF := aCOLS[nLIN][nDTF]
	cHOF := aCOLS[nLIN][nHOF]
	cSQT := If(nSQT > 0,aCOLS[nLIN][nSQT],Space(1))
	cGAR := If(nGAR > 0,aCOLS[nLIN][nGAR],Space(15))

	If Empty(cTAR) .And. Empty(cCOD) .And. Empty(cTIP) .And. Empty(cQTR);
	.And. Empty(cQTD) .And. Empty(cDES) .And. Empty(cUND)
		Return .T.
	EndIf

	nMax := Len(oGet:aCols[oGet:nAt])

	If ( nTAR = 0, aEval( aCOLS, { | x | If( ( x[ nTIP ] == cTIP .And. cCOD == x[ nCOD ] .And. !x[ nMax ] .And. If( !Empty( cSQT ), x[ nSQT ] == cSQT, .T. ) ), qtd++, NIL ) } ),;
	aEval( aCOLS, { |x| If( ( x[ nTAR ] == cTAR .And. x[ nTIP ] == cTIP .And. cCOD == x[ nCOD ] .And. !x[ nMax ] ), qtd++, NIL ) } ) )
	
	If qtd > 1
	
		If !lSEQTAR .Or. oGet:aCols[ oGet:nAt, nTip ] == 'E'
			
			Help( ' ' , 1, 'TARJAEXIST' )
			Return .F.
		
		EndIf
	
	EndIf

	If cTip == 'P'

		nQTD := 1

		// Verifica integração com RM e se os campos de numero e item S.A. estão presentes em tela
		If lIntegRM .And. nNumSa != 0 .And. nItemSA != 0

			// TAR+PROD+LOC já existe acols
			For nInsumos := 1 To Len(aCOLS)

				// Verifica se o insumo inserido é Produto, se não está deletado,
				// se existe algum outro registro no aCOLS que possuia a mesma chave (TAR+COD+LOC)
				// e que não seja a linha que está posicionada o LinOK(nLIN)
				If nInsumos != oGet:nAt .And. !aTail( aCols[nInsumos] ) .And. aCols[nInsumos,nTIP] == 'P' .And. aCols[nInsumos,nLOC] == cLOC .And.;
					IIf( lUSATARG, aCols[nInsumos,nTAR] == cTAR, .T. ) .And. aCols[nInsumos, nCOD] == cCod 
					
					If( !Empty( aCOLS[nInsumos,nNumSa] ) .And. NGMUTRAREQ( 'SCP', aCOLS[nInsumos,nNumSa], xFilial("SCP"), .F., aCOLS[nInsumos,nItemSA], ,;
						aCOLS[nInsumos,nLOC] ) ) .Or. Empty( aCOLS[nInsumos,nNumSa] )

						nQTD++
						Exit

					EndIf

				EndIf

			Next nInsumos

		Else
			
			If !fVlDpIns()
				Return .F.
			EndIf
		
		EndIf

	Else

		nQTD := 0
		//Verificar se usa Tarefa Generica
		If lUSATARG
			aEVAL(aCOLS,{|x|If(x[nCOD] == cCOD .And. x[nTAR] == cTAR .And. x[nGAR] == cGAR .And. x[nTIP] ==  cTIP .And.  x[nLOC] == cLOC .And.;
			x[nDES] == cDES .And. x[nDTI] ==  cDTI .And. x[nHOI] == cHOI .And. !x[Len(x)],nQTD++,Nil)})
		Else
			aEVAL(aCOLS,{|x|If(x[nCOD] == cCOD .And. x[nGAR] == cGAR .And. x[nTIP] ==  cTIP .And.  x[nLOC] == cLOC .And. x[nDES] == cDES .And.;
			x[nDTI] ==  cDTI .And. x[nHOI] == cHOI .And. !x[Len(x)],nQTD++,Nil)})
		EndIf

	EndIf

	If nQTD > 1 .And. !Empty(cCOD)
		Help(" ",1,"JAGRAVADO")
		lRET := .F.
		Return .F.
	EndIf

	lRet := Mnt990ChkL(nLIN,.T.)

	If lRet

		// Caso a linha atual seja maior que o total de linhas do aGetInsAl, considera como inclusão de linha.
		If oGet:nAt > Len( aGetInsAl ) .And. aScan( oGet:aLastEdit, { |x| x == oGet:nAt } ) == 0

			// Inclui está linha no aLastEdit
			oGet:AddLastEdit( oGet:nAt )

		EndIf

		M->TL_TIPOREG := ' '
		PutFileInEoF("STL") //Colocar a tabela STL em EoF para não mostrar descrição do Insumo na nova linha

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Mnt990ChkL
Consiste a GETDADOS

@sample
Mnt990ChkL(nVLIN,lVdlLinha)

@author Denis Hyroshi de Souza
@since 26/05/10
@version 1.0
/*/
//---------------------------------------------------------------------
Function Mnt990ChkL(nVLIN, lVdlLinha )

	Local lRETCHK     := .T.

	Private nVLINPE   := nVLIN
	Private lChkPR    := GetNewPar("MV_NGCOQPR","N") == "S" //checa qtd pecas de reposicao
	Private lUSATARG  := NGUSATARPAD()

	Default lVdlLinha := .T.

	If !Positivo(cQTD)
		Return .F.
	EndIf

	If Empty(cTIP) .Or. Empty(cCOD) .Or. ((lUSATARG .Or. Val(M->TJ_PLANO) > 0) .And. Empty(cTAR))
		Help(" ",1,"NGPROBINSU")
		lRETCHK := .F.
	EndIf

	If lRETCHK
		M->TL_TIPOREG := cTIP
		M->TL_CODIGO  := cCOD
		M->TL_QUANTID := cQTD
		M->TL_USACALE := cUSC
		M->TL_DTINICI := cDTI
		M->TL_HOINICI := cHOI
		M->TL_DTFIM   := cDTF
		M->TL_HOFIM   := cHOF
		M->TL_UNIDADE := cUND
		M->TL_TAREFA  := If(!Empty(cTAR),cTAR,"0     ")
		M->TL_QUANREC := cQTR

		If cTIP <> "P"
			aCOLS[nVLIN,nUND] := "H"+Space(Len(aCOLS[nVLIN,nUND])-1)
			If Empty(cQTD)
				Help(" ",1,"NGATENCAO",,STR0268,3,1) //"Campo quantidade obrigatório."
				lRETCHK := .F.
			EndIf
			If cTIP == "M" .And.  cUSC == "S"  .And. lRETCHK
				If Empty(cDTI) .Or. Empty(cHOI)
					Help(" ",1,"NGATENCAO",,STR0269+" "+STR0174+" "+Alltrim(Str(nVLIN,3))+".",3,1) //"Data/Hora obrigatório quando o campo Usa calend. = 'S'." //"Item"
					lRETCHK := .F.
				EndIf
				//Retorna Código do Calendário verificando o Parametro MV_NGFLUT
				cCodCal := fGetCalen( cCOD,cDTI,cDTF )

				If lRETCHK .And. !NGVALHRCALE( cCodCal,cDTI,cHOI,"I" ) //Consistência da hora do calendário
					lRETCHK := .F.
				EndIf
				If lRETCHK
					M->TL_TIPOREG := cTIP
					M->TL_USACALE := cUSC
					M->TL_CODIGO  := cCOD
					M->TL_DTINICI := cDTI
					M->TL_HOINICI := cHOI
					M->TL_DTFIM   := cDTF
					M->TL_HOFIM   := cHOF
					If !NGSTLHORIN()
						lRETCHK := .F.
					EndIf
				EndIf
			EndIf
			If lRETCHK
				lRETCHK := NGQUANTCHK(M->TL_TIPOREG,M->TL_UNIDADE,M->TL_QUANTID)
			EndIf



		Else
			If Empty(cQTD) .Or. Empty(cUND)
				Help(" ",1,"NGPROBINSU")
				lRETCHK := .F.
			EndIf
			If lRETCHK
				If cTIP == "P"
					If Empty(cDES)
						Help(" ",1,"DESTINO")
						lRETCHK := .F.
					EndIf
					If lRETCHK .And. cUsaIntEs == "S"  //INTEGRACAO COM ESTOQUE
						If !NGEMPALM(cLOC,nVLIN)
							lRETCHK := .F.
						Else
							If !NGPROALM(cCOD,cLOC,nVLIN)
								lRETCHK := .F.
							EndIf
						EndIf
					EndIf
					If lRETCHK .And. lChkPR		//checa qtd de pecas de reposicao do bem
						lRETCHK := NGCHKLIMP(If(FunName()=="MNTA295",cBEMSOLI,M->TJ_CODBEM),M->TL_CODIGO,M->TL_QUANTID)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	If lRETCHK
		If cTIP $ "F/E" .And. Empty(cQTR)
			Help(" ",1,"QUANTIDADE")
			lRETCHK := .F.
		EndIf
	EndIf

	If lVdlLinha //Somente no LinOK
		If lRETCHK .And. cTIP != "P"
			lMsgErro := .F.
			vDtFim   := {SToD(""),"  :  "}
			If cQTD <> 0
				If cTIP == "M" .And. cUSC == "S"
					cCodSh1 := IIf(Empty(cCodCal), NGSEEK("ST1",Substr(cCOD,1,6),1,"T1_TURNO"), cCodCal)
					vDtFim  := NGDTHORFCALE(cDTI,cHOI,cQTD,cCodSh1)
					If vDtFim[1] < dTT1_DTPROG .Or. vDtFim[1] > dTT1_DTFIM
						lMsgErro := .T.
					EndIf
				Else
					__dINI := dDatabase //Data Atual.
					__hINI := SubStr( Time(),1,5 ) //Hora Atual.
					vDtFim  := NGDTHORFIM(__dINI,__hINI,cQTD)
					If vDtFim[1] < dTT1_DTPROG .Or. vDtFim[1] > dTT1_DTFIM
						lMsgErro := .T.
					EndIf
				EndIf
			EndIf
			If lMsgErro //Se data fim do insumo esteja fora do periodo da programacao
				If !MsgYesNo(STR0293+Chr(13)+Chr(10)+;  //"A Data Fim prevista para o insumo não está dentro do período da Programação."
				STR0240+DtoC(dTT1_DTPROG)+" à "+DtoC(dTT1_DTFIM)+Chr(13)+Chr(10)+; //"Período: De "
				STR0294 + " " + DtoC(vDtFim[1])+Chr(13)+Chr(10)+;  //"Data Fim Prevista:"
				STR0292)  //"Deseja continuar mesmo assim?"
					lRETCHK := .F.
				EndIf
			EndIf
		EndIf
	EndIf

	If lRETCHK
		If lUSATARG .Or. Val(M->TJ_PLANO) > 0
			nTARL := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TAREFA"})
			If nTARL > 0
				If !Atail(oGet:aCOLS[oGet:nAt])
					If Empty(oGet:aCOLS[oGet:nAt,nTARL])
						MsgInfo(STR0270,STR0190) //"Tarefa não informada." //"NÃO CONFORMIDADE"
						lRETCHK := .F.
					Endif
				Endif
			Endif
		Endif
	Endif

	If ExistBlock("MNTA990C")
		If !ExecBlock("MNTA990C",.F.,.F.)
			lRETCHK := .F.
		EndIf
	EndIf
Return lRETCHK

//---------------------------------------------------------------------
/*/{Protheus.doc} fPosObjet
Define posicionamento dos objetos

@sample
fPosObjet()

@author Denis Hyroshi de Souza
@since 01/06/2008
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fPosObjet()

	Local lFlatMode := IIf(FindFunction("FLATMODE"), FlatMode(), SetMDIChild())
	Local nFat  	:= 1
	Local nFat2 	:= 0

	If lFlatMode //Se MDI aplicar os fatores abaixo para igualar as dimensões da tela
		aSize[6] := aSize[6] * 1.15
		aSize[5] := aSize[5] * 1.03
	EndIf

	nPorcVert := 1.43 //768
	nPorcHorz := 1.25 //1024

	//Verifica resolução Vertical
	If aSize[6] >= 934
		If lFlatMode
			nPorcVert := nPorcVert * 0.97
		Else
			nPorcVert := nPorcVert * 1
		EndIf
		nFat  := 0.88
		nFat2 := 30
	ElseIf aSize[6] >= 870
		If lFlatMode
			nPorcVert := nPorcVert * 0.91
		Else
			nPorcVert := nPorcVert * 0.93
		EndIf
		nFat  := 0.91
		nFat2 := 20
	ElseIf aSize[6] >= 774
		If lFlatMode
			nPorcVert := nPorcVert * 0.80
		Else
			nPorcVert := nPorcVert * 0.82
		EndIf
		nFat  := 0.95
		nFat2 := 10
	Else
		nPorcVert := 1
	EndIf
	//Verifica resolução Horizontal
	If aSize[5] >= 1272
		If lFlatMode
			nPorcHorz := nPorcHorz * 0.98
			nwHorBt4 := 602
		Else
			nPorcHorz := nPorcHorz * 1
			nwHorBt4 := 614
		EndIf
	ElseIf aSize[5] >= 1144
		If lFlatMode
			nPorcHorz := nPorcHorz * 0.87
			nwHorBt4 := 536
		Else
			nPorcHorz := nPorcHorz * 0.9
			nwHorBt4 := 552
		EndIf
	Else
		nPorcHorz := 1
		nwHorBt4 := 491
	EndIf

	nwHorPar := 240  * nPorcHorz //Largura Quadro Parametros
	nwHorCal := 260  * nPorcHorz //Posição Horizontal do Calendário e Campos Proximos
	nwVerOS1 := 100  * nPorcVert //Altura O.S. Pendentes
	nwHorOS1 := 234  * nPorcHorz //Largura O.S. Pendentes
	nwVerBt1 := (186 * nPorcVert) * nFat //Posição Vertical Botões O.S. Pendentes
	nwIniFol := 15.2 * nPorcVert * nFat //Posição Vertical Inicio Folder
	nwVerFol := (85  * nPorcVert) + nFat2 //Altura Folder
	nwHorFol := 435  * nPorcHorz //Largura Folder
	nwVerBt3 := 215  * nPorcVert * nFat //Posição Vertical Botões Folder
	nwHorBt3 := 448  * nPorcHorz //Posição Horizontal Botões Folder

	nTemp := ((nwHorCal-15)*2)+1
	If nwHorBt4 > nTemp+10
		nwHorBt4 := nTemp
	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fCorMark
Retorna a legenda da Marcacao

@sample
fCorMark(nTipo)

@author Denis Hyroshi de Souza
@since 27/11/2007
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fCorMark(nTipo)
	Local cRet := 'NG_SEM_INFO'

	If nTipo == 1
		If !(c990TRB1)->(EoF())
			cRet := IIf( Empty((c990TRB1)->MARCADO) , 'LBNO' , 'LBOK')
		EndIf
	Else
		If !(c990TRB3)->(EoF())
			cRet := IIf( Empty((c990TRB3)->MARCADO) , 'LBNO' , 'LBOK')
		EndIf
	EndIf

Return cRet

//----------------------------------------------------------------
/*/{Protheus.doc} MNT990DHF
Trazer data e hora apos a inserir a quantidade

@author Robson Cristian
@since 27/04/12
@version MP11 e MP12
@return .T.
/*/
//----------------------------------------------------------------
Function MNT990DHF()

	Local aDataHora := {}
	Local cHora		:= SubStr( TIME(),1,5 ) //Hora Atual

	//-----------------------------------------------------
	// Controle de Posições para captura de dados do Acols
	//-----------------------------------------------------
	Local nCod   := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
	Local nTReg  := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG"})
	Local nDIni  := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_DTINICI"})
	Local nHIni  := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_HOINICI"})
	Local nDFim  := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_DTFIM"  })
	Local nHFim  := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_HOFIM"  })
	Local nUCal  := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_USACALE"})

	//Caso não utilize calendário será atribuido data e hora atual.
	If	oGet:aCols[oGet:nAt][nUCal] <> 'S'
		oGet:aCols[oGet:nAt][nDIni]	:= _dDiaAtu
		oGet:aCols[oGet:nAt][nHIni] := cHora
	EndIf

	//Verifica se o Tipo de Insumo é Diferente de Produto para contabilizar as horas gastas.
	If oGet:aCols[oGet:nAt][nTReg] <> "P"

		If !Empty( StrTran( oGet:aCols[oGet:nAt][nHIni], ":", "", 1 ) )
			//Verifica se o Tipo de Insumo é M.O e se está Utilizando Calendário
			If oGet:aCols[oGet:nAt][nTReg] == "M" .And. oGet:aCols[oGet:nAt][nUCal] == 'S'
				//Retorna Data e Hora Final da O.S. com base no Calendário.
				aDataHora := NGDTHORFCALE(oGet:aCols[oGet:nAt][nDIni],; //Data Inicial da O.S.
										  oGet:aCols[oGet:nAt][nHIni],;	//Hora Inicial da O.S.
										  M->TL_QUANTID,;   //Quantidade Insumo O.S.
										  fGetCalen(oGet:aCols[oGet:nAt][nCod],;  //Código do Funcionário
													oGet:aCols[oGet:nAt][nDIni],; //Data Data Inicial da O.S.
													oGet:aCols[oGet:nAt][nDFim]) )//Retorna Código do Calendário.
			Else
				//Retorna Data e Hora Final da O.S. sem considerar Calendário.
				aDataHora := NGDTHORFIM( oGet:aCols[oGet:nAt][nDIni], oGet:aCols[oGet:nAt][nHIni], M->TL_QUANTID)
			EndIf
			oGet:aCols[oGet:nAt][nDFim] := aDataHora[1] //Data Final após soma dos insumos
			oGet:aCols[oGet:nAt][nHFim] := aDataHora[2] //Hora Final após soma dos insumos
		EndIf

	Else
		oGet:aCols[oGet:nAt][nDFim] := _dDiaAtu // Data Atual
		oGet:aCols[oGet:nAt][nHFim] := cHora	// Hora Atual
	EndIf

Return .T.

//----------------------------------------------------------------
/*/{Protheus.doc} VALDTFIM
Funcao para alimentar data fim ao insumo do tipo mão de obra

@param cCodFun: 	Código do Funcionário | Obrigatório
@param dIni:     	Data inicio
@param hIni:    	Hora inicio
@param dFim:   		Data fim
@param hFim:   	 	Hora fim

@author Tainã Alberto Cardoso
@since 18/06/2014
@version MP11
@return .T.
/*/
//----------------------------------------------------------------
Function VALDTFIM()

	Local nCod   := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
	Local nTReg  := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG"})
	Local nQuant := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID"})
	Local nDFim  := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_DTFIM" })
	Local nHFim  := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_HOFIM" })
	Local nUCal  := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_USACALE"})
	Local aDtfim := {} // Array que define Data e Hora Final da O.S.
	
	// Este processo somente é aplicado a insumos do tipo mão de obra.
	If oGet:aCols[oGet:nAt,nTReg] == 'M' .And. !Empty( M->TL_DTINICI ) .And. !Empty( M->TL_HOINICI )

		// Insumo utiliza o calendário.
		If oGet:aCols[oGet:nAt,nUCal] == 'S'

			// Retorna data e hora final do insumo com base no calendário.
			aDtFim  := NGDTHORFCALE( M->TL_DTINICI, M->TL_HOINICI, oGet:aCols[oGet:nAt,nQuant], fGetCalen( oGet:aCols[oGet:nAt,nCod],;
				M->TL_DTINICI, oGet:aCols[oGet:nAt,nDFim]) )

		Else
			
			// Retorna Data e Hora Final da O.S. sem considerar Calendário.
			aDtfim := NGDTHORFIM( M->TL_DTINICI, M->TL_HOINICI, oGet:aCols[oGet:nAt,nQuant] )

		EndIf

		oGet:aCols[oGet:nAt,nDFim] := aDtfim[1] // Data Final após soma dos insumos
		oGet:aCols[oGet:nAt,nHFim] := aDtfim[2] // Hora Final após soma dos insumos

	EndIf

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} fDtAtras
Verificar: se considerar O.S. atrasada, desabilita o parametro Data Inicio.

@sample
fDtAtras()

@author Taina Alberto Cardoso
@since 04/04/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fDtAtras()

	If M->TT1_CONDTA == "1"
		lAltDtIni := .F.
		M->TT1_DTDE := CTOD("  /  /  ")
	Else
		lAltDtIni := .T.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fDataFim
Valida a data fim do parametro de programacao

@sample
fDataFim()

@author Taina Alberto Cardoso
@since 04/04/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fDataFim()

	If M->TT1_CONDTA == "1" .And. M->TT1_DTATE < dDataBase
		MsgInfo(STR0284,STR0285)  //"Quando o parametro 'Data Atrasada' estiver igual a 'Sim' a data fim deve ser igual ou maior que a data base." ## "ATENÇÃO"
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fProgAuto
Verfica o parametro de programacao automatica

@sample
fProgAuto(nTipo,nOSPrInd)

@author Taina Alberto Cardoso
@since 04/04/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fProgAuto( nTipo, nOSPrInd, lClean )

	Local aMNTA9906 := {}
	Local cWhere    := '%'
	Local cTable    := '%' + oARQT9901:GetRealName() + '%'
	Local cAlsTRB1  := GetNextAlias()
	Local nIndex    := 0

	Default lClean := .F.

	dbSelectArea(c990TRB2)
	dbSetOrder(nTipoInd)
	dbGoBottom()
	cUltSeq := (c990TRB2)->SEQUENC

	If M->TT1_PROGAU == "4" .And. nTipo == 1

		// Atualiza com base na data do calendario
		Processa( { |lEND| fPrgChgDia( 2 ) }, STR0046 )

		Return .T.
	EndIf

	// Ao alterar a carga de à programar para em programação deve-se zerar as listas de insumos para recarga.
	If lClean .Or. lFilOsPro

		aList2 := {{ 0 , " " , 0 , 0 , 0 , 0 , 0 , "00:00" , "00:00" ,0 , " "}}
		aList3 := aList3Def
		aList4 := {{ " " , " " , " " , 0 }}
		aList5 := {{0, " ", " ", " ", "00:00", "00:00", 0, " " }}

	EndIf

	If nTipo == 1 .Or. nTipo == 3 .Or. nTipo == 2

		If nTipo == 2 .And. nOSPrInd == 2

			cWhere := 'TRB1.DTMPINI = ' + ValToSQL( oCalend:dDiaAtu )
				
		EndIf

		If nTipo == 1 .Or. nTipo == 3
			
			// Define o tipo de manutenção que será programada automaticamente.
			If M->TT1_PROGAU != '4'

				If M->TT1_PROGAU == '3'

					cWhere += "STE.TE_CARACTE IN ( 'C', 'P' )  AND "

				Else
					
					cWhere += 'STE.TE_CARACTE = ' + ValToSQL( IIf( M->TT1_PROGAU == '1', 'C', 'P' ) ) + ' AND '

				EndIf
			
			EndIf

			cWhere += 'TRB1.DTMPINI >= '  + ValToSQL( dTT1_DTPROG ) + ' AND '
			cWhere += 'TRB1.DTMPINI <= '  + ValToSQL( dTT1_DTFIM )
				
		EndIf
			
		cWhere += '%'

		BeginSQL Alias cAlsTRB1

			SELECT 
				TRB1.*
			FROM
				%exp:cTable% TRB1
			INNER JOIN
				%table:ST4% ST4 ON
					ST4.T4_SERVICO = TRB1.CODSER   AND
					ST4.T4_FILIAL  = %xFilial:ST4% AND
					ST4.%NotDel%
			INNER JOIN
				%table:STE% STE ON
					STE.TE_TIPOMAN = ST4.T4_TIPOMAN AND
					STE.TE_FILIAL  = %xFilial:STE%  AND
					STE.%NotDel%
			WHERE
				%exp:cWhere%

		EndSQL

		ProcRegua( (cAlsTRB1)->( RecCount() ) )

		While (cAlsTRB1)->( !EoF() )

			IncProc()

			If nTipo == 1 .Or. nTipo == 3
				
				cUltSeq := Soma1(cUltSeq)

				RecLock( c990TRB2, .T. )
				
				(c990TRB2)->MARCADO := "  "
				(c990TRB2)->PRIORID := (cAlsTRB1)->PRIORID
				If Type((cAlsTRB1)->PRIORID) == 'N'
					(c990TRB2)->PRIOINV := (Val((cAlsTRB1)->PRIORID) * -1)
				Else
					(c990TRB2)->PRIOINV := 0
				EndIf
				(c990TRB2)->ORDEM   := (cAlsTRB1)->ORDEM
				(c990TRB2)->PLANO   := (cAlsTRB1)->PLANO
				(c990TRB2)->CODBEM  := (cAlsTRB1)->CODBEM
				(c990TRB2)->SEQRELA := (cAlsTRB1)->SEQRELA
				(c990TRB2)->DESCRIC := (cAlsTRB1)->DESCRIC
				(c990TRB2)->CODSER  := (cAlsTRB1)->CODSER
				(c990TRB2)->DESSER  := (cAlsTRB1)->DESSER
				(c990TRB2)->EQUIPE  := (cAlsTRB1)->EQUIPE
				(c990TRB2)->DTMPINI := sToD( (cAlsTRB1)->DTMPINI )

				If !Empty(cStProg990)
					(c990TRB2)->XSTATUS := cStProg990
					(c990TRB2)->LIBERA  := '1'

					If (cAlsTRB1)->REALIZA == '0'
						(c990TRB2)->DTMPINI := _dDiaAtu
					EndIf

					(c990TRB2)->DTMPROG := sToD( (cAlsTRB1)->DTMPINI )
				Else
					(c990TRB2)->XSTATUS := (cAlsTRB1)->XSTATUS
					If lCpoTT2Dt
						(c990TRB2)->DTMPROG := sToD( (cAlsTRB1)->DTMPINI )
					EndIf
				EndIf
				(c990TRB2)->SEQUENC := cUltSeq
				(c990TRB2)->DTORIGI := sToD( (cAlsTRB1)->DTORIGI )
				(c990TRB2)->SITUACA := (cAlsTRB1)->SITUACA
				(c990TRB2)->REALIZA := (cAlsTRB1)->REALIZA
				If !Empty(cEventoOS)
					(c990TRB2)->EVENTO  := cEventoOS
				EndIf

				// P.E. que atribui conteúdo aos campos de usuário criados pelo P.E. MNTA9902.
				If lMNTA9906 .And. ValType( aMNTA9906 := ExecBlock( 'MNTA9906', .F., .F., { c990TRB2, aDBFa } ) ) == 'A'

					For nIndex := 1 To Len( aMNTA9906 )

						// Valida a existência do campo na tabela temporária.
						If (c990TRB2)->( FieldPos( aMNTA9906[nIndex,1] ) ) > 0
							(c990TRB2)->&( aMNTA9906[nIndex,1] ) := aMNTA9906[nIndex,2]
						EndIf

					Next nIndex

				EndIf

				(c990TRB2)->( MsUnLock() )

				RecLock( c990TRB3, .T. )
			
				(c990TRB3)->MARCADO := "  "
				(c990TRB3)->PRIORID := (cAlsTRB1)->PRIORID
				If Type((cAlsTRB1)->PRIORID) == 'N'
					(c990TRB3)->PRIOINV := (Val((cAlsTRB1)->PRIORID) * -1)
				Else
					(c990TRB3)->PRIOINV := 0
				EndIf
				(c990TRB3)->ORDEM   := (cAlsTRB1)->ORDEM
				(c990TRB3)->PLANO   := (cAlsTRB1)->PLANO
				(c990TRB3)->CODBEM  := (cAlsTRB1)->CODBEM
				(c990TRB3)->SEQRELA := (cAlsTRB1)->SEQRELA
				(c990TRB3)->DESCRIC := (cAlsTRB1)->DESCRIC
				(c990TRB3)->CODSER  := (cAlsTRB1)->CODSER
				(c990TRB3)->DESSER  := (cAlsTRB1)->DESSER
				(c990TRB3)->EQUIPE  := (cAlsTRB1)->EQUIPE
				(c990TRB3)->DTMPINI := sToD( (cAlsTRB1)->DTMPINI )
				If !Empty(cStProg990)
					(c990TRB3)->XSTATUS := cStProg990
					(c990TRB3)->LIBERA  := '1'
					
					If (cAlsTRB1)->REALIZA == '0'
						(c990TRB3)->DTMPINI := sToD( (cAlsTRB1)->DTMPINI )
					EndIf

					(c990TRB3)->DTMPROG := sToD( (cAlsTRB1)->DTMPINI )
					If _dDiaAtu < dTT1_DTPROG
						dTT1_DTPROG := _dDiaAtu
						If nOSPrInd == 1
							lMudouDt := .T.
						EndIf
					EndIf
					If _dDiaAtu > dTT1_DTFIM
						dTT1_DTFIM := _dDiaAtu
						If nOSPrInd == 1
							lMudouDt := .T.
						EndIf
					EndIf
				Else
					(c990TRB3)->XSTATUS := (cAlsTRB1)->XSTATUS
					If lCpoTT2Dt
						(c990TRB3)->DTMPROG := sToD( (cAlsTRB1)->DTMPINI )
						If _dDiaAtu < dTT1_DTPROG
							dTT1_DTPROG := _dDiaAtu
							If nOSPrInd == 1
								lMudouDt := .T.
							EndIf
						EndIf
						If _dDiaAtu > dTT1_DTFIM
							dTT1_DTFIM := _dDiaAtu
							If nOSPrInd == 1
								lMudouDt := .T.
							EndIf
						EndIf
					EndIf
				EndIf
				(c990TRB3)->SEQUENC := cUltSeq
				(c990TRB3)->DTORIGI := sToD( (cAlsTRB1)->DTORIGI )
				(c990TRB3)->SITUACA := (cAlsTRB1)->SITUACA
				(c990TRB3)->REALIZA := (cAlsTRB1)->REALIZA
				If !Empty(cEventoOS)
					(c990TRB3)->EVENTO  := cEventoOS
				EndIf

				// P.E. que atribui conteúdo aos campos de usuário criados pelo P.E. MNTA9902.
				If lMNTA9906 .And. ValType( aMNTA9906 := ExecBlock( 'MNTA9906', .F., .F., { c990TRB3, aDBFa } ) ) == 'A'

					For nIndex := 1 To Len( aMNTA9906 )

						// Valida a existência do campo na tabela temporária.
						If (c990TRB3)->( FieldPos( aMNTA9906[nIndex,1] ) ) > 0
							(c990TRB3)->&( aMNTA9906[nIndex,1] ) := aMNTA9906[nIndex,2]
						EndIf

					Next nIndex

				EndIf

				(c990TRB3)->( MsUnLock() )

				dbSelectArea(c990TRB1)
				dbGoTo( (cAlsTRB1)->R_E_C_N_O_ )
				RecLock(c990TRB1,.F.)
				dbDelete()
				MsUnLock(c990TRB1)
			
			EndIf

			(cAlsTRB1)->( dbSkip() )

		End

		(cAlsTRB1)->( dbCloseArea() )

	EndIf

	// Carrega mão de obra e especialidade utilizadas nas O.S. à programar
	fUpdFolds( oARQT9901:GetRealName(), .T., .T. )

	If nTipo == 1 .Or. nTipo == 3 .Or. nTipo == 4
		//Atualiza com base na data do calendario
		Processa({|lEND| fPrgChgDia(2)},STR0046)
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fParMnt990
Monta a tela de parametros da programacao

@sample
fParMnt990(nTipo)

@author Taina Alberto Cardoso
@since 04/04/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fParMnt990(nTipo)

	Local oPanelPar
	Local aNgBtPar := {}
	Local lConfirm := .F.
	Private oBoxEstr, aIndEstr := {STR0321,STR0322}//"1=Sim", "2=Não"
	lAltAteBem := ( INCLUI .Or. ALTERA )

	If nTipo == 2  .Or. (INCLUI .Or. ALTERA)
		
		DEFINE MSDIALOG oDlgPar TITLE Oemtoansi(STR0033) From  0,0 To nTamParam,480 OF oMainWnd COLOR CLR_BLACK,CLR_WHITE PIXEL

		If nTipo == 1 //Inclusao
			//Carrega os campos "de Data" e "ate Data"
			If lAltDtIni
				M->TT1_DTDE  := dSvTT1INI
			EndIf
			M->TT1_DTATE := dSvTT1FIM
		EndIf

		oPanelPar := TPanel():New(0, 0, Nil, oDlgPar, Nil, .T., .F., Nil, Nil, 0, 0, .T., .F. )
		oPanelPar:Align := CONTROL_ALIGN_ALLCLIENT

		@ 009,010  Say OemtoAnsi( STR0034 ) SIZE 55,07 Of oPanelPar Pixel // De Bem
		@ 009,060  MsGet M->TT1_BEMDE Valid IIf( Empty( M->TT1_BEMDE ), .T., ExistCpo( 'ST9', M->TT1_BEMDE ) ) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 'ST9' When lAltProg HASBUTTON

		@ 009,127  Say OemtoAnsi( STR0035 ) SIZE 55,07 Of oPanelPar Pixel // Ate Bem
		@ 009,167  MsGet M->TT1_BEMATE Valid AteCodigo("ST9",M->TT1_BEMDE,M->TT1_BEMATE,16) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 "ST9" When lAltAteBem HASBUTTON

		@ 020,010  Say OemtoAnsi( STR0036 ) SIZE 55,07 Of oPanelPar Pixel // De Equipe
		@ 020,060  MsGet M->TT1_EQUDE Valid IIf( Empty( M->TT1_EQUDE ), .T., ExistCpo( cTabEquipe, M->TT1_EQUDE ) ) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 cTabEquipe When lAltProg HASBUTTON

		@ 020,127  Say OemtoAnsi( STR0037 ) SIZE 55,07 Of oPanelPar Pixel // Ate Equipe
		@ 020,167  MsGet M->TT1_EQUATE Valid AteCodigo(cTabEquipe,M->TT1_EQUDE,M->TT1_EQUATE,6) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 cTabEquipe When lAltProg HASBUTTON

		@ 031,010  Say OemtoAnsi( STR0038 ) SIZE 55,07 Of oPanelPar Pixel // De C.Custo
		@ 031,060  MsGet M->TT1_CCDE Valid IIf( Empty( M->TT1_CCDE ), .T., ExistCpo( 'CTT', M->TT1_CCDE ) )  Picture '@!' Size 50,7 Of oPanelPar Pixel F3 'CTT' When lAltProg HASBUTTON

		@ 031,127  Say OemtoAnsi( STR0039 ) SIZE 55,07 Of oPanelPar Pixel // Ate C.Custo
		@ 031,167  MsGet M->TT1_CCATE  Valid AteCodigo("CTT",M->TT1_CCDE,M->TT1_CCATE,nSizeSI3) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 "CTT" When lAltProg HASBUTTON

		@ 042,010  Say OemtoAnsi( STR0042 ) SIZE 55,07 Of oPanelPar Pixel // Data Inicio
		@ 042,060  MsGet oGet001 Var M->TT1_DTDE  Picture '99/99/9999' Size 50,7 Of oPanelPar Pixel When lAltDtIni HASBUTTON

		@ 042,127  Say OemtoAnsi( STR0043 ) SIZE 55,07 Of oPanelPar Pixel // Data Fim
		@ 042,167  MsGet oGet002 Var M->TT1_DTATE  Valid fDataFim() Picture '99/99/9999' Size 50,7 Of oPanelPar Pixel When lAltProg HASBUTTON

		aAdd(aNgBtPar,{"btcalend", {|| fCalFiltro()},STR0201,STR0273})

		nLinDt := 044

		If lCpoStatus

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0040 ) SIZE 55,07 Of oPanelPar Pixel // De Status
			@ nLinDt,060  MsGet M->TT1_STADE Valid IIf( Empty( M->TT1_STADE ), .T., ExistCpo( cTabStatus, M->TT1_STADE ) ) Picture '@!' Size 40,7 Of oPanelPar Pixel F3 cTabStatus When lAltProg HASBUTTON

			@ nLinDt,127  Say OemtoAnsi( STR0041 ) SIZE 55,07 Of oPanelPar Pixel // Ate Status
			@ nLinDt,167  MsGet M->TT1_STAATE Valid AteCodigo(cTabStatus,M->TT1_STADE,M->TT1_STAATE,2) Picture '@!' Size 40,7 Of oPanelPar Pixel F3 cTabStatus When lAltProg HASBUTTON

		EndIf

		If lCpoTrab

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0202 ) SIZE 55,07 Of oPanelPar Pixel // De C.Trabalho
			@ nLinDt,060  MsGet M->TT1_TRADE  Valid IIf( Empty( M->TT1_TRADE ), .T., ExistCpo( 'SHB', M->TT1_TRADE ) )  Picture '@!' Size 50,7 Of oPanelPar Pixel F3 'SHB' When lAltProg HASBUTTON

			@ nLinDt,127  Say OemtoAnsi( STR0203 ) SIZE 55,07 Of oPanelPar Pixel // Ate C.Trabalho
			@ nLinDt,167  MsGet M->TT1_TRAATE  Valid AteCodigo("SHB",M->TT1_TRADE,M->TT1_TRAATE,nSizeSHB) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 "SHB" When lAltProg HASBUTTON

		EndIf

		If lCpoFamB

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0204 ) SIZE 55,07 Of oPanelPar Pixel // De Família
			@ nLinDt,060  MsGet M->TT1_FAMDE Valid IIf( Empty( M->TT1_FAMDE ), .T., ExistCpo( 'ST6', M->TT1_FAMDE ) )  Picture '@!' Size 50,7 Of oPanelPar Pixel F3 'ST6' When lAltProg HASBUTTON

			@ nLinDt,127  Say OemtoAnsi( STR0205 ) SIZE 55,07 Of oPanelPar Pixel // Ate Família
			@ nLinDt,167  MsGet M->TT1_FAMATE  Valid AteCodigo("ST6",M->TT1_FAMDE,M->TT1_FAMATE,nSizeST6) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 "ST6" When lAltProg HASBUTTON

		EndIf

		If lCpoTipM

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0206 ) SIZE 55,07 Of oPanelPar Pixel // De Tipo Manut.
			@ nLinDt,060  MsGet M->TT1_TIPDE Valid IIf( Empty( M->TT1_TIPDE ), .T., ExistCpo( 'STE', M->TT1_TIPDE ) ) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 'STE' When lAltProg HASBUTTON

			@ nLinDt,127  Say OemtoAnsi( STR0207 ) SIZE 55,07 Of oPanelPar Pixel // Ate Tipo Manut.
			@ nLinDt,167  MsGet M->TT1_TIPATE  Valid AteCodigo("STE",M->TT1_TIPDE,M->TT1_TIPATE,nSizeSTE) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 "STE" When lAltProg HASBUTTON

		EndIf

		If lCpoAreM

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0208 ) SIZE 55,07 Of oPanelPar Pixel // De Área Manut.
			@ nLinDt,060  MsGet M->TT1_AREDE Valid IIf( Empty( M->TT1_AREDE ), .T., ExistCpo( 'STD', M->TT1_AREDE ) )  Picture '@!' Size 50,7 Of oPanelPar Pixel F3 'STD' When lAltProg HASBUTTON

			@ nLinDt,127  Say OemtoAnsi( STR0209 ) SIZE 55,07 Of oPanelPar Pixel // Ate Área Manut.
			@ nLinDt,167  MsGet M->TT1_AREATE  Valid AteCodigo("STD",M->TT1_AREDE,M->TT1_AREATE,nSizeSTD) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 "STD" When lAltProg HASBUTTON

		EndIf

		If lCpoServ

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0210 ) SIZE 55,07 Of oPanelPar Pixel // De Serviço
			@ nLinDt,060  MsGet M->TT1_SERDE Valid IIf( Empty( M->TT1_SERDE ), .T., ExistCpo( 'ST4', M->TT1_SERDE ) ) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 'ST4' When lAltProg HASBUTTON

			@ nLinDt,127  Say OemtoAnsi( STR0211 ) SIZE 55,07 Of oPanelPar Pixel // Ate Serviço
			@ nLinDt,167  MsGet M->TT1_SERATE  Valid AteCodigo("ST4",M->TT1_SERDE,M->TT1_SERATE,nSizeST4) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 "ST4" When lAltProg HASBUTTON

		EndIf

		If lCpoOrde

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0212 ) SIZE 55,07 Of oPanelPar Pixel // De Ordem
			@ nLinDt,060  MsGet M->TT1_ORDDE Valid IIf( Empty( M->TT1_ORDDE ), .T., ExistCpo( 'STJ', M->TT1_ORDDE ) ) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 'STJ' When lAltProg HASBUTTON

			@ nLinDt,127  Say OemtoAnsi( STR0213 ) SIZE 55,07 Of oPanelPar Pixel // Ate Ordem
			@ nLinDt,167  MsGet M->TT1_ORDATE  Valid AteCodigo("STJ",M->TT1_ORDDE,M->TT1_ORDATE,nSizeSTJ) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 "STJ" When lAltProg HASBUTTON

		EndIf

		If lCpoPlan

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0214 ) SIZE 55,07 Of oPanelPar Pixel // De Plano
			@ nLinDt,060  MsGet M->TT1_PLADE Valid IIf( Empty( M->TT1_PLADE ), .T., ExistCpo( 'STI', M->TT1_PLADE ) ) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 'STI' When lAltProg HASBUTTON

			@ nLinDt,127  Say OemtoAnsi( STR0215 ) SIZE 55,07 Of oPanelPar Pixel // Ate Plano
			@ nLinDt,167  MsGet M->TT1_PLAATE  Valid AteCodigo("STI",M->TT1_PLADE,M->TT1_PLAATE,nSizeSTS) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 "STI" When lAltProg HASBUTTON

		EndIf

		If lCpoEvent .And. lPrgEvento

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0216 ) SIZE 55,07 Of oPanelPar Pixel // De Evento
			@ nLinDt,060  MsGet M->TT1_EVEDE Valid IIf( Empty( M->TT1_EVEDE ), .T., ExistCpo( 'TTQ', M->TT1_EVEDE ) ) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 'TTQ' When lAltProg HASBUTTON

			@ nLinDt,127  Say OemtoAnsi(STR0217) SIZE 55,07 Of oPanelPar Pixel // Ate Evento
			@ nLinDt,167  MsGet M->TT1_EVEATE  Valid AteCodigo("TTQ",M->TT1_EVEDE,M->TT1_EVEATE,nSizeEve) Picture '@!' Size 50,7 Of oPanelPar Pixel F3 "TTQ" When lAltProg HASBUTTON

		EndIf

		If lCpoLbLoc

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0245 ) SIZE 55,07 Of oPanelPar Pixel // O.S. Lubrific. ?
			@ nLinDt,060  Combobox oBoxLub VAR M->TT1_INDLUB ITEMS aIndLub SIZE 40,10 PIXEL Of oPanelPar When lAltProg

			@ nLinDt,127  Say OemtoAnsi( STR0246 ) SIZE 55,07 Of oPanelPar Pixel // O.S. Localiz. ?
			@ nLinDt,167  Combobox oBoxLoc VAR M->TT1_INDLOC ITEMS aIndLoc SIZE 40,10 PIXEL Of oPanelPar When lAltProg

		EndIf

		If lCpoContDt

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0282 ) SIZE 55,07 Of oPanelPar Pixel  // Data Atrasada?
			@ nLinDt,060  Combobox oBoxDtAt VAR M->TT1_CONDTA Valid fDtAtras() ITEMS aIndDtAt SIZE 40,10 PIXEL Of oPanelPar When lAltProg

			@ nLinDt,127  Say OemtoAnsi( STR0283 ) SIZE 55,07 Of oPanelPar Pixel  // Prog. Auto. ?
			@ nLinDt,167  Combobox oBoxDtAt VAR M->TT1_PROGAU ITEMS aIndPrAu SIZE 50,10 PIXEL Of oPanelPar When lAltProg

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0299 ) SIZE 55,07 Of oPanelPar Pixel  // De Calendário
			@ nLinDt,060  MsGet M->TT1_CALEDE Picture '@!' Size 30,7 Of oPanelPar Pixel F3 'SH7' When lAltProg HASBUTTON

			@ nLinDt,127  Say OemtoAnsi( STR0300 ) SIZE 55,07 Of oPanelPar Pixel  // Até Calendário
			@ nLinDt,167  MsGet M->TT1_CALEAT Picture '@!' Size 30,7 Of oPanelPar Pixel F3 "SH7"  When lAltProg HASBUTTON

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0288 ) SIZE 55,07 Of oPanelPar Pixel  // De Prioridade
			@ nLinDt,060  MsGet M->TT1_PRIDE Picture '@!' Size 30,7 Of oPanelPar Pixel  When lAltProg

			@ nLinDt,127  Say OemtoAnsi( STR0289 ) SIZE 55,07 Of oPanelPar Pixel  // Até Prioridade
			@ nLinDt,167  MsGet M->TT1_PRIATE Valid (Naovazio(M->TT1_PRIATE))Picture '@!' Size 30,7 Of oPanelPar Pixel  When lAltProg

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0298 ) SIZE 55,07 Of oPanelPar Pixel  // De Etapa
			@ nLinDt,060  MsGet M->TT1_ETADE Picture '@!' Size 40,7 Of oPanelPar Pixel F3 'TPA' When lAltProg HASBUTTON

			@ nLinDt,127  Say OemtoAnsi( STR0297 ) SIZE 55,07 Of oPanelPar Pixel  // Até Etapa
			@ nLinDt,167  MsGet M->TT1_ETAAT Picture '@!' Size 40,7 Of oPanelPar Pixel F3 "TPA" When lAltProg HASBUTTON

			nLinDt += 11

			@ nLinDt,010  Say OemtoAnsi( STR0296 ) SIZE 55,07 Of oPanelPar Pixel // Incremento
			@ nLinDt,060  Combobox oBoxInc VAR M->TT1_INCRE VALID fValIncDt() ITEMS aIndInc SIZE 50,10 PIXEL Of oPanelPar When lAltProg

			@ nLinDt,127  Say OemtoAnsi( STR0295 ) SIZE 55,07 Of oPanelPar Pixel  // Dias
			@ nLinDt,167  MsGet M->TT1_QTDDIA Picture '9999' Size 30,7 Of oPanelPar Pixel  When lAltProg .And. lWhenInc

			nLinDt += 11

			@ nLinDt,010 Say OemtoAnsi( STR0320 ) SIZE 55,07 Of oPanelPar Pixel // Estrutura?
			@ nLinDt,060 Combobox oBoxEstr VAR M->TT1_ESTRUT Valid fEstrutura() ITEMS aIndEstr SIZE 40,10 PIXEL Of oPanelPar When lAltProg

		EndIf


		@ 011.5,nwHorCal+143  Say OemToAnsi( STR0052 ) SIZE 55,07 Of oPanelPar Pixel // Localizar O.S.:
		@ 011.4,nwHorCal+188  MsGet cBuscaOS Valid fLocalizOS() Picture '@!' Size 30,5 Of oPanelPar Pixel When lAltProg HASBUTTON

		@ 023.5,nwHorCal+143  Say OemToAnsi( STR0053 ) SIZE 55,07 Of oPanelPar Pixel // Ordenar O.S. por:
		@ 023.5,nwHorCal+188  Combobox oBoxObj VAR cTipoInd ITEMS aTipoInd SIZE 55,10 Of oPanelPar PIXEL ON CHANGE (fAltBox(cTipoInd))

		If lCpoTT2Dt .And. lCpoVerOs
			@ 034,nwHorCal+143 To 065, nwHorCal+243 LABEL Oemtoansi(STR0218) OF oPanelPar PIXEL //"Ver O.S. Programadas"
			@ 041,nwHorCal+145 RADIO oBoxOSP VAR nOSPrInd ITEMS STR0219,STR0220 3D ; //"Todas"###"Data selecionada no calendário"
			ON CHANGE fAltBoxOS(nOSPrInd) SIZE 100,20 PIXEL OF oPanelPar When lAltProg
		EndIf

		If lPrgEvento .And. lPrgDiaria

			@ 065.5,nwHorCal+143  Say OemToAnsi( STR0221 ) SIZE 55,07 Of oPanelPar Pixel // Código do Evento:
			@ 065.4,nwHorCal+188  MsGet oCodEvento Var cEventoOS Valid VldCodEve() Picture '@!' F3 "TTQ" Size 30,5 Of oPanelPar Pixel When lAltProg HASBUTTON
			oCodEvento:cToolTip := STR0222 //"Ao transferir uma O.S. do lado esquerdo para o lado direito, automaticamente será atribuido este Código do Evento à ela."

		EndIf

		Activate MsDialog oDlgPar On Init EnchoiceBar( oDlgPar, { || lConfirm := .T., fBuscaOS( 1 ), oDlgPar:End() },;
			{ || oDlgPar:End() }, , aNgBtPar ) CENTERED

	ENdIf

	If lConfirm

		// Atualiza legenda do calendário.
		Processa( { |lEND| fPrgChgMes( 1, @oCalend ) }, STR0046 ) // Atualizando Calendário...

		/*--------------------------------------------------------------------+
		| Realiza o reload dos folders conforme as definições da programação. |
		+--------------------------------------------------------------------*/
		fLoadTTXX( .T., ( nOSPrInd == 1 ) )

	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fTrocaFolder
Função executada na troca de folders

@sample
fTrocaFolder(nOpcFol)

@author Taina Alberto Cardoso
@since 10/04/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fTrocaFolder(nOpcFol)

	If nOpcFol == 1

		oBtnVisCo:Hide()
		oBtnImpSA:Hide()

		If lIntegRM
			
			oBtnSldRM:Hide()

		EndIf

		oBtnDeEsp:Show()

	ElseIf nOpcFol == 2

		oBtnVisCo:Show()
		oBtnImpSA:Show()

		If lIntegRM
			
			oBtnSldRM:Show()

		EndIf

		oBtnDeEsp:Hide()

	ElseIf nOpcFol == 3

		oBtnVisCo:Hide()
		oBtnImpSA:Hide()
		oBtnDeEsp:Hide()

		If lIntegRM
			
			oBtnSldRM:Hide()

		EndIf

	ElseIf nOpcFol == 4

		oBtnVisCo:Hide()
		oBtnImpSA:Hide()
		oBtnDeEsp:Hide()

		If lIntegRM
			
			oBtnSldRM:Hide()

		EndIf

	EndIf

Return .T.

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fTrocaCarg
Atualiza datas da O.S. e insumos diretamente na tabela temporária.
@type function

@author Tainã Alberto Cardoso
@since 15/06/2012

@sample fTrocaCarg( 1, oObj )

@param  nTipo , Númerico, 1 - O.S. à programar / 2 - O.S. em programação.
@param  oCarga, Objeto  , Objeto que controla a carga que está em foco.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fTrocaCarg( nTipo, oCarga )

	Local dLastDay := LastDay( dDataBase, 2 )

	If nTipo == 1

		lFilOsPro := .F.
		oCarga:SetText( STR0286 ) // Carga a Programar

		// Verificando Disponibilidade da Mão-de-Obra
		Processa( { |lEND| fDispoST1( .T., .F., dDataBase, IIf( dTT1_DTFIM > dLastDay, dLastDay, dTT1_DTFIM ) ) }, STR0020 )

	Else

		lFilOsPro := .T.
		oCarga:SetText( STR0287 ) // Carga em Programação

		// Se os folders estiverem apresentando os dados conforme a data setada no calendário.
		If nOSPrInd == 2

			// Verificando Disponibilidade da Mão-de-Obra
			Processa( { |lEND| fDispoST1( .T., .F., _dDiaAtu, _dDiaAtu ) }, STR0020 )

		EndIf

	EndIf

	Processa( {|lEND| fProgAuto( 4, nOSPrInd ) }, STR0045 ) // Filtrando Ordens de Serviços

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fValIncDt
Uso MNTA990

@sample
fValIncDt()

@author Taina Alberto Cardoso
@since 03/09/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fValIncDt()

	If	M->TT1_INCRE == ""
		lWhenInc := .F.
		M-> TT1_QTDDIA := 0
	Else
		lWhenInc := .T.
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fAddFBem
Altera a Query para que os filhos do Bem também sejam considerados no filtro de busca.

@obs.: Função proveniente do ponto de entrada MNTA9909 da versão 11.

@return Nil

@sample
fAddFBem(cQuery)

@author Wexlei Silveira
@since 17/07/2015
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fAddFBem(cQuery)

	Local nX, aEstBem := {}
	Local nPos, nPos1
	Local cQueryB := ""

	cQueryB := cQuery

	If M->TT1_ESTRUT == '1'
		nPos := At("AND STJ.TJ_CODBEM >=",cQuery)
		nPos1 := At("AND",SubString(cQuery,nPos+1,Len(cQuery)))
		If nPos > 0
			cQueryB := SubString(cQuery,1,nPos-1) + SubString(cQuery,nPos+nPos1-1,Len(cQuery))
		EndIf

		nPos := At("AND STJ.TJ_CODBEM <=",cQueryB)
		nPos1 := At("AND",SubString(cQueryB,nPos+1,Len(cQueryB)))
		If nPos > 0
			cQueryB := SubString(cQueryB,1,nPos-1) + SubString(cQueryB,nPos+nPos1-1,Len(cQueryB))
		EndIf

		cQueryB += " AND (STJ.TJ_CODBEM = " + ValToSql(M->TT1_BEMDE)

		M->TT1_BEMATE := M->TT1_BEMDE

		//Função q retorna Bem pai e seus filhos
		aEstBem := NGCOMPEST(M->TT1_BEMDE, "B")//NGCOMPPCONT(M->TT1_BEMDE,dDataBase,SubStr(Time(),1,5))
		If Len(aEstBem) > 0

			cQueryB += " OR STJ.TJ_CODBEM IN ("

			For nX := 1 to Len(aEstBem)
				If nX == 1
					cQueryB += "'" + Alltrim(aEstBem[nX]) + "'"
				Else
					cQueryB += ",'" + Alltrim(aEstBem[nX]) + "'"
				EndIf
			Next nX
			cQueryB += ") "
		EndIf
		cQueryB += ") "
	EndIf

Return cQueryB
//---------------------------------------------------------------------
/*/{Protheus.doc} fEstrutura
Verificar: se considerar Estrutura, desabilita o parametro Até Bem.

@sample
fDtAtras()

@author Wexlei Silveira
@since 21/07/2015
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fEstrutura()

	If M->TT1_ESTRUT == "2"
		lAltAteBem := .T.
		M->TT1_BEMATE := "ZZZZZZZZZZZZZZZZ"
	Else
		lAltAteBem := .F.
		M->TT1_BEMATE := ""
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetCalen
Verifica se o turno é Flutuante e retorna Código do Calendário

@author Eduardo Mussi
@since 29/09/2017
@Param  cCodFun - Código do Funcionário		- Obrigatório
		cDtIni  - Data Inicio O.S.			- Obrigatório
		cDtFim  - Data Fim O.S.				- Obrigatório
/*/
//---------------------------------------------------------------------
Static Function fGetCalen(cCodFun, dDtIni, dDtFim)

	Local cCodCal	:= ""

	//Caso data fim venha vazio, é colocado data inicio para validar calendario.
	dDtFim := IIf( !Empty( dDtFim ), dDtFim, dDtIni )

	If lNGFlut

		//Verifica qual o calendário do Funcionário quando usa Turno Flutuante
		cCodCal := MNTCALFLU( cCodFun,dDtIni,dDtFim )

		If Empty( cCodCal )
			//Se o funcionário não estiver relacionado à uma equipe de manutenção retorna Código do Calendário do Funcionário.
			cCodCal := NGSEEK( "ST1",Substr( cCodFun,1,6),1,"T1_TURNO" )
		EndIf

	Else

		cCodCal := NGSEEK( "ST1",Substr( cCodFun,1,6),1,"T1_TURNO" )
		
	EndIf

Return cCodCal

//----------------------------------------------------------------
/*/{Protheus.doc} fImpCabec
Imprime os cabeçalhos

@sample
fImpCabec(nTipo)

@Param  nTipo - Tipo de Insumo      		       - Obrigatório
                1 = Especialidade
				2 = Produto
				3 = Ferramenta
				4 = Mão de Obra

		lCabec  - Variavel para imprimir cabeçalho - Obrigatório

@author Tainã Alberto Cardoso
@since 08/01/2018
@version 1.0
/*/
//----------------------------------------------------------------
Static Function fImpCabec( nTipo,lCabec)

	Default nTipo = 0
	Default lCabec := .F.

	If lCabec

		oPrint:StartPage()
		nLin := 200
		oPrint:Say(130,3050,Alltrim(Str(nPag1,6)),oFont08)

		cFileLogo := NGLOCLOGO()

		If File(cFileLogo)
			oPrint:SayBitMap(150,150,cFileLogo,250,120)
		EndIf

		cDescTit := ""
		If !Empty(cTT1_DESCRI)
			cDescTit := Alltrim(cTT1_DESCRI)
		Else
			cDescTit := STR0098 //"PROGRAMAÇÃO"
		Endif
		cDescTit += STR0156 + DtoC(dTT1_DTPROG) + " - " + DtoC(dTT1_DTFIM) //" - PERÍODO: "
		oPrint:Say(nLin,800,cDescTit,oFont20)

		oPrint:Say(nLin,2100,STR0157+cTT1_CODIGO,oFont20) //"NÚMERO: "

	EndIf

	If nTipo == 1

		nLin += 100

		oPrint:Say(nLin,1150,STR0266,oFont20) //"Relatório de Especialidades"

		nLin += 40
		oPrint:Line(nLin,100,nLin,2320)

		nLin += 35
		oPrint:Say(nLin,0100,STR0083,oFont12) //"Código"
		oPrint:Say(nLin,0200,STR0074,oFont12) //"Especialidade"
		oPrint:Say(nLin,0510,STR0075,oFont12) //"Total Técnicos"
		oPrint:Say(nLin,0735,STR0164,oFont12) //"Adicionais("
		oPrint:Say(nLin,0890,STR0165,oFont12) //"Técnicos  x"
		oPrint:Say(nLin,1030,STR0166,oFont12) //"Dias )"
		oPrint:Say(nLin,1190,STR0167,oFont12) //"Ausentes("
		oPrint:Say(nLin,1330,STR0165,oFont12) //"Técnicos  x"
		oPrint:Say(nLin,1480,STR0166,oFont12) //"Dias )"
		oPrint:Say(nLin,1645,STR0080,oFont12) //"Tempo Programado"
		oPrint:Say(nLin,1940,STR0168,oFont12) //"Tempo Disponível"
		oPrint:Say(nLin,2190,STR0082,oFont12) //"% Utilizada"

		nLin += 30
		oPrint:Line(nLin,100,nLin,2320)

		nLin += 30

	ElseIf nTipo == 2

		nLin += 100

		oPrint:Say(nLin,1200,STR0169,oFont20) //"Relatório de Produtos"

		nLin += 40

		oPrint:Line(nLin,100,nLin,2320)

		nLin += 35

		oPrint:Say(nLin,0100,STR0010,oFont12) //"Ordem"
		oPrint:Say(nLin,0200,STR0083,oFont12) //"Codigo"
		oPrint:Say(nLin,0420,STR0031,oFont12) //"Produto"
		oPrint:Say(nLin,0600,STR0170,oFont12) //"Qtd. Necessária"
		oPrint:Say(nLin,0820,STR0171,oFont12) //"Unidade"
		oPrint:Say(nLin,0970,STR0223,oFont12) //"Estoque Físico"
		oPrint:Say(nLin,1220,STR0172,oFont12) //"Qtd. em Estoque"
		oPrint:Say(nLin,1440,STR0173,oFont12) //"Numero S.A."
		oPrint:Say(nLin,1630,STR0174,oFont12) //"Item"
		oPrint:Say(nLin,1900,STR0175,oFont12) //"Numero S.C."
		oPrint:Say(nLin,2160,STR0015,oFont12) //"Data Prevista"

		nLin += 30

		oPrint:Line(nLin,100,nLin,2320)

		nLin += 30

	ElseIf nTipo == 3

		nLin += 100

		oPrint:Say(nLin,1200,STR0176,oFont20) //"Relatório de Ferramentas"

		nLin += 40

		oPrint:Line(nLin,100,nLin,2320)

		nLin += 35

		oPrint:Say(nLin,0100,STR0010,oFont12) //"Ordem"
		oPrint:Say(nLin,0230,STR0083,oFont12) //"Codigo"
		oPrint:Say(nLin,0430,STR0012,oFont12) //"Descrição"
		oPrint:Say(nLin,1270,STR0170,oFont12) //"Qtd. Necessária"

		nLin += 30

		oPrint:Line(nLin,100,nLin,2320)

		nLin += 30

	ElseIf nTipo == 4

		nLin += 100

		oPrint:Say(nLin,1200,STR0163,oFont20) //"Relatório de Mão-de-Obra"

		nLin += 40

		oPrint:Line(nLin,100,nLin,2320)

		nLin += 35

		oPrint:Say(nLin,0100,NGRETTITULO("T1_CODFUNC"),oFont12) //Matricula
		oPrint:Say(nLin,0230,NGRETTITULO("T1_NOME"),oFont12) //Nome
		oPrint:Say(nLin,0680,STR0083,oFont12) //"Código"
		oPrint:Say(nLin,0840,STR0074,oFont12) //"Especialidade"
		oPrint:Say(nLin,1450,STR0080,oFont12) //"Tempo Programado"
		oPrint:Say(nLin,1750,STR0168,oFont12) //"Tempo Disponível"
		oPrint:Say(nLin,2175,STR0082,oFont12) //"% Utilizada"

		nLin += 30

		oPrint:Line(nLin,100,nLin,2320)

		nLin += 30

	EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} fValBloAus
Verifica Ausência e Bloqueio do Funcionário
@author  Eduardo Mussi
@since   28/03/18
@version P12
@param  cCodeFunc, Caracter, Funcionário ST1
		dIniData, Data, Data Inicio programação O.S.
		dFimData, Data, Data Fim programação O.S.
/*/
//-------------------------------------------------------------------
Static Function fValBloAus(cCodeFunc, dIniData, dFimData)

	Local cAliasSTK := GetNextAlias()

	If lIntegGPE

		dbSelectArea("SR8")
		dbSetOrder(1)
		dbSeek( xFilial("SR8") + cCodeFunc + DTOS(dIniData), .T.)
		While !EoF() .And. SR8->R8_FILIAL == xFilial("SR8") .And. cCodeFunc == SR8->R8_MAT

			IF SR8->R8_DATAINI > dFimData .Or. ( SR8->R8_DATAFIM < dIniData .And. !Empty(SR8->R8_DATAFIM) )
				dbSelectArea("SR8")
				SR8->(dbSkip())
				Loop
			EndIf

			dIniSTK := Max( SR8->R8_DATAINI, dIniData )
			dFimSTK := Min( SR8->R8_DATAFIM, dFimData )

			dDtAtu := dIniSTK
			While dDtAtu <= dFimSTK
				nSem     := IIf( DOW(dDtAtu) == 1, 7, DOW(dDtAtu)-1)
				cHoraIni := "00:00"
				cHoraFim := "24:00"
				cDiasSem := NGCALCHCAR(dDtAtu,cHoraIni,dDtAtu,cHoraFim)
				nDiasSem := HTOM(cDiasSem)
				If nDiasSem > HtoM(aCalends[nPosC,nSem,3])
					nDiasSem := HtoM(aCalends[nPosC,nSem,3])
				EndIf
				aDispon[nEspec,4] += nDiasSem
				aDispFunc[nLenFunc,4] += nDiasSem

				dDtAtu := dDtAtu + 1
			EndDo
			dbSelectArea("SR8")
			SR8->(dbSkip())
		End
	EndIf

	BeginSQL Alias cAliasSTK
		column	TK_DATAINI as Date
		column	TK_DATAFIM as Date
		SELECT  TK_DATAINI, TK_DATAFIM,	TK_HORAINI,	TK_HORAFIM
			FROM %table:STK% 
		WHERE	TK_FILIAL  = %xFilial:STK%  AND
				TK_ORDEM   = %exp:Space(Len(STK->TK_ORDEM))% AND
				TK_PLANO   = %exp:Space(Len(STK->TK_PLANO))% AND
				TK_TAREFA  = %exp:Space(Len(STK->TK_TAREFA))% AND
				TK_CODFUNC = %exp:cCodeFunc% AND
				TK_DATAINI BETWEEN %exp:dIniData% AND %exp:dFimData% AND
		    	D_E_L_E_T_ <> %exp:'*'%
	EndSQL

	While (cAliasSTK)->( !EoF() )

		dIniSTK := Max((cAliasSTK)->TK_DATAINI, dIniData)
		dFimSTK := Min((cAliasSTK)->TK_DATAFIM, dFimData)

		dDtAtu := dIniSTK
		While dDtAtu <= dFimSTK
			nSem	 := IIf( DOW(dDtAtu) == 1, 7, DOW(dDtAtu)-1)
			cHoraIni := IIf( dDtAtu == (cAliasSTK)->TK_DATAINI, (cAliasSTK)->TK_HORAINI, "00:00" )
			cHoraFim := IIf( dDtAtu == (cAliasSTK)->TK_DATAFIM, (cAliasSTK)->TK_HORAFIM, "24:00" )
			cDiasSem := NGCALCHCAR(dDtAtu,cHoraIni,dDtAtu,cHoraFim)
			nDiasSem := HTOM(cDiasSem)
			If nDiasSem > HtoM(aCalends[nPosC,nSem,3])
				nDiasSem := HtoM(aCalends[nPosC,nSem,3])
			EndIf
			aDispon[nEspec,4] += nDiasSem
			aDispFunc[nLenFunc,4] += nDiasSem

			dDtAtu := dDtAtu + 1
		End

		dbSelectArea(cAliasSTK)
		(cAliasSTK)->( dbSkip() )
	EndDo

	(cAliasSTK)->( dbCloseArea() )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT990QUAT
Valida o campo TL_QUANTIDADE

@sample
MNT990QUAT()

@author Tainã Alberto Cardoso
@since 26/02/2018
@version 1.0
/*/
//---------------------------------------------------------------------
Function MNT990QUAT()

Local lRet := .F.

If NAOVAZIO(M->TL_QUANTID) .And. POSITIVO() ;
	.And. NG420QUANT(oGet:aCOLS[oGet:nAt,nTIPHEA],M->TL_QUANTID,oGet:Acols,oGet:nAt);
	.And. NGVQLIMITP() .And. NGQUANTCHK() .And. NGCALDTHO() .And. MNT990DHF()
	lRet := .T.
EndIf

Return lRet

//------------------------------------------------------------------------------------------
/*/{Proteus.doc} fInsertSTL
Insere os registros na tabela temporária de insumos.
@type function

@author Alexandre Santos
@since  06/08/2019

@sample fInsertSTL( 'STL->' )

@param  cKey, Caracter, Chave única do registo de insumos.
@return
/*/
//------------------------------------------------------------------------------------------
Static Function fInsertSTL( cKey )

	Local aStruct := (cTempStl)->( dbStruct() )
	Local aArea   := GetArea()
	Local nIndex  := 0

	dbSelectArea( 'STL' )
	dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
	dbSeek( cKey )

	RecLock( cTempStl, .T. )

		For nIndex := 1 to Len( aStruct )

			If aStruct[nIndex,1] == 'STATUS'
				(cTempStl)->STATUS := 0
			ElseIf aStruct[nIndex,1] == 'RECNO'
				(cTempStl)->RECNO := STL->( RecNo() )
			Else
				&( '(cTempStl)->' + aStruct[nIndex,1] ) := &( 'STL->' + aStruct[nIndex,1] )
			EndIf

		Next

	(cTempStl)->( MsUnLock() )

	RestArea( aArea )

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fGetCols
Monta aCols e aHeader conforme os campos solicitados.
@type function

@author Alexandre Santos
@since 03/09/2019

@sample fGetCols( '000001', '000000', .T. )

@param  cOrder   , Caracter, Ordem de Serviço.
@param  cPlan    , Caracter, Plano de Manutenção.
@param  [lBackup], Lógico  , Define se deve carregar um aCols de backup conforme
o que se encontra já salvo em base.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fGetCols( cOrder, cPlan, lBackup )

	Local cWhere    := ''
	Local nInd      := 0
	Local lUSATARG  := IIf( FindFunction( 'NGUSATARPAD' ), NGUSATARPAD(), .F. )
	Local aNoField  := { 'TL_ORDEM'  , 'TL_PLANO'  , 'TL_SEQUENC', 'TL_SEQRELA', 'TL_NOMSEQ' , 'TL_NOMTREG', 'TL_CUSTO'  ,;
	              		 'TL_CUSTO2' , 'TL_CUSTO3' , 'TL_CUSTO4' , 'TL_CUSTO5' , 'TL_CUSENT1', 'TL_CUSENT2', 'TL_CUSENT3',;
				  		 'TL_CUSENT4', 'TL_CUSENT5', 'TL_OCORREN', 'TL_REPFIM' , 'TL_NUMSEQ' , 'TL_CODOBS' , 'TL_PCTHREX',;
				  		 'TL_CONTROL', 'TL_ETAPA'  , 'TL_GARANTI', 'TL_NOMETAP', 'TL_NOMLOCA', 'TL_NUMLOTE', 'TL_LOTECTL',;
				  		 'TL_LOCALIZ', 'TL_DTVALID', 'TL_NUMSERI', 'TL_POSCONT', 'TL_POSCON2', 'TL_PERMDOE' }

	Default lBackup := .F.

	cWhere := 'TL_FILIAL = ' + ValToSQL( xFilial( 'STL' ) ) + ' AND TL_ORDEM = ' + ValToSQL( cOrder ) + ' AND '
	cWhere += 'TL_PLANO = ' + ValToSQL( cPlan ) + " AND TL_SEQRELA = '0' AND D_E_L_E_T_ <> '*'"

	If !lUSATARG .And. Val( cPlan ) == 0

		aAdd( aNoField, 'TL_TAREFA' )
		aAdd( aNoField, 'TL_NOMTAR' )

	EndIf

	dbSelectArea( 'STL' )
	dbSetOrder( 3 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_SEQRELA + TL_TAREFA + TL_TIPOREG + TL_CODIGO
	aHeaIns := CabecGetD( 'STL', aNoField, 2 )

	ADHeadRec( 'STL', aHeaIns )

	nTipHea := GDFieldPos( 'TL_TIPOREG', aHeaIns )
	nUsaCal := GDFieldPos( 'TL_USACALE', aHeaIns )
	nCodIns := GDFieldPos( 'TL_CODIGO' , aHeaIns )
	nDataFn := GDFieldPos( 'TL_DTFIM'  , aHeaIns )
	nHoraFn := GDFieldPos( 'TL_HOFIM'  , aHeaIns )
	nDataIn := GDFieldPos( 'TL_DTINICI', aHeaIns )
	nHoraIn := GDFieldPos( 'TL_HOINICI', aHeaIns )
	nQuanti := GDFieldPos( 'TL_QUANTID', aHeaIns )
	nSee    := GDFieldPos( 'TL_SEQTARE', aHeaIns )

	If nUsaCal > 0
		aHeaIns[nUsaCal,6]  := "Pertence('SN') .And. NGCHKCALEN(oGet:aCOLS[oGet:nAt,nCODINS],6,'ST1','T1_TURNO') .And. MNT420ACHO(oGet:Acols,oGet:nAt)"
	EndIf

	If nDataIn > 0  .And. nHoraIn > 0
		aHeaIns[nDataIn,6] := "NAOVAZIO() .And. NGDTAINSUIN(M->TL_DTINICI) .And. NGVDTIN420( (c990TRB3)->(DTMPINI) ) .And. MNT990DTPR() .And. VALDTFIM()"
		aHeaIns[nHoraIn,6] := "NG420HOINI(oGet:aCOLS,oGet:nAt) .And. VALDTFIM() .And. NGCALDTHO()"
	EndIf

	If nDataFn > 0  .And. nHoraFn > 0
		aHeaIns[nDataFn,6] := " NGCALDTHO()"
		aHeaIns[nHoraFn,6] := "NGVALHORA(M->TL_HOFIM) .AND. NGSTLHORFI() .AND. NGCALDTHO()"
	EndIf

	If nTipHea > 0
		aHeaIns[nTipHea,6] := "PERTENCE('MPFTE') .And. NGVALTERC(M->TL_TIPOREG) .And. NGRETNOREG(M->TL_TIPOREG) .And. MNT420ACHO(oGet:Acols, oGet:nAt) .And. NGCLEARSTL() .And. NG420VLTR(oGet:Acols, oGet:nAt)"
	EndIf

	aHeaIns[nQuanti,6]  := 'MNT990QUAT()'

	aGetIns := MNTA990Get( oTmpSTL:GetRealName(), cWhere, aHeaIns )

	If lBackup

		aGetInSal := {}
		aHeaInSal := {}
		cSeekKey   := xFilial( 'STL' ) + cOrder + cPlan + '0  '
		bSeekWhile := { || STL->TL_FILIAL + STL->TL_ORDEM + STL->TL_PLANO + STL->TL_SEQRELA }

		FillGetDados( 4, 'STL', 3, cSeekKey, bSeekWhile, , aNoField, , , , , , aHeaInSal, aGetInSal )

	EndIf

	For nInd := 1 To Len( aGETINS )

		nField := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_TIPOREG' } )
		M->TL_TIPOREG := IIf( nField > 0, aGETINS[nInd,nField], ' ' )

		nField := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_CODIGO' } )
		M->TL_CODIGO  := IIf( nField > 0, aGETINS[nInd,nField], Space( 15 ) )

		nField := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_NOMCODI' } )
		If nField > 0
			aGetIns[nInd,nField] := VirtInsumo( M->TL_TIPOREG, M->TL_CODIGO )
		EndIf

		nField := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_TAREFA' } )
		M->TL_TAREFA  := IIf( nField > 0, aGETINS[nInd,nField], Space( 6 ) )

		nField := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_NOMTAR' } )
		If nField > 0
			aGetIns[nInd,nField] := Posicione( 'TT9', 1, xFilial( 'TT9' ) + M->TL_TAREFA, 'TT9_DESCRI' )
		EndIf

		If nSee > 0

			If nInd == 1

				cPxSeq := aGETINS[nInd,nSee]

			Else

				If aGetIns[nInd,nSee] > cPxSeq

					cPxSeq := aGetIns[nInd,nSee]

				EndIf

			EndIf

		EndIf

	Next nInd

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} MNTA990Get
Monta aCols conforme os campos solicitados via parâmentro, permitindo utilizar
como alias uma tabela temporária.
@type function

@author Alexandre Santos
@since 03/09/2019

@sample MNTA990Get( 'STL990', "TL_ORDEM = '000001'", { 'TL_ORDEM', 'TL_PLANO' } )

@param  cAlias , Caracter, Tabela no formato SQL que será consultada para montage mdo aCols.
@param  cWhere , Caracter, Condição de filtro para a consulta no formato SQL.
@param  aFields, Data    , Campos que serão retornados no aCols.
@return Array , Lista com registros conforme filtro na tabela definida por parâmetro.
/*/
//------------------------------------------------------------------------------------
Function MNTA990Get( cAlias, cWhere, aFields, cFields )

	Local cAliasTmp := GetNextAlias()
	Local cAliasBg  := '%' + cAlias + '%'
	Local cWhereBg  := '%' + cWhere + '%'
	Local cOrderBy  := '% %'
	Local cField    := ''
	Local aReturn   := {}
	Local aArea     := GetArea()
	Local nIndex    := 0
	Local nPos      := 1

	cFieldQry := IIf( Empty( cFields ), cFieldQry, cFields )

	cOrderBy := '% TL_FILIAL, TL_ORDEM, TL_PLANO, TL_SEQRELA, TL_TAREFA, TL_TIPOREG, TL_CODIGO %'

	BeginSQL Alias cAliasTmp

		SELECT 
			%exp:cFieldQry%
		FROM 
			%exp:cAliasBg%
		WHERE 
			%exp:cWhereBg%
		ORDER BY 
			%exp:cOrderBy%

	EndSQL

	Do While (cAliasTmp)->( !EoF() )

		STL->( msGoTo( (cAliasTmp)->RECNO ) )

		aAdd( aReturn, {} )

		For nIndex := 1 To ( Len( aFields ) - 2 )

			If Posicione( 'SX3', 2, aFields[nIndex,2], 'X3_CONTEXT' ) == 'V'

				aAdd( aReturn[nPos], CriaVar( AllTrim( aFields[nIndex,2] ) ) )

			ElseIf aFields[nIndex,8] == 'D'

				cField := '(cAliasTmp)->' + aFields[nIndex,2]
				aAdd( aReturn[nPos], SToD( &cField. ) )

			ElseIf aFields[nIndex,2] == 'TL_OBSERVA'

				aAdd( aReturn[nPos], (cAliasTmp)->TL_OBSERVA )

			Else

				cField := '(cAliasTmp)->' + aFields[nIndex,2]
				aAdd( aReturn[nPos], &cField. )

			EndIf

		Next nIndex

		aAdd( aReturn[nPos], cAliasTmp )
		aAdd( aReturn[nPos], (cAliasTmp)->RECNO )
		aAdd( aReturn[nPos], (cAliasTmp)->STATUS == 3 )

		nPos++

		(cAliasTmp)->( dbSkip() )

	EndDo

	(cAliasTmp)->( dbCloseArea() )

	RestArea( aArea )

Return aReturn

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fVldAltDtI
Realiza as validações referente a alteração de data do insumo.
@type function

@author Alexandre Santos
@since 01/08/2019

@sample fVldAltDtI( '000100', '000000', 01/08/2019 )

@param  cOrder, Caracter, Ordem de Serviço.
@param  cPlan , Caracter, Plano de Manutenção.
@param  dNewDt, Data    , Nova data de inicio informada para o insumo.
@param  aInfs , Array   , 	[1] - Código do insumo
							[2] - Tarefa do insumo
							[3] - Tipo do registro
@param [aRet], array, armazena mensagens de validação
@return Array , Lista com registros ao quais foram detectados inconsistências no processo de validação.
				[1] - Tipo do insumo.
				[2] - Código do insumo.
				[3] - Código tarefa genérica.
				[4] - Ordem de Serviço.
				[5] - Plano de manutenção.
				[6] - Mensagem de inconsitência.
/*/
//------------------------------------------------------------------------------------
Static Function fVldAltDtI( cOrder, cPlan, dNewDt, aInfs, lVdlLinha, aRet )

	Local cAliasTL    := GetNextAlias()
	Local cTable      := '%' + oTmpSTL:GetRealName()   + '%'
	Local cMessage    := ''
	Local cWhere      := '%%'
	Local aNewDt      := {}
	Local aBlq        := {}

	Default lVdlLinha := .F.
	Default aRet      := {}

	If !Empty( aInfs )

		cWhere := "%AND TL_CODIGO  = " + ValToSQL( aInfs[1] )
		cWhere += " AND TL_TAREFA  = " + ValToSQL( aInfs[2] )
		cWhere += " AND TL_TIPOREG = " + ValToSQL( aInfs[3] )

		If lVdlLinha

			cWhere += " UNION "
			cWhere += 	" SELECT "
			cWhere +=		ValToSQL( aInfs[1] ) + ","
			cWhere +=		ValToSQL( aInfs[4] ) + ","
			cWhere +=		ValToSQL( aInfs[5] ) + ","
			cWhere +=		ValToSQL( aInfs[6] ) + ","
			cWhere +=		ValToSQL( aInfs[3] ) + ","
			cWhere +=		ValToSQL( aInfs[2] ) + ","
			cWhere +=		ValToSQL( cOrder )   + ","
			cWhere +=		ValToSQL( cPlan )    + ","
			cWhere +=		ValToSQL( aInfs[7] )
			cWhere += 	" FROM " + oTmpSTL:GetRealName()

		EndIf

		cWhere += "%"

	EndIf

	BeginSQL Alias cAliasTL

		SELECT
			TL_CODIGO ,
			TL_HOINICI,
			TL_QUANTID,
			TL_USACALE,
			TL_TIPOREG,
			TL_TAREFA ,
			TL_ORDEM  ,
			TL_PLANO  ,
			TL_QUANREC
		FROM
			%exp:cTable%
		WHERE
			TL_ORDEM  = %exp:cOrder%  AND
			TL_PLANO  = %exp:cPlan%   AND
			TL_FILIAL = %xFilial:STL% AND
			STATUS <> 3  // Status diferente de 3 - excluido
			%exp:cWhere%

	EndSQL

	Do While (cAliasTL)->( !EoF() )

		cMessage := ''

		// Define data e hora para inicio e fim do insumo
		aNewDt := M420RETDAT( (cAliasTL)->TL_CODIGO, dNewDt, (cAliasTL)->TL_HOINICI, (cAliasTL)->TL_QUANTID,;
			(cAliasTL)->TL_USACALE )

		// Insumos do tipo mão de obra
		If (cAliasTL)->TL_TIPOREG == 'M'

			// Verifica afastamentos(SR8) da mão de obra
			If !NGFRHAFAST( (cAliasTL)->TL_CODIGO, aNewDt[1], aNewDt[3], .T., .F. )

				/*
				O funcionário possui registro de afastamento dentro do periodo apontado: XX/XX/XXXX às XX:XX até
				XX/XX/XXXX às XX:XX.
				*/
				cMessage := STR0329 + dToC( aNewDt[1] ) + STR0330 + aNewDt[2] + STR0331 + dToC( aNewDt[3] ) + STR0330 +;
				            aNewDt[4] + '.'

			// Verifica bloqueios(STK) da mão de obra
			Else

				aBlq := aClone( fVldBlqMOE( (cAliasTL)->TL_CODIGO, (cAliasTL)->TL_TIPOREG, aNewDt, (cAliasTL)->TL_ORDEM +;
					(cAliasTL)->TL_PLANO + (cAliasTL)->TL_TAREFA + (cAliasTL)->TL_TIPOREG + (cAliasTL)->TL_CODIGO ) )

				If aBlq[1]

					aBlq := MntVldBlqM( (cAliasTL)->TL_ORDEM, (cAliasTL)->TL_PLANO, { (cAliasTL)->TL_TAREFA, (cAliasTL)->TL_CODIGO,;
						(cAliasTL)->TL_USACALE, (cAliasTL)->TL_QUANTID, dNewDt, (cAliasTL)->TL_HOINICI }, , .F. )

				EndIf

				If !aBlq[1]
					cMessage := aBlq[2]
				EndIf

			EndIf

		// Insumos do tipo especialidade
		ElseIf (cAliasTL)->TL_TIPOREG == 'E'

			aBlq := aClone( fVldBlqMOE( (cAliasTL)->TL_CODIGO, (cAliasTL)->TL_TIPOREG, aNewDt, (cAliasTL)->TL_ORDEM +;
				(cAliasTL)->TL_PLANO + (cAliasTL)->TL_TAREFA + (cAliasTL)->TL_TIPOREG + (cAliasTL)->TL_CODIGO ) )

			If aBlq[1]

				// Verifica bloqueios(TTY) da especialidade
				aBlq := MntVldBlqE( (cAliasTL)->TL_ORDEM, (cAliasTL)->TL_PLANO, { (cAliasTL)->TL_CODIGO, (cAliasTL)->TL_QUANTID,;
				(cAliasTL)->TL_QUANREC, dNewDt, (cAliasTL)->TL_HOINICI, , .F. } )

			EndIf

			If !aBlq[1]
				cMessage := aBlq[2]
			EndIf

		EndIf

		// Caso encontre alguma inconsitência guarda os registros para apresentação da mensagem ao final
		If !Empty( cMessage )

			aAdd( aRet, { (cAliasTL)->TL_TIPOREG, (cAliasTL)->TL_CODIGO, (cAliasTL)->TL_TAREFA, (cAliasTL)->TL_ORDEM,;
			              (cAliasTL)->TL_PLANO  , cMessage } )

		EndIf

		(cAliasTL)->( dbSkip() )

	EndDo

	(cAliasTL)->( dbCloseArea() )

Return aRet

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fKillBloq
Deleta registros relacionado aos insumos vinculados a data original destes.
@type function

@author Alexandre Santos
@since 01/08/2019

@sample fKillBloq( '000100', '000000' )

@param  cOrder, Caracter, Ordem de Serviço.
@param  cPlan , Caracter, Plano de Manutenção.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fKillBloq( cOrder, cPlan )

	Local aArea  := GetArea()
	Local nTamTK := TamSX3( 'TK_CODFUNC' )[1]

	dbSelectArea( 'STL' )
	dbSetOrder( 1 )
	If dbSeek( xFilial( 'STL' ) + cOrder+ cPlan )

		Do While STL->( !EoF() ) .And. STL->TL_FILIAL == xFilial( 'STL' ) .And.	STL->TL_ORDEM == cOrder .And.;
			     STL->TL_PLANO == cPlan

			If STL->TL_TIPOREG == 'M'

				// Bloqueio de mão de obra
				dbSelectArea( 'STK' )
				dbSetOrder( 1 ) // TK_FILIAL + TK_ORDEM + TK_PLANO + TK_TAREFA + TK_CODFUNC + TK_DATAINI + TK_HORAINI
				If dbSeek( xFilial( 'STK' ) + STL->TL_ORDEM + STL->TL_PLANO + STL->TL_TAREFA + PadR( STL->TL_CODIGO,;
				 nTamTK ) )

					RecLock( 'STK', .F. )
						dbDelete()
					STK->( MsUnLock() )

				EndIf

			ElseIf STL->TL_TIPOREG == 'E'

				// Bloqueio de especialidade
				dbSelectArea( 'TTY' )
				dbSetOrder( 1 ) // TTY_FILIAL + TTY_ORDEM + TTY_PLANO + TTY_TAREFA + TTY_CODESP + TTY_DTINI + TTY_HRINI
				If dbSeek( xFilial( 'TTY' ) + STL->TL_ORDEM + STL->TL_PLANO + STL->TL_TAREFA + STL->TL_CODIGO )

					RecLock( 'TTY', .F. )
						dbDelete()
					TTY->( MsUnLock() )

				EndIf

			EndIf

			// Problemas identificados nas O.S.
			dbSelectArea( 'STA' )
			dbSetOrder( 1 ) // TA_FILIAL + TA_ORDEM + TA_PLANO + TA_TAREFA + TA_TIPOREG + TA_CODIGO + TA_DESCRIC
			If dbSeek( xFilial( 'STA' ) + STL->TL_ORDEM + STL->TL_PLANO + STL->TL_TAREFA + STL->TL_TIPOREG +;
					STL->TL_CODIGO )

				Do While STA->( !EoF() ) .And. ( xFilial( 'STA' ) + STL->TL_ORDEM + STL->TL_PLANO + STL->TL_TAREFA +;
					STL->TL_TIPOREG + STL->TL_CODIGO == STA->TA_FILIAL + STA->TA_ORDEM + STA->TA_PLANO +;
					STA->TA_TAREFA + STA->TA_TIPOREG + STA->TA_CODIGO )

					RecLock( 'STA', .F. )
						dbDelete()
					STA->( MsUnLock() )

					STA->( dbSkip() )

				EndDo

			EndIf

			STL->( dbSkip() )

		EndDo

	EndIf

	RestArea( aArea )

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fShowMsg
Apresenta mensagem no formato MsgYesNO() em lote de possíveis inconsitências nos insumos.
@type function

@author Alexandre Santos
@since 01/08/2019

@sample fShowMsg( { 'M', 'TRUMP', '0', '000100', '000000', 'Error 404' } )

@param  aItensMsg, Array, Itens que serão apresentado na mensagem.
							[1] - Tipo de Insumo
							[2] - Código do Insumo
							[3] - Código da Tarefa.
							[4] - Ordem de Serviço.
							[5] - Plano de Manutenção.
							[6] - Mensagem de inconsitência.
@return Lógico, Define se o processo poderá seguir ou não.
/*/
//------------------------------------------------------------------------------------
Static Function fShowMsg( aItensMsg )

	Local cMsg     := ''
	Local cPlan    := ''
	Local cOrder   := ''
	Local cDescIns := ''
	Local cDescTar := ''
	Local cTipReg  := ''
	Local nIndex   := 0
	Local lRet     := .T.
	Local lFirst   := .T.
	Local oDlgMsg
	Local oMemo
	Local oBtnYs
	Local oBtnNo
	Local oPnl

	// Realiza ordenação por O.S.
	aSort( aItensMsg, , , { |x,y| x[4] < y[4] } )

	DEFINE MSDIALOG oDlgMsg TITLE STR0247 From 3, 0 To 339, 550 PIXEL // Atenção

		oPnl := TPanel():New( ,,, oDlgMsg,,,,,,,, .F., .F. )
			oPnl:Align := CONTROL_ALIGN_ALLCLIENT

			oMemo  := tMultiGet():New( 5, 5, { |u| IIf( Pcount() > 0, cMsg := u, cMsg ) }, oPnl, 265, 150, , , , , , .T.,;
									, , , , , .T. )
			oMemo:bRClicked := { || AllwaysTrue() }
			oMemo:lReadOnly := .T.

			// Foram identificadas algumas inconsitências no reporte de insumos. Deseja prosseguir assim mesmo?
			oMemo:AppendText( STR0342 + CRLF + CRLF )
			oMemo:AppendText( '-------------------------------------------------------' + CRLF + CRLF )

			For nIndex := 1 to Len( aItensMsg )

				Do Case

					Case aItensMsg[nIndex,1] == 'P' .Or.  aItensMsg[nIndex,1] == 'F'
						Loop

					Case aItensMsg[nIndex,1] == 'M'
						cDescIns := Posicione( 'ST1', 1, xFilial( 'ST1' ) + aItensMsg[nIndex,2], 'T1_NOME' )
						cTipReg  := STR0340 //Mão-de-Obra

					Case aItensMsg[nIndex,1] == 'E'
						cDescIns := Posicione( 'ST0', 1, xFilial( 'SB0' ) + aItensMsg[nIndex,2], 'T0_NOME' )
						cTipReg  := STR0341 // Especialidade

				EndCase

				cDescTar := Posicione( 'TT9', 1, xFilial( 'TT9' ) + aItensMsg[nIndex,3], 'TT9_DESCRI' )

				If cPlan != aItensMsg[nIndex,5] .Or. cOrder != aItensMsg[nIndex,4]

					If !lFirst
						oMemo:AppendText( '-------------------------------------------------------' + CRLF + CRLF )
					EndIf

					oMemo:AppendText( STR0332 + aItensMsg[nIndex,4] + CRLF )        // Ordem de Serviço
					oMemo:AppendText( STR0333 + aItensMsg[nIndex,5] + CRLF + CRLF ) // Plano Manutenção

					lFirst := .F.

				EndIf

				oMemo:AppendText( STR0334 + Trim( aItensMsg[nIndex,3] ) + ' - ' + cDescTar + CRLF ) // Tarefa:
				oMemo:AppendText( STR0335 + cTipReg                     + CRLF )                    // Tipo Insumo
				oMemo:AppendText( STR0336 + Trim( aItensMsg[nIndex,2] ) + ' - ' + cDescIns + CRLF ) // Código:
				oMemo:AppendText( STR0337 + Trim( aItensMsg[nIndex,6] ) + CRLF + CRLF )             // Inconsistência

				cOrder := aItensMsg[nIndex,4]
				cPlan  := aItensMsg[nIndex,5]

			Next nIndex

			oMemo:AppendText( '-------------------------------------------------------' + CRLF + CRLF )

			oMemo:GoTop()

			// Não
			oBtnNo := TButton():New( 156, 205, STR0339, oPnl, { || lRet := .F., oDlgMsg:End() }, 30, 11, , , .F., .T., .F., ,;
			.F., , ,.F. )

			// Sim
			oBtnYs := TButton():New( 156, 240, STR0338, oPnl, { || lRet := .T., oDlgMsg:End() }, 30, 11, , , .F., .T., .F., ,;
			.F., , , .F. )

	ACTIVATE MSDIALOG oDlgMsg CENTER

Return lRet

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fSave
Realiza a gravação dos insumos na tabela temporária de insumos.
@type function

@author Alexandre Santos
@since 06/09/2019

@sample fSave( aColsOld, aCols )

@param  aColsOld, Array, Lista de insumos antes das alterações sofridas.
@param  aColsAtu, Array, Lista de insumos após alterações sofridas.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fSave( aColsOld, aColsAtu )

	Local nPosTar    := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_TAREFA'  } )
	Local nPosReg    := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_TIPOREG' } )
	Local nPosCod    := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_CODIGO'  } )
	Local nPosSqT    := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_SEQTARE' } )
	Local cTarGe     := ''
	Local cKey       := ''
	Local nIndex     := 0

	Default aColsOld := {}

	If !Empty( aColsOld )

		cTarGe := IIf( NGUSATARPAD() .Or. Val( M->TJ_PLANO ) > 0, aColsOld[nPosTar], PadR( '0', Len( STL->TL_TAREFA ) - 1 ) )
		cKey    := M->TJ_ORDEM + M->TJ_PLANO + cTarGe + aColsOld[nPosReg] + aColsOld[nPosCod] + '0  '

		// Caso o campo TL_SEQTARE esteja em uso, auto preenche ele.
		If nPosSqT > 0

			cKey   += aColsOld[nPosSqT]
			cPxSeq := IIf( aColsOld[nPosSqT] > cPxSeq, aColsOld[nPosSqT], cPxSeq )

		EndIf

	EndIf

	If aColsAtu[Len( aColsAtu )] // Deleção

		dbSelectArea( cTempStl )
		dbSetOrder( 2 )	// FILIAL + ORDEM + PLANO + TAREFA + TIPOREG + CODIGO + SEQRELA + SEQTARE
		If dbSeek( cKey )

			RecLock( cTempStl, .F. )
			(cTempStl)->STATUS := 3
			(cTempStl)->( MsUnLock() )

		EndIf

	Else

		If Empty( aColsOld ) // Inclusão

			RecLock( cTempStl, .T. )

				(cTempStl)->TL_FILIAL  := xFilial( 'STL' )
				(cTempStl)->TL_ORDEM   := M->TJ_ORDEM
				(cTempStl)->TL_PLANO   := M->TJ_PLANO
				(cTempStl)->TL_SEQRELA := '0  '
				(cTempStl)->TL_TAREFA  := cTarGe
				(cTempStl)->TL_SEQTARE := cPxSeq

				For nIndex := 1 to Len( aHeaIns )

					If aHeaIns[nIndex,2] == 'M'

						MsMM( '(cTempStl)->' + aStruct[nIndex,1], 80, , aColsAtu[nIndex], 1 )

					ElseIf aHeaIns[nIndex,10] != 'V'

						cField      := '(cTempStl)->' + aHeaIns[nIndex,2]
						&( cField ) := aColsAtu[nIndex]

					EndIf

				Next nIndex

				(cTempStl)->STATUS := 1

			(cTempStl)->( MsUnlock() )

		Else // Alteração

			dbSelectArea( cTempStl )
			dbSetOrder( 2 )	// FILIAL + ORDEM + PLANO + TAREFA + TIPOREG + CODIGO + SEQRELA + SEQTARE
			If dbSeek( cKey )

				RecLock( cTempStl, .F. )

					For nIndex := 1 to Len( aHeaIns )

						If aHeaIns[nIndex,2] == 'M'

							MsMM( '(cTempStl)->' + aStruct[nIndex,1], 80, , aColsAtu[nIndex], 1 )

						ElseIf aHeaIns[nIndex,10] != 'V'

							cField      := '(cTempStl)->' + aHeaIns[nIndex,2]
							&( cField ) := aColsAtu[nIndex]

						EndIf

					Next nIndex

					(cTempStl)->STATUS := IIf( (cTempStl)->STATUS != 1, 2, 1 )

				(cTempStl)->( MsUnlock() )

			EndIf

		EndIf

	EndIf

	fUpdList1( aColsOld, aColsAtu )

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fCheckIns
Realiza checagem nos insumos alterados, limpando os campos de SA/SC para que sejam
regerados pela integração.
@type function

@author Alexandre Santos
@since 06/09/2019

@sample fCheckIns( aHeader, aCols )

@param  aHeadIns, Array   , Cabeçalho de insumos.
@param  aColsAtu, Array   , Lista de insumos após alterações sofridas.
@param  nLine   , Númerico, Posição do insumo que será avaliado.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fCheckIns( aHeadIns, aColsAtu, nLine )

	Local nNumSC  := aScan( aHeadIns, { |x| AllTrim( Upper( x[2] ) ) == 'TL_NUMSC'  } )
	Local nItemSC := aScan( aHeadIns, { |x| AllTrim( Upper( x[2] ) ) == 'TL_ITEMSC' } )
	Local aAreaT  := (cTempStl)->( GetArea() )
	Local aArea   := GetArea()

	// Limpa campos S.C.
	If ( nNumSC > 0 .And. nItemSC > 0 ) .And. !Empty( aColsAtu[nLine,nNumSC] + aColsAtu[nLine,nItemSC] )

		dbSelectArea( 'SC1' )
		dbSetOrder( 1 )
		If dbSeek( xFilial( 'SC1' ) + aColsAtu[nLine,nNumSC] + aColsAtu[nLine,nItemSC] )

			If Empty( SC1->C1_COTACAO ) .And. Empty( SC1->C1_PEDIDO )

				aColsAtu[nLine,nNumSC]  := Space( Len( SC1->C1_NUM  ) )
				aColsAtu[nLine,nItemSC] := Space( Len( SC1->C1_ITEM ) )

				dbSelectArea( cTempStl )
				dbSetOrder( 3 )	// NUMSC + ITEMSC
				If dbSeek( SC1->C1_NUM + SC1->C1_ITEM )

					RecLock( cTempStl, .F. )
						(cTempStl)->TL_NUMSC  := Space( Len( SC1->C1_NUM  ) )
						(cTempStl)->TL_ITEMSC := Space( Len( SC1->C1_ITEM ) )
					(cTempStl)->( MsUnLock() )

				EndIf

			EndIf

		EndIf

	EndIf

	RestArea( aArea )
	RestArea( aAreaT )

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fUpdFolds
Atualiza folders e tabelas temporárias referentes aos insumos da O.S. posicionada.
@type function

@author Alexandre Santos
@since 12/09/2019

@sample fUpdFolds( 'cAlias', .F. )

@param  cTable    , Caracter, Tabela que será consultada.
@param  [lAll]    , Lógico  , Define se deve considerar todas as O.S. da programação.
@param  [lRefresh], Lógico  , Define se atualizar os objetos vísuais do browse.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fUpdFolds( cTable, lAll, lRefresh, lInput )

	Local aSldPrd    := {}
	Local cTableIns  := '%' + oTmpSTL:GetRealName() + '%'
	Local cTableOS   := '%' + cTable + '%'
	Local cWhere     := ''
	Local cAliasSTL  := GetNextAlias()
	Local cFilST1    := xFilial( 'ST1' )
	Local cFilST2    := xFilial( 'ST2' )
	Local cFilST0    := xFilial( 'ST0' )
	Local cCalendar  := ''
	Local cOrderBkp  := ''
	Local cPlanBkp   := ''
	Local nIndex     := 0

	Default lAll     := .F.
	Default lRefresh := .T.
	Default lInput   := .F.

	If lInput

		fDelTemp()

		cWhere := '%AND TINS.TL_ORDEM = ' + ValToSQL( M->TJ_ORDEM )
		cWhere += ' AND TINS.TL_PLANO = ' + ValToSQL( M->TJ_PLANO )

		// Filtro Especialidade
		If !Empty( aUpdInp[1] )

			cWhere += ' AND ( '
			cWhere += 'TINS.TL_TIPOREG = ' + ValToSQL( 'E' ) + ' AND '
			cWhere += 'TINS.TL_CODIGO IN ( '

			For nIndex := 1 To Len( aUpdInp[1] )
				
				If nIndex > 1
					cWhere += ', '
				EndIf

				cWhere += ValToSQL( aUpdInp[1,nIndex] )

			Next

			cWhere += ' ) )'

		EndIf

		// Filtro Mão de Obra
		If !Empty( aUpdInp[2] )

			// Se a váriavel de controle FOR estiver alterada, já houve inserção de filtro para algum insumo.
			If nIndex > 0
				cWhere += ' OR ( '
			Else
				cWhere += ' AND ( '
			EndIf

			cWhere += 'TINS.TL_TIPOREG = ' + ValToSQL( 'M' ) + ' AND '
			cWhere += 'TINS.TL_CODIGO IN ( '

			For nIndex := 1 To Len( aUpdInp[2] )
				
				If nIndex > 1
					cWhere += ', '
				EndIf

				cWhere += ValToSQL( aUpdInp[2,nIndex] )

			Next

			cWhere += ' ) )'

		EndIf

		// Filtro Produto
		If !Empty( aUpdInp[3] )

			// Se a váriavel de controle FOR estiver alterada, já houve inserção de filtro para algum insumo.
			If nIndex > 0
				cWhere += ' OR ( '
			Else
				cWhere += ' AND ( '
			EndIf

			cWhere += 'TINS.TL_TIPOREG = ' + ValToSQL( 'P' ) + ' AND '
			cWhere += 'TINS.TL_CODIGO IN ( '

			For nIndex := 1 To Len( aUpdInp[3] )
				
				If nIndex > 1
					cWhere += ', '
				EndIf

				cWhere += ValToSQL( aUpdInp[3,nIndex] )

			Next

			cWhere += ' ) )'

		EndIf

		// Filtro Ferramenta
		If !Empty( aUpdInp[4] )
			
			// Se a váriavel de controle FOR estiver alterada, já houve inserção de filtro para algum insumo.
			If nIndex > 0
				cWhere += ' OR ( '
			Else
				cWhere += ' AND ( '
			EndIf

			cWhere += 'TINS.TL_TIPOREG = ' + ValToSQL( 'F' ) + ' AND '
			cWhere += 'TINS.TL_CODIGO IN ( '

			For nIndex := 1 To Len( aUpdInp[4] )
				
				If nIndex > 1
					cWhere += ', '
				EndIf

				cWhere += ValToSQL( aUpdInp[4,nIndex] )

			Next

			cWhere += ' ) )'

		EndIf

		cWhere += '%'

	Else

		// Produtos
		dbSelectArea( c990TRBB1 )
		Zap

		aList3 := {}
		aList2 := {}
		aList4 := {}
		aList5 := {}

		dbSelectArea( c990TRBE )
		Zap
		dbSelectArea( c990TRBM )
		Zap
		dbSelectArea( c990TRBF )
		Zap

		cWhere := '%AND TINS.TL_ORDEM IS NOT NULL%'
	
	EndIf

	If lAll

		/*----------------------------------------------------------------------+
		| Atualiza disponibilidade de funcionários e especialidade considerando |
		| todo o periodo de programação      .                                  |
		+----------------------------------------------------------------------*/
		fDispoST1( .T., .F., IIf( dTT1_DTPROG < dDataBase, dDataBase, dTT1_DTPROG ), dTT1_DTFIM )
	
	Else

		/*----------------------------------------------------------------------+
		| Atualiza disponibilidade de funcionários e especialidade considerando |
		| o dia selecionado no calenário.                                       |
		+----------------------------------------------------------------------*/
		fDispoST1( .T., .F., _dDiaAtu, _dDiaAtu )

	EndIf
	
	BeginSQL Alias cAliasSTL

		SELECT
			TINS.TL_ORDEM  ,
			TINS.TL_PLANO  ,
			TINS.TL_CODIGO ,
			TINS.TL_USACALE,
			TINS.TL_DTINICI,
			TINS.TL_HOINICI,
			TINS.TL_DTFIM  ,
			TINS.TL_HOFIM  ,
			TINS.TL_QUANREC,
			TINS.TL_QUANTID,
			TINS.TL_NUMSA  ,
			TINS.TL_NUMSC  ,
			TINS.TL_ITEMSA ,
			TINS.TL_TIPOREG,
			TINS.STATUS
		FROM
			%exp:cTableIns% TINS
		INNER JOIN
			%exp:cTableOS% TOS ON
				TOS.ORDEM = TINS.TL_ORDEM AND
				TOS.PLANO = TINS.TL_PLANO AND
				TOS.%NotDel%
		WHERE
			TINS.TL_FILIAL  = %xFilial:STL% AND
			TINS.TL_TIPOREG <> %exp:'T'%    AND
			TINS.TL_SEQRELA = '0' %exp:cWhere%

	EndSQL

	Do While (cAliasSTL)->( !EoF() )

		// Verifica se ouve mudou a O.S. posicionada e realiza atualização da listagem de insumos para a mesma.
		If ( !Empty( cOrderBkp ) .And. cOrderBkp != (cAliasSTL)->TL_ORDEM ) .Or. ( !Empty( cOrderBkp ) .And.;
			cPlanBkp != (cAliasSTL)->TL_PLANO )

			// Atualiza listas com insumos referentes as O.S.
			fUpdList( cOrderBkp, cPlanBkp )

		EndIf

		cOrderBkp := (cAliasSTL)->TL_ORDEM
		cPlanBkp  := (cAliasSTL)->TL_PLANO

		Do Case

			// Mão de obra / Especialidade
			Case (cAliasSTL)->TL_TIPOREG $ 'M/E'

				If (cAliasSTL)->TL_TIPOREG == 'M' .And. (cAliasSTL)->TL_USACALE == 'S'

					cCalendar := fGetCalen( (cAliasSTL)->TL_CODIGO, SToD( (cAliasSTL)->TL_DTINICI ),;
						SToD( (cAliasSTL)->TL_DTFIM ) )

				Else

					cCalendar := ''

				EndIf

				// Aciona a gravação para registros não deletados
				If (cAliasSTL)->STATUS != 3

					// Grava registros atualizados nas tabelas de mão de obra e especialidade
					fLoadModE( cAliasSTL, cCalendar, { cFilST0, cFilST1, cFilST2 }, lAll )

				EndIf

			// Produto
			Case (cAliasSTL)->TL_TIPOREG == 'P'

				// Aciona a gravação para registros não deletados e quando a data de previsão é a mesma do calendário ou considera todas as datas
				If (cAliasSTL)->STATUS != 3 .And. ( _dDiaAtu == SToD( (cAliasSTL)->TL_DTINICI ) .Or. lAll )

					// Grava registros atualizados na tabela de produto
					fLoadProd( cAliasSTL, @aSldPrd )

				EndIf

			// Ferramenta
			Case (cAliasSTL)->TL_TIPOREG == 'F'

				// Aciona a gravação para registros não deletados e quando a data do calendário está no periodo de previsão ou considera todas as datas
				If (cAliasSTL)->STATUS != 3 .And. ( ( _dDiaAtu >= SToD( (cAliasSTL)->TL_DTINICI ) .And. _dDiaAtu <=;
					SToD( (cAliasSTL)->TL_DTFIM ) ) .Or. lAll )

					// Grava registros atualizados na tabela de ferramentas
					fLoadTool( cAliasSTL, lAll )

				EndIf

		EndCase

		(cAliasSTL)->( dbSkip() )

	EndDo

	// Atualiza listas com insumos referentes a última O.S. retornada pela query
	If !Empty( cOrderBkp )

		fUpdList( cOrderBkp, cPlanBkp )

	EndIf

	(cAliasSTL)->( dbCloseArea() )

	If lRefresh

		// Atualiza objetos e folders dos insumos
		fRefresh()

	EndIf

	FWFreeArray( aSldPrd )

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fUpdList
Atualiza listas com especialidade, mão de obra, produto e ferramenta por O.S.
@type function

@author Alexandre Santos
@since 12/09/2019

@sample fUpdList( '000001', '000000' )

@param  cOrder, Caracter, Ordem de Serviço.
@param  cPlan , Caracter, Plano de Manutenção.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fUpdList( cOrder, cPlan )

	Local cAliasM   := GetNextAlias()
	Local cAliasE   := GetNextAlias()
	Local cAliasP   := GetNextAlias()
	Local cAliasF   := GetNextAlias()
	Local cTblM     := '%' + oARQT990M:GetRealName() + '%'
	Local cTblE     := '%' + oARQT990E:GetRealName() + '%'
	Local cTblP     := '%' + oARQT990B1:GetRealName() + '%'
	Local cTblF     := '%' + oARQT990F:GetRealName() + '%'
	Local nFound    := 0
	Local nPosBkp   := 0
	Local nMinAdd   := 0
	Local nMinAus   := 0
	Local lFirst    := .F.
	Local lMNTA990H := ExistBlock( 'MNTA990H' )

	// Especialidades

	BeginSQL Alias cAliasE

		SELECT
			CODIGO,
			DESCRI,
			QTDTEC,
			TECADD,
			DIAADD,
			TECAUS,
			DIAAUS,
			TEMPRO,
			TEMREA
		FROM
			%exp:cTblE%
		WHERE
			ORDEM = %exp:cOrder% AND
			PLANO = %exp:cPlan%  AND
			%NotDel%

	EndSQL

	Do While (cAliasE)->( !EoF() )

		nFound  := aScan( aList2    , { |x| PadR( x[2], 40 ) == PadR( (cAliasE)->DESCRI, 40 ) } )
		nPosBkp := aScan( aList2bkp , { |x| PadR( x[2], 40 ) == PadR( (cAliasE)->DESCRI, 40 ) } )

		/*
			Caso o registro não esteja no lista controlada pelo objeto e o insumo estaja contido no array de backup,
			passo o conteudo para a lista.
		*/
		If nFound == 0 .And. nPosBkp > 0

			aAdd( aList2 , aClone( aList2bkp[nPosBkp] ) )
			nFound := Len( aList2 )

		EndIf

		If nFound == 0

			nMinAdd := 0
			nMinAus := 0

			// Cálculo em minutos de técnicos adicionais
			If (cAliasE)->TECADD > 0 .And. (cAliasE)->DIAADD > 0

				// 8      = QUANTIDADE DE HORAS POR TÉCNICO.
				// 60     = MINUTOS POR HORA.
				// TECADD = QUANTIDADE DE TÉCNICOS ADICIONADOS.
				// DIAADD = DIAS COM TÉCNICOS ADICIONAIS.
				nMinAdd := 8 * 60 * (cAliasE)->TECADD * (cAliasE)->DIAADD

			EndIf

			// Cálculo em minutos de técnicos ausentes
			If (cAliasE)->TECAUS > 0 .And. (cAliasE)->DIAAUS > 0

				// 8      = QUANTIDADE DE HORAS POR TÉCNICO.
				// 60     = MINUTOS POR HORA.
				// TECAUS = QUANTIDADE DE TÉCNICOS AUSENTES.
				// DIAAUS = DIAS COM TÉCNICOS AUSENTES.
				nMinAus := 8 * 60 * (cAliasE)->TECAUS * (cAliasE)->DIAAUS

			EndIf

			// Recupera o maior valor entre 0 e o cálculo em minuos que será adicionado ao tempo disponivel da especialidade
			nMinAdd := Max( nMinAdd - nMinAus, 0 )

			aAdd( aList2, { fRetLegend( (cAliasE)->TEMPRO, MToH( nMinAdd ) ), Trim( (cAliasE)->DESCRI ),;
			 (cAliasE)->QTDTEC, (cAliasE)->TECADD, (cAliasE)->DIAADD, (cAliasE)->TECAUS, (cAliasE)->DIAAUS,;
			 (cAliasE)->TEMPRO, MtoH( nMinAdd ), 0, (cAliasE)->CODIGO } )

		Else

			lFirst := ( aList2[nFound,4] == 0 .And. aList2[nFound,5] == 0 .And. aList2[nFound,6] == 0 .And.;
			 aList2[nFound,7] == 0 )

			If lFirst

				aList2[nFound,4] := (cAliasE)->TECADD
				aList2[nFound,5] := (cAliasE)->DIAADD
				aList2[nFound,6] := (cAliasE)->TECAUS
				aList2[nFound,7] := (cAliasE)->DIAAUS

				nMinAdd := 0
				nMinAus := 0

				// Cálculo em minutos de técnicos adicionais
				If (cAliasE)->TECADD > 0 .And. (cAliasE)->DIAADD > 0

					// 8      = QUANTIDADE DE HORAS POR TÉCNICO.
					// 60     = MINUTOS POR HORA.
					// TECADD = QUANTIDADE DE TÉCNICOS ADICIONADOS.
					// DIAADD = DIAS COM TÉCNICOS ADICIONAIS.
					nMinAdd := 8 * 60 * (cAliasE)->TECADD * (cAliasE)->DIAADD

				EndIf

				// Cálculo em minutos de técnicos ausentes
				If (cAliasE)->TECAUS > 0 .And. (cAliasE)->DIAAUS > 0

					// 8      = QUANTIDADE DE HORAS POR TÉCNICO.
					// 60     = MINUTOS POR HORA.
					// TECAUS = QUANTIDADE DE TÉCNICOS AUSENTES.
					// DIAAUS = DIAS COM TÉCNICOS AUSENTES.
					nMinAus := 8 * 60 * (cAliasE)->TECAUS * (cAliasE)->DIAAUS

				EndIf

				// Recupera o maior valor entre 0 e o cálculo em minutos que será adicionado ao tempo disponivel da especialidade
				nMinAdd := Max( hToM( aList2[nFound,9] ) + ( nMinAdd - nMinAus ), 0 )

				aList2[nFound,9] := MToH( nMinAdd )

			EndIf

			aList2[nFound,8] := NGSOMAHCAR( aList2[nFound,8], (cAliasE)->TEMPRO )
			aList2[nFound,1] := fRetLegend( aList2[nFound,8], aList2[nFound,9] )

		EndIf

		(cAliasE)->( dbSkip() )

	EndDo

	(cAliasE)->( dbCloseArea() )

	// Produto
	BeginSQL Alias cAliasP

		SELECT
			ORDEM ,
			CODIGO,
			DESCRI,
			QTDNEC,
			QTDFIS,
			QTDEST,
			NUMSC ,
			DTPREV,
			PLANO ,
			NUMSA ,
			ITEMSA
		FROM
			%exp:cTblP%
		WHERE
			ORDEM = %exp:cOrder% AND
			PLANO = %exp:cPlan%  AND
			%NotDel%

	EndSQL

	If (cAliasP)->( !EoF() )

		If Len( aList3 ) == 1 .And.;
			Empty( aList3[1,1] )

			aList3 := {}
		
		EndIf
		
		While (cAliasP)->( !EoF() )

			aAdd( aList3, { (cAliasP)->ORDEM , (cAliasP)->CODIGO, (cAliasP)->DESCRI, (cAliasP)->QTDNEC, (cAliasP)->QTDFIS,;
						(cAliasP)->QTDEST, (cAliasP)->NUMSC , SToD( (cAliasP)->DTPREV ), (cAliasP)->PLANO, (cAliasP)->NUMSA,;
						(cAliasP)->ITEMSA } )

			If lMNTA990H

				aList3 := ExecBlock( 'MNTA990H', .F., .F., { aList3, Len( aList3 ) } )

			EndIf

			(cAliasP)->(dbSkip())

		End

	EndIf

	(cAliasP)->( dbCloseArea() )

	// Ferramenta
	BeginSQL Alias cAliasF

		SELECT
			ORDEM ,
			CODIGO,
			DESCRI,
			QUANTI
		FROM
			%exp:cTblF%
		WHERE
			ORDEM = %exp:cOrder% AND
			PLANO = %exp:cPlan%  AND
			%NotDel%

	EndSQL

	Do While (cAliasF)->( !EoF() )

		aAdd( aList4, { (cAliasF)->ORDEM, (cAliasF)->CODIGO, (cAliasF)->DESCRI, Transform( (cAliasF)->QUANTI, '@E 999,999.99' ) } )
		(cAliasF)->( dbSkip() )

	EndDo

	(cAliasF)->( dbCloseArea() )

	// Mão de obra

	BeginSQL Alias cAliasM

		SELECT
			CODIGO,
			TEMPRO,
			DESCRI,
			NOMESP,
			CODESP
		FROM
			%exp:cTblM%
		WHERE
			ORDEM = %exp:cOrder% AND
			PLANO = %exp:cPlan%  AND
			%NotDel%

	EndSQL

	Do While (cAliasM)->( !EoF() )

		nFound  := aScan( aList5    , { |x| PadR( x[2], 6 ) == PadR( (cAliasM)->CODIGO, 6 ) } )
		nPosBkp := aScan( aList5bkp , { |x| PadR( x[2], 6 ) == PadR( (cAliasM)->CODIGO, 6 ) } )

		/*
			Caso o registro não esteja no lista controlada pelo objeto e o insumo estaja contido no array de backup,
			passo o conteudo para a lista.
		*/
		If nFound == 0 .And. nPosBkp > 0
			aAdd( aList5 , aClone( aList5bkp[nPosBkp] ) )
			nFound := Len( aList5 )
		EndIf

		If nFound == 0

			aAdd( aList5, { fRetLegend( (cAliasM)->TEMPRO, '00:00' ), Trim( (cAliasM)->CODIGO ),;
			                Trim( (cAliasM)->DESCRI ), Trim( (cAliasM)->NOMESP ), (cAliasM)->TEMPRO, '00:00', 0,;
							Trim( (cAliasM)->CODESP ) } )

		Else

			aList5[nFound,5] := NGSOMAHCAR( aList5[nFound,5], (cAliasM)->TEMPRO )
			aList5[nFound,1] := fRetLegend( aList5[nFound,5], aList5[nFound,6] )

		EndIf

		(cAliasM)->( dbSkip() )

	EndDo

	(cAliasM)->( dbCloseArea() )

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fRefresh
Função central de atualização de todos os folders e markbrowses simultâneos.
@type function

@author Alexandre Santos
@since 19/09/2019

@sample fRefresh()

@param
@return
/*/
//------------------------------------------------------------------------------------
Static Function fRefresh()

	// Especialidade
	If Empty( aList2 )

		aList2 := { { 0, ' ', 0, 0, 0, 0, 0, '00:00', '00:00', 0, ' ' } }

	EndIf

	// Ordena o array de especilidades pelo código da especialidade
	aSort( aList2, , , { |x,y| x[2] < y[2] } )

	// Atualiza o objeto referente ao folder de especialidade
	oList2:SetArray( aList2 )
	oList2:bLine := bList2
	oList2:GoTop()
	oList2:Refresh()

	// Produto
	If Empty( aList3 )

		aList3 := aList3Def

	EndIf

	// Ordena o array de produtos pela O.S.
	aSort( aList3, , , { |x,y| x[1] < y[1] } )

	// Atualiza o objeto referente ao folder de produto
	oList3:SetArray( aList3 )
	oList3:bLine:= bList3
	oList3:GoTop()
	oList3:Refresh()

	// Ferramenta
	If Empty( aList4 )

		aList4 := { { ' ', ' ', ' ', 0 } }

	EndIf

	// Ordena o array de produtos pela O.S.
	aSort( aList4, , , { |x,y| x[1] < y[1] } )

	// Atualiza o objeto referente ao folder de ferramentas
	oList4:SetArray( aList4 )
	oList4:bLine:= bList4
	oList4:GoTop()
	oList4:Refresh()

	// Mão de obra
	If Empty( aList5 )

		aList5 := { { 0, ' ', ' ', ' ', '00:00', '00:00', 0, ' ' } }

	EndIf

	// Ordena o array de mão de obra pela especialidade do funcionário
	aSort( aList5, , , { |x,y| x[3] < y[3] } )

	// Atualiza o objeto referente ao folder de mão de obra
	oList5:SetArray( aList5 )
	oList5:bLine := bList5
	oList5:GoTop()
	oList5:Refresh()

	// Atualiza markbrowse de O.S. à programar
	dbSelectArea( c990TRB1 )
	dbSetOrder( nTipoInd )
	dbGoTop()
	oMark1:Refresh()

	// Atualiza markbrowse de O.S. em programação
	dbSelectArea( c990TRB3 )
	dbSetOrder( nTipoInd )
	oMark2:Refresh()

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fLoadModE
Atualiza tabelas temporárias de mão de obra e especialidade.
@type function

@author Alexandre Santos
@since 12/09/2019

@sample fLoadModE( 'cTempTable', 'Calend', { 'M RJ 01 ', 'M RJ 01 ', 'M RJ 01 ' }, .F. )

@param  cTempTable, Caracter, Tabela que será consultada.
@param  cCalendar , Caracter, Calendário utilizado pelo insumo.
@param  aBranches , Array   , Lista contendo as filias que serão utilizadas na função.
							 [1] - Filial Especialidade (ST0).
							 [2] - Filial Funcionário (ST1).
							 [3] - Filial Especialidade do Func. (ST2).
@param  [lAll]    , Lógico  , Define se deve considerar todas as O.S. da programação.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fLoadModE( cTempTable, cCalendar, aBranches, lAll )

	Local nX          := 0
	Local cHours      := ''
	Local aSpecialty  := {}

	Default aBranches := {}
	Default lAll      := ( nOSPrInd == 1 )

	// Recupera tempo de execução do insumo no intervalo definido por parâmetro.
	cHours := fTimeInput( (cTempTable)->TL_CODIGO, cCalendar, sToD( (cTempTable)->TL_DTINICI ), (cTempTable)->TL_HOINICI,;
				SToD( (cTempTable)->TL_DTFIM ) , (cTempTable)->TL_HOFIM, lAll )

	If cHours > '00:00'

		// Mão de obra
		If (cTempTable)->TL_TIPOREG == 'M'

			dbSelectArea( c990TRBM )
			dbSetOrder( 1 )
			dbGoTop()
			If !MsSeek( (cTempTable)->TL_ORDEM + (cTempTable)->TL_PLANO + (cTempTable)->TL_CODIGO )

				RecLock( (c990TRBM), .T. )

					(c990TRBM)->ORDEM  := (cTempTable)->TL_ORDEM
					(c990TRBM)->PLANO  := (cTempTable)->TL_PLANO
					(c990TRBM)->CODIGO := (cTempTable)->TL_CODIGO
					(c990TRBM)->DESCRI := Posicione( 'ST1', 1, aBranches[2] + (cTempTable)->TL_CODIGO, 'T1_NOME' )
					(c990TRBM)->CODESP := Posicione( 'ST2', 1, aBranches[3] + (cTempTable)->TL_CODIGO, 'T2_ESPECIA' ) //Essa informção é correta?? o cara pode ter N especialidades
					(c990TRBM)->NOMESP := Posicione( 'ST0', 1, aBranches[1] + (c990TRBM)->CODESP, 'T0_NOME' )
					(c990TRBM)->TEMPRO := cHours
					(c990TRBM)->TEMREA := (c990TRBM)->TEMPRO

				(c990TRBM)->( MsUnLock() )

			Else

				RecLock( (c990TRBM), .F. )

					(c990TRBM)->TEMPRO := NGSOMAHCAR( cHours, (c990TRBM)->TEMPRO )
					(c990TRBM)->TEMREA := (c990TRBM)->TEMPRO

				(c990TRBM)->( MsUnLock() )

			EndIf

			aSpecialty := aClone( fGetEspc( (cTempTable)->TL_CODIGO ) )

		EndIf

		// Especialidade

		// Atribui especialidade ao array, permitindo calculos que consideram multiplas especialidade em um mesmo funcionário
		If Empty( aSpecialty )

			If (cTempTable)->TL_TIPOREG == 'E'

				aSpecialty := { { (cTempTable)->TL_CODIGO, Posicione( 'ST0', 1, aBranches[1] + (cTempTable)->TL_CODIGO,;
					'T0_NOME' ), fCountST2( (cTempTable)->TL_CODIGO ) } }

			Else

				aSpecialty := { { STR0346, STR0346, fCountST2( (cTempTable)->TL_CODIGO ) } } // SEM ESPECIALIDADE DEFINIDA

			EndIf

		EndIf

		For nX := 1 to Len( aSpecialty )

			dbSelectArea( c990TRBE )
			dbSetOrder( 1 ) // ORDEM + PLANO + CODIGO
			If !MsSeek( (cTempTable)->TL_ORDEM + (cTempTable)->TL_PLANO + aSpecialty[nX,1] )

				RecLock( (c990TRBE), .T. )

					(c990TRBE)->ORDEM  := (cTempTable)->TL_ORDEM
					(c990TRBE)->PLANO  := (cTempTable)->TL_PLANO
					(c990TRBE)->CODIGO := aSpecialty[nX,1]
					(c990TRBE)->DESCRI := aSpecialty[nX,2]
					(c990TRBE)->QTDTEC := aSpecialty[nX,3]

					/*
						Neste ponto são tratado insumos do tipo especialidade e mão de obra, para os casos onde seja
						mão de obra, o campo TL_QUANREC vira como 0 portanto para contabilizar no folder de especialidade
						é fixado o valor de 1. Para os insumos do tipo especialidade o valor mínimo já é um, portanto
						qualquer valor maior que este já é considerado.
					*/
					If (cTempTable)->TL_QUANREC > 1

						(c990TRBE)->TEMPRO := MtoH( HtoM( cHours ) * (cTempTable)->TL_QUANREC )

					Else

						(c990TRBE)->TEMPRO := cHours

					EndIf

					(c990TRBE)->TEMREA := (c990TRBE)->TEMPRO

				(c990TRBE)->( MsUnLock() )

			Else

				RecLock( (c990TRBE), .F. )

					If (cTempTable)->TL_QUANREC > 1

						(c990TRBE)->TEMPRO := NGSOMAHCAR( MtoH( HtoM( cHours ) * (cTempTable)->TL_QUANREC ),;
														(c990TRBE)->TEMPRO )

					Else

						(c990TRBE)->TEMPRO := NGSOMAHCAR( cHours, (c990TRBE)->TEMPRO )

					EndIf

					(c990TRBE)->TEMREA := (c990TRBE)->TEMPRO

				(c990TRBE)->( MsUnLock() )

			EndIf

		Next nX

	EndIf

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fLoadProd
Atualiza tabela temporária de produto.
@type function

@author Alexandre Santos
@since 18/09/2019

@sample fLoadProd( 'cAlias', .F. )

@param  cAlias, string, Tabela que será consultada.
@param  cAlias, array   , Lista com produto que já tiveram o saldo consultado.

@return
/*/
//------------------------------------------------------------------------------------
Static Function fLoadProd( cAlias, aSldPrd )

	Local nQtdFis := 0
	Local nPosSld := 0

	dbSelectArea( 'SB1' )
	dbSetOrder( 1 ) // B1_FILIAL + B1_COD
	msSeek( FWxFilial( 'SB1' ) + (cAlias)->TL_CODIGO )

	dbSelectArea( 'SB2' )
	dbSetOrder( 1 ) // B2_FILIAL + B2_COD + B2_LOCAL
	msSeek( FWxFilial( 'SB2' ) + SB1->B1_COD + SB1->B1_LOCPAD )

	If ( nPosSld := aScan( aSldPrd, { |x| x[1] == SB1->B1_COD } ) ) > 0

		nQtdFis := aSldPrd[nPosSld,2]

	Else

		nQtdFis := SaldoSB2( .F., .T., dDataBase+3650, .F. )

		aAdd( aSldPrd, { SB1->B1_COD, nQtdFis } )

	EndIf

	dbSelectArea( c990TRBB1 )
	dbSetOrder( 1 )
	dbGoTop()
	If !msSeek( (cAlias)->TL_ORDEM + (cAlias)->TL_PLANO + (cAlias)->TL_CODIGO )

		RecLock( (c990TRBB1), .T. )

			(c990TRBB1)->ORDEM  := (cAlias)->TL_ORDEM
			(c990TRBB1)->PLANO  := (cAlias)->TL_PLANO
			(c990TRBB1)->CODIGO := (cAlias)->TL_CODIGO
			(c990TRBB1)->DESCRI := Posicione( 'SB1', 1, xFilial( 'SB1' ) + (cAlias)->TL_CODIGO, 'B1_DESC' )
			(c990TRBB1)->QTDNEC := (cAlias)->TL_QUANTID
			(c990TRBB1)->NUMSC  := (cAlias)->TL_NUMSC
			(c990TRBB1)->NUMSA  := (cAlias)->TL_NUMSA
			(c990TRBB1)->ITEMSA := (cAlias)->TL_ITEMSA
			(c990TRBB1)->DTINIP := SToD( (cAlias)->TL_DTINICI )
			(c990TRBB1)->QTDFIS := nQtdFis
			(c990TRBB1)->QTDEST := nQtdFis + SB2->B2_SALPEDI + SB2->B2_QACLASS - SB2->B2_QEMPN + AvalQtdPre( 'SB2', 2 )

		(c990TRBB1)->( MsUnLock() )

	Else

		RecLock( (c990TRBB1), .F. )

			(c990TRBB1)->QTDNEC += (cAlias)->TL_QUANTID

		(c990TRBB1)->( MsUnLock() )

	EndIf

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fLoadTool
Atualiza tabela temporária de ferramentas.
@type function

@author Alexandre Santos
@since 19/09/2019

@sample fLoadTool( 'cAlias', .F. )

@param  cAlias   , Caracter, Tabela que será consultada.
@param  [lAll]   , Lógico  , Define se deve considerar todas as O.S. da programação.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fLoadTool( cAlias, lAll )

	Default lAll := .F.

	dbSelectArea( c990TRBF )
	dbSetOrder( 1 )
	dbGoTop()
	If !MsSeek( (cAlias)->TL_ORDEM + (cAlias)->TL_PLANO + (cAlias)->TL_CODIGO )

		RecLock( (c990TRBF), .T. )

			(c990TRBF)->ORDEM  := (cAlias)->TL_ORDEM
			(c990TRBF)->PLANO  := (cAlias)->TL_PLANO
			(c990TRBF)->CODIGO := (cAlias)->TL_CODIGO
			(c990TRBF)->DESCRI := Posicione( 'SH4', 1, xFilial( 'SH4' ) + (cAlias)->TL_CODIGO, 'H4_DESCRI' )
			(c990TRBF)->QUANTI := (cAlias)->TL_QUANTID

		(c990TRBF)->( MsUnLock() )

	Else

		RecLock( (c990TRBF), .F. )

			(c990TRBF)->QUANTI += (cAlias)->TL_QUANTID

		(c990TRBF)->( MsUnLock() )

	EndIf

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fTimeInput
Calcula a duração do insumo para o dia atual setado no calendário.
@type function

@author Alexandre Santos
@since 12/09/2019

@sample fTimeInput( 'COD001', , 11/09/2019, '08:00', 12/09/2019, '08:00', , 11/09/2019 )

@param  cCode      , Caracter, Código do insumo.
@param  [cCalendar], Caracter, Código do calendário.
@param  dDateIn    , Data    , Data inicio do insumo.
@param  cHorIn     , Caracter, Hora inicio do insumo.
@param  dDateFi    , Data    , Data fim do insumo.
@param  cHorFi     , Caracter, Hora fim do insumo.
@param  [lAll]     , Lógico  , Define se deve considerar todas as O.S. da programação.
@param  [dDtaAtu]  , Data    , Data atual setada no calendário.
@return Caracter   , Quantidade de horas de duração do insumo no dia setado no calendário.
/*/
//------------------------------------------------------------------------------------
Static Function fTimeInput( cCode, cCalendar, dDateIn, cHorIn, dDateFi, cHorFi, lAll, dDtaAtu )

	Local nDay        := 0.0     // Valor numérico referente ao dia  Ex: Domingo(1) / Segunda(2)
	Local cHours      := '00:00' // Hora em formato sexagesimal      Ex: 01:30 / 13:45
	Local aCldInfo    := {}      // Informações gerais do calendário.
	Local lUseCald    := .F.

	Default lAll      := .F.
	Default cCalendar := ''
	Default dDtaAtu    := _dDiaAtu

	If !Empty( cCalendar ) // Considera calendário.

		lUseCald := .T.
		aCldInfo := NGCALENDAH( cCalendar )
		nDay 	 := Dow( dDtaAtu )

	EndIf

	Do Case

		// INSUMO INICIA E FINALIZA NA DATA SETADO NO CALENDÁRIO OU QUANDO FOR APRESENTADO TODOS INSUMOS
		Case ( dDateIn == dDtaAtu .And. dDateFi == dDtaAtu ) .Or. lAll

			If lUseCald
				cHours := NtoH( TimeWork( dDateIn, cHorIn, dDateFi, cHorFi, cCalendar ) )
			Else
				cHours := NtoH( NGCALCH100( dDateIn, cHorIn, dDateFi, cHorFi ) )
			EndIf

		// INSUMO INICIA NA DATA SETADO NO CALENDÁRIO, PORÉM FINALIZA EM OUTRA DATA.
		Case dDateIn == dDtaAtu

			If lUseCald
				cHours  := NtoH( TimeWork( dDateIn, cHorIn, dDateIn, aCldInfo[nDay,2,Len( aCldInfo[nDay,2] ),2],;
									cCalendar ) )
			Else
				cHours := NtoH( NGCALCH100( dDateIn, cHorIn, dDateIn, '24:00' ) )
			EndIf

		// INSUMO FINALIZA NA DATA SETADA NO CALENDÁRIO.
		Case dDateFi == dDtaAtu

			If lUseCald
				cHours := NtoH( TimeWork( dDateFi, aCldInfo[nDay,2,1,1], dDateFi, cHorFi, cCalendar ) )
			Else
				cHours := NtoH( NGCALCH100( dDateFi, '00:00', dDateFi, cHorFi ) )
			EndIf

		// DATA SETADA ESTÁ FORA DO PERIODO DE INICIO E FIM DO INSUMO.
		Case dDateFi < dDtaAtu .Or. dDateIn > dDtaAtu
			cHours	:= "00:00"

		// DATA SETADA ESTÁ ENTRE O INICIO E O FIM DO INSUMO.
		OtherWise

			If lUseCald
				cHours := aCldInfo[nDay,1]
			Else
				cHours := '24:00'
			EndIf

	EndCase

Return cHours

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fGetEspc
Recupera todas as especialidades vinculadas a um funcionário.
@type function

@author Alexandre Santos
@since 12/09/2019

@sample fGetEspc( 'COD001' )

@param  cCode, Caracter, Código do funcionário.
@return Array,  [1] - Códgio da especialidade.
				[2] - Descrição da especialidade.
/*/
//------------------------------------------------------------------------------------
Static Function fGetEspc( cCode )

	Local cAliasST2 := GetNextAlias()
	Local aReturn   := {}
	Local aArea     := GetArea()
	Local cModComp  := '%' + NgModComp( 'ST0', 'ST2' ) + '%'

	BeginSQL Alias cAliasST2

		SELECT
			ST2.T2_ESPECIA,
			ST0.T0_NOME
		FROM
			%table:ST2% ST2
		INNER JOIN
			%table:ST0% ST0 ON
				ST2.T2_ESPECIA = ST0.T0_ESPECIA AND
				ST0.%NotDel%                    AND
				%exp:cModComp%
		WHERE
			ST2.T2_FILIAL  = %xFilial:ST2% AND
			ST2.T2_CODFUNC = %exp:cCode%   AND
			ST2.%NotDel%

	EndSQL

	Do While (cAliasST2)->( !EoF() )

		aAdd( aReturn, { (cAliasST2)->T2_ESPECIA, (cAliasST2)->T0_NOME, fCountST2( (cAliasST2)->T2_ESPECIA ) } )
		(cAliasST2)->( dbSkip() )

	EndDo

	(cAliasST2)->( dbCloseArea() )
	RestArea( aArea )

Return aReturn

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fCountST2
Contabiliza a quantidade de funcionários em determinada especialidade.
@type function

@author Alexandre Santos
@since 03/11/2020

@sample fCountST2( '00000' )

@param  cCode, string, Código da especialidade pesquisada.
@return numeric, Quantidade e funcionários vinculados a especialidade pesquisada.
/*/
//------------------------------------------------------------------------------------
Static Function fCountST2( cCode )

	Local cAliasST2 := GetNextAlias()
	Local nResult   := 0

	BeginSQL Alias cAliasST2

		SELECT
			COUNT( ST1.T1_CODFUNC ) AS QTDT2
		FROM
			%table:ST2% ST2
		RIGHT JOIN
			%table:ST1% ST1 ON
				ST1.T1_CODFUNC = ST2.T2_CODFUNC AND
				ST1.%NotDel%
		WHERE
			ST2.T2_FILIAL  = %xFilial:ST2% AND
 			ST2.T2_ESPECIA = %exp:cCode%   AND
 			ST2.%NotDel%

	EndSQL

	nResult := (cAliasST2)->QTDT2

	(cAliasST2)->( dbCloseArea() )

Return nResult

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fUpdInsum
Atualiza datas da O.S. e insumos diretamente na tabela temporária.
@type function

@author Alexandre Santos
@since 23/09/2019

@sample fUpdInsum( '000001', '000000', 23/09/2019, {   /  /  , ':', /  /    , ':' } )

@param  cOrder, Caracter, Ordem de Serviço.
@param  cPlan , Caracter, Plano de Manutenção.
@param  dNewDt, Data    , Nova data da O.S.
@param  aDtOS , Array   , Datas atuais da O.S.
							[1] - TJ_DTMPINI.
							[2] - TJ_HOMPINI.
							[3] - TJ_DTMPFIM.
							[4] - TJ_HOMPFIM.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fUpdInsum( cOrder, cPlan, dNewDt, aDtOS )

	Local aArea := GetArea()

	dbSelectArea( cTempStl )
	dbSetOrder( 1 ) // TL_ORDEM + TL_PLANO + TL_SEQRELA + TL_TIPOREG + TL_CODIGO
	If MsSeek( cOrder + cPlan )

		Do While cOrder == (cTempStl)->TL_ORDEM .And. cPlan == (cTempStl)->TL_PLANO

			If (cTempStl)->TL_TIPOREG == 'P'

				// QUANDO PRODUTO DATA E HORA INICIO MANTE-SE IGUAIS A DATA E HORA FIM.
				aDtIns := { dNewDt, (cTempStl)->TL_HOINICI, dNewDt, (cTempStl)->TL_HOINICI }

			Else

				// QUANDO DEMAIS INSUMOS ACIONA A FUNÇÃO DA ROTINA MNTA420 PARA CALCULO DA DATA E HORA FIM.
				aDtIns := M420RETDAT( (cTempStl)->TL_CODIGO, dNewDt, (cTempStl)->TL_HOINICI, (cTempStl)->TL_QUANTID,;
				(cTempStl)->TL_USACALE )

			EndIf

			// ATUALIZA DATA DOS INSUMOS, CONFORME A DATA DA O.S.
			RecLock( cTempStl, .F. )

				(cTempStl)->TL_DTINICI := aDtIns[1]
				(cTempStl)->TL_HOINICI := aDtIns[2]
				(cTempStl)->TL_DTFIM   := aDtIns[3]
				(cTempStl)->TL_HOFIM   := aDtIns[4]
				(cTempStl)->STATUS     := IIf( (cTempStl)->STATUS == 2 .Or. (cTempStl)->STATUS == 0, 2, (cTempStl)->STATUS )

			(cTempStl)->( MsUnLock() )

			// DEFINE A MENOR DATA E HORA COMO INICIO DA O.S.
			If Empty( aDtOS[2] ) .Or. ( dToS( aDtOS[1] ) + aDtOS[2] > dToS( aDtIns[1] ) + aDtIns[2] )

				aDtOS[1] := aDtIns[1]
				aDtOS[2] := aDtIns[2]

			EndIf

			// DEFINE A MAIOR DATA E HORA COMO FIM DA O.S.
			If dToS( aDtOS[3] ) + aDtOS[4] < dToS( aDtIns[3] ) + aDtIns[4]

				aDtOS[3] := aDtIns[3]
				aDtOS[4] := aDtIns[4]

			EndIf

			(cTempStl)->( dbSkip() )

		EndDo

	EndIf

	RestArea( aArea )

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} NGUpdDtOrd
Atualiza datas da O.S. e insumos diretamente na tabela temporária.
@type function

@author Alexandre Santos
@since 23/09/2019

@sample NGUpdDtOrd( '000001', '000000', .T., { 23/09/2019, '10:00' } )

@param  cOrder , Caracter, Ordem de Serviço.
@param  cPlan  , Caracter, Plano de Manutenção.
@param  nOption, Númerico, Define se atulização é referente ao início, fim ou ambos momentos da O.S.
@param  aNewDt , Array   , Datas para atualização, obedecendo o parametro lStart.
							[1] - TJ_DTMPINI / TJ_DTMPFIM.
							[2] - TJ_HOMPINI / TJ_HOMPFIM.
@return
/*/
//------------------------------------------------------------------------------------
Function NGUpdDtOrd( cOrder, cPlan, nOption, aNewDt )

	Local aAreaSC2 := SC2->( FWGetArea() )
	Local aAreaSTJ := STJ->( FWGetArea() )
	Local aStpIn   := {}
	Local aStpFi   := {}
	Local aIntCZ2  := {}
	Local aDtBkp   := {}
	Local cOp      := ''
	Local cIntSFC  := IIf( FindFunction( 'NGINTSFC' ), NGINTSFC( .F. ), '' ) // Verifica se ha integracao com modulo Chao de Fabrica [SIGASFC]

	Default aOSRepro := {}

	If Empty( aNewDt[2] )
		aNewDt[2] := Substr( Time(), 1, 5 )
	EndIf

	dbSelectArea( 'STJ' )
	dbSetOrder( 1 )
	If MsSeek( xFilial( 'STJ' ) + cOrder + cPlan )

		aDtBkp := {STJ->TJ_DTPPINI, STJ->TJ_HOPPINI}

		cOp := STJ->TJ_ORDEM + 'OS001'

		If aScan(aOSRepro,{|x| x[1] == STJ->TJ_ORDEM}) == 0 .And. STJ->TJ_SITUACA == 'L'

			aAdd( aOSRepro, { STJ->TJ_ORDEM, STJ->TJ_PLANO} )

		EndIf

		// DATA E HORA ÍNICIO
		If nOption == 1

			RecLock( 'STJ', .F. )
				STJ->TJ_DTMPINI := SToD( aNewDt[1] )
				STJ->TJ_HOMPINI := aNewDt[2]
			STJ->( MsUnLock() )

		// DATA E HORA FIM
		ElseIf nOption == 2

			RecLock( 'STJ', .F. )
				STJ->TJ_DTMPFIM := SToD( aNewDt[1] )
				STJ->TJ_HOMPFIM := aNewDt[2]
			STJ->( MsUnLock() )

		// AMBOS
		ElseIf nOption == 0

			RecLock( 'STJ', .F. )
				STJ->TJ_DTMPINI := SToD( aNewDt[1] )
				STJ->TJ_HOMPINI := aNewDt[2]
				STJ->TJ_DTMPFIM := SToD( aNewDt[1] )
				STJ->TJ_HOMPFIM := aNewDt[2]
			STJ->( MsUnLock() )

		EndIf

		// RECALCULA DATA DE PARADA PREVISTA INÍCIO DA MANUTENÇÃO.
		aStpIn := MNT490PRE( STJ->TJ_CODBEM, STJ->TJ_SERVICO, STJ->TJ_SEQRELA, STJ->TJ_DTMPINI, STJ->TJ_HOMPINI )

		// RECALCULA DATA DE PARADA PREVISTA FIM DA MANUTENÇÃO.
		aStpFi := MNT490POS( STJ->TJ_CODBEM, STJ->TJ_SERVICO, STJ->TJ_SEQRELA, STJ->TJ_DTMPFIM, STJ->TJ_HOMPFIM )

		// ATUALIZA DATAS DE PARADA DA O.S.
		If !Empty( aStpIn ) .And. !Empty( aStpFi )

			RecLock( 'STJ', .F. )
				STJ->TJ_DTPPINI := aStpIn[1]
				STJ->TJ_HOPPINI := aStpIn[2]
				STJ->TJ_DTPPFIM := aStpFi[1]
				STJ->TJ_HOPPFIM := aStpFi[2]
			STJ->(MsUnLock())

		EndIf

		dbSelectArea( 'SC2' )
		dbSetOrder( 1 ) // C2_FILIAL + C2_NUM + C2_ITEM + C2_SEQUEN + C2_ITEMGRD
		If MsSeek( xFilial( 'SC2' ) + cOp )

			// ATUALIZA DATAS REALCIONADA A ORDEM DE PRODUÇÃO VINCULADA A O.S.
			Do While SC2->( !EoF() ) .And. SC2->C2_FILIAL == xFilial( 'SC2' ) .And. SC2->C2_NUM + SC2->C2_ITEM +;
			 SC2->C2_SEQUEN == cOp

				RecLock( 'SC2', .F. )
					SC2->C2_DATPRI  := STJ->TJ_DTMPINI
					SC2->C2_DATPRF  := STJ->TJ_DTMPINI
				SC2->( MsUnLock() )

				SC2->( dbSkip() )

			EndDo

		EndIf

		// Atualiza Bloqueio
		If FindFunction('MNTAJUSSH9') .And. (aDtBkp[1] <> STJ->TJ_DTPPINI .Or. aDtBkp[2] <> STJ->TJ_HOPPINI) .And. NGIFDBSEEK('ST9',STJ->TJ_CODBEM,1);
		.And. !Empty(ST9->T9_RECFERR)

			MNTAJUSSH9(STJ->TJ_ORDEM, STJ->TJ_PLANO, aDtBkp)

		EndIf

		// CASO INTEGRADO AO MÓDULO CHÃO DE FÁBRICA ( SIGASFC ), ATUALIZA PARADA PROGRAMADA (CZ2).
		If !Empty( cIntSFC ) .And. !Empty( STJ->TJ_DTPPINI ) .And. !Empty( NGVRFMAQ( STJ->TJ_CODBEM ) )

			// DATA DE INÍCIO DA PARADA DO BEM.
			aAdd( aIntCZ2, { 'CZ2_DTBGPL', STJ->TJ_DTPPINI } )

			// HORA INÍCIO DA PARADA DO BEM.
			aAdd( aIntCZ2, { 'CZ2_HRBGPL', PadR( Trim( Transform( STJ->TJ_HOPPINI, '99:99:99' ) ), 8, '0' ) } )

			// DATA DE FIM DA PARADA DO BEM.
			aAdd( aIntCZ2, { 'CZ2_DTEDPL', STJ->TJ_DTPPFIM } )

			// HORA FIM DA PARADA DO BEM.
			aAdd( aIntCZ2, { 'CZ2_HREDPL', PadR( Trim( Transform( STJ->TJ_HOPPFIM, '99:99:99' ) ), 8, '0' ) } )

			// TIPO ESTADO PARADA.
			aAdd( aIntCZ2, { 'CZ2_TPSTSP', NGSFCSTPP( cIntSFC ) } )

			// ATUALIZA PARADA PROGRAMADA CONFORME O.S.
			NGSFCATPRD( STJ->TJ_ORDEM, aIntCZ2 )

		EndIf

	EndIf

	FWRestArea( aAreaSC2 )
	FWRestArea( aAreaSTJ )

	/*----------------------------+
	| Desaloca consumo de memória |
	+----------------------------*/
	FWFreeArray( aStpIn )
	FWFreeArray( aStpFi )
	FWFreeArray( aAreaSC2 )
	FWFreeArray( aAreaSTJ )
	FWFreeArray( aIntCZ2 )
	FWFreeArray( aDtBkp )

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fVldBlqMOE
Validação de bloqueio dentro da tabela temporaria.
@type function

@author Alexandre Santos
@since 18/12/2019

@sample fVldBlqMOE( '000001', '000000', 'CCOD00', 'M', { 23/09/2019, '10:00' } )

@param  cOrder , Caracter, Ordem de Serviço.
@param  cPlan  , Caracter, Plano de Manutenção.
@param  cCode  , Caracter, Código do Insumo.
@param  cTipRg , Caracter, Tipo do Insumo.
@param  aNewDt , Array   , Inicio do insumo
							[1] - Data
							[2] - Hora
@return
/*/
//------------------------------------------------------------------------------------
Static Function fVldBlqMOE( cCode, cTipRg, aNewDt, cKeySTL )

	Local cAliasTL := GetNextAlias()
	Local cTable   := '%' + oTmpSTL:GetRealName()   + '%'
	Local cMessage := ''
	Local cInit    := dToS( aNewDt[1] ) + aNewDt[2]
	Local cEnd     := dToS( aNewDt[3] ) + aNewDt[4]
	Local lRet     := .T.

	BeginSQL Alias cAliasTL

		SELECT
			NULL
		FROM
			%exp:cTable%
		WHERE
			EXISTS(
					SELECT
						NULL
					FROM
						%exp:cTable%
					WHERE
						TL_CODIGO  = %exp:cCode%   AND
						TL_TIPOREG = %exp:cTipRg%  AND
						STATUS IN ( 1, 2 )         AND // Somente registros que foram incluidos ou alterados na prog. os
						TL_DTINICI || TL_HOINICI <= %exp:cInit% AND
						TL_DTFIM   || TL_HOFIM   >= %exp:cEnd%  AND
						TL_ORDEM || TL_PLANO || TL_TAREFA || TL_TIPOREG || TL_CODIGO <> %exp:cKeySTL% AND
						%NotDel%
			)

	EndSQL

	If (cAliasTL)->( !EoF() )

		/*
			Já existe bloqueio do funcionário no periodo apontado: XX/XX/XXXX às XX:XX
			até XX/XX/XXXX às XX:XX.
		*/
		cMessage := STR0352 + dToC( aNewDt[1] ) + STR0353 + aNewDt[2] + STR0354 + dToC( aNewDt[3] ) +;
			STR0353 + aNewDt[4] + '.'
		lRet     := .F.

	EndIf

	(cAliasTL)->( dbCloseArea() )

Return { lRet, cMessage }

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fAlterDtOS
Permite a alteração da data da ordem de serviço, repassando para seus relacionamentos.
@type function

@author Alexandre Santos
@since 25/09/2019

@sample fAlterDtOS( cTRB01, 1 )

@param  cAlias , Caracter, Tabela temporária que possui a O.S. para atualização.
@param  nOption, Númerico, Define de qual markbrowse o processo foi acionado.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fAlterDtOS( cAlias, nOption )

	Local lAll      := .F.
	Local lCancel   := .F.
	Local lExit     := .T.
	Local lNoFlag   := .T. // Define que não existe ordens selecionadas para esta alteração de data.
	Local lAltCpo   := lAltProg
	Local aTemp     := {}
	Local oDialog
	Local oCheck
	Local oPanel3

	Default nOption := 0

	If (cAlias)->( !EoF() )

		If lAltCpo

			If ExistBlock( 'MNTA990D' )

				lAltCpo := ExecBlock( 'MNTA990D', .F., .F., { (cAlias)->ORDEM, (cAlias)->DTMPINI } )

			Else

				If (cAlias)->REALIZA == '1'

					MsgInfo( STR0115 ) // A Ordem de Serviço já possui insumo(s) realizado(s), portanto, não será possível alterar a data prevista.
					lExit   := .F.

				EndIf

			EndIf

		EndIf

		dDTMPINI := (cAlias)->DTMPINI

		If lExit

			nOpc1Cad := 0
			Define MsDialog oDialog Title OemToAnsi( STR0062 ) From 0,0 To 11,65 OF oMainWnd  // Alterar Data

				oDialog:lEscClose := .F.

				oPanel3 := TPanel():New( 0, 0, , oDialog, , .T., .F., , , 0, 0, .T., .F. )
				oPanel3:Align := CONTROL_ALIGN_ALLCLIENT

				@ 010,008 Say Oemtoansi( STR0010 ) Of oPanel3 Pixel // Ordem
				@ 010,045 MsGet (cAlias)->ORDEM Size 50,7 Of oPanel3 Pixel When .F.

				@ 026,008 Say Oemtoansi( STR0015 ) Of oPanel3 Pixel // Data Prevista
				@ 026,045 MsGet dDTMPINI Picture '99/99/9999' Valid NaoVazio() Size 50,7 Of oPanel3 Pixel When lAltCpo HASBUTTON

				@ 042,008 CheckBox oCheck Var lAll Prompt STR0116; // Aplicar as alterações em todas as O.S. listadas?
				Size 130,7 OF oPanel3 PIXEL When lAltCpo

			Activate MsDialog oDialog On Init EnchoiceBar( oDialog, { || ( oDialog:End(), nOpc1Cad := 1 ) }, { ||;
				oDialog:End(), lCancel := .T.} ) Centered

			If nOpc1Cad == 1 .And. lAltCpo .And. !lCancel

				aTemp := GetArea()

				// Repassa a data alterada para todas as O.S. que estão listadas, independete das marcações.
				If lAll

					lNoFlag := .F. // Define que existe ordens selecionadas para está alteração.

					dbSelectArea( cAlias )
					dbSetOrder( 3 ) // ORDEM + PLANO
					dbGoTop()
					Do While (cAlias)->( !EoF() )

						fSaveDtOS( cAlias, nOption, dDTMPINI )

						(cAlias)->( dbSkip() )

					EndDo

				// Atualiza a data somente para as O.S. marcadas.
				Else

					dbSelectArea( cAlias )
					dbSetOrder( 2 ) // MARCADO
					dbGoTop()
					Do While (cAlias)->( !EoF() )

						If !Empty( (cAlias)->MARCADO )

							fSaveDtOS( cAlias, nOption, dDTMPINI )
							lNoFlag := .F. // Define que existe ordens selecionadas para está alteração.

						EndIf

						(cAlias)->( dbSkip() )

					EndDo

				EndIf

				RestArea( aTemp )
				dbGoTop()

				// As O.S. marcadas foram alteradas com êxito.
				If !lNoFlag

					If lPrgDiaria .And. INCLUI

						If dDTMPINI < dTT1_DTPROG

							dTT1_DTPROG := dDTMPINI

						EndIf

						If dDTMPINI > dTT1_DTFIM

							dTT1_DTFIM := dDTMPINI

						EndIf

					ElseIf !lPrgDiaria

						If dDTMPINI < dTT1_DTPROG

							dTT1_DTPROG := dDTMPINI

						EndIf

						If dDTMPINI > dTT1_DTFIM

							dTT1_DTFIM := dDTMPINI

						EndIf

					EndIf

					// Atualiza registros da O.S. em folders e markbrowse assumindo a nova data.
					Processa( { |lEND| fPrgChgDia( 2 ) }, STR0046 ) // Atualizando Calendário...

					// Atualiza legenda do calendário.
					Processa( { |lEND| fPrgChgMes( 1, @oCalend ) }, STR0046 ) // Atualizando Calendário...

				// Apresenta alerta que não foi selecionada nenuma O.S. para a alteração
				Else

					/*
					Atenção ### Não foi marcado nenhuma ordem de serviço para esta alteração de data ###
					Favor marque no browse quais ordens de serviço devem assumir esta data ou habilite a aplicação para todas as ordens listadas.
					*/
					Help( '', 1, STR0247, , STR0348, 2, 0, , , , , , { STR0349 } )

				EndIf

				If nOption > 0

					dbSelectArea( c990TRB3 )
					oMark2:GoTop()

				Else

					dbSelectArea( c990TRB1 )
					oMark1:GoTop()

				EndIf

			Else

				If dDTMPINI < dTT1_DTPROG .Or. dDTMPINI > dTT1_DTFIM

					Help( '', 1, 'NGATENCAO', , STR0136 + Chr( 13 ) + Chr( 10 ) +; // A Data Prevista deve estar no período da Programação.
						STR0240 + dToC( dTT1_DTPROG ) + ' à ' + dToC( dTT1_DTFIM ), 3, 1 ) // Período: De

				EndIf

			EndIf

		EndIf

	ElseIf lAltProg

		Help( '', 1, 'NGATENCAO', , STR0113, 3, 1 ) // Arquivo vazio!

	EndIf

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fSaveDtOS
Realiza a cópia e gravação dos registros da O.S. entre as tabelas temporárias.
@type function

@author Alexandre Santos
@since 25/09/2019

@sample fSaveDtOS( cTRB01, 1 )

@param  cAlias  , Caracter, Tabela temporária que possui a O.S. para atualização.
@param  nOption , Númerico, Define de qual markbrowse o processo foi acionado.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fSaveDtOS( cAlias, nOption, dDate )

	Local aDtOS      := { cToD( '' ), '', cToD( '' ), '' }
	Local cError     := ''

	Default nOption  := 0

	/*--------------------------------------------------+
	| Valida a alteração de datas referente aos insumos |
	+--------------------------------------------------*/
	If fVldInsum(  (cAlias)->ORDEM, (cAlias)->PLANO, dDate, @cError ) 
		
		/*-------------------------------------------+
		| Atualização de datas referente aos insumos |
		+-------------------------------------------*/
		fUpdInsum( (cAlias)->ORDEM, (cAlias)->PLANO, dDate, @aDtOS )

		// Caso não exista insumos na O.S. assume-se a nova data, já horarios da ordem se mantem
		If Empty( aDtOS[1] )

			aDtOS := { dDate, (cAlias)->HOMPINI, dDate, (cAlias)->HOMPFIM }

		EndIf

		RecLock( cAlias, .F. )

			(cAlias)->DTMPROG := aDtOS[1]
			(cAlias)->DTMPINI := aDtOS[1]
			(cAlias)->HOMPINI := aDtOS[2]
			(cAlias)->DTMPFIM := aDtOS[3]
			(cAlias)->HOMPFIM := aDtOS[4]

		(cAlias)->( MsUnLock() )

		If nOption == 1

			// REPASSE PARA TABELA BACKUP
			dbSelectArea( c990TRB2 )
			dbSetOrder( 3 ) // ORDEM + PLANO
			dbGoTop()
			If dbSeek( (c990TRB3)->ORDEM + (c990TRB3)->PLANO )

				If (c990TRB2)->REALIZA == '0'

					RecLock( c990TRB2, .F. )

						(c990TRB2)->DTMPROG := aDtOS[1]
						(c990TRB2)->DTMPINI := aDtOS[1]
						(c990TRB2)->HOMPINI := aDtOS[2]
						(c990TRB2)->DTMPFIM := aDtOS[3]
						(c990TRB2)->HOMPFIM := aDtOS[4]

					(c990TRB2)->( MsUnLock() )

				EndIf

			EndIf

		EndIf

	Else

		If !Empty( cError )

			NGMSGMEMO( STR0285,; // ATENÇÃO
				STR0355 + CRLF + CRLF + cError ) // Não existe disponibilidade de calendário para os funcionários listados abaixo: 

		EndIf

	EndIf

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fDelTemp
Realiza a deleção dos registros da das tabelas temporárias.
@type function

@author Alexandre Santos
@since 26/05/2021

@return
/*/
//------------------------------------------------------------------------------------
Function fDelTemp()

	Local cDelete := ''

	// Produtos
	cDelete := 'DELETE FROM ' + oARQT990B1:GetRealName()
	cDelete += ' WHERE '
	cDelete += ' ORDEM = ' + ValToSQL( M->TJ_ORDEM ) + ' AND '
	cDelete += ' PLANO = ' + ValToSQL( M->TJ_PLANO )

	TcSQLExec( cDelete )

	// Ferramentas
	cDelete := 'DELETE FROM ' + oARQT990F:GetRealName()
	cDelete += ' WHERE '
	cDelete += ' ORDEM = ' + ValToSQL( M->TJ_ORDEM ) + ' AND '
	cDelete += ' PLANO = ' + ValToSQL( M->TJ_PLANO )

	TcSQLExec( cDelete )

	// Mão de Obra
	cDelete := 'DELETE FROM ' + oARQT990M:GetRealName()
	cDelete += ' WHERE '
	cDelete += ' ORDEM = ' + ValToSQL( M->TJ_ORDEM ) + ' AND '
	cDelete += ' PLANO = ' + ValToSQL( M->TJ_PLANO )

	TcSQLExec( cDelete )

	// Especialidade
	cDelete := 'DELETE FROM ' + oARQT990E:GetRealName()
	cDelete += ' WHERE '
	cDelete += ' ORDEM = ' + ValToSQL( M->TJ_ORDEM ) + ' AND '
	cDelete += ' PLANO = ' + ValToSQL( M->TJ_PLANO )

	TcSQLExec( cDelete )

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fUpdList1
Atualiza a tabela temporária de insumos
@type function

@author Alexandre Santos
@since 26/05/2021

@param  aColsOld  , Array, Insumos antes da alteração .
@param  aColsNew  , Array, Insumos após a alteração.

@return
/*/
//------------------------------------------------------------------------------------
Static Function fUpdList1( aColsOld, aColsNew )

	Local aSpec  := {}
	Local nIndex := 0
	Local nPsLst := 0
	Local nPsReg := GDFieldPos( 'TL_TIPOREG', aHeaIns )
	Local nPsCod := GDFieldPos( 'TL_CODIGO' , aHeaIns )
	Local nPsDtI := GDFieldPos( 'TL_DTINICI', aHeaIns )
	Local nPsHoI := GDFieldPos( 'TL_HOINICI', aHeaIns )
	Local nPsDtF := GDFieldPos( 'TL_DTFIM'  , aHeaIns )
	Local nPsHoF := GDFieldPos( 'TL_HOFIM'  , aHeaIns )
	Local nPsUse := GDFieldPos( 'TL_USACALE', aHeaIns )
	Local nPsQRe := GDFieldPos( 'TL_QUANREC', aHeaIns )

	// Alteração/Deleção de Insumo
	If !Empty( aColsOld )

		Do Case

			// Mão de Obra e Especialidade
			Case aColsOld[nPsReg] $ 'M/E'

				// Obtém intervalo de tempo de utilização prevista para o insumo antes da alteração.
				cHours := fTimeInput( aColsOld[nPsCod], IIf( aColsOld[nPsUse] == 'S', fGetCalen( aColsOld[nPsCod], aColsOld[nPsDtI],;
					aColsOld[nPsDtF] ), '' ), aColsOld[nPsDtI], aColsOld[nPsHoI], aColsOld[nPsDtF], aColsOld[nPsHoF], .F. )

				If aColsOld[nPsReg] == 'M' .And. ( nPsLst := aScan( aList5, { |x| x[2] == Trim( aColsOld[nPsCod] ) } ) ) > 0

					// Subtrai tempo previsto de antes da alteração do totalizador geral do funcionário.
					aList5[nPsLst,5] := NToH( SubHoras( aList5[nPsLst,5], cHours ) )

					// Quando a subtração zerar o totalizador do funcionário o mesmo é removido do array.
					If HToN( aList5[nPsLst,5] ) <= 0

						// Remove insumo do aList.
						aDel( aList5, nPsLst )

						// Ajusta tamanho do aList.
						aSize( aList5, Len( aList5 ) - 1 )

					EndIf

					// Obtém especialidades do funcionário.
					aSpec := aClone( fGetEspc( aColsOld[nPsCod] ) )

					aAdd( aUpdInp[2], Trim( aColsNew[nPsCod] ) ) 

				EndIf

				// Atribui especialidade ao array, permitindo calculos que consideram multiplas especialidade em um mesmo funcionário
				If Empty( aSpec )

					If aColsOld[nPsReg] == 'E'

						aSpec   := { { aColsOld[nPsCod], Posicione( 'ST0', 1, xFilial( 'ST0' ) + aColsOld[nPsCod],;
							'T0_NOME' ), fCountST2( aColsOld[nPsCod] ) } }

						aAdd( aUpdInp[1], Trim( aColsNew[nPsCod] ) ) 

					Else

						aSpec := { { '', STR0346, fCountST2( aColsOld[nPsCod] ) } } // SEM ESPECIALIDADE DEFINIDA

					EndIf

				EndIf

				For nIndex := 1 to Len( aSpec )

					If ( nPsLst := aScan( aList2, { |x| Trim( x[11] ) == Trim( aSpec[nIndex,1] ) } ) ) > 0

						aList2[nPsLst,8] := NToH( SubHoras( aList2[nPsLst,8], IIf( aColsOld[nPsQRe] > 1, MToH( HToM( cHours ) * aColsOld[nPsQRe] ), cHours ) ) )

						If HToN( aList2[nPsLst,8] ) <= 0

							// Remove insumo do aList.
							aDel( aList2, nPsLst )

							// Ajusta tamanho do aList.
							aSize( aList2, Len( aList2 ) - 1 )

						EndIf

					EndIf
				
				Next nIndex
			
			// Produto
			Case aColsOld[nPsReg] == 'P'

				aAdd( aUpdInp[3], Trim( aColsNew[nPsCod] ) ) 

				// Produtos
				If ( nPos := aScan( aList3, { |x| x[1] == M->TJ_ORDEM } ) ) > 0
					
					// Remove insumo do aList.
					aDel( aList3, nPos )

					// Ajusta tamanho do aList.
					aSize( aList3, Len( aList3 ) - 1 )

				EndIf

			Case aColsOld[nPsReg] == 'P'

				aAdd( aUpdInp[4], Trim( aColsNew[nPsCod] ) ) 

				If ( nPos := aScan( aList4, { |x| x[1] == M->TJ_ORDEM } ) ) > 0
			
					// Remove insumo do aList.
					aDel( aList4, nPos )

					// Ajusta tamanho do aList.
					aSize( aList4, Len( aList4 ) - 1 )

				EndIf

		End Case

	// Inclusão de Insumo
	Else

		Do Case

			Case aColsNew[nPsReg] == 'E'
				aAdd( aUpdInp[1], Trim( aColsNew[nPsCod] ) ) 

			Case aColsNew[nPsReg] == 'M'
				aAdd( aUpdInp[2], Trim( aColsNew[nPsCod] ) ) 

			Case aColsNew[nPsReg] == 'P'
				aAdd( aUpdInp[3], Trim( aColsNew[nPsCod] ) ) 

			Case aColsNew[nPsReg] == 'F'
				aAdd( aUpdInp[4], Trim( aColsNew[nPsCod] ) ) 

		End Case

	EndIf

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fDelOSProg
Realiza deleção dos registros de tabelas temporárias para o processo de reprogramação.
@type function

@author Alexandre Santos
@since 07/09/2021

@param  lZap, boolean, Indica se o processo de deleção será feito sem qualquer filtro,
assim deletando todos os registros das tabelas envolvidas.
@return
/*/
//------------------------------------------------------------------------------------
Static Function fDelOSProg( lZap )

	Local cQueryDel := ''
	
	/*--------------------------------------------------------+
	| Deleção dos registros de O.S. pendentes de programação. |
	+--------------------------------------------------------*/
	dbSelectArea( c990TRB1 )
	Zap

	/*---------------------------------------------------------------------+
	| Deleção de todos os registros de O.S. programadas e não programadas. |
	+---------------------------------------------------------------------*/
	If lZap

		/*----------------------------------------------+
		| Deleção dos registros de O.S. já programadas. |
		+----------------------------------------------*/
		dbSelectArea( c990TRB2 )
		Zap
		
		/*-------------------------------------------------------+
		| Deleção da cópia dos registros de O.S. já programadas. |
		+-------------------------------------------------------*/
		dbSelectArea( c990TRB3 )
		Zap
		
		/*-------------------------------------------------------------+
		| Deleção dos registros referente a insumos de especialidades. |
		+-------------------------------------------------------------*/
		dbSelectArea( c990TRBE )
		Zap

		/*----------------------------------------------------------+
		| Deleção dos registros referente a insumos de ferramentas. |
		+----------------------------------------------------------*/
		dbSelectArea( c990TRBF )
		Zap

		/*------------------------------------------------------+
		| Deleção dos registros referente a insumos de produto. |
		+------------------------------------------------------*/
		dbSelectArea( c990TRBB1 )
		Zap

		/*----------------------------------------------------------+
		| Deleção dos registros referente a insumos de mão de obra. |
		+----------------------------------------------------------*/
		dbSelectArea( c990TRBM )
		Zap
		
		/*-------------------------------+
		| Deleção dos insumos previstos. |
		+-------------------------------*/
		dbSelectArea( cTempStl )
		Zap
	
	/*------------------------------------------------------------------+
	| Deleção apenas dos registros relacionados a O.S. não programadas. |
	+------------------------------------------------------------------*/
	Else

		/*----------------------------------------------------------+
		| Deleção dos registros referente a insumos de ferramentas. |
		+----------------------------------------------------------*/
		cQueryDel := 'DELETE FROM ' + oARQT990F:GetRealName()
		cQueryDel += " WHERE ORDEM NOT IN ( SELECT ORDEM FROM " + oARQT9902:GetRealName() + " WHERE D_E_L_E_T_ <> '*' ) "

		TcSQLExec( cQueryDel )

		/*------------------------------------------------------+
		| Deleção dos registros referente a insumos de produto. |
		+------------------------------------------------------*/
		cQueryDel := 'DELETE FROM ' + oARQT990B1:GetRealName()
		cQueryDel += " WHERE ORDEM NOT IN ( SELECT ORDEM FROM " + oARQT9902:GetRealName() + " WHERE D_E_L_E_T_ <> '*' ) "

		TcSQLExec( cQueryDel )

		/*-------------------------------------------------------------+
		| Deleção dos registros referente a insumos de especialidades. |
		+-------------------------------------------------------------*/
		cQueryDel := 'DELETE FROM ' + oARQT990E:GetRealName()
		cQueryDel += " WHERE ORDEM NOT IN ( SELECT ORDEM FROM " + oARQT9902:GetRealName() + " WHERE D_E_L_E_T_ <> '*' ) "

		TcSQLExec( cQueryDel )

		/*----------------------------------------------------------+
		| Deleção dos registros referente a insumos de mão de obra. |
		+----------------------------------------------------------*/
		cQueryDel := 'DELETE FROM ' + oARQT990M:GetRealName()
		cQueryDel += " WHERE ORDEM NOT IN ( SELECT ORDEM FROM " + oARQT9902:GetRealName() + " WHERE D_E_L_E_T_ <> '*' ) "

		TcSQLExec( cQueryDel )

		/*-------------------------------+
		| Deleção dos insumos previstos. |
		+-------------------------------*/
		cQueryDel := "DELETE FROM " + oTmpSTL:GetRealName()
		cQueryDel += " WHERE TL_ORDEM NOT IN ( SELECT ORDEM FROM " + oARQT9902:GetRealName() + " WHERE D_E_L_E_T_ <> '*' ) "

		TcSQLExec( cQueryDel )
		
	EndIf

Return

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fDiffGetD
Valida se o insumo posicionado teve alteração.
@type function

@author Alexandre Santos
@since 22/09/2021

@param aGetOld , array  , aCols antes da confirmação da tela de insumos.
@param aGetNew , array  , aCols após a confirmação da tela de insumos.
@param nLine   , numeric, Linha em validação.
@return boolean, Indica se a linha validada sofreu alteração.
/*/
//------------------------------------------------------------------------------------
Static Function fDiffGetD( aGetOld, aGetNew, nLine )

	Local nColumn := 0
	Local lDiff   := .F. 

	For nColumn := 1 to Len( aGetNew[nLine] )

		If ( lDiff := aGetOld[nLine,nColumn] != aGetNew[nLine,nColumn] )
			Exit
		EndIf
		
	Next nColumn
	
Return lDiff

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fVldInsum
Valida insumo ao alterar data de uma O.S.
@type function

@author Alexandre Santos
@since 09/05/2022

@param cOrder, string, Número da O.S..
@param cPlan , string, Plano de manutenção.
@param dNewDt, date  , Nova data da O.S..
@param cError, string, Mensagem de erro, caso houver.

@return boolean, Indica se a alteração passou pela validação.
/*/
//------------------------------------------------------------------------------------
Static Function fVldInsum( cOrder, cPlan, dNewDt, cError )

	Local cAlsVld := GetNextAlias()
	Local cTblTL  := '%' + oTmpSTL:GetRealName() + '%'
	Local lRet    := .T.

	BeginSQL Alias cAlsVld

		SELECT
			TEMP.TL_CODIGO ,
			ST1.T1_NOME    ,
			TEMP.TL_HOINICI,
			TEMP.TL_ORDEM  ,
			TEMP.TL_PLANO
		FROM
			%exp:cTblTL% TEMP
		INNER JOIN
			%table:ST1% ST1 ON
				ST1.T1_FILIAL  = %xFilial:ST1%  AND
				ST1.T1_CODFUNC = TEMP.TL_CODIGO AND
				ST1.%NotDel%
		WHERE
			TEMP.TL_ORDEM = %exp:cOrder% AND
			TEMP.TL_PLANO = %exp:cPlan%  AND
			TEMP.TL_TIPOREG = 'M'        AND
			TEMP.TL_USACALE = 'S'        AND
			TEMP.STATUS <> 3 // Desconsidera status 3, que são registros excluidos.

	EndSQL

	While (cAlsVld)->( !EoF() )

		If NGDtHrCale( dNewDt, (cAlsVld)->TL_HOINICI, fGetCalen( (cAlsVld)->TL_CODIGO, dNewDt ) )[1] != dNewDt

			cError += STR0332 + (cAlsVld)->TL_ORDEM + CRLF +; // Ordem de Serviço: 
				STR0333 + (cAlsVld)->TL_PLANO  + CRLF +; // Plano de Manutenção:
				STR0336 + Trim( (cAlsVld)->TL_CODIGO ) + ' - ' +; // Código:
				Trim( (cAlsVld)->T1_NOME ) + CRLF + CRLF
						
			lRet := .F.
			Exit

		EndIf

		(cAlsVld)->( dbSkip() )

	End

	(cAlsVld)->( dbCloseArea() )
	
Return lRet

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fSaldoRM
Atualiza saldo quando integrado ao RM.
@type function

@author Alexandre Santos
@since 08/05/2025

@param 
@return
/*/
//------------------------------------------------------------------------------------
Static Function fSaldoRM()

	Local aPrdAtu := {}
	Local cUpdSld := ''
	Local nQtdFis := 0
	Local nPosSld := 0
	Local nInd1   := 0

	For nInd1 := 1 To Len( aList3 )

		If ( nPosSld := aScan( aPrdAtu, { |x| x[1] == aList3[nInd1,2] } ) ) == 0

			dbSelectArea( 'SB1' )
			dbSetOrder( 1 ) // B1_FILIAL + B1_COD
			msSeek( FWxFilial( 'SB1' ) + aList3[nInd1,2] )

			dbSelectArea( 'SB2' )
			dbSetOrder( 1 ) // B2_FILIAL + B2_COD + B2_LOCAL
			msSeek( FWxFilial( 'SB2' ) + SB1->B1_COD + SB1->B1_LOCPAD )

			nQtdFis := NGMUStoLvl( SB1->B1_COD, SB1->B1_LOCPAD, .T. )

			aList3[nInd1,5] := nQtdFis
			aList3[nInd1,6] := nQtdFis + SB2->B2_SALPEDI + SB2->B2_QACLASS - SB2->B2_QEMPN + AvalQtdPre( 'SB2', 2 )

			cUpdSld := " UPDATE "
			cUpdSld += 		oARQT990B1:GetRealName()
			cUpdSld += " SET "
			cUpdSld += 		"QTDFIS = " + ValToSQL( aList3[nInd1,5] ) + ", "
			cUpdSld += 		"QTDEST = " + ValToSQL( aList3[nInd1,6] )
			cUpdSld += " WHERE "
			cUpdSld +=		"CODIGO = " + ValToSQL( SB1->B1_COD ) + " AND "
			cUpdSld += 		"D_E_L_E_T_ = ' '"
			
			TCSQLExec( cUpdSld )

			aAdd( aPrdAtu, { SB1->B1_COD, aList3[nInd1,5], aList3[nInd1,6] } )
		
		Else

			aList3[nInd1,5] := aPrdAtu[nPosSld,2]
			aList3[nInd1,6] := aPrdAtu[nPosSld,3]

		EndIf
		
	Next nInd1

	FWFreeArray( aPrdAtu )

Return 

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fIncOSRep
Incrementa o campo TJ_QTDREP para todas as OSs reprogramadas.
@type function

@author Cauê Girardi Petri
@since 11/08/2025

@param aOSRepro, array, array com as OSs reprogramadas
@return
/*/
//------------------------------------------------------------------------------------
Function fIncOSRep( aOSRepro )

	Local nI := 0

	For nI := 1 To Len(aOSRepro)

		dbSelectArea("STJ")
		dbSetOrder(1)
		If MsSeek(FwxFilial("STJ") + aOSRepro[nI,1] + aOSRepro[nI,2])

			RecLock("STJ", .F.)
			
				STJ->TJ_QTDREP ++

			STJ->(MsUnLock())

		EndIf

	Next nI

Return
