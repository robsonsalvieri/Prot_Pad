#INCLUDE "mnta435.ch"
#INCLUDE "Protheus.ch"
#INCLUDE "FONT.CH"
#INCLUDE "COLORS.CH"

#define _OCCURRENCES_ 10

#define _LEGENDAOCOR_ 1
#define _INSUMOCORRE_ 11

static cQryGrvSTN
static cQryInsAss
static cQryPerStl

Static oTmpTblOS 

Static cMVPAR01   := '' // Váriavel utilizada para controle do filtro de etapas não executadas da O.S.
Static lPEMNTA435 := ExistBlock( "MNTA435N" )
Static lHasMNTREQ := !Empty( SuperGetMV( 'MV_MNTREQ', .F., '' ) ) // Param. utilizado para realizar requisições ao estoque.
Static cQuerySTL

//-------------------------------------------------------------------
/*/{Protheus.doc} MNTA435
Retorno de O.S. Modelo 2

VERSAO 2
-Reporte por Tarefa ou Tarefa/Etapa
-facilitar busca por OS
-melhor opcoes da etapa

@author  Denis Hyroshi de Souza
@since   23/06/2008
@version P12
@param strChave, caracter, Chave de Pesquisa
@param numIndice, numérico, Indice do STJ
/*/
//-------------------------------------------------------------------
Function MNTA435(strChave,numIndice)

	// Guarda conteudo e declara variaveis padroes
	Local aNGBEGINPRM := NGBEGINPRM(,,,,.T.)

	// Declaracao das Variaveis dos componentes
	Local nControl  := 0
	Local aPages    := {}
	Local aTitles   := {}
	Local aDadosInd := fMontInd("STJ")
	Local lRetTela  := .F.
	Local lRetTmp   := .F.
	Local nLinGet   := 3000
	Local aPesq     := {}
	Local aFieldFil := {}

	// Utilizado na tabela temporaria responsável por montar o Browse das O.S.'s
	Local aFields   := {}

	Local oPnlOcr
	Local oPnlOcrGD1
	Local oPnlOcrBtn
	Local oPnlOcrGD2
	Local oPnlOcrTit
	Local oPnlOcrTi1
	Local oPnlOcrTi2

	// Utilizado para validar quando o Browse principial for filtrado
	Private lClearData    := .F.

	Private lArvoreLogica := ( ValType( StrChave ) == "C" .And. ValType( numIndice ) == "N" )
	Private cChave435     := Space(255)

	SetKey( VK_F5 , { || MntF5Saldo() } )
	SetKey( VK_F10, { || MNT435RLOC( 1 ) } )
	SetKey( VK_F11, { || MNT435RLOC( 2 ) } )
	SetKey( VK_F12, { || fPerg435() } )

	Private oOrdem
	Private oBtnBuscar
	Private oFolder435
	Private aOrdIx435    := aDadosInd[2]
	Private aBlockInd    := {}
	Private cPrograma    := "MNTA400"
	Private oOk          := LoadBitmap( GetResources(), "ENABLE" )
	Private oVerde       := LoadBitmap( GetResources(), "br_verde" )
	Private oRed         := LoadBitmap( GetResources(), "br_vermelho" )
	Private oLaranja     := LoadBitmap( GetResources(), "br_laranja" )
	Private oAzul        := LoadBitmap( GetResources(), "br_azul" )
	Private oBranco      := LoadBitmap( GetResources(), "LBNO" )
	Private oChecked     := LoadBitmap( GetResources(), "LBOK" )
	Private aSize	     := MsAdvSize(,.F.,420), aObjects := {}
	Private cMarca       := 'XX'
	Private lFoiAlterado := .F.
	Private lCamposSA	 := If(STJ->(FieldPos("TL_NUMSA")) > 0 .And. STJ->(FieldPos("TL_ITEMSA")) > 0, .T., .F.)
	Private Inclui		 := .T.
	Private Altera		 := .T.
	Private lFocusBrw3	 := .F.
	Private aCoBrw2		 := {}
	Private aCoBrw3		 := {}
	Private aCoBrw3_2    := {}
	Private aCoBrw3_3    := {}
	Private aBrw3Old     := {}
	Private aCoBrw4		 := {}
	Private aCoBrw6		 := {}
	Private aCols        := {}
	Private aHoBrw2      := {}
	Private aHoBrw3      := {}
	Private aHoBrw3_2    := {}
	Private aHoBrw3_3    := {}
	Private aHoBrw4      := {}
	Private aHoBrw6      := {}
	Private aHeaExec     := {}
	Private aHeader      := {}
	Private aInsSub      := {}
	Private aCores2      := {}
	Private aTRBK        := {}
	Private aCores       := {} // Cores dos Insumos previstos
	Private noBrw2       := 0
	Private noBrw3       := 0
	Private noBrw4       := 0

	// Flags
	Private lRet435	:= .T. // Flag para indicar se grava os dados ou nao

	// Tamanho de Campos
	Private nLenST1	:= If( Len(ST1->T1_CODFUNC) > 0, Len(ST1->T1_CODFUNC), 6)

	// Tabelas Temporarias
	Private aVETINR := {}
	Private oTmpTbl1
	Private oTmpTbl2
	Private oTmpTbl3
	Private oTmpTbl4
	Private oTmpTbl5
	Private oTmpTbl6
	Private oTmpTbl7
	Private oTmpTbl8
	Private oTmpTbl9

	// Dados Temporarios
	Private aNewSC     := {} // Utilizado no processo de produto alternativo
	Private aOS        := {} // OS do browse principal
	Private aDadosOS   := {} // Espelho do aOS, com dados de insumos, etapas, etc...
	Private aDadosTPZ  := {} // Garantia de Insumos Temporario
	Private aDadosSA   := {} // Registros de S.A.
	Private aVetorCan  := {} // OS canceladas
	Private aVetorFin  := {} // OS finalizadas
	Private aProd435   := {} // PRODUTOS atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	Private aLote435   := {} // LOTE atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	Private aSubL435   := {} // SUB-LOTE atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	Private aEnde435   := {} // ENDERECAMENTO atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	Private aNovoSTL   := Nil
	Private aNovoExec  := {}
	Private aNovaOcor  := {}
	Private aTRBQ      := {} // Layout TRB Etapas
	Private aTRBIP     := {} // Layout TRB Insumos Previstos
	Private aEstruAss  := {} // Estrutura da tabela de insumos para associação
	Private aNgBtn     := {}
	Private cOrdemTJ   := Space( Len( STJ->TJ_ORDEM ))
	Private cPlanoTJ   := Space( Len( STJ->TJ_PLANO ))
	Private cCdBemTJ   := Space( Len( STJ->TJ_CODBEM ))
	Private nPosOS	   := 2 // Posição do campo TJ_ORDEM no browse
	Private nPosPL	   := 3 // Posição do campo TJ_PLANO no browse
	Private cFiltSTJ   := "" // Filtro do browse STJ
	Private lChkEtaAnt := .T.
	Private lIsStack   := .F.

	// Variaveis Utilizadas para o Botao de Conhecimento
	Private cCadastro  := Oemtoansi(STR0001) // "Retorno de Ordem de Serviço"
	Private cCadTemp   := cCadastro
	Private bSalvar	   := {|| FWMsgRun( , {|| If(fValidOK(@lRetTmp,.T.),Processa({|| fGrava435(,.T.) } , STR0002 ),lRetTmp := .F.) }, STR0402, STR0417 ) } // "Gravando as informações"  ## Aguarde ## Validando informações

	// Variaveis de campo
	Private M->TJ_ORDEM   := cOrdemTJ
	Private M->TJ_PLANO   := cPlanoTJ
	Private M->TJ_CODBEM  := cCdBemTJ
	Private M->TL_TIPOREG := " "
	Private M->TL_DESTINO := " "
	Private M->TL_CODIGO  := Space(Len(stl->tl_codigo))
	Private M->TL_UNIDADE := Space(03)
	Private M->TL_LOCAL   := "  "
	Private M->TL_DTINICI := StoD("")
	Private M->TL_HOINICI := Space(5)
	Private M->TL_DTFIM   := StoD("")
	Private M->TL_HOFIM   := Space(5)
	Private M->TL_QUANTID := 0
	Private M->TL_NUMLOTE := Space(6)
	Private M->TL_LOTECTL := Space(10)
	Private M->TL_LOCALIZ := Space(15)
	Private M->TL_NUMSERI := Space(20)
	Private M->TL_GARANTI := Space(1)
	Private M->TL_TAREFA  := "0     "
	Private M->TL_USACALE := "N"
	Private M->TL_SEQRELA := "0  "

	// Parametros
	Private aARTAR     := {}
	Private lRETORNO   := .F.
	Private cLocaliz   := Space(Len(TPS->TPS_CODLOC))  // Codigo de Localizacao
	Private lNumSeq2   := NGCADICBASE("TL_NUMSEQ2","A","STL",.F.)
	Private aTROCAF3   := {}
	Private cUSAINT1   := AllTrim( GETMv( "MV_NGMNTPC" )) // Integração PCP
	Private cUsaInt2   := AllTrim( GetMv( "MV_NGMNTCM" )) // Integração Compras
	Private cUsaInt3   := AllTrim( GetMv( "MV_NGMNTES" )) // Integração Estoque
	Private cUIntHis   := AllTrim( GetMv( "MV_NGHISES" ))
	Private cUsaGeRe   := " "
	Private lESTNEGA   := If(AllTrim(GETMV("MV_ESTNEG")) == "S",.T.,.F.)
	Private cTENDFLAHA := AllTrim(GETMv("MV_NGTNDFL"))
	Private cGERAPREV  := AllTrim(GETMv("MV_NGGERPR"))
	Private lCUSTO     := If(cUsaInt3 == "N",.T.,.F.)
	Private cVALPECRE  := AllTrim(GETMv("MV_NGCOQPR"))
	Private cParSX6Ret := SuperGetMv("MV_NGREPRE",.F.," ")
	Private cRet400    := SuperGetMv("MV_NGUSUAL",.F.," ")
	Private dDtUlMes   := SuperGetMv('MV_ULMES', .F., " " )
	Private oMenu
	Private cNGINSPREA := "R" // Indica se o insumo e realizado ou previsto, nao deve ser retirado
	Private lOrPai435  := .F. // Indica se apresenta indices de Ordem e Bem Pai
	Private lIntSFC    := FindFunction("NGINTSFC") .And. NGINTSFC() // Verifica se ha integracao com modulo Chao de Fabrica [SIGASFC]
	Private lMMoeda    := NGCADICBASE("TL_MOEDA","A","STL",.F.) // Multi-Moeda

	// Declaracao das Variaveis dos Objetos
	Private lStartVar := .F.
	Private oDlg1
	Private oSay1
	Private oSay2
	Private oSay3
	Private oGet1
	Private oBrw1
	Private oBtn1
	Private oBtn2
	Private oBtn3
	Private oBtn4
	private oBtn5
	Private oChv435
	Private oBrw2
	Private oGrp2
	Private oGd435Ocr
	Private oGd435Ass
	Private oGrp3
	private oBrw4
	Private oBrw5
	Private oBrw6
	Private oBrw7
	Private oGrp4
	Private oGrp5
	Private oSay4
	Private oSay5
	Private oSay6
	Private oSay7
	Private oSay8
	Private oSay9
	Private oGet3
	Private oGet4
	Private oGet5
	Private oGet6
	Private oGet7

	Private bOSLine1
	Private oFont1	  := TFont():New( "Arial",0,-19,,.F.,0,,400,.F.,.F.,,,,,, )
	Private oFont2	  := TFont():New( "Arial",0,-13,,.F.,0,,400,.F.,.F.,,,,,, )
	Private oFont3	  := TFont():New( "Arial",0,-11,,.T.,0,,400,.F.,.F.,,,,,, )
	Private lCORRET	  := .T. // Indica que a OS é corretiva
	Private nControGD := 0   // Variavel para controle da ultima GETDADOS editada devido ao problema de que quando se esta editando a getdados
	// e depois clica direto no OK nao e executado o CODBLOCK de LOSTFOCUS da GETDADOS.

	// Variaveis de Posicionamento  Objetos
	Private nTipoVert
	Private nTipoHorz
	Private nPorcVert
	Private nPorcHorz
	Private nFolIniI
	Private nFolColI
	Private nFolLarg
	Private nFolAltu
	Private nBOSIniI
	Private nBOSColI
	Private nBOSLarg
	Private nBOSAltu
	Private nIPrIniI
	Private nIPrColI
	Private nIPrLarg
	Private nIPrAltu
	Private nFO1IniI
	Private nFO1ColI
	Private nFO1Larg
	Private nFO1Altu
	Private nFO2IniI
	Private nFO2ColI
	Private nFO2Larg
	Private nFO2Altu
	private nFO3IniI
	Private nFO3ColI
	Private nFO3Larg
	Private nFO3Altu
	Private nFO4IniI
	Private nFO4ColI
	Private nFO4Larg
	Private nFO4Altu
	Private nBtCeLin
	Private nBtCeCol
	Private nBtEtLin
	Private nBtEtCol
	Private nSalBtn
	Private nLaToLin
	Private nLaToCol
	Private nBtDista
	Private nFZ2ColI
	Private nFZ2Larg
	Private nTamBotao

	Private lPendInput := .T.
	Private lPartInput := .T.
	Private lTotInput := .T.

	// Variaveis para Ponto de Entrada
	Private aInsNaoGra := {}	//Utilizada no Ponto de Entrada MNTA4353 e MNTA4354
	Private aNBaixaEst := {}	//Ponto de Entrada MNT4356 - Variável para bloqueio de movimentação do estoque
	Private lVldExcG   := .T.	//Flag utilizada em P.E. para que a validação da exclusao do insumo não seja executado duas vezes.
	Private cCodFunc   := ""	//De acordo com a utilização do Ponto de Entrada MNTA435G para gravação do código do funcionário padrão
	Private nIndStq435 := 3  // Índice utilizado para ordenação de etapas

	//Botões da Barra de botões a ser declarado na funcao MNTA435BAR
	Private oBtCalc
	Private oBtSpl
	Private oBtAjd
	Private oBtVsl
	Private oBtImp
	Private oBtRdz
	private oBtRto
	Private oBtCOS
	Private oBtFOS
	Private oBtLgd
	Private oBtBCn
	Private oBtGrv
	Private oBtPEt
	Private oBtRMR
	Private oBtOK
	Private oBtCan
	Private oBtBus

	//Otimização da tela principal
	Private oPanelPrin
	Private oPanelUP1
	Private oPanelUP2
	Private oPanelUP3
	Private oPanelUP31
	Private oPanelUP32
	Private oPanelUP33
	Private oPnlUP34
	Private oPnlUP342
	Private oPnlUP343
	Private oPanelUP4
	Private oPanelUP41
	Private oPanelUP42
	Private oPanelUP43
	Private oPanelUP44
	Private oPnlUP442
	Private oPnlUP443
	Private oPnlUP4431
	Private oPanelUP6
	Private oPnlInput
	Private oPending
	Private oPartially
	Private oTotally

	Private lIntRM := AllTrim(GetNewPar("MV_NGINTER","N")) == "M"

	/*----------------------------------------------------------------+
	| Valor padrão das perguntas de parametrização da rotina MNTA435. |
	+----------------------------------------------------------------*/
	Pergunte( 'MNT435', .F. )

	/*--------------------------------------------------+
	| Atribuição da váriavel de controle das perguntas. |
	+--------------------------------------------------*/
	cMVPAR01 := cValToChar( MV_PAR01 )

	If ExistBlock( "MNTA4357" )
		MsgInfo( STR0386, STR0037 ) // "Foi identificada a existência do Ponto de Entrada MNTA4357 compilado neste ambiente."
									// "Informamos que este ponto de entrada foi descontinuado.
									// Para validações adicionais utilize o PE MNTA435N."
	EndIf

	If ExistBlock( 'MNTA4006' )
		MsgInfo( STR0403, STR0037 ) // Foi identificada a existência do Ponto de Entrada MNTA4006 compilado neste ambiente.
									// Informamos que este ponto de entrada foi descontinuado.
									// Para validações adicionais utilize o Ponto de Entrada MNTA400O."
	EndIf

	If ExistBlock( 'MNTA435H' )
		MsgInfo( STR0404, STR0037 ) // Foi identificada a existência do Ponto de Entrada MNTA435H compilado neste ambiente.
									// Informamos que este ponto de entrada foi descontinuado.
									// Para validações adicionais utilize o Ponto de Entrada MNTA435Q."
	EndIf

	If !NGCADICBASE("TB0_FILORD","A","TB0",.F.) .And. NGFUNCRPO("SgaMntEst",.F.) .And. GetMv("MV_SGAMNT") == "S" .And. GetMv("MV_NGSGAES") <> "N"
		If !NGINCOMPDIC("UPDSGA01","00000015391/2010")
			Return
		EndIf
	EndIf

	If !AMiIN(19,56) //Somente autorizado para o MNT/SGA
		Return
	EndIf

	// Declaracao das Variaveis de dimensionamento de tela
	aAdd(aObjects,{050,050,.T.,.T.})
	aAdd(aObjects,{100,100,.T.,.F.})
	aAdd(aObjects,{100,100,.T.,.F.})

	aInfo := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
	aPosObj := MsObjSize(aInfo, aObjects,.T.)

	// Cores dos insumos previstos
	aAdd(aCores,{"(cTRBIP)->STATUS == '0'","BR_VERMELHO"  })
	aAdd(aCores,{"(cTRBIP)->STATUS == '1'","BR_LARANJA"})
	aAdd(aCores,{"(cTRBIP)->STATUS == '2'","BR_VERDE"   })

	// Alias Tabelas Temporárias
	Private cTRBZ400  := GetNextAlias()
	Private cTRBK400  := GetNextAlias()
	Private cTRBQ400  := GetNextAlias()
	Private cTRBTAR	  := GetNextAlias()
	Private cTRB3400  := GetNextAlias()
	Private cTRBIP	  := GetNextAlias()
	Private cAliOS435 := GetNextAlias()
	Private cAlsExecu := GetNextAlias()
	Private cAlsAssoc := GetNextAlias()
	Private cAlsOcor  := GetNextAlias()

	// Define posicionamento dos objetos
	fPosObjet()

	// Carrega os campos definidos para serem apresentados em tela
	LoadFldSTJ( @aFields )

	// Cabecalho e linha vazia para Motivo Atraso
	aHoBrw4 := NGHeader("TPL", {"TPL_FILIAL","TPL_ORDEM"}, .F. )

	nPosDtF := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_DTFIM" })

	aCoBrw4 := BLANKGETD(aHoBrw4)

	/*------------------------------------+
	| Centraliza montagem dos cabeçalhos. |
	+------------------------------------*/
	fCriaGetD()

	If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0

		/*-----------------------------------------------------+
		| Monta estrutura da tabela temporária de ocorrências. |
		+-----------------------------------------------------*/
		fTrbOcorr()

	EndIf

	// Monta Arq para Insumos
	PutFileInEof("STL")
	fTrbInsPre()

	// Monta Arq para Etapas da OS
	fTrbEtapa()

	Private nTpRg435 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})

	// Variáveis do F3 de Ocorrências (Cauxa X Problema X Solução)
	Private aHeaderSTN := {}

	If aScan( aHeader, { |x| Trim( Upper( x[2] ) ) == "TN_CODOCOR" } ) > 0
		aHeaderSTN := aHeader
	Else
		aHeaderSTN := aHoBrw3
	EndIf

	// Variáveis do F3 de Ocorrências (Cauxa X Problema X Solução)
	Private nCodOcor := aScan( aHeaderSTN, { |x| Trim( Upper( x[2] ) ) == "TN_CODOCOR" })

	// Criação da Tela Principal
	DEFINE MSDIALOG oDlg1 Title OemToAnsi(cCadastro) From aSize[7],0 To aSize[6],aSize[5] Of oMainWnd COLOR CLR_BLACK,CLR_WHITE Pixel
	oDlg1:lMaximized := .T.

	// Monta Tela Principal
	oPanelPrin := TPanel():New(aSize[6],aSize[5],,oDlg1,,,,,,10,10,.F.,.F.)
		oPanelPrin:Align := CONTROL_ALIGN_ALLCLIENT

	// Monta Parte Superior - Tela dividida em duas (superior e inferior)
	oPanelUP1 := TPanel():New(0,0,,oPanelPrin,,,,,,10,10,.F.,.F.)
		oPanelUP1:nHeight := (aSize[6]/1.1)
		oPanelUP1:nWidth := (aSize[5]/2)
		oPanelUP1:Align := CONTROL_ALIGN_ALLCLIENT

	// Monta Parte Inferior - Tela dividida em duas (superior e inferior)
	oPanelUP2 := TPanel():New(0,0,,oPanelPrin,,,,,,10,10,.F.,.F.)
		oPanelUP2:nHeight := (aSize[6]/2.37)
		oPanelUP2:nWidth := (aSize[5]/2)
		oPanelUP2:Align := CONTROL_ALIGN_BOTTOM

	If lArvoreLogica //Se Chamada for pela arvore logica não poderá filtrar/buscar
		oDlg1:LESCCLOSE := .F.
	EndIf

	// Cria tabela temporária
	fCriaTRB( cAliOS435, aFields, @aPesq, @aFieldFil )

	// Carrega tabela temporária com as O.S.
	fLoadBrw( .F., aFields, .F., strChave )

	// Objetos para criação das colunas do Browse.
	aColumns	:= fGerCol(aFields)

	//----------------------------------
	// Criação do Browse
	//----------------------------------
	oBrwOS := FWFormBrowse():New()
	oBrwOS:SetOwner( oPanelUP1 )
	Legend435( oBrwOS )
	oBrwOS:SetDataTable(.T.)
	oBrwOS:SetAlias( cAliOS435 )//Define alias de utilizacao
	oBrwOS:SetTemporary(.T.)
	oBrwOS:SetColumns( aColumns )
	oBrwOS:SetUseFilter(.T.)
	oBrwOS:DisableDetails(.T.)
	oBrwOS:SetProfileID('A435')
	oBrwOS:DisableReport()//Desabilita Impressão
	oBrwOS:SetInsert( .F. )
	oBrwOS:SetEditCell( .F. )
	oBrwOS:SetChange( {|| FWMsgRun( , { | | fRefreshOS( (cAliOS435)->TJ_ORDEM, (cAliOS435)->TJ_PLANO, 1 ) }, STR0402, STR0416 ) } ) // Aguarde ## Carregando informações adicionais
	oBrwOS:SetSeek(, aPesq )
	oBrwOS:SetLineHeight( 10 )     // seta altura da linha
	oBrwOS:SetFieldFilter( aFieldFil ) // Responsável por apresentar a descrição dos campos na função de filtros do componente
	oBrwOS:Activate()

	// Montagem dos FOLDERS
	aTitles  := {STR0087,STR0017,STR0018,STR0019} // "Insumos"###"Etapas"###"Ocorrências"###"Motivo de Atraso"
	aPages   := {"HEADER 1","HEADER 2","HEADER 3","HEADER 4"}
	nControl := 4

	oFolder435 := TFolder():New( 0, 0, aTitles, aPages, oPanelUP2, , , , .F., .F., 0 , 0 )
	oFolder435:bChange := {|| fChgFolder() }

	oFolder435:Align := CONTROL_ALIGN_ALLCLIENT
	// Folder de Insumos
	oFolder435:aDialogs[1]:oFont := oPanelUP2:oFont
	// Folder de Etapas
	oFolder435:aDialogs[2]:oFont := oPanelUP2:oFont
	// Folder de Ocorrências
	oFolder435:aDialogs[3]:oFont := oPanelUP2:oFont
	// Folder de Motivo de Atraso
	oFolder435:aDialogs[4]:oFont := oPanelUP2:oFont

	// Folder 1 - Insumos
	oPanelUP3 := TPanel():New(0,0,,oFolder435:aDialogs[1],,,,,,10,10,.F.,.F.)
		oPanelUP3:Align := CONTROL_ALIGN_ALLCLIENT
		oPanelUP3:nWidth := (aSize[5]/2)

	// Folder 1 - Parte 1 Insumos previstos (Dividida em três, insumos previstos/botões/realizados)
	oPanelUP31 := TPanel():New(0,0,,oPanelUP3,,,,,,10,10,.F.,.F.)
		oPanelUP31:Align := CONTROL_ALIGN_LEFT
		oPanelUP31:nWidth := (aSize[5]/2.15)

	// Folder 1 - Parte 2 Botões (Dividida em três, insumos previstos/realizados/botões)
	oPanelUP32 := TPanel():New(0,0,,oPanelUP3,,,,,,10,10,.F.,.F.)
		oPanelUP32:Align := CONTROL_ALIGN_ALLCLIENT
		oPanelUP32:nWidth := (aSize[5]/12)

	// Contorno Folder 1 - Parte 2 Botões
	oGrp2 := TGroup():New( 0, 0, 0, 0,,oPanelUP32,,,.T.,.F. )
		oGrp2:Align := CONTROL_ALIGN_ALLCLIENT

	// Folder 1 - Parte 3 Insumos Realizados (Dividida em três, insumos previstos/botões/realizados)
	oPanelUP33 := TPanel():New(0,0,,oPanelUP3,,,,,,10,10,.F.,.F.)
		oPanelUP33:Align := CONTROL_ALIGN_RIGHT
		oPanelUP33:nWidth := (aSize[5]/2.15)

	// Folder 1 - Parte 4 Superior (Descrição dos insumos)
	oPnlUP34 := TPanel():New(0,0,,oPanelUP3,,,,,,10,10,.F.,.F.)
		oPnlUP34:Align := CONTROL_ALIGN_TOP
		oPnlUP34:nHeight := (aSize[6]/26)
		oPnlUP34:nWidth := aSize[5]

	// Folder 1 - Parte 4 Superior (Insumos Previstos)
	oPnlUP342 := TPanel():New(0,0,STR0008,oPnlUP34,,,,,,10,10,.F.,.F.) // "Insumos Previstos"
		oPnlUP342:Align := CONTROL_ALIGN_LEFT
		oPnlUP342:nWidth := (aSize[5]/12)

	// Painel com os Checkbox de aplicação de insumos
	oPnlInput := TPanel():New(01, 10,, oPnlUP34,,,,,, 0, 80, .F., .F.)
	oPnlInput:Align := CONTROL_ALIGN_LEFT
	oPnlInput:nWidth := (oPnlUP34:nWidth / 2) - oPnlUP342:nWidth
	oPnlInput:Disable()

	TSay():New(02, 00, {|| STR0267 + ":"}, oPnlInput,,,,,, .T.) // "Exibir:"

	oPending := TCheckBox():New(02, 20, STR0353,, oPnlInput, 60, 7,,,,,,,, .T.,,,) // "Não aplicado"
	oPending:bSetGet   := {|u| If(PCount() == 0 , lPendInput , lPendInput := u)}
	oPending:bLClicked := {|u| fUpdInput()}

	oPartially := TCheckBox():New(02, 70, STR0354,, oPnlInput, 70, 7,,,,,,,, .T.,,,) // "Parcialmente Aplicado"
	oPartially:bSetGet   := {|u| If(PCount() == 0 , lPartInput , lPartInput := u)}
	oPartially:bLClicked := {|u| fUpdInput()}

	oTotally := TCheckBox():New(02, 143, STR0355,, oPnlInput, 60, 7,,,,,,,, .T.,,,) // "Totalmente aplicado"
	oTotally:bSetGet   := {|u| If(PCount() == 0 , lTotInput , lTotInput := u)}
	oTotally:bLClicked := {|u| fUpdInput()}

	//Folder 1 - Parte 4 Superior (Insumos Realizados)
	oPnlUP343 := TPanel():New(0,0,STR0009,oPnlUP34,,,,,,10,10,.F.,.F.) //"Insumos Realizados"
		oPnlUP343:Align := CONTROL_ALIGN_RIGHT
		oPnlUP343:nWidth := (aSize[5]/2.15)

	// Montagem dos Insumos previstos e realizados.

	// Insumos Previstos da Ordem de Servico
	oGrp1:= TGroup():New( 0, 0, 0, 0, STR0008,oPanelUP31,,,.T.,.F. ) //"Insumos Previstos"
	oGrp1:Align := CONTROL_ALIGN_ALLCLIENT
	oBrw2:= MsSelect():New( (cTRBIP),"TL_OK","",aTRBIP,.F.,@cMARCA,{0, 0, 0, 0},,, oPanelUP31,, aCores)
	oBrw2:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oBrw2:bMark              := {|| MNT435SEL()}
	oBrw2:oBrowse:bAllMark	 := {|| MNT435ALL() }
	oBrw2:oBrowse:bGotFocus	 := {|| SetKey(VK_F4,{|| MntViewSB2((cTRBIP)->TL_TIPOREG, (cTRBIP)->TL_CODIGO ) })}
	oBrw2:oBrowse:bLostFocus := {|| SETKEY( VK_F4,Nil)}
	oBrw2:oBrowse:Disable()

	// Indice para listar os insumos por ordem de aplicação
	IndRegua((cTRBIP),CriaTrab(Nil, .F.),"STATUS",,.F.)

	// Insumos Realizados da Ordem de Servico
	dbSelectArea("STL")
	oGrp5 := TGroup():New( 0, 0, 0, 0, STR0009,oPanelUP33,,,.T.,.F. ) //"Insumos Realizados"
	oGrp5:Align := CONTROL_ALIGN_ALLCLIENT
	aCols := aClone(aCoBrw6)

	nTipR := aScan(aHoBrw6,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	cVal3 := x3valid("TL_TIPOREG")

	aHoBrw6[nTipR,6] := StrTran( cVal3, 'NGCLEARSTL()', 'fValDel435(.T.) .And. NGCLEARSTL()' )

	nNumS   := aScan(aHoBrw6,{|x| Trim(Upper(x[2])) == "TL_NUMSEQ"})
	aHeader := aClone(aHoBrw6)
	
	oBrw6 := MsNewGetDados():New( 0, 0, 0, 0, GD_INSERT + GD_UPDATE + GD_DELETE, 'LinOkTL435()', , , , ,;
		nLinGet, 'fValDel435( .T. )', , 'MNT435DelOk()', oPanelUP33, aHoBrw6, aCoBrw6 )

	oBrw6:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oBrw6:oBrowse:lDisablePaint := .T.
	oBrw6:oBrowse:bGotFocus     := {|| Fd_Entra(1)}
	oBrw6:oBrowse:bLostFocus    := {|| Fd_Sai( 1 )}
	oBrw6:oBrowse:bChange       := { || fLoadSTL() }
	oBrw6:oBrowse:Disable()
	oBrw6:oBrowse:Default()
	oBrw6:oBrowse:Refresh()

	// Botoes para transformar o insumo previsto em realizado
	@ 001, 15 BTNBMP oBtAllNext Resource "NG_ICO_RETORNO02" Size 34,34 Pixel Of oPanelUP32 Noborder Pixel Action MNT435CALLB( 1 ) // fPrgNext(@oChv435)
	@ 041, 15 BTNBMP oBtNext    Resource "NG_ICO_RETORNO01" Size 34,34 Pixel Of oPanelUP32 Noborder Pixel Action MNT435CALLB( 2 ) // f435Next(@oChv435)
	@ 081, 15 BTNBMP oBtPrev    Resource "NG_ICO_RETORNO04" Size 34,34 Pixel Of oPanelUP32 Noborder Pixel Action MNT435CALLB( 3 )
	@ 121, 15 BTNBMP oBtAllPrev Resource "NG_ICO_RETORNO03" Size 34,34 Pixel Of oPanelUP32 Noborder Pixel Action MNT435CALLB( 4 )
	@ 201, 15 BTNBMP oBtFilIns  Resource "FILTRO" 		  	Size 32,32 Pixel Of oPanelUP32 Noborder Pixel Action fFiltroS()
	@ 241, 15 BTNBMP oBtGeraSA  Resource "SOLICITA" 		Size 34,34 Pixel Of oPanelUP32 Noborder Pixel Action Processa({|lEND| fGerarSA()},STR0010) //"Gerando Solicitação ao Armazém..."

	oBtAllNext:cToolTip		:= STR0011 // "Incluir todos os insumos previstos"
	oBtAllNext:lCanGotFocus	:= .T.     // Força a perda do focus
	oBtNext:cToolTip		:= STR0012 // "Incluir o insumo previsto"
	oBtNext:lCanGotFocus	:= .T.     // Força a perda do focus
	oBtPrev:cToolTip		:= STR0013 // "Excluir o insumo realizado"
	oBtAllPrev:cToolTip		:= STR0014 // "Excluir todos os insumos realizados"
	oBtFilIns:cToolTip		:= STR0015 // "Filtro por tarefa para os insumos previstos e etapas da ordem de serviço"
	oBtGeraSA:cToolTip		:= STR0016 // "Gerar SA (Solicitação ao Armazém) para os itens selecionados"

	If ExistBlock( "MNTA435C" )
		oBtAllNext:Hide()
		oBtNext:Hide()
		oBtPrev:Hide()
		oBtAllPrev:Hide()
		oBtFilIns:Hide()
		oBtGeraSA:Hide()
	Else
		oBtAllNext:Disable()
		oBtNext:Disable()
		oBtPrev:Disable()
		oBtAllPrev:Disable()
		oBtFilIns:Hide()
		oBtGeraSA:Hide()
	EndIf

	// Folder 2
	oPanelUP4 := TPanel():New(0,0,,oFolder435:aDialogs[2],,,,,,10,10,.F.,.F.)
		oPanelUP4:Align := CONTROL_ALIGN_ALLCLIENT
		oPanelUP4:nWidth := (aSize[5]/2)

	// Folder 2 - Parte 1 Etapas da OS (Dividida em três, etapas da OS/botões/Etapas não realizadas)
	oPanelUP41 := TPanel():New(0,0,,oPanelUP4,,,,,,10,10,.F.,.F.)
		oPanelUP41:Align := CONTROL_ALIGN_LEFT
		oPanelUP41:nWidth := (aSize[5]/2.20)

	// Folder 2 - Parte 2 Botões (Dividida em três, etapas da OS/botões/Etapas não realizadas)
	oPanelUP42 := TPanel():New(0,0,,oPanelUP4,,,,,,10,10,.F.,.F.)
		oPanelUP42:Align := CONTROL_ALIGN_ALLCLIENT
		oPanelUP42:nWidth := (aSize[5]/12)

	// Folder 2 - Parte 3 Etapas Não Realizadas (Dividida em três, etapas da OS/botões/Etapas não realizadas)
	oPanelUP43 := TPanel():New(0,0,,oPanelUP4,,,,,,10,10,.F.,.F.)
		oPanelUP43:Align := CONTROL_ALIGN_RIGHT
		oPanelUP43:nWidth := (aSize[5]/2.20)

	// Folder 2 - Parte 4 Superior (Descrição das etapas)
	oPanelUP44 := TPanel():New(0,0,,oPanelUP4,,,,,,10,10,.F.,.F.)
		oPanelUP44:Align := CONTROL_ALIGN_TOP
		oPanelUP44:nHeight := (aSize[6]/26)
		oPanelUP44:nWidth := aSize[5]

	// Folder 2 - Parte 4 Superior (Etapas da Ordem de Serviço)
	oPnlUP442 := TPanel():New(0,0,STR0020,oPanelUP44,,,,,,10,10,.F.,.F.) //"Etapas da Ordem de Serviço"
		oPnlUP442:Align := CONTROL_ALIGN_ALLCLIENT
		oPnlUP442:nWidth := (aSize[5]/12)

	// Folder 2 - Parte 4 Superior (Etapas não executadas de O.S. anteriores)
	oPnlUP443 := TPanel():New(0,0,,oPanelUP44,,,,,,10,10,.F.,.F.)
		oPnlUP443:Align := CONTROL_ALIGN_RIGHT
		oPnlUP443:nWidth := (aSize[5]/2.20)

	// Folder 2 - Parte 4 Superior Direita (Texto à esquerda)
	oPnlUP4431 := TPanel():New(0,0,,oPnlUP443,,,,,,10,10,.F.,.F.)
		oPnlUP4431:Align := CONTROL_ALIGN_LEFT
		oPnlUP4431:nWidth := (aSize[5]/2)

	// Montagem das Etapas da Ordem de Servico.
	@ nFO2IniI,nFO2ColI+10 Say STR0020 of oPanelUP41 Pixel //"Etapas da Ordem de Serviço"

	oBrw4 := FWMarkBrowse():New()
	oBrw4:SetOwner( oPanelUP41 )
	oBrw4:SetDataTable()
	oBrw4:SetAlias( cTRBQ400 )
	oBrw4:SetTemporary( .T. )
	oBrw4:SetAfterMark( { || MNTA435Mrk() } )

	If SuperGetMV( 'MV_NG1ETPM', .F., 'N' ) == 'S'

		oBrw4:SetFieldMark( 'TQ_MARK' )
		oBrw4:SetMark( cMarca, cTRBQ400, 'TQ_MARK' )
		oBrw4:SetValid( { || fVldMarkEt() } )

	Else

		oBrw4:SetFieldMark( 'TQ_OK' )
		oBrw4:SetMark( cMarca, cTRBQ400, 'TQ_OK' )
		oBrw4:SetAllMark( { || MNT435ETAL() } )

	EndIf

	oBrw4:SetFields( aTRBQ )
	oBrw4:SetIgnoreARotina( .T. )
	oBrw4:SetMenuDef( 'MNTA435' )
	oBrw4:DisableDetails()
	oBrw4:DisableReport()
	oBrw4:DisableSaveConfig()
	oBrw4:DisableConfig()
	oBrw4:DisableFilter()
	oBrw4:addLegend( "(cTRBQ400)->STATUS == '1'", "GREEN" , 'EXECUTADA' )
	oBrw4:addLegend( "(cTRBQ400)->STATUS == '2'", "RED"   , 'NÃO EXECUTADA' )
	oBrw4:addLegend( "(cTRBQ400)->STATUS == '3'", "YELLOW", 'EM EXECUÇÃO' )
	oBrw4:addLegend( "(cTRBQ400)->STATUS == '4'", "ORANGE", 'EXECUTADO > 100%' )
	oBrw4:Activate()

	// Ponto de Entrada para selecionar o executante padrão das etapas de O.S.
	If ExistBlock("MNTA435G")
		cCodFunc := ExecBlock("MNTA435G",.F.,.F.)
	EndIf

	oBrw4:Disable()

	@ 0,0 Say STR0021 of oPnlUP4431 Pixel // "Etapas não executadas de O.S. anteriores"

	dbSelectArea(cTRBTAR)
	@ 0,0 ListBox oBrw7 Fields (cTRBTAR)->DTMPINI,(cTRBTAR)->TAREFA, (cTRBTAR)->NOMETAR, (cTRBTAR)->ETAPA, (cTRBTAR)->NOMEETA, (cTRBTAR)->ORDEM ;
	COLSIZES 22,20,60,20,200,40 Size 0, 0; // nFO2Larg-nFO2ColI,nFO2Altu-(nFO2IniI+11)
	HEADERS STR0022,STR0023, STR0024, STR0025, STR0026, STR0027 ; // "Dt.Prevista"###"Tarefa"###"Nome Tarefa"###"Etapa"###"Descr. Etapa"###"Ordem"
	Of oPanelUP43 Pixel
	oBrw7:Align := CONTROL_ALIGN_ALLCLIENT
	oBrw7:Disable()

	@ 001 , 05 Button oBtEtInc PROMPT STR0028 of oPanelUP42 Size 34,nTamBotao Action (fCadEtapa(1)) Pixel // "Incluir"
	@ 014 , 05 Button oBtEtAlt PROMPT STR0029 of oPanelUP42 Size 34,nTamBotao Action (fCadEtapa(3)) Pixel // "Alterar"
	@ 027 , 05 Button oBtEtExc PROMPT STR0030 of oPanelUP42 Size 34,nTamBotao Action (fCadEtapa(2)) Pixel // "Excluir"
	@ 040 , 05 Button oBtEtAdd PROMPT "<< " + STR0031 of oPanelUP42 Size 34,nTamBotao Action fAddEtap() Pixel // "Adicionar"

	If SuperGetMV( 'MV_NG1ETPM', .F., 'N' ) == 'S'

		@ 053, 005 Button oBtEtExe PROMPT STR0410 of oPanelUP42 Size 34,nTamBotao Action fExecEtap() Pixel // Executar

		oBtEtExe:cToolTip := STR0411 // Execução Múltipla de Etapas

		oBtEtExe:Disable()

	EndIf

	oBtEtInc:cToolTip := STR0033 // "Incluir uma nova etapa para a ordem de serviço"
	oBtEtAlt:cToolTip := STR0034 // "Alterar a etapa selecionada"
	oBtEtExc:cToolTip := STR0035 // "Excluir a etapa selecionada"
	oBtEtAdd:cToolTip := STR0036 // "Transfere a etapa não executada de uma ordem de serviço antiga para a atual"

	oBtEtInc:Disable()
	oBtEtAlt:Disable()
	oBtEtExc:Disable()
	oBtEtAdd:Disable()

	/*-----------------------+
	| Folder 3 - Ocorrências |
	+-----------------------*/
	If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0

		/*-------------------------------------+
		| Folder 3 - Panel principal do Folder |
		+-------------------------------------*/
		oPnlOcr  := TPanel():New( 0, 0, , oFolder435:aDialogs[3], , , , , , 10, 10, .F., .F. )
		oPnlOcr:Align  := CONTROL_ALIGN_ALLCLIENT
		oPnlOcr:nWidth := ( aSize[5] / 2 )
		
			/*-----------------------------------+
			| Folder 3 - GetDados de Ocorrências |
			+-----------------------------------*/
			oPnlOcrGD1 := TPanel():New( 0, 0, , oPnlOcr, , , , , , 10, 10, .F., .F. )
			oPnlOcrGD1:Align  := CONTROL_ALIGN_LEFT
			oPnlOcrGD1:nWidth := ( aSize[5] / 2.15 )

			oGd435Ocr := MsNewGetDados():New( 0, 0, 200, 200, GD_INSERT + GD_UPDATE + GD_DELETE, 'MNA435LiOk( 1, oGd435Ocr:nAt, 3 )',;
				'', , , , 9999, , , , oPnlOcrGD1, aHoBrw3, aCoBrw3, { || fChangeOcr() } )
			
			oGd435Ocr:oBrowse:Align      := CONTROL_ALIGN_ALLCLIENT
			oGd435Ocr:oBrowse:bGotFocus  := { || Fd_Entra( 2 ) }
			oGd435Ocr:oBrowse:bLostFocus := { || Fd_Sai( 2 ) }

			/*------------------+
			| Folder 3 - Botões |
			+------------------*/
			oPnlOcrBtn := TPanel():New( 0, 0, , oPnlOcr, , , , , , 10, 10, .F., .F. )
			oPnlOcrBtn:Align  := CONTROL_ALIGN_ALLCLIENT
			oPnlOcrBtn:nWidth := ( aSize[5] / 12 )
		

				@ 005, 005 Button oBtOcInc PROMPT STR0418 OF oPnlOcrBtn SIZE 45, nTamBotao ACTION fOcorrAss() Pixel // Associar
		
			/*------------------------------------------+
			| Folder 3 - GetDados de Insumos Realizados |
			+------------------------------------------*/
			oPnlOcrGD2 := TPanel():New( 0, 0, , oPnlOcr, , , , , , 10, 10, .F., .F. )
			oPnlOcrGD2:Align  := CONTROL_ALIGN_RIGHT
			oPnlOcrGD2:nWidth := ( aSize[5] / 2.15 )

			oGd435Ass := MsNewGetDados():New( 0, 0, 200, 200, GD_INSERT + GD_UPDATE + GD_DELETE, 'MNA435LiOk( 1, oGd435Ass:nAt, 1 )', 'AllwaysTrue()', , , ,;
				9999, , , 'MNA435LiOk( 2, oGd435Ass:nAt, 1 )', oPnlOcrGD2, aHoBrw3_2, aCoBrw3_2 )
			
			oGd435Ass:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
			oGd435Ass:oBrowse:bLostFocus := { || Fd_Sai( 5 ) }
			oGd435Ass:oBrowse:bGotFocus  := { || Fd_Entra( 5 ) }
			
			/*-------------------------------------------+
			| Folder 3 - Panel principal para os titulos |
			+-------------------------------------------*/
			oPnlOcrTit := TPanel():New( 0, 0, , oPnlOcr, , , , , , 10, 10, .F., .F. )
			oPnlOcrTit:Align   := CONTROL_ALIGN_TOP
			oPnlOcrTit:nHeight := ( aSize[6] / 26 )
			oPnlOcrTit:nWidth  := aSize[5]
		
				/*---------------------------------------+
				| Folder 3 - Titulo da GetDados esquerda |
				+---------------------------------------*/
				oPnlOcrTi1 := TPanel():New( 0, 0, STR0018, oPnlOcrTit, , , , , , 10, 10, .F., .F. ) // Ocorrências
				oPnlOcrTi1:Align  := CONTROL_ALIGN_LEFT
				oPnlOcrTi1:nWidth := ( aSize[5] / 12 )
		
				/*--------------------------------------+
				| Folder 3 - Titulo da GetDados direita |
				+--------------------------------------*/
				oPnlOcrTi2 := TPanel():New( 0, 0, STR0419, oPnlOcrTit, , , , , , 10, 10, .F., .F. ) // Insumos Associados
				oPnlOcrTi2:Align  := CONTROL_ALIGN_RIGHT
				oPnlOcrTi2:nWidth := ( aSize[5] / 2.15 )

	Else

		/*-------------------------------------+
		| Folder 3 - Panel principal do Folder |
		+-------------------------------------*/
		oPnlOcr  := TPanel():New( 0, 0, , oFolder435:aDialogs[3], , , , , , 10, 10, .F., .F. )
		oPnlOcr:Align  := CONTROL_ALIGN_ALLCLIENT
		oPnlOcr:nWidth := ( aSize[5] / 2 )

			oGd435Ocr := MsNewGetDados():New( 0, 0, 0, 0, GD_INSERT + GD_UPDATE + GD_DELETE, 'MNA435LiOk( 1, oGd435Ocr:nAt, 3 )',;
				'', , , , 9999, , , , oPnlOcr, aHoBrw3, aCoBrw3 )
			
			oGd435Ocr:oBrowse:Align         := CONTROL_ALIGN_ALLCLIENT
			oGd435Ocr:oBrowse:lDisablePaint := .T.
			oGd435Ocr:oBrowse:bGotFocus     := { || Fd_Entra( 2 ) }
			oGd435Ocr:oBrowse:bLostFocus    := { || Fd_Sai( 2 ) }

	EndIf

	// Folder 4
	oPanelUP6 := TPanel():New(0,0,,oFolder435:aDialogs[4],,,,,,10,10,.F.,.F.)
		oPanelUP6:Align := CONTROL_ALIGN_ALLCLIENT
		oPanelUP6:nWidth := (aSize[5]/2)

	// Montagem do Motivo de Atraso da Ordem de Servico
	aCols   := aClone(aCoBrw4)
	aHeader := aClone(aHoBrw4)
	oBrw5   := MsGetDados():New(0, 0, 0, 0, 4   ,"LinOk435PL()","TudOk435PL()","",.T.,,,,nLinGet,,,,,oPanelUP6)
	oBrw5:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oBrw5:oBrowse:lDisablePaint := .T.
	oBrw5:oBrowse:bGotFocus     := {|| Fd_Entra(3) }
	oBrw5:oBrowse:bLostFocus    := {|| Fd_Sai( 3 ) }
	oBrw5:oBrowse:Disable()
	oBrw5:oBrowse:Default()
	oBrw5:oBrowse:Refresh()

	// Fim da montagem dos folders

	aCols   := aClone(aCoBrw6)
	aHeader := aClone(aHoBrw6)

	lStartVar := .T.

	// Caso exista um filtro ativo no browse, faz o carregamento automático.
	If oBrwOS:lFiltrate
		fLoadBrw( .T., aFields, .T. )
	EndIf

	NGPOPUP(aSMenu,@oMenu)
	oDlg1:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg1)}

	If lArvoreLogica
		fRefreshOS( (cAliOS435)->TJ_ORDEM, (cAliOS435)->TJ_PLANO, 1 )
	EndIf

	Activate MsDialog oDlg1 ON INIT MNTA435BAR(@oPanelUP1,;
		{|| If(fValidOK(@lRetTela,.T.),(Processa({|| fGrava435(,.F.,.F.) } , STR0002),oDlg1:End()),lRetTela := .F.) },; //Ok
			{|| IIf( fVldAltOS(.T.), oDlg1:End(), ) }, aFields, oBrwOS ) Centered //Cancelar

	// Deleção de Tabelas Temporárias
	oTmpTbl3:Delete()
	oTmpTbl6:Delete()
	oTmpTbl4:Delete()
	oTmpTbl5:Delete()
	oTmpTblOS:Delete()

	If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0
		
		oTmpTbl7:Delete()

	EndIf
	
	NGRETURNPRM(aNGBEGINPRM)

	aRet := {lRetTela,aClone(aVetorCan),aClone(aVetorFin)}

Return aRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fGrava435
Gravar registros

@type Static function
@source MNTA435.prx
@author Denis
@since 06/08/2001
@param nIniOS, Numérico, posição da OS.
@param lRefBrow, Lógico, Indica se atualizará o browse.
@param lLoadIns, Lógico, Indica se os insumos da ordem selecioanda devem ser carregados.
@param [lCanOrFin], Lógico, Define se é um canelamento ou uma finalização
@obs o parâmetro lLoadIns deve ser passado falso para os seguintes casos: botões
oBtOK (grava tabelas e fecha);
oBtCOS (grava cancelamento e fecha);
oBtFOS (grava e a ordem não será mais apresentada)

@return boolean, se houve sucesso na operação
/*/
//---------------------------------------------------------------------
Static Function fGrava435( nIniOS, lRefBrow, lLoadIns, lCanOrFin )

	Local nIndOS 		:= 0
	Local nIndTL 		:= 0
	Local nX			:= 0
	Local nErro         := 0
	Local nIndTPL		:= 0
	Local nYtmp			:= 0
    Local nIndSTN		:= 0
	Local nIndOS2		:= 0
	Local nxSA			:= 0
	Local nXX			:= 0
	Local i				:= 0
	Local nXtmp			:= 0
	Local nPosArray 	:= 0
	Local nCopy         := 0
	Local nItemSA   	:= 0
	Local nPosAux   	:= 0
	Local nPosArr       := 0
	Local nOkSTQ        := Len( aTrbQ ) + 1
	Local nSeqSTQ       := Len( aTrbQ ) + 2
	Local nRecSTQ       := Len( aTrbQ ) + 3
	Local nPos01    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPos02 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DESTINO"})
	Local nPos03   	 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPos05    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	Local nPos06    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	Local nPos08    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"  })
	Local nPos10    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	Local nPos11    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})
	Local nPos12    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})
	Local nPos13    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCALIZ"})
	Local nPos14    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSERI"})
	Local nPos15    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_GARANTI"})
	Local nPos16    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA" })
	Local nPos18    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	Local nPos19    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_OBSERVA"})
	Local nPos20    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_ETAPA"})
	Local nPos21    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CUSTO"})
	Local nPosGrt   	:= aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_GARANTI"}) //Verifica se esta focado no browse de insumos realizados
	Local nMotCo    	:= aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_CODMOT"})
	Local nMotDI    	:= aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_DTINIC"})
	Local nMotHI    	:= aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_HOINIC"})
	Local nMotDF    	:= aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_DTFIM" })
	Local nMotHF    	:= aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_HOFIM" })
	Local nOcoCo    	:= aScan(aHoBrw3,{|x| Trim(Upper(x[2])) == "TN_CODOCOR"})
	Local nOcoCa    	:= aScan(aHoBrw3,{|x| Trim(Upper(x[2])) == "TN_CAUSA"  })
	Local nOcoSo    	:= aScan(aHoBrw3,{|x| Trim(Upper(x[2])) == "TN_SOLUCAO"})
	Local nEtaTa    	:= aScan( aTRBQ ,{ |x| Trim( Upper( x[2] ) ) == 'TQ_TAREFA'  } )
	Local nEtapa    	:= aScan( aTRBQ ,{ |x| Trim( Upper( x[2] ) ) == 'TQ_ETAPA'   } )
	Local nEtSeq        := aScan( aTRBQ ,{ |x| Trim( Upper( x[2] ) ) == 'TQ_SEQETA'  } )
	Local nLinOS        := 0
    Local lDelGarant	:= .F.
	Local lAltGarant	:= .F.
	Local lTpGeraOS		:= .F.
	Local lTPGeraSS		:= .F.
	Local lCondicao		:= .F.
	Local lMNTB4354		:= ExistBlock( 'MNTB4354' )
	Local lMNTA4353		:= ExistBlock( 'MNTA4353' )
	Local lMNTA435I		:= ExistBlock( 'MNTA435I' )
	Local lMNTA435M     := ExistBlock( 'MNTA435M' )
	Local lNGCALCUSTI   := ExistBlock( 'NGCALCUSTI' )
	Local lProcSTL  	:= .T.
	Local lRet          := .T.
    Local lOSHESTO  	:= .F. //Variavel que indica se terá integração com o estoque quando TJ_SERVICO = 'HISTOR'
	Local lSerRef		:= .F.
    Local cOrdem		:= ""
	Local cPlano		:= ""
	Local cForm			:= ""
	Local cResp			:= ""
	Local cServCar		:= ""
	Local cTipoMan		:= ""
	Local cTpcMark  	:= ''
	Local cMsgSS		:= ''
	Local cAliIns		:= ''
	Local cQueryIns		:= ''
	Local cRMTaref      := ''
	Local cRMTipoR      := ''
	Local cRMCodIn      := ''
	Local cRMSeqre      := ''
	Local cRMNumse      := ''
	Local cNGUNIDT		:= AllTrim( SuperGetMv( 'MV_NGUNIDT', .F., 'S' ) )
	Local cNGMNTAS		:= SuperGetMV("MV_NGMNTAS",.F.,"2")
	Local cNumSA    	:= Space( TAMSX3('CP_NUM')[ 1 ] )
	Local cNumCP    	:= cNumSA
	Local cAlsSTN       := GetNextAlias()
	Local cMemoQry      := TCConfig( 'GETMEMOINQUERY' )
	Local cCast         := ''
	Local cDbase        := TCGetDB()
	Local aBind			:= {}
    Local aReqSD3   	:= {}
	Local aTRBZ435  	:= {}
	Local aTempAux  	:= {}
	Local aSolic    	:= {}
	Local aLogRM        := {}
	Local aLogNoCanc    := {}
	Local aNoCopy       := {}
	Local aRollBack     := {}
	Local aRetSD3       := {}
	Local aAreaAlOs     := (cAliOS435)->( GetArea() )
	Local aAreaSTJ      := STJ->( GetArea() )
	Local lPrimVez  	:= .T.
	Local lOSRepet  	:= .F.
	Local cChavAnt  	:= ""

	Private aTRBZ   	:= {}

	Default lLoadIns 	:= .T.
	Default lCanOrFin   := .F.

	Store .F. To lTpGeraOS, lTPGeraSS, lCondicao

	//Ordena S.A. pelo campo Ordem + Plano
	aSort( aDadosSA,,,{|x,y| x[1]+x[2] < y[1]+y[2] })

	//Ordena Garantia pelo campo Ordem + Plano
	aSort( aDadosTPZ,,,{|x,y| x[5]+x[6] < y[5]+y[6] })

	aArray  := {}
	aArray2 := {}
	fCriaOsGer(@aTRBZ435)

	CursorWait()

	aInsNaoGra := {}
	aReqSD3    := {} //Salva requisicoes para executar no final da gravacao
	ProcRegua( (cAliOS435)->( RecCount() ) )

	Begin Transaction

		If !lCanOrFin
			DbSelectArea( cAliOS435 )
			dbSetOrder( 1 )
			dbGoTop()
		EndIf

		Do While (cAliOS435)->( !EoF() )

			IncProc()
			cOrdem := (cAliOS435)->TJ_ORDEM
			cPlano := (cAliOS435)->TJ_PLANO

			//Se o numero da OS nao existir
			dbSelectArea("STJ")
			dbSetOrder(1)
			If !dbSeek( xFilial("STJ") + cOrdem + cPlano )
				Loop
			EndIf

			If STJ->TJ_SITUACA == 'C'
				aAdd( aLogNoCanc, { STJ->TJ_ORDEM, STJ->TJ_PLANO } )
				Loop
			EndIf

			lOSHESTO := .F.

			If cUsaInt3 == 'S' .And. cUIntHis == "N" .And. STJ->TJ_SERVICO == "HISTOR"
				lOSHESTO := .T.
			EndIf

			cCodBem := STJ->TJ_CODBEM

			//Se o numero da OS nao existir no array
			nLineOS := aScan(aDadosOS, {|x|x[1]+x[2] == cOrdem+cPlano })

			If nLineOS == 0
				Loop
			EndIf

			//Gravacao Motivos de Atraso
			If ValType( aDadosOS[nLineOS,7] ) == "A"

				//Excluindo os motivos que foram retirados da tela
				dbSelectArea("TPL")
				dbSetOrder(1)
				dbSeek( xFilial("TPL") + cOrdem )
				While !EoF() .And. xFilial("TPL")+cOrdem == TPL->TPL_FILIAL+TPL->TPL_ORDEM
					If aScan(aDadosOS[nLineOS,7], {|x| x[nMotCo]          == TPL->TPL_CODMOT .And.;
					x[nMotDI] == TPL->TPL_DTINIC .And. x[nMotHI] == TPL->TPL_HOINIC .And.;
					x[nMotDF] == TPL->TPL_DTFIM  .And. x[nMotHF] == TPL->TPL_HOFIM  .And. !ATail(x) }) == 0

						RecLock("TPL", .F.)
						dbDelete()
						TPL->(MsUnLock())
					EndIf

					dbSelectArea("TPL")
					dbSkip()
				EndDo

				//Os registros deletados serão os primeiros da lista
				aSort(aDadosOS[nLineOS,7],,,{|x,y| ATail(x) .And. !ATail(y) })

				For nIndOS := 1 To Len(aDadosOS[nLineOS,7])

					If Empty( aDadosOS[nLineOS,7,nIndOS,nMotCo] ) //Nao validar se codigo vazio
						Loop
					EndIf

					cKeyTPL := xFilial("TPL") + cOrdem
					cKeyTPL += aDadosOS[nLineOS,7,nIndOS,nMotCo] + DtoS(aDadosOS[nLineOS,7,nIndOS,nMotDI])
					cKeyTPL += aDadosOS[nLineOS,7,nIndOS,nMotHI] + DtoS(aDadosOS[nLineOS,7,nIndOS,nMotDF])
					cKeyTPL += aDadosOS[nLineOS,7,nIndOS,nMotHF]

					//Se nao for deletado
					If !aDadosOS[nLineOS,7][nIndOS][Len(aDadosOS[nLineOS,7][nIndOS])]

						lTPL_Lock := .T.
						dbSelectArea("TPL")
						dbSetOrder(1) // TPL_FILIAL+TPL_ORDEM+TPL_CODMOT+DTOS(TPL_DTINIC)+TPL_HOINIC+DTOS(TPL_DTFIM)+TPL_HOFIM
						lTPL_Lock := !dbSeek(cKeyTPL)
						RecLock("TPL",lTPL_Lock)

						For nIndTPL := 1 To FCount()
							If Alltrim(FieldName(nIndTPL)) $ "TPL_FILIAL/TPL_ORDEM"
								Loop
							EndIf

							nPosTmp := aScan(aHoBrw4, {|x| AllTrim(Upper(X[2])) == FieldName(nIndTPL) })
							y  := "TPL->" + FieldName(nIndTPL)

							If nPosTmp > 0
								x  := "M->" + FieldName(nIndTPL)
								&x.:= aDadosOS[nLineOS,7,nIndOS,nPosTmp]
								&y := &x
							ElseIf lTPL_Lock
								&y := CriaVar(FieldName(nIndTPL))
							EndIf
						Next nIndTPL

						TPL->TPL_FILIAL := xFilial("TPL")
						TPL->TPL_ORDEM  := cOrdem
						TPL->(MsUnLock())
					Else

						dbSelectArea("TPL")
						dbSetOrder(1)
						//TPL_FILIAL + TPL_ORDEM + TPL_CODMOT + DTOS(TPL_DTINIC) + TPL_HOINIC + DTOS(TPL_DTFIM) + TPL_HOFIM
						If dbSeek( cKeyTPL )
							RecLock( "TPL", .F. )
							dbDelete()
							TPL->(MsUnLock())
						EndIf
					EndIf
				Next nIndOS
			EndIf //Fim Gravacao Motivos

			//Gravacao dos Insumo
			lAlteraSTL := .F.

			If ValType( aDadosOS[nLineOS,5] ) == "A"
				//Verifica se algo foi alterado
				nTemGar := aScan(aDadosTPZ, {|x| x[5]+x[6] == cOrdem+cPlano })

				If Len(aDadosOS[nLineOS,4]) <> Len( aDadosOS[nLineOS,5] ) .Or. nTemGar > 0
					lAlteraSTL := .T.
				Else
					For nXtmp := 1 to Len(aDadosOS[nLineOS,5])
						If Len(aDadosOS[nLineOS,4,nXtmp]) <> Len(aDadosOS[nLineOS,5,nXtmp])
							lAlteraSTL := .T.
							Exit
						EndIf
						If  Empty(aDadosOS[nLineOS,4,nXtmp,1]) .And. Empty(aDadosOS[nLineOS,4,nXtmp,3]) .And. Empty(aDadosOS[nLineOS,4,nXtmp,5]) .And. ;
						Empty(aDadosOS[nLineOS,5,nXtmp,1]) .And. Empty(aDadosOS[nLineOS,5,nXtmp,3]) .And. Empty(aDadosOS[nLineOS,5,nXtmp,5])
							Loop
						EndIf

						For nYtmp := 1 to Len(aDadosOS[nLineOS,5,nXtmp])
							If nYtmp == Len(aDadosOS[nLineOS,5,nXtmp]) - 1
								Loop
							EndIf

							If ValType(aDadosOS[nLineOS,5,nXtmp,nYtmp]) <> ValType(aDadosOS[nLineOS,4,nXtmp,nYtmp])
								lAlteraSTL := .T.
								Exit
							EndIf

							If aDadosOS[nLineOS,5,nXtmp,nYtmp] <> aDadosOS[nLineOS,4,nXtmp,nYtmp]
								lAlteraSTL := .T.
								Exit
							EndIf
						Next nYtmp

						If lAlteraSTL
							Exit
						EndIf
					Next nXtmp
				EndIf
			EndIf

			If lAlteraSTL

				lSerRef := AllTrim( STJ->TJ_SERVICO ) == SuperGetMV("MV_NGSERPN", .F., "")

				RecLock("STJ", .F.)

					STJ->TJ_TIPORET := 'S' //Para legenda entender que contem insumo aplicado

				STJ->( MsUnlock() )


				//Excluindo os insumos que foram retirados da tela
				dbSelectArea( 'STL' )
				dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
				MsSeek( FWxFilial( 'STL' ) + cOrdem + cPlano )

				While !EoF() .And. FWxFilial( 'STL' ) + cOrdem + cPlano == STL->( TL_FILIAL + TL_ORDEM + TL_PLANO )
					If !Empty( STL->TL_SEQRELA ) .And. AllTrim( STL->TL_SEQRELA ) != '0' .And. ;
					aScan( aDadosOS[ nLineOS, 5 ] , { | x | x[ nPos16 ] == STL->TL_TAREFA .And. x[ nPos01 ] == STL->TL_TIPOREG .And. ;
					x[ nPos03 ] == STL->TL_CODIGO .And. x[ nPos18 ] == STL->TL_SEQRELA .And. ATail( x ) } ) > 0

						//Verificar se o insumo foi gerado atraves de uma requisicao do estoque e nao deleta
						If !lIntRM .And. STL->TL_ORIGNFE == "SD3" .Or. STL->TL_ORIGNFE == "SD1"
							dbSelectArea("STL")
							dbSkip()
							Loop
						ElseIf cUsaInt3 == 'S' .And. ; // integração com estoque
								lSerRef .And.; // serviço mov. pneu
								( nPosDOS := aScan(aDadosOS,{|x| Trim(Upper(x[1])) == cOrdemTJ}) ) > 0 .And.; // posição da ordem
								( nPosSav := aScan(aDadosOS[nPosDOS,4] ,{|x| ; // posição do insumo
											x[nPos01] == aCols[n][nPos01] .And.;
											x[nPos03] == aCols[n][nPos03] .And.;
											x[nPos18] == aCols[n][nPos18] }) ) > 0 .And.;
								aDadosOs[nPosDOS,4,nPosSav,nPos01] == 'P' .And. ; // insumo produto
								Val( aDadosOs[nPosDOS,4,nPosSav,nPos18] ) .And.; // insumo realizado
								ProdutoPn( aDadosOs[nPosDOS,4,nPosSav,nPos03],; // é um pneu
											aDadosOs[nPosDOS,4,nPosSav,nPos05], STJ->TJ_ORDEM )

							dbSelectArea("STL")
							dbSkip()
							Loop

						EndIf

						If !Empty(STL->TL_NUMSEQ)
							//Faz devoulucao para o estoque
							dbSelectArea("SD3")
							dbSetOrder(4)
							If dbSeek( xFilial( 'SD3' ) + STL->TL_NUMSEQ )

								aRetSD3 := MntGeraD3( 'DE1', , , .T., .F., .T. )

								If aRetSD3[2]

									If NGPRODESP( SD3->D3_COD, .F., 'M' )
										NGAtuErp( 'SD3', 'INSERT' )
									EndIf

								Else

									aAdd( aLogRM, { aRetSD3[3], STL->TL_ORDEM, STL->TL_PLANO, STL->TL_TAREFA,;
										STL->TL_TIPOREG, STL->TL_CODIGO, STL->TL_SEQRELA, STL->TL_NUMSEQ } )

									STL->( dbSkip() )
									Loop

								EndIf

							EndIf
						EndIf

						If STL->TL_TIPOREG == "P"
							//MOSTRA OS REGISTROS DO HISTORICO PARA EXECLUIR
							NGDELINSLAN( STJ->TJ_CODBEM, STL->TL_DTINICI, STL->TL_HOINICI )
						EndIf

						fNgGarDelete(cOrdem,cPlano,STL->TL_SEQRELA)

							dbSelectArea("STN")
							dbSetOrder(1)
							dbSeek( xFilial("STN") + STL->(TL_ORDEM+TL_PLANO+TL_TAREFA+TL_SEQRELA) )
							While !EoF() .And. STL->(TL_ORDEM + TL_PLANO + TL_TAREFA + TL_SEQRELA ) == STN->( TN_ORDEM + TN_PLANO + TN_TAREFA + TN_SEQRELA ) .And. ;
							xFilial("STN") == STN->TN_FILIAL

								RecLock("STN",.F.)
								dbDelete()
								STL->(MsUnLock())

								dbSelectArea("STN")
								dbSkip()
							EndDo

						dbSelectArea("STL")
						RecLock("STL",.F.)
						dbDelete()
						STL->(MsUnLock())
						If lMNTB4354
							ExecBlock("MNTB4354")
						EndIf
					EndIf

					dbSelectArea("STL")
					dbSetOrder(1)
					STL->(dbSkip())
				EndDo

				//Ordena pelo campo TL_SEQRELA
				aSort(aDadosOS[nLineOS,5],,,{|x,y| x[nPos18] < y[nPos18] })

				//Os registros deletados serão os primeiros da lista
				aSort(aDadosOS[nLineOS,5],,,{|x,y| x[Len(x)] .And. !y[Len(y)] })

				//Ultima Sequencia
				M->TL_ORDEM := cOrdem
				M->TL_PLANO := cPlano

				For nIndOS := 1 to Len(aDadosOS[nLineOS,5])
					//Verifica se o insumo foi gerado atraves do estoque e altera a tarefa
					dbSelectArea( "STL" )
					dbSetOrder( 02 ) //TL_FILIAL+TL_TIPOREG+TL_SEQRELA+TL_CODIGO+TL_ORDEM+TL_PLANO
					If dbSeek( xFilial( "STL" )+aDadosOS[nLineOS,5,nIndOS,nPos01]+aDadosOS[nLineOS,5,nIndOS,nPos18]+aDadosOS[nLineOS,5,nIndOS,nPos03]+cOrdem+cPlano)
						If ( STL->TL_ORIGNFE == "SD3" .Or. STL->TL_ORIGNFE == "SD1" ) .And. aDadosOS[nLineOS,5,nIndOS,nPos16] <> STL->TL_TAREFA
							RecLock( "STL",.F. )
							STL->TL_TAREFA := aDadosOS[nLineOS,5,nIndOS,nPos16]
							MsUnLock( "STL" )
							Loop
						ElseIf cUsaInt3 == 'S' .And. ; // integração com estoque
								lSerRef .And.; // serviço mov. pneu
								( nPosDOS := aScan(aDadosOS,{|x| Trim(Upper(x[1])) == cOrdemTJ}) ) > 0 .And.; // posição da ordem
								( nPosSav := aScan(aDadosOS[nPosDOS,4] ,{|x| ; // posição do insumo
											x[nPos01] == aCols[n][nPos01] .And.;
											x[nPos03] == aCols[n][nPos03] .And.;
											x[nPos18] == aCols[n][nPos18] }) ) > 0 .And.;
								aDadosOs[nPosDOS,4,nPosSav,nPos01] == 'P' .And. ; // insumo produto
								Val( aDadosOs[nPosDOS,4,nPosSav,nPos18] ) .And.; // insumo realizado
								ProdutoPn( aDadosOs[nPosDOS,4,nPosSav,nPos03],; // é um pneu
											aDadosOs[nPosDOS,4,nPosSav,nPos05], STJ->TJ_ORDEM )

							RecLock( "STL",.F. )
							STL->TL_TAREFA := aDadosOS[nLineOS,5,nIndOS,nPos16]
							STL->TL_DESTINO := aDadosOS[nLineOS,5,nIndOS,nPos02]
							MsUnLock( "STL" )
							Loop

						EndIf

						RecLock( "STL",.F. )
						STL->TL_ETAPA := aDadosOS[nLineOS,5,nIndOS,nPos20]
						MsUnLock( "STL" )
					EndIf

					If Empty( aDadosOS[ nLineOS, 5, nIndOS, nPos03 ] ) .Or. !fPersSTL( cOrdem, cPlano, aDadosOS[ nLineOS, 5, nIndOS ] ) //Nao validar se codigo vazio ou Insumo já deletado
						Loop
					EndIf

					cTIPOMAN := IIf( Val(STJ->TJ_PLANO) == 0, "C", "P")

					cKeySTL  := xFilial("STL")+cOrdem+cPlano
					cKeySTL  += aDadosOS[nLineOS,5,nIndOS,nPos16] + aDadosOS[nLineOS,5,nIndOS,nPos01]
					cKeySTL  += aDadosOS[nLineOS,5,nIndOS,nPos03] + aDadosOS[nLineOS,5,nIndOS,nPos18]

					//Se nao for deletado
					If !aDadosOS[nLineOS,5][nIndOS][Len(aDadosOS[nLineOS,5][nIndOS])]

						lProcSTL := .T.

						If lMNTA4353
							aTempAux := aClone(ExecBlock("MNTA4353",.F.,.F.,{.F.,aHoBrw6,aDadosOS[nLineOS,5][nIndOS]}))
							If aTempAux[1]
								nPosAux := aScan(aInsNaoGra, {|x| AllTrim(x[1])+AllTrim(x[2]) == AllTrim(aDadosOS[nLineOS][1])+AllTrim(aDadosOS[nLineOS][2])})
								If nPosAux == 0
									aAdd(aInsNaoGra,{aDadosOS[nLineOS][1], aDadosOS[nLineOS][2], {aTempAux[2]}})
								Else
									aAdd(aInsNaoGra[nPosAux][3], aTempAux[2])
								EndIf
								lProcSTL := .F.
							EndIf
						EndIf

						If lProcSTL
							lDelGarant := .F. //Indica se foi retirada a garantia
							lAltGarant := .F. //Indica se foi alterada a data da garantia
							lSTL_Lock  := .T.
							dbSelectArea("STL")
							dbSetOrder(1) //TL_FILIAL+TL_ORDEM+TL_PLANO+TL_TAREFA+TL_TIPOREG+TL_CODIGO+TL_SEQRELA
							If !Empty(aDadosOS[nLineOS,5,nIndOS,nPos18]) .And. AllTrim( aDadosOS[ nLineOS, 5, nIndOS, nPos18 ] ) != '0' //Se nao vazio TL_SEQRELA
								lSTL_Lock := !dbSeek(cKeySTL)
							EndIf

							RecLock("STL",lSTL_Lock)

							If !lSTL_Lock //Verifica se foi retirada a garantia na alteração do STL
								If STL->TL_GARANTI == "S" .And. aDadosOS[nLineOS,5,nIndOS,nPos15] == "N"
									lDelGarant := .T.
								EndIf
								dDtTmp01 := If(Empty(STL->TL_DTFIM),STL->TL_DTINICI,STL->TL_DTFIM)
								dDtTmp02 := If(Empty(aDadosOS[nLineOS,5,nIndOS,nPos08]),aDadosOS[nLineOS,5,nIndOS,nPos06],aDadosOS[nLineOS,5,nIndOS,nPos08])
								If dDtTmp01 <> dDtTmp02
									lAltGarant := .T.
								EndIf
							EndIf

							For nIndTL := 1 TO FCount()
								If Alltrim(FieldName(nIndTL)) $ "TL_FILIAL/TL_ORDEM/TL_PLANO/TL_REPFIM/TL_NUMSEQ/TL_SEQRELA/TL_OBSERVA/TL_USERLGI/TL_USERLGA"
									Loop
								EndIf

								nPosTmp := aScan(aHoBrw6, {|x| AllTrim(Upper(X[2])) == FieldName(nIndTL) })
								y  := "STL->" + FieldName(nIndTL)
								If nPosTmp > 0
									x  := "M->" + FieldName(nIndTL)
									&x.:= aDadosOS[nLineOS,5,nIndOS,nPosTmp]
									&y := &x
								ElseIf lSTL_Lock
									&y := CriaVar(FieldName(nIndTL))
								EndIf
							Next nIndTL

							STL->TL_FILIAL  := xFilial("STL")
							STL->TL_ORDEM   := cOrdem
							STL->TL_PLANO   := cPlano
							STL->TL_SEQRELA := aDadosOS[nLineOS,5,nIndOS,nPos18]
							STL->TL_REPFIM  := "S"
							STL->TL_USACALE := If(STL->TL_USACALE <> "S","N",STL->TL_USACALE)
							If STL->TL_TIPOREG <> "P"
								STL->TL_TIPOHOR := If(STL->TL_USACALE == "S","S", cNGUNIDT)
							Else
								STL->TL_TIPOHOR := cNGUNIDT
								STL->TL_DTFIM   := STL->TL_DTINICI
								STL->TL_HOFIM   := STL->TL_HOINICI
							EndIf

							If nPos19 > 0
								STL->TL_OBSERVA := aDadosOS[nLineOS,5,nIndOS,nPos19]
							EndIf

							// Caso o campo não esteja em tela, persiste o calculo e gravação.
							If nPos21 == 0
								STL->TL_CUSTO := Round( NGCALCUSTI( STL->TL_CODIGO, STL->TL_TIPOREG, STL->TL_QUANTID, STL->TL_LOCAL, , , , STL->TL_QUANREC, '1' ), 2 )
							EndIf

							STL->(MsUnLock())

							//PE para que seja possível alterar um insumo após a gravação da STL
							If lMNTA435I
								ExecBlock("MNTA435I",.F.,.F.)
							EndIf

							If STL->TL_GARANTI == "S" //Grava garantia
								nLineSA := aScan(aDadosTPZ, {|x| x[2] + x[3] == STL->TL_TIPOREG + STL->TL_CODIGO .And. ;
								x[5] + x[6] == STL->TL_ORDEM   + STL->TL_PLANO  .And. ;
								x[7]        == STL->TL_SEQRELA })

								If nLineSA > 0
									fNgGarInsert(nLineSA,cOrdem,cPlano,STL->TL_SEQRELA, If(Empty(STL->TL_DTFIM),STL->TL_DTINICI,STL->TL_DTFIM) )
								EndIf
							EndIf

							If lSTL_Lock //Incluir
								If cUsaInt3 == "S" .And. !lOSHESTO
									If STL->TL_TIPOREG $ "PM"
										If MNT435CANB() // Caso não haja bloqueio para a movimentação no estoque
											aAdd( aReqSD3 , { STL->(Recno()) , .F. } )
										EndIf
									EndIf
								EndIf
							Else
								If lDelGarant //Retira Garantia
									fNgGarDelete(cOrdem,cPlano,STL->TL_SEQRELA)
								EndIf
								If lAltGarant //Altera data da garantia
									fNgGarUpdate(cOrdem,cPlano,STL->TL_SEQRELA, If(Empty(STL->TL_DTFIM),STL->TL_DTINICI,STL->TL_DTFIM) )
								EndIf

								If cUsaInt3 == "S" .And. STL->TL_TIPOREG $ 'PT' .And. !lOSHESTO

									nPosSav := aScan( aDadosOS[nLineOS,4], { |x| x[nPos16] == aDadosOS[nLineOS,5,nIndOS,nPos16] .And. x[nPos01] == aDadosOS[nLineOS,5,nIndOS,nPos01] .And.;
										x[nPos03] == aDadosOS[nLineOS,5,nIndOS,nPos03] .And. x[nPos18] == aDadosOS[nLineOS,5,nIndOS,nPos18] } )
									
									lProSD3 := .T.

									If nPosSav > 0

										lProSD3 := .F.

										If lIntRM .And. !Empty( STL->TL_NUMSA )

											If aDadosOS[nLineOS,4,nPosSav,nPos10] != STL->TL_QUANTID

												dbSelectArea("SD3")
												dbSetOrder(4)
												If dbSeek( xFilial( 'SD3' ) + STL->TL_NUMSEQ )

													RecLock( 'SD3', .F. )
														SD3->D3_QUANT  := STL->TL_QUANTID
														SD3->D3_CUSTO1 := STL->TL_CUSTO
													MsUnLock()

													If !NGMUStoTuO( SD3->( RecNo() ), 'SD3', .F., 4 )

														/* Não foi identificado forma de obter retorno negativo do RM para está MU.
															aRetSD3 := { '', .F., '' }
														*/
					
													EndIf

												EndIf
												
											EndIf

										Else

											If aDadosOS[nLineOS,4,nPosSav,nPos10] <> STL->TL_QUANTID .Or. aDadosOS[nLineOS,4,nPosSav,nPos06] <> STL->TL_DTINICI .Or. ;
												aDadosOS[nLineOS,4,nPosSav,nPos05] <> STL->TL_LOCAL   .Or. aDadosOS[nLineOS,4,nPosSav,nPos12] <> STL->TL_LOTECTL .Or. ;
												aDadosOS[nLineOS,4,nPosSav,nPos11] <> STL->TL_NUMLOTE .Or. aDadosOS[nLineOS,4,nPosSav,nPos14] <> STL->TL_NUMSERI .Or. ;
												aDadosOS[nLineOS,4,nPosSav,nPos13] <> STL->TL_LOCALIZ

												lProSD3 := .T.

											EndIf

										EndIf

									EndIf

									If lProSD3

										If !Empty( STL->TL_NUMSEQ )
											//Faz devoulucao para o estoque
											dbSelectArea("SD3")
											dbSetOrder(4)
											If dbSeek( xFilial( 'SD3' ) + STL->TL_NUMSEQ )
  
												aRetSD3 := MntGeraD3( 'DE1', , , .T., .F., .T. )

												If aRetSD3[2]

													If NGPRODESP( SD3->D3_COD, .F., 'M' )
														NGAtuErp( 'SD3', 'INSERT' )
													EndIf

												Else

													aAdd( aLogRM, { aRetSD3[3], STL->TL_ORDEM, STL->TL_PLANO, STL->TL_TAREFA,;
														STL->TL_TIPOREG, STL->TL_CODIGO, STL->TL_SEQRELA, STL->TL_NUMSEQ } )
													Loop

												EndIf

											EndIf
										EndIf

										If MNT435CANB() // Caso não haja bloqueio para a movimentação no estoque

											aAdd( aReqSD3 , { STL->(Recno()) , nil } ) //Faz uma nova requisicao no estoque - MNTGERAD3("RE0")
											
										Else
											If !Empty(STL->TL_NUMSEQ)
												Reclock("STL", .F.)
												STL->TL_NUMSEQ := Space(Len(STL->TL_NUMSEQ))
												MsUnlock()
											EndIf
										EndIf

									EndIf

								EndIf

							EndIf
						EndIf
					Else
						If !Empty(aDadosOS[nLineOS,5,nIndOS,nPos18]) .And. AllTrim( aDadosOS[ nLineOS, 5, nIndOS, nPos18] ) != '0' //Se nao vazio TL_SEQRELA

							lProcSTL := .T.

							If lMNTA4353
								aTempAux := aClone(ExecBlock("MNTA4353",.F.,.F.,{.T.,aHoBrw6,aDadosOS[nLineOS,5][nIndOS]}))
								If aTempAux[1]
									nPosAux := aScan(aInsNaoGra, {|x| AllTrim(x[1])+AllTrim(x[2]) == AllTrim(aDadosOS[nLineOS][1])+AllTrim(aDadosOS[nLineOS][2]) })
									If nPosAux == 0
										aAdd(aInsNaoGra, { aDadosOS[nLineOS][1], aDadosOS[nLineOS][2], {aTempAux[2]} })
									Else
										aAdd(aInsNaoGra[nPosAux][3], aTempAux[2])
									EndIf
									lProcSTL := .F.
								EndIf
							EndIf

							//Excluir Registro
							If lProcSTL
								dbSelectArea("STL")
								dbSetOrder(1) //TL_FILIAL+TL_ORDEM+TL_PLANO+TL_TAREFA+TL_TIPOREG+TL_CODIGO+TL_SEQRELA
								If dbSeek(cKeySTL)
									If !Empty(STL->TL_NUMSEQ)
										//Faz devoulucao para o estoque
										dbSelectArea("SD3")
										dbSetOrder(4)
										If dbSeek(xFilial("SD3")+STL->TL_NUMSEQ)

											aRetSD3 := MntGeraD3( 'DE1', , , .T., .F., .T. )

											If aRetSD3[2]

												If NGPRODESP( SD3->D3_COD, .F., 'M' )
													NGAtuErp( 'SD3', 'INSERT' )
												EndIf

											Else

												aAdd( aLogRM, { aRetSD3[3], STL->TL_ORDEM, STL->TL_PLANO, STL->TL_TAREFA,;
													STL->TL_TIPOREG, STL->TL_CODIGO, STL->TL_SEQRELA, STL->TL_NUMSEQ } )
												Loop

											EndIf

										EndIf
									EndIf
									If STL->TL_TIPOREG == "P"
										//MOSTRA OS REGISTROS DO HISTORICO PARA EXECLUIR
										NGDELINSLAN(STJ->TJ_CODBEM,STL->TL_DTINICI,STL->TL_HOINICI)
									EndIf
									fNgGarDelete(cOrdem,cPlano,STL->TL_SEQRELA)

									dbSelectArea("STN")
									dbSetOrder(1)
									dbSeek( xFilial("STN") + STL->(TL_ORDEM+TL_PLANO+TL_TAREFA+TL_SEQRELA) )
									While !EoF() .And. STL->(TL_ORDEM+TL_PLANO+TL_TAREFA+TL_SEQRELA) == STN->(TN_ORDEM+TN_PLANO+TN_TAREFA+TN_SEQRELA) .And. ;
									xFilial("STN") == STN->TN_FILIAL

										RecLock("STN",.F.)
										dbDelete()
										STL->(MsUnLock())
										dbSkip()
									EndDo

									dbSelectArea("STL")
									RecLock("STL",.F.)
									dbDelete()
									STL->(MsUnLock())
									If lMNTB4354
										ExecBlock("MNTB4354")
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf

				Next nIndOS

				//Retoma a ordenção pelo campo TL_SEQRELA
				aSort( aDadosOS[nLineOS,5],,,{ |x,y| x[nPos18] < y[nPos18] } )

				If Empty(cQueryIns)

					cQueryIns := "SELECT COUNT( STL.TL_ORDEM ) AS QTD_INS "
					cQueryIns += "FROM "+ RetSqlName( 'STL' ) +" STL "
					cQueryIns += "WHERE STL.TL_FILIAL = ? AND "
					cQueryIns += "STL.TL_ORDEM = ? 		  AND "
					cQueryIns += "STL.TL_SEQRELA > ?      AND "
					cQueryIns += "STL.D_E_L_E_T_ = ' '        "

					cQueryIns := ChangeQuery( cQueryIns )

				EndIf

				aBind := {}
				aAdd( aBind, FwxFilial( 'STL' ) )
				aAdd( aBind, aDadosOs[nLineOs,1] )
				aAdd( aBind, '0' )

				cAliIns := GetNextAlias()

				dbUseArea( .T., 'TOPCONN', TcGenQry2( , , cQueryIns, aBind ), cAliIns, .T., .T. )

				//Se não encontrou, coloca o TJ_TIPORET como vazio
				If ( cAliIns )->QTD_INS == 0

					DbSelectArea( 'STJ' )
					//TJ_FILIAL+TJ_ORDEM+TJ_PLANO+TJ_TIPOOS+TJ_CODBEM+TJ_SERVICO+TJ_SEQRELA
					DbSetOrder(1)
					If DbSeek(FwxFilial('STJ') + aDadosOs[nLineOs,1])

						RecLock('STJ',.F.)

							STJ->TJ_TIPORET := ' '

						STJ->( MsUnlock() )

					EndIf

				EndIf

				( cAliIns )->( dbCloseArea() )

			EndIf //Fim gravacao insumos

			/*-------------------------+
			| Gravacao das Ocorrencias |
			+-------------------------*/
			If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0

				If ( cMemoQry == 'OFF' )

					/*-------------------------------------+
					| Habilita retorno de campos tipo memo |
					+-------------------------------------*/
					TCConfig( 'SETMEMOINQUERY=ON' )

				EndIf

				If Empty( cQryGrvSTN )

					cCast := " STN.TN_DESCRIC, " // INFORMIX

					Do Case
						
						Case cDbase == 'ORACLE'
							
							cCast := " UTL_RAW.CAST_TO_VARCHAR2( dbms_lob.substr( STN.TN_DESCRIC, 2000, 1 ) ) AS TN_DESCRIC "
						
						Case cDbase == 'POSTGRES'
							
							cCast := " COALESCE( CAST( CAST( STN.TN_DESCRIC AS bytea ) AS bytea ), '' ) AS TN_DESCRIC "
							
						Case 'MSSQL' $ cDbase

							cCast := " ISNULL( CAST( CAST( STN.TN_DESCRIC AS VARBINARY( 2000 ) ) AS VARCHAR( 2000 ) ),'') AS TN_DESCRIC "
					
					End Case

					cQryGrvSTN := "SELECT "
					cQryGrvSTN += 	"STN.TN_ORDEM  , "
					cQryGrvSTN += 	"STN.TN_PLANO  , "
					cQryGrvSTN += 	"STN.TN_SEQRELA, "
					cQryGrvSTN += 	"STN.TN_TAREFA , "
					cQryGrvSTN += 	"STN.TN_CODOCOR, "
					cQryGrvSTN += 	"STN.TN_CAUSA  , "
					cQryGrvSTN += 	"STN.TN_SOLUCAO, "
					cQryGrvSTN += 	"STN.RECSTN    , "
					cQryGrvSTN += 	"STN.D_E_L_E_T_ AS DELSTN, "
					cQryGrvSTN +=	cCast 
					cQryGrvSTN += "FROM "
					cQryGrvSTN += 	oTmpTbl8:GetRealName() + " STN "
					cQryGrvSTN += "WHERE "
					cQryGrvSTN += 	"STN.TN_ORDEM   = ? AND "
					cQryGrvSTN += 	"STN.TN_PLANO   = ? "

					cQryGrvSTN := ChangeQuery( cQryGrvSTN )

				EndIf

				aBind := {}

				aAdd( aBind, cOrdem )
				aAdd( aBind, cPlano )

				dbUseArea( .T., 'TOPCONN', TcGenQry2( , , cQryGrvSTN, aBind ), cAlsSTN, .T., .T. )
				
				If (cAlsSTN)->( !EoF() )
					
					While (cAlsSTN)->( !EoF() )
						
						/*--------------------------------------+
						| Posiciona na ocorrência para gravação |
						+--------------------------------------*/
						If !( lFound := Empty( (cAlsSTN)->RECSTN ) )

							dbSelectArea( 'STN' )
							dbGoTo( (cAlsSTN)->RECSTN )

						EndIf

						/*------------------------+
						| Exclusão de ocorrências |
						+------------------------*/
						If !Empty( (cAlsSTN)->DELSTN )

							If !Empty( (cAlsSTN)->RECSTN )
							
								RecLock( 'STN', .F. )

									dbDelete()

								STN->( MsUnLock() )

							EndIf

						/*-------------------------------------+
						| Inclusão ou Alteração de ocorrências |
						+-------------------------------------*/
						Else

							RecLock( 'STN', lFound )

								STN->TN_FILIAL  := FWxFilial( 'STN' )
								STN->TN_ORDEM   := (cAlsSTN)->TN_ORDEM
								STN->TN_PLANO   := (cAlsSTN)->TN_PLANO
								STN->TN_TAREFA  := (cAlsSTN)->TN_TAREFA
								STN->TN_SEQRELA := (cAlsSTN)->TN_SEQRELA
								STN->TN_CODOCOR := (cAlsSTN)->TN_CODOCOR
								STN->TN_CAUSA   := (cAlsSTN)->TN_CAUSA
								STN->TN_SOLUCAO := (cAlsSTN)->TN_SOLUCAO
								STN->TN_DESCRIC := (cAlsSTN)->TN_DESCRIC

							STN->( MsUnLock() )

						EndIf

						(cAlsSTN)->( dbSkip() )

					End

					If ( nLinOS := aScan( aDadosOS, { |x| x[1] + x[2] == cOrdem + cPlano } ) )
						
						aDadosOS[nLinOS,_OCCURRENCES_] := {}

					EndIf

					/*--------------------------------------------+
					| Faz o reset das informações de ocorrências. |
					+--------------------------------------------*/
					NGZap( oTmpTbl8:GetRealName(), "TN_ORDEM = " + ValToSQL( cOrdem ) +;
						" AND TN_PLANO = " + ValToSQL( cPlano ) )

				EndIf

				(cAlsSTN)->( dbCloseArea() )

				If ( cMemoQry == 'OFF' )

					/*-------------------------------------+
					| Habilita retorno de campos tipo memo |
					+-------------------------------------*/
					TCConfig( 'SETMEMOINQUERY=OFF' )

				EndIf

			Else

				If ValType( aDadosOS[nLineOS,5] ) == 'A'

					For nIndOS := 1 to Len(aDadosOS[nLineOS,5])
						
						aArrayTmp := aDadosOS[ nLineOS,5,nIndOS, Len(aDadosOS[nLineOS,5,nIndOS])-1  ]
						If Valtype(aArrayTmp) <> "A" .Or. aDadosOS[ nLineOS,5,nIndOS, Len(aDadosOS[nLineOS,5,nIndOS]) ]
							Loop
						EndIf

						//Excluindo os motivos que foram retirados da tela
						//TN_FILIAL+TN_ORDEM+TN_PLANO+TN_TAREFA+TN_SEQRELA+TN_CODOCOR+TN_CAUSA+TN_SOLUCAO
						dbSelectArea("STN")
						dbSetOrder(1)
						dbSeek(xFilial("STN")+cOrdem+cPlano+aDadosOS[nLineOS,5,nIndOS,nPos16]+aDadosOS[nLineOS,5,nIndOS,nPos18])
						While !EoF() .And. xFilial("STN")+cOrdem+cPlano      == STN->(TN_FILIAL+TN_ORDEM+TN_PLANO) .And. ;
						aDadosOS[nLineOS,5,nIndOS,nPos16] == STN->TN_TAREFA .And. ;
						aDadosOS[nLineOS,5,nIndOS,nPos18] == STN->TN_SEQRELA

							If aScan(aArrayTmp ,{|x| x[nOcoCo] == STN->TN_CODOCOR .And. x[nOcoCa] == STN->TN_CAUSA .And. ;
							x[nOcoSo] == STN->TN_SOLUCAO .And. !x[Len(x)] }) == 0
								RecLock("STN",.F.)
								dbDelete()
								STN->(MsUnLock())
							EndIf

							dbSelectArea("STN")
							dbSkip()
						EndDo

						//Os registros deletados serão os primeiros da lista
						aSort(aArrayTmp,,,{|x,y| x[Len(x)] .And. !y[Len(y)] })
						For nIndOS2 := 1 to Len(aArrayTmp)

							If Empty(aArrayTmp[nIndOS2,nOcoCo]) //Nao validar se codigo vazio
								Loop
							EndIf

							cKeySTN := xFilial("STN")+cOrdem+cPlano+aDadosOS[nLineOS,5,nIndOS,nPos16]+aDadosOS[nLineOS,5,nIndOS,nPos18]
							cKeySTN += aArrayTmp[nIndOS2,nOcoCo] + aArrayTmp[nIndOS2,nOcoCa] + aArrayTmp[nIndOS2,nOcoSo]

							//Se nao for deletado
							If !aArrayTmp[nIndOS2][Len(aArrayTmp[nIndOS2])]

								lSTN_Lock := .T.
								dbSelectArea("STN")
								dbSetOrder(1)
								lSTN_Lock := !dbSeek(cKeySTN)
								RecLock("STN",lSTN_Lock)

								For nIndSTN := 1 TO FCount()
									If Alltrim(FieldName(nIndSTN)) $ "TN_FILIAL/TN_ORDEM/TN_PLANO/TN_TAREFA/TN_SEQRELA"
										Loop
									EndIf
									nPosTmp := aScan(aHoBrw3, {|x| AllTrim(Upper(X[2])) == FieldName(nIndSTN) })
									y  := "STN->" + FieldName(nIndSTN)
									If nPosTmp > 0
										x  := "M->" + FieldName(nIndSTN)
										&x.:= aArrayTmp[nIndOS2,nPosTmp]
										&y := &x
									ElseIf lSTN_Lock
										&y := CriaVar(FieldName(nIndSTN))
									EndIf
								Next nIndSTN
								STN->TN_FILIAL  := xFilial("STN")
								STN->TN_ORDEM   := cOrdem
								STN->TN_PLANO   := cPlano
								STN->TN_TAREFA  := aDadosOS[nLineOS,5,nIndOS,nPos16]
								STN->TN_SEQRELA := aDadosOS[nLineOS,5,nIndOS,nPos18]
								STN->(MsUnLock())
							Else

								dbSelectArea("STN")
								dbSetOrder(1)
								If dbSeek(cKeySTN)
									RecLock("STN",.F.)
									dbDelete()
									STN->(MsUnLock())
								EndIf

							EndIf

						Next nIndOS2
					Next nIndOS

				EndIf

			EndIf

			//Gerar SA
			If Len(aDadosSA) > 0
				nLineSA := aScan(aDadosSA, {|x|x[1]+x[2] == cOrdem+cPlano })
				If nLineSA > 0
					For nxSA := nLineSA To Len(aDadosSA)
						//Se terminar as SA da OS
						If aDadosSA[nxSA,1]+aDadosSA[nxSA,2] != cOrdem+cPlano
							Exit
						EndIf

						//Se estiver deletado
						If !aDadosSA[nxSA,13]
							Loop
						EndIf

						nItemSA++

						dbSelectArea("SCP")
						If nItemSA > 99
							nItemSA := 1
							cNumSA  := " "
						EndIf

						RecLock("SCP",.T.)
						SCP->CP_FILIAL  := xFilial("SCP")

						If Empty(cNumSA)
							cNumSA := GetSxeNum("SCP","CP_NUM")
							ConfirmSX8()
						EndIf
						SCP->CP_NUM     := cNumSA
						SCP->CP_ITEM    := StrZero(nItemSA,2)
						SCP->CP_PRODUTO := aDadosSA[nxSA,03]
						SCP->CP_UM      := aDadosSA[nxSA,04]
						SCP->CP_QUANT   := aDadosSA[nxSA,05]
						SCP->CP_DATPRF  := aDadosSA[nxSA,06]
						SCP->CP_LOCAL   := aDadosSA[nxSA,07]
						SCP->CP_OP      := aDadosSA[nxSA,08]
						SCP->CP_CC      := aDadosSA[nxSA,09]
						SCP->CP_EMISSAO := aDadosSA[nxSA,10]
						SCP->CP_DESCRI  := aDadosSA[nxSA,11]
						SCP->CP_SOLICIT := aDadosSA[nxSA,12]

						SCP->(MsUnLock())

						//Mensagem Unica
						If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"
							If cNGMNTAS == "1"
								cNumCP := SCP->CP_NUM
							Else
								NGMUReques(SCP->(RecNo()),"SCP",.F.,3)
							EndIf
						EndIf

					Next nxSA
				Endif

				If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"
					If cNGMNTAS == "1"
						If !Empty(cNumCP) .And. NGIFDBSEEK( "SCP",cNumCP,01,.F. )
							NGMUReques( SCP->( RecNo()),"SCP",.F.,3 )
						EndIf
					EndIf
				EndIf
			EndIf//Fim Geracao SA

			/*-------------------+
			| Gravação de Etapas |
			+-------------------*/
			If ValType(aDadosOS[nLineOS,8]) == "A"

				//Excluindo as etapas que foram retirados da tela
				dbSelectArea("STQ")
				dbSetOrder(1)
				dbSeek( xFilial("STQ") + cOrdem + cPlano )
				While !EoF() .And. xFilial("STQ") + cOrdem + cPlano == STQ->( TQ_FILIAL + TQ_ORDEM + TQ_PLANO )

					If aScan( aDadosOS[nLineOS,8], { |x| !Empty( x[nRecSTQ] ) .And.;
						x[nRecSTQ] == STQ->( RecNo() ) } ) == 0
						
						dbSelectArea("TPQ")
						dbSetOrder(1)
						If dbSeek( xFilial("TPQ") + cOrdem + cPlano + STQ->TQ_TAREFA + STQ->TQ_ETAPA )
							While !EoF() .And. TPQ->TPQ_FILIAL == xFilial("TPQ") .And.;
							TPQ->TPQ_ORDEM == cOrdem .And. TPQ->TPQ_PLANO == cPlano .And.;
							TPQ->TPQ_TAREFA == STQ->TQ_TAREFA .And. TPQ->TPQ_ETAPA  == STQ->TQ_ETAPA

								RecLock("TPQ", .F.)
								dbDelete()
								TPQ->( MsUnLock() )

								dbSelectArea("TPQ")
								dbSkip()
							EndDo

						EndIf

						RecLock( 'STQ', .F. )

							dbDelete()

						STQ->( MsUnLock() )

					EndIf

					dbSelectArea("STQ")
					dbSkip()

				End

				For nIndOS := 1 to Len(aDadosOS[nLineOS,8])

					aVetTemp  := aDadosOS[nLineOS,8,nIndOS]
					nPosArray := aScan( aVetTemp, { |x| ValType( x ) == 'A' } )

					If Empty(aVetTemp[nEtaTa]) .And. Empty(aVetTemp[nEtapa])
						Loop
					EndIf

					cORDSTJ := STJ->TJ_ORDEM
					cPLASTJ := STJ->TJ_PLANO
					cBEMSTJ := STJ->TJ_CODBEM
					cSERSTJ := STJ->TJ_SERVICO
					nSEQSTJ := STJ->TJ_SEQRELA
					nSEQOLD := STJ->TJ_SEQRELA
					cBEMOLD := STJ->TJ_CODBEM
					cSEROLD := STJ->TJ_SERVICO

					nSEQSTJ := nSEQOLD

					If Empty( aVetTemp[nRecSTQ] )
						
						RecLock( 'STQ', .T. )

							STQ->TQ_FILIAL  := FWxFilial( 'STQ' )
							STQ->TQ_ORDEM   := cOrdem
							STQ->TQ_PLANO   := cPlano
							STQ->TQ_OK      := aVetTemp[nOkSTQ]

							If STQ->( FieldPos( 'TQ_SEQRELA' ) ) > 0
								
								STQ->TQ_SEQRELA := aVetTemp[nSeqSTQ]

							EndIf

							For i := 1 To Len( aTRBQ )

								If !( AllTrim( aTRBQ[i,2] ) $ 'TQ_FILIAL/TQ_ORDEM/TQ_PLANO' ) .And.;
									Posicione( 'SX3', 2, aTRBQ[i,2], 'X3_CONTEXT' ) != 'V'

									xx := AllTrim( aTRBQ[i,2] )
									&( 'STQ->' + xx ) := aVetTemp[i]

								EndIf

							Next i

						STQ->( MsUnLock() )

					Else

						STQ->( msGoTo( aVetTemp[nRecSTQ] ) )

						RecLock( 'STQ', .F. )

							STQ->TQ_OK := aVetTemp[nOkSTQ]

							If STQ->( FieldPos( 'TQ_SEQRELA' ) ) > 0
								
								STQ->TQ_SEQRELA := aVetTemp[nSeqSTQ]

							EndIf

							For i := 1 To Len( aTRBQ )

								If !( Alltrim(aTRBQ[i,2] ) $ 'TQ_FILIAL/TQ_ORDEM/TQ_PLANO/TQ_TAREFA/TQ_ETAPA/TQ_OK' ) .And.;
									Posicione( 'SX3', 2, aTRBQ[i,2], 'X3_CONTEXT' ) != 'V'

									xx := AllTrim( aTRBQ[i,2] )
									&( 'STQ->' + xx ) := aVetTemp[i]

								EndIf

							Next i

						STQ->( MsUnLock() )

					EndIf

					If STQ->( FieldPos( 'TQ_SEQRELA' ) ) > 0

						/*----------------------------------------+
						| Define as cores para legenda de etapas. |
						+----------------------------------------*/
						fLegendEt( STQ->TQ_ORDEM + STQ->TQ_PLANO + STQ->TQ_TAREFA +;
							STQ->TQ_ETAPA + STQ->TQ_SEQRELA, 4 )

					Else

						/*----------------------------------------+
						| Define as cores para legenda de etapas. |
						+----------------------------------------*/
						fLegendEt( STQ->TQ_TAREFA + STQ->TQ_ETAPA + STQ->TQ_SEQETA )

					EndIf

					//Opções de resposta das etapas. Verifica se house marcação anteriormente
					aArray  := {}
					aArray2 := {}
					
					If Empty( aVetTemp[nOkSTQ] )

						dbSelectArea("TPQ")
						dbSetOrder(1)
						dbSeek(xFilial("TPQ")+cOrdem+cPlano+aVetTemp[nEtaTa]+aVetTemp[nEtapa])
						While !EoF() .And. TPQ->TPQ_FILIAL == xFilial("TPQ") .And.;
						TPQ->TPQ_ORDEM == cOrdem .And. TPQ->TPQ_PLANO == cPlano .And. ;
						TPQ->TPQ_TAREFA == aVetTemp[nEtaTa] .And. TPQ->TPQ_ETAPA  == aVetTemp[nEtapa]

							RecLock("TPQ",.F.)
							dbDelete()
							TPQ->(MsUnLock())
							dbSelectArea("TPQ")
							dbSkip()
						EndDo

					Else

						//Excluindo as opções retiradas da tela
						dbSelectArea("TPQ")
						dbSetOrder(1)
						dbSeek(xFilial("TPQ") + cOrdem + cPlano + aVetTemp[nEtaTa] + aVetTemp[nEtapa])
						While !EoF() .And. TPQ->TPQ_FILIAL == xFilial("TPQ") .And.;
						TPQ->TPQ_ORDEM == cOrdem .And. TPQ->TPQ_PLANO == cPlano .And. ;
						TPQ->TPQ_TAREFA == aVetTemp[nEtaTa] .And. TPQ->TPQ_ETAPA  == aVetTemp[nEtapa]

							If aScan(aVetTemp[nPosArray] ,{|x| !Empty(x[1]) .And. x[2] == TPQ->TPQ_OPCAO }) == 0
								dbSelectArea("TPQ")

								RecLock("TPQ",.F.)
								dbDelete()
								TPQ->(MsUnLock())
							EndIf

							dbSelectArea("TPQ")
							dbSkip()
						EndDo

						lPrimVez := .T.
						For nXX := 1 To Len(aVetTemp[nPosArray])

							If Empty( aVetTemp[nPosArray , nXX , 1] )
								Loop
							EndIf

							nSEQSTF   := nSEQOLD
							cBEMSTJ   := cBEMOLD
							lTpGeraOS := .F.
							lTPGeraSS := .F.

							cTpcMark   := aVetTemp[nPosArray,nXX,1]
							cTpcRespos := aVetTemp[nPosArray,nXX,3]
							cTpcOpcao  := aVetTemp[nPosArray,nXX,2]

							dbSelectArea("TPC")
							dbSetOrder(1)
							If !dbSeek(xFilial("TPC") + aVetTemp[nEtapa] + cTpcOpcao )
								Loop
							EndIf

							lAltTPQ := .F. //Indica se a Resposta da Etapa é nova ou foi modificada
							lTPQ_OS := .F. //Indica se a Resposta da Etapa que está sendo modificada, já tinha gerado OS antes
							lGerTPQ := .F. //Indica se a Resposta da Etapa que está sendo modificada não deve gerar OS

							dbSelectArea("TPQ")
							dbSetOrder(1)
							If !dbSeek(xFilial("TPQ")+ cOrdem+ cPlano+ aVetTemp[nEtaTa]+ aVetTemp[nEtapa]+ cTpcOpcao )
								RecLock("TPQ",.T.)
								TPQ->TPQ_FILIAL := xFilial("TPQ")
								TPQ->TPQ_ORDEM  := cOrdem
								TPQ->TPQ_PLANO  := cPlano
								TPQ->TPQ_TAREFA := aVetTemp[nEtaTa]
								TPQ->TPQ_ETAPA  := aVetTemp[nEtapa]
								TPQ->TPQ_OPCAO  := cTpcOpcao
								TPQ->TPQ_RESPOS := cTpcRespos
								TPQ->TPQ_OK     := cTpcMark
								TPQ->(MsUnLock())
								lAltTPQ := .T.
							Else
								RecLock("TPQ",.F.)
								If Alltrim(TPQ->TPQ_RESPOS) <> Alltrim(cTpcRespos)
									lAltTPQ := .T.
									If !Empty(TPQ->TPQ_ORDEMG)
										lTPQ_OS := .T.
									EndIf
								EndIf
								TPQ->TPQ_RESPOS := cTpcRespos
								TPQ->TPQ_OK     := cTpcMark
								TPQ->(MsUnLock())
							EndIf

							cSerSTJ := TPC->TPC_SERVIC

							If TPC->TPC_TPMANU == '1'
								lTpGeraOS := .T.
								cTipoMan  := NGSEEK( "ST4", TPC->TPC_SERVIC, 1, "T4_TIPOMAN")
								cServCar  := NGSEEK( "STE", cTipoMan, 1, "TE_CARACTE")

							ElseIf TPC->TPC_TPMANU == '2'
								lTPGeraSS := .T.
							EndIf

							//Identificação da geração da Ordem
							If TPC->TPC_PORBEM == '2'
								cBemOr := Space( TAMSX3("T9_CODBEM")[1] )

								If !Empty(TPC->TPC_DESCRI)

									cBemOr := SubStr( TPC->TPC_DESCRI, 1, TAMSX3("T9_CODBEM")[1] )

									dbSelectArea("ST9")
									dbSetOrder(1)
									If !dbSeek(xFilial("ST9") + cBEMOR)
										cBemOr := Space( TAMSX3("T9_CODBEM")[1] )
									Else
										If lTpGeraOS
											If cServCar == 'P' // O.S. Preventiva
												nSeqSTJ := IIf( Alltrim(nSeqSTJ) == "0", "1  ", nSeqSTJ )
												dbSelectArea("STF")
												dbSetOrder(1)
												If !dbSeek(xFilial("STF") + cBemOr + cSerSTJ + nSeqSTJ)
													cBemOr := Space( TAMSX3("T9_CODBEM")[1] )
												EndIf
											EndIf
										EndIf
									EndIf
								EndIf
								cBemSTJ := IIf( Empty(cBemOr), cBemSTJ, cBemOr )
							EndIf

							//Processa a geração de O.S.
							If !NG400VALOS(,TPC->TPC_SERVIC, .T.)
								If TPC->TPC_TIPRES == '2' .And. lAltTPQ // INFORMADA
									If !Empty(cTpcRespos)

										dbSelectArea("TPC")
										dbSetOrder(1)
										If dbSeek( xFilial("TPC") + aVetTemp[nEtapa] + cTPCOpcao )

											lCondicao := .F.

											Do Case
												Case TPC->TPC_TIPCAM == "L"
												cResp := AllTrim( cTpcRespos )
												Case TPC->TPC_TIPCAM == "N"
												cResp := cValToChar( Val( cTpcRespos ) )
												Case TPC->TPC_TIPCAM == "D"
												cResp := "'" + DToS( cToD( cTpcRespos ) ) + "'"
												Case TPC->TPC_TIPCAM == "C"
												cResp := "'" + AllTrim( cTpcRespos ) + "'"
											EndCase

											cForm := StrTran( TPC->TPC_FORMUL, '#RESP#', cResp )

											lCondicao := &( cForm )
										EndIf
									EndIf
								EndIf

								If lCondicao .Or. ( TPC->TPC_TIPRES == '1' .And. lAltTPQ )
									xx := aScan(aArray, {|x|(x[1]+x[2]) == cTpcOpcao + aVetTemp[nEtaTa] })
									xy := aScan(aArray2,{|x|(x[1]+x[2]) == cTpcRespos + aVetTemp[nEtaTa] })

									If lTPGeraOs
										If cServCar $ "P/O" .And. xx == 0  .And. xy == 0

											//--inicio--OS 024720 //
											/*
											Verifica se é a primeira que está passando por esse for.
											Caso for, lPrimVez se torna false para o proximo loop, assim como
											cChavAnt recebe a chave atual do OS. (Codigo do Bem e Serviço).
											Caso não seja a primeira vez, irá verificar se a chave atual é a mesma
											que a chave anterior, caso seja, considerará que está repetindo a OS, setando
											para True a váriavel lOSRepet, para que não faça a inclusão de uma nova OS
											para a mesma chave.
											Casa não seja a mesma chave a ser gerada, lOSRepet recebe False, para fazer
											uma nova inclusão de OS. E a chave atual se torna a chave anterior.
											Logica feita tanto para OSs Preventivas, quanto para Corretivas.
											SS: 024720
											Autor: Maicon André Pinheiro
											Data 11/02/2016
											*/
											If lPrimVez
												lPrimVez := .F.
												cChavAnt := STJ->TJ_CODBEM+STJ->TJ_SERVICO
											Else

												If STJ->TJ_CODBEM+STJ->TJ_SERVICO == cChavAnt
													lOSRepet := .T.
												Else
													lOSRepet := .F.
													cChavAnt := STJ->TJ_CODBEM+STJ->TJ_SERVICO
												EndIf
											EndIf
											//---fim----OS 024720 //

											//Deve gerar OS
											lGerTPQ := .T.

											//Se nao tinha gerado OS
											If !lTPQ_OS .And. lOSRepet == .F.
												cVPREVEN := fNG435GPRE( '2', cOrdem, nEtaTa, nEtapa, cServCar)
												If cVPREVEN[1]
													dbSelectArea("TPQ")
													dbSetOrder(1)
													If dbSeek(xFilial("TPQ") + cOrdem + cPlano + aVetTemp[nEtaTa] + aVetTemp[nEtapa] + cTpcOpcao )
														RecLock("TPQ", .F.)
														TPQ->TPQ_ORDEMG := cVPREVEN[2]
														TPQ->(MsUnLock())
													EndIf
												EndIf
											EndIf
										ElseIf cServCar == "C" .And. xx == 0  .And. xy == 0

											//--inicio--OS 024720 //
											If lPrimVez
												lPrimVez := .F.
												cChavAnt := STJ->TJ_CODBEM+STJ->TJ_SERVICO
											Else

												If STJ->TJ_CODBEM+STJ->TJ_SERVICO == cChavAnt
													lOSRepet := .T.
												Else
													lOSRepet := .F.
													cChavAnt := STJ->TJ_CODBEM+STJ->TJ_SERVICO
												EndIf
											EndIf
											//---fim----OS 024720 //

											//Deve gerar OS
											lGerTPQ := .T.

											//Se não tinha gerado OS
											If !lTPQ_OS .And. lOSRepet == .F.
												cVOSCORR := fNG435GCOR( '2', cOrdem, nEtaTa, nEtapa, cServCar)
												If cVOSCORR[1]
													dbSelectArea("TPQ")
													dbSetOrder(1)
													If dbSeek(xFilial("TPQ") + cOrdem + cPlano + aVetTemp[nEtaTa] + aVetTemp[nEtapa]+ cTpcOpcao )
														RecLock("TPQ", .F.)
														TPQ->TPQ_ORDEMG := cVOSCORR[2]
														TPQ->(MsUnLock())
													EndIf
												EndIf
											EndIf
										EndIf
									ElseIf lTPGeraSS

										cMsgSS := STR0044 + ": " + STJ->TJ_ORDEM + Chr(13) + Chr(10)		//"O.S. Origem"
										cMsgSS += STR0025 + ": " + aVetTemp[nEtapa] + Chr(13) + Chr(10)	//"Etapa"
										cMsgSS += STR0045 + ": " + cTpcOpcao + Chr(13) + Chr(10)			//"Opção"

										If TPC->TPC_TIPRES == '2'
											cMsgSS += STR0047 + ": " + cTpcRespos //"Resposta"
										Else
											cMsgSS += STR0048 + ": " + STR0049 //"Marcou" ## "Sim"
										EndIf

										If lMNTA435M
											cMsgSS += ExecBlock( "MNTA435M",.F.,.F.,{ cMsgSS, STJ->TJ_CODBEM, STJ->TJ_ORDEM, STJ->TJ_PLANO, ;
																					aVetTemp[nEtaTa], aVetTemp[nEtapa], aVetTemp[nEtSeq] } )
										EndIf

										// aSolic := { Código do Bem, Ramal, Descrição da Solicitação, Serviço }
										aSolic := { { "TQB_CODBEM", cBemSTJ, Nil },;
										{ "TQB_RAMAL" , "0000", Nil },;
										{ "TQB_DESCSS", cMsgSS, Nil },;
										{ "TQB_CDSERV", TPC->TPC_SERVIC, Nil } }

										lMSHelpAuto := .T. // Não apresenta erro em tela
										lMSErroAuto := .F. // Caso a variável torne-se .T. apos MsExecAuto, apresenta erro em tela

										MSExecAuto( {|x,z,y,w| MNTA280(x,z,y,w)},,, aSolic )

										If lMsErroAuto
											MostraErro()

										ElseIf !Empty( TQB->TQB_SOLICI )
											MsgInfo( STR0271 ) //"Foi gerada uma S.S. conforme a resposta da etapa!"

											dbSelectArea("TPQ")
											dbSetOrder(01)
											If dbSeek( xFilial("TPQ") + cOrdem + cPlano + aVetTemp[nEtaTa] + aVetTemp[nEtapa] + cTpcOpcao )
												RecLock( "TPQ", .F.)
												TPQ->TPQ_ORDEMG := TQB->TQB_SOLICI
												MsUnlock("TPQ")
											EndIf
										EndIf
									EndIf
								EndIf
							EndIf

							If !lGerTPQ //Se esta Resposta não deve gerar OS
								If lTPQ_OS //Se esta Resposta gerou OS anteriormente
									dbSelectArea("TPQ")
									dbSetOrder(01)
									If dbSeek(xFilial("TPQ") + cOrdem + cPlano + aVetTemp[nEtaTa] + aVetTemp[nEtapa] + cTpcOpcao )
										RecLock("TPQ",.F.)
										TPQ->TPQ_ORDEMG := Space( TAMSX3("TPQ_ORDEMG")[1] )
										TPQ->(MsUnLock())
									EndIf
								EndIf
							EndIf

						Next nXX //Fim laço das opções da etapa/tarefa
					EndIf //Fim se estiver concluido etapa/tarefa
				Next nIndOS //Fim laço etapa/tarefa
			EndIf

			//Retira da getdados os registros deletados
			If lRefBrow .And. ValType(aDadosOS[nLineOS,5]) == "A"

				aTmpCol := aClone( aDadosOS[nLineOS, 5] )
				aDadosOS[nLineOS,5] := {}

				//Inclue no array de insumos, somente os que não estão deletados
				For nIndOS := 1 to Len( aTmpCol )

					If !aTmpCol[nIndOS, Len( aTmpCol[nIndOS] )]
						aAdd( aDadosOS[nLineOS,5] , aClone( aTmpCol[nIndOS] ) )
					EndIf

				Next nIndOS

				//Caso algum insumo tenha apresentado erro ao ser deletado, este será mantido no array de insumos.
				If !Empty( aLogRM )

					For nErro := 1 to Len( aLogRM )

						If aDadosOS[nLineOS, 1] == aLogRM[nErro, 2] .And. aDadosOS[nLineOS, 2] == aLogRM[nErro, 3]

							nFound  := aScan( aTmpCol, { |x| x[nPos18] == aLogRM[nErro, 7] } )

							If nFound > 0 .And. aScan( aDadosOS[nLineOS,5], { |x| x[nPos18] == aLogRM[nErro, 7] } ) == 0

								//Armazena posição do insumo e o array do insumo para que este não seja copiado para o array de insumos já gravados
								aNoCopy := { nFound, aDadosOS[nLineOS, 4, nFound] }

								aAdd( aDadosOS[nLineOS,5] , aClone( aTmpCol[nFound] ) )

							EndIf

						EndIf

					Next nErro

				EndIf

				// Reordena aCols conforme TL_SEQRELA
				If nPos18 > 0
					aSort( aDadosOS[nLineOS,5],,, { |x,y| x[nPos18] < y[nPos18] } )
				EndIf

				//Faz a copia do conteudo do Array de insumos alterados [5] para o array de insumos já gravados [4]
				If Len(aDadosOS[nLineOS,5]) > 0

					/*-----------------------------------------------------------------------------------+
					| Em caso de inconsitência nos processos a seguir, o array de controle é restaurado. |
					+-----------------------------------------------------------------------------------*/
					aAdd( aRollBack, { nLineOS, aClone( aDadosOS[nLineOS] ) } )

					aDadosOS[nLineOS,4] := aClone(aDadosOS[nLineOS,5])

					//Caso tenha algum que não pode ser gavado efetivamente, retorna o backup da posição correta do insumo.
					If !Empty( aNoCopy )

						//Importante que para o funcionamento os arrays estejam ordenados por TL_SEQRELA.
						For nCopy := 1 To Len( aNoCopy )

							aDadosOS[nLineOS, 4, aNoCopy[1]] := aClone( aNoCopy[2] )

						Next nCopy

					EndIf

				Else

					/*-----------------------------------------------------------------------------------+
					| Em caso de inconsitência nos processos a seguir, o array de controle é restaurado. |
					+-----------------------------------------------------------------------------------*/
					aAdd( aRollBack, { nLineOS, aDadosOS[nLineOS] } )

					aDadosOS[nLineOS,4] := aClone( aNovoSTL )
					
					aDadosOS[nLineOS,5] := Nil

				EndIf

			EndIf

			If lCanOrFin
				exit
			Else
				(cAliOS435)->( dbSkip() )
			EndIf

		EndDo

		//Executa as requisicoes de uma so vez
		For nX := 1 To Len(aReqSD3)
			dbSelectArea("STL")
			dbSetOrder(1)
			dbGoTo(aReqSD3[nX,1])
			If !EoF() .And. !Bof()

				// Posicionamento na STJ exigido, devido ao processo de gravacao da função MNTGERAD3
				If NGIFDBSEEK("STJ",STL->TL_ORDEM + STL->TL_PLANO,1)

					/*----------------------------------------------------------------------------------------------------+
					| Salva valores da STL antes da função MntGeraD3, pois ao integrar com RM o registro pode ser perdido |
					+----------------------------------------------------------------------------------------------------*/
					cRMTaref := STL->TL_TAREFA
					cRMTipoR := STL->TL_TIPOREG
					cRMCodIn := STL->TL_CODIGO
					cRMSeqre := STL->TL_SEQRELA
					cRMNumse := STL->TL_NUMSEQ

					aRetSD3 := MntGeraD3( 'RE0', aReqSD3[nX,2], , .T., .F., .T. )

					If aRetSD3[2]

						dbSelectArea( 'STL' )
						RecLock( 'STL', .F. )

							STL->TL_NUMSEQ := aRetSD3[1]

							If !lNGCALCUSTI

								STL->TL_CUSTO  := SD3->D3_CUSTO1

							EndIf

							If lMMoeda
								STL->TL_MOEDA := '1'
							EndIf

						STL->( MsUnLock() )

						If NGPRODESP( SD3->D3_COD, .F., 'M' )
							NGAtuErp( 'SD3', 'INSERT' )
						EndIf

					Else

						aAdd( aLogRM, { aRetSD3[3], STJ->TJ_ORDEM, STJ->TJ_PLANO, cRMTaref,;
							cRMTipoR, cRMCodIn, cRMSeqre, cRMNumse } )

						If lRefBrow

							If nPosArr := aScan( aRollBack, { |x| x[2,1] == STJ->TJ_ORDEM } )

								aDadosOS[aRollBack[nPosArr,1],4] := aClone( aRollBack[nPosArr,2,4] )

							EndIf

						EndIf

						Loop

					EndIf

				EndIf
			EndIf
		Next nX

		//Retira da getdados os registros deletados
		If lRefBrow

			aTmpCol := aClone( aCoBrw6 )
			aCoBrw6 := {}

			For nX := 1 To Len( aTmpCol )

				If !aTmpCol[nX,Len(aTmpCol[nX])]
					aAdd( aCoBrw6, aClone( aTmpCol[nX] ) )
				EndIf

			Next nX

			//Caso algum registro não pode ser deletado, ele retorno com a mesma condição.
			If !Empty( aLogRM )

				For nErro := 1 to Len( aLogRM )

					If cOrdem == aLogRM[nErro, 2] .And. cPlano == aLogRM[nErro, 3]

						nFound := aScan( aTmpCol, { |x| x[nPos18] == aLogRM[nErro, 7] } )

						If nFound > 0
							aAdd( aCoBrw6 , aClone( aTmpCol[nFound] ) )
						EndIf

					EndIf

				Next nErro

			EndIf

			// Reordena aCols conforme TL_SEQRELA
			If nPos18 > 0
				aSort( aCoBrw6,,, { |x,y| x[nPos18] < y[nPos18] } )
			EndIf

			If Len( aCoBrw6 ) == 0

				aCoBrw6 := aClone( aNovoSTL )
				
				// propriedade que valida se foi alterado utilizada no linok
				oBrw6:lModified := .F.

			EndIf

			If oBrw6:lModified .And. Len( aCoBrw6 ) != Len( aTmpCol )
				// propriedade que valida se foi alterado utilizada no linok
				oBrw6:lModified := .F.
			EndIf

			If nPosGrt > 0 .And. Len(aCols) > 0

				If Len(aCols[1]) >= nPosGrt

					aTmpCol := aClone( aCols )
					aCols   := {}

					For nX := 1 To Len( aTmpCol )

						If !aTmpCol[nX,Len( aTmpCol[nX] )]
							aAdd( aCols , aClone( aTmpCol[nX] ) )
						EndIf
					Next nX

					//Caso algum registro não pode ser deletado, ele retorno com a mesma condição.
					If !Empty( aLogRM )

						For nErro := 1 to Len( aLogRM )

							If cOrdem == aLogRM[nErro, 2] .And. cPlano == aLogRM[nErro, 3]

								nFound := aScan( aTmpCol, { |x| x[nPos18] == aLogRM[nErro, 7] } )

								If nFound > 0
									aAdd( aCols , aClone( aTmpCol[nFound] ) )
								EndIf

							EndIf

						Next nErro

					EndIf

					// Reordena aCols conforme TL_SEQRELA
					If nPos18 > 0
						aSort( aCols,,, { |x,y| x[nPos18] < y[nPos18] } )
					EndIf

					If Len( aCols ) == 0

						aCols := aClone( aNovoSTL )
						
						// propriedade que valida se foi alterado utilizada no linok
						oBrw6:lModified := .F.

					EndIf

					If oBrw6:lModified .And. Len( aCols ) != Len( aTmpCol )
						// propriedade que valida se foi alterado utilizada no linok
						oBrw6:lModified := .F.
					EndIf

				EndIf
			EndIf

			oBrw6:oBrowse:Refresh()
			oBrw6:oBrowse:SetFocus()

		EndIf

		// Apresentação em lote de inconsitências encontradas.
		If !Empty( aLogRM ) .Or. !Empty( aLogNoCanc )

			MNTA435Log( aLogRM, aLogNoCanc )

			DisarmTransaction()
			lRet := .F.

		EndIf

	End Transaction

	// Corrige posicionamento do browse
	RestArea( aAreaAlOs )
	RestArea( aAreaSTJ )

	If ExistBlock("MNTA4354")
		ExecBlock("MNTA4354",.F.,.F.,{aHoBrw6,aInsNaoGra})
	EndIf

	CursorArrow()

	/*-----------------------------------------------------
	Mostra browse com as OS geradas atraves das etapas
	-----------------------------------------------------*/
	dbSelectArea(cTRBZ400)
	dbGoTop()
	If !EoF()
		aTRBZ := aClone(aTRBZ435)
		NGMOSTTRBZ()
	EndIf

	dbSelectArea(cTRBK400)
	dbGotop()
	If Reccount() > 0
		NGTRBKMOST()
	EndIf

	//Deleção Tabela Temporária
	oTmpTbl1:Delete()
	oTmpTbl2:Delete()

	lFoiAlterado := .F.

	aProd435   := {} //Produtos atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	aLote435   := {} //LOTE atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	aSubL435   := {} //SUB-LOTE atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	aEnde435   := {} //ENDERECAMENTO atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	aDadosTPZ  := {} //Garantia de Insumos Temporario
	aNBaixaEst := {} //Insumos que não efetuarão baixa no estoque - Ponto de Entrada MNT4356

	PutFileInEOF( 'STL' )
	PutFileInEOF( 'STN' )
	PutFileInEOF( 'STQ' )
	PutFileInEOF( 'TPL' )

	/*-------------------------------------------------------------------------------------------+
	| Não deve carregar informações quando ação do click vier dos botões: oBtOK, oBtCOS, oBtFOS. |
	+-------------------------------------------------------------------------------------------*/
	If lLoadIns

		/*-------------------------------------------------------------------+
		| Recarrega informações de insumos realizados para O.S. posicionada. |
		+-------------------------------------------------------------------*/
		LoadInsum( M->TJ_ORDEM , M->TJ_PLANO, aScan( aDadosOS, { |x| x[1] + x[2] == M->TJ_ORDEM + M->TJ_PLANO } ), oBrw6:oBrowse:nAt )

		/*-------------------------------------------------------+
		| Recarrega informações de etapas para O.S. posicionada. |
		+-------------------------------------------------------*/
		LoadEtapas( M->TJ_ORDEM, M->TJ_PLANO, aScan( aDadosOS, { |x| x[1] + x[2] == M->TJ_ORDEM + M->TJ_PLANO } ) )
		
		If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0

			/*---------------------------------------------------------------------------------+
			| Recarrega informações de ocorrências e insumos associados para O.S. posicionada. |
			+---------------------------------------------------------------------------------*/
			fLoadOcorr( aScan( aDadosOS, { |x| x[1] + x[2] == M->TJ_ORDEM + M->TJ_PLANO } ), oGd435Ocr:nAt )

		EndIf

	EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³fNG435GPRE³ Autor ³ Denis                 ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Consiste e gera O.S. preventiva                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA400                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fNG435GPRE( cTipoEta, cOrdem, nEtaTa, nEtapa, cServCar)

	Local cVINCLUIOS := { .F., Space( TAMSX3("TJ_ORDEM")[1] ) }
	Local nSEQTP1    := nSEQSTJ
	Local nSEQPOS    := nSEQSTJ
	Local aAreaXXX   := GetArea()
	Local aAreaSTJ   := STJ->(GetArea())
	Local aSeqSTF    := {}
	Local aRegSTF    := {}

	dbSelectArea("TP1")
	dbSetOrder(1)
	If dbSeek(xFilial("TP1") + cBemSTJ + TPC->TPC_SERVIC + nSeqPOS + aVetTemp[nEtaTa] + aVetTemp[nEtapa] + cTpcOpcao)
		nSeqTP1 := TP1->TP1_SEQRMN
	EndIf

	//Tenta encontrar a Manutenção, com a sequencia da tabela TP1
	dbSelectArea("STF")
	dbSetOrder(1)
	If dbSeek(xFilial("STF") + cBemSTJ + TPC->TPC_SERVIC + nSeqTP1)
		aSeqSTF := STF->(GetArea())
	Else
		//Se não encontrar, verifica as manutenções ativas
		dbSelectArea("STF")
		dbSetOrder(1)
		If dbSeek(xFilial("STF") + cBemSTJ + TPC->TPC_SERVIC)
			While !EoF() .And. xFilial("STF")+cBEMSTJ+TPC->TPC_SERVIC == STF->(TF_FILIAL+TF_CODBEM+TF_SERVICO)
				If STF->TF_ATIVO <> "N"
					aSeqSTF := STF->(GetArea())

					aAdd( aRegSTF , { 	.F.,;                //Marcado S/N
					STF->TF_SEQRELA,;  //Sequencia
					STF->TF_NOMEMAN,;  //Nome Manutenção
					STF->TF_DTULTMA,;  //Data Ultima Manutenção
					NGSEEK("STD",STF->TF_CODAREA,1,"STD->TD_NOME"),; //Area
					NGSEEK("STE",STF->TF_TIPO,1,"STE->TE_NOME") } ) //Tipo
				EndIf

				dbSelectArea("STF")
				dbSkip()
			EndDo
		EndIf

		//Se encontrar mais do que 1 manutenção, abre tela para o usuario selecionar qual sequencia da manutenção deseja gerar
		If Len(aRegSTF) > 1
			aSeqSTF := {}
			nRetTmp := MNT400STF(aRegSTF,cOrdem,cBEMOLD,cBEMSTJ,cSEROLD,TPC->TPC_SERVIC,aVetTemp[nEtapa])
			If nRetTmp > 0 .And. Len(aRegSTF) >= nRetTmp
				dbSelectArea("STF")
				dbSetOrder(1)
				If dbSeek(xFilial("STF")+cBEMSTJ+TPC->TPC_SERVIC+aRegSTF[nRetTmp,2])
					aSeqSTF := STF->(GetArea())
				EndIf
			EndIf
		ElseIf Len(aRegSTF) == 0
			cDessEta := Alltrim( Upper( NGSEEK( "TPA", aVetTemp[nEtapa], 1, "TPA->TPA_DESCRI") ) )

			ShowHelpDlg( STR0037, {STR0038 + " '" + cDessEta + "', " + STR0039 }, 3, ;
			{ STR0040 + " " + Alltrim(cBEMSTJ) + STR0041 + STR0042 + " " +;
			Alltrim(TPC->TPC_SERVIC) + STR0043 }, 2);

			//"Atenção" ## "Houve a necessidade de gerar uma O.S. Preventiva a partir da resposta da etapa"
			//"porém não existe manutenção cadastrada para o Bem e Serviço."
			//"Cadastrar uma manutenção para o Bem" ## " com o " ## "Serviço" ## " na rotina MNTA120."
		EndIf
	EndIf

	If Len(aSeqSTF) > 0
		RestArea(aSeqSTF)
		nSEQTP1 := STF->TF_SEQRELA

		lRETORNA := NGGERAOS( cServCar, dDataBase, cBemSTJ, TPC->TPC_SERVIC, nSeqTP1, "N", "N", "N",, NG400VPAR())
		If lRETORNA[1][1]= "S" .And. Empty(lRETORNA[1][2])
			dbSelectArea("STJ")
			nINDGEOS := IndexOrd()
			nREGGEOS := Recno()

			If cTipoEta != Nil .And. !( cModulo $ 'MNT/GFR' )

				dbSelectArea("TPC")
				dbSetOrder(01)
				If dbSeek(xFilial("TPC") + aVetTemp[nEtapa] + cTpcOpcao) .And. !Empty(TPC->TPC_OBSERV)
					dbSelectArea("STJ")
					dbSetOrder(01)
					If dbSeek(xFilial("STJ") + lRETORNA[1][3] + "000001")
						RecLock("STJ",.F.)
						If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
							MsMM(,80,,TPC->TPC_OBSERV,1,,,"STJ","TJ_MMSYP")
						Else
							STJ->TJ_OBSERVA := TPC->TPC_OBSERV
						EndIf
						MsUnlock("STJ")

					EndIf

				EndIf

			EndIf

			dbSelectArea( 'STJ' )
			dbSetOrder( 1 )
			If msSeek( FWxFilial( 'STJ' ) + lRETORNA[1,3] + '000001' )

				dbSelectArea("ST9")
				dbSetOrder(1)
				dbSeek(xFilial("ST9") + STJ->TJ_CODBEM)
				dbSelectArea("ST4")
				dbSetOrder(1)
				dbSeek(xFilial("ST4") + STJ->TJ_SERVICO)

				dbSelectArea(cTRBZ400)
				RecLock(cTRBZ400,.T.)
				(cTRBZ400)->ORDEM   := STJ->TJ_ORDEM
				(cTRBZ400)->PLANO   := STJ->TJ_PLANO
				(cTRBZ400)->CODBEM  := STJ->TJ_CODBEM
				(cTRBZ400)->NOMBEM  := ST9->T9_NOME
				(cTRBZ400)->SERVICO := STJ->TJ_SERVICO
				(cTRBZ400)->NOMSER  := ST4->T4_NOME
				(cTRBZ400)->SEQRELA := STJ->TJ_SEQRELA
				(cTRBZ400)->ETAPA   := aVetTemp[nEtapa]
				(cTRBZ400)->OPCAO   := cTpcOpcao
				(cTRBZ400)->TIPOET  := If( cTipoEta <> Nil, cTipoEta, TPC->TPC_TIPRES )
				(cTRBZ400)->RESPOS  := cTpcRespos
				(cTRBZ400)->OSORIG  := cOrdem
				(cTRBZ400)->(MsUnLock())

				If !( cTipoEta != Nil .And. !( cModulo $ 'MNT/GFR' ) )

					cMsgObs := STR0044 + ": " + (cTRBZ400)->OSORIG + Chr(13) + Chr(10) //"O.S. Origem"
					cMsgObs += STR0025 + ": " + (cTRBZ400)->ETAPA + " - " + NGSEEK("TPA",(cTRBZ400)->ETAPA,1,"SubStr(TPA_DESCRI,1,30)") + Chr(13) + Chr(10) //"Etapa"
					cMsgObs += STR0045 + ": " + (cTRBZ400)->OPCAO + Chr(13) + Chr(10) //"Opção"
					If (cTRBZ400)->TIPOET == '2'
						cMsgObs += STR0046 + ": " + NGSEEK("TPC",(cTRBZ400)->ETAPA+(cTRBZ400)->OPCAO,1,"TPC_CONDIN") + Chr(13) + Chr(10) //"Limite"
						cMsgObs += STR0047 + ": " + (cTRBZ400)->RESPOS //"Informou"
					Else
						cMsgObs += STR0048 + ": " + STR0049 //"Marcou"###"Sim"
					EndIf

					RecLock( 'STJ', .F. )

						If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
							MsMM(,80,,cMsgObs,1,,,"STJ","TJ_MMSYP")
						Else
							STJ->TJ_OBSERVA := cMsgObs
						EndIf

					MsUnLock()

				EndIf

			EndIf

			dbSelectArea("STJ")
			dbSetOrder(nINDGEOS)
			dbGoto(nREGGEOS)
			cVINCLUIOS := {.T.,lRETORNA[1][3]}
		EndIf
	EndIf

	RestArea(aAreaSTJ)
	RestArea(aAreaXXX)

Return cVINCLUIOS

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³fNG435GCOR³ Autor ³ Denis                 ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Consiste e gera O.S. corretiva                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA400                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fNG435GCOR(cTipoEta,cOrdem,nEtaTa,nEtapa, cServCar)

	Local cVINCLUIOS := {.F., Space( TAMSX3("TJ_ORDEM")[1] )}

	If !Empty(TPC->TPC_SERVIC)
		lRETORNA := NGGERAOS( cServCar, dDataBase, cBemSTJ, TPC->TPC_SERVIC, 0, "N", "N", "N",, NG400VPAR())

		If lRETORNA[1][1]= "S" .And. Empty(lRETORNA[1][2])
			cXORDEM := STJ->TJ_ORDEM
			cXPLANO := STJ->TJ_PLANO

			dbSelectArea("TPE")
			dbSetOrder(1)
			If dbSeek(xFilial("TPE") + STJ->TJ_CODBEM)
				dbSelectArea( "STJ" )
				RecLock("STJ", .F.)
				STJ->TJ_POSCON2 := TPE->TPE_POSCON
				MsUnlock("STJ")
			EndIf

			If cTipoEta != Nil .And. !( cModulo $ 'MNT/GFR' )

				dbSelectArea("TPC")
				dbSetOrder(01)
				If dbSeek(xFilial("TPC")+aVetTemp[nEtapa]+cTpcOpcao)
					
					If !Empty(TPC->TPC_OBSERV)
						dbSelectArea("STJ")

						RecLock("STJ",.F.)

						If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
							MsMM(,80,,TPC->TPC_OBSERV,1,,,"STJ","TJ_MMSYP")
						Else
							STJ->TJ_OBSERVA := TPC->TPC_OBSERV
						EndIf

						MsUnlock("STJ")

					EndIf

				EndIf

			EndIf

			dbSelectArea("ST9")
			dbSetOrder(1)
			dbSeek(xFilial("ST9") + STJ->TJ_CODBEM)

			dbSelectArea("ST4")
			dbSetOrder(1)
			dbSeek(xFilial("ST4") + STJ->TJ_SERVICO)

			dbSelectArea(cTRBZ400)
			RecLock(cTRBZ400,.T.)
			(cTRBZ400)->ORDEM   := STJ->TJ_ORDEM
			(cTRBZ400)->PLANO   := STJ->TJ_PLANO
			(cTRBZ400)->CODBEM  := STJ->TJ_CODBEM
			(cTRBZ400)->NOMBEM  := ST9->T9_NOME
			(cTRBZ400)->SERVICO := STJ->TJ_SERVICO
			(cTRBZ400)->NOMSER  := ST4->T4_NOME
			(cTRBZ400)->SEQRELA := STJ->TJ_SEQRELA
			(cTRBZ400)->ETAPA   := aVetTemp[nEtapa]
			(cTRBZ400)->OPCAO   := cTpcOpcao
			(cTRBZ400)->TIPOET  := If( cTipoEta <> Nil, cTipoEta, TPC->TPC_TIPRES )
			(cTRBZ400)->RESPOS  := cTpcRespos
			(cTRBZ400)->OSORIG  := cOrdem
			(cTRBZ400)->(MsUnLock())

			dbSelectArea( 'STJ' )
			dbSetOrder( 1 )
			If msSeek( FWxFilial( 'STJ' ) + lRETORNA[1,3] + '000000' )

				If !( cTipoEta != Nil .And. !( cModulo $ 'MNT/GFR' ) )

					cMsgObs := STR0044 + ": " + (cTRBZ400)->OSORIG + Chr(13) + Chr(10) //"O.S. Origem"
					cMsgObs += STR0025 + ": " + (cTRBZ400)->ETAPA + " - " + NGSEEK("TPA",(cTRBZ400)->ETAPA,1,"SubStr(TPA_DESCRI,1,30)") + Chr(13) + Chr(10) //"Etapa"
					cMsgObs += STR0045 + ": " + (cTRBZ400)->OPCAO + Chr(13) + Chr(10) //"Opção"

					If (cTRBZ400)->TIPOET == '2'
						cMsgObs += STR0046 + ": " + NGSEEK("TPC",(cTRBZ400)->ETAPA+(cTRBZ400)->OPCAO,1,"TPC_CONDIN") + Chr(13) + Chr(10) //"Limite"
						cMsgObs += STR0047 + ": " + (cTRBZ400)->RESPOS //"Informou"
					Else
						cMsgObs += STR0048 + ": " + STR0049 //"Marcou"###"Sim"
					EndIf

					RecLock("STJ", .F.)
						
						If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
							MsMM(,80,,cMsgObs,1,,,"STJ","TJ_MMSYP")
						Else
							STJ->TJ_OBSERVA := cMsgObs
						EndIf

					MsUnLock()

				EndIf

			EndIf

			cVINCLUIOS := {.T., lRETORNA[1][3]}
		EndIf
	EndIf

Return cVINCLUIOS

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³fCriaOsGer³ Autor ³Denis Hyroshi de Souza ³ Data ³06/06/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Cria arquivo temporarios O.S. geradas e Mensagens tolerancia³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fCriaOsGer(aTRBZ435)

	Local aDBFZ := {}
	Local aDBFK := {}

	aAdd(aDBFZ,{"ORDEM"  ,"C", 06, 0 })
	aAdd(aDBFZ,{"PLANO"  ,"C", 06, 0 })
	aAdd(aDBFZ,{"CODBEM" ,"C", 16, 0 })
	aAdd(aDBFZ,{"NOMBEM" ,"C", 30, 0 })
	aAdd(aDBFZ,{"SERVICO","C", 06, 0 })
	aAdd(aDBFZ,{"NOMSER" ,"C", 30, 0 })
	aAdd(aDBFZ,{"SEQRELA","C", 03, 0 })
	aAdd(aDBFZ,{"ETAPA"  ,"C", 06, 0 })
	aAdd(aDBFZ,{"OPCAO"  ,"C", 15, 0 })
	aAdd(aDBFZ,{"TIPOET" ,"C", 01, 0 })
	aAdd(aDBFZ,{"RESPOS" ,"C", TAMSX3( 'TPQ_RESPOS' )[1], 0 })
	aAdd(aDBFZ,{"OSORIG" ,"C", 06, 0 })

	aAdd(aTRBZ435,{STR0027, "ORDEM"  , "C", 06, 0,"@!"}) //"Ordem"
	aAdd(aTRBZ435,{STR0050, "PLANO"  , "C", 06, 0,"@!"}) //"Plano"
	aAdd(aTRBZ435,{STR0051, "CODBEM" , "C", 16, 0,"@!"}) //"Bem"
	aAdd(aTRBZ435,{STR0052, "NOMBEM" , "C", 30, 0,"@!"}) //"Nome Bem"
	aAdd(aTRBZ435,{STR0053, "SERVICO", "C", 06, 0,"@!"}) //"Servico"
	aAdd(aTRBZ435,{STR0054, "NOMSER" , "C", 30, 0,"@!"}) //"Nome Servico"
	aAdd(aTRBZ435,{STR0055, "SEQRELA", "C", 03, 0,"@!"}) //"Sequen"

	//Criação Tabela Temporária
	oTmpTbl1 := NGFwTmpTbl(cTRBZ400,aDBFZ,{{ "ORDEM" }})

	aAdd(aDBFK,{"ORDEM"   , "C", TamSx3("TJ_ORDEM")[1], 0 })
	aAdd(aDBFK,{"PLANO"   , "C", TamSx3("TJ_PLANO")[1], 0 })
	aAdd(aDBFK,{"BEM"     , "C", 16, 0 })
	aAdd(aDBFK,{"ETAPA"   , "C", 06, 0 })
	aAdd(aDBFK,{"OPCAO"   , "C", 15, 0 })
	aAdd(aDBFK,{"RESPOSTA", "C", TAMSX3( 'TPQ_RESPOS' )[1], 0 })
	aAdd(aDBFK,{"INFORMOU", "C", 10, 0 })
	aAdd(aDBFK,{"PERCENTO", "N", 06, 2 })
	aAdd(aDBFK,{"VLRMENOR", "N", 12, 2 })
	aAdd(aDBFK,{"VLRMAIOR", "N", 12, 2 })
	aAdd(aDBFK,{"OBSERVA" , "C", 50, 0 })

	aAdd(aTRBK,{STR0027, "ORDEM"   , "C", TamSx3("TJ_ORDEM")[1],0,"@!"})				//"Ordem"
	aAdd(aTRBK,{STR0050, "PLANO"   , "C", TamSx3("TJ_PLANO")[1],0,"@!"})				//"Plano"
	aAdd(aTRBK,{STR0051, "BEM"     , "C", 16,0,"@!"}) //"Bem"
	aAdd(aTRBK,{STR0025, "ETAPA"   , "C", 06,0,"@!"}) //"Etapa"
	aAdd(aTRBK,{STR0057, "OPCAO"   , "C", 15,0,"@!"}) //"Opcao"
	aAdd(aTRBK,{STR0058, "INFORMOU", "C", 10,0,"@!"}) //"Informado"
	aAdd(aTRBK,{STR0059, "RESPOSTA", "C", TAMSX3( 'TPQ_RESPOS' )[1],0,"@!"}) //"Resposta"
	aAdd(aTRBK,{STR0060, "OBSERVA" , "C", 40,0,"@!"}) //"Observacao"
	aAdd(aTRBK,{STR0061, "PERCENTO", "N", 06,2,"@E 999.99"}) //"Percent."
	aAdd(aTRBK,{STR0062, "VLRMENOR", "N", 12,2,"@E 999,999,999.99"}) //"Vlr Menor"
	aAdd(aTRBK,{STR0063, "VLRMAIOR", "N", 12,2,"@E 999,999,999.99"}) //"Vlr Maior"

	//Criação Tabela Temporária
	oTmpTbl2 := NGFwTmpTbl(cTRBK400,aDBFK,{{ "BEM","ETAPA" }})

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ Mnt435F12³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Descrio ³ Funcao para buscar pecas de reposicao (F12)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Mnt435F12()

	NGINSUF12("M->TL_CODIGO",cCdBemTJ,aCOLS[n,nTpRg435],.T.,,"TL_NOMCODI",oBrw6)

Return

//--------------------------------------------------------------
/*/{Protheus.doc} Fd_Entra
Ações ao selecionar determinado objeto

@author Denis Hyroshi de Souza
@since 23/06/08

@param nE, integer, Indica o objeto selecionado
						1 - Insumos realizados
						2 - Ocorrências
						3 - Motivo de atraso
						4 - Etapas
						5 - Insumos Associados
@return
/*/
//--------------------------------------------------------------
Static Function Fd_Entra( nE )

	Local nPos := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPox := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })

	lFocusBrw3 := .F.

	Do Case
		
		/*-------------------+
		| Insumos Realizados |
		+-------------------*/
		Case nE == 1

			n := 1

			aHeader := aClone( aHoBrw6 )
			aCols   := aClone( aCoBrw6 )

			/*-----------------------------------------+
			| Ativa manipulação do browse pelo sistema |
			+-----------------------------------------*/
			oBrw6:oBrowse:lDisablePaint := .F.
			oBrw6:oBrowse:Refresh()
			
			fLoadSTL()

			/*--------------------------------------------+
			| Desativa manipulação do browse pelo sistema |
			+--------------------------------------------*/
			oGd435Ocr:oBrowse:lDisablePaint := .T.
			oBrw5:oBrowse:lDisablePaint     := .T.

			SetKey( VK_F4 , { || MntViewSB2( oBrw6:aCols[oBrw6:nAt,nPos], oBrw6:aCols[oBrw6:nAt,nPox] ) } )
			SetKey(VK_F12,{|| Mnt435F12() })

			//Verifica se o parâmetro MV_NGHISES está como "N" para permitir a alteração do custo do insumo
			If STJ->TJ_SERVICO == "HISTOR"
				If cUIntHis == "N" .And. cUsaInt3 == 'S' .And. aCols[n,nPos] $ ("P\M")
					lCusto := .T.
				Else
					lCusto := .F.
				EndIf
			ElseIf cUsaInt3 == 'S'
				lCusto := .F.
			EndIf

		/*------------+
		| Ocorrências |
		+------------*/
		Case nE == 2

			/*-----------------------------------------+
			| Ativa manipulação do browse pelo sistema |
			+-----------------------------------------*/
			oGd435Ocr:oBrowse:lDisablePaint := .F.

			/*---------------------------------+
			| Váriavel utilizada no F10 e F11. |
			+---------------------------------*/
			lFocusBrw3 := .T.

			If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0
				
				If !Empty( oGd435Ocr:aCols[1,1] )
					
					/*---------------------------------------------------------------+
					| Cópia do aCols, para ao fim comparar as alterações realizadas. |
					+---------------------------------------------------------------*/
					aBrw3Old := aClone( oGd435Ocr:aCols )
					aCols    := aClone( oGd435Ocr:aCols )

					oGd435Ocr:GoTop()

				EndIf

			Else

				aHeader := aClone( oGd435Ocr:aHeader )
				aCols   := aClone( oGd435Ocr:aCols )

				oGd435Ocr:oBrowse:Refresh()

				//-----------------------------------------------
				//Valida insumo selecionado para as ocorrências
				//-----------------------------------------------
				If !fValInsOco( oBrw6:oBrowse:nAt, nPos, nPox )

					oFolder435:nOption := 1 //Posiciona no folder de Insumos
					oBrw6:oBrowse:SetFocus() //volta foco no browse insumos
					Return

				EndIf

			EndIf

			/*--------------------------------------------+
			| Desativa manipulação do browse pelo sistema |
			+--------------------------------------------*/
			oBrw6:oBrowse:lDisablePaint := .T.
			oBrw5:oBrowse:lDisablePaint := .T.

		/*-----------------+
		| Motivo de Atraso |
		+-----------------*/
		Case nE == 3

			aHeader := aClone( aHoBrw4 )
			aCols   := aClone( aCoBrw4 )

			/*-----------------------------------------+
			| Ativa manipulação do browse pelo sistema |
			+-----------------------------------------*/
			oBrw5:oBrowse:lDisablePaint := .F.

			oBrw5:oBrowse:Refresh()

			/*--------------------------------------------+
			| Desativa manipulação do browse pelo sistema |
			+--------------------------------------------*/
			oBrw6:oBrowse:lDisablePaint     := .T.
			oGd435Ocr:oBrowse:lDisablePaint := .T.

		/*-------------------+
		| Insumos Associados |
		+-------------------*/
		Case nE == 5

			/*-----------------------------------------+
			| Ativa manipulação do browse pelo sistema |
			+-----------------------------------------*/
			oGd435Ass:oBrowse:lDisablePaint := .F.

			/*--------------------------------------------+
			| Desativa manipulação do browse pelo sistema |
			+--------------------------------------------*/
			oGd435Ocr:oBrowse:lDisablePaint := .T.
			oBrw6:oBrowse:lDisablePaint     := .T.

	End Case

	nControGD := nE

Return

//--------------------------------------------------------------
/*/{Protheus.doc} Fd_Sai
Ações ao perder o foco de determinado objeto

@author Denis Hyroshi de Souza
@since 23/06/08

@param nE, integer, Indica o objeto selecionado
						1 - Insumos realizados
						2 - Ocorrências
						3 - Motivo de atraso
						4 - Etapas
						5 - Insumos Associados
@return
/*/
//--------------------------------------------------------------
Static Function Fd_Sai( nE )

	Local aAreaOld := GetArea()
	Local aBkpCols := {}
	Local cUpdOcr  := ''
	Local nXX,nYY,i,aTemp
	Local nLineOS := aScan( aDadosOS, { |x| x[1] + x[2] == cOrdemTJ + cPlanoTJ } )
	Local nInd1   := 0
	Local nInd2   := 0
	Local nInd3   := 0
	Local nFound  := 0
	Local nPosSTL := Nil
	Local nPosSTN := Nil
	Local nPosTPL := Nil
	Local nPosSq1 := 0
	Local nPosSq2 := 0
	Local nPosBrw := 0
	Local nPosTar := 0
	Local nPosPro := 0
	Local nPosCau := 0
	Local nPosSol := 0
	Local nSTLlin := oBrw6:oBrowse:nAt
	Local nTmpOld
	Local lValBkp := .F.

	lFocusBrw3 := .F.

	Set Key VK_F12 To
	Set Key VK_F4 To
	// 1-Ordem / 2-Plano / 3-Previstos SALVO[] / 4-Realizados SALVO[] / 5-Realizados NOVO[]
	// 6-Motivos Atraso SALVO[] / 7-Motivos Atraso NOVO[] / 8-Etapas NOVO[] / 9-Etapas Outras OS[]

	/*-------------------------------------------------------------------+
	| Ao finalizar a ultima O.S. do browse a TRB fica em fim de arquivo. |
	+-------------------------------------------------------------------*/
	If (cAliOS435)->( !EoF() )

		Do Case

			/*-------------------+
			| Insumos Realizados |
			+-------------------*/
			Case nE == 1

				//Apaga ultima linha caso vazia
				If oBrw6:lNewLine

					aDel( oBrw6:aCols , nSTLlin )
					aSize( oBrw6:aCols, nSTLlin - 1 )
					oBrw6:lNewLine := .F.

				EndIf

				aCoBrw6 := aClone( oBrw6:aCols )
				aHoBrw6 := aClone( oBrw6:aHeader )

				aCols   := aClone( oBrw6:aCols )
				aHeader := aClone( oBrw6:aHeader )

				If !lClearData .And. nLineOS > 0
					
					// Transferi as alteracoes para o arquivo temporario
					aDadosOS[nLineOS,5] := aClone( aCoBrw6 )

				EndIf

				RecLock( cAliOS435, .F. )

					If !Empty( aCoBrw6[1,1] )

						(cAliOS435)->TJ_TIPORET := 'S'

					Else

						(cAliOS435)->TJ_TIPORET := ' '

					EndIf

				MsUnLock()

				If !TudOkTL435( @nPosSTL )

					//------------------------------------------------
					//Posiciona no folder de Insumos
					//------------------------------------------------
					oFolder435:nOption := 1

					//Posiciona na Insumo anterior
					oBrw6:oBrowse:SetFocus()

					If ValType( nPosSTL ) == 'N'
						oBrw6:GoTo( nPosSTL )
					EndIf

					lRet435 := .F. //Retorna falso para cancelar a gravacao

					Return .F.

				Else

					If lIntRM

						fRefreshOS( (cAliOS435)->TJ_ORDEM, (cAliOS435)->TJ_PLANO, 1 )
					
					EndIf

					If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0

						/*-----------------------------------------------------+
						| Posição dos campos no GetDados de Insumos Realizados |
						+-----------------------------------------------------*/
						nPosSq1 := GDFieldPos( 'TL_SEQRELA' , aHoBrw6 )

						/*-----------------------------------------------------+
						| Posição dos campos no GetDados de Insumos Associados |
						+-----------------------------------------------------*/
						nPosSq2 := GDFieldPos( 'TL_SEQRELA' , oGd435Ass:aHeader )

						If nLineOS > 0

							For nInd1 := 1 To Len( aCoBrw6 )
								
								For nInd2 := 1 To Len( aDadosOS[nLineOS,_OCCURRENCES_] )

									If ( nFound := aScan( aDadosOS[nLineOS,_OCCURRENCES_,nInd2,_INSUMOCORRE_],;
										{ |x| x[nPosSq2] == aCoBrw6[nInd1,nPosSq1] .And. !aTail( x ) } ) ) > 0

										/*------------------------------------------------------------------------------------------+
										| Atualiza linha do insumo associado, com alterações feitas no folder de insumos realizados |
										+------------------------------------------------------------------------------------------*/
										For nInd3 := 1 To Len( oGd435Ass:aHeader )

											If ( nPosBrw := GDFieldPos( oGd435Ass:aHeader[nInd3,2], aHoBrw6 ) )

												aDadosOS[nLineOS,_OCCURRENCES_,nInd2,_INSUMOCORRE_,nFound,nInd3] := aCoBrw6[nInd1,nPosBrw]

											EndIf
											
										Next nInd3

									EndIf
									
								Next nInd2
								
							Next nInd1

							/*------------------------------------------------------+
							| Carrega insumos associados a ocorrências posicionada. |
							+------------------------------------------------------*/
							fChangeOcr( nLineOS, 1 )

						EndIf

					EndIf

					oBrwOS:Refresh()

				EndIf

				//Verifica se algo foi alterado
				If nLineOS > 0 .And. !lFoiAlterado
					If ValType(aDadosOS[nLineOS,4]) <> ValType(aDadosOS[nLineOS,5]) .Or. ValType(aDadosOS[nLineOS,5]) != "A"
						lFoiAlterado := .T.
					ElseIf Len(aDadosOS[nLineOS,4]) <> Len(aDadosOS[nLineOS,5])
						lFoiAlterado := .T.
					Else
						For nXX := 1 to Len(aDadosOS[nLineOS,5])
							If Len(aDadosOS[nLineOS,4,nXX]) <> Len(aDadosOS[nLineOS,5,nXX])
								lFoiAlterado := .T.
								Exit
							EndIf
							If  Empty(aDadosOS[nLineOS,4,nXX,1]) .And. Empty(aDadosOS[nLineOS,4,nXX,3]) .And. Empty(aDadosOS[nLineOS,4,nXX,5]) .And. ;
							Empty(aDadosOS[nLineOS,5,nXX,1]) .And. Empty(aDadosOS[nLineOS,5,nXX,3]) .And. Empty(aDadosOS[nLineOS,5,nXX,5])
								Loop
							EndIf

							For nYY := 1 to Len(aDadosOS[nLineOS,5,nXX])
								If nYY == Len(aDadosOS[nLineOS,5,nXX])-1 .Or. ;
								(Len(aHeader) >= nYY .And. Len(aHeader[nYY]) >= 10 .And. AllTrim(aHeader[nYY,10]) == "V") // Não considera campos virtuais
									Loop
								EndIf
								If ValType(aDadosOS[nLineOS,5,nXX,nYY]) <> ValType(aDadosOS[nLineOS,4,nXX,nYY])
									lFoiAlterado := .T.
									Exit
								EndIf
								If aDadosOS[nLineOS,5,nXX,nYY] <> aDadosOS[nLineOS,4,nXX,nYY]
									lFoiAlterado := .T.
									Exit
								EndIf
							Next nYY

							If lFoiAlterado
								Exit
							EndIf

						Next nXX

					EndIf

				EndIf

				/*--------------------------------------------+
				| Desativa manipulação do browse pelo sistema |
				+--------------------------------------------*/
				oBrw6:oBrowse:lDisablePaint := .T.

			/*------------+
			| Ocorrências |
			+------------*/
			Case nE == 2
			
				If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0

					For nInd1 := 1 To Len( oGd435Ocr:aCols )

						If ValType( oGd435Ocr:aCols[nInd1,_INSUMOCORRE_] ) != 'A'

							/*----------------------------------------------------------------------+
							| Inclui um array na penultima posição do aCols - Legado de ocorrências |
							+----------------------------------------------------------------------*/
							lValBkp := aTail( oGd435Ocr:aCols[nInd1] )

							aDel( oGd435Ocr:aCols[nInd1] , Len( oGd435Ocr:aCols[nInd1] ) )
								
							aSize( oGd435Ocr:aCols[nInd1], Len( oGd435Ocr:aCols[nInd1] ) - 1 ) 
								
							aAdd( oGd435Ocr:aCols[nInd1] , {} )
							
							aAdd( oGd435Ocr:aCols[nInd1] , lValBkp )

						EndIf
						
					Next nInd1

					aCoBrw3   := aClone( oGd435Ocr:aCols )
					aHoBrw3   := aClone( oGd435Ocr:aHeader )
					aCoBrw3_2 := aClone( oGd435Ass:aCols )
					aHoBrw3_2 := aClone( oGd435Ass:aHeader )

				Else

					aCoBrw3 := aClone( oGD435Ocr:aCols )
					aHoBrw3 := aClone( oGD435Ocr:aHeader )

				EndIf
				
				If Empty( aCoBrw3 )

					aCoBrw3 := BlankGetD( aHoBrw3 )
				
				EndIf

				/*--------------------------------------------------+
				| Transfere as alterações para o arquivo temporário |
				+--------------------------------------------------*/
				nTmpOld := oBrw6:oBrowse:nAt
				If nTmpOld <= Len(aCoBrw6)

					If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0

						nPosTar := GDFieldPos( 'TN_TAREFA' , oGd435Ocr:aHeader )
						nPosPro := GDFieldPos( 'TN_CODOCOR', oGd435Ocr:aHeader )
						nPosCau := GDFieldPos( 'TN_CAUSA'  , oGd435Ocr:aHeader )
						nPosSol := GDFieldPos( 'TN_SOLUCAO', oGd435Ocr:aHeader )
						nPosSeq := GDFieldPos( 'TN_SEQRELA', oGd435Ocr:aHeader )
						nPosObs := GDFieldPos( 'TN_DESCRIC', oGd435Ocr:aHeader )
						
						If !Empty( oGd435Ocr:aCols[1,1] )

							aDadosOS[nLineOS,_OCCURRENCES_] := aClone( oGd435Ocr:aCols )

							For nInd1 := 1 To Len( oGd435Ocr:aCols )

								/*---------------------------------------------------------+
								| Grava na tabela temporária se alteração nos campos chave |
								+---------------------------------------------------------*/
								If !Empty( aBrw3Old ) .And. Len( aBrw3Old ) >= nInd1 .And.;
									( !( oGd435Ocr:aCols[nInd1,nPosTar] == aBrw3Old[nInd1,nPosTar] ) .Or.;
									  !( oGd435Ocr:aCols[nInd1,nPosPro] == aBrw3Old[nInd1,nPosPro] ) .Or.;
									  !( oGd435Ocr:aCols[nInd1,nPosCau] == aBrw3Old[nInd1,nPosCau] ) .Or.;
									  !( oGd435Ocr:aCols[nInd1,nPosSol] == aBrw3Old[nInd1,nPosSol] ) .Or.;
									  !( oGd435Ocr:aCols[nInd1,nPosObs] == aBrw3Old[nInd1,nPosObs] ) )
									
									cUpdOcr := "UPDATE "
									cUpdOcr += 		oTmpTbl8:GetRealName()
									cUpdOcr += " SET "
									cUpdOcr += 		"TN_TAREFA  = " + ValToSQL( oGd435Ocr:aCols[nInd1,nPosTar] ) + ", "
									cUpdOcr += 		"TN_CODOCOR = " + ValToSQL( oGd435Ocr:aCols[nInd1,nPosPro] ) + ", "
									cUpdOcr += 		"TN_CAUSA   = " + ValToSQL( oGd435Ocr:aCols[nInd1,nPosCau] ) + ", "
									cUpdOcr += 		"TN_SOLUCAO = " + ValToSQL( oGd435Ocr:aCols[nInd1,nPosSol] )
									cUpdOcr += " WHERE "
									cUpdOcr += 		"TN_TAREFA  = " + ValToSQL( aBrw3Old[nInd1,nPosTar] ) + " AND "
									cUpdOcr += 		"TN_CODOCOR = " + ValToSQL( aBrw3Old[nInd1,nPosPro] ) + " AND "
									cUpdOcr += 		"TN_CAUSA   = " + ValToSQL( aBrw3Old[nInd1,nPosCau] ) + " AND "
									cUpdOcr += 		"TN_SOLUCAO = " + ValToSQL( aBrw3Old[nInd1,nPosSol] ) + " AND "
									cUpdOcr += 		"TN_ORDEM   = " + ValToSQL( cOrdemTJ )                + " AND "
									cUpdOcr += 		"TN_PLANO   = " + ValToSQL( cPlanoTJ )                + " AND "
									cUpdOcr += 		"D_E_L_E_T_ = ' ' " 

									TCSQLExec( cUpdOcr )

									If !Empty( oGd435Ocr:aCols[nInd1,nPosObs] ) .Or. !Empty( aBrw3Old[nInd1,nPosObs] )
										
										cChavTRB := oGd435Ocr:aCols[nInd1,nPosTar] + oGd435Ocr:aCols[nInd1,nPosPro] + oGd435Ocr:aCols[nInd1,nPosCau] +;
											oGd435Ocr:aCols[nInd1,nPosSol] + cOrdemTJ + cPlanoTJ

										dbSelectArea( cAlsOcor )
										dbSetOrder( 2 ) // TN_TAREFA + TN_CODOCOR + TN_CAUSA + TN_SOLUCAO + TN_ORDEM + TN_PLANO
										If msSeek( cChavTRB )

											While (cAlsOcor)->( !EoF() ) .And. (cAlsOcor)->TN_TAREFA + (cAlsOcor)->TN_CODOCOR + (cAlsOcor)->TN_CAUSA +;
												(cAlsOcor)->TN_SOLUCAO + (cAlsOcor)->TN_ORDEM + (cAlsOcor)->TN_PLANO == cChavTRB
											
												RecLock( cAlsOcor, .F. )

													(cAlsOcor)->TN_DESCRIC := oGd435Ocr:aCols[nInd1,nPosObs]

												MsUnLock()

												(cAlsOcor)->( dbSkip() )

											End

										EndIf

									EndIf
								
								/*---------------------------------------------------------------------------+
								| Gravação na tabela temporária de inclusão e alterações em campos não chave |
								+---------------------------------------------------------------------------*/
								ElseIf !Empty( oGd435Ocr:aCols[nInd1,nPosTar] )

									dbSelectArea( cAlsOcor )
									dbSetOrder( 2 ) // TN_TAREFA + TN_CODOCOR + TN_CAUSA + TN_SOLUCAO + TN_ORDEM + TN_PLANO
									If !msSeek( oGd435Ocr:aCols[nInd1,nPosTar] + oGd435Ocr:aCols[nInd1,nPosPro] +;
										oGd435Ocr:aCols[nInd1,nPosCau] + oGd435Ocr:aCols[nInd1,nPosSol] + cOrdemTJ + cPlanoTJ )

										RecLock( cAlsOcor, .T. )

											(cAlsOcor)->TN_ORDEM   := cOrdemTJ
											(cAlsOcor)->TN_PLANO   := cPlanoTJ
											(cAlsOcor)->TN_SEQRELA := '0  '
											(cAlsOcor)->TN_TAREFA  := oGd435Ocr:aCols[nInd1,nPosTar]
											(cAlsOcor)->TN_CODOCOR := oGd435Ocr:aCols[nInd1,nPosPro]
											(cAlsOcor)->TN_CAUSA   := oGd435Ocr:aCols[nInd1,nPosCau]
											(cAlsOcor)->TN_SOLUCAO := oGd435Ocr:aCols[nInd1,nPosSol]
											(cAlsOcor)->TN_DESCRIC := oGd435Ocr:aCols[nInd1,nPosObs]

										MsUnLock()
									
									Else

										RecLock( cAlsOcor, .F. )
										
											(cAlsOcor)->TN_DESCRIC  := oGd435Ocr:aCols[nInd1,nPosObs]

										MsUnLock()

									EndIf

								EndIf

								/*---------------------------------------------------------+
								| Marca como deletado os registros, removidos do GetDados. |
								+---------------------------------------------------------*/
								If aTail( oGd435Ocr:aCols[nInd1] )

									/*-----------------------------------------------------------------+
									| Valida se existe uma ocorrência exatamente igual e não deletada. |
									+-----------------------------------------------------------------*/
									If aScan( oGd435Ocr:aCols, { |x| x[nPosTar] == oGd435Ocr:aCols[nInd1,nPosTar] .And. x[nPosPro] == oGd435Ocr:aCols[nInd1,nPosPro] .And.;
										x[nPosCau] == oGd435Ocr:aCols[nInd1,nPosCau] .And. x[nPosSol] == oGd435Ocr:aCols[nInd1,nPosSol] .And. !aTail( x ) } ) == 0

										dbSelectArea( cAlsOcor )
										dbSetOrder( 2 ) // TN_TAREFA + TN_CODOCOR + TN_CAUSA + TN_SOLUCAO + TN_ORDEM + TN_PLANO
										If msSeek( oGd435Ocr:aCols[nInd1,nPosTar] + oGd435Ocr:aCols[nInd1,nPosPro] + oGd435Ocr:aCols[nInd1,nPosCau] +;
											oGd435Ocr:aCols[nInd1,nPosSol] + cOrdemTJ + cPlanoTJ )

											While (cAlsOcor)->( !EoF() ) .And. oGd435Ocr:aCols[nInd1,nPosTar] + oGd435Ocr:aCols[nInd1,nPosPro] + oGd435Ocr:aCols[nInd1,nPosCau] + oGd435Ocr:aCols[nInd1,nPosSol] + cOrdemTJ + cPlanoTJ ==;
												(cAlsOcor)->TN_TAREFA + (cAlsOcor)->TN_CODOCOR + (cAlsOcor)->TN_CAUSA + (cAlsOcor)->TN_SOLUCAO + (cAlsOcor)->TN_ORDEM + (cAlsOcor)->TN_PLANO

												RecLock( cAlsOcor, .F. )
													
													dbDelete()

												MsUnLock()

												(cAlsOcor)->( dbSkip() )

											End

										EndIf

									EndIf

								EndIf
								
							Next nInd1

						EndIf
					
					Else

						oBrw6:aCols[nTmpOld, Len(aCoBrw6[nTmpOld])-1 ] := aClone(aCoBrw3)

					EndIf

					If nLineOS > 0

						aDadosOS[nLineOS,5] := aClone( oBrw6:aCols )
					
					EndIf

				EndIf

				/*-------------------------------------------+
				| Validação total das linhas de ocorrências. |
				+-------------------------------------------*/
				If !MNA435TdOk( 3, , @nPosSTN )

					//------------------------------------------------
					//Posiciona no folder de ocorrências
					//------------------------------------------------
					oFolder435:nOption := 3

					oGd435Ocr:oBrowse:SetFocus()

					aHeader := aClone( aHoBrw3 )
					aCols   := aClone( aCoBrw3 )
					
					If ValType( nPosSTN ) == 'N'
						
						oGd435Ocr:ForceRefresh()
						oGd435Ocr:oBrowse:nAt := nPosSTN
						oGd435Ocr:oBrowse:nRowPos := 3

					EndIf

					lRet435 := .F. //Retorna falso para cancelar a gravacao

					Return .F.

				EndIf

				If nTmpOld <= Len( aCoBrw6 )

					If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0
						
						aDadosOS[nLineOS,_OCCURRENCES_] := aClone( aCoBrw3 )
					
					Else

						oBrw6:aCols[nTmpOld, Len(aCoBrw6[nTmpOld])-1 ] := aClone(aCoBrw3)

					EndIf

					If nLineOS > 0

						aDadosOS[nLineOS,5] := aClone( oBrw6:aCols )

					EndIf

				EndIf

				//Verifica se algo foi alterado
				If !Empty( aDadosOS[nLineOS,4] ) .And.;
					nLineOS > 0 .And. !lFoiAlterado

					If nTmpOld > Len(aDadosOS[nLineOS,4])
						lFoiAlterado := .T.
					Else
						aTemp := aClone( aDadosOS[nLineOS,4,nTmpOld, Len(aDadosOS[nLineOS,4,nTmpOld])-1 ] )
						If ValType(aTemp) <> ValType(aCols) .Or. ValType(aTemp) != "A"
							lFoiAlterado := .T.
						ElseIf Len(aTemp) <> Len(aCols)
							lFoiAlterado := .T.
						Else
							For nXX := 1 to Len(aCols)
								If Len(aTemp[nXX]) <> Len(aCols[nXX])
									lFoiAlterado := .T.
									Exit
								EndIf
								For nYY := 1 to Len(aCols[nXX])
									If ValType(aCols[nXX,nYY]) <> ValType(aTemp[nXX,nYY])
										lFoiAlterado := .T.
										Exit
									EndIf
									If aCols[nXX,nYY] <> aTemp[nXX,nYY]
										lFoiAlterado := .T.
										Exit
									EndIf
								Next nYY
								If lFoiAlterado
									Exit
								EndIf
							Next nXX
						EndIf
					EndIf
				EndIf

				/*--------------------------------------------+
				| Desativa manipulação do browse pelo sistema |
				+--------------------------------------------*/
				oGd435Ocr:oBrowse:lDisablePaint := .T.

			/*-----------------+
			| Motivo de Atraso |
			+-----------------*/
			Case nE == 3 .And. Len(aHoBrw4) == Len(aHeader) //Motivos de Atraso

				aCoBrw4 := aClone(aCols)
				aHoBrw4 := aClone(aHeader)

				If Len(aCoBrw4) == 0
					aCoBrw4 := BlankGetD(aHoBrw4)
				EndIf

				//Transferi as alteracoes para o arquivo temporario
				If !lClearData .And. nLineOS > 0
					aDadosOS[nLineOS,7] := aClone(aCols)
				EndIf

				If !TudOk435PL(@nPosTPL)

					//------------------------------
					//Posiciona no folder de Motivo
					//------------------------------
					oFolder435:nOption := 4

					oBrw5:oBrowse:SetFocus()
					If ValType(nPosSTL) == "N"
						oBrw5:oBrowse:nAt := nPosSTL
					EndIf

					lRet435 := .F. //Retorna falso para cancelar a gravacao

					Return .F.

				EndIf

				//Verifica se algo foi alterado
				If nLineOS > 0 .And. !lFoiAlterado
					If ValType(aDadosOS[nLineOS,6]) <> ValType(aCols) .Or. ValType(aDadosOS[nLineOS,6]) != "A"
						lFoiAlterado := .T.
					ElseIf Len(aDadosOS[nLineOS,6]) <> Len(aCols)
						lFoiAlterado := .T.
					Else
						For nXX := 1 to Len(aCols)
							If Len(aDadosOS[nLineOS,6,nXX]) <> Len(aCols[nXX])
								lFoiAlterado := .T.
								Exit
							EndIf
							For nYY := 1 to Len(aCols[nXX])
								If ValType(aCols[nXX,nYY]) <> ValType(aDadosOS[nLineOS,6,nXX,nYY])
									lFoiAlterado := .T.
									Exit
								EndIf
								If aCols[nXX,nYY] <> aDadosOS[nLineOS,6,nXX,nYY]
									lFoiAlterado := .T.
									Exit
								EndIf
							Next nYY
							If lFoiAlterado
								Exit
							EndIf
						Next nXX
					EndIf
				EndIf

			/*-------+
			| Etapas |
			+-------*/
			Case nE == 4

				nRecTrb := (cTRBQ400)->(Recno())
				aTempCab := {}
				dbSelectArea(cTRBQ400)
				dbSetOrder(2)
				dbGoTop()
				While !EoF()

					aTemp := {}

					For i := 1 To Len( aTRBQ )

						//De acordo com a utilização do Ponto de Entrada MNTA435G inclui o executante padrão
						If i == aScan( aTRBQ, { |x| Trim( x[2] ) == 'TQ_CODFUNC' } ) .And. !Empty(cCodFunc) .And. !Empty((cTRBQ400)->TQ_OK)
							(cTRBQ400)->TQ_CODFUNC := cCodFunc
						EndIf

						aAdd( aTemp , &( cTRBQ400 + '->' + aTRBQ[i,2] ) )

					Next i

					aAdd( aTemp, (cTRBQ400)->TQ_OK )
					aAdd( aTemp, (cTRBQ400)->TQ_SEQRELA )
					aAdd( aTemp, (cTRBQ400)->RECSTQ )

					aOpcEtapa := {}
					dbSelectArea(cTRB3400)
					dbSetOrder(1)
					dbGoTop()
					dbSeek((cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_TAREFA)
					While !EoF() .And. (cTRB3400)->TPC_ETAPA == (cTRBQ400)->TQ_ETAPA .And. (cTRB3400)->TPC_TAREFA == (cTRBQ400)->TQ_TAREFA
						If !Empty( (cTRB3400)->TPC_OK )
							aAdd( aOpcEtapa , {;
							(cTRB3400)->TPC_OK		,;
							(cTRB3400)->TPC_OPCAO	,;
							(cTRB3400)->TPC_RESPOS	 ;
							})
						EndIf
						dbSkip()
					EndDo

					aAdd( aTemp , aOpcEtapa )
					aAdd( aTemp, (cTRBQ400)->STATUS)
					aAdd( aTempCab , aTemp )
					dbSelectArea(cTRBQ400)
					dbSkip()
				End

				dbSelectArea(cTRBQ400)
				dbGoTo(nRecTrb)
				dbSelectArea(cTRB3400)
				dbGoTop()

				If !lClearData .And. nLineOS > 0
					aDadosOS[nLineOS,8] := aClone(aTempCab)
				EndIf

				nRecTrb := (cTRBTAR)->(Recno())
				aTempCab := {}

				If cMVPAR01 == '1'

					dbSelectArea(cTRBTAR)
					dbSetOrder(1)
					dbGoTop()
					While !EoF()
						aAdd( aTempCab , {	(cTRBTAR)->TAREFA,;
						(cTRBTAR)->NOMETAR,;
						(cTRBTAR)->ETAPA,;
						(cTRBTAR)->NOMEETA,;
						(cTRBTAR)->ORDEM,;
						(cTRBTAR)->DTMPINI } )
						dbSkip()
					End

				EndIf
				dbSelectArea(cTRBTAR)
				dbGoTo(nRecTrb)
				If nLineOS > 0

					If cMVPAR01 == '1'
						aDadosOS[nLineOS,9] := aClone(aTempCab)
					Else
						aDadosOS[nLineOS,9] := Nil
					EndIf

				EndIf

			/*-------------------+
			| Insumos Associados |
			+-------------------*/
			Case nE == 5

				/*--------------------------------------------------+
				| Validação total das linhas de insumos associados. |
				+--------------------------------------------------*/
				If MNA435TdOk( 1, , @nPosSTL )
					
					/*-----------------------------------------+
					| Ativa manipulação do browse pelo sistema |
					+-----------------------------------------*/
					oBrw6:oBrowse:lDisablePaint := .F.
					
					aDadosOS[nLineOS,_OCCURRENCES_] := aClone( oGd435Ocr:aCols )

					aDadosOS[nLineOS,_OCCURRENCES_,oGd435Ocr:nAt,_INSUMOCORRE_] := aClone( oGd435Ass:aCols )

					oGd435Ocr:aCols[oGd435Ocr:nAt,_INSUMOCORRE_] := aClone( oGd435Ass:aCols )

					oBrw6:aCols := aClone( aCoBrw6 )

					/*--------------------------------------------+
					| Desativa manipulação do browse pelo sistema |
					+--------------------------------------------*/
					oBrw6:oBrowse:lDisablePaint := .T.

				Else

					/*-----------------------------------+
					| Posiciona no folder de ocorrências |
					+-----------------------------------*/
					oFolder435:nOption := 3

					/*--------------------------------------------+
					| Salva backup dos insumos com incosistências |
					+--------------------------------------------*/
					aBkpCols := aClone( oGd435Ass:aCols )

					/*---------------------------------------------------+
					| Altera o foco para o objeto de insumos associados. |
					+---------------------------------------------------*/
					oGd435Ass:oBrowse:SetFocus()

					/*---------------------------------------+
					| Restaura backup de insumos associados. |
					+---------------------------------------*/
					oGd435Ass:aCols := aClone( aBkpCols )

					If ValType( nPosSTL ) == 'N'

						/*-------------------------------------+
						| Volta na posição que ocorreu o erro. |
						+-------------------------------------*/
						oGd435Ass:oBrowse:nAt := nPosSTL

					EndIf

					oGd435Ass:Refresh()

					lRet435 := .F. //Retorna falso para cancelar a gravacao

					Return .F.

				EndIf

		End Case

	EndIf

	n := 1
	nControGD := 0

	RestArea(aAreaOld)

return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} fRefreshOS
Atualiza informacoes ao alterar a OS no browse

@type   Function

@author Denis Hyroshi de Souza
@since  01/06/2008
@param  cTJ_ORDEM, Caracter, Código da O.S.
@param  cTJ_PLANO, Caracter, Código do Plano
@param  nLinSTL  , Numérico, Linha posicionada no browse de Insumos
@param  [lRatIns], Lógico  , Define que a chamada vem da função Rateio Insumos

/*/
//-------------------------------------------------------------------
Static Function fRefreshOS( cTJ_ORDEM, cTJ_PLANO, nLinSTL, lRatIns )

	Local lRet		:= .T.
	Local nLinOS	:= 0

	//Controle dos parâmetros MV_PAR01, MV_PAR02 e MV_PAR05
	Private cPar01 := Space(6)
	Private cPar02 := Space(6)
	Private cPar05 := Space(3)

	Default lRatIns := .F.

	If !( IsIncallStack("NGMUStoLvl") .Or. IsIncallStack("NGMUGetSit") )

		//Se o número da OS nao existir no array
		nLinOS := aScan( aDadosOS, {| x| x[1] + x[2] == cTJ_ORDEM + cTJ_PLANO } )

		If nLinOS == 0

			// Limpa tabelas temporárias quando não houver O.S. para serem apresentadas
			NGZap( oTmpTbl3:GetRealName() )

			NGZap( oTmpTbl4:GetRealName() )

			NGZap( oTmpTbl5:GetRealName() )
			
			NGZap( oTmpTbl6:GetRealName() )
		
			// Tratamento para o correto carregamento dos insumos realizados
			lClearData := .T.

			If Type( 'oBrw5' ) == 'O'

				// Insumos realizados
				aCoBrw6     := aClone( aNovoSTL )
				oBrw6:aCols := aClone( aCoBrw6 )
				oBrw6:oBrowse:Refresh()
				oBrw6:oBrowse:SetFocus()

				// Ocorrencias
				oGd435Ocr:aCols := BlankGetD( aHoBrw3 )
				oGd435Ocr:ForceRefresh()

				If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0

					oGd435Ass:aCols := BlankGetD( aHoBrw3_2 )
					oGd435Ass:ForceRefresh()

				EndIf

				// Motivo de Atraso
				aCoBrw4 := BLANKGETD(aHoBrw4)
				oBrw5:oBrowse:Refresh()
				oBrw5:oBrowse:SetFocus()

				// Etapas
				oBrw4:Refresh()

			EndIf

			Return .T.
		EndIf

		If !lStartVar
			Return .T.
		EndIf

		If Empty(cTJ_ORDEM)
			Return .T.
		EndIf

		dbSelectArea("STJ")
		dbSetOrder(01)
		dbSeek(xFilial("STJ")+cTJ_ORDEM+cTJ_PLANO)
		dbSelectArea("STF")
		dbSetOrder(01)
		dbSeek(xFilial("STF")+STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA)
		M->TF_CODBEM  := STJ->TJ_CODBEM
		M->TF_SERVICO := STJ->TJ_SERVICO
		M->TF_SEQRELA := STJ->TJ_SEQRELA
		M->TJ_ORDEM   := STJ->TJ_ORDEM
		M->TJ_PLANO   := STJ->TJ_PLANO
		M->TJ_CODBEM  := STJ->TJ_CODBEM
		cOrdemTJ      := M->TJ_ORDEM
		cPlanoTJ      := M->TJ_PLANO
		cCdBemTJ      := M->TJ_CODBEM
		M->TL_TIPOREG := Space(01)
		MV_PAR01      := STJ->TJ_CODBEM
		MV_PAR02      := STJ->TJ_SERVICO
		MV_PAR05      := STJ->TJ_SEQRELA
		cPar01			:= MV_PAR01
		cPar02 		:= MV_PAR02
		cPar05 		:= MV_PAR05
		lCORRET       := If( Val(STJ->TJ_PLANO) == 0 , .T. , .F. )  //Indica que a OS é corretiva ou nao

		If STJ->TJ_TIPOOS == "B"
			If !NGBEMATIV(STJ->TJ_CODBEM)
				lRet := .F.
			EndIf
			If !NGMANATIV(STJ->TJ_CODBEM,STJ->TJ_SERVICO,STJ->TJ_SEQRELA)
				lRet := .F.
			EndIf
		EndIf

		If !lRet

			oBrw2:oBrowse:Disable()
			oBrw6:oBrowse:Disable()
			oBrw4:Disable()
			oBrw7:Disable()
			oBrw5:oBrowse:Disable()
			oBtAllNext:Disable()
			oBtNext:Disable()
			oBtPrev:Disable()
			oBtAllPrev:Disable()
			oBtEtInc:Disable()
			oBtEtAlt:Disable()
			oBtEtExc:Disable()
			oBtEtAdd:Disable()

		Else

			If ExistBlock( "MNTA435C" )
				oBrw6:oBrowse:Disable()
				oBrw2:oBrowse:Disable()
			Else
				oBrw6:oBrowse:Enable()
				oBrw2:oBrowse:Enable()
			EndIf

			oBrw4:Enable()
			oBrw7:Enable()
			oBrw5:oBrowse:Enable()
			oBtAllNext:Enable()
			oBtNext:Enable()
			oBtPrev:Enable()
			oBtAllPrev:Enable()
			oBtEtInc:Enable()
			oBtEtAlt:Enable()
			oBtEtExc:Enable()
			oBtEtAdd:Enable()

		EndIf

		If SuperGetMV( 'MV_NG1ETPM', .F., 'N' ) == 'S'

			oBtEtExe:Disable()

		EndIf

		/*-----------------------------------------+
		| Ativa manipulação do browse pelo sistema |
		+-----------------------------------------*/
		oGd435Ocr:oBrowse:lDisablePaint := .F.
		oBrw5:oBrowse:lDisablePaint := .F.
		oBrw6:oBrowse:lDisablePaint := .F.

		oBrw6:aCols := aClone( aNovoSTL )

		/*---------------+
		| Carrega Etapas |
		+---------------*/
		LoadEtapas(cTJ_ORDEM, cTJ_PLANO, nLinOS)

		/*-----------------------+
		| Carrega Motivos Atraso |
		+-----------------------*/
		LoadMotAtr(cTJ_ORDEM, cTJ_PLANO, nLinOS)

		If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0
		
			/*--------------------+
			| Carrega Ocorrências |
			+--------------------*/
			fLoadOcorr( nLinOS, 1 )

		EndIf

		/*----------------+
		| Carrega Insumos |
		+----------------*/
		LoadInsum(cTJ_ORDEM, cTJ_PLANO, nLinOS, nLinSTL, lRatIns )

		//Atualiza texto do cabecalho
		cCadastro := cCadTemp + STR0065+cTJ_ORDEM //" O.S.: "
		oDlg1:cTitle := cCadastro

		//Verifica se o parâmetro MV_NGHISES está como "N" para permitir a alteração do custo do insumo
		dbSelectArea("STJ")
		dbSetOrder(1)
		If dbSeek(xFilial("STJ") + cTJ_ORDEM + cTJ_PLANO)
			If STJ->TJ_SERVICO == "HISTOR"
				If cUIntHis == "N" .And. cUsaInt3 == 'S'
					lCusto := .T.
				Else
					lCusto := .F.
				EndIf
			ElseIf cUsaInt3 == 'S'
				lCusto := .F.
			EndIf
		EndIf

		/*--------------------------------------------+
		| Desativa manipulação do browse pelo sistema |
		+--------------------------------------------*/
		oGd435Ocr:oBrowse:lDisablePaint := .T.
		oBrw5:oBrowse:lDisablePaint := .T.
		oBrw6:oBrowse:lDisablePaint := .T.

	EndIf

	oBrwOS:oBrowse:SetFocus()

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} LoadInsum
Monta aHeader e aCols com os insumos da OS selecionada

@type   Function

@author Denis Hyroshi de Souza
@since  23/06/2008
@param  cTJ_ORDEM, Caracter, Código da O.S.
@param  cTJ_PLANO, Caracter, Código do Plano
@param  nLinOS   , Numérico, Numero da linha da O.S.
@param  nLinSTL  , Numérico, Numero da linha do insumo
@param  [lRatIns], Lógico  , Define que a chamada vem da função Rateio Insumos

/*/
//-------------------------------------------------------------------
Static Function LoadInsum(cTJ_ORDEM, cTJ_PLANO, nLinOS, nLinSTL, lRatIns )

	Local aBind     := {}
	Local aTemp     := {}
	Local cKEY      := ''
	Local cGETWHILE := ''
	Local cAlsOrd   := ''
	Local nG        := 0
	Local i         := 0
	Local nX2       := 0
	Local nPosNomCod:= 0
	Local nPosLoja 	:= 0
	Local nPosCod	:= 0
	Local nPosTipReg:= 0
	Local lTemIns   := .T.
	Local lTemAlt   := .T.
	Local lMNTA435P	:= ExistBlock("MNTA435P")
	Local cAliasSTL := ''
	Local cField    := ''

	Default lRatIns := .F.

	n:=1

	If Len(aDadosOS) == 0
		Return .T.
	ElseIf nLinOS == 0
		nLinOS := 1
	EndIf

	// [aDadosOS]
	// 1-Ordem / 2-Plano / 3-Previstos SALVO[] / 4-Realizados SALVO[] / 5-Realizados NOVO[]
	// 6-Motivos Atraso SALVO[] / 7-Motivos Atraso NOVO[] / 8-Etapas NOVO[] / 9-Etapas Outras OS[]
	If Type("aDadosOS["+Alltrim(Str(nLinOS))+",3]") <> "A" .Or. Type("aDadosOS["+Alltrim(Str(nLinOS))+",4]") <> "A"
		lTemIns := .F.
	EndIf
	If Type("aDadosOS["+Alltrim(Str(nLinOS))+",5]") <> "A"
		lTemAlt := .F.
	EndIf

	NGZap( oTmpTbl6:GetRealName() )

	dbSelectArea("STJ")
	dbSetOrder(1)
	dbSeek(xFilial("STJ")+cTJ_ORDEM+cTJ_PLANO,.T.)

	If !Empty(cTJ_ORDEM)

		//Carrega Insumos Previstos
		aCoBrw2 := {}
		If lTemIns
			aCoBrw2 := aClone(aDadosOS[nLinOS,3])
			For nX2 := 1 To Len(aCoBrw2)
				(cTRBIP)->(DbAppend())
				(cTRBIP)->TL_OK      := "  "
				(cTRBIP)->STATUS := "2"
				For i := 1 To Len(aHoBrw2)
					xx := aHoBrw2[i][2]
					(cTRBIP)->(&xx.) := aCoBrw2[nX2,i]
				Next i
				(cTRBIP)->XX_USACAL := If((cTRBIP)->TL_USACALE=="S","Sim",If((cTRBIP)->TL_USACALE=="N","Nao",(cTRBIP)->TL_USACALE))
				(cTRBIP)->XX_DESTIN := If((cTRBIP)->TL_DESTINO=="A","Apoio",If((cTRBIP)->TL_DESTINO=="S","Substituicao",If((cTRBIP)->TL_DESTINO=="T","Troca",(cTRBIP)->TL_DESTINO)))
				(cTRBIP)->XX_TEMGAR := If((cTRBIP)->TL_GARANTI=="S","Sim",If((cTRBIP)->TL_GARANTI=="N","Nao",(cTRBIP)->TL_GARANTI))
				(cTRBIP)->XX_NOMINS := GetNomeTip((cTRBIP)->TL_TIPOREG)
			Next nX2
		Else

			cAlsOrd := GetNextAlias()
			Inclui  := .F.

			BeginSQL Alias cAlsOrd

				SELECT
					STL.R_E_C_N_O_
				FROM
					%table:STL% STL
				WHERE
					STL.TL_FILIAL  = %xFilial:STL%       AND
					STL.TL_ORDEM   = %exp:cTJ_ORDEM%     AND
					STL.TL_PLANO   = %exp:cTJ_PLANO%     AND
					STL.TL_SEQRELA = '0  '               AND
					STL.%NotDel%
				ORDER BY
					STL.TL_SEQTARE

			EndSQL

			While (cAlsOrd)->( !EoF() )

				dbSelectArea( 'STL' )
				dbGoTo( (cAlsOrd)->R_E_C_N_O_ )

				(cTRBIP)->(DbAppend())
				(cTRBIP)->TL_OK  := "  "
				(cTRBIP)->STATUS := "2"
				aTemp := {}
				For i := 1 To Len(aHoBrw2)
					xx := aHoBrw2[i][2]
					If Posicione("SX3",2,xx ,"X3_CONTEXT") == "V"
						(cTRBIP)->(&xx.) := CriaVar( AllTrim(xx) )
					Else
						If xx == "TL_GARANTI"
							Inclui := .T.
							(cTRBIP)->(&xx.) := CriaVar( AllTrim(xx) )
							Inclui := .F.
						ElseIf Posicione("SX3",2,xx ,"X3_CONTEXT") != "V"
							(cTRBIP)->(&xx.) := STL->(&xx.)
						EndIf
					EndIf
					aAdd( aTemp , (cTRBIP)->(&xx.) )
				Next i
				
				(cTRBIP)->XX_USACAL := If((cTRBIP)->TL_USACALE=="S","Sim",If((cTRBIP)->TL_USACALE=="N","Nao",(cTRBIP)->TL_USACALE))
				(cTRBIP)->XX_DESTIN := If((cTRBIP)->TL_DESTINO=="A","Apoio",If((cTRBIP)->TL_DESTINO=="S","Substituicao",If((cTRBIP)->TL_DESTINO=="T","Troca",(cTRBIP)->TL_DESTINO)))
				(cTRBIP)->XX_TEMGAR := If((cTRBIP)->TL_GARANTI=="S","Sim",If((cTRBIP)->TL_GARANTI=="N","Nao",(cTRBIP)->TL_GARANTI))
				(cTRBIP)->XX_NOMINS := GetNomeTip((cTRBIP)->TL_TIPOREG)

				aAdd( aTemp  , {}  )
				aAdd( aTemp  , .F. )
				aAdd( aCoBrw2, aTemp )

				(cAlsOrd)->( dbSkip() )

			End

			(cAlsOrd)->( dbCloseArea() )

			Inclui := .T.

			nPosTipReg	:= aScan( aHoBrw2, {|x| Trim( Upper( x[2] ) ) == 'TL_TIPOREG' } )
			nPosCod		:= aScan( aHoBrw2, {|x| Trim( Upper( x[2] ) ) == 'TL_CODIGO' } )
			nPosLoja	:= aScan( aHoBrw2, {|x| Trim( Upper(x[2] ) ) == 'TL_LOJA' } )
			nPosNomCod	:= aScan( aHoBrw2, {|x| Trim( Upper( x[2] ) ) == 'TL_NOMCODI' } )

			For nG := 1 To Len( aCoBrw2 )

				M->TL_TIPOREG := aCoBrw2[nG, nPosTipReg]
				M->TL_CODIGO := aCoBrw2[nG, nPosCod]

				If nPosLoja > 0

					M->TL_LOJA := aCoBrw2[nG, nPosLoja]

				Else

					M->TL_LOJA := Space( Len( STL->TL_LOJA ) )

				EndIf


				If nPosNomCod > 0
					aCoBrw2[nG, nPosNomCod] := VirtInsumo( M->TL_TIPOREG, M->TL_CODIGO, M->TL_LOJA )
				EndIf
			Next
		EndIf

		cGETWHILE := "TL_FILIAL == xFilial('STL') .And. "
		cGETWHILE += "TL_ORDEM  == '"+cTJ_ORDEM+"' .And. "
		cGETWHILE += "TL_PLANO  == '"+cTJ_PLANO+"'"
		cKEY      := cTJ_ORDEM + cTJ_PLANO

		//Carrega Insumos Realizados
		aCoBrw6 := {}
		
		If !lClearData .And. lTemAlt

			aCoBrw6 := aClone(aDadosOS[nLinOS,5])

		ElseIf !lClearData .And. lTemIns

			aCoBrw6 := aClone(aDadosOS[nLinOS,4])

		Else
			
			Inclui := .F.

			If Empty( cQuerySTL )

				cQuerySTL := " SELECT"
				cQuerySTL += "    STL.R_E_C_N_O_ AS RECNO"
				cQuerySTL += " FROM " + RetSqlName( 'STL' ) + " STL"
				cQuerySTL += " WHERE  STL.TL_FILIAL  = ?"
				cQuerySTL += "    AND STL.TL_ORDEM   = ?"
				cQuerySTL += "    AND STL.TL_PLANO   = ?"
				cQuerySTL += "    AND STL.TL_SEQRELA > '0'"
				cQuerySTL += "    AND STL.D_E_L_E_T_ = ' '"
				cQuerySTL += " ORDER BY"
				cQuerySTL += "    STL.TL_SEQTARE"

			EndIf

			aBind := {}
			aAdd( aBind, FwxFilial( 'STL' ) )
			aAdd( aBind, cTJ_ORDEM )
			aAdd( aBind, cTJ_PLANO )
			
			cAliasSTL := GetNextAlias()

			dbUseArea( .T., 'TOPCONN', TcGenQry2( , , cQuerySTL, aBind ), cAliasSTL, .T., .T. )
			
			Do While (cAliasSTL)->( !EoF() )
				
				aTemp := {}
				
				STL->( DbGoTo( (cAliasSTL)->RECNO ) )

				For i := 1 To Len( aHoBrw6 )

					cField := aHoBrw6[ i, 2 ]

					If aHoBrw6[ i, 10 ] == 'V'
						
						aAdd( aTemp , CriaVar( AllTrim( aHoBrw6[ i, 2 ] ) ) )

					Else
						
						aAdd( aTemp , STL->( &cField. ) )

					EndIf

				Next i
				
				aAdd( aTemp , {} )
				aAdd( aTemp , .F. )
				aAdd( aCoBrw6 , aTemp )

				(cAliasSTL)->( dbSkip() )

			EndDo

			(cAliasSTL)->( dbCloseArea() )

			Inclui := .T.

			//Ponto de Entrada customizar ordenamento dos insumos
			If lMNTA435P
				aCoBrw6 := ExecBlock("MNTA435P",.F.,.F., {aCoBrw6,aHoBrw2})
			Else
				//Ordena pelo campo TL_SEQRELA
				nPos18 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
				If nPos18 > 0
					aSort(aCoBrw6,,,{|x,y| x[nPos18] < y[nPos18] })
				EndIf

			EndIf

		EndIf

		If Len( aCoBrw6 ) == 0

			aCoBrw6 := aClone( aNovoSTL )

		EndIf

		//Atualiza Insumos Previstos
		(cTRBIP)->(dbGoTop())
		oBrw2:oBrowse:Refresh()

		//----------------------------------------------
		//Atualiza legenda/status dos insumos previstos
		//----------------------------------------------
		fStatus()

		If (cTRBIP)->(RecCount()) > 0
			oPnlInput:Enable()
		Else
			oPnlInput:Disable()
		EndIf

		//Atualiza Insumos Previstos
		(cTRBIP)->(dbGoTop())
		oBrw2:oBrowse:Refresh()

		//Atualiza Insumos Realizados e aCols de Ocorrencias
		oBrw6:aCols   := aClone(aCoBrw6)
		oBrw6:aHeader := aClone(aHoBrw6)
		oBrw6:nAt     := 1

		If !lTemIns
			aDadosOS[nLinOS,3] := aClone(aCoBrw2)
			aDadosOS[nLinOS,4] := aClone(aCoBrw6)
		EndIf

		fLoadSTL( nLinSTL )

		PutFileInEof("STL")

		lClearData := .F.

	EndIf

	FwFreeArray( aBind )

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³LoadMotAtr³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Carrega os Motivos de Atrasos - TPL                         |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function LoadMotAtr(_cOrdem,_cPlano, nLinOS)
	Local cGETWHILE := "TPL_ORDEM == '"+  cOrdemTJ  +"'"
	Local lTemIns := .T.
	Local lTemAlt := .T.

	// [aDadosOS]
	// 1-Ordem / 2-Plano / 3-Previstos SALVO[] / 4-Realizados SALVO[] / 5-Realizados NOVO[]
	// 6-Motivos Atraso SALVO[] / 7-Motivos Atraso NOVO[] / 8-Etapas NOVO[] / 9-Etapas Outras OS[]

	If Type("aDadosOS["+Alltrim(Str(nLinOS))+",6]") <> "A"
		lTemIns := .F.
	EndIf
	If Type("aDadosOS["+Alltrim(Str(nLinOS))+",7]") <> "A"
		lTemAlt := .F.
	EndIf

	If lTemAlt
		aCoBrw4 := aClone(aDadosOS[nLinOS,7])
	Else
		dbSelectArea("TPL")
		dbSetOrder(1)
		Inclui := .F.
		aCoBrw4 := MAKEGETD("TPL", _cOrdem,  aHoBrw4, cGETWHILE,,.F.)

		If Len(aCoBrw4) == 0
			aCoBrw4 := BLANKGETD(aHoBrw4)
		EndIf

		Inclui := .T.
		aDadosOS[nLinOS,7] := aClone(aCoBrw4)
	EndIf

	If !lTemIns
		aDadosOS[nLinOS,6] := aClone(aCoBrw4)
	EndIf

	PutFileInEof("TPL")

	n:=1
	aCols   := aClone(aCoBrw4)
	aHeader := aClone(aHoBrw4)
	oBrw5:oBrowse:Default()
	oBrw5:oBrowse:Refresh()

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fTrbEtapa ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Monta o Markbrowse do STQ                                   |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fTrbEtapa()

	Local aHoBrws  	:= NGHeader("STQ", {"TQ_FILIAL","TQ_NOMSITU", "TQ_OK"}, .F.)
	Local nInd1     := 0
	Local nInd     	:= 0
	Local nTot     	:= 0
	Local nTamanho 	:= 0
	Local nDecimal 	:= 0
	Local cCampo   	:= ""
	Local cArquivo 	:= ""
	Local cTipo    	:= ""
	Local aInd435a  := {}

	aDBF  := {}
	aTRBQ := {}

	aAdd( aDBF, { 'TQ_OK', 'C', 02, 0 } )

	For nInd1 := 1 To Len(aHoBrws)

		If Trim( aHoBrws[nInd1,2] ) == 'TQ_NOMETAP'

			aHoBrws[nInd1,4] := 40

		ElseIf Trim( aHoBrws[nInd1,2] ) == 'TQ_CODFUNC'

			aHoBrws[nInd1,1] := STR0066 // Executante

		ElseIf Trim( aHoBrws[nInd1,2] ) == 'TQ_ORDEM' .Or.;
			Trim( aHoBrws[nInd1,2] ) == 'TQ_PLANO'

			aAdd( aDBF, { Trim( aHoBrws[nInd1,2] ), aHoBrws[nInd1,8], aHoBrws[nInd1,4], aHoBrws[nInd1,5] } )

			Loop

		EndIf

		aAdd( aDBF , { Trim( aHoBrws[nInd1,2] ), aHoBrws[nInd1,8], aHoBrws[nInd1,4], aHoBrws[nInd1,5] } )

		aAdd( aTRBQ, { aHoBrws[nInd1,1], Trim( aHoBrws[nInd1,2] ), aHoBrws[nInd1,8], aHoBrws[nInd1,4],;
			aHoBrws[nInd1,5], aHoBrws[nInd1,3]} )

	Next nInd1

	//Campos de uso exclusivo da Legenda
	aAdd( aDBF, { 'CODBEM'	  , 'C', 16, 0 } )
	aAdd( aDBF, { 'SEQRELA'	  , 'N', 03, 0 } )
	aAdd( aDBF, { 'QUANTID'	  , 'N', 09, 0 } )
	aAdd( aDBF, { 'STATUS'	  , 'C', 01, 0 } )
	aAdd( aDBF, { 'TQ_MARK'   , 'C', 02, 0 } )
	aAdd( aDBF, { 'TQ_SEQRELA', 'C', 03, 0 } )
	aAdd( aDBF, { 'RECSTQ'    , 'N', 10, 0 } )

	aInd435a := { 	{ 'TQ_TAREFA' , 'TQ_SEQETA', 'TQ_ETAPA' },;
					{ 'TQ_TAREFA' , 'TQ_ETAPA' , 'TQ_SEQETA', 'TQ_SEQTARE' },;
					{ 'TQ_SEQTARE', 'TQ_SEQETA', 'TQ_TAREFA', 'TQ_ETAPA' },;
					{ 'TQ_ORDEM'  , 'TQ_PLANO' , 'TQ_TAREFA', 'TQ_ETAPA', 'TQ_SEQRELA' },;
					{ 'TQ_MARK' } ,;
					{ 'TQ_SEQRELA' } }

	//Criação Tabela Temporária
	oTmpTbl3 := NGFwTmpTbl( cTRBQ400, aDBF, aInd435a )

	/*------------------------------------------------------------------------+
	| Cria tabela temporária para insumos listados no processo de associação. |
	+------------------------------------------------------------------------*/
	oTmpTbl9 := FWTemporaryTable():New( cAlsExecu, aDBF )
	oTmpTbl9:Create()

	aDBFTar := {}
	aAdd(aDBFTar,{"TAREFA" ,"C",06,0})
	aAdd(aDBFTar,{"NOMETAR","C",20,0})
	aAdd(aDBFTar,{"ETAPA"  ,"C",06,0})
	aAdd(aDBFTar,{"NOMEETA","C",40,0})
	aAdd(aDBFTar,{"ORDEM"  ,"C",06,0})
	aAdd(aDBFTar,{"DTMPINI","D",08,0})

	//Indice Tabela Temporária
	aInd435d := {{"DTMPINI","TAREFA","ETAPA","ORDEM"},{"TAREFA","ETAPA"}}
	//Criação Tabela Temporária
	oTmpTbl4 := NGFwTmpTbl(cTRBTAR,aDBFTar,aInd435d)

	aDBF3 := TPC->( dbStruct() )

	aAdd(aDBF3,{"TPC_RESPOS","C",TAMSX3( 'TPQ_RESPOS' )[1],0})
	aAdd(aDBF3,{"TPC_OK"    ,"C",2,0})
	aAdd(aDBF3,{"TPC_TAREFA","C",6,0})

	aCposAlTPQ := {}
	If ExistBlock("NG405CPU")
		aCposAlTPQ := ExecBlock("NG405CPU",.F.,.F.)
	EndIf

	//--------------------------------------------------------
	//Agrega no array aHeader os campos de Usuarios...
	//--------------------------------------------------------
	nTot := Len(aCposAlTPQ)
	For nInd := 1 To nTot

		cCampo   := aCposAlTPQ[nInd]
		cArquivo := Posicione("SX3",2,cCampo,"X3_ARQUIVO")
		If (cArquivo)->(FieldPos(cCampo)) > 0

			cTipo    := Posicione("SX3",2,cCampo,"X3_TIPO")
			nTamanho := TAMSX3(cCampo)[1]
			nDecimal := TAMSX3(cCampo)[2]

			aAdd(aDBF3,{cCampo,cTipo,nTamanho,nDecimal})

		EndIf

	Next nInd

	//Criação Tabela Temporária
	oTmpTbl5 := NGFwTmpTbl(cTRB3400,aDBF3,{{ "TPC_ETAPA","TPC_TAREFA","TPC_OPCAO" }})

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} LoadEtapas
Carrega as etapas da OS - STQ

@author  Denis Hyroshi de Souza
@since   23/06/08
@version P11/P12
@param   _cOrdem, Caracter, Código da O.S.
@param   _cPlano, Caracter, Plano
@param   nLisOS , Numérico, Linha posicionada na grid de O.S.
/*/
//-------------------------------------------------------------------
Static Function LoadEtapas(_cOrdem,_cPlano, nLinOS)

	Local i,xx
	Local nInd1     := 0
	Local nInd2     := 0
	Local nPosResp  := 0
	Local cAliasQry := ''
	Local lTemTb8   := Type( 'aDadosOS[' + AllTrim( Str( nLinOS ) ) + ',8]' ) != 'A'
	Local lTemTb9   := Type("aDadosOS["+Alltrim(Str(nLinOS))+",9]") != "A"
	Local aTempCab
    Local cBanco  := Upper(TCGetDB())
	Local aSql := {'', ''}

	// [aDadosOS]
	// 1-Ordem / 2-Plano / 3-Previstos SALVO[] / 4-Realizados SALVO[] / 5-Realizados NOVO[]
	// 6-Motivos Atraso SALVO[] / 7-Motivos Atraso NOVO[] / 8-Etapas NOVO[] / 9-Etapas Outras OS[]

	If cBanco == 'ORACLE'
        aSql[2] := ' OFFSET 0 ROWS FETCH NEXT 1 ROWS ONLY '
    ElseIf cBanco $  'POSTGRES/MYSQL'
        aSql[2] := ' LIMIT 1 '
    Else
        aSql[1] := ' TOP 1 '
	EndIf

	NGZap( oTmpTbl3:GetRealName() )

	NGZap( oTmpTbl4:GetRealName() )
	
	NGZap( oTmpTbl5:GetRealName() )
	
	dbSelectArea("STJ")
	dbSetOrder(1)
	dbSeek(xFilial("STJ")+_cOrdem+_cPlano)

	Inclui := .F.

	//+----------------------------------+
	//| Carregando etapas de outras OS   |
	//+----------------------------------+
	If lTemTb9

		If cMVPAR01 $ '1/3'

			cAliasQry := GetNextAlias()

			If cMVPAR01 == '1'

				cQuery := " SELECT STQ.TQ_TAREFA, STQ.TQ_ETAPA, STQ.TQ_ORDEM, STJ.TJ_CODBEM,"
				cQuery += " STJ.TJ_SERVICO, STJ.TJ_SEQRELA,STJ.TJ_DTMPINI, STJ.TJ_PLANO, TPA.TPA_DESCRI,"

				If SuperGetMv( 'MV_NGTARGE', .F., '1' ) == '1'

					cQuery += "    ( SELECT TT9_DESCRI FROM " + RetSqlName( 'TT9' ) + " WHERE TT9_FILIAL = " + ValToSql( FWxFilial( 'TT9' ) )
					cQuery += "            AND TT9_TAREFA = STQ.TQ_TAREFA AND D_E_L_E_T_ = ' ' )"
					cQuery += " AS TARDESCRI "

				Else

					cQuery += " CASE WHEN STJ.TJ_PLANO = '000000' THEN ' '
					cQuery += " ELSE
					cQuery += "    ( SELECT " + aSql[1] + " T5_DESCRIC FROM " + RetSqlName( 'ST5' ) + " WHERE T5_FILIAL = " + ValToSql( FWxFilial( 'ST5' ) )
					cQuery += "            AND T5_CODBEM = STJ.TJ_CODBEM AND T5_TAREFA = STQ.TQ_TAREFA "
					cQuery += "            AND T5_SERVICO = STJ.TJ_SERVICO AND D_E_L_E_T_ = ' ' " + aSql[2] + " )"
					cQuery += " END AS TARDESCRI "

				EndIf
				cQuery += " FROM " + RetSQLName("STQ") + " STQ"
				cQuery += " INNER JOIN "+RetSqlName("STJ")+" STJ"
				cQuery += " ON (STQ.TQ_ORDEM = STJ.TJ_ORDEM) "
				cQuery += " INNER JOIN " + RetSQLName( "TPA" ) + " TPA "
				cQuery += " ON ( TPA.TPA_ETAPA = STQ.TQ_ETAPA )
				cQuery += " WHERE STJ.TJ_CODBEM = '"+STJ->TJ_CODBEM+"'"
				cQuery += " AND STQ.TQ_OK = ''"
				cQuery += " AND (STQ.TQ_TAREFA <> '' OR STQ.TQ_ETAPA <> '') "
				cQuery += " AND STJ.TJ_ORDEM <> '"+_cOrdem+"' AND STJ.TJ_TERMINO = 'S' "
				cQuery += " AND STQ.TQ_FILIAL = " + ValToSQL( FWxFilial("STQ") ) + " AND STQ.D_E_L_E_T_ = ' ' "
				cQuery += " AND STJ.TJ_FILIAL = " + ValToSQL( FWxFilial("STJ") ) + " AND STJ.D_E_L_E_T_ = ' ' "
				cQuery += " AND TPA.TPA_FILIAL = " + ValToSQL( FWxFilial( 'TPA' ) ) + " AND TPA.D_E_L_E_T_ = ' ' "
				cQuery := ChangeQuery(cQuery)
				dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

			Else

				BeginSQL Alias cAliasQry

					SELECT  STQ.TQ_TAREFA,
							STQ.TQ_ETAPA,
							STQ.TQ_ORDEM,
							STJ.TJ_CODBEM,
							STJ.TJ_SERVICO,
							STJ.TJ_SEQRELA,
							STJ.TJ_DTMPINI,
							STJ.TJ_PLANO,
							TPA.TPA_DESCRI,
							CASE
								WHEN STJ.TJ_PLANO = '000000' THEN ( SELECT TT9_DESCRI
																	FROM   %table:TT9%
																	WHERE  TT9_FILIAL = %xFilial:TT9%
																	AND TT9_TAREFA = STQ.TQ_TAREFA
																	AND %NotDel% )
								ELSE ( SELECT T5_DESCRIC
									FROM   %table:ST5%
									WHERE  T5_FILIAL = %xFilial:ST5%
											AND T5_CODBEM  = STJ.TJ_CODBEM
											AND T5_TAREFA  = STQ.TQ_TAREFA
											AND T5_SERVICO = STJ.TJ_SERVICO
											AND %NotDel% )
							END AS TARDESCRI
							FROM   %table:STJ% STJ
								INNER JOIN %table:STQ% STQ
										ON ( STJ.TJ_FILIAL = STQ.TQ_FILIAL
												AND STJ.TJ_ORDEM  = STQ.TQ_ORDEM
												AND STJ.TJ_CODBEM = %exp:STJ->TJ_CODBEM% )
								INNER JOIN %table:TPA% TPA
										ON ( TPA.TPA_ETAPA = STQ.TQ_ETAPA )
							WHERE  STQ.TQ_OK = ' '
								AND STJ.TJ_TERMINO = 'S'
								AND STJ.TJ_ORDEM  != %exp:_cOrdem%
								AND STQ.TQ_FILIAL  = %xFilial:STQ%
								AND STQ.%NotDel%
								AND STJ.TJ_FILIAL  = %xFilial:STJ%
								AND STJ.%NotDel%
								AND STJ.TJ_DTMRFIM || STJ.TJ_HOMRFIM = ( SELECT Max( STJ1.TJ_DTMRFIM || STJ1.TJ_HOMRFIM )
																		FROM  %table:STQ% STQ1
									INNER JOIN %table:STJ% STJ1
											ON ( STQ1.TQ_FILIAL = STJ1.TJ_FILIAL
													AND STQ1.TQ_ORDEM = STJ1.TJ_ORDEM )
									WHERE  STQ1.TQ_OK = ' '
										AND STQ1.TQ_FILIAL  = %xFilial:STQ%
										AND STQ1.%NotDel%
										AND STJ1.TJ_FILIAL  = %xFilial:STJ%
										AND STJ1.%NotDel%
										AND STJ1.TJ_TERMINO = 'S'
										AND STJ1.TJ_CODBEM  = %exp:STJ->TJ_CODBEM%
										AND STJ1.TJ_DTMRFIM || STJ1.TJ_HOMRFIM < %exp:DToS( dDataBase ) + SubStr( Time(), 1, 5 )%
										AND STQ1.TQ_TAREFA  = STQ.TQ_TAREFA
										AND STQ1.TQ_ETAPA   = STQ.TQ_ETAPA )
										AND STQ.TQ_TAREFA NOT IN ( SELECT STQ2.TQ_TAREFA
															FROM   %table:STQ% STQ2
																	INNER JOIN %table:STJ% STJ2
																			ON ( STQ2.TQ_FILIAL = STJ2.TJ_FILIAL
																				AND STQ2.TQ_ORDEM = STJ2.TJ_ORDEM )
															WHERE  STQ2.TQ_OK != ' '
																	AND STJ2.TJ_DTMRFIM || STJ2.TJ_HOMRFIM >=
																		STJ.TJ_DTMRFIM  || STJ.TJ_HOMRFIM
																	AND STQ2.TQ_FILIAL  = %xFilial:STQ%
																	AND STQ2.%NotDel%
																	AND STJ2.TJ_FILIAL  = %xFilial:STJ%
																	AND STJ2.%NotDel%
																	AND STJ2.TJ_TERMINO = 'S'
																	AND STJ2.TJ_CODBEM  = %exp:STJ->TJ_CODBEM%
																	AND STQ2.TQ_TAREFA  = STQ.TQ_TAREFA
																	AND STQ2.TQ_ETAPA   = STQ.TQ_ETAPA  )

								AND STQ.TQ_ETAPA NOT IN (SELECT STQ2.TQ_ETAPA
															FROM   %table:STQ% STQ2
																INNER JOIN %table:STJ% STJ2
																		ON ( STQ2.TQ_FILIAL = STJ2.TJ_FILIAL
																				AND STQ2.TQ_ORDEM = STJ2.TJ_ORDEM )
															WHERE  STQ2.TQ_OK != ' '
																AND STJ2.TJ_DTMRFIM || STJ2.TJ_HOMRFIM >= STJ.TJ_DTMRFIM || STJ.TJ_HOMRFIM
																AND STQ2.TQ_FILIAL  = %xFilial:STQ%
																AND STQ2.%NotDel%
																AND STJ2.TJ_FILIAL  = %xFilial:STJ%
																AND STJ2.%NotDel%
																AND STJ2.TJ_TERMINO = 'S'
																AND STJ2.TJ_CODBEM  = %exp:STJ->TJ_CODBEM%
																AND STQ2.TQ_TAREFA  = STQ.TQ_TAREFA
																AND STQ2.TQ_ETAPA   = STQ.TQ_ETAPA  )

								AND TPA.TPA_FILIAL = %xFilial:TPA%
								AND TPA.%NotDel%
				EndSQL
			EndIf

			aTempCab := {}
			dbSelectArea(cTRBTAR)
			(cAliasQry)->( dbGoTop() )
			While (cAliasQry)->( !EoF() )

				(cTRBTAR)->(DbAppend())
				(cTRBTAR)->TAREFA  := (cAliasQry)->TQ_TAREFA
				(cTRBTAR)->NOMETAR := (cAliasQry)->TARDESCRI
				(cTRBTAR)->ETAPA   := (cAliasQry)->TQ_ETAPA
				(cTRBTAR)->NOMEETA := (cAliasQry)->TPA_DESCRI
				(cTRBTAR)->ORDEM   := (cAliasQry)->TQ_ORDEM
				(cTRBTAR)->DTMPINI := STOD( (cAliasQry)->TJ_DTMPINI )

				aAdd( aTempCab, {   (cTRBTAR)->TAREFA,;
									(cTRBTAR)->NOMETAR,;
									(cTRBTAR)->ETAPA,;
									(cTRBTAR)->NOMEETA,;
									(cTRBTAR)->ORDEM,;
									(cTRBTAR)->DTMPINI } )

				(cAliasQry)->( dbSkip() )
			EndDo

			(cAliasQry)->( dbCloseArea() )

			If Len(aTempCab) == 0
				aAdd( aTempCab , { " ",;
				" ",;
				" ",;
				" ",;
				" ",;
				StoD("") } )
			EndIf

		EndIf

		If Type("aTempCab") == "A"
			aDadosOS[nLinOS,9] := aClone(aTempCab)
		Else
			aDadosOS[nLinOS,9] := Nil
		EndIf
	Else
		dbSelectArea(cTRBTAR)
		For i := 1 to Len(aDadosOS[nLinOS,9])
			(cTRBTAR)->(DbAppend())
			(cTRBTAR)->TAREFA  := aDadosOS[nLinOS,9,i,1]
			(cTRBTAR)->NOMETAR := aDadosOS[nLinOS,9,i,2]
			(cTRBTAR)->ETAPA   := aDadosOS[nLinOS,9,i,3]
			(cTRBTAR)->NOMEETA := aDadosOS[nLinOS,9,i,4]
			(cTRBTAR)->ORDEM   := aDadosOS[nLinOS,9,i,5]
			(cTRBTAR)->DTMPINI := aDadosOS[nLinOS,9,i,6]
		Next i
	EndIf

	//+---------------------------------------+
	//| Carregando etapas previstas desta OS  |
	//+---------------------------------------+
	If lTemTb8

		aTempCab := {}
		dbSelectArea("STQ")
		dbSetOrder(1)
		dbSeek(xFilial("STQ")+_cOrdem+_cPlano)
		While !EoF() .And. STQ->TQ_FILIAL == xFilial("STQ") .And. STQ->TQ_ORDEM == _cOrdem .And. STQ->TQ_PLANO == _cPlano

			If Empty(STQ->TQ_TAREFA) .And. Empty(STQ->TQ_ETAPA)
				dbSelectArea("STQ")
				dbSkip()
				Loop
			EndIf

			aTemp := {}

			RecLock( cTRBQ400, .T. )

				For nInd1 := 1 To Len( aTRBQ )

					xx := aTRBQ[nInd1,2]

					If Posicione( 'SX3', 2, aTRBQ[nInd1,2] , 'X3_CONTEXT' ) == 'V'

						(cTRBQ400)->( &xx. ) := CriaVar( AllTrim( xx ) )

					Else

						(cTRBQ400)->( &xx. ) := STQ->( &xx. )

					EndIf

					aAdd( aTemp, (cTRBQ400)->( &xx. ) )

				Next nInd1

				If STQ->( FieldPos( 'TQ_SEQRELA' ) ) > 0

					(cTRBQ400)->TQ_SEQRELA := STQ->TQ_SEQRELA

				Else

					(cTRBQ400)->TQ_SEQRELA := '0'

				EndIf
				
				If !Empty( STQ->TQ_OK )

					(cTRBQ400)->TQ_OK := cMarca
				
				EndIf

				(cTRBQ400)->TQ_ORDEM := STQ->TQ_ORDEM
				(cTRBQ400)->TQ_PLANO := STQ->TQ_PLANO
				(cTRBQ400)->CODBEM	 := STJ->TJ_CODBEM
				(cTRBQ400)->RECSTQ   := STQ->( RecNo() )

			MsUnLock()

			//Adicionando opcoes da etapa
			aOpcEtapa := {}
			dbSelectArea("TPQ")
			dbSetOrder(1)
			dbSeek(xFilial("TPQ") + _cOrdem +_cPlano + STQ->TQ_TAREFA + STQ->TQ_ETAPA )
			While !EoF() .And. TPQ->TPQ_FILIAL == xFilial("TPQ") .And.;
			TPQ->TPQ_ORDEM == _cOrdem .And. TPQ->TPQ_PLANO == _cPlano .And. ;
			TPQ->TPQ_TAREFA == STQ->TQ_TAREFA .And. TPQ->TPQ_ETAPA == STQ->TQ_ETAPA

				aAdd( aOpcEtapa , { "XX" , TPQ->TPQ_OPCAO , TPQ->TPQ_RESPOS } )

				RecLock( cTRB3400, .T. )
				
					(cTRB3400)->TPC_ETAPA  := STQ->TQ_ETAPA
					(cTRB3400)->TPC_TAREFA := STQ->TQ_TAREFA
					(cTRB3400)->TPC_OK     := "XX"
					(cTRB3400)->TPC_OPCAO  := TPQ->TPQ_OPCAO
					(cTRB3400)->TPC_RESPOS := TPQ->TPQ_RESPOS

				MsUnLock()

				dbSelectArea("TPQ")
				dbSkip()

			End

			/*----------------------------------------+
			| Define as cores para legenda de etapas. |
			+----------------------------------------*/
			fLegendEt( (cTRBQ400)->TQ_ORDEM + (cTRBQ400)->TQ_PLANO + (cTRBQ400)->TQ_TAREFA +;
				(cTRBQ400)->TQ_ETAPA + (cTRBQ400)->TQ_SEQRELA, 4 )

			aAdd( aTemp, (cTRBQ400)->TQ_OK )
			aAdd( aTemp, (cTRBQ400)->TQ_SEQRELA )
			aAdd( aTemp, (cTRBQ400)->RECSTQ )
			aAdd( aTemp, aOpcEtapa )
			aAdd( aTemp, (cTRBQ400)->STATUS )//STATUS#//MANTER A CRIAÇÃO DO CAMPO STATUS SEMPRE COMO ULTIMO NA TRB

			aAdd( aTempCab , aTemp )

			dbSelectArea("STQ")
			dbSkip()

		EndDo
	
		aDadosOS[nLinOS,8] := aClone(aTempCab)

	Else

		nPosResp := Len( aTrbQ ) + 4

		For nInd1 := 1 To Len( aDadosOS[nLinOS,8] )

			RecLock( (cTRBQ400), .T. )

				For nInd2 := 1 To Len( aTrbQ )

					cField := aTrbQ[nInd2,2]

					(cTRBQ400)->( &cField. ) := aDadosOS[nLinOS,8,nInd1,nInd2]
				
				Next nInd2
			
				(cTRBQ400)->TQ_OK      := aDadosOS[nLinOS,8,nInd1,nInd2++]
				(cTRBQ400)->TQ_SEQRELA := aDadosOS[nLinOS,8,nInd1,nInd2++]
				(cTRBQ400)->RECSTQ     := aDadosOS[nLinOS,8,nInd1,nInd2++]
				(cTRBQ400)->STATUS     := aDadosOs[nLinOS,8,nInd1,Len(aDadosOS[nLinOS,8,nInd1])]
				(cTRBQ400)->TQ_ORDEM   := _cOrdem
				(cTRBQ400)->TQ_PLANO   := _cPlano
				(cTRBQ400)->CODBEM	   := STJ->TJ_CODBEM

			MsUnLock()

			For nInd2 := 1 To Len( aDadosOS[nLinOS,8,nInd1,nPosResp] )

				RecLock( cTRB3400, .T. )
					
					(cTRB3400)->TPC_ETAPA  := (cTRBQ400)->TQ_ETAPA
					(cTRB3400)->TPC_TAREFA := (cTRBQ400)->TQ_TAREFA
					(cTRB3400)->TPC_OK     := aDadosOS[nLinOS,8,nInd1,nPosResp,nInd2,1]
					(cTRB3400)->TPC_OPCAO  := aDadosOS[nLinOS,8,nInd1,nPosResp,nInd2,2]
					(cTRB3400)->TPC_RESPOS := aDadosOS[nLinOS,8,nInd1,nPosResp,nInd2,3]

				MsUnLock()
			
			Next nInd2

		Next nInd1

	EndIf

	If cMVPAR01 == '3'

		dbSelectArea(cTRBQ400)
		dbSetOrder(2)
		dbGotop()
		While !EoF()
			dbSelectArea(cTRBTAR)
			dbSetOrder(2)
			If dbSeek( (cTRBQ400)->TQ_TAREFA + (cTRBQ400)->TQ_ETAPA )
				RecLock((cTRBTAR),.F.)
				dbDelete()
				(cTRBTAR)->(MsUnLock())
			EndIf

			dbSelectArea(cTRBQ400)
			dbSkip()
		EndDo

	EndIf

	Inclui := .T.

	dbSelectArea( cTRBQ400 )
	dbSetOrder( 3 ) // ordena visualização das etapas pela sequencia tarefa + etapa

	oBrw4:Refresh()
	oBrw4:GoTop()

	dbSelectArea(cTRBTAR)
	dbSetOrder(1)
	dbGotop()

	oBrw7:Refresh()

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} fVldAltOS
Valida se houve alterações na rotina e informa usuário caso seja
cancelada a tela.

@type   Function

@author Eduardo Mussi
@since  13/10/2022
@param  lForAtu, Lógico, Força atualização das abas presentes na tela

@return Lógico, define se o processo poderá prosseguir
/*/
//-------------------------------------------------------------------
Static Function fVldAltOS( lForAtu )

	Default lForAtu := .F.

	oDlg1:LESCCLOSE := .F.

	If !Empty( (cAliOS435)->TJ_CODBEM )

		// Força verificação das abas da O.S. posicionada para validar se houve algum tipo de alteração
		If !lFoiAlterado .And. lForAtu

			Fd_Sai( 1 )
			Fd_Sai( 2 )
			Fd_Sai( 3 )
			Fd_Sai( 4 )

		EndIf

		If lFoiAlterado
			nRetAviso := Aviso(STR0037,STR0069, ; //"Atenção"###"Existem alterações que ainda não foram processadas. Deseja gravá-las ou desfazê-las?"
			{STR0070,STR0071,STR0072}) //"Gravar"###"Desfazer"###"Cancelar"
			If nRetAviso == 1
				If fValidOK( .T., .F. )
					Processa({|| fGrava435(,.T.) } , STR0002 ) //"Gravando as informações"
				Else
					Return .T.
				EndIf
			ElseIf nRetAviso == 3
				Return .F.
			EndIf
			lFoiAlterado := .F.

		EndIf

	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fPFiltro ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Cria a tela de funcionarios da especialidade                |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fPFiltro(cCod_Esp,nQtRec,dDtIniTL)

	Local oDlg2,oOS2,aOS2 := {},oSayEspe
	Local lOutraEsp := .F.
	Local aTemp
	Local nXX
	Local cPesquisar := Space( 200 )
	Local aDescIdx	:= {"Código","Nome"}

	Private cCodEspec := Padr(cCod_Esp,Len(ST2->T2_ESPECIA))
	Private cQtdEspec := If(Valtype(nQtRec)=="N",If(nQtRec>0,nQtRec,1),1)
	Private nPosCpo1 := 0

	Private aCbxPesq //ComboBox com indices de pesquisa
	Private cCbxPesq   := ""
	Private oCbxPesq //ComboBox de Pesquisa

	dbSelectArea("ST0")
	dbSetOrder(1)
	dbSeek(xFilial("ST0")+cCodEspec)

	nOpcFun := 0
	Define MsDialog oDlg2 Title OemToAnsi(STR0076) From 089,232 To 407,619 Of oMainWnd Pixel //"Funcionários"

	aCbxPesq := aClone( aDescIdx )
	cCbxPesq := aCbxPesq[ 1 ]

	@ 002,004 Say STR0077 of oDlg2 Font oFont2 Pixel COLOR CLR_BLUE  //"Especialidade:"
	@ 002,070 Say oSayEspe Prompt ST0->T0_NOME of oDlg2 Font oFont2 Pixel COLOR CLR_BLACK
	@ 013,004 Say STR0078 of oDlg2 Font oFont2 Pixel COLOR CLR_BLUE  //"Quantidade:"
	@ 013,070 Say nQtRec of oDlg2 Font oFont2 Pixel COLOR CLR_BLACK

	oPesquisar := TGet():New( 024 , 004 , { | u | If( PCount() > 0 , cPesquisar := u , cPesquisar ) } , oDlg2 , 110 , 008 , "" , { | | .T. } , CLR_BLACK , CLR_WHITE , ,;
	.F. , , .T. /*lPixel*/ , , .F. , { | | cCbxPesq <> aCbxPesq[ Len( aCbxPesq ) ] }/*bWhen*/ , .F. , .F. , , .F. /*lReadOnly*/ , .F. , "" , "cPesquisar" , , , , .F. /*lHasButton*/ )

	oBtnPesq := TButton():New( 024 , 127 , STR0181 , oDlg2 , { | | fPesqEsp( @aOS2 , @oOS2, cPesquisar ) } , ;
	60 , 10 , , , .F. , .T. , .F. , , .F. , , , .F. )

	@ 035,004 ListBox oOS2 Fields;
	Header  " ",;
	STR0079,; //"Código"
	STR0080; //"Nome"
	Size    184,094 Of oDlg2 Pixel

	bOS2Line1 := { || { If(aOS2[oOS2:nAt,1]==1,oChecked,oBranco),aOS2[oOS2:nAt,2],aOS2[oOS2:nAt,3] } }
	bOS2Line2 := { || { oBranco, Space(6), Space(40) } }
	oOS2:SetArray( aOS2 )
	IIF(Len(aOS2)>0,oOS2:bLine:= bOS2Line1,oOS2:bLine:= bOS2Line2)
	oOS2:bLDblClick := {|| fMarkFunc(@oOS2,@aOS2) , oOS2:DrawSelect() }
	oOS2:GoTop()
	oOS2:Refresh()

	fShowFunc(@oOS2,@aOS2,@oSayEspe,lOutraEsp,dDtIniTL)

	@ 142, 004 CheckBox oCBox1 Var lOutraEsp Prompt STR0081 Of oDlg2 On Change fShowFunc(@oOS2,@aOS2,@oSayEspe,lOutraEsp,dDtIniTL) Pixel SIZE 80,09 //"Outra Especialidade?"

	Define sButton oBtOk  from 142, 126 type 1 enable of oDlg2 pixel Action ( nOpcFun:=1,If(fVldMkFun(@oOS2,@aOS2,nQtRec),oDlg2:End(),nOpcFun:=2) )
	Define sButton oBtCan from 142, 156 type 2 enable of oDlg2 pixel Action (nOpcFun:=2,oDlg2:End())

	oDlg2:Activate(,,,.T.)

	If nOpcFun == 1
		aTemp := {}
		For nXX := 1 To Len(aOS2)
			If aOS2[nXX,1] == 1
				aAdd( aTemp , aOS2[nXX,2] )
			EndIf
		Next aOS2
		Return aTemp
	EndIf

Return nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fVldMkFun³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida tela de selecao dos funcionarios                    |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fVldMkFun(oOS2,aOS2,nQtRec)
	Local nXX,nCont := 0

	For nXX := 1 To Len(aOS2)
		If aOS2[nXX,1] == 1
			nCont++
		EndIf
	Next aOS2

	If nCont <> nQtRec
		If !MsgYesNo(STR0082+; //"A quantidade de funcionários selecionados não corresponde à quantidade prevista. Deseja continuar?"
		Chr(13)+Chr(10)+STR0083+Alltrim(Str(nQtRec,6))+; //"Qtde. Prevista: "
		Chr(13)+Chr(10)+STR0084+Alltrim(Str(nCont,6)) ) //"Qtde. Selecionada: "
			Return .F.
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fMarkFunc³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Mostra um funcionario                                       |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fMarkFunc(oOS2,aOS2)
	If aOS2[oOS2:nAt][1] == 0
		aOS2[oOS2:nAt][1] := 1
	Else
		aOS2[oOS2:nAt][1] := 0
	EndIf
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fShowFunc³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Mostra todos os funcionarios                                |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fShowFunc(oOS2,aOS2,oSayEspe,lOutraEsp,dDtIniTL)
	Local dDtIni2 := If( Valtype(dDtIniTL)<>"D" .Or. Empty(dDtIniTL) , dDataBase , dDtIniTL )

	aOS2 := {}

	IF lOutraEsp

		dbSelectArea("ST1")
		dbSetOrder(1)
		dbSeek(xFilial("ST1"))
		While !EoF() .And. xFilial("ST1") == ST1->T1_FILIAL
			If !NGFUNCRH(ST1->T1_CODFUNC,.F.,dDtIni2)
				dbSelectArea("ST1")
				dbSkip()
				Loop
			EndIf
			If ST1->T1_DISPONI <> "N"
				aAdd(aOS2,{0,ST1->T1_CODFUNC, ST1->T1_NOME })
			EndIf
			dbSkip()
		End

		oSayEspe:SetText(STR0085) //"TODAS"

	Else

		dbSelectArea("ST2")
		dbSetOrder(2)
		dbSeek(xFilial("ST2")+cCodEspec)
		While !EoF() .And. xFilial("ST2") == ST2->T2_FILIAL .And. cCodEspec == ST2->T2_ESPECIA
			dbSelectArea("ST1")
			dbSetOrder(1)
			dbSeek(xFilial("ST1")+ST2->T2_CODFUNC)
			If !NGFUNCRH(ST2->T2_CODFUNC,.F.,dDtIni2)
				dbSelectArea("ST2")
				dbSkip()
				Loop
			EndIf
			If ST1->T1_DISPONI <> "N"
				aAdd(aOS2,{0,ST1->T1_CODFUNC, ST1->T1_NOME })
			EndIf
			dbSelectArea("ST2")
			dbSkip()
		End

		oSayEspe:SetText(ST0->T0_NOME)

	EndIf

	oOS2:SetArray( aOS2 )
	IIF(Len(aOS2)>0,oOS2:bLine:= bOS2Line1,oOS2:bLine:= bOS2Line2)
	oOS2:GoTop()
	oOS2:Refresh()

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fPrgNext ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Adiciona todos os insumos previstos em Realizados          |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fPrgNext()

	Local aCodFunc 	:= {}
	Local cProdBloq := ''
	Local cCodInsum := ''
	Local cNGMNTES	:= SuperGetMv( 'MV_NGMNTES', .F., 'N' )
	Local cLocPad   := SuperGetMV( 'MV_NGLOCPA', .F., '01' )
	Local cNGUNIDT  := SuperGetMV( 'MV_NGUNIDT', .F., 'S' )
	Local lTemSC1 	:= .F.
	Local nYY 		:= 0
	Local nZZZ 		:= 0
	Local nQtdCvrt  := 0
	Local nSeqTmp 	:= 0
	Local nLenBrw6	:= 0
	Local nCustIns  := 0
	Local lMNTA435O	:= ExistBlock( 'MNTA435O' )
	Local lMNTA435R := ExistBlock( 'MNTA435R' )

	Local nPos 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPox 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPoZ 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NOMCODI"})
	Local nPoQ 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANREC"})
	Local nPoY 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA" })
	Local nPos18 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	Local nDtIni 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	Local nDtFim 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"  })
	Local nCpoGar 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_GARANTI"})
	Local nNumSa  	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSA"  })
	Local nITEMSa  	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_ITEMSA" })
	Local nQuanti  	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})

	Local nPosCust  := GDFieldPos( 'TL_CUSTO'  , aHoBrw2 )
	Local nPosAlmo  := GDFieldPos( 'TL_LOCAL'  , aHoBrw2 )
	Local nPosSeqT  := GDFieldPos( 'TL_SEQTARE', aHoBrw2 )

	lRet435 := .T.

	oBrwOS:SetFocus()
	If !lRet435 //Problema encontrado em alguma rotina de validacao da LinhaOK
		Return .F.
	EndIf

	nLenBr6 := Len(aCoBrw6)
	If nLenBr6 == 1
		If Empty(aCoBrw6[1,nPox])
			aCoBrw6 := {}
		EndIf
	ElseIf nLenBr6 > 1
		If Empty(aCoBrw6[nLenBr6,nPox])
			aDel(aCoBrw6,nLenBr6)
			aSize(aCoBrw6,nLenBr6-1)
			oBrw6:lNewLine := .F.
		EndIf
	EndIf

	lFirstMsg := .T.
	dbSelectArea(cTRBIP)
	dbGoTop()
	While !EoF()

		nYY := aScan( aCoBrw2, { |x| x[nPoY] + x[nPos] + x[nPox] + x[nPos18] + x[nPosSeqT] == (cTRBIP)->TL_TAREFA + (cTRBIP)->TL_TIPOREG +;
			(cTRBIP)->TL_CODIGO + (cTRBIP)->TL_SEQRELA + (cTRBIP)->TL_SEQTARE } )

		If nYY > Len(aCoBrw2)

			dbSelectArea(cTRBIP)
			dbSkip()

			Loop

		EndIf

		lTemSC1 := .F.

		//Verifica se o Insumo possui Solicitação de Armazem
		If aCoBrw2[nYY,nPos] $ "PT" .And. cUsaInt2 == "S" .And. cUsaInt3 == "S"

			If nNumSa > 0 .And. nITEMSa > 0
				dbSelectArea("SCP")
				dbSetOrder(2) //CP_FILIAL+CP_PRODUTO+CP_NUM+CP_ITEM
				If dbSeek( xFilial("SCP") + aCoBrw2[nYY,nPox] + aCoBrw2[nYY,nNumSa] + aCoBrw2[nYY,nITEMSa])

					ShowHelpDlg(STR0174, {STR0344 + Alltrim(aCoBrw2[nYY,nPoZ]) + STR0345+; //"ATENCAO" ## "O insumo " ## "esta relacionado a Solicitação "
					STR0346 + SCP->CP_NUM},1,; //"ao Armazem numero "
					{STR0347+; //"Realizar a aplicação do insumo utilizando a rotina de Baixa Pré-Requisição(MATA185)."
					STR0348},1) //" Excluir/Alterar a Solicitação ao Armazem"
					dbSelectArea(cTRBIP)
					dbSkip()
					Loop

				EndIf
			EndIf

			dbSelectArea("SC1")
			dbSetOrder(4) //C1_FILIAL+C1_OP+C1_NUM+C1_ITEM
			If dbSeek( xFilial("SC1") + cOrdemTJ+"OS001")
				While !Eof() .And. SC1->C1_FILIAL == xFilial("SC1") .And. Alltrim(SC1->C1_OP) == cOrdemTJ+"OS001"

					If SC1->C1_PRODUTO == aCoBrw2[nYY,nPox] .And. aCoBrw2[nYY,nQuanti] == SC1->C1_QUANT

						If !MsgYesNo(STR0344 +Alltrim(aCoBrw2[nYY,nPoZ])+ STR0349+; //"O insumo " ## " está relacionado a Solicitação de Compra numero "
						SC1->C1_NUM +STR0350) //". Deseja incluir como realizado ? "

							lTemSC1 := .T.
							Exit

						EndIf

					EndIf

					dbSelectArea("SC1")
					dbSkip()

				End

			EndIf

			If lTemSC1
				dbSelectArea(cTRBIP)
				dbSkip()
				Loop
			EndIf

		EndIf

		If aCoBrw2[nYY,nPos] == "P"
			//Verificar os produtos que estao bloqueados
			dbSelectArea("SB1")
			dbSetOrder(1)
			If dbSeek(xFilial("SB1")+aCoBrw2[nYY,nPox])
				If SB1->B1_MSBLQL == "1"
					If !Empty(cProdBloq)
						cProdBloq += ", "
					EndIf
					cProdBloq += Alltrim(aCoBrw2[nYY,nPox])
					dbSelectArea(cTRBIP)
					dbSkip()
					Loop
				EndIf
			EndIf

			M->TL_SEQRELA := aCoBrw2[nYY,nPos18]
			M->TL_TIPOREG := aCoBrw2[nYY,nPos]
			M->TL_CODIGO  := aCoBrw2[nYY,nPox]
			MNT400CHKGAR()
			MNT400PCKGAR()
		EndIf
		If cUsaGeRe == "EST" .And. aCoBrw2[nYY,nPos] == "P"
			If lFirstMsg
				MsgInfo(STR0086) //"Para insumo produto somente poderá ser gerado SA (Solicitação ao Armazém)."
				lFirstMsg := .F.
			EndIf
			dbSelectArea(cTRBIP)
			dbSkip()
			Loop
		Else
			
			If aCoBrw2[nYY,nPos] == "E"

				aCodFunc := fPFiltro(aCoBrw2[nYY,nPox], aCoBrw2[nYY,nPoQ], aCoBrw2[nYY,nDtFim])

				If ValType(aCodFunc) <> "A"
					dbSelectArea(cTRBIP)
					dbSkip()
					Loop
				EndIf

				For nZZZ := 1 to Len(aCodFunc)

					nPosBrw := aScan(aCoBrw6 ,{|x| x[nPoY] == aCoBrw2[nYY,nPoY] .And. x[nPos] == "M" .And. ;
					x[nPox] == aCodFunc[nZZZ] .And. !x[Len(x)] })
					If nPosBrw > 0
						fInsChange(aCoBrw2[nYY],nPosBrw,@nSeqTmp,nPos18)
					Else
						aAdd(aCoBrw6 , aClone(aCoBrw2[nYY]) )
						nLenBrw6 := Len(aCoBrw6)
						aCoBrw6[ nLenBrw6 , nPos ] := "M"
						aCoBrw6[ nLenBrw6 , nPox ] := aCodFunc[nZZZ]

						dbSelectArea("ST1")
						dbSetOrder(1)
						dbSeek(xFilial("ST1") + aCodFunc[nZZZ])

						GDFieldPut( 'TL_NOMCODI', ST1->T1_NOME             , nLenBrw6, aHoBrw2, aCoBrw6 )
						GDFieldPut( 'TL_QUANREC', 0                        , nLenBrw6, aHoBrw2, aCoBrw6 )
						GDFieldPut( 'TL_SEQRELA', MNT435SEQ( aCoBrw6, .T. ), nLenBrw6, aHoBrw2, aCoBrw6 )

						If cNGMNTES != 'S'
						
							If !Empty( ST1->T1_SALARIO )

								GDFieldPut( 'TL_CUSTO', ( ST1->T1_SALARIO * GDFieldGet( 'TL_QUANTID', nLenBrw6, .F.,;
									aHoBrw2, aCoBrw6 ) ), nLenBrw6, aHoBrw2, aCoBrw6 )
							
							Else

								GDFieldPut( 'TL_CUSTO', 0, nLenBrw6, aHoBrw2, aCoBrw6 )
							
							EndIf

						Else
						
							cCodInsum := MntGetPrdM()

							If lIntRM

								NGMUStoLvl( cCodInsum, cLocPad, .T., 'M', ST1->T1_CODFUNC )

							EndIf

							nQtdCvrt := NGCONVERHORA( aCoBrw2[nYY,nQuanti], cNGUNIDT, 'D' )

							nCustIns := Round( NGCALCUSTI( cCodInsum, 'P', nQtdCvrt, , , , , aCoBrw2[nYY,nPoQ], 1 ), 2 )

							GDFieldPut( 'TL_CUSTO', nCustIns, nLenBrw6, aHoBrw2, aCoBrw6 )

						EndIf

					EndIf

				Next nZZZ

			Else
				If aCoBrw2[nYY,nPos] == "T"
					If !NGVALTERC("T",cUsaInt3)
						dbSelectArea(cTRBIP)
						dbSkip()
						Loop
					EndIf
				EndIf
				nPosBrw := aScan(aCoBrw6 ,{|x| x[nPoY] == aCoBrw2[nYY,nPoY] .And. x[nPos] == aCoBrw2[nYY,nPos] .And. ;
				x[nPox] == aCoBrw2[nYY,nPox] .And. !x[Len(x)] })
				If nPosBrw > 0
					fInsChange(aCoBrw2[nYY],nPosBrw,@nSeqTmp,nPos18)
				Else
					If !Empty( aCoBrw2[nYY,1] )

						aAdd( aCoBrw6, aClone( aCoBrw2[nYY] ) )

						nTempXX := Len(aCoBrw6)

						If aCoBrw6[nTempXX,nPos] == 'P' .And. !Empty( nPosCust )

							aCoBrw6[nTempXX,nPosCust] := Round( NGCALCUSTI( aCoBrw6[nTempXX,nPox], aCoBrw6[nTempXX,nPos], aCoBrw6[nTempXX,nQuanti],;
								aCoBrw6[nTempXX,nPosAlmo], , , , aCoBrw6[nTempXX,nPoQ], '1' ), 2 )

						EndIf

						If lMNTA435R

							/*------------------------------------+
							| P.E. para alterar conteudo do aCols |
							+------------------------------------*/
							aCoBrw6 := aClone( ExecBlock( 'MNTA435R', .F., .F.,;
								{ aHoBrw2, aCoBrw6, nTempXX } ) )

						EndIf

						aCoBrw6[ nTempXX ,nPos18] := MNT435SEQ(aCoBrw6,.T.)

						If aCoBrw6[nTempXX,nPos] == "P"
							M->TL_CODIGO  := aCoBrw6[nTempXX,nPox]
							M->TL_GARANTI := aCoBrw6[nTempXX,nCpoGar]
							strDescIns    := aCoBrw6[nTempXX,nPoZ]
							tmpSeqRela    := aCoBrw6[nTempXX,nPos18]
							tmpDtInic     := aCoBrw6[nTempXX,nDtIni]
							tmpDtFim      := aCoBrw6[nTempXX,nDtFim]
							fNgGar435("S",.T.,M->TL_GARANTI,strDescIns,tmpSeqRela,tmpDtInic,tmpDtFim) //Verifica se tem garantia de peça de reposição
							aCoBrw6[nTempXX,nCpoGar] := M->TL_GARANTI
						EndIf
					EndIf
					//Se possuir o PE e integração ao estoque deverá validar
					If lMNTA435O .And. cUsaInt3 == 'S' .And. aCoBrw6[nTempXX,nPos] == "M"

						//Se o P.E. retornar .F. e se a chave atual nao esteja relacionada como bloqueio.
						//não deverá realizar a baixa no estoque, sendo assim deverá ser adicionada no aNBaixaEst
						If !ExecBlock("MNTA435O",.F.,.F.,{ aCoBrw6[nTempXX], aHoBrw2 }) .And. ;
								MNT435CANB(cOrdemTJ + cPlanoTJ + aCoBrw6[nTempXX,nPos18] + aCoBrw6[nTempXX,nPoY] + aCoBrw6[nTempXX,nPos] + aCoBrw6[nTempXX,nPox])
							aAdd(aNBaixaEst,{cOrdemTJ,;  //TL_ORDEM
							cPlanoTJ,;			         //TL_PLANO
							aCoBrw6[nTempXX,nPos18] ,;	 //TL_SEQRELA
							aCoBrw6[nTempXX,nPoY] ,;	 //TL_TAREFA
							aCoBrw6[nTempXX,nPos] ,;	 //TL_TIPOREG
							aCoBrw6[nTempXX,nPox] })	 //TL_CODIGO
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		dbSelectArea(cTRBIP)
		dbSkip()

	End

	If ExistBlock("MNTB4351")
		ExecBlock("MNTB4351")
	EndIf

	dbSelectArea(cTRBIP)
	dbGoTop()

	If Len( aCoBrw6 ) == 0

		aCoBrw6 := aClone( aNovoSTL )
		
	Else

		oBrw6:lModified := .T.

	EndIf

	oBrw6:aCols := aClone( aCoBrw6 )

	oBrw6:oBrowse:Refresh()
	oBrw6:oBrowse:SetFocus()

	//Mostra os Produtos bloqueados
	If !Empty(cProdBloq)
		MsgInfo(STR0259 + cProdBloq  )  //"Produto(s) blqueado(s) : "
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ f435Next ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Adiciona um insumo previsto em Realizados                  |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function f435Next()

	Local aCodFunc 	:= {}
	Local cProdBloq := ''
	Local cCodInsum := ''
	Local cNGMNTES	:= SuperGetMv("MV_NGMNTES", .F., "N")
	Local cLocPad   := SuperGetMV( 'MV_NGLOCPA', .F., '01' )
	Local cNGUNIDT  := SuperGetMV( 'MV_NGUNIDT', .F., 'S' )
	Local lTemSC1 	:= .F.
	Local lMNTA435O	:= ExistBlock("MNTA435O")
	Local lMNTA435R := ExistBlock( 'MNTA435R' )
    Local nSeqTmp 	:= 0
    Local nYY  		:= 0
	Local nZZZ 		:= 0
	Local nLenBrw6 	:= 0
	Local nQtdCvrt  := 0
	Local nPos 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPox 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPoZ 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NOMCODI"})
	Local nPoQ 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANREC"})
	Local nPoY 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA" })
	Local nPos18 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	Local nDtIni 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	Local nDtFim 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"  })
	Local nCpoGar 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_GARANTI"})
	Local nNumSa  	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSA"  })
	Local nITEMSa  	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_ITEMSA" })
	Local nQuanti  	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})

	Local nPosCust  := GDFieldPos( 'TL_CUSTO'  , aHoBrw2 )
	Local nPosAlmo  := GDFieldPos( 'TL_LOCAL'  , aHoBrw2 )
	Local nPosSeqT  := GDFieldPos( 'TL_SEQTARE', aHoBrw2 )

	lRet435 := .T.

	oBrwOS:SetFocus()
	If !lRet435 //Problema encontrado em alguma rotina de validacao da LinhaOK
		Return .F.
	EndIf

	nLenBr6 := Len(aCoBrw6)
	If nLenBr6 == 1
		If Empty(aCoBrw6[1,nPox])
			aCoBrw6 := {}
		EndIf
	ElseIf nLenBr6 > 1
		If Empty(aCoBrw6[nLenBr6,nPox])
			aDel(aCoBrw6,nLenBr6)
			aSize(aCoBrw6,nLenBr6-1)
			oBrw6:lNewLine := .F.
		EndIf
	EndIf

	lFirstMsg := .T.

	dbSelectArea(cTRBIP)
	dbGoTop()
	While (cTRBIP)->( !EoF() )

		nYY := aScan( aCoBrw2, { |x| x[nPoY] + x[nPos] + x[nPox] + x[nPos18] + x[nPosSeqT] == (cTRBIP)->TL_TAREFA + (cTRBIP)->TL_TIPOREG +;
			(cTRBIP)->TL_CODIGO + (cTRBIP)->TL_SEQRELA + (cTRBIP)->TL_SEQTARE } )

		If nYY > Len(aCoBrw2) .Or. Empty((cTRBIP)->TL_OK)

			dbSelectArea(cTRBIP)
			dbSkip()

			Loop

		EndIf

		lTemSC1 := .F.

		//Verifica se o Insumo possui Solicitação de Armazem ou Solicitacao de Compras
		If aCoBrw2[nYY,nPos] $ "PT" .And. cUsaInt2 == "S" .And. cUsaInt3 == "S"

			If nNumSa > 0 .And. nITEMSa > 0
				dbSelectArea("SCP")
				dbSetOrder(2) //CP_FILIAL+CP_PRODUTO+CP_NUM+CP_ITEM
				If dbSeek( xFilial("SCP") + aCoBrw2[nYY,nPox] + aCoBrw2[nYY,nNumSa] + aCoBrw2[nYY,nITEMSa])

					ShowHelpDlg(STR0174, {STR0344 + Alltrim(aCoBrw2[nYY,nPoZ]) + STR0345+; //"ATENCAO" ## "O insumo " ## "esta relacionado a Solicitação "
					STR0346 + SCP->CP_NUM},1,; //"ao Armazem numero "
					{STR0347+; //"Realizar a aplicação do insumo utilizando a rotina de Baixa Pré-Requisição(MATA185)."
					STR0348},1) //" Excluir/Alterar a Solicitação ao Armazem"
					dbSelectArea(cTRBIP)
					dbSkip()
					Loop

				EndIf
			EndIf

			dbSelectArea("SC1")
			dbSetOrder(4) //C1_FILIAL+C1_OP+C1_NUM+C1_ITEM
			If dbSeek( xFilial("SC1") + cOrdemTJ+"OS001")
				While !Eof() .And. SC1->C1_FILIAL == xFilial("SC1") .And. Alltrim(SC1->C1_OP) == cOrdemTJ+"OS001"

					If SC1->C1_PRODUTO == aCoBrw2[nYY,nPox] .And. aCoBrw2[nYY,nQuanti] == SC1->C1_QUANT

						If !MsgYesNo(STR0344 +Alltrim(aCoBrw2[nYY,nPoZ])+ STR0349+; //"O insumo " ## " está relacionado a Solicitação de Compra numero "
						SC1->C1_NUM +STR0350) //". Deseja incluir como realizado ? "

							lTemSC1 := .T.
							Exit

						EndIf

					EndIf

					dbSelectArea("SC1")
					dbSkip()

				End

			EndIf

			If lTemSC1
				dbSelectArea(cTRBIP)
				dbSkip()
				Loop
			EndIf

		EndIf

		If aCoBrw2[nYY,nPos] == "P"
			//Verificar se o Produto esta bloqueado
			dbSelectArea("SB1")
			dbSetOrder(1)
			If dbSeek(xFilial("SB1")+aCoBrw2[nYY,nPox])
				If SB1->B1_MSBLQL == "1"
					If !Empty(cProdBloq)
						cProdBloq += ", "
					EndIf
					cProdBloq += Alltrim(aCoBrw2[nYY,nPox])
					dbSelectArea(cTRBIP)
					dbSkip()
					Loop
				EndIf
			EndIf
			M->TL_SEQRELA := aCoBrw2[nYY,nPos18]
			M->TL_TIPOREG := aCoBrw2[nYY,nPos]
			M->TL_CODIGO  := aCoBrw2[nYY,nPox]
			MNT400CHKGAR()
			MNT400PCKGAR()
		EndIf
		If cUsaGeRe == "EST" .And. aCoBrw2[nYY,nPos] == "P"
			If lFirstMsg
				MsgInfo(STR0086) //"Para insumo produto somente poderá ser gerado SA (Solicitação ao Armazém)."
				lFirstMsg := .F.
			EndIf
			dbSelectArea(cTRBIP)
			dbSkip()
			Loop
		Else
			If aCoBrw2[nYY,nPos] == "E"
				aCodFunc := fPFiltro(aCoBrw2[nYY,nPox], aCoBrw2[nYY,nPoQ], aCoBrw2[nYY,nDtFim])
				If ValType(aCodFunc) <> "A"
					dbSelectArea(cTRBIP)
					dbSkip()
					Loop
				EndIf
				For nZZZ := 1 to Len(aCodFunc)
					nPosBrw := aScan(aCoBrw6 ,{|x| x[nPoY] == aCoBrw2[nYY,nPoY] .And. x[nPos] == "M" .And. ;
					x[nPox] == aCodFunc[nZZZ] .And. !x[Len(x)] })
					If nPosBrw > 0

						fInsChange(aCoBrw2[nYY],nPosBrw,@nSeqTmp,nPos18)

					Else

						aAdd(aCoBrw6 , aClone(aCoBrw2[nYY]) )
						nLenBrw6 := Len(aCoBrw6)
						aCoBrw6[nLenBrw6 , nPos ] := "M"
						aCoBrw6[nLenBrw6 , nPox ] := aCodFunc[nZZZ]

						dbSelectArea("ST1")
						dbSetOrder(1)
						dbSeek(xFilial("ST1") + aCodFunc[nZZZ])

						GDFieldPut( 'TL_NOMCODI', ST1->T1_NOME             , nLenBrw6, aHoBrw2, aCoBrw6 )
						GDFieldPut( 'TL_QUANREC', 0                        , nLenBrw6, aHoBrw2, aCoBrw6 )
						GDFieldPut( 'TL_SEQRELA', MNT435SEQ( aCoBrw6, .T. ), nLenBrw6, aHoBrw2, aCoBrw6 )

						If cNGMNTES != 'S'
							
							If !Empty( ST1->T1_SALARIO )

								GDFieldPut( 'TL_CUSTO', ( ST1->T1_SALARIO * GDFieldGet( 'TL_QUANTID', nLenBrw6, .F.,;
									aHoBrw2, aCoBrw6 ) ), nLenBrw6, aHoBrw2, aCoBrw6 )

							Else
							
								GDFieldPut( 'TL_CUSTO', 0, nLenBrw6, aHoBrw2, aCoBrw6 )

							EndIf

						Else
							
							cCodInsum := MntGetPrdM()

							//Atualiza saldo e custo do produto relacionado a mão de obra
							If lIntRM

								NGMUStoLvl( cCodInsum, cLocPad, .T., 'M', ST1->T1_CODFUNC )

							EndIf

							nQtdCvrt := NGCONVERHORA( aCoBrw2[nYY,nQuanti], cNGUNIDT, 'D' )

							nCustIns := Round( NGCALCUSTI( cCodInsum, 'P', nQtdCvrt, , , , , aCoBrw2[nYY,nPoQ], 1 ), 2 )

							GDFieldPut( 'TL_CUSTO', nCustIns, nLenBrw6, aHoBrw2, aCoBrw6 )

						EndIf

					EndIf

				Next nZZZ

			Else
				If aCoBrw2[nYY,nPos] == "T"
					If !NGVALTERC("T",cUsaInt3)
						dbSelectArea(cTRBIP)
						dbSkip()
						Loop
					EndIf
				EndIf
				nPosBrw := aScan(aCoBrw6 ,{|x| x[nPoY] == aCoBrw2[nYY,nPoY] .And. x[nPos] == aCoBrw2[nYY,nPos] .And. ;
				x[nPox] == aCoBrw2[nYY,nPox] .And. !x[Len(x)] })

				If nPosBrw > 0
					fInsChange(aCoBrw2[nYY],nPosBrw,@nSeqTmp,nPos18)
				Else

					If !Empty(aCoBrw2[nYY,1])

						aAdd(aCoBrw6 , aClone( aCoBrw2[nYY] ) )

						nTempXX := Len(aCoBrw6)

						If aCoBrw6[nTempXX,nPos] == 'P' .And. !Empty( nPosCust )

							aCoBrw6[nTempXX,nPosCust] := Round( NGCALCUSTI( aCoBrw6[nTempXX,nPox], aCoBrw6[nTempXX,nPos], aCoBrw6[nTempXX,nQuanti],;
								aCoBrw6[nTempXX,nPosAlmo], , , , aCoBrw6[nTempXX,nPoQ], '1' ), 2 )

						EndIf

						If lMNTA435R

							/*------------------------------------+
							| P.E. para alterar conteudo do aCols |
							+------------------------------------*/
							aCoBrw6 := aClone( ExecBlock( 'MNTA435R', .F., .F.,;
								{ aHoBrw2, aCoBrw6, nTempXX } ) )

						EndIf

						aCoBrw6[ nTempXX ,nPos18] := MNT435SEQ(aCoBrw6,.T.)

						If aCoBrw6[nTempXX,nPos] == "P"
							M->TL_CODIGO  := aCoBrw6[nTempXX,nPox]
							M->TL_GARANTI := aCoBrw6[nTempXX,nCpoGar]
							strDescIns    := aCoBrw6[nTempXX,nPoZ]
							tmpSeqRela    := aCoBrw6[nTempXX,nPos18]
							tmpDtInic     := aCoBrw6[nTempXX,nDtIni]
							tmpDtFim      := aCoBrw6[nTempXX,nDtFim]
							fNgGar435("S",.T.,M->TL_GARANTI,strDescIns,tmpSeqRela,tmpDtInic,tmpDtFim) //Verifica se tem garantia de peça de reposição
							aCoBrw6[nTempXX,nCpoGar] := M->TL_GARANTI
						EndIf

						//Se possuir o PE e integração ao estoque deverá validar
						If lMNTA435O .And. cUsaInt3 == 'S' .And. aCoBrw6[nTempXX,nPos] == "M"

							//Se o P.E. retornar .F. e se a chave atual nao esteja relacionada como bloqueio.
							//não deverá realizar a baixa no estoque, sendo assim deverá ser adicionada no aNBaixaEst
							If !ExecBlock("MNTA435O",.F.,.F.,{ aCoBrw6[nTempXX], aHoBrw2 }) .And. ;
									MNT435CANB(cOrdemTJ + cPlanoTJ + aCoBrw6[nTempXX,nPos18] + aCoBrw6[nTempXX,nPoY] + aCoBrw6[nTempXX,nPos] + aCoBrw6[nTempXX,nPox])
								aAdd(aNBaixaEst,{cOrdemTJ,; //TL_ORDEM
								cPlanoTJ,;			        //TL_PLANO
								aCoBrw6[nTempXX,nPos18] ,;	//TL_SEQRELA
								aCoBrw6[nTempXX,nPoY] ,;	//TL_TAREFA
								aCoBrw6[nTempXX,nPos] ,;	//TL_TIPOREG
								aCoBrw6[nTempXX,nPox] })	//TL_CODIGO
							EndIf
						EndIf

					EndIf
				EndIf
			EndIf
		EndIf

		dbSelectArea(cTRBIP)
		dbSkip()
	End

	If ExistBlock("MNTB4352")
		ExecBlock("MNTB4352")
	EndIf

	dbSelectArea(cTRBIP)
	dbGoTop()

	If Len( aCoBrw6 ) == 0

		aCoBrw6 := aClone( aNovoSTL )
		
	Else

		oBrw6:lModified := .T.
		
	EndIf

	oBrw6:aCols := aClone( aCoBrw6 )
	
	oBrw6:oBrowse:Refresh()
	oBrw6:oBrowse:SetFocus()

	//Mostra os Produtos bloqueados
	If !Empty(cProdBloq)
		MsgInfo(STR0259 + cProdBloq  )  //"Produto(s) blqueado(s) : "
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fInsChange³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Exclui um insumo realizado                                 |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fInsChange(aColsTmp,nLinPos,nSeqTmp,nPos18)
	
	Local aTemp    := aClone( aColsTmp )
	Local cNGMNTES := SuperGetMv( 'MV_NGMNTES', .F., 'N' )
	Local cLocPad  := SuperGetMV( 'MV_NGLOCPA', .F., '01' )
	Local cNGUNIDT := SuperGetMV( 'MV_NGUNIDT', .F., 'S' )
	Local cCodInsu := ''
	Local nModelo  := 1
	Local nOpcFun  := 0
	Local nPos10   := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	Local nPos     := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPox     := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPoZ     := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NOMCODI"})
	Local nPoQ     := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANREC"})
	Local nCpoGar  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_GARANTI" })
	Local nDtIni   := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI" })
	Local nDtFim   := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM" })
	Local nPosCust := GDFieldPos( 'TL_CUSTO'  , aHoBrw2 )
	Local nQtdConv := 0
	Local oDlg2
	Local oRadOp

	Private cCpoTarefa := Alltrim((cTRBIP)->TL_TAREFA) + " - " + Alltrim((cTRBIP)->TL_NOMTAR )
	Private cCpoTipoIn := GetNomeTip((cTRBIP)->TL_TIPOREG)
	Private cCpoInsumo := Alltrim((cTRBIP)->TL_CODIGO) + " - " + Alltrim(NOMINSBRW((cTRBIP)->TL_TIPOREG, (cTRBIP)->TL_CODIGO))
	Private nCpoQtdade := (cTRBIP)->TL_QUANTID
	Private cCpoUnidad := (cTRBIP)->TL_UNIDADE
	Private oCpoTarefa,oCpoTipoIn,oCpoInsumo,oCpoQtdade,oCpoUnidad
	Private nQtdTemp   := aCoBrw6[nLinPos,nPos10]

	Define MsDialog oDlg2 Title OemToAnsi(STR0087) From 089,232 To 390,619 Of oMainWnd Pixel //"Insumos"

	@ 002,004 Say STR0088 of oDlg2 Font oFont3 Pixel //"Este insumo já foi utilizado nesta ordem de serviço."
	@ 013,004 Say STR0089 of oDlg2 Font oFont3 Pixel //"Selecione a opção desejada:"
	@ 028,004 Radio oRadOp Var nModelo Items STR0090,; //"Não adicionar o insumo."
	STR0091,; //"Adicionar o insumo novamente."
	STR0092,; //"Adicionar o insumo novamente, informando outra quantidade."
	STR0093; //"Alterar a quantidade do insumo já utilizado."
	Size 180,13 Pixel On Change fOnChIns(nModelo) OF oDlg2

	@ 072,004 Say STR0023     of oDlg2 Pixel //"Tarefa"
	@ 072,080 MsGet oCpoTarefa Var cCpoTarefa Size 60,08 Of oDlg2 Pixel
	oCpoTarefa:Disable()
	@ 083,004 Say STR0094       of oDlg2 Pixel //"Tipo"
	@ 083,080 MsGet oCpoTipoIn Var cCpoTipoIn Size 60,08 Of oDlg2 Pixel
	oCpoTipoIn:Disable()
	@ 094,004 Say STR0079     of oDlg2 Pixel //"Código"
	@ 094,080 MsGet oCpoInsumo Var cCpoInsumo Size 80,08 Of oDlg2 Pixel
	oCpoInsumo:Disable()
	@ 105,004 Say STR0095 of oDlg2 Pixel //"Quantidade"
	@ 105,080 MsGet oCpoQtdade Var nCpoQtdade Picture "999,999.99" Valid (Positivo(nCpoQtdade) .And. NGVALQUANT((cTRBIP)->TL_TIPOREG,(cTRBIP)->TL_UNIDADE,nCpoQtdade)) Size 60,08 Of oDlg2 Pixel HASBUTTON
	oCpoQtdade:Disable()
	@ 116,004 Say STR0096 of oDlg2 Pixel //"Unidade"
	@ 116,080 MsGet oCpoUnidad Var cCpoUnidad Size 30,08 Of oDlg2 Pixel
	oCpoUnidad:Disable()

	Define sButton oBtOk  from 134, 126 type 1 enable of oDlg2 pixel Action (nOpcFun:=1,If(.T.,oDlg2:End(),nOpcFun:=2))
	Define sButton oBtCan from 134, 156 type 2 enable of oDlg2 pixel Action (nOpcFun:=2,oDlg2:End())

	oDlg2:Activate(,,,.T.)

	If nOpcFun == 1
	
		If nModelo == 2

			aAdd( aCoBrw6 , aClone( aTemp ) )
			nLen := Len( aCoBrw6 )

			aCoBrw6[nLen,nPos18] := MNT435SEQ( aCoBrw6, .T. )
			aCoBrw6[nLen,nPos]   := aCoBrw6[nLinPos,nPos]
			aCoBrw6[nLen,nPox]   := aCoBrw6[nLinPos,nPox]
			aCoBrw6[nLen,nPoZ]   := aCoBrw6[nLinPos,nPoZ]
			aCoBrw6[nLen,nPoQ]   := aCoBrw6[nLinPos,nPoQ]

			If aCoBrw6[nLen,nPos] == 'P'

				M->TL_CODIGO  := aCoBrw6[nLen,nPox]
				M->TL_GARANTI := aCoBrw6[nLen,nCpoGar]
				strDescIns    := aCoBrw6[nLen,nPoZ]
				tmpSeqRela    := aCoBrw6[nLen,nPos18]
				tmpDtInic     := aCoBrw6[nLen,nDtIni]
				tmpDtFim      := aCoBrw6[nLen,nDtFim]
				fNgGar435("S",.T.,M->TL_GARANTI,strDescIns,tmpSeqRela,tmpDtInic,tmpDtFim) //Verifica se tem garantia de peça de reposição
				aCoBrw6[nLen,nCpoGar] := M->TL_GARANTI
			
			EndIf

			If aCoBrw6[nLen,nPos] == 'M'

				dbSelectArea( 'ST1' )
				dbSetOrder( 1 ) // T1_FILIAL + T1_CODFUNC
				msSeek( FWxFilial( 'ST1' ) + aCoBrw6[nLen,nPox] )

				If cNGMNTES != 'S'
								
					If !Empty( ST1->T1_SALARIO )

						aCoBrw6[nLen,nPosCust] := ( ST1->T1_SALARIO * aCoBrw6[nLen,nPos10] )
					
					Else

						aCoBrw6[nLen,nPosCust] := 0

					EndIf

				Else
					
					cCodInsu := MntGetPrdM()

					If lIntRM

						NGMUStoLvl( cCodInsu, cLocPad, .T., 'M', ST1->T1_CODFUNC )

					EndIf
					
					nQtdConv := NGCONVERHORA( aCoBrw6[nLen,nPos10], cNGUNIDT, 'D' )
					
					aCoBrw6[nLen,nPosCust] := Round( NGCALCUSTI( cCodInsu, 'P', nQtdConv, , , , , aCoBrw6[nLen,nPoQ], 1 ), 2 )

				EndIf

			EndIf

		ElseIf nModelo == 3

			aAdd( aCoBrw6, aClone( aTemp ) )
			nLen := Len( aCoBrw6 )
			
			aCoBrw6[nLen,nPos10] := nCpoQtdade
			aCoBrw6[nLen,nPos18] := MNT435SEQ( aCoBrw6, .T. )
			aCoBrw6[nLen,nPos]   := aCoBrw6[nLinPos,nPos]
			aCoBrw6[nLen,nPox]   := aCoBrw6[nLinPos,nPox]
			aCoBrw6[nLen,nPoZ]   := aCoBrw6[nLinPos,nPoZ]
			aCoBrw6[nLen,nPoQ]   := aCoBrw6[nLinPos,nPoQ]

			If aCoBrw6[nLen,nPos] == 'P'

				M->TL_CODIGO  := aCoBrw6[nLen,nPox]
				M->TL_GARANTI := aCoBrw6[nLen,nCpoGar]
				strDescIns    := aCoBrw6[nLen,nPoZ]
				tmpSeqRela    := aCoBrw6[nLen,nPos18]
				tmpDtInic     := aCoBrw6[nLen,nDtIni]
				tmpDtFim      := aCoBrw6[nLen,nDtFim]
				fNgGar435("S",.T.,M->TL_GARANTI,strDescIns,tmpSeqRela,tmpDtInic,tmpDtFim) //Verifica se tem garantia de peça de reposição
				aCoBrw6[nLen,nCpoGar] := M->TL_GARANTI

			EndIf

			If aCoBrw6[nLen,nPos] == 'M'

				dbSelectArea( 'ST1' )
				dbSetOrder( 1 ) // T1_FILIAL + T1_CODFUNC
				msSeek( FWxFilial( 'ST1' ) + aCoBrw6[nLen,nPox] )

				If cNGMNTES != 'S'
								
					If !Empty( ST1->T1_SALARIO )

						aCoBrw6[nLen,nPosCust] := ( ST1->T1_SALARIO * aCoBrw6[nLen,nPos10] )
					
					Else

						aCoBrw6[nLen,nPosCust] := 0

					EndIf

				Else
					
					cCodInsu := MntGetPrdM()

					If lIntRM

						NGMUStoLvl( cCodInsu, cLocPad, .T., 'M', ST1->T1_CODFUNC )

					EndIf
					
					nQtdConv := NGCONVERHORA( aCoBrw6[nLen,nPos10], cNGUNIDT, 'D' )
					
					aCoBrw6[nLen,nPosCust] := Round( NGCALCUSTI( cCodInsu, 'P', nQtdConv, , , , , aCoBrw6[nLen,nPoQ], 1 ), 2 )

				EndIf

			EndIf

		ElseIf nModelo == 4

			aCoBrw6[nLinPos,nPos10] := nCpoQtdade
			aCols[nLinPos,nPos10]   := nCpoQtdade

			//Atualiza os campos de data inicio e fim do insumo
			NGCALDTHO()

			aCoBrw6   := aClone( aCols )
		
		EndIf
	
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fOnChIns ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Funcao chamada ao alterar o Radio da tela de insumos       |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fOnChIns(nModelo)

	oCpoTarefa:Disable()
	oCpoTipoIn:Disable()
	oCpoInsumo:Disable()
	oCpoQtdade:Disable()
	oCpoUnidad:Disable()

	If nModelo == 3
		oCpoQtdade:Enable()
		nCpoQtdade := (cTRBIP)->TL_QUANTID
		oCpoQtdade:Refresh()
	ElseIf nModelo == 4
		oCpoQtdade:Enable()
		nCpoQtdade := nQtdTemp
		oCpoQtdade:Refresh()
	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fDelInsumo
Exclui um ou todos os insumos realizados.
@type function

@author Alexandre Santos
@since  26/06/2024

@param 	lDelAll, boolean, Indica se exclui todos os insumos.
@return
/*/
//-------------------------------------------------------------------
Static Function fDelInsumo( lDelAll )

	Local nInd1 := 0

	If lDelAll

		For nInd1 := 1 To Len( oBrw6:aCols )

			If fValDel435( .F., oBrw6:aCols[nInd1], nInd1 )

				If !oBrw6:aCols[ nInd1, len(oBrw6:aCols[nInd1]) ]

					oBrw6:GoTo( nInd1 )
					oBrw6:DelLine()

				EndIf
			
			EndIf
	
		Next nInd1

	Else

		If fValDel435( .F., oBrw6:aCols[oBrw6:nAt], oBrw6:nAt )

			If !oBrw6:aCols[ oBrw6:nAt, len(oBrw6:aCols[oBrw6:nAt]) ]

				oBrw6:GoTo( oBrw6:nAt )
				oBrw6:DelLine()

			EndIf

		EndIf

	EndIf

	oBrw6:oBrowse:Refresh()
	oBrw6:oBrowse:SetFocus()

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fFiltroS ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Filtro do browse de Insumos Previstos                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fFiltroS()
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fGerarSA ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Gerar temporariamente a SA                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fGerarSA()
	Local cCodProd
	Local nTamB1 := Len(SCP->CP_PRODUTO)
	Local lNoCheck := .F.
	Local cNumOP   := cOrdemTJ+"OS001"

	If !MsgYesNo(STR0097) //"Confirma a Geração de Solicitação ao Armazém?"
		Return .F.
	EndIf

	dbSelectArea(cTRBIP)
	dbGoTop()
	ProcRegua(RecCount())
	While !EoF()

		IncProc()
		If (cTRBIP)->TL_TIPOREG <> "P"
			dbSelectArea(cTRBIP)
			dbSkip()
			Loop
		EndIf

		cCodProd := PadR((cTRBIP)->TL_CODIGO,nTamB1)
		dbSelectArea("SB1")
		dbSetOrder(1)
		If !dbSeek(xFilial("SB1")+cCodProd)
			dbSelectArea(cTRBIP)
			dbSkip()
			Loop
		EndIf

		dbSelectArea("STJ")
		dbSetOrder(1)
		dbSeek(xFilial("STJ")+cOrdemTJ + cPlanoTJ)

		dbSelectArea("ST9")
		dbSetOrder(1)
		dbSeek(xFilial("ST9")+STJ->TJ_CODBEM)

		If !Empty((cTRBIP)->TL_OK) .And. (cTRBIP)->XTL_SA == 0
			lNoCheck := .T.
			nLineSA := aScan(aDadosSA, {|x| x[1]+x[2]+x[3]+x[4] == cOrdemTJ+cPlanoTJ+cCodProd+Dtos((cTRBIP)->TL_DTINICI) })
			If nLineSA == 0
				//Chave: Ordem + Plano + Produto + Data Necessidade
				aAdd( aDadosSA ,{cOrdemTJ						,; //Ordem
				cPlanoTJ						,; //Plano
				cCodProd						,; //CP_PRODUTO
				SB1->B1_UM						,; //CP_UM
				(cTRBIP)->TL_QUANTID				,; //CP_QUANT
				(cTRBIP)->TL_DTINICI				,; //CP_DATPRF
				SB1->B1_LOCPAD					,; //CP_LOCAL
				cNumOP							,; //CP_OP
				ST9->T9_CCUSTO					,; //CP_CC
				dDataBase						,; //CP_EMISSAO
				SB1->B1_DESC					,; //CP_DESCRI
				cUserName						,; //CP_SOLICIT
				.T.								 ; //ATIVO/INATIVO
				};
				)
				nLineSA := Len(aDadosSA)
			Else
				aDadosSA[ nLineSA , 5 ] += (cTRBIP)->TL_QUANTID
			EndIf
			(cTRBIP)->XTL_SA := nLineSA

		ElseIf Empty((cTRBIP)->TL_OK) .And. (cTRBIP)->XTL_SA > 0

			If Len(aDadosSA) >= (cTRBIP)->XTL_SA
				aDadosSA[(cTRBIP)->XTL_SA , 5] := aDadosSA[(cTRBIP)->XTL_SA , 5] - (cTRBIP)->TL_QUANTID
				If aDadosSA[(cTRBIP)->XTL_SA , 5] <= 0
					aDadosSA[(cTRBIP)->XTL_SA , 13] := .F. //INATIVO
				EndIf
			EndIf

		EndIf

		dbSelectArea(cTRBIP)
		dbSkip()
	End
	dbSelectArea(cTRBIP)
	dbGoTop()

	If !lNoCheck
		MsgInfo(STR0098) //"Nenhum produto foi selecionado para gerar Solicitação ao Armazém (S.A.)."
		Return .F.
	EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} Mnt435bCon
Funcionalidade do botao do conhecimento

@type   Function

@author Denis Hyroshi de Souza
@since  30/06/2008

/*/
//-------------------------------------------------------------------
Static Function Mnt435bCon()

	dbSelectArea( 'STJ' )
	dbSetOrder( 1 )
	If msSeek( FWxFilial( 'STJ') + (cAliOS435)->TJ_ORDEM + (cAliOS435)->TJ_PLANO )
		MsDocument( 'STJ', Recno(), 4 )
	Else
		MsgInfo(STR0099) //"Nenhuma ordem de serviço foi selecionada."
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} LoadFldSTJ()
Monta a array dos campos da OS conforme campos usados do SX3
e que X3_BROWSE esteja = "S"

@type static

@author Eduardo Henrique Mussi
@since  20/09/2022

@param aFields, Array, campos que serão apresentados no Browse
/*/
//---------------------------------------------------------------------
Static Function LoadFldSTJ( aFields )

	Local nFields    := 0
	Local aHeaderSTJ := NGHeader( 'STJ',, .F. )
	Local aFieldForc := { 'TJ_ORDEM', 'TJ_PLANO' } // Campos que são obrigatorios há apresentação em tela

	For nFields := 1 To Len( aHeaderSTJ )

		cCampo  := AllTrim( aHeaderSTJ[ nFields, 2 ] )

		If Posicione( 'SX3', 2, cCampo, 'X3_BROWSE' ) == 'S' .Or. ( aScan( aFieldForc, { | x | x == cCampo } ) > 0 )

			// Tratativa para o campo Memo
			If cCampo == 'TJ_OBSERVA'
				aAdd( aFields, { cCampo, aHeaderSTJ[ nFields, 1 ], 'C', 200, aHeaderSTJ[ nFields, 3 ] } )
			Else
				// Campo, Titulo, Tipo, Tamanho, Picture
				aAdd( aFields, { cCampo, aHeaderSTJ[ nFields, 1 ], aHeaderSTJ[ nFields, 8 ], aHeaderSTJ[ nFields, 4 ], aHeaderSTJ[ nFields, 3 ] } )
			EndIf

		EndIf

	Next nFields

	// Ponto de Entrada para eliminar ou adicionar campos da STJ ao mostrar na Tela Inicial
	If ExistBlock( 'MNTA435Q' )
		aFields := ExecBlock( 'MNTA435Q', .F., .F., aFields )
	EndIf

Return

/*/{Proteus.doc} MNT435LEG
	Cria uma janela contendo a legenda da mBrowse
	@param
	@return
	@author Alexandre Santos
	@since 23/10/2017
/*/
Static Function Mnt435Leg()

	Local oDlgLeg

	Define MsDialog oDlgLeg Title OemToAnsi(STR0100) From 0,0 To 25.5,38.5

	// LEGENDA DE ORDENS DE SERVIÇO
	@ 008,005 To 65,150 LABEL Oemtoansi(STR0337) OF oDlgLeg PIXEL
	@ 017,020 BitMap Resource "BR_VERDE"    Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 029,020 BitMap Resource "BR_AZUL"     Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 041,020 BitMap Resource "BR_VERMELHO" Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 053,020 BitMap Resource "BR_LARANJA" 	Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 017,032 Say Oemtoansi(STR0101)  Of oDlgLeg Pixel //COM INSUMO
	@ 029,032 Say Oemtoansi(STR0102)  Of oDlgLeg Pixel //SEM INSUMO
	@ 041,032 Say STR0103+" "+STR0102 Of oDlgLeg Pixel //ATRASADA SEM INSUMO
	@ 053,032 Say STR0103+" "+STR0101 Of oDlgLeg Pixel //ATRASADA COM INSUMO
	// LEGENDA DE INSUMOS
	@ 73,005 To 119, 150 LABEL Oemtoansi(STR0087) OF oDlgLeg PIXEL
	@ 082,020 BitMap Resource "BR_VERMELHO"   Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 094,020 BitMap Resource "BR_LARANJA" Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 106,020 BitMap Resource "BR_VERDE"    Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 082,032 Say Oemtoansi(STR0353) Of oDlgLeg Pixel // Não aplicado
	@ 094,032 Say Oemtoansi(STR0354) Of oDlgLeg Pixel // Parcialmente Aplicado
	@ 106,032 Say Oemtoansi(STR0355) Of oDlgLeg Pixel // Totalmente aplicado
	// LEGENDA DE ETAPAS
	@ 126,005 To 186, 150 LABEL Oemtoansi(STR0017) OF oDlgLeg PIXEL
	@ 138,020 BitMap Resource "BR_VERDE"    Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 150,020 BitMap Resource "BR_AMARELO"  Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 162,020 BitMap Resource "BR_LARANJA"  Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 174,020 BitMap Resource "BR_VERMELHO" Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 138,032 Say Oemtoansi(STR0358) Of oDlgLeg Pixel //EXECUTADA
	@ 150,032 Say Oemtoansi(STR0359) Of oDlgLeg Pixel //EM EXECUÇÃO
	@ 162,032 Say Oemtoansi(STR0360) Of oDlgLeg Pixel //EM EXECUÇÃO ACIMA DO TEMPO PREVISTO
	@ 174,032 Say Oemtoansi(STR0361) Of oDlgLeg Pixel //NÃO EXECUTADA

	Activate MsDialog oDlgLeg Centered

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Mnt435Rel ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Funcionalidade do botao de imprimir OS                      |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Mnt435Rel()

	Local cOrdem := (cAliOS435)->TJ_ORDEM
	Local cPlano := (cAliOS435)->TJ_PLANO

	dbSelectArea("STJ")
	dbSetOrder(01)
	If dbSeek(xFilial("STJ")+cOrdem+cPlano)
		NGIMP675(cOrdem,cPlano,.F.,,STJ->(RECNO()))
	Else
		MsgInfo(STR0099) //"Nenhuma ordem de serviço foi selecionada."
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Mnt435Vis ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Funcionalidade do botao de visualizar OS                    |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Mnt435Vis()

	Local cOrdem := (cAliOS435)->TJ_ORDEM
	Local cPlano := (cAliOS435)->TJ_PLANO

	aChoice := {}

	dbSelectArea("STJ")
	dbSetOrder(01)
	If dbSeek(xFilial("STJ")+cOrdem+cPlano)
		NGCAD01("STJ",Recno(),2)
	Else
		MsgInfo(STR0099) //"Nenhuma ordem de serviço foi selecionada."
	EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} Mnt435Fin
Funcionalidade do botao de finalizar OS
@author	Denis Hyroshi de Souza
@since	01/06/08
@return	- lRet, Lógico, Retorna se a OS pode ser finalizada ou não
/*/
//-------------------------------------------------------------------
Static Function Mnt435Fin()

	Local nXX,nYY
	Local dMINSTL,dMAXSTL,dMAXF,hMINSTL,hMAXSTL,hMAXF
	Local cOrdem
	Local cPlano
	Local nPox      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO"  })
	Local nPos      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG" })
	Local nPoY      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA"  })
	Local nPoQ      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID" })
	Local nDtI      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI" })
	Local nHoI      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOINICI" })
	Local nDtF      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM" })
	Local nHoF      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOFIM" })
	Local aFin2P    := {}
	Local aFinTmp   := {}
	Local lTemIReal := .F. //indica se tem insumo realizado
	Local lSemIns   := .F.
	Local lRet 		:= .T.
	Local lSoProd	:= .T. //Indica que só tem insumo do tipo Produto

	Local nDatFim   := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_DTFIM"})
	Local nHorFim   := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_HOFIM"})
	Local nJ        := 0

	Local nNumSa    := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSA" })
	Local nDataPos  := 0

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de entrada que indica se a O.S ³
	//³podera ser finalizada sem insumos    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("NGSEMINS")
		lSemIns := ExecBlock("NGSEMINS",.F.,.F.)
		lSemIns := If(ValType(lSemIns) == "L",lSemIns,.F.)
	EndIf

	If !Empty(aCoBrw4)
		For nJ := 1 To Len(aCoBrw4)
			If lRet .And. !Empty(aCoBrw4[nJ][1]) .And. (Empty(aCoBrw4[nJ][nDatFim]) .Or. Empty(aCoBrw4[nJ][nHorFim]))
				ShowHelpDlg("ATENCAO", {STR0342}, 2,;	//"Existe(m) motivo(s) de atraso(s) reportado(s) para a ordem de serviço sem a data ou a hora final informados."
				{STR0343}, 2)	//"Favor, informar uma data fim/hora fim para o(s) motivo(s) em questão para proceder com a finalização da O.S."
				lRet := .F.
			EndIf
		Next nJ
	EndIf

	If lRet .And. !Empty( (cAliOS435)->TJ_ORDEM )

		cOrdem := (cAliOS435)->TJ_ORDEM
		cPlano := (cAliOS435)->TJ_PLANO
		dbSelectArea("STJ")
		dbSetOrder(01)
		If dbSeek(xFilial("STJ")+cOrdem+cPlano)

			//-----------------------------------------------------------
			// Verifica se não há pneus aguardando aplicação
			//-----------------------------------------------------------
			If FindFunction( 'MNTVLDFIN' ) .And. !MNTVLDFIN( STJ->TJ_ORDEM )[1]
				lRet := .F.
			EndIf

			If lRet .And. NGFUNCRPO("NGRESPETAEX",.F.)
				If !NGRESPETAEX( STJ->TJ_ORDEM, .T., oTmpTbl3:GetRealName(), .F. )
					lRet := .F.
				EndIf
			EndIf

			//Valida se o usuario tem permissão
			If lRet .And. !Empty(cRet400)
				If !(Upper(AllTrim(cUsername)) $ Upper(AllTrim(cRet400)))
					MsgStop(STR0104,STR0037) //"Usuário não autorizado para encerrar a O.S."###"ATENÇÃO"
					lRet := .F.
				EndIf
			EndIf

			//Valida se existir ponto de entrada
			If lRet .And. ExistBlock("MNT40011")
				lRet := ExecBlock("MNT40011",.F.,.F.)
			EndIf

			//Valida se tem ordem de producao
			If lRet .And. cUsaInt3 == "S"
				dbSelectArea("SC2")
				dbSetOrder(01)
				If !dbSeek(xFilial("SC2")+STJ->TJ_ORDEM+"OS001")
					MsgInfo(STR0105+STJ->TJ_ORDEM+STR0106 + ; //"A Ordem de Serviço  "###" não poderá ser finalizada, pois"
					chr(13)+chr(10)+STR0107,STR0037) //"não existe Ordem de Produção para a mesma."###"ATENÇÃO"
					lRet := .F.
				EndIf
			EndIf


			If lRet .And. !lSemIns // Verifica se pode finalizar a O.S. sem insumo //Nao tem insumo
				//Valida se tem algum insumo reportado
				nPDR := aScan(aCoBrw6 ,{|x| !Empty(x[nPoY]) .And. !Empty(x[nPos]) .And. !Empty(x[nPox]) .And. !x[Len(x)] })
				If nPDR == 0
					MsgInfo(STR0108+STJ->TJ_ORDEM+STR0106+; //"A Ordem de Serviço "###" não poderá ser finalizada, pois"
					chr(13)+chr(10)+STR0109,STR0037) //"não existe insumo realizado."###"ATENÇÃO"
					lRet := .F.
				EndIf
			EndIf

			If lRet
				//Se MV_NGREPRE = S, verifica se tem algum insumo faltando reportar a quantidade prevista
				lRetNgRep := If(cParSX6Ret == Nil .Or. Empty(cParSX6Ret) .Or. Alltrim(cParSX6Ret) == "N",.F.,.T.)
				If lRetNgRep
					lINSUSRET := .F.
					For nYY := 1 To Len(aCoBrw2)
						nQUATINS := 0
						If aCoBrw2[nYY,nPos] != "E"
							For nXX := 1 To Len(aCoBrw6)
								If ((nNumSa > 0 .And. !Empty(aCoBrw2[nYY,nNumSa])) .Or. aCoBrw6[nXX,nPoY] == aCoBrw2[nYY,nPoY]) .And.;
									aCoBrw6[nXX,nPos] == aCoBrw2[nYY,nPos] .And. aCoBrw6[nXX,nPox] == aCoBrw2[nYY,nPox]  .And.;
									!aCoBrw6[nXX, Len(aCoBrw6[nXX])]

									nQUATINS += aCoBrw6[nXX,nPoQ]
								EndIf
							Next nXX
						EndIf
						If nQUATINS < aCoBrw2[nYY,nPoQ] .And. aCoBrw2[nYY,nPos] != "E"
							lINSUSRET := .T.
							Exit
						EndIf
					Next nYY
					If lINSUSRET //Nao reportou tudo que foi previsto
						If !MsgYesNo(STR0110+;                       //"Para alguns insumos não foram reportadas a quantidade prevista."
						chr(13)+chr(10)+STR0111,STR0037) //"Deseja finalizar assim mesmo?"###"ATENÇÃO"
							lRet := .F.
						EndIf
					EndIf
				EndIf
			EndIf

			If lRet
				//Localiza Data/Hora fim da OS
				lSEQUEN0 := .T.
				For nXX := 1 To Len(aCoBrw6)
					If aCoBrw6[nXX, Len(aCoBrw6[nXX]) ]
						Loop
					EndIf
					lTemIReal := .T.
					If aCoBrw6[nXX,nPos] == "P"
						If Len(aFin2P) == 0
							aFin2P := {aCoBrw6[nXX,nDtI],aCoBrw6[nXX,nHoI],aCoBrw6[nXX,nDtI],aCoBrw6[nXX,nHoI]}
						Else
							If DtoS(aCoBrw6[nXX,nDtI]) + aCoBrw6[nXX,nHoI] > DtoS(aFin2P[3])+aFin2P[4]
								aFin2P[3] := aCoBrw6[nXX,nDtI]
								aFin2P[4] := aCoBrw6[nXX,nHoI]
							EndIf
							If DtoS(aCoBrw6[nXX,nDtI]) + aCoBrw6[nXX,nHoI] < DtoS(aFin2P[1])+aFin2P[2]
								aFin2P[1] := aCoBrw6[nXX,nDtI]
								aFin2P[2] := aCoBrw6[nXX,nHoI]
							EndIf
						EndIf
						Loop
					Else //Se possuir insumo diferente de produto atribui .F. para a variavel
						lSoProd := .F.
					EndIf
					If lSEQUEN0
						dMINSTL := aCoBrw6[nXX,nDtI]
						hMINSTL := aCoBrw6[nXX,nHoI]
						dMAXSTL := aCoBrw6[nXX,nDtF]
						hMAXSTL := aCoBrw6[nXX,nHoF]
						lSEQUEN0 := .F.
					EndIf
					If aCoBrw6[nXX,nDtI] < dMINSTL
						dMINSTL := aCoBrw6[nXX,nDtI]
						hMINSTL := aCoBrw6[nXX,nHoI]
					ElseIf aCoBrw6[nXX,nDtI] = dMINSTL
						hMINSTL := If(aCoBrw6[nXX,nHoI] < hMINSTL,aCoBrw6[nXX,nHoI],hMINSTL)
					EndIf
					dMAXF := aCoBrw6[nXX,nDtF]
					hMAXF := aCoBrw6[nXX,nHoF]
					If dMAXF > dMAXSTL
						dMAXSTL := dMAXF
						hMAXSTL := hMAXF
					ElseIf dMAXF = dMAXSTL
						dMAXSTL := If(dMAXF > dMAXSTL,dMAXF,dMAXSTL)
						hMAXSTL := If(hMAXF > hMAXSTL,hMAXF,hMAXSTL)
					EndIf
				Next nXX
			EndIf

			//Se possuir vários tipos de insumos deve validar com o produto, pois os produtos estão no array aFin2P
			If Len( aFin2P ) > 0

				//Verifica se a data do produto é menor a do outro insumo, se for deve pegar a data e horário desse produto
				If aFin2P[1] < dMINSTL

					dMINSTL := aFin2P[1]
					hMINSTL := aFin2P[2]

				//Se a data do produto for igual ao do outro insumo, deve verificar qual possui o menor horário para ser considerado
				ElseIf aFin2P[1] == dMINSTL .And. aFin2P[2] <= hMINSTL

					hMINSTL := aFin2P[2]

				EndIf

				//Verifica se a data do produto é menor a do outro insumo, se for deve pegar a data e horário desse produto
				If aFin2P[3] > dMAXSTL

					dMAXSTL := aFin2P[3]
					hMAXSTL := aFin2P[4]

				//Se a data do produto for igual ao do outro insumo, deve verificar qual possui o menor horário para ser considerado
				ElseIf aFin2P[3] == dMAXSTL .And. aFin2P[4] >= hMAXSTL

						hMAXSTL := aFin2P[4]

				EndIf

			EndIf

			//Valida se tem Data/Hora FIM OS
			If lRet .And. !lSemIns .And. !lTemIReal
				MsgInfo(STR0108+stj->tj_ordem+STR0106+; //"A Ordem de Serviço "###" não poderá ser finalizada, pois"
				chr(13)+chr(10)+STR0109,STR0037) //"não existe insumo realizado."###"ATENÇÃO"
				lRet := .F.
			EndIf

			// Se estiver integrado ao SIGASFC
			// Verifica se é possível finalizar a O.S.
			If lRet .And. lIntSFC .And. !NGSFCATPRD(STJ->TJ_ORDEM,{{"CZ2_LGMN",.F.}},.F.,.F.)
				NGSFCSNDML(4, {{STJ->TJ_ORDEM}})
				lRet := .F.
			EndIf

			If lRet

				/*--------------+
				| Finaliza O.S. |
				+--------------*/
				aFinTmp := { dMINSTL, hMINSTL, dMAXSTL, hMAXSTL, lSoProd }
				nRET    := 0

				fFina435( 'STJ', (cAliOS435)->RECNO, 4, aFinTmp, , aFin2P )

				oBrw6:oBrowse:nAt := 1
				oBrw6:oBrowse:Refresh()
				oBrw6:oBrowse:SetFocus()

				If nRET == 1
					
					nPosAnt := oBrwOS:At()

					aAdd( aVetorFin , { cOrdem, cPlano } )

					If nPosAnt > 0
						
						RecLock( cAliOS435, .F. )

							dbDelete()
				
						MsUnLock()
						
						/*-------------------------------------------------------------------+
						| Caso não possua O.S. não deletas disponiveis na tabela temporaria. | 
						+-------------------------------------------------------------------*/
						If NGCount( oTmpTblOS:GetRealName() ) == 0

							fEmptyOS( .T. )

						ElseIf ( nDataPos := aScan( aDadosOS, {|x|x[1] + x[2] == cOrdem + cPlano }) ) > 0

							aDel( aDadosOS, nDataPos )
							aSize( aDadosOS, Len( aDadosOS ) - 1 )

						EndIf

					EndIf

					// Força atualização do browse para pegar numero correto de linhas ativas
					oBrwOS:Refresh()

					// Utilizado para sair da linha que foi deletada e atualizar corretamente o dbGoTo
					oBrwOS:GoTop()

					// Força atualização do browse para pegar numero correto de linhas ativas
					oBrwOS:Refresh()

					// Atualiza posicionamento do browse
					oBrwOS:GoTo( IIf( nPosAnt > oBrwOS:nLen, oBrwOS:nLen, nPosAnt ), .T. )

					// Força atualização do browse para remover corretamente a linha deletada
					oBrwOS:Refresh()

					// Tratamento para quando o browse possuir filtro e existir apenas 1 registro em tela.
					If nPosAnt > 0 .And. oBrwOS:lFiltrate .And. nPosAnt == oBrwOS:nLen
						fEmptyOS(.T.)
					EndIf

					// Atualiza abas relacionadas as O.S.'s do browse
					fRefreshOS( (cAliOS435)->TJ_ORDEM, (cAliOS435)->TJ_PLANO, 1 )

					// Força atualização do browse para remover corretamente a linha deletada
					oBrwOS:Refresh()

					If lArvoreLogica //Se for chamada atraves da Arvore Logica, a tela sera fechada, pois não ficará nenhuma OS listada no browse
						oDlg1:End()
						lRet := .T.
					EndIf
				EndIf
			EndIf

		Else
			MsgInfo(STR0099) //"Nenhuma ordem de serviço foi selecionada."
		EndIf
	EndIf

	If lRet .And. !lArvoreLogica
		PutFileInEof("STN")
		PutFileInEof("TPL")
		PutFileInEof("STL")
	EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Mnt435Can ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Funcionalidade do botao de cancelar  OS                      ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Mnt435Can()

	Local cOrdem, cPlano, nPosAnt, nLineOS
	Local nRet    := 0
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local aAreaSTJ := {}

	If GetNewPar("MV_NGMNTCC","N") == "S"
		aAreaSTJ := GetArea()
		dbSelectArea("TV9")
		dbSetOrder(1)
		If dbSeek(xFilial("TV9")+STJ->TJ_CODBEM+STJ->TJ_ORDEM)
			MsgStop(STR0351,STR0312)
			Return .F.
		EndIf
		RestArea(aAreaSTJ)
	EndIf

	cOrdem := (cAliOS435)->TJ_ORDEM
	cPlano := (cAliOS435)->TJ_PLANO
	nLineOS := aScan(aDadosOS, {|x|x[1]+x[2] == cOrdem+cPlano })
	dbSelectArea("STJ")
	dbSetOrder(01)
	If dbSeek(xFilial("STJ")+cOrdem+cPlano)

		/* Ponto de entrada executado antes do cancelamento da O.S, como parâmetro
		o código da ordem a ser cancelada. */
		If ExistBlock( "MNTA435F" )
			If !ExecBlock( "MNTA435F",.F.,.F., {cOrdem})
				Return .F.
			EndIf
		EndIf

		//Verifica se a OS tem insumo realizado na tela
		If nPos03 > 0 .And. nLineOS > 0
			If aScan(aDadosOS[nLineOS,5], {|x| !x[Len(x)] .And. !Empty(x[nPos03]) }) > 0
				Help(" ",1,"HAREPORT")
				Return .F.
			EndIf
		EndIf

		// Caso integrado ao modulo SIGASFC, e o bem for uma maquina
		// Verifica se será possivel cancelar a parada programada relacionada a O.S.
		If lIntSFC .And. !Empty(NGVRFMAQ(STJ->TJ_CODBEM)) .And. ;
		!NGSFCDELPP(STJ->TJ_ORDEM,.F.,.F.)
			NGSFCSNDML(3, {{STJ->TJ_ORDEM}}) // Envia e-mail ao responsavel no SIGASFC
			Return .F.
		EndIf

		nPosAnt := oBrwOS:At()

		Begin Transaction

			fGrava435( , .F., .F., .T. )

			If ( nRet := NG400EXC( 'STJ', RecNo(), 5 ) ) != 2

				DisarmTransaction()

				oBrwOS:GoTo( nPosAnt , .T. )

			EndIf

		End Transaction

		If nRet == 2

			aAdd( aVetorCan, { cOrdem, cPlano } )

			If nPosAnt > 0

				RecLock( cAliOS435, .F. )

					dbDelete()
				
				MsUnLock()

				/*-------------------------------------------------------------------+
				| Caso não possua O.S. não deletas disponiveis na tabela temporaria. | 
				+-------------------------------------------------------------------*/
				If NGCount( oTmpTblOS:GetRealName() ) == 0

					fEmptyOS( .T. )

				EndIf

			EndIf

			// Força atualização do browse para pegar numero correto de linhas ativas
			oBrwOS:Refresh()

			// Utilizado para sair da linha que foi deletada e atualizar corretamente o dbGoTo
			oBrwOS:GoTop()

			// Força atualização do browse para pegar numero correto de linhas ativas
			oBrwOS:Refresh()

			// Atualiza posicionamento do browse
			oBrwOS:GoTo( IIf( nPosAnt > oBrwOS:nLen, oBrwOS:nLen, nPosAnt ), .T. )

			// Força atualização do browse para remover corretamente a linha deletada
			oBrwOS:Refresh()

			// Tratamento para quando o browse possuir filtro e existir apenas 1 registro em tela.
			If nPosAnt > 0 .And. oBrwOS:lFiltrate .And. nPosAnt == oBrwOS:nLen
				fEmptyOS(.T.)
			EndIf

			fRefreshOS( (cAliOS435)->TJ_ORDEM, (cAliOS435)->TJ_PLANO, 1 )

			If lArvoreLogica //Se for chamada atraves da Arvore Logica, a tela sera fechada, pois não ficará nenhuma OS listada no browse
				oDlg1:End()
				Return .T.
			EndIf
			/* Ponto de entrada executado no cancelamento da O.s, passa o por parâmetro
			o código da ordem a ser cancelada. */
			If ExistBlock( "MNTA435B" )
				ExecBlock( "MNTA435B",.F.,.F., {cOrdem})
			EndIf

		EndIf

	Else

		MsgInfo(STR0099) //"Nenhuma ordem de serviço foi selecionada."

	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fMontInd ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Monta array com o titulo dos indices                        |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fMontInd(cAliasInd)
	Local aRet := { {} , {} }

	dbSelectArea("SIX")
	dbSetOrder(1)
	dbSeek(cAliasInd)
	While !EoF() .And. SIX->INDICE == cAliasInd
		aAdd(aRet[2], Alltrim(SIX->DESCRICAO) )
		aAdd(aRet[1], Alltrim(SIX->CHAVE) )
		dbSkip()
	End

Return aRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fTrbInsPre³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Cria arquivo temporario para Insumos Previstos             |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fTrbInsPre()

	Local aLine := {}
	Local nXX
	Local nInd1 := 1
	Local aNAO  := {"TL_FILIAL","TL_ORDEM", "TL_PLANO", "TL_REPFIM",;
		"TL_NUMOP", "TL_ITEMOP", "TL_SEQUEOP", "TL_CODBEM",;
	  	"TL_SERVICO", "TL_SEQMAN", "TL_POSCONT", "TL_POSCON2", "TL_TIPOHOR", "TL_SEQUENC", "TL_SEQRMAN",;
	  	"TL_DOC", "TL_ITEM", "TL_ORIGNFE", "TL_SDOC", "TL_HREXTRA ", "TL_NOMTREG", "TL_NOMSEQ "}

	//Ponto de entrada utilizado para Inibir campos da tabela STL na GetDados.
	If ExistBlock ( "MNTA435E" )
		aNAO := ExecBlock("MNTA435E",.F.,.F.,aNAO)
	EndIf

	aHoBrw2 := CabecGetD( 'STL', aNao, 2 )

	nPosXXX := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	If nPosXXX > 0
		aTemp := aClone(aHoBrw2[nPosXXX])
		aDel(aHoBrw2,nPosXXX)
		aSize(aHoBrw2,Len(aHoBrw2)-1)
		aAdd(aHoBrw2 , aClone(aTemp) )
	EndIf

	aDBF   := {}
	aTRBIP := {}
	aAdd(aDBF,  {"TL_OK"     ,"C",02, 0 })
	aAdd(aDBF,  {"STATUS","C",01,0})
	aAdd(aTRBIP,{"TL_OK"     ,Nil," "    ,})
	For nXX := 1 To Len(aHoBrw2)
		aAdd(aDBF,  {Alltrim(aHoBrw2[nXX,2]),aHoBrw2[nXX,8],aHoBrw2[nXX,4], aHoBrw2[nXX,5] })
		If aHoBrw2[nXX,8] == "N"
			aAdd(aTRBIP,{Alltrim(aHoBrw2[nXX,2]),Nil,aHoBrw2[nXX,1],aHoBrw2[nXX,3] })
		Else
			If "TL_USACALE" == Alltrim(aHoBrw2[nXX,2])
				aAdd(aTRBIP,{"XX_USACAL",Nil,aHoBrw2[nXX,1],})
			ElseIf "TL_DESTINO" == Alltrim(aHoBrw2[nXX,2])
				aAdd(aTRBIP,{"XX_DESTIN",Nil,aHoBrw2[nXX,1],})
			ElseIf "TL_GARANTI" == Alltrim(aHoBrw2[nXX,2])
				aAdd(aTRBIP,{"XX_TEMGAR",Nil,aHoBrw2[nXX,1],})
			ElseIf "TL_TIPOREG" == Alltrim(aHoBrw2[nXX,2])
				aAdd(aTRBIP,{"XX_NOMINS",Nil,aHoBrw2[nXX,1],})
			Else
				aAdd(aTRBIP,{Alltrim(aHoBrw2[nXX,2]),Nil,aHoBrw2[nXX,1],})
			EndIf
		EndIf

		If "TL_CODIGO" == Alltrim(aHoBrw2[nXX,2])
			nPosTReg := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
			nPosTReg := Alltrim(Str(nPosTReg,6))
			nPosDTF := Alltrim(Str(aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"}) ,6))
			nPosCOD := Alltrim(Str(aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO"}) ,6))
			aHoBrw2[nXX,6] := 'If(!Empty(M->TL_CODIGO), fValDel435( .T. ) .And. NGPROD435() .And. ' +;
			"If(aCOLS[n]["+nPosTReg+"] = 'M' .And. !Empty(aCOLS[n]["+nPosDTF+"]) ,NGFUNCRH(M->TL_CODIGO,.T.,aCOLS[n]["+nPosDTF+"],.F.),.T.) .And. MNT435CUS(), .T.)"
		ElseIf "TL_QUANTID" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NGQUANT435() .And. MNT435CUS()'
		ElseIf "TL_DTINICI" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435DTINI() .And. ' +;
			"If(aCOLS[n]["+nPosTReg+"] = 'M' ,NGFUNCRH(aCOLS[n]["+nPosCOD+"],.T.,M->TL_DTINICI,.F.),.T.) .And. MNT435CUS()"
		ElseIf "TL_HOINICI" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435HOINI() .And. MNT435CUS()'
		ElseIf "TL_DTFIM"   == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435DTFIM() .And. ' +;
			"If(aCOLS[n]["+nPosTReg+"] = 'M' ,NGFUNCRH(aCOLS[n]["+nPosCOD+"],.T.,M->TL_DTFIM,.F.),.T.) .And. MNT435CUS()"
		ElseIf "TL_HOFIM"   == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435HOFIM() .And. MNT435CUS()'
		ElseIf "TL_LOTECTL" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435LOTCT()'
		ElseIf "TL_NUMLOTE" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435NUMLO()'
		ElseIf "TL_LOCALIZ" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435LOCAL()'
		ElseIf "TL_GARANTI" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := "fValDel435( .T. ) .And. PERTENCE( 'SN' ) .And. fNgGar435( 'S' )"
		ElseIf "TL_TIPOREG" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NGRETNO435( M->TL_TIPOREG ) .And. MNT435CUS()'
		ElseIf "TL_QUANREC" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := If( Empty( aHoBrw2[nXX,6] ) , "MNT435CUS()" , Alltrim(aHoBrw2[nXX,6]) + " .And. MNT435CUS()" )
		ElseIf "TL_LOCAL" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NGVALALMOX() .And. MNT435CUS()'
			
		ElseIf "TL_TAREFA" == Alltrim(aHoBrw2[nXX,2])
			
			If !( aHoBrw2[nXX,6] $ 'NGALTTAR' )
				
				aHoBrw2[nXX,6] := 'NGALTTAR( STJ->TJ_CODBEM + STJ->TJ_SERVICO + STJ->TJ_SEQRELA, M->TL_TAREFA )                                                         '

			EndIf

		EndIf

	Next nXX
	aAdd(aDBF,  {"XTL_SA"  ,"N",6, 0 }) //Tem SA
	aAdd(aDBF,  {"XX_USACAL"  ,"C",3, 0 })
	aAdd(aDBF,  {"XX_DESTIN"  ,"C",12, 0 })
	aAdd(aDBF,  {"XX_TEMGAR"  ,"C",3, 0 })
	aAdd(aDBF,  {"XX_NOMINS"  ,"C",15, 0 })

	oTmpTbl6 := NGFwTmpTbl(cTRBIP,aDBF,{{ "TL_TAREFA","TL_TIPOREG","TL_CODIGO","TL_SEQRELA" }})

	aHoBrw6 := aClone( aHoBrw2 )

	If Len( aCoBrw6 ) == 0

		aCoBrw6 := BlankGetD( aHoBrw6 )

		aCoBrw6[1,Len( aCoBrw6[1] )] := {}
		
		aAdd( aCoBrw6[1], .F. )

		aCoBrw2 := aClone( aCoBrw6 )

		PutFileInEof( 'STL' )
		
		For nInd1 := 1 To Len( aHoBrw6 )
			
			If aHoBrw6[nInd1,2] == 'TL_SEQRELA'
			
				aCoBrw6[1,nInd1] := PADR( '1', 3 )
			
			Else
			
				aCoBrw6[1,nInd1] := CriaVar( AllTrim( aHoBrw6[nInd1,2] ) )
			
			EndIf

		Next nInd1

		If Empty( aNovoSTL )

			aNovoSTL := aClone( aCoBrw6 )
		
		EndIf
	
	EndIf
	
	FWFreeArray( aLine )

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ fAddEtap ³ Autor ³ Denis                 ³ Data ³ 17-09-99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Adiciona etapa de OS antiga nas etapas da OS corrente      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fAddEtap()

	Local aAreaXXXX := GetArea()
	Local aAreaTRBQ := (cTRBQ400)->(GetArea())

	If Empty((cTRBTAR)->TAREFA) .And. Empty((cTRBTAR)->ETAPA)
		Return .F.
	EndIf

	If (cTRBTAR)->(EoF())
		MsgInfo(STR0112) //"Não contém registro na tabela de etapas não realizadas."
		Return .F.
	EndIf

	dbSelectArea( cTRBQ400 )
	dbSetOrder( 2 ) // TQ_TAREFA + TQ_ETAPA + TQ_SEQETA + TQ_SEQTARE
	If !msSeek( (cTRBTAR)->TAREFA + (cTRBTAR)->ETAPA )
		
		lFoiAlterado := .T.

		lInc435 := .T.
		If (cTRBQ400)->( LastRec() ) == 1
			(cTRBQ400)->(dbGoTop())
			If (cTRBQ400)->(!EoF()) .And. Empty((cTRBQ400)->TQ_ETAPA) .And. Empty((cTRBQ400)->TQ_TAREFA)
				lInc435 := .F.
			EndIf
		EndIf

		RecLock( cTRBQ400, lInc435 )
			(cTRBQ400)->TQ_TAREFA  := (cTRBTAR)->TAREFA
			(cTRBQ400)->TQ_NOMTARE := (cTRBTAR)->NOMETAR
			(cTRBQ400)->TQ_ETAPA   := (cTRBTAR)->ETAPA
			(cTRBQ400)->TQ_NOMETAP := (cTRBTAR)->NOMEETA
			(cTRBQ400)->TQ_OK      := "  "
			(cTRBQ400)->TQ_ORDEM   := cOrdemTJ
			(cTRBQ400)->TQ_PLANO   := cPlanoTJ
			(cTRBQ400)->TQ_SEQRELA := '0'
		(cTRBQ400)->( MsUnlock() )

		dbSelectArea(cTRBTAR)
		dbSetOrder(1)
		RecLock((cTRBTAR),.F.)
		dbDelete()
		(cTRBTAR)->(MsUnLock())

		If (cTRBTAR)->(EoF())
			dbSelectArea(cTRBTAR)
			dbGoTop()
		EndIf

		dbSelectArea(cTRBTAR)
		oBrw7:Refresh()
		dbSelectArea(cTRBQ400)

		oBrw4:Refresh()
		oBrw4:GoTop()

	Else

		Help( , , STR0037, , STR0113, 2, 0 ) // Esta tarefa/etapa já existe para a Ordem de Serviço.
	
	EndIf

	RestArea(aAreaTRBQ)
	RestArea(aAreaXXXX)

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fExecEtap
Processo de execução de múltiplas etapas.
@type Function

@author Alexandre Santos
@since  15/12/2023

@param
@return
/*/
//---------------------------------------------------------------------
Static Function fExecEtap()

	Local aAreaTRB := (cTRBQ400)->( FWGetArea() )
	Local aColList := {}
	Local aColExec := aClone( aNovoExec )
	Local aColsBkp := aClone( oBrw6:aCols )
	Local cBkpTit  := cCadastro
	Local lOk      := .F.
	Local nInd1    := 0

	cCadastro := STR0412 + cOrdemTJ // Execução Múltipla de Etapas - O.S.:

	DEFINE MSDIALOG oDlgEtap TITLE STR0411 From 3,0 TO 340,417 PIXEL // Execução Múltipla de Etapas

		oDlgEtap:lMaximized := .T.

		/*--------------------------------------------+
		| Limpa tabela temp. de Etapas em executadas. |
		+--------------------------------------------*/
		NGZap( oTmpTbl9:GetRealName() )

		/*------------------------+
		| Monta o aCols de etapas |
		+------------------------*/
		fColsEtap()

		oPnlMaster := TPanel():New( 0, 0, , oDlgEtap, , , , , , 10, 10 )
		oPnlMaster:Align := CONTROL_ALIGN_ALLCLIENT

			oPnlTop := TPanel():New( 0, 0, , oPnlMaster, , , , , , 10, 120 )
			oPnlTop:Align := CONTROL_ALIGN_TOP

				oGd435Et2 := FwBrowse():New()
				oGd435Et2:SetOwner( oPnlTop )
				oGd435Et2:DisableConfig() // Desabilita a Configuração do browse
				oGd435Et2:DisableFilter() // Desabilita o Filtro
				oGd435Et2:DisableLocate() // Desabilita a Localização
				oGd435Et2:DisableReport() // Desabilita o Relatório
				oGd435Et2:DisableSeek() // Desabilita a Pesquisa
				oGd435Et2:DisableSaveConfig()
				oGd435Et2:DisableFilter()
				oGd435Et2:SetDataTable()
				oGd435Et2:SetAlias( cAlsExecu )
				oGd435Et2:SetInsert( .F. ) // Desabilita a Inserção de registros

				For nInd1 := 1 To Len( aTrbQ )

					If !( aTrbQ[nInd1,2] $ 'TQ_CODFUNC/TQ_SEQTARE/TQ_SEQETA/TQ_OBSERVA' )

						aAdd( aColList, NGObjeColu( '{ || (cAlsExecu)->' + aTrbQ[nInd1,2] + ' }',;
							.F., aTrbQ[nInd1,1], aTrbQ[nInd1,3], aTrbQ[nInd1,4], aTrbQ[nInd1,6] ) )

					EndIf

				Next nInd1

				oGd435Et2:SetColumns( aColList )
				oGd435Et2:Activate()

			oPnlBot := TPanel():New( 0, 0, , oPnlMaster, , , , , , 10, 50  )
			oPnlBot:Align := CONTROL_ALIGN_ALLCLIENT

				PutFileInEof( 'STL' )

				oGd435In2 := MsNewGetDados():New( 0, 0, 0, 0, GD_INSERT + GD_UPDATE, 'MNA435LiOk( Nil, oGd435In2:nAt, 2 )', , , , ,;
					9999, , , , oPnlBot, aHeaExec, aColExec )
				oGd435In2:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	ACTIVATE MSDIALOG oDlgEtap ON INIT EnchoiceBar( oDlgEtap, { || lOk := MNA435TdOk( 2, oDlgEtap ) },;
		{|| oDlgEtap:End() }) CENTERED

	If lOk

		nCodIn1 := GDFieldPos( 'TL_CODIGO' , oBrw6:aHeader )
		nTipRe1 := GDFieldPos( 'TL_TIPOREG', oBrw6:aHeader )
		nTarGe1 := GDFieldPos( 'TL_TAREFA' , oBrw6:aHeader )
		nDtIni1 := GDFieldPos( 'TL_DTINICI', oBrw6:aHeader )
		nHrIni1 := GDFieldPos( 'TL_HOINICI', oBrw6:aHeader )
		nQuant1 := GDFieldPos( 'TL_QUANTID', oBrw6:aHeader )
		nSeqRel := GDFieldPos( 'TL_SEQRELA', oBrw6:aHeader )

		nCodIn2 := GDFieldPos( 'TL_CODIGO' , oGd435In2:aHeader )
		nTipRe2 := GDFieldPos( 'TL_TIPOREG', oGd435In2:aHeader )
		nDtIni2 := GDFieldPos( 'TL_DTINICI', oGd435In2:aHeader )
		nHrIni2 := GDFieldPos( 'TL_HOINICI', oGd435In2:aHeader )
		nDtFim2 := GDFieldPos( 'TL_DTFIM'  , oGd435In2:aHeader )
		nHrFim2 := GDFieldPos( 'TL_HOFIM'  , oGd435In2:aHeader )
		nUsCal2 := GDFieldPos( 'TL_USACALE', oGd435In2:aHeader )
		nQuant2 := GDFieldPos( 'TL_QUANTID', oGd435In2:aHeader )
		nUnida2 := GDFieldPos( 'TL_UNIDADE', oGd435In2:aHeader )
		nCusto2 := GDFieldPos( 'TL_CUSTO'  , oGd435In2:aHeader )
		nObser2 := GDFieldPos( 'TL_OBSERVA', oGd435In2:aHeader )

		(cAlsExecu)->( dbGoTop() )

		While (cAlsExecu)->( !EoF() )

			For nInd1 := 1 To Len( oGd435In2:aCols )

				If nTail := aScan( oBrw6:aCols, { |x| !aTail( x ) .And. x[nTipRe1] == 'M' .And. x[nTarGe1] == (cAlsExecu)->TQ_TAREFA .And.;
					x[nCodIn1] == oGd435In2:aCols[nInd1,nCodIn2] .And. x[nDtIni1] == oGd435In2:aCols[nInd1,nDtIni2] .And.;
					x[nHrIni1] == oGd435In2:aCols[nInd1,nHrIni2] .And. x[nQuant1] == oGd435In2:aCols[nInd1,nQuant2] } )

					dbSelectArea( cTRBQ400 )
					dbSetOrder( 4 ) // TQ_ORDEM + TQ_PLANO + TQ_TAREFA + TQ_ETAPA + TQ_SEQRELA
					If msSeek( cOrdemTJ + cPlanoTJ + (cAlsExecu)->TQ_TAREFA +;
						(cAlsExecu)->TQ_ETAPA )

						If Empty( (cTRBQ400)->TQ_CODFUNC )

							RecLock( cTRBQ400, .F. )

								(cTRBQ400)->TQ_MARK    := ''
								(cTRBQ400)->TQ_OK      := 'XX'
								(cTRBQ400)->TQ_CODFUNC := oBrw6:aCols[nTail,nCodIn1]
								(cTRBQ400)->TQ_SEQRELA := oBrw6:aCols[nTail,nSeqRel]

							MsUnLock()

						Else

							RecLock( cTRBQ400, .T. )

								(cTRBQ400)->TQ_TAREFA  := (cAlsExecu)->TQ_TAREFA
								(cTRBQ400)->TQ_NOMTARE := (cAlsExecu)->TQ_NOMTARE
								(cTRBQ400)->TQ_ETAPA   := (cAlsExecu)->TQ_ETAPA
								(cTRBQ400)->TQ_NOMETAP := (cAlsExecu)->TQ_NOMETAP
								(cTRBQ400)->TQ_CODFUNC := oBrw6:aCols[nTail,nCodIn1]
								(cTRBQ400)->TQ_SEQRELA := oBrw6:aCols[nTail,nSeqRel]
								(cTRBQ400)->TQ_OK      := 'XX'
								(cTRBQ400)->TQ_ORDEM   := cOrdemTJ
								(cTRBQ400)->TQ_PLANO   := cPlanoTJ
								(cTRBQ400)->CODBEM     := STJ->TJ_CODBEM

							MsUnLock()

						EndIf

						fLegendEt( (cTRBQ400)->TQ_ORDEM + (cTRBQ400)->TQ_PLANO + (cTRBQ400)->TQ_TAREFA +;
							(cTRBQ400)->TQ_ETAPA + (cTRBQ400)->TQ_SEQRELA, 4 )

					EndIf

				EndIf

			Next nInd1

			(cAlsExecu)->( dbSkip() )

		End

		/*----------------------------------------------------------------+
		| Atualiza tabelas temporárias/arrays com as alterações de etapas |
		+----------------------------------------------------------------*/
		Fd_Sai( 4 )

		oBrw6:oBrowse:Refresh()

	Else

		oBrw6:aCols := aClone( aColsBkp )

	EndIf

	cCadastro := cBkpTit

	FWRestArea( aAreaTRB )

	oBrw4:Refresh()
	oBrw4:GoTop()

	FWFreeArray( aColList )
	FWFreeArray( aAreaTRB )
	FWFreeArray( aColExec )
	FWFreeArray( aColsBkp )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fColsEtap
Montagem do aCols de etapas para execução.
@type Function

@author Alexandre Santos
@since  15/12/2023

@param
@return
/*/
//---------------------------------------------------------------------
Static Function fColsEtap()

	Local nInd1    := 0
	Local nRecTRB  := 0
	
	dbSelectArea( cTRBQ400 )
	dbSetOrder( 4 )
	If msSeek( (cAliOS435)->TJ_ORDEM + (cAliOS435)->TJ_PLANO )

		While (cTRBQ400)->( !EoF() ) .And. (cAliOS435)->TJ_ORDEM == (cTRBQ400)->TQ_ORDEM .And.;
			(cAliOS435)->TJ_PLANO == (cTRBQ400)->TQ_PLANO

			If !Empty( (cTRBQ400)->TQ_MARK )

				nRecTRB := (cTRBQ400)->( RecNo() )

				RecLock( cAlsExecu, .T. )

					For nInd1 := 1  To Len( aTrbQ )

						&( "(cAlsExecu)->" + aTrbQ[nInd1,2] ) := &( "(cTRBQ400)->" + aTrbQ[nInd1,2] )

					Next nInd1

				MsUnLock()

			EndIf

			(cTRBQ400)->( dbSkip() )

		End

	EndIf

Return

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} MNTA435Mrk
Regra executada após a marcar/desmarcar uma etapa.
@type function

@author Dênis
@since 17/09/1999

@param
@return
/*/
//-----------------------------------------------------------------------------------
Static Function MNTA435Mrk()

	Local aAreaTRB := (cTRBQ400)->( FWGetArea() )

	If SuperGetMV( 'MV_NG1ETPM', .F., 'N' ) == 'S'

		dbSelectArea( cTRBQ400 )
		dbSetOrder( 5 ) // TQ_MARK
		If msSeek( cMarca )

			oBtEtExe:Enable()

		Else

			oBtEtExe:Disable()

		EndIf

	Else

		lFoiAlterado := .T.
		dbSelectarea(cTRBQ400)
		dbSetOrder(2)
		dbSeek((cTRBQ400)->TQ_TAREFA+(cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_SEQETA)
		RecLock(cTRBQ400, .F.)

		If Empty((cTRBQ400)->TQ_OK)
			(cTRBQ400)->TQ_CODFUNC := Space( TamSX3('TQ_CODFUNC')[1] )
		EndIf

		(cTRBQ400)->(MsUnlock())

		fMNTA405()

		fLegendEt((cTRBQ400)->TQ_TAREFA+(cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_SEQETA) //Define as cores para legenda de etapas

		Fd_Sai( 4 )

	EndIf

	FWRestArea( aAreaTRB )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fVldMarkEt
Validação ao marcar a etapa para execução.
@type Function

@author Alexandre Santos
@since  15/12/2023

@param
@return boolean, Indica se a etapa pode ser marcada.
/*/
//---------------------------------------------------------------------
Static Function fVldMarkEt()

	Local aArea   := (cTRBQ400)->( FWGetArea() )
	Local cTarEtp := (cTRBQ400)->TQ_TAREFA
	Local lRet    := .T.

	dbSelectArea( cTRBQ400 )
	dbSetOrder( 5 ) // TQ_MARK
	If msSeek( cMarca )

		While (cTRBQ400)->( !EoF() ) .And.;
			!Empty( (cTRBQ400)->TQ_MARK )

			If !( cTarEtp == (cTRBQ400)->TQ_TAREFA )

				Help( , , STR0037, , STR0409, 2, 0 ) // Não é possivel marcar etapas com tarefas diferentes para execução.

				lRet := .F.

				Exit

			EndIf

			(cTRBQ400)->( dbSkip() )

		End

	EndIf

	FWRestArea( aArea )

	FWFreeArray( aArea )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fCadEtapa
Cadastro de etapas

@param nOpcx, string, operação: 1=incluir;2=excluir;3=alterar
@author Denis
@since 17/09/99
@return bollean, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fCadEtapa(nOPCX)

	Local aAreaSTJ   := STJ->(GetArea())
	Local aAreaTRB   := (cTRBQ400)->(GetArea())
	Local cCadOld    := cCadastro
	Local nOldPerc   := 0
	Local lUSATARL   := NGUSATARPAD()
	Local lEtaMult   := SuperGetMV( 'MV_NG1ETPM', .F., 'N' ) == 'S'
	Local lCORRET    := If(Val(STJ->TJ_PLANO) == 0,.T.,.F.)
	// [LGPD] Caso o usuário não possua acesso ao(s) campo(s), deve-se ofuscá-lo(s)
	Local lOfuscar := FindFunction( 'FWPDCanUse' ) .And. FwPdCanUse( .T. );
						.And. Len( FwProtectedDataUtil():UsrAccessPDField( __CUSERID, { 'T1_NOME' } ) ) == 0
	Local oldHead
	Local oldCols
	Local lIncOpc    := .F.
	Local lTemOsG    := .F.
	Local lRet       := .F.
	Local cVldEtapa  := 'NGSTQETA(M->TQ_ETAPA) '
	Local cVldTarefa := 'If(FindFunction("NGGTARPADRA") .And. cF3T=="TT9",NGALTTAR(STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,M->TQ_TAREFA),NGSTQTAR(M->TQ_TAREFA))'
	Local cValidUser := ""

	Private lCheckEta := .F.
	Private lCheckFun := .F.

	Private oGetExeSRA := Nil
	Private oGetExeNom := Nil
	Private oGetSeqEta := Nil
	Private oCBoxChkEt := Nil

	If ExistBlock( "MNTA4359" )
		lRet := ExecBlock( "MNTA4359",.F.,.F.,{ nOPCX,(cTRBQ400) } )
		If !lRet
			Return .F.
		EndIf
	EndIf

	nOPCA   := 0
	aCOLS   := {}

	M->TQ_TAREFA  := Space(TamSX3('TQ_TAREFA')[1])
	M->TQ_NOMTARE := Space(TamSX3('TQ_NOMTARE')[1])
	M->TQ_ETAPA   := Space(TamSX3('TQ_ETAPA')[1])
	M->TQ_NOMETAP := Space(TamSX3('TQ_NOMETAP')[1])
	M->TQ_SEQETA  := Space(TamSX3('TQ_SEQETA')[1])
	M->TQ_PERCENT := 0
	M->TQ_CODFUNC := Space( TamSX3('TQ_CODFUNC')[1] )
	M->TQ_OBSERVA := Space(TamSX3('TQ_OBSERVA')[1])
	cNOMFUNC      := Space(30)
	M->TQ_SEQTARE := Space(TamSX3('TQ_SEQTARE')[1])

	//Nao pode desmarcar Etapa, caso a resposta desta etapa gerou uma OS e esta OS nao esta com situação cancelada
	If !Empty((cTRBQ400)->TQ_OK) .And. nOPCx <> 1
		//Verifica se foi gerada OS para esta etapa, e a OS gerada nao esta cancelada
		If nOPCx == 2 //Se Exclusão
			If !MNT400OSG( (cTRBQ400)->TQ_ORDEM , (cTRBQ400)->TQ_PLANO , (cTRBQ400)->TQ_TAREFA , (cTRBQ400)->TQ_ETAPA , .T. ,  .T.  )
				Return .F.
			ElseIf !MNT400SSG( (cTRBQ400)->TQ_ORDEM, (cTRBQ400)->TQ_PLANO, (cTRBQ400)->TQ_TAREFA, (cTRBQ400)->TQ_ETAPA )
				Return .F.
			EndIf
		Else //Se Alteracao
			If !MNT400OSG( (cTRBQ400)->TQ_ORDEM , (cTRBQ400)->TQ_PLANO , (cTRBQ400)->TQ_TAREFA , (cTRBQ400)->TQ_ETAPA , .F. ,  .F.  )
				lTemOsG := .T.
			EndIf
		EndIf
	EndIf

	dbSelectArea("STJ")
	dbSetOrder(1)
	dbSeek( xFilial("STJ") + cOrdemTJ + cPlanoTJ )
	If nOPCX != 1
		dbSelectArea("ST5")
		dbSetOrder(1)
		dbSeek(xFilial("ST5")+STJ->TJ_CODBEM + STJ->TJ_SERVICO + STJ->TJ_SEQRELA + (cTRBQ400)->TQ_TAREFA)
		M->TQ_TAREFA  := (cTRBQ400)->TQ_TAREFA
		M->TQ_NOMTARE := NGNOMETAR( STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA , (cTRBQ400)->TQ_TAREFA )
		dbSelectArea("TPA")
		dbSetOrder(1)
		dbSeek(xFilial("TPA") + (cTRBQ400)->TQ_ETAPA)
		M->TQ_ETAPA   := (cTRBQ400)->TQ_ETAPA
		M->TQ_NOMETAP := TPA->TPA_DESCRI
		M->TQ_SEQETA  := (cTRBQ400)->TQ_SEQETA
		M->TQ_SEQTARE := (cTRBQ400)->TQ_SEQTARE
		M->TQ_OBSERVA := (cTRBQ400)->TQ_OBSERVA
		M->TQ_CODFUNC := (cTRBQ400)->TQ_CODFUNC
		M->TQ_OBSERVA := (cTRBQ400)->TQ_OBSERVA

		dbSelectArea("ST1")
		dbSetOrder(1)
		dbSeek(xFilial("ST1")+M->TQ_CODFUNC)
		cNOMFUNC      := ST1->T1_NOME

		If !Empty((cTRBQ400)->TQ_OK)

			lCheckEta := .T.
			nOldPerc  := 100

		EndIf

	EndIf

	If nOPCx <> 1
		If Empty(M->TQ_ETAPA)
			Return
		EndIf
	EndIf

	cF3T := 'ST5'

	If ExistBlock( 'NGTROCF3' )

		cF3T := ExecBlock( 'NGTROCF3', .F., .F. )

		/*------------------------------------------------------------------------------------+
		| Ao trocar a consulta do campo o valid padrão tbm é alterado, pois a função NGALTTAR |
		| possui ponto de entrada para customização.                                          |
		+------------------------------------------------------------------------------------*/
		cVldTarefa := 'NGALTTAR( STJ->TJ_CODBEM + STJ->TJ_SERVICO + STJ->TJ_SEQRELA, M->TQ_TAREFA )'

	ElseIf ( ( lUSATARL .And. lCORRET ) .Or. AllTrim( STJ->TJ_SERVICO ) == 'HISTOR' )

		cF3T := 'TT9'

	EndIf

	//Busca as validações de usuário no campo de tarefa e etapa.
	cValidUser := Posicione("SX3",2,"TQ_TAREFA","X3_VLDUSER")
	If !Empty(cValidUser)
		cVldTarefa += " .And. " + cValidUser
	EndIf

	cValidUser := Posicione("SX3",2,"TQ_ETAPA","X3_VLDUSER")
	If !Empty(cValidUser)
		cVldEtapa += " .And. " + cValidUser
	EndIf

	oldHead := aClone(aHeader)
	oldCols := aClone(aCols)
	aHeader := nil
	aCols   := {}

	cCadastro := STR0114 //"Etapas da O.S."

	DEFINE MSDIALOG oDlg5 TITLE cCadastro+"  "+Alltrim(cOrdemTJ)+" - "+If(nOPCX=1,STR0028,If(nOPCX=3,STR0029,STR0030)) From 15,20 To 35,78 OF oMainWnd //"Incluir"###"Alterar"###"Excluir"

		oPanel := TPanel():New( 00,00,,oDlg5,,,,,CLR_WHITE,18,12,.F.,.F. )
		oPanel:Align := CONTROL_ALIGN_ALLCLIENT

		@ 10.5,5 Say OemToAnsi(STR0023) SIZE 37,7 OF oPanel PIXEL //"Tarefa"
		@ 10,040 MsGet M->TQ_TAREFA  SIZE 025,7 OF oPanel PIXEL F3 cF3T ;
		VALID &(cVldTarefa)  WHEN (nOPCX == 1) HASBUTTON
		@ 10,075 MsGet M->TQ_NOMTARE SIZE 150,7 OF oPanel PIXEL When .F.

		@ 25.5,5 Say OemToAnsi(STR0025) SIZE 37,7 OF oPanel PIXEL    //"Etapa"
		@ 25,040 MsGet M->TQ_ETAPA   SIZE 025,7 OF oPanel PIXEL F3 "MNTTAR" VALID &(cVldEtapa) WHEN (nOPCX == 1) HASBUTTON
		@ 25,075 MsGet M->TQ_NOMETAP SIZE 150,7 OF oPanel PIXEL When .F.

		@ 40.5,5 Say OemToAnsi(STR0115) SIZE 37,7 OF oPanel PIXEL //"Seq.Etapa"
		@ 40,040 MsGet oGetSeqEta Var M->TQ_SEQETA  SIZE 025,7 OF oPanel PIXEL WHEN (nOPCX != 2)

		If lEtaMult

			@ 40.5,075 CheckBox oCBox3 Var lCheckEta Prompt STR0116 OF oPanel On Change ValEtaFun(2) Pixel SIZE 80,09 WHEN ( lCheckEta .And. nOPCX == 3 .And. !lTemOsG ) //"Etapa Concluída?"

		Else

			@ 40.5,075 CheckBox oCBox3 Var lCheckEta Prompt STR0116 OF oPanel On Change ValEtaFun(2) Pixel SIZE 80,09 WHEN (nOPCX != 2 .And. !lTemOsG) //"Etapa Concluída?"

		EndIf

		@ 55.5,5 Say OemToAnsi(STR0060) SIZE 37,7 OF oPanel PIXEL //Observação
		@ 55,040 GET oMemo VAR M->TQ_OBSERVA MEMO SIZE 185,25 OF oPanel PIXEL

		@ 87.5,5 Say Oemtoansi(STR0066) OF oPanel PIXEL //"Executante"

		If lEtaMult

			@ 87,040 MsGet oGetExeSRA Var M->TQ_CODFUNC  Picture "@!" Size 025,7 F3 "ST1" Valid ValFunExe(M->TQ_CODFUNC) OF oPanel PIXEL WHEN .F. HASBUTTON

		Else

			@ 87,040 MsGet oGetExeSRA Var M->TQ_CODFUNC  Picture "@!" Size 025,7 F3 "ST1" Valid ValFunExe(M->TQ_CODFUNC) OF oPanel PIXEL WHEN (nOPCX != 2 .And. lCheckEta ) HASBUTTON

		EndIf

		@ 87,075 MsGet oGetExeNom Var cNOMFUNC When .F. Size 150,7 OF oPanel PIXEL

		If lOfuscar
			oGetExeNom:lObfuscate := .T.
			oGetExeNom:bWhen := {|| .F. }
		EndIf

		If !lEtaMult

			@ 102,5 CheckBox oCBoxF Var lCheckFun Prompt STR0117 OF oPanel Pixel SIZE 200,09 WHEN (nOPCX != 2 .And. !Empty(M->TQ_CODFUNC)) //"Deseja replicar este executante nas demais etapas concluídas?"

		EndIf

	ACTIVATE MSDIALOG oDlg5 ON INIT EnchoiceBar(oDlg5,{||nOpca:=1,oDlg5:End()},{||oDlg5:End()}) CENTERED

	If nOPCA == 1

		lFoiAlterado := .T.

		If nOPCx == 1

			dbSelectArea( cTRBQ400 )
			dbSetOrder( 2 ) // TQ_TAREFA + TQ_ETAPA + TQ_SEQETA + TQ_SEQTARE

			lInc435 := .T.
			If (cTRBQ400)->(Reccount()) == 1
				(cTRBQ400)->(dbGoTop())
				If (cTRBQ400)->(!EoF()) .And. Empty((cTRBQ400)->TQ_ETAPA) .And. Empty((cTRBQ400)->TQ_TAREFA)
					lInc435 := .F.
				EndIf
			EndIf

			If !msSeek( M->TQ_TAREFA + M->TQ_ETAPA )

				RecLock(cTRBQ400,lInc435)

					(cTRBQ400)->TQ_ORDEM   := cOrdemTJ
					(cTRBQ400)->TQ_PLANO   := cPlanoTJ
					(cTRBQ400)->TQ_TAREFA  := M->TQ_TAREFA
					(cTRBQ400)->TQ_NOMTARE := M->TQ_NOMTARE
					(cTRBQ400)->TQ_ETAPA   := M->TQ_ETAPA
					(cTRBQ400)->TQ_NOMETAP := M->TQ_NOMETAP
					(cTRBQ400)->TQ_SEQETA  := M->TQ_SEQETA
					(cTRBQ400)->TQ_SEQTARE := M->TQ_SEQTARE
					(cTRBQ400)->TQ_CODFUNC := M->TQ_CODFUNC
					(cTRBQ400)->TQ_OBSERVA := M->TQ_OBSERVA
					(cTRBQ400)->CODBEM     := STJ->TJ_CODBEM

					If !lCheckEta

						(cTRBQ400)->TQ_OK      := '  '
						(cTRBQ400)->TQ_SEQRELA := '0  '

					ElseIf !lEtaMult

						(cTRBQ400)->TQ_OK      := cMarca
						(cTRBQ400)->TQ_SEQRELA := '0  '

						lIncOpc := .T.

					EndIf

				(cTRBQ400)->( MsUnLock() )

				/*----------------------------------------+
				| Define as cores para legenda de etapas. |
				+----------------------------------------*/
				fLegendEt( (cTRBQ400)->TQ_ORDEM + (cTRBQ400)->TQ_PLANO + (cTRBQ400)->TQ_TAREFA +;
					(cTRBQ400)->TQ_ETAPA + (cTRBQ400)->TQ_SEQRELA, 4 )

			Else

				Help( , , STR0037, , STR0113, 2, 0 ) // Esta tarefa/etapa já existe para a Ordem de Serviço.

			EndIf

			aAreaTRB := (cTRBQ400)->( FWGetArea() )

		ElseIf nOPCx == 2

			dbSelectArea(cTRBQ400)
			dbSetOrder(2)
			dbSeek((cTRBQ400)->TQ_TAREFA + (cTRBQ400)->TQ_ETAPA + (cTRBQ400)->TQ_SEQETA)

			/*----------------------------------------------------+
			| Valida se permite excluir insumo vinculado a etapa. |
			+----------------------------------------------------*/
			If STQ->( FieldPos( 'TQ_SEQRELA' ) ) == 0 .Or.;
				fDelInsum( (cTRBQ400)->TQ_SEQRELA, .F., (cTRBQ400)->TQ_OK )

				RecLock( cTRBQ400, .F. )
					dbDelete()
				MsUnLock()

			EndIf

			RestArea(aAreaTRB)
			Pack

		ElseIf nOPCx == 3

			RestArea(aAreaTRB)

			/*----------------------------------------------------+
			| Valida se permite excluir insumo vinculado a etapa. |
			+----------------------------------------------------*/
			If STQ->( FieldPos( 'TQ_SEQRELA' ) ) == 0 .Or.;
				fDelInsum( (cTRBQ400)->TQ_SEQRELA, lCheckEta, (cTRBQ400)->TQ_OK )

				If !lCheckEta .And. Trim( (cTRBQ400)->TQ_SEQRELA ) != '0'

					aAreaTRB := (cTRBQ400)->( FWGetArea() )

					dbSelectArea( cTRBQ400 )
					dbSetOrder( 4 )
					If msSeek( (cTRBQ400)->TQ_ORDEM + (cTRBQ400)->TQ_PLANO + (cTRBQ400)->TQ_TAREFA +;
						(cTRBQ400)->TQ_ETAPA + '0' )

						RecLock( cTRBQ400, .F. )
							dbDelete()
						MsUnLock()

					EndIf

					FWRestArea( aAreaTRB )

				EndIf

				RecLock( cTRBQ400, .F. )

					(cTRBQ400)->TQ_SEQETA  := M->TQ_SEQETA
					(cTRBQ400)->TQ_SEQTARE := M->TQ_SEQTARE
					(cTRBQ400)->TQ_CODFUNC := M->TQ_CODFUNC
					(cTRBQ400)->TQ_OBSERVA := M->TQ_OBSERVA

					If !lCheckEta

						(cTRBQ400)->TQ_OK      := '  '
						(cTRBQ400)->TQ_SEQRELA := '0  '
					
					ElseIf !lEtaMult

						(cTRBQ400)->TQ_OK      := cMarca
						(cTRBQ400)->TQ_SEQRELA := '0  '
						
						lIncOpc := .T.

					EndIf

				(cTRBQ400)->( MsUnLock() )

				/*----------------------------------------+
				| Define as cores para legenda de etapas. |
				+----------------------------------------*/
				fLegendEt( (cTRBQ400)->TQ_ORDEM + (cTRBQ400)->TQ_PLANO + (cTRBQ400)->TQ_TAREFA +;
					(cTRBQ400)->TQ_ETAPA + (cTRBQ400)->TQ_SEQRELA, 4 )

			EndIf

		EndIf

		If nOPCx != 2 .And. lIncOpc

			fMNTA405()
			
		EndIf

		//--------------------------------------------------
		//Replica executante nas demais etapas concluidas
		//somente nas etapas que não estão gravadas no banco
		//--------------------------------------------------
		If lCheckFun .And. !Empty(M->TQ_CODFUNC)
			dbSelectArea(cTRBQ400)
			dbGoTop()
			While !(cTRBQ400)->( EoF() )
				If !Empty( (cTRBQ400)->TQ_OK ) .And. ( Empty( (cTRBQ400)->TQ_CODFUNC ) .Or.;
					!fRecord( cTRBQ400 ) )

					(cTRBQ400)->TQ_CODFUNC := M->TQ_CODFUNC
				EndIf
				(cTRBQ400)->( dbSkip() )
			EndDo
		EndIf

		//Atualiza tabelas temporárias/arrays com as alterações de etapas
		Fd_Sai( 4 )

		//Chama ponto de entrada para imprimir a O.S.
		If nOPCx == 1
			If ExistBlock ( "MNTA435K" )
				ExecBlock("MNTA435K",.F.,.F.,{ cOrdemTJ, cTRBQ400 } )
			EndIf
		EndIf

	EndIf

	aHeader := aClone(oldHead)
	aCols   := aClone(oldCols)

	cCadastro := cCadOld
	RestArea(aAreaSTJ)

	dbSelectArea(cTRBQ400)
	dbSetOrder( 3 )

	oBrw4:GoTop( .T. )

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fDelInsum
Valida e exclui insumo originado por etapa executada.
@type Function

@author Alexandre Santos
@since  15/12/2023

@param 	cSeqRel, string, Sequência do insumo que deve ser excluido.
@param 	lChkEta, string, Indica se a etapa estava executada.
@return boolean, Indica se o insumo foi excluido.
/*/
//---------------------------------------------------------------------
Static Function fDelInsum( cSeqRel, lChkEta, cMarkOK )

	Local aAreaTMP := (cTRBQ400)->( FWGetArea() )
	Local lRet     := .T.
	Local nPosSTL  := 0
	Local nQtdSeq  := 0
	Local nPosSeq  := GDFieldPos( 'TL_SEQRELA', oBrw6:aHeader )

	If !Empty( cMarkOK ) .And. !lChkEta .And. Trim( cSeqRel ) != '0'

		dbSelectArea( cTRBQ400 )
		dbSetOrder( 6 ) // TQ_SEQRELA
		msSeek( cSeqRel )

		While (cTRBQ400)->( !EoF() ) .And.;
			(cTRBQ400)->TQ_SEQRELA == cSeqRel

				nQtdSeq++

				If nQtdSeq > 1

					Exit

			EndIf

			(cTRBQ400)->( dbSkip() )

		End

		If nQtdSeq == 1

			If ( nPosSTL := aScan( oBrw6:aCols, { |x| x[nPosSeq] == cSeqRel .And.;
				!aTail( x ) } ) ) > 0

				If fValDel435( .F., oBrw6:aCols[nPosSTL], nPosSTL, Nil )

					oBrw6:GoTo( nPosSTL )
					oBrw6:DelLine()

					oBrw6:oBrowse:Refresh()
					oBrw6:oBrowse:SetFocus()

					Fd_Sai( 1 )

				EndIf

			EndIf

		EndIf

	EndIf

	FWRestArea( aAreaTMP )

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ ValFunExe³ Autor ³ Denis                 ³ Data ³29/06/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida funcionario executante da etapa                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function ValFunExe(cTQ_CODFUNC)
	Local lRet := NG400FUN(cTQ_CODFUNC)

	If ValType(lRet) == "L"
		If !lRet
			Return .F.
		EndIf
	EndIf

	If Empty(cTQ_CODFUNC)
		lCheckFun := .F.
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ ValEtaFun³ Autor ³ Denis                 ³ Data ³29/06/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida se habilita campo Executante ou nao                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function ValEtaFun(nTipo)
	If nTipo == 1

		If !Positivo(M->TQ_PERCENT)
			Return .F.
		EndIf

		If M->TQ_PERCENT > 100

			MsgInfo(STR0118) //"Porcentagem não pode ser maior que 100%"
			Return .F.

		ElseIf M->TQ_PERCENT != 100

			If M->TQ_PERCENT == 0
				//De acordo com a utilização do Ponto de Entrada MNTA435G para gravação do código do funcionário padrão
				If Empty(cCodFunc)
					M->TQ_CODFUNC	:= Space( TamSX3('TQ_CODFUNC')[1] )
					cNOMFUNC		:= Space(30)
				Else
					M->TQ_CODFUNC	:= cCodFunc
					dbSelectArea("ST1")
					dbSetOrder(1)
					If dbSeek(xFilial("ST1")+M->TQ_CODFUNC)
						cNOMFUNC		:= ST1->T1_NOME
					EndIf
				EndIf
				lCheckFun     := .F.
			EndIf

		EndIf
	Else
		If !lCheckEta
			//De acordo com a utilização do Ponto de Entrada MNTA435G para gravação do código do funcionário padrão
			If Empty(cCodFunc)
				M->TQ_CODFUNC	:= Space( TamSX3('TQ_CODFUNC')[1] )
				cNOMFUNC		:= Space(30)
			Else
				M->TQ_CODFUNC	:= cCodFunc
				dbSelectArea("ST1")
				dbSetOrder(1)
				If dbSeek(xFilial("ST1")+M->TQ_CODFUNC)
					cNOMFUNC		:= ST1->T1_NOME
				EndIf
			EndIf
			lCheckFun     := .F.
		EndIf
	EndIf

	oGetExeSRA:Refresh()
	oGetExeNom:Refresh()
	oGetSeqEta:SetFocus()

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³TudOkTL435³ Autor ³ Denis Hyroshi         ³ Data ³17/07/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Validacao completa do insumo realizado                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function TudOkTL435( nPosSTL )

	Local nInd := 0
	Local nOld := oBrw6:nAt

	If !Empty( oBrw6:aCols[1,1] )

		For nInd := 1 to Len( oBrw6:aCols )

			n := nInd

			If !LinOkTL435()

				nPosSTL := nInd

				Return .F.
			
			EndIf
		
		Next nInd

	EndIf

	// caso tudo correto, reiniciar propriedade que valida se foi alterado utilizada no linok
	oBrw6:lModified := .F.
	oBrw6:GoTo( nOld )

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³LinOkTL435³ Autor ³ Denis Hyroshi         ³ Data ³17/07/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Validacao da linha do insumo realizado                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LinOkTL435()

	Local nXX, nPosSav, nZZ
	Local cOLDALI   := ALIAS()
	Local lPROPLSTL := .F.
	Local nLineOS   := aScan(aDadosOS, {|x|x[1]+x[2] == cOrdemTJ+cPlanoTJ })
	Local nOperacao := 1 //1-Incluir, 2-Alterar ou 3-Visualizar
	Local nPosTL    := n 
	Local lAltGara  := .F.
	Local lBaixaEst := .T. // Variável para bloqueio de movimentação do estoque - Ponto de Entrada MNT4356
	Local lMNTA435O	:= ExistBlock("MNTA435O")
	Local aVetSTL 	:= {}
	Local lVerDt    := !(STJ->TJ_SERVICO == 'HISTOR' .And. cUIntHis == 'N')
	Local cFornec	:= ''
	Local cLoja		:= ''

	Local nPos03    := GDFieldPos( 'TL_CODIGO', oBrw6:aHeader )

	nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DESTINO"})
	nPos04 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_UNIDADE"})
	nPos05 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	nPos06 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	nPos07 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOINICI"})
	nPos08 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"  })
	nPos09 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOFIM"  })
	nPos10 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	nPos11 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})
	nPos12 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})
	nPos13 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCALIZ"})
	nPos14 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSERI"})
	nPos15 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_GARANTI"})
	nPos16 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA" })
	nPos18 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	nPos19 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSEQ" })
	nPos20 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_MOEDA"  })
	nPos21 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CUSTO"  })
	nPos22 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANREC"})
	nPos23 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NOMTAR" })
	nPos24 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_ETAPA"  })
	nPos26 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAPLI"})
	nPos27 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NOTFIS"})
	nPos28 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SERIE"})
	nPos29 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_FORNEC"})
	nPos30 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOJA"})

	If nPos29 > 0

		cFornec := aCols[ n, nPos29 ]

	EndIf

	If nPos30 > 0

		cLoja := aCols[ n, nPos30 ]

	EndIf

	//If !lClearData .And. aCols[n, nPos18] != Padr('0', TamSx3('TL_SEQRELA')[1], ' ') .And. Val(aCols[n, nPos18]) == 0
	//	Help( NIL, 1, STR0174, NIL, STR0398, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0399} ) // "ATENÇÃO"###"A ordem de serviço chegou ao limite temporário de 999 insumos realizados, para continuar reportando insumos realizados crie uma nova ordem de serviço."###"Estamos atuando em melhorias para aumentar o limite de insumos realizados."
	//	Return .F.
	//EndIf

	If FWIsInCallStack( 'F435NEXT' ) .Or. FWIsInCallStack( 'FPRGNEXT' )

		/*--------------------------------------------------------------------------------------------------------------------------+
		| Ao passar um insumo de previsto para realizado, não deve-se executar o linhaOk, pois esse valid. é feito em outro momento |
		+--------------------------------------------------------------------------------------------------------------------------*/
		Return .T.

	EndIf

	If nPos03 == 0
		n := oBrw6:oBrowse:nAt
		aHeader := aClone( aHoBrw6 )
		aCols   := aClone( aCoBrw6 )
		Return .T.
	EndIf

	// Não realiza processo de validação, caso não possua registro alterado.
	If !oBrw6:lModified
		Return .T.
	EndIf

	If aTail( aCols[n] ) //Nao validar se deletado
		Return .T.
	EndIf

	If Empty(aCols[n,nPos01])
		MsgInfo(STR0119,STR0037) //"O campo Tipo Insumo é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf
	If Empty(aCols[n,nPos03])
		MsgInfo(STR0120,STR0037) //"O campo Código Insumo é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf
	If Empty(aCols[n,nPos16])
		MsgInfo(STR0121,STR0037) //"O campo Tarefa é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf
	If aCols[n,nPos01] == 'F' .AND. aCols[n,nPos22] == 0
		MsgInfo(STR0381,STR0037) //"O campo Quant. Rec. é obrigatório."###"ATENÇÃO"
		Return .F.
	Endif
	If Empty(aCols[n,nPos06])
		MsgInfo(STR0123,STR0037) //"O campo Data Início é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf
	If Empty(aCols[n,nPos07])
		MsgInfo(STR0124,STR0037) //"O campo Hora Início é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf
	If aCols[n,nPos06] > dDataBase
		MsgInfo(STR0125,STR0037) //"O campo Data Início não pode ser maior do que a data atual."###"ATENÇÃO"
		Return .F.
	EndIf
	If aCols[n,nPos08] > dDataBase
		MsgInfo(STR0126,STR0037) //"O campo Data Fim não pode ser maior do que a data atual."###"ATENÇÃO"
		Return .F.
	EndIf

	//Validação do preenchimento do campo TL_LOCAPLI, quando obrigatório
	If nPos26 > 0 .And. Empty(aCols[n,nPos26]) .And. X3Obrigat(aHoBrw2[nPos26][2])
		MsgInfo(STR0357,STR0037) //"O campo Local de Aplicação é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf

	// Valida obrigatoriedade do campo GARANTIA
	If nPos15 > 0 .And. Empty( aCols[ n, nPos15 ] ) .And. X3Obrigat( aHoBrw2[ nPos15, 2 ] )
		MsgInfo( STR0385 , STR0037) //###"ATENÇÃO" // "O campo 'Tem Garantia é obrigatório."
		Return .F.
	EndIf

	// Valida se a data de baixa de estoque é maior que a data de bloqueio de estoque (LinOkTL435)
	If nLineOS > 0
		nOperacao := 3 //1-Incluir, 2-Alterar ou 3-Visualizar
		nLinTmp := nPosTL
		nPosSav := aScan(aDadosOS[nLineOS,4] ,{|x|  x[nPos01] == aCols[nLinTmp,nPos01]  .And. ;
		x[nPos03] == aCols[nLinTmp,nPos03] .And. ;
		x[nPos18] == aCols[nLinTmp,nPos18] })
		If nPosSav > 0//Len(aDadosOS[nLineOS,4]) >= nLinTmp
			lAlterou := .F.
			For nZZ := 1 To Len(aDadosOS[nLineOS,4,nPosSav])-2
				//Posições que pode haver alteração sem validação do linha OK , campos Código da tarefa,nome tarefa, destino, garantia e Local de aplicação
				If aCols[ nLinTmp , nZZ ] != aDadosOS[nLineOS,4,nPosSav,nZZ] .And. ;
				( nZZ <> nPos16 .And. nZZ <> nPos23 .And. nZZ <> nPos02 .And. nZZ <> nPos15 .And. nZZ <> nPos26)

					lAlterou := .T.

					Exit
				EndIf
			Next nZZ

			If lAlterou

				nOperacao := 2 //1-Incluir, 2-Alterar ou 3-Visualizar

				// Valida se a data de baixa de estoque é maior que a data de bloqueio de estoque (LinOkTL435)
				If aCols[nLinTmp,nPos01] $ 'P/M' .And. ;
					( aCols[nLinTmp,nPos03] <> aDadosOS[nLineOS,4,nPosSav,nPos03] .Or. ;
					aCols[nLinTmp,nPos10] <> aDadosOS[nLineOS,4,nPosSav,nPos10] .Or. ;
					aCols[nLinTmp,nPos06] <> aDadosOS[nLineOS,4,nPosSav,nPos06] ) .And.;
					lVerDt .And. !MNTValDBl(aCols[n,nPos06])

					Return .F.

				EndIf
			EndIf
		Else
			nOperacao := 1 //1-Incluir, 2-Alterar ou 3-Visualizar
			If aCols[nLinTmp,nPos01] $ 'P/M' .And. lVerDt .And. !MNTValDBl(aCols[n,nPos06])
				Return .F.
			EndIf
		EndIf
	EndIf

	If nPos20 > 0 .And. !( aCols[n,nPos20] $ "1/2/3/4/5" )
		MsgInfo(STR0252,STR0037) //"O campo Moeda é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf

	dbSelectArea('SD1')
	dbSetOrder(1)
	If aCols[n,nPos01] == "P" .And. aCols[n,nPos08] == dDataBase .And. aCols[n,nPos09] > SubS(Time(),1,5) .And. ;
	!dbSeek( xFilial('SD1') + aCols[ n, nPos27 ] + aCols[ n, nPos28 ] + cFornec + cLoja + ;
	IIF( aCols[ n, nPos01 ] == 'T', NGProdMNT('T')[1], aCols[ n, nPos03 ] ) )
		MsgInfo(STR0245,STR0037)
		Return .F.
	EndIf
	//verifica qual é a operação da linha nOperacao := 1-Incluir, 2-Alterar ou 3-Visualizar
	If nLineOS > 0
		nOperacao := 3 //1-Incluir, 2-Alterar ou 3-Visualizar
		nLinTmp := nPosTL
		nPosSav := aScan(aDadosOS[nLineOS,4] ,{|x|  x[nPos01] == aCols[nLinTmp,nPos01]  .And. ;
		x[nPos03] == aCols[nLinTmp,nPos03] .And. ;
		x[nPos18] == aCols[nLinTmp,nPos18] })
		If nPosSav > 0//Len(aDadosOS[nLineOS,4]) >= nLinTmp
			lAlterou := .F.
			For nXX := 1 To Len(aDadosOS[nLineOS,4,nPosSav])-2
				//Posições que pode haver alteração sem validação do linha OK , campos Código da tarefa,nome tarefa, destino e garantia
				If aCols[ nLinTmp , nXX ] != aDadosOS[nLineOS,4,nPosSav,nXX] .And. ;
				( nXX <> nPos16 .And. nXX <> nPos23 .And. nXX <> nPos02 .And. nXX <> nPos15)

					lAlterou := .T.

					Exit
				EndIf
			Next nXX
			If lAlterou
				nOperacao := 2 //1-Incluir, 2-Alterar ou 3-Visualizar
				If aCols[nLinTmp,nPos01] <> aDadosOS[nLineOS,4,nPosSav,nPos01] .Or. aCols[nLinTmp,nPos03] <> aDadosOS[nLineOS,4,nPosSav,nPos03]
					lAltGara := .T.
				EndIf
			EndIf
		Else
			nOperacao := 1 //1-Incluir, 2-Alterar ou 3-Visualizar
		EndIf
	EndIf

	cOrdem2 := Space(Len(STL->TL_ORDEM))
	cPlano1 := Space(Len(STL->TL_PLANO))
	nSequen := Space(3)
	lRET    := .T.

	M->TL_TIPOREG := aCols[ nPosTL , nPos01 ]
	M->TL_DESTINO := aCols[ nPosTL , nPos02 ]
	M->TL_CODIGO  := aCols[ nPosTL , nPos03 ]
	M->TL_UNIDADE := aCols[ nPosTL , nPos04 ]
	M->TL_LOCAL   := aCols[ nPosTL , nPos05 ]
	M->TL_DTINICI := aCols[ nPosTL , nPos06 ]
	M->TL_HOINICI := aCols[ nPosTL , nPos07 ]
	M->TL_DTFIM   := aCols[ nPosTL , nPos08 ]
	M->TL_HOFIM   := aCols[ nPosTL , nPos09 ]
	M->TL_QUANTID := aCols[ nPosTL , nPos10 ]
	M->TL_NUMLOTE := aCols[ nPosTL , nPos11 ]
	M->TL_LOTECTL := aCols[ nPosTL , nPos12 ]
	M->TL_LOCALIZ := aCols[ nPosTL , nPos13 ]
	M->TL_NUMSERI := aCols[ nPosTL , nPos14 ]
	M->TL_GARANTI := aCols[ nPosTL , nPos15 ]
	M->TL_TAREFA  := aCols[ nPosTL , nPos16 ]
	//Para evitar inconsistência sem o campo "em uso"
	If nPos19 > 0
		M->TL_NUMSEQ := aCols[ nPosTL , nPos19 ]
	Else
		M->TL_NUMSEQ := Space(Len(STL->TL_NUMSEQ))
	EndIf
	M->TL_ETAPA   := aCols[ nPosTL , nPos24 ]

	If nOperacao <> 1
		aVetSTL:= {cOrdemTJ, ;//Ordem
		aDadosOS[nLineOS,4,n,nPos03],;//Funcionário banco
		aDadosOS[nLineOS,4,n,nPos16],;//Tarefa no banco
		aDadosOS[nLineOS,4,n,nPos24],;//Etapa no banco
		aDadosOS[nLineOS,4,n,nPos06],;//Data Inicial banco
		aDadosOS[nLineOS,4,n,nPos07],;//Hora Inicial banco
		aDadosOS[nLineOS,4,n,nPos08],;//Data Final banco
		aDadosOS[nLineOS,4,n,nPos09],;// Hora Final banco
		M->TL_CODIGO,;		//Código do Funcionário memória
		M->TL_TAREFA,;		//Código da Tarefa na memória
		M->TL_ETAPA,;		//Código da Etapa memória
		M->TL_DTINICI,;		//Data Inicial na memória
		M->TL_HOINICI,;		//Hora Inicial na memória
		M->TL_DTFIM,;		//Data Final na memória
		M->TL_HOFIM}		//Hora Final na memória
	EndIf

	//Critica se houve alteração da data ou hora e o se apontamento foi realizado pelo apontamento de MDO - MNTA422
	If nOperacao <> 1 	.And. aDadosOS[nLineOS,4,n,nPos01] == "M" ;
	.And. !NGVLDSTL2(aVetSTL)
		Return .f.
	EndIf

	//Validação do campo quantidade vazio
	If Empty(aCols[n,nPos10])
		//Nao validar se datainicio+horainicio e datafim+horafim são iguais (quando a inclusão foi realizada pelo apontamento de MDO - MNTA422)
		If .Not. (nOperacao <> 1 .And. aDadosOS[nLineOS,4,n,nPos01] == "M" ;
		.And. DtoS(aVetSTL[5]) + aVetSTL[6] == DtoS(aVetSTL[7]) + aVetSTL[8]; //verifica se DtInicio+Hrinicio e DataFim+HrFim são iguais
		.And. DtoS(aVetSTL[5]) + aVetSTL[6] == DtoS(aVetSTL[12]) + aVetSTL[13]; //Verifica se DtInicio+HrInicio getDados são iguais a DtInicio+HrInicio do banco
		.And. DtoS(aVetSTL[7]) + aVetSTL[8] == DtoS(aVetSTL[14]) + aVetSTL[15] )  // //Verifica se DtFim+HrFim getDados são iguais a DtFim+HrFim do banco

			MsgInfo(STR0122,STR0037) //"O campo Quantidade é obrigatório."###"ATENÇÃO"
			Return .F.
		EndIf
	EndIf

	If M->TL_TIPOREG == "P"

		If Empty(M->TL_DESTINO)
			Help("",1,"DESTINO")
			Return .F.
		EndIf

		cUNPROD := NGSEEK("SB1",M->TL_CODIGO,1,"B1_UM")
		If Alltrim(cUNPROD) <> Alltrim(M->TL_UNIDADE)
			Help("",1,"UNIDADE")
			Return .F.
		EndIf

		// QUANDO INTEGRADO COM O MÓDULO DE ESTOQUE.
		If cUsaInt3  == "S"

			//Verifica se o produto tem no almoxarifado
			If !NGPROALM(M->TL_CODIGO,M->TL_LOCAL)
				Return .F.
			EndIf

			//Verifica data de fechamento do estoque
			//1-Incluir, 2-Alterar ou 3-Visualizar
			If ( nOperacao == 1 .Or. nOperacao == 2 ) .And. lVerDt .And. !NGCHKMESFE(M->TL_DTINICI,M->TL_TIPOREG)
				Return .F.
			EndIf

			// VALIDA SE O PRODUTO NO LOCAL INFORMADO ENCONTRA-SE EM PROCESSO DE INVENTÁRIO.
			If BlqInvent( M->TL_CODIGO, M->TL_LOCAL )

				Help( '', 1, 'BLQINVENT' )
				Return .F.

			EndIf

		EndIf
	Else
		If M->TL_TIPOREG == "M"

			If !NGFUNCRH(M->TL_CODIGO,.T.,M->TL_DTFIM)
				Return .F.
			EndIf

			//Verifica data de fechamento do estoque
			If nOperacao == 1 .Or. nOperacao == 2 //1-Incluir, 2-Alterar ou 3-Visualizar

				If lVerDt .And. !NGCHKMESFE(M->TL_DTINICI,M->TL_TIPOREG)
					Return .F.
				EndIf

				//Se possuir o PE e integração ao estoque deverá validar
				If lMNTA435O .And. cUsaInt3 == 'S'

					//Se o P.E. retornar .F. e se a chave atual nao esteja relacionada como bloqueio.
					//não deverá realizar a baixa no estoque, sendo assim deverá ser adicionada no aNBaixaEst
					If !ExecBlock("MNTA435O",.F.,.F.,{ aCols[n], aHoBrw2 }) .And. ;
							MNT435CANB(cOrdemTJ + cPlanoTJ + aCols[n,nPos18] + aCols[n,nPos16] + aCols[n,nPos01] + aCols[n,nPos03])
						aAdd(aNBaixaEst,{cOrdemTJ,; 		 //TL_ORDEM
						cPlanoTJ,;			 //TL_PLANO
						aCols[n,nPos18] ,;	 //TL_SEQRELA
						aCols[n,nPos16] ,;	 //TL_TAREFA
						aCols[n,nPos01] ,;	 //TL_TIPOREG
						aCols[n,nPos03] })	 //TL_CODIGO
					EndIf
				EndIf
			EndIf
		EndIf
		If !Empty( M->TL_UNIDADE ) .And. !( Alltrim(M->TL_UNIDADE) $ "MHDS" )
			Help("",1,"UNIDADE")
			Return .F.
		EndIf

		//Validação para que não permita que seja 'gatilhado' Hora Fim superior à Hora atual
		dbSelectArea('SD1')
		dbSetOrder(1)
		If dDataBase == aCols[ nPosTL , nPos08 ] .And. !Empty(M->TL_HOFIM) .And. !Empty(aCols[ nPosTL , nPos07 ]) .And. ;
		 HTOM(aCols[ nPosTL , nPos09 ]) > HTOM(Substr(Time(),1,5)) .And. !dbSeek( xFilial('SD1') + aCols[ n, nPos27 ] + ;
		 aCols[ n, nPos28 ] + cFornec + cLoja + IIF( aCols[ n, nPos01 ] == 'T', ;
		 NGProdMNT('T')[1], aCols[ n, nPos03 ] ) )
			MsgStop(STR0352) //"Hora fim não pode ser maior que a hora atual."
			Return .F.
		EndIf
	EndIf

	If nOperacao == 1 .Or. nOperacao == 2 //1-Incluir, 2-Alterar ou 3-Visualizar
		If M->TL_TIPOREG $ "M/F"
			lPROPLSTL := !f435VlFun(M->TL_CODIGO,cOrdemTJ,cPlanoTJ,M->TL_DTINICI,M->TL_HOINICI,M->TL_DTFIM,M->TL_HOFIM,nLineOS,n,M->TL_TIPOREG,.T.)
			If lPROPLSTL
				Return .F.
			EndIf
		EndIf
	EndIf

	// Verifica se o estoque(SB2) podera ficar negativo
	dbSelectArea("STL")
	If M->TL_TIPOREG == "P"  .And. (nOperacao == 1 .Or. nOperacao == 2) //1-Incluir, 2-Alterar ou 3-Visualizar

		If !NG435VLIM()
			Return .F.
		EndIf

		If cUsaInt3  == "S"

			If cUIntHis == 'N' .And. Alltrim(NGSEEK( "STJ", cOrdemTJ + cPlanoTJ, 1, "TJ_SERVICO")) == 'HISTOR'
				lBaixaEst := .F.
			EndIf
			// Ponto de Entrada destinado ao possivel bloqueio da baixa do estoque
			If ExistBlock("MNTA4356")
				lBaixaEst := ExecBlock("MNTA4356",.F.,.F.)
			EndIf

			If lBaixaEst
				If !lESTNEGA
					dbSelectArea("SB2")
					dbSetOrder(1)
					If !dbSeek(xFilial("SB2") + M->TL_CODIGO + M->TL_LOCAL)
						MsgInfo(STR0127+M->TL_CODIGO+STR0128+M->TL_LOCAL,STR0037) //"Produto "###" não cadastrado no almoxarifado "###"ATENÇÃO"
						dbSelectArea(cOLDALI)
						Return .F.
					EndIf

					If !NGSALDOES(M->TL_CODIGO,M->TL_LOCAL,M->TL_QUANTID,.T.,nLineOS,1,,,,,M->TL_DTINICI)
						dbSelectArea(cOLDALI)
						Return .F.
					EndIf

					//Adiciona o Produto+Local na lista para checar o estoque na gravacao dos dados
					If aScan( aProd435 ,{|x| x[1]+x[2] == M->TL_CODIGO+M->TL_LOCAL }) == 0
						aAdd( aProd435 , { M->TL_CODIGO , M->TL_LOCAL , M->TL_DTINICI } )
					EndIf

				EndIf
				//Valida saldo(SB8) de controle de rastreabilidade por lote do produto
				If Rastro(M->TL_CODIGO)
					If Rastro(M->TL_CODIGO,"S")
						If !NGIFDBSEEK( "SD1" , M->TL_NUMSEQ , 4 , .F. )
							//Valida o sub-lote
							If Empty(M->TL_NUMLOTE)
								Help(" ",1,"NGATENCAO",,STR0129,3,1) //"Numero do sub-lote não informado"
								Return .F.
							Else

								If !NGSALDOES(M->TL_CODIGO,M->TL_LOCAL,M->TL_QUANTID,.T.,nLineOS,2,M->TL_LOTECTL,M->TL_NUMLOTE,nil,nil,M->TL_DTINICI)
									dbSelectArea(cOLDALI)
									Return .F.
								EndIf

								//Adiciona no Array para validar saldo de Sub-Lote
								If aScan( aSubL435 ,{|x| x[1]+x[2]+x[3]+x[4] == M->TL_CODIGO+M->TL_LOCAL+M->TL_LOTECTL+M->TL_NUMLOTE }) == 0
									aAdd( aSubL435 , { M->TL_CODIGO , M->TL_LOCAL , M->TL_LOTECTL , M->TL_NUMLOTE } )
								EndIf
							EndIf
						EndIf
					ElseIf Rastro( M->TL_CODIGO , "L" ) //Valida saldo(SB8) de controle de rastreabilidade por lote do produto
						If !NGIFDBSEEK( "SD1" , M->TL_NUMSEQ , 4 , .F. )
							//Valida o lote
							If Empty(M->TL_LOTECTL)
								Help(" ",1,"NGATENCAO",,STR0130,3,1) //"Numero do lote não informado"
								Return .F.
							Else

								If !NGSALDOES(M->TL_CODIGO,M->TL_LOCAL,M->TL_QUANTID,.T.,nLineOS,3,M->TL_LOTECTL,M->TL_NUMLOTE,nil,nil,M->TL_DTINICI)
									dbSelectArea(cOLDALI)
									Return .F.
								EndIf

								//Adiciona no Array para validar saldo de Lote
								If aScan( aLote435 ,{|x| x[1]+x[2]+x[3] == M->TL_CODIGO+M->TL_LOCAL+M->TL_LOTECTL }) == 0
									aAdd( aLote435 , { M->TL_CODIGO , M->TL_LOCAL , M->TL_LOTECTL } )
								EndIf

							EndIf

						EndIf
					EndIf

					//Validacao do LOCALIZACAO
					//Verifica se ha problema na habilitacao do controle por enderecamento fisico
					If !Empty(M->TL_LOCALIZ) .Or. !Empty(M->TL_NUMSERI)
						If !LOCALIZA( Padr( M->TL_CODIGO, TAMSX3("B1_COD")[1] ) ) //LOCALIZA(Trim(M->TL_CODIGO))
							MsgInfo(STR0131+chr(13)+STR0132,; //"O parâmetro MV_LOCALIZ esta desativado ou o campo"###" B1_LOCALIZ do produto esta preenchido com N."
							STR0133) //"NAO CONFORMIDADE"
							Return .F.
						EndIf
					EndIf

				Else
					// Se não existir rastreabilidade e existir endereçamento para o campo.
					If Rastro( M->TL_CODIGO , "N" ) .And. RetFldProd(SB1->B1_COD,"B1_LOCALIZ") == "S"
						If Empty( M->TL_NUMSEQ )
							If Empty(M->TL_LOCALIZ) .And. Empty(M->TL_NUMSERI)
								Help(" ",1,"LOCALIZOBR")
								Return .F.
							ElseIf Empty(M->TL_LOCALIZ)
								Help(" ",1,"LOCALIZOBR")
								Return .F.
							EndIf
						EndIf
					EndIf
				EndIf
			Else
				// Caso a chave atual nao esteja relacionada como bloqueio. Adiciona a mesma ao array correspondente.
				If MNT435CANB(cOrdemTJ + cPlanoTJ + aCols[n,nPos18] + aCols[n,nPos16] + aCols[n,nPos01] + aCols[n,nPos03])
					aAdd(aNBaixaEst,{cOrdemTJ,; 		 //TL_ORDEM
					cPlanoTJ,;			 //TL_PLANO
					aCols[n,nPos18] ,;	 //TL_SEQRELA
					aCols[n,nPos16] ,;	 //TL_TAREFA
					aCols[n,nPos01] ,;	 //TL_TIPOREG
					aCols[n,nPos03] })	 //TL_CODIGO
				EndIf
			EndIf

			If LOCALIZA( Padr( M->TL_CODIGO, TAMSX3("B1_COD")[1] ) ) .And. !lESTNEGA //LOCALIZA(M->TL_CODIGO)
				//Valida a obrigatoriedade de informar o enderecamento fisico se o produto tem o controle
				dbSelectArea( "SD1" ) //Itens das NF de Entrada.
				dbSetOrder( 09 ) //D1_FILIAL+D1_ORDEM+D1_COD
				If !dbSeek( xFilial( "SD1" )+ cOrdemTJ + M->TL_CODIGO ) //Se não vier do documento de Entrada - (Compras)
					If Empty(M->TL_LOCALIZ) .And. Empty(M->TL_NUMSERI)
						Help(" ",1,"LOCALIZOBR")
						Return .F.
					ElseIf Empty(M->TL_LOCALIZ)
						Help(" ",1,"LOCALIZOBR")
						Return .F.
					EndIf
				EndIf

				If !Empty(M->TL_LOCALIZ)
					If !EXISTCPO("SBE",M->TL_LOCAL+M->TL_LOCALIZ)
						Return .F.
					EndIf
				EndIf
				//Verifica a obrigatoriedade da quantidade do insumo quando informado a serie
				If !MtAvlNSer(M->TL_CODIGO,M->TL_NUMSERI,M->TL_QUANTID)
					Return .F.
				EndIf
				If !Empty(M->TL_LOCALIZ) .Or. !Empty(M->TL_NUMSERI)

					If !NGSALDOES(M->TL_CODIGO,M->TL_LOCAL,M->TL_QUANTID,.T.,nLineOS,4,M->TL_LOTECTL,M->TL_NUMLOTE,M->TL_LOCALIZ,M->TL_NUMSERI)
						dbSelectArea(cOLDALI)
						Return .F.
					EndIf

					//Adiciona no Array para validar saldo de Enderecamento
					If aScan( aEnde435 ,{|x| x[1]+x[2]+x[3]+x[4]+x[5]+x[6] == M->TL_CODIGO+M->TL_LOCAL+;
					M->TL_LOCALIZ+M->TL_NUMSERI+M->TL_LOTECTL+M->TL_NUMLOTE }) == 0
						aAdd( aEnde435 , { M->TL_CODIGO , M->TL_LOCAL , M->TL_LOCALIZ , M->TL_NUMSERI , M->TL_LOTECTL , M->TL_NUMLOTE } )
					EndIf

				EndIf
			EndIf
		EndIf
	EndIf

	If nOperacao == 2
		If lAltGara
			fNgGar435("A")
		EndIf
	EndIf

	If M->TL_GARANTI == "S" .And. nOperacao <> 5
		fChkGaran()
	EndIf

	If M->TL_TIPOREG == "M"
		//Ao executar a mensagem unica é zerado o aCols e a memoria da STL
		aColsSave := aCols

		//Verifica se a mao de obra possui afastamentos no RH
		If !NGFRHAFAST(M->TL_CODIGO,M->TL_DTINICI,M->TL_DTFIM,.T.) .And. (nOperacao == 1 .Or. nOperacao == 2) //1-Incluir, 2-Alterar ou 3-Visualizar
			Return .F.
		EndIf

		//Atualiza saldo e custo do produto relacionado a mão de obra
		If lIntRM

			cProdMDO := MntGetPrdM( M->TL_CODIGO )
			cLocPad  := SuperGetMV( 'MV_NGLOCPA', .F., '01' )
			NGMUStoLvl( cProdMDO, cLocPad, .T., 'M', M->TL_CODIGO )

		EndIf

		aCols := aColsSave

	EndIf

	If nPos21 == 0
		M->TL_CUSTO := Round( NGCALCUSTI( aCols[ nPosTL , nPos03 ] ,aCols[ nPosTL , nPos01 ], aCols[ nPosTL , nPos10 ] , aCols[ nPosTL , nPos05 ] , , , , aCols[ nPosTL ,  nPos22 ], "1" ) , 2 )//Atribui o custo ja tratado, passando sempre ele como 'realizado'
	Else
		If lIntRM .And. ( dDTULMES < aCols[ nPosTL , nPos06 ] )
			aCols[ nPosTL , nPos21 ] := Round( NGCALCUSTI( aCols[ nPosTL , nPos03 ], aCols[ nPosTL , nPos01 ], aCols[ nPosTL , nPos10 ] , aCols[ nPosTL , nPos05 ] , , , , aCols[ nPosTL ,  nPos22 ], "1" ) , 2 )//Atribui o custo ja tratado, passando sempre ele como 'realizado'
		EndIf
		M->TL_CUSTO   := aCols[ nPosTL , nPos21 ]
	EndIf

	/*Ponto de entrada que realiza automaticamente alterações junto aos campos Data/Hora da STL (após o processo de validações).*/
	If ExistBlock( "MNTA435D" )
		ExecBLock( "MNTA435D",.F.,.F.,{ @aCols,aHeader } )
	EndIf
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fChkGaran ³ Autor ³ Denis                 ³ Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Checa a garantia                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fChkGaran()

	dbSelectArea("STJ")
	dbSetOrder(1)
	If msSeek( FWxFilial("STJ") + cOrdemTJ + cPlanoTJ )
		cOrdem := (cAliOS435)->TJ_ORDEM
		cPlano := (cAliOS435)->TJ_PLANO
		MNT400CHKGAR()
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fNgGar435 ³ Autor ³ Denis                 ³ Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Inclusao de garantia para insumo diferente de produto chama³±±
±±³          ³ da a partir do campo garantia                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fNgGar435(cUsa,lValPrev,cGarAnt,strDescIns,strSeqrel,dtTmpIni,dtTmpFim)
	Local nOPGA2 := 0
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_GARANTI"})
	Local nDTI   := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI" })
	Local nDTF   := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM" })
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPos18 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	Local lGrava := .T.
	Local cTitGaran := STR0143 //"Garantia"
	Local cTmpLocal 	:= "" // Usado no ponto de entrada MNTA435A
	Local nTmpQnt	 	:= 0  // Usado no ponto de entrada MNTA435A
	Local cTmpUni		:= "" // Usado no ponto de entrada MNTA435A

	Private nQtde  := 0, nQtdeC := 0
	Private cUni   := " ",cCont := " "
	Default lValPrev := .F.

	lTemCG1 := If(NGSEEK("ST9",cCdBemTJ,1,"T9_TEMCONT") <> "N",.T.,.F.)
	lTemCG2 := If(NGIFDBSEEK("TPE",cCdBemTJ,1,.F.),.T.,.F.)

	aUni     := {" ",STR0144,STR0145,STR0146} //"Dia"###"Semana"###"Mes"
	aCont    := {" ",STR0147,STR0148} //"Contador 1"###"Contador 2"
	cLocaliz := Space(Len(TPS->TPS_CODLOC))
	cNomLoc  := Space(20)

	If lValPrev
		dbSelectArea("TPY")
		dbSetOrder(1)
		If dbSeek(xFilial("TPY")+cCdBemTJ+M->TL_CODIGO)
			cLocaliz := If(Empty(TPY->TPY_LOCGAR),Space(Len(TPS->TPS_CODLOC)),TPY->TPY_LOCGAR)
			M->TL_GARANTI := "S"
			nQtde  := TPY->TPY_QTDGAR
			nQtdeC := If(Empty(TPY->TPY_QTDCON),0,TPY->TPY_QTDCON)

			cUni1  := TPY->TPY_UNIGAR
			If cUni1 == "D"
				cUni := aUni[2]
			ElseIf cUni1 == "S"
				cUni := aUni[3]
			Else
				cUni := aUni[4]
			EndIf
			If !Empty(TPY->TPY_CONGAR)
				If TPY->TPY_CONGAR == "1"
					cCont := aCont[2]
				Else
					cCont := aCont[1]
				EndIf
			EndIf
			If Empty(TPY->TPY_CONGAR) .And. Empty(TPY->TPY_UNIGAR)
				lGrava := .F.
			EndIf
		Else
			lGrava := .F.
		EndIf
		cTitGaran += STR0149 + strDescIns //" - Produto: "
	EndIf

	If M->TL_GARANTI == "S" .And. lGrava

		If aCols[n][nPos01] == "P" .And. ExistBlock("MNTA435A") // Verifica se p insumo e produto e se existe o ponto de entrada
			cTmpLocal	:= ExecBlock("MNTA435A",.F.,.F.,{"L"}) // Retorna o codigo da localizacao
			nTmpQnt	:= ExecBlock("MNTA435A",.F.,.F.,{"Q"}) // Retorna a quantidade - Garantia por Tempo
			cTmpUni	:= ExecBlock("MNTA435A",.F.,.F.,{"U"}) // Retorna a unidade de tempo
			If ValType(cTmpLocal) == "C" // Verifica se o retorno do ponto de entrada e caracter
				If NGLOCGAR(cTmpLocal) // Se existir a localização
					cLocaliz	:= cTmpLocal // Preenche com o codigo retornado pelo ponto de entrada
					cNomLoc	:= NGSeek('TPS',cLocaliz,1,'TPS_NOME') // Preenche com a descricao da localizacao
				EndIf
			EndIf
			If ValType(nTmpQnt) == "N" // Verifica se o retorno do ponto de entrada e numerico
				nQtde := nTmpQnt // Preenche com a quantidade retornada pelo ponto de entrada
			EndIf

			If Valtype(cTmpUni) == "C" // Verifica se o retorno do ponto de entrada e caracter
				cUni	:= cTmpUni // Preenche com a unidade retornada pelo ponto de entrada
			EndIf
		EndIf

			Define Msdialog oDlgTZ From  000,000 To 280,550 Title cTitGaran Pixel

				oPanelGar := TPanel():New(0,0,,oDlgTZ,,,,,,10,10,.F.,.F.)
				oPanelGar:Align := CONTROL_ALIGN_ALLCLIENT

					@ 0.5,.5 To 2.5,34 LABEL STR0153 OF oPanelGar //"Localização"
					@ 20,008 Say Oemtoansi(STR0150) Size 47,07 Of oPanelGar Pixel //"Local"
					@ 20,040 MsGet cLocaliz Size 38,08 Of oPanelGar Pixel Picture "@!" F3 "TPS" Valid NGLOCGAR(cLocaliz) HASBUTTON
					@ 20,100 MsGet oNomLoc Var cNomLoc Of oPanelGar Pixel Picture "@!" When .F. Size 90,08

					@ 3.0,.5 To 5.0,34 LABEL STR0154 OF oPanelGar //"Garantia por Tempo"
					@ 55,008 Say Oemtoansi(STR0151) Size 47,07 Of oPanelGar Pixel //"Qde"
					@ 55,040 MsGet nQtde Size 38,08 Of oPanelGar Pixel Valid Positivo(nQtde) Picture "@E 999,999,999" HASBUTTON
					@ 55,100 Say Oemtoansi(STR0096) Size 47,07 Of oPanelGar Pixel //"Unidade"
					@ 55,132 Combobox cUni Items aUni Size 40,12 OF oPanelGar Pixel Valid NG400CON(cUni,cCont,1,nQtde)

					@ 5.5,.5 To 7.5,34 LABEL STR0155 OF oPanelGar //"Garantia por Contador"
					@ 90,008 Say Oemtoansi(STR0151) Size 47,07 Of oPanelGar Pixel //"Qde"
					@ 90,040 MsGet nQtdeC Size 38,08 Of oPanelGar Pixel Valid positivo(nQtdeC) Picture "@E 999,999,999" When lTemCG1 .Or. lTemCG2  HASBUTTON
					@ 90,100 Say OemtoAnSi(STR0152) Size 47,07 Of oPanelGar Pixel //"Tp Contador"
					@ 90,132 Combobox cCont Items aCont Size 40,12 Of oPanelGar Pixel Valid NG400CON(cUni,cCont,2,nQtdeC) When lTemCG1 .Or. lTemCG2

			Activate MsDialog oDlgTZ On Init EnchoiceBar(oDlgTZ,{||nOPGA2 := 2,If(!MNT400GF(lTemCG1,lTemCG2),nOPGA2 := 1,oDlgTZ:End())},{||oDlgTZ:End()}) CENTERED

		If lValPrev
			If nOPGA2 == 2 .And. ( !Empty(cUni) .Or. !Empty(cCont) )
				fNgGarGrava(cLocaliz,nQtde,cUni,cCont,nQtdeC, "P" , M->TL_CODIGO, strSeqrel, dtTmpIni, dtTmpFim)
			Else
				M->TL_GARANTI := cGarAnt
			EndIf
		Else
			If nOPGA2 == 2 .And. ( !Empty(cUni) .Or. !Empty(cCont) )
				fNgGarGrava(cLocaliz,nQtde,cUni,cCont,nQtdeC, aCols[n][nPos01], aCols[n][nPos03], aCols[n][nPos18], aCols[n][nDTI], aCols[n][nDTF])
			Else
				M->TL_GARANTI := aCols[n][nPos02]
			EndIf
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fNgGarGrava³ Autor ³Denis Hyroshi de Souza³Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Grava a garantia na tabela TPZ                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fNgGarGrava(cLocaliz,nQtde,cUni1,cCont,nQtdeC,cTmpTreg,cTmpCodigo,cTmpSeqrel,dTmpIdt,dTmpFdt)
	Local cSeq_Rel := If(Empty(cTmpSeqrel),"1",cTmpSeqrel)
	Local dDtiniga := If(Empty(dTmpFdt),dTmpIdt,dTmpFdt)
	Local nLineSA

	If cUni1 == STR0144 //"Dia"
		cUni := "D"
	ElseIf cUni1 == STR0145 //"Semana"
		cUni := "S"
	ElseIf cUni1 == STR0146 //"Mes"
		cUni := "M"
	Else
		cUni := " "
	EndIf

	cTmpCG := " "
	If cCont=STR0147 //"Contador 1"
		cTmpCG := "1"
	ElseIf cCont=STR0148 //"Contador 2"
		cTmpCG := "2"
	EndIf

	nLineSA := aScan(aDadosTPZ, {|x| x[2]+x[3]+x[4]+x[5]+x[6] == cTmpTreg+cTmpCodigo+cLocaliz+cOrdemTJ+cPlanoTJ })
	If nLineSA > 0
		If dDtiniga >= aDadosTPZ[nLineSA,10]
			aDadosTPZ[nLineSA,07] := cSeq_Rel
			aDadosTPZ[nLineSA,08] := nQtde
			aDadosTPZ[nLineSA,09] := cuni
			aDadosTPZ[nLineSA,10] := dDtiniga
			aDadosTPZ[nLineSA,11] := cTmpCG
			aDadosTPZ[nLineSA,12] := nQtdeC
		EndIf
	Else
		nLineSA := aScan(aDadosTPZ, {|x| x[2]+x[3]+x[5]+x[6] == cTmpTreg+cTmpCodigo+cOrdemTJ+cPlanoTJ .And. x[7] == cSeq_Rel })
		If nLineSA > 0
			aDadosTPZ[nLineSA,04] := cLocaliz
			aDadosTPZ[nLineSA,08] := nQtde
			aDadosTPZ[nLineSA,09] := cuni
			aDadosTPZ[nLineSA,10] := dDtiniga
			aDadosTPZ[nLineSA,11] := cTmpCG
			aDadosTPZ[nLineSA,12] := nQtdeC
		Else
			aAdd(aDadosTPZ, {;
			cCdBemTJ,; 													//01. TPZ_CODBEM
			cTmpTreg,;		 											//02. TPZ->TPZ_TIPORE
			cTmpCodigo,;	 											//03. TPZ->TPZ_CODIGO
			cLocaliz,; 													//04. TPZ->TPZ_LOCGAR
			cOrdemTJ,; 													//05. TPZ->TPZ_ORDEM
			cPlanoTJ,; 													//06. TPZ->TPZ_PLANO
			cSeq_Rel,;		   											//07. TPZ->TPZ_SEQREL
			nQtde,; 													//08. TPZ->TPZ_QTDGAR
			cuni,; 														//09. TPZ->TPZ_UNIGAR
			dDtiniga,;							 						//10. TPZ->TPZ_DTGARA
			cTmpCG,; 													//11. TPZ->TPZ_CONGAR
			nQtdeC; 													//12. TPZ->TPZ_QTDCON
			})
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fNgGarDelete| Autor ³ Denis               ³ Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Deleta a garantia se nao confirmada a inclusao do insumo   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fNgGarDelete(cOrdem,cPlano,cTL_SEQRELA)

	dbSelectArea("TPZ")
	dbSetOrder(2)
	If dbSeek(xFilial("TPZ")+cOrdem+cPlano+cTL_SEQRELA)
		While !EoF() .And. TPZ->(TPZ_FILIAL+TPZ_ORDEM+TPZ_PLANO+TPZ_SEQREL) == xFilial("TPZ")+cOrdem+cPlano+cTL_SEQRELA
			RecLock("TPZ",.F.)
			DbDelete()
			TPZ->(MsUnLock())
			TPZ->(dbSkip())
		End
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fNgGarUpdate| Autor ³ Denis               ³ Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Altera a data da garantia                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fNgGarUpdate(cOrdem,cPlano,cTL_SEQRELA,dTL_DTINICI)

	dbSelectArea("TPZ")
	dbSetOrder(2)
	If dbSeek(xFilial("TPZ")+cOrdem+cPlano+cTL_SEQRELA) .And. !Empty(dTL_DTINICI)
		While !EoF() .And. TPZ->(TPZ_FILIAL+TPZ_ORDEM+TPZ_PLANO+TPZ_SEQREL) == xFilial("TPZ")+cOrdem+cPlano+cTL_SEQRELA
			RecLock("TPZ",.F.)
			TPZ->TPZ_DTGARA := dTL_DTINICI
			TPZ->(MsUnLock())
			TPZ->(dbSkip())
		End
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fNgGarInsert| Autor ³ Denis               ³ Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Cadastra garantia para o insumo                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fNgGarInsert(nLineSA,cOrdem,cPlano,cTL_SEQRELA,dTL_DTINICI)

	Local lGrava  := .T.
	Local nRecTPZ := 0

	If nLineSA == 0
		Return
	EndIf

	dbSelectArea("TPZ")
	dbSetOrder(1)
	lAchou := dbSeek(xFilial("TPZ")+aDadosTPZ[nLineSA,1]+aDadosTPZ[nLineSA,2]+aDadosTPZ[nLineSA,3]+aDadosTPZ[nLineSA,4]+;
	aDadosTPZ[nLineSA,5]+aDadosTPZ[nLineSA,6])
	If lAchou
		If dTL_DTINICI < TPZ->TPZ_DTGARA
			lGrava := .F.
			nRecTPZ := TPZ->(Recno())
		EndIf
	EndIf
	If lGrava
		RecLock("TPZ",!lAchou)
		If !lAchou
			TPZ->TPZ_FILIAL := xFilial("TPZ")
			TPZ->TPZ_CODBEM := aDadosTPZ[nLineSA,1]
			TPZ->TPZ_TIPORE := aDadosTPZ[nLineSA,2]
			TPZ->TPZ_CODIGO := aDadosTPZ[nLineSA,3]
			TPZ->TPZ_LOCGAR := aDadosTPZ[nLineSA,4]
			TPZ->TPZ_ORDEM  := aDadosTPZ[nLineSA,5]
			TPZ->TPZ_PLANO  := aDadosTPZ[nLineSA,6]
		EndIf
		TPZ->TPZ_SEQREL := aDadosTPZ[nLineSA,7]
		TPZ->TPZ_QTDGAR := aDadosTPZ[nLineSA,8]
		TPZ->TPZ_UNIGAR := aDadosTPZ[nLineSA,9]
		TPZ->TPZ_DTGARA := dTL_DTINICI //aDadosTPZ[nLineSA,10]
		TPZ->TPZ_CONGAR := aDadosTPZ[nLineSA,11]
		TPZ->TPZ_QTDCON := aDadosTPZ[nLineSA,12]
		TPZ->(MsUnLock())
		nRecTPZ := TPZ->(Recno())
	EndIf

	dbSelectArea("TPZ")
	dbSetOrder(2)
	If dbSeek(xFilial("TPZ")+cOrdem+cPlano+cTL_SEQRELA)
		While !EoF() .And. TPZ->(TPZ_FILIAL+TPZ_ORDEM+TPZ_PLANO+TPZ_SEQREL) == xFilial("TPZ")+cOrdem+cPlano+cTL_SEQRELA
			If TPZ->(Recno()) <> nRecTPZ
				RecLock("TPZ",.F.)
				dbDelete()
				TPZ->(MsUnLock())
			EndIf
			TPZ->(dbSkip())
		End
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuno    ³TudOk435PLºAutor  ³ Denis Hyroshi Souzaº Data ³  03/10/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Testa os intervalos aceitaveis de datas e hora para a in-   º±±
±±º          ³clusao de motivos de atraso da O.S                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MNTA435( )                                                  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function TudOk435PL(nPosTPL)
	Local vx

	For vx := 1 To Len(aCols)
		If !LinOk435PL(vx)
			nPosTPL := vx
			Return .F.
		EndIf
	Next vx

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} LinOk435PL
Testa os intervalos aceitaveis de datas e hora para a inclusao de
motivos de atraso da O.S
@author  Denis Hyroshi Souza
@since   03/10/08
@version P12
@use mnta435
/*/
//-------------------------------------------------------------------
Function LinOk435PL(nLinTPL)

    Local nXZ
	Local aVRET     := {}
	Local cMENS     := Space(1)
	Local cMENA     := STR0158 //"nao informada"
    Local cHrIniOs  := STJ->TJ_HORACO1
    Local dDtIniOs  := STJ->TJ_DTORIGI
    Local cOrdem    := STJ->TJ_ORDEM

	Local nPos01 := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_CODMOT"})
	Local nPos02 := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_DTINIC"})
	Local nPos03 := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_HOINIC"})
	Local nPos04 := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_DTFIM" })
	Local nPos05 := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_HOFIM" })
	Local cMOTIVO, dVDTINI, cVHINI, dVDTFIM, cVHFIM

	Local nRowTPL := n

	If ValType(nLinTPL) == "N"
		nRowTPL := nLinTPL
	EndIf

	cMOTIVO := aCols[nRowTPL,nPos01]
	dVDTINI := aCols[nRowTPL,nPos02]
	cVHINI  := aCols[nRowTPL,nPos03]
	dVDTFIM := aCols[nRowTPL,nPos04]
	cVHFIM  := aCols[nRowTPL,nPos05]

	If aCols[nRowTPL,Len(aCols[nRowTPL])] .Or. Empty(aCols[nRowTPL,nPos01]) //Nao validar se deletado ou codigo vazio
		Return .T.
	EndIf

	If Empty(cMENS) .And. Empty(cMOTIVO)
		cMENS := STR0159+cMENA //"Motivo "
	EndIf

	If Empty(cMENS) .And. Empty(dVDTINI)
		cMENS := STR0160+cMENA //"Data Inicio "
	EndIf

	If Empty(cMENS) .And. (Empty(cVHINI) .Or. AllTrim(cVHIni) == ":")
		cMENS := STR0161+cMENA //"Hora inicio "
	EndIf

	If Empty(dVDTFim) .And. AllTrim(cVHFim) <> ":"  .And. Empty(cMens)
		cMens := STR0162 + cMena //"Data Fim"
	EndIf

	If !Empty(dVDTFim) .And. Empty(cVHFim) .And. Empty(cMens)
		cMens := STR0163 + cMena //"Hora Fim"
	EndIf

    If Empty(cMens) .And. dVDTIni < dDtIniOs
        If cVHIni < cHrIniOs
            cMens := STR0363 + cOrdem
        EndIf
        cMens := STR0364 + cOrdem
    EndIf

	If Empty(cMENS) .And. !Empty(dVDTINI) .And. !Empty(dVDTFIM)
		If dVDTFIM < dVDTINI
			cMENS := STR0240  //"Data Inicio devera ser menor ou igual a Data Fim "
		ElseIf dVDTFIM = dVDTINI .And. cVHFIM <= cVHINI
			cMENS := STR0165 //"Hora fim devera ser maior que a hora inicio "
		EndIf
	EndIf

	If Empty(cMENS) .And. !Empty(dVDTINI) .And. !Empty(dVDTFIM)
		If dVDTFIM == dDataBase .And. cVHFIM > SubStr(Time(),1,5)
			cMENS := STR0243
		EndIf
	EndIf

	If !Empty(dVDTFim) .And. !Empty(cVHFim)

		If dVDTFim > dDataBase
			Help(" ", 1, "NGATENCAO",, STR0244, 3, 1)	//"A Data Fim é maior que a Data Atual."
			Return .F.
		EndIf

		If dVDTFim < dVDTINI
			Help(" ", 1, "NGATENCAO",, STR0156 + Chr(13) + Chr(10) + STR0157, 3, 1)	//"A Data Fim não pode ser menor"###" do que a Data Início."
			Return .F.
		EndIf

	EndIf

	If !Empty(cMENS)
		aVRET := {.F.,cMENS}
	Else
		aVRET := {.T.,STR0166} //"Data e hora de avaliacao estao fora do Intervalo"
		For nXZ := 1 To Len(aCols)
			If nXZ == nRowTPL .Or. aCols[nXZ,Len(aCols[nXZ])]
				Loop
			EndIf
			If aCols[nXZ,nPos01] == cMOTIVO .And. aCols[nXZ,nPos02] == dVDTINI .And. ;
			aCols[nXZ,nPos03] == cVHINI .And. aCols[nXZ,nPos04] == dVDTFIM .And. ;
			aCols[nXZ,nPos05] == cVHFIM

				aVRET := {.F.,STR0167} //"Registro informado ja existe"
				Exit
			Else
				If aCols[nXZ,nPos01] == cMOTIVO
					If DtoS(dVDTINI)+cVHINI <= DtoS(aCols[nXZ,nPos04])+aCols[nXZ,nPos05] .And.;
					DtoS(dVDTFIM)+cVHFIM >= DtoS(aCols[nXZ,nPos02])+aCols[nXZ,nPos03]

						aVRET := {.F.,STR0168} //"Ja existe registro dentro do periodo informado"
						Exit
					EndIf
				EndIf
			EndIf
		Next nXZ

	EndIf

	If !aVRET[1]
		MsgInfo(aVRET[2],STR0133) //"NAO CONFORMIDADE"
		Return .F.
	Else
		Return .T.
	EndIf

Return aVRET

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fValidOK   ³ Autor ³ Denis               ³ Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida confirmacao da tela                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fValidOK(lRetTela,lSetFocBt)

	Local nXX, nYY, nZZZ, nEE
	Local lRet := .T.
	Local nPosTip := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPosCod := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPosLoc := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	Local nPosQtd := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	Local nPos02  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	Local nPos03  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOINICI"})
	Local nPos04  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM" })
	Local nPos05  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOFIM" })
	Local nPosSub := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})
	Local nPosLot := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})
	Local nPosEnd := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCALIZ"})
	Local nPosNuS := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSERI"})
	Local cTmpCod,cTmpOrdem,cTmpPlano
	Local cPosAnt := ""
	Local aVRET  := {.F.," "}

	If lSetFocBt
		If !NGLostFocus()
			Return .F.
		EndIf
	EndIf

	If Empty( (cAliOS435)->TJ_CODBEM )
		MsgInfo( STR0405, STR0037 ) // "Não há registros a serem salvos!" ## 'Atenção'
		Return .F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Valida estoque dos produtos              ³
	//ÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//variavel nDiffoS representa, nesse ponto, a diferenca do que havia sido aplicado antes da alteracao
	//e o que está sendo aplicado após alteração
	nDiffOS := 0

	/*-------------------------------------------------------------------------------------------------+
	| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
	+-------------------------------------------------------------------------------------------------*/
	If Len(aProd435) > 0 .And. !lESTNEGA .And. cUsaInt3  == "S" .And. !lHasMNTREQ

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Valida Saldo Lote                        ³
		//ÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRet
			cChvPrAlm := "Nil"
			For nZZZ := 1 To Len(aLote435)
				nDiffOS := 0
				cChvPrAlm := aLote435[nZZZ,1] + aLote435[nZZZ,2] + aLote435[nZZZ,3]
				For nXX := 1 To Len(aDadosOS)
					If ValType(aDadosOS[nXX,4]) == "A" .And. ValType(aDadosOS[nXX,5]) == "A"
						For nYY := 1 To Len(aDadosOS[nXX,4])
							If aDadosOS[nXX,4,nYY,nPosTip] == "P"
								If aDadosOS[nXX,4,nYY,nPosCod]+aDadosOS[nXX,4,nYY,nPosLoc]+aDadosOS[nXX,4,nYY,nPosLot] == cChvPrAlm
									nDiffOS -= aDadosOS[nXX,4,nYY,nPosQtd]
								EndIf
							EndIf
						Next nYY
						For nYY := 1 To Len(aDadosOS[nXX,5])
							If aDadosOS[nXX,5,nYY,Len(aDadosOS[nXX,5,nYY])]
								Loop //Deletado
							EndIf
							If aDadosOS[nXX,5,nYY,nPosTip] == "P"
								If aDadosOS[nXX,5,nYY,nPosCod]+aDadosOS[nXX,5,nYY,nPosLoc]+aDadosOS[nXX,5,nYY,nPosLot] == cChvPrAlm
									nDiffOS += aDadosOS[nXX,5,nYY,nPosQtd]
									cPosAnt := aDadosOS[nXX,1]+aDadosOS[nXX,2]
								EndIf
							EndIf
						Next nYY
					EndIf
				Next nXX

				//Analisa se existe retiradas do estoque na tela e desconta do saldo atual.
				If nDiffOS > 0
					dbSelectArea("SB8")
					dbSetOrder(03)
					If dbSeek(xFilial("SB8")+cChvPrAlm)
						nSaldo:=SaldoLote(aLote435[nZZZ,1],aLote435[nZZZ,2],aLote435[nZZZ,3],NIL,.F.,.T.,NIL,dDataBase)
						If QtdComp(nSaldo) < QtdComp(nDiffOS)
							cHelp:=STR0127+AllTrim(aLote435[nZZZ,1])+chr(13)+STR0169+aLote435[nZZZ,2]+chr(13)+STR0170; //"Produto "###"Local "###"Saldo Disponível "
							+Alltrim(Transform(nSaldo,PesqPictQt("B8_SALDO", 14)))+chr(13)+STR0171+Alltrim(aLote435[nZZZ,3]) //"Lote "
							Help(" ",1,"A240LOTENE",,cHelp,4,1)
							lRet := .F.
						EndIf
					EndIf
				EndIf
				If !lRet
					Exit
				EndIf
			Next nZZZ
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Valida Saldo Sub-Lote                    ³
		//ÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRet
			cChvPrAlm := "Nil"
			For nZZZ := 1 To Len(aSubL435)
				nDiffOS := 0
				cChvPrAlm := aSubL435[nZZZ,1] + aSubL435[nZZZ,2] + aSubL435[nZZZ,3] + aSubL435[nZZZ,4]
				For nXX := 1 To Len(aDadosOS)
					If ValType(aDadosOS[nXX,4]) == "A" .And. ValType(aDadosOS[nXX,5]) == "A"
						For nYY := 1 To Len(aDadosOS[nXX,4])
							If aDadosOS[nXX,4,nYY,nPosTip] == "P"
								If aDadosOS[nXX,4,nYY,nPosCod]+aDadosOS[nXX,4,nYY,nPosLoc]+aDadosOS[nXX,4,nYY,nPosLot]+aDadosOS[nXX,4,nYY,nPosSub] == cChvPrAlm
									nDiffOS -= aDadosOS[nXX,4,nYY,nPosQtd]
								EndIf
							EndIf
						Next nYY
						For nYY := 1 To Len(aDadosOS[nXX,5])
							If aDadosOS[nXX,5,nYY,Len(aDadosOS[nXX,5,nYY])]
								Loop //Deletado
							EndIf
							If aDadosOS[nXX,5,nYY,nPosTip] == "P"
								If aDadosOS[nXX,5,nYY,nPosCod]+aDadosOS[nXX,5,nYY,nPosLoc]+aDadosOS[nXX,5,nYY,nPosLot]+aDadosOS[nXX,5,nYY,nPosSub] == cChvPrAlm
									nDiffOS += aDadosOS[nXX,5,nYY,nPosQtd]
									cPosAnt := aDadosOS[nXX,1]+aDadosOS[nXX,2]
								EndIf
							EndIf
						Next nYY
					EndIf
				Next nXX

				//Analisa se existe retiradas do estoque na tela e desconta do saldo atual.
				If nDiffOS > 0
					dbSelectArea("SB8")
					dbSetOrder(02)
					If dbSeek(xFilial("SB8")+aSubL435[nZZZ,4]+aSubL435[nZZZ,3]+aSubL435[nZZZ,1]+aSubL435[nZZZ,2])
						nSaldoLote := SB8Saldo(.F.,.T.,NIL,NIL,NIL,NIL,NIL,dDataBase)
						If QtdComp(nSaldoLote) < QtdComp(nDiffOS)
							cHelp:=STR0127+AllTrim(aSubL435[nZZZ,1])+chr(13)+STR0169+aSubL435[nZZZ,2]+chr(13)+STR0170; //"Produto "###"Local "###"Saldo Disponível "
							+Alltrim(Transform(nSaldoLote,PesqPictQt("B8_SALDO", 14)))+chr(13)+STR0171+Alltrim(aSubL435[nZZZ,3]); //"Lote "
							+chr(13)+STR0172+Alltrim(aSubL435[nZZZ,4]) //"Sub-lote "
							Help(" ",1,"A240LOTENE",,cHelp,4,1)
							lRet := .F.
						EndIf
					EndIf
				EndIf
				If !lRet
					Exit
				EndIf
			Next nZZZ
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Valida Saldo Enderecamento               ³
		//ÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRet
			cChvPrAlm := "Nil"
			For nZZZ := 1 To Len(aEnde435)
				nDiffOS := 0
				nEmpenho:= 0
				cChvPrAlm := aEnde435[nZZZ,1] + aEnde435[nZZZ,2] + aEnde435[nZZZ,3] + aEnde435[nZZZ,4] + aEnde435[nZZZ,5] + aEnde435[nZZZ,6]
				For nXX := 1 To Len(aDadosOS)
					If ValType(aDadosOS[nXX,3]) == "A" .And. ValType(aDadosOS[nXX,5]) == "A"
						For nEE := 1 To Len(aDadosOS[nXX,3])
							If aDadosOS[nXX,3,nEE,nPosTip] == "P"
								If aDadosOS[nXX,3,nEE,nPosCod] + aDadosOS[nXX,3,nEE,nPosLoc] == aEnde435[nZZZ,1] + aEnde435[nZZZ,2]
									nEmpenho += aDadosOS[nXX,3,nEE,nPosQtd]
									cOPEMP := aDadosOS[nXX,1]+"OS001"
									cOPCOD := aDadosOS[nXX,3,nEE,nPosCod]
								EndIf
							EndIf
						Next nEE
					EndIf
					If ValType(aDadosOS[nXX,4]) == "A" .And. ValType(aDadosOS[nXX,5]) == "A"
						For nYY := 1 To Len(aDadosOS[nXX,4])
							If aDadosOS[nXX,4,nYY,nPosTip] == "P"
								If aDadosOS[nXX,4,nYY,nPosCod]+aDadosOS[nXX,4,nYY,nPosLoc]+aDadosOS[nXX,4,nYY,nPosEnd]+;
								aDadosOS[nXX,4,nYY,nPosNuS]+aDadosOS[nXX,4,nYY,nPosLot]+aDadosOS[nXX,4,nYY,nPosSub] == cChvPrAlm

									nDiffOS -= aDadosOS[nXX,4,nYY,nPosQtd]
								EndIf
							EndIf
						Next nYY
						For nYY := 1 To Len(aDadosOS[nXX,5])
							If aDadosOS[nXX,5,nYY,Len(aDadosOS[nXX,5,nYY])]
								Loop //Deletado
							EndIf
							If aDadosOS[nXX,5,nYY,nPosTip] == "P"
								If aDadosOS[nXX,5,nYY,nPosCod]+aDadosOS[nXX,5,nYY,nPosLoc]+aDadosOS[nXX,5,nYY,nPosEnd]+;
								aDadosOS[nXX,5,nYY,nPosNuS]+aDadosOS[nXX,5,nYY,nPosLot]+aDadosOS[nXX,5,nYY,nPosSub] == cChvPrAlm

									nDiffOS += aDadosOS[nXX,5,nYY,nPosQtd]
									cPosAnt := aDadosOS[nXX,1]+aDadosOS[nXX,2]
								EndIf
							EndIf
						Next nYY
					EndIf
				Next nXX

				//Analisa se existe retiradas do estoque na tela e desconta do saldo atual.
				If nDiffOS > 0
					If QtdComp(SaldoSBF(aEnde435[nZZZ,2],aEnde435[nZZZ,3],aEnde435[nZZZ,1],aEnde435[nZZZ,4],aEnde435[nZZZ,5],;
					aEnde435[nZZZ,6],.F.)) + nEmpenho < QtdComp(nDiffOS)
						Help(" ",1,"SALDOLOCLZ")
						lRet := .F.
					EndIf
				EndIf
				If !lRet
					Exit
				EndIf
			Next nZZZ
		EndIf

	EndIf

	//Valida as etapas
	If lRet
		lRet := MNTA435EFI()
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Valida mao de obra alocada no mesmo horario
	//ÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet
		For nXX := 1 To Len(aDadosOS)
			If aVRET[1]
				Exit
			EndIf
			If ValType(aDadosOS[nXX,5]) == "A" //Se [insumos realizados] foi editado pelo usuario
				For nYY := 1 To Len(aDadosOS[nXX,5])
					If aVRET[1]
						Exit
					EndIf
					If aDadosOS[nXX,5][nYY,Len(aDadosOS[nXX,5][nYY])]
						Loop //Deletado
					EndIf
					cTmpCod   := aDadosOS[nXX,5,nYY,nPosCod]
					cTmpOrdem := aDadosOS[nXX,1]
					cTmpPlano := aDadosOS[nXX,2]
					cTmpTipoR := aDadosOS[nXX,5,nYY,nPosTip]
					lPROPLSTL := f435VlFun(cTmpCod,cTmpOrdem,cTmpPlano,aDadosOS[nXX,5][nYY,nPos02],aDadosOS[nXX,5][nYY,nPos03],;
					aDadosOS[nXX,5][nYY,nPos04],aDadosOS[nXX,5][nYY,nPos05],nXX,nYY,cTmpTipoR,.F.)
					If !lPROPLSTL
						aVRET := {.T.,STR0167} //"Registro informado ja existe"
						cPosAnt := aDadosOS[nXX,1]+aDadosOS[nXX,2]
					EndIf
				Next nYY
			EndIf
		Next nXX
		If aVRET[1]
			lRet := .F.
			PutFileInEof("STL")
		EndIf
	EndIf

	//---------------------------------------------------------------
	//Realiza chamada do ponto de entrada para validações adicionais
	//---------------------------------------------------------------
	If lRet .And. lPEMNTA435
		lRet := ExecBlock( "MNTA435N", .F., .F., { "VALID_CONFIRM", aDadosOS } )
	EndIF

	lRetTela := .T.

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NG435VLim
Valida a quant. limite do produto referente a peças de reposição.
@type Function

@author Dênis
@since  02/12/2003

@param 	aCabec , array, Cabeçalho do GetDados que origina a chamada.
@return boolean, Indica se o contéudo informado é valido.
/*/
//---------------------------------------------------------------------
Function NG435VLim( aCabec )

	Local nPos01   := 0
	Local nPos02   := 0

	Default aCabec := aClone( aHoBrw2 )

	nPos01 := GDFieldPos( 'TL_TIPOREG', aCabec )
	nPos02 := GDFieldPos( 'TL_CODIGO' , aCabec )

	If cVALPECRE == "S"

		If aCols[n][nPos01] == "P"

			If !NGCHKLIMP(STJ->TJ_CODBEM,aCols[n][nPos02],M->TL_QUANTID)

				Return .F.

			EndIf

		EndIf

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGProd435
Valida código do insumo.
@type Function

@author Dênis
@since  06/09/2001

@param 	aCabec , array, Cabeçalho do GetDados que origina a chamada.
@return boolean, Indica se o contéudo informado é valido.
/*/
//---------------------------------------------------------------------
Function NGProd435( aCabec )

	Local nPos01   := 0
	Local nPos04   := 0
	Local nPos05   := 0
	Local nPos11   := 0
	Local nPos12   := 0
	Local nPos13   := 0
	Local nPos14   := 0
	Local nPos99   := 0
	Local nPos98   := 0
	Local aAINSUMO := {}
	Local cCodTer  := ''
	Local _RET     := .T. 
	Local cHelp    := ''
	Local OldAli   := Alias()
	Local cCODSTL
	Local nDesLoja := 0

	Default aCabec := aClone( aHoBrw2 )

	nPos01   := GDFieldPos( 'TL_TIPOREG', aCabec )
	nPos04   := GDFieldPos( 'TL_UNIDADE', aCabec )
	nPos05   := GDFieldPos( 'TL_LOCAL'  , aCabec )
	nPos11   := GDFieldPos( 'TL_NUMLOTE', aCabec )
	nPos12   := GDFieldPos( 'TL_LOTECTL', aCabec )
	nPos13   := GDFieldPos( 'TL_LOCALIZ', aCabec )
	nPos14   := GDFieldPos( 'TL_NUMSERI', aCabec )
	nPos99   := GDFieldPos( 'TL_DTVALID', aCabec )
	nPos98   := GDFieldPos( 'TL_NOMCODI', aCabec )

	aAINSUMO := NGNOMINSUM( aCOLS[n][nPos01],M->TL_CODIGO,20)

	// Tratativa para valor default quando não informado o campo TL_TIPOREG.
	aCols[n,nPos01] := IIf( Empty( aCols[n,nPos01] ), 'M', aCols[n,nPos01] )

	// Repasse do valor default para a memória do campo.
	M->TL_TIPOREG   := aCols[n,nPos01]

	// Testa o tamanho do campo para nao permitir informar codigo invalido
	If aCOLS[n][nPos01] == "M"  //Mao de obra
		If Len(Alltrim(M->TL_CODIGO)) > Len(ST1->T1_CODFUNC)
			_RET  := .F.
			cHelp := "FUNCNEXIST"
		EndIf
	ElseIf aCOLS[n][nPos01] == "T"  //Terceiros
		If Len(Alltrim(M->TL_CODIGO)) > Len(SA2->A2_COD)
			_RET := .F.
			cHelp := "TERCNEXIST"
		EndIf
	ElseIf aCOLS[n][nPos01] == "F"  //Ferramenta
		If Len(Alltrim(M->TL_CODIGO)) > Len(SH4->H4_CODIGO)
			_RET := .F.
			cHelp := "FERRNEXIS"
		EndIf
	ElseIf aCOLS[n][nPos01] == "P"  //Produto
		If Len(Alltrim(M->TL_CODIGO)) > Len(SB1->B1_COD)
			_RET := .F.
			cHelp := "PRODNEXIST"
		EndIf
	EndIf

	If !_RET
		Help(" ",1,cHelp)
		dbSelectArea(OldAli)
		Return .F.
	EndIf

	If aCOLS[n][nPos01] == "P"  //Produto
		cCODSTL := Substr(M->TL_CODIGO,1,Len(SB1->B1_COD))
		If !NGPRODESP( cCODSTL )
			Return .F.
		EndIf

		//Não permite selecionar um produto 'bloqueado'
		If !Empty(M->TL_CODIGO)
			If !EXISTCPO("SB1",M->TL_CODIGO)
				Return .F.
			EndIf
		EndIf
	EndIf

	//Devido ao fato de não existir na tabela STL um campo correspondente a A2_LOJA, as validações abaixo devem ser feitas
	//para diferenciar Fornecedores com o mesmo código e lojas diferentes.
	cCodTer := Padr( M->TL_CODIGO, Len( SA2->A2_COD ) )
	If aCOLS[n][nPos01] == 'T' .AND. !Empty( M->TL_CODIGO )
		If cCodTer == SA2->A2_COD //Quando é acionado o F3
			If !ExistCpo( "SA2", cCodTer + SA2->A2_LOJA ) //Terceiros
				Return .F.
			ElseIf dbSeek( xFilial('SA2') + cCodTer + SA2->A2_LOJA )
				aCols[n][nPos98] := SA2->A2_NOME
				nDesLoja := 1
			EndIf
		Else //Quando é digitado
			DbSelectArea('SA2')
			DbSetOrder(1)
			DbSeek( xFilial('SA2') + cCodTer )
			If !ExistCpo( "SA2", cCodTer + SA2->A2_LOJA )
				Return .F.
			Endif
		Endif
	Endif

	If Empty(aAINSUMO[1][2])
		MsgInfo(STR0173,STR0174) //"Insumo nao cadastrado"###"ATENCAO"
		Return .F.
	Else
		If nDesLoja == 0
			aCols[n][nPos98] := aAINSUMO[1][2]
		Endif
		If acols[n][nPos01] = "P"
			aCols[n][nPos04] := NGSEEK("SB1",M->TL_CODIGO,1,"B1_UM")
			dbSelectArea("STJ")
			dbSetOrder(1)
			dbSeek(xFilial("STJ")+cOrdemTJ+cPlanoTJ)
			aCols[n][nPos05] := NGALMOXA(STJ->TJ_CODBEM,M->TL_CODIGO,aCols[n][nPos01],.T.)
			//Zera os campos de controle de rastreabilidade quando for trocado o codigo do produto
			If nPos12 > 0 .And. nPos11  > 0 .And. nPos99 > 0
				If !Empty(aCOLS[n][nPos12]) .Or. !Empty(aCOLS[n][nPos11]) .Or. !Empty(aCOLS[n][nPos99]);
				.Or. !Empty(aCOLS[n][nPos13]) .Or. !Empty(aCOLS[n][nPos14])
					aCOLS[n][nPos12] := Space(Len(STL->TL_LOTECTL))
					aCOLS[n][nPos11] := Space(Len(STL->TL_NUMLOTE))
					aCOLS[n][nPos99] := CTOD("  /  /  ")
					aCOLS[n][nPos13] := Space(Len(STL->TL_LOCALIZ))
					aCOLS[n][nPos14] := Space(Len(STL->TL_NUMSERI))
				EndIf
			Else
				If !Empty(M->TL_LOTECTL) .Or. !Empty(M->TL_NUMLOTE) .Or. !Empty(M->TL_DTVALID);
				.Or. !Empty(M->TL_LOCALIZ) .Or. !Empty(M->TL_NUMSERI)
					M->TL_LOTECTL := Space(Len(STL->TL_LOTECTL))
					M->TL_NUMLOTE := Space(Len(STL->TL_NUMLOTE))
					M->TL_DTVALID := CTOD("  /  /  ")
					M->TL_LOCALIZ := Space(Len(STL->TL_LOCALIZ))
					M->TL_NUMSERI := Space(Len(STL->TL_NUMSERI))
				EndIf
			EndIf
		Else
			aCols[n][nPos04] := "H"
			lTipo := .F.
		EndIf
	EndIf

	MV_PAR01 := STJ->TJ_CODBEM
	MV_PAR02 := STJ->TJ_SERVICO
	MV_PAR05 := STJ->TJ_SEQRELA
	cPar01   := MV_PAR01
	cPar02 	 := MV_PAR02
	cPar05   := MV_PAR05

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGQuant435
Pre-consistencia da quantidade do insumo.
@type Function

@author Dênis
@since  10/02/2004

@param 	aCabec , array, Cabeçalho do GetDados que origina a chamada.
@return boolean, Indica se o contéudo informado é valido.
/*/
//---------------------------------------------------------------------
Function NGQuant435( aCabec )

	Local nPos01   := 0
	Local nPos02   := 0

	Default aCabec := aClone( aHoBrw2 )

	nPos01 := GDFieldPos( 'TL_TIPOREG', aCabec )
	nPos02 := GDFieldPos( 'TL_UNIDADE', aCabec )

	If !NaoVazio( M->TL_QUANTID ) .Or. !Positivo()

		Return .F.

	EndIf

	If !NGVALQUANT(aCols[n,nPos01],aCols[n,nPos02],M->TL_QUANTID)

		Return .F.

	EndIf

	If !NG435VLIM( aCabec )

		Return .F.

	EndIf

	If !NGCALDTHO()

		Return .F.

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG435DtIni
Valida a data inicio.
@type Function

@author Dênis
@since  06/09/2001

@param 	aCabec , array, Cabeçalho do GetDados que origina a chamada.
@return boolean, Indica se o contéudo informado é valido.
/*/
//---------------------------------------------------------------------
Function NG435DtIni( aCabec )

	Local nPos01   := 0
	Local nPos02   := 0
	Local nPos03   := 0
	Local nPos04   := 0
	Local lVerDt   := !( STJ->TJ_SERVICO == 'HISTOR' .And. cUIntHis == 'N' )

	Default aCabec := aClone( aHoBrw2 )

	nPos01 := GDFieldPos( 'TL_TIPOREG', aCabec )
	nPos02 := GDFieldPos( 'TL_DTFIM'  , aCabec )
	nPos03 := GDFieldPos( 'TL_DTINICI', aCabec )
	nPos04 := GDFieldPos( 'TL_HOINICI', aCabec )

	If !MNTA435MC( aCabec )
		Return .F.
	EndIf

	If(M->TL_DTINICI > dDataBase)
		HELP(" ",1,"DATAINVAL")
		Return .F.
	EndIf

	If !NGDTINIC()
		Return .F.
	EndIf

	//Verifica data de fechamento do estoque
	If lVerDt .And. !NGCHKMESFE(M->TL_DTINICI,Acols[n,nPos01])
		Return .F.
	EndIf

	If !NGCALDTHO()
		Return .F.
	EndIf

	If aCols[n][nPos01] == "P"
		aCols[n][nPos02] := M->TL_DTINICI
		If !Empty(aCOls[n][nPos04]) .And. !Empty(aCOls[n][nPos03])
			MNT400CHKGAR()
			MNT400PCKGAR()
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG435HoIni
Valida e mostra a hora inicio.
@type Function

@author Dênis
@since  06/09/2001

@param 	aCabec , array, Cabeçalho do GetDados que origina a chamada.
@return boolean, Indica se o contéudo informado é valido.
/*/
//---------------------------------------------------------------------
Function NG435HoIni( aCabec )

	Local nPos01   := 0
	Local nPos02   := 0
	Local nPos03   := 0
	Local nPos04   := 0
	Local nPos05   := 0

	Default aCabec := aClone( aHoBrw2 )

	nPos01 := GDFieldPos( 'TL_TIPOREG', aCabec )
	nPos02 := GDFieldPos( 'TL_DTFIM'  , aCabec )
	nPos03 := GDFieldPos( 'TL_HOFIM'  , aCabec )
	nPos04 := GDFieldPos( 'TL_DTINICI', aCabec )
	nPos05 := GDFieldPos( 'TL_USACALE', aCabec )

	If !NGVALHORA(M->TL_HOINICI,.T.)
		Return .F.
	EndIf

	If !MNTA435MC( aCabec )
		Return .F.
	EndIf

	If !NGCALDTHO()
		Return .F.
	EndIf

	If aCols[n][nPos01] == "P"
		aCols[n][nPos02] := aCols[n][nPos04]
		aCols[n][nPos03] := M->TL_HOINICI
		If aCols[n,nPos04] = dDataBase .And. M->TL_HOINICI > SubS(Time(),1,5)
			MsgInfo(STR0245,STR0133)
			Return .F.
		EndIf
		If !Empty(aCOls[n][nPos04]) .And. !Empty(M->TL_HOINICI)
			MNT400CHKGAR()
			MNT400PCKGAR()
		EndIf
	Else
		M->TL_USACALE := If(aCols[n][nPos05] <> "S","N",aCols[n][nPos05])
		If !NGSTLHORIN()
			Return .F.
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG435DtFim
Valida a data fim.
@type Function

@author Dênis
@since  06/09/2001

@param 	aCabec , array, Cabeçalho do GetDados que origina a chamada.
@return boolean, Indica se o contéudo informado é valido.
/*/
//---------------------------------------------------------------------
Function NG435DtFim( aCabec )

	Local nPos01   := 0
	Local nPos02   := 0
	Local lRet     := .T.

	Default aCabec := aClone( aHoBrw2 )

	nPos01 := GDFieldPos( 'TL_DTINICI', aCabec )
	nPos02 := GDFieldPos( 'TL_HOFIM'  , aCabec )

	If !NaoVazio( M->TL_DTFIM )

		lRet := .F.

	EndIf

	If lRet .And.;
		!NGCPDIAATU( M->TL_DTFIM, '<=', .T., , .T. )

		lRet := .F.

	EndIf

	If lRet .And.;
		!MNTA435MC( aCabec )

		lRet := .F.

	EndIf

	If lRet .And. M->TL_DTFIM == dDataBase .And. !Empty( aCols[n,nPos02] ) .And.;
		aCols[n,nPos02] > SubStr( Time(), 1, 5 )

		MsgInfo( STR0202 + ' ' + STR0246 + ' ' + STR0247 + ' ' + STR0248 +;
			' ' + STR0249 + ' ' + STR0203 + ' ' + STR0250 + ' ' + STR0251 + ' ' + STR0248, STR0133 )

		lRet := .F.

	EndIf

	If lRet .And.;
		!NGCALDTHO()

		lRet := .F.

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NG435HoFim
Atualiza hora fim quando digitado qtde de horas.
@type Function

@author Dênis
@since  06/09/2001

@param 	aCabec , array, Cabeçalho do GetDados que origina a chamada.
@return boolean, Indica se o contéudo informado é valido.
/*/
//---------------------------------------------------------------------
Function NG435HoFim( aCabec )

	Local nPos01   := 0
	Local nPos02   := 0
	Local nPos03   := 0
	Local nPos04   := 0
	Local nPos05   := 0

	Default aCabec := aClone( aHoBrw2 )

	nPos01 := GDFieldPos( 'TL_TIPOREG', aCabec )
	nPos02 := GDFieldPos( 'TL_DTFIM'  , aCabec )
	nPos03 := GDFieldPos( 'TL_HOINICI', aCabec )
	nPos04 := GDFieldPos( 'TL_DTINICI', aCabec )
	nPos05 := GDFieldPos( 'TL_USACALE', aCabec )

	If !NGVALHORA(M->TL_HOFIM,.T.)
		Return .F.
	EndIf

	If !MNTA435MC( aCabec )

		Return .F.

	EndIf

	If aCols[n][nPos01] <> "P"
		If aCols[n][nPos04] = aCols[n][nPos02] .And. M->TL_HOFIM < aCols[n][nPos03]
			MsgInfo(STR0242,STR0133)
			Return .F.
		ElseIf  aCols[n][nPos02] = dDataBase .And. M->TL_HOFIM > SubS(Time(),1,5)
			MsgInfo(STR0243,STR0133)
			Return .F.
		EndIf
		M->TL_TIPOREG := aCols[n][nPos01]
		M->TL_USACALE := If(aCols[n][nPos05] <> "S","N",aCols[n][nPos05])
		M->TL_DTINICI := aCols[n][nPos04]
		M->TL_HOINICI := aCols[n][nPos03]
		M->TL_DTFIM   := aCols[n][nPos02]
		If !NGSTLHORFI()
			Return .F.
		EndIf
		NGCALQUANT()
	EndIf

	If !NGCALDTHO()
		Return .F.
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fLoadSTL ³ Autor ³ Denis                 ³ Data ³ 06.09.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Carrega aCols do STL nos campos temporarios M->            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fLoadSTL( nLinSTL )

	Local cKEY,cGETWHILE
	Local lTemIns    := .F.
	Local nPosFld    := 0
	Local nPosTp     := oBrw6:nAt
	
	If ValType( nLinSTL ) == 'N' .And.;
		Len( oBrw6:aCols ) >= nLinSTL

		nPosTp := nLinSTL

	EndIf

	If !lStartVar
		Return .T.
	EndIf

	If ( nPosFld := GDFieldPos( 'TL_TIPOREG', oBrw6:aHeader ) ) > 0

		M->TL_TIPOREG := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_DESTINO', oBrw6:aHeader ) ) > 0

		M->TL_DESTINO := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_CODIGO', oBrw6:aHeader ) ) > 0

		M->TL_CODIGO  := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_UNIDADE', oBrw6:aHeader ) ) > 0

		M->TL_UNIDADE := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_LOCAL', oBrw6:aHeader ) ) > 0

		M->TL_LOCAL   := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_DTINICI', oBrw6:aHeader ) ) > 0

		M->TL_DTINICI := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_HOINICI', oBrw6:aHeader ) ) > 0

		M->TL_HOINICI := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_DTFIM', oBrw6:aHeader ) ) > 0

		M->TL_DTFIM   := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_HOFIM', oBrw6:aHeader ) ) > 0

		M->TL_HOFIM   := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_QUANTID', oBrw6:aHeader ) ) > 0

		M->TL_QUANTID := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_NUMLOTE', oBrw6:aHeader ) ) > 0

		M->TL_NUMLOTE := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_LOTECTL', oBrw6:aHeader ) ) > 0

		M->TL_LOTECTL := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_LOCALIZ', oBrw6:aHeader ) ) > 0

		M->TL_LOCALIZ := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_NUMSERI', oBrw6:aHeader ) ) > 0

		M->TL_NUMSERI := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_GARANTI', oBrw6:aHeader ) ) > 0

		M->TL_GARANTI := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_TAREFA', oBrw6:aHeader ) ) > 0

		M->TL_TAREFA  := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_USACALE', oBrw6:aHeader ) ) > 0

		M->TL_USACALE := oBrw6:aCols[nPosTp,nPosFld]

	EndIf

	If ( nPosFld := GDFieldPos( 'TL_SEQRELA', oBrw6:aHeader ) ) > 0

		oBrw6:aCols[nPosTp,nPosFld] := MNT435SEQ( oBrw6:aCols, .F., nPosTp )

		M->TL_SEQRELA := oBrw6:aCols[nPosTp,nPosFld]

	EndIf
	
	aColsAtu := aClone( oBrw6:aCols )
	nPosAtu  := oBrw6:nAt

	oGd435Ocr:oBrowse:lDisablePaint := .F.

	If !Empty(cOrdemTJ)
		dbSelectArea("STJ")
		dbSetOrder(01)
		dbSeek(xFilial("STJ")+cOrdemTJ+cPlanoTJ)

		If ValType(aColsAtu[ nPosTp , Len(aColsAtu[nPosTp])-1 ]) == "A"
			If Len( aColsAtu[ nPosTp , Len(aColsAtu[nPosTp])-1 ] ) > 0
				lTemIns := .T.
			EndIf
		Else
			aAdd( aColsAtu[nPosTp] , aColsAtu[ nPosTp , Len(aColsAtu[nPosTp]) ] )
			aColsAtu[ nPosTp , Len(aColsAtu[nPosTp])-1 ] := {}
		EndIf

		If TT9->( FieldPos( 'TT9_CARACT' ) ) == 0

			aCoBrw3 := {}

			If lTemIns
				aCoBrw3 := aClone( aColsAtu[ nPosTp , Len(aColsAtu[nPosTp])-1 ] )
			Else
				If !Empty(M->TL_SEQRELA)
					cKEY  := cOrdemTJ + cPlanoTJ + M->TL_TAREFA + M->TL_SEQRELA
					cGETWHILE := "TN_ORDEM   == '"+  cOrdemTJ  +"' .And. "
					cGETWHILE += "TN_PLANO   == '"+  cPlanoTJ  +"' .And. "
					cGETWHILE += "TN_TAREFA  == '"+M->TL_TAREFA +"' .And. "
					cGETWHILE += "TN_SEQRELA == '"+M->TL_SEQRELA+"'"
					dbSelectArea("STN")
					dbSetOrder(1)
					Inclui := .F.
					aHoBrw3 := NGHeader("STN", {"TN_FILIAL", "TN_TAREFA","TN_NOMETAR","TN_ORDEM","TN_PLANO","TN_SEQRELA", "TN_SEQUENC"}, .F. )
					aCoBrw3 := MAKEGETD("STN", cKEY,  aHoBrw3, cGETWHILE,,.F.)
					Inclui := .T.
				EndIf
			EndIf

			If Len(aCoBrw3) == 0
				aCoBrw3 := BLANKGETD(aHoBrw3)
			EndIf

			aCols           := aClone( aCoBrw3 )
			aHeader         := aClone( aHoBrw3 )
			oGd435Ocr:aCols := aClone( aCoBrw3 )
			
			If oFolder435:nOption == 3
				
				oGd435Ocr:GoTo( 1 )
				oGd435Ocr:oBrowse:Default()
				oGd435Ocr:oBrowse:Refresh()
			
			EndIf

		EndIf

		aCols       := aClone( aColsAtu )
		aHeader     := aClone( aHoBrw6 )
		oBrw6:aCols := aClone( aColsAtu )
		oBrw6:GoTo( nPosTp )

		oBrw6:oBrowse:Default()
		oBrw6:oBrowse:Refresh()

		If !lTemIns

			aCols[nPosTp,Len(aCols[nPosTp])-1] := aClone( aCoBrw3 )

		EndIf

		PutFileInEof( 'STN' )

	EndIf

	oGd435Ocr:oBrowse:lDisablePaint := .T.

	dbSelectArea("STJ")
	dbSetOrder(01)
	dbSeek(xFilial("STJ")+cOrdemTJ+cPlanoTJ)

	If STJ->TJ_SERVICO == "HISTOR"
		If cUIntHis == "N" .And. cUsaInt3 == 'S' .And. M->TL_TIPOREG $ ( 'P/M' )
			lCusto := .T.
		Else
			lCusto := .F.
		EndIf
	ElseIf cUsaInt3 == 'S'
		lCusto := .F.
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NG435LOTCT³ Autor ³ Denis                 ³ Data ³ 13/03/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Valida o campo TL_LOTECTL                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG435LOTCT()
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})

Return If(!Empty(M->TL_LOTECTL),NGVRASTSB8(aCols[n][nPos01],aCols[n][nPos02],M->TL_LOTECTL,aCols[n][nPos03]),.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NG435NUMLO³ Autor ³ Denis                 ³ Data ³ 13/03/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Valida o campo TL_NUMLOTE                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG435NUMLO()
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})

Return If(!Empty(M->TL_NUMLOTE),NGVRASTSB8(aCols[n][nPos01],aCols[n][nPos02],aCols[n][nPos03],M->TL_NUMLOTE),.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NG435LOCAL³ Autor ³ Denis                 ³ Data ³ 13/03/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Valida o campo TL_LOCALIZ                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG435LOCAL()
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })

Return If(!Empty(M->TL_LOCALIZ),ExistCpo("SBE",aCols[n][nPos01]+M->TL_LOCALIZ),.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³NGRETNO435³ Autor ³Denis                  ³ Data ³06/08/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Mostra o nome do tipo de insumo                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA400                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGRETNO435(cTipo)

	If cUsaGeRe == "EST" .And. cTipo == "P"
		MsgInfo(STR0086) //"Para insumo produto somente poderá ser gerado SA (Solicitação ao Armazém)."
		Return .F.
	EndIf

	If !NGVALTERC(cTipo)
		Return .F.
	EndIf

	If cTipo == "P"
		If ExistBlock("MNTA4009")
			If !ExecBlock("MNTA4009",.F.,.F.)
				Return .F.
			EndIf
		EndIf
	ElseIf cTipo == "E"
		MsgInfo(STR0175+chr(13)+chr(10)+STR0176,STR0133) //"Tipo de insumo invalido.."###"Informe um tipo de insumo diferente de especialidade"###"NAO CONFORMIDADE"
		Return .F.
	EndIf

	NGCLEARSTL()

	If NGFUNCRPO("NGMDOEXECU",.F.)
		nColPe := GDFIELDPOS("TL_PERMDOE")
		nColTi  := GDFIELDPOS("TL_TIPOREG")
		If nColPe > 0  .And. nColTi > 0 .And.  (aCOLS[n,nColTi ] <> "M" .Or.  aCOLS[n,nColTi] <> M->TL_TIPOREG)
			aCOLS[n,nColPe] := 0.00
		EndIf
	EndIf
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ fMNTA405 ³ Autor ³ Denis                 ³ Data ³24/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Retorno das Opcoes da Etapa da manutencao                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Objetivo  ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fMNTA405()

	Local aAreaTRB   := (cTRBQ400)->( FWGetArea() )
	Local aCposAlter := {}, nI := 0
	Local aPosCpo    := {}
	Local aAlterCpos := { "TX_OK", "TPQ_RESPOS" }
	Local aOldHea    := aClone(aHeader)
	Local aOldRot    := aClone(aRotina)
	Local aOldCol    := aClone(aCols)
	Local nLineOS    := aScan(aDadosOS, {|x|x[1] + x[2] == cOrdemTJ + cPlanoTJ })
	Local aTempDad   := Nil
	Local cTOpcao, lOk
	Local oPnlAll
	Local lPE4351L   := ExistBlock("MNTA435L")
	Local nTot       := 0
	Local nInd       := 0
	Local nTamanho   := 0
	Local nDecimal   := 0
	Local nDscOpt    := 0
	Local nPosResp   := Len( aTrbQ ) + 4
	Local cCampo     := ""
	Local cArquivo   := ""
	Local cTitulo    := ""
	Local cPicture   := ""
	Local cValid     := ""
	Local cUsado     := ""
	Local cTipo      := ""
	Local cContext   := ""
	Local cX3Nivel   := ""

	Private oDlg3, oGet, cCodAnt

	nItens := 0

	/*--------------------------------------------------------------------------------------
	| Caso a etapa esteja marcada, verifica se esta etapa gerou alguma OS/SS que não está	|
	| cancelada. Caso exista alguma OS/SS não cancelada não permitirá desmarcá-la.			|
	| 																						|
	| MNT400OSG - Verifica se existem OS's													|
	| MNT400SSG - Verifica se existem OS's													|
	---------------------------------------------------------------------------------------*/
	If Empty((cTRBQ400)->TQ_OK)
		If !MNT400OSG( (cTRBQ400)->TQ_ORDEM , (cTRBQ400)->TQ_PLANO , (cTRBQ400)->TQ_TAREFA , (cTRBQ400)->TQ_ETAPA )
			(cTRBQ400)->TQ_OK := cMarca
			Return .F.
		ElseIf !MNT400SSG( (cTRBQ400)->TQ_ORDEM, (cTRBQ400)->TQ_PLANO, (cTRBQ400)->TQ_TAREFA, (cTRBQ400)->TQ_ETAPA )
			(cTRBQ400)->TQ_OK := cMarca
			Return .F.
		EndIf
	EndIf

	ccAlias := Alias()

	//Carrega informações da ordem de serviço da etapa etapa selecionada
	dbSelectArea("STJ")
	dbSetOrder(1)
	dbSeek( xFilial("STJ") + (cTRBQ400)->TQ_ORDEM + (cTRBQ400)->TQ_PLANO )

	cOrdem   := STJ->TJ_ORDEM
	cPlano   := STJ->TJ_PLANO
	cBem     := STJ->TJ_CODBEM
	cServico := STJ->TJ_SERVICO
	nSequenc := STJ->TJ_SEQRELA
	cTarefa  := (cTRBQ400)->TQ_TAREFA
	cEtapa   := (cTRBQ400)->TQ_ETAPA

	//Verifica se a etapa existe na TPA (Etapas Genéricas)
	dbSelectArea("TPA")
	dbSetOrder(1)
	If dbSeek(xFilial("TPA") + cEtapa) .And. TPA->TPA_OPCOES != '0'

		aRotina := {{STR0181, "AxPesqui",0,1},; //"Pesquisar"
					{STR0182, "NGCAD02" ,0,2},; //"Visualizar"
					{STR0028, "MNTA405" ,0,3}}  //"Incluir"

		If !Empty( (cTRBQ400)->TQ_OK )

			aCols := {}

			If Type("aDadosOS[" + Alltrim( Str(nLineOS) ) + ",8]") == "A"

				nPosTar := aScan( aTRBQ, { |x| AllTrim( x[2] ) == 'TQ_TAREFA' } )
				nPosEta := aScan( aTRBQ, { |x| AllTrim( x[2] ) == 'TQ_ETAPA' } )

				If nPosTar > 0 .And. nPosEta > 0

					If ( nPosCol := aScan( aDadosOS[nLineOS,8], { |x| x[nPosTar] == cTarefa .And.;
						x[nPosEta] == cEtapa } ) ) > 0

						aTemp := aDadosOS[nLineOS,8,nPosCol,nPosResp]

						If ValType( aTemp ) == 'A'

							aTempDad := aClone( aTemp )

						EndIf

					EndIf

				EndIf

			EndIf

			cTOpcao  := IIf( TPA->TPA_OPCOES == '1', STR0183, STR0272) //"Exclusiva" ## "Múltiplas"

			lTpOpcao := IIf( TPA->TPA_OPCOES == '1', '1', '2' )
			cNomEta := SubStr(TPA->TPA_DESCRI, 1, 70)
			cNomTar := NGNOMETAR( cBem + cServico + nSequenc, cTarefa )

			M->TP1_TPMANU := '0'
			M->TP1_TIPRES := "X"
			M->TPQ_RESPOS := Space( TAMSX3("TPQ_RESPOS")[1] )
			lEOpcao       := .F.
			nOpcx         := 3


			nUsado  := 0
			aHeader := {}
			fMntCabec() // Montagem do aHeader

			// Preenche o array auxiliar aCposAlter...
			If ExistBlock("NG405CPU")
				aCposAlter := ExecBlock("NG405CPU", .F., .F.)
			EndIf

			// Agrega no array aHeader os campos de Usuarios...
			nTot := Len(aCposAlter)
			For nInd := 1 To nTot

				cCampo   := aCposAlter[nInd]
				cArquivo := Posicione("SX3",2,cCampo,"X3_ARQUIVO")
				If TPQ->(FieldPos(cCampo)) > 0

					cTitulo  := AllTrim(Posicione("SX3",2,cCampo,"X3Titulo()"))
					cPicture := X3Picture(cCampo)
					nTamanho := TAMSX3(cCampo)[1]
					nDecimal := TAMSX3(cCampo)[2]
					cValid   := Posicione("SX3",2,cCampo,"X3_VALID")
					cUsado   := Posicione("SX3",2,cCampo,"X3_USADO")
					cTipo    := Posicione("SX3",2,cCampo,"X3_TIPO")
					cContext := Posicione("SX3",2,cCampo,"X3_CONTEXT")
					cX3Nivel := Posicione("SX3",2,cCampo,"X3_NIVEL")

					If X3USO(cUsado) .And. cNivel >= cX3Nivel
						nUsado++
						aAdd(aHeader,{cTitulo,cCampo,cPicture,nTamanho,nDecimal,cValid,cUsado,cTipo,cArquivo,cContext})
					EndIf

				EndIf

			Next nInd

			nOk     := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TX_OK" })
			nnOPCA  := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TP1_OPCAO" })
			nBEMIMN := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TP1_BEMIMN" })
			nTIPCAM := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TP1_TIPCAM" })
			nRESPOS := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TPQ_RESPOS" })
			nDscOpt := GdFieldPos( 'TPC_DESOPC', aHeader )

			//Conta o número de opções que a etapa possui
			dbSelectArea("TPC")
			dbSetOrder(1) //TPC_FILIAL+TPC_ETAPA+TPC_OPCAO
			If dbSeek( xFilial("TPC") + cEtapa )
				nCnt   := 0
				nItens := 0

				While !EoF() .And. TPC->TPC_FILIAL == xFilial("TPC") .And. cEtapa == TPC->TPC_ETAPA
					nCnt++
					dbSkip()
				EndDo
			EndIf

			//---------------------------------------------------------------
			// Início -> Montagem do aCols
			//---------------------------------------------------------------
			If nCnt > 0
				aCols := Array(nCnt, nUsado + 1)

				dbSelectArea("TPC")
				dbSetOrder(1)
				If dbSeek(xFilial("TPC") + cEtapa)
					nCnt   := 0
					nUsado := 0
					While !EoF() .And. TPC->TPC_FILIAL == xFilial("TPC") .And. cEtapa == TPC->TPC_ETAPA
						nCnt++
						nUsado++

						cRes := " "
						If ValType(aTempDad) == "A"
							nPosCpo := aScan(aTempDad ,{|x| x[2] == TPC->TPC_OPCAO })
							If nPosCpo > 0
								cRes := aTempDad[nPosCpo][3]
							EndIf
						Else
							dbSelectArea("TPQ")
							dbSetOrder(1) //TPQ_FILIAL+TPQ_ORDEM+TPQ_PLANO+TPQ_TAREFA+TPQ_ETAPA+TPQ_OPCAO
							If dbSeek( xFilial("TPQ") + cOrdem + cPlano + cTarefa + cEtapa + TPC->TPC_OPCAO )
								cRes := TPQ->TPQ_RESPOS
							EndIf
						EndIf

						aCOLS[nCnt,nnOPCA]  := TPC->TPC_OPCAO
						aCOLS[nCnt,nDscOpt] := TPC->TPC_DESOPC
						aCOLS[nCnt,nOK]     := Space(01)

						If TPC->TPC_TIPRES == '1'
							aCOLS[nCnt][nBEMIMN] := STR0186 //"MARCAR"
							If ValType(aTempDad) == "A"
								nPosCpo := aScan(aTempDad ,{|x| x[2] == TPC->TPC_OPCAO })
								If nPosCpo > 0
									aCOLS[nCnt][nOK] := "X"
								EndIf
							Else
								dbSelectArea("TPQ")
								dbSetOrder(2)
								If dbSeek( xFilial("TPQ") + cOrdem + cEtapa + TPC->TPC_OPCAO )
									aCOLS[nCnt][nOK] := "X"
								EndIf
							EndIf
						Else
							aCOLS[nCnt][nBEMIMN] := STR0187 //"INFORMAR"
						EndIf

						aCOLS[nCnt][nTIPCAM] := TPC->TPC_TIPCAM

						If !Empty(cRes)
							aCOLS[nCnt][nOK]     := "X"
							aCOLS[nCnt][nRESPOS] := cRes
						Else
							aCOLS[nCnt][nRESPOS] := Space( TAMSX3( 'TPQ_RESPOS' )[1] )
						EndIf

						If Len(aCposAlter) > 0
							For nI := 1 To Len(aCposAlter)
								nPosCpo := aScan(aHeader,{|x| AllTrim(x[2]) == aCposAlter[nI]})

								aAdd( aPosCpo, { aCposAlter[nI], nPosCpo })

								aCOLS[nCnt][nPosCpo] := CriaVar(aCposAlter[nI])
							Next nI
						EndIf

						ATail(aCOLS[nCnt]) := .F.
						nItens++
						lRefresh := .T.

						If lPE4351L
							aCOLS := ExecBlock("MNTA435L",.F.,.F.,{aHEADER,aCOLS,nCnt})
						EndIf

						dbSelectArea("TPC")
						dbSkip()
					EndDo
				EndIf

			EndIf
			//---------------------------------------------------------------
			// Fim -> Montagem do aCols
			//---------------------------------------------------------------

			DEFINE MSDIALOG oDlg3 TITLE OemToAnsi(STR0188) From 6.5,10 To 27,90 OF oMainWnd

			oPnlAll := TPanel():New( 00,00,,oDlg3,,,,,CLR_WHITE,12,12,.F.,.F. )
			oPnlAll:Align := CONTROL_ALIGN_ALLCLIENT

			oPnlCabec := TPanel():New( 00,00,,oPnlAll,,,,,CLR_WHITE,12,12,.F.,.F. )
			oPnlCabec:Align := CONTROL_ALIGN_TOP
			oPnlCabec:nHeight := 95

			oPnlGetD := TPanel():New( 00,00,,oPnlAll,,,,,CLR_WHITE,10,10,.F.,.F. )
			oPnlGetD:Align := CONTROL_ALIGN_ALLCLIENT

			@ 0.7,1  Say OemToAnsi(STR0027) Of oPnlCabec //"Ordem"
			@ 0.7,4  MsGet cOrdem When .F. Of oPnlCabec

			@ 0.7,9  Say OemToAnsi(STR0050) Of oPnlCabec //"Plano"
			@ 0.7,12 MsGet cPlano  When .F. Of oPnlCabec

			@ 0.7,17 Say OemToAnsi(STR0057) Of oPnlCabec//"Opcao"
			@ 0.7,20 MsGet cTOpcao When .F. Of oPnlCabec

			@ 1.7,1  Say OemToAnsi(STR0023) Of oPnlCabec //"Tarefa"
			@ 1.7,4  MsGet cTarefa When .F. Of oPnlCabec

			@ 1.7,9  Say OemToAnsi(STR0080) Of oPnlCabec//"Nome"
			@ 1.7,12 MsGet cNomTar SIZE 150,10 When .F. Of oPnlCabec

			@ 2.7,1  Say OemToAnsi(STR0025) Of oPnlCabec //"Etapa"
			@ 2.7,4  MsGet cEtapa  When .F. Of oPnlCabec

			@ 2.7,9  Say OemToAnsi(STR0080) Of oPnlCabec //"Nome"
			@ 2.7,12 MsGet cNomEta SIZE 200,10 When .F. Of oPnlCabec

			oGet := MsGetDados():New( 2, 6, 70, 310, nOpcx, "fE405LINOK", "fE405TUDO", "", .F., aAlterCpos,,, nItens,,,,, oPnlGetD )

			ACTIVATE MSDIALOG oDlg3 ON INIT EnchoiceBar(oDlg3,{|| lOk := .T., IIf( !fE405TUDO(), lOk := .F., oDlg3:End())},;
			{|| lOk := .F., oDlg3:End()}) CENTERED

			If lOk
				dbSelectArea(cTRB3400)
				dbSetOrder(1)
				dbGoTop()
				If dbSeek((cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_TAREFA)
					While !EoF() .And. (cTRB3400)->TPC_ETAPA == (cTRBQ400)->TQ_ETAPA;
					.And. (cTRB3400)->TPC_TAREFA == (cTRBQ400)->TQ_TAREFA

						RecLock(cTRB3400,.F.)
						DbDelete()
						(cTRB3400)->(MsUnLock())
						dbSkip()
					EndDo
				EndIf

				//Salva as respostas das etapas na tabela temporária (cTRB3400)
				fSaveResp( cEtapa, cTarefa, aCposAlter)
			Else
				//Desmarca a etapa caso a tela de resposta das opções seja fechada
				dbSelectArea(cTRBQ400)
				(cTRBQ400)->TQ_OK := ""
			EndIf

		Else
			dbSelectArea(cTRB3400)
			dbSetOrder(1)
			dbGoTop()
			If dbSeek( (cTRBQ400)->TQ_ETAPA + (cTRBQ400)->TQ_TAREFA )
				While !EoF() .And. (cTRB3400)->TPC_ETAPA == (cTRBQ400)->TQ_ETAPA .And.;
				(cTRB3400)->TPC_TAREFA == (cTRBQ400)->TQ_TAREFA

					RecLock(cTRB3400,.F.)
					dbDelete()
					(cTRB3400)->(MsUnLock())

					dbSelectArea(cTRB3400)
					dbSkip()
				EndDo
			EndIf
		EndIf

	EndIf

	//Atualiza tabelas temporárias/arrays com as alterações de etapas
	Fd_Sai( 4 )
	
	aHeader := aClone(aOldHea)
	aCols   := aClone(aOldCol)
	aRotina := aClone(aOldRot)

	FWRestArea( aAreaTRB )

	FWFreeArray( aAreaTRB )

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ fE405TUDO³ Autor ³ Denis                 ³ Data ³24/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Consistencia final                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Objetivo  ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fE405Tudo()

	Local nI
	Local cOpcao
	Local lNaoMarca  := .F.

	For nI := 1 To nItens

		cOpcao := IIf( SubStr( aCols[nI][nBEMIMN], 1, 1 ) == "M", '1', '2' )

		If !Empty(aCols[nI][nOk]) .And. cOpcao == '2' .And. Empty(aCols[nI][nRESPOS])
			Help(" ",1,"OPSEMINFO")
			Return .F.
		EndIf

		If !lNaoMarca
			If !Empty(aCols[nI][nOk])
				lNaoMarca := .T.
			EndIf
		EndIf
	Next nI

	If !lNaoMarca
		dbSelectArea(cTRBQ400)
		(cTRBQ400)->TQ_OK := "   "
		ShowHelpDlg( "NGATENCAO", { STR0273 }, 1,; //"Não há opções marcadas e/ou respondidas para esta etapa."
		{ STR0274 }, 1)				 //"É necessário marcar e/ou informar pelo menos uma opção para etapas que possuem opção 'Exclusiva' ou 'Múltiplas'."
		Return .F.
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³FE405TPVAR³ Autor ³ Denis                 ³ Data ³24/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Consistencia campo de resposta                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Objetivo  ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FE405TPVAR()

	If findfunction("NGTPCONTCAR")
		dbSelectArea("TPC")
		dbSetOrder(1)
		If dbSeek(xFilial("TPC")+cEtapa+aCOLS[n,nnOPCA])
			If !NGTPCONTCAR(TPC->TPC_TIPCAM,M->TPQ_RESPOS)
				Return .F.
			EndIf
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³fE405LINOK³ Autor ³ Denis                 ³ Data ³24/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Consistencia da linha                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Objetivo  ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fE405LINOK()
	If n > nItens
		Return .F.
	EndIf
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ fEmptyOS ³ Autor ³ Denis                   Data ³24/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Cria tela de OS vazia                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Objetivo  ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fEmptyOS(lRef)

	If lRef

		// Browse de O.S.
		NGZap( oTmpTblOS:GetRealName() )

		// Etapas
		NGZap( oTmpTbl3:GetRealName() )

		NGZap( oTmpTbl4:GetRealName() )

		NGZap( oTmpTbl5:GetRealName() )
		
		NGZap( oTmpTbl9:GetRealName() )

		//Insumos
		NGZap( oTmpTbl6:GetRealName() )

		// Ocorrências
		If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0
			
			NGZap( oTmpTbl8:GetRealName() )
		
			NGZap( oTmpTbl7:GetRealName() )

		EndIf

		aCoBrw2 := BLANKGETD(aHoBrw2)
		oBrw2:oBrowse:Refresh()

		aCoBrw6 := aClone( aNovoSTL )
		aCols   := aClone( aCoBrw6 )
		aHeader := aClone( aHoBrw6 )
		n := 1
		
		oBrw6:oBrowse:Refresh()
	
		//Ocorrencias
		aCoBrw3 := BLANKGETD(aHoBrw3)
		aCols   := aClone(aCoBrw3)
		aHeader := aClone(aHoBrw3)
		n := 1
		oGd435Ocr:oBrowse:lDisablePaint := .F.
		oGd435Ocr:ForceRefresh()
		oGd435Ocr:oBrowse:lDisablePaint := .T.

		If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0

			aCoBrw3_2 := BlankGetD( aHoBrw3_2 )
			aCols     := aClone( aCoBrw3_2 )
			aHeader   := aClone( aCoBrw3_2 )
			oGd435Ass:ForceRefresh()

		EndIf

		//Motivos Atraso
		n:=1
		aCoBrw4 := BLANKGETD(aHoBrw4)
		aCols   := aClone(aCoBrw4)
		aHeader := aClone(aHoBrw4)
		oBrw5:oBrowse:lDisablePaint := .F.
		oBrw5:oBrowse:Refresh()
		oBrw5:oBrowse:lDisablePaint := .T.

		oBrw7:Refresh()

		oBrwOS:Refresh()
		oBrwOS:SetFocus()

		lClearData := .T.

		oDlg1:cTitle := cCadTemp

	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ fFina435 ³ Autor ³ Denis                 ³ Data ³ 13/06/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Programa para finalizacao OS de servico de Manutencao      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MNTA400                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fFina435(cALIAS,nREG,nOPCX,aVetData,nOSnAt,_aFin2P)

	Local nRecnSTJ, nCont
	Local cTipoCon   := " "
	Local lSoProduto := aVetData[5]
	Local cLanex     := IIf(FindFunction('NGUSELANEX'), NGUSELANEX( STJ->TJ_CODBEM ) , ;
						AllTrim( SuperGetMv( 'MV_NGLANEX', .F., '' ) )  )

	Local lSemIns := ExistBlock("NGSEMINS")

	Private bNGGRAVA, aCHKDEL     := {}
	Private TipoAcom, TipoAcom2, lFimOsWhen  := Nil

	Store .F. To TipoAcom, TipoAcom2

	nRET := 0

	dDTMRINI := STJ->TJ_DTMRINI
	dDTMRFIM := STJ->TJ_DTMRFIM
	cHOMRINI := STJ->TJ_HOMRINI
	cHOMRFIM := STJ->TJ_HOMRFIM
	nCONTOL1 := STJ->TJ_POSCONT
	nCONTOL2 := STJ->TJ_POSCON2

	dbSelectArea("STJ")
	dbSetOrder(1)
	dbSeek( xFilial("STJ") + cOrdemTJ + cPlanoTJ )

	nINDSTJ  := IndexOrd()
	nRECSTJ  := Recno()
	nREGFIM  := Recno()

	cBemRet  := Space( TAMSX3("TJ_CODBEM")[1] )
	cBemRet  := NGTBEMPAI( STJ->TJ_CODBEM, cBemRet)
	cBemRet  := IIf( Empty(cBEMRET), STJ->TJ_CODBEM, cBemRet )

	cTIPOCON := NGSEEK("ST9",cBEMRET,1,"T9_TEMCONT")
	TIPOACOM := ( cTIPOCON == "S" )
	nCONTBEM := ST9->T9_POSCONT
	nCONTSTJ := 0
	//FindFunction remover na release GetRPORelease() >= '12.1.027'
	If FindFunction("MNTCont2")
		TipoAcom2 := MNTCont2(xFilial("TPE"), cBemRet )
	Else
		dbSelectArea("TPE")
		dbSetOrder( 1 )
		TipoAcom2 := ( dbSeek( xFilial("TPE") + cBemRet ) )
	EndIf

	dbSelectArea("STJ")
	//VERIFICA A DATA E HORA FINAL PARA O.S. COM INSUMOS REAL
	dDTINI := aVetData[1]
	hORINI := aVetData[2]
	dDTFIM := aVetData[3]
	hORFIM := aVetData[4]

	If lSoProduto
		If Len(_aFin2P) == 0
			dDTFIM := dDataBase
			hORFIM := Time()
		EndIf
	EndIf

	vCONLA := NGACUMEHIS(cBEMRET,dDTFIM,hORFIM,1,IIf( !Empty(cLanex), "E", "P" ) )
	aCHOICE := {"TJ_ORDEM", "TJ_DTPRINI", "TJ_DTPRFIM", "TJ_HOPRINI", "TJ_HOPRFIM", "TJ_POSCONT",;
	"TJ_HORACO1", "TJ_POSCON2", "TJ_HORACO2", "TJ_DTMRINI", "TJ_HOMRINI", "TJ_DTMRFIM",;
	"TJ_HOMRFIM", "TJ_OBSERVA"}

	If ExistBlock("MNT40017")
		ExecBlock("MNT40017",.F.,.F.)
	EndIf

	If lSoProduto .Or. lSemIns //Verifica se existe só insumo do tipo produto ou utilizar o P.E. NGSEMINS
		lFimOsWhen := .T.
	EndIf

	aRELAC  := { { "TJ_POSCONT", "vCONLA[1]" },;
					( IIf( TipoAcom, { "TJ_HORACO1", "hORFIM" }, { "TJ_HORACO1", "''" } ) ),;
					{ "TJ_DTMRINI", "dDTINI" },;
					{ "TJ_HOMRINI", "hORINI" },;
					{ "TJ_DTMRFIM", "dDTFIM" },;
					{ "TJ_HOMRFIM", "hORFIM" },;
					( IIf( TipoAcom2, { "TJ_HORACO2", "hORFIM" }, { "TJ_HORACO2", "''" } ) ) }

	If cTENDFLAHA <> "N" .And. STJ->TJ_PLANO == "000000" //os corretiva
		aAdd( aCHOICE, "TJ_IRREGU" )
		aAdd( aCHOICE, "TJ_NIRREGU" )
	EndIf

	If ExistBlock("MNT40012")
		aRelacPE := ExecBlock("MNT40012",.F.,.F.,{aHoBrw6, aCoBrw6})
	EndIf

	If(Type("aRelacPE") == "A")
		If Len(aRelacPE) > 0
			For nCont := 1 To Len(aRelacPE)
				aAdd(aRELAC,aRelacPE[nCont])
			Next
		EndIf
	EndIf

	dbSelectArea("STJ")
	bNGGRAVA := { || NG435CHK( nOSnAt, lSoProduto ) .And. fInteg( cOrdemTJ ) }

	Inclui      := .F.
	nRet        :=  NGCAD01("STJ",nREG,4)
	Inclui      := .T.
	bNGGRAVA    := {}

	dbSelectArea("STJ")
	nRECNSTJ := Recno()
	If nRET == 1
		/*Ponto de entrada disponível para customização específica na Finalização do Retorno da Ordem de Serviço. SS: 021345*/
		If ExistBlock("MNTA4352")
			nRet := ExecBlock("MNTA4352",.F.,.F., { nRET })
		EndIf
		/*-----------------------------+
		| Integração SIGAGFR x SIGALOC |
		+-----------------------------*/
		If SuperGetMV( 'MV_NG1LOC', .F., .F. ) .And.;
			FindFunction( 'LOCM001' )

			 LOCM001()
		endif
	EndIf

	If nRET == 1
		cAORDEM   := STJ->TJ_ORDEM
		cAPLANO   := STJ->TJ_PLANO
		cACODBEM  := STJ->TJ_CODBEM
		cASERVICO := STJ->TJ_SERVICO
		nASEQUENC := STJ->TJ_SEQRELA
		nCONTSTJ  := STJ->TJ_POSCONT
		nDIFX     := nCONTSTJ - nCONTBEM
		nDIF      := IIf( nDIFX > 0, nDIFX, 0 )

		NGFINAL( STJ->TJ_ORDEM, STJ->TJ_PLANO, STJ->TJ_DTPRINI, STJ->TJ_HOPRINI,;
		STJ->TJ_DTPRFIM, STJ->TJ_HOPRFIM, STJ->TJ_POSCONT, STJ->TJ_POSCON2,;
		cBEMRET, STJ->TJ_HORACO1, STJ->TJ_HORACO2, nDIF)

		lSTJAchou := A400STJBUS(cACODBEM)
		dbSelectArea("ST9")
		dbSetOrder(1)
		If dbSeek(xFilial("ST9")+cACODBEM)
			RecLock("ST9",.F.)
			If lSTJAchou = .F.
				ST9->T9_TERCEIR := "1"
			EndIf
			ST9->(MsUnlock())
		EndIf

		lOSPOST := ( AllTrim( GetMv("MV_NGREPRO") ) == "S" )
		If STJ->TJ_DTMRFIM <> STJ->TJ_DTMPFIM .And. Val(STJ->TJ_PLANO) > 0 .And. lOSPost
			NGOSREPROG( STJ->TJ_CODBEM, STJ->TJ_SERVICO, STJ->TJ_SEQRELA, STJ->TJ_DTMRFIM, STJ->TJ_DTMPFIM )
		EndIf

		dbSelectArea("STJ")
		dbGoto(nRECSTJ)
		If ExistBlock("NG400FI1")
			ExecBlock("NG400FI1",.F.,.F.)
		EndIf

		dbSelectArea("STJ")
		nREGFIM := Recno()
		dbGoto(nRECSTJ)

		//Fechamento de solicitacao de servico
		NGFECHASS(stj->tj_ordem)
	EndIf

	dbSelectArea("STJ")
	dbSetOrder(nINDSTJ)
	lREFRESH := .T.

Return (nRet == 1)

//-----------------------------------------------------------------------
/*/{Protheus.doc} NG435CHK
Valida tela de finalizacao de OS e aciona gravação da ordem

@author Denis Hyroshi de Souza
@since 01/06/08

@param nOSnAt, numérico, posição da ordem que está sendo finalizada
@param lSoProduto, boolean, indica se há somente insumos tipo produto
@return boolean, se houve sucesso na operação
/*/
//-----------------------------------------------------------------------
Function NG435CHK( nOSnAt, lSoProduto )

	Local lRet := .T.

	If !NG400CHKFIM(lSoProduto)
		Return .F.
	EndIf

	If FindFunction("NGVLDSTL") .And. !NGVLDSTL(STJ->TJ_ORDEM) // verifica se não existe insumo com data e hora inicial igual a data e hora final
		Return .F.
	EndIf
	Inclui := .T.
	lRet := fGrava435( nOSnAt, .F., .F., .T. )
	Inclui := .F.

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fPosObjet ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ1ÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Define posicionamento dos objetos                           |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fPosObjet()

	Local lFlatMode := If(FindFunction("FLATMODE"),FlatMode(),SetMDIChild())

	nTipoVert := 1 //1024
	nTipoHorz := 1 //1280
	nPorcVert := 1 //% em relação a resolucao maxima
	nPorcHorz := 1 //% em relação a resolucao maxima
	//Verifica resolução Vertical
	If aSize[6] >= 934
		nTipoVert := 1 //1024          1
		nPorcVert := 1
	ElseIf aSize[6] >= 870
		nTipoVert := 2 //960
		nPorcVert := 0.93
	ElseIf aSize[6] >= 774
		nTipoVert := 3 //864
		nPorcVert := 0.82
	ElseIf aSize[6] >= 678
		nTipoVert := 4 //768
		nPorcVert := 0.70 //678/934
	ElseIf aSize[6] >= 630
		nTipoVert := 5 //720
		nPorcVert := 0.65
	ElseIf aSize[6] >= 510
		nTipoVert := 6 //600
		nPorcVert := 0.62
	Else
		nTipoVert := 6 //600
		nPorcVert := 0.42
	EndIf
	//Verifica resolução Horizontal
	If aSize[5] >= 1272
		nTipoHorz := 1 //1280
		nPorcHorz := 1
	ElseIf aSize[5] >= 1144
		nTipoHorz := 2 //1152
		nPorcHorz := 0.9
	ElseIf aSize[5] >= 1016
		nTipoHorz := 3 //1024
		nPorcHorz := 0.8
	Else	//If aSize[5] >= 792
		nTipoHorz := 4 //800
		nPorcHorz := 0.62
	EndIf

	// ------------- Folder -----------------
	nFolIniI := 11 * nPorcVert  //Linha Inicio
	nFolColI := 0.7             //Coluna Inicio (FIXO)
	nFolLarg := 616 * nPorcHorz //Largura
	nFolAltu := 320 * nPorcVert //Altura
	If lFlatMode .And. nTipoVert <= 4
		nFolAltu := 320 * (nPorcVert * 0.9) //Altura
	EndIf
	// ------------- Browse OS --------------
	nBOSIniI := 28              //Linha Inicio (FIXO)
	nBOSColI := 4               //Coluna Inicio (FIXO)
	nBOSLarg := 616 * nPorcHorz //Largura
	nBOSAltu := 110 * nPorcVert //Altura
	If nTipoVert == 2
		nBOSAltu := nBOSAltu * 0.98
	ElseIf nTipoVert == 3
		nBOSAltu := nBOSAltu * 0.94
	ElseIf nTipoVert == 4
		nBOSAltu := nBOSAltu * 0.90
	ElseIf nTipoVert == 5
		nBOSAltu := nBOSAltu * 0.85
	ElseIf nTipoVert == 6
		nBOSAltu := nBOSAltu * 0.80
	EndIf
	// ---------- Folder1 - Insumos ----------

	// ---------- Insumos Previstos ---------
	nIPrIniI := 1/*40 * nPorcVert*/ //Linha Inicio
	nIPrColI := 1//4               //Coluna Inicio (FIXO)
	nIPrLarg := 298 * nPorcHorz //Largura
	nIPrAltu := nFolAltu - 26   //Altura

	// --------- Insumos Realizados ---------
	nFO1IniI := 1/*40 * nPorcVert*/ //Linha Inicio
	nFO1ColI := 326 * nPorcHorz //Coluna Inicio
	nFO1Larg := 615 * nPorcHorz //Largura
	nFO1Altu := nFolAltu - 26   //Altura

	// ---------- Folder2 - Etapas ----------
	nFO2IniI := 1               //Linha Inicio (FIXO)
	nFO2ColI := 1               //Coluna Inicio (FIXO)
	nFO2Larg := 284 * nPorcHorz //Largura
	nFO2Altu := nFolAltu - 26   //Altura
	If nTipoHorz == 4
		nFO2Larg := nFO2Larg * 0.95
	EndIf
	nFZ2ColI := 328 * nPorcHorz //Coluna Inicio (FIXO)
	nFZ2Larg := nFO2Larg
	If nTipoHorz == 2
		nFZ2ColI := nFZ2ColI * 1.017
		nFZ2Larg := nFO2Larg * 0.98
	ElseIf nTipoHorz == 3
		nFZ2ColI := nFZ2ColI * 1.02
		nFZ2Larg := nFO2Larg * 0.97
	ElseIf nTipoHorz == 4
		nFZ2ColI := nFZ2ColI * 1.03
		nFZ2Larg := nFO2Larg
	EndIf
	// ------- Folder3 - Ocorrrencias -------
	nFO3IniI := 1               //Linha Inicio (FIXO)
	nFO3ColI := 1               //Coluna Inicio (FIXO)
	nFO3Larg := 612 * nPorcHorz //Largura
	nFO3Altu := nFolAltu - 26   //Altura
	// ------- Folder4 - Mot. Atrasos -------
	nFO4IniI := 1               //Linha Inicio (FIXO)
	nFO4ColI := 1               //Coluna Inicio (FIXO)
	nFO4Larg := 612 * nPorcHorz //Largura
	nFO4Altu := nFolAltu - 26   //Altura
	// ----------- Botões Centrais ----------
	nBtCeLin := 135 * nPorcVert //Linha
	nBtDista := 35
	nBtCeCol := 612 * nPorcHorz //Coluna
	If nTipoVert == 2
		nBtCeLin := nBtCeLin * 0.98
	ElseIf nTipoVert == 3
		nBtCeLin := nBtCeLin * 0.96
	ElseIf nTipoVert == 4
		nBtCeLin := nBtCeLin * 0.93
	ElseIf nTipoVert == 5
		nBtCeLin := nBtCeLin * 0.90
	ElseIf nTipoVert == 6
		nBtCeLin := nBtCeLin * 0.87
		nBtDista := 31
		nBtCeCol := nBtCeCol - 5
	EndIf

	// ----------- Botões Etapas ------------
	nBtEtLin := 11 //Linha
	nBtEtCol := 289 * nPorcHorz //Coluna
	nSalBtn  := 16
	nTamBotao := 11

	If nTipoVert == 6
		If lFlatMode .And. aSize[6] >= 600
			nSalBtn   := 10
			nTamBotao := 10
		Else
			nSalBtn   := 10
			nBtEtLin  := 2 //Linha
			nTamBotao := 9
		EndIf
	ElseIf nTipoVert == 4 .Or. nTipoVert == 5
		nSalBtn := 12
	EndIf
	If nTipoHorz == 4
		nBtEtCol := nBtEtCol * 0.96
	EndIf
	// ----------- Label TOTAL ------------
	nLaToLin := 285 * nPorcVert //Linha
	nLaToCol := 480 * nPorcHorz //Coluna

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} NGSALDOES
Verifica o saldo do produto em estoque

@author Denis Hyroshi de Souza
@since 04/09/2001
@param cVcod, string, código do Produto
@param cAlmox, string, código do Almoxifado
@param nQuant, string, quantidade solicitada
@param lMensa, boolean, se mostra msg de erro
@param nLineOS, numeric, linha da Matriz aDadosOS
@param nTipoVal, numeric, tipo de verificação
		1-Saldo SB2;
		2-Saldo Sub-Lote
		3-Saldo Lote
		4-Saldo Enderecamento
@param cLoteclt, string, código do lote
@param cNumLote, string, código do SubLote
@param cLocaliz, string, código do Endereco
@param cNumseri, string, código do Numero de Serie
/*/
//-------------------------------------------------------------------
Static Function NGSALDOES(cVCOD,cALMOX,nQUANT,lMENSA,nLineOS,nTipoVal,cLOTECTL,cNUMLOTE,cLOCALIZ,cNUMSERI,dDTINICI)

	Local cALIASOLD := ALIAS()
	Local nOLDKEY   := INDEXORD()
	Local cALMOXAF  := If(Empty(cALMOX),"01",cALMOX)
	Local lOk       := .T.
	Local nXX, nYY
	Local cChvPrAlm := ""
	Local nInicial  := 0 // quant itens da O.S antes de alterações
	Local nQFinal   := 0 // quant itens da após alterações (outras linhas)
	Local nOutras   := 0 // quant itens outras O.S
	Local nSobra    := 0
	Local nQntEmp   := 0
	Local nEmpenho  := 0
	Local lVerEmp   := .T.
	Local cTpSaldo   := SuperGetMv('MV_TPSALDO', .F., 'S' )

	Private nP435Tar := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA"})
	Private nP435Tip := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Private nP435Cod := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Private nP435Loc := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	Private nP435Qtd := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	Private nP435Sub := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})
	Private nP435Lot := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})
	Private nP435End := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCALIZ"})
	Private nP435NuS := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSERI"})
	Private nP435SqR := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	Private nP435SqT := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQTARE"})
	Private nForXX,nForYY
	Private bChv1Alm := "''"
	Private bChv2Alm := "''"
	Private bChv3Alm := "''"

	/*-------------------------------------------------------------------------------------------------+
	| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
	+-------------------------------------------------------------------------------------------------*/
	If nP435Cod == 0 .Or. nP435Tip == 0 .Or. nP435Qtd == 0 .Or. !lHasMNTREQ
		Return .T.
	EndIf

	If nTipoVal == 1 //Saldo SB2
		cChvPrAlm := cVCOD+cALMOXAF
		bChv1Alm  := "aDadosOS[nForXX,4,nForYY,nP435Cod]+aDadosOS[nForXX,4,nForYY,nP435Loc]"
		bChv2Alm  := "aDadosOS[nForXX,5,nForYY,nP435Cod]+aDadosOS[nForXX,5,nForYY,nP435Loc]"
		bChv3Alm  := "aCols[nForYY,nP435Cod]+aCols[nForYY,nP435Loc]"
	ElseIf nTipoVal == 2 //Saldo SubLote
		cChvPrAlm := cVCOD+cALMOXAF+cLOTECTL+cNUMLOTE
		bChv1Alm  := "aDadosOS[nForXX,4,nForYY,nP435Cod]+aDadosOS[nForXX,4,nForYY,nP435Loc]+aDadosOS[nForXX,4,nForYY,nP435Lot]"+;
		"+aDadosOS[nForXX,4,nForYY,nP435Sub]"
		bChv2Alm  := "aDadosOS[nForXX,5,nForYY,nP435Cod]+aDadosOS[nForXX,5,nForYY,nP435Loc]+aDadosOS[nForXX,5,nForYY,nP435Lot]"+;
		"+aDadosOS[nForXX,5,nForYY,nP435Sub]"
		bChv3Alm  := "aCols[nForYY,nP435Cod]+aCols[nForYY,nP435Loc]+aCols[nForYY,nP435Lot]+aCols[nForYY,nP435Sub]"
	ElseIf nTipoVal == 3 //Saldo Lote
		cChvPrAlm := cVCOD+cALMOXAF+cLOTECTL
		bChv1Alm  := "aDadosOS[nForXX,4,nForYY,nP435Cod]+aDadosOS[nForXX,4,nForYY,nP435Loc]+aDadosOS[nForXX,4,nForYY,nP435Lot]"
		bChv2Alm  := "aDadosOS[nForXX,5,nForYY,nP435Cod]+aDadosOS[nForXX,5,nForYY,nP435Loc]+aDadosOS[nForXX,5,nForYY,nP435Lot]"
		bChv3Alm  := "aCols[nForYY,nP435Cod]+aCols[nForYY,nP435Loc]+aCols[nForYY,nP435Lot]"
	ElseIf nTipoVal == 4 //Saldo Enderecamento
		cChvPrAlm := cVCOD+cALMOXAF+cLOCALIZ+cNUMSERI+cLOTECTL+cNUMLOTE
		bChv1Alm  := "aDadosOS[nForXX,4,nForYY,nP435Cod]+aDadosOS[nForXX,4,nForYY,nP435Loc]+aDadosOS[nForXX,4,nForYY,nP435End]"+;
		"+aDadosOS[nForXX,4,nForYY,nP435NuS]+aDadosOS[nForXX,4,nForYY,nP435Lot]+aDadosOS[nForXX,4,nForYY,nP435Sub]"
		bChv2Alm  := "aDadosOS[nForXX,5,nForYY,nP435Cod]+aDadosOS[nForXX,5,nForYY,nP435Loc]+aDadosOS[nForXX,5,nForYY,nP435End]"+;
		"+aDadosOS[nForXX,5,nForYY,nP435NuS]+aDadosOS[nForXX,5,nForYY,nP435Lot]+aDadosOS[nForXX,5,nForYY,nP435Sub]"
		bChv3Alm  := "aCols[nForYY,nP435Cod]+aCols[nForYY,nP435Loc]+aCols[nForYY,nP435End]+aCols[nForYY,nP435NuS]+"+;
		"aCols[nForYY,nP435Lot]+aCols[nForYY,nP435Sub]"
	EndIf

	nEmpenho:= 0

	//Analisa se existe retiradas do estoque na tela e desconta do saldo atual.
	//aqui nDiffOS corresponde a diferenca entre o que havia sido baixado antes de acessar a rotina e o atual
	nDiffOS := 0
	For nXX := 1 To Len(aDadosOS)
		nForXX := nXX
		If nLineOS != nXX
			If ValType(aDadosOS[nXX,4]) == "A" .And. ValType(aDadosOS[nXX,5]) == "A"
				For nYY := 1 To Len(aDadosOS[nXX,4])
					nForYY := nYY
					If aDadosOS[nXX,4,nYY,nP435Tip] == "P"
						If &(bChv1Alm) == cChvPrAlm
							nDiffOS += aDadosOS[nXX,4,nYY,nP435Qtd]
							nOutras-= aDadosOS[nXX,4,nYY,nP435Qtd]
						EndIf
					EndIf
				Next nYY
				For nYY := 1 To Len(aDadosOS[nXX,5])
					nForYY := nYY
					If aDadosOS[nXX,5,nYY,Len(aDadosOS[nXX,5,nYY])]
						Loop //Deletado
					EndIf
					If aDadosOS[nXX,5,nYY,nP435Tip] == "P"
						If &(bChv2Alm) == cChvPrAlm
							nDiffOS -= aDadosOS[nXX,5,nYY,nP435Qtd]
							nOutras += aDadosOS[nXX,5,nYY,nP435Qtd]
						EndIf
					EndIf
				Next nYY
			EndIf
		Else
			If ValType(aDadosOS[nXX,4]) == "A"
				For nYY := 1 To Len(aDadosOS[nXX,4])
					nForYY := nYY
					If aDadosOS[nXX,4,nYY,nP435Tip] == "P"
						If &(bChv1Alm) == cChvPrAlm
							nDiffOS += aDadosOS[nXX,4,nYY,nP435Qtd]
							nInicial -= aDadosOS[nXX,4,nYY,nP435Qtd]
						EndIf
					EndIf
				Next nYY
			EndIf
			For nYY := 1 To Len(aCols)
				nForYY := nYY
				If aCols[nYY,Len(aCols[nYY])]
					Loop //Deletado
				EndIf
				If aCols[nYY,nP435Tip] == "P" .And. nYY <> n
					If &(bChv3Alm) == cChvPrAlm
						nDiffOS -= aCols[nYY,nP435Qtd]
						nEmpenho+= aCols[nYY,nP435Qtd]
						nQFinal +=aCols[nYY,nP435Qtd]
					EndIf
				EndIf
			Next nYY
		EndIf
	Next nXX

	If nTipoVal == 1 //Saldo SB2

		//--------------------------------------------
		// Verifica se há necessidade de ver empenho
		//--------------------------------------------
		If lIntRM .Or. cTpSaldo != 'S' .Or. ( nQuant + nQFinal ) <= nInicial

			lVerEmp := .F.

		EndIf

		nQFinal := nQFinal + nInicial // itens da O.S sem a linha posicionada

		nQuant+= nQFinal + nOutras // quantidade real

		//------------------------------------------------------------------
		// Verifica se saldo físico do estoque atende a quantidade de itens
		//------------------------------------------------------------------
		lOk := NGSALSB2( cVCOD, cALMOX, nQuant,,, dDTINICI )

		//---------------------------------------------------------------------------------------------------------
		// Trecho abaixo verifica se tem saldo dísponível para a ordem de serviço ( se possui reserva de empenho )
		//---------------------------------------------------------------------------------------------------------
		If lOk .And. lVerEmp

			nQuant -= nOutras // total de itens da O.S
			nQntEmp := fQntEmp( cVCOD, cAlmox, aDadosOS[nLineOS,1] ) // quant. empenhada para a O.S

			//--------------------------------------------
			// Verifica se possui quantidade disponível
			//--------------------------------------------
			If nQuant > nQntEmp

				DbSelectArea('SB2')
				DbSetOrder(1)
				If !Dbseek( xFilial('SB2') + cVCOD + cAlmox )
					CriaSB2( cVCOD, cAlmox )
				EndIf

				nAmais := nQuant - nQntEmp // quantid. a mais
				nSobra := SaldoSB2( .F., .T. , dDataBase+3650, .F. ) // Saldo que está sobrando

				lOk := nSobra >= nAmais // Verifica se estoque não ficará negativo

				// ajusta valores para mostrar na msg
				If nQntEmp > 0 .And. nSobra < 0
					nSobra := nQntEmp
				ElseIf nSobra > 0
					nSobra+= nQntEmp
				EndIf

				nAmais+= nQntEmp

				If !lOk
					//'Saldo indisponível para a ordem de serviço' #'Disponível'#Entrada#
					Help( '', 1,'NGATENCAO',, STR0395 + CRLF + STR0396 + ':' + cValToChar( nSobra ) + CRLF + STR0397 + ':' + cValToChar( nAmais ) ,4,1)

				EndIf

			EndIf

 		EndIf

	ElseIf nTipoVal == 2 //Saldo SubLote

		dbSelectArea("SB8")
		dbSetOrder(02)
		If dbSeek(xFilial("SB8")+cNUMLOTE+cLOTECTL+cVCOD+cALMOX)
			nSaldoLote := SB8Saldo(.F.,!Empty(cLOTECTL+cNUMLOTE),NIL,NIL,NIL,NIL,NIL,dDTINICI)
			nSaldoLote := nSaldoLote + nDiffOS
			If QtdComp(nSaldoLote) < QtdComp(nQUANT)
				cHelp:=STR0127+AllTrim(cVCOD)+Chr(13)+STR0169+cALMOX+Chr(13)+STR0170; //"Produto "###"Local "###"Saldo Disponível "
				+Alltrim(Transform(nSaldoLote,PesqPictQt("B8_SALDO", 14)))+Chr(13)+STR0171+Alltrim(cLOTECTL); //"Lote "
				+Chr(13)+STR0172+Alltrim(cNUMLOTE) //"Sub-lote "
				Help(" ",1,"A240LOTENE",,cHelp,4,1)
				lOk := .F.
			EndIf
		Else
			Help(" ",1,"NGATENCAO",,STR0195+Chr(13)+Chr(10)+; //"Numero do sub-lote não corresponde ao produto que foi "
			STR0196,3,1) //" informado. Digite um sub-lote correspondente."
			lOk := .F.
		EndIf

	ElseIf nTipoVal == 3 //Saldo Lote

		dbSelectArea("SB8")
		dbSetOrder(03)
		If dbSeek(xFilial("SB8")+cVCOD+cALMOX+cLOTECTL)
			nSaldoLote := SaldoLote(cVCOD,cALMOX,cLOTECTL,NIL,.F.,!Empty(cLOTECTL+cNUMLOTE),NIL,dDTINICI)
			nSaldoLote := nSaldoLote + nDiffOS
			If QtdComp(nSaldoLote) < QtdComp(nQUANT)
				cHelp:=STR0127+AllTrim(cVCOD)+Chr(13)+STR0169+cALMOX+Chr(13)+STR0170; //"Produto "###"Local "###"Saldo Disponível "
				+Alltrim(Transform(nSaldoLote,PesqPictQt("B8_SALDO", 14)))+Chr(13)+STR0171+Alltrim(cLOTECTL) //"Lote "
				Help(" ",1,"A240LOTENE",,cHelp,4,1)
				lOk := .F.
			EndIf
		Else
			Help(" ",1,"NGATENCAO",,STR0197+Chr(13)+Chr(10)+; //"Numero do lote não corresponde ao produto que foi "
			STR0198,3,1) //" informado. Digite um lote correspondente."
			lOk := .F.
		EndIf

	ElseIf nTipoVal == 4 //Saldo Enderecamento
		If (aCols[n,nP435Cod] + aCols[n,nP435Loc] + aCols[n,nP435End] + aCols[nForYY,nP435NuS]+aCols[nForYY,nP435Lot]+aCols[nForYY,nP435Sub] == cChvPrAlm);
		.And. aCols[n,nP435SqR] > "0"
			nEmpenho += aCols[n,nP435Qtd]
		EndIf
		nSaldoLote := SaldoSBF(cALMOX,cLOCALIZ,cVCOD,cNUMSERI,cLOTECTL,cNUMLOTE,.F.)
		nSaldoLote := nSaldoLote + nDiffOS + nEmpenho
		If QtdComp(nSaldoLote) < QtdComp(nQUANT)
			Help(" ",1,"SALDOLOCLZ")
			lOk := .F.
		EndIf
	EndIf

	dbSelectArea(cALIASOLD)
	dbSetOrder(nOLDKEY)

Return lOk

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³GetNomeTip ³ Autor ³ Denis                ³ Data ³13/08/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Retorna nome do tipo de insumo                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA400                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function GetNomeTip(cTIPREG)
	Local cRet := Space(15)

	If cTIPREG == "M"
		cRet := "Mao de obra"
	ElseIf cTIPREG == "P"
		cRet := "Produto"
	ElseIf cTIPREG == "F"
		cRet := "Ferramenta"
	ElseIf cTIPREG == "T"
		cRet := "Terceiros"
	ElseIf cTIPREG == "E"
		cRet := "Especialidade"
	EndIf

Return cRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ f435VlFun ³ Autor ³ Denis                ³ Data ³13/08/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida intervalo dos insumos Mao de Obra temporario        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA400                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function f435VlFun(cTmpCod,cTmpOrdem,cTmpPlano,dTmpDtIni,cTmpHoIni,dTmpDtFim,cTmpHoFim,nLineOS,nPosCols,cTipoSTL,lRowCall)
	Local lRet := .T.
	Local nYY, nXX, nXArq
	Local nPosTip := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPosCod := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOINICI"})
	Local nPos04 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM" })
	Local nPos05 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOFIM" })
	Local aVRET  := {.F.," "}
	Local vARQSTL := {}
	Local nQUATISH4 := 0
	Local nQUATFEU  := 1
	Local cOldAlias := Alias()
	Local cAlsTTL   := ''
	Local aAreaSTJ  := STJ->(GetArea())

	Local cAliasQry := ''

	aAdd( vARQSTL , {"STL",8,"STL->TL_FILIAL","STL->TL_CODIGO",;
	"STL->TL_SEQRELA","STL->TL_ORDEM",;
	"STL->TL_PLANO","STL->TL_DTINICI",;
	"STL->TL_DTFIM","STL->TL_HOINICI",;
	"STL->TL_HOFIM","STL->TL_TIPOREG","STL->TL_QUANREC"} )
	aAdd( vARQSTL , {"STT",3,"STT->TT_FILIAL","STT->TT_CODIGO",;
	"STT->TT_SEQRELA","STT->TT_ORDEM",;
	"STT->TT_PLANO","STT->TT_DTINICI",;
	"STT->TT_DTFIM","STT->TT_HOINICI",;
	"STT->TT_HOFIM","STT->TT_TIPOREG","STT->TT_QUANREC"})

	If cTipoSTL == "F"
		dbSelectArea("SH4")
		dbSetOrder(1)
		If dbSeek(xFilial("SH4")+SubStr(cTmpCod,1,6))
			nQUATISH4 := SH4->H4_QUANT
		EndIf

	ElseIf cTipoSTL == 'M'

		cAlsTTL := GetNextAlias()

		BeginSql Alias cAlsTTL

			SELECT
				TTL.TTL_DTINI,
				TTL.TTL_HRINI,
				TTL.TTL_DTFIM,
				TTL.TTL_HRFIM
			FROM
				%table:TTL% TTL
			WHERE
				TTL.TTL_CODFUN = %exp:cTmpCod% AND
				( ( %exp:dToS( dTmpDtIni )% || %exp:cTmpHoIni% <= TTL.TTL_DTFIM || TTL.TTL_HRFIM ) AND
				  ( %exp:dToS( dTmpDtFim )% || %exp:cTmpHoFim% >= TTL.TTL_DTINI || TTL.TTL_HRINI ) ) AND
				TTL.TTL_FILIAL = %xFilial:TTL% AND
				%NotDel%

		EndSql

		If (cAlsTTL)->( !EoF() )

			cHelpMsg := STR0204 + Chr( 13 ) + Chr( 13 ) +; // Já existe aplicação de insumo no intervalo de Data/Hora informada.
						STR0205 + ': ' + cTmpCod + Chr( 13 ) +; // Código Insumo
						STR0206 + '....: ' + cTmpOrdem + Chr( 13 ) +; // Ordem Serv
						STR0050 + '..............: ' + cTmpPlano + Chr( 13 ) +; // Plano
						STR0200 + '......: ' + dToC( dTmpDtIni ) + Chr( 13 ) +; // Data Inicio
						STR0201 + '......: ' + SubStr( cTmpHoIni, 1, 5 ) + Chr( 13 ) +; // Hora Inicio
						STR0202 + '.........: ' + dToC( dTmpDtFim ) + Chr( 13 ) +; // Data Fim
						STR0203 + '.........: ' + SubStr( cTmpHoFim, 1, 5 ) + Chr( 13 ) + Chr( 13 ) +; // Hora Fim
						STR0387 + Chr( 13 ) + Chr( 13 ) +; // Aplicação do insumo já existente:
						STR0200 + '.....: ' + dToC( sToD( (cAlsTTL)->TTL_DTINI ) ) + Chr( 13 ) +; // Data Inicio
						STR0201 + '.....: ' + SubStr( (cAlsTTL)->TTL_HRINI, 1, 5 ) + Chr( 13 ) +; // Hora Inicio
						STR0202 + '........: ' + dToC( sToD( (cAlsTTL)->TTL_DTFIM ) ) + Chr( 13 ) +; // Data Fim
						STR0203 + '........: ' + SubStr( (cAlsTTL)->TTL_HRFIM, 1, 5 ) // Hora Fim

			aVRet := { .T., cHelpMsg }

		EndIf

		(cAlsTTL)->( dbCloseArea() )

	EndIf

	If !aVRET[1]

		For nXX := 1 To Len(aDadosOS)

			If nLineOS != nXX .Or. !lRowCall
				If ValType(aDadosOS[nXX,5]) == "A"
					For nYY := 1 To Len(aDadosOS[nXX,5])
						If aDadosOS[nXX,5][nYY,Len(aDadosOS[nXX,5][nYY])]
							Loop //Deletado
						EndIf
						If !lRowCall
							If nLineOS == nXX .And. nPosCols == nYY
								Loop
							EndIf
						EndIf
						If aDadosOS[nXX,5,nYY,nPosTip] == cTipoSTL .And. PadR(aDadosOS[nXX,5,nYY,nPosCod],nLenST1) == Padr(cTmpCod,nLenST1)
							If aDadosOS[nXX,5][nYY,nPos02] == dTmpDtIni .And. aDadosOS[nXX,5][nYY,nPos03] == cTmpHoIni .And. ;
							aDadosOS[nXX,5][nYY,nPos04] == dTmpDtFim .And. aDadosOS[nXX,5][nYY,nPos05] == cTmpHoFim

								If cTipoSTL == "M"
									aVRET := {.T.}
									aAdd( aVRET, cHelpMsg := STR0204 + Chr( 13 ) + Chr( 13 ) +;                                  // Já existe aplicação de insumo no intervalo de Data/Hora informada.
											STR0205 + ': ' + cTmpCod + Chr( 13 ) +;                                              // Código Insumo
											STR0206 + '....: ' + aDadosOS[ nXX, 1 ] + Chr( 13 ) +;                               // Ordem Serv
											STR0050 + '..............: ' + aDadosOS[ nXX, 2 ] + Chr( 13 ) +;                     // Plano
											STR0200 + '......: ' + dToC( dTmpDtIni ) + Chr( 13 ) +;                              // Data Inicio
											STR0201 + '......: ' + SubStr( cTmpHoIni, 1, 5 ) + Chr( 13 ) +;                      // Hora Inicio
											STR0202 + '.........: ' + dToC( dTmpDtFim ) + Chr( 13 ) +;                           // Data Fim
											STR0203 + '.........: ' + SubStr( cTmpHoFim, 1, 5 ) + Chr( 13 ) + Chr( 13 ) +;       // Hora Fim
											STR0167 + Chr( 13 ) + Chr( 13 ) +;                                                   // Aplicação do insumo já existente:
											STR0200 + '.....: ' + dToC( aDadosOS[ nXX, 5, nYY, nPos02 ] ) + Chr( 13 ) +;         // Data Inicio
											STR0201 + '.....: ' + SubStr( aDadosOS[ nXX, 5, nYY, nPos03 ], 1, 5 ) + Chr( 13 ) +; // Hora Inicio
											STR0202 + '........: ' + dToC( aDadosOS[ nXX, 5, nYY, nPos04 ] ) + Chr( 13 ) +;      // Data Fim
											STR0203 + '........: ' + SubStr( aDadosOS[ nXX, 5, nYY, nPos05 ], 1, 5 ) )           // Hora Fim
									Exit
								ElseIf cTipoSTL == "F"
									nQUATFEU++
									If nQUATFEU > nQUATISH4
										cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
										+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
										+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
										+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
										+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
										aVRET := {.T.,cHelpMsg}
										Exit
									EndIf
								EndIf

							ElseIf DtoS(dTmpDtIni)+cTmpHoIni < DtoS(aDadosOS[nXX,5][nYY,nPos04])+aDadosOS[nXX,5][nYY,nPos05] .And.;
							DtoS(dTmpDtFim)+cTmpHoFim > DtoS(aDadosOS[nXX,5][nYY,nPos02])+aDadosOS[nXX,5][nYY,nPos03]

								If cTipoSTL == "M"
									cHelpMsg := STR0204+ chr(13)+chr(13); //"Já existe aplicação de insumo no intervalo de Data/Hora informada."
									+ STR0205 + ": " + cTmpCod + chr(13); //"Código Insumo"
									+ STR0206 + "....: " + cTmpOrdem + chr(13); //"Ordem Serv"
									+ STR0050 + "..............: " + cTmpPlano + chr(13); //"Plano"
									+ STR0200 + "......: " + dtoc(dTmpDtIni) + chr(13); //"Data Inicio"
									+ STR0201 + "......: " + Substr(cTmpHoIni,1,5) + chr(13); //"Hora Inicio"
									+ STR0202 + ".........: " + dtoc(dTmpDtFim) + chr(13); //"Data Fim"
									+ STR0203 + ".........: " + Substr(cTmpHoFim,1,5) + chr(13)+chr(13); //"Hora Fim"
									+ STR0207 + chr(13)+chr(13); //"Aplicação do insumo já existente:"
									+ STR0206 + "....: " + aDadosOS[nXX,1] + chr(13); //"Ordem Serv"
									+ STR0050 + ".............: " + aDadosOS[nXX,2] + chr(13); //"Plano"
									+ STR0200 + ".....: " + dtoc(aDadosOS[nXX,5][nYY,nPos02]) + chr(13); //"Data Inicio"
									+ STR0201 + ".....: " + Substr(aDadosOS[nXX,5][nYY,nPos03],1,5) + chr(13); //"Hora Inicio"
									+ STR0202 + "........: " + dtoc(aDadosOS[nXX,5][nYY,nPos04]) + chr(13); //"Data Fim"
									+ STR0203 + "........: " + Substr(aDadosOS[nXX,5][nYY,nPos05],1,5) //"Hora Fim"
									aVRET := {.T.,cHelpMsg}
									Exit
								ElseIf cTipoSTL == "F"
									nQUATFEU++
									If nQUATFEU > nQUATISH4
										cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
										+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
										+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
										+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
										+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
										aVRET := {.T.,cHelpMsg}
										Exit
									EndIf
								EndIf
							EndIf
						EndIf
					Next nYY
				ElseIf ValType(aDadosOS[nXX,4]) == "A" .And. lRowCall
					For nYY := 1 To Len(aDadosOS[nXX,4])
						If aDadosOS[nXX,4][nYY,Len(aDadosOS[nXX,4][nYY])]
							Loop //Deletado
						EndIf
						If aDadosOS[nXX,4,nYY,nPosTip] == cTipoSTL .And. PadR(aDadosOS[nXX,4,nYY,nPosCod],nLenST1) == PadR(cTmpCod,nLenST1)
							If aDadosOS[nXX,4][nYY,nPos02] == dTmpDtIni .And. aDadosOS[nXX,4][nYY,nPos03] == cTmpHoIni .And. ;
							aDadosOS[nXX,4][nYY,nPos04] == dTmpDtFim .And. aDadosOS[nXX,4][nYY,nPos05] == cTmpHoFim

								If cTipoSTL == "M"
									aVRET := {.T.}
									aAdd( aVRET, cHelpMsg := STR0204 + Chr( 13 ) + Chr( 13 ) +;                                  // Já existe aplicação de insumo no intervalo de Data/Hora informada.
											STR0205 + ': ' + cTmpCod + Chr( 13 ) +;                                              // Código Insumo
											STR0206 + '....: ' + aDadosOS[ nXX, 1 ] + Chr( 13 ) +;                               // Ordem Serv
											STR0050 + '..............: ' + aDadosOS[ nXX, 2 ] + Chr( 13 ) +;                     // Plano
											STR0200 + '......: ' + dToC( dTmpDtIni ) + Chr( 13 ) +;                              // Data Inicio
											STR0201 + '......: ' + SubStr( cTmpHoIni, 1, 5 ) + Chr( 13 ) +;                      // Hora Inicio
											STR0202 + '.........: ' + dToC( dTmpDtFim ) + Chr( 13 ) +;                           // Data Fim
											STR0203 + '.........: ' + SubStr( cTmpHoFim, 1, 5 ) + Chr( 13 ) + Chr( 13 ) +;       // Hora Fim
											STR0167 + Chr( 13 ) + Chr( 13 ) +;                                                   // Aplicação do insumo já existente:
											STR0200 + '.....: ' + dToC( aDadosOS[ nXX, 4, nYY, nPos02 ] ) + Chr( 13 ) +;         // Data Inicio
											STR0201 + '.....: ' + SubStr( aDadosOS[ nXX, 4, nYY, nPos03 ], 1, 5 ) + Chr( 13 ) +; // Hora Inicio
											STR0202 + '........: ' + dToC( aDadosOS[ nXX, 4, nYY, nPos04 ] ) + Chr( 13 ) +;      // Data Fim
											STR0203 + '........: ' + SubStr( aDadosOS[ nXX, 4, nYY, nPos05 ], 1, 5 ) )           // Hora Fim
									Exit
								ElseIf cTipoSTL == "F"
									nQUATFEU++
									If nQUATFEU > nQUATISH4
										cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
										+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
										+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
										+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
										+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
										aVRET := {.T.,cHelpMsg}
										Exit
									EndIf
								EndIf

							ElseIf DtoS(dTmpDtIni)+cTmpHoIni < DtoS(aDadosOS[nXX,4][nYY,nPos04])+aDadosOS[nXX,4][nYY,nPos05] .And.;
							DtoS(dTmpDtFim)+cTmpHoFim > DtoS(aDadosOS[nXX,4][nYY,nPos02])+aDadosOS[nXX,4][nYY,nPos03]

								If cTipoSTL == "M"
									cHelpMsg := STR0204+ chr(13)+chr(13); //"Já existe aplicação de insumo no intervalo de Data/Hora informada."
									+ STR0205 + ": " + cTmpCod + chr(13); //"Código Insumo"
									+ STR0206 + "....: " + cTmpOrdem + chr(13); //"Ordem Serv"
									+ STR0050 + "..............: " + cTmpPlano + chr(13); //"Plano"
									+ STR0200 + "......: " + dtoc(dTmpDtIni) + chr(13); //"Data Inicio"
									+ STR0201 + "......: " + Substr(cTmpHoIni,1,5) + chr(13); //"Hora Inicio"
									+ STR0202 + ".........: " + dtoc(dTmpDtFim) + chr(13); //"Data Fim"
									+ STR0203 + ".........: " + Substr(cTmpHoFim,1,5) + chr(13)+chr(13); //"Hora Fim"
									+ STR0207 + chr(13)+chr(13); //"Aplicação do insumo já existente:"
									+ STR0206 + "....: " + aDadosOS[nXX,1] + chr(13); //"Ordem Serv"
									+ STR0050 + ".............: " + aDadosOS[nXX,2] + chr(13); //"Plano"
									+ STR0200 + ".....: " + dtoc(aDadosOS[nXX,4][nYY,nPos02]) + chr(13); //"Data Inicio"
									+ STR0201 + ".....: " + Substr(aDadosOS[nXX,4][nYY,nPos03],1,5) + chr(13); //"Hora Inicio"
									+ STR0202 + "........: " + dtoc(aDadosOS[nXX,4][nYY,nPos04]) + chr(13); //"Data Fim"
									+ STR0203 + "........: " + Substr(aDadosOS[nXX,4][nYY,nPos05],1,5) //"Hora Fim"
									aVRET := {.T.,cHelpMsg}
									Exit
								ElseIf cTipoSTL == "F"
									nQUATFEU++
									If nQUATFEU > nQUATISH4
										cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
										+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
										+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
										+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
										+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
										aVRET := {.T.,cHelpMsg}
										Exit
									EndIf
								EndIf
							EndIf
						EndIf
					Next nYY
				EndIf
			Else
				For nYY := 1 To Len(aCols)
					If aCols[nYY,Len(aCols[nYY])]
						Loop //Deletado
					EndIf
					If aCols[nYY,nPosTip] == cTipoSTL .And. nYY <> nPosCols .And. PadR(aCols[nYY,nPosCod],nLenST1) == PadR(cTmpCod,nLenST1)
						If aCols[nYY,nPos02] == dTmpDtIni .And. aCols[nYY,nPos03] == cTmpHoIni .And. ;
						aCols[nYY,nPos04] == dTmpDtFim .And. aCols[nYY,nPos05] == cTmpHoFim

							If cTipoSTL == "M"
								aVRET := {.T.,STR0167} //"Registro informado ja existe"
								Exit
							ElseIf cTipoSTL == "F"
								nQUATFEU++
								If nQUATFEU > nQUATISH4
									cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
									+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
									+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
									+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
									+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
									aVRET := {.T.,cHelpMsg}
									Exit
								EndIf
							EndIf

						ElseIf DtoS(dTmpDtIni)+cTmpHoIni < DtoS(aCols[nYY,nPos04])+aCols[nYY,nPos05] .And.;
						DtoS(dTmpDtFim)+cTmpHoFim > DtoS(aCols[nYY,nPos02])+aCols[nYY,nPos03]

							If cTipoSTL == "M"
								cHelpMsg := STR0204+ chr(13)+chr(13); //"Já existe aplicação de insumo no intervalo de Data/Hora informada."
								+ STR0205 + ": " + cTmpCod + chr(13); //"Código Insumo"
								+ STR0206 + "....: " + cTmpOrdem + chr(13); //"Ordem Serv"
								+ STR0050 + "..............: " + cTmpPlano + chr(13); //"Plano"
								+ STR0200 + "......: " + dtoc(dTmpDtIni) + chr(13); //"Data Inicio"
								+ STR0201 + "......: " + Substr(cTmpHoIni,1,5) + chr(13); //"Hora Inicio"
								+ STR0202 + ".........: " + dtoc(dTmpDtFim) + chr(13); //"Data Fim"
								+ STR0203 + ".........: " + Substr(cTmpHoFim,1,5) + chr(13)+chr(13); //"Hora Fim"
								+ STR0207 + chr(13)+chr(13); //"Aplicação do insumo já existente:"
								+ STR0206 + "....: " + cTmpOrdem + chr(13); //"Ordem Serv"
								+ STR0050 + ".............: " + cTmpPlano + chr(13); //"Plano"
								+ STR0200 + ".....: " + dtoc(aCols[nYY,nPos02]) + chr(13); //"Data Inicio"
								+ STR0201 + ".....: " + Substr(aCols[nYY,nPos03],1,5) + chr(13); //"Hora Inicio"
								+ STR0202 + "........: " + dtoc(aCols[nYY,nPos04]) + chr(13); //"Data Fim"
								+ STR0203 + "........: " + Substr(aCols[nYY,nPos05],1,5) //"Hora Fim"
								aVRET := {.T.,cHelpMsg}
								Exit
							ElseIf cTipoSTL == "F"
								nQUATFEU++
								If nQUATFEU > nQUATISH4
									cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
									+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
									+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
									+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
									+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
									aVRET := {.T.,cHelpMsg}
									Exit
								EndIf
							EndIf
						EndIf
					EndIf
				Next nYY
			EndIf

			If aVRET[1]
				Exit
			EndIf
		Next nXX

	EndIf

	If !aVRET[1]
		For nXArq := 1 to 2
			If nXArq == 1

				cAliasQry	:= GetNextAlias()
				cQuery		:= " SELECT STL.TL_ORDEM,"
				cQuery		+= "	STL.TL_PLANO, "
				cQuery		+= "    STL.TL_DTINICI, "
				cQuery		+= "    STL.TL_HOINICI, "
				cQuery		+= "    STL.TL_DTFIM, "
				cQuery		+= "    STL.TL_HOFIM, "
				cQuery		+= "    STL.TL_TIPOREG "
				cQuery		+= " FROM " +RetSqlName("STL")+ " STL "
				cQuery		+= " JOIN " + RetSqlName("STJ")+" STJ ON  STL.TL_ORDEM = STJ.TJ_ORDEM "
				cQuery		+= " AND STL.TL_PLANO = STJ.TJ_PLANO AND STJ.D_E_L_E_T_ = ' ' "
				cQuery		+= " WHERE STL.TL_FILIAL = '" +xFilial("STL")+ "' "
				cQuery		+= " AND (STL.TL_TIPOREG = 'M' OR  STL.TL_TIPOREG = 'F') "
				cQuery		+= " AND STL.TL_CODIGO = '"+cTmpCod+ "'"
				cQuery		+= " AND STL.TL_SEQRELA <> '0'
				cQuery		+= " AND ( '" +DtoS(dTmpDtIni)+cTmpHoIni+ "' < (STL.TL_DTFIM || STL.TL_HOFIM)
				cQuery		+= "	AND  '"+DtoS(dTmpDtFim)+cTmpHoFim+ "' >  (STL.TL_DTINICI || STL.TL_HOINICI) )
				cQuery		+= " AND STJ.TJ_SITUACA <> 'C'
				cQuery		+= " AND STL.D_E_L_E_T_ = ' ' "

			Else

				cAliasQry	:= GetNextAlias()

				cQuery		:= " SELECT STT.TT_ORDEM TL_ORDEM,"
				cQuery		+= "	STT.TT_PLANO TL_PLANO, "
				cQuery		+= "    STT.TT_DTINICI TL_DTINICI, "
				cQuery		+= "    STT.TT_HOINICI TL_HOINICI, "
				cQuery		+= "    STT.TT_DTFIM TL_DTFIM, "
				cQuery		+= "    STT.TT_HOFIM TL_HOFIM, "
				cQuery		+= "    STT.TT_TIPOREG TL_TIPOREG "
				cQuery		+= " FROM " +RetSqlName("STT")+ " STT "
				cQuery		+= " JOIN " + RetSqlName("STS")+" STS ON  STT.TT_ORDEM = STS.TS_ORDEM "
				cQuery		+= " AND STT.TT_PLANO = STS.TS_PLANO AND STS.D_E_L_E_T_ = ' ' "
				cQuery		+= " WHERE STT.TT_FILIAL = '" +xFilial("STT")+ "' "
				cQuery		+= " AND (STT.TT_TIPOREG = 'M' OR  STT.TT_TIPOREG = 'F') "
				cQuery		+= " AND STT.TT_CODIGO = '"+cTmpCod+ "'"
				cQuery		+= " AND STT.TT_SEQRELA <> '0'
				cQuery		+= " AND ( '" +DtoS(dTmpDtIni)+cTmpHoIni+ "' < (STT.TT_DTFIM || STT.TT_HOFIM)
				cQuery		+= "	AND  '"+DtoS(dTmpDtFim)+cTmpHoFim+ "' >  (STT.TT_DTINICI || STT.TT_HOINICI) )
				cQuery		+= " AND STS.TS_SITUACA <> 'C'
				cQuery		+= " AND STT.D_E_L_E_T_ = ' ' "

			EndIf

			cQuery		:= ChangeQuery( cQuery )
			dbUseArea(	.T., "TOPCONN", TCGENQRY( , , cQuery ), cAliasQry, .F., .T. )

			While !Eof()

				nLineTmp := aScan(aDadosOS, {|x| x[1]+x[2] == (cAliasQry)->TL_ORDEM+(cAliasQry)->TL_PLANO })
				If nLineTmp > 0
					If lRowCall
						If ValType(aDadosOS[nLineTmp,4]) == "A" .Or. ValType(aDadosOS[nLineTmp,5]) == "A" .Or. nLineOS == nLineTmp
							dbSelectArea(cAliasQry)
							dbSkip()
							Loop
						EndIf
					Else
						If ValType(aDadosOS[nLineTmp,5]) == "A" .Or. nLineOS == nLineTmp
							dbSelectArea(cAliasQry)
							dbSkip()
							Loop
						EndIf
					EndIf
				EndIf

				If (cAliasQry)->TL_TIPOREG == "M"

					cHelpMsg := STR0204+ chr(13)+chr(13); //"Já existe aplicação de insumo no intervalo de Data/Hora informada."
					+ STR0205 + ": " + cTmpCod + chr(13); //"Código Insumo"
					+ STR0206 + "....: " + cTmpOrdem + chr(13); //"Ordem Serv"
					+ STR0050 + "..............: " + cTmpPlano + chr(13); //"Plano"
					+ STR0200 + "......: " + dtoc(dTmpDtIni) + chr(13); //"Data Inicio"
					+ STR0201 + "......: " + Substr(cTmpHoIni,1,5) + chr(13); //"Hora Inicio"
					+ STR0202 + ".........: " + dtoc(dTmpDtFim) + chr(13); //"Data Fim"
					+ STR0203 + ".........: " + Substr(cTmpHoFim,1,5) + chr(13)+chr(13); //"Hora Fim"
					+ STR0207 + chr(13)+chr(13); //"Aplicação do insumo já existente:"
					+ STR0206 + "....: " + (cAliasQry)->TL_ORDEM + chr(13); //"Ordem Serv"
					+ STR0050 + ".............: " + (cAliasQry)->TL_PLANO + chr(13); //"Plano"
					+ STR0200 + ".....: " + dtoc(StoD((cAliasQry)->TL_DTINICI)) + chr(13); //"Data Inicio"
					+ STR0201 + ".....: " + Substr((cAliasQry)->TL_HOINICI,1,5) + chr(13); //"Hora Inicio"
					+ STR0202 + "........: " + dtoc(StoD((cAliasQry)->TL_DTFIM)) + chr(13); //"Data Fim"
					+ STR0203 + "........: " + Substr((cAliasQry)->TL_HOFIM,1,5) //"Hora Fim"
					aVRET := {.T.,cHelpMsg}
					Exit
				ElseIf (cAliasQry)->TL_TIPOREG == "F"
					nQUATFEU++
					If nQUATFEU > nQUATISH4
						cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
						+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
						+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
						+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
						+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
						aVRET := {.T.,cHelpMsg}
						Exit
					EndIf
				EndIf

				dbSelectArea( cAliasQry )
				dbSkip()
			End

			If aVRET[1]
				Exit
			EndIf

			(cAliasQry)->( DbCloseArea() )

		Next nXArq
	EndIf

	If aVRET[1]
		MsgInfo(aVRET[2],STR0037) //"Atenção"
		lRet := .F.
	EndIf

	PutFileInEof("STL")
	RestArea(aAreaSTJ)
	dbSelectArea(cOldAlias)
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ Mnt435Rod ³ Autor ³ Denis Hyroshi        ³ Data ³22/06/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Abre programa de rodizio da estrutura                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA400                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Mnt435Rod()

	Local cBEMPAI := cCdBemTJ
	Local aOldHea := aClone(aHeader)
	Local aOldRot := aClone(aRotina)
	Local aOldCol := aClone(aCols)
	Local cOrdem, cPlano

	cOrdem := (cAliOS435)->TJ_ORDEM
	cPlano := (cAliOS435)->TJ_PLANO
	dbSelectArea("STJ")
	dbSetOrder(01)
	If dbSeek(xFilial("STJ")+cOrdem+cPlano)
		dbSelectarea("STC")
		dbSetOrder(1)
		If !dbSeek(xFilial("STC")+cBEMPAI)
			Help(" ",1,"NGMBNEXEST")
		Else
			MNTA098(cBEMPAI)
		EndIf
	Else
		MsgInfo(STR0099) //"Nenhuma ordem de serviço foi selecionada."
	EndIf

	aHeader := aClone(aOldHea)
	aRotina := aClone(aOldRot)
	aCols   := aClone(aOldCol)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA435BAR
Altera o menu de opções

@return

@sample MNTA435BAR(oDlg,bOk,bCancel)
@param 	oDlg     , Objeto			, Painel principal
@param  bOk      , Bloco de código	, Ações a serem realizadas ao acionar o botão Ok
@param	bCancel  , Bloco de código	, Ações a serem realizadas ao acionar o botão Cancelar
@param 	aFields  , Array            , Array com os campos disponibilizados no Browse
@param  oBrwOS   , Objeto           , Tela principal

@author Alexandre Santos
@since 05/07/2017
/*/
//---------------------------------------------------------------------
Static Function MNTA435BAR( oDlg, bOk, bCancel, aFields, oBrwOS )
	Local oBar
	Local lPyme 	:= Iif(Type("__lPyme") <> "U",__lPyme,.F.)
	Local aButton 	:= {}
	Local nX 		:= 0
	Local lCCivil	:= GetNewPar("MV_NGMNTCC","N") == "S"

	DEFINE BUTTONBAR oBar SIZE 40, 40 TOP OF oDlg

	/*
		aButton[x][1] = Resource
		aButton[x][2] = Bloco de código definindo ação do botão
		aButton[x][3] = Descrição do botão
		aButton[x][4] = Nome do objeto botão
		aButton[x][5] = Visivel/Invisivel
	*/
	aButton := {;
		{ 'S4WB008N'	  , { || Calculadora() }				      , STR0209        , 'oBtCalc', .T.           },; // Calc ### Calculadora
		{ 'S4WB010N'	  , { || OurSpool() }				          , STR0210        , 'oBtSpl' , ''            },; // Spool
		{ 'S4WB016N'	  , { || HelProg() }					      , STR0211        , 'oBtAjd' , ''            },; // Ajuda
		{ 'BMPVISUAL'	  , { || NGLostFocus(), Mnt435Vis() }         , STR0212        , 'oBtVsl' , ''            },; // Visualizar ### Visualizar Ordem de Serviço
		{ 'PMSPRINT'	  , { || NGLostFocus(), Mnt435rel() }         , STR0214        , 'oBtImp' , ''            },; // Imprimir ### Imprimir Ordem de Serviço
		{ 'DESTINOS' 	  , { || NGLostFocus(), Mnt435Rod() }         , STR0216        , 'oBtRdz' , ''            },; // Rodízio ### Rodízio da Estrutura
		{ 'AVGARMAZEM'	  , { || NGLostFocus(), Mnt435Rat( aFields ) }, STR0218        , 'oBtRto' , lArvoreLogica },; // Rateio ### Rateio de Insumos
		{ 'BPMSDOCE'	  , 'Eval( {||NGLostFocus(), Mnt435Can()})'   , STR0220        , 'oBtCOS' , ''            },; // Canc. O.S ### Cancelar Ordem de Serviço
		{ 'SDUSETDEL'	  , 'Eval( {|| IIf( fValidOk(.F.,.T.), Mnt435Fin(), )} )', STR0222        , 'oBtFOS' , '' },; // Finaliz. O.S ### Finalizar Ordem de Serviço
		{ 'NG_ICO_LEGENDA', { || NGLostFocus(), Mnt435Leg() }         , STR0223        , 'oBtLgd' , ''            },; // Legenda ### Legenda das Ordens de Serviço
		{ 'SSFONTES'	  , { || Mnt435bCon() }				          , STR0225        , 'oBtBCn' , lPyme         },; // Conhecim. ### Banco de Conhecimento da Ordem de Serviço
		{ 'SALVAR'		  , { || Eval( bSalvar ) }				      , STR0226        , 'oBtGrv' , lArvoreLogica },; // Gravar ### Grava as informações
		{ 'NG_ICO_ALTBEMM', { || NGLostFocus(), MNT435MR( .T. ) }	  , STR0329        , 'oBtRMR' , lCCivil       },; // Medição Material Rodante
		{ 'OK'			  , { || Eval( bOk ) }					      , STR0423        , 'oBtOK'  , ''            },; // Ok ### Confirma
		{ 'CANCEL'		  , { || Eval( bCancel ) }				      , STR0227        , 'oBtCan' , ''            },; // Cancelar ### Cancelar - <Ctrl-X>"
		{ 'MNT_ICO_REABOS', { || fReabreOS( aFields ) }				  , STR0407        , 'oBtRea' , ''            };  // Reabertura
	}

	If STQ->( FieldPos( 'TQ_SEQRELA' ) ) > 0

		aAdd( aButton, { 'MNT_ICO_CONSOS', { || MNTC790() }, STR0408, 'oBtCon' , '' } )  // Consulta

	EndIf

	// Somente adiciona botão de buscar todas O.S.'s quando o processo vier diretamente do MNTA435
	If !lArvoreLogica
		// 'Aguarde' # 'Carregando O.S.' # 'Buscar Todas O.S. Abertas'
		aAdd( abutton, {"button_ng_435_1"  , {|| FWMsgRun( , { | | fLoadBrw( .T., aFields, .T. ) }, STR0402, STR0400 ) }, STR0401, "oBtBus", ""} ) //
	EndIf

	//Ponto de entrada para selecionar os botões que iram ser apresentados na EnchoiceBar
	If ExistBlock( 'MNTA435J' )

		aButton := aClone( ExecBlock( 'MNTA435J', .F., .F., { aButton } ) )

	EndIf

	For nX := 1 To Len(aButton)

		//Define propriedades de cada botão informado no aButton
		DEFINE BUTTON &(aButton[nX][4]) RESOURCE aButton[nX,1] OF oBar PROMPT "" TOOLTIP aButton[nX,3]

		/*----------------------------------------------------------------------------------------
		Para os botões que tiram registros do Browse (Finalização de O.s. e Cancelamento de O.s.)
		a execução do botão deve ser realizada utilizando o método Execute do FwFormBrowse, dessa
		forma o refresh acontece corretamente e o registro excluido é retirado da tela
		----------------------------------------------------------------------------------------*/
		If ValType(aButton[nX][2]) == 'C'
			&(aButton[nX][4]):bLClicked := &( "{ || NGLostFocus() .And. oBrwOS:Execute('"+aButton[nX][2]+"',4 ) }" )
		Else
			&(aButton[nX][4]):bLClicked := aButton[nX][2]
		EndIf

		&(aButton[nX][4]):lVisible := If(!Empty(aButton[nX][5]), aButton[nX][5], .T.)

		If aButton[nX][4] == "oBtOk"
			SetKEY(15,oBtOk:bAction)
		EndIf

		If aButton[nX][4] == "oBtCan"
			SetKEY(24,oBtCan:bAction)
		EndIf
	Next nX

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} Mnt435Rat
Faz a chamada para o Rateio de insumos

@type   Function

@author Vitor Emanuel Batista
@since  31/07/2009
@param 	aFields, Array, Array com os campos disponibilizados no Browse

/*/
//-------------------------------------------------------------------
Static Function Mnt435Rat( aFields )

	Local aArea := GetArea()

	dbSelectArea( 'STJ' )
	dbSetOrder( 1 )
	If msSeek( FwxFilial( 'STJ') + (cAliOS435)->TJ_ORDEM + (cAliOS435)->TJ_PLANO )

		MNTA402()

		// Devido as alterações realizadas pelo MNTA402 será necessário recarregar as informações
		fLoadBrw( .T., aFields, .T. )

	Else
		MsgInfo(STR0099) //"Nenhuma ordem de serviço foi selecionada."
	EndIf

	RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³NGLostFocus³Autor ³Vitor Emanuel Batista  ³ Data ³31/07/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Forca a saida de do objeto para executar validacoes         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA435                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NGLostFocus()

	lRet435 := .T.
	oBrwOS:SetFocus()
	If !lRet435 //Problema encontrado em alguma rotina de validacao da LinhaOK
		Return .F.
	EndIf

Return .T.

//----------------------------------------------------------------------
/*/{Protheus.doc} fValDel435
Valida exclusão de insumo realizado.
@type Function

@author Vitor Emanuel Batista
@since  31/07/2009

@param 	lGetDados, boolean, Indica se utiliza o objeto para validação.
@param 	[aArrTmp], array  , Detalhes do insumos especifico.
@param 	[nPosTp] , integer, Linha da GetDados corresponde o insumo.
@param 	lDel     , booelan, 

@return boolean, Indica se o contéudo informado é valido.
/*/
//----------------------------------------------------------------------
Function fValDel435( lGetDados, aArrTmp, nPosTp, lDel )

	Local cOLDALI:= ALIAS()
	Local aAreaTL:= STL->(GetArea())
	Local nInd1   := 0
	Local nInd2   := 0
	Local nPos01  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPos03  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPos16  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA" })
	Local nPos18  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	Local nPosNS  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSEQ"})
	Local nPosNSA := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSA"})
	Local nPosISA := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_ITEMSA"})
	Local nPosLoc := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"})
	Local nPosSqO := GDFieldPos( 'TL_SEQRELA', aHoBrw3_2 )
	Local nPosOS  := aScan( aDadosOS, { |x| Trim( Upper( x[1] ) ) == cOrdemTJ } )
	Local cKeySTL := "",nPosSav
	Local cNumSeq  := ''
	Local aTemp   := {},lTestaNF := .T.
	Local lVerDt  := !(STJ->TJ_SERVICO == 'HISTOR' .And. cUIntHis == 'N')

	Default nPosTp := oBrw6:nAt

	If !lGetDados

		aTemp  := aClone( aArrTmp )

	Else

		aTemp := aClone( oBrw6:aCols[nPosTp] )

	EndIf

	If SuperGetMV( 'MV_NG1ETPM', .F., 'N' ) == 'S'

		dbSelectArea(cTRBQ400)
		dbSetOrder( 6 ) // TQ_SEQRELA
		If msSeek( aTemp[nPos18] ) .And. !FWIsInCallStack( 'fDelInsum' )

			Help( '', 1, 'NGATENCAO',, STR0414, 3, 1 ) // Esse insumo não pode ser alterado ou excluído, pois está vinculado à uma execução de etapa.

			Return .F.

		EndIf

	EndIf

	If Readvar() == 'M->TL_TAREFA' .Or. Readvar() == 'M->TL_CODIGO' .Or. Readvar() == 'M->TL_LOCAL'

		For nInd1 := 1 To Len( aDadosOS[nPosOS,_OCCURRENCES_] )

			For nInd2 := 1 To Len( aDadosOS[nPosOS,_OCCURRENCES_,nInd1,_INSUMOCORRE_] )

				If aTemp[nPos18] == aDadosOS[nPosOS,_OCCURRENCES_,nInd1,_INSUMOCORRE_,nInd2,nPosSqO]

					Help( '', 1, 'NGATENCAO',, STR0422, 3, 1 ) // Esse insumo não pode ser alterado ou excluído, pois está vinculado à uma ocorrência.

					Return .F.

				EndIf

			Next nInd2
			
		Next nInd1

	EndIf

	If nPosNS > 0

		cNumSeq := aTemp[nPosNS]

	Else

		dbSelectArea('STL')
		dbSetOrder(1)
		If msSeek( FWxFilial('STL') + cOrdemTJ + cPlanoTJ + aTemp[nPos16] + aTemp[nPos01] + ;
			aTemp[nPos03] + aTemp[nPos18] )

			cNumSeq := STL->TL_NUMSEQ

		Endif

	EndIf

	//-----------------------------------------------------------------------
	// Valida alteração ou exclusão de insumo pneu que entrou na estrutura
	//-----------------------------------------------------------------------
	If cUsaInt3 == 'S' .And. ; // integração com estoque
		Alltrim( STJ->TJ_SERVICO ) == SuperGetMv( 'MV_NGSERPN', .F., '' ) .And.; // serviço mov. pneu
		!( Readvar()  $( "M->TL_DESTINO/M->TL_TAREFA" ) ) .AND.; // Não é tarefa nem destino
		( nPosDOS := aScan(aDadosOS,{|x| Trim(Upper(x[1])) == cOrdemTJ}) ) > 0 .And.; // posição da ordem
		( nPosSav := aScan(aDadosOS[nPosDOS,4] ,{|x| ; // posição do insumo
					x[nPos01] == aTemp[nPos01] .And.;
					x[nPos03] == aTemp[nPos03] .And.;
					x[nPos18] == aTemp[nPos18] }) ) > 0 .And.;
		aDadosOs[nPosDOS,4,nPosSav,nPos01] == 'P' .And. ; // insumo produto
		Val( aDadosOs[nPosDOS,4,nPosSav,nPos18] ) .And.; // insumo realizado
		ProdutoPn( aDadosOs[nPosDOS,4,nPosSav,nPos03],; // é um pneu
					aDadosOs[nPosDOS,4,nPosSav,nPosLoc], STJ->TJ_ORDEM )
		// "Este produto está relacionado a movimentação de pneu e não é permitido alterar\excluir por meio desta rotina."
		// "Utilize a rotina de rodados para esta finalidade."
		HELP( ' ', 1, "NGATENCAO",, STR0391, 2, 0,,,,,, { STR0394 } )
		Return .F.

	EndIf

	If Readvar() == "M->TL_LOTECTL" .Or. Readvar() == "M->TL_NUMLOTE" .Or. Readvar() == "M->TL_GARANTI"
		lTestaNF := .F.
	EndIf

	//Integração SIGAMNT x SIGALOC
    If SuperGetMV( 'MV_NG1LOC', .F., .F. ) .And. Readvar() == "M->TL_AS"
        lTestaNF := .F.
    EndIf

	If lTestaNF

		If ( cUsaInt3 == "S" .Or. cUsaInt2 == "S" ) .And. aTemp[nPos01] $ "P/M/T" .And. !aTemp[Len(aTemp)] .And. Val( aTemp[nPos18] ) > 0

			nPosDOS := aScan(aDadosOS,{|x| Trim(Upper(x[1])) == cOrdemTJ})

			If nPosDOS > 0 .And. !Empty( cNumSeq )
				nPosSav := aScan(aDadosOS[nPosDOS,4] ,{|x|  /*x[nPos16] == aTemp[nPos16] .And.*/ ;
				x[nPos01] == aTemp[nPos01] .And. ;
				x[nPos03] == aTemp[nPos03] .And. ;
				x[nPos18] == aTemp[nPos18] })

				If nPosSav > 0

					cMsgErro := STR0037 //"Atenção"

					If ValType( nPosTp ) == 'N'

						cMsgErro += STR0228 + AllTrim( Str( nPosTp, 9 ) ) //" - Linha:"

					EndIf

					If NGIFDBSEEK("SD1",cNumSeq,4,.F.) .And.;
						!( ReadVar() $ ( 'M->TL_DESTINO/M->TL_TAREFA/M->TL_ETAPA/M->TL_LOCAPLI' ) )

						MSGINFO(STR0229+chr(13); //"Esse insumo não pode ser alterado ou excluído, pois está vinculado à uma"
						+STR0230+chr(13); //"NF de Entrada. Para que essa alocação seja modificada, é necessário executar"
						+STR0231+chr(13); //"o acerto na NF de entrada através da transação Documento de Entrada."
						+STR0232+chr(13); //"Alertamos que, se o estoque já estiver fechado e a NF já tenha sido"
						+STR0233+chr(13); //"contabilizada, essa alteracão não será possível. Outra situação a ser"
						+STR0234+chr(13); //"considerada, é que a NF de entrada somente poderá ser modificada"
						+STR0235+chr(13); //"se a O.S vinculada a mesma ainda estiver em aberto. Se a OS estiver"
						+STR0236,cMsgErro) //"fechada, será necessário a reabertura da mesma."

						dbSelectArea( cOLDALI )

						Return .F.

					ElseIf NGIFDBSEEK( 'SD3', cNumSeq, 4, .F. ) .And.;
						!( ReadVar() $ ( 'M->TL_DESTINO/M->TL_TAREFA/M->TL_ETAPA/M->TL_LOCAPLI' ) )

						//------------------------------------
						// Valida data de fechamento do mês
						//------------------------------------
						If !NGCHKMESFE( SD3->D3_EMISSAO, aDadosOs[nPosDOS,4,nPosSav,nPos01], .F. )
							// 'Não é permitido alterar ou deletar um insumo com data menor que o fechamento do mês. Data de fechamento: '
							Help( '', 1, 'NGATENCAO',, STR0392  + CRLF + STR0393 + ': ' + Dtoc( dDtUlMes ),3,1)
							Return .F.
						EndIf

						//------------------------------------
						// Valida data de bloqueio do mês
						//------------------------------------
						If aDadosOs[nPosDOS,4,nPosSav,nPos01] $ 'P/M' .And. lVerDt .And. !MNTValDBl( SD3->D3_EMISSAO )
							Return .F.
						EndIf

						If NGCADICBASE("TL_ORIGNFE","A","STL",.F.)
							cTempONFE := ""
							cKeySTL := xFilial("STL") + cOrdemTJ + cPlanoTJ + aDadosOs[nPosDOS,4,nPosSav,nPos16] + aTemp[nPos01] + aTemp[nPos03] + aTemp[nPos18]
							dbSelectArea("STL")
							dbSetOrder(1) //TL_FILIAL+TL_ORDEM+TL_PLANO+TL_TAREFA+TL_TIPOREG+TL_CODIGO+TL_SEQRELA
							If dbSeek(cKeySTL)
								cTempONFE := STL->TL_ORIGNFE
							EndIf
							RestArea(aAreaTL)

							// Verifica se não está integrado com o BackOffice RM
							If AllTrim( SuperGetMV( 'MV_NGINTER', .F., 'N' ) ) != 'M'

								If lDel == Nil

									If cTempONFE == "SD3"
										MSGINFO(STR0237+chr(13)+; //"Esse insumo nao pode ser alterado ou excluido porque esta vinculado a uma"
										STR0238+Chr(13)+Chr(13)+; //"movimentacao originaria de um movimento interno do estoque."
										STR0239,; //"Operacao somente permitida pelo modulo Estoque/Custos."
										cMsgErro)

										dbSelectArea(cOLDALI)

										Return .F.

									ElseIf ( nPosNSA > 0 .And. !Empty(aDadosOs[nPosDOS,4,nPosSav,nPosNSA]) ) .Or.;
										( nPosISA > 0 .And. !Empty(aDadosOs[nPosDOS,4,nPosSav,nPosISA]) )
										//Verifica se tem o campo NUMSA ou ITEMSA preenchidos, se preenchido indica que veio de baixa/pré-requisição de SA
										MSGINFO(STR0237+space(1)+; //"Esse insumo não pode ser alterado ou excluído porque está vinculado a uma"
										STR0238+Chr(10)+Chr(10)+; //"movimentação originária de um movimento interno do estoque."
										STR0239) //"Operação somente permitida pelo módulo Estoque/Custos."
										dbSelectArea(cOLDALI)
										Return .F.
									EndIf

								EndIf

							EndIf

						EndIf

					EndIf

				EndIf

			EndIf

		EndIf

		If ExistBlock("MNTB4353")

			ExecBlock("MNTB4353",.F.,.F.,{aArrTmp,lDel})

		EndIf

	EndIf

	dbSelectArea(cOLDALI)

Return .T.

//----------------------------------------------------------------------
/*/{Protheus.doc} MNT435DelOk
Valida e realiza ações ao excluir de insumo realizado.
@type function

@author Alexandre Santos
@since  16/07/2025

@param
@return boolean, Indica se o contéudo informado é valido.
/*/
//----------------------------------------------------------------------
Function MNT435DelOk()

	Local aAreaSTL := STL->( FWGetArea() )
	Local cAlsSTL  := GetNextAlias()
	Local nPsSeq   := GDFieldPos( 'TL_SEQRELA', aHoBrw6 )
	Local nPsSeqO  := GDFieldPos( 'TL_SEQRELA', aHoBrw3_2 )
	Local nPosOS   := aScan( aDadosOS, { |x| Trim( Upper( x[1] ) ) == cOrdemTJ } )
	Local nPsIni   := oBrw6:nAt
	Local nPsIns   := 0
	Local nInd1    := 0
	Local nInd2    := 0
	Local lRet     := .F.

	/*---------------------------------+
	| Validações para excluir a linha. |
	+---------------------------------*/
	If ( lRet := fValDel435( .T., , , .T. ) )

		/*-----------------------------------+
		| Excluir associação com ocorrência. |
		+-----------------------------------*/
		For nInd1 := 1 To Len( aDadosOS[nPosOS,_OCCURRENCES_] )

			For nInd2 := 1 To Len( aDadosOS[nPosOS,_OCCURRENCES_,nInd1,_INSUMOCORRE_] )

				If oBrw6:aCols[nPsIni,nPsSeq] == aDadosOS[nPosOS,_OCCURRENCES_,nInd1,_INSUMOCORRE_,nInd2,nPsSeqO]

					aDadosOS[nPosOS,_OCCURRENCES_,nInd1,_INSUMOCORRE_,;
						nInd2,Len(aDadosOS[nPosOS,_OCCURRENCES_,nInd1,_INSUMOCORRE_,nInd2])] := .T.

				EndIf

			Next nInd2
			
		Next nInd1

		/*-----------------------------------------------------------------------+
		| Quando integrado ao RM, excluir insumos gerados na mesma movimentação. |
		+-----------------------------------------------------------------------*/
		If lIntRM .And. !lIsStack

			oBrw6:oBrowse:lDisablePaint := .T.

			dbSelectArea( 'STL' )
			dbSetOrder( 3 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_SEQRELA + TL_TAREFA + TL_TIPOREG + TL_CODIGO
			msSeek( FWxFilial( 'STL' ) + cOrdemTJ + cPlanoTJ + oBrw6:aCols[nPsIni,nPsSeq] )

			BeginSQL Alias cAlsSTL

				SELECT
					STL.TL_SEQRELA
				FROM
					%table:STL% STL
				WHERE
					STL.TL_FILIAL  =  %xFilial:STL%         AND
					STL.TL_NOTFIS  =  %exp:STL->TL_NOTFIS%  AND
					STL.TL_SERIE   =  %exp:STL->TL_SERIE%   AND
					STL.TL_SEQRELA <> %exp:STL->TL_SEQRELA% AND
					STL.%NotDel%

			EndSQL

			lIsStack := .T. // Controle de recursividade

			While (cAlsSTL)->( !EoF() )
				
				If ( nPsIns := aScan( oBrw6:aCols, { |x| x[nPsSeq] == (cAlsSTL)->TL_SEQRELA } ) ) > 0

					oBrw6:GoTo( nPsIns )	
					oBrw6:DelLine()

				EndIf

				(cAlsSTL)->( dbSkip() )
			
			End

			(cAlsSTL)->( dbCloseArea() )

			oBrw6:ForceRefresh()
			oBrw6:GoTo( nPsIni )

			oBrw6:oBrowse:lDisablePaint := .F.

			lIsStack := .F. // Controle de recursividade

		EndIf

	EndIf

	FWRestArea( aAreaSTL )

	FWFreeArray( aAreaSTL )
	
Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA435Mc
Valida insumo MDO com calendario.
@type Function

@author Inacio Luiz Kolling
@since  30/03/2011

@param 	[aCabec], array, Cabeçalho do GetDados que origina a chamada.

@return boolean, Indica se o contéudo informado é valido.
/*/
//---------------------------------------------------------------------
Function MNTA435MC( aCabec )

	Local nPos01   := 0
	Local nPos02   := 0
	Local nPos03   := 0

	Default aCabec := aClone( aHoBrw2 )

	nPos01 := GDFieldPos( 'TL_TIPOREG', aCabec )
	nPos02 := GDFieldPos( 'TL_CODIGO' , aCabec )
	nPos03 := GDFieldPos( 'TL_USACALE', aCabec )

	If aCols[n,nPos01] = "M" .And. aCols[n,nPos03] = "S" .And. Empty(aCols[n,nPos02])

		Help( " ", 1, "OBRIGAT", , + Chr(13) + NGRETTITULO("TL_CODIGO") + Space(35), 3 )

		Return .F.

	EndIf

Return .T.

//------------------------------------------------------------------------------
/*/{Protheus.doc} MNT435SEQ
Validacao para incremento do seqrela

@type Function

@author Taina A. Carodoso
@since 06/06/2011
@Param aColsSqe, array, aCols do registro
@Param lChange, logica, indica se o processo é de alteração
@Param nLnAt, numérica, linha posicionada no aCols

@return Caractere, retorna o valor do SEQRELA atualizado.
/*/
//------------------------------------------------------------------------------
Static Function MNT435SEQ( aColsSqe, lChange, nLnAt )

	Local nFor
	Local oldaCols, oldaHeader
	Local lPRIMLO := .T.
	Local nPos18  := aScan( aHoBrw2,{|x| Trim( Upper(x[2]) ) == "TL_SEQRELA" })
	Local nPosTp  := 0
	Local cSeqAtu := "0  "

	Default nLnAt := 0

	If nLnAt == 0

		nPosTp := oBrw6:oBrowse:nAt

	Else

		nPosTp := nLnAt

	EndIf


	If lChange .Or. (  Len(aColsSqe) >= nPosTp .And. ;
	( AllTrim(aColsSqe[ nPosTp , nPos18 ]) == "0" .Or. Empty(aColsSqe[ nPosTp , nPos18 ]) ))
		//Define maior sequencia atual
		For nFor := 1 To Len(aColsSqe)
			If Empty(aColsSqe[nFor,nPos18])
				Loop
			EndIf
			If Val(aColsSqe[nFor,nPos18]) > 0
				If Val(aColsSqe[nFor,nPos18]) > Val(cSeqAtu)
					cSeqAtu := aColsSqe[nFor,nPos18]
				EndIf
			ElseIf !IsDigit(Substr(aColsSqe[nFor,nPos18],1,1))
				cSeqAtu := If(lPRIMLO,aColsSqe[nFor,nPos18],If(aColsSqe[nFor,nPos18] > cSeqAtu,aColsSqe[nFor,nPos18],cSeqAtu))
				lPRIMLO := .F.
			EndIf
		Next nFor

		//Adiciona 1 à sequencia atual
		If Alltrim(cSeqAtu) == "0" .Or. Empty(cSeqAtu)
			cSeqAtu := PADR("1",3)
		Else
			If !lPRIMLO
				If FindFunction("Soma1Old")
					cSeqAtu := PADR(Soma1Old(cSeqAtu),3)
				Else
					cSeqAtu := PADR(Soma1(cSeqAtu),3)
				EndIf
			Else
				If FindFunction("Soma1Old")
					cSeqAtu := IIf( Val( cSeqAtu ) == 0,PADR( "1", 3),PADR( Soma1Old( cSeqAtu ), 3 ))
				Else
					cSeqAtu := IIf( Val( cSeqAtu ) == 0,PADR( "1", 3),PADR( Soma1( cSeqAtu ), 3 ))
				EndIf
			EndIf
		EndIf
	ElseIf Len(aColsSqe) >= nPosTp
		cSeqAtu := aColsSqe[ nPosTp , nPos18 ]
	EndIf

	oGd435Ocr:oBrowse:lDisablePaint := .F.
	oldaCols   := aClone(aColsSqe)
	oldaHeader := aClone(aHeader)

Return cSeqAtu

//----------------------------------------------------------------------------
/*/{Protheus.doc} MntF5Saldo
Consulta de saldo por endereço.
@type function

@author Robson Pereira
@since 11/01/2012

@param aHeSTL, array, Lista de campos do objeto GetDados Insumos.
@param aCoSTL, array, Conteúdo dos campos do objeto GetDados Insumos.

@return
/*/
//----------------------------------------------------------------------------
Function MntF5Saldo( aHeSTL, aCoSTL )

	Local cVar		 := ReadVar()
	Local nTLLOCALIZ := 0
	Local nTLNUMSERI := 0

	Default aHeSTL := aHoBrw6
	Default aCoSTL := aCols

	nTLLOCALIZ := aScan(aHeSTL,{|x| Trim( Upper(x[2]) ) == "TL_LOCALIZ" })
	nTLNUMSERI := aScan(aCoSTL,{|x| Trim( Upper(x[2]) ) == "TL_NUMSERI" })

	If cVar == "M->TL_LOCALIZ" .Or. cVar == "M->TL_NUMSERI"

		F4MNTLocal()

		M->TL_LOCALIZ := If(nTLLOCALIZ > 0, aCoSTL[n][nTLLOCALIZ], Space(TAMSX3("TL_LOCALIZ")[1]))
		M->TL_NUMSERI := If(nTLNUMSERI > 0, aCoSTL[n][nTLNUMSERI], Space(TAMSX3("TL_NUMSERI")[1]))

	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT435CANB ³Autor ³Hugo Rizzo Pereira     ³ Data ³20/03/2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Verifica se existe bloqueio para a baixa no estoque.       ³±±
±±³          ³ Caso exista, a movimencao nao deve ser efetuada.           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cKeySTL - Chave de pesquisa. (STL)                         ³±±
±±³          ³ Ordem + Plano + Seq. + Tarefa + TipoReg + Codigo           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ lRet - Retorna se existe um bloqueio para a movimentacao.  ³±±
±±³          ³        .T. - Nao existe bloqueio. Movimentacao permitida.  ³±±
±±³          ³        .F. - Existe bloqueio. Movimentacao cancelada.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Variaveis ³ lCanScan - Verifica se deve ou nao validar possiveis       ³±±
±±³          ³ bloqueios gerados. Caso a mesma seja falsa, define que     ³±±
±±³          ³ nao bloqueios a serem considerados.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA435                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MNT435CANB(cKeySTL)

	Local lCanScan := Type("aNBaixaEst") == "A" .And. Len( aNBaixaEst ) > 0
	Local lRet     := .T.

	Default cKeySTL := STL->TL_ORDEM + STL->TL_PLANO + STL->TL_SEQRELA + STL->TL_TAREFA + STL->TL_TIPOREG + STL->TL_CODIGO

	lRet := !lCanScan .Or. ( aScan( aNBaixaEst,{|x| x[1]+x[2]+x[3]+x[4]+x[5]+x[6] == cKeySTL }) == 0)

Return lRet

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT435CALLB
Função utilizada para chamar Funções dos botões de Insumo na tela de retorno de O.S..

@author André Felipe Joriatti
@since 06/12/2012
@version MP11
@param nOp: Indica a função a ser chamada.
oChv435: Objeto passado por referencia para funções fPrgNext( @oChv435 ) e fPrgNext( @oChv435 )
@return Nil
/*/
//---------------------------------------------------------------------------------------
Static Function MNT435CALLB( nOp )

	Local lRet  := .F.

	If ExistBlock( "MNTA4358" )
		lRet := ExecBlock( "MNTA4358",.F.,.F., { nOp,(cTRBIP) } )
		If !lRet
			Return .F.
		EndIf
	EndIf

	If nOp == 1 // "Incluir todos os insumos previstos."
		fPrgNext()
	ElseIf nOp == 2 // "Incluir o insumo previsto."
		f435Next()
	ElseIf nOp == 3 // "Excluir o insumo realizado."
		fDelInsumo( .F. )
	ElseIf nOp == 4 // "Excluir todos os insumos realizados."
		fDelInsumo( .T. )
	EndIf

Return

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT435RLOC()
Chama funÃ§Ã£o NGRELOCORRC de acordo com o parametro nOpc.

@author Felipe Helio dos Santos
@since 08/03/2013
@version MP10/MP11
@param nOpc: 1 = F10 2 = F11
/*/
//---------------------------------------------------------------------------------------
Static Function MNT435RLOC( nOpc )

	Local nPosPro := GDFieldPos( 'TN_CODOCOR', oGd435Ocr:aHeader )
	Local nPosCau := GDFieldPos( 'TN_CAUSA'  , oGd435Ocr:aHeader )

	If Type( 'lFocusBrw3' ) == 'L' .And. lFocusBrw3

		If nOpc == 1 //F10

			NGRELOCORRC( 'M->TN_CAUSA'  , oGd435Ocr:aCols[oGd435Ocr:nAt,nPosPro], 'P', .T., , 'TN_NOMCAUS', oGd435Ocr )

		ElseIf nOpc == 2 //F11

			NGRELOCORRC( 'M->TN_SOLUCAO', oGd435Ocr:aCols[oGd435Ocr:nAt,nPosCau], 'C', .T., , 'TN_NOMSOLU', oGd435Ocr )

		EndIf

	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} MNT435Cus
Retorna o custo de acordo com o tipo do insumo.
@type Function

@author Jackson Machado
@since  30/04/2013

@param 	[aCabec], array, Cabeçalho do GetDados que origina a chamada.
@return .T.
/*/
//-------------------------------------------------------------------
Function MNT435Cus( aCabec )

	Local nQtd    := 0 //Define a Quantidade
	Local nQtdRec := 0 //Define a Quantidade Recurso
	Local nPosTip := 0
	Local nPosPrd := 0
	Local nPosQtd := 0
	Local nPosCus := 0
	Local nPosRec := 0
	Local nPosLoc := 0
	Local cInsumo := "" // Define o Codigo do Insumo
	Local cTipIns := "" // Define o Tipo de Insumo

	//Verifica integracao com o estoque
	Local cIntEst	 := AllTrim( GetMv( "MV_NGMNTES" ) )
	Local cUIntHis   := AllTrim( GetMv( "MV_NGHISES" ))
	Local cLocal     := ""

	Default aCabec   := aClone( aHoBrw2 )

	nPosTip	:= GDFieldPos( 'TL_TIPOREG', aCabec )
	nPosPrd	:= GDFieldPos( 'TL_CODIGO' , aCabec )
	nPosQtd	:= GDFieldPos( 'TL_QUANTID', aCabec )
	nPosCus	:= GDFieldPos( 'TL_CUSTO'  , aCabec )

	cTipIns	:= aCols[n,nPosTip]
	nQtd	:= aCols[n,nPosQtd]
	cInsumo	:= aCols[n,nPosPrd]

	If ( nPosRec := GDFieldPos( 'TL_QUANREC', aCabec ) ) > 0

		nQtdRec	:= aCols[n,nPosRec]

	EndIf

	If ( nPosLoc := GDFieldPos( 'TL_LOCAL'  , aCabec ) ) > 0

		cLocal  := aCols[n,nPosLoc]

	EndIf

	Do Case

		Case 'TL_CODIGO' $ ReadVar()

			cInsumo	:= M->TL_CODIGO

		Case 'TL_QUANTID' $ ReadVar()

			nQtd	:= M->TL_QUANTID

		Case 'TL_QUANREC' $ ReadVar()

			nQtdRec	:= M->TL_QUANREC

		Case 'TL_LOCAL' $ ReadVar()

			cLocal	:= M->TL_LOCAL

	End Case

	//Verifica se o campo TL_CUSTO está contido no aHoBrw2 para validar Custo da M.O. (Verificar PE MNTA435E).
	If nPosCus > 0

		If cIntEst == "S" // Atribui o valor apenas quando tiver integração com o Estoque

			// Define os valores de acordo com o campo que esta sendo alterado
			If ( "TL_TIPOREG" $ ReadVar() .And. aCols[ n , nPosTip ] <> M->TL_TIPOREG ) .Or. nQtd == 0
				aCols[ n , nPosCus ] := 0 // Caso altere o Tipo de Insumo, zera o custo
			Else

				If STJ->TJ_SERVICO <> "HISTOR"
					aCols[ n , nPosCus ] := Round( NGCALCUSTI( cInsumo, cTipIns, nQtd, cLocal, , , , nQtdRec , "1" ) , 2 )//Atribui o custo ja tratado, passando sempre ele como 'realizado'
				ElseIf STJ->TJ_SERVICO == "HISTOR" .And. cUIntHis == "N" .And. cTipIns <> "P"
					aCols[ n , nPosCus ] := Round( NGCALCUSTI( cInsumo, cTipIns, nQtd, cLocal, , , , nQtdRec , "1" ) , 2 )//Atribui o custo ja tratado, passando sempre ele como 'realizado'
				ElseIf cUIntHis == "S"
					aCols[ n , nPosCus ] := Round( NGCALCUSTI( cInsumo, cTipIns, nQtd, cLocal, , , , nQtdRec , "1" ) , 2 )//Atribui o custo ja tratado, passando sempre ele como 'realizado'
				EndIf

			EndIf

		ElseIf cTipIns == "M"

			dbSelectArea( 'ST1' )
			dbSetOrder( 1 ) // T1_FILIAL + T1_CODFUNC
			msSeek( FWxFilial( 'ST1' ) + cInsumo )

			If cIntEst == 'N'
							
				If !Empty( ST1->T1_SALARIO )

					aCols[n,nPosCus] := ( ST1->T1_SALARIO * nQtd )
				
				Else

					aCols[n,nPosCus] := 0

				EndIf

			Else

				aCols[n,nPosCus] := Round( NGCALCUSTI( cInsumo, cTipIns, nQtd, , , , , nQtdRec, "1", , aCols[n,nPosCus] ), 2 )

			EndIf

		EndIf

	EndIf

Return .T.

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT435SEL()
Marca os insumos previstos.

@author Pedro Henrique Soares de Souza
@since 25/11/2013
/*/
//---------------------------------------------------------------------------------------
Static Function MNT435SEL()

	RecLock((cTRBIP),.F.)

	If Marked("TL_OK")
		(cTRBIP)->TL_OK := cMARCA
	Else
		(cTRBIP)->TL_OK := ""
	EndIf

	(cTRBIP)->(MSUNLOCK())

	oBrw2:oBrowse:Refresh()

Return

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT435ALL()
Marca todos os insumos previstos.

@author Pedro Henrique Soares de Souza
@since 25/11/2013
/*/
//---------------------------------------------------------------------------------------
Static Function MNT435ALL()

	Local aArea     := GetArea()
	Local aAreTRBIP := (cTRBIP)->(GetArea())

	dbSelectArea(cTRBIP)
	dbGoTop()
	While !EoF()

		Reclock((cTRBIP), .F.)
		(cTRBIP)->TL_OK := If( Empty( (cTRBIP)->TL_OK ), cMarca, Space( TAMSX3('TQ_OK')[1]) )
		(cTRBIP)->(MsUnLock())

		dbSelectArea(cTRBIP)
		dbSkip()
	EndDo

	oBrw2:oBrowse:Refresh()

	RestArea(aAreTRBIP)
	RestArea(aArea)

Return
//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT435ETAL()
Marca todas as etapas.

@author Tainã Alberto Cardoso
@since 07/05/2014
/*/
//---------------------------------------------------------------------------------------
Static Function MNT435ETAL()

	Local aArea := GetArea()
	Local aAreaTrb := (cTRBQ400)->( GetArea() )

	dbSelectArea(cTRBQ400)
	dbGoTop()
	While !EoF()

		Reclock( cTRBQ400, .F. )

			If Empty( (cTRBQ400)->TQ_OK )

				(cTRBQ400)->TQ_OK := cMarca //cMarca

			Else
			
				(cTRBQ400)->TQ_OK	   := Space( TAMSX3('TQ_OK')[1] )
				(cTRBQ400)->TQ_CODFUNC := Space( TamSX3('TQ_CODFUNC')[1] )

			EndIf

		MsUnLock()

		fMNTA405() //Mostra tela de resposta da etapa (se etapa for de responder)

		fLegendEt((cTRBQ400)->TQ_TAREFA+(cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_SEQETA) //Define as cores para legenda de etapas

		dbSelectArea(cTRBQ400)
		dbSkip()

	EndDo

	Fd_Sai( 4 )

	oBrw4:Refresh()
	oBrw4:Refresh()

	RestArea(aAreaTrb)
	RestArea(aArea)

Return
//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNTA435EFI ()
Consistencia final das etapas e respostas

@author Tainã Alberto Cardoso
@since 07/05/2014
/*/
//---------------------------------------------------------------------------------------
Static Function MNTA435EFI()

	Local aAreaTRB := (cTRBQ400)->( GetArea() )
	Local aAreaTPA := TPA->( GetArea() )
	Local aAreaTPQ := TPQ->( GetArea() )

	dbSelectArea(cTRBQ400)
	dbGotop()
	While !EoF()
		If !Empty((cTRBQ400)->TQ_OK)

			dbSelectArea("TPA")
			dbSetOrder(1)
			If dbSeek(xFilial("TPA")+(cTRBQ400)->TQ_ETAPA)

				If TPA->TPA_OPCOES <> '0'

					dbSelectArea(cTRB3400)
					dbSetOrder(1)
					If dbSeek((cTRBQ400)->TQ_ETAPA)

						lREPOS := .F.

						While !EoF() .And. (cTRB3400)->TPC_ETAPA = (cTRBQ400)->TQ_ETAPA
							If !Empty((cTRB3400)->TPC_OK)
								lREPOS := .T.
								Exit
							EndIf
							dbSkip()
						End

						If !lREPOS
							MsgInfo( STR0260 + " " + (cTRBQ400)->TQ_ETAPA + "  " + STR0023 + " " + (cTRBQ400)->TQ_TAREFA, STR0261 ) //"Não foi selecionado as respostas das opcões da etapa" ## "Tarefa" ## "NÃO CONFORMIDADE"
							Return .F.
						EndIf
					Else
						dbSelectArea("TPQ")
						dbSetOrder(1)
						If !dbSeek( xFilial("TPQ") + STJ->TJ_ORDEM + STJ->TJ_PLANO + (cTRBQ400)->TQ_TAREFA + (cTRBQ400)->TQ_ETAPA )
							MsgInfo( STR0260 + " " + (cTRBQ400)->TQ_ETAPA + "  " + STR0023 + " " + (cTRBQ400)->TQ_TAREFA, STR0261 ) //"Não foi selecionado as respostas das opcões da etapa" ## "Tarefa"  "NÃO CONFORMIDADE"
							Return .F.
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		dbSelectArea(cTRBQ400)
		dbSkip()
	EndDo

	RestArea(aAreaTPQ)
	RestArea(aAreaTPA)
	RestArea(aAreaTRB)

Return .T.

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} fSaveResp()
Salva as respostas das etapas na tabela temporária (cTRB3400)

@author Pedro Henrique Soares de Souza
@since 03/12/2014

@param cEtapa		- Etapa genérica respondida
@param cTarefa		- Tarefa correspondente a etapa
@param aCposAlter	- Campos utilizados para gravação

@return Nil Nulo
/*/
//---------------------------------------------------------------------------------------
Function fSaveResp( cEtapa, cTarefa, aCposAlter )
	//Armazena área da tabela TPC antes de posicionar na tabela para gravação da TRB
	Local aAreaTPC := TPC->(GetArea())
	Local nX, nI, i, x, y
	For nX := 1 To nItens
		dbSelectArea("TPC")
		dbSetOrder(1)
		If !dbSeek(xFilial("TPC") + cEtapa + aCols[nx][nnOPCA]) .Or. Empty(aCols[nX][nOK])
			Loop
		EndIf
		dbSelectArea(cTRB3400)
		dbSetOrder(1)
		dbGoTop()
		If !dbSeek( cEtapa + cTarefa + aCols[nX][nnOPCA] )
			RecLock(cTRB3400, .T.)
			dbSelectArea("TPC")
			dbSetOrder(1)
			If dbSeek(xFilial("TPC") + cEtapa + aCols[nX][nnOPCA])
				For i := 1 To FCount()
					x  := "TPC->" + FieldName(i)
					y  := cTRB3400 + "->" + FieldName(i)
					Replace &y. with &x.
				Next i
				If Len(aCposAlter) > 0
					For nI := 1 To Len(aCposAlter)
						nPosCpo := aScan(aHeader,{|x| AllTrim(x[2]) == aCposAlter[nI]})
						If nPosCpo > 0
							(cTRB3400)->(FieldPut(FieldPos(aCposAlter[nI]),aCols[nx][nPosCpo]))
						EndIf
					Next nI
				EndIf
				(cTRB3400)->TPC_RESPOS := aCols[nx][nRESPOS]
				(cTRB3400)->TPC_OK     := "XX"
				(cTRB3400)->TPC_TAREFA := cTarefa
				(cTRB3400)->TPC_ETAPA  := cEtapa
				(cTRB3400)->(MsUnLock())
			EndIf
		EndIf
	Next nX
	//Restaura área da tabela TPC
	RestArea(aAreaTPC)
Return Nil

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} fPesqEsp()
Pesquisa por codigo ou nome na tela de funcionarios da especialidade

@author Thiago Olis Machado
@since 08/06/2016

@return Nil
/*/
//---------------------------------------------------------------------------------------
Static Function fPesqEsp( aOS2 , oOS2, cPesquisar )

	Local nPos := 0

	nPos := aScan( aOS2, { |x| AllTrim(x[2]) == AllTrim(cPesquisar) } )

	If nPos > 0
		oOS2:nAt := nPos
		oOS2:Refresh()
	Else
		nPos := aScan( aOS2, { |x| AllTrim(cPesquisar) $ AllTrim(x[3]) } )
		If nPos > 0
			oOS2:nAt := nPos
			oOS2:Refresh()
		EndIf
	EndIf

Return Nil

//---------------------------------------------------------------------------------------
/*/{Proteus.doc} fLegendEt
Atualiza o status da etapa conforme legenda definida.
@static

@author Alexandre Santos
@since 23/10/2017

fLegendEt("cChave")

@param  cChave, Caracter, Chave de busca para a TRB
@return Nil
/*/
//---------------------------------------------------------------------------------------
Static Function fLegendEt( cChave, nIndic )

	Local cCodFam	:= ""
	Local cTempMed	:= ""
	Local aAreaSTQ  := STQ->( FWGetArea() )
	Local aAreaSTL  := STL->( FWGetArea() )
	Local aAreaTRB  := (cTRBQ400)->( FWGetArea() )

	Default nIndic  := 2 // TQ_TAREFA + TQ_ETAPA + TQ_SEQETA

	dbSelectarea( cTRBQ400 )
	dbSetOrder( nIndic )
	msSeek( cChave )

	cCodFam  := NGSEEK("ST9", STJ->TJ_CODBEM, 1, "T9_CODFAMI")
	cTempMed := NGSEEK("TVT", cCodFam + (cTRBQ400)->TQ_ETAPA, 2, "TVT_TEMPO")
	cTempMed := Val(cTempMed)

	RecLock(cTRBQ400, .F.)
	dbSelectArea("STL")
	dbSetOrder(1)
	If dbSeek(xFilial("STL")+(cTRBQ400)->TQ_ORDEM + (cTRBQ400)->TQ_PLANO + (cTRBQ400)->TQ_TAREFA + "M")
		(cTRBQ400)->QUANTID := 0
		(cTRBQ400)->SEQRELA := 0
		While !EoF() .And. STL->TL_FILIAL == xFilial("STL") .And. STL->TL_ORDEM == (cTRBQ400)->TQ_ORDEM .And. STL->TL_PLANO == (cTRBQ400)->TQ_PLANO;
				.And. STL->TL_TAREFA == (cTRBQ400)->TQ_TAREFA .And. STL->TL_TIPOREG == "M"

			If STL->TL_ETAPA != (cTRBQ400)->TQ_ETAPA .Or. STL->TL_SEQRELA == '0'
				dbSelectArea("STL")
				dbSkip()
				Loop
			EndIf

			dbSelectArea( cTRBQ400 )
			dbSetOrder( nIndic )
			If msSeek( cChave )
				(cTRBQ400)->QUANTID	+= STL->TL_QUANTID
			Else
				(cTRBQ400)->QUANTID	:= STL->TL_QUANTID
			EndIf

			(cTRBQ400)->SEQRELA	:= Val(STL->TL_SEQRELA)

			dbSelectArea("STL")
			dbSkip()

		EndDo
		If !Empty((cTRBQ400)->TQ_OK)
			(cTRBQ400)->STATUS := '1'
		ElseIf Empty((cTRBQ400)->TQ_OK) .And. (cTRBQ400)->SEQRELA != 0 .And. !Empty(cTempMed)
			If (cTRBQ400)->QUANTID	<= cTempMed
				(cTRBQ400)->STATUS := '3'
			Else
				(cTRBQ400)->STATUS := '4'
			EndIf
		ElseIf Empty((cTRBQ400)->TQ_OK) .And. (cTRBQ400)->SEQRELA != 0 .And. Empty(cTempMed)
			(cTRBQ400)->STATUS := '2'
		ElseIf Empty((cTRBQ400)->TQ_OK)
			(cTRBQ400)->STATUS := '2'
		EndIf
	Else

		dbSelectArea( cTRBQ400 )
		dbSetOrder( nIndic )
		If msSeek( cChave )

			If !Empty((cTRBQ400)->TQ_OK)
				(cTRBQ400)->STATUS := '1'
			ElseIf Empty((cTRBQ400)->TQ_OK)
				(cTRBQ400)->STATUS := '2'
			EndIf

		EndIf

	EndIf

	(cTRBQ400)->(MsUnlock())

	FWRestArea( aAreaTRB )
	FWRestArea( aAreaSTL )
	FWRestArea( aAreaSTQ )

Return

//---------------------------------------------------------------------------------------
/*/{Proteus.doc} fMntCabec

@author Maicon André Pinheiro
@since  04/05/2018
/*/
//---------------------------------------------------------------------------------------
Static Function fMntCabec()

	Local nInd     := 0
	Local nTot     := 0
	Local nTamanho := 0
	Local nDecimal := 0
	Local aCampos  := { 'TX_OK', 'TP1_OPCAO', 'TPC_DESOPC', 'TP1_BEMIMN', 'TP1_TIPCAM', 'TPQ_RESPOS' }
	Local cCampo   := ""
	Local cArquivo := ""
	Local cTitulo  := ""
	Local cPicture := ""
	Local cValid   := ""
	Local cUsado   := ""
	Local cTipo    := ""
	Local cContext := ""
	Local cF3      := ""
	Local cWhen    := ""

	nTot := Len(aCampos)
	For nInd := 1 To nTot

		cCampo   := aCampos[nInd]
		cArquivo := Posicione("SX3",2,cCampo,"X3_ARQUIVO")
		If (cArquivo)->(FieldPos(cCampo)) > 0

			cTitulo  := AllTrim(Posicione("SX3",2,cCampo,"X3Titulo()"))
			cPicture := X3Picture(cCampo)
			nTamanho := TAMSX3(cCampo)[1]
			nDecimal := TAMSX3(cCampo)[2]
			cValid   := Posicione("SX3",2,cCampo,"X3_VALID")
			cUsado   := Posicione("SX3",2,cCampo,"X3_USADO")
			cTipo    := Posicione("SX3",2,cCampo,"X3_TIPO")
			cContext := Posicione("SX3",2,cCampo,"X3_CONTEXT")
			cF3      := Posicione("SX3",2,cCampo,"X3_F3")
			cWhen    := Posicione("SX3",2,cCampo,"X3_WHEN")

			If cCampo == "TX_OK"
				cTitulo := ""
			ElseIf cCampo $ 'TP1_OPCAO/TP1_TIPCAM/TPC_DESOPC
				cWhen := ".F."
			ElseIf cCampo == "TP1_BEMIMN"
				cTitulo := STR0185 // "Tp. Respost."
				cWhen   := ".F."
			ElseIf cCampo == "TPQ_RESPOS"
				cTitulo := STR0059 // "Resposta"
				cValid  := "FE405TPVAR()"
			EndIf

			nUsado++
			aAdd(aHeader,{cTitulo,cCampo,cPicture,nTamanho,nDecimal,cValid,cUsado,cTipo,cArquivo,cContext,cF3,cWhen})

		EndIf

	Next nInd

Return

//------------------------------------------------------------------------------
/*/{Protheus.doc} fStatus
Define o status dos insumos previstos de acordo com os insumos realizados
	'0' - Não aplicado
	'1' - Parcialmente Aplicado
	'2' - Totalmente aplicado

@author Wexlei Silveira
@autor Maria Elisandra de Paula
@since 11/12/2018
@return Nil
/*/
//------------------------------------------------------------------------------
Static Function fStatus()

	Local nIndex     := 0
	Local nPCodigo   := aScan( aHoBrw6, { | x | Trim( Upper( x[ 2 ] ) ) == "TL_CODIGO" } )
	Local nPTarefa   := aScan( aHoBrw6, { | x | Trim( Upper( x[ 2 ] ) ) == "TL_TAREFA" } )
	Local nPTiporeg  := aScan( aHoBrw6, { | x | Trim( Upper( x[ 2 ] ) ) == "TL_TIPOREG" } )
	Local nPQuantid  := aScan( aHoBrw6, { | x | Trim( Upper( x[ 2 ] ) ) == "TL_QUANTID" } )
	Local nNSA       := GDFieldPos( 'TL_NUMSA' , aHoBrw6 )
	Local nISA       := GDFieldPos( 'TL_ITEMSA', aHoBrw6 )
	Local nNSC       := GDFieldPos( 'TL_NUMSC' , aHoBrw6 )
	Local nISC       := GDFieldPos( 'TL_ITEMSC' , aHoBrw6 )
	Local nLine      := 0
	Local nQuantid   := 0 //quantidade do insumo realizado
	Local cCodigo    := "" //código do insumo realizado
	Local cTiporeg   := "" //tipo do insumo realizado
	Local nSizeField := TamSx3( "T2_CODFUNC" )[ 1 ]
	Local cStatus    := ""

	dbSelectArea( cTRBIP )
	dbGoTop()
	While !(cTRBIP)->( EoF() )

		nQuantid := 0


		// Somente para insumos do tipo Produto e que possuam vinculo com uma S.A.
		If (cTRBIP)->TL_TIPOREG == 'P' .And. ( nNSA > 0 .And. !Empty( (cTRBIP)->TL_NUMSA ) ) .And.;
			( nISA .And. !Empty( (cTRBIP)->TL_ITEMSA ) )

			nLine := 0

			// Considera a quantidade somente de insumos aplicados vinculados a mesma S.A.
			If nNSA > 0 .And. nISA > 0 .And. ( ( nLine := aScan( aCoBrw6, { |x| x[nNSA] == (cTRBIP)->TL_NUMSA .And.;
				x[nISA] == (cTRBIP)->TL_ITEMSA } ) ) > 0 )

				nQuantid := aCoBrw6[nLine,nPQuantid]

			EndIf

		ElseIf lIntRM .And. (cTRBIP)->TL_TIPOREG $ 'P\T' .And. ( nNSC > 0 .And. !Empty( (cTRBIP)->TL_NUMSC ) ) .And.;
			( nISC .And. !Empty( (cTRBIP)->TL_ITEMSC ) )

			// Considera a quantidade somente de insumos aplicados vinculados a mesma S.C.
			If nNSC > 0 .And. nISC > 0 .And. ( ( nLine := aScan( aCoBrw6, { |x| x[nNSC] == (cTRBIP)->TL_NUMSC .And.;
				x[nISC] == (cTRBIP)->TL_ITEMSC } ) ) > 0 )

				nQuantid := aCoBrw6[nLine,nPQuantid]

			EndIf

		Else

			For nIndex := 1 To Len( aCoBrw6 )

				cTiporeg := aCoBrw6[ nIndex, nPTiporeg ]
				cCodigo  := aCoBrw6[ nIndex, nPCodigo ]

				//----------------------------------------------------
				//Comparação de insumos previstos x insumos realizados
				//----------------------------------------------------
				If AllTrim( (cTRBIP)->TL_TAREFA ) == AllTrim( aCoBrw6[ nIndex, nPTarefa ] ) ;
					.And. ( ( Alltrim( (cTRBIP)->TL_TIPOREG ) == "E" .And. AllTrim( cTiporeg ) == "M" ;
					.And. NGIFDBSEEK( "ST2", Padr( cCodigo, nSizeField )  + Alltrim( (cTRBIP)->TL_CODIGO ), 1 ) ) ;
					.Or. ( AllTrim( (cTRBIP)->TL_TIPOREG ) == AllTrim( cTiporeg ) ;
					.And. AllTrim( (cTRBIP)->TL_CODIGO ) == AllTrim( cCodigo ) ) )

					//Soma a quantidade de insumos que já foram aplicados
					nQuantid += aCoBrw6[ nIndex, nPQuantid ]
				EndIf
			Next nIndex

		EndIf

		If nQuantid == 0
			cStatus := "0" //'0' - Não aplicado
		ElseIf nQuantid < (cTRBIP)->TL_QUANTID
			cStatus := "1" //'1' - Parcialmente Aplicado
		ElseIf nQuantid >= (cTRBIP)->TL_QUANTID
			cStatus := "2" //'2' - Totalmente aplicado
		EndIf

		//----------------------------------------------
		//Atualiza legenda/status dos insumos previstos
		//----------------------------------------------
		RecLock( (cTRBIP), .F. )
		(cTRBIP)->STATUS := cStatus
		MsUnLock()

		(cTRBIP)->( dbSkip() )

	EndDo

Return

//------------------------------------------------------------------------------
/*/{Protheus.doc} fUpdInput
Filtra os insumos previstos.

@author Wexlei Silveira
@since 13/12/2018
@return nil
/*/
//------------------------------------------------------------------------------
Static Function fUpdInput()

	LoadInsum(M->TJ_ORDEM, M->TJ_PLANO, aScan(aDadosOS, {|x| x[1] + x[2] == M->TJ_ORDEM + M->TJ_PLANO }), oBrw6:oBrowse:nAt)

	dbSelectArea(cTRBIP)
	dbGoTop()
	While !EoF()

		RecLock((cTRBIP),.F.)

		If (cTRBIP)->STATUS == "1" .And. !lPartInput
			DbDelete()
		ElseIf (cTRBIP)->STATUS == "2" .And. !lTotInput
			DbDelete()
		ElseIf (cTRBIP)->STATUS == "0" .And. !lPendInput
			DbDelete()
		EndIf

		MsUnLock()

		dbSelectArea(cTRBIP)
		DbSkip()
	End

	//Atualiza Insumos Previstos
	(cTRBIP)->(dbGoTop())
	oBrw2:oBrowse:Refresh()
	oPnlInput:Enable()

Return nil

//--------------------------------------------------------------
/*/{Protheus.doc} MNTA435Log
Apresenta log com inconsistências no processo de gravação das O.S .
@type function

@author Alexandre Santos
@since 06/02/2019

@param aMsgRM    , array, Ordens que não podem ser canceladas
@param aMsgCancel, array, Lista de registros que não puderam ser
gravados pois já estavam cancelados.
							[1] - Ordem de Serviço
							[2] - Plano de Manutenção
@return
/*/
//--------------------------------------------------------------
Function MNTA435Log( aMsgRM, aMsgCancel )

	Local nX       := 0
	Local cText    := ''
	Local cOrder   := ''
	Local cPlano   := ''
	Local cFile    := ''
	Local cTipReg  := ''
	Local cDescIns := ''
	Local cDescTar := ''
	Local oPnl     := Nil
	Local oDlg     := Nil
	Local bSave    := { || ( cFile := cGetFile( STR0372, STR0373 ), If( cFile == '', .T., MemoWrite( IIf( '.txt' $ cFile, cFile, AllTrim( cFile ) + '.txt' ), cText ) ), oDlg:End() ) }

	Default aMsgRM     := {}
	Default aMsgCancel := {}

	DEFINE MSDIALOG oDlg TITLE STR0375 From 3,0 TO 340,417 COLOR CLR_BLACK,CLR_WHITE PIXEL // Inconsistências de gravação

		oPnl := TPanel():New( ,,, oDlg,,,,,,,, .F., .F. )
			oPnl:Align := CONTROL_ALIGN_ALLCLIENT

			oMemo := tMultiGet():New( 5 , 5 , {|u| If( Pcount() > 0 , cText := u , cText )} , oDlg , 200 , 145,,,,,,.T.,,,,,, .T. )
			oMemo:bRClicked := { || AllwaysTrue() }
			oMemo:lReadOnly := .T.

			SButton():New( 153, 145, 13, bSave, oDlg, .T. ) //Salvar Como
			SButton():New( 153, 175, 01, { || oDlg:End() }, oPnl, .T. ) // OK

			// Montagem da estrutura da mensagem de LOG para inconsitêsncias no processo de gravação de insumos.
			If !Empty( aMsgRM )

				oMemo:AppendText( '#######################################################' + CRLF )

				// Foram encontradas inconsistências no processo de integração.
				oMemo:AppendText( CRLF + STR0390 + CRLF + CRLF )

				For nX := 1 To Len( aMsgRM )

					cTipReg := IIf( aMsgRM[nX, 5] == 'P', STR0127, STR0365 ) //Produto # Mão de Obra

					If aMsgRM[nX, 5] == 'P'
						cDescIns := Posicione( 'SB1', 1, xFilial( 'SB1' ) + aMsgRM[nX, 6], 'B1_DESC' )
					Else
						cDescIns := Posicione( 'ST1', 1, xFilial( 'ST1' ) + aMsgRM[nX, 6], 'T1_NOME' )
					EndIf

					cDescTar := Posicione( 'TT9', 1, xFilial( 'TT9' ) + aMsgRM[nX, 4], 'TT9_DESCRI' )

					If cPlano != aMsgRM[nX, 3] .Or. cOrder != aMsgRM[nX, 2]

						oMemo:AppendText( '-------------------------------------' + CRLF )

						oMemo:AppendText( STR0366 + aMsgRM[nX, 2] + CRLF ) // Ordem de Serviço
						oMemo:AppendText( STR0367 + aMsgRM[nX, 3] + CRLF + CRLF ) // Plano Manutenção

					EndIf

					oMemo:AppendText( STR0376 + Trim( aMsgRM[nX, 4] ) + ' - ' + cDescTar + CRLF ) //Tarefa:
					oMemo:AppendText( STR0368 + cTipReg          + CRLF ) // Tipo Insumo
					oMemo:AppendText( STR0374 + Trim( aMsgRM[nX, 6] ) + ' - ' + cDescIns + CRLF ) //Código:
					oMemo:AppendText( STR0369 + aMsgRM[nX, 7] + CRLF ) //Seq. Insumo
					oMemo:AppendText( STR0370 + aMsgRM[nX, 8] + CRLF ) //Seq. SD3
					oMemo:AppendText( STR0371 + aMsgRM[nX, 1] + CRLF ) //Inconsistência

					cOrder := aMsgRM[nX, 2]
					cPlano := aMsgRM[nX, 3]

				Next nX

			EndIf

			// Montagem da estrutura da mensagem de LOG para inconsitêsncias no processo de alteração de O.S.
			If !Empty( aMsgCancel )

				oMemo:AppendText( CRLF + '#######################################################' + CRLF + CRLF )

				// Algumas alterações não foram gravadas, pois as ordens de serviço listadas a seguir foram canceladas por meio de outra rotina ou usuário.
				oMemo:AppendText( STR0388 + CRLF + CRLF )

				For nX := 1 To Len( aMsgCancel )

					oMemo:AppendText( '---------------------------------' + CRLF )
					oMemo:AppendText( STR0366 + aMsgCancel[nX,1] + CRLF ) // Ordem de Serviço
					oMemo:AppendText( STR0367 + aMsgCancel[nX,2] + CRLF ) // Plano Manutenção

				Next Nx

				oMemo:AppendText( '---------------------------------' + CRLF )

				// Atualize a listagem de ordens de serviço no browse principal da rotina ou realize a reabertura das ordens de serviço listadas pela rotina MNTA260.
				oMemo:AppendText( CRLF + STR0389 + CRLF )

			EndIf

			oMemo:GoTop()

	ACTIVATE MSDIALOG oDlg CENTERED

Return

//--------------------------------------------------------------
/*/{Protheus.doc} fValInsOco
Valida o insumo selecionado ao mudar para folder de ocorrências

@author Maria Elisandra de Paula
@since 10/06/2019

@param nPosInsumo, numerico, posição do insumo no acols
@param nPos, numerico, posição do campo tiporeg no acols de insumos
@param nPox, numerico, posição do campo código no acols de insumos

@return boolean
/*/
//--------------------------------------------------------------
Static Function fValInsOco( nPosInsumo, nPos, nPox )

	Local lOkOcor := .T.

	If Len( aCoBrw6 ) == 1 .And. Empty( aCoBrw6[ 1, nPos ] ) .And. Empty( aCoBrw6[ 1, nPox ] )
		//"As Ocorrências devem ser relacionadas aos insumos realizados" # "mas no momento não existe nenhum insumo realizado."
		MsgInfo( STR0377 + Space( 1 ) + STR0378 )
		lOkOcor := .F.
	EndIf

	//-------------------------------------
	//O insumo selecionado está deletado
	//-------------------------------------
	If lOkOcor .And. ( nPosInsumo > Len( aCoBrw6 ) .Or. ;
		aCoBrw6[ nPosInsumo, Len( aCoBrw6[ nPosInsumo ] ) ] )
		//"As Ocorrências estão relacionadas aos insumos realizados mas o insumo selecionado está deletado."
		MsgInfo( STR0377 + Space( 1 ) + STR0380 )
		lOkOcor := .F.
	EndIf

	If lOkOcor .And. Empty( aCoBrw6[ nPosInsumo, nPos ] ) .And. Empty( aCoBrw6[ nPosInsumo, nPox ] )
		//"As Ocorrências estão relacionadas aos insumos realizados mas o insumo selecionado não está preenchido."
		MsgInfo( STR0377 + Space( 1 ) + STR0379 )
		lOkOcor := .F.
	EndIf

Return lOkOcor

//-----------------------------------------------------------------------
/*/{Protheus.doc} fRecord
Verifica se a etapa já está gravada no banco com funcionário preenchido

@author Maria Elisandra de Paula
@since 10/06/2019

@param cTRBQ400, string, tabela temporária de etapas
@return boolean
/*/
//-----------------------------------------------------------------------
Static Function fRecord( cTRBQ400 )

	Local lRecorded := .F.
	Local cAliasQry := GetNextAlias()

	BeginSQL Alias cAliasQry

		SELECT TQ_OK
		FROM %table:STQ% STQ
		WHERE TQ_FILIAL = %xFilial:STQ%
			AND TQ_ORDEM = %exp:(cTRBQ400)->TQ_ORDEM%
			AND TQ_PLANO = %exp:(cTRBQ400)->TQ_PLANO%
			AND TQ_TAREFA = %exp:(cTRBQ400)->TQ_TAREFA%
			AND TQ_ETAPA = %exp:(cTRBQ400)->TQ_ETAPA%
			AND TQ_CODFUNC <> %exp:' '%
			AND %NotDel%

	EndSQL

	lRecorded := !( cAliasQry )->( Eof() )

	( cAliasQry )->( dbCloseArea() )

Return lRecorded

//-------------------------------------------------------------------
/*/{Protheus.doc} ProdutoPn
Verifica se insumo é um pneu

@author Maria Elisandra de Paula
@since 09/06/2021
@param cProduto, string, código do produto
@param cLocal, string, código do almxarifado
@param cOrdem, string, código da ordem de serviço
@return logic, se insumo é um pneu
/*/
//-------------------------------------------------------------------
Static Function ProdutoPn( cProduto, cLocal, cOrdem )

	Local lRet      := .F.
	Local cAliasQry := GetNextAlias()

	BeginSQL Alias cAliasQry
		SELECT COUNT( TQZ.TQZ_CODBEM ) QNT
		FROM %table:TQZ% TQZ
		JOIN %table:STZ% STZ
			ON STZ.TZ_FILIAL = %xFilial:STZ%
			AND STZ.TZ_ORDEM = %exp:cOrdem%
			AND STZ.TZ_CODBEM = TQZ.TQZ_CODBEM
			AND TQZ.TQZ_DTSTAT || TQZ.TQZ_HRSTAT <= STZ.TZ_DATAMOV || STZ.TZ_HORAENT
			AND STZ.%NotDel%
		WHERE TQZ.%NotDel%
			AND TQZ.TQZ_PRODUT = %exp:cProduto%
			AND TQZ.TQZ_ALMOX = %exp:cLocal%
			AND TQZ.TQZ_FILIAL = %xFilial:TQZ%

	EndSql

	lRet := (cAliasQry)->QNT > 0

	(cAliasQry)->( dbCloseArea() )

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fQntEmp
Retorna a quantidade de produtos empenhada para a ordem de serviço

@author Maria Elisandra de Paula
@since 27/04/2021
@param cProduto, string, código do produto
@param cAlmox, string, código do almoxarifado
@param cOrdem, string, código da ordem de serviço
/*/
//-------------------------------------------------------------------
Static Function fQntEmp( cProduto, cAlmox, cOrdem )

	Local nReturn   := 0
	Local cAliasQry := GetNextAlias()
	Local cCodProd  := Padr( cProduto, TamSx3('D4_COD')[1] )
	Local cOPD4     := Padr( cOrdem + 'OS001', TamSx3('D4_OP')[1] )

	BeginSql Alias cAliasQry

		SELECT ISNULL( SUM ( SD4.D4_QUANT ), 0 ) QUANT
		FROM %Table:SD4% SD4
		WHERE SD4.%NotDel%
			AND SD4.D4_OP = %Exp:cOPD4%
			AND SD4.D4_COD = %Exp:cCodProd%
			AND SD4.D4_LOCAL = %Exp:cAlmox%
			AND SD4.D4_FILIAL = %xFilial:SD4%

	EndSql

	nReturn += (cAliasQry)->QUANT

	(cAliasQry)->( dbCloseArea() )

Return nReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} fCriaTRB
Cria Arquivo temporário.

@type   Static Function
@author Eduardo Mussi
@since

@param cAliasTRB, caracter, Alias Tabela Temporária
@param aFldSTJ  , array   , Array com os campos utilizados no TRB
@param aPesq    , array   , Array com os indices do Browse
@param aFieldFil, array   , Array com os campos que serão apresentados no filtro do browse

@return
/*/
//---------------------------------------------------------------------
Static Function fCriaTRB( cAliasTRB, aFldSTJ, aPesq, aFieldFil )

	Local aDBF   := {}
	Local nIndex := 0

	// Cria estrutura do TRB com base no dicionário
	For nIndex := 1 To Len( aFldSTJ )
		aAdd( aDBF, { aFldSTJ[ nIndex, 1 ], aFldSTJ[ nIndex, 3 ], aFldSTJ[ nIndex, 4 ], 0 } )
		aAdd( aFieldFil, { aFldSTJ[ nIndex, 1 ], aFldSTJ[ nIndex, 2 ], aFldSTJ[ nIndex, 3 ], aFldSTJ[ nIndex, 4 ], 0, '' } )
	Next nIndex

	// Adiciona campos essenciais para o funcionamento da rotina
	If aScan( aFldSTJ, { | x | x[ 1 ] == 'TJ_DTPPINI' } ) == 0
		aAdd( aDBF,	{ 'TJ_DTPPINI', 'D', TamSx3( 'TJ_DTPPINI' )[ 1 ], 0 } )
		aAdd( aFieldFil, { 'TJ_DTPPINI', FwX3Titulo( 'TJ_DTPPINI' ),'D', TamSx3( 'TJ_DTPPINI' )[ 1 ], 0, '' } )
	EndIf

	If aScan( aFldSTJ, { | x | x[ 1 ] == 'TJ_DTMPFIM' } ) == 0
		aAdd( aDBF,	{ 'TJ_DTMPFIM', 'D', TamSx3( 'TJ_DTMPFIM' )[ 1 ], 0 } )
		aAdd( aFieldFil, { 'TJ_DTMPFIM', FwX3Titulo( 'TJ_DTMPFIM' ),'D', TamSx3( 'TJ_DTMPFIM' )[ 1 ], 0, '' } )
	EndIf

	If aScan( aFldSTJ, { | x | x[ 1 ] == 'TJ_TIPORET' } ) == 0
		aAdd( aDBF, { 'TJ_TIPORET', 'C', TamSx3( 'TJ_TIPORET' )[ 1 ], 0 } )
		aAdd( aFieldFil, { 'TJ_TIPORET', FwX3Titulo( 'TJ_TIPORET' ),'C', TamSx3( 'TJ_TIPORET' )[ 1 ], 0, '' } )
	EndIf

	aAdd( aDBF, { 'RECNO', 'N', 16, 0 } )

	// Instancia classe FWTemporaryTable
	oTmpTblOS := FWTemporaryTable():New( cAliasTRB, aDBF )

	/*----------------------------------------+
	| Inclui os indices na tabela temporária. |
	+----------------------------------------*/
	fAddIndex( aDBF, @aPesq )

	oTmpTblOS:Create()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fAddIndex
Adiciona indices ao objeto da tabela temporári.
@type   function

@author Alexandre Santos
@since  22/06/2023

@param aFields, array, Lista com os campos que disponiveis no browse.
@param aPesq  , array, Lista com os indices do Browse

@return
/*/
//---------------------------------------------------------------------
Static Function fAddIndex( aFields, aPesq )

	Local aIndAux := {}
	Local aValInd := {}
	Local aIndSIX := FWSIXUtil():GetAliasIndexes( 'STJ' )
	Local nInd1   := 0

	/*-----------------------------------------------------+
	| Valida todos os indices disponiveis para tabela STJ. |
	+-----------------------------------------------------*/
	For nInd1 := 1 To Len( aIndSIX )

		If !Empty( aIndAux := fIndTRB( aFields, aIndSIX[ nInd1 ] ) )

			/*-------------------------------------------------------------------+
			| Realiza a validação dos indices antes de inclui-los na temporária. |
			+-------------------------------------------------------------------*/
			fValInd( aIndAux, @aValInd )

		EndIf

	Next nInd1

	/*--------------------------------------------------+
	| Inclui os indices validados na tabela temporária. |
	+--------------------------------------------------*/
	For nInd1 := 1 To Len( aValInd )

		If !Empty( aValInd[nInd1] )

			oTmpTblOS:AddIndex( cValToChar( nInd1 ), aClone( aValInd[nInd1] ) )

			aAdd( aPesq, { aOrdIx435[nInd1], { { '', 'C', 255, 0, '', '@!' } }, 2 } )

		EndIf

	Next nInd1

	FWFreeArray( aIndAux )
	FWFreeArray( aValInd )
	FWFreeArray( aIndSIX )

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fIndTRB
Cria indice para o browse

@type   Function

@author Eduardo Mussi
@since  19/08/2022
@param  aDBF, array, Array com os campos utilizados no TRB
@param  aSIX, array, Array com os Indices da tabela

@return Array, retorna indice para adição no TRB
/*/
//-------------------------------------------------------------------
Static Function fIndTRB( aDBF, aSIX )

	Local aIndTRB := {}
	Local cField  := ''
	Local nQtdSIX := Len( aSIX )
	Local nFldSIX

	For nFldSIX := 1 To nQtdSIX

		If 'DTOS' $ Upper( aSIX[ nFldSix ] )
			cField := StrTran( SubStr( aSIX[ nFldSix ], 6, Len( aSIX[ nFldSix ] ) ), ')', '' )
		Else
			cField := aSIX[ nFldSIX ]
		EndIf

		If ( nPosFld := aScan( aDBF, { | x | x[ 1 ] == cField } ) ) > 0
			aAdd( aIndTRB, cField )
		EndIf

	Next nFldSIX

Return aIndTRB

//-------------------------------------------------------------------
/*/{Protheus.doc} fValInd
Realiza validação do indice a ser adicionado
@type   Function

@author Eduardo Mussi
@since  12/04/2023

@param  aIndAdd, array, Array com o indice que será adicionado ao TRB
@param  aIndOld, array, Array com os indices já adicionados no TRB

@return Lógico, define se o indice será adicionado ao TRB
/*/
//-------------------------------------------------------------------
Static Function fValInd( aIndAdd, aIndOld )

	Local nInd     := 0
	Local nInd2    := 0
	Local lReturn  := .T.
	Local nSizInd1 := Len( aIndAdd ) // Tamanho do novo indice

	/*------------------------------------------------------------+
	| Percorre todos os índices já inclusos no array de controle. |
	+------------------------------------------------------------*/
	For nInd := 1 To Len( aIndOld )

		nSizInd2 := Len( aIndOld[ nInd ] ) // Tamanho do indice atual

		If nSizInd2 == 0

			Loop

		EndIf

		lReturn := .F.

		/*----------------------------------------------------------------------------------+
		| Percorre todos os campos do índice posiciona que já incluso no array de controle. |
		+----------------------------------------------------------------------------------*/
		For nInd2 := 1 To nSizInd2

			/*-------------------------------------------------------------------------------+
			| Se o tamanho do indice incluso é menor que o índice posiciona, encerra o loop. |
			+-------------------------------------------------------------------------------*/
			If nInd2 > nSizInd1

				Exit

			EndIf

			/*--------------------------------------------------------------------------------------------+
			| Se existirem campos diferentes entre o indice incluso e o índice posiciona, encerra o loop. |
			+--------------------------------------------------------------------------------------------*/
			If aIndOld[ nInd, nInd2 ] != aIndAdd[ nInd2 ]

				lReturn := .T.

				Exit

			EndIf

		Next nInd2

		If !lReturn

			/*-----------------------------------------------------------------------------------------------+
			| Se o indice incluso sobrepõe um indice no array de controle, sobrescreve o array de controle. |
			+-----------------------------------------------------------------------------------------------*/
			If nSizInd1 > nSizInd2

				/*----------------------------------------------------------+
				| Zera o índice na posição sobreposta do array de controle. |
				+----------------------------------------------------------*/
				aIndOld[nInd] := {}

				lReturn := .T.

			EndIf

			Exit

		EndIf

	Next nInd

	If lReturn

		/*----------------------------------------+
		| Adiciona o índice no array de controle. |
		+----------------------------------------*/
		aAdd( aIndOld, aIndAdd )

	Else

		/*-----------------------------------------------------------------------------------------------+
		| Adiciona o posição vazia no array de controle. Para manter a ordem dos indices dentro do array |
		+-----------------------------------------------------------------------------------------------*/
		aAdd( aIndOld, {} )

	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fGerCol
Gera as Colunas do Browse conforme os campos informados no aFldCon.

@type   Static Function

@author Eduardo Mussi
@since  23/11/17

@param  cAliasTRB, Caracter - Alias pela tabela temporária.

@return oColuna Objeto Objeto da Coluna
@example - fCreateCol( "{ | | ALIAS->CAMPO }" )
/*/
//---------------------------------------------------------------------
Static Function fGerCol( aFields )

	Local aColu := {}
	Local nInd 	:= 0

	//Cria Colunas do Browse
	For nInd := 1 To Len( aFields )
		aAdd( aColu, fCreateCol( "{ | | (cAliOS435)->" + aFields[ nInd, 1 ] + " }", aFields[ nInd ] ) )
	Next nInd

Return aColu

//---------------------------------------------------------------------
/*/{Protheus.doc} fCreateCol
Criação das Colunas do Browse.

@type  Static Function

@author Eduardo Mussi
@since 23/11/17
@version P12

@param  cDadosCol, Caracter, Indica a busca do valor do campo
		aFieldSTJ, Array   , Estrutura do campo
							[ 1 ] - Campo
							[ 2 ] - Titulo
							[ 3 ] - Tipo
							[ 4 ] - Tamanho
							[ 5 ] - Picture

@return oColuna Objeto Objeto da Coluna
/*/
//---------------------------------------------------------------------
Static Function fCreateCol( cDadosCol, aFieldSTJ )

	Local aArea		  := GetArea()
	// Objeto de criação das colunas do Browse
	Local oColumn
	// [LGPD] Caso o usuário não possua acesso ao(s) campo(s), deve-se ofuscá-lo(s)
	Local lOfuscar := FindFunction( 'FWPDCanUse' ) .And. FwPdCanUse( .T. );
				  	 .And. Len( FwProtectedDataUtil():UsrAccessPDField( __CUSERID, { aFieldSTJ[ 1 ] } ) ) == 0

	//Adiciona as colunas do Browse
	oColumn := FWBrwColumn():New()      // Cria objeto
	oColumn:SetData( &( cDadosCol ) )   // Define valor
	oColumn:SetEdit( .F. )	      	    // Indica se é editavel
	oColumn:SetTitle( aFieldSTJ[ 2 ] )  // Define titulo
	oColumn:SetType( aFieldSTJ[ 3 ] )   // Define tipo
	oColumn:SetSize( aFieldSTJ[ 4 ] )	// Define tamanho
	oColumn:SetPicture( aFieldSTJ[ 5 ] )// Define picture
	oColumn:SetReadVar( aFieldSTJ[ 1 ] )// Define o nome da coluna
	If lOfuscar
		oColumn:SetObfuscateCol( .T. )  // Define que coluna será ofuscada
	EndIf

	RestArea(aArea)

Return oColumn

//---------------------------------------------------------------------
/*/{Protheus.doc} fLoadBrw()
Efetua busca dos funcionários disponiveis e passaos resgistros
para o arquivo temporário

@type   Static Function

@author Eduardo Mussi
@since  18/05/2022
@param  lClearTemp, Lógico  , Define se deverá limpar tabela temporária de O.S.
@param  aFldSTJ   , Array   , Array com os campos disponibilizados no Browse
@param  lLoadOS   , Lógico  , Se deverá ser carregada O.S.'s no Browse
@param  [cChv902] , Caracter, Chave de pesquisa para quando a chamada vier do MNTA902

/*/
//---------------------------------------------------------------------
Static Function fLoadBrw( lClearTemp, aFldSTJ, lLoadOS, cChv902 )

	Local cSerefor  := Alltrim( SuperGetMv( 'MV_NGSEREF', .F., '' ) )
	Local aServRef  := StrTokArr( cSerefor, ';' )
	Local cSercons  := Alltrim( SuperGetMv( 'MV_NGSECON', .F., '' ) )
	Local aServCon  := StrTokArr( cSercons, ';' )
	Local cAliasQry := GetNextAlias()
	Local cCodPai   := Space( TamSX3( 'TJ_ORDEPAI' )[ 1 ] )
	Local cBanco    := AllTrim( TCGetDB() )
	Local cFilter   := "%"
	Local cCast     := ''
	Local cFilPE    := ''
	Local lValidTUA := .F.
	Local lObserva  := .F.
	Local nSumFields
	Local nCount
	Local nX
	Local aVrtFlds  := {}
	Local aIniSTJ   := {}
	Local oHashSTJ
	Local lIncluiBkp   := Inclui


	// Tratamento criado para que por padrão seja verificado a ST9, pois quando a chamada
	// é feita pela Planta(MNTA907 ) deverá ser validado pela TAF.
	Local cInnerJoin := ''
	Local cFields    := "% "
	Local lPlantaGra := IsInCallStack('MNTA907')

	Default cChv902 := ''
	
	// Necessário para garantir a execução correta da função VDISP no carregamento de campos virtuais
	Inclui := .F.

	If lClearTemp

		// Limpa Tabela Temporária para apresentar corretamente os dados da consulta
		NGZap( oTmpTblOS:GetRealName() )

		aDadosOS := {}

	EndIf

	// Se a chamada for pelo MNTA435 diretamente, faz o carregamento dos dados
	// Caso a chamada for do MNTA902 ou MNTA904, valida permissões de acesso à informações
	If lLoadOS .Or. ( !Empty( cChv902 ) .And. ( lValidTUA := NGValidTUA( 'STJ' ) ) )

		If ExistBlock( 'MNTA400O' )
			cFilPE := " AND " + ExecBlock( 'MNTA400O', .F., .F. )
		EndIf

		If IsInCallStack( 'MNTA902' )

			// Tratamento para carregar corretamente as informações para quando a O.S. for de uma localização
			cInnerJoin := "% LEFT JOIN " + RetSQLName( 'TAF' ) + " TAF "
			cInnerJoin += " ON ( TAF.TAF_FILIAL = " + ValToSQL( FwxFilial( 'TAF' ) ) + " AND STJ.TJ_CODBEM = TAF.TAF_CODNIV AND STJ.TJ_TIPOOS = 'L' AND TAF.TAF_MODMNT = 'X' AND  TAF.D_E_L_E_T_= ' ' ) "
			cInnerJoin += " LEFT JOIN " + RetSQLName( 'ST9' ) + " ST9 "
			cInnerJoin += "ON ( ST9.T9_FILIAL = " + ValToSQL( FwxFilial( 'ST9' ) ) + " AND STJ.TJ_CODBEM = ST9.T9_CODBEM AND STJ.TJ_TIPOOS = 'B' AND ST9.D_E_L_E_T_= ' ' ) %"

			// Filtro aplicado na Query
			cFilter    += " STJ.TJ_ORDEM = " + ValToSQL( cChv902 )
			cFilter    += cFilPE
			cFilter    += " AND STJ.D_E_L_E_T_= ' ' %"

		ElseIf lPlantaGra
			// Inner Join com TAF
			cInnerJoin := "% INNER JOIN " + RetSQLName( 'TAF' ) + " TAF "
			cInnerJoin += " ON ( TAF.TAF_FILIAL = " + ValToSQL( FwxFilial( 'TAF' ) ) + " AND STJ.TJ_CODBEM = TAF.TAF_CODNIV AND TAF.TAF_MODMNT = 'X' AND TAF.D_E_L_E_T_= ' ' ) %"

			// Filtro aplicado na Query
			cFilter += " STJ.TJ_TIPOOS || STJ.TJ_CODBEM = " + ValToSQL( cChv902 )
			cFilter += 	cFilPE
			cFilter += " AND STJ.TJ_SITUACA = 'L' "
			cFilter += " AND STJ.TJ_TERMINO = 'N' "
			cFilter += " AND STJ.D_E_L_E_T_= ' ' %"
		Else
			// Ao carregar o retorno modelo 2, deve-se apresentar O.S. abertas tanto para bens quanto para localizações
			cInnerJoin := "% LEFT JOIN " + RetSQLName( 'ST9' ) + " ST9 ON ( ST9.T9_FILIAL = " + ValToSQL( FwxFilial( 'ST9' ) ) + " AND STJ.TJ_CODBEM = ST9.T9_CODBEM AND STJ.TJ_TIPOOS = 'B' AND ST9.D_E_L_E_T_= ' ' ) "
			cInnerJoin += " LEFT JOIN " + RetSQLName( 'TAF' ) + " TAF ON ( TAF.TAF_FILIAL = " + ValToSQL( FwxFilial( 'TAF' ) ) + " AND STJ.TJ_CODBEM = TAF.TAF_CODNIV AND STJ.TJ_TIPOOS = 'L' AND TAF.TAF_MODMNT = 'X' AND TAF.D_E_L_E_T_= ' ' ) %"

			// Filtro aplicado na Query
			If !Empty( cChv902 )

				cFilter += " STJ.TJ_ORDEM = " + ValToSQL( cChv902 ) + " AND "

			EndIf

			//Preenche a variavel cSerefor com todos os serviços do parametro MV_NGSEREF
			If !Empty(cSerefor)

				For nX := 1 To Len(aServRef)
					If nX == 1
						cSerefor := "'"+aServRef[nX]+"'"
					Else
						cSerefor += ",'"+aServRef[nX]+"'"
					EndIf
				Next nX

			Else

				//Garante que a aspas vão certas para a Query
				cSerefor := "' '"

			EndIf

			//Preenche a variavel cSercons com todos os serviços do parametro MV_NGSECON
			If !Empty(cSercons)

				For nX := 1 To Len(aServCon)
					If nX == 1
						cSercons := "'"+aServCon[nX]+"'"
					Else
						cSercons += ",'"+aServCon[nX]+"'"
					EndIf
				Next nX

			Else

				//Garante que a aspas vão certas para a Query
				cSercons := "' '"

			EndIf

			cFilter += " STJ.TJ_SITUACA = 'L' "
			cFilter += " AND STJ.TJ_TERMINO = 'N' "
			cFilter += " AND STJ.TJ_ORDEPAI = " + ValToSQL( cCodPai )
			cFilter += " AND STJ.TJ_LUBRIFI <> 'S' "
			cFilter += " AND STJ.TJ_SERVICO NOT IN( " + cSerefor + ", " + cSercons + " ) "
			cFilter += 	cFilPE
			cFilter += " AND STJ.D_E_L_E_T_= ' ' %"

		EndIf

		// Realiza contagem de campos que serão apresentados no Browse
		nSumFields := Len( aFldSTJ )

		// Adiciona na query os campos que serão apresentados em tela
		For nCount := 1 To nSumFields

			If Posicione( 'SX3', 2, aFldSTJ[ nCount, 1 ], 'X3_CONTEXT' ) == 'V' .And.;
				aFldSTJ[ nCount, 1 ] != 'TJ_NOMSERV' .And. aFldSTJ[ nCount, 1 ] != 'TJ_NOMBEM'

				aAdd( aVrtFlds, aFldSTJ[ nCount, 1 ] )

				// Monta estrutura de inicialização padrão dos campos apresentados em tela
				If ExistIni( aFldSTJ[ nCount, 1 ] )
					aAdd( aIniSTJ, { aFldSTJ[ nCount, 1 ], Posicione( 'SX3', 2, aFldSTJ[ nCount, 1 ], 'X3_RELACAO' ) } )
				Else
					aAdd( aIniSTJ, { aFldSTJ[ nCount, 1 ], Space( TamSX3( aFldSTJ[ nCount, 1 ] )[ 1 ] ) } )
				EndIf

			EndIf

			If aFldSTJ[ nCount, 1 ] == 'TJ_NOMSERV'

				cFields += ", CASE "
				cFields +=    " WHEN STJ.TJ_SERVICO = 'HISTOR' THEN " + ValToSql(STR0406)
				cFields +=    " ELSE ST4.T4_NOME "
				cFields += " END AS TJ_NOMSERV "

			ElseIf aFldSTJ[ nCount, 1 ] == 'TJ_NOMBEM'

				If lPlantaGra
					// Caso venha da planta Gráfica, adiciona o campo TAF
					cFields += ', TAF.TAF_NOMNIV AS TJ_NOMBEM '
				Else
					cFields += ", CASE "
					cFields +=    " WHEN STJ.TJ_TIPOOS = 'B' THEN ST9.T9_NOME "
					cFields +=    " ELSE TAF.TAF_NOMNIV "
					cFields += " END AS TJ_NOMBEM "
				EndIf

			ElseIf  aFldSTJ[ nCount, 1 ] == 'TJ_DTPPINI' .Or.;
					aFldSTJ[ nCount, 1 ] == 'TJ_DTMPINI' .Or.;
					aFldSTJ[ nCount, 1 ] == 'TJ_DTMPFIM'
					// Devido a possibilidade de alteração dos campos, foi necessário realizar uma tratativa
					// para que mesmo se o usuário remover os campos eles sejam carregados ao menos no TRB.
					// pois são campos utilizados em validações/filtros ou afins da rotina.
				cFields += ''

			ElseIf aScan( aVrtFlds , { | x | x == aFldSTJ[ nCount, 1 ] } ) == 0

				cFields +=  ', STJ.' + aFldSTJ[ nCount, 1 ]

			EndIf

		Next nCount

		cCast := ", STJ.TJ_OBSERVA " // INFORMIX

		Do Case

			Case cBanco == 'ORACLE'

				cCast := ", UTL_RAW.CAST_TO_VARCHAR2( dbms_lob.substr( STJ.TJ_OBSERVA, 2000, 1 ) ) AS TJ_OBSERVA "

			Case cBanco == 'POSTGRES'

				cCast := ", COALESCE( CAST( ENCODE( STJ.TJ_OBSERVA, 'ESCAPE' ) AS VARCHAR( 8000 ) ), '' ) AS TJ_OBSERVA "

			Case 'MSSQL' $ cBanco

				cCast := ", ISNULL( CAST( CAST( STJ.TJ_OBSERVA AS VARBINARY( 8000 ) ) AS VARCHAR( 8000 ) ),'') AS TJ_OBSERVA "

		End Case

		cFields += cCast

		// Inicializa objeto e adiciona os valores
		oHashSTJ := HmNew()
		oHashSTJ := aToHM(aIniSTJ)
		aIniSTJ  := {}

		// Tratamento para que ao retornar a query seja passado o valor correto do campo observação para o TRB
		If ( nCount := aScan( aFldSTJ , { | x | x[ 1 ] == 'TJ_OBSERVA' } ) ) > 0
			aDel( aFldSTJ , nCount )
			aSize( aFldSTJ , Len( aFldSTJ ) - 1 )
			nSumFields--
			lObserva := .T.
		EndIf

		// Fecha condição de execução do BeginSQL
		cFields += ' %'

		BeginSQL Alias cAliasQry

			SELECT  STJ.TJ_FILIAL,
					STJ.TJ_TIPORET,
					STJ.TJ_DTPPINI,
					STJ.TJ_DTMPINI,
					STJ.TJ_DTMPFIM,
					STJ.R_E_C_N_O_ AS RECNO
					%exp:cFields%
			FROM %table:STJ% STJ
			%Exp:cInnerJoin%
			LEFT JOIN %table:ST4% ST4
				ON ( ST4.T4_FILIAL = %xFilial:ST4% AND STJ.TJ_SERVICO = ST4.T4_SERVICO AND ST4.%NotDel% )
			WHERE   STJ.TJ_FILIAL = %xFilial:STJ%
				AND %exp:cFilter%

		EndSQL

		Do While (cAliasQry)->( !EoF() )

			// Utilizado no inicializador padrão
			STJ->( dbGoTo( (cAliasQry)->RECNO ) )

			RecLock( cAliOS435, .T. )
			// Adiciona na query os campos que serão apresentados em tela
			For nCount := 1 To nSumFields

				If aScan( aVrtFlds , { | x | x == aFldSTJ[ nCount, 1 ] } ) == 0
					If aFldSTJ[ nCount, 3 ] == 'D'
						&( cAliOS435 + '->' + aFldSTJ[ nCount, 1 ] ) := StoD( &( cAliasQry + '->' + aFldSTJ[ nCount, 1 ] ) )
					Else
						&( cAliOS435 + '->' + aFldSTJ[ nCount, 1 ] ) := &( cAliasQry + '->' + aFldSTJ[ nCount, 1 ] )
					EndIf
				Else
					// Captura valor do campo a ser inicializado
					If HmGet( oHashSTJ, aFldSTJ[ nCount, 1 ], @aIniSTJ)
						&( cAliOS435 + '->' + aFldSTJ[ nCount, 1 ] ) := &( aIniSTJ[ 1, 2 ] )
					EndIf
				EndIf

			Next nCount

			(cAliOS435)->TJ_DTMPFIM := StoD((cAliasQry)->TJ_DTMPFIM)
			(cAliOS435)->TJ_TIPORET := (cAliasQry)->TJ_TIPORET
			(cAliOS435)->RECNO      := (cAliasQry)->RECNO

			If lObserva
				(cAliOS435)->TJ_OBSERVA := (cAliasQry)->TJ_OBSERVA
			EndIf

			(cAliOS435)->( MsUnlock() )

			aAdd( aDadosOS, {;
				(cAliasQry)->TJ_ORDEM,;
				(cAliasQry)->TJ_PLANO,;
				Nil                  ,;
				Nil                  ,;
				Nil                  ,;
				Nil                  ,;
				Nil                  ,;
				Nil                  ,;
				Nil                  ,;
				{} } )                 // Ocorrências

			(cAliasQry)->( dbSkip() )

		End Do

		// Limpa os dados do HashMap
		HMClean( oHashSTJ )

		// Libera o objeto de HashMap
		FreeObj( oHashSTJ )

		// Limpa os dados do Array
		FWFreeArray( aIniSTJ )

		(cAliasQry)->( dbCloseArea() )

		If lLoadOS .And. ( oBrwOS:lFiltrate .Or. Empty( cChv902 ) .Or.;
			( !Empty( cChv902 ) .And. FWIsInCallStack( 'MNTA435' ) ) )

			oBrwOS:GoTop()
			oBrwOS:Refresh()

			// Atualiza abas relacionadas a primeira O.S. posicionada no browse
			If !Empty( aDadosOS )
				fRefreshOS( (cAliOS435)->TJ_ORDEM, (cAliOS435)->TJ_PLANO, 1 )
			Else
				MsgInfo( STR0382 , STR0037 ) //"Não foram encontradas O.S. abertas para essa pesquisa."###"Atenção"
			EndIf

		EndIf

	EndIf

	Inclui := lIncluiBkp

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fQntEmp
Apresenta perguntas para parametrização da rotina.
@type function

@author Alexandre Santos
@since 18/04/2022
/*/
//-------------------------------------------------------------------
Static Function fPerg435()

	/*-------------------------------------------------+
	| Perguntas para parametrização da rotina MNTA435. |
	+-------------------------------------------------*/
	Pergunte( 'MNT435', .T. )

	/*--------------------------------------------------+
	| Atribuição da váriavel de controle das perguntas. |
	+--------------------------------------------------*/
	cMVPAR01 := cValToChar( MV_PAR01 )

	/*--------------------------------------------------------------------+
	| Recarrega informações da O.S. posicionada conforme novas definições |
	+--------------------------------------------------------------------*/
	fRefreshOS( (cAliOS435)->TJ_ORDEM, (cAliOS435)->TJ_PLANO, 1 )

	/*-------------------------------------------------------+
	| Atualiza objeto de controle da lista principal de O.S. |
	+-------------------------------------------------------*/
	oBrwOS:Refresh()

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fInteg
Realiza o processo de integração com estoque ao finalizar a O.S.
@type function

@author Alexandre Santos
@since 19/08/2022

@param cOServ  , string, O.S. que está sendo finalizada.

@return boolean, Indica se o processo foi realizado com êxito.
/*/
//-------------------------------------------------------------------
Static Function fInteg( cOServ )

	Local cOProd   := PadR( cOServ + 'OS001', FwTamSX3( 'D4_OP' )[1] )
	Local lRet     := .T.

	If NgVldRpo( { { 'MNTUTIL.prx', SToD( '20221103' ), '12:00' } } ) .And. MntUseExec( 'SD4' )

		BEGIN TRANSACTION

			dbSelectArea( 'SD4' )
			dbSetOrder( 2 ) // D4_FILIAL + D4_OP + D4_COD + D4_LOCAL
			If msSeek( FWxFilial( 'SD4' ) + cOProd )

				/*-------------------------------------------------------+
				| ExecAuto MATA381 para zerar os espenhos remanescentes. |
				+-------------------------------------------------------*/
				lRet := MntExecSD4( cOProd, , 0 )[1]

				If !lRet

					DisarmTransaction()

					BREAK

				EndIf

			EndIf

		END TRANSACTION

	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Legend435
Cria legenda no browse.

@type   Function

@author Eduardo Mussi
@since  21/09/2022
@param  oBrowOS, Objeto, Objeto referente ao browse de O.S.

/*/
//-------------------------------------------------------------------
Static Function Legend435( oBrowOS )

	Local aLegOs435 := { { ' !Empty((cAliOS435)->TJ_TIPORET) .And. (cAliOS435)->TJ_DTMPFIM >= dDataBase', 'BR_VERDE'   , /*Legenda*/, /*cId*/, .F. },;
						 { ' Empty((cAliOS435)->TJ_TIPORET)  .And. (cAliOS435)->TJ_DTMPFIM >= dDataBase', 'BR_AZUL'    , /*Legenda*/, /*cId*/, .F. },;
						 { ' Empty((cAliOS435)->TJ_TIPORET)  .And. (cAliOS435)->TJ_DTMPFIM < dDataBase' , 'BR_VERMELHO', /*Legenda*/, /*cId*/, .F. },;
						 { ' !Empty((cAliOS435)->TJ_TIPORET) .And. (cAliOS435)->TJ_DTMPFIM < dDataBase' , 'BR_LARANJA' , /*Legenda*/, /*cId*/, .F. } }
	Local aLeg4355 := {}
	Local nLeg

	// Ponto de entrada para manipular legenda do browse de O.S.
	If ExistBlock( 'MNTA4355 ' )
		aLeg4355 := aClone( aLegOs435 )
		aLeg4355 := ExecBlock( 'MNTA4355', .F., .F., aLeg4355 )
		// Tratamento para validar se o cliente está com o ponto de entrada atualizado.
		If Len( aLeg4355 ) > 0 .And. 'aOS' $ aLeg4355[ 1, 1 ]
			// "ATENÇÃO" # 'O ponto de entrada MNTA4355 está desatualizado, favor verificar o novo funcionamento.'
			Help( , , STR0037, , 'O ponto de entrada MNTA4355 está desatualizado, favor verificar o novo funcionamento.', 4, 0 )
		Else
			aLegOs435 := aClone( aLeg4355 )
		EndIf
	EndIf

	For nLeg := 1 To Len( aLegOs435 )
		oBrowOS:AddLegend(  aLegOs435[ nLeg, 1 ],; // Condição da legenda
							aLegOs435[ nLeg, 2 ],; // Cor da legenda
							IIf( aLegOs435[ nLeg, 3 ], aLegOs435[ nLeg, 3 ], ),; // Legenda( descrição )
							NIL,; // Compatibilidade
							IIf( aLegOs435[ nLeg, 4 ], aLegOs435[ nLeg, 4 ], ) ) // Indica se deve ser exibido o filtro da legenda
	Next

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fCriaGetD
Centraliza montagem e alterações nos cabeçalhos das GetDados.
@type function

@author Alexandre Santos
@since  15/12/2023

@param
@return
/*/
//-------------------------------------------------------------------
Static Function fCriaGetD()

	Local aNoSTL   := {}
	Local aHeaPadr := {}
	Local aBkpCo   := {}
	Local nPosBrw  := 0

	If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0

		/*------------------------------------------------------------+
		| Lista de campos não apresentados na GetDados de Ocorrências |
		+------------------------------------------------------------*/
		aNoFld := { 'TN_FILIAL', 'TN_ORDEM', 'TN_PLANO', 'TN_SEQUENC', 'TN_SEQRELA' }

		/*-------------------------------+
		| Monta o aHeader de ocorrências |
		+-------------------------------*/
		aHoBrw3 := CabecGetD( 'STN', aNoFld, 2, .T. )

		aNovaOcor := BlankGetD( aHoBrw3 )

		aDel( aNovaOcor[1] , Len( aNovaOcor[1] ) )

		aSize( aNovaOcor[1], Len( aNovaOcor[1] ) - 1 )

		aAdd( aNovaOcor[1] , {} )
								
		aAdd( aNovaOcor[1] , .F. )

		If ( nPosBrw := GDFieldPos( 'TN_TAREFA', aHoBrw3 ) ) > 0

			aHoBrw3[nPosBrw,6]  := "MNA435Vlda( 'TN_TAREFA' )"

		EndIf

		If ( nPosBrw := GDFieldPos( 'TN_CODOCOR', aHoBrw3 ) ) > 0

			aHoBrw3[nPosBrw,6]  := "MNA435Vlda( 'TN_CODOCOR' )"
			aHoBrw3[nPosBrw,9]  := "ST8435"

		EndIf

		If ( nPosBrw := GDFieldPos( 'TN_CAUSA', aHoBrw3 ) ) > 0

			aHoBrw3[nPosBrw,6]  := "MNA435Vlda( 'TN_CAUSA' )"
			aHoBrw3[nPosBrw,9]  := "ST8435"

		EndIf

		If ( nPosBrw := GDFieldPos( 'TN_SOLUCAO', aHoBrw3 ) ) > 0

			aHoBrw3[nPosBrw,6]  := "MNA435Vlda( 'TN_SOLUCAO' )"
			aHoBrw3[nPosBrw,9]  := "ST8435"

		EndIf

		/*--------------------------------------------------------+
		| Lista de campos não apresentados na GetDados de insumos |
		+--------------------------------------------------------*/
		aNoFld := { 'TL_ORDEM'  , 'TL_PLANO'  , 'TL_SEQUENC', 'TL_NOMSEQ' , 'TL_NOMTREG', 'TL_CUSTO2' , 'TL_OBSERVA',;
					'TL_CUSTO3' , 'TL_CUSTO4' , 'TL_CUSTO5' , 'TL_CUSENT1', 'TL_CUSENT2', 'TL_CUSENT3', 'TL_CUSENT4',;
					'TL_CUSENT5', 'TL_OCORREN', 'TL_REPFIM' , 'TL_NUMSEQ' , 'TL_CODOBS' , 'TL_PCTHREX', 'TL_CONTROL',;
					'TL_ETAPA'  , 'TL_GARANTI', 'TL_NOMETAP', 'TL_NOMLOCA', 'TL_NUMLOTE', 'TL_LOTECTL', 'TL_DTVALID',;
					'TL_NUMSERI', 'TL_POSCONT', 'TL_POSCON2', 'TL_LOCALIZ', 'TL_TAREFA' , 'TL_NOMTAR' ,	'TL_LOCAPLI',;
					'TL_NUMSC'  , 'TL_ITEMSC' , 'TL_NOTFIS' , 'TL_SERIE'  , 'TL_FORNEC' , 'TL_LOJA'   ,;
					'TL_NUMSA'  , 'TL_ITEMSA' , 'TL_SEQTARE', 'TL_PERMDOE', 'TL_CODAEN'  }

		aHoBrw3_2 := CabecGetD( 'STL', aNoFld, 2 )

		/*-----------------------------------------------------------+
		| Move o campo TL_SEQRELA para a ultima posição do cabeçalho |
		+-----------------------------------------------------------*/
		If ( nPosBrw := GDFieldPos( 'TL_SEQRELA', aHoBrw3_2 ) ) > 0

			aBkpCo := aClone( aHoBrw3_2[nPosBrw] )

			aDel( aHoBrw3_2 , nPosBrw )

			aSize( aHoBrw3_2, Len( aHoBrw3_2 ) - 1 )

			aAdd( aHoBrw3_2 , aClone( aBkpCo ) )

		EndIf

		/*-------------------------------------------+
		| Cabec. de insumos associados à ocorrencia. | 
		+-------------------------------------------*/
		If ( nPosBrw := GDFieldPos( 'TL_CODIGO' , aHoBrw3_2 ) ) > 0

			aHoBrw3_2[nPosBrw,6] := "MNA435Vlda( 'TL_CODIGO', oGd435Ass )"

		EndIf

		If ( nPosBrw := GDFieldPos( 'TL_QUANTID', aHoBrw3_2 ) ) > 0

			aHoBrw3_2[nPosBrw,6] := "MNA435Vlda( 'TL_QUANTID', oGd435Ass )"

		EndIf

		If ( nPosBrw := GDFieldPos( 'TL_DTINICI', aHoBrw3_2 ) ) > 0

			aHoBrw3_2[nPosBrw,6] := "MNA435Vlda( 'TL_DTINICI', oGd435Ass )"
			aHoBrw3_2[nPosBrw,12] := "CTOD( '' )"

		EndIf

		If ( nPosBrw := GDFieldPos( 'TL_HOINICI', aHoBrw3_2 ) ) > 0

			aHoBrw3_2[nPosBrw,6] := "MNA435Vlda( 'TL_HOINICI', oGd435Ass )"

		EndIf

		If ( nPosBrw := GDFieldPos( 'TL_DTFIM'  , aHoBrw3_2 ) ) > 0

			aHoBrw3_2[nPosBrw,6] := "MNA435Vlda( 'TL_DTFIM', oGd435Ass )"
			aHoBrw3_2[nPosBrw,12] := "CTOD( '' )"

		EndIf

		If ( nPosBrw := GDFieldPos( 'TL_HOFIM'  , aHoBrw3_2 ) ) > 0

			aHoBrw3_2[nPosBrw,6] := "MNA435Vlda( 'TL_HOFIM', oGd435Ass )"

		EndIf

		If ( nPosBrw := GDFieldPos( 'TL_USACALE', aHoBrw3_2 ) ) > 0

			aHoBrw3_2[nPosBrw,12] := "'N'"

		EndIf

		If ( nPosBrw := GDFieldPos( 'TL_TIPOREG', aHoBrw3_2 ) ) > 0

			aHoBrw3_2[nPosBrw,6]  := "MNA435Vlda( 'TL_TIPOREG', oGd435Ass )"
			aHoBrw3_2[nPosBrw,11] := "M=Mão de Obra;P=Produto"

		EndIf

		/*--------------------------------------------------------+
		| Lista de campos não apresentados na GetDados de insumos |
		+--------------------------------------------------------*/
		aNoFld := { 'TL_ORDEM'  , 'TL_PLANO'  , 'TL_SEQUENC', 'TL_NOMSEQ' , 'TL_NOMTREG', 'TL_CUSTO2' , 'TL_OBSERVA',;
					'TL_CUSTO3' , 'TL_CUSTO4' , 'TL_CUSTO5' , 'TL_CUSENT1', 'TL_CUSENT2', 'TL_CUSENT3', 'TL_CUSENT4',;
					'TL_CUSENT5', 'TL_OCORREN', 'TL_REPFIM' , 'TL_NUMSEQ' , 'TL_CODOBS' , 'TL_PCTHREX', 'TL_CONTROL',;
					'TL_ETAPA'  , 'TL_GARANTI', 'TL_NOMETAP', 'TL_NOMLOCA', 'TL_NUMLOTE', 'TL_LOTECTL', 'TL_DTVALID',;
					'TL_NUMSERI', 'TL_POSCONT', 'TL_POSCON2', 'TL_LOCAL'  , 'TL_LOCALIZ', 'TL_TAREFA' , 'TL_NOMTAR' ,;
					'TL_LOCAPLI', 'TL_NUMSC'  , 'TL_ITEMSC' , 'TL_NOTFIS' , 'TL_SERIE'  , 'TL_FORNEC' , 'TL_LOJA'   ,;
					'TL_NUMSA'  , 'TL_ITEMSA' , 'TL_SEQTARE', 'TL_PERMDOE', 'TL_CODAEN'  }

		aHoBrw3_3 := CabecGetD( 'STL', aNoFld, 2 )

		/*-----------------------------------------------------------+
		| Move o campo TL_SEQRELA para a ultima posição do cabeçalho |
		+-----------------------------------------------------------*/
		If ( nPosBrw := GDFieldPos( 'TL_SEQRELA', aHoBrw3_3 ) ) > 0

			aCopSeq := aClone( aHoBrw3_3[nPosBrw] )
			
			aDel( aHoBrw3_3 , nPosBrw )
			
			aSize( aHoBrw3_3, Len( aHoBrw3_3 ) - 1 ) 
			
			aAdd( aHoBrw3_3 , aClone( aCopSeq ) )

		EndIf

	Else

		aHoBrw3   := NGHeader( 'STN', { 'TN_FILIAL', 'TN_TAREFA', 'TN_NOMETAR', 'TN_ORDEM', 'TN_PLANO', 'TN_SEQRELA', 'TN_SEQUENC' }, .F. )

		aNovaOcor := BlankGetD( aHoBrw3 )

	EndIf

	/*--------------------------------------------------------+
	| Lista de campos não apresentados na GetDados de insumos |
	+--------------------------------------------------------*/
	aNoSTL := { "TL_ORDEM"  , "TL_PLANO"  , "TL_SEQUENC", "TL_NOMSEQ" , "TL_NOMTREG", "TL_CUSTO2" , 'TL_NOMTAR' ,;
				"TL_CUSTO3" , "TL_CUSTO4" , "TL_CUSTO5" , "TL_CUSENT1", "TL_CUSENT2", "TL_CUSENT3", "TL_CUSENT4",;
				"TL_CUSENT5", "TL_OCORREN", "TL_REPFIM" , "TL_NUMSEQ" , "TL_CODOBS" , 'TL_PCTHREX', "TL_CONTROL",;
				"TL_ETAPA"  , "TL_GARANTI", "TL_NOMETAP", "TL_NOMLOCA", "TL_NUMLOTE", "TL_LOTECTL", "TL_DTVALID",;
				"TL_NUMSERI", "TL_POSCONT", "TL_POSCON2", 'TL_QUANREC', 'TL_DESTINO', 'TL_LOCAL'  , 'TL_LOCALIZ',;
				'TL_LOCAPLI', 'TL_NUMSC'  , 'TL_ITEMSC' , 'TL_NOTFIS' , 'TL_SERIE'  , 'TL_FORNEC' , 'TL_LOJA'   ,;
				'TL_NUMSA'  , 'TL_ITEMSA' , 'TL_SEQTARE', 'TL_PERMDOE', 'TL_CODAEN' , 'TL_TAREFA'  }

	/*---------------------------+
	| Monta o aHeader de insumos |
	+---------------------------*/
	aHeaPadr  := CabecGetD( 'STL', aNoSTL, 2 )

	/*-----------------------------------------------------------+
	| Move o campo TL_SEQRELA para a ultima posição do cabeçalho |
	+-----------------------------------------------------------*/
	If ( nPosBrw := GDFieldPos( 'TL_SEQRELA', aHeaPadr ) ) > 0

		aBkpCo := aClone( aHeaPadr[nPosBrw] )

		aDel( aHeaPadr , nPosBrw )

		aSize( aHeaPadr, Len( aHeaPadr ) - 1 )

		aAdd( aHeaPadr , aClone( aBkpCo ) )

	EndIf

	/*--------------------------------+
	| Cópia do cabec para executantes |
	+--------------------------------*/
	aHeaExec  := aClone( aHeaPadr )

	/*--------------------------------------+
	| Monta o aCols padrão para executantes |
	+--------------------------------------*/
	aNovoExec := BlankGetD( aHeaExec )

	/*--------------------------------+
	| Cabec. de executantes da etapa. | 
	+--------------------------------*/
	If ( nPosBrw := GDFieldPos( 'TL_CODIGO' , aHeaExec ) ) > 0

		aHeaExec[nPosBrw,6] := "MNA435Vlda( 'TL_CODIGO', oGD435In2 )"

	EndIf

	If ( nPosBrw := GDFieldPos( 'TL_QUANTID', aHeaExec ) ) > 0

		aHeaExec[nPosBrw,6] := "MNA435Vlda( 'TL_QUANTID', oGD435In2 )"

	EndIf

	If ( nPosBrw := GDFieldPos( 'TL_DTINICI', aHeaExec ) ) > 0

		aHeaExec[nPosBrw,6]  := "MNA435Vlda( 'TL_DTINICI', oGD435In2 )"
		aHeaExec[nPosBrw,12] := "CTOD( '' )"

	EndIf

	If ( nPosBrw := GDFieldPos( 'TL_HOINICI', aHeaExec ) ) > 0

		aHeaExec[nPosBrw,6] := "MNA435Vlda( 'TL_HOINICI', oGD435In2 )"

	EndIf

	If ( nPosBrw := GDFieldPos( 'TL_DTFIM'  , aHeaExec ) ) > 0

		aHeaExec[nPosBrw,6] := "MNA435Vlda( 'TL_DTFIM', oGD435In2 )"
		aHeaExec[nPosBrw,12] := "CTOD( '' )"

	EndIf

	If ( nPosBrw := GDFieldPos( 'TL_HOFIM'  , aHeaExec ) ) > 0

		aHeaExec[nPosBrw,6] := "MNA435Vlda( 'TL_HOFIM', oGD435In2 )"

	EndIf

	If ( nPosBrw := GDFieldPos( 'TL_USACALE'  , aHeaExec ) ) > 0

		aHeaExec[nPosBrw,12] := "'N'"

		aNovoExec[1,nPosBrw] := "N"

	EndIf

	If ( nPosBrw := GDFieldPos( 'TL_TIPOREG', aHeaExec ) ) > 0

		aHeaExec[nPosBrw,6]  := "MNA435Vlda( 'TL_TIPOREG', oGD435In2 )"
		aHeaExec[nPosBrw,11] := "M=Mão de Obra"
		aHeaExec[nPosBrw,12] := "'M'"
		aHeaExec[nPosBrw,13] := ".F."

		aNovoExec[1,nPosBrw] := "M"

	EndIf

	FWFreeArray( aBkpCo )
	FWFreeArray( aHeaPadr )
	FWFreeArray( aNoSTL )

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fReabreOS
Faz a chamada para Reabertura de O.S. e atualiza o browse com a O.S.
@type Function

@author Alexandre Santos
@since  29/11/2023

@param 	aFields, Array, Array com os campos disponibilizados no Browse
@return
/*/
//-------------------------------------------------------------------
Static Function fReabreOS( aFields )

	/*-------------------------------+
	| Processo de reabertura de O.S. |
	+-------------------------------*/
	If MNTA880()[1]

		/*--------------------------------------------+
		| Carrega O.S. reaberta na tabela temporária. |
		+--------------------------------------------*/
		fLoadBrw( .F., aFields, .T., STJ->TJ_ORDEM )

	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} MNTA435Gat
Função que centraliza regras para gatilhos
@type Function

@author Alexandre Santos
@since  29/11/2023

@param 	cSequen, string, Sequeñcia de gatilho será validada.
@return boolean, Indica se o gatilho será ativado.
/*/
//-------------------------------------------------------------------
Function MNTA435Gat( cSequen )

	Local lRet := .T.

	Do Case

		Case cSequen == '01'

			lRet := FWIsInCallStack( 'MNTA435' ) .And. ( SuperGetMv( 'MV_NGTARGE', .F., '1' ) == '1' .Or.;
				( STJ->TJ_PLANO == '000000' ) )

		Case cSequen == '02'

			lRet := FWIsInCallStack( 'MNTA435' ) .And. ( !( SuperGetMv( 'MV_NGTARGE', .F., '1' ) == '1' ) .Or.;
				!( STJ->TJ_PLANO == '000000' ) )

	End Case

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MNA435Vlda
Centraliza regras para consistência de campos.
@type Function

@author Alexandre Santos
@since  08/12/2023

@param 	cField, string, Campo que será validado.
@param 	oObjGD, object, GetDados que contém o campo validado.

@return boolean, Indica se o conteúdo informado está valido.
/*/
//-------------------------------------------------------------------
Function MNA435Vlda( cField, oObjGD )

	Local cCodPro  := ''
	Local cCodCau  := ''
	Local cCodSol  := ''
	Local lRet     := .T.
	Local nPosTar  := 0
	Local nPosDtF  := 0
	Local nPosTip  := 0
	Local nPosCod  := 0
	Local nPosPro  := 0
	Local nPosAtu  := 0

	Default oObjGD := Nil

	Do Case

		/*---------------+
		| Tipo de Insumo |
		+---------------*/
		Case cField == 'TL_TIPOREG'

			lRet := Pertence( 'MPFTE' ) .And. NGValTerc( M->TL_TIPOREG ) .And. NGCLEARSTL()

			If lRet .And. oFolder435:nOption == 3

				oGd435Ocr:oBrowse:lDisablePaint := .F.

				nPosAtu := oGd435Ocr:nAt

				/*----------------------------------+
				| Atualiza a legenda da ocorrência. | 
				+----------------------------------*/
				oGd435Ocr:aCols[oGd435Ocr:nAt,_LEGENDAOCOR_] := 'BR_VERDE'

				oGd435Ocr:ForceRefresh()

				oGd435Ocr:GoTo( nPosAtu )

				oGd435Ocr:oBrowse:lDisablePaint := .T.

			EndIf

		/*-----------------+
		| Código de Insumo |
		+-----------------*/
		Case cField == 'TL_CODIGO'

			nPosDtF := GDFieldPos( 'TL_DTFIM'  , oObjGD:aHeader )
			nPosTip := GDFieldPos( 'TL_TIPOREG', oObjGD:aHeader )

			If !Empty( M->TL_CODIGO )

				If ( lRet := NGProd435( oObjGD:aHeader ) .And. CheckCod() )

					If oObjGD:aCols[oObjGD:nAt,nPosTip] == 'M' .And.;
						!Empty( oObjGD:aCols[oObjGD:nAt,nPosDtF] )

						lRet := NGFUNCRH( M->TL_CODIGO, .T., oObjGD:aCols[oObjGD:nAt,nPosDtF], .F. ) .And.;
							MNT435Cus( oObjGD:aHeader )

					Else

						lRet := MNT435Cus( oObjGD:aHeader )

					EndIf

				EndIf

			EndIf

		/*-----------+
		| Quantidade |
		+-----------*/
		Case cField == 'TL_QUANTID'

			lRet := NGQuant435( oObjGD:aHeader ) .And. MNT435Cus( oObjGD:aHeader )

		/*------------+
		| Data Inicio |
		+------------*/
		Case cField == 'TL_DTINICI'

			nPosCod := GDFieldPos( 'TL_CODIGO' , oObjGD:aHeader )
			nPosTip := GDFieldPos( 'TL_TIPOREG', oObjGD:aHeader )

			If NG435DtIni( oObjGD:aHeader )

				If oObjGD:aCols[oObjGD:nAt,nPosTip] == 'M' .And.;
					!Empty( oObjGD:aCols[oObjGD:nAt,nPosCod] )

					lRet := NGFuncRH( oObjGD:aCols[oObjGD:nAt,nPosCod], .T., M->TL_DTINICI, .F. ) .And.;
						MNT435Cus( oObjGD:aHeader )

				Else

					lRet := MNT435Cus( oObjGD:aHeader )

				EndIf

			EndIf

		/*------------+
		| Hora Inicio |
		+------------*/
		Case cField == 'TL_HOINICI'

			lRet := NG435HoIni( oObjGD:aHeader ) .And. MNT435Cus( oObjGD:aHeader )

		/*-----------+
		| Data Final |
		+-----------*/
		Case cField == 'TL_DTFIM'

			nPosCod := GDFieldPos( 'TL_CODIGO' , oObjGD:aHeader )
			nPosTip := GDFieldPos( 'TL_TIPOREG', oObjGD:aHeader )

			If NG435DtFim( oObjGD:aHeader )

				lRet := NGFuncRH( oObjGD:aCols[oObjGD:nAt,nPosCod], .T., M->TL_DTFIM  , .F. ) .And.;
					MNT435Cus( oObjGD:aHeader )

			EndIf

		/*-----------+
		| Hora Final |
		+-----------*/
		Case cField == 'TL_HOFIM'

			lRet := NG435HoFim( oObjGD:aHeader ) .And. MNT435Cus( oObjGD:aHeader )
		
		/*---------------------+
		| Tarefa da Ocorrência |
		+---------------------*/
		Case cField == 'TN_TAREFA'

			cCodPro := GDFieldGet( 'TN_CODOCOR', oGd435Ocr:nAt, .F.,;
				oGd435Ocr:aHeader, oGd435Ocr:aCols )
			cCodCau := GDFieldGet( 'TN_CAUSA'  , oGd435Ocr:nAt, .F.,;
				oGd435Ocr:aHeader, oGd435Ocr:aCols )
			cCodSol := GDFieldGet( 'TN_SOLUCAO', oGd435Ocr:nAt, .F.,;
				oGd435Ocr:aHeader, oGd435Ocr:aCols )

			nPosTar := GDFieldPos( 'TN_TAREFA', oGd435Ocr:aHeader )

			/*-----------------------------+
			| Validação de tarefa genérica | 
			+-----------------------------*/
			lRet := NGALTTAR( STJ->TJ_CODBEM + STJ->TJ_SERVICO + STJ->TJ_SEQRELA, M->TN_TAREFA )

			/*------------------------------------+
			| Validação vinculo Tarefa x Problema | 
			+------------------------------------*/
			If lRet .And. !Empty( cCodPro )

				dbSelectArea( 'ST8' )
				dbSetOrder( 1 ) // T8_FILIAL + T8_CODOCOR + T8_TIPO + T8_TAREFA
				If msSeek( FWxFilial( 'ST8' ) + cCodPro ) .And. !Empty( ST8->T8_TAREFA ) .And.;
					ST8->T8_TAREFA != M->TN_TAREFA

					Help( '', 1, 'TAREOCOR' )

					lRet := .F.

				EndIf

			EndIf

			/*---------------------------------+
			| Validação vinculo Tarefa x Causa | 
			+---------------------------------*/
			If lRet .And. !Empty( cCodCau )

				dbSelectArea( 'ST8' )
				dbSetOrder( 1 ) // T8_FILIAL + T8_CODOCOR + T8_TIPO + T8_TAREFA
				If msSeek( FWxFilial( 'ST8' ) + cCodCau ) .And. !Empty( ST8->T8_TAREFA ) .And.;
					ST8->T8_TAREFA != M->TN_TAREFA

					Help( '', 1, 'TAREOCOR' )

					lRet := .F.

				EndIf

			EndIf

			/*-----------------------------------+
			| Validação vinculo Tarefa x Solução | 
			+-----------------------------------*/
			If lRet .And. !Empty( cCodSol )

				dbSelectArea( 'ST8' )
				dbSetOrder( 1 ) // T8_FILIAL + T8_CODOCOR + T8_TIPO + T8_TAREFA
				If msSeek( FWxFilial( 'ST8' ) + cCodSol ) .And. !Empty( ST8->T8_TAREFA ) .And.;
					ST8->T8_TAREFA != M->TN_TAREFA

					Help( '', 1, 'TAREOCOR' )

					lRet := .F.

				EndIf

			EndIf

			If lRet .And. !Empty( oGd435Ocr:aCols[oGd435Ocr:nAt,nPosTar] ) .And.;
				oGd435Ocr:aCols[oGd435Ocr:nAt,nPosTar] != M->TN_TAREFA

				fResetAsso( M->TN_TAREFA, nPosTar )

			Else

				/*------------------+
				| Iniciliza Legenda |
				+------------------*/
				oGd435Ocr:aCols[oGd435Ocr:nAt,_LEGENDAOCOR_] := 'BR_VERMELHO'

			EndIf

		/*---------+
		| Problema |
		+---------*/
		Case cField == 'TN_CODOCOR'

			nPosPro := GDFieldPos( 'TN_CODOCOR', oGd435Ocr:aHeader )

			If ( nPosTar := GDFieldPos( 'TN_TAREFA', oGd435Ocr:aHeader ) ) > 0

				cCodTar := oGd435Ocr:aCols[oGd435Ocr:nAt,nPosTar]

			EndIf

			lRet := MNA420VOcr( M->TN_CODOCOR, cCodTar, 'P' )

			If lRet .And. !Empty( oGd435Ocr:aCols[oGd435Ocr:nAt,nPosPro] ) .And.;
				oGd435Ocr:aCols[oGd435Ocr:nAt,nPosPro] != M->TN_CODOCOR

				fResetAsso( M->TN_CODOCOR, nPosPro )

			EndIf
		
		/*------+
		| Causa |
		+------*/
		Case cField == 'TN_CAUSA'

			nPosCau := GDFieldPos( 'TN_CAUSA', oGd435Ocr:aHeader )

			If ( nPosTar := GDFieldPos( 'TN_TAREFA', oGd435Ocr:aHeader ) ) > 0

				cCodTar := oGd435Ocr:aCols[oGd435Ocr:nAt,nPosTar]

			EndIf
			
			If !Empty( M->TN_CAUSA )

				lRet := MNA420VOcr( M->TN_CAUSA, cCodTar, 'C' )

			EndIf

			If lRet .And. !Empty( oGd435Ocr:aCols[oGd435Ocr:nAt,nPosCau] ) .And.;
				oGd435Ocr:aCols[oGd435Ocr:nAt,nPosCau] != M->TN_CAUSA

				fResetAsso( M->TN_CAUSA, nPosCau )

			EndIf

		/*--------+
		| Solução |
		+--------*/
		Case cField == 'TN_SOLUCAO'

			nPosSol := GDFieldPos( 'TN_SOLUCAO', oGd435Ocr:aHeader )

			If ( nPosTar := GDFieldPos( 'TN_TAREFA', oGd435Ocr:aHeader ) ) > 0

				cCodTar := oGd435Ocr:aCols[oGd435Ocr:nAt,nPosTar]

			EndIf

			If !Empty( M->TN_SOLUCAO )

				lRet := MNA420VOcr( M->TN_SOLUCAO, cCodTar, 'S' )

			EndIf

			If lRet .And. !Empty( oGd435Ocr:aCols[oGd435Ocr:nAt,nPosSol] ) .And.;
				oGd435Ocr:aCols[oGd435Ocr:nAt,nPosSol] != M->TN_SOLUCAO

				fResetAsso( M->TN_SOLUCAO, nPosSol )

			EndIf

	End Case

Return lRet

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} MNA435LiOk
Centraliza regras de linhaOK.
@type function

@author Alexandre Santos
@since 05/01/2023

@param nOption , integer, Operação
							1 - Inclusão/Alteração
							2 - Deleção
@param nLine2  , integer, Linha que será validada.
@param nGetDad , integer, Indica qual GetDados será validado.
							1 - Insumos Associado à ocorrência
							2 - Insumos MO para Execução de Etapa 
							3 - Ocorrências
							
@return boolean, Indica se toda a GetDados está valida.
/*/
//-----------------------------------------------------------------------------------
Function MNA435LiOk( nOption, nLine2, nGetDad )

	Local aBkpCols := {}
	Local lRet     := .T.

	Local nInd1    := 0
	Local nLine1   := 0
	Local nQtdReg  := 0
	Local nPsTip2  := 0
	Local nPsCod2  := 0
	Local nPsQtd2  := 0
	Local nPsDtI2  := 0
	Local nPsHrI2  := 0
	Local nPsSeq2  := 0
	Local nPsTar2  := 0
	Local nPosPro  := 0
	Local nPosCau  := 0
	Local nPosSol  := 0
	Local nPosOS   := aScan( aDadosOS, { |x| x[1] + x[2] == cOrdemTJ + cPlanoTJ } )

	Local nPsTar1  := GDFieldPos( 'TL_TAREFA' , oBrw6:aHeader )
	Local nPsTip1  := GDFieldPos( 'TL_TIPOREG', oBrw6:aHeader )
	Local nPsCod1  := GDFieldPos( 'TL_CODIGO' , oBrw6:aHeader )
	Local nPsQtd1  := GDFieldPos( 'TL_QUANTID', oBrw6:aHeader )
	Local nPsDtI1  := GDFieldPos( 'TL_DTINICI', oBrw6:aHeader )
	Local nPsHrI1  := GDFieldPos( 'TL_HOINICI', oBrw6:aHeader )
	Local nPosSq1  := GDFieldPos( 'TL_SEQRELA', oBrw6:aHeader )

	Default nLine2 := oGd435In2:nAt

	/*------------------------------+
	| Insumo associado à Ocorrência |
	+------------------------------*/
	If nGetDad == 1

		nPsTip2 := GDFieldPos( 'TL_TIPOREG', oGd435Ass:aHeader )
		nPsCod2 := GDFieldPos( 'TL_CODIGO' , oGd435Ass:aHeader )
		nPsQtd2 := GDFieldPos( 'TL_QUANTID', oGd435Ass:aHeader )
		nPsDtI2 := GDFieldPos( 'TL_DTINICI', oGd435Ass:aHeader )
		nPsHrI2 := GDFieldPos( 'TL_HOINICI', oGd435Ass:aHeader )
		nPosSq2 := GDFieldPos( 'TL_SEQRELA', oGd435Ass:aHeader )
		nPsTar2 := GDFieldPos( 'TN_TAREFA' , oGd435Ocr:aHeader )
		nPosPro := GDFieldPos( 'TN_CODOCOR', oGd435Ocr:aHeader )
		nPosCau := GDFieldPos( 'TN_CAUSA'  , oGd435Ocr:aHeader )
		nPosSol := GDFieldPos( 'TN_SOLUCAO', oGd435Ocr:aHeader )

		/*-----------------------------------------+
		| Ativa manipulação do browse pelo sistema |
		+-----------------------------------------*/
		oGd435Ocr:oBrowse:lDisablePaint := .F.

		Do Case

			/*--------------------------------------------------+
			| Valida exclusão de insumo associado à ocorrência. |
			+--------------------------------------------------*/
			Case nOption == 2

				dbSelectArea( cAlsOcor )
				dbSetOrder( 1 ) // TN_ORDEM + TN_PLANO + TN_SEQRELA + TN_TAREFA + TN_CODOCOR + TN_CAUSA + TN_SOLUCAO

				/*-------------------------------------------------------+
				| Acionado ao desfazer a deleção de um insumo associado. |
				+-------------------------------------------------------*/
				If aTail( oGd435Ass:aCols[nLine2] )

					/*-----------------------------------------+
					| Permite posicionar em registro deletado. |
					+-----------------------------------------*/
					SET DELETED OFF

					If msSeek( cOrdemTJ + cPlanoTJ + oGd435Ass:aCols[nLine2,nPosSq2] + oGd435Ocr:aCols[oGd435Ocr:nAt,nPsTar2] +;
						oGd435Ocr:aCols[oGd435Ocr:nAt,nPosPro] + oGd435Ocr:aCols[oGd435Ocr:nAt,nPosCau] + oGd435Ocr:aCols[oGd435Ocr:nAt,nPosSol] )

						/*---------------------------------------------------+
						| Desfaz a deleção do registro na tabela temporária. |
						+---------------------------------------------------*/
						dbRecall()

						/*----------------------------------+
						| Atualiza a legenda da ocorrência. | 
						+----------------------------------*/
						oGd435Ocr:aCols[oGd435Ocr:nAt,_LEGENDAOCOR_] := 'BR_VERDE'

					EndIf

					/*----------------------------------------------+
					| Bloqueia posicionamento em registro deletado. |
					+----------------------------------------------*/
					SET DELETED ON

				/*------------------------------+
				| Exclusão de insumo associado. |
				+------------------------------*/
				Else
				
					If msSeek( cOrdemTJ + cPlanoTJ + oGd435Ass:aCols[nLine2,nPosSq2] + oGd435Ocr:aCols[oGd435Ocr:nAt,nPsTar2] +;
						oGd435Ocr:aCols[oGd435Ocr:nAt,nPosPro] + oGd435Ocr:aCols[oGd435Ocr:nAt,nPosCau] + oGd435Ocr:aCols[oGd435Ocr:nAt,nPosSol] )

						RecLock( cAlsOcor, .F. )

							dbDelete()

						MsUnLock()

						/*----------------------------------------------+
						| Contagem de insumos associados não deletados. | 
						+----------------------------------------------*/
						aEval( oGd435Ass:aCols, { |x| IIf( !aTail( x ), nQtdReg++, Nil ) } )

						If nQtdReg <= 1

							/*-----------------------------------------------------------------------------+
							| Quando deletado o ultimo insumo associado, atualiza a legenda da ocorrência. | 
							+-----------------------------------------------------------------------------*/
							oGd435Ocr:aCols[oGd435Ocr:nAt,_LEGENDAOCOR_] := 'BR_VERMELHO'

						EndIf

					EndIf

				EndIf

			/*---------------------------------------+
			| Valida de linha para insumo associado. |
			+---------------------------------------*/
			Case nOption == 1

				If !aTail( oGd435Ass:aCols[nLine2] )

					aBkpCols := aClone( aCoBrw6 )

					For nInd1 := 1 To Len( aCoBrw6 )

						If aTail( aCoBrw6[nInd1] )

							/*----------------------------+
							| Não valida insumo deletado. |
							+----------------------------*/
							Loop

						EndIf

						If !Empty( oGd435Ass:aCols[nLine2,nPsTip2] )

							If 	aCoBrw6[nInd1,nPsTar1] == oGd435Ocr:aCols[oGd435Ocr:nAt,nPsTar2] .And.;
								aCoBrw6[nInd1,nPsTip1] == oGd435Ass:aCols[nLine2,nPsTip2] .And.;
								aCoBrw6[nInd1,nPsCod1] == oGd435Ass:aCols[nLine2,nPsCod2] .And.;
								aCoBrw6[nInd1,nPsQtd1] == oGd435Ass:aCols[nLine2,nPsQtd2] .And.;
								aCoBrw6[nInd1,nPsDtI1] == oGd435Ass:aCols[nLine2,nPsDtI2] .And.;
								aCoBrw6[nInd1,nPsHrI1] == oGd435Ass:aCols[nLine2,nPsHrI2] .And.;
								!( aCoBrw6[nInd1,nPosSq1] == oGd435Ass:aCols[nLine2,nPosSq2] )

								Help( '', 1, STR0037, , STR0421, 2, 0 ) // Já existe um insumo realizado com estas caracterisiticas.

								lRet := .F.

								Exit

							EndIf

						EndIf
					
					Next nInd1

					If lRet .And. !Empty( oGd435Ass:aCols[nLine2,1] )

						/*--------------------------------------------------------------+
						| Busca na GetDados de Insumos Realizado com a chave TL_SEQRELA |
						+--------------------------------------------------------------*/
						If Empty( oGd435Ass:aCols[nLine2,nPosSq2] )
							
							If Len( aCoBrw6 ) >= 1 .And. !Empty( aCoBrw6[1,1] )

								/*---------------------------------+
								| Define o SEQRELA do novo insumo. |
								+---------------------------------*/
								oGd435Ass:aCols[nLine2,nPosSq2] := MNT435SEQ( aCoBrw6, .T. )
								
								/*---------------------------------------+
								| Inclui nova linha do insumo realizado. |
								+---------------------------------------*/
								aAdd( aCoBrw6, {} )
								
								/*---------------------------------------------------+
								| Salva a posição da nova linha de insumo realizado. |
								+---------------------------------------------------*/
								nFound := Len( aCoBrw6 )

								/*--------------------------------------------------+
								| Preenche a linha com conteúdo default de insumos. |
								+--------------------------------------------------*/
								aCoBrw6[nFound] := aClone( aNovoSTL[1] )
							
							Else

								/*---------------------------------+
								| Define o SEQRELA do novo insumo. |
								+---------------------------------*/
								oGd435Ass:aCols[nLine2,nPosSq2] := '1  '

								/*----------------------------------------+
								| Utiliza linha vazia do insumo realizado |
								+----------------------------------------*/
								nFound := 1

							EndIf

						Else
							
							nFound := aScan( aCoBrw6, { |x| x[nPosSq1] == oGd435Ass:aCols[nLine2,nPosSq2] } )

							If nFound == 0

								/*---------------------------------------+
								| Inclui nova linha do insumo realizado. |
								+---------------------------------------*/
								aAdd( aCoBrw6, {} )
								
								/*---------------------------------------------------+
								| Salva a posição da nova linha de insumo realizado. |
								+---------------------------------------------------*/
								nFound := Len( aCoBrw6 )

								/*--------------------------------------------------+
								| Preenche a linha com conteúdo default de insumos. |
								+--------------------------------------------------*/
								aCoBrw6[nFound] := aClone( aNovoSTL[1] )

							EndIf

						EndIf

						/*-----------------------------------------------------------------------------------+
						| Atualiza linha do insumo realizado, com alterações feitas no folder de ocorrências |
						+-----------------------------------------------------------------------------------*/
						For nInd1 := 1 To Len( aHoBrw6 )

							If ( nPosBrw := GDFieldPos( aHoBrw6[nInd1,2], oGd435Ass:aHeader ) )

								aCoBrw6[nFound,nInd1] := oGd435Ass:aCols[nLine2,nPosBrw]

							EndIf
							
						Next nInd1

						If ( nPosBrw := GDFieldPos( 'TL_TAREFA', aHoBrw6 ) ) > 0

							aCoBrw6[nFound,nPosBrw] :=  GDFieldGet( 'TN_TAREFA', oGd435Ocr:nAt,;
								.F., oGd435Ocr:aHeader, oGd435Ocr:aCols )

						EndIf

						If ( nPosBrw := GDFieldPos( 'TL_NOMTAR', aHoBrw6 ) ) > 0

							aCoBrw6[nFound,nPosBrw] :=  GDFieldGet( 'TN_NOMETAR', oGd435Ocr:nAt,;
								.F., oGd435Ocr:aHeader, oGd435Ocr:aCols )

						EndIf

						If ( nPosBrw := GDFieldPos( 'TL_GARANTI', aHoBrw6 ) ) > 0

							aCoBrw6[nFound,nPosBrw] := 'N'

						EndIf

						n := nFound

						aCoBrw3_2 := aClone( oGd435Ass:aCols )
						aCols     := aClone( aCoBrw6 )

						oBrw6:lModified := .T.

						/*-------------------------------------------+
						| Validações de linha para insumo realizado. |
						+-------------------------------------------*/
						If lRet .And. !LinOkTL435()

							lRet := .F.

							oBrw6:lModified := .F.

							aCoBrw6 := aClone( aBkpCols )

						Else

							aDadosOS[nPosOS,5] := aClone( aCoBrw6 )
							oBrw6:aCols        := aClone( aCoBrw6 )

						EndIf

						aCols := aClone( aCoBrw3_2 )

					EndIf
				
				EndIf

		End Case

		oGd435Ocr:oBrowse:Refresh()

		/*--------------------------------------------+
		| Desativa manipulação do browse pelo sistema |
		+--------------------------------------------*/
		oGd435Ocr:oBrowse:lDisablePaint := .T.

	/*------------------+
	| Execução de Etapa |
	+------------------*/
	ElseIf nGetDad == 2

		nPsTip2  := GDFieldPos( 'TL_TIPOREG', oGd435In2:aHeader )
		nPsCod2  := GDFieldPos( 'TL_CODIGO' , oGd435In2:aHeader )
		nPsQtd2  := GDFieldPos( 'TL_QUANTID', oGd435In2:aHeader )
		nPsDtI2  := GDFieldPos( 'TL_DTINICI', oGd435In2:aHeader )
		nPsHrI2  := GDFieldPos( 'TL_HOINICI', oGd435In2:aHeader )
		nPsSeq2  := GDFieldPos( 'TL_SEQRELA', oGd435In2:aHeader )
		nLinOS   := aScan( aDadosOS, {| x| x[1] + x[2] == cOrdemTJ + cPlanoTJ } )

		(cAlsExecu)->( dbGoTop() )
		While (cAlsExecu)->( !EoF() )
			
			For nInd1 := 1 To Len( oBrw6:aCols )

				If !aTail( oBrw6:aCols[nInd1] )

					If  oBrw6:aCols[nInd1,nPsTar1] == (cAlsExecu)->TQ_TAREFA          .And.;
						oBrw6:aCols[nInd1,nPsTip1] == oGd435In2:aCols[nLine2,nPsTip2] .And.;
						oBrw6:aCols[nInd1,nPsCod1] == oGd435In2:aCols[nLine2,nPsCod2] .And.;
						oBrw6:aCols[nInd1,nPsQtd1] == oGd435In2:aCols[nLine2,nPsQtd2] .And.;
						oBrw6:aCols[nInd1,nPsDtI1] == oGd435In2:aCols[nLine2,nPsDtI2] .And.;
						oBrw6:aCols[nInd1,nPsHrI1] == oGd435In2:aCols[nLine2,nPsHrI2]

						If oBrw6:aCols[nInd1,nPosSq1] == oGd435In2:aCols[nLine2,nPsSeq2]

							nLine1 := nInd1

							Exit

						ElseIf Empty( oGd435In2:aCols[nLine2,nPsSeq2] )
							
							Help( '', 1, STR0037, , STR0421 ) // á existe um insumo realizado com estas caracterisiticas.

							lRet := .F.

							Exit

						EndIf

					EndIf

				EndIf
					
			Next nInd1

			If lRet .And. !Empty( oGd435In2:aCols[nLine2,1] )

				If nLine1 == 0 
					
					If Empty( oBrw6:aCols ) .Or.;
						!Empty( oBrw6:aCols[1,1] )

						aAdd( oBrw6:aCols, aClone( aNovoSTL[1] ) )

						nLine1 := Len( oBrw6:aCols )

						If ( nPosBrw := GDFieldPos( 'TL_SEQRELA', oGd435In2:aHeader ) ) > 0

							oGd435In2:aCols[nLine2,nPosBrw] := MNT435SEQ( oBrw6:aCols, .T. )

						EndIf

					Else

						nLine1 := 1

						If ( nPosBrw := GDFieldPos( 'TL_SEQRELA', oGd435In2:aHeader ) ) > 0

							oGd435In2:aCols[nLine2,nPosBrw] := '1  '

						EndIf

					EndIf

					/*-----------------------------------------------------------------------------------+
					| Atualiza linha do insumo realizado, com alterações feitas no folder de ocorrências |
					+-----------------------------------------------------------------------------------*/
					For nInd1 := 1 To Len( oBrw6:aHeader )

						If ( nPosBrw := GDFieldPos( oBrw6:aHeader[nInd1,2], oGd435In2:aHeader ) )

							oBrw6:aCols[nLine1,nInd1] := oGd435In2:aCols[nLine2,nPosBrw]

						EndIf
						
					Next nInd1

					If ( nPosBrw := GDFieldPos( 'TL_TAREFA', oBrw6:aHeader ) ) > 0

						oBrw6:aCols[nLine1,nPosBrw] := (cAlsExecu)->TQ_TAREFA

					EndIf

					If ( nPosBrw := GDFieldPos( 'TL_NOMTAR', oBrw6:aHeader ) ) > 0

						oBrw6:aCols[nLine1,nPosBrw] := (cAlsExecu)->TQ_NOMTARE

					EndIf

				EndIf

				n     := nLine1
				aCols := aClone( oBrw6:aCols )
				oBrw6:lModified := .T.

				/*------------------------------+
				| Valid. de linha para insumos. |
				+------------------------------*/
				If lRet .And. !LinOkTL435()

					If Len( oBrw6:aCols ) > 1

						aDel( oBrw6:aCols , Len( oBrw6:aCols ) )

						aSize( oBrw6:aCols, Len( oBrw6:aCols ) - 1 )

					Else

						oBrw6:aCols := aClone( aNovoSTL )

					EndIf

					If ( nPosBrw := GDFieldPos( 'TL_SEQRELA', oGd435In2:aHeader ) ) > 0

						oGd435In2:aCols[nLine2,nPosBrw] := ''

					EndIf

					oBrw6:lModified := .F.
					aCols := aClone( oBrw6:aCols )

					lRet  := .F.
				
				Else

					aCols := aClone( oGd435In2:aCols )

				EndIf

				aDadosOS[nLinOS,5] := aClone( oBrw6:aCols )
				aCoBrw6 := aClone( oBrw6:aCols )

			EndIf

			(cAlsExecu)->( dbSkip() )

		End

	/*------------+
	| Ocorrências |
	+------------*/
	Else

		aHeader := aClone( oGd435Ocr:aHeader )
		aCols   := aClone( oGd435Ocr:aCols  )

		nPosPro := GDFieldPos( 'TN_CODOCOR' )
		nPosCau := GDFieldPos( 'TN_CAUSA' )
		nPosSol := GDFieldPos( 'TN_SOLUCAO' )

		If  !Empty( nPosPro ) .And. !Empty( nPosCau ) .And.;
			!Empty( nPosSol )

			lRet := M400GetDo( nLine2 )

		EndIf

		PutFileInEof( 'STN' )

	EndIf

	PutFileInEof( 'STL' )

	FWFreeArray( aBkpCols )

Return lRet

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} MNA435TdOk
Centraliza regras de tudoOK.
@type function

@author Alexandre Santos
@since 05/01/2023

@param nGetDad , integer, Indica qual GetDados será validado.
							1 - Insumos Associado à ocorrência
							2 - Execução de Etapa 
							3 - Ocorrências
@param oObjDlg , object , Objeto de controle da Dialog.
@param nPosErr , integer, Posição da linha inconsistente.
							
@return boolean, Indica se toda a GetDados está valida.
/*/
//-----------------------------------------------------------------------------------
Function MNA435TdOk( nGetDad, oObjDlg, nPosErr )

	Local lRet    := .T.
	Local nInd1   := 0
	Local nPosTar := 0
	Local nPosPro := 0
	Local nPosCau := 0
	Local nPosSol := 0
	Local nPosSeq := 0
	Local nPosObs := 0

	Do Case

		/*------------------------------+
		| Insumo associado à Ocorrência |
		+------------------------------*/
		Case nGetDad == 1

			nPosTar := GDFieldPos( 'TN_TAREFA' , oGd435Ocr:aHeader )
			nPosPro := GDFieldPos( 'TN_CODOCOR', oGd435Ocr:aHeader )
			nPosCau := GDFieldPos( 'TN_CAUSA'  , oGd435Ocr:aHeader )
			nPosSol := GDFieldPos( 'TN_SOLUCAO', oGd435Ocr:aHeader )
			nPosObs := GDFieldPos( 'TN_DESCRIC', oGd435Ocr:aHeader )
			nPosSeq := GDFieldPos( 'TL_SEQRELA', oGd435Ass:aHeader )

			For nInd1 := 1 To Len( oGd435Ass:aCols )

				If !aTail( oGd435Ass:aCols[nInd1] ) .And.;
					!Empty( oGd435Ass:aCols[nInd1,1] )
					
					/*-------------------+
					| Validação de linha |
					+-------------------*/
					lRet := MNA435LiOk( 1, nInd1, 1 )

					If lRet

						/*-------------------------------------------+
						| Atualiza tabela temporária com alterações. |
						+-------------------------------------------*/
						dbSelectArea( cAlsOcor )
						dbSetOrder( 1 ) // TN_ORDEM + TN_PLANO + TN_SEQRELA + TN_TAREFA + TN_CODOCOR + TN_CAUSA + TN_SOLUCAO
						If msSeek( cOrdemTJ + cPlanoTJ + oGd435Ass:aCols[nInd1,nPosSeq] + oGd435Ocr:aCols[oGd435Ocr:nAt,nPosTar] +;
							oGd435Ocr:aCols[oGd435Ocr:nAt,nPosPro] + oGd435Ocr:aCols[oGd435Ocr:nAt,nPosCau] + oGd435Ocr:aCols[oGd435Ocr:nAt,nPosSol] )

							RecLock( cAlsOcor, .F. )
										
								(cAlsOcor)->TN_TAREFA  := oGd435Ocr:aCols[oGd435Ocr:nAt,nPosTar]
								(cAlsOcor)->TN_CODOCOR := oGd435Ocr:aCols[oGd435Ocr:nAt,nPosPro]
								(cAlsOcor)->TN_CAUSA   := oGd435Ocr:aCols[oGd435Ocr:nAt,nPosCau]
								(cAlsOcor)->TN_SOLUCAO := oGd435Ocr:aCols[oGd435Ocr:nAt,nPosSol]
								(cAlsOcor)->TN_DESCRIC := oGd435Ocr:aCols[oGd435Ocr:nAt,nPosObs]

							MsUnLock()
						
						Else

							RecLock( cAlsOcor, .T. )
										
								(cAlsOcor)->TN_TAREFA  := oGd435Ocr:aCols[oGd435Ocr:nAt,nPosTar]
								(cAlsOcor)->TN_CODOCOR := oGd435Ocr:aCols[oGd435Ocr:nAt,nPosPro]
								(cAlsOcor)->TN_CAUSA   := oGd435Ocr:aCols[oGd435Ocr:nAt,nPosCau]
								(cAlsOcor)->TN_SOLUCAO := oGd435Ocr:aCols[oGd435Ocr:nAt,nPosSol]
								(cAlsOcor)->TN_ORDEM   := cOrdemTJ
								(cAlsOcor)->TN_PLANO   := cPlanoTJ
								(cAlsOcor)->TN_SEQRELA := oGd435Ass:aCols[nInd1,nPosSeq]
								(cAlsOcor)->TN_DESCRIC := oGd435Ocr:aCols[oGd435Ocr:nAt,nPosObs]

							MsUnLock()

						EndIf

					Else

						nPosErr := nInd1

						Exit

					EndIf

				EndIf
				
			Next nInd1

		/*------------------+
		| Execução de Etapa |
		+------------------*/
		Case nGetDad == 2

			For nInd1 := 1 To Len( oGD435In2:aCols )

				/*-------------------+
				| Validação de linha |
				+-------------------*/
				If !( lRet := MNA435LiOk( Nil, nInd1, 2 ) )

					Exit 

				EndIf
			
			Next nInd1

			If lRet

				oObjDlg:End() 

			EndIf

		/*------------+
		| Ocorrências |
		+------------*/
		Case nGetDad == 3

			For nInd1 := 1 To Len( oGD435Ocr:aCols )
				
				/*-------------------+
				| Validação de linha |
				+-------------------*/
				If !( lRet := MNA435LiOk( Nil, nInd1, 3 ) )
					
					nPosErr := nInd1

					Exit

				EndIf

			Next nInd1

	End Case
	
Return lRet

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} MNTA435SXB
Filtro para consulta padrão ST8435.
@type function

@author Alexandre Santos
@since 21/12/2023

@param 
@return boolean, Condição SQL para filtro dos registros de ocorrências.
/*/
//-----------------------------------------------------------------------------------
Function MNTA435SXB()

	Local cTipOcr := 'P' // Problema
	Local cCodFam := ''
	Local cCodTar := ''
	Local cCaract := ''
	Local cReturn := ''
	Local cCampo  := ReadVar()

	dbSelectArea( 'STJ' )
	dbSetOrder( 1 ) // TJ_FILIAL + TJ_ORDEM + TJ_PLANO
	If msSeek( FWxFilial( 'STJ' ) + (cAliOS435)->TJ_ORDEM )

		/*----------------------------------------------+
		| Define caracteristica para filtro de tarefas. |
		+----------------------------------------------*/
		If STJ->TJ_PLANO == '000000'

			cCaract := '2' // Corretiva

		Else

			cCaract := '1' // Preventiva

		EndIf
	
		/*----------------------------------------+
		| Busca família do bem vinculada a ordem. |
		+----------------------------------------*/
		cCodFam := Posicione( 'ST9', 1, FWxFilial('ST9') + STJ->TJ_CODBEM, 'T9_CODFAMI' )

		/*-----------------------------------------+
		| Define o tipo de ocorrência para filtro. |
		+-----------------------------------------*/
		If cCampo == 'M->TN_CAUSA'

			cTipOcr := 'C' // Causa

		ElseIf cCampo == 'M->TN_SOLUCAO'

			cTipOcr := 'S' // Solução

		EndIf

		/*-----------------------------------------------+
		| Busca tarefa informada na linha da ocorrência. |
		+-----------------------------------------------*/
		cCodTar := GDFieldGet( 'TN_TAREFA', oGd435Ocr:nAt, .F.,;
			oGd435Ocr:aHeader, oGd435Ocr:aCols )
	
		/*-------------------------------------+
		| Retorna filtro SQL para ocorrências. |
		+-------------------------------------*/
		cReturn := MNTA125Fil( cTipOcr, cCodFam, cCodTar, cCaract )

	EndIf
	
Return cReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} fChgFolder
Ação ao trocar de folder.
@type function

@author Alexandre Santos
@since  14/02/2024

@param
@return
/*/
//-------------------------------------------------------------------
Function fChgFolder()

	Do Case

        Case oFolder435:nOption == 1

			oBrw6:oBrowse:Refresh()
			oBrw6:oBrowse:SetFocus()

        Case oFolder435:nOption == 2

        Case oFolder435:nOption == 3

			oGD435Ocr:oBrowse:Refresh()
			oGD435Ocr:oBrowse:SetFocus()

        Case oFolder435:nOption == 4


    EndCase

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fLoadOcorr
Carga de ocorrências.
@type function

@author Alexandre Santos
@since  09/10/2024

@param nLinOS   , integer, Linha da O.S. posicionada.
@param nLinOcr  , integer, Linha da ocorrência posicionada.

@return
/*/
//-------------------------------------------------------------------
Static Function fLoadOcorr( nLinOS, nLinOcr )

	Local aLine   := {}
	Local nInd1   := 0
	Local nPosTar := GDFieldPos( 'TN_TAREFA' , oGd435Ocr:aHeader )
	Local nPosPro := GDFieldPos( 'TN_CODOCOR', oGd435Ocr:aHeader )
	Local nPosCau := GDFieldPos( 'TN_CAUSA'  , oGd435Ocr:aHeader )
	Local nPosSol := GDFieldPos( 'TN_SOLUCAO', oGd435Ocr:aHeader )
	Local nPosOcr := 0

	/*-----------------------------------------+
	| Ativa manipulação do browse pelo sistema |
	+-----------------------------------------*/
	oGd435Ocr:oBrowse:lDisablePaint := .F.

	If !Empty( aDadosOS[nLinOS,_OCCURRENCES_] )
		
		/*-----------------------------------------------------------------------+
		| Quando a carga inicial já foi feita, busca as informações do aDadosOS. |
		+-----------------------------------------------------------------------*/
		oGd435Ocr:aCols := aClone( aDadosOS[nLinOS,_OCCURRENCES_] )

	Else

		SetInclui( .F. )

		/*---------------------------------------------------+
		| Carga inicial, busca as informações da tabela STN. |
		+---------------------------------------------------*/
		dbSelectArea( 'STN' )
		dbSetOrder( 1 ) // TN_FILIAL + TN_ORDEM + TN_PLANO + TN_TAREFA + TN_SEQRELA + TN_CODOCOR + TN_CAUSA + TN_SOLUCAO
		If msSeek( FWxFilial( 'STN' ) + cOrdemTJ + cPlanoTJ )

			While STN->( !EoF() ) .And. STN->TN_ORDEM == cOrdemTJ .And.;
				STN->TN_PLANO == cPlanoTJ

				RecLock( cAlsOcor, .T. )

					(cAlsOcor)->TN_ORDEM   := STN->TN_ORDEM   
					(cAlsOcor)->TN_PLANO   := STN->TN_PLANO  
					(cAlsOcor)->TN_TAREFA  := STN->TN_TAREFA 
					(cAlsOcor)->TN_SEQRELA := STN->TN_SEQRELA
					(cAlsOcor)->TN_CODOCOR := STN->TN_CODOCOR
					(cAlsOcor)->TN_CAUSA   := STN->TN_CAUSA  
					(cAlsOcor)->TN_SOLUCAO := STN->TN_SOLUCAO
					(cAlsOcor)->TN_DESCRIC := STN->TN_DESCRIC
					(cAlsOcor)->RECSTN     := STN->( RecNo() )

				MsUnLock()

				If ( nPosOcr := aScan( aDadosOS[nLinOS,_OCCURRENCES_], { |x| x[nPosTar] == STN->TN_TAREFA .And.;
					x[nPosPro] == STN->TN_CODOCOR .And.	x[nPosCau] == STN->TN_CAUSA .And. x[nPosSol] == STN->TN_SOLUCAO } ) ) == 0

					aLine := {}

					For nInd1 := 1 To Len( oGd435Ocr:aHeader )
							
						If Posicione( 'SX3', 2, oGd435Ocr:aHeader[nInd1,2], 'X3_CONTEXT' ) == 'V'

							aAdd( aLine, CriaVar( AllTrim( oGd435Ocr:aHeader[nInd1,2] ) ) )

						ElseIf oGd435Ocr:aHeader[nInd1,2] == 'LEGENDA'

							If Trim( STN->TN_SEQRELA ) == '0'

								aAdd( aLine, 'BR_VERMELHO' )

							Else

								aAdd( aLine, 'BR_VERDE' )
								
							EndIf

						Else

							cField := oGd435Ocr:aHeader[nInd1,2]
							aAdd( aLine, &cField. )

						Endif
						
					Next nInd1

					aAdd( aLine, {} )

					aAdd( aLine, .F. )

					aAdd( aDadosOS[nLinOS,_OCCURRENCES_], aClone( aLine ) )

					/*----------------------------------------+
					| Posição da última ocorrência carregada. |
					+----------------------------------------*/
					nPosOcr := Len( aDadosOS[nLinOS,_OCCURRENCES_] )

				EndIf

				
				If Trim( STN->TN_SEQRELA ) != '0'

					/*------------------------------------------+
					| Carga de insumos associados à ocorrência. |
					+------------------------------------------*/
					fLoadAssoc( nLinOS, nPosOcr, STN->TN_TAREFA, STN->TN_CODOCOR,;
						STN->TN_CAUSA, STN->TN_SOLUCAO )

					/*--------------------------------------------------------+
					| Atualiza legenda para ocorrências com insumo associado. |
					+--------------------------------------------------------*/
					aDadosOS[nLinOS,_OCCURRENCES_,nPosOcr,1] := 'BR_VERDE'

				EndIf
				
				STN->( dbSkip() )

			End

		EndIf

		SetInclui( .T. )

		If !Empty( aDadosOS[nLinOS,_OCCURRENCES_] )
			
			oGd435Ocr:aCols := aClone( aDadosOS[nLinOS,_OCCURRENCES_] )
			aBrw3Old        := aClone( oGd435Ocr:aCols )

		Else

			oGd435Ocr:aCols := aClone( aNovaOcor )
			aBrw3Old        := {}

		EndIf

	EndIf

	aCols    := aClone( oGd435Ocr:aCols )
	aHeader  := aClone( oGd435Ocr:aHeader )
	
	oGd435Ocr:oBrowse:Refresh()

	/*--------------------------------------------------------------------------------+
	| Inicialização da primeira linha do GetDados de Ocorrencia e Insumos Associados. |
	+--------------------------------------------------------------------------------*/
	fChangeOcr( nLinOS, nLinOcr )

	/*-----------------------------------------+
	| Ativa manipulação do browse pelo sistema |
	+-----------------------------------------*/
	oGd435Ocr:oBrowse:lDisablePaint := .T.

	FWFreeArray( aLine )
	
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fLoadAssoc
Carga de insumos associados à ocorrência.
@type function

@author Alexandre Santos
@since  09/10/2024

@param [nLinOS] , integer, Linha da O.S. posicionada.
@param [nLinOcr], integer, Linha da ocorrência posicionada.
@param cCodTar  , string , Código da tarefa
@param cCodPro  , string , Problema
@param cCodCau  , string , Causa
@param cCodSol  , string , Solução
 
@return
/*/
//-------------------------------------------------------------------
Static Function fLoadAssoc( nLinOS, nLinOcr, cCodTar, cCodPro, cCodCau, cCodSol )

	Local aAssoc  := {}
	Local aLine   := {}
	Local aBind   := {}
	Local cAlsSTL := GetNextAlias()
	Local nInd1   := 0

	Default nLinOS  := aScan( aDadosOS, { |x| x[1] + x[2] == cOrdemTJ + cPlanoTJ } )
	Default nLinOcr := 1

	If Empty( cQryInsAss )

		cQryInsAss := "SELECT "
		cQryInsAss += 	"STL.R_E_C_N_O_ "
		cQryInsAss += "FROM "
		cQryInsAss += 	RetSqlName( 'STL' ) + " STL "
		cQryInsAss += "INNER JOIN "
		cQryInsAss += 	RetSqlName( 'STN' ) + " STN ON "
		cQryInsAss += 	"STN.TN_ORDEM   = STL.TL_ORDEM   AND "
		cQryInsAss += 	"STN.TN_PLANO   = STL.TL_PLANO   AND "
		cQryInsAss += 	"STN.TN_TAREFA  = STL.TL_TAREFA  AND "
		cQryInsAss +=   "STN.TN_SEQRELA = STL.TL_SEQRELA AND "
		cQryInsAss += 	"STN.TN_CODOCOR = ?              AND "
		cQryInsAss += 	"STN.TN_CAUSA   = ?              AND "
		cQryInsAss += 	"STN.TN_SOLUCAO = ?              AND "
		cQryInsAss += 	"STN.D_E_L_E_T_ = ? "
		cQryInsAss += "WHERE "
		cQryInsAss += 	"STL.TL_FILIAL  = ? AND "
		cQryInsAss += 	"STL.TL_ORDEM   = ? AND "
		cQryInsAss += 	"STL.TL_PLANO   = ? AND "
		cQryInsAss += 	"STL.TL_TAREFA  = ? AND "
		cQryInsAss += 	"STL.TL_SEQRELA > ? AND "
		cQryInsAss += 	"STL.D_E_L_E_T_ = ? "

		cQryInsAss := ChangeQuery( cQryInsAss )

	EndIf

	aAdd( aBind, cCodPro )
	aAdd( aBind, cCodCau )
	aAdd( aBind, cCodSol )
	aAdd( aBind, Space( 1 ) )
	aAdd( aBind, FWxFilial( 'STL' ) )
	aAdd( aBind, cOrdemTJ )
	aAdd( aBind, cPlanoTJ )
	aAdd( aBind, cCodTar )
	aAdd( aBind, '0' )
	aAdd( aBind, Space( 1 ) )

	dbUseArea( .T., 'TOPCONN', TcGenQry2( , , cQryInsAss, aBind ), cAlsSTL, .T., .T. )

	While (cAlsSTL)->( !EoF() )

		dbSelectArea( 'STL' )
		dbGoTo( (cAlsSTL)->R_E_C_N_O_ )

		aLine := {}

		For nInd1 := 1 To Len( oGd435Ass:aHeader )
			
			If Posicione( 'SX3', 2, oGd435Ass:aHeader[nInd1,2], 'X3_CONTEXT' ) == 'V'

				aAdd( aLine, CriaVar( AllTrim( oGd435Ass:aHeader[nInd1,2] ) ) )

			Else

				cField := oGd435Ass:aHeader[nInd1,2]
				
				aAdd( aLine, &cField. )

			Endif
		
		Next nInd1

		aAdd( aLine, .F. )

		aAdd( aAssoc, aClone( aLine ) )

		(cAlsSTL)->( dbSkip() )

	End

	/*--------------------------------------------------------------+
	| Carga inicial de insumos associados à ocorrência no aDadosOS. |
	+--------------------------------------------------------------*/
	aDadosOS[nLinOS,_OCCURRENCES_,nLinOcr,_INSUMOCORRE_] := aClone( aAssoc )

	FWFreeArray( aBind )
	FWFreeArray( aLine )
	FWFreeArray( aAssoc )

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fChangeOcr
Ação ao trocar de ocorrência.
@type function

@author Alexandre Santos
@since  04/10/2024

@param [nLinOS] , integer, Linha de O.S. posicionada.
@param [nLinOcr], integer, Linha da ocorrência posicionada.

@return
/*/
//-------------------------------------------------------------------
Static Function fChangeOcr( nLinOS, nLinOcr )

	Default nLinOS  := aScan( aDadosOS, { |x| x[1] + x[2] == cOrdemTJ + cPlanoTJ } )
	Default nLinOcr := oGd435Ocr:nAt
	
	/*-----------------------------------------+
	| Ativa manipulação do browse pelo sistema |
	+-----------------------------------------*/
	oGd435Ass:oBrowse:lDisablePaint := .F.
	
	If nLinOS > 0

		If Len( aDadosOS[nLinOS,_OCCURRENCES_] ) >= oGd435Ocr:nAt
	
			If !Empty( aDadosOS[nLinOS,_OCCURRENCES_,oGd435Ocr:nAt,_INSUMOCORRE_] )

				/*------------------------------------------------------------------+
				| Carrega informações do aDadosOS no GetDados de insumos associados |
				+------------------------------------------------------------------*/
				oGd435Ass:aCols := aClone( aDadosOS[nLinOS,_OCCURRENCES_,oGd435Ocr:nAt,_INSUMOCORRE_] )

			Else
				
				/*----------------------------------------------------------+
				| Carrega uma linha vazia no GetDados de insumos associados |
				+----------------------------------------------------------*/
				oGd435Ass:aCols := BlankGetD( oGd435Ass:aHeader )

			EndIf

		Else

			/*----------------------------------------------------------+
			| Carrega uma linha vazia no GetDados de insumos associados |
			+----------------------------------------------------------*/
			oGd435Ass:aCols := BlankGetD( oGd435Ass:aHeader )

		EndIf

	EndIf

	oGd435Ass:oBrowse:Refresh()

	/*--------------------------------------------+
	| Desativa manipulação do browse pelo sistema |
	+--------------------------------------------*/
	oGd435Ass:oBrowse:lDisablePaint := .T.

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fTrbOcorr
Monta estrutura das tabelas temporárias utilizadas para ocorrências.
@type function

@author Alexandre Santos
@since  04/10/2024

@param 
@return
/*/
//-------------------------------------------------------------------
Static Function fTrbOcorr()

	Local nInd1     := 0
	Local aEstruOcr := {}

	aAdd( aEstruOcr, { 'TRB_OK'    , 'C' , 02, 0 } )

	For nInd1 := 1 To Len( aHoBrw3_3 )

		aAdd( aEstruOcr, { AllTrim( aHoBrw3_3[nInd1,2] ), aHoBrw3_3[nInd1,8],;
			aHoBrw3_3[nInd1,4], aHoBrw3_3[nInd1,5] } )

		aAdd( aEstruAss, { aHoBrw3_3[nInd1,1], Alltrim( aHoBrw3_3[nInd1,2] ), aHoBrw3_3[nInd1,8],;
			aHoBrw3_3[nInd1,4], aHoBrw3_3[nInd1,5], aHoBrw3_3[nInd1,3] } )

	Next nInd1

	/*------------------------------------------------------------------------+
	| Cria tabela temporária para insumos listados no processo de associação. |
	+------------------------------------------------------------------------*/
	oTmpTbl7 := FWTemporaryTable():New( cAlsAssoc, aEstruOcr )
	oTmpTbl7:AddIndex( '1', { 'TL_SEQRELA' } )
	oTmpTbl7:AddIndex( '2', { 'TRB_OK' } )
	oTmpTbl7:Create() 

	aEstruOcr:= {}

	For nInd1 := 1 To Len( aHoBrw3 )

		If aHoBrw3[nInd1,10] != 'V'

			aAdd( aEstruOcr, { AllTrim( aHoBrw3[nInd1,2] ), aHoBrw3[nInd1,8],;
				aHoBrw3[nInd1,4], aHoBrw3[nInd1,5] } )

		EndIf

	Next nInd1

	aAdd( aEstruOcr, { 'TN_ORDEM'  , 'C', 6 , 0 } )
	aAdd( aEstruOcr, { 'TN_PLANO'  , 'C', 6 , 0 } )
	aAdd( aEstruOcr, { 'TN_SEQRELA', 'C', 3 , 0 } )
	aAdd( aEstruOcr, { 'RECSTN'    , 'N', 10, 0 } )

	/*------------------------------------------------------------------------+
	| Cria tabela temporária para insumos listados no processo de associação. |
	+------------------------------------------------------------------------*/
	oTmpTbl8 := FWTemporaryTable():New( cAlsOcor, aEstruOcr )
	oTmpTbl8:AddIndex( '1', { 'TN_ORDEM' , 'TN_PLANO'  , 'TN_SEQRELA', 'TN_TAREFA' , 'TN_CODOCOR', 'TN_CAUSA', 'TN_SOLUCAO' } )
	oTmpTbl8:AddIndex( '2', { 'TN_TAREFA', 'TN_CODOCOR', 'TN_CAUSA'  , 'TN_SOLUCAO', 'TN_ORDEM'  , 'TN_PLANO' } )
	oTmpTbl8:Create()

	FWFreeArray( aEstruOcr )

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fOcorrAss
Monta tela para associar insumos realizados a uma ocorrência.
@type function

@author Alexandre Santos
@since  04/10/2024

@param 
@return
/*/
//-------------------------------------------------------------------
Static Function fOcorrAss()

	Local aFields  := aClone( aEstruAss )
	Local aColunas := {}
	Local aOccorre := {} 
	Local aLine    := {}
	Local nInd1    := 0
	Local nLinOS   := 0
	Local nPosIns  := 0
	Local nPosTare := GDFieldPos( 'TN_TAREFA' , oGd435Ocr:aHeader )
	Local nPosProb := GDFieldPos( 'TN_CODOCOR', oGd435Ocr:aHeader )
	Local nPosCaus := GDFieldPos( 'TN_CAUSA'  , oGd435Ocr:aHeader )
	Local nPosSolu := GDFieldPos( 'TN_SOLUCAO', oGd435Ocr:aHeader )
	Local nPosObsv := GDFieldPos( 'TN_DESCRIC', oGd435Ocr:aHeader )
	Local nPosSeq1 := GDFieldPos( 'TL_SEQRELA', oGd435Ass:aHeader )
	Local nPosTar2 := GDFieldPos( 'TL_TAREFA' , oBrw6:aHeader )
	Local nPosSeq2 := GDFieldPos( 'TL_SEQRELA', oBrw6:aHeader )
	Local lSave    := .T.
	
	Local oColuna
	Local oPnlBot
	Local oGd435Oc2
	Local oGd435As2
	Local oDlgAssoc
	Local oPnlMaster
	Local oPnlTop

	/*-------------------------------------------------+
	| Limpa dados da tabela de insumos para associação |
	+-------------------------------------------------*/
	NGZap( oTmpTbl7:GetRealName() )

	/*----------------------------------+
	| Desconsidera ocorrência deletada. |
	+----------------------------------*/
	If !aTail( oGd435Ocr:aCols[oGd435Ocr:nAt] )

		/*-----------------------------------------------------------------------------+
		| Carrega para o MarkBrowse os insumos realizados disponiveis para associação. |
		+-----------------------------------------------------------------------------*/
		For nInd1 := 1 To Len( oBrw6:aCols )

			/*--------------------------------+
			| Desconsidera insumos deletados. |
			+--------------------------------*/
			If !aTail( oBrw6:aCols[nInd1] )
				
				/*-----------------------------------------------------+
				| Permitir associar ocorrência à insumos com tarefa 0. |
				+-----------------------------------------------------*/
				If !( AllTrim( GDFieldGet( 'TL_TAREFA', nInd1, .F., oBrw6:aHeader, oBrw6:aCols ) ) == '0' )

					/*--------------------------------------------------------------------------+
					| Para permitir associar, ocorrência e insumo devem possuir a mesma tarefa. |
					+--------------------------------------------------------------------------*/
					If !( GDFieldGet( 'TN_TAREFA', oGd435Ocr:nAt, .F., oGd435Ocr:aHeader, oGd435Ocr:aCols ) ==;
						GDFieldGet( 'TL_TAREFA', nInd1, .F., oBrw6:aHeader, oBrw6:aCols ) )

						Loop

					EndIf

				EndIf

				/*--------------------------------------------------------------------+
				| Não carrega insumos do tipo Ferramenta, Especialidade ou Terceiros. |
				+--------------------------------------------------------------------*/
				If GDFieldGet( 'TL_TIPOREG', nInd1, .F., oBrw6:aHeader, oBrw6:aCols ) $ 'F/E/T'

					Loop

				EndIf

				/*-----------------------------------------------------------------------------------------+
				| Não carrega se a sequencia do insumo realizado estiver associada, mesmo quando deletada. |
				+-----------------------------------------------------------------------------------------*/
				If aScan( oGd435Ass:aCols, { |x| x[nPosSeq1] == oBrw6:aCols[nInd1,nPosSeq2] }  ) > 0

					Loop

				EndIf

				dbSelectArea( cAlsOcor )
				dbSetOrder( 1 ) // TN_ORDEM + TN_PLANO + TN_SEQRELA
				If !msSeek( cOrdemTJ + cPlanoTJ + GDFieldGet( 'TL_SEQRELA', nInd1, .F., aHoBrw6, aCoBrw6 ) )

					RecLock( cAlsAssoc, .T. )
						
						(cAlsAssoc)->TRB_OK     := ''
						(cAlsAssoc)->TL_TIPOREG := GDFieldGet( 'TL_TIPOREG', nInd1, .F., oBrw6:aHeader, oBrw6:aCols )
						(cAlsAssoc)->TL_CODIGO  := GDFieldGet( 'TL_CODIGO' , nInd1, .F., oBrw6:aHeader, oBrw6:aCols )
						(cAlsAssoc)->TL_NOMCODI := GDFieldGet( 'TL_NOMCODI', nInd1, .F., oBrw6:aHeader, oBrw6:aCols )
						(cAlsAssoc)->TL_USACALE := GDFieldGet( 'TL_USACALE', nInd1, .F., oBrw6:aHeader, oBrw6:aCols )
						(cAlsAssoc)->TL_QUANREC := GDFieldGet( 'TL_QUANREC', nInd1, .F., oBrw6:aHeader, oBrw6:aCols )
						(cAlsAssoc)->TL_QUANTID := GDFieldGet( 'TL_QUANTID', nInd1, .F., oBrw6:aHeader, oBrw6:aCols )
						(cAlsAssoc)->TL_UNIDADE := GDFieldGet( 'TL_UNIDADE', nInd1, .F., oBrw6:aHeader, oBrw6:aCols )
						(cAlsAssoc)->TL_CUSTO   := GDFieldGet( 'TL_CUSTO'  , nInd1, .F., oBrw6:aHeader, oBrw6:aCols )
						(cAlsAssoc)->TL_DESTINO := GDFieldGet( 'TL_DESTINO', nInd1, .F., oBrw6:aHeader, oBrw6:aCols )
						(cAlsAssoc)->TL_DTINICI := GDFieldGet( 'TL_DTINICI', nInd1, .F., oBrw6:aHeader, oBrw6:aCols )
						(cAlsAssoc)->TL_HOINICI := GDFieldGet( 'TL_HOINICI', nInd1, .F., oBrw6:aHeader, oBrw6:aCols )
						(cAlsAssoc)->TL_DTFIM   := GDFieldGet( 'TL_DTFIM'  , nInd1, .F., oBrw6:aHeader, oBrw6:aCols )
						(cAlsAssoc)->TL_HOFIM   := GDFieldGet( 'TL_HOFIM'  , nInd1, .F., oBrw6:aHeader, oBrw6:aCols )
						(cAlsAssoc)->TL_SEQRELA := GDFieldGet( 'TL_SEQRELA', nInd1, .F., oBrw6:aHeader, oBrw6:aCols )

					MsUnLock()

				EndIf

			EndIf
			
		Next nInd1

		dbSelectArea( cAlsAssoc )
		dbGoTop()

		/*-------------------------------------------------------------------+
		| Copia para o novo browse as informações da ocorrência posicionada. |
		+-------------------------------------------------------------------*/
		aAdd( aOccorre, aClone( oGd435Ocr:aCols[oGd435Ocr:nAt] ) )

		DEFINE MSDIALOG oDlgAssoc TITLE STR0420 From 3,0 TO 340,417 PIXEL // Associação Insumo x Ocorrência

			oDlgAssoc:lMaximized := .T.

			oPnlMaster := TPanel():New( 0, 0, , oDlgAssoc, , , , , , 10, 10 )
			oPnlMaster:Align := CONTROL_ALIGN_ALLCLIENT

				oPnlTop := TPanel():New( 0, 0, , oPnlMaster, , , , , , 10, 50 )
				oPnlTop:Align := CONTROL_ALIGN_TOP

					/*-----------------------------------------------+
					| Browse que lista a ocorrência para associação. |
					+-----------------------------------------------*/
					oGd435Oc2 := FwBrowse():New()
					oGd435Oc2:SetOwner( oPnlTop )
					oGd435Oc2:DisableConfig()
					oGd435Oc2:DisableFilter() 
					oGd435Oc2:DisableLocate()
					oGd435Oc2:DisableReport() 
					oGd435Oc2:DisableSeek()   
					oGd435Oc2:DisableSaveConfig()
					oGd435Oc2:DisableFilter()
					oGd435Oc2:SetDataArray()
					oGd435Oc2:SetInsert( .F. )

					For nInd1 := 1 To Len( oGd435Ocr:aHeader )
						
						If !( oGd435Ocr:aHeader[nInd1,2] == 'LEGENDA' )

							// Instancia a Classe
							oColuna := FWBrwColumn():New()

							// Definições Básicas do Objeto
							oColuna:SetAlign(If(oGd435Ocr:aHeader[nInd1,8] == "N", CONTROL_ALIGN_RIGHT, CONTROL_ALIGN_LEFT))
							oColuna:SetEdit( .F. )

							// Definições do Dado apresentado
							oColuna:SetSize( oGd435Ocr:aHeader[nInd1,4] )
							oColuna:SetTitle( oGd435Ocr:aHeader[nInd1,1] )
							oColuna:SetType( oGd435Ocr:aHeader[nInd1,8] )
							oColuna:SetPicture( oGd435Ocr:aHeader[nInd1,3] )

							cSetData := "{|| aOccorre[oGd435Oc2:At()][" + cValToChar(nInd1) + "] }"
							oColuna:SetData( &(cSetData) )

							aAdd( aColunas, oColuna )

						EndIf
					
					Next nInd1

				oGd435Oc2:SetColumns( aColunas )
				oGd435Oc2:SetArray( aOccorre )
				oGd435Oc2:Activate()

				oPnlBot := TPanel():New( 0, 0, , oPnlMaster, , , , , CLR_RED, 10, 50  )
				oPnlBot:Align := CONTROL_ALIGN_ALLCLIENT

					/*----------------------------------------------------------------------------+
					| MarkBrowse que lista todos os insumos realizados disponiveis para associar. |
					+----------------------------------------------------------------------------*/
					oGd435As2 := FWMarkBrowse():New()
					oGd435As2:SetOwner( oPnlBot )
					oGd435As2:SetTemporary( .T. )
					oGd435As2:SetAlias( cAlsAssoc )
					oGd435As2:SetFieldMark( 'TRB_OK' )
					oGd435As2:SetMark( cMarca, cAlsAssoc, 'TRB_OK' )
					oGd435As2:SetAllMark( { || fMarkAssoc( oGd435As2 ) } )
					oGd435As2:SetFields( aFields )
					oGd435As2:SetIgnoreARotina( .T. )
					oGd435As2:DisableDetails()
					oGd435As2:DisableReport()
					oGd435As2:DisableSaveConfig()
					oGd435As2:DisableConfig()
					oGd435As2:DisableFilter()
					oGd435As2:Activate()

		ACTIVATE MSDIALOG oDlgAssoc ON INIT EnchoiceBar( oDlgAssoc, { || lSave := .T., oDlgAssoc:End() },;
			{|| lSave := .F., oDlgAssoc:End() }) CENTERED

		If lSave

			/*-----------------------------------------+
			| Ativa manipulação do browse pelo sistema |
			+-----------------------------------------*/
			oGd435Ocr:oBrowse:lDisablePaint := .F.
			oGd435Ass:oBrowse:lDisablePaint := .F.

			dbSelectArea( cAlsAssoc )
			dbGoTop()

			While (cAlsAssoc)->( !EoF() )
				
				If !Empty( (cAlsAssoc)->TRB_OK )
						
					RecLock( cAlsOcor, .T. )
						
						(cAlsOcor)->TN_TAREFA  := aOccorre[1,nPosTare]
						(cAlsOcor)->TN_CODOCOR := aOccorre[1,nPosProb]
						(cAlsOcor)->TN_CAUSA   := aOccorre[1,nPosCaus]
						(cAlsOcor)->TN_SOLUCAO := aOccorre[1,nPosSolu]
						(cAlsOcor)->TN_ORDEM   := cOrdemTJ
						(cAlsOcor)->TN_PLANO   := cPlanoTJ
						(cAlsOcor)->TN_SEQRELA := (cAlsAssoc)->TL_SEQRELA 
						(cAlsOcor)->TN_DESCRIC := aOccorre[1,nPosObsv]

					MsUnLock()

					aLine := {}

					For nInd1 := 1 To Len( oGd435Ass:aHeader )
						
						cField := oGd435Ass:aHeader[nInd1,2]
							
						aAdd( aLine, (cAlsAssoc)->( &cField. ) )
					
					Next nInd1

					aAdd( aLine, .F. )

					If Empty( oGd435Ass:aCols[1,1] )

						aDel( oGd435Ass:aCols , 1 )

						aSize( oGd435Ass:aCols, 0 )
					
					EndIf

					/*------------------------------------------+
					| Busca linha da O.S. posiciona no momento. |
					+------------------------------------------*/
					nLinOS := aScan( aDadosOS, { |x| x[1] + x[2] == cOrdemTJ + cPlanoTJ } )

					/*-------------------------------------------------------------------------+
					| Quando insumo possui tarefa 0, atualiza este com a tarefa da ocorrência. |
					+-------------------------------------------------------------------------*/
					If !( AllTrim( aOccorre[1,nPosTare] ) == '0' ) .And. ( nPosIns := aScan( oBrw6:aCols, { |x| !aTail( x ) .And.;
						x[nPosSeq2] == (cAlsAssoc)->TL_SEQRELA .And. AllTrim( x[nPosTar2] ) == '0' } ) ) > 0

						oBrw6:aCols[nPosIns,nPosTar2] := aOccorre[1,nPosTare]

						aDadosOS[nLinOS,5] := aClone( oBrw6:aCols )

					EndIf

					/*---------------------------------------------------------+
					| Atualiza objeto do GetDados com o novo insumo associado. |
					+---------------------------------------------------------*/
					aAdd( oGd435Ass:aCols, aClone( aLine ) )

					/*----------------------------------------------------------------+
					| Atualiza insumos associados a ocorrência no objeto do GetDados. |
					+----------------------------------------------------------------*/
					oGd435Ocr:aCols[oGd435Ocr:nAt,_INSUMOCORRE_] := aClone( oGd435Ass:aCols )

					/*-------------------------------+
					| Atualiza legenda da ocorrência |
					+-------------------------------*/
					oGd435Ocr:aCols[oGd435Ocr:nAt,_LEGENDAOCOR_] := 'BR_VERDE'

					/*------------------------------------------------------+
					| Atualiza insumos associados a ocorrência no aDadosOS. |
					+------------------------------------------------------*/
					aDadosOS[nLinOS,_OCCURRENCES_] := aClone( oGd435Ocr:aCols )

					/*-------------------------------------------------------+
					| Força atualização do objeto para listar o novo insumo. |
					+-------------------------------------------------------*/
					oGd435Ass:ForceRefresh()

					/*----------------------------------------------+
					| Força atualização do objeto para com legenda. |
					+----------------------------------------------*/
					oGd435Ocr:ForceRefresh()

				EndIf

				(cAlsAssoc)->( dbSkip() )

			End

			/*--------------------------------------------+
			| Desativa manipulação do browse pelo sistema |
			+--------------------------------------------*/
			oGd435Ocr:oBrowse:lDisablePaint := .T.
			oGd435Ass:oBrowse:lDisablePaint := .T.

		EndIf

	EndIf

	aColunas := Nil
	FWFreeArray( aColunas )

	aLine := Nil
	FWFreeArray( aLine )

	aFields := Nil
	FWFreeArray( aFields )

	aOccorre := Nil
	FWFreeArray( aOccorre )
	
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fResetAsso
Zera insumos associados ao alterar um dos campos chave da ocorrência.
@type function

@author Alexandre Santos
@since  26/11/2024

@param cCampoAlt, string, Contéudo do campo alterado.
@param nPosAlter, string, Posição no aCols do campo em alteração.

@return
/*/
//-------------------------------------------------------------------
Static Function fResetAsso( cCampoAlt, nPosAlter )

	Local nInd1   := 0
	Local nPosTar := GDFieldPos( 'TN_TAREFA' , oGd435Ocr:aHeader )
	Local nPosPro := GDFieldPos( 'TN_CODOCOR', oGd435Ocr:aHeader )
	Local nPosCau := GDFieldPos( 'TN_CAUSA'  , oGd435Ocr:aHeader )
	Local nPosSol := GDFieldPos( 'TN_SOLUCAO', oGd435Ocr:aHeader )
	Local nPosSeq := GDFieldPos( 'TL_SEQRELA', oGd435Ass:aHeader )

	If !Empty( oGd435Ass:aCols[1,1] )

		/*-----------------------------------------+
		| Ativa manipulação do browse pelo sistema |
		+-----------------------------------------*/
		oGd435Ass:oBrowse:lDisablePaint := .F.

		For nInd1 := 1 to Len( oGd435Ass:aCols )

			dbSelectArea( cAlsOcor )
			dbSetOrder( 1 ) // TN_ORDEM + TN_PLANO + TN_SEQRELA + TN_TAREFA + TN_CODOCOR + TN_CAUSA + TN_SOLUCAO
			If msSeek( cOrdemTJ + cPlanoTJ + oGd435Ass:aCols[nInd1,nPosSeq] + oGd435Ocr:aCols[oGd435Ocr:nAt,nPosTar] +;
				oGd435Ocr:aCols[oGd435Ocr:nAt,nPosPro] + oGd435Ocr:aCols[oGd435Ocr:nAt,nPosCau] + oGd435Ocr:aCols[oGd435Ocr:nAt,nPosSol] )

				RecLock( cAlsOcor, .F. )

					dbDelete()

				MsUnLock()

			EndIf

		Next mInd1

		/*----------------------------------------------------------+
		| Carrega uma linha vazia no GetDados de insumos associados |
		+----------------------------------------------------------*/
		oGd435Ass:aCols := BlankGetD( oGd435Ass:aHeader )

		/*----------------------------------------------------------------+
		| Atualiza insumos associados a ocorrência no objeto do GetDados. |
		+----------------------------------------------------------------*/
		oGd435Ocr:aCols[oGd435Ocr:nAt,_INSUMOCORRE_] := aClone( oGd435Ass:aCols )

		/*-----------------------------------------------------+
		| Atualiza objeto da ocorrência com conteúdo alterado. |
		+-----------------------------------------------------*/
		oGd435Ocr:aCols[oGd435Ocr:nAt,nPosAlter] := cCampoAlt

		/*-------------------------------+
		| Atualiza legenda da ocorrência |
		+-------------------------------*/
		oGd435Ocr:aCols[oGd435Ocr:nAt,_LEGENDAOCOR_] := 'BR_VERMELHO'

		/*-------------------------------------------------------+
		| Força atualização do objeto para listar o novo insumo. |
		+-------------------------------------------------------*/
		oGd435Ass:ForceRefresh()

		/*-------------------------------------------------------+
		| Força atualização do objeto para listar o novo insumo. |
		+-------------------------------------------------------*/
		oGd435Ocr:ForceRefresh()

		/*--------------------------------------------+
		| Desativa manipulação do browse pelo sistema |
		+--------------------------------------------*/
		oGd435Ass:oBrowse:lDisablePaint := .T.

	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fMarkAssoc
Marca todos os registros do browse de insumos para associar.
@type function

@author Alexandre Santos
@since  02/12/2024

@param oMarkAss, object, Objeto do browse de marcação.

@return
/*/
//-------------------------------------------------------------------
Static Function fMarkAssoc( oMarkAss )

	Local aAreaTrb := (cAlsAssoc)->( FWGetArea() )

	dbSelectArea( cAlsAssoc )
	dbGoTop()

	While (cAlsAssoc)->( !EoF() )

		Reclock( cAlsAssoc, .F. )

			If Empty( (cAlsAssoc)->TRB_OK )

				(cAlsAssoc)->TRB_OK := cMarca

			Else
			
				(cAlsAssoc)->TRB_OK	:= Space( 2 )

			EndIf

		MsUnLock()

		(cAlsAssoc)->( dbSkip() )
	
	End

	FWRestArea( aAreaTrb )

	oMarkAss:GoTop()
	oMarkAss:Refresh()

	FWFreeArray( aAreaTrb )

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fPersSTL
Função responsável por validar se um Insumo já foi deletado mas não foi atualizado
em tela (Necessário para caso dois usuários acessem ao mesmo tempo e excluam Insumos diferentes).
@type function

@author João Ricardo Santini Zandoná
@since  10/09/2025

@param cOrdem, caractere, Código da Ordem de Serviço.
@param cOrdem, caractere, Código do plano da Ordem de Serviço.
@param aInsumo, array, Array com todos os campos referentes ao Insumos (Pego do aCols)

@return logico, indica se o Insumo é válido ou se já foi deletado
/*/
//-------------------------------------------------------------------
Static Function fPersSTL( cOrdem, cPlano, aInsumo )

	Local lReturn   := .T.
	Local aBind     := {}
	Local cAliasQry := GetNextAlias()

	If Empty( cQryPerStl )

		cQryPerStl := 'SELECT '
		cQryPerStl += 	'COUNT( STL.TL_CODIGO ) AS COUNTER '
		cQryPerStl += 'FROM '
		cQryPerStl += 	RetSqlName( 'STL' ) + ' STL '
		cQryPerStl += 'WHERE '
		cQryPerStl += 	'STL.TL_FILIAL = ? AND '
		cQryPerStl += 	'STL.TL_ORDEM  = ? AND '
		cQryPerStl += 	'STL.TL_PLANO  = ? AND '
		cQryPerStl += 	'STL.TL_TAREFA = ? AND '
		cQryPerStl +=	'STL.TL_TIPOREG = ? AND '
		cQryPerStl += 	'STL.TL_CODIGO = ? AND '
		cQryPerStl +=	'STL.TL_SEQRELA = ? AND '
		cQryPerStl += 	'STL.TL_DTINICI = ? AND '
		cQryPerStl += 	'STL.TL_HOINICI = ? AND '
		cQryPerStl += 	'STL.TL_DTFIM = ? AND '
		cQryPerStl += 	'STL.TL_HOFIM = ? AND '
		cQryPerStl += 	'STL.D_E_L_E_T_ = ? '

		cQryPerStl := ChangeQuery( cQryPerStl )

	EndIf

	aAdd( aBind, FWxFilial( 'STL' ) )
	aAdd( aBind, cOrdem )
	aAdd( aBind, cPlano )
	aAdd( aBind, aInsumo[ aScan( aHoBrw2, { |x| Trim( Upper( x[ 2 ] ) ) == 'TL_TAREFA' } ) ] )
	aAdd( aBind, aInsumo[ aScan( aHoBrw2, { |x| Trim( Upper( x[ 2 ] ) ) == 'TL_TIPOREG' } ) ] )
	aAdd( aBind, aInsumo[ aScan( aHoBrw2, { |x| Trim( Upper( x[ 2 ] ) ) == 'TL_CODIGO' } ) ] )
	aAdd( aBind, aInsumo[ aScan( aHoBrw2, { |x| Trim( Upper( x[ 2 ] ) ) == 'TL_SEQRELA' } ) ] )
	aAdd( aBind, DTOS( aInsumo[ aScan( aHoBrw2, { |x| Trim( Upper( x[ 2 ] ) ) == 'TL_DTINICI' } ) ] ) )
	aAdd( aBind, aInsumo[ aScan( aHoBrw2, { |x| Trim( Upper( x[ 2 ] ) ) == 'TL_HOINICI' } ) ] )
	aAdd( aBind, DTOS( aInsumo[ aScan( aHoBrw2, { |x| Trim( Upper( x[ 2 ] ) ) == 'TL_DTFIM' } ) ] ) )
	aAdd( aBind, aInsumo[ aScan( aHoBrw2, { |x| Trim( Upper( x[ 2 ] ) ) == 'TL_HOFIM' } ) ] )
	aAdd( aBind, '*' )

	dbUseArea( .T., 'TOPCONN', TcGenQry2( , , cQryPerStl, aBind ), cAliasQry, .T., .T. )

	If (cAliasQry)->COUNTER > 0

		lReturn := .F.

	EndIf

	(cAliasQry)->(DbCloseArea())

Return lReturn
