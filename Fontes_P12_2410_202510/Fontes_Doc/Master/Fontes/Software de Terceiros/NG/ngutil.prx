#INCLUDE "NGUTIL.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "DBINFO.CH"
#INCLUDE "MSGRAPHI.CH"
#INCLUDE "RWMAKE.CH"
#INCLUDE "Tbiconn.ch"
#INCLUDE "VKEY.CH"
#INCLUDE "APWIZARD.CH"
#INCLUDE "ap5mail.ch"
#INCLUDE "COLORS.CH"
#INCLUDE "TOPCONN.CH"
#INCLUDE 'PARMTYPE.CH'
#INCLUDE 'TBICONN.CH'

#DEFINE cCORAZ COLOR CLR_HBLUE

Static aTrbIndex  := {} //Controle de indices de TRB
Static aNGFilTemp := {} // variavel para armazenamento de filtro da funcao NGFilTemp

//------------------------------------------------------------------------------
/*/{Protheus.doc} hToM
Converte horas para minutos.
@type function

@author Alexandre Santos
@since 04/12/2019

@sample hToM( 08:59 )  => 539
		hToM( 09:00 )  => 540
		hToM( -08:59 ) => -539

@param  cHour   , Caracter, Horas a serem convertidas.
@return Númerico, Minutos equivalentes.
/*/
//------------------------------------------------------------------------------
Function hToM( cHour )
Return __Hrs2Min( cHour )

//------------------------------------------------------------------------------
/*/{Protheus.doc} mToH
Converte minutos para horas em formato de string.
@type function

@author Alexandre Santos
@since 04/12/2019

@sample mToH( 539.6 ) => 09:00
		mToH( 539.4 ) => 08:59
		mToH( -539  ) => -08:59

@param  nMinutes, Numérico, Minutos a serem convertidos.
@return Caracter, Hora equivalente já no formato 99:99.

@Obs Decimais acima ou igual a 5 são arredondados para o próxima valor inteiro.
Menores que cindo para o inteiro anterior.
/*/
//------------------------------------------------------------------------------
Function mToH( nMinutes )

	Local nHours    := 0
	Local nRest     := 0

	// Se negativo incluir o sinal para o mesmo.
	Local cFormat   := IIf( nMinutes < 0, '-', '' )

	// Logaritimo para definação da escala númerica das horas.
	Local bIntSize  := { |nInt| Int( Log10( nInt ) ) + 1 }

	// Realiza o arredondamento dos minutos já convertidos para um valor positivo.
	nMinutes := Round( Abs( nMinutes ), 0 )

	// Cálculo para definição da quantidade de horas.
	nHours   := Int( nMinutes / 60 )

	// Resto da divisão anterior, referente aos minutos.
	nRest    := Int( nMinutes % 60 )

	/*
	Define o valor da hora, incluindo um zero a esquerda para valores menores que 10 e mantendo o valor maximo
	para os demais.
	*/
	cFormat += StrZero( nHours, Max( 2, Eval( bIntSize, nHours ) ) ) + ':'

	//Define o valor em minuto, forçando o valor de duas casas.
	cFormat += StrZero( nRest, 2 )

Return cFormat

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ VALHORA  ³ Autor ³ NG INFORMATICA        ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consistencia de hora                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Parametros -> cHORA -> Horas em 99:99                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION VALHORA(cHora)
	Local nPos    := At(":",cHora)
	Local nHora   := Val(SubStr(cHora,1,(nPos-1)))
	Local nMinuto := Val(SubStr(cHora,(nPos+1)))
	Local lRet   	:= nMinuto < 60 .Or. nMinuto < 0
	Local lFim		:= .F.

	If "-" $ cHora
		Help(" ",1,"HORAINVALI")
		lRet := .F.
		lFim := .T.
	EndIf

	If !lFim
		//Valida a hora somente quando houver 2 digitos em Hora
		If lRet .And. nPos == 3
			lRet := nHora < 24 .Or. nMinuto < 0
		EndIf

		If Alltrim(cHORA) = ":" .Or. !lRet
			If Alltrim(cHORA) = ":"
				Help(" ",1,"HORAINVA")
			Else
				Help(" ",1,"HORAINVALI")
			EndIf
			lRet := .F.
		EndIf
	EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ VALDATA  ³ Autor ³ NG INFORMATICA        ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consistencia de datas                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION VALDATA(DT1,DT2,MESS)
	Local _Ret := .T.

	If (Dt2 < Dt1)
		_Ret := .F.
	Endif
	If !_Ret
		Help(" ",1,Mess)
	Endif
Return  _RET


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NTOH     ³ Autor ³ PAULO PEGO            ³ Data ³ 10/09/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Converte um valor (Numeric) em Horas (99:99)               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nHORAS   -> Quantidade de Horas (Decimal)                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³ Quantidade de horas (99:99)                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NTOH(nHORAS)
	If nHORAS = 0
		Return '00:00'
	EndIf

Return MtoH(nHORAS*60)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ HTON     ³ Autor ³ PAULO PEGO            ³ Data ³ 10/09/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Converte uma String no formato de horas em valor Decimal   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cHORAS   -> String formato de Horas (99:99)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function HTON(cHORAS)
Return Round(HtoM(cHORAS)/60,2)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ 	VDISP   ³ Autor ³ NG INFORMATICA        ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o valor de um campo apos pesquisa da chave         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ARG1 -> Chave de Pesquisa (Sem o xFilial())                ³±±
±±³          ³ ARG2 -> Expressao contendo o campo com o valor de retorno  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function VDISP(cKey,cINI,NTAM)
	Local cRet,cTIPO

	If !MsSeek(FwxFilial()+ckey) .or. Empty(cKey) .or. ( Type( "Inclui" ) == "L" .And. Inclui )
		cRet := &cINI.
		cRet := Space( Len(cRET) )
	Else
		cRet := &cINI.
	Endif

	cTIPO := VALTYPE(nTAM)
	IF cTIPO == "N"
		cRET := SubStr(cRet+Space(nTAM),01,nTAM)
	ENDIF
Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} CabecGetD
Monta o cabeçalho para uma GetDaodos.
@type Function

@author NG INFORMÁTICA
@since  15/12/2023

@param 	cAlias   , string , Tabela principal.
@param 	aCampos  , array  , Lista de campos que não serão incluidos.
@param 	nTipo    , integer, Tipo de GetDados.
							1 - MsGetDados
							2 - MsNewGetDados  
@param 	[lLegend], boolean, Indica se inclui coluna para legenda.

@return array, Cabeçalho no formato definido nos parâmetros.
/*/
//-------------------------------------------------------------------
Function CabecGetD( cAlias, aCampos, nTipo, lLegend )
	
	Local aRet      := {}
	Local aHeadGET  := {}
	Local nTamTot   := 0
	Local nInd      := 0
	Local lSX3OK    := .F.
	Local _Usado
	Local xx

	Default nTipo   := 1
	Default lLegend := .F.

	aHeadGET := NGHeader(cALIAS,aCAMPOS)

	If nTipo == 2 .And. lLegend

		aAdd( aRet, { 	''        ,; //01
						'LEGENDA' ,; //02
						'@BMP'    ,; //03
						2         ,; //04
						0         ,; //05
						''        ,; //06
						Chr( 251 ),; //07
						'C'       ,; //08
						''        ,; //09
						'V'       ,; //10
						''        ,; //11
						''        ,; //12
						'.F.'    } ) //13

	EndIf
	
	nTamTot := Len(aHeadGET)
	For nInd := 1 To nTamTot
		
		IF X3USO(aHeadGET[nInd,7]) .And. cNivel >= Posicione("SX3",2,aHeadGET[nInd,2],"X3_NIVEL") .And. !("_FILIAL"$Upper(aHeadGET[nInd,2]))

			lSX3OK  := .F.
			cCAMSX3 := Alltrim(aHeadGET[nInd,2])
			For XX := 1 To Len(aCAMPOS)
				If aCAMPOS[XX] == cCAMSX3
					lSX3OK := .T.
					Exit
				Endif
			Next

			If !lSX3OK

				_usado  := Space(Len(aHeadGET[nInd,7]))
				cTitSX3 := Trim(aHeadGET[nInd,1])

				If nTipo == 1 //MsGetDados

					aAdd(aRET,{cTitSX3                              ,; //01
					aHeadGET[nInd,2]                                ,; //02
					aHeadGET[nInd,3]                                ,; //03
					TamSX3(aHeadGET[nInd,2])[1]                     ,; //04
					TamSX3(aHeadGET[nInd,2])[2]                     ,; //05
					aHeadGET[nInd,6]                                ,; //06
					_usado    										,; //07
					aHeadGET[nInd,8]                                ,; //08
					Posicione("SX3",2,aHeadGET[nInd,2],"X3_ARQUIVO"),; //09
					aHeadGET[nInd,10]                               ,; //10
					Posicione("SX3",2,aHeadGET[nInd,2],"X3_F3")     ,; //11
					Posicione("SX3",2,aHeadGET[nInd,2],"X3_WHEN")})    //12

				Else //MsNewGetDados

					aAdd(aRET,{cTitSX3         						,; //01
					aHeadGET[nInd,2]                                ,; //02
					aHeadGET[nInd,3]                                ,; //03
					TamSX3(aHeadGET[nInd,2])[1]                     ,; //04
					TamSX3(aHeadGET[nInd,2])[2]                     ,; //05
					aHeadGET[nInd,6]                                ,; //06
					_usado         									,; //07
					aHeadGET[nInd,8]                                ,; //08
					aHeadGET[nInd,9]                                ,; //09
					aHeadGET[nInd,10]                               ,; //10
					Posicione("SX3",2,aHeadGET[nInd,2],"X3CBox()")   ,; //11
					Posicione("SX3",2,aHeadGET[nInd,2],"X3_RELACAO"),; //12
					Posicione("SX3",2,aHeadGET[nInd,2],"X3_WHEN") })   //13

				EndIf

			EndIf

		EndIf

	Next nInd

Return aRET

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ BLANKGETD³ Autor ³ NG INFORMATICA        ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta o aCOLS com itens em branco (Para inclusao)          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Array com o Cabecalho da GETDADOS (aHEADER)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION BLANKGETD(aVETOR)
	Local i,aRET := {}

	AADD(aRET,{})
	For i := 1 to Len(aVETOR)
		IF aVETOR[i][8] == "C"
			AADD(aRET[1], SPACE(aVETOR[i][4]))
		ELSEIF aVETOR[i][8] == "N"
			AADD(aRET[1], 0)
		ELSEIF aVETOR[i][8] == "D"
			//  AADD(aRET[1], DdDATABASE)
			AADD(aRET[1], CTOD('  /  /  '))
		ELSEIF aVETOR[i][8] == "M"
			AADD(aRET[1], " ")
		ELSE
			AADD(aRET[1],.F.)
		Endif
	Next
	AADD(aRET[1],.F.)
Return aRET

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MAKEGETD ³ Autor ³ NG INFORMATICA        ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta o aCOLS com itens da base de dados                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Arg1- Alias do arquivo                                     ³±±
±±³          ³ Arg2- Chave de Pesquisa (Sem a filial)                     ³±±
±±³          ³ Arg3- Array com o Cabecalho da GETDADOS (aHEADER)          ³±±
±±³          ³ Arg4- Expressao contendo o parametro "WHILE" fim de arquivo³±±
±±³          ³ Arg5- Expressao contendo o parametro "If"                  ³±±
±±³          ³ Arg6- Indica se utiliza WalkThru, .T. = Sim, .F. = Nao     ³±±
±±³          ³       nao obrigatorio                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION MAKEGETD(cALI,cKey,aVETOR,cWhile,cFilif,lWalkThru)
	Local i,aRET := {},cOLD := ALIAS(),xx,nv:=1
	Local lWalkT := NGWALKTHRU(lWalkThru)
	Local nConWalt := If(lWalkT,2,0)

	DbselectArea(cALI)
	Dbseek(xFILIAL(cALI)+cKEY)
	While !Eof() .And. &cWHILE.
		If cFilif = NIL
			Aadd(aRET,{})
			For i := 1 TO Len(aVETOR)-nConWalt
				If Posicione("SX3",2,aVETOR[i][2],"X3_CONTEXT") == "V"
					Aadd(aRET[nv],CriaVar(AllTrim(aVETOR[i][2])))
				Else
					xx := aVETOR[i][2]
					Aadd(aRET[nv], &xx.)
				Endif
			Next
			If lWalkT
				Aadd(aRET[nv],cAli)
				Aadd(aRET[nv],(cALI)->(Recno()))
				Aadd(aRET[nv],.F.)
			Else
				Aadd(aRET[nv],.F.)
			EndIf
			nv++
		Else
			If &cFilif.
				Aadd(aRET, {})
				For i := 1 TO Len(aVETOR)-nConWalt
					If Posicione("SX3",2,aVETOR[i][2],"X3_CONTEXT") == "V"
						Aadd(aRET[nv],CriaVar(AllTrim(aVETOR[i][2])))
					Else
						xx := aVETOR[i][2]
						Aadd(aRET[nv], &xx.)
					Endif
				Next
				If lWalkT
					Aadd(aRET[nv],cAli)
					Aadd(aRET[nv],(cALI)->(Recno()))
					Aadd(aRET[nv],.F.)
				Else
					Aadd(aRET[nv],.F.)
				EndIf
				nv++
			Endif
		Endif
		DbselectArea(cALI)
		Dbskip()
	End
	DbselectArea(cOLD)
Return aRET
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NGPOPUP  ³ Autor ³ NG INFORMATICA LTDA.  ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta um Menu POPUP para selecao                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aSMenu - Array contendo 3 dimensoes (Titulo,Funcao,Imagem) ³±±
±±³          ³ oMenu  - Objeto PopUp                                      ³±±
±±³          ³ oParent- Indica a janela onde o objeto será criado.        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION NGPOPUP(aSMenu,oMenu,oParent)
	Local nX,cImg
	Local oItem

	oMenu := TMenu():New(0,0,0,0,.T.,,oParent)
	If Len(aSMenu) > 0
		For nX := 1 to Len(aSMenu)
			//Verifica posicao 3 - Imagem da opcao do clique (TQD_IMAGEM)
			cImg := If(Len(aSMenu[nX]) >= 3,aSMenu[nX][3],Nil)

			oItem := TMenuItem():New(oMenu:Owner(),aSMenu[nX][1],,,,&("{|| "+aSMenu[nX][2]+"}"),,cImg,,,,,,,.T.)
			oMenu:Add(oItem)
		Next nX
	EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³         INICIO DAS ROTINAS PADROES DE CADASTRAMENTO                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCAD01   ³ Autor ³ Paulo Pego            ³ Data ³ 05/08/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de Manutencao de Cadastro Modelo 1(Exeto Exclusao)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCAD01(cAlias,nReg,nOpcX)

	Local bCampo
	Local lCLICK, lGRAVA, lFIELD
	Local nRegSM0   := 0
	Local nTamTot   := 0
    Local nInd      := 0
	Local aNgCadBtn := {}
	Local aHead01   := {}
	Local nC,  i, x, ny, nX2
	Local cCampo
	Local nIndex := (cAlias)->(IndexOrd())

	If nOpcX = 2 .And. (cAlias = "ST9" .Or. cAlias = "STF")
		NOPCA := 0
		If cAlias = "ST9"
			NG080FOLD(cAlias,Recno(),nOpcX)
			(cAlias)->(dbSetorder(nIndex))
			Return NOPCA
		Else
			NG120FOLD(cAlias,Recno(),nOpcX)
			(cAlias)->(dbSetorder(nIndex))
			Return NOPCA
		EndIf
	EndIf

	Private cFilCad := xFilial(cAlias)
	Private oDlg, oGet, oMenu
	Private aAC := {STR0001,STR0002},aCRA:= {STR0002,STR0003,STR0001} //"Abandona"###"Confirma"###"Confirma"###"Redigita"###"Abandona"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta a entrada de dados do arquivo                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Private aTELA[0][0],aGETS[0],aHeader[0],Continua,nUsado:=0
	Private aSize := MsAdvSize(,.F.,430), aObjects := {}
	Aadd(aObjects,{050,050,.T.,.T.})
	Aadd(aObjects,{100,100,.T.,.T.})
	aInfo   := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
	aPosObj := MsObjSize(aInfo, aObjects,.T.)
	bCampo  := {|nCPO| Field(nCPO) }

	lCLICK   := (TYPE("aSMENU")   == "A") .And. Len(aSMENU) > 0
	lRELAC   := (TYPE("aRELAC")   == "A")
	lRELMEMO := (TYPE("bRELMEMO") == "B")
	lINCMEMO := (TYPE("bINCMEMO") == "B")
	lALTMEMO := (TYPE("bALTMEMO") == "B")
	lDELMEMO := (TYPE("bDELMEMO") == "B")
	lGRAVA   := (TYPE("bNGGRAVA") == "B")
	lDELRE   := (TYPE("bNGDELRE") == "B")
	lCHKSQL  := (TYPE("aChkSql")  == "A")
	lAFTCAD  := (TYPE("bNGAFTCAD") == "B")

	If TYPE("cNgFilCad") == "C"
		DbSelectArea("SM0")
		nRegSM0 := Recno()
		If DbSeek(cEmPant+cNgFilCad)
			If ngsx2modo(cAlias) = 'E'
				If !Empty(cNgFilCad)
					cFilCad := cNgFilCad
				Endif
			Endif
		Endif
		DbSelectArea("SM0")
		Dbgoto(nRegSM0)
	EndIf

	If TYPE("aNgButton") == "A"
		aNgCadBtn := aClone(aNgButton)
	EndIf

	If TYPE("aCHKDEL") != "A"
		aCHKDEL := {}
	Endif
	lFIELD := (TYPE("aCHOICE") == "A")
	If lFIELD
		lAli := .T.
		dbSelectArea("SX3")
		dbSetOrder(2)
		For nC := 1 To Len(aChoice)
			If dbSeek(aChoice[nC])  //Verifica se o alias esta correto com os campos
				If Posicione("SX3",2,aChoice[nC],"X3_ARQUIVO") != cAlias
					lAli := .F.
					Exit
				EndIf
			EndIf
		Next
		If !lAli
			aChoice := {}
		EndIf
		lFIELD := !empty(aCHOICE)
	Endif
	If TYPE("aPOS1") != "A"
		aPOS1 := {15,1,95,315}
	Endif

	dbSelectArea(cALIAS)
	dbSetOrder(1)
	FOR i := 1 TO FCount()
		M->&(EVAL(bCampo,i)) := &(EVAL(bCampo,i))
		If nOPCX == 3    //INCLUIR
			IF     ValType(M->&(EVAL(bCampo,i))) == "C"
				M->&(EVAL(bCampo,i)) := SPACE(LEN(M->&(EVAL(bCampo,i))))
			ELSEIF ValType(M->&(EVAL(bCampo,i))) == "N"
				M->&(EVAL(bCampo,i)) := 0
			ELSEIF ValType(M->&(EVAL(bCampo,i))) == "D"
				M->&(EVAL(bCampo,i)) := cTod("  /  /  ")
			ELSEIF ValType(M->&(EVAL(bCampo,i))) == "L"
				M->&(EVAL(bCampo,i)) := .F.
			ENDIF
		Endif
	Next i

	If nOPCX == 3

		aHead01 := NGHeader(cALIAS)
		nTamTot := Len(aHead01)
		For nInd := 1 To nTamTot
			IF !Empty(Posicione("SX3",2,aHead01[nInd,2],"X3_RELACAO"))
				xx  := "m->" + Trim(aHead01[nInd,2])
				yy  := Trim(Posicione("SX3",2,aHead01[nInd,2],"X3_RELACAO"))
				&xx.:= &yy.
			Endif
		Next nInd

	Endif
	If lRELMEMO
		&cMEMO. := Eval(bRELMEMO)
	Endif
	If lRELAC
		For i := 1 to Len(aRELAC)
			cCampo := "M->" + aRELAC[i][1]
			cRelac := aRELAC[i][2]
			&cCampo. := &cRelac
		Next
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa variaveis para campos Memos Virtuais						 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("aMemos")=="A"
		For nX2 := 1 To Len(aMemos)
			cMemo := "M->" + aMemos[nX2,2]
			If ExistIni(aMemos[nX2,2])
				&cMemo := InitPad(Posicione("SX3",2,aMemos[nX2,2],"X3_RELACAO"))
			Else
				&cMemo := ""
			EndIf
		Next nX2
	EndIf

	//Ponto de Entrada para retirar campos da STJ ao mostrar na Tela Inicial
	If ExistBlock("NGUTILAB")
		aChoice := ExecBlock("NGUTILAB",.F.,.F.,aChoice)
	EndIf

	nOpca := 0
	DEFINE MSDIALOG oDlg TITLE Ccadastro From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL
	oPanel := TPanel():New(0, 0, Nil, oDlg, Nil, .T., .F., Nil, Nil, 0, 0, .T., .F. )
	oPanel:Align := CONTROL_ALIGN_ALLCLIENT
	oEnchoice := If(lFIELD,Msmget():New(cALIAS, nReg, nopcx,,,,aCHOICE,aPosObj[1],,3,,,,oPanel),;
	Msmget():New(cALIAS, nReg, nopcx,,,,,aPosObj[1],,3,,,,oPanel))
	If lCLICK
		If SuperGetMV("MV_ENCHOLD",.F.,"2") == "2"
			NGPOPUP(aSMenu,@oMenu,oEnchoice:oBox)
			oEnchoice:oBox:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oEnchoice:oBox)}
		Else
			NGPOPUP(aSMenu,@oMenu,oPanel)
			oPanel:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oPanel)}
		EndIf
	Endif
	If nOpcX = 5
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,If(!NGCHKDEL(cALIAS),nOpca := 0,oDlg:End())},{||oDlg:End()},;
		AlignObject(oDlg,{oEnchoice:oBox},1),aNgCadBtn)
	ElseIf lGRAVA .And. (nOpcX =  3  .Or. nOpcX = 4)
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,If(!obrigatorio(aGets,aTela),nOpca := 0,If(!Eval(bNGGRAVA),nOpca := 0,oDlg:End()))},{||oDlg:End()},;
		AlignObject(oDlg,{oEnchoice:oBox},1),aNgCadBtn)
	ElseIf nOpcX = 2
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,oDlg:End()},{||oDlg:End()},;
		AlignObject(oDlg,{oEnchoice:oBox},1),aNgCadBtn)
	Else
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,If(!obrigatorio(aGets,aTela),nOpca := 0,oDlg:End())},{||oDlg:End()},;
		AlignObject(oDlg,{oEnchoice:oBox},1),aNgCadBtn)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se Confirmou e a opcao incluir ou alterar                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nOPCA == 1 .and. (nOPCx == 3 .or. nOPCx == 4)
		DbSelectArea(cALIAS)
		RecLock(cAlias,Inclui)
		For ny := 1 To FCOUNT()
			nx := "m->" + FieldName(ny)
			If "_FILIAL"$Upper(nx) .And. nOPCx = 3
				&nx. := cFilCad
			Endif
			FieldPut(ny, &nx.)
		Next ny
		If nOPCX == 3 .and. lINCMEMO
			Eval(bINCMEMO)
		Endif
		If nOPCX == 4 .and. lALTMEMO
			Eval(bALTMEMO)
		Endif
		//Manipula campos MEMO
		If Type("aMemos") == "A"
			If nOPCX == 3  .Or. nOPCX == 4
				For nX2 := 1 to Len(aMemos)
					cVar := aMemos[nX2][2]
					cVar1:= aMemos[nX2][1]
					If (cAlias)->(FieldPos(cVar1)) > 0
						cAliasMemo := If(len(aMemos[nX2]) == 3,aMemos[nX2][3],Nil)
						If nOPCX == 3
							MSMM(,TamSx3(aMemos[nX2][2])[1],,&cVar,1,,,cAlias,aMemos[nX2][1],cAliasMemo)
						Else
							MSMM(&cVar1,TamSx3(aMemos[nX2][2])[1],,&cVar,1,,,cAlias,aMemos[nX2][1],cAliasMemo)
						EndIf
					Endif
				Next nX2
			Endif
		Endif

		(cALIAS)->(MSUNLOCK())
		EvalTrigger()       // Processa Gatilhos
		If nOPCX == 3
			ConfirmSX8()
		Endif
	Endif

	If nOPCA <> 1 .and. nOPCx == 3
		RollBackSX8()
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se Confirmou e a opcao excluir                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nOPCA == 1 .and. nOPCx == 5
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica a Integridade Referencial                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		//Manipula campos MEMO
		If Type("aMemos") == "A"
			If nOPCX == 5
				For nX2 := 1 To Len(aMemos)
					cAliasMemo := If(len(aMemos[nX2]) == 3,aMemos[nX2][3],Nil)
					If NGCADICBASE(aMemos[nX2][1],"A",cAlias,.F.)
						MSMM(&(aMemos[nX2][1]),,,,2,,,,,cAliasMemo)
					EndIf
				Next nX2
			Endif
		Endif

		DbSelectArea(cALIAS)
		RecLock(cAlias,.F.)
		DbDelete()
		(cALIAS)->(MSUNLOCK())
		EvalTrigger()       // Processa Gatilhos
		If lDELMEMO
			Eval(bDELMEMO)
		Endif
		// DELETA OS RELACIONAMENTO SEQUNDµRIOS
		If lDELRE
			Eval(bNGDELRE)
		Endif
	Endif

	//Caso o usuário confirme a tela e exista função a ser executada ao final da transação
	//Obs: Tratamento de tipo de ação (I, A ou E) deverá ser feita no fonte da função a ser chamada
	If nOPCA == 1 .And. lAFTCAD
		Eval( bNGAFTCAD )
	EndIf

	// -------------------------------------------- ATENCAO --------------------------------------------
	// Este ponto de entrada deve ser o ultimo evento executado antes do Return da funcao.
	// Qualquer consistencia deve ser aplicada acima deste.
	// -------------------------------------------------------------------------------------------------
	If ExistBlock("NGCAD01F")
		ExecBlock( "NGCAD01F", .F., .F., {cAlias, nReg, nOpcX, nOPCA, FunName()} )
	Endif

	lRefresh := .T.

	//Retorna o Indice do Brose
	(cAlias)->(dbSetorder(nIndex))

Return nOPCa

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCAD02   ³ Autor ³ Paulo Pego            ³ Data ³ 05/08/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de Manutencao de Cadastro Modelo 3                ³±±
±±³          ³ (Exeto Exclusao)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAlias - Nome do arquivo para alteracao, inclusao, etc     ³±±
±±³          ³ nReg   - Recno do Registro                                 ³±±
±±³          ³ nOpcX  - Opcao (Inclusaso,alteracao,exclusao, etc)         ³±±
±±³          ³ lWalkThru - Indica se o cadastra utiliza WalkTrue          ³±±
±±³          ³ Se falso nao utiliza WalkTrue, se nulo usa Waltrue - n Obri³±±
±±³          ³ nLinGetD - Numero limite de linhas no GetDados - n Obrigat.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ OBS      ³ Deve ser definido no programa chamador um array com o nome ³±±
±±³          ³ aGETNAO contendo os campos que nao devem ser chamados na   ³±±
±±³          ³ getdados.                                                  ³±±
±±³          ³ Deve ser definida (Obrigatorio) uma variavel com o nome    ³±±
±±³          ³ cGETMAKE contendo a chave de pesquisa de chamada para      ³±±
±±³          ³ a getdados (sem filial)                                    ³±±
±±³          ³ Deve ser definida (Obrigatorio) uma variavel com o nome    ³±±
±±³          ³ cGETKEY contendo a chave de pesquisa para a getdados       ³±±
±±³          ³ (Sem Filial)                                               ³±±
±±³          ³ Deve ser definida (Obrigatorio) uma variavel com o nome    ³±±
±±³          ³ cGETWHILE contendo o expressao While da chave de pesquisa  ³±±
±±³          ³ Deve ser definida (Obrigatorio) uma variavel com o nome    ³±±
±±³          ³ cGETALIAS com o nome do alias da getdados                  ³±±
±±³          ³ Definir as variaveis cTUDOOK e cLINOK com os nomes das     ³±±
±±³          ³ funcoes de chamada de consitencia da GETDADOS              ³±±
±±³          ³ Definir o array aSMENU para chamda das funcoes com o click ³±±
±±³          ³ da direita                                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCAD02(cAlias, nReg, nOpcX, lWalkThru, nLinGet)

	Local i           := 0
	Local nX2         := 0
	Local ah          := 0
	Local ny          := 0
	Local sc          := 0
	Local nc          := 0
	Local nTotal      := 0
	Local aNAO        := {}
	Local aNgCadBtn   := {}
	Local aNoFields   := {}
	Local aHead02     := {}
	Local cKey        := ""
	Local cCampo      := ""
	Local cValor      := ""
	Local cFilCaP     := xFilial(cAlias)
	Local cFilCaF     := xFilial(cGetAlias)
	Local lCLICK      := .F.
	Local lDelOk      := .F.
	Local lChgLiNG    := .F. //Indica se deverá executar bloco de codigos ao mudar de linha na GetDados
	Local nIndex      := (cAlias)->(IndexOrd())
	Local nSaveSX8SQT := GETSX8LEN()
	Local nTamTot     := 0
	Local nInd        := 0

	Default nLinGet := 3000

	Private oDlg, oGet,nLinNG, oMenu
	Private aTELA[0][0],aGETS[0],aHeader[0],aCOLS[0],Continua,nUsado:=0
	Private lWalkT  := NGWALKTHRU(lWalkThru)
	Private aAC     := {STR0001,STR0002}, aCRA:= {STR0002,STR0003,STR0001} //"Abandona"###"Confirma"###"Confirma"###"Redigita"###"Abandona"
	Private aSize   := MsAdvSize(,.F.,430), aObjects := {}

	Aadd(aObjects,{050,050,.T.,.T.})
	Aadd(aObjects,{100,100,.T.,.T.})
	aInfo   := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
	aPosObj := MsObjSize(aInfo, aObjects,.T.)

	If TYPE("cNgFilCaP") == "C"

		DbSelectArea("SM0")
		nRegSM0 := Recno()
		If DbSeek(cEmPant+cNgFilCaP)
			If ngsx2modo(cAlias) = 'E'
				If !Empty(cNgFilCaP)
					cFilCaP := cNgFilCaP
				Endif
			Endif
		Endif
		DbSelectArea("SM0")
		Dbgoto(nRegSM0)

	EndIf

	If TYPE("cNgFilCaF") == "C"

		DbSelectArea("SM0")
		nRegSM0 := Recno()
		If DbSeek(cEmPant+cNgFilCaF)
			If ngsx2modo(cGetAlias) = 'E'
				If !Empty(cNgFilCaF)
					cFilCaF := cNgFilCaF
				Endif
			Endif
		Endif
		DbSelectArea("SM0")
		Dbgoto(nRegSM0)

	EndIf

	lCLICK	   := (TYPE("aSMENU")   == "A") .And. Len(aSMENU) > 0
	lFIELD	   := (TYPE("aCHOICE")  == "A")
	lGRAVA	   := (TYPE("bNGGRAVA")  == "B")
	lNGWHEN	   := (TYPE("bNGWHEN")   == "B")
	lDELRE	   := (TYPE("bNGDELRE")  == "B")
	lRELAC	   := (TYPE("aRELAC")    == "A")
	lNG2GET	   := (TYPE("aNGPOSGET") == "A")
	lCHKSQL	   := (TYPE("aChkSql")   == "A")
	lChgLiNG   := (TYPE("bChgLiNG")  == "B") //Bloco de codigos executado ao mudar de linha na GetDados
	lDelOk	   := (TYPE("cDelOk")    == "C")
	cFuCad02A  := If(TYPE("NGCAD02FA") <>  "U",NGCAD02FA,"AllwaysTrue() ")  // Bloco de codigos na alteracao do item da getdados.
	cFuCad02D  := If(TYPE("NGCAD02FD") <>  "U",NGCAD02FD,"AllwaysTrue() ")  // Bloco de codigos na exclusao do item da getdados.
	lTesGGet   := (TYPE("cCondGGet")   == "C")

	If TYPE("aNGBUTTON") == "A"
		aNgCadBtn := aClone(aNGBUTTON)
	EndIf

	If TYPE("aCHKDEL") != "A"
		aCHKDEL := {}
	Endif

	If lFIELD
		lFIELD := !Empty(aCHOICE)
	Endif

	If !lNG2GET
		aNGPOSGET := {80,1,140,315}
	Endif

	dbSelectArea(cALIAS)
	dbSetOrder(1)

	nTotal  := FCOUNT()
	For i := 1 To nTotal

		cCampo := Field(i)
		cValor := &cCampo.
		cCampo := "M->" + cCampo

		If nOPCX == 3 //Incluir
			If ValType(cValor) == "C"
				&cCampo := SPACE(LEN(cValor))
			ElseIf ValType(cValor) == "N"
				&cCampo := 0
			ElseIf ValType(cValor) == "D"
				&cCampo := cTod("  /  /  ")
			ElseIf ValType(cValor) == "L"
				&cCampo := .F.
			ElseIf ValType(cValor) == "M"
				&cCampo := SPACE(50)
			Endif
		Else
			&cCampo := cValor
		Endif

	Next i

	If nOPCX == 3

		aHead02 := NGHeader(cALIAS)
		nTamTot := Len(aHead02)
		For nInd := 1 To nTamTot
			IF !Empty(Posicione("SX3",2,aHead02[nInd,2],"X3_RELACAO"))
				xx  := "m->" + Trim(aHead02[nInd,2])
				yy  := Trim(Posicione("SX3",2,aHead02[nInd,2],"X3_RELACAO"))
				&xx.:= &yy.
			Endif
		Next nInd

	Endif

	If lRELAC
		For i := 1 to Len(aRELAC)
			cCampo := "M->" + aRELAC[i][1]
			cRelac := aRELAC[i][2]
			&cCampo. := &cRelac
		Next
	Endif

	//Inicializa variaveis para campos Memos Virtuais
	If Type("aMemos")=="A"
		For nX2 := 1 To Len(aMemos)
			cMemo := "M->" + aMemos[nX2][2]
			If ExistIni(aMemos[nX2][2])
				&cMemo := InitPad(Posicione("SX3",2,aMemos[nX2][2],"X3_RELACAO"))
			Else
				&cMemo := ""
			EndIf
		Next nX2
	EndIf

	//Monta o aHEADER e o aCOLS da Getdados
	aNAO := {}
	For i := 1 to Len(aGETNAO)
		AAdd(aNAO, aGETNAO[i][1])
	Next

	If !lWalkT
		aHeader := CABECGETD(cGETALIAS, aNAO)
		If nOPCX == 3
			aCOLS :=BLANKGETD(aHeader)
		Else
			cKey  := &cGETMAKE.
			aCOLS :=MAKEGETD(cGETALIAS, cKEY,aHeader, cGETWHILE,,lWalkT)
			If Empty(aCOLS)
				aCOLS :=BLANKGETD(aHeader)
			Endif
		Endif
	Else
		aNoFields := aClone(aNAO)
		cKey  := &cGETMAKE.
		FillGetDados( nOpcx, cGETALIAS, 1, cKEY, {|| }, {|| .T.},aNoFields,,,,{|| NGMontaAcols(cGETALIAS,cKey,cGETWHILE)})

		If Empty(aCols) .Or. nOpcx == 3
			aCOLS :=BLANKGETD(aHeader)
		Endif
	EndIf

	If lNGWHEN
		Eval(bNGWHEN)
	Endif

	aPos1 := {15,1,78,315}
	nOpca := 0
	DEFINE MSDIALOG oDlg TITLE Ccadastro From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL STYLE nOR(WS_VISIBLE,WS_POPUP)

		oPanel       := TPanel():New(0, 0, Nil, oDlg, Nil, .T., .F., Nil, Nil, 0, 0, .T., .F. )
		oPanel:Align := CONTROL_ALIGN_ALLCLIENT
		oEnchoice    := If(lFIELD,Msmget():New(cALIAS, nReg, nopcx,,,,aCHOICE,aPosObj[1],,3,,,,oPanel),;
		                Msmget():New(cALIAS, nReg, nopcx,,,,,aPosObj[1],,3,,,,oPanel))

		oEnchoice:oBox:Align := CONTROL_ALIGN_TOP

		oGet := MSGetDados():New(aPosObj[2,2],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpcx,cLINOK,cTUDOOK,"",If( nOpcx == 2 , .F. , .T. ),,,,nLinGet,,,,If(lDelOk,cDelOk,Nil),oPanel)
		oGet:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

		If lCLICK
			NGPOPUP(aSMenu,@oMenu,oPanel)
			oPanel:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oPanel)}
		Endif

		If lChgLiNG
			oGet:oBrowse:bChange:= {|| NGCAD02SPB() .And. bChgLiNG}
		Else
			oGet:oBrowse:bChange:= {|| NGCAD02SPB()} // NOVA LINHA SEM INFORMAÇÕES
		EndIf

	If nOpcX = 5
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1, If(!NGCHKDEL(cALIAS),nOPCA := 0,oDlg:End())},{||oDlg:End()},;
		AlignObject(oDlg,{oEnchoice:oBox,oGet:oBrowse},1),aNgCadBtn)
	ElseIf lGRAVA  .And. (nOpcX =  3  .Or. nOpcX = 4)
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1, If(oGET:TUdoOK(),If(!obrigatorio(aGets,aTela),nOpca := 0,If(!Eval(bNGGRAVA),nOpca := 0,oDlg:End())), nOpca := 0)},{||oDlg:End()},;
		AlignObject(oDlg,{oEnchoice:oBox,oGet:oBrowse},1),aNgCadBtn)
	ElseIf nOpcX = 2
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1, If(oGET:TUdoOK(),oDlg:End(), nOPCA := 0)},{||oDlg:End()},;
		AlignObject(oDlg,{oEnchoice:oBox,oGet:oBrowse},1),aNgCadBtn)
	Else
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1, If(oGET:TUdoOK(),If(!obrigatorio(aGets,aTela),nOpca := 0,oDlg:End()), nOPCA := 0)},{||oDlg:End()},;
		AlignObject(oDlg,{oEnchoice:oBox,oGet:oBrowse},1),aNgCadBtn)
	EndIf

	If nOPCA == 1 .and. (nOPCx == 3 .or. nOPCx == 4)

		//Atualiza o arquivo principal (cALIAS)
		DbSelectArea(cALIAS)
		For ah := 1 to Len(aVARNAO)
			xx   := aVARNAO[ah][1]
			yy   := aVARNAO[ah][2]
			If !empty(yy)
				&xx. := &yy.
			Endif
		Next

		If nOPCx == 3
			RecLock(cAlias,.T.)
		Else
			RecLock(cAlias,.F.)
		Endif

		nTotal  := FCOUNT()
		For ny := 1 To nTotal

			nx := "M->" + FieldName(ny)
			If "_FILIAL" $ Upper(nx)
				FieldPut(ny, cFilCaP)
			Else
				CC := &NX.
				If ValType(CC) != "M"
					FieldPut(ny, &nx.)
				EndIf
			Endif

		Next ny

		//Manipula campos MEMO
		If Type("aMemos") == "A"
			If nOPCX == 3
				For nX2 := 1 to Len(aMemos)
					cVar := aMemos[nX2][2]
					cAliasMemo := If(len(aMemos[nX2]) == 3,aMemos[nX2][3],Nil)
					MSMM(,TamSx3(aMemos[nX2][2])[1],,&cVar,1,,,cAlias,aMemos[nX2][1],cAliasMemo)
				Next nX2
			ElseIf nOPCX == 4
				For nX2 := 1 to Len(aMemos)
					cVar := aMemos[nX2][2]
					cVar1:= aMemos[nX2][1]
					cAliasMemo := If(len(aMemos[nX2]) == 3,aMemos[nX2][3],Nil)
					MSMM(&cVar1,TamSx3(aMemos[nX2][2])[1],,&cVar,1,,,cAlias,aMemos[nX2][1],cAliasMemo)
				Next nX2
			Endif
		Endif
		(cALIAS)->(MSUNLOCK())

		//Atualiza o arquivo da getdados (cGETALIAS)
		dbSelectArea(cGETALIAS)
		cScan := " "
		For sc := 1 To FCOUNT()
			xx := Trim( Upper( FieldName(sc) ) )
			xx := aScan(aHeader,{|x| Trim(Upper(x[2])) == xx})
			If xx > 0
				If !empty(cScan); cScan += ".And."; End
				cSCAN += aHeader[xx][2] + " == aCOLS[nLinNG][" + STRZERO(xx,2) + "]"
			Endif
		Next

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se houve alteracao na linha da     ³
		//³ get dados e exclui o registro               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		/*
		Bloco de código abaixo somente alterar se tiver a certeza que está com problema.
		Se alterar testar em todas as rotinas que usam NGCAD02

		Início do bloco
		*/
		lLinhaD := .F.
		For ah := 1 To Len(aCOLS)
			If Atail(aCols[ah])
				lLinhaD := .T.
				Exit
			EndIf
		Next ah

		If lLinhaD
			// Salva e ordena a aCOLS pelos itens deletados
			nUltCol := Len(aCOLS[1])
			aCOLSO  := Aclone(aCOLS)
			aCOLSO  := Asort(aCOLS,,,{|x,y| x[nUltCol ] < y[nUltCol ]})
			nTamAM  := Len(aCOLSO)+1
			aCOLS   := {}

			For ah := 1 To Len(aCOLSO)
				Aadd(aCOLS,aCOLSO[nTamAM-ah])
			Next ah
		EndIf
		// Fim do bloco de código

		DbSeek(cFilCaF+&cGETMAKE.)
		Do While !eof() .and. &cGETWHILE.
			lDel := .T.
			For nc := 1 to Len(aCOLS)
				nLinNG := nc
				If &cScan.
					lDel := .F.
				Endif
			Next
			If lDel
				RecLock(cGetAlias,.F.)
				DbDelete()
				(cGetAlias)->(MSUNLOCK())
			Endif
			DbSkip()
		EndDo

		For nc := 1 to Len(aCOLS)

			//criando as variaveis da getdados
			//Somente alterar no bloco abaixo se tiver certeza que está incorreta
			//Inicio do bloco
			lGravaGet := .F.
			If lTesGGet
				cGetCha := Strtran(cGETKEY,"+",",")
				cGetCha := Strtran(cGetCha,"M->","")
				vGetCha := StrTokArr(cGetCha,',')
				cChaGet := ""
				vCampoS := {}
				For ah := 1 To Len(vGetCha)
					cChaVGet := Alltrim(vGetCha[ah])
					nPosH := Ascan(aHeader,{|x| Alltrim(Trim(Upper(x[2]))) == cChaVGet})
					If nPosH > 0
						cChaGet := ' "aCOLS['+Alltrim(Str(nc,3))+','+Alltrim(Str(nPosH,3))+']" '
						cGetGeN := SubS(cChaGet,3,Len(cChaGet)-4)
						cCondGGet := Strtran(cCondGGet,cChaVGet,cGetGeN)
					EndIf
				Next ah

				If &(&(cCondGGet))
					lGravaGet := .T.
				EndIf

			Else
				If !empty(aCOLS[nc][1])
					lGravaGet := .T.
				EndIf
			EndIf

			If lGravaGet

				// Fim do bloco
				For ah := 1 to Len(aHeader)
					xx   := "m->" + aheader[ah][2]
					&xx. := aCOLS[nc][ah]
				Next
				For ah := 1 to Len(aGETNAO)
					xx   := "m->" + aGETNAO[ah][1]
					yy   := aGETNAO[ah][2]
					If !empty(yy)
						&xx. := &yy.
					Endif
				Next

				//Excluindo registros se a linha da get dados marcada para exclusao
				If aCOLS[nc][ Len(aCOLS[nc]) ]
					If DbSeek(cFilCaF + &cGETKEY.)
						RecLock(cGetAlias,.F.)
						DbDelete()
						(cGetAlias)->(MSUNLOCK())
					Endif
					Loop
				Endif

				//Atualiza o registro conforme a getdados
				If !DbSeek(cFilCaF + &cGETKEY.)
					RecLock(cGetAlias,.T.)
				Else
					RecLock(cGetAlias,.F.)
				Endif

				For ny := 1 To FCOUNT()
					nx := "m->" + FieldName(ny)
					If "_FILIAL"$ Upper(nx)
						FieldPut(ny, cFilCaF)
					Else
						If ValType(&nx.) $ "CNDMT"
							FieldPut(ny, &nx.)
						Endif
					Endif
				Next ny
				(cGetAlias)->(MSUNLOCK())

			Endif
		Next nc
		EvalTrigger() //Processa Gatilhos

		If nOPCA == 1 .and. nOPCx == 3
			ConfirmSX8()
		Endif
	Endif

	If nOPCA != 1 .and. (nOPCx == 3 .or. nOPCx == 4)
		If nSaveSX8SQT < GETSX8LEN() //Verificar se o conteudo SX8 não é chamado de outra Rotina
			RollBackSX8()
		EndIf
	Endif

	//Se Confirmou e a opcao excluir
	If nOPCA == 1 .and. nOPCx == 5

		//Verifica a Integridade Referencial
		If Type("aMemos") == "A" //Manipula campos MEMO
			If nOPCX == 5
				For nX2 := 1 To Len(aMemos)
					cAliasMemo := If(len(aMemos[nX2]) == 3,aMemos[nX2][3],Nil)
					MSMM(&(aMemos[nX2][1]),,,,2,,,,,cAliasMemo)
				Next nX2
			Endif
		Endif

		DbSelectArea(cGETALIAS)
		DbSeek(cFilCaF + &cGETMAKE.)
		Do While !eof() .and. &cGETWHILE.
			RecLock(cGETALIAS,.F.)
			DbDelete()
			(cGetAlias)->(MSUNLOCK())
			DbSkip()
		EndDo

		DbSelectArea(cALIAS)
		RecLock(cAlias,.F.)
		DbDelete()
		(cALIAS)->(MsUnlock())
		EvalTrigger()       // Processa Gatilhos

		// DELETA OS RELACIONAMENTOS SECUNDARIOS
		If lDELRE
			Eval(bNGDELRE)
		Endif

	Endif

	// -------------------------------------------- ATENCAO --------------------------------------------
	// Este ponto de entrada deve ser o ultimo evento executado antes do Return da funcao.
	// Qualquer consistencia deve ser aplicada acima deste.
	// -------------------------------------------------------------------------------------------------
	If ExistBlock("NGCAD02F")
		ExecBlock( "NGCAD02F", .F., .F., {cAlias, nReg, nOpcX, nOPCA, FunName()} )
	Endif

	(cAlias)->(dbSetorder(nIndex))

Return nOPCA

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³            FIM DAS ROTINAS PADROES DE CADASTRAMENTO                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ATECODIGO ³ Autor ³ Inacio luiz Kolling   ³ Data ³ 12/08/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consistencia do codigo  ( ate  do SX1....)                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ VALIAS  -> Alias do arquivo de pesquisa                    ³±±
±±³          ³ VPAR01  -> Codigo de pesquisa  ( De .... )                 ³±±
±±³          ³ VPAR02  -> Codigo de pesquisa  ( Ate ... )                 ³±±
±±³          ³ VTAM    -> Tamanho do campo do codigo de pesquisa (N. OBRIG³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ATECODIGO(VALIAS,VPAR01,VPAR02,VTAM)
	If !Empty(vpar01) .and. Empty(vpar02)
		Help(" ",1,"ATEINVALID")
		Return .F.
	ElseIf vpar02 < vpar01
		Help(" ",1,"DEATEINVAL")
		Return .F.
	Endif

	If vpar02 = replicate('Z',Len(vPAR02))
		Return .T.
	Else
		If VALIAS == "SRA"
			If !ExCpoMDT(VALIAS,VPAR02)
				Return .F.
			EndIf
		Else
			If !Empty(vpar02) .And. !ExistCpo(VALIAS,VPAR02)
				Return .F.
			EndIf
		EndIf
	EndIf
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCONSULTA
Funcao criar um arquivo de trabalho para simular um filtro
no arquivo

@author Paulo Pego
@since xx/xx/xxxx

@param cTRB, caracter, Alias do trb a criar (TRB1,TRB2...)
@param cKey, caracter, Chave de Pesquisa (Default Inico do arquivo)
@param bWhile, Codblock com a clausa WHILE (Defaut !EOF())
@param bFOR, Codblock com a clausula FOR
@param aBOTTOM, Array, Rotinas a serem executadas no browse (aROTINA)
@param aFIELD, Array, Array com as definicoes dos campos do browse
@param bDBFFUNC, CODBLOCK executado antes do browse
@param bTMPFUNC, CODBLOCK sra executado antes de eliminar ARQ.TEMP
@param lSoftSeek, boolean, Define se o "SoftSeek" estará habilitado ou não
no momento em que o programa pesquisar na tabela.
@param bGRAVAFIL, CODBLOCK executado na gravacao do arquivo temp.
@param lAltVis, boolean, Indica se quer alterar rotina de visualizacao
.T. - Altera / .F. - Não altera (Default .T.)
@param lAtivFil, boolean, Indica se deverá habilitar o filtro do browse.

@return _cTrb, caracter, alias da tabela temporária

/*/
//---------------------------------------------------------------------
Function NGCONSULTA(cTRB,cKEY,bWHILE,bFOR,aBOTTOM,aFIELD,bDBFFUNC,bTMPFUNC,lSoftSeek,bGRAVAFIL,aCOLORS,cFILTER, lAltVis, lAtivFil)

	Local _ix
	Local nX			:= 0
	Local nY 			:= 0
	Local nTamCon       := 0
	Local nLeg			:= 0
	Local nPosDel		:= 0
	Local nPosLoc		:= 0
	Local aChave        := {}
	Local nIdx			:= 1
	Local nCntStr		:= 1
	Local nIndex        := 0
	Local cAli			:= Alias()
	Local cTitulo		:= "" //Define os titulos dos campos
	Local cDescInd      := ""
	Local cOrdem        := ""
	Local lField		:= .F.
	Local lROTINA		:= .F.
	Local lCOLORS		:= .F.
	Local lFILTER		:= .F.
	Local lChaveOld		:= .T.
	Local aOLD			:= {}
	Local aExpDel		:= { "DTOS" , "DESCEND", "STR" }
	Local aArea			:= GetArea()
	Local oTmpTbl
	Local aStrTrb 		:= {} // Define a estrutura do TRB
	Local aFldBrw 		:= {} // Campos a serem exibidos no Browse
	Local aFldFil		:= {} // Campos utilizados para o filtro do browse
	Local aPesq			:= {} // Define as pesquisas do Browse
	Local aCampCon		:= {} // Receberá os campos, conforme o alias.
	Local aIndex        := {}

	Default lAltVis		:= .T.
	Default lSoftSeek	:= .F.
	Default lAtivFil	:= .T.

	Private cMESTRE		:= Alias()
	Private cFuncVis	:= ""
	Private cTRAB		:= ""
	Private _cTrb		:= cTRB

	If aField == NIL
		aFIELD := {}
	EndIf
	If Len(aFIELD) > 0
		lField := .T.
	EndIf
	If TYPE("aROTINA") == "A"
		aOLD    := aCLONE(aROTINA)
		lRotina := .T.
	EndIf

	aROTINA := aCLONE(aBOTTOM)
	dbSelectArea("SX3")
	dbSetOrder(01)
	If !DbSeek(cALI)
		If lROTINA
			aROTINA := aCLONE(aOLD)
		EndIf
		Return .F.
	EndIf

	lCOLORS := ( If(ValType(aCOLORS) == "A", Len(aCOLORS) > 0, .F.) )
	lFILTER := ( If(ValType(cFILTER) == "C", !Empty(cFILTER), .F.) )

	aDBF := {}
	If !lField
		aFIELD := {}
	EndIf

	aCampCon := NGHeader(cALI)
	nTamCon := Len(aCampCon)

	If nTamCon > 0
		For nY := 1 To nTamCon

			If aCampCon[nY, 10] != "V" .Or.;
				Posicione("SX3",2,aCampCon[nY, 2],"X3_BROWSE") == "S"


				AAdd(aDBF, {aCampCon[nY,2], aCampCon[nY,8],;
							aCampCon[nY,4], aCampCon[nY,5]})
			EndIf

		Next nY
	EndIf

	aAdd(aDBF, {"RECORIG", "N", 15, 0}) //Campo utilizado para armazenar o RecNo do mesmo registro da tabela original
	aAdd(aDBF, {"TBLORIG", "C", 03, 0}) //Campo utilizado para armazenar a Tabela Orignal do registro

	aIND := {}

	//Instancia classe FWTemporaryTable
	oTmpTbl := FWTemporaryTable():New( _cTrb, aDBF )

	aIndex := NGRETINDTAB( cALI )

	If FWSIXUtil():ExistIndex( cALI, "1" )
		
		aIndex := FWSIXUtil():GetAliasIndexes( cALI )

		For nIndex := 1 To Len( aIndex )

			cChave := ''
			aIND := aIndex[ nIndex ]

			//Se possuir o campo de filial na primeira posição deverá deletar
			If "_FILIAL" $ aIND[1]
				aDel( aIND , 1 )
				aSize( aIND , (Len(aIND)-1) )
			EndIf
			For _ix := 1 To Len( aIND )
				If ( nPosDel := aScan( aExpDel , { | x | AllTrim( Upper( x ) ) $ Upper( aIND[ _ix ] ) } ) ) > 0
					If ( nPosLoc := AT( "(" , aIND[ _ix ] ) ) > 0
						aIND[ _ix ] := SubStr( aIND[ _ix ] , nPosLoc + 1 )
					EndIf
					If ( nPosLoc := AT( "," , aIND[ _ix ] ) ) > 0
						aIND[ _ix ] := SubStr( aIND[ _ix ] , 1 , nPosLoc - 1 )
					EndIf
					If ( nPosLoc := AT( ")" , aIND[ _ix ] ) ) > 0
						aIND[ _ix ] := SubStr( aIND[ _ix ] , 1 , nPosLoc - 1 )
					EndIf
				EndIf
				aIND[ _ix ] := AllTrim(aIND[ _ix ])
				
				If _ix > 1
				
					cChave += '+'
				
				EndIF
				
				cChave += aIND[ _ix ]

			Next _ix

			aAdd( aChave, AllTrim( cChave ) )

			If nIdx > 1
				//Verificação impeditiva de chave duplicada
				For _ix := 1 To Len(aChave)
					If (aChave[nIdx] $ aChave[_ix]) .And. _ix < Len(aChave)
						lChaveOld := .F.
					EndIf

				Next _ix
			EndIf

			If lChaveOld

				oTmpTbl:AddIndex( "Index" + cValToChar( nIdx ) , aIND )

				cOrdem   := AllTrim( AllToChar( nIndex ) )
				cDescInd := Posicione( "SIX", 1, cALI + cOrdem, "DESCRICAO" )

				aAdd( aPesq , { AllTrim( cDescInd ), { { "" , "C" , 255 , 0 , "" , "@!" } } } )

			EndIf

			nIdx++
			lChaveOld := .T.

		Next nIndex

	EndIf

	oTmpTbl:Create()

	If lFILTER

		dbSelectArea( cALI )
		Set Filter To &( cFILTER )

	EndIf
	
	Processa( { |lEnd| NGCONPROC( cALI, _cTrb, cKEY, bWHILE, bFOR, lSoftSeek, bGRAVAFIL ) } )

	If lFILTER

		dbSelectArea( cALI )
		Set Filter To

	EndIf

	DbSelectArea(_cTrb)
	DbGotop()

	//+---------------------------------------------------------------------+
	//| Se Possuir executa CODBLOCK defindo em bDBFFUNC                     |
	//+---------------------------------------------------------------------+
	If !Empty(bDBFFUNC)
		Eval(bDBFFUNC,_cTrb)
	Endif

	//+---------------------------------------------------------------------+
	//| Altera a funcao de visualizacao                                     |
	//+---------------------------------------------------------------------+
	For nX := 1 To Len(aRotina)
		If ( Upper( SubStr(STR0203,1,4) ) $ Upper(aRotina[nX][1]) .Or.;
			Upper( (SubStr(STR0203,1,3) + ".") ) $ Upper(aRotina[nX][1]) ) .And.; //"Visualizar" -> "VISU"; "Visualizar" -> "VIS."
			!("NGVISUAL" $ Upper(aRotina[nX][2])) .And. lAltVis

			cFuncVis := aRotina[nX][2]
			aRotina[nX][2] := "NGVISUAL(_cTrb, Recno(), IndexOrd())"
		EndIf
	Next

	dbSelectArea( _cTrb )
	dbSetOrder( 1 )
	dbGoTop()

	oBrowse:= FWMBrowse():New()
	oBrowse:SetDescription(FWX2Nome(cALI))
	oBrowse:SetTemporary(.T.)
	oBrowse:SetAlias(_cTrb)
	aStrTrb := (_cTRB)->( dbStruct() )
	For nCntStr := 1 To Len( aStrTrb )
		dbSelectArea( "SX3" )
		dbSetOrder( 2 )
		If dbSeek( aStrTrb[ nCntStr, 1 ] ) .And. Posicione("SX3",2,aStrTrb[ nCntStr, 1 ],"X3_BROWSE") == "S"
			//Necessário criar uma váriavel porque se possuir 2 X3Titulo() seguidos o 2º não atualiza.
			cTitulo := X3Titulo()
			aAdd( aFldBrw , { cTitulo , aStrTrb[ nCntStr, 1 ] , aStrTrb[ nCntStr, 2 ] , aStrTrb[ nCntStr, 3 ] , aStrTrb[ nCntStr, 4 ] , X3Picture() } )
			aAdd( aFldFil , { aStrTrb[ nCntStr, 1 ] , cTitulo, aStrTrb[ nCntStr, 2 ] , aStrTrb[ nCntStr, 3 ] , aStrTrb[ nCntStr, 4 ] , X3Picture() } )
		EndIf
	Next nCntStr
	oBrowse:SetFields(aFldBrw)
	If lAtivFil
		oBrowse:SetFieldFilter(aFldFil) //Indica os campos que serão apresentados na edição de filtros
	Else
		oBrowse:SetUseFilter(.F.)
	EndIf
	oBrowse:SetSeek(.T.,aPesq)

	If lCOLORS //Caso possua alguma legenda.
		For nLeg := 1 To Len(aCOLORS)
			If Len(aCOLORS[nLeg]) == 3 //Valida se foi passado corretamente as 3 posições.
				oBrowse:AddLegend(  aCOLORS[nLeg,1] , aCOLORS[nLeg,2] , aCOLORS[nLeg,3] )
			EndIf
		Next nLeg
	EndIf

	oBrowse:Activate()

	//+---------------------------------------------------------------------+
	//| Reabre o arquivo de Original                                        |
	//+---------------------------------------------------------------------+
	DbSelectArea("ST0")
	CHKFILE(_cTrb, .F.)

	//+---------------------------------------------------------------------+
	//| Se Possuir executa CODBLOCK defindo em bTMPFUNC                     |
	//+---------------------------------------------------------------------+
	If !Empty(bTMPFUNC)
		Eval(bTMPFUNC, _cTrb)
	Endif

	DbSelectArea(_cTrb)
	oTmpTbl:Delete()

	If lROTINA
		aROTINA := aCLONE(aOLD)
	Endif
	RestArea(aArea)

Return _cTrb

//---------------------------------------------------------------------
/*/{Protheus.doc} NGVISUAL
Funcao que posiciona para a visulizacao com a funcao
AXVISUAL da MICROSIGA usando arquivo temporario

@sample NGVISUAL( 'ST9' , 1 , 4 )

@param cAlias, string, alias da consulta
@param nReg, numérico, número do recno
@param nOpcx, numérico, Opção selecionada
@param cFunMenu, string, função a ser executada
@author Paulo Pego

@return Nil
/*/
//---------------------------------------------------------------------
Function NGVISUAL( cAlias, nReg, nOpcx, cFunMenu )

	Local aArea      := GetArea()
	Default cAlias   := Alias()
	Default nReg     := Recno()
	Default nOpcX    := 1
	Default cFunMenu := cFuncVis

	Private nRecOrig := &(cAlias + "->RECORIG")
	Private cTblOrig := &(cAlias + "->TBLORIG")

	If IsInCallStack( "mdtc700" )
		nOpcX := 1
	EndIf

	CHKFILE(cTblOrig, .F.)

	dbSelectArea(cTblOrig)
	dbGoTo(nRecOrig)
	If 'NGCAD01' $ cFunMenu
		NGCAD01(cTblOrig, nRecOrig, nOpcx)
	ElseIf 'NGCAD02' $ cFunMenu
		NGCAD02(cTblOrig, nRecOrig, nOpcx)
	Else

		If SubStr(cFunMenu,Len(cFunMenu),1) <> ")"
			//Verificado chamada da função pois, neste caso a visualização está na primeira posição do aRotina.
			cFunMenu += "(cTblOrig, nRecOrig," + cValtoChar(nOpcx) + ")"
		EndIf

		&(cFunMenu)

	EndIf

	//--------------------------------------
	//Posiciona o arquivo
	//--------------------------------------
	dbSelectArea(cTblOrig)
	Use

	dbSelectArea(cAlias)
	Set Filter To 
	RestArea(aArea)

Return NIL

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NGSEEK    ³ Autor ³ Paulo Pego           ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³1.cAlias - Alias do arquivo para pesquisa                   ³±±
±±³          ³2.cKEY - Chave de pesquisa no arquivo (sem filial)          ³±±
±±³          ³3.nORD - Ordem para pesquisa                                ³±±
±±³          ³4.cFIELD - Campo para retorno                               ³±±
±±³          ³5.cFilTroc - Filial para troca                  -N. Obrigat.³±±
±±³          ³6.cEmpTroc - Empresa para troca                 -N. Obrigat.³±±
±±³          ³7.cEmpRet - Empresa para retorno                -N. Obrigat.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Posiciona em um determidado registro e retorna um valor    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³ Nova funcionalidade.Acesso da filial pelo indice - 17/10/08³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSEEK(cALIAS,cKEY,nORD,cFIELD,cFilTroc,cEmpTroc,cEmpRet)
	Local xRet,aAreaSe := GetArea(),cEmpInfo,cFilInfo
	Local cFilArq := If(Empty(cFilTroc),xFilial(cALIAS),If(Empty(cEmpTroc),xFilial(cALIAS,cFilTroc),(NGTROCAFILI(cALIAS,cFilTroc,cEmpTroc))))
	Default cKEY := ''

	If cEmpTroc <> Nil
		dbSelectArea(cALIAS)
		cEmpInfo := If(cEmpRet <> NIL,cEmpRet,SM0->M0_CODIGO)
		cFilInfo := cFilAnt
		NGPrepTBL({{cALIAS,nORD}},cEmpTroc,cFilTroc)
	EndIf

	xRet := Posicione(cAlias, nOrd, cFilArq + cKey, cField)

	If cEmpTroc <> Nil
		NGPrepTBL({{cALIAS,nORD}},cEmpInfo,cFilInfo)
	EndIf

	RestArea(aAreaSe)
Return xRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCHKSX1  ³ Autor ³ Paulo Pego            ³ Data ³ 10/09/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica de o SX1 e inclui as perguntas faltantes           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cGRUPO -> Titulo do Grupo de Perguntas                     ³±±
±±³          ³ aPERG  -> Array bi-dimencional contendo os seguintes dados ³±±
±±³          ³           [n][01] - Pergunta                               ³±±
±±³          ³           [n][02] - Tipo                                   ³±±
±±³          ³           [n][03] - Tamanho                                ³±±
±±³          ³           [n][04] - Decimal                                ³±±
±±³          ³           [n][05] - Validacao                              ³±±
±±³          ³           [n][06] - F3                                     ³±±
±±³          ³           [n][07] - GSC                                    ³±±
±±³          ³           [n][08] - DEF.01                                 ³±±
±±³          ³           [n][09] - DEF.02                                 ³±±
±±³          ³           [n][10] - DEF.03                                 ³±±
±±³          ³           [n][11] - DEF.04                                 ³±±
±±³          ³           [n][12] - DEF.05                                 ³±±
±±³          ³           [n][13] - PICTURE                                ³±±
±±³          ³           [n][14] - PERSPA                                 ³±±
±±³          ³           [n][15] - PERENG                                 ³±±
±±³          ³           [n][16] - DEFSPA 01                              ³±±
±±³          ³           [n][17] - DEFSPA 02                              ³±±
±±³          ³           [n][18] - DEFSPA 03                              ³±±
±±³          ³           [n][19] - DEFSPA 04                              ³±±
±±³          ³           [n][20] - DEFSPA 05                              ³±±
±±³          ³           [n][21] - DEFENG 01                              ³±±
±±³          ³           [n][22] - DEFENG 02                              ³±±
±±³          ³           [n][23] - DEFENG 03                              ³±±
±±³          ³           [n][24] - DEFENG 04                              ³±±
±±³          ³           [n][25] - DEFENG 05                              ³±±
±±³          ³           [n][26] - X1_GRPSXG                              ³±±
±±³          ³                                                            ³±±
±±³          ³ lIncre -> Indica se inclui novas perguntas      -Nao Obrig.³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION NGCHKSX1(cGRUPO,aPERG,lIncre)

	Local i        := 0
	Local nChr     := 123
	Local cAli     := ALIAS()
	Local lNovP    := If(lIncre = Nil,.F.,lIncre)
	Local aGRUPO   := {"1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","Y","Z"}
	Local cDef01   := ""
	Local cDef02   := ""
	Local cDef03   := ""
	Local cDef04   := ""
	Local cDef05   := ""
	Local cPicture := ""
	Local cPerSpa  := ""
	Local cPerEng  := ""
	Local cDefSpa1 := ""
	Local cDefSpa2 := ""
	Local cDefSpa3 := ""
	Local cDefSpa4 := ""
	Local cDefSpa5 := ""
	Local cDefEng1 := ""
	Local cDefEng2 := ""
	Local cDefEng3 := ""
	Local cDefEng4 := ""
	Local cDefEng5 := ""
	Local cGrpSXG  := ""
	Local cVersRPO := GetRPORelease() //Pega a release do protheus Ex: 12.1.017
	Local cENGSX1  := "ENGSX1" + SubSTr(cVersRPO,4,1) + SubSTr(cVersRPO,7,2) //Monta a função de engenharia que irá alterar o conteúdo do parâmetro

	cGRUPO := PadR( Alltrim(cGRUPO), Len(Posicione("SX1", 1, Alltrim(cGRUPO), "X1_GRUPO")) )
	For i := 1 to Len(aPERG)

		cDef01   := IIf(Len(aPERG[i]) >  7, aPERG[i][8] ,"")
		cDef02   := IIf(Len(aPERG[i]) >  8, aPERG[i][9] ,"")
		cDef03   := IIf(Len(aPERG[i]) >  9, aPERG[i][10],"")
		cDef04   := IIf(Len(aPERG[i]) > 10, aPERG[i][11],"")
		cDef05   := IIf(Len(aPERG[i]) > 11, aPERG[i][12],"")
		cPicture := IIf(Len(aPERG[i]) > 12, aPERG[i][13],"")
		cPerSpa  := IIf(Len(aPERG[i]) > 13, aPERG[i][14],"")
		cPerEng  := IIf(Len(aPERG[i]) > 14, aPERG[i][15],"")
		cDefSpa1 := IIf(Len(aPERG[i]) > 15, aPERG[i][16],cDef01)
		cDefSpa2 := IIf(Len(aPERG[i]) > 16, aPERG[i][17],cDef02)
		cDefSpa3 := IIf(Len(aPERG[i]) > 17, aPERG[i][18],cDef03)
		cDefSpa4 := IIf(Len(aPERG[i]) > 18, aPERG[i][19],cDef04)
		cDefSpa5 := IIf(Len(aPERG[i]) > 19, aPERG[i][20],cDef05)
		cDefEng1 := IIf(Len(aPERG[i]) > 20, aPERG[i][21],cDef01)
		cDefEng2 := IIf(Len(aPERG[i]) > 21, aPERG[i][22],cDef02)
		cDefEng3 := IIf(Len(aPERG[i]) > 22, aPERG[i][23],cDef03)
		cDefEng4 := IIf(Len(aPERG[i]) > 23, aPERG[i][24],cDef04)
		cDefEng5 := IIf(Len(aPERG[i]) > 24, aPERG[i][25],cDef05)
		cGrpSXG  := IIf(Len(aPERG[i]) > 25, aPERG[i][26],"")
		cPSX1    := IIf(lNovP,NGSX1PROXORD(cGRUPO),StrZero(i,2))
		cCH      := IIf(lNovP,If(val(cPSX1) <= Len(aGRUPO),aGRUPO[Val(cPSX1)],Chr(nChr++)),If(i <= Len(aGRUPO),aGRUPO[i],Chr(nChr++)))
		cPA      := IIf(lNovP,cPSX1,StrZero(i,2))

		If Empty(Posicione("SX1",1,cGRUPO+cPSX1,"X1_GRUPO")) .And.;//Caso não exista a pergunta
		   cVersRPO < '12.1.023'

			&cENGSX1.(cGRUPO       ,; //<cGrupo>
			          cPSX1        ,; //<cOrdem>
					  aPERG[i][1]  ,; //<cPergunt>
					  aPERG[i][1]  ,; //<cPerSpa>
					  aPERG[i][1]  ,; //<cPerEng>
					  "MV_CH"+cCH  ,; //<cVar>
					  aPERG[i][2]  ,; //<cTipo>
					  aPERG[i][3]  ,; //<nTamanho>
					  aPERG[i][4]  ,; //<nDecimal>
					  0            ,; //<nPresel>
					  aPERG[i][7]  ,; //<cGSC>
					  aPERG[i][5]  ,; //<cValid>
					  aPERG[i][6]  ,; //<cF3>
					  cGrpSXG      ,; //<cGrpSxg>
					  "2"          ,; //<cPyme>
					  "MV_PAR"+cPA ,; //<cVar01>
					  cDef01       ,; //<cDef01>
					  cDefSpa1     ,; //<cDefSpa1>
					  cDefEng1     ,; //<cDefEng1>
					  ""           ,; //<cCnt01>
					  cDef02       ,; //<cDef02>
					  cDefSpa2     ,; //<cDefSpa2>
					  cDefEng2     ,; //<cDefEng2>
					  cDef03       ,; //<cDef03>
					  cDefSpa3     ,; //<cDefSpa3>
					  cDefEng3     ,; //<cDefEng3>
					  cDef04       ,; //<cDef04>
					  cDefSpa4     ,; //<cDefSpa4>
					  cDefEng4     ,; //<cDefEng4>
					  cDef05       ,; //<cDef05>
					  cDefSpa5     ,; //<cDefSpa5>
					  cDefEng5     ,; //<cDefEng5>
					  {}           ,; //<aHelpPor>
					  {}           ,; //<aHelpEng>
					  {}           ,; //<aHelpSpa>
					  "")             //<cHelp> )

		Endif
	Next
	DbSelectArea(cALI)
Return NIL

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGFUNGE   ³ Autor ³In cio Luiz Kolling    ³ Data ³05/03/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa que Chamada as Fun‡äes Genericas                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGFUNGE()

	/*
	cFUNCAO := SPACE(50)
	cPARAME := SPACE(200)
	nOpca   := 1

	DEFINE MSDIALOG oDlg4 TITLE OemToAnsi(STR0054) From 15,15 To 25,85 OF oMainWnd //"Chamada Funcao Generica"
	@ 1.8,2 say OemtoAnsi(STR0055) //"Nome Funcao"
	@ 1.8,7 MSget cFUNCAO Picture "@!" SIZE 50,12 VALID NAOVAZIO() .And. NGFUNCRPO()
	@ 2.9,2 say OemtoAnsi(STR0056) //"Parametros"
	@ 2.9,7 MSget cPARAME Picture "@S150!"  SIZE 200,12
	ACTIVATE MSDIALOG oDlg4 ON INIT EnchoiceBar(oDlg4,{||nOpca:=2,oDlg4:End()},{||nOpca:=1,oDlg4:End()})

	If nOpca == 2
	vvFUNC := ALLTRIM(cFUNCAO)+'('+ALLTRIM(cPARAME)+')'
	cFUNC  := &(vvFUNC)
	Endif*/

	//Função descontinuada por medidas de segurança.
	MsgStop(STR0450) //"Função descontinuada por medidas de segurança, duvidas consultar o chamado TUUYFN"

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} NGFUNCRPO
Validação da Chamada da Função

@type   Function

@author Inácio Luiz Kolling
@since  05/03/2001
@Param  cFUNCRPO, Caractere, Nome da funcao
@Param  lTela, Lógico, Indica se mostra mensagem
@Param  cProgram, Caractere, Nome do fonte para atualizar

@return Lógico, verdadeiro se a função foi encontrada
/*/
//-------------------------------------------------------------------
Function NGFUNCRPO(cFUNCRPO, lTela, cProgram)

	Local lMostT   := IIf(lTela = Nil, .T., lTela)
	Local lRetF    := .T.
	Local cPESFRPO := IIf(cFUNCRPO = Nil, cFUNCAO, cFUNCRPO)

	If !FINDFUNCTION(cPESFRPO)

		If lMostT

			If cProgram <> Nil
				Help(,, STR0025,, STR0057 + CRLF + "( " + Alltrim(cPESFRPO) + " )",1 ,0 ,,,,,, {STR0204 + " " + cProgram})
			Else
				msgInfo(STR0057 + CRLF + "( " + Alltrim(cPESFRPO) + " )", STR0053) // "Função Nao Encontrada No RPO Em Uso"###"NAO CONFORMIDADDE"
			EndIf

		Endif

		lRetF := .F.

	Endif

Return lRetF

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³NGSEMANANO ³ Autor ³ NG Informatica Ltda   ³ Data ³26/11/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡Æo³Calcula a semana do ano                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³dDTANO                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
/*/
Function NGSEMANANO(dDTANO)
	Local i
	Local nSemana := 0
	Local dData
	Local nData

	If !Empty(dDTANO)

		dData := CTOD('01/01/'+Right(cValToChar(Year(dDTANO)),2))

		If dow(dData) <> 1
			For i := 1 to 6
				dData := dData + 1
				If Dow(dData) == 1
					Exit
				Endif
			Next
		Endif

		nData := Int((dDTANO - dData) / 7) + 1

		nSemana := Int(nData)
	Endif
Return nSemana

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGVALHORA ³ Autor ³In cio Luiz Kolling    ³ Data ³11/03/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³V lida a hora                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cVHORA - Hora                                  - Obrigat¢rio³±±
±±³          ³lMOSTM - Indica se a sa¡da de erro na tela     - Obrigatorio³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³.T. ou .F.                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGVALHORA(cVHORA,lMOSTM,lObrigat)
	Local lSMENS := If(lMOSTM = NIL,.T.,lMOSTM)
	Local lRETVH := .T.
	Local lPROVH := .F.
	Local xh,xm

	Default lObrigat := .F.

	If (Empty(cVHORA) .Or. Alltrim(cVHORA) == ":") .And. !lObrigat
		lPROVH := .F.
	Else
		posv := At(":",cVHORA)
		If posv = 0
			lPROVH := .T.
		Else
			cHorav   := SubStr(cVHORA,1,(posv-1))
			cMinutov := SubStr( cVHORA,(posv+1),2)
			If Empty(cHorav) .Or. Empty(cMinutov) .Or. Len(Alltrim(cMinutov)) < 2
				lPROVH := .T.
			Else
				For xh := 1 To Len(cHorav)
					cCARACHOR := Substr(cHorav,xh,1)
					If Empty(cCARACHOR) .Or. !Isdigit(cCARACHOR)
						lPROVH := .T.
						Exit
					Endif
				Next xh
				If !lPROVH
					For xm := 1 To Len(cMinutov)
						cCARACMIN := Substr(cMinutov,xm,1)
						If Empty(cCARACMIN) .Or. !Isdigit(cCARACMIN)
							lPROVH := .T.
							Exit
						Endif
					Next xm
				Endif

				If !lPROVH
					nHorav   := Val(cHorav)
					nMinutov := Val(cMinutov)
					If nHorav >= 24 .Or. nHorav < 0 .Or. (nHorav = 24 .And. nMinutov > 0)
						lPROVH := .T.
					Endif
					If !lPROVH
						If nMinutov >= 60 .Or. nMinutov < 0
							lPROVH := .T.
						Endif
					Endif
				Endif
			Endif
		Endif
	Endif

	If lPROVH
		If lSMENS
			Help(" ",1,"HORAINVALI")
		Endif
		lRETVH := .F.
	Endif
Return lRETVH

//-------------------------------------------------------------------
/*/{Protheus.doc} NGGRAFICO
Valida montagem do gráfico ( Arquivos / Parâmetros )

@author  Inácio Luiz Kolling
@since   06/12/2004
@version P11/P12

@param   cTITJA,       Caracter, Linha titulo do gráfico (janela)
@param   cTITEG,       Caracter, Linha titulo da esquerda do gráfico
@param   cTITSG,       Caracter, Linha titulo superior do gráfico
@param   cTITDG,       Caracter, Linha titulo da direita do gráfico
@param   cTITIN,       Caracter, Linha titulo da inferior do gráfico
@param   vSERIE,       Vetor,    Linha series do grafico
@param   cLEIT,        Caracter, Leitura ("A" - Arquivo temporario,"M" - Matriz)
@param   cVALIA,       Caracter, Alias do arquivo temporário
@param   [aMATRI],     Array,    Matriz com os dados
@param   [cTypeGraf],  Caracter, Tipo de gráfico
@param   [lNgGrafico], Caracter, Forca a usar a funcao NGGRAPHIC
@param   [oGrafOpen],  Objeto,   Objeto no qual sera aberta o gráfico
@param   [oObjLeg],    Objeto,   Objeto no qual sera criada a legenda

/*/
//-------------------------------------------------------------------
Function NGGRAFICO( cTITJA, cTITEG,cTITSG,cTITDG,cTITIN,vSERIE,cLEIT,cVALIA,;
					aMATRI, cTypeGraf, lNgGrafico, oObjOpen, oObjLeg)

	Local cMENTXT   := STR0108 + chr(13) + STR0109 + chr(13) + chr(13) + STR0110 + " NGCRIAGATXT"
	Local lRet	    := .T.
	Local nType		:= Nil
	Local nForMat	:= 0
	Local aDataGra	:= Array( 6 )
	Local aLEG		:= {}
	Local aEIXOX	:= {}
	Local aDate		:= {}
	Local aValues	:= {}

	Default lNgGrafico := .F.

	If ( cLEIT == "A" .And. ( cVALIA == NIL .Or. Empty( cVALIA ) ) ) .Or. ( cLEIT == "M" .And. ( aMATRI == NIL .Or. Empty( aMATRI ) ) )
		lRet := .F.
	Endif

	If lRet

		// Monta os dados do gráfico
		If cLEIT == "A"
			dbSelectArea( cVALIA )
			dbGoTop()
			While (cVALIA)->( !EoF() )

				aDate := fGetValues( (cVALIA)->( dbStruct() ), cVALIA )

				// Valores do Gráfico
				aAdd( aValues, aDate[ 1 ] )
				// Cordenadas para montagem do gráfico;
				aAdd( aEIXOX,  aDate[ 2 ] )
				// Legenda
				aAdd( aLeg,    aDate[ 3 ] )

				dbSelectArea(cVALIA)
				(cVALIA)->( DbSkip() )
			EndDo
		Else
			For nForMat := 1 To Len( aMATRI )

				aDate := fGetValues( aMATRI[ nForMat ] )

				// Valores do Gráfico
				aAdd( aValues, aDate[ 1 ] )
				// Cordenadas para montagem do gráfico;
				aAdd( aEIXOX,  aDate[ 2 ] )
				// Legenda
				aAdd( aLeg,    aDate[ 3 ] )
			Next nForMat
		Endif

		// Monta estrutura de criação do gráfico
		aDataGra[ 1 ] := { cTITEG, cTITSG, cTITDG, cTITIN }
		aDataGra[ 2 ] := aClone( vSERIE )
		aDataGra[ 3 ] := aClone( aLEG )
		aDataGra[ 4 ] := aClone( aEIXOX )
		aDataGra[ 5 ] := aClone( aValues )
		aDataGra[ 6 ] := cTITJA

		If !Empty(cTypeGraf)
			If cTypeGraf $ "025"
				nType := GRP_LINE
			ElseIf cTypeGraf == "4"
				nType := GRP_PIE
			ElseIf  cTypeGraf $ "37"
				nType := GRP_POINT
			Else
				nType := GRP_BAR
			EndIf
		EndIf
		
		// Tratativa para não gerar incompatibilidade ao atualizar o NGUTIL e não atualizar o MNTC920.
		If IsInCallStack("MNTC920") .And. Len( vSERIE ) > 0 .And. vSERIE[1] == 'REALIZADO'
			NGGRAFFWCH( aDataGra )
		ElseIf IsInCallStack("MNTC910")
			NGGRAFFMOV( , , , aDataGra )
		Else
			NGGRAPHIC( nType, IIF( lNgGrafico, oObjOpen, ), IIF( lNgGrafico, oObjLeg, ), aDataGra )
		EndIf
	Else
		MsgInfo(cMENTXT,STR0053)
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} NGGraphic
Funcao para ler txt criado pelo NGGRAFICO e gerar grafico utilizando
a classe MsGraphic

@author  Vitor Emanuel Batista
@since   17/02/2010
@version P11/P12
@use	 NGGRAFICO

@param	 nType,       Numérico, Tipo Inicial de Gráfico
@param	 [oGrafOpen], Objeto,   Objeto no qual sera aberta o gráfico
@param	 [oObjLeg],	  Objeto,   Objeto no qual sera criada a legenda
@param	 aDataGra,    Array,	Dados para montagem do Gráfico
/*/
//-------------------------------------------------------------------
Function NGGraphic( nType, oObjOpen, _oObjLeg, aDataGra )

	Default lNewChart := .F.
	Default oObjOpen := Nil
	Default _oObjLeg := Nil
	Default nType    := GRP_BAR //GRP_LINE, GRP_AREA, GRP_POINT, GRP_BAR, GRP_PIE

	Private nNGGraType  := nType
	Private lNGGraLeg   := .T.
	Private aGraph		:= aDataGra

	If oObjOpen == Nil
		Private oNGGraphic
		//Cores disponiveis para o grafico
		Private aColorGraph := {CLR_HGREEN,CLR_HBLUE,CLR_HRED,CLR_YELLOW,CLR_BROWN,CLR_CYAN,;
		CLR_MAGENTA,CLR_GRAY,CLR_WHITE,CLR_BLUE,CLR_GREEN,CLR_RED,CLR_HGRAY,;
		CLR_HCYAN,CLR_HMAGENTA,CLR_BLACK,RGB(178,241,18),RGB(131,199,154),;
		RGB(111,156,210),RGB(236,99,120),RGB(255,255,162),RGB(19,88,88),;
		RGB(60,9,60),RGB(141,125,194),RGB(255,93,0),RGB(255,196,0)}
	Endif

	//Se nao foi gerado relatorio retorna .F.
	If Len(aGraph) == 0
		Return .F.
	EndIf

	//Cores para os textos do cabecalho e rodape
	Private aColorText  := {CLR_GREEN,CLR_GREEN}

	cTitulo := aGraph[6]

	fNewChart( aGraph )

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} CreateSerie
Cria serie de acordo com o tipo de gráfico passado por parametro

@author  Vitor Emanuel Batista
@since   17/02/2010
@version P11/P12
@use	 NGGRAPHIC

@param	 oDlg,       Objeto,   Dialog para criacao do gráfico
@param	 nType,      Numérico, Tipo de gráfico a ser gerado
@param	 aGraph,     Array,	   Array contendo informacoes sobre o gráfico
@param	 [oObjOpen], Objeto,   Objeto no qual sera aberta o gráfico
/*/
//-------------------------------------------------------------------
Static Function CreateSerie( oDlg, nType, aGraph, oObjOpen )

	Local nX,nZ
	Local aTIT       := aGraph[1]
	Local aSER       := aGraph[2]
	Local aEIXOX     := aGraph[4]
	Local aVALUE     := aGraph[5]
	Local aTot       := {}
	Local oChart     := Nil

	oChart := FWChartFactory():New()
	oChart := oChart:GetInstance( nType )
	oChart:SetTitle( aTIT[3], CONTROL_ALIGN_CENTER) //"Oportunidades por fase"
	oChart:Init( oDlg, .T. )	
	oChart:setPicture( "99999.99" )
	oChart:setLegend( CONTROL_ALIGN_RIGHT ) 	
	oChart:setColor( 'Random' ) 

	ProcRegua(Len(aSER)*Len(aEIXOX))

	If GRP_PIE == nType .Or. PIECHART == nType
		nTotal := 0
		aEval(aVALUE[1],{|x| nTotal += x})
		If Len(aSER) > 1 .or. nTotal == 0
			nTotal := 0

			For nX := 1 To Len( aEIXOX )

				nTotSerie := 0

				IncProc( STR0167 ) // Processando gráfico...

				nTotSerie += aVALUE[nX, 1]

				If FWIsInCallStack( 'MNTC905' )

					nTotal += NGConverHora( aVALUE[nX, 1], 'S', 'D' )

				Else
					
				nTotal += aVALUE[nX,1]

				EndIf
			
				aAdd( aTot, nTotSerie )

			Next nX
				
			For nZ := 1 To Len( aTot )

				aTot[nZ] *= 100  

				oChart:addSerie( AllTrim(aEIXOX[nZ]), Round(aTot[nZ]/nTotal,2) )

			Next nZ

		Else
			nTotal := 0
			aEval(aVALUE,{|x| nTotal += x[1]})
			nTotal /= 100
			For nX := 1 To Len(aEIXOX)
				If Len(aEIXOX) > 16 .and. aVALUE[nX][1] == 0
					Loop
				Endif
				IncProc(STR0167) //"Processando gráfico..."

				oChart:addSerie( aEIXOX[nX], Round(aVALUE[nX][1]/nTotal,2) )

			Next nX
		EndIf
	Else
		
		For nX := 1 To Len(aEIXOX)

			aChart := {}

			IncProc(STR0167) //"Processando gráfico..."

			aadd( aChart, { aEIXOX[nX], aVALUE[nX][1]})

			oChart:addSerie( AllTrim(aEIXOX[nX]), aChart )

		Next nX
		

	EndIf

	oChart:Build()
	
Return oChart

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³DetailGraph ³Autor ³Vitor Emanuel Batista  ³ Data ³02/03/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Mostra detalhes sobre os itens em X                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NGGRAPHIC                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function DetailGraph(aGraph)
	Local oDlg, oScroll
	Local nX
	Local aLEG   := aGraph[3]
	Local aEIXOX := aGraph[4]

	DEFINE DIALOG oDlg TITLE STR0174 FROM 0,0 TO 250,400 Pixel //"Detalhes""Detalhes"
	oFont := TFont():New('Courier new',,-18,.T.)
	oScroll := TScrollBox():New(oDlg,01,01,50,100,.T.,.T.,.T.)
	oScroll:Align := CONTROL_ALIGN_ALLCLIENT
	For nX := 1 To Len(aEIXOX)
		TSay():New((nX-1)*9 + 1,03,&("{|| '"+AllTrim(aEIXOX[nX]) + " - " + AllTrim(aLEG[nX]) + "' }"),oScroll,,oFont,,,,.T.,CLR_BLACK,CLR_WHITE)
	Next nX
	ACTIVATE DIALOG oDlg CENTERED


Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AlterGraph  ³Autor ³Vitor Emanuel Batista  ³ Data ³17/02/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta GetDados para alteracao dos valores do grafico         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NGGRAPHIC                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function AlterGraph(oParent,aGraph)

	Local oDlg
	Local nX,nY
	Local aTmpRotina
	Local aTIT   := aGraph[1]
	Local aSER   := aGraph[2]
	//Local aLEG   := aGraph[3]
	Local aEIXOX := aGraph[4]
	Local aVALUE := aGraph[5]
	Local lConfirm := .F.
	Local cLinOk := "n <= Len(aCols)"

	Private aHeader := {}
	Private aCols   := {}
	Private M->NGGRAPHIC := Space(15)

	If Type("aRotina") == "A"
		aTmpRotina := aClone(aRotina)
	EndIf

	//Para o funcionamento do GetDados
	Private aRotina := {	{ "" , ""    , 0 , 1},;
	{ "" , ""    , 0 , 2},;
	{ "" , ""    , 0 , 3},;
	{ "" , ""    , 0 , 4,0},;
	{ "" , ""    , 0 , 5,3},;
	{ "" , ""    , 0 , 6,0}}

	//Cria aHeader conforme array aTIT
	If !IsInCallStack("MNTC920")
		aAdd(aHeader,{ aTIT[4]+Space(50-Len(aTIT[4])),"NGGRAPHIC", " ",, 0,"AllwaysTrue()","€€€€€€€€€€€€€€ ", "C", ""/*x3_arquivo*/, "V" } )
	EndIf
	For nX := 1 to Len(aSER)
		aAdd(aHeader,{ TRIM(aSER[nX]),"NGGRAPHIC", "@E 9999999999999.99",15, 2,"AllwaysTrue()","€€€€€€€€€€€€€€ ", "N", ""/*x3_arquivo*/, "R" } )
	Next nX
	If !IsInCallStack("MNTC920")
		//Alimenta aCols conforme array aVALUE
		For nX := 1 To Len(aEixoX)
			aAdd(aCols,{aEixoX[nX]})
			For nY := 1 To Len(aSER)
				aAdd(aTail(aCols),aVALUE[ nX, nY ])
			Next nY
			aAdd(aTail(aCols),.F.)
		Next nX
	Else
		aCols := {{}}
		For nX := 1 To Len(aSER)
			aAdd(aTail(aCols),aVALUE[ nX, 1 ])
		Next nX
		aAdd(aTail(aCols),.F.)
	EndIf

	DEFINE DIALOG oDlg TITLE STR0181 FROM 0,0 TO 400,600 PIXEL //"Alteração dos Dados"
	oGet := MSGetDados():New(0,0,140,315,3,"AllwaysTrue()",cLinOk,cLinOk)
	oGet:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oGet:nMax := Len(aCols)
	ACTIVATE DIALOG oDlg ON INIT EnchoiceBar(@oDlg,{|| lConfirm := .T.,oDlg:End()},{|| lConfirm := .F.,oDlg:End()}) CENTERED

	If lConfirm
		If !IsInCallStack("MNTC920")
			For nX := 1 To Len(aCols)

				//Adiciona a alteração do eixo
				aEIXOX[nX] := aCols[nX][1]

				//Adiciona os valores do grafico
				For nY := 2 To Len(aCols[nX])-1
					aVALUE[nX][nY-1] := aCols[nX][nY]
				Next nY

			Next nX
		Else
			For nY := 1 To Len( aCols[ 1 ] ) - 1
				aVALUE[ nY, 1 ] := aCols[ 1, nY ]
			Next nY
		EndIf

		Processa({ || CreateSerie(oParent,nNGGraType,aGraph)})
	EndIf

	If ValType(aTmpRotina) == "A"
		aRotina := aTmpRotina
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} PrintGraph(cTitle, oGraphic, lFormat)
Imprime grafico pelo FwMSPrinter

@author	Alexandre Santos
@since	20/04/2018
@param	cTitle	, Caracter	, Titulo do Relatorio
		oGraphic, Objeto	, Objeto gráfico para impressão.
		lFormat	, Lógico	, Valida formato do arquivo, .F. - BMP .T. - PNG

@return	Nil
/*/
//---------------------------------------------------------------------
Static Function PrintGraph(cTitle, oGraphic, lFormat)

	Local cRaizServer 	:=  AllTrim(GetSrvProfString("StartPath",If(issrvunix(), "/", "\")))
	Local cDirTemp    	:= GetTempPath()
	Local cNameImg    	:= CriaTrab(, .F.)
	Local nLarg			:= 0
	Local nAlt			:= 0
	Local nOrientation	:= 0
	Local lCopy 		:= .F.

	Default lFormat := .F.
	Default cTitle	:= cNameImg

	If lFormat
		cNameImg += ".PNG"
		If GetScreenRes()[2] < 1025 .And. GetScreenRes()[1] < 1281
			oGraphic:saveToPng( 4, 4, 1210, 793, cDirTemp + cNameImg)
		ElseIf GetScreenRes()[2] == 1080 .And. GetScreenRes()[1] == 1920
			oGraphic:saveToPng( 4, 4, 1855, 848, cDirTemp + cNameImg)
		Else
			oGraphic:saveToPng( 4, 4, 1302, 536, cDirTemp + cNameImg)
		EndIf
		lCopy := .T.
	Else
		cNameImg += ".BMP"
		oGraphic:SaveToBMP(cNameImg,cRaizServer)
		lCopy := __CopyFile(cRaizServer + cNameImg, cDirTemp + cNameImg)
		Ferase(cRaizServer + cNameImg)
	EndIf

	If lCopy
		oPrint := FwMSPrinter():New(cTitle, 6, .F., , .F.)			//Cria um objeto que permite visualizar e imprimir relatório.													//Apresenta a janela de configuração de impressoras.
		// Caso a geracao do relatorio tenha sido cancelado, encerra a funcao
		IF Empty(oPrint:cPathpdf)
			Return .F.
		EndIf

		oPrint:StartPage()

		nOrientation := oPrint:GetOrientation()						//Retorna a orientação (Retrato-1 ou Paisagem-2) do objeto.

		If nOrientation == 2
			nLarg := 770
			nAlt  := 370
			oPrint:SayBitmap( 50, 25, cDirTemp + cNameImg, nLarg, nAlt )	//Insere uma imagem no relatório
			oPrint:SetLandscape()									//Define a orientação do relatório como paisagem (Landscape).
		Else
			nLarg := 550
			nAlt  := 250
			oPrint:SayBitmap( 50, 25, cDirTemp + cNameImg, nLarg, nAlt )	//Insere uma imagem no relatório
			oPrint:SetPortrait()										//Define a orientação do relatório como retrato (Portrait).
		EndIf

		oPrint:Preview() //Abre a janela de visualização do relatório.

	Else
		MsgStop( STR0182,STR0025 ) //"Não foi possível copiar a imagem para o servidor."##"ATENCAO"
	EndIf

Return


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³SetLegenda  ³Autor ³Vitor Emanuel Batista  ³ Data ³17/02/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Habilita ou desabilita a legenda                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NGGRAPHIC                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function SetLegenda()
	lNGGraLeg := !lNGGraLeg
	oNGGraphic:SetLegenProp( GRP_SCRRIGHT, CLR_WHITE, GRP_SERIES, lNGGraLeg)
	oNGGraphic:ZoomIn()
	oNGGraphic:ZoomOut()
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AlterColor  ³Autor ³Vitor Emanuel Batista  ³ Data ³01/03/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Altera as cores do Grafico                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aItens - Itens que irao aparecer no TRadMenu                 ³±±
±±³          ³oParent- Janela Pai                                          ³±±
±±³          ³aGrapht- Array contendo dados do Grafico                     ³±±
±±³          ³aColor - Cores do tipo a ser alterado                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NGGRAPHIC                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function AlterColor(aItens,oParent,aGraph,aColor)
	Local oDlg, oColor, oScroll
	Local lConfirm, nRadio,nTmpRadio
	Local aTmpColor := aClone(aColor)

	DEFINE DIALOG oDlg TITLE STR0184 FROM 0,0 TO 270,600 PIXEL //"Alteração de Cores"
	oScroll := TScrollBox():New(oDlg,01,01,50,100,.T.,.T.,.T.)
	oScroll:Align := CONTROL_ALIGN_LEFT

	nRadio := nTmpRadio := 1
	oRadio := TRadMenu():New (01,01,aItens,,oScroll,,,,,,,,98,12,,,,.T.)
	oRadio:Align   := CONTROL_ALIGN_LEFT
	oRadio:bSetGet := {|u| If(PCount()==0,nRadio,nRadio:=u)}
	oRadio:bChange := {|| aTmpColor[nTmpRadio] := oColor:RetColor(),	oColor:SetColorIni(aColor[nRadio]),;
	oColor:SetColor(aTmpColor[nRadio]),nTmpRadio:= nRadio}

	oColor := tColorTriangle():Create( oDlg  )
	oColor:Align := CONTROL_ALIGN_ALLCLIENT
	oColor:SetColorIni(aColor[1])
	oColor:SetColor(aColor[1])

	ACTIVATE DIALOG oDlg ON INIT EnchoiceBar(@oDlg,{|| lConfirm := .T.,Eval(oRadio:bChange),oDlg:End()},{|| lConfirm := .F.,oDlg:End()}) CENTERED

	If lConfirm
		aColor := aTmpColor
		Processa({ || CreateSerie(oParent,nNGGraType,aGraph)})
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NGCALCH100³ Autor ³In cio Luiz Kolling    ³ Data ³04/08/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula a quantidade de horas entre datas e horas           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ dDTAINI  - Data inicial                    - Obrigat¢rio   ³±±
±±³          ³ hHORINI  - Hora inicial                    - Obrigat¢rio   ³±±
±±³          ³ dDTAFIM  - Data final                      - Obrigat¢rio   ³±±
±±³          ³ hHORFIM  - Hora final                      - Obrigat¢rio   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³nHORETO   - Quantidade de horas em valor numerico           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCALCH100(dDTAINI,hHORINI,dDTAFIM,hHORFIM)
	Local nSOMA := 0,nHORETO := 0,nINI := (HTOM(hHORINI)/60)
	Local nFIM  := (HTOM(hHORFIM)/60)

	IF dDTAFIM > dDTAINI
		nSOMA := ((dDTAFIM - dDTAINI)*24)
	ENDIF

	nHORAFI := (nFIM+nSOMA) - nINI
	cHORACA := Alltrim(Str(nHORAFI))
	nPOSVIS := At('.',cHORACA)
	If nPOSVIS > 0
		cHORAINI := Substr(cHORACA,1,nPOSVIS-1)
		cMINUINI := Alltrim(Substr(cHORACA,nPOSVIS+1,3))
		If Len(Alltrim(cMINUINI)) > 2
			cPRIMINU := Substr(cMINUINI,1,1)
			cSEGMINU := Substr(cMINUINI,2,1)
			cTERMINU := Substr(cMINUINI,3,1)
			cSOMMINU := If(cSEGMINU = cTERMINU,Str(Val(cSEGMINU)+1),cSEGMINU)
			nHORACER := Val(cHORAINI+'.'+cPRIMINU+Alltrim(cSOMMINU))
		Else
			nHORACER := nHORAFI
		Endif
		nHORETO := nHORACER
	Else
		nHORETO := nHORAFI
	Endif
Return nHORETO

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡Æo   ³NGCALCHCAR³ Autor ³ Inacio Luiz Kolling   ³ Data ³05/08/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³Calcula a quantidade de horas entre duas datas e horas,     ³±±
±±³          ³Considerando 24 horas por dia e horas tipo caracter..'00:00'³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorna  ³cHORACAR - Quantidade de horas.... 10:10                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function NGCALCHCAR(dINICIO,hINICIO,dDFIM,hOFIM)
	Local nINIHOR := HTOM(hINICIO), nFIMHOR := HTOM(hOFIM)
	Local cHORAHO,cHORAIHO,cHORINHO,cMININHO,cHORACAR
	Local nSOMADT,nPOSTIHO,nHORINHO,nMININHO

	Store 0 To nSOMADT,nPOSTIHO,nHORINHO,nMININHO

	If dDFIM > dINICIO
		nSOMADT := ((dDFIM - dINICIO)*1440)
	Endif

	cHORAHO  := NTOH(((nFIMHOR+nSOMADT) - nINIHOR)/60)
	cHORAIHO := Alltrim(cHORAHO)
	nPOSTIHO := At (':',cHORAIHO)

	If nPOSTIHO > 0
		cHORINHO := Substr(cHORAIHO,1,nPOSTIHO-1)
		cMININHO := Substr(cHORAIHO,nPOSTIHO+1,2)
		nHORINHO := Val(cHORINHO)
		nMININHO := Val(cMININHO)
		cHORACAR := If(nHORINHO < 10,Alltrim(Strzero(nHORINHO,2)),Alltrim(Str(nHORINHO,4))) + ':' + Strzero(nMININHO,2)
	Endif
Return cHORACAR

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡Æo   ³NGSAMAHCAR³ Autor ³ Inacio Luiz Kolling   ³ Data ³05/08/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³Soma a quantidade de horas em uma variavel de totalizador.  ³±±
±±³          ³Considerando as horas tipo caracter..'01:00' .. '10:30      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorna  ³cHORSOMAD  Quantidade de horas total .... 11:30             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function NGSOMAHCAR(cHORASAMA,cHORASTOT)
	Local cHORSAMA := Alltrim(cHORASAMA), cHORTOT := Alltrim(cHORASTOT)
	Local cHORINH1,cMININH1,cHORISOM,cMINISOM,cHORSOMAD // := '00:00'
	Local nHORINH1,nMININH1,nHORISOM,nMINISOM,nHORSOMFIM,nMINSOMFIM,nPOSAMA,nPOSTOT

	Store 0 To nHORINH1,nMININH1,nHORISOM,nMINISOM,nHORSOMFIM,nMINSOMFIM
	Store 0 To nPOSAMA,nPOSTOT

	nPOSAMA := At(':',cHORSAMA)
	nPOSTOT := At(':',cHORTOT)

	If nPOSAMA > 0 .And. nPOSTOT > 0
		cHORINH1 := Substr(cHORSAMA,1,nPOSAMA-1)
		cMININH1 := Substr(cHORSAMA  ,nPOSAMA+1,2)
		nHORINH1 := Val(cHORINH1)
		nMININH1 := Val(cMININH1)

		cHORISOM := Substr(cHORTOT,1,nPOSTOT-1)
		cMINISOM := Substr(cHORTOT  ,nPOSTOT+1,2)
		nHORISOM := Val(cHORISOM)
		nMINISOM := Val(cMINISOM)

		nHORSOMFIM := nHORISOM + nHORINH1
		nMINSOMFIM := nMINISOM + nMININH1

		IF nMINSOMFIM >= 60
			nHORSOMFIM := nHORSOMFIM + 1
			nMINSOMFIM := nMINSOMFIM - 60
		Endif
		cHORSOMAD := If(nHORSOMFIM < 10,Alltrim(Strzero(nHORSOMFIM,2)),Alltrim(Str(nHORSOMFIM,14)))  + ':' + Strzero(nMINSOMFIM,2)
	Endif
Return cHORSOMAD

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCAMPNSX3³ Autor ³ Inacio Luiz Kolling   ³ Data ³24/11/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retira da achoice os campos que nao deverao faz parte da    ³±±
±±³          ³enchoice                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cVALIAS    - Nome do alias                                  ³±±
±±³          ³vVNCAMPO   - Vetor com os campos nao usados na enchoice     ³±±
±±³          ³lBROWSE    - Adiciona somente campos que sao mostrados no   ³±±
±±³          ³             Browse                                         ³±±
±±³          ³lUser      - Se .T. considera os campos de usuario, caso    ³±±
±±³          ³             contrario, nao adiciona esses campos.          ³±±
±±³          ³             Default: .T. -> Considera os campos de usuario.³±±
±±³          ³lTodo      - Se .T., nao verifica se o USADO nem o NIVEL dos³±±
±±³          ³             campos, considerando todos como validos para a ³±±
±±³          ³             verificacao.                                   ³±±
±±³          ³             Default: .F. -> Considera USADE e NIVEL.       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³vCAMPOSX3  - Vetor com os campos da enchoice                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCAMPNSX3(cVALIAS,vVNCAMPO,lBROWSE, lUser, lTodo)
	Local vCAMPOSX3 := {}
	Local aArea     := GetArea()
	Local aCampSx3  := {}
	Local nX        := 0
	Local nTamCamp  := 0
	Local lAdd      := .T.

	Default cVALIAS  := Alias()
	Default vVNCAMPO := {}
	Default lBROWSE  := .F.
	Default lUser    := .T.
	Default lTodo    := .F.

	aCampSx3 := NGHeader(cVALIAS)
	nTamCamp := Len(aCampSx3)

	If nTamCamp > 0
		For nX := 1 To nTamCamp
			If (X3USO(aCampSx3[nX,7]) .And. cNivel >= Posicione("SX3",2,aCampSx3[nX,2],"X3_NIVEL")) .Or. lTodo
				If Ascan(vVNCAMPO,{|x| Alltrim(Upper(x)) == Alltrim(aCampSx3[nX,2])}) = 0
					lAdd := .T.
					If lBROWSE .And. Posicione("SX3",2,aCampSx3[nX,2],"X3_BROWSE") != 'S'
						lAdd := .F.
					EndIf
					If !lUser .And. AllTrim(Posicione("SX3",2,aCampSx3[nX,2],"X3_PROPRI")) == "U"
						lAdd := .F.
					EndIf
					If lAdd
						Aadd(vCAMPOSX3,aCampSx3[nX,2])
					EndIf
				Endif
			Endif
		Next nX
	EndIf

	RestArea(aArea)

Return vCAMPOSX3

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCALENDAH
Transforma os dados binarios referente calendario do SH7 para o formato hora (hh:mm)

@return aReturn - 	Matriz com os Horarios do Calendario
[DIA,1]    - Horas disponiveis
[DIA,2,{}] - Horarios disponiveis

@param cCalend    , Caracter, Codigo do Calendario ( Obrigatorio )
@param [cFil]     , Caracter, Codigo da Filial ( Opcional )
@param [nValueInt], Numérico, Intervalo do calendário( MV_PRECISA ).

@sample
NGCALENDAH( "001" )

@author In cio Luiz Kolling; Refeito por: Jackson Machado
@since 09/02/2004; Revisão: 05/03/2013
/*/
//---------------------------------------------------------------------
Function NGCALENDAH(cCalend,cFil, nValueInt )

	//Variaveis de For
	Local nX, nY, nDias

	//Variaveis de Contador de HORAS
	Local nPos1C, nPos2C//Receberao os valores iniciais e finais, respectivamente, do valor binario positivo ( 1 ou 'x' )
	Local cHoraFca, cHoraIca//Receberao, respectivamente, os valores iniciais e finais de horas do periodo
	Local nTotHora		:= 0//Recebera o total de horas disponiveis do dia

	//Variaveis utilizadas na conversao binaria
	Local cBinSH7 //Recebe o valor binario contido no campo H7_ALOC
	Local nTamDia 		:= 0 // Indica o valor de 'corte' da string binaria (Retirado da Funcao A780Arrays no MATA780)
	Local nInicio 		:= 1 // Indica o inicio do valor binario a ser 'cortado'

	//Variaveis de backup de ambiente
	Local cFilSH7 		:= NGTROCAFILI( "SH7" , cFil )//Verifica a filial da SH7
	Local aArea         := GetArea()
	Local aAreaSH7      := SH7->( GetArea() )

	//Arrays de Controle de Horas
	Local aDispBin 		:= {}//Array que ira receber as disponibilidades em valor binario
	Local aReturn 		:= {}//Array contendo o retorno final
	Local aHorasDisp 	:= {}//Array temporario que ira receber os intervalos de horas

	Default nValueInt := SuperGetMv( 'MV_PRECISA', .F., 4 ) // Parametro de Intervalo do Calendario

	nTamDia := 1440 / ( 60 / nValueInt )//Indica o valor de 'corte' da string binaria (Retirado da Funcao A780Arrays no MATA780)

	//Verifica se o calenderio exite na SH7
	dbSelectArea( "SH7" )
	If dbSeek( cFilSH7 + cCalend )

		cBinSH7 :=  SH7->H7_ALOC
		cBinSH7 := 	Upper(cBinSH7)

		aAdd( aDispBin, "" ) //Adiciona primeira posicao que sera utilizada posteriomente

		For nDias := 1 to 7//Percorre todos os dias da semana, fazendo o 'corte' na string binaria de acordo com o tamanho correto
			aAdd( aDispBin , SubStr( cBinSH7 , nInicio , nTamDia ) )//Adiciona o dia no array
			nInicio += nTamDia//Incrementa o contador de 'corte'
		Next nDias

		// Salva o valor de 'Domingo' na primera posicao criada, vazia anteriomente, pois o retorno da string binaria eh de segunda - domingo
		// e os valores utilizados sao de domingo - sabado
		aDispBin[ 1 ] := aDispBin[ 8 ]

		//Deleta a ultima posicao do array que corresponde a 'domingo'
		aDel( aDispBin , 8 )
		aSize( aDispBin , 7 )

		For nX := 1 to Len( aDispBin )//Percorre todo o array binario
			Store 0 To nPos1C , nPos2C , nTotHora//A cada dia, zera o total de horas e as posicoes de 'corte'
			aHorasDisp := {}//Zera o array de horas disponiveis do periodo
			For nY := 1 to Len( aDispBin[ nX ] )//Percorre todas as posicoes da string
				If SubStr( aDispBin[ nX ] , nY , 1 ) == "X" .and. nPos1C = 0//Verifica se esta posicao esta 'ativa' e salva como primeira posicao
					nPos1C := nY
				ElseIf SubStr( aDispBin[ nX ] , nY , 1 ) == " " .And. nPos1C <> 0//Verifica se a posicao esta inativa e primeira posicao nao esta vazia
					nPos2C		:= nY//Salva a posicao atual
					//-----------------------------------------------------------------------------------------------//
					// Funcao BitToTime: Retorna o número de horas correspondente aos bits passados( nBits ). O retorno é tipo caracter no formato HHHH:MM. //
					// Exemplo: Se MV_PRECISA estiver configurado para intervalo de 15 min, passando o bit 00, ela retornará '0000:00', já passando o bit   //
					// 01, ela retornará '0000:15'. Porem caso MV_PRECISA estiver configurado para intervalo de 5 min, passando o bit 00, ela retornará     //
					// '0000:00', já passando o bit 01, ela retornará '0000:05'. Ou seja, a conversão se dará de acordo com o intervalo configurado no      //
					// parametro MV_PRECISA.                                                                                                                //
					//-----------------------------------------------------------------------------------------------//
					cHoraIca	:= BitToTime( nPos1C - 1 ,,nValueInt) //Verifica a hora inicial de acordo com a conversao de bit para tempo
					cHoraFca	:= BitToTime( nPos2C - 1 ,,nValueInt) //Verifica a hora final de acordo com a conversao de bit para tempo
					nTotHora	+= HtoM( cHoraFca ) - HtoM( cHoraIca )//Salva a quantidade de horas de acordo com a diferenca de final - inicial
					nPos1C		:= 0//Zera a primeira posicao para retomar as condicoes
					nPos2C		:= 0//Zera a segunda posicao para retomar as condicoes
					aAdd( aHorasDisp , { cHoraIca , cHoraFca } )//Salva o periodo de disponibilidade
				ElseIf nY == Len( aDispBin[ nX ] ) .And. nPos1C <> 0 .And. nPos2C == 0
					//Verifica se eh a ultima posicao a ser considerada e primeira posicao nao esta vazia, caso nao tenha salvo, salva
					nPos2C		:= nY//Salva a posicao atual
					cHoraIca	:= BitToTime( nPos1C - 1 ,,nValueInt)//Verifica a hora inicial de acordo com a conversao de bit para tempo
					cHoraFca	:= BitToTime( nPos2C ,,nValueInt)//Verifica a hora final de acordo com a conversao de bit para tempo
					nTotHora	+= HtoM( cHoraFca ) - HtoM( cHoraIca )//Salva a quantidade de horas de acordo com a diferenca de final - inicial
					nPos1C		:= 0//Zera a primeira posicao para retomar as condicoes
					nPos2C		:= 0//Zera a segunda posicao para retomar as condicoes
					aAdd( aHorasDisp , { cHoraIca , cHoraFca } )//Salva o periodo de disponibilidade
				Endif
			Next nY
			//A cada dia, salva uma nova posicao no array de retorno com as horas totais e os periodos de disponibilidade
			aAdd( aReturn , { MtoH( nTotHora ) , aHorasDisp } )
		Next nX

	EndIf

	RestArea( aAreaSH7 )
	RestArea( aArea )

Return aReturn
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³NGCHKCALEN ³ Autor ³In cio Luiz Kolling   ³ Data ³09/02/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Consistencia do calendario  (ESPECIFICO)                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cVCODIGO - Codigo de relacionamento (Ex. tl_codigo)  -Obrig.³±±
±±³          ³nVTAM    - Tamanho da subtracao     (Ex. tl_codigo,1,6) II  ³±±
±±³          ³cVALIAS  - Arquivo de busca         (Ex. ST1)           II  ³±±
±±³          ³cVCAMP   - Campo da busca           (Ex. T1_TURNO)      II  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
/*/
Function NGCHKCALEN(cVCODIGO,nVTAM,cVALIAS,cVCAMP)
	Local cMENSAL := Space(10)
	Local aArea   := FwGetArea()
	Local c1LI    := chr(13)+chr(10)

	cCODCAL := NGSEEK(cVALIAS,Substr(cVCODIGO,1,nVTAM),1,cVCAMP)
	If cCODCAL <> NIL .And. !Empty(cCODCAL)
		DbSelectArea("SH7")
		DbSetorder(1)
		If !DbSeek(xFilial("SH7")+cCODCAL)
			cMENSAL := STR0077+Alltrim(cCODCAL)+STR0078+c1LI;
			+STR0079+c1LI+STR0080
		Endif
	Endif

	If !Empty(cMENSAL)
		Msginfo(cMENSAL,STR0053)
	Endif

	FwRestArea( aArea )

	FwFreeArray( aArea )

Return If(Empty(cMENSAL),.T.,.F.)

//---------------------------------------------------------------------
/*/{Protheus.doc} NGVALHRCALE
Consistência de hora do calendário

@param cVCALEND, string, calendário do funcionário
@param dVDATA, date, data para validação
@param cVHORA, string, hora para validação
@param cVTIPO, string, indica Tipo de hora (I/F -Inicio/fim)
@param lRetBool, boolean, indica se deve retornar um boolean
@return boolean ou string, string com erro

@author Inácio Luiz Kolling 
@since 10/02/2004
/*/
//---------------------------------------------------------------------
Function NGVALHRCALE( cVCALEND, dVDATA, cVHORA, cVTIPO, lMESAG, lRetBool )

	Local nlo     := 0
	Local c1LI    := chr(13)+chr(10)
	Local cMENSAC := Space(10)
	Local aCALEND := NGCALENDAH(cVCALEND)
	Local nDIASEM := DOW(dVDATA)
	Local lMES    := If(lMESAG <> Nil,lMESAG,.T.)

	Default lRetBool := .T.

	If aCALEND[nDIASEM,1] = "00:00"
		cMENSAC := STR0081+" ( "+Alltrim(DIAEXTENSO(dVDATA))+" )"+c1LI;
		+STR0082+" "+Alltrim(cVCALEND)+" - "+sh7->h7_descri
	Else
		lFORAH := .F.
		For nlo := 1 To Len(aCALEND[nDIASEM,2])
			If cVTIPO = "I"
				If cVHORA >= aCALEND[nDIASEM,2,nlo,1] .And. cVHORA < aCALEND[nDIASEM,2,nlo,2]
					lFORAH := .T.
					Exit
				Endif
			Else
				// Horario fim o insumo deve estar entre o horario inicio do calendário
				If cVHORA >= aCALEND[nDIASEM,2,nlo,1] .And. cVHORA <= aCALEND[nDIASEM,2,nlo,2]
					lFORAH := .T.
					Exit
				Endif
			Endif
		Next nlo
		If !lFORAH
			cMENSAC := STR0083+" "+Dtoc(dVDATA)+c1LI+STR0084+c1LI
			nlo := 0
			For nlo := 1 To Len(aCALEND[nDIASEM,2])
				cMENSAC := cMENSAC+aCALEND[nDIASEM,2,nlo,1]+" "+STR0085+" "+ aCALEND[nDIASEM,2,nlo,2]+c1LI
			Next nlo
		Endif
	Endif

	If !Empty(cMENSAC) .And. lMES
		MsgInfo(cMENSAC,STR0053)
	Endif

	If !lRetBool
		Return cMENSAC
	EndIf

Return If(Empty(cMENSAC),.T.,.F.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NGLocComp ³ Autor ³ Felipe Nathan Welter  ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Funcao recursiva que retorna a localizacao completa de um  ³±±
±±³          ³ componente da estrutura organizacional em forma de texto   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 1. cCod - Codigo do item a pesquisar                       ³±±
±±³          ³ 2. cIndCon - Indicador de Conteudo (1=Bem,2=Localizacao)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SIGAMNT                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGLocComp(cCod,cIndCon,cModulo)
	Local cNiv := '', cNomNiv := '', cRet := ''
	Local aArea := GetArea()
	Default cModulo := "MNT"

	//Identifica o codigo do nivel
	If cIndCon == '1'
		dbSelectArea("TAF")
		dbSetOrder(06)
		If dbSeek(xFilial("TAF")+"X"+cIndCon+cCod)
			cNiv := TAF->TAF_CODNIV
		EndIf
	ElseIf cIndCon == '2' .Or. cIndCon == '3' .or. cIndCon == '4' .or. cIndCon == '7'
		cNiv:= cCod
	EndIf

	If Empty(cNiv)
		cRet := AllTrim(cCod)
	Else
		//Encontra descricao e chama recursivamente nivel superior
		If cModulo == "MNT"
			dbSelectArea("TAF")
			dbSetOrder(07)
			If dbSeek(xFilial("TAF")+"X"+cIndCon+cNiv)
				cNomNiv := TAF->TAF_NOMNIV
				If !( TAF->TAF_NIVSUP == '000' )
					cRet := NGLocComp(TAF->TAF_NIVSUP,'2',cModulo) + " > "
				EndIf
				cRet += AllTrim(If(cIndCon == '1', NGSEEK('ST9',cCod,1,'T9_NOME'), cNomNiv))
			EndIf
		Else
			dbSelectArea("TAF")
			dbSetOrder(08)
			If dbSeek(xFilial("TAF")+cNiv)
				cNomNiv := TAF->TAF_NOMNIV
				If TAF->TAF_NIVSUP <> '000'
					cRet := NGLocComp(TAF->TAF_NIVSUP,'2',cModulo) + " > "
				EndIf
				cRet += AllTrim(If(cIndCon == '1', NGSEEK('ST9',cCod,1,'T9_NOME'), cNomNiv))
			EndIf
		Endif
	EndIf

	RestArea(aArea)

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} NGCALEHDIS
Quantidade de horas disponiveis em um periodo de datas com relacao
ao calendario. (SH7)

@author  Inacio Luiz Kolling
@since   10/05/2004
@version P11/P12

@param   cCALEDIS   , Codigo do Calendario
@param   dDATAIN    , Data    , Data inicio
@param   dDATAFI    , Data    , Data fim
@param   cTIPOHO    , Caracter, Tipo de hora (Num‚rico/Caracter)
@param   [nValueInt], Numérico, Intervalo do calendário( MV_PRECISA ).
@param   [cUniData] , Caracter, Tipo de unidade da quantidade quando for
								informado um insumo que utiliza tipo de
								unidade e hora.( MV_NGUNIDT )
@return  Numérico, Quantidade de horas disponiveis
/*/
//-------------------------------------------------------------------
Function NGCALEHDIS(cCALEDIS,dDATAIN,dDATAFI,cTIPOHO, nValueInt, cUniData )

	Local nD
	Local aARRAYDI := {}
	Local cHORTIPO := If(cTIPOHO = NIL,"C",cTIPOHO)
	Local dDATPRIN := dDATAIN,nVEZES := dDATAFI-dDATAIN

	Private nQUANTDI := 0.00

	Default nValueInt := SuperGetMv( 'MV_PRECISA', .F., 4 ) // Parametro de Intervalo do Calendario
	Default cUniData  := SuperGetMv( 'MV_NGUNIDT', .F., 'S' )

	aARRAYDI := NGCALENDAH( cCALEDIS, , nValueInt )

	If Len(aARRAYDI) = 0
		Return If(cHORTIPO = "C","00.00",nQUANTDI)
	Endif
	For nD := 1 To nVEZES+1
		cHORADIA := aARRAYDI[Dow(dDATPRIN),1]
		nPOSHORA := At(":",cHORADIA)
		cHORADIS := Alltrim(Substr(cHORADIA,1,nPOSHORA-1))
		cMINUDIS := Alltrim(Substr(cHORADIA,nPOSHORA+1,2))
		nHORADIS := Val(cHORADIS+"."+cMINUDIS)
		NGSOMAHORAS(nHORADIS,"S","nQUANTDI", cUniData )
		dDATPRIN := dDATPRIN + 1
	Next
	If cHORTIPO = "C"
		cHORASDIS := Alltrim(Str(nQUANTDI,10,2))
		nPOSHORAC := At(".",cHORASDIS)
		cHORADISC := Alltrim(Substr(cHORASDIS,1,nPOSHORAC-1))
		cMINUDISC := Alltrim(Substr(cHORASDIS,nPOSHORAC+1,2))
		cHORADISF := cHORADISC+":"+cMINUDISC
	Endif

Return If(cHORTIPO = "C",cHORADISF,nQUANTDI)

//-------------------------------------------------------------------
/*/{Protheus.doc} NGSX2NOME
Busca a descricao do arquivo/tabela

@type   Function

@author Inacio Luiz Kolling
@since  10/05/2004

@Param  cTabela, Caracter, Nome da tabela a ser pesquisado a descrição

@return Caracter, Descricao do arquivo/tabela
/*/
//-------------------------------------------------------------------
Function NGSX2NOME( cTabela )

	Local aArea    := GetArea()
	Local cDescTab := Alltrim( FwX2Nome( cTabela ) )
	RestArea( aArea )

Return cDescTab

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGDIASMES ³Autor  ³Inacio Luiz Kolling    ³ Data ³25/06/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna a quantidade de dias do mes                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³nVMES - Mes                                 - Obrigatorio   ³±±
±±³          ³nVANO - Ano                                 - Obrigatorio   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGDIASMES(nVMES,nVANO)
	Local aVETDM := {31,28,31,30,31,30,31,31,30,31,30,31}
Return If(nVMES <> 2,aVETDM[nVMES],If(nVANO % 4 = 0,29,aVETDM[nVMES]))

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCRIATRB
Criação de arquivos temporários.

@author Inacio Luiz Kolling
@param aField  - Matriz com as definicoes dos campos	-Nao Obrig.
@param aIndex  - Vetor com as definicoes dos indices	-Obrigatorio
@param cTrb    - Alias do arquivo temporario         	-Obrigatorio
@param cAlias  - Alias do arquivo replica            	-Nao Obrig.
@param cDrive  - Formato do drive utilizado            -Nao Obrig.
@since 04/10/2005
@return cArqTrb Nome do arquivo gerado pela CriaTrab

@Obs Uns dos parametros (aField ou cAlias) sera Obrigatorio.
@deprecated FUNÇÃO MANTIDA PARA COMPATIBILIDADE COM ROTINAS ESPECÍFICAS.
			NÃO UTILIZAR ESTA FUNÇÃO, UTILIZE DIRETAMENTE A FUNÇÃO NGFWTMPTBL.
/*/
//---------------------------------------------------------------------
Function NGCRIATRB(aField,aIndex,cTrb,cAlias,cDrive)

	Local nX
	Local aIdx := {}
	Local oTrb

	For nX := 1 To Len(aField)

		aAdd(aField[nX], 0)

	Next nX

	For nX := 1 To Len(aIndex)

		aIndex[nX] := StrTran(Upper(aIndex[nX]), "DTOS")
		aIndex[nX] := StrTran(Upper(aIndex[nX]), "DTOC")
		aIndex[nX] := StrTran(Upper(aIndex[nX]), "CTOD")
		aIndex[nX] := StrTran(Upper(aIndex[nX]), "STOD")
		aIndex[nX] := StrTran(aIndex[nX], "(")
		aIndex[nX] := StrTran(aIndex[nX], ")")

		aAdd(aIdx, StrTokArr(aIndex[nX], "+"))

	Next nX

	oTrb := NGFwTmpTbl(cTrb,aField,aIdx,cAlias)

Return oTrb

//---------------------------------------------------------------------
/*/{Protheus.doc} NGDELETRB
Delecao de arquivos temporarios.

@author Inacio Luiz Kolling
@param cTrb  - Alias do arquivo temporario         -Obrigatorio
@param cArqTrb  - Nome do arquivo temporario          -Obrigatorio
@since 04/10/2005
@return cArq Nome do arquivo gerado pela CriaTrab
@deprecated.: FUNÇÃO DESCONTINUADA.
/*/
//---------------------------------------------------------------------
Function NGDELETRB(cTrb,cArqTrb)

	If ValType(cArqTrb) == "O"
		cArqTrb:Delete()
	EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³NGTEMACENTO ³ Autor ³Inacio Luiz Kolling    ³ Data ³06/09/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Consistencia de acento em uma string                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cString - Conte£do da string                    - Obrigatorio ³±±
±±³          ³lMostT  - Indica se a saia for via tela         - Nao Obrigat.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³.T.,.F. para lMostT = .T. Senao                               ³±±
±±³          ³vVetTem Onde [1] = .T.,.F. [2] = Mensagem                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGTEMACENTO(cString,lMostT)
	Local i,cCaract,cTexSt := Alltrim(cString),nPosAc := 0
	Local cAcentos := "ÁÂÀÄÅÃáâàäåãÇçÉÊËÈéêëèÍÎÏÌíîïìÖÓÔÒÕöóôòõÜÚÛÙüúûùİı"
	Local cMensag  := Space(1), lTela := If(lMostT = Nil,.T.,lMostT)
	Local lRetTem  := .T.,vVetTem := {.T.,Space(25)}

	For i := 1 To Len(cTexSt)
		cCaract := Space(1)
		cCaract := Substr(cTexSt,i,1)
		nPosAc := AT(cCaract,cAcentos)
		If nPosAc > 0
			cMensag := STR0140
			Exit
		Endif
	Next i
	If lTela
		If !Empty(cMensag)
			MsgInfo(cMensag,STR0053)
			lRetTem := .F.
		Endif
	Else
		vVetTem := {.F.,cMensag}
	Endif
Return If(lTela,lRetTem,vVetTem)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MGSOMAMES ³ Autor ³ Andre E. Perez Alvarez³ Data ³30/11/06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula a nova data somando a quantidade de meses informada ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ dData = Data  -Obrigatorio                                 ³±±
±±³          ³ nQtMes = Quantidade de meses a serem somados -Obrigatorio  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ dData                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSomaMes(dData, nQtMes)
	Local nDia := Day(dData)
	Local nMesIni := Month(dData)
	Local nMesNew := nMesIni + nQtMes
	Private nAno := Year(dData)

	Default nQtMes := 0

	If Empty(nQtMes)
		Return dData
	Endif

	nDIA := Strzero(nDIA,2)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Calcula o novo mes e ano da data, de acordo ³
	//³com a  quantidade de meses a ser somada.    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nQtMes > 0
		While nMesNew > 12
			nMesNew := nMesNew - 12
			nAno := nAno + 1
		End
	Else
		While nMesNew <= 0
			nMesNew := nMesNew + 12
			nAno    := nAno - 1
		End
	Endif
	nMesIni := nMesNew

	nAno := Alltrim( Strzero(nANO,4) )
	nMesIni := Strzero(nMesIni,2)
	dData := CtoD(nDia + '/' + nMesIni + '/' + nAno)

	While Empty(dData)
		nDia := Val(nDia) - 1
		nDia := Strzero(nDia,2)
		dData := CtoD(nDia + '/' + nMesIni + '/' + nAno)
	End

Return dData

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGSomaAno ³ Autor ³ Andre E. Perez Alvarez³ Data ³30/11/06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula a nova data somando a quantidade de anos informada  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ dData = Data  -Obrigatorio                                 ³±±
±±³          ³ nQtAno = Quantidade de anos a serem somados -Obrigatorio   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ dData                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSomaAno(dData, nQtAno)
	Local nDia := Day(dData)
	Local nMes := Month(dData)
	Local nAno := Year(dData)
	Local nAnoNew := nAno + nQtAno

	nDIA := Strzero(nDIA,2)
	nMes := Strzero(nMes,2)
	nAnoNew := Alltrim( Strzero(nAnoNew,4) )

	dData := CtoD(nDia + '/' + nMes + '/' + nAnoNew)

	While Empty(dData)
		nDia := Val(nDia) - 1
		nDia := Strzero(nDia,2)
		dData := CtoD(nDia + '/' + nMes + '/' + nAnoNew)
	End

Return dData
//-------------------------------------------------------------------
/*/{Protheus.doc} NGRETPARSX6
Posiciona em um determidado registro de parametro do sx6

@author  Inacio Luiz Kolling
@since   08/12/2006

@param cVPar, Caracer, Codigo do parametro
@param [cVCond], Caracer, Condicao de comparacao
@param [cFilAc], Caracer, Codigo da Filial
@param [cEmpAc], Caracer, Codigo da Empresa

@sample NGRETPARSX6('MV_NGSECON')       - Retorna o valor
@sample NGRETPARSX6('MV_NGSECON','002') - Retorna .T.,.F.

@Obs Na incerteza da existencia do parametro ou das variaveis
testar o retorno da fun‡ao se for igual a Nil. Exemplo:
cRET := NGRETPARSX6('MV_XXXXXXX')
If cRET = Nil  Nao achou o parametro ou os tipos das variaveis sao diferentes.

@Obs Está função foi descontinuada e poderá ser retirada na próxima
versão.

/*/
//-------------------------------------------------------------------
Function NGRETPARSX6(cVPar,cVCond,cFilAc,cEmpAc)
Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGSEEKDIC  ³ Autor ³ Inacio Luiz Kolling  ³ Data ³20/12/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Posiciona em um determinado registro do dicionario e retorna³±±
±±³          ³a informacao solicitada                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias - Alias do arquivo                     - Obrigatorio ³±±
±±³          ³cChave - Chave de acesso                      - Obrigatorio ³±±
±±³          ³nOrdem - Ordem de acesso                      - Obrigatorio ³±±
±±³          ³cFielR - Campo de retorno (Conteudo)          - Obrigatorio ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Exemplo de³cTitut := NGSEEKDIC("SX3","T1_CODFUNC",2,"X3_TITULO")       ³±±
±±³Chamadas  ³nTam   := NGSEEKDIC("SX3","T9_POSCONT",2,"X3_TAMANHO")      ³±±
±±³          ³nInd   := NGSEEKDIC("SIX","STJA",1,"CHAVE")                 ³±±
±±³          ³          .....                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Na incerteza testar o retorno da fun‡ao.  Exemplo:          ³±±
±±³          ³                                                            ³±±
±±³          ³cTitut := NGSEEKDIC("SX3","T1_CODFUNC",2,"X3_TITULO")       ³±±
±±³          ³                                                            ³±±
±±³          ³If Empty(cTitut) .. Nao achou                               ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³cRet   - Conteudo do campo do dicionario                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSEEKDIC(cAlias,cChave,nOrdem,cFielR)
	Local aAreaTemF := GetArea(), cRet := " "

	dbSelectArea(cAlias)
	dbSetOrder(nOrdem)
	If dbSeek(cChave)
		cRet := &cFielR.
	Endif
	RestArea(aAreaTemF)
Return cRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCADICBASE³ Autor ³ Inacio Luiz Kolling  ³ Data ³20/12/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se existe um determinado campo no dicionario (SX3) ³±±
±±³          ³ou na base dados ou em ambos                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cCampP - Campo a ser pesqusado                - Obrigatorio ³±±
±±³          ³cTipoP - Indica o tipo de pesquisa (D,B,A)    - Obrigatorio ³±±
±±³          ³cAlias - Alias do arquivo                     - Obrigatorio ³±±
±±³          ³                                                P/ cTipoP = ³±±
±±³          ³                                                 D,A        ³±±
±±³          ³lTelaS - Indica se a saida for na tela        - Nao Obrigat.³±±
±±³          ³cEmpresa - Dicionario da empresa a verificar  - Nao Obrigat.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Exemplo de³        NGCADICBASE('TL_CODIGO','D',,.T.)                   ³±±
±±³Chamadas  ³        NGCADICBASE('TL_CODIGO','B','STL',.T.)              ³±±
±±³          ³        NGCADICBASE('TL_CODIGO','A','STL',.T.)              ³±±
±±³          ³vRet := NGCADICBASE('TL_CODIGO','A','STL',,SM0->M0_CODIGO)  ³±±
±±³          ³          .....                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³.T.,.F. Se for informado lTelaS                             ³±±
±±³          ³vRetPesq Onde: vRetPesq[1] = .T.,.F. vRetPesq[2] = Mensagem ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCADICBASE(cCampP,cTipoP,cAlias,lTelaS,cEmpresa)

	Local aAreaTemF := GetArea()
	Local vRetPesq  := {.T.,Space(1)}

	If cTipoP $ "DA"
		If Empty(NGSEEKDIC("SX2",cAlias,1,"X2_NOME"))
			vRetPesq := {.F.,STR0149+" "+cAlias+" "+STR0148+" (SX2)"}
		ElseIf Empty(NGSEEKDIC("SIX",cAlias,1,"INDICE"))
			vRetPesq := {.F.,STR0149+" "+cAlias+" "+STR0148+" (SIX)"}
		ElseIf Empty(NGSEEKDIC("SX3",cCampP,2,"X3_TITULO"))
			vRetPesq := {.F.,STR0147+" "+cCampP+" "+STR0148+" (SX3)"}
		Endif
	Endif

	If vRetPesq[1] .And. cTipoP $ "BA"
		If Empty(NGSEEKDIC("SX2",cAlias,1,"X2_NOME"))
			vRetPesq := {.F.,STR0149+" "+cAlias+" "+STR0148+" (SX2)"}
		Endif
		If vRetPesq[1]
			dbSelectArea(cAlias)
			If FieldPos(cCampP) = 0
				vRetPesq := {.F.,STR0147+" "+cCampP+" "+STR0150+" ("+cAlias+")"}
			Endif
		Endif
	Endif

	If lTelaS <> Nil
		If lTelaS
			If !vRetPesq[1]
				MsgInfo(vRetPesq[2],STR0053)
			Endif
		Endif
		RestArea(aAreaTemF)
		Return vRetPesq[1]
	Endif

	RestArea(aAreaTemF)
Return vRetPesq

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGSEEKSM0  ³ Autor ³ Inacio Luiz Kolling  ³ Data ³20/12/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Posiciona em um determinado registro do SIGAMAT e retorna   ³±±
±±³          ³a informacao solicitada                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cChave - Chave de acesso                      - Obrigatorio ³±±
±±³          ³vVetCa - Vetor com o(s) campo(s) de retorno   - Obrigatorio ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Exemplo de³vReto := NGSEEKSM0(cChave,{"M0_NOME","M0_CIDENT"})          ³±±
±±³Chamadas  ³vReto := NGSEEKSM0(cChave,{"M0_ESTENT"})                    ³±±
±±³          ³          .....                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Na incerteza testar o retorno da fun‡ao.  Exemplo:          ³±±
±±³          ³                                                            ³±±
±±³          ³vReto := NGSEEKSM0(cChave,{"M0_NOME","M0_CIDENT"})          ³±±
±±³          ³                                                            ³±±
±±³          ³If Empty(vReto) .. Nao achou                                ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³vReto - Vetor com o(s) conteudo(s) solicitado(s)            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSEEKSM0(cChave,vVetCa)
	Local aAreaTemF := GetArea(), vReto := {},nRecSM0 := 0, nSM0 := 0

	dbSelectArea("SM0")
	nRecSM0 := Recno()
	If dbSeek(cChave)
		For nSM0 := 1 To Len(vVetCa)
			Aadd(vReto,&("SM0->"+vVetCa[nSM0]))
		Next
	Endif
	dbgoto(nRecSM0)
	RestArea(aAreaTemF)
Return vReto
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGMontaAcols³ Autor ³ Rafael Diogo Richter  ³ Data ³08/01/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao para montagem do aCols.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         Atualizacoes Sofridas Desde a Construcao Inicial.               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ F.O  ³  Motivo da Alteracao                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³            ³        ³      ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGMontaAcols(cAlias,cKey,cWhile,cFilif,nIndex)
	Local i,cOld := Alias(),xx,nv:=1

	dbSelectArea(cAlias)
	If ValType(nIndex) == "N"
		dbSetOrder(nIndex)
	EndIf
	dbSeek(xFilial(cAlias)+cKey)
	While !Eof() .And. &cWhile.
		If cFilif = NIL
			Aadd(aCols,{})
			For i := 1 TO Len(aHeader)-2
				If aHeader[i][10] == "V"
					Aadd(aCols[nv],CriaVar(AllTrim(aHeader[i][2])))
				Else
					xx := aHeader[i][2]
					Aadd(aCols[nv], &xx.)
				Endif
			Next
			Aadd(aCols[nv],cAlias)
			Aadd(aCols[nv],(cAlias)->(Recno()))
			Aadd(aCols[nv],.F.)
			nv++
		Else
			If &cFilif.
				Aadd(aCols, {})
				For i := 1 TO Len(aHeader)-2
					If aHeader[i][10] == "V"
						Aadd(aCols[nv],CriaVar(AllTrim(aHeader[i][2])))
					Else
						xx := aHeader[i][2]
						Aadd(aCols[nv], &xx.)
					Endif
				Next
				Aadd(aCols[nv],cAlias)
				Aadd(aCols[nv],(cAlias)->(Recno()))
				Aadd(aCols[nv],.F.)
				nv++
			Endif
		Endif
		dbSelectArea(cAlias)
		dbSkip()
	End
	dbSelectArea(cOLD)

Return .T.


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGWALKTHRU ³ Autor ³Elisangela Costa      ³ Data ³23/03/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida a variavel de controle do WalkThru                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³lWalkThru - Variavel de controle do WalkThu   - Obrigatorio ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGWALKTHRU(lWalkThru)

	Local lWalk := .T.

	If lWalkThru = Nil
		lWalk := .T.
	Else
		If VALTYPE(lWalkThru) == "L"
			lWalk := lWalkThru
		Else
			lWalk := .T.
		End
	EndIf

Return lWalk

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGTROCAFILI³ Autor ³Inacio Luiz Kolling   ³ Data ³18/05/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Troca de filial                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cVAlias - Alias do arquivo                    - Obrigatorio ³±±
±±³          ³cFilPTr - Codigo da filial                    - Nao Obrigat.³±±
±±³          ³cEmpPTr - Codigo da empresa                   - Nao Obrigat.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³OBSERVACAO³Funcao funcional.                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
----Se passar:
*cVAlias -> retorna FILIAL corrente da EMPRESA corrente
*cVAlias,cFilPTr -> retorna FILIAL cFilPTr da EMPRESA corrente (ou "  " se for Compartilhada)
*cVAlias,cFilPTr,cEmpPTr -> retorna FILIAL cFilPTr da EMPRESA cEmpPTr (ou "  " se for Compartilhada)
*cVAlias,cEmpPTr -> retorna primeira FILIAL da EMPRESA cEmpPTr
----Exemplo de Uso:
*Logado na 99/10
NGTROCAFILI("ST9") - retorna 10
NGTROCAFILI("ST9","03") - retorna 03
NGTROCAFILI("ST9","09","02") - retorna 09
NGTROCAFILI("ST9","02","99") - retorna 02
NGTROCAFILI("ST9",,"02") - retorna 01
/*/

Function NGTROCAFILI(cVAlias,cFilPTr,cEmpPTr)
	Local nPos
	Local cRetFil := ""
	Local cModoEmp := "", cModoUn := "", cModoFil := ""
	Local aSM0 := FwLoadSM0()
	Local aArea := GetArea()
	Default cEmpPTr := ""

	If !Empty(cEmpPTr) .and. cEmpPTr <> FWGrpCompany() .and. !Empty(cFilPtr)
		nPos := aScan(aSM0, {|x| x[1]+x[2] == cEmpPTr+cFilPTr})
		If nPos > 0
			cModoEmp := NGSX2MODO(cVAlias,cEmpPTr,1)
			cModoUn  := NGSX2MODO(cVAlias,cEmpPTr,2)
			cModoFil := NGSX2MODO(cVAlias,cEmpPTr,3)
			If !Empty(aSM0[nPos][3])
				If cModoEmp == "E"
					cRetFil += aSM0[nPos][3]
				Else
					cRetFil += Space(Len(aSM0[nPos][3]))
				Endif
			Endif
			If !Empty(aSM0[nPos][4])
				If cModoUn == "E"
					cRetFil += aSM0[nPos][4]
				Else
					cRetFil += Space(Len(aSM0[nPos][4]))
				Endif
			Endif
			If !Empty(aSM0[nPos][5])
				If cModoFil == "E"
					cRetFil += aSM0[nPos][5]
				Else
					cRetFil += Space(Len(aSM0[nPos][5]))
				Endif
			Endif
			cRetFil := Padr(cRetFil, aSM0[nPos][8])
		Endif
	EndIf

	If Empty(cRetFil) .and. Len(cRetFil) == 0
		If !Empty(cFilPTr)
			cRetFil := xFilial(cVAlias,cFilPTr)
		Else
			cRetFil := xFilial(cVAlias)
		Endif
	EndIf

	RestArea(aArea)

Return cRetFil


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿±±
±±³Funcao    ³NGPESQTRB   ³ Autor³Inacio Luiz Kolling ³ Data ³07/11/2007³09:00³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄ´±±
±±³Descricao ³Pesquisa em um arquivo Temporario                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlTRB - Alias do arquivo/tabela                  - Obrigatorio ³±±
±±³          ³vOpcao - Vetor com o nome dos campos de indice(s) - Obrigatorio ³±±
±±³          ³nMaxt  - Tamanho da maior chave do(s) indice(s)   - Obrigatorio ³±±
±±³          ³cTitJa - Titulo da janela de pesquisa             - Nao Obrigat.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Chamadas  ³NGPESQTRB(cAlTRB,vOpcao,nMaxT,cTitJa)                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGPESQTRB(cAlTRB,vOpcao,nMaxT,cTitJa)
	Local cChaveP := Space(nMaxT),nMaxTI,nF,nMaxM,nMulT
	Local cTiJ    := If(cTitJa = Nil .Or. Empty(cTitJa),STR0155,cTitJa)
	Local cOpcPes := vOpcao[1]
	Local nPosI   := aSCAN(vOpcao, {|x| Upper(Alltrim(x)) == Upper(Alltrim(cOpcPes))})
	nOpPes := 0

	Store 0 To nMaxTI,nF,nMaxM,nMulT

	For nF := 1 To Len(vOpcao)
		nMaxTI := Max(nMaxTI,Len(vOpcao[nF]))
	Next nF

	nMaxM := If(nMaxTI > 58,nMaxTI,58)
	nMulT := If(nMaxM > 58,3,2.5)

	DEFINE MSDIALOG oDLGP TITLE OemToAnsi(cTiJ) From 10,14 To 20,nMaxM+2  Of oMainWnd
	@ 1.6,01   Say OemToAnsi(STR0155+":")          Size 6  ,7 COLOR CLR_BLUE
	@ 2.4,01   MSComBoBox cOpcPes ITEMS vOpcao     Size nMaxM*nMulT,12 Of oDLGP
	@ 3.4,01   MSGET  cChaveP   Picture '@SnMaxT'  Size 160,7          Of oDLGP
	ACTIVATE MSDIALOG oDLGP Centered ON INIT EnchoiceBar(oDLGP,{||nOpPes := 1,oDLGP:End()},{||nOpPes := 0,oDLGP:End()})
	nPosI := aSCAN(vOpcao,{|x| Upper(Alltrim(x)) == Upper(Alltrim(cOpcPes))})
	If nOpPes = 1
		dbSelectArea(cAlTRB)
		DbSetOrder(nPosI)
		Dbseek(Rtrim(cChaveP),.T.)
		If Eof()
			DbSkip(-1)
		Endif
	Endif
Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGRETSX3BOX³ Autor ³Inacio Luiz Kolling ³ Data ³17/11/2007³22:00³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna o conteudo do SX3 box                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cVCampo - Campo                                   - Obrigatorio ³±±
±±³          ³cVCond  - Condicao de filtro                      - Nao Obrigat.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Chamadas  ³NGRETSX3BOX("T9_FERRAME","F")  - Apenas a condicao              ³±±
±±³          ³NGRETSX3BOX("TF_MFMEAN")       - Todo o conteudo                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³Descricao do Sub-item do SX3 box ou todo o conteudo             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGRETSX3BOX(cVCampo,cVCond)
	Local cConteu := ' ',aAreaAtu := GetArea(),nPosIg
	Local nv := 0,cVCondN,cStrings := ''

	dbselectArea("SX3")
	dbsetOrder(2)
	If dbseek(cVCampo)
		If cVCond = Nil
			cConteu := AllTrim(X3CBox())
		Else
			cConteu := AllTrim(X3CBox())
			cVCondN := cVCond+"="
			nPosIg  := At(cVCondN,cConteu)
			If nPosIg > 0
				For nv := nPosIg To Len(Alltrim(cConteu))
					cCaract := Substr(cConteu,nv,1)
					If cCaract = ';'
						Exit
					Else
						cStrings += cCaract
					Endif
				Next
				If Len(cStrings) > 0
					nPosIg := At("=",cStrings)
					If nPosIg > 0
						cConteu := Substr(cStrings,nPosIg+1,Len(cStrings))
					Endif
				Endif
			Else
				cConteu := ""
			Endif
		Endif
	Endif
	dbselectArea("SX3")
	dbsetOrder(1)
	RestArea(aAreaAtu)
Return cConteu

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿±±
±±³Funcao    ³NGRETORDEM  ³ Autor³Inacio Luiz Kolling ³ Data ³06/12/2007³11:00³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna o numero do indice                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias  - Alias do arquivo/tabela                   -Obrigatorio³±±
±±³          ³cConte  - Conteudo do indice (chave)                -Obrigatorio³±±
±±³          ³lExato  - Indica se a pesquisa e pelo exato ou pelo -Nao Obrig. ³±±
±±³          ³          primeiro parecido                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³nIndRet - Numero do indice - Se nao encontrou retorna 0         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GENERICO                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGRETORDEM(cAliTab,cConte,lExato)
	Local lPosic  := If(lExato = Nil,.T.,lExato)
	Local aAreaId := GetArea(), nIndRet := 0, nIndInc := 0
	Local nIndex  := 0
	Local aIndex  := {}
	Local cIndexAt := ""

	aIndex := NGRETINDTAB( cAliTab )

	If Len( aIndex ) > 0

		For nIndex := 1 To Len( aIndex )

			nIndInc ++

			cIndexAt := aIndex[ nIndex ]

			If lPosic
				If Alltrim( StrTran( Upper( cIndexAt ) ," ", "" ) ) = Alltrim( StrTran( Upper( cConte ), " ", "" ) )
					nIndRet := nIndInc
					Exit
				EndIf
			Else
				If Alltrim( StrTran( Upper( cConte ), " ", "" ) ) $ StrTran( Upper( cIndexAt ), " ", "" )
					nIndRet := nIndInc
					Exit
				Endif
			Endif

		Next nIndex

	EndIf

	RestArea(aAreaId)
Return nIndRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGRETTITULO³ Autor ³Inacio Luiz Kolling ³ Data ³06/12/2007³10:00³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna o conteudo do titulo                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cVCampo - Campo                                   - Obrigatorio ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Chamadas  ³NGRETTITULO("T9_FERRAME")                                       ³±±
±±³          ³cTiT := NGRETTITULO("T9_NOME")                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³cTitLab - Nome do titulo do campo (Se nao achou retorna vazio)  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGRETTITULO(cVCampo)
Return FWX3Titulo( cVCampo )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±±±
±±±±³           INICIO - FUNCOES PARA TRABALHAR COM MULTIEMPRESA            ³±±±±
±±±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ INICIO - OPERACOES COM TABELAS DA BASE DE DADOS                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGPrepTBL ³ Autor ³ Felipe N. Welter      ³ Data ³ 12/03/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Abre/prepara simultaneamente varias Alias de uma empresa    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³1.aTBL - Array com Alias/Ordem a ser aberta                 ³±±
±±³          ³2.cEMP - Empresa                                            ³±±
±±³          ³3.cFIL - Filial (opcional - altera variavel do sistema)     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Exemplo   ³NGPrepTBL({{"STL"},{"STT",01}},SM0->M0_CODIGO)              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³OBSERVACAO³- SEMPRE QUE TERMINAR DE USAR A AREA DESTA FUNCAO,          ³±±
±±³          ³RETORNAR PARA A EMPRESA/FILIAL QUE ESTAVA INICIALMENTE.     ³±±
±±³          ³- ATENCAO PARA O USO DO PARAMETRO cFIL (EVITAR)!            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGPrepTBL( aTBL, cEMP, cFIL )

	Local nPos

	If (cFIL <> NIL) .And. !Empty(cFIL)
		cFilAnt := cFIL
	EndIf

	For nPos := 1 To Len(aTBL)

		cModo := NGSX2MODO(aTBL[nPos][1],cEMP)
		If cModo != NIL
			NGEMPOPEN(aTBL[nPos][1],aTBL[nPos][1],If(Len(aTBL[nPos])==1,01,aTBL[nPos][2]),cEMP,Len(cArqTab),cModo)
		Else
			Final(STR0212+aTBL[nPos][1]+STR0213+cEMP+" (SX2).")//"Erro ao verificar modo da tabela "###" na Empresa "
		EndIf

	Next nPos

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} NGEMPOPEN
Abre arquivo de outra empresa

@author  Vitor Emanuel Batista
@since   30/09/2008
@param   cAlias1   - Alias com o Qual o Arquivo Sera Aberto
@param   cAlias2   - Nome da Alias que sera aberta a tabela
@param   nIndice   - Indice
@param   cEmpresa  - Empresa
@param   nTamTable - Tamanho do cArqTab
@param   cMd       - Modo de Acesso (Compartilhado ou Exclusivo )
@example NGEMPOPEN("ST9","ST9",1,SM0->M0_CODIGO,Len(cArqTab),@cModo)
@example NGEMPOPEN("ST9","ST92",1,'01',Len(cArqTab),@cModo)
/*/
//-------------------------------------------------------------------
Function NGEMPOPEN(cAlias1,cAlias2,nIndice,cEmpresa,nTamTable,cMd)

	Local nAT      := 0
	Local lRet     := .F.
	Local cEmpInfo

	Default nTamTable := Len(cArqTab)
	Default cMd       := NGSX2MODO(cAlias1,cEmpresa)

	dbSelectArea(cAlias1)
	cEmpInfo := DBINFO(DBI_FULLPATH) //DBI_FULLPATH 10
	If cEmpInfo != NGRETX2(cAlias1,cEmpresa,.F.)

		UniqueKey( NIL , cAlias1 , .T. )
		lRet := EmpOpenFile(cAlias2,cAlias1,nIndice,.T.,cEmpresa,@cMd)   // Abre arquivo da empresa selecionada

		nAT := AT(cAlias1,cArqTab)
		IF nAT > 0
			cArqTab := Subs(cArqTab,1,nAT+2)+cMd+Subs(cArqTab,nAT+4)
		EndIF

		cArqTab := Subs(cArqTab,1,nTamTable)
	EndIf

	NGDBAREAORDE(cAlias1,nIndice)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} NGOPENDB
Verifica e cria a tabela da empresa no banco de dados

ATENÇÃO - Função DESCONTINUADA, será mantida sua declaração até o fim da 12.1.17
para evitar erro.log.
Não deverá mais ser utilizada a mesma.

@author Vitor Emanuel Batista
@since  27/03/09
@source Generico
@param  cAlias - Tabela para ser criada
@param  cEmpresa - Empresa proprietaria da tabela
/*/
//-------------------------------------------------------------------
Function NGOPENDB(cAlias,cEmpresa)

	Local lReturn := .F.
/*	Local aArea   := GetArea()
	Local cArqIni := NGRETX2(cAlias,cEmpresa,.F.) //Retorna o X2_ARQUIVO da tabela

	If !MsFile(cArqIni)
		lReturn := .F.
	EndIf

	RestArea(aArea)
*/
Return lReturn

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ FIM - OPERACOES COM TABELAS DA BASE DE DADOS                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ INICIO - OPERACOES COM ARQUIVOS DO DICIONARIO DE DADOS                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//-------------------------------------------------------------------
/*/{Protheus.doc} NGRETX2
Retorna o X2_ARQUIVO da Alias informada

@author  Vitor Emanuel Batista
@since   20/01/2009
@param   cAlias   - Tabela para buscar o X2_ARQUIVO - Obrigatorio
@param   cEmp     - Empresa para abrir o SX2        - Def. cEmpAnt
@param   lOpenTbl - Verifica se a tabela da empresa esta aberta no
                    banco de dados (e cria se necessario)-Def. .T.

@return  cRetorno - pode ser o conteudo de X2_ARQUIVO ou ""
@example NGRETX2("ST9",SM0->M0_CODIGO)
/*/
//-------------------------------------------------------------------
Function NGRETX2(cAlias,cEmp,lOpenTbl)

	Local aArea := GetArea()
	Local cArquivo

	Default lOpenTbl := .T. //Não é mais utilizado, mantido por compatibilidade.
	Default cEmp     := cEmpAnt

	//Retorna o X2_ARQUIVO da Tabela e Empresa informada
	cArquivo := RetFullName(cAlias,cEmp)

	RestArea(aArea)

Return cArquivo
//-------------------------------------------------------------------
/*/{Protheus.doc} NGABRESX
Abre arquivo SX do dicionario de outra empresa, substituindo
o Alias da empresa corrente e permitindo acesso pelo mesmo
"nome". (SX6, SX3, SX2, etc)

@param cArquivo, Caracter, Arquivo SX para abrir
@param [cEmp], Caracter, Empresa

@author  Felipe N. Welter
@since   30/03/2009

@return lReturn, Conseguiu abrir SX ?

@obs Evitar utilizar esta funcao sem EXTREMA necessidade, e sempre
que for necessario fazer nova chamada para retornar os arqui-
vos da empresa corrente. Por exemplo:
  *Situacao: Preciso acessar SX6 da empresa 05, estou na 99.
      NABRESX("SX6","05")
      cFrota := GetNewPar("MV_NGMNTFR")
      NABRESX("SX6","99")

@Obs Está função foi descontinuada e poderá ser retirada na próxima
versão.
/*/
//-------------------------------------------------------------------
Function NGABRESX(cArquivo,cEmp)
Return Nil

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ FIM - OPERACOES COM ARQUIVOS DO DICIONARIO DE DADOS                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ INICIO - FUNCOES GENERICAS                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGArrayEmp³ Autor ³Felipe N. Welter       ³ Data ³ 04/05/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna um array contendo todas as empresas                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³bCondic - Bloco de codigo p/ validar empresas       -Obrigat³±±
±±³          ³aCampos - Campos SM0 para retorno, alem dos default -Opcion.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aRet - Array com M0_CODIGO e M0_NOMECOM + campos par. 2     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGArrayEmp(bCondic,aCampos)

	Local aRet := {}
	Local cSM0Cd := ""
	Local nX := 0
	Default aCampos := {}
	Default bCondic := {|| .T.}

	dbSelectArea("SM0")
	nRecSM0 := SM0->(RecNo())
	dbGoTop()
	While !Eof()
		If cSM0Cd != SM0->M0_CODIGO
			If Eval(bCondic)
				aAdd(aRet,{SM0->M0_CODIGO,SM0->M0_NOMECOM})
				For nX := 1 To Len(aCampos)
					aAdd(aRet[Len(aRet)],SM0->&(aCampos[nX]))
				Next(nX)
				cSM0Cd := SM0->M0_CODIGO
			EndIf
		EndIf
		dbSelectArea("SM0")
		dbSkip()
	EndDo

	dbGoTo(nRecSM0)

Return aRet

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ FIM - FUNCOES GENERICAS                                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±±±
±±±±³            FIM - FUNCOES PARA TRABALHAR COM MULTIEMPRESA              ³±±±±
±±±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

//-------------------------------------------------------------------
/*/{Protheus.doc} NGSX1PROXORD
Proxima ordem da pergunta (SX1)

@author  Inacio Luiz Kolling
@since   18/03/2009
@param   cPergu - Código da pergunta
@return  cProx  - Numeração da próxima ordem
@version P12
@source  Generico
/*/
//-------------------------------------------------------------------
Static Function NGSX1PROXORD(cPergu)

	Local aAreaSX1 := GetArea()
	Local cPergA   := PadR( Alltrim(cPergu), Len(Posicione("SX1", 1, Alltrim(cPergu), "X1_GRUPO")) )
	Local cOrdem   := "01"
	Local cProx    := ""

	If !Empty(Posicione("SX1",1,cPergA,"X1_GRUPO")) //Garante que a pergunta existe

		While !Empty(cOrdem) //Continua procurando pela próxima pergunta, enquanto existir a ordem

			cOrdem  := Posicione("SX1",1,cPergA + Soma1(cOrdem),"X1_ORDEM") //Posiciona na próxima pergunta.

			//Caso encontrou a pergunta, soma mais 1. Quando encontrar a ultima pergunta, o proximo posicione
			//Vai retornar vazio, dessa forma o valor de cProx será a útima pergunta encontrada+1 que é
			//exatamente o próximo valor encontrado.
			If !Empty(cOrdem)
				cProx := Soma1(cOrdem)
			EndIf

		End

	Endif

	RestArea(aAreaSX1)

Return cProx

//-------------------------------------------------------------------
/*/{Protheus.doc} NGVALSX9
Faz a checagem da integridade referencial de um registro

@type   	Function
@example	NGVALSX9( "TG1" , { "TG5" , "TG9" , "TGB" } , .T. )

@author 	Roger Rodrigues
@since  	12/08/2009
@Param  	cAlias, Character, 	Alias
			aNao, 	Array, 		Tabelas que não serão verificadas (Opcional)
			lHelp, 	Lógico, 	Verifica será necessária mensagem de Help
								(Padrão(.F.)) (Opcional)
			lNG, 	Lógico, 	Checa somente as tabelas da NG(.T. NG, .F. Todas)
								(Padrão(.F.)) (Opcional)
			lHelpExc, Lógico, 	Indica help de exclusão (.T.) ou de
								Alteração/Exclusão (.F.) (Opcional)
			cTableErro, Chacarter, Mensagem passada por referência. (Opcional)

@todo		Em futuras implementações para o NGVALSX9, considerar substituir por FwCheckSX9

			Função FwCheckSX9 passada pelo Jandir Deodato do Frame/SP:
			Funtion FwCheckSX9(cAlias, cFormId, aAlias, cMessage, lMessage)
			Ela vai realizar a validação do campo Dominio na SX9 e aceita Array com Tabelas a nao considerar e retorna verdadeiro ou falso.
			Parâmetros:	cAlias:		Alias do domínio
						cFormId:	IDentificador da tela ou formulário (é utilizado na mensagem de erro para facilitar a visualização do erro para o usuário)
						aAlias:		Array unidimensional com as tabelas que devem ser ignoradas no relacionamento (por exemplo, se na sua rotina os
									relacionamentos com a tabela pai serão excluidos, tal qual um modelo pai -filho no mvc você inclui esses alias aqui
									para que não sejam verificados. )
						cMessage:	Passada por referencia, recebe a string de rro
						lMessage:	Se true o Frame exibe a mensagem dizendo que a validação falhou. Se falso, fica a cargo de vocês mostrar ou não a mensagem
			Return FwCheckSX9( cAlias, cFormId, aNao, @cTableErro, lHelp)

@return Lógico, .T. - Permite Exclusão e .F. - Não Permite Exclusão
/*/
//-------------------------------------------------------------------
Function NGVALSX9(cAlias,aNao,lHelp,lNG,lHelpExc,cTableErro)

	Local i 		:= 1
	Local k 		:= 1
	Local lOk		:= .T.
	Local cCampo    := {}, aCampos := {}, cTabTmp
	Local cHelpSX9  := ""
	Local lAmbTopC  := .T.
	Local cSaveAli  := If(Empty(Alias()),cAlias,Alias())
	Local nModPos   := 0
	Local cChTable  := ""

	Default aNao 		:= {}
	Default lHelp		:= .F.
	Default lNG  		:= .T.
	Default lHelpExc 	:= .T.

	If cAlias = Nil
		Return .T.
	Endif

	cHelpSX9 := If( lHelpExc , "NGINTMOD" , "NGINTMOD2" )

	#IFNDEF TOP
		lAmbTopC := .F. //Indica ambiente Codebase
	#ENDIF

	If (TYPE("aChkSql")  != "A")
		aChkSql := NGRETSX9(cAlias,aNao)//Carrega todos SX9 referentes ao Alias
	Endif

	For i := 1 to Len(aChkSql)
		If aChkSql[i][3] == cAlias
			Loop
		Endif
		lOk := .T.
		//Verifica se a tabela pertence aos modulos da NG
		If lNG
			nModPos := Posicione("SX2",1,aChkSql[i][3],"X2_MODULO")
			If nModPos <> 56 .And. nModPos <> 19 .And. nModPos <> 35
				cChTable := Posicione("SX2",1,aChkSql[i][3],"X2_CHAVE")
				If !(Substr(cChTable,1,2) $ "ST/TA/TB/TC/TD/TK/TL/TM/TN/TO/TP/TQ/TR/TS/TT/TU/TZ")
					lOk := .F.
				Endif
			Endif
		Endif
		If lOk
			aCampos := {}
			cCampo := ""
			//Separa os campos para fazer checagem se existem no banco antes de validar
			For k:=1 to Len(aChkSql[i][4])
				If Substr(aChkSql[i][4],k,1) == "+"
					aADD( aCampos,{ cCampo } )
					cCampo := ""
				ElseIf Substr(aChkSql[i][4],k,2) == "||"
					aADD( aCampos,{ cCampo } )
					cCampo := ""
					k++
				Else
					cCampo += Substr(aChkSql[i][4],k,1)
				Endif
			Next k
			If !Empty(cCampo)
				aADD( aCampos,{cCampo})
			Endif
			//Checa se os campos existem na base
			k := 1
			For k:= 1 to Len(aCampos)
				If !NGCADICBASE(aCampos[k][1],"A",aChkSql[i][3],.F.)
					lOk := .F.
					Exit
				Endif
			Next k
		Endif
		If lOk
			//Adiciona Alias da Query para o dominio
			cBDDOM := StrTran( aChkSql[i][2] , "||", "+" )
			x := AT("+",cBDDOM)
			While x > 0
				cBDDOM := Substr(cBDDOM,1,x) + cAlias + "." + Substr(cBDDOM,x+1)
				If AT("+",Substr(cBDDOM,x+1)) == 0
					Exit
				Endif
				x += AT("+",Substr(cBDDOM,x+1))
			End
			cBDDOM := StrTran( cBDDOM , "+", "||" )

			//Adiciona Alias da Query para o contra-dominio
			cBDCDOM := StrTran( aChkSql[i][4] , "||", "+" )
			If lAmbTopC
				x := AT("+",cBDCDOM)
				While x > 0
					cBDCDOM := Substr(cBDCDOM,1,x) + aChkSql[i][3] + "." + Substr(cBDCDOM,x+1)
					If AT("+",Substr(cBDCDOM,x+1)) == 0
						Exit
					Endif
					x += AT("+",Substr(cBDCDOM,x+1))
				End
				cBDCDOM := StrTran( cBDCDOM , "+", "||" )
			Else
				cBDCDOM := aChkSql[i][3] + "->(" + Alltrim(cBDCDOM) + ")"
			Endif

			aCampos := StrTokArr(StrTran( aChkSql[i][2] , "||", "+" ),"+")

			//+------------------------------------------------------------+
			//| Analisa campos do formato Data para preencher com o DTOS() |
			//+------------------------------------------------------------+
			cAPDOM := ""
			For k:= 1 to Len(aCampos)
				If TAMSX3(aCampos[k])[3] == "D"
					cAPDOM += "DTOS(" + aCampos[k] + ")"
				Else
					cAPDOM += aCampos[k]
				Endif
				If Len(aCampos) > k
					cAPDOM += "+"
				EndIf
			Next k

			cAPDOM := cAlias + "->(" + Alltrim(cAPDOM) + ")"

			cTabTmp := AllTrim(aChkSql[i][3])

			// Acesso direto pelo indice
			nIndTab := NGINDPCDOM(aChkSql[i,3],aChkSql[i,4])
			If nIndTab > 0 .And. Empty(xFILIAL(aChkSql[i,3]))
				DbSelectArea(aChkSql[i,3])
				DbSetOrder(nIndTab)
				If DbSeek(xFILIAL(aChkSql[i,3])+&cAPDOM.)

					If Empty( aChkSql[i][5] ) .Or. &( aChkSql[i][5] ) //Se x9_CondSql esta preenchido executa

						If lHelp

							cTableErro := AllTrim(FwX2Nome(aChkSql[i,3])) + " (" + aChkSql[i,3] + ")"
							HELP(" ",1,cHelpSX9,,cTableErro,5,1)

						EndIf

						dbSelectArea( cSaveAli )
						Return .F.

					EndIf

				Endif

			Else
				If lAmbTopC

					//+--------------------------------------+
					//| Inicio da Query                      |
					//+--------------------------------------+
					dbSelectArea(cTabTmp)
					cQryAlias := GetNextAlias()
					cQuery := "SELECT COUNT(*) TOTAL"
					cQuery += " FROM " + RetSqlName(aChkSql[i][3]) + " " + aChkSql[i][3]
					cQuery += " JOIN " + RetSqlName(cAlias) + " " + cAlias
					cQuery += " ON "+cAlias+"."+cBDDOM+" = '"+&(cAPDOM)+"'"
					cQuery += " WHERE "+aChkSql[i][3]+".D_E_L_E_T_<>'*' AND "
					cQuery += aChkSql[i][3]+"."+cBDCDOM+ " = '" + &(cAPDOM) + "' AND "+cAlias+".D_E_L_E_T_ <> '*' "
					If !Empty(aChkSql[i][6])
						cQuery += "AND "+cAlias+"."+aChkSql[i][6]+" "
					Endif
					If !Empty(aChkSql[i][7])
						cQuery += "AND "+aChkSql[i][3]+"."+aChkSql[i][7]
					Endif
					If !Empty(aChkSql[i][5])
						cQuery += "AND ("+aChkSql[i][5]+")"
					EndIf
					cQuery := ChangeQuery(cQuery)
					dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cQryAlias, .F., .T.)

					(cQryAlias)->(dbGoTop())
					If (cQryAlias)->TOTAL > 0
						If lHelp
							cTableErro := NGSX2NOME(aChkSql[i][3]) + " (" + aChkSql[i][3] + ")"
							HELP(" ",1,cHelpSX9,,cTableErro,5,1)
							(cQryAlias)->(dbCloseArea())
							dbSelectArea(cSaveAli)
							Return .F.
							Exit
						Else
							dbSelectArea(cSaveAli)
							Return .F.
						Endif
					EndIf
					(cQryAlias)->(dbCloseArea())
				Else
					//+--------------------------------------+
					//| Filtro CODEBASE                      |
					//+--------------------------------------+
					dbSelectArea(cTabTmp)
					dbSetOrder(1)
					cInd := CriaTrab(NIL,.F.)
					cKey := IndexKey()
					cCondicao := cBDCDOM + " == '"+&(cAPDOM)+"'"
					If !Empty(aChkSql[i][6])
						cCondicao += " .And. "+cAlias+"->"+aChkSql[i][6]
					Endif
					If !Empty(aChkSql[i][7])
						cCondicao += " .And. "+aChkSql[i][3]+"->"+aChkSql[i][7]
					Endif
					If !Empty(aChkSql[i][5])
						aChkSql[i][5] := StrTran( aChkSql[i][5] , " OR", " .OR." )
						aChkSql[i][5] := StrTran( aChkSql[i][5] , " AND", " .And." )
						cCondicao += " .And. ("+aChkSql[i][5]+")"
					EndIf
					IndRegua(cTabTmp,cInd,cKey,,cCondicao) //"Selecionando Registros ..."

					nInd := RetIndex(cTabTmp)
					#IFNDEF TOP
						dbSetIndex(cInd+OrdBagExT())
					#ENDIF
					dbSetOrder(nInd+1)
					dbGotop()
					lNaoExcluir := .F.
					If (cTabTmp)->(!Eof())
						lNaoExcluir := .T.
					Endif
					dbSelectArea(cTabTmp)
					dbClearFilter()
					RetIndex(cTabTmp)
					Ferase(cInd+OrdBagExt())
					If lNaoExcluir
						If lHelp
							cTableErro := NGSX2NOME(aChkSql[i][3]) + " (" + aChkSql[i][3] + ")"
							HELP(" ",1,cHelpSX9,,cTableErro,5,1)
						Endif
						dbSelectArea(cSaveAli)
						Return .F.
						Exit
					Endif
				Endif
			EndIf
		Endif
	Next i
	dbSelectArea(cSaveAli)
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³NGMTAMFIL ºAutor  ³Roger Rodrigues     º Data ³  05/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna o maior tamanho de filial de todas as               º±±
±±º          ³empresas (P11 Gestão Corporativa)                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³GENERICO                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGMTAMFIL()
	Local nSize := 2,i,nTam := 0
	Local aSM0 := {}//Varáivel para carregar estrutura do SIGAMAT
	Local lPosCpo := (SM0->(FieldPos("M0_SIZEFIL")) > 0)//Verifica se existe o campo M0_SIZEFIL
	Local aArea := GetArea()

	//Se Encontrar a função de Gestão Corporativa usa a mesma
	//para evitar consultas diretas no SIGAMAT
	If FindFunction("FWLoadSM0()")
		aSM0 := FWLoadSM0()
		For i:=1 to Len(aSM0)
			//Se Exisitir M0_SIZEFIL
			If lPosCpo
				nTam := aSM0[i][8]//Posição do M0_SIZEFIL no array
			Endif
			If !lPosCpo .OR. nTam == 0//Se não existir M0_SIZEFIL ou for Zero
				nTam := Len(Trim(aSM0[i][2]))//Posição do M0_CODFIL no array
			Endif
			//Atribui tamanho caso maior que o guardado
			If nTam > nSize
				nSize := nTam
			Endif
		Next i
	Else
		dbSelectArea("SM0")
		dbSetOrder(1)
		dbGotop()
		While !eof()
			//Se Exisitir M0_SIZEFIL
			If lPosCpo
				nTam := SM0->M0_SIZEFIL
			Endif
			If !lPosCpo .OR. nTam == 0//Se não existir M0_SIZEFIL ou for Zero
				nTam := Len(Trim(SM0->M0_CODFIL))
			Endif
			//Atribui tamanho caso maior que o guardado
			If nTam > nSize
				nSize := nTam
			Endif
			dbSelectArea("SM0")
			dbSkip()
		End
	Endif

	RestArea(aArea)//Retorna Area
Return nSize

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    |NGHEXRGB  | Autor ³Vitor Emanuel Batista  ³ Data ³15/04/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o |Transforma cores Hexadecimal para RGB                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cClrHex - Cor em Hexadecimal. Ex: FFFFFF       -Obrigatorio ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aRGB - Vetor de tres posicoes com a cor em RGB              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGHEXRGB(cClrHex)
	Local aRGB := Array(3)

	Default cClrHex := "000000"

	If Len(cClrHex) == 3
		cClrHex += cClrHex
	EndIf

	aRGB[1] := CTON(Substr(cClrHex,1,2),16)
	aRGB[2] := CTON(Substr(cClrHex,3,2),16)
	aRGB[3] := CTON(Substr(cClrHex,5,2),16)

Return aRGB

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    |NGRGBHEX  | Autor ³Vitor Emanuel Batista  ³ Data ³27/04/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o |Transforma cores RGB para Hexadecimal                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aRGB - Vetor de tres posicoes com a cor em RGB -Obrigatorio ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³cClrHex - Cor em Hexadecimal.                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGRGBHEX(aRGB)
	Local cClrHex

	Default aRGB := {0,0,0}

	cClrHex := NTOC(aRGB[1],16,2)
	cClrHex += NTOC(aRGB[2],16,2)
	cClrHex += NTOC(aRGB[3],16,2)

Return cClrHex

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³NGIsAllNumºAutor  ³Wagner S. de Lacerdaº Data ³  09/06/2010 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se determinada string e' composta apenas por      º±±
±±º          ³ valores numericos.                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ .F. se conter algum caracter nao numerico.                 º±±
±±º          ³ .T. se for composta apenas por valores numericos.          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³	cStr -> Obrigatorio;                                       º±±
±±º          ³	        String a ser verificada.                           º±±
±±º          ³	nTam -> Opcional;                                          º±±
±±º          ³	        Indica ate' que ponto e' para verificar a string.  º±±
±±º          ³	        Default: recebe o tamanho total da string.         º±±
±±º          ³	lDec -> Opcional;                                          º±±
±±º          ³	        Valida o numero como decimal                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Generico                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGIsAllNum(cStr, nTam,lDec)

	Local nCont   := 0   // Contador do 'For'
	Local cAuxStr := ""  // Auxiliar para receber o caracter da string em determinada posicao
	Local lRet    := .T. // Retorno
	Local lJaDec  := .F.

	Default lDec := .T.
	Default nTam := Len(cStr)

	If nTam > Len(cStr)
		nTam := Len(cStr)
	EndIf

	For nCont := 1 To nTam
		cAuxStr := SubStr(cStr,nCont,1)
		If !(cAuxStr $ "0123456789")
			If lDec .And. cAuxStr $ ",." .And. !lJaDec
				lJaDec := .T.
			Else
				lRet := .F.
				Exit
			EndIf
		EndIf
	Next nCont

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³NGStrIsDatºAutor  ³Wagner S. de Lacerdaº Data ³  04/10/2010 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se determinada string esta' no formato de data.   º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ aRet[1] indica True pra data valida e False para invalida. º±±
±±º          ³ aRet[2] indica as mensagens de erro acumuladas durante o   º±±
±±º          ³ processo.                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³	cStr --> Obrigatorio;                                      º±±
±±º          ³	         String a ser verificada como data.                º±±
±±º          ³	cTipo -> Obrigatorio;                                      º±±
±±º          ³	         C - define cStr como caracter. (01/01/2001)       º±±
±±º          ³	         S - define cStr como string. (20010101)           º±±
±±º          ³	lMsg --> Opcional;                                         º±±
±±º          ³	         Se True apresenta mensagem.                       º±±
±±º          ³	         Default: recebe False.                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Generico                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGStrIsDat(cStr, cTipo, lMsg)

	Local aRet    := {}  // Retorno
	Local aMsg    := {}  // Mensagens de Erro
	Local nCont   := 0   // Contador do 'For'
	Local nLen    := 0   // Tamanho da cStr
	Local nDia    := 0   // Dia
	Local nMes    := 0   // Mes
	Local nAno    := 0   // Ano
	Local cAuxStr := ""  // Auxiliar para receber o caracter da string em determinada posicao
	Local lRet    := .T. // Retorno
	Local lDia    := .T. // Verifica dia
	Local lMes    := .T. // Verifica mes
	Local lAno    := .T. // Verifica ano

	Default lMsg := .F.

	nLen := Len(cStr)

	If Empty(cStr)
		Return {.F.,{STR0201}} //"Data não informada."
	EndIf

	If cTipo == "C"
		If nLen == 8 .Or. nLen == 10
			nDia := Val( SubStr(cStr,1,2) )
			nMes := Val( SubStr(cStr,4,2) )
			nAno := Val( SubStr(cStr,7) )

			For nCont := 1 To nLen
				cAuxStr := SubStr(cStr,nCont,1)
				If nCont == 3 .Or. nCont == 6
					If cAuxStr <> "/"
						lRet := .F.
					EndIf
				Else
					If !(cAuxStr $ "0123456789")
						lRet := .F.
						If nCont == 1 .Or. nCont == 2
							lDia := .F.
						ElseIf nCont == 4 .Or. nCont == 5
							lMes := .F.
						ElseIf nCont >= 7
							lAno := .F.
						EndIf
					EndIf
				EndIf
			Next nCont
		Else
			lRet := .F.
		EndIf

		If lMsg .And. !lRet
			If nLen < 8 .Or. !("/" $ cStr)
				aAdd(aMsg, STR0185) //"Data inválida no formato DD/MM/AA."
			ElseIf nLen > 8 .And. nLen <> 10
				aAdd(aMsg, STR0186) //"Data inválida no formato DD/MM/AAAA."
			EndIf

			If !lDia
				aAdd(aMsg, STR0192) //"Conteúdo do dia DD inválido."
			EndIf
			If !lMes
				aAdd(aMsg, STR0193) //"Conteúdo do mês MM inválido."
			EndIf
			If !lAno
				If nLen < 8
					aAdd(aMsg, STR0194) //"Conteúdo do ano AA inválido."
				ElseIf nLen > 8
					aAdd(aMsg, STR0195) //"Conteúdo do ano AAAA inválido."
				EndIf
			EndIf
		EndIf
	ElseIf cTipo == "S"
		If nLen == 8
			nDia := Val( SubStr(cStr,7,2) )
			nMes := Val( SubStr(cStr,5,2) )
			nAno := Val( SubStr(cStr,1,4) )

			For nCont := 1 To nLen
				cAuxStr := SubStr(cStr,nCont,1)
				If !(cAuxStr $ "0123456789")
					lRet := .F.
					If nCont >= 1 .And. nCont <= 4
						lAno := .F.
					ElseIf nCont == 5 .Or. nCont == 6
						lMes := .F.
					ElseIf nCont == 7 .Or. nCont == 8
						lDia := .F.
					EndIf
				EndIf
			Next nCont
		Else
			lRet := .F.
		EndIf

		If lMsg .And. !lRet .And. nLen <> 8
			aAdd(aMsg, STR0187) //"Data inválida no formato AAAAMMDD."
		EndIf

		If !lDia
			aAdd(aMsg, STR0192) //"Conteúdo do dia DD inválido."
		EndIf
		If !lMes
			aAdd(aMsg, STR0193) //"Conteúdo do mês MM inválido."
		EndIf
		If !lAno
			aAdd(aMsg, STR0195) //"Conteúdo do ano AAAA inválido."
		EndIf
	Else
		lRet := .F.
		If lMsg .And. !lRet
			aAdd(aMsg, STR0188) //"Data inválida. Tipo inválido."
		EndIf
	EndIf

	If lRet
		If nMes >= 1 .And. nMes <= 12
			If nMes <= 7
				If nMes % 2 == 0
					If nDia < 1 .Or. nDia > 30
						If lMsg
							aAdd(aMsg, STR0189) //"Dia inválido"
						EndIf
						lRet := .F.
					EndIf
				Else
					If nDia < 1 .Or. nDia > 31
						If lMsg
							aAdd(aMsg, STR0189) //"Dia inválido"
						EndIf
						lRet := .F.
					EndIf
				EndIf
			Else
				If nMes % 2 == 0
					If nDia < 1 .Or. nDia > 31
						If lMsg
							aAdd(aMsg, STR0189) //"Dia inválido"
						EndIf
						lRet := .F.
					EndIf
				Else
					If nDia < 1 .Or. nDia > 30
						If lMsg
							aAdd(aMsg, STR0189) //"Dia inválido"
						EndIf
						lRet := .F.
					EndIf
				EndIf
			EndIf
		Else
			If lMsg
				aAdd(aMsg, STR0190) //"Mês inválido."
			EndIf
			lRet := .F.
		EndIf

		If nLen == 8
			If nAno < 0 .Or. nAno > 99
				If lMsg
					aAdd(aMsg, STR0191) //"Ano inválido."
				EndIf
				lRet := .F.
			EndIf
		ElseIf nLen == 10
			If nAno < 1500 .Or. nAno > 7999
				If lMsg
					aAdd(aMsg, STR0191) //"Ano inválido."
				EndIf
				lRet := .F.
			EndIf
		EndIf
	EndIf

	aAdd(aRet, lRet )
	aAdd(aRet, aMsg )

Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³NGNewMBrw ºAutor  ³Wagner S. de Lacerdaº Data ³  25/10/2010 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Monta um novo mBrowse, validando indice e filtro.          º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ True  -> Tudo Ok.                                          º±±
±±º          ³ False -> Ocorreu erro no processo.                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cAliasBrw --> Opcional;                                    º±±
±±º          ³               Indica o alias para montar o browse.         º±±
±±º          ³               Default: Alias atual.                        º±±
±±º          ³ cFilterBrw -> Opcional;                                    º±±
±±º          ³               Indica o filtro a ser utilziado na tabela.   º±±
±±º          ³               Default: Vazio.                              º±±
±±º          ³ nIndBrw ----> Opcional;                                    º±±
±±º          ³               Indica o indice de ordem da tabela.      .   º±±
±±º          ³               Default: 1.                                  º±±
±±º          ³ aRotBrw ----> Opcional;                                    º±±
±±º          ³               Indica a variavel aRotina a ser utilizada.   º±±
±±º          ³               Default: Variavel aRotina anterior;          º±±
±±º          ³               * Se nao definida neste parametro, a         º±±
±±º          ³                 variavel aRotina deve estar declarada.     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SigaMNT                                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º           ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºProgramador ³   Data     ³ Descricao                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º            ³ xx/xx/xxxx ³                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGNewMBrw(cAliasBrw,cFilterBrw,nIndBrw,aRotBrw)

	Local aOldRot    := {}      //Armazena a variavel aRotina anterior
	Local cOldAlias  := Alias() //Armazena o alias anterior
	Local cOldFilter := ""      //Armazena o filtro anterior
	Local nOldIndex  := 1       //Armazena o indice anterior
	Local cVerInd    := ""      //Verifica se existen o indice selecionada para a tabela

	Default cAliasBrw  := Alias()
	Default cFilterBrw := ""
	Default nIndBrw    := 1
	Default aRotBrw    := {}

	If Type("aRotina") == "A"
		aOldRot := aClone(aRotina)
		If Len(aRotBrw) == 0
			aRotBrw := aClone(aRotina)
		EndIf
	EndIf

	//ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
	//º Validacoes gerais                        º
	//ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
	If Len(aRotBrw) == 0
		MsgStop(STR0196,STR0025) //"Variável padrão de browse não definida."###"ATENCAO"
		Return .F.
	EndIf

	dbSelectArea("SIX")
	dbSetOrder(1)
	dbGoTop()
	cVerInd := cAliasBrw + Space( Len(SIX->INDICE) - Len(cAliasBrw) ) + NGTransInd(nIndBrw)
	If !dbSeek(cVerInd)
		MsgStop(STR0197+" ("+AllTrim(Str(nIndBrw))+") "+STR0198+" ("+cAliasBrw+").",STR0025) //"O índice indicado"###"não existe na tabela"###"ATENCAO"
		Return .F.
	EndIf

	If !Empty(cFilterBrw)
		If !(cAliasBrw+"->" $ cFilterBrw)
			If !MsgYesNo(STR0199+" ("+cAliasBrw+")."+Chr(13)+Chr(10)+; //"O filtro está incoerente com a tabela"
			STR0200,STR0025) //"Continuar o processo?"###"ATENCAO"
				Return .F.
			EndIf
		EndIf
	EndIf

	//ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
	//º Recebe as condicoes anteriores do alias  º
	//ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
	dbSelectArea(cOldAlias)
	cOldFilter := dbFilter()
	nOldIndex  := IndexOrd()

	aRotina := aClone(aRotBrw)

	//ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
	//º Monta o mBrowse                          º
	//ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
	dbSelectArea(cAliasBrw)
	dbSetOrder(nIndBrw)
	dbGoTop()
	Set Filter To &(cFilterBrw)

	mBrowse(6,1,22,75,cAliasBrw)

	Set Filter To

	//ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
	//º Retorna as condicoes anteriores do alias º
	//ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
	dbSelectArea(cOldAlias)
	dbSetOrder(nOldIndex)
	Set Filter To &(cOldFilter)

	aRotina := aClone(aOldRot)

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³NGTransIndºAutor  ³Wagner S. de Lacerdaº Data ³  26/10/2010 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Converte um indice numerico em caracter, para indices      º±±
±±º          ³ maiores que a ordem 9. (10 = A; 11 = B; 12 = C; etc.)      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ cInd -> Indice convertido em caracter, e se necessario,    º±±
±±º          ³         transformado em A, B, C, D, etc.                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ nInd -> Obrigatorio;                                       º±±
±±º          ³         Indica o indice a ser convertido.                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SigaMNT                                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º           ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºProgramador ³   Data     ³ Descricao                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º            ³ xx/xx/xxxx ³                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGTransInd(nInd)

	Local cInd     := ""
	Local nCont    := 0
	Local lCont    := .T.

	Default nInd := 0

	If nInd >= 10
		cInd  := "1"
		While lCont
			nCont++

			If nCont == 10
				cInd := "A"
			EndIf

			If nCont == nInd
				lCont := .F.
				Exit
			EndIf

			cInd := Soma1(cInd)
		End
	Else
		cInd := AllTrim(Str(nInd))
	EndIf

Return cInd

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCHKDEL ³ Autor ³ Inacio luiz Kolling   ³ Data ³ 01/03/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consistencia na exclusão                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cALIAS  -> Alias da tabela                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCHKDEL(cAlias)
	Local   lDEL := .T. ,I := 0, aAreaD  := GetArea()
	Local lGRAVA  := (TYPE("bNGGRAVA")  == "B")
	For i := 1 to Len(aCHKDEL)
		DbSelectArea(aCHKDEL[i][2])
		OldInd := INDEXORD()
		DbSetOrder(aCHKDEL[i][3])
		cKEY := aCHKDEL[i][1]
		lDEL := !(DbSeek(xFILIAL(aCHKDEL[i][2])+&cKEY.))
		DbSetOrder(OldInd)
		If !lDEL
			cError := AllTrim(FwX2Nome(aCHKDEL[i][2])) + " (" + aCHKDEL[i][2] + ")"
			HELP(" ",1,"NGINTMOD",,cError,5,1)
			Exit
		Endif
	Next

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Valida de acordo com SX9      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lDEL .And. TYPE("lCHKSQL") <>  "U" .And. lCHKSQL
		If !NGVALSX9(cAlias,,.T.)
			lDEL := .F.
		Endif
	EndIf
	If lDEL
		If lGRAVA .And. !Eval(bNGGRAVA)
			lDEL := .F.
		Endif
	EndIf
	RestArea(aAreaD)
Return lDEL
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGINDPCDOM ³ Autor ³ Inacio luiz Kolling   ³ Data ³ 01/03/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Busca o indice correspondente ao contra dominio  sem a filial         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cALIAS  -> Alias da tabela                        ³±±
±±³          ³ cCDOM   -> Contra dominio                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³ nIndLoc -> Numero do indice -> 0 Não existe indice ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NGINDPCDOM(cAlias,cCDOM)
	Local nIndLoc := 0, nFl := 0, vVetInd := NGRETINDTAB(cAlias)
	For nFl := 1 To Len(vVetInd)
		cChaveA := vVetInd[nFl]
		cChaveI := Strtran(cChaveA," ","")
		nPosF := At("_FILIAL",cChaveI)
		If nPosF > 0
			nPosM := At("+",cChaveI)
			If nPosM > 0
				cChaveI := Alltrim(SubS(cChaveI,nPosM+1,Len(cChaveI)))
			EndIf
		EndIf
		If SubS(cChaveI,1,Len(Alltrim(cCDOM))) = Alltrim(cCDOM)
			nIndLoc := nFl
			Exit
		EndIf
	Next nFl
Return nIndLoc

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ NGRETINDTABAutor ³Inácio Luiz Kolling  ³ Data ³ 02/03/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta vetor com os indices da tabela                 |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³vRetL  - Vetor com os indices                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGRETINDTAB( cAliasTab )

	Local vRetL  := {}

	Local aAreaT := GetArea()
	Local aIndex := {}

	Local cChave := ''

	Local nIndex := 0

	If FWSIXUtil():ExistIndex( cAliasTab, '1' )

		aIndex := FWSIXUtil():GetAliasIndexes( cAliasTab )

		For nIndex := 1 To Len( aIndex )
			
			cChave := StrTran( ArrTokStr( aIndex[ nIndex ] ), '|', '+' )

			aAdd( vRetL, cChave )

		Next nIndex

	EndIf

	RestArea( aAreaT )

Return vRetL
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NGCAD02SPB  ³ Autor ³ Inacio Luiz Kolling   ³ Data ³22/05/2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Mundança de linha da getdados                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ NGCAD02                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function NGCAD02SPB()
	Local lTudoVaz := .T.,nFl := 0
	If Len(aCOLS) = 2
		For nFl := 1 To Len(aCOLS[1])-If(lWalkT,3,1)
			If !Empty(aCOLS[1,nFl])
				lTudoVaz := .F.
				Exit
			EndIf
		Next nFl
		If lTudoVaz
			n  := 1
			aCOLS := {}
			aCOLS :=BLANKGETD(aHeader)
			oget:oBrowse:Refresh()
			oget:ForceRefresh()
		EndIf
	EndIf
Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} NGMVCUserBtn
Tratamento na View do MVC para adicionar itens no "Ações Relacionadas",
de acordo com o conceito NGRightClick

@param Array aUserBTN: indica botões de usuário a serem adicionados
além do que vier da função NGRIGHTCLICK
aRemoveBtn: indica botões a serem adicionados do menu
aWhenBtn: indica em quais operações os botões devem ser apresentados ex.:
{ { 'MNC600CON'	, { MODEL_OPERATION_VIEW , MODEL_OPERATION_UPDATE } }
{   'MNTC090'	, { MODEL_OPERATION_DELETE , MODEL_OPERATION_UPDATE } }

@author Vitor Emanuel Batista
@since 23/03/2012
@version P11
@return Nil
/*/
//---------------------------------------------------------------------
Function NGMVCUserBtn(oView,aUserBTN,aRemoveBtn,aWhenBtn)

	Local aArea   := GetArea()
	Local aPopUp  := {}
	Local cRotina := oView:GetModel():GetId()
	Local nPopUp, nFunctPos, aOperation

	Local nI := 0
	Local TITULO_BOTAO := 1
	Local FUNCAO_BOTAO := 2

	Default aUserBTN	:= {}
	Default aRemoveBtn	:= {}
	Default aWhenBtn	:= {}

	// Inclusão dos itens do clique da direita no Ações Relacionadas
	If Len( aUserBTN ) > 0
		aPopUp := NGRIGHTCLICK(cRotina,,aRemoveBtn)

		For nI := 1 To Len( aUserBTN )
			aAdd( aPopUp,{ aUserBTN[nI][TITULO_BOTAO],aUserBTN[nI][FUNCAO_BOTAO],"" } )
		Next nI

	Else
		aPopUp := NGRIGHTCLICK(cRotina,,aRemoveBtn)
	EndIf

	For nPopUp := 1 To Len(aPopUp)
		aPopUp[nPopUp][3] := If(Empty(aPopUp[nPopUp][3]),'',aPopUp[nPopUp][3])
		aOperation	:= Nil
		nFunctPos	:= aScan( aWhenBtn , { |x| AllTrim( Upper( x[1] ) ) + '(' $ aPopUp[nPopUp][2] })
		If nFunctPos > 0
			aOperation := aWhenBtn[nFunctPos][2]
		EndIf
		oView:AddUserButton( aPopUp[nPopUp][1], aPopUp[nPopUp][3], &("{|oView| " + aPopUp[nPopUp][2] + "}") , , , aOperation )
	Next nPopUp

	RestArea(aArea)
Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NGMSGMEMO
Mostra mensagem em um memo
Uso Genérico

@return

@sample
NGMSGMEMO( "Titulo" , "Descrição" , { 3 , 0 , 340 , 550 } )

@author Jackson Machado e Hugo Rizzo Pereira
@since 21/08/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Function NGMSGMEMO(cTitulo,cDescricao,aDms)
	Local cMemo
	Local cFile := ""
	Local oDlg, oMemo, oBtnApa, oBtnSal
	Local cMask := STR0207 //"Arquivos Texto (*.TXT) |*.txt|"

	Default cTitulo    := ""
	Default cDescricao := ""
	Default aDms       := { 3 , 0 , 340 , 550 }

	cMemo := cDescricao

	DEFINE MSDIALOG oDlg TITLE cTitulo From aDms[1] , aDms[2] to aDms[3] , aDms[4] PIXEL

	oMemo := tMultiGet():New( 5 , 5 , {|u| If( Pcount() > 0 , cMemo := u , cMemo )} , oDlg , ( aDms[4] / 2 ) - 10 , ( aDms[3] / 2 ) - 25 ,/*oFont*/,/*lHScroll*/,/*uParam9*/,/*uParam10*/,;
	/*uParam11*/,.T.,/*uParam13*/, /*uParam14*/, /*bWhen*/, /*uParam16*/, /*uParam17*/, .T. )

	oBtnSal := SButton():New( ( aDms[3] / 2 ) - 15 , ( aDms[4] / 2 ) - 60 , 13 , {|| (cFile := cGetFile( cMask , OemToAnsi( STR0208 + "..." ) ),; //"Salvar Como"
	If( cFile == "" , .T. , MemoWrite( If( ".txt" $ cFile , cFile , AllTrim( cFile ) + ".txt" ), cMemo ) ), ;
	oDlg:End() ) } , oDlg , .T. , /*cMsg*/ , /*bWhen*/ )
	oBtnApa := SButton():New( ( aDms[3] / 2 ) - 15 , ( aDms[4] / 2 ) - 30 , 1 , {|| oDlg:End() } , oDlg , .T. , /*cMsg*/ , /*bWhen*/ )

	ACTIVATE MSDIALOG oDlg CENTER

Return

//---------------------------------------------------------------------
/*{Protheus.doc} NGTrocaF3
Realiza o controle da variável aTrocaF3

@return Nil

@param cCampoF3 - Campo que deverá alterar o F3
@param cSXB	    - Consulta que o campo deverá utilizar

@author Vitor Emanuel Batista
@since 06/06/2013
@version 1.0
//---------------------------------------------------------------------
*/
Function NGTrocaF3(cCampoF3,cSXB)
	Local nPos

	//Declara variável caso aTrocaF3 não esteja declarada
	If Type("aTrocaF3") <> "A"
		_SetNamedPrvt("aTrocaF3", {}, "__EXECUTE")
	EndIf

	//Localiza no aTrocaF3 se o campo já possui troca
	nPos := aScan(aTrocaF3,{|x| x[1] == cCampoF3})

	//Caso não esteja da array, cria posição
	If nPos == 0
		aAdd(aTrocaF3,{,})

		nPos := Len(aTrocaF3)
		aTrocaF3[nPos][1] := cCampoF3
	EndIf

	//Modifica o F3 do campo
	aTrocaF3[nPos][2] := cSXB
Return
//---------------------------------------------------------------------
/*{Protheus.doc} NGClickBar
Função que define o Clique da direita na barra de abutton da EnchoiceBar
Adiciona no array do parametro as funções do aSMenu

@return Nil

@param aButton - Parametro a ser alterado
@param aClkMenu - Parâmetro referente ao aSMenu, caso não seja passado
recebe o conteudo do aSMenu existente

@sample NGClickBar ( @aNgButton )

@author Guilherme Benkendorf
@since 29/07/2014
@version 1.0
//---------------------------------------------------------------------
*/
Function NGClickBar( aButton, aClkMenu )
	Local nX

	Default aButton	:= {}
	Default aClkMenu	:= If( Type( "aSMenu" ) == "A", aClone( aSMenu ), {} )

	For nX := 1 To Len( aClkMenu )
		aAdd( aButton, { If( Len( aClkMenu[nX] ) > 2, aClkMenu[nX][3] , Nil ) ,;
		&( "{|| " + aClkMenu[nX][2] +"}" ), aClkMenu[nX][1] } )
	Next nX

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGIFDBSEEK ³ Autor ³In cio Luiz Kolling ³ Data ³22/04/2008³09:30³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o registro existe                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias  - Alias do arquivo                        - Obrigatorio ³±±
±±³          ³cChave  - Chave de acesso  (Sem a filial)         - Obrigatorio ³±±
±±³          ³nIndic  - Indice de acesso                        - Obrigatorio ³±±
±±³          ³lMostr  - Indica se mostra mensagem               - Nao Obrigat.³±±
±±³          ³cFilia  - Codigo da filial                        - Nao Obrigat.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³.T.,.F. - .T. Achou,  .F. Nao achou o registro                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Generico                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGIFDBSEEK(cAlias,cChave,nIndic,lMostr,cFilia)
	Local cFilIF := xFilial(cAlias,cFilia),lRetLo := .F.
	Local lMostT := If(lMostr = Nil,.F.,lMostr)

	NGDBAREAORDE(cAlias,nIndic)
	lRetLo := If(Dbseek(If(NGFILNACHAVE(cAlias,nIndic,cFilia),cFilIf+cChave,cChave)),.T.,.F.)
	If !lRetLo .And. lMostT
		MsgInfo(STR0214+NGFINALLINHA(2)+"Alias"+"....: "+cAlias+NGFINALLINHA(); //"Registro nao encontrado."
		+STR0152+"...: "+cChave+NGFINALLINHA()+STR0153+"...: "+Str(nIndic,2),; //"Chave"###"Indice"
		STR0215) //"NAO CONFORMIDADE"
	Endif
Return lRetLo

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGIFDICIONA³ Autor ³In cio Luiz Kolling ³ Data ³23/04/2008³09:30³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o registro existe no dicionario                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias  - Alias do arquivo                        - Obrigatorio ³±±
±±³          ³cChave  - Chave de acesso  (Sem a filial)         - Obrigatorio ³±±
±±³          ³nIndic  - Indice de acesso                        - Obrigatorio ³±±
±±³          ³lMostr  - Indica se mostra mensagem               - Nao Obrigat.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³.T.,.F. - .T. Achou,  .F. Nao achou o registro                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Generico                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGIFDICIONA(cAlias,cChave,nIndic,lMostr)
	Local lMostT := If(lMostr = Nil,.F.,lMostr)
	NGDBAREAORDE(cAlias,nIndic)
	lRet := If(Dbseek(cChave),.T.,.F.)
	If !lRet .And. lMostT
		MsgInfo(STR0214+NGFINALLINHA(2)+"Alias"+"....: "+cAlias+NGFINALLINHA(); //"Registro nao encontrado."
		+STR0152+"...: "+cChave+NGFINALLINHA()+STR0153+"...: "+Str(nIndic,2),; //"Chave"###"Indice"
		STR0215) //"NAO CONFORMIDADE"
	Endif
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} NGRETSX1BOX
Retorna o conteudo do SX1 box

@author  Inacio Luiz Kolling
@since   22/07/2008
@param   cPergun - Codigo da pergunta
         cOrdemP - Ordem da pergunta
@return  Descricao do Sub-item do SX1 box
@version P12
/*/
//-------------------------------------------------------------------
Function NGRETSX1BOX(cPergun,cOrdemP)

	Local cConteu  := " "
	Local aAreaAtu := GetArea()
	Local cPerX1   := PadR( Alltrim(cPergun), Len(Posicione("SX1", 1, Alltrim(cPergun), "X1_GRUPO")) )
	Local cTipo    := ""
	Local cGSC     := ""
	Local cPresel  := ""

	If !Empty(Posicione("SX1",1,cPerX1+cOrdemP,"X1_GRUPO")) //Garante que a pergunta existe

		cTipo   := Posicione("SX1",1,cPerX1+cOrdemP,"X1_TIPO")
		cGSC    := Posicione("SX1",1,cPerX1+cOrdemP,"X1_GSC")
		cPresel := Posicione("SX1",1,cPerX1+cOrdemP,"X1_PRESEL")

		If cTipo == "N" .And. cGSC == "C"

			nPerce := If(Empty(cPresel),1,cPresel)
			cConteu := Posicione( 'SX1' , 1 , cPergun + cOrdemP , 'X1Def0' + Str(nPerce,1) + '()' )

		Endif
	Endif

	RestArea(aAreaAtu)

Return cConteu

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NGSX3PROXORD³ Autor ³ Inacio Luiz Kolling   ³ Data ³18/06/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Proxima ordem do SX3                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ vAlias  - Alias do compo para a alteracao        - Obrigatorio³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³ cOrdPr  - Numeracao da proxima ordem                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGSX3PROXORD(vAlias)
	Local aAreaSX3 := GetArea(),cOrdPr := Space(Len(Posicione("SX3",1,vAlias,"X3_ORDEM"))),cUlOrd := cOrdPr
	Local aLetNu   := {{'A9','B1'},{'B9','C1'},{'C9','D1'},{'D9','E1'},;
	{'E9','F1'},{'F9','G1'},{'G9','H1'},{'H9','I1'}}
	Local aHeaderORD := {}
	Local nTamTot    := 0
	Local nInd       := 0

	If NGIFDICIONA("SX3",vAlias,1)
		cUlOrd := Posicione("SX3",1,vAlias,"X3_ORDEM")

		aHeaderORD := NGHeader(vAlias)
		nTamTot := Len(aHeaderORD)
		For nInd := 1 To nTamTot
			cUlOrd := Alltrim(Posicione("SX3",2,aHeaderORD[nInd,2],"X3_ORDEM"))
		Next nInd

		nPosOrd := aSCAN(aLetNu,{|x| x[1] == cUlOrd})
		If nPosOrd > 0
			cOrdPr := aLetNu[nPosOrd,2]
		ElseIf cUlOrd = '99'
			cOrdPr := "A0"
		Else
			cOrdPr := If(FindFunction("Soma1Old"),PADL(Soma1Old(cUlOrd),2),;
			PADL(Soma1(cUlOrd),2))
		Endif
	Endif

	RestArea(aAreaSX3)
Return cOrdPr

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³NGATVERTXT³ Autor ³ In cio Luiz Kolling   ³ Data ³12/08/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Atualiza os arquivos de controle de versao                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICA                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGATVERTXT
	If FindFunction("NGFONTERPO")
		cVerEx := Alltrim(cVersao)
		cVerEx := STRTRAN(cVerEx,".","")
		cArqVH := "CHKVERH"+cVerEx+".TXT"
		cArqVA := "CHKVERA"+cVerEx+".TXT"

		If File(cArqVA)
			Ferase(cArqVA)
		Endif
		MsgRun(STR0228,"ATENCAO",{ || NGFONTERPO()}) //"Aguarde... filtrando e gerando arquivos."
		Copy file &cArqVH to &cArqVA
	Endif
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³NGENVTXTCL³ Autor ³ In cio Luiz Kolling   ³ Data ³13/08/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Gera o arquivo de controle de versao (CHKVERH+VERSAO)e envia³±±
±±³          ³para a NG INFORMATICA                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICA                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGENVTXTCL()
	NGFONTERPO(.T.)
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGTDELACOLS³ Autor ³In cio Luiz Kolling    ³ Data ³11/09/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retira os itens deletados de uma acols  (getdados)           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aRACOLS - Array com os dados                    - OBRIGATORIO³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGTDELACOLS(aRACOLS)
	Local nFd := 0,aARet := {}
	For nFd := 1 To Len(aRACOLS)
		If !Atail(aRACOLS[nFd])
			Aadd(aARet,aRACOLS[nFd])
		Endif
	Next nFd
Return aARet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NGSIXPROXORD³ Autor ³ Inacio Luiz Kolling   ³ Data ³15/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Proxima ordem do SIX                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ vAlias  - Alias do compo para a alteracao        - Obrigatorio³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³ cOrdPr  - Numeracao da proxima ordem                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGSIXPROXORD(vAlias)
	Local aAreaSIX := GetArea(),cOrdPr := Space(Len(SIX->ORDEM)),cUlOrd := cOrdPr
	Local aLetNu   := {{'A','B'},{'B','C'},{'C','D'},{'D','E'},;
	{'E','F'},{'F','G'},{'G','H'},{'H','I'}}
	If NGIFDICIONA("SIX",vAlias,1)
		cUlOrd := SIX->ORDEM
		While !Eof() .And. SIX->INDICE = vAlias
			cUlOrd := Alltrim(SIX->ORDEM)
			Dbskip()
		End
		nPosOrd := aSCAN(aLetNu,{|x| x[1] == cUlOrd})
		If nPosOrd > 0
			cOrdPr := aLetNu[nPosOrd,2]
		ElseIf cUlOrd = '9'
			cOrdPr := "A"
		Else
			cOrdPr := If(FindFunction("Soma1Old"),PADL(Soma1Old(cUlOrd),1),;
			PADL(Soma1(cUlOrd),1))
		Endif
	Endif
	RestArea(aAreaSIX)
Return cOrdPr

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NGCONVINDICE³ Autor ³ Inacio Luiz Kolling   ³ Data ³15/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Conversao do codigo do indice para numerico/caracter          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cvInd   - Conteudo do indice                     - Obrigatorio³±±
±±³          ³ ctip    - Tipo do conteudo                       - Obrigatorio³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³ cIndi   - Indice convertido em numerico ou em caracter        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGCONVINDICE(cvInd,cTip)
	If cTip = "N"
		cIndi := If(cvInd > 10,Chr((cvInd - 9)+64),Str(cvInd,2))
		cIndi := Alltrim(cIndi)
	Else
		cIndi := If(cvInd > "9",(Asc(cvInd)-64)+9,Val(cvInd))
	Endif
Return cIndi
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGFILNACHAVE³ Autor ³In cio Luiz Kolling   ³ Data ³29/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se no inicio do indice tem a filial                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cAlias - Alias do arquivo\Tabela                  Obrigatorio³±±
±±³          ³nInd   - Indice de acesso                         Obrigatorio³±±
±±³          ³cFilAc - Filial de acesso                         Nao Obrig. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³lRetF - .T.,.F.                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³OBSERVACAO³Nao mexer na funcao                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGFILNACHAVE(cAlias,nInd,cFilac)
	Local lTemFilI := .T.
	cDesInd := Alltrim(NGSEEKDIC("SIX",cAlias+NGCONVINDICE(nInd,"N"),1,'CHAVE'))
	nPosTra := At("_",cDesInd)
	If nPosTra > 0
		nPosMai := At("+",cDesInd)
		cFilInc := If(nPosMai > 0,SubStr(cDesInd,nPosTra+1,(nPosMai-1)-nPosTra),;
		SubStr(cDesInd,nPosTra+1,Len(cDesInd)-nPosTra))
		lTemFilI := 'FILIAL' $ cFilInc
	Endif
Return lTemFilI

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGFINALLINHA³ Autor ³In cio Luiz Kolling   ³ Data ³30/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Finaliza linha de uma string                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³nLin - Quantidade de linha(s)                 Nao Obrigatorio³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³cChr - Linhas em branco                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³OBSERVACAO³Nao mexer na funcao                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGFINALLINHA(nLin)
	Local nSomaL := If(nLin = Nil,1,nLin),nF := 0, cChrR := Space(1)
	For nF := 1 To nSomaL
		cChrR += CRLF
	Next nF
Return cChrR

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGDBAREAORDE³ Autor ³In cio Luiz Kolling   ³ Data ³30/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Seleciona o alias e o indice                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cAlias - Alias do arquivo\Tabela                  Obrigatorio³±±
±±³          ³nInd   - Indice de acesso                         Nao Obrig. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³OBSERVACAO³Nao mexer na funcao                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGDBAREAORDE(cAlias,nInd)
	Local nIndA := If(nInd = Nil,1,nInd)
	DbSelectArea(cAlias)
	DbSetOrder(nIndA)
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGSETIFARQUI³ Autor ³In cio Luiz Kolling   ³ Data ³31/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Seta para o inicio/ou final do arquivo                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cAlias - Alias do arquivo\Tabela                  Obrigatorio³±±
±±³          ³cTip   - Indica o posicionamento (Inicio/final)   Nao Obrig. ³±±
±±³          ³nInd   - Indice de acesso                         Nao Obrig. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³OBSERVACAO³Nao mexer na funcao                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSETIFARQUI(cAlias,cTip,nInd)
	Local cTipP := If(cTip = Nil,"I",cTip)
	DbSelectArea(cAlias)
	If nInd <> Nil
		DbSetOrder(nInd)
	Endif
	If cTipP = "I"
		DbGotop()
	Else
		DbGobottom()
		DbSkip()
	Endif
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGDBSELSKIP ³ Autor ³In cio Luiz Kolling   ³ Data ³03/11/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Seleciona um arquivo/tabela e seta um registro               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cAlias - Alias do arquivo\Tabela                  Obrigatorio³±±
±±³          ³lProxi - Proximo registro                         Nao Obrig  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGDBSELSKIP(cAlias,lProxi)
	Local nPAReg := If(lProxi = Nil,1,If(lProxi,1,-1))
	DbSelectArea(cAlias)
	DbSkip(nPAReg)
Return
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³NGINCOMPDIC ³ Autor ³In cio Luiz Kolling   ³ Data ³19/05/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Mensagem de incompatibilidade do dicionario de dados         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cFuncao - Nome da funcao a ser executada       - Nao Obrigat.³±±
±±³          ³cNumBol - Numero do boletim tecnico            - Nao Obrigat.³±±
±±³          ³lTerm   - Indica se o sistema sera encerrado   - Nao Obrigat.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGINCOMPDIC(cFuncao,cNumBol,lTerm)
	Local cMenF := If(cFuncao <> Nil,STR0261+" "+cFuncao+"."+CRLF," ")+CRLF; //"Favor execute a função"
	+STR0262+" "+If(cNumBol <> Nil,STR0263+" "+cNumBol,STR0264) //"Para mais informações consulte o"###"Boletim Técnico de código"###"Suporte Técnico"
	Local lTermi := If(lTerm = Nil,.F.,lTerm)
	MsgInfo(STR0265+" "+OAPP:CMODDESC+" "+STR0266+CRLF+CRLF+cMenF,STR0215) //"O Sistema de"###"possui incompatibilidade de dicionário."###"NAO CONFORMIDADE"
	If lTermi
		Final(STR0134) //"Termino Normal"
	Else
		Return .F.
	Endif
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³NGRetBuscaºAutor  ³Wagner S. de Lacerdaº Data ³  29/10/2010 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Consulta de diretorios/arquivos.                           º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ cRet -> Diretorio ou Arquivo selecionado.                  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ nTipo   -> Obrigatorio;                                    º±±
±±º          ³            Indica qual o tipo de pesquisa:                 º±±
±±º          ³            1 - Diretorios;                                 º±±
±±º          ³            2 - Arquivos;                                   º±±
±±º          ³ lServer -> Opcional;                                       º±±
±±º          ³            Se True, indica que a busca deve ser feita      º±±
±±º          ³            apenas no servidor.                             º±±
±±º          ³            Default: False.                                 º±±
±±º          ³ cTitulo -> Opcional;                                       º±±
±±º          ³            Indica o titulo da janela de busca.             º±±
±±º          ³            Default: Se nTipo 1 - Selecione o Diretorio;    º±±
±±º          ³                     Se nTipo 2 - Selecione o Arquivo;      º±±
±±º          ³ cFiltro -> Opcional;                                       º±±
±±º          ³            Indica os tipos de arquivo que serao buscados.  º±±
±±º          ³            Default: Pesquisa por todo tipo.                º±±
±±º          ³ cVarRec -> Opcional;                                       º±±
±±º          ³            Indica o conteudo da variavel que recebera o    º±±
±±º          ³            retorno deste funcao.                           º±±
±±º          ³            Default: "". (string vazia)                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SigaMNT                                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º           ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºProgramador ³   Data     ³ Descricao                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º            ³ xx/xx/xxxx ³                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGRetBusca(nTipo,lServer,cTitulo,cFiltro,cVarRec)

	Local cRet
	Local uDirs

	Default lServer := .F.
	Default cTitulo := If( nTipo == 1,STR0267,STR0268 ) //"Selecione o Diretório"###"Selecione o Arquivo" //"Selecione o Diretório"###"Selecione o Arquivo"
	Default cFiltro := "*"
	Default cVarRec := ""

	uDirs := GETF_LOCALHARD+GETF_NETWORKDRIVE
	If lServer
		uDirs := GETF_ONLYSERVER
	EndIf

	If nTipo == 1
		cRet := cGetFile(cFiltro,OemToAnsi(cTitulo),,cVarRec,.T.,uDirs+GETF_RETDIRECTORY)
	ElseIf nTipo == 2
		cRet := cGetFile(cFiltro,OemToAnsi(cTitulo),,cVarRec,.T.,uDirs)
	EndIf

	If Empty(cRet)
		cRet := cVarRec + Space( 100 - Len(cVarRec) )
	Else
		cRet := cRet + Space( 100 - Len(cRet) )
	EndIf

Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³NGCONPDTRBºAutor  ³Roger Rodrigues     º Data ³  17/03/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Monta Consulta F3 a partir de um arquivo temporário         º±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAliasTRB - > Alias do Arquivo temporário já preenchido    ³±±
±±³          ³ aOpcao  - > Array com opçoes de pesquisa do ComboBox       ³±±
±±³          ³ aCabec  - > Array com Titulo de Cabeçalho, Campo TRB       ³±±
±±³          ³ 			(S/ Alias) e Tamanho das colunas                  ³±±
±±³          ³ nMax  - > Tamanho máximo de campo para pesquisa            ³±±
±±³          ³ cTitulo  - > Titulo da Janela                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³ .T. ->Valor Selecionado .F.->Cancelado                     ³±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Génerico                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGCONPDTRB(cAliasTRB,aOpcao,aCabec,nMax,cTitulo)
	Local oDlgCol, oList, lOk := .F., i
	Local cPesq := "", cOpcao:= " "
	Local cCampos := ""//Varíavel para montagem do listbox
	Default aCabec := {}//Campos do Cabeçalho
	Default aOpcao:= {}//Opções do Combo
	Default nMax := 0//Tamanho Máximo a ser pesquisado
	Default cTitulo := STR0269//Titulo da Janela//"Consulta" //"Consulta"
	cPesq := Space(nMax)
	If Len(aOpcao) > 0
		cOpcao := aOpcao[1]
	Endif

	Define MsDialog oDlgCol Title cTitulo Color CLR_BLACK, CLR_WHITE From 0,0 to 27,65 Of oMainWnd

	@005,003 ComboBox oOpc Var cOpcao Items aOpcao Size 195,10 Of oDlgCol Pixel On Change (dbSelectArea(cAliasTRB),dbSetOrder(oOpc:nAt),oList:Refresh())
	@005,205 Button STR0155 Size 40,12 Of oDlgCol Pixel Action (dbSelectArea(cAliasTRB),dbSetOrder(oOpc:nAt),dbSeek(RTrim(cPesq)),oList:Refresh())//"Pesquisar" //"Pesquisar"

	@020,003 MsGet cPesq Size 195,10 Of oDlgCol Pixel Picture "@!"
	dbSelectArea(cAliasTRB)
	dbGoTop()

	@045,000 ListBox oList Fields ON DBLCLICK (lOk:=.T.,oDlgCol:End()) Size 258,140 Of oDlgCol Pixel

	//Define Cabeçalho e campos de acordo com os parametros informados
	aSize(oList:aHeaders ,Len(aCabec))
	aSize(oList:aColSizes,Len(aCabec))
	For i:=1 to Len(aCabec)
		oList:aHeaders[i] := aCabec[i][1]

		If i <> 1
			cCampos += ",('"+cAliasTRB+"')->"
		Else
			cCampos := "{('"+cAliasTRB+"')->"
		Endif
		cCampos += aCabec[i][2]//+"'"
		oList:aColSizes[i] := aCabec[i][3]
	Next i
	If !Empty(cCampos)
		cCampos += "}"
		oList:bLine := {|| &cCampos }
	Endif
	Define sButton oBtnOk From 190,003 Type 1 Of oDlgCol Pixel When .T. Action (lOk := .T., oDlgCol:End())
	Define sButton oBtnOk From 190,033 Type 2 Of oDlgCol Pixel When .T. Action (lOk := .F., oDlgCol:End())
	Define sButton oBtnOk From 190,063 Type 5 Of oDlgCol Pixel

	Activate MsDialog oDlgCol Centered

	If !lOk
		Return .F.
	Endif
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³NGRETSXB   ºAutor  ³Roger Rodrigues     º Data ³ 17/03/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna Valor da função NGCONPDTRB                          º±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCampo - > Campo a ser retornado pela consulta             ³±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Genérico                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGRETSXB(cCampo)
Return &cCampo
//---------------------------------------------------------------------
/*/{Protheus.doc} NGFILTEMP
Cria Opcao de filtro para tabelas temporarias
- cAlias - Alias da tabela temporaria
- aCampos - Array contendo as informacoes dos campos da tabela

@return Nil

@sample
NGFILTEMP(cAlias,aCampos)

@author Guilherme Benkendorf
@since 16/01/2013
@version 1.0
/*/
//---------------------------------------------------------------------
Function NGFILTEMP(cAlias,aCampos)

	Local aAux		 := {}
	Local cFiltroBrw := ""
	Local nPosAlias	 := 0

	Default cAlias 	:= Alias()

	aAux := fNGAltAr(aCampos)//Altera array da tabela temporaria para funcao da BuildExpr

	nPosAlias	:= aScan( aNGFilTemp, {|x| x[1] == cAlias })
	If nPosAlias > 0
		cFiltroBrw := aNGFilTemp[nPosAlias][2]
	EndIf

	cFiltroBrw	:= BuildExpr(/*cAlias*/ ,/*oWnd*/,/*cFilter*/cFiltroBrw,.F.,;
							{|| &("cAlias->( DBGoTop() )")  } ,/*oDlg*/,/*aUsado*/,;
							/*cDesc*/,/*nRow*/,/*nCol*/, aAux,/*lVisibleTopFilter*/,;
							/*lExpBtn*/,/*cTopFilter*/)

	If nPosAlias == 0
		aAdd(aNGFilTemp,{cAlias,cFiltroBrw})
	Else
		aNGFilTemp[nPosAlias][2] := cFiltroBrw
	EndIf

	//Filtra com a condicao escolhida
	dbSelectArea(cAlias)
	Set Filter To &cFiltroBrw

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} fNGAltAr
Cria novo array alterando array dos campos da tabela
temporaria, para poder utilizar na BuildExpr

- aCampos - Array contendo as informacoes dos campos da tabela

@return Nil

@sample
NGFILTEMP(aCampos)

@author Guilherme Benkendorf
@since 16/01/2013
@version 1.0
/*/
//---------------------------------------------------------------------
Static Function fNGAltAr(aCampos)

	Local nX
	Local aAux := {}

	//Formato do array:
	// X3_CAMPO,X3Titulo(),If(!x3Uso(X3_USADO),.F.,.T.),X3_ORDEM,X3_TAMANHO,Trim(X3_PICTURE),X3_TIPO,X3_DECIMAL
	For nX := 1 to Len(aCampos)
		aAdd(aAux,{aCampos[nX][2],aCampos[nX][1],.T.,nX,aCampos[nX][4],aCampos[nX][6],aCampos[nX][3],0})
	Next nX

Return aAux

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGENTRAENC ³Autor ³ Deivys Joenck         ³ Data ³ 14/08/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza aTela e aGets quando e focada a enchoice          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION NGENTRAENC(cALIAS)
	aTELA := aCLONE(aSVATELA)
	aGETS := aCLONE(aSVAGETS)
	DBSELECTAREA(cALIAS)
RETURN

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³ NGSOMALI ³ Autor ³ In cio Luiz Kolling   ³ Data ³17/09/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Incrementa Linha e Controla Salto de Pagina                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nLINP - Quantidades de linhas por p gina                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Gen‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
/*/
Function NGSOMALI(nLINP,lImpPars)
	Default lImpPars := .T.
	Li++
	If Li > nLINP
		Cabec(titulo,cabec1,cabec2,nomeprog,tamanho,nTipo,,lImpPars)
		Li := PROW() + 1
	EndIf
Return
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NGSEMAFARO³ Autor ³ In cio Luiz Kolling   ³ Data ³23/07/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao de valida‡Æo de retorno para semafaro                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ cCONDSEM - Condi‡Æo para valida‡Æo de retorno              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.,.F.                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSEMAFARO(cCONDSEM)
	If &(cCONDSEM)
		Return .T.
	EndIF
Return .F.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³NGCOLOR   ºAutor  ³Wagner S. de Lacerdaº Data ³  10/11/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Define a cor padrao da NG para o fundo de barras lateriais,º±±
±±º          ³ menus, etc., e tambem a cor do texto sobreposto.           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ aColors -> Cores padroes da NG (em RGB ou Hexadecimal)     º±±
±±º          ³               [1] - Cor do Texto                           º±±
±±º          ³               [2] - Cor do Fundo                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cParVersao -> Opcional;                                    º±±
±±º          ³               Define o a Versao do Protheus para escolher  º±±
±±º          ³               qual cor utilizar.                           º±±
±±º          ³               Default: 'cVersao' (variavel publica).       º±±
±±º          ³ cParTipo ---> Opcional;                                    º±±
±±º          ³               Define o o tipo do retorno da Cor:           º±±
±±º          ³                  "N" - Numerico (RGB)                      º±±
±±º          ³                  "H" - Hexadecimal                         º±±
±±º          ³               Default: "N".                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GENERICO                                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º           ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºProgramador ³   Data     ³ Descricao                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º            ³ xx/xx/xxxx ³                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGCOLOR(cParVersao, cParTipo)

	Local aColors := {}

	Local nForeRed   := 0, nBackRed   := 0
	Local nForeGreen := 0, nBackGreen := 0
	Local nForeBlue  := 0, nBackBlue  := 0

	Local uForeColor := Nil, uBackColor := Nil

	Default cParVersao := If(Type("cVersao") == "C",cVersao,"0")
	Default cParTipo   := "N"

	cParVersao := AllTrim(cParVersao)
	cParTipo   := AllTrim(cParTipo)

	If "10" $ cParVersao
		//Texto: Branco
		nForeRed   := 255
		nForeGreen := 255
		nForeBlue  := 255

		//Fundo: Personalizado (Azul meio cinza)
		nBackRed   := 67
		nBackGreen := 70
		nBackBlue  := 87
	Else
		If GetTheme() == "SUNSET"
			//Texto: SteelRed
			nForeRed   := 153
			nForeGreen := 59
			nForeBlue  := 91

			//Fundo: Personalizado (Vermelho claro)
			nBackRed   := 251
			nBackGreen := 240
			nBackBlue  := 240
		Else
			//Texto: SteelBlue
			nForeRed   := 70
			nForeGreen := 130
			nForeBlue  := 180

			//Fundo: Personalizado (Azul claro)
			/*
			nBackRed   := 215
			nBackGreen := 230
			nBackBlue  := 255
			*/
			nBackRed   := 233
			nBackGreen := 240
			nBackBlue  := 246
		EndIf
	EndIf

	If cParTipo == "H" //Hexadecimal
		uForeColor := "#"+NGRGBHEX({nForeRed,nForeGreen,nForeBlue})
		uBackColor := "#"+NGRGBHEX({nBackRed,nBackGreen,nBackBlue})
	Else //Numerico (RGB)
		uForeColor := RGB(nForeRed,nForeGreen,nForeBlue)
		uBackColor := RGB(nBackRed,nBackGreen,nBackBlue)
	EndIf

	aColors := {uForeColor, uBackColor}

Return aColors

//-------------------------------------------------------------------------------
/*/{Protheus.doc} NGSALSB2
Verifica o saldo do produto em estoque.
@type function

@author Inácio Luiz Kolling
@since 04/09/2001

@sample NGSALSB2( '000001', '01', 10, .T. )

@param cVCOD    , Caracter  , Código do Produto.
@param cALMOX   , Caracter  , Código do Almoxifado.
@param nQUANT   , Númerico  , Quantidade Solicitada.
@param lMENSA   , Lógico    , Indicador de saida da mensagem (.T.,.F.).
@param [nDevol] , Númerico, Quantidade que será somada no saldo (como devolução)
@param [lConAlt], Lógico  , Indica se valida alteracao.
@param [cTipIns], Caracter, Tipo do insumo que será consultado.
@param [cFilAux], caracter, Filial
@return Lógico, Indica se o processo foi realizado com êxito.
/*/
//-------------------------------------------------------------------------------
Function NGSALSB2( cVCOD, cALMOX, nQUANT, lMENSA, nDevol, dData, lConAlt, cTipIns, cFilAux )

	Local aArea     := GetArea()
	Local cALMOXAF  := If(Empty(cALMOX),NGSEEK("SB1",cVCOD,1,"B1_LOCPAD"),cALMOX)
	Local lPROBLEM  := .T.
	Local  lSAIDAME	:= If(lMENSA = Nil,.T.,lMENSA)
	Local cTpSaldo	:= AllTrim(SuperGetMV("MV_TPSALDO"))
	Local cFilBkp   := cFilAnt

	Default dData	:= dDataBase
	Default lConAlt := INCLUI //Verificar se valida alteração
	Default cTipIns := ''
	Default cFilAux := cFilAnt
	Default nDevol  := 0

	//--------------------------------------------------------------------------------------------------
	// Tratativa para setar na filial correta pois as funções do estoque não tem parâmetros de filial
	//--------------------------------------------------------------------------------------------------
	If cFilAux != cFilAnt
		cFilAnt := cFilAux
	EndIf

	DbSelectArea("SB2")
	DbSetOrder(1)
	If !Dbseek(xFilial('SB2') + cVCOD + cALMOXAF)
		CriaSB2(cVCOD,cALMOXAF)
	EndIf

	If lPROBLEM

		// Integracao por Mensagem Única
		If GetNewPar( 'MV_NGINTER', '') == 'M'

			If cTipIns == 'M'

				nSaldoP := NGMUStoLvl( MntGetPrdM( cVCOD ), cALMOXAF, .F., cTipIns, cVCOD )

			ElseIf !Empty( cTipIns )

				nSaldoP := NGMUStoLvl( NGMURetIns( cTipIns, cVCOD ), cALMOXAF, .F. )

			Else

				nSaldoP := NGMUStoLvl( cVCOD, cALMOXAF, .F. )

			EndIf

		Else

			If cTpSaldo == "C" //Busca saldo que o estoque tinha na data informada no parâmetro dData
				nSALDOP := CalcEst(SB2->B2_COD,SB2->B2_LOCAL,dData+1)[1]
			ElseIf cTpSaldo == "S" //Retorna saldo atual independente da data

				nSALDOP := SaldoSB2( .F., .F. , dDataBase+3650, .F. ) + nDevol

			ElseIf cTpSaldo == "Q" //Retorna saldo com desconto de quantidade reservada e quantidade a enderecar
				nSALDOP := SB2->B2_QATU - SB2->B2_QACLASS - SB2->B2_RESERVA
			EndIf

		EndIf

		If ( INCLUI .Or. lConAlt ) .And. nSALDOP < nQUANT
			If lSAIDAME
				MsgInfo( STR0270+Chr( 13 )+Chr( 13 ); //"Foi especificado no parâmetro de controle do estoque (MV_ESTNEG)"
				+STR0271+Chr( 13 )+Chr( 13 ); //"Que o este não poderá ficar negativo."
				+STR0272+AllTrim( cVCOD )+Chr( 13 )+Chr( 13 );//"Produto: "
				+STR0273+cALMOXAF+Chr( 13 )+Chr( 13 ); //Armazém: "
				+STR0274+Str( nSALDOP, 14, 2 )+Chr( 13 )+Chr( 13 ); //"Saldo Atual: "
				+STR0275+Str( nQUANT, 14, 2 ), STR0025 ) //"Quant. Entr.: "###"Atenção"
			Endif
			lPROBLEM := .F.
		EndIf
	EndIf

	//-------------------------------------
	// Restaura filial
	//-------------------------------------
	If cFilBkp != cFilAnt
		cFilAnt := cFilBkp
	EndIf

	RestArea( aArea )

Return lPROBLEM

//------------------------------------------------------------------------------------
/*/{Protheus.doc} NGCONVERHORA
Converte hora de sexagesimal para centesimal ou inverso.
@type function

@author Inácio Luiz Kolling
@since 30/04/2004

@sample NGCONVERHORA( 1.5, 'D', 'S' )

@param  nVQDTHORA  , Númerico, Quantidade de horas.
@param  cVTIPHORA  , Caracter, Tipo da hora origem ( D = 100, <> 60 ).
@param  [cVPTIPHOR], Caracter, Tipo de conversão ( D = 100, <> 60 ).
@param  [cEMP]     , Caracter, Código da Empresa.
@param  [nDec]     , Númerico, Quantidade retornada após a virgula.
@return Númerico   , VAlor da hora convertida.
/*/
//------------------------------------------------------------------------------------
Function NGCONVERHORA( nVQDTHORA, cVTIPHORA, cVPTIPHOR, cEMP, nDec )
	Local nPARTINTE := Int(nVQDTHORA), nPARTREST := nVQDTHORA-nPARTINTE
	Local cCONVPARA := If(cVPTIPHOR = Nil,AllTrim(GetNewPar("MV_NGUNIDT")),cVPTIPHOR)
	Local nHORACONV := nVQDTHORA

	Default nDec := 0

	If cVTIPHORA <> cCONVPARA
		If cVTIPHORA = "D"
			If cCONVPARA <> "D"
				nMINCONVE := (nPARTREST / 100) * 60
				cPARTINTE := Alltrim(Str(nPARTINTE,10))
				cPARTRPON := Alltrim(Str(nMINCONVE,10,2))
				nPOSPONTO := At(".",cPARTRPON)
				cPARTREST := Substr(cPARTRPON,nPOSPONTO,Len(cPARTRPON))
				cHORACONV := cPARTINTE+cPARTREST
				nHORACONV := Val(cHORACONV)
			Endif
		Else
			If cCONVPARA = "D"
				nMINCONVE := (nPARTREST * 100) / 60
				cPARTINTE := Alltrim(Str(nPARTINTE,10))

				// CASO O VALOR COMPLETO DOS DECIMAIS SEJA REQUISITADO.
				If nDec > 0

					// RETORNA TODOS OS VALORES APÓS A VIRGULA.
					cPARTRPON := AllTrim( Str( nMINCONVE, 10, nDec ) )

				// CASO NÃO SEJA REQUISITADO O VALOR COMPLETO CONTENDO OS DECIMAIS.
				Else

					// RETORNA APENAS DUAS CASAS APÓS A VIRGULA.
					cPARTRPON := AllTrim( Str( nMINCONVE, 10, 2 ) )

				EndIf

				nPOSPONTO := At(".",cPARTRPON)
				cPARTREST := Substr(cPARTRPON,nPOSPONTO,Len(cPARTRPON))
				cHORACONV := cPARTINTE+cPARTREST
				nHORACONV := Val(cHORACONV)
			Endif
		Endif
	Endif
Return nHORACONV

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCONDTSB8 ³ Autor ³ Vitor Emanuel Batista ³ Data ³02/03/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Consiste data de validade do produto quando houver rastreabi-³±±
±±³          ³lidade dos Lotes de Produtos                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaMNT                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGCONDTSB8(dData)

	If !Empty(dData) .And. (dData < dDataBase)
		If MsgYesNo(STR0276+CHR(13)+; //"A Data de Validade do produto informado está vencida." //"A Data de Validade do produto informado está vencida."
		STR0277+DtoC(dDataBase)+CHR(13)+;//"Data Atual.......: " //"Data Atual.......: "
		STR0278+DtoC(dData)+CHR(13)+CHR(13)+; //"Data Validade.: " //"Data Validade.: "
		STR0279,STR0025)//"Deseja continuar?" ## "ATENÇÃO" //"Deseja continuar?"###"ATENCAO"
		Else
			Return .F.
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³  NGVersao    ³ Autor ³ Rafael Diogo Richter  ³ Data ³23/02/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao para controle de versao de fontes da NG. Mostra em qual  ³±±
±±³          ³versao do fonte o cliente esta no momento.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cProg   -> Nome do Programa;                                    ³±±
±±³          ³nVersao -> Numero da versao em que o fonte se encontra.         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaMNT, SigaMDT, SigaSGA                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ F.O  ³  Motivo da Alteracao                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³            ³        ³      ³                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGVersao(cProg, nVersao)
	MsgInfo(STR0280+AllTrim(cProg)+CHR(13)+CHR(10)+; //	"Rotina:	" //"Rotina:	"
	STR0281+AllTrim(StrZero(nVersao,3)),STR0282) //"Versão:	"#"Informação" //"Versão:	"###"Informação"
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} NGSX2MODO
Verifica o tipo de compartilhamento do arquivo/tabela

@author author
@since  24/05/2006
@source Generico
@param  cAliasA   - Codigo do alias do arquivo/tabela / Obrigatório
@param  cEmpresa  - Codigo da empresa para verificar o X2_MODO
/*/
//-------------------------------------------------------------------
Function NGSX2MODO(cAliasA,cEmpresa)

	Local aAreaCe := GetArea()
	Local cModo   := ''

	cModo := FWModeAccess(cAliasA,3,cEmpresa) //Função contempla o uso do grupo de empresa

	RestArea(aAreaCe)

Return cModo

//-------------------------------------------------------------------
/*/{Protheus.doc} NgHelp
Funcao para gravar o Help de campo nos campos criados via
atualizador de dicionario.

@author  Thiago Olis Machado
@since   27/03/2007
@Obs Está função foi descontinuada e poderá ser retirada na próxima
versão.
/*/
//-------------------------------------------------------------------
Function NgHelp(cHelp,cHlpVar,lSX1,cLang,cSolucao)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGRIGHTCLICK³Autor ³Vitor Emanuel Batista ³ Data ³ 16/05/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna uma Array para utilizacao do click da direita      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cProg   - Programa (Obrigatorio)                           ³±±
±±³          ³ cSequen - Numero(s) da(s) sequencia(s) a ser incluido na   ³±±
±±³          ³ array (01,02,03,04,05,06,07,08,09 e/ou A)                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGRIGHTCLICK(cProg,cSequen,aRemoveBtn )
	Local nAt, nCnt := 0
	Local aCols   := {}
	Local lImagem := NGCADICBASE("TQD_IMAGEM","D","TQD",.F.)
	Local nCol    := If(lImagem,3,2)
	Local lAtivar := NGCADICBASE("TQD_ATIVAR","D","TQD",.F.)
	Local cNomeFuncao
	Default cSequen := ""
	Default aRemoveBtn := {}

	If (NGCADICBASE("TQC_PROGRA","D","TQC",.F.) .And. NGCADICBASE("TQD_PROGRA","D","TQD",.F.))

		dbSelectArea("TQC")
		dbSetOrder(1)
		If dbSeek(xFilial("TQC")+cProg)
			dbSelectArea("TQD")
			dbSetOrder(2)
			dbSeek(xFilial("TQD")+cProg)
			While !EOF() .And. TQD->TQD_FILIAL + Trim(TQD->TQD_PROGRA) == xFilial("TQD") + Trim(cProg)

				cNomeFuncao := AllTrim( Upper( TQD->TQD_FUNCAO ) )

				If aScan( aRemoveBtn , { |x| AllTrim( Upper( x ) ) == cNomeFuncao }) > 0
					dbSelectArea("TQD")
					dbSkip()
					Loop
				EndIf

				If (Empty(cSequen) .OR. (Trim(TQD->TQD_SEQUEN) $ cSequen))
					If lAtivar
						If TQD->TQD_ATIVAR == "2"
							dbSelectArea("TQD")
							dbSkip()
							Loop
						EndIf
					EndIf
					nCnt++
					aAdd(aCOLS,Array(nCol))

					aCOLS[nCnt][1] := Capital( TQD->TQD_DESPOR )

					If !Empty(At("(",Trim(TQD->TQD_FUNCAO)))
						nAt := At("(",Trim(TQD->TQD_FUNCAO))-1
					Else
						nAt := len(Trim(TQD->TQD_FUNCAO))
					EndIf

					aCOLS[nCnt][2] := Substr(TQD->TQD_FUNCAO,0,nAt) + "(" + Trim(TQD->TQD_PARAM) + ")"
					aCOLS[nCnt][2] := "!NGCALLSTACK('"+Substr(TQD->TQD_FUNCAO,0,nAt)+"',.T.) .And. " + aCOLS[nCnt][2]

					If lImagem
						aCOLS[nCnt][3] := If(!Empty(TQD->TQD_IMAGEM),TQD->TQD_IMAGEM,Nil)
					EndIf

				EndIf
				dbSelectArea("TQD")
				dbSkip()
			EndDo
		EndIf

	EndIf

Return aCOLS

//----------------------------------------------------------------
/*/{Protheus.doc} NGTQCTQD
Funcao que importa todos os dados do click da direita para
as tabelas TQC(Programas Click da Direita) e TQD(Chamadas
Click Direita). Podendo ser visualizada no programa MNTA960

@author Vitor Emanuel Batista
@since 31/07/2014

@param nVerOld - Versão antiga da execução da função
	   nVerAtu - Versão atual da função

@versiON MP11
/*/
//----------------------------------------------------------------
Function NGTQCTQD(nVerOld,nVerAtu)
	
	Local aArrDad   := {}
	Local aMenuItem := {}
	Local cRotMenu
	Local cActClick
	Local nX
	Local nFo
	Local nFo2
	Local nTamTqdPro := 0
	Local nTamTqdFun := 0
	Local lNGMNTCC := .T.
	
	Default nVerOld := 0
	Default nVerAtu := 1

	If nVerOld < nVerAtu

		lNGMNTCC   := SuperGetMv( 'MV_NGMNTCC', .F., 'N' ) == 'S'
		nTamTqdPro := TAMSX3( "TQD_PROGRA" )[1]
		nTamTqdFun := TAMSX3( "TQD_FUNCAO" )[1]

		Aadd(aArrDad,{"MNTA010",STR0283,{}}) //"Programa de Especialidades"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC565",".T.",STR0284}) //"Onde-Se-Usa"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC010",".T.",STR0285}) //"Funcionarios Da Especialidade"
		Aadd(aArrDad[Len(aArrDad),3],{"CONOSPEND","'E',ST0->T0_ESPECIA",STR0286}) //"O.S. Pendentes"

		Aadd(aArrDad,{"MDTA114",STR0287,{}}) //"Cadastro de Programas de Saude e Exames"
		Aadd(aArrDad[Len(aArrDad),3],{"MDTA115","M->TMO_CODPRO",STR0288}) //"Funcionarios por Programa"

		Aadd(aArrDad,{"MDTA145",STR0289,{}}) //"Programa Cadastros de Questionario Medico"
		Aadd(aArrDad[Len(aArrDad),3],{"EXAME120","",STR0290}) //"Exames do Funcionario"

		Aadd(aArrDad,{"MDTA155",STR0291,{}}) //"Registrar os Diagnosticos Medicos."
		Aadd(aArrDad[Len(aArrDad),3],{"NG155PREP","",STR0290}) //"Exames do Funcionario"
		Aadd(aArrDad[Len(aArrDad),3],{"MDTR407","M->TMT_NUMFIC,M->TMT_DTCONS,M->TMT_HRCONS,M->TMT_CODUSU",STR0292}) //"Receita Medica"
		Aadd(aArrDad[Len(aArrDad),3],{"MDTA110P","'MDTA155'",STR0293}) //"Ocorrencias da Ficha Medica"
		Aadd(aArrDad[Len(aArrDad),3],{"MDT160FWEX","",STR0294}) //"Encaminhamento de Exames"
		Aadd(aArrDad[Len(aArrDad),3],{"MDTAHIS","",STR0295}) //"Historico corrido do Paciente"
		Aadd(aArrDad[Len(aArrDad),3],{"NG160ATES","",STR0296}) //"Atestados Medicos"

		Aadd(aArrDad,{"MDTA160",STR0297,{}}) //"Programa de Atendimento Medico."
		Aadd(aArrDad[Len(aArrDad),3],{"NG160PREP","",STR0290}) //"Exames do Funcionario"
		Aadd(aArrDad[Len(aArrDad),3],{"Diag160","",STR0298}) //"Diagnosticos Realizados do Funcionario"
		Aadd(aArrDad[Len(aArrDad),3],{"MDTA110P","'MDTA160'",STR0293}) //"Ocorrencias da Ficha Medica"
		Aadd(aArrDad[Len(aArrDad),3],{"MDTR407","M->TMT_NUMFIC,M->TMT_DTCONS,M->TMT_HRCONS,M->TMT_CODUSU",STR0292}) //"Receita Medica"
		Aadd(aArrDad[Len(aArrDad),3],{"MDTAHIS","",STR0295}) //"Historico corrido do Paciente"
		Aadd(aArrDad[Len(aArrDad),3],{"MDT160FWEX","",STR0294}) //"Encaminhamento de Exames"
		Aadd(aArrDad[Len(aArrDad),3],{"NG160RIS","",STR0300}) //"Riscos do Funcionario"
		Aadd(aArrDad[Len(aArrDad),3],{"QuesHis160","",STR0301}) //"Historico de Questionarios Medicos"
		Aadd(aArrDad[Len(aArrDad),3],{"A160QUEST","",STR0302}) //"Questionario Medico"

		Aadd(aArrDad,{"MDTA685",STR0303,{}}) //"Programa de Cadastro de Atestado Medico"
		Aadd(aArrDad[Len(aArrDad),3],{"NGDIAG","",STR0304}) //"Diagnosticos"
		Aadd(aArrDad[Len(aArrDad),3],{"NG155PREP","",STR0290}) //"Exames do Funcionario"
		Aadd(aArrDad[Len(aArrDad),3],{"MDTR407","M->TMT_NUMFIC,M->TMT_DTCONS,M->TMT_HRCONS,M->TMT_CODUSU",STR0292}) //"Receita Medica"
		Aadd(aArrDad[Len(aArrDad),3],{"MDTA110P","'MDTA155'",STR0293}) //"Ocorrencias da Ficha Medica"
		Aadd(aArrDad[Len(aArrDad),3],{"MDTAHIS","",STR0295}) //"Historico corrido do Paciente"

		Aadd(aArrDad,{"MNTA040",STR0305,{}}) //"Programa de atualizacao de Servicos"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC040MN","",STR0306}) //"Manutencoes"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC040","",STR0307}) //"Ordens Servico"

		Aadd(aArrDad,{"MNTA050",STR0308,{}}) //"Programa de manutencao de Familia de Bens"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC050","M->T6_CODFAMI",STR0309}) //"Bens da Familia"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC051","M->T6_CODFAMI",STR0310}) //"Ordem Servico da Familia"

		Aadd(aArrDad,{"MNTA060",STR0311,{}}) //"Programa de Desgaste por Producao"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC060","M->TR_CODBEM,M->TR_BEMFAMI",STR0312}) //"Desgaste Informados"

		Aadd(aArrDad,{"MNTA070",STR0313,{}}) //"Programa de manutencao de Fabricantes de Bens"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC070","M->T7_FABRICA",STR0314}) //"Bens Fabricante"

		Aadd(aArrDad,{"MNTA080",STR0315,{}}) //"Bens de Manutencao"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC600CON","",STR0306}) //"Manutencoes"
		Aadd(aArrDad[Len(aArrDad),3],{"MNA080CON","",STR0316}) //"Historico"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC090","M->T9_CODBEM,.T.",STR0317}) //"Manut. Estrutura"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC600ORD","",STR0307}) //"Ordens Servico"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTSEGU","M->T9_CODBEM,nOPCAO",STR0318}) //"Segundo Contador"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA080HCO","M->T9_CODBEM",STR0319}) //"Historico do Contador"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA080COM","M->T9_CODBEM",STR0320}) //"Local. Componente Estrutura"
		Aadd(aArrDad[Len(aArrDad),3],{"MNT080PERP","",STR0321}) //"Util.Pecas de Reposicao"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA080HST","M->T9_CODBEM",STR0322}) //"Historico do Status"
		Aadd(aArrDad[Len(aArrDad),3],{"NGACOPLAD","M->T9_CODBEM",STR0323}) //"Acoplamento/Desacoplamento"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC085","M->T9_CODBEM",STR0324,'NGULTTQD("MNTA080 ")'}) //"Curva da Banheira"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC075","M->T9_CODBEM",STR0325,'NGULTTQD("MNTA080 ")'}) //"Curva de Custos"
		Aadd(aArrDad[Len(aArrDad),3], {"MNTA830", "M->T9_CODBEM", STR0451, 'NGULTTQD("MNTA080 ")' }) //"Informa Contador"
		Aadd(aArrDad[Len(aArrDad),3], {"MNTA490", "'B',M->T9_CODBEM", STR0452, 'NGULTTQD("MNTA080 ")'}) //"Liberação O.S."
		Aadd(aArrDad[Len(aArrDad),3], {"MNTA875", "M->T9_CODBEM", STR0453, 'NGULTTQD("MNTA080 ")'}) //"Acerto de Contador"
		Aadd(aArrDad[Len(aArrDad),3], {"MNTA450", "M->T9_CODBEM", STR0454, 'NGULTTQD("MNTA080 ")'}) //"O.S. Reforma"
		Aadd(aArrDad[Len(aArrDad),3], {"MNTA460", "M->T9_CODBEM", STR0455, 'NGULTTQD("MNTA080 ")'}) //"Retorno O.S. Reforma"
		Aadd(aArrDad[Len(aArrDad),3], {"MNTA655", "M->T9_CODBEM", STR0456, 'NGULTTQD("MNTA080 ")'}) //"Abast. Manual"

		If lNGMNTCC// Verifica se utiliza template construção civil
			Aadd(aArrDad[Len(aArrDad),3],{"MNTA688","M->T9_CODBEM",STR0415})//"Especificação Material Rodante"
		EndIf

		Aadd(aArrDad,{"MNTA082",STR0315,{}}) //"Veiculos"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC600CON","",STR0306}) //"Manutencoes"
		Aadd(aArrDad[Len(aArrDad),3],{"MNA080CON","",STR0316}) //"Historico"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC090","M->T9_CODBEM,.T.",STR0317}) //"Manut. Estrutura"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC600ORD","",STR0307}) //"Ordens Servico"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA080HCO","M->T9_CODBEM",STR0319}) //"Historico do Contador"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA080COM","M->T9_CODBEM",STR0320}) //"Local. Componente Estrutura"
		Aadd(aArrDad[Len(aArrDad),3],{"MNT080PERP","",STR0321}) //"Util.Pecas de Reposicao"
		Aadd(aArrDad[Len(aArrDad),3],{"NGACOPLAD","M->T9_CODBEM",STR0323}) //"Acoplamento/Desacoplamento"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC085","M->T9_CODBEM",STR0324,'NGULTTQD("MNTA082 ")'}) //"Curva da Banheira"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC075","M->T9_CODBEM",STR0325,'NGULTTQD("MNTA082 ")'}) //"Curva de Custos"

		If lNGMNTCC // Verifica se utiliza template construção civil
			Aadd(aArrDad[Len(aArrDad),3],{"MNTA688","M->T9_CODBEM",STR0415})//"Especificação Material Rodante"
		EndIf

		Aadd(aArrDad,{"MNTA083",STR0315,{}}) //"Bens de Manutencao"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC600CON","",STR0306}) //"Manutencoes"
		Aadd(aArrDad[Len(aArrDad),3],{"MNA080CON","",STR0316}) //"Historico"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC090","M->T9_CODBEM,.T.",STR0317}) //"Manut. Estrutura"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC600ORD","",STR0307}) //"Ordens Servico"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA080HCO","M->T9_CODBEM",STR0319}) //"Historico do Contador"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA080COM","M->T9_CODBEM",STR0320}) //"Local. Componente Estrutura"
		Aadd(aArrDad[Len(aArrDad),3],{"MNT080PERP","",STR0321}) //"Util.Pecas de Reposicao"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA080SUH","M->T9_CODBEM","Historico do Sulco"}) //"Historico do Sulco"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA080HST","M->T9_CODBEM",STR0322}) //"Historico do Status"
		Aadd(aArrDad[Len(aArrDad),3],{"NGACOPLAD","M->T9_CODBEM",STR0323}) //"Acoplamento/Desacoplamento"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC085","M->T9_CODBEM",STR0324,'NGULTTQD("MNTA080 ")'}) //"Curva da Banheira"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC075","M->T9_CODBEM",STR0325,'NGULTTQD("MNTA080 ")'}) //"Curva de Custos"

		If lNGMNTCC // Verifica se utiliza template construção civil
			Aadd(aArrDad[Len(aArrDad),3],{"MNTA688","M->T9_CODBEM",STR0415})//"Especificação Material Rodante"
		EndIf

		Aadd(aArrDad,{"MNTA084",STR0315,{}}) //"Veiculos"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC600CON","",STR0306}) //"Manutencoes"
		Aadd(aArrDad[Len(aArrDad),3],{"MNA080CON","",STR0316}) //"Historico"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC090","M->T9_CODBEM,.T.",STR0317}) //"Manut. Estrutura"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC600ORD","",STR0307}) //"Ordens Servico"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA080HCO","M->T9_CODBEM",STR0319}) //"Historico do Contador"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA080COM","M->T9_CODBEM",STR0320}) //"Local. Componente Estrutura"
		Aadd(aArrDad[Len(aArrDad),3],{"MNT080PERP","",STR0321}) //"Util.Pecas de Reposicao"
		Aadd(aArrDad[Len(aArrDad),3],{"NGACOPLAD","M->T9_CODBEM",STR0323}) //"Acoplamento/Desacoplamento"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC085","M->T9_CODBEM",STR0324,'NGULTTQD("MNTA082 ")'}) //"Curva da Banheira"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC075","M->T9_CODBEM",STR0325,'NGULTTQD("MNTA082 ")'}) //"Curva de Custos"

		If lNGMNTCC // Verifica se utiliza template construção civil
			Aadd(aArrDad[Len(aArrDad),3],{"MNTA688","M->T9_CODBEM",STR0415})//"Especificação Material Rodante"
		EndIf

		Aadd(aArrDad,{"MNTA090",STR0326,{}}) //"Estrutura de Bem"
		Aadd(aArrDad[Len(aArrDad),3],{"MNT90OSCOR","",STR0327}) //"O.S.Corretiva"
		Aadd(aArrDad[Len(aArrDad),3],{"NGC090","(cTRBSTC)->TC_COMPONE",STR0328}) //"Consulta de O.S"

		Aadd(aArrDad,{"MNTA100",STR0329,{}}) //"Programa de manutencao de Areas de Mantencao "
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC100","M->TD_CODAREA",STR0327}) //"O.S.Corretiva"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC105","M->TD_CODAREA",STR0306}) //"Manutencoes"

		Aadd(aArrDad,{"MNTA110",STR0330,{}}) //"Programa de manutencao de Tipos de Manutencao"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC110","M->TE_TIPOMAN",STR0331}) //"Servicos"

		Aadd(aArrDad,{"MNTA120",STR0332,{}}) //"Funcao para montatgem de folder"
		Aadd(aArrDad[Len(aArrDad),3],{"OSHISTORI","'STF',RECNO(),2,,M->TF_CODBEM,M->TF_SERVICO,M->TF_SEQRELA",STR0333}) //"Historico da Manutencao"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC120","M->TF_CODBEM,M->TF_SERVICO,M->TF_SEQRELA",STR0334}) //"Manutencao da Estrutura"
		Aadd(aArrDad[Len(aArrDad),3],{"MNT120PROX","M->TF_CODBEM",STR0335}) //"Data da Prox. Manutencao"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA120OP","",STR0336}) //"Ordem Servico Pendentes"
		Aadd(aArrDad[Len(aArrDad),3],{"MNT120GEOS","",STR0337,'NGULTTQD("MNTA120 ")'}) //"Abrir O.S Manual"

		If lNGMNTCC // Verifica se utiliza template construção civil
			Aadd(aArrDad[Len(aArrDad),3],{"MNTA689","M->TF_CODBEM",STR0416})//"Percentual de Material Desgastante"
		EndIf

		Aadd(aArrDad,{"MNTA150",STR0338,{}}) //"Programa de Bloqueio de Recrusos "
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC150","",STR0339}) //"Ordem Servico do Bloqueio"

		Aadd(aArrDad,{"MNTA160",STR0338,{}}) //"Programa de Bloqueio de Recrusos "
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC160","M->TK_CODFUNC",STR0339}) //"Ordem Servico do Bloqueio"

		Aadd(aArrDad,{"MNTA180",STR0340,{}}) //"Bens de Manutencao Padrao "
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC180","M->TPF_CODFAM",STR0341}) //"Onde-Se-Usa Padrao"

		Aadd(aArrDad,{"MNTA230",STR0342,{}}) //"Esquemas de Rodados"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA230COM","",STR0343}) //"Composicao"

		Aadd(aArrDad,{"MNTA231",STR0344,{}}) //"Monta a Estrutura de Rodados"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA231COM","",STR0343}) //"Composicao"
		Aadd(aArrDad,{"MNTA400",STR0345,{}}) //"Programa Retorno OS"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA420RO","",STR0342}) //"Esquema de Rodados"

		Aadd(aArrDad,{"MNTA420",STR0345,{}}) //"Programa para OS corretivas"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC600CON","M->TJ_CODBEM",STR0306}) //"Manutencoes"
		Aadd(aArrDad[Len(aArrDad),3],{"MNA420CON","M->TJ_CODBEM",STR0316}) //"Historico"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC420MAES","M->TJ_CODBEM",STR0317}) //"Manut. Estrutura"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC420ORD","M->TJ_CODBEM",STR0307}) //"Ordens Servico"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA080HCO","M->TJ_CODBEM",STR0319}) //"Historico do Contador"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTA080COM","M->TJ_CODBEM",STR0320}) //"Local. Componente Estrutura"
		Aadd(aArrDad[Len(aArrDad),3],{"MNT420PERP","M->TJ_CODBEM",STR0321}) //"Util.Pecas de Reposicao"
		If GetMv("MV_NGMNTQN") == "S" .And. !NGIFDBSEEK("TQD","MNTA420 "+"MNT420QNC",1)
			Aadd(aArrDad[Len(aArrDad),3],{"MNTA420QNC","M->TJ_FILQNC,M->TJ_FNC,M->TJ_REVQFNC",STR0215,'NGUltTQD("MNTA420 ")'}) //"NAO CONFORMIDADE"
		EndIf

		Aadd(aArrDad,{"MNTA765",STR0346,{}}) //"Programa de Cadastro de Multas"
		Aadd(aArrDad[Len(aArrDad),3],{"MNT765NF","",STR0347}) //"Notas Fiscais"

		Aadd(aArrDad,{"MNTA910",STR0348,{}}) //"Funcoes de integracao com a PLANTA GRAFICA"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC600CON","",STR0306}) //"Manutencoes"
		Aadd(aArrDad[Len(aArrDad),3],{"MNC510CON","",STR0316}) //"Historico"
		Aadd(aArrDad[Len(aArrDad),3],{"MNTC090","m->t9_codbem,.T.","Manut. Estrutura"})
		Aadd(aArrDad[Len(aArrDad),3],{"MNC600ORD","",STR0307}) //"Ordens Servico"

		Aadd(aArrDad,{"SGAA010",STR0349,{}}) //"Programa para cadastrar legislacao em vigor"
		Aadd(aArrDad[Len(aArrDad),3],{"SG010SITE","",STR0350}) //"Ir ao Site Relacionado"

		Aadd(aArrDad,{"SGAA100",STR0351,{}}) //"Programa para cadastrar nivel organizacional da empresa."
		Aadd(aArrDad[Len(aArrDad),3],{"Sg100Local","'X','','',3,1",STR0352}) //"Identificacao"
		Aadd(aArrDad[Len(aArrDad),3],{"Sg100Del","",STR0353}) //"Excluir"

		Aadd(aArrDad,{"SGAC030",STR0354,{}}) //"Programa para Avaliar Aspectos e Impactos Ambientais"
		Aadd(aArrDad[Len(aArrDad),3],{"Sgc030Val","",STR0355}) //"Documentos Relacionados"
		Aadd(aArrDad[Len(aArrDad),3],{"Sgc030Vi","",STR0203}) //"Visualizar"

		If GetMv("MV_NGMNTES") == "S"
			If !NGIFDBSEEK("TQD","MNTA401 "+"01",2)
				Aadd(aArrDad,{"MNTA401",STR0356,{}}) //"Retorno de O.S. em Lote"
				Aadd(aArrDad[Len(aArrDad),3],{"MNTC290","",STR0357}) //"Solicitação de Compra"
			EndIf

			If !NGIFDBSEEK("TQD","MNTA435 "+"01",2)
				Aadd(aArrDad,{"MNTA435",STR0358,{}}) //"Retorno de OS (Modelo 2)"
				Aadd(aArrDad[Len(aArrDad),3],{"MNTC290","",STR0357}) //"Solicitação de Compra"
			EndIf

			If !NGIFDBSEEK("TQD","MNTA480 "+"01",2)
				Aadd(aArrDad,{"MNTA480",STR0359,{}}) //"Retorno de Etapas em Lote"
				Aadd(aArrDad[Len(aArrDad),3],{"MNTC290","",STR0357}) //"Solicitação de Compra"
			EndIf
		EndIf

		If !NGIFDBSEEK("TQD","MNTA420 "+"09",2)
			Aadd(aArrDad,{"MNTA420",STR0360,{}}) //"Consulta de Ordem de Serviço"
			Aadd(aArrDad[Len(aArrDad),3],{"MNTC755","M->TJ_ORDEM",STR0360,'NGULTTQD("MNTA420 ")'}) //"Consulta de Ordem de Serviço"
		EndIf

		If NGIFDBSEEK("TQD","MNTA010 "+"MNTC565",1) .And. ALLTRIM(TQD->TQD_PARAM) == "M->T0_ESPECIA"
			RecLock("TQD",.F.)
			DbDelete()
			MsunLock("TQD")
		EndIf

		If NGIFDBSEEK("TQD","MNTA010 "+"MNTC010",1) .And. ALLTRIM(TQD->TQD_PARAM) == "M->T0_ESPECIA"
			RecLock("TQD",.F.)
			DbDelete()
			MsunLock("TQD")
		EndIf

		If NGIFDBSEEK("TQD","MNTA010 "+"CONOSPEND",1) .And. ALLTRIM(TQD->TQD_PARAM) == "tipoins,ST0->T0_ESPECIA"
			RecLock("TQD",.F.)
			DbDelete()
			MsunLock("TQD")
		EndIf

		If NGIFDBSEEK( 'TQD', 'MNTA080 ' + 'MNTA080PER', 1 )
			
			RecLock( 'TQD', .F. )
			
				dbDelete()
			
			MsUnLock()
		
		EndIf

		If NGIFDBSEEK( 'TQD', 'MNTA082 ' + 'MNTA080PER', 1 )
			
			RecLock( 'TQD', .F. )
			
				dbDelete()
			
			MsUnLock()
		
		EndIf

		If NGIFDBSEEK( 'TQD', 'MNTA083 ' + 'MNTA080PER', 1 )
			
			RecLock( 'TQD', .F. )
			
				dbDelete()
			
			MsUnLock()
		
		EndIf

		If NGIFDBSEEK( 'TQD', 'MNTA084 ' + 'MNTA080PER', 1 )
			
			RecLock( 'TQD', .F. )
			
				dbDelete()
			
			MsUnLock()
		
		EndIf

		If NGIFDBSEEK( 'TQD', 'MNTA420 ' + 'MNTA420PER', 1 )
			
			RecLock( 'TQD', .F. )
			
				dbDelete()
			
			MsUnLock()
		
		EndIf

		For nFo := 1 To Len(aArrDad)
			cChaveX := Alltrim(aArrDad[nFo,1])
			cChaveA := cChaveX+Space(Len(TQC->TQC_PROGRA)-Len(cChaveX) )
			If !NGIFDBSEEK("TQC",cChaveA,1)
				RecLock("TQC",.T.)
				TQC->TQC_FILIAL := xFilial("TQC")
				TQC->TQC_PROGRA := aArrDad[nFo,1]
				TQC->TQC_DESCRI := aArrDad[nFo,2]
				TQC->(MsunLock())
			EndIf
			For nFo2 := 1 To Len(aArrDad[nFo,3])
				nIndA := 2
				If Len(aArrDad[nFo,3,nFo2]) > 3 .And. !Empty(aArrDad[nFo,3,nFo2,4])
					cSeqd   := NGULTTQD(cChaveA)
					cFuncA  := Alltrim(aArrDad[nFo,3,nFo2,1])
					cChaveP := cChaveA+cFuncA+Space(Len(TQD->TQD_FUNCAO)-Len(cFuncA))
					nIndA   := 1
				Else
					cSeqd   := StrZero(nFo2,2)
					cChaveP := cChaveA+cSeqd
				EndIf
				If !NGIFDBSEEK("TQD",cChaveP,nIndA)
					RecLock("TQD",.T.)
					TQD->TQD_FILIAL := xFilial("TQD")
					TQD->TQD_PROGRA := aArrDad[nFo,1]
					TQD->TQD_SEQUEN := cSeqD
					TQD->TQD_TIPOFU := "1"
					TQD->TQD_FUNCAO := aArrDad[nFo,3,nFo2,1]
					TQD->TQD_PARAM  := aArrDad[nFo,3,nFo2,2]
					TQD->TQD_DESPOR := aArrDad[nFo,3,nFo2,3]
					TQD->TQD_DESING := aArrDad[nFo,3,nFo2,3]
					TQD->TQD_DESESP := aArrDad[nFo,3,nFo2,3]
					TQD->TQD_ATIVAR := "1"
					TQD->(MsunLock())
				EndIf
			Next nFo2
		Next nFo

		//------------------------------------------------------------
		// Alterações de Intens do Click da Direita
		//------------------------------------------------------------
		aAdd( aMenuItem , { "MNTA080" , "MNTSEGU" , "M->T9_CODBEM,ST9->T9_TEMCONT,nOPCAO" } )
		aAdd( aMenuItem , { "MNTA050" , "MNTC050" , "ST6->T6_CODFAMI" } )
		aAdd( aMenuItem , { "MNTA050" , "MNTC051" , "ST6->T6_CODFAMI" } )
		aAdd( aMenuItem , { "MNTA070" , "MNTC070" , "ST7->T7_FABRICA" } )
		aAdd( aMenuItem , { "MNTA110" , "MNTC110" , "STE->TE_TIPOMAN" } )

		DbSelectArea( "TQD" )
		DbSetOrder( 01 ) // TQD_FILIAL + TQD_PROGRA + TQD_FUNCAO
		For nX := 1 To Len( aMenuItem )

			cRotMenu	:= PadR( aMenuItem[nX][1] , nTamTqdPro )
			cActClick	:= PadR( aMenuItem[nX][2] , nTamTqdFun )

			If DbSeek( xFilial ( "TQD" ) + cRotMenu + cActClick ) .And.;
			AllTrim( TQD->TQD_PARAM  ) != aMenuItem[nX][3]
				RecLock( "TQD", .F. )
				TQD->TQD_PARAM := aMenuItem[nX][3]
				MsUnLock( "TQD" )
			EndIf
		Next nX

	EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ NGUltTQD ³ Autor ³Vitor Emanuel Batista  ³ Data ³18/03/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna a proxima sequencia para o clique da direita        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cPrograma - Ultima sequencia para o programa                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGUltTQD(cPrograma)
	Local aAreaTQD := TQD->(GetArea())
	Local cProgra  := AllTrim(cPrograma),cUltimaS := Space(Len(TQD->TQD_SEQUEN))
	Local cChaveD  := cProgra+Space(Len(TQC->TQC_PROGRA)-Len(cProgra))

	NGIFDBSEEK("TQD",cChaveD,2)
	While !Eof() .And. xFilial("TQD") == TQD->TQD_FILIAL .And. TQD->TQD_PROGRA == cChaveD
		cUltimaS := TQD->TQD_SEQUEN
		dbSkip()
	End
	RestArea(aAreaTQD)
Return If(Empty(cUltimaS),"01",If(FindFunction("Soma1Old"),Soma1Old(cUltimaS),Soma1(cUltimaS)))

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³NGFONTERPO³ Autor ³ Thiago Olis Machado   ³ Data ³09/08/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Gera um arquivo em TXT do fontes do RPO e envia o arquivo   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³lEnve - Indica de envia o arquivo em TXT - NAO OBRIGATORIO  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGFONTERPO(lEnve)
	Local _nHdl    := 0
	Local _cTxt    := ""
	Local cHeader  := ""
	Local cMiddle  := ""
	Local aModName := RetModName(.T.)
	Local cModName := ""
	Local nX
	Local iX
	Local cModulo  := ""
	Local aFonte   := {}
	Local aFontes  := {}
	Local lFirst   := .T.
	Local yX

	cVerEx   := Alltrim(cVersao)
	cVerEx   := STRTRAN(cVerEx,".","")
	cArqVH   := "CHKVERH"+cVerEx+".TXT"
	cArquivo := cArqVH


	nX := Ascan(aModName,{|x| x[3] == oApp:cModDesc})
	If nX > 0
		cModName := aModName[nX][2]
	Else
		cModName := cModulo
	EndIf

	cHeader  := STR0361+" "+SM0->M0_NOMECOM+CRLF //"Empresa:"
	cHeader  += STR0362+" "+AllTrim(SM0->M0_ENDCOB)+" - "+AllTrim(SM0->M0_CIDCOB)+" - "+AllTrim(SM0->M0_ESTCOB)+CRLF+CRLF+CRLF //"Endereço:"

	cHeader += STR0363+" "+GetVersao(.T.,.F.)+CRLF //"Versão:"
	cHeader += STR0364+"  "+GetBuild()+CRLF //"Build:"

	// Esta funcao existe em alguns RPO
	//cHeader += STR0118+"  "+GetRPORelease()+CRLF

	cHeader += STR0365+"  "+Capital(GetEnvServer())+CRLF //"Ambiente:"
	cHeader += STR0366+" "+GetSrvProfString("LocalFiles","CodeBase")+CRLF //"Local files:"
	#IFDEF TOP
	cHeader += STR0367+TCGetDB()+CRLF //"Top DataBase: "
	#ENDIF
	cHeader += STR0368+" "+cModName+CRLF+CRLF //"Módulo:"

	aFontes := getFuncArray(SubStr(cModName,5,3)+'????')

	For iX := 1 To Len( aFontes )
		aFonte := GetApoInfo(aFontes[iX]+".PRX")
		If !Empty(aFonte)
			cMiddle += aFonte[01]+" "+DTOC(aFonte[04])+CRLF
		Else
			aFonte := GetApoInfo(aFontes[iX]+".PRW")
			If !Empty(aFonte)
				cMiddle += aFonte[01]+" "+DTOC(aFonte[04])+CRLF
			EndIf
		EndIf
	Next iX

	aFontes := getFuncArray('NG??????')
	For iX := 1 To Len( aFontes )
		aFonte := GetApoInfo(aFontes[iX]+".PRX")
		If !Empty(aFonte)
			cMiddle += aFonte[01]+" "+DTOC(aFonte[04])+CRLF
		Else
			aFonte := GetApoInfo(aFontes[iX]+".PRW")
			If !Empty(aFonte)
				cMiddle += aFonte[01]+" "+DTOC(aFonte[04])+CRLF
			EndIf
		EndIf
	Next iX

	For yX := 0 to 99
		If lFirst
			aFonte := GetApoInfo("NGUTIL.PRX")
			lFirst := .F.
		Else
			aFonte := GetApoInfo("NGUTIL"+StrZero(yX,2)+".PRX")
			If Empty(aFonte)
				aFonte := GetApoInfo("NGUTIL"+StrZero(yX,2)+".PRW")
			EndIf
		EndIf

		If !Empty(aFonte)
			cMiddle += aFonte[01]+" "+DTOC(aFonte[04])+CRLF
		Else
			Exit
		EndIf
	Next yX

	_cTxt := cHeader+CRLF+CRLF+cMiddle
	_nHdl := Fcreate(cArquivo)

	fWrite(_nHdl,_cTxt,Len(_cTxt))

	fClose(_nHdl)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NGBEGINPRM ³Autor ³Vitor Emanuel Batista ³ Data ³28/05/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Salva conteudo de variaveis padroes carregadas pela funcao/ ³±±
±±³          ³programa Pai e inicializa variaveis basicas                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nVersao     - Versao do programa                           ³±±
±±³          ³ cProgram    - Programa                                     ³±±
±±³          ³ aChkAlias   - Array que identificara o Alias a verificar no³±±
±±³          ³               SX9 ao excluir um registro.           Def={} ³±±
±±³          ³ lGetArea    - Verifica se deve guardar GetArea e retorna-la³±±
±±³          ³               na funcao	NGRETURNPRM                 Def=.T.³±±
±±³          ³ laRotina    - Verifica se aRotina deve ser iniciada Def=.F.³±±
±±³          ³ lcPrograma  - Verif. se cPrograma deve ser iniciada Def=.T.³±±
±±³          ³ laSMenu     - Verifica se aSMenu deve ser iniciada  Def=.T.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³ aNGBEGINPRM[1][1][x] = GetArea() - Area de Tramalho        ³±±
±±³          ³ aNGBEGINPRM[1][2][x] = GetKeys() - Teclas de Atalho        ³±±
±±³          ³ aNGBEGINPRM[x][1]    = Nome da variavel                    ³±±
±±³          ³ aNGBEGINPRM[x][2]    = Conteudo da variavel                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Observ.  ³ A primeira posicao da Array de retorno podera ser extendida³±±
±±³          ³ para futuras necessidades.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGBEGINPRM(nVersao,cProgram,aChkAlias,lGetArea,laRotina,lcPrograma,laSMenu)
	Local cChkAlias, aAliasNao, uRotina
	Local aNGBEGINPRM := {}

	Default cProgram   := ProcName(1)
	Default lcPrograma := .T.
	Default laSMenu    := .T.
	Default lGetArea   := .T.
	Default laRotina   := .F.
	Default aChkAlias  := {}

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Guarda Variaveis padroes      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ProcName(2) != "__EXECUTE" //Nao guarda variaveis se programa for chamado pelo menu
		aNGBEGINPRM :={	{ ;
		{	If(lGetArea,GetArea(),{}) },	;
		GetKeys()							;
		},;
		{"cGETWHILE"   ,If(Type("cGETWHILE") == "C",cGETWHILE        ,Nil)},; //--->CARACTER
		{"cGETMAKE"    ,If(Type("cGETMAKE")  == "C",cGETMAKE         ,Nil)},;
		{"cGETKEY"     ,If(Type("cGETKEY")   == "C",cGETKEY          ,Nil)},;
		{"cGETALIAS"   ,If(Type("cGETALIAS") == "C",cGETALIAS        ,Nil)},;
		{"cTUDOOK"     ,If(Type("cTUDOOK")   == "C",cTUDOOK          ,Nil)},;
		{"cLINOK"      ,If(Type("cLINOK")    == "C",cLINOK           ,Nil)},;
		{"cCADASTRO"   ,If(Type("cCADASTRO") == "C",cCADASTRO        ,Nil)},;
		{"cPrograma"   ,If(Type("cPrograma") == "C",cPrograma        ,Nil)},;
		{"cNgFilCad"   ,If(Type("cNgFilCad") == "C",cNgFilCad        ,Nil)},;
		{"nUsado"      ,If(Type("nUsado")    == "N",nUsado           ,Nil)},; //--->NUMERICO
		{"nOPCx"       ,If(Type("nOPCx")     == "N",nOPCx            ,Nil)},;
		{"n"           ,If(Type("n")         == "N",n                ,Nil)},;
		{"aTROCAF3"    ,If(Type("aTROCAF3")  == "A",aTROCAF3         ,Nil)},; //--->ARRAY
		{"aNAO"        ,If(Type("aNAO")      == "A",ACLONE(aNAO)     ,Nil)},;
		{"aNoFields"   ,If(Type("aNoFields") == "A",ACLONE(aNoFields),Nil)},;
		{"aCHOICE"     ,If(Type("aCHOICE")   == "A",ACLONE(aCHOICE)  ,Nil)},;
		{"aVARNAO"     ,If(Type("aVARNAO")   == "A",ACLONE(aVARNAO)  ,Nil)},;
		{"aGETNAO"     ,If(Type("aGETNAO")   == "A",ACLONE(aGETNAO)  ,Nil)},;
		{"aRELAC"      ,If(Type("aRELAC")    == "A",ACLONE(aRELAC)   ,Nil)},;
		{"aCHKDEL"     ,If(Type("aCHKDEL")   == "A",ACLONE(aCHKDEL)  ,Nil)},;
		{"aChkSql"     ,If(Type("aChkSql")   == "A",ACLONE(aChkSql)  ,Nil)},;
		{"aNGBUTTON"   ,If(Type("aNGBUTTON") == "A",ACLONE(aNGBUTTON),Nil)},;
		{"aCores"      ,If(Type("aCores")    == "A",ACLONE(aCores)   ,Nil)},;
		{"aRotina"     ,If(Type("aRotina")   == "A",ACLONE(aRotina)  ,Nil)},;
		{"aCols"       ,If(Type("aCols")     == "A",aCols            ,Nil)},;
		{"aHeader"     ,If(Type("aHeader")   == "A",aHeader          ,Nil)},;
		{"aSVHEADER"   ,If(Type("aSVHEADER") == "A",aSVHEADER        ,Nil)},;
		{"aSVCOLS"     ,If(Type("aSVCOLS")   == "A",aSVCOLS          ,Nil)},;
		{"aTELA"       ,If(Type("aTELA")     == "A",aTELA            ,Nil)},;
		{"aGETS"       ,If(Type("aGETS")     == "A",aGETS            ,Nil)},;
		{"aFields"     ,If(Type("aFields")   == "A",aFields          ,Nil)},;
		{"aBLO"        ,If(Type("aBLO")      == "A",aBLO             ,Nil)},;
		{"aSMenu"      ,If(Type("aSMenu")    == "A",aSMenu           ,Nil)},;
		{"aPOS1"       ,If(Type("aPOS1")     == "A",aPOS1            ,Nil)},;
		{"aMemos"      ,If(Type("aMemos")    == "A",aMemos           ,Nil)},;
		{"bNGGRAVA"    ,If(Type("bNGGRAVA")  == "B",bNGGRAVA         ,Nil)},; //--->BLOCO DE CODIGO
		{"bFiltraBrw"  ,If(Type("bFiltraBrw")== "B",bFiltraBrw       ,Nil)},;
		{"bRELMEMO"    ,If(Type("bRELMEMO")  == "B",bRELMEMO         ,Nil)},;
		{"bINCMEMO"    ,If(Type("bINCMEMO")  == "B",bINCMEMO         ,Nil)},;
		{"bALTMEMO"    ,If(Type("bALTMEMO")  == "B",bALTMEMO         ,Nil)},;
		{"bDELMEMO"    ,If(Type("bDELMEMO")  == "B",bDELMEMO         ,Nil)},;
		{"bNGGRAVA"    ,If(Type("bNGGRAVA")  == "B",bNGGRAVA         ,Nil)},;
		{"bNGDELRE"    ,If(Type("bNGDELRE")  == "B",bNGDELRE         ,Nil)},;
		{"INCLUI"      ,If(Type("INCLUI")    == "L",INCLUI           ,Nil)},; //--->LOGICO
		{"ALTERA"      ,If(Type("ALTERA")    == "L",ALTERA           ,Nil)},;
		{"oMenu"       ,If(Type("oMenu")     == "O",oMenu            ,Nil)},; //--->OBJETO
		{"oDlg"        ,If(Type("oDlg")      == "O",oDlg             ,Nil)},;
		{"oGET"        ,If(Type("oGET")      == "O",oGET             ,Nil)},;
		{"oPanel"      ,If(Type("oPanel")    == "O",oPanel           ,Nil)},;
		{"oScrollBox"  ,If(Type("oScrollBox")== "O",oScrollBox       ,Nil)};
		}
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Declara e carrega cPrograma   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lcPrograma
		_SetOwnerPrvt("cPrograma",cProgram)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Declara e carrega aSMenu      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If laSMenu
		_SetOwnerPrvt("asMenu",{})
		If NGCADICBASE("TQC_PROGRA","D","TQC",.F.) .And. NGCADICBASE("TQD_PROGRA","D","TQD",.F.)
			asMenu := NGRIGHTCLICK(cProgram)
		EndIf
		If Len( asMenu ) > 0 .And. SuperGetMv( "MV_ENCHOLD", .F., "2" ) == "2"
			_SetOwnerPrvt( "aNGButton", {} )
			NGClickBar( @aNGButton )
			asMenu := {}
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Declara e carrega aRotina     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If laRotina
		//aRotina simples com Incluir,Alterar,Excluir utilizando NGCAD01
		uRotina := { { STR0155, "AxPesqui"  , 0 , 1},; //"Pesquisar"
		{ STR0203, "NGCAD01"   , 0 , 2},; //"Visualizar"
		{ STR0369, "NGCAD01"   , 0 , 3},; //"Incluir"
		{ STR0370, "NGCAD01"   , 0 , 4},; //"Alterar"
		{ STR0353, "NGCAD01"   , 0 , 5, 3} }  //"Excluir"
		_SetOwnerPrvt("aRotina",uRotina)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Declara e carrega aChkAlias   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cChkAlias := If(Len(aChkAlias)>=1,aChkAlias[1],"")
	aAliasNao := If(Len(aChkAlias)>=2,aChkAlias[2],{})
	If !Empty(cChkAlias)
		_SetOwnerPrvt("aChkSql",NGRETSX9(cChkAlias,aAliasNao))
	EndIf

	If ExistBlock("NGBEGINP")
		ExecBlock("NGBEGINP",.F.,.F.,aNGBEGINPRM)
	EndIf

Return aNGBEGINPRM

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³  NGRETSX9  ³Autor ³Vitor Emanuel Batista ³ Data ³01/06/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna array contendo integridade referencial da tabela    ³±±
±±³          ³informada como parametro                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAlias  - Alias                                            ³±±
±±³          ³ aNao    - Alias que nao ira verificar                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ aChkSql[x][1] - X9_DOM                                     ³±±
±±³          ³ aChkSql[x][2] - X9_EXPDOM                                  ³±±
±±³          ³ aChkSql[x][3] - X9_CDOM                                    ³±±
±±³          ³ aChkSql[x][4] - X9_EXPCDOM                                 ³±±
±±³          ³ aChkSql[x][5] - X9_CONDSQL                                 ³±±
±±³          ³ aChkSql[x][6] - Comparacao da Filial do X9_DOM             ³±±
±±³          ³ aChkSql[x][7] - Comparacao da Filial do X9_CDOM            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGRETSX9( cAlias, aNao )

	Local aChkSql    := {}
	Local aAreaSX9   := SX9->( GetArea() )
	Local aEstrut	 := ( aAreaSX9[ 1 ] )->( DbStruct() )

	Local cCondSQL   := ""
	Local cCampDom   := ""
	Local cCampCDom  := ""
	Local cExpDom    := ""
	Local cExpCDom   := ""
	Local cCampSQL   := "_CONDSQL"
	Local cEnable	 := "_ENABLE"
	Local cUseFilial := "_USEFIL"

	Default aNao := {}

	If cAlias = Nil .Or. Empty( cAlias )
		Return aChkSql
	EndIf

	DbSelectArea( aAreaSX9[ 1 ] )
	( aAreaSX9[ 1 ] )->( DbSetOrder( 1 ) )

	If ( aAreaSX9[ 1 ] )->( DbSeek( cAlias ) )

		While ( aAreaSX9[ 1 ] )->( !Eof() ) .And. ( aAreaSX9[ 1 ] )->&( aEstrut[ 1 ][ 1 ] ) == cAlias

			cCampDom  := ( aAreaSX9[ 1 ] )->&( aEstrut[ 1 ][ 1 ] )
			cCampCDom := ( aAreaSX9[ 1 ] )->&( aEstrut[ 3 ][ 1 ] )

			cExpDom   := ( aAreaSX9[ 1 ] )->&( aEstrut[ 4 ][ 1 ] )
			cExpCDom  := ( aAreaSX9[ 1 ] )->&( aEstrut[ 5 ][ 1 ] )

			If aScan( aNao,{ |x| x == cCampCDom } ) == 0

				If ( aAreaSX9[ 1 ] )->&( SubStr( aAreaSX9[ 1 ], 2 ) + cEnable ) == "S"

					cFILDOM  := ""
					cFILCDOM := ""
					cCondSQL := ( aAreaSX9[ 1 ] )->&( SubStr( aAreaSX9[ 1 ], 2 ) + cCampSQL )

					If ( aAreaSX9[ 1 ] )->&( SubStr( aAreaSX9[ 1 ], 2 ) + cUseFilial ) = "S" .And. !Empty( FwxFilial( cCampDom ) )
						cFILDOM  := PrefixoCpo( cCampDom ) + "_FILIAL = '" + FwxFilial( cCampDom ) + "' "
						cFILCDOM := PrefixoCpo( cCampCDom ) + "_FILIAL = '" + FwxFilial( cCampCDom ) + "' "
					EndIf

					aAdd( aChkSql, { cCampDom, AllTrim( cExpDom ), cCampCDom, AllTrim( cExpCDom ), AllTrim( StrTran( cCondSQL, "#", "") ), cFILDOM, cFILCDOM } )

				EndIf
			EndIf

			( aAreaSX9[ 1 ] )->( DbSkip() )
			
		End

	EndIf

	RestArea( aAreaSX9 )

Return aChkSql

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGRETURNPRM ³Autor ³Vitor Emanuel Batista ³ Data ³28/05/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Salva conteudo de variaveis padroes carregadas pela funcao/ ³±±
±±³          ³programa Pai                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aNGBEGINPRM - Variaveis padroes a serem retornadas         ³±±
±±³          ³               aNGBEGINPRM[1][1][x] = GetArea()             ³±±
±±³          ³               aNGBEGINPRM[1][2][x] = Teclas de Atalho      ³±±
±±³          ³               aNGBEGINPRM[x][1]    = Nome da variavel      ³±±
±±³          ³               aNGBEGINPRM[x][2]    = Conteudo da variavel  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nil                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO - UTILIZANDO FUNCAO NGBEGINPRM                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGRETURNPRM(aNGBEGINPRM)
	Local nX, nY

	If ExistBlock("NGRETURN")
		ExecBlock("NGRETURN",.F.,.F.,aNGBEGINPRM)
	EndIf

	If Len(aNGBEGINPRM) > 0

		//Primera posicao FIXA para diversos tratamentos
		If Len(aNGBEGINPRM[1]) > 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Retorna Area de Trabalho anterior       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nY := 1 to Len(aNGBEGINPRM[1][1])
				If Len(aNGBEGINPRM[1][1][nY]) > 0
					RestArea(aNGBEGINPRM[1][1][nY])
				EndIf
			Next nX

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Restaura as Teclas de Atalho           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Len(aNGBEGINPRM[1][2]) > 0
				RestKeys( aNGBEGINPRM[1][2] , .T. )
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Retorna conteudo anterior das variaveis ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nX := 2 to Len(aNGBEGINPRM)
			&(aNGBEGINPRM[nX][1]) := aNGBEGINPRM[nX][2]
		Next nX

	EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCALLSTACK ³Autor ³Vitor Emanuel Batista ³ Data ³28/05/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se a funcao informada como parametro esta na pilha ³±±
±±³          ³de chamada do processamento atual                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cFunction   - Nome da funcao                               ³±±
±±³          ³ lMostraMsg  - Indica se ira mostrar Help se funcao estiver ³±±
±±³          ³               em execucao                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. ou .F. - Indicando que funcao informada esta ou nao em  ³±±
±±³          ³             execucao                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCALLSTACK(cFunction,lMostraMsg)
	Local lRet := .F.

	Default lMostraMsg := .F.

	If IsInCallStack(cFunction)
		lRet := .T.
		If lMostraMsg
			ShowHelpDlg( STR0025,	{ STR0371 },2,; //"ATENCAO"###"Programa solicitado ja está em execução."
			{ STR0372 },2)  //"Utilize o programa em processo."
		EndIf
	EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGDIAUTEIS³ Autor ³ Marcos Wagner Junior  ³ Data ³ 08/06/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna a quantidade de dias uteis em um periodo            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³1.dDataIni - Data Inicio para verificacao dos dias -Obrigat.³±±
±±³          ³2.dDataFim - Data Fim para verificacao dos dias    -Obrigat.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³NGUTIL05                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGDIAUTEIS(_dDataIni,_dDataFim)
	Local aFeriados :=RetFeriados()
	Local nDow
	Local nQtdeDias := 0
	Local dDataWhile := _dDataIni

	While dDataWhile <= _dDataFim
		nDow := Dow(dDataWhile)
		If Ascan(aFeriados,Dtos(dDataBase)) = 0 .And. nDow <> 1 .And. nDow <> 7
			nQtdeDias++
		EndIf
		dDataWhile := dDataWhile + 1
	End

Return nQtdeDias

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGLOCLOGO ³ Autor ³ Andrey Martim Pegorini³ Data ³ 17/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o caminho utilizado pelo sistema para localizar a  ³±±
±±³          ³imagem de logotipo da empresa.                              ³±±
±±³          ³ Prioridade (Exemplo): - Empresa + Filial (LGRL9901)        ³±±
±±³          ³                       - Empresa (LGRL99)                   ³±±
±±³          ³                       - Geral (LGRL)                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³cLogo - Variável do tipo caracter contendo o caminho comple-³±±
±±³          ³        to da localização do logotipo da empresa, mais o no-³±±
±±³          ³        me do logotipo.                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³NGUTIL05                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGLOCLOGO()

	Local cBarras    := If(isSRVunix(),"/","\")
	Local cSMCOD 	 := If(FindFunction("FWGrpCompany"),FWGrpCompany(),SM0->M0_CODIGO)
	Local cSMFIL 	 := AllTrim(If(FindFunction("FWCodFil"),FWCodFil(),SM0->M0_CODFIL))
	Local cStartPath := AllTrim(GetSrvProfString("StartPath",cBarras))
	Private cLogo 	 := ""

	// Se StartPath NAO tiver barra no final, adiciona
	If SubStr(AllTrim(cStartPath),Len(AllTrim(cStartPath))) != cBarras
		cStartPath += cBarras
	EndIf

	// Se StartPath NAO tiver barra no inicio, adiciona
	If SubStr(AllTrim(cStartPath),1) != cBarras
		cStartPath = cBarras + cStartPath
	EndIf

	// Empresa + Filial
	If File(cStartPath+"LGRL"+cSMCOD+cSMFIL+".BMP")
		cLogo := cStartPath+"LGRL"+cSMCOD+cSMFIL+".BMP"
	ElseIf File("LGRL"+cSMCOD+cSMFIL+".BMP")
		cLogo := "LGRL"+cSMCOD+cSMFIL+".BMP"

	// Empresa
	ElseIf File(cStartPath+"LGRL"+cSMCOD+".BMP")
		cLogo := cStartPath+"LGRL"+cSMCOD+".BMP"
	ElseIf File("LGRL"+cSMCOD+".BMP")
		cLogo := "LGRL"+cSMCOD+".BMP"

	// Todos
	ElseIf File(cStartPath+"LGRL.BMP")
		cLogo := cStartPath+"LGRL.BMP"
	ElseIf File("LGRL.BMP")
		cLogo := "LGRL.BMP"
	Endif

Return (cLogo)

//-----------------------------------------------------------------------------------------------
/*/{Protheus.doc} NGWFLog
Gera o log especifico do processamento do workflow no arquivo de log no diretório de WorkFlow especificado pelo parâmetro MV_WFDIR


@type  Function
@author Wagner S. de Lacerda
@since 01/12/2010

@param cLog    , Character, Mensagem a ser impressa no log
@param lHeader , Logic    , Indica se irá imprimir o cabeçalho da mensagem (utilizado na primeira mensagem de uma Thread)
@param lEnd    , Logic    , Indica se irá imprimir rodapé
@param cProgram, Character, Nome da Rotina sendo executada

/*/
//-----------------------------------------------------------------------------------------------
Function NGWFLog( cLog, lHeader, lEnd, cProgram )

	Local lLog     := SuperGetMv("MV_NGWFLG",.F.,"-1") == "1" //1 - True; 0 - Falso;
	Local cDir     := AllTrim(SuperGetMv("MV_WFDIR",.F.,""))
	Local cArqLog  := "WFLogExclusiv.log"
	Local cPrefixo := "[WF INFO]"
	Local nHandle  := -1
	Local uTexto
	Local uEnter   := Chr(13)+Chr(10)
	Local lSchedule:= IsBlind() .And. !Empty( cUserName )
	Local cNomeUsu := IIf( !lSchedule, IIf( Empty( cUserName ), 'JOB', cUserName ), 'SCHEDULE' )
	Local cThread  := cValToChar( ThreadId() )

	Default cProgram := STR0463 // 'Rotina não informada'
	Default lHeader  := .F.
	Default lEnd     := .F.

	cLog := AllTrim(cLog)

	If !lLog
		Return .F.
	EndIf

	If Empty(cDir)
		cDir := "\workflow\"
	EndIf

	If SubStr(cDir,Len(cDir),1) <> "\"
		cDir += "\"
	EndIf

	cDir += "log\"
	MakeDir(cDir)

	If !File(cDir+cArqLog)
		nHandle := FCreate(cDir+cArqLog,0)

		If nHandle <> -1
			uTexto := Replicate("*",60)+uEnter
			FWrite(nHandle,uTexto,Len(uTexto))

			FWrite( nHandle, uEnter + uEnter, Len( uEnter + uEnter ) )

			uTexto := STR0374+uEnter //"LOG EXCLUSIVO DO WORKFLOW"
			FWrite(nHandle,uTexto,Len(uTexto))

			uTexto := STR0375+DTOC(dDataBase)+uEnter //"Data Início: "
			FWrite(nHandle,uTexto,Len(uTexto))

			uTexto := STR0376+SubStr(Time(),1,8)+uEnter //"Hora Início: "
			FWrite(nHandle,uTexto,Len(uTexto))

			FWrite(nHandle,uEnter,Len(uEnter))

			uTexto := Replicate("*",60)+uEnter
			FWrite(nHandle,uTexto,Len(uTexto))

			FClose(nHandle)
		EndIf
	EndIf
	nHandle := FOpen(cDir+cArqLog,2 + 64)

	If nHandle == -1
		Return .F.
	EndIf

	FSeek(nHandle, 0, 2)
	If lHeader
		FWrite(nHandle,uEnter,Len(uEnter))

		uTexto := "@ "+STR0378+Upper(AllTrim(cNomeUsu))+uEnter+; //"USUÁRIO: "
		Upper( STR0236 ) + ': ' + cProgram + uEnter +; // "PROGRAMA"
		'THREAD: ' + cThread + uEnter
		FWrite(nHandle,uTexto,Len(uTexto))

		uTexto := Replicate("-",40)+uEnter
		FWrite(nHandle,uTexto,Len(uTexto))
	EndIf

	uTexto := cPrefixo+"["+;
	'Thread ' + cThread + "][" +;
	PADL(AllTrim(Str(Day(dDataBase))),2,"0")+"/"+;
	PADL(AllTrim(Str(Month(dDataBase))),2,"0")+"/"+;
	AllTrim(Str(Year(dDataBase)))+;
	" "+SubStr(Time(),1,8)+"]["+;
	cNomeUsu + "][" +;
	cProgram + "]" +;
	cLog + uEnter
	FWrite(nHandle,uTexto,Len(uTexto))

	If lEnd
		uTexto := Replicate("-",40)+uEnter
		FWrite(nHandle,uTexto,Len(uTexto))
	EndIf

	FClose(nHandle)

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³NGWFVerWF7ºAutor  ³Wagner S. de Lacerdaº Data ³  02/12/2010 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se o usuario possui e-mail cadastrado na tabela   º±±
±±º          ³ de Contas de E-mail do WorkFlow - WF7.                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ .T. -> Esta cadastrado.                                    º±±
±±º          ³ .F. -> Destinatario nao cadastrado / vazio / em branco.    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cEmailTo -> Obrigatorio.                                   º±±
±±º          ³             Indica o destinatario do e-mail a validar.     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SigaMNT                                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º           ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºProgramador ³   Data     ³ Descricao                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º            ³ xx/xx/xxxx ³                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGWFVerWF7(cEmailTo)

	Local cAliasQry := ""
	Local cQueryWF7 := ""
	Local lRet      := .F.

	If !Empty(cEmailTo)
		cEmailTo := AllTrim(cEmailTo)

		#IFDEF TOP
		cAliasQry := GetNextAlias()

		cQueryWF7 := " SELECT WF7.WF7_ATIVO "
		cQueryWF7 += " FROM "+RetSqlName("WF7")+" WF7 "
		cQueryWF7 += " WHERE WF7.WF7_FILIAL = '"+xFilial("WF7")+"' "
		cQueryWF7 += " AND UPPER(WF7.WF7_ENDERE) = '"+Upper(cEmailTo)+"' "
		cQueryWF7 += " AND WF7.D_E_L_E_T_ <> '*'"
		cQueryWF7 := ChangeQuery(cQueryWF7)

		dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQueryWF7),cAliasQry, .F., .T.)

		dbSelectArea(cAliasQry)
		dbGoTop()
		If !Eof()
			lRet := .T.
			If Upper((cAliasQry)->WF7_ATIVO) <> "T"
				MsgStop(STR0379+cEmailTo+STR0380,STR0381) //"Este endereço: "###" está inativo."###"Atenção"
			EndIf
		EndIf
		(cAliasQry)->(dbCloseArea())
		#ELSE
		dbSelectArea("WF7")
		dbGoTop()
		dbSetOrder(1)
		dbSeek(xFilial("WF7"))
		While !Eof()
			If Upper(AllTrim(WF7->WF7_ENDERE)) == Upper(cEmailTo)
				lRet := .T.

				If !(WF7->WF7_ATIVO)
					MsgStop(STR0379+cEmailTo+STR0380) //"Este endereço: "###" está inativo."
				EndIf

				Exit
			EndIf

			dbSelectArea("WF7")
			dbSkip()
		End
		#ENDIF
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCHKCOMP
Verifica se o compartilhamento das tabelas são iguais.

@author Wagner Sobral de Lacerda
@since 02/02/2012

@param aTables
Tabelas para verificar o compartilhamento * Obrigatório
Formato:
[1] - tabela 1
[2] - tabela 2
[3] - tabela 3
...
@param lMsg
Indica se deve mostrar mensagem em tela * Opcional
Default: .T.

@return .T. compartilhamentos iguais / .F. diferentes
/*/
//---------------------------------------------------------------------
Function NGCHKCOMP(aTables, lMsg)

	Local aErro := {}
	Local cMsg  := ""
	Local nErro := 0

	Local cFirstTbl := ""
	Local nTable    := 0
	Local nModo     := 0
	Local nTotModos := 3

	Default aTables := {}
	Default lMsg    := .T.

	// São necessárias no mínimo 2 (duas) tabelas para realizar a comparação
	If Len(aTables) < 2
		Return .T.
	EndIf

	//------------------------------
	// Compara os compartilhamentos
	//------------------------------
	cFirstTbl := aTables[1]

	// Não é necessário verificar todas as tabelas entre si, porque os compartilhamentos devem ser iguais.
	// Logo, basta comparar uma tabela com todas as outras, e se uma for diferente, também já será diferente das demais, retornando .F.
	For nTable := 2 To Len(aTables)
		For nModo := 1 To nTotModos

			// Modos:
			// 1 - Empresa
			// 2 - Unidade de Negócio
			// 3 - Filial
			If FWModeAccess(cFirstTbl, nModo) <> FWModeAccess(aTables[nTable], nModo)
				aAdd(aErro, aTables[nTable])
			EndIf

		Next nModo
	Next nTable

	// Mostra o erro e retorna
	If Len(aErro) > 0
		If lMsg
			cMsg := STR0382 //"O sistema apresenta divergência no Modo de Compartilhamento das seguintes tabelas:"
			cMsg += CRLF
			cMsg += " - " + cFirstTbl
			For nErro := 1 To Len(aErro)
				cMsg += CRLF + " - " + aErro[nErro]
			Next nErro
			cMsg += CRLF + CRLF
			cMsg += STR0383 //"Favor providenciar a correta configuração dessas tabelas, as quais devem possuir os mesmos Modos de Compartilhamento."
			Aviso(STR0025, cMsg, {"Ok"}, 3, STR0025, , , , , 1) //"ATENCAO"###"ATENCAO"
		EndIf

		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGUserMod
Monta um array com os módulos que o usuário possui acesso.

@author Wagner Sobral de Lacerda
@since 03/02/2012

@param cCodUser
Código do Usuário * Opcional
Default: RetCodUsr() - usuário atual

@return aUserMod Array com os módulos que o usuário possui acesso;
formato:
[x][1] - Código    (Ex.: 19)
[x][2] - Nome      (Ex.: SIGAMNT)
[x][3] - Descrição (Ex.: Manutenção de Ativos)
/*/
//---------------------------------------------------------------------
Function NGUserMod(cCodUser)

	Local aModulos  := aClone( RetModName() ) // Todos os Módulos do Sistema
	Local aInfoUser := {}
	Local nNumMod   := 0
	Local nX := 0

	Local aUserMod := {} // Módulos que o usuário possui Acesso

	Default cCodUser := RetCodUsr()

	//--------------------
	// Recebe os Módulos do Usuário
	//--------------------
	PswOrder(1)
	If PswSeek(cCodUser, .T.)
		aInfoUser := aClone( PswRet() ) // Informações do Usuário
		// Percorre os módulos que o usuário tem acesso e adiciona no array de Módulos do Usuário
		For nX := 1 To Len(aInfoUser[3])

			If SubStr(aInfoUser[3][nX],3,1) <> "X" // Deve possuir Permissão de acesso
				nNumMod := Val( SubStr(aInfoUser[3][nX],1,2) )

				nPos := aScan(aModulos, {|x| x[1] == nNumMod })
				If nPos > 0 .And. aScan(aUserMod, {|x| x[1] == nNumMod }) == 0 // Usuário tem acesso ao módulo e esse módulo ainda não foi processado
					// Número do Módulo (Código) ; Nome do Módulo ; Descrição do Módulo
					aAdd(aUserMod, {aModulos[nPos][1], aModulos[nPos][2], aModulos[nPos][3]})
				EndIf
			EndIf

		Next nX
	EndIf

Return aUserMod

//---------------------------------------------------------------------
/*/{Protheus.doc} NGRetModNa
Retorna o nome do módulo passado como parâmetro.

@author Wagner Sobral de Lacerda
@since 31/05/2012

@param uParModulo
Código do Módulo * Opcional
Default: nModulo (variável pública)
* ATENÇÃO: Este parâmetro deve ser ou Numérico, ou Caractere!

@return cRetModName
/*/
//---------------------------------------------------------------------
Function NGRetModNa(uParModulo)

	// Variáveis de Controle
	Local aModulos   := aClone( RetModName() ) // Todos os Módulos do Sistema
	Local nValModulo := 0
	Local nScan := 0

	// Variável do Retorno
	Local cRetModName := ""

	// Defaults
	Default uParModulo := nModulo

	// Converte o Módulo para numérico
	If ValType(uParModulo) == "C"
		nValModulo := Val(uParModulo)
	Else
		nValModulo := uParModulo
	EndIf

	// Busca o Nome do Módulo
	nScan := aScan(aModulos, {|x| x[1] == nValModulo })
	If nScan > 0
		cRetModName := AllTrim(aModulos[nScan][3])
	EndIf

Return cRetModName

//---------------------------------------------------------------------
/*/{Protheus.doc} NGSXBSM0
Consulta padrão personalizada implementada no padrão para ler SIGAMAT.EMP
( SM0 ) e permitir pesquisa conforme indices definidos em variáveis da rotina
visto que os indices do SIGAMAT estão com mau funcionamento.
Consulta no sxb: MNTGEN.
Necessita ter as seguintes variáveis declaradas na rotina que vai usar a
consulta:
Private cMntGenFun	:= "NGSXBSM0()"
Private cMntGenRet	:= "NGSXBSM0Ret()"

@author André Felipe Joriatti
@since 04/02/2013
@sample:
NGSXBSM0()
@version MP11
/*/
//---------------------------------------------------------------------

Function NGSXBSM0()

	Local aIndcs     := {} // array de indices.
	Local oDlgCFil    // dialog de consulta
	Local cPesq      := Space( 40 )
	Local oComboIndex // combo utilizado para indices de pesquisa
	Local oGetFil     // campo que recebe a chave de pesquisa
	Local aCamposFil := { 'M0_CODFIL','M0_FILIAL','M0_CIDENT','M0_NOME' } // campos do sigamat que vao ser apresentados em tela
	Local lOk        := .F.
	Local aOpcCo     := {}
	Local cOpcComb   := ""
	Local cFilSel		:= ""
	Local aColsFil   := {}
	Local oPnlBtns   // panel de botões e campo de pesquisa.
	Local oPnlGrid   // panel do grid de filiais
	Local oPnlBtEnc  // panel dos botões de 'OK' e 'Cancelar'

	Private oBrowse
	Private aFiliais := {}

	// Define array de objetos das colunas DEVE ESTAR NA ORDEM DO ARRAY aCamposFil
	aAdd( aColsFil , NGObjeColu( "{|| aFiliais[oBrowse:At()]["+cValToChar( 1 )+"] }",.F.,STR0384,"C",13,"@!" ) ) // "Código"
	aAdd( aColsFil , NGObjeColu( "{|| aFiliais[oBrowse:At()]["+cValToChar( 2 )+"] }",.F.,STR0154,"C",15,"@" ) )  // "Filial"
	aAdd( aColsFil , NGObjeColu( "{|| aFiliais[oBrowse:At()]["+cValToChar( 3 )+"] }",.F.,STR0385,"C",15,"@!" ) ) // "Município"
	aAdd( aColsFil , NGObjeColu( "{|| aFiliais[oBrowse:At()]["+cValToChar( 4 )+"] }",.F.,STR0037,"C",17,"@" ) )  // "Nome"

	//-------------------------------------------------------------------------------------------
	// para adicionar índices de pesquisa na consulta, basta adicionar, uma 'linha' no array
	// aIndcs com os campos que compoem o índice separados pelo sinal '+' e uma 'linha' no array
	// aOpcCo contendo a descrição desse índice.
	//-------------------------------------------------------------------------------------------

	// array com índices de pesquisa no browse
	aAdd( aIndcs,"M0_CODFIL+M0_FILIAL")
	aAdd( aIndcs,"M0_FILIAL+M0_CODFIL")
	aAdd( aIndcs,"M0_NOME+M0_CODFIL"  )

	// array com descrição dos indices de pesquisa, deve estar conforme a ordem do array de indices aIndcs
	aAdd( aOpcCo,STR0386 ) //"1=Código + Filial"
	aAdd( aOpcCo,STR0387 ) //"2=Filial + Código"
	aAdd( aOpcCo,STR0388 ) //"3=Nome + Código"

	Define MsDialog oDlgCFil From 03.5,6 To 460,530 Title OemToAnsi( STR0389 ) COLOR CLR_BLACK,CLR_WHITE Pixel  //"Consulta Padrão - SM0"

	//-----------------------------
	// panel botões de pesquisa
	//-----------------------------
	oPnlBtns         := TPanel():New( 00,00,,oDlgCFil,,,,,CLR_WHITE,12,12,.F.,.F. )
	oPnlBtns:Align   := CONTROL_ALIGN_TOP
	oPnlBtns:nHeight := 60

	@ 003,003 ComboBox oComboIndex Var cOpcComb Items aOpcCo Size 200,060 Of oPnlBtns On Change fReOrdn( aCamposFil,cOpcComb,aIndcs ) Pixel // reordena a tabela quando muda o combo
	@ 003,205 Button STR0155 Of oPnlBtns Size 040,010 Pixel Action fPesqFil( aCamposFil,cOpcComb,aIndcs,cPesq ) //"Pesquisar"
	@ 017,003 MsGet oGetFil Var cPesq Size 200,010 Of oPnlBtns On Change fPesqFil( aCamposFil,cOpcComb,aIndcs,cPesq ) Pixel

	//------------------------------
	// panel grid
	//------------------------------
	oPnlGrid := TPanel():New( 030,000,,oDlgCFil,,,,,CLR_WHITE,265,170,.F.,.F. )

	oBrowse := FWBrowse():New()
	oBrowse:SetDataArray()          //Define que a utilizacao é por array
	oBrowse:SetColumns( aColsFil )  //Define as colunas preestabelecidas
	oBrowse:SetOwner( oPnlGrid )    //Define o objeto pai
	aFiliais := fLoadFil( aCamposFil,"SM0->M0_CODIGO == cEmpAnt","M0_CODFIL+M0_FILIAL" ) // carrega dados no browse/grid
	oBrowse:SetBackColor( CLR_WHITE )
	oBrowse:SetLocate()             // habilita botão de 'Localizar'
	oBrowse:SetLineHeight( 17 )     // seta altura da linha
	oBrowse:SetDoubleClick ( { || lOk := .T., oDlgCFil:End(),cFilSel := AllTrim( aFiliais[oBrowse:At()][1] ) } ) // duplo click
	oBrowse:Activate()              // Ativa o browse

	//-------------------------------
	// panel botões OK e Cancelar
	//-------------------------------
	oPnlBtEnc := TPanel():New( 210,000,,oDlgCFil,,,,,CLR_WHITE,265,020,.F.,.F. )

	Define sButton From 000,005 Type 1 Enable Of oPnlBtEnc Action Eval( { || lOk := .T., oDlgCFil:End(),cFilSel := AllTrim( aFiliais[oBrowse:At()][1] ) } )
	Define sButton From 000,035 Type 2 Enable Of oPnlBtEnc Action Eval( { || oDlgCFil:End() } )

	Activate MsDialog oDlgCFil Centered

	//Feito posicionamento para buscar os dados, e não deixar
	//o campo vazio ao selecionar alguma filial.
	DbSelectArea( "SM0" )
	DbSetOrder( 1 )
	DbSeek( cEmpAnt+cFilSel)

Return lOk

//---------------------------------------------------------------------
/*/{Protheus.doc} NGSXBSM0Ret
Retorna o código da filial selecionada no browse da consulta padrão.
Uso: tela de consulta padrão de Filiais personalizada.

@author André Felipe Joriatti
@since 05/02/2013
Refeito por:
@author Jean Pytter da Costa
@Since 07/04/2015

@sample:
NGSXBSM0Ret()
@return SM0->M0_CODFIL - Feito retorno direto pelo campo, pois como
era feito não era possivel declarar a variavel.

@version MP12

/*/
//---------------------------------------------------------------------

Function NGSXBSM0Ret()
Return SM0->M0_CODFIL

//---------------------------------------------------------------------
/*/{Protheus.doc} fLoadFil
Carrega Filiais em objeto FWBrowse.

@author André Felipe Joriatti
@param Array aCampos: indica quais os campos (na ordem) que o array/matriz
de retorno deve conter (do sigamat).
@param String cFiltro: indica o filtro para carregar as filiais, opcional.
@param String cIndice: indice o indice para ordenar array de retorno.
@param String cOperLog: indica operador lógico para definir se array será
ordenado de forma ascendente ou descendente conforme
os campos de índice informados no parametro cIndice,
valores possíveis: " < " ou " > "
@param String cPesq: indica chave de pesquisa, caso seja diferente de Nil,
a função irá realizar posicionamento no browse conforme
o valor informado nesse parametro
@since 04/02/2013
@sample:
fLoadFil()
@version MP11
@return Array aFiliais: array de filiais.
/*/
//---------------------------------------------------------------------

Static Function fLoadFil( aCampos,cFiltro,cIndice,cOperLog,cPesq )

	Local aFlds        := {}
	Local nI           := 0
	Local aFldsInd     := {}
	Local cCondOrdem   := "|x,y| "
	Local cOrdLeft     := ""
	Local cOrdRight    := ""
	Local nPosFld      := 0
	Local cChav        := "" // utilizada no posicionamento no browse quando cPesq for != de Nil

	Private aFiliais   := {} // definida como private para poder usar no macro que ordena o array de filiais
	Private nLi        := 0

	Default cFiltro    := ".T." // cFiltro parametro opcional
	Default cOperLog   := " < " // indica que a ordenação do array será de forma ascendente por padrão

	//--------------------------
	// gera conteúdo para grid
	//--------------------------
	DbSelectArea( "SM0" )
	DbGoTop()
	While !EoF()
		If !( &( cFiltro ) )
			DbSelectArea( "SM0" )
			DbSkip()
			Loop
		EndIf
		aFlds := {} // limpa array de registro
		For nI := 1 To Len( aCampos )
			aAdd( aFlds,SM0->&( aCampos[nI] ) )
		Next nI
		aAdd( aFiliais,aFlds )
		DbSelectArea( "SM0" )
		DbSkip()
	EndDo

	//-------------------------------------------------
	// ordenação do array de filiais conforme cIndice
	//-------------------------------------------------
	aFldsInd := StrTokArr( cIndice, "+" )

	For nI := 1 To Len( aFldsInd )
		nPosFld := 0
		If aScan( aCampos,{ |x| AllTrim( x ) == AllTrim( aFldsInd[nI] ) } ) == 0
			Loop
		EndIf
		nPosFld := aScan( aCampos,{ |x| AllTrim( x ) == AllTrim( aFldsInd[nI] ) } )
		cOrdLeft += "x[" + cValToChar( nPosFld ) + "]+"
		cOrdRight += "y[" + cValToChar( nPosFld ) + "]+"
	Next nI

	cOrdLeft  := SubStr( cOrdLeft,1,Len( cOrdLeft ) - 1 )   // retira o ultimo '+'
	cOrdRight := SubStr( cOrdRight,1,Len( cOrdRight ) - 1 ) // retira o ultimo '+'

	cCondOrdem := cCondOrdem + cOrdLeft + cOperLog + cOrdRight

	&( "aSort( aFiliais,,, { " + cCondOrdem + " } )" ) // ordena array de filiais de acordo com os campos passados em cIndice

	// seta o conteúdo do browse
	oBrowse:SetArray( aFiliais )

	//---------------------------------------------------------
	// caso chave tenha sido informado, realiza posicionamento
	//---------------------------------------------------------
	If cPesq != Nil
		cChav := "aScan( aFiliais, { |x| AllTrim( cPesq  ) $ " + cOrdLeft + " } )"
		nLi := &( cChav )
		If nLi != 0
			oBrowse:GoTo( nLi,.T. ) // posiciona na linha conforme pesquisa e força refresh
		EndIf
		Return Nil
	EndIf

	oBrowse:Refresh()

Return aFiliais

//---------------------------------------------------------------------
/*/{Protheus.doc} fReOrdn
Reordena a tabela de filiais conforme filtro escolhido.
Uso: tela de consulta padrão personalizada Filiais.

@author André Felipe Joriatti
@param Array aCamposFil: indica campos da SM0 que deverão existir na consulta
@param String cOpcComb: indica a opção escolhida de indice.
@param Array aIndcs: indica array de indices.
@since 05/02/2013
@sample:
fReOrdn()
@return boolean lRet: ever true
@version MP11
/*/
//---------------------------------------------------------------------
Static Function fReOrdn( aCamposFil,cOpcComb,aIndcs )
	Local cCposInd := ""
	cCposInd := aIndcs[Val( cOpcComb )] // verifica quais os campos pertencentes ao indice escolhido
	aFiliais := fLoadFil( aCamposFil,"SM0->M0_CODIGO == cEmpAnt",cCposInd ) // carrega array de filiais conforme novo indice
Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fPesqFil
Posiciona o cursor no browse conforme o valor digitado e o índice
escolhido.
Uso: tela de consulta padrão personalizada Filiais.
@author André Felipe Joriatti
@param Array aCamposFil: indica campos do browse (da SM0)
@param String cOpcComb: indica o valor de indice para pesquisar.
@param Array aIndcs: indica array de indices do browse, do qual
vamos extrair o indice usado pela pesquisa
de acordo com o informado no parametro
cOpcComb.
@param String cPesq: indica o valor pesquisado no browse.
@since 05/02/2013
@sample:
fPesqFil()
@return Nil
@version MP11
/*/
//---------------------------------------------------------------------

Static Function fPesqFil( aCamposFil,cOpcComb,aIndcs,cPesq )
	Local cCposInd   := ""
	Private aFiliais := {}
	cCposInd := aIndcs[Val( cOpcComb )] // verifica quais os campos pertencentes ao indice escolhido
	aFiliais := fLoadFil( aCamposFil,"SM0->M0_CODIGO == cEmpAnt",cCposInd,,cPesq )
Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} NGObjeColu
Retorna objeto para coluna de FWBrowse com propriedades de acordo com
parametros informados. Caso haja necessidade de se aumentar a quantidade
de propriedades/utilizar propriedade não definida, basta aumentar a
quantidade de parametros.

@author André Felipe Joriatti
@since 05/02/2013
@param String cData: indicbloco de código da coluna.
@param Boolean lEdit: indica se campo é editável ou não.
@param String cTitle: indica titulo da coluna.
@param String cType: indica tipo da coluna.
@param Number nSize: indica tamanho da coluna.
@param String cPict: indica picture da coluna/campo
@sample:
NGObjeColu()
@return Object oColuna: indica objeto de coluna para FWBrowse.
@version MP11
/*/
//---------------------------------------------------------------------
Function NGObjeColu( cData, lEdit, cTitle, cType, nSize, cPict )
	
	Local oColuna

	oColuna := FWBrwColumn():New()
		oColuna:SetData( &( cData ) ) // Valor
		oColuna:SetEdit( lEdit )      // Indica se é editavel
		oColuna:SetTitle( cTitle )    // Título
		oColuna:SetType( cType )      // Tipo
		oColuna:SetSize( nSize )      // Tamanho
		oColuna:SetPicture( cPict )   // Picture

		If cType == 'N'
			
			oColuna:SetAlign( CONTROL_ALIGN_RIGHT )

		Else

			oColuna:SetAlign( CONTROL_ALIGN_LEFT)

		EndIf

Return oColuna

//---------------------------------------------------------------------
/*/{Protheus.doc} NGVLDMDMV
Validacao para campo moeda.

@param cMoeda - Moeda a ser validada.

@author Hugo R. Pereira
@since 05/06/2012
@version MP10
@return cMoeda -
/*/
//---------------------------------------------------------------------
Function NGVLDMDMV(cMoeda, lPertence)

	Local lReturn   := .F.
	Local cParMoeda

	Default cMoeda    := ""
	Default lPertence := .T.

	lReturn := !lPertence .Or. Pertence("12345")

	If lReturn

		cMoeda    := AllTrim(cMoeda)
		cParMoeda := "MV_MOEDA" + cMoeda

		If Empty( GetNewPar(cParMoeda, "") )
			lReturn := MsgYesNo(STR0390 + cMoeda + "." + CRLF + ; //"A moeda informada não está definida corretamente no parametro MV_MOEDA"
			STR0391) //"Deseja realmente utilizar esta moeda para a operação?"
		Endif

	Endif

Return lReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} NGDBFTRB
Gera os Arrays com a estrutura para montagem de TRB, montagem do Browse em um TRB e índices para o TRB
Uso Generico

@sample
NGDBFTRB( "TRB" , @aEst, @aBrowse , @aInd , @aIndBrw , .F. , .F. )

@param cAliTmp    Alias da Tabela Pai - Obrigatorio
@param aEstrutura Array que recebera a estrutura do TRB - Obrigatorio
@param aBrowse    Array que recebera a estrutura para montagem do Browse - Obrigatorio
@param aIndex     Array que recebera a estrutura dos Indices totais da tabela - Obrigatorio
@param aIdxBrw    Array que recebera a estrutura dos Indices de browse da tabela - Obrigatorio
@param lDescIdx   Indica se deve incluir no array de indices a Descricao
@param lFilBrw    Indica se deve obrigar a incluir a filial no Browse

@author Jackson Machado
@since 16/01/2013
@return Nil
@version 1.0
/*/
//---------------------------------------------------------------------
Function NGDBFTRB( cAliTmp , aEstrutura, aBrowse , aIndex , aIdxBrw , lDescIdx , lFilBrw )

	Local nEst, nEst2
	Local nIndex   := 0
	Local aEstTot  := {}, aEstBrw := {}
	Local aIndexes := {}, aIndBrw := {}
	Local aArea    := GetArea()
	Local aIndex   := {}
	Local cChave   := ""
	Local cDescInd := ""
	Local cOrdem   := ""

	Default lDescIdx  := .F.
	Default lFilBrw   := .F.

	aEstTot := ( cAliTmp )->( dbStruct() )

	dbSelectArea( "SX3" )
	dbSetOrder( 2 )
	For nEst := 1 To Len( aEstTot )
		dbSeek(  aEstTot[ nEst , 1 ] )
		aAdd( aEstrutura , aEstTot[ nEst ] )
		If Posicione("SX3",2,aEstTot[ nEst , 1 ],"X3_BROWSE") == "S" .OR. ( lFilBrw .And. "_FILIAL" $ Posicione("SX3",2,aEstTot[ nEst , 1 ],"X3Descric()") )
			aAdd( aEstBrw , {} )
			aAdd( aEstBrw[ Len( aEstBrw ) ] , X3Titulo() )
			For nEst2 := 1 To Len( aEstTot[ nEst ] )
				aAdd( aEstBrw[ Len( aEstBrw ) ] , aEstTot[ nEst , nEst2 ] )
			Next nEst2
			aAdd( aEstBrw[ Len( aEstBrw ) ] , PesqPict(Posicione("SX3",2,aEstTot[nEst,1],"X3_ARQUIVO"), aEstTot[nEst,1]) )

		EndIf
	Next nEst

	aBrowse := aClone( aEstBrw )

	aIndex := NGRETINDTAB( cAliTmp )

	If Len( aIndex ) > 0

		For nIndex := 1 To Len( aIndex )

			cChave := aIndex[ nIndex ]
			
			// Verifica se podera utilizar o indice, conforme os campos utilizados
			If CanUseInd( cChave , aEstrutura )
				If aScan( aIndexes , {|x| x[1] == AllTrim( cChave ) } ) == 0
					cOrdem   := AllTrim( AllToChar( nIndex ) )
					cDescInd := Posicione( "SIX", 1, cAliTmp + cOrdem, "DESCRICAO" )
					aAdd( aIndexes , { AllTrim( cChave ) , AllTrim( cDescInd ) } )
				Endif
			Endif

			// Verifica se podera utilizar o indice, conforme os campos utilizados no BROWSE
			If CanUseInd( cChave , aEstBrw , 2 )
				If aScan( aIndBrw , {|x| x[1] == AllTrim( cChave ) } ) == 0
					cOrdem   := AllTrim( AllToChar( nIndex ) )
					cDescInd := Posicione( "SIX", 1, cAliTmp + cOrdem, "DESCRICAO" )
					aAdd( aIndBrw , { AllTrim( cChave ) , AllTrim( cDescInd ) } )
				Endif
			Endif

		Next nIndex

	EndIf

	aIndex  := aClone( aIndexes )
	aIdxBrw	:= aClone( aIndBrw )

	RestArea( aArea )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} CanUseInd
Verifica se o indice pode ser utilizado conforme os campos pre-definidos.

@sample
CanUseInd( "XXX_FILIAL" , { { "XXX_FILIAL" , "C" , 2 , 0 } } )

@param cIndex  Indice a ser avaliado.  - Obrigatorio
@param aFldBrw Array com os campos pre-definidos.  - Obrigatorio

@author Jackson Machado
@since 16/01/2013
@return Logico Indica se o indice pode ser usado
/*/
//---------------------------------------------------------------------
Static Function CanUseInd( cIndex , aFldBrw , nPosCpo )

	Local lIndexOk := .T.
	Local aFields  := {}
	Local nInd

	Default nPosCpo := 1

	If Empty(aFldBrw)
		Return .T.
	Endif

	// Seleciona campos presentes no indice
	aFields := StrTokArr( AllTrim(cIndex), "+" )

	// Verifica se algum dos campos nao esta definido previamente
	For nInd := 1 To Len(aFields)
		If !( lIndexOk := ( aScan( aFldBrw, {|x| AllTrim( Upper( x[ nPosCpo ] ) ) $ AllTrim( Upper( aFields[ nInd ] ) ) .OR. ;
		"_FILIAL" $ AllTrim( Upper( aFields[ nInd ] ) ) } ) > 0 ) )
			Exit
		Endif
	Next nInd

Return lIndexOk

//---------------------------------------------------------------------
/*/{Protheus.doc} NGPESQTEMP
Monta Dialog de Janela para Pesquisa em Arquivo Temporário
Para correto funcionamento da Funcao, faz-se necessario a declaracao de um array
contendo todos os indices disponiveis, este array deve ser nomeado aIndPTmp e
sera utilizado na funcao fRetIndex

Uso Generico

@sample
NGPESQTEMP( "TRB" , 1 , 1 )

@param  cAlias - Alias de Trabalho - Obrigatorio
@param  nRec   - Recno posicionado
@param  nOpcx  - Opção do MenuDef

@author Jackson Machado
@since 16/01/2013
@return Nil
@version 1.0
/*/
//---------------------------------------------------------------------
Function NGPESQTEMP( cAlias , nRec , nOpcx )

	//Declaracao de variavies
	Local oDialog, oCbx, cOrd, oGet
	Local nOrd     := 1
	Local nIndex   := fPesqIndex( cAlias )
	Local cCampo   := Space(120)
	Local lMenuDef := ( ProcName( 1 ) == "MBRBLIND" ) .Or. RunInMenuDef()//Define se foi chamado pelo MenuDef
	Local aOrd     := {}

	If ( cAlias )->( Eof() )//Caso esteja em final de arquivo, valida.
		If lMenuDef //Se for chamado via Menu Funcional exibe outra mensagem
			Help(" ",1,"ARQVAZIO")
		Else
			Help(" ",1,"A000FI")
		EndIf
		Return
	EndIf

	aOrd := fRetIndex( 2 ) //Seleciona o array descritivo dos indices
	cOrd := aOrd[ nIndex ]
	nOrd := nIndex

	//Monta a dialog
	DEFINE MSDIALOG oDialog FROM 00,00 TO 80,490 PIXEL TITLE OemToAnsi(STR0247) //"Pesquisa"

	//Monta o ComboBox com os indices
	oCbx := TComboBox():New( 05 , 05 , {|u| If(PCount() > 0, cOrd := u, cOrd)} , aOrd , 206 , 36 , oDialog , , ,;
	{|| nOrd := oCbx:nAt } , , , .T. , , , , {|| .T. } , , , , , "cOrd" )

	//Monta o get que ira receber o valor de pesquisa
	oGet := TGet():New( 22 , 05 , {|u| If(PCount() > 0, cCampo := u, cCampo)} , oDialog , 206 , 10 , "" , {|| .T. } , , , ,;
	.T. , , .T. , , .T. , , .F. , .F. , , .F. , .F. , , cCampo , , , , .T. )

	// Define os botoes
	// Caso confirme a tela, chama funcao para pesquisa, se retorar verdadeiro, fecha a tela
	SButton():New( 05 , 215 , 1 , {|| If(fPosiciona( cAlias , oCbx , cOrd , oGet , cCampo , nOrd ),oDialog:End(),) },;
	oDialog , .T. , /*cMsg*/ , /*bWhen*/ )
	// Caso cancele, apenas fecha a tela
	SButton():New( 20 , 215 , 2 , {|| oDialog:End() },;
	oDialog , .T. , /*cMsg*/ , /*bWhen*/ )

	ACTIVATE MSDIALOG oDialog CENTERED

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fPosiciona
Posiciona no registro selecionado

@sample
fPosiciona( "TRB" , oObj , "1" , oObj2 , "VEILEV" , 1 )

@param  cAlias - Alias de Trabalho - Obrigatorio
@param  oCbx   - Objeto do ComboBox
@param  cOrd   - Valor do Objeto do ComboBox
@param  oGet   - Objeto do TGet - Obrigatorio
@param  cCampo - Valor do Objeto do TGet - Obrigatorio
@param  nOrd   - Ordem a ser posicionada na tabela - Obrigatorio

@author Jackson Machado
@since 16/01/2013
@return Logico - Retorna verdadeiro caso posicione no registro e falso caso nao posicione
/*/
//---------------------------------------------------------------------
Static Function fPosiciona( cAlias , oCbx , cOrd , oGet , cCampo , nOrd )

	Local lRet := .T.//Declara variavel de controle de retorno

	dbSelectArea( cAlias )//Posiciona no alias
	dbSetOrder( nOrd )//Posiciona no indice selecionado
	If !dbSeek( AllTrim( cCampo ) )//Realiza a pesquisa de acordo com o valor do GET
		//Caso nao encontre, mostra a mensagem
		ShowHelpDlg( STR0025 , { STR0392 } , 1 , ; //"ATENCAO"###"Nenhuma resultado foi encontrado."
		{ STR0393 } , 1 ) //"Realize uma nova pesquisa."
		oGet:SetFocus()//Seta o foco no Get para realizacao de nova pesquisa
		lRet := .F.	//Altera variavel do controle de retorno para retornar falso
	EndIf

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} fRetIndex
Retorna os indices utilizados

@sample fRetIndex( 1 )

@param  nType - Indica o tipo de retorno
1 - Indice para utilizacao
2 - Descricao dos indices
Caso nao seja definido retorna ambos

@author Jackson Machado
@since 16/01/2013
@return Array - Retorna o indice utilizado de acordo com a necessidade
/*/
//---------------------------------------------------------------------
Static Function fRetIndex( nType )

	//Declaracao de variavies
	Local nIndex  := 0  // Variavel de For
	Local aDesc   := {} // Array com as descricoes dos indices
	Local aIndex  := {} // Array com os indices
	Local aReturn := {} // Array bidimencional contendo o array de descricoes e o array de indices

	Default nType := 0 // Declara o tipo como 0 para retornar o aReturn completo

	For nIndex := 1 To Len( aIndPTmp ) // Percorre o array de indices, adicionando os arrays secundarios
		// Retira o DTOS dos Índices
		If 'DTOS' $ aIndPTmp[ nIndex , 1 ]
			aIndPTmp[ nIndex , 1 ] := StrTran( aIndPTmp[ nIndex , 1 ], 'DTOS(', '' )
			aIndPTmp[ nIndex , 1 ] := StrTran( aIndPTmp[ nIndex , 1 ], ')', '' )
		EndIf
		aAdd( aIndex , aIndPTmp[ nIndex , 1 ] ) // Adiciona os valores dos indices no array de indices
		aAdd( aDesc  , aIndPTmp[ nIndex , 2 ] ) // Adiciona as descricoes dos indices no array de indices
	Next nIndex

	aReturn := { aIndex , aDesc } // Adiciona no array de retorno o array de valores dos indices e de descricoes dos indices
	aReturn := IIf( nType <> 0 , aClone( aReturn[ nType ] ) , aClone( aReturn ) ) // Caso tipo diferente de 0, retorna de acordo com a tipo informado

Return aReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} fPesqIndex
Pesquisa o indice selecionado

@sample
fPesqIndex()

@param  cAlias - Alias a ser pesquisado - Obrigatorio

@author Jackson Machado
@since 16/01/2013
@return Numerico - Retorna o valor do indice selecionado
/*/
//---------------------------------------------------------------------
Static Function fPesqIndex( cAlias )

	Local nIndex    := 1, nIdx := 1
	Local cIndexTRB := ( cAlias )->( IndexKey() ) //Verifica qual o indice no exato momento no TRB
	Local aIndexTRB := fRetIndex( 1 )//Retorna todos os indices disponíveis no TRB

	//Realiza adequacao de espacos entre o indice
	cIndexTRB := StrTran(cIndexTRB,"+"," + ")

	//Adequa todos os indices
	For nIdx := 1 To Len( aIndexTRB )
		aIndexTRB[ nIdx ] := StrTran( aIndexTRB[ nIdx ] , " + " , "+" )
		aIndexTRB[ nIdx ] := StrTran( aIndexTRB[ nIdx ] , "+" , " + " )
	Next nIdx

	//Verifica se o indice esta nos indices de criacao
	nIndex    := aScan( aIndexTRB , { |x| AllTrim( x ) == AllTrim( cIndexTRB ) } )

	//Caso nao localize o indice solicitado
	If nIndex == 0
		ShowHelpDlg( STR0025 , { STR0394 } , 1 , ; //"ATENCAO"###"Índice não encontrado."
		{ STR0395 } , 1 ) //"Contate o administrador do sistema."
		nIndex := 1
	Endif

Return nIndex

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGRETIRAHOR³ Autor ³In cio Luiz Kolling    ³ Data ³28/03/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retira uma quantidade de hora(s) de um valor em horas        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cVarH - Valor da hora inicial                   - Obrigatorio³±±
±±³          ³cHorM - Valor a ser retirado da vari vel hora   - Obrigatorio³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³vRetH - Vetor com os dados [1] valor da hora, [2] Dias a des-³±±
±±³          ³        contar se houver uma data de referencia              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGRETIRAHOR(cVarH,cHorM)
	Local nDiasD := 0, vRetH := {'00:00',nDiasD}
	nHoraH := Htom(cVarH)
	nHoraM := Htom(cHorM)

	If nHoraM > nHoraH
		nHoraD := nHoraH - nHoraM

		If nHoraD < -1440
			nDiasI := Int((nHoraD * -1) / 1440)
			nResto := (nHoraD*-1) - (nDiasI * 1440)
			nHoraF := 1440 - nResto
			nDiasD ++
			nHorDi := nHoraM-nHoraH
			nDiasD += If(nHorDi > 0,Int(nHorDi / 1440),0)
		Else
			nHoraF := 1440 - (nHoraD * -1)
			nDiasD ++
		Endif

		vRetH[2] := nDiasD

	Else
		nHoraF := nHoraH - nHoraM
	Endif

	vRetH[1] := MtoH(nHoraF)

Return vRetH
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGALTCONTEU³ Autor ³ Inacio Luiz Kolling   ³ Data ³05/08/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Altera o conteudo de um campo Dicionario                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAlias  - Alias do arquivo/tabela              - Obrigatorio³±±
±±³          ³ cChav   - Chave de acesso                      - Obrigatorio³±±
±±³          ³ nInd    - Numero do indice                     - Obrigatorio³±±
±±³          ³ cCamp   - Nome do campo                        - Obrigatorio³±±
±±³          ³ cCont   - Conteudo                             - Obrigatorio³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³ .T.     - Alterou , .F. Nao alterou                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³OBSERVACAO³ Ser muito criterioso na utilizacao da funcao.   FUNCIONAL   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGALTCONTEU(cAlias,cChav,nInd,cCamp,cCont)

	//+-----------------------------------------------------------------------+
	//| não deve ser alterado dicionário via aplicação, apos garantir que tal |
	//| prática não ocorre mais, deverá ser removida esta função              |
	//+-----------------------------------------------------------------------+

	Local aAreaAt := GetArea(),lRet := .F.,lTipI := .F.
	If NGIFDICIONA(cAlias,cChav,nInd)
		aEstrD := DbStruct()
		If Ascan(aEstrD,{|x| x[1] == cCamp}) > 0
			cCa1 := cAlias+"->"+cCamp
			If type(cCa1) = Valtype(cCont)
				lTipI := .T.
			ElseIf type(cCa1) = 'M' .And. Valtype(cCont) = 'C'
				lTipI := .T.
			Endif
			If lTipI
				If &(cCa1) <> cCont .Or. cCont <> &(cCa1) //Problema de Build, onde a String maior deve ficar na direita para validar corretamente
					RecLock(cAlias,.F.)
					&(cCa1) := cCont
					(cAlias)->(MSUNLOCK())
					lRet := .T.
				Endif
			Endif
		Endif
	Endif
	RestArea(aAreaAt)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NGMAQUEZERO³ Autor ³ Inacio Luiz Kolling   ³ Data ³26/11/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se o valor e maior que zero                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nValor - Valor a ser comparado                    Obrigatorio³±±
±±³          ³ cCampo - Titulo do campo                          Nao Obrig. ³±±
±±³          ³ lDicX3 - Indica se Titulo e do Dicionario         Nao Obrig. ³±±
±±³          ³ lSaiTe - Saida via tela                           Nao Obrig. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³ lRetEo   - .T.,.F. Se lSaite = .T.                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGMAQUEZERO(nValor,cCampo,lDicX3,lSaiTe)
	Local lTela  := If(lSaiTe = Nil,.T.,lSaiTe),vRet := {.T.,Space(1)}
	Local cCampM := If(cCampo <> Nil,cCampo,Space(1))

	If nValor <= 0
		If lDicX3 <> Nil .And. cCampo <> Nil
			cCampM := NGRETTITULO(cCampo)
		Endif

		vRet := {.F.,If(cCampo <> Nil,STR0396+Alltrim(cCampM)+" "+STR0397,; //"Conteudo do campo"###"devera ser maior que zero (0)"
		vRet[2] := STR0398+" "+STR0397)} //"Conteudo"###"devera ser maior que zero (0)"
	Endif
	If !vRet[1]
		If lTela
			MsgInfo(vRet[2],STR0215)//"NAO CONFORMIDADE"
		Endif
	Endif
Return If(lTela,vRet[1],vRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³NGCHKFRASTO³ Autor ³In cio Luiz Kolling   ³ Data ³11/11/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Consistencia final do rastro e enderecamento fisico         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cCodEsto - Codigo do produto do estoque        - Obrigatorio³±±
±±³          ³dDataS   - Data de saida do estoque            - Obrigatorio³±±
±±³          ³cSubLote - Numero do sub-lote                  - Nao obrig. ³±±
±±³          ³cLotecTL - Numero do lote                      - Nao obrig. ³±±
±±³          ³cLocalEs - Codigo da localizacao estoque       - Nao obrig. ³±±
±±³          ³cNumSeri - Numero da serie                     - Nao obrig. ³±±
±±³          ³cLocalFi - Localizacao fisica                  - Nao obrig. ³±±
±±³          ³nQtdProd - Quantidade do produto               - Obrigatorio³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³.T.,.F.                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCHKFRASTO(cCodEsto,dDataS,cSubLote,cLotecTl,cLocalEs,cNumSeri,;
	cLocalFi,nQtdProd)

	Local aArAll  := GetArea()
	Local lEstNeg := SuperGetMV( 'MV_ESTNEG', .F., 'N' ) == 'S'
	
	If lESTNEG .Or. ( !lESTNEG .And. NGSALSB2( cCodEsto, cLocalEs, nQtdProd ) )

		//Valida saldo(SB8) de controle de rastreabilidade por lote do produto
		If Rastro(cCodEsto)

			If Rastro(cCodEsto,"S")
				//Valida o sub-lote
				If Empty(cSubLote)
					Help(" ",1,"NGATENCAO",,STR0399,3,1) //"Numero do sub-lote não informado"
					Return .F.
				Else
					If NGIFDBSEEK("SB8",cSubLote+cLotecTl+cCodEsto+cLocalEs,2,.F.)
						nSaldoLote := SB8Saldo(.F.,!Empty(cLotecTl+cSubLote),NIL,NIL,NIL,NIL,NIL,dDataS)
						If QtdComp(nSaldoLote) < QtdComp(nQtdProd)
							cHelp:=OemToAnsi(STR0007)+AllTrim(cCodEsto)+OemToAnsi(STR0400)+cLocalEs+OemToAnsi(STR0401); //"Produto"###"Local "###" Saldo Disponivel "
							+Alltrim(Transform(nSaldoLote,PesqPictQt("B8_SALDO", 14)))+OemToAnsi(STR0402)+Alltrim(cLotecTl); //"Lote"
							+OemToAnsi(STR0403)+Alltrim(cSubLote) //" Sub-lote "
							Help(" ",1,"A240LOTENE",,cHelp,4,1)
							Return .F.
						EndIf
					Else
						Help(" ",1,"NGATENCAO",,STR0404+CRLF+; //"Numero do sub-lote não corresponde ao produto que foi "
						STR0405,3,1)  //" informado. Digite um sub-lote correspondente."
						Return .F.
					EndIf
				EndIf
			Else
				//Valida o lote
				If Empty(cLotecTl)
					Help(" ",1,"NGATENCAO",,STR0406,3,1) //"Numero do lote não informado"
					Return .F.
				Else
					If NGIFDBSEEK("SB8",cCodEsto+cLocalEs+cLotecTl,3,.F.)
						nSaldo:=SaldoLote(cCodEsto,cLocalEs,cLotecTl,NIL,.F.,!Empty(cLotecTl+cSubLote),NIL,dDataS)
						If QtdComp(nSaldo) < QtdComp(nQtdProd)
							cHelp:=OemToAnsi(STR0407)+AllTrim(cCodEsto)+OemToAnsi(STR0408)+cLocalEs+OemToAnsi(STR0401); //"Produto "###" Local "###" Saldo Disponivel "
							+Alltrim(Transform(nSaldo,PesqPictQt("B8_SALDO", 14)))+" "+OemToAnsi(STR0409)+" "+Alltrim(cLotecTl)  //" Lote "
							Help(" ",1,"A240LOTENE",,cHelp,4,1)
							Return .F.
						EndIf
					Else
						Help(" ",1,"NGATENCAO",,STR0410+Chr(13)+Chr(10)+;  //"Numero do lote não corresponde ao produto que foi "
						STR0411,3,1)   //" informado. Digite um lote correspondente."
						Return .F.
					EndIf
				EndIf
			EndIf
		EndIf
		
		//Adicionado espaço na varial ve estoque pos a funcao localiza do estoque precisa estar com o campo do tamanho exato da SB1
		cCodEsto := PadR( cCodEsto, TAMSX3("B1_COD")[1] )

		//Verifica se ha problema na habilitacao do controle por enderecamento fisico
		If !Empty(cLocalFi) .Or. !Empty(cNumSeri)
			If !LOCALIZA(cCodEsto)
				MsgInfo(STR0412+' "MV_LOCALIZ" '+STR0413+"'B1_LOCALIZ'"+chr(13)+STR0414,STR0025) //"O paramtro"###"esta desativado ou o campo"###"do produto esta preenchido com N."
				Return .F.
			EndIf
		EndIf

		If LOCALIZA(Trim(cCodEsto))

			//Valida a obrigatoriedade de informar o enderecamento fisico se o produto
			//tem o controle
			If Empty(cLocalFi) .And. Empty(cNumSeri)
				Help(" ",1,"LOCALIZOBR")
				Return .F.
			ElseIf Empty(cLocalFi)
				Help(" ",1,"LOCALIZOBR")
				Return .F.
			EndIf

			If !Empty(cLocalFi)
				If !EXISTCPO("SBE",cLocalEs+cLocalFi)
					Return .F.
				EndIf
			EndIf

			//Verifica a obrigatoriedade da quantidade do insumo quando informado a serie
			If !MtAvlNSer(cCodEsto,cNumSeri,nQtdProd)
				Return .F.
			EndIf

			If (!Empty(cLocalFi) .Or. !Empty(cNumSeri)) .And.;
			QtdComp(SaldoSBF(cLocalEs,cLocalFi,cCodEsto,;
			cNumSeri,cLotecTl,cSubLote,.F.)) < QtdComp(nQtdProd)

				Help(" ",1,"SALDOLOCLZ")
				Return .F.
			EndIf
		EndIf

	EndIf

	RestArea( aArAll )

	/*--------------------------------------------------+
	| Desaloca consumo de memória p/ melhor performance |
	+--------------------------------------------------*/
	aSize( aArAll, 0 )
	aArAll := Nil

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGRASTOLOTE³ Autor ³Inacio Luiz Kolling    ³ Data ³08/11/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida o rastreabilidade do insumo do tipo produto no SB8    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cCodProd = Codigo do insumo                   - Obrigatorio  ³±±
±±³          ³cLocalEs = Local do insumo                    - Obrigatorio  ³±±
±±³          ³cLoteCTL = Numero do lote                     - Obrigatorio  ³±±
±±³          ³cSubLote = Numero do sub-lote                 - Nao Obrigat. ³±±
±±³          ³cVarDatv = Data de validade                   - Nao Obrigat. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³.T.,.F.                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGRASTOLOTE(cCodProd,cLocalEs,cLoteCTL,cSubLote,cVarDatv)

	//Valida controle por sub-lote
	If Rastro(cCodProd,"S")
		If !Empty(cSubLote)
			If NGIFDBSEEK("SB8",cSubLote,2) .And. cCodProd+cLocalEs == SB8->B8_PRODUTO+SB8->B8_LOCAL
				If cLoteCTL != SB8->B8_LOTECTL
					Help(" ",1,"A240LOTCTL")
					Return .F.
				Else
					If NGCONDTSB8(SB8->B8_DTVALID)
						If cVarDatv <> Nil
							&(cVarDatv) := SB8->B8_DTVALID
						Endif
					Else
						Return .F.
					EndIf
				EndIf
			EndIf
		EndIf
	Else
		//Valida controle por lote
		If !Empty(cLoteCTL)
			If !NGIFDBSEEK("SB8",cCodProd+cLocalEs+cLoteCTL,3)
				Help(" ",1,"NGATENCAO",,STR0410+Chr(13)+Chr(10)+;  //"Numero do lote não corresponde ao produto que foi "
				STR0411,3,1) //" informado. Digite um lote correspondente."
				Return .F.
			Else
				If NGCONDTSB8(SB8->B8_DTVALID)
					If cVarDatv <> Nil
						&(cVarDatv) := SB8->B8_DTVALID
					Endif
				Else
					Return .F.
				EndIf
			EndIf
		EndIf
	EndIf

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGRASSUBLOTE³ Autor ³Inacio Luiz Kolling   ³ Data ³08/11/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida o rastreabilidade do Sub-Lote do produto no SB8       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cCodProd = Codigo do insumo                   - Obrigatorio  ³±±
±±³          ³cLocalEs = Local do insumo                    - Obrigatorio  ³±±
±±³          ³cSubLote = Numero do sub-lote                 - Nao Obrigat. ³±±
±±³          ³cVarLCTL = Numero do lote                     - Obrigatario  ³±±
±±³          ³cVarDatv = Data de validade                   - Nao Obrigat. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³.T.,.F.                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGRASSUBLOTE(cCodProd,cLocalEs,cSubLote,cVarLCTL,cVarDatv)
	If Rastro(cCodProd,"S")
		If !Empty(cSubLote)
			If NGIFDBSEEK("SB8",cSubLote,2) .And. cCodProd+cLocalEs == SB8->B8_PRODUTO+SB8->B8_LOCAL
				If NGCONDTSB8(SB8->B8_DTVALID)
					If cVarLCTL <> Nil
						&(cVarLCTL) := SB8->B8_LOTECTL
					Endif
					If cVarDatv <> Nil
						&(cVarDatv) := SB8->B8_DTVALID
					Endif
				Else
					Return .F.
				EndIf
			Else
				Help(" ",1,"NGATENCAO",,STR0404+Chr(13)+Chr(10)+; //"Numero do sub-lote não corresponde ao produto que foi "
				STR0405,3,1) //" informado. Digite um sub-lote correspondente."
				Return .F.
			EndIf
		EndIf
	EndIf
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} NGProdEsp
Consiste o codigo do produto.
@type function

@author Inacio Luiz Kolling
@since 17/05/2010

@sample NGProdEsp( 'CodPro' )

@param cCodPro , Caracter, Código do produto a ser validado.
@param [lSaida], Lógico  , Mensagem via tela.
@param [cParam], Caracter, Parametro a verificar: ( '*' -> Todos, 'M' -> MV_PRODMNT, 'T' -> MV_PRODTER (Terceiro))

@return Array  , [1] -> .T.,.F. / [2] -> Mensagem
/*/
//-------------------------------------------------------------------
Function NGPRODESP( cCodPro, lSaida, cParam )

	Local aAreaStl  := STL->( GetArea() )
	Local vVetRet   := { .T., '  ' }
	Local aProdutos := {}
	Local cCodTer   := ''
	Local cCodMan   := ''
	Local lRet      := .T.

	Default lSaida := .T.
	Default cParam := '*'

	If !NGIFDBSEEK( 'SB1', AllTrim( cCodPro ), 1, .F. )
		vVetRet := { .F., 'RECNOIS' }
	ElseIf nModulo == 19 .Or. nModulo == 95//SIGAMNT e SIGAGFR

		If !( AllTrim( GetNewPar( 'MV_NGINTER', 'N' )) == 'L' )
			
			/*-----------------------------------------------------------+
			| Quando produto de controle de mão de obra, retorna 'Falso' |
			+-----------------------------------------------------------*/
			If MntProdMod( cCodPro )
				vVetRet:= { .F., 'NGMMODTEMA' }
			EndIf
			
		EndIf

		If vVetRet[1]
			If FindFunction( 'NGProdMNT' )
				aProdutos := aClone( NGProdMNT( cParam ) )
				If aScan(aProdutos, {|x| AllTrim(x) == AllTrim(cCodPro) }) > 0
					vVetRet:= {.F.,"NGMMODTEMA"}
				EndIf
			Else
				cCodTer := GetMv("MV_PRODTER")
				cCodMan := GetMv("MV_PRODMNT")

				lRet := .T.
				If cParam == '*' .And. ( cCodPro == SubStr(cCodTer, 1, Len( SB1->B1_COD ) ) .Or. cCodPro == SubStr( cCodMan, 1, Len( SB1->B1_COD ) ) )
					lRet := .F.
				ElseIf cParam == 'T' .And. ( cCodPro == SubStr( cCodTer, 1, Len( SB1->B1_COD ) ) )
					lRet := .F.
				ElseIf cParam == 'M' .And. ( cCodPro == SubStr( cCodMan, 1, Len( SB1->B1_COD ) ) )
					lRet := .F.
				EndIf

				If !lRet
					vVetRet:= {.F.,"NGMMODTEMA"}
				EndIf
			EndIf
		EndIf

	EndIf

	If !vVetRet[1] .And. lSaida
		Help( ' ', 1, vVetRet[2] )
	EndIf

	RestArea( aAreaStl )

Return vVetRet[1]

//---------------------------------------------------------------------
/*/{Protheus.doc} NGEXPLSTR
Explode string conforme separador informado no parametro
OBS.: CONSIDERA CAMPOS VAZIOS
Função desenvolvida devido o STRTOKARR não considerar posições que estejam
vazias.

@param String cString: indica String a ser explodida
@param String cSeparador: indica separador da string para gerar array
@author André Felipe Joriatti
@since 12/11/2013
@version P11
@return Array aSeparado: array contendo a string explodida conforme
separador
/*/
//---------------------------------------------------------------------

Function NGEXPLSTR( cString,cSeparador )

	Local aSeparado  := {}
	Local nI         := 0
	Local nContSep   := 0
	Local nInic      := 0
	Local nAndar     := 0
	Local cConteudo  := ""
	Local nPosSepAnt := 0

	For nI := 1 To Len( cString )
		If SubStr( cString,nI,1 ) == cSeparador

			nInic  := nPosSepAnt + 1
			nAndar := ( nI - 1 ) - nPosSepAnt

			cConteudo := If( nAndar == 0,"",SubStr( cString,nInic,nAndar ) )
			aAdd( aSeparado,cConteudo )

			nContSep++
			nPosSepAnt := nI
		EndIf
	Next nI

	If Len( cString ) - nPosSepAnt == 0
		cConteudo := ""
	Else
		cConteudo := SubStr( cString,nPosSepAnt+1,Len( cString ) - nPosSepAnt )
	EndIf

	aAdd( aSeparado,cConteudo )

Return aSeparado

//---------------------------------------------------------------------
/*/{Protheus.doc} NGF3TAR
F3 para a tarefa padrão

@author Inácio Luiz Kolling
@since 20/10/2008
@param cCamp - Código do campo do dicionário
@return .T.
/*/
//---------------------------------------------------------------------
Function NGF3TAR(cCamp)

	Local cF3Tar := "ST5"

	If NGExistVar("cPrograma")
		If cPrograma $ 'MNTA400/MNTA402'
			If !Inclui
				Return .F.
			Endif
		Endif
	Endif

	If NGExistVar("lCorret")
		If ( lCORRET .Or. STJ->TJ_SERVICO == 'HISTOR' ) .And. NGUSATARPAD()
			cF3Tar := "TT9"
		Endif
	Endif

	aTROCAF3 := {}

	If ExistBlock( 'NGTROCF3' )
		
		cF3TAR := ExecBlock( 'NGTROCF3', .F., .F. )
		
	EndIf

	aAdd(aTROCAF3,{cCamp,cF3TAR})
	
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGProAlm
Verifica se o produto está no almoxarifado informado

@author Inácio Luiz Kolling
@since 26/09/2001

@param cCodPro - Indica o código do produto
@param cAlmoxa - Indica o código do almoxarifado

@return .T.
/*/
//---------------------------------------------------------------------
Function NGProAlm(cCodPro, cAlmoxa, nPos)

	Local aOldArea := GetArea()

	dbSelectArea("SB2")
	dbSetOrder(1)
	If !dbSeek( xFilial('SB2') + cCodPro + cAlmoxa)
		If !Empty(cAlmoxa)

			CriaSB2(cCodPro, cALMOXA)

			// A função acima não libera o registro, por isso é necessário o MsUnlock
			SB2->(MsUnLock())

			NGAtuErp("SB2","INSERT")
		EndIf
	EndIf

	RestArea(aOldArea)

Return .T.


//-------------------------------------------------------------------------
/*/{Protheus.doc} NGAtuErp
Faz a geração dos registros para a tabela de integração com outros ERP's.
@type function

@author Rafael Diogo Richter
@since 07/05/2008

@param cAlias   , string, Indica o código do produto.
@param cTipo    , string, Indica o código do almoxarifado.
@param [cSC1Del], string, Indica o item da S.C. que deve ser deletado.

@return boolean, Indica se o processo foi executado com sucesso.
/*/
//-------------------------------------------------------------------------
Function NGAtuErp( cAlias, cOper, cSC1Del )

	Local aAreaErp  := GetArea()
	Local lOk       := .T.
	Local g         := 0
	Local t         := 0
	Local y         := 0
	Local aInt		:= {}
	Local aSet		:= {}

	Default cSC1Del := ''

	If ExistBlock("NGAtuErp")

		ExecBlock("NGAtuErp", .F., .F., { cAlias, cOper } )

	Else

		If AllTrim( GetNewPar("MV_NGINTER", "N") ) == "L"

			If FindFunction("NGBaseLog")
				NGBaseLog()
			EndIf

			//Tabelas não serão enviadas ao Logix
			If cAlias == "SB2" .Or. cAlias == "SC1" .Or. cAlias == "SC2" .Or. cAlias == "SB1"

				lOk := .F.

			Else

				//Tratamento para devolução (DE1) enviar operação DELETE
				If cAlias == "SD3" .And. SD3->D3_CF == 'DE1'
					cOper := 'DELETE'
				EndIf

				t := 1

				If cOper == "INSERT"

					aAdd( aInt, {"INSERT", "tabela", cAlias, 3, t, 1, 1 } )

				ElseIf cOper == "UPDATE"

					c := 1
					aAdd( aInt, {"UPDATE", "tabela", cAlias, 3, t, 1, 1} )

				ElseIf cOper == "DELETE"

					aAdd( aInt, {"DELETE", "tabela", cAlias, 3, t, 1, 1} )

				EndIf

				For g := 1 To (cAlias)->( FCount() )

					cCampo		:= ""
					nTipCamp	:= 0

					If ValType( &(cAlias + "->" + (cAlias)->(FieldName(g))) ) == "C"

						cCampo := &(cAlias + "->" + (cAlias)->(FieldName(g)) )
						nTipCamp := 3

					ElseIf ValType( &(cAlias+"->"+(cAlias)->(FieldName(g))) ) == "N"

						cCampo := Alltrim(Str(&(cAlias+"->"+(cAlias)->(FieldName(g)))))
						nTipCamp := 5

					ElseIf ValType( &(cAlias+"->"+(cAlias)->(FieldName(g))) ) == "D"

						cCampo := DToC( &(cAlias+"->"+(cAlias)->(FieldName(g))) )
						nTipCamp := 4

					EndIf

					If cOper == "INSERT"

						aAdd( aInt, {"INSERT", (cAlias)->(FieldName(g)),	cCampo, nTipCamp, t, 1, g + 1} )

					ElseIf cOper == "UPDATE"

						dbSelectArea("SIX")
						dbSetOrder(1)
						dbSeek(cAlias)
						If (cAlias)->( FieldName(g) ) $ SIX->CHAVE

							c++
							aAdd( aInt, {"WHERE", (cAlias)->(FieldName(g)), cCampo, nTipCamp, t, 1, c} )
							Loop

						EndIf

						aAdd( aSET, {"SET", (cAlias)->(FieldName(g)), cCampo, nTipCamp, t, 1, 2} )

					ElseIf cOper == "DELETE"

						dbSelectArea("SIX")
						dbSetOrder(1)
						dbSeek(cAlias)
						If ((cAlias)->(FieldName(g)) $ SIX->CHAVE) .Or. ;
						((cAlias)->(FieldName(g)) == 'D3_LOTECTL' .Or.;
						(cAlias)->(FieldName(g)) == 'D3_NUMLOTE')

							aAdd( aInt, {"WHERE",(cAlias)->(FieldName(g)),	cCampo	,nTipCamp,t,1,g+1} )

						EndIf
					EndIf

				Next g

				If cOper == "INSERT"

					If cAlias == "SD3"
						aAdd( aInt, {"INSERT","D3_CCUSTO",	NGSEEK("STJ",SubStr(SD3->D3_OP,1,6),1,"STJ->TJ_CCUSTO")	,3,1,1,Len(aInt)+1} )
					ElseIf cAlias == "SD4"
						aAdd( aInt, {"INSERT","D4_CCUSTO",	NGSEEK("STJ",SubStr(SD4->D4_OP,1,6),1,"STJ->TJ_CCUSTO")	,3,1,1,Len(aInt)+1} )
					EndIf

				ElseIf cOper == "UPDATE"

					For y := 1 To Len(aSET)
						c++
						aAdd( aInt, {aSet[y][1], aSet[y][2], aSet[y][3], aSet[y][4], aSet[y][5], aSet[y][6], c} )
					Next y

				EndIf

				//Envia o usuário logado que realizou a inclusão\alteração\exclusão
				If cOper == "INSERT"
					aAdd( aInt, {"INSERT","USUARIO",cUserName	,3,t,1,g+2} )
				ElseIf cOper == "UPDATE"
					aAdd( aInt, {"SET","USUARIO",cUserName	,3,t,1,g+2} )
				EndIf

				NGIntLogix("S",aInt)

			EndIf

		ElseIf AllTrim( GetNewPar("MV_NGINTER","N") ) == "M"  //Mensagem Unica

			// Solicitação de Compras
			If cAlias == 'SC1' .And. cOper == 'DELETE'

				lOk := NGMUReques( SC1->( RecNo() ), 'SC1', .F., 5, , , cSC1Del )

			EndIf

		EndIf

	EndIf

	RestArea(aAreaErp)

Return lOk

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³NGIMPMEMO ³ Autor ³ Inacio Luiz Kolling   ³ Data ³ 04/06/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Imprime campo MEMO                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cDESCRIC   - Campo MEMO para ser impresso                  ³±±
±±³          ³ nTAM       - Tamanho da linha a ser impresso               ³±±
±±³          ³ nCOL       - Posi‡Æo em que come‡a a ser impresso          ³±±
±±³          ³ cTITULO    - T¡tulo que precede a primeira linha de impres.³±±
±±³          ³ lPRIMEIRO  - Indica se ser  impresso o t¡tulo              ³±±
±±³          ³ lSOMALINHA - Indica se ser  somado a linha antes de impri- ³±±
±±³          ³              mir o t¡tulo com a primeira linha da cDESCRIC ³±±
±±³          ³ cSOMALI    - Nome da fun‡Æo que imprime o cabe‡alho especi-³±±
±±³          ³              para o programa em questÆo                    ³±±
±±³          ³ nLPAG      - Quantidade de linhas por pagina               ³±±
±±³          ³                                                            ³±±
±±³          ³ Ex: NGIMPMEMO(ST9->T9_DESCRIC,56,0,"Descricao..:",.F.,.F., ³±±
±±³          ³               "NGCABEC1()",40)                             ³±±
±±³          ³ Ex: NGIMPMEMO(TPA->TPA_DESCRI,56,0,,.F.,.F.)               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGIMPMEMO(cDESCRIC,nTAM,nCOL,cTITULO,lPRIMEIRO,lSOMALINHA,cSOMALI,nLPAG)
	Local nLINHAPG := If (nLPAG = Nil,58,nLPAG),LinhaCorrente
	If !Empty(cDESCRIC)
		nLinhasMemo = MLCOUNT(cDESCRIC,nTAM)
		For LinhaCorrente := 1 to nLinhasMemo
			If lSOMALINHA
				If cSOMALI <> Nil
					EVAL({|A| &(cSOMALI)})
				Else
					NGSOMALI(nLINHAPG)
				EndIf
				lSOMALINHA := .F.
			EndIf
			If !empty(MemoLine(cDESCRIC,nTAM,LinhaCorrente))
				If !lPRIMEIRO
					@ Li,nCOL PSay cTITULO
					lPRIMEIRO := .T.
					If !Empty(cTITULO)
						nCOL := nCOL + Len(cTITULO)
					EndIf
				EndIf
				@ Li,nCOL PSay (MemoLine(cDESCRIC,nTAM,LinhaCorrente))
				If cSOMALI <> Nil
					EVAL({|A| &(cSOMALI)})
				Else
					NGSOMALI(nLINHAPG)
				EndIf
			EndIf
		Next
	EndIf
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCONPROC  ³ Autor ³ NG INFORMATICA       ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Processa a consulta                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCONPROC(cALI,cTRB,cKEY,bWHILE,bFOR,lSoftSeek,bGRAVAFIL)

	DbSelectArea(cALI)
	If Empty(cKey)
		DbSeek(xFilial(cALI))
	Else
		DbSeek(xFilial(cALI) + cKEY)
	Endif
	nTOTREG := 0
	DbEval({|| nTOTREG++},bFOR,bWHILE)

	ProcRegua(nTOTREG)

	DbSelectArea(cALI)
	If Empty(cKey)
		DbSeek(xFilial(cALI), lSoftSeek)
	Else
		DbSeek(xFilial(cALI) + cKEY, lSoftSeek)
	Endif
	DbEval( {||NGGRAVACON(cALI, cTRB) }, bFOR, bWHILE )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se Possuir executa CODBLOCK defindo em bGRAVAFIL                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(bGRAVAFIL)
		Eval(bGRAVAFIL,cALI)
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGGravaCon
Carrega conteudo da consulta na TRB

@sample NGGravaCon(cAlias, cTrb)
@param cAlias, Caracter, Tabela de onde os registros estão gravados.
       cTrb  , Caracter, TRB onde os registros serão carregados.
@return

@author NG INFORMATICA
@since 04/07/2018
/*/
//---------------------------------------------------------------------
Static Function NGGravaCon(cAlias, cTrb)

	Local nInd     := 0
	Local cCampo   := ""
	Local cConteud := ""
	Local cCmpTrb  := ""

	IncProc()
	dbSelectArea(cTrb)
	dbAppend()

	For nInd := 1 To FCount()

		cCmpTrb := FieldName(nInd)
		dbSelectArea("SX3")
		dbSetOrder(2)
		If dbSeek(cCmpTrb) .And. Posicione("SX3", 2, cCmpTrb, "X3_BROWSE") == "S" .And. Posicione("SX3", 2, cCmpTrb, "X3_CONTEXT") == "V"
			cCampo    := cTrb + "->" + cCmpTrb
			cConteud  := AllTrim(Posicione("SX3", 2, cCmpTrb, "X3_INIBRW"))
			&cCampo. := &cConteud.
			dbSelectArea(cTrb)
			Loop
		EndIf

		dbSelectArea(cAlias)
		If cCmpTrb == "RECORIG"
			cCmpTrb   := cTrb + "->RECORIG"
			&cCmpTrb. := RecNo()
			dbSelectArea(cTrb)
			Loop
		EndIf

		If cCmpTrb == "TBLORIG"
			cCmpTrb   := cTrb + "->TBLORIG"
			&cCmpTrb. := cAlias
			dbSelectArea(cTrb)
			Loop
		EndIf

		If FieldPos(cCmpTrb) == 0
			dbSelectArea(cTrb)
			Loop
		EndIf

		dbSelectArea(cTrb)
		cCmpTrb   := cTrb + "->" + FieldName(nInd)
		cConteud  := cAlias + "->" + FieldName(nInd)
		&cCmpTrb. := &cConteud.

	Next nInd

	dbSelectArea(cAlias)
Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NGALTCALE
Consistencia de calendario na troca de controle de calendário.

@author	Inacio Luiz Kolling
@since		17/06/2006
@version	MP11 e MP12
/*/
//---------------------------------------------------------------------
Function NGALTCALE()

	Local lCHKQTD	 := .T.
	Local lUSALEOK := .F.
	Local lHORDTOK := .T.

	If Type( "M->TL_TIPOREG" ) == "C"
		If M->TL_TIPOREG <> "M"
			Return .T.
		EndIf
	EndIf

	lGETACH  := .T.
	If type( "aHeader" ) == "A"

		nTIPO := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})

		If nTIPO > 0
			If aCols[n,nTIPO] <> "M"
				Return .T.
			EndIf
			lGETACH := .F.
		EndIf
	EndIf

	If Type( "lPREVIS" ) == "L"
		If lPREVIS
			lCHKQTD := .F.
		EndIf
	EndIf

	If lCHKQTD
		If !lGETACH

			nUSAL := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_USACALE"})

			If nUSAL > 0 .And. aCols[n][nUsal] = "S"
				lUSALEOK := .T.
				nDTIN := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
				nHOIN := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_HOINICI"})
				nDTFI := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_DTFIM"})
				nHOFI := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_HOFIM"})
				nHOFI := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_HOFIM"})
				nCODI := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_CODIGO"})

				If nDTIN > 0 .And. nHOIN > 0 .And. nDTFI > 0 .And. nHOFI > 0 .And. nCODI > 0
					M->TL_DTINICI := aCols[n,nDTIN]
					M->TL_HOINICI := aCols[n,nHOIN]
					M->TL_DTFIM   := aCols[n,nDTFI]
					M->TL_HOFIM   := aCols[n,nHOFI]
					M->TL_CODIGO  := aCols[n,nCODI]
				Else
					MsgInfo( STR0115+chr(13)+STR0116,STR0053 )
					Return .F.
				EndIf
			EndIf
		Else
			If M->TL_USACALE == "S"
				lUSALEOK := .T.
			EndIf
		EndIf

		If lUSALEOK
			// Valida a data e hora inicio do calendario
			cCODCAL := NGSEEK("ST1",Substr( M->TL_CODIGO,1,6 ),1,"T1_TURNO")
			If !Empty( M->TL_DTINICI ) .And. !Empty( M->TL_HOINICI )
				lHORDTOK := NGVALHRCALE( cCODCAL,M->TL_DTINICI,M->TL_HOINICI,"I" )
			EndIf

			// Valida a data e hora fim do calendario
			If lHORDTOK
				If !Empty( M->TL_DTFIM ) .And. !Empty( M->TL_HOFIM )
					lHORDTOK := NGVALHRCALE( cCODCAL,M->TL_DTFIM,M->TL_HOFIM,"F" )
				EndIf
			EndIf
		EndIf
	EndIf

Return lHORDTOK

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³ CHKHELP  ³ Autor ³ NG INFORMATICA LTDA   ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Monta uma mensagem de saida (Help)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CHKHELP(cTit)
	Help(" ",1,cTIT)
Return .F.

//-------------------------------------------------------------------
/*/{Protheus.doc} NGUseTWF
Verifica se as premissas para a utilização da classe TWFProcess são atendidas.
@type  Function

@author Lucas Meneghelli Pereira
@since 22/11/2018

@param cNameWF, Caracter, Nome do arquivo .htm do WorkFlow a ser enviado.
@return Array, array que indica se existe o arquivo .htm no servidor para envio de WF e retorna uma string com
o erro caso exista.
	- [1]: Logical  , Indica se existe o arquivo .htm no servidor para envio de WF.
	- [2]: Character, String com o erro caso exista.
/*/
//-------------------------------------------------------------------
Function NGUseTWF( cNameWF )

	Local cFile       := cNameWF + '.htm'
	Local cError      := ''
	Local cBarras     := IIf( isSRVunix() , '/', '\' )

	// Caminho do diretório de WorkFlow aonde o arquivo .htm, modelo do workFlow, está localizado.
	Local cDir := AllTrim( SuperGetMv( 'MV_WFDIR', .F., '' ) )

	// Adiciona a barra no final do parametro do diretorio
	If Substr( cDir, Len( cDir ), 1 ) != cBarras
		cDir += cBarras
	Endif

	If ExistDir( cDir )

		//Verifica se existe o arquivo de workflow
		If !File( cDir + cFile )

			// Não foi possivel localizar o arquivo XXXX.htm
			cError := STR0231 + cFile
			// no diretório XXXXXXX
			cError += STR0232 + cDir + '. ' + CRLF
			// Favor verifique se o parâmetro MV_WFDIR foi configurado corretamente e se o arquivo XXXX.htm encontra-se
			// no diretório descrito no parâmetro.
			cError += '  ' + STR0488 + cFile + STR0489

		EndIf

	Else

		// Não foi possivel localizar o diretório XXXX. FError: XXX
		cError := STR0493 + cDir + '. ' + STR0494 + cValToChar( fError() ) + CRLF
		// Favor verificar se o parâmetro MV_WFDIR foi configurado corretamente e se o acesso ao diretório é permitido.
		cError += '  ' + STR0495

	EndIf

Return { Empty( cError ), cError }

//-------------------------------------------------------------------
/*/{Protheus.doc} NGValidTWF
Função para validação dos parâmetros de envio de WorkFlow

@type  Function
@author Lucas Meneghelli Pereira
@since 21/11/2018

@param cNameWF  , Caracter, Nome do arquivo .htm do WorkFlow a ser enviado.

@return return, logic, indica se os parâmetros são válidos

/*/
//-------------------------------------------------------------------
Function NGValidTWF( cNameWF )

	Local cMailBox  := SuperGetMv( 'MV_WFMLBOX', .F., '' )
	Local lAuth     := SuperGetMV( 'MV_RELAUTH', .F., .F. )
	Local cErrors   := ''
	Local cServer   := ''
	Local cPassServ := ''
	Local cUsuServ  := ''
	Local aUseTWF   := {}
	Local nRet      := 0
	Local lSSL      := .F.
	Local lTLS      := .F.
	Local oServer   := Nil

	aUseTWF := NGUseTWF( cNameWF )

	// Verifica se utiliza TWFProcess para envio de WF
	If !aUseTWF[1]
		cErrors += '- ' + aUseTWF[2] + CRLF
	EndIf

	If !Empty( cMailBox )

		dbSelectArea( 'WF7' )
		dbSetOrder( 1 )
		If dbSeek( xFilial( 'WF7' ) + cMailBox )

			If !WF7->WF7_ATIVO

				// Conta de e-mail XXXXX utilizada como remetente, encontra-se inativa ##
				cErrors += '- ' + STR0497 + cMailBox + STR0486 + CRLF
				// Favor verificar as configurações em Ambiente > Workflow > Contas de E-mail, no Configurador.
				cErrors += '  ' + STR0476 + CRLF

			Else

				If IsEmail( WF7->WF7_REMETE )

					// Campo remetente preenchido no formato de e-mail, no entanto este campo deve ser informado um nome para a conta de e-mails.
					cErrors += '- ' + STR0472 + CRLF
					// Favor verificar as configurações em Ambiente > WorkFlow > Contas de E-mail, no Configurador.
					cErrors += '  ' + STR0476 + CRLF

				EndIf

				cServer   := AllTrim( WF7->WF7_SMTPSR )
				cPassServ := AllTrim( WF7->WF7_AUTSEN )
				cUsuServ  := AllTrim( WF7->WF7_AUTUSU )

				If Empty( cServer )

					// - Servidor SMTP não informado para a caixa de e-mails XXXX.
					cErrors += '- ' + STR0487 + cMailBox + '. ' + CRLF
					// Favor verificar as configurações em Ambiente > WorkFlow > Contas de E-mail, no Configurador.
					cErrors += '  ' + STR0476 + CRLF

				ElseIf lAuth .And. ( Empty( cPassServ ) .Or. Empty( cUsuServ ) )

					// - Usuário ou senha não foram informados para a caixa de e-mails XXXX.
					cErrors += '- ' + STR0496 + cMailBox + '. ' + CRLF
					// Favor verificar as configurações em Ambiente > WorkFlow > Contas de E-mail, no Configurador
					cErrors += '  ' + STR0476 + CRLF

				Else

					//Cria a conexão com o server STMP ( Envio de e-mail )
					oServer := TMailManager():New()

					If Trim( WF7->WF7_SMTPSE ) == 'TLS'
						lTLS := .T.
					ElseIf Trim( WF7->WF7_SMTPSE ) == 'SSL'
						lSSL := .T.
					EndIf

					oServer:SetUseTLS( lTLS )
					oServer:SetUseSSL( lSSL )

					// Inicializa o servidor
					oServer:Init( '', cServer, cUsuServ, cPassServ, , WF7->WF7_SMTPPR )

					// Variável para identificar erro na conexão com o servidor de e-mail
					nRet := oServer:SMTPConnect()

					// Faz a conexão com o servidor.
					If nRet == 0

						If lAuth

							nRet := oServer:SmtpAuth( cUsuServ, cPassServ )

							If nRet != 0

								// - Não foi possivel autenticar o servidor SMTP XXXXX.
								cErrors += '- ' + STR0464 + cUsuServ + '. ' + CRLF
								// Favor verificar as configurações em Ambiente > WorkFlow > Contas de E-mail, no Configurador.
								cErrors += '  ' + STR0476 + CRLF

							EndIf
							oServer:SmtpDisconnect()

						EndIf

					Else

						// - Não foi possivel realizar a conexão ao servidor SMTP definido para a caixa de e-mails XXXXX
						cErrors += '- ' + STR0474 + cMailBox + '. ' + CRLF
						// Favor verificar as configurações em Ambiente > WorkFlow > Contas de E-mail, no Configurador.
						cErrors += '  ' + STR0476 + CRLF

					EndIf

					If nRet != 0

						// Verificando erro de acordo com o codigo de erro gerado
						cErrors += ' ' + STR0480 + ': ' + oServer:GetErrorString( nRet ) // "Erro"
						cErrors += CRLF

					EndIf

				EndIf

			EndIf

		Else

			// - Não foi possivel localizar a conta de e-mails XXXXX na filial: XXXXX
			cErrors += '- ' + STR0471 + cMailBox + STR0498 + Trim( FwFilial() ) + CRLF
			// Favor verificar o conteúdo do parâmetro MV_WFMLBOX e das configurações de workflow
			// disponíveis em Ambiente > Workflow > Contas de E-mail no Configurador.
			cErrors += '  ' + STR0499 +  CRLF

		EndIf

	Else

		// - Não foi possivel localizar a conta de e-mails XXXXX na filial: XXXXX
		cErrors += '- ' + STR0471 + cMailBox + STR0498 + Trim( FwFilial() ) + CRLF
		// Favor verificar o conteúdo do parâmetro MV_WFMLBOX e das configurações de workflow
		// disponíveis em Ambiente > Workflow > Contas de E-mail no Configurador.
		cErrors += '  ' + STR0499 +  CRLF

	EndIf

	If !Empty( cErrors )

		If isBlind()

			// Atenção ## Foram detectadas inconsistências nos parâmetros do WorkFlow
			NGWFLog( STR0492 + CRLF + CRLF + cErrors, .T. )

		Else

			// Atenção ## Foram detectadas inconsistências nos parâmetros do WorkFlow
			NGMsgMemo( STR0025, STR0492 + CRLF + CRLF + cErrors )

		EndIf

	EndIf

Return Empty( cErrors )

//-------------------------------------------------------------------
/*/{Protheus.doc} NGBuildTWF
Função de encapsulamento com MsgRun para a função NGTWFProcB

@type  Function
@author Lucas Meneghelli Pereira
@since 12/02/2019

@param cTo         , Character, Destinatario de E-mail, quando mais de um separar por ';'.

@param cHtm        , Character, Nome do arquivo .htm do WorkFlow a ser enviado.

@param [cSubject]  , Character, Assunto do e-mail.

@param [cOrigin]       , Character, Caso possua P.E. NGTWFPro, Infoma nome da rotina de origem.

@param [aFieldsSta], Array    , Array bidimensional contendo o valor dos campos estáticos do arquivo .htm ( variaveis que
possuem estrutura fixa ).
	- [x][1]: Caracter, Contem o nome do campo na estrutura.
	- [x][2]: Qualquer, Contem o valor do campo.

@param [aFieldsDin], Array    , Array bidimensional contendo o valor dos campos dinâmicos do arquivo .htm ( variaveis que
possuem estrutura que será gerada ).
		- [x][1]: Caracter, Contem o nome do campo na estrutura.
		- [x][2]: Qualquer, Contem o valor do campo.

@return return, Array, Array que indica se foi possivel a criação do objeto e o objeto caso criado.
	- [1]: Logic , Indica se foi possível a criação do objeto
	- [2]: Objeto, objeto da classe TWFProcess()

@example

	Local cTitulo		:= 'Titulo Exemplo'
	Local cSubTitulo	:= 'SubTitulo Exemplo'
	Local cEmail		:= 'lucas.pereira@ngi.com.br'
	Local aFieldsSta	:= {}
	Local aFieldsDin	:= {}
	Local aProcess		:= {}

	// Campos estáticos de estruturas pré definidas no .htm
	aFieldsSta := {	{ 'strCampo'	  , 'Campo fora de Tabela' },;
					{ 't1l1.strCampo1', 'Campo 1 da linha 1 da Tabela 1 Pré-definida' },;
					{ 't2l1.strCampo1', 'Campo 1 da linha 1 da Tabela 2 Pré-definida' },;
					{ 't2l2.strCampo2', 'Campo 1 da linha 2 da Tabela 2 Pré-definida' },;
					{ 't2l3.strCampo3', 'Campo 1 da linha 3 da Tabela 2 Pré-definida' },;
					{ 't3l1.strCampo1', 'Campo 1 da linha 1 da Tabela 3 Pré-definida' },;
					{ 't3l1.strCampo2', 'Campo 2 da linha 1 da Tabela 3 Pré-definida' } }

	// Campos de uma tabela com linha única no .htm que serve como base para outras linhas a serem criadas,
	// será gerada uma estrutura html para cada linha nova, desse modo pode ser utilizado em laços de repetição
	aFieldsDin := {	{ 't5l1.1', 'Campo 1 Linha 1' },; // começo linha 1
					{ 't5l1.2', 'Campo 2 Linha 2' },;
					{ 't5l1.3', 'Campo 3 Linha 3' },;
					{ 't5l1.4', 'Campo 4 Linha 4' },;
					{ 't5l1.1', 'Campo 1 Linha 1' },; // começo linha 2
					{ 't5l1.2', 'Campo 2 Linha 2' },;
					{ 't5l1.3', 'Campo 3 Linha 3' },;
					{ 't5l1.4', 'Campo 4 Linha 4' },;
					{ 't5l1.1', 'Campo 1 Linha 1' },; // começo linha 3
					{ 't5l1.2', 'Campo 2 Linha 2' },;
					{ 't5l1.3', 'Campo 3 Linha 3' },;
					{ 't5l1.4', 'Campo 4 Linha 4' } }

	aProcess := NGBuildTWF( cEmail, 'MNTW693', DToC( dDataBase ) + ' - ' + cTitulo, 'MNTA693', aCamposEst )

	If aProcess[1]
		NGSendTWF( aProcess[2] )
	EndIf

@obs É necessário que esteja configurado o envio de workflows no ambiente para que seja possível utilizar esta função

/*/
//-------------------------------------------------------------------
Function NGBuildTWF( cTo, cHtm, cSubject, cOrigin, aFieldsSta, aFieldsDin )

	Local aReturn := {}

	If !isBlind()

		// "Aguarde... Processando" ## "Processando"
		MsgRun( STR0112, STR0234 + ' WorkFlow', {|| aReturn := NGTWFProcB( cTo, cHtm, cSubject, cOrigin, aFieldsSta,;
		        aFieldsDin ) } )

	Else

		aReturn := NGTWFProcB( cTo, cHtm, cSubject, cOrigin, aFieldsSta, aFieldsDin )

	EndIf

Return aReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} NGTWFProcB
Função para criação do objeto da classe TWFProcess para envio de workflow. Grava os passos no log de WF.

@type  Function
@author Lucas Meneghelli Pereira
@since 15/11/2018

@param cTo         , Character, Destinatario de E-mail, quando mais de um separar por ';'.

@param cHtm        , Character, Nome do arquivo .htm do WorkFlow a ser enviado.

@param [cSubject]  , Character, Assunto do e-mail.

@param [cOrigin]   , Character, Caso possua P.E. NGTWFPro, Infoma nome da rotina de origem.

@param [aFieldsSta], Array    , Array bidimensional contendo o valor dos campos estáticos do arquivo .htm ( variaveis que
possuem estrutura fixa ).
	- [x][1]: Caracter, Contem o nome do campo na estrutura.
	- [x][2]: Qualquer, Contem o valor do campo.

@param [aFieldsDin], Array    , Array bidimensional contendo o valor dos campos dinâmicos do arquivo .htm ( variaveis que
possuem estrutura que será gerada ).
		- [x][1]: Caracter, Contem o nome do campo na estrutura.
		- [x][2]: Qualquer, Contem o valor do campo.

@return return, Array, Array que indica se foi possivel a criação do objeto e o objeto caso criado.
	- [1]: Logic , Indica se foi possível a criação do objeto
	- [2]: Objeto, objeto da classe TWFProcess()

@obs É necessário que esteja configurado o envio de workflows no ambiente para que seja possível utilizar esta função

/*/
//-------------------------------------------------------------------
Function NGTWFProcB( cTo, cHtm, cSubject, cOrigin, aFieldsSta, aFieldsDin )

	Local cBarras      := IIf( isSRVunix() , '/', '\' )
	Local cDir         := AllTrim( SuperGetMv( 'MV_WFDIR', .F. ) )
	Local nPos         := 0
	Local lRet         := .T.
	Local xCampo       := Nil
	Local oProcess     := Nil

	Default cSubject   := ''
	Default cOrigin    := ''
	Default aFieldsSta := {}
	Default aFieldsDin := {}

	// valida os parâmetros e existência de .htm para envio de WF
	lRet := NGValidTWF( cHtm )

	If lRet

		// Adiciona a barra no final do parametro do diretorio
		If Substr( cDir, Len( cDir ), 1 ) != cBarras
			cDir += cBarras
		Endif

		// Inicialize a classe TWFProcess e assinale a variável objeto oProcess:
		oProcess := TWFProcess():New( cHtm, cSubject )
		NGWFLog( STR0465 + ' - ' + oProcess:fProcessID, .T. ) // "Processo Iniciado"

		// Crie uma tarefa.
		oProcess:NewTask( STR0466 + ' ' + cHtm, cDir + cHtm + '.htm' ) // "Executando"
		NGWFLog( STR0467 + ' - ' + oProcess:fTaskID, .T. ) // "Tarefa Iniciada"

		// Repasse o texto do assunto criado para a propriedade especifica do processo.
		oProcess:cSubject := cSubject

		// Informe o endereço eletrônico do destinatário.
		oProcess:cTo  := cTo

		// Utilize a funcao RetCodUsr para obter o codigo do usuario protheus.
		oProcess:UserSiga := RetCodUsr()

		// Processando campos estaticos
		For nPos := 1 To Len( aFieldsSta )

			xCampo := oProcess:oHTML:ValByName( aFieldsSta[ nPos, 1 ] )
			If ValType( xCampo ) == 'A'
				aAdd( oProcess:oHTML:ValByName( aFieldsSta[ nPos, 1 ] ), aFieldsSta[ nPos, 2 ] )
			Else
				oProcess:oHTML:ValByName( aFieldsSta[ nPos, 1 ], aFieldsSta[ nPos, 2 ] )
			EndIf

		Next nPos

		// Processando campos apresentados em formato de getdados
		For nPos := 1 To Len( aFieldsDin )

			aAdd( ( oProcess:oHTML:ValByName( aFieldsDin[ nPos, 1 ] ) ), aFieldsDin[ nPos, 2 ] )

		Next nPos

		// Ponto de entrada para adicionar variaveis ao arquivo .htm
		If !Empty( cOrigin ) .And. ExistBlock( 'NGTWFPro' )
			oProcess := ExecBlock( 'NGTWFPro', .F., .F., { oProcess, cOrigin } )
		EndIf

	EndIf

Return { lRet, oProcess }

//-------------------------------------------------------------------
/*/{Protheus.doc} NGSendTWF
Função para enviar o e-mail configurado no objeto de classe TWFProcess e salvar passos no log de WF. Pode ser utilizada
em conjunto da função padrão de criação do objeto ( NGBuildTWF ) ou em conjunto da criação do objeto por outro meio,
pois grava no log de WF os passos feitos.

@type  Function
@author Lucas Meneghelli Pereira
@since 27/11/2018

@param oProcess, Object, Objeto TWFProcess que terá seu workflow enviado.
/*/
//-------------------------------------------------------------------
Function NGSendTWF( oProcess )

	Local cMailID := ''
	Local cTo     := ''
	Local nIndex  := 0
	Local aMails  := {}

	cMailID := oProcess:Start()
	NGWFLog( STR0468 + ' - ' + oProcess:fProcessID + ' | ' + 'ID' + ' - ' + cMailID, .T. ) // "Processo Enviado"
	NGWFLog( STR0469 + ': ' + oProcess:cSubject, .T. ) // "Descrição"
	oProcess:Finish()

	aMails := StrTokArr2( oProcess:cTo, ';' )

	For nIndex := 1 to Len( aMails )

		cTo += Trim( aMails[nIndex] ) + CRLF

	Next nIndex

	If !Empty( oProcess:cCC )

		cTo    += CRLF + CRLF + STR0491 + CRLF // Cc:
		aMails := StrTokArr2( oProcess:cCC, ';' )

		For nIndex := 1 to Len( aMails )

			cTo += Trim( aMails[nIndex] ) + CRLF

		Next nIndex

	EndIf

	If !Empty( oProcess:cBCC )

		cTo    += CRLF + CRLF + STR0490 + CRLF // Cco:
		aMails := StrTokArr2( oProcess:cBCC, ';' )

		For nIndex := 1 to Len( aMails )

			cTo += Trim( aMails[nIndex] ) + CRLF

		Next nIndex

	EndIf

	If !isBlind()

		// Workflow enviado para:
		NGMsgMemo( '', STR0479 + CRLF + CRLF + cTo )

	EndIf

	// Workflow enviado para:
	NGWFLog( STR0479 + CRLF + CRLF + cTo, .T. )

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} NGSendMail
Rotina Generica de Envio de E-mail (WorkFlow).
@type function

@author Rodrigo Luan Backes
@since 19/06/2015

@sample NGSendMail( "MeuNome", "destinatario@ngi.com.br",, "Teste de Envio",, "<b>TESTE DE ENVIO<b>" )

@param [cDe]      , Caracter , E-mail Remetente.
@param cPara      , Caracter , Destinatario, quando mais de um separar por ";"
@param [cCc]      , Caracter , Destinatario de Copia, quando mais de um separar por ";"
@param [cCCO]     , Caracter , Destinatario de Copia Oculta.
@param [cAssunto] , Caracter , Assunto.
@param [cAnexo]   , Caracter , Anexo a ser enviado, devem estar abaixo do RootPath, com caminho completo.
@param cMsg       , Caracter , Mensagem do e-mail no formato texto ou html.
@param [cServer]  , Caracter , Servidor de autenticação.
@param [cEmail]   , Caracter , E-mail Remetente.
@param [cPass]    , Caracter , Senha de autenticação.
@param [lAuth]    , Lógico   , Se deve realizar autenticação.
@param [cContAuth], Caracter , Usuario de autenticação.
@param [cPswAuth] , Caracter , Senha de autenticação.
@param [cFunction], Caracter , Rotina que realizou a chamada do envio de e-mails.

@return Lógico    , Verifica se o e-mail foi enviado corretamente.
/*/
//----------------------------------------------------------------------------------------------------------
Function NGSendMail( cDe, cPara, cCc, cCCO, cAssunto, cAnexo, cMsg, cServer, cEmail, cPass, lAuth, cContAuth, cPswAuth, cFunction )

	Local lResulConn := .T.
	Local lResulSend := .T.
	Local lRet       := .T.
	Local cError     := ''
	Local cFrom      := ''

	ParamType 0  Var cDe       As Character Optional Default AllTrim( SuperGetMV( 'MV_RELFROM', .F., STR0432 + GetVersao() ) ) // Microsiga Protheus
	ParamType 1  Var cPara     As Character
	ParamType 2  Var cCc       As Character Optional Default NIL
	ParamType 3  Var cCCO      As Character Optional Default ""
	ParamType 4  Var cAssunto  As Character Optional Default STR0433 //<sem assunto>
	ParamType 5  Var cAnexo    As Character Optional Default NIL
	ParamType 6  Var cMsg      As Character Optional Default ""
	ParamType 7  Var cServer   As Character Optional Default AllTrim(SuperGetMV('MV_RELSERV', .F., ''    ))// smtp.dominio.com.br ou 200.181.100.51
	ParamType 8  Var cEmail    As Character Optional Default AllTrim(SuperGetMV('MV_RELACNT', .F., ''    ))// fulano@dominio.com.br
	ParamType 9  Var cPass     As Character Optional Default AllTrim(SuperGetMV('MV_RELPSW' , .F., ''    ))// senha
	ParamType 9  Var lAuth     As Logical   Optional Default SuperGetMV('MV_RELAUTH', .F., .F.            )// Tem Autenticacao ?
	ParamType 10 Var cContAuth As Character Optional Default AllTrim(SuperGetMV('MV_RELAUSR', .F., ''    ))// Conta Autenticacao
	ParamType 11 Var cPswAuth  As Character Optional Default AllTrim(SuperGetMV('MV_RELAPSW', .F., ''    ))// Senha Autenticacao

	// Alguns servidores SMTP exigem endereco e senha do remetente e outros nao
	// Portanto, o conteudo do MV_RELAUTH (lAuth) pode gerar resultados diferentes no momento do CONNECT SMTP SERVER
	If Empty( cServer ) .Or. ( ( Empty( cEmail ) .Or. Empty( cPass ) ) .And. lAuth )

		/*
			Os Parâmetros MV_RELSERV, MV_RELACNT e MV_RELPSW não foram informados corretamente e/ou se encontram sem preenchimento.
			Falha no envio de e-mail
		*/
		NGLogMsg( STR0482, STR0437, , 'WARN', cFunction )
		lRet := .F.

	Else

		cDe       := IIf( Empty( cDe ), cEmail, cDe )
		cPara     := AllTrim(cPara)
		cCC       := AllTrim(cCC)
		cAssunto  := AllTrim(cAssunto)
		cAnexo    := AllTrim(cAnexo)
		cAnexo    := IIf( Left( cAnexo, 1 ) == ';' , SubStr( cAnexo, 2 )                  , cAnexo )
		cAnexo    := IIf( Right( cAnexo, 1 ) == ';', SubStr( cAnexo, 1, Len( cAnexo) - 1 ), cAnexo )
		cContAuth := IIf( Empty( cContAuth ), cEmail, cContAuth )
		cPswAuth  := IIf( Empty( cPswAuth ) , cPass , cPswAuth )

		// Realiza verificação se o e-mail utilizado como remetente está em um formato válido.
		If IsEmail( cEmail )

			cFrom := Trim( cEmail )

		ElseIf IsEmail( cDe )

			cFrom := Trim( cDe )

		Else

			/*
				Foram detectadas inconsistências na configuração de remetente para envio, verifique o parâmetro MV_RELFROM.
				Falha no envio de e-mail
			*/
			NGLogMsg( STR0470, STR0437, , 'WARN', cFunction )
			lRet := .F.

		EndIf

		If lAuth .And. lRet

			If Empty( cContAuth ) .Or. Empty( cPswAuth )

				/*
					Não foram definidos conta ou senha de autenticação para envio de e-mail pelo Protheus.
					Verifique os parâmetros ( MV_RELAUSR, MV_RELAPSW ).
					Falha no envio de e-mail
				*/
				NGLogMsg( STR0434, STR0437, , 'WARN', cFunction )
				lRet := .F.

			EndIf

		EndIf

		If lRet

			CONNECT SMTP SERVER cServer ACCOUNT cEmail PASSWORD cPass RESULT lResulConn

			If !lResulConn

				GET MAIL ERROR cError

				/*
					Falha na conexão para envio de e-mail: (ERRO). ##
					Verifique os parâmetros MV_RELSERV, MV_RELACNT e MV_RELPSW.
					Falha no envio de e-mail
				*/
				NGLogMsg( STR0435 + '(' + cError + '). ' +  STR0461, STR0437, , 'ERROR', cFunction )
				lRet := .F.

			EndIf

			If lAuth .And. lRet

				If !MailAuth( cContAuth, cPswAuth )

					/*
						Não foi possível autenticar a conta de e-mail: (Conta). ##
						Verifique os parâmetros MV_RELAUSR e MV_RELAPSW.
						Falha no envio de e-mail
					*/
					NGLogMsg( STR0436 + '(' + cContAuth + '). ' + STR0481, STR0437, , 'ERROR', cFunction )
					lRet := .F.

					DISCONNECT SMTP SERVER

				EndIf

			EndIf

			If lRet

				//Realiza o envio do e-mail
				If      Empty( cCc ) .And.  Empty( cAnexo ) .And. Empty( cCCO )
					SEND MAIL FROM cFrom TO cPara SUBJECT cAssunto BODY cMsg RESULT lResulSend
				ElseIf  Empty( cCc ) .And. !Empty( cAnexo ) .And. Empty( cCCO )
					SEND MAIL FROM cFrom TO cPara SUBJECT cAssunto BODY cMsg ATTACHMENT cAnexo RESULT lResulSend
				ElseIf  Empty( cCc ) .And. !Empty( cAnexo ) .And. !Empty( cCCO )
					SEND MAIL FROM cFrom TO cPara BCC cCCO SUBJECT cAssunto BODY cMsg ATTACHMENT cAnexo RESULT lResulSend
				ElseIf !Empty( cCc ) .And.  Empty( cAnexo ) .And. Empty( cCCO )
					SEND MAIL FROM cFrom TO cPara CC cCc SUBJECT cAssunto BODY cMsg RESULT lResulSend
				ElseIf !Empty( cCc ) .And.  Empty( cAnexo ) .And. !Empty( cCCO )
					SEND MAIL FROM cFrom TO cPara CC cCc BCC cCCO SUBJECT cAssunto BODY cMsg RESULT lResulSend
				Else
					SEND MAIL FROM cFrom TO cPara CC cCc BCC cCCO SUBJECT cAssunto BODY cMsg ATTACHMENT cAnexo RESULT lResulSend
				EndIf

				If !lResulSend

					GET MAIL ERROR cError

					/*
						Devido a uma inconsistência nos dados não foi possível enviar o e-mail: (Erro).
						Falha no envio de e-mail
					*/
					NGLogMsg( STR0485 + ' (' + cError + ').', STR0437, , 'ERROR', cFunction )
					lRet := .F.

				EndIf

				DISCONNECT SMTP SERVER

			EndIf

		EndIf

	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} NgTimeStamp
Funcao para retornar o time stamp.
Uso Geral.

@param 	nTipo		Tipo do time stamp, Onde
1 =	aaaammddhhmmss
2 = [FUNNAME/ROTINA dd/mm hh:mm]
3 = [dd/mm hh:mm]

@return	cRet		String com o time stamp

@sample
//
// Ex. dia  01/06/2009
//     hora 12:10:05
//
Alert( NgTimeStamp( 1 ) // Retorna 20090601121005
Alert( NgTimeStamp( 2 ) // Retorna [FUNNAME/ROTINA 01/06 12:05] ]
Alert( NgTimeStamp( 3 ) // Retorna [01/06 12:05]

@author Rodrigo Luan Backes
@since 23/06/2015
@version 1.0
/*/
//-------------------------------------------------------------------
Function NgTimeStamp( nTipo )
	Local cRet    := ''
	Local cRotina := ''

	ParamType 0 Var nTipo      As Numeric Optional Default 1

	If nTipo == 1
		cRet    := DToS( Date() )+ StrTran( Time(), ':', '' )

	ElseIf nTipo == 2
		cRotina := ProcName( 1 )
		cRotina := IIf( SubStr( cRotina, 1, 2 ) $ 'u_/U_', SubStr( cRotina, 3 ), cRotina )
		cRet    := '[' + FunName() +'/'+ cRotina + ' ' + SubStr( DtoC( Date() ), 1, 5 ) + ' ' + SubStr( Time(), 1, 5 ) + ']'

	ElseIf nTipo == 3
		cRet    := '[' + SubStr( DtoC( Date() ), 1, 5 ) + ' ' + SubStr( Time(), 1, 5 ) + ']'

	EndIf

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} ReCountTmp
Conta registros em uma alias (query ou trb).
Uso Construção Civil.

@param 	cAlias - Alias para contar regisros.
@return nCntRec - Quantidade de registros.

@author Marcos Wagner Junior
@since 08/06/2010
@version 1.0

Observação: Esta função foi inclusão pelo Lúcio em 30/09/2015 dadas necessidades do Construção Civil.
/*/
//-------------------------------------------------------------------
Function ReCountTmp(cAlias)
	Local nCntRec := 0
	Local aOldArea := GetArea()

	dbSelectArea(cAlias)
	dbGoTop()
	While !Eof()
		nCntRec++
		dbSkip()
	EndDo

	dbGoTop()

	RestArea(aOldArea)

Return nCntRec

//---------------------------------------------------------------------
/*/{Protheus.doc} ValDtBase(dData)
Função de validação se a data informada nao é maior que a atual

@author Tainã Alberto Cardoso
@since 22/05/15
@version 1.0
@param dData: data que deve ser verificar com a data base do sistema

@return boolean
@sample

/*/
//---------------------------------------------------------------------
Function NGValDtHr(dData,cHora)

	Default cHora := ""

	If dData > dDatabase

		ShowHelpDlg(STR0212,{STR0213},1,{STR0419 },1) //"Data inválida" ## "Data maior que a data base." ## "Informe uma data igual ou menor que a data base."
		Return .F.

	ElseIf !Empty(cHora) .And. Alltrim(cHora) <> ":"

		If !NGVALHORA(cHora,.T.)
			Return .F.
		EndIf

		If (dData >= dDatabase) .and. (cHora > Substr(Time(),1,5))
			ShowHelpDlg(STR0420 ,{STR0421 },1,{STR0422 },1) //"Período inválido" ## "Período maior que data/hora atual." ## "Informe uma data/hora igual ou menor que a data base."
			Return .F.
		EndIf

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGGRAFFWCH()
Função de impressão do gráfico

@author  Rodrigo Luan Backes
@since 	 09/11/2015
@version P11/P12

@param	 aDataGra, Array, Dados para montagem do Gráfico

/*/
//---------------------------------------------------------------------
Function NGGRAFFWCH( aDataGra )

	Local oDlg
	Local aSize			:= MsAdvSize( , .F., 430 )

	Private lNGGraLeg	:= .T.
	Private aGraph		:= aDataGra

	Private aSER		:= {}	//aGraph[2]
	Private aEIXOX		:= {}	//aGraph[4]
	Private aVALUE		:= {}	//aGraph[5]
	Private cTitulo		:= ''	//aGraph[6]

	Private oFWChart

	//Se nao foi gerado relatorio retorna .F.
	If Len( aGraph ) == 0
		Return .F.
	EndIf

	aSER	:= aGraph[2]
	aEIXOX	:= aGraph[4]
	aVALUE	:= aGraph[5]
	cTitulo	:= aGraph[6]

	DEFINE MSDIALOG oDlg FROM aSize[7],0 To aSize[6],aSize[5] Of oMAINWND Pixel

	oDlg:lMaximized		:= .T.

	NGGRAFFWFA( oDlg, BARCOMPCHART )

	ACTIVATE MSDIALOG oDlg Centered ON INIT ( NGMenuGraf( oDlg, aGraph ) )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NGMenuGraf( oDlg, aGraph, _oObjLeg )
Inclui itens no Menu

@author Rodrigo Luan Backes
@since 10/11/2015
@param	oDlg: Objeto do MSDIALOG.
@param	aGraph: Array de parâmetros do Gráfico.
@param	_oObjLeg: Objeto da legenda do gráfico.
@version 1.0
@return

/*/
//---------------------------------------------------------------------
Static Function NGMenuGraf( oDlg, aGraph, _oObjLeg )
	Local oMenu

	oMenu := TBar():New( IIf( _oObjLeg != Nil, _oObjLeg, oDlg ), 25, 32, .T., , , , .F. )
	DEFINE BUTTON RESOURCE "S4WB008N"		OF oMenu	ACTION Calculadora()										PROMPT " "	TOOLTIP STR0168			//"Calculadora"
	DEFINE BUTTON RESOURCE "PMSPRINT"		OF oMenu	ACTION PrintGraph( aGraph[1][2], oFWChart, .T.)				PROMPT " "	TOOLTIP Capital(STR0026)	//"Imprimir"
	DEFINE BUTTON RESOURCE "SALVAR"			OF oMenu	ACTION NGSavePNG( oFWChart )								PROMPT " "	TOOLTIP STR0169			//"Salva &BMP"
	DEFINE BUTTON RESOURCE "S4WB013N"		OF oMenu	ACTION Processa({ || NGGRAFFWFA( oDlg, PIECHART ) } )		PROMPT " "	TOOLTIP STR0171			//"Pizza"
	DEFINE BUTTON RESOURCE "BAR"			OF oMenu	ACTION Processa({ || NGGRAFFWFA( oDlg, BARCOMPCHART ) } )	PROMPT " "	TOOLTIP STR0172			//"Barra"
	DEFINE BUTTON RESOURCE "PAPEL_ESCRITO"	OF oMenu	ACTION DetailGraph( aGraph )								PROMPT " "	TOOLTIP STR0174			//"Detalhes"

	If _oObjLeg == Nil
		DEFINE BUTTON oBtCan RESOURCE "FINAL" 		OF oMenu ACTION oDlg:End() PROMPT " " 	TOOLTIP STR0100 //"Sair"
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NGGRAFFWFA( oDlg, nTipo )
Gráfico de Barras modelo FWChart

@author Rodrigo Luan Backes
@since 11/11/2015
@param	oDlg: Objeto do MSDIALOG.
@param	nTipo: Tipo do gráfico de acordo com o FWChartFactory.
@version 1.0
@return

/*/
//---------------------------------------------------------------------
Static Function NGGRAFFWFA( oDlg, nTipo )

	Local nX

	oFWChart				:= FWChartFactory():New()
	oFWChart				:= oFWChart:getInstance( nTipo )

	oFWChart:init( oDLG, .T. )
	oFWChart:setTitle( cTitulo, CONTROL_ALIGN_CENTER )
	oFWChart:setLegend( CONTROL_ALIGN_RIGHT )
	oFWChart:setMask( "$ *@* " )
	oFWChart:setPicture( "@E 999999.99" )

	For nX := 1 To Len( aEIXOX )
		If nTipo == BARCOMPCHART
			oFWChart:addSerie( aEIXOX[nX], { { aEIXOX[nX], aVALUE[nX][1] } } )
		ElseIf nTipo == PIECHART
			oFWChart:addSerie( aEIXOX[nX], aVALUE[nX][1] )
		EndIf
	Next nX

	oFWChart:build()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NGSavePNG( oGraphic )
Salva o gráfico em PNG

@author Rodrigo Luan Backes
@since 11/11/2015
@param	oGraphic: Objeto do FWChartFactory.
@version 1.0
@return Nil

/*/
//---------------------------------------------------------------------
Function NGSavePNG( oGraphic )

	Local cPngName, cPngDir
	Local cWhereToSave	:= "\"	// Somente gravar abaixo do rootpath do servidor

	cPngDir := cGetFile( STR0440, STR0441, 0, "", .F., GETF_LOCALHARD ) //"Arquivos Png (*.Png) |*.Png|"###"Selecione arquivo .Png"

	If Empty( cPngDir )
		Return
	Endif

	If Rat("\", cPngDir) > 0
		cWhereToSave		:= Subs( cPngDir, 1,	Rat( "\", cPngDir ) )
		cPngName			:= Subs( cPngDir,		Rat( "\", cPngDir ) + 1 )
	Endif

	If (nPos := At(".", AllTrim( cPngName ) ) ) == 0
		cPngName			:= AllTrim( cPngName ) + ".Png"
	Else
		cPngName			:= AllTrim( Substr( cPngName, 1, nPos ) ) + "Png"
	EndIf

	If At( ":", cWhereToSave ) > 0

		//-------------------------------------------------------
		// Validacao com o tamanho da tela menor que 1280x1024
		//-------------------------------------------------------
		If GetScreenRes()[2] < 1025 .And. GetScreenRes()[1] < 1281
			oGraphic:saveToPng( 4, 4, 1210, 793, cPngDir )
		ElseIf GetScreenRes()[2] == 1080 .And. GetScreenRes()[1] == 1920
			oGraphic:saveToPng( 4, 4, 1855, 848, cDirTemp + cNameImg )
		Else
			oGraphic:saveToPng( 4, 4, 1350, 578, cPngDir )
		EndIf

	Endif

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCHKDIC( nVerif, cAlias, cField )
Função de consistência de dicionário.
objetivo é unificar as verificações de exitência de uma tabela ou campo
de acordo com os padrões da versão 12, sempre que for necessario incluir
uma nova verificação adicionar a esta função seguindo o padrão já estabelecido.

até o momento estão sendo utilizadas:
AliasInDic()
ColumnPos()

@author Bruno Lobo de Souza
@since 23/11/15
@version 1.0
@param nVerif: Numérico indicando o teste a ser realizado
1 - AliasInDic()
2 - ColumnPos()

@param cAlias: Alias da tabela a ser testada
@param cField: Campo a ser testado

@return boolean
@sample NGCHKDIC( 1, "TV5" )

/*/
//---------------------------------------------------------------------
Function NGCHKDIC( nVerif, cAlias, cField )

	Local lRet := .F.

	If nVerif == 1
		lRet := AliasInDic( cAlias )
	ElseIf 	nVerif == 2
		lRet := ColumnPos( cField ) > 0
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} CompDtInFi(dDataPai,cHorPai,dDataFil,cHorFil)
Função de validação para comprar data inicio e fim

@author Tainã Alberto Cardoso
@since 22/05/15
@version 1.0

@param dDtIni: Data Inicio
@param cHrIni: Hora Inicio
@param dDtFim: Data Fim
@param cHrFim: Hora Fim
@param lFim: Verifica se esta comparando data inicio ou fim.
@return boolean
@sample

/*/
//---------------------------------------------------------------------
Function NGCompData(dDtIni,cHrIni,dDtFim,cHrFim,lFim)

	Default lFim := .F.

	If !Empty(dDtIni) .And. !Empty(dDtFim)
		If 	dDtIni > dDtFim
			If lFim
				ShowHelpDlg(STR0420,{STR0423},1,{STR0424},1) //"Período inválido" ## "Data menor que data inicio." ## "Informe uma data maior que a inicio."
			Else
				ShowHelpDlg(STR0420,{STR0425},1,{STR0426},1) //"Período inválido" ## "Data maior que a data fim." ## "Informe uma data menor ou igual a fim."
			EndIf
			Return .F.
		ElseIf !Empty(cHrIni) .And. !Empty(cHrFim) .And. Alltrim(cHrIni) <> ":" .And.  Alltrim(cHrFim) <> ":"
			If dDtIni == dDtFim .And. cHrIni > cHrFim
				If lFim
					ShowHelpDlg(STR0420,{STR0427},1,{STR0428},1) //"Período inválido" ## "Hora menor que hora inicio." ## "Informe uma hora maior que a inicio."
				Else
					ShowHelpDlg(STR0420,{STR0429},1,{STR0430},1) //"Período inválido" ## "Hora maior que hora fim." ## "Informe uma hora menor que a fim."
				EndIf
				Return .F.
			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGGRAFFMOV()
Função de impressão do gráfico

@author Diego de Oliveira
@since 24/12/2015
@version P11/P12

@param	 nType,      Numérico, Tipo de gráfico a ser gerado
@param	 [oObjOpen], Objeto,   Objeto no qual sera aberta o gráfico
@param	 [_oObjLeg], Objeto,   Objeto da legenda do gráfico.
@param	 aDataGra,   Array,	   Dados para montagem do Gráfico
/*/
//---------------------------------------------------------------------
Function NGGRAFFMOV( nType, oObjOpen, _oObjLeg, aDataGra )

	Local oDlg
	Local aSize			:= MsAdvSize( , .F., 430 )

	Default oObjOpen := Nil
	Default _oObjLeg := Nil
	Default nType    := GRP_BAR //GRP_LINE, GRP_AREA, GRP_POINT, GRP_BAR, GRP_PIE

	Private lNGGraLeg	:= .T.
	Private aGraph		:= aDataGra

	Private aSER		:= {}	//aGraph[2]
	Private aEIXOX		:= {}	//aGraph[4]
	Private aVALUE		:= {}	//aGraph[5]
	Private cTitulo		:= ''	//aGraph[6]

	//Cores para os textos do cabecalho e rodape
	Private nNGGraType := nType

	Private oFWChart, oNGGraphic

	//Se nao foi gerado relatorio retorna .F.
	If Len( aGraph ) == 0
		Return .F.
	EndIf

	aSER	:= aGraph[2]
	aEIXOX	:= aGraph[4]
	aVALUE	:= aGraph[5]
	cTitulo	:= aGraph[6]

	If GetScreenRes()[2] < 1025 .And. GetScreenRes()[1] < 1281
		aSize[5] := 1210
		aSize[6] :=  793
	ElseIf GetScreenRes()[2] == 1080 .And. GetScreenRes()[1] == 1920
		aSize[5] := 1855
		aSize[6] :=  848
	Else
		aSize[5] := 1302
		aSize[6] :=  536
	EndIf

	DEFINE MSDIALOG oDlg FROM aSize[7],0 To aSize[6],aSize[5] Of oMAINWND Pixel

	oDlg:lMaximized		:= .T.

	NGGRAMOVCH( oDlg, BARCOMPCHART )

	ACTIVATE MSDIALOG oDlg Centered ON INIT ( NGMenuGMov( oDlg, aGraph ) )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NGMenuGMov( oDlg, aGraph, _oObjLeg )
Inclui itens no Menu

@author Diego de Oliveira
@since 24/12/2015
@param	oDlg: Objeto do MSDIALOG.
@param	aGraph: Array de parâmetros do Gráfico.
@param	_oObjLeg: Objeto da legenda do gráfico.
@version 1.0
@return
/*/
//---------------------------------------------------------------------
Static Function NGMenuGMov( oDlg, aGraph, _oObjLeg)

	Local oMenu

	oMenu := TBar():New( IIf( _oObjLeg != Nil, _oObjLeg, oDlg ), 25, 32, .T., , , , .F. )
	DEFINE BUTTON RESOURCE "S4WB008N"		OF oMenu	ACTION Calculadora()										PROMPT " "	TOOLTIP STR0168			//"Calculadora"
	DEFINE BUTTON RESOURCE "PMSPRINT"		OF oMenu	ACTION PrintGraph( aGraph[1][1], oFWChart, .T.)				PROMPT " "	TOOLTIP Capital(STR0026)//"Imprimir"
	DEFINE BUTTON RESOURCE "SALVAR"			OF oMenu	ACTION NGSavePNG( oFWChart )								PROMPT " "	TOOLTIP STR0169			//"Salva &BMP"
	DEFINE BUTTON RESOURCE "S4WB013N"		OF oMenu	ACTION Processa({ || NGGRAMOVCH( oDlg, PIECHART ) } )		PROMPT " "	TOOLTIP STR0171			//"Pizza"
	DEFINE BUTTON RESOURCE "BAR"			OF oMenu	ACTION Processa({ || NGGRAMOVCH( oDlg, BARCOMPCHART ) } )	PROMPT " "	TOOLTIP STR0172			//"Barra"
	DEFINE BUTTON RESOURCE "PAPEL_ESCRITO"	OF oMenu	ACTION DetailGraph( aGraph )								PROMPT " "	TOOLTIP STR0174			//"Detalhes"

	If _oObjLeg == Nil
		DEFINE BUTTON oBtCan RESOURCE "FINAL" 		OF oMenu ACTION oDlg:End() PROMPT " " 	TOOLTIP STR0100 //"Sair"
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NGGRAMOVCH( oDlg, nTipoGra )
Gráfico modelo FWChart de acordo com o tipo (nTipoGra)

@author Diego de Oliveira
@since 24/12/2015
@param	oDlg: Objeto do MSDIALOG.
@param	nTipoGra: Tipo do gráfico de acordo com o FWChartFactory.
@version 1.0
@return
/*/
//---------------------------------------------------------------------
Static Function NGGRAMOVCH( oDlg, nTipoGra )

	// Variáveis utilizadas para geração das séries do gráfico
	Local nSerie := 0
	Local aSerie := { STR0457, STR0458, STR0459, STR0460 } // 'Abertas'##'Concluídas'##'Pendentes'##'Canceladas'

	Private aColorGraph := {CLR_HGREEN,CLR_HBLUE,CLR_HRED,CLR_YELLOW,CLR_BROWN,CLR_CYAN,;
	CLR_MAGENTA,CLR_GRAY,CLR_WHITE,CLR_BLUE,CLR_GREEN,CLR_RED,CLR_HGRAY,;
	CLR_HCYAN,CLR_HMAGENTA,CLR_BLACK,RGB(178,241,18),RGB(131,199,154),;
	RGB(111,156,210),RGB(236,99,120),RGB(255,255,162),RGB(19,88,88),;
	RGB(60,9,60),RGB(141,125,194),RGB(255,93,0),RGB(255,196,0)}

	//Cores para os textos do cabecalho e rodape
	Private aColorText  := {CLR_GREEN,CLR_GREEN}

	oFWChart := FWChartFactory():New()
	oFWChart := oFWChart:getInstance( nTipoGra )
	oFWChart:init( oDLG, .T. )
	oFWChart:setTitle( cTitulo, CONTROL_ALIGN_CENTER )
	oFWChart:setLegend( CONTROL_ALIGN_RIGHT )
	oFWChart:setMask( "$ *@* " )
	oFWChart:setPicture( "@E 999999.99" )
	oFWChart:setColor("Random")

	If nTipoGra == PIECHART

		// Gráfico do tipo Pizza
		For	nSerie := 1 To Len( aEIXOX )
			oFWChart:addSerie( aEIXOX[nSerie], aVALUE[nSerie][1] )
		Next nSerie

	ElseIf nTipoGra == BARCOMPCHART

		// Gráfico do tipo Barra
		For nSerie := 1 To Len( aSerie )
			oFWChart:addSerie( aSerie[nSerie], {{ aEIXOX[1] , aVALUE[1, nSerie]  }, { aEIXOX[2] , aVALUE[2, nSerie]  }, { aEIXOX[3] , aVALUE[3, nSerie]  },;
												{ aEIXOX[4] , aVALUE[4, nSerie]  }, { aEIXOX[5] , aVALUE[5, nSerie]  }, { aEIXOX[6] , aVALUE[6, nSerie]  },;
												{ aEIXOX[7] , aVALUE[7, nSerie]  }, { aEIXOX[8] , aVALUE[8, nSerie]  }, { aEIXOX[9] , aVALUE[9, nSerie]  },;
												{ aEIXOX[10], aVALUE[10, nSerie] }, { aEIXOX[11], aVALUE[11, nSerie] }, { aEIXOX[12], aVALUE[12, nSerie] } } )
		Next nSerie

	EndIf

	oFWChart:build()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NGALTTAR
Consistência da Tarefa

@param String cPreC: indica Pré chave ( Bem+Serviço+Sequencia ) Obrigatório
para preventiva
@param String cTar - indica Codigo da Tarefa - Obrigatório
@author Diego de Oliveira
@since 13/06/2016
@return Boolean lRet: conforme validação
@version MP11
/*/
//---------------------------------------------------------------------
Function NGALTTAR( cPreC,cTar )

	Local lRet := .T.

	If ExistBlock("NGVALTAR")

		lRet := ExecBlock( 'NGVALTAR', .F., .F., { cTar, cPreC } )
	
	Else
	
		lRet := NGSTLTAR( cPreC, cTar )
	
	EndIf

Return lRet

//------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} NGRETTXT(cCod)
Formata um texto para utilizar em uma consulta SQL.
Essa função é utilizada para quando o código tiver um apostofo (') na texto.
Sendo assim é necessário adicionar outro apostofo no código.

1) Pega a primeira parte do texto até a possição anterior ao ', adiciona na frente outro apostofo.
E pega o resto do texto em diante.
2) Inicializa a Varivel Start 2 posições depois que achou o apostofo, pois essa é a primeira posição
após o mesmo, visto que ele ganhou um novo caracter.
3) Pesquisa por outro possível apostofo. A pesquisa da String será apartir da posição Start, não sendo
possivel encontrar o mesmo que anteriormente. Ficará preso dentro do While enquanto houver apostofo.

Exem: cCod = "CODVEI001'"
Retorno "CODVEI001''"

@author Maicon André Pinheiro
@since 24/02/2017
@param	cCod: Código texto que será validado
@version 1.0
@return cCodAlt: Código alterado (Caso não exista apostofo retorna a mesma String)
/*/
//------------------------------------------------------------------------------------------------------
Function NGRETTXT(cCod)

	Local cCodAlt := cCod
	Local nPos    := 0
	Local nStart  := 0

	nPos := AT("'",cCod) //Verifica a primeira possíção que contém o apostofo.
	While nPos > 0       //Enquanto encontrar apostofo irá fazer as validações.
		cCodAlt := SUBSTR(cCodAlt,1,nPos-1) + "'" + SUBSTR(cCodAlt,nPos,Len(cCod)) //1
		nStart  := nPos+2                                                          //2
		nPos    := AT("'",cCodAlt,nStart)                                          //3
	End

Return cCodAlt

//------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} NGFILBROINI
Remonta o browse com o filtro inicial da funcao FilBrowse

@author Inacio Luiz Kolling
@since 05/07/2009
@param cAli - Alias do arquivo/tabela
@param aInd  - Array com os arquivos e indices
@param cCond - Condicao inicial do filtro
@version 1.0
@return Nil
/*/
//------------------------------------------------------------------------------------------------------
Function NGFILBROINI(cAli,aInd,cCond)
	dbSelectArea(cAli)
	Set Filter To
	bFiltraBrw := {|| FilBrowse(cAli,@aInd,@cCond) }
	Eval(bFiltraBrw)
Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} NGMODCOMP
Verifica o modo de compartilhamento das tabelas (cAlias1 e cAlias2)
e retorna uma comparação (utilizando o sinal fornecido pelo cComp)
entre os dois campos de filial considerando o modo de compartilhamento.
Ex.: "SUBSTRING(ST9.T9_FILIAL,1,2) = SUBSTRING(TQN.TQN_FILIAL,1,2)"
Obs.: Caso seja fornecido os valores cFil1 e cFil2, a comparação será
entre os valores, e não entre os campos.

@param cAlias1, string, tabela 1
@param cAlias2, string, tabela 2
@param [cComp], string, sinal de comparação
@param [cFil1], string, valor da Filial da tabela 1
@param [cFil2], string, valor da Filial da tabela 2
@param [cName1], string, nome do campo filial da tabela 1 (ex.: ST91.T9_FILIAL)
@param [cName2], string, nome do campo filial da tabela 2 (ex.: STJ2.TJ_FILIAL)
@author Wexlei Silveira
@since 28/02/17
@version P11
@return String
/*/
//---------------------------------------------------------------------
Function NGMODCOMP(cAlias1,cAlias2, cComp, cFil1, cFil2, cName1, cName2 )

	Local cQuery  := ""
	Local _cGetDB := TcGetDb() // Verifica qual Banco de Dados está sendo usado
	Local cSubstr := IIF(Upper(_cGetDB) $ 'ORACLE,POSTGRES,INFORMIX' .OR. Upper(_cGetDB) $ 'DB2',"SUBSTR","SUBSTRING")
	Local nLayout1 := NGLEASTLAY(cAlias1)//Retorna o tamanho mínimo do layout da filial
	Local nLayout2 := NGLEASTLAY(cAlias2)

	Default cComp := "="
	Default cFil1 := ""
	Default cFil2 := ""
	Default cName1 := ''
	Default cName2 := ''

	If !Empty(cFil1)
		cFil1 := "'" + cFil1 + "'" // conteúdo do campo filial
	ElseIf !Empty( cName1 )
		cFil1 := cName1 // nome do campo filial 
	Else
		cFil1 := PrefixoCpo(cAlias1) + "_FILIAL"
	EndIf

	If !Empty(cFil2)
		cFil2 := "'" + cFil2 + "'" // conteúdo do campo filial
	ElseIf !Empty( cName2 )
		cFil2 := cName2 // nome do campo filial 
	Else
		cFil2 := PrefixoCpo(cAlias2) + "_FILIAL"
	EndIf

	If nLayout1 == 0 .Or. nLayout2 == 0//Se o tamanho do layout de uma das tabelas for 0 (zero), não deve comparar
		cQuery :=  "0 " + cComp + " 0"//Retorna esta comparação para não gerar erro em queries com um AND vazio.
	Else
		cQuery := cSubstr + "(" + cFil1 + ",1," + cValToChar(IIF(nLayout1 <= nLayout2, nLayout1, nLayout2)) + ") " + cComp + " " +;
				cSubstr + "(" + cFil2 + ",1," + cValToChar(IIF(nLayout1 <= nLayout2, nLayout1, nLayout2)) + ")"
	Endif

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} NGLEASTLAY
Retorna o menor valor para o layout de filial da tabela

@param cAliasL: Nome da tabela
@author Wexlei Silveira
@since 18/01/17
@version P11/P12
@return Numeric
/*/
//---------------------------------------------------------------------
Function NGLEASTLAY(cAliasL)

Local n
Local nLayout := 0

For n := 1 To 3
	If FWModeAccess(cAliasL,n) == "E"//Verifica o modo de compartilhamento para Empresa/Unidade/Filial
		nLayout += Len(FWSM0Layout(cempant,n))//Se o modo for Exclusivo, soma o tamanho do layout para a E/U/F
	EndIf
Next n

Return nLayout
//---------------------------------------------------------------------
/*/{Protheus.doc} NGFwTmpTbl
Cria TRB
@author eduardo.izola
@since 16/02/2017
@version undefined
@param cAlias, characters, Alias Tabela
@param aFields, array, Array de campos
@param aIndex, array, Indice TRB
@param AliasTab, characters, Tabela para criação do aField caso;
não exista.
@type function
/*/
//---------------------------------------------------------------------
Function NGFwTmpTbl(cAlias,aFields,aIndex,AliasTab)

	Local i

	If !Empty(AliasTab)
		dbSelectArea(AliasTab)
		aFields := DbStruct()
	EndIf

	oTempTable := FWTemporaryTable():New( cAlias , aFields )
	For i := 1 To Len(aIndex)
		oTempTable:AddIndex("ind"+cValToChar(i), aIndex[i] )
	Next i
	oTempTable:Create()

Return oTempTable

//-------------------------------------------------------------------
/*/{Protheus.doc} NGRetParEx - NG Retorna Parâmetro externo
Retorna o parâmetro de outro grupo de empresas

Obs: Essa função causa perda de performance importante usar somente quando
for preciso buscar o parâmetro de outro grupo de empresa, senão for caso
utilizar o SuperGetMv.

@author  Maicon André Pinheiro
@since   17/03/2018
@param   cEmp     - C - Grupo de empresa
@param   cFil     - C - Filial
@param   cMvPar   - C - Parâmetro para busca
@param   cDefault - C - Conteúdo padrão do parâmetro
/*/
//-------------------------------------------------------------------
Function NGRetParEx(cEmp, cFil, cMvPar, cDefault)

	Local xParametro := Nil //Conteúdo do parâmetro

	If cEmp == cEmpAnt
		xParametro := SuperGetMv(cMvPar, .F., cDefault, cFil)
	Else
		xParametro := StartJob( "NGGetMvPar" , GetEnvServer() , .T. , cEmp , cFil , cMvPar , cDefault)
	EndIf

Return xParametro

//-------------------------------------------------------------------
/*/{Protheus.doc} NGGetMvPar
Obtem o Parâmetro de Acordo com a Empresa de Referência

@author  Maicon André Pinheiro
@since   17/03/2018
@param   cEmp     - C - Grupo de empresa
@param   cFil     - C - Filial
@param   cMvPar   - C - Parâmetro para busca
@param   cDefault - C - Conteúdo padrão do parâmetro
/*/
//-------------------------------------------------------------------
Function NGGetMvPar(cEmp, cFil, cMvPar, cDefault)

	Local xParametro := Nil

	BEGIN SEQUENCE

		//Abre empresa para busca do parâmetro
		RpcSetType(3)
		RpcSetEnv(cEmp, cFil)

		xParametro := SuperGetMv(cMvPar, .F., cDefault, cFil)

	END SEQUENCE

Return xParametro

//-------------------------------------------------------------------
/*/{Protheus.doc} NGAliasInDic
Retorna se a tabela existe no dicionário, função utilizada para buscar
a informação de outro grupo de empresa

Obs: Essa função causa perda de performance importante usar somente quando
for preciso verificar a existência de uma tabela de outro grupo de empresa,
senão for o caso utilizar o FWAliasInDic.

@author  Maicon André Pinheiro
@since   17/03/2018
@param   cAliasBsc   - C - Alias para busca da informação
@param   cEmp        - C - Grupo de empresa
@return  lAliasInDic - L - Retorna se o Alias existe no grupo de empresa informado
/*/
//-------------------------------------------------------------------
Function NGAliasInDic(cAliasBsc, cEmp)

	Local lAliasInDic := .F.

	If cEmp == cEmpAnt
		lAliasInDic := FWAliasInDic(cAliasBsc)
	Else
		lAliasInDic := StartJob("NGRetAlias", GetEnvServer(), .T., cAliasBsc, cEmp)
	EndIf

Return lAliasInDic

//-------------------------------------------------------------------
/*/{Protheus.doc} NGRetAlias
Retorna a informação de existência ou não do Alias no grupo de empresas
selecionado.

@author  Maicon André Pinheiro
@since   17/03/2018
@param   cAliasBsc   - C - Alias para busca da informação
@param   cEmp        - C - Grupo de empresa
@return  lAliasInDic - L - Retorna se o Alias existe no grupo de empresa informado
/*/
//-------------------------------------------------------------------
Function NGRetAlias(cAliasBsc, cEmp)

	Local lAliasInDic := .F.

	BEGIN SEQUENCE

		//Abre empresa para busca da tabela
		RpcSetType(3)
		RpcSetEnv(cEmp)

		lAliasInDic := FWAliasInDic(cAliasBsc)

	END SEQUENCE

Return lAliasInDic

//---------------------------------------------------------------------
/*/{Protheus.doc} NGHeader
Retorna todas as colunas contidas na tabela com a mesma estrutura do aHeader.

@author Wexlei Silveira
@since	15/05/2018

@param cAlias, Caractere, Alias da tabela
@param [aNotInc], Array, Array dos campos que não serão trazidos no aHeader
@param [lNotUsed], Lógico, Define quando retorno do array não traz os campos não usados

@return Array, Array dos campos no formato do aHeader
/*/
//---------------------------------------------------------------------
Function NGHeader(cAlias, aNotInc, lNotUsed)

	Local aStruct := {}
	Local aHeader := {}
	Local aArea   := GetArea()
	Local aAreaX3 := SX3->( GetArea() )
	Local n       := 1

  	Default aNotInc := {}
	Default lNotUsed := .T.

	DbSelectArea(cAlias)
	aStruct := DBStruct()
	aHeader := APBuildHeader(cAlias, aNotInc)

	If lNotUsed // Carrega no array os campos não usados

		For n := 1 To Len(aHeader) // Adiciona o campo X3_ORDEM para ordenação

			aAdd(aHeader[n], Posicione("SX3",2,aHeader[n, 2],"X3_ORDEM"))

		Next n

		For n := 1 To Len(aStruct)

			If (aScan(aHeader, {|x| Alltrim(x[2]) == AllTrim(aStruct[n, 1])}) == 0 .And.;
			   aScan(aNotInc, {|x| Alltrim(x) == AllTrim(aStruct[n, 1])}) == 0)

				aAdd(aHeader, {Posicione("SX3",2,aStruct[n, 1],"X3Titulo()"),;
							   aStruct[n, 1],;
							   Posicione("SX3",2,aStruct[n, 1],"X3_PICTURE"),;
							   Posicione("SX3",2,aStruct[n, 1],"X3_TAMANHO"),;
							   Posicione("SX3",2,aStruct[n, 1],"X3_DECIMAL"),;
							   Posicione("SX3",2,aStruct[n, 1],"X3_VALID"),;
							   Posicione("SX3",2,aStruct[n, 1],"X3_USADO"),;
							   Posicione("SX3",2,aStruct[n, 1],"X3_TIPO"),;
							   Posicione("SX3",2,aStruct[n, 1],"X3_F3"),;
							   Posicione("SX3",2,aStruct[n, 1],"X3_CONTEXT"),;
							   Posicione("SX3",2,aStruct[n, 1],"X3_ORDEM")})

			EndIf

		Next n

		aSort(aHeader,,,{|x,y| x[11] < y[11]}) // Ordena o array pelo campo X3_ORDEM

		For n := 1 To Len(aHeader) // Remove o campo X3_ORDEM

			aDel(aHeader[n], 11)
			aSize(aHeader[n], Len(aHeader[n]) - 1)

		Next n

	EndIf

	RestArea( aAreaX3 )
	RestArea(aArea)

Return aHeader

//---------------------------------------------------------------------
/*/{Protheus.doc} NGINDCARGA
Função que faz a gravação dos indicadores.

@author Guilherme Freudenburg
@since 31/08/2018

@param aIndTZ1, Array, Array com Classificação dos Indicadores.
@param aIndTZ2, Array, Array com  Varáveis.
@param aIndTZ3, Array, Array com Parâmetros das Varáveis.
@param aIndTZ4, Array, Array com Tipos de Parâmetro.
@param aIndTZ5, Array, Array com Indicadores (Fórmulas).
@param aIndTZ6, Array, Array com Variáveis por Fórmula.
@param aIndTZ7, Array, Array com Parametros Fixos por Indicador.
@param aIndSAH, Array, Array com Unidades de Medida.
@param aIndTZ9, Array, Array com Indicadores Gráficos.
@param aIndTZB, Array, Array com Painéis de Indicadores.
@param aAltInd, Array, Array com nomes de indicadores que serão alterados por motivo de internacionalização.

@version 2.0
@return Sempre Verdadeiro.
/*/
//---------------------------------------------------------------------
Function NGINDCARGA(aIndTZ1,aIndTZ2,aIndTZ3,aIndTZ4,aIndTZ5,aIndTZ6,aIndTZ7,aIndSAH,aIndTZ9,aIndTZB,aAltInd)

	Local aTZ1 := aIndTZ1
	Local aTZ2 := aIndTZ2
	Local aTZ3 := aIndTZ3
	Local aTZ4 := aIndTZ4
	Local aTZ5 := aIndTZ5
	Local aTZ6 := aIndTZ6
	Local aTZ7 := aIndTZ7
	Local aSAH := aIndSAH
	Local i, j
	Local nX        := 0
	Local nExecSql  := 0
	Local lIni      := .F.
	Local lAti      := .F.
	Local lRet      := .T.
	Local lRPORel17 := GetRPORelease() <= '12.1.017' // Verifica se a release é 12.1.7 ou menor.
	Local cMaxCod   := ""
	Local cAtuCod   := ""
	Local cQuery    := ""
	Local cCodTZ9   := ""
	Local nLenMod    := 0
	Local nLenOrd    := 0
	Local nLenCodVar := 0
	Local nLenTip	 := 0

	Default aAltInd := {}

	If NGCADICBASE("TZ4_VALID","A","TZ4",.F.)
		lIni := .T.
	Endif

	If NGCADICBASE("TZ5_ATIVO","A","TZ5",.F.)
		lAti := .T.
	Endif

	If !FindFunction("MNTINDIC") .And. lRPORel17
		Help(Nil, Nil, STR0381, Nil, STR0477, 1, 0) //"Atenção" ## "Por favor, realize a atualização do fonte MNTUTIL, através do código do chamado DNG-3908"
		lRet := .F.
	ElseIf FindFunction("NGMNTIND") .And. lRPORel17
		Help(Nil, Nil, STR0381, Nil, STR0478, 1, 0) //"Atenção" ## "Por favor, realize a atualização do fonte NGIND006 - Configuração de Indicadores, através do código do chamado DNG-3908"
		lRet := .F.
	EndIf

	If lRet
		If Len(aAltInd) > 0

			For nX := 1 To Len(aAltInd)
				// TZ5 - INDICADORES (FORMULAS)
				cQuery := " UPDATE " + RetSqlName( "TZ5" )
				cQuery += " SET TZ5_CODIND = " + ValToSQL( aAltInd[nX,2] )
				cQuery += " WHERE TZ5_CODIND = " + ValToSQL( aAltInd[nX,1] )
				cQuery += "  AND TZ5_FILIAL = " + ValToSQL( xFilial("TZ5") )
				cQuery += "  AND D_E_L_E_T_ <> '*'"
				nExecSql := TCSQLExec(cQuery)

				If nExecSql >= 0
					// TZ6 - VARIAVEIS POR FORMULA
					cQuery := " UPDATE " + RetSqlName( "TZ6" )
					cQuery += " SET TZ6_CODIND = " + ValToSQL( aAltInd[nX,2] )
					cQuery += " WHERE TZ6_CODIND = " + ValToSQL( aAltInd[nX,1] )
					cQuery += "  AND TZ6_FILIAL = " + ValToSQL( xFilial("TZ6") )
					cQuery += "  AND D_E_L_E_T_ <> '*'"
					nExecSql := TCSQLExec(cQuery)
				EndIf

				If nExecSql >= 0
					// TZ7 - PARAMETROS FIXOS POR INDICADOR
					cQuery := " UPDATE " + RetSqlName( "TZ7" )
					cQuery += " SET TZ7_CODIND = " + ValToSQL( aAltInd[nX,2] )
					cQuery += " WHERE TZ7_CODIND = " + ValToSQL( aAltInd[nX,1] )
					cQuery += "  AND TZ7_FILIAL = " + ValToSQL( xFilial("TZ7") )
					cQuery += "  AND D_E_L_E_T_ <> '*'"
					nExecSql := TCSQLExec(cQuery)
				EndIf

				If nExecSql >= 0 .And. !fCheckTZA( aAltInd[nX,2], aAltInd[nX,1] )
					// TZA - Formulas Ind. Gráficos
					cQuery := " UPDATE " + RetSqlName( "TZA" )
					cQuery += " SET TZA_CODIND = " + ValToSQL( aAltInd[nX,2] )
					cQuery += " WHERE TZA_CODIND = " + ValToSQL( aAltInd[nX,1] )
					cQuery += "  AND TZA_FILIAL = " + ValToSQL( xFilial("TZA") )
					cQuery += "  AND D_E_L_E_T_ <> '*'"
					nExecSql := TCSQLExec(cQuery)
				EndIf

				If nExecSql >= 0
					// TZC - Itens do Painel Ind.
					cQuery := " UPDATE " + RetSqlName( "TZC" )
					cQuery += " SET TZC_CODIND = " + ValToSQL( aAltInd[nX,2] )
					cQuery += " WHERE TZC_CODIND = " + ValToSQL( aAltInd[nX,1] )
					cQuery += "  AND TZC_FILIAL = " + ValToSQL( xFilial("TZC") )
					cQuery += "  AND D_E_L_E_T_ <> '*'"
					nExecSql := TCSQLExec(cQuery)
				EndIf

				If nExecSql < 0  // Caso as querys não foram executadas corretamente.
					Help(Nil, Nil, STR0381, Nil, TcSQLError() , 1, 0) // Atenção
				EndIf

			Next nX

		EndIf

		nLenMod := Len(TZ1->TZ1_MODULO)
		nLenCod := Len(TZ1->TZ1_CODCLA)

		If !Empty(aTZ1)
			dbSelectArea("TZ1")
			dbSetOrder(1) // TZ1_FILIAL+TZ1_MODULO+TZ1_CODCLA
			For i := 1 To Len(aTZ1)
				If !dbSeek( xFilial("TZ1") + PadR(aTZ1[i,1],nLenMod) + PadR(aTZ1[i,2],nLenCod) )
					Reclock("TZ1",.T.)
					TZ1->TZ1_FILIAL := xFilial("TZ1")
					TZ1->TZ1_MODULO := aTZ1[i,1]
					TZ1->TZ1_CODCLA := aTZ1[i,2]
					TZ1->TZ1_DESCRI := aTZ1[i,3]
					MsUnLock("TZ1")
				Endif
			Next i
		Endif

		nLenMod := Len(TZ2->TZ2_MODULO)
		nLenCod := Len(TZ2->TZ2_CODVAR)

		If !Empty(aTZ2)
			dbSelectArea("TZ2")
			dbSetOrder(1) // TZ2_FILIAL+TZ2_MODULO+TZ2_CODVAR
			For i := 1 To Len(aTZ2)
				If !dbSeek( xFilial("TZ2") + PadR(aTZ2[i,1],nLenMod) + PadR(aTZ2[i,2],nLenCod) )
					RecLock("TZ2",.T.)
					TZ2->TZ2_FILIAL := xFilial("TZ2")
					TZ2->TZ2_MODULO := aTZ2[i,1]
					TZ2->TZ2_CODVAR := aTZ2[i,2]
					TZ2->TZ2_TIPO   := aTZ2[i,3]
					TZ2->TZ2_FUNCAO := aTZ2[i,4]
					TZ2->TZ2_TITULO := aTZ2[i,5]
					MsUnLock("TZ2")
					MSMM(,,,aTZ2[i,6],1,,,"TZ2","TZ2_DESCRI")
				Endif
			Next i
		Endif

		nLenMod := Len(TZ3->TZ3_MODULO)
		nLenCod := Len(TZ3->TZ3_CODVAR)
		nLenOrd := Len(TZ3->TZ3_ORDEM)

		If !Empty(aTZ3)
			dbSelectArea("TZ3")
			dbSetOrder(1) // TZ3_FILIAL+TZ3_MODULO+TZ3_CODVAR+TZ3_ORDEM
			For i := 1 To Len(aTZ3)
				If !dbSeek( xFilial("TZ3") + PadR(aTZ3[i,1],nLenMod) + PadR(aTZ3[i,2],nLenCod) + PadR(aTZ3[i,3],nLenOrd) )
					RecLock("TZ3",.T.)
					TZ3->TZ3_FILIAL := xFilial("TZ3")
					TZ3->TZ3_MODULO := aTZ3[i,1]
					TZ3->TZ3_CODVAR := aTZ3[i,2]
					TZ3->TZ3_ORDEM  := aTZ3[i,3]
					TZ3->TZ3_CODPAR := aTZ3[i,4]
					MsUnLock("TZ3")
				Endif
			Next i
		Endif

		nLenMod := Len(TZ4->TZ4_MODULO)
		nLenCod := Len(TZ4->TZ4_CODPAR)

		If !Empty(aTZ4)
			dbSelectArea("TZ4")
			dbSetOrder(1) //TZ4_FILIAL+TZ4_MODULO+TZ4_CODPAR
			For i := 1 To Len(aTZ4)

				// Atualiza os indicadores "DE_SOLICI" e "ATE_SOLICI" pois estavam com conteúdo errôneo.
				If Alltrim(aTZ4[i,2]) == "DE_SOLICI" .Or. Alltrim(aTZ4[i,2]) == "ATE_SOLICI"
					If dbSeek( xFilial("TZ4") + PadR(aTZ4[i,1],nLenMod) + PadR(aTZ4[i,2],nLenCod) )
						RecLock("TZ4",.F.)
						DbDelete()
						TZ4->(MsUnlock())
					EndIf
				EndIf

				// Atualiza o parâmetro 'CON_PARADA'.
				If AllTrim( aTZ4[i,2] ) == 'CON_PARADA' .And. dbSeek( xFilial( 'TZ4') +PadR(aTZ4[i,1],nLenMod) + PadR( aTZ4[i,2],nLenCod) )
					RecLock( 'TZ4', .F. )
					dbDelete()
					TZ4->( MsUnLock() )
				EndIf

				If !dbSeek( xFilial("TZ4") + PadR(aTZ4[i,1],nLenMod) + PadR(aTZ4[i,2],nLenCod) )
					RecLock("TZ4",.T.)
					TZ4->TZ4_FILIAL := xFilial("TZ4")
					TZ4->TZ4_MODULO := aTZ4[i,1]
					TZ4->TZ4_CODPAR := aTZ4[i,2]
					TZ4->TZ4_DESCRI := aTZ4[i,3]
					TZ4->TZ4_TIPO   := aTZ4[i,4]
					TZ4->TZ4_TAMANH := aTZ4[i,5]
					TZ4->TZ4_DECIMA := aTZ4[i,6]
					TZ4->TZ4_PICTUR := aTZ4[i,7]
					TZ4->TZ4_TABELA := aTZ4[i,8]
					TZ4->TZ4_CAMPOS := aTZ4[i,9]
					TZ4->TZ4_F3 	:= aTZ4[i,10]
					TZ4->TZ4_OPCOES := aTZ4[i,11]
					TZ4->TZ4_RELACA := aTZ4[i,12]
					If lIni
						TZ4->TZ4_VALID  := aTZ4[i,13]
					Endif
					MsUnLock("TZ4")
				Endif
			Next i
		Endif

		nLenMod := Len(TZ5->TZ5_MODULO)
		nLenCod := Len(TZ5->TZ5_CODIND)

		If !Empty(aTZ5)
			dbSelectArea("TZ5")
			dbSetOrder(1) //TZ5_FILIAL+TZ5_MODULO+TZ5_CODIND
			For i := 1 To Len(aTZ5)
				If !dbSeek( xFilial("TZ5") + PadR(aTZ5[i,1],nLenMod) + PadR(aTZ5[i,2],nLenCod) )
					RecLock("TZ5",.T.)
					TZ5->TZ5_FILIAL := xFilial("TZ5")
					TZ5->TZ5_MODULO := aTZ5[i,1]
					TZ5->TZ5_CODIND := aTZ5[i,2]
					TZ5->TZ5_NOME   := aTZ5[i,3]
					TZ5->TZ5_FORMUL := aTZ5[i,4]
					TZ5->TZ5_CODCLA := aTZ5[i,5]
					TZ5->TZ5_UNIMED := aTZ5[i,7]
					TZ5->TZ5_TAMMED := aTZ5[i,8]
					TZ5->TZ5_DECMED := aTZ5[i,9]
					TZ5->TZ5_TIPRES := aTZ5[i,10]
					TZ5->TZ5_VALOR1 := aTZ5[i,11]
					TZ5->TZ5_VALOR2 := aTZ5[i,12]
					TZ5->TZ5_TIPVAL := aTZ5[i,13]
					TZ5->TZ5_FORCON := aTZ5[i,14]
					If lAti
						TZ5->TZ5_ATIVO := aTZ5[i,15]
					EndIf
					MsUnLock("TZ5")
					MSMM(,,,aTZ5[i,6],1,,,"TZ5","TZ5_DESCRI")
				Endif
				If aTZ5[i,2] == "MTBF" .Or. aTZ5[i,2] == "MTTR"// Caso seja MTBF e MTTR, realiza a troca da formula.
					If dbSeek( xFilial("TZ5") + PadR(aTZ5[i,1],nLenMod) + PadR(aTZ5[i,2],nLenCod) )
						RecLock("TZ5",.F.)
						TZ5->TZ5_FORMUL := aTZ5[i,4]
						MsUnLock("TZ5")
					EndIf
				EndIf
			Next i
		Endif

		nLenMod		:= Len(TZ6->TZ6_MODULO)
		nLenCod		:= Len(TZ6->TZ6_CODIND)
		nLenCodVar	:= Len(TZ6->TZ6_CODVAR)

		If !Empty(aTZ6)
			dbSelectArea("TZ6")
			dbSetOrder(1) //TZ6_FILIAL+TZ6_MODULO+TZ6_CODIND+TZ6_CODVAR
			For i := 1 To Len(aTZ6)

				// Remoção da utilização da variável MNTV033 pelo indicador MTBF, agora ele utiliza o MNTV001 e MNTV002 apenas.
				If Alltrim(aTZ6[i,2]) == "MTBF" // Caso seja o Tempo Médio entre Falhas.
					If dbSeek( xFilial("TZ6") + PadR(aTZ6[i,1],nLenMod) + PadR(aTZ6[i,2],nLenCod) + PadR("MNTV033", nLenCodVar) )
						RecLock("TZ6",.F.)
						DbDelete()
						TZ6->(MsUnlock())
					EndIf
				EndIf

				If !dbSeek( xFilial("TZ6") + PadR(aTZ6[i,1],nLenMod) + PadR(aTZ6[i,2],nLenCod) + PadR(aTZ6[i,3],nLenCodVar) )
					RecLock("TZ6",.T.)
					TZ6->TZ6_FILIAL := xFilial("TZ6")
					TZ6->TZ6_MODULO := aTZ6[i,1]
					TZ6->TZ6_CODIND := aTZ6[i,2]
					TZ6->TZ6_CODVAR := aTZ6[i,3]
					TZ6->(MsUnlock())
				Endif
			Next i
		Endif

		nLenMod		:= Len(TZ7->TZ7_MODULO)
		nLenCod		:= Len(TZ7->TZ7_CODIND)
		nLenTip		:= Len(TZ7->TZ7_TIPO)
		nLenCodVar	:= Len(TZ7->TZ7_CODPAR)

		If !Empty(aTZ7)
			dbSelectArea("TZ7")
			dbSetOrder(1) // TZ7_FILIAL+TZ7_MODULO+TZ7_CODIND+TZ7_TIPO+TZ7_CODPAR
			For i := 1 To Len(aTZ7)
				If !dbSeek(xFilial("TZ7") + PadR(aTZ7[i,1],nLenMod) + PadR(aTZ7[i,2],nLenCod) + PadR(aTZ7[i,3],nLenTip) + PadR(aTZ7[i,4],nLenCodVar) )
					RecLock("TZ7",.T.)
					TZ7->TZ7_FILIAL := xFilial("TZ7")
					TZ7->TZ7_MODULO := aTZ7[i,1]
					TZ7->TZ7_CODIND := aTZ7[i,2]
					TZ7->TZ7_TIPO   := aTZ7[i,3]
					TZ7->TZ7_CODPAR := aTZ7[i,4]
					TZ7->TZ7_CONTEU := aTZ7[i,5]
					MsUnLock("TZ7")
			Endif
			Next i
		Endif

		If !Empty(aSAH)
			dbSelectArea("SAH")
			dbSetOrder(1)
			For i := 1 To Len(aSAH)
				If !dbSeek(xFilial("SAH")+PadR(aSAH[i,1],Len(SAH->AH_UNIMED)))
					RecLock("SAH",.T.)
					SAH->AH_FILIAL  := xFilial("SAH")
					SAH->AH_UNIMED  := aSAH[i,1]
					SAH->AH_UMRES   := aSAH[i,2]
					SAH->AH_DESCPO  := aSAH[i,3]
					SAH->AH_DESCIN  := aSAH[i,4]
					SAH->AH_DESCES  := aSAH[i,5]
					SAH->AH_COD_SIS := aSAH[i,6]
					SAH->AH_SIS_MER := aSAH[i,7]
					SAH->AH_CODRIEX := aSAH[i,8]
					SAH->AH_UM_SRF  := aSAH[i,9]
					MsUnLock("SAH")
				Endif
			Next i
		Endif

		If !Empty(aIndTZ9)
			cMaxCod := ""
			For i := 1 To Len(aIndTZ9)
				aIndTZ9[i][1] := PADL(aIndTZ9[i][1], TAMSX3("TZ9_CODIGO")[1], "0")
				If Empty(cMaxCod) .Or. aIndTZ9[i][1] > cMaxCod
					cMaxCod := aIndTZ9[i][1]
				EndIf

				cCodTZ9 := fRegTZ9(aIndTZ9[i,2]) // Verifica se o indicador já existe pelo seu nome.
				
				dbSelectArea( 'TZ9' )
				dbSetOrder( 2 ) // TZ9_FILIAL+DTOS(TZ9_DTCAD)+TZ9_HRCAD+TZ9_MODULO+TZ9_PROPRI

				If Empty( cCodTZ9 )
					
					RecLock( 'TZ9', .T. )
					TZ9->TZ9_FILIAL := xFilial("TZ9")
					TZ9->TZ9_CODIGO := aIndTZ9[i][1]

				Else

					dbSeek( xFilial( 'TZ9' ) + DTOS( aIndTZ9[i][5] ) + aIndTZ9[i][6] + aIndTZ9[i][9] + aIndTZ9[i][4]  )
					RecLock( 'TZ9', .F. )
					
				EndIf

				TZ9->TZ9_TITULO := aIndTZ9[i][2]
				TZ9->TZ9_SUBTIT := aIndTZ9[i][3]
				TZ9->TZ9_CODDES := ""
				TZ9->TZ9_PROPRI := aIndTZ9[i][4]
				TZ9->TZ9_DTCAD  := aIndTZ9[i][5]
				TZ9->TZ9_HRCAD  := aIndTZ9[i][6]
				TZ9->TZ9_USCAD  := aIndTZ9[i][7]
				TZ9->TZ9_ATIVO  := aIndTZ9[i][8]
				TZ9->TZ9_MODULO := aIndTZ9[i][9]
				TZ9->TZ9_MODELO := aIndTZ9[i][10]
				TZ9->TZ9_TIPCON := aIndTZ9[i][11]
				TZ9->TZ9_VAL01  := aIndTZ9[i][12]
				TZ9->TZ9_VAL02  := aIndTZ9[i][13]
				TZ9->TZ9_VAL03  := aIndTZ9[i][14]
				TZ9->TZ9_VAL04  := aIndTZ9[i][15]
				TZ9->TZ9_VAL05  := aIndTZ9[i][16]
				TZ9->TZ9_VAL06  := aIndTZ9[i][17]
				TZ9->TZ9_VAL07  := aIndTZ9[i][18]
				TZ9->TZ9_SECMIN := aIndTZ9[i][19]
				TZ9->TZ9_SECMAX := aIndTZ9[i][20]
				TZ9->TZ9_SOMB01 := aIndTZ9[i][21]
				TZ9->TZ9_SOMB02 := aIndTZ9[i][22]
				TZ9->TZ9_SOMB03 := aIndTZ9[i][23]
				TZ9->TZ9_COR01  := aIndTZ9[i][24]
				TZ9->TZ9_COR02  := aIndTZ9[i][25]
				TZ9->TZ9_COR03  := aIndTZ9[i][26]
				TZ9->TZ9_COR04  := aIndTZ9[i][27]
				TZ9->TZ9_COR05  := aIndTZ9[i][28]
				TZ9->TZ9_COR06  := aIndTZ9[i][29]
				TZ9->TZ9_COR07  := aIndTZ9[i][30]
				TZ9->TZ9_COR08  := aIndTZ9[i][31]
				TZ9->TZ9_COR09  := aIndTZ9[i][32]
				TZ9->TZ9_COR10  := aIndTZ9[i][33]
				TZ9->TZ9_COR11  := aIndTZ9[i][34]
				TZ9->TZ9_COR12  := aIndTZ9[i][35]
				TZ9->TZ9_COR13  := aIndTZ9[i][36]
				TZ9->TZ9_COR14  := aIndTZ9[i][37]
				TZ9->TZ9_LEGMIN := aIndTZ9[i][38]
				TZ9->TZ9_LEGMED := aIndTZ9[i][39]
				TZ9->TZ9_LEGMAX := aIndTZ9[i][40]
				If Len(aIndTZ9[i]) >= 42
					MsMM(If(!Empty(TZ9->TZ9_CODDES),TZ9->TZ9_CODDES,Nil)/*cChave*/, /*nTam*/, /*nLin*/, aIndTZ9[i][42]/*cString*/, 1/*nOpc*/, /*nTamSize*/, ;
						/*lWrap*/, "TZ9"/*cAlias*/, "TZ9_CODDES"/*cCpoChave*/, /*cRealAlias*/, /*lSoInclui*/)
				EndIf

				TZ9->( MsUnlock() )

				If Empty(cCodTZ9)

					For j := 1 To Len(aIndTZ9[i][41])
						aIndTZ9[i][41][j] := PADR(aIndTZ9[i][41][j], TAMSX3("TZA_CODIND")[1], " ")

						dbSelectArea("TZA")
						dbSetOrder(1)
						If !dbSeek(xFilial("TZA") + If(Empty(cCodTZ9),aIndTZ9[i][1],cCodTZ9) + aIndTZ9[i][41][j])
							RecLock("TZA", .T.)
							TZA->TZA_FILIAL := xFilial("TZA")
							TZA->TZA_CODGRA := If(Empty(cCodTZ9),aIndTZ9[i][1],cCodTZ9)
							TZA->TZA_CODIND := aIndTZ9[i][41][j]
							MsUnlock()
						EndIf
					Next j
				
				EndIf

				cCodTZ9 := "" // Limpa variável.

			Next i

			// Coloca o Código Máximo no GETSXENUM()
			While .T.
				cAtuCod := GETSXENUM("TZ9", "TZ9_CODIGO")
				If cAtuCod > cMaxCod .Or. !Empty( cCodTZ9 )
					RollBackSX8()
					Exit
				Else
					ConfirmSX8()
				EndIf
			End
			
		EndIf

		If !Empty(aIndTZB)
			cMaxCod := ""
			For i := 1 To Len(aIndTZB)
				aIndTZB[i][1] := PADL(aIndTZB[i][1], TAMSX3("TZB_CODIGO")[1], "0")
				If Empty(cMaxCod) .Or. aIndTZB[i][1] > cMaxCod
					cMaxCod := aIndTZB[i][1]
				EndIf

				dbSelectArea("TZB")
				dbSetOrder(1)
				If !dbSeek(xFilial("TZB") + aIndTZB[i][1])
					RecLock("TZB", .T.)
					TZB->TZB_FILIAL := xFilial("TZB")
					TZB->TZB_CODIGO := aIndTZB[i][1]
					TZB->TZB_NOME   := aIndTZB[i][2]
					TZB->TZB_CODUSU := aIndTZB[i][3]
					TZB->TZB_MODULO := aIndTZB[i][4]
					TZB->TZB_ATIVO  := aIndTZB[i][5]
					MsUnlock()
				EndIf

				For j := 1 To Len(aIndTZB[i][6])
					aIndTZB[i][6][j] := PADR(aIndTZB[i][6][j], TAMSX3("TZC_CODIND")[1], " ")

					dbSelectArea("TZC")
					dbSetOrder(1)
					If !dbSeek(xFilial("TZC") + aIndTZB[i][1] + aIndTZB[i][6][j])
						RecLock("TZC", .T.)
						TZC->TZC_FILIAL := xFilial("TZC")
						TZC->TZC_CODPNL := aIndTZB[i][1]
						TZC->TZC_CODIND := aIndTZB[i][6][j]
						MsUnlock()
					EndIf
				Next j
			Next i

			// Coloca o Código Máximo no GETSXENUM()
			While .T.
				cAtuCod := GETSXENUM("TZB", "TZB_CODIGO")
				If cAtuCod > cMaxCod
					RollBackSX8()
					Exit
				Else
					ConfirmSX8()
				EndIf
			End
		EndIf
	EndIf

Return .T.
//-------------------------------------------------------------------
/*/{Protheus.doc} NGHeadExc
Retorna o aHeader de acordo com o array de campos e exceções
passados como parâmetro.

@type   function
@author Julia Kondlatsch
@since  27/06/2018

@sample NGHeadExc( {'TAB_EPI','TAB_DESC'}, .F., .F., .F., ;
{ { 'TAB_EPI', 'X3_TITULO', 'EPIs Usados'}, { 'TAB_DESC', 'X3_VALID', 'fDescEPI()' } }, ;
{|| .T.}, .T. )

@param  aCampos, Array, Campos a serem inseridos no aHeader
@param  [lNewGet], Lógico, Indica se a Estrutura é de MsNewGetDados (.T.)
		ou MsGetDados (.F.)
@param  [lUsa], Lógico, Se considera somente campos usados
@param  [lNiv], Lógico, Se considera soemnte campos com nível
		menor ou igual ao do usuário atual
@param  [aExc], Array, Matriz de exceções, de duas dimensões, para inserir
		nas propriedades de algum campo do cabeçalho, valores diferentes do
		que estão no dicionário. Cada array deve ter a seguinte configuração:
		- Posição 1:
		Nome do campo no array de campos para a montagem do
		cabeçalho.
		- Posição 2:
		Nome do campo de X3 que receberá o valor. Devem ser considerados
		de acordo com a função de GetDados usada.
		- Posição 3 :
		Valor diferente a ser atribuido no array de cabeçalho.
@param  [bCondic], Bloco de Código, Condição extra de adição do campo no
		cabeçalho, deve retorar um valor lógico.
@param  [lForFil], Lógico, Indica se força a inclusão da Filial da Tabela

@return aHeader, Array, Contém os campos e suas propriedades
/*/
//-------------------------------------------------------------------
Function NGHeadExc( aCampos, lNewGet, lUsa, lNiv, aExc, bCondic, lForFil )

	Local cCampo    := ''
	Local cNivCpo   := ''
	Local cUsado    := ''
	Local aHeader   := {}
	Local aTamCpo   := {}
	Local aAuxHead  := {}
	Local aStrHead  := {}
	Local nCps      := 0
	Local nPosExc   := 0
	Local nValExec  := 0
	Local nHead     := 0
	Local aArea     := GetArea()

	Default lNewGet := .T.
	Default lUsa    := .T.
	Default lNiv    := .T.
	Default aExc    := {}
	Default bCondic := {|| .T. }
	Default lForFil := .F.

	//Determia os campos do SX3 que irão no aHeader de acordo com a função utilizada
	aStrHead := IIf( lNewGet,  { 'X3_TITULO' , 'X3_CAMPO' , 'X3_PICTURE' , 'X3_TAMANHO' , 'X3_DECIMAL' , 'X3_VALID'  ,               ;
						 		 'X3_USADO'  , 'X3_TIPO'  , 'X3_F3'      , 'X3_CONTEXT' , 'X3_CBOX'    , 'X3_RELACAO', 'X3_WHEN' } , ;
						 		{ 'X3_TITULO', 'X3_CAMPO' , 'X3_PICTURE' , 'X3_TAMANHO' , 'X3_DECIMAL' , 'X3_VALID'  ,               ;
						    	  'X3_USADO' , 'X3_TIPO'  , 'X3_ARQUIVO' , 'X3_CONTEXT' , 'X3_F3'      , 'X3_WHEN'               }   )

	For nCps := 1 To Len( aCampos )

		nPosExc := 0
		cCampo  := aCampos[ nCps ]
		aTamCpo := TamSX3( cCampo )
		cUsado  := GetSx3Cache( cCampo, 'X3_USADO' )
		cNivCpo := GetSx3Cache( cCampo, 'X3_NIVEL' )

		If ( !lUsa .Or. X3Uso( cUsado ) ) .And. ( !lNiv .Or. cNivel >= cNivCpo ) .And. ;
				Eval( bCondic ) .And. ( !( '_FILIAL' $ cCampo ) .Or. lForFil )

			aAuxHead := {}

			For nHead := 1 To Len( aStrHead )
				If aStrHead[ nHead ] == 'X3_TITULO'
					//Utilizado o Posicione pois a função X3Titulo() não funciona corretamente em GetSx3Cache()
					aAdd( aAuxHead , Posicione( 'SX3' , 2 , cCampo , 'X3Titulo()' ) )
				ElseIf aStrHead[ nHead ] == 'X3_PICTURE'
					aAdd( aAuxHead , X3Picture(cCampo) )
				ElseIf aStrHead[ nHead ] == 'X3_TAMANHO'
					aAdd( aAuxHead , aTamCpo[ 1 ] )
				ElseIf aStrHead[ nHead ] == 'X3_DECIMAL'
					aAdd( aAuxHead , aTamCpo[ 2 ] )
				ElseIf aStrHead[ nHead ] == 'X3_USADO'
					aAdd( aAuxHead , cUsado )
				Else
					aAdd( aAuxHead , GetSx3Cache( cCampo , aStrHead[ nHead ] ) )
				EndIf
			Next nHead

			//Enquanto houver array de exceções e o campo atual estiver nele, insere os valores passados dentro do aHeader
			If !Empty( aExc )
				While ( nPosExc := aScan( aExc, { |x| x[ 1 ] == cCampo } ) ) > 0
					nValExec := aScan( aStrHead , { | x | x == aExc[ nPosExc , 2 ] } )
					If nValExec > 0
						aAuxHead[ nValExec ] := aExc[ nPosExc, 3 ]
					EndIf
					//Retira a exceção já adicionada no aHeader
					aDel( aExc , nPosExc )
					aSize( aExc , Len( aExc ) - 1 )
				EndDo
			EndIf

			aAdd( aHeader , aClone( aAuxHead ) )
		EndIf

	Next nCps

	RestArea( aArea )

Return aHeader

//-------------------------------------------------------------------
/*/{Protheus.doc} fGetValues
Monta estrutura de valores do gráfico.

@author  Eduardo Mussi
@since   07/08/2018
@version P12

@param   aValues, Array, Array de estrutura
@param   cAlias, Caracter, Arquivo de Trabalho da estrutura de valores

@return  Array, Estrutura para montagem do gráfico;
				aDate[1] - Valores array;
				aDate[2] - Cordenadas para montagem do gráfico;
				aDate[3] - Legendas do gráfico

/*/
//-------------------------------------------------------------------
Static Function fGetValues( aValues, cAlias )

	Local aVal    := {}
	Local cEixo	  := ''
	Local cLegen  := ''
	Local cValue  := ''
	Local nForVal := 0

	Default cAlias := ''

	For nForVal := 1 To Len( aValues )

		If !Empty( cAlias )
			cValue := &( cAlias + "->" + aValues[ nForVal, 1 ] )
		Else
			cValue := aValues[ nForVal ]
		EndIf

		If nForVal == 1 // Adiciona Colunas do gráfico
			cEixo  := AllTrim( cValue )
		ElseIf nForVal == 2 // Adiciona Legendas do Gráfico
			cLegen := AllTrim( cValue )
		Else // Adiciona Valores do gráfico
			aAdd(aVal, &( AllTrim( Str( cValue , 12, 2 ) ) ) )
		Endif

	Next nForVal

Return { aVal, cEixo, cLegen }


//-------------------------------------------------------------------
/*/{Protheus.doc} fRegTZ9
Função responsável por verificar a existência do indicador pelo seu
título, pois o código é variável.

@author  Guilherme Freudenburg
@since   08/02/2019
@version P12

@param   cTitulo, Caracter, Título do indicador.

@return  Caracter, Código do indicador.

/*/
//-------------------------------------------------------------------
Static Function fRegTZ9(cTitulo)

	Local cAliTZ9 := GetNextAlias()

	Default cTitulo := ""

	BeginSql Alias cAliTZ9
		SELECT TZ9_CODIGO FROM %Table:TZ9% TZ9
			WHERE TZ9.%NotDel% AND
			TZ9.TZ9_FILIAL = %xFilial:TZ9% AND
			TZ9.TZ9_TITULO = %exp:SubStr(cTitulo,1,TAMSX3("TZ9_TITULO")[1])%
	EndSql

Return (cAliTZ9)->TZ9_CODIGO

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} NGLogMsg
Define a forma de apresentação de mensagens quando utilizado JOB.
@type function

@author Alexandre Santos
@since 17/04/2019

@sample NGLogMsg( 'cMessage', 'cTitle', , 'INFO', 'MNTW010' )

@param  cMessage   , Caracter, Mensagem que deve ser apresentada em tela ou console.
@param  [cTitle]   , Caracter, Titulo da mensagem quando em interface.
@param  [aSolution], Array   , Contém string com solução quando utilizado a função Help.
@param  cSeverity  , Caracter, Define o tipo de alerta (INFO, ERROR e WARN).
@param  [cFunction], Caracter, Nome da função de origem.
@return Nil
/*/
//---------------------------------------------------------------------------------------
Function NGLogMsg( cMessage, cTitle, aSolution, cSeverity, cFunction )

	Local lNoInterf   := IsBlind()

	Default cTitle    := ''
	Default cFunction := 'NGUTIL'
	Default aSolution := {}

	Do Case

		Case lNoInterf
			FwLogMsg( cSeverity, , 'BusinessObject', cFunction, '', '01', cMessage, 0, 0, {} )

		Case !Empty( aSolution )
			Help( '', 1, cTitle, , cMessage, 2, 0, , , , , , aSolution )

		Case cSeverity == 'INFO'
			MsgInfo( cMessage, cTitle )

		Case cSeverity == 'WARN'
			MsgAlert( cMessage, cTitle )

		Case cSeverity == 'ERROR'
			MsgStop( cMessage, cTitle )

	EndCase

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} NGREGRAEST
Função responsável por bloquear as validações padrões do Estoque
sobre o produto MANUTENÇÃO ao gerar um registro na tabela SD3
através dos fontes MATA240 e MATA250.Pois o produto MANUTENÇÃO
não é considerado um produto normal como os demais, por este motivo
algumas validações não devem ser feitas.

@param cD3OP,  Caracter, Numero da ordem de produção.
@param cD3COD, Caracter, Código do produto.

@author  Guilherme Freudenburg
@since   16/01/2019
@version P12.1.17 e P12.1.23

@return lRet, Lógico, Retorna falso quando o produto é MANUTENÇÃO.

/*/
//-------------------------------------------------------------------
Function NGREGRAEST(cD3OP,cD3COD)

	Local lRet := .T. // Variável de retorno.

	Default cD3OP := ""
	Default cD3COD := ""

	If !Empty(cD3OP) .And. !Empty(cD3COD) .And. "OS001" $ SubStr(cD3OP,7,5)
		lRet := Alltrim(cD3COD) <> "MANUTENCAO"
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fCheckTZA
Verifica existencia dos códigos na tabela TZA para que não gere
duplicidade ao executar o update.

@author  Eduardo Mussi
@since   04/10/2019
@version P12
@param   cSet  , Caracter, Código a ser inserido no banco
@param   cWhere, Caracter, Código a ser alterado.
@return  Lógico, Define se o código já existe
/*/
//-------------------------------------------------------------------
Static Function fCheckTZA( cSet, cWhere )

	Local aArea := GetArea()
	Local lRet  := .F.

	dbSelectArea( 'TZA' )
	dbsetOrder( 2 ) // TZA_FILIAL + TZA_CODIND
	If ( lRet := dbSeek( xFilial( 'TZA' ) + cSet ) ) .And. dbSeek( xFilial( 'TZA' ) + cWhere )
		RecLock( 'TZA', .F. )
		TZA->( dbDelete() )
		TZA->( MsUnlock() )
	EndIf

	RestArea( aArea )

Return lRet

//-----------------------------------------------------------------------------------------
/*/{Protheus.doc} NgVldRpo
Valida se o os fontes passados via parâmetros encontram-se atualizados no RPO.
@type function

@author Alexandre Santos
@since 22/10/2019

@sample NgVldRpo( { { 'MNTA420.prx', cToD( '22/10/2019' ), '08:00' }, { 'MNTUTIL_OS.prw',;
	cToD( '22/10/2019' ), '08:00' } } )

@param 	aProgram, Array, [1] - Nome do fonte com sua extensão que será verificado.
						 [2] - Data minima para versão do fonte ser considerada atualizada.
						 [3] - Hora minima para versão do fonte ser considerada atualizada.
@return Lógico  , Define se os fontes verificados encontram-se atualizados ou não.
/*/
//-----------------------------------------------------------------------------------------
Function NgVldRpo( aProgram )

	Local aInfos := {}
	Local lRet   := .T.
	Local nIndex := 0
	
	For nIndex := 1 to Len( aProgram )

		If !Empty( aInfos := aClone( GetApoInfo( aProgram[nIndex,1] ) ) )

			If dToS( aProgram[nIndex,2] ) + aProgram[nIndex,3] >= dToS( aInfos[4] ) + aInfos[5]

				lRet := .F.
				Exit

			EndIf
		
		Else

			/*-----------------------------------+
			| Caso algum fonte não exista no RPO |
			+-----------------------------------*/
			lRet := .F.
			Exit

		EndIf

	Next nIndex

	/*--------------------------------------------------+
	| Desaloca consumo de memória p/ melhor performance |
	+--------------------------------------------------*/
	aSize( aInfos, 0 )
	aInfos := Nil

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} BitToTime
Tranforma Numero de Bits em Tempo de Operacao

@author Eduardo Henrique Mussi
@since  30/03/2020
@param  nBits    , Numérico, Bits
@param  lTypeHour, Lógico  , Define qual formato irá retornar a hora.
							 .T. = 'HHHH:MM'
							 NIL = 'HH:MM'
@param  nValueInt, Numérico, Intervalo do calendário( MV_PRECISA ).
@return cTime, retorna tempo de operação.
/*/
//-------------------------------------------------------------------
Function BitToTime( nBits, lTypeHour, nValueInt )

	Local cTime    := ''
	Local cHours    := 0
	Local nBitsMin  := 0
	Local nMinutes  := 0
	Local nSizeHour := 0

	Default nValueInt := SuperGetMv( 'MV_PRECISA', .F., 4 ) // Parametro de Intervalo do Calendario

	cHours := Int( nBits / nValueInt )

	nSizeHour := IIf( lTypeHour == NIL, 4, Len( Alltrim( Str( cHours, 8, 0 ) ) ) )

	nSizeHour := IIf( nSizeHour == 1, 2, nSizeHour )

	cTime := StrZero( cHours, nSizeHour, 0)

	nBitsMin := ( ( nBits / nValueInt ) - Int( nBits / nValueInt ) ) * nValueInt
	nMinutes := ( 60 / nValueInt ) * nBitsMin

	cTime += ":"+StrZero( nMinutes, 2, 0)

Return SubStr( cTime, 3 )

//-------------------------------------------------------------------
/*/{Protheus.doc} NGREL27OUT
Verifica se o release acessado é 27 Outubro ou superior.

MPRetDicM2 - Função disponibilizada pela equipe de engenharia (Ernani)
de forma a consultar uma submarca de release no dicionário do ambiente.

Exemplo release 12.1.27 Outubro:
Quando o cliente executar a migração para o release 12.1.27 OUT,
seu ambiente possuirá uma submarca para o release 12.1.27.
Dessa forma a função MPRetDicM2 apenas recuperará a submarca do ambiente.

Logo,

Release 12.1.27 origem (Abril): a função retornará uma string vazia,
pois não possui submarca;
Release 12.1.27 Outubro: a função retornará a data de expedição do
release (20201001)
Release 12.131: a função retornará uma string vazia, pois é um
release de origem e não possuirá submarca;
Lembrando que a marca está no dicionário, logo não basta atualizar
o RPO para ter acesso à essa informação.

@type   Function

@author Eduardo Mussi
@since  17/08/2020

@return Lógico, .T. - Release 27 outubro ou superior
/*/
//-------------------------------------------------------------------
Function NGREL27OUT()
Return GetRPORelease() >= '12.1.031' .Or. ( FindFunction( 'MPRetDicM2' ) .And. !Empty( MPRetDicM2() ) )

//-------------------------------------------------------------------
/*/{Protheus.doc} fNewChart
Gráficos criados pela classe FWChartFactory

@author Maria Elisandra de Paula
@since 22/06/2021
@param aGraph, array, informações do gráfico
@return Nil
/*/
//-------------------------------------------------------------------
Static Function fNewChart( aGraph )

	Local oPanelPai
	Local oPanelTop
	Local oDlg
	Local oChart

	aSize := MsAdvSize(,.F.,400)
	aObjects := {}
	
	AAdd( aObjects, { 100, 100 , .T., .T. } )
	aPosObj := MsObjSize( { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 2, 2 }, aObjects, .T. )
	
	DEFINE MSDIALOG oDlg TITLE aGraph[6] From aSize[7],0 to aSize[6],aSize[5] of oMainWnd PIXEL

		//oDlg:lMaximized := .T.
		oDlg:lEscClose  := .F.
		oPanelTop:= TPanel():New( , ,,oDlg,,,,,, 0,  50)
		oPanelTop:Align := CONTROL_ALIGN_TOP

		oPanelPai:= TPanel():New(,,,oDlg,,,,,, 0,0)
		oPanelPai:Align := CONTROL_ALIGN_ALLCLIENT

		Processa({|| oChart := CreateSerie( oPanelPai, PIECHART, aGraph )})

	ACTIVATE DIALOG oDlg ON INIT fNewMenu( oPanelTop, aGraph, oPanelPai, oChart )

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fNewMenu
Define menu para gráficos da classe FWChartFactory

@author Maria Elisandra de Paula
@since 22/06/2021
@param oPanelTop, object, painel onde será criado o menu
@param aGraph, array, informações do gráfico
@param oPanelPai, object, painel onde será criado o gráfico
@param oChart, object, gráfico gerado
@return Nil
/*/
//-------------------------------------------------------------------
Static Function fNewMenu( oPanelTop, aGraph, oPanelPai, oChart )

	Local oMenu := TBar():New( oPanelTop, 25, 32, .T. ,,,, .T. )

	DEFINE BUTTON RESOURCE 'S4WB008N' OF oMenu ACTION Calculadora() PROMPT ' '	TOOLTIP STR0168 //"Calculadora"
	DEFINE BUTTON RESOURCE 'PMSPRINT' OF oMenu ACTION PrintGraph( aGraph[1][1], oChart, .T.) PROMPT ' ' TOOLTIP Capital( STR0026 ) //"Imprimir"
	DEFINE BUTTON RESOURCE 'SALVAR'   OF oMenu ACTION NGSavePNG( oChart ) PROMPT ' ' TOOLTIP STR0169 //"Salva &BMP"
	DEFINE BUTTON RESOURCE 'S4WB013N' OF oMenu ACTION oChart := CreateSerie( oPanelPai, PIECHART,     aGraph ) PROMPT ' ' TOOLTIP STR0171 //"Pizza"
	DEFINE BUTTON RESOURCE 'BAR'      OF oMenu ACTION oChart := CreateSerie( oPanelPai, BARCOMPCHART, aGraph ) PROMPT ' ' TOOLTIP STR0172 //"Barra"
	DEFINE BUTTON RESOURCE 'LINE'     OF oMenu ACTION oChart := CreateSerie( oPanelPai, LINECHART,    aGraph ) PROMPT ' ' TOOLTIP STR0173 //"Linha"
	DEFINE BUTTON RESOURCE 'PAPEL_ESCRITO' OF oMenu ACTION DetailGraph( aGraph ) 									 PROMPT ' ' TOOLTIP STR0174 //"Detalhes"

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} NgMemo
Função para substituir a MSMM porque por algum motivo ela vem falhando.
Retorna os atalhos do laudo. ( lAtalho := .T. )
Retorna conteúdo do campo. ( lAtalho := .F. )

@author Gabriel Sokacheski
@since 28/10/2021

@param cChave, Caractere, Código chave do campo na tabela SYP
@param lAtalho, Lógico, Indica se a busca é por um atalho de laudo.
@param cTabela, Caractere, Alias da tabela memo, SYP ou RDY.
@param cFilial, Caractere, Como o PPRA/PGR possuem impressão
	multi-filial, é necessário passar a filial.

@return xConteudo, Indefinido, Contém os atalhos a serem impressos.
/*/
//-------------------------------------------------------------------
Function NgMemo( cChave, lAtalho, cTabela, cFil )

	//Salva a área
	Local aArea := GetArea()

	//Variáveis de busca das informações
	Local cAlias	 := GetNextAlias()
	Local cCampo	 := ''
	Local xConteudo	 := ''
	Local nQuebraLi	 := 0
	Local nPosArroba := 0

	//Valores padrões
	Default lAtalho	:= .F.
	Default cTabela	:= 'SYP'
	Default cFil	:= xFilial( cTabela )

	cCampo := IIf( cTabela == 'SYP', 'YP_TEXTO', 'RDY_TEXTO' )

	If cTabela == 'SYP'

		BeginSQL Alias cAlias
			SELECT 
				YP_TEXTO
			FROM 
				%Table:SYP% SYP
			WHERE 
				SYP.YP_FILIAL = %Exp:cFil%
				AND SYP.YP_CHAVE = %Exp:cChave%
				AND SYP.%NotDel%
		EndSQL

	Else

		BeginSQL Alias cAlias
			SELECT 
				RDY_TEXTO
			FROM 
				%Table:RDY% RDY
			WHERE 
				RDY.RDY_FILIAL = %xFilial:RDY%
				AND RDY.RDY_CHAVE = %Exp:cChave%
				AND RDY.%NotDel%
		EndSQL

	EndIf

	While !( cAlias )->( Eof() )

		If lAtalho // Atalhos do laudo

			nPosArroba := Rat( '@', ( cAlias )->( &cCampo ) ) // Posição do último @

			// Algumas opções da montagem do laudo possuem @ e outras não
			If nPosArroba > 0

				xConteudo += SubStr( ( cAlias )->( &cCampo ), 1, nPosArroba ) + Chr( 13 ) + Chr( 10 )

			Else

				nQuebraLi := At( '\', ( cAlias )->( &cCampo ) ) // Posição da primeira \
				xConteudo += SubStr( ( cAlias )->( &cCampo ), 1, nQuebraLi - 1 ) + Chr( 13 ) + Chr( 10 )

			EndIf

		Else // Conteúdo do campo cadastrado

			nQuebraLi := At( '\', ( cAlias )->( &cCampo ) ) // Posição da primeira \

			If nQuebraLi != 0

				xConteudo += SubStr( ( cAlias )->( &cCampo ), 1, nQuebraLi - 1 ) + Chr( 13 ) + Chr( 10 )

			Else

				xConteudo += RTrim( ( cAlias )->( &cCampo ) )

			EndIf

		EndIf

		( cAlias )->( dbSkip() )

	End

	( cAlias )->( dbCloseArea() )

	RestArea( aArea )

Return xConteudo

//---------------------------------------------------------------------
/*/{Protheus.doc} NGMedia
Realiza a media a partir de um array.
@type function

@author	Cauê Girardi Petri
@since 31/05/2023

@param  aAvg , array, array que será analisado.
@return nAvg, int, media do array
/*/
//---------------------------------------------------------------------
Function NGMedia(aAvg)

Local i
Local nAvg := 0

If !Empty(aAvg)

	For i := 1 to Len(aAvg)

		nAvg += aAvg[i]

	Next i

	nAvg := nAvg/Len(aAvg)

EndIf
	
Return nAvg

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCount
Realiza contagem de registros em uma tabela.
@type function

@author	Alexandre Santos
@since 09/07/2024

@param  cTable , string, Tabela que será contabilizada.
@return integer, Quantidade de registros não deletados.
/*/
//---------------------------------------------------------------------
Function NGCount( cTable )

	Local cAlsRec   := GetNextAlias()
	Local cTabRec   := '%' + cTable + '%'
	Local nRecCount := 0

	BeginSQL Alias cAlsRec

		SELECT
			COUNT( 1 ) AS QTD_REC
		FROM
			%exp:cTabRec%
		WHERE
			%NotDel%

	EndSQL

	nRecCount := (cAlsRec)->QTD_REC

	(cAlsRec)->( dbCloseArea() )
	
Return nRecCount

//---------------------------------------------------------------------
/*/{Protheus.doc} NGZap
Realiza deleção de todos os registros da tabela.
@type function

@author	Alexandre Santos
@since 05/09/2024

@param  cTable   , string, Tabela que terá os registros deletados.
@param  [cCondic], string, Filtro para execução do DELETE.
@return
/*/
//---------------------------------------------------------------------
Function NGZap( cTable, cCondic )

	Local cDelete   := ''

	Default cCondic := ''

	cDelete := "DELETE FROM " + cTable

	If !Empty( cCondic )
		
		cDelete += ' WHERE ' + cCondic

	EndIf

	TcSQLExec( cDelete )
	
Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NgSX2Fil
Retorna o compartilhamento da tabela conforme SX2

@author Eloisa Anibaletto
@since 28/11/2024

@param, cAlias, Código da tabela
@param, cFil, Código da filial

@return, cFilComp, Código filial conforme compartilhamento na SX2
/*/
//---------------------------------------------------------------------
Function NgSX2Fil( cAlias, cFil )

	Local aCampos 	:= FWSX2Util():GetSX2Data( cAlias, { 'X2_MODO', 'X2_MODOUN', 'X2_MODOEMP' } )

	Local cFilComp	:= FwxFilial( cAlias, cFil, aCampos[ 3, 2 ], aCampos[ 2, 2 ], aCampos[ 1, 2 ] )

Return cFilComp
