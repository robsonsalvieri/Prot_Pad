#Include "Mdta685.ch"
#Include "Protheus.ch"
#Include "FWMVCDEF.CH"

Static _DTINIC_ := 1
Static _DTFIM_  := 2
Static _HRINIC_ := 3
Static _HRFIM_  := 4
Static _EMITEN_ := 5
Static _CODABO_ := 6
Static _NATEST_ := 7
Static _TIPATE_ := 8
Static _TIPAFA_ := 9
Static _CODAFA_ := 10
Static _CID_    := 11
Static _NUMFIC_ := 12

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTA685
Programa de Cadastro de Atestado Medico

@type function

@source MDTA685.prx

@author Paulo Pego
@since 11/12/99

@param lFontPS, Lógico, Determina se é prestador de serviço.

@sample MDTA685( .F. )

@return Nil , Vazio.
/*/
//---------------------------------------------------------------------
Function MDTA685( lFontPS , nOpcAuto , aAuto , oModelAuto )

	Local oBrowse
	Local lRet     := .T.
	Local cAlsAfas := GetNextAlias()

	Private aTROCAF3 	:= {}
	Private lInt_AfaGpe := SuperGetMv( "MV_NGMDTAF" , .F. , "N" ) == "S"
	Private cPrograma 	:= 'MDTA685'
	Private nDiasFecha  := 0
	Private lInt_PonGpe := MDT685VPON( lInt_AfaGpe , @nDiasFecha )
	Private lSigaMdtPS  := SuperGetMv("MV_MDTPS",.F.,"N") == "S" //Prestador de Serviço
	Private lCpoSr8 	:= .F.
	Private nIndSR8     := f685RetOrder("SR8","R8_FILIAL+R8_NATEST")
	Private lAtesAnt    := NGCADICBASE("TNY_ATEANT","A","TNY",.F.)
	Private lCpoIndSr8 	:= .F.
	Private lFicha		:= .T.
	Private APERATUAL 	:= {}
	Private cCadastro   := OemtoAnsi(STR0006) //"Atestado Medico"
	Private lContinu    := .F. //Determina que está sendo chamada pela Continuação do atestado.
	Private lDiagnos    := .F. //Determina que está sendo chamada pela rotina de Diagnóstico.
	Private cMarca	    := GetMark()
	Private lInvert     := .F.
	Private lPriCont    := .F.

	Default lFontPS  := !IsInCallStack( "MDTA685PS" )
	Default aAuto    := {}
	Default nOpcAuto := 0

	If AMiIn( 35 ) // Somente autorizado para SIGAMDT

		If !FindFunction( 'G240NextSq' ) .And. SuperGetMv( 'MV_MDTGPE', .F., 'N' ) == 'S'
			// "Será necessário atualizar o fonte gpea240 do módulo SIGAGPE para utilizar a integração com a rotina de ausências"
			MsgStop( STR0249 + '.', STR0153 )
			Return
		EndIf

		If SR8->(ColumnPos("R8_NATEST")) > 0 //Campo Específico.
			lCpoSr8 := .T.
			If nIndSR8 > 0
				lCpoIndSr8 := .T.
			EndIf
		EndIf

		//Pega todos os Atestados com Afastamento
		BeginSQL Alias cAlsAfas
			SELECT TNY.TNY_FILIAL, TNY.TNY_NUMFIC, TNY.TNY_DTINIC, TNY.TNY_HRINIC
				FROM %table:TNY% TNY
				WHERE ( TNY.TNY_DTSAID <> '' OR TNY.TNY_DTSAI2 <> '' OR TNY.TNY_DTSAI3 <> '' ) AND
						TNY.TNY_CODAFA <> '' AND
						TNY.TNY_FILIAL = %xFilial:TNY% AND
						TNY.%notDel%
		EndSQL

		If TYZ->(LASTREC()) == 0 .And. ( cAlsAfas )->( !EoF() ) //Se a tabela TYZ não foi populada

			MsgStop(STR0221) // "Verificamos que os seus registros de afastamento dos atestados médicos, não foram transferidos para a nova
							// tabela (TYZ) em sua base. Não é possível acessar a rotina de Atestado Medico (MDTA685) sem a correção destes dados."
			lRet := .F.

		ElseIf ValType( aAuto ) == 'A' .And. Len( aAuto ) > 0 //Caso seja rotina automatica.
			FwMVCRotAuto( oModelAuto , "TNY" , nOpcAuto , aAuto )
			If lMsErroAuto //Mostra mensagem de Erro, caso encontre alguma inconsistência no ExecAuto.
				If !IsBlind()
					Mostraerro()
				EndIf
				lRet := .F.
			EndIf
		Else
			AADD(aTROCAF3,{"TNY_CID","TMR"})

			//Verifica se usuario de acesso tem permissão para a execução.
			If FindFunction("MDTRESTRI") .And. MDTRESTRI('MDTA685')
				If fValExeRot( lFontPS )
					// Instanciamento da Classe de Browse
					oBrowse := FWMBrowse():New()

					// Definição da tabela do Browse
					oBrowse:SetAlias("TNY")

					oBrowse:SetMenuDef( 'Mdta685' )

					// Titulo da Browse
					oBrowse:SetDescription(STR0006) //"Atestado Medico"

					If FwIsInCallStack( 'mdta156' )
						oBrowse:SetFilterDefault( 'TMT->TMT_NUMFIC == TNY->TNY_NUMFIC' )
					EndIf

					// Ativação da Classe
					oBrowse:Activate()
				EndIf
			EndIf

			// Retorna conteudo de variaveis padroes
			SetKey( VK_F9, { | |  } )
		EndIf

	EndIf

Return lRet

//--------------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Definição do Menu (padrão MVC).

@type function

@source MDTA685.prx

@author Rafael Diogo Richter
@since 29/11/2006

@sample MenuDef()

@return aRotina, Array, Retorna as opções do Menu.
/*/
//-------------------------------------------------------------------------
Static Function MenuDef()

	Local aRotina := {}
	Local lPyme   := IIf( Type("__lPyme") <> "U", __lPyme, .F. )

	ADD OPTION aRotina Title STR0001 Action 'AxPesqui'		  OPERATION 1 ACCESS 0 //'Pesquisar'
	ADD OPTION aRotina Title STR0002 Action 'VIEWDEF.MDTA685' OPERATION 2 ACCESS 0 //'Visualizar'
	ADD OPTION aRotina Title STR0003 Action 'VIEWDEF.MDTA685' OPERATION 3 ACCESS 0 //'Incluir'
	ADD OPTION aRotina Title STR0004 Action 'VIEWDEF.MDTA685' OPERATION 4 ACCESS 0 //'Alterar'
	ADD OPTION aRotina Title STR0005 Action 'VIEWDEF.MDTA685' OPERATION 5 ACCESS 0 //'Excluir'
	ADD OPTION aRotina Title STR0128 Action 'MDT685CONT' 	  OPERATION 9 ACCESS 0 //'Continuação'
	ADD OPTION aRotina Title STR0018 Action 'MDT685IMP' 	  OPERATION 2 ACCESS 0 //'Imprimir.'

	If SuperGetMv( "MV_NG2AUDI" , .F. , "2" ) == "1"
		ADD OPTION aRotina Title STR0154 Action 'MDTA991("TNY")' OPERATION 3 ACCESS 0 //"Hist. Exc."
	EndIf

	If !lPyme
		ADD OPTION aRotina Title 'Conhecimento' Action 'MsDocument' OPERATION 4 ACCESS 0 //'Conhecimento'
	EndIf

Return aRotina

//--------------------------------------------------------------------------
/*/{Protheus.doc} ModelDef
Definição do Modelo (padrão MVC).

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since  09/02/2017

@sample ModelDef()

@return oModel, oBject, Retorna o modelo.
/*/
//-------------------------------------------------------------------------
Static Function ModelDef()

	// Cria a estrutura a ser usada no Modelo de Dados
	Local oStruTNY := FWFormStruct( 1, 'TNY' ) //Estrutura principal TNY - Atestados Medicos.
	Local oStruTKI := FWFormStruct( 1, 'TKI' ) //Primera Grid TKI - CID complementar para Atestado.
	Local oStruTYZ
	Local oModel
	Local aArea := TNY->(GetArea())

	oStruTYZ := FWFormStruct( 1, 'TYZ' ) //Segunda Grid TYZ - Afastamentos.

	If !FindFunction( "MDTRESTRI" ) .Or. MDTRESTRI( "MDTA685" )

		// Remove elementos da estrutura Grid.
		oStruTKI:RemoveField( "TKI_NATEST" )
		oStruTKI:RemoveField( "TKI_FILIAL" )

		If ( FWIsInCallStack( 'Tcfa040' ) .Or. FWIsInCallStack( 'MdtExe' ) ) .And. aMeuRh[ 2 ]
			oStruTNY:SetProperty( 'TNY_NUMFIC', MODEL_FIELD_WHEN, { || .F. } )
		EndIf

		// Cria o objeto do Modelo de Dados
		oModel := MPFormModel():New( 'MDT685',;
			{ | oModel | MDT685COND( oModel ) } /* bPreValid */,;
			{ | oModel | If( IsInCallStack( 'MDTA410' ), .T., MDT685POS( oModel ) ) } /* bPosValid */,;
			{ | oModel | MDT685COMM( oModel )} /* bCommit */,;
			/* bCancel */;
		)

		// Define função que será executada na pré validação do modelo
		oModel:SetVldActivate({|oModel| IIf( ExistBlock("MDTA6852"), ExecBlock("MDTA6852",.F.,.F.,{ oModel:GetOperation(), aArea } ), .T. ) })

		// Adiciona ao modelo um componente de formulário
		oModel:AddFields( 'TNYMASTER1', /*cOwner*/, oStruTNY )

		// Adiciona ao modelo uma componente de Grid TKI - CID complementar para Atestado.
		oModel:AddGrid( 'TKIDETAIL', 'TNYMASTER1', oStruTKI, /*bLinePre*/, { |oStruTKI| MDT685TUDOK( oModel ) }/*bLinePos*/, /*bPreVal*/,{ |oStruTKI| MDT685TUDOK( oModel , .T. ) }/*bPosVal*/ , /*BLoad*/ )

		// Adiciona ao modelo uma componente de Grid TYZ - Afastamentos.
		oModel:AddGrid( 'TYZDETAIL', 'TNYMASTER1', oStruTYZ, { |oStruTYZ| MDT685PRE( oModel ) }/*bLinePre*/, { |oStruTYZ| MDT685TYZ( oModel ) .And. MDT685GRID(oModel) }/*bLinePos*/, /*bPreVal*/,{ |oStruTYZ| MDT685TYZ( oModel  ) }/*bPosVal*/ , /*BLoad*/ )

		// Retira a obrigatoriedade de preenchimento da Grid.
		oModel:GetModel( 'TKIDETAIL' ):SetOptional( .T. ) //CID complementar para Atestado.

		oModel:GetModel( 'TYZDETAIL' ):SetOptional( .T. ) //TYZ - Afastamentos.

		// Valida repetição de Linha da Grid.
		oModel:GetModel( "TKIDETAIL" ):SetUniqueLine( { 'TKI_GRPCID', 'TKI_CID' } )

		oModel:GetModel( "TYZDETAIL" ):SetUniqueLine( { 'TYZ_DTSAID', 'TYZ_DTALTA' } )


		// Faz relacionamento entre os componentes do model
		oModel:SetRelation( 'TKIDETAIL', { { 'TKI_FILIAL', 'xFilial( "TKI" )' }, { 'TKI_NATEST', 'TNY_NATEST' } }, TKI->( IndexKey( 1 ) ) )

		oModel:SetRelation( 'TYZDETAIL', { { 'TYZ_FILIAL', 'xFilial( "TYZ" )' }, { 'TYZ_NATEST', 'TNY_NATEST' } }, TYZ->( IndexKey( 1 ) ) )


		// Adiciona a descrição do Modelo de Dados
		oModel:SetDescription(STR0006) //"Atestado Medico"

		// Adiciona a descrição do Componente do Modelo de Dados
		oModel:GetModel( 'TNYMASTER1' ):SetDescription( STR0006 )//"Atestado Medico"
		oModel:GetModel( 'TKIDETAIL'  ):SetDescription( STR0190 ) //"CID Complementar para Atestado"


		oModel:GetModel( 'TYZDETAIL'  ):SetDescription( STR0191 ) //"Afastamentos"


	EndIf

Return oModel // Retorna o Modelo de dados

//--------------------------------------------------------------------------
/*/{Protheus.doc} ViewDef
Definição do View (padrão MVC).

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since  09/02/2017

@sample ViewDef()

@return oView, oBject, Retorna o modelo.
/*/
//-------------------------------------------------------------------------
Static Function ViewDef()

	// Cria um objeto de Modelo de dados baseado no ModelDef() do fonte informado
	Local oModel := FWLoadModel( 'MDTA685' )

	//Variaiveis para auxilio a montagem dos folders.
	Local nCamp     := 0
	Local nX 	    := 0
	Local nY	    := 0
	Local cCampos	:= ""
	Local aCampos	:= { { "1" , STR0218 }, ; //"Atestado"
						 { "2" , STR0219 }, ; //"Ponto Eletrônico"
						 { "3" , STR0220 }, ; //"Afastamentos"
						 { "4" , STR0201 } } //"Outros"
	Local cCampo    := ''
	Local nCps      := 0
	Local aNao := {;
		'TNY_DTSAID',;
		'TNY_DTALTA',;
		'TNY_DTSAI2',;
		'TNY_DTALT2',;
		'TNY_DTSAI3',;
		'TNY_DTALT3',;
		'TNY_ATEANT',;
		'TNY_FILIAL',;
		'TNY_COMUOK';
	}
	Local aCpsTNY   := APBuildHeader( "TNY" ) //Traz todos os campos da tabela

	// Cria as estruturas que serão utilizadas.
	Local oStruTNY1  //Estrutura principal
	Local oStruTKI  := FWFormStruct( 2, 'TKI' ) //Estrutura da Grid TKI - CID complementar para Atestado.
	Local oStruTYZ

	Local oView // Interface de visualização construída

	oStruTYZ  := FWFormStruct( 2, 'TYZ' ) //Estrutura da Grid TYZ - Afastamentos.

	If !FindFunction( "MDTRESTRI" ) .Or. MDTRESTRI( "MDTA685" )

		// Cria o objeto de View
		oView := FWFormView():New()

		// Define qual o Modelo de dados será utilizado na View
		oView:SetModel( oModel )

		// Remove elementos da estrutura
		oStruTKI:RemoveField( "TKI_NATEST" )
		oStruTKI:RemoveField( "TKI_FILIAL" )
		oStruTYZ:RemoveField( "TYZ_NATEST" )
		oStruTYZ:RemoveField( "TYZ_FILIAL" )
		oStruTYZ:RemoveField( "TYZ_MAT"    )
		oStruTYZ:RemoveField( "TYZ_TIPO"   )
		oStruTYZ:RemoveField( "TYZ_TIPOAF" )
		oStruTYZ:RemoveField( 'TYZ_SEQ' )

		// Cria Box na view
		oView:CreateHorizontalBox( 'MAIN', 100 )

		// Cria Folder na view
		oView:CreateFolder( 'MAIN_FOLDER' , 'MAIN' )

		For nCps := 1 To Len(aCpsTNY)

			cCampo  := AllTrim(aCpsTNY[ nCps, 2 ])
			cFolder := GetSx3Cache( cCampo, 'X3_FOLDER' )

			If aSCAN( aNao,{|x| Alltrim(x) == Alltrim(cCampo) } ) == 0 //Retira campos da tela.
				If !Empty(cFolder)
					nCamp := aSCAN(aCampos,{|x| x[1] == cFolder })
					If nCamp > 0
						aAdd( aCampos[nCamp],  cCampo )
					EndIf
				Else
					aAdd( aCampos[Len(aCampos)],  cCampo )
				EndIf
			EndIf

		Next nCps

		// Percorre todos os campos e monta os Folders.
		For nX := 1 To Len(aCampos)
			For nY := 1 To Len(aCampos[nX])
				If nY <> 1 .And. nY <> 2
					cCampos += aCampos[nX,nY]+","
				EndIf
			Next nY
			If !Empty(cCampos)

				//Adiciona os campos na Estrutura
				oStruTNY1 := FWFormStruct( 2, 'TNY' ,{|cCampo| (AllTrim(cCampo) $ cCampos )} )
				oStruTNY1:aFolders := {}

				//Adiciona o View com os campos.
				oView:AddField( 'VIEW_TNY'+cValtoChar(aCampos[nX,1]), oStruTNY1, 'TNYMASTER1' )

				//Adiciona um folder (Aba).
				oView:AddSheet( 'MAIN_FOLDER', 'ABA'+cValtoChar(aCampos[nX,1]) , cValtoChar(aCampos[nX,2]) )

				oView:CreateHorizontalBox('BOX'+cValtoChar(aCampos[nX,1]) ,If( nX == 1 .Or. nX == 3 , 50 , 100 ) ,,,'MAIN_FOLDER','ABA'+cValtoChar(aCampos[nX,1]))

				oView:SetOwnerView( 'VIEW_TNY'+cValtoChar(aCampos[nX,1]) , 'BOX'+cValtoChar(aCampos[nX,1]) )
				If nX == 1 //Caso seja Folder Atestado adiciona a Grid.

					//Adiciona no nosso View um controle do tipo Grid (antiga Getdados)
					oView:AddGrid( 'VIEW_TKI'+cValtoChar(aCampos[nX,1]), oStruTKI, 'TKIDETAIL' )
					//Adiciona nome a grid de Cid Complementar
					oView:EnableTitleView( 'VIEW_TKI'+cValtoChar(aCampos[nX,1]) , FwX2Nome("TKI") )

					oView:CreateHorizontalBox('BOX01GRID' ,50,,,'MAIN_FOLDER','ABA'+cValtoChar(aCampos[nX,1]))

					oView:SetOwnerView( 'VIEW_TKI'+cValtoChar(aCampos[nX,1]) , "BOX01GRID"  )

				ElseIf nX == 3//Caso seja Folder de Afastamento, adiciona a Grid.
					//Adiciona no nosso View um controle do tipo Grid (antiga Getdados)
					oView:AddGrid( 'VIEW_TYZ'+cValtoChar(aCampos[nX,1]), oStruTYZ, 'TYZDETAIL' )
					//Adiciona nome a grid de Afastamento Atestado Médico
					oView:EnableTitleView( 'VIEW_TYZ'+cValtoChar(aCampos[nX,1]) , FwX2Nome("TYZ") )

					oView:CreateHorizontalBox( 'BOX02GRID' ,50,,,'MAIN_FOLDER','ABA'+cValtoChar(aCampos[nX,1]) )

					oView:SetOwnerView( 'VIEW_TYZ'+cValtoChar(aCampos[nX,1]) , "BOX02GRID"  )
				EndIf
				//Limpa Variavel de campos.
				cCampos := ""
			EndIf
		Next nX

		// Opção adcionadas em 'Outras Ações'
		oView:AddUserButton(STR0027, "DEVOLNF", { |oView| MDT685AFAS() } ) //"Afastamentos"
		oView:AddUserButton(STR0029, "BMPCONS", { |oView| MdtPesqCid() } ) //"C.I.D."

		NGMVCUserBtn( oView ) // Inclusão de itens no 'Outras Ações'
	EndIf

Return oView // Retorna o objeto de View criado

//----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} MDT685VPON
Carrega parâmetros de Integração com o Ponto Eletrônico

@return lPonGpe Lógico Indica se há ou não a integração com o Ponto Eletrônico

@param lInt_AfaGpe Lógico Indica se gera Afastamento para o SIGAGPE
@param nQtdDFch Numérico Valor a ser considerado para validar o lançamento no fechamento do Ponto

@sample MDT685VPON( .T. )

@author Jackson Machado
@since 01/07/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function MDT685VPON( lInt_AfaGpe , nQtdDFch )

	Local xQtdDia := 0
	Local lPonGpe := .F.

	Default lInt_AfaGpe := Alltrim( GetMV( "MV_NGMDTAF" ) ) == "S"
	Default nQtdDFch	:= 0

	If SuperGetMv("MV_NG2IPON",.F., If( lInt_AfaGpe , "1" , "2" ) ) == "1"
		lPonGpe := .T.
	EndIf

	xQtdDia  := GetNewPar( "MV_NG2DFP" , 0 )
	nQtdDFch := If( ValType( xQtdDia ) == "C" , Val( xQtdDia ) , xQtdDia )

Return lPonGpe

//---------------------------------------------------------------------
/*/{Protheus.doc} fValExeRot
Valida execução da rotina MDTA095PS

@return lIncons Boolean Indica se há inconsistencia na execução.
@param lFontPS  Boolean Indica se foi feito a chamada pelo MDTA095PS

@sample fValExeRot(.T.)
@author Jean Pytter da Costa

@since 24/08/2015
/*/
//---------------------------------------------------------------------
Static Function fValExeRot( lFontPS )

	Local lIncons := .T.

	If lSigaMDTPS .And. !lFontPS
		ShowHelpDlg( 	"NOCALLPS"  , ;
				    	{ STR0198 } , 1 , ; //"Função incorreta."
				    	{ STR0199 + ; 		//"Faz se necessário a alteração do Menu. A rotina 'Atestado Médico' deverá chamar o programa MDTA685PS."
				    	  STR0200 } , 3 ) 	//"Favor contate administrador de sistemas"
		lIncons := .F.
	EndIf

Return lIncons

//--------------------------------------------------------------------------
/*/{Protheus.doc} MDT685FicV
Valida o campo de FIcha Médica.

@type function

@source MDTA685.prx

@author Inacio Luiz Kolling
@since  24/03/2000

@param cFichaMed, Caracter, Ficha Médica utilizada.

@sample MDT685FicV('0000001')

@obs Função usada no Dicionário de Dados

@return lRet, Lógico, Retorna verdadeiro caso não ocorra inconsistencias.
/*/
//-------------------------------------------------------------------------
Function MDT685FicV(cFichaMed)

	Local lRet       := .T.
	Local aAreaTNY   := TNY->(GetArea())//Salva área posicionada
	Local aAreaTM0   := TM0->(GetArea())//Salva área posicionada

	dbSelectArea("TM0") //Posiciona na Ficha Médica
	dbSetOrder(1)
	dbSeek(xFilial("TM0")+cFichaMed)

	lRet := SitFunFicha(cFichaMed,.T.,.T.,.T.)

	// Retorna área
	RestArea(aAreaTM0)
	RestArea(aAreaTNY)

	DbSelectArea( 'TM0' )
	( 'TM0' )->( DbSetOrder( 1 ) )

	If ( 'TM0' )->( Dbseek( xFilial( 'TM0' ) + M->TNY_NUMFIC ) )

		DbSelectArea( 'SRA' )
		( 'SRA' )->( DbSetOrder( 1 ) )

		If !Empty( TM0->TM0_MAT ) .And. ( 'SRA' )->( Dbseek( xFilial( 'SRA', TM0->TM0_FILFUN ) + TM0->TM0_MAT ) )

			If !Empty(M->TNY_DTINIC) .And. M->TNY_DTINIC < SRA->RA_ADMISSA
				MsgStop(STR0209, STR0111) //"A data de início do atestado não pode ser menor que a data de admissão do funcionário."###"ATENÇÃO"
				lRet := .F.
			ElseIf ( FWIsInCallStack( 'Tcfa040' ) .Or. FWIsInCallStack( 'MdtExe' ) ) .And. !aMeuRh[ 2 ] .And. SRA->RA_MAT != aMeuRh[ 3 ]

				//-----------------------------------------------------------------------------
				// Mensagens:
				// "Atenção"
				// "A matrícula da ficha médica é diferente da matrícula informada pelo MeuRh"
				// "Informe uma ficha médica que possua a mesma matrícula"
				//-----------------------------------------------------------------------------
				Help( Nil, Nil, STR0111, Nil, STR0257 + '.', 1, 0, Nil, Nil, Nil, Nil, Nil, { STR0258 + '.' } )

				lRet := .F.

			EndIf

		ElseIf ( FWIsInCallStack( 'Tcfa040' ) .Or. FWIsInCallStack( 'MdtExe' ) )

			//-----------------------------------------------------------------------------
			// Mensagens:
			// "Atenção"
			// "A matrícula da ficha médica é diferente da matrícula informada pelo MeuRh"
			// "Informe uma ficha médica que possua a mesma matrícula"
			//-----------------------------------------------------------------------------
			Help( Nil, Nil, STR0111, Nil, STR0257 + '.', 1, 0, Nil, Nil, Nil, Nil, Nil, { STR0258 + '.' } )

			lRet := .F.

		EndIf

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685MT1
Função responsavel por realizar o gatilho dos campos de Testemunha.

@type function

@source MDTA685.prx

@sample MDT685MT1()

@author Guilherme Freudenburg
@since 14/03/2017

@return cMatTes, Caracter, Matrícula da Testemunha.
/*/
//---------------------------------------------------------------------
Function MDT685MT1()

	Local oModel
	Local oModelTNC
	Local cMatTes

	If IsInCallStack("MDTA410")
		cMatTes := M->TNC_MTEST2
		M->TNC_TESTE1 := SRA->RA_NOME
		M->TNC_ENDTE1 := SRA->RA_ENDEREC
		M->TNC_BAIRR1 := SRA->RA_BAIRRO
		M->TNC_CIDAD1 := SRA->RA_MUNICIP
		M->TNC_CEP1   := SRA->RA_CEP
		M->TNC_ESTAD1 := SRA->RA_ESTADO
		M->TNC_TELEF1 := SRA->RA_TELEFON
		M->TNC_NUEND1 :=  Val(SRA->RA_NUMENDE)
		M->TNC_CIDT1  := SRA->RA_CODMUN
	Else
		oModel 	  := FWModelActive()
		oModelTNC := oModel:GetModel( "TNCMASTER" )
		cMatTes	  := oModelTNC:GetValue( "TNC_MTEST2" )
		oModel:LoadValue( "TNCMASTER" , "TNC_TESTE1"  , SRA->RA_NOME )
		oModel:LoadValue( "TNCMASTER" , "TNC_ENDTE1"  , SRA->RA_ENDEREC )
		oModel:LoadValue( "TNCMASTER" , "TNC_BAIRR1"  , SRA->RA_BAIRRO )
		oModel:LoadValue( "TNCMASTER" , "TNC_CIDAD1"  , SRA->RA_MUNICIP )
		oModel:LoadValue( "TNCMASTER" , "TNC_CEP1"    , SRA->RA_CEP )
		oModel:LoadValue( "TNCMASTER" , "TNC_ESTAD1"  , SRA->RA_ESTADO )
		oModel:LoadValue( "TNCMASTER" , "TNC_TELEF1"  , SRA->RA_TELEFON )
		oModel:LoadValue( "TNCMASTER" , "TNC_NUEND1"  , Val(SRA->RA_NUMENDE) )
		oModel:LoadValue( "TNCMASTER" , "TNC_CIDT1"   , SRA->RA_CODMUN )
	EndIf

Return cMatTes

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685MT2
Função responsavel por realizar o gatilho dos campos de Testemunha.

@type function

@source MDTA685.prx

@sample MDT685MT2()

@author Guilherme Freudenburg
@since 14/03/2017

@return cMatTes, Caracter, Matrícula da Testemunha.
/*/
//---------------------------------------------------------------------
Function MDT685MT2()

	Local oModel
	Local oModelTNC
	Local cMatTes

	If IsInCallStack("MDTA410")
		cMatTes := M->TNC_MTEST1
		M->TNC_TESTE2 := SRA->RA_NOME
		M->TNC_ENDTE2 := SRA->RA_ENDEREC
		M->TNC_BAIRR2 := SRA->RA_BAIRRO
		M->TNC_CIDAD2 := SRA->RA_MUNICIP
		M->TNC_CEP2   := SRA->RA_CEP
		M->TNC_ESTAD2 := SRA->RA_ESTADO
		M->TNC_TELEF2 := SRA->RA_TELEFON
		M->TNC_NUEND1 :=  Val(SRA->RA_NUMENDE)
		M->TNC_CIDT2  := SRA->RA_CODMUN
	Else
		oModel 	  := FWModelActive()
		oModelTNC := oModel:GetModel( "TNCMASTER" )
		cMatTes	  := oModelTNC:GetValue( "TNC_MTEST1" )
		oModel:LoadValue( "TNCMASTER" , "TNC_TESTE2"  , SRA->RA_NOME )
		oModel:LoadValue( "TNCMASTER" , "TNC_ENDTE2"  , SRA->RA_ENDEREC )
		oModel:LoadValue( "TNCMASTER" , "TNC_BAIRR2"  , SRA->RA_BAIRRO )
		oModel:LoadValue( "TNCMASTER" , "TNC_CIDAD2"  , SRA->RA_MUNICIP )
		oModel:LoadValue( "TNCMASTER" , "TNC_CEP2"    , SRA->RA_CEP )
		oModel:LoadValue( "TNCMASTER" , "TNC_ESTAD2"  , SRA->RA_ESTADO )
		oModel:LoadValue( "TNCMASTER" , "TNC_TELEF2"  , SRA->RA_TELEFON )
		oModel:LoadValue( "TNCMASTER" , "TNC_NUEND1"  , Val(SRA->RA_NUMENDE) )
		oModel:LoadValue( "TNCMASTER" , "TNC_CIDT2"   , SRA->RA_CODMUN )
	EndIf

Return cMatTes

//-----------------------------------------------------------------------
/*/{Protheus.doc} MDT685VLDT
Atualiza o campo TNY_QTDIAS (DTFIM - DTINIC)

@type function

@source MDTA685.prx

@author Denis Hyroshi de Souza
@since  01/04/2004

@param nTipo, Numérico, Tipo a interação. ( 1 - DTINIC, 2 - DTFIM )
@param lAtHora, lógico, Se a função é chamada pelo campo de hora fim

@sample MDT685VLDT(1)

@obs Função usada no Dicionário de Dados

@return lRet, Lógico, Caso não encontre nenhum impedimento retorna .T.
/*/
//-----------------------------------------------------------------------
Function MDT685VLDT( nTipo, lAtHora )

	Local lRet 	  	 := .T.
	Local aAreaQry	 := GetArea() //Salva área
	Local oModel
	Local oView

	Default lAtHora  := .F.

	If IsInCallStack("MDTA410")

		If nTipo == 1 .And. !Empty(M->TNY_DTINIC) .And. !Empty(M->TNY_NUMFIC)
			dbSelectArea("TM0")
			dbSetOrder(1)
			If Dbseek(xFilial("TM0")+M->TNY_NUMFIC)
				dbSelectArea("SRA")
				dbSetOrder(1)
				If Dbseek(xFilial("SRA",TM0->TM0_FILFUN)+TM0->TM0_MAT)
					If M->TNY_DTINIC < SRA->RA_ADMISSA
						Help( , , STR0111 , ,  STR0209, 5 , 5 ) //"A data de início do atestado não pode ser menor que a data de admissão do funcionário."###"ATENÇÃO"
						lRet := .F.
					EndIf
				EndIf
			EndIf
		EndIf

		If !Empty(M->TNY_DTFIM) .And. !Empty(M->TNY_DTINIC)

			If lRet
				lRet := MDT685FIM( .T., M->TNY_NATEST, M->TNY_DTFIM )
			EndIf

			If lRet .And. !lAtHora //Caso seja chamado pelo campo de Data (TNY_DTFIM)
				If M->TNY_DTFIM < M->TNY_DTINIC .And. nTipo == 2
					Help( , , STR0111 , , STR0076, 5 , 5 )//"ATENÇÃO"##"Data Fim não pode ser inferior à Data Inicio."
					lRet := .F.
				EndIf

				If lRet .And. !MDT685DtAf( nTipo )
					lRet := .F.
				EndIf

			EndIf

			//Se foi chamado do campo afastamentos
			If lRet .And. lAtHora
				MDTA685DIA() //Atualiza os dias de afastamento de acordo com a grid da TYZ
			EndIf

		EndIf

	Else

		//Ativação do modelo e view
		oModel:= FWModelActive()
		oView := FWViewActive()

		If nTipo == 1 .And. !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ))
			dbSelectArea("TM0")
			dbSetOrder(1)
			If Dbseek(xFilial("TM0")+oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ))
				dbSelectArea("SRA")
				dbSetOrder(1)
				If Dbseek(xFilial("SRA",TM0->TM0_FILFUN)+TM0->TM0_MAT)
					If oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' ) < SRA->RA_ADMISSA
						Help( , , STR0111 , , STR0209 , 5 , 5 )
						//"A data de início do atestado não pode ser menor que a
						//data de admissão do funcionário."###"ATENÇÃO"
						lRet := .F.
					EndIf
				EndIf
			EndIf
		EndIf

		If lRet .And. !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM' )) .And. !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' ))

			If !lAtHora //Caso seja chamado pelo campo de Data

				If oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM' ) < oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' ) .And. nTipo == 2
					Help( , , STR0111 , , STR0076, 5 , 5 )//"ATENÇÃO"##"Data Fim não pode ser inferior à Data Inicio."
					lRet := .F.
				EndIf

				If lRet .And. !MDT685DtAf( nTipo )
					lRet := .F.
				EndIf

			EndIf

			If lRet
				MDTA685DIA()
			EndIf

		EndIf

	EndIf

	RestArea(aAreaQry) // Retorna área

Return lRet

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} MDT685F3CID
Valida o campo Grupo CID

@type function

@source MDTA685.prx

@author Denis Hyroshi de Souza
@since  06/02/2007

@sample MDT685F3CID()

@obs Função usada no Dicionário de Dados

@return lRet, Lógico, Retorna verdadeiro caso grupo CID preenchido corretamente.
/*/
//---------------------------------------------------------------------------------
Function MDT685F3CID()

	Local lRet 	:= .T. //Variavel de Retorno.
	Local oModel

	If IsInCallStack("MDTA410")
		IF !Empty(M->TNY_GRPCID) // Verifica se foi preenchido
			If !ExistCpo("TLG",M->TNY_GRPCID)
				lRet := .F.
			EndIf
			If M->TNY_GRPCID <> Substr( M->TNY_CID, 1 , 3 ) .And. lRet
				M->TNY_CID := Space( Len( M->TNY_CID ) )
				M->TNY_DOENCA := Space( Len( M->TNY_DOENCA ) )
			EndIf
		EndIf
	Else
		oModel:= FWModelActive()  //Ativação do modelo utilizado
		IF !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_GRPCID' )) // Verifica se foi preenchido
			If !ExistCpo("TLG",oModel:GetValue( 'TNYMASTER1', 'TNY_GRPCID' ))
				lRet := .F.
			EndIf
			If oModel:GetValue( 'TNYMASTER1', 'TNY_GRPCID' ) <> Substr( oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ) , 1 , 3 ) .And. lRet
			oModel:LoadValue( 'TNYMASTER1', 'TNY_CID'		, Space( Len( M->TNY_CID 	) ) )
			oModel:LoadValue( 'TNYMASTER1', 'TNY_DOENCA'	, Space( Len( M->TNY_DOENCA ) ) )
			EndIf
		EndIf
	EndIf

Return lRet

//--------------------------------------------------------------------------------------
/*/{Protheus.doc} MDT685CIDP
Validacoes para o C.I.D. principal

@type function

@source MDTA685.prx

@author Taina A. Cardoso
@since 13/04/11

@sample MDT685CIDP( )

@obs Função usada no Dicionário de Dados

@return lRet, Lógico, Retorna verdadeiro caso CID Principal preenchido corretamente.
/*/
//------------------------------------------------------------------------------------
Function MDT685CIDP()

	Local oModel 	:= FWModelActive()  //Copia o Model utilizado.
	Local oGrid 	:= oModel:GetModel( 'TKIDETAIL' )
	Local nLenGrid  := oGrid:Length()   //Quantidade Total de linhas do oGrid.
	Local i 		:= 0
	Local lRet 		:= .T.

	If IsInCallStack("MDTA410")
		If !Empty(M->TNY_GRPCID) .And. M->TNY_GRPCID <> Substr(M->TNY_CID,1,3)  .And. !Empty(M->TNY_CID)
			Help( , , STR0111 , , STR0124 , 5 , 5 )//"ATENÇÃO"###"Informe um CID dentro do Grupo de CID informado."
			lRet := .F.
		EndIf

		If !Empty(M->TNY_CID) .And. lRet
			If!EXISTCPO("TMR",M->TNY_CID)
				lRet := .F.
			EndIf
		EndIf
		If Type("aCols") == "A"
			nLenGrid := Len(aCols)
			If nLenGrid > 0 .And. lRet
				For i := 1 to nLenGrid
					If !aCols[i,Len(aCols[i])] .And.  !Empty(M->TNY_CID)
						If M->TNY_CID == aCols[i][nCid]
							Help( , , STR0111 , , STR0121 + NGRETTITULO( "TNY_CID" ) + STR0122 + NGRETTITULO( "TKI_CID" ) + STR0123 + cValtoChar( i ) + "." , 6 , 6 )//"ATENÇÃO"###"O campo '"##"' não pode ser igual ao campo '"##"', linha "
							lRet := .F.
						EndIf
					EndIf
				Next i
			EndIf
		EndIf
	Else
		If !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_GRPCID' )) .And. oModel:GetValue( 'TNYMASTER1', 'TNY_GRPCID' ) <> Substr(oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ),1,3)  .And. !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ))
			Help( , , STR0111 , , STR0124 , 5 , 5 )//"ATENÇÃO"###"Informe um CID dentro do Grupo de CID informado."
			lRet := .F.
		EndIf

		If !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_CID' )) .And. lRet
			If!EXISTCPO("TMR",oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ))
				lRet := .F.
			EndIf
		EndIf

		If nLenGrid > 0 .And. lRet
			For i := 1 to nLenGrid
				oGrid:GoLine( i )
				If !( oGrid:IsDeleted() ) .And.  !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ))
					If oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ) == oGrid:GetValue( "TKI_CID" )
						Help( , , STR0111 , , STR0121 + NGRETTITULO( "TNY_CID" ) + STR0122 + NGRETTITULO( "TKI_CID" ) + STR0123 + cValtoChar( i ) + "." , 6 , 6 )//"ATENÇÃO"###"O campo '"##"' não pode ser igual ao campo '"##"', linha "
						lRet := .F.
					EndIf
				EndIf
			Next i
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685DtAf
Função para validação das datas do afastamento.

@param nCpoTNY Numérico Indica o campo a ser feito a verificação.

@author Guilherme Benekendorf
@since 29/10/2014
@version P11/P12
@return lRet Boolean Indica se há erro nas datas
/*/
//---------------------------------------------------------------------
Function MDT685DtAf( nCpoTNY )

	Local lRet     := .T.
	Local cCpoName := ""
	Local dDtAux   := ""
	Local oModel

	//Salva área.
	Local aAreaSRA := SRA->( GetArea() )
	Local aAreaTNY := TNY->( GetArea() )
	Local aArea    := GetArea()

	If IsInCallStack("MDTA685")
		oModel   := FWModelActive()  //Ativação do modelo utilizado

		dbSelectArea("TM0")
		dbSetOrder(1)
		dbSeek(xFilial("TM0")+oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ))
		dbSelectArea("SRA")
		dbSetOrder(1)

		If dbSeek(xFilial("SRA",TM0->TM0_FILFUN)+TM0->TM0_MAT) .And. !Empty( SRA->RA_DEMISSA )

			Do Case
				Case nCpoTNY == 1 .And. !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' ) )//Data Inicio Afastamento
					dDtAux   := oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' )
					cCpoName := NGRETTITULO("TNY_DTINIC")
				Case nCpoTNY == 2 .And. !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM' ) )//Data Final  Afastamento
					dDtAux   := oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM' )
					cCpoName := NGRETTITULO("TNY_DTFIM")
				Case nCpoTNY == 9 .And. !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_DTCONS' ) )//Data da Consulta
					dDtAux   := oModel:GetValue( 'TNYMASTER1', 'TNY_DTCONS' )
					cCpoName := NGRETTITULO("TNY_DTCONS")
			End Case

			If !Empty( dDtAux ) .And. dDtAux > SRA->RA_DEMISSA
				Help( , , STR0112 , ,  STR0174 + CRLF + STR0121 + cCpoName+ ":" + CRLF + STR0175  , 6 , 6 )//"AVISO"##"Funcionário encontra-se demitido. O preenchimento das datas não poderá ser posterior a data de demissão."
				lRet := .F.																							//"Informe a data anterior a data de demissão do funcionário."
			EndIf

		EndIf

	ElseIf IsInCallStack("MDTA410")
		dbSelectArea("TM0")
		dbSetOrder(1)
		dbSeek(xFilial("TM0")+M->TNY_NUMFIC)
		dbSelectArea("SRA")
		dbSetOrder(1)

		If dbSeek(xFilial("SRA",TM0->TM0_FILFUN)+TM0->TM0_MAT) .And. !Empty( SRA->RA_DEMISSA )
			Do Case
				Case nCpoTNY == 1 .And. !Empty( M->TNY_DTINIC )//Data Inicio Afastamento
					dDtAux := M->TNY_DTINIC
					cCpoName := NGRETTITULO("TNY_DTINIC")
				Case nCpoTNY == 2 .And. !Empty( M->TNY_DTFIM )//Data Final  Afastamento
					dDtAux := M->TNY_DTFIM
					cCpoName := NGRETTITULO("TNY_DTFIM")
				Case nCpoTNY == 3 .And. !Empty( M->TNY_DTSAID )//Dt.Saida A.D
					dDtAux := M->TNY_DTSAID
					cCpoName := NGRETTITULO("TNY_DTSAID")
				Case nCpoTNY == 4 .And. !Empty( M->TNY_DTALTA )//Dt.Alta A.D
					dDtAux := M->TNY_DTALTA
					cCpoName := NGRETTITULO("TNY_DTALTA")
				Case nCpoTNY == 5 .And. !Empty( M->TNY_DTSAI2 )//Dt.Saida A.D
					dDtAux := M->TNY_DTSAI2
					cCpoName := NGRETTITULO("TNY_DTSAI2")
				Case nCpoTNY == 6 .And. !Empty( M->TNY_DTALT2 )//Dt.Alta A.D
					dDtAux := M->TNY_DTALT2
					cCpoName := NGRETTITULO("TNY_DTALT2")
				Case nCpoTNY == 7 .And. !Empty( M->TNY_DTSAI3 )//Dt.Saida A.D
					dDtAux := M->TNY_DTSAI3
					cCpoName := NGRETTITULO("TNY_DTSAI3")
				Case nCpoTNY == 8 .And. !Empty( M->TNY_DTALT3 )//Dt.Alta A.D
					dDtAux := M->TNY_DTALT3
					cCpoName := NGRETTITULO("TNY_DTALT3")
				Case nCpoTNY == 9 .And. !Empty( M->TNY_DTCONS )//Data da Consulta
 					dDtAux := M->TNY_DTCONS
 					cCpoName := NGRETTITULO("TNY_DTCONS")
			End Case

			If !Empty( dDtAux ) .And. dDtAux > SRA->RA_DEMISSA
				Help( , , STR0112 , ,  STR0174 + CRLF + STR0121 + cCpoName+ ":" + CRLF + STR0175  , 6 , 6 )//"AVISO"##"Funcionário encontra-se demitido. O preenchimento das datas não poderá ser posterior a data de demissão."
				lRet := .F.																							//"Informe a data anterior a data de demissão do funcionário."
			EndIf
		EndIf
	EndIf

	If lRet
		MDTA685DIA()
	EndIf

	//Retorna área salva.
	RestArea( aAreaSRA )
	RestArea( aAreaTNY )
	RestArea( aArea )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MT685VLDOC
Função para valid do campo TNY_OCORRE, se a ocorrencia for 1,5 ou 6
limpa campo TNY_ACIDEN e TNY_DESACI

@obs Função usada no Dicionário de Dados

@author Felipe Helio dos Santos
@since 31/01/2013
/*/
//---------------------------------------------------------------------
Function MT685VLDOC()

Local oModel := FWModelActive() //Ativação do modelo utilizado

		If IsInCallStack("MDTA410")

			If oModel:Cid != "MDT685"

				oModel := FWLoadModel("MDTA685")

				If !oModel:isActive()
					oModel:Activate()
				EndIf
				
			EndIf
			
			If	M->TNY_OCORRE $ "1/5/6" .Or. Empty(M->TNY_OCORRE)
				M->TNY_ACIDEN := Space(Len(oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) ) )
				M->TNY_DESACI := Space(Len(oModel:GetValue( 'TNYMASTER1', 'TNY_DESACI' ) ) )
			EndIf
		Else
			If	oModel:GetValue( 'TNYMASTER1', 'TNY_OCORRE' ) $ "1/5/6" .Or. Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_OCORRE' ))
				oModel:LoadValue( 'TNYMASTER1', 'TNY_ACIDEN', Space(Len(oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) ) ) )
				oModel:LoadValue( 'TNYMASTER1', 'TNY_DESACI', Space(Len(oModel:GetValue( 'TNYMASTER1', 'TNY_DESACI' ) ) ) )
			EndIf
		EndIf

Return .T.

//----------------------------------------------------------------------------
/*/{Protheus.doc} MDT685ACI
Tras da tabela TNC a Qtd de dias afastados

@type function

@source MDTA685.prx

@author Andre E. Perez Alvarez
@since  06/08/08

@sample MDT685ACI()

@obs Função usada no Dicionário de Dados

@return lRet, Lógico, Retorna verdadeiro quando não encontrar inconsistencia.
/*/
//----------------------------------------------------------------------------
Function MDT685ACI()

	Local aArea		:= GetArea() //Salva área
	Local lRet 	 	:= .T.
	Local lExecAuto	:= IsBlind() .Or. !( AllTrim( FunName() ) $ 'MDTA685/MDTA410/MDTA110F/MDTA686/TCFA040' )
	Local oModel

	If IsInCallStack("MDTA410")
		If !Empty(M->TNY_ACIDEN)
			Dbselectarea("TNC")
			Dbsetorder(1)
			If Dbseek( xFilial("TNC") + M->TNY_ACIDEN )
				If !Empty( TNC->TNC_CID ) .And. M->TNY_CID <> TNC->TNC_CID
					If MsgYesNo( STR0183 + AllTrim( M->TNY_ACIDEN ) + ;//"O Acidente "
						STR0184 + AllTrim( TNC->TNC_CID ) + STR0185 )//" possui o CID "//", deseja incluir o mesmo CID no Atestado?"
						M->TNY_CID := TNC->TNC_CID
						M->TNY_DOENCA := SubSTR(NGSeek( "TMR" , TNC->TNC_CID, 1 , "TMR_DOENCA" ),1,80)
						M->TNY_GRPCID := TNC->TNC_GRPCID
						M->TNY_DESGRP := SubSTR(NGSeek( "TLG" , TNC->TNC_GRPCID, 1 , "TLG_DESCRI" ),1,80)
					EndIf
				EndIf
			EndIf

			If !NG685CID()
				lRet := .F.
			EndIf

			If lRet .And. !Empty( M->TNY_ACIDEN ) .And. !EXISTCHAV( "TNY" , M->TNY_ACIDEN , 5 )
				lRet := .F.
			EndIf

			Dbselectarea("TNC")
			Dbsetorder(1)
			If lRet
				If Dbseek(xFilial("TNC")+M->TNY_ACIDEN )
					M->TNY_QTDIAS := TNC->TNC_QTAFAS
					M->TNY_DESACI := SubStr(TNC->TNC_DESACI,1,40)
				Else
					M->TNY_DESACI := Space(Len(oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) ) )
				EndIf
			EndIf
		EndIf
	Else
		oModel := FWModelActive()  //Ativação do modelo utilizado
		Dbselectarea("TNC")
		Dbsetorder(1)
		If Dbseek( xFilial("TNC") + oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) )
			If !Empty( TNC->TNC_CID ) .And. oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ) <> TNC->TNC_CID
				If lExecAuto .Or. MsgYesNo( STR0183 + AllTrim( oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) ) + ;//"O Acidente "
					STR0184 + AllTrim( TNC->TNC_CID ) + STR0185 )//" possui o CID "//", deseja incluir o mesmo CID no Atestado?"
					oModel:LoadValue( 'TNYMASTER1', 'TNY_CID'	 , TNC->TNC_CID )
					oModel:LoadValue( 'TNYMASTER1', 'TNY_DOENCA' , SubSTR(NGSeek( "TMR" , TNC->TNC_CID, 1 , "TMR_DOENCA" ),1,80) )
					oModel:LoadValue( 'TNYMASTER1', 'TNY_GRPCID' , TNC->TNC_GRPCID )
					oModel:LoadValue( 'TNYMASTER1', 'TNY_DESGRP' , SubSTR(NGSeek( "TLG" , TNC->TNC_GRPCID, 1 , "TLG_DESCRI" ),1,80) )
				EndIf
			EndIf
		EndIf

		If !NG685CID()
			lRet := .F.
		EndIf

		If lRet .And. !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) ) .And. !EXISTCHAV( "TNY" , oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) , 5 )
			lRet := .F.
		EndIf

		Dbselectarea("TNC")
		Dbsetorder(1)
		If lRet
			If Dbseek(xFilial("TNC")+oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) )
				oModel:LoadValue( 'TNYMASTER1', 'TNY_QTDIAS', TNC->TNC_QTAFAS )
				oModel:LoadValue( 'TNYMASTER1', 'TNY_DESACI', SubStr(TNC->TNC_DESACI,1,40) )
			Else
				oModel:LoadValue( 'TNYMASTER1', 'TNY_DESACI', Space(Len(oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) ) ) )
			EndIf
		EndIf
	EndIf

	RestArea(aArea) //Retorna área salva

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTRelacTNY
Trás descrição do Afastamento.

@type function

@source MDTA685.prx

@author Guilherme Benekendorf
@since 06/01/2014

@param nOption, Caracter, Tipo de opção.

@sample MDTRelacTNY( '1' )

@obs Função usada no Dicionário de Dados

@return cDescri, Caracter , Descrição do tipo de afastamento.
/*/
//---------------------------------------------------------------------
Function MDTRelacTNY( nOption )

	Local cDescri := ""
	Local oModel
	Local aArea := GetArea()

	If IsInCallStack( "MDTA410" ) .Or. ( aArea [ 1 ] != "TNY" .And. IsInCallStack( "MDTA110" ) )
		Do Case
			Case nOption == 1 //TNY_DESCAD
			If !INCLUI
				If !Empty( M->TNY_TIPAFA )
					cDescri := FDESC( "SX5", "30" + TNY->TNY_TIPAFA, "X5_DESCRI", 30 )
				ElseIf !Empty( M->TNY_CODAFA )
					cDescri := SubStr( Posicione( "RCM", 1, xFilial( "RCM" ) + M->TNY_CODAFA, "RCM->RCM_DESCRI" ), 1, 30 )
				EndIf
			EndIf
		End Case
	Else
		oModel := FWModelActive() //Ativação do modelo utilizado
		Do Case
			Case nOption == 1 //TNY_DESCAD
			If !INCLUI
				If !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_TIPAFA' ) )
					cDescri := FDESC( "SX5", "30" + TNY->TNY_TIPAFA, "X5_DESCRI", 30 )
				ElseIf !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' ) )
					cDescri := SubStr( Posicione( "RCM", 1, xFilial( "RCM" ) + oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' ), "RCM->RCM_DESCRI" ), 1, 30 )
				EndIf
			EndIf
		End Case

		If IsInCallStack( "MDT685CONT" ) //Caso seja chamado pela ocorrencias da ficha, preenche o campo de Ficha Médica e Nome.
			oModel:LoadValue( "TNYMASTER1", "TNY_NUMFIC", TNY->TNY_NUMFIC  )
			oModel:LoadValue( "TNYMASTER1", "TNY_NOMFIC", Posicione( "TM0", 1, xFilial( "TM0" ) + TNY->TNY_NUMFIC, "TM0_NOMFIC" ) )
			oModel:LoadValue( "TNYMASTER1", "TNY_ATEANT", TNY->TNY_NATEST )
			oModel:LoadValue( "TNYMASTER1", "TNY_NATEST", GETSXENUM( "TNY", "TNY_NATEST", , 2 ) )
		ElseIf IsInCallStack( "MDTA110" ) //Caso seja chamado pela Ocorrência Ficha.
			If oModel:GetOperation() <> 5 //Caso não seja exclusão.
				oModel:LoadValue( "TNYMASTER1", "TNY_NUMFIC", sNUMFIC )
				oModel:LoadValue( "TNYMASTER1", "TNY_NOMFIC", Posicione( "TM0", 1, xFilial( "TM0" ) + sNUMFIC, "TM0_NOMFIC" ) )
			EndIf
		EndIf
	EndIf

	RestArea( aArea )

Return cDescri //Retorna a Descrição do Afastamento.

//---------------------------------------------------------------------
/*/{Protheus.doc} WhenTNYCID
Troca F3 do campo CID

@type function

@source MDTA685.prx

@author Denis Hyroshi de Souza
@since  06/02/2007

@sample WhenTNYCID()

@obs Função usada no Dicionário de Dados

@return Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
Function WhenTNYCID()

	Local oModel

	aTROCAF3 := {}

	If IsInCallStack("MDTA410")
		IF !Empty(M->TNY_GRPCID)
			AADD(aTROCAF3,{"TNY_CID","TMR4"})
		Else
			AADD(aTROCAF3,{"TNY_CID","TMR"})
		EndIf
	Else
		oModel := FWModelActive()  //Ativação do modelo utilizado
		IF !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_GRPCID' ))
			AADD(aTROCAF3,{"TNY_CID","TMR4"})
		Else
			AADD(aTROCAF3,{"TNY_CID","TMR"})
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685BRW
Função que retorna o nome do Funcionário para o Browse.

@obs Função usada no Dicionário de Dados

@author Rodrigo Soledade
@since 01/10/2013
/*/
//---------------------------------------------------------------------
Function MDT685BRW( nRet )

	Local cNomefunc	:= ""
	Local aAreaTNY	:= TNY->( GetArea() ) //Salva área posicionada

	If nRet == 1 //TNY_NOMFIC
		dbSelectArea( "TM0" )
		dbSetOrder( 1 )
		If dbSeek( xFilial( "TM0" , TNY->TNY_FILIAL ) + TNY->TNY_NUMFIC )
			cNomefunc := TM0->TM0_NOMFIC
		EndIf
	ElseIf nRet == 2 //TNY_NOMUSU
		dbSelectArea( "TNP" )
		dbSetOrder( 1 )
		If dbSeek( xFilial( "TNP" , TNY->TNY_FILIAL ) + TNY->TNY_EMITEN )
			cNomefunc := TNP->TNP_NOME
		EndIf
	EndIf

	//Retorna área
	RestArea(aAreaTNY)

Return cNomefunc

//-----------------------------------------------------------------------------
/*/{Protheus.doc} NG685CID
Verifica antes de confirmar a tela de inclusao

@type function

@source MDTA685.prx

@author Andre E. Perez Alvarez
@since  06/08/2008

@sample NG685CID()

@return lRet, Lógico, Retorna verdadeiro quando não encontrar inconsistencia.
/*/
//-----------------------------------------------------------------------------
Function NG685CID()

	Local aArea := GetArea() //Salva área posicionada
	Local lRet  := .T.
	Local oModel:= FWModelActive()  //Ativação do modelo utilizado

	If !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) ) .And. oModel:GetValue( 'TNYMASTER1', 'TNY_OCORRE' ) $ "2/3/4"
		Dbselectarea( "TNC" )
		Dbsetorder( 1 )
		If Dbseek( xFilial( "TNC" ) + oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) )
			If !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ) ) .And. !Empty( TNC->TNC_CID ) .And. oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ) != TNC->TNC_CID
				oModel:LoadValue( 'TNYMASTER1', 'TNY_ACIDEN', Space( Len( oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) ) ) )
				//"ATENÇÃO" ## "O conteúdo do campo 'CID Principal' não está de acordo com o CID informado no "
				//"cadastro de Acidentes."###"CID Principal: "
				//"CID do Acidente: "###
				Help( , , STR0153 , , STR0149 + STR0150+Chr(13)+Chr(13)+STR0151+oModel:GetValue( 'TNYMASTER1', 'TNY_CID' )+Chr(13)+ STR0152 + TNC->TNC_CID , 6 , 6 )
				lRet := .F.
			EndIf
		EndIf
		If oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ) <> TNC->TNC_NUMFIC
			Help( , , STR0111 , , STR0108, 6 , 6 )//ATENÇÃO##"O número da ficha médica do atestado não está igual ao número da ficha médica informada no acidente."
			oModel:LoadValue( 'TNYMASTER1', 'TNY_ACIDEN', Space(Len(oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ))) )
			lRet := .F.
		EndIf
	EndIf
	//Retorna área salva
	RestArea(aArea)
Return lRet

//-----------------------------------------------------------------------
/*/{Protheus.doc} MDT685DAT
Responsavel por validar a Dt. Saída e Dt. Alta.
@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since 01/03/2017

@param nNumCamp , Numérico , Determina o campo que está sendo validado.

@sample MDT685DAT()

@return Lógico, Retorna verdadeiro casa a data estava válida.
/*/
//-----------------------------------------------------------------------
Function MDT685DAT(nNumCamp)

	Local lRet	 := .T.
	Local oModel
	Local oGrid
	Local aAreaAtu := GetArea()
	Local aAreaTM0 := TM0->( GetArea() )
	Local aAreaSRA := SRA->( GetArea() )

	Default nNumCamp := 0

	If !IsInCallStack("MDTA410")

		oModel := FWModelActive()  //Copia o Model utilizado.
		oGrid  := oModel:GetModel( 'TYZDETAIL' ) //Posiciona no Model da Grid

		dbSelectArea("TM0")
		dbSetOrder(1)//TM0_FILIAL+TM0_NUMFIC
		dbSeek(xFilial("TM0")+oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ))
		dbSelectArea("SRA")
		dbSetOrder(1)//RA_FILIAL+RA_MAT
		dbSeek(xFilial("SRA",TM0->TM0_FILFUN)+TM0->TM0_MAT)

		If !Empty( oGrid:GetValue( "TYZ_DTSAID" ) ) .And.  !Empty( oGrid:GetValue( "TYZ_DTALTA" ) ) .And. ;
			oGrid:GetValue( "TYZ_DTSAID" ) > oGrid:GetValue( "TYZ_DTALTA" )
			lRet := .F.
			If nNumCamp == 1
				Help( , , STR0111 , , STR0193, 5 , 5 )//ATENÇÃO##"A Dt. Saída é maior que a Dt. Alta. Favor informar uma Dt. Saída inferior a Dt. Alta."
			ElseIf nNumCamp == 2
				Help( , , STR0111 , , STR0194, 5 , 5 )//ATENÇÃO##""A Dt. Saída é maior que a Dt. Alta. Favor informar uma Dt. Alta superior a Dt. Saída."
			EndIf
		EndIf

		If !Empty( oGrid:GetValue( "TYZ_DTALTA" ) ) .And. oGrid:GetValue( "TYZ_DTALTA" ) > SRA->RA_DEMISSA .And. lRet  .And. !Empty(SRA->RA_DEMISSA)
			Help( , , STR0112 , , STR0174 + CRLF + STR0121 + NGRETTITULO("TYZ_DTALTA")+ ":" + CRLF + STR0175, 5 , 5 )//"AVISO"//"Funcionário encontra-se demitido. O preenchimento das datas não poderá ser posterior a data de demissão."
			lRet := .F.																			   			//"Informe a data anterior a data de demissão do funcionário."
		EndIf

	Else
		dbSelectArea("TM0")
		dbSetOrder(1)//TM0_FILIAL+TM0_NUMFIC
		dbSeek(xFilial("TM0")+M->TNY_NUMFIC)
		dbSelectArea("SRA")
		dbSetOrder(1)//RA_FILIAL+RA_MAT
		dbSeek(xFilial("SRA",TM0->TM0_FILFUN)+TM0->TM0_MAT)

		If !Empty( aCols[n,3] ) .And. aCols[n,3] > SRA->RA_DEMISSA .And. lRet  .And. !Empty(SRA->RA_DEMISSA)
			Help( , , STR0112 , , STR0174 + CRLF + STR0121 + NGRETTITULO("TYZ_DTALTA")+ ":" + CRLF + STR0175, 5 , 5 )//"AVISO"//"Funcionário encontra-se demitido. O preenchimento das datas não poderá ser posterior a data de demissão."
			lRet := .F.																			   			//"Informe a data anterior a data de demissão do funcionário."
		EndIf

	EndIf
	RestArea( aAreaTM0 )
	RestArea( aAreaSRA )
	RestArea( aAreaAtu )

	If lRet
		MDTA685DIA()
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685TUDOK
Valida a todo conteudo da getdados.

@type function

@source MDTA685.prx

@param lFim , Lógico , Determina se é TudoOk ou LinOk

@author Taina A. Cardoso
@since 13/04/11

@sample MDT685TUDOK( .T. )

@return lRet , Lógico , Verifica inconsistencias.
/*/
//---------------------------------------------------------------------
Function MDT685TUDOK( oModel , lFim )

	//Variais utilizadas no Model
	Local oGrid 	:= oModel:GetModel( 'TKIDETAIL' ) //Posiciona no Model da Grid
	Local nLinAtual := oGrid:GetLine()  //Linha Atual.
	Local nLenGrid  := oGrid:Length()   //Quantidade Total de linhas do oGrid.
	Local cCidAtual := oGrid:GetValue( "TKI_CID" )
	Local cGrupoCid := oGrid:GetValue( "TKI_GRPCID" )
	Local lDelet    := !( oGrid:IsDeleted() ) //Caso não seja deletado
	Local nLin		:= 0
	Local lRet 		:= .T.

	Default lFim := .F.

	If Empty(cCidAtual)
		cCidAtual := oGrid:GetValue( "TKI_CID" )
	ElseIf Empty(cGrupoCid)
		cGrupoCid := oGrid:GetValue( "TKI_GRPCID" )
	EndIf

	For nLin := 1 to nLenGrid
		oGrid:GoLine( nLin )
		If lFim
			If !( oGrid:IsDeleted() )
				//VerIfica se os campos obrigatórios estão preenchidos
				If  nLin <> 1 .And. Empty(cGrupoCid) .And. Empty(cCidAtual)
					//Mostra mensagem de Help
					Help(1," ","OBRIGAT2",,oGrid:GetIdField( "TKI_CID" ))
					lRet := .F.
				EndIf

				// Verifica se deixou algum campo vazio.
				If Empty(oGrid:GetValue( "TKI_GRPCID" )) .And. lRet
					Help(1," ","OBRIGAT2",,oGrid:GetValue( "TKI_GRPCID" ))
					lRet := .F.
				ElseIf Empty(oGrid:GetValue( "TKI_CID" )) .And. lRet
					Help(1," ","OBRIGAT2",,oGrid:GetIdField( "TKI_CID" ))
					lRet := .F.
				EndIf

				If !Empty(oGrid:GetValue( "TKI_GRPCID" ) ) .And. lRet
					If oGrid:GetValue( "TKI_GRPCID" ) == oModel:GetValue( 'TNYMASTER1', 'TNY_GRPCID' ) .And. (Empty(oGrid:GetValue( "TKI_CID" )) .Or. Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ))) .And. lDelet
						Help( , , STR0111 , , STR0121+NGRETTITULO("TKJ_CID")+STR0125 , 5 , 5 )//"ATENÇÃO"###"o campo" ## "deve ser preenchido quando já existir outro CID do mesmo grupo."
						lRet := .F.
					EndIf
				EndIf
				If nLin <> nLinAtual .And. lDelet .And. lRet
					If oGrid:GetValue( "TKI_CID" ) == cCidAtual .And. !Empty(oGrid:GetValue( "TKI_CID" ))
						Help( , , STR0111 , , STR0121+NGRETTITULO("TKJ_CID")+STR0122+cValtoChar(nLin)+"." , 5 , 5 )//"ATENÇÃO"###"O campo '"##"' ja foi informado na linha "
						lRet := .F.
					EndIf
					If !Empty(oGrid:GetValue( "TKI_GRPCID" )) .And. lRet
						If oGrid:GetValue( "TKI_GRPCID" ) == cGrupoCid	.And. Empty(cGrupoCid)
							Help( , , STR0111 , , STR0121+NGRETTITULO("TKJ_CID")+STR0125 , 5 , 5 )//"ATENÇÃO"###"o campo" ## "deve ser preenchido quando já existir outro CID do mesmo grupo."
							lRet := .F.
						EndIf
					EndIf
				EndIf
			EndIf
		Else
			If ( Empty(oGrid:GetValue( "TKI_GRPCID" )) .Or. Empty(oGrid:GetValue( "TKI_CID" )) ) .And. !( oGrid:IsDeleted() ) .And. nLin <> nLinAtual .And. lRet
				//MsgStop(STR0127) //"Informe um Grupo de CID ou um CID ."
				Help( , , STR0111 , , STR0127 , 5 , 5 )//"ATENÇÃO"###"Informe um Grupo de CID ou um CID ."
				lRet := .F.
			EndIf
			If nLin <> nLinAtual .And. lDelet .And. !( oGrid:IsDeleted() ) .And. lRet
				If oGrid:GetValue( "TKI_CID" ) == cCidAtual .And. !Empty(oGrid:GetValue( "TKI_CID" ))
					//MsgStop(STR0121+NGRETTITULO("TKJ_CID")+STR0122+cValtoChar(f)+".") //"O campo '"##"' ja foi informado na linha "
					Help( , , STR0111 , , STR0121+NGRETTITULO("TKI_CID")+STR0122+cValtoChar(nLin)+"." , 5 , 5 )//"ATENÇÃO"###"O campo '"##"' ja foi informado na linha "
					lRet := .F.
				EndIf
			EndIf
		EndIf
		If !lRet
			EXIT
		EndIf
	Next nLin

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fMontaArSR8
Função auxiliar para montar array da SR8, onde sempre inicia com
Filial/Matricula/Tipo Afastamento
@type function

@author Guilherme Benekendorf
@since 06/01/2014

@param cTipoAfast, Caractere, Nome do campo de tipo do afastamento

@return aAuxSR8, Array, Para auxiliar na pesquisa do registro SR8
/*/
//---------------------------------------------------------------------
Static Function fMontaArSR8( cTipoAfast )
Return { { "R8_FILIAL" , SRA->RA_FILIAL } , { "R8_MAT" , SRA->RA_MAT } , { "R8_TIPO" , cTipoAfast } }

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} MDT685POS
Função Pós-valide do Modelo de Dados.

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since  01/03/2016

@sample MDT685POS( oModel )

@return lRet, Lógico, Retorna verdadeiro caso não ocorra nenhuma inconsistência no oModel
/*/
//----------------------------------------------------------------------------------------------
Function MDT685POS(oModel,nOpc410)

	Local aAreaTNY 	 := TNY->( GetArea() ) //Salva área posicionada
	Local aAreaATS   := {}
	Local lRet 	 	 := .T.
	Local nY 		 := 0
	Local dDataFecha
	Local cTipAfas := 'IIf( Empty( M->TNY_CODAFA ), M->TNY_TIPAFA, M->TNY_CODAFA )'
	Local aOldTNY 	 := MDT685TNYA()
	//Utilização do Modelo e Grid.
	Local oGrid
	Local nLenGrid   := 0
	Local nOpcx 	 := oModel:GetOperation() // Opção utilizada no Modelo.
	Local nW 		 := 0
	Local nX		 := 0

	//Verificação de Parâmetros
	Local lRetUsu 	 := SuperGetMV( "MV_NG2SEG" , .F. , "2" ) == "1"
	Local nDiasTotAf := SuperGetMv( "MV_NG2TOAF" , .F. , 15 )//"Indica a quantidade de dias que a empresa deverá ""pagar, referente ao afastamentos do trabalho. "
	Local cAfast 	 := Alltrim(GETMV("MV_NG2AFAS"))
	Local aCpsVir    := { "TNY_NOMFIC", "TNY_DESGRP", "TNY_DOENCA", "TNY_NOMUSU", "TNY_NOMUSU",;
				 	   "TNY_NOMUSU", "TNY_ESPDES", "TNY_ABODES", "TNY_DESCAD", "TNY_DESACI",;
				   	   "TNY_ATEANT", "TNY_USERGI", "TNY_TPEFD" }
	Local aParam     := {}

	Private lInt_AfaGpe := SuperGetMv( "MV_NGMDTAF" , .F. , "N" ) == "S"
	Private lInt_PonGpe := MDT685VPON( lInt_AfaGpe )
	Private APERATUAL   := {}
	Private CPROCESSO   := ""

	Default nOpc410 := 0

	If !IsInCallStack("MDTA410")
		oGrid 	 := oModel:GetModel( 'TYZDETAIL' ) //Posiciona no Model da Grid
		nLenGrid := oGrid:Length()
	EndIf

	If IsInCallStack("MDTA410")
		nOpcx := nOpc410

		If oModel:cSource <> "MDTA685" //Caso seja um modelo diferente do Atestado Médico.
			oModel  := FWLoadModel( "MDTA685" )
			oModel:Activate()
		EndIf

		If nOpcx == 4

			aCpsVir := { "TNY_NOMFIC", "TNY_DESGRP", "TNY_DOENCA", "TNY_NOMUSU", "TNY_NOMUSU",;
						"TNY_NOMUSU", "TNY_ESPDES", "TNY_ABODES", "TNY_DESCAD", "TNY_DESACI",;
						"TNY_ATEANT", "TNY_USERGI", "TNY_DTSAID", "TNY_DTALTA", "TNY_DTSAI2",;
						"TNY_DTALT2", "TNY_DTSAI3", "TNY_DTALT3", "TNY_TPEFD"  }

			For nX := 1 To TNY->(FCount())
				If aScan( aCpsVir , { | x | TNY->(FieldName( nX )) == x }  ) == 0
					If TNY->(FieldName( nX )) == "TNY_HRINIC"
						oModel:LoadValue( "TNYMASTER1", TNY->(FieldName( nX ) )  , SubStr(M->( &( TNY->(FieldName( nX ) ) ) ),1,5)  )
					Else
						oModel:LoadValue( "TNYMASTER1", TNY->(FieldName( nX ) )  , M->( &( TNY->(FieldName( nX ) ) ) )  )
					EndIf
				EndIf
			Next nX
		EndIf

	EndIf

	If nOpcx == MODEL_OPERATION_UPDATE .Or. nOpcx == MODEL_OPERATION_DELETE //Caso seja Alteração ou Exclusão.
		dbSelectArea( "TNP" )
		dbSetOrder( 1 )
		dbSeek( xFilial( "TNP" ) + TNY->TNY_EMITEN )
		If lRetUsu .And. AllTrim( cUserName ) <> AllTrim( MDTDATALO( "TNY->TNY_USERGI" , .F. ) ) .And. ;
			AllTrim( MDTDATALO( "TNY->TNY_USERGI" , .F. ) ) <> AllTrim( cUserName ) .And. AllTrim( cUserName ) <> AllTrim( TNP->TNP_USUARI ) .And.;
			AllTrim( TNP->TNP_USUARI ) <> AllTrim( cUserName )
			ShowHelpDlg("SEMPERM", {STR0139} , 2 , ;//"Usuário sem permissão para alterar o registro."
			{STR0140} , 2 )//"Acesse o sistema com o usuário de inclusão/alteração do registro."
			lRet := .F.
		EndIf
	EndIf

	If ( nOpcx == MODEL_OPERATION_UPDATE .Or. nOpcx == MODEL_OPERATION_DELETE ) .And. !IsInCallStack( 'MDTA410' )

		lRet := fTemConti( oModel, oGrid, nOpcx == MODEL_OPERATION_DELETE )

	EndIf

	If ( nOpcx == MODEL_OPERATION_INSERT .Or. nOpcx == MODEL_OPERATION_UPDATE ) .And. lRet
		If Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ))
			If oModel:GetValue( 'TNYMASTER1', 'TNY_OCORRE' ) $ "2"  .And. !MsgYesNo(STR0141)//"O Atendimento foi referente a Doença do Trabalho e o campo de acidente não foi preenchido. Deseja mesmo continuar?"
				lRet := .F.
			EndIf
			If oModel:GetValue( 'TNYMASTER1', 'TNY_OCORRE' ) $ "3" .And. !MsgYesNo(STR0142)//"O Atendimento foi referente a Acidente Típico e o campo de acidente não foi preenchido. Deseja mesmo continuar?"
				lRet := .F.
			EndIf
			If oModel:GetValue( 'TNYMASTER1', 'TNY_OCORRE' ) $ "4" .And. !MsgYesNo(STR0143)//"O Atendimento foi referente a Acidente Trajeto e o campo de acidente não foi preenchido. Deseja mesmo continuar?"
				lRet := .F.
			EndIf
		EndIf
	EndIf

	If ( nOpcx == MODEL_OPERATION_UPDATE .Or. nOpcx == MODEL_OPERATION_INSERT ) .And. !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' ) ) .And. !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_HRINIC' ) ) .And. !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ) ) .And. lRet
		nRecTNY_ := If( nOpcx == MODEL_OPERATION_INSERT , 0 , TNY->( Recno() ) )
		aAreaATS := TNY->(GetArea())
		_DataIni := oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC'  )
		_HoraIni := oModel:GetValue( 'TNYMASTER1', 'TNY_HRINIC'  )
		_DataFim := oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM'   )
		_HoraFim := oModel:GetValue( 'TNYMASTER1', 'TNY_HRFIM'   )
		_CodAfas := oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA'  )
		_cTipAfas := oModel:GetValue( 'TNYMASTER1', 'TNY_TIPAFA' )
		lProDFim := .F.
		lProHFim := .F.

		If Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM') )
			_DataFim := dDataBase + 5000
			lProDFim := .T.
		EndIf
		If Alltrim(oModel:GetValue( 'TNYMASTER1', 'TNY_HRFIM')) == ":"
			_HoraFim := "23:59"
			lProHFim := .T.
		EndIf
		lDuplic_ := .F.
		cMsgTNY := ""

		If lRet
			lRet := fVerificaDatas( oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC'), oModel )
		EndIf

		RestArea(aAreaATS) //Retorna área

		If !Empty(cMsgTNY)
			Help( , , STR0111 , , cMsgTNY , 5 , 5 )
			lRet := .F.
		EndIf
	EndIf

	If !FwIsInCallStack( 'MDTA410' )
		If ((nOpcx == MODEL_OPERATION_UPDATE .And. oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ) <> aOldTNY[1,_CID_]) .Or. nOpcx == MODEL_OPERATION_INSERT) .And. !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_CID' )) .And. lRet
			cCodCnae := ""
			cCodCnae := SM0->M0_CNAE
			If !Empty(cCodCnae)
				If MDT82NEXO(oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ) , cCodCnae , 2 )
					lRet := .F.
				EndIf
			EndIf
		EndIf
	EndIf

	If lInt_PonGpe .And. lRet //Caso integração com o Ponto.
		If ( nOpcx == MODEL_OPERATION_UPDATE .Or. nOpcx == MODEL_OPERATION_DELETE ) .And. !Empty( aOldTNY[1,_CODABO_] ) //Cod Abono nao estava vazio
			If A685STATUS( oModel:GetValue( 'TNYMASTER1', 'TNY_NATEST' ) )

				// Nao alterou nenhum campo importante p/ o Ponto ou exclusao de reg.
				If aScan(aOldTNY,{|x| x[_DTINIC_] == oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' ) .And. x[_DTFIM_] == oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM' ) .And.;
					x[_HRINIC_] == oModel:GetValue( 'TNYMASTER1', 'TNY_HRINIC' ) .And. x[_HRFIM_] == oModel:GetValue( 'TNYMASTER1', 'TNY_HRFIM' ) .And.;
					x[_CODABO_] == oModel:GetValue( 'TNYMASTER1', 'TNY_CODABO' ) } ) <= 0 .Or. nOpcx == MODEL_OPERATION_DELETE

					If Empty(dDataFecha := STOD(SubStr(GetMv("MV_PONMES"),10,8))) .And. lRet
						Help( , , STR0111 , , STR0031+Chr(10)+Chr(10)+STR0031+STR0032 , 6 , 6 )//Problema: Não foi possível encontrar a data de fechamento do Ponto Eletrônico."
						lRet := .F.															   //"Solução:  Verificar se o parametro 'MV_PONMES' está com as datas de "
					EndIf

					If dDataBase >= dDataFecha - nDiasFecha .And. lRet
						If nOpcx == MODEL_OPERATION_UPDATE
							Help( , , STR0111 , , STR0033+STR0034 , 6 , 6 )//"ATENÇÃO"+"Não podera alterar o Atestado, pois a informação já foi processada pelo"+" Ponto Eletrônico."
						Else
							Help( , , STR0111 , , STR0035+STR0034 , 6 , 6 )//"ATENÇÃO"+"Não podera excluir o Atestado, pois a informação já foi processada pelo"+" Ponto Eletrônico."
						EndIf
						lRet := .F.
					EndIf

				EndIf
			EndIf
		EndIf
	EndIf

	If ( nOpcx == MODEL_OPERATION_UPDATE .Or. nOpcx == MODEL_OPERATION_INSERT )  .And. lRet

		lRet := fValCodAfa( oModel:GetValue( 'TNYMASTER1', 'TNY_NATEST' ),oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' ), ;
							nOpcx == MODEL_OPERATION_UPDATE )

		//Valida com os atestados cadastrados pelo GPE
		If lInt_AfaGpe .And. lRet
			If !M685DTVAL( nOpcx, oModel )
				lRet := .F.
			EndIf
		EndIf
		//Validar a Data/Hora de Inicio e Fim do Afastamento
		If oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' ) > oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM' ) .And. !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM' )) .And. lRet
			Help( , , STR0112 , , STR0036 , 6 , 6 )//"AVISO"+"A Data Fim do Afastamento tem que ser maior que a Data Inicio."
			lRet := .F.
		ElseIf oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' ) == oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM' ) .And. oModel:GetValue( 'TNYMASTER1', 'TNY_HRINIC' ) >= oModel:GetValue( 'TNYMASTER1', 'TNY_HRFIM' ) .And. ;
			!Empty(Substr(oModel:GetValue( 'TNYMASTER1', 'TNY_HRFIM' ),1,2)) .And. !Empty(Substr(oModel:GetValue( 'TNYMASTER1', 'TNY_HRFIM' ),4,2)) .And. lRet
			Help( , , STR0112 , , STR0037 , 6 , 6 ) //"AVISO"+"A Hora Fim do Afastamento tem que ser maior que a Hora Inicio."
			lRet := .F.
		EndIf
		If !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' )) .And. !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_HRINIC' )) .And. !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' )) .And. ;
			nOpcx == MODEL_OPERATION_INSERT .And. nOpcx <> MODEL_OPERATION_UPDATE .And. lRet
			If !ExistChav("TNY",oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' )+DTOS(oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' ))+oModel:GetValue( 'TNYMASTER1', 'TNY_HRINIC' ))
				lRet := .F.
			EndIf
		EndIf

		// Verifica os atestado com o mesmo CID
		If !fChkAteCID( oModel ) .And. lRet
			lRet := .F.
		EndIf

		// Verifica se os funcionario esta demitido, sendo as datas informadas menores que a de demissão.
		If !fChkDtAfas() .And. lRet
			lRet := .F.
		EndIf

		//Validar os campos Codigo Abono ou Tipo Afastamento
		If ( lInt_PonGpe .Or. lInt_AfaGpe ) .And. lRet
			If !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_CODABO' ) ) .And. ( Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' ) ) .Or. Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM' ) ) .Or. Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_HRFIM' ) ) .Or. Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_HRINIC' ) ) )
				//"Quando o 'Cod.Abono' estiver preenchido, os campos abaixo precisam ser preenchidos também:"
				//"- Dt. Inic. Afas."###"- Hr. Ini. Afas."
				//"- Dt. Fim Afas."###"- Hr. Fim Afas."###"AVISO"
				Help( , , STR0112 , , STR0038 + Chr(10) + STR0040 + Chr(10) + STR0041 + Chr(10) + STR0042 + Chr(10) + STR0043 , 6 , 6 )
				lRet := .F.
			EndIf

			If (oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM' ) - oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' )) > nDiasTotAf .And. !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_CODABO' )) .And. lRet .And. nOpcx <> 5
				//"Problema: Quando o 'Cod.Abono' estiver preenchido, o afastamento não pode ser superior à "//" dia(s)."
				//"Solução:  Verificar os campos 'Dt. Inic. Afas.' e 'Dt. Fim Afas.'."
				Help( , , STR0112 , , STR0046 + cValToChar( nDiasTotAf ) + STR0180 + Chr(10)+Chr(10)+STR0048 , 6 , 6 )
				lRet := .F.
			EndIf

			// Percorre todas as linhas da Grid, para que seja verificado as datas de Afastamento.
			If lRet .And. !FwIsInCallStack( 'MDTA410' )
				For nY := 1 to nLenGrid
					oGrid:GoLine( nY )
					If !( oGrid:IsDeleted() ) //Verifica se não está deletado.
						If !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' ) )
							If Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' )) .Or. Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_HRINIC' )) .Or.;
								 (Empty(oGrid:GetValue( "TYZ_DTSAID" )) .And. nLenGrid == 1 )
								//"Quando o 'Tipo Afasta.' estiver preenchido, os campos abaixo precisam ser preenchidos também: "
								//"- Dt. Saida. A.D"
								//"- Dt. Inic. Afas."
								//"- Hr. Ini. Afas."###"AVISO"
								Help( , , STR0112 , , STR0044 + Chr(10) + STR0045 + Chr(10) + STR0040 + Chr(10) + STR0041 , 6 , 6 )
								lRet := .F.
							EndIf
						EndIf

						If lRet .And. !Empty( oGrid:GetValue( 'TYZ_DTSAID' ) )

							If oGrid:GetValue( 'TYZ_DTSAID' ) != oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' ) .And. nY == 1

								//---------------------------------------------------------------------------------------------
								// Mensagens:
								// "Atenção"
								// "A data de saída do afastamento não pode ser diferente da data de início do atestado médico"
								// "Ajuste a data de início do afastamento"
								//---------------------------------------------------------------------------------------------

								Help( Nil, Nil, STR0153, Nil, STR0104 + '.', 1, 0, Nil, Nil, Nil, Nil, Nil, { STR0248 + '.' } )
								lRet := .F.

							EndIf

							If !Empty(oGrid:GetValue( "TYZ_DTALTA" )) .And. oGrid:GetValue( "TYZ_DTALTA" ) < oGrid:GetValue( "TYZ_DTSAID" ) .And. lRet
								Help( , , STR0112 , , STR0105 , 6 , 6 ) //"AVISO"+"A Dt. Alta deve ser maior ou igual que a Dt. Saída"
								lRet := .F.
							EndIf

						EndIf

						If !Empty(oGrid:GetValue( "TYZ_DTALTA" )) .And. lRet .And. !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM' ))
							If oGrid:GetValue( "TYZ_DTALTA" ) > oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM' )
								Help( , , STR0112 , , STR0136 , 6 , 6 ) //"AVISO"##"1ª Data Alta A.D não deve ser menor que a 'Dt. Fim Afas.'"
								lRet := .F.
							EndIf
						EndIf
					EndIf
				Next nY
			EndIf

			If !Empty( cAfast )
				If !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_TIPAFA' ) ) .And. !(SubStr(oModel:GetValue( 'TNYMASTER1', 'TNY_TIPAFA' ),1,1) $ cAfast+"O/P") .Or. ;
					( !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' ) ) .And. !(SubStr(NGSeek( "RCM" , oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' ) , 1 , "RCM->RCM_CODSEF" ),1,1) $ cAfast+"O/P") ) .And. lRet
					//"O tipo de afastamento"###"não pode ser informado pelo programa de Atestado Medico"
					//"Os Códigos válidos são aqueles informados no parametro do SX6 'MV_NG2AFAS'."
					//"O conteúdo informado no parâmetro MV_NG2AFAS deve ser um código de movimento existente na tabela S046 na rotina de Manutenção de Tabelas (GPEA320) do módulo SIGAGPE." 
					//"Os valores devem ser informados separados por vírgula. Se o parâmetro estiver em branco serão considerados todos os códigos."
					Help( , , STR0112 , , STR0061 + " '" + SubStr( If( !Empty( M->TNY_TIPAFA ) , M->TNY_TIPAFA , NGSeek( "RCM" , M->TNY_CODAFA , 1 , "RCM->RCM_CODSEF" )) , 1 , 1 ) + STR0062 , 6 , 6, , , , , , { STR0253 } )
					lRet := .F.
				EndIf
			EndIf

			dbSelectArea( "SP6" )
			dbSetOrder( 1 )
			If dbSeek( xFilial( "SP6" ) + oModel:GetValue( 'TNYMASTER1', 'TNY_CODABO' ) )
				If SP6->P6_PREABO != "S" .And. !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_CODABO' )) .And. lRet
					//"O codigo de abono"###"não pode ser informado pelo programa de Atestado Medico"
					//"Os Códigos válidos são aqueles que podem ser Pre-abonados."
					Help( , , STR0112 , , STR0058 + " '" + oModel:GetValue( 'TNYMASTER1', 'TNY_CODABO' ) + "' " + STR0059 + CRLF + STR0060 , 6 , 6 )
					lRet := .F.
				EndIf
			EndIf
		EndIf
	EndIf

	If nOpcx == MODEL_OPERATION_DELETE .And. lInt_PonGpe .And. lRet .And. !IsInCallStack("MDTA410")
		dbSelectArea( "TM0" )
		dbSetOrder( 1 )
		dbSeek( xFilial( "TM0" ) + oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ) )
		dbSelectArea( "SRA" )
		dbSetOrder( 1 )
		If dbSeek( xFilial( "SRA" , TM0->TM0_FILFUN ) + TM0->TM0_MAT )
			If !Empty( &( cTipAfas ) )
				If lCpoIndSr8
					dbSelectArea( "SR8" )
					dbSetOrder( 2 )
					If dbSeek( SRA->RA_FILIAL + oModel:GetValue( 'TNYMASTER1', 'TNY_NATEST' ) )
						If !MsgYesNo( STR0063 + ; //"Foi registrado afastamento referente a este atestado médico."
						STR0064 )  //"Confirma exclusão do Afastamento e Atestado Médico?"
							lRet := .F.
						EndIf
					EndIf
				Else
					lTemSr8 := .F.
					aRecordSR8 := fMontaArSR8( oModel:GetValue( 'TNYMASTER1', 'TNY_TIPAFA' ) )

					aAdd( aRecordSR8 , { "R8_TIPOAFA"	, oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' ) } )

					If !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' ) )
						dbSelectArea("SR8")
						lTemSr8 := MDTRecnoSR8( aRecordSR8 ) > 0
					EndIf

					For nW := 1 To nLenGrid
						oGrid:GoLine( nW )
						If !Empty(oGrid:GetValue( "TYZ_DTSAID" )) .And. !lTemSr8
							nPosAux := aScan( aRecordSR8 , { | x | x[1] == "R8_DATAINI" } )
							If nPosAux > 0
								aRecordSR8[ nPosAux ][ 2 ] := oGrid:GetValue( "TYZ_DTSAID" )
							Else
								aAdd( aRecordSR8 , { "R8_DATAINI" , oGrid:GetValue( "TYZ_DTSAID" ) } )
							EndIf

							dbSelectArea("SR8")
							lTemSr8 := MDTRecnoSR8( aRecordSR8 ) > 0
						EndIf
					Next nW

					If lTemSr8
						If !MsgYesNo( STR0063 + ; //"Foi registrado afastamento referente a este atestado médico."
									  STR0064 ) //"Confirma exclusão do Afastamento e Atestado Médico?"
							lRet := .F.
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	If ExistBlock("MDTA6851") .And. lRet
		aAdd( aParam , nOpcx )
		lRet := ExecBlock( "MDTA6851",.F.,.F., aParam )
		lRet := IIf( ValType( lRet ) == "L" .And. lRet , .T., .F. )
	EndIf

	If nOpcx == MODEL_OPERATION_UPDATE .Or. nOpcx == MODEL_OPERATION_DELETE
		If !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) ) .And. lRet
			dbSelectArea( "TNC" )
			dbSetOrder( 1 ) //TNC_FILIAL+TNC_ACIDEN
			If dbSeek( xFilial( "TNC" ) + oModel:GetValue( 'TNYMASTER1', 'TNY_ACIDEN' ) ) .And. TNC->TNC_CID <> oModel:GetValue( 'TNYMASTER1', 'TNY_CID' )
				If MsgYesNo( STR0181 + AllTrim( TNC->TNC_ACIDEN ) + STR0182 )//"O Atestado está vinculado ao Acidente "//", deseja replicar o CID para o Acidente?"
					RecLock( "TNC" , .F. )
					TNC->TNC_CID   := oModel:GetValue( 'TNYMASTER1', 'TNY_CID' )
					TNC->TNC_GRPCID:= oModel:GetValue( 'TNYMASTER1', 'TNY_GRPCID' )
					MsUnLock()
				EndIf
			EndIf
		EndIf
	EndIf

	//Verifica Duracao do afastamento para alertar.
	If cPaisLoc == 'BRA' .And. lRet
		If nOpcx == MODEL_OPERATION_UPDATE .Or. nOpcx == MODEL_OPERATION_INSERT
			ChkDurAfas( oModel )
		EndIf
	EndIf

	//----------------------------------------------------------------------------------------
	// // Realiza as validações das informações do evento S-2210 que serão enviadas ao Governo
	//----------------------------------------------------------------------------------------
	If lRet .And. FindFunction( "MDTIntEsoc" )
		lRet := MDTIntEsoc( "S-2210", nOpcx, oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ), , .F., , oModel )
	EndIf

	RestArea(aAreaTNY) // Retorna área salva.

Return lRet

//-------------------------------------------------------
/*/{Protheus.doc} MDT685COMM
Função responsável por fazer a gravação dos dados.

@type   function
@author Guilherme Freudenburg
@since  01/03/2016
@sample MDT685COMM( oModel )

@param  oModel, Mbjeto, Modelo de dados
@param  nAltera, Numérico, Opção a ser efetuada
@param  lGrvAfas, Lógico, Falso se não deve gravar os
afasatmentos (SR8)

@return Lógico, Verdadeiro se realizou o Commit dos dados.
/*/
//--------------------------------------------------------
Function MDT685COMM( oModel, nAltera, lGrvAfas )

	Local aAreaTNY 	  := TNY->(GetArea()) // Salva área posicionada
	Local lRet		  := .T.
	Local nDiasEx     := SuperGetMv( "MV_NG2D685" , .F. , 0 ) // Numero minimo de dias para gerar um exame de (NR7).
	Local nOpcx 	  := oModel:GetOperation() // Opção realizada.
	Local oGrid
	Local nLenGrid    := 0
	Local cNumAt 	  := TNY->TNY_NATEST
	Local nX  		  := 0
	Local nY          := 0
	Local lMsErroAuto := .F.
	Local aRecDelSR8  := {}
	Local aDelSR8     := {}
	Local aCabec 	  := {}
	Local aLinha 	  := {}
	Local aItens 	  := {}
	Local aErrAfa	  := {}

	Private lInt_AfaGpe := SuperGetMv( "MV_NGMDTAF" , .F. , "N" ) == "S"
	Private lInt_PonGpe := MDT685VPON( lInt_AfaGpe )
	Private lIntMDTGPE  := SuperGetMv( "MV_MDTGPE" , .F. , "N" ) == "S" // Interação de com módulo GPE.
	Private cProcesso   := ""
	Private aOldTNY     := MDT685TNYA()
	Private aRotina     := {}

	Default nAltera     := 0
	Default lGrvAfas    := .T.
	Default Inclui      := IIf( MODEL_OPERATION_INSERT, .T., .F. )

	If IsInCallStack("MDTA410")
		nOpcx := nAltera
	EndIf

	oGrid	 := oModel:GetModel( 'TYZDETAIL' )
	nLenGrid := oGrid:Length()   // Quantidade Total de linhas do oGrid.

	dbSelectArea("SRA")
	dbSetOrder(1)
	dbSeek(xFilial("SRA",TM0->TM0_FILFUN)+TM0->TM0_MAT)

	// Caso seja exclusão.
	If nOpcx == MODEL_OPERATION_DELETE

		nOrd := NGRETORDEM("TNY","TNY_FILIAL+TNY_NATEST")
		If nOrd == 0
			nOrd := 5
		EndIf

		dbSelectArea( "TNY" )
		dbSetOrder( nOrd )

		If dbSeek( xFilial( "TNY" ) + cNumAt )

			dbSelectArea( "TKI" )
			dbSetOrder( 1 )

			If dbSeek( xFilial( "TKI" ) + TNY->TNY_NATEST )

				While !EoF() .And. TKI->TKI_NATEST == TNY->TNY_NATEST
					RecLock( "TKI" , .F. )
					dbDelete()
					TKI->( MsUnLock() )
					dbSelectArea( "TKI" )
					dbSkip()
				End

			EndIf

			If lIntMDTGPE .And. lInt_AfaGpe

				For nX := 1 To nLenGrid
					aRecDelSR8 := {} // Limpa o Array
					oGrid:GoLine( nX )
					// Salva dos registros que foram deletados.
					aAdd( aRecDelSR8, { "R8_FILIAL"	, SRA->RA_FILIAL			 	 } )
					aAdd( aRecDelSR8, { "R8_MAT"	, SRA->RA_MAT					 } )
					aAdd( aRecDelSR8, { "R8_TIPOAFA", TNY->TNY_CODAFA 				 } )
					aAdd( aRecDelSR8, { "R8_SEQ"	, oGrid:GetValue( "TYZ_SEQ" )	 } )
					aAdd( aRecDelSR8, { "R8_DATAINI", oGrid:GetValue( "TYZ_DTSAID" ) } )
					aAdd( aRecDelSR8, { "R8_DATAFIM", oGrid:GetValue( "TYZ_DTALTA" ) } )
					aAdd(aDelSR8 , aRecDelSR8)
				Next nX

				If Len(aDelSR8) > 0 // Registros Deletados.

					lEmpty := .T.
					oModSR8 := FWLoadModel("GPEA240") // Chama modelo do GPE
					oModSR8:SetOperation(4) // Seta Alteração
					oModSR8:Activate() // Ativa Modelo.
					oGridSR8 := oModSR8:GetModel("GPEA240_SR8") // Grid para inclusão de SR8

					// Verifica se é a GetDados ficará vazia
					For nY := 1 To oGridSR8:Length()

						If aScan( aDelSR8 , { | x | x[ 3 , 2 ] == oGridSR8:GetValue("R8_TIPOAFA") .And. ;
													x[ 4 , 2 ] == oGridSR8:GetValue("R8_SEQ") .And. ;
													x[ 5 , 2 ] == oGridSR8:GetValue("R8_DATAINI") .And. ;
													x[ 6 , 2 ] == oGridSR8:GetValue("R8_DATAFIM") } ) == 0
							lEmpty := .F.
							Exit

						EndIf

					Next nY

					For nY := 1 To Len( aDelSR8 )

						If oGridSR8:SeekLine( aDelSR8[ nY ] )
							oGridSR8:DeleteLine()
						EndIf

					Next nY

					//Caso haja inconsistências na gravação da SR8, na integração do TAF por exemplo, emite o Help avisando.
					If !( lRet := MDTGravSR8(  ,  , , , , oModSR8 , .T., @aErrAfa ) )
						Help( ' ', 1, aErrAfa[ 1, 1 ], , aErrAfa[ 1, 2 ], 2, 0, , , , , , { STR0233 } )
						//"Favor ajustar os ítens inconsistentes e/ou realizar a exclusão do afastamento relacionado ao Atestado diretamente
						//pela rotina de Afastamentos (GPEA240) para integração com o SIGATAF"
						lRet := .F.
					EndIf

					oModSR8:DeActivate()

					If lRet
						RetSituacao(SRA->RA_FILIAL,SRA->RA_MAT,.T.)
					EndIf

				EndIf
			EndIf

			If lInt_PonGpe .And. lRet

				aAdd( aCabec, {"RF0_FILIAL", SRA->RA_FILIAL , })
				aAdd( aCabec, {"RF0_MAT"   , SRA->RA_MAT    , })

				For nX := 1 To nLenGrid
					aAdd( aLinha  , { "RF0_FILIAL"	, SRA->RA_FILIAL				,} )
					aAdd( aLinha  , { "RF0_MAT"		, SRA->RA_MAT					,} )

					aAdd( aLinha  , { "RF0_DTPREI"	, oGrid:GetValue( "TYZ_DTSAID" ),} )
					aAdd( aLinha  , { "RF0_DTPREF"	, oGrid:GetValue( "TYZ_DTALTA" ),} )

					aAdd(aLinha	  , { "RF0_CODABO" 	, TNY->TNY_CODABO				,})

					If !Empty( Posicione( "TNP" , 1 , xFilial("TNP") + TNY->TNY_EMITEN , "TNP_USUARI" ) )
						aAdd(aLinha	  , { "RF0_USUAR" 	, Posicione( "TNP" , 1 , xFilial( "TNP" ) + TNY->TNY_EMITEN , "TNP_USUARI" ) ,})
					EndIf

					aAdd(aLinha	  , { "RF0_NATEST" 	, TNY->TNY_NATEST				,})
					aAdd(aItens, aLinha)
					oGrid:GoLine( nX )
				Next nX

				If Len(aItens) > 0

					MSExecAuto({|x,y,z| PONA350(x,y,z)},aCabec,aItens,5)

					If lMsErroAuto
						If !IsBlind()
							Mostraerro()
						EndIf
						lRet := .F.
					EndIf

				EndIf

			EndIf

			// Apaga o Registro da TNY e TYZ
			If lRet
				FWFormCommit( oModel )
			EndIf

		EndIf

	EndIf

	RestArea(aAreaTNY)
	dbSelectArea("TNY")
	dbSetOrder(2)

	// Caso seja Inclusão ou Alteração
	If nOpcx == MODEL_OPERATION_INSERT .Or. nOpcx == MODEL_OPERATION_UPDATE

		MDT685VLDT(2) //Atualiza o valor de TNY_QTDIAS

		// Verifica a integração com os Módulos do Ponto eletrônico e com o Gestão de Pessoas
		If lIntMDTGPE .And. ( lInt_PonGpe .Or. lInt_AfaGpe )
			lRet := A685UPDATE( nOpcx , oModel,, lGrvAfas ) // Grava tabela SR8 e SPK e RF0	
		EndIf

		If !Empty(M->TNY_CODABO) .AND. !lInt_PonGpe

			Help(,, STR0239 ,,, 1 , 0 ,,,,,, { STR0240 } )//"Abono não registrado","Verifique se o parâmetro MV_MDTGPE e/ou MV_NG2IPON estão habilitados e tente novamente"

			lRet := .F.

		EndIf

		If lRet
			IIf( nOpcx == 3 .And. !Inclui, Inclui := .T., )
			// Grava as informações
			FWFormCommit( oModel )
			ConfirmSX8()
			FreeUsedCode() // Libera os nomes reservados para evitar mensagem de Lock

			If IsInCallStack('MDTA410')
				MDTA685DIA()
			EndIf
		EndIf

	EndIf

	RetSituacao(SRA->RA_FILIAL,SRA->RA_MAT,.T.)

	//Realiza Gravação da TM5
	If nDiasEx <> 0 .And. lRet
		A685TM5( nOpcx , nDiasEx ) //Grava tabela TM5
	EndIf

	If lRet .And. nOpcx != 2 .And. ExistBlock("MDTA6854")
		ExecBlock("MDTA6854",.F.,.F., { nOpcx } )
	EndIf

	//-----------------------------------------------------------------
	// Realiza a integração das informações do evento S-2210 ao Governo
	//-----------------------------------------------------------------
	If FindFunction( "MDTIntEsoc" ) .And. lRet
		MDTIntEsoc( "S-2210", nOpcx, TNY->TNY_NUMFIC, , , , oModel )
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} A685UPDATE
Atualiza a tabela de afastamentos(SR8) e Ponto eletr.(SPK)

@type   function
@author Denis Hyroshi de Souza
@since  04/04/03
@sample A685UPDATE(3,oModel)

@param  nOpcx,  Numérico, Opção utilizada.
@param  oModel,  Objeto, Modelo de Dados.
@param  aTNYCont,  Array, Valores da TNY.
@param  lGravaSR8,  Lógico, .T. se deve efetuar a gravação da SR8 .

@return Lógico, Sempre Verdadeiro.
/*/
//---------------------------------------------------------------------
Function A685UPDATE( nOpcx, oModel, aTNYCont, lGravaSR8 )

	Local aCabec 		:= {}
	Local aItens 		:= {}
	Local aLinha 		:= {}
	Local aCabSR8 		:= {}
	Local aAreaSR8 		:= {}
	Local aAreaTNC 		:= TNC->( GetArea() ) // Salva a área da TNC para não desposicionar o acidente
	Local aRetDias		:= { 0, 0, 0, 0, 0 }
	Local aErrosSR8 	:= {}

	Local lRet 			:= .T.
	Local lAdd 			:= .F.
	Local lEmpty 		:= .F.
	Local lNoturn 		:= .F. // Indica se o funcionário trabalha em turno noturno

	Local nY 			:= 0
	Local nFor 			:= 0
	Local nInd 			:= 0
	Local nTYZ 			:= 0
	Local nLenGrid 		:= 0

	Local oGrid
	Local oModSR8
	Local oMaster 		:= oModel:GetModel( 'TNYMASTER1' )

	Local cAfast 		:= Alltrim( GetNewPar( 'MV_NG2AFAS', '' ) )
	Local cTpEfd 		:= oMaster:GetValue('TNY_TPEFD')
	Local dDtFim 		:= oMaster:GetValue('TNY_DTFIM')
	Local cTNYAfa 		:= oMaster:GetValue('TNY_TIPAFA')
	Local cCodAfa 		:= oMaster:GetValue('TNY_CODAFA')
	Local cNumFic 		:= oMaster:GetValue('TNY_NUMFIC')
	Local cGrpCID 		:= oMaster:GetValue('TNY_GRPCID')
	Local cCodCID 		:= oMaster:GetValue('TNY_CID')
	Local cNAtest 		:= oMaster:GetValue('TNY_NATEST')
	Local cEmiten 		:= oMaster:GetValue('TNY_EMITEN')
	Local cAciden 		:= oMaster:GetValue('TNY_ACIDEN')
	Local cCodAbo 		:= oMaster:GetValue('TNY_CODABO')
	Local cHrInic 		:= oMaster:GetValue('TNY_HRINIC')
	Local cHorFim 		:= oMaster:GetValue('TNY_HRFIM')
	Local cSeqCon 		:= ''
	Local cPeriod 		:= ''
	Local cNumpag 		:= ''
	Local cTipAfas 		:= "IIf( Empty( M->TNY_CODAFA ), M->TNY_TIPAFA, NGSeek( 'RCM', M->TNY_CODAFA, 1, 'RCM->RCM_CODSEF' ) )"
	Local cSequencia	:= ''

	Local dDtInic 		:= oMaster:GetValue('TNY_DTINIC')
	Local dDataAlt

	Public lBloqFol 	:= .T. // Variável utilizada no fonte mdta686
	Public lMdtBloq 	:= .T. // Variável utilizada no fonte mdta686

	Private aOldRF0     := {}

	Private lCpoSr8 	:= .F.
	Private lCpoCid     := NGCADICBASE("R8_CID"    ,"A","SR8",.F.)
	Private lCpoDura    := NGCADICBASE("R8_DURACAO","A","SR8",.F.);
							.And. NGCADICBASE("R8_DPAGAR" ,"A","SR8",.F.);
							.And. NGCADICBASE("R8_DIASEMP","A","SR8",.F.)
	Private lCpoIndSr8 	:= .F.
	Private lInt_AfaGpe	:= SuperGetMv( "MV_NGMDTAF" , .F. , "N" ) == "S"
	Private lInt_PonGpe := MDT685VPON( lInt_AfaGpe )

	Private nIndSR8     := f685RetOrder("SR8","R8_FILIAL+R8_NATEST")
	Private nAntDemp    := 0
	Private nAntDPag    := 0

	Private oGridSR8

	Default aTNYCont    := {}

	Default lGravaSR8   := .T.

	Default nOpcx	    := oModel:GetOperation() //Opção realizada.

	oGrid 	 := oModel:GetModel( 'TYZDETAIL' )
	nLenGrid := oGrid:Length() //Quantidade Total de linhas do oGrid.

	If SR8->(ColumnPos("R8_NATEST")) > 0 //Campo Específico.
		lCpoSr8 := .T.
		If nIndSR8 > 0
			lCpoIndSr8 := .T.
		EndIf
	EndIf

	dbSelectArea("TM0")
	dbSetOrder(1)
	dbSeek(xFilial("TM0")+ cNumFic)
	dbSelectArea("SRA")
	dbSetOrder(1)
	If !Empty(TM0->TM0_MAT)

		dbSeek(xFilial("SRA",TM0->TM0_FILFUN)+TM0->TM0_MAT)

		lNoturn := MDT685TUR( cNumFic, dDtInic )[1]
		lMsErroAuto := .F.

		// A integração com o GPE deve ser feita por último
		// Pois é a única que pode retornar erro e cadastrar o atestado
		// As demais integrações caso não sejam validadas devem impedir o cadastro do atestado

		// Grava Abono RF0
		If lInt_PonGpe .And. !IsInCallStack( 'MDTA686' ) // Não grava pela rotina de Comunicar Atestados
			If !Empty(cCodAbo)
				aDiasRF0 := {}
				If !Empty( &( cTipAfas ) )
					//Se campos de 1º afastamento preenchido
					For nFor := 1 To nLenGrid
						oGrid:GoLine( nFor )//Posiciona na linha desejada.
						If !( oGrid:IsDeleted() )  //Verifica se não foi deletado.
							If !Empty(oGrid:GetValue( "TYZ_DTALTA" )) .And. !Empty(oGrid:GetValue( "TYZ_DTSAID" ))
								aAdd( aDiasRF0 , {oGrid:GetValue( "TYZ_DTSAID" ),oGrid:GetValue( "TYZ_DTALTA" )} )
							EndIf
						EndIf
					Next nFor
				Else
					//Se campos de afastamento NAO preenchido
					aAdd( aDiasRF0 , {dDtInic,dDtFim} )
				EndIf
				If Len(aDiasRF0) > 0
					//ALTERACAO
					If nOpcx == MODEL_OPERATION_UPDATE .And. Len(aOldRF0) > 0
						aCabec := {}
						aItens := {}
						aLinha := {}
						aAdd( aCabec, {"RF0_FILIAL", SRA->RA_FILIAL , })
						aAdd( aCabec, {"RF0_MAT"   , SRA->RA_MAT    , })
						If Len(aOldRF0) > Len(aDiasRF0)
							For nInd := Len(aDiasRF0)+1 to Len(aOldRF0)
								dbSelectArea("RF0")
								If Len(aOldRF0) >= nInd
									If aOldRF0[nInd,1] > 0
										Dbgoto(aOldRF0[nInd,1])
										If !EoF() .And. !Bof() .And. !Deleted()
											aAdd( aLinha  , { "RF0_FILIAL"	, RF0->RF0_FILIAL	,} )
											aAdd( aLinha  , { "RF0_MAT"		, RF0->RF0_MAT		,} )
											aAdd( aLinha  , { "RF0_DTPREI"	, RF0->RF0_DTPREI	,} )
											aAdd( aLinha  , { "RF0_DTPREF"	, RF0->RF0_DTPREF	,} )
											aAdd( aLinha  , { "RF0_USUAR"	, RF0->RF0_USUAR	,} )
											aAdd( aLinha  , { "RF0_CODABO"	, RF0->RF0_CODABO	,} )
											aAdd( aLinha  , { "RF0_NATEST"	, RF0->RF0_NATEST	,} )
											aAdd( aLinha  , { "RF0_FLAG"	, RF0->RF0_FLAG		,} )
											aAdd( aLinha  , { "RF0_ABONA"	, RF0->RF0_ABONA	,} )
											aAdd( aLinha  , { "RF0_HORTAB"	, RF0->RF0_HORTAB	,} )
											aAdd( aLinha  , { "RF0_HORINI"	, RF0->RF0_HORINI	,} )
											aAdd( aLinha  , { "RF0_HORFIM"	, RF0->RF0_HORFIM	,} )
											aadd(aItens, aLinha)
										EndIf
									EndIf
								EndIf
							Next nInd
						EndIf

						If Len(aItens) > 0
							MSExecAuto({|x,y,z| PONA350(x,y,z)},aCabec,aItens,5)
							If lMsErroAuto
								If !IsBLind()
									Mostraerro()											
								EndIf
								lRet := .F.
							EndIf
						EndIf

						If lRet
							aCabec := {}
							aItens := {}
							aLinha := {}
							aAdd( aCabec, {"RF0_FILIAL", SRA->RA_FILIAL , })
							aAdd( aCabec, {"RF0_MAT"   , SRA->RA_MAT    , })
							For nFor := 1 to Len(aDiasRF0)
								aadd(aLinha,{"RF0_DTPREI" 	, aDiasRF0[nFor,1]		      , })
								aadd(aLinha,{"RF0_DTPREF" 	, aDiasRF0[nFor,2]		      , })
								aadd(aLinha,{"RF0_CODABO" 	, cCodAbo, })
								aadd(aLinha,{"RF0_ABONA" 	, 'N'					,})
								If !Empty( Posicione( "TNP" , 1 , xFilial("TNP") + cEmiten , "TNP_USUARI" ) )
									aAdd(aLinha	  , { "RF0_USUAR" 	, Posicione( "TNP" , 1 , xFilial( "TNP" ) + cEmiten , "TNP_USUARI" ) ,})
								EndIf
								aadd(aLinha,{"RF0_NATEST" 	, cNAtest		,})
								aadd(aLinha,{"RF0_FLAG" 	, 'G'			,})

								If dDtInic == aDiasRF0[nFor,1] .And. nFor == 1 .And. !Empty( &cTipAfas ) .And. ;
									(cHrInic <> '00:00' .Or. cHorFim <> '23:59')

									aAdd( aLinha, { "RF0_HORTAB", "N"				 , Nil } )
									aAdd( aLinha, { "RF0_HORINI", FHcTOHn685(cHrInic), Nil } )
									If dDtFim == aDiasRF0[nFor,2]
										aAdd( aLinha, { "RF0_HORFIM", If(!Empty(cHorFim),FHcTOHn685(cHorFim),0.00), Nil } )
									Else
										aAdd( aLinha, { "RF0_HORFIM", 0.00	, Nil} )
									EndIf

								ElseIf nFor == 1 .And. Empty( &cTipAfas ) .And. (cHrInic <> '00:00' .Or. cHorFim <> '23:59')
									aAdd( aLinha, { "RF0_HORTAB", "N"										  , Nil } )
									aAdd( aLinha, { "RF0_HORINI", FHcTOHn685(cHrInic)						  , Nil } )
									aAdd( aLinha, { "RF0_HORFIM", If(!Empty(cHorFim),FHcTOHn685(cHorFim),0.00), Nil } )
								Else
									aAdd( aLinha, { "RF0_HORTAB", "S" , Nil } )
									aAdd( aLinha, { "RF0_HORINI", 0.00, Nil } )
									aAdd( aLinha, { "RF0_HORFIM", 0.00, Nil } )
								EndIf

								aadd(aItens, aLinha)
								aLinha := {}
							Next nFor

							If Len(aItens) > 0
								MSExecAuto({|x,y,z| PONA350(x,y,z)},aCabec,aItens,3)
								If lMsErroAuto
									If !IsBLind()
										Mostraerro()
									EndIf
									lRet := .F.
								EndIf
							EndIf

						EndIf
					Else
					//INCLUSAO
						aCabec := {}
						aItens := {}
						aLinha := {}
						dbSelectArea("RF0")
						dbSetOrder(2)
						If dbSeek(xFilial("RF0",TM0->TM0_FILFUN)+cNAtest)
							aAdd( aCabec, {"RF0_FILIAL", SRA->RA_FILIAL , })
							aAdd( aCabec, {"RF0_MAT"   , SRA->RA_MAT    , })
							While !EoF() .And. xFilial("RF0",TM0->TM0_FILFUN)+cNAtest == RF0->RF0_FILIAL+RF0->RF0_NATEST
								If TM0->TM0_MAT == RF0->RF0_MAT
									aAdd( aLinha  , { "RF0_FILIAL"	, RF0->RF0_FILIAL	,} )
									aAdd( aLinha  , { "RF0_MAT"		, RF0->RF0_MAT		,} )
									aAdd( aLinha  , { "RF0_DTPREI"	, RF0->RF0_DTPREI	,} )
									aAdd( aLinha  , { "RF0_DTPREF"	, RF0->RF0_DTPREF	,} )
									aAdd( aLinha  , { "RF0_USUAR"	, RF0->RF0_USUAR	,} )
									aAdd( aLinha  , { "RF0_CODABO"	, RF0->RF0_CODABO	,} )
									aAdd( aLinha  , { "RF0_NATEST"	, RF0->RF0_NATEST	,} )
									aAdd( aLinha  , { "RF0_FLAG"	, RF0->RF0_FLAG		,} )
									aAdd( aLinha  , { "RF0_ABONA"	, RF0->RF0_ABONA	,} )
									aAdd( aLinha  , { "RF0_HORTAB"	, RF0->RF0_HORTAB	,} )
									aAdd( aLinha  , { "RF0_HORINI"	, RF0->RF0_HORINI	,} )
									aAdd( aLinha  , { "RF0_HORFIM"	, RF0->RF0_HORFIM	,} )
									aadd(aItens, aLinha)
								EndIf
								dbSkip()
							End

							If Len(aItens) > 0
								MSExecAuto({|x,y,z| PONA350(x,y,z)},aCabec,aItens,5)
								If lMsErroAuto
									If !IsBLind()
										Mostraerro()
									EndIf
									lRet := .F.
								EndIf
							EndIf
						EndIf

						If lRet
							aCabec := {}
							aItens := {}
							aLinha := {}
							aAdd( aCabec, {"RF0_FILIAL", SRA->RA_FILIAL , })
							aAdd( aCabec, {"RF0_MAT"   , SRA->RA_MAT    , })
							For nFor := 1 to Len(aDiasRF0)
								aadd(aLinha,{"RF0_DTPREI" 	, aDiasRF0[nFor,1]		,})
								aadd(aLinha,{"RF0_DTPREF" 	, aDiasRF0[nFor,2]		,})
								aadd(aLinha,{"RF0_CODABO" 	, cCodAbo		,})
								aadd(aLinha,{"RF0_ABONA" 	, 'N'					,})
								If !Empty( Posicione( "TNP" , 1 , xFilial("TNP") + cEmiten , "TNP_USUARI" ) )
									aadd(aLinha	  , { "RF0_USUAR" 	, Posicione( "TNP" , 1 , xFilial( "TNP" ) + cEmiten , "TNP_USUARI" ) ,})
								EndIf
								aadd(aLinha,{"RF0_NATEST" 	, cNAtest		,})
								aadd(aLinha,{"RF0_FLAG" 	, 'G'					,})

								If dDtInic == aDiasRF0[nFor,1] .And. nFor == 1 .And. !Empty( &cTipAfas ) .And. ;
									(cHrInic <> '00:00' .Or. cHorFim <> '23:59')

									aAdd( aLinha, { "RF0_HORTAB", "N"				 , Nil} )
									aAdd( aLinha, { "RF0_HORINI", FHcTOHn685(cHrInic), Nil} )
									If dDtFim == aDiasRF0[IF(IsInCallStack("MDTA410"),Len(aDiasRF0),nFor),2]
										aAdd( aLinha, { "RF0_HORFIM", If(!Empty(cHorFim),FHcTOHn685(cHorFim),0.00)	, Nil } )
									Else
										aAdd( aLinha, { "RF0_HORFIM", 0.00	, Nil} )
									EndIf

								ElseIf nFor == 1 .And. Empty( &cTipAfas ) .And. (cHrInic <> '00:00' .Or. cHorFim <> '23:59')
									aAdd( aLinha, { "RF0_HORTAB", "N"									      , Nil } )
									aAdd( aLinha, { "RF0_HORINI", FHcTOHn685(cHrInic)					 	  , Nil } )
									aAdd( aLinha, { "RF0_HORFIM", If(!Empty(cHorFim),FHcTOHn685(cHorFim),0.00), Nil } )
								Else
									aAdd( aLinha, { "RF0_HORTAB", "S" , Nil} )
									aAdd( aLinha, { "RF0_HORINI", 0.00, Nil} )
									aAdd( aLinha, { "RF0_HORFIM", 0.00, Nil} )
								EndIf

								aadd(aItens, aLinha)
								aLinha := {}
							Next nFor

							If Len(aItens) > 0
								MSExecAuto({|x,y,z| PONA350(x,y,z)},aCabec,aItens,3)
								If lMsErroAuto
									If !IsBLind()
										Mostraerro()
									EndIf
									lRet := .F.
								EndIf
							EndIf

						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	Else

		Help(,, STR0241 ,,, 1 , 0 ,,,,,, { STR0242 } )//"Numero de matricula não encontrado"
													  //"Verifique se foi cadastrado o numero de matricula do funcionário na ficha médica"
		lRet := .F.		

	EndIf
	

	If !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' ) ) .And. lRet // Verifica se foi lançado afastamento no atestado

		//Antes de abrir o modelo salva o estado atual
		aSaveModel := FWSaveRows()

		oModSR8 := FWLoadModel("GPEA240") //Chama modelo do GPE
		oModSR8:SetOperation( 3 ) //Seta Alteração
		oModSR8:Activate() //Ativa Modelo.
		oGridSR8 := oModSR8:GetModel("GPEA240_SR8") //Grid para inclusão de SR8
		oGridSR8:Activate()

		lRetBlo   := Mdt685BloF( .T., oModel )
		lMdtBloq := !lRetBlo

		If lMdtBloq
		// Grava Afastamento SR8
			If (nOpcx == MODEL_OPERATION_UPDATE .Or. nOpcx == MODEL_OPERATION_INSERT ) .And. lInt_AfaGpe .And. lGravaSR8
			
				// Percorre todos os registros da SR8, para que seja verificado se foi
				// realizado a inclusão ou Alteração através da TYZ.
				For nY := 1 To oGridSR8:Length()
					oGridSR8:GoLine( nY )
					aAdd( aCabSR8 , { { "R8_SEQ"	 , oGridSR8:GetValue("R8_SEQ") 	   }, ;
									{ "R8_DATAINI" , oGridSR8:GetValue("R8_DATAINI") }, ;
									{ "R8_DATAFIM" , oGridSR8:GetValue("R8_DATAFIM") } } )
				Next nY

				For nY := 1 To nLenGrid //Percorre todos os registro da TYZ

					lEmpty := oGridSR8:Length() == 1 .And. Empty( oGridSR8:GetValue("R8_DATAINI") )

					oGrid:GoLine( nY )

					cSequencia := fConSeq( nOpcx, oModel, oGrid, nY ) // Retorna sequência

					nTYZ := aScan( aCabSR8 , { | x | x[1,2] == oGrid:GetValue( "TYZ_SEQ" ) } )
					If nTYZ > 0
						If aCabSR8[nTYZ,2,2] <> oGrid:GetValue( "TYZ_DTSAID" ) .Or. aCabSR8[nTYZ,3,2] <> oGrid:GetValue( "TYZ_DTALTA" )
							oGridSR8:GoLine( nTYZ )
							lAdd    := .T.
						ElseIf oGrid:IsDeleted() //Caso registro foi deletado.
							oGridSR8:GoLine( nTYZ )
							oGridSR8:DeleteLine()
							lAdd := .F.
						ElseIf oMaster:IsModified() //Se algum campo na TNY foi modificado
							oGridSR8:GoLine( nTYZ )
							lAdd := .T.
						EndIf
					Else
						If !( oGrid:IsDeleted() ) //Caso registro não foi deletado.
							If !lEmpty
								oGridSR8:AddLine() //Registro novo, faz a inclusão da linha.
								nTYZ := oGridSR8:GetLine()
								lEmpty := .F.
							EndIf
							lAdd := .T.
						EndIf
					EndIf

					If lAdd // Adiciona valores a Grid da SR8

						// Busca a sequência do afastamento a ser continuado
						cSeqCon := fContinua( oModel, oGrid, oGridSR8, SRA->RA_MAT, cCodCID, cGrpCID )

						If Empty( cSeqCon )

							cSeqCon := Space( 3 )

						EndIf

						// Retorna a situação original do Modelo da TYZ e SR8 de antes de entrar na função fContinua
						oGrid:GoLine( nY )
						oGridSR8:GoLine( nTYZ )

						fLoadValue( oGridSR8, nTYZ, 'R8_FILIAL'  , SRA->RA_FILIAL	)
						fLoadValue( oGridSR8, nTYZ, 'R8_MAT' 	 , SRA->RA_MAT	    )
						fLoadValue( oGridSR8, nTYZ, 'R8_DATA' 	 , dDataBase	    )
						fLoadValue( oGridSR8, nTYZ, 'R8_TIPOAFA' , cCodAfa	        )
						fLoadValue( oGridSR8, nTYZ, 'R8_PD' 	 , NGSeek( "RCM" , cCodAfa , 1 , "RCM->RCM_PD")	)
						If SR8->( ColumnPos( "R8_PROADIC" ) ) > 0
							fLoadValue( oGridSR8, nTYZ, 'R8_PROADIC' , NGSeek( "RCM" , cCodAfa , 1 , "RCM->RCM_PROADI")	)
						EndIf
						fLoadValue( oGridSR8, nTYZ, 'R8_SEQ' 	 , cSequencia )
						fLoadValue( oGridSR8, nTYZ, 'R8_DATAINI' , oGrid:GetValue( "TYZ_DTSAID" ) )
						fLoadValue( oGridSR8, nTYZ, 'R8_DATAFIM' , oGrid:GetValue( "TYZ_DTALTA" ) )
						fLoadValue( oGridSR8, nTYZ, 'R8_CONTINU' , "1"     )
						fLoadValue( oGridSR8, nTYZ, 'R8_CONTAFA' , cSeqCon )

						fLoadValue( oGridSR8, nTYZ, 'R8_OBSAFAS' , oModel:GetValue( 'TNYMASTER1', 'TNY_OBSERV' ) )

						If ( FWIsInCallStack( 'Tcfa040' ) .Or. FWIsInCallStack( 'MdtExe' ) ) // Aprovação de atestados
							fLoadValue( oGridSR8, nTYZ, 'R8_NUMID', cSR8NumId )
						EndIf

						If lCpoSr8
							fLoadValue( oGridSR8, nTYZ, 'R8_NATEST'	, cNAtest	)
						EndIf

						If !Empty(SRA->RA_PROCES) //Verifica se Código do Processo foi preenchido.
							MDT685PER(@cPeriod,@cNumpag,SRA->RA_PROCES,dDtInic)
							fLoadValue( oGridSR8, nTYZ, 'R8_PROCES', SRA->RA_PROCES )
							fLoadValue( oGridSR8, nTYZ, 'R8_PER'	, cPeriod	) //Cod. Periodo
							fLoadValue( oGridSR8, nTYZ, 'R8_NUMPAGO', cNumpag	) //Numero Pagto
						EndIf

						fLoadValue( oGridSR8, nTYZ, 'R8_CID', cCodCID )

						If nTYZ == 0 .Or. oGridSR8:GetValue( 'R8_TPEFD' ) <> cTpEfd
							fLoadValue( oGridSR8, nTYZ, 'R8_TPEFD', cTpEfd )
						EndIf

						If !Empty( cEmiten )
							fLoadValue( oGridSR8, nTYZ, 'R8_NMMED', NGSEEK( "TNP", cEmiten, 1, "TNP_NOME" ) )
							fLoadValue( oGridSR8, nTYZ, 'R8_CRMMED', PADR( NGSEEK( "TNP", cEmiten, 1, "TNP_NUMENT" ), 14 ) )
							fLoadValue( oGridSR8, nTYZ, 'R8_IDEOC', fEntCalsse( cEmiten ) )
							fLoadValue( oGridSR8, nTYZ, 'R8_UFCRM', NGSEEK( "TNP", cEmiten, 1, "TNP_UF" ) )
						EndIf

						If IsInCallStack( "MDTA640" )
							If !Empty( cAciden )
								fLoadValue( oGridSR8, nTYZ, 'R8_TIPOAT', M->TNC_TIPOAT )
								fLoadValue( oGridSR8, nTYZ, 'R8_CODCAT', M->TNC_CATINS )
								If MDT640Rcb() //Caso existirem os campos de recibo no dic de dados
									fLoadValue( oGridSR8, nTYZ, 'R8_RECIBO', M->TNC_RECIBO )
								EndIf
							EndIf
						Else
							If !Empty( cAciden )
								fLoadValue( oGridSR8, nTYZ, 'R8_TIPOAT', NGSEEK( "TNC", cAciden, 1, "TNC_TIPOAT" ) )
								fLoadValue( oGridSR8, nTYZ, 'R8_CODCAT', NGSEEK( "TNC", cAciden, 1, "TNC_CATINS" ) )
								If MDT640Rcb() //Caso existirem os campos de recibo no dic de dados
									fLoadValue( oGridSR8, nTYZ, 'R8_RECIBO', NGSEEK( "TNC", cAciden, 1, "TNC_RECIBO" ) )
								EndIf
							EndIf
						EndIf
						lAdd := .F.
					Else
						If IsInCallStack( "MDTA640" )
							If !Empty( cAciden )
								fLoadValue( oGridSR8, nTYZ, 'R8_TIPOAT', M->TNC_TIPOAT )
								fLoadValue( oGridSR8, nTYZ, 'R8_CODCAT', M->TNC_CATINS )
								If MDT640Rcb() //Caso existirem os campos de recibo no dic de dados
									fLoadValue( oGridSR8, nTYZ, 'R8_RECIBO', M->TNC_RECIBO )
								EndIf
							EndIf
						Else
							If !Empty( cAciden )
								fLoadValue( oGridSR8, nTYZ, 'R8_TIPOAT', NGSEEK( "TNC", cAciden, 1, "TNC_TIPOAT" ) )
								fLoadValue( oGridSR8, nTYZ, 'R8_CODCAT', NGSEEK( "TNC", cAciden, 1, "TNC_CATINS" ) )
								If MDT640Rcb() //Caso existirem os campos de recibo no dic de dados
									fLoadValue( oGridSR8, nTYZ, 'R8_RECIBO', NGSEEK( "TNC", cAciden, 1, "TNC_RECIBO" ) )
								EndIf
							EndIf
						EndIf
					EndIf

					dDataAlt := oGrid:GetValue( "TYZ_DTALTA" )

					// Responsável por atualizar os campos R8_DIASEMP / R8_DPAGAR / R8_DPAGOS / R8_SDPAGAR
					a240NumDias(.F.)

				Next nY

				If !lRetBlo

					lRet := MDTGravSR8( Nil, Nil, Nil, Nil, Nil, oModSR8, .T., @aErrosSR8 )

					oModel:Activate()

					If !lRet
						If FwIsInCallStack( 'MDTA686' )
							Help( ' ', 1, @aErrosSR8[ 1, 1 ], , @aErrosSR8[ 1, 2 ], 2, 0, , , , , , )
						Else
							oModel:SetErrorMessage( 'TNYMASTER1', Nil, Nil, Nil, STR0153, aErrosSR8[ 1, 2 ], Nil ) // "Atenção"
						EndIf
					EndIf

				EndIf

				If lRet
					oModel:LoadValue( 'TNYMASTER1', 'TNY_COMUOK', 'OK' )
					RetSituacao( SRA->RA_FILIAL, SRA->RA_MAT, .T. )
				ElseIf !lRetBlo // Verifica se o motivo é o bloqueio da folha
					oModel:LoadValue( 'TNYMASTER1', 'TNY_COMUOK', '  ' )
				EndIf

				//Retorna a situação original
				FWRestRows( aSaveModel )

				// Permite a inclusão do atestado sem integrar o afastamento, somente quando o motivo é o bloqueio da folha
				lRet := IIf( !IsInCallStack( 'MDTA686' ) .And. lRetBlo, .T., lRet )

			EndIf

		EndIf

		
		If lRet .And. lRetBlo

			oModel:LoadValue( 'TNYMASTER1', 'TNY_COMUOK', '  ' )

		EndIf

	EndIf

	lBloqFol := !lRet // Retorna para a rotina de Comunicar atestados se houve um erro no cadastro do afastamento

	//Retorna a área da TNC
	RestArea( aAreaTNC )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fSomCar
Incrementa valor caractere de acordo com a quantidade informada.

@author Gabriel Sokacheski
@since 22/11/2022

@param cValor, valor a ser incrementado
@param nQtd, número de vezes que o valor deve ser incrementado

@return cValor, valor incrementado
/*/
//---------------------------------------------------------------------
Static Function fSomCar( cValor, nQtd )

	cValor := StrZero( Val( cValor ) + nQtd, 3 )

Return cValor

//---------------------------------------------------------------------
/*/{Protheus.doc} fConSeq
Controla a sequência do afastamento.

@author Gabriel Sokacheski
@since 22/11/2022

@param nOpcao, opção da rotina
@param oModel, modelo da rotina
@param oGrid, grid dos registros da tabela TYZ
@param nLinha, linha posicionada da grid

@return cSequencia, sequência que será gravada no registro da TYZ
/*/
//---------------------------------------------------------------------
Static Function fConSeq( nOpcao, oModel, oGrid, nLinha )

	Local cCorreta := ''
	Local cSequencia := ''

	If FwIsInCallStack( 'mdta686' )

		cSequencia := G240NextSq( SRA->RA_FILIAL, SRA->RA_MAT )

	ElseIf nOpcao == 3

		cSequencia := G240NextSq( SRA->RA_FILIAL, SRA->RA_MAT )

		If nLinha != 1
			cSequencia := fSomCar( cSequencia, ( nLinha - 1 ) )
		EndIf

	ElseIf nOpcao == 4

		If oGrid:IsUpdated() .And. ( oModel:GetValue( 'TNYMASTER1', 'TNY_COMUOK' ) != 'OK' .Or. !fAltAfa( oGrid ) ) // Adicionado novo afastamento

			cSequencia := G240NextSq( SRA->RA_FILIAL, SRA->RA_MAT )

		Else // Alterado afastamento já existente

			cSequencia := oGrid:GetValue( 'TYZ_SEQ' )

			If cSequencia == ( cCorreta := G240NextSq( SRA->RA_FILIAL, SRA->RA_MAT ) )
				cSequencia := StrZero( Val( cSequencia ) - 1, 3 )
			EndIf

		EndIf

	EndIf

	If oGrid:GetValue( 'TYZ_SEQ' ) != cSequencia
		fAtuTYZ( oGrid, cSequencia )
	EndIf

Return cSequencia

//---------------------------------------------------------------------
/*/{Protheus.doc} fAltAfa
Verifica se a linha atual é alteração e não uma linha incluída.

@author Gabriel Sokacheski
@since 22/11/2022

@param oGrid, grid dos registros da tabela TYZ

@return lAlt, indica se o afastamento foi alterado
/*/
//---------------------------------------------------------------------
Static Function fAltAfa( oGrid )

	Local aArea := GetArea( 'SR8' )

	Local lAlt := .F.

	DbSelectArea( 'SR8' )
	DbSetOrder( 2 )

	If DbSeek( xFilial( 'SR8' ) + oGrid:GetValue( 'TYZ_MAT' ) + oGrid:GetValue( 'TYZ_SEQ' ) )

		If oGrid:GetValue( 'TYZ_DTSAID' ) != SR8->R8_DATAINI .Or. oGrid:GetValue( 'TYZ_DTALTA' ) != SR8->R8_DATAFIM
			lAlt := .T.
		EndIf

	EndIf

	RestArea( aArea )

Return lAlt

//---------------------------------------------------------------------
/*/{Protheus.doc} fAtuTYZ
Atualiza a sequência do afastamento na tabela e grid.

@author Gabriel Sokacheski
@since 22/11/2022

@param oGrid, grid dos registros da tabela TYZ
@param cSequencia, sequência que será gravada no registro da TYZ

/*/
//---------------------------------------------------------------------
Static Function fAtuTYZ( oGrid, cSequencia )

	DbSelectArea( 'TYZ' )
	DbSetOrder( 1 )

	If DbSeek( xFilial( 'TYZ' ) + SRA->RA_MAT + DtoS( oGrid:GetValue( 'TYZ_DTSAID' ) ) )

		RecLock( 'TYZ', .F. )
			( 'TYZ' )->TYZ_SEQ := cSequencia
		( 'TYZ' )->( MsUnLock() )

	EndIf

	oGrid:LoadValue( 'TYZ_SEQ', cSequencia )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fChkDtAfas
Função auxiliar para verficação no CHKTA685 sendo validadas as datas
do atestado.

@type function

@source MDTA685.prx

@author Guilherme Benekendorf
@since 29/10/2014

@sample fChkDtAfas()

@return lRet, Lógico, Determina se ocorreu inconsistência.
/*/
//---------------------------------------------------------------------
Static Function fChkDtAfas()

	Local lRet := .T.
	Local nX
	Local aChkDtAf := { 1 , 2 , 9 } //Data Inicio Afastamento////Data Final  Afastamento////Data da Consulta

	For nX := 1 To Len( aChkDtAf )
		lRet := MDT685DtAf( aChkDtAf[ nX ] )
		If !lRet
			Exit
		EndIf
	Next nX

Return lRet

//-------------------------------------------------------------------------------
/*/{Protheus.doc} fChkAteCID
Verifica se o atestado do mesmo CID. Caso houver um atestado em um perio-
do do parametro MV_NG2QTVE será realizado a ação conforme parametro MV_NG2VEAT

@type    function
@author  Guilherme Benekendorf
@since   01/10/2014
@sample  fChkAteCID( oModel )
@param   oModel, Objeto, Modelo de dados

@return lRet, Lógico, Indica se há informação atestado com o mesmo CID no período.
/*/
//-------------------------------------------------------------------------------
Static Function fChkAteCID( oModel )

	Local lRet		:= .T.
	Local lExistAte := .F.
	Local cIndPro	:= SuperGetMv( "MV_NG2VEAT" , .F. , "1"  ) //Indica o processo a ser seguido.
	Local nQntDias  := 0
	Local aArea		:= GetArea()
	Local aAreaTNY	:= TNY->( GetArea() )
	Local cAtest    := ''
	Local cCID      := ''

	//Variável de controle de execução automática
	Local lExecAuto := IsBlind() .Or. !( AllTrim( FunName() ) $ "MDTA685/MDTA410/MDTA110F/MDTA686" )

	//Utilização do Modelo e Grid.
	Local oGrid
	Local nLenGrid 	:= 0

	oGrid 	:= oModel:GetModel( 'TYZDETAIL' ) //Posiciona no Model da Grid
	nLenGrid:= oGrid:Length()

	If cPaisLoc == 'BRA'
		nQntDias :=  Val( SuperGetMv( "MV_NG2QTVE" , .F. , "60" ) )
	EndIf

	If cIndPro <> "1" .And. !Empty( oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ) )

		dbSelectArea( "TNY" )
		dbSetOrder( 3 ) //TNY_FILIAL+TNY_CID+TNY_NUMFIC
		dbSeek( xFilial( "TNY" ) + oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ) + oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ) )
		While TNY->( !EoF() ) .And. xFilial( "TNY" ) == TNY->TNY_FILIAL 	.And. ;
			  oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ) == TNY->TNY_CID 	.And. ;
			  oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ) == TNY->TNY_NUMFIC

			//Verifica se o numero do atestado é diferente, caso contrário deixa preencher por causa da Continuação.
			If oModel:GetValue( 'TNYMASTER1', 'TNY_NATEST' ) <> TNY->TNY_NATEST .And. ;
				oModel:GetValue( 'TNYMASTER1', 'TNY_EMITEN' ) == TNY->TNY_EMITEN
				If Empty( TNY->TNY_CODAFA )
					If ( TNY->TNY_DTINIC + nQntDias ) >= oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' )
						lExistAte := .T.
						cAtest := TNY->TNY_NATEST
						cCID   := TNY->TNY_CID
						Exit
					EndIf
				Else

					dbSelectArea( "TYZ" )
					dbSetOrder( 2 ) // TYZ_FILIAL + TYZ_NATEST
					If dbSeek( xFilial( "TYZ" ) + TNY->TNY_NATEST )
						While TYZ->( !EoF() ) 						.And. ;
								TYZ->TYZ_FILIAL == xFilial( "TYZ" ) 	.And. ;
								TYZ->TYZ_NATEST == TNY->TNY_NATEST

							If ( TYZ->TYZ_DTSAID + nQntDias ) >= oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' )
								lExistAte := .T.
								cAtest := TNY->TNY_NATEST
								cCID   := TNY->TNY_CID
								Exit
							EndIf

							TYZ->( dbSkip() )
						End
					EndIf

				EndIf
			EndIf
			TNY->( dbSkip() )
		End

		//Caso já existir um atestado
		If lExistAte

			If cIndPro == "2" //Questiona
				
				//Caso não for execução automática
				If !lExecAuto
				
					//"Este funcionário já possui o atestado "###" para o CID "###" Deseja incluir um novo atestado mesmo assim?"
					lRet := MsgYesNo( STR0161 + AllTrim( cAtest ) + STR0162 + AllTrim( cCID ) + "." + STR0163 )

				Else

					//Informa ao usuário que o conteúdo do parâmetro deve ser alterado
					Help( ' ', 1, STR0153, , STR0246, 2, 0, , , , , , { STR0247 } ) //"O parâmetro MV_NG2VEAT está definido como '2', porém essa opção não é permitida na execução automática" ## "Favor alterar o conteúdo do parâmetro"
					lRet := .F.

				EndIf

			ElseIf cIndPro == "3" //Bloqueia

				//Informa ao usuário que não é permitido
				Help( ' ', 1, STR0153, , STR0161 + AllTrim( cAtest ) + STR0162 + AllTrim( cCID ) + ".", 2, 0, , , , , , { STR0164 } ) //"Este funcionário já possui o atestado "XXX" para o CID XXX." ## "Favor alterar o atestado e informar novo período de afastamento."
				lRet := .F.

			EndIf

		EndIf

	EndIf

	RestArea( aArea )
	RestArea( aAreaTNY )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} a685AtuDia
Calcula os campos R8_DURACAO, R8_DPAGAR e R8_DIASEMP
@type function

@author Andre E. Perez Alvarez
@since 06/08/2008

@param dDtIni,	  Date, 	Data de início.
@param __dDtFim,  Date, 	Data fim.
@param cContin,   Caracter, Continuação.
@param cContAfa,  Caracter, Continuação do afastamento.
@param dAntDtFim, Date,		Data do afastamento anterior.
@param nAntDEmp,  Numérico, Quantidade de dias empresa.
@param nAntDPag,  Numérico, Quantidade de dias a pagar.

@return Array, Com a quantidade duração, dias empresa, dias a pagar e dias pagos.
/*/
//---------------------------------------------------------------------
Function a685AtuDia( dDtIni, __dDtFim, cContin, cContAfa, dAntDtFim, nAntDEmp, nAntDPag, nQtdEmp )

	Local aArea		 := GetArea()
	Local nDuracao	 := 0
	Local nDiasEmp	 := 0
	Local nDiasPagar := 0
	Local nDiasPagos := 0
	Local nTotDias	 := SuperGetMv( "MV_NG2TOAF" , .F. , 15 )
	Local dDtFim	 := __dDtFim
	Local dDtFimPer
	Local aRotFol	 := fGetRotTipo("1")
	Local aPerAtual
	Local cPerAtual

	If Len(aRotFol) > 0
		cPerAtual := fPerFech( SRA->RA_PROCES , aRotFol[1] , , @aPerAtual )
	EndIf

	If Empty( cPerAtual )
		dDtFimPer	:= dDataBase
	Else
		DbSelectArea("RCH")
		RCH->(DbSetOrder(4)) //RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG
		RCH->(DbSeek(xFilial("RCH") + SRA->RA_PROCES + aRotFol[1] + cPerAtual ))
		dDtFimPer 	:= RCH->RCH_DTFIM
	EndIf

	If ValType( nQtdEmp ) == "N"
		nTotDias := nQtdEmp
	EndIf

	If lCpoDura
		//Calcula duração do atestado
		If !Empty(dDtFim)
			nDuracao := (dDtFim-dDtIni)+1

			//Caso não seja continuação de afastamento ou o atestado anterior foi pelo INSS
			If Empty(cContin) .Or. cContin == "2"
				nDiasEmp	:= nTotDias
				nDiasPagar	:= If( nDuracao > nDiasEmp , nDiasEmp , nDuracao )
			Else //Continuacao de afastamento
				nDiasEmp   := If( ( dDtIni - dAntDtFim ) > 60,  nTotDias, nAntDEmp - nAntDPag )
				nDiasPagar := If( nDuracao > nDiasEmp , nDiasEmp , nDuracao )
			EndIf

			If cPaisLoc == "PAR"
				nDiasEmp	:= 3 //No Paraguai, se o func. se afastar mais do que 3 dias, o IPS paga para o func.
				nDiasPagar	:= If( nDuracao > nDiasEmp, 0,nDuracao)
			EndIf
		Else
			nDuracao:= 999
			If cContin == "1"
				nDiasEmp   := If( ( dDtIni - dAntDtFim ) > 60 ,  nTotDias , nAntDEmp - nAntDPag )
				nDiasPagar := If( nDuracao > nDiasEmp , nDiasEmp , nDuracao )
			Else
				nDiasEmp:= nTotDias
				nDiasPagar:= nTotDias
			EndIf
		EndIf

		// Validação para popular os campos R8_DPAGOS, R8_SDPAGAR
		If !Empty(dDtFim)
			// Se data fim for superior a data atual não deverá pagar esses dias
			If dDtFim > dDtFimPer
				// Se data atual igual a data de inicio pagará somente 1 dia
				If dDtIni == dDtFimPer
					nDiaspagos := ( dDtFimPer - dDtIni ) + 1
				// Se data inicio com inicio antes pagará somente até a data atual
				ElseIf dDtIni < dDtFimPer
					If DateDiffDay(dDtIni,dDtFimPer) >= nDiasEmp
						nDiaspagos := nDiasEmp
					Else
						nDiaspagos := ( dDtFimPer - dDtIni ) + 1
					EndIf
				ElseIf dDtIni > dDtFimPer // Se data inicio e data fim for superior não deverá pagar
					nDiaspagos := 0
				EndIf
			Else
				If DateDiffDay(dDtIni,dDtFim) >= nDiasEmp
					nDiaspagos := nDiasEmp
				Else
					nDiaspagos := ( dDtFim - dDtIni ) + 1
				EndIf
			EndIf
		Else //Se não possuir data fim no Afastamento será considerada a Data atual como Fim.
			//Verificar se validação é necessária para quando não possuir data fim do afastamento.
			//Somente add os dias se data inicio começar antes da data atual, caso contrário ñ será considerado pago
			If dDtIni <= dDtFimPer
				If DateDiffDay(dDtIni,dDtFimPer) >= nDiasEmp
					nDiaspagos := nDiasEmp
				Else
					//Se data inicio do afastamento for igual data atual será considerado o dia como pago
					nDiaspagos := ( dDtFimPer - dDtIni ) + 1
				EndIf
			EndIf
		EndIf

	EndIf
	RestArea(aArea)

Return { nDuracao , nDiasEmp , nDiasPagar, nDiasPagos }

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685AFAS
Visualizar afastamentos do funcionario

@type function

@source MDTA685.prx

@author Denis Hyroshi de Souza
@since 01/06/2004

@sample MDT685AFAS()

@return Vazio.
/*/
//---------------------------------------------------------------------
Function MDT685AFAS()

	Local aArea := GetArea()
	Local aColBrw
	Local oDlgAfast
	Local oBrwAfas
	Local oTempTable
	Local cTRBAFA 	:= GetNextAlias()

	Default lCpoIndSr8 := .F.

	Default nIndSR8 := f685RetOrder( 'SR8', 'R8_FILIAL+R8_NATEST' )

	If FwIsInCallStack( 'MDTA686' ) .And. SR8->( FieldPos( 'R8_NATEST' ) ) > 0

		If nIndSR8 > 0
			lCpoIndSr8 := .T.
		EndIf

	EndIf

	dbSelectArea( "TM0" )
	dbSetOrder( 1 )

	If !dbSeek( xFilial( "TM0" ) + M->TNY_NUMFIC )
		Help( ,, STR0111,, STR0077, 6, 6 ) // "Ficha Médica Inválida!"
		RestArea(aArea)
		Return .F.
	EndIf

	dbSelectArea( "SRA" )
	dbSetOrder( 1 )

	If !dbSeek( xFilial( "SRA", TM0->TM0_FILFUN) + TM0->TM0_MAT )
		Help( ,, STR0111,, STR0078, 6, 6 ) // "Não foi encontrada a Matrícula relacionada a Ficha Médica do funcionário!"
		RestArea(aArea)
		Return .F.
	EndIf

	aDBF6 := {}
	aAdd( aDBF6, { "DTALT", "D", TamSx3('R8_DATA')[1], TamSx3('R8_DATA')[2] } )
	aAdd( aDBF6, { "TIPOA", "C", 60, 0 } )
	aAdd( aDBF6, { "DTINI", "D", TamSx3('R8_DATAINI')[1], TamSx3('R8_DATAINI')[2] } )
	aAdd( aDBF6, { "DTFIM", "D", TamSx3('R8_DATAFIM')[1], TamSx3('R8_DATAFIM')[2] } )
	If lCpoIndSr8
		aAdd( aDBF6, { "NATEST", "C", TamSx3('R8_NATEST')[1], TamSx3('R8_NATEST')[2] } )
	EndIf
	aAdd( aDBF6, { "CODCID", "C", TamSx3('R8_CID')[1], TamSx3('R8_CID')[2] } )

	// Cria tabela temporária para armazenar os afastamentos
	oTempTable := FWTemporaryTable():New( cTRBAFA, aDBF6 )
	oTempTable:AddIndex( "1", {"DTINI"} )
	oTempTable:Create()

	dbSelectArea( "SR8" )
	dbSetOrder( 1 )
	dbSeek( xFilial( "SRA", TM0->TM0_FILFUN ) + SRA->RA_MAT )

	While !EoF() .And. SR8->R8_FILIAL + SR8->R8_MAT == xFilial("SRA", TM0->TM0_FILFUN) + SRA->RA_MAT

		dbSelectArea( cTRBAFA )

		RecLock(cTRBAFA,.T.)

			(cTRBAFA)->DTALT := SR8->R8_DATA

			If !Empty( SR8->R8_TIPOAFA )
				(cTRBAFA)->TIPOA := SR8->R8_TIPOAFA + " - " +;
					SubStr( NGSEEK( "RCM", SR8->R8_TIPOAFA, 1, "RCM->RCM_DESCRI" ), 1, 54 )
			Else
				dbSelectArea( "SX5" )
				dbSetOrder( 1 )
				dbSeek( xFilial( "SX5" ) + "30" + SR8->R8_TIPO )

				(cTRBAFA)->TIPOA := SR8->R8_TIPO + " - " + X5Descri()
			EndIf

			(cTRBAFA)->DTINI := SR8->R8_DATAINI
			(cTRBAFA)->DTFIM := SR8->R8_DATAFIM

			If lCpoIndSr8
				(cTRBAFA)->NATEST:= SR8->R8_NATEST
			EndIf

			(cTRBAFA)->CODCID := SR8->R8_CID

		MsUnLock(cTRBAFA)

		dbSelectArea("SR8")
		dbSkip()
	End

	dbSelectArea(cTRBAFA)
	dbGoTop()

	If reccount() = 0
		MsgInfo(STR0079) // "O funcionário não tem afastamento."
		oTempTable:Delete()
		RestArea(aArea)
		Return
	EndIf

	oDlgAfast := MSDialog():New(0, 0, 400, 650, STR0027,,,,, CLR_BLACK, CLR_WHITE,,, .T.)

	// Panel principal (preenche a tela toda)
	oPnlDlg := TPanel():New(,,, oDlgAfast,,,,,,,, .F., .F.)
		oPnlDlg:Align := CONTROL_ALIGN_ALLCLIENT

	//Panel superior (contem os campos)
	oPnlFld := TPanel():New(,,, oPnlDlg,,,,,,, 20, .F., .F.)
		oPnlFld:Align := CONTROL_ALIGN_TOP

	// Panel inferior (comtem o browse)
	oPnlBrw := TPanel():New(,,, oPnlDlg,,,,,,,, .F., .F.)
		oPnlBrw:Align := CONTROL_ALIGN_ALLCLIENT

	// Matrícula
	TSay():New(5, 4, {|| OemtoAnsi(STR0080) }, oPnlFld,,, .F., .F., .F., .T., CLR_BLACK, CLR_WHITE, 200, 010 )
	TGet():New(3, 30, {|u| IIf( PCount() > 0, SRA->RA_MAT := u, MDTHideCpo( SRA->RA_MAT, "RA_MAT" ) ) },;
		oPnlFld, 30, 10, "@!",, CLR_BLACK, CLR_WHITE,,,, .T., "",, {|| .F. }, .F., .F.,, .F., .F.,,,,,, .T.)

	//Nome
	TSay():New(5, 84, {|| OemtoAnsi(STR0069) }, oPnlFld,,, .F., .F., .F., .T., CLR_BLACK, CLR_WHITE, 200, 010 )
	TGet():New(3, 102, {|u| IIf( PCount() > 0, SRA->RA_NOME := u, MDTHideCpo( SRA->RA_NOME, "RA_NOME" ) ) },;
		oPnlFld, 120, 10, "@!",, CLR_BLACK, CLR_WHITE,,,, .T., "",, {|| .F. }, .F., .F.,, .F., .F.,,,,,, .T.)

	// Admissão
	TSay():New(5, 240, {|| OemtoAnsi(STR0081) }, oPnlFld,,, .F., .F., .F., .T., CLR_BLACK, CLR_WHITE, 200, 010 )
	TGet():New(3, 270, {|u| IIf( PCount() > 0, SRA->RA_ADMISSA := u, SRA->RA_ADMISSA ) },;
		oPnlFld, 50, 10, "@!",, CLR_BLACK, CLR_WHITE,,,, .T., "",, {|| .F. }, .F., .F.,, .F., .F.,,,,,, .T.)

	// Define as colunas do browse
	aColBrw := {}
	aAdd( aColBrw , fAddCol("{|| DTALT  }", STR0082, "R8_DATA" ) )
	aAdd( aColBrw , fAddCol("{|| TIPOA  }", STR0083, "R8_TIPOAFA" ) )
	aAdd( aColBrw , fAddCol("{|| DTINI  }", STR0084, "R8_DATAINI" ) )
	aAdd( aColBrw , fAddCol("{|| DTFIM  }", STR0085, "R8_DATAFIM" ) )
	If lCpoIndSr8
		aAdd( aColBrw , fAddCol("{|| NATEST  }", STR0085, "R8_NATEST" ) )
	EndIf
	aAdd( aColBrw , fAddCol("{|| CODCID  }", 'C.I.D.', "R8_CID" ) )

	//Monta o browse com os afastamentos
	oBrwAfas := FWBrowse():New()
		oBrwAfas:SetDataTable(.T.) // Define a utilização de tabela
		oBrwAfas:SetAlias(cTRBAFA) // Define a tabela utilizada
		oBrwAfas:SetColumns(aColBrw) // Define as colunas preestabelecidas
		oBrwAfas:SetOwner(oPnlBrw) // Define o objeto pai
		oBrwAfas:DisableReport() // Desabilita botao de impressao
		oBrwAfas:DisableConfig() // Desabilita botao de configuracao
		oBrwAfas:Activate() // Ativa o browse

	// Ativa a dialog
	oDlgAfast:Activate(,,, .T., {||.T.},,;
		{|| EnchoiceBar(oDlgAfast,;
			{||oDlgAfast:End()},;
			{||oDlgAfast:End()};
		) } )

	oTempTable:Delete()

	RestArea(aArea)
Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fAddCol
Define objeto das colunas

@type function
@source MDTA685.prx

@param cData , Caractere, Valor do campo
@param cTitle ,Caractere, Array de Riscos
@param cField, Campo, Nome do campo

@sample fAddCol("{|| CODCID  }", 'C.I.D.', "R8_CID" )
@return .T.

@author Bruno Lobo de Souza
@since 02/04/2020

/*/
//---------------------------------------------------------------------
Static Function fAddCol( cData, cTitle, cField )

	Local oColumn
	Local aFieldSize := IIf( cField == "R8_TIPOAFA", { 60, 0 }, TamSX3( cField ) )

	//Adiciona as colunas do markbrowse
	oColumn := FWBrwColumn():New() //Cria objeto
		oColumn:SetAlign( CONTROL_ALIGN_LEFT ) //Define alinhamento
		oColumn:SetData( &(cData) ) //Define valor
		oColumn:SetEdit( .F. ) //Indica se é editavel
		oColumn:SetTitle( cTitle ) //Define titulo
		oColumn:SetType( GetSx3Cache( cField, 'X3_TIPO' ) ) //Define tipo
		oColumn:SetSize( aFieldSize[1] + aFieldSize[2] ) //Define tamanho
		oColumn:SetPicture( X3Picture(cField) ) //Define picture

Return oColumn

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685SEQ
Função para determinar a sequência dos registros da Afastamentos.
Será utilizada a maior sequência encontrada, seja na TYZ ou SR8.

@author Guilherme Freudenburg
@since 08/03/2017

@param nVal, Numérico, caso 1 é chamado pelo X3_RELACAO, caso 2 é chamado pelo X3_VALID.

@return cSeq, Caracter, Sequência do afastamento ou Sempre Verdadeiro.
/*/
//---------------------------------------------------------------------
Function MDT685SEQ( nVal )

	Local cMat := ''
	Local cSeq := '000'
	Local cFilFun := ''
	Local cNumFic := ''
	Local cSeqBas := '000'
	Local cSeqTrb := '000'
	Local cAliasTYZ := GetNextAlias()
	Local cAliasSR8 := ''

	Local nLenGrid

	Local oModel
	Local oGrid

	Default nVal := 1 //Caso seja chamado pelo X3_RELACAO

	If IsInCallStack("MDTA410")
		cNumFic := M->TNY_NUMFIC
	Else
		oModel 	 := FWModelActive() //Ativa modelo utilizado.

			oGrid 	 := oModel:GetModel( 'TYZDETAIL' ) //Posiciona no Model da Grid
			nLenGrid := oGrid:Length()
			cNumFic  := oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' )

	EndIf

	cFilFun := xFilial( 'TYZ', Posicione( 'TM0', 1, xFilial( 'TM0' ) + cNumFic, 'TM0_FILFUN' ) )
	cMat := Posicione( 'TM0', 1, xFilial( 'TM0' ) + cNumFic, 'TM0_MAT' )

	// Busca a última sequência lançada na tabela TYZ
	BeginSQL Alias cAliasTYZ
		SELECT 
			TYZ.TYZ_SEQ
		FROM %table:TYZ% TYZ
		WHERE 
			TYZ.TYZ_FILIAL = %exp:cFilFun%
			AND TYZ.TYZ_MAT = %exp:cMat%
			AND TYZ.%NotDel%
		ORDER BY TYZ_SEQ DESC
	EndSQL

	dbSelectArea( cAliasTYZ )
	dbGoTop()

	If !Empty( ( cAliasTYZ )->TYZ_SEQ ) .And. ( cAliasTYZ )->TYZ_SEQ > cSeqBas

		cSeqBas := ( cAliasTYZ )->TYZ_SEQ

	EndIf

	( cAliasTYZ )->( dbCloseArea() )

	cAliasSR8 := GetNextAlias()
	cFilFun := xFilial( 'SR8', Posicione( 'TM0', 1, xFilial( 'TM0' ) + cNumFic, 'TM0_FILFUN' ) )

	// Busca a última sequência lançada na tabela SR8
	BeginSQL Alias cAliasSR8
		SELECT 
			SR8.R8_SEQ
		FROM %table:SR8% SR8
		WHERE 
			SR8.R8_FILIAL = %exp:cFilFun%
			AND SR8.R8_MAT = %exp:cMat%
			AND SR8.%NotDel%
		ORDER BY SR8.R8_SEQ DESC
	EndSQL

	dbSelectArea( cAliasSR8 )
	dbGoTop()

	If !Empty( ( cAliasSR8 )->R8_SEQ ) .And. ( cAliasSR8 )->R8_SEQ > cSeqBas

		cSeqBas := ( cAliasSR8 )->R8_SEQ

	EndIf

	//|---------------------------------|
	//| Busca a ultima sequência da TRB |
	//|---------------------------------|

	If IsInCallStack("MDTA410")
		If Len(aCols) > 1 .And. !Empty( aCols[n,2] )
			cSeqTrb := aCols[n,1]
		EndIf
	Else

			If nLenGrid >= 1 .And. !Empty( oGrid:GetValue( "TYZ_SEQ" ) ) .And. !Empty( oGrid:GetValue( "TYZ_DTSAID" ) ) //Verifica se possui algum registro e está preenchido.
				oGrid:GoLine( nLenGrid )
				cSeqTrb := oGrid:GetValue( "TYZ_SEQ" )
			EndIf

	EndIf

	//|--------------------------------|
	//|Verifica qual a sequência maior |
	//|--------------------------------|
	cSeq := If( cSeqBas >= cSeqTrb, cSeqBas, cSeqTrb )
	cSeq := SOMA1(cSeq)

	//|-------------------------------------------|
	//| Adiciona o valor ao Campo de Sequência.   |
	//|-------------------------------------------|
	If nVal == 2 //Caso seja chamado pelo X3_VALID

			If IsInCallStack("MDTA410")
				M->TYZ_SEQ := cSeq
			Else
				oGrid:LoadValue( "TYZ_SEQ"  , cSeq  )
			EndIf

	EndIf

Return If( nVal == 2 , .T. , cSeq )

//---------------------------------------------------------------------
/*/{Protheus.doc} A685TM5
Grava um exame de NR7 conformo o parametro MV_NG2D685.

@type function

@source MDTA685.prw

@author Taina A. Carodoso
@since 11/04/11

@sample A685TM5(3)

@return Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
Function A685TM5( nOpcx , nDiasEx )

	Local lIncExa	:= .F.
	Local nDiasPre	:= ( TNY->TNY_DTFIM - TNY->TNY_DTINIC ) + 1 // Dia previsto para retorno

	Default nDiasEx := 0

	If nDiasEx <= nDiasPre
		If nOpcx == MODEL_OPERATION_INSERT
			dbSelectArea("TM5")
			dbSetORder(1)
			If !dbSeek(xFilial("TM5")+TNY->TNY_NUMFIC+DTOS(TNY->TNY_DTFIM)+"NR7")
				RecLock("TM5",.T.)
				TM5->TM5_FILIAL := xFilial("TM5")
				TM5->TM5_NUMFIC := TNY->TNY_NUMFIC
				TM5->TM5_EXAME  := "NR7"
				TM5->TM5_DTPROG := TNY->TNY_DTFIM
				TM5->TM5_ORIGEX	:= "2" //Ocupacional
				TM5->TM5_NATEXA	:= "4"  //Retorno Trabalho
				MsUnlock("TM5")
				//lIncExa indica que foi gerado um exame NR7
				lIncExa := .T.
			EndIf
		ElseIf nOpcx == MODEL_OPERATION_DELETE
			dbSelectArea("TM5")
			dbSetORder(1)
			If dbSeek(xFilial("TM5")+aOldTNY[1][_NUMFIC_]+DTOS(aOldTNY[1][_DTFIM_])+"NR7   ")
				RecLock("TM5",.F.)
				dbDelete()
				MsUnlock("TM5")
			EndIf
		EndIf
	EndIf

	If nOpcx == MODEL_OPERATION_UPDATE .And. TNY->TNY_DTFIM <> aOldTNY[1][_DTFIM_]
		If nDiasEx <= nDiasPre
			dbSelectArea("TM5")
			dbSetORder(1)
			If dbSeek(xFilial("TM5")+TNY->TNY_NUMFIC+DTOS(aOldTNY[1][_DTFIM_])+"NR7")
				RecLock("TM5",.F.)
				TM5->TM5_DTPROG := TNY->TNY_DTFIM
				MsUnlock("TM5")
			Else
				RecLock("TM5",.T.)
				TM5->TM5_FILIAL := xFilial("TM5")
				TM5->TM5_NUMFIC := TNY->TNY_NUMFIC
				TM5->TM5_EXAME  := "NR7"
				TM5->TM5_DTPROG := TNY->TNY_DTFIM
				TM5->TM5_ORIGEX := "2" //Ocupacional
				TM5->TM5_NATEXA := "4" //Retorno Trabalho
				MsUnlock("TM5")
				//lIncExa indica que foi gerado um exame NR7
				lIncExa := .T.
			EndIf
		Else
			dbSelectArea("TM5")
			dbSetORder(1)
			If dbSeek(xFilial("TM5")+TNY->TNY_NUMFIC+DTOS(aOldTNY[1][_DTFIM_])+"NR7")
				If nDiasEx >= nDiasPre .And. Empty(TM5->TM5_DTRESUL)
					RecLock("TM5",.F.)
					dbDelete()
					MsUnlock("TM5")
				EndIf
			EndIf
		EndIf
	EndIf

	If lIncExa//Foi incluso exame NR7
		Help( , , STR0153 , , STR0156 + DToC(TNY->TNY_DTFIM) +".", 5 , 5 )//"Foi gerada uma pendência nos exames do funcionário: Este colaborador deverá fazer o exame de retorno ao trabalho previsto para o dia " //"Atenção"
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685TYZ
Realiza a validação da Grid de afastamentos.

@type function

@source MDTA685.prw

@author Guilherme Freudenburg
@since 08/03/2017

@sample MDT685TYZ( oModel )

@return Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
Function MDT685TYZ( oModel )

	Local cSeqAfas 	:= ''

	Local dDataIni	:= SToD( '' )
	Local dDataFim	:= SToD( '' )
	Local dDataAlt	:= SToD( '' )

	Local lRet     	:= .T.
	Local lDelet	:= Nil
	Local TotDel   	:= .T.
	Local lBloqueio := Mdt685BloF( .F., oModel )

	Local nX       	:= 0
	Local nDtAl    	:= 1
	Local nLenGrid	:= 0
	Local nGridAtu	:= 0

	Local oGrid		:= Nil

	Default oModel := FWModelActive()  //Copia o Model utilizado.

	oGrid	 := oModel:GetModel( 'TYZDETAIL' ) //Posiciona no Model da Grid
	nLenGrid := oGrid:Length()   //Quantidade Total de linhas do oGrid.
	nGridAtu := oGrid:GetLine() //Linha Atual Posicionada.
	lDelet   := !( oGrid:IsDeleted() ) //Verifica se o registro atual está deletado.
	dDataIni := oGrid:GetValue( "TYZ_DTSAID" )
	dDataFim := oGrid:GetValue( "TYZ_DTALTA" )
	cSeqAfas := oGrid:GetValue( "TYZ_SEQ" )

	//Se o Cod. Afastasmento estiiver preenchido
	If !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' ))

		If !IsInCallStack( "MDTA410" )
			For nX := 1 To nLenGrid //Checa se há somente linhas deletadas
				oGrid:GoLine( nX )
				If !( oGrid:IsDeleted() )
					TotDel := .F.
					Exit
				EndIf
			Next nX
		Else
			TotDel := .F.
		EndIf

		//Se houver somente uma linha em branco ou somente linhas deletadas
		If (nLenGrid == 1 .And. Empty(oGrid:GetValue( "TYZ_DTSAID" )) .And. Empty(oGrid:GetValue( "TYZ_DTALTA" )) ) .Or. TotDel
			Help( " ", 1, 'OBRIGAT2', ,FwX2Nome("TYZ"), 5, 1 )
			lRet := .F.
		EndIf

	EndIf

	If lRet

		For nX := 1 To nLenGrid
			oGrid:GoLine( nX )
			If !( oGrid:IsDeleted() ) //Verifica se não foi deletado.

				If Empty(oGrid:GetValue( "TYZ_DTSAID" )) .And. Empty(oGrid:GetValue( "TYZ_DTALTA" ))
					oGrid:DeleteLine()
				Else
					If Empty( dDataAlt ) .And. nDtAl > 1 .And. nGridAtu <> nX .And. cSeqAfas < oGrid:GetValue( "TYZ_SEQ" ) //Verifica se a Data Fim do registro anterior foi preenchido.
						Help( , , STR0112 , , STR0195, 5 , 5 )//"Existe um afastamento sem a 'Dt. Alta' preenchida, não sendo possível ter um afastamento posterior a ele."
						lRet := .F.
					EndIf
					If !Empty(oGrid:GetValue( "TYZ_DTSAID" )) .Or. !Empty(oGrid:GetValue( "TYZ_DTALTA" ))
						If Empty(oGrid:GetValue( "TYZ_DTSAID" )) .And. !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' ))
							Help( 1 , " " , "OBRIGAT2" , , STR0196 )//" Dt. Saida "
							lRet := .F.
						EndIf
					EndIf

					dDataAlt := oGrid:GetValue( "TYZ_DTALTA" ) //Adiciona a Data de Alta do registro atual.
					nDtAl += 1

					If lRet .And. lDelet .And. nGridAtu <> nX  .And. ( ( oGrid:GetValue( "TYZ_DTSAID" ) >= dDataIni .And. oGrid:GetValue( "TYZ_DTSAID" ) <= dDataFim ) .Or. ;
						( oGrid:GetValue( "TYZ_DTALTA" ) >= dDataIni .And. oGrid:GetValue( "TYZ_DTALTA" ) <= dDataFim ) )
						Help( , , STR0112 , , STR0197, 5 , 5 )//'Já existe um afastamento para este mesmo período.'
						lRet := .F.
					EndIf
				EndIf
			EndIf

			If lRet .And. oModel:GetOperation() == 4;
			.And. ( oGrid:IsFieldUpdated( 'TYZ_DTSAID' ) .Or. oGrid:IsFieldUpdated( 'TYZ_DTALTA' ) );
			.And. lBloqueio .And. fValTemAfa( oModel, nX )

				//---------------------------------------------------------------------------------------------------
				// Mensagens:
				// "Atenção"
				// "Não será possível alterar o afastamento pois o roteiro de folha do período atual está bloqueado"
				// "Desbloqueie o roteiro para alterar o afastamento"
				//---------------------------------------------------------------------------------------------------
				Help( Nil, Nil, STR0153, Nil, STR0252 + '.', 1, 0, Nil, Nil, Nil, Nil, Nil, { STR0259 + '.' } )
				lRet := .F.
				Exit

			EndIf

		Next nX

	EndIf

	If lRet

		For nX := 1 To nLenGrid

			oGrid:GoLine( nX )

			If ( oGrid:IsDeleted() )

				lRet := fTemConti( oModel, oGrid, .T. )

			EndIf

		Next nX

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Mdt685BloF
Valida se a folha está bloqueada

@author Gabriel Sokacheski
@since 31/07/2023

@param lMensagem, indica se deve apresentar mensagem
@param oModel, modelo da rotina de atestado médico

@return lRet, indica se a folha está bloqueada
/*/
//---------------------------------------------------------------------
Function Mdt685BloF( lMensagem, oModel )

	Local aAreaRG3 := GetArea( 'RG3' )

	Local cChaveRG3	:= xFilial( 'RG3' ) + cEmpAnt + cFilAnt + SRA->RA_PROCES + fGetFolmes()
	Local cUsuario  := RetCodUsr()

	Local lRet 		:= .F.

	Local oMaster	:= oModel:GetModel( 'TNYMASTER1' )

	Default lMensagem := .F.

	DbSelectArea( 'RG3' )
	( 'RG3' )->( DbSetOrder( 4 ) )
	If ( 'RG3' )->( DbSeek( cChaveRG3 ) )

		While ( 'RG3' )->( !Eof() .And. RG3_FILIAL + RG3_EMP + RG3_FIL + RG3_PROCES + RG3_PERIOD == cChaveRG3  )

			If 'MDT' $ RG3->RG3_ROTEIR .And. dDataBase >= RG3->RG3_DTINI .And. dDataBase <= RG3->RG3_DTFIM;
			.And. !( cUsuario $ RG3->RG3_USER1 + "/" + RG3->RG3_USER2 )

				lRet := .T.

				If lMensagem

					If !( FWIsInCallStack( 'Tcfa040' ) .Or. FWIsInCallStack( 'MdtExe' ) )

						//---------------------------------------------------------------------------------------------------
						// Mensagens:
						// "Atenção"
						// "O roteiro de folha do período atual está bloqueado"
						// "O atestado ficará disponível na rotina Comunicar Atestados, desbloqueie o roteiro e comunique
						//	o atestado pela rotina"
						//---------------------------------------------------------------------------------------------------
						Help( Nil, Nil, STR0153, Nil, STR0255 + '.', 1, 0, Nil, Nil, Nil, Nil, Nil, { STR0256 + '.' } )

					Else

						//---------------------------------------------------------------------------------------------------
						// Mensagens:
						// "Atenção"
						// "O roteiro de folha do período atual está bloqueado"
						// "Este atestado ficará disponível na rotina Comunicar Atestados, desbloqueie o roteiro e comunique
						//	o atestado pela rotina"
						//---------------------------------------------------------------------------------------------------

						If aMeuRh[ 1 ]
							aAdd( aLogMdt, STR0255 + '.' + Space( 1 ) + oMaster:GetValue('TNY_NATEST') + ' - ' + STR0256 + '.' )
						Else
							MsgAlert( STR0255 + '.' + Space( 1 ) + STR0256 + '.', STR0153 )
						EndIf

					EndIf

				EndIf

			EndIf

			( 'RG3' )->( DbSkip() )

		End

	EndIf

	RestArea( aAreaRG3 )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fValTemAfa
Valida se existe afastamento

@author Gabriel Sokacheski
@since 31/07/2023

@param oModel, modelo de dados
@param nAfa, posição do registro da grid de afastamentos

@return lRet, indica se existe afastamento
/*/
//---------------------------------------------------------------------
Static Function fValTemAfa( oModel, nAfa )

	Local aAreaTYZ := GetArea( 'TYZ' )
	Local aAreaSR8 := GetArea( 'SR8' )

	Local cChave	:= xFilial( 'TYZ' ) + oModel:GetValue( 'TNYMASTER1', 'TNY_NATEST' )

	Local lRet		:= .F.

	Local nReg		:= 0

	DbSelectArea( 'TYZ' )
	( 'TYZ' )->( DbSetOrder( 2 ) )

	If ( 'TYZ' )->( DbSeek( cChave ) )

		While ( 'TYZ' )->( !Eof() .And. cChave == TYZ->TYZ_FILIAL + TYZ->TYZ_NATEST )

			nReg++

			If nReg == nAfa // Se o registro da TYZ for o registro atual posicionado da grid

				DbSelectArea( 'SR8' )
				( 'SR8' )->( DbSetOrder( 6 ) )

				If ( 'SR8' )->( DbSeek( xFilial( 'SR8' ) + SRA->RA_MAT + DtoS( TYZ->TYZ_DTSAID ) + TYZ->TYZ_TIPOAF ) )
					lRet := .T.
					Exit
				EndIf

			EndIf

			( 'TYZ' )->( DbSkip() )

		End

	EndIf

	RestArea( aAreaTYZ )
	RestArea( aAreaSR8 )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} FHcTOHn685
Converte hora em numero serial

@type function

@source MDTA685.prx

@param  cHora, Caracter, Hora.

@author Denis Hyroshi de Souza
@since 04/04/03

@sample FHcTOHn685( '11:11' )

@return nHora, Numérico, Retorna a quantidade horas.
/*/
//---------------------------------------------------------------------
Function FHcTOHn685(cHora)

	Local nHora := 0,nPos := 0,nHor := 0,nMin := 0

	nPos := At(":",cHora)
	nHor := Val(Substr(cHora,1,nPos-1))
	nMin := Val("0."+Alltrim(Substr(cHora,nPos+1)))

	If nMin > 0.59
		nMin := 0.59
	EndIf

	nHora := nHor + nMin

Return nHora

//---------------------------------------------------------------------
/*/{Protheus.doc} A685STATUS
Verifica se existe algum registro no ponto ja processado

@type function

@source MDTA685.prx

@param  cNATEST, Caracter, Número do atestado.

@author Denis Hyroshi de Souza
@since 01/04/04

@sample A685STATUS( '000001' )

@return lRet, Lógico, Retorna verdadeiro quando as informações estiverem corretas.
/*/
//---------------------------------------------------------------------
Function A685STATUS(cNATEST)

	Local lRet   := .F.
	Local oModel := FWModelActive() //Utilização do Modelo.

	dbSelectArea( "TM0" )
	dbSetOrder( 1 )
	dbSeek( xFilial( "TM0" ) + oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ) )

	dbSelectArea( "RF0" )
	dbSetOrder( 2 )
	dbSeek( xFilial( "RF0" , TM0->TM0_FILFUN ) + cNATEST )
	While !EoF() .And. xFilial( "RF0" , TM0->TM0_FILFUN ) + cNATEST == RF0->RF0_FILIAL + RF0->RF0_NATEST
		If RF0->RF0_ABONA == "S" .And. TM0->TM0_MAT == RF0->RF0_MAT
			lRet := .T.
		EndIf
		dbSkip()
	End

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685SECID
Valida o campo Grupo CID Complementares.

@type function

@source MDTA685.prx

@author Taina A. Cardoso
@since 12/04/2011

@sample MDT685SECID()

@return lRet, Lógico, Retorna verdadeiro quando não encontrar nenhuma problema.
/*/
//---------------------------------------------------------------------
Function MDT685SECID()

	Local oModel := FWModelActive()  //Copia o Model utilizado.
	Local oGrid  := oModel:GetModel( 'TKIDETAIL' )
	Local lRet 	 := .T.

	If !Empty(oGrid:GetValue( 'TKI_GRPCID' ))
		If !ExistCpo("TLG",oGrid:GetValue( 'TKI_GRPCID' ))
			lRet := .F.
		EndIf
		If oGrid:GetValue( 'TKI_GRPCID' ) <> Substr(oGrid:GetValue( "TKI_CID" ),1,3) .And. !Empty(oGrid:GetValue( "TKI_CID" ))
			oGrid:LoadValue('TKI_CID', Space(Len(oGrid:GetValue( "TKI_CID" ))) )
			oGrid:LoadValue('TKI_DOENCA', Space(Len(oGrid:GetValue( "TKI_DOENCA" ))) )
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685DOEN
Carrega a descricao do C.I.D.

@type function

@source MDTA685.prx

@author Taina A. Cardoso
@since 12/04/11

@sample MDT685DOEN()

@return lRet, Lógico, Retorna verdadeiro quando não encontrar nenhum problema.
/*/
//---------------------------------------------------------------------
Function MDT685DOEN()

	Local oModel 	:= FWModelActive()  //Copia o Model utilizado.
	Local oGrid 	:= oModel:GetModel( 'TKIDETAIL' )
	Local nLenGrid  := oGrid:Length()
	Local cGrupo 	:= oGrid:GetValue( "TKI_GRPCID" )
	Local cCid		:= oGrid:GetValue( "TKI_CID" )
	Local lDelet    := !( oGrid:IsDeleted() )
	Local f
	Local lRet 		:= .T.

	For f := 1 to nLenGrid
		oGrid:GoLine( f )
		If lDelet
			If Substr(cCid,1,3) == oGrid:GetValue( "TKI_GRPCID" ) .And. Empty(oGrid:GetValue( "TKI_CID" )) .And. Empty( cCid )
				Help( , , STR0111 , , STR0126 , 5 , 5 )//"Neste Atestado Médico já foi informado o Grupo relacionado a esta doença, sem que o Código CID fosse preenchido."
				lRet := .F.
			EndIf
		EndIf
	Next f
	If !Empty( cCid ) .And. lRet
		If !EXISTCPO( 'TMR' , cCid )
			lRet := .F.
		EndIf
		If cCid == oModel:GetValue( 'TNYMASTER1', 'TNY_CID' ) .And. lRet
			Help( , , STR0111 , , STR0121 + NGRETTITULO("TKI_CID") + STR0122 + NGRETTITULO("TNY_CID") + "." , 5 , 5 )//"O campo "##" não pode ser igual ao campo "
			lRet := .F.
		EndIf
		If !Empty(cGrupo) .And. cGrupo <> Substr( cCid , 1 , 3 ) .And. lRet
			Help( , , STR0111 , , STR0124 , 5 , 5 ) //"Informe um CID dentro do Grupo de CID informado."
			lRet := .F.
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685VLPR
Função para validação de parametros SX6.

@type function

@source MDTA685.prx

@param nParam = 1 - Não informar valores diferentes  de 1, 2 e 3
2 - Exibir uma mensagem indicando que o valor padrão no
Brasil é de 60 dias, caso seja informado um valor diferente.

@author Guilherme Benekendorf
@since 01/10/2014

@return lRet Boolean Indica se foi correta a informação.
/*/
//---------------------------------------------------------------------
Function MDT685VLPR( nParam )

	Local cConteudo := AllTrim( M->X6_CONTEUDO )

	Local lRet := .T.

	If nParam == 1 // MV_NG2VEAT

		If !( cConteudo $ '123' )

			ShowHelpDlg( STR0153, { STR0165 }, 2, { STR0166 }, 2 ) // "Os conteúdos não deverão ser diferentes de 1,2 ou 3."

			lRet := .F.

		EndIf

	ElseIf nParam == 2 // MV_NG2QTVE

		If cConteudo != '60'

			MsgInfo( STR0167, STR0153 ) // "O valor padrão no Brasil é de 60 dias."

		EndIf

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} M685DTVAL
Valida se o funcionário possui atestados cadastrados pelo
GPE no periodo.
@type function

@author Roger Rodrigues
@since 12/05/09

@param nOpcx, Numérico, Contêm a opção selecionada.

@return Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
Function M685DTVAL( nOpcx, oModel )

	Local cQuery 	 := ""
	Local cAliasSR8  := GetNextAlias()

	Local lRet 		 := .T.

	Local nLenGrid   := 0
	Local nX 		:= 0

	Local oGrid

	oGrid := oModel:GetModel( 'TYZDETAIL' ) // Posiciona no Model da Grid
	nLenGrid := oGrid:Length()

	For nX := 1 To nLenGrid
		oGrid:GoLine( nX )
		If !Empty( oGrid:GetValue( 'TYZ_DTSAID' ) )
			dbSelectArea( 'TYZ' )
			dbSetOrder( 2 ) // TYZ_FILIAL+TYZ_NATEST+DTOS(TYZ_DTSAID)+DTOS(TYZ_DTALTA)
			If !dbSeek( oGrid:GetValue( 'TYZ_FILIAL' ) + oGrid:GetValue( 'TYZ_NATEST' ) +;
				DTOS( oGrid:GetValue( 'TYZ_DTSAID' ) ) +; // Verifica se já foi incluido o registro.
				DTOS( oGrid:GetValue( 'TYZ_DTALTA' ) ) ) // Caso não exista realiza a validação do mesmo.

				cQuery := "SELECT * "
				cQuery += "FROM " + RetSqlName( "SR8" ) + " "
				cQuery += "WHERE D_E_L_E_T_ != '*' AND "
				cQuery += "R8_FILIAL = '" + oGrid:GetValue( "TYZ_FILIAL" ) + "' AND "
				cQuery += "R8_MAT = '" + oGrid:GetValue( "TYZ_MAT" ) + "' AND "
				cQuery += "R8_SEQ != '" + oGrid:GetValue( "TYZ_SEQ" ) + "'"
				cQuery += "AND (  "
				cQuery += "('" + DTOS( oGrid:GetValue( "TYZ_DTSAID" ) ) + "' <= R8_DATAINI AND '" + DTOS( oGrid:GetValue( "TYZ_DTALTA" ) ) + "' = '')"
				cQuery += "OR ('" + DTOS( oGrid:GetValue( "TYZ_DTSAID" ) ) + "' <= R8_DATAINI AND '" + DTOS( oGrid:GetValue( "TYZ_DTALTA" ) ) + "' >= R8_DATAINI )"
				cQuery += "OR ('" + DTOS( oGrid:GetValue( "TYZ_DTSAID" ) ) + "' >= R8_DATAINI AND ( '" + DTOS( oGrid:GetValue( "TYZ_DTALTA" ) ) + "' >= R8_DATAINI AND ('" + DTOS( oGrid:GetValue( "TYZ_DTALTA" ) ) + "' <= R8_DATAFIM OR '" + DTOS( oGrid:GetValue( "TYZ_DTALTA" ) ) + "' = '' ) ) )"
				cQuery += "OR ('" + DTOS( oGrid:GetValue( "TYZ_DTSAID" ) ) + "' <= R8_DATAINI AND '" + DTOS( oGrid:GetValue( "TYZ_DTALTA" ) ) + "' >= R8_DATAINI AND R8_DATAFIM = '' )"
				cQuery += "OR ('" + DTOS( oGrid:GetValue( "TYZ_DTSAID" ) ) + "' >= R8_DATAINI AND R8_DATAFIM = '' AND '" + DTOS( oGrid:GetValue( "TYZ_DTALTA" ) ) + "' = '' )"
				cQuery += " ) "

				cQuery := ChangeQuery( cQuery )
				MPSysOpenQuery( cQuery , cAliasSR8 )

				If !Empty( ( cAliasSR8 )->R8_SEQ )
					ShowHelpDlg( STR0111, { STR0103 }, 1, { STR0236 }, 1 ) // "Já existe um afastamento cadastrado no periodo desejado!" // "Verifique se já existe um afastamento dentro do mesmo período cadastrado na rotina de Afastamento. (SR8)"
					lRet := .F.
				EndIf
			EndIf
		EndIf
	Next nX

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685HIMP
Verifica os registros a serem impressos

@type function

@source MDTA685.prx

@author Jackson Machado
@since 21/08/2012

@param aRecnos, Array, Contêm o recno selecionado.

@sample MDT685HIMP( Array )

@return Vazio
/*/
//---------------------------------------------------------------------
Function MDT685HIMP(aRecnos)

	Local aArea   := GetArea()
	Local aRecCon := {}

	aRecnos := {{"TNY",{TNY->(RECNO())}}}
	If AliasInDic("TKI")//Percorre os CID's complementares
		aArea := GetArea()
		dbSelectArea("TKI")
		dbSetOrder(1)
		dbSeek(xFilial("TKI")+TNY->TNY_NATEST)
		While TKI->(!EoF()) .And. xFilial("TKI")+TNY->TNY_NATEST == TKI->TKI_FILIAL+TKI->TKI_NATEST
			aAdd(aRecCon,TKI->(Recno()))
			If (nPos := aScan(aRecnos,{|x| x[1] == "TKI" })) > 0
				aAdd(aRecnos[nPos][2],TKI->(Recno()))
			Else
				aAdd(aRecnos,{"TKI",{TKI->(Recno())}})
			EndIf
			TKI->(dbSkip())
		End
		RestArea(aArea)
	EndIf
	MDTBUSCADEL(@aRecnos,"TKI",{xFilial("TKI"),TNY->TNY_NATEST,MDTDATALO("TNY->TNY_USERGI")},{"TKI_FILIAL","TKI_NATEST","TKI_USERGI"},aRecCon)

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685IMP
Atribui os valores aos MV_par do relatório MDTR740.

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since 09/03/2017

@sample MDT685IMP()

@return Nulo
/*/
//---------------------------------------------------------------------
Function MDT685IMP()

	Local cPerg := "MDT685"
	Local aPerg := {}
	Local lPerg := .F.
	Local lFim  := .F.

	dbSelectArea("SX1")
	dbSetOrder(1)

	If ExistBlock("MDT685IMP")
		ExecBlock("MDT685IMP",.F.,.F.)
		lFim := .T.
	EndIf

	If !lFim

		lPerg := pergunte(cPerg,.T.) //Chama as perguntas.

		If lPerg //Caso seja confirmado a impressão.
			//|--------------------------------------------------------------|
			//| ADICIONAR OS VALORES PARA QUE SEJA ENVIADO PARA A IMPRESSÃO. |
			//|--------------------------------------------------------------|
			aAdd( aPerg , {  MV_par01 } )
			aAdd( aPerg , {  TM0->TM0_NUMFIC } )
			aAdd( aPerg , {  TM0->TM0_NUMFIC } )
			aAdd( aPerg , {  TNY->TNY_DTINIC } )
			aAdd( aPerg , {  TNY->TNY_DTFIM  } )
			aAdd( aPerg , {  MV_par02 		 } )
			aAdd( aPerg , {  MV_par03 		 } )
			aAdd( aPerg , {  MV_par04 		 } )
			aAdd( aPerg , {  MV_par05 		 } )

			If Len(aPerg) > 0
				MDTR740(aPerg)//Faz a chamada do relatório.
			EndIf
		EndIf

	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MdtTurnoSPJ
Verifica se funcionário possui turno com horarios e retorna
a quantidade de horas reais de atestado medico.

@type function

@source MDTA685.prx

@author NG Informatica
@since 17/03/11

@param dDtIniTNY, Date		, Data início do afastamento.
@param dDtFimTNY, Date		, Data fim do afastamento.
@param cHrIniTNY, Caracter	, Hora início do afastamento.
@param cHrFimTNY, Caracter	, Hora fim do afastamento.

@sample MdtTurnoSPJ( 01/01/2001 , 01/01/2017 , '14:20' , '12:12' )

@return Array , Quantidade de horas e dias.

@obs Utilizado no relatório MDTR740.prx
/*/
//---------------------------------------------------------------------
Function MdtTurnoSPJ( dDtIniTNY, dDtFimTNY, cHrIniTNY, cHrFimTNY )

	Local aTabTno   := {} //Horarios do turno
	Local bVld, nPos, nDow, lCont, nFor
	Local lTemHrPad := .F.
	Local cQtdHoras := "  :  "
	Local lNoturno  := .F.
	Local nHrsNoturno := 0
	Local nHorIni   := 0
	Local nMinIni   := 0
	Local nNumIni   := 0
	Local nHorFim   := 0
	Local nMinFim   := 0
	Local nNumFim   := 0
	Local nNumMIN   := 0
	Local nNumMAX   := 0
	Local cTurSRA   := SRA->RA_TNOTRAB
	Local cTurSEQ   := SRA->RA_SEQTURN
	Local cNG2TUAT  := GetMv("MV_NG2TUAT")
	Local nDias     := 0
	Private aTab685

	dbSelectArea("SR6")
	dbSetOrder(1)
	If dbSeek(xFilial("SR6",SRA->RA_FILIAL)+SRA->RA_TNOTRAB)
		If SuperGetMv("MV_TNOOPC",NIL,"N") == "S"
			If !Empty(SR6->R6_TNOOPC)
				cTurSRA := SR6->R6_TNOOPC
				cTurSEQ := ""
			EndIf
		EndIf
	EndIf

	nPos 	:= At(":",cHrIniTNY)
	nHorIni := Val(SubStr(cHrIniTNY,1,nPos-1))
	nMinIni := Val(SubStr(cHrIniTNY,nPos+1  ))
	nNumIni := Val(StrZero(nHorIni,2)+"."+StrZero(nMinIni,2))
	nPos 	:= At(":",cHrFimTNY)
	nHorFim := Val(SubStr(cHrFimTNY,1,nPos-1))
	nMinFim := Val(SubStr(cHrFimTNY,nPos+1  ))
	nNumFim := Val(StrZero(nHorFim,2)+"."+StrZero(nMinFim,2))
	nNumFim := If(nNumFim < nNumIni,nNumFim+24,nNumFim)

	//Verifica se a sequencia do turno esta preenchida
	If !Empty(cTurSEQ)
		bVld := &("{|| PJ_SEMANA == '"+cTurSEQ+"' }")
	Else
		//Verifica o turno possui horario cadastrado
		dbSelectArea("SPJ")
		dbSetOrder(1)
		If dbSeek(xFilial("SPJ",SRA->RA_FILIAL)+cTurSRA)
			bVld := &("{|| PJ_SEMANA == '"+SPJ->PJ_SEMANA+"' }")
		EndIf
	EndIf

	//-------------------------------------------------------------
	// Indica se o turno possuir horario cadastrado e a diferença
	// entre a data inicio e fim não for superior a 1 dia
	//-------------------------------------------------------------
	If ValType(bVld) == "B" .And. !Empty(dDtIniTNY)

		//Busca horario do turno
		fTabPadrao( @aTabTno , xFilial("SR6",SRA->RA_FILIAL) , cTurSRA , , bVld )
		aTab685 := aClone(aTabTno)

		//--------------------------------------------------------
		//Verifica calendario na data inicio atestado
		//--------------------------------------------------------
		nDow  := Dow(dDtIniTNY)
		If Type("aTab685[1,3,"+Str(Dow(dDtIniTNY),1)+"]") == "A" //Se existem horários
			lCont := .F.
			If aTab685[1,3,nDow,9] > 0 //Se existem horas trabalhadas entre a primeira entrada e a primeira saida
				//--------------------------------------------------------
				// Analisa 1ª entrada e saida.
				//--------------------------------------------------------
				nNumMIN := aTab685[1,3,nDow,1] //primeira entrada
				nNumMAX := aTab685[1,3,nDow,2] //primeira saida
				If aTab685[1,3,nDow,32] == "S" .Or. aTab685[1,3,nDow,2] < aTab685[1,3,nDow,1]
					nNumMAX += 24
					lCont := .T.
				EndIf
				For nFor := 2 To 4
					If aTab685[1,3,nDow,nFor+8] > 0 //Se existem horas trabalhadas entre as outras entradas e saidas
						//--------------------------------------------------------
						// Analisa 2ª a 4º entrada e saida.
						//--------------------------------------------------------
						If lCont
							If aTab685[1,3,nDow,(nFor*2)-1] >= aTab685[1,3,nDow,(nFor*2)-2] .And. aTab685[1,3,nDow,(nFor*2)] > aTab685[1,3,nDow,(nFor*2)-1]
								nNumMAX := aTab685[1,3,nDow,(nFor*2)] + 24
							EndIf
						Else
							If aTab685[1,3,nDow,(nFor*2)-1] >= aTab685[1,3,nDow,(nFor*2)-2]
								If aTab685[1,3,nDow,nFor+31] == "S" .Or. aTab685[1,3,nDow,(nFor*2)] < aTab685[1,3,nDow,(nFor*2)-1]
									nNumMAX := aTab685[1,3,nDow,(nFor*2)] + 24
									lCont := .T.
								Else
									nNumMAX := aTab685[1,3,nDow,(nFor*2)]
								EndIf
							Else
								If aTab685[1,3,nDow,(nFor*2)] > aTab685[1,3,nDow,(nFor*2)-1]
									nNumMAX := aTab685[1,3,nDow,(nFor*2)] + 24
									lCont := .T.
								EndIf
							EndIf
						EndIf
					EndIf
				Next nFor
			EndIf
			If nNumMAX > 0
				lTemHrPad := .T.
				nQtdHoras := 0
				nDias     := 0
				If cNG2TUAT == "1"
					dDtAux := dDtIniTNY
					While dDtIniTNY <= dDtFimTNY
						nDow  := Dow(dDtIniTNY)
						lEntra1 := .F.
						lEntra2 := .F.
						lEntra3 := .F. //Se existem horas trabalhadas no periodo
						nQtdTmp := 0
						For nFor := 1 To 4
							If aTab685[1,3,nDow,nFor+31] == "S" .Or. aTab685[1,3,nDow,(nFor*2)] < aTab685[1,3,nDow,(nFor*2)-1] //Verifica os pares de hora de entrada e saída, se a saida é maior do que a entrada
								lCont := .T.
								lNoturno := .T. //Horario de entrada > horario de saida logo, horario noturno
							Else
								lCont := .F.
							EndIf
							If aTab685[1,3,nDow,nFor+8] > 0 //Se existem horas trabalhadas entre as outras entradas e saidas
								lEntra3 := .T.
							EndIf

							cHrTmp1 := NTOH(NGCONVERHORA(aTab685[1,3,nDow,(nFor*2)-1],"S","D")) //Entrada
							cHrTmp  := NTOH(NGCONVERHORA(aTab685[1,3,nDow,(nFor*2)],"S","D")) //Saida

							If dDtIniTNY == dDtAux .And. cHrTmp1 < cHrIniTNY .And. aTab685[1,3,nDow,nFor+8] > 0 //Se a hora de inicio do turno for menor que a hora de inicio do atestado (Primeiro Dia)
								cHrTmp1 := cHrIniTNY
								lEntra1 := .T.
							EndIf
							If dDtIniTNY >= dDtFimTNY .And. cHrTmp > cHrFimTNY .And. aTab685[1,3,nDow,nFor+8] > 0 //Se a hora de fim do turno for maior que a hora de fim do atestado (Ultimo dia)
								cHrTmp := cHrFimTNY
								lEntra2 := .T.
							EndIf
							If lCont
								dDtIniTNY++
								nQtdTmp += HTON(NGCALCHCAR(dDtIniTNY-1,cHrTmp1,dDtIniTNY,cHrTmp)) //Soma as horas trabalhadas no período
							Else
								If cHrTmp1 < cHrTmp
									nQtdTmp += HTON(NGCALCHCAR(dDtIniTNY,cHrTmp1,dDtIniTNY,cHrTmp))
								EndIf
							EndIf
						Next nFor
						If !lEntra1 .And. !lEntra2 .And. lEntra3
							nDias ++
						Else
							nQtdHoras += nQtdTmp
						EndIf
						dDtIniTNY++
					EndDo

					For nFor := 1 To 4
						nDow := Dow(dDtAux)
						If lNoturno .And. cHrIniTNY != "00:00" .And. cHrFimTNY != "23:59"  //Se for Noturno e calculo por atestado
							If nHorIni < aTab685[1,3,nDow,(nFor*2)] //Se for menor que o horario de saida
								If nHrsNoturno == 0 //Primeiro intervalo de entrada e saida calcula apartir do horario de inicio
									nHrsNoturno += HTON(NGCALCHCAR(dDtIniTNY,cHrIniTNY,dDtIniTNY,NTOH(NGCONVERHORA(aTab685[1,3,nDow,(nFor*2)],"S","D"))))
								Else
									nHrsNoturno += HTON(NGCALCHCAR(dDtIniTNY,NTOH(NGCONVERHORA(aTab685[1,3,nDow,(nFor*2)-1],"S","D")),dDtIniTNY,NTOH(NGCONVERHORA(aTab685[1,3,nDow,(nFor*2)],"S","D"))))
								EndIf
							EndIf
						EndIf
					Next nFor

					nQtdHoras += nHrsNoturno
					cQtdHoras := NTOH(nQtdHoras)
				Else
					If cHrIniTNY == "00:00" .And. cHrFimTNY == "23:59"
						cHrIniTNY = "00:00"
						cHrFimTNY = "00:00"
						nDias++
					EndIf
					cQtdHoras := NGCALCHCAR(dDtIniTNY,cHrIniTNY,dDtFimTNY,cHrFimTNY)
					nQtdHoras := HTON(cQtdHoras)
					nDias     += Int(nQtdHoras / 24)
					nQtdHoras := nQtdHoras % 24
					cQtdHoras := NTOH(nQtdHoras)
				EndIf
			EndIf
		EndIf
	EndIf

	//Se for calculo de dias pelo afastamento e seja um horario que começe em um dia e termine no outro, acrescenta um dia
	If cHrIniTNY == "00:00" .And. cHrFimTNY == "23:59" .And. lNoturno
		nDias ++
	EndIf

Return {lTemHrPad, cQtdHoras, nDias, cNG2TUAT}

//------------------------------------------------------------------------
/*/{Protheus.doc} MDT685TUR
Função responsável pela verificação do Turno do funcionário, retornando
VERDADEIRO caso seja noturno ou FALSO caso não seja.

@type function

@source MDTA685.prx

@author Gabriel Gustavo de Mora
@since 24/01/2017

@param cNumFic, Caracter, Código da ficha médica do atestado
@param dDtInic, Date, Data de inicio do atestado

@sample MDT685TUR( "0000001" , 01/01/2016 )

@return Lógico, Retorna verdadeiro se o turno do funcionário for noturno.

@obs Utilizado também no relatório MDTR740.prx
/*/
//-------------------------------------------------------------------------
Function MDT685TUR(cNumFic , dDtInic)

	Local lNoturn  := .F.
	Local nSaida   := 0
	Local nEntrada := 0
	Local cDia     := ""
	Local cAliQry  := ""
	Local aArea    := GetArea()
	Local cFilFun  := NGSEEK( 'TM0', cNumFic, 1, 'TM0_FILFUN' )
	Local cFilSPJ  := xFilial( 'SPJ', cFilFun )
	Local cFilSRA  := xFilial( 'SRA', cFilFun )

	Default cNumFic := If( Type("M->TNY_NUMFIC") == "C" , M->TNY_NUMFIC , "" )
	Default dDtInic := If( Type("M->TNY_DTINIC") == "D" , M->TNY_DTINIC , StoD(Space(8)) )

	If !Empty(cNumFic) .And. !Empty(dDtInic)
		//Executa Query de busca do turno do funcionário
		cAliQry := GetNextAlias()
		BeginSql Alias cAliQry
			SELECT PJ_ENTRA1,
			       PJ_SAIDA1,
			       PJ_SAIDA2,
			       PJ_SAIDA3,
			       PJ_SAIDA4,
			       PJ_DIA
			FROM   %table:SPJ% SPJ
			WHERE SPJ.%NotDel%
			  		AND SPJ.PJ_FILIAL = %exp:cFilSPJ%
			  		AND SPJ.PJ_TURNO = (SELECT SRA.RA_TNOTRAB
			                   FROM   %table:SRA% SRA
			                   WHERE  SRA.%NotDel%
									   AND SPJ.PJ_SEMANA = SRA.RA_SEQTURN
			                   			AND	SRA.RA_FILIAL = %exp:cFilSRA%
			                   			AND SRA.RA_MAT = (SELECT TM0.TM0_MAT
			                                        FROM   %table:TM0% TM0
			                                        WHERE  TM0.%NotDel%
			                                        		AND TM0.TM0_FILIAL = %xFilial:TM0%
			                                        		AND TM0.TM0_NUMFIC = %exp:cNumFic%))
		EndSql

		cDia := CValToChar(Dow(dDtInic)) //Dia da semana
		dbSelectArea(cAliQry)
		dbGoTop()
		While !EoF() .And. cDia <> (cAliQry)->PJ_DIA //Verifica o horario correspondente ao dia da semana do inicio do atestado
			(cAliQry)->(dbSkip())
		End
		nEntrada := (cAliQry)->PJ_ENTRA1 //Inicio do Turno
		Do Case //Verifica qual o final de expediente do funcionário
			Case Empty((cAliQry)->PJ_SAIDA2)
				nSaida := (cAliQry)->PJ_SAIDA1
			Case Empty((cAliQry)->PJ_SAIDA3)
				nSaida := (cAliQry)->PJ_SAIDA2
			Case Empty((cAliQry)->PJ_SAIDA4)
				nSaida := (cAliQry)->PJ_SAIDA3
			Otherwise
				nSaida := (cAliQry)->PJ_SAIDA4
		EndCase

		If nSaida < nEntrada //Quando o horario de Saida for menor que o de Entrada, funcionário trabalha noturno.
			lNoturn := .T.
		EndIf
		(cAliQry)->( dbCloseArea() )
	EndIf

	RestArea( aArea )

Return {lNoturn,IntToHora(nEntrada),IntToHora(nSaida)}

//---------------------------------------------------------------------
/*/{Protheus.doc} WhenTKICID
Troca F3 do campo CID

@type function

@source MDTA685.prx

@author Denis Hyroshi de Souza
@since 06/02/2007

@sample WhenTKICID()

@return Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
Function WhenTKICID()

	Local oModel
	Local oGrid

	If !IsInCallStack( 'mdta410' )

		oModel := FWModelActive()  //Copia o Model utilizado.
		oGrid := oModel:GetModel( 'TKIDETAIL' ) //Posiciona no Model da Grid

		aTROCAF3 := {}

		If !Empty(oGrid:GetValue( "TKI_GRPCID" ) )
			AADD(aTROCAF3,{"TKI_CID","TMR5"})
		Else
			AADD(aTROCAF3,{"TKI_CID","TMR"})
		EndIf

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685GRID
Responsavel por jogar valores para Grid através do X3_RELACAO

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since 20/03/2017

@sample MDT685GRID()

@return Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
Function MDT685GRID(oModel)

	Local oGrid
	Local nLenGrid

	Default oModel 	:= FWModelActive() //Ativa modelo utilizado.

	oGrid := oModel:GetModel( 'TYZDETAIL' ) //Posiciona no Model da Grid
	nLenGrid := oGrid:Length()

	oGrid:LoadValue( "TYZ_FILIAL"  , xFilial("TNY")  )
	oGrid:LoadValue( "TYZ_MAT"	   , Posicione("TM0",1,xFilial("TM0")+oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ),"TM0_MAT")   )
	oGrid:LoadValue( "TYZ_TIPO"	   , SubStr(Posicione("RCM",1,xFilial("RCM")+oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' ),"RCM_CODSEF"),1,1)   )
	oGrid:LoadValue( "TYZ_TIPOAF"  , oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' ) )

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685TNYA
Preenche o acols com as variaveis padrões atuais.

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since 20/03/2017

@sample MDT685TNYA()

@return aAtual, Array, Retorna os valores do campo TNY.
/*/
//---------------------------------------------------------------------
Function MDT685TNYA()

	Local aAtual := {}

	//|---------------------------------------------------|
	//| Responsável por buscar os valores padrões atuais. |
	//|---------------------------------------------------|
	aAtual := { {	TNY->TNY_DTINIC	, TNY->TNY_DTFIM  ,	TNY->TNY_HRINIC ,;
					TNY->TNY_HRFIM	, TNY->TNY_EMITEN ,	TNY->TNY_CODABO ,;
					TNY->TNY_NATEST	, TNY->TNY_TIPATE ,	TNY->TNY_TIPAFA ,;
					TNY->TNY_CODAFA , TNY->TNY_CID    ,	TNY->TNY_NUMFIC } }

Return aAtual

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685AFRA
Joga o valor do gatilho para o campo TNY_AFRAIS

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since 20/03/2017

@sample MDT685AFRA()

@return Vazio.
/*/
//---------------------------------------------------------------------
Function MDT685AFRA()

	Local oModel 	:= FWModelActive()
	Local oModelTNY	:= oModel:GetModel( "TNYMASTER1" )
	Local cCodAfas	:= oModelTNY:GetValue( "TNY_CODAFA" )

	oModel:LoadValue( "TNYMASTER1", "TNY_AFRAIS"  , RCM->RCM_CODRAI )

	If IsInCallStack("MDTA410")
		cCodAfas := M->TNY_CODAFA
		M->TNY_AFRAIS := RCM->RCM_CODRAI
	EndIf

Return cCodAfas

//---------------------------------------------------------------------
/*/{Protheus.doc} f685RetOrder
Verifica existencia de indice no dicionário de dados.

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since 20/03/2017

@sample f685RetOrder('SR8','R8_FILIAL+R8_NATEST')

@return nOrdem, Numérico , Retorna o indice.
/*/
//---------------------------------------------------------------------
Function f685RetOrder(cAlias,cChave)

	Local nOrdem      := 0
	Local nIndex      := 0
	Local aArea       := GetArea()
	Local aIndex      := {}
	Local cChaveAlias := ""

	aIndex := NGRETINDTAB( cAlias )

	If Len( aIndex ) > 0

		For nIndex := 1 To Len( aIndex )
				
			cChaveAlias := aIndex[ nIndex ]

			If Alltrim( cChaveAlias ) == Alltrim( cChave )
				nOrdem := nIndex
			EndIf

		Next nIndex

	EndIf

	RestArea(aArea)

Return nOrdem

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685ACTI
Função responsavel por realizar a ativação do Modelo, para o fonte MDTA410

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since 25/04/2017

@sample  MDT685ACTI()

@return Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
Function MDT685ACTI( nOpcx ,oModel, lActive , lGrava)

	//Adiciona campos que não receberão valor no Modelo de Dados
	Local aCpsVir := { "TNY_NOMFIC", "TNY_DESGRP", "TNY_DOENCA", "TNY_NOMUSU", "TNY_NOMUSU",;
					"TNY_NOMUSU", "TNY_ESPDES", "TNY_ABODES", "TNY_DESCAD", "TNY_DESACI",;
					"TNY_ATEANT", "TNY_USERGI", "TNY_TPEFD" }
	Local lCpoSr8 := .F.
	Local nX := 0
	Local lRet := .T.
	Local aAtes := {}

	Default oModel  := FWLoadModel( "MDTA685" ) //Realiza ativação do modelo.
	Default lActive := .T.
	Default lGrava 	:= .F.
	Default nOpcx  	:= 0

	aCpsVir := { "TNY_NOMFIC", "TNY_DESGRP", "TNY_DOENCA", "TNY_NOMUSU", "TNY_NOMUSU",;
				"TNY_NOMUSU", "TNY_ESPDES", "TNY_ABODES", "TNY_DESCAD", "TNY_DESACI",;
				"TNY_ATEANT", "TNY_USERGI", "TNY_DTSAID", "TNY_DTALTA", "TNY_DTSAI2",;
				"TNY_DTALT2", "TNY_DTSAI3", "TNY_DTALT3", "TNY_TPEFD"  }

	If SR8->(ColumnPos("R8_NATEST")) > 0 //Campo Específico.
		lCpoSr8 := .T.
	EndIf

	If lActive
		oModel  := FWLoadModel( "MDTA685" )
		oModel:Activate()
	EndIf
	dbSelectArea( "TNY" )
	For nX := 1 To FCount()
		If aScan( aCpsVir , { | x | FieldName( nX ) == x }  ) == 0
			If nOpcx <> 5
				aAdd(aAtes,{FieldName( nX ) ,M->( &( FieldName( nX ) ) ) })
			Else
				oModel:LoadValue( "TNYMASTER1", FieldName( nX )  , M->( &( FieldName( nX ) ) )  )
			EndIf
		EndIf
	Next nX

	If lGrava
		oModel:DeActivate() //Desativa o modelo, para que seja informado a Opção.
		oModel:SetOperation(nOpcx) //Informa opção para o modelo.
		oModel:Activate() //Ativação do Modelo

		If Len(aAtes) > 0 .And. IsInCallStack("MDTA410") .And. nOpcx <> 5

			For nX := 1 To Len(aAtes)
				oModel:LoadValue( "TNYMASTER1", aAtes[nX,1]  , aAtes[nX,2] )
			Next nX

		EndIf

		lRet := MDT685COMM(oModel, nOpcx, .F. )
	EndIf

Return oModel

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685LOC
Função utilizada no botão 'Incluir Afastamentos' na rotina Ficha Médica
Mod. 02 (MDTA410)

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since 25/04/2017

@sample  MDT685LOC()

@return Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
Function MDT685LOC()

	Local oDlgLOC
	Local oModel
	Local aNao := {}

	Local aRecBKP := {}

	Local cKeyGet := ""
	Local cWhileGet := ""

	Local lOk := .F.
	Local lRet := .T.

	Private aObje685 := {}
	Private aInfo685 := {}

	Private aSize685 := MsAdvSize(Nil,.F.)
	Private aPosOb685 := {}

	Private oGetLOC
	Private aColsTYZ := {}
	Private aHeaderTYZ := {}
	Private APERATUAL := {}
	Private cProcesso := ""
	Private cCadastro := OemtoAnsi(STR0191) //"Afastamento"

	//Define o Tamanho dos objetos em tela
	Aadd(aObje685,{050,050,.T.,.T.})
	Aadd(aObje685,{100,100,.T.,.T.})
	Aadd(aObje685,{100,100,.T.,.T.})
	aInfo685 := {aSize685[1],aSize685[2],aSize685[3],aSize685[4],0,0}
	aPosOb685 := MsObjSize(aInfo685, aObje685,.T.)

	//|--------------------|
	//| Ativa o Modelo.    |
	//|--------------------|
	oModel := FWLoadModel( "MDTA685" ) //Chama modelo.
	oModel:SetOperation(4) //Alteração
	oModel:Activate() //Ativação do Modelo

	lRet := MDT685PRE(oModel)

	If Empty(M->TNY_CODAFA) .And. lRet
		Help( , , STR0111 , , STR0208, 5 , 5 )//"Para informar afastamentos é necessário ter o campo 'Cód. Ausência' preenchido."
		lRet := .F.
	EndIf

	If lRet

		//|-------------------------------------------|
		//| Monta a GetDados dos Exames da Brigada    |
		//|-------------------------------------------|
		aAdd( aNao , "TYZ_FILIAL" )
		aAdd( aNao , "TYZ_MAT"	  )
		aAdd( aNao , "TYZ_TIPO"   )
		aAdd( aNao , "TYZ_NATEST" )
		aAdd( aNao , "TYZ_TIPOAF" )

		//|-----------------------------|
		//| Montegam do aCols e aHeader |
		//|-----------------------------|
		cKeyGet	  := "TNY->TNY_NATEST" //Chave para a busca dos registros.
		cWhileGet := "TYZ->TYZ_FILIAL == '" + xFilial( "TYZ" ) + "' .And. TYZ->TYZ_NATEST == '" + TNY->TNY_NATEST + "'" //Verificação de while para busca dos registros.
		FillGetDados( 3 , "TYZ" , 2 , xFilial("TYZ")+TNY->TNY_NATEST , { | | } , { | | .T. } , aNao , , , , ;
					{ | | NGMontaACols( "TYZ" , &cKeyGet , cWhileGet,,2 ) },.T.,aHeaderTYZ,aColsTYZ )


		If Len(aColsTYZ) == 0 //Caso aCols esteja vazio.
			aColsTYZ := BLANKGETD(aHeaderTYZ)
			aColsTYZ[n,1] := MDT685SEQ(1)
		EndIf

		//Realiza cópia do aCols.
		aRecBKP := aClone(aColsTYZ)

		DEFINE MSDIALOG oDlgLOC TITLE STR0191 From 0,0 To aSize685[6],aSize685[5] OF oMainWnd PIXEL  //Define Dialog

		oGetLOC := MsNewGetDados():New( aPosOb685[1,1],aPosOb685[1,2],aPosOb685[3,3],aPosOb685[3,4] , GD_INSERT + GD_UPDATE + GD_DELETE , ;
																		{ | | MDT685LIN(,oGetLOC) } , { | | MDT685LIN(.T.,oGetLOC) } , , , , 9999 , , , , oDlgLOC , ;
																		aHeaderTYZ , aColsTYZ, { | | MDT685LIP(oGetLOC) }  )

		ACTIVATE MSDIALOG oDlgLOC ON INIT EnchoiceBar(oDlgLOC,;
					{|| lOk := .T., IIf( MDT685LIN(.T.,oGetLOC) .And. fGrvTYZ( oModel, aRecBKP ), oDlgLOC:End() , Nil )},;
					{|| oDlgLOC:End(),lOk := .F.})
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fGrvTYZ
Realiza o Repasse do aCols para a Grid e realiza o Commit

@type function

@source MDTA685.prx

@author Jackson Machado
@since 23/05/2019

@sample  fGrvTYZ( oObj , {} )

@param oModel, Object, Objeto do Modelo
@param aRecBKP, Array, Backup dos Valores antes da alteração

@return Lógico, Indica se está correto a gravação
/*/
//---------------------------------------------------------------------
Static Function fGrvTYZ( oModel, aRecBKP )

	Local aNaoTNY := { "TNY_ATEANT" , "TNY_USERGI" }
	Local oGrid   := oModel:GetModel("TYZDETAIL") //Chama a Grid da TYZ
	Local nX := 0, nY := 0
	Local nLinha := 0

	// Atualiza aCols
	aColsTYZ := aClone( oGetLOC:aCols )
	//|-------------------------------------------------------------------|
	//| Percorre todos os campos da TNY, para adicionar o valor ao modelo |
	//|-------------------------------------------------------------------|
	dbSelectArea( "TNY" )
	For nX := 1 To FCount()
		If aScan( aNaoTNY , { | x | FieldName( nX ) == x }  ) == 0
			oModel:LoadValue( 'TNYMASTER1', FieldName( nX ), TNY->( &( FieldName( nX ) ) ) )
		EndIf
	Next nX

	For nX := 1 To oGrid:Length() //Percorre todos os registros da Grid.
		oGrid:GoLine( nX ) //Posiciona na linha da Grid.
		nLinha := aScan( aColsTYZ , { | x | x[1] == oGrid:GetValue( "TYZ_SEQ" ) } ) //Procura posição do aColsTYZ, correspondente ao valor da Grid.
		If !aColsTYZ[nLinha, Len(aColsTYZ[nLinha])] //Verificar se registro não foi deletado.
			If aColsTYZ[nLinha,2] <> oGrid:GetValue("TYZ_DTSAID") .Or. aColsTYZ[nLinha,3] <> oGrid:GetValue("TYZ_DTALTA") //Caso ocorreu alguma mudança
				oGrid:LoadValue( 'TYZ_DTSAID'	, aColsTYZ[nLinha,2] )
				oGrid:LoadValue( 'TYZ_DTALTA'	, aColsTYZ[nLinha,3] )
			EndIf
		Else
			oGrid:DeleteLine() //Caso deletado do aCols, deleta da Grid.
		EndIf
	Next nX

	//|--------------------------------|
	//| Verifica as inclusões do aCols |
	//|--------------------------------|
	If Len(aRecBKP) < Len(aColsTYZ)  //Caso ocorreu alteração no aColsTYZ.
		nLinha := If( Len(aRecBKP) == 0 , 1 ,Len(aRecBKP) + 1 ) //Posiciona no ultimo registro que já estava adicionado.
		For nX := nLinha To Len(aColsTYZ)
			If !aColsTYZ[ nX , Len( aColsTYZ[ nX ] ) ] .And. ;//Verifica se não está deletado.
				!Empty(aColsTYZ[ nX , 2 ])  //Verifica se possui alguma data preenchida.
				If nX <> 1 //Caso seja o primeiro registro, não adiciona linha
					oGrid:AddLine()
				EndIf
				oGrid:LoadValue( 'TYZ_FILIAL' 	, xFilial("TYZ")  )
				oGrid:LoadValue( 'TYZ_MAT'		, Posicione("TM0",1,xFilial("TM0")+TNY->TNY_NUMFIC,"TM0_MAT") )
				oGrid:LoadValue( 'TYZ_NATEST'	, TNY->TNY_NATEST )
				oGrid:LoadValue( 'TYZ_TIPOAF'	, TNY->TNY_CODAFA )
				oGrid:LoadValue( 'TYZ_TIPO'		, SubStr(Posicione("RCM",1,xFilial("RCM")+TNY->TNY_CODAFA,"RCM_CODSEF"),1,1) )
				For nY := 1 To Len( aColsTYZ[ nX ] )
					If Len( aHeader ) >= nY .And. ;
						aHeader[ nY , 2 ] <> "TYZ_ALI_WT" .And. ;
						aHeader[ nY , 2 ] <> "TYZ_REC_WT"
						oGrid:LoadValue( aHeader[ nY , 2 ] , aColsTYZ[ nX , nY ] )
					EndIf
				Next nY
			EndIf
		Next nX
	EndIf

	If ( lRet := oModel:VldData() )
		lRet := MDT685COMM(oModel,4)
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685TRAN
Função responsável por realizar a tratativa de Base.

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since 25/04/2017

@sample  MDT685TRAN()

@return Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
FUNCTION MDT685TRAN()

	Local aCont := {} //Array que conterá as datas de continuação.
	Local nSaid := 0
	Local nX 	:= 0
	Local nY    := 0
	Local cMat := ""
	Local nPosCam := 0
	Local nQtdDia := 0

	dbSelectArea("TNY")
	dbGoTop() //Posiciona no ultimo registro da Tabela.
	While TNY->(!EoF()) .And. TNY->TNY_FILIAL == xFILIAL("TNY")

		If Empty(TNY->TNY_ATEANT) //Caso não seja Continuação.
			If !Empty(TNY->TNY_DTSAID) .Or. !Empty(TNY->TNY_DTALTA)
				nSaid := 1
			EndIf
			If !Empty(TNY->TNY_DTSAI2) .Or. !Empty(TNY->TNY_DTALT2)
				nSaid := 2
			EndIf
			If !Empty(TNY->TNY_DTSAI3) .Or. !Empty(TNY->TNY_DTALT3)
				nSaid := 3
			EndIf
			If nSaid > 0
				For nX := 1 To nSaid
					RecLock( "TYZ" , .T. )
						cMat := Posicione("TM0",1,xFilial("TM0")+TNY->TNY_NUMFIC,"TM0_MAT")
						TYZ->TYZ_FILIAL :=  TNY->TNY_FILIAL //Filial Utilizada.
						TYZ->TYZ_MAT    :=  cMat  // Matricula do Funcionário.
						TYZ->TYZ_TIPO   :=  TNY->TNY_TIPAFA // Tipo de Afastamento.
						TYZ->TYZ_NATEST :=  TNY->TNY_NATEST // Numero de Atestado.
						TYZ->TYZ_TIPOAF :=  TNY->TNY_CODAFA // Código de Afastamento.
						If nX == 1 //Caso tenha preenchido a primeira Saída.
							dbSelectArea("SR8")
							dbSetOrder(1)//R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPO
							If Dbseek(TYZ->TYZ_FILIAL+cMat+DTOS(TNY->TNY_DTSAID)+SubSTR(TNY->TNY_TIPAFA,1,2))
								TYZ->TYZ_SEQ    := SR8->R8_SEQ 		// Numero da Sequência da SR8.
								TYZ->TYZ_DTSAID := SR8->R8_DATAINI  // Data Saida para Afastamento.
								TYZ->TYZ_DTALTA := SR8->R8_DATAFIM  // Data Fim do Afastamento.
							EndIf
						ElseIf nX == 2 //Caso tenha preenchido a segunda Saída.
							dbSelectArea("SR8")
							dbSetOrder(1)//R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPO
							If Dbseek(TYZ->TYZ_FILIAL+cMat+DTOS(TNY->TNY_DTSAI2)+SubSTR(TNY->TNY_TIPAFA,1,2))
								TYZ->TYZ_SEQ    := SR8->R8_SEQ  	// Numero da Sequência da SR8.
								TYZ->TYZ_DTSAID := SR8->R8_DATAINI  // Data Saida para Afastamento.
								TYZ->TYZ_DTALTA := SR8->R8_DATAFIM  // Data Fim do Afastamento.
							EndIf
						ElseIf nX == 3//Caso tenha preenchido a terceira Saída.
							dbSelectArea("SR8")
							dbSetOrder(1)//R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPO
							If Dbseek(TYZ->TYZ_FILIAL+cMat+DTOS(TNY->TNY_DTSAI3)+SubSTR(TNY->TNY_TIPAFA,1,2))
								TYZ->TYZ_SEQ    := SR8->R8_SEQ 	   // Numero da Sequência da SR8.
								TYZ->TYZ_DTSAID := SR8->R8_DATAINI // Data Saida para Afastamento.
								TYZ->TYZ_DTALTA := SR8->R8_DATAFIM // Data Fim do Afastamento.
							EndIf
						EndIf
					TYZ->(MsUnLock())
				Next nX
			EndIf
			nSaid := 0
			cMat := ""
		Else //Caso seja Continuação.
			cMat := Posicione("TM0",1,xFilial("TM0")+TNY->TNY_NUMFIC,"TM0_MAT") //Busca a Matricula.

			aAdd( aCont , { TNY->TNY_NATEST, TNY->TNY_ATEANT, TNY->TNY_FILIAL, cMat, ;
							TNY->TNY_TIPAFA,TNY->TNY_CODAFA,;
							{ TNY->TNY_DTSAID, TNY->TNY_DTSAI2, TNY->TNY_DTSAI3 } } )
			//Deleta o Registro da Tabela.
			RecLock( "TNY" , .F. )
			dbDelete()
			TNY->(MsUnLock())
		EndIf

		TNY->(dbSkip()) //Volta um registro
	End

	//Ordena o registro do por numero do atestado.
	aSORT(aCont,,,{|x,y| x[2] < y[2] })
	//Caso tenha alguma continuação de Atestado.
	If Len(aCont) > 0
		For nX := Len(aCont) To 1 Step -1
			nPosCam := aSCAN(aCont,{|x| x[1] == aCont[nX,2]})
			If nPosCam > 0  //Caso encontre alguma outra continuação.
				For nY := 1 To Len(aCont[nX,7])
					aAdd( aCont[nPosCam,7] , aCont[nX,7,nY] )
				Next nY
				//Deleta a continuação do Atestado.
				aDel(aCont,nX)
				aSize(aCont,Len(aCont)-1)
			EndIf
		Next nX

	EndIf
	If Len(aCont) > 0
		For nX := 1 To Len(aCont)
			nQtdDia := 0
			For nY := 1 To Len(aCont[nX,7])
				dbSelectArea("SR8")
				dbSetOrder(1)//R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPO
				If Dbseek(aCont[nX,3]+aCont[nX,4]+DTOS(aCont[nX,7,nY])+SubSTR(aCont[nX,5],1,2))
					dbSelectArea("TYZ")
					dbSetOrder(1)//TYZ_FILIAL+TYZ_MAT+DTOS(TYZ_DTSAID)+TYZ_TIPO+TYZ_TIPOAF
					If !dbSeek(xFilial("TYZ")+aCont[nX,4]+DTOS(SR8->R8_DATAINI)+aCont[nX,5]+aCont[nX,6])
						RecLock( "TYZ" , .T. )
						TYZ->TYZ_FILIAL :=  aCont[nX,3] //Filial Utilizada.
						TYZ->TYZ_MAT    :=  aCont[nX,4] // Matricula do Funcionário.
						TYZ->TYZ_TIPO   :=  aCont[nX,5] // Tipo de Afastamento.
						TYZ->TYZ_NATEST :=  aCont[nX,2] // Numero de Atestado.
						TYZ->TYZ_TIPOAF :=  aCont[nX,6] // Código de Afastamento.
						TYZ->TYZ_SEQ    := SR8->R8_SEQ 	   // Numero da Sequência da SR8.
						TYZ->TYZ_DTSAID := SR8->R8_DATAINI // Data Saida para Afastamento.
						TYZ->TYZ_DTALTA := SR8->R8_DATAFIM // Data Fim do Afastamento.
						TYZ->(MsUnLock())
						nQtdDia += SR8->R8_DATAFIM - SR8->R8_DATAINI
					EndIf
				EndIf
			Next nY
			dbSelectArea("TNY")
			dbSetOrder(2)//TNY_FILIAL+TNY_NATEST
			If dbSeek(xFilial("TNY")+aCont[nX,2]) .And. nQtdDia > 0
				RecLock( "TNY" , .F. )
					TNY->TNY_QTDIAS := nQtdDia
				TNY->(MsUnLock())
			EndIf
		Next nX
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685PER
Busca o Código do Período e o Numero do Pagamento relacionado ao Período
do Processo.

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since 28/10/2016

@param cPeriod , Caracter, Código do Período
@param cNumpag , Caracter, Numero Pagamento
@param cCodProc, Caracter, Código do Processo
@param dDataIn , Date    , Data inicio do afastamento

@sample MDT685PER( "", "", "00001", "00/00/0000" )

@return Vazio
/*/
//---------------------------------------------------------------------
Static Function MDT685PER( cPeriod, cNumpag, cCodProc, dDataIn )

	Local aAreaPer := GetArea()
	Local aPerAberto := {}
	Local aPerFechado := {}
	Local nPos := 0

	fRetPerComp( Month2Str( dDataIn ), Year2Str( dDataIn ), Nil, cCodProc, If (SRA->RA_CATFUNC $ "P*A", fGetCalcRot("9"),fGetRotOrdinar()), @aPerAberto, @aPerFechado)

	If ( nPos := aScan( aPerAberto, { |x| dDataIn >= x[5] .And. dDataIn <= x[6] } ) ) > 0//Aberto
		cPeriod := aPerAberto[nPos,1]
		cNumpag := aPerAberto[nPos,2]
	ElseIf ( nPos := aScan( aPerFechado, { |x| dDataIn >= x[5] .And. dDataIn <= x[6] } ) ) > 0 // Fechado
		cPeriod := aPerFechado[nPos,1]
		cNumpag := aPerFechado[nPos,2]
	EndIf

	RestArea(aAreaPer)

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685SDT
Gera a sujestao de atestado por 120 dias, caso seja por
motivo de licenca gestante

@type function

@source MDTA685.prx

@author Guilherme Benkendorf
@since 29/01/12

@sample MDT685SDT(01/01/2000)

@obs Função usada no Dicionário de Dados

@return Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
Function MDT685SDT(dDataFim)

	Local nDias  := SuperGetMv( "MV_NG2LICE" , .F. , 120 )
	Local oModel

	If cPaisLoc == 'BRA' //Caso seja Brasil.
		If IsInCallStack("MDTA410")
			If M->TNY_TIPAFA == "Q" //AFASTAMENTO TEMPORARIO POR MOTIVO LICENCA GESTANTE
				If MsgYesNo( STR0001 + Alltrim(STR(nDias)) + STR0002 ) //"Será feito alteração da Quantidade de 'Dias Afast.' para "+ nDias + " dias. Deseja alterar?"
					M->TNY_DTFIM := dDataFim+( nDias - 1 )
					M->TNY_QTDIAS := nDias
				EndIf
			EndIf
		Else
			oModel := FWModelActive()  //Ativação do modelo utilizado
			If oModel:GetValue( 'TNYMASTER1', 'TNY_TIPAFA' ) == "Q" //AFASTAMENTO TEMPORARIO POR MOTIVO LICENCA GESTANTE
				If MsgYesNo( STR0001 + Alltrim(STR(nDias)) + STR0002 ) //"Será feito alteração da Quantidade de 'Dias Afast.' para "+ nDias + " dias. Deseja alterar?"
					oModel:LoadValue( 'TNYMASTER1', 'TNY_DTFIM', dDataFim+( nDias - 1 ) ) //Data de Retorno da Licenca Maternidade
					oModel:LoadValue( 'TNYMASTER1', 'TNY_QTDIAS', nDias )
				EndIf
			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} ChkDurAfas
Indica que o funcionario já esta com afastamento superior a 15 dias,
caracterizando o encaminhamento ao INSS.

@author Guilherme Benkendorf
@since 19/11/2013
/*/
//---------------------------------------------------------------------
Static Function ChkDurAfas( oModel )

	Local aAreaDur 		:= GetArea()
	Local aAreaTNY 		:= TNY->( GetArea() )

	Local cAfast 		:= Alltrim( GetMv( 'MV_NG2AFAS' ) )
	Local cTipAfas 		:= "IIf( Empty( M->TNY_CODAFA ), M->TNY_TIPAFA, NGSeek( 'RCM', M->TNY_CODAFA, 1, 'RCM->RCM_CODSEF' ) )"
	Local cFichaFun 	:= oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' )
	Local cNomeFun  	:= Posicione( 'TM0', 1, xFilial( 'TM0' ) + cFichaFun, 'TM0_NOMFIC' )

	Local dAfaAnt		:= StoD( '  /  /    ' ) // Data do afastamento anterior

	Local nY 			:= 0
	Local nLenGrid  	:= 0
	Local nTotDias 		:= SuperGetMv( 'MV_NG2TOAF' , .F. , 15 )
	Local nDtAuxDur		:= 0
	// Quantidade de dias entre os afastamentos para continuação
	Local nDiaEntAfa	:= Val( SuperGetMv( 'MV_NG2QTVE', .F., '60' ) )

	Local oGrid := oModel:GetModel( 'TYZDETAIL' )
	Local lMsg  := .F.
	
	nLenGrid := oGrid:Length()

	If ( SubStr( &( cTipAfas ), 1, 1 ) $ cAfast + 'O/P' ) .And. cPaisLoc == 'BRA'

		For nY := 1 To nLenGrid

			oGrid:GoLine( nY )

			If !( oGrid:IsDeleted() ) .And. !Empty( oGrid:GetValue( 'TYZ_DTSAID' ) ) .And. !Empty( oGrid:GetValue( 'TYZ_DTALTA' ) )
				If ( nY == 1 .Or. dAfaAnt >= DaySub( oGrid:GetValue( 'TYZ_DTSAID' ), nDiaEntAfa ) )
					dAfaAnt := oGrid:GetValue( 'TYZ_DTALTA' )
					nDtAuxDur += ( oGrid:GetValue( 'TYZ_DTALTA' ) - oGrid:GetValue( 'TYZ_DTSAID' ) ) + 1
				Else
					nDtAuxDur := 0
				EndIf
			EndIf

			If oGrid:IsUpdated( nY ) // Se é um afastamento novo sendo incluído
				If ValType( nDtAuxDur ) == 'N' .And. nDtAuxDur > nTotDias .And. !IsBlind()
					// "Funcionário"
					// "está/ficará afastado por mais de "//" dia(s), portanto deverá ser encaminhado ao INSS para as devidas providências legais."
					MsgAlert( STR0157 + " '" + Alltrim( cNomeFun ) + "' " + STR0158 + cValToChar( nTotDias ) + STR0179 )
					lMsg := .T.
				EndIf
			EndIf

		Next nY

	EndIf

	// Verifica se existe mais de um afastamento cadastrado (SR8 x TYZ) e se a soma dos mesmos ultrapassa o valor do MV_NG2TOAF
	If !lMsg .And. fAfastCont( oModel, oGrid ) .And. !IsBlind()
		// "Funcionário"
		// "está/ficará afastado por mais de "//" dia(s), portanto deverá ser encaminhado ao INSS para as devidas providências legais."
		MsgAlert( STR0157 + " '" + Alltrim( cNomeFun ) + "' " + STR0158 + cValToChar( nTotDias ) + STR0179 )
	EndIf

	RestArea( aAreaDur )
	RestArea( aAreaTNY )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685CODA
Responsavel por gatilhar valores para os campos TNY_DESCAD, TNY_TIPAFA e
TNY_AFRAIS

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since 15/08/2017

@sample MDT685CODA()

@obs Função chamada através do X3_VALID do campo TNY_CODAFA

@return Sempre Verdadeiro.
/*/
//---------------------------------------------------------------------
Function MDT685CODA()

	Local oModelTNY
	Local lRet      := .T.
	Local oModel    := FWModelActive()
	Local oGrid
	Local nReg      := 1

	If IsInCallStack("MDTA410")

		lRet := fValCodAfa( M->TNY_NATEST, M->TNY_CODAFA, ALTERA )

		If !Empty(M->TNY_CODAFA) .And. lRet

			M->TNY_DESCAD := SubStr(POSICIONE('RCM',1,XFILIAL('RCM')+M->TNY_CODAFA ,'RCM_DESCRI'),1,30)
			M->TNY_AFRAIS := POSICIONE('RCM',1,XFILIAL('RCM')+M->TNY_CODAFA ,'RCM_CODRAI')
			lRet := MDT685PRE(oModel)

		Else

			If lRet
				M->TNY_DESCAD := " "
				M->TNY_TIPAFA := " "
				M->TNY_AFRAIS := " "
				M->TNY_DTSAID := StoD("")
				M->TNY_DTALTA := StoD("")
				M->TNY_DTSAI2 := StoD("")
				M->TNY_DTALT2 := StoD("")
				M->TNY_DTSAI3 := StoD("")
				M->TNY_DTALT3 := StoD("")
			EndIf
			MDTA685DIA() //Atualiza TNY_QTDIAS
		EndIf
	Else
		oModel 	:= FWModelActive()
		oModelTNY	:= oModel:GetModel( "TNYMASTER1" )

		lRet := fValCodAfa( oModelTNY:GetValue( "TNY_NATEST" ), oModelTNY:GetValue( "TNY_CODAFA" ), oModelTNY:GetOperation() == MODEL_OPERATION_UPDATE )

		If lRet
			If !Empty(oModelTNY:GetValue( "TNY_CODAFA" ))
				oModelTNY:LoadValue(  "TNY_DESCAD"  , SubStr(POSICIONE('RCM',1,XFILIAL('RCM')+oModelTNY:GetValue( "TNY_CODAFA" ) ,'RCM_DESCRI'),1,30)   )
				oModelTNY:LoadValue(  "TNY_AFRAIS"  , POSICIONE('RCM',1,XFILIAL('RCM')+oModelTNY:GetValue( "TNY_CODAFA" ) ,'RCM_CODRAI')  )

				lRet := MDT685PRE(oModel)
			Else
				oModelTNY:LoadValue(  "TNY_DESCAD"  , " "  )
				oModelTNY:LoadValue(  "TNY_TIPAFA"  , " " )
				oModelTNY:LoadValue(  "TNY_AFRAIS"  , " "  )

				oGrid := oModel:GetModel( 'TYZDETAIL' )
				If !(oGrid:Length() == 1 .And. Empty( oGrid:GetValue("TYZ_DTSAID") ))
					For nReg := 1 To oGrid:Length()
						oGrid:GoLine( nReg )
						oGrid:DeleteLine()
					Next nReg
				EndIf
				MDTA685DIA() //Atualiza TNY_QTDIAS
			EndIf
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685LIN
Responsavel por validar o LinOk e TudoOk do Getdados de Afastamnetos.

@type function

@source MDTA685.prx

@author Guilherme Freudenburg
@since 15/08/2017

@param lTudo - Lógico, Determina se é TudoOk.

@sample MDT685LIN(.T.)

@obs Função chamada MDT685LOC.

@return lRet - Lógico.
/*/
//---------------------------------------------------------------------
Function MDT685LIN(lTudo,oGetDad)

	Local lRet := .T.
	Local nX := 0
	Local nY := 0

	Default lTudo := .F.

	aColsTYZ := aClone( oGetDad:aCols )

	If lTudo //Caso seja TudoOk
		For nX := 1 To Len(aColsTYZ)

			If lRet .And. nX == 1 .And. aColsTYZ[ nX, 2 ] != TNY->TNY_DTINIC
				Help( Nil, Nil, STR0153, Nil, STR0104 + '.', 1, 0, Nil, Nil, Nil, Nil, Nil, { STR0248 + '.' } )
				lRet := .F.
			EndIf

			If !aColsTYZ[nX,Len(aColsTYZ[nX])]
				If Empty( aColsTYZ[nX,2] ) .And.  !Empty( aColsTYZ[nX,3] ) .And. lRet
					Help( , , STR0111 , , STR0207, 5 , 5 )//"É necessário informar a Data Saída, pois o registro possui uma Data Alta."
					lRet := .F.
				EndIf

				If !Empty( aColsTYZ[nX,2] ) .And.  !Empty( aColsTYZ[nX,3] ) .And. lRet
					If aColsTYZ[nX,2] > aColsTYZ[nX,3]
						Help( , , STR0111 , , STR0193, 5 , 5 )//ATENÇÃO##"A Data Saída é maior que a Data Alta. Favor informar uma Data Saída inferior a Data Alta."
						lRet := .F.
					EndIf
				EndIf
			EndIf

			If !Empty( aColsTYZ[nX,2] ) .And.  !Empty( aColsTYZ[nX,3] ) .And. lRet .And. !aColsTYZ[nX,Len(aColsTYZ[nX])]
				If aColsTYZ[nX,2] < M->TNY_DTINIC .Or. aColsTYZ[nX,2] > M->TNY_DTFIM
					lRet := .F.
				EndIf
				If ( aColsTYZ[nX,3] < M->TNY_DTINIC .Or. aColsTYZ[nX,3] > M->TNY_DTFIM ) .And. lRet
					lRet := .F.
				EndIf
				If !lRet //Caso encontre alguma data fora.
					Help( , , STR0111 , , STR0215, 5 , 5 )//"Existem períodos fora da data de início e fim do atestado. Favor informar outra data."
				EndIf
			ElseIf !Empty( aColsTYZ[nX,2] ) .And.  Empty( aColsTYZ[nX,3] ) .And. lRet .And. !aColsTYZ[nX,Len(aColsTYZ[nX])]
				If aColsTYZ[nX,2] < M->TNY_DTINIC
					lRet := .F.
					Help( , , STR0111 , , STR0215, 5 , 5 ) //"Existem períodos fora da data de início e fim do atestado. Favor informar outra data."
				EndIf
				If Empty( aColsTYZ[nX,3] ) .And. !Empty( M->TNY_DTFIM )
					lRet := .F.
					Help( , , STR0111 , , STR0216, 5 , 5 ) //"O atestado médico possui data fim, por este motivo os afastamentos também devem possuir."
				EndIf
			EndIf

			//Verifica se existe algum registro duplicado.
			For nY := 1 To Len(aColsTYZ)
				If nX <> nY .And. !Empty( aColsTYZ[nX,2] ) .And. !Empty( aColsTYZ[nX,3] ) ;
					.And. !Empty( aColsTYZ[nY,2] ) .And. !Empty( aColsTYZ[nY,3] ) .And. !aColsTYZ[nY,Len(aColsTYZ[nY])] .And. !aColsTYZ[nX,Len(aColsTYZ[nX])] .And. lRet
					If aColsTYZ[nX,2] >= aColsTYZ[nY,2] .And. aColsTYZ[nX,2] <= aColsTYZ[nY,3] .Or.;
						aColsTYZ[nX,3] >= aColsTYZ[nY,2] .And. aColsTYZ[nX,3] <= aColsTYZ[nY,3]
						Help( , , STR0111 , , STR0206, 5 , 5 )//"Existem períodos sobre postos, favor corrigidar as datas de Saída e Alta."
						lRet := .F.
						Exit
					EndIf
					If ( aColsTYZ[nX,2] == aColsTYZ[nY,2] .Or. aColsTYZ[nX,3] == aColsTYZ[nY,3] ) .And. lRet
						Help( , , STR0111 , , STR0206, 5 , 5 )//"Existem períodos com a mesma data favor corrigir os períodos."
						lRet := .F.
						Exit
					EndIf
				EndIf
				If nY <> Len(aColsTYZ) .And. nX <> nY .And. lRet
					If Empty(aColsTYZ[nY,3]) .And. !aColsTYZ[nY,Len(aColsTYZ[nY])]
						Help( , , STR0111 , , STR0205, 5 , 5 )//"Existe um período sem Data Alta e um posterior, não será possível salvar os afastamentos."
						lRet := .F.
						Exit
					EndIf
				EndIf

			Next nY
		Next nX
	Else //Caso seja LinOk
		If !Empty( aColsTYZ[n,2] ) .And. lRet
			If aColsTYZ[n,2] > aColsTYZ[n,3] .And. !Empty(aColsTYZ[n,3])
				Help( , , STR0111 , , STR0193, 5 , 5 )//ATENÇÃO##"A Data Saída é maior que a Data Alta. Favor informar uma Data Saída inferior a Data Alta."
				lRet := .F.
			EndIf
			If Len(aColsTYZ) > 1 .And. n > 1
				If Empty(aColsTYZ[n-1,3]) .And. !aColsTYZ[n-1,Len(aColsTYZ[n])]
					Help( , , STR0111 , , STR0204, 5 , 5 ) //"O afastamento anterior está sem o preenchimento da Data Alta, não será possivel incluir um afastamento poesterior."
					lRet := .F.
				EndIf
			EndIf
		ElseIf n == 1 .And. Empty(aColsTYZ[n,2]) .And. Empty(aColsTYZ[n,3])
			Help( , , STR0111 , , STR0210, 5 , 5 ) //"O afastamento anterior está sem o preenchimento da Data Saída e Data Alta, não será possivel incluir um afastamento poesterior."
			lRet := .F.
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MT685DTINI
Função que valida a Continuação.

@author Rodrigo Soledade
@since 24/04/2013
/*/
//---------------------------------------------------------------------
Function MT685DTINI()
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685CONT
Continuação do Atestado Médico

@type function

@source MDTA685.prx

@author Jackson Machado
@since 07/07/11

@param nOpcx - Numérico, Determina a opção selecionada.

@sample MDT685CONT(4)

@return Vazio.
/*/
//---------------------------------------------------------------------
Function MDT685CONT(nOpcx)

	Local lRet := .T.

	Private oExecView

	Help( , , STR0111 , , STR0202, 5 , 5 )//'Atenção'##"A Continuação não é mais necessária, na aba de "Afastamentos" pode ser cadastrado todos os afastamentos."
	lRet := .F.

	//Após a Continuação retornas as variaveis para o valor padrão.
	lContinu := .F.

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} A685NEXTAT
era o proximo numero sequencial de Atestado

@type function

@source MDTA685.prx

@author Denis Hyroshi de Souza
@since 01/04/04

@sample A685NEXTAT()

@return cNumAtest - Caracter - Numero do Atestado.
/*/
//---------------------------------------------------------------------
Function A685NEXTAT()

	Local cNumAtest := ""

	IF INCLUI
		cNumAtest := GETSXENUM( "TNY", "TNY_NATEST", , 2 )

		While MDTNumSQL( "TNY", "TNY_NATEST", cNumAtest )
			cNumAtest := GETSXENUM( "TNY", "TNY_NATEST", , 2 )
		End
	Else
		cNumAtest := M->TNY_NATEST
	EndIf

Return cNumAtest

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetCont
Atribui em um array os valores do atestado anterior da continuação.

@author Guilherme Benekendorf
@since 06/01/2014
@version P12
@return lRet
/*/
//---------------------------------------------------------------------
Static Function fGetCont()

	Local nRecnoSR8 := 0
	Local aContinua := {}

	Local aAreaAux := GetArea()
	Local aAreaSR8 := SR8->( GetArea() )

	Local aRecordSR8 := fMontaArSR8( TNY->TNY_CODAFA )

	aAdd( aRecordSR8 , { "R8_DATAINI"	, TNY->TNY_DTSAI3	} )

	If TNY->( ColumnPos( "TNY_CODAFA" ) ) > 0
		aAdd( aRecordSR8 , { "R8_TIPOAFA"		, TNY->TNY_CODAFA 	} )
	EndIf

	nRecnoSR8 := MDTRecnoSR8( aRecordSR8 )
	dbSelectArea( "SR8" )
	SR8->( dbGoTo( nRecnoSR8 ) )
	//Variavel para informar a data anterior de continuacao na A685UPDATE
	aAdd( aContinua , { TNY->TNY_DTALT3 , SR8->R8_DIASEMP, SR8->R8_DPAGAR } )

	RestArea( aAreaAux )
	RestArea( aAreaSR8 )

Return aContinua

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTAtesTAF
Função auxiliar para cadastrar informação em arrays

@param
@author Guilherme Benekendorf
@since 09/09/2014
@version P11
@return

/*/
//---------------------------------------------------------------------
Static Function fGraInfAfa( aGraTmp , aGraRec )

	//Armazena informacoes dos afastamentos antes de gravar
	aAdd( aGraTmp , { SR8->R8_TIPOAFA , SR8->R8_DATAINI , SR8->R8_DATAFIM } )

	aAdd( aGraRec , { SR8->(RecNo()),SR8->R8_SEQ })

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685CID
Função auxiliar para cadastrar informação em arrays

@author Taina A. Cardoso
@since 12/04/11

@return
/*/
//---------------------------------------------------------------------
Function MDT685CID()

	Local nX

	Private lAtesAnt := NGCADICBASE("TNY_ATEANT","A","TNY",.F.)
	Private lDESGRP  := NGCADICBASE("TKI_DESGRP","D","TKI",.F.)

	nGrpCid := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TKI_GRPCID"})
	nCid    := aScan( aHeader, { |x| Trim( Upper(x[2]) ) == "TKI_CID"   })
	nDoenca := aScan( aHeader, { |x| Trim( Upper(x[2]) ) == "TKI_DOENCA"})
	If lAtesAnt .And. lDESGRP
		cKey  := &cGETMAKE.
		aCOLS :=MAKEGETD(cGETALIAS, cKEY,aHeader, cGETWHILE)
		If Empty(aCOLS)
			aCOLS :=BLANKGETD(aHeader)
		EndIf
		If !Empty(aCOLS)
			nDescG := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TKI_DESGRP"})
			For nX := 1 TO Len(aCOLS)
				aCols[nX][nDescG]  := NGSEEK("TLG",aCols[nX][nGrpCid],1,"TLG_DESCRI")
				aCols[nX][nDoenca] := NGSEEK("TMR",aCols[nX][nCid],1,"TMR_DOENCA")
			Next nX
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685COP
Função de Reabertura, utilizada para validar quando for reabertura.

@param oModel, Objeto, Modelo Utilizado.

@author Guilherme Freudenburg
@since 14/03/2017

@return lRet, Numérico, Retorna verdadeiro quando não encontrar inconsistência.
/*/
//---------------------------------------------------------------------
Function MDT685COP( )

	//Local oModelTNY	:= oModelCON:GetModel( "TNYMASTER1" )
	Local	oModel 	:= FWModelActive()

	If lContinu //Caso seja continuação

		oModel:LoadValue( "TNYMASTER1" , "TNY_FILIAL"  , xFilial("TNY") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_NUMFIC"  , TNY->TNY_NUMFIC )
		oModel:LoadValue( "TNYMASTER1" , "TNY_NOMFIC"  , SubStr(POSICIONE('TM0',1,XFILIAL('TM0')+ TNY->TNY_NUMFIC,'TM0_NOMFIC'),1,20) )
		oModel:LoadValue( "TNYMASTER1" , "TNY_GRPCID"  , TNY->TNY_GRPCID )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DESGRP"  , POSICIONE('TLG',1,XFILIAL('TLG')+ TNY->TNY_GRPCID,'TLG_DESCRI') )
		oModel:LoadValue( "TNYMASTER1" , "TNY_CID"  	, TNY->TNY_CID )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DOENCA"  , POSICIONE('TMR',1,XFILIAL('TLG')+ TNY->TNY_CID,'TMR_DOENCA') )
		oModel:LoadValue( "TNYMASTER1" , "TNY_EMITEN"  , TNY->TNY_EMITEN )
		oModel:LoadValue( "TNYMASTER1" , "TNY_NOMUSU"  , POSICIONE('TNP',1,XFILIAL('TNP')+ IF(INCLUI, M->TNY_EMITEN, TNY->TNY_EMITEN),'TNP_NOME') )
		oModel:LoadValue( "TNYMASTER1" , "TNY_ATEANT"  , TNY->TNY_NATEST )
		oModel:LoadValue( "TNYMASTER1" , "TNY_NATEST"  , GETSXENUM("TNY","TNY_NATEST",,2) )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTSAID"  , StoD("") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTALTA"  , StoD("") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTSAI2"  , StoD("") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTALT2"  , StoD("") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTSAI3"  , StoD("") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTALT3"  , StoD("") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTINIC"  , StoD("") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTFIM"   , StoD("") )

	EndIf

Return .F.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG685DAFA
Chama cadastro de Diagnosticos apartir do click da direita.

@sample NG685DAFA()

@author Thiago Olis Machado
@since 17/04/03

@return nDias, Numérico, Quantidade de dias.
/*/
//---------------------------------------------------------------------
Function NG685DAFA()

	Local nDias := 0

	If Type("nDiasAfast") == "N"
		nDias := nDiasAfast
	EndIf

Return nDias

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685TEL
Monta tela MVC quando chamado pela rotina MDTA160.

@sample MDT685TEL()

@author Guilherme Freudenburg
@since 30/11/2017

@return Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
Function MDT685TEL(nOpca)

	Local nX := 0
	//Adiciona campos que não receberão valor no Modelo de Dados
	Local aCpsVir := { "TNY_NOMFIC", "TNY_DESGRP", "TNY_DOENCA", "TNY_NOMUSU", "TNY_NOMUSU",;
					   "TNY_NOMUSU", "TNY_ESPDES", "TNY_ABODES", "TNY_DESCAD", "TNY_DESACI",;
					   "TNY_ATEANT", "TNY_USERGI", "TNY_DTSAID", "TNY_DTALTA", "TNY_DTSAI2",;
					   "TNY_DTALT2", "TNY_DTSAI3", "TNY_DTALT3", "TNY_TPEFD"  }

	Private oExecTEL
	Private lDiagnos   := .T.
	Private oView
	Private oModel := FWLoadModel( "MDTA685" )

	Default nOpca := 3

	If nOpca <> 1
		oModel:SetOperation(nOpca)
	EndIf
	oModel:Activate()

	If nOpca <> 5 .And. nOpca <> 1
		If nOpca <> 3
			dbSelectArea( "TNY" )
			For nX := 1 To FCount()
				If aScan( aCpsVir , { | x | FieldName( nX ) == x }  ) == 0
					oModel:LoadValue( "TNYMASTER1", FieldName( nX )  , TNY->( &( FieldName( nX ) ) )  )
				EndIf
			Next nX
		ElseIf nOpca == 3 .And. Type( "sNUMFIC" ) == "C"
			oModel:LoadValue( "TNYMASTER1", "TNY_NUMFIC"  , sNUMFIC  )
			oModel:LoadValue( "TNYMASTER1", "TNY_NOMFIC"  , sNOMFIC  )
		EndIf
	EndIf

	oView := FWLoadView("MDTA685")
	oView:SetModel(oModel)
	oView:SetOperation(nOpca)

	oExecTEL := FWViewExec():New()
	oExecTEL:SetTitle("Acidentes")
	oExecTEL:SetView(oView)
	oExecTEL:SetModal(.F.)
	oExecTEL:SetCloseOnOK({|| .T. })
	oExecTEL:SetOperation(nOpca)
	oExecTEL:OpenView(.T.)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685PRE
Função responsável por fazer a Pré-Validação da Grid de TYZ - Afastamentos.

@sample MDT685PRE()

@author Guilherme Freudenburg
@since 30/11/2017

@return lRet - Lógico - Quando o funcionário for um candidato retorna .F.
/*/
//---------------------------------------------------------------------
Function MDT685PRE(oModel)

	Local lRet := .T.

	If IsInCallStack("MDTA410")
		If !Empty(M->TNY_NUMFIC)
			If !Empty(Posicione( "TM0", 1, xFilial( "TM0" ) + M->TNY_NUMFIC, "TM0_CANDID" )) .And. ;
				Empty(Posicione( "TM0", 1, xFilial( "TM0" ) + M->TNY_NUMFIC, "TM0_MAT" ))
				Help( , , STR0111 , , STR0203, 5 , 5 )//"ATENÇÃO"##""Esta ficha médica é de um candidato, não será possível informar afastamentos.""
				lRet := .F.
			EndIf
		EndIf
	Else
		oModel 	:= FWModelActive()  //Copia o Model utilizado.
		If !Empty(oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ))
			If !Empty(Posicione( "TM0", 1, xFilial( "TM0" ) + oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ), "TM0_CANDID" )) .And. ;
				Empty(Posicione( "TM0", 1, xFilial( "TM0" ) + oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ), "TM0_MAT" ))
				Help( , , STR0111 , , STR0203, 5 , 5 )//"ATENÇÃO"##""Esta ficha médica é de um candidato, não será possível informar afastamentos.""
				lRet := .F.
			EndIf
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685LIP
Função responsável por realizar a limpesa dos campos da Data.

@sample MDT685LIP()

@param oGet, Objeto,  Objeto de montagem da tela.

@author Guilherme Freudenburg
@since 30/11/2017

@return Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
Function MDT685LIP(oGet)

	Local nTOT := Len(oGet:aCols)

	If !Empty(oGet:aCols[oGet:oBrowse:nAt,2]) .And. nTOT > Len(aColsTYZ)
		oGet:aCols[oGet:oBrowse:nAt,2] := STOD("")
		oGet:aCols[oGet:oBrowse:nAt,3] := STOD("")
		oGet:Refresh()
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685COND
Função de Pré-validação para a continuação.

@sample MDT685COND()

@param oModel, Objeto,  Modelo do MVC.

@author Guilherme Freudenburg
@since 30/11/2017

@return Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
Function MDT685COND(oModel)

	If (Type("lContinu") == "L" .And. Type("lPriCont") == "L") .And. (lContinu .And. lPriCont)
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTSAID"  , StoD("") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTALTA"  , StoD("") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTSAI2"  , StoD("") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTALT2"  , StoD("") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTSAI3"  , StoD("") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_DTALT3"  , StoD("") )
		oModel:LoadValue( "TNYMASTER1" , "TNY_ATEANT"  , TNY->TNY_NATEST )
		lPriCont := .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT685FIM
Função responsável pela validação da data fim do atestado pelo MDTA410

@sample MDT685FIM(.T.)

@param lMdt410, Lógico,  Determina que foi chamado pelo MDTA410.

@author Guilherme Freudenburg
@since 30/11/2017

@return lRet, Lógico, Caso encontro alguma inconsistênca retornará .F.
/*/
//---------------------------------------------------------------------
Function MDT685FIM( lMdt410, cNates, dDataFim )

	Local lRet := .T.
	Local cAffast := GetNextAlias()

	Default lMdt410 := .T.
	Default cNates := ""
	Default dDataFim := StoD("")

	BeginSql Alias cAffast
		SELECT COUNT(TYZ_SEQ) AS TOTAL FROM %Table:TYZ% TYZ
			WHERE TYZ.%NotDel% AND
			TYZ.TYZ_FILIAL = %xFilial:TYZ% AND
			TYZ.TYZ_NATEST = %exp:cNates% AND
			TYZ.TYZ_DTALTA > %exp:dDataFim%
	EndSql

	If (cAffast)->TOTAL > 0
		lRet := .F.
		Help( , , STR0111 , , STR0214, 5 , 5 )//"Não será possível alterar a data fim do atestado, pois existem afastamentos posteriores a esta data."
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fEntCalsse
Função que retorna a entidade de classe do médico para alimentar o
campo R8_IDEOC da tabela SR8(Controle de Ausência)
1 = CRM
2 = CRO
3 = RMS

@author  Julia Kondlatsch
@since   24/04/2018
@sample  fEntCalsse("0001")
@param   cEmitTNY, Caractere, Código do Emitente

@return  cRet, Caractere, Número da entidade equivalente no campo
R8_IDEOC
/*/
//-------------------------------------------------------------------
Static Function fEntCalsse( cEmitTNY )

	Local cRet 		:= ""
	Local cEntidade := ""

	cEntidade := AllTrim( Posicione("TNP", 1, xFilial("TNP")+cEmitTNY, "TNP_ENTCLA") ) //Emitentes de Atestado

	Do Case
		Case "CRM" $ Upper(cEntidade)
			cRet := "1"
		Case "CRO" $ Upper(cEntidade)
			cRet := "2"
		Case "RMS" $ Upper(cEntidade)
			cRet := "3"
		OtherWise
			cRet := ""
	EndCase

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fVerificaDatas
Valida se o período do atestado não coincide com algum outro atestado
do funcionário.

@type    function
@author  Julia Kondlatsch
@since   07/12/2018
@sample  fVerificaDatas( '001', oModel )

@param   cNumFiTNY, Numérico, Ficha do registro atual
@param   oModel, Objeto, Modelo de dados

@return  Nil, Sempre Nulo
/*/
//-------------------------------------------------------------------
Function fVerificaDatas( cNumFiTNY, oModel )

	Local lRet    := .T.
	Local lMsg    := .F.
	Local nVer    := 0
	Local cMat    := Posicione('TM0',1, xFilial('TM0')+cNumFiTNY, 'TM0_MAT')

	dbSelectArea( "TNY" )
	dbSetOrder( 1 )
	dbSeek( xFilial( "TNY" ) + cNumFiTNY ) //Vai até o primeiro registro de atestado do funcionário.
	//Enquanto o registro for do funcionário ele verifica
	While TNY->(!EoF()) .And. xFilial( "TNY" ) == TNY->TNY_FILIAL .And. TNY->TNY_NUMFIC == cNumFiTNY
		//Se não for o registro que ele está atualmente
		If nRecTNY_ <> TNY->( Recno() )

 			//Se o registro atual for aberto e existir outro em aberto, notifica.
			If lProDFim .And. Empty( TNY->TNY_DTFIM )
				cMsgTNY := STR0115 //"Existe outro atestado com data de término em aberto."
				cMsgTNY += Chr(13)+Chr(10)+Chr(13)+Chr(10)
				cMsgTNY += STR0117+DTOC(TNY->TNY_DTINIC)+Chr(13)+Chr(10) //"Data Inicio: "
				cMsgTNY += STR0118+(TNY->TNY_HRINIC)+Chr(13)+Chr(10) //"Hora Inicio: "
				cMsgTNY += STR0119+DTOC(TNY->TNY_DTFIM)+Chr(13)+Chr(10) //"Data Fim...: "
				cMsgTNY += STR0120+(TNY->TNY_HRFIM)+Chr(13)+Chr(10) //"Hora Fim...: "
				lRet := .F.
				Exit
			EndIf

			//Se o atestado atual estiver dentro do intervalo de outro atestado que não tem afastamento
			If  Empty( TNY->TNY_CODAFA ) .And. ( DtoS(_DataIni)+_HoraIni < DtoS(If( Empty(TNY->TNY_DTFIM) , ;
				dDataBase+5000 , TNY->TNY_DTFIM )) + IIf( Alltrim(TNY->TNY_HRFIM) == ":" , "23:59" , TNY->TNY_HRFIM ) .And.;
				DtoS(_DataFim)+_HoraFim > DtoS(TNY->TNY_DTINIC)+TNY->TNY_HRINIC)

				lMsg := .T.
				Exit

			EndIf

		EndIf
		TNY->(dbSkip())
	End

	dbSelectArea('TYZ')
	dbSetOrder(1) //TYZ_FILIAL+TYZ_MAT+DTOS(TYZ_DTSAID)+TYZ_TIPO+TYZ_TIPOAF
	dbSeek( xFilial('TYZ') + cMat + DTOS(_DataIni), .T.) //Posiciona no registro mais próximo a busca do afastamento da ficha do funcionário
	If Empty(_CodAfas) .And. Empty(_cTipAfas)//Se não tiver afastamento

		For nVer := 1 To 2 //Verifica o registro seguinte e o anterior ao fastamento

			//Se o intervalo da TNY estiver dentro de algum intervalo da TYZ do mesmo funcionário
			If TYZ->TYZ_MAT == cMat .And. ( _DataIni == TYZ->TYZ_DTSAID .Or. ( _DataFim > TYZ->TYZ_DTSAID .And. TYZ->TYZ_DTALTA > _DataIni) ) .And.;
				TYZ->TYZ_NATEST != oModel:GetValue( 'TNYMASTER1', 'TNY_NATEST' )
				lMsg := .T.
				//Posiciona no atestado que há conflito para mostrar corretamente na mensagem
				TNY->( dbSetOrder( 2 )  )
				TNY->( dbSeek( xFilial('TNY') + TYZ->TYZ_NATEST ) )
				Exit
			EndIf

			TYZ->(dbSkip(-1))

		Next nVer

	EndIf

	If lMsg
		cMsgTNY := STR0116 //"Existe outro atestado cadastrado para o mesmo intervalo."
		cMsgTNY += Chr(13)+Chr(10)+Chr(13)+Chr(10)
		cMsgTNY += STR0117+DTOC(TNY->TNY_DTINIC)+Chr(13)+Chr(10) //"Data Inicio: "
		cMsgTNY += STR0118+(TNY->TNY_HRINIC)+Chr(13)+Chr(10) //"Hora Inicio: "
		cMsgTNY += STR0119+DTOC(TNY->TNY_DTFIM)+Chr(13)+Chr(10) //"Data Fim...: "
		cMsgTNY += STR0120+(TNY->TNY_HRFIM)+Chr(13)+Chr(10) //"Hora Fim...: "
		lRet := .F.
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTA685DIA
Função para atualizar o campo TNY_QTDIAS de acordo com os registros de
afastamento da TYZ

@type    function
@author  Julia Kondlatsch
@since   11/01/2019
@sample  AtuQtAfas()

@return  nQtdDias, Numérico, Retorna a quantidade de dias
(Para o gatilho do campo TNY_DTINIC )
/*/
//-------------------------------------------------------------------
Function MDTA685DIA()

	Local oGrid
	Local oModel
	Local oView
	Local aAfast    := {}
	Local dDtInic   := StoD('')
	Local dDtFinal  := StoD('')
	Local nQtdDias  := 0
	Local nAfas     := 0
	Local nPosDtSa  := 0
	Local nPosDtAl  := 0
	Local lVazio    := .F.
	Local aColsOk   := {}
	Local lExecAuto	:= !( FunName() $ "MDTA685/MDTA410/MDTA110F" )

	If IsInCallStack("MDTA410")

		nPosDtSa := aScan( aHeader, { | x | Alltrim(UPPER(x[2])) == "TYZ_DTSAID" } )
		nPosDtAl := aScan( aHeader, { | x | Alltrim(UPPER(x[2])) == "TYZ_DTALTA" } )

		If nPosDtSa > 0 // Se for a atualização pelo campo TYZ_DTALTA

			cHrIni  := TNY->TNY_HRINIC
			cHrFim  := TNY->TNY_HRFIM
			cNumFic := TNY->TNY_NUMFIC

			aColsOk  := aClone( oGetLOC:aCols )
			nTamGrid := Len( aColsOk )
			If Len( aColsOk ) == 1 .And. Empty( aColsOk[ 1, nPosDtSa ] ) //Se a grid não estiver vazia
				lVazio := .T.
			EndIf

		Else

			cHrIni  := M->TNY_HRINIC
			cHrFim  := M->TNY_HRFIM
			cNumFic := M->TNY_NUMFIC

			dbSelectArea( 'TYZ' )
			dbSetOrder( 2 )
			If dbSeek( xFilial('TYZ') + M->TNY_NATEST ) //Se houver afastamentos na TYZ
				While TYZ->(!EoF()) .And. TYZ->TYZ_FILIAL == xFilial( 'TYZ' ) .And. TYZ->TYZ_NATEST == M->TNY_NATEST
					If !Empty(TYZ->TYZ_DTALTA)

						aAdd( aAfast, { TYZ->TYZ_DTSAID, TYZ->TYZ_DTALTA } )

					EndIf

					TYZ->(dbSkip())
				EndDo
			EndIf

			nTamGrid := Len(aAfast)
			lVazio   := nTamGrid == 0

		EndIf

	Else

		If lExecAuto
			oModel   := FWLoadModel("MDTA685")
			oModel:Activate()
			oView    := FWLoadView("MDTA685")
		Else
			oModel   := FWModelActive()
			oView    := FWViewActive()
		EndIf

		oGrid    := oModel:GetModel( 'TYZDETAIL' )
		cHrIni   := oModel:GetValue( 'TNYMASTER1', 'TNY_HRINIC' )
		cHrFim   := oModel:GetValue( 'TNYMASTER1', 'TNY_HRFIM'  )
		cNumFic  := oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC')
		nTamGrid := oGrid:Length()

		If nTamGrid == 1 .And. Empty( oGrid:GetValue("TYZ_DTSAID") )
			lVazio := .T.
		EndIf

	EndIf

	If !lVazio

		For nAfas := 1 To nTamGrid //Percorre todos os registro de afastamento do atestado

			If !IsInCallStack("MDTA410") // Chamada no cadastro de afastamento

				oGrid:GoLine( nAfas )
				dDtInic  := oGrid:GetValue( "TYZ_DTSAID" )
				dDtFinal := oGrid:GetValue( "TYZ_DTALTA" )

			ElseIf nPosDtSa > 0 // Chamada prontuário grid afastamento
				dDtInic  := aColsOk[ nAfas, nPosDtSa ]
				dDtFinal := aColsOk[ nAfas, nPosDtAl ]
			Else // Chamada prontuário campos atestado
				dDtInic  :=	aAfast[ nAfas, 1 ]
				dDtFinal := aAfast[ nAfas, 2 ]
			EndIf

			nQtdDias += MDTA685CLC( dDtInic, dDtFinal, Alltrim(cHrIni), Alltrim(cHrFim), cNumFic, nAfas, nTamGrid )

		Next nAfas

	ElseIf !Empty( M->TNY_DTINIC ) .And. !Empty( M->TNY_DTFIM ) .And. !Empty(M->TNY_NUMFIC)

		nQtdDias := MDTA685CLC( M->TNY_DTINIC, M->TNY_DTFIM, Alltrim(cHrIni), Alltrim(cHrFim), cNumFic)

	EndIf

	If !IsInCallStack("MDTA410")
		oModel:LoadValue( 'TNYMASTER1', 'TNY_QTDIAS', nQtdDias )
	ElseIf nPosDtSa > 0
		Reclock("TNY",.F.)
			TNY->TNY_QTDIAS := nQtdDias
		TNY->(MsUnlock())
	Else
		M->TNY_QTDIAS := nQtdDias
	EndIf

Return nQtdDias

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTA685CLC
Calcula os dias de afastamento do pedíodo de acordo com os valores
passado por parâmetros

@type    function
@author  Julia Kondlatsch
@since   15/01/2019
@sample  MDTA685CLC( 01/01/2019, 05/01/19, "10:30", "20:00", "0002", 1, 2 )

@param   dDtInic, Data, Data inicial do período de afastamento
@param   dDtFinal, Data, Data inicial do período de afastamento
@param   cHrIni, Caractere, Hora do iniciao do afastamento
@param   cHrFim, Caractere, Hora do final do afastamento
@param   cNumFic, Caractere, Numero da ficha médica do funcionário
@param   [nAfas], Numérico, Número da linha do afastamento do atestado
@param   [nTamGrid], Numérico, Número de linhas de afastamento do
		 atestado

@return  nQtdDias, Numérico, Número de dias de afastamento do período
/*/
//-------------------------------------------------------------------
Function MDTA685CLC( dDtInic, dDtFinal, cHrIni, cHrFim, cNumFic, nAfas, nTamGrid, cHrsPerd )

	Local nDias    := 0
	Local cEntrada := '00:00'
	Local cSaida   := '00:00'
	Local cSumHora := '00:00'
	Local cHoras   := '00'
	Local cMinutos := '00'
	Local lNoturno := .F.
	Local lAfaGpe  := SuperGetMv( "MV_NGMDTAF" , .F. , "N" ) == "S"
	Local lPonGpe  := MDT685VPON( lAfaGpe )

	Default nAfas    := 1
	Default nTamGrid := 1
	Default cHrsPerd  := '00:00'

	If lPonGpe
		lNoturno := MDT685TUR( cNumFic, dDtInic  )[1]
		cEntrada := MDT685TUR( cNumFic, dDtInic  )[2]
		cSaida	 := MDT685TUR( cNumFic, dDtFinal )[3]
	EndIf

	lSemHor := ( cEntrada == '00:00' .And. cSaida == '00:00' )

	If !Empty(dDtFinal)
		nDias += dDtFinal - dDtInic + 1

		If !lNoturno

			If nAfas == 1

				If !( ( ( lPonGpe .And. !lSemHor ) .And. cHrIni <= cEntrada ) .Or.;
					( ( !lPonGpe .Or. lSemHor ) .And. cHrIni == "00:00") ) // Se saiu depois do início do turno

					nDias--
					cHrsPerd := NGRETIRAHOR(cSaida, cHrIni)[1]

				EndIf

			EndIf

			If nAfas == nTamGrid .And. !Empty( cHrFim )

				If !( ( ( lPonGpe .And. !lSemHor ) .And. cHrFim >= cSaida ) .Or. ;
					( ( !lPonGpe .Or. lSemHor ) .And. cHrFim == "23:59" ) ) // Se antes do fim do turno

					If nDias > 0
						nDias--
						cSumHora := NGRETIRAHOR(cHrFim, cEntrada)[1]
						cHoras   := SubStr(cSumHora, 1, 2)
						cMinutos := SubStr(cSumHora, 4, 2)
						cHrsPerd := SubStr(IncTime(cHrsPerd, Val(cHoras), Val(cMinutos)), 1, 5)
					EndIf

				EndIf

			EndIf

		EndIf

	EndIf

Return nDias

//-------------------------------------------------------------------
/*/{Protheus.doc} fValCodAfa
Valida o código de afastamento informado.

@type    function
@author  Julia Kondlatsch
@since   13/02/2019
@sample  fValCodAfa( '00115258', '001' )

@param   cNumAtes, Caractere, Código do atestado atual
@param   cCodAfas, Caractere, Código do afastamento atual
@param	 lAltera , Lógico, Se está alterando o reistro.
(Se o valor for falso indica que é inclusão)

@return  lRet, Lógico, Verdadeiro se o código de afastamento for
válido
/*/
//-------------------------------------------------------------------
Function fValCodAfa( cNumAtes, cCodAfas, lAltera )

	Local lRet      := .T.
	Local aAreaTNY  := TNY->(GetArea())
	Local lAfas     := .F.
	Local cCodSef   := SubStr( Posicione( 'RCM', 1, xFilial('RCM') + cCodAfas, 'RCM_CODSEF' ) , 1, 1 )
	Local nY        := 0
	Local oModel    := FWModelActive()
	Local oGrid
	Local lTotDel := .T.
	Local nI

	If lAltera // Alteração com TYZ

		dbSelectArea('TYZ')
		dbSetOrder(2) // TYZ_FILIAL+TYZ_NATEST+DTOS(TYZ_DTSAID)+DTOS(TYZ_DTALTA)
		lAfas := dbSeek( xFilial('TYZ') + cNumAtes )

	ElseIf !lAltera .And. !IsInCallStack('MDTA410')// Inclusão com TYZ

		oGrid := oModel:GetModel('TYZDETAIL')

		For nY := 1 to oGrid:Length()
			oGrid:GoLine( nY )
			If !( oGrid:IsDeleted() ) // Verifica se o registro não está deletado.
				lAfas := !Empty( oGrid:GetValue( 'TYZ_DTSAID' ) ) .Or. !Empty( oGrid:GetValue( 'TYZ_DTALTA' ) )
			EndIf
		Next nY

	EndIf

	If lAfas
		oGrid := oModel:GetModel('TYZDETAIL')

		For nI := 1 To oGrid:Length()
			oGrid:GoLine( nI )
			If !( oGrid:IsDeleted() )
				lTotDel := .F.
				Exit
			EndIf
		Next nI

		If lTotDel
			lAfas := .F.
		EndIf
	EndIf

	If Empty( cCodAfas ) .And. lAfas
		Help( , , STR0111, , STR0212, 5, 5 ) // "Não será permitido deixar o campo 'Cód. Ausência' vazio, pois o atestado médico possui afastamentos."
		lRet := .F.
	ElseIf lAltera .And. lAfas // Se foi modifiacado o código do afastamento

		dbSelectArea('TNY')
		dbSetOrder(2) // TNY_FILIAL+TNY_NATEST
		If dbSeek( xFilial('TNY') + cNumAtes ) .And. cCodAfas <> TNY->TNY_CODAFA

			If Empty( TNY->TNY_CODAFA ) // Se foi gravado com o código vazio
				If !Empty( TNY->TNY_TIPAFA ) .And. cCodSef <> TNY->TNY_TIPAFA
					Help( , , STR0111, , STR0222, 5, 5 ) // "O campo 'Cód.Ausência' possui um Código de Ausência SEFIP diferente do 'Tipo Afasta.' já informado."
					lRet := .F.
				EndIf
			Else
				Help( , , STR0111, , STR0217, 5, 5 ) // "O campo 'Cód.Ausência' não poderá ser alterado, pois o atestado possui afastamentos."
				lRet := .F.
			EndIf

		EndIf

	EndIf

	RestArea(aAreaTNY)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fContinua
Define o valor do campo de continuação de afastamento
@type function

@author Gabriel Sokacheski
@since 08/06/2021

@param oModel, Objeto, Model dos registros da TNY
@param oGrid, Objeto, Grid dos registros da TYZ
@param oGridSR8, Objeto, Grid dos registros atuais da SR8
@param cMat, Caractere, Matrícula do funcionário
@param cCid, Caractere, Código CID do atestado
@param cGrupo, Caractere, Código grupo CID do atestado

@return cSeq, Caractere, Sequência do afastamento a ser continuado
/*/
//-------------------------------------------------------------------
Static Function fContinua( oModel, oGrid, oGridSR8, cMat, cCid, cGrupo )

	Local aNaoConti := {} // Array de afastamentos que não devem ser continuados

	Local nI := 0
	Local nDias := Val( SuperGetMv( 'MV_NG2QTVE', .F., '60' ) )

	Local cSeq := ''
	Local cCodAus := oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' )
	Local cAliasSR8 := GetNextAlias()
	Local cSeqAtual := oGrid:GetValue( 'TYZ_SEQ' )
	Local cConCidDif := IIf( SuperGetMv( 'MV_NG2COAF', .F., 1 ) == 0, 1, SuperGetMv( 'MV_NG2COAF', .F., 1 ) ) // 1=Questiona; 2=Continua; 3=Não continua;

	Local dDtSaida := oGrid:GetValue( 'TYZ_DTSAID' )
	Local dPeriodo := DaySub( dDtSaida , nDias ) // Afastamentos a serem contínuados devem ser maior que esta data
	Local dDtInicio := CToD( '  /  /  ' )

	Local lContinua  := .F.
	Local lNaoDeseja := .T.
	Local lExecAuto	 := IsBlind() .Or. !( AllTrim( FunName() ) $ 'MDTA685/MDTA410/MDTA110F/MDTA686/TCFA040' )

	If ( !Empty( cCid ) .Or. !Empty( cGrupo ) )

		BeginSQL Alias cAliasSR8
			SELECT SR8.R8_SEQ, SR8.R8_DATAINI, SR8.R8_DATAFIM, SR8.R8_MAT, SR8.R8_TIPOAFA, SR8.R8_CID, TNY.TNY_GRPCID, TNY.TNY_CID, TNY.TNY_CODAFA
			FROM %table:SR8% SR8
				LEFT JOIN %table:TYZ% TYZ ON
					TYZ.TYZ_FILIAL = %xFilial:TYZ%
					AND TYZ.TYZ_MAT = SR8.R8_MAT
					AND TYZ.TYZ_SEQ = SR8.R8_SEQ
					AND TYZ.%notDel%
				LEFT JOIN %table:TNY% TNY ON
					TNY.TNY_FILIAL = %xFilial:TNY%
					AND TNY.TNY_NATEST = TYZ.TYZ_NATEST
					AND TNY.%notDel%
			WHERE 
				SR8.R8_FILIAL = %xFilial:SR8%
				AND SR8.R8_MAT = %exp:cMat%
				AND SR8.R8_SEQ != %exp:cSeqAtual%
				AND SR8.R8_DATAINI <= %exp:dDtSaida%
				AND SR8.R8_DATAFIM >= %exp:dPeriodo%
				AND SR8.%notDel%
			ORDER BY SR8.R8_DATAINI DESC
		EndSQL

		// Sequência de afastamentos que não devem ser continuados
		aNaoConti := fNaoConti( cMat, cSeqAtual, dDtSaida, dPeriodo )

		// Caso encontre afastamentos para continuar
		While ( cAliasSR8 )->( !EoF() )

			// Permite continuação caso ausência seja a mesma ou para mesmo grupo de CID (verificado "grupo" usando o CID)
			If ( ( ( ( cAliasSR8 )->R8_TIPOAFA == cCodAus ) .Or. ( ( cAliasSR8 )->TNY_CODAFA == cCodAus ) ) .Or. ( !Empty( cCid ) .And. Left( ( cAliasSR8 )->TNY_CID, 3 ) == Left( cCid, 3 ) ) )

				// Verifica se a sequência atual pode ser continuada
				If IIf( Len( aNaoConti ) > 0, aScan( aNaoConti, ( cAliasSR8 )->R8_SEQ ) == 0, .T. )

					If !Empty( cCid ) .And. ( ( AllTrim( ( cAliasSR8 )->R8_CID ) == AllTrim( cCid ) ) .Or. ( ( cAliasSR8 )->TNY_CID == cCid ) )

						lContinua := .T.

					ElseIf cConCidDif == 2

						lContinua := .T.

					ElseIf cConCidDif == 1 .And. ( IIf( lExecAuto, .T., lNaoDeseja := MsgYesNo(;
							STR0237 /* "Ficha Médica" */ + ': ' + oModel:GetValue( 'TNYMASTER1', 'TNY_NUMFIC' ) +;
							Chr( 13 ) + Chr( 10 ) +;
							STR0157 /* "Funcionário" */ + ': ' + oGrid:GetValue( 'TYZ_MAT' ) +;
							Chr( 13 ) + Chr( 10 ) +;
							STR0238 /* "Data Início e Fim" */ + ': ' + DtoC( oModel:GetValue( 'TNYMASTER1', 'TNY_DTINIC' ) ) + ' - ' + DtoC( oModel:GetValue( 'TNYMASTER1', 'TNY_DTFIM' ) ) +;
							Chr( 13 ) + Chr( 10 ) +;
							Chr( 13 ) + Chr( 10 ) +;
							STR0230 +; // "Deseja considerar este registro uma continuação do afastamento com período de "
							DToC( SToD( ( cAliasSR8 )->R8_DATAINI ) ) +;
							STR0231 +; // " até "
							DToC( SToD( ( cAliasSR8 )->R8_DATAFIM ) ) +;
							STR0232 +; // " com CID "
							( cAliasSR8 )->R8_CID + '?';
						) ) )

						lContinua := .T.

					EndIf

					If lContinua

						If ( oGrid:SeekLine( { { 'TYZ_SEQ', ( cAliasSR8 )->R8_SEQ } }, .T. ) .And. !oGrid:IsDeleted() ) .Or. ;
							!oGrid:SeekLine( { { 'TYZ_SEQ', ( cAliasSR8 )->R8_SEQ } }, .T. )

							lNaoDeseja := .T.
							cSeq := ( cAliasSR8 )->R8_SEQ
							dDtInicio := SToD( ( cAliasSR8 )->R8_DATAINI )
							Exit

						EndIf

					EndIf

				EndIf

			EndIf

			( cAliasSR8 )->( dbSkip() )

		End

		( cAliasSR8 )->( dbCloseArea() )

		// Verifica se deve continuar algum afastamento da própria grid
		For nI := 1 To oGrid:Length()

			oGrid:GoLine( nI )

			If oGrid:GetValue( 'TYZ_SEQ' ) != cSeqAtual .And.;
				oGrid:GetValue( 'TYZ_DTSAID' ) > dDtInicio .And.;
				oGrid:GetValue( 'TYZ_DTSAID' ) <= dDtSaida .And.;
				oGrid:GetValue( 'TYZ_DTALTA' ) >= dPeriodo .And.;
				!oGrid:IsDeleted()

				cSeq := oGrid:GetValue( 'TYZ_SEQ' )

			EndIf

		Next nI

		// Organiza os afastamentos caso o afastamento lançado esteja entre dois já existentes
		If oGridSR8:SeekLine( { { 'R8_CONTAFA', cSeq } } ) .And. oGridSR8:GetValue( 'R8_SEQ' ) != cSeqAtual

			oGridSR8:LoadValue( 'R8_CONTAFA', cSeqAtual )

		EndIf

		// Caso usuário não queira continuar o afastamento
		If !lNaoDeseja

			cSeq := ''

		EndIf

	EndIf

Return cSeq

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTA685VEM
Valida o conteúdo dos campos TNY_EMITEN e TNP_INDFUN, verificando
se tem função de médico e se os campos de Entidade de Classe
(TNP_ENTCLA) e Número da Entidade de Classe (TNP_NUMENT) do cadastro
do médico, estão preenchidos caso haja integração com o eSocial.

@type    function
@author  Julia Kondlatsch
@since   19/03/2019
@sample  MDTA685VEM( 1 )
@param   nCampo, Numérico, Indica qual campo está sendo validado
1 - TNY_EMITEN, 2 - TNP_INDFUN

@return  lRet, Lógico, verdadeiro quando o emitente tiver um código
de fução válido
/*/
//-------------------------------------------------------------------
Function MDTA685VEM( nCampo )

	Local lRet      := .T.
	Local cTipos    := SuperGetMV('MV_NG2FUNM' , .F. , '1/6/A/C' )
	Local cIndFunc  := IIf( nCampo == 1, Posicione( 'TNP', 1, xFilial('TNP') + M->TNY_EMITEN, 'TNP_INDFUN' ), M->TNP_INDFUN )
	Local cDescFun  := AllTrim( Posicione('SX5', 1, xFilial('SX5')+'P1'+cIndFunc, 'X5Descri()') )
	Local lParNMod  := cTipos == '1/6/A/C' // Se o parâmetro não existe ou não foi modificado

	If nCampo == 1 // TNY_EMITEN

		If !( cIndFunc $ cTipos )
			Help( , , STR0111 , , IIf( lParNMod, STR0223, STR0226 + cIndFunc + ' - ' + cDescFun + STR0227) ;
				, 5 , 5 , , , , , , { STR0225 } )
			// "Atestados médicos só podem ser gerados por emitentes com as funções:
			// 1 - Médico do Trabalho, 6 - Médico, A - Fisioterapeuta ou C - Médico Terceiro. "
			// "A função " # " não está cadastrada no parâmetro MV_NG2FUNM como uma função liberada para emitir atestados médicos"
			// "Favor informar outro emitente"
			lRet := .F.
		EndIf

	Else // TNP_INDFUN

		If !(cIndFunc $ cTipos)
			If !IsBlind() .And. !MsgYesNo( IIf( lParNMod, STR0223, STR0226 + cIndFunc + ' - ' + cDescFun + STR0227 )  + STR0224 )
				// "Atestados médicos só podem ser gerados por emitentes com as funções:
				// 1 - Médico do Trabalho, 6 - Médico, A - Fisioterapeuta ou C - Médico Terceiro. "
				// "A função " # " não está cadastrada no parâmetro MV_NG2FUNM como uma função liberada para emitir atestados médicos"
				// "Deseja cadastrar mesmo assim?"
				lRet := .F.
			EndIf
		EndIf

	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fLoadValue
Carrega apenas os valores alterados no modelo da grid de afastamentos

@type    function
@author  Julia Kondlatsch
@since   14/06/2019
@sample  fLoadValue( oGridSR8, 5, 'R8_FILIAL', 'D MG 01  ' )

@param   oGrid, Objeto, Grid de asfatamentos do funcionário
@param   nTYZ, Numérico, Posição na grid de afastamentos
@param   cField, Caractere, Campo sendo informado
@param   xValue, Indefinido, Valor a ser inserido no campo

@return  Nil, Sempre nulo
/*/
//-------------------------------------------------------------------
Static Function fLoadValue( oGrid, nTYZ, cField, xValue )

	Local nTamSX3    := TAMSX3( cField )[ 1 ]
	Local xValueTrat := If( ValType( xValue ) == "C", PadR( xValue, nTamSX3 ), xValue )

	If nTYZ == 0 .Or. oGrid:GetValue( cField ) <> xValueTrat
		If cField == 'R8_DATAINI' .Or. cField == 'R8_DATAFIM'
			// Os campos de data possuem validação do período no GPE, portanto deve ser utilizado o SetValue
			oGrid:SetValue( cField, xValueTrat )
		Else
			oGrid:LoadValue( cField, xValueTrat )
		EndIf
	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} MDT685WFic

Verifica se o campo TNY_NUMFIC pode ser editado ou não

@author	Luis Fellipy Bett
@since	16/01/2020
@return	lRet, Lógico, Verdadeiro ou falso de acordo com a condição
/*/
//-------------------------------------------------------------------
Function MDT685WFic()

	Local lRet		:= .T.
	Local lExecAuto	:= !( FunName() $ "MDTA685/MDTA410" )

	If !lExecAuto
		
		lRet := IsInCallStack('MDTA685') .and. !IsInCallStack('MDT685CONT')

	ElseIf IsInCallStack( 'MDTA110' )

		lRet := .F.

	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fTemConti
Verifica se o afastamento vinculado ao atestado possui continuação.
@type function

@author	Gabriel Sokacheski
@since	25/11/2020

@param oGrid, Model dos registros
@param oGrid, Grid dos registros
@param lExclusao, indica se é exclusão caso contrário é alteração

@return	lRet, Lógico, Verdadeiro caso o afastamento não possua continuação.
/*/
//-------------------------------------------------------------------
Static Function fTemConti( oModel, oGrid, lExclusao )

	Local lRet 		:= .T.
	Local lValida	:= .F.

	Local nAtestado	:= 0

	If SuperGetMv( 'MV_MDTGPE', .F., 'N' ) == 'S' .And. SuperGetMv( 'MV_NGMDTAF' , .F. , 'N' ) == 'S'

		If !lExclusao // Se não for exclusão verifica se algum afastamento foi alterado

			For nAtestado := 1 To oGrid:Length()

				oGrid:GoLine( nAtestado )

				If oGrid:IsFieldUpdated( 'TYZ_DTSAID' ) .Or. oGrid:IsFieldUpdated( 'TYZ_DTALTA' )
					lValida := .T.
					Exit
				EndIf

			Next nAtestado

		EndIf

		If lValida .Or. lExclusao

			DbSelectArea( 'SR8' )
			( 'SR8' )->( DbSetOrder( 1 ) )

			If ( 'SR8' )->( DbSeek( FWxFilial( 'SR8' ) + oGrid:GetValue( 'TYZ_MAT' ) ) )

				While ( 'SR8' )->( !Eof() ) .And. SR8->R8_FILIAL == FWxFilial( 'SR8' ) .And. SR8->R8_MAT == oGrid:GetValue( 'TYZ_MAT' )

					For nAtestado := 1 To oGrid:Length()

						oGrid:GoLine( nAtestado )

						If SR8->R8_MAT == oGrid:GetValue( 'TYZ_MAT' ) .And. !Empty( SR8->R8_CONTAFA );
						.And. SR8->R8_CONTAFA == oGrid:GetValue( 'TYZ_SEQ' ) .And. lRet .And. ( lExclusao;
						.Or. ( oGrid:IsFieldUpdated( 'TYZ_DTSAID' ) .Or. oGrid:IsFieldUpdated( 'TYZ_DTALTA' ) ) )

							//--------------------------------------------------------------------------------------------------------------------------
							// "O afastamento vinculado a este atestado possui continuação. A exclusão ou alteração deste afastamento não é permitida."
							// "Exclua primeiro o atestado que contém o afastamento continuação deste, ou o próprio afastamento."
							//--------------------------------------------------------------------------------------------------------------------------
							Help( Nil, Nil, STR0111, Nil, STR0234, 1, 0, Nil, Nil, Nil, Nil, Nil, { STR0235 } ) 
							
							lRet := .F.
							Exit

						EndIf

					Next nAtestado

					( 'SR8' )->( DbSkip() )

				End

			EndIf

		EndIf

	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fNaoConti
Busca os afastamentos que já possuem continuação, para não continuar eles de novo.
@type function

@author	Gabriel Sokacheski
@since	16/12/2020

@param cMat, Caractere, Matrícula do funcionário
@param cSeqAtual, Caractere, Sequência atual do afastamento
@param dDtSaida, Data, Data de início do afastamento
@param dPeriodo, Data, Data de fim do afastamento

@return	aNaoConti, array, Contendo a sequência de afastamentos que não devem ser continuados.
/*/
//-------------------------------------------------------------------
Static Function fNaoConti( cMat, cSeqAtual, dDtSaida, dPeriodo )

	Local aArea := GetArea()
	Local aNaoConti := {}

	Local cAliasSR82 := GetNextAlias()

	BeginSQL Alias cAliasSR82
		SELECT SR8.R8_CONTAFA
		FROM %table:SR8% SR8
			LEFT JOIN %table:TYZ% TYZ ON
				TYZ.TYZ_FILIAL = %xFilial:TYZ% AND
				TYZ.TYZ_MAT = SR8.R8_MAT AND
				TYZ.TYZ_SEQ = SR8.R8_SEQ AND
				TYZ.%notDel%
			LEFT JOIN %table:TNY% TNY ON
				TNY.TNY_FILIAL = %xFilial:TNY% AND
				TNY.TNY_NATEST = TYZ.TYZ_NATEST AND
				TNY.%notDel%
		WHERE SR8.R8_FILIAL = %xFilial:SR8% AND
			SR8.R8_MAT = %exp:cMat% AND
			SR8.R8_SEQ != %exp:cSeqAtual% AND
			SR8.R8_DATAINI <= %exp:dDtSaida% AND
			SR8.R8_DATAFIM >= %exp:dPeriodo% AND
			SR8.R8_CONTAFA != '  ' AND
			SR8.%notDel%
		ORDER BY SR8.R8_DATAINI DESC
	EndSQL

	While ( cAliasSR82 )->( !EoF() )
		aAdd( aNaoConti, ( cAliasSR82 )->R8_CONTAFA )
		( cAliasSR82 )->( dbSkip() )
	EndDo

	RestArea( aArea )

Return aNaoConti

//-------------------------------------------------------------------
/*/{Protheus.doc} Mdt685Sx3
Função utilizada para conter o X3_VALID, X3_RELACAO e X3_INIBRW do
cadastro de atestado médico.

@author Gabriel Sokacheski
@since 01/09/2021
 
@param nRegra, Numérico, Opção do campo a ser validado/retornado (1- X3_VALID, 2- X3_RELACAO, 3- X3_INIBRW)
@param cCampo, Caracter, Campo a ser validado/retornado
 
@return xRet, Caracter/Boolean, Retorna caracter ou lógico de acordo com a regra
/*/
//-------------------------------------------------------------------
Function Mdt685Sx3( nRegra, cCampo )

    Local xRet // Variável de retorno

    If nRegra == 1 //Caso for X3_VALID



    ElseIf nRegra == 2 // Caso for X3_RELACAO



	ElseIf nRegra == 3

		Do Case

           Case cCampo == 'TNY_COMUNI'

                xRet := IIf( M->TNY_COMUOK == 'OK', STR0146, STR0147 )

        End Case

    EndIf

Return xRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Mdt685Sx6
Função utilizada para conter o X6_VALID do cadastro de atestado médico.

@author Gabriel Sokacheski
@since 10/09/2021
 
@param cParametro, Caractere, Nome do parâmetro.
 
@return lRet, Lógico, Retorna o valor lógico de acordo com a validação.
/*/
//-------------------------------------------------------------------
Function Mdt685Sx6( cParametro )

	Local cConteudo := M->X6_CONTEUDO

	Local lRet := .T.

	Do Case

		Case cParametro == 'MV_NG2COAF'

			If cConteudo != '1' .And. cConteudo != '2' .And. cConteudo != '3'

				MsgStop( STR0166, STR0153 )

				lRet := .F.

			EndIf

	End Case

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Mdt685Sx7
Dispara o gatilho do campo informado. Necessário caso desejado gatilhar
campos de Folders diferentes.

@author Gabriel Sokacheski
@since 17/09/2021

@param cCampo, Caractere, Nome do campo gatilhado.
@param xValor, Indefinido, Valor a ser recebido pelo campo gatilhado.

@return xRet, Indefinido, Retorna o valor para validar o gatilho.
/*/
//-------------------------------------------------------------------
Function Mdt685Sx7( cCampo, xValor )

	Local cTipoCampo := FWSX3Util():GetFieldType( cCampo )
	Local cTipoValor := ValType( xValor )

	Local xRet := ''

	oModel:= FWModelActive()
	oView := FWViewActive()

	If cTipoCampo != cTipoValor

		If cTipoCampo == 'C' .And. cTipoValor == 'N'

			oModel:LoadValue( 'TNYMASTER1', cCampo, Str( xValor ) )
			xRet := Str( xValor )

		ElseIf cTipoCampo == 'N' .And. cTipoValor == 'C'

			oModel:LoadValue( 'TNYMASTER1', cCampo, Val( xValor ) )
			xRet := Val( xValor )

		Else

			oModel:LoadValue( 'TNYMASTER1', cCampo, xValor )
			xRet := xValor

		EndIf

	Else

		oModel:LoadValue( 'TNYMASTER1', cCampo, xValor )
		xRet := xValor

	EndIf

	oView:Refresh()

Return xRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fAfastCont
Indica que o funcionario já esta com afastamento superior a 15 dias,
na somatória de vários atestados com o mesmo CID, caracterizando 
o encaminhamento ao INSS.

@author Eduardo Martinez
@since 26/08/2025

@param oModel, Objeto, Modelo utilizado
@param oGrid, Objeto, Grid TYZ.

@return lRet, Boolean, Indica se foi correta a informação.
/*/
//-------------------------------------------------------------------
Static Function fAfastCont( oModel, oGrid )

	Local aNaoConti := {} // Array de afastamentos que não devem ser continuados

	Local cAliasSR8 := GetNextAlias()
	Local cMat   	:= SRA->RA_MAT
	Local cCodAus   := oModel:GetValue( 'TNYMASTER1', 'TNY_CODAFA' )
	Local cCid   	:= oModel:GetValue( 'TNYMASTER1', 'TNY_CID' )
	Local cGrupo 	:= oModel:GetValue( 'TNYMASTER1', 'TNY_GRPCID' )
	Local cSeqAtual := oGrid:GetValue( 'TYZ_SEQ' )

	Local nI 		:= 0
	Local nDtAuxDur := 0
	Local nDias 	:= Val( SuperGetMv( 'MV_NG2QTVE', .F., '60' ) )
	Local nTotDias  := SuperGetMv( 'MV_NG2TOAF' , .F. , 15 )

	Local dDtSaida  := oGrid:GetValue( 'TYZ_DTSAID' )
	Local dPeriodo  := DaySub( dDtSaida , nDias ) // Afastamentos a serem contínuados devem ser maior que esta data
	Local dDtInicio := SToD( '' )
	Local dDtAlta   := SToD( '' )

	Local lContinua := .F.
	Local lFirst    := .T.
	Local lRet   	:= .F.

	If ( !Empty( cCid ) .Or. !Empty( cGrupo ) )

		BeginSQL Alias cAliasSR8
			SELECT SR8.R8_SEQ, SR8.R8_DATAINI, SR8.R8_DATAFIM, SR8.R8_MAT, SR8.R8_TIPOAFA, 
				SR8.R8_CID, TNY.TNY_GRPCID, TNY.TNY_CID, TNY.TNY_CODAFA
			FROM %table:SR8% SR8
				LEFT JOIN %table:TYZ% TYZ ON
					TYZ.TYZ_FILIAL = %xFilial:TYZ%
					AND TYZ.TYZ_MAT = SR8.R8_MAT
					AND TYZ.TYZ_SEQ = SR8.R8_SEQ
					AND TYZ.%notDel%
				LEFT JOIN %table:TNY% TNY ON
					TNY.TNY_FILIAL = %xFilial:TNY%
					AND TNY.TNY_NATEST = TYZ.TYZ_NATEST
					AND TNY.%notDel%
			WHERE 
				SR8.R8_FILIAL = %xFilial:SR8%
				AND SR8.R8_MAT = %exp:cMat%
				AND SR8.R8_SEQ != %exp:cSeqAtual%
				AND SR8.R8_DATAINI <= %exp:dDtSaida%
				AND SR8.R8_DATAFIM >= %exp:dPeriodo%
				AND SR8.%notDel%
			ORDER BY SR8.R8_DATAINI 
		EndSQL

		// Sequência de afastamentos que não devem ser continuados
		aNaoConti := fNaoConti( cMat, cSeqAtual, dDtSaida, dPeriodo )

		// Caso encontre afastamentos para continuar
		While ( cAliasSR8 )->( !EoF() )

			If lFirst

				// Inicio do afastamento
				dDtInicio := StoD( ( cAliasSR8 )->R8_DATAINI ) 
				lFirst := .F.

			EndIf

			// Continuação caso ausência seja a mesma ou para mesmo grupo de CID ( verificado "grupo" usando o CID )
			If ( ( ( ( cAliasSR8 )->R8_TIPOAFA == cCodAus ) .Or. ( ( cAliasSR8 )->TNY_CODAFA == cCodAus ) ) .Or. ( !Empty( cCid ) .And. Left( ( cAliasSR8 )->TNY_CID, 3 ) == Left( cCid, 3 ) ) )

				// Verifica se a sequência atual pode ser continuada
				If Len( aNaoConti ) == 0 .Or. Len( aNaoConti ) > 0 .And. aScan( aNaoConti, ( cAliasSR8 )->R8_SEQ ) == 0

					If !Empty( cCid )

						lContinua := .T.

					EndIf

				EndIf

			EndIf

			( cAliasSR8 )->( dbSkip() )

		End

		( cAliasSR8 )->( dbCloseArea() )

		If lContinua

			For nI := 1 To oGrid:Length()

				oGrid:GoLine( nI )

				If !Empty( oGrid:GetValue( 'TYZ_DTALTA' ) )
					dDtAlta := oGrid:GetValue( 'TYZ_DTALTA' )
				EndIf

			Next nI

		EndIf

	EndIf

	If !Empty( dDtAlta )

		nDtAuxDur += ( dDtAlta - dDtInicio ) + 1

		If nDtAuxDur > nTotDias 
			lRet := .T.
		EndIf

	EndIf

Return lRet	
