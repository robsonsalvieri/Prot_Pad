#INCLUDE "SGAA180.ch"
#include "Protheus.ch"
#include "DbTree.ch"

#DEFINE _nVERSAO 2 //Versao do fonte

//-------------------------------------------------------------------
/*/{Protheus.doc} SGAA180
Programa para cadastro do Plano Emergencial.
TAF - Nivel Organizacional
TBB - Plano Emergencial
TBC - Processos do Plano Emergencial

@author Rafael Diogo Richter
@since 21/02/2005

/*/
//-------------------------------------------------------------------
Function SGAA180()

	Local aNGBEGINPRM := NGBEGINPRM(_nVERSAO) // Armazena variaveis p/ devolucao (NGRIGHTCLICK)
	Local aCores		:= {}
	Local lIndAva		:= NGCADICBASE( "TBB_INDAVA" , "A" , "TBB" , .F. )

	If Amiin(56,35)  // Verifica se o usuário possui licença para acessar a rotina.

	Private aRotina := MenuDef()
	Private cCadastro := OemtoAnsi(STR0006) // "Plano Emergencial"
	Private aChkDel :=  {{"TBB->TBB_CODPLA" ,"TC2",1}}

	Private aTrocaF3 := {}
	If lIndAva
		aCores := { ;
						{ "TBB->TBB_INDAVA == '1'"    ,  'BR_VERDE'		}	,;
						{ "TBB->TBB_INDAVA == '2'"    ,  'BR_VERMELHO'	}	,;
						{ "TBB->TBB_INDAVA == '3'"    ,  "BR_AZUL"		}   ;
					}
	EndIf

	dbSelectArea("TBB")
	dbSetOrder(1)
	mBrowse( 6 , 1 , 22 , 75 , "TBB" , , , , , , If( lIndAva , aCores , Nil ) )

	EndIf

	NGRETURNPRM(aNGBEGINPRM) // Devolve variaveis armazenadas (NGRIGHTCLICK)

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} Sg180Pro
Programa para cadastro do Plano Emergencial.

@author Rafael Diogo Richter
@since 21/02/2005

/*/
//-------------------------------------------------------------------
Function Sg180Pro( cAlias, nRecno, nOpcx, xPar01, lLocTemp )

	// Variaveis de tela
	Local lOK := .f.
	Local cTitulo := cCadastro  // Titulo da janela
	Local aPages:= {}, aTitles:= {}
	Local oDlg180, oEnc180, oMenu
	Local oPnl180, oPanelBot, oFolder180, oPnlLgnd, oPnlBtn
	Local oBtnInc, oBtnPesq

	// Variaveis de tamanho de tela e objetos
	Local aSize := {}, aObjects := {}, aInfo := {}, aPosObj := {}

	// Variaveis de GetDados
	Local cGetTBO := "", aColsTBO := {}, aHeadTBO := {}
	Local cGetTBP := "", aColsTBP := {}, aHeadTBP := {}
	Local cGetTBU := "", aColsTBU := {}, aHeadTBU := {}
	Local cGetTDQ := "", aColsTDQ := {}, aHeadTDQ := {}

	Local aLocPla := {}, nNivel
	Local lFldEquip := nModulo <> 56 .And. NGCADICBASE('TDQ_CODPLA','A','TDQ',.F.)
	Local nIdx := 0

	Private oGetTBO, oGetTBP, oGetTBU, oGetTDQ

	// Variaveis de uso do MarkBrowse
	Private lInverte := .F.
	Private cMarca := GetMark()

	// Variaveis de tela
	Private aTela := {}, aGets := {}

	Default lLocTemp	:= .F.

	// Variaveis para Estrutura Organizacional e TRB
	Private aLocal := {}, aMarcado := {}
	Private aTRB := SGATRBEST(.T.)

	cTRBSGA := aTRB[3]
	oTempTRB := FWTemporaryTable():New( cTRBSGA, aTRB[1] )
	For nIdx := 1 To Len( aTRB[2] )
		oTempTRB:AddIndex( RETASC( cValToChar( nIdx ) , 1 , .T. ), aTRB[2,nIdx] )
	Next nIdx
	oTempTRB:Create()

	// Definicao de tamanho de tela e objetos
	aSize := MsAdvSize(,.f.,430)
	Aadd(aObjects,{035,035,.t.,.t.})
	Aadd(aObjects,{065,065,.t.,.t.})
	aInfo := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
	aPosObj := MsObjSize(aInfo, aObjects,.t.)

	// Define nome dos folders
	Aadd(aTitles,OemToAnsi(STR0007)) // "Processos"
	Aadd(aPages,"Header 1")
	Aadd(aTitles,OemToAnsi(STR0008)) // "Ações"
	Aadd(aPages,"Header 2")
	Aadd(aTitles,OemToAnsi(STR0009)) // "Participantes"
	Aadd(aPages,"Header 3")
	Aadd(aTitles,OemToAnsi(STR0047)) // "Contatos Externos"
	Aadd(aPages,"Header 4")

	If lFldEquip
		Aadd(aTitles,OemToAnsi(STR0061)) // "Equipamentos e Materiais"
		Aadd(aPages,"Header 5")
	Endif

	Define MsDialog oDlg180 Title OemToAnsi(cTitulo) From aSize[7],0 To aSize[6],aSize[5] Of oMainWnd Pixel

	// Define painel principal
	oPnl180 := TPanel():New(0,0,,oDlg180,,,,,,aSize[5],aSize[6],.F.,.F.)
	oPnl180:Align := CONTROL_ALIGN_ALLCLIENT

	// Parte Superior da tela
	dbSelectArea("TBB")
	RegToMemory("TBB",(nOpcx == 3))
	oEnc180:= MsMGet():New("TBB",nRecno,nOpcx,,,,,aPosObj[1],,,,,,oPnl180,,,.F.)
	oEnc180:oBox:Align := CONTROL_ALIGN_TOP

	// Parte de baixo da tela
	oPanelBot := TPanel():New(0,0,,oPnl180,,,,,,0,aPosObj[2,4],.F.,.F.)
	oPanelBot:Align := CONTROL_ALIGN_ALLCLIENT

	oFolder180 := TFolder():New(aSize[6]/5,0,aTitles,aPages,oPanelBot,,,,.f.,.F.)
	oFolder180:Align := CONTROL_ALIGN_ALLCLIENT

	// Folder 01

	//Carrega todos niveis selecionados

	If ValType(xPar01) == "A"
		For nNivel := 1 To Len(xPar01)
			If aScan( aLocal, { |x| Trim( Upper( x[1] ) ) == xPar01[nNivel] } ) == 0
				aAdd( aLocal, { xPar01[nNivel], .T. } )
			Endif
		Next nNivel
	ElseIf !Inclui
		dbSelectArea("TBC")
		dbSetOrder(1)
		dbSeek(xFilial("TBC")+TBB->TBB_CODPLA)
		While !eof() .and. xFilial("TBC")+TBB->TBB_CODPLA == TBC->TBC_FILIAL+TBC->TBC_CODPLA
			If aScan(aLocal,{|x| Trim(Upper(x[1])) == TBC->TBC_CODNIV}) == 0
				aAdd(aLocal, {TBC->TBC_CODNIV, .T.} )
			Endif
			dbSelectArea("TBC")
			dbSkip()
		End
	Endif
	aMarcado := aClone(aLocal)

	oTree := DbTree():New(005, 022, 170, 302, oFolder180:aDialogs[1],,, .t.)

	oTree:Align := CONTROL_ALIGN_ALLCLIENT

	// Padronizacao de carregamento de estrutura
	SGA140TREE( 1, aMarcado )

	If Str(nOpcx,1) $ "2/5" .Or. !Empty( aMarcado )
		oTree:bChange	:= {|| SGA140TREE(2)}
		oTree:BlDblClick:= {||}
	Else
		oTree:bChange	 := {|| SGA140TREE(2)}
		oTree:blDblClick := {|| Sg180ChangeBmp()}
	EndIf

	// Painel de Legenda
	oPnlLgnd := TPanel():New(00,00,,oFolder180:aDialogs[1],,,,,RGB(67,70,87),200,200,.F.,.F.)
	oPnlLgnd:Align := CONTROL_ALIGN_BOTTOM
	oPnlLgnd:nHeight := 40

	@ 002,004 Say OemToAnsi(STR0010) Size 207,27 Of oPnlLgnd Pixel Color RGB(255,255,255) // "Escolha a área clicando duas vezes sobre a pasta"

	// Folder 02
	cGetTBO := "TBO->TBO_FILIAL == '"+xFilial("TBO")+"' .AND. TBO->TBO_CODPLA = '"+TBB->TBB_CODPLA+"'"
	FillGetDados( nOpcx, "TBO", 1, "TBB->TBB_CODPLA", {|| }, {|| .T.},{"TBO_CODPLA"},,,,{|| NGMontaAcols("TBO", TBB->TBB_CODPLA,cGetTBO)},,aHeadTBO,aColsTBO)

	If Empty(aColsTBO) .Or. nOpcx == 3
	aColsTBO := BlankGetd(aHeadTBO)
	Endif

	n       := Len(aColsTBO)
	oGetTBO := MsNewGetDados():New(005, 005, 500, 500,IIF(!Inclui.And.!Altera,0,GD_INSERT+GD_UPDATE+GD_DELETE),{|| SG180LIN("TBO")},"AllwaysTrue()",,,,9999,,,{|| SG180DELOK("TBO")},oFolder180:aDialogs[2],aHeadTBO, aColsTBO)
	oGetTBO:oBrowse:Default()
	oGetTBO:oBrowse:Refresh()
	oGetTBO:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	PutFileInEof("TBO")

	// Folder 03

	oPnlBtn := TPanel():New(00,00,,oFolder180:aDialogs[3],,,,,RGB(67,70,87),12,12,.F.,.F.)
		oPnlBtn:Align := CONTROL_ALIGN_LEFT

		If nOpcx == 3 .or. nOpcx == 4
			oBtnInc  := TBtnBmp():NewBar("ng_ico_entrada","ng_ico_entrada",,,,{||SG180IMPF() },,oPnlBtn,,,STR0048,,,,,"") //"Incluir Participantes por Função"
				oBtnInc:Align  := CONTROL_ALIGN_TOP
		Endif
		oBtnPesq := TBtnBmp():NewBar("ng_ico_localizar","ng_ico_localizar",,,,{||SG180PESQ() },,oPnlBtn,,,STR0049,,,,,"") //"Pesquisar Participante"
			oBtnPesq:Align := CONTROL_ALIGN_TOP

	cGetTBP := "TBP->TBP_FILIAL == '"+xFilial("TBP")+"' .AND. TBP->TBP_CODPLA = '"+TBB->TBB_CODPLA+"'"
	DbSelectArea( "TBP" )
	DbSetOrder( 01 )
	FillGetDados( nOpcx, "TBP", 1, "TBB->TBB_CODPLA", {|| }, {|| .T.},{"TBP_CODPLA","TBP_DESPLA"},,,,{|| NGMontaAcols("TBP", TBB->TBB_CODPLA,cGetTBP)},,aHeadTBP,aColsTBP)

	If Empty(aColsTBP) .Or. nOpcx == 3
	aColsTBP := BlankGetd(aHeadTBP)
	Endif

	n       := Len(aColsTBP)
	oGetTBP := MsNewGetDados():New(005, 005, 500, 500,IIF(!Inclui.And.!Altera,0,GD_INSERT+GD_UPDATE+GD_DELETE),{|| SG180LIN("TBP")},"AllwaysTrue()",,,,9999,,,,oFolder180:aDialogs[3],aHeadTBP, aColsTBP)
	oGetTBP:oBrowse:Default()
	oGetTBP:oBrowse:Refresh()
	oGetTBP:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	PutFileInEof("TBP")

	// Folder 04
	cGetTBU := "TBU->TBU_FILIAL == '"+xFilial("TBU")+"' .AND. TBU->TBU_CODPLA = '"+TBB->TBB_CODPLA+"'"
	FillGetDados( nOpcx, "TBU", 1, "TBB->TBB_CODPLA", {|| }, {|| .T.},{"TBU_CODPLA"},,,,{|| NGMontaAcols("TBU", TBB->TBB_CODPLA,cGetTBU)},,aHeadTBU,aColsTBU)

	If Empty(aColsTBU) .Or. nOpcx == 3
	aColsTBU := BlankGetd(aHeadTBU)
	Endif

	n       := Len(aColsTBU)
	oGetTBU := MsNewGetDados():New(005, 005, 500, 500,IIF(!Inclui.And.!Altera,0,GD_INSERT+GD_UPDATE+GD_DELETE),{|| SG180LIN("TBU")},"AllwaysTrue()",,,,9999,,,,oFolder180:aDialogs[4],aHeadTBU, aColsTBU)
	oGetTBU:oBrowse:Default()
	oGetTBU:oBrowse:Refresh()
	oGetTBU:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	PutFileInEof("TBU")

	If Len(asMenu) > 0
		NGPOPUP(asMenu,@oMenu)
		oDlg180:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg180)}
		oEnc180:oBox:bRClicked := { |o,x,y| oMenu:Activate(x,y,oDlg180)}
	Endif

	// Folder 05

	If lFldEquip

		cGetTDQ := "TDQ->TDQ_FILIAL == '"+xFilial("TDQ")+"' .AND. TDQ->TDQ_CODPLA = '"+TBB->TBB_CODPLA+"'"
		FillGetDados( nOpcx, "TDQ", 1, "TBB->TBB_CODPLA", {|| }, {|| .T.},{"TDQ_CODPLA"},,,,{|| NGMontaAcols("TDQ", TBB->TBB_CODPLA,cGetTDQ)},,aHeadTDQ,aColsTDQ)

		If Empty(aColsTDQ) .Or. nOpcx == 3
		aColsTDQ := BlankGetd(aHeadTDQ)
		Endif

		n       := Len(aColsTDQ)
		oGetTDQ := MsNewGetDados():New(005, 005, 500, 500,IIF(!Inclui.And.!Altera,0,GD_INSERT+GD_UPDATE+GD_DELETE),{|| SG180LIN("TDQ")},"AllwaysTrue()",,,,9999,,,,oFolder180:aDialogs[5],aHeadTDQ, aColsTDQ)
		oGetTDQ:oBrowse:Default()
		oGetTDQ:oBrowse:Refresh()
		oGetTDQ:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

		PutFileInEof("TDQ")

	Endif

	If Len(asMenu) > 0
		NGPOPUP(asMenu,@oMenu)
		oDlg180:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg180)}
		oEnc180:oBox:bRClicked := { |o,x,y| oMenu:Activate(x,y,oDlg180)}
	Endif

	Activate Dialog oDlg180 On Init (EnchoiceBar(oDlg180,	{|| lOk := .T., If( Sg180Obrig(nOpcx, lLocTemp), oDlg180:End(), lOk := .F.) },;
																					{|| lOk := .F., oDlg180:End() } ) ) Centered
	oTempTRB:Delete()

Return lOk

//-------------------------------------------------------------------
/*/{Protheus.doc} Sg180Obrig
Verifica se as informacoes obrigatorias estao preenchidas.

@author Roger Rodrigues
@since 05/12/2011

/*/
//-------------------------------------------------------------------
Static Function Sg180Obrig( nOpcx, lLocTemp )

	Local aArea			:= GetArea() // Guarda variaveis de alias e indice
	Local aRetGrava	:= {}
	Local lRetOk		:= .T.
	Local i

	If nOpcx == 2
		Return .T.
	Endif

	If nOpcx != 5

		If !Obrigatorio(aGets,aTela)
			lRetOk := .F.
		Endif

		If lRetOk .And. (nOpcx == 3 .or. nOpcx == 4) .and. ( aScan(aLocal,{|x| x[2] }) == 0 )
			ShowHelpDlg(STR0041,{STR0050},1,{STR0051}) // "Atenção"###"Por favor, selecione uma localização da Estrutura."###"Escolha a localização clicando duas vezes sobre a pasta."
			lRetOk := .F.
		EndIf

		If lRetOk .And. !SG180LIN("TBO",.T.)
			lRetOk := .F.
		Endif

		If lRetOk .And. !SG180LIN("TBP",.T.)
			lRetOk := .F.
		Endif

		If lRetOk .And. !SG180LIN("TBU",.T.)
			lRetOk := .F.
		Endif

	Else

		For i := 1 to Len(aChkDel)

			dbSelectArea(aChkDel[i][2])
			dbSetOrder(aCHKDEL[i][3])
			cKEY := aCHKDEL[i][1]
			If (dbSeek(xFilial() + &cKEY.))
				Help(" ",1,"MA10SC",,AllTrim(FwX2Nome(aCHKDEL[i][2])) + " (" + aChkDel[i][2] + ")",5,1)
				RestArea(aArea)
				lRetOk := .F.
				Exit
			Endif

		Next

		If lRetOk .And. !NGVALSX9("TBB",{"TBC","TBO","TBP","TBU"},.T.)
			lRetOk := .F.
		EndIf

	EndIf

	If lRetOk
		Sg180Grava( nOpcx, lLocTemp )
	Endif

	RestArea(aArea)

Return lRetOk

//-------------------------------------------------------------------
/*/{Protheus.doc} Sg180Grava
Verifica se as informacoes obrigatorias estao preenchidas.
TBB - Plano Emergencial
TAZ - Criterios de Controle
TAV - Residuos do Processo

@author Rafael Diogo Richter
@since 24/02/2005

/*/
//-------------------------------------------------------------------
Function Sg180Grava( nOpcx, lLocTemp )

	Local i, j, nPosCod := 0, nPos := 0
	Local lAcao:= .F.
	Local aHeadGrv := aColsGrv := {}
	Local lFldEquip := nModulo <> 56 .And. NGCADICBASE('TDQ_CODPLA','A','TDQ',.F.)

	// Manipula a tabela TBB
	ConfirmSX8()
	dbSelectArea("TBB")
	dbSetOrder(1)
	If dbSeek(xFilial("TBB")+M->TBB_CODPLA)
		RecLock("TBB",.F.)
	Else
		RecLock("TBB",.T.)
	EndIf

	If nOpcx <> 5
		For i:=1 to FCount()
			If "_FILIAL" $ Upper(FieldName(i))
				FieldPut(i, xFilial("TBB"))
			Else
				FieldPut(i, &("M->"+FieldName(i)))
			Endif
		Next i
	Else
		dbDelete()
	EndIf
	MsUnLock("TBB")

	// Manipula a tabela TBC
	dbSelectArea("TBC")
	dbSetOrder(1)
	dbSeek(xFilial("TBC")+M->TBB_CODPLA+cCodEst)
	While !Eof() .and. xFilial("TBC")+M->TBB_CODPLA+cCodEst == TBC->TBC_FILIAL+TBC->TBC_CODPLA+TBC->TBC_CODEST
		RecLock("TBC",.f.)
		dbDelete()
		MsUnLock("TBC")
		dbSelectArea("TBC")
		dbSkip()
	End

	If !lLocTemp
		If nOpcx != 5 .or. nOpcx != 2
			For i:= 1 To Len(aLocal)
				dbSelectArea("TBC")
				dbSetOrder(1)
				If !dbSeek(xFilial("TBC")+M->TBB_CODPLA+cCodEst+aLocal[i][1])
					If aLocal[i][2]
						RecLock("TBC",.t.)
						TBC->TBC_FILIAL := xFilial("TBC")
						TBC->TBC_CODPLA := M->TBB_CODPLA
						TBC->TBC_CODEST := cCodEst
						TBC->TBC_CODNIV := aLocal[i][1]
						MsUnLock("TBC")
					EndIf
				Else
					RecLock("TBC",.f.)
					If !aLocal[i][2]
						dbDelete()
					Else
						TBC->TBC_FILIAL := xFilial("TBC")
						TBC->TBC_CODPLA := M->TBB_CODPLA
						TBC->TBC_CODEST := cCodEst
						TBC->TBC_CODNIV := aLocal[i][1]
					EndIf
					MsUnLock("TBC")
				EndIf
			Next
		Endif
	EndIf

	// Manipula a tabela TBO
	aHeadGrv := oGetTBO:aHeader
	aColsGrv := oGetTBO:aCols
	nPosCod  := GDFIELDPOS("TBO_CODACA",aHeadGrv)

	dbSelectArea("TBO")
	dbSetOrder(1)
	dbSeek(xFilial("TBO")+M->TBB_CODPLA)
	While !Eof() .and. xFilial("TBO")+M->TBB_CODPLA == TBO->TBO_FILIAL+TBO->TBO_CODPLA
		RecLock("TBO",.F.)
		dbDelete()
		MsUnLock("TBO")
		dbSelectArea("TBO")
		dbSkip()
	End
	If nOpcx != 5 .or. nOpcx != 2
		If Len(aColsGrv) > 0
			aSORT(aColsGrv,,, { |x, y| x[Len(aColsGrv[1])] .and. !y[Len(aColsGrv[1])] } )
		Endif
		For i:=1 to Len(aColsGrv)
			If !aColsGrv[i][Len(aColsGrv[i])] .and. !Empty(aColsGrv[i][nPosCod])
				dbSelectArea("TBO")
				dbSetOrder(1)
				If dbSeek(xFilial("TBO")+M->TBB_CODPLA+aColsGrv[i][nPosCod])
					RecLock("TBO",.F.)
				Else
					RecLock("TBO",.T.)
				Endif
				For j:=1 to FCount()
					If "_FILIAL"$Upper(FieldName(j))
						FieldPut(j, xFilial("TBO"))
					ElseIf "_CODPLA"$Upper(FieldName(j))
						FieldPut(j, M->TBB_CODPLA)
					ElseIf (nPos := GDFIELDPOS(FieldName(j), aHeadGrv) ) > 0
						FieldPut(j, aColsGrv[i][nPos])
					Endif
				Next j
				MsUnlock("TBO")
			Elseif !Empty(aColsGrv[i][nPosCod])
				dbSelectArea("TBO")
				dbSetOrder(1)
				If dbSeek(xFilial("TBO")+M->TBB_CODPLA+aColsGrv[i][nPosCod])
					RecLock("TBO",.F.)
					dbDelete()
					MsUnlock("TBO")
				Endif
			Endif
		Next i
	Endif

	// Manipula a tabela TC3
	dbSelectArea("TC3")
	dbSetOrder(1)
	dbSeek(xFilial("TC3")+M->TBB_CODPLA)
	While !Eof() .and. xFilial("TC3")+M->TBB_CODPLA == TC3->TC3_FILIAL+TC3->TC3_CODPLA
		If Empty(TC3->TC3_OK) .and. (aScan( aColsGrv, { |x| x[nPosCod] == TC3->TC3_CODACA .and. x[Len(aHeadGrv)+1] } ) > 0 .or.;
			aScan( aColsGrv, { |x| x[nPosCod] == TC3->TC3_CODACA} ) == 0)
			lAcao := .T.
			Exit
		EndIf

		dbSelectArea("TC3")
		dbSkip()
	End
	dbSelectArea("TC2")
	dbSetOrder(1)
	dbSeek(xFilial("TC2")+M->TBB_CODPLA)
	While !Eof() .and. xFilial("TC2")+M->TBB_CODPLA == TC2->TC2_FILIAL+TC2->TC2_CODPLA

		For i:= 1 To Len(aColsGrv)
			If !aColsGrv[i][Len(aColsGrv[i])] .and. !Empty(aColsGrv[i][nPosCod])
				dbSelectArea("TC3")
				dbSetOrder(2)
				If !dbSeek(xFilial("TC3")+M->TBB_CODPLA+aColsGrv[i][nPosCod]+TC2->TC2_CODOCO)
					lAcao := .T.
					Exit
				EndIf
			Endif
		Next
		dbSelectArea("TC2")
		dbSkip()
	End

	If lAcao
		If MsgYesNo(STR0052,STR0041) // "Deseja repassar as alterações feitas nas Ações do Plano Emergencial para as Ocorrências já cadastradas?"###"Atenção"
			dbSelectArea("TC2")
			dbSetOrder(1)
			dbSeek(xFilial("TC2")+M->TBB_CODPLA)
			ProcRegua(RecCount())
			While !Eof() .and. xFilial("TC2")+M->TBB_CODPLA == TC2->TC2_FILIAL+TC2->TC2_CODPLA

				IncProc()
				For i:= 1 To Len(aColsGrv)
					If !aColsGrv[i][Len(aColsGrv[i])] .and. !Empty(aColsGrv[i][nPosCod])
						dbSelectArea("TC3")
						dbSetOrder(2)
						If !dbSeek(xFilial("TC3")+M->TBB_CODPLA+aColsGrv[i][nPosCod]+TC2->TC2_CODOCO)
							RecLock("TC3",.t.)
							TC3->TC3_FILIAL := xFilial("TC3")
							TC3->TC3_CODPLA := M->TBB_CODPLA
							TC3->TC3_CODOCO := TC2->TC2_CODOCO
							TC3->TC3_DTOCO  := TC2->TC2_DATA
							TC3->TC3_HROCO  := TC2->TC2_HORA
							TC3->TC3_CODACA := aColsGrv[i][nPosCod]
							MsUnLock('TC3')
						EndIf
					Endif
				Next
				dbSelectArea("TC2")
				dbSkip()
			End

			dbSelectArea("TC3")
			dbSetOrder(1)
			dbSeek(xFilial("TC3")+M->TBB_CODPLA)
			While !Eof() .and. xFilial("TC3")+M->TBB_CODPLA == TC3->TC3_FILIAL+TC3->TC3_CODPLA

				If Empty(TC3->TC3_OK) .and. (aScan( aColsGrv, { |x| x[nPosCod] == TC3->TC3_CODACA .and. x[Len(aHeadGrv)+1] } ) > 0 .or.;
					aScan( aColsGrv, { |x| x[nPosCod] == TC3->TC3_CODACA} ) == 0)
					RecLock("TC3",.f.)
					dbDelete()
					MsUnLock("TC3")
				EndIf

				dbSelectArea("TC3")
				dbSkip()
			End
		EndIf
	EndIf


	// Manipula a tabela TBP
	aHeadGrv := oGetTBP:aHeader
	aColsGrv := oGetTBP:aCols
	nPosCod  := GDFIELDPOS("TBP_CODPAR",aHeadGrv)
	dbSelectArea("TBP")
	dbSetOrder(1)
	dbSeek(xFilial("TBP")+M->TBB_CODPLA)
	While !Eof() .and. xFilial("TBP")+M->TBB_CODPLA == TBP->TBP_FILIAL+TBP->TBP_CODPLA
		RecLock("TBP",.F.)
		dbDelete()
		MsUnLock("TBP")
		dbSelectArea("TBP")
		dbSkip()
	End
	If nOpcx != 5 .or. nOpcx != 2
		If Len(aColsGrv) > 0
			aSORT(aColsGrv,,, { |x, y| x[Len(aColsGrv[1])] .and. !y[Len(aColsGrv[1])] } )
		Endif
		For i:=1 to Len(aColsGrv)
			If !aColsGrv[i][Len(aColsGrv[i])] .and. !Empty(aColsGrv[i][nPosCod])
				dbSelectArea("TBP")
				dbSetOrder(1)
				If dbSeek(xFilial("TBP")+M->TBB_CODPLA+aColsGrv[i][nPosCod])
					RecLock("TBP",.F.)
				Else
					RecLock("TBP",.T.)
				Endif
				For j:=1 to FCount()
					If "_FILIAL"$Upper(FieldName(j))
						FieldPut(j, xFilial("TBP"))
					ElseIf "_CODPLA"$Upper(FieldName(j))
						FieldPut(j, M->TBB_CODPLA)
					ElseIf (nPos := GDFIELDPOS(FieldName(j), aHeadGrv) ) > 0
						FieldPut(j, aColsGrv[i][nPos])
					Endif
				Next j
				MsUnlock("TBP")
			Elseif !Empty(aColsGrv[i][nPosCod])
				dbSelectArea("TBP")
				dbSetOrder(1)
				If dbSeek(xFilial("TBP")+M->TBB_CODPLA+aColsGrv[i][nPosCod])
					RecLock("TBP",.F.)
					dbDelete()
					MsUnlock("TBP")
				Endif
			Endif
		Next i
	Endif

	// Manipula a tabela TBU
	aHeadGrv := oGetTBU:aHeader
	aColsGrv := oGetTBU:aCols
	nPosCod  := GDFIELDPOS("TBU_CODCON",aHeadGrv)
	dbSelectArea("TBU")
	dbSetOrder(1)
	dbSeek(xFilial("TBU")+M->TBB_CODPLA)
	While !Eof() .and. xFilial("TBU")+M->TBB_CODPLA == TBU->TBU_FILIAL+TBU->TBU_CODPLA
		RecLock("TBU",.F.)
		dbDelete()
		MsUnLock("TBU")
		dbSelectArea("TBU")
		dbSkip()
	End
	If nOpcx != 5 .and. nOpcx != 2
		If Len(aColsGrv) > 0
			aSORT(aColsGrv,,, { |x, y| x[Len(aColsGrv[1])] .and. !y[Len(aColsGrv[1])] } )
		Endif
		For i:=1 to Len(aColsGrv)
			If !aColsGrv[i][Len(aColsGrv[i])] .and. !Empty(aColsGrv[i][nPosCod])
				dbSelectArea("TBU")
				dbSetOrder(1)
				If dbSeek(xFilial("TBU")+M->TBB_CODPLA+aColsGrv[i][nPosCod])
					RecLock("TBU",.F.)
				Else
					RecLock("TBU",.T.)
				Endif
				For j:=1 to FCount()
					If "_FILIAL"$Upper(FieldName(j))
						FieldPut(j, xFilial("TBU"))
					ElseIf "_CODPLA"$Upper(FieldName(j))
						FieldPut(j, M->TBB_CODPLA)
					ElseIf (nPos := GDFIELDPOS(FieldName(j), aHeadGrv) ) > 0
						FieldPut(j, aColsGrv[i][nPos])
					Endif
				Next j
				MsUnlock("TBU")
			Elseif !Empty(aColsGrv[i][nPosCod])
				dbSelectArea("TBU")
				dbSetOrder(1)
				If dbSeek(xFilial("TBU")+M->TBB_CODPLA+aColsGrv[i][nPosCod])
					RecLock("TBU",.F.)
					dbDelete()
					MsUnlock("TBU")
				Endif
			Endif
		Next i
	Endif

	// Manipula a tabela TDQ
	If lFldEquip
		aHeadGrv := oGetTDQ:aHeader
		aColsGrv := oGetTDQ:aCols
		nPosCod  := GDFIELDPOS("TDQ_CODEQP",aHeadGrv)
		dbSelectArea("TDQ")
		dbSetOrder(1)
		dbSeek(xFilial("TDQ")+M->TBB_CODPLA)
		While !Eof() .and. xFilial("TDQ")+M->TBB_CODPLA == TDQ->TDQ_FILIAL+TDQ->TDQ_CODPLA
			RecLock("TDQ",.F.)
			dbDelete()
			MsUnLock("TDQ")
			dbSelectArea("TDQ")
			dbSkip()
		End
		If nOpcx != 5 .and. nOpcx != 2
			If Len(aColsGrv) > 0
				aSORT(aColsGrv,,, { |x, y| x[Len(aColsGrv[1])] .and. !y[Len(aColsGrv[1])] } )
			Endif
			For i:=1 to Len(aColsGrv)
				If !aColsGrv[i][Len(aColsGrv[i])] .and. !Empty(aColsGrv[i][nPosCod])
					dbSelectArea("TDQ")
					dbSetOrder(1)
					If dbSeek(xFilial("TDQ")+M->TBB_CODPLA+aColsGrv[i][nPosCod])
						RecLock("TDQ",.F.)
					Else
						RecLock("TDQ",.T.)
					Endif
					For j:=1 to FCount()
						If "_FILIAL"$Upper(FieldName(j))
							FieldPut(j, xFilial("TDQ"))
						ElseIf "_CODPLA"$Upper(FieldName(j))
							FieldPut(j, M->TBB_CODPLA)
						ElseIf (nPos := GDFIELDPOS(FieldName(j), aHeadGrv) ) > 0
							FieldPut(j, aColsGrv[i][nPos])
						Endif
					Next j
					MsUnlock("TDQ")
				Elseif !Empty(aColsGrv[i][nPosCod])
					dbSelectArea("TDQ")
					dbSetOrder(1)
					If dbSeek(xFilial("TDQ")+M->TBB_CODPLA+aColsGrv[i][nPosCod])
						RecLock("TDQ",.F.)
						dbDelete()
						MsUnlock("TDQ")
					Endif
				Endif
			Next i
		Endif
	Endif

Return { aLocal }

//-------------------------------------------------------------------
/*/{Protheus.doc} SG180PESQ
Pesquisa Participantes.

@author Roger Rodrigues
@since 06/12/2011

/*/
//-------------------------------------------------------------------
Static Function SG180PESQ()

	Local nOk  := 0, nPos := 0, nPosCod := 0
	Local oDlgPesq
	Local cTabela, cCpoMat
	Local cCodPar, cNomePar
	Local lAccsCod

	Local oCbxPart
	Local oGetCodPar

	// Variaveis CBox participante
	Local aCbxPart := { "1=Usuário", "2=Funcionário" }
	Local cCbxPart := M->TBB_MODULO

	If M->TBB_MODULO == "1"
		cTabela 	:= "QAA"
		cCpoMat  	:= "QAA_MAT"
		cCodPar 	:= IIf( FindFunction( "MDTHideCpo" ), MDTHideCpo( cCodPar, "QAA_MAT" ), Space(TAMSX3("QAA_MAT")[1]) )
		cNomePar	:= IIf( FindFunction( "MDTHideCpo" ), MDTHideCpo( cNomePar, "QAA_NOME" ), Space(TAMSX3("QAA_NOME")[1]) )
		lAccsCod	:= IIf( FindFunction( "MDTVldFldAcc" ), MDTVldFldAcc( "QAA_MAT" ), .T. )
	ElseIf M->TBB_MODULO == "2"
		cTabela		:= "SRA"
		cCpoMat		:= "RA_MAT"
		cCodPar		:= IIf( FindFunction( "MDTHideCpo" ), MDTHideCpo( cCodPar, "RA_MAT" ), Space(TAMSX3("RA_MAT")[1]) )
		cNomePar	:= IIf( FindFunction( "MDTHideCpo" ), MDTHideCpo( cNomePar, "RA_NOME" ), Space(TAMSX3("RA_NOME")[1]) )
		lAccsCod	:= IIf( FindFunction( "MDTVldFldAcc" ), MDTVldFldAcc( "RA_MAT" ), .T. )
	EndIf

	Define MsDialog oDlgPesq Title OemToAnsi(STR0043) From 000,000 To 115,315 OF oMainWnd Pixel//"Pesquisa Participante"

		@ 003,003 TO 040,153 LABEL OemToAnsi(STR0040) Of oDlgPesq Pixel //"Participante"

		oCbxPart := TComboBox():New( 010, 006, { | u | If( PCount() > 0, cCbxPart := u, cCbxPart ) }, aCbxPart, 55, 10, oDlgPesq,,;
			{ || oGetCodPar:cF3 := SG180F3PAR( cCbxPart, @cTabela, , @cCpoMat, , , @cCodPar, @cNomePar, 1 )  },;
			,,, .T.,,,,,,,,, "cCbxPart" )

		@ 010,065 MsGet oGetCodPar Var cCodPar Picture PesqPict( cTabela, cCpoMat ) F3 cTabela Size 065,008 Of oDlgPesq Pixel Valid ( fValField( cCodPar, @cNomePar, cTabela ) ) HasButton When lAccsCod
		@ 025,006 MsGet cNomePar Size 114,008 Of oDlgPesq Pixel ReadOnly

		Define sButton From 043,095 Type 1 Enable Of oDlgPesq Action (nOk := 1, oDlgPesq:End())
		Define sButton From 043,125 Type 2 Enable Of oDlgPesq Action oDlgPesq:End()

	Activate MsDialog oDlgPesq Centered

	If nOk == 1
		nPosCod := GDFIELDPOS("TBP_CODPAR", oGetTBP:aHeader)
		If (nPos:= aScan(oGetTBP:aCols, {|x| x[nPosCod] == cCodPar} )) > 0
			oGetTBP:oBrowse:nAt:= nPos
			oGetTBP:oBrowse:Refresh()
			oGetTBP:oBrowse:SetFocus()
		Else
			Help(" ",1,STR0041,,STR0044,3,1) // "ATENÇÃO"###"Esse Responsável não está listado como participante"
		EndIf
	EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} fValField
Valida codigo do usuario pesquisado.

@author Roger Rodrigues
@since 06/12/2011

/*/
//-------------------------------------------------------------------
Static Function fValField(cCodigo,cNome,cTabela)

	Local lRet := .T.

	Default cTabela := "QAA"

	If !Empty(cCodigo)
		If cTabela == "QAA"
			If !ExistCpo("QAA",cCodigo)
				lRet := .F.
			Else
				cNome := NGSEEK("QAA",cCodigo,1,"QAA->QAA_NOME")
			EndIf
		ElseIf cTabela == "QAC"
			If !ExistCpo("QAC",cCodigo)
				lRet := .F.
			Else
				cNome := NGSEEK("QAC",cCodigo,1,"QAC->QAC_DESC")
			EndIf
		ElseIf cTabela == "SRA"
			If !ExistCpo("SRA",cCodigo)
				lRet := .F.
			Else
				cNome := NGSEEK("SRA",cCodigo,1,"SRA->RA_NOME")
			EndIf
		ElseIf cTabela == "SRJ"
			If !ExistCpo("SRJ",cCodigo)
				lRet := .F.
			Else
				cNome := NGSEEK("SRJ",cCodigo,1,"SRJ->RJ_DESC")
			EndIf
		EndIf
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Sg180ChangeBmp
Programa para trocar cor da pasta clicada na estrutura.

@author Rafael Diogo Richter
@since 22/03/2006

/*/
//-------------------------------------------------------------------
Static Function Sg180ChangeBmp()

	Local nPos
	Local aClrNiv := { "Folder10", "Folder11" }

	If !Empty(oTree:cArqTree)
		dbSelectArea(oTree:cArqTree)

		If Substr( oTree:GetCargo(), 7, 1 ) = "2"
			dbSelectArea("TC1")
			dbSetOrder(2)
			If dbSeek(xFilial("TC1")+M->TBB_CODPLA+cCodEst+SubStr( oTree:GetCargo(), 1, 3 ))
				MsgStop(STR0053,STR0041) // "Não é possível desmarcar essa localização, pois existem Ocorrências relacionadas a ela."###"Atenção"
				Return .F.
			EndIf

			If !Sg100NvAtv( Substr( oTree:GetCargo(), 1, 3 ), cCodest )
				aClrNiv := {"cadeado","cadeado"}
			Endif

			oTree:ChangeBmp(aClrNiv[1],aClrNiv[2])

			(oTree:cArqTree)->T_CARGO := SubStr(oTree:getCargo(),1,6)+"1"
			If (nPos := aScan(aLocal, {|x| x[1] == SubStr( oTree:GetCargo(), 1, 3 )})) > 0
				aLocal[nPos][2] := .F.
			EndIf
		Else
			oTree:ChangeBmp('Folder7','Folder8')
			(oTree:cArqTree)->T_CARGO := SubStr(oTree:getCargo(),1,6)+"2"
			If (nPos := aScan(aLocal, {|x| x[1] == SubStr( oTree:GetCargo(), 1, 3 )})) > 0
				aLocal[nPos][2] := .T.
			Else
				aAdd( aLocal,{ SubStr( oTree:GetCargo(), 1, 3 ),.T. } )
			EndIf
		EndIf
	Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Utilizacao de Menu Funcional. Opções:
1 - Pesquisa e Posiciona em um Banco de Dados
2 - Simplesmente Mostra os Campos
3 - Inclui registros no Bancos de Dados
4 - Altera o registro corrente
5 - Remove o registro corrente do Banco de Dados

@author Rafael Diogo Richter
@since 29/11/2006

/*/
//-------------------------------------------------------------------
Static Function MenuDef()

	Local lIndAva		:= Select("SX2") > 0 .And. NGCADICBASE( "TBB_INDAVA" , "A" , "TBB" , .F. )
	Local aRotina :=	{	{ STR0001	, "AxPesqui"	, 0 , 1},;//"Pesquisar"
							{ STR0002	, "Sg180Pro"	, 0 , 2},;//"Visualizar"
							{ STR0003	, "Sg180Pro"	, 0 , 3},;//"Incluir"
							{ STR0004	, "Sg180Pro"	, 0 , 4},;//"Alterar"
							{ STR0005	, "Sg180Pro"	, 0 , 5, 3},;//"Excluir"
							{ STR0046	, "MsDocument"	, 0 , 4}}//Conhecimento

	If lIndAva
		aADD( aRotina , { "Legenda" , "SG180BRLG"  , 0 , 2 } ) //"Legenda"
	EndIf

Return aRotina

//-------------------------------------------------------------------
/*/{Protheus.doc} SG180LIN
Valida linhas da getdados.

@author Roger Rodrigues
@since 02/12/2011

/*/
//-------------------------------------------------------------------
Static Function SG180LIN( cAliasOk, lFim )

	Local f
	Local aColsOk := {}, aHeadOk := {}
	Local nPosCod := nPosDesc := nPosFone := 0, nAt := 1
	Local lLinhas := .F.
	Default lFim := .F.

	If cAliasOk == "TBO"
		aColsOk := aClone(oGetTBO:aCols)
		aHeadOk := aClone(oGetTBO:aHeader)
		nAt := oGetTBO:nAt
		nPosCod := GDFIELDPOS("TBO_CODACA",aHeadOk)
		nPosDesc:= GDFIELDPOS("TBO_DESACA",aHeadOk)
	ElseIf cAliasOk == "TBP"
		aColsOk := aClone(oGetTBP:aCols)
		aHeadOk := aClone(oGetTBP:aHeader)
		nAt := oGetTBP:nAt
		nPosCod := GDFIELDPOS("TBP_CODPAR",aHeadOk)
	ElseIf cAliasOk == "TBU"
		aColsOk := aClone(oGetTBU:aCols)
		aHeadOk := aClone(oGetTBU:aHeader)
		nAt := oGetTBU:nAt
		nPosCod := GDFIELDPOS("TBU_CODCON",aHeadOk)
		nPosDesc:= GDFIELDPOS("TBU_DESCON",aHeadOk)
		nPosFone:= GDFIELDPOS("TBU_FONE"  ,aHeadOk)
	ElseIf cAliasOk == "TDQ"
		aColsOk := aClone(oGetTDQ:aCols)
		aHeadOk := aClone(oGetTDQ:aHeader)
		nAt := oGetTDQ:nAt
		nPosCod := GDFIELDPOS("TDQ_CODEQP",aHeadOk)

	Endif
	If lFim
		For f:=1 to Len(aColsOk)
			If !aColsOk[f][Len(aColsOk[f])] .and. !Empty(aColsOk[f][nPosCod])
				lLinhas := .T.
				Exit
			Endif
		Next f
		If !lLinhas
			If cAliasOK == "TBU"
				Return .T.
			Else
				Help(1," ","OBRIGAT2",,aHeadOk[nPosCod][1],3,0)
				Return .F.
			Endif
		Endif
	Endif

	// Percorre aCols
	For f:= 1 to Len(aColsOk)
		If !aColsOk[f][Len(aColsOk[f])]
			If lFim .or. f == nAt
				// VerIfica se os campos obrigatórios estão preenchidos
				If Empty(aColsOk[f][nPosCod])
					// Mostra mensagem de Help
					Help(1," ","OBRIGAT2",,aHeadOk[nPosCod][1],3,0)
					Return .F.
				ElseIf nPosDesc > 0 .and. Empty(aColsOk[f][nPosDesc])
					// Mostra mensagem de Help
					Help(1," ","OBRIGAT2",,aHeadOk[nPosDesc][1],3,0)
					Return .F.
				ElseIf nPosFone > 0 .and. Empty(aColsOk[f][nPosFone])
					// Mostra mensagem de Help
					Help(1," ","OBRIGAT2",,aHeadOk[nPosFone][1],3,0)
					Return .F.
				Endif
			Endif
			// Verifica se é somente LinhaOk
			If f <> nAt .and. !aColsOk[nAt][Len(aColsOk[nAt])]
				If aColsOk[f][nPosCod] == aColsOk[nAt][nPosCod]
					Help(" ",1,"JAEXISTINF",,aHeadOk[nPosCod][1])
					Return .F.
				Endif
			Endif
		Endif
	Next f

	PutFileInEof(cAliasOk)

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} SG180REL
Relacao dos campos da tela

@author  Roger Rodrigues
@since   06/12/2011

@param   cCampo, Caracter, Campo a ser retornado o conteúdo

@return  cRetorno, Caracter, Valor retornado de acordo com o campo
/*/
//-------------------------------------------------------------------
Function SG180REL( cCampo )

	Local cRetorno := ""

	If !NGCADICBASE("TBB_MODULO","A","TBB",.F.)

		If cCampo == "M->TBP_NOMPAR"
			cRetorno := NGSEEK( "QAA", TBP->TBP_CODPAR, 1, "QAA->QAA_NOME" )
		ElseIf cCampo == "M->TBP_CODFUN"
			cRetorno := NGSEEK( "QAA", TBP->TBP_CODPAR, 1, "QAA->QAA_CODFUN" )
		ElseIf cCampo == "M->TBP_DESFUN"
			cRetorno := NGSEEK( "QAC", SG180REL( "M->TBP_CODFUN" ), 1, "QAC->QAC_DESC" )
		Endif

	Else

		If cCampo == "M->TBP_NOMPAR"
			If TBP->TBP_TIPPAR == "2" // Funcionário
				cRetorno := NGSEEK( "SRA", SubStr( TBP->TBP_CODPAR, 1, TAMSX3( "RA_MAT" )[1] ), 1, "SRA->RA_NOME" )
			Else // Usuário
				cRetorno := NGSEEK( "QAA", TBP->TBP_CODPAR, 1, "QAA->QAA_NOME" )
			EndIf
		ElseIf cCampo == "M->TBP_CODFUN"
			If TBP->TBP_TIPPAR == "2" // Funcionário
				cRetorno := NGSEEK( "SRA", SubStr( TBP->TBP_CODPAR, 1, TAMSX3( "RA_MAT" )[1] ), 1, "SRA->RA_CODFUNC" )
			Else // Usuário
				cRetorno := NGSEEK( "QAA", TBP->TBP_CODPAR, 1, "QAA->QAA_CODFUN" )
			EndIf
		ElseIf cCampo == "M->TBP_DESFUN"
			If TBP->TBP_TIPPAR == "2" // Funcionário
				cRetorno := NGSEEK( "SRJ", SG180REL( "M->TBP_CODFUN" ), 1, "SRJ->RJ_DESC" )
			Else // Usuário
				cRetorno := NGSEEK( "QAC", SG180REL( "M->TBP_CODFUN" ), 1, "QAC->QAC_DESC" )
			EndIf
		Endif

	Endif

Return cRetorno

//-------------------------------------------------------------------
/*/{Protheus.doc} SG180IMPF
Inclui participantes por funcao.

@author Roger Rodrigues
@since 02/12/2011

/*/
//-------------------------------------------------------------------
Static Function SG180IMPF()

	// Variaveis do dialog
	Local oPanelTop, oPanelBottom, oDlgImp
	Local aSize := MsAdvSize(,.f.,430)
	Local aButtons := {{"ng_ico_legenda" ,{|| SG180LEG()}, STR0031, STR0031}} // "Legenda"###"Legenda"

	// Variaveis do campo participante
	Local cCodPar, cF3, cTabela, nIndice, cTipPar
	Local cCpoMat, cCpoNom, cDesPar, nTamMat

	// Variaveis do markbrowse
	Local aDBF := {}, aTRB := {}
	Local oMark
	Local oTempMrk

	// Variaveis CBox participante
	Local aCbxPart := { "1=Usuário", "2=Funcionário" }
	Local cCbxPart := M->TBB_MODULO
	Local oCbxPart
	Local oGetParFun

	Private cAliasMrk := GetNextAlias()

	If M->TBB_MODULO == "1"
		cTabela	:= "QAA"
		nIndice	:= 4
		cCpoMat	:= "QAA_MAT"
		cCpoNom	:= "QAA_NOME"
		cCodPar	:= Space(TAMSX3("QAA_CODFUN")[1])
		cDesPar	:= Space(30)
		cF3			:= "QAC"
		nTamMat	:= TAMSX3("QAA_MAT")[1]
	ElseIf M->TBB_MODULO == "2"
		cTabela	:= "SRA"
		nIndice	:= 7
		cCpoMat	:= "RA_MAT"
		cCpoNom	:= "RA_NOME"
		cCodPar	:= Space(TAMSX3("RA_CODFUNC")[1])
		cDesPar	:= Space(30)
		cF3			:= "SRJ"
		nTamMat	:= TAMSX3("RA_MAT")[1]
	EndIf

	Define MsDialog oDlgImp Title STR0029 From 0,0 To aSize[4]+100,aSize[3]+140 of oMainWnd Pixel // "Incluir Participantes"

		oPnlPai := TPanel():New(,,,oDlgImp,,,,,,,,.F.,.F.)
			oPnlPai:Align := CONTROL_ALIGN_ALLCLIENT

			// Panel de cima com os filtros
			oPanelTop := TPanel():New(,,,oPnlPai,,,,,,,, .F., .F. )
				oPanelTop:Align := CONTROL_ALIGN_TOP
				oPanelTop:nHeight := 90

				@ 003 , 003 TO 026 , 355 LABEL OemToAnsi(STR0054) Of oPanelTop Pixel // "Importar Participantes"
				@ 013 , 007 SAY OemToAnsi("Tipo Part.:") OF oPanelTop Pixel Color CLR_HBLUE // "Tipo Part."

				oCbxPart := TComboBox():New( 011, 035, { | u | If( PCount() > 0, cCbxPart := u, cCbxPart ) }, aCbxPart, 55, 10, oPanelTop,,;
					{ || oGetParFun:cF3 := SG180F3PAR( cCbxPart, @cTabela, @nIndice, @cCpoMat, @nTamMat, @cCpoNom, @cCodPar, @cDesPar, 2 ), oMark:oBrowse:Refresh() },;
					,,, .T.,,,,,,,,, "cCbxPart" )

				@ 013 , 099 SAY OemToAnsi(STR0055) OF oPanelTop Pixel Color CLR_HBLUE // "Função:"
				@ 011 , 123 MSGET oGetParFun Var cCodPar SIZE 60,8 F3 cF3 OF oPanelTop Pixel Valid (fValField(cCodPar,@cDesPar,cF3)) HasButton

				@ 013 , 185 SAY OemToAnsi(STR0057) OF oPanelTop Pixel //"Descrição:"
				@ 011 , 215 MSGET cDesPar SIZE 130,8 WHEN .F. OF oPanelTop Picture "@!" Pixel
				@ 028 , 003 BUTTON STR0001 SIZE 49,12 ACTION(fLoadTRB(cCodPar,cTabela,nIndice)) OF oPanelTop Pixel // "Pesquisar"

			dbSelectArea( cTabela )

			aAdd(aDBF,{ "TRB_OK"     , "C", 02, 		0 })
			aAdd(aDBF,{ "TRB_MAT"    , "C", nTamMat,	0 })
			aAdd(aDBF,{ "TRB_NOME"   , "C", 30, 		0 })
			aAdd(aDBF,{ "TRB_STATUS" , "C", 01,			0 })

			oTempMrk := FWTemporaryTable():New( cAliasMrk, aDBF )
			oTempMrk:AddIndex( "1", {"TRB_MAT"} )
			oTempMrk:Create()

			aAdd(aTRB,{ "TRB_OK"      ,NIL," "    ,})
			aAdd(aTRB,{ "TRB_MAT"     ,NIL,RetTitle( cCpoMat ),})
			aAdd(aTRB,{ "TRB_NOME"    ,NIL,RetTitle( cCpoNom ),})

			aCores:= {	{"(cAliasMrk)->TRB_STATUS == '1'"	,"ENABLE"		}	,;
						{"(cAliasMrk)->TRB_STATUS == '2'"	,"BR_VERMELHO"	}}

			oMark := MsSelect():NEW(cAliasMrk,"TRB_OK",,aTRB,@lINVERTE,@cMARCA,,,,oPnlPai,,aCores)
			oMark:oBrowse:lHASMARK 		:= .T.
			oMark:oBrowse:lCANALLMARK 	:= .T.
			oMark:oBrowse:bALLMARK 		:= {|| fMarkAll() }
			oMark:oBrowse:Align 		:= CONTROL_ALIGN_ALLCLIENT

	Activate MsDialog oDlgImp ON INIT EnchoiceBar(oDlgImp,{|| fLoadAcols( cCodPar, cCbxPart ), nOpc :=1, oDlgImp:End()},{||nOpc := 0,oDlgImp:End()},.f.,aButtons)Centered

	oTempMrk:Delete()

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} fLoadTRB
Carrega arquivo temporario com usuarios.

@author Roger Rodrigues
@since 02/12/2011

/*/
//-------------------------------------------------------------------
Static Function fLoadTRB( cFuncao, cTabela, nIndice )

	Local aArea := GetArea()
	Local nPosCod := GDFIELDPOS("TBP_CODPAR", oGetTBP:aHeader)

	dbSelectArea(cAliasMrk)
	Zap

	If cTabela == "QAA"
		cFil		:= "QAA->QAA_FILIAL"
		cMat		:= "QAA->QAA_MAT"
		cNome		:= "QAA->QAA_NOME"
		cStatus	:= "QAA->QAA_STATUS"
		cFunc		:= "QAA->QAA_CODFUN"
	ElseIf cTabela == "SRA"
		cFil 		:= "SRA->RA_FILIAL"
		cMat		:= "SRA->RA_MAT"
		cNome		:= "SRA->RA_NOME"
		cStatus	:= "If( Empty( SRA->RA_DEMISSA ), '1', '2' )"
		cFunc		:= "SRA->RA_CODFUNC"
	EndIf

	dbSelectArea(cTabela)
	dbSetOrder(nIndice)
	dbSeek(xFilial(cTabela)+cFuncao)
	While !eof() .and. xFilial(cTabela) == &( cFil ) .And. cFuncao ==  &( cFunc )
		dbSelectArea(cAliasMrk)
		dbSetOrder(1)
		If !dbSeek( &( cMat ) )
			RecLock(cAliasMrk,.T.)
			(cAliasMrk)->TRB_OK     := If( ( aScan( oGetTBP:aCols,{|x| x[nPosCod] == &( cMat ) } ) ) > 0, cMarca, Space(2))
			(cAliasMrk)->TRB_MAT    := &( cMat )
			(cAliasMrk)->TRB_NOME   := &( cNome )
			(cAliasMrk)->TRB_STATUS := &( cStatus )
			MsUnlock(cAliasMrk)
		Endif
		dbSelectArea(cTabela)
		dbSetOrder(nIndice)
		dbSkip()
	End
	dbSelectArea(cTabela)
	dbSetOrder(1)
	dbSelectArea(cAliasMrk)
	dbGoTop()
	RestArea(aArea)

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} SG180LEG
Monta tela de legenda.

@author Roger Rodrigues
@since 02/12/2011

/*/
//-------------------------------------------------------------------
Static Function SG180LEG()

	BrwLegenda(STR0058,STR0031,	{{"BR_VERDE"		,OemToAnsi(STR0059)},; // "Usuário"###"Legenda"###"Ativo"
                              	{"BR_VERMELHO"	,OemToAnsi(STR0060)}}) // "Inativo"

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} fLoadAcols
Adiciona participantes marcados no acols.

@author Roger Rodrigues
@since 02/12/2011

/*/
//-------------------------------------------------------------------
Static Function fLoadAcols( cFuncao, cTipPar )

	Local aHeader := oGetTBP:aHeader
	Local nPosCod := GDFIELDPOS("TBP_CODPAR", aHeader)
	Local aCols := oGetTBP:aCols
	Local aColsNew := {}
	Local i, nDel := 0

	Default cTipPar := M->TBB_MODULO

	For i := 1 To Len(aCols)
		If !Empty(aCols[i][nPosCod]) .and. !aCols[i][Len(aCols[i])]
			dbSelectArea(cAliasMrk)
			dbSetOrder(1)
			If !dbSeek(aCols[i][nPosCod]) .or. (dbSeek(aCols[i][nPosCod]) .and. IsMark("TRB_OK",cMarca))
				aAdd(aColsNew, aCols[i])
			Endif
		Endif
	Next id

	dbSelectArea(cAliasMrk)
	dbSetOrder(1)
	dbGoTop()
	While !eof()
		If !Empty((cAliasMrk)->TRB_OK) .and. aScan(aColsNew,{|x| x[nPosCod] == (cAliasMrk)->TRB_MAT}) == 0
			aAdd(aColsNew, BlankGetD(aHeader)[1])
			For i:=1 to Len(aHeader)
				If aHeader[i][2] == "TBP_TIPPAR"
					aColsNew[Len(aColsNew)][i] := cTipPar
				ElseIf aHeader[i][2] == "TBP_CODPAR"
					aColsNew[Len(aColsNew)][i] := (cAliasMrk)->TRB_MAT
				Elseif aHeader[i][2] == "TBP_NOMPAR"
					aColsNew[Len(aColsNew)][i] := (cAliasMrk)->TRB_NOME
				ElseIf aHeader[i][2] == "TBP_CODFUN"
					aColsNew[Len(aColsNew)][i] := cFuncao
				ElseIf aHeader[i][2] == "TBP_DESFUN"
					aColsNew[Len(aColsNew)][i] := NGSEEK("QAC",cFuncao,1,"QAC->QAC_DESC")
				ElseIf aHeader[i][2] == "TBP_ALI_WT"
					aColsNew[Len(aColsNew)][i] := "TBP"
				ElseIf aHeader[i][2] == "TBP_REC_WT"
					aColsNew[Len(aColsNew)][i] := 0
				Endif
			Next i
		Endif
		dbSelectArea(cAliasMrk)
		dbSkip()
	End
	If Len(aColsNew) == 0
		aColsNew := BLANKGETD(oGetTBP:aHeader)
	Endif
	oGetTBP:aCols := aColsNew
	oGetTBP:oBrowse:Refresh()

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} fMarkAll
Inverte Marcacao.

@author Roger Rodrigues
@since 02/12/2011

/*/
//-------------------------------------------------------------------
Static Function fMarkAll()

	Local nRecno := Recno()// Guarda registro posicionado

	// Inverte a marcacao dos registros
	dbSelectarea(cAliasMrk)
	dbGoTop()
	While !Eof()
	dbSelectArea(cAliasMrk)
	RecLock(cAliasMrk,.F.)
	(cAliasMrk)->TRB_OK := If(IsMark("TRB_OK",cMarca),Space(2),cMarca)
	MsUnlock(cAliasMrk)
	dbSkip()
	End

	// Reposiciona no Registro
	dbGoTo(nRecno)

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} SG180DELOK
Verifica se a linha da getDados pode ser excluida.

@author Roger Rodrigues
@since 06/12/2010

/*/
//-------------------------------------------------------------------
Static Function SG180DELOK(cTabela)

	Local lRet := .T.
	Local aColsOk := {}, aHeadOk := {}
	Local nPosCod := 1, nAt := 1

	If cTabela == "TBO"
		aColsOk := aClone(oGetTBO:aCols)
		aHeadOk := aClone(oGetTBO:aHeader)
		nAt := oGetTBO:nAt
		nPosCod := GDFIELDPOS("TBO_CODACA", aHeadOk)
	Else
		Return .T.
	Endif
	// Se inclusao ou estiver reativando a linha
	If Inclui .or. aColsOk[nAt][Len(aColsOk[nAt])]
		Return .T.
	Endif

	dbSelectArea("TBO")
	dbSetOrder(1)
	If dbSeek(xFilial("TBO")+M->TBB_CODPLA+aColsOk[nAt][nPosCod])
		lRet := NGVALSX9("TBO",{"TBB"},.T.)
	Endif

	PutFileInEof("TBO")

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} SGA180DEM()
Informa caso for demitir o funcionário, que está relacionado a um
ou mais planos emergenciais. Usado pelo GPEA010.

@Author Elynton Fellipe Bazzo
@since 11/05/2013

/*/
//-------------------------------------------------------------------
Function SGA180DEM()

	Local aArea  := GetArea() // Retorna a area de Trabalho.
	Local lRet   := .F.
	Local lPerg	 := .F.

	dbSelectArea( "SIX" )
	dbSetOrder( 01 )
	If dbSeek( "TBP" + "3" ) // Verifica se existe o indice criado por essa SS.
		dbSelectArea( "TBP" )
		dbSetOrder( 03 ) // TBP_FILIAL+TBP_CODPAR
		If dbSeek( xFilial ( "TBP" ) + SRA->RA_MAT )
			lRet := MsgYesNo( STR0062 ) // "Este Funcionário está relacionado a um ou mais planos emergenciais, deseja excluí-lo do(s) plano(s) em que estiver relacionado(s)?"
			lPerg := .T.
		EndIf
	EndIf

	If lRet // Retorno que exibe a mensagem informando que o funcionário será demitido.
		dbSelectArea( "TBP" )
		dbSetOrder( 03 ) // TBP_FILIAL+TBP_CODPAR
		If dbSeek( xFilial ( "TBP" ) + SRA->RA_MAT )
			While !Eof() .And. TBP->TBP_FILIAL == xFilial( "TBP" )  .And. TBP->TBP_CODPAR == PadR(SRA->RA_MAT,TAMSX3("TBP_CODPAR")[1])
				RecLock( "TBP" ,.F. )
				dbDelete() // Deleta o Funcionário demitido do Plano Emergencial.
				MsUnlock( "TBP" )
				dbSelectArea( "TBP" )
				dbSkip()
			EndDo
		EndIf
	EndIf

	lRet := If(lPerg,lRet,.T.) // Se entrou na pergunta, recebe a opção do usuário, senão .T.

	RestArea ( aArea )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} SG180VLIND
Valida o indicador de avaliação

@author Jackson Machado
@since 18/03/2013

/*/
//---------------------------------------------------------------------
Function SG180VLIND()

	Local lRet := .T.

	If TBB->TBB_INDAVA <> "1" .AND. M->TBB_INDAVA == "1"
		ShowHelpDlg( STR0041 , { STR0063 } , 2 , { STR0064 } , 2 ) // "ATENÇÃO" # "Tipo de Avaliação indisponível." # "Para planos reavaliados, apenas as opções de 'Necessita de Reavaliação' e 'Reavaliado' estão disponíveis."
		lRet := .F.
	EndIf

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} SG180BRLG
Cria uma janela contendo a legenda da mBrowse

@author Jackson Machado
@since 18/03/2013

/*/
//---------------------------------------------------------------------
Function SG180BRLG()

	Local aLegenda := {}

	aAdd( aLegenda , { "BR_VERDE"	, STR0065 } ) // "Primeira Avaliação"
	aAdd( aLegenda , { "BR_VERMELHO", STR0066 } ) // "Necessita Reavaliação"
	aAdd( aLegenda , { "BR_AZUL"	, STR0067 } ) // "Reavaliado"

	BrwLegenda( cCadastro , STR0031 , aLegenda ) // "Legenda"

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} SG180F3PAR
Altera F3 de acordo com o tipo 1=Usuário;2=Funcionário

@author Bruno Lobo de Souza
@since 13/11/2014

/*/
//---------------------------------------------------------------------
Static Function SG180F3PAR( cTipo, cTabela, nIndice, cCpoMat, nTamMat, cCpoNom, cCodPar, cDesPar, nChamada  )

	Local cRet

	If nChamada == 1
		If cTipo == "1"
			cRet		:= "QAA"
			cTabela 	:= "QAA"
			cCpoMat  	:= "QAA_MAT"
			cCodPar 	:= Space(TAMSX3("QAA_MAT")[1])
		ElseIf cTipo == "2"
			cRet 		:= "SRA"
			cTabela  	:= "SRA"
			cCpoMat   	:= "RA_MAT"
			cCodPar  	:= Space(TAMSX3("RA_MAT")[1])
		EndIf
	ElseIf nChamada == 2
		If Select( cAliasMrk ) > 0
			dbSelectArea( cAliasMrk )
			Zap
		EndIf
		If cTipo == "1"
			cRet		:= "QAC"
			cTabela	:= "QAA"
			nIndice	:= 4
			cCpoMat	:= "QAA_MAT"
			cCpoNom	:= "QAA_NOME"
			cCodPar	:= Space(TAMSX3("QAA_CODFUN")[1])
			cDesPar	:= Space(30)
			nTamMat	:= TAMSX3("QAA_MAT")[1]
		ElseIf cTipo == "2"
			cRet		:= "SRJ"
			cTabela	:= "SRA"
			nIndice	:= 7
			cCpoMat	:= "RA_MAT"
			cCpoNom	:= "RA_NOME"
			cCodPar	:= Space(TAMSX3("RA_CODFUNC")[1])
			cDesPar	:= Space(30)
			nTamMat	:= TAMSX3("RA_MAT")[1]
		EndIf
	EndIf

Return cRet
