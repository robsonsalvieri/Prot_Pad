#Include "totvs.ch"
#include "tlpp-core.th"
#include "distribution.convergencia.recebimento.util.ch"

/*/{Protheus.doc} WMSSIntRec
Efetua a integração do recebimento com o Wms Saas
@type function
@author fagner.ferraz
@since 4/22/2024
@param cDoc, character, Numero da nota 
@param cSerie, character, Serie da nota
@param cFornece, character, Fornecedor
@param cLoja, character, Loja
@param dCriacao, date, Data de digitação
@param dEmissao, date, Data de emissão
@param cTransp, character, Transportador
@param cChvNfe, character, Chave da nota
/*/
Function WMSSIntRec(cDoc as character, cSerie as character, cFornece as character, cLoja as character, dCriacao as date, dEmissao as date, cTransp as character, cChvNfe as character) as character
Local oRecebimentoExistente := WMSSaasRecebimento():loadByChave(cDoc, cSerie, cFornece, cLoja)
Local oRecebimento := WMSSaasRecebimento():new(cDoc, cSerie, cFornece, cLoja, dCriacao, dEmissao, cTransp, cChvNfe)

    //-- Verifica se o documento existente pode ser alterado
    If !Empty(oRecebimentoExistente:id) .And. !oRecebimentoExistente:canBeUpdated()
        return oRecebimentoExistente:id
    EndIf
    //-- Verifica se existe um registro na convergencia para o documento e deleta.
    oRecebimentoExistente:delete()

    //-- Verifica se existem itens aptos a integração WMS Saas, em caso positivo, efetua o load e aciona a gravação da classe de convergencia
    If oRecebimento:loadItens() 
        Begin Transaction
            oRecebimento:save()
            oRecebimento:saveItens()
        End Transaction
    EndIf
Return oRecebimento:id

/*/{Protheus.doc} WMSSVlExRe
Efetua a integração do recebimento com o Wms Saas
@type function
@author Filipe Mendes
@since 24/04/2024
@param cDoc, character, Numero da nota 
@param cSerie, character, Serie da nota
@param cFornece, character, Fornecedor
@param cLoja, character, Loja
@param dCriacao, date, Data de digitação
@param dEmissao, date, Data de emissão
@param cTransp, character, Transportador
@param cChvNfe, character, Chave da nota
/*/
Function WMSSVlExRe(cDoc as character, cSerie as character, cFornece as character, cLoja as character, dCriacao as date, dEmissao as date, cTransp as character, cChvNfe as character) as logical
Local oRecebimento := WMSSaasRecebimento():loadByChave(cDoc, cSerie, cFornece, cLoja)

If !Empty(oRecebimento:id) .And. !oRecebimento:canBeUpdated()
    WmsMessage(STR0001,STR0002,,,,STR0003+oRecebimento:getDetalheStatus()) //-- WMSSaas - WmsValidPreNota - Recebimento já integrado ao WMS SaaS. Status - 
    return .F.
EndIF

Return .T.

/*/{Protheus.doc} WMSSVUpSD1
    Valida se campos da SD1 foram alterados
    @type  Function
    @author Filipe Mendes
    @since 29/04/2024
    @version version
    @param aLinha, array, linha do aCols
    @return lWasUpdated, boolean, Retorna se campos proibidos foram alterados
    @example
    (examples)
    @see (links_or_references)
    /*/
Function WMSSVUpSD1(aLinha as array) as logical
Local aAreaSD1 := GetArea("SD1")
Local nRecnoItem := aLinha[Len(aLinha)-1]
Local lIsItemDelete := aLinha[Len(aLinha)]
Local cCodItem := aLinha[GetPosSD1("D1_COD")]
Local cLocalItem := aLinha[GetPosSD1("D1_LOCAL")]
// -- Lista dos campos que nao podem ser alterados
Local aForbiddenFields := {;
    "D1_COD",;
    "D1_QUANT",;
    "D1_VUNIT",;
    "D1_LOCAL",;
    "D1_LOTECTL",;
    "D1_DTVALID",;
    "D1_ITEM";
}
Local lWasUpdated := .F.

	// -- Se recno está em branco e está deletado, nao atualizou
	If Empty(nRecnoItem) .And. lIsItemDelete
		return .F.
	EndIf

	// -- Se recno está em branco, foi uma inserção, então atualizou
	// -- Se delete está true e tem recno, foi uma deleção, então atualizou
	If (Empty(nRecnoItem) .Or. (lIsItemDelete .And. !Empty(nRecnoItem))) .And. WMSSaasInt(cCodItem, cLocalItem)
		return .T.
	EndIf

	DbSelectArea("SD1")
	SD1->(DbGoTo(nRecnoItem))

	// -- Valida campos para ver se alteracao foi efetuada
	aEval(aForbiddenFields, {|field| Iif(SD1->(&(field)) != aLinha[GetPosSD1(field)], lWasUpdated := .T., nil) })

	// -- Valida se o codigo foi alterado e se algum deles controla WMS.
	If !WMSSaasInt(SD1->D1_COD, SD1->D1_LOCAL) .And. !WMSSaasInt(cCodItem, cLocalItem)
		return .F.
	EndIF

	RestArea(aAreaSD1)
Return lWasUpdated

/*/{Protheus.doc} WMSSExcRec
Efetua a integração do recebimento com o Wms Saas
@type function
@author Filipe Mendes
@since 29/04/2024
@param cDoc, character, Numero da nota 
@param cSerie, character, Serie da nota
@param cFornece, character, Fornecedor
@param cLoja, character, Loja
@param dCriacao, date, Data de digitação
@param dEmissao, date, Data de emissão
@param cTransp, character, Transportador
@param cChvNfe, character, Chave da nota
/*/
Function WMSSExcRec(cDoc as character, cSerie as character, cFornece as character, cLoja as character, dCriacao as date, dEmissao as date, cTransp as character, cChvNfe as character) as logical
Local oRecebimento := WMSSaasRecebimento():loadByChave(cDoc, cSerie, cFornece, cLoja)

If !Empty(oRecebimento:id)
    If oRecebimento:canBeUpdated()
        oRecebimento:delete()
    EndIf
EndIF

Return

/*/{Protheus.doc} WMSRetCaracteristicas
Efetua a leitura do payload e gravação das caracteristicas dos itens conferidos
que serão enviados para o processo de finalização na classe de recebimento

@type function
@version 1.0 
@author fagner.ferraz
@since 5/15/2024
@param oCaracteristicasConferidas, object, Json das caracteristicas dos itens
@return array, array das caracteristicas dos itens conferidos no Wms Saas no formato:
[
	{	
		"propriedade": "valor",
		"quantidade": 0
	}
]
/*/
Function WMSRetCaracteristicas(oCaracteristicasConferidas)
    Local aResult := {}
    Local caracteristicaConferida := 0
    Local valorCaracteristica := 0
	Local aCaracteristicaValor
	Local jCaracteristicaTratada := nil

    For caracteristicaConferida := 1 To Len(oCaracteristicasConferidas)
		jCaracteristicaTratada := JsonObject():New()
		aCaracteristicaValor := oCaracteristicasConferidas[caracteristicaConferida]['caracteristicasValor']
		aEval(aCaracteristicaValor, {|valorCaracteristica| ;
			jCaracteristicaTratada[valorCaracteristica['caracteristicaConfiguracao']] := valorCaracteristica['valor'] ;
		})
        jCaracteristicaTratada['quantidade'] := oCaracteristicasConferidas[caracteristicaConferida]['quantidade']
        Aadd( aResult, jCaracteristicaTratada )
    Next caracteristicaConferida

Return aResult

/*/{Protheus.doc} WMSSaasSplitD1
Efetua quebra do item na SD1, subtraindo a quantidade a ser quebrada do registro origem
Baseada na rotina WmsSplitD1 utilizada na conferencia do recebimento
@type function
@version 1.0 
@author fagner.ferraz
@since 5/15/2024
@param nQtdSpl, numeric, Quantidade que sera quebrada na SD1
@param cLocal, character, Armazem
@param cLote, character, Lote
@param dDataValid, date, Data de Validade do lote
@return Nil
/*/
Function WMSSaasSplitD1(nQtdSpl,cLocal,cLote,dDataValid)
Local aAreaAnt  := SB2->(GetArea())
Local aAreaSD1  := SD1->(GetArea()) 
Local aCopiaSD1 := {}
Local cAliasSD1 := GetNextAlias()
Local item     	:= 0
Local cRotina   := "WMSA320" //--Mantido por compatibilidade para uso da função WmsSubSD1
Local nQtdOri   := 0
Local __aCposCal := WMSSaasRecalcularImposto()

Default cLote		:= ""
Default dDataValid	:= SToD("")

	BeginSql Alias cAliasSD1
		SELECT MAX(SD1.D1_ITEM) D1_ITEM
		  FROM %Table:SD1% SD1
		 WHERE SD1.D1_FILIAL  = %xFilial:SD1%
		   AND SD1.D1_DOC     = %Exp:SD1->D1_DOC%
		   AND SD1.D1_SERIE   = %Exp:SD1->D1_SERIE%
		   AND SD1.D1_FORNECE = %Exp:SD1->D1_FORNECE%
		   AND SD1.D1_LOJA    = %Exp:SD1->D1_LOJA%
		   AND SD1.D1_QUANT   > 0
		   AND SD1.%NotDel%
	EndSql
	If (cAliasSD1)->(!Eof())
		nItem := Soma1((cAliasSD1)->D1_ITEM)
	EndIf
	(cAliasSD1)->(DbCloseArea())
	// Guarda a quantidade original do item
	nQtdOri := SD1->D1_QUANT
	// Copia para o array o registro a ser duplicado
	For item := 1 To SD1->(FCount())
		If SD1->(FieldName(item)) == "D1_ITEM"
			AAdd(aCopiaSD1, nItem)
		ElseIf SD1->(FieldName(item)) == "D1_QUANT"
			AAdd(aCopiaSD1, nQtdSpl)
		ElseIf SD1->(FieldName(item)) == "D1_TOTAL"
			AAdd(aCopiaSD1, nQtdSpl * SD1->D1_VUNIT) 			
		ElseIf SD1->(FieldName(item)) == "D1_NUMSEQ"
			AAdd(aCopiaSD1, ProxNum())
		ElseIf !(SD1->(FieldName(item)) == "D1_DESC") .And. AScan(__aCposCal,SD1->(FieldName(item))) > 0 
			// Calcula valores proporcionais para campos predefinidos
			AAdd(aCopiaSD1, WMSSaasCalcularProporcionais(SD1->(FieldName(item)),nQtdSpl,nQtdOri))
		Else
			AAdd(aCopiaSD1,SD1->(FieldGet(item)))
		EndIf
	
		If SD1->(FieldName(item)) == "D1_LOCAL"
			aCopiaSD1[item] := PadR(cLocal,Len(SD1->D1_LOCAL))
		ElseIf SD1->(FieldName(item)) == "D1_QTDCONF"
			aCopiaSD1[item] := 0
		EndIf
	Next item
	
    // Diminui a quantidade faltante do item atual
    WmsSubSD1(cRotina,nQtdSpl/*,cCodDis*/)

	//Cria o novo item na SD1
	RecLock('SD1', .T.)
	For item := 1 To SD1->(FCount())
		SD1->(FieldPut(item,aCopiaSD1[item]))
	Next item

	SD1->D1_LOTECTL := cLote
	SD1->D1_DTVALID := dDataValid
	WMSSaasAtualizarCamposCalculados()
	SD1->(MsUnlock())
	// Valida se SB2 existe
	WmsAvalSB2(SD1->D1_LOCAL,SD1->D1_COD)
	// Ajusta SB2->B2_NAOCLAS
	If SB2->(dbSeek(xFilial("SB2")+SD1->D1_COD+SD1->D1_LOCAL))
		// Grava
		RecLock('SB2',.F.)
		SB2->B2_NAOCLAS += nQtdSpl
		SB2->(MsUnlock())
	EndIf
	RestArea(aAreaAnt)
    //--Necessario reposicionar no registro origem da SD1 que esta sendo dividido
    RestArea(aAreaSD1)
Return

//----------------------------------------------------------
/*/{Protheus.doc} WMSSaasRecalcularImposto
Retorna os campos que necessitam de recálculo na quebra de
itens das Prenotas de Entrada (SD1)

@author  Guilherme A. Metzger
@version P12
@since   13/02/2019
/*/
//----------------------------------------------------------
Static Function WMSSaasRecalcularImposto()
Local aCampos := {}

	AAdd(aCampos,"D1_BASEIPI")
	AAdd(aCampos,"D1_BASEICM")
	AAdd(aCampos,"D1_ICMSRET")
	AAdd(aCampos,"D1_BRICMS" )
	AAdd(aCampos,"D1_BASEIRR")
	AAdd(aCampos,"D1_BASEINS")
	AAdd(aCampos,"D1_PESO"   )
	AAdd(aCampos,"D1_VALCMAJ")
	AAdd(aCampos,"D1_BASIMP5")
	AAdd(aCampos,"D1_BASIMP6")
	AAdd(aCampos,"D1_VALIMP5")
	AAdd(aCampos,"D1_VALIMP6")
	AAdd(aCampos,"D1_DESPESA")
	AAdd(aCampos,"D1_II"     )
	AAdd(aCampos,"D1_BASIMP3")
	AAdd(aCampos,"D1_BASIMP4")
	AAdd(aCampos,"D1_VALIMP2")
	AAdd(aCampos,"D1_VALIMP3")
	AAdd(aCampos,"D1_VALIMP4")
	AAdd(aCampos,"D1_BASIMP2")
	AAdd(aCampos,"D1_VALFRE" )
	AAdd(aCampos,"D1_BASIMA" )
	AAdd(aCampos,"D1_BASEISS")
	AAdd(aCampos,"D1_BASFASE")
	AAdd(aCampos,"D1_BASFUND")
	AAdd(aCampos,"D1_VFCPDIF")
	AAdd(aCampos,"D1_VALINP" )
	AAdd(aCampos,"D1_VRDICMS")
	AAdd(aCampos,"D1_QTPCCEN")
	AAdd(aCampos,"D1_POTENCI")
	AAdd(aCampos,"D1_DESCICM")
	AAdd(aCampos,"D1_BASECOF")
	AAdd(aCampos,"D1_BASECSL")
	AAdd(aCampos,"D1_BASEPIS")
	AAdd(aCampos,"D1_ESTCRED")
	AAdd(aCampos,"D1_BASFEEF")
	AAdd(aCampos,"D1_BASECPB")
	AAdd(aCampos,"D1_AVLINSS")
	AAdd(aCampos,"D1_ABATISS")
	AAdd(aCampos,"D1_BASEINP")
	AAdd(aCampos,"D1_DIFAL"  )
	AAdd(aCampos,"D1_VALANTI")
	AAdd(aCampos,"D1_SLDDEP" )
	AAdd(aCampos,"D1_BSSENAR")
	AAdd(aCampos,"D1_BASEFAB")
	AAdd(aCampos,"D1_BASEFAC")
	AAdd(aCampos,"D1_BASEFET")
	AAdd(aCampos,"D1_ABATMAT")
	AAdd(aCampos,"D1_CRPRSIM")
	AAdd(aCampos,"D1_CONIMP" )
	AAdd(aCampos,"D1_ABATINS")
	AAdd(aCampos,"D1_VALPMAJ")
	AAdd(aCampos,"D1_VALCMAJ")
	AAdd(aCampos,"D1_MARGEM" )
	AAdd(aCampos,"D1_BASEFMP")
	AAdd(aCampos,"D1_BASECPM")
	AAdd(aCampos,"D1_CUSRP1" )
	AAdd(aCampos,"D1_CUSRP2" )
	AAdd(aCampos,"D1_VALCSL" )
	AAdd(aCampos,"D1_CUSRP3" )
	AAdd(aCampos,"D1_CUSRP4" )
	AAdd(aCampos,"D1_CUSRP5" )
	AAdd(aCampos,"D1_CRPRESC")
	AAdd(aCampos,"D1_BASEPRO")
	AAdd(aCampos,"D1_BASEFMD")
	AAdd(aCampos,"D1_VOPDIF" )
	AAdd(aCampos,"D1_BASFECP")
	AAdd(aCampos,"D1_BFCPANT")
	AAdd(aCampos,"D1_BSFCCMP")
	AAdd(aCampos,"D1_BSFCPST")
	AAdd(aCampos,"D1_FCPAUX" )
	AAdd(aCampos,"D1_CRPREPR")
	AAdd(aCampos,"D1_VALFDS" )
	AAdd(aCampos,"D1_PRFDSUL")
	AAdd(aCampos,"D1_UFERMS" )
	AAdd(aCampos,"D1_BASESES")
	AAdd(aCampos,"D1_BASNDES")
	AAdd(aCampos,"D1_ICMNDES")
	AAdd(aCampos,"D1_CUSTO")
Return aCampos

//----------------------------------------------------------
/*/{Protheus.doc} WMSSaasCalcularProporcionais
Calcula os valores proporcionais para o novo item da SD1

@author  Guilherme A. Metzger
@version P12
@since   13/02/2019
/*/
//----------------------------------------------------------
Static Function WMSSaasCalcularProporcionais(cCampo,nQuant,nQtdOri)
Local nValor := SD1->&(cCampo)
Local nRet   := 0
	nRet := (nValor * nQuant) / nQtdOri
Return nRet

/*/{Protheus.doc} D1UpdCalculatedFields
	Função para atualizar os campos calculados da SD1
	@type  Static Function
	@author Filipe Mendes
	@since 04/06/2024
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function WMSSaasAtualizarCamposCalculados()
	SD1->D1_VALIPI  := (SD1->D1_BASEIPI * (SD1->D1_IPI     / 100))
	SD1->D1_VALICM  := (SD1->D1_BASEICM * (SD1->D1_PICM    / 100))
	SD1->D1_VALIRR  := (SD1->D1_BASEIRR * (SD1->D1_ALIQIRR / 100))
	SD1->D1_VALINS  := (SD1->D1_BASEINS * (SD1->D1_ALIQINS / 100))
	SD1->D1_VALDESC := (SD1->D1_TOTAL   * (SD1->D1_DESC    / 100))
	SD1->D1_VALIMA  := (SD1->D1_BASIMA  * (SD1->D1_ALIIMA  / 100))
	SD1->D1_VALISS  := (SD1->D1_BASEISS * (SD1->D1_ALIQISS / 100))
	SD1->D1_VALFASE := (SD1->D1_BASFASE * (SD1->D1_ALIFASE / 100))
	SD1->D1_VALFUND := (SD1->D1_BASFUND * (SD1->D1_ALIFUND / 100))
	SD1->D1_VALFEEF := (SD1->D1_BASFEEF * (SD1->D1_ALQFEEF / 100))
	SD1->D1_VALCPB  := (SD1->D1_BASECPB * (SD1->D1_ALIQCPB / 100))
	SD1->D1_VLSENAR := (SD1->D1_BSSENAR * (SD1->D1_ALSENAR / 100))
	SD1->D1_VALFAB  := (SD1->D1_BASEFAB * (SD1->D1_ALIQFAB / 100))
	SD1->D1_VALFAC  := (SD1->D1_BASEFAC * (SD1->D1_ALIQFAC / 100))
	SD1->D1_VALFET  := (SD1->D1_BASEFET * (SD1->D1_ALIQFET / 100))
	SD1->D1_VALCOF  := (SD1->D1_BASECOF * (SD1->D1_ALQCOF  / 100))
	SD1->D1_VLCIDE  := (SD1->D1_BASECID * (SD1->D1_ALQCIDE / 100))
	SD1->D1_VALPIS  := (SD1->D1_BASEPIS * (SD1->D1_ALQPIS  / 100))
	SD1->D1_VALCPM  := (SD1->D1_BASECPM * (SD1->D1_ALQCPM  / 100))
	SD1->D1_VALPRO  := (SD1->D1_BASEPRO * (SD1->D1_ALIQPRO / 100))
	SD1->D1_VALFMD  := (SD1->D1_BASEFMD * (SD1->D1_ALQFMD  / 100))
	SD1->D1_VFCPANT := (SD1->D1_BFCPANT * (SD1->D1_AFCPANT / 100))
	SD1->D1_VALFMP  := (SD1->D1_BASEFMP * (SD1->D1_ALQFMP  / 100))
	SD1->D1_VALSES  := (SD1->D1_BASESES * (SD1->D1_ALIQSES / 100))
	SD1->D1_QTSEGUM := ConvUm(SD1->D1_COD, SD1->D1_QUANT, 0, 2)
Return

/*/{Protheus.doc} WMSSaasUCodeS1 
//Converte o valor do campo "sequencia" do SaaS para C6/9_ITEM. 
Devido ao tamanho dos campos serem diferente e ter o uso da função SOMA1()
@author Filipe Mendes
@since 11/07/2022
@version 1.0
@return ${return}, ${return_description}
@param cItem, characters, Conteudo do campo Sequencia
@param nTamanho, numeric, Tamanho do campo C6/9_ITEM
@type function
/*/
//--TO DO - Verificar se este é o melhor fonte para manter esta função, caso seja usada por outros tipos de integração
Function WMSSaasUCodeS1(cItem,nTamanho)
Local cResult
Local nLoop
Local nValor
        
nValor := DecodSoma1(cItem)

cResult := strzero(0,nTamanho)
For nLoop := 1 to nValor
    cResult := Soma1(cResult)
Next nLoop

Return cResult
/*/{Protheus.doc} WMSSVldCla
Valida se documento pode ser classificado antes do envio para o 
WMS SaaS
@type function
@author Filipe Mendes
@since 29/04/2024
@param cDoc, character, Numero da nota 
@param cSerie, character, Serie da nota
@param cFornece, character, Fornecedor
@param cLoja, character, Loja
@param dCriacao, date, Data de digitação
@param dEmissao, date, Data de emissão
@param cTransp, character, Transportador
@param cChvNfe, character, Chave da nota
/*/
Function WMSSVldCla(cDoc as character, cSerie as character, cFornece as character, cLoja as character, dCriacao as date, dEmissao as date, cTransp as character, cChvNfe as character) as logical
Local oRecebimento := WMSSaasRecebimento():loadByChave(cDoc, cSerie, cFornece, cLoja)

If Empty(oRecebimento:id)
    return .T.
EndIF

If !oRecebimento:canBeClassed()
    WmsMessage(STR0001,STR0004,,,,STR0005+oRecebimento:getDetalheStatus()) // -- WMSSaas - WMSSVldCla - Recebimento não pode ser classificado antes do retorno do WMS SaaS. Status - 
    return .F.
EndIf

Return .T.

/*/{Protheus.doc} WMSSVldDiv
Valida se documento está finalizado com divergência e mostra mensagem
WMS SaaS
@type function
@author Filipe Mendes
@since 29/04/2024
@param cDoc, character, Numero da nota 
@param cSerie, character, Serie da nota
@param cFornece, character, Fornecedor
@param cLoja, character, Loja
@param dCriacao, date, Data de digitação
@param dEmissao, date, Data de emissão
@param cTransp, character, Transportador
@param cChvNfe, character, Chave da nota
/*/
Function WMSSVldDiv(cDoc as character, cSerie as character, cFornece as character, cLoja as character, dCriacao as date, dEmissao as date, cTransp as character, cChvNfe as character) as logical
Local oRecebimento := WMSSaasRecebimento():loadByChave(cDoc, cSerie, cFornece, cLoja)

If Empty(oRecebimento:id)
    return .T.
EndIF

If oRecebimento:isFinalizadoDivergente()
    Return FWAlertNoYes(STR0006 + CRLF + CRLF + STR0007 + CRLF + STR0008 + CRLF + STR0009 + CRLF + CRLF + STR0010 + CRLF, STR0011 )
EndIf

Return .T.

/*/{Protheus.doc} WMSSaasRebuildSD1
	(long_description)
	@type  Function
	@author user
	@since 03/06/2024
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Function WMSSaasRebuildSD1(cId as character) as logical
Local aArea := GetArea()
Local cAliasDBY := GetNextAlias()
Local cAliasSD1 := GetNextAlias()
Local aItems := {}
Local __aCposCal := WMSSaasRecalcularImposto()
Local campo := 0
Local nQtdAtu := 0

    BeginSql Alias cAliasDBY
		SELECT SD1.R_E_C_N_O_ RECNO, DBY_QUANT, DBY_LOTE, DBY_DTVALI, DBY_LOCAL,
				DBZ_NUMDOC, DBZ_SERIE, DBZ_CLIFOR, DBZ_LOJA, DBY_ITEM
		
		  FROM %Table:DBY% DBY 
		 INNER JOIN %Table:DBZ% DBZ
			ON DBZ_ID     = DBY_ID
		   AND DBZ_FILIAL = DBY_FILIAL

		 INNER JOIN %Table:SD1% SD1
		    ON D1_DOC     = DBZ_NUMDOC
		   AND D1_SERIE   = DBZ_SERIE
		   AND D1_FORNECE = DBZ_CLIFOR
		   AND D1_LOJA    = DBZ_LOJA
		   AND D1_ITEM    = DBY_ITEM
		   AND D1_COD     = DBY_PRODUT

		 WHERE DBY.%NotDel%
		   AND DBZ.%NotDel%
		   AND SD1.%NotDel%
		   AND DBZ_FILIAL =  %Exp:FWxFilial("DBZ")%
		   AND D1_FILIAL  =  %Exp:FWxFilial("SD1")%
		   AND DBZ_TIPOTR = %Exp:WMSSaasConvergencia():getTipoTransacaoRecebimento()%
		   AND DBZ_ID     = %Exp:cId%
	EndSql

	DbSelectArea("SD1")
	While (cAliasDBY)->(!Eof())
        DbGoTo((cAliasDBY)->RECNO)
		
		nQtdAtu := SD1->D1_QUANT

		RecLock("SD1",.F.)
		SD1->D1_QUANT   := (cAliasDBY)->DBY_QUANT
		SD1->D1_TOTAL   := SD1->D1_VUNIT * SD1->D1_QUANT
		SD1->D1_LOTECTL := (cAliasDBY)->DBY_LOTE
		SD1->D1_DTVALID := StoD((cAliasDBY)->DBY_DTVALI)
		SD1->D1_LOCAL   := (cAliasDBY)->DBY_LOCAL
		
		// -- Calcula campos predefinidos
		For campo := 1 To SD1->(FCount())
			If(AScan(__aCposCal,;
				SD1->(FieldName(campo))) > 0,; 
				SD1->(FieldPut(campo, WMSSaasCalcularProporcionais(SD1->(FieldName(campo)),(cAliasDBY)->DBY_QUANT,nQtdAtu))),;
				nil)
		Next campo

		WMSSaasAtualizarCamposCalculados()
		SD1->(MsUnlock())
		aAdd(aItems, (cAliasDBY)->DBY_ITEM )
		(cAliasDBY)->(DbSkip())
    End

(cAliasDBY)->(DbGoTop())
BeginSql Alias cAliasSD1
	SELECT SD1.R_E_C_N_O_ RECNO, D1_COD, D1_LOCAL
	  FROM %Table:SD1% SD1
	 WHERE SD1.%NotDel%
	   AND D1_FILIAL  =  %Exp:FWxFilial("SD1")%
	   AND D1_DOC     = %Exp:(cAliasDBY)->DBZ_NUMDOC%
	   AND D1_SERIE   = %Exp:(cAliasDBY)->DBZ_SERIE%
	   AND D1_FORNECE = %Exp:(cAliasDBY)->DBZ_CLIFOR%
	   AND D1_LOJA    = %Exp:(cAliasDBY)->DBZ_LOJA%
	   AND D1_ITEM NOT IN (%Exp:ArrToKStr(aItems, ",")%)
EndSql

// -- Se item integra e não existe na DBY, deleta.
(cAliasSD1)->(DbEval( {|| If(WMSSaasInt((cAliasSD1)->D1_COD, (cAliasSD1)->D1_LOCAL), WMSSaasDeleteSD1((cAliasSD1)->RECNO), nil) },,, (cAliasSD1)->(FCount()) )) 

(cAliasDBY)->(DbCloseArea())
(cAliasSD1)->(DbCloseArea())
RestArea(aArea)
Return .T.

/*/{Protheus.doc} WMSSaasDeleteSD1
	deleta SD1 baseada no recno
	@type  Static Function
	@author Filipe Mendes
	@since 05/06/2024
	@version version
	@param nRecno, integer, recno a ser deletado
	@return 
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function WMSSaasDeleteSD1(nRecno as integer)
	DbSelectArea("SD1")
	SD1->(DbGoTo(nRecno))
	SD1->(RecLock("SD1",.F.))
	SD1->(DbDelete())
	SD1->(MsUnlock())
Return
