#include "Totvs.ch"
#include "tlpp-core.th"
#include "distribution.convergencia.manufatura.controle.requisicao.classe.ch"

#define GERADA "1"
#define CONCLUIDA "2"
#define EXCLUIDA "3"

Static nTamProd   := TamSx3('D3_COD')[1]
Static nTamLocal  := TamSx3('D3_LOCAL')[1]
Static nTamLote   := TamSx3('D3_LOTECTL')[1]
Static nTamSeqReq := TamSX3("DBX_SEQREQ")[1]
Static nTamIdRes  := TamSX3("DBX_IDRES")[1]

/*/{Protheus.doc} WMSSaasManufaturaRequisicao
    Classe de requisicao manufatura
    @author Fagner Ferraz
    @since 05/12/2024
    @version 1.0
    /*/
Class WMSSaasManufaturaControleRequisicao
    Public Method new(cOrdemProducao as character, cProduto as character, cSequenciaEstrutura as character, cLote as character, cSubLote as character, dDataValidade as date, cArmazem as character, cOrdem as character, cOrdemProducaoOrigem as character, cSequencia as character, dDataEmpenho, nQuantidade as numeric) as object
    Public Method load() as object
    Public Method loadOrNew(cOrdemProducao as character, cProduto as character, cSequenciaEstrutura as character, cLote as character, cSubLote as character, dDataValidade as date, cArmazem as character, cOrdem as character, cOrdemProducaoOrigem as character, cSequencia as character, dDataEmpenho, nQuantidade as numeric) as object
    Public Method loadByChave(cOrdemProducao as character, cProduto as character, cSequenciaEstrutura as character, cLote as character, cSubLote as character, cArmazem as character, cOrdem as character, cOrdemProducaoOrigem as character, cSequencia as character, nQuantidade as numeric) as object
    Public Method loadByIdDBZ(cId as character) as object
    Public Method loadByRecno(nRecno as numeric) as object
    Public Method loadConvergencia() as object
    Static Method getStatusGerada() as character
    Static Method getStatusConcluida() as character
    Public method isGerada() as logical
    Public Method save()
    Public Method delete()   
    Public Method updateStatus(cStatus as character)
    Public Method getSequence() as character
    Public Method atualizaManufaturaRequisicao(jManufaturaRequisicao as json) as logical
    Public Method validaRequisicaoProcessada(jManufaturaRequisicao as json) as logical
    Public Method geraTransferenciaProducao(jManufaturaRequisicao as json) as logical
    Public Method geraMovimentoTransferencia(aItens as array) as logical
    Public Method ajustesEmpenhoRequisicao(jManufaturaRequisicao as json) as logical
    Public Data convergencia as object
    Public Data produto as character
    Public Data ordemProducao as character
    Public Data sequenciaOrdemProducao as character
    Public Data sequenciaEstrutura as character
    Public Data lote as character
    Public Data subLote as character
    Public Data armazem as character
    Public Data ordem as character
    Public Data origem as character
    Public Data ordemProducaoOrigem as character
    Public Data sequencia as character
    Public Data sequenciaRequisicao as character
    Public Data dataRequisicao as date
    Public Data dataEmissao as date
    Public Data dataValidade as date
    Public Data quantidade as numeric
    Public Data status as character
    Public Data sequenciaIntegracao as numeric
    Public Data recno as numeric
    Public Data idConvergencia as character
    Public Data idReserva as character
EndClass

/*/{Protheus.doc} New
    @author Alexsander Burigo Correa
    @since 16/12/2024
    @version 1.0
    @param cOrdemProducao, character, Ordem de producao
    @param cProduto, character, materia prima
    @param cSequenciaEstrutura, character, sequencia da estrutura
    @param cLote, character, Lote da materia prima
    @param cSubLote, character, SubLote do lote da materia prima
    @param dDataValidade, date, Data de validade do lote
    @param cArmazem, character, Armazem
    @param dDataEmpenho, date, Data de geracao do empenho
    @param nQuantidade, numeric, Quantidade para requisitar
    @return self, object, Objeto do controle de requisicao
    /*/
Method new(cOrdemProducao, cProduto, cSequenciaEstrutura, cLote, cSubLote, dDataValidade, cArmazem, cOrdem, cOrdemProducaoOrigem, cSequencia, dDataEmpenho, nQuantidade) Class WMSSaasManufaturaControleRequisicao
    self:produto             := cProduto
    self:ordemProducao       := cOrdemProducao
    self:sequenciaEstrutura  := cSequenciaEstrutura
    self:lote                := cLote
    self:subLote             := cSubLote
    self:armazem             := cArmazem
    self:ordem               := cOrdem
    self:ordemProducaoOrigem := cOrdemProducaoOrigem
    self:sequencia           := cSequencia
    self:dataEmissao         := dDataEmpenho
    self:dataRequisicao      := dDataBase
    self:dataValidade        := dDataValidade
    self:quantidade          := nQuantidade
    self:status              := self:getStatusGerada()
    self:convergencia        := self:loadConvergencia()
    self:origem              := 'S'
    self:idReserva           := ""
    self:recno               := 0
Return self

/*/{Protheus.doc} loadOrNew
    (long_description)
    @author Alexsander Burigo Correa
    @since 16/12/2024
    @version 1.0
    @param cOrdemProducao, character, Ordem de producao
    @param cProduto, character, materia prima
    @param cSequenciaEstrutura, character, sequencia da estrutura
    @param cLote, character, Lote da materia prima
    @param cSubLote, character, SubLote do lote da materia prima
    @param dDataValidade, date, Data de validade do lote
    @param cArmazem, character, Armazem
    @param cOrdem, character, Ordem
    @param cOrdemProducaoOrigem, character, Ordem de producao origem
    @param cSequencia, character, Sequencia
    @param dDataEmpenho, date, Data de geracao do empenho
    @param nQuantidade, numeric, Quantidade para requisitar    
    @return self, object, Objeto do controle de requisicao
    /*/
Method loadOrNew(cOrdemProducao, cProduto, cSequenciaEstrutura, cLote, cSubLote, dDataValidade, cArmazem, cOrdem, cOrdemProducaoOrigem, cSequencia, dDataEmpenho, nQuantidade) Class WMSSaasManufaturaControleRequisicao
local oLoad := self:loadByChave(cOrdemProducao, cProduto, cSequenciaEstrutura, cLote, cSubLote, cArmazem, cOrdem, cOrdemProducaoOrigem, cSequencia)
    If !Empty(oLoad:recno)
        Return oLoad
    EndIf
Return self:new(cOrdemProducao, cProduto, cSequenciaEstrutura, cLote, cSubLote, dDataValidade, cArmazem, cOrdem, cOrdemProducaoOrigem, cSequencia, dDataEmpenho, nQuantidade)

/*/{Protheus.doc} Load
    (long_description)
    @author Alexsander Burigo Correa
    @since 15/12/2024
    @version 1.0
    @return self, object, Objeto do controle de requisicao
    /*/
Method load() Class WMSSaasManufaturaControleRequisicao
    self:produto             := DBX->DBX_COD
    self:ordemProducao       := DBX->DBX_OP
    self:sequenciaEstrutura  := DBX->DBX_TRT
    self:lote                := DBX->DBX_LOTECT
    self:subLote             := DBX->DBX_NUMLOT
    self:armazem             := DBX->DBX_LOCAL
    self:ordem               := DBX->DBX_ORDEM
    self:ordemProducaoOrigem := DBX->DBX_OPORIG
    self:sequencia           := DBX->DBX_SEQ
    self:sequenciaRequisicao := DBX->DBX_SEQREQ
    self:dataRequisicao      := DBX->DBX_DATREQ
    self:dataValidade        := DBX->DBX_DTVALD
    self:quantidade          := DBX->DBX_QUANT
    self:status              := DBX->DBX_STATUS
    self:origem              := DBX->DBX_ORIGEM
    self:idReserva           := DBX->DBX_IDRES
    self:idConvergencia      := DBX->DBX_IDDBZ
    self:recno               := DBX->(Recno())
    self:convergencia        := self:loadConvergencia()
Return self

/*/{Protheus.doc} loadByChave
    Faz o load da classe de requisicao empenha WMS SaaS e convergencia pela chave
    Esse metodo deve retornar apenas um registro da DBX sempre, pois cada requisicao pode ter uma sequencia em branco nao integrada.
    @author Alexsander Burigo Correa
    @since 19/12/2024
    @version 1.0
    @param cOrdemProducao, character, Ordem de producao
    @param cProduto, character, materia prima
    @param cSequenciaEstrutura, character, sequencia da estrutura
    @param cLote, character, Lote da materia prima
    @param cSubLote, character, SubLote do lote da materia prima
    @param cArmazem, character, Armazem
    @param cOrdem, character, Ordem
    @param cOrdemProducaoOrigem, character, Ordem de producao origem
    @param cSequencia, character, Sequencia
    @return self, object, Objeto do controle de requisicao
    /*/
Method loadByChave(cOrdemProducao, cProduto, cSequenciaEstrutura, cLote, cSubLote, cArmazem, cOrdem, cOrdemProducaoOrigem, cSequencia) Class WMSSaasManufaturaControleRequisicao
Local cAliasDBX  := GetNextAlias()
Local cOrigem    := "S"
Local cIdReserva := Space(nTamIdRes)
    BeginSql Alias cAliasDBX
		SELECT DBX.R_E_C_N_O_ RECNODBX
		  FROM %Table:DBX% DBX
         INNER JOIN %Table:DBZ% DBZ
            ON DBZ.DBZ_FILIAL = %Exp:xFilial("DBZ")%
           AND DBZ.DBZ_ID     = DBX.DBX_IDDBZ
           AND DBZ.DBZ_STATUS = %Exp:WMSSaasConvergencia():getStatusCriado()%
           AND DBZ.%NotDel%
		 WHERE DBX.DBX_FILIAL = %Exp:xFilial("DBX")%
		   AND DBX.DBX_COD    = %Exp:cProduto%
		   AND DBX.DBX_OP     = %Exp:cOrdemProducao%
           AND DBX.DBX_TRT    = %Exp:cSequenciaEstrutura%
           AND DBX.DBX_LOTECT = %Exp:cLote%
           AND DBX.DBX_NUMLOT = %Exp:cSubLote%
           AND DBX.DBX_LOCAL  = %Exp:cArmazem%
           AND DBX.DBX_ORDEM  = %Exp:cOrdem%
           AND DBX.DBX_OPORIG = %Exp:cOrdemProducaoOrigem%
           AND DBX.DBX_SEQ    = %Exp:cSequencia%
           AND DBX.DBX_STATUS = %Exp:self:getStatusGerada()%
           AND DBX.DBX_ORIGEM = %Exp:cOrigem%
           AND DBX.DBX_IDRES  = %Exp:cIdReserva%
		   AND DBX.%NotDel%
	EndSql
    If (cAliasDBX)->(!Eof())
        self:loadByRecno((cAliasDBX)->RECNODBX)
    EndIf
    (cAliasDBX)->(DbCloseArea())
Return self

/*/{Protheus.doc} loadByRecno
    Instancia um novo objeto a partir do id
    @author Alexsander Burigo Correa
    @since 18/12/2024
    @version 1.0
    @param nRecno, numeric, Recno do registro na tabela (DBX)
    @return self, object, classe instanciada
    /*/
Method loadByRecno(nRecno) Class WMSSaasManufaturaControleRequisicao
Local aArea    := GetArea()
Local aAreaDBX := DBX->(GetArea())  
    If WMSSaasSeekDBXByRecno(nRecno)
        self:load()
    EndIf
    RestArea(aAreaDBX)
    RestArea(aArea)
Return self

/*/{Protheus.doc} loadByIdDBZ
    Instancia um novo objeto a partir do id
    @author Alexsander Burigo Correa
    @since 18/12/2024
    @version 1.0
    @param nRecno, numeric, Recno do registro na tabela (DBX)
    @return self, object, classe instanciada
    /*/
Method loadByIdDBZ(cId) Class WMSSaasManufaturaControleRequisicao
Local aArea    := GetArea()
Local aAreaDBX := DBX->(GetArea())  
    If WMSSaasSeekDBXByIdDBZ(cId)
        self:load()
    EndIf
    RestArea(aAreaDBX)
    RestArea(aArea)
Return self

/*/{Protheus.doc} Save
    @author Alexsander Burigo Correa
    @since 18/12/2024
    @version 1.0
    /*/
Method Save() Class WMSSaasManufaturaControleRequisicao    
Local lInsert    := self:recno == 0

    DBX->(DbGoTo(self:recno))
    If lInsert
        self:sequenciaRequisicao := self:getSequence()
    EndIf
    // Salva as informaÃ§Ãµes da convergencia
    self:convergencia:save()
    self:convergencia:saveItens()

    If RecLock("DBX", lInsert)
        DBX->DBX_FILIAL := xFilial("DBX")
        DBX->DBX_COD    := self:produto
        DBX->DBX_OP     := self:ordemProducao
        DBX->DBX_TRT    := self:sequenciaEstrutura
        DBX->DBX_LOTECT := self:lote
        DBX->DBX_NUMLOT := self:subLote 
        DBX->DBX_LOCAL  := self:armazem 
        DBX->DBX_ORDEM  := self:ordem
        DBX->DBX_OPORIG := self:ordemProducaoOrigem
        DBX->DBX_SEQ    := self:sequencia
        DBX->DBX_SEQREQ := self:sequenciaRequisicao
        DBX->DBX_DATREQ := self:dataRequisicao
        DBX->DBX_DTVALD := self:dataValidade
        DBX->DBX_QUANT  := self:convergencia:getItem(self:produto, self:lote):quantidade
        DBX->DBX_STATUS := self:status
        DBX->DBX_IDDBZ  := self:convergencia:id
        DBX->DBX_ORIGEM := self:origem
        DBX->DBX_IDRES  := self:idReserva
        DBX->(MsUnlock())
    EndIf
Return 

/*/{Protheus.doc} Delete
    @author Alexsander Burigo Correa
    @since 18/12/2024
    @version 1.0
    /*/
Method delete() Class WMSSaasManufaturaControleRequisicao
    If WMSSaasSeekDBXByRecno(self:recno) .And. RecLock("DBX",.F.)
		DBX->(dbDelete())
		DBX->(MsUnlock())
    EndIf
Return

/*/{Protheus.doc} updateStatus
    @author Equipe WMS
    @since 31/01/2025
    @version 1.0
    /*/
Method updateStatus(cStatus as character) Class WMSSaasManufaturaControleRequisicao
    If WMSSaasSeekDBXByRecno(self:recno) .And. RecLock("DBX",.F.)
		DBX->DBX_STATUS := cStatus
		DBX->(MsUnlock())
    EndIf
Return


/*/{Protheus.doc} loadConvergencia
    @author Alexsander Burigo Correa
    @since 16/12/2024
    @version 1.0
    @return oConvergencia, object, Objeto da convergencia
    /*/
Method loadConvergencia() Class WMSSaasManufaturaControleRequisicao
Local oConvergencia := WMSSaasManufaturaRequisicao():new(self:ordemProducao, self:dataEmissao)

    If !Empty(self:idConvergencia)
        oConvergencia := oConvergencia:loadById(self:idConvergencia)
    EndIf

Return oConvergencia

/*/{Protheus.doc} getStatusGerada
    @author Alexsander Burigo Correa
    @since 16/12/2024
    @version 1.0
    @return Status, character, Status correspondente a requisicao gerada
    /*/
Method getStatusGerada() Class WMSSaasManufaturaControleRequisicao
Return GERADA

/*/{Protheus.doc} getStatusConcluida
    @author Equipe WMS Protheus
    @since 16/12/2024
    @version 1.0
    @return Status, character, Status correspondente a requisicao gerada
    /*/
Method getStatusConcluida() Class WMSSaasManufaturaControleRequisicao
Return CONCLUIDA

/*/{Protheus.doc} isGerada
    @author Alexsander Burigo Correa
    @since 16/12/2024
    @version 1.0
    @return lRet, logical, Indica se o status da requisicao esta como gerada
    /*/
Method isGerada() Class WMSSaasManufaturaControleRequisicao
Return (self:status == GERADA)

/*/{Protheus.doc} getSequence
    @author Alexsander Burigo Correa
    @since 17/12/2024
    @version 1.0
    @return cNewSeq, character, nova sequencia da requisicao
    /*/
Method getSequence() Class WMSSaasManufaturaControleRequisicao
Local cAliasDBX := GetNextAlias()
Local cNewSeq   := ''              
    
    BeginSql Alias cAliasDBX
		SELECT MAX(DBX.DBX_SEQREQ) MAXSEQREQ
		  FROM %Table:DBX% DBX
		 WHERE DBX.DBX_FILIAL = %Exp:xFilial("DBX")%
		   AND DBX.DBX_OP     = %Exp:self:ordemProducao%
		   AND DBX.%NotDel%
	EndSql    
	cNewSeq := Iif(!Empty((cAliasDBX)->MAXSEQREQ), Soma1(PadL((cAliasDBX)->MAXSEQREQ, nTamSeqReq, "0" )), Soma1(PadL("0",nTamSeqReq,"0")))

    (cAliasDBX)->(DbCloseArea())
Return cNewSeq

/*/{Protheus.doc} atualizaManufaturaRequisicao
    @author Alexsander Burigo Correa
    @since 22/01/2025
    @version version 1.0
    @param jFinalizados, array, Reservas finalizadas
    @return return_var, return_type, return_description
    /*/
Method atualizaManufaturaRequisicao(jManufaturaRequisicao) Class WMSSaasManufaturaControleRequisicao
    Conout("INICIO | atualizaManufaturaRequisicao | WMSSaasManufaturaControleRequisicao")
    If jManufaturaRequisicao['quantidade'] > 0
        Conout("Quantidade maior que zero | atualizaManufaturaRequisicao | WMSSaasManufaturaControleRequisicao")
        If !self:geraTransferenciaProducao(jManufaturaRequisicao)
            Conout("Falha ao gerar transferencia | atualizaManufaturaRequisicao | WMSSaasManufaturaControleRequisicao")
            Return .F.
        EndIf
    EndIf
    self:ajustesEmpenhoRequisicao(jManufaturaRequisicao)
    Conout("FIM | atualizaManufaturaRequisicao | WMSSaasManufaturaControleRequisicao")
Return .T.

/*/{Protheus.doc} validaRequisicaoProcessada
    @author user
    @since 23/09/2024
    @version version
    @param jManufaturaRequisicao, json, Dados da json
    @return lRet, logical, Indica se requisicao ja processada
    /*/
Method validaRequisicaoProcessada(jManufaturaRequisicao) Class WMSSaasManufaturaControleRequisicao
Local cAliasDBX        := GetNextAlias()
Local cOrigem          := 'N'
Local cIdReserva       := jManufaturaRequisicao['idReserva']
Local lRet             := .F. 

    Conout("INICIO | validaRequisicaoProcessada | WMSSaasManufaturaControleRequisicao")
    BeginSql Alias cAliasDBX
        SELECT 1
          FROM %Table:DBX% DBX
         WHERE DBX.DBX_FILIAL = %Exp:xFilial("DBX")%
           AND DBX.DBX_IDDBZ  = %Exp:self:idConvergencia%
           AND DBX.DBX_ORIGEM = %Exp:cOrigem%
           AND DBX.DBX_IDRES  = %Exp:cIdReserva%
           AND DBX.%NotDel%
    EndSql
    If (cAliasDBX)->(!Eof())
        Conout(" Encontrou IDRES com mesma origem | validaRequisicaoProcessada | WMSSaasManufaturaControleRequisicao")
        lRet := .T.
    EndIf
    (cAliasDBX)->(DbCloseArea())
    Conout("FIM | validaRequisicaoProcessada | WMSSaasManufaturaControleRequisicao")
Return lRet

/*/{Protheus.doc} geraTransferenciaProducao
    Metodo de finalizacao do movimento transferencia
    @author Alexsander Burigo Correa
    @since 23/01/2025
    @version version
    @param jManufaturaRequisicao, array, array de json com item movimentado
    @return return_var, return_type, return_description
/*/
Method geraTransferenciaProducao(jManufaturaRequisicao) Class WMSSaasManufaturaControleRequisicao
Local cProduto           := Padr(jManufaturaRequisicao['produto'],nTamProd)
Local lRastro            := Rastro(cProduto,"L")
Local cTipEstoqueOrigem  := Padr(jManufaturaRequisicao['tipoEstoque'],nTamLocal)
Local cLote              := If(lRastro .And. !(jManufaturaRequisicao['lote']==NIL),jManufaturaRequisicao['lote'],Space(nTamLote))
Local dDataValidade      := If(lRastro,jManufaturaRequisicao['dataValidade'],CtoD('  /  /  '))
Local cTipEstoqueDestino := ""
Local nQuantidade        := jManufaturaRequisicao['quantidade']
Local cNumSeq            := ""
Local cUM                := ""
Local cDescricao         := ""
Local aTransf            := {}
Local cAliasSD4          := GetNextAlias()
Local aWmsCMov           := {}

    DbSelectArea("SD3")
    SD3->(DbSetOrder(1))
    
    DBSelectArea("SB1")
    SB1->(DbSetOrder(1))

    DBSelectArea("SB2")
    SB2->(DbSetOrder(1))

    DBSelectArea("NNR")
    NNR->(DbSetOrder(1))

    BeginSql Alias cAliasSD4
        SELECT DISTINCT SD4.D4_LOCAL
          FROM %Table:DBX% DBX
         INNER JOIN %Table:SD4% SD4
            ON SD4.D4_FILIAL  = %Exp:xFilial("SD4")%
           AND SD4.D4_COD     = DBX.DBX_COD
           AND SD4.D4_OP      = DBX.DBX_OP
           AND SD4.D4_TRT     = DBX.DBX_TRT
           AND SD4.%NotDel%
         WHERE DBX.DBX_FILIAL = %Exp:xFilial("DBX")%
           AND DBX.DBX_IDDBZ  = %Exp:self:idConvergencia%
           AND DBX.%NotDel%
	EndSql
    If (cAliasSD4)->(!Eof())
        cTipEstoqueDestino := (cAliasSD4)->D4_LOCAL
    EndIf
    (cAliasSD4)->(DbCloseArea())

    If cTipEstoqueOrigem == cTipEstoqueDestino
        self:convergencia:setMensagemIntegracao(STR0001) // "Nao permite alteracoes do mesmo tipo de estoque (origem e destino)"
        Return .F.
    EndIf

    If !SB1->(MsSeek(xFilial("SB1") + cProduto))
        self:convergencia:setMensagemIntegracao(STR0002+ AllTrim(cProduto) + STR0003) // "Produto "" nao encontrado na filial."
        Return .F.
    EndIf

    If !NNR->(MsSeek(xFilial("NNR") + cTipEstoqueOrigem))
        self:convergencia:setMensagemIntegracao(STR0004 + AllTrim(cTipEstoqueOrigem) + STR0005) // "Armazem "" nao encontrado na filial."
        Return .F.
    EndIf

    If !NNR->(MsSeek(xFilial("NNR") + cTipEstoqueDestino))
        self:convergencia:setMensagemIntegracao(STR0004 + AllTrim(cTipEstoqueDestino) + STR0005) // "Armazem "" nao encontrado na filial."
        Return .F.
    EndIf
    
    cDescricao := SB1->B1_DESC
    cUM        := SB1->B1_UM

    // Valida se produto esta cadastrado no armazem origem
    If !SB2->(DbSeek(xFilial("SB2") + cProduto + cTipEstoqueOrigem))
        CriaSB2(cProduto, cTipEstoqueOrigem, xFilial("SB2"))
    EndIf

    // Valida se produto esta cadastrado no armazem destino
    If !SB2->(DbSeek(xFilial("SB2") + cProduto + cTipEstoqueDestino))
        CriaSB2(cProduto, cTipEstoqueDestino, xFilial("SB2"))
    EndIf

    cNumSeq := SD3->(ProxNum())

    aAdd(aTransf, {cNumSeq, dDataBase})
    aAdd(aTransf,{})
    aAdd(aTransf[02],{"D3_COD"    , cProduto                           , Nil}) // [01] Produto origem
    aAdd(aTransf[02],{"D3_DESCRI" , cDescricao                         , Nil}) // [02] Descricao origem 
    aAdd(aTransf[02],{"D3_UM"     , cUM                                , Nil}) // [03] Unidade de medica origem
    aAdd(aTransf[02],{"D3_LOCAL"  , cTipEstoqueOrigem                  , Nil}) // [04] Armazem origem
    aAdd(aTransf[02],{"D3_LOCALIZ", CriaVar("D3_LOCALIZ")              , Nil}) // [05] Endereco origem
    aAdd(aTransf[02],{"D3_COD"    , cProduto                           , Nil}) // [06] Produto destino
    aAdd(aTransf[02],{"D3_DESCRI" , cDescricao                         , Nil}) // [07] Descricao origem
    aAdd(aTransf[02],{"D3_UM"     , cUM                                , Nil}) // [08] Unidade de medida destino
    aAdd(aTransf[02],{"D3_LOCAL"  , cTipEstoqueDestino                 , Nil}) // [09] Armazem destino
    aAdd(aTransf[02],{"D3_LOCALIZ", CriaVar("D3_LOCALIZ")              , Nil}) // [10] Endereco destino
    aAdd(aTransf[02],{"D3_NUMSERI", CriaVar("D3_NUMSERI")              , Nil}) // [11] Numero de serie
    aAdd(aTransf[02],{"D3_LOTECTL", cLote                              , Nil}) // [12] Lote
    aAdd(aTransf[02],{"D3_NUMLOTE", CriaVar("D3_NUMLOTE")              , Nil}) // [13] Sub-Lote
    aAdd(aTransf[02],{"D3_DTVALID", dDataValidade                      , Nil}) // [14] Data de validade
    aAdd(aTransf[02],{"D3_POTENCI", CriaVar("D3_POTENCI")              , Nil}) // [15] Potencia
    aAdd(aTransf[02],{"D3_QUANT"  , nQuantidade                        , Nil}) // [16] Quantidade
    aAdd(aTransf[02],{"D3_QTSEGUM", ConvUm(cProduto, nQuantidade, 0, 2), Nil}) // [17] Quantidade segunda unidade
    aAdd(aTransf[02],{"D3_ESTORNO", .F.                                , Nil}) // [18] Estorno
    aAdd(aTransf[02],{"D3_NUMSEQ" , CriaVar("D3_NUMSEQ")               , Nil}) // [19] Numero sequencial
    aAdd(aTransf[02],{"D3_LOTECTL", cLote                              , Nil}) // [20] Lote destino
    aAdd(aTransf[02],{"D3_DTVALID", dDataValidade                      , Nil}) // [21] Data de validade destino
    aAdd(aTransf[02],{"D3_SERVIC" , CriaVar("D3_SERVIC")               , Nil}) // [22] Servico
    aAdd(aTransf[02],{"D3_ITEMGRD", CriaVar("D3_ITEMGRD")              , Nil}) // [23]

    aAdd(aWmsCMov, {"CPROGRAMA", "WMSSAAS"})

    If !self:geraMovimentoTransferencia(aTransf, aWmsCMov)
        Return .F.
    EndIf
Return .T.

/*/{Protheus.doc} geraMovimenotransferencia
(aCab, aItens)
    @author user
    @since 23/09/2024
    @version version
    @param aCab, array, Cabecalho da movimentacao
    @param aItens, array, Itens para movimentacao
    @return lRet, logical, Indica se movimentacao foi realizada com sucesso
    /*/
Method geraMovimentoTransferencia(aTransf, aWmsCMov) Class WMSSaasManufaturaControleRequisicao
Local cPath    := GetSrvProfString("StartPath","")
Local cFile    := NomeAutoLog()
Local cMsgErro := ""

Private lMsHelpAuto  := .F.
Private lMsErroAuto  := .F.
Private lMsFinalAuto := .F.

    MSExecAuto({|x,y,z| MATA261(x,y,z)}, aTransf, 3, aWmsCMov)
    If lMsErroAuto
        cMsgErro := MostraErro(cPath,cFile)
        self:convergencia:setErroIntegracao(cMsgErro)
        Return .F.        
    EndIf
Return .T.

/*/{Protheus.doc} ajustesEmpenhoRequisicao
    @author Alexsander Burigo Correa
    @since 22/01/2025
    @version version 1.0
    @param jFinalizados, array, Reservas finalizadas
    @return return_var, return_type, return_description
    /*/
Method ajustesEmpenhoRequisicao(jManufaturaRequisicao) Class WMSSaasManufaturaControleRequisicao
Local lConsVenc        := GetMV('MV_LOTVENC')=='S'
Local lFinalizado      := jManufaturaRequisicao['atendimentoFinalizado']
Local lAtendido        := jManufaturaRequisicao['atendido']
Local cProduto         := jManufaturaRequisicao['produto']
Local lRastro          := Rastro(cProduto,"L")
Local cLote            := If(lRastro .And. !(jManufaturaRequisicao['lote']==NIL),jManufaturaRequisicao['lote'],Space(nTamLote))
Local dDataValidade    := If(lRastro,jManufaturaRequisicao['dataValidade'],CtoD('  /  /  '))
Local nQuantSeparada   := jManufaturaRequisicao['quantidade']
Local nQuantidade      := 0
Local cIdReserva       := jManufaturaRequisicao['idReserva']
Local cAliasAux        := GetNextAlias()
Local cAliasSD4        := Nil
Local cAliasDBX        := Nil
Local bCampo           := {|nCPO|	Field(nCPO)}
Local nQuantidade2UM   := ConvUM(cProduto, nQuantidade, 0, 2)
Local cStatus          := '2' /* 1=Gerado | 2=Concluido*/
Local nX               := 0
Local cOrigem          := 'S'
Local cNewReq          := ''     
Local oControleReq     := Nil

    Conout("INICIO | ajustesEmpenhoRequisicao | WMSSaasManufaturaControleRequisicao")
    BeginSql Alias cAliasAux
        SELECT DBX.R_E_C_N_O_ RECNODBX,
                SD4.R_E_C_N_O_ RECNOSD4,
                SD4.D4_COD,
                SD4.D4_OP,
                SD4.D4_TRT,
                SD4.D4_LOTECTL,
                SD4.D4_QUANT
          FROM %Table:DBX% DBX
         INNER JOIN %Table:SD4% SD4
            ON SD4.D4_FILIAL  = %Exp:xFilial("SD4")%
           AND SD4.D4_COD     = DBX.DBX_COD
           AND SD4.D4_OP      = DBX.DBX_OP
           AND SD4.D4_TRT     = DBX.DBX_TRT
           AND SD4.D4_LOTECTL = DBX.DBX_LOTECT
           AND SD4.%NotDel%
         WHERE DBX.DBX_FILIAL = %Exp:xFilial("DBX")%
           AND DBX.DBX_IDDBZ  = %Exp:self:idConvergencia%
           AND DBX.DBX_ORIGEM = %Exp:cOrigem%
           AND DBX.%NotDel%
    EndSql
    If (cAliasAux)->(!Eof())
        Conout("Encontrou registro para atualizacao | ajustesEmpenhoRequisicao | WMSSaasManufaturaControleRequisicao")    
        /* Quando controla rastro devera descontar a quantidade separada do empenho sem lote
           e quando encontrar o lote separado somar ou criar novo empenho para o lote separado */
        If nQuantSeparada > 0
            If (cAliasAux)->D4_QUANT > 0
                nQuantidade := nQuantSeparada
                If nQuantidade > (cAliasAux)->D4_QUANT
                    nQuantidade := (cAliasAux)->D4_QUANT
                EndIf
                If lRastro
                    Conout("Registro possui lote | ajustesEmpenhoRequisicao | WMSSaasManufaturaControleRequisicao")  
                    /* Busca o empenho com o lote infomado */
                    cAliasSD4 := GetNextAlias()
                    BeginSql Alias cAliasSD4
                        SELECT SD4.R_E_C_N_O_ RECNOSD4
                        FROM %Table:SD4% SD4
                        WHERE SD4.D4_FILIAL = %Exp:xFilial("SD4")%
                        AND SD4.D4_COD     = %Exp:(cAliasAux)->D4_COD%
                        AND SD4.D4_OP      = %Exp:(cAliasAux)->D4_OP%
                        AND SD4.D4_TRT     = %Exp:(cAliasAux)->D4_TRT%
                        AND SD4.D4_LOTECTL = %Exp:cLote%
                        AND SD4.%NotDel%
                    EndSql
                    If (cAliasSD4)->(!Eof())
                        SD4->(DbGoTo((cAliasSD4)->RECNOSD4))
                        
                        RecLock("SD4",.F.)
                        SD4->D4_QTDEORI += nQuantidade
                        SD4->D4_QUANT   += nQuantidade
                        SD4->(MsUnlock())
                        Conout("Encontrou SD4 com o lote preenchido | ajustesEmpenhoRequisicao | WMSSaasManufaturaControleRequisicao")  
                    Else
                        /* Posiciona no empenho para ajustar as quantidades no lote separado */
                        DbSelectArea("SD4")
                        SD4->(DbGoTo((cAliasAux)->RECNOSD4))

                        /* Salva a integridade dos campos de Bancos de Dados */
                        For nX := 1 To FCount()
                            M->&(EVAL(bCampo,nX)) := FieldGet(nX)
                        Next nX
                        /* Cria o registro de empenho com mesmos dados do original */
                        RecLock("SD4",.T.)
                        For nX	:=	1 To FCount()
                            FieldPut(nX,M->&(EVAL(bCampo,nX)))
                        Next nX
                        /* Atualiza com a quantidade e lote separada */
                        SD4->D4_LOTECTL := cLote
                        SD4->D4_DTVALID := dDataValidade
                        SD4->D4_QTDEORI := nQuantidade
                        SD4->D4_QUANT   := nQuantidade
                        SD4->(MsUnlock())
                        Conout("Atualizou SD4 com o lote informado | ajustesEmpenhoRequisicao | WMSSaasManufaturaControleRequisicao")
                    EndIf
                    (cAliasSD4)->(DbCloseArea())

                    /* Gera empenho para quantidade separada */
                    GravaEmp(   SD4->D4_COD,;       //-- 01.Codigo do Produto
                                SD4->D4_LOCAL,;     //-- 02.Local
                                nQuantidade,;       //-- 03.Quantidade
                                nQuantidade2UM,;    //-- 04.Quantidade
                                SD4->D4_LOTECTL,;   //-- 05.Lote
                                SD4->D4_NUMLOTE,;   //-- 06.SubLote
                                NIL,;               //-- 07.Localizacao
                                NIL,;               //-- 08.Numero de Serie
                                SD4->D4_OP,;        //-- 09.OP
                                SD4->D4_TRT,;       //-- 10.Seq. do Empenho/Liberacao do PV (Pedido de Venda)
                                NIL,;               //-- 11.PV
                                NIL,;               //-- 12.Item do PV
                                "SC2",;             //-- 13.Origem do Empenho
                                NIL,;               //-- 14.OP Original
                                SD4->D4_DATA,;      //-- 15.Data da Entrega do Empenho
                                NIL,;               //-- 16.Array para Travamento de arquivos
                                .F.,;               //-- 17.Estorna Empenho?
                                NIL,;               //-- 18.? chamada da Projeto de Estoques?
                                .F.,;               //-- 19.Empenha no SB2?
                                .F.,;               //-- 20.Grava SD4?
                                lConsVenc,;         //-- 21.Considera Lotes Vencidos?
                                .T.,;               //-- 22.Empenha no SB8/SBF?
                                .F.)                //-- 23.Cria SDC?
                    
                    /* Posiciona no empenho sem o lote informado para ajustar as quantidade, eliminando quando zerado */
                    SD4->(DbGoTo((cAliasAux)->RECNOSD4))
                    RecLock('SD4',.F.)

                    /* Cenarios
                    Intro: Caso a SD4 nao seja zerada, podera ser requisitada ao WMS SaaS novamente.
                           Quando aponta tudo no ERP e envia ao WMS SaaS, deixa saldo livre na volta. Nao passa por essas regras, apenas executa MATA261.

                    1-Finalizar separacao no app sem selecionar nada, nao alteraramos SD4, Mas deletamos DBX. SEM_ATENDIMENTO

                    2-Separacao completa no WMS SaaS da requisicao.
                        SD4 sera deletada, apenas se foi solicitada toda a quantidade origem.

                    3-Separacao parcial dentro do WMS SaaS (quantidade nao finalizada).
                        Devemos dimiuir SD4 apenas, nao deletar.

                    4-Separacao parcial dentro do WMS SaaS (quantidade finalizada)
                        Devemos dimiuir SD4. A SD4 sera deletada se atender toda a quantidade empenhada e D4_QTDEORI.

                    5-Apontar producao de saldo livre antes/apos enviar requisicao ao WMS SaaS. Ao retornar, devemos criar saldo livre e sem empenho.
                        Segue regra de separacao parcial ou completa. Mas atentar-se ao campo D4_QTDEORI. Este e a quantidade da OP original e controla exclusao da SD4.

                    6-No WMS SaaS, clicar em Selecionar estoque automaticamente.
                        03/04/2025 nao atendendo */

                    If SD4->D4_QUANT - nQuantidade >= 0
                        SD4->D4_QTDEORI -= nQuantidade
                        SD4->D4_QUANT   -= nQuantidade
                    EndIf                    
                       
                    If (SD4->D4_QUANT == 0 .And. SD4->D4_QTDEORI == SD4->D4_QUANT) 
                        SD4->(DBDelete())
                        Conout("SD4 deletada | ajustesEmpenhoRequisicao | WMSSaasManufaturaControleRequisicao")
                    EndIf
                    /*  Quando realizado o apontamento total ou parcial com pendencia de requisicao no WMS SaaS, de produto que controla lote sem o lote informado.
                        O sistema busca o lote empenhado e desconta a quantidade utilzada, havendo saldo a baixar, utiliza os saldos disponivel no estoque, porem nao 
                        grava as informacoes do lote utilizado na SD4, SD3. 
                        Dessa forma e necessario avaliar se a quantidade original e igual a quantidade utilizada para saber se a SD4 foi utilizada no apontamento total
                        ou parcial com pendencia de requisicao no WMS SaaS*/
                    SD4->(MsUnlock())
                    Conout("SD4 atualizada | ajustesEmpenhoRequisicao | WMSSaasManufaturaControleRequisicao")
                EndIf
            EndIf
            /*  Busca o empenho WMS SaaS que quando a origem for 'S' desconta a quantidade separa e 
                quando encotrar origem 'N' cria novo empenho WMS SaaS e grava identificador da reserva*/
            oControleReq := WMSSaasManufaturaControleRequisicao():loadByRecno((cAliasAux)->RECNODBX)
            cNewReq := oControleReq:getSequence()
            cOrigem := 'N'                

            DBSelectArea('DBX')
            DBX->(DbGoTo((cAliasAux)->RECNODBX))
            /* Salva a integridade dos campos de Bancos de Dados */
            For nX := 1 To FCount()
                M->&(EVAL(bCampo,nX)) := FieldGet(nX)
            Next nX

            /* Cria o registro de empenho com mesmos dados do original */
            DBSelectArea('DBX')
            RecLock("DBX",.T.)
            For nX	:=	1 To FCount()
                FieldPut(nX,M->&(EVAL(bCampo,nX)))
            Next nX

            /* Atualiza com a quantidade e lote separada */
            DBX->DBX_LOTECT := cLote
            DBX->DBX_DTVALD := dDataValidade
            DBX->DBX_QUANT  := nQuantSeparada
            DBX->DBX_ORIGEM := cOrigem
            DBX->DBX_SEQREQ := cNewReq
            DBX->DBX_IDRES  := cIdReserva
            DBX->(MsUnlock())
            Conout("DBX atualizada | ajustesEmpenhoRequisicao | WMSSaasManufaturaControleRequisicao")
        EndIf
        
        /* Posiciona no empenho WMS SaaS com origem igual 'S' para ajustar as quantidade, eliminando quando zerado */
        DBSelectArea('DBX')
        DBX->(DbGoTo((cAliasAux)->RECNODBX))
        RecLock('DBX',.F.)
        If !lFinalizado .And. DBX->DBX_QUANT - nQuantSeparada > 0
            DBX->DBX_QUANT -= nQuantSeparada
        Else
            If lAtendido
                DBX->(DBDelete())
                Conout("DBX deletada | ajustesEmpenhoRequisicao | WMSSaasManufaturaControleRequisicao")
            Else
                DBX->DBX_STATUS := EXCLUIDA
                Conout("DBX excluida | ajustesEmpenhoRequisicao | WMSSaasManufaturaControleRequisicao")                
            EndIf
        EndIf    
        DBX->(MsUnlock())

        /* Quando finalizado busca todos os empenhos WMS SaaS de origem igual 'N' e atualiza o status para '2' = Concluido*/
        If lFinalizado
            Conout("Atendimento finalizado | ajustesEmpenhoRequisicao | WMSSaasManufaturaControleRequisicao") 
            cOrigem   := 'N'
            cAliasDBX := GetNextAlias()
            BeginSql Alias cAliasDBX
                SELECT DBX.R_E_C_N_O_ RECNODBX
                  FROM %Table:DBX% DBX
                 WHERE DBX.DBX_FILIAL = %Exp:xFilial("DBX")%
                   AND DBX.DBX_COD    = %Exp:(cAliasAux)->D4_COD%
                   AND DBX.DBX_OP     = %Exp:(cAliasAux)->D4_OP%
                   AND DBX.DBX_TRT    = %Exp:(cAliasAux)->D4_TRT%
                   AND DBX.DBX_ORIGEM = %Exp:cOrigem%
                   AND DBX.%NotDel%
            EndSql
            While (cAliasDBX)->(!Eof())
                DBX->(DbGoTo((cAliasDBX)->RECNODBX))        
                
                RecLock("DBX",.F.)
                DBX->DBX_STATUS := cStatus
                DBX->(MsUnlock())
                
                (cAliasDBX)->(DbSkip())
                Conout("Status da DBX atualizado | ajustesEmpenhoRequisicao | WMSSaasManufaturaControleRequisicao") 
            EndDo
            (cAliasDBX)->(DbCloseArea())
        EndIf
    EndIf    
    (cAliasAux)->(DbCloseArea())
    Conout("FIM | ajustesEmpenhoRequisicao | WMSSaasManufaturaControleRequisicao")    
Return .T.
