#Include "Totvs.ch"
#include "tlpp-core.th"
#include "distribution.convergencia.ch"
#include "distribution.convergencia.pedido.venda.classe.ch"

#define DEVOLUCAO "D"
#define BENEFICIAMENTO "B"
#define CONTROLA_ESTOQUE "S" 
#define PRODUTO 5
#define LOTE 1
Static FINALIZADO_WMSSAAS := "05"
Static nTamCli      := TamSx3("C5_CLIENTE")[1]
Static nTamLoja     := TamSx3("C5_LOJACLI")[1]
Static nTamPed      := TamSx3("C5_NUM")[1]
Static nTamSeqInt   := TamSX3("DBZ_SEQINT")[1]
Static nTamC9Lote   := TamSX3("C9_LOTECTL")[1]
Static nTamC9EndPad := TamSX3("C9_ENDPAD")[1]
Static nTamC9Prod   := TamSX3("C9_PRODUTO")[1]


/*/{Protheus.doc} WMSSaasPedidoVenda
Classe de pedidoVenda Wms Saas
@type class
@author fagner.ferraz
@since 4/22/2024
/*/
Class WMSSaasPedidoVenda From WMSSaasConvergencia implements WMSSaasConvergenciaInterface
    Public Method new(cDoc as character, cSerie as character, cFornece as character, cLoja as character, dCriacao as date, dEmissao as date , cTransp as character, cChvNfe as character)
    Public Method loadByChave(cDoc as character, cCarga as character) as object
    Public Method loadByItem(pedido as character, produto as character, item as character, sequencia as character)
    Public Method canBeUpdated() as logical
    Public Method canBeFinished() as logical
    Public Method canBeCanceled() as logical
    Public Method setLiberado() as object
    Public Method setCancelado() as object
    Public Method setFinalizado() as object
    Public Method getSequence() as character
    Public Method finaliza(finaliza as array) as logical
    Public Method validaSeparacao(aSeparacaoProdutoLote as array)
    Public Method isItemEligibleToIntegration() as logical
    Static Method isItemInConvergencia(cPedido as character, cItem as character, cProduto as character, cSequencia as character)
    Public Method parseItemConvergencia(nRecnoSC9 as numeric) as logical
    Public Method saveNewSequences(aSequenciasCriadas as array)
    Public Method updateSequences(aSequenciasAlteradas as array)
    Public Method getNomePessoa() as character
    Public Method usaFornecedor() as logical
    Public Method getAllItems() as array
    Static Method getStatusFinalizadoWms() as character

EndClass

/*/{Protheus.doc} WMSSaasPedidoVenda::New
Carga das propriedades do cabeçalho da classe de convergência
@type method
@author fagner.ferraz
@since 4/22/2024
@param cDoc, character, Numero da nota 
@param cSerie, character, Serie da nota
@param cFornece, character, Fornecedor
@param cLoja, character, Loja
@param dCriacao, date, Data de digitação
@param dEmissao, date, Data de emissão
@param cTransp, character, Transportador
@param cChvNfe, character, Chave da nota
/*/
Method New(cDoc, cFornece, cLoja, dCriacao, dEmissao, cTransp, cCarga) Class WMSSaasPedidoVenda
    self:status              := self:getStatusCriado()
    self:tipoTransacao       := self:getTipoTransacaoPedidoVenda()
    self:numeroDocumento     := cDoc
    self:clienteOuFornecedor := cFornece
    self:loja                := cLoja
    self:dataCriacao         := FwTimeStamp(3,dCriacao, Time())
    self:dataEmissao         := dEmissao
    self:transportador       := cTransp
    self:sequenciaIntegracao := ""
    self:mensagemIntegracao  := ""
    self:carga               := cCarga
    self:itensConvergencia   := {}
Return self


/*/{Protheus.doc} parseItemConvergencia
    (Converte SC9 liberada em objeto ItemConvergencia )
    @author user
    @since 16/05/2024
    @version version
    @param nRecnoSC9, numeric, recno do registro liberado
    @return lRet, logical, sucesso na conversao
    /*/
Method parseItemConvergencia(nRecnoSC9) Class WMSSaasPedidoVenda as logical
Local aArea  := GetArea() 
Local lRet   := .F.

    If self:isItemEligibleToIntegration(nRecnoSC9)
        AAdd(self:itensConvergencia, WMSSaasItemPedidoVenda():set(;
            SC9->C9_PRODUTO,;
            SC9->C9_ITEM,;
            SC9->C9_SEQUEN,;
            SC9->C9_QTDLIB,;
            SC9->C9_PRCVEN,;
            SC9->C9_LOCAL,;
            SC9->C9_LOTECTL,;
            IIf(!Empty(SC9->C9_LOTECTL),SC9->C9_DTVALID,);
            ))
        lRet := .T.
    EndIf

    RestArea(aArea)
Return lRet

/*/{Protheus.doc} loadByChave
    Faz o load da classe de pedidoVenda e convergencia pela chave
    Esse metodo deve retornar apenas um registro da DBZ sempre, pois cada pedido de venda só pode ter uma sequencia em branco não integrada.
    @author Filipe Mendes
    @since 26/04/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method loadByChave(cDoc, cCarga) Class WMSSaasPedidoVenda
Local cAliasDBZ := GetNextAlias()
Default cCarga  := " "
    BeginSql Alias cAliasDBZ
		SELECT DBZ.DBZ_ID IDCONVERGENCIA
		  FROM %Table:DBZ% DBZ
		 WHERE DBZ.DBZ_FILIAL = %Exp:xFilial("DBZ")%
		   AND DBZ.DBZ_TIPOTR = %Exp:self:getTipoTransacaoPedidoVenda()%
		   AND DBZ.DBZ_NUMDOC = %Exp:cDoc%
           AND DBZ.DBZ_CARGA  = %Exp:cCarga%
           AND DBZ.DBZ_SEQINT = ' '
		   AND DBZ.%NotDel%
	EndSql

    If (cAliasDBZ)->(!Eof())
        self:loadById((cAliasDBZ)->IDCONVERGENCIA)
    EndIf
    (cAliasDBZ)->(DbCloseArea())
Return self

/*/{Protheus.doc} loadByItem
    Busca o item da convergência
    @author user
    @since 26/04/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
/*/
Method loadByItem(pedido as character, produto as character, item as character, sequencia as character) Class WMSSaasPedidoVenda
Local cId := WMSSaasItemPedidoVenda():getIdByItem(pedido, produto, item, sequencia)

    If !Empty(cId)
        self:loadById(cId)
    Else
        return self:new()
    EndIf

Return self

/*/{Protheus.doc} canBeUpdated
    Retorna status nos quais os documentos de entrada podem ser alterados
    @author user
    @since 26/04/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
/*/
Method canBeUpdated() as logical Class WMSSaasPedidoVenda
Return self:isCriado() .Or. self:isCancelado() .Or. self:isErroIntegracao()


/*/{Protheus.doc} canBeFinished
    Retorna se pedido de venda por ser separado
    @author user
    @since 17/10/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method canBeFinished() as logical Class WMSSaasPedidoVenda
Return self:isIntegrado() .Or. self:isCancelado() .Or. self:isErroIntegracao()


/*/{Protheus.doc} canBeCanceled
    Retorna se o registro pode ser cancelado
    @author user
    @since 26/04/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method canBeCanceled() as logical Class WMSSaasPedidoVenda
Local lRet := .F.
    If !self:isCancelado() .And. (self:isFinalizado() .Or. self:isIntegrado()) .And. !WMSSaaSPedidoFaturado(self:id)
        lRet := .T.
    EndIf

Return lRet


/*/{Protheus.doc} setLiberado
    (long_description)
    @author user
    @since 15/04/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description 
    /*/
Method setLiberado() Class WMSSaasPedidoVenda
    Begin Transaction
        If WMSSaasSeekDBZById(self:id) .And. RecLock("DBZ", .F.)
            DBZ->DBZ_STATUS := self:getStatusLiberado()
            DBZ->DBZ_SEQINT := self:getSequence()
            DBZ->(MsUnlock())
            
            //Bloqueia itens na SC9 para faturamento
            aEval(self:itensConvergencia, {|item| item:blockItem(self:numeroDocumento, item:item, item:sequencia, item:produto)})

            //Na liberacao, remove empenhos SC9 e SB8 para o item DBY
            aEval(self:itensConvergencia, {|item| item:removeEmpenhos(self:id, self:numeroDocumento, item:item, item:produto, item:sequencia)})
            
            //Atualiza status da carga para integrado
            WMSSaasCargaPedidoVenda():atualizaCargaParaIntegrado(self:carga)

            self:load()
        EndIf
    End Transaction
Return self

/*/{Protheus.doc} setCancelado
    (long_description)
    @author user
    @since 15/04/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method setCancelado() Class WMSSaasPedidoVenda
    Local lContinua := .T.

    Begin Transaction
        If WMSSaasSeekDBZById(self:id) .And. RecLock("DBZ", .F.)
      
            If self:isCancelado()
                lContinua := .F.
                self:setMensagemIntegracao(STR0005) //"A separação já está cancelada no ERP." 
            ElseIf !self:canBeCanceled()
                self:setMensagemIntegracao(STR0006) //"A separação não pode ser cancelada no ERP. Verifique o status da integração e se existe faturamento para este item.")
                lContinua := .F.         
            EndIf

            If lContinua
                DBZ->DBZ_STATUS := self:getStatusCancelado()
                DBZ->(MsUnlock())

                //Nao faremos desbloqueio da SC9 em caso de cancelamento de separacao no WMS SaaS.
                //Isto impede falhas no processo de faturamento antecipado. Sera tratado se solicitado.

                //Atualiza status da carga para cancelado
                WMSSaasCargaPedidoVenda():atualizaCargaParaCancelado(self:carga)
                        
                self:load()
            EndIf
        EndIf
    End Transaction

Return self

/*/{Protheus.doc} setFinalizado
    (long_description)
    @author user
    @since 15/04/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method setFinalizado() Class WMSSaasPedidoVenda
    If WMSSaasSeekDBZById(self:id) .And. RecLock("DBZ", .F.)
        DBZ->DBZ_STATUS := self:getStatusFinalizado()
        DBZ->(MsUnlock())

        //Atualiza status da carga para finalizado
        WMSSaasCargaPedidoVenda():atualizaCargaParaFinalizado(self:carga)

        self:load()
    EndIf
Return self

/*/{Protheus.doc} getSequence
    (long_description)
    @author user
    @since 15/07/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method getSequence() Class WMSSaasPedidoVenda
Local cAliasDBZ as character
Local cNewSeq as character

    If !Empty(self:sequenciaIntegracao)
        return self:sequenciaIntegracao
    EndIf

    cAliasDBZ := GetNextAlias()
    BeginSql Alias cAliasDBZ
		SELECT MAX(DBZ.DBZ_SEQINT) MAXSEQINT
		  FROM %Table:DBZ% DBZ
		 WHERE DBZ.DBZ_FILIAL = %Exp:xFilial("DBZ")%
		   AND DBZ.DBZ_TIPOTR = %Exp:self:getTipoTransacaoPedidoVenda()%
		   AND DBZ.DBZ_NUMDOC = %Exp:self:numeroDocumento%
           AND DBZ.DBZ_SEQINT <> ' '
		   AND DBZ.%NotDel%
	EndSql

    
	cNewSeq := Iif(!Empty((cAliasDBZ)->MAXSEQINT), Soma1(PadL((cAliasDBZ)->MAXSEQINT, nTamSeqInt, "0" )), Soma1(PadL("0",nTamSeqInt,"0")))

    (cAliasDBZ)->(DbCloseArea())

Return cNewSeq

/*/{Protheus.doc} finaliza
    Metodo de finalizacao do documento de entrada
    @author user
    @since 26/04/2024
    @version version
    @param aFinalizados, array, array de json com finalizados
    {
         "produto": aProdutos[item]['produto']['codigo'],
         "item": aReservas[reserva]['sequencia'],
         "sequencia": aReservas[reserva]['sequencia'],
         "tipoEstoque": aReservas[reserva]['tipoEstoque'],
         "quantidade": aReservas[reserva]['quantidade'],
         "lote": aReservas[reserva]['caracteristicas']['lote'],
         "dataValidade": aReservas[reserva]['caracteristicas']['dataValidade']
      }
    @return return_var, return_type, return_description
/*/
Method finaliza(aFinalizados) Class WMSSaasPedidoVenda as logical
Local itemFinalizado
Local item
Local aRetorno               := {}
Local aSequenciasFinalizadas := {}
Local aSequenciasCriadas     := {}
Local aSequenciasAlteradas   := {}
Local aRetPE                 := {}
Local lWMSFIMPV              := ExistBlock("WMSFIMPV")

    Conout("INICIO | FINALIZA-CLASSE PEDIDO VENDA")
    
    If lWMSFIMPV
         aRetPE := ExecBlock("WMSFIMPV",.F.,.F.,{aFinalizados, ::Self})
         If ValType(aRetPE[1]) == "L"
            If !aRetPE[1]
                self:setMensagemIntegracao(aRetPE[2])
                return .F.
            EndIf
        Else
            self:setMensagemIntegracao(STR0007) //"Erro no retorno do ponto de entrada WMSFIMPV."
            return .F.
        EndIf
    EndIf

    For itemFinalizado := 1 to Len(aFinalizados)
        // Filtra apenas as sequencias relacionadas ao produto.
        aSequenciasFinalizadas := WMSSaasMap(WMSSFilter(aFinalizados,  {|x| x['produto'] == aFinalizados[itemFinalizado]['produto'] .And. x['item'] == aFinalizados[itemFinalizado]['item'] }),  {|x| x['sequencia'] })

        // Se sequencias foram criadas durante o processamento, adiciona na busca
        If !Empty(aSequenciasCriadas)
            // Filtra a sequencia criada para o produto em questão
            WMSSaasMap(WMSSFilter(aSequenciasCriadas,  {|x| x['produto'] == aFinalizados[itemFinalizado]['produto'] .And. x['item'] == aFinalizados[itemFinalizado]['item'] }),  {|x| aAdd(@aSequenciasFinalizadas,x['sequencia']) })
        EndIf

        Conout("CHAMADA WMSaasFinishPedidoVenda | FINALIZA-CLASSE PEDIDO VENDA")
        If !(aRetorno := WMSaasFinishPedidoVenda(self:numeroDocumento,;
                                aFinalizados[itemFinalizado]['item'],;
                                aSequenciasFinalizadas,;
                                aFinalizados[itemFinalizado]['produto'],;
                                aFinalizados[itemFinalizado]['lote'],;
                                "",; // Tratar sublote?
                                aFinalizados[itemFinalizado]['quantidade'],;
                                aFinalizados[itemFinalizado]['tipoEstoque'];
                            ))[1]
            Conout("RETORNO COM ERRO WMSaasFinishPedidoVenda | FINALIZA-CLASSE PEDIDO VENDA")                
            self:setMensagemIntegracao(aRetorno[2])
            return .F.
        EndIf

        // Adiciona as sequencias criadas no array
        WMSSaasMap(aRetorno[3], {|x| aAdd(@aSequenciasCriadas, x) })
        WMSSaasMap(aRetorno[4], {|x| aAdd(@aSequenciasAlteradas, x) })
    Next itemFinalizado
    
    // faz a deleção dos itens não finalizados
    aEval(self:itensConvergencia, {|item|, item:checkItemDelete(self:numeroDocumento, aSequenciasCriadas) }) 
    
    // Salva as novas sequencias finalizadas
    self:saveNewSequences(aSequenciasCriadas)

    // Atualiza DBY com novas quantidades, lotes e data de validade
    self:updateSequences(aSequenciasAlteradas)

    Conout("FiNALIZA CONVERGENCIA | setMensagemIntegracao: " + cValToChar(aRetorno[2]))
    self:setMensagemIntegracao(aRetorno[2])
    self:setFinalizado()
    Conout("FIM | FINALIZA-CLASSE PEDIDO VENDA")
Return .T.

/*/{Protheus.doc} saveNewSequences
    (long_description)
    @author Filipe Mendes
    @since 25/07/2024
    @version version
    @param aSequenciasCriadas, array, array de sequencias criadas
    @return
    /*/
Method saveNewSequences(aSequenciasCriadas) Class WMSSaasPedidoVenda
Local aArea     := GetArea()
Local sequencia := 0

    DbSelectArea("SC9")
    SC9->(DbSetOrder(1))
    For sequencia := 1 to Len(aSequenciasCriadas)
        // Se achar na SC9 e não estiver nos itens da convergência
        If SC9->(DbSeek(xFilial("SC9")+WMSSaasPadRToField(self:numeroDocumento,"C9_PEDIDO")+WMSSaasPadRToField(aSequenciasCriadas[sequencia]['item'],"C9_ITEM")+WMSSaasPadRToField(aSequenciasCriadas[sequencia]['sequencia'],"C9_SEQUEN"))) .And.; 
                !self:IsItemInConvergencia(self:numeroDocumento, aSequenciasCriadas[sequencia]['item'], aSequenciasCriadas[sequencia]['produto'], aSequenciasCriadas[sequencia]['sequencia'] )
                /*salva novo item na DBY*/
                AAdd(self:itensConvergencia, WMSSaasItemPedidoVenda():set(;
                    SC9->C9_PRODUTO,;
                    SC9->C9_ITEM,;
                    SC9->C9_SEQUEN,;
                    SC9->C9_QTDLIB,;
                    SC9->C9_PRCVEN,;
                    SC9->C9_LOCAL,;
                    SC9->C9_LOTECTL,;
                    IIf(!Empty(SC9->C9_LOTECTL),SC9->C9_DTVALID,);
                ))
                self:itensConvergencia[Len(self:itensConvergencia)]:save(self:id)
        EndIf
    Next sequencia

    RestArea(aArea)
Return

/*/{Protheus.doc} updateSequences
    (Atualiza DBY com as novas quantidades, lotes e data de validade definidas na separacao)
    @author Equipe WMS
    @since 25/07/2024
    @version version
    @param aSequenciasAlteradas, array, array de sequencias alteradas
    @return
    /*/
Method updateSequences(aSequenciasAlteradas) Class WMSSaasPedidoVenda
Local aArea             := GetArea()
Local nSequencia        := 0
Local oItemConvergencia := Nil

    Conout("INICIO UPDATE SEQUENCIAS ALTERADAS SC9 - CONVERGENCIA |updateSequences")
    For nSequencia := 1 to Len(aSequenciasAlteradas)
        oItemConvergencia := WMSSaasItemPedidoVenda():loadByItemProdutoSequencia( self:numeroDocumento,WMSSaasPadRToField(aSequenciasAlteradas[nSequencia]['item'],"C9_ITEM"),;
                WMSSaasPadRToField(aSequenciasAlteradas[nSequencia]['produto'],"C9_PRODUTO"),WMSSaasPadRToField(aSequenciasAlteradas[nSequencia]['sequencia'],"C9_SEQUEN"))
        Conout("UPDATE SEQUENCIAS ALTERADAS SC9 - CONVERGENCIA oItemConvergencia:id: " + oItemConvergencia:id)
        If AllTrim(oItemConvergencia:id) == Alltrim(self:id)
            oItemConvergencia:quantidade    := aSequenciasAlteradas[nSequencia]['quantidade']
            oItemConvergencia:lote          := aSequenciasAlteradas[nSequencia]['lote']
            oItemConvergencia:dataValidade  := aSequenciasAlteradas[nSequencia]['dataValidade']
        
            oItemConvergencia:save(self:id)
        EndIf
    Next nSequencia

    RestArea(aArea)
Return

/*/{Protheus.doc} isItemEligibleToIntegration
    Verifica se item do pedidoVenda é elegivel para ser integrado ao Saas.
    @author user
    @since 07/05/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method isItemEligibleToIntegration(nRecno) Class WMSSaasPedidoVenda as logical
Local aAreaSC9 := SC9->(GetArea())
Local aAreaSC6 := SC6->(GetArea())
Local lRet     := .T.
    
    DbSelectArea("SC9")
    SC9->(DbGoTo(nRecno))

    SC6->(DbSetOrder(1))
    SC6->(DbSeek(xFilial("SC6")+SC9->C9_PEDIDO+SC9->C9_ITEM+SC9->C9_PRODUTO))

    // -- Se item não controla WMS SaaS, não deve ser enviado
    If !WMSSaasInt(SC9->C9_PRODUTO, SC9->C9_LOCAL)
        lRet := .F.
    EndIf
    
    If lRet .And. (SC9->C9_BLEST <> '  ' .Or. SC9->C9_BLCRED <> '  ')
        lRet := .F.
    EndIf
    
    // -- Se TES está preenchida e não controla estoque, não deve ser enviado
    If lRet .And. Alltrim(GetAdvFVal("SF4","F4_ESTOQUE",xFilial("SF4")+SC6->C6_TES,1)) != CONTROLA_ESTOQUE
        lRet := .F.
    EndIf

    RestArea(aAreaSC9)
    RestArea(aAreaSC6)
Return lRet

/*/{Protheus.doc} IsItemInConvergencia
    Valida se item já está na tabela de convergencia
    @author user
    @since 14/05/2024
    @param param_name, param_type, param_descr
    @return lRet, logico, item na tabela de convergencia
    /*/
Method IsItemInConvergencia(cPedido as character, cItem as character, cProduto as character, cSequencia as character) Class WMSSaasPedidoVenda
Local lRet := .T.
Local oWMSSaasItemPedidoVenda := WMSSaasItemPedidoVenda():loadByItemProdutoSequencia( cPedido,cItem,cProduto,cSequencia)
    If Empty(oWMSSaasItemPedidoVenda:id)
        lRet := .F.
    EndIf
    FwFreeObj(oWMSSaasItemPedidoVenda)
Return lRet

/*/{Protheus.doc} getNomePessoa
    (long_description)
    @author user
    @since 24/05/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method getNomePessoa() Class WMSSaasPedidoVenda as character
Local jCliente := WMSSaasClienteAdapter():montaPayload(Padr(self:clienteOuFornecedor,nTamCli), Padr(self:loja,nTamLoja), self:usaFornecedor())
Return jCliente['nome']

/*/{Protheus.doc} usaFornecedor
    (long_description)
    @author user
    @since 24/05/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method usaFornecedor() Class WMSSaasPedidoVenda as logical
Return GetAdvFVal("SC5",; 
                    "C5_TIPO",;
                    xFilial("SC5")+;
                    Padr(self:numeroDocumento,nTamPed),;
                    1, "") $ BENEFICIAMENTO+"/"+DEVOLUCAO

/*/{Protheus.doc} getAllItems
    (long_description)
    @author user
    @since 25/04/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method getAllItems() Class WMSSaasPedidoVenda as array
Return WMSSaasItemPedidoVenda():loadAllByParentId(self:id)

/*/{Protheus.doc} getStatusFinalizadoWms
    (long_description)
    @author user
    @since 23/09/2024
    @version version
    @param param_name, param_type, param_descr
    @return cStatus, character, status de finalizado WMS SaaS Sc9
    /*/
Method getStatusFinalizadoWms() Class WMSSaasPedidoVenda as character
Return FINALIZADO_WMSSAAS


/*/{Protheus.doc} validaSeparacao
    (Valida se o pedido pode ser separado e enviado para o ERP)
    @author Equipe WMS
    @since 09/10/2024
    @param jSeparacaoProdutoLote, json, produtos e lotes agrupados
    {;
                        "produto"        : AllTrim(aProdutos[item]['produto']['codigo']),;
                        "lote"           : AllTrim(jLote['valor']),;
                        "quantidade"     : aReservas[reserva]['quantidade'],;
                        "tipoEstoque"    : AllTrim(aReservas[reserva]['tipoEstoque'])}
    @param cIdDBZ, character, id DBZ
    @param cMsg, character, mensagem que pode ser retornada para o SaaS
    @return lRet, numeric, pedido foi faturado
    /*/
Method validaSeparacao(aSeparacaoProdutoLote as array) Class WMSSaasPedidoVenda
Local nQtdEmpLoteC9 := 0
Local nQtdSeparada  := 0
Local cLocalEstoque := ""
Local nValorSegUnid := 0
Local lUsaVenc      := SuperGetMv('MV_LOTVENC')=='S'
Local cProduto      := ""
Local item          := 0
Local cAliasSC9
Local cLoteCtl      := ""
Local cIdDBZ        := self:id
    
	For item := 1 to Len(aSeparacaoProdutoLote)
		nQtdSeparada := 0
		cProduto := PadR(aSeparacaoProdutoLote[item]['produto'],nTamC9Prod)
		cLoteCtl := PadR(aSeparacaoProdutoLote[item]['lote'],nTamC9Lote)   
		If Rastro(cProduto,"L") 

			cAliasSC9 := GetNextAlias()

			BeginSql Alias cAliasSC9
				SELECT CASE 
					WHEN 
						Sum(SC9.C9_QTDLIB) IS NULL THEN 0
					ELSE
						Sum(SC9.C9_QTDLIB) END
					AS QTDEMPC9LOTE
				  FROM %Table:SC9% SC9
				 INNER JOIN %Table:DBZ% DBZ
					ON (DBZ.%NotDel%
				   AND DBZ.DBZ_FILIAL = %xFilial:DBZ%
				   AND DBZ.DBZ_NUMDOC = SC9.C9_PEDIDO
				   AND DBZ.DBZ_ID = %Exp:cIdDBZ%)
				 INNER JOIN %Table:DBY% DBY 
					ON (DBY.DBY_FILIAL = %xFilial:DBY%
				   AND DBY.DBY_ITEM = SC9.C9_ITEM
				   AND DBY.DBY_SEQUEN = SC9.C9_SEQUEN
				   AND DBY.DBY_PRODUT = SC9.C9_PRODUTO 
				   AND DBZ.DBZ_ID = DBY.DBY_ID)
				 WHERE DBY.%NotDel%
				   AND SC9.C9_PRODUTO = %Exp:cProduto%
				   AND (SC9.C9_LOTECTL <> %Exp:Space(nTamC9Lote)% AND SC9.C9_LOTECTL = %Exp:cLoteCtl%)
				   AND SC9.C9_FILIAL  = %xFilial:SC9% 
				   AND SC9.%NotDel%
			EndSql
			If (cAliasSC9)->(!Eof())
				nQtdEmpLoteC9 := (cAliasSC9)->QTDEMPC9LOTE
			EndIf
			(cAliasSC9)->(DbCloseArea())

			nQtdSeparada  := aSeparacaoProdutoLote[item]['quantidade']
			cLocalEstoque := aSeparacaoProdutoLote[item]['tipoEstoque']
			nValorSegUnid := ConvUM(cProduto, nQtdSeparada, 0, 2)

			aSaldos := SldPorLote(cProduto,cLocalEstoque,nQtdSeparada,nValorSegUnid,cLoteCtl,NIL,NIL,NIL,NIL,.F.,NIL,lUsaVenc,nil,nil,dDataBase)
            //Se nao existir saldos por lote retorna ERRO
			If !Empty(aSaldos) .And. aSaldos[LOTE][PRODUTO] > 0
				If (aSaldos[LOTE][PRODUTO] + nQtdEmpLoteC9) < nQtdSeparada
					self:setMensagemIntegracao(STR0001 + STR0002 + AllTrim(cProduto)+ STR0003 +AllTrim(cLoteCtl)+ STR0004) //"Não foi possivel confirmar a separação! ""Não existe saldo para o produto "" e lote "
					Return .F. 
				EndIf
			Else
				If nQtdEmpLoteC9 < nQtdSeparada
					self:setMensagemIntegracao(STR0001 + STR0002 + AllTrim(cProduto)+ STR0003 +AllTrim(cLoteCtl)+ STR0004) //"Não foi possivel confirmar a separação! ""Não existe saldo para o produto "" e lote "" no ERP."
					Return .F.
				EndIf
			EndIf
		EndIf
	Next item
Return .T.
