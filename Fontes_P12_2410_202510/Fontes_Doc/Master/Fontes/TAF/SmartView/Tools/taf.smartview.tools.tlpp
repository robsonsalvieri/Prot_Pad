#include "totvs.ch"
#include "msobject.ch"
#include "totvs.framework.treports.integratedprovider.th"
#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "taf.smartview.tools.ch"

namespace totvs.protheus.fiscal.taf.treportsintegratedprovider

//-------------------------------------------------------------------
/*{Protheus.doc}  tafSmartviewTools
    Classe de funções genéricas usadas pela Squad Taf Fiscal no Smartview - Projeto Júpiter

    @author Denis Souza
    @since 10/11/2023
*/
//-------------------------------------------------------------------  
class tafSmartviewTools
    public method new() constructor
    public method Paginacao(nPages)
    public method validPerg(lValid)
    public method montaFilial(cFilDe,cFilAte)
    private method existFil(cFilSis,nPos)
    public method validFil(lValid)
    private method checkFil()
    private method mountFilter()
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} New()
    Método construtor da classe
    @author Denis Souza
    @since 25.10.2023
/*/
//-------------------------------------------------------------------
method new() class tafSmartviewTools
return self

//-------------------------------------------------------------------
/*/{Protheus.doc} validPerg
    Mensagem de erro caso o SX1 não seja encontrado (Smartview)
	@author Juliana Mellão
	@since 12/06/2024
    @param lExistPerg, indica se a pergunta foi posicionada corretamente
/*/
//-------------------------------------------------------------------
Method validPerg(lExistPerg) CLASS tafSmartviewTools

    Local laux as logical

    if GetGlbVars("lValSX1", laux) .OR. !lExistPerg  
        FwLogMsg(STR0001,, STR0002,,, , STR0003, , ,)
    endif

Return 

//-------------------------------------------------------------------
/*/{Protheus.doc} Paginacao
    Passa a quantidade de linhas que serão utilizadas para a paginação do objeto (Smartview)
    @author Denis Souza
    @since 26/10/2023
    @since 10/11/2023
    @param nPages (quantidade de linhas atualmente utilizadas para a paginação do objeto)
    @return nPages (nova quantidade de linhas que serão utilizadas para a paginação do objeto)
/*/
//-------------------------------------------------------------------
method paginacao(nPages) Class tafSmartviewTools
    local nAutPages as numeric
    if GetGlbVars("nPages",nAutPages) //so entra no if se a variavel global existir
        nPages := nAutPages
    endif
return nPages

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} montaFilial
    Validação das filiais informadas pelo usuário nos parâmetros do objeto de negócios
	@author Juliana Mellão
	@since 12/06/2024
    @version 1
    @param cFilDe, cFilAte, range de filiais De/Ate informado nos parâmetros
    @return cReturn, retorna todas as filiais que serão usadas na query do objeto de negócios. Também retorna erro.
/*/
//----------------------------------------------------------------------------------------------------------------------
Method montaFilial(cFilDe,cFilAte, aFiliais as array) Class tafSmartviewTools
    Local cReturn as Character
    Local aSM0Data := FWLoadSM0()
    Local nPosDe as numeric
    Local nPosAte as numeric
    
    Default aFiliais := {} 

    cFilDe := padr(cFilDe,len(aSM0Data[1][2]))
    cFilAte:= padr(cFilAte,len(aSM0Data[1][2]))
    aSort(aSM0Data,,,{|x,y| x[1]+x[2] < y[1]+y[2]})


    if self:checkFil(@cFilDe, @cFilAte, @nPosDe, @nPosAte, aSM0Data)
       cReturn := self:mountFilter(cFilDe, cFilAte, nPosDe, nPosAte, aSM0Data, @aFiliais)
    else
        cReturn := 'Erro'
    endif

Return cReturn

//-----------------------------------------------------------------------------------------------
/*/{Protheus.doc} validFil
    Mensagem de erro caso o SX1 seja preenchido de forma errada pelo usuário (Smartview)
	@author Juliana Mellão
	@since 12/06/2024
    @param lValid, retorna msg de erro caso o método montaFilial retorne erro
/*/
//-------------------------------------------------------------------
Method validFil(lValid) CLASS tafSmartviewTools
	if !lValid      //zzz a branco cai aqui
        FwLogMsg(STR0001,, STR0002,,, , STR0004, , ,)
        lRet := .f.
    endif
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} existFil
    Valida se a filial De existe
	@author Juliana Mellão
	@since 12/06/2024
    @param 
/*/
//-------------------------------------------------------------------

Method existFil(cFilSis, nPos, aSM0Data) CLASS tafSmartviewTools

Local lOk as logical

lOk := .T.

//valida filial de
    nPos := AScan(aSM0Data, {|x| x[1]==cempant .and. AllTrim(x[2])==AllTrim(cFilSis)})
    if nPos == 0
        lOk := .F. 
    endif

Return lOk

//-------------------------------------------------------------------
/*/{Protheus.doc} checkFil
    Valida se a filial De e Até é uma filial valida
	@author Juliana Mellão
	@since 12/06/2024
    @param 
/*/
//-------------------------------------------------------------------

Method checkFil(cFilDe, cFilAte, nPosDe, nPosAte, aSM0Data) CLASS tafSmartviewTools

Local lOk := .T. as logical
    
if !Empty(cFilDe)
    lOK := self:existFil(cFilDe, @nPosDe, aSM0Data)
endIf

//valida filial até
    if lOk .and. !EMPTY(cFilAte)
        if 'ZZZ' $ UPPER(cFilAte)
            nPosAte := 999
        else
            lOk :=  self:existFil(cFilAte, @nPosAte, aSM0Data)
        endif
    else
        lOk := .F. 
    endif

    if lOk .and. nPosDe > nPosAte
        cReturn := 'Erro'
        lOk := .F.        
    endif

Return lOk

//-------------------------------------------------------------------
/*/{Protheus.doc} mountFilter
    Monta a string com as filiais selecionadas (caso existam)
	@author Juliana Mellão
	@since 12/06/2024
    @param
/*/
//-------------------------------------------------------------------

Method mountFilter(cFilDe, cFilAte, nPosDe, nPosAte, aSM0Data, aFiliais) CLASS tafSmartviewTools
    
Local lFirst := .t. as logical
Local n as numeric
Local cReturn as character

    if nPosDe == 0
        nPosDe := 1
    endif

    for n := nPosDe to len(aSM0Data)
        if lFirst .and. aSM0Data[n][1] == cempant .and. aSM0Data[n][2] <> cFilAte 
            cReturn += "'" + aSM0Data[n][2] + "'"
            lFirst := .f.
            Aadd(aFiliais,aSM0Data[n][2])
        elseif !lFirst .and. aSM0Data[n][1] == cempant .and. aSM0Data[n][2] <> cFilAte 
            cReturn += ",'" + aSM0Data[n][2] + "'"
            Aadd(aFiliais,aSM0Data[n][2])
        endif
        if lFirst .and. aSM0Data[n][1] == cempant .and. aSM0Data[n][2] == cFilAte 
            cReturn += "'" + aSM0Data[n][2] + "'"
            Aadd(aFiliais,aSM0Data[n][2])
            exit
        elseif !lFirst .and. aSM0Data[n][1] == cempant .and. aSM0Data[n][2] == cFilAte
            cReturn += ",'" + aSM0Data[n][2] + "'"
            Aadd(aFiliais,aSM0Data[n][2])
            exit
        endif
    next

Return cReturn
