#INCLUDE "TLPP-CORE.TH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWLIBVERSION.CH"

#DEFINE DOCUMENTOS_FISCAIS							"invoice"
#DEFINE INFORMACOES_COMPLEMENTARES					"complementaryInformationByTaxDocument"
#DEFINE ITENS 										"fiscalDocumentItems"
#DEFINE LANCAMENTOS_FISCAIS							"otherTaxObligationsAdjustmentsAndInformation"
#DEFINE PROCESSOS_REFERENCIADOS						"indicativeOfSuspensionByJudicialProcess"
#DEFINE SERVICO_TRANSPORTE							"transportComplement"
#DEFINE TRIBUTOS 									"valuesByTaxPerItem"
#DEFINE VALORES_TRIBUTO								"valuesByTax"
#DEFINE FLUSH_DATA_LIMIT 							501

Static __jFields  := Nil as json
Static __jIndexes := Nil as json
Static __jBulks   := Nil as json
Static __oError   := Nil as object
static _nTmINDOPE := GetSx3Cache( 'C20_INDOPE','X3_TAMANHO')
static _nTmCODMOD := GetSx3Cache( 'C20_CODMOD','X3_TAMANHO')
static _nTmSERIE  := GetSx3Cache( 'C20_SERIE' ,'X3_TAMANHO')
static _nTmSUBSER := GetSx3Cache( 'C20_SUBSER','X3_TAMANHO')
static _nTmNUMDOC := GetSx3Cache( 'C20_NUMDOC','X3_TAMANHO')
static _nTmDTDOC  := GetSx3Cache( 'C20_DTDOC' ,'X3_TAMANHO')
static _nTmCODPAR := GetSx3Cache( 'C20_CODPAR','X3_TAMANHO')
static _nTmCliFor := GetSX3Cache( "FT_CLIEFOR",'X3_TAMANHO')
static _nTmLoja   := GetSX3Cache( "FT_LOJA", 'X3_TAMANHO')
Static _cTmT9CTpI := lTrim(cValToChar(GetSx3Cache('T9C_TPINSC','X3_TAMANHO')))
Static _cTmT9CNrI := lTrim(cValToChar(GetSx3Cache('T9C_NRINSC','X3_TAMANHO')))
Static oHashC01   := HMNew()
Static oHashC07   := HMNew()
Static oHashC09   := HMNew()
Static oHashC01   := HMNew()
Static oHashC02   := HMNew()
Static oHashC0U   := HMNew()
Static oHashC0X   := HMNew()
Static oHashT9C   := HMNew()
Static oHashC3Q   := HMNew()
Static oHashC0Y   := HMNew()
Static oHashC1H   := HMNew()
Static oHashC1L   := HMNew()
Static oHashC1N   := HMNew()
Static oHashC03   := HMNew()
Static oHashC1J   := HMNew()
Static oHashC0B   := HMNew()
Static oHashC0J   := HMNew()
Static oHashC8C   := HMNew()
Static oHashLF0   := HMNew()
Static oHashV3O   := HMNew()
Static oHashC3S   := HMNew()
Static oHashCHY   := HMNew()
Static oHashC1G   := HMNew()
Static oHashC20   := HshC20()
Static oHashC21   := HshC21()
Static oHashC30   := HshC30()
Static oHashC35   := HshC35()
Static oHashC39   := HshC39()
Static oHashC2D   := HshC2D()
Static oHashC2F   := HshC2F()
Static oHashT9Q   := HshT9Q()

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} TSIFiscalDocument
@type			function
@description	Inicia o processo de gravação dos documentos fiscais respeitando
				o limite definido na constante COMMIT_DATA_LIMIT
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@param          jDocumentos - JSON contendo os documentos fiscais a serem integrados
@return			Nil 
/*/
//-----------------------------------------------------------------------------------
Function TSIFiscalDocument(jDocumentos as json, lAutomato as logical)

	Local iDocumentos := 0   as integer
	Local cKey 		  := ''  as character
	Local iX 		  := 0   as integer
	Local lGrava 	  := .T. as logical
	Local iCount 	  := 0   as integer
	Local aDocs  	  := {}  as array

	Private cStamp := "" as character

	Default jDocumentos := Nil
	Default lAutomato   := .F.

	If jDocumentos != Nil

		iDocumentos := Len(jDocumentos[DOCUMENTOS_FISCAIS])

		For iX := 1 To iDocumentos
			If jDocumentos[DOCUMENTOS_FISCAIS][iX] != Nil

				lGrava := .T.
				//Retorno a chave do indice
				cKey := KeyIndex(jDocumentos[DOCUMENTOS_FISCAIS][iX], oHashC1H)

				C20->( DbSetOrder(5) )
				If C20->( DbSeek( xfilial('C20') + cKey ) )
					DeleteDoc()
					If jDocumentos[DOCUMENTOS_FISCAIS][iX]["opCancelation"] == "5" .and. jDocumentos[DOCUMENTOS_FISCAIS][iX]["identificationSituation"] == "02"
						lGrava := .F.
					EndIf
				EndIf

				If lGrava .and. !(jDocumentos[DOCUMENTOS_FISCAIS][iX]["opCancelation"] == "5" .and. jDocumentos[DOCUMENTOS_FISCAIS][iX]["identificationSituation"] == "02")
					iCount++
					AAdd(aDocs, jDocumentos[DOCUMENTOS_FISCAIS][iX])
				EndIf
			EndIf
		Next

		If Len(aDocs) > 0 .and. iCount < FLUSH_DATA_LIMIT
			InitTransaction(aDocs, lAutomato)
		EndIf

	EndIf

Return cStamp

//---------------------------------------------------------------------
/*/{Protheus.doc} InitError
@type			function
@description	Cria uma estância da classe ErrorClass()
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@return			Nil
/*/
//---------------------------------------------------------------------
Static Function DeleteDoc()

	Local oModel :=	FWLoadModel( "TAFA062" )

	oModel:DeActivate()
	oModel:SetOperation( 5 )
	oModel:Activate()

	FwFormCommit( oModel )

	oModel:DeActivate()

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} InitTransaction
@type			function
@description	Inicia a transação de gravação dos documentos fiscais
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@param          aDocumentos - Array contendo os documentos fiscais a serem integrados
@param          lAutomato - Valida se é automação
@return			Nil
/*/
//---------------------------------------------------------------------
Static Function InitTransaction(aDocumentos as array, lAutomato as logical)

	Local cKeyERP := "" as character
	Local cKeyV5r := "" as character
	Local iDocs   := 0  as integer
	Local aRetJs  := {} as array

	Default aDocumentos := {}
	Default lAutomato   := .F.

	For iDocs := 1 To Len(aDocumentos)
		BEGIN TRANSACTION
			iF FlushDocumentsData({aDocumentos[iDocs]}, @cKeyV5r, @cKeyERP, @aRetJs, lAutomato)
				DisarmTransaction()
				putTsiV5r('C20', cKeyV5r, aRetJs, cStamp, cKeyERP)
				aRetJs := {}
			EndIf
			ClearCachedData()
		END TRANSACTION
	Next

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} FlushDocumentsData
@type			function
@description	Realiza o despejo dos dados referentes aos documentos fiscais
				respeitando o limite definido na constante FLUSH_DATA_LIMIT
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@param          aData - Array contendo os dados dos documentos fiscais
@param          cKeyV5r - Retorna chave V5R_REGKEY em caso de erro
@param          cKeyERP - Retorna chave V5R_ERPKEY em caso de erro
@param          aRetJs - Retorna array dos erros agrupados
@param          lAutomato - Valida se é automação
@return			Nil
/*/
//---------------------------------------------------------------------
Static Function FlushDocumentsData(aData as array, cKeyV5r as character, cKeyERP as character, aRetJs as array, lAutomato as logical)

	Local cChvNf  := ""    as character
	Local cField  := ""    as character
	Local lRet    := .T.   as logical
	Local lErro   := .F.   as logical
	Local iC21    := 0     as integer
	Local iC2D    := 0     as integer
	Local iC2F    := 0     as integer
	Local iC30    := 0     as integer
	Local iC35    := 0     as integer
	Local iC39    := 0     as integer
	Local iT9Q    := 0     as integer
	Local iData   := 0     as integer
	Local jData   := Nil   as json
	Local oC20    := Nil   as object
	Local oC21    := Nil   as object
	Local oC2D    := Nil   as object
	Local oC2F    := Nil   as object
	Local oC30    := Nil   as object
	Local oC35    := Nil   as object
	Local oC39    := Nil   as object
	Local oT9Q    := Nil   as object

	Default lAutomato   := .F.

	If !Empty(aData)
		For iData := 1 To Len(aData)
			jData := aData[iData]
			KeyLogs(jData, oHashC20, @cKeyERP, @cKeyV5r)

			cChvNf := FWUUID("C20")

			ValidObject( @jData, oHashC20, @aRetJs, @lRet, cKeyV5r, "C20", lAutomato)

			cStamp := jData['stamp']

			If lRet
				GetBulk("C20", @oC20)
				oC20:AddData(GetValues("C20", jData, oHashC20, cChvNf))
				If !Empty(oC20:GetError()) .Or. !oC20:Flush()
					ErrorHandling(oC20:GetError(), "C20", {jData}, @aRetJs, oHashC20, cKeyV5r)
					InitBulk("C20", @oC20)
					lRet := .F.
					If lAutomato
						lRet := .T.
					EndIf
				EndIf
			EndIf

			If jData != Nil .and. lRet
				If jData:HasProperty(INFORMACOES_COMPLEMENTARES)
					If Len(jData[INFORMACOES_COMPLEMENTARES]) > 0
						For iC21 := 1 To Len(jData[INFORMACOES_COMPLEMENTARES])
							lErro := .T.
							ValidObject( @jData[INFORMACOES_COMPLEMENTARES][iC21], oHashC21, @aRetJs, @lErro, cKeyV5r, "C21", lAutomato)

							lRet := lErro := lErro

							If lRet
								GetBulk("C21", @oC21)
								oC21:AddData(GetValues("C21", jData[INFORMACOES_COMPLEMENTARES][iC21], oHashC21, cChvNf))
							EndIf
						Next
						If lRet
							If !Empty(oC21:GetError()) .Or. !oC21:Flush()
								ErrorHandling(oC21:GetError(), "C21", jData[INFORMACOES_COMPLEMENTARES], @aRetJs, oHashC21, cKeyV5r)
								InitBulk("C21", @oC21)
								lRet := .F.
								If lAutomato
									lRet := .T.
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf

				If jData:HasProperty(LANCAMENTOS_FISCAIS)
					If Len(jData[LANCAMENTOS_FISCAIS]) > 0
						For iC2D := 1 To Len(jData[LANCAMENTOS_FISCAIS])
							lErro := .T.
							ValidObject( @jData[LANCAMENTOS_FISCAIS][iC2D], oHashC2D, @aRetJs, @lErro, cKeyV5r, "C2D", lAutomato)

							lRet := lErro := lErro
							If lRet
								GetBulk("C2D", @oC2D)
								oC2D:AddData(GetValues("C2D", jData[LANCAMENTOS_FISCAIS][iC2D], oHashC2D, cChvNf,,jData[LANCAMENTOS_FISCAIS][iC2D]['product']))
							EndIf
						Next
						If lRet
							If !Empty(oC2D:GetError()) .Or. !oC2D:Flush()
								ErrorHandling(oC2D:GetError(), "C2D", jData[LANCAMENTOS_FISCAIS], @aRetJs, oHashC2D, cKeyV5r)
								InitBulk("C2D", @oC2D)
								lRet := .F.
								If lAutomato
									lRet := .T.
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf

				If jData:HasProperty(ITENS) .and. lRet
					For iC30 := 1 To Len(jData[ITENS])
						lErro := .T.
						ValidObject( @jData[ITENS][iC30], oHashC30, @aRetJs, @lErro, cKeyV5r, "C30", lAutomato)

						lRet := lErro := lErro
						If lRet
							GetBulk("C30", @oC30)
							If oC30:AddData(GetValues("C30", jData[ITENS][iC30], oHashC30, cChvNf))
								If jData[ITENS][iC30]:HasProperty(TRIBUTOS)
									If Len(jData[ITENS][iC30][TRIBUTOS]) > 0 
										For iC35 := 1 To Len(jData[ITENS][iC30][TRIBUTOS])
											lErro := .T.
											ValidObject( @jData[ITENS][iC30][TRIBUTOS][iC35], oHashC35, @aRetJs, @lErro, cKeyV5r, "C35", lAutomato)

											lRet := lErro := lErro

											If lRet
												GetBulk("C35", @oC35)
												oC35:AddData(GetValues("C35", jData[ITENS][iC30][TRIBUTOS][iC35], oHashC35, cChvNf, jData[ITENS][iC30]['itemNumber'], jData[ITENS][iC30]['itemCode']))
											EndIf
										Next
										If lRet
											If !Empty(oC35:GetError()) .Or. !oC35:Flush()
												ErrorHandling(oC35:GetError(), "C35", jData[ITENS][iC30][TRIBUTOS], @aRetJs, oHashC35, cKeyV5r)
												InitBulk("C35", @oC35)
												lRet := .F.
												If lAutomato
													lRet := .T.
												EndIf
											EndIf
										EndIf
									EndIf
								EndIf

								If jData[ITENS][iC30]:HasProperty(SERVICO_TRANSPORTE) .and. lRet
									If Len(jData[ITENS][iC30][SERVICO_TRANSPORTE]) > 0 
										For iC39 := 1 To Len(jData[ITENS][iC30][SERVICO_TRANSPORTE])
											lErro := .T.
											ValidObject( @jData[ITENS][iC30][SERVICO_TRANSPORTE][iC39], oHashC39, @aRetJs, @lErro, cKeyV5r, "C39", lAutomato)

											lRet := lErro := lErro
											If lRet
												GetBulk("C39", @oC39)
												oC39:AddData(GetValues("C39", jData[ITENS][iC30][SERVICO_TRANSPORTE][iC39], oHashC39, cChvNf, jData[ITENS][iC30]['itemNumber'], jData[ITENS][iC30]['itemCode']))
											EndIf
										Next
										If lRet
											If !Empty(oC39:GetError()) .Or. !oC39:Flush()
												ErrorHandling(oC39:GetError(), "C39", jData[ITENS][iC30][SERVICO_TRANSPORTE], @aRetJs, oHashC39, cKeyV5r)
												InitBulk("C39", @oC39)
												lRet := .F.
												If lAutomato
													lRet := .T.
												EndIf
											EndIf
										EndIf
									EndIf
								EndIf

								If jData[ITENS][iC30]:HasProperty(PROCESSOS_REFERENCIADOS) .and. lRet
									If Len(jData[ITENS][iC30][PROCESSOS_REFERENCIADOS]) > 0
										For iT9Q := 1 To Len(jData[ITENS][iC30][PROCESSOS_REFERENCIADOS])
											lErro := .T.
											ValidObject( @jData[ITENS][iC30][PROCESSOS_REFERENCIADOS][iT9Q], oHashT9Q, @aRetJs, @lErro, cKeyV5r, "T9Q", lAutomato)
											//Valido se pela menos uma esta em branco e preenchida, pois são compos obrigatórios
											IF (Empty(jData[ITENS][iC30][PROCESSOS_REFERENCIADOS][iT9Q]['processNumber']) .and. !Empty(jData[ITENS][iC30][PROCESSOS_REFERENCIADOS][iT9Q]['tributeCode']));
											 .or. (!Empty(jData[ITENS][iC30][PROCESSOS_REFERENCIADOS][iT9Q]['processNumber']) .and. Empty(jData[ITENS][iC30][PROCESSOS_REFERENCIADOS][iT9Q]['tributeCode']))
												lErro := .F.
												HMGet( oHashT9Q, 'processNumber', @cField )
												cField := SubStr( cField, 1, 10)
												cErro := RetErroTaf( 'processNumber', jData[ITENS][iC30][PROCESSOS_REFERENCIADOS][iT9Q], cField, "OBRIGAT" )
												AgrupaErro( cKeyV5r, cErro, @aRetJs )
											EndIf

											lRet := lErro := lErro
											If lRet
												GetBulk("T9Q", @oT9Q)
												oT9Q:AddData(GetValues("T9Q", jData[ITENS][iC30][PROCESSOS_REFERENCIADOS][iT9Q], oHashT9Q, cChvNf, jData[ITENS][iC30]['itemNumber'], jData[ITENS][iC30]['itemCode']))											
											EndIf
										Next
										If lRet
											If !Empty(oT9Q:GetError()) .Or. !oT9Q:Flush()
												ErrorHandling(oT9Q:GetError(), "T9Q", jData[ITENS][iC30][PROCESSOS_REFERENCIADOS], @aRetJs, oHashT9Q, cKeyV5r)
												InitBulk("T9Q", @oT9Q)
												lRet := .F.
												If lAutomato
													lRet := .T.
												EndIf
											EndIf
										EndIf
									EndIf
								EndIf
							EndIf
						EndIf
					Next
					If lRet
						If !Empty(oC30:GetError()) .Or. !oC30:Flush()
							ErrorHandling(oC30:GetError(), "C30", jData[ITENS], @aRetJs, oHashC30, cKeyV5r)
							InitBulk("C30", @oC30)
							lRet := .F.
							If lAutomato
								lRet := .T.
							EndIf
						EndIf
					Else
						InitBulk("C30", @oC30)
					EndIf
				EndIf

				If jData:HasProperty(VALORES_TRIBUTO) .and. lRet
					If Len(jData[VALORES_TRIBUTO]) > 0  
						For iC2F := 1 To Len(jData[VALORES_TRIBUTO])
							lErro := .T.
							ValidObject( @jData[VALORES_TRIBUTO][iC2F], oHashC2F, @aRetJs, @lErro, cKeyV5r, "C2F", lAutomato)

							lRet := lErro := lErro
							If lRet
								GetBulk("C2F", @oC2F)
								oC2F:AddData(GetValues("C2F", jData[VALORES_TRIBUTO][iC2F], oHashC2F, cChvNf))
							EndIf
						Next
						If lRet
							If !Empty(oC2F:GetError()) .Or. !oC2F:Flush()
								ErrorHandling(oC2F:GetError(), "C2F", jData[VALORES_TRIBUTO], @aRetJs, oHashC2F, cKeyV5r)
								InitBulk("C2F", @oC2F)
								lRet := .F.
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		Next
	EndIf

Return !(lRet)

//---------------------------------------------------------------------
/*/{Protheus.doc} ValidObject
@type			function
@description	Validação dos Ids e demais campos
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@param          jData - Json contendo os documentos fiscais a serem integrados
@param          oHash - Hash da tabela a ser validada
@param          aRetJs - Retorna array dos erros agrupados
@param          lRet - Retorna se o json esta valido
@param          cKey - Retorna chave V5R_REGKEY em caso de erro
@param          cTable - Alias a ser validado
@param          lAutomato - Valida se é automação
@return			Nil
/*/
//---------------------------------------------------------------------
Static Function ValidObject(jData as json, oHash as object, aRetJs as array, lRet as logical, cKey as character, cTable as character, lAutomato as logical)

	Local cField    := ''  as character
	Local cChave    := ''  as character
	Local cFunc     := ''  as character
	Local cProperty := ''  as character
	Local cErro     := ''  as character
	Local cId       := ''  as character
	Local iX        := 0   as integer
	Local aProperty := {}  as array
	Local lErro     := .T. as logical//variavel para acumular ao menos 1 falha.
	Local lOk       := .T. as logical

	Default lAutomato   := .F.

	If !(lAutomato)

		aProperty := jData:GetNames( )

		For iX := 1 To Len( aProperty )
			lOk := .T.
			If HMGet( oHash, aProperty[iX], @cField )
				cChave := jData[aProperty[iX]]
				If "#F3#" $ cField //Tratamento de-para para campos F3
					cField := SubStr( cField, 1, Len( cField ) - 4 )
					If !Empty( cChave )
						HMGet( oHash, "#F3#"+cField, @cFunc )
						cChave := &cFunc					
						If "NOTFOUND" == cChave
							lErro := lOk := .F.
							cChave := jData[aProperty[iX]]
							HMGet( oHash, cField, @cProperty )
							cErro := RetErroTaf( cProperty, jData, cField, "NOTFOUND" )
							AgrupaErro( cKey, cErro, @aRetJs )
						Else
							jData[aProperty[iX]] := cChave
						EndIf
					ElseIf cTable == "C20"	
						If cField == "C20_CODMOD"
							cChave := '000001'
							jData[aProperty[iX]] := cChave
						ElseIf cField $ "C20_INDOPE|C20_TPDOC|C20_CODSIT|C20_NUMDOC"
							HMGet( oHash, cField, @cProperty )
							cErro := RetErroTaf( cProperty, jData, cField, "OBRIGAT" )
							AgrupaErro( cKey, cErro, @aRetJs )
						EndIf
					EndIf
				ElseIf "#DT#" $ cField // Tratamento para campos tipo data
					cField := SubStr( cField, 1, Len( cField ) - 4 )
					If valtype(cChave) == 'C'
						cChave := ctod(cChave)
						If cField <> "C20_DTCPIS" .And. ( alltrim(cvaltochar(cChave)) == "/  /" .or. empty(alltrim(cvaltochar(cChave))) ) //C20_DTCPIS nao eh obrigatorio logo nao passara na validacao de data vazia.
							cChave := cTod('')
							lErro := lOk := .F.
							HMGet( oHash, cField, @cProperty )
							cErro := RetErroTaf( cProperty, jData, cField, "DATE" )
							AgrupaErro( cKey, cErro, @aRetJs )						
						EndIf
					EndIf
				EndIf
			Endif
		Next
		lRet := lErro
	EndIf
Return

//---------------------------------------------------------------------
/*/{Protheus.doc} GetFields
@type			function
@description	Retorna os campos da tabela informada
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@param          cTable - Alias da tabela
@param          lVirtual - .T. para retornar campos virtuais; .F. para não retornar campos virtuais
@return			aFields - Campos ta tabela no formato: {{"CAMPO", "TIPO", "TAMANHO", "DECIMAIS"}}
/*/
//---------------------------------------------------------------------
Static Function GetFields(cTable as character, lVirtual as logical) as array

	Local aFields 	 := {} as array

	Default cTable   := ""
	Default lVirtual := .F.

	If !Empty(cTable)
		If __jFields == Nil
			__jFields := JsonObject():New()
		EndIf

		If __jFields:HasProperty(cTable) .And. !Empty(__jFields[cTable])
			aFields := __jFields[cTable]
		Else
			__jFields[cTable] := FWSX3Util():GetListFieldsStruct(cTable, lVirtual)
			aFields := __jFields[cTable]
		EndIf
	EndIf

Return aFields

//---------------------------------------------------------------------
/*/{Protheus.doc} GetIndex
@type			function
@description	Retorna a chave única da tabela informada
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@param          cTable - Alias da tabela
@return			aIndex - Campos que compõem a chave única
/*/
//---------------------------------------------------------------------
Static Function GetIndex(cTable as character) as array

	Local aIndex := {} as array

	Default cTable := ""

	If !Empty(cTable)
		If __jIndexes == Nil
			__jIndexes := JsonObject():New()
		EndIf

		__jIndexes[cTable] := StrTokArr2(FWX2Unico(cTable), "+")
		aIndex := __jIndexes[cTable]

	EndIf

Return aIndex

//---------------------------------------------------------------------
/*/{Protheus.doc} ErrorHandling
@type			static function
@description	Realiza o tratamento dos erros retornados pelo FWBulk()
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@param          cError - Erro gerado pelo FWBulk()
@param          cTable - Alias da tabela em que o erro foi gerador
@param          aData - Dados que geraram o erro
@param          aRetJs - Campos e conteúdos que compõe os registros com erro
@return			Nil
/*/
//---------------------------------------------------------------------
	Using Namespace tlpp.regex
Static Function ErrorHandling(cError as character, cTable as character, aData as array, aRetJs as array, oHash as object, cKeyV5r as character)

	Local aCampos 	:= {} as array
	Local aIndexes 	:= {} as array
	Local aChave 	:= {} as array
	Local oRegex 	:= Nil as object
	Local jData 	:= Nil as json
	Local cProperty := "" as character

	Default aData 	:= {}
	Default aDados 	:= {}
	Default aErrors := {}
	Default cError  := ""
	Default cTable  := ""
	Default lRet    := .F.

	If !Empty(cTable) .And. !Empty(aData)
		jData := aData[1]
		aCampos := GetFields(cTable)
		aChave := GetIndex(cTable)
		oRegex := Regex():New("")

		oRegex:SetMultiline(.T.)
		oRegex:SetCaseSensitive(.F.)

		oRegex:SetPattern("Invalid bind parameter size")

		If oRegex:Tokenizer(cError,, @aIndexes)

			nColumn := Val(AllTrim(SubStr(cError, At("Col", cError) + 4, At(")", cError) - (At("Col", cError) + 4))))

			hmget( oHash, aCampos[nColumn][1], @cProperty )
			If !Empty(cProperty)
				cErro := "O conteúdo incluído, " + jData[cProperty] + " é maior que o tamanho do campo: " + aCampos[nColumn][1]
				AgrupaErro( cKeyV5r, cErro, @aRetJs )
			EndIf
		EndIf

		FWFreeArray(aChave)
		FWFreeArray(aCampos)
		FWFreeArray(aIndexes)
		FWFreeObj(oRegex)
	EndIf
Return

//---------------------------------------------------------------------------------------------------
/*/{Protheus.doc} GetValues
@type			function
@description	Realiza o tratamento do conteúdo a ser gravado pelo FWBulk() na tabela informada
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@param          cTable - Alias da tabela
@param          jData - Dados a serem gravados na tabela informada
@param          oHash - Hash do alias
@param          cChvNf - Chave da única da nota
@param          cNumIte - Número do item
@param          cCodIte - Código do item
@return			aValues - Valores estruturados no formato e ordem correta para o FWBulk() 
/*/
//---------------------------------------------------------------------------------------------------
Static Function GetValues(cTable as character, jData as json, oHash as Object, cChvNf as character, cNumIte as character, cCodIte as character) as array

	Local aValues 	:= {} as array
	Local aFields 	:= {} as array
	Local iX		:= 0  as integer
	Local cProperty := "" as character

	Default cTable 	:= ""
	Default jData 	:= Nil
	Default oHash 	:= Nil
	Default cChvNf 	:= ""
	Default cNumIte := ""
	Default cCodIte := ""

	If !Empty(cTable) .and. jData != Nil .and. oHash != Nil .and. !Empty(cChvNf)
		aFields := GetFields(cTable)

		For iX := 1 To Len(aFields)
			If aFields[iX][1] $ ''+cTable+'_FILIAL|'+cTable+'_CHVNF'
				If aFields[iX][1] $ cTable+'_FILIAL'
					AAdd(aValues, xFilial(cTable))
				Else
					AAdd(aValues, cChvNf)
				EndIf
			ElseIf !(cTable == 'C30') .and. aFields[iX][1] $ ''+cTable+'_NUMITE|'+cTable+'_CODITE|T9Q_ID'
				If aFields[iX][1] $ cTable+'_NUMITE'
					AAdd(aValues, cNumIte)
				Else
					AAdd(aValues, cCodIte)
				EndIf
			Else
				cProperty := ""
				hmget( oHash, aFields[iX][1], @cProperty )
				If jData:HasProperty(cProperty)
					If aFields[iX][2] $ "C|M"
						AAdd(aValues, alltrim(jData[cProperty]))
					ElseIf aFields[iX][2] == "D"
						AAdd(aValues, CToD(jData[cProperty]))
					Else
						AAdd(aValues, jData[cProperty])
					EndIf
				Else
					Do Case
					Case aFields[iX][2] $ "C|M"
						AAdd(aValues, "")

					Case aFields[iX][2] == "D"
						AAdd(aValues, CToD(""))

					Case aFields[iX][2] == "N"
						AAdd(aValues, 0)

					EndCase
				EndIf
			EndIf
		Next
	EndIf

Return aValues

//---------------------------------------------------------------------
/*/{Protheus.doc} GetBulk
@type			function
@description	Instancia o objeto da classe FWBulk() para a respectiva tabela informada
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@param          cTable - Alias da tabela
@param          oBulk - Objeto que retornará a instância da classe FWBulk() por referência
@return			Nil
/*/
//---------------------------------------------------------------------
Static Function GetBulk(cTable as character, oBulk as object)

	Default cTable := ""
	Default oBulk  := Nil

	If !Empty(cTable) .And. oBulk == Nil
		If __jBulks == Nil
			__jBulks := JsonObject():New()
		EndIf

		InitBulk(cTable, @oBulk)
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} InitBulk
@type			function
@description	Instancia um objeto da classe FWBulk() para a respectiva tabela informada
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@param          cTable - Alias da tabela
@param          oBulk - Objeto que retornará a instância da classe FWBulk() por referência
@return			Nil
/*/
//---------------------------------------------------------------------
Static Function InitBulk(cTable as character, oBulk as object)

	Default cTable := ""
	Default oBulk  := Nil

	If !Empty(cTable)
		__jBulks[cTable] := Nil
		__jBulks[cTable] := FwBulk():New(RetSQLName(cTable), FLUSH_DATA_LIMIT)

		__jBulks[cTable]:SetFields(GetFields(cTable))

		oBulk := __jBulks[cTable]
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} ClearCachedData
@type			static function
@description	Limpa a variável em cache
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@return			Nil
/*/
//---------------------------------------------------------------------
Static Function ClearCachedData()

	__jBulks 	:= Nil

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} HashC20
@type			function
@description	Monta o hash da C35
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@return			Nil
/*/
//---------------------------------------------------------------------
Function HshC20()

	Local oHashC20 := NIL as object

	oHashC20 := HMNew()

	SetHashKey(oHashC20, "operationType"              , "C20_INDOPE" )     // 02 - IND_OPER
	SetHashKey(oHashC20, "documentType"               , "C20_TPDOC" )  // 03 - TIPO_DOC -> De/Para na query -> FDeParaTAF( )   // C0U
	SetHashKey(oHashC20, "documentType"               , "C20_TPDOC#F3#" )  // 03 - TIPO_DOC -> De/Para na query -> FDeParaTAF( )   // C0U
	SetHashKey(oHashC20, "taxDocumentIssuer"          , "C20_INDEMI" )     // 04 - IND_EMIT -> De/Para na query
	SetHashKey(oHashC20, "participatingCode"          , "C20_CODPAR" ) // 05 - COD_PART
	SetHashKey(oHashC20, "participatingCode"          , "C20_CODPAR#F3#" ) // 05 - COD_PART
	SetHashKey(oHashC20, "identificationSituation"    , "C20_CODSIT" ) // 06 - COD_SIT  SPEDSITDOC( ) // C02
	SetHashKey(oHashC20, "identificationSituation"    , "C20_CODSIT#F3#" ) // 06 - COD_SIT  SPEDSITDOC( ) // C02
	SetHashKey(oHashC20, "taxDocumentSeries"          , "C20_SERIE" )	   // 07 - SER
	SetHashKey(oHashC20, "taxDocumentNumber"          , "C20_NUMDOC" )	   // 09 - NUM_DOC
	SetHashKey(oHashC20, "fiscalDocumentDate"         , "C20_DTDOC" )  // 10 - DT_DOC
	SetHashKey(oHashC20, "fiscalDocumentDate"         , "C20_DTDOC#DT#" )  // 10 - DT_DOC
	SetHashKey(oHashC20, "electronicKeyDocument"      , "C20_CHVELE" )     // 11 - CHV_DOC_E
	SetHashKey(oHashC20, "documentValue"              , "C20_VLDOC" )      // 12 - VL_DOC
	SetHashKey(oHashC20, "typeOfPayment"              , "C20_INDPAG" )     // 13 - IND_PGTO
	SetHashKey(oHashC20, "discountAmount"             , "C20_VLDESC" )	   // 14 - VL_DESC
	SetHashKey(oHashC20, "modelIdentificationCode"    , "C20_CODMOD" ) // 15 - COD_MOD -> AModNot( )
	SetHashKey(oHashC20, "modelIdentificationCode"    , "C20_CODMOD#F3#" ) // 15 - COD_MOD -> AModNot( )
	SetHashKey(oHashC20, "finalDocumentNumber"        , "C20_NDOCF" )	   // 16 - NUM_DOC_FIN
	SetHashKey(oHashC20, "valueOfGoods"               , "C20_VLMERC" )	   // 18 - VL_MERC
	SetHashKey(oHashC20, "taxDocumentEntryAndExitDate", "C20_DTES" )   // 19 - DT_E_S
	SetHashKey(oHashC20, "taxDocumentEntryAndExitDate", "C20_DTES#DT#" )   // 19 - DT_E_S
	SetHashKey(oHashC20, "amountOfAccessoryExpenses"  , "C20_VLRDA" )	   // 20 - VL_DA
	SetHashKey(oHashC20, "shippingIndicator"          , "C20_INDFRT" )     // 25 - IND_FRT
	SetHashKey(oHashC20, "shippingIndicator"          , "C20_INDFRT#F3#" )     // 25 - IND_FRT
	SetHashKey(oHashC20, "insuranceAmount"            , "C20_VLRSEG" )	   // 26 - VL_SEG
	SetHashKey(oHashC20, "otherExpenses"              , "C20_VLOUDE" )	   // 27 - VL_OUT_DESP
	SetHashKey(oHashC20, "freight"                    , "C20_VLRFRT" )	   // 28 - VL_FRT
	SetHashKey(oHashC20, "untaxedAllowanceAmount"     , "C20_VLABNT" )	   // 30 - VL_ABAT_NT
	SetHashKey(oHashC20, "AIDFNumber"                 , "C20_AIDF" )       // 31 - NUM_AUT
	SetHashKey(oHashC20, "valueOfServices"            , "C20_VLSERV" )	   // 38 - VL_SERV
	SetHashKey(oHashC20, "placeOfDelivery"            , "C20_CODLOC" )     // 62 - LOC_PRESTACAO
	SetHashKey(oHashC20, "placeOfDelivery"            , "C20_CODLOC#F3#" )     // 62 - LOC_PRESTACAO
	SetHashKey(oHashC20, "valueReducedISSMaterials"   , "C20_VLABMT" )	   // 63 - VL_DED_ISS_MAT
	SetHashKey(oHashC20, "cnoNumber"                  , "C20_IDOBR" )  // 65 - NR_INSC_ESTAB
	SetHashKey(oHashC20, "cnoNumber"                  , "C20_IDOBR#F3#" )  // 65 - NR_INSC_ESTAB
	SetHashKey(oHashC20, "registrationType"           , "C20_TPOBR" )      // 70 - TP_INSCRICAO CAMPO FAKE
	SetHashKey(oHashC20, "federativeUnitOrigin"       , "C20_UF" )	   // 69 - UF_ORIGEM
	SetHashKey(oHashC20, "federativeUnitOrigin"       , "C20_UF#F3#" )	   // 69 - UF_ORIGEM

	If TAFColumnPos( "C20_DTCONT" )
		SetHashKey(oHashC20, "accountingDate"         , "C20_DTCONT" ) // 74 - Dt. Contabilização
		SetHashKey(oHashC20, "accountingDate"         , "C20_DTCONT#DT#" ) // 74 - Dt. Contabilização
	Endif

	If TAFColumnPos( "C20_DTCPIS" )
		SetHashKey(oHashC20, "competenceIss"          , "C20_DTCPIS" ) //Data Competencia ISS
		SetHashKey(oHashC20, "competenceIss"          , "C20_DTCPIS#DT#" ) //Data Competencia ISS
	Endif

	SetHashKey(oHashC20, "stamp" 					  , "C20_STAMP" )      // 09 - STAMP

	HMSet(oHashC20, '#F3#C20_CODLOC', "GetIDCache( 'C07', XFUNGETUF( iif(Len(jData['placeOfDelivery'])==7, substr(jData['placeOfDelivery'],1,2),'')) + iif(Len(jData['placeOfDelivery'])==7, substr(jData['placeOfDelivery'],3,5),'') , 1 ,oHashC07)" ) //C07_FILIAL, C07_UF, C07_CODIGO
	HMSet(oHashC20, '#F3#C20_UF'    , "GetIDCache( 'C09', jData['federativeUnitOrigin'] , 1 ,oHashC09)" )                //C09_FILIAL, C09_UF
	HMSet(oHashC20, '#F3#C20_CODMOD', "ValCodMod(GetIDCache('C01',jData['modelIdentificationCode'],1,oHashC01))" )  //C01_FILIAL, C01_CODIGO
	HMSet(oHashC20, '#F3#C20_CODSIT', "GetIDCache( 'C02', jData['identificationSituation'] , 1 ,oHashC02)" )                //C02_FILIAL, C02_CODIGO
	HMSet(oHashC20, '#F3#C20_TPDOC' , "GetIDCache( 'C0U', jData['documentType'] , 1 ,oHashC0U)" )                //C0U_FILIAL, C0U_CODIGO
	HMSet(oHashC20, '#F3#C20_CODPAR', "GetIDCache( 'C1H', jData['participatingCode'] , 1 ,oHashC1H)" )                //C1H_FILIAL, C1H_CODPAR
	HMSet(oHashC20, '#F3#C20_INDFRT', "GetIDCache( 'C0X', jData['shippingIndicator'] , 1 ,oHashC0X)" )                //C0X_FILIAL, C0X_CODIGO
	HMSet(oHashC20, '#F3#C20_IDOBR' , "GetIDCache( 'T9C', padr(jData['registrationType']," + _cTmT9CTpI + ") + padr(jData['cnoNumber']," + _cTmT9CNrI + "), 3 , oHashT9C)" ) //T9C_FILIAL, T9C_ID

Return oHashC20

//---------------------------------------------------------------------
/*/{Protheus.doc} HashC21
@type			function
@description	Monta o hash da C35
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@return			Nil
/*/
//---------------------------------------------------------------------
Function HshC21()

	Local oHashC21 := NIL as object

	oHashC21 := HMNew( )

	//Campos das informações complementares de documentos fiscais.
	SetHashKey(oHashC21, 'complementaryInfoCode', 'C21_CODINF'	  )
	SetHashKey(oHashC21, 'complementaryInfoCode', 'C21_CODINF#F3#')
	SetHashKey(oHashC21, 'auxiliaryCode',         'C21_CDINFO'    )
	SetHashKey(oHashC21, 'complementaryInfoDesc', 'C21_DCODIN'    )
	SetHashKey(oHashC21, 'complementaryInfoText', 'C21_DESCRI'    )

	HMSet(oHashC21, '#F3#C21_CODINF', "GetIDCache( 'C3Q', jData['complementaryInfoCode'], 1 ,oHashC3Q)") //C3Q_FILIAL, C3Q_CODINF

Return oHashC21

//---------------------------------------------------------------------
/*/{Protheus.doc} HashC2D
@type			function
@description	Monta o hash da C35
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@return			Nil
/*/
//---------------------------------------------------------------------
Function HshC2D()

	Local oHashC2D := NIL as object

	oHashC2D := HMNew()

	SetHashKey(oHashC2D, "adjustmentCode"       , "C2D_CODAJ"     )   // 02 - COD_AJ
	SetHashKey(oHashC2D, "adjustmentCode"       , "C2D_CODAJ#F3#" )   // 02 - COD_AJ
	SetHashKey(oHashC2D, "settingDescription"   , "C2D_DESCRI"	  )   // 03 - DESCR_COMPL_AJ
	SetHashKey(oHashC2D, "product"              , "C2D_CODITE"    )   // 04 - COD_ITEM
	SetHashKey(oHashC2D, "product"              , "C2D_CODITE#F3#")   // 04 - COD_ITEM
	SetHashKey(oHashC2D, "basisOfCalculation"   , "C2D_BSICM"     )   // 05 - VL_BC_ICMS
	SetHashKey(oHashC2D, "aliquot"              , "C2D_ALQICM"    )   // 06 - ALIQ_ICMS
	SetHashKey(oHashC2D, "value"                , "C2D_VLICM"     )   // 07 - VL_ICMS
	SetHashKey(oHashC2D, "subitemCode"          , "C2D_IDSUBI"    )   // 09 - COD_SUBITEM
	SetHashKey(oHashC2D, "subitemCode"          , "C2D_IDSUBI#F3#")   // 09 - COD_SUBITEM

	HMSet(oHashC2D, '#F3#C2D_CODAJ', "GetIDCache( 'C0J', jData['adjustmentCode'], 4 ,oHashC0J)") //C0J_FILIAL, C0J_CODIGO
	HMSet(oHashC2D, '#F3#C2D_CODITE', "GetIDCache( 'C1L', jData['product'], 1 ,oHashC1L)")       //C1L_FILIAL, C1L_CODIGO
	HMSet(oHashC2D, '#F3#C2D_IDSUBI', "GetIDCache( 'CHY', jData['subitemCode'], 2 ,oHashCHY)")   //CHY_FILIAL, CHY_CODIGO, CHY_OPERAC, CHY_IDUF

Return oHashC2D

//---------------------------------------------------------------------
/*/{Protheus.doc} HashC30
@type			function
@description	Monta o hash da C35
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@return			Nil
/*/
//---------------------------------------------------------------------
Function HshC30()

	Local oHashC30 := NIL as object	

	oHashC30 := HMNew()

	SetHashKey(oHashC30, "itemNumber"             , "C30_NUMITE"     )
	SetHashKey(oHashC30, "itemCode"               , "C30_CODITE"     )
	SetHashKey(oHashC30, "itemCode"               , "C30_CODITE#F3#" )
	SetHashKey(oHashC30, "cfopIndicator"          , "C30_CFOP" 		 )
	SetHashKey(oHashC30, "cfopIndicator"          , "C30_CFOP#F3#" 	 )
	SetHashKey(oHashC30, "itemAdditions"          , "C30_VLACRE" 	 )
	SetHashKey(oHashC30, "operationNature"        , "C30_NATOPE" 	 )
	SetHashKey(oHashC30, "operationNature"        , "C30_NATOPE#F3#" )
	SetHashKey(oHashC30, "originIdentCode"        , "C30_ORIGEM" 	 )
	SetHashKey(oHashC30, "originIdentCode"        , "C30_ORIGEM#F3#" )
	SetHashKey(oHashC30, "physicalMovement"       , "C30_INDMOV" 	 )
	SetHashKey(oHashC30, "accountingValue"        , "C30_VLOPER" 	 )
	SetHashKey(oHashC30, "socialSecurityExemption", "C30_INDISE" 	 )
	SetHashKey(oHashC30, "itemAmount"             , "C30_QUANT" 	 )
	SetHashKey(oHashC30, "itemTotalValue"         , "C30_TOTAL" 	 )
	SetHashKey(oHashC30, "discountValue"          , "C30_VLDESC" 	 )
	SetHashKey(oHashC30, "itemValue"              , "C30_VLRITE" 	 )
	SetHashKey(oHashC30, "acessoryExpense"        , "C30_VLRDA" 	 )
	SetHashKey(oHashC30, "unitOfMeasurement"      , "C30_UM" 		 )
	SetHashKey(oHashC30, "unitOfMeasurement"      , "C30_UM#F3#" 	 )
	SetHashKey(oHashC30, "serviceCode"            , "C30_CODSER" 	 )
	SetHashKey(oHashC30, "serviceCode"            , "C30_CODSER#F3#" )
	SetHashKey(oHashC30, "cityServiceCode"        , "C30_SRVMUN" 	 )
	SetHashKey(oHashC30, "serviceType"            , "C30_IDTSER" 	 )
	SetHashKey(oHashC30, "serviceType"            , "C30_IDTSER#F3#" )
	SetHashKey(oHashC30, "dipamCode"              , "C30_CODIPA" 	 )
	SetHashKey(oHashC30, "dipamCode"              , "C30_CODIPA#F3#" )
	SetHashKey(oHashC30, "natureOfIncome"         , "C30_CNATRE" 	 )
	SetHashKey(oHashC30, "natureOfIncome"         , "C30_CNATRE#F3#" )
	SetHashKey(oHashC30, "indicator13Salary"      , "C30_DECTER" 	 )
	SetHashKey(oHashC30, "typeOfTransfer"         , "C30_TPREPA" 	 )
	SetHashKey(oHashC30, "itemDiscrimination"     , "C30_DESCRI"     )

	HMSet(oHashC30, '#F3#C30_CODITE', "GetIDCache( 'C1L', jData['itemCode'], 1 ,oHashC1L)" ) //C1L_FILIAL, C1L_CODIGO
	HMSet(oHashC30, '#F3#C30_CFOP'  , "GetIDCache( 'C0Y', jData['cfopIndicator'], 1 ,oHashC0Y)" ) //C0Y_FILIAL, C0Y_CODIGO
	HMSet(oHashC30, '#F3#C30_NATOPE', "GetIDCache( 'C1N', jData['operationNature'], 1 ,oHashC1N)" ) //C1N_FILIAL, C1N_CODNAT
	HMSet(oHashC30, '#F3#C30_ORIGEM', "GetIDCache( 'C03', jData['originIdentCode'], 1 ,oHashC03)" ) //C03_FILIAL, C03_CODIGO
	HMSet(oHashC30, '#F3#C30_UM'    , "GetIDCache( 'C1J', jData['unitOfMeasurement'] , 1 ,oHashC1J)" ) //C1J_FILIAL, C1J_CODIGO
	HMSet(oHashC30, '#F3#C30_CODSER', "GetIDCache( 'C0B', cValToChar(Val(StrTran(jData['serviceCode'],'.'))), 1 ,oHashC0B)" ) //C0B_FILIAL, C0B_CODIGO
	HMSet(oHashC30, '#F3#C30_IDTSER', "GetIDCache( 'C8C', jData['serviceType'] , 4 ,oHashC8C)" ) //C8C_FILIAL, C8C_CREINF
	HMSet(oHashC30, '#F3#C30_CODIPA', "GetIDCache( 'LF0', jData['dipamCode'] , 2 ,oHashLF0)" ) //LF0_FILIAL, LF0_CODIGO
	HMSet(oHashC30, '#F3#C30_CNATRE', "GetIDCache( 'V3O', jData['natureOfIncome'] , 1 ,oHashV3O)" ) //V3O_FILIAL, V3O_CODIGO

Return oHashC30

//---------------------------------------------------------------------
/*/{Protheus.doc} HashC35
@type			function
@description	Monta o hash da C35
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@return			Nil
/*/
//---------------------------------------------------------------------
Function HshC35()

	Local oHashC35 := NIL as object	

	oHashC35 := HMNew()

	SetHashKey(oHashC35, "taxCode"                        , "C35_CODTRI"     ) 	   
	SetHashKey(oHashC35, "taxCode"                        , "C35_CODTRI#F3#" )     
	SetHashKey(oHashC35, "cst"                            , "C35_CST"        )     
	SetHashKey(oHashC35, "cst"                            , "C35_CST#F3#" 	 )     
	SetHashKey(oHashC35, "mva"                            , "C35_MVA" 		 )     
	SetHashKey(oHashC35, "percentageReduction"            , "C35_REDBC" 	 )     
	SetHashKey(oHashC35, "calculationBase"                , "C35_BASE" 		 )     
	SetHashKey(oHashC35, "calculationBaseNotTaxed"        , "C35_BASENT"	 )     
	SetHashKey(oHashC35, "taxRate"                        , "C35_ALIQ" 		 )     
	SetHashKey(oHashC35, "taxValue"                       , "C35_VALOR" 	 )     
	SetHashKey(oHashC35, "exemptValue"                    , "C35_VLISEN" 	 )     
	SetHashKey(oHashC35, "otherValue"                     , "C35_VLOUTR" 	 )     
	SetHashKey(oHashC35, "nonTaxedValue"                  , "C35_VLNT" 		 )     
	SetHashKey(oHashC35, "valueWithoutCredit"             , "C35_VLSCRE" 	 )     
	SetHashKey(oHashC35, "subContractServiceValue"        , "C35_VLSCON" 	 )     
	SetHashKey(oHashC35, "addRetentionAmount"             , "C35_VLRADI" 	 )     
	SetHashKey(oHashC35, "UnpaidRetentionAmount"          , "C35_VLRNPG" 	 )     
	SetHashKey(oHashC35, "serviceValueSpecialCondition15A", "C35_VLCE15" 	 )     
	SetHashKey(oHashC35, "serviceValueSpecialCondition20A", "C35_VLCE20" 	 )     
	SetHashKey(oHashC35, "serviceValueSpecialCondition25A", "C35_VLCE25" 	 )     
	SetHashKey(oHashC35, "addUnpaidRetentionAmount"       , "C35_VLRANP" 	 )     

	HMSet(oHashC35, '#F3#C35_CODTRI', "GetIDCache( 'C3S', jData['taxCode'] , 1 ,oHashC3S)" ) 
	HMSet(oHashC35, '#F3#C35_CST'   , "ValCodCst(jData['cst'], GetIDCache( 'C3S', jData['taxCode'] , 1 ,oHashC3S) )" )

Return oHashC35

//---------------------------------------------------------------------
/*/{Protheus.doc} HshC39
@type			function
@description	Monta o hash da C39
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@return			Nil
/*/
//---------------------------------------------------------------------
Function HshC39()

	Local oHashC39 := NIL as object	

	oHashC39 := HMNew()

	SetHashKey(oHashC39, "originFUCode"   , "C39_UFORIG" 	 ) 	   
	SetHashKey(oHashC39, "originFUCode"   , "C39_UFORIG#F3#" ) 
	SetHashKey(oHashC39, "originCityCode" , "C39_CMUNOR" 	 ) 	   
	SetHashKey(oHashC39, "originCityCode" , "C39_CMUNOR#F3#" ) 
	SetHashKey(oHashC39, "destinyFUCode"  , "C39_UFDEST" 	 ) 	   
	SetHashKey(oHashC39, "destinyFUCode"  , "C39_UFDEST#F3#" ) 
	SetHashKey(oHashC39, "destinyCityCode", "C39_CMUNDE" 	 ) 	   
	SetHashKey(oHashC39, "destinyCityCode", "C39_CMUNDE#F3#" ) 

	HMSet(oHashC39,'#F3#C39_UFORIG',"GetIDCache( 'C09', jData['originFUCode'] , 1 ,oHashC09)")  
	HMSet(oHashC39,'#F3#C39_CMUNOR',"GetIDCache( 'C07', jData['originFUCode'] + jData['originCityCode'],1,oHashC07)")   
	HMSet(oHashC39,'#F3#C39_UFDEST',"GetIDCache( 'C09', jData['destinyFUCode'] , 1 ,oHashC09)") 
	HMSet(oHashC39,'#F3#C39_CMUNDE',"GetIDCache( 'C07', jData['destinyFUCode'] + jData['destinyCityCode'] , 1 ,oHashC07)") 

Return oHashC39

//---------------------------------------------------------------------
/*/{Protheus.doc} HashT9Q
@type			function
@description	Monta o hash da T9Q
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@return			Nil
/*/
//---------------------------------------------------------------------
Function HshT9Q()

	Local oHashT9Q   := NIL as object	
	Local cTamCodSus := ''  as character 
	Local cTamVers   := ''  as character 
	Local cTamPro    := ''  as character

	oHashT9Q := HMNew( )
	cTamCodSus := lTrim(cValToChar(GetSx3Cache('T5L_CODSUS','X3_TAMANHO'))) 
	cTamVers   := lTrim(cValToChar(GetSx3Cache('C1G_VERSAO','X3_TAMANHO'))) 
	cTamPro    := lTrim(cValToChar(GetSx3Cache('C1G_NUMPRO','X3_TAMANHO')))  

	SetHashKey(oHashT9Q, "processNumber"          , "T9Q_NUMPRO" 	) 	   
	SetHashKey(oHashT9Q, "processNumber"          , "T9Q_NUMPRO#F3#") 
	SetHashKey(oHashT9Q, "typeOfProcess"          , "T9Q_TPPROC" 	) 	   
	SetHashKey(oHashT9Q, "suspensionCode"         , "T9Q_IDSUSP" 	) 	   
	SetHashKey(oHashT9Q, "suspensionCode"         , "T9Q_IDSUSP#F3#") 
	SetHashKey(oHashT9Q, "tributeCode"            , "T9Q_CODTRI" 	)     
	SetHashKey(oHashT9Q, "tributeCode"            , "T9Q_CODTRI#F3#") 
	SetHashKey(oHashT9Q, "retentionValue"         , "T9Q_VALSUS"	)     
	If TAFColumnPos("T9Q_BSSUSP")
		SetHashKey(oHashT9Q, "baseValueOfSuspendedTax", "T9Q_BSSUSP") 
	EndIf	

	HMSet(oHashT9Q, '#F3#T9Q_NUMPRO', "GetIDCache( 'C1G', padr(jData['processNumber']," + cTamPro + "), 1 ,oHashC1G)" ) 
	HMSet(oHashT9Q, '#F3#T9Q_CODTRI', "GetIDCache( 'C3S', jData['tributeCode'], 1 ,oHashC3S)" ) 
	HMSet(oHashT9Q, '#F3#T9Q_IDSUSP', "GetIDCache( 'C1G', padr(jData['processNumber']," + cTamPro + "), 1 ,oHashC1G) + padr(alltrim(jData['versionSuspensionCode'])," + cTamVers + ") + padr(alltrim(jData['suspensionCode'])," + cTamCodSus + ") " )

Return oHashT9Q

//---------------------------------------------------------------------
/*/{Protheus.doc} HashC2F
@type			function
@description	Monta o hash da C2F
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@return			Nil
/*/
//---------------------------------------------------------------------
Function HshC2F()

	Local oHashC2F := NIL as object

	oHashC2F := HMNew()

	//campos dos tributos capa documento fiscal "valuesByTax"
	SetHashKey(oHashC2F, "taxCode"                 , "C2F_CODTRI" 	 )    	   
	SetHashKey(oHashC2F, "taxCode"                 , "C2F_CODTRI#F3#")    
	SetHashKey(oHashC2F, "calculationBase"	       , "C2F_BASE" 	 )          
	SetHashKey(oHashC2F, "calculationBaseAmount"   , "C2F_BASEQT" 	 )        
	SetHashKey(oHashC2F, "calculationBaseNotTaxed" , "C2F_BASENT" 	 )        
	SetHashKey(oHashC2F, "taxValue"                , "C2F_VALOR" 	 )         
	SetHashKey(oHashC2F, "taxBaseValue"            , "C2F_VLRPAU" 	 )        
	SetHashKey(oHashC2F, "exemptValue"             , "C2F_VLISEN" 	 )        
	SetHashKey(oHashC2F, "otherValue"              , "C2F_VLOUTR" 	 )        
	SetHashKey(oHashC2F, "nonTaxedValue"           , "C2F_VLNT" 	 )          
	SetHashKey(oHashC2F, "cst"                     , "C2F_CST" 	  	 )       	   
	SetHashKey(oHashC2F, "cst"                     , "C2F_CST#F3#" 	 )       
	SetHashKey(oHashC2F, "cfop"                    , "C2F_CFOP" 	 )      	   
	SetHashKey(oHashC2F, "cfop"                    , "C2F_CFOP#F3#"  )      
	SetHashKey(oHashC2F, "taxRate"                 , "C2F_ALIQ" 	 )          
	SetHashKey(oHashC2F, "serviceCode"             , "C2F_CODSER" 	 )    	   
	SetHashKey(oHashC2F, "serviceCode"             , "C2F_CODSER#F3#")    
	SetHashKey(oHashC2F, "operationValue"          , "C2F_VLOPE" 	 )    
	SetHashKey(oHashC2F, "previousICMSSTvalue" , "C2F_CREDST" 	 )     

	If TAFColumnPos( "C2F_VLSCRE" ) //protecao conforme TafLayout
		SetHashKey(oHashC2F, "valueWithoutCredit"  , "C2F_VLSCRE" 	 )        
	EndIf

	HMSet(oHashC2F, '#F3#C2F_CODTRI', "GetIDCache( 'C3S', jData['taxCode'] , 1 ,oHashC3S)")  
	HMSet(oHashC2F, '#F3#C2F_CST'   , "ValCodCst(jData['cst'], jData['taxCode'])")               
	HMSet(oHashC2F, '#F3#C2F_CFOP'  , "GetIDCache( 'C0Y', jData['cfop'] , 1 ,oHashC0Y)")     
	HMSet(oHashC2F, '#F3#C2F_CODSER', "GetIDCache( 'C0B', cValToChar(Val(StrTran(jData['serviceCode'],'.'))) , 1 ,oHashC0B)" )

Return oHashC2F

//---------------------------------------------------------------------
/*/{Protheus.doc} GetIDCache
@type			static function
@description	Busca o _ID de cada consulta F3 no cache da tabela e caso não encontre, 
				pesquisa diretamente na tabela e alimenta o cache para uma próxima busca.
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@param          cAlias - Alias da tabela
@param          cChave - Chave da tabela
@param          nIndex - Indice da tabela
@param          oHash - Hash do alias
@return			cRet
/*/
//---------------------------------------------------------------------
Function GetIDCache( cAlias, cChave, nIndex, oHash )
	Local   cRet := ''
	Default cAlias := ''
	Default cChave := ''
	Default nIndex := 0

	If ValType(oHash) == "O"
		HMGet( oHash, cChave, @cRet )
		If Empty(cRet)
			cRet := GetTafId( cAlias, cChave, nIndex, oHash )
			SetHashKey(oHash, cChave, cRet)
		Endif
	EndIf

Return cRet

//---------------------------------------------------------------------
/*/{Protheus.doc} ValCodMod
@type			static function
@description	Retorna o código do modelo 
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@param          cCodMod - Código do modelo
@return			cCodMod
/*/
//---------------------------------------------------------------------
static function ValCodMod(cCodMod)
	Default cCodMod := ''
	If empty(cCodMod)
		cCodMod := '000001'
	EndIf
return cCodMod

//---------------------------------------------------------------------
/*/{Protheus.doc} ValCodCst
@type			static function
@description	Ajusta o codigo do cst
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@param          cCodCst - Código CST; cIDTrib - Id do Tributo
@return			Nil
/*/
//---------------------------------------------------------------------
static function ValCodCst(cCodCst,cIDTrib)

	Local cAliasCst := "" as character

	Default cCodCst := ""
	Default cIDTrib := ""

	If !empty(cIDTrib)
		cAliasCst	:= XFUNChgF3(,,,cIdTrib) //Consulta tabela específica conforme o tributo.
	EndIf

	If cCodCst == "0  " //mantem o mesmo mecanismo do extrator fiscal
		cCodCst := '00 '
	EndIf
	If !Empty(cAliasCst)
		cCodCst := alltrim(Posicione( cAliasCst , 1 , xFilial( cAliasCst ) + cCodCst , cAliasCst+'_ID' ))
	EndIf

return cCodCst

//---------------------------------------------------------------------
/*/{Protheus.doc} KeyIndex
@type			Monta o indice da C20
@description	Ajusta o codigo do cst
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@return			Nil
/*/
//---------------------------------------------------------------------
static function KeyIndex(jData as json, oHashC1H as object)

	Local cKey := "" as character

	Default jData := {}

	cKey := padr(jData['operationType'],_nTmINDOPE)
	cKey += ValCodMod(padr(GetIDCache('C01',jData['modelIdentificationCode'],1,oHashC01),_nTmCODMOD))
	cKey += padr(jData['taxDocumentSeries'],_nTmSERIE)
	cKey += padr('',_nTmSUBSER)
	cKey += padr(jData['taxDocumentNumber'],_nTmNUMDOC)
	cKey += padr(DTOS(CTOD(jData['fiscalDocumentDate'])),_nTmDTDOC)
	cKey += padr(GetIDCache('C1H',jData['participatingCode'],1,oHashC1H),_nTmCODPAR)

return cKey

//---------------------------------------------------------------------
/*/{Protheus.doc} KeyLogs
@type			Monta as chaves 
@description	Ajusta o codigo do cst
@author			Carlos Pister
@since			07/03/2025
@version		1.0
@return			Nil
/*/
//---------------------------------------------------------------------
static function KeyLogs(jData as json, oHash as object, cKeyERP as character, cKeyV5r as character)

	Default cKeyERP := ""
	Default cKeyV5r := ""
	Default jData := {}

	cKeyERP := jData['operationType'] + '|'
	cKeyERP += padr(DTOS(CTOD(jData['fiscalDocumentDate'])),_nTmDTDOC) + '|'
	cKeyERP += padr(jData['taxDocumentSeries'],_nTmSERIE) + '|'
	cKeyERP += padr(jData['taxDocumentNumber'],_nTmNUMDOC) + '|'
	cKeyERP += SubStr(LTrim(jData['participatingCode']), 2, _nTmCliFor) + '|'
	cKeyERP += Right(RTrim(jData['participatingCode']), _nTmLoja)

	cKeyV5r := padr(jData['modelIdentificationCode'],_nTmCODMOD)
	cKeyV5r += padr(jData['operationType'],_nTmINDOPE)
	cKeyV5r += padr(jData['documentType'], GetSx3Cache( 'C20_TPDOC','X3_TAMANHO'))
	cKeyV5r += padr(jData['taxDocumentIssuer'], GetSx3Cache( 'C20_INDEMI','X3_TAMANHO'))
	cKeyV5r += padr(jData['participatingCode'], _nTmCODPAR)
	cKeyV5r += padr(jData['identificationSituation'], GetSx3Cache( 'C20_CODSIT','X3_TAMANHO'))
	cKeyV5r += padr(jData['taxDocumentSeries'],_nTmSERIE)
	cKeyV5r += padr('',_nTmSUBSER)
	cKeyV5r += padr(jData['taxDocumentNumber'],_nTmNUMDOC)
	cKeyV5r += padr(DTOS(CTOD(jData['fiscalDocumentDate'])),_nTmDTDOC)
	cKeyV5r += padr(DTOS(CTOD(jData['taxDocumentEntryAndExitDate'])), GetSx3Cache( 'C20_DTES','X3_TAMANHO'))

Return
