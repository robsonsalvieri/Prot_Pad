#INCLUDE 'APWEBEX.CH'
#INCLUDE "APWEBSRV.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "AP5MAIL.CH"
#Include "topconn.ch"

#DEFINE DIRRAIZ 	PLSMUDSIS( GetNewPar("MV_TISSDIR","\TISS\") )
#DEFINE DIRONLINE 	PLSMUDSIS( "ONLINE\" )
#DEFINE DIRSUBRAI 	DIRRAIZ+DIRONLINE
#DEFINE DIRCAISA  	PLSMUDSIS( DIRSUBRAI+"CAIXASAIDA\" )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³PLSXFUN   ³ Autor ³Alexander Santos       ³ Data ³28.03.2006  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Web Service das funcionalidades do Plano de Saude.           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas da composicao da solicitacao.			       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatCompGui
	WSDATA RdaCode	 		AS String  OPTIONAL //Codigo da Rda
	WSDATA NomeUsu	 		AS String  OPTIONAL //Nome do usuario
	WSDATA DtGui	 		AS String  OPTIONAL //Data da Guia
	WSDATA CodTab	 		AS String  OPTIONAL //Tabela
	WSDATA CodPro	 		AS String  OPTIONAL //Codigo do Procedimento
	WSDATA DesPro	 		AS String  OPTIONAL //Descricao do Procedimento
	WSDATA QtdSol			AS String  OPTIONAL //Quantidade Solicitada
	WSDATA QtdRea			AS String  OPTIONAL //Quantidade Realizada
	WSDATA QtdSal			AS String  OPTIONAL //Quantidade Saldo
	WSDATA StaAud			AS String  OPTIONAL //Status do Auditoria
	WSDATA StaPro			AS String  OPTIONAL //Status do procedimento
	WSDATA StaGui			AS String  OPTIONAL //Status da Guia
	WSDATA Cancel			AS String  OPTIONAL //Cancelada
	WSDATA OnLine			AS String  OPTIONAL //Guia Online
	WSDATA MatCri			AS Array Of GenericStruct OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas do BD6										   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatBD6
	WSDATA seqinf	 		AS String  OPTIONAL //Sequencia informada
	WSDATA sequen	 		AS String  OPTIONAL //Sequencia gravada
	WSDATA codpad	 		AS String  OPTIONAL //CodPad
	WSDATA codpro	 		AS String  OPTIONAL //CodPro
	WSDATA qtdpro	 		AS Integer OPTIONAL //QtdPro
	WSDATA orimov	 		AS String  OPTIONAL //OriMov
	WSDATA procci	 		AS String  OPTIONAL //ProcCi
	WSDATA recno	 		AS Integer OPTIONAL //Recno
	WSDATA denreg			AS String  OPTIONAL //Denreg
	WSDATA fadent			AS String  OPTIONAL //FadEnt
	WSDATA datpro			AS Date    OPTIONAL //DatPro
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas do pre-atendimento							   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatPre
	WSDATA Matric	 		AS String  OPTIONAL //Matricula
	WSDATA CodUsr	 		AS String  OPTIONAL //Codigo de usuario web
	WSDATA NomeUsu	 		AS String  OPTIONAL //Nome do usuario
	WSDATA OpeRda	 		AS String  OPTIONAL //Operadora da rda
	WSDATA CodRda	 		AS String  OPTIONAL //Codigo da rda
	WSDATA NomRda	 		AS String  OPTIONAL //Nome da rda
	WSDATA CodLoc	 		AS String  OPTIONAL //LOCAL de atendimento
	WSDATA Trilha	 		AS String  OPTIONAL //Trilha Cartao
	WSDATA TpAca			AS String  OPTIONAL //Tipo de acao inclusao/alteracao/exclusao
	WSDATA TissVer			AS String  OPTIONAL //versao tiss
	WSDATA CodRdaOld 		AS String  OPTIONAL //Codigo da rda antes da alteração
	WSDATA CodLocOld		AS String  OPTIONAL //LOCAL de atendimento antes da alteração
	WSDATA OrdResult		AS String  OPTIONAL //Ordenação do resultado Pre-Atendimento (Desc/Asc)
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas do co-participacao							   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatVlr
	WSDATA ExibeCo	 			AS String  OPTIONAL //Se exibe a co-participacao
	WSDATA ExibeBa	 			AS String  OPTIONAL //Se exibe a Base da co-participacao
	WSDATA GuiAco	 			AS String  OPTIONAL //Guia Comprada
	WSDATA PagRDA				AS String  OPTIONAL //Pagamento da Rda
	WSDATA VlrPF	 				AS Float   OPTIONAL //Valor PF
	WSDATA VlrBPF				AS Float   OPTIONAL //Valor Base PF
	WSDATA PercPF	 			AS Float   OPTIONAL //Valor Percentual PF
	WSDATA VlrTPF	 			AS Float   OPTIONAL //Valor Total PF
	WSDATA VlrTAD	 			AS Float   OPTIONAL //Valor Taxa
	WSDATA Msg001	 			AS String  OPTIONAL //"Valor da Co-Participacao&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	WSDATA Msg002	 			AS String  OPTIONAL //"Valor a ser pago direto a rede de atendimento&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
	WSDATA Msg003	 			AS String  OPTIONAL //"Valor da Co-Participacao&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
	WSDATA Msg004	 			AS String  OPTIONAL //"Valor da Compra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
	WSDATA Msg005	 			AS String  OPTIONAL //"Valor da Taxa Administracao&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
	WSDATA Msg006	 			AS String  OPTIONAL //"Valor Total da Co-Participacao&nbsp;R$:&nbsp;")
	WSDATA Msg007	 			AS String  OPTIONAL //"Valor total a ser pago direto a rede de atendimento&nbsp;R$:&nbsp;")
	WSDATA Msg008	 			AS String  OPTIONAL //"Valor Total da Co-Participacao&nbsp;R$:&nbsp;")
	WSDATA Msg009	 			AS String  OPTIONAL //"Valor Total da Compra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
	WSDATA Msg010	 			AS String  OPTIONAL //"(*) Nao inclui valores de materiais e medicamentos.&nbsp;")
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas do pre-atendimento							   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SRetMatPre
	WSDATA Matric	 		AS String OPTIONAL 	//Nome do Usuario
	WSDATA NomeUsu	 		AS String OPTIONAL 	//Nome do Usuario
	WSDATA Rda		 		AS String OPTIONAL 	//Nome do Usuario
	WSDATA NomeRda	 		AS String OPTIONAL 	//Nome da Rda
	WSDATA CodLoc	 		AS String  OPTIONAL //LOCAL de atendimento
	WSDATA DatChe	 		AS Date OPTIONAL 	//Data de chegada
	WSDATA HorChe	 		AS String OPTIONAL 	//Hora de Chegada
	WSDATA Msg		 		AS String OPTIONAL 	//Mensagem
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para profissiona de saude			   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT RtProfSaud
	WSDATA ListProfSaud			AS Array Of ProfSaud OPTIONAL
	WSDATA ListPfSExe			AS Array Of ProfSaud OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para profissiona de saude			   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT ProfSaud
	WSDATA Code	 				AS String OPTIONAL //Codigo do Profissional de Saude
	WSDATA Name					AS String OPTIONAL //Nome do profissional de Saude
	WSDATA CodSig				AS String OPTIONAL //Sigla CRM
	WSDATA NumCr				AS String OPTIONAL //Numero CRM
	WSDATA Estado				AS String OPTIONAL //Estado CRM
	WSDATA CpfCnpj				AS String OPTIONAL //Cpf ou Cnpj
	WSDATA CodOpe				AS String OPTIONAL //Operadora
	WSDATA Especi				AS Array Of GenericStruct OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de entrada de dados do web service							   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMITE
	WSDATA CodOpe				AS String OPTIONAL
	WSDATA AnoAut				AS String OPTIONAL
	WSDATA MesAut				AS String OPTIONAL
	WSDATA AliMov				AS String OPTIONAL
	WSDATA NumAut				AS String OPTIONAL
	WSDATA SeqProc				AS String OPTIONAL
	WSDATA TpPublico			AS String OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de entrada de dados do web service							   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMProDad
	WSDATA CodPad				AS String OPTIONAL
	WSDATA CodPro				AS String OPTIONAL
	WSDATA VlrPro				AS String OPTIONAL
	WSDATA CodRda				AS String OPTIONAL
	WSDATA Data	  				AS Date   OPTIONAL
	WSDATA CodLoc				AS String OPTIONAL
	WSDATA TpPrest				AS String OPTIONAL
	WSDATA TpServ				AS String OPTIONAL
	WSDATA TpProc				AS String OPTIONAL
	WSDATA qtdpro	 			AS Integer OPTIONAL //QtdPro
	WSDATA TissVer	 			AS String OPTIONAL //QtdPro
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de matriz MSDadRda											   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT MSDadRda
	WSDATA Code					AS String OPTIONAL 			//Codigo da RDA
	WSDATA Name					AS String OPTIONAL 			//Nome da RDA
	WSDATA CnpfCpf				AS String OPTIONAL 			//Cnpj ou Cpf
	WSDATA Cnes					AS String OPTIONAL 			//Codigo CNES
	WSDATA CodProf				AS String OPTIONAL 			//Codigo do Profissional
	WSDATA CodOpe				AS String OPTIONAL 			//Operadora
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de matriz de combos											   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT MSCombo
	WSDATA CodPad				AS String OPTIONAL
	WSDATA CbTpDoe		        AS Array Of GenericStruct OPTIONAL
	WSDATA CbTmpDoe		        AS Array Of GenericStruct OPTIONAL
	WSDATA CbIndAcid	        AS Array Of GenericStruct OPTIONAL
	WSDATA CbTpCon		        AS Array Of GenericStruct OPTIONAL
	WSDATA CbTpSai		        AS Array Of GenericStruct OPTIONAL
	WSDATA CbCarSolict			AS Array Of GenericStruct OPTIONAL
	WSDATA CbTpAtend			AS Array Of GenericStruct OPTIONAL
	WSDATA CbTpAtOD				AS Array Of GenericStruct OPTIONAL
	WSDATA CbViaAce		        AS Array Of GenericStruct OPTIONAL
	WSDATA CbTecUti		        AS Array Of GenericStruct OPTIONAL
	WSDATA CbGraPart			AS Array Of GenericStruct OPTIONAL
	WSDATA CbTpPreAte			AS Array Of GenericStruct OPTIONAL
	WSDATA CbTpInter			AS Array Of GenericStruct OPTIONAL
	WSDATA CbRegInter			AS Array Of GenericStruct OPTIONAL
	WSDATA CbTipGui				AS Array Of GenericStruct OPTIONAL
	WSDATA CbTipFat				AS Array Of GenericStruct OPTIONAL

	WSDATA CbCategoria			AS Array Of GenericStruct OPTIONAL
	WSDATA CbSexo				AS Array Of GenericStruct OPTIONAL
	WSDATA CbEstCiv				AS Array Of GenericStruct OPTIONAL
	WSDATA CbEstado				AS Array Of GenericStruct OPTIONAL
	WSDATA CbCidade				AS Array Of GenericStruct OPTIONAL
	WSDATA CbTipLog				AS Array Of GenericStruct OPTIONAL
	WSDATA CbStatus				AS Array Of GenericStruct OPTIONAL
	WSDATA CbSituac				AS Array Of GenericStruct OPTIONAL
	WSDATA CbOperac				AS Array Of GenericStruct OPTIONAL
	WSDATA CbTipo				AS Array Of GenericStruct OPTIONAL
	WSDATA CbSitCad				AS Array Of GenericStruct OPTIONAL
	WSDATA CbGeneric			AS Array Of GenericStruct OPTIONAL
	WSDATA CbMotCar				AS Array Of GenericStruct OPTIONAL
	WSDATA CbMotBlo				AS Array Of GenericStruct OPTIONAL
	WSDATA CbGrauPa				AS Array Of GenericStruct OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de matriz de parametros										   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT MSParam
	WSDATA LinkProfi			AS String OPTIONAL
	WSDATA LinkProdu			AS String OPTIONAL
	WSDATA LinkPriAc			AS String OPTIONAL
	WSDATA TimeAte				AS Boolean OPTIONAL

	WSDATA LogProd				AS Boolean OPTIONAL
	WSDATA Unimeds				AS Boolean OPTIONAL
	WSDATA SmtpEnv				AS String OPTIONAL
	WSDATA UsuEmai				AS String OPTIONAL
	WSDATA UsuPass				AS String OPTIONAL
	WSDATA AprNImp				AS String OPTIONAL
	WSDATA CodCons				AS String OPTIONAL
	WSDATA Diagno				AS Boolean OPTIONAL
	WSDATA FiltPRF				AS Boolean OPTIONAL
	WSDATA PreAten				AS Boolean OPTIONAL
	WSDATA UsuProc				AS String OPTIONAL
	WSDATA ChaGe				AS String OPTIONAL
	WSDATA MatrAnt				AS Boolean OPTIONAL
	WSDATA ValParam				AS String OPTIONAL
	WSDATA MVQTDIARQ			AS String OPTIONAL
	WSDATA MVLOGSCHE			AS String OPTIONAL
	WSDATA MosGui				AS Boolean OPTIONAL
	WSDATA CodOff				AS String OPTIONAL
	WSDATA POGTISS				AS Boolean OPTIONAL
	WSDATA Baixar				AS String OPTIONAL
	WSDATA VldOpc				AS Boolean OPTIONAL
	WSDATA RecOb				AS String OPTIONAL
	WSDATA MultComp				AS String OPTIONAL
	WSDATA TourReemb			AS String OPTIONAL
	WSDATA TitPar				AS String OPTIONAL
	WSDATA MVLRN360				AS String OPTIONAL
	WSDATA PL395WS				AS Boolean OPTIONAL
	WSDATA PLSDRDA				AS String OPTIONAL
	WSDATA PLCMPFP				AS String OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de matriz de combos											   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT MSDadESP
	WSDATA CodPad				AS String OPTIONAL
	WSDATA DadRdaTp				AS Array Of MSDadRda OPTIONAL
	WSDATA CbGraPar				AS Array Of GenericStruct OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura para retorno da autorizacao de um procedimento				   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatRetAutProc
	WSDATA ProAut				AS Boolean 	OPTIONAL				//Autorizado sim ou nao
	WSDATA Nivel				AS String 	OPTIONAL				//Nivel da autorizacao ou da negativa
	WSDATA TpProc				AS String 	OPTIONAL				//Tipo de Procedimento, resgatado da tabela BR8
	WSDATA Chave				AS String 	OPTIONAL				//Chave
	WSDATA Autori				AS String 	OPTIONAL				//Autori com base no BR8
	WSDATA PosBD6				AS Integer 	OPTIONAL				//Posicao da matriz aMatBD6
	WSDATA SeqInf				AS String 	OPTIONAL				//Sequencia informada
	WSDATA MatRetRes			AS String 	OPTIONAL				//String com o retorno campo a campo conforme matriz solicitada. deve ser separada por # para campos e ";" para campo valor
	WSDATA MatCri				AS Array Of GenericStruct OPTIONAL 	//Criticas da autorizacao
	WSDATA Lembrete				AS String OPTIONAL				//Lembrete da BR8
	WSDATA Alerta				AS Array Of GenericStruct OPTIONAL 	//Alertas do procedimento
	WSDATA NumGui				AS String   OPTIONAL
	WSDATA Impede				AS Boolean	OPTIONAL				//Critica de/para tiss
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura da matriz de retorno de Interação
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SViewInteracao
	WSDATA SeqInt				AS String OPTIONAL
	WSDATA SeqMop				AS String OPTIONAL
	WSDATA DesMop				AS String OPTIONAL
	WSDATA RespPrest			AS String OPTIONAL
	WSDATA Setor  				AS String OPTIONAL
	WSDATA DtIteracao  			AS Date OPTIONAL
	WSDATA ResPre  				AS Boolean OPTIONAL
	WSDATA Observacao 			AS String OPTIONAL
	WSDATA AliasPai				AS String OPTIONAL
	WSDATA Anexado 			    AS Boolean OPTIONAL
	WSDATA TipDirec 			AS String OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura da matriz de retorno do Log de Acesso					   	   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SViewHistLog
	WSDATA DataAc				AS String OPTIONAL
	WSDATA HoraAc				AS String OPTIONAL
	WSDATA EstacaoAc			AS String OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura da matriz de parametros do Log de Acesso					   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SViewPar
	WSDATA CodLog				AS String OPTIONAL
	WSDATA DateDe				AS String OPTIONAL
	WSDATA DateAte				AS String OPTIONAL
	WSDATA HorDe				AS String OPTIONAL
	WSDATA HorAte				AS String OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura da matriz de Criticas										   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT UserCardCri
	WSDATA DesPri				AS String OPTIONAL
	WSDATA DesSeq				AS String OPTIONAL
	WSDATA DesTer				AS String OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de matriz do cabecalho da guia								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT MCabGui
	WSDATA Rda					AS String OPTIONAL
	WSDATA CodLoc				AS String OPTIONAL
	WSDATA RegAns				AS String OPTIONAL
	WSDATA NomeRda				AS String OPTIONAL
	WSDATA CnpjCpfSol 			AS String OPTIONAL
	WSDATA CnesSol      		AS String OPTIONAL
	WSDATA TpLograd				AS String OPTIONAL
	WSDATA Endereco				AS String OPTIONAL
	WSDATA Numero				AS String OPTIONAL
	WSDATA Complemento			AS String OPTIONAL
	WSDATA Municipio			AS String OPTIONAL
	WSDATA Bairro				AS String OPTIONAL
	WSDATA Estado				AS String OPTIONAL
	WSDATA IBGE					AS String OPTIONAL
	WSDATA Cep					AS String OPTIONAL
	WSDATA Tel   				AS String OPTIONAL
	WSDATA DtAut				AS Date   OPTIONAL
	WSDATA HrAut				AS String OPTIONAL
	WSDATA TipAut				AS String OPTIONAL
	WSDATA Senha				AS String OPTIONAL
	WSDATA DtValid				AS Date   OPTIONAL
	WSDATA DtSolicit			AS Date   OPTIONAL
	WSDATA HrSolicit			AS String OPTIONAL
	WSDATA CarSolicit			AS String OPTIONAL
	WSDATA Cid					AS String OPTIONAL
	WSDATA Cid2					AS String OPTIONAL
	WSDATA Cid3					AS String OPTIONAL
	WSDATA Cid4					AS String OPTIONAL
	WSDATA ProSol				AS String OPTIONAL
	WSDATA OpeSol				AS String OPTIONAL
	WSDATA NomeSol				AS String OPTIONAL
	WSDATA CodSigSol			AS String OPTIONAL
	WSDATA NumCrSol				AS String OPTIONAL
	WSDATA EstSigSol			AS String OPTIONAL
	WSDATA CbosSol				AS String OPTIONAL
	WSDATA DescCbosSol			AS String OPTIONAL
	WSDATA ProExe				AS String OPTIONAL
	WSDATA OpeExe				AS String OPTIONAL
	WSDATA NomeExe				AS String OPTIONAL
	WSDATA CodSigExe			AS String OPTIONAL
	WSDATA NumCrExe				AS String OPTIONAL
	WSDATA EstSigExe			AS String OPTIONAL
	WSDATA obs		    		AS String OPTIONAL
	WSDATA Matric	    		AS String OPTIONAL
	WSDATA NomeUsr	    		AS String OPTIONAL
	WSDATA STAut	    		AS String OPTIONAL
	WSDATA DesSTAut	    		AS String OPTIONAL
	WSDATA IndCli	    		AS String OPTIONAL
	WSDATA NumImp	    		AS String OPTIONAL
	WSDATA Origem	    		AS String OPTIONAL
	WSDATA ChvBD6	    		AS String OPTIONAL
	WSDATA TipAto	    		AS String OPTIONAL
	WSDATA TipFat	    		AS String OPTIONAL
	WSDATA TpIntern	    		AS String OPTIONAL
	WSDATA RegInter	    		AS String OPTIONAL
	WSDATA QtdDSol	    		AS String OPTIONAL
	WSDATA TipDoe	    		AS String OPTIONAL
	WSDATA TmpDoe	    		AS String OPTIONAL
	WSDATA UndDoe	    		AS String OPTIONAL
	WSDATA IndAcid	    		AS String OPTIONAL
	WSDATA DPrAH  				AS Date   OPTIONAL
	WSDATA QtdDAut				AS String OPTIONAL
	WSDATA QtdDPro				AS String OPTIONAL
	WSDATA TpAcom				AS String OPTIONAL
	WSDATA DesAcom				AS String OPTIONAL
	WSDATA PadCon				AS String OPTIONAL
	WSDATA CnpjSolT				AS String OPTIONAL
	WSDATA NomeSolT				AS String OPTIONAL
	WSDATA CnesSolT				AS String OPTIONAL
	WSDATA RdaSolT				AS String OPTIONAL
	WSDATA ProfSolT				AS String OPTIONAL
	WSDATA OpeSolT				AS String OPTIONAL
	WSDATA DatInt  				AS Date   OPTIONAL
	WSDATA DatAlt  				AS Date   OPTIONAL
	WSDATA HorAlt  				AS String OPTIONAL
	WSDATA Cancel  				AS String OPTIONAL
	WSDATA FindEvo 				AS String OPTIONAL
	WSDATA NomPla 				AS String OPTIONAL
	WSDATA DtVldCar     		AS Date   OPTIONAL
	WSDATA CarSaud      		AS String OPTIONAL
	WSDATA GrPar      			AS String OPTIONAL
	WSDATA Peso      			AS String OPTIONAL
	WSDATA Altura      			AS String OPTIONAL
	WSDATA Idade      			AS String OPTIONAL
	WSDATA Sexo      			AS String OPTIONAL
	WSDATA AteRN				AS String OPTIONAL	//Se e recen nascido
	WSDATA IniFat      			AS Date   OPTIONAL
	WSDATA FimFat      			AS Date   OPTIONAL
	WSDATA PrvOpm      			AS String OPTIONAL
	WSDATA PrvQui      			AS String OPTIONAL
	WSDATA DtRlz 				AS String OPTIONAL
	WSDATA DtRlz2				AS String OPTIONAL
	WSDATA DtRlz3				AS String OPTIONAL
	WSDATA DtRlz4				AS String OPTIONAL
	WSDATA DtRlz5				AS String OPTIONAL
	WSDATA DtRlz6				AS String OPTIONAL
	WSDATA DtRlz7				AS String OPTIONAL
	WSDATA DtRlz8				AS String OPTIONAL
	WSDATA DtRlz9				AS String OPTIONAL
	WSDATA DtRlz1				AS String OPTIONAL
	WSDATA TipAte				AS String OPTIONAL
	WSDATA TipCon				AS String OPTIONAL
	WSDATA IndAci				AS String OPTIONAL
	WSDATA TipSai				AS String OPTIONAL
	WSDATA EXECCO				AS String OPTIONAL
	WSDATA RGEXCO				AS String OPTIONAL
	WSDATA CCPECO				AS String OPTIONAL
	WSDATA CEPCCO				AS String OPTIONAL
	WSDATA PREXCC				AS STRING OPTIONAL
	WSDATA Gralau				AS String OPTIONAL
	WSDATA Protoc  				AS String OPTIONAL
	WSDATA NumAux				as String OPTIONAL
	WSDATA GuiaOpe				as String OPTIONAL
	WSDATA cListProc			AS String OPTIONAL
	WSDATA GuiaPri				AS String OPTIONAL
	wsdata CobEspW				as String OPTIONAL 
	wsdata NomSocBn				as String OPTIONAL //Nome Social
	WSDATA cRegAtendim			AS String	OPTIONAL 	//Regime de Atendimento
	WSDATA cCobertEsp			AS String 	OPTIONAL 	//Cobertura Especial
	WSDATA cSaudeOcupac			AS String 	OPTIONAL	//Saúde Ocupacional
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de matriz do itens da guia									   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT MIteGui
	WSDATA TpServ				AS String  OPTIONAL
	WSDATA Sequencia			AS String  OPTIONAL
	WSDATA CodPad				AS String  OPTIONAL
	WSDATA CodPad_Ori			AS String  OPTIONAL
	WSDATA CodPro				AS String  OPTIONAL
	WSDATA CodPro_Ori			AS String  OPTIONAL
	WSDATA TpModAdd				AS String  OPTIONAL
	WSDATA DesPro				AS String  OPTIONAL
	WSDATA QtdSol				AS String  OPTIONAL
	WSDATA QtdAut				AS String  OPTIONAL
	WSDATA Fabric				AS String  OPTIONAL
	WSDATA VlrApr				AS Float   OPTIONAL
	WSDATA Exibe				AS String  OPTIONAL
	WSDATA Dente				AS String  OPTIONAL
	WSDATA Face					AS String  OPTIONAL
	WSDATA QtdUs				AS Float   OPTIONAL
	WSDATA VlrCon				AS Float   OPTIONAL
	WSDATA VlrTPF				AS Float   OPTIONAL
	WSDATA Autori				AS String  OPTIONAL
	WSDATA DtExe				AS Date    OPTIONAL
	WSDATA Senha				AS String  OPTIONAL
	WSDATA ResAut				AS String  OPTIONAL
	WSDATA GrPar				AS String  OPTIONAL
	WSDATA HorIni				AS String  OPTIONAL
	WSDATA HorFim				AS String  OPTIONAL
	WSDATA ViaAc				AS String  OPTIONAL
	WSDATA TecUt				AS String  OPTIONAL
	WSDATA RedAcre				AS Float   OPTIONAL
	WSDATA VlrTAp				AS Float   OPTIONAL
	WSDATA StProc				AS String  OPTIONAL
	WSDATA Diagno				AS String  OPTIONAL
	WSDATA Pacote				AS String  OPTIONAL
	WSDATA TpProc				AS String  OPTIONAL
	WSDATA SPctIteGui	       	AS Array Of MPctIteGui OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Pacotes do item da guia
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT MPctIteGui
	WSDATA CodPad				AS String  OPTIONAL
	WSDATA CodPro				AS String  OPTIONAL
	WSDATA DesPro				AS String  OPTIONAL
ENDWSSTRUCT


WSSTRUCT MExeGui

	WSDATA Sequen  				AS String OPTIONAL
	WSDATA GrPar				AS String OPTIONAL
	WSDATA	CpfExe 				AS String OPTIONAL
	WSDATA	NomExe 				AS String OPTIONAL
	WSDATA	ConReg 				AS String OPTIONAL
	WSDATA	NumCr 				AS String OPTIONAL
	WSDATA	UfCr 				AS String OPTIONAL
	WSDATA	Cbo	 				AS String OPTIONAL

ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura  Principal												   	   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatAutGui
	WSDATA SCabGui			    AS MCabGui OPTIONAL
	WSDATA SIteGui			    AS Array Of MIteGui OPTIONAL
	WSDATA SCriGui			    AS Array Of AutErrorView OPTIONAL
	WSDATA MatCri				AS Array Of GenericStruct OPTIONAL
	WSDATA SExeGui				AS Array Of MExeGui OPTIONAL
	WSDATA SetDtInt				AS String OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura  Principal												   	   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatAut
	WSDATA NumeAut			    AS String 	OPTIONAL
	WSDATA NumeInt			    AS String 	OPTIONAL
	WSDATA TipoTran			    AS String 	OPTIONAL
	WSDATA DtAut			    AS Date 	OPTIONAL
	WSDATA HrAut			    AS String 	OPTIONAL
	WSDATA Tp				    AS String 	OPTIONAL
	WSDATA TpStatus				AS String 	OPTIONAL
	WSDATA Prorrog				AS String 	OPTIONAL
	WSDATA Status			    AS String 	OPTIONAL
	WSDATA Senha			    AS String 	OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura  Principal												   	   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT UserCardView
	WSDATA CardNumber			AS String 	OPTIONAL				//Numero do cartao. (caso seja usuario de intercambio vai cadastrar na hora)
	WSDATA CardNumberOld		AS String 	OPTIONAL                //Matricula Antiga
	WSDATA CardName				AS String 	OPTIONAL				//Nome na Carteirinha
	WSDATA Interchange			AS Boolean 	OPTIONAL				//Intercambio
	WSDATA OpeOri				AS String 	OPTIONAL   				//Operadora Origem
	WSDATA Plano				AS String 	OPTIONAL				//Plano do Usuario
	WSDATA ValCar				AS Date 	OPTIONAL				//Validade da Carteirinha
	WSDATA NumCarNac			AS String 	OPTIONAL				//Numero nacional de saude
	WSDATA ViaCartao			AS Integer 	OPTIONAL				//Via do Cartao
	WSDATA LOCALCob				AS String 	OPTIONAL				//LOCAL de Cobranca
	WSDATA Abrange				AS String 	OPTIONAL				//Abrangencia
	WSDATA NatJuri				AS String 	OPTIONAL				//Naturesa juridica
	WSDATA Telefone				AS String 	OPTIONAL				//Telefone
	WSDATA NomTit				AS String 	OPTIONAL				//Nome Titular
	WSDATA NomEmp				AS String 	OPTIONAL				//Nome Empresa
	WSDATA Vida					AS String 	OPTIONAL				//Vida do usuario
	WSDATA Dig1					AS String 	OPTIONAL				//String Biometrica 1
	WSDATA Dig2					AS String 	OPTIONAL				//String Biometrica 2
	WSDATA TpAcom				AS String 	OPTIONAL				//Tipo de Acomodacao
	WSDATA DesAcom				AS String 	OPTIONAL				//Descricao da Acomodacao
	WSDATA PadCon				AS String 	OPTIONAL				//Padrao de Conforto
	WSDATA ChkBioInter			AS Boolean 	OPTIONAL				//Checa Sim ou Nao Biometria para intercambio
	WSDATA UserCritica			AS Array Of UserCardCri OPTIONAL	//Matriz de criticas do usuario
	WSDATA DatBlo               AS Date     OPTIONAL                //Data de Bloqueio do usuário
	WSDATA CritPreAtdm			AS Boolean  OPTIONAL				//permite continuar pre-atendimento mesmo com criticas
	WSDATA StatusEl             AS String   OPTIONAL                //Status Elegibilidade
	WSDATA MsnBloInter 			AS String	OPTIONAL
	WSDATA OpeANS               AS String   OPTIONAL                //Código da Operadora na ANS
	WSDATA CodNeg               AS String   OPTIONAL                //Código da Negativa da Elegibilidade
	WSDATA DesNeg               AS String   OPTIONAL                //Descrição da Negativa da Elegibilidade
	WSDATA NomSocBn				AS String 	OPTIONAL				//Nome Social do Beneficiário
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura para autorizacao de um procedimento							   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatAutProc
	WSDATA Rda					AS String 	OPTIONAL	//Codigo da RDA
	WSDATA NomRda				AS String 	OPTIONAL	//Nome da Rda
	WSDATA OpeRda				AS String 	OPTIONAL	//Operadora da RDA
	WSDATA CodLoc				AS String 	OPTIONAL	//LOCAL de Atendimento
	WSDATA Matric				AS String 	OPTIONAL	//Matricula do Usuario
	WSDATA CdpfSo				AS String 	OPTIONAL	//Codigo do profissional Solicitante
	WSDATA TipGui				AS String 	OPTIONAL	//Tipo de guia
	WSDATA PadInt				AS String 	OPTIONAL	//Tipo Acomodacao
	WSDATA PadCon				AS String 	OPTIONAL	//Padrao de Conforto
	WSDATA DatPro				AS Date 	OPTIONAL	//Data da autorizacao
	WSDATA HorPro				AS String 	OPTIONAL	//Hora da autorizacao
	WSDATA SeqMov				AS String 	OPTIONAL	//Sequencia
	WSDATA CodPad				AS String 	OPTIONAL	//Codigo da Tabela
	WSDATA CodPro				AS String 	OPTIONAL	//Codigo do Procedimento
	WSDATA QtdPro				AS Integer 	OPTIONAL	//Qtd de procedimento
	WSDATA Cid					AS String 	OPTIONAL	//Cid
	WSDATA RegAte				AS String 	OPTIONAL	//Regime de atendimento
	WSDATA RegInter				AS String 	OPTIONAL	//Regime de internacao
	WSDATA CodExe				AS String 	OPTIONAL	//Codigo do profissional Executante
	WSDATA NomExe				AS String 	OPTIONAL	//Nome do Executante
	WSDATA CodSig				AS String 	OPTIONAL 	//Sigla CRM
	WSDATA NumCr				AS String 	OPTIONAL 	//Numero CRM
	WSDATA Estado				AS String 	OPTIONAL 	//Estado CRM
	WSDATA AteRN				AS String 	OPTIONAL	//Se e recen nascido
	WSDATA Sequen				AS String 	OPTIONAL	//Sequencia
	WSDATA TipPre				AS String 	OPTIONAL	//Tipo de prestador
	WSDATA GrpInt				AS String 	OPTIONAL	//Grupo de Internacao
	WSDATA AreaAbr				AS String 	OPTIONAL	//Abrangencia
	WSDATA ChavLib				AS String 	OPTIONAL	//Chave da Guia
	WSDATA MatRet				AS String 	OPTIONAL	//String com os campos de retorno separados por #
	WSDATA TipoProc				AS String 	OPTIONAL	//Tipo de Processamento
	WSDATA Cbos				    AS String 	OPTIONAL	//Cbos Especialidade
	WSDATA ChvBD6				AS String 	OPTIONAL	//Chave BD6
	WSDATA EndCon				AS String 	OPTIONAL	//Endereco do Contratado
	WSDATA Dente				AS String 	OPTIONAL	//Dente
	WSDATA Face					AS String 	OPTIONAL	//Face
	WSDATA GrPar				AS String 	OPTIONAL	//Grau de Participacao
	WSDATA AutItem				AS Array Of AutItemView OPTIONAL //Item do formulario
	WSDATA MatBD6          		AS Array Of SMatBD6 OPTIONAL //Dados do BD6
	WSDATA StProc				AS String 	OPTIONAL	//Status do Procedimento
	WSDATA TissVer			    AS String 	OPTIONAL	//Versao Tiss da RDA
	WSDATA ValorApr			    AS String 	OPTIONAL	//Valor apresentado
	WSDATA RegAtendim			AS String	OPTIONAL 	//Regime de Atendimento
	WSDATA CobertEsp			AS String 	OPTIONAL 	//Cobertura Especial
	WSDATA SaudeOcupac			AS String 	OPTIONAL	//Saúde Ocupacional

	WSDATA CarSol				AS String   OPTIONAL    //Carater Solicitação
	WSDATA Cnes					AS String   OPTIONAL    //CNES
	WSDATA Cid2					AS String   OPTIONAL    // CID 2
	WSDATA Cid3					AS String   OPTIONAL    // CID 3
	WSDATA Cid4					AS String   OPTIONAL    // CID 4
	WSDATA Cid5					AS String   OPTIONAL    // CID 5
	WSDATA TipSai				AS String   OPTIONAL    // Tipo de Saida
	WSDATA TipFat				AS String   OPTIONAL    // Tipo de Faturamento
	WSDATA IndAci				AS String   OPTIONAL    // Indicação de Acidente
	WSDATA TipInt				AS String   OPTIONAL    // Tipo de Internação
	WSDATA NumSol				AS String   OPTIONAL    // Número Solicitação de Internação
	WSDATA NumGuiTrc			AS String   OPTIONAL    // Número Solicitação de Internação

	WSDATA CodOpe				AS String   OPTIONAL    // Número Solicitação de Internação
	WSDATA CodLdp				AS String   OPTIONAL    // Número Solicitação de Internação
	WSDATA CodPeg				AS String   OPTIONAL    // Número Solicitação de Internação
	WSDATA Numero			    AS String   OPTIONAL    // Número Solicitação de Internação

	WSDATA DtIniF 				AS String   OPTIONAL    // Data de Inicio do Faturamento
	WSDATA HrIniF				AS String   OPTIONAL    // Hora Inicio Faturamento
	WSDATA DtFimF				AS String   OPTIONAL    // Data Fim Faturamento
	WSDATA HrFimF				AS String   OPTIONAL    // Hora Fim Faturamento

	WSDATA HorIni				AS String OPTIONAL	//Hora Inicio
	WSDATA HorFim				AS String OPTIONAL	//Hora Fim
	WSDATA ViaAc				AS String OPTIONAL	//Via Acesso
	WSDATA TecUt				AS String OPTIONAL   //Tecnica Utilizada
	WSDATA RedAcre			    AS Float  OPTIONAL   //RedAcre
	WSDATA GrpParExe			AS String OPTIONAL//Array Of GrpPar OPTIONAL
	WSDATA Operacao			    AS String OPTIONAL//Array Of GrpPar OPTIONAL
	WSDATA Observ				AS String OPTIONAL
	WSDATA OutDesp				AS String OPTIONAL
	WSDATA NumAuxi				as String OPTIONAL  //número de auxiliares previstos
	WSDATA GuiRef				as String OPTIONAL  //Número da Guia Referencia Anexo OPME
	WSDATA ItGeralPac			AS Array Of SItGerPac OPTIONAL
	WSDATA ListProc				AS String OPTIONAL

ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para Contatos						   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT ContatosTiss
	WSDATA Nome					AS String OPTIONAL //Nome do Contato
	WSDATA TipoContato			AS String OPTIONAL //Tipo do Contato//Coordenador/Suplente
	WSDATA Telefone				AS String OPTIONAL //Telefone
	WSDATA Email				AS String OPTIONAL //Email
	WSDATA Site  				AS String OPTIONAL //Site
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para Links						   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT LinksList
	WSDATA Codigo				AS String OPTIONAL //Codigo do Link
	WSDATA Descricao			AS String OPTIONAL //Descrição
	WSDATA Link					AS String OPTIONAL //Link
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para Produtos						   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT ProdutosList
	WSDATA Codigo				AS String OPTIONAL //Codigo do Produto
	WSDATA Versao				AS String OPTIONAL //Versao do Produto
	WSDATA Nome					AS String OPTIONAL //Nome do Produto
	WSDATA Abrangencia			AS String OPTIONAL //Abrangencia do Produto
	WSDATA Susep				AS String OPTIONAL //Numero do Registro do Produto
	WSDATA Segmentacao			AS String OPTIONAL //Segmentacao assistencial
	WSDATA NRegistro 			AS String OPTIONAL //Numero Registro ANS BI3_SCPA
	WSDATA Classificacao		AS String OPTIONAL //BI3_CLAPLS
	WSDATA Situacao 			AS String OPTIONAL //Situação na ANS BI3_APOSRG
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para Familia						   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT FamBloqList
	WSDATA Matricula			AS String  OPTIONAL //Matricula do Beneficiario
	WSDATA Nome					AS String  OPTIONAL //Nome do Beneficiario
	WSDATA CPF	  				AS String  OPTIONAL //CPF do Beneficiario
	WSDATA DataInc				AS DATE    OPTIONAL //Data de Inclusao do Beneficiario
	WSDATA DataNasc				AS DATE    OPTIONAL //Data de Nascimento do Beneficiario
	WSDATA DataBloq				AS DATE    OPTIONAL //Data de Bloqueio do Beneficiario
	WSDATA SolicAbert			AS String  OPTIONAL //Tipo de vinculo do Beneficiario
	WSDATA TipoBenef			AS String  OPTIONAL //Tipo de vinculo do Beneficiario
	WSDATA Recno            	AS Integer OPTIONAL //
	WSDATA MsgRN            	AS String  OPTIONAL //Mensagem RN412
	WSDATA PrazoFidel           AS String  OPTIONAL //Prazo de Fidelidade
	WSDATA DataFimFid           AS DATE    OPTIONAL //Data Final da Fidelidade
	WSDATA ValorMulta           AS String  OPTIONAL //Valor da Multa Rescisoria
	WSDATA HtmlMulta            AS String  OPTIONAL //Valor da Multa Rescisoria
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas solicitacoes de bloqueio			   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SolicCanPlaList
	WSDATA Protocolo			AS String OPTIONAL
	WSDATA DataSolic			AS DATE   OPTIONAL
	WSDATA DataBloq 			AS DATE   OPTIONAL
	WSDATA Status   			AS String OPTIONAL
	WSDATA Origem           	AS String OPTIONAL
	WSDATA Recno            	AS Integer OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas na Consulta de Classes de Carencias  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT CarenBenList
	WSDATA CodClasse			AS String OPTIONAL
	WSDATA DesClasse			AS String OPTIONAL
	WSDATA DataFimCar			AS DATE   OPTIONAL
	WSDATA Status   			AS String OPTIONAL
	WSDATA Recno            	AS Integer OPTIONAL
	WSDATA NomeBenef        	AS String OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para Produtos						   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT ArquivosList
	WSDATA Data					AS Date OPTIONAL //Data do Upload
	WSDATA NomeArqIn			AS String OPTIONAL //Nome do Arquivo de entrada a ser exibido
	WSDATA ArquivoIn			AS String OPTIONAL //Nome do Arquivo de entrada
	WSDATA ArquivoOut			AS String OPTIONAL //Nome do Arquivo de saida
	WSDATA DesSta				AS String OPTIONAL //Descricao do status do arquivo
	WSDATA Status				AS String OPTIONAL //Status do arquivo
	WSDATA QtdPag				AS Integer OPTIONAL //Quantidade de Paginas
	WSDATA CodPeg				AS String OPTIONAL 	//CodPeg
	WSDATA TPARQ				AS String OPTIONAL //NFSS
	WSDATA Sequen				AS String OPTIONAL //Sequencia
	WSDATA Origem				AS String OPTIONAL
	WSDATA ProGlo				AS String OPTIONAL //Protocolo recurso glosa
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para peg
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT sMatPEG
	WSDATA funName				AS String	OPTIONAL
	WSDATA where				AS String	OPTIONAL
	WSDATA colsCk				AS String	OPTIONAL
	WSDATA colsUnCk				AS String	OPTIONAL
	WSDATA semaforo				AS String	OPTIONAL
	WSDATA gerPeg				AS Boolean	OPTIONAL
	WSDATA mosGui				AS Boolean	OPTIONAL
	WSDATA funJS				AS String	OPTIONAL
	WSDATA grvVlrApr			AS Boolean	OPTIONAL
	WSDATA TipoGuia				AS String OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar proc. com carência no portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SCarPor
	WSDATA CodPro			    AS String 	OPTIONAL
	WSDATA DescPro		    	AS String 	OPTIONAL
	WSDATA REC				    AS String 	OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para termos TISS
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT STermoTiss
	WSDATA VerTiss				AS String	OPTIONAL
	WSDATA VlrProt				AS String	OPTIONAL
	WSDATA CodAlias				AS String	OPTIONAL
	WSDATA VlrTiss				AS String	OPTIONAL
	WSDATA CodTab				AS String	OPTIONAL
	WSDATA Campo				AS String	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SGuiaTiss
	WSDATA VerTiss				AS String	OPTIONAL
	WSDATA TipGui				AS String	OPTIONAL
	WSDATA DadCombo				AS String OPTIONAL
ENDWSSTRUCT

WSSTRUCT SRetGuiaTiss
	WSDATA Pagina				AS String OPTIONAL
	WSDATA CmpGuia				AS Array Of SCmpGuia OPTIONAL
	WSDATA RetCmbsGuia			AS Array Of SRetCmbsGuia OPTIONAL
	WSDATA Grids				AS String OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar os dados dos usuarios do grupo familiar
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDadGrp
	WSDATA Matricl			    AS String 	OPTIONAL
	WSDATA NomeBnf			    AS String 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar as receitas cadastradas para o usuario
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDadRecUsr
	WSDATA CodRec               AS String OPTIONAL
	WSDATA NomRec               AS String OPTIONAL
	WSDATA CodMed               AS String OPTIONAL
	WSDATA NomMed               AS String OPTIONAL
	WSDATA QtdAut				AS Integer OPTIONAL
	WSDATA QtdExe				AS Integer OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estrutura para retornar os dados da solicitação de opcionais
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDadSolOpc
	//informações da solicitação
	WSDATA RecnoSol  		AS String 	OPTIONAL //recno da solicitação
	WSDATA Prot      		AS String 	OPTIONAL //protocolo
	WSDATA DataSol   		AS Date 	OPTIONAL //data da solicitação
	WSDATA HoraSol   		AS String 	OPTIONAL //hora da solicitação
	WSDATA Classe    		AS String  OPTIONAL
	//informações da operadora
	WSDATA DadosOpe  		AS SDadOpe OPTIONAL //nome da operadora
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estrutura para retornar os dados da operadora
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDadOpe
	WSDATA CodOpe	   		AS String 	OPTIONAL //código da operadora
	WSDATA NomeOpe   		AS String 	OPTIONAL //nome da operadora
	WSDATA Ender     		AS String 	OPTIONAL //endereço
	WSDATA NumEnd    		AS String 	OPTIONAL //numero do endereco
	WSDATA Compl     		AS String 	OPTIONAL //complemento
	WSDATA Bairro    		AS String 	OPTIONAL //bairro
	WSDATA Cidade    		AS String 	OPTIONAL //cidade
	WSDATA Estado    		AS String 	OPTIONAL //estado
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar a carencia do beneficiario no portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SRetCaren
	WSDATA cMsg			    	AS String 	OPTIONAL
	WSDATA cInfo			    AS String 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Estrutura  Principal Noticias			                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SNoticia
	WSDATA DtNotIni		    	AS Date 		OPTIONAL
	WSDATA DtNotFin		    	AS Date 		OPTIONAL
	WSDATA TituloNot		    AS String 	OPTIONAL
	WSDATA TextoNot		    	AS String 	OPTIONAL
	WSDATA ArqNot			    AS Array Of  SArqNot OPTIONAL
	WSDATA cEspec			    AS String 	OPTIONAL
	WSDATA cCodNot		    	AS String 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Estrutura  Principal Arquivos de Noticias                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SArqNot
	WSDATA CodObj		    	AS String 		OPTIONAL
	WSDATA Objeto		   	 	AS String 		OPTIONAL
ENDWSSTRUCT


WSSTRUCT SCmbGuia
	WSDATA CampoG				AS String	OPTIONAL
	WSDATA CBOX					AS String	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SRetCmbsGuia
	WSDATA CampoG				AS String	OPTIONAL
	WSDATA CBOX					AS String	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SCmpGuia
	WSDATA Tipo					AS String	OPTIONAL
	WSDATA Nome					AS String	OPTIONAL
	WSDATA Descri				AS String	OPTIONAL
	WSDATA CmpGrid				AS Array Of SCmpGrid OPTIONAL
	WSDATA aCols				AS Array Of String	OPTIONAL
	WSDATA aHeader				AS Array Of String	OPTIONAL
	WSDATA xCols				AS String	OPTIONAL
	WSDATA xHeader				AS String	OPTIONAL
	WSDATA Valid				AS String	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SCmpGrid
	WSDATA Tipo					AS String	OPTIONAL
	WSDATA Nome					AS String	OPTIONAL
	WSDATA Descri				AS String	OPTIONAL
	WSDATA Valid				AS String	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Estrutura  Principal dado beneficiário                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SBenefi
	WSDATA NomBenef		    	AS String 	OPTIONAL
	WSDATA Matric			    AS String 	OPTIONAL
	WSDATA REC				    AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SMatric
	WSDATA Matric			    AS String 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar as classes de procedimentos cadastradas
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SClasseProc
	WSDATA CodInt	    		AS String 	OPTIONAL // Cod operadora
	WSDATA CODE		    		AS String 	OPTIONAL // Codigo da Classe
	WSDATA Description    		AS String 	OPTIONAL // Descrição
	WSDATA IsMedic	    		AS String 	OPTIONAL // Classe de agrupamento para medicamentos sim ou nao
	WSDATA CodPad          		AS String 	OPTIONAL // Codigo de tabela padrão para procedimento padrao
	WSDATA CodProc          	AS String  OPTIONAL // Codigo de procedimento padrão para essa classe
	WSDATA DesProc				As String OPTIONAL // Descrição do procedimento, para evitar uma nova requisição no app
ENDWSSTRUCT

WSSTRUCT SUsuario
	WSDATA permite				AS String 		OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar os dados do tipo de documento de reembolso do portal do beneficiario
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDadTip
	WSDATA Cod					AS String 	OPTIONAL
	WSDATA Descri				AS String 	OPTIONAL
	WSDATA ImgHelp			    AS String 	OPTIONAL
	WSDATA Obriga        		AS String  OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas dos procedimentos inseridos pelo beneficiario pelo portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SItensReemb
	WSDATA CodPro	    		AS String 	OPTIONAL // Cod da despesa
	WSDATA CodPad	    		AS String 	OPTIONAL // Cod da despesa
	WSDATA TipDoc		    	AS String 	OPTIONAL // Tipo do documento
	WSDATA NroDoc		    	AS String 	OPTIONAL // Numero do documento fiscal
	WSDATA CodRda		    	AS String 	OPTIONAL // Codigo da RDA nao ref
	WSDATA UsoC		    		AS String 	OPTIONAL // Medcimento de Uso Continuo
	WSDATA IsMedic	    		AS String 	OPTIONAL // Se e medicamento
	WSDATA EnviaRec    			AS String 	OPTIONAL // Se sera enviada a receita junto ao protocolo
	WSDATA VlrPro	    		AS String 	OPTIONAL // Valor da despesa
	WSDATA DatDoc	    		AS Date 	OPTIONAL // Data do documento
	WSDATA QtdPro	    		AS String 	OPTIONAL // qtd da despesa
	WSDATA Estd	    			AS String 	OPTIONAL // qtd da despesa
	WSDATA CodMun	    		AS String 	OPTIONAL // qtd da despesa
	WSDATA SeqRec	    		AS String 	OPTIONAL // Sequencial da Receita
	WSDATA NomRDA				AS STRING 	OPTIONAL //Nome da RDA não referenciada
	WSDATA Matric         		AS String 	OPTIONAL // matricula do beneficiario
	WSDATA CodRec           	AS String 	OPTIONAL // codigo da receita
	WSDATA CodMed				AS String 	OPTIONAL // codigo do medicamento
	WSDATA SeqMed           	AS String 	OPTIONAL // sequencial do medicamento
	WSDATA CPFCNPJ				AS String 	OPTIONAL // CPF/CNPJ da rede não referenciada
	WSDATA	TipSer				AS String 	OPTIONAL // tipo do serviço
	WSDATA RecNoItem			AS String 	OPTIONAL // recno do item do reembolso
	WSDATA StatusIte			AS String 	OPTIONAL // Status do item (aprovado ou negado)
	WSDATA Cidade			    AS String 	OPTIONAL // recno do item do reembolso
	WSDATA UF        			AS String 	OPTIONAL // recno do item do reembolso
	WSDATA ValorPago   			AS String 	OPTIONAL // valor reembolsado
	WSDATA ValUnitari  			AS String 	OPTIONAL // valor reembolsado
	WSDATA DatComprov  			AS String 	OPTIONAL // Data do comprovante

ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas dos procedimentos inseridos pelo beneficiario pelo portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SEstrReemb
	WSDATA CodSol				AS String	OPTIONAL // Codigo da solicitação (protocolo)
	WSDATA CodRda		    	AS String 	OPTIONAL // Codigo da RDA nao ref
	WSDATA TipDoc				AS String 	OPTIONAL // Tipo do documento da solicitação de reembolso
	WSDATA CpfCnpj				AS String 	OPTIONAL // CPF ou CNPJ do prestador do serviço
	WSDATA NomePre				AS String 	OPTIONAL // Nome do prestador do serviço
	WSDATA NumDoc				AS String 	OPTIONAL // Número do documento/comprovante fiscal
	WSDATA DtEmis				AS String	OPTIONAL // Data de emissão do documento/comprovante fiscal
	WSDATA status				AS String	OPTIONAL // Status do protocolo
	WSDATA UF					AS String 	OPTIONAL
	WSDATA Cidade				AS String 	OPTIONAL
	WSDATA ListDesp				AS Array Of SItensReemb OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar a observação do protocolo de reembolso
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SRetObsProt
	WSDATA cMsg			    	AS String 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar itens excluidos do reembolso
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SRetIteEx
	WSDATA cMsg			    	AS String 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar o nome de todos os estados do Brasil
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDadEst
	WSDATA Descri				AS String 	OPTIONAL
	WSDATA CodMun				AS String 	OPTIONAL
ENDWSSTRUCT
WSSTRUCT STratind
	WSDATA obrigat				AS Boolean	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDadCodMun
	WSDATA Descri				AS String 	OPTIONAL
	WSDATA CodCid				AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDadSiglaCR
	WSDATA Descri				AS String 	OPTIONAL
	WSDATA CodMun				AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDadEnder
	WSDATA Descri				AS String 	OPTIONAL
	WSDATA CodLoc				AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDadEspec
	WSDATA Descri				AS String 	OPTIONAL
	WSDATA CodEsp				AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDadload
	WSDATA DescriA			    AS String 	OPTIONAL
	WSDATA DescriB			    AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDadBloq
	WSDATA CodBlo				AS String 	OPTIONAL
	WSDATA Descri				AS String 	OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas de dados de documento										  						³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDocs
	WSDATA DocSeq				AS String 	OPTIONAL // Código do documento
	WSDATA DocDesc				AS String 	OPTIONAL // Descrição do documento
	WSDATA DocObrig				AS String 	OPTIONAL // Obrigatoriedade do documento
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estrutura de acreditacoes
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SAcredit
	WSDATA CODIGO 				As String // "Codigo da relação"
	WSDATA CODACR 				As String // "Codigo da acreditação"
	WSDATA DESCACR 				As String // "Descrição da acreditação"
	WSDATA NIVACR 				As String // "Nivel da acreditação"
	WSDATA DESCNIV 				As String // "Descrição do nivel da acreditação"
	WSDATA CODINT 				As String // "CODINT"
	WSDATA CODLOC 				As String // "Código do Local"
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas das solicitações de opcionais no portal									  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SItensOpc
	WSDATA CodBen	    		AS String 	OPTIONAL // Cod do Beneficiário
	WSDATA CodOpc	    		AS String 	OPTIONAL // Cod do Opcional
	WSDATA DatAde		    	AS Date 	OPTIONAL // Data adesão
	WSDATA DatLim		    	AS Date 	OPTIONAL // Data Limite
	WSDATA GrpEmp				AS String	OPTIONAL // Grupo Empresa
	WSDATA CtrEmp				AS String	OPTIONAL // Contrato Empresa
	WSDATA VerCtr				AS String	OPTIONAL // Versão Contrato
	WSDATA SubCtr				AS String	OPTIONAL // Sub Contrato
	WSDATA VerSub				AS String	OPTIONAL // Versão Sub-Contrato
	WSDATA MatUsu				AS String	OPTIONAL // Matricula Titular
	WSDATA EmpBen				AS String	OPTIONAL // Empresa/Beneficiario
	WSDATA CodPln				AS String	OPTIONAL // Codigo Plano
	WSDATA VerPln				AS String	OPTIONAL // Versão Plano
	WSDATA VerOpc				AS String	OPTIONAL // Versão Opcional
	WSDATA DtDoc				AS Date		OPTIONAL // Data emissão recibo
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas das solicitações de opcionais no portal									  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SAdadosOpc
	WSDATA dadosBenOpc	    	AS Array of SItensOpc OPTIONAL // Cod do Beneficiário
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar as mensagens do portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SMsgPortal
	WSDATA CodMsg				AS String 	OPTIONAL
	WSDATA Mensagem	    		AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SAMsgsPortal
	WSDATA mensagens			AS Array of SMsgPortal  OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas da impressão de guias TISS em branco			   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT STipGui //30-11
	WSDATA Cod				AS String 	OPTIONAL //codigo
	WSDATA Descri			AS String 	OPTIONAL // descrição
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas da composicao da solicitacao					   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄlÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT st_cart_usuario
	WSDATA mat_usuario			AS String OPTIONAL
	WSDATA tip_usuario			AS String OPTIONAL
ENDWSSTRUCT

WSSTRUCT cart_usuarios
	WSDATA cLogin				AS String OPTIONAL
	WSDATA cart_usuarios		AS Array of st_cart_usuario OPTIONAL
ENDWSSTRUCT

WSSTRUCT layouts_cartao
	WSDATA layout_nickname 		AS String OPTIONAL
ENDWSSTRUCT

WSSTRUCT carencias
	WSDATA tipo_servico   		AS String OPTIONAL
	WSDATA carencia				AS String OPTIONAL
ENDWSSTRUCT

WSSTRUCT cartao_virtual
	WSDATA login				AS String OPTIONAL		//DESCRIPTION "Informar 'S'(Sim) no beneficiario da familia que acabou de logar"
	WSDATA titular				AS String OPTIONAL
	WSDATA titular_matricula	AS String OPTIONAL
	WSDATA matricula			AS String OPTIONAL
	WSDATA matricula_funcionario	AS String OPTIONAL
	WSDATA matricula_sis_antigo		AS String OPTIONAL
	WSDATA nome					AS String OPTIONAL
	WSDATA sexo					AS String OPTIONAL
	WSDATA nascimento			AS Date   OPTIONAL
	WSDATA telefone				AS String OPTIONAL
	WSDATA email				AS String OPTIONAL
	WSDATA inclusao				AS Date   OPTIONAL
	WSDATA dependencia_id		AS String OPTIONAL
	WSDATA prontuario_id		AS String OPTIONAL
	WSDATA bloqueado			AS String OPTIONAL
	WSDATA motivo_bloqueio		AS String OPTIONAL
	WSDATA cpf					AS String OPTIONAL
	WSDATA tipo_pessoa_contratante	AS String OPTIONAL
	WSDATA numero_contrato			AS String OPTIONAL

	WSDATA endereco				AS String OPTIONAL
	WSDATA numero				AS String OPTIONAL
	WSDATA complemento			AS String OPTIONAL
	WSDATA bairro				AS String OPTIONAL
	WSDATA cidade				AS String OPTIONAL
	WSDATA estado				AS String OPTIONAL
	WSDATA cep					AS String OPTIONAL
	WSDATA celular				AS String OPTIONAL

	WSDATA tipo_beneficiario_id			AS String OPTIONAL
	WSDATA tipo_beneficiario_descricao 	AS String OPTIONAL
	WSDATA grau_parentesco_id			AS String OPTIONAL
	WSDATA grau_parentesco_descricao	AS String OPTIONAL
	WSDATA numero_cns					AS String OPTIONAL
	WSDATA data_cpt						AS String OPTIONAL

	WSDATA convenio_id					AS String OPTIONAL
	WSDATA convenio_descricao			AS String OPTIONAL
	WSDATA convenio_versao				AS String OPTIONAL
	WSDATA convenio_abrangencia			AS String OPTIONAL
	WSDATA convenio_acomodacao			AS String OPTIONAL
	WSDATA convenio_segmentacao			AS String OPTIONAL
	WSDATA convenio_tipo_contrato		AS String OPTIONAL
	WSDATA convenio_participativo		AS String OPTIONAL
	WSDATA convenio_modalidade_cobranca AS String OPTIONAL
	WSDATA convenio_padrao_conforto		AS String OPTIONAL
	WSDATA convenio_permite_reembolso	AS String OPTIONAL
	WSDATA convenio_tipo_rede_id		AS String OPTIONAL
	WSDATA convenio_tipo_rede_descricao AS String OPTIONAL
	WSDATA convenio_opcional			AS String OPTIONAL
	WSDATA convenio_carencias			AS Array of carencias OPTIONAL
	WSDATA convenio_ANS					AS String OPTIONAL
	WSDATA convenio_regulamentacao		AS String OPTIONAL

	// Dados do cartão do beneficiario
	WSDATA cartao_validade				AS Date OPTIONAL
	WSDATA cartao_via					AS String OPTIONAL
	WSDATA cartao_imagem				AS String OPTIONAL
	WSDATA cartao_imagem_verso			AS String OPTIONAL
	WSDATA cartao_obs					AS String OPTIONAL
	wsdata cartao_contato1  			AS String OPTIONAL
	WSDATA cartao_contato2				AS String OPTIONAL
	WSDATA cartao_contato3				AS String OPTIONAL
	WSDATA cartao_contato4				AS String OPTIONAL
	WSDATA cartao_contato5				AS String OPTIONAL
	WSDATA layout_cartoes				AS Array of layouts_cartao OPTIONAL

	// Empresa
	WSDATA empresa_id					AS String OPTIONAL
	WSDATA empresa_nome					AS String OPTIONAL
	WSDATA empresa_responsavel			AS String OPTIONAL
ENDWSSTRUCT

WSSTRUCT st_cartao_virtual
	WSDATA retorno_status   	 		AS Boolean 					OPTIONAL
	WSDATA mensagem						As String						OPTIONAL
	WSDATA retorno_dados		 		AS Array Of cartao_virtual 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Retorna o texto do li e concordo no portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT RetLieCon
	WSDATA cLieCon				AS String 	OPTIONAL
ENDWSSTRUCT

//--< Dados do beneficiario >--
WSSTRUCT st_dados_benef
	WSDATA CNOMEUSUARI	 		AS String 	OPTIONAL
	WSDATA CMATRICULA			As String	OPTIONAL
	WSDATA DDTNACTO				As String	OPTIONAL
	WSDATA CCNESUSU				As String	OPTIONAL
	WSDATA CSUSEP				As String	OPTIONAL
	WSDATA CSEGASSPL			As String	OPTIONAL
	WSDATA CNUMREGOPE			As String	OPTIONAL
	WSDATA CCONTATOOPE			As String	OPTIONAL
	WSDATA CCONTATOANS			As String	OPTIONAL
	WSDATA DCPT					As String	OPTIONAL
	WSDATA CTPACOMODA			As String	OPTIONAL
	WSDATA CCONTRATACA			As String	OPTIONAL
	WSDATA CABRANG				As String	OPTIONAL
	WSDATA CNOMPRO				As String	OPTIONAL
	WSDATA CNFANTAZOPE			As String	OPTIONAL
	WSDATA CNFAADMBENE			As String	OPTIONAL
	WSDATA CRZSOCIAL			As String	OPTIONAL
	WSDATA DDTVIGPL				As String	OPTIONAL
	WSDATA CNUMCON				As String	OPTIONAL
	WSDATA DDATCON				As String	OPTIONAL
	WSDATA DDTMAXCON			As String	OPTIONAL
	WSDATA CINFOPLAN			As String	OPTIONAL
	WSDATA CINFORMACOE			As String	OPTIONAL
	WSDATA CCARENCAMB			As String	OPTIONAL
	WSDATA CCARENCHOS			As String	OPTIONAL
	WSDATA CCARENCPAT			As String	OPTIONAL
	WSDATA CCARENCODO			As String	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas de Itens Gerais do Pacote						³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SItGerPac
	WSDATA CodProc	 			AS String  OPTIONAL //Codigo de Procedimento
ENDWSSTRUCT


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao do Web Service de Controle do Usuario                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSERVICE PLSXFUN	 				DESCRIPTION "Funções Genéricas (Login Usuário, E-Mail, Cartão e RDA)"
	WSDATA UserCode					AS String
	WSDATA UserPlsCode				AS String
	WSDATA UserPlsName				AS String
	WSDATA PLSCodUsr 				AS String  OPTIONAL //Codigo de usuario web
	WSDATA TpPor					AS integer OPTIONAL
	WSDATA VldGen					AS String
	WSDATA CodeOpe					AS String
	WSDATA UserLCode				AS LoginView
	WSDATA UserCardNumber			AS String 	OPTIONAL
	WSDATA UserCardEdition			AS String 	OPTIONAL
	WSDATA UserCardName				AS String
	WSDATA LOCALExec				AS String 	OPTIONAL
	WSDATA AreaAbr					AS String 	OPTIONAL
	WSDATA ListOfRDA				AS Array Of RDAView
	WSDATA ObjProfSaud				AS RtProfSaud
	WSDATA RDACode					AS String 	OPTIONAL
	WSDATA CodLoc					AS String 	OPTIONAL
	WSDATA Tipo						AS String 	OPTIONAL
	WSDATA CodEsp					AS String 	OPTIONAL
	WSDATA ServiceCode				AS String
	WSDATA ServiceName				AS String
	WSDATA TableCode				AS String
	WSDATA ProcedureCode			AS String
	WSDATA ProcCodeTransformed		AS String
	WSDATA UserCard					AS UserCardView
	WSDATA MatGuia					AS SMatAutGui
	WSDATA UserEmail                AS String
	WSDATA SmtpEnv                	AS String
	WSDATA UsuEmai                	AS String
	WSDATA UsuPass	                AS String
	WSDATA MsgRet                	AS String
	WSDATA MViewPar					AS SViewPar
	WSDATA MViewHistLog 			AS Array Of SViewHistLog
	WSDATA MViewInteracao 			AS Array Of SViewInteracao
	WSDATA MatAut              		AS Array Of SMatAut
	WSDATA IteGui              		AS Array Of MIteGui
	WSDATA Header           		As Array Of BrwHeader
	WSDATA Alias					As String OPTIONAL
	WSDATA Campos					As String
	WSDATA Busca					As String OPTIONAL
	WSDATA TipBusca					As String OPTIONAL
	WSDATA Protocolo				As String OPTIONAL
	WSDATA MtStCOMBO                As MsCombo
	WSDATA MtStPARAM                As MSParam
	WSDATA MtStDadESP               As MSDadESP
	WSDATA RetAutProc               AS SMatRetAutProc
	WSDATA WSNULL					AS String
	WSDATA Cid						AS String
	WSDATA NumAut					AS String
	WSDATA NumPeg					AS String
	WSDATA Motivo					AS String
	WSDATA TipoAut					AS String 	OPTIONAL
	WSDATA DtAut					AS Date
	WSDATA ProDad                   AS SMProDad
	WSDATA IteDad                   AS SMITE
	WSDATA MtStProDad				AS SMProDad
	WSDATA SAutProc                 AS SMatAutProc
	WSDATA MatPre          			AS SMatPre
	WSDATA MatBD6          			AS Array Of SMatBD6
	WSDATA ItGeralPac				AS Array Of SItGerPac
	WSDATA MatComGui          		AS Array Of SMatCompGui
	WSDATA RetMatPre				AS Array Of SRetMatPre
	WSDATA RetBox					AS Array Of GenericStruct OPTIONAL
	WSDATA RetCoPar					AS SMatVlr 	OPTIONAL
	WSDATA CompanyCode				AS String  	OPTIONAL
	WSDATA RegPagina 	        	AS Integer 	OPTIONAL 	//Indica quantos registros serao mostrados por pagina
	WSDATA PaginaIni   	    		AS Integer 	OPTIONAL 	//Indica pagina inicial
	WSDATA BuscaTReg				AS String  	OPTIONAL 	//Indica se procura total de registro ou total de pagina
	WSDATA RegTotal   	    		AS Boolean 	OPTIONAL 	//Indica se busca quantidade de registros
	WSDATA QtdPaginas				AS Integer 	OPTIONAL 	//Indica quantidade de paginas
	WSDATA TipoLink 	    		AS String  	OPTIONAL 	//Tipo Link 1=WebService;2=UpLoad/Download
	WSDATA Pesquisa					AS String	OPTIONAL	//Pesquisa em formato de filtro
	WSDATA semaforo					AS String	OPTIONAL	//Controla processo assincrono
	WSDATA Limite					AS Integer	OPTIONAL	//Quantidade de registros a ser devolvido pela query
	WSDATA TissContatos				AS Array Of ContatosTiss OPTIONAL
	WSDATA ListProdutos				AS Array Of ProdutosList OPTIONAL
	WSDATA ListArquivos				AS Array Of ArquivosList OPTIONAL
	WSDATA ListLinks				AS Array Of LinksList OPTIONAL
	WSDATA ListFamBloq				AS Array Of FamBloqList OPTIONAL
	WSDATA ListSolicCanPla  		AS Array Of SolicCanPlaList OPTIONAL
	WSDATA ListCarenBene			AS Array of CarenBenList OPTIONAL
	WSDATA DatInt  					AS Date 	OPTIONAL
	WSDATA HorInt  					AS String 	OPTIONAL
	WSDATA DatAlt  					AS Date   OPTIONAL
	WSDATA HorAlt  					AS String OPTIONAL
	WSDATA MotAlt  					AS String OPTIONAL
	WSDATA Where  					AS String 	OPTIONAL
	WSDATA camposCustom            	AS String OPTIONAL
	WSDATA DirArqIn					AS String 	OPTIONAL
	WSDATA Tp						AS Integer 	OPTIONAL
	WSDATA Retorno					AS String 	OPTIONAL
	WSDATA Idx						AS Integer 	OPTIONAL
	WSDATA Chave					AS String 	OPTIONAL
	WSDATA CmdChave					AS String 	OPTIONAL
	WSDATA FunName				    AS String 	OPTIONAL
	WSDATA MatUsu				    AS String 	OPTIONAL
	WSDATA MotCar				    AS String 	OPTIONAL
	WSDATA NumCon				    AS String 	OPTIONAL
	WSDATA SubCon				    AS String 	OPTIONAL
	WSDATA TipAtd				    AS String 	OPTIONAL
	WSDATA matPeg					AS sMatPEG 	OPTIONAL
	WSDATA Especi					AS Array Of GenericStruct OPTIONAL
	WSDATA TermoTiss				AS STermoTiss OPTIONAL
	WSDATA GuiaTiss					AS SGuiaTiss OPTIONAL
	WSDATA RetGuiaTiss				AS SRetGuiaTiss OPTIONAL
	WSDATA cParMV					AS String OPTIONAL
	WSDATA cDefMV					AS String OPTIONAL
	WSDATA cRetMv                   AS String OPTIONAL
	WSDATA StProc				    AS String 	OPTIONAL
	WSDATA ProcCarPort				AS Array Of SCarPor OPTIONAL
	WSDATA DadosGrpFam				AS Array Of SDadGrp OPTIONAL
	WSDATA DadUsrRec            	AS Array of SDadRecUsr OPTIONAL
	WSDATA cUsrLogin			   	AS String 	OPTIONAL
	WSDATA SoFam   			   		AS String 	OPTIONAL
	WSDATA UsrLoginCode			   	AS String 	OPTIONAL
	WSDATA DadCarenc				AS Array Of SRetCaren OPTIONAL
	WSDATA cMatrc					AS String 	OPTIONAL
	WSDATA cRecno					AS String 	OPTIONAL
	WSDATA Noticia          		AS Array Of SNoticia
	WSDATA cCodEsp					AS String 	OPTIONAL
	WSDATA cCodNotic				AS String 	OPTIONAL
	WSDATA cCodRDA					AS String 	OPTIONAL
	WSDATA cUserCod					AS String 	OPTIONAL
	WSDATA cOpcao					AS String 	OPTIONAL
	WSDATA ExisTbl					AS Boolean	OPTIONAL
	WSDATA MClasseProc 				AS Array Of SClasseProc
	WSDATA CpfCnpj					AS String 	OPTIONAL
	WSDATA Crm						AS String 	OPTIONAL
	WSDATA Protoc 					AS String 	OPTIONAL
	WSDATA Benef 					AS String 	OPTIONAL
	WSDATA Medico 					AS String 	OPTIONAL
	WSDATA DtReceita 				AS String 	OPTIONAL
	WSDATA Medicamento 				AS String 	OPTIONAL
	WSDATA CodSig					AS String 	OPTIONAL 	//Sigla Conselho
	WSDATA RetProtocolo         	AS String 	OPTIONAL
	WSDATA UsaClasse 				AS String OPTIONAL
	WSDATA Estado					AS String 	OPTIONAL
	WSDATA ShowAnexo				AS String 	OPTIONAL
	WSDATA cRDA						AS String 	OPTIONAL
	WSDATA BenInter					AS Array Of SBenefi
	WSDATA AMatric 					AS Array Of SMatric
	WSDATA Usuario 					AS Array Of SUsuario
	WSDATA cUsr						AS String 	OPTIONAL
	WSDATA SetDtInt					AS String OPTIONAL
	WSDATA cCheckDePara 			AS String 	OPTIONAL
	WSDATA cTissVer 				AS String 	OPTIONAL
	WSDATA TipGui 					AS String 	OPTIONAL
	WSDATA DadosTipDoc				AS Array Of SDadTip OPTIONAL
	WSDATA DatDoc					AS Date
	WSDATA NomRdaNRef			 	AS String 	OPTIONAL
	WSDATA VlrApr				 	AS String 	OPTIONAL
	WSDATA ItensReemb				AS SEstrReemb OPTIONAL //Item do formulario
	WSDATA DadObsProt				AS Array Of SRetObsProt OPTIONAL
	WSDATA DadItemExc				AS Array Of SRetIteEx OPTIONAL
	WSDATA UsrCod				 	AS String 	OPTIONAL
	WSDATA DadEst					AS Array Of SDadEst OPTIONAL
	WSDATA cCodPro               	AS String OPTIONAL
	WSDATA dTratvinc              	AS Array Of STratInd 	OPTIONAL
	WSDATA CodMenu              	AS String
	WSDATA CodPor               	AS Integer
	WSDATA CamImg               	AS String
	WSDATA codPro                	AS String OPTIONAL
	WSDATA TipoVld              	AS String 	OPTIONAL
	WSDATA SenhaVld              	AS String 	OPTIONAL
	WSDATA RetSenha              	AS String 	OPTIONAL
	WSDATA Telefone              	AS String 	OPTIONAL
	WSDATA RecnoBB8              	AS String 	OPTIONAL
	WSDATA RetPrest              	AS String 	OPTIONAL
	WSDATA CodRdaAcr				AS String  	OPTIONAL
	WSDATA Acredit				 	AS Array of SAcredit	 OPTIONAL
	WSDATA ChaveInt					AS String 	OPTIONAL
	WSDATA Resposta					AS String 	OPTIONAL
	WSDATA Pendente					AS Boolean OPTIONAL
	WSDATA Publico					AS String OPTIONAL
	WSDATA Sequen					AS String OPTIONAL
	WSDATA Ret					 	As String Optional
	WSDATA Pacotes					AS	String OPTIONAL
	WSDATA cArquivo					AS String OPTIONAL
	WSDATA NoArqComp				AS String OPTIONAL

	WSDATA Indice					AS String OPTIONAL
	WSDATA lIncRap					AS Boolean OPTIONAL
	WSDATA CodSol					AS String OPTIONAL
	WSDATA Observ					AS String OPTIONAL
	WSDATA CodEst					AS String OPTIONAL
	WSDATA DADRETMUN				As Array Of SDadCodMun OPTIONAL
	WSDATA DadSiglaCR				AS Array Of SDadSiglaCR OPTIONAL
	WSDATA DadEnder					AS Array Of SDadEnder OPTIONAL
	WSDATA DadEspec					AS Array Of SDadEspec OPTIONAL
	WSDATA DadLog					AS String OPTIONAL
	WSDATA Dadload					AS Array Of SDadload OPTIONAL
	WSDATA DadosOpc        			AS SAdadosOpc OPTIONAL
	WSDATA Valores          		AS String OPTIONAL
	WSDATA ArrOpc			   		AS String OPTIONAL
	WSDATA Classe          			AS String OPTIONAL
	WSDATA DadSolOpc        		AS SDadSolOpc OPTIONAL
	WSDATA cCodTb					AS String OPTIONAL
	WSDATA FlgVRDA					AS String   OPTIONAL
	WSDATA cCodLoc					AS String OPTIONAL
	WSDATA Documentos				AS Array of SDocs OPTIONAL
	WSDATA ItemReemb        		AS SItensReemb OPTIONAL
	WSDATA TipSer					AS String OPTIONAL
	WSDATA Matric					AS String OPTIONAL
	WSDATA NumDoc					AS String OPTIONAL
	WSDATA DocEmi					AS String OPTIONAL
	WSDATA CEP				    	AS String OPTIONAL
	WSDATA Rotina           		AS String OPTIONAL
	WSDATA CodMsg           		AS String OPTIONAL
	WSDATA Idioma           		AS String OPTIONAL
	WSDATA DadBloq					AS Array Of SDadBloq OPTIONAL
	WSDATA CodMot					AS String OPTIONAL
	WSDATA CdPlan					AS String OPTIONAL
	WSDATA VsPlan					AS String OPTIONAL
	WSDATA PermT					AS String OPTIONAL
	WSDATA DadosTipGui	   			AS Array Of STipGui OPTIONAL
	WSDATA DatGuia			    	AS String OPTIONAL
	WSDATA DtLimRetro				AS String OPTIONAL
	WSDATA Modo						AS String OPTIONAL
	WSDATA MsnBloInter 		    	AS String	OPTIONAL
	WSDATA DigiGui					AS String OPTIONAL
	WSDATA DtJs						AS String OPTIONAL
	WSDATA NumGuiRef 				AS String OPTIONAL
	WSDATA TpGuiRef  				AS String OPTIONAL
	WSDATA RecGuiRef 				AS String OPTIONAL
	WSDATA DocObrig           		AS String OPTIONAL
	WSDATA Altera        			AS String OPTIONAL
	WSDATA BloqGui					AS Boolean OPTIONAL
	WSDATA AltCpAT					AS Boolean OPTIONAL
	WSDATA RecnoBD5					AS String OPTIONAL
	WSDATA CamposAlterados	    	AS String OPTIONAL
	WSDATA ItensAlterados	    	AS String OPTIONAL
	WSDATA DataString				AS String OPTIONAL
	WSDATA NumProtoc			 	AS String OPTIONAL
	WSDATA CritProtoc			 	AS String OPTIONAL
	WSDATA DDD  				 	AS String OPTIONAL
	WSDATA	ProtAnt 				AS String OPTIONAL
	WSDATA	Sentimento 			 	AS String OPTIONAL
	WSDATA	TxtLivre 				AS String OPTIONAL
	WSDATA	Intercambio		 		AS Boolean OPTIONAL
	WSDATA 	dados_benef				AS st_dados_benef OPTIONAL
	WSDATA lista_de_cartoes		 	AS cart_usuarios OPTIONAL
	WSDATA ret_cartao_virtual		As st_cartao_virtual OPTIONAL
	WSDATA lVisualizaProtoc			AS Boolean	OPTIONAL
	WSDATA StMPctIteGui				AS Array Of MPctIteGui OPTIONAL
	WSDATA RetLieCon 				AS RetLieCon OPTIONAL
	WSDATA CabAlt					AS Boolean OPTIONAL
	WSDATA RecDivs					AS String 	OPTIONAL //recnos B1N
	WSDATA AtuB1N					AS String 	OPTIONAL //Atualiza B1N

	WSDATA TipProf					AS String OPTIONAL
	WSDATA DadosLanc			 	AS Array Of STipGui OPTIONAL
	WSDATA CodProf              	AS String OPTIONAL
	WSDATA OriReemb            	  	AS String OPTIONAL
	WSDATA CodPad		 			AS String OPTIONAL
	WSDATA CodDente		 			AS String OPTIONAL
	WSDATA CodFace		 			AS String OPTIONAL
	WSDATA Dados		 			AS String OPTIONAL
	WSDATA CarreExe					AS Boolean OPTIONAL
	WSDATA Reimpressao		 		AS String OPTIONAL
	WSDATA AliAux		 		    AS String OPTIONAL
	WSDATA IndiceAux	 		    AS String OPTIONAL
	WSDATA ChaveAux		 		    AS String OPTIONAL
	WSDATA CampoAux		 		    AS String OPTIONAL
	WSDATA CodLogin					AS String OPTIONAL
	WSDATA TpPortal					AS String OPTIONAL
	WSDATA MatricPrt				AS String OPTIONAL
	WSDATA ContPrt					AS String OPTIONAL
	WSDATA MonSol					AS String OPTIONAL
	WSDATA NumCrm					AS String OPTIONAL
	WSDATA SgCrm					AS String OPTIONAL
	WSDATA TpEst					AS String OPTIONAL
	WSDATA ProtocUpl				AS String OPTIONAL
	WSDATA TriCar					AS String OPTIONAL
	WSDATA DtRecibo 				AS String OPTIONAL
	WSDATA DtDoc					AS Date OPTIONAL
	WSDATA NumCpf					AS String OPTIONAL
	WSDATA DtExclu					AS Date OPTIONAL
	WSDATA UserLGPD                 AS String OPTIONAL
	WSDATA RotinLGPD				AS String OPTIONAL
	WSDATA ListProc					AS String OPTIONAL
	WSDATA FornecDir				AS String OPTIONAL
	WSDATA RegAtendim			    AS String OPTIONAL 	//Regime de Atendimento
	WSDATA CobertEsp			    AS String OPTIONAL 	//Cobertura Especial
	WSDATA SaudeOcupac			    AS String OPTIONAL	//Saúde Ocupacional
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Metodo																   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	WSMETHOD PlsIntPad			 DESCRIPTION "Operadora  LOCAL"
	WSMETHOD ChkCodPro			 DESCRIPTION "Verifica se o procedimento e valido"
	WSMETHOD ChkCodPct			 DESCRIPTION "Verifica se o procedimento e pacote"
	WSMETHOD GetInteracao		 DESCRIPTION "Retornar dados da Interação"
	WSMETHOD GrvIntera			 DESCRIPTION "Atualizar Auditoria/Interação"
	WSMETHOD RetLstPro 			 DESCRIPTION "Retorna a lista de procedimentos vinculados ao pacote"
	WSMETHOD ChkQtdPro			 DESCRIPTION "Verifica a quantidade para wxibir o lembrete"
	WSMETHOD GetVlrPro			 DESCRIPTION "Retorna o valor do procedimento"
	WSMETHOD ChkCid				 DESCRIPTION "Verifica se o CID e valido"
	WSMETHOD BrwRDA				 DESCRIPTION "Retorna RDA x Local de Atendimento"
	WSMETHOD ProfSaud				 DESCRIPTION "Retorno todos os Profissional de Saude não bloqueados"
	WSMETHOD UserCardValidation	 DESCRIPTION "Validação da Trilha do Cartão"
	WSMETHOD GetEmail			 	 DESCRIPTION "Envio de de E-mail com senha do usuario "
	WSMETHOD GetHistLogin		 DESCRIPTION "Historico de Acesso ao Portal"
	WSMETHOD getCombo			 	 DESCRIPTION "Alimenta varios combos"
	WSMETHOD getParam			 	 DESCRIPTION "Alimenta varios parametros"
	WSMETHOD AutProc				 DESCRIPTION "Autorização de Procedimento"
	WSMETHOD RetAutLib			 DESCRIPTION "Retorna dados de uma Autorização/Solicitação pela matricula ou numero da guia"
	WSMETHOD RetSerPct			 DESCRIPTION "Retorna serviços que fazem parte de pacote"
	WSMETHOD RetAut				 DESCRIPTION "Retorno das guias do usuário por data e prestador"
	WSMETHOD PreAte				 DESCRIPTION "Rotina de Pré-Atendimento"
	WSMETHOD StatusGuia			 DESCRIPTION "Status de uma Autorização"
	WSMETHOD CancelaGuia			 DESCRIPTION "Cancelamento de Guia"
	WSMETHOD GetBox				 DESCRIPTION "Retorna o x2-box de um determinado campo"
	WSMETHOD GetVlrCo				 DESCRIPTION "Retorna o valor da co-participacao"
	WSMETHOD Elegibilidade		 DESCRIPTION "Elegibilidade do Beneficiário"
	WSMETHOD GetContato			 DESCRIPTION "Lista os Contatos TISS"
	WSMETHOD getProdutos			 DESCRIPTION "Lista os Produtos"
	WSMETHOD GetPaginas			 DESCRIPTION "Total de Paginas"
	WSMETHOD getFList				 DESCRIPTION "Lista de arquivo xml do usuario Upload"
	WSMETHOD GetLinks			 	 DESCRIPTION "Lista Links de WebService / Upload - Download"
	WSMETHOD GetDadG				 DESCRIPTION "Retorna dado especifico por tipo de guia"
	WSMETHOD ExeDHInt				 DESCRIPTION "Informar a data de internação"
	WSMETHOD VldHoIn				 DESCRIPTION "Valida dados do Honorario Individual"
	WSMETHOD VldHoPar				 DESCRIPTION "Valida Participações do Honorario Individual"
	WSMETHOD GetBD6				 DESCRIPTION "Carrega dados do BD6"
	WSMETHOD ProcUpXml			 DESCRIPTION "Processa arquivo XML de Upload"
	WSMETHOD ProcDeXml			 DESCRIPTION "Deleta arquivo XML de Upload"
	WSMETHOD IncXmlUp			 	 DESCRIPTION "Inclui ou altera registro da tabela de upload"
	WSMETHOD getGAT    			 DESCRIPTION "Gatilho de campo"
	WSMETHOD setSolCar			 DESCRIPTION "Soliticacao de Carteirinha"
	WSMETHOD getDadGrid			 DESCRIPTION "Retorna dados para gridData"
	WSMETHOD setTFGuia			 DESCRIPTION "Transferencia de guia eletronica para PEG de definitivo"
	WSMETHOD getInProces			 DESCRIPTION "Verifica se esta em processamento transferencia de guais para peg definitivo"
	WSMETHOD posicione			 DESCRIPTION "Posicione"
	WSMETHOD ppImpRel				 DESCRIPTION "Imprime um determinado relatorio e manda ele por email"
	WSMETHOD ProfSAll				 DESCRIPTION "Retorna todos os profissionais de saude cadastrados"
	WSMETHOD PLSGETMV            DESCRIPTION "Retorna o valor de um parametro SX6"
	WSMETHOD ExCarPortal			 DESCRIPTION "Exibe no portal procedimentos com carência "
	WSMETHOD DadGrpFam			 DESCRIPTION "Retorna os beneficiários que fazem parte do grupo familiar"
	WSMETHOD CarenBnf				 DESCRIPTION "Retorna os dados de carencia do beneficiario"
	WSMETHOD RetNot				 DESCRIPTION "Retorno do filtro de Noticias X Prestadores"
	WSMETHOD ExNotPort			 DESCRIPTION "Verifica a existencia da tabela BPL"
	WSMETHOD GetVlrTiss			 DESCRIPTION "Retorna o termo da TISS"
	WSMETHOD GetFormTiss			 DESCRIPTION "Retorna o formulário da Guia TISS"
	WSMETHOD GetCMBFormT			 DESCRIPTION "Retorna os campos do Tipo Combo da Guia TISS"
	WSMETHOD RetClassProc		 DESCRIPTION "Retorna as classes de procedimentos cadastradas"
	WSMETHOD RDANotRef			 DESCRIPTION "Retorna os dados da rede não referenciada BK6"
	WSMETHOD VldBTQChv           DESCRIPTION "Valida uma chave na tabela BTQ"
	WSMETHOD AutAnexo            DESCRIPTION "Autorizacao de procedimento do anexo"
	WSMETHOD Matric				 DESCRIPTION "Retorna matricula para o campo do pré-atendimento do portal"
	WSMETHOD VALACEBOT			 DESCRIPTION "Valida se usuario logado tem permissão para utilizar o botao internado na tela de pré-atendimento"
	WSMETHOD ReembChkRegr		 DESCRIPTION "Retorna parametrizações de solicitaçao de reembolso no portal do beneficiario"
	WSMETHOD DadTipDoc			 DESCRIPTION "Retorna os tipos de documento que será selecionado no reembolso pelo portal do beneficiario"
	WSMETHOD RDARef				 DESCRIPTION "Retorna os dados da rede não referenciada BK6"
	WSMETHOD PutReembBen			 DESCRIPTION "Faz a gravacao do protocolo de solicitacao de reembolso no portal do beneficiario"
	WSMETHOD OBSPROTOC			 DESCRIPTION "Retorna a observação digitada pelo usuário no protocolo de reembolso/uso constante"
	WSMETHOD RETMEMOGEN			 DESCRIPTION "Retorna o conteudo de um campo memo real genericamente posicionando pelo recno"
	WSMETHOD ExcItmReemb			 DESCRIPTION "Retorna os itens excluidos pelo usuário de uma solicitação de reembolso"
	WSMETHOD ReembDelPI			 DESCRIPTION "Exclui item ou solicitaçao de reembolso protocolada"
	WSMETHOD AtuBow				 DESCRIPTION "Atualiza BOW de acordo com as baixas dos titulo vinculados ao protocolo"
	WSMETHOD DADRETEST			 DESCRIPTION "Retorna todos os estado brasileiros"
	WSMETHOD GetDadGen			 DESCRIPTION "Retorna os dados de um registro de uma tabela qualquer passada por parametro"
	WSMETHOD PPINDCLIN			 DESCRIPTION "Verifica se é obrigatorio a indicação clinica para um procedimento"
	WSMETHOD SenhaExp		        DESCRIPTION "Verifica se a Senha Expirou"
	WSMETHOD VLNUMGUI            DESCRIPTION "Verifica se a guia informada e valida"
	WSMETHOD DelAtalho		  	 DESCRIPTION "Deleta atalho do portal"
	WSMETHOD AddAtalho           DESCRIPTION "Grava atalho no portal"
	WSMETHOD DesProc				 DESCRIPTION "Verifica se o codigo do procedimento é válido"
	WSMETHOD CriPsw		        DESCRIPTION "Valida senha de usário de portal Web"
	WSMETHOD GetPrestBB8         DESCRIPTION "Retorna Dados do prestador de acordo com o RECNO da BAX"
	WSMETHOD Acreditacoes		 DESCRIPTION "Retorna dados das acreditações"
	WSMETHOD GetCalend			 DESCRIPTION "Calendario de Envio de Faturamento"
	WSMETHOD UplConhec 			 DESCRIPTION "Upload de documentos com destino ao banco de conhecimento"
	WSMETHOD GrvSolAdt			 DESCRIPTION "Pré-Gravação da solicitação de aditivo contratual"
	WSMETHOD ConSolAdt			 DESCRIPTION "Pós gravação da solicitação de aditivo contratual (pós-anexos)"
	WSMETHOD DADRETSIGLACR		 DESCRIPTION "Retorna todas as siglas do C.R dos profissionais"
	WSMETHOD DADRETENDER         DESCRIPTION "Combo de endereços"
	WSMETHOD DADRETESPEC			 DESCRIPTION "Combo de Especialidades"
	WSMETHOD GRAVALOG				 DESCRIPTION "Gravação Corpo clínico"
	WSMETHOD DADLOAD				 DESCRIPTION "Load das combos Estado e CR"
	WSMETHOD DelCorpoClinico		 DESCRIPTION "Exclui um profissional do corpo clinico"
	WSMETHOD DadFrmEmp      	 	 DESCRIPTION "Retorna os beneficiários vinculados ao grupo familiar/ grupo empresa"
	WSMETHOD DADRETCID			 DESCRIPTION "Combo de Cidades"
	WSMETHOD DADRETCEN			 DESCRIPTION "Retorna dados do endereco"
	WSMETHOD VERACESSO			 DESCRIPTION "Verifica se é primeiro acesso"
	WSMETHOD INCBENOPC 			 DESCRIPTION "Grava BeneficiáriosxOpcionais"
	WSMETHOD VLDBENOPC   		 DESCRIPTION "Valida a inclusão de opcionais na solicitação de opcionais do portal"
	WSMETHOD GetSolOpc   		 DESCRIPTION "Retorna os dados da solicitação de opcionais"
	WSMETHOD CHECKPROCEDIMENTO   DESCRIPTION "Verifica se inclusão de procedimento é válida de acordo com existência do registro"
	WSMETHOD GRAVAPROCEDIMENTO   DESCRIPTION "Gravação de log para análise de inclusão ou exclusão de procedimentos no contrado da RDA"
	WSMETHOD GrvSolOpc	        DESCRIPTION "pós-gravação da rotina de solicitação de opcionais, caso seja anexado documento"
	WSMETHOD UnUplConhec	        DESCRIPTION "Exclui arquivo enviado para o banco de conhecimento"
	WSMETHOD CpyArqConhe	        DESCRIPTION "Copia um arquivo do banco de conhecimento para uma pasta de download"
	WSMETHOD DelDesp				 DESCRIPTION "Exclui registro de despesa da solicitação de reembolso"
	WSMETHOD VerPermRee			 DESCRIPTION "Verifica se o beneficiário tem permissãopara reembolso"
	WSMETHOD AltSolOpc   		 DESCRIPTION "altera o status da solicitação de opcionais para 2-EM ANALISE quando há inclusão de documentos"
	WSMETHOD PLSTWPGQ				 DESCRIPTION "Grava dados na tabela B96, sobre solictação de tabela de preços RDA"
	WSMETHOD PLSRELYB				 DESCRIPTION "Select para mostrar tabela de solictações"
	WSMETHOD GetDocCorpoCli		 DESCRIPTION "Retorna os documentos cadastrados para o corpo clínico da RDA"
	WSMETHOD GetUsrRec   		 DESCRIPTION "Retorna as receitas do usuário cadastradas para medicamentos de uso continuo"
	WSMETHOD GrvItReemb  		 DESCRIPTION "Grava item do reembolso antes de finalizar a solicitação"
	WSMETHOD GrvFimReemb			 DESCRIPTION "Finaliza gravação da solicitação"
	WSMETHOD VldPrtReem 			 DESCRIPTION "Valida o status da solicitação e devolve os dados para serem editados na tela de solicitação"
	WSMETHOD AltStatRee			 DESCRIPTION "Altera o status do reembolso"
	WSMETHOD IsMedBJE				 DESCRIPTION "Verifica se o serviço é do tipo medicamento"
	WSMETHOD EditSolic 			 DESCRIPTION "Retorna os dados para serem editados na tela de solicitação"
	WSMETHOD GrvRec				 DESCRIPTION "Grava Receita e itens da receita."
	WSMETHOD ExclRect			DESCRIPTION "Exclusão Itens da Receita."
	WSMETHOD AltRect			DESCRIPTION "Alteração Status Receita."
	WSMETHOD USRRECBLQ			DESCRIPTION "Verifica se o beneficiário está bloqueado"
	WSMETHOD RDAPro				DESCRIPTION "Retorna os dados do Profissional BB0."
	WSMETHOD DADRETBEN 			DESCRIPTION "Retorna os dados da vida."
	WSMETHOD VERBENPRI 			DESCRIPTION "Recebe o Login e verifica se é benef, ou ja solicitou."
	WSMETHOD VerPro 			DESCRIPTION "Verifica se já não possue algum protocolo em aberto."
	WSMETHOD AltStBen 			DESCRIPTION "Altera staus da solicitação."
	WSMETHOD PLSPSQVIDA   		DESCRIPTION "Valida o primeiro acesso"
	WSMETHOD GetMsgPortal 		DESCRIPTION "Retorna as mensagens do portal"
	WSMETHOD DADRETBLOQ 		DESCRIPTION "Retorna os motivos da tabela B9G"
	WSMETHOD RETDOC				DESCRIPTION "Retorna os documentos vinculados ao motivo"
	WSMETHOD PREEXCBEN			DESCRIPTION "Pré-gravação da exclusão do beneficiários"
	WSMETHOD POSEXCBEN			DESCRIPTION "Pós-Gravaço da exclusão do beneficiário"
	WSMETHOD PLSVERINCDIG		DESCRIPTION "Verifica se usuário tem acesso a inclusão de guias no portal"
	WSMETHOD getDiaRetro		DESCRIPTION "Dias Retroativos e Permissões de Inclusão de Guias"
	WSMETHOD DadTipGui			DESCRIPTION "Retorna o tipo de guia para impressão em branco"
	WSMETHOD getArqRel			DESCRIPTION "Lista arquivos gerados dos relatorios de pagamentos para download"
	WSMETHOD BloqReem			DESCRIPTION "Verifica se a data do recibo do reembolso é anterior a data de bloqueio do usuário"
	WSMETHOD UsoConsDel 		DESCRIPTION "Exclui protocolo de uso constante ou medicamento"
	WSMETHOD AltStatusB4F       DESCRIPTION "Altera o status da receita quando o beneficiario anexa itens"
	WSMETHOD VLDBA1MATEMP		DESCRIPTION "Retorna número da carteirinha caso o número informado seja encontrado na BA1 (BA1_MATEMP)"
	WSMETHOD GETDIGP 			DESCRIPTION "Retorna o local de digitação padrão para digitação offline"
	WSMETHOD ATGUIAAAUT 		DESCRIPTION "Atualiza guia após autorização"
	WSMETHOD AltFlaInt			DESCRIPTION "Altera a flag do anexo"
	WSMETHOD GRVALTOFF			DESCRIPTION "Grava Alteração Offline"
	WSMETHOD RETCRIMF			DESCRIPTION "Retorna as críticas da BDX"
	WSMETHOD RETCRIAUT			DESCRIPTION "Exbir críticas das guias através da BEG/BEL para o beneficiário"
	WSMETHOD VerDtGuia			DESCRIPTION "Verifica data de atendimento da guia"
	WSMETHOD VBlqBen			DESCRIPTION "Verifica a data de bloqueio do beneficiário"
	WSMETHOD getNumProtoc		DESCRIPTION "Retorna o número sequencial do Protocolo"
	WSMETHOD VldNumProtoc		DESCRIPTION "Valida se o número do Protocolo de Atendimento está correto"
	WSMETHOD Protocolo			DESCRIPTION "Retorna os dados do protocolo quando for intercambio"
	WSMETHOD RetBTQChv 		    DESCRIPTION "Retorna os dados da BTQ de acordo com a Tabela"
	WSMETHOD ExeDHAlt			DESCRIPTION "Informar a data de internação"
	WSMETHOD VlDtFut			DESCRIPTION "Validação de data futura"
	WSMETHOD GetReembProc		DESCRIPTION "Retorna uma lista de procedimento com base no tipo de serviço do reembolso online"
	WSMETHOD PesqReembProc		DESCRIPTION "Retorna uma lista de procedimento com base no tipo de serviço do reembolso online"
	WSMETHOD RetCarVirt			DESCRIPTION "Retorna os dados necessários para geração do cartão virtual do beneficiário no app totvs guia saúde"
	WSMETHOD GetLieCon			DESCRIPTION "Retorna texto do Li e Concordo na solicitaçao reembolso"
	WSMETHOD UpdB1N				DESCRIPTION "Atualiza todas os itens da B1N quando altera o cabeçalho no reembolso"
	WSMETHOD RetItercamb		DESCRIPTION "Retorna se é um usuário de intercambio"
	WSMETHOD RetDadBen			DESCRIPTION "Retorna os dados do beneficiario"
	WSMETHOD HabBotao			DESCRIPTION "Verifica de foi anexado uma receita no Uso constante"
	WSMETHOD getLancam			DESCRIPTION "Lista os lançamentos"
	WSMETHOD VerGuiInt			DESCRIPTION "Verifica situação da Internação, para lançamento da guia de Resumo de Internação."
	WSMETHOD ExclResu 			DESCRIPTION "Exclusã Resumo"
	WSMETHOD VldItReemb			DESCRIPTION "Valida itens negados para reembolso"
	WSMETHOD getFamBloq			DESCRIPTION "Retorna os beneficiários da família para realização do bloqueio"
	WSMETHOD procSolicBloq    	DESCRIPTION "Efetua a gravação de uma solicitação de bloqueio"
	WSMETHOD getSolCanPla     	DESCRIPTION "Busca solicitações de bloqueio de plano"
	WSMETHOD RetCriTXT			Description "Retorna as críticas do XML em base 64"
	WSMETHOD isDupGui			DESCRIPTION "Verifica se a guia prestes a ser digitada pode estar sendo duplicada"
	WSMethod RetProSau			Description "Retorna codigo do profissional de saude para internacao"
	WsMethod RetCriPROT			Description "Protocolo"
	WSMETHOD RetVldDent			DESCRIPTION "Retorna as faces para um determinado dente"
	WSMETHOD getCboxGen			DESCRIPTION "Retorna dados para combobox generico"
	WSMETHOD VldDente           DESCRIPTION "Valida se o dente informado existe"
	WSMETHOD VldFace            DESCRIPTION "Valida se a face informada existe"
	WSMETHOD getRadio  		    DESCRIPTION "Busca Radioterapia"
	WSMETHOD CarenBenefi		DESCRIPTION "Retorna as classes de carencia do beneficiario"
	WSMETHOD GrvUplGui		    DESCRIPTION "Realiza a gravação do protocolo de solicitação upload de guias"
	WSMETHOD ConsSolProf        DESCRIPTION "Realiza a consulta do prof solicitante ou executante p solicitação de autorização"
	WSMETHOD relTissOn			DESCRIPTION "Gera o demonstrativo usando o webservice do tissonline"
	WSMETHOD VldCpfB2n          DESCRIPTION "Valida se o CPF esta duplicado na B2n"
	WSMETHOD getObs          	DESCRIPTION "Retorna observação de peg glosada integralmente"
	WSMETHOD LogLGPD			DESCRIPTION "Registra acesso do usuario conforme LGPD"

ENDWSSERVICE
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PlsIntPad ³Autor  ³ Alexander Santos      ³ Data ³13.01.2005 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina que retorna a operadora local						     |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PlsIntPad WSRECEIVE NullParam WSSEND CodeOpe  WSSERVICE PLSXFUN
	LOCAL lRet    := .t.
	LOCAL cCodInt := PlsIntPad()

	if ! empty(cCodInt) .and. len(cCodInt) == 4
		::CodeOpe := cCodInt
	else
		SetSoapFault( "PlsIntPad", cCodInt )
		lRet := .F.
	endIf

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getCombo  ³Autor  ³ Alexander Santos      ³ Data ³02.02.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina para alimentar matriz conforme o x3_combo			   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getCombo WSRECEIVE UserCode,Tp,Alias,Retorno,Idx,Chave,CmdChave,ShowAnexo WSSEND MtStCOMBO WSSERVICE PLSXFUN
	LOCAL nI	  		:= 0
	LOCAL lRet    		:= .T.
	LOCAL aArea	  		:= GetArea()
	LOCAL aRet	  		:= {}
	LOCAL aRetAux 		:= {}
	LOCAL lOdonto 		:= GetNewPar("MV_PLATIOD","0") == "1"
	LOCAL lSisOdo 		:= GetNewPar("MV_PLSISOD","0") == "1"
	lOCAL cEvento		:=	""
	LOCAL cCodInt 		:= PlsIntPad()
	LOCAL cRetTpFt		:= ""
	LOCAL cTissVer		:= PLSTISSVER()
	LOCAL lPLSTPFAT     := ExistBlock("PLSTPFAT")

	DEFAULT ::Tp		:= 1
	DEFAULT ::Alias    	:= ""
	DEFAULT ::Retorno	:= ""
	DEFAULT ::Idx       := 1
	DEFAULT ::Chave		:= ""
	DEFAULT ::CmdChave	:= ""
	DEFAULT ::ShowAnexo	:= "0"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Checa rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode , "PLSXFUN", "getCombo" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Define a strutura principal											   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO := WsClassNew( "MsCombo" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Prestador
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If ::Tp == 1
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta o codigo da tabela codpad									   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CodPad := GetNewPar("MV_PLSTBPD","01")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box Tipo de Doença							   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPDOE",'X3_CBOX') ),,,1 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbTpDoe := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbTpDoe, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbTpDoe[nI]:Code        := AllTrim(aRet[nI,2])
						::MtStCOMBO:CbTpDoe[nI]:Description := AllTrim(aRet[nI,3])
					EndIf
				Next
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box Tempo doenca							   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_UTPDOE",'X3_CBOX') ),,,1 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbTmpDoe := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbTmpDoe, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbTmpDoe[nI]:Code        := AllTrim(aRet[nI,2])
						::MtStCOMBO:CbTmpDoe[nI]:Description := AllTrim(aRet[nI,3])
					EndIf
				Next
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box Indicacao de acidente					   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_INDACI",'X3_CBOX') ),,,1 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbIndAcid := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbIndAcid, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbIndAcid[nI]:Code        := AllTrim(aRet[nI,2])
						::MtStCOMBO:CbIndAcid[nI]:Description := AllTrim(aRet[nI,3])
					EndIf
				Next
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box										   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPCON",'X3_CBOX') ),,,1 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura Tipo de consulta								   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbTpCon := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbTpCon, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbTpCon[nI]:Code        := AllTrim(aRet[nI,2])
						::MtStCOMBO:CbTpCon[nI]:Description := AllTrim(aRet[nI,3])
					EndIf
				Next
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box Tip de saida							   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			aRet := iif(TamSX3("BEA_TIPSAI")[1]==1, RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPSAI",'X3_CBOX') ),,,1 ), PLGETDADR("BIY","BIY->BIY_CODSAI+'='+BIY->BIY_DESCRI,BIY->BIY_CODSAI,BIY->BIY_DESCRI",1,cCodInt,"BIY->BIY_CODOPE") )

			//so considera valores > 10 e nao duplicados
			if TamSX3("BEA_TIPSAI")[1] <> 1
				for nI:= 1 to len(aRet)
					if (Val(aRet[nI,2]) > 10) .and. (aScan(aRetAux, {|x| x[2] == aRet[nI,2]}) == 0)
						aadd(aRetAux,aRet[nI])
					endif
				next nI
				aRet:= aClone(aRetAux)
			endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbTpSai := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbTpSai, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbTpSai[nI]:Code        := AllTrim(aRet[nI,2])
						::MtStCOMBO:CbTpSai[nI]:Description := AllTrim(aRet[nI,3])
					EndIf
				Next
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box Carater da solicitacao					   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			If BB8->( FieldPos("BB8_CARSOL") ) == 0
				AaDd(aRet,{'U',"Urgencia/Emergencia"} )
				AaDd(aRet,{'E',"Eletiva"} )
			Else
				aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BB8_CARSOL",'X3_CBOX') ),,,1 )
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbCarSolict := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbCarSolict, WsClassNew( "GenericStruct" ) )
						If BB8->( FieldPos("BB8_CARSOL") ) == 0
							::MtStCOMBO:CbCarSolict[nI]:Code        := AllTrim(aRet[nI,1])
							::MtStCOMBO:CbCarSolict[nI]:Description := AllTrim(aRet[nI,2])
						Else
							::MtStCOMBO:CbCarSolict[nI]:Code        := AllTrim(aRet[nI,2])
							::MtStCOMBO:CbCarSolict[nI]:Description := AllTrim(aRet[nI,3])
						EndIf
					EndIf
				Next
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box tipo de atendimento					   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPATE",'X3_CBOX') ),,,2 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Para versoes inferiores a 3.0 nao utilizo os novos tipos de atendimento³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTissVer < "3.00.00"
				aRetAux := {}
				For nI := 1 to len(aRet)
					If !aRet[nI][2] $ "11,13,14,15,16,17 18,19,20,21"
						Aadd(aRetAux,aRet[nI])
					EndIf
				Next
				aRet := aRetAux
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbTpAtend := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbTpAtend, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbTpAtend[nI]:Code        := AllTrim(aRet[nI,2])
						::MtStCOMBO:CbTpAtend[nI]:Description := AllTrim(aRet[nI,3])
					EndIf
				Next
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box tipo de atendimento ODONTOLOGICO		   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPATO",'X3_CBOX') ),,,2 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbTpAtOD := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbTpAtOD, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbTpAtOD[nI]:Code        := AllTrim(aRet[nI,2])
						::MtStCOMBO:CbTpAtOD[nI]:Description := AllTrim(aRet[nI,3])
					EndIf
				Next
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Matriz auxiliar para pegar a via de acesso mais codigo da via	   	   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			BGR->( DbSetOrder(1) )//BGR_FILIAL + BGR_CODINT + BGR_CODVIA
			BGR->( DbGoTop() )
			While !BGR->( Eof() )
				AaDd(aRetAux,{BGR->BGR_VIATIS,BGR->BGR_CODVIA})
				BGR->( DbSkip() )
			EndDo
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box Via de acesso							   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BGR_VIATIS",'X3_CBOX') ),,,1 )
			For nI := 1 To Len( aRet )
				nPos := aScan( aRetAux, { |x| x[1] == aRet[nI,2] } )
				If !Empty(aRet[nI,1]) .And. nPos > 0
					aRet[nI,2] := aRetAux[nPos,2]
				EndIf
			Next
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbViaAce := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbViaAce, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbViaAce[nI]:Code        := AllTrim(aRet[nI,2])
						::MtStCOMBO:CbViaAce[nI]:Description := AllTrim(aRet[nI,3])
					EndIf
				Next
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box Tecnica Utilizada						   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BE2_TECUTI",'X3_CBOX') ),,,1 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbTecUti := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbTecUti, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbTecUti[nI]:Code        := AllTrim(aRet[nI,2])
						::MtStCOMBO:CbTecUti[nI]:Description := AllTrim(aRet[nI,3])
					EndIf
				Next
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box Grau de participacao					   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			BWT->( DbSetOrder(1) )//BWT_FILIAL + BWT_CODOPE + BWT_CODPAR
			BWT->( DbGoTop() )
			While !BWT->( Eof() )
				AaDd(aRet,{BWT->BWT_CODPAR,BWT->BWT_DESCRI} )
				BWT->( DbSkip() )
			EndDo
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbGraPart := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbGraPart, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbGraPart[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbGraPart[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box Tipo de pre atendimento				   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPO",'X3_CBOX') ),,,1 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbTpPreAte := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						//³ Se Nao for Odonto nao montar o Tipo Atendimento = 4-Odontologico
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						If !lSisOdo
							If !lOdonto .And. AllTrim(aRet[nI,2])== "4"
								Loop
							Endif
						ElseIf lSisOdo .and. AllTrim(aRet[nI,2])<> "4"
							Loop
						EndIf
						If ::ShowAnexo == '0' .and. alltrim(AllTrim(aRet[nI,2])) $ "7,8,9"
							loop
						Endif
						AaDd( ::MtStCOMBO:CbTpPreAte, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbTpPreAte[Len(::MtStCOMBO:CbTpPreAte)]:Code        := AllTrim(aRet[nI,2])
						::MtStCOMBO:CbTpPreAte[Len(::MtStCOMBO:CbTpPreAte)]:Description := AllTrim(aRet[nI,3])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box Tipo de Internacao						   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			BQR->( DbSetOrder(1) )//BQR_FILIAL + BQR_GRPINT + BQR_TIPINT
			BQR->( DbGoTop() )
			While !BQR->( Eof() )

				If BQR->BQR_GRPINT == GetNewPar("MV_GRPINT",'1')
					AaDd(aRet,{BQR->BQR_TIPINT,BQR->BQR_DESTIP} )
				EndIf

				BQR->( DbSkip() )
			EndDo
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbTpInter := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbTpInter, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbTpInter[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbTpInter[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz conforme x3_box Regime internacao						   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BE4_REGINT",'X3_CBOX') ),,,1 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbRegInter := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbRegInter, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbRegInter[nI]:Code        := AllTrim(aRet[nI,2])
						::MtStCOMBO:CbRegInter[nI]:Description := AllTrim(aRet[nI,3])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Monta matriz conforme x3_box Tipo de guia
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := {}
			aadd(aRet,{'01', 'Guia de Consulta'})
			aadd(aRet,{'02', 'Guia de SP_SADT'})
			aadd(aRet,{'05', 'Guia de Resumo de Internação '})
			aadd(aRet,{'06', 'Guia de Honorários '})
			aadd(aRet,{'10', 'Guia de Recurso de Glosa '})
			aadd(aRet,{'13', 'Odontologica '})

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbTipGui := {}
			if len(aRet) > 0
				for nI := 1 to len( aRet )
					if !empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbTipGui, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbTipGui[nI]:Code        := allTrim(aRet[nI,1])
						::MtStCOMBO:CbTipGui[nI]:Description := allTrim(aRet[nI,2])
					endIf
				next nI
			endIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Monta matriz conforme x3_box Sexo
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := {}
			aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPFAT",'X3_CBOX') ),,,1 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbTipFat := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						If lPLSTPFAT
							cRetTpFt := ExecBlock("PLSTPFAT",.F.,.F.,{})
						Endif

						If !Empty(cRetTpFt)
							If aRet[nI,2] $ Alltrim(cRetTpFt)
								AaDd( ::MtStCOMBO:CbTipFat, WsClassNew( "GenericStruct" ) )
								::MtStCOMBO:CbTipFat[Len(::MtStCOMBO:CbTipFat)]:Code        := AllTrim(aRet[nI,2])
								::MtStCOMBO:CbTipFat[Len(::MtStCOMBO:CbTipFat)]:Description := AllTrim(aRet[nI,3])
							Endif
						Else
							AaDd( ::MtStCOMBO:CbTipFat, WsClassNew( "GenericStruct" ) )
							::MtStCOMBO:CbTipFat[Len(::MtStCOMBO:CbTipFat)]:Code        := AllTrim(aRet[nI,2])
							::MtStCOMBO:CbTipFat[Len(::MtStCOMBO:CbTipFat)]:Description := AllTrim(aRet[nI,3])
						Endif
					EndIf
				Next nI
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Empresa
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		ElseIf ::Tp == 2
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Monta matriz de categoria
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := PLGETDADR("BIH","BIH->BIH_CODTIP,BIH->BIH_DESCRI")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbCategoria := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbCategoria, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbCategoria[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbCategoria[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Monta matriz conforme x3_box Sexo
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := {}
			aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BA1_SEXO",'X3_CBOX') ),,,1 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbSexo := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbSexo, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbSexo[nI]:Code        := AllTrim(aRet[nI,2])
						::MtStCOMBO:CbSexo[nI]:Description := AllTrim(aRet[nI,3])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Estado civil
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := PLGETDADR("SX5","SX5->X5_CHAVE,SX5->X5_DESCRI",1,'33',"X5_TABELA")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Alimenta a estrutura
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			::MtStCOMBO:CbEstCiv := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbEstCiv, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbEstCiv[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbEstCiv[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Estado
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := PLGETDADR("SX5","SX5->X5_CHAVE,SX5->X5_DESCRI",1,'12',"X5_TABELA")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Alimenta a estrutura
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			::MtStCOMBO:CbEstado := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbEstado, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbEstado[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbEstado[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Tipo Logradouro
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := PLGETDADR("B18","B18->B18_CODIGO,B18->B18_DESCRI")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Alimenta a estrutura
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			::MtStCOMBO:CbTipLog := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbTipLog, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbTipLog[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbTipLog[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Status
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := { {'0','Novo'},{'1','Pendente'},{'2','Rejeitado'},{'3','Aceite'} }
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Alimenta a estrutura
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			::MtStCOMBO:CbStatus := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbStatus, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbStatus[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbStatus[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Motivo de bloqueio
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := PLGETDADR("BG3","BG3->BG3_CODBLO,BG3->BG3_DESBLO",,'0',"BG3_TIPBLO",.T.)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Alimenta a estrutura
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			::MtStCOMBO:CbMotBlo := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbMotBlo, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbMotBlo[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbMotBlo[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Monta matriz conforme x3_box GrauPa
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := {}
			aRet := PLGETDADR("BRP","BRP->BRP_CODIGO,BRP->BRP_DESCRI")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStCOMBO:CbGrauPa := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbGrauPa, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbGrauPa[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbGrauPa[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Familia
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		ElseIf ::Tp == 3
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Verifico os Motivo de segunda via de cartao no Parametro
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			cEvento := AllTrim(GetNewPar("MV_PLSPERO",""))+"/"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³Posiciona na BPX
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			BPX->( DbSetOrder(1) ) //BPX_FILIAL+BPX_CODINT +BPX_MOTIVO

			While (nPos := at("/",cEvento)) > 0
				cAux   	:= SubStr(cEvento, 1, nPos-1)
				cEvento	:= SubStr(cEvento, nPos+1)

				If	BPX->( MsSeek( xFilial( "BPX" ) + cCodInt+cAux) )
					AaDd(aRet, {BPX->BPX_MOTIVO,BPX->BPX_DESCRI } )
				EndIf
			EndDo
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Alimenta a estrutura
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			::MtStCOMBO:CbMotCar := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbMotCar, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbMotCar[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbMotCar[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Especifico
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		ElseIf ::Tp == 4
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Retorno Generico
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := PLGETDADR(::Alias,::Retorno,::Idx,::Chave,::CmdChave)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Alimenta a estrutura
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			::MtStCOMBO:CbGeneric := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbGeneric, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbGeneric[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbGeneric[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Movimentacao
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		ElseIf ::Tp == 5
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Situacao
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := { {'1','Pendente'},{'2','Rejeitado'},{'3','Aceite'} }
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Alimenta a estrutura
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			::MtStCOMBO:CbSituac := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbSituac, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbSituac[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbSituac[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Operacao
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := { {'0','Carteirinha'},{'1','Inclusão'},{'2','Alteração'},{'3','Cancelamento'} }
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Alimenta a estrutura
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			::MtStCOMBO:CbOperac := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbOperac, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbOperac[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbOperac[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Tipo
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := { {'0','Analítico'},{'1','Sintético'} }
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Alimenta a estrutura
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			::MtStCOMBO:CbTipo := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbTipo, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbTipo[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbTipo[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next nI
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Situacao Cadastral
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := { {'0','Ativo'},{'1','Bloqueado'} }
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Alimenta a estrutura
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			::MtStCOMBO:CbSitCad := {}
			If Len(aRet) > 0
				For nI := 1 To Len( aRet )
					If !Empty(aRet[nI,1])
						AaDd( ::MtStCOMBO:CbSitCad, WsClassNew( "GenericStruct" ) )
						::MtStCOMBO:CbSitCad[nI]:Code        := AllTrim(aRet[nI,1])
						::MtStCOMBO:CbSitCad[nI]:Description := AllTrim(aRet[nI,2])
					EndIf
				Next nI
			EndIf
		EndIf
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRet

/*/{Protheus.doc} getParam
Carrega todos os parametros do app

@type function
@author PLSTEAM
@since 20.03.18
@version 1.0
/*/
WSMETHOD getParam WSRECEIVE UserCode WSSEND MtStPARAM WSSERVICE PLSXFUN
	local lRet := .t.
	local aLink := {}
	local lLinkProf := .T.
	local lLinkProd := .T.
	//Checa rotina
	if PrtChkUser( ::UserCode , "PLSXFUN", "getParam" )

		//Define a strutura principal
		::MtStPARAM := WsClassNew( "MsParam" )

		If ExistBlock("PLSHABLIN")
			aLink := ExecBlock("PLSHABLIN",.F.,.F.)
			lLinkProf := aLink[1]
			lLinkProd := aLink[2]
		EndIf

		If lLinkProf
			::MtStPARAM:LinkProfi 	:= superGetMV("MV_PLLPROF",, 'Rede Credenciada')
			If Empty(superGetMV("MV_PLLPROF",, 'Rede Credenciada'))
				::MtStPARAM:LinkProfi := 'Rede Credenciada'
			EndIf
		Else
			::MtStPARAM:LinkProfi := ''
		EndIf

		If lLinkProd
			::MtStPARAM:LinkProdu 	:= superGetMV("MV_PLLPROD",, 'Consulte aqui os Produtos')
			If Empty(superGetMV("MV_PLLPROD",, 'Consulte aqui os Produtos'))
				::MtStPARAM:LinkProdu := 'Consulte aqui os Produtos'
			EndIf
		Else
			::MtStPARAM:LinkProdu := ''
		EndIf

		::MtStPARAM:LinkPriAc 	:= iIf( superGetMV("MV_PLLPACE",, .f.), "Primeiro acesso", "" )
		::MtStPARAM:TimeAte 	:= superGetMV("MV_PTIMATE",, .f.)
		::MtStPARAM:LogProd 	:= superGetMV("MV_PLLOGPR",, .f.)
		::MtStPARAM:Unimeds 	:= iIf( superGetMV("MV_PLSUNI",, '0') == '0', .f., .t.)
		::MtStPARAM:SmtpEnv 	:= superGetMV("MV_RELSERV",, '')
		::MtStPARAM:UsuEmai 	:= superGetMV("MV_RELACNT",, '')
		::MtStPARAM:UsuPass 	:= superGetMV("MV_RELPSW",, '')
		::MtStPARAM:AprNImp 	:= superGetMV("MV_PLSNIMP",, '')
		::MtStPARAM:CodCons 	:= subStr(superGetMV("MV_PLSCDCO",, ''),3,16)
		::MtStPARAM:Diagno 		:= iIf( superGetMV("MV_PLSDGN",, '.f.') == '.f.', .f., .t. )
		::MtStPARAM:FiltPRF 	:= superGetMV("MV_PLSPRFS",, .f.)
		::MtStPARAM:PreAten 	:= superGetMV("MV_PLPREAT",, .f.)
		::MtStPARAM:UsuProc 	:= superGetMV("MV_PLPROGE",, '')
		::MtStPARAM:ChaGe 		:= superGetMV("MV_PLCHAGE",, '')
		::MtStPARAM:MatrAnt 	:= iIf( superGetMV("MV_PLMATAP",, '0') == '0', .f., .t.)
		::MtStPARAM:ValParam 	:= superGetMV("MV_PLCALPG",, '1')
		::MtStPARAM:MVQTDIARQ 	:= superGetMV("MV_QTDIARQ",, '0')
		::MtStPARAM:MVLOGSCHE 	:= superGetMV("MV_LOGSCHE",, '1')
		::MtStPARAM:MosGui 		:= iIf( superGetMV("MV_PLSEGU",, '1') == '1', .t., .f.)
		::MtStPARAM:CodOff 		:= superGetMV("MV_PLSDIGP",, '')
		::MtStPARAM:POGTISS 	:= superGetMV("MV_POGTISS",, .f.)
		::MtStPARAM:Baixar 		:= iIf( superGetMV("MV_PLPDWN",, .f.), '1', '0')
		::MtStPARAM:VldOpc 		:= superGetMV("MV_PVLOPCT",, .f.)

		::MtStPARAM:RecOb 		:= iIf( superGetMV("MV_PLRECOB",, .f.), 'true', 'false')
		::MtStPARAM:MultComp 	:= iIf( superGetMV("MV_PLREEMC",, .f.), 'true', 'false')
		::MtStPARAM:TourReemb 	:= iIf( superGetMV("MV_PLTOURE",, .f.), 'true', 'false')

		::MtStPARAM:TitPar 		:= superGetMV("MV_PLCDTIT",, "T")
		::MtStPARAM:MVLRN360	:= superGetMV("MV_LRN360",, '')
		::MtStPARAM:PL395WS		:= iIf( superGetMV("MV_PL395WS",, '0') == '0', .f., .t. )
		::MtStPARAM:PLSDRDA		:= superGetMV("MV_PLSDRDA",, '')
		::MtStPARAM:PLCMPFP		:= superGetMV("MV_PLCMPFP",, '')

	else

		lRet := .f.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )

	endIf

return(lRet)
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetDadG     ³Autor³ Alexander Santos      ³ Data ³22.02.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna dados especificos por tipo de guia				   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetDadG WSRECEIVE UserCode,Tipo WSSEND MtStDadESP WSSERVICE PLSXFUN
	LOCAL aArea	:= GetArea()
	LOCAL nI	:= 0
	LOCAL lRet  := .T.
	LOCAL aRet	:= {}

	//Checa rotina
	If PrtChkUser( ::UserCode, "PLSXFUN", "GetDadG" )

		//Define a strutura principal
		::MtStDadESP := WsClassNew( "MSDadESP" )

		Do Case

			//Consulta
			Case ::Tipo == '1'

				//Sadt
			Case ::Tipo == '2'

				//Internacao
			Case ::Tipo == '3'

				//Dados da internacao
				aRet := {}
				aRet := PLRDATP()

				//Alimenta a estrutura
				::MtStDadESP:DadRdaTp := {}

				If Len(aRet) > 0
					For nI := 1 To Len( aRet )
						AaDd( ::MtStDadESP:DadRdaTp, WsClassNew( "MSDadRda" ) )
						::MtStDadESP:DadRdaTp[nI]:Code      := aRet[nI,1]
						::MtStDadESP:DadRdaTp[nI]:Name 		:= AllTrim(aRet[nI,2])
						::MtStDadESP:DadRdaTp[nI]:CnpfCpf 	:= aRet[nI,3]
						::MtStDadESP:DadRdaTp[nI]:Cnes 		:= aRet[nI,4]
						::MtStDadESP:DadRdaTp[nI]:CodProf	:= aRet[nI,5]
						::MtStDadESP:DadRdaTp[nI]:CodOpe		:= aRet[nI,6]
					Next

				EndIf

				//Odontologico
			Case ::Tipo == '4'

				//Alimenta o codigo da tabela codpad
				::MtStDadESP:CodPad := GetNewPar("MV_PLSTPOD",GetNewPar("MV_PLSTBPD","01") )

				//Honorario Individual
			Case ::Tipo == '5'

				//Alimenta a estrutura
				BWT->( DbSetOrder(3) )//BWT_FILIAL + BWT_CODOPE + BWT_CODEDI
				BWT->( DbGoTop() )

				//Monta retorno
				::MtStDadESP:CbGraPar := {}
				While !BWT->( Eof() )

					If !Empty(BWT->BWT_CODEDI)

						AaDd( ::MtStDadESP:CbGraPar, WsClassNew( "GenericStruct" ) )
						::MtStDadESP:CbGraPar[Len(::MtStDadESP:CbGraPar)]:Code        := BWT->BWT_CODPAR
						::MtStDadESP:CbGraPar[Len(::MtStDadESP:CbGraPar)]:Description := AllTrim(BWT->BWT_DESCRI)

					EndIf

					BWT->( DbSkip() )
				EndDo

		EndCase

	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³UserCardVa³Autor  ³ Alexander Santos      ³ Data ³05.11.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao do cartao do usuário                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD UserCardValidation WSRECEIVE UserCode, UserCardNumber, UserCardEdition ,UserCardName, LOCALExec, AreaAbr ,Tipo, TipAtd, DatGuia, BloqGui, TriCar WSSEND  UserCard WSSERVICE PLSXFUN
	LOCAL nI			:= 0
	LOCAL lRetorno 		:= .T.
	LOCAL aArea 		:= GetArea()
	LOCAL aRetorno 		:= {}
	LOCAL lMatrAnt      := GetNewPar("MV_PLMATAP","0") == "1" //Mostra Matricula Antiga Portal
	Local nDiasBloq		:= GetNewPar("MV_PLDIABL", 0) //Tolerância para atendimento de usuário bloqueado

	DEFAULT ::LOCALExec := ""
	DEFAULT ::AreaAbr   := ""
	DEFAULT ::Tipo		:= "0"
	DEFAULT ::DatGuia	:= ""
	DEFAULT ::BloqGui	:= ""
	DEFAULT ::TriCar	:=""

	If PrtChkUser( ::UserCode, "PLSXFUN", "USERCARDVALIDATION" )

		aRetorno := PLVLDUSRP( ::UserCardNumber, ::UserCardEdition,::UserCardName,::LOCALExec,::AreaAbr,"2",::Tipo,::TipAtd,::DatGuia,::BloqGui, ::TriCar)

		If Len(aRetorno) > 0
			If aRetorno[1]
				::UserCard 					:= WsClassNew( "UserCardView" )
				::UserCard:CardNumber		:= IIF(lMatrAnt .And. !Empty(aRetorno[3,1,2]),aRetorno[3,1,2],aRetorno[3,1,1])
				::UserCard:CardNumberOld	:= aRetorno[3,1,2]
				::UserCard:CardName			:= Upper(aRetorno[3,1,3])
				::UserCard:Interchange		:= aRetorno[3,1,4]
				::UserCard:OpeOri	   	    := aRetorno[3,1,5]
				::UserCard:Plano	   	    := aRetorno[3,1,6]
				::UserCard:ValCar	   	    := aRetorno[3,1,7]
				::UserCard:NumCarNac	    := aRetorno[3,1,8]
				::UserCard:ViaCartao		:= aRetorno[3,1,9]
				::UserCard:LOCALCob			:= aRetorno[3,1,10]
				::UserCard:Abrange			:= aRetorno[3,1,11]
				::UserCard:NatJuri			:= aRetorno[3,1,12]
				::UserCard:Telefone			:= aRetorno[3,1,13]
				::UserCard:NomTit			:= aRetorno[3,1,14]
				::UserCard:NomEmp			:= aRetorno[3,1,15]
				::UserCard:Vida				:= aRetorno[3,1,16]
				::UserCard:Dig1				:= aRetorno[3,1,17]
				::UserCard:Dig2				:= aRetorno[3,1,18]
				::UserCard:TpAcom			:= aRetorno[3,1,19]
				::UserCard:PadCon			:= aRetorno[3,1,20]
				::UserCard:DesAcom			:= aRetorno[3,1,21]
				::UserCard:ChkBioInter		:= GetNewPar("MV_PLCHINB","0") == "1"
				::UserCard:CritPreAtdm		:= GetNewPar("MV_CRIPREA",.F.)
				::UserCard:NomSocBn			:= aRetorno[3,1,38]
				//         If !(GetNewPar("MV_PLATURG",.F.))
				If Len(aRetorno[3,1]) >= 22
					::UserCard:DatBlo           := iif(valType(aRetorno[3,1,22]) == "C", cToD(aRetorno[3,1,22]), aRetorno[3,1,22])
				EndIf

				IF !(aRetorno[3,1,23])  //Verifico se tem algum tipo de bloqueio

				IF (Empty(::DatGuia)) //Não vem da digitação de guias off-line
					If  !Empty(::UserCard:DatBlo) .AND. (::UserCard:DatBlo + nDiasBloq )<= (dDatabase)
						lRetorno := .F.
						SetSoapFault( "", "Usuário Bloqueado, não será possível prosseguir com o atendimento!!!" )
					Else
						lRetorno := .T.
						::UserCard:MsnBloInter	:= aRetorno[2]
					Endif
				ELSE
					IF ( !Empty(::UserCard:DatBlo) .AND. (::UserCard:DatBlo + nDiasBloq )<= (cToD(::DatGuia)) )
						lRetorno := .F.
						SetSoapFault( "", "Usuário Bloqueado, não será possível prosseguir com o atendimento!!!" )
					ElseIf cToD(::DatGuia) < BA1->BA1_DATINC //vemos se o beneficiário já estava cadastrado na data, estamos com a BA1 posicionada
						lRetorno := .F.
						SetSoapFault( "","Data de Atendimento anterior à data de inclusão do Beneficiário!"	)
					Endif
				ENDIF
			ENDIF

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Retorna Criticas do usuário											   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::UserCard:UserCritica 	:= {}
			//DatGuia preenchido significa digitação off-line. A regra de cima verifica se a data do atendimento é menor que bloqueio
			//pois o PLSVLDCON usa a database para conferir bloqueio e no nosso caso, pode estar bloqueado hoje, mas alguns dias atras não.

			If Len(aRetorno[4]) > 0 .AND. (Empty(::DatGuia))
				For nI := 1 To Len( aRetorno[4] )
					if aRetorno[4,nI,1] == "004" //Valida se for a crítica financeira, aparecer "1001 - NUMERO DA CARTEIRA INVALIDO"
						AaDd( ::UserCard:UserCritica, WsClassNew( "UserCardCri" ) )
						cCdTerm := PLSGETVINC("BTU_CDTERM", "BCT", .F.,"38")
						cDester := PLSGETVINC("BTQ_DESTER", "BCT", .F.,"38")
						if !(cCdTerm == "" .Or. cCdTerm == Nil) .And. !(cDester == "" .Or. cDester == Nil)
							aRetorno[4,nI,1] := cCdTerm
							aRetorno[4,nI,3] := cDester
							::UserCard:UserCritica[nI]:DesPri := aRetorno[4,nI,1]
							::UserCard:UserCritica[nI]:DesTer := aRetorno[4,nI,3]
						else
							AaDd( ::UserCard:UserCritica, WsClassNew( "UserCardCri" ) )
							::UserCard:UserCritica[nI]:DesPri := aRetorno[4,nI,1]
							::UserCard:UserCritica[nI]:DesSeq := aRetorno[4,nI,2]
							::UserCard:UserCritica[nI]:DesTer := aRetorno[4,nI,3]
						endIf
					else
						AaDd( ::UserCard:UserCritica, WsClassNew( "UserCardCri" ) )
						::UserCard:UserCritica[nI]:DesPri := aRetorno[4,nI,1]
						::UserCard:UserCritica[nI]:DesSeq := aRetorno[4,nI,2]
						::UserCard:UserCritica[nI]:DesTer := aRetorno[4,nI,3]
					endif
				Next
			EndIf
			//		  EndIf
		Else
			lRetorno := .F.
			SetSoapFault( "", aRetorno[2] )
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Passe o cartão ou digite a matricula novamente" )
	EndIf
	Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³BrwRDA    ³Autor  ³ Alexander Santos      ³ Data ³05.11.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao do cartao do usuário                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD BrwRDA WSRECEIVE UserCode, UserLCode WSSEND ListOfRDA WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea 		:= GetArea()
	LOCAL aRetorno 		:= {}
	LOCAL nI			:= 0
	LOCAL nY			:= 0

	If PrtChkUser( ::UserCode, "PLSXFUN", "BRWRDA" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Rda																	   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRetorno := PLRELRDA( ::UserLCode:UserLoginCode )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Matriz Rda															   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::ListOfRda := {}
		For nI := 1 To Len( aRetorno )
			aAdd( ::ListOfRda, WsClassNew( "RDAView" ) )
			::ListOfRda[nI]:Code		:= aRetorno[nI][1]
			::ListOfRda[nI]:Name		:= aRetorno[nI][2]
			::ListOfRda[nI]:RegAtend	:= aRetorno[nI][3]
			::ListOfRda[nI]:TpPrest		:= aRetorno[nI][4]
			::ListOfRda[nI]:CnpfCpf		:= aRetorno[nI][5]
			::ListOfRda[nI]:Cnes		:= aRetorno[nI][6]
			::ListOfRda[nI]:TpLograd	:= aRetorno[nI][7]
			::ListOfRda[nI]:Address		:= aRetorno[nI][8]
			::ListOfRda[nI]:Numero		:= aRetorno[nI][9]
			::ListOfRda[nI]:Complen		:= aRetorno[nI][10]
			::ListOfRda[nI]:District	:= aRetorno[nI][11]
			::ListOfRda[nI]:Zone		:= aRetorno[nI][12]
			::ListOfRda[nI]:State		:= aRetorno[nI][13]
			::ListOfRda[nI]:IBGE		:= aRetorno[nI][14]
			::ListOfRda[nI]:Cep			:= aRetorno[nI][15]
			::ListOfRda[nI]:RegAns		:= aRetorno[nI][16]
			::ListOfRda[nI]:SigCr		:= aRetorno[nI][18]
			::ListOfRda[nI]:CodCr		:= aRetorno[nI][19]
			::ListOfRda[nI]:EstCr		:= aRetorno[nI][20]
			::ListOfRda[nI]:TipPE		:= aRetorno[nI][21]
			::ListOfRda[nI]:CodBB0		:= aRetorno[nI][22]
			::ListOfRda[nI]:CodOpe		:= aRetorno[nI][23]
			::ListOfRda[nI]:CodLoc		:= aRetorno[nI][24]
			::ListOfRda[nI]:DesLoc		:= aRetorno[nI][25]
			::ListOfRda[nI]:CarSol		:= aRetorno[nI][28]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Versão da TISS                      									   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Len(aRetorno[nI]) >=29
				::ListOfRda[nI]:TissVer		:= aRetorno[nI][29]
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Matriz Especialidades												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::ListOfRda[nI]:MEspRda := {}
			For nY := 1 To Len( aRetorno[nI,26] )
				AaDd( ::ListOfRda[nI]:MEspRda, WsClassNew( "EspRda" ) )
				::ListOfRda[nI]:MEspRda[nY]:CodEsp		:= aRetorno[nI,26,nY][1]
				::ListOfRda[nI]:MEspRda[nY]:DesEsp 	:= aRetorno[nI,26,nY][2]
				::ListOfRda[nI]:MEspRda[nY]:CodCBOS	:= aRetorno[nI,26,nY][3]
				::ListOfRda[nI]:MEspRda[nY]:DesCBOS	:= aRetorno[nI,26,nY][4]
			Next nY
		Next nI
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ProfSaud  ³Autor  ³ Alexander				³ Data ³01.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Pega todos os profissionais de saude BB0					   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ProfSaud WSRECEIVE UserCode,RDACode,CodLoc,Busca,Tipo, TipGui, TipProf, CarreExe WSSEND ObjProfSaud WSSERVICE PLSXFUN
	Local lRetorno 	   := .T.
	Local aArea 	   := GetArea()
	Local aRetorno 	   := {}
	Local nI		   := 0
	Local nJ		   := 1
	DEFAULT ::Busca    := ""
	DEFAULT ::Tipo	   := "1"
	DEFAULT ::TipGui   := ""
	DEFAULT ::TipProf  := "S"
	DEFAULT ::CarreExe := .T.

	If PrtChkUser( ::UserCode, "PLSXFUN", "ProfSaud" )

		//Profissional de saude
		// Solicitante: 1
		// Executante : 2

		if ::TipProf == "S"
			//Verifica retorno
			aRetorno := PLPROFSAUD(::RDACode,::CodLoc,::Busca,::Tipo, 1, ::TipGui)

			If !Empty(aRetorno)

				::ObjProfSaud:ListProfSaud := {}

				For nI := 1 To Len( aRetorno )

					aAdd( ::ObjProfSaud:ListProfSaud, WsClassNew( "ProfSaud" ) )

					::ObjProfSaud:ListProfSaud[nI]:Code		:= aRetorno[nI][1]
					::ObjProfSaud:ListProfSaud[nI]:Name 	:= aRetorno[nI][2]
					::ObjProfSaud:ListProfSaud[nI]:CodSig	:= aRetorno[nI][3]
					::ObjProfSaud:ListProfSaud[nI]:NumCr	:= aRetorno[nI][4]
					::ObjProfSaud:ListProfSaud[nI]:Estado	:= aRetorno[nI][5]
					::ObjProfSaud:ListProfSaud[nI]:CpfCnpj	:= aRetorno[nI][6]
					::ObjProfSaud:ListProfSaud[nI]:CodOpe	:= aRetorno[nI][7]
					::ObjProfSaud:ListProfSaud[nI]:Especi  := {}

					nK := 1

					If Len(aRetorno[nI]) >= 12 .and. !Empty(aRetorno[nI][12])

						For nJ := 1 to Len(aRetorno[nI][12])

							AaDd( ::ObjProfSaud:ListProfSaud[nI]:Especi, WsClassNew( "GenericStruct" ) )

							::ObjProfSaud:ListProfSaud[nI]:Especi[nK]:Code			:= aRetorno[nI][12][nJ][1]
							::ObjProfSaud:ListProfSaud[nI]:Especi[nK]:Description	:= aRetorno[nI][12][nJ][2]

							nK++

						Next

					Endif

				Next nI
			EndIf

		else
			//³Profissional de saude Executante
			If ::CarreExe != NIL .AND. ::CarreExe

				aRetorno := PLPROFSAUD(::RDACode,::CodLoc,::Busca,::Tipo, 2, ::TipGui)

				If !Empty(aRetorno)

					::ObjProfSaud:ListPfSExe := {}

					For nI := 1 To Len( aRetorno )

						aAdd( ::ObjProfSaud:ListPfSExe, WsClassNew( "ProfSaud" ) )

						::ObjProfSaud:ListPfSExe[nI]:Code		:= aRetorno[nI][1]
						::ObjProfSaud:ListPfSExe[nI]:Name 		:= aRetorno[nI][2]
						::ObjProfSaud:ListPfSExe[nI]:CodSig		:= aRetorno[nI][3]
						::ObjProfSaud:ListPfSExe[nI]:NumCr		:= aRetorno[nI][4]
						::ObjProfSaud:ListPfSExe[nI]:Estado		:= aRetorno[nI][5]
						::ObjProfSaud:ListPfSExe[nI]:CpfCnpj	:= aRetorno[nI][6]
						::ObjProfSaud:ListPfSExe[nI]:CodOpe		:= aRetorno[nI][7]
						::ObjProfSaud:ListPfSExe[nI]:Especi  := {}

						nK := 1

						If Len(aRetorno[nI]) >= 12 .and. !Empty(aRetorno[nI][12])

							For nJ:=1 to Len(aRetorno[nI][12])

								AaDd( ::ObjProfSaud:ListPfSExe[nI]:Especi, WsClassNew( "GenericStruct" ) )
								::ObjProfSaud:ListPfSExe[nI]:Especi[nK]:Code		:= aRetorno[nI][12][nJ][1]
								::ObjProfSaud:ListPfSExe[nI]:Especi[nK]:Description	:= aRetorno[nI][12][nJ][2]
								nK++

							Next

						Endif

					Next nI

				EndIf

			EndIf
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ProfSAll  ³Autor  ³ Daher					³ Data ³01.03.2013 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Pega todos os profissionais de saude BB0					   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ProfSAll WSRECEIVE UserCode,Busca WSSEND ObjProfSaud WSSERVICE PLSXFUN
	Local lRetorno 	:= .T.
	Local aArea 	:= GetArea()
	Local aRetorno 	:= {}
	Local nI		:= 0
	Local nJ		:= 1
	DEFAULT ::Busca := ""

	If PrtChkUser( ::UserCode, "PLSXFUN", "ProfSaud" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Profissional de saude												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRetorno := PROFALL(::Busca)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica retorno														   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		::ObjProfSaud:ListProfSaud := {}
		For nI := 1 To Len( aRetorno )
			aAdd( ::ObjProfSaud:ListProfSaud, WsClassNew( "ProfSaud" ) )
			::ObjProfSaud:ListProfSaud[nI]:Code		:= aRetorno[nI][1]
			::ObjProfSaud:ListProfSaud[nI]:Name 	:= aRetorno[nI][2]
			::ObjProfSaud:ListProfSaud[nI]:CodSig	:= aRetorno[nI][3]
			::ObjProfSaud:ListProfSaud[nI]:NumCr	:= aRetorno[nI][4]
			::ObjProfSaud:ListProfSaud[nI]:Estado	:= aRetorno[nI][5]
			::ObjProfSaud:ListProfSaud[nI]:CpfCnpj	:= aRetorno[nI][6]
			::ObjProfSaud:ListProfSaud[nI]:CodOpe	:= aRetorno[nI][7]
			::ObjProfSaud:ListProfSaud[nI]:Especi  := {}
			nK := 1
			If Len(aRetorno[nI]) >= 12 .and. !Empty(aRetorno[nI][12])
				For nJ:=1 to Len(aRetorno[nI][12])
					AaDd( ::ObjProfSaud:ListProfSaud[nI]:Especi, WsClassNew( "GenericStruct" ) )
					::ObjProfSaud:ListProfSaud[nI]:Especi[nK]:Code			:= aRetorno[nI][12][nJ][1]
					::ObjProfSaud:ListProfSaud[nI]:Especi[nK]:Description	:= aRetorno[nI][12][nJ][2]
					nK++
				Next
			Endif
		Next nI


	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetEmail	    ³Autor  ³ Alexander				³ Data ³15/06/2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina para envio da senha do usuário por e-mail				   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetEmail WSRECEIVE UserCode, UserEmail, SmtpEnv, UsuEmai, UsuPass WSSEND MsgRet WSSERVICE PLSXFUN
	LOCAL aArea    		:= GetArea()
	LOCAL lRetorno		:= .T.
	LOCAL cBody			:= ""
	LOCAL cSenhaTemp	:= ""
	LOCAL cDirRaiz 		:= PLSMUDSIS( GetNewPar("MV_TISSDIR","\TISS\") )
	LOCAL cDirWeb			:= PLSMUDSIS( cDirRaiz+"UPLOAD\")
	Local carqName		:= ""
	LOCAL dDataB		:= DATE()
	DEFAULT ::MsgRet 	:= ""

	If PrtChkUser( ::UserCode, "PLSXFUN", "GetEmail" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se o email existe											   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BSW->(DbSetOrder(4)) //BSW_FILIAL + BSW_EMAIL
		If BSW->( MsSeek(xFilial("BSW")+UPPER(Alltrim(UserEmail))))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Monta o corpo do e-mail												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cBody := "<html><style type='text/css'><!-- .texto {font-family: Arial, Helvetica, sans-serif;font-size: 12px;"
			cBody += "color: #333333;text-decoration: none;font-weight: normal;}"
			cBody += ".titulo {	font-family: Arial, Helvetica, sans-serif;font-size: 16px;"
			cBody += "color: #19167D;text-decoration: none;font-weight: bold;} --> </style><body>"
			cBody += "<table width='550' border='0' cellpadding='0' cellspacing='0'><tr>"
			cBody += "<td height='263' align='left' valign='top' class='texto'><p class='titulo'><strong><font size='4'>"
			cBody += "Senha de acesso ao Portal do Plano de Saude"
			cBody += "</font></strong></p>"
			While !BSW->(Eof()) .And. BSW->(BSW_FILIAL+UPPER(Alltrim(BSW_EMAIL))) == xFilial("BSW")+UPPER(Alltrim(UserEmail))
				cBody += "<table  width='550' border='1' cellpadding='2' cellspacing='2' bordercolor='#D2DCDF'>"
				cBody += "<tr bordercolor='#D2DCDF' bgcolor='F2F3F5'>"
				cBody += "<td><span class='texto'>"
				cBody += "Login: "
				cBody += "<strong>" + AllTrim(BSW->BSW_LOGUSR) + "</strong><br>"
				cSenhaTemp := Embaralha(DtoS(date())+StrTran(Time(),":","")+AllTrim(BSW->BSW_LOGUSR)+Alltrim(BSW->BSW_EMAIL),0)
				cSenhaTemp := Left(Alltrim(cSenhaTemp),8)
				RecLock("BSW",.F.)
				BSW->BSW_SENHA := PLSCRIDEC(1,AllTrim(cSenhaTemp))
				BSW->BSW_DTSEN := dDataB
				BSW->(MsUnlock())
				cBody += "Senha:" + AllTrim(cSenhaTemp) + "</strong></span></td>"
				cBody += "</tr></table><br />"
				BSW->(DbSkip())
			End
			cBody += "</td></tr></table></body></html>"

			//criamos o arquivo .htm temporário para enviar o e-mail
			cArqName := cDirWeb + "00001" + "senha" + STRTran(time(), ":", "_") + ".htm"
			nHandle  := FCreate(carqName)

			fWrite(nHandle, cBody) //colocamos o conteúdo no arquivo
			fclose(nHandle)

			//Função de envio de e-mails dos sinalizadores
			PlsWFProc("00001", "email esqueceu a senha", "Senha do PORTAL Plano de Saude", cBody, AllTrim(UserEmail), , , carqName, , , ,)

			//Apagamos o arquivo criado
			FErase(carqName)
			::MsgRet := "Senha enviada com sucesso!"

		Else
			::MsgRet := "E-MAIL não encontrado"
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea(aArea)

Return(lRetorno)
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetHistLogin³Autor  ³ Alexander 	        ³ Data ³15.06.2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna o Historio de acesso ao portal para um Usuário	   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetHistLogin WSRECEIVE UserCode, MViewPar  WSSEND MViewHistLog WSSERVICE PLSXFUN
	LOCAL nI
	LOCAL lRetorno 		:= .T.
	LOCAL aArea 		:= GetArea()
	LOCAL aRet			:= {}

	If PrtChkUser( ::UserCode, "PLSXFUN", "GetHistLogin" )

		aRet := PLSHISTLOG( ::MViewPar:CodLog,::MViewPar:DateDe,::MViewPar:DateAte,::MViewPar:HorDe,::MViewPar:HorAte )

		::MViewHistLog 	:= {}
		If Len(aRet) > 1
			For nI := 1 To Len( aRet )
				AaDd( ::MViewHistLog, WsClassNew( "SViewHistLog" ) )
				::MViewHistLog[nI]:DataAc 		:= DtoC(aRet[nI,1])
				::MViewHistLog[nI]:HoraAc 		:= aRet[nI,2]
				::MViewHistLog[nI]:EstacaoAc 	:= aRet[nI,3]
			Next
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ChkCid 	³Autor  ³ Alexander	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o cid	e valido						  		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ChkCid WSRECEIVE UserCode, Cid WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea    		:= GetArea()
	LOCAL cTamCid		:= padr(::cId, TamSX3("BA9_CODDOE")[1], "")
	DEFAULT ::WSNULL 	:= "true|"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "ChkCid" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se verifica se e consulta											   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BA9->( DbSetOrder(1) )//BA9_FILIAL+BA9_CODDOE
		If !BA9->( MsSeek( xFilial("BA9")+cTamCid ) )
			::WSNULL  := "false|Cid não encontrado"
		Else
			::WSNULL := alltrim(BA9->BA9_DOENCA)
		Endif
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetLstPro ³Autor  ³ Roberto	            ³ Data ³10.04.2015	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna lista de procedimentos do pacote   	 	 		 	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetLstPro WSRECEIVE ProDad WSSEND WSNULL WSSERVICE PLSXFUN
	local cCodPad  		:= ::ProDad:CodPad
	local cCodPro  		:= ::ProDad:CodPro
	local cProcedimento := ''
	local nCont	 		:= 0
	local cCodInt		:= plsIntPad()
	local cCodPadVinc	:= ''
	local cCodProVinc	:= ''
	local cDesProVinc	:= ''
	local cSQL			:= ''
	local lPLSEXPC 		:= getNewPar("MV_PLSEXPC",.f.)

	private aTabDup 	:= {}

	default ::WSNULL 	:= ""

	//TODO - 20/04/2018 - Roberto - necessario rever este codigo

	if lPLSEXPC

		aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB", .F. ,"87"))

		cSQL := " SELECT BLE_CPADOC, BLE_CODOPC, BLE_CODPRO, BLE_CODPAD "
		cSQL += "   FROM " + retSQLName("BLE")
		cSQL += "  WHERE BLE_FILIAL = '" + xFilial("BLE") + "' "
		cSQL += "    AND BLE_CODINT = '" + cCodInt + "' "
		cSQL += "    AND BLE_CODPAD = '" + cCodPad + "' "
		cSQL += "    AND BLE_CODPRO = '" + cCodPro + "' "
		cSQL += "    AND BLE_TIPO   = '9' "
		cSQL += "    AND ( BLE_VIGDE <= '" + dtos(dDataBase) + "' AND "
		cSQL += "        ( BLE_VIGATE = '' OR '" + dtos(dDataBase) + "' <= BLE_VIGATE ) ) "
		cSQL += "    AND D_E_L_E_T_ = '' "

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,ChangeQuery(cSQL)),"TRBBLE",.T.,.F.)

		if ! TRBBLE->( eof() )
			::WSNULL += "true|"
		endIf

		while ! TRBBLE->(eof())

			if nCont <> 0
				::WSNULL += "|"
			endIf

			cProcedimento 	:= posicione("BR8",1, xFilial("BR8") + TRBBLE->(BLE_CPADOC + BLE_CODOPC),"BR8_DESCRI")

			cPadBkp 		:= PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  AllTrim(TRBBLE->BLE_CPADOC) ,.T.)

			cCodProVinc	  	:= PLSGETVINC("BTU_CDTERM", "BR8", .F., cCodPadVinc,  Alltrim(AllTrim(TRBBLE->BLE_CPADOC) + AllTrim(TRBBLE->BLE_CODOPC)), .F. ,aTabDup, @cPadBkp)

			cCodPadVinc   	:= cPadBkp

			cDesProVinc	  	:= PlDcCrcPrt( PLSGETVINC("BTQ_DESTER", "BR8", .F., cCodPadVinc,  Alltrim(AllTrim(TRBBLE->BLE_CPADOC) + AllTrim(TRBBLE->BLE_CODOPC))) )

			//Adicionando campos para preenchimento da grade em tela.
			::WSNULL += "cCodPadSSol;" + cCodPadVinc/*AllTrim(BLE->BLE_CPADOC)*/ + "~"+ "cCodProSSol;"+ cCodProVinc/*AllTrim(BLE->BLE_CODOPC)*/ + "~" + "cDesProSSol;" + /*AllTrim(cProcedimento)*/cDesProVinc

			nCont += 1

			TRBBLE->(dbSkip())
		endDo

		TRBBLE->( dbCloseArea() )

	endIf

	::WSNULL += "||"

return .t.

/*/{Protheus.doc} ChkCodPct
Verifica se o procedimento e pacote
@author PLSTEAM
@since 07/2016
@version P12
/*/
WSMETHOD ChkCodPct WSRECEIVE ProDad  WSSEND WSNULL WSSERVICE PLSXFUN
	local cCodInt	:= plsIntPad()
	local cCodPad  	:= ::ProDad:CodPad
	local cCodPro  	:= ::ProDad:CodPro
	local cCodRda	:= ::ProDad:CodRda
	local lRetorno 	:= "3"
	local aDados	:= {}
	local lPLSEXPC 	:= getNewPar("MV_PLSEXPC",.f.)
	local nTamCODPRO:= BLE->(tamSX3("BLE_CODPRO")[1])
	local cSQL		:= ''

	default ::WSNULL := ''

	//TODO - 20/04/2018 - Roberto - necessario rever este codigo
	//TODO - Verificar chamada deste metodo ao sair do campo codpad (neste momento o codpro esta vindo errado) tabela B7B
	//TODO - verificar verificar chamado que nao envia o codrda (em branco)

	if lPLSEXPC .and. ! empty(cCodRda)

		//Verifica se o evento e um pacote
		BLE->(dbSetOrder(1))//BLE_FILIAL+BLE_CODINT+BLE_CODPAD+BLE_CODPRO+BLE_TIPO+BLE_CPADOC+BLE_CODOPC
		if BLE->( msSeek( xFilial("BLE") + cCodInt + cCodPad + allTrim(cCodPro) + space( nTamCODPRO - len(allTrim(cCodPro) ) ) + "9" ) ) .and. BLE->BLE_VIGDE <= dDataBase .and. ( empty(BLE->BLE_VIGATE) .or. dDataBase <= BLE->BLE_VIGATE )

			BLZ->(dbSetOrder(1))//BLZ_FILIAL+BLZ_CODINT+BLZ_CODRDA+BLZ_CODPAD+BLZ_CODPRO

			if ! BLZ->( msSeek( xFilial("BLZ") + cCodInt + cCodRda + cCodPad + cCodPro ) )

				lRetorno  := '0'  //Indica que o pacote não pertence a RDA.

			else

				lRetorno  := '1'  //Indica que o código digitado é um pacote.

			endIf

		else

			//verifica se o codigo do evento esta em um pacote
			cSQL := " SELECT BLE_CPADOC, BLE_CODOPC, BLE_CODPRO, BLE_CODPAD "
			cSQL += "   FROM " + retSQLName("BLE")
			cSQL += "  WHERE BLE_FILIAL = '" + xFilial("BLE") + "' "
			cSQL += "    AND BLE_CODINT = '" + cCodInt + "' "
			cSQL += "    AND BLE_CPADOC = '" + cCodPad + "' "
			cSQL += "    AND BLE_CODOPC = '" + cCodPro + "' "
			cSQL += "    AND BLE_TIPO   = '9' "
			cSQL += "    AND ( BLE_VIGDE <= '" + dtos(dDataBase) + "' AND "
			cSQL += "        ( BLE_VIGATE = '' OR '" + dtos(dDataBase) + "' <= BLE_VIGATE ) ) "
			cSQL += "    AND D_E_L_E_T_ = '' "

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,changeQuery(cSQL)),"TRBBLE",.T.,.F.)

			if ! TRBBLE->(eof())

				BLD->(dbSetOrder(1))//BLD_FILIAL+BLD_CODINT+BLD_CODPAD+BLD_CODPRO
				BLZ->(dbSetOrder(1))//BLZ_FILIAL+BLZ_CODINT+BLZ_CODRDA+BLZ_CODPAD+BLZ_CODPRO

				while ! TRBBLE->(eof())

					if BLD->( msSeek( xFilial("BLD") + cCodInt + TRBBLE->(BLE_CODPAD + BLE_CODPRO) ) )

						//Verifica se na tabela de RDA x Pacote existe o procedimento dentro do pacote
						if BLZ->( msSeek( xFilial("BLZ") + BLD->BLD_CODINT + cCodRda + BLD->(BLD_CODPAD+BLD_CODPRO) ) )

							aadd(aDados, { BLD->BLD_CODPRO, BLD->BLD_DESPRO } )

						endIf

					endIf

					TRBBLE->(dbSkip())
				endDo

				if len(aDados) > 0
					lRetorno := '2' //Indica que o código digitado pertence a um serviço que esta relacionado a um pacote.
				else
					lRetorno := '3' //Indica que o código digitado pertence a um serviço que não esta relacionado a um pacote.
				endIf

			else
				lRetorno := '3' //Indica que o código digitado pertence a um serviço que não esta relacionado a um pacote.
			endIf

			TRBBLE->( dbCloseArea() )

		endIf

	endIf

	::WSNULL += lRetorno

return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ChkCodPro ³Autor  ³ Alexander	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o procedimento e valido						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ChkCodPro WSRECEIVE UserCode, ProDad, MatPre WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL lConsulta		:= .F.
	LOCAL aArea    		:= GetArea()
	LOCAL lForBloq      := .F.
	LOCAL lForLembr     := .F.
	LOCAL cLembrete		:= ""
	Local lBusDir		:= .F.
	LOCAL aDadUsr    	:= {}
	LOCAL aDadRDA    	:= {}
	LOCAL Ano			:= ""
	LOCAL Mes			:= ""
	LOCAL cTissVer 		:= ""
	LOCAL cCodPad  		:= ::ProDad:CodPad
	LOCAL cCodPro  		:= ::ProDad:CodPro
	PRIVATE aTabDup 	:= PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))
	PRIVATE aErrVarVin 	:= {.F., "", "", ""}


	DEFAULT ::WSNULL 	:= ""

	//Checa Usuário
	If PrtChkUser( ::UserCode, "PLSXFUN", "ChkCodPro" )

		//Verifica se o procedimento existe

		If aScan(  ClassDataArr(::ProDad)  ,{|x| AllTrim(x[1]) == "TISSVER"  }) > 0 .AND. ValType(::ProDad:TissVer) <> 'U'
			cTissVer := ::ProDad:TissVer
		EndIf

		//Faz os de-para das terminologias
		If cTissVer >= "3"

			cCodPad	:= AllTrim(PLSVARVINC('87','BR4',cCodPad))
			cCodPro	:= AllTrim(PLSVARVINC(::ProDad:CodPad,'BR8', ::ProDad:CodPro, cCodPad+::ProDad:CodPro,,aTabDup,@CCODPAD))

			If 	!PChkTabDup(@cCodPad,cCodPro,::ProDad:CodPad) .or. aErrVarVin[1] == .T.
				::WSNULL := "false|De/Para não realizado para -> ("+::ProDad:CodPad+")("+::ProDad:CodPro+"), certifique-se que o mesmo encontra-se na tabela de dominio TISS/ANS. Caso esteja, entre em contato com a sua operadora."
			EndIf

			BR8->(DbSetOrder(3))
			If !BR8->( MsSeek(xFilial("BR8")+AllTrim(cCodPro) + Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) )+cCodPad ))
				::WSNULL := "false|Procedimento não encontrado -> ("+cCodPad+")("+cCodPro+")"
			EndIf

		Else

			BR8->( DbSetOrder(3) )//BR8_FILIAL + BR8_CODPSA + BR8_CODPAD
			If !BR8->( MsSeek(xFilial("BR8")+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) )+cCodPad ))
				::WSNULL := "false|Procedimento não encontrado -> ("+cCodPad+")("+cCodPro+")"
			EndIf

		Endif

		//Verifica procedimento e tipo de guia
		lConsulta := PLSISCON( AllTrim(cCodPad),AllTrim(cCodPro) )

		If ::ProDad:TpServ == "1" .And. !lConsulta

			::WSNULL := "false|Não é um codigo de consulta ->( "+cCodPro+" )"

		ElseIf ::ProDad:TpServ == "1" .And. lConsulta .And. !(alltrim(cCodPro) $ Iif(!Empty(GetMv("MV_PTCELET")), GetMv("MV_PTCELET"), "10101012" ))

			::WSNULL := "false|Procedimento não condizente de uma consulta Eletiva, favor retificar"

		ElseIf At(BR8->BR8_TPPROC,::ProDad:TpProc) == 0 .And. !Empty(BR8->BR8_TPPROC)

			::WSNULL := "false|Procedimento não compatível como tipo de serviço"

		EndIf

		If BR8->(FieldPos("BR8_TIPRAX")) > 0 .and. !Empty(BR8->BR8_TIPRAX) .and. BR8->BR8_TIPRAX <> '0'
			lForBloq := .T.
		Endif

		If BR8->(FieldPos("BR8_LEMBRE")) > 0 .and. !Empty(BR8->BR8_LEMBRE)

			cLembrete := BR8->BR8_LEMBRE

			If ::ProDad:TpServ == "5"
				lForLembr := .F.
			Else
				lForLembr := PLSLEMBRE(Iif(ProDad:TpServ == '3',.T.,.F.),.T.,cCodPad,cCodPro)
			EndIf

		Endif

		//Verifica se o procedimento permite busca direta
		BTP->(dbSetOrder(1)) //BTP_FILIAL + BTP+_CODTAB
		lBusDir := BTP->(MsSeek(xFilial("BTP") + ProDad:CodPad)) .AND. BTP->BTP_BUSDIR = "1"

		//Retorna a descricao do procedimento
		If Empty(::WSNULL)

			::WSNULL := "true|"+Iif(cTissVer >="3" .AND. !lBusDir, PlDcCrcPrt( PLSGETVINC("BTQ_DESTER", 'BR8', .F., ::ProDad:CodPad, Alltrim(cCodPad+cCodPro)) ), PlDcCrcPrt( AllTrim(BR8->BR8_DESCRI) ))	+"|"+Iif( BR8->( FieldPos("BR8_TRAIND") )>0 , BR8->BR8_TRAIND,"0" )+"|"+BR8->BR8_TPPROC

			//³Retorna o valor do procedimento
			Ano := Alltrim(Str(Year(dDataBase)))
			Mes := Alltrim(Str(month(dDataBase)))

			BA1->(dbSetorder(02))
			If valtype(MatPre:Matric) <> 'U' .AND. BA1->( dbSeek(xFilial("BA1")+MatPre:Matric) )

				aDadUsr := PLSDADUSR(::MatPre:Matric,'1',.F.,dDatabase,Nil,Nil,Nil)
				aDadRda := PLSDADRDA(PlsIntPad(),::ProDad:CodRda,"1",dDataBase,"","")

				// Retorna Valor
				aValor := PLSCALCEVE(cCodPad,cCodPro,Mes,Ano,;
					PlsIntPad(),::ProDad:CodRda,aDadRDA[15],"",;
					aDadRDA[12],1,dDataBase,"1",/*cPadInt*/ "",/*::RegAte*/,0,aDadUsr,"",;
					{},nil,nil,nil,nil,"",{},nil,"",0,{},nil,dDataBase,"",{},"",.F.,0,{},nil,;
					.F.,100,"","",1,1,{},"","",,,/*::RegInt*/,"","")

				If ValType(aValor) == "A"

					If Len(aValor) >= 2
						::WSNULL += "|" + Alltrim(Str(aValor[2],13,2))
					Endif

				Else
					::WSNULL += "|0"
				Endif

			Else
				::WSNULL += "|0"
			Endif

			//Se for odonto
			If ::ProDad:TpServ == "4"

				If cTissVer >= "3"

					If BR8->(FieldPos("BR8_ODONTO")) > 0 .and. BR8->BR8_ODONTO <> "1"
						::WSNULL := "false|Tipo do procedimento não é odontológico! -> ("+cCodPad+")("+cCodPro+")"
					EndIf

					//³Retorna os dentes que estao amarados ao procedimento					   ³
					BYL->( DbSetOrder(1) )//BYL_FILIAL + BYL_CODPAD + BYL_CODPSA + BYL_CODIGO + BYL_TIPO + BYL_FACE
					B05->( DbSetOrder(1) )//B05_FILIAL + B05_CODPAD + B05_CODPSA + B05_CODIGO + B05_TIPO
					If B05->( MsSeek( xFilial("B05")+AllTrim(cCodPad)+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) ) ) )
						::WSNULL += '|1'
					Else
						::WSNULL += '|0'
					EndIf

				Else

					//³Retorna os dentes que estao amarados ao procedimento					   ³
					BYL->( DbSetOrder(1) )//BYL_FILIAL + BYL_CODPAD + BYL_CODPSA + BYL_CODIGO + BYL_TIPO + BYL_FACE
					B05->( DbSetOrder(1) )//B05_FILIAL + B05_CODPAD + B05_CODPSA + B05_CODIGO + B05_TIPO
					If B05->( MsSeek( xFilial("B05")+AllTrim(cCodPad)+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) ) ) )

						While !B05->( Eof() ) .And. xFilial("B05")+AllTrim(cCodPad+cCodPro) == B05->B05_FILIAL+AllTrim(B05->(B05_CODPAD+B05_CODPSA))

							::WSNULL += '~' + AllTrim(B05->B05_CODIGO) + '$' + AllTrim(B05->B05_CODIGO)+'-'+AllTrim(B05->B05_DESCRI)+'&%-- Face --'

							//³Retorna as faces do dente											   ³
							If BYL->( MsSeek( xFilial("BYL")+AllTrim(cCodPad)+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) )+B05->B05_CODIGO ) )

								While !BYL->( Eof() ) .And. xFilial("BYL")+cCodPad+AllTrim(cCodPro)+AllTrim(B05->B05_CODIGO) == BYL->BYL_FILIAL+BYL->(BYL_CODPAD+AllTrim(BYL_CODPSA)+AllTrim(BYL_CODIGO))
									::WSNULL += '*' + AllTrim(BYL->BYL_FACE) + '%' + AllTrim(BYL->BYL_FACE)+'-'+AllTrim(BYL->BYL_DESFAC)
									BYL->( DbSkip() )
								EndDo

							EndIf

							B05->( DbSkip() )
						EndDo
					EndIf

				EndIf

			Else
				// Apenas para igualar o tamanho do array quando nao for odontologico.
				::WSNULL += "| "
			EndIf

			// Mensagem de raio X
			If lForBloq
				::WSNULL += "|forblo"
			Else
				::WSNULL += "| "
			Endif

			// Lembretes
			If lForLembr
				::WSNULL += "|forbla"
				::WSNULL += "|"+cLembrete
			Else
				::WSNULL += "| "
				::WSNULL += "| "
			Endif

		EndIf

		If	ProDad:CodPro <> "" .And. cTissVer >= "3" .AND. !lBusDir

			cSql := " SELECT BTU_VLRSIS, BTU_VLRBUS FROM "+RetSqlName("BTU")
			cSql += "  WHERE BTU_FILIAL = '"+xFilial("BTU")+"' "
			cSql += "    AND BTU_CODTAB = '" + ProDad:CodPad  + "' "
			cSql += "    AND BTU_CDTERM = '" + ProDad:CodPro + "' "
			cSql += "    AND D_E_L_E_T_ <> '*' "

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,ChangeQuery(cSql)),"TRBBTU",.T.,.F.)

			if TRBBTU->(eof())
				SetSoapFault( "", "Procedimento não encontrado na Tab. da TISS->( "+::ProDad:CodPro+" )" )
				TRBBTU->(DbCloseArea())
				return(.F.)
			endIf

			cSql1 := "SELECT BR8_LEMBRE FROM "+RetSqlName("BR8")
			cSql1 += " WHERE BR8_FILIAL = '"+xFilial("BR8")+"' "
			cSql1 += "   AND BR8_CODPAD = '" + subStr(TRBBTU->BTU_VLRSIS,len(xFilial("BR8")) + 1 ,2) + "' "
			cSql1 += "   AND BR8_CODPSA = '" + TRBBTU->BTU_VLRBUS  + "' "
			cSql1 += "   AND D_E_L_E_T_ <> '*' "

			TRBBTU->(DbCloseArea())

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,ChangeQuery(cSql1)),"TRBBR8",.T.,.F.)

			if ! TRBBR8->(eof())
				cLembrete := allTrim(TRBBR8->BR8_LEMBRE)
			endIf

			if ! empty(cLembrete)
				::WSNULL += "true|forbla"
				::WSNULL += "|" + cLembrete
			endIf

			TRBBR8->(DbCloseArea())

		endIf

	Else
		lRetorno := .f.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ChkQtdPro ³Autor  ³ Totvs	            ³ Data ³21.10.2013 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³QtdPro																   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ChkQtdPro WSRECEIVE UserCode, ProDad WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea    		:= GetArea()
	LOCAL lForLembr     := .F.
	LOCAL cLembrete		:= ""
	DEFAULT ::WSNULL 	:= ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If PrtChkUser( ::UserCode, "PLSXFUN", "ChkQtdPro" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se o procedimento existe									   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BR8->( DbSetOrder(3) )//BR8_FILIAL + BR8_CODPSA + BR8_CODPAD
		If BR8->( MsSeek(xFilial("BR8")+AllTrim(ProDad:CodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(ProDad:CodPro) ) )+ProDad:CodPad ))

			If BR8->(FieldPos("BR8_LEMBRE")) > 0 .and. !Empty(BR8->BR8_LEMBRE)
				cLembrete := BR8->BR8_LEMBRE
				lForLembr := PLSLEMBRE(Iif(ProDad:TpServ == '3',.T.,.F.),.T.,ProDad:CodPad,ProDad:CodPro,ProDad:QtdPro)
			Endif

			// Lembretes
			If lForLembr
				::WSNULL += "true|forbla"
				::WSNULL += "|"+cLembrete
			Endif
		Endif
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf
	RestArea( aArea )

	If 	ProDad:CodPro <> ""
		cSql := "SELECT BTU_VLRSIS, BTU_VLRBUS FROM "+RetSqlName("BTU")
		cSql += " WHERE BTU_FILIAL = '"+xFilial("BTU")+"' "
		cSql += " AND BTU_CODTAB = '" + ProDad:CodPad  + "' "
		cSql += " AND BTU_CDTERM = '" + ProDad:CodPro + "' "
		cSql += " AND D_E_L_E_T_ <> '*' "
		cSql := ChangeQuery(cSql)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"ALIASBTU",.T.,.F.)

		cSql1 := "SELECT BR8_LEMBRE FROM "+RetSqlName("BR8")
		cSql1 += " WHERE BR8_FILIAL = '"+xFilial("BR8")+"' "
		cSql1 += " AND BR8_CODPAD = '" + SUBSTR(ALIASBTU->BTU_VLRSIS,Len(xFilial("BR8"))+1,2) + "' "
		cSql1 += " AND BR8_CODPSA = '" + ALIASBTU->BTU_VLRBUS  + "' "
		cSql1 += " AND D_E_L_E_T_ <> '*' "
		cSql1 := ChangeQuery(cSql1)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql1),"ALIASBR8",.T.,.F.)

		cLembrete := ALLTRIM(ALIASBR8->BR8_LEMBRE)
		If ! Empty(cLembrete)
			::WSNULL += "true|forbla"
			::WSNULL += "|"+cLembrete
		EndIf

		If Select("ALIASBTU") > 0
			DbSelectArea("ALIASBTU")
			ALIASBTU->(DbCloseArea())
		Endif

		If Select("ALIASBR8") > 0
			DbSelectArea("ALIASBR8")
			ALIASBR8->(DbCloseArea())
		Endif
	Endif

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetVlrPro ³Autor  ³ Alexander	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o procedimento e valido						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetVlrPro WSRECEIVE UserCode, cCodTb, cCodPro, cCodRDA, cCodLoc, cCodEsp, Matric, FlgVRDA WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 	:= .T.
	LOCAL aArea    	:= GetArea()
	Local nI		:= 0
	LOCAL aDadUsr   := {}
	LOCAL aDadRDA   := {}
	LOCAL Ano		:= ""
	LOCAL Mes		:= ""
	Local cColum	:= ""
	Local aRetDaD	:= {}
	Local aValor	:= {}
	Local cAno		:= alltrim(Str(Year(date())))
	Local cMes		:= alltrim(Str(month(date())))
	Local lFlgCt	:= iIf(FlgVRDA = "SIM", .T., .F.)
	Local cPadBkp	:= ""
	local cCodInt	:= PlsIntPad()
	PRIVATE aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))

	::WSNULL := ""

	//Checa Usuário
	If PrtChkUser( ::UserCode, "PLSXFUN", "GetVlrPro" )

		BR8->( dbSetOrder(1) )//BR8_FILIAL+BR8_CODPAD+BR8_CODPSA+BR8_ANASIN

		aDadRDA := PLSDADRDA(cCodInt,::cCodRDA,'1',date(), ::cCodLoc, ::cCodEsp,/*cCodTb*/,/*cCodPro*/,,,,,)

		if PLSDADUSR(::Matric,'1',.f.,dDatabase,,,"NAO_VALIDAR_CARTAO")[1]
			aDadUsr := PLSGETUSR()
		else
			lRetorno := .F.
			SetSoapFault( "","Verifique os parâmetros informados." )
		endIf

		if lRetorno

			//Se não for valorizar por RDA
			if !lFlgCt

				//Verifica se o procedimento existe
				BR8->( dbSetOrder(1) )//BR8_FILIAL+BR8_CODPAD+BR8_CODPSA+BR8_ANASIN
				if BR8->( MsSeek( xFilial("BR8") + ::cCodTb + allTrim(::cCodPro) + space( TamSX3("BR8_CODPSA")[1] - len( allTrim(::cCodPro) ) ) ))

					//³Retorna o valor do procedimento
					Ano := alltrim(str(year(dDataBase)))
					Mes := alltrim(str(month(dDataBase)))

					//Retorna Valor
					aValor := PLSCALCEVE(::cCodTb,::cCodPro,Mes,Ano,;
						cCodInt,::cCodRDA, aDadRDA[15],"",;
						aDadRDA[12],1,dDataBase,"1",/*cPadInt*/ "",/*::RegAte*/,0,aDadUsr,"",;
						{},nil,nil,nil,nil,"",{},nil,"",0,{},nil,dDataBase,"",{},"",.F.,0,{},nil,;
						.F.,100,"","",1,1,{},"","",,,/*::RegInt*/,"","")

					if ValType(aValor) == "A"

						If Len(aValor) >= 2
							::WSNULL :=  Alltrim(Str(aValor[2],13,2))
						Endif

					Else
						::WSNULL := "0"
					endIf

				else
					lRetorno := .F.
					SetSoapFault( "","Procedimento não encontrado->( "+::cCodPro+" )" )
				endIf

				//Se for valorizar por prestador
			else

				::cCodTb	:= allTrim( PLSGETVINC("BTU_CDTERM", "BR4", .F., "87", ::cCodTb,.T.) )
				::cCodPro 	:= alltrim( PLSGETVINC("BTU_CDTERM", "BR8", .F., alltrim(::cCodTb),  alltrim(::cCodPro), .T. ,aTabDup, @cPadBkp) )

				BR8->( MsSeek( xFilial("BR8") + ::cCodTb + allTrim(::cCodPro) + space( TamSX3("BR8_CODPSA")[1] - len( allTrim(::cCodPro) ) ) ))

				aRetDad := PLSAUTP(date(),,::cCodTb,::cCodPro,1,aDadUsr,,aDadRDA,,.T.,,.F.,,,,,,,,,,,,,,,,,,,,,,'2')

				//Monto array de cabeçalho para grid de composição
				cCabec := "[{name:'Unidade'},{name:'Descrição'},{name:'Referência'},{name:'Porte'}]"

				//Se aRetDad[1] = .T., então procedimento pode ser realizado e está liberado. Verificar valores
				If aRetDaD[1]

					aValor := PLSCALCEVE(::cCodTb, ::cCodPro, cMes, cAno, cCodInt, ::cCodRDA, ::cCodEsp,"", ::cCodLoc,1, date(),"1","",,,aDadUsr)

					If Len(aValor[1][1]) > 8

						if Len(aValor[1]) >= 1

							BD3->(DbSetOrder(1))
							for nI := 1 to Len(aValor[1])

								if BD3->(MsSeek((xFilial("BD3")) + aValor[1, nI, 1]))
									cColum += "{0:{field:'UNID', value:'" + aValor[1,nI,1] + "'} ,1:{field:'DESCRI', value:'" + BD3->BD3_DESCRI + "'},2:{field:'REFER', value:'" + STR(aValor[1,nI,9]) + "'},3:{field:'PORTE', value:'" + (aValor[1,nI,12]) + "'} },"
								endIf

							Next

						endIf

						//Monto o arrays de colunas
						cColum := "[" + subStr(cColum, 1, Len(cColum)-1) + "]"

						//Nome do procedimento + elegivel + valor + cabeçalho grid + colunas grid
						::WSNULL := aValor[1][1][8] + "|Sim|" + AllTrim(cValtochar(transform(aValor[2], "@E 999,999,999.99"))) + "|" + cCabec + "|" + cColum + "|" + AllTrim(BR8->BR8_DESCRI) + "|"

					else
						::WSNULL := aValor[1][1][8] + "|Não|" + AllTrim(STR(aValor[2])) + "|" + cCabec + "|" + cColum + "|" + BR8->BR8_DESCRI + "|"
					endIf

				else

					//Aqui, retorno a crítica caso o procedimento não tenha sido encontrado no PLSAUTP
					cCabec := "[{name:'Cód. Glosa'},{name:'Descrição'},{name:'Observação'}]"

					For nI := 1 To Len(aRetDad[2])
						cColum += "{0:{field:'COD', value:'" + aRetDad[2,nI,1] + "'} ,1:{field:'DESCRI', value:'" + aRetDad[2,nI,2] + "'},2:{field:'OBS', value:'" + aRetDad[2,nI,3] + "'} },"
					Next

					cColum 	 := "[" + subStr(cColum, 1, Len(cColum)-1) + "]"
					::WSNULL := aRetDad[2,1,7] + "|Não|" + AllTrim("0.00") + "|" + cCabec + "|" + cColum + "|" + BR8->BR8_DESCRI + "|"

				endIf

			endIf

		endIf

	else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AutProc   ³Autor  ³ Alexander	            ³ Data ³06.04.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Checa regra de um procedimento para um atendimento		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD AutProc WSRECEIVE UserCode, SAutProc, cRecno, DigiGui WSSEND RetAutProc WSSERVICE PLSXFUN
	LOCAL nI		 := 0
	LOCAL nCont		 := 0
	LOCAL nRecBD6    := 0
	LOCAL cTipo		 := "1"
	LOCAL cOpeSol	 := ""
	LOCAL cOpeExe	 := ""
	LOCAL cMsg		 := ""
	LOCAL cEspSol 	 := ""
	LOCAL cEspExe 	 := ""
	LOCAL cAliasCab  := ""

	LOCAL lRetorno 	 := .T.
	LOCAL lTrtExe    := .F.
	LOCAL lRdaProf	 := .F.
	LOCAL lAto		 := .F.
	LOCAL lSolict	 := (::SAutProc:TipoProc == 'S')
	LOCAL cRdaProf	 := ""
	LOCAL cCodRda  	 := ::SAutProc:Rda
	LOCAL cOpeMov	 := ::SAutProc:OpeRDA
	LOCAL cCodEsp    := ::SAutProc:Cbos
	LOCAL cCodLoc	 := ::SAutProc:CodLoc
	LOCAL cCodProf   := Iif(lSolict,::SAutProc:CdpfSo,::SAutProc:CodExe)
	LOCAL cAno		 := ""
	LOCAL cMes       := ""
	LOCAL cString	 := ""
	LOCAL cMatRetRes := "" //Resultado da solicitacao da matriz de retorno separados por ";" para campo e valor e por "#" para outro campo.
	LOCAL nQtdUs	 := 0
	LOCAL nVlrCon	 := 0
	LOCAL nVlrTPF	 := 0
	LOCAL aMatRet    := {} //Matriz de retorno faz tratamento para ate 10 retornos diferentes
	LOCAL aRetCri	 := {}
	LOCAL aVldGen	 := nil
	LOCAL aCritica	 := {{}}
	LOCAL aCliente	 := {}
	LOCAL aRet		 := {}
	LOCAL aRetUs	 := {}
	LOCAL aDadUsr    := {}
	LOCAL aDadRda    := {}
	LOCAL aValor	 := {}
	LOCAL aQtdBrw	 := {}
	LOCAL aArea    	 := GetArea()
	LOCAL lFiltPRF   := GetNewPar("MV_PLSPRFS",.t.)
	LOCAL nLimitePTU := GetNewPar("MV_PLLIPTU",50)
	LOCAL cCodNeg 	 := ""
	LOCAL aAlerta    := {}
	LOCAL aRetAlert  := {}
	Local nRecno	 := iIf( ValType(::cRecno) == "U", 0, Val(::cRecno))
	Local lDiggui	 := ValType(::DigiGui) == "C" .and. lower(::DigiGui) == "digitacao"
	Local aProcAuto	 := {}
	Local lMv_Platurg := GetNewPar("MV_PLATURG",.F.)
	local cNumLibe2	:= ""

	//Variáveis de pacotes
	Local nj := 0
	Local lFoundItem := .F.
	Local lNegProPac := .F.
	Local aItensPac := {}
	Local aListPac := {}

	Local aDados 	 := {}
	Local aItens 	 := {}
	Local objCtrlGuia:= nil

	Local aObjProcedimentos := {}
	Local oObjVOGuia
	Local aRetGui
	Local lVerAud := .T.
	Local lCkLib  := GetNewPar("MV_PLSCKLB",.T.)

	Local aProrInt 	:= {}
	Local lProrInt	:= .F.

	PRIVATE aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))
	PRIVATE aErrVarVin := {.F., "", "", ""}

	//Checa Usuário
	If PrtChkUser( ::UserCode, "PLSXFUN", "AutProc" )

		//Ponto de entrada para troca de dados na aut do portal
		If ExistBlock("PLCHEDAD")
			aRetPtoEnt := ExecBlock("PLCHEDAD",.F.,.F.,{::SAutProc:CodPad,	::SAutProc:CodPro,::SAutProc:TipoProc })
			::SAutProc:CodPad 	:= aRetPtoEnt[1]
			::SAutProc:CodPro	:= aRetPtoEnt[2]
			::SAutProc:TipoProc	:= aRetPtoEnt[3]
		EndIf

		//Monta a matriz de retorno
		cString := ::SAutProc:MatRet
		While ( nPos := At( "~", cString ) ) > 0
			AaDd( aMatRet,SubStr( cString, 1, nPos-1 ) )
			cString := SubStr( cString, nPos+1, Len(cString) )
		EndDo

		//Monta matriz com procedimentos ja executados
		For nI := 1 To Len( ::SAutProc:AutItem )

			AaDd( aQtdBrw, { 	PADR(::SAutProc:AutItem[nI]:CodPad,Len(BR8->BR8_CODPAD)),;
				PADR(::SAutProc:AutItem[nI]:ProcedureCode,Len(BR8->BR8_CODPSA)),;
				::SAutProc:AutItem[nI]:ProcedureQuantity,;
				::SAutProc:DATPRO,;
				::SAutProc:AutItem[nI]:HORINI,;
				PADR(::SAutProc:AutItem[nI]:DENTE,Len(B04->B04_CODIGO)),;
				PADR(::SAutProc:AutItem[nI]:FACE,Len(B09->B09_FADENT)),;
				StrZero(Val(::SAutProc:AutItem[nI]:SEQUENCE), TamSx3("BD6_SEQUEN")[1])} )
		Next

		//Pega o ano e o mes de pagamento
		aRet := PLSXVLDCAL(::SAutProc:DatPro,PLSINTPAD(),.F.,"","")

		If aRet[1]
			cMes := aRet[5]
			cAno := aRet[4]
		ElseIf Len(aRet[2]) > 0
			lRetorno := .F.
			SetSoapFault( "", aRet[2,1,1]+" - "+aRet[2,1,2])
		EndIf

		BAU->(DbSelectArea("BAU"))
		BAU->(DbSetOrder(1))
		If (BAU->(MsSeek(xFilial("BAU")+cCodRda)))
			cTissVer := BAU->BAU_TISVER
		EndIf

		If cTissVer >= "3"

			cCodPad := AllTrim(PLSVARVINC('87','BR4', Alltrim(::SAutProc:CodPad)))
			cCodPro := AllTrim(PLSVARVINC(::SAutProc:CodPad,'BR8',::SAutProc:CodPro ,cCodPad+::SAutProc:CodPro,,aTabDup,@CCODPAD))

			If 	!PChkTabDup(@cCodPad,cCodPro,::SAutProc:CodPad) .or. aErrVarVin[1] == .T.
				SetSoapFault( "", "De/Para não realizado para -> ("+::SAutProc:CodPad+") "+::SAutProc:CodPro )
				Return .F.
			EndIf

			BR8->(DbSetOrder(3))
			If !BR8->( MsSeek(xFilial("BR8")+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) )+cCodPad ))
				SetSoapFault( "", "Procedimento não encontrado na tabela padrao -> ("+cCodPad+") "+cCodPro )
				Return .F.
			else 
				if !BR8->BR8_TIPEVE $ "2,3" 
					if !empty(::SAutProc:VIAAC) 
						SetSoapFault( "", "Apenas é possível informar via de acesso para procedimentos cirurgicos.")
						return .f.
					endif
				endif
			EndIf

			::SAutProc:CodPad := cCodPad
			::SAutProc:CodPro := cCodPro

		Endif

		//Verifica RDA
		If lRetorno

			//Operadora do profissional
			BB0->( DbSetOrder(1) ) //BB0_FILIAL + BB0_CODIGO
			If BB0->( MsSeek( xFilial( "BB0" ) + cCodProf) )

				If lSolict
					cOpeSol := BB0->BB0_CODOPE
				Else
					cOpeExe := BB0->BB0_CODOPE
				EndIf

			EndIf

			//Posiciona no local e verifica se e para tratar o executante
			BB8->( MsSeek(xFilial("BB8")+cCodRda+cOpeMov+cCodLoc) )

			lTrtExe := Iif(BB8->BB8_TRTEXE == '1',.t.,.f.)

			//Pega a Rda do Profissional
			BAU->( DbSetOrder(5) ) //BAU_FILIAL + BAU_CODBB0
			If BAU->( MsSeek( xFilial("BAU") + cCodProf ) )
				cRdaProf := BAU->BAU_CODIGO
			EndIf

			//Rda contratada diference da rda do profissional
			lRdaProf := ( cCodRda <> cRdaProf .and. ! Empty(cRdaProf) )

			//Procura o Local	no profissional
			lEntrou := .F.

			If ! empty(cRdaProf) .and. ! empty(::SAutProc:EndCon) .and. lRdaProf .and. lTrtExe

				BB8->( DbSetOrder(5) )//BB8_FILIAL + BB8_TIPLOG + BB8_CEP + BB8_NR_END + BB8_EST + BB8_CODIGO + BB8_CODINT                                          //sempre procuro um local na rda que eu vou gerar a guia
				If BB8->( MsSeek( xFilial("BB8") + ::SAutProc:EndCon + cRdaProf + cOpeMov ) )

					while  !BB8->(Eof()) .and. BB8->(BB8_FILIAL+BB8_TIPLOG+BB8_CEP+BB8_NR_END+BB8_EST+BB8_CODIGO+BB8_CODINT) == ;
							xFilial("BB8")+::SAutProc:EndCon + cRdaProf + cOpeMov

						if empty(BB8->BB8_DATBLO)
							lEntrou := .t.
							cCodLoc := BB8->BB8_CODLOC
							exit
						endIf

						BB8->(dbSkip())
					enddo

					If ! lEntrou

						cCodLoc := ""

						FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01',"RDA Prof. " + cRdaProf + " - Local de Atendimento não encontrado com base no Endereço -> ( " + ::SAutProc:EndCon + "-" + cRdaProf + "-" + cOpeMov + " )" , 0, 0, {})

					endIf

				else

					cCodLoc := ""
					FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01',"RDA Prof. " + cRdaProf + " - Local de Atendimento não encontrado com base no Endereço -> ( " + ::SAutProc:EndCon + "-" + cRdaProf + "-" + cOpeMov + " )" , 0, 0, {})

				endIf

			endIf

			//Verifica se vai checar a rda contratada ou a do profissional
			If lRdaProf .and. ( lTrtExe .and. lSolict ) .and. lFiltPRF
				cCodRda := cRdaProf
			endIf

			if lSolict
				cEspSol := cCodEsp
			else
				cEspExe := cCodEsp
			endIf

			// Tratamento para quando a RDA estiver bloqueado mas o beneficiario foi internado
			// Antes do bloqueio, nesse tipo de situação é permitido realizar a prorrogação.

			If ::SAutProc:TipGui == "11" // Prorrogação de Internação
				BE4->(DbSetORder(2))//BE4_FILIAL+BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT
				If BE4->(msSeek(xFilial("BE4")+::SAutProc:NumSol))
					aProrInt 	:= {BE4->BE4_DATPRO, Substr(BE4->BE4_HORPRO,1,4)}
					lProrInt 	:= .T.
				EndIF
			EndIf

			//Tratamento para Rda
			aRet := PLSDADRDA(cOpeMov,cCodRda,"1",IIF(lProrInt,aProrInt[1],::SAutProc:DatPro),cCodLoc,cCodEsp,::SAutProc:CodPad,::SAutProc:CodPro,nil,nil,cEspSol,cEspExe,,lProrInt)

			if aRet[1]
				aDadRda := PLSGETRDA()
			else

				lRetorno := .F.

				for nI := 1 to len(aRet[2])
					cMsg += aRet[2,nI,1] + " - " + allTrim(aRet[2,nI,2]) + Iif( nI != 1, " - " + allTrim(aRet[2,nI,3]),"") + chr(13) + chr(10)
				next

				setSoapFault( "", cMsg )

			endIf

		endIf

		//Verifica Usr
		if lRetorno

			::SAutProc:Matric:= PPLTROMAT(::SAutProc:Matric)
			//Dados do usuario
			aRet := PLSDADUSR(::SAutProc:Matric,cTipo,.F.,::SAutProc:DatPro,nil,nil,nil)

			if aRet[1]
				aDadUsr := PLSGETUSR()
			else

				lRetorno := .F.
				for nI := 1 to len(aRet[2])
					cMsg += aRet[2,nI,1] + " - " + allTrim(aRet[2,nI,2]) + Iif( nI != 1," - " + allTrim(aRet[2,nI,3]),"") + chr(13) + chr(10)
				next

				SetSoapFault( "", cMsg)
			endIf

		endIf

		//Verifica se alcancou o limite de itens PTU Online
		If lRetorno .and. aDadUsr[45] <> PlsIntPad() .and. allTrim(GetNewPar("MV_PLSUNI","1")) == "1" .and. len(aQtdBrw) >= nLimitePTU

			if aScan(aQtdBrw,{|x| alltrim(x[1]) == alltrim(::SAutProc:CodPad) .and. alltrim(x[2]) == alltrim(::SAutProc:CodPro) }) == 0
				lRetorno := .F.
				cMsg += "O limite para solicitações PTU Online é de "+Alltrim(Str(nLimitePTU))+" itens. "+Chr(13)+Chr(10)
				SetSoapFault( "", cMsg)
			EndIf

		EndIf

		//Se Execucao Odonto ou Sadt, verifica se a quantidade informada e superior ao saldo
		If (::SAutProc:TipGui == "4" .Or. ::SAutProc:TipGui == "2") .And. !Empty(::SAutProc:ChavLib)
			BE2->(DbSetOrder(6)) //BE2_FILIAL+BE2_OPEMOV+BE2_ANOAUT+BE2_MESAUT+BE2_NUMAUT+BE2_CODPAD+BE2_CODPRO+BE2_DENREG+BE2_FADENT
			If BE2->(MsSeek(xFilial("BE2")+::SAutProc:ChavLib + ::SAutProc:CodPad + ::SAutProc:CodPro)) .And. ::SAutProc:QtdPro > BE2->BE2_SALDO .And. BE2->BE2_LIBERA == '1' //retirado ::SAutProc:dente + ::SAutProc:face porque não estava trazendo a resposta fazendo com que não apareça a crítica de quantidade informada.
				lRetorno := .F.
				cMsg += "A quantidade informada é maior que o saldo disponível na Liberação para este evento ("+cValtoChar(BE2->BE2_SALDO)+")."+Chr(13)+Chr(10)
				SetSoapFault( "", cMsg)
			EndIf
		EndIf

		//Verifica se pode fazer a autorizacao
		If lRetorno

			//Recno do BD6
			If ! lSolict .AND. ! lDigGui

				If nRecno == 0 .And. Empty(SubStr(::SAutProc:ChvBD6,5,4)) .And. !Empty(SubStr(BEA->(BEA_OPEMOV+BEA_CODLDP+BEA_CODPEG+BEA_NUMGUI+BEA_ORIMOV),5,4))
					::SAutProc:ChvBD6:=	BEA->(BEA_OPEMOV+BEA_CODLDP+BEA_CODPEG+BEA_NUMGUI+BEA_ORIMOV)
				EndIf

				BD6->( DbSetOrder(6) ) //BD6_FILIAL + BD6_CODOPE + BD6_CODLDP + BD6_CODPEG + BD6_NUMERO + BD6_ORIMOV + BD6_CODPAD + BD6_CODPRO
				If BD6->( MsSeek( xFilial("BD6")+::SAutProc:ChvBD6+::SAutProc:CodPad+::SAutProc:CodPro) )
					nRecBD6 := BD6->( Recno() )
				EndIf

			Elseif ! lSolict .and. lDigGui .and. nRecno > 0

				BD5->(DbGoTo(nRecno))
				BD6->(DbsetOrder(6))
				If BD6->(MsSeek(xfilial("BD6") + BD5->(BD5_CODOPE + BD5_CODLDP + BD5_CODPEG + BD5_NUMERO + BD5_ORIMOV) + ::SAutProc:CodPad + ::SAutProc:CodPro))
					nRecBD6 := BD6->( Recno() )
				EndIf

			EndIf

			//TODO - 01/05/2017 - rever o conceito solicita executa deve ser feito deintro da PLSAUTP e nao aqui.
			//se teve liberacao nao preciso mais checar as regras idade, sexo, etc etc
			If ! Empty(::SAutProc:ChavLib)

				BE2->(dbSetOrder(6))
				If BE2->(MsSeek(xFilial("BE2") + ::SAutProc:ChavLib + ::SAutProc:CodPad + ::SAutProc:CodPro))

					::SAutProc:Cid := BE2->BE2_CID  //carrego o CID da guia que foi liberada
					If BE2->BE2_STATUS == "1"

						If !lDiggui .and. ::SAutProc:DatPro < BE2->BE2_DATPRO

							SetSoapFault( "","A data de atendimento é anterior à data da solicitação" )
							return .F.
						EndIf

					EndIf

					If BE2->BE2_AUDITO == "0"
						lVerAud := .F.
					EndIf

					//TODO - 11/04/2018 - OSCAR ficou de rever este ponto.
				elseIf BE2->(MsSeek(xFilial("BE2") + ::SAutProc:ChavLib))

					If !(empTy(BE2->BE2_NRLBOR))
						cNumLibe2 := BE2->BE2_NRLBOR
						lVerAud := !(PLBYEPU(PADL(::SAutProc:TipGui,2,"0"), BE2->BE2_NRLBOR, aProcAuto, ::SAutProc:CodPad, ::SAutProc:CodPro,,,,::SAutProc:ChavLib)[1])
					EndIf

				EndIf

				aVldGen := {.T.,.T.,.F.,.F., iif(!lVerAud,.t.,.F.),.F.,.F.,.F.,.F.,lVerAud,.F.}

			Else
				If !lCkLib
					aVldGen := {.F.,.F.,nil,nil,nil,nil,nil,nil,nil,nil,nil}
				EndIf
			EndIf

			If ::SAutProc:TipGui $ "2"
				cAliasCab := "BE1"
			elseIf ::SAutProc:TipGui $ "3"
				cAliasCab := "BE4"
			endIf

			If !Empty(SAutProc:ListProc)
				aListPac := strtokarr(SAutProc:ListProc, "|")
			
				For nj := 1 to Len(aListPac)

					cCodPadPac := AllTrim(PLSVARVINC('87','BR4', Alltrim(SUBSTR(aListPac[nj], 1 , 2))))
					cCodProPac := AllTrim(PLSVARVINC(Alltrim(SUBSTR(aListPac[nj], 1 , 2)),'BR8', Alltrim(SUBSTR(aListPac[nj], 3 )),cCodPadPac+Alltrim(SUBSTR(aListPac[nj], 3 )),,aTabDup,@CCODPAD))

					aListPac[nj] := cCodPadPac + cCodProPac 
					
					BR8->(DbSetorder(1))
					if BR8->(MsSeek(xFilial("BR8") + cCodPadPac+ cCodProPac))
						
						if BR8->BR8_TPPROC == "6"
							//Checa se o procedimento encontrado e um pacote
							aItensPac := PlRetPac(PLSINTPAD(),::SAutProc:Rda, cCodPadPac, cCodProPac ,nil,::SAutProc:DatPro)
						EndIf
					Endif

					If Len(aItensPac) > 0

						nPosProc := aScan(aItensPac, {|x| alltrim(x[2]) == AllTrim(::SAutProc:CodPro)})
						
						If nPosProc > 0
							lNegProPac := .T.
							lFoundItem := .T.
						Endif
					Endif

				Next nj

			EndIf

			//Checa a regra para um determinado procedimento
			if !(lMv_Platurg == .T. .AND. ::SAutProc:CarSol == '2')
				if ::SAutProc:TipGui <> '5'

					aRet := PLSAUTP(::SAutProc:DatPro,;
						::SAutProc:HorPro,;
						PADR(::SAutProc:CodPad,Len(BR8->BR8_CODPAD)),;
						PADR(::SAutProc:CodPro,Len(BR8->BR8_CODPSA)),;
						::SAutProc:QtdPro - IIF(nRecBD6 > 0 .and. lDigGui .and. nRecno > 0, BD6->BD6_QTDPRO, 0),;
						aDadUsr,;
						nRecBD6,;
						aDadRDA,;
						"1",;
						Iif(GetNewPar("MV_PLSMODA","1")=="0",.F.,.T.),;
						::SAutProc:Cid,;
						.t.,;
						"1",;
						lSolict,;
						cOpeSol,;
						::SAutProc:CdpfSo,;
						cAno,;
						cMes,;
						::SAutProc:PadInt,;
						::SAutProc:PadCon,;
						::SAutProc:RegAte,;
						.f.,;
						::SAutProc:CodExe,;
						NIL,;
						0,;
						cOpeExe,;
						NIL,;
						::SAutProc:AteRN,;
						NIL,NIL,;
						::SAutProc:Sequen,;
						::SAutProc:ChavLib,;
						.f.,;
						"2",;
						::SAutProc:Face,;
						NIL,NIL,;
						::SAutProc:TipPre,;
						::SAutProc:GrpInt,;
						NIL,NIL,;
						SAutProc:ChavLib,;
						::SAutProc:AreaAbr,;
						NIL,NIL,;
						::SAutProc:Dente,;
						NIL,NIL,;
						IiF( lSolict,.F.,lTrtExe),;
						.F.,;
						::SAutProc:TipoProc,;
						cCodEsp,;
						aQtdBrw,;
						aVldGen,;
						cCodLoc,;
						nil,;
						nil,;
						nil,;
						.T.,;
						cAliasCab,;
						::SAutProc:RegInter,;
						nil,;
						lNegProPac,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						cEspSol,;
						cEspExe,;
						nil,;
						nil,;
						iIf(!Empty(::SAutProc:TipGui),PADL(::SAutProc:TipGui,2,"0"),""),;
						::SAutProc:StProc,;
						nil,;
						.t.,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						::SAutProc:ValorApr,;
						nil,;
						nil,;
						iIf(nRecBD6 > 0 .and. lDigGui .and. nRecno > 0, BD6->BD6_QTDPRO, 0),;
						nil,;
						iif(::SAutProc:OutDesp == "1", .t., .f.),;
						cNumLibe2,;
						::SAutProc:CarSol,,,aProrInt,IIF(::SAutProc:TipGui == "3",.T.,.F.),;//94
						nil, nil,nil,::SAutProc:CobertEsp, ::SAutProc:RegAtendim, ::SAutProc:SaudeOcupac )	//100

				else
					aRet := {}
					aadd(aRet, .t.)
					lAto := .f.
				endif
			else
				aRet := {}
				aadd(aRet, .t.)
				lAto := .f.
			endif

			//Retorno
			If Len(aRet) > 0

				If  Len(aRet) >= 2 .AND. valtype(aRet[2]) == "A"
					lAuditoria := aScan( aRet[2],{|x| x[1] == "025" } ) > 0
				Else
					lAuditoria := .f.
				EndIf

				//Verifica se procedimento em auditoria se enquandra na exceção cadastrada
				//Caso esteja na exceção retira o procedimento da auditoria.
				if ! empty(lAuditoria) .and. lAuditoria

					//Internação ou Resumo de Internação
					if ::SAutProc:TipGui $ "3,5"

						cTpaten := PLSRetAut("3")[1]

						//Anexos
					elseif ::SAutProc:TipGui $ "7,8,9"

						cTpaten := PLSRetAut("7")[1]

					else
						cTpaten := PLSRetAut()[1]
					endif

					//³B1O_CODPRO+B1O_TPGUIA+B1O_IDADE+B1O_QTDPRO
					if PLSVLDEX(Left( cCodPro + Space( TamSX3("B1O_CODPRO")[1] ), TamSX3("B1O_CODPRO")[1] )+cTpaten,aDadUsr[26],::SAutProc:QtdPro)

						If LEN(aRet[2]) == 2
							aRet[1] := .T.
							aRet[2] := {}
							aRet[3] := "B1O"
						Else
							aRet[2][Ascan( aRet[2],{|x| x[1] == "025" } )][2] := ""
							aRet[2][Ascan( aRet[2],{|x| x[1] == "025" } )][1] := ""
						EndIf

					endif

				endif

				aCritica := IIF(Len(aRet) >= 2, aRet[2], {})

				//Separa o que é critica negativa do que é alerta
				PLSALERTA(@aCritica,@aRet,@aAlerta)

				::RetAutProc			:= WsClassNew( "SMatRetAutProc" )
				::RetAutProc:ProAut	:= aRet[1]
				::RetAutProc:Nivel	:= iIf( Len(aRet) >= 3, aRet[3], "")
				::RetAutProc:TpProc	:= BR8->BR8_TPPROC
				::RetAutProc:Chave	:= iIf( Len(aRet) >= 4, aRet[4], "")
				lAto					:= iIf( len(aRet) >= 5, aRet[5], .f. )
				aValor 				:= iIf( len(aRet) >= 6 .and. lAto , aRet[6], {} )
				::RetAutProc:Autori	:= ""
				::RetAutProc:MatCri	:= {}

				//Se foi autorizado
				If aRet[1]

					::RetAutProc:Autori := IIF( Len(aRet) >= 2, iif(valType(aRet[2])=='C',aRet[2],''), "") //BR8_AUTORI (0=Dispensa Autorizacao;1=Automatica;2=Guia Operadora;3=Auditoria;4=Guia Empresa;5=Guia Empresa/Operadora;6=Avalicao Contratual)

					//Somente guia Odontologica
					If ::SAutProc:TipGui == '4' .And. Len(aValor) == 0

						//Valor da Co-Participacao
						aValor := PLSCALCCOP(	::SAutProc:CodPad,;
							::SAutProc:CodPro,;
							cMes,;
							cAno,;
							aDadRda[02],;
							cCodEsp,;
							"",;
							cCodLoc,;
							::SAutProc:QtdPro,;
							::SAutProc:DatPro,;
							.F.,;
							"2",;
							'0',;
							::SAutProc:GrpInt,;
							aDadUsr,;
							nil,;
							nil,;
							{},;
							::SAutProc:RegAte,;
							0,;
							.T.,;
							.F.,;
							::SAutProc:HorPro,;
							NIL,;
							aDadRda[14],;
							::SAutProc:TipPre,;
							NIL,;
							NIL,;
							{},;
							::RetAutProc:Nivel,;
							::RetAutProc:Chave,;
							nil,;
							nil,;
							::SAutProc:Cid,;
							nil,;
							IIF(!Empty(::SAutProc:TipGui),PADL(::SAutProc:TipGui,2,"0"),""),; //36
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							::SAutProc:Dente,;
							::SAutProc:Face)
					EndIf

					//Verifica pagamento no ato
					If lAto

						If aValor[1] .And. aValor[16] == "1" .And. If( Len(aValor)>=27, !aValor[27], .T. )

							If BA3->BA3_TIPOUS == "1"
								aCliente := PlBuscaClien("1","1",aDadUsr)
							Else
								aCliente := PlBuscaClien("2","1",aDadUsr)
							EndIf

							lAto := ( aCliente[1] .Or. ( aValor[12] > 0 .And. BR8->BR8_PODDIG == "1" ) )

						Else
							lAto := .F.
						EndIf

					EndIf

					//Alertas do procedimento
					If len(aAlerta) > 0

						::RetAutProc:Alerta := {}

						nCont := 0

						For nI := 1 To Len(aAlerta)

							//Retira a informacao de nivel das criticas
							If At('nível',Lower(aAlerta[nI,2])) > 0
								Loop
							EndIf

							If ! Empty(aAlerta[nI,1])
								aRetAlert := PLSRETCRI( AllTrim( aAlerta[nI,1] ),cTissVer )
							Else
								aRetAlert := {}
								AaDd(aRetAlert,{"",aAlerta[nI,2]} )
							EndIf

							nCont++
							AaDd( ::RetAutProc:Alerta, WsClassNew( "GenericStruct" ) )
							::RetAutProc:Alerta[nCont]:Code			:= Iif( Empty(aRetAlert[1,1]),"&nbsp;&nbsp;&nbsp;&nbsp;",aRetAlert[1,1] )
							::RetAutProc:Alerta[nCont]:Description	:= PadR( AllTrim(aRetAlert[1,2]),60 ) + Iif( !Empty( aAlerta[nI,3] ) ," ( " + AllTrim( aAlerta[nI,3] ) + " )" ,"" ) + "<br>"

						Next

					EndIf

				Else

					//Criticas
					For nI := 1 To Len(aCritica)

						//Retira a informacao de nivel das criticas
						If At('nível',Lower(aCritica[nI,2])) > 0
							Loop
						EndIf

						If !Empty(aCritica[nI,1])
							aRetCri := PLSRETCRI( AllTrim( aCritica[nI,1] ),cTissVer )

							If EMPTY(aRetCri[1][2])
								aRetCri[1][1] := aCritica[nI][2]
								aRetCri[1][2] := aCritica[nI][3]
							EndIf

							If aCritica[nI,1] $ "518,026" // Critica sistemica referente ao código da tabela Invalido
								::RetAutProc:Impede := .T.
							Endif	

							cCodNeg := aRetCri[1,1]
						Else
							aRetCri := {}
							AaDd(aRetCri,{"",aCritica[nI,2]} )
						EndIf

						nCont++
						AaDd( ::RetAutProc:MatCri, WsClassNew( "GenericStruct" ) )
						::RetAutProc:MatCri[nCont]:Code			:= Iif( Empty(aRetCri[1,1]),"&nbsp;&nbsp;&nbsp;&nbsp;",aRetCri[1,1] )
						::RetAutProc:MatCri[nCont]:Description	:= PadR( AllTrim(aRetCri[1,2]),100 ) + Iif( !Empty( aCritica[nI,3] ) ," ( " + AllTrim( aCritica[nI,3] ) + " )" ,"" ) + "<br>"

					Next

					//Alertas do procedimento
					If len(aAlerta) > 0

						::RetAutProc:Alerta := {}

						nCont := 1

						AaDd( ::RetAutProc:Alerta, WsClassNew( "GenericStruct" ) )

						::RetAutProc:Alerta[nCont]:Code	:= "<hr size='40' width='99%' align='center' noshade><br>" +;
							"<b>Alertas do Procedimento</b> <br>"
						::RetAutProc:Alerta[nCont]:Description	:= "<br>"

						For nI := 1 To Len(aAlerta)

							//Retira a informacao de nivel das criticas
							If At('nível',Lower(aAlerta[nI,2])) > 0
								Loop
							EndIf

							If ! Empty(aAlerta[nI,1])
								aRetAlert := PLSRETCRI( AllTrim( aAlerta[nI,1] ),cTissVer )
							Else
								aRetAlert := {}
								AaDd(aRetAlert,{"",aAlerta[nI,2]} )
							EndIf

							nCont++
							AaDd( ::RetAutProc:Alerta, WsClassNew( "GenericStruct" ) )
							::RetAutProc:Alerta[nCont]:Code		:= Iif( Empty(aRetAlert[1,1]),"&nbsp;&nbsp;&nbsp;&nbsp;",aRetAlert[1,1] )
							::RetAutProc:Alerta[nCont]:Description	:= PadR( AllTrim(aRetAlert[1,2]),60 ) + Iif( !Empty( aAlerta[nI,3] ) ," ( " + AllTrim( aAlerta[nI,3] ) + " )" ,"" ) + "<br>"

						Next

					EndIf

				EndIf

				//Vou incluir a Primeira BE4 ou BD6 que está sendo autorizada
				if ::SAutProc:TipGui == '5' .and. ::SAutProc:Operacao == 'I'


					aDados := MntResDad(::SAutProc:CarSol, ::SAutProc:Rda, ::SAutProc:Cnes, ::SAutProc:CodLoc, ::SAutProc:Matric, ::SAutProc:Cbos,;
						::SAutProc:Cid, ::SAutProc:Cid2, ::SAutProc:Cid3, ::SAutProc:Cid4, ::SAutProc:Cid5, ::SAutProc:TipSai,;
						::SAutProc:TipFat, ::SAutProc:IndAci, ::SAutProc:TipInt, ::SAutProc:RegAte, ::SAutProc:NumSol, ::SAutProc:AteRN,;
						::SAutProc:DtIniF, ::SAutProc:HrIniF, ::SAutProc:DtFimF, ::SAutProc:HrFimF, ::SAutProc:NumGuiTrc, ::SAutProc:Observ,;
						::SAutProc:PadCon, ::SAutProc:PadInt, ::SAutProc:DatPro )


					aItens := MntResIte(::SAutProc:SeqMov , ::SAutProc:CodPro, ::SAutProc:CodPad,  ::SAutProc:QtdPro ,;
						iif(aRet[1] .OR. (!aRet[1] .AND. aRet[2][1][1]) == "564", ::SAutProc:QtdPro, 0) ,;
						::SAutProc:ValorApr,::SAutProc:HorIni, ::SAutProc:HorFim, ::SAutProc:ViaAc, ::SAutProc:TecUt,;
						::SAutProc:RedAcre, iif(aRet[1], "1", "0"), ::SAutProc:DatPro)


					objCtrlGuia := CO_ResumoInter():New()

					if alltrim(::SAutProc:Numero) = ""

						oObjGui 			:= objCtrlGuia:addGuia(aDados,aItens)
						::RetAutProc:NumGui := oObjGui:getCodOpe() + ";" + oObjGui:getCodLdp()  + ";" + oObjGui:getCodPeg()  + ";" + oObjGui:getNumero()

					else

						if alltrim(::SAutProc:CodOpe) <> alltrim(BE4->BE4_CODOPE) .or. ;
								alltrim(::SAutProc:CodLdp) <> alltrim(BE4->BE4_CODLDP) .or. ;
								alltrim(::SAutProc:CodPeg) <> alltrim(BE4->BE4_CODPEG) .or. ;
								alltrim(::SAutProc:Numero) <> alltrim(BE4->BE4_NUMERO)

							BE4->(dbSetOrder(1)) //BE4_FILIAL+BE4_CODOPE+BE4_CODLDP+BE4_CODPEG+BE4_NUMERO+BE4_SITUAC+BE4_FASE
							BE4->(msSeek(xFilial("BE4")+::SAutProc:CodOpe+::SAutProc:CodLdp+::SAutProc:CodPeg + left(::SAutProc:Numero, TamSx3("BE4_NUMERO")[1])))

						endif

						oObjVOGuia := objCtrlGuia:montaResInt(aDados, aItens, .F., .F., .F. )

						oObjVOGuia:setCodOpe(::SAutProc:CodOpe)
						oObjVOGuia:setTipGui("05")
						oObjVOGuia:setCodLdp(::SAutProc:CodLdp)
						oObjVOGuia:setCodPeg(::SAutProc:CodPeg)
						oObjVOGuia:setNumero(::SAutProc:Numero)

						aObjProcedimentos 	:= objCtrlGuia:getLstProcedimentos(::SAutProc:Matric, aItens, oObjVOGuia)
						aRetGui 			:= objCtrlGuia:incIteGuia(oObjVOGuia, aObjProcedimentos, .F.)
						::RetAutProc:NumGui := oObjVOGuia:getCodOpe() + ";" + oObjVOGuia:getCodLdp()  + ";" + oObjVOGuia:getCodPeg()  + ";" + oObjVOGuia:getNumero()

					endif

				endif

				//Pega os valores do procedimento caso seja odonto ou pagamento no ato
				If Len(aValor) > 0

					If aValor[1]

						If Len(aValor) >= 17

							aRetUs  := aValor[17][1]

							For nI := 1 To Len(aRetUs)

								If Len(aRetUs[nI]) >= 9

									nQtdUs += aRetUs[nI,9] //US usada para calculo do evento

								EndIf

							Next

						EndIf

						nVlrCon	:= aValor[06] //Valor contratado
						nVlrTPF	:= aValor[12] //Valor Total da participacao

					Endif

				EndIf

				//Resultado da matriz de retorno
				For nI := 1 To Len(aMatRet)

					Do Case

						//Retorna sim ou nao para autorizacao
						Case Lower(aMatRet[nI]) == 'cstatusaut'

							cMatRetRes += aMatRet[nI] + ";" + Iif(aRet[1],Iif(lAto,"5","1"),"0") + "~"

							//Retorna quantidade autorizada ou negada
						Case Lower(aMatRet[nI]) $ 'cqtdautssol,cqtdsexe,cqtdoexe,cqtdsautpro'

							If aRet[1]

								cMatRetRes += aMatRet[nI] + ";" + AllTrim(Str(::SAutProc:QtdPro)) + "~"

								//Critica de quantidade executada maior que solicitada
								//nesse caso é necessário gravar a quantidade no grid para que na confirmação da guia
								//o sistema possa negar o procedimento pela quantidade executada.
							ElseIf ! aRet[1] .and. len(aRet[2]) > 0 .and. aRet[2][1][1] $ "564,078"

								cMatRetRes += aMatRet[nI] + ";" + AllTrim(Str(::SAutProc:QtdPro)) + "~"

							ElseIf Lower(aMatRet[nI]) != "cqtdsexe"

								cMatRetRes += aMatRet[nI] + ";0~"

							EndIf

							//Retorna Quantidade US
						Case Lower(aMatRet[nI]) == 'nqtdusse'
							if(::SAutProc:TipGui <> '4')
								cMatRetRes += aMatRet[nI] + ";" + AllTrim(Str(nQtdUs))  +"~"
							else
								cMatRetRes += aMatRet[nI] + ";" + AllTrim(Str(0))  +"~"
							endIf

							//Retorna Valor contratado
						Case Lower(aMatRet[nI]) == 'nvlrunise'
							if(::SAutProc:TipGui <> '4')
								cMatRetRes += iif( !empty(::SAutProc:ValorApr) .and. (::SAutProc:ValorApr > "0,00"), aMatRet[nI] + ";" + alltrim(::SAutProc:ValorApr),  aMatRet[nI] + ";" + AllTrim(Str(nVlrCon))) + "~"
							else
								cMatRetRes += iif( !empty(::SAutProc:ValorApr) .and. (::SAutProc:ValorApr > "0,00"), aMatRet[nI] + ";" + alltrim(::SAutProc:ValorApr),  aMatRet[nI] + ";" + AllTrim(Str(0))) + "~"
							endIf
							//Retorna Valor participacao
						Case Lower(aMatRet[nI]) == 'nvlrfrpase'
							if(::SAutProc:TipGui <> '4')
								cMatRetRes += aMatRet[nI] + ";" + AllTrim(Str(nVlrTPF)) + "~"
							else
								cMatRetRes += aMatRet[nI] + ";" + AllTrim(Str(0))  +"~"
							endIf

							//Retorna S-autorizado, N-nao autorizado
						Case Lower(aMatRet[nI]) == 'cautse'

							cMatRetRes += aMatRet[nI] + ";" + Iif(aRet[1],"S","N") + "~"

							//Retorna o codigo da glosa
						Case Lower(aMatRet[nI]) == 'ccodneg'

							cMatRetRes += aMatRet[nI] + ";" + cCodNeg + "~"

					EndCase

				Next

				//Retorna a string formatada
				::RetAutProc:MatRetRes := cMatRetRes

				//Lembrete do Procedimento na Tabela Padrão
				::RetAutProc:Lembrete := "0"

				If BR8->( FieldPos("BR8_LEMBRE") ) > 0 .and. ! Empty(BR8->BR8_LEMBRE)

					If PLSLEMBRE(.F.,.T.,::SAutProc:CodPad,::SAutProc:CodPro)
						::RetAutProc:Lembrete := allTrim(BR8->BR8_LEMBRE)
					EndIf

				EndIf

			Else

				lRetorno := .F.
				SetSoapFault( "", "Retorno invalido na checagem do procedimento ("+::ProDad:CodPro+")" )

			EndIf

		EndIf

	Else

		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )

	EndIf

	RestArea( aArea )

Return lRetorno


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VldHoPar   ³Autor  ³ Alexander	            ³ Data ³11.03.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica item do honorario individual						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VldHoPar WSRECEIVE UserCode, SAutProc WSSEND RetAutProc WSSERVICE PLSXFUN

	LOCAL lRetorno 		:= .T.
	Local cOpeOri := ""
	Local cCodPla := ""
	Local cTissVer
	Local cGrPar
	Local cCodPad
	Local cCodPro
	Local aTpPRec := {}
	Local aItens := {}
	Local aResult := {}
	Local aPartAntigas	:= strToArray( ::SAutProc:GrpParExe , ';')

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "VldHoPar" )

		//Posiciona na internacao
		BE4->( DbSetOrder(2) )//BE4_FILIAL + BE4_CODOPE + BE4_ANOINT + BE4_MESINT + BE4_NUMINT
		If BE4->( MsSeek(xFilial("BE4")+::SAutProc:ChavLib) )

			If aScan(  ClassDataArr(::SAutProc)  ,{|x| AllTrim(x[1]) == "TISSVER"  }) > 0
				cTissVer := ::SAutProc:TissVer
			EndIf

			//Faz os de-para das terminologias
			If cTissVer >="3"
				cGrPar		:= AllTrim(PLSVARVINC('35','BWT', ::SAutProc:GrPar))

				cCodPad := AllTrim(PLSVARVINC('87','BR4', ::SAutProc:CodPad))
				cCodPro := AllTrim(PLSVARVINC(::SAutProc:CodPad,'BR8',::SAutProc:CodPro ,cCodPad+::SAutProc:CodPro))
				::SAutProc:CodPad := cCodPad
				::SAutProc:CodPro := cCodPro

			Else
				cGrPar := ::SAutProc:GrPar
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Participacao																³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			AaDd( aTpPRec,{ cGrPar,;
				::SAutProc:Rda,;
				::SAutProc:NomRda,;
				::SAutProc:CodSig,;
				::SAutProc:NumCr,;
				::SAutProc:Estado,;
				Iif(Empty(::SAutProc:NomExe),::SAutProc:NomRda,::SAutProc:NomExe),;
				.T. } )


			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Item																		³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			AaDd( aItens, {	{ "SEQMOV", StrZero(Val(::SAutProc:SeqMov),TamSx3("BD6_SEQUEN")[1]) },;
				{ "CODPRO", ::SAutProc:CodPro },;
				{ "CODPAD", ::SAutProc:CodPad },;
				{ "QTD"	  , ::SAutProc:QtdPro },;
				{ "QTDAUT", ::SAutProc:QtdPro },;
				{ "VLRAPR", 0 },;
				{ "DATPRO", Date() },;
				{ "ATPPAR", aTpPRec },;
				{ "TISSVER", cTissVer } } )

			aItens[1] := WsAutoOpc( aItens[1] )


			BA1->(dbSetOrder(2))
			if BA1->(msseek(xFilial("BA1")+BE4->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC+BE4_TIPREG+BE4_DIGITO)))
				cOpeOri := BA1->BA1_OPEORI
				cCodPla := BA1->BA1_CODPLA
			endIf

			if(empty(cCodPla))
				BA3->(dbSetOrder(1))
				if BA3->(msseek(xFilial("BA3")+BE4->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC)))
					cCodPla := BA3->BA3_CODPLA
				endIf
			endIf

			::RetAutProc		:= WsClassNew( "SMatRetAutProc" )

			aResult	:= PLVLDPART(/*CToD("")*/ ::SAutProc:DatPro , BE4->BE4_CODRDA, BE4->BE4_CODESP, BE4->BE4_SUBESP, BE4->BE4_CODLOC, BE4->BE4_LOCAL, cOpeOri, cCodPla, aItens, aPartAntigas)
			::RetAutProc:ProAut	   := aResult[1]
			::RetAutProc:MatRetRes := aResult[2]

		Else
			lRetorno := .F.
			SetSoapFault( "", "Nenhuma guia encontrada ( "+Transform( ::SAutProc:ChavLib, "@R 9999.9999.99.99999999" )+" )" )
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VldHoIn   ³Autor  ³ Alexander	            ³ Data ³11.03.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica item do honorario individual						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VldHoIn WSRECEIVE UserCode, SAutProc WSSEND RetAutProc WSSERVICE PLSXFUN
	LOCAL nI		 	:= 0
	LOCAL lRetorno 		:= .T.
	LOCAL aItens		:= {}
	LOCAL aTpPRec		:= {}
	LOCAL aCriticas 	:= {}
	LOCAL aMatBD6		:= {}
	LOCAL aRet			:= {}
	LOCAL aArea    	 	:= GetArea()
	LOCAL cTissver	:= ""
	LOCAL cOpeOri		:= ""
	LOCAL cCodPla		:= ""
	local lTemAux		:= iif ( (val(::SAutProc:NumAuxi) > 0), .t., .f.)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "VldHoIn" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona na internacao														³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BE4->( DbSetOrder(2) )//BE4_FILIAL + BE4_CODOPE + BE4_ANOINT + BE4_MESINT + BE4_NUMINT
		If BE4->( MsSeek(xFilial("BE4")+::SAutProc:ChavLib) )

			If aScan(  ClassDataArr(::SAutProc)  ,{|x| AllTrim(x[1]) == "TISSVER"  }) > 0 .AND. ValType(::SAutProc:TissVer) <> 'U'
				cTissVer := ::SAutProc:TissVer
			EndIf

			//Faz os de-para das terminologias
			If cTissVer >="3"
				cGrPar		:= AllTrim(PLSVARVINC('35','BWT', ::SAutProc:GrPar))

				cCodPad := AllTrim(PLSVARVINC('87','BR4', ::SAutProc:CodPad))
				cCodPro := AllTrim(PLSVARVINC(::SAutProc:CodPad,'BR8',::SAutProc:CodPro ,cCodPad+::SAutProc:CodPro))
				::SAutProc:CodPad := cCodPad
				::SAutProc:CodPro := cCodPro

			Else
				cGrPar := ::SAutProc:GrPar
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Participacao																³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			AaDd( aTpPRec,{ cGrPar,;
				::SAutProc:Rda,;
				::SAutProc:NomRda,;
				::SAutProc:CodSig,;
				::SAutProc:NumCr,;
				::SAutProc:Estado,;
				Iif(Empty(::SAutProc:NomExe),::SAutProc:NomRda,::SAutProc:NomExe),;
				.T. } )

			If aScan(  ClassDataArr(::SAutProc)  ,{|x| AllTrim(x[1]) == "TISSVER"  }) > 0
				cTissVer := ::SAutProc:TissVer
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Item																		³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			AaDd( aItens, {	{ "SEQMOV", StrZero(Val(::SAutProc:SeqMov),TamSx3("BD6_SEQUEN")[1]) },;
				{ "CODPRO", ::SAutProc:CodPro },;
				{ "CODPAD", ::SAutProc:CodPad },;
				{ "QTD"	  , ::SAutProc:QtdPro },;
				{ "QTDAUT", ::SAutProc:QtdPro },;
				{ "VLRAPR", 0 },;
				{ "DATPRO", Date() },;
				{ "ATPPAR", aTpPRec },;
				{ "TISSVER", cTissVer } } )

			aItens[1] := WsAutoOpc( aItens[1] )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta aMatBD6															 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nI:=1 To Len(SAutProc:MATBD6)
				AaDd(aMatBD6,{	SAutProc:MATBD6[nI]:seqinf,;
					SAutProc:MATBD6[nI]:sequen,;
					SAutProc:MATBD6[nI]:codpad,;
					SAutProc:MATBD6[nI]:codpro,;
					SAutProc:MATBD6[nI]:qtdpro,;
					SAutProc:MATBD6[nI]:orimov,;
					SAutProc:MATBD6[nI]:procci,;
					SAutProc:MATBD6[nI]:recno,;
					SAutProc:MATBD6[nI]:denreg,;
					SAutProc:MATBD6[nI]:fadent,;
					SAutProc:MATBD6[nI]:datpro } )
			Next
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Valida procedimento do Honorario Individual								 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			BA1->(dbSetOrder(2))
			if BA1->(msseek(xFilial("BA1")+BE4->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC+BE4_TIPREG+BE4_DIGITO)))
				cOpeOri := BA1->BA1_OPEORI
				cCodPla := BA1->BA1_CODPLA
			endIf

			if(empty(cCodPla))
				BA3->(dbSetOrder(1))
				if BA3->(msseek(xFilial("BA3")+BE4->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC)))
					cCodPla := BA3->BA3_CODPLA
				endIf
			endIf

			aRet := PLVLDRESHO(BE4->(BE4_CODOPE+BE4_CODLDP+BE4_CODPEG+BE4_NUMERO),"2"/*"1"*/,"2",;
				BE4->BE4_DTALTA,BE4->BE4_TIPFAT,.T.,;
				BE4->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC+BE4_TIPREG+BE4_DIGITO),"2",;
				"","","",::SAutProc:DatPro,aItens,aMatBD6,{},{},aCriticas,nil,nil,nil,;
				BE4->BE4_CODRDA, BE4->BE4_CODESP, BE4->BE4_SUBESP, BE4->BE4_CODLOC, BE4->BE4_LOCAL, cOpeOri, cCodPla, .T., lTemAux )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Retorno															   	   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::RetAutProc		:= WsClassNew( "SMatRetAutProc" )
			::RetAutProc:ProAut	:= .T.
			::RetAutProc:PosBD6	:= aRet[2]
			::RetAutProc:SeqInf	:= aRet[3]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se foi autorizado													   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (aRet[1] == .F. .And. Len(aCriticas) == 0) //Pode ocorrer do usuário trocar o código da tabela ou procedimento para um inexistente e o sistema não criticava e dava errorlog. Controle realizado para esta situação.
				lRetorno := .F.
				SetSoapFault( "", "De/Para não existente ou códigos inválidos de tabela e procedimento.<br>Revise os dados." )
			EndIf
			If Len(aCriticas) > 0
				::RetAutProc:ProAut	:= .F.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Processar criticas retornadas										   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				::RetAutProc:MatCri	:= {}
				For nI:=1 To Len(aCriticas)

					If !Empty(aCriticas[nI,1])
						aRetCri := PLSRETCRI( AllTrim( aCriticas[nI,2] ) )

						If EMPTY(aRetCri[nI][2])
							aRetCri[1][1] := aCriticas[nI][2]
							aRetCri[1][2] := aCriticas[nI][3]
						EndIf
					Else
						aRetCri := {}
						AaDd(aRetCri,{"",aCriticas[nI,2]} )
					EndIf

					AaDd( ::RetAutProc:MatCri, WsClassNew( "GenericStruct" ) )
					::RetAutProc:MatCri[nI]:Code 		:= Iif( Empty(aRetCri[1,1]),"&nbsp;&nbsp;&nbsp;&nbsp;",aRetCri[1,1] )
					::RetAutProc:MatCri[nI]:Description	:= PadR( AllTrim(aRetCri[1,2]),60 ) + "<br>"
				Next
			EndIf
		Else
			lRetorno := .F.
			SetSoapFault( "", "Nenhuma guia encontrada ( "+Transform( ::SAutProc:ChavLib, "@R 9999.9999.99.99999999" )+" )" )
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/{Protheus.doc} VldBTQChv
retorna terminologia
@author PLSTEAM
@since 10.2007
@version P12
/*/
WSMETHOD VldBTQChv WSRECEIVE UserCode, Chave, cOpcao, cCheckDePara WSSEND MatGuia WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL cSQL			:= ""
	LOCAL cAlias      	:= "BTQ"

	If PrtChkUser( ::UserCode, "PLSXFUN", "VldBTQChv" ) //consome uma licença, checa integridade d acesso

		cSql := " SELECT R_E_C_N_O_ RECNE, BTQ_DESTER DESCRI "
		cSql += "   FROM " + RetSQLName(cAlias)
		cSql += "  WHERE BTQ_FILIAL = '" + xFilial(cAlias) + "' "
		cSql += "    AND BTQ_CODTAB = '" + ::cOpcao + "'"
		cSql += "    AND BTQ_VIGDE <= '" + dtos(dDataBase) + "' "
		cSql += "    AND BTQ_CDTERM = '" + ::Chave + "' "
		cSql += "    AND D_E_L_E_T_ = '' "

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,changeQuery(cSQL)),"TrbSql",.T.,.F.)

		::MatGuia:SCabGui		:= WsClassNew( "MCabGui" )
		::MatGuia:SCabGui:obs	:= ""

		If !TrbSql->(Eof()) .and. TrbSql->RECNE > 0

			BTU->(DbSetOrder(5)) //BTU_FILIAL, BTU_CODTAB, BTU_CDTERM, BTU_ALIAS

			If cCheckDePara == '1' .and. ! BTU->(MsSeek(xFilial("BTU")+::cOpcao+padr(::Chave, tamsx3("BTU_CDTERM")[1])))

				lRetorno := .F.
				TrbSql->(DbCloseArea())
				SetSoapFault( "", "Tabela de terminologia ["+::cOpcao+"] nao contem o de-para para o termo ["+::Chave+"]. Entre em contato com a sua operadora." )

			Else

				lRetorno := .T.
				::MatGuia:SCabGui:obs				:= UPPER(ALLTRIM(TrbSql->DESCRI))
				TrbSql->(DbCloseArea())

			Endif

		Else

			lRetorno := .F.
			TrbSql->(DbCloseArea())
			SetSoapFault( "", "Nao encontrada nenhuma referencia para o codigo informado" )

		EndIf

	Else

		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )

	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    RetBTQChv ³Autor  ³ Roberto	            ³ Data ³06.04.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os dados da BTQ de acordo com a tabela e data.	   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetBTQChv WSRECEIVE UserCode, Chave WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL cSQL			:= ""
	LOCAL cAlias      	:= "BTQ"

	If PrtChkUser( ::UserCode, "PLSXFUN", "RetBTQChv" ) //consome uma licença, checa integridade de acesso

		cSql := "SELECT BTQ_CDTERM CDTERM,BTQ_DESTER DESCRI"
		cSql += " FROM " + RetSQLName(cAlias)
		cSql += " WHERE " + cAlias + "_FILIAL = '" + xFilial(cAlias) + "'"

		cSQL += " AND ( '"+dtos(dDataBase)+"' >= BTQ_VIGDE ) AND "
		cSQL += "     (( '"+dtos(dDataBase)+"' <= BTQ_VIGATE OR BTQ_VIGATE = '' ) OR ( BTQ_VIGDE = '' AND BTQ_VIGATE = '' )) "

		cSql += " AND BTQ_CODTAB ='" + ::Chave  + "'"
		cSql += " AND D_E_L_E_T_ = '' "

		cQuery	:= ChangeQuery(cSql)
		TcQuery cQuery New Alias "TabTmp"

		::WSNULL := ""

		While !TabTmp->(Eof())
			::WSNULL += alltrim(TabTmp->CDTERM) + ";" + alltrim(TabTmp->DESCRI) + "#"
			TabTmp->(DbSkip())
		Enddo

		TabTmp->(DBCLOSEAREA())

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetSerPct ³Autor  ³ Roberto	Vanderlei     ³ Data ³07.05.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os dados dos serviços que compoem algum pacote	   	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetSerPct WSRECEIVE UserCode, UserCardNumber, NumAut, TipoAut, RDACode, CodLoc, Tipo, CodEsp, SetDtInt, Altera WSSEND IteGui WSSERVICE PLSXFUN
	local nI			:= 0
	local nP			:= 0
	local cCodPad		:= ''
	local cCodPro		:= ''
	local cProcedimento	:= ''
	local cSQL			:= ''
	local cMatric		:= ''
	local cNameBLE		:= BLE->(retSQLName("BLE"))
	local cFilialBLE	:= BLE->(xFilial("BLE"))
	local cCodInt		:= plsIntPad()
	local lPLSEXPC 		:= getNewPar("MV_PLSEXPC",.f.)

	private aTabDup 	:= {}

	//TODO - 20/04/2018 - Roberto - necessario rever este codigo
	//TODO - colocar tratamento dentro da RETAULI (sendo chamada duas vezes desnecessariamente)
	//TODO - colocar tratamento para validacao do metodo PrtChkUser avisar clientes para carregar lista de WS como direito

	if lPLSEXPC

		aTabDup := PlsBusTerDup(superGetMv("MV_TISSCAB", .f. ,"87"))

		cMatric	 := PPLTROMAT(UserCardNumber)
		aRetorno := PLSRETAULI(cMatric,::NumAut,::TipoAut,::RDACode,::CodLoc,::CodEsp,,,,,,::Tipo,,,::Altera)

		BAU->(dbSetOrder(1))

		for nI := 1 to len(aRetorno[4])

			cCodPad	:= aRetorno[4,nI,3]
			cCodPro := aRetorno[4,nI,4]

			cSQL := " SELECT BLE_CPADOC, BLE_CODPRO, BLE_CODPAD "
			cSQL += "   FROM " + cNameBLE
			cSQL += "  WHERE BLE_FILIAL = '" + cFilialBLE + "' "
			cSQL += "    AND BLE_CODINT = '" + cCodInt + "' "
			cSQL += "    AND BLE_CPADOC = '" + cCodPad + "' "
			cSQL += "    AND BLE_CODOPC = '" + cCodPro + "' "
			cSQL += "    AND BLE_TIPO = '9' "
			cSQL += "    AND ( BLE_VIGDE <= '" + dtos(dDataBase) + "' AND "
			cSQL += "        ( BLE_VIGATE = '' OR '" + dtos(dDataBase) + "' <= BLE_VIGATE ) ) "
			cSQL += "    AND D_E_L_E_T_ = '' "

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,ChangeQuery(cSQL)),"TRBBLE",.T.,.F.)

			if ! TRBBLE->(eof())

				nP := 1

				AaDd(::IteGui, WsClassNew( "MIteGui" ) )

				::IteGui[nI]:TpServ 	:= aRetorno[4,nI,1]
				::IteGui[nI]:Sequencia	:= aRetorno[4,nI,2]

				BAU->( msSeek(xFilial("BAU") + aRetorno[3,1] ) )

				If BAU->BAU_TISVER >= "3"

					cPadBkp := PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  aRetorno[4,nI,3],.T.)

					::IteGui[nI]:CodPro 	:= PLSGETVINC("BTU_CDTERM", "BR8", .F., ::IteGui[nI]:CodPad,  Alltrim(aRetorno[4,nI,3]+aRetorno[4,nI,4]), .F. ,aTabDup, @cPadBkp)
					::IteGui[nI]:CodPad 	:= cPadBkp
					::IteGui[nI]:DesPro 	:= PlDcCrcPrt( PLSGETVINC("BTQ_DESTER", "BR8", .F., ::IteGui[nI]:CodPad,  Alltrim(aRetorno[4,nI,3]+aRetorno[4,nI,4])) )
					::IteGui[nI]:CodPro_Ori := aRetorno[4,nI,4]

				Else

					::IteGui[nI]:CodPad 	:= aRetorno[4,nI,3]
					::IteGui[nI]:CodPro 	:= aRetorno[4,nI,4]
					::IteGui[nI]:DesPro 	:= aRetorno[4,nI,5]

				Endif

				::IteGui[nI]:QtdSol 	:= aRetorno[4,nI,6]
				::IteGui[nI]:QtdAut 	:= aRetorno[4,nI,7]

				::IteGui[nI]:SPctIteGui := {}

				while !TRBBLE->(eof())

					AaDd(::IteGui[nI]:SPctIteGui, WsClassNew( "MPctIteGui" ) )

					cProcedimento := posicione("BLD",3, xFilial("BLD") + TRBBLE->(BLE_CPADOC + BLE_CODPRO) ,"BLD_DESPRO")

					::IteGui[nI]:SPctIteGui[nP]:CodPad := alltrim(TRBBLE->BLE_CODPAD)
					::IteGui[nI]:SPctIteGui[nP]:CodPro := alltrim(TRBBLE->BLE_CODPRO)
					::IteGui[nI]:SPctIteGui[nP]:DesPro := alltrim(cProcedimento)

					nP += 1

					TRBBLE->(DbSkip())
				endDo

			endIf

			TRBBLE->( dbCloseArea() )

		next

	endIf

	lRetorno := .T.

return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetAutLib ³Autor  ³ Alexander	            ³ Data ³06.04.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os dados da liberacao pelo numero da liberacao	   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetAutLib WSRECEIVE UserCode, UserCardNumber, NumAut, TipoAut, RDACode, CodLoc, Tipo, CodEsp, SetDtInt, Pacotes, Altera, TipGui, DigiGui, DatGuia, cOpcao, Reimpressao WSSEND MatGuia WSSERVICE PLSXFUN
	LOCAL nI                := 0
	LOCAL nP                := 0
	LOCAL nPct 				:= 0
	LOCAL lRetorno 	 		:= .T.
	LOCAL lInc				:= .F.
	LOCAL aRet				:= {}
	LOCAL aRetorno	 		:= {}
	LOCAL aArea				:= GetArea()
	LOCAL cMatric			:= ""
	LOCAL lContinua			:= .t.
	LOCAL cTissVer			:= PLSTISSVER(::RDACode)//passo como parametro a RDA que esta logada
	LOCAL aTpProcs			:= BR8->(RetSx3Box( X3CBox( Posicione('SX3',2,'BR8_TPPROC','X3_CBOX') ),,,1 ))
	LOCAL nPosTpProc		:= 0
	local aPacotes			:= {}
	local cCodProc			:= ""
	local cCodPadc			:= ""
	local aCampos			:= {}
	local cTpAlt			:= ""
	local cDatAtd			:= ""
	local lDtSeInt       	:= getNewPar("MV_DTSEINT",.F.)
	local lPLSEXPC 			:= getNewPar("MV_PLSEXPC",.f.)
	local cSQL				:= ''
	local cNameBLE			:= BLE->(retSQLName("BLE"))
	local cFilialBLE		:= BLE->(xFilial("BLE"))
	local cCodInt			:= plsIntPad()
	local lProrroga			:= GetNewPar("MV_PLLBALT",.F.)
	local cNmSocial         := ""

	PRIVATE aTabDup 			:= PlsBusTerDup(SuperGetMv("MV_TISSCAB", .F. ,"87"))
	DEFAULT ::UserCardNumber	:= ""
	DEFAULT ::NumAut		 	:= ""
	DEFAULT ::TipoAut			:= "0"
	DEFAULT ::RDACode			:= ""
	DEFAULT ::CodLoc			:= ""
	DEFAULT ::Tipo				:= "0"
	DEFAULT ::CodEsp			:= ""
	DEFAULT ::SetDtInt			:= "0"
	DEFAULT ::Pacotes			:= {}
	DEFAULT ::TipGui 			:= ""
	DEFAULT ::DigiGui 			:= ""
	DEFAULT ::DatGuia 			:= ""
	DEFAULT ::cOpcao			:= "0"
	DEFAULT ::Reimpressao		:= ""

	//TODO - Roberto - necessario rever este codigo relacionado a tabela BLE/BLZ e BLD
	//TODO - verificar onde a funcao PlSplitAdvpl foi declarada

	//Checa Usuário
	If PrtChkUser( ::UserCode, "PLSXFUN", "RetAutLib" )

		//Verifica se e Usuário de intercambio e pega a matricula original
		cMatric := PPLTROMAT(::UserCardNumber)

		//Ponto de entrada para validar a liberacao informada
		if existblock("PL90VLDLIB")
			aRetorno	:=  execBlock("PL90VLDLIB",.F.,.F.,{::NumAut,.t.})
			lContinua	:= aRetorno[1]
		endIf

		//Retorna dados da Internacao - formulario de internacao/data internacao
		if lContinua

			aRetorno := {} //Reinicia array caso esteja utilizando PE PL90VLDLIB

			if ::cOpcao == "1"
				cDatAtd := ::DatGuia
			endif

			If ::Tipo == '3' .OR. ::Tipo == '11' .OR. ::Tipo == '6'

				BE4->(dbsetorder(2))
				If BE4->(MsSeek(xFilial("BE4") + ::NumAut))

					If BE4->BE4_SITUAC == "2"

						lRetorno := .f.
						SetSoapFault( "", "A guia digitada está cancelada" )

						/*ElseIf ! Empty(BE4->BE4_DATVAL) .and. dDataBase > (BE4->BE4_DATVAL + dDatRet)

					lRetorno := .f.
						SetSoapFault( "", "Data de validade da Guia foi Ultrapassada!" )*/

					ElseIf BE4->BE4_STATUS == "6"

						lRetorno := .f.
						SetSoapFault( "", "Guia em análise pela auditoria" )

					ElseIf BE4->BE4_STATUS == "3"

						lRetorno := .f.
						SetSoapFault( "", "A guia digitada não foi autorizada" )

					ElseIf ::Tipo == '6' .AND. Empty(BE4->BE4_DATPRO)

						lRetorno := .f.
						SetSoapFault( "", "A data de Internação ainda não foi informada pelo prestador. Não será possível continuar." )

					EndIf

					If ( ! empty(::RDACode) .and.  ::Tipo == '11' ) .or. ( ! empty(::RDACode) .and. ::Tipo == '3' .and. ::SetDtInt = '1' )

						If !lProrroga .And. ::Tipo == '11' .And. !Empty(BE4->BE4_DTALTA)

							lRetorno := .F.
							SetSoapFault( "", "Data da alta já informada, não é permitido incluir uma prorrogação." )

						ElseIf !(BE4->BE4_CODRDA $ ::RDACode)

							lRetorno := .f.
							SetSoapFault( "", "A guia informada pertence a outro prestador." )

						Else

							If ::Tipo == '11' .And. lDtSeInt

								If Empty(BE4->BE4_DATPRO)
									lRetorno := .f.
									SetSoapFault( "", "Data de internação nao informada!" )
								EndIf

							EndIf

						EndIf

					Endif

				EndIf

				If !lRetorno
					Return lretorno
				EndIf

				aRetorno := PLSDADINT(::NumAut,,::TipoAut, ::Tipo)

				//Retorna dados dos Anexos
			ElseIf ::Tipo $ '7,8,9'

				PLA09ALIB(::NumAut,.T.,aRetorno, ::RDACode)

				//Retorna uma liberacao se existir para este Usuário 					   ³
				//Vai ter que ser ajustado para checar se pode executar ou nao somente    ³
				//quando selecionar o executante. (Caso onde a clinica e Juridica e tem   ³
				//corpo clinico. (Contratado diferente de profissional)				   ³
			Else

				BEA->(dbsetorder(1))
				If BEA->(MsSeek(xFilial("BEA")+::NumAut))

					If BEA->BEA_LIBERA == "0" .and. !empty(::UserCardNumber) // Para guias no padrão antigo não deve validar.

						lRetorno := .F.
						SetSoapFault( "", "O número digitado não é de uma liberação." )

					ElseIf !empty(::UserCardNumber) .And. AllTrim(BEA->(BEA_OPEUSR+BEA_CODEMP+BEA_MATRIC+BEA_TIPREG+BEA_DIGITO)) <> ::UserCardNumber .And. AllTrim(BEA->(BEA_OPEUSR+BEA_CODEMP+BEA_MATRIC+BEA_TIPREG+BEA_DIGITO)) <> cMatric

						lRetorno := .F.
						SetSoapFault( "", "Esta guia não corresponde ao beneficiário selecionado" )

					ElseIf BEA->BEA_CANCEL == '1'

						lRetorno := .F.
						SetSoapFault( "", "A guia digitada está cancelada")

					ElseIf BEA->BEA_STATUS == '3' .and.  !empty(::UserCardNumber)

						lRetorno := .F.
						SetSoapFault( "", "A guia digitada não foi autorizada")

					ElseIf BEA->BEA_STALIB == "2"
						if !empty(::UserCardNumber) //Sefor reimpressao manda esse campo em branco e não valida saldo.
							lRetorno := .F.
							SetSoapFault( "", "Liberação não possui saldo para execução")
						endif
					EndIf

					If !lRetorno
						Return lretorno
					EndIf
				EndIf

				aRetorno := PLSRETAULI(cMatric,::NumAut,::TipoAut,::RDACode,::CodLoc,::CodEsp,,,,,,::Tipo,,,::Altera,cDatAtd )

			endIf

		endIf

		//Verifica o Retorno
		If aRetorno[1]

			if (::TipGui == "6")

				if !empty(::DatGuia)

					if !empty(aRetorno[3,70]) .and.  aRetorno[3,70] < CTOD(::DatGuia)
						lRetorno := .F.
						SetSoapFault( "", "A internação está com a data de alta anterior a data de atendimento informada, não será possível incluir honorário." )
						return lRetorno
					EndIf

					if  aRetorno[3,69] > CTOD(::DatGuia)
						lRetorno := .F.
						SetSoapFault( "", "A data de atendimento esta anterior a data de inclusão da solicitação de internação, não será possível incluir honorário." )
						return lRetorno
					EndIf

				endIf

				if ::UserCardNumber <> aRetorno[3,39]
					lRetorno := .F.
					SetSoapFault( "", "A solicitação de internação informada pertence a outra matrícula." )
					return lRetorno
				endif

			endIf

			If (cTissVer >= '3')

				if ::Tipo = '3'
					cCarSol := alltrim(PLSGETVINC("BTU_CDTERM", "BDR", .F., "23", AllTrim(aRetorno[3,92])))
				else
					If Len(aRetorno[3]) > 91 .and. Len(aRetorno[3]) <= 97
						cCarSol := alltrim(PLSGETVINC("BTU_CDTERM", "BDR", .F., "23", AllTrim(aRetorno[3,91])))
					Else
						cCarSol := alltrim(PLSGETVINC("BTU_CDTERM", "BDR", .F., "23", AllTrim(aRetorno[3,22])))
					Endif
				endif

			Else
				cCarSol := AllTrim(aRetorno[3,22])
			Endif

			//Atualizando o nome social do beneficiario, baseado no array de retorno
			if ::Tipo $ '3,11,6'
				cNmSocial := aRetorno[3,97]
			elseif ::Tipo $ '7,8,9'
				cNmSocial := aRetorno[3,110]
			else
				cNmSocial := aRetorno[3,113]
			endif

			//Cabecalho
			::MatGuia:SCabGui					:= WsClassNew( "MCabGui" )
			::MatGuia:SCabGui:Rda				:= aRetorno[3,1]
			::MatGuia:SCabGui:RegAns			:= aRetorno[3,2]
			::MatGuia:SCabGui:NomeRda			:= aRetorno[3,3]
			::MatGuia:SCabGui:CnpjCpfSol 		:= aRetorno[3,4]
			::MatGuia:SCabGui:CnesSol      		:= aRetorno[3,5]
			::MatGuia:SCabGui:TpLograd			:= aRetorno[3,6]
			::MatGuia:SCabGui:Endereco			:= aRetorno[3,7]
			::MatGuia:SCabGui:Numero			:= aRetorno[3,8]
			::MatGuia:SCabGui:Complemento		:= aRetorno[3,9]
			::MatGuia:SCabGui:Municipio			:= aRetorno[3,10]
			::MatGuia:SCabGui:Bairro			:= aRetorno[3,11]
			::MatGuia:SCabGui:Estado			:= aRetorno[3,12]
			::MatGuia:SCabGui:IBGE				:= aRetorno[3,13]
			::MatGuia:SCabGui:Cep				:= aRetorno[3,14]
			::MatGuia:SCabGui:Tel   			:= aRetorno[3,15]
			::MatGuia:SCabGui:DtAut				:= aRetorno[3,16]
			::MatGuia:SCabGui:HrAut				:= aRetorno[3,17]
			::MatGuia:SCabGui:Senha				:= aRetorno[3,18]
			::MatGuia:SCabGui:DtValid			:= aRetorno[3,19]
			::MatGuia:SCabGui:DtSolicit			:= aRetorno[3,20]
			::MatGuia:SCabGui:HrSolicit			:= aRetorno[3,21]
			::MatGuia:SCabGui:CarSolicit		:= cCarSol
			::MatGuia:SCabGui:Cid				:= aRetorno[3,23]
			::MatGuia:SCabGui:ProSol			:= aRetorno[3,24]
			::MatGuia:SCabGui:OpeSol			:= aRetorno[3,25]
			::MatGuia:SCabGui:NomeSol			:= aRetorno[3,26]
			::MatGuia:SCabGui:CodSigSol			:= aRetorno[3,27]
			::MatGuia:SCabGui:NumCrSol			:= aRetorno[3,28]
			::MatGuia:SCabGui:EstSigSol			:= aRetorno[3,29]
			::MatGuia:SCabGui:CbosSol			:= aRetorno[3,30]
			::MatGuia:SCabGui:DescCbosSol		:= aRetorno[3,31]
			::MatGuia:SCabGui:ProExe			:= aRetorno[3,32]
			::MatGuia:SCabGui:OpeExe			:= aRetorno[3,33]
			::MatGuia:SCabGui:NomeExe			:= aRetorno[3,34]
			::MatGuia:SCabGui:CodSigExe			:= aRetorno[3,35]
			::MatGuia:SCabGui:NumCrExe			:= aRetorno[3,36]
			::MatGuia:SCabGui:EstSigExe			:= aRetorno[3,37]
			::MatGuia:SCabGui:Obs				:= aRetorno[3,38]
			::MatGuia:SCabGui:Matric			:= iif(::Tipo <> '11' .and. !empty(cMatric) .and. aRetorno[3,39]<>cMatric,cMatric,aRetorno[3,39])
			::MatGuia:SCabGui:NomeUsr			:= aRetorno[3,40]
			::MatGuia:SCabGui:STAut				:= aRetorno[3,41]
			::MatGuia:SCabGui:IndCli			:= aRetorno[3,42]
			::MatGuia:SCabGui:Origem			:= aRetorno[3,43]
			::MatGuia:SCabGui:ChvBD6			:= aRetorno[3,44]
			::MatGuia:SCabGui:TipAto			:= aRetorno[3,45]
			::MatGuia:SCabGui:TipFat			:= aRetorno[3,46]
			::MatGuia:SCabGui:NumImp			:= aRetorno[3,47]
			::MatGuia:SCabGui:NomSocBn			:= cNmSocial

			//Retorno para internação
			If ::Tipo == '3' .OR. ::Tipo == '11' .OR. ::Tipo == '6' //Len(aRetorno[3]) == 97

				::MatGuia:SCabGui:CodLoc		:= aRetorno[3,95]

				If (cTissVer >= '3')

					cTpAlt := alltrim(PLSGETVINC("BTU_CDTERM", "BIY", .F., "39", AllTrim(aRetorno[3,96])))

					::MatGuia:SCabGui:TipAut			:= cTpAlt

				else
					::MatGuia:SCabGui:TipAut			:= AllTrim(aRetorno[3,96])
				endif

				If ValType(::MatGuia:SCabGui:TipAut) <> "C"
					::MatGuia:SCabGui:TipAut := ""
				EndIf

				//Nome Social do beneficiário TISS 4.00
				::MatGuia:SCabGui:NomSocBn := iif(len(aRetorno[3]) >= 97 .and. valtype(aRetorno[3,97]) == "C", aRetorno[3,97], "")
			Endif



			//Numero de Auxiliares
			if Len(aRetorno) > 6
				::MatGuia:SCabGui:NumAux := Alltrim(STR(aRetorno[7]))
			else
				::MatGuia:SCabGui:NumAux := ""
			endif

			//Retorno SADT
			If ::Tipo == "2" //Len(aRetorno[3]) > 97

				If (cTissVer >= '3')

					cTpAlt := alltrim(PLSGETVINC("BTU_CDTERM", "BIY", .F., "39", AllTrim(aRetorno[3,96])))
					::MatGuia:SCabGui:TipAut			:= cTpAlt

				else
					::MatGuia:SCabGui:TipAut			:= AllTrim(aRetorno[3,96])
				endif

				If ! Empty(aRetorno[3,89])
					::MatGuia:SCabGui:DtRlz		:= dToc(aRetorno[3,89])
					::MatGuia:SCabGui:DtRlz2	:= dToc(aRetorno[3,90])
					::MatGuia:SCabGui:DtRlz3	:= dToc(aRetorno[3,91])
					::MatGuia:SCabGui:DtRlz4	:= dToc(aRetorno[3,92])
					::MatGuia:SCabGui:DtRlz5	:= dToc(aRetorno[3,93])
					::MatGuia:SCabGui:DtRlz6	:= dToc(aRetorno[3,94])
					::MatGuia:SCabGui:DtRlz7	:= dToc(aRetorno[3,95])
					::MatGuia:SCabGui:DtRlz8	:= dToc(aRetorno[3,96])
					::MatGuia:SCabGui:DtRlz9	:= dToc(aRetorno[3,97])
					::MatGuia:SCabGui:DtRlz1	:= dToc(aRetorno[3,98])
				EndIf

				if !Empty(Altera)

					::MatGuia:SCabGui:TipSai	:= aRetorno[3,100]
					::MatGuia:SCabGui:TipCon	:= aRetorno[3,101]
					::MatGuia:SCabGui:TipAte	:= aRetorno[3,102]

					::MatGuia:SCabGui:EXECCO	:= aRetorno[3,103]
					::MatGuia:SCabGui:CEPCCO	:= aRetorno[3,106]
					::MatGuia:SCabGui:RGEXCO	:= aRetorno[3,104]
					::MatGuia:SCabGui:CCPECO	:= aRetorno[3,105]
					::MatGuia:SCabGui:PREXCC	:= aRetorno[3,107]
					::MatGuia:SCabGui:IndAci	:= aRetorno[3,108]
				endIf

				::MatGuia:SCabGui:Protoc			:= iif(len(aRetorno[3]) >= 109, aRetorno[3,109], "")
				::MatGuia:SCabGui:GuiaOpe 			:= iif(len(aRetorno[3]) >= 110, AllTrim(aRetorno[3,110]), "")
				::MatGuia:SCabGui:GuiaPri 			:= iif(len(aRetorno[3]) >= 111, AllTrim(aRetorno[3,111]), "")
				::MatGuia:SCabGui:CobEspW			:= iif(len(aRetorno[3]) >= 112, aRetorno[3,112], "") //r7
			else
				::MatGuia:SCabGui:Protoc			:= ""
			Endif

			//Referente a internacao/prorrogacao
			lInc := ( Len( aRetorno[3] ) > 47 )

			If (cTissVer >= '3')

				cTpIntern := Iif(lInc,aRetorno[3,48],'')

				If Len(aRetorno[3]) > 60
					cTpAcom := alltrim(PLSGETVINC("BTU_CDTERM", "BI4", .F., "49", AllTrim(aRetorno[3,60])))
				Endif
				If Len(aRetorno[3]) > 92 .and. Len(aRetorno[3]) <= 97
					cTpIntern := aRetorno[3,93]//pego o conteudo do grpint
				Endif
			Else
				cTpIntern := Iif(lInc,aRetorno[3,48],'')
				cTpAcom   := Iif(lInc,aRetorno[3,60],'')
			Endif

			if ::Tipo $ "7/8/9" .and. Len(aRetorno[3]) >= 110
				::MatGuia:SCabGui:NomSocBn := alltrim(aRetorno[3,110])
			endif

			::MatGuia:SCabGui:TpIntern			:= cTpIntern
			::MatGuia:SCabGui:RegInter			:= Iif(lInc,aRetorno[3,49],'')
			::MatGuia:SCabGui:QtdDSol			:= Iif(lInc,AllTrim(Str(aRetorno[3,50])),'0')
			::MatGuia:SCabGui:TipDoe			:= Iif(lInc,aRetorno[3,51],'')
			::MatGuia:SCabGui:TmpDoe			:= Iif(lInc,aRetorno[3,52],'')
			::MatGuia:SCabGui:UndDoe			:= Iif(lInc,aRetorno[3,53],'')
			::MatGuia:SCabGui:IndAcid			:= Iif(lInc,aRetorno[3,54],'')
			::MatGuia:SCabGui:Cid2				:= Iif(lInc,aRetorno[3,55],'')
			::MatGuia:SCabGui:Cid3				:= Iif(lInc,aRetorno[3,56],'')
			::MatGuia:SCabGui:Cid4				:= Iif(lInc,aRetorno[3,57],'')
			::MatGuia:SCabGui:DPrAH			    := Iif(lInc,aRetorno[3,58],CToD(""))
			::MatGuia:SCabGui:QtdDAut			:= Iif(lInc,AllTrim(Str(aRetorno[3,59])),'0')
			::MatGuia:SCabGui:TpAcom			:= cTpAcom
			::MatGuia:SCabGui:PadCon			:= Iif(lInc,aRetorno[3,61],'')
			::MatGuia:SCabGui:CnpjSolT			:= Iif(lInc,aRetorno[3,62],'')
			::MatGuia:SCabGui:NomeSolT			:= Iif(lInc,AllTrim(aRetorno[3,63]),'')
			::MatGuia:SCabGui:CnesSolT			:= Iif(lInc,aRetorno[3,64],'')
			::MatGuia:SCabGui:DesAcom			:= Iif(lInc,aRetorno[3,65],'')
			::MatGuia:SCabGui:RdaSolT			:= Iif(lInc,aRetorno[3,66],'')
			::MatGuia:SCabGui:ProfSolT			:= Iif(lInc,aRetorno[3,67],'')
			::MatGuia:SCabGui:OpeSolT			:= Iif(lInc,aRetorno[3,68],'')
			::MatGuia:SCabGui:DatInt			:= Iif(lInc,aRetorno[3,69],Date())
			::MatGuia:SCabGui:DatAlt			:= Iif(lInc,aRetorno[3,70],CToD(""))
			::MatGuia:SCabGui:HorAlt			:= Iif(lInc,aRetorno[3,71],'')
			::MatGuia:SCabGui:Cancel			:= Iif(lInc,aRetorno[3,72],'')
			::MatGuia:SCabGui:DesSTAut			:= Iif(lInc,aRetorno[3,73],'')
			::MatGuia:SCabGui:FindEvo			:= Iif(lInc,aRetorno[3,74],'')
			::MatGuia:SCabGui:NomPla			:= Iif(lInc,aRetorno[3,75],'')
			::MatGuia:SCabGui:DtVldCar			:= Iif(lInc,aRetorno[3,76],CToD(""))
			::MatGuia:SCabGui:CarSaud			:= Iif(lInc,aRetorno[3,77],'')
			::MatGuia:SCabGui:GrPar				:= Iif( Len(aRetorno[3]) >= 79 ,aRetorno[3,79],'')
			::MatGuia:SCabGui:QtdDPro			:= Iif( Len(aRetorno[3]) >= 80 ,Iif(lInc,AllTrim(Str(aRetorno[3,80])),'0'),'0')

			If Empty(aRetorno[3,69]) .And. ::SetDtInt == "0"//Liberacao sem data de internacao, somente na execucao/prorrogacao
				SetSoapFault( "","Liberação sem data de internação.")
				RestArea(aArea)
				Return .F.
			EndIf

			lCmp := ( Len( aRetorno[3] ) > 82 )

			::MatGuia:SCabGui:Peso			    := Iif(lInc .and. lCmp,aRetorno[3,82],'')
			::MatGuia:SCabGui:Altura			:= Iif(lInc .and. lCmp,aRetorno[3,83],'')
			::MatGuia:SCabGui:Idade				:= Iif(lInc .and. lCmp,aRetorno[3,84],'')
			::MatGuia:SCabGui:Sexo				:= Iif(lInc .and. lCmp,aRetorno[3,85],'')

			lCmp := ( Len( aRetorno[3] ) > 85 )
			::MatGuia:SCabGui:AteRN				:= Iif(lCmp,aRetorno[3,86],'')
			::MatGuia:SCabGui:IniFat			:= Iif(lCmp,aRetorno[3,87],cTod(''))
			::MatGuia:SCabGui:FimFat			:= Iif(lCmp,aRetorno[3,88],cTod(''))

			lIxs := ( Len( aRetorno[3] ) > 88 .and. Len(aRetorno[3]) <= 97)
			::MatGuia:SCabGui:AteRN				:= Iif(lIxs,aRetorno[3,91],::MatGuia:SCabGui:AteRN)//na internacao o rn vem na posicao 91
			::MatGuia:SCabGui:PrvOpm			:= Iif(lIxs,aRetorno[3,89],'')
			::MatGuia:SCabGui:PrvQui			:= Iif(lIxs,aRetorno[3,90],'')
			::MatGuia:SCabGui:Gralau			:= Iif(lIxs,aRetorno[3,IIF(Len(aRetorno[3]) > 97, 99, 95)],'')

			//Item
			::MatGuia:SIteGui := {}

			BTP->(DbSetOrder(1))
			BR8->(dbSetOrder(1))
			BAU->(dbSetOrder(1))
			BCT->(DbSetOrder(1))

			For nI := 1 To Len( aRetorno[4] )

				AaDd( ::MatGuia:SIteGui, WsClassNew( "MIteGui" ) )

				::MatGuia:SIteGui[nI]:TpServ 	:= aRetorno[4,nI,1]
				::MatGuia:SIteGui[nI]:Sequencia	:= aRetorno[4,nI,2]

				if BAU->BAU_CODIGO <> aRetorno[3,1]
					BAU->(msSeek(xFilial("BAU") + aRetorno[3,1]))
				endIf

				If cTissVer >= "3"

					cPadBkp := PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  aRetorno[4,nI,3],.T.)

					If BTP->(Msseek(xFilial("BTP")+cPadBkp)) .and. BTP->BTP_BUSDIR == "1"
						::MatGuia:SIteGui[nI]:CodPro 	:= PLSGETVINC("BTU_CDTERM", "BR8", .F., ::MatGuia:SIteGui[nI]:CodPad,  AllTrim(aRetorno[4,nI,4]), .F. ,aTabDup, @cPadBkp)
					else
						::MatGuia:SIteGui[nI]:CodPro 	:= PLSGETVINC("BTU_CDTERM", "BR8", .F., ::MatGuia:SIteGui[nI]:CodPad,  Alltrim(aRetorno[4,nI,3]+aRetorno[4,nI,4]), .F. ,aTabDup, @cPadBkp)
					EndIf

					::MatGuia:SIteGui[nI]:CodPad 	 := cPadBkp
					::MatGuia:SIteGui[nI]:DesPro 	 := PlDcCrcPrt( PLSGETVINC("BTQ_DESTER", "BR8", .F., ::MatGuia:SIteGui[nI]:CodPad,  Alltrim(aRetorno[4,nI,5])) )
					::MatGuia:SIteGui[nI]:CodPro_Ori := alltrim(aRetorno[4,nI,4])
					::MatGuia:SIteGui[nI]:CodPad_Ori := alltrim(aRetorno[4,nI,3])

				Else

					::MatGuia:SIteGui[nI]:CodPad 	:= aRetorno[4,nI,3]
					::MatGuia:SIteGui[nI]:CodPro 	:= aRetorno[4,nI,4]
					::MatGuia:SIteGui[nI]:DesPro 	:= PlDcCrcPrt( aRetorno[4,nI,5] )

				Endif

				::MatGuia:SIteGui[nI]:QtdSol 	:= aRetorno[4,nI,6]
				::MatGuia:SIteGui[nI]:QtdAut 	:= aRetorno[4,nI,7]
				::MatGuia:SIteGui[nI]:Fabric 	:= aRetorno[4,nI,8]
				::MatGuia:SIteGui[nI]:VlrApr 	:= aRetorno[4,nI,9]
				::MatGuia:SIteGui[nI]:Exibe	 	:= aRetorno[4,nI,10]
				::MatGuia:SIteGui[nI]:Dente	 	:= aRetorno[4,nI,18]
				::MatGuia:SIteGui[nI]:Face	 	:= aRetorno[4,nI,19]
				::MatGuia:SIteGui[nI]:QtdUs	 	:= IIF(::Tipo == "4",0,aRetorno[4,nI,20])
				::MatGuia:SIteGui[nI]:VlrCon	:= aRetorno[4,nI,21]
				::MatGuia:SIteGui[nI]:VlrTpf	:= IIF(::Tipo == "4",0,aRetorno[4,nI,22])
				::MatGuia:SIteGui[nI]:Autori	:= aRetorno[4,nI,23]
				::MatGuia:SIteGui[nI]:DtExe	 	:= aRetorno[4,nI,26]
				::MatGuia:SIteGui[nI]:Senha	 	:= aRetorno[4,nI,27]
				::MatGuia:SIteGui[nI]:ResAut 	:= IiF( Len(aRetorno[4,nI]) >= 28,aRetorno[4,nI,28],"")

				If (cTissVer >= '3')
					::MatGuia:SIteGui[nI]:GrPar 		:= IiF( Len(aRetorno[4,nI]) >= 29 .And. !Empty(aRetorno[4,nI,29]),PLSGETVINC("BTU_CDTERM", "BWT", .F., "35",  aRetorno[4,nI,29]),"")
					::MatGuia:SIteGui[nI]:ViaAc 		:= IiF( Len(aRetorno[4,nI]) >= 32 .And. !Empty(aRetorno[4,nI,32]),PLSGETVINC("BTU_CDTERM", "BGR", .F., "61",  aRetorno[4,nI,32]),"")
					::MatGuia:SIteGui[nI]:TecUt 		:= IiF( Len(aRetorno[4,nI]) >= 33 .And. !Empty(aRetorno[4,nI,33]),PLSGETVINC("BTU_CDTERM", "B0E", .F., "48",  aRetorno[4,nI,33]),"")
				Else
					::MatGuia:SIteGui[nI]:GrPar 		:= IiF( Len(aRetorno[4,nI]) >= 29,aRetorno[4,nI,29],"")
					::MatGuia:SIteGui[nI]:ViaAc 		:= IiF( Len(aRetorno[4,nI]) >= 32,aRetorno[4,nI,32],"")
					::MatGuia:SIteGui[nI]:TecUt 		:= IiF( Len(aRetorno[4,nI]) >= 33,aRetorno[4,nI,33],0)
				Endif

				::MatGuia:SIteGui[nI]:HorIni 	:= IiF( Len(aRetorno[4,nI]) >= 30,aRetorno[4,nI,30],"")
				::MatGuia:SIteGui[nI]:HorFim 	:= IiF( Len(aRetorno[4,nI]) >= 31,aRetorno[4,nI,31],"")
				::MatGuia:SIteGui[nI]:RedAcre 	:= IiF( Len(aRetorno[4,nI]) >= 34,aRetorno[4,nI,34],0)
				::MatGuia:SIteGui[nI]:VlrTAp 	:= IiF( Len(aRetorno[4,nI]) >= 35,aRetorno[4,nI,35],0)
				::MatGuia:SIteGui[nI]:Diagno 	:= IiF( Len(aRetorno[4,nI]) >= 36,aRetorno[4,nI,36],"")
				::MatGuia:SIteGui[nI]:Pacote 	:= "N"
				::MatGuia:SIteGui[nI]:TpModAdd 	:= "M"  //Indica se o procedimento esta sendo adicionado M - Manualmente ou A - Automaticamente pelo processo de pacotes.

				if BR8->( msSeek(xFilial("BR8") + aRetorno[4,nI,3] + aRetorno[4,nI,4] ) )

					nPosTpProc := iif( ! empty(BR8->BR8_TPPROC), aScan(aTpProcs, {|x| x[2] == BR8->BR8_TPPROC}),aScan(aTpProcs, {|x| x[2] == "0"}))

					if nPosTpProc > 0
						::MatGuia:SIteGui[nI]:TpProc := aTpProcs[nPosTpProc][2] + " - " + aTpProcs[nPosTpProc][3]//uso para carregar os campos de total na guia
					endIf

				endIf

			Next

			//Roberto - Verifica se os itens da liberação são pacotes, se sim, adicionam todos os sub-itens do pacote.
			if BAU->BAU_TISVER >= "3" .and. ::Tipo == '2' .and. lPLSEXPC

				aPacotes := StrTokArr(::Pacotes, "|")

				//Montando Array com todos os pacotes.
				For nP := 1 To Len( ::MatGuia:SIteGui )

					cCodPadc := ::MatGuia:SIteGui[nP]:CodPad_Ori
					cCodProc := ::MatGuia:SIteGui[nP]:CodPro_Ori

					cSQL := " SELECT BLE_CPADOC, BLE_CODPRO, BLE_CODPAD, BLE_CODOPC "
					cSQL += "   FROM " + cNameBLE
					cSQL += "  WHERE BLE_FILIAL = '" + cFilialBLE + "' "
					cSQL += "    AND BLE_CODINT = '" + cCodInt + "' "
					cSQL += "    AND BLE_CODPAD = '" + cCodPadc + "' "
					cSQL += "    AND BLE_CODPRO = '" + cCodProc + "' "
					cSQL += "    AND BLE_TIPO = '9' "
					cSQL += "    AND ( BLE_VIGDE <= '" + dtos(dDataBase) + "' AND "
					cSQL += "        ( BLE_VIGATE = '' OR '" + dtos(dDataBase) + "' <= BLE_VIGATE ) ) "
					cSQL += "    AND D_E_L_E_T_ = '' "

					dbUseArea(.T.,"TOPCONN",TcGenQry(,,ChangeQuery(cSQL)),"TRBBLE",.T.,.F.)

					if ! TRBBLE->(eof())

						while !TRBBLE->(eof())

							if ! PPLSEXIS(::MatGuia:SIteGui, TRBBLE->BLE_CODOPC)

								aadd(::MatGuia:SIteGui, WsClassNew( "MIteGui" ) )
								nTamanho := len(::MatGuia:SIteGui)

								::MatGuia:SIteGui[nP]:Pacote 	:= "S"
								::MatGuia:SIteGui[nTamanho] 	:= PPLSPCTM(::MatGuia:SIteGui[nP], "I", aTabDup, PPLSPCTSEQ(::MatGuia))

								cPadBkp := PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  TRBBLE->BLE_CODPAD,.T.)

								::MatGuia:SIteGui[nTamanho]:CodPro 		:= PLSGETVINC("BTU_CDTERM", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim( TRBBLE->(BLE_CODPAD + BLE_CODOPC) ), .F. ,aTabDup, @cPadBkp)
								::MatGuia:SIteGui[nTamanho]:CodPad 		:= PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  TRBBLE->BLE_CODPAD,.T.)
								::MatGuia:SIteGui[nTamanho]:DesPro 		:= PlDcCrcPrt( PLSGETVINC("BTQ_DESTER", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim( TRBBLE->(BLE_CODPAD + BLE_CODOPC) ) ) )
								::MatGuia:SIteGui[nTamanho]:CodPro_Ori 	:= TRBBLE->BLE_CODOPC;

								if BR8->( msSeek(xFilial("BR8") + TRBBLE->BLE_CODPAD + TRBBLE->BLE_CODPRO ) )

									nPosTpProc := iif( ! empty(BR8->BR8_TPPROC), aScan(aTpProcs, {|x| x[2] == BR8->BR8_TPPROC}),aScan(aTpProcs, {|x| x[2] == "0"}))

									if nPosTpProc > 0
										::MatGuia:SIteGui[nTamanho]:TpProc := aTpProcs[nPosTpProc][2] + " - " + aTpProcs[nPosTpProc][3]//uso para carregar os campos de total na guia
									endIf

								endIf

							endIf

							TRBBLE->(DbSkip())
						enddo

						TRBBLE->( dbCloseArea() )

					else

						TRBBLE->( dbCloseArea() )

						for nPct := 1 to Len(aPacotes)

							aCampos := StrTokArr(aPacotes[nPct], ";")

							if len(aCampos[1]) > 8
								cCod := subStr(aCampos[1], 3,  len(aCampos[1]))
							else
								cCod := aCampos[1]
							endif

							if ( cCod == ::MatGuia:SIteGui[nP]:CodPro_Ori )

								cSQL := " SELECT BLE_CPADOC, BLE_CODPRO, BLE_CODPAD, BLE_CODOPC "
								cSQL += "   FROM " + cNameBLE
								cSQL += "  WHERE BLE_FILIAL = '" + cFilialBLE + "' "
								cSQL += "    AND BLE_CODINT = '" + cCodInt + "' "
								cSQL += "    AND BLE_CODPAD = '" + ::MatGuia:SIteGui[nP]:CodPad_Ori + "' "
								cSQL += "    AND BLE_CODPRO = '" + alltrim(aCampos[2]) + "' "
								cSQL += "    AND BLE_TIPO = '9' "
								cSQL += "    AND ( BLE_VIGDE <= '" + dtos(dDataBase) + "' AND "
								cSQL += "        ( BLE_VIGATE = '' OR '" + dtos(dDataBase) + "' <= BLE_VIGATE ) ) "
								cSQL += "    AND D_E_L_E_T_ = '' "

								dbUseArea(.T.,"TOPCONN",TcGenQry(,,ChangeQuery(cSQL)),"TRBBLE",.T.,.F.)

								if ! TRBBLE->(eof())

									//Adicionando o Pacote
									if ! PPLSEXIS(::MatGuia:SIteGui, /*cCodProcedimento*/TRBBLE->BLE_CODPRO)

										AADD(::MatGuia:SIteGui, WsClassNew( "MIteGui" ) )
										nTamanho := len(::MatGuia:SIteGui)

										::MatGuia:SIteGui[nTamanho] := PPLSPCTM(::MatGuia:SIteGui[nP], "I", aTabDup, PPLSPCTSEQ(::MatGuia))

										cPadBkp := PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  TRBBLE->BLE_CODPAD,.T.)

										::MatGuia:SIteGui[nTamanho]:CodPro 		:= PLSGETVINC("BTU_CDTERM", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim( TRBBLE->( BLE_CODPAD + BLE_CODPRO ) ), .F. ,aTabDup, @cPadBkp)
										::MatGuia:SIteGui[nTamanho]:CodPad 		:= PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  TRBBLE->BLE_CODPAD,.T.)
										::MatGuia:SIteGui[nTamanho]:DesPro 		:= PlDcCrcPrt( PLSGETVINC("BTQ_DESTER", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim( TRBBLE->( BLE_CODPAD + BLE_CODPRO ) ) ) )
										::MatGuia:SIteGui[nTamanho]:CodPro_Ori 	:= TRBBLE->BLE_CODPRO

										if BR8->( msSeek(xFilial("BR8") + TRBBLE->BLE_CODPAD + TRBBLE->BLE_CODPRO ) )

											nPosTpProc := iif( ! empty(BR8->BR8_TPPROC), aScan(aTpProcs, {|x| x[2] == BR8->BR8_TPPROC}),aScan(aTpProcs, {|x| x[2] == "0"}))

											if nPosTpProc > 0
												::MatGuia:SIteGui[nTamanho]:TpProc := aTpProcs[nPosTpProc][2] + " - " + aTpProcs[nPosTpProc][3]//uso para carregar os campos de total na guia
											endIf

										endIf

									endIf

								endIf

								while ! TRBBLE->(eof())

									if ! PPLSEXIS(::MatGuia:SIteGui, TRBBLE->BLE_CODOPC)

										AADD(::MatGuia:SIteGui, WsClassNew( "MIteGui" ) )
										nTamanho := len(::MatGuia:SIteGui)

										::MatGuia:SIteGui[nTamanho] := PPLSPCTM(::MatGuia:SIteGui[nP], "I", aTabDup, PPLSPCTSEQ(::MatGuia))

										cPadBkp := PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  TRBBLE->BLE_CODPAD,.T.)

										::MatGuia:SIteGui[nTamanho]:CodPro 		:= PLSGETVINC("BTU_CDTERM", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim( TRBBLE->(BLE_CODPAD + BLE_CODOPC) ), .F. ,aTabDup, @cPadBkp)
										::MatGuia:SIteGui[nTamanho]:CodPad 		:= PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  TRBBLE->BLE_CODPAD,.T.)
										::MatGuia:SIteGui[nTamanho]:DesPro 		:= PlDcCrcPrt( PLSGETVINC("BTQ_DESTER", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim( TRBBLE->(BLE_CODPAD + BLE_CODOPC) ) ) )
										::MatGuia:SIteGui[nTamanho]:CodPro_Ori 	:= TRBBLE->BLE_CODOPC

										if BR8->( msSeek(xFilial("BR8") + TRBBLE->BLE_CODPAD + TRBBLE->BLE_CODOPC ) )

											nPosTpProc := iif( ! empty(BR8->BR8_TPPROC), aScan(aTpProcs, {|x| x[2] == BR8->BR8_TPPROC}),aScan(aTpProcs, {|x| x[2] == "0"}))

											if nPosTpProc > 0
												::MatGuia:SIteGui[nTamanho]:TpProc := aTpProcs[nPosTpProc][2] + " - " + aTpProcs[nPosTpProc][3]//uso para carregar os campos de total na guia
											endIf

										endIf

									endif

									TRBBLE->(DbSkip())
								enddo

								TRBBLE->( dbCloseArea() )

							endIf

						next

					endIf

				Next

			endif

			If ::Tipo == '5' .AND. cTissVer >= "3"

				//Item
				::MatGuia:SExeGui := {}

				For nI := 1 To Len( aRetorno[6] )

					AaDd( ::MatGuia:SExeGui, WsClassNew( "MExeGui" ) )

					::MatGuia:SExeGui[nI]:Sequen 	:= aRetorno[6,nI,1]
					::MatGuia:SExeGui[nI]:GrPar		:= PLSGETVINC("BTU_CDTERM", "BWT", .F., "35", ALLTRIM(aRetorno[6,nI,2]))
					::MatGuia:SExeGui[nI]:CpfExe 	:= aRetorno[6,nI,3]
					::MatGuia:SExeGui[nI]:NomExe 	:= aRetorno[6,nI,4]
					::MatGuia:SExeGui[nI]:ConReg 	:= aRetorno[6,nI,5]
					::MatGuia:SExeGui[nI]:NumCr 	:= aRetorno[6,nI,6]
					::MatGuia:SExeGui[nI]:UfCr 		:= aRetorno[6,nI,7]
					::MatGuia:SExeGui[nI]:Cbo	 	:= PLSGETVINC("BTU_CDTERM", "BAQ", .F., "24", ALLTRIM(aRetorno[6,nI,8]))
				Next

			EndIf

			//Critica de Itens
			::MatGuia:SCriGui := {}

			For nI := 1 To Len( aRetorno[5] )

				AaDd( ::MatGuia:SCriGui, WsClassNew( "AutErrorView" ) )

				::MatGuia:SCriGui[nI]:Sequence 	:= aRetorno[5,nI,1]

				If !Empty(AllTrim(aRetorno[5,nI,1]))  .And. !Empty(AllTrim(aRetorno[5,nI,2]))

					aRet := PLSRETCRI( AllTrim( aRetorno[5,nI,1] ))

					If len(aRetorno[5][nI]) >= 7

						If empty(aRet[1][2])
							aRet[1][1] := "[" + alltrim(aRetorno[5][nI][7]) + "] " + aRetorno[5][nI][2]
							aRet[1][2] := alltrim(aRetorno[5][nI][3])
						Else
							aRet[1][1] := "[" + alltrim(aRetorno[5][nI][7]) + "] " + aRet[1][1]
						EndIf

					Else

						If ! Empty( AllTrim(aRetorno[5,nI,2]) )

							aRet := PLSRETCRI( AllTrim( aRetorno[5,nI,2] ) )

							If EMPTY(aRet[1][2])
								aRet[1][1] := aRetorno[5][nI][2]
								aRet[1][2] := aRetorno[5][nI][3]
							EndIf
						Else
							aRet := {}
							AaDd( aRet, {"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" , AllTrim( aRetorno[5,nI,3] ) })
						EndIf

					EndIf

					If ::Reimpressao == "1"
						If BCT->(MsSeek(xFilial("BCT")+cCodInt+aRetorno[5][nI][2]))
							aRet[1][1]  := BCT->BCT_GLTISS
							aRet[1][2]  := BCT->BCT_DESTIS
						EndIf
					EndIf

				Else
					aRet := {}
					AaDd( aRet, {"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" , AllTrim( aRetorno[5,nI,3] ) })
				EndIf

				::MatGuia:SCriGui[nI]:Code			:= AllTrim( aRet[1,1] )
				::MatGuia:SCriGui[nI]:Description 	:= PadR( AllTrim(aRet[1,2]),70 )

			Next

			//³Critica Genericas
			If Len(aRetorno) > 5 .AND. ::Tipo <> '5'

				::MatGuia:MatCri := {}

				For nI := 1 To Len( aRetorno[6] )
					AaDd( ::MatGuia:MatCri, WsClassNew( "GenericStruct" ) )
					::MatGuia:MatCri[nI]:Code			:= aRetorno[6,nI,1]
					::MatGuia:MatCri[nI]:Description	:= aRetorno[6,nI,2]
				Next

			EndIf

		ElseIf ! Empty(aRetorno[2])

			lRetorno := .F.
			SetSoapFault( "", aRetorno[2] )

		Else

			lRetorno := .F.

			If Len(aRetorno[5]) >= 1

				If Len(aRetorno[6]) >= 1

					cMsgAux	:= "Liberação não pode ser executada ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" + Chr(13)+Chr(10) + Chr(13)+Chr(10)

					For nI := 1 To Len( aRetorno[6] )
						cMsgAux += aRetorno[6,nI,1] +" - "+ aRetorno[6,nI,2] + Chr(13)+Chr(10)
					Next

					SetSoapFault( "", cMsgAux )

				Else
					SetSoapFault( "", "Liberação não pode ser executada ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
				EndIf

			Else

				If Len(aRetorno) >= 8

					BE2->(dbsetOrder(1))
					If BE2->( msSeek(xFilial("BE2") + aRetorno[8]) )

						If BE2->BE2_STATUS == "0" .and. BE2->BE2_AUDITO == "1"

							SetSoapFault( "", "Guia encontra-se em Auditoria e não pode ser executada. ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )

						Elseif BEA->BEA_STATUS == "5"

							SetSoapFault( "", "Guia contém título a receber e não pode ser executada. ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
						Else
							lRetorno:= .T.
						Endif

					Else

						SetSoapFault( "", "Nenhuma guia encontrada ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )

					Endif

				Else

					If ::Tipo == '3' .or. ::Tipo == '6'

						If BEA->(MsSeek(xFilial("BEA")+::NumAut)) .And. BEA->BEA_TIPO <> ::Tipo
							SetSoapFault( "", "Guia informada não é uma guia de solicitação de internação ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
						Else
							SetSoapFault( "", "Nenhuma guia encontrada ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
						EndIf

					Elseif ::Tipo == '5'

						SetSoapFault( "", "Nenhuma guia encontrada ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )

					Elseif ::Tipo $ '7,8,9,11'

						If EmpTy(aRetorno[2])
							SetSoapFault( "", "Guia nao encontrada ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
						else
							SetSoapFault( "", aRetorno[2] + " ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
						EndIf

					Endif

				EndIf

			Endif

		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

static Function PPLSPCTSEQ(aMatGuia)

	local nSequencia := 0
	local nS

	For nS := 1 To Len( aMatGuia:SIteGui )
		if aMatGuia:SIteGui[nS]:Sequencia <> NIL
			if nSequencia < val(aMatGuia:SIteGui[nS]:Sequencia)
				nSequencia := val(aMatGuia:SIteGui[nS]:Sequencia)
			endif
		endif
	next

return CVALTOCHAR(nSequencia + 1)


static Function PPLSPCTM(oMatGuia, cTipo, aTabDup, cSeq)

	local SIteGuiPct := WsClassNew("MIteGui")

	SIteGuiPct:TpServ 		:= oMatGuia:TpServ
	SIteGuiPct:Sequencia		:= cSeq//oMatGuia:Sequencia
	SIteGuiPct:QtdSol			:= oMatGuia:QtdSol
	SIteGuiPct:QtdAut 	 	:= oMatGuia:QtdAut
	SIteGuiPct:Exibe	 	 	:= oMatGuia:Exibe
	SIteGuiPct:Autori	 		:= oMatGuia:Autori
	SIteGuiPct:DtExe	 		:= oMatGuia:DtExe
	SIteGuiPct:Senha	 		:= oMatGuia:Senha
	SIteGuiPct:ResAut 	 	:= oMatGuia:ResAut
	SIteGuiPct:GrPar 	 		:= oMatGuia:GrPar
	SIteGuiPct:HorIni 	 	:= oMatGuia:HorIni
	SIteGuiPct:HorFim 	 	:= oMatGuia:HorFim


	SIteGuiPct:Fabric 		:= oMatGuia:Fabric
	SIteGuiPct:VlrApr 		:= oMatGuia:VlrApr
	SIteGuiPct:Dente	 		:= oMatGuia:Dente
	SIteGuiPct:Face	 		:= oMatGuia:Face
	SIteGuiPct:QtdUs	 		:= oMatGuia:QtdUs
	SIteGuiPct:VlrCon			:= oMatGuia:VlrCon
	SIteGuiPct:VlrTpf			:= oMatGuia:VlrTpf
	SIteGuiPct:Autori			:= oMatGuia:Autori
	SIteGuiPct:DtExe	 		:= oMatGuia:DtExe
	SIteGuiPct:Senha	 		:= oMatGuia:Senha
	SIteGuiPct:ViaAc 			:= oMatGuia:ViaAc
	SIteGuiPct:TecUt 			:= oMatGuia:TecUt
	SIteGuiPct:RedAcre 		:= oMatGuia:RedAcre
	SIteGuiPct:VlrTAp 		:= oMatGuia:VlrTAp
	SIteGuiPct:Diagno 		:= oMatGuia:Diagno
	SIteGuiPct:Pacote 		:= cTipo

return SIteGuiPct


static Function PPLSEXIS(aArray, cCodigo)

	local vExiste := .F.
	local nI

	for  nI := 1  to len(aArray)
		if(alltrim(aArray[nI]:CodPro_Ori) = alltrim(cCodigo))
			vExiste := .T.
		endif
	next

return vExiste


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetAut    ³Autor  ³ Alexander	            ³ Data ³06.04.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna guias de um Usuário por prestador e data			   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetAut WSRECEIVE UserCode, UserCardNumber,RDACode,CodLoc,DtAut WSSEND MatAut WSSERVICE PLSXFUN
	LOCAL nI            := 1
	LOCAL lRetorno 		:= .T.
	LOCAL aRet	 		:= {}
	LOCAL aArea			:= GetArea()
	LOCAL cMatric		:= ""
	LOCAL cSQL			:= ""

	BQV->(dbSetOrder(1))

	If PrtChkUser( ::UserCode, "PLSXFUN", "RetAut" ) //consome uma licença, checa integridade d acesso

		//////////////////////////////////////////////////////////////////////
		//Verifica se e Usuário de intercambio e pega a matricula original
		//////////////////////////////////////////////////////////////////////
		cMatric := PPLTROMAT(::UserCardNumber)

		//////////////////////////////////////////////////////////////////////
		//Monta query para pegar as autorizações do usuario + rda
		//////////////////////////////////////////////////////////////////////
		cSQL := " SELECT BEA_OPEMOV,BEA_ANOAUT,BEA_MESAUT,BEA_NUMAUT,BEA_OPEINT, "
		cSQL += " BEA_TIPO,BEA_DTDIGI,BEA_HORPRO,BEA_STATUS, BEA_SENHA "
		cSQL += " FROM " + RetSQLName("BEA")
		cSQL += " WHERE BEA_FILIAL = '" + xFilial("BEA") +"' "
		cSQL += "   AND BEA_OPEUSR = '" + SubStr(cMatric,1,4) +"' "
		cSQL += "   AND BEA_CODEMP = '" + SubStr(cMatric,5,4) +"' "
		cSQL += "   AND BEA_MATRIC = '" + SubStr(cMatric,9,6) +"' "
		cSQL += "   AND BEA_TIPREG = '" + SubStr(cMatric,15,2) +"' "
		cSQL += "   AND BEA_DIGITO = '" + SubStr(cMatric,17,1) +"' "
		cSQL += "   AND BEA_CODRDA = '" + ::RDACode +"'  "
		cSQL += "   AND BEA_TIPO  <> '3' "

		If !EMPTY(::DtAut)
			cSQL += "    AND BEA_DTDIGI = '" + DtoS(::DtAut) +"' "
		EndIf

		cSQL += "    AND BEA_CODLOC = '" + ::CodLoc +"' "
		cSQL += "    AND D_E_L_E_T_ <> '*' "
		cSQL += "    AND BEA_STATUS <> '5' "
		cSQL += " ORDER BY BEA_DATPRO "

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,ChangeQuery(cSQL)),"TRBRETAUT",.T.,.F.)

		While !TrbRetAut->( Eof() )

			AaDd(aRet,{	TrbRetAut->(BEA_OPEMOV+BEA_ANOAUT+BEA_MESAUT+BEA_NUMAUT),;  									//Numero da autorizacao consult/sadt
				"",;
				Iif(TrbRetAut->BEA_TIPO=="1","CONSULTA",Iif(TrbRetAut->BEA_TIPO=="2","SADT","ODONTOLOGICO"  ) ),; //Tipo de guia
				TrbRetAut->BEA_DTDIGI,;									 										//Data da autorizacao
				TrbRetAut->BEA_HORPRO,;																			//Hora da autorizacao
				TrbRetAut->BEA_TIPO  ,;																			 //Tipo Guia
				TrbRetAut->BEA_STATUS,;
				TrbRetAut->BEA_SENHA})									 									    //Status Guia

			TrbRetAut->( DbSkip() )
		EndDo

		TrbRetAut->( DbCloseArea() )

		//////////////////////////////////////////////////////////////////////
		//Monta query para pegar as autorizações do usuario + rda
		//////////////////////////////////////////////////////////////////////
		cSQL := " SELECT B4A_OPEMOV,B4A_ANOAUT,B4A_MESAUT,B4A_NUMAUT,B4A_DATSOL,B4A_TIPGUI ,B4A_STATUS, B4A_SENHA"
		cSQL += "   FROM " + RetSQLName("B4A") + " B4A "
		cSQL += "  INNER JOIN " + RetSQLName("BEA") + " BEA "
		cSQL += "  ON BEA_FILIAL = '" + xFilial("BEA") + "' "
		cSQL += "    AND BEA_OPEMOV || BEA_ANOAUT || BEA_MESAUT || BEA_NUMAUT = B4A_GUIREF "
		cSQL += "  WHERE B4A_FILIAL = '" + xFilial("B4A") +"' "
		cSQL += "    AND B4A_OPEUSR = '" + SubStr(cMatric,1,4) +"' "
		cSQL += "    AND B4A_CODEMP = '" + SubStr(cMatric,5,4) +"' "
		cSQL += "    AND B4A_MATRIC = '" + SubStr(cMatric,9,6) +"' "
		cSQL += "    AND B4A_TIPREG = '" + SubStr(cMatric,15,2) +"' "
		cSQL += "    AND B4A_DIGITO = '" + SubStr(cMatric,17,1) +"' "
		cSQL += "    AND BEA_CODRDA = '" + ::RDACode + "' "
		cSQL += "    AND BEA_CODLOC = '" + ::CodLoc + "' "

		If !EMPTY(::DtAut)
			cSQL += "    AND B4A_DATSOL = '" + DtoS(::DtAut) +"' "
		EndIf

		cSQL += "    AND B4A.D_E_L_E_T_ <> '*' "
		cSQL += "    AND BEA.D_E_L_E_T_ <> '*' "
		cSQL += " ORDER BY B4A_DATSOL "

		cSQL := ChangeQuery(cSQL)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TRBRETAUT",.T.,.F.)

		While !TrbRetAut->( Eof() )

			AaDd(aRet,{	TrbRetAut->(B4A_OPEMOV+B4A_ANOAUT+B4A_MESAUT+B4A_NUMAUT),;	//Numero da autorizacao consult/sadt
				'',; 														//Numero da autorizacao de internacao
				IF(TrbRetAut->B4A_TIPGUI=='09','ANEXO OPME',If(TrbRetAut->B4A_TIPGUI=='07','ANEXO QUIMIOTERAPIA','ANEXO RADIOTERAPIA')),; 				//Tipo de guia
				TrbRetAut->B4A_DATSOL,;										//Data da autorizacao
				'',;														//Hora da autorizacao
				alltrim(str(VAL(TrbRetAut->B4A_TIPGUI))),;
				TrbRetAut->B4A_STATUS,;
				TrbRetAut->B4A_SENHA } )									//Tipo Guia

			TrbRetAut->( DbSkip() )
		EndDo

		TrbRetAut->( DbCloseArea() )

		//////////////////////////////////////////////////////////////////////
		//Monta query para pegar as autorizações do usuario + rda
		//////////////////////////////////////////////////////////////////////
		cSQL := " SELECT B4Q_OPEMOV,B4Q_ANOAUT,B4Q_MESAUT,B4Q_NUMAUT,B4Q_DATSOL, B4Q_STATUS, B4Q_SENHA "
		cSQL += "   FROM " + RetSQLName("B4Q") + " B4Q "

		cSQL += "  INNER JOIN " + RetSQLName("BE4") + " BE4 "
		cSQL += "  ON BE4_FILIAL = '" + xFilial("BE4") + "' "
		cSQL += "    AND BE4_CODOPE || BE4_ANOINT || BE4_MESINT || BE4_NUMINT = B4Q_GUIREF "

		cSQL += "  WHERE B4Q_FILIAL = '" + xFilial("B4Q") +"' "
		cSQL += "    AND B4Q_OPEUSR = '" + SubStr(cMatric,1,4) +"' "
		cSQL += "    AND B4Q_CODEMP = '" + SubStr(cMatric,5,4) +"' "
		cSQL += "    AND B4Q_MATRIC = '" + SubStr(cMatric,9,6) +"' "
		cSQL += "    AND B4Q_TIPREG = '" + SubStr(cMatric,15,2) +"' "
		cSQL += "    AND B4Q_DIGITO = '" + SubStr(cMatric,17,1) +"' "
		cSQL += "    AND B4Q_CODRDA = '" + ::RDACode +"' "
		cSQL += "    AND BE4_CODRDA = '" + ::RDACode + "' "
		cSQL += "    AND BE4_CODLOC = '" + ::CodLoc + "' "

		If !EMPTY(::DtAut)
			cSQL += "    AND B4Q_DATSOL = '" + DtoS(::DtAut) +"' "
		EndIf

		cSQL += "    AND B4Q.D_E_L_E_T_ <> '*' "
		cSQL += "    AND BE4.D_E_L_E_T_ <> '*' "

		cSQL += " ORDER BY B4Q_DATSOL "

		cSQL := ChangeQuery(cSQL)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TRBRETAUT",.T.,.F.)

		While !TrbRetAut->( Eof() )

			AaDd(aRet,{	TrbRetAut->(B4Q_OPEMOV+B4Q_ANOAUT+B4Q_MESAUT+B4Q_NUMAUT),;	//Numero da autorizacao consult/sadt
				'',; 														//Numero da autorizacao de internacao
				"PRORROGAÇÃO INTERNAÇÃO",; 									//Tipo de guia
				TrbRetAut->B4Q_DATSOL,;										//Data da autorizacao
				'',;														//Hora da autorizacao
				'11',;
				TrbRetAut->B4Q_STATUS,;
				TrbRetAut->B4Q_SENHA})										//Tipo Guia

			TrbRetAut->( DbSkip() )
		EndDo

		TrbRetAut->( DbCloseArea() )

		//////////////////////////////////////////////////////////////////////
		//Monta query para pegar as autorizações do usuario + rda
		//////////////////////////////////////////////////////////////////////
		cSQL := " SELECT BE4_CODOPE,BE4_ANOINT,BE4_MESINT,BE4_NUMINT,BE4_DTDIGI,BE4_HORPRO,BE4_STATUS, BE4_SENHA"
		cSQL += " FROM " + RetSQLName("BE4")
		cSQL += " WHERE BE4_FILIAL = '" + xFilial("BE4") +"' "
		cSQL += "   AND BE4_OPEUSR = '" + SubStr(cMatric,1,4) +"' "
		cSQL += "   AND BE4_CODEMP = '" + SubStr(cMatric,5,4) +"' "
		cSQL += "   AND BE4_MATRIC = '" + SubStr(cMatric,9,6) +"' "
		cSQL += "   AND BE4_TIPREG = '" + SubStr(cMatric,15,2) +"' "
		cSQL += "   AND BE4_DIGITO = '" + SubStr(cMatric,17,1) +"' "
		cSQL += "   AND BE4_CODRDA = '" + ::RDACode +"' "
		cSQL += "   AND BE4_CODLOC = '" + ::CodLoc +"' "

		If !EMPTY(::DtAut)
			cSQL += "    AND BE4_DTDIGI = '" + DtoS(::DtAut) +"' "
		EndIf

		cSQL += "    AND D_E_L_E_T_ <> '*' "
		cSQL += " ORDER BY BE4_DATPRO "

		cSQL := ChangeQuery(cSQL)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TRBRETAUT",.T.,.F.)

		While !TrbRetAut->( Eof() )

			AaDd(aRet,{	TrbRetAut->(BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT),;	//Numero da autorizacao consult/sadt
				TrbRetAut->(BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT),; 	//Numero da autorizacao de internacao
				"INTERNAÇÃO",; 												//Tipo de guia
				TrbRetAut->BE4_DTDIGI,;										//Data da autorizacao
				TrbRetAut->BE4_HORPRO,;										//Hora da autorizacao
				"3",;														//Tipo Guia
				TrbRetAut->BE4_STATUS,;
				TrbRetAut->BE4_SENHA})										//Tipo Guia

			TrbRetAut->( DbSkip() )
		EndDo

		TrbRetAut->( DbCloseArea() )

		//////////////////////////////////////////////////////////////////////
		//Guias
		//////////////////////////////////////////////////////////////////////
		If Len(aRet) > 0

			::MatAut := {}

			For nI := 1 To Len( aRet )
				AaDd( ::MatAut, WsClassNew( "SMatAut" ) )
				::MatAut[nI]:NumeAut 	:= aRet[nI,1]
				::MatAut[nI]:NumeInt 	:= aRet[nI,2]
				::MatAut[nI]:TipoTran 	:= aRet[nI,3]
				::MatAut[nI]:DtAut 		:= STOD(aRet[nI,4])
				::MatAut[nI]:HrAut 		:= aRet[nI,5]
				::MatAut[nI]:Tp 			:= aRet[nI,6]

				If Len(aRet[nI]) >= 7
					::MatAut[nI]:TpStatus	:= aRet[nI,7]
				EndIf

				::MatAut[nI]:Prorrog		:= cvaltochar( IIF(B4Q->(dbSeek(xFilial('B4Q')+::MatAut[nI]:NumeAut)), .F., (BQV->(dbSeek(xFilial('BQV')+::MatAut[nI]:NumeAut))) ) )
				::MatAut[nI]:Status		:= PlsStatGui( aRet[nI,7], IIf("ANEXO"$aRet[nI,3], "B4A", "BEA"  )  )
				::MatAut[nI]:Senha		:= aRet[nI,8]

				//////////////////////////////////////////////////////////////////////
				//Necessário a alteração para a impressão somentes quando há guias em auditoria que tenha pelo menos (1)uma autorizadas
				If ::MatAut[nI]:Tp = "2" .and. ::MatAut[nI]:TpStatus = "6" .and. PLIBAUD(aRet[nI,1])
					::MatAut[nI]:TpStatus := "2"
				EndIf
			Next
		Else
			lRetorno := .F.
			SetSoapFault( "", "Nenhuma guia encontrada para o Usuário ( "+Iif( Len(::UserCardNumber)>16 ,Transform(::UserCardNumber, "@R 9999.9999.999999.99-9" ),Transform(::UserCardNumber, "@R 999.9999.999999.99-9" ) )+" )" )
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	BQV->(dbCloseArea())

	RestArea( aArea )

Return lRetorno
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³ PreAte   ³ Autor ³ Alexander Santos	     ³ Data ³ 2.05.07  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Inclusao do pre-atendimento								   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PreAte WSRECEIVE UserCode, MatPre WSSEND RetMatPre WSSERVICE PLSXFUN
	LOCAL nI        	:= 1
	LOCAL lRetorno 		:= .T.
	LOCAL aMat 			:= {}
	LOCAL aRet 			:= {}
	LOCAL aArea			:= GetArea()

	//Checa Usuário
	If PrtChkUser( ::UserCode, "PLSXFUN", "PreAte" )

		//³Matriz  com dados do pre atendimento
		AaDd(aMat,MatPre:Matric)	//Matricula
		AaDd(aMat,MatPre:CodUsr)	//Codigo de Usuário web
		AaDd(aMat,MatPre:NomeUsu)	//Nome do Usuário
		AaDd(aMat,MatPre:OpeRda)	//Operadora da rda
		AaDd(aMat,MatPre:CodRda)	//Codigo da rda
		AaDd(aMat,MatPre:NomRda)	//Nome da rda
		AaDd(aMat,MatPre:CodLoc)	//LOCAL de atendimento
		AaDd(aMat,MatPre:Trilha)	//Trilha do Cartao
		AaDd(aMat,MatPre:CodRdaOld) // codigo da RDA antes da alteração
		AaDd(aMat,MatPre:CodLocOld) // codigo do local antes da alteração

		//gravacao ou atualizacao do pre atendimento retorna todos os Usuários
		aRet := PLVLDPRE(aMat,MatPre:TpAca, MatPre:OrdResult)

		//Guias
		::RetMatPre := {}

		For nI := 1 To Len( aRet[2] )

			AaDd(::RetMatPre, WsClassNew( "SRetMatPre" ) )

			::RetMatPre[nI]:Msg		:= aRet[1]
			::RetMatPre[nI]:Matric	:= aRet[2,nI,1]
			::RetMatPre[nI]:NomeUsu	:= aRet[2,nI,2]
			::RetMatPre[nI]:Rda		:= aRet[2,nI,3]
			::RetMatPre[nI]:NomeRda 	:= aRet[2,nI,4]
			::RetMatPre[nI]:CodLoc	:= aRet[2,nI,5]
			::RetMatPre[nI]:DatChe 	:= aRet[2,nI,6]
			::RetMatPre[nI]:HorChe 	:= aRet[2,nI,7]

		Next

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³ StatusGuia       ³ Autor ³ Alexander Santos	³ Data ³ 29.05.07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Status de uma Autorizacao								   	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
WSMETHOD StatusGuia WSRECEIVE UserCode, NumAut ,TipoAut WSSEND MatComGui WSSERVICE PLSXFUN
	LOCAL nI,nY,nPos:= 0
	LOCAL lRetorno 	:= .T.
	LOCAL aRet 		:= {}
	LOCAL aCriticas	:= {}
	LOCAL aRetCri	:= {}
	LOCAL aRetBox	:= {}
	LOCAL aArea		:= GetArea()
	LOCAL cNomUsrP  := ""
	LOCAL cCodRdaP  := ""
	LOCAL cStatusP  := ""
	LOCAL cDatSolP  := ""
	LOCAL cCancelP	:= ""
	local cOnLine	:= "0"
	Local lPTUOn50  := alltrim(GetNewPar("MV_PTUVEON","35")) >= "50" .And. BEA->(FieldPos("BEA_CANEDI")) > 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Data com 4 digitos													   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Set Century On
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "StatusGuia" )

		If ::TipoAut != '3'

			SIX->( DbSetOrder(1) )
			If SIX->( MsSeek("BEAA") )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Posiciona no cabecalho               									   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				BEA->( DbSetOrder(1) )//BEA_FILIAL + BEA_OPEMOV + BEA_ANOAUT + BEA_MESAUT + BEA_NUMAUT
				If PlsAliasExi('B4A')
					B4A->( DbSetOrder(1) )
				Endif
				If PlsAliasExi('B4A') .and. B4A->( MsSeek(xFilial("B4A")+::NumAut) ) .And. B4A->B4A_TIPGUI == strzero(val(::TipoAut),2)
					cNomUsrP := B4A->B4A_NOMUSR
					cCodRdaP := space(6)
					cStatusP := B4A->B4A_STATUS
					cDatSolP := DToC(B4A->B4A_DATSOL)
					cCancelP := B4A->B4A_CANCEL
					cOnLine  := B4A->B4A_COMUNI

					B4C->( DbSetOrder(1) )//BE2_FILIAL + BE2_OPEMOV + BE2_ANOAUT + BE2_MESAUT + BE2_NUMAUT + BE2_SEQUEN
					BEG->( DbSetOrder(1) )//BEG_FILIAL + BEG_OPEMOV + BEG_ANOAUT + BEG_MESAUT + BEG_NUMAUT + BEG_SEQUEN
					If B4C->( MsSeek(xFilial("B4C")+B4A->(B4A_OPEMOV+B4A_ANOAUT+B4A_MESAUT+B4A_NUMAUT)) )
						While ! B4C->( Eof() ) .And. B4C->(B4C_FILIAL+B4C_OPEMOV+B4C_ANOAUT+B4C_MESAUT+B4C_NUMAUT) == ;
								xFilial("B4C")+B4A->(B4A_OPEMOV+B4A_ANOAUT+B4A_MESAUT+B4A_NUMAUT)
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Critica de Itens										 			       ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							aCriticas := {}
							If BEG->( MsSeek( xFilial("BEG")+B4C->(B4C_OPEMOV+B4C_ANOAUT+B4C_MESAUT+B4C_NUMAUT+B4C_SEQUEN) ) )
								While !BEG->( Eof() ) .And. BEG->(BEG_FILIAL+BEG_OPEMOV+BEG_ANOAUT+BEG_MESAUT+BEG_NUMAUT+BEG_SEQUEN) ==;
										xFilial("BEG")+B4C->(B4C_OPEMOV+B4C_ANOAUT+B4C_MESAUT+B4C_NUMAUT+B4C_SEQUEN)
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Matriz de itens															   ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									If !Empty(BEG->BEG_CODGLO)
										AaDd(aCriticas,{	AllTrim(BEG->BEG_SEQUEN),; //Sequencia
											AllTrim(BEG->BEG_CODGLO),; //Codigo Glosa
											AllTrim(BEG->BEG_DESGLO),; 	//Tabela
											AllTrim(BEG->BEG_INFGLO)} )	//Procedimento
									EndIf
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Skip																	    ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									BEG->( DbSkip() )
								EndDo
							EndIf
							AaDd(aRet,{	AllTrim(B4C->B4C_CODPAD),; 										    //01-Tabela
								AllTrim(B4C->B4C_CODPRO),; 										    //02-Procedimento
								AllTrim(B4C->B4C_DESPRO),;											//03-Descricao
								Iif( B4C->B4C_QTDSOL==0 , AllTrim(Str(B4C->B4C_QTDPRO)) , AllTrim(Str(B4C->B4C_QTDSOL)) ) ,;//04-Qtd Solicitada
								Iif( B4C->B4C_STATUS=="1" , AllTrim(Str(B4C->B4C_QTDPRO)),"0"),;	//05-Qtd Realizada
								Iif( B4C->B4C_STATUS=="1",AllTrim(Str(B4C->B4C_SALDO)),"0"),;  	 //06-Qtd Saldo
								Iif(B4C->B4C_AUDITO=="1","Sim","Não"),;						     //07-Auditoria
								Iif(B4C->B4C_STATUS=="1","Autorizado","Não Autorizado"),;			 //08-Status
								aCriticas} )    		                                             //09-Criticas
							B4C->( DbSkip() )
						Enddo
					Endif
				ElseIf BEA->( MsSeek(xFilial("BEA")+::NumAut) ) .And. BEA->BEA_TIPO == ::TipoAut
					cNomUsrP := BEA->BEA_NOMUSR
					cCodRdaP := BEA->BEA_CODRDA
					cStatusP := BEA->BEA_STATUS
					cDatSolP := DToC(BEA->BEA_DATSOL)
					cCancelP := BEA->BEA_CANCEL
					cOnLine  := BEA->BEA_COMUNI
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ item																		  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					BE2->( DbSetOrder(1) )//BE2_FILIAL + BE2_OPEMOV + BE2_ANOAUT + BE2_MESAUT + BE2_NUMAUT + BE2_SEQUEN
					BEG->( DbSetOrder(1) )//BEG_FILIAL + BEG_OPEMOV + BEG_ANOAUT + BEG_MESAUT + BEG_NUMAUT + BEG_SEQUEN
					If BE2->( MsSeek(xFilial("BE2")+BEA->(BEA_OPEMOV+BEA_ANOAUT+BEA_MESAUT+BEA_NUMAUT)) )
						While ! BE2->( Eof() ) .And. BE2->(BE2_FILIAL+BE2_OPEMOV+BE2_ANOAUT+BE2_MESAUT+BE2_NUMAUT) == ;
								xFilial("BE2")+BEA->(BEA_OPEMOV+BEA_ANOAUT+BEA_MESAUT+BEA_NUMAUT)
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Critica de Itens										 			       ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							aCriticas := {}
							If BEG->( MsSeek( xFilial("BEG")+BE2->(BE2_OPEMOV+BE2_ANOAUT+BE2_MESAUT+BE2_NUMAUT+BE2_SEQUEN) ) )
								While !BEG->( Eof() ) .And. BEG->(BEG_FILIAL+BEG_OPEMOV+BEG_ANOAUT+BEG_MESAUT+BEG_NUMAUT+BEG_SEQUEN) ==;
										xFilial("BEG")+BE2->(BE2_OPEMOV+BE2_ANOAUT+BE2_MESAUT+BE2_NUMAUT+BE2_SEQUEN)
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Matriz de itens															   ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									If !Empty(BEG->BEG_CODGLO)
										AaDd(aCriticas,{	AllTrim(BEG->BEG_SEQUEN),; //Sequencia
											AllTrim(BEG->BEG_CODGLO),; //Codigo Glosa
											AllTrim(BEG->BEG_DESGLO),; 	//Tabela
											AllTrim(BEG->BEG_INFGLO)} )	//Procedimento
									EndIf
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Skip																	    ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									BEG->( DbSkip() )
								EndDo
							EndIf
							AaDd(aRet,{	AllTrim(BE2->BE2_CODPAD),; 										    //01-Tabela
								AllTrim(BE2->BE2_CODPRO),; 										    //02-Procedimento
								AllTrim(BE2->BE2_DESPRO),;											//03-Descricao
								Iif( BE2->BE2_QTDSOL==0 , AllTrim(Str(BE2->BE2_QTDPRO)) , AllTrim(Str(BE2->BE2_QTDSOL)) ) ,;//04-Qtd Solicitada
								AllTrim(Str(BE2->BE2_QTDPRO)) /*Iif( BE2->BE2_STATUS=="1" , AllTrim(Str(BE2->BE2_QTDPRO)),"0")*/,;	//05-Qtd Realizada
								Iif( BE2->BE2_STATUS=="1",AllTrim(Str(BE2->BE2_SALDO)),"0"),;  	 //06-Qtd Saldo
								Iif(BE2->BE2_AUDITO=="1","Sim","Não"),;						     //07-Auditoria
								Iif(BE2->BE2_STATUS=="1","Autorizado","Não Autorizado"),;			 //08-Status
								aCriticas,;
								BEA->BEA_TIPGUI} )    		                                             //09-Criticas
							BE2->( DbSkip() )
						Enddo
					Else
						lRetorno := .F.
						SetSoapFault( "", "Não existe procedimento para esta Guia" )
					EndIf
				Else
					lRetorno := .F.
					SetSoapFault( "", "Guia não encontrada" )
				EndIf
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no cabecalho               									   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			BE4->( DbSetOrder(2) )//BE4_FILIAL + BE4_CODOPE + BE4_ANOINT + BE4_MESINT + BE4_NUMINT
			If BE4->( MsSeek(xFilial("BE4")+::NumAut) )
				cNomUsrP := BE4->BE4_NOMUSR
				cCodRdaP := BE4->BE4_CODRDA
				cStatusP := BE4->BE4_STATUS
				cDatSolP := DToC(BE4->BE4_DTDIGI)
				cCancelP := BE4->BE4_CANCEL
				cOnLine  := BE4->BE4_COMUNI
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ item																		  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				BEJ->( DbSetOrder(1) )//BEJ_FILIAL + BEJ_CODOPE + BEJ_ANOINT + BEJ_MESINT + BEJ_NUMINT + BEJ_SEQUEN
				BEL->( DbSetOrder(1) ) //BEL_FILIAL + BEL_CODOPE + BEL_ANOINT + BEL_MESINT + BEL_NUMINT + BEL_SEQUEN + BEL_CODGLO
				If BEJ->( MsSeek(xFilial("BEJ")+BE4->(BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT)) )
					While ! BEJ->( Eof() ) .And. BEJ->(BEJ_FILIAL+BEJ_CODOPE+BEJ_ANOINT+BEJ_MESINT+BEJ_NUMINT) == ;
							xFilial("BEJ")+BE4->(BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Critica de Itens										 			       ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						aCriticas := {}
						If BEL->( MsSeek( xFilial("BEL")+BEJ->(BEJ_CODOPE+BEJ_ANOINT+BEJ_MESINT+BEJ_NUMINT+BEJ_SEQUEN) ) )
							While !BEL->( Eof() ) .And. BEL->(BEL_FILIAL+BEL_CODOPE+BEL_ANOINT+BEL_MESINT+BEL_NUMINT+BEL_SEQUEN) == ;
									xFilial("BEL")+BEJ->(BEJ_CODOPE+BEJ_ANOINT+BEJ_MESINT+BEJ_NUMINT+BEJ_SEQUEN)
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Matriz de itens															   ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If !Empty(BEL->BEL_CODGLO)
									AaDd(aCriticas,{	AllTrim(BEL->BEL_SEQUEN),; //Sequencia
										AllTrim(BEL->BEL_CODGLO),; //Codigo Glosa
										AllTrim(BEL->BEL_DESGLO),; 	//Tabela
										AllTrim(BEL->BEL_INFGLO)} )	//Procedimento
								EndIf
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Skip																	    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								BEL->( DbSkip() )
							EndDo
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Procedimento																   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						AaDd(aRet,{	AllTrim(BEJ->BEJ_CODPAD),; 										    //01-Tabela
							AllTrim(BEJ->BEJ_CODPRO),; 										    //02-Procedimento
							AllTrim(BEJ->BEJ_DESPRO),;											//03-Descricao
							Iif( BEJ->BEJ_QTDSOL==0 , AllTrim(Str(BEJ->BEJ_QTDPRO)) , AllTrim(Str(BEJ->BEJ_QTDSOL)) ) ,;//04-Qtd Solicitada
							Iif( BEJ->BEJ_STATUS=="1" , AllTrim(Str(BEJ->BEJ_QTDPRO)),"0"),;	//05-Qtd Realizada
							"0",;  	 															//06-Qtd Saldo
							Iif( BEJ->BEJ_AUDITO=="1","Sim","Não"),;						    //07-Auditoria
							Iif( BEJ->BEJ_STATUS=="1","Autorizado","Não Autorizado"),;			//08-Status
							aCriticas} )    		                                            //09-Criticas
						BEJ->( DbSkip() )
					EndDo
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Itens da prorrogacao														 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				BQV->( DbSetOrder(1) )//BQV_FILIAL + BQV_CODOPE + BQV_ANOINT + BQV_MESINT + BQV_NUMINT + BQV_SEQUEN
				BQZ->( DbSetOrder(1) ) //BQZ_FILIAL + BQZ_CODOPE + BQZ_ANOINT + BQZ_MESINT + BQZ_NUMINT + BQZ_SEQUEN
				If BQV->( MsSeek(xFilial("BQV")+BE4->(BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT) ) )
					While ! BQV->( Eof() ) .And. BQV->(BQV_FILIAL+BQV_CODOPE+BQV_ANOINT+BQV_MESINT+BQV_NUMINT) == ;
							xFilial("BQV")+BE4->(BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Critica de Itens										 			       ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						aCriticas := {}
						If BQZ->( MsSeek( xFilial("BQZ")+BQV->(BQV_CODOPE+BQV_ANOINT+BQV_MESINT+BQV_NUMINT+BQV_SEQUEN) ) )
							While !BQZ->( Eof() ) .And. BQZ->(BQZ_FILIAL+BQZ_CODOPE+BQZ_ANOINT+BQZ_MESINT+BQZ_NUMINT+BQZ_SEQUEN) == ;
									xFilial("BQZ")+BQV->(BQV_CODOPE+BQV_ANOINT+BQV_MESINT+BQV_NUMINT+BQV_SEQUEN)
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Matriz de itens															   ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If !Empty(BQZ->BQZ_CODGLO)
									AaDd(aCriticas,{	AllTrim(BQZ->BQZ_SEQUEN),; //Sequencia
										AllTrim(BQZ->BQZ_CODGLO),; //Codigo Glosa
										AllTrim(BQZ->BQZ_DESGLO),; 	//Tabela
										AllTrim(BQZ->BQZ_INFGLO)} )	//Procedimento
								EndIf
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Skip																	    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								BQZ->( DbSkip() )
							EndDo
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Procedimento																³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						AaDd(aRet,{	AllTrim(BQV->BQV_CODPAD),; 										    //01-Tabela
							AllTrim(BQV->BQV_CODPRO),; 										    //02-Procedimento
							AllTrim(BQV->BQV_DESPRO),;											//03-Descricao
							Iif( BQV->BQV_QTDSOL==0 , AllTrim(Str(BQV->BQV_QTDPRO)) , AllTrim(Str(BQV->BQV_QTDSOL)) ) ,;//04-Qtd Solicitada
							Iif( BQV->BQV_STATUS=="1" , AllTrim(Str(BQV->BQV_QTDPRO)),"0"),;	//05-Qtd Realizada
							"0",;  	 															//06-Qtd Saldo
							Iif( BQV->BQV_AUDITO=="1","Sim","Não"),;						     //07-Auditoria
							Iif( BQV->BQV_STATUS=="1","Autorizado","Não Autorizado"),;			 //08-Status
							aCriticas} )    		                                             //09-Criticas
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Skip																		 ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						BQV->( DbSkip() )
					EndDo
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verfica se achou procediemntos											  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Len(aRet)==0
					lRetorno := .F.
					SetSoapFault( "", "Não existe procedimento para esta Guia" )
				EndIf
			Else
				lRetorno := .F.
				SetSoapFault( "", "Guia não encontrada" )
			EndIf

		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Monta restorno														   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If ::TipoAut $ '07,08,09'
			aRetBox		:= RetSx3Box( X3CBox( Posicione('SX3',2,"B4A_STATUS",'X3_CBOX') ),,,Val(B4A->B4A_STATUS) )
		Else
			aRetBox		:= RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_STATUS",'X3_CBOX') ),,,Val(BEA->BEA_STATUS) )
		Endif

		::MatComGui	:= {}
		For nI:=1 To Len( aRet )
			AaDd( ::MatComGui, WsClassNew( "SMatCompGui" ) )
			::MatComGui[nI]:RdaCode	:= cCodRdaP 							//1-Codigo da Rda
			::MatComGui[nI]:NomeUsu	:= cNomUsrP 							//2-Nome do Usuário
			::MatComGui[nI]:DtGui	:= cDatSolP   					//3-Dt da Autorizacao

			If (nPos := AsCan( aRetBox , {|x| AllTrim(x[2]) == cStatusP} ))>0
				::MatComGui[nI]:StaGui 	:= aRetBox[nPos,3] 						//4-Status Guia
			EndIf

			::MatComGui[nI]:Cancel 	:= Iif(cCancelP=="1","SIM","NÃO")	//5-Cancelada
			::MatComGui[nI]:CodTab 	:= aRet[nI,1]	    						//6-Tabela
			::MatComGui[nI]:CodPro 	:= aRet[nI,2]	   							//7-Codigo do procedimento
			::MatComGui[nI]:DesPro 	:= aRet[nI,3]	   		   					//8-Descricao procedimento
			::MatComGui[nI]:QtdSol 	:= aRet[nI,4]	   							//9-Qtd Solicitada
			::MatComGui[nI]:QtdRea 	:= aRet[nI,5]	   							//10-Qtd Realizada
			::MatComGui[nI]:QtdSal 	:= aRet[nI,6]	   							//11-Qtd Saldo
			::MatComGui[nI]:StaAud 	:= aRet[nI,7]	   		   					//12-Status Auditoria
			::MatComGui[nI]:StaPro 	:= aRet[nI,8]	   							//13-Status Procedimento
			::MatComGui[nI]:OnLine 	:= iIf(lPTUOn50,cOnLine,'0')				//14-Guia Online

			//Criticas

			aCriticas 				:= aRet[nI,9]
			::MatComGui[nI]:MatCri	:= {}
			For nY := 1 To Len( aCriticas )
				AaDd( ::MatComGui[nI]:MatCri, WsClassNew( "GenericStruct" ) )

				aRetCri := PLSRETCRI( AllTrim( aCriticas[nY,2] ) )

				If EMPTY(aRetCri[nI][2])
					aRetCri[1][1] := aCriticas[nI][2]
					aRetCri[1][2] := aCriticas[nI][3]
				EndIf

				::MatComGui[nI]:MatCri[nY]:Code		:= AllTrim( aRetCri[1,1] )
				::MatComGui[nI]:MatCri[nY]:Description := PadR( AllTrim( aRetCri[1,2] ),70 )
			Next
		Next
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Area																	   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³ CancelaGuia      ³ Autor ³ Alexander Santos	³ Data ³ 29.05.07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Cancelamento da Guia										  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
WSMETHOD CancelaGuia WSRECEIVE UserCode, NumAut, Motivo, Tipo WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 	:= .T.
	LOCAL aArea		:= GetArea()
	Local aMotivo 	:= {}
	Local aAreaBD5  := {}
	default ::Motivo := ''
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Data com 4 digitos													   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Set Century On
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "CancelaGuia" )
		SIX->( DbSetOrder(1) )
		If SIX->( MsSeek("BEAA") )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no cabecalho               									   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			BEA->( DbSetOrder(1) )//BEA_FILIAL + BEA_OPEMOV + BEA_ANOAUT + BEA_MESAUT + BEA_NUMAUT
			If PlsAliasExi('B4A')
				B4A->( DbSetOrder(1) )
			Endif
			B4Q->( DbSetOrder(1)) //B4Q_FILIAL+B4Q_OPEMOV+B4Q_ANOAUT+B4Q_MESAUT+B4Q_NUMAUT

			//Delecao de guias geradas pela Digitacao Offline
			aAreaBD5 := BD5->(GetArea())
			BD5->(DbSetOrder(17)) //BD5_FILIAL+BD5_OPEMOV+BD5_ANOAUT+BD5_MESAUT+BD5_NUMAUT
			if len(::NumAut) == 18 .And. BD5->( MsSeek(xFilial("BD5")+::NumAut) ) .And. BD5->BD5_ORIMOV == "5"
				::Motivo := "RECOFF"
				::NumAut := cValtoChar(BD5->(Recno()))
			endIf
			RestArea(aAreaBD5)

			//Ajuste temporário, para cancelar as guias de prorrogação, pois no remote, gravam BEA e no Portal, apenas B4Q
			if (::Tipo == "0" .or. ::Tipo == "11") .and. B4Q->( MsSeek(xFilial("B4Q") + ::NumAut) )
				aadd(aMotivo, ::Motivo)

				::WSNULL :=  PLSA09PCAN(.T.,,,,,,aMotivo)

				//Verifica o processamento do cancelamento
				if !Empty(::WSNULL)
					::WSNULL := "false|"+::WSNULL
				else
					::WSNULL:= "true|SIM"
				endif
			elseIf (::Tipo == "0" .or. ::Tipo == "1" .or. ::Tipo == "2" .or. ::Tipo == "3") .and.  BEA->( MsSeek(xFilial("BEA")+::NumAut) )

				While !BEA->(Eof())

					if BEA->(BEA_FILIAL+BEA_OPEMOV+BEA_ANOAUT+BEA_MESAUT+BEA_NUMAUT) = xFilial("BEA")+::NumAut .and. (BEA->BEA_TIPGUI <> "07" .and. BEA->BEA_TIPGUI <> "08" .and. BEA->BEA_TIPGUI <> "09" .and. BEA->BEA_TIPGUI <> "11")
						exit
					endif

					BEA->(dbSkip())
				enddo

				::WSNULL := PLSA090CAN(.T.,::Motivo)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica o processamento do cancelamento								 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !Empty(::WSNULL)
					::WSNULL := "false|"+::WSNULL
				Else
					::WSNULL:= "true|SIM"
				EndIf
			ElseIF (::Tipo == "0" .or. ::Tipo == "7" .or. ::Tipo == "8" .or. ::Tipo == "9") .and. PlsAliasExi('B4A') .and. B4A->( MsSeek(xFilial("B4A")+::NumAut))

				aadd(aMotivo, ::Motivo)

				::WSNULL := PLSA09ACAN(.T.,,,,,aMotivo)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica o processamento do cancelamento								 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !Empty(::WSNULL)
					::WSNULL := "false|"+::WSNULL
				Else
					::WSNULL:= "true|SIM"
				EndIf

			ELSEIF (::Motivo == "RECOFF")  //Para cancelar o registro da BD5
				::WSNULL := PLSCNCGCOB(::NumAut,,,::Tipo)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica o processamento do cancelamento								 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !Empty(::WSNULL)
					::WSNULL := "false|"+::WSNULL
				Else
					::WSNULL:= "true|SIM"
				EndIf

			Else
				lRetorno := .F.
				SetSoapFault( "", "Guia não encontrada" )
			Endif
		Endif
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Area																	   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³ ExeDHInt         ³ Autor ³ Alexander Santos	³ Data ³ 06.03.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Data e hora da internacao									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
WSMETHOD ExeDHInt WSRECEIVE UserCode, NumAut, DatInt, HorInt WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 	:= .T.
	LOCAL aRet		:= {}
	LOCAL aArea		:= GetArea()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Data com 4 digitos													   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Set Century On
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "ExeDHInt" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona no cabecalho               									   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BE4->( DbSetOrder(2) )//BE4_FILIAL + BE4_CODOPE + BE4_ANOINT + BE4_MESINT + BE4_NUMINT
		If BE4->( MsSeek(xFilial("BE4")+::NumAut) )
			aRet 	 := PLSA92DtIn(.T.,::DatInt, ::HorInt)
			::WSNULL := aRet[1]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica o processamento do cancelamento								 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(::WSNULL)
				::WSNULL := "false|"+::WSNULL
			Else
				::WSNULL:= "true|SIM|" + DtoC(aRet[2]) + "|" + aRet[3]
			EndIf
		Else
			lRetorno := .F.
			SetSoapFault( "", "Guia não encontrada" )
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Area																	   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³ ExeDHAlt         ³ Autor ³ Roberto Vanderlei³ Data ³ 02.09.16 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Data e hora da alta     									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
WSMETHOD ExeDHAlt WSRECEIVE UserCode, NumAut, DatAlt,HorAlt,MotAlt   WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 	:= .T.
	LOCAL cRet		:= ""
	LOCAL aArea		:= GetArea()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Data com 4 digitos													   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Set Century On
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "ExeDHAlt" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se existe guias com datas posteriores a data de alta informada	   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !PlsDtGuias(DatAlt,HorAlt)
			lRetorno := .F.
			SetSoapFault( "", "Não será possível incluir uma data de alta, devido ter guias posteriores a essa data!" )
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no cabecalho               									   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			BE4->( DbSetOrder(2) )//BE4_FILIAL + BE4_CODOPE + BE4_ANOINT + BE4_MESINT + BE4_NUMINT
			If BE4->( MsSeek(xFilial("BE4")+::NumAut) )
				cRet 	 := PLSADtAlt(.T.,::DatAlt, ::HorAlt, ::MotAlt)
				::WSNULL := cRet
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica o processamento do cancelamento								 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !Empty(::WSNULL)
					::WSNULL := "false|"+::WSNULL
				Else
					::WSNULL:= "true|SIM|"// + DtoC(aRet[2]) + "|" + aRet[3]
				EndIf
			Else
				lRetorno := .F.
				SetSoapFault( "", "Guia não encontrada" )
			EndIf
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Area																	   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³ Elegibilidade    ³ Autor ³ Alexander Santos	³ Data ³ 29.05.07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Elegibilidade do beneficiario								  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
WSMETHOD Elegibilidade WSRECEIVE UserCode, UserCardNumber WSSEND UserCard WSSERVICE PLSXFUN
	LOCAL nI        := 1
	Local nDiasBloqueio := GetNewPar("MV_PLDIABL", 0) //Tolerância em dias para o Bloqueio
	LOCAL lRetorno 	:= .T.
	LOCAL aRetorno	:= {}
	LOCAL aRetCri   := {}
	LOCAL aArea		:= GetArea()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Data com 4 digitos													   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Set Century On
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "Elegibilidade" )

		aRetorno := PLVLDUSRP( ::UserCardNumber,"","","1" )

		If Len(aRetorno) > 0
			If aRetorno[1]
				::UserCard 					:= WsClassNew( "UserCardView" )
				::UserCard:CardNumber		:= aRetorno[3,1,1]
				::UserCard:CardNumberOld	:= aRetorno[3,1,2]
				::UserCard:CardName			:= Upper(aRetorno[3,1,3])
				::UserCard:Interchange		:= aRetorno[3,1,4]
				::UserCard:OpeOri	   	    := aRetorno[3,1,5]
				::UserCard:Plano	   	    := aRetorno[3,1,6]
				::UserCard:ValCar	   	    := aRetorno[3,1,7]
				::UserCard:NumCarNac	    := aRetorno[3,1,8]
				::UserCard:ViaCartao		:= aRetorno[3,1,9]
				::UserCard:LOCALCob			:= aRetorno[3,1,10]
				::UserCard:Abrange			:= aRetorno[3,1,11]
				::UserCard:NatJuri			:= aRetorno[3,1,12]
				::UserCard:Telefone			:= aRetorno[3,1,13]
				::UserCard:NomTit			:= aRetorno[3,1,14]
				::UserCard:NomEmp			:= aRetorno[3,1,15]
				::UserCard:Vida				:= aRetorno[3,1,16]
				::UserCard:Dig1				:= aRetorno[3,1,17]
				::UserCard:Dig2				:= aRetorno[3,1,18]

				If Len(aRetorno[3,1]) >= 22
					::UserCard:DatBlo          := aRetorno[3,1,22]
				EndIf

				BA0->( DbSetOrder(1) ) //BA0_FILIAL+BA0_SUSEP
				BA0->( MsSeek( xFilial("BA0")+substr(aRetorno[3,1,1],1,4) ) )
				::UserCard:OpeANS := AllTrim(BA0->BA0_SUSEP)

				::UserCard:StatusEl := Iif(Len(aRetorno[4]) > 0 .Or. (!Empty( self:UserCard:DatBlo) .And. (self:UserCard:DatBlo + nDiasBloqueio) <= dDataBase), "NAO", "SIM")

				If ExistBlock("PPLEXSTAT")
					::UserCard:StatusEl := ExecBlock("PPLEXSTAT",.F.,.F.,{})
				Endif

				::UserCard:CodNeg := ""
				::UserCard:DesNeg := ""

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Retorna Criticas do usuário											   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				::UserCard:UserCritica 	:= {}
				If Len(aRetorno[4]) > 0
					If !Empty( AllTrim( aRetorno[4,1,1] ) )
						aRetCri := PLSRETCRI( AllTrim( aRetorno[4,1,1] ) )
						::UserCard:CodNeg := aRetCri[1,1]
						::UserCard:DesNeg := aRetCri[1,2]
					EndIf
					For nI := 1 To Len( aRetorno[4] )
						AaDd( ::UserCard:UserCritica, WsClassNew( "UserCardCri" ) )
						::UserCard:UserCritica[nI]:DesPri := aRetorno[4,nI,1]
						::UserCard:UserCritica[nI]:DesSeq := aRetorno[4,nI,2]
						::UserCard:UserCritica[nI]:DesTer := aRetorno[4,nI,3]
					Next
				EndIf
			Else
				lRetorno := .F.
				SetSoapFault( "", aRetorno[2] )
			EndIf
		Else
			lRetorno := .F.
			SetSoapFault( "", "Matricula não encontrada" )
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetBox    ³Autor  ³ Alexander Santos      ³ Data ³02.02.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina para alimentar matriz conforme o x3_box			   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetBox WSRECEIVE UserCode,Campos,ShowAnexo WSSEND RetBox WSSERVICE PLSXFUN
	LOCAL nI	  		:= 0
	LOCAL lRet    		:= .T.
	LOCAL aArea	  		:= GetArea()
	LOCAL aRet	  		:= {}
	LOCAL cX3cBox       := NIL
	LOCAL cStrCBox		:= NIL
	DEFAULT ::ShowAnexo	:= '0'
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Checa rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "GetBox" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Tipo de pre atendimento				   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cX3cBox := GetSx3Cache(::Campos,"X3_CBOX")

		If SUBSTR(cX3cBox,1,1) == "#"

			cX3cBox := STRTRAN(SUBSTR(cX3cBox,2), " ", "")
			cStrCBox := &(cX3cBox)
		Else
			cStrCBox := ALLTRIM(cX3cBox)
		EndIf

		aRet := {}
		aRet := RetSx3Box( cStrCBox,,,1 )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::RetBox := {}
		If Len(aRet) > 0
			For nI := 1 To Len( aRet )
				If !Empty(aRet[nI,3])
					If (::Campos $ "BEA_TIPO") .and. ::ShowAnexo == '0' .and. alltrim(aRet[nI,2]) $ "7,8,9"
					loop
				Endif
				AaDd( ::RetBox, WsClassNew( "GenericStruct" ) )
				::RetBox[nI]:Code        := aRet[nI,2]
				::RetBox[nI]:Description := AllTrim(aRet[nI,3])
			EndIf
			Next
		EndIf

	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetVlrCo  ³Autor  ³ Alexander Santos      ³ Data ³02.02.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna o valor da co-participacao						   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetVlrCo WSRECEIVE UserCode,NumAut WSSEND RetCoPar WSSERVICE PLSXFUN
	LOCAL lRet     	:= .T.
	LOCAL aArea	   	:= GetArea()
	LOCAL cExibeCo 	:= ""
	LOCAL cExibeBa 	:= ""
	LOCAL aVlrPF   	:= {}
	LOCAL aRet		:= {}
	LOCAL cMsg001	:= "Valor da Co-Participacao&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	LOCAL cMsg002	:= "Valor a ser pago direto a rede de atendimento&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	LOCAL cMsg003	:= "Valor da Co-Participacao&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	LOCAL cMsg004	:= "Valor da Compra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	LOCAL cMsg005	:= "Valor da Taxa Administracao&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	LOCAL cMsg006	:= "Valor Total da Co-Participacao&nbsp;R$:&nbsp;"
	LOCAL cMsg007	:= "Valor total a ser pago direto a rede de atendimento&nbsp;R$:&nbsp;"
	LOCAL cMsg008	:= "Valor Total da Co-Participacao&nbsp;R$:&nbsp;"
	LOCAL cMsg009	:= "Valor Total da Compra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	LOCAL cMsg010	:= "(*) Nao inclui valores de materiais e medicamentos.&nbsp;"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Checa rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "GetVlrCo" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Tipo de pre atendimento				   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cExibeCo := GetNewPar("MV_PLSEXPF","1")
		cExibeBa := GetNewPar("MV_PLSEXBT","1")
		If cExibeCo == "1"
			BEA->( DbSetOrder(1) )//BEA_FILIAL + BEA_OPEMOV + BEA_ANOAUT + BEA_MESAUT + BEA_NUMAUT + DTOS(BEA_DATPRO) + BEA_HORPRO
			If BEA->( MsSeek( xFilial("BEA")+::NumAut ) )
				BD5->( DbSetOrder(1) )//BD5_FILIAL + BD5_CODOPE + BD5_CODLDP + BD5_CODPEG + BD5_NUMERO + BD5_SITUAC + BD5_FASE + dtos(BD5_DATPRO) + BD5_OPERDA + BD5_CODRDA
				If BD5->(MsSeek(xFilial("BD5")+BEA->(BEA_OPEMOV+BEA_CODLDP+BEA_CODPEG+BEA_NUMGUI)))
					aVlrPF := PLSVALCOPA()
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Len(aVlrPF) > 0
				::RetCoPar		  := WsClassNew( "SMatVlr" )
				::RetCoPar:ExibeCo := cExibeCo
				::RetCoPar:ExibeBa := cExibeBa
				::RetCoPar:GuiAco  := BEA->BEA_GUIACO
				::RetCoPar:VlrPF   := aVlrPF[1]
				::RetCoPar:VlrBPF  := aVlrPF[2]
				::RetCoPar:PercPF  := aVlrPF[3]
				::RetCoPar:VlrTPF  := aVlrPF[4]
				::RetCoPar:VlrTAD  := aVlrPF[5]
				::RetCoPar:PagRDA  := aVlrPF[6]
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Personalizacao das mensagens de co-participacao no portal pls		   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ExistBlock("PLSCOPGUI")
					aRet := ExecBlock("PLSCOPGUI")
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Mensagem customisada													  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Len(aRet) == 0
					aRet :=  {{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""}}
				EndIf
				::RetCoPar:Msg001 := Iif( aRet[1,1], Iif( Empty(aRet[1,2]) ,cMsg001,aRet[1,2] ), "" )
				::RetCoPar:Msg002 := Iif( aRet[2,1], Iif( Empty(aRet[2,2]) ,cMsg002,aRet[2,2] ), "" )
				::RetCoPar:Msg003 := Iif( aRet[3,1], Iif( Empty(aRet[3,2]) ,cMsg003,aRet[3,2] ), "" )
				::RetCoPar:Msg004 := Iif( aRet[4,1], Iif( Empty(aRet[4,2]) ,cMsg004,aRet[4,2] ), "" )
				::RetCoPar:Msg005 := Iif( aRet[5,1], Iif( Empty(aRet[5,2]) ,cMsg005,aRet[5,2] ), "" )
				::RetCoPar:Msg006 := Iif( aRet[6,1], Iif( Empty(aRet[6,2]) ,cMsg006,aRet[6,2] ), "" )
				::RetCoPar:Msg007 := Iif( aRet[7,1], Iif( Empty(aRet[7,2]) ,cMsg007,aRet[7,2] ), "" )
				::RetCoPar:Msg008 := Iif( aRet[8,1], Iif( Empty(aRet[8,2]) ,cMsg008,aRet[8,2] ), "" )
				::RetCoPar:Msg009 := Iif( aRet[9,1], Iif( Empty(aRet[9,2]) ,cMsg009,aRet[9,2] ), "" )
				::RetCoPar:Msg010 := Iif( aRet[10,1], Iif( Empty(aRet[10,2]) ,cMsg010,aRet[10,2] ), "" )
			EndIf
		EndIf
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetContato³Autor  ³ Flavio S. Correa      ³ Data ³16.06.2009 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina Lista de Contatos TISS                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetContato WSRECEIVE UserCode, CompanyCode WSSEND TissContatos WSSERVICE PLSXFUN
	LOCAL lRet 		:= .T.
	LOCAL aArea 	:= GetArea()
	LOCAL nI		:= 1
	LOCAL aSx3Box	:= {}
	LOCAL TipoPrest	:= ""

	DEFAULT ::CompanyCode 	:= PLSINTPAD()

	If PrtChkUser( ::UserCode, "PLSXFUN","GetContato" )

		If BIM->( FieldPos('BIM_CONTIS') ) > 0 .And. BIM->( FieldPos('BIM_TIPCOM') ) > 0 .And.;
				BIM->( FieldPos('BIM_RG') ) > 0 .And. BIM->( FieldPos('BIM_ESPECI') ) > 0 .And. BIM->( FieldPos('BIM_SITE') ) > 0
			dbSelectArea("BA0")
			dbSelectArea("BIM")

			BA0->(dbSetOrder(1)) //BA0_FILIAL+BA0_CODIDE+BA0_CODINT
			BIM->(dbSetOrder(1))
			::TissContatos := {}

			aSx3Box := RetSx3Box( Posicione("SX3", 2, "BIM_TIPCOM", "X3CBox()" ),,, 1 )

			If BA0->(dbSeek(xFilial("BA0")+::CompanyCode))
				If BIM->(dbSeek(xFilial("BIM")+::CompanyCode))
					While !BIM->(Eof()) .And. BIM->(BIM_FILIAL+BIM_CODINT) == xFilial("BIM")+::CompanyCode
						If BIM->BIM_CONTIS == "1"
							aadd(::TissContatos,wsClassNew("ContatosTiss"))
							::TissContatos[nI]:Nome 		:= BIM->BIM_NOME

							TipoPrest	:= AllTrim( aSx3Box[Ascan( aSx3Box, { |aBox| aBox[2] = BIM->BIM_TIPCOM} )][3] )
							::TissContatos[nI]:TipoContato	:= TipoPrest

							::TissContatos[nI]:Telefone 	:= IIf(!Empty(BIM->BIM_RAMAL),BIM->BIM_TELCON + " - " + BIM->BIM_RAMAL,BIM->BIM_TELCON)
							::TissContatos[nI]:Email 		:= BIM->BIM_EMAIL
							::TissContatos[nI]:Site 		:= If(UPPER(Substr(Alltrim(BIM->BIM_SITE),1,4))=="HTTP",Alltrim(BIM->BIM_SITE),;
								"http://"+Alltrim(BIM->BIM_SITE))
							nI++
						EndIf
						BIM->(dbSkip())
					EndDo
				EndIf
			Else
				lRet := .F.
				SetSoapFault( "", "Operadora não encontrada" )
			EndIf

			If Len(::TissContatos) == 0
				lRet := .F.
				SetSoapFault( "", "Nenhum contato encontrado" )
			EndIf
		Else
			lRet := .F.
			SetSoapFault( "", "Verifique o dicionario de dados" )
		EndIf
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getProdutos³Autor  ³ Alexander Santos      ³ Data ³18.05.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina Lista de Produtos 		                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getProdutos WSRECEIVE UserCode WSSEND ListProdutos WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL nI		:= 1
	LOCAL lRet 		:= .T.
	LOCAL cCondBI3  := IiF(BI3->(Fieldpos("BI3_PORTAL")) > 0,'BI3->BI3_STATUS == "1" .And. BI3->BI3_PORTAL <>"2" ','BI3->BI3_STATUS == "1"')
	LOCAL cCodInt 	:= PlsIntPad()

	DEFAULT ::RegPagina	:= 10
	DEFAULT ::PaginaIni	:= 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se tem direito para executar o metodo								   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode , "PLSXFUN", "getProdutos" )

		::ListProdutos := {}
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona no produto da operadora									   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BI3->( dbSetOrder(1) )//BI3_FILIAL + BI3_CODINT + BI3_CODIGO + BI3_VERSAO
		If BI3->( dbSeek(xFilial("BI3")+cCodInt) )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Carrega os produtos													   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			While !BI3->(Eof()) .And. BI3->(BI3_FILIAL + BI3_CODINT) == xFilial("BI3")+cCodInt
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Filtro																   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If &(cCondBI3)
					AaDd( ::ListProdutos,wsClassNew("ProdutosList") )
					::ListProdutos[nI]:Codigo		:= BI3->BI3_CODIGO
					::ListProdutos[nI]:Versao		:= BI3->BI3_VERSAO
					::ListProdutos[nI]:Nome 		:= Alltrim(BI3->BI3_DESCRI)
					::ListProdutos[nI]:Abrangencia 	:= Posicione("BF7",1,xFilial("BF7")+BI3->BI3_ABRANG,"BF7_DESORI")
					::ListProdutos[nI]:Susep 		:= BI3->BI3_SUSEP
					::ListProdutos[nI]:Segmentacao 	:= Posicione("BI6",1,xFilial("BI6")+BI3->BI3_CODSEG,"BI6_DESCRI")
					::ListProdutos[nI]:NRegistro 		:= BI3->BI3_SCPA

					aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BI3_CLAPLS",'X3_CBOX') ),,,1 )
					If (nPos := AsCan( aRet , {|x| AllTrim(x[2]) == BI3->BI3_CLAPLS} ) ) > 0
						::ListProdutos[nI]:Classificacao := aRet[nPos,3]
					else
						::ListProdutos[nI]:Classificacao := " "
					EndIf

					aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BI3_SITANS",'X3_CBOX') ),,,1 )
					If (nPos := AsCan( aRet , {|x| AllTrim(x[2]) == BI3->BI3_SITANS} ) ) > 0
						::ListProdutos[nI]:Situacao := aRet[nPos,3]
					else
						::ListProdutos[nI]:Situacao := " "
					EndIf

					nI++
				EndIf
				BI3->( dbSkip() )
			EndDo
		EndIf
	Else
		lRet := .F.
		SetSoapFault( "", "Usuário não autorizado" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim do metodo														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetPaginas ³Autor  ³ Alexander Santos      ³ Data ³18.05.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina Total de Paginas da tabela Produto                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetPaginas WSRECEIVE RegPagina WSSEND QtdPaginas WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL nI 		:= 0
	LOCAL nRet		:= 0
	LOCAL lRet 		:= .T.
	LOCAL cSQL		:= ""
	LOCAL cCodInt 	:= PlsIntPad()

	DEFAULT ::RegPagina	:= 10
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se tem direito para executar o metodo								   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( "MSALPHA", "PLSXFUN","GetPaginas" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Query retorna quantidade de produtos									   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cSQL := "SELECT COUNT(*) AS QTD "
		cSQL += "  FROM " + RetSQLName("BI3")
		cSQL += " WHERE BI3_FILIAL = '" + xFilial("BI3") +"' "
		cSQL += "   AND BI3_CODINT = " + cCodInt
		cSQL += "   AND BI3_STATUS = '1' "
		cSQL += "   AND D_E_L_E_T_ <> '*' "

		If BI3->( Fieldpos("BI3_PORTAL") ) > 0
			cSQL += " AND BI3_PORTAL <> '2' "
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Executa query														   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		OPEN QUERY cSQL ALIAS "GETPAGINAS"

		::QtdPaginas := 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Quantidade de paginas												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !GETPAGINAS->( Eof() )
			nI	:= GETPAGINAS->QTD
			nRet:= mod(nI, ::RegPagina)

			If nRet > 0
				::QtdPaginas := Int(nI / ::RegPagina)+1
			Else
				::QtdPaginas := Int(nI / ::RegPagina)
			EndIf
		Else
			lRet := .F.
			SetSoapFault( "", "Nenhum Produto encontrado" )
		EndIf

		CLOSE QUERY "GETPAGINAS"
	Else
		lRet := .F.
		SetSoapFault( "", "Usuário não autorizado" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim do Metodo														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetLinks	³Autor  ³ Flavio S. Correa      ³ Data ³22.06.2009 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina Lista de Links 		                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetLinks WSRECEIVE UserCode, CompanyCode, TipoLink WSSEND ListLinks WSSERVICE PLSXFUN
	LOCAL lRet 		:= .T.
	LOCAL aArea 	:= GetArea()
	LOCAL nI		:= 1

	DEFAULT ::CompanyCode	:= PLSINTPAD()
	DEFAULT ::TipoLink		:= "1"

	If PrtChkUser( ::UserCode, "PLSXFUN","GetLinks" )

		If PLSALIASEXI("B0F") .And. B0F->( FieldPos("B0F_CODIGO") ) > 0 .And. B0F->( FieldPos("B0F_CODINT") ) > 0
			dbSelectArea("BA0")
			dbSelectArea("B0F")

			BA0->(dbSetOrder(1))//BA0_FILIAL+BA0_CODIDE+BA0_CODINT
			B0F->(dbSetOrder(1))

			::ListLinks := {}

			If BA0->(dbSeek(xFilial("BA0")+::CompanyCode))
				If B0F->(dbSeek(xFilial("B0F")+::CompanyCode))
					While !B0F->(Eof()) .And. B0F->(B0F_FILIAL+B0F_CODINT) == xFilial("B0F")+::CompanyCode
						If B0F->B0F_TIPO == ::TipoLink

							aadd(::ListLinks,wsClassNew("LinksList"))
							::ListLinks[nI]:Codigo 	  	:= B0F->B0F_CODIGO
							::ListLinks[nI]:Descricao	:= Alltrim(B0F->B0F_DESCRI)
							::ListLinks[nI]:Link	 	:= If(UPPER(Substr(Alltrim(B0F->B0F_LINK),1,4))=="HTTP",Alltrim(B0F->B0F_LINK),;
								"http://"+Alltrim(B0F->B0F_LINK))
							nI++

						EndIf
						B0F->(dbSkip())
					EndDo
				EndIf
			Else
				lRet := .F.
				SetSoapFault( "", "Operadora não encontrada" )
			EndIf

			If Len(::ListLinks) == 0
				lRet := .F.
				SetSoapFault( "", "Nenhum link encontrado" )
			EndIf
		Else
			lRet := .F.
			SetSoapFault( "", "Tabela B0F não encontrada na base de DADOS" )
		EndIf
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetBD6	³Autor  ³ Alexander Santos      ³ Data ³13.04.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna a dados do BD6									   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetBD6 WSRECEIVE UserCode,NumPeg  WSSEND MatBD6 WSSERVICE PLSXFUN
	LOCAL nI		:= 1
	LOCAL aMatBD6 	:= {}
	LOCAL aArea 	:= GetArea()
	LOCAL lRet 		:= .T.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Checa rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN","GetBD6" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Carrega BD6															   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aMatBD6 := PLSCARBD6(::NumPeg)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Carrega Estrutura													   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MatBD6 := {}
		If Len(aMatBD6) > 0
			For nI := 1 To Len( aMatBD6 )

				AaDd( ::MatBD6, WsClassNew( "SMatBD6" ) )

				::MatBD6[nI]:seqinf := aMatBD6[nI,1]
				::MatBD6[nI]:sequen := aMatBD6[nI,2]
				::MatBD6[nI]:codpad := aMatBD6[nI,3]
				::MatBD6[nI]:codpro := aMatBD6[nI,4]
				::MatBD6[nI]:qtdpro := aMatBD6[nI,5]
				::MatBD6[nI]:orimov := aMatBD6[nI,6]
				::MatBD6[nI]:procci := aMatBD6[nI,7]
				::MatBD6[nI]:recno  := aMatBD6[nI,8]
				::MatBD6[nI]:denreg := aMatBD6[nI,9]
				::MatBD6[nI]:fadent := aMatBD6[nI,10]
				::MatBD6[nI]:datpro := aMatBD6[nI,11]

			Next
		EndIf
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getFList   ³Autor  ³ Totvs 				 ³ Data ³20.02.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Lista de arquivos xml											³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getFList WSRECEIVE UserCode, RegPagina, PaginaIni, RDACode WSSEND ListArquivos WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL nI		:= 1
	LOCAL nSkip		:= 0
	LOCAL nQtdPag	:= 0
	LOCAL lRetorno	:= .T.
	LOCAL cCodInt 	:= PlsIntPad()

	DEFAULT ::RegPagina		:= 10
	DEFAULT ::PaginaIni		:= 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se tem direito para executar o metodo								   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode , "PLSXFUN","getFList" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Quantidade de registro que deve pular								   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If PLSALIASEXI("BXX") .and. BXX->(FieldPos("BXX_CODPEG")) > 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³Retorna a quantidade de paginas
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			nQtdPag := getRegPag("BXX"," WHERE BXX_FILIAL = '" + xFilial("BXX") + "' AND BXX_CODINT = '" + cCodInt + "' AND BXX_CODRDA = '" + ::RDACode + "' AND BXX_TPNFS IN('1','2') AND D_E_L_E_T_ = ' ' AND BXX_DATMOV >= '"+dtos(dDatabase-GetNewPar("MV_PLDIXML",30))+"' ",::RegPagina)[1]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³nSkip
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			nSkip := (::RegPagina * ::PaginaIni) - ::RegPagina
			::ListArquivos := {}
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³Posiciona no arquivo da rda
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			cSql := " select R_E_C_N_O_ REC from "+RetSqlName("BXX")
			cSql += " where "
			cSql += " BXX_FILIAL = '"+xFilial("BXX")+"' "
			cSql += " AND BXX_CODINT = '"+cCodInt+"' "
			cSql += " AND BXX_CODRDA = '"+::RDACode+"' "
			cSql += " AND BXX_TPNFS IN ('1','2') "
			cSql += " AND BXX_DATMOV >= '"+dtos(dDatabase-GetNewPar("MV_PLDIXML",30))+"'"
			cSql += " AND D_E_L_E_T_ = ' ' "
			cSql += " ORDER BY R_E_C_N_O_ desc"
			PlsQuery(cSql,'trbBXX')

			If trbBXX->(!Eof())
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Elemina registros ja mostrados										   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//If nSkip > 0
				//trbBXX->( dbSkip(nSkip) ) // dbSkip(X) estava falhando
				//EndIf
				If ::PaginaIni > 1
					While nI <= nSkip
						trbBXX->( dbSkip() )
						nI++
					EndDo
					nI := 1
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Carrega os arquivos do usuario										   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				While !trbBXX->( Eof() )

					BXX->(DbGoTo(trbBXX->REC))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Filtro																   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					AaDd( ::ListArquivos,wsClassNew("ArquivosList") )
					::ListArquivos[nI]:Data			:= BXX->BXX_DATMOV
					::ListArquivos[nI]:NomeArqIn	:= BXX->BXX_ARQIN
					::ListArquivos[nI]:ArquivoIn	:= BXX->BXX_ARQIN
					::ListArquivos[nI]:ArquivoOut 	:= AllTrim(BXX->BXX_ARQOUT)
					::ListArquivos[nI]:Status 		:= BXX->BXX_STATUS
					::ListArquivos[nI]:DesSta 		:= PLSTXTSX3("BXX_STATUS",BXX->BXX_STATUS)
					::ListArquivos[nI]:QtdPag 		:= nQtdPag
					::ListArquivos[nI]:CodPeg 		:= If(Empty(BXX->BXX_CODPEG),space(tamsx3("BXX_CODPEG")[1]),BXX->BXX_CODPEG)
					::ListArquivos[nI]:tpArq 		:= BXX->BXX_TIPGUI
					::ListArquivos[nI]:Sequen 		:= BXX->BXX_SEQUEN
					::ListArquivos[nI]:Origem 		:= PLSTXTSX3("BXX_TPNFS",BXX->BXX_TPNFS)
					::ListArquivos[nI]:ProGlo		:= BXX->BXX_PROGLO
					nI++
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Verifica registros por paginas										   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If nI > ::RegPagina
						Exit
					EndIf
					trbBXX->( dbSkip() )
				EndDo
			EndIf
			trbBXX->(DbCloseArea())
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se existe registros													   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(::ListArquivos) == 0
			lRetorno := .F.
			SetSoapFault( "", "Nenhum registro encontrado" )
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim do metodo														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³IncXmlUp   ³Autor  ³ Totvs 				 ³ Data ³20.02.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de inclusao de arquivo de Upload						³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD IncXmlUp WSRECEIVE UserCode, UserPlsName, DirArqIn, RDACode WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno		:= .T.
	LOCAL aArea 		:= GetArea()
	LOCAL cDirRaiz 		:= PLSMUDSIS( GetNewPar("MV_TISSDIR","\TISS\") )
	LOCAL cDirWeb		:= PLSMUDSIS( cDirRaiz+"UPLOAD\")//getWebDir("UPLOADPATH")
	Local cPartArq		:= ::RDACode + "_" + Alltrim(Str(month(date()))) + "_" + ( Alltrim(Str(Year(date()))) ) + "_" +;
		Left(Time(),2) + "_" + Substr(Time(),4,2) + "_" + Right(Time(),2)
	Local nI				:= 0
	Local nRename		:= -1
	DEFAULT ::WSNULL 	:= ""

	cNomeArq1 	:= Lower( AllTrim( SubStr( ::DirArqIn, Rat(PLSMUDSIS('\'),::DirArqIn)+1) ) )
	//Copia nome Arquivo para montar nome exibição
	cNomeExibe := cNomeArq1
	//Pega a extensão do arquivo
	cExtArq	:= SubStr(cNomeArq1, RAT(".", cNomeArq1)+1)
	//Monta nome de exibição
	cNomeExibe := SubStr(cNomeExibe, 1, RAT(".", cNomeExibe)) + cExtArq
	//Pega o nome do arquivo
	cNomeArq1	:= SubStr(cNomeArq1, 1, RAT(".", cNomeArq1)-1)
	//Renomeia o aruqivo para nome nome + data atual + horário atual
	//às vezes não dava tempo de renomear o arquivo, então tentamos umas vezes mais
	while (nRename == -1 .AND. nI < 1000)
		nRename := FRename(cDirWeb+cNomeArq1+"."+cExtArq, cDirWeb+cNomeArq1+"_"+cPartArq+"."+cExtArq)
		nI++
	EndDo

	::DirArqIn := cDirWeb+cNomeArq1+"_"+cPartArq+"."+cExtArq

	If PrtChkUser( ::UserCode ,"PLSXFUN","IncXmlUp" )

		If nRename <> -1 //Se não conseguiu renomear, solicitamos um novo envio
			::WSNULL := PLSINALUP(::UserPlsName, ::RDACode,.T.,.T.,::DirArqIn) //cDirWeb+cNomeArq1+"_"+cPartArq+"."+cExtArq)
		Else
			::WSNULL := "Ocorreu um erro no envio do arquivo, por favor tente novamente. (" + cValToChar(FError()) + ")."
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ProcUpXml  ³Autor  ³ Totvs 				 ³ Data ³20.02.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de processamento do arquivo xml Upload					³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ProcUpXml WSRECEIVE UserCode, UserPlsName, DirArqIn, RDACode WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno	 	:= .T.
	LOCAL aArea 		:= GetArea()
	LOCAL aRet			:= {}
	DEFAULT ::WSNULL	:= "true|"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se tem direito para executar o metodo								   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode ,"PLSXFUN","ProcUpXml" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Faz a gravacao do arquivo de saida										 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::WSNULL := PLSINALUP(::UserPlsName, ::RDACode, .T., .F., ::DirArqIn,aRet)
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim do metodo														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getGAT    ³Autor  ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Gatilho de campo											   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getGAT WSRECEIVE UserCode, UserPlsCode, TpPor, VldGen, FunName, Chave, Tp, TipGui WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno	:= .T.
	LOCAL nI		:= 0
	LOCAL aArea 	:= GetArea()
	LOCAL aRet		:= {}
	DEFAULT ::TipGui  := ''
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Se tem direito para executar o metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If PrtChkUser( ::UserCode ,"PLSXFUN","getGat" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Retira mascara do conteudo da chave
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::Chave := PLRETCARS(::Chave)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Executa rotina generica (gatilho)
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := ExecBlock(::FunName, .F., .F., { ::Chave, ::Tp, ::UserPlsCode ,::TpPor ,::VldGen,::TipGui } )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Retorno
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := WCGatField(aRet)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Devolve os campos em vazio para limpar a tela
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		For nI:=1 To Len(aRet)
			::WSNULL += aRet[nI]
		Next
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Fim do metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³setSolCar ³Autor  ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Solicitacao de Carteirinha								   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD setSolCar WSRECEIVE UserCode, MatUsu, MotCar WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno	:= .T.
	LOCAL nI		:= 0
	LOCAL aArea 	:= GetArea()
	LOCAL aRet		:= {}

	DEFAULT ::WSNULL := ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Se tem direito para executar o metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If PrtChkUser( ::UserCode ,"PLSXFUN","setSolCar" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Retira mascara do conteudo da chave
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::MatUsu := PLRETCARS(::MatUsu)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Executa rdmake
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := ExecBlock('PLSPROSC', .F., .F., { ::MatUsu, ::MotCar } )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Se falha no processamento
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If !aRet[1]

			::WSNULL += "false|Processamento não foi Efetivado|"

			For nI:=1 To Len(aRet[2])
				::WSNULL += WCTextNeg(aRet[2,nI,1] + " - " + aRet[2,nI,2],.F.)
			Next

		Else
			::WSNULL += "true|Processado com Sucesso|"+ Chr(13)+Chr(10) + aRet[2]
		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Fim do metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getDadGrid³Autor  ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retonar dados para a gridData								   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getDadGrid WSRECEIVE userCode, funName, where, buscaTReg, paginaIni, pesquisa, semaforo, camposCustom WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= getArea()
	LOCAL lRetorno	:= .t.
	LOCAL lContinua	:= .t.
	LOCAL nQtd		:= (::PaginaIni-1)
	LOCAL nRecPes	:= 0
	LOCAL nI		:= 0
	LOCAL nQtdPag 	:= 0
	LOCAL nSkip		:= 0
	LOCAL nPos		:= 0
	LOCAL nQtdReg 	:= 1
	LOCAL nPaginaAtu:= 0
	LOCAL nH		:= 0
	LOCAL nW 		:= 0
	LOCAL nPosSel	:= 0
	LOCAL lResetVar	:= .f.
	LOCAL lCSemafo	:= .f.
	LOCAL cBtnPos	:= ""
	LOCAL cAlias	:= ""
	LOCAL cTitulo	:= ""
	LOCAL cSql		:= ""
	LOCAL cMsg		:= ""
	LOCAL cPesquisa	:= ""
	LOCAL xHeader 	:= "[{}]"
	LOCAL xCols		:= "[]"
	LOCAL cWhere	:= ""
	LOCAL cFieldJ	:= ""
	LOCAL bFilPes	:= ""
	LOCAL aRet		:= {}
	LOCAL aFieldInfo:= {}
	LOCAL lNoIdeLine := .F.
	//Vetor aAlisNExt: em SQL UNION, quando não existe a coluna em alguma tabela, passar o alias da coluna
	//principal e o nome do apelido, para que seja substituido na rotina e traga o valor correto, evitando NIL
	Local aAlisNExt  := {}
	DEFAULT ::WSNULL 	:= ""
	DEFAULT ::pesquisa 	:= ""
	DEFAULT ::semaforo  := ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Se tem direito para executar o metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	if prtChkUser( ::UserCode, "PLSXFUN", "getDadGrid" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³se recebe o semaforo devo verificar se e possivel fazer a consulta
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		if !empty(::semaforo)
			nH := PLSAbreSem(::semaforo, .f.)
			if nH == 0
				cMsg := "Favor aguardar o termino do processamento que esta em andamento!"
				lResetVar := .t.
				lCSemafo := .t.
			else
				PLSFechaSem(nH,::semaforo)
			endIf
		endIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Executa rotina generica dados para brw gridData
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		if !lCSemafo
			aRet       := execBlock(::funName, .f., .f., { ::Where, ::camposCustom } )
			cAlias     := aRet[01]
			cSql       := aRet[02]
			cWhere     := aRet[03]
			nRegPagina := aRet[04]
			aFieldInfo := getIField( aRet[05] )
			cFieldJ    := aRet[06]
			cPesquisa  := iIf(len(aRet)>06,aRet[07],"")
			cAlias1    := iIf(len(aRet)>07,aRet[08],"")
			cSql1      := iIf(len(aRet)>08,aRet[09],"")
			cWhere1    := iIf(len(aRet)>09,aRet[10],"")
			lNoIdeLine := iIf(len(aRet)>10,aRet[11],.F.)
			cCmpCbox   := iIf(len(aRet)>11,aRet[12],"")
			cAlias2    := iIf(len(aRet)>12,aRet[13],"")
			cSql2      := iIf(len(aRet)>13,aRet[14],"")
			cWhere2    := iIf(len(aRet)>14,aRet[15],"")
			aAlisNExt  := iIf(len(aRet)>15,aRet[16],"")
			cAlias3    := iIf(len(aRet)>16,aRet[17],"")
			cSql3      := iIf(len(aRet)>17,aRet[18],"")
			cWhere3    := iIf(len(aRet)>18,aRet[19],"")
			cAlias4    := iIf(len(aRet)>19,aRet[20],"")
			cSql4      := iIf(len(aRet)>20,aRet[21],"")
			cWhere4    := iIf(len(aRet)>21,aRet[22],"")

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³Se faz a busca por quantidade de registros e paginas
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			If ::BuscaTReg == '1'
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³Retorna a quantidade de registros
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				aRet := getRegPag(cAlias,cWhere,nRegPagina,cFieldJ)

				nQtdPag := aRet[1]
				nQtdReg := aRet[2]

				If ! Empty(cSql1)
					aRet 	:= getRegPag(cAlias1,cWhere1,nRegPagina,/*cFieldJ*/,.T.)
					nQtdReg += aRet[2]
				Endif

				If ! Empty(cSql2)
					aRet 	:= getRegPag(cAlias2,cWhere2,nRegPagina,/*cFieldJ*/,.T.)
					nQtdReg += aRet[2]
				Endif

				If ! Empty(cSql3)
					aRet 	:= getRegPag(cAlias3,cWhere3,nRegPagina,/*cFieldJ*/,.T.)
					nQtdReg += aRet[2]
				Endif

				If ! Empty(cSql4)
					aRet 	:= getRegPag(cAlias4,cWhere4,nRegPagina,/*cFieldJ*/,.T.)
					nQtdReg += aRet[2]
				Endif

				//	Calcula a quantidade real de Páginas
				nI 		:= Mod(nQtdReg, nRegPagina)
				nQtdPag := Int(nQtdReg / nRegPagina)
				nQtdPag += Iif(nI > 0, 1 ,0)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ aHeader
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				xHeader := "["

				For nI := 1 To Len(aFieldInfo)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ Verifica se foi informado funcao de tratamento na linha
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					cTitulo := aFieldInfo[nI,1]
					If (nPos := At('#',cTitulo) ) > 0
						cTitulo := SubStr(cTitulo, (nPos+1), Len(cTitulo) )
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ Cabecalho
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					xHeader += "{name:'" + cTitulo + "'}" + Iif( Len(aFieldInfo) != nI ,",","]" )
				Next

			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³Monta cabecalho e item
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			If nQtdReg > 0
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³verifica se o idenfificador de linha "IDENLINHA" foi inserido na query
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				if ! empty(cAlias) .and. at("IDENLINHA",cSql) == 0 .and. ! lNoIdeLine
					nPosSel	:= at('SELECT',upper(cSql))
					cSql 	:= subStr(cSql,nPosSel,7)+" DISTINCT " + retSQLName(cAlias) + ".R_E_C_N_O_ IDENLINHA, " + substr(cSql,nPosSel+7)
				endIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³Executa query
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				OPEN QUERY cSQL ALIAS "GETDADGRID"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ verifica se tem pesquisa
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				if ! empty(::Pesquisa)
					bFilPes 	:= {|| &(::Pesquisa) }
					cPesquisa 	:= "'" + cPesquisa + "' "
					GETDADGRID->(dbSetFilter(bFilPes, ::Pesquisa))
					GETDADGRID->(dbGoTop())
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ filtro nao encontrou dados da pesquisa
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					if GETDADGRID->(eof())
						lContinua := .f.
					else
						nRecPes := GETDADGRID->(recno())
						GETDADGRID->(dBClearFilter())
						GETDADGRID->(dbGoTop())
					endIf
				else
					nRecPes := nRegPagina	//	Serve para ajudar no calculo da página atual na Consulta Status Autorização
				endIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ Alimenta a matriz
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				if lContinua
					if !GETDADGRID->(eof())
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						//³ Abre matriz aCols
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						xCols := '['
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						//³Quantidade de registro que deve pular ja contando o registro de pesquisa em qual pagina foi encontrado
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						if nRecPes > 0
							nPaginaAtu := ::PaginaIni + iIf( mod(nRecPes, nRegPagina) > 0, int(nRecPes / nRegPagina), int(nRecPes / nRegPagina)-1 )
							nSkip := (nRegPagina *  nPaginaAtu ) - nRegPagina
						else
							nSkip := (nRegPagina * ::PaginaIni ) - nRegPagina
						endIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						//³Elimina registros
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						/*if nSkip > 0
						GETDADGRID->( dbSkip(nSkip) )
						endIf*/
						//fiz isso poruqe por algum motivo o dbskip(numero) parou de funcionar
						for nW := 1 to nSkip
							GETDADGRID->( dbSkip() )
						next nW
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						//³ while do resultado
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						while !GETDADGRID->(eof())
							nQtd++

							if nQtd <= ((::PaginaIni + nRegPagina)-1)
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
								//³ aCols
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
								xCols += '{'
								for nI := 1 to len(aFieldInfo)
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
									//³ Verificando se tem alguma coluna especial (bottons)
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
									cBtnPos := aFieldInfo[nI,1]
									if (nPos := at('#',cBtnPos) ) > 0
										cBtnPos := subStr(cBtnPos, 1, nPos )
									else
										cBtnPos := ""
									endIf
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
									//³ Monta acols
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
									For nH := 1 TO Len(aAlisNExt)  //Nos casos onde no SQL Union, não existe a coluna em determinada tabela, para evitar erro de Nil.
										IF (aFieldInfo[nI,2] == aAlisNExt[nH,1])
										aFieldInfo[nI,2] := aAlisNExt[nH,2]
									ENDIF
								Next
								//Verifico se a guia foi criada no Digitação de guias e se o BD5_NUMAUT está vazio
								If 'BD5_NUMAUT' $ aFieldInfo[nI,2] .and. Empty(GETDADGRID->BD5_NUMAUT)
									aFieldInfo[nI,2] := StrTran( aFieldInfo[nI,2], 'BD5_NUMAUT', 'BD5_NUMERO')
								EndIf

								__SetCentury( "on" ) //coloquei aqui pois quando o campo tem ALIAS, o sistema não acha no SX3 e não pega o tipo e ai precisa fazer o DTOC la no cCampo da query

								if aFieldInfo[nI,2] $ "RECNO,R_E_C_N_O_"

									xCols += cValToChar((nI-1)) + ':{field:"'+aFieldInfo[nI,2]+'", value:"' + cBtnPos + IIF(ValType(GETDADGRID->&(aFieldInfo[nI,2]))=='N',allTrim(cValToChar(GETDADGRID->&(aFieldInfo[nI,2]))),allTrim(GETDADGRID->&(aFieldInfo[nI,2]))) + '"} ' + Iif( Len(aFieldInfo) != nI ,',','' )
								else
									xCols += cValToChar((nI-1)) + ':{field:"'+aFieldInfo[nI,2]+'", value:"' + cBtnPos + strtran(getFMask(GETDADGRID->&(aFieldInfo[nI,2]), aFieldInfo[nI,3], aFieldInfo[nI,4], aFieldInfo[nI,2], IIf(aFieldInfo[nI,2] $ cCmpCbox, AllTrim( X3CBox(Posicione('SX3' , 2 ,cCmpCbox,'X3_CBOX')) ),'')), '"', '\"') + '"} ' + Iif( Len(aFieldInfo) != nI ,',','' )																		
								endif

								__SetCentury( "Off" )
								next
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
								//³ verifica se tem o campo na area de trabalho
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
								if GETDADGRID->(fieldPos("IDENLINHA"))>0
									If GETDADGRID->(fieldPos("ALIAS"))>0
										xCols += ',' + cValToChar((nI-1)) + ':{field: "IDENLINHA", value:"' + alltrim(GETDADGRID->ALIAS)+allTrim(cValToChar(GETDADGRID->IDENLINHA)) + '"} '
									Else
										xCols += ',' + cValToChar((nI-1)) + ':{field: "IDENLINHA", value:"' + allTrim(cValToChar(GETDADGRID->IDENLINHA)) + '"} '
									Endif
								endIf
								xCols +=  '},'
							else
								exit
							endIf

							GETDADGRID->( dbSkip() )
						endDo
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						//³ Fecha matriz
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						xCols := iif(xCols == '[', xCols + ']',left( xCols,len(xCols)-1 ) + ']')
					else
						lContinua 	:= .f.
						cMsg 		:= "Não existe registro para esta consulta!"
					endif
				else
					lContinua 	:= .f.
					cMsg 		:= "Conteudo da pesquisa não encontrado!"
				endIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ Fecha area de trabalho
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				CLOSE QUERY "GETDADGRID"
			Else
				cMsg := "Não existe registro para esta consulta!"
				lResetVar := .t.
			endIf
		endIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ limpa conteudo de retorno
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		if lResetVar
			xHeader := "[{}]"
			nQtdReg := 0
			nQtdPag := 0
			nRegPagina := 0
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Retorno
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::WSNULL := "true|" + cValToChar(nQtdReg) + "|" + cValToChar(nQtdPag) + "|" + cValToChar(nRegPagina) + "|" + xHeader + "|" +	xCols + "|" + cMsg + "|" + iIf(lContinua,'true','false') + "|" + cValToChar(nPaginaAtu) + "|" + cPesquisa + "|" + iIf(lCSemafo,'true','false') + "|"
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf
	RestArea( aArea )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Fim do metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lRetorno

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VerDtGuia  ³Autor ³ Roberto Vanderlei     ³ Data ³21.07.2016 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Validação para geração de peg de guias do portal			   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VerDtGuia WSRECEIVE Chave,Tipo, userCode, TipGui WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= getArea()
	LOCAL lRetorno	:= .T.
	LOCAL nQtdDias 	:= getNewPar("MV_PLDRETR",90)
	LOCAL dDtMin    := daySub(Date(), nQtdDias + 1) //O dia inicial é o dia Zero
	LOCAL dDtAtend	:= 0
	LOCAL aGuias	:= {}
	LOCAL nI		:= 0
	LOCAL cRetorno	:= "true|"
	LOCAL cContador := 0
	local cRecno	:= 0
	Local cAlias	:= Iif ( (Valtype(::TipGui) == 'U') .Or. ::TipGui <> "05", "BD5", "BE4" )
	Local cFinal	:= Iif ( (Valtype(::TipGui) == 'U') .Or. ::TipGui <> "05", "AUT", "INT" )
	Local cOperad	:= Iif ( (Valtype(::TipGui) == 'U') .Or. ::TipGui <> "05", "_OPEMOV", "_CODOPE" )

	DEFAULT ::WSNULL := ""

	//Se tem direito para executar o metodo
	if PrtChkUser( ::userCode ,"PLSXFUN","VerDtGuia" )

		cRetorno += str(nQtdDias) + "|"

		if ::Tipo = "D" .or. ::Tipo = "'D'"//Digitação Offline

			aGuias	:= strToArray( ::Chave , ';')

			For nI := 1 To Len( aGuias )

				dDtAtend := strToArray(aGuias[nI], '$')[2]

				if ctod(dDtAtend) <= dDtMin
					cContador := cContador +  1
					cRetorno += aGuias[nI] + ";"
				endif

			next

		else

			aGuias := strToArray( ::Chave , ',')

			//Posiciona nos Recnos para verificar data de atendimento e afins.
			for nI := 1 to len(aGuias)

				cRecno := aGuias[nI]

				cSQL := "SELECT " + cAlias + "_DATPRO DATPRO," + cAlias + cOperad + " OPEMOV, " + cAlias + "_ANO" + cFinal + " ANOAUT, " + cAlias + "_MES" + cFinal + " MESAUT, " + cAlias + "_NUM" + cFinal + " NUMAUT "
				cSQL += "   FROM " + retSQLName(cAlias)
				cSQL += " WHERE R_E_C_N_O_ = " + cRecno
				cSQL += "    AND D_E_L_E_T_ = ''"

				dbUseArea(.T.,"TOPCONN",TCGENQRY(,,ChangeQuery(cSql)),"TrbBD5",.F.,.T.)

				If !TrbBD5->(EOF())

					TCSETFIELD("TrbBD5","DATPRO","D",08,0)

					if TrbBD5->DATPRO <= dDtMin
						cContador := cContador +  1
						cRetorno  += cRecno +  "$" + dtoc(TrbBD5->DATPRO) + "$" + TrbBD5->OPEMOV + TrbBD5->ANOAUT + TrbBD5->MESAUT + TrbBD5->NUMAUT +  ";"
					endif

				Else

					FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01',"Não achou !" , 0, 0, {})

				EndIf

				TrbBD5->(dbCloseArea())

			next

		endif

		if cContador = Len( aGuias )
			cRetorno += "|" + "T"
		else
			cRetorno += "|" + "P"
		endif
	else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf

	::WSNULL := cRetorno

	restArea( aArea )

Return lRetorno

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³setTFGuia  ³Autor ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Inclusao de peg de guias do portal						   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD setTFGuia WSRECEIVE userCode, matPeg WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= getArea()
	LOCAL nH 		:= 0
	LOCAL lRetorno	:= .t.
	LOCAL lContinua	:= .t.
	LOCAL lExcluiPEG	:= .t.
	LOCAL aMat		:= strToArray( matPeg:where , '|' )
	local lErroCat	:= .f.
	Default matPeg:funName	:= ""  //Se vazio, vem da geração normal da peg no portal.

	DEFAULT ::WSNULL := ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Se tem direito para executar o metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	if PrtChkUser( ::userCode ,"PLSXFUN","setTFGuia" )
		//tratamento contorno
		if !matPeg:gerPeg
			if !empty(matPeg:colsCk)
				matPeg:gerPeg := .t.
			elseif ( empty(matPeg:colsCk) .and. !('_RECNO' $ matPeg:where) )
				lErroCat := .t.
			endif
		endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ cria protocolo
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		nH := PLSAbreSem(matPeg:semaforo,.f.)
		if nH == 0
			::WSNULL := "true|Favor aguardar o termino do processamento que esta em andamento!"
		else
			if !lErroCat
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ fecha semaforo
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				PLSFechaSem(nH,matPeg:semaforo)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ quanto nao mostra as guias no portal deve verificar se existe registro para selecao
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				If matPeg:gerPeg .and. !matPeg:mosGui
					lContinua := PLSVDPEGU(aMat)
				ElseIf !matPeg:gerPeg
					lExcluiPEG := PLSDELPEG(aMat) //verifica se a PEG pode ser excluida
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ se existe registro
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				If lContinua .and. lExcluiPEG
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ transfere as guias
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					PLSPEGGUI(aMat,matPeg:colsCk,matPeg:colsUnCk,matPeg:semaforo,matPeg:mosGui, matPeg:funName,matPeg:grvVlrApr, .T., matPeg:TipoGuia)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ retorno
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					if matPeg:gerPeg
						::WSNULL := "true|O protocolo está sendo gerado. Em alguns minutos consulte o mesmo através da opção << Consultar Protocolos Gerados >>"
					else
						::WSNULL := "true|Protocolo está sendo cancelado. Em alguns minutos consulte a sua exclusão através da opção << Consultar Protocolos Gerados >>. Caso o protocolo não mais esteja sendo exibido o seu cancelamento foi finalizado."
					endIf
				else
					If !lExcluiPEG
						::WSNULL := "true|PEG com guia faturada não pode ser excluida."
					Else
						::WSNULL := "true|Não existe registro para os parâmetros informados!"
					EndIf
				endIf
			else
				PlLogWsFn1(matPeg:colsCk, matPeg:colsUnCk, matPeg:semaforo, matPeg:mosGui, matPeg:funName, matPeg:grvVlrApr, matPeg:TipoGuia, matPeg:where, matPeg:gerPeg )
				PLSFechaSem(nH,matPeg:semaforo)
				::WSNULL := "true|Ocorreu algum problema com sua solicitação.<br> Tente novamente mais tarde!"
			endif
		endIf
	else
		lRetorno := .f.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Fim do metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lRetorno


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getInProces³Autor ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³verifica se ainda esta em processo de transferencia de guia  |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getInProces WSRECEIVE userCode, matPeg WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= getArea()
	LOCAL lRetorno	:= .t.

	DEFAULT ::WSNULL := ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Se tem direito para executar o metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	if PrtChkUser( ::userCode ,"PLSXFUN","getInProces" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ cria protocolo
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		nH := PLSAbreSem(matPeg:semaforo,.f.)
		if nH == 0
			::WSNULL := "true|false|"
		else
			PLSFechaSem(nH,matPeg:semaforo)
			::WSNULL := "true|true|" + matPeg:funJS
		endIf
	else
		lRetorno := .f.
		setSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Fim do metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getIField ³Autor  ³ Totvs			        ³ Data ³06.07.2012 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retonar titulo + campo 									   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function getIField(cCampo)
	LOCAL aRet 		:= {}
	LOCAL aRetAux	:= {}
	LOCAL aCampos	:= StrToArray(AllTrim(cCampo),",")
	LOCAL nI		:= 1
	LOCAL cTitulo	:= ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Matriz de campos para identificar os titulos dos campos aHeader
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	For nI:=1 To Len(aCampos)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Matriz de titulo + campo
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRetAux := StrToArray( AllTrim( aCampos[nI] ),"=" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Se o titulo nao foi informado pega do x3_titulo
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		cTitulo := RetTitle(aRetAux[2])
		If AllTrim(aRetAux[1]) == "?"
			aRetAux[1] := cTitulo
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Titulo e Campos (pegar o conteudo posteriormente)
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		AaDd(aRet, { AllTrim(aRetAux[1]) ,aRetAux[2] , AllTrim(SX3->X3_TIPO), SX3->X3_PICTURE, SX3->X3_CBOX} )
	Next
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Fim do metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return aRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getRegPag  ³Autor  ³ Totvs				 ³ Data ³20.02.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina Total de Paginas e Total de Registros				    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function getRegPag(cAlias,cWhere,nRegPagina,cFieldJ,lComp)
	LOCAL aArea 	:= GetArea()
	LOCAL nRest		:= 0
	LOCAL nQtdReg	:= 0
	LOCAL nQtdPag 	:= 0
	LOCAL cSQL		:= ""
	LOCAL lAliasExit:= .T.
	DEFAULT cFieldJ	:= ""
	DEFAULT lComp		:= .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Query
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If !Empty(cAlias)
		lAliasExit := PLSALIASEXI(cAlias)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Se a tabela existe
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If lAliasExit
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Join o from esta na variavel cWhere retornada pela PPLSRDBRW
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If !Empty(cFieldJ)
			cSQL := "SELECT COUNT(DISTINCT " + cFieldJ + ") AS QTD "
		Else
			cSQL := "SELECT COUNT(*) AS QTD "
			cSQL += "  FROM " + RetSQLName(cAlias)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Where
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If !Empty(cWhere)
			cSQL += cWhere
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Executa query
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		OPEN QUERY cSQL ALIAS "GETREGPAG"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Quantidade de paginas
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If !GETREGPAG->( Eof() )
			nQtdReg	:= GETREGPAG->QTD

			if nRegPagina==0
				nRegPagina := 1
			endIf

			nRest	:= mod(nQtdReg, nRegPagina)

			If nRest > 0
				nQtdPag	:= Int(nQtdReg / nRegPagina)+1
			Else
				nQtdPag := Int(nQtdReg / nRegPagina)
			EndIf

			If 	nQtdPag == 0 .And. !lComp
				nQtdPag := 1
			EndIf
		EndIf

		CLOSE QUERY "GETREGPAG"
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Fim do Metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return( {nQtdPag,nQtdReg} )
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getFMask	 ³Autor  ³ Totvs				 ³ Data ³20.02.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna conteudo formatado conforme tipo e picture			³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function getFMask(xConteudo ,cTipo, cPicture,cCampo, cBox)
	LOCAL nPos			:= 0
	LOCAL aRetBox		:= {}
	DEFAULT cTipo	 	:= ValType(xConteudo)
	DEFAULT cPicture 	:= ""
	DEFAULT cCampo 	:= ""
	DEFAULT cBox 		:= ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Se nao informado ou nao achou no x3 recno por exemplo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If Empty(cTipo)
		cTipo := ValType(xConteudo)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Convert e formata
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	Do Case
		Case !Empty(cBox) .AND. cTipo == 'C'
			aRetBox := RetSx3Box( X3CBox( Posicione('SX3',2,cCampo,'X3_CBOX') ),,,1 )

			If (nPos := AsCan( aRetBox , {|x| AllTrim(x[2]) == xConteudo} ))>0
				xConteudo := aRetBox[nPos,3]
			EndIf
		Case cTipo == 'C'
			xConteudo := allTrim( Iif(!Empty(cPicture), TransForm( AllTrim(xConteudo) ,cPicture), AllTrim(xConteudo) ) )
		Case cTipo == 'N'
			If Empty(cPicture)
				cPicture := "@E 999,999,999.99"
			EndIf
			xConteudo := allTrim(Iif(!Empty(cPicture), TransForm( xConteudo ,cPicture), cValToChar(xConteudo) ))
		Case cTipo == 'D'
			__SetCentury( "on" )

			xConteudo := DToC(SToD(xConteudo))

			__SetCentury("off")
	EndCase
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Fim do Metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return(xConteudo)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³timeField ³Autor  ³ Karine Riquena Limp   ³ Data ³23.12.2016 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Transforma um campo da query no formato Hora   				  |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function timeField(xConteudo)
	Local nTam := len(xConteudo)

	xConteudo := Stuff( xConteudo, 3, 0, ":" )

	if(nTam > 4)
		xConteudo := Stuff( xConteudo, 6, 0, ":" )
	endIf

Return xConteudo

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Somente para poder compilar
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function PLSXFUN()
Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ProcUpXml  ³Autor  ³ Totvs 				 ³ Data ³20.02.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de processamento do arquivo xml Upload					³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ProcDeXml WSRECEIVE UserCode, UserPlsName, DirArqIn, RDACode WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno	 	:= .T.
	LOCAL aArea 		:= GetArea()
	LOCAL cDirRaiz	   	:= PLSMUDSIS( GetNewPar("MV_TISSDIR","\TISS\") )
	LOCAL cDirBkp		:= PLSMUDSIS( cDirRaiz+"UPLOAD\BACKUP\")
	LOCAL cDirUpload	:= PLSMUDSIS( cDirRaiz+"UPLOAD\" )
	LOCAL cFile    		:= ""
	LOCAL cExten   		:= ""
	LOCAL cDirDocs 		:= ""

	DEFAULT ::WSNULL	:= "true|"

	//Se tem direito para executar o metodo
	If PrtChkUser( ::UserCode ,"PLSXFUN","ProcDeXml" )

		//Processa o arquivo enviado
		cSql := " SELECT R_E_C_N_O_ REC FROM " + retSqlName("BXX")
		cSql += "  WHERE BXX_FILIAL  = '" + xFilial("BXX") + "' "
		cSql += "    AND BXX_CODRDA  = '" + ::RDACode + "' "
		cSql += "    AND ( BXX_ARQIN = '" + lower(::DirArqIn) + "' OR BXX_ARQIN  = '" + ::DirArqIn + "') "
		cSql += "    AND D_E_L_E_T_  = ' ' "

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,changeQuery(cSQL)),"trbBXX",.T.,.F.)

		If ! trbBXX->( eof() )

			BXX->( dbGoTo(trbBXX->REC) )

			BXX->(reclock("BXX", .f.))
			BXX->(dbDelete())
			BXX->(msUnlock())

			::WSNULL := "true|Arquivo excluido com sucesso!"
		endIf

		trbBXX->(DbCloseArea())

		//³Estou deletando ele do banco de conhecimento
		SplitPath( ::DirArqIn,,, @cFile, @cExten )

		If FindFunction( "MsMultDir" ) .And. MsMultDir()
			cDirDocs := MsRetPath( cFile+cExten )
		Else
			cDirDocs := MsDocPath()
		Endif

		If file(PLSMUDSIS(cDirDocs + "\" + cFile+cExten))
			fErase(PLSMUDSIS(cDirDocs + "\" + cFile+cExten))
		Endif

		ACB->(DbSetOrder(2))
		while ACB->(MsSeek(xFilial('ACB')+Upper( cFile + cExten )))
			AC9->(DbSetORder(1))
			while AC9->(MsSeek(xFilial("AC9")+ACB->ACB_CODOBJ))
				AC9->(RecLock( "AC9", .F. ))
				AC9->(DbDelete())
				AC9->( MsUnlock() )
			Enddo
			ACB->(RecLock( "ACB", .F. ))
			ACB->(DbDelete())
			ACB->( MsUnlock() )
		Enddo

		if file(cDirUpload+cFile+cExten)
			fErase(cDirUpload+cFile+cExten)
		endIf
		if file(cDirBkp+cFile+cExten)
			fErase(cDirBkp+cFile+cExten)
		endIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim do metodo														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getInProces³Autor ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³verifica se ainda esta em processo de transferencia de guia  |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD posicione WSRECEIVE userCode,Alias,Chave,CmdChave,Idx WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= getArea()
	LOCAL lRetorno	:= .t.

	DEFAULT ::WSNULL := ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Se tem direito para executar o metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	if PrtChkUser( ::userCode ,"PLSXFUN","posicione" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ cria protocolo
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		if (::Alias)->(FieldPos(::CmdChave)) > 0
			cRet 	 := "true|"+alltrim(Posicione(::Alias,::Idx,xFilial(::Alias)+::Chave,::CmdChave))
		else
			cRet 	 := "true|"
		Endif
		::WSNULL := cRet

	else
		lRetorno := .f.
		setSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Fim do metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lRetorno

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getInProces³Autor ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³verifica se ainda esta em processo de transferencia de guia  |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ppImpRel WSRECEIVE userCode,Chave,FunName WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= getArea()
	LOCAL aChave	:= {} // Campos da chave
	LOCAL aRecTit	:= {} // Recno dos titulos selecionados
	LOCAL aParF		:= {} // parametros pra função (Devem ser montados na ordem de recebimento da função)
	LOCAL lRetorno	:= .t.
	LOCAL nLin			:= 0
	LOCAL cTitRel		:= ""
	LOCAL cPathSrv 	:= lower(getMV("MV_RELT"))
	LOCAL aTitulos	:= {{"PLSRELDPM", "Demonstrativo de Pagamento"} ,; // Titulo dos relatorios por rotina
		{"PLSRELDAC", "Demonstrativo de Análise de Processamento de Contas"},;
		{"PLSRELDPO", "Demonstrativo de Pagamento Odontologico"},;
		{"PLSRELEPM", "Extrato de Pagamento da RDA"}}
	Local lRetUsu		:= .t.
	Local cMensag 		:= ""

	DEFAULT ::WSNULL := ""

	//PE para troca do nome de exibição dos relatorios no email por Rotina
	If ExistBlock("PLIMPRELT")
		aTitulos := ExecBlock("PLIMPRELT",.F.,.F.,{::FunName})
	EndIf

	//Se tem direito para executar o metodo
	if PrtChkUser( ::userCode ,"PLSXFUN","ppImpRel" )

		aChave 	:= PSplitAdvpl(::Chave, "|") // 1 - RDA, 2 - Email, 3 - Recnos SE2, 4 - Tipo Relatório: '1' = PDF ou '2' = XML, 5 - Somente Glosa ?
		aRecTit	:= PSplitAdvpl(aChave[3], ",") //RecnoS SE2

		BAU->(DbSetOrder(1))
		If BAU->(MsSeek(xFilial("BAU")+aChave[1]))

			If Empty(BAU->BAU_EMAIL) .and. ! Empty(aChave[2])

				BAU->(recLock("BAU", .f.))
				BAU->BAU_EMAIL := alltrim(aChave[2])
				BAU->(MsUnlock())

			EndIf

		EndIf

		If Len(aRecTit) > 0 .and. lRetUsu

			For nLin := 1 to Len(aRecTit)

				If funname$'PLSRELDPM/PLSRELEPM' //Demonstrativo de Pagamento/Extrato de Pagamento da RDA

					cAlias := strTran(Substr(aRecTit[nLin],1,4),"'","")

					DbSelectArea(cAlias)
					DbGoTo(Val(StrTran(Substr(aRecTit[nLin],5,len(aRecTit[nLin])),"'","")))//retira aspas e posiciona no registro

					If cAlias =="SE2"
						aParF := {aChave[1], SE2->E2_ANOBASE, SE2->E2_MESBASE, .T.,cPathSrv, SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),"SE2"} // Montagem dos parametros que a função vai receber  // Ex.: PLSRELDPM(cCodRda,cAnoW,cMesW,lWeb,cPathW,cNmTitPg)
					Else
						aParF := {aChave[1], Substr(SC7->C7_LOTPLS,1,4), Substr(SC7->C7_LOTPLS,5,2), .T.,cPathSrv, SC7->C7_NUM,"SC7"} // Montagem dos parametros que a função vai receber  // Ex.: PLSRELDPM(cCodRda,cAnoW,cMesW,lWeb,cPathW,cNmTitPg)
					Endif

				ElseIf funname == "PLSRELDAC" //Demonstrativo de Análise de Processamento de Contas

					cAlias := StrTran(Substr(aRecTit[nLin],1,4),"'","")

					DbSelectArea(cAlias)
					DbGoTo(Val(StrTran(Substr(aRecTit[nLin],5,len(aRecTit[nLin])),"'","")))//retira aspas e posiciona no registro

					aParF := {aChave[1], BCI->BCI_ANO, BCI->BCI_MES,.T.,cPathSrv, BCI->BCI_CODPEG,"BCI", .F., aChave[5]} // Montagem dos parametros que a função vai receber  // Ex.: PLSRELDPM(cCodRda,cAnoW,cMesW,lWeb,cPathW,cNmTitPg)

					//Demonstrativo de Pagamento Odontologico
				Else
					DbSelectArea("SE2")
					DbGoTo(Val(StrTran(Substr(aRecTit[nLin],5,len(aRecTit[nLin])),"'","")))//retira aspas e posiciona no registro
					aParF := {aChave[1], SE2->E2_ANOBASE, SE2->E2_MESBASE, .T.,cPathSrv, SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)} // Montagem dos parametros que a função vai receber  // Ex.: PLSRELDPM(cCodRda,cAnoW,cMesW,lWeb,cPathW,cNmTitPg)
				Endif

				cTitRel := aTitulos[aScan( aTitulos, { |x| x[1] == ::FunName } ), 2] // Busca no array o titulo do relatorio de acordo com a rotina do mesmo

				//"Relatorios processamento de contas"
				// EXECUTA O STARTJOB PLSTJBMAIL(cNomRot,cMailSend, cTitRel, lExcel, aParFuncao, cTipoRel)
				PLSTJBMAIL(::FunName,aChave[2], cTitRel, .F., aParF, aChave[4] )

			Next nLin

			cRet 	 := "true|"
			::WSNULL := cRet

		Else
			lRetorno := .f.
			cMensag	 += "Não autorizado a utilização do metodo"
			setSoapFault( "",cMensag )
		EndIf

	else
		lRetorno := .f.
		setSoapFault( "", "Não foram informados os parametros necessários" )
	endIf

	RestArea( aArea )

Return lRetorno

//PSplitAdvpl - Funcao que retorna um array a partir de uma string de
// separacao conforme passo pelo parametro (similir Split JavaScript)
Static Function PSplitAdvpl(cString, cCharSep)
	Local aArray	:= {}
	Local cStrAtu	:= ""
	Local nAt		:= 0

	If SubStr(cString, 1,1) == cCharSep //remove caracter de separação no inicio
		cString := Alltrim(SubStr(cString, 2,Len(cString)))
	EndIf

	If SubStr(cString, Len(cString),1) == cCharSep //remove caracter de separação no fim
		cString := Alltrim(SubStr(cString, 1,Len(cString)-1))
	EndIf

	While (nAt := At(cCharSep, cString)) > 0

		cStrAtu := Alltrim(SubStr(cString, 1,At(cCharSep, cString)-1 ))

		If ! Empty(cStrAtu)
			AaDD(aArray,  Alltrim(SubStr(cString, 1,At(cCharSep, cString)-1 )))
		EndIf

		cString := Alltrim(SubStr(cString, At(cCharSep, cString)+1,Len(cString) ))

	EndDo

	If ! Empty(Alltrim(cString))
		AaDD(aArray,  cString)
	EndIf

Return(aArray)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ PLSGETMV ºAutor  ³ TOTVS S/A          º Data ³  16/08/2013 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Um metodo para retornar o valor de um parametro SX6        º±±
±±ºParametro:³ cParMV - parametro a ser consultado                        º±±
±±º          ³ cDefMV - valor padrao para parametro inexistente           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
WSMETHOD PLSGETMV WSRECEIVE cParMV,cDefMV WSSEND cRetMv WSSERVICE PLSXFUN
	Default ::cRetMv := ""

	If !Empty(cParMV)
		::cRetMV := GetNewPar(cParMV,cDefMV)
	EndIf

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ExCarPortal    ³Autor  ³ Thiago Guilherme  ³ Data ³28.11.2013 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os procedimentos que possuem carência que poderão ser³±±
±±³				visualizados
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ExCarPortal WSRECEIVE UserCode WSSEND ProcCarPort WSSERVICE PLSXFUN
	LOCAL nI        := 1
	LOCAL aArea	  := GetArea()
	LOCAL lRetorno  := .T.
	LOCAL cExiCaren := "1"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "ExCarPortal" )

		If BR8->(FieldPos("BR8_CARPRT")) > 0

			dbSelectArea("BR8")
			BR8->(DbSetOrder(9))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Retorna os procedimentos que possuem carencia e que poderao ser vistos  ³
			// no portal.
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If dbSeek(xFilial("BR8")+cExiCaren)

				::ProcCarPort := {}

				While !BR8->(EOF()) .AND. BR8->(BR8_FILIAL+BR8_CARPRT) == xFilial("BR8")+cExiCaren

					AaDd( ::ProcCarPort, WsClassNew( "SCarPor" ) )
					::ProcCarPort[nI]:CodPro   := AllTrim(BR8->BR8_CODPSA)
					::ProcCarPort[nI]:DescPro  := SubSTR(BR8->BR8_DESCRI,1, 50)
					::ProcCarPort[nI]:REC      := ALLTRIM(STR(br8->(recno())))
					nI++
					BR8->(dbSkip())
				EndDo
			EndIf
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DadGrpFam    ³Autor  ³ Thiago Guilherme  ³ Data ³08.01.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os beneficiários que fazem parte do grupo familiar   ³±±
±±³
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DadGrpFam WSRECEIVE UserCode, cUsrLogin WSSEND DadosGrpFam WSSERVICE PLSXFUN
	LOCAL nI        := 1
	LOCAL aArea	  := GetArea()
	LOCAL lRetorno  := .T.
	LOCAL cSQL
	LOCAL cCodFam
	LOCAL dBloqueio	:= FsDateConv(dDataBase,"YYYYMMDD")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "DadGrpFam" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³retorna a matricula do beneficiario que esta cadastrado para o login	³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		cSQL := "SELECT B49_BENEFI "
		cSQL += "FROM " + RetSQLName("B49")
		cSQL += " WHERE B49_CODUSR = '" + cUsrLogin + "' AND "
		cSQL += " D_E_L_E_T_ = ' '"

		PLSQuery(cSQL,"TrbRetTit")

		if !TrbRetTit->(EOF())

			cCodFam := SUBSTR(TrbRetTit->B49_BENEFI,1,14)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³retorna os beneficiarios da familia principal
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			cSQL := "SELECT BA1_CODINT, BA1_CODEMP, BA1_MATRIC, BA1_TIPREG, BA1_DIGITO, BA1_NOMUSR, BA1_TIPUSU"
			cSQL += " FROM " + RetSQLName("BA1")
			cSQL += " WHERE BA1_CODINT + BA1_CODEMP + BA1_MATRIC = '" + cCodFam + "' "
			cSQL += " AND (BA1_DATBLO = ' ' OR BA1_DATBLO > '" + dBloqueio + "')"
			cSQL += " AND D_E_L_E_T_ = ' '"
			PLSQuery(cSQL,"TrbRetFMP")

			If TrbRetFMP->(EoF())
				Return lRetorno := .F.
			EndIF

			While !TrbRetFMP->(EOF())

				AaDd( ::DadosGrpFam, WsClassNew( "SDadGrp" ) )
				::DadosGrpFam[nI]:Matricl := TrbRetFMP->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)
				::DadosGrpFam[nI]:NomeBnf := TrbRetFMP->BA1_NOMUSR
				nI++
				TrbRetFMP->(dbSkip())
			EndDo

			If BA3->(FieldPos("BA3_GRPFAM")) > 0

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³retorna os dados dos beneficiarios que fazem parte do grupo familiar
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				TrbRetFMP->(dbGoTop())

				cSQL := "SELECT BA3_CODINT, BA3_CODEMP, BA3_MATRIC "
				cSQL += "FROM " + RetSQLName("BA3")
				cSQL += " INNER JOIN " + RetSQLName("BA1")
				cSQL += " ON BA1_CODINT + BA1_CODEMP + BA1_MATRIC = BA3_CODINT + BA3_CODEMP + BA3_MATRIC"
				cSQL += " WHERE BA3_GRPFAM = '" + TrbRetFMP->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO) + "'"
				cSQL += " AND " + RetSQLName("BA3")+".D_E_L_E_T_ = '' AND " + RetSQLName("BA1")+".D_E_L_E_T_ = ''"
				cSQL += " GROUP BY BA3_CODINT, BA3_CODEMP, BA3_MATRIC"
				PLSQuery(cSQL,"TrbRetGpFm")


				cSQL := "SELECT BA1_CODINT, BA1_CODEMP, BA1_MATRIC, BA1_TIPREG, BA1_DIGITO, BA1_NOMUSR, BA1_TIPUSU"
				cSQL += " FROM " + RetSQLName("BA1")
				cSQL += " WHERE BA1_CODINT + BA1_CODEMP + BA1_MATRIC IN( "

				If !TrbRetGpFm->(EOF())

					While !TrbRetGpFm->(EOF())
						cSQL += TrbRetGpFm->(BA3_CODINT + BA3_CODEMP + BA3_MATRIC)

						TrbRetGpFm->(dbSkip())

						if TrbRetGpFm->(EOF())
							cSQL += ")"
						Else
							cSQL += ","
						EndIf
					EndDo

					cSQL += " AND D_E_L_E_T_ = ''"
					PLSQuery(cSQL,"TrUsrGrp")

					While !TrUsrGrp->(EOF())

						AaDd( ::DadosGrpFam, WsClassNew( "SDadGrp" ) )
						::DadosGrpFam[nI]:Matricl := TrUsrGrp->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)
						::DadosGrpFam[nI]:NomeBnf := TrUsrGrp->BA1_NOMUSR
						nI++
						TrUsrGrp->(dbSkip())
					EndDo

					TrUsrGrp->(dbCloseArea())
				EndIf

				TrbRetGpFm->(dbCloseArea())

			EndIf
		EndIf

		TrbRetFMP->(dbCloseArea())
		TrbRetTit->(dbCloseArea())

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CarenBnf    ³Autor  ³ Thiago Guilherme  ³ Data ³08.01.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os dados de carencia do beneficiario				   ³±±
±±³
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD CarenBnf WSRECEIVE UserCode, cMatrc, cRecno WSSEND DadCarenc WSSERVICE PLSXFUN
	LOCAL lRetorno  := .T.
	LOCAL aRDA 	  := PLSDADRDA(PlsIntPad(),GetNewPar("MV_PLSRDAG","999999"),"1",dDatabase)
	LOCAL dData	  := dDatabase
	LOCAL cHora	  := TIME()
	LOCAL aUsr 	  := PLSDADUSR(cMatrc,'1',.F.,dDatabase,,,"NAO_VALIDAR_CARTAO")
	LOCAL aRetCar
	LOCAL cSQL
	LOCAL nI
	LOCAL nQtdCrt
	LOCAL aArea	  := GetArea()
	LOCAL nCont	  := 1
	LOCAL aCriTerm
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "CarenBnf" )

		cSQL := "SELECT BR8_CODPAD, BR8_CODPSA "
		cSQL += "FROM " + RetSQLName("BR8")
		cSQL += " WHERE R_E_C_N_O_ = " + cRecno
		PLSQuery(cSQL,"TrbRetCar")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Retorna as carências														   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRetCar := PLSAUTP(dData,cHora,TrbRetCar->BR8_CODPAD,TrbRetCar->BR8_CODPSA,1,aUsr,0,aRDA,"1",,,.T.,"1",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,;
			,,,,.F.,,,,NIL,.F.,,,,,,,,,,,,,,,,,,,,,,,.F.)

		TrbRetCar->(dbCloseArea())
		nQtdCrt := len(aRetCar[2])

		If !aRetCar[1]

			For nI := 1 To nQtdCrt

				If !EMPTY(aRetCar[2][nI][1] )
					aCriTerm := PLSRETCRI( AllTrim(aRetCar[2,nI,1]))
					aRetCar[2,nI,1] :=  aCriTerm[1,1]
					aRetCar[2,nI,2] :=  aCriTerm[1,2]
				EndIF

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Filtra as críticas que devem ser retornadas para o beneficiario			 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !("Nível" $ aRetCar[2][nI][2]) .AND. (LEN(aRetCar[2][nI][2]) > 3)

					AaDd( ::DadCarenc, WsClassNew( "SRetCaren" ) )

					If !EMPTY(aRetCar[2][nI][2] )
						::DadCarenc[nCont]:cMsg  := aRetCar[2][nI][2]
					Else
						::DadCarenc[nCont]:cMsg  := ""
					endIf

					If !EMPTY(aRetCar[2][nI][3])
						::DadCarenc[nCont]:cInfo := aRetCar[2][nI][3]
					Else
						::DadCarenc[nCont]:cInfo := ""
					EndIf

					nCont++
				EndIf
			Next
		Else

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se nao existir críticas, o procedimento esta liberado   					 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			AaDd( ::DadCarenc, WsClassNew( "SRetCaren" ) )
			::DadCarenc[1]:cMsg  := ""
			::DadCarenc[1]:cInfo := ".T."
		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetAut    ³Autor  ³ Thiago Guilherme      ³ Data ³27.01.14	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna as noticias disponiveis no portal para o prestador   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetNot WSRECEIVE UserCode, cCodEsp, cCodNotic, cCodRDA, cUserCod, cOpcao WSSEND Noticia WSSERVICE PLSXFUN
	LOCAL nI          := 1
	LOCAL nJ          := 1
	LOCAL lRetorno	:= .T.
	LOCAL aRet	 		:= {}
	LOCAL aRetArq		:= {}
	LOCAL aArea		:= BPL->(GetArea())
	LOCAL cCodNot		:= ""
	LOCAL cSQL			:= ""
	LOCAL cSQL2		:= ""
	LOCAL cEspc		:= ""
	LOCAL nReg
	LOCAL aDadUsr		:= {}
	LOCAL cDir	 	:= getWebDir()
	LOCAL nQtdArq
	LOCAL nQtdBco
	LOCAL lExtArq := .F.
	LOCAL nCount
	LOCAL nCountArq := 0

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "RetNot" ) //consome uma licença, checa integridade de acesso

		If cOpcao == "1"

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Retorna os títulos das notícias 											   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			If EMPTY(cUserCod)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Seleciona as especialidades dos prestadores    						   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL := "SELECT BBF_CODIGO,BBF_CDESP "
				cSQL += " FROM " + RetSQLName("BBF")
				cSQL += " WHERE BBF_FILIAL = '" + xFilial("BBF")+"' "
				cSQL += " AND BBF_CODIGO IN (" + cCodRDA  + ")"
				cSQL += " AND " + RetSqlName("BBF")+".D_E_L_E_T_ = ''"

				PLSQuery(cSQL,"TrbEspPrt")

				While !TrbEspPrt->(EOF())

					cEspc += TrbEspPrt->BBF_CDESP + ","
					TrbEspPrt->(dbSkip())
				EndDo

				nReg := len(cEspc)

				cEspc := STUFF(cEspc , nReg, 1, "")

				TrbEspPrt->(dbCloseArea())

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verifica a existencia de noticias para as especialidades				   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL2 := "SELECT BAQ_CODESP, BAQ_DESCRI, BPM_CODIGO"
				cSQL2 += " FROM " + RetSQLName("BAQ")
				cSQL2 += " INNER JOIN " +RetSQLName("BPM")
				cSQL2 += " ON BAQ_CODESP = BPM_CODESP"
				cSQL2 += " WHERE BPM_CODESP IN( " + cEspc + ") AND "
				cSQL2 += RetSqlName("BPM")+".D_E_L_E_T_ = '' AND " + RetSqlName("BAQ")+".D_E_L_E_T_ = ''
				cSQL2 += "GROUP BY BAQ_CODESP, BAQ_DESCRI, BPM_CODIGO"

				PLSQuery(cSQL2,"TrbReTEspc")

				nI := 0

				While !TrbReTEspc->(EOF())

					cCodNot += TrbReTEspc->BPM_CODIGO + ","
					TrbReTEspc->(dbSkip())
				EndDo

				TrbReTEspc->(dbCloseArea())

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Retorna as noticias para os Prestadores especificos			            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL:= " SELECT BPO_CODIGO"
				cSQL+= " FROM " + RetSQLName("BPO")
				cSQL+= " WHERE BPO_CODRDA IN (" + cCodRDA + ")
				cSQL+= " AND " + RetSqlName("BPO")+".D_E_L_E_T_ = ''"
				PLSQuery(cSQL,"TrbRetBPO")

				nI := 0

				While !TrbRetBPO->(EOF())

					cCodNot += If ( !TrbRetBPO->BPO_CODIGO $ cCodNot, TrbRetBPO->BPO_CODIGO + ",",'')
					TrbRetBPO->(dbSkip())
				EndDo

				TrbRetBPO->(dbCloseArea())

				nReg 	 := len(cCodNot)
				cCodNot := If(EMPTY(cCodNot),"''", STUFF(cCodNot , nReg, 1, ""))

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Retorna as noticias disponiveis para as especialidades				   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL:= "SELECT BPL_FILIAL,BPL_CODIGO,BPL_TITULO,BPL_VIGINI,BPL_VIGFIN"
				cSQL+= " FROM " + RetSQLName("BPL")
				cSQL+= " WHERE BPL_CODIGO IN( " + cCodNot + ") "
				cSQL+= " AND BPL_TIPUSU IN(1,3)"
				cSQL+= " AND BPL_VIGINI <= '" + DTOS(dDataBase) + "' AND BPL_VIGFIN >= '" + DTOS(dDataBase) + "'"
				cSQL+= " AND " + RetSqlName("BPL")+".D_E_L_E_T_ = '' "

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Quando não existir especialidade e nem prestador cadastrado em uma
				// noticia, entao todas as especialidades visualizarao a noticia           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL += " OR  NOT EXISTS( SELECT BPM_CODIGO FROM " + RetSQLName("BPM") + " WHERE BPL_CODIGO = BPM_CODIGO AND D_E_L_E_T_ ='' ) AND "
				cSQL +=      "NOT EXISTS( SELECT BPO_CODIGO FROM " + RetSQLName("BPO") + " WHERE BPL_CODIGO = BPO_CODIGO AND D_E_L_E_T_ = '')"
				cSQL += " AND " + RetSqlName("BPL") + ".D_E_L_E_T_ = '' "
				cSQL += " AND BPL_VIGINI <= '" + DTOS(dDataBase) + "' AND BPL_VIGFIN >= '" + DTOS(dDataBase) + "' AND BPL_TIPUSU IN(1,3)"

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Agrupamento e ordenação pela ultima noticia inclusa, pois o portal    ³
				// sempre mostrará as ultimas dez notícias inclusas
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL+= " GROUP BY BPL_FILIAL,BPL_CODIGO,BPL_TITULO,BPL_VIGINI,BPL_VIGFIN"
				cSQL+= " ORDER BY BPL_CODIGO DESC"
				PLSQuery(cSQL,"TrbRetNot")
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³retorna a matricula do beneficiario que esta cadastrado para o login	³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL := "SELECT B49_BENEFI "
				cSQL += "FROM " + RetSQLName("B49")
				cSQL += " WHERE B49_CODUSR = '" + cUserCod + "' AND "
				cSQL += " D_E_L_E_T_ = ' '"
				PLSQuery(cSQL,"TrbRetTit")

				if !TrbRetTit->(EOF())

					aDadUsr := PLSDADUSR(TrbRetTit->B49_BENEFI,'1',.F.,dDatabase,,,"NAO_VALIDAR_CARTAO")

					cSQL:= " SELECT BPP_CODIGO"
					cSQL+= " FROM " + RetSQLName("BPP")
					cSQL+= " WHERE BPP_CODPLA = '" + IIF(LEN(aDadUsr) < 11, GetNewPar("MV_CODPLAP",""), aDadUsr[11]) + "'"
					cSQL+= " AND " + RetSqlName("BPP")+".D_E_L_E_T_ = ''"
					PLSQuery(cSQL,"TrbRetBPP")

					While !TrbRetBPP->(EOF())

						cCodNot += If ( !TrbRetBPP->BPP_CODIGO $ cCodNot, TrbRetBPP->BPP_CODIGO + ",",'')
						TrbRetBPP->(dbSkip())
					EndDo

					TrbRetBPP->(dbCloseArea())

					//retira a virgula na última posição
					cCodNot := If(EMPTY(cCodNot),"''", STUFF(cCodNot , len(cCodNot), 1, ""))

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Retorna as noticias disponiveis para o beneficiario					   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cSQL:= "SELECT BPL_FILIAL,BPL_CODIGO,BPL_TITULO,BPL_VIGINI,BPL_VIGFIN"
					cSQL+= " FROM " + RetSQLName("BPL")
					cSQL+= " WHERE BPL_CODIGO IN( " + cCodNot + ") "
					cSQL+= " AND BPL_TIPUSU IN(2,3)"
					cSQL+= " AND BPL_VIGINI <= '" + DTOS(dDataBase) + "' AND BPL_VIGFIN >= '" + DTOS(dDataBase) + "'"
					cSQL+= " AND " + RetSqlName("BPL")+".D_E_L_E_T_ = '' "

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Quando não existir produto cadastrado em uma
					// noticia, entao todos os beneficiários visualizarão a noticia           ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cSQL+= " OR  NOT EXISTS( SELECT BPP_CODIGO FROM " + RetSQLName("BPP")
					cSQL+= " WHERE BPL_CODIGO = BPP_CODIGO "
					cSQL+= " AND " + RetSqlName("BPP") + ".D_E_L_E_T_ ='') AND " + RetSqlName("BPL") + ".D_E_L_E_T_ = '' "
					cSQL+= " AND BPL_VIGINI <= '" + DTOS(dDataBase) + "' AND BPL_VIGFIN >= '" + DTOS(dDataBase) + "' AND BPL_TIPUSU IN(2,3)"
					cSQL+= " GROUP BY BPL_FILIAL,BPL_CODIGO,BPL_TITULO,BPL_VIGINI,BPL_VIGFIN"
					cSQL+= " ORDER BY BPL_CODIGO DESC"

					PLSQuery(cSQL,"TrbRetNot")
				EndIf

				TrbRetTit->(dbCloseArea())
			EndIf

			If (Select("TrbRetNot") > 0)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Monta matriz de retorno												   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				While !TrbRetNot->( Eof() )
					cNotic := BPL->BPL_NOTICI

					dbSelectArea("BPL")
					dbSetOrder(1)
					If BPL->( MsSeek( xFilial( "BPL" ) + TrbRetNot->BPL_CODIGO) )
						cNotic := BPL->BPL_NOTICI
					EndIf

					AaDd(aRet,{TrbRetNot->BPL_VIGINI,; 	 					//Data Inicial
						TrbRetNot->BPL_VIGFIN,; 							//Data Final
						TrbRetNot->BPL_TITULO,;							//Titulo
						cNotic, TrbRetNot->BPL_CODIGO} )

					TrbRetNot->( DbSkip() )
				EndDo

				TrbRetNot->( DbCloseArea() )
			EndIf

			If !EMPTY(aRet)
				If Len(aRet) > 0
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Guias													 			      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					::Noticia := {}

					For nI := 1 To Len( aRet )
						AaDd( ::Noticia, WsClassNew( "SNoticia" ) )//cria uma estrutura e alienta c o contreudo do array aRet
						::Noticia[nI]:DtNotIni 	:= aRet[nI,1]   //essa estrutura deve ser declarada no cabeçalho do webservice
						::Noticia[nI]:DtNotFin 	:= aRet[nI,2]   //com base em outra etrutura SMatAut
						::Noticia[nI]:TituloNot 	:= aRet[nI,3]
						::Noticia[nI]:TextoNot	:= aRet[nI,4]
						::Noticia[nI]:cCodNot		:= aRet[nI,5]
						::Noticia[nI]:cEspec     := cEspc
						::Noticia[nI]:ArqNot  := {}
					Next
				Else
					lRetorno := .F.
					SetSoapFault( "", "Nenhuma Noticia encontrada para o Usuário ( "+Iif( Len(::UserCardNumber)>16 ,Transform(::UserCardNumber, "@R 9999.9999.999999.99-9" ),Transform(::UserCardNumber, "@R 999.9999.999999.99-9" ) )+" )" )
				EndIf
			EndIf

		ElseIf cOpcao == "2"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Retornar as noticias e os anexos de acordo com o título selecionado     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			dbSelectArea("BPL")
			dbSetOrder(1)

			If BPL->( MsSeek( xFilial( "BPL" ) + cCodNotic) ) // TROCAR PARA CODIGO DA NOTICIA
				While xFilial( "BPL" ) + cCodNotic == BPL->(BPL_FILIAL+BPL_CODIGO)

					If cOpcao == "2"

						dbSelectArea("AC9")
						dbSetOrder(2)//AC9_FILIAL, AC9_ENTIDA, AC9_FILENT, AC9_CODENT, AC9_CODOBJ
						If AC9->( MsSeek( xFilial( "AC9" ) + "BPL"+ BPL->(BPL_FILIAL+BPL_FILIAL+BPL_CODIGO)))

							While (xFilial( "AC9" )+ AllTrim(AC9_ENTIDA+AC9_FILENT+AC9_CODENT)) == ;
									(xFilial( "AC9" )+'BPL'+ BPL->(BPL_FILIAL+BPL_FILIAL+BPL_CODIGO))

								dbSelectArea("ACB")
								dbSetOrder(1)//ACB_FILIAL, ACB_CODOBJ
								If ACB->( MsSeek( xFilial( "ACB" ) + AC9->AC9_CODOBJ) )

									AaDd(aRetArq,{ACB->ACB_CODOBJ, ACB->ACB_OBJETO} )
								EndIf
								AC9->(dbSkip())
							EndDo
						EndIf
					EndIf

					AaDd(aRet,{BPL->BPL_TITULO,	BPL->BPL_NOTICI, BPL->BPL_CODIGO} )

					BPL->( DbSkip() )
				EndDo
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica o Retorno													   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Len(aRet) > 0
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Guias													 			      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				::Noticia := {}

				For nI := 1 To Len( aRet )
					AaDd( ::Noticia, WsClassNew( "SNoticia" ) )//cria uma estrutura e alienta c o contreudo do array aRet
					::Noticia[nI]:TituloNot 	:= aRet[nI,1]
					::Noticia[nI]:TextoNot	:= aRet[nI,2]
					::Noticia[nI]:cCodNot		:= aRet[nI,3]
					::Noticia[nI]:ArqNot  := {}

					If cOpcao == "2"

						cDir := cDir + "imagens-pls\arquivonoticia\"+ cCodNotic + "\"

						aArqDir := DIRECTORY(cDir + PLSMUDSIS("\*.*"))

						nQtdArq := Len(aArqDir)
						nQtdBco := Len(aRetArq)

						If nQtdArq > 0

							For nCount := 1 To nQtdArq

								For nJ := 1 To nQtdBco

									If ALLTRIM(aRetArq[nJ,2]) == STRTRAN(aArqDir[nCount][1], "_", " ")
										lExtArq := .T.

										nCountArq += 1

										AaDd( ::Noticia[nI]:ArqNot, WsClassNew( "SArqNot" ) )
										::Noticia[nI]:ArqNot[nCountArq]:CodObj	:= aRetArq[nJ,1]
										::Noticia[nI]:ArqNot[nCountArq]:Objeto	:= aRetArq[nJ,2]

										EXIT
									EndIf
								Next

								If !lExtArq

									If aArqDir[nCount][5] == "A"
										fErase(cDir+aArqDir[nCount][1])
									EndIf
								Else
									lExtArq := .F.
								EndIf
							Next
						EndIf
					EndIf
				Next
			Else
				lRetorno := .F.
				SetSoapFault( "", "Nenhuma Noticia encontrada para o Usuário ( "+Iif( Len(::UserCardNumber)>16 ,Transform(::UserCardNumber, "@R 9999.9999.999999.99-9" ),Transform(::UserCardNumber, "@R 999.9999.999999.99-9" ) )+" )" )
			EndIf
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ExNotPort    ³Autor  ³ Thiago Guilherme   ³ Data ³28.01.14	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna as noticias disponiveis no portal para o prestador   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ExNotPort WSRECEIVE UserCode WSSEND ExisTbl WSSERVICE PLSXFUN

	LOCAL aArea	  := GetArea()
	LOCAL lRetorno  := .T.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "ExNotPort" )

		If PLSALIASEX("BPL") .AND. GetNewPar("MV_NOTPRT",.F.)
			::ExisTbl:= .T.
		Else
			::ExisTbl:= .F.
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetVlrTiss ³Autor  ³ Alexander	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o procedimento e valido						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetVlrTiss WSRECEIVE UserCode,TermoTiss WSSEND WSNULL WSSERVICE PLSXFUN

	LOCAL lRetorno 		:= .T.
	LOCAL aArea    		:= GetArea()

	//LOCAL cTissVer		:= PLSTISSVER()


	DEFAULT ::WSNULL	:= ""

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode , "PLSXFUN", "GetVlrTiss" )

		If Valtype(TermoTiss:VerTiss) <> 'U' .AND. TermoTiss:VerTiss >= '3'
			::WSNULL := "true|"
			::WSNULL += TermoTiss:Campo + "|" + ALLTRIM(PLSRETTIS("",TermoTiss:CodAlias,TermoTiss:VlrProt, .F., /*cChave*/) )
		Else
			::WSNULL := "true|"
			::WSNULL += TermoTiss:Campo + "|" + TermoTiss:cVlrProt
		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetCmbFormT ³Autor  ³ Rogerio Machado Tabosa ³ Data ³01.02.2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os campos do TIpo Combo da GUIA dinamica do Portal	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetCmbFormT WSRECEIVE UserCode,GuiaTiss WSSEND RetGuiaTiss WSSERVICE PLSXFUN
	LOCAL aArea    	:= GetArea()
	LOCAL nCmp		:= 0
	LOCAL cTipGui	:= ""
	LOCAL cVerTiss	:= ""
	LOCAL cCampo	:= ""
	LOCAL cBOXRet	:= ""
	LOCAL lRetorno 	:= .T.

	If PrtChkUser( ::UserCode , "PLSXFUN", "GetCmbFormT" )

		//VARIÁVEL DE RETORNO
		::RetGuiaTiss := WsClassNew( "SRetGuiaTiss" )
		::RetGuiaTiss:RetCmbsGuia := {}

		cTipGui := GuiaTiss:TipGui
		cVerTiss:= GuiaTiss:VerTiss

		B7B->(dbSetOrder(1))
		If B7B->( MsSeek( xFilial("B7B") + cTipGui + cVerTiss) )

			While ! B7B->(eof()) .and. xFilial("B7B")+cTipGui+cVerTiss == B7B->(B7B_FILIAL+B7B_TIPGUI+B7B_TISVER)

				cCampo 	:= AllTrim(B7B->B7B_NOMXMO)
				cBOXRet := Alltrim(B7B->B7B_CBOX)

				//Alimenta a Struct com os combos
				If B7B->B7B_TIPO == 'C'

					//Adiciona o grid a estrutura
					AaDd( ::RetGuiaTiss:RetCmbsGuia, WsClassNew( "SRetCmbsGuia" ) )
					nCmp := Len(::RetGuiaTiss:RetCmbsGuia)
					::RetGuiaTiss:RetCmbsGuia[nCmp]:CampoG := cCampo
					::RetGuiaTiss:RetCmbsGuia[nCmp]:CBOX := cBOXRet

				EndIf

				B7B->(DbSkip())
			EndDo

		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetFormTiss ³Autor  ³ Everton M. Fernandes   ³ Data ³06.03.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Monta formulario da guia no padrao da TISS configurado  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetFormTiss WSRECEIVE UserCode,GuiaTiss,Tipo,cRecno,DtLimRetro,MsnBloInter,DigiGui,AltCpAT,RecnoBD5,NumGuiRef,TpGuiRef,RecGuiRef,Intercambio,DtJs WSSEND RetGuiaTiss WSSERVICE PLSXFUN
	Local lRetorno 		:= .T.
	Local lContinua		:= .T.
	Local aArea   		:= GetArea()
	Local oForm			:= Nil
	Local oTabPriFP		:= Nil
	Local oHtml			:= Nil
	Local RetGuia		:= NIL
	Local cGrids		:= ""
	Local cDesGri		:= ""
	local cCodInt		:= PlsIntPad()
	Local aDadosGuia	:= {}
	Local aAreaBCL  	:= {}
	Local aAreaB7A  	:= {}
	Local aAreaB7B  	:= {}
	Local aCustomBtn 	:= {}
	Local cDigiGui		:= IIF(ValType(::DigiGui) == "C", AllTrim(::DigiGui), "")
	Local lTpAlt		:= IIF(ValType(::AltCpAT) == "L", AltCpAT, .F. )
	Local lIntercambio	:= IIF(ValType(::Intercambio) == "L", ::Intercambio, .F. )
	Local lPLPRGSN 		:= IIF(GuiaTiss:TipGui == "11",GetNewPar("MV_PLPRGSN", .F.),.F.)

	Default ::RecnoBD5 	:= ""
	Default ::DtJs		:= ""

	//Checa Usuário
	If PrtChkUser( ::UserCode , "PLSXFUN", "GetFormTiss" )

		//VARIÁVEL DE RETORNO
		::RetGuiaTiss 			:= WsClassNew( "SRetGuiaTiss" )
		::RetGuiaTiss:CmpGuia 	:= {}

		//VARIAVEL QUE É MANIPULADA
		RetGuia 		:= WsClassNew( "SRetGuiaTiss" )
		RetGuia:CmpGuia := {}

		B7C->(DbSetOrder(1))
		B7B->(DbSetOrder(3))

		BCL->(DbSetOrder(1))
		BCL->(DbGoTop())

		If BCL->(MsSeek(xFilial("BCL") + cCodInt + GuiaTiss:TipGui))

			cFuncLoad := AllTrim(BCL->BCL_PORLOA)

			if Empty(cDigiGui)
				cFuncVoltar := AllTrim(BCL->BCL_PORVOL)
			endIf

			if (AltCpAT)
				cFuncVoltar	:= "window.location='W_PPLCHACOM.APW'" //Se veio da opção de alterar guias já autorizadas na tela de consulta autorização
			endIf

			if !Empty(cDigiGui)
				cFuncVoltar	:= "window.location='W_PPLDIGGUIP.APW'" //Se veio do digitação de guias, vai voltar pro digitação de guias
			endIf

			cFuncImp := AllTrim(BCL->BCL_PORIMP)

			if !AltCpAT .or. ::RecnoBD5 <> ""
				cFuncGrv := AllTrim(BCL->BCL_PORGRV)
			else
				cFuncGrv := "fRecCmp(FrmGuia); return false;"
			endIf
		else
			cFuncGrv 	:= ""
			cFuncLoad 	:= ""
			cFuncVoltar := ""
			cFuncImp 	:= ""
		endIf

		//Cria a página
		oHtml := WCHtml():New()

		//Cria cabeçalho da página
		::RetGuiaTiss:Pagina := "true|" + oHtml:getDType(.T.,.T.,,,::DtJs)

		//Formulario
		oForm := WCForm():New("FrmGuia")
		oForm:setWidth("800")
		oForm:setTitle(BCL->BCL_PORTIT)
		oForm:setAlignBtn("RIGHT")

		//Funções e botões
		oForm:setJsFClick(cFuncGrv)//("fProcForm(FrmGuia); return false;")
		oForm:setJsFImp(cFuncImp)//("fImpGuia()")
		oForm:setFBack(cFuncVoltar)//("window.location='W_PPLCHAPRE.APW?cP=2'")

		if Empty(cDigiGui) .and. GuiaTiss:TipGui $ "01,02,03,07,08,09,11" //se não é digitação offline
			aadd(aCustomBtn,"bAnexoDoc~Anexar documentos~anexoDocGui()")
		endIf

		oForm:setACustomBtn(aCustomBtn)
		oForm:setFuncLoad(cFuncLoad)

		//Cria campos Hidden
		MntHidden(GuiaTiss:TipGui,@oForm)

		//Tabela principal
		oTabPriFP := WCTable():New("tabPrincipal")

		//Logo Institucional
		oLiImgInst	:= WCLine():new()
		oGrpImgInst := WCFieldSet():new("","770","100","100")

		oBLegBr := WCComponent():New("BI","bLegBr","Logo Institucional")
		oBLegBr:SetJsFunc("fLinkLogo();")

		If !Empty(BCL->BCL_PORIMG)
			oBLegBr:setImgBtn("/" + BCL->BCL_PORIMG)
		Else
			oBLegBr:setImgBtn("/Protheus.png")
		EndIf

		oBLegBr:setHelpBtn("Logo Institucional")
		oBLegBr:setAlign('right')
		oBLegBr:setDisable()
		oBLegBr:setImgWidth("260")
		oBLegBr:setImgHeight("53")

		oGrpImgInst:setAddCFS(oBLegBr)
		oLiImgInst:setAddComp(oGrpImgInst)
		oTabPriFP:setAddLine(oLiImgInst)

		//Caso possua guia fornecida para alteração, posiciona na BEA a guia selecionada para alteração.
		if ! Empty(::cRecno)

			BEA->(DbSetOrder(1))
			If BEA->(MsSeek(xFilial("BEA") + ::cRecno))

				aAreaBCL  := BCL->(GetArea())
				aAreaB7A  := B7A->(GetArea())
				aAreaB7B  := B7B->(GetArea())

				aDadosGuia := PL446DAD(BEA->BEA_TIPGUI)

				BCL->(RestArea(aAreaBCL))
				B7A->(RestArea(aAreaB7A))
				B7B->(RestArea(aAreaB7B))

			EndIf

		endif

		//Monta os Grupos de Campos e Campos da tela
		aReturn := MntGrupo(GuiaTiss:TipGui,GuiaTiss:VerTiss,,@oTabPriFP,@RetGuia,@oForm, GuiaTiss:DadCombo,@cGrids,@cDesGri,aDadosGuia,cDigiGui,lTpAlt,lIntercambio)

		//Cria o campo que guarda os nomes e descrições dos grids
		oForm:setAddFieldHidden(alltrim('cGrids'),Alltrim(cGrids))

		//Armazena origem da chamada da tela de digitação
		oForm:setAddFieldHidden(alltrim('cTipoOrigem'),::Tipo)

		//Armazena em hidden a data limite retroativa para digitação de guias 
		oForm:setAddFieldHidden(allTrim('dDtLimRetro'),::DtLimRetro)

		//Armazenamento Hidden se trata de alteração de alguns campos após autorização e número da guia
		oForm:setAddFieldHidden(alltrim('cLstCmpAlt'),"")
		oForm:setAddFieldHidden(alltrim('cLstCmpAltServ'),"")

		//Armazenamento Hidden se trata de alteração de alguns campos após autorização e número da guia
		oForm:setAddFieldHidden(alltrim('cAltCmpG'),::Tipo)

		//Armazenamento Hidden se trata do recno da bd5 para alterar as guias de digitação offline
		oForm:setAddFieldHidden(alltrim('cRecnoBD5'),::RecnoBD5)
		oForm:setAddFieldHidden(allTrim('cNumGuiRef'),::NumGuiRef)
		oForm:setAddFieldHidden(allTrim('cTpGuiRef '),::TpGuiRef)
		oForm:setAddFieldHidden(allTrim('cRecGuiRef'),::RecGuiRef)

		oForm:setAddFieldHidden(alltrim('cValueProcAnt'),"")

		oForm:setAddFieldHidden(alltrim('cNumGuiRes'),iif(::RecnoBD5 != "", substr(::NumGuiRef,3), ""))

		If (lPLPRGSN)
			oForm:setAddFieldHidden(alltrim('cPLPRGSN'),"1")
		EndIf

		lContinua := aReturn[1]

		//Armazena em hidden a menssagem de paciente internado e bloqueiado
		oForm:setAddFieldHidden(allTrim('cMsnBloInt'),::MsnBloInter)

		//Tabelas do form
		oForm:setAddTables(oTabPriFP)

		//Form no HTML
		oHtml:setObj(oForm)

		//Se deu tudo certo, retorna o HTML
		If lContinua
			::RetGuiaTiss:Pagina 	+= oHtml:loadWC()
			::RetGuiaTiss:CmpGuia 	:= aClone(RetGuia:CmpGuia)
			::RetGuiaTiss:Grids		:= cGrids
		Else
			::RetGuiaTiss := WsClassNew( "SRetGuiaTiss" )
			::RetGuiaTiss:Pagina := aReturn[2]
		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autoriza do a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MntGrupo ³Autor  ³ Alexander	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Monta grupo de campos              						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function MntGrupo(cTipGui, cVerTiss, cPai, oTabPriFP,RetGuiaTiss,oForm, cDadCmb,cGrids,cDesGri,aDadosGuia,cDigiGui,lTpAlt,lIntercambio)
	Local aReturn 		:= {.T.,""}
	Local aArea			:= B7C->(GetArea())

	Default cTipGui		:= ""
	Default cVerTiss	:= ""
	Default cPai		:= CriaVar("B7C_GRUPAI")
	Default aDadosGuia	:= {}
	Default cDigiGui	:= ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Varre a tabela de grupos de campos do portal
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If B7C->(MsSeek(xFilial("B7C")+cTipGui+cVerTiss+cPai) )
		While !B7C->(EOF()) .AND. xFilial("B7C")+cTipGui+cVerTiss+cPai ==;
				B7C->(B7C_FILIAL+B7C_TIPGUI+B7C_TISVER+B7C_GRUPAI)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//Monta os campos do Grupo
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			MntCampo(cTipGui,cVerTiss,cPai,@oTabPriFP,@RetGuiaTiss,@oForm, cDadCmb, @cGrids,@cDesGri,aDadosGuia,cDigiGui,lTpAlt,lIntercambio)

			B7C->(DbSkip())
		EndDo
	Else
		aReturn[1] := .F.
		aReturn[2] := "<b>Não existem campos configurados para a guia <br>Contate a Operadora."
	EndIf

	RestArea( aArea )

Return aReturn

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MntCampo ³Autor  ³ Alexander	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o procedimento e valido						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function MntCampo(cTipGui, cVerTiss, cPai, oTabPriFP, RetGuiaTiss, oForm, cDadCmb, cGrids, cDesGri, aDadosGuia, cDigiGui, lTpAlt,lIntercambio)
	Local cTamanho  := ""
	Local nOrdem	:= Val(B7C->B7C_ORDEM)
	Local nCmp		:= 0
	Local cBtn		:= ""
	Local cBtnS	    := ""
	Local cAleBS	:= ""
	Local nI		:= 0
	Local nK		:= 0
	Local nOrdemOld := "0"
	Local aArSess   := {}
	Local aArAux	:= {}
	Local aCmbGuia  := {}
	Local lDisable	:= .F.
	Default cDesGri	:= ""
	Default aDadosGuia := {}
	Default cDigiGui	:= ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Cria nova Linha
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	&("oLi"+ B7C->B7C_ORDEM ):= WCLine():new()
	&("oLi"+ B7C->B7C_ORDEM ):setHGroup()
	&("oLi"+ B7C->B7C_ORDEM ):setNomeHGr(Alltrim(B7C->B7C_VARGRU))
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Cria o grupo fieldset
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	cGrupo := "oFS" + B7C->B7C_ORDEM
	&(cGrupo) := WCFieldSet():new(B7C->B7C_DESCRI,"770","10","10")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Varre os campos do grupo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If B7B->(MsSeek(xFilial("B7B")+cTipGui+cVerTiss+B7C->B7C_ORDEM ) )
		While !B7B->(EOF()) .AND. xFilial("B7B")+cTipGui+cVerTiss+B7C->B7C_ORDEM ==;
				B7B->(B7B_FILIAL+B7B_TIPGUI+B7B_TISVER+B7B_GRUPO)

			//Se o campo não tiver nome de variável vai para o próximo...
			If Empty(B7B->B7B_NOMXMO)
				B7B->(DbSkip())
				Loop
			EndIf

			//Campo exclusivo de UNIMEDs para transações de PTU Online
			If AllTrim(B7B->B7B_NOMXMO) == 'cTokEdi' .And. !lIntercambio
				B7B->(DbSkip())
				Loop
			EndIf

			cCampo := AllTrim("oCmp"+B7B->B7B_NOMXMO)
			cDescri := Capital(STRZERO(B7B->B7B_ORDEM,3) + " - " + B7B->B7B_DESCRI) //Alterado para Capital, pois, por algum motivo, a função CAPITALACE não funcionava com as palavras "descrição" e "doses"
			cNome := AllTrim(B7B->B7B_NOMXMO)
			nOrdem := B7B->B7B_ORDEM
			lDisable := .F.

			//Se o array de dados da guia possuir elementos, alimenta o conteudo do campo
			//Essa funcionalidade será contemplada no futuro: alteração de guias pelo portal
			/*if (len(aDadosGuia) > 0)
			IF(ValType(aDadosGuia[B7B->B7B_ORDEM]) == "D")
				cConteudo := DTOC(aDadosGuia[B7B->B7B_ORDEM])
			ElseIF(ValType(aDadosGuia[B7B->B7B_ORDEM]) == "N")
				cConteudo := AllTrim(Str(aDadosGuia[B7B->B7B_ORDEM]))
			ElseIF(ValType(aDadosGuia[B7B->B7B_ORDEM]) == "A")
				cConteudo := aDadosGuia[B7B->B7B_ORDEM][1]
			ElseIF(ValType(aDadosGuia[B7B->B7B_ORDEM]) <> "U")
				cConteudo := aDadosGuia[B7B->B7B_ORDEM]
			EndIf
			endif*/
			//Contador de campos
			nCmp := Len(RetGuiaTiss:CmpGuia)

			If Substr(cDescri,7,2) == "Uf"
				cDescri := Upper(cDescri)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//Alimenta a Struct que servirá de guia na página
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			If B7C->B7C_TIPO == 'G'
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//Adiciona o grid a estrutura
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				If !Empty(B7C->B7C_NOMGRI)
					cGrid := AllTrim(B7C->B7C_NOMGRI)
				Else
					cGrid := "Brw" + B7C->B7C_ORDEM
				EndIf
				If nCmp == 0 .OR. nOrdemOld <> B7B->B7B_GRUPO
					nCmp++
					nK := 1
					AaDd( RetGuiaTiss:CmpGuia, WsClassNew( "SCmpGuia" ) )
					RetGuiaTiss:CmpGuia[nCmp]:Tipo := 'G'
					RetGuiaTiss:CmpGuia[nCmp]:Nome := cGrid
					RetGuiaTiss:CmpGuia[nCmp]:Descri := ""
					RetGuiaTiss:CmpGuia[nCmp]:CmpGrid := {}
					RetGuiaTiss:CmpGuia[nCmp]:aCols := {}
					RetGuiaTiss:CmpGuia[nCmp]:aHeader := {}
					RetGuiaTiss:CmpGuia[nCmp]:xCols := ""
					RetGuiaTiss:CmpGuia[nCmp]:xHeader := ""

					oForm:setGlobalVar("o"+cGrid)

					//Prepara variável que seja passada para o JS com os campos do Grid
					If !Empty(cGrids)
						cGrids += "@"
					EndIf
					cGrids += cGrid + "~"

				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//Adiciona os campos da Grid
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				AaDd( RetGuiaTiss:CmpGuia[nCmp]:CmpGrid, WsClassNew( "SCmpGrid" ) )
				RetGuiaTiss:CmpGuia[nCmp]:CmpGrid[nK]:Tipo := B7B->B7B_TIPO
				RetGuiaTiss:CmpGuia[nCmp]:CmpGrid[nK]:Nome := cNome
				RetGuiaTiss:CmpGuia[nCmp]:CmpGrid[nK]:Descri := B7B->B7B_DESCRI
				nK++
				nOrdemOld := B7B->B7B_GRUPO

				//cGrids += "'" + cNome + "',"
				cGrids += cNome + ","
				cDesGri += B7B->B7B_DESCRI + ","
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//Adiciona os campos
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				nCmp++
				AaDd( RetGuiaTiss:CmpGuia, WsClassNew( "SCmpGuia" ) )

				RetGuiaTiss:CmpGuia[nCmp]:Tipo := B7B->B7B_TIPO
				RetGuiaTiss:CmpGuia[nCmp]:Nome := cNome
				RetGuiaTiss:CmpGuia[nCmp]:Descri := B7B->B7B_DESCRI
				RetGuiaTiss:CmpGuia[nCmp]:CmpGrid := {}

			EndIf

			//Recupera tamanho do campo
			If Len(cDescri) > B7B->B7B_TAMANH
				cTamanho := STR(Len(cDescri))
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Monta os objetos HTML
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			Do Case

				Case B7B->B7B_TIPO == 'T'
					If B7B->(FieldPos('B7B_MAXLEN')) > 0 .AND. B7B->B7B_MAXLEN > 0
						//Para um atendimento normal, o campo de Protocolo de Atendimento não pode permitir digitação e deve ser obrigatório
						//Para um atendimento de intercambio, o campo deve ser opcional e permite digitação
						If !lIntercambio .And. cNome $ ("cProtoc")
							&(cCampo) := WCComponent():new("F",cNome,cDescri,,Alltrim(STR(B7B->B7B_MAXLEN)),.T.)
						Else
							&(cCampo) := WCComponent():new("F",cNome,cDescri,,Alltrim(STR(B7B->B7B_MAXLEN)),B7B->B7B_OBRIGA)
						Endif
					Else
						&(cCampo) := WCComponent():new("F",cNome,cDescri,,Alltrim(STR(B7B->B7B_TAMANH)),B7B->B7B_OBRIGA)
					EndIf

				Case B7B->B7B_TIPO == 'F' // Tipo File
					If B7B->(FieldPos('B7B_MAXLEN')) > 0 .AND. B7B->B7B_MAXLEN > 0
						&(cCampo) := WCComponent():new("F",cNome,cDescri,,Alltrim(STR(B7B->B7B_MAXLEN)),B7B->B7B_OBRIGA)
					Else
						&(cCampo) := WCComponent():new("F",cNome,cDescri,,Alltrim(STR(B7B->B7B_TAMANH)),B7B->B7B_OBRIGA)
					EndIf
					&(cCampo):setType("file") // Falo que é do tipo file

				Case B7B->B7B_TIPO == 'M'
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ Insere objeto do tipo TEXTAREA
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					&(cCampo) := WCComponent():new("TA",cNome,cDescri,'500',STR(B7B->B7B_TAMANH),B7B->B7B_OBRIGA)

				Case B7B->B7B_TIPO == 'C'
					cTamanho := Alltrim(B7B->B7B_TAMANH)

					aArSess 	:= {}
					aCmbGuia 	:= {}
					aArAux		:= {}
					If ValType(cDadCmb) <> 'U'
						aCmbGuia := StrToArray(cDadCmb, "|")
					EndIf

					&(cCampo) := WCComponent():new("C",cNome,cDescri,cTamanho,Alltrim(STR(B7B->B7B_TAMANH)),B7B->B7B_OBRIGA,.f.)

					For nI := 1 To Len(aCmbGuia)
						If  Alltrim(B7B->B7B_NOMXMO) $ aCmbGuia[nI] .AND. ";" $ aCmbGuia[nI]
							aArAux := Separa(aCmbGuia[nI], ";")
							Exit
						EndIf
					Next nI
					For nI := 2 To Len(aArAux) // Começa a partir da segunda posição pois a primeira eh o nome do campo
						AADD(aArSess, aArAux[nI])
					Next

					If !Empty(aArSess)
						&(cCampo):setArrCombo(aArSess)
					EndIf

					&(cCampo):setIsName()

			EndCase

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//Seta as propriedades comuns dos campos
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			If !Empty(Alltrim(B7B->B7B_INIPAD))
				cIniPad := AllTrim(B7B->B7B_INIPAD)
				If B7B->B7B_TIPO == 'C'
					&(cCampo):setDefCB(cInipad)
				EndIf
				&(cCampo):setValue(cIniPad)

			EndIf
			//ele tem que ficar aqui do lado de fora pois o usuario pode criar um inicializador novo, dai la no jsusr.pls eu ja coloquei todos campos do grid
			//oForm:setAddFieldHidden(alltrim('aInipad'+B7B->B7B_CAMPO),Alltrim(B7B->B7B_INIPAD))
			If !Empty(B7B->B7B_INIPAD)
				oForm:setAddFieldHidden(alltrim('aInipad'+B7B->B7B_NOMXMO),Alltrim(B7B->B7B_INIPAD))
			EndIf

			If Empty(cDigiGui)
				If !lTpAlt
					If !(B7B->B7B_EDITAR)
						&(cCampo):setReadOnly()
						lDisable := .T.
					EndIf
					If !Empty(Alltrim(B7B->B7B_F3))
						&(cCampo):setJsFF3(B7B->B7B_F3)
						&(cCampo):setOpenGrp(.T.)
						&(cCampo):setCloseGrp(.T.)
					EndIf
				Else
					If !(B7B->B7B_EDIALT)
						&(cCampo):setReadOnly()
						lDisable := .T.
					ElseIf B7B->B7B_EDIALT .And. !(cNome $ ("cTpAteExe|cIndAcid|cTpCon|cTpSai|cProSol|cCbosExe|cVlrPro|cAssBen|cObs"))
						&(cCampo):setReadOnly()
						lDisable := .T.
					Else
						If !Empty(Alltrim(B7B->B7B_F3))
							&(cCampo):setJsFF3(B7B->B7B_F3)
							&(cCampo):setOpenGrp(.T.)
							&(cCampo):setCloseGrp(.T.)
						EndIf
					EndIf

				EndIf
			Else
				If !(B7B->B7B_EDIOFF)
					&(cCampo):setReadOnly()
					lDisable := .T.
				ElseIf B7B->B7B_EDIOFF .And. (cNome $ ("cNumeHoId|cGuiaInter")) .And. lTpAlt
					&(cCampo):setReadOnly()
					lDisable := .T.
				Else
					If !Empty(Alltrim(B7B->B7B_F3))
						&(cCampo):setJsFF3(B7B->B7B_F3)
						&(cCampo):setOpenGrp(.T.)
						&(cCampo):setCloseGrp(.T.)
					EndIf
				EndIf
			EndIf

			If !Empty(Alltrim(B7B->B7B_KEYPRE))
				&(cCampo):setJSKeyPre(alltrim(B7B->B7B_KEYPRE))
			EndIf

			If B7B->B7B_OBRIGA
				oForm:setObrigat(B7B->B7B_NOMXMO,AllTrim(B7B->B7B_KEYPRE))
			ElseIf !lIntercambio .And. cNome $ ("cProtoc")
				&(cCampo):setReadOnly()
				oForm:setObrigat(B7B->B7B_NOMXMO,AllTrim(B7B->B7B_KEYPRE))
			EndIf

			If !Empty(Alltrim(B7B->B7B_KEYDOW))
				&(cCampo):setJSKeyDown(alltrim(B7B->B7B_KEYDOW))
			EndIf

			If !Empty(Alltrim(B7B->B7B_VALID))
				cValid := AllTrim(B7B->B7B_VALID)
				&(cCampo):setJSBlur(cValid)
			EndIf

			If !Empty(Alltrim(B7B->B7B_GATILH))
				cGatilho := AllTrim(B7B->B7B_GATILH)
				cChave := AllTrim(B7B->B7B_CHVGAT)
				&(cCampo):setJSChange("validCmpGen(null"+",'"+;
					cNome+"',"+IIF(Empty(cGatilho),"null","'"+cGatilho+"'")+","+IIF(Empty(cChave),"null","'"+cChave+"'")+")")
			EndIf

			If !Empty(Alltrim(B7B->B7B_ACTION))
				&(cCampo):setJsFBtn(B7B->B7B_ACTION)
				&(cCampo):setOpenGrp(.T.)
				&(cCampo):setCloseGrp(.T.)
			EndIf

			If B7B->(FieldPos('B7B_ACTIO2'))>0 .AND. !Empty(Alltrim(B7B->B7B_ACTIO2)) .AND. !lDisable
				&(cCampo):setJsFBtL(B7B->B7B_ACTIO2)
				&(cCampo):setOpenGrp(.T.)
				&(cCampo):setCloseGrp(.T.)
			EndIf

			If B7B->(FieldPos('B7B_TOOTIP'))>0 .AND. B7B->B7B_TOOTIP == '1'
				&(cCampo):setToolTip('1')
			EndIf

			If B7B->(FieldPos('B7B_HELP'))>0 .AND. !Empty(Alltrim(B7B->B7B_HELP))
				&(cCampo):setJsHelp(B7B->B7B_HELP)
			EndIf

			If !Empty(Alltrim(B7B->B7B_CHANGE))
				cChange := AllTrim(B7B->B7B_CHANGE)
				&(cCampo):setJSChange(cChange)
			EndIf

			If !Empty(Alltrim(B7B->B7B_CSS))
				&(cCampo):setCSS(B7B->B7B_CSS)
			EndIf
			//Adiciona classe do calendário nos campos de data porém quando o campo esta desabilitado não pode adicionar
			if UPPER(SubStr(Alltrim(B7B->B7B_NOMXMO),1,1)) == "D" .AND. !lDisable
				&(cCampo):setData(.T.)
			endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//Seta componente ao fiedlset
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			&(cGrupo):setAddCFS(&(cCampo))
			B7B->(DbSkip())
		EndDo

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ As Grids necessitam de alguns objetos a mais
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If B7C->B7C_TIPO == 'G'

			cGrids += "|" + cDesGri
			cDesGri := ""
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Campo oculto RECNO
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			oForm:setAddFieldHidden(cGrid + "_RECNO","")

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Botao Salvar
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			If !Empty(B7C->B7C_FUNSAV)
				cBtnS := "oSave" + cGrid
				&(cBtnS) := WCComponent():New("B","bSave" + cGrid,"Salvar")

				cFunSave := B7C->B7C_FUNSAV + " ; "
				&(cBtnS):SetJsFunc(cFunSave)
				&(cBtnS):setAlign('right')
				&(cBtnS):setInlineB(.T.)
				&(cBtnS):setDisable()
				&(cBtnS):setCSS("Botoes")
				&(cBtnS):setNoTagTDIE()
				&(cBtnS):setOpenGrp(.T.)
				&(cBtnS):setCloseGrp( Empty(B7C->B7C_LINOK) ) //Se o B7C_LINOK estiver vazio, fecha o grupo, se não estiver, vai fechar no if abaixo
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Botao incluir
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			If !Empty(B7C->B7C_LINOK)
				cBtn := "oInc" + cGrid
				&(cBtn) := WCComponent():New("B","bInc" + cGrid,"Incluir")

				cFunInc := B7C->B7C_LINOK + " ; "
				&(cBtn):SetJsFunc(cFunInc)
				&(cBtn):setAlign('right')
				&(cBtn):setInlineB(.T.)
				&(cBtn):setCSS("Botoes")
				&(cBtn):setNoTagTDIE()
				&(cBtn):setOpenGrp(.F.)
				&(cBtn):setCloseGrp(.T.)
			EndIf

			//-----------------------------------------------------------------------------------
			//   Componente de alert do bootstrap para exibir mensagens no grid ao add um item
			//-----------------------------------------------------------------------------------

			cAleBS := "info"+cGrid
			&(cAleBS) := WCComponent():New("CHTM")
			&(cAleBS):setValue( '<div class="col-xs-12 col-sm-12 col-md-12 col-lg-12"><div class="alert alert-info" id="' + "info"+cGrid +'" style="display:none;"></div></div>' )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Grid
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			&(cGrid) := WCComponent():New("BW",cGrid)
			&(cGrid):setBrWidth("770")
			&(cGrid):setJsFunc("")
			&(cGrid):setPosicao("30")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Adiciona os componentes ao grupo
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

			If !Empty(B7C->B7C_FUNSAV)
				&(cGrupo):setAddCFS(&(cBtnS))
			EndIf
			If !Empty(B7C->B7C_LINOK)
				&(cGrupo):setAddCFS(&(cBtn))
			EndIf

			&(cGrupo):setAddCFS(&(cAleBS))
			&(cGrupo):setAddCFS(&(cGrid))

		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//Seta o Grupo à Linha
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		&("oLi"+ B7C->B7C_ORDEM ):setAddComp(&(cGrupo))

	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Fechamento da Tabela
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	oTabPriFP:setAddLine(&("oLi"+ B7C->B7C_ORDEM ))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Cria subgrupos
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	MntGrupo(cTipGui,cVerTiss,B7C->B7C_ORDEM,@oTabPriFP,@RetGuiaTiss,@oForm,GuiaTiss:DadCombo,@cGrids, @cDesGri, aDadosGuia,cDigiGui,lTpAlt, lIntercambio)


Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MntHidden ³Autor  ³ Alexander	            ³ Data ³06.03.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Insere campos hidden na guia                         		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function MntHidden(cTipGui,oForm,aCampos)

	Local nPos	:= 0

	DEFAULT aCampos := { 	;
		{"01","cRda"		,"<%=HttpGet->cRda%>"       										       },;
		{"01","cCodLoc"	,"<%=HttpGet->cCodLoc%>"       												},;
		{"01","cTpPe"		,""                              											},;
		{"01","cNomeExe"	,""                           												},;
		{"01","cRegEsp"	,"<%=HttpSession->ExisRegEsp%>"												},;
		{"01","cCpsObr"	,"<%=HttpSession->cObrCpGuia%>"												},;
		{"01","cmvTabDef",GETMV("MV_TABDEF")															},;
		{"01","cTp"		,"<%=HttpSession->cTp%>"														},;
		{"01","cProSol"	,""																				},;
		{"02","cCmpl"		,"<%=IIf (Type('HttpSession->cCmpl') <> 'U',HttpSession->cCmpl,'')%>"	},;
		{"02","cTp"		,"<%=IIf(Type('HttpSession->cTp') <> 'U' ,HttpSession->cTp,'')%>"		},;
		{"02","cRda"		,"<%=HttpGet->cRda%>"														},;
		{"02","cCodLoc"	,"<%=HttpGet->cCodLoc%>"														},;
		{"02","cChvBD6"	,""																				},;
		{"02","cTpPe" 	,""																				},;
		{"02","cNomeSol"	,""																				},;
		{"02","cNomeExe"	,""																				},;
		{"02","cSeqProc"	,""																				},;
		{"02","cStatusAut","0"																			},;
		{"02","cmvTabDef",GETMV("MV_TABDEF")															},;
		{"02","cMatTabES"	,""																				},;
		{"02","cMatTabExe",""																			},;
		{"02","cCmpIndCli",""																			},;
		{"02","cPacote",""																				},;
		{"02","cRegEsp"	,"<%=HttpSession->ExisRegEsp%>"												},;
		{"02","cIteRegEsp",""																			},;
		{"02","cCpsObr"	,"<%=HttpSession->cObrCpGuia%>"												},;
		{"02","cProSol"	,""																				},;
		{"02","cStatItem",""																				},;
		{"02","cDataServ","<%=IIF(VALTYPE(HttpSession->USR_INFO[1]:OWSUSERLOGPLS:dDataServer) == 'D',"  +;
		" DTOC(HttpSession->USR_INFO[1]:OWSUSERLOGPLS:dDataServer),'')%>"       },;
		{"02","cVlOutDesp",""																			},;
		{"03","cmvTabDef",GETMV("MV_TABDEF")															},;
		{"03","cRda"		,"<%=HttpGet->cRda%>"														},;
		{"03","cCodLoc"	,"<%=HttpGet->cCodLoc%>"														},;
		{"03","cCmpl"		,"<%=HttpSession->cCmpl%>"													},;
		{"03","cTp"		,"<%=HttpSession->cTp%>"														},;
		{"03","cChvBD6"	,""																				},;
		{"03","cNomeSol"	,""																				},;
		{"03","cStatusAut","0"																			},;
		{"03","cMatTabES"	,""																				},;
		{"03","cCmpIndCli",""																			},;
		{"03","cRdaSolT"	,""																				},;
		{"03","cProfSolT"	,""																				},;
		{"03","cProSol"	,""																				},;
		{"03","cOpeSolT"	,""																				},;
		{"03","dDatInt"	,""																				},;
		{"03","dDatAlt"	,""																				},;
		{"03","cGralau"	,""																				},;
		{"03","cDataServ","<%=IIF(VALTYPE(HttpSession->USR_INFO[1]:OWSUSERLOGPLS:dDataServer) == 'D'," +;
		" DTOS(HttpSession->USR_INFO[1]:OWSUSERLOGPLS:dDataServer),'')%>"},;
		{"05","cCmpl"		,"<%=IIf (Type('HttpSession->cCmpl') <> 'U',HttpSession->cCmpl,'')%>"	},;
		{"05","cTp"		,"<%=IIf(Type('HttpSession->cTp') <> 'U' ,HttpSession->cTp,'')%>"		},;
		{"05","cRda"		,"<%=HttpGet->cRda%>"														},;
		{"05","cCodLoc"	,"<%=HttpGet->cCodLoc%>"														},;
		{"05","cChvBD6"	,""																				},;
		{"05","cTpPe" 	,""																				},;
		{"05","cNomeSol"	,""																				},;
		{"05","cNomeExe"	,""																				},;
		{"05","cSeqProc"	,""																				},;
		{"05","cStatusAut","0"																			},;
		{"05","cmvTabDef",GETMV("MV_TABDEF")															},;
		{"05","cMatTabES"	,""																				},;
		{"05","cMatTabExe",""																			},;
		{"05","cCmpIndCli",""																			},;
		{"05","cPacote",""																				},;
		{"05","cRegEsp"	,"<%=HttpSession->ExisRegEsp%>"												},;
		{"05","cIteRegEsp",""																			},;
		{"05","cCpsObr"	,"<%=HttpSession->cObrCpGuia%>"												},;
		{"05","cProSol"	,""																				},;
		{"05","cProExe"	,""																				},;
		{"05","cTissVer"	,"<%=HttpSession->cTissVer%>"												},;
		{"05","cCritProc"	,""												},;
		{"05","cPadConfSol",""																			},;
		{"05","cTpAcomSol",""																			},;
		{"05","cNumMaxAux","<%=HttpSession->cNumAux%>"												},;
		{"05","cRelExecCar",""																			},;
		{"05","cVlOutDesp",""																			},;
		{"06","cRda"		,"<%=IIF(Type('HttpSession->cRdaRel') <> 'U',HttpSession->cRdaRel,HttpGet->cRda)%>"},;
		{"06","cCodLoc"	,"<%=IIF(Type('HttpSession->cCodLoc') <> 'U',HttpSession->cCodLoc,HttpGet->cCodLoc)%>"},;
		{"06","cChvBD6"	,""																				},;
		{"06","cProSol"	,""																				},;
		{"06","cMatTabES"	,""																			},;
		{"06","cMatTabExe",""																			},;
		{"06","cProExe"	,""																				},;
		{"06","cTp"		,"<%=HttpSession->cTp%>"														},;
		{"06","cTissVer"	,"<%=HttpSession->cTissVer%>"												},;
		{"06","cNumMaxAux","<%=HttpSession->cNumAux%>"												},;
		{"07","cStatusAut","0"																			},;
		{"07","cNumAut","0"																				},;
		{"07","cMatTabExe",""																			},;
		{"07","cMatTabES"	,""																				},;
		{"07","cTp"		,"<%=HttpSession->cTp%>"														},;
		{"08","cMatTabES"	,""																				},;
		{"08","cStatusAut","0"																			},;
		{"08","cNumAut","0"																				},;
		{"08","cMatTabExe",""																			},;
		{"08","cTp"		,"<%=HttpSession->cTp%>"														},;
		{"09","cNumAut","0"																				},;
		{"09","cStatusAut","0"																			},;
		{"09","cMatTabExe",""																			},;
		{"09","cMatTabES"	,""																				},;
		{"09","cTp"		,"<%=HttpSession->cTp%>"														},;
		{"10","cRecnoB4D"	,"<%=HttpGet->cRecnoB4D%>"    										       },;
		{"10","cMatJustif",""																			},;
		{"10","cOpc"		,"<%=HttpGet->cOpc%>"														},;
		{"10","cTpRecGlo"	,""																				},;
		{"11","cCmpl"		,"<%=IIf (Type('HttpSession->cCmpl') <> 'U',HttpSession->cCmpl,'')%>"	},;
		{"11","cTp"		,"<%=IIf(Type('HttpSession->cTp') <> 'U' ,HttpSession->cTp,'')%>"		},;
		{"11","cRda"		,"<%=IIF(Type('HttpSession->cRdaRel') <> 'U',HttpSession->cRdaRel,HttpGet->cRda)%>"},;
		{"11","cCodLoc"	,"<%=IIF(Type('HttpSession->cCodLoc') <> 'U',HttpSession->cCodLoc,HttpGet->cCodLoc)%>"},;
		{"11","cChvBD6"	,""																				},;
		{"11","cTpPe" 	,""																				},;
		{"11","cProSol"	,""																				},;
		{"11","cNomeSol"	,""																				},;
		{"11","cNomeExe"	,""																				},;
		{"11","cStatusAut","0"																			},;
		{"11","cTissVer"	,"<%=HttpSession->cTissVer%>"												},;
		{"11","cMatTabES"	,""																				},;
		{"11","cmvTabDef",GETMV("MV_TABDEF")															},;
		{"11","cRdaLog","<%= PLA09ASES() %>"															},; //Rdas's Que estão Logadas no Sistema
		{"12","cRda"		,"<%=HttpGet->cRda%>"       										       },;
		{"12","cCodLoc"	,"<%=HttpGet->cCodLoc%>"       												},;
		{"12","cTpPe"		,""                              											},;
		{"12","cChvBD6"	,""																				},;
		{"12","cNomeExe"	,""                           												},;
		{"12","cTp"		,"<%=HttpSession->cTp%>"      												},;
		{"12","cMatTabES"	,""																				},;
		{"12","cMatTabExe",""																			},;
		{"12","cProExe"	,""																				},;
		{"12","cStatusAut","0"																			},;
		{"12","cTissVer"	,"<%=HttpSession->cTissVer%>"												},;
		{"12","cDatIniFat"	,""												},;
		{"12","cDatFimFat"	,""												},;
		{"12","cDatAtd"	,"<%=HttpSession->cDatAtd%>"												};
		}

	//Permite a inclusão de campos Hidden por P.E.
	If ExistBlock("PLSCPHID")
		aCampos := ExecBlock("PLSCPHID",.F.,.F.,{cTipGui,aCampos})
	Endif

	While (nPos:=aScan( aCampos , {|x| AllTrim(x[1]) == cTipGui} )) > 0 .AND. aCampos[nPos][1] == cTipGui
		oForm:setAddFieldHidden(aCampos[nPos,2],aCampos[nPos,3])
		nSize := Len(aCampos)
		aDel(aCampos,nPos)
		aSize(aCampos,nSize-1)
	EndDo

Return

//--------------------------------------------------------------------
/*/{Protheus.doc} RetClassProc

Retorna as classes de procedimentos cadastradas na BJE
@since 02/2014
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD RetClassProc WSRECEIVE userCode WSSEND MClasseProc WSSERVICE PLSXFUN
	LOCAL aArea 	:= getArea()
	LOCAL lRetorno	:= .t.
	LOCAL nC			:= 0
	LOCAL cSql 		:= ""
	LOCAL lPadPro 	:= (BJE->(FieldPos("BJE_CODPAD")) > 0) .AND. (BJE->(FieldPos("BJE_CODPRO")) > 0)
	DEFAULT ::WSNULL := ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Se tem direito para executar o metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If PrtChkUser( ::userCode ,"PLSXFUN","RetClassProc" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ alimenta array de classes
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

		cSql := "SELECT "
		cSql += "BJE_CODINT, "
		cSql += "BJE_CODIGO, "
		cSql += "BJE_ISMEDI, "
		cSql += "BJE_DESCRI, "
		cSql += "BJE_CODPAD, "
		cSql += "BJE_CODPRO  "
		cSql += " FROM " + retSqlName("BJE") + " BJE "
		cSql += " INNER JOIN " + retSqlName("BR8") + " BR8 "
		cSql += " ON BJE_FILIAL = '" + xFilial("BJE") + "'"
		cSql += " AND BR8_FILIAL = '" + xFilial("BR8") + "'"
		cSql += " AND BJE_CODIGO = BR8_CLASSE "
		cSql += " AND BR8_EXPBEN = '1' "
		cSql += " AND BJE.D_E_L_E_T_ = ' '"
		cSql += " AND BR8.D_E_L_E_T_ = ' '"
		cSql += "GROUP BY "
		cSql += "BJE_CODINT, "
		cSql += "BJE_CODIGO,
		cSql += "BJE_DESCRI, "
		if lPadPro
			cSql += "BJE_CODPAD, "
			cSql += "BJE_CODPRO,  "
		endIf
		cSql += "BJE_ISMEDI "
		cSql += "ORDER BY BJE_DESCRI "

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,ChangeQuery(cSQL)),"TrbBJE",.T.,.F.)

		while !TrbBJE->(EOF())

			nC ++
			AaDd( ::MClasseProc, WsClassNew( "SClasseProc" ) )
			::MClasseProc[nC]:CodInt			:= TrbBJE->BJE_CODINT
			::MClasseProc[nC]:Code			:= TrbBJE->BJE_CODIGO + "|" + IIF( Vazio(AllTrim(TrbBJE->BJE_ISMEDI)), "0", TrbBJE->BJE_ISMEDI )
			::MClasseProc[nC]:Description	:= TrbBJE->BJE_DESCRI
			if lPadPro
				::MClasseProc[nC]:CodPad  	:= TrbBJE->BJE_CODPAD
				::MClasseProc[nC]:CodProc	:= TrbBJE->BJE_CODPRO

				BR8->(DbSetOrder(1))
				If BR8->(MsSeek(xFilial("BR8") + TrbBJE->BJE_CODPAD + TrbBJE->BJE_CODPRO))

					::MClasseProc[nC]:DesProc := AllTrim(BR8->(BR8_DESCRI))
				Else
					::MClasseProc[nC]:DesProc := "Descrição não encontrada"
				EndIf
			endIf

			TrbBJE->(DbSkip())
		EndDo

		TrbBJE->(DbCloseArea())
	Else
		lRetorno := .f.
		setSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ChkCid 	³Autor  ³ Tabosa 	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o cid	e valido						  		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RDANotRef WSRECEIVE UserCode, CpfCnpj WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea    		:= GetArea()
	DEFAULT ::WSNULL 	:= "true|"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "RDANotRef" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se verifica se e consulta											   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BK6->( DbSetOrder(4) )//BK6_FILIAL+BK6_CGC
		If !BK6->( MsSeek( xFilial("BK6")+ StrTran(StrTran(StrTran(::CpfCnpj,".",""),"-",""),"/","") ) )
			::WSNULL := "false|Rede de atendimento não encontrada"
		Else
			::WSNULL := "true|" + BK6->(BK6_CODIGO+"|"+Alltrim(BK6_NOME)+"|"+Alltrim(BK6_SIGLA)+"|"+BK6_ESTCR)
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    AutAnexo   ³Autor  ³ Daher		            ³ Data ³26.02.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Checa regra de um procedimento para um atendimento		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD AutAnexo WSRECEIVE UserCode, SAutProc WSSEND RetAutProc WSSERVICE PLSXFUN
	LOCAL nI		 := 0
	LOCAL nCont		 := 0
	LOCAL cTipo		 := "1"
	LOCAL cMsg		 := ""
	LOCAL lRetorno 	 := .T.
	LOCAL lAto		 := .F.
	LOCAL cAno		 := ""
	LOCAL cMes       := ""
	LOCAL cString	 := ""
	LOCAL cMatRetRes := "" //Resultado da solicitacao da matriz de retorno separados por ";" para campo e valor e por "#" para outro campo.
	LOCAL nQtdUs	 := 0
	LOCAL nVlrCon	 := 0
	LOCAL nVlrTPF	 := 0
	LOCAL aMatRet    := {} //Matriz de retorno faz tratamento para ate 10 retornos diferentes
	LOCAL aRetCri	 := {}
	LOCAL aVldGen	 := nil
	LOCAL aCritica	 := {{}}
	LOCAL aRet		 := {}
	LOCAL aDadUsr    := {}
	LOCAL aValor	 := {}
	LOCAL aQtdBrw	 := {}
	LOCAL aArea    	 := GetArea()
	LOCAL cGuiRef 	 := ""

	PRIVATE aTabDup 	:= PlsBusTerDup(SuperGetMv("MV_TISSCAB", .F. ,"87"))
	PRIVATE aErrVarVin 	:= {.F., "", "", ""}

	//Checa Usuário
	If PrtChkUser( ::UserCode, "PLSXFUN", "AutAnexo" )

		//Ponto de entrada para troca de dados na aut do portal
		If ExistBlock("PLCHEDAD")

			aRetPtoEnt := ExecBlock("PLCHEDAD",.F.,.F.,{::SAutProc:CodPad,	::SAutProc:CodPro,::SAutProc:TipoProc })

			::SAutProc:CodPad 	:= aRetPtoEnt[1]
			::SAutProc:CodPro	:= aRetPtoEnt[2]
			::SAutProc:TipoProc	:= aRetPtoEnt[3]

		EndIf

		//Monta a matriz de retorno
		cString := ::SAutProc:MatRet

		While ( nPos := At( "~", cString ) ) > 0
			AaDd( aMatRet,SubStr( cString, 1, nPos-1 ) )
			cString := SubStr( cString, nPos+1, Len(cString) )
		EndDo

		//Monta matriz com procedimentos ja executados
		//Pega o ano e o mes de pagamento
		aRet := PLSXVLDCAL(::SAutProc:DatPro,PLSINTPAD(),.F.,"","")

		If aRet[1]

			cMes := aRet[5]
			cAno := aRet[4]

		ElseIf Len(aRet[2]) > 0

			lRetorno := .F.
			SetSoapFault( "", aRet[2,1,1]+" - "+aRet[2,1,2])

		EndIf

		//Verifica Usr
		If lRetorno

			//Dados do usuario
			aRet := PLSDADUSR(::SAutProc:Matric,cTipo,.F.,::SAutProc:DatPro,Nil,Nil,Nil)

			If aRet[1]
				aDadUsr := PLSGETUSR()
			Else

				lRetorno := .F.

				For nI := 1 To Len(aRet[2])
					cMsg += aRet[2,nI,1]+" - "+AllTrim(aRet[2,nI,2])+Iif(nI!=1," - "+AllTrim(aRet[2,nI,3]),"")+Chr(13)+Chr(10)
				Next

				SetSoapFault( "", cMsg)

			EndIf

		EndIf

		//Verifica se pode fazer a autorizacao
		cCodPad := AllTrim(PLSVARVINC('87','BR4', ::SAutProc:CodPad))
		cCodPro := AllTrim(PLSVARVINC(::SAutProc:CodPad,'BR8',::SAutProc:CodPro ,cCodPad+::SAutProc:CodPro,,aTabDup,@CCODPAD))

		If aErrVarVin[1] == .T.
			SetSoapFault( "", "De/Para não realizado para ->  ("+::SAutProc:CodPad+") "+::SAutProc:CodPro )
			Return .F.
		EndIf

		If 	!PChkTabDup(@cCodPad,cCodPro,::SAutProc:CodPad,.T.)
			SetSoapFault( "", "Procedimento Bloqueado pela Operadora -> ("+::SAutProc:CodPad+") "+::SAutProc:CodPro )
			Return .F.
		EndIf

		::SAutProc:CodPad := cCodPad
		::SAutProc:CodPro := cCodPro
		cGuiRef := StrTran( ::SAutProc:GuiRef, ".", "" )
		cGuiRef := StrTran( cGuiRef, "-", ""  )

		For nI := 1 To Len( ::SAutProc:AutItem )

			AaDd( aQtdBrw, {PADR(cCodPad,Len(BR8->BR8_CODPAD)),;
				PADR(cCodPro,Len(BR8->BR8_CODPSA)),;
				::SAutProc:AutItem[nI]:ProcedureQuantity,;
				::SAutProc:DATPRO,;
				::SAutProc:AutItem[nI]:HORINI,;//Iif(ValType(SAutProc:AutItem[nI]:HORINI)=='C',::SAutProc:AutItem[nI]:HORINI,Substr(TIME(),1,5)),;
				PADR(::SAutProc:AutItem[nI]:DENTE,Len(B04->B04_CODIGO)),;
				PADR(::SAutProc:AutItem[nI]:FACE,Len(B09->B09_FADENT)),;
				StrZero(Val(::SAutProc:AutItem[nI]:SEQUENCE), TamSx3("BD6_SEQUEN")[1])} )
		Next

		If lRetorno

			//Checa a regra para um determinado procedimento
			aRet := PLSAUTP(::SAutProc:DatPro,;
				nil,;
				PADR(::SAutProc:CodPad,Len(BR8->BR8_CODPAD)),;
				PADR(::SAutProc:CodPro,Len(BR8->BR8_CODPSA)),;
				::SAutProc:QtdPro,;
				aDadUsr,;
				nil,;
				nil,;
				"1",;
				.f.,;
				::SAutProc:Cid,;
				.t.,;
				"1",;
				.f.,;
				nil,;
				nil,;
				cAno,;
				cMes,;
				nil,;
				nil,;
				nil,;
				.t.,;
				nil,;
				nil,;
				0,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				.f.,;//33
				"2",;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				.f.,;//49
				.f.,;
				nil,;
				nil,;
				aQtdBrw,;
				aVldGen,;
				nil,;
				nil,;
				nil,;
				nil,;
				.f.,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				iIf(! empty(::SAutProc:TipGui),PADL(::SAutProc:TipGui,2,"0"),""),;
				nil,;
				nil,;
				.T.,; //77
				nil,;
				nil,;
				nil,; //80
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,;
				nil,; //91
				cGuiRef)

			//Retorno
			If Len(aRet) > 0

				::RetAutProc		:= WsClassNew( "SMatRetAutProc" )
				::RetAutProc:ProAut	:= aRet[1]

				aCritica 			:= aRet[2]
				::RetAutProc:Nivel	:= aRet[3]
				::RetAutProc:Chave	:= aRet[4]

				lAto				:= Iif( len(aRet) >= 5, aRet[5], .f. )
				aValor 				:= Iif( len(aRet) == 6 .and. lAto , aRet[6], {} )

				::RetAutProc:Autori	:= ""
				::RetAutProc:MatCri	:= {}

				//Se foi autorizado
				If aRet[1]
					::RetAutProc:Autori := iif(valType(aRet[2])=='C',aRet[2],'') //BR8_AUTORI (0=Dispensa Autorizacao;1=Automatica;2=Guia Operadora;3=Auditoria;4=Guia Empresa;5=Guia Empresa/Operadora;6=Avalicao Contratual)
				Else

					//Criticas
					For nI := 1 To Len(aCritica)

						//Retira a informacao de nivel das criticas
						If At('nível',Lower(aCritica[nI,2])) > 0
							Loop
						endIf

						If ! empty(aCritica[nI,1])

							aRetCri := PLSRETCRI( AllTrim( aCritica[nI,1] ) )

							if empty(aRetCri[1][2])
								aRetCri[1][1] := aCritica[nI][2]
								aRetCri[1][2] := aCritica[nI][3]
							endIf

						else

							aRetCri := {}
							aadd(aRetCri,{"",aCritica[nI,2]} )

						endIf

						nCont++
						aadd( ::RetAutProc:MatCri, WsClassNew( "GenericStruct" ) )

						::RetAutProc:MatCri[nCont]:Code			:= Iif( empty(aRetCri[1,1]),"&nbsp;&nbsp;&nbsp;&nbsp;",aRetCri[1,1] )
						::RetAutProc:MatCri[nCont]:Description	:= PadR( allTrim(aRetCri[1,2]),60 ) + Iif( ! Empty( aCritica[nI,3] ) ," ( " + AllTrim( aCritica[nI,3] ) + " )" ,"" ) + "<br>"
					Next

				EndIf

				//Resultado da matriz de retorno
				For nI := 1 To Len(aMatRet)

					Do Case

						//Retorna sim ou nao para autorizacao
						Case Lower(aMatRet[nI]) == 'cstatusaut'

							cMatRetRes += aMatRet[nI]+";"+Iif(aRet[1],Iif(lAto,"5","1"),"0")+"~"

							//Retorna quantidade autorizada ou negada
						Case Lower(aMatRet[nI]) $ 'cqtdautssol,cqtdsexe,cqtdoexe,cqtdsautpro'

							cMatRetRes += aMatRet[nI]+";"+Iif(aRet[1],AllTrim(Str(::SAutProc:QtdPro)),"0")+"~"

							//Retorna Quantidade US
						Case Lower(aMatRet[nI]) == 'nqtdusse'

							cMatRetRes += aMatRet[nI]+";"+AllTrim(Str(nQtdUs))+"~"

							//Retorna Valor contratado
						Case Lower(aMatRet[nI]) == 'nvlrunise'

							cMatRetRes += aMatRet[nI]+";"+AllTrim(Str(nVlrCon))+"~"

							//Retorna Valor participacao
						Case Lower(aMatRet[nI]) == 'nvlrfrpase'

							cMatRetRes += aMatRet[nI]+";"+AllTrim(Str(nVlrTPF))+"~"

							//Retorna S-autorizado, N-nao autorizado
						Case Lower(aMatRet[nI]) == 'cautse'

							cMatRetRes += aMatRet[nI]+";"+Iif(aRet[1],"S","N")+"~"

					EndCase

				Next

				//Retorna a string formatada
				::RetAutProc:MatRetRes := cMatRetRes

			Else
				lRetorno := .F.
				SetSoapFault( "", "Retorno invalido na checagem do procedimento ("+::ProDad:CodPro+")" )
			EndIf
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Matric    ³Autor  ³ Thiago Guilherme      ³ Data ³19.03.14	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna a matricula selecionado no pré atendimento		     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD Matric WSRECEIVE UserCode, cRecno WSSEND AMatric WSSERVICE PLSXFUN

	LOCAL cSQL
	LOCAL lRetorno := .T.
	LOCAL nI 		 := 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "Matric" ) //consome uma licença, checa integridade de acesso

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Seleciona os beneficiarios com internação em aberto						   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cSQL := " SELECT BE4_CODOPE, BE4_CODEMP, BE4_MATRIC, BE4_TIPREG, BE4_DIGITO"
		cSQL += " FROM " + RetSQLName("BE4")
		cSQL += " WHERE R_E_C_N_O_ = '" + cRecno + "'"
		cSQL += " AND " + RetSqlName("BE4")+".D_E_L_E_T_ = ''"
		PLSQuery(cSQL,"TrbMatric")

		While !TrbMatric->(Eof())

			AaDd( ::AMatric, WsClassNew( "SMatric" ) )
			::AMatric[nI]:Matric   := TrbMatric->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC+BE4_TIPREG+BE4_DIGITO)
			nI++
			TrbMatric->(dbSkip())
		EndDo

		TrbMatric->(dbCloseArea())
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VALACEBOT    ³Autor  ³ Thiago Guilherme      ³ Data ³19.03.14³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Valida se usuario tem acesso ao botão internação			     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VALACEBOT WSRECEIVE UserCode, cUsr WSSEND Usuario WSSERVICE PLSXFUN
	LOCAL cSQL		:= ""
	LOCAL lRetorno 	:= .t.

	If PrtChkUser( ::UserCode, "PLSXFUN", "VALACEBOT" ) //consome uma licença, checa integridade de acesso

		//Seleciona os beneficiarios com internação em aberto
		cSQL := " SELECT BSW_BEINTR "
		cSQL += "   FROM " + retSQLName("BSW")
		cSQL += "  WHERE BSW_FILIAL = '" + xFilial('BSW') + "' "
		cSQL += "    AND BSW_CODUSR = '" + cUsr + "' "
		cSQL += "    AND D_E_L_E_T_ = '' "

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,changeQuery(cSQL)),"TrbUsr",.T.,.F.)

		If !TrbUsr->(Eof())

			If ! empty(TrbUsr->BSW_BEINTR)

				AaDd( ::Usuario, WsClassNew( "SUsuario" ) )
				::Usuario[1]:permite := TrbUsr->BSW_BEINTR

			EndIf

		EndIf

		TrbUsr->(dbCloseArea())

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ReembChkRegr ³Autor  ³ Tabosa 	          ³ Data ³06.03.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna parametrizacoes de reembolso no port benef           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ReembChkRegr WSRECEIVE UserCode, MatUsu WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea    		:= GetArea()
	LOCAL nDiasTol		:= 60

	If PrtChkUser( "MSALPHA", "PLSXFUN", "ReembChkRegr" )

		BA1->(DbSetOrder(2))
		BA1->(MsSeek(xFilial("BA1")+SubStr(::MatUsu,1,16)))
		BA3->(DbSetOrder(1))
		BA3->(MsSeek(xFilial("BA3")+SubStr(::MatUsu,1,14)))

		BI3->( DbSetOrder(1) )//BI3_FILIAL + BI3_CODINT + BI3_CODIGO + BI3_VERSAO
		BI3->(MsSeek(xFilial("BI3")+BA3->(BA3_CODINT+BA3_CODPLA+BA3_VERSAO) ) )

		// ****** NUMERO DE DIAS DE TOLERANCIA A PARTIR DA DATA DO DOCUMENTO PARA SOLIC.

		If BI3->BI3_MXDRMB > 0
			nDiasTol := BI3->BI3_MXDRMB
			::WSNULL := DTOC(dDataBase - nDiasTol) + "|1"  // Permite reemb na web
		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DadGrpFam    ³Autor  ³ Thiago Guilherme  ³ Data ³08.01.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os beneficiários que fazem parte do grupo familiar   ³±±
±±³
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DadTipDoc WSRECEIVE UserCode WSSEND DadosTipDoc WSSERVICE PLSXFUN
	LOCAL nI        := 1
	LOCAL aArea	  := GetArea()
	LOCAL lRetorno  := .T.
	LOCAL cSQL
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "DadTipDoc" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³retorna os tipos de documentos utilizados no reembolso do portal do beneficiário	³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		cSQL := "SELECT BBS_COD, BBS_DESCRI, BBS_IMG  "
		if(BBS->(FieldPos("BBS_OBRIGA")) > 0 )
			cSQL += ", BBS_OBRIGA "
		endIf

		cSQL += "FROM " + RetSQLName("BBS")
		cSQL += " WHERE D_E_L_E_T_ = ''"
		PLSQuery(cSQL,"TrbRetTip")

		if !TrbRetTip->(EOF())

			While !TrbRetTip->(EOF())

				AaDd( ::DadosTipDoc, WsClassNew( "SDadTip" ))
				::DadosTipDoc[nI]:Cod    := TrbRetTip->BBS_COD
				::DadosTipDoc[nI]:Descri := TrbRetTip->BBS_DESCRI
				::DadosTipDoc[nI]:ImgHelp := TrbRetTip->BBS_IMG
				::DadosTipDoc[nI]:Obriga  := iif(BBS->(FieldPos("BBS_OBRIGA")) > 0 , TrbRetTip->BBS_OBRIGA, "1")
				nI++
				TrbRetTip->(dbSkip())
			EndDo
		EndIf
		TrbRetTip->(dbCloseArea())

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RDARef 	³Autor  ³ Tabosa 	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o cid	e valido						  		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RDARef WSRECEIVE UserCode, CpfCnpj, Matric WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea    		:= GetArea()
	Local cCpfCnpj		:= AllTrim(StrTran(StrTran(StrTran(::CpfCnpj,".",""),"-",""),"/",""))
	DEFAULT ::WSNULL 	:= "true|"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "RDARef" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se o CPF não corresponde a alguem da familia				   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BA1->( DbSetOrder(4) )//BA1_FILIAL + BA1_CPFUSR

		If BA1->( MsSeek( xFilial("BA1")+ cCpfCnpj ) ) .AND. BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC) == ::Matric

			::WSNULL := "true|NE|O CPF digitado corresponde ao titular ou dependente da família, digite o CPF/CNPJ do prestador do serviço contido no documento fiscal."

			RestArea( aArea )
			Return lRetorno
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se prestador esta cadastrado na rede não referenciada		    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BK6->( DbSetOrder(4) )//BK6_FILIAL+BK6_CGC
		If !BK6->( MsSeek( xFilial("BK6")+ StrTran(StrTran(StrTran(::CpfCnpj,".",""),"-",""),"/","") ) )

			::WSNULL := "true|N|Prestador de serviço não encontrado, clique em OK para cadastrá-lo."
		Else

			If LEN(cCpfCnpj) <> 11 .AND. LEN(cCpfCnpj) <> 14

				::WSNULL := "false|Quantidade de caracteres inválido."
			Else

				BID->(DbSetOrder(1))
				BID->(MsSeek(xFilial("BID") + BK6->(BK6_MUNCR)))

				::WSNULL := "true|S|" + BK6->(BK6_CODIGO+"|"+Alltrim(BK6_NOME)+"|"+Alltrim(BK6_SIGLA)+"|"+BK6_ESTCR+"|"+BK6_MUNCR+"|"+BID->BID_DESCRI)
			EndIf
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PutReembBen 	³Autor  ³ Tabosa 	           ³ Data ³06.03.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³ Realiza a gravacao da solic de reembolso do portal do Benef ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD PutReembBen WSRECEIVE UserCode, MatUsu, DatDoc, CpfCnpj, NomRdaNRef, VlrApr, Telefone, ItensReemb WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea    		:= GetArea()
	LOCAL cProtocolo	:= ""
	LOCAL aCliente 		:= {}
	LOCAL aDadRDA 		:= {}
	LOCAL nValMin		:= 0 // Valor minimo acumulado para solicitaçao de reembolso
	LOCAL lOK			:= .T.
	LOCAL ADadCli		:= separa(::CpfCnpj)
	LOCAL aNomBen		:= separa(::MatUsu)
	LOCAL nCount		:= 0
	LOCAL cMatBen		:= ""
	Local lInsBK6		:= SupergetMV("MV_VRDANRF", .F., .F.)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If PrtChkUser( "MSALPHA", "PLSXFUN", "PutReembBen" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Checagem do usuario															   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		BA1->(DbSetOrder(2))
		If BA1->(dbSeek(xFilial("BA1")+ substr(aNomBen[1],1,14)))
			While BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC) == substr(aNomBen[1],1,14)

				If BA1->BA1_TIPUSU == "T"
					cMatBen := BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)
					EXIT
				EndIf
			EndDo
		EndIf

		BA1->(DbSetOrder(2))
		BA1->(MsSeek(xFilial("BA1")+SubStr(cMatBen,1,16)))
		BA3->(DbSetOrder(1))
		BA3->(MsSeek(xFilial("BA3")+SubStr(cMatBen,1,14)))

		BI3->( DbSetOrder(1) )//BI3_FILIAL + BI3_CODINT + BI3_CODIGO + BI3_VERSAO
		BI3->(MsSeek(xFilial("BI3")+BA3->(BA3_CODINT+BA3_CODPLA+BA3_VERSAO) ) )

		// ***************** Verifica valor minimo para sol de reembolso cadastrado no produto //
		If BI3->( FieldPos("BI3_VMIRMB") ) > 0
			nValMin := BI3->BI3_VMIRMB
		EndIf

		If Val(::VlrApr) < nValMin // nao atingiu o valor necessário para solicitar o reembolso
			::WSNULL := "false|Valor minimo [ " + Alltrim(Str(nValMin)) + " ] para solicitação de reembolso não atingido!"
			lOK := .F.
		EndIf
		// ***************VErifica permissao para sol de reemb no portal do beneficiario //
		If BA3->BA3_REEWEB <> "1" .OR. BA3->BA3_PODREM <> "1" .AND. lOK
			::WSNULL := "false|Beneficiário sem permissão para solicitação de reembolso!"
			lOK := .F.
		EndIf

		If ExistBlock("PLVLWEBA")
			lOk := ExecBlock("PLVLWEBA",.F.,.F.,{lOk, aNomBen, ::DatDoc, aDadCli, ::NomRdaNRef, ::VlrApr, ::ItensReemb})
		EndIf
		If lOK
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Cria protocolo de Reembolso													   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Begin Transaction
				RecLock("BOW", .T.)
				BOW->BOW_FILIAL := xFilial("BOW")
				BOW->BOW_PROTOC := (cProtocolo := GetSXENum("BOW","BOW_PROTOC"))
				BOW->BOW_TIPPAC := getNewPar("MV_PLSTPAA","05")
				BOW->BOW_STATUS := "0"
				BOW->BOW_USUARI := cMatBen

				aCliente := PLSAVERNIV(	BA3->BA3_CODINT,BA3->BA3_CODEMP,BA3->BA3_MATRIC,IF(BA3->BA3_TIPOUS=="1","F","J"),;
					BA3->BA3_CONEMP,BA3->BA3_VERCON,BA3->BA3_SUBCON,BA3->BA3_VERSUB,nil,BA1->BA1_TIPREG,.F.)

				If aCliente[1,1] <> "ZZZZZZ"
					BOW->BOW_CODCLI	:= aCliente[1][1]
					BOW->BOW_LOJA  	:= aCliente[1][2]
					BOW->BOW_NOMCLI	:= aCliente[1][3]
				EndIf

				BOW->BOW_TIPUSR := "99"
				BOW->BOW_VIACAR := BA1->BA1_VIACAR
				BOW->BOW_NOMUSR := BA1->BA1_NOMUSR
				BOW->BOW_CODEMP := BA3->BA3_CODEMP
				BOW->BOW_MATRIC := BA3->BA3_MATRIC
				BOW->BOW_TIPREG := BA1->BA1_TIPREG
				BOW->BOW_DIGITO := BA1->BA1_DIGITO
				BOW->BOW_MATUSA := "1"
				BOW->BOW_DTDIGI := dDataBase
				BOW->BOW_OPERDA := BA1->BA1_CODINT
				BOW->BOW_CONEMP := BA3->BA3_CONEMP
				BOW->BOW_VERCON := BA3->BA3_VERCON
				BOW->BOW_SUBCON := BA3->BA3_SUBCON
				BOW->BOW_VERSUB := BA3->BA3_VERSUB
				BOW->BOW_TELCON := ::Telefone

				BK6->( DbSetOrder(4) )//BK6_FILIAL+BK6_CGC

				For nCount := 1 To LEN(ADadCli)
					If !EMPTY(ADadCli[nCount])

						If BK6->( MsSeek( xFilial("BK6")+ StrTran(StrTran(StrTran(ADadCli[nCount],".",""),"-",""),"/","") ) )
							BOW->BOW_CODREF 	:= BK6->BK6_CODIGO
							BOW->BOW_NOMREF 	:= BK6->BK6_NOME
							BOW->BOW_UFATE	:= 	BK6->BK6_ESTCR
							If BK6->( FieldPos("BK6_MUNCR") ) > 0
								BOW->BOW_MUNATE	:= 	BK6->BK6_MUNCR
							EndIf
						Else // Cria novo registro de rede nao referenciada na BK6
							IF (!lInsBK6)
								aDadRda :=  PlsIncBK6(Alltrim(::NomRdaNRef), ::CpfCnpj)
								BOW->BOW_CODREF 	:= aDadRda[1][1]
								BOW->BOW_NOMREF 	:= aDadRda[1][2]
							EndIf
						EndIf
					EndIf
				Next

				BOW->BOW_OPESOL := BA1->BA1_CODINT
				BOW->BOW_OPEUSR := BA1->BA1_CODINT
				BOW->BOW_ESTSOL := GETMV("MV_PLSESPD")
				BOW->BOW_OPEEXE := BA1->BA1_CODINT
				BOW->BOW_SIGLA  := GETMV("MV_PLSIGLA")
				BOW->BOW_ESTEXE := GETMV("MV_PLSESPD")
				BOW->BOW_VLRAPR := Val(::VlrApr)
				BOW->BOW_CDOPER := ::UserCode
				BOW->BOW_NOMOPE := Posicione("BSW",5,xFilial("BSW")+::UserCode,"BSW_NOMUSR")

				lBAU    := .F.

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ Se foi informado a rede nao referenciada
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				If !Empty(BOW->BOW_CODREF)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ Rede nao referenciada
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					BK6->(dbSetOrder(3) )//BK6_FILIAL, BK6_CODIGO
					If BK6->( MsSeek(xFilial("BK6")+BOW->BOW_CODREF) )
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						//³ Rda referente a Rede nao referenciada
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						BAU->(dbSetOrder(8) )//BAU_FILIAL, BAU_CODBK6
						If BAU->( MsSeek(xFilial("BAU")+BOW->BOW_CODREF) )
							lBAU := .T.
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						//³ Se achou a rda e o estado e crm esta preenchido
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						If !lBAU .And. !Empty(BK6->BK6_CONREG) .And. !Empty(BK6->BK6_ESTCR)
							BAU->(dbSetOrder(3) )//BAU_FILIAL, BAU_ESTCR, BAU_CONREG, BAU_SIGLCR
							If BAU->( MsSeek(xFilial("BAU")+BK6->(BK6_ESTCR+BK6_CONREG)) )
								lBAU := .T.
							EndIf
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						//³ Se tem vida
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
						If !lBAU .And. !Empty(BK6->BK6_MATVID)
							BAU->(dbSetOrder(9) )//BAU_FILIAL,BAU_MATVID
							If BAU->( MsSeek(xFilial("BAU")+BK6->BK6_MATVID) )
								lBAU := .T.
							EndIf
						EndIf
					EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³Se nao encontrar procuro RDA generica
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				If !lBAU
					BAU->(dbSetOrder(1) )//BAU_FILIAL,BAU_CODIGO
					If BAU->( MsSeek(xFilial("BAU")+GetNewPar("MV_PLSRDAG","999999")) )
						lBAU := .T.
					Endif
				Endif

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ Alimenta M
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				If lBAU
					BOW->BOW_CODRDA := BAU->BAU_CODIGO
					BOW->BOW_NOMRDA := BAU->BAU_NOME
					BOW->BOW_TIPPRE := BAU->BAU_TIPPRE

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ Profissional relacionado a rda
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					BB0->( DbSetOrder(1) ) //BB0_FILIAL + BB0_CODIGO
					BB0->( MsSeek( xFilial("BB0")+BAU->BAU_CODBB0 ) )

					If BB0->(Found())
						BOW->BOW_REGEXE := BB0->BB0_NUMCR
						BOW->BOW_NOMEXE := BB0->BB0_NOME
						BOW->BOW_CDPFRE := BB0->BB0_CODIGO
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ DadRda
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					PLSDADRDA(BOW->BOW_OPERDA,BOW->BOW_CODRDA,"1",dDataBase,Subs(BOW->BOW_LOCATE,1,3),"")

					aDadRDA := PLSGETRDA()
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ Atualiza M
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					if len(aDadRDA) >=15
						BOW->BOW_CODESP := aDadRDA[15]
						BOW->BOW_DESESP := aDadRDA[17]
						BOW->BOW_LOCATE := aDadRDA[18]
						BOW->BOW_ENDLOC := aDadRDA[20]
					EndIf
				EndIf

				BOW->BOW_OPEMOV := PLSINTPAD()
				BOW->BOW_EMPMOV := cNumEmp

				BA3->(DbSetOrder(1))
				BA3-> (DbSeek(xFilial("BA3") + BOW->BOW_OPERDA + BOW->BOW_CODEMP + BOW->BOW_MATRIC))

				If BA3->(FieldPos("BA3_TIPPGO")) > 0
					BOW->BOW_PGMTO := "Em Análise"
				EndIf

				BOW->(MsUnlock())
				PlsGrvB1N( cProtocolo,::ItensReemb,aNomBen, lInsBK6 )
				ConfirmSX8()
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ P.E. utilizado para manipular o último registro da BOW que foi gravado ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ExistBlock("PLWEBBOW")
					ExecBlock("PLWEBBOW",.F.,.F.,{BOW->(Recno())})
				Endif
			End Transaction
			::WSNULL := "true|" + cProtocolo
		Else
			If lOK // passou pelas outras criticas
				::WSNULL := "false|Existe inconsistências no seu cadastro que impossibilitam a solicitação do reembolso, entre em contato com a operadora!"
			EndIf
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

//Requisito: Nova tela de solicitação de reembolso
//Static Function PlsIncBK6 Movida para o Fonte PLSFUNREEMB como Function
//Static Function PlsGrvB1N Movida para o fonte PLSFUNREEMB como function

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³OBSPROTOC ³Autor  ³ Thiago Guilherme³ Data ³01.08.2014       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna observação do protocolo de reembolso                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD OBSPROTOC WSRECEIVE UserCode, cRecno, Tipo WSSEND DadObsProt WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea 		:= GetArea()
	LOCAL cObs := ""
	LOCAL nI := 1
	If PrtChkUser( ::UserCode, "PLSXFUN", "OBSPROTOC" )
		if ::Tipo == "receita" //protocolo de uso constante
			B7D->(dbSelectArea("B7D"))
			B7D->(dbGoto(val(cRecno)))

			nLines := MLCount( B7D->B7D_OBS )

			For nI := 1 to nLines
				if !(empty(memoLine(B7D->B7D_OBS,,nI)))
					cObs += alltrim(strTran(strTran(memoLine(B7D->B7D_OBS,,nI), chr(10), ""), chr(13),""))
				endIf
			Next nI

			AaDd( ::DadObsProt, WsClassNew( "SRetObsProt" ) )
			::DadObsProt[1]:cMsg  := IIf(EMPTY(cObs), "false|Sem Observação", "true|"+cObs)
		else
			BOW->(dbSelectArea("BOW"))
			BOW->(dbGoto(val(cRecno)))

			nLines := MLCount( BOW->BOW_OBS )

			For nI := 1 to nLines
				if !(empty(memoLine(BOW->BOW_OBS,,nI)))
					cObs += alltrim(strTran(strTran(memoLine(BOW->BOW_OBS,,nI), chr(10), ""), chr(13),""))
					cObs += Space(01)
				endIf
			Next nI

			AaDd( ::DadObsProt, WsClassNew( "SRetObsProt" ) )
			::DadObsProt[1]:cMsg  := IIf(EMPTY(cObs), "Sem Informação.", ALLTRIM(cObs))

		endIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ExcItmReemb ³Autor  ³ Thiago Ribas      ³ Data ³01.08.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retornar mensagem                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ExcItmReemb WSRECEIVE UserCode, cRecno WSSEND DadItemExc WSSERVICE PLSXFUN
	LOCAL lRetorno := .T.
	LOCAL lAchou   := .F.

	If PrtChkUser( ::UserCode, "PLSXFUN", "ExcItmReemb" )

		B1N->(dbGoTo(VAL(cRecno)))


		B14->(DbSetOrder(1))
		If B14->(MsSeek(xFilial("B14") + B1N->(B1N_PROTOC + B1N_CODPRO + B1N_MATRIC + B1N_SEQUEN)))

			lAchou := .T.

		ElseIf B14->(MsSeek(xFilial("B14") + B1N->(B1N_PROTOC + B1N_CODPRO)))

			While !lAchou .and. B14->(!EOF()) .and. xFILIAL("B14")+B14->(B14_CDPROT+B14_CODPRO) == ;
					B1N->(B1N_FILIAL + B1N_PROTOC + B1N_CODPRO)

				if alltrim(B1N->B1N_MATRIC) == alltrim(B14->B14_MATRIC)
					lAchou := .T.
				else
					B14->(dbSkip())
				endIf
			EndDo
		EndIf

		IF lAchou
			AaDd( ::DadItemExc, WsClassNew( "SRetIteEx" ) )
			::DadItemExc[1]:cMsg  := B14->B14_MOTIVO
		Else
			AaDd( ::DadItemExc, WsClassNew( "SRetIteEx" ) )
			::DadItemExc[1]:cMsg  := "Sem Informação."
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ReembChkRegr ³Autor  ³ Tabosa 	          ³ Data ³06.03.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna parametrizacoes de reembolso no port benef           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ReembDelPI WSRECEIVE UserCode, cRecno, Alias, Chave WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea    		:= GetArea()
	LOCAL nVlrItem		:= 0
	LOCAL aChave			:= {}
	LOCAL aRecnosB1N		:= {}
	LOCAL nI := 0
	DEFAULT ::Chave := "" //formato B1N: B1N_PROTOC-B1N_TIPDOC-B1N_NUMDOC-B1N_DATDOC-B1N_PRCNPJ
	DEFAULT ::cRecno := "0"
	If PrtChkUser( "MSALPHA", "PLSXFUN", "ReembDelPI" )

		If ::Alias == "BOW" // Deleta protocolo
			BOW->(DbGoTop())
			BOW->(DbGoTo(Val(::cRecno)))
		Else // Deleta Item
			//no reembolso multicomprovante no portal, exclui o comprovante inteiro, portanto exclui várias B1N
			if((empty(::cRecno) .or. ::cRecno == "0") .and. !empty(::Chave))
				aChave := Separa(::Chave, "-")

				BOW->(DbSetOrder(1))
				BOW->(MsSeek(xFilial("BOW") + alltrim(aChave[1]) ))

				B1N->(DbSetOrder(2))
				B1N->(MsSeek(xFilial("B1N") + alltrim(aChave[1]) ))

				While B1N->(!EOF()) .AND. B1N->B1N_PROTOC == aChave[1]

					if STRTRAN(B1N->B1N_TIPDOC, " ", "") == aChave[2] .and. ALLTRIM(B1N->B1N_NUMDOC) == aChave[3];
							.and. B1N->B1N_DATDOC == STOD(aChave[4]);
							.and. ALLTRIM(B1N->B1N_PRCNPJ) == aChave[5]
						aAdd(aRecnosB1N, B1N->(Recno()))
					endIf

					B1N->(dbSkip())
				EndDo

			else
				B1N->(DbGoTop())
				B1N->(DbGoTo(Val(::cRecno)))

				aAdd(aRecnosB1N, B1N->(Recno()))

				BOW->(DbSetOrder(1))
				BOW->(MsSeek(xFilial("BOW") + B1N->B1N_PROTOC ))
			endIf
		EndIf

		//Solicitação Não concluída - Foi alterado, pois devido aos novos status e a obrigatoriedade de anexo,
		//poderá cancelar somente se não concluiu a solicitação
		If BOW->BOW_STATUS <> 'A'

			::WSNULL := "false|Não foi possível excluir esta solicitação pois já esta protocolada, entre em contato com a operadora!"
		Else
			If ::Alias == "BOW"
				Begin Transaction
					P001AEXCG(BOW->BOW_PROTOC)
				End Transaction
			Else

				for nI := 1 to len(aRecnosB1N)

					B1N->(DbGoTo(aRecnosB1N[nI]))

					B14->(dbSetOrder(1))
					If B14->(dbSeek(xFilial("B14")+B1N->(B1N_PROTOC + B1N_CODPRO + B1N_MATRIC + B1N_SEQUEN))) //11-09

						nVlrItem := B1N->B1N_VLRAPR
						B14->(RecLock('B14',.F.))
						B14->(DbDelete())
						B14->( MsUnlock() )
					EndIf

					if B1N->(FieldPos("B1N_VLRTOT")) > 0
						nVlrItem += B1N->B1N_VLRTOT
					else
						nVlrItem += B1N->B1N_VLRAPR
					endIf

					B1N->(RecLock('B1N',.F.))
					B1N->(DbDelete())
					B1N->(DbSkip())
					B1N->( MsUnlock() )

				next nI

			EndIf

			::WSNULL := "true|Excluido com sucesso!"

			//atualiza o valor total apresentado ao incluir novos itens pelo remote.
			BOW->(RecLock('BOW',.F.))
			BOW->BOW_VLRAPR -= nVlrItem
			BOW->( MsUnlock() )
		EndIf

		nVlrItem := 0
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AtuBow   ³Autor  ³ Totvs 				 ³ Data ³19.08.14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Atualiza a BOW com as baixas de titulo							³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD AtuBow WSRECEIVE UserCode,UsrCod WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL aDadUsr := {}
	LOCAL nI
	LOCAL lRetorno := .T.
	LOCAL aMatric  := {}
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se tem direito para executar o metodo								   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode , "PLSXFUN","AtuBow" )
		If BOW->(FieldPos("BOW_PGMTO")) > 0

			//Retorna o usuario relacionado a solicitacao
			cSQL := "SELECT B49_BENEFI "
			cSQL += "FROM " + RetSQLName("B49")
			cSQL += " WHERE B49_CODUSR = '" + UsrCod + "' AND "
			cSQL += " D_E_L_E_T_ = ' '"
			PLSQuery(cSQL,"TrbRetTit")

			While !TrbRetTit->(EOF())
				AADD(aDadUsr, PLSDADUSR(TrbRetTit->B49_BENEFI,'1',.F.,dDatabase,,,"NAO_VALIDAR_CARTAO"))
				AADD(aMatric,TrbRetTit->B49_BENEFI)
				TrbRetTit->(dbSkip())
			EndDo

			TrbRetTit->(dbCloseArea())

			//verifica os reembolsos aprovados e que ainda nao foram atualizados no protocolo que o titulo foi pago.
			For nI := 1 To LEN(aDadUsr)

				BOW->(dbSetOrder(5)) // BOW_FILIAL + BOW_USUARI
				If BOW->(dbSeek(xFilial("BOW") + aMatric[nI]))

					While !BOW->(EOF()) .AND. BOW->BOW_USUARI == aMatric[nI]

						SE2->(dbSetOrder(1)) //E2_FILIAL, E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, E2_FORNECE
						If SE2->(dbSeek(xFilial("SE2") + BOW->(BOW_PREFIX + BOW_NUM + BOW_PARCE + BOW_TIPO + BOW_FORNEC)))

							If !EMPTY(SE2->E2_BAIXA) .AND. LEN(ALLTRIM(BOW->BOW_PGMTO)) < 12

								BOW->(Reclock("BOW",.F.))
								BOW->BOW_PGMTO := 'Pagamento realizado ' + DTOC(SE2->E2_VENCTO)
								BOW->(MsUnlock())

								//caso uma baixa de título seja cancelada, atualiza para a data de pagamento.
							ElseIf EMPTY(SE2->E2_BAIXA) .AND. LEN(ALLTRIM(BOW->BOW_PGMTO)) > 12
								BOW->(Reclock("BOW",.F.))
								BOW->BOW_PGMTO := DTOC(SE2->E2_VENCTO)
								BOW->(MsUnlock())
							EndIf
						EndIf

						BOW->(dbSkip())
					EndDo

				EndIf
			Next
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim do metodo														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DadRetEst    ³Autor  ³ Thiago Guilherme  ³ Data ³08.01.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna o nome de todos os estados							    ³±±
±±³
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETEST WSRECEIVE UserCode,Tipo WSSEND DadEst WSSERVICE PLSXFUN
	LOCAL nI        := 1
	LOCAL aArea	  := GetArea()
	Local aSX5		:= {}
	LOCAL lRetorno  := .T.
	Local nJ 		:= 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "DADRETEST" )

		If EMPTY(Tipo)

			//retorna os estados utilizados no reembolso do portal do beneficiário

			aSX5 := FWGetSX5("12")

			For nJ := 1 To Len(aSX5)
				If ALLTRIM(aSX5[nJ][3]) != "EX"
					AaDd( ::DadEst, WsClassNew( "SDadEst" ))
					::DadEst[nI]:Descri := aSX5[nJ][3]
					nI++
				EndIf
			Next nJ
		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetDadGen 	³Autor  ³ Tabosa 	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os campos com os valores de uma tabela generica		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD GetDadGen WSRECEIVE UserCode, cRecno, Alias, Campos WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea    		:= GetArea()
	LOCAL lRetorno 		:= .T.
	LOCAL cAlias		:= ::Alias
	LOCAL cCampos		:= ::Campos
	LOCAL cStrMacro		:= ""
	LOCAL cRetMacro		:= ""
	LOCAL nAt1, nAt2, nI:= 0
	LOCAL aVlrRet		:= {}
	LOCAL cTipCpo		:= ""
	DEFAULT ::WSNULL 	:= "true|"

	//Checa Usuário
	If PrtChkUser( ::UserCode, "PLSXFUN", "GetDadGen" )

		If Empty(cAlias) .OR. Empty(::cRecno) .OR. Empty(cCampos)
			::WSNULL := "false|Parametros insuficentes para encontrar o registro"
		Else
			::WSNULL 	:= "true|"

			DbSelectArea(cAlias)
			DbGoTo(Val(::cRecno))

			cCampos := StrTran(cCampos,"(mais)" ,"+") // Alguma versão estaqva substituindo o + pro espaço na URL aqui eu trato

			If "***" $ cCampos // quer dizer que tem uma expressão pra rodar entao eu substituo pela macro rodada (Ex: Posicione)

				While (nAt1 := at("***",cCampos)) > 0 // Busco os delimitadores do macro #FUNCAO()#
					nAt2 		:= at("***",SubStr(cCampos, nAt1+1, Len(cCampos)) )
					cStrMacro 	:= SubStr(cCampos, nAt1+3, nAt2-3 )
					cRetMacro 	:= "'" + Alltrim(&(cStrMacro)) + "'" // Executo a macro e guardo na variavel entre aspas (somente string por enquanto)
					cCampos 	:= StrTran(cCampos,"***" + cStrMacro + "***",cRetMacro) // Substituo a macro pelo valor
				EndDo

			EndIf

			aVlrRet := StrToArray(cCampos, "|")

			For nI := 1 To Len(aVlrRet)

				If Substr(cAlias,2,3) + "_" $ Substr(aVlrRet[nI],1,4) // Se é um campo e nao uma expressão trato o tipo

					cTipCpo := Valtype(&(cAlias+"->" + aVlrRet[nI]))

					If cTipCpo <> "C"

						Do Case
							Case cTipCpo == 'N'
								aVlrRet[nI] := "Alltrim(Str(" + aVlrRet[nI] + "))"
							Case cTipCpo == 'D'
								aVlrRet[nI] := "DTOC(" + aVlrRet[nI] + ")"
						EndCase

					EndIf

				EndIf

				::WSNULL += &(cAlias+"->(" + aVlrRet[nI] + ")")  + "|"

			Next nI

		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    PPINDCLIN    ³ Autor ³ Daher			       ³ Data ³ 11/12/14 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PPINDCLIN WSRECEIVE SAutProc WSSEND dTratVinc WSSERVICE PLSXFUN
	Local lRetorno 	:= .T.
	Local nI 		:= 1
	LOCAL aTabDup 	:= PlsBusTerDup(SuperGetMv("MV_TISSCAB", .F. ,"87"))
	LOCAL xCodPad 	:= ""
	LOCAL xCodPro 	:= ""

	AaDd( ::dTratVinc, WsClassNew( "sTratInd" ))

	::dTratVinc[nI]:obrigat := .f.

	BR8->(DbSetOrder(1))//BR8_FILIAL+BR8_CODPAD+BR8_CODPSA+BR8_ANASIN

	for nI := 1 To Len( ::SAutProc:AutItem )

		xCodPad := AllTrim(PLSVARVINC('87','BR4', ::SAutProc:AutItem[nI]:CodPad ))
		xCodPro := AllTrim(PLSVARVINC(xCodPad,'BR8',::SAutProc:AutItem[nI]:ProcedureCode ,xCodPad + ::SAutProc:AutItem[nI]:ProcedureCode,,aTabDup,@xCodPad))

		If BR8->( msSeek( xFilial("BR8") + alltrim(xCodPad + xCodPro) ) )

			If BR8->BR8_TRAIND == '1'

				::dTratVinc[1]:obrigat := .t.

				exit
			endIf

		endIf

	next

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³SenhaExp  ³Autor  ³ Totvs				    ³ Data ³19.03.14   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³verifique se ira mostrar msg expiraçao senha portal		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD SenhaExp WSRECEIVE UserCode, PLSCodUsr WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea		:= getArea()
	LOCAL lRetorno 	:= .t.

	//Se tem direito para executar o metodo
	if PrtChkUser( ::UserCode , "PLSXFUN", "SenhaExp" )

		if BSW->(tamSx3('BSW_SENHA')[1]) >= 32

			//Valida usuario/senha
			BSW->( dbSetOrder(5) ) //BSW_FILIAL + BSW_CODUSR
			if BSW->( msSeek( xFilial("BSW") + ::PLSCodUsr ) )

				aRetSen := PLVLDSDT()

				if ! aRetSen[1] .and. aRetSen[2]
					::WSNULL := "true|Falta(m) " + alltrim( str(aRetSen[3]) ) + " dia(s) para expirar a sua senha, favor efetuar a troca de sua senha...!!!"
				endIf

			endIf

		endIf

	else

		lRetorno := .F.
		setSoapFault( "", "Não autorizado a utilização do metodo" )

	endIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DesProc 	³Autor  ³ Thiago 	            ³ Data ³16.012.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o codigo do procedimento é válido		  		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DesProc WSRECEIVE UserCode, codPro,classe WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea    		:= GetArea()
	DEFAULT ::WSNULL 	:= "true|"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "DesProc" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se o codigo digitado é válido									   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BR8->( DbSetOrder(3) )//BR8_FILIAL + BR8_CODPSA

		If !BR8->( MsSeek( xFilial("BR8")+ codPro))

			::WSNULL := "false|Procedimento não encontrado."

			RestArea( aArea )
			Return lRetorno
		Else

			while xFilial("BR8") + codPro == xFilial("BR8") + ALLTRIM(BR8->(BR8_CODPSA))
				If BR8->(BR8_CLASSE) == classe
					::WSNULL := "true|" + BR8->(BR8_DESCRI) + "|" + BR8->(BR8_CODPAD)

					RestArea( aArea )
					Return lRetorno
				Else
					::WSNULL := "false|Procedimento não encontrado."
				EndIf

				BR8->(dbSkip())
			EndDo
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VldNumGPri³Autor  ³ TOTVS S/A	            ³ Data ³04/11/2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o numero da guia informado e valido			   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VLNUMGUI WSRECEIVE UserCode, NumAut, TipGui, Benef WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRet			:= .T.
	LOCAL cDescricao := "Guia não localizada!"
	DEFAULT ::WSNULL	:= "true|"

	//Verifica o usuario
	If PrtChkUser( ::UserCode, "PLSXFUN", "VLNUMGUI" )

		If PLVLNGUI(::NumAut,::TipGui, ::Benef, @cDescricao)

			::WSNULL := "true|"
		Else
			::WSNULL :=  "true|" + cDescricao
		Endif
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DelAtalho        ³Autor  ³ Karine Riquena	³ Data ³26.11.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Deleta atalho do portal        							        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DelAtalho WSRECEIVE UserCode, CodMenu, UsrCod WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL lReturn := .T.
	LOCAL lAchou  := .F.
	DEFAULT ::WSNULL 	:= "true|"


	If PrtChkUser( ::UserCode, "PLSXFUN", "DelAtalho" )
		dbSelectArea("B95")
		B95->(dbGoTop())

		While (B95->(!Eof()) .AND. lAchou == .F.)
			If(B95->B95_CODUSR == ::UsrCod .and. B95->B95_CODMNU == ::CodMenu)
				RecLock("B95",.F.)
				B95->(dbDelete())
				B95->(MsUnlock())
				lAchou = .T.
			EndIf
			B95->(dbSkip())
		EndDo

		::WSNULL 	:= "true|"
	Else
		lReturn := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea(aArea)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Fim do Metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lReturn
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AddAtalho        ³Autor  ³ Karine Riquena	³ Data ³05.12.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Adiciona atalho no portal      							        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD AddAtalho WSRECEIVE UserCode, CodMenu, UsrCod, CamImg, CodPor WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL lReturn := .T.
	LOCAL cCodPortal
	LOCAL cDescri
	LOCAL aAtalhos := {}
	LOCAL lAchou := .F.
	LOCAL cString
	DEFAULT ::WSNULL 	:= "true|"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "AddAtalho" )
		If ::CodPor == 1
			cCodPortal := "000008"
		Else
			cCodPortal := "000010"
		EndIf

		DbSelectArea("B95")
		DbSetOrder(1) // SIX -> B95_FILIAL+B95_CODUSR+B95_CODMNU+B95_CODPOR
		If !(B95->(DbSeek(XFilial("B95") + UsrCod + ::CodMenu + cCodPortal )))
			cDescri := Posicione("AI8",1,xFilial("AI8") + cCodPortal + ::CodMenu ,"AI8_TEXTO")
			Begin Transaction
				RecLock("B95", .T.)
				B95->B95_FILIAL := xFilial("B95")
				B95->B95_CODUSR := ::UsrCod
				B95->B95_CODMNU := ::CodMenu
				B95->B95_CODPOR := cCodPortal
				B95->B95_DESCRI := cDescri
				B95->B95_IMG    := ::CamImg
				B95->(MsUnlock())
			End Transaction

			dbSelectArea("AI8")
			AI8->(DBGoTop())

			While (AI8->(!Eof()) .AND. lAchou == .F.)
				If(AI8->AI8_CODMNU == ::CodMenu .AND. AI8->AI8_PORTAL == cCodPortal)
					Aadd(aAtalhos, { ::CodMenu, cDescri, ::CamImg, AI8->AI8_WEBSRV, AI8_ROTINA })
					lAchou := .T.
				EndIf
				AI8->(dbSkip())
			EndDo

			AI8->(dbCloseArea())

			cString := Alltrim(aAtalhos[1][1]) + "|" + AllTrim(aAtalhos[1][2]) + "|" + AllTrim(aAtalhos[1][3]) + "|" + AllTrim(aAtalhos[1][4]) + "|" + AllTrim(aAtalhos[1][5])
			::WSNULL := "true|" + cString
		Else
			::WSNULL := "false|Atalho ja existente, verifique!"
		EndIf
	Else
		lReturn := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lReturn
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CriPsw  ³Autor  ³ Totvs				    ³ Data ³19.03.14   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³verifique se ira mostrar msg expiraçao senha portal		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD CriPsw WSRECEIVE UserCode, TipoVld, SenhaVld WSSEND RetSenha WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL lRetorno := .T.

	If PrtChkUser( ::UserCode , "PLSXFUN","CriPsw" )
		::RetSenha := PLSCRIDEC(Val(::TipoVld),::SenhaVld)
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim do metodo														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ UplConhec ³Autor  ³ Oscar				 ³ Data ³15.06.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³			 ³ Upload Banco Conhecimento 									³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD UplConhec WSRECEIVE UserCode, cArquivo, cCodRDA, Chave, Alias, cRecno, Indice, lIncRap, NoArqComp WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno	:= .T.
	LOCAL aArea 	:= GetArea()
	LOCAL cRet 		:= ""
	LOCAL cNomeArq1	:= ""
	Local cNomeExibe:= ""
	Local cExtArq	:= ""
	LOCAL cDirRaiz 	:= PLSMUDSIS( GetNewPar("MV_TISSDIR","\TISS\") )
	LOCAL cDirWeb	:= PLSMUDSIS( cDirRaiz+"UPLOAD\")
	Local nIndice	:= IIF( !(Empty(::Indice)), Val(::Indice), 0 )
	Local nRecno	:= IIF( !(Empty(::cRecno)), Val(::cRecno), 0 )
	local cTabela	:= ::Alias
	Local cPartArq	:= "_"+ Alltrim(Str(month(date()))) + "_" + ( Alltrim(Str(Year(date()))) ) + "_" +;
		Left(Time(),2) + "_" + Substr(Time(),4,2) + "_" + Right(Time(),2)
	Local cAlias    := ""
	Local cAliasIte	:= ""
	Local lDownload	:= .F.
	local cDownload	:= ""
	Local lBlqAne	:= GetNewPar("MV_PLBAGN",.F.)
	Local lGuiNeg	:= .F.
	Local cChaveInt	:= ''
	local cExpExSO	:= "PLSMUDSIS('\')"

	Default lIncRap 	:= .F.

	DEFAULT ::WSNULL 	:= ""
	DEFAULT ::cArquivo 	:= ""
	DEFAULT ::NoArqComp := "" //Texto Adicional a ser adicionado no arquivo para upload.

	If PrtChkUser( ::UserCode ,"PLSXFUN","UplConhec" )

		//Analisa se a matrícula é antiga, se for, altera para o novo padrão.
		If cTabela == "B4F"
			::Chave := PlsProRecAne(::Chave)
		EndIf

		cChave	:= xFilial(cTabela) + ::Chave
		cChavBow	:= substr(::Chave,5,LEN(BOW->BOW_PROTOC))
		cChavBku	:= Chave
		lDownload := GetNewPar("MV_PLPDWN", .F.)

		//Trata se não existe pasta para uploads definida no .INI
		If "ERROR" $ upper(alltrim(cDirWeb))
			FWLogMsg('ERROR',, 'SIGAPLS', funName(), '', '01',"LOG DE ERRO NO UPLOAD PATH: " + Upper( GetPvProfString( GetEnvHost(), "UPLOADPATH", "ERROR", GetADV97() ) ) , 0, 0, {})
			cRet := "Diretorio de upload nao informado no .INI do SERVER."
		Endif

		//Trata se o arquivo existe, já foi enviado, ou não foi informado
		if ! lIncRap

			//Adiciona o dia no cPartArq
			cPartArq := allTrim(str(day(date()))) + cPartArq

			If ! empty(::cArquivo) .and. empty(cRet)

				cExpExSO  	:= iif( IsSrvUnix() .and. ("\" $ cArquivo), "('\')", "PLSMUDSIS('\')" )
				cNomeArq1	:= lower( allTrim( subStr( ::cArquivo, Rat(&(cExpExSO),::cArquivo)+1) ) )

				//Copia nome Arquivo para montar nome exibição
				cNomeExibe := cNomeArq1

				//Pega a extensão do arquivo
				cExtArq := subStr(cNomeArq1, RAT(".", cNomeArq1)+1) //Alterado de AT para RAT

				//Monta nome de exibição
				cNomeExibe := subStr(cNomeExibe, 1, RAT(".", cNomeExibe)) + cExtArq

				//Pega o nome do arquivo
				cNomeArq1 := subStr(cNomeArq1, 1, RAT(".", cNomeArq1)-1)

				//Renomeia o aruqivo para nome nome + data atual + horário atual
				if ! empty(::NoArqComp)
					cPartArq += lower("_" + ::NoArqComp)
				endif

				FRenameEx(cDirWeb + cNomeArq1 + "." + cExtArq, cDirWeb + cNomeArq1 + "_" + cPartArq + "." + cExtArq)

				If Empty(cNomeArq1)
					cRet :=  "Falha ao incluir (Verifique se o arquivo já foi inserido ou entre em contato com a operadora)"
				Endif

				//atribuição apra busca no banco de conhecimento
				cNomeArq1 := cNomeArq1 + "_" + cPartArq + "." + cExtArq

				ACB->( dbSetOrder(2) )
				If ACB->( msSeek( xFilial("ACB") + upper( allTrim(cNomeArq1) ) ) )
					cRet := "Arquivo [" + cNomeExibe + "] ja existe no banco de conhecimento, altere o nome e tente novamente!"
				endIf

			Else
				cRet := "Arquivo nao informado."
			EndIf

		ELSE

			If ! Empty(::cArquivo) .and. Empty(cRet)

				cNomeArq1 := Lower( AllTrim( SubStr( ::cArquivo, Rat(PLSMUDSIS('\'),::cArquivo)+1) ) )
				cExtArq	:= SubStr(cNomeArq1, RAT(".", cNomeArq1)+1)
				cNomeArq1	:= SubStr(cNomeArq1, 1, AT(".", cNomeArq1)-1)

				FRenameEx(cDirWeb+cNomeArq1+"."+cExtArq, cDirWeb+::Chave+cPartArq+"."+cExtArq)

				cNomeArq1 := ::Chave+cPartArq+"."+cExtArq

				If Empty(cNomeArq1)
					cRet :=  "Falha ao incluir (Verifique se o arquivo já foi inserido ou entre em contato com a operadora)"
				Endif

				ACB->(DbSetOrder(2))
				If ACB->(MsSeek(xFilial("ACB") + Upper(Alltrim(cNomeArq1))))
					cRet := "Arquivo ja existe no banco de conhecimento, altere o nome e tente novamente!"
				EndIf

			Else
				cRet := "Arquivo nao informado."
			EndIf

		ENDIF

		If Empty(cRet)
			//Posiciona no registro
			//Se o REcno não foi informado, traz o Recno do registro
			//Dono da chave informada
			if ( nRecno == 0 .and. ! lIncRap )

				&(cTabela)->(DbSetOrder(nIndice))
				&(cTabela)->(MsSeek(cChave))

				nRecno := &(cTabela)->(Recno())

			EndIF

			IF ! empty(cRecno)
				&(cTabela)->( DbGoTo( nRecno ) )
			EndIf

			If cTabela != "BOW"

				BE4->(dbSetOrder(2))
				BEA->(dbSetOrder(1))
				B4A->(dbSetOrder(1))
				B4Q->(DbSetOrder(1))
				BE2->(DbSetOrder(1))
				B4C->(DbSetOrder(1))

				If BE4->(MsSeek(xFilial("BE4") + subStr(Chave,1,18)))
					cAlias 		:= "BE4"
					cAliasIte 	:= "BEJ"
				ElseIf BEA->(MsSeek(xFilial("BEA") + subStr(Chave,1,18)))
					cAlias 		:= "BEA"
					cAliasIte 	:= "BE2"
				ElseIf B4A->(MsSeek(xFilial("B4A") + subStr(Chave,1,18)))
					cAlias 		:= "B4A"
					cAliasIte 	:= "B4C"
				ElseIf B4Q->(MsSeek(xFilial("B4Q") + subStr(Chave,1,18)))
					cAlias 		:= "B4Q"
					cAliasIte 	:= "BQV"
				EndIf

				//Verifica Guia/Evento negado na auditoria
				if ! Empty(cAlias)

					lGuiNeg := &(cAlias + "->" + cAlias +"_STATUS") == "3"

					If ! lGuiNeg .and. Len(Chave) == 21

						If (&(cAliasIte)->(MsSeek(xFilial(cAliasIte)+Chave)))
							lGuiNeg := &(cAliasIte + "->" + cAliasIte +"_STATUS") == "0" .AND. &(cAliasIte + "->" + cAliasIte +"_AUDITO") == "0"
						EndIf

					EndIf

				EndIf

			EndIf

			//Se há arquivo, chama função que grava no banco de conhecimento
			//E exclui do local padrão de upload
			If lBlqAne .and. lGuiNeg

				cRet 	 := "Não é permitido incluir anexos em guia/evento negado."
				::WSNULL := "false|" + cRet

				Return(lRetorno)

			ElseIf ! Empty(cNomeArq1)

				PLSINCONH(cDirWeb + cNomeArq1, IIF(::Alias == "BEJ","BE2",::Alias), cChave,.T.)

				//Se tiver B53, altera para deixar identificado como "Existe Documento"
				cChaveInt := substr(cChave, len(xFilial("BEA")) + 1, 18)
				PLSATUB53(cChave, cChaveInt, ::Alias)

				//Se permitir download, copia o arquivo para o diretorio web
				If lDownload

					cDownload := SuperGetMV("MV_RELT")

					// Copio para pasta de downloads
					__COPYFILE( PLSMUDSIS(cDirWeb + cNomeArq1), PLSMUDSIS(cDownload + cNomeArq1) )

				EndIf

				FERASE(cDirWeb + cNomeArq1) //apaga arquivo do diretorio WEB e deixa apenas no conhecimento

			EndIf

			cRet := "Arquivo Enviado com sucesso."

			If cTabela != "BOW"

				If ! empty(cAlias)

					BBR->(dbSetOrder(1))
					If BBR->(MsSeek(xFilial("BBR") + Chave))

						// Só devo atualizar o status da Guia se for interação, pois essa função é generica pra anexo de documentos, não deve ocorrer pra tudo
						If cAlias != 'BEA' .And. cAlias != 'BE4'
							&(cAlias + "->(RecLock('" + cAlias + "',.F.))" )
							&(cAlias + "->" + cAlias +"_STATUS") := "6"
							&(cAlias + "->(MsUnLock())")
						EndIf

						While BBR->(BBR_FILIAL + BBR_CODOPE + BBR_ANOAUT + BBR_MESAUT + BBR_NUMAUT + BBR_SEQPRO) == xFilial("BBR") + Chave

							If !BBR->BBR_RESPRE  .OR. BBR->BBR_TPDIRP == "B" //quando é beneficiario não tem respostas

								BBR->(RecLock("BBR",.F.))
								BBR->BBR_RESPRE := .F.
								BBR->BBR_TPDIRP := ""
								BBR->(MsUnLock())

								exit
							EndIf

							BBR->(DbSkip())
						EndDo

					EndIf

				EndIf

			EndIf

			//Atualmente o protocolo de reembolso não possui interação com o beneficiário, caso este processo
			//se confirme o código abaixo deve ser retirado.
			IF cTabela == "BOW"

				DbselectArea("BOW")
				DbSetOrder(1)
				IF DbSeek(xFilial("BOW") + cChavBow)

					If BOW->BOW_STATUS == "B"
						BOW->(RecLock("BOW",.F.))
						BOW->BOW_STATUS := "2"
						BOW->(MsUnLock())
					Endif

				Endif
			Endif

			// Alterando status do envio da documentação
			IF cTabela == "BKU"
				DbselectArea("BKU")
				DbSetOrder(1)
				IF DbSeek(xFilial("BKU") + cChavBku)
					If BKU->BKU_STATUS == "9"
						BKU->(RecLock("BKU",.F.))
						BKU->BKU_STATUS := "7"
						BKU->(MsUnLock())
					Endif

				Endif
			Endif


			IF (ValType(HttpSession->nAnexos) == "N")
				HttpSession->nAnexos := HttpSession->nAnexos + 1
			else
				HttpSession->nAnexos := 1
			EndIf

		EndIf

		::WSNULL := "true|" + cRet

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GrvSolAdt  ³Autor  ³ Oscar 				 ³ Data ³15.06.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ 		 ³																³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GrvSolAdt WSRECEIVE UserCode, cCodRDA, CodSol, Observ WSSEND WSNULL WSSERVICE PLSXFUN

	LOCAL lRetorno	:= .T.
	LOCAL aArea 		:= GetArea()
	LOCAL cRet 		:= ""

	DEFAULT ::WSNULL 	:= ""

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se tem direito para executar o metodo								   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode ,"PLSXFUN","GrvSolAdt" )

		cRet := PLS814GRVS(::CodSol, ::cCodRDA, ::Observ)
		::WSNULL := "true|" + cRet

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ConSolAdt  ³Autor  ³ Oscar				 ³ Data ³15.06.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³			 ³																³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ConSolAdt WSRECEIVE UserCode, cCodRDA, Chave WSSEND WSNULL WSSERVICE PLSXFUN

	LOCAL lRetorno	:= .T.
	LOCAL aArea 		:= GetArea()
	LOCAL cRet 		:= ""

	DEFAULT ::WSNULL 	:= ""

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se tem direito para executar o metodo								   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode ,"PLSXFUN","ConSolAdt" )

		cRet := PLS814SEND(::cCodRDA, ::Chave)
		::WSNULL := cRet

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetPrestBB8  ³Autor  ³Everton M Fernandes ³ Data ³15.10.15   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna dados do prestador de acordo com a BAX               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetPrestBB8 WSRECEIVE UserCode, RecnoBB8 WSSEND RetPrest WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL lRetorno := .T.

	If PrtChkUser( ::UserCode , "PLSXFUN","GetPrestBB8" )

		BB8->(DbSelectArea("BB8"))
		BB8->(DbGoTo(val(::RecnoBB8)))

		cRet := "{Descricao:'" + trim(BB8->BB8_DESLOC)	+ "'," + ;
			"CPFCGC:'"		+ trim(BB8->BB8_CPFCGC)	+ "'," + ;
			"Estado:'"		+ trim(BB8->BB8_EST)	+ "'," + ;
			"Municipio:'"	+ trim(BB8->BB8_MUN)	+ "'," + ;
			"Bairro:'"		+ trim(BB8->BB8_BAIRRO)	+ "'," + ;
			"Endereco:'"	+ trim(BB8->BB8_END)	+ "'," + ;
			"Numero:'"		+ trim(BB8->BB8_NR_END)	+ "'," + ;
			"CEP:'"		+ trim(BB8->BB8_CEP)	+ "'," + ;
			"Telefone:'"	+ trim(BB8->BB8_TEL)	+ "'," + ;
			"Email:'"		+ trim(BB8->BB8_EMAIL)	+ "'," + ;
			"Site:'"		+ trim(BB8->BB8_WEB)	+ "'"

		BAU->(DbSelectArea("BAU"))
		BAU->(DbSetOrder(1))
		If BAU->(MsSeek(xFilial("BAX")+trim(BB8->BB8_CODIGO)))
			cRet += ",NFantasia:'" + trim(BAU->BAU_NFANTA) + "'" + ;
				",Nome:'" + trim(BAU->BAU_NOME) + "'" + ;
				",ConReg:'" + trim(BAU->BAU_CONREG) + "'}"

		Else
			cRet += ",NFantasia:''" + ;
				",Nome:''" + ;
				",ConReg:''}"
		EndIf


		::RetPrest := cRet
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Retorno
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim do metodo														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
//--------------------------------------------------------------------------
/*/{Protheus.doc} Acreditacoes
WS que retorna as acreditações.

@Project	TTQLAU
@author	Lucas de Azevedo Nonato
@since		15/10/2015
@version	P12
/*/
//---------------------------------------------------------------------------

wsMethod Acreditacoes wsReceive UserCode,CodRdaAcr wsSend Acredit wsService PLSXFUN
	local lRetorno := .T.
	local i 		:= 1
	local aArea 	:= GetArea()
	local cSql		:= ""

	if PrtChkUser( ::UserCode , "PLSXFUN","Acreditacoes" )

		cSql := " SELECT B7P_CODIGO, B7P_CODACR, B7P_NIVACR, B7P_CODINT, B7P_CODLOC "
		cSql += "   FROM " + RetSQLName("B7P")
		cSql += "  WHERE B7P_FILIAL = '" + xFilial("B7P") + "' "
		cSql += "   AND B7P_CODIGO = '" + alltrim(CodRdaAcr) + "'  "
		if B7P->(FieldPos("B7P_DATINI")) > 0
			cSql += " 	AND (B7P_DATINI = '        ' OR B7P_DATFIM = '        ' OR (B7P_DATINI <= '" + dtos(date()) + "' AND B7P_DATFIM >= '" + dtos(date()) + "'))  "
		endif
		cSql += "   AND D_E_L_E_T_ = ' ' "

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,ChangeQuery(cSql)),"TrbB7P",.T.,.F.)

		while !TrbB7P->(eof())

			aadd( ::Acredit, WsClassNew( "SAcredit" ))

			::Acredit[i]:CODIGO 	:= TrbB7P->B7P_CODIGO
			::Acredit[i]:CODACR     := TrbB7P->B7P_CODACR
			::Acredit[i]:DESCACR    := PlRetSX5("ZJ",TrbB7P->B7P_CODACR)
			::Acredit[i]:NIVACR     := TrbB7P->B7P_NIVACR
			::Acredit[i]:DESCNIV	:= PlsNIVACR(TrbB7P->B7P_NIVACR)
			::Acredit[i]:CODINT     := TrbB7P->B7P_CODINT
			::Acredit[i]:CODLOC     := TrbB7P->B7P_CODLOC
			i++

			TrbB7P->(dbSkip())
		endDO

	else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	endif

	RestArea( aArea )

return lRetorno

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} PlsNIVACR
Retorna a descrição do nivel de acreditações.

@Project	TTQLAU
@author	Lucas de Azevedo Nonato
@since		15/10/2015
@version	P12
@Return	L

/*/
//---------------------------------------------------------------------------------------
Function PlsNIVACR(cNivAcr)
	Local cDesc := ''

	DO CASE
		CASE alltrim(cNivAcr) == '1'
			cDesc := "Acreditado"
		CASE alltrim(cNivAcr) == '2'
			cDesc := "Acreditado Pleno"
		CASE alltrim(cNivAcr) == '3'
			cDesc := "Acreditado com Excelencia"
		CASE alltrim(cNivAcr) == '4'
			cDesc := "Acreditado sem nivel de acreditacao"
		OTHERWISE
			cDesc := " "
	ENDCASE

Return cDesc

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETSIGLACR ³Autor  ³ TOTVS             ³ Data ³17.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna as siglas do C.R dos profissionais       		    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETSIGLACR WSRECEIVE UserCode WSSEND DadSiglaCR WSSERVICE PLSXFUN
	LOCAL nI        := 1
	LOCAL aArea	  := GetArea()
	LOCAL lRetorno  := .T.


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³retorna os tipos de documentos utilizados no reembolso do portal do beneficiário	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

	BAH->(DbSetOrder(1))
	//BAH->(MsSeek(xFilial("BAH")+""))
	While !BAH->(Eof()) //.and. BAH->BAH_XXX == "XXXX"
		AaDd( ::DadSiglaCR, WsClassNew( "SDadSiglaCR" ))
		::DadSiglaCR[nI]:Descri := BAH->BAH_CODIGO
		nI++
		BAH->(DbSkip())
	Enddo

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GrvIntera ³Autor  ³ Roberto	Vanderlei     ³ Data ³12.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Atualiza Auditoria/Interação	   	  							 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GrvIntera WSRECEIVE Chave, ChaveInt, Resposta, Pendente, Publico WSSEND WSNULL WSSERVICE PLSXFUN
	local cSETORAT := GetNewPar("MV_SETORAT","00")
	local cAliasMov
	Local cAliasRec
	local cChavGui:= SUBSTR(::ChaveInt,1,18)
	local lPendInte := .F.
	default ::Pendente := .T.
	default ::Publico := ""

	B53->(dbSetOrder(1))

	If B53->(msSeek(xFilial("B53") + ::Chave)) .or. B53->(msSeek(xFilial("B53") + cChavGui))
		Begin Transaction

			BBR->(dbSetOrder(2))

			//Atualiza Interacao
			If BBR->(msSeek(xFilial("BBR") + ::ChaveInt))

				cAlias := BBR->BBR_ALIMOV

				BBR->(RecLock("BBR",.F.))
				BBR->BBR_RESPOS := ::Resposta
				BBR->BBR_SETOR  := Posicione("SX5",1,xFilial("SX5")+"BL"+cSETORAT/*BX4->BX4_CODDEP*/,"X5_DESCRI")//cSETORAT
				BBR->BBR_TPDIRP:=""
				BBR->(MsUnLock())
			endif

			//se o publico é prestador e não há mais pendencias com anexos e respostas, atualiza o status da guia
			if (::Publico) == "P"  .and.  !(::Pendente)

				If BBR->(msSeek(xFilial("BBR") + cChavGui))
					While (BBR->(!Eof()) .AND. BBR->(BBR_FILIAL+BBR_CODOPE+BBR_ANOAUT+BBR_MESAUT+BBR_NUMAUT) == (xFilial("BBR") + cChavGui))

						//Verifica se tem alguma pendência de interação por parte do PRESTADOR, caso possua, o setor responsável permanece como PRESTADOR.
						If BBR->BBR_TPDIRP == "P" .and. BBR->BBR_RESPRE .AND. EMPTY(BBR->BBR_RESPOS)
							lPendInte := .T.
							EXIT

						ElseIf !BBR->BBR_ANEXAD
							lPendInte := .T.
							EXIT
						endif

						BBR->(dbSkip())
					endDo
				EndIf

				If !lPendInte

					if(cAlias == "BEA")
						BEA->(DbSetOrder(1))
						If BEA->(MsSeek(xFilial("BEA")+B53->(B53_NUMGUI)))
							BEA->(RecLock("BEA",.F.))
							BEA->BEA_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
							BEA->(MsUnLock())
						EndIf
					elseif(cAlias == "BE4")
						BE4->(DbSetOrder(2))
						If BE4->(MsSeek(xFilial("BE4")+B53->(B53_NUMGUI)))
							BE4->(RecLock("BE4",.F.))
							BE4->BE4_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
							BE4->(MsUnLock())
						EndIf
					elseif(cAlias == "B4A")
						B4A->(DbSetOrder(1))
						If B4A->(MsSeek(xFilial("B4A")+B53->(B53_NUMGUI)))
							B4A->(RecLock("B4A",.F.))
							B4A->B4A_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
							B4A->(MsUnLock())
						EndIf

					endIf

					IF B53->B53_ALIMOV=="B4Q"
						B4Q->(DbSetOrder(1))
						If B4Q->(MsSeek(xFilial("B4Q")+B53->(B53_NUMGUI)))
							B4Q->(RecLock("B4Q",.F.))
							B4Q->B4Q_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
							B4Q->(MsUnLock())
						EndIf

					Endif

					//Atualiza Auditoria
					cAliasMov 	:= B53->B53_ALIMOV
					cAliasRec 	:= B53->B53_RECMOV

					B53->(RecLock("B53",.F.))
					B53->B53_CODDEP := cSETORAT
					B53->(MsUnLock())

					//Atualizar tabela de Encaminhamento - B71
					IF !Empty(cSETORAT)
						PLSICB71(cAliasMov, cAliasRec, cSETORAT,::Resposta )
					ENDIF
				EndIf

				::WSNULL := If(lPendInte, 'true', 'false')
			Else
				if(cAlias == "BEA")
					BEA->(DbSetOrder(1))
					If BEA->(MsSeek(xFilial("BEA")+B53->(B53_NUMGUI)))
						BEA->(RecLock("BEA",.F.))
						BEA->BEA_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
						BEA->(MsUnLock())
					EndIf
				elseif(cAlias == "BE4")
					BE4->(DbSetOrder(2))
					If BE4->(MsSeek(xFilial("BE4")+B53->(B53_NUMGUI)))
						BE4->(RecLock("BE4",.F.))
						BE4->BE4_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
						BE4->(MsUnLock())
					EndIf
				elseif(cAlias == "B4A")
					B4A->(DbSetOrder(1))
					If B4A->(MsSeek(xFilial("B4A")+B53->(B53_NUMGUI)))
						B4A->(RecLock("B4A",.F.))
						B4A->B4A_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
						B4A->(MsUnLock())
					EndIf

				endIf

				IF B53->B53_ALIMOV=="B4Q"
					B4Q->(DbSetOrder(1))
					If B4Q->(MsSeek(xFilial("B4Q")+B53->(B53_NUMGUI)))
						B4Q->(RecLock("B4Q",.F.))
						B4Q->B4Q_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
						B4Q->(MsUnLock())
					EndIf

				Endif

				//Atualiza Auditoria
				cAliasMov 	:= B53->B53_ALIMOV
				cAliasRec 	:= B53->B53_RECMOV

				B53->(RecLock("B53",.F.))
				B53->B53_CODDEP := cSETORAT
				B53->(MsUnLock())

				//Atualizar tabela de Encaminhamento - B71
				IF !Empty(cSETORAT)
					PLSICB71(cAliasMov, cAliasRec, cSETORAT,::Resposta )
				ENDIF
				::WSNULL := 'true'
			endIf

		End Transaction
	endif

return .T.


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetInteracao ³Autor  ³ Roberto	        ³ Data ³07.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Busca dados das Interações   	 	 				           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetInteracao WSRECEIVE IteDad  WSSEND MViewInteracao WSSERVICE PLSXFUN

	LOCAL lRet       := .F.
	LOCAL cAliMov	  := ::IteDad:AliMov
	LOCAL cAliIte	 := ""
	LOCAL cCodOpe    := ::IteDad:CodOpe
	LOCAL cAnoAut    := ::IteDad:AnoAut
	LOCAL cMesAut    := ::IteDad:MesAut
	LOCAL cNumAut    := ::IteDad:NumAut
	LOCAL cSeqProc   := ::IteDad:SeqProc
	LOCAL cTpPublico := ::IteDad:TpPublico
	LOCAL cAnoProBKU := ::IteDad:AnoAut
	LOCAL cMesProBKU := ::IteDad:MesAut
	LOCAL cNumProBKU := ::IteDad:NumAut
	LOCAL cNrProtocolo := ""
	LOCAL cChavebku    := ""
	local nCont      := 0
	local cSQL       := ""
	local cObs		:= ""
	local cRespos	:= ""

	// Ajuste para considerar o cabeçalho e o item pra mostrar o historico pois ambos são gravados na tabela
	IF cAliMov == "BE2" .OR. cAliMov == "BEA"
		cAliIte := "BE2"
		cAliMov := "BEA"
	ElseIf cAliMov == "BE4" .OR. cAliMov == "BEJ"
		cAliIte := "BEJ"
		cAliMov := "BE4"
	ElseIf cAliMov == "B4A" .OR. cAliMov == "B4C"
		cAliIte := "B4C"
		cAliMov := "B4A"
	ElseIf cAliMov == "B4Q" .OR. cAliMov == "BQV"
		cAliIte := "BQV"
		cAliMov := "B4Q"
	ElseIf cAliMov == "BKU"
		cAliMov := "BKU"
	EndIf

	::MViewInteracao 	:= {}

	cSQL := "SELECT * FROM " + RetSQLName("BBR")
	cSQL += "WHERE BBR_FILIAL = '" + xFilial("BBR") + "' "
	if (cAliMov == "BKU")

		cNrProtocolo := cAnoProBKU + cMesProBKU + cNumProBKU
		cSQL += "AND BBR_TPDIRP = '" + cTpPublico + "'"
		cSQL += "AND BBR_NRPRO LIKE '%" + cNrProtocolo + "%'"
	Else
		cSQL += "AND BBR_CODOPE = '" + cCodOpe + "' "
		cSQL += "AND BBR_ANOAUT = '" + cAnoAut + "' "
		cSQL += "AND (BBR_TPDIRP = '" + cTpPublico + "' OR BBR_TPDIRP = 'A') "
		cSQL += "AND BBR_MESAUT = '" + cMesAut + "' "
		cSQL += "AND BBR_NUMAUT = '" + cNumAut + "' "
		cSQL += "AND BBR_SEQPRO = '" + cSeqProc + "' "
		cSQL += "AND (BBR_ALIMOV = '" + cAliMov + "' OR BBR_ALIMOV = '" + cAliIte + "') "
	EndIf
	cSQL += "AND " + RetSQLName("BBR")+".D_E_L_E_T_ = ''"

	cSQL := ChangeQuery(cSQL)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TrbBBR",.T.,.F.)

	while !TrbBBR->(EOF())

		nCont += 1

		AaDd( ::MViewInteracao, WsClassNew( "SViewInteracao" ) )

		if cTpPublico = TrbBBR->BBR_TPDIRP .Or. TrbBBR->BBR_TPDIRP = 'A'

			::MViewInteracao[nCont]:SeqInt 	  	:= TrbBBR->BBR_SEQUEN
			::MViewInteracao[nCont]:SeqMop 	  	:= TrbBBR->BBR_SEQMOP
			::MViewInteracao[nCont]:DesMop 	  	:= Posicione("BBP",1,xFilial("BBP")+TrbBBR->BBR_SEQMOP,"BBP_DESMOT")
			::MViewInteracao[nCont]:Setor 	  	:= TrbBBR->BBR_SETOR
			::MViewInteracao[nCont]:DtIteracao  := STOD(TrbBBR->BBR_DTITER)
			::MViewInteracao[nCont]:ResPre 		:= &("."+TrbBBR->BBR_RESPRE+".")
			::MViewInteracao[nCont]:Anexado		:= &("."+TrbBBR->BBR_ANEXAD+".")
			::MViewInteracao[nCont]:TipDirec	:= TrbBBR->BBR_TPDIRP

			If cAliMov == "BKU"
				cChavebku := TrbBBR->BBR_NRPRO
				BBR->(dbSetOrder(4))
				lRet := BBR->(MsSeek(xFilial("BBR") + cChavebku))
			else
				BBR->(dbSetOrder(2))
				lRet := BBR->(MsSeek(xFilial("BBR") + cCodOpe + cAnoAut + cMesAut + cNumAut + cSeqProc + TrbBBR->BBR_SEQUEN))
			EndIf

			if lRet
				//Codifica em hexadecimal
				cObs := ""
				cRespos := ""
				if !empty(BBR->BBR_OBSERV)

					cObs := plsStrBNum( BBR->BBR_OBSERV ,16, 2 )
				endif

				if !empty(BBR->BBR_RESPOS)

					cRespos := plsStrBNum( BBR->BBR_RESPOS ,16, 2 )

				endif
			EndIf
			::MViewInteracao[nCont]:RespPrest 	:= cRespos
			::MViewInteracao[nCont]:Observacao	:= cObs
			::MViewInteracao[nCont]:AliasPai	:= TrbBBR->BBR_ALIMOV
		endif

		TrbBBR->(DbSkip())
	enddo

	TrbBBR->(dbCloseArea())

return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETCID	 ³Autor  ³ Fábio S. dos Santos   ³ Data ³22/07/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Recebe o código do estado e envia os códigos e descrições das ³±±
±±³			 ³cidades.														³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETCID WSRECEIVE UserCode, CodEst WSSEND DADRETMUN WSSERVICE PLSXFUN
	Local nI		:= 1
	LOCAL aArea 	:= GetArea()
	Local lRetorno	:= .T.

	If PrtChkUser( ::UserCode ,"PLSXFUN","DADRETESPEC" )

		BID->(DbSetOrder(4))
		BID->(MsSeek(xFilial("BID")+alltrim(::CodEst)))
		While ( !(BID->(EoF())) .AND. (BID->BID_EST == alltrim(::CodEst)))
			Aadd(::DADRETMUN, WsClassNew ( "SDadCodMun" ) )
			::DADRETMUN[nI]:CodCid := BID->BID_CODMUN
			::DADRETMUN[nI]:Descri := StrTran(BID->BID_DESCRI,"'"," ")
			nI++
			BID->(DbSkip())
		EndDo
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do método." )
	EndIf
	RestArea( aArea )
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETCEN	 ³Autor  ³ Roberto vanderlei   ³ Data ³  16/11/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Recebe o código do CEP e retorna o endereço. 					³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETBEN WSRECEIVE UserCode, CpfCnpj  WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	Local lRetorno	:= .T.
	::WSNULL := ""
	If PrtChkUser( ::UserCode ,"PLSXFUN","DADRETCEN" )
		BTS->(DbSetOrder(3))
		BTS->(MsSeek(xFilial("BTS")+ ::CpfCnpj + Space(TamSX3("BTS_CPFUSR")[1]-Len( AllTrim(::CpfCnpj)))   ))
		While ( !(BTS->(EoF())) .AND. (Alltrim(BTS->(BTS_CPFUSR)) == Alltrim(::CpfCnpj)))
			::WSNULL := "true|" + BTS->BTS_NOMUSR + "|" + SubStr((dtos(BTS->BTS_DATNAS)),7,2) + '/'+ SubStr((dtos(BTS->BTS_DATNAS)),5,2)+'/'+ SubStr((dtos(BTS->BTS_DATNAS)),0,4) + "|" + BTS->BTS_DRGUSR + "|" + BTS->BTS_ORGEM +  "|" + BTS->BTS_NRCRNA + "|" + BTS->BTS_PAI + "|" + BTS->BTS_MAE + "|" + BTS->BTS_EMAIL + "|" + BTS->BTS_CEPUSR  + "|" + BTS->BTS_COMEND + "|" + BTS->BTS_NR_END + "|" + BTS->BTS_DDD + "|" + BTS->BTS_TELEFO + "|" + BTS->BTS_SEXO + "|" + BTS->BTS_RGEST + "|" + BTS->BTS_UNIVER + "|" + BTS->BTS_ESTCIV + "|" + BTS->BTS_INVALI + "|" + BTS->BTS_ESTADO + "|" + BTS->BTS_CODMUN + "?" + BTS->BTS_MUNICI + "|" + BTS->BTS_ENDERE + "|" + BTS->BTS_BAIRRO
			BTS->(DbSkip())
		EndDo
	Else
		lRetorno := .F.
		//SetSoapFault( "", "Não autorizado a utilização do método." )
	EndIf
	RestArea( aArea )
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETCEN	 ³Autor  ³ Roberto vanderlei   ³ Data ³  16/11/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Recebe o código do CEP e retorna o endereço. 					³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETCEN WSRECEIVE UserCode, Cep WSSEND WSNULL WSSERVICE PLSXFUN

	LOCAL aArea := GetArea()
	Local lRetorno := .T.

	::WSNULL := ""
	If PrtChkUser( ::UserCode ,"PLSXFUN","DADRETCEN" )
		BC9->(DbSetOrder(1))
		BC9->(MsSeek(xFilial("BC9") + ::Cep))	//	Se for EOF() (CEP não Cadastrado), irá limpar os campos na Tela
		::WSNULL := "true|" + BC9->(IIF(EOF(), "CEP não Cadastrado !", BC9_END)) + "|" + BC9->BC9_BAIRRO + "|" + BC9->BC9_CODMUN+"?"+BC9->BC9_MUN + "|" + BC9->BC9_EST
	Else
		lRetorno := .F.
	EndIf
	RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VERBENPRI	 ³Autor  ³ Roberto vanderlei   ³ Data ³  16/11/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Recebe o Login e verifica se é benef, ou ja solicitou.        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VERBENPRI WSRECEIVE UserCode, UsrLoginCode WSSEND WSNULL WSSERVICE PLSXFUN

	LOCAL aArea 	:= GetArea()
	Local lRetorno	:= .T.

	::WSNULL := ""

	If PrtChkUser( ::UserCode ,"PLSXFUN","VERBENPRI" )

		BA1->(DbSetOrder(4))
		BA1->(MsSeek(xFilial("BA1")+ alltrim(::UsrLoginCode) + Space(TamSX3("BA1_CPFUSR")[1]-Len( AllTrim(::UsrLoginCode)))   ))

		if (!(BA1->(EoF())) .AND. (Alltrim(BA1->(BA1_CPFUSR)) == Alltrim(::UsrLoginCode)))
			::WSNULL	:= "N"
		else
			B2N->(DbSetOrder(2))
			B2N->(MsSeek(xFilial("B2N")+ alltrim(::UsrLoginCode) + Space(TamSX3("B2N_CPFUSR")[1]-Len( AllTrim(::UsrLoginCode)))   ))

			if (!(B2N->(EoF())) .AND. (Alltrim(B2N->(B2N_CPFUSR)) == Alltrim(::UsrLoginCode)))
				::WSNULL	:= "N"
			else
				::WSNULL	:= "S"
			endif
		endif
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do método." )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETENDER ³Autor  ³ Oscar Zanin         ³ Data ³24.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Carrega combo de locais de atendimento	 	               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETENDER WSRECEIVE UserCode, cCodRDA, cCodLoc  WSSEND DadEnder WSSERVICE PLSXFUN

	Local cCodInt := PLSINTPAD()
	Local nI		:= 1
	Local lRetorno	:= .T.
	local cCodLoc		:= IIF(ValType(::cCodLoc) == "C", ::cCodLoc, "")

	If PrtChkUser( ::UserCode ,"PLSXFUN","DADRETENDER" )

		BB8->(DbSetOrder(1))
		BB8->(MsSeek(xFilial("BB8")+::cCodRDA+cCodInt+cCodLoc))
		while (!(BB8->(EoF())) .AND. (BB8->(BB8_CODIGO) == ::cCodRDA) .And. BB8->(BB8_CODLOC) == cCodLoc .And. Empty(BB8->(BB8_DATBLO)) )
			Aadd(::DadEnder, WsClassNew ( "sDadEnder" ) )
			::DadEnder[nI]:CodLoc := BB8->(BB8_CODLOC)
			::DadEnder[nI]:Descri := BB8->(BB8_END)
			nI++
			BB8->(DbSkip())
		EndDo
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETESPEC ³Autor  ³ Oscar Zanin         ³ Data ³24.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Carrega combo de especialidades	 		 	               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETESPEC WSRECEIVE UserCode, cCodRDA, CodLoc WSSEND DadEspec WSSERVICE PLSXFUN

	Local cCodInt := PLSINTPAD()
	Local nI		:= 1
	Local lRetorno	:= .T.
	local cCodLoc		:= IIF(ValType(::CodLoc) == "C", ::CodLoc, "")
	Local cCodRDA		:= Iif(Valtype(::cCodRDA) == "C", ::cCodRDA, "")

	If PrtChkUser( ::UserCode ,"PLSXFUN","DADRETESPEC" )

		BAX->(DbSetOrder(1))
		BAX->(MsSeek(xFilial("BAX")+cCodRDA+cCodInt+cCodLoc))
		while ( !(BAX->(EoF())) .AND. (BAX->(BAX_CODIGO) == ::cCodRDA) .AND. (BAX->(BAX_CODLOC) == ::CodLoc) )
			Aadd(::DadEspec, WsClassNew ( "SDadEspec" ) )
			::DadEspec[nI]:CodEsp := BAX->(BAX_CODESP)
			::DadEspec[nI]:Descri := Posicione("BAQ",1,xFilial("BAQ")+cCodInt+BAX->BAX_CODESP,"BAQ_DESCRI")
			nI++
			BAX->(DbSkip())
		EndDo
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GRAVALOG 	³Autor  ³ Oscar Zanin           ³ Data ³24.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Grava solicitação de inclusão de corpo clínico               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GRAVALOG WSRECEIVE UserCode, DadLog, cUsrLogin WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno	:= .T.
	Local cDados		:= ::DadLog
	Local cLogin 		:= ::cUsrLogin
	Local cRet			:= ""

	DEFAULT ::WSNULL 	:= "true|"

	If PrtChkUser( ::UserCode ,"PLSXFUN","GRAVALOG" )

		cRet := PLS814LOG(cDados, cLogin)
		::WSNULL += cRet
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADLOAD	³Autor  ³ Oscar Zanin           ³ Data ³24.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os estados e sigla CR para combos corpo clínico      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADLOAD WSRECEIVE UserCode, Tipo WSSEND Dadload WSSERVICE PLSXFUN
	LOCAL nI        	:= 1
	LOCAL cTipo		:= iif(EMPTY(::Tipo),"UF|SIGLA",::Tipo)
	LOCAL lRetorno  	:= .T.
	Local aSX5 		:= {}
	Local nJ		:= 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "DADLOAD" )

		//Faz consulta de acordo com o parâmetro 'Campos':
		// VAZIO 	- UF e Sigla
		// UF		- Apenas UF
		// Sigla	- Apenas Sigla

		If(cTipo == "UF|SIGLA" .or. Upper(cTipo) == "UF")
			aSX5 := FWGetSX5("12")

			For nJ := 1 To Len(aSX5)
				AaDd( ::Dadload, WsClassNew( "SDadload" ))
				::Dadload[nI]:DescriA := aSX5[nJ][3]
				nI++
			Next nJ
		EndIf

		If(cTipo == "UF|SIGLA" .or. Upper(cTipo) == "SIGLA")
			BAH->(DbSetOrder(1))
			BAH->(DbGoTop())
			While !BAH->(Eof())
				AaDd( ::Dadload, WsClassNew( "SDadload" ))
				::Dadload[nI]:DescriB := BAH->BAH_CODIGO
				nI++
				BAH->(DbSkip())
			Enddo
		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DelCorpoClinico³Autor  ³ TOTVS	        ³ Data ³20/07/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Bloqueia um profissional do copro clinico                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DelCorpoClinico WSRECEIVE UserCode, cRecno, Alias WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea    		:= GetArea()

	BC1->(DbGoTo(Val(cRecno)))
	RecLock('BC1', .F.)
	BC1_CODBLO := GetNewPar("MV_PLBLQCC", "   ")
	BC1_MOTBLO := Posicione("BAP", 1, xFilial("BAP") + BC1->BC1_CODBLO, "BAP_DESCRI")
	BC1_DATBLO := dDataBase
	BC1_OBSERV := "Bloqueio via Portal"
	MsUnlock()
	::WSNULL := "true|Bloqueado com sucesso!"
	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetCalend ³Autor  ³ Giuvany Ribeiro       ³ Data ³05.08.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Pegar o calendario                                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetCalend WSRECEIVE UserCode, RDACode WSSEND WSNULL WSSERVICE PLSXFUN
	Local lRet 		:= .T.
	Local aArea 	:= GetArea()
	Local nI		:= 1
	Local aAux		:={}
	Local aRet    := {}
	Local  cCodPad := Subs(AllTrim(GetMv("MV_PLSCDCO")),1,2)
	Local  cCodPro := Subs(AllTrim(GetMv("MV_PLSCDCO")),3,16)
	Local lReembolso:= .F.
	Local lJob :=.T.
	Local lRPC	:= .T.
	Local lHelp := .F.
	Local cCodInt := PLSINTPAD()
	Local aRdas := strtokarr(RDACode, "|")
	Local cDataDe := ""
	Local cDataAte := ""
	DEFAULT WSNULL := ""

	If PrtChkUser( ::UserCode, "PLSXFUN","GetCalend" )
		for nI := 1 to len(aRdas)
			aAux := PLSXVLDCAL(Date(),cCodInt,lHelp,cCodPad,cCodPro,lRPC,aRdas[nI],lReembolso,lJob)
			if aAux[1]
				if nI > 1
					::WSNULL += "@"
				endIf

				if len(aAux) > 8
					cDataDe := aAux[8]
					cDataAte := aAux[9]
					if Len(aAux) > 10 .AND. aAux[10]
						if Date() >= CtoD(aAux[11]) .AND. Date() <= cToD(aAux[12])
							cDataDe := aAux[11]
							cDataAte := aaux[12]
						endif
					endif
					::WSNULL += aRdas[nI]+"|"+cDataDe+"~"+cDataAte
				else
					::WSNULL += aRdas[nI]
				endif

				aAdd(aRet, aAux)
			Else
				if nI > 1
					::WSNULL += "@"
				endIf

				if len(aAux) > 8
					::WSNULL += aRdas[nI]+"|"+ "Não encontrado" +"~"+ "Não encontrado"
				else
					::WSNULL += aRdas[nI]
				endif

				aAdd(aRet, aAux)
			endIf
		next nI
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o 	 ³CheckProcedimento ³Autor  ³ Rodrigo Morgon³ Data ³17/08/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³        ³Verifica se solicitação do prestador pode ser realizada        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD CHECKPROCEDIMENTO WSRECEIVE UserCode, DadLog WSSEND WSNULL WSSERVICE PLSXFUN

	LOCAL aArea	  	:= GetArea()
	LOCAL lRetorno	:= .T.
	LOCAL cCodInt		:= PlsIntPad()
	LOCAL cCodRDA		:= ""
	LOCAL cCodLoc		:= ""
	LOCAL cCodEsp		:= ""
	LOCAL cCodTab		:= ""
	LOCAL cCodPro		:= ""
	LOCAL cPadBkp		:= ""
	LOCAL lHasBC0		:= .F.
	LOCAL lHasB7L		:= .F.
	LOCAL cSQL		    := ""
	LOCAL nQtdReg	 	:= 0

	PRIVATE aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "CHECKPROCEDIMENTO" )

		::WSNULL 	:= "true|"

		// Realiza validação de acordo com os critérios do Where na BC0 e B7L
		//
		// BC0 - Procedimentos da RDA
		// aWhere[1] = 1 - Inclusão = Verifica se não existe registro na base para esse procedimento
		// aWhere[1] = 2 - Exclusão = Verifica se existe registro na base para esse procedimento
		//
		// B7L - Tabela de log
		// aWhere[1] = 1 - Inclusão = Verifica se não existe solicitação em análise para essa RDA, tabela e procedimento
		// aWhere[1] = 2 - Exclusão = Verifica se não existe solicitação de exclusão para essa RDA, tabela e procedimento
		//
		// Para todos os casos, se uma das condições não for satisfeita, retorna .F.

		//Formata os campos para correta busca na tabela
		aDadLog := Separa( ::DadLog, "|" )

		cCodRDA	:= AllTrim(aDadLog[2])+Space(TamSX3("BC0_CODIGO")[1]-Len(AllTrim(aDadLog[2])))
		cCodLoc	:= AllTrim(aDadLog[3])+Space(TamSX3("BC0_CODLOC")[1]-Len(AllTrim(aDadLog[3])))
		cCodEsp	:= AllTrim(aDadLog[4])+Space(TamSX3("BC0_CODESP")[1]-Len(AllTrim(aDadLog[4])))
		cCodTab	:= AllTrim(aDadLog[5])+Space(TamSX3("BC0_CODTAB")[1]-Len(AllTrim(aDadLog[5])))
		cCodPro	:= AllTrim(aDadLog[7])+Space(TamSX3("BC0_CODOPC")[1]-Len(AllTrim(aDadLog[7])))

		//DE/PARA da tabela e procedimento ANS para código interno.
		//cColuna, cAlias, lMsg, cCodTab , cVlrTiss, lPortal, aTabDup, cPadBkp )
		cPadBkp	:= PLSGETVINC("BTU_VLRBUS", "BR4", .F., "87", cCodTab, .T.)
		cCodTab	:= AllTrim(cPadBkp)
		cCodPro 	:= PLSGETVINC("BTU_VLRBUS", "BR8", .F., cCodTab,  cCodTab + AllTrim(cCodPro), .T. ,aTabDup, @cPadBkp)

		//Verifica na tabela BC0 - Procedimentos da RDA e na B7L - Tabela de log
		BC0->(DbSetOrder(1)) // BC0_FILIAL+BC0_CODIGO+BC0_CODINT+BC0_CODLOC+BC0_CODESP+BC0_CODTAB+BC0_CODOPC
		BC0->(MsSeek(xFilial("BC0") + cCodRDA + cCodInt + cCodLoc + cCodEsp + cCodPro))
		lHasBC0 := !BC0->(EoF())

		//Verifica na tabela B98 se existe cabeçalho de item criado para a RDA selecionada
		B98->(DbSetOrder(2)) //B98_FILIAL+B98_CODINT+B98_CODIGO
		B98->(MsSeek(xFilial("B98") + cCodInt + cCodRDA))

		While !B98->(EoF()) .And. (B98->(B98_CODIGO) == cCodRda) .And. !lHasB7L
			If	!B98->(B98_APROVA) .and. !B98->(B98_INDEFE) .and. !B98->(B98_ATIVO)
				//Se existe na B98 e ainda não foi verificada (isto é, não foi aprovada/indeferida/não está ativa
				//Verifica se os itens tabela B7L correspondem ao procedimento solicitado.
				//Verificação feita através do índice B7L_FILIAL+B7L_CHAVE+B7L_CAMPO

				B7L->(DbSetOrder(3))
				B7L->(MsSeek(xFilial("B7L") + PADR(B98->B98_CODSEQ, TamSX3("B7L_CHAVE")[1]) + "BC0_CODOPC"))

				lHasB7L := !B7L->(EoF()) .And. AllTrim(B7L->B7L_VLPOS) == AllTrim(cCodPro)
			EndIf

			B98->(DbSkip())
		EndDo

		If AllTrim(aDadLog[1]) == "1" .AND. !lHasB7L//Inclusão de procedimento
			cSQL := "SELECT B7L_CHAVE"
			cSQL += " FROM " + RetSQLName("B7L")
			cSQL += " WHERE B7L_CAMPO = 'BC0_CODIGO' AND B7L_VLPOS = '" + cCodRDA + "' AND"
			cSQL += " B7L_GRAVAD = 'F' AND " + RetSqlName("B7L")+".D_E_L_E_T_ = '' "

			cSQL += " OR    B7L_CAMPO = 'BC0_CODLOC' AND B7L_VLPOS = '" + cCodLoc + "' AND"
			cSQL += " B7L_GRAVAD = 'F' AND " + RetSqlName("B7L")+".D_E_L_E_T_ = '' "

			cSQL += " OR    B7L_CAMPO = 'BC0_CODESP' AND B7L_VLPOS = '" + cCodEsp + "' AND"
			cSQL += " B7L_GRAVAD = 'F' AND " + RetSqlName("B7L")+".D_E_L_E_T_ = '' "

			cSQL += " OR    B7L_CAMPO = 'BC0_CODPAD' AND B7L_VLPOS = '" + cCodTab + "' AND"
			cSQL += " B7L_GRAVAD = 'F' AND " + RetSqlName("B7L")+".D_E_L_E_T_ = '' "

			cSQL += " OR    B7L_CAMPO = 'BC0_CODOPC' AND B7L_VLPOS = '" + SUBSTR(cCodPro,4) + "' AND"
			cSQL += " B7L_GRAVAD = 'F' AND " + RetSqlName("B7L")+".D_E_L_E_T_ = '' "

			cSQL += " GROUP BY B7L_CHAVE"
			cSQL += " HAVING COUNT(B7L_CHAVE) = 5"

			cSQL := ChangeQuery(cSQL)
			dbUseArea( .T., "TOPCONN", TCGENQRY(,,cSQL),"B7LQuery", .F., .T.)

			Count To nQtdReg //Variavel que recebe a quantidade de registros

			B7LQuery->(dbCloseArea())

			If nQtdReg > 0
				lHasB7L := .T.
			EndIf
		EndIf

		Do Case
			//Inclusão de procedimento
			Case AllTrim(aDadLog[1]) == "1"
				If lHasBC0 .or. lHasB7L
					//Procedimento já existente no cadastro, então não pode ser realizado novamente.
					::WSNULL := "false|Procedimento já cadastrado ou em análise."
				EndIf

				//Exclusão de procedimento
			Case AllTrim(aDadLog[1]) == "2"
				If !lHasBC0
					::WSNULL := "false|Procedimento não encontrado."
				EndIf
		EndCase

		RestArea(aArea)
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

return lRetorno


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GRAVAPROCEDIMENTO ³Autor  ³ Rodrigo Morgon³ Data ³21.08.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   	Grava solicitação de inclusão ou exclusão procedimento   		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GRAVAPROCEDIMENTO WSRECEIVE UserCode, DadLog, cUsrLogin WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno	:= .T.
	Local cDados		:= ::DadLog
	Local cLogin 		:= ::cUsrLogin
	Local cRet			:= ""
	Local aDados		:= {}
	Local aLinhas		:= {}
	Local nI			:= 1

	DEFAULT ::WSNULL 	:= "true|"

	If PrtChkUser( ::UserCode ,"PLSXFUN","GRAVAPROCEDIMENTO" )

		//Cria um array com todas as linhas da grid
		aDados := Separa(cDados,"|",.F.)
		for nI := 1 to len(aDados)
			aadd(aLinhas, Separa(aDados[nI],"$",.F.))
		next

		cRet := PLS814PROC(aLinhas, cLogin)
		::WSNULL += cRet
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VerAcesso ³Autor  ³ Roberto Vanderlei     ³ Data ³14.08.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verificar primeiro acesso, caso sim, solicitar atualização.  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VERACESSO WSRECEIVE UsrLoginCode WSSEND WSNULL WSSERVICE PLSXFUN
	Local lRet 		     	:= .T.
	local lPrimeiroAcesso 	:= .F.
	local cPrimeiroAcesso	:= ''
	local cNomUsr  			:= ""
	local cLogin  	 		:= ""
	local cSenha   			:= ""
	local nCont				:= 0
	local cMensagem 		:= ""

	DEFAULT WSNULL := ""

	if ValType(HttpSession->aMensagensPortal) = 'U'
		HttpSession->aMensagensPortal := PLSRETMSG("3")
	endif

	for nCont := 1 to len(HttpSession->aMensagensPortal)

		if (HttpSession->aMensagensPortal[nCont][1] == "STR0001")
			cMensagem := HttpSession->aMensagensPortal[nCont][2]
			exit
		endif

	next nCont

	BSW->(DbSetOrder(5))
	if BSW->( MsSeek( xFilial("BSW") + ::UsrLoginCode ) )

		lPrimeiroAcesso := BSW->BSW_PRIACE

		if lPrimeiroAcesso
			cPrimeiroAcesso := "true"
		else
			cPrimeiroAcesso := "false"
		endif

		cNomUsr := BSW->BSW_NOMUSR
		cLogin := BSW->BSW_LOGUSR
		cSenha := BSW->BSW_SENHA

		If Len(cSenha) == 64
			cSenha := SHA256(Trim(cSenha))
		Else
			cSenha := PLSCRIDEC(2, BSW->BSW_SENHA) //Se estiver no padrão antigo, descriptografa e gera o hash MD5
		EndIf	

		if alltrim(cMensagem) <> ""
			cMensagem := strTran(cMensagem, "%NOMUSR%", Capital(cNomUsr))
		endif

		::WSNULL := ::UsrLoginCode + "|" + cLogin + "|" + Capital(cNomUsr) + "|" + cSenha + "|" + cPrimeiroAcesso + "|" + cMensagem

	else
		lRet := .F.
		SetSoapFault( "", "Usuário não encontrado.")
	endIf

Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ GrvSolOpc ³Autor  ³ Oscar 				 ³ Data ³18.09.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³			 ³	Grava solicitação  2 de 2                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GrvSolOpc WSRECEIVE UserCode, Chave WSSEND WSNULL WSSERVICE PLSXFUN

	LOCAL lRetorno	:= .T.
	LOCAL aArea 		:= GetArea()

	DEFAULT ::WSNULL 	:= ""

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se tem direito para executar o metodo								   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode ,"PLSXFUN","GrvSolOpc" )

		PLS009WEBP(::Chave)
		::WSNULL := "true|"

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Exclusão Banco Conhecimento³Autor  ³ Oscar ³ Data ³05.10.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³UnUplConhec ³																      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD UnUplConhec WSRECEIVE UserCode, cRecno WSSEND WSNULL WSSERVICE PLSXFUN

	LOCAL lRetorno	:= .T.
	LOCAL lRet    	:= .T.
	LOCAL aArea 		:= GetArea()
	LOCAL cRet 		:= ""
	Local nRecno		:= IIF( !(Empty(::cRecno)), Val(::cRecno), 0 )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se tem direito para executar o metodo								   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode ,"PLSXFUN","UnUplConhec" )

		If nRecno > 0
			//Chama a função para exclusão do arquivo
			lRet := PLSOUTCONH( nRecno )
		EndIf

		If lRet
			cRet := "Arquivo Excluído com sucesso"
		EndIF

		::WSNULL := "true|"+cRet

	Else
		lRetorno := .F.
		::WSNULL := "false|"+"Erro na exclusão"
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³Cópia da base conhecimento³Autor ³ Francisco ³ Data ³06.01.2017 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³CpyArqConhe ³																      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD CpyArqConhe WSRECEIVE UserCode, cRecno WSSEND WSNULL WSSERVICE PLSXFUN

	LOCAL lRetorno	:= .T.
	LOCAL aArea 		:= GetArea()
	LOCAL cRet 		:= ""
	Local nRecno		:= IIF( !(Empty(::cRecno)), Val( STRTRAN(::cRecno,".","")), 0 )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se tem direito para executar o metodo								   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode ,"PLSXFUN","CpyArqConhe" )

		If nRecno > 0
			//Chama a função para copia do arquivo
			cRet := PLSCOPWEB( nRecno )
		EndIf

		If !Empty(cRet)
			::WSNULL := "true|"+cRet
		Else
			::WSNULL := "false|Falha ao baixar o arquivo"
		EndIF
	Else
		lRetorno := .F.
		::WSNULL := "false|"+"Erro na transmissão do arquivo"
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DelDesp³Autor  ³ Oscar Zanin   ³ Data ³20.10.2015 		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Método para deletar uma despesa adicionada							  	 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DelDesp WSRECEIVE UserCode, cRecno WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno 	:= .T.
	Local lRet			:= .T.
	Local aArea		:= GetArea()
	Local cRet			:= ""
	Local nRecno		:= IIF( !(Empty(::cRecno)), Val(::cRecno), 0 )

	If PrtChkUser( ::UserCode, "PLSXFUN", "DelDesp" )

		If nRecno > 0
			lRet := PLSOUTB1N(nRecno)
		EndIf

		If lRet
			cRet := "Despesa Excluída com sucesso"
		EndIf

		::WSNULL := "true|"+cRet

	else
		lRetorno := .F.
		::WSNULL	:= "false|"+"Erro na Exclusão"
		setSoapFault( "", "Não autorizado a utilização do método" )
	EndIF

	restArea(aArea)

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GrvFimReemb³Autor  ³ Oscar Zanin   ³ Data ³20.10.2015 		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Finaliza gravação da solicitação de reembolso 							  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GrvFimReemb WSRECEIVE UserCode, MatUsu, NomRdaNRef, CPFCNPJ, cUsrLogin, CodSol, NumDoc, DocEmi, Tipo, Altera, DocObrig, CabAlt, RecDivs, AtuB1N, TipoVld WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno	:= .T.
	Local aRet		:= {}
	Local cRet		:= ""
	Local cCodSol	:= If(Valtype(::CodSol) == "C", ::CodSol, "ZZZZX")
	Local aDados	:= {}
	LOCAL aDadUsr := PLSGETUSR()
	Local aDadBK6	:= {}
	Local lIncBK6	:= GetNewPar("MV_VRDANRF", .F.)
	Local cUf		:= ""
	Local cMunc		:= ""
	LOCAL aDadRet := {}

	DEFAULT ::Altera   := "false"
	DEFAULT ::DocObrig := "true"
	DEFAULT ::CabAlt   := .F.
	DEFAULT ::RecDivs  := "0"
	DEFAULT ::AtuB1N   := "S"
	DEFAULT ::TipoVld  := "1"

	// Quando esse método é executado por fora do portal protheus, o aDadUsr fica vazio porque não passar por nenhum lugar que executa PLSDADUSR.
	// É necessário executar PLSDADUSR.
	If Len(aDadUsr) == 0
		// Executa PLSDADUSR apenas para alimentar a váriavel stática aDadUsr do PLSMFUN. Essa váriavel será necessária ao longo deste processo e depende essa ação.
		aDadUsr := PLSDADUSR(::MatUsu,'1',.F.,dDatabase,,,"NAO_VALIDAR_CARTAO")
	Endif

	//Monta aDados
	Aadd(aDados, ::MatUsu)
	Aadd(aDados, ::CPFCNPJ)
	Aadd(aDados, ::cUsrLogin)
	Aadd(aDados, xFilial("BOW"))
	Aadd(aDados, AllTrim(::NomRdaNRef))
	Aadd(aDados, AllTrim(::NumDoc))
	Aadd(aDados, ::DocEmi)
	Aadd(aDados, ::Tipo)
	Aadd(aDados, cUf)
	Aadd(aDados, cMunc)

	//Verifico se é Multicomprovante. Se sim, tenho que pegar as possiveis RDAs diferentes na B1N
	//Além disso, o sistema grava na BOW o estado e Municipio da primeira inclusão, mas caso coloquemos mais
	//de um comprovante, o sistema retorna o CNPJ do último comprobante, sem sempre de acordo com a BOW
	If (TipoVld == "1" .And. !lIncBK6 ) //Tem que ser multicomprovante = "1" e o parâmetro deve estar false, grava direto
		aDadBK6 := PLSRCRNRF (cCodSol)
		If ( (Empty(aDados[2]) .Or. aDados[2] <> aDadBK6[2,1]) .And. (Len(aDadBK6[1]) > 0) )
			aDados[2] := Iif(!Empty(aDadBK6[2,1]), aDadBK6[2,1], aDadBK6[1,2,2])
		EndIf
		If ( (Empty(aDados[5]) .Or. aDados[5] <> aDadBK6[2,2]) .And. (Len(aDadBK6[1]) > 0))
			aDados[5] := Iif(!Empty(aDadBK6[2,2]), aDadBK6[2,2], aDadBK6[1,2,1])
		EndIf
		If (!Empty(aDadBK6[2,3]) .AND. len(aDadBK6[1]) >= 1)
			aDados[9]  := Iif(!Empty(aDadBK6[2,3]), aDadBK6[2,3], aDadBK6[1,2,3])
			aDados[10] := Iif(!Empty(aDadBK6[2,4]), aDadBK6[2,4], aDadBK6[1,2,4])
		EndIf
	Endif


	If PrtChkUser( ::UserCode, "PLSXFUN", "GrvFimReemb" )
		if !empty(cCodSol)

			If BCT->(FieldPos("BCT_VALREE")) > 0

				//verifica se existem itens negados e deleta do banco de dados.
				aDadRet := PLDELITEM(cCodSol)

				//Se na primeir posição retornar true, significa que existe pelo menos um item aprovado no protocolo.
				If aDadRet[1]

					cRet := PLSCMPBOW(cCodSol, aDados, ::Altera, ::DocObrig, ::CabAlt, ::RecDivs, ::AtuB1N)
					aRet := Separa(cRet, "|")
					if aRet[1] == "true"
						lRetorno := .T.
					EndIf

					//se na segunda posição retornar false significa que não existem itens negados.
					If !aDadRet[2]
						::WSNULL := cRet + "|true"
					else

						//se na segunda posição retornar true significa existem itens negados e aprovados no protocolo.
						::WSNULL := "true|<b>Os itens negados não serão gravados ou contabilizados no protocolo!</b>"
						::WSNULL += "<br/><br/>"
						::WSNULL += SubStr(cRet,6)
						::WSNULL += "|false"
					EndIf
				Else
					//se na primeira posição retornar false significa que todos os itens foram negados.
					::WSNULL := "true|Solicitação não concluída pois todos os itens foram negados!|false"
				EndIf
			Else

				cRet := PLSCMPBOW(cCodSol, aDados, ::Altera, ::DocObrig, ::CabAlt, ::RecDivs, ::AtuB1N)
				aRet := Separa(cRet, "|")

				if aRet[1] == "true"
					lRetorno := .T.
				EndIf

				::WSNULL := cRet
			EndIf
		Else
			::WSNULL := "false|"
		EndIf
	else
		lRetorno := .F.
		::WSNULL := "false|"
		setSoapFault("", "Não autorizado a utilização do método" )
	EndIF

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VerPermRee³Autor  ³ Oscar Zanin   ³ Data ³20.10.2015 		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Verifica se o usuário do portal tem permissão para solicitar reembolso ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VerPermRee WSRECEIVE UserCode, cUsrLogin WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno := .T.

	If PrtChkUser( ::UserCode, "PLSXFUN", "VerPermRee" )
		::WSNULL := IIF( PLSREEMBDI(::cUsrLogin), "true", "false" )
	else
		lRetorno := .F.
		::WSNULL := "false|"
		setSoapFault("", "Não autorizado a utilização do método" )
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DadFrmEmp ³Autor  ³ Karine Riquena Limp   ³ Data ³11.09.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Retorna os beneficiários que fazem parte do grupo familiar            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DadFrmEmp WSRECEIVE UserCode, cUsrLogin, TpPor, SoFam, MatUsu, PermT,DtRecibo WSSEND DadosGrpFam WSSERVICE PLSXFUN

	LOCAL nI          := 1
	LOCAL aArea	      := GetArea()
	LOCAL lRetorno    := .T.
	LOCAL cSQL		  := ""
	LOCAL lDatFonte   := GetApoInfo( "PLSXFUN.PRW" )[4]  >= CTOD("31/08/18")
	LOCAL cSQL2       := ""
	LOCAL lCpoCodRas  := BA3->(FieldPos("BA3_CODRAS")) > 0
	LOCAL cCodRas     := ""

	DEFAULT ::TpPor  	:= 3
	DEFAULT ::SoFam   	:= ""
	DEFAULT ::MatUsu  	:= ""
	DEFAULT ::PermT		:= ""
	DEFAULT ::DtRecibo 	:= ""

	If PrtChkUser( ::UserCode, "PLSXFUN", "DadGrpFam" )

		////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//³retorna a matricula do beneficiario que esta cadastrado para o login	³
		//Se Permt igual a 1, significa que é filtro referente aos usuários na solicitaçãod e reembolso
		//pois agora, o controle de quem pode constar neste campo como disponíevl para reembolso é via BA1_REEWEB
		// e BA3_REEWEB não existe mais.
		////////////////////////////////////////////////////////////////////////////////////////////////////////////
		DtRecibo := IIF(!EMPTY(DtRecibo), DTOS(CTOD(DtRecibo)), DTOS(dDataBase))

		If (::PermT == '1') // Como mencionado acima, o Permt tem de ser igual a 1 para condizer que seja solicitação de reembolso.
			cSQL := PLSGETBA1(::TpPor, ::cUsrLogin, ::MatUsu, ::SoFam)
		Else
			cSQL := PLSGETREE(::TpPor, ::cUsrLogin, ::MatUsu, ::SoFam, ::PermT)
		EndIf

		cSQL := ChangeQuery(cSQL)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TrbRetFE",.T.,.F.)

		While !TrbRetFE->(EOF())

			If lDatFonte .AND. lCpoCodRas .And. (::PermT != '1')

				cCodRas := TrbRetFE->BA3_CODRAS
				If TrbRetFE->BA1_DATINC <= DtRecibo .And. (TrbRetFE->BA1_DATBLO > DtRecibo .or. Empty(TrbRetFE->BA1_DATBLO)) .And. !Empty(DtRecibo)

					AaDd( ::DadosGrpFam, WsClassNew( "SDadGrp" ) )
					::DadosGrpFam[nI]:Matricl  := TrbRetFE->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)
					::DadosGrpFam[nI]:NomeBnf  := ALLTRIM(TrbRetFE->BA1_NOMUSR)
				Else
					nI--
				EndIf
			Else

				AaDd( ::DadosGrpFam, WsClassNew( "SDadGrp" ) )
				::DadosGrpFam[nI]:Matricl := TrbRetFE->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)
				::DadosGrpFam[nI]:NomeBnf := TrbRetFE->BA1_NOMUSR
			EndIf


			nI++
			TrbRetFE->(dbSkip())
		EndDo

		TrbRetFE->(dbCloseArea())

		//Preenche o array de beneficiários com os beneficiários vinculados ao código de rastreio BA3_CODRAS
		If lDatFonte .AND. lCpoCodRas .AND. !Empty(cCodRas) .and. !Empty(DtRecibo)

			If ::PermT == '1'
				cSQL2 := PLSGETRAS(cCodRas,DtRecibo)
				cSQL2 := ChangeQuery(cSQL2)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL2),"TrbRetRas",.T.,.F.)

				While !TrbRetRas->(EOF())
					If (TrbRetRas->BA1_DATINC <= DtRecibo .And. (TrbRetRas->BA1_DATBLO > DtRecibo .or. Empty(TrbRetRas->BA1_DATBLO)))

						AaDd( ::DadosGrpFam, WsClassNew( "SDadGrp" ) )
						::DadosGrpFam[nI]:Matricl  := TrbRetRas->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)
						::DadosGrpFam[nI]:NomeBnf  := ALLTRIM(TrbRetRas->BA1_NOMUSR) //+ " - " + ;
						nI++
					EndIF
					TrbRetRas->(dbSkip())

				EndDo

				TrbRetRas->(dbCloseArea())
			EndIf
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	If Empty(DadosGrpFam)
		lRetorno := .F.
	EndIF

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³INCBENOPC ³Autor  ³ Fábio S. dos Santos   ³ Data ³14/08/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³ Realiza a gravacao dos Beneficiários x Opcionais			   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD INCBENOPC WSRECEIVE UserCode, DadosOpc, cUsrLogin, CodPor, Classe WSSEND WSNULL WSSERVICE PLSXFUN
	Local lRet		:= .T.
	Local lRetorno	:= .T.
	Local aRet		:= {}
	Local aDadRet	:= {}
	Local cMsg		:= ""
	Local oDados	:= DadosOpc:DADOSBENOPC
	Local nI := 1
	local aOpc := {}
	local cMatTit := ""
	local cCodOpc := ""
	local cVerOpc := ""
	local cDesOpc := ""
	local cMatricula := ""
	local cOpc := ""
	local lVldOpcTit := SuperGetMv("MV_PVLOPCT")
	Default WSNULL := ""

	If PrtChkUser( ::UserCode, "PLSXFUN", "SolOpc" )

		if lVldOpcTit .and. len(::DadosOpc:DADOSBENOPC) > 0
			BA1->(dbSetOrder(1))
			BA1->(msSeek(xFilial("BA1")+left(::DadosOpc:DADOSBENOPC[1]:CODBEN, 14)+ALLTRIM(SuperGetMv("MV_PLCDTIT"))))
			cMatTit := BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)

			For nI := 1 to len(::DadosOpc:DADOSBENOPC)

				cMatricula := ::DadosOpc:DADOSBENOPC[nI]:CODBEN
				cCodOpc    := ::DadosOpc:DADOSBENOPC[nI]:CODOPC
				cVerOpc    := ::DadosOpc:DADOSBENOPC[nI]:VEROPC
				cDesOpc    := Posicione("BI3",1,xFilial("BI3")+PLSINTPAD()+cCodOpc,"BI3_DESCRI")

				//garanto que vou validar o codigo do opcional apenas uma vez, pois posso ter varios dependentes com o mesmo codigo
				if !(aScan(aOpc, { |x| x == cCodOpc}) > 0 )
					//se não é a matricula do titular e não tem ele na solicitação com esse codigo de opcional e não existe na BF4 a matricula do titular
					if(cMatricula != cMatTit) .and. !(AScan( ::DadosOpc:DADOSBENOPC, { |x| x:CODBEN == cMatTit .and. x:CODOPC == cCodOpc} ) > 0)	;
							.and. !PLSVLDOPCT(cMatTit, cCodOpc, 3)

						cOpc += cCodOpc+"~"+cVerOpc+"~"+cDesOpc+"#"
						lRet := .F.

					endIf

					aAdd(aOpc, cCodOpc)

				endIf


			Next nI

		endIf

		if lRet

			If ExistBlock("PLSGRVBEN")
				aRet := ExecBlock("PLSGRVBEN",.F.,.F.,{oDados})
				lRet	:= aRet[1]
			EndIf

		endIf

		If lRet
			::WSNULL := PLS009GRV(::DadosOpc, cUsrLogin, CodPor, Classe)

			aDadRet := Separa( ::WSNULL, '|' )
			cMsg := "Solicitação gravada com sucesso, seu protocolo é " + aDadRet[5]
			If aDadRet[1] == "1"
				cExec := "W_PPLUPLOPC.APW?cChave="+aDadRet[2]+"&cRecno="+aDadRet[3]+"&cLista="+aDadRet[4]+"&cModo=2&cAlitab=BBA&cNumInd=1"
				::WSNULL := "anexo|" + cMsg + ", por favor anexar os documentos necessários na pagina seguinte!|" + cExec + "|" + aDadRet[6]
			Else
				::WSNULL := cMsg
			EndIf
		Elseif !lRet .and. !empty(cOpc)
			::WSNULL := "opctit|" + left(cOpc, len(cOpc)-1)
		Else
			::WSNULL := aRet[2]
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VldBenOpc ³Autor  ³ Karine Riquena Limp   ³ Data ³21.09.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Verifica se os beneficiarios inseridos na solicitação já possuem os   ³±±
±±³  opcionais solicitados na base de dados e em vigência                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VLDBENOPC WSRECEIVE UserCode, Valores, ArrOpc WSSEND WSNULL WSSERVICE PLSXFUN
	local aValores := {}
	local cMatricula := ""
	local cCodOpc := ""
	local cVerOpc := ""
	local cDesOpc := ""
	local cNome := ""
	local cValores := ""
	local cRec := ""
	local cVldEspe := ""
	local dtBlo
	local dtBas
	local dtAtu := dToS(Date())
	local nI := 0
	local lAchou := .F.
	local lRetorno := .T.
	local aRet := {.T., ""}
	local aOpc := {}
	local cMatTit := ""
	local cOpcTit := ""
	local lVldOpcTit := getNewPar("MV_PVLOPCT", .F.)
	Local lPLVINSOP  := ExistBlock("PLVINSOP")
	Default ::WSNULL := ""
	Default ::ArrOpc := ""
	If PrtChkUser( ::UserCode, "PLSXFUN", "VldBenOpc" )
		aValores	:= Separa ( ::Valores, "@" , .F.)

		BF4->(dbSetOrder(1))
		nI := 1

		if lVldOpcTit .and. len(aValores) > 0

			BA1->(dbSetOrder(1))
			cValores   := Separa(aValores[1], ";", .F.)
			BA1->(msSeek(xFilial("BA1")+left(Separa(cValores[1], "$", .F.)[2], 14)+ALLTRIM(SuperGetMv("MV_PLCDTIT"))))
			cMatTit := BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)
		endIf

		while nI <= len(aValores) .AND. len(aValores) > 0 // essa condição é pq eu diminuo o array no meio do while
			cValores   := Separa(aValores[nI], ";", .F.)
			cMatricula := left(Separa(cValores[1], "$", .F.)[2], 16) // retiro o digito da matricula
			cNome      := Separa(cValores[2], "$", .F.)[2]
			cCodOpc    := Separa(cValores[3], "$", .F.)[2]
			cDesOpc    := Separa(cValores[5], "$", .F.)[2]
			dtBas      := Separa(cValores[6], "$", .F.)[2]
			dtBlo      := Separa(cValores[7], "$")[2] //retirei .F. pois quando nao vinha a data de bloqueio dava array out of bounds, esse .f. é para não considerar a posição quando estiver vazia
			lAchou     := .F.

			If lPLVINSOP
				//se for bloqueada a inclusão do opcional por algun motivo especificico,
				//esse ponto de entrada retorna um array, composto por um valor lógico e uma mensagem
				aRet := ExecBlock("PLVINSOP",.F.,.F.,{cMatricula, cCodOpc, cToD(dtBas), cToD(dtBlo)})
			Endif

			if(aRet[1])
				if(BF4->(MsSeek(xFilial("BF4")+cMatricula+cCodOpc)))
					while( BF4->(!EOF()) .AND. ;
							BF4->(BF4_FILIAL+BF4_CODINT+BF4_CODEMP+BF4_MATRIC+BF4_TIPREG+BF4_CODPRO);
							==(xFilial("BF4")+cMatricula+cCodOpc)  .AND. !lAchou  )
						dtBas := dToS(BF4->BF4_DATBAS)
						dtBlo := dToS(BF4->BF4_DATBLO)
						//verifica se o opcional está em vigênia
						if ( (empty(dtBas) .or. dtBas <= dtAtu) .AND. (empty(dtBlo) .or. dtAtu <= dtBlo) )
							ADEL(aValores, nI)
							ASIZE(aValores, (len(aValores)-1))
							nI-- //nI-- porque estou diminuindo o array
							cRec += cMatricula+"~"+cNome+"~"+cCodOpc+"~"+cDesOpc+"~"+dToC(BF4->BF4_DATBAS)+"~"+dToC(BF4->BF4_DATBLO)+"#"
							lAchou := .T.
						endIf
						BF4->(dbSkip())
					endDo
				endIf
			else
				ADEL(aValores, nI)
				ASIZE(aValores, (len(aValores)-1))
				nI-- //nI-- porque estou diminuindo o array
				cVldEspe += aRet[2]+"~"+cMatricula+"~"+cNome+"~"+cCodOpc+"~"+cDesOpc+"#"
			endIf
			nI++
		endDo


		if lVldOpcTit .and. len(aValores) > 0


			//faço o while novamente para pegar somente os opcionais que ainda nao existem na BF4
			//entao se o titular estiver nesse aValores é pq ainda nao possui o opcional na BF4
			//logo, ele deve estar aqui, senão, não pode incluir os dependentes
			nI := 1
			while nI <= len(aValores) .AND. len(aValores) > 0 // essa condição é pq eu diminuo o array no meio do while

				cValores   := Separa(aValores[nI], ";", .F.)
				cMatricula := alltrim(Separa(cValores[1], "$", .F.)[2])
				cCodOpc    := Separa(cValores[3], "$", .F.)[2]
				cVerOpc    := Separa(cValores[4], "$", .F.)[2]
				cDesOpc    := Separa(cValores[5], "$", .F.)[2]

				//garanto que vou validar o codigo do opcional apenas uma vez, pois posso ter varios dependentes com o mesmo codigo
				if !(aScan(aOpc, { |x| x == cCodOpc}) > 0 )
					//se não é a matricula do titular e não tem ele na solicitação com esse codigo de opcional e não existe na BF4 a matricula do titular
					if(cMatricula != cMatTit) .and. !(AScan( aValores, { |x| "Field_BenefsMat$"+cMatTit $ x .and. "Field_CodOpc$"+cCodOpc $ x} ) > 0)	;
							.and. !(cMatTit+"$"+cCodOpc $ ::ARROPC) .and. !PLSVLDOPCT(cMatTit, cCodOpc, 3)
						ADEL(aValores, nI)
						ASIZE(aValores, (len(aValores)-1))
						nI-- //nI-- porque estou diminuindo o array
						cOpcTit += cCodOpc+"~"+cVerOpc+"~"+cDesOpc+"#"
					endIf

					aAdd(aOpc, cCodOpc)

				endIf

				nI++
			endDo

		endIf

		if(len(aValores) <= 0)
			::WSNULL += "0" //coloco esse 0 quando não tem mais valores no array, para dar o split na webfunction
		else
			for nI := 1 to len(aValores)
				::WSNULL += aValores[nI] + iif(nI < len(aValores), "@", "")
			next nI
		endIf

		::WSNULL += "|" + iif(cRec <> "",left(cRec, len(cRec)-1) ,"0") + "|" + iif(cVldEspe <> "",left(cVldEspe, len(cVldEspe)-1) ,"0") + "|" + iif(cOpcTit <> "",left(cOpcTit, len(cOpcTit)-1) ,"0") // tirando o # do final
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetSolOpc ³Autor  ³ Karine Riquena Limp   ³ Data ³25.09.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Retorna o protocolo da solicitação                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetSolOpc WSRECEIVE UserCode, cRecno WSSEND DadSolOpc WSSERVICE PLSXFUN
	LOCAL aArea	  := GetArea()
	LOCAL lRetorno  := .T.
	LOCAL nRecno    := 0
	LOCAL cClasse   := ""
	LOCAL cCodInt   := PLSINTPAD()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "GetSolOpc" )

		BA0->(dbSetOrder(1))
		BA0->(msSeek(xFilial("BA0")+cCodInt))
		nRecno := Val(cRecno)
		BBA->(dbGoTo(nRecno))

		if(!empty(BBA->BBA_CLASSE))

			BY4->(dbSetOrder(1))
			if(BY4->(msSeek(xFilial("BY4")+BBA->BBA_CLASSE)))
				cClasse:= BY4->BY4_DESC
			endif

		endif

		::DadSolOpc := WsClassNew( "SDadSolOpc" )

		::DadSolOpc:RecnoSol           := ::cRecno
		::DadSolOpc:Prot               := BBA->BBA_NROPRO
		::DadSolOpc:DataSol            := BBA->BBA_DATSOL
		::DadSolOpc:HoraSol            := BBA->BBA_HORSOL
		::DadSolOpc:Classe             := cClasse
		::DadSolOpc:DadosOpe           := WsClassNew( "SDadOpe" )
		::DadSolOpc:DadosOpe:CodOpe    := cCodInt
		::DadSolOpc:DadosOpe:NomeOpe   := BA0->BA0_NOMINT
		::DadSolOpc:DadosOpe:Ender     := BA0->BA0_END
		::DadSolOpc:DadosOpe:NumEnd    := BA0->BA0_NUMEND
		::DadSolOpc:DadosOpe:Compl     := BA0->BA0_COMPEN
		::DadSolOpc:DadosOpe:Bairro    := BA0->BA0_BAIRRO
		::DadSolOpc:DadosOpe:Cidade    := BA0->BA0_CIDADE
		::DadSolOpc:DadosOpe:Estado    := BA0->BA0_EST
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AltSolOpc ³Autor  ³ Karine Riquena Limp   ³ Data ³28.09.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Altera o status da solicitação para 2-EM ANÁÇISE quando há            ³±±
±±³		envio de documento pela consulta                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD AltSolOpc WSRECEIVE UserCode, cRecno WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRet := .T.
	LOCAL lRetorno := .T.
	LOCAL aArea	  := GetArea()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "AltSolOpc" )
		lRet := PL09AltOpc(Val(::cRecno))
		if(lRet)
			::WSNULL := "true|"
		else
			::WSNULL := "false|"
		endif
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetUsrRec ³Autor  ³ Karine Riquena Limp   ³ Data ³07.10.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Retorna as receitas de medicamentos de uso continuo                   ³±±
±±³		cadastradas para o beneficiario                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetUsrRec WSRECEIVE UserCode, MatUsu, DtDoc WSSEND DadUsrRec WSSERVICE PLSXFUN
	local nI        := 1
	local lRetorno  := .T.
	local aArea	    := GetArea()
	local cValidRec := GetNewPar("MV_PLVALRE","0") //Valida o medicamento pela data da receita = 0 ou pela data do medicamento = 1

	if PrtChkUser( ::UserCode, "PLSXFUN", "GetUsrRec" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³retorna as receitas e medicamentos do beneficiario                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		B4F->(dbSetOrder(2))
		B7D->(dbSetOrder(3))
		BR8->(dbSetOrder(3))

		B4F->(MsSeek(xFilial("B4F")+ alltrim(::MatUsu)))

		while !B4F->(EOF()) .AND. alltrim(xFilial("B4F")+::MatUsu) == alltrim(B4F->(B4F_FILIAL+B4F_MATRIC))

			If B4F->B4F_STATUS $ '3,5'/*3= Deferido ; 5=Deferido parcialmente*/

				if B7D->(MsSeek(xFilial("B7D") + B4F->B4F_CODREC))

					while !B7D->(EOF()) .AND. alltrim(xFilial("B7D")+B4F->B4F_CODREC) == alltrim(B7D->(B7D_FILIAL+B7D_CODREC))


						if B7D->B7D_OK .AND. B7D->B7D_QTDAUT >= B7D->B7D_QTDEXE .AND.;
								iIf(cValidRec == "0", PLSINTVAL("B4F","B4F_DATINI","B4F_DATFIN",DtDoc), PLSINTVAL("B7D","B7D_DTVINI","B7D_DTFVAL",DtDoc))//SE O MEDICAMENTO ESTÁ APROVADO


							if BR8->(MsSeek(xFilial("BR8") + B7D->(B7D_CODMED+B7D_CODPAD)))
								AaDd( ::DadUsrRec, WsClassNew( "SDadRecUsr" ) )
								::DadUsrRec[nI]:CodRec := alltrim(B4F->B4F_CODREC)
								::DadUsrRec[nI]:NomRec := alltrim(B4F->B4F_DESCRI)
								::DadUsrRec[nI]:CodMed := alltrim(B7D->B7D_CODPAD) + "|" + alltrim(B7D->B7D_CODMED) + "|" + alltrim(B7D->B7D_SEQUEN)
								::DadUsrRec[nI]:NomMed := alltrim(BR8->BR8_DESCRI)
								::DadUsrRec[nI]:QtdAut := B7D->B7D_QTDAUT
								::DadUsrRec[nI]:QtdExe := B7D->B7D_QTDEXE
								nI++

							EndIF

						Endif

						B7D->(dbSkip())

					endDo
				endIf
			endIf

			B4F->(dbSkip())
		endDo

		BR8->(dbCloseArea())
		B7D->(dbCloseArea())
		B4F->(dbCloseArea())
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno


/*//-------------------------------------------------------------------
{Protheus.doc} GrvItReemb
Grava o item do reembolso
@author		Karine Riquena Limp 
@since    	14.10.2015
//-------------------------------------------------------------------*/
WSMETHOD GrvItReemb WSRECEIVE UserCode, CodSol, ItemReemb, cRecno, MatUsu, CabAlt, RecDivs, OriReemb WSSEND WSNULL WSSERVICE PLSXFUN

	local lRetorno	:= .T.
	local aArea		:= GetArea()
	local aResult	:= {}
	local lBOW		:= iif(::CodSol == "0", .T., .F.)
	local lB1N		:= iif(::cRecno == "0", .T., .F.)

	default ::WSNULL := ""
	default ::CabAlt := .F.
	default ::RecDivs := ""

	if PrtChkUser( ::UserCode, "PLSXFUN", "GrvItReemb" )
		aResult := PLSREEMBIT(lBOW, lB1N, ::CodSol, ::ItemReemb, ::cRecno, ::MatUsu, ::CabAlt, ::RecDivs, ::OriReemb) //retorna o protocolo da BOW e o recno da B1N

		If VALTYPE(aResult) == "A"

			::WSNULL := aResult[1] + "$" + FWJsonSerialize(aResult[2],.F.,.T.)
		Else
			::WSNULL := aResult
		EndIf
	else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf

	RestArea( aArea )
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PLSPSQVIDA³Autor  ³ Fábio S. dos Santos   ³ Data ³21.09.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Verifica se os beneficiarios inseridos na solicitação já possuem os   ³±±
±±³  opcionais solicitados na base de dados e em vigência                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PLSPSQVIDA WSRECEIVE UserCode, CpfCnpj WSSEND WSNULL WSSERVICE PLSXFUN
	Local lRetorno := .T.
	Local aArea	:= GetArea()
	Default ::WSNULL := ""
	If PrtChkUser( ::UserCode, "PLSXFUN", "PLSPSQVIDA" )
		::WSNULL := PLS013VCPF(::CpfCnpj)
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf
	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³IsMedBJE³Autor  ³ Oscar Zanin   ³ Data ³20.10.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Verifica se o Serviço foi marcado como Medicamento		               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD IsMedBJE WSRECEIVE UserCode, TipSer WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRet	:= .T.
	Local aArea	:= GetArea()
	Default ::WSNULL := ""

	If PrtChkUser( ::UserCode, "PLSXFUN", "IsMedBJE" )
		::WSNULL := PLSBJECHK(::TipSer)
	else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do método" )
	EndIF

	RestArea( aArea )

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o 	³ EditSolic ³Autor  ³ Rodrigo Morgon³      Data ³17/08/2015  	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³        ³ Retorna array com dados de uma solicitação                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD EditSolic WSRECEIVE UserCode, cRecno, lVisualizaProtoc, Chave WSSEND ItensReemb WSSERVICE PLSXFUN

	Local lRetorno 	:= .T.
	Local aArea	  	:= GetArea()
	Local cDtB1N		:= ""
	Local nI			:= 1
	Local cDescPro	:= ""
	Local cIsMed		:= ""
	Local aChave		:= {}
	Local cDataComp    	:= ""

	DEFAULT ::lVisualizaProtoc := .F.
	DEFAULT ::Chave := ""
	DEFAULT ::cRecno := ""

	//Private aDadosSoli 	:= {}

	if PrtChkUser( ::UserCode, "PLSXFUN", "EditSolic" )

		if(!empty(::cRecno))
			BOW->(DbGoTop())
			BOW->(DbGoTo(Val(::cRecno))) //Posiciona no registro selecionado para edição na tela de consulta.

			if BOW->(BOW_STATUS) == "A" .or. ::lVisualizaProtoc //Permite a edição se o status for "A" (Solicitação não concluída).
				// lVisualizaProtoc = para permitir que o app apresente o detalhe do reembolso pois não cabem todos em uma celula da lista de protocolos
				// mesmo retornando os dados para o app, a edição só será permitida se o status for A.

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Dados referentes ao cabeçalho                                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				::ItensReemb := WsClassNew( "SEstrReemb" )

				::ItensReemb:CodSol	:= BOW->BOW_PROTOC //Alimenta struct com o codigo da solicitação (protocolo de reembolso).

				//Para recuperar os dados do documento, posicionar no primeiro item do protocolo na B1N
				B1N->(DbSetOrder(1))
				B1N->(DbGoTop())
				B1N->(MsSeek(xFilial("B1N") + BOW->BOW_PROTOC ))

				::ItensReemb:TipDoc	:= AllTrim(B1N->B1N_TIPDOC)
				::ItensReemb:NumDoc 	:= AllTrim(B1N->B1N_NUMDOC)
				cDtB1N := DTOS(B1N->B1N_DATDOC)
				::ItensReemb:DtEmis 	:= SubStr(cDtB1N,7,2) + "/" + SubStr(cDtB1N,5,2) + "/" + SubStr(cDtB1N,1,4)

				::ItensReemb:CpfCnpj := B1N->B1N_PRCNPJ
				::ItensReemb:NomePre	:= B1N->B1N_PRNOME
				::ItensReemb:UF		:= B1N->B1N_EST
				::ItensReemb:Cidade	:= B1N->B1N_CODMUN
				::ItensReemb:status	:= BOW->BOW_STATUS // agora retorna o status do protocolo para controle de edição no app.

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Dados referentes aos itens da solicitação                               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				::ItensReemb:ListDesp := {}
				while( !B1N->( Eof() ) .AND. B1N->B1N_PROTOC == ::ItensReemb:CodSol)
					aadd(::ItensReemb:ListDesp, WsClassNew( "SItensReemb" ))

					cIsMed := Posicione("BJE", 1, xfilial("BJE") + Alltrim(B1N->B1N_TIPSER), "BJE_ISMEDI")
					::ItensReemb:ListDesp[nI]:CodPro     := AllTrim(B1N->B1N_CODPRO) + "|" + ALLTRIM( Posicione("BR8",1,xFilial("BR8")+B1N->B1N_CODPAD+B1N->B1N_CODPRO,"BR8_DESCRI") )
					::ItensReemb:ListDesp[nI]:VlrPro     := StrTran(StrTran(AllTrim(STRZero(B1N->B1N_VLRTOT,12,2)), ",", ""), ".", ",")
					::ItensReemb:ListDesp[nI]:ValorPago  := StrTran(StrTran(AllTrim(STRZero(B1N->B1N_VLRREE,12,2)), ",", ""), ".", ",")
					::ItensReemb:ListDesp[nI]:ValUnitari := StrTran(StrTran(AllTrim(STRZero(B1N->B1N_VLRAPR,12,2)), ",", ""), ".", ",")

					cDataComp := DTOS(B1N->B1N_DATDOC)
					::ItensReemb:ListDesp[nI]:DatComprov := SubStr(cDataComp,7,2) + "/" + SubStr(cDataComp,5,2) + "/" + SubStr(cDataComp,1,4)

					::ItensReemb:ListDesp[nI]:CodPad := AllTrim(B1N->B1N_CODPAD)
					::ItensReemb:ListDesp[nI]:UsoC   := AllTrim(B1N->B1N_USOCON)
					::ItensReemb:ListDesp[nI]:QtdPro := AllTrim(STR(B1N->B1N_QTDPRO))
					::ItensReemb:ListDesp[nI]:Matric := AllTrim(B1N->B1N_MATRIC)
					::ItensReemb:ListDesp[nI]:CodRec := AllTrim(B1N->B1N_CODREC)
					::ItensReemb:ListDesp[nI]:CodMed := AllTrim(B1N->B1N_CODMED)
					::ItensReemb:ListDesp[nI]:SeqMed := AllTrim(B1N->B1N_SEQMED)
					::ItensReemb:ListDesp[nI]:TipSer := AllTrim(B1N->B1N_TIPSER) + "|" + iif(empty(cIsMed), "0", cIsMed)
					::ItensReemb:ListDesp[nI]:RecNoItem := AllTrim(STR(B1N->(Recno())))
					::ItensReemb:ListDesp[nI]:StatusIte := B1N->B1N_IMGSTA
					B1N->(DbSkip())
					nI++
					cDescPro := ""
				endDo
			else
				//Status diferente de "A" - Solicitação não concluída
				lRetorno := .F.
				SetSoapFault( "", "O status atual da solicitação não permite o uso desta funcionalidade." )
			endif
		else

			aChave := Separa(::Chave, "-")

			BOW->(DbSetOrder(1))
			BOW->(MsSeek(xFilial("BOW") + alltrim(aChave[1]) ))
			if(BOW->BOW_STATUS == "A" .or. aChave[6] == "V")

				::ItensReemb := WsClassNew( "SEstrReemb" )
				::ItensReemb:CodSol	:= BOW->BOW_PROTOC //Alimenta struct com o codigo da solicitação (protocolo de reembolso).

				B1N->(DbSetOrder(2))
				if(B1N->(MsSeek(xFilial("B1N") + alltrim(aChave[1]) )))


					::ItensReemb:ListDesp := {}
					::ItensReemb:status	:= BOW->BOW_STATUS // agora retorna o status do protocolo para controle de edição no app.

					while( !B1N->( Eof() ) .AND. B1N->B1N_PROTOC == ::ItensReemb:CodSol)

						if STRTRAN(B1N->B1N_TIPDOC, " ", "") == aChave[2] .and. ALLTRIM(B1N->B1N_NUMDOC) == aChave[3];
								.and. B1N->B1N_DATDOC == STOD(aChave[4]);
								.and. ALLTRIM(B1N->B1N_PRCNPJ) == aChave[5]

							::ItensReemb:TipDoc	:= AllTrim(B1N->B1N_TIPDOC)
							::ItensReemb:NumDoc 	:= AllTrim(B1N->B1N_NUMDOC)
							cDtB1N := DTOS(B1N->B1N_DATDOC)
							::ItensReemb:DtEmis 	:= SubStr(cDtB1N,7,2) + "/" + SubStr(cDtB1N,5,2) + "/" + SubStr(cDtB1N,1,4)

							::ItensReemb:CpfCnpj := B1N->B1N_PRCNPJ
							::ItensReemb:NomePre	:= B1N->B1N_PRNOME
							::ItensReemb:UF		:= B1N->B1N_EST
							::ItensReemb:Cidade	:= B1N->B1N_CODMUN

							aadd(::ItensReemb:ListDesp, WsClassNew( "SItensReemb" ))
							//Recupera descrição do procedimento
							BR8->(DbSetOrder(3))//BR8_FILIAL + BR8_CODPSA
							If BR8->(MsSeek(xFilial("BR8") + B1N->(B1N_CODPRO)))
								While xFilial("BR8") + ALLTRIM(B1N->(B1N_CODPRO)) == xFilial("BR8") + ALLTRIM(BR8->(BR8_CODPSA)) .and. Empty(cDescPro)
									If BR8->(BR8_CLASSE) == B1N->(B1N_TIPSER)
										cDescPro	:= AllTrim(BR8->(BR8_DESCRI))
									EndIf
									BR8->(dbSkip())
								EndDo
							EndIf

							cIsMed := Posicione("BJE", 1, xfilial("BJE") + Alltrim(B1N->B1N_TIPSER), "BJE_ISMEDI")
							::ItensReemb:ListDesp[nI]:CodPro := AllTrim(B1N->B1N_CODPRO) + "|" + cDescPro
							::ItensReemb:ListDesp[nI]:VlrPro := StrTran(StrTran(AllTrim(STRZero(B1N->B1N_VLRTOT,12,2)), ",", ""), ".", ",")
							::ItensReemb:ListDesp[nI]:ValUnitari := StrTran(StrTran(AllTrim(STRZero(B1N->B1N_VLRAPR,12,2)), ",", ""), ".", ",")
							::ItensReemb:ListDesp[nI]:ValorPago  := StrTran(StrTran(AllTrim(STRZero(B1N->B1N_VLRREE,12,2)), ",", ""), ".", ",")
							::ItensReemb:ListDesp[nI]:CodPad := AllTrim(B1N->B1N_CODPAD)
							::ItensReemb:ListDesp[nI]:UsoC   := AllTrim(B1N->B1N_USOCON)
							::ItensReemb:ListDesp[nI]:QtdPro := AllTrim(STR(B1N->B1N_QTDPRO))
							::ItensReemb:ListDesp[nI]:Matric := AllTrim(B1N->B1N_MATRIC)
							::ItensReemb:ListDesp[nI]:CodRec := AllTrim(B1N->B1N_CODREC)
							::ItensReemb:ListDesp[nI]:CodMed := AllTrim(B1N->B1N_CODMED)
							::ItensReemb:ListDesp[nI]:SeqMed := AllTrim(B1N->B1N_SEQMED)
							::ItensReemb:ListDesp[nI]:TipSer := AllTrim(B1N->B1N_TIPSER) + "|" + iif(empty(cIsMed), "0", cIsMed)
							::ItensReemb:ListDesp[nI]:RecNoItem := AllTrim(STR(B1N->(Recno())))
							::ItensReemb:ListDesp[nI]:StatusIte := B1N->B1N_IMGSTA
							nI++
							cDescPro := ""

						endIf

						B1N->(DbSkip())

					endDo

				endIf
			else
				//Status diferente de "A" - Solicitação não concluída
				lRetorno := .F.
				SetSoapFault( "", "O status atual da solicitação não permite o uso desta funcionalidade." )
			endIf

		endIf
	else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf

	RestArea(aArea)
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o 	³ VldStatPro³Autor  ³ Rodrigo Morgon³ Data ³17/08/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³        ³Valida status do protocolo e retorna array com dados do mesmo. ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VldPrtReem WSRECEIVE UserCode, cRecno WSSEND ItensReemb WSSERVICE PLSXFUN

	Local lRetorno 	:= .T.
	Local aArea	  	:= GetArea()
	Local lInsBK6		:= SupergetMV("MV_VRDANRF", .F., .F.)

	default ::WSNULL := ""

	if PrtChkUser( ::UserCode, "PLSXFUN", "VldPrtReem" )

		BOW->(DbGoTop())
		BOW->(DbGoTo(Val(::cRecno))) //Posiciona no registro selecionado para edição na tela de consulta.

		if BOW->(BOW_STATUS) == "A" //Permite a edição se o status for "A" (Solicitação não concluída).
			::ItensReemb := WsClassNew( "SEstrReemb" )

			//Para recuperar os dados do documento, posicionar no primeiro item do protocolo na B1N
			B1N->(DbSetOrder(1))
			B1N->(DbGoTop())
			B1N->(MsSeek(xFilial("B1N") + BOW->BOW_PROTOC ))

			::ItensReemb:TipDoc	:= B1N->B1N_TIPDOC
			::ItensReemb:NumDoc 	:= B1N->B1N_NUMDOC
			::ItensReemb:DtEmis 	:= B1N->B1N_DATDOC

			//Recupera dados da BK6 - Rede não referenciada
			//Caso o parâmetro MV_VRDANRF esteja definido como .T., o ambiente utiliza a validação da BK6 antes da inclusão.
			//Nesse caso, os dados estão disponíveis nos campos B1N_PRCNPJ e B1N_PRNOME da tabela B1N.
			If lInsBK6
				::ItensReemb:CpfCnpj := B1N->B1N_PRCNPJ
				::ItensReemb:NomePre	:= B1N->B1N_PRNOME
			Else
				BK6->(DbSetOrder(3))
				BK6->(DbGoTop())
				BK6->(MsSeek(xFilial("BK6") + B1N->B1N_CODREF))

				::ItensReemb:CpfCnpj := BK6->BK6_CGC
				::ItensReemb:NomePre	:= BK6->BK6_NOME
			EndIf
		else
			//Status diferente de "A" - Solicitação não concluída
			lRetorno := .F.
			SetSoapFault( "", "O status atual da solicitação não permite o uso desta funcionalidade." )
		endif
	else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

//
//
//
WSMETHOD AltStatRee WSRECEIVE UserCode, cRecno, cOpcao WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno 	:= .T.
	Local nRecno 		:= IIF( ValType(::cRecno) == "C", Val(::cRecno), 0)
	Default WSNULL 	:= ""

	If PrtChkUser( ::UserCode, "PLSXFUN", "AltStatRee" )

		if nRecno > 0
			::WSNULL := "false|"
		else
			::WSNULL := "false|"
		EndIf

	else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do método" )
		::WSNULL := "false|"
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RDAPro 	³Autor  ³ Roberto Vanderlei     ³ Data ³13.10.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna profisisonal BB0						  		   	   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RDAPro WSRECEIVE UserCode, Crm, Estado, CodSig WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea    		:= GetArea()
	LOCAL cCodInt 		:= PlsIntPad()

	DEFAULT ::WSNULL 	:= "true|"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "RDAPro" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se prestador esta cadastrado na rede não referenciada		    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		BB0->( DbSetOrder(4) )//BB0_FILIAL+BB0_ESTADO+BB0_NUMCR+BB0_CODSIG+BB0_CODOPE

		If BB0->( MsSeek( xFilial("BB0") + alltrim(::Estado) + ::Crm + Space(TamSx3("BB0_NUMCR")[1] - Len(::Crm)) + alltrim(::CodSig)/*"CRM"*/ + Space(TamSx3("BB0_CODSIG")[1] - Len(CodSig)) + cCodInt ))
			::WSNULL := "true|1|" + BB0->(BB0_CODIGO+"|"+Alltrim(BB0_NOME))
		else
			::WSNULL := "true|0|"
		endif

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GrvRec  ³Autor  ³ Roberto Vanderlei 	     ³ Data ³16.10.15   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Grava Receita.		   									 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD GrvRec WSRECEIVE UserCode, Protoc, Benef, Crm, Estado, Medico, DtReceita, Medicamento, CodSig, FornecDir WSSEND RetProtocolo WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL lRetorno := .T.

	If PrtChkUser( ::UserCode , "PLSXFUN","GrvRec" )

		B7D->(DbSetOrder(3))
		If !B7D->(MsSeek(xFilial("B7D") + ::Protoc + ::Medicamento))

			::RetProtocolo := PlsGrvRec(::Protoc, ::Benef, ::Crm, ::Estado, ::Medico, ::DtReceita,::Medicamento, ::CodSig, ::FornecDir)
		Else
			::RetProtocolo := "false|Este medicamento já foi selecionado"
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim do metodo														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PlsGrvRec  ³Autor  ³ Roberto Vanderlei    ³ Data ³16.10.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Grava os Dados da Receita B7D - B4F..            			   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function PlsGrvRec(cProtoc, cBenef, cCrm, cUf, cMedico, cDtReceita, cMedicamento, cCodSig, cFornecDir)

	local cProtocItem := ""
	local nRecB4F	  := ""
	local aIndice     := {}

	default cProtoc := "000000"

	BA1->(dbSetOrder(5))//BA1_FILIAL + BA1_MATANT + BA1_TIPANT
	If BA1->(DbSeek(xFilial("BA1")+cBenef))
		cBenef := BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)
	EndIf

	if cProtoc == "000000"

		Begin Transaction

			If TamSX3("B4F_CODREC")[1] > 6 .AND. TamSX3("B7D_CODREC")[1] > 6
				cProtoc	:= P773GERPRO()
			Else
				cProtoc	:= GetSXENum("B4F", "B4F_CODREC")
				B4F->(ConfirmSX8())
			EndIf

			B4F->(RecLock("B4F", .T.))
			B4F->B4F_FILIAL := xFilial("B4F")
			B4F->B4F_CODREC := cProtoc
			B4F->B4F_DESCRI	:= "Receita Nº " + cProtoc + "."
			B4F->B4F_MATRIC := cBenef
			B4F->B4F_CODFAM := SubStr(cBenef, 1, 14)
			B4F->B4F_DTCAD  := Date()
			B4F->B4F_SIGLA	:= cCodSig//"CRM"
			B4F->B4F_ESTSOL := cUf
			B4F->B4F_REGSOL := cCrm
			B4F->B4F_PORTAL := .T.
			B4F->B4F_STATUS := "A"
			B4F->B4F_DATINI := ctod(cDtReceita)
			B4F->B4F_DATFIN := ctod(cDtReceita) + val(GetNewPar("MV_PLSVLDR", "30"))
			B4F->(MsUnlock())

			PlSveProfAll(cMedico, cCodSig, cUf, cCrm, PLSINTPAD(), '', '2', '', {})

		End Transaction
	endif

	//Gravação dos itens da receita.
	nRecB4F := B4F->(Recno())

	If FindFunction("PLGERSEQE")

		aadd(aIndice,{"B7D_FILIAL",xFilial("B7D")})
		aadd(aIndice,{"B7D_CODREC",cProtoc})

		cProtocItem := PLGERSEQE("B7D", "B7D_SEQUEN", aIndice)

	Else
		cProtocItem := GetSXENum("B7D", "B7D_SEQUEN")
	EndIf

	B7D->(RecLock("B7D", .T.))
	B7D->B7D_FILIAL := xFilial("B7D")
	B7D->B7D_CODREC := cProtoc
	B7D->B7D_SEQUEN := cProtocItem
	B7D->B7D_CODMED	:= cMedicamento
	B7D->B7D_BENEFI := cBenef
	B7D->B7D_QTDAUT := 0
	B7D->B7D_QTDEXE := 0
	B7D->B7D_DTVINI := ctod(cDtReceita)
	B7D->B7D_DTFVAL := ctod(cDtReceita) + val(GetNewPar("MV_PLSVLDR", "30"))
	B7D->B7D_CODPAD := PlsBusCla(cMedicamento)
	if B7D->(fieldPos("B7D_FORDIR")) > 0
		B7D->B7D_FORDIR := cFornecDir
	endif
	B7D->(MsUnlock())

	//	Ponto de Entrada na Inclusão do Medicamento
	If ExistBlock("PLGRRCFIM")
		ExecBlock("PLGRRCFIM", .f., .f., {cProtoc})
	Endif

Return(cProtoc + "|" + str(nRecB4F))

//************************************************
Static Function PlsBusCla(cMedicamento)
	local cClasse  := ""
	local cSQL

	cSQL := "SELECT BR8_CODPAD "
	cSQL += "FROM " + RetSQLName("BR8")
	cSQL += " INNER JOIN " + RetSQLName("BJE")
	cSQL += " ON BJE_CODIGO = BR8_CLASSE"
	cSQL += " WHERE BR8_CODPSA = '" + AllTrim(cMedicamento) + Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cMedicamento) ) ) + "'"
	cSQL += " AND " + RetSQLName("BR8")+".D_E_L_E_T_ = '' AND " + RetSQLName("BJE")+".D_E_L_E_T_ = ''"

	OPEN QUERY cSQL ALIAS "TrbRetPad"

	If !TrbRetPad->(EOF())

		While !TrbRetPad->(EOF())
			cClasse := TrbRetPad->BR8_CODPAD
			TrbRetPad->(dbSkip())
		EndDo
	Endif

	CLOSE QUERY "TrbRetPad"

return(cClasse)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetMsgPortal ³Autor  ³  Karine Riquena   ³ Data ³14.08.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verificar primeiro acesso, caso sim, solicitar atualização.  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetMsgPortal WSRECEIVE UserCode,TpPor,Rotina,CodMsg, Idioma WSSEND WSNULL WSSERVICE PLSXFUN
	Local lRet 		     := .T.
	Local aMensagensPortal := {}
	Local oMsgs := nil
	Local nCont := 0
	DEFAULT ::WSNULL := ""
	DEFAULT ::TpPor  := 0
	DEFAULT ::Rotina := ""
	DEFAULT ::Idioma := "POR"
	DEFAULT ::CodMsg := ""
	If PrtChkUser( ::UserCode, "PLSXFUN", "GetMsgPortal" )
		aMensagensPortal := PLSRETMSG(alltrim(STR(::TpPor)), ::CodMsg , ::Idioma, ::Rotina)
		oMsgs := WsClassNew( "SAMsgsPortal" )
		oMsgs:Mensagens  := {}
		for nCont := 1 to len(aMensagensPortal)

			AaDd( oMsgs:Mensagens, WsClassNew( "SMsgPortal" ) )
			oMsgs:Mensagens[nCont]:CodMsg	  := aMensagensPortal[nCont][1]
			oMsgs:Mensagens[nCont]:Mensagem := aMensagensPortal[nCont][2]

		next nCont

		::WSNULL := FWJsonSerialize(oMsgs,.F.,.T.)
	Else


		lRet := .F.
		SetSoapFault( "", "Usuário não encontrado.")
	EndIf

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ExclResu  ³Autor  ³ Roberto Vanderlei 	 ³ Data ³16.10.15   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Excluir Resumo		   								   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD ExclResu WSRECEIVE UserCode, Chave WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 		:= GetArea()
	LOCAL lRetorno 		:= .T.
	Local aResultado	:= {}
	Local aNumGui		:= {}
	Local cCodOpe		:= ''
	Local cCodLdp		:= ''
	Local cCodPeg		:= ''
	Local cNumero		:= ''
	Local cOriMov 		:= "5"
	Local cCodPad_Orig	:= ''
	Local cCodPad		:= ''
	Local cCodPro		:= ''

	PRIVATE aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))

	If PrtChkUser( ::UserCode , "PLSXFUN","ExclRect" )

		aResultado := StrTokArr(::Chave, "$")

		cCodPad_Orig := aResultado[2]
		cCodPro	:= aResultado[3]

		cCodPad := AllTrim(PLSVARVINC('87','BR4', cCodPad_Orig))
		cCodPro := AllTrim(PLSVARVINC(cCodPad_Orig,'BR8',cCodPro ,cCodPad+cCodPro,,aTabDup,@CCODPAD))

		cCodPro := cCodPro + Space(16 - len(cCodPro))

		aResultado[1] := aResultado[1] + ";;"

		aNumGui := StrTokArr(aResultado[1], ";")

		cCodOpe := aNumGui[1]
		cCodLdp := aNumGui[2]
		cCodPeg := aNumGui[3]
		cNumero := aNumGui[4]

		BD6->(DbSetorder(6))
		If BD6->(msSeek(xFilial("BD6")+cCodOpe+cCodLdp+cCodPeg+cNumero+cOriMov+cCodPad+cCodPro))

			BD6->(RecLock( "BD6" , .F. ))
			BD6->(DBDelete())
			BD6->(MsUnLock())

		endif

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ExclRect  ³Autor  ³ Roberto Vanderlei 	 ³ Data ³16.10.15   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Excluir Item receita		   								   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD ExclRect WSRECEIVE UserCode, Protoc, Medicamento WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL lRetorno 	:= .T.

	If PrtChkUser( ::UserCode , "PLSXFUN","ExclRect" )

		B7D->(DbSetOrder(3)) //B7D_FILIAL + B7D_CODREC + B7D_CODMED
		If B7D->( MsSeek( xFilial("B7D")+AllTrim(::Protoc) + Space(TamSX3("B7D_CODREC")[1]-Len( AllTrim(::Protoc))) + AllTrim(::Medicamento) + Space(TamSX3("B7D_CODMED")[1]-Len( AllTrim(::Medicamento)))) ) = .T.

			B7D->(RecLock('B7D',.F.))
			B7D->(DbDelete())
			B7D->(MsUnlock())

		endif

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AltRect  ³Autor  ³ Roberto Vanderlei 	 ³ Data ³16.10.15   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Alterar Status Item receita		   						³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD AltRect WSRECEIVE UserCode, Protoc, Benef WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL lRetorno 	:= .T.

	If PrtChkUser( ::UserCode , "PLSXFUN","AltRect" )
		BA1->(dbSetOrder(5))//BA1_FILIAL + BA1_MATANT + BA1_TIPANT
		B4F->(DbSetOrder(1)) //B7D_FILIAL + B7D_CODREC + B7D_CODMED
		If BA1->(DbSeek(xFilial("BA1")+::Benef))
			::Benef := BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)
		EndIf
		If B4F->( MsSeek( xFilial("B4F")+AllTrim(::Protoc) + Space(TamSX3("B4F_CODREC")[1]-Len( AllTrim(::Protoc))) + AllTrim(::Benef) + Space(TamSX3("B4F_MATRIC")[1]-Len( AllTrim(::Benef)))) ) = .T.

			B4F->(RecLock('B4F',.F.))
			B4F->B4F_STATUS := "1"
			B4F->(MsUnlock())
		endif

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VerPro  ³Autor  ³ Roberto Vanderlei 	 ³ Data ³16.10.15   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³xxxx	   						³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VerPro WSRECEIVE UserCode, CpfCnpj WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL lRetorno  := .T.

	If PrtChkUser( ::UserCode , "PLSXFUN","VerPro" )

		BBA->(DbSetOrder(2)) //B7D_FILIAL + B7D_CODREC + B7D_CODMED

		If BBA->( MsSeek( xFilial("BBA")+AllTrim(::CpfCnpj) + Space(TamSX3("BBA_CPFTIT")[1]-Len( AllTrim(::CpfCnpj))))) = .T.

			if BBA->BBA_TIPSOL == "2" .and. BBA->BBA_TIPMAN == "2" .and. BBA->BBA_STATUS $ "1,2"
				::WSNULL := "S"
			else
				::WSNULL := "N"
			endif
		else
			::WSNULL := "N"
		endif

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DadTipGui    ³Autor  ³ Thiago Guilherme  ³ Data ³30.11.2015  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³³Retorna os tipos de guia para impressão em branco                      ³±±
±±³																		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DadTipGui WSRECEIVE UserCode WSSEND DadosTipGui WSSERVICE PLSXFUN
	LOCAL nI       := 1
	LOCAL aArea	   := GetArea()
	LOCAL lRetorno := .T.
	LOCAL cTissVer := PLSTISSVER()
	Local aSX5		:= {}
	Local nJ 		:= 1

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "DadTipGui" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³retorna os tipos de guia para impressão em branco					 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aSX5 := FWGetSX5("PU")
		For nJ := 1 To Len(aSX5)

			If cTissVer >= "3"
				AaDd( ::DadosTipGui, WsClassNew( "STipGui" ))
				::DadosTipGui[nI]:Cod    := aSX5[nJ][3]
				::DadosTipGui[nI]:Descri := aSX5[nJ][4]
				nI++
			Else
				If !ALLTRIM(aSX5[nJ][3]) $ "3,4,5,6,7"
					AaDd( ::DadosTipGui, WsClassNew( "STipGui" ))
					::DadosTipGui[nI]:Cod    := aSX5[nJ][3]
					::DadosTipGui[nI]:Descri := aSX5[nJ][4]
					nI++
				EndIf
			EndIf
		Next nJ
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AltStBen  ³Autor  ³ Roberto Vanderlei 	 ³ Data ³08.12.15   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Alterar Status Solicitação Alteração Beneficiário  		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD AltStBen WSRECEIVE UserCode, Chave, Modo WSSEND WSNULL WSSERVICE PLSXFUN

	LOCAL aArea 	:= GetArea()
	LOCAL lRetorno := .T.

	::WSNULL := ""

	If PrtChkUser( ::UserCode , "PLSXFUN","AltStBen" )

		BBA->(DbSetOrder(1)) //B7D_FILIAL + B7D_CODREC + B7D_CODMED

		if alltrim(::Modo) = "1"
			If BBA->( MsSeek( xFilial("BBA")+AllTrim(::Chave) + Space(TamSX3("BBA_CODSEQ")[1]-Len( AllTrim(::Chave))))) = .T.
				BBA->(RecLock('BBA',.F.))
				BBA->BBA_STATUS := "2"
				BBA->(MsUnlock())
			endif
		else
			BBA->(DbGoTo(val(alltrim(::Chave))))
			BBA->(Reclock("BBA",.F.))
			BBA->BBA_STATUS := "2"
			BBA->(MsUnlock())
		endif
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim do metodo														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PlsTWPGQ 	³Autor  ³ Renan Martins         ³ Data ³06.03.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³INCLUI REGISTROS DE SOLICITAÇÃO DA TABELA DE PREÇOS PELO PRES-±±
±±³          ³TADOR NO PROTAL						  							  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PLSTWPGQ WSRECEIVE UserCode, cCodTb, cCodRDA, cCodLoc, cCodEsp, UsuEmai, PLSCodUsr, Tipo  WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRet 	 	:= .T.
	Local aArea		:= GetArea()
	DEFAULT ::WSNULL 	:= "true|"

	If PrtChkUser( ::UserCode, "PLSXFUN", "PLSTWPGQ" ) //Checa autorização
		::WSNULL := PLSINB96(::cCodTb, ::cCodRDA, ::cCodLoc, ::cCodEsp, ::UsuEmai, ::PLSCodUsr, ::Tipo)
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea(aArea)
Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PLSRELTB 	³Autor  ³ Renan Martins         ³ Data ³06.03.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna select para Solicitações da tabela B96  		          ±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PLSRELYB WSRECEIVE UserCode, cCodRDA, PLSCodUsr WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRet 	 	:= .T.
	Local aArea		:= GetArea()

	If PrtChkUser(::UserCode, "PLSXFUN", "PLSRELYB" )
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea(aArea)
Return lRet
//-------------------------------------------------------------------
/*/{Protheus.doc} GetDocCorpoCli
Retorna array com documentos cadastrados para o corpo clínico da RDA.

@author Rodrigo Morgon
@since 28/10/2015
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD GetDocCorpoCli WSRECEIVE UserCode WSSEND Documentos WSSERVICE PLSXFUN

	Local lRetorno	:= .T.
	Local cCodMot		:= GetNewPar("MV_MOTCORP","")
	Local nI			:= 1
	Default ::WSNULL	:= ""

	If PrtChkUser( ::UserCode, "PLSXFUN", "GetDocCorpoCli" )

		if !Empty(cCodMot)
			::Documentos := {}

			cCodMot := AllTrim(cCodMot)

			B9X->(DbSetOrder(3)) //B9X_FILIAL+B9X_CODINT+B9X_CODMOT+B9X_SEQMOT
			If(B9X->(MsSeek(xFilial("B9X") + PlsIntPad() + cCodMot)))
				While !B9X->(Eof()) .and. B9X->B9X_CODMOT == cCodMot
					aadd(::Documentos, WsClassNew("SDocs")) //Add novo item na lista de documentos

					::Documentos[nI]:DocSeq		:= AllTrim(B9X->B9X_SEQMOT)
					::Documentos[nI]:DocDesc		:= AllTrim(B9X->B9X_DOCMOT)
					::Documentos[nI]:DocObrig	:= AllTrim(B9X->B9X_OBRIG)

					B9X->(dbSkip())
					nI++
				EndDo
			EndIf

			::WSNULL := IIF(len(::Documentos) > 0, "true|", "false|")
		else
			::WSNULL := "false|"
		EndIf
	else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do método" )
		::WSNULL := "false|"
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETBLOQ ³Autor  ³ Oscar Zanin         ³ Data ³04.12.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Carrega combo de locais de Motivos			 	               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETBLOQ WSRECEIVE UserCode WSSEND DadBloq WSSERVICE PLSXFUN

	Local nI		:= 1
	Local lRetorno	:= .T.

	If PrtChkUser( ::UserCode ,"PLSXFUN","DADRETBLOQ" )

		B9G->(DbSetOrder(3))
		B9G->(MsSeek(xFilial("B9G")+"2"))
		while (!(B9G->(EoF())) .AND. (B9G->(B9G_TIPMOT) == "2") )
			Aadd(::DadBloq, WsClassNew ( "sDadBloq" ) )
			::DadBloq[nI]:CodBlo := B9G->(B9G_COD) + "~" + B9G->(B9G_MOTBG3)
			::DadBloq[nI]:Descri := B9G->(B9G_MOTIVO)
			nI++
			B9G->(DbSkip())
		EndDo
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RETDOC   ³Autor  ³ Oscar Zanin         ³ Data ³04.12.2015    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Alerta com os documentos. Vai ser no onchange do combo       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RETDOC WSRECEIVE UserCode, CodMot WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno	:= .T.
	Default ::WSNULL := ""

	If PrtChkUser( ::UserCode, "PLSXFUN", "RETDOC" )

		::WSNULL := P977BDOC(::CodMot)

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PREEXCBEN  ³Autor  ³ Oscar Zanin         ³ Data ³04.12.2015  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Pré-gravação da exclusão do beneficiário                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PREEXCBEN WSRECEIVE UserCode, Tp, UsrCod, cRecno, CodMot, VsPlan, CdPlan WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno   := .T.
	Local aRetPLEXIS := {}
	Default ::WSNULL := ""

	If PrtChkUser( ::UserCode, "PLSXFUN", "PREEXCBEN" )

		If FindFunction("PLEXISSOLI")

			aRetPLEXIS := PLEXISSOLI(VAL(::cRecno))

			If aRetPLEXIS[1] //se retornar true na posição 1 significa que existe uma solicitação em análise

				//Caso não retorne o número da solicitação
				If EMPTY(aRetPLEXIS[2])
					::WSNULL := "true~Existe uma solicitação de exclusão em análise, aguarde sua finalização"
				Else
					::WSNULL := "true~Existe uma solicitação de exclusão com o código " + aRetPLEXIS[2] + " em análise, aguarde sua finalização"
				EndIf
			Else
				::WSNULL := PLXPR997AB(::UsrCod, ::Tp, ::cRecno, ::CodMot, ::VsPlan, ::CdPlan)
			EndIf
		Else
			::WSNULL := PLXPR997AB(::UsrCod, ::Tp, ::cRecno, ::CodMot, ::VsPlan, ::CdPlan)
		EndIf
	else

		lRetorno := .F.
		SetSoapFault("", "Não autorizado a utilização do método")
	EndIF

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³POSEXCBEN  ³Autor  ³ Oscar Zanin         ³ Data ³04.12.2015  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ ³Pós-gravação da exclusão do beneficiário (conclusão da solicitação)   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD POSEXCBEN WSRECEIVE UserCode, cRecno, CodMot, DtExclu WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno := .T.
	Local nRecno := Val(::cRecno)
	Local cMsgBloqueio := ""
	Local lCheckBloqTitular := FindFunction("PLCheckBloqTit") .And. BG3->(FieldPos("BG3_BLQFAM")) > 0 .And. B2N->(FieldPos("B2N_TIPBLO")) > 0

	Default ::WSNULL := ""

	If PrtChkUser( ::UserCode, "PLSXFUN", "POSEXCBEN" )

		If FindFunction("PLBENEFBLO") .AND. PLBENEFBLO(nRecno, ::DtExclu)
			::WSNULL := "true|O beneficiário possui um bloqueio na data digitada, digite uma nova data"
		Else
			::WSNULL := "false|" + PLS977ABPS(nRecno, ::CodMot, ::DtExclu)

			If lCheckBloqTitular
				cMsgBloqueio := PLCheckBloqTit(::CodMot,"","",nRecno,.T.)
				If !Empty(cMsgBloqueio)
					::WSNULL += "|true|" + cMsgBloqueio
				Else
					::WSNULL += "|false"
				EndIf
			Else
				::WSNULL += "|false"
			EndIf
		EndIf
	else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do método")
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PLSRELTB 	³Autor  ³ Renan Martins         ³ Data ³10/2014 ³   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna select para Solicitações da tabela B96  		          ±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PLSVERINCDIG WSRECEIVE UserCode, PLSCodUsr WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRet 	 	:= .T.
	Local aArea		:= GetArea()

	If PrtChkUser(::UserCode, "PLSXFUN", "PLSVERINCDIG" )
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea(aArea)
Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getDiaRetro ³Autor  ³       ³ Data ³25.11.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Pegar Permissão Digitação de Guia Retroativa e os dias       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GETDIARETRO WSRECEIVE UserCode, RDACode, CodLoc, cUsr, DatGuia WSSEND WSNULL WSSERVICE PLSXFUN
	Local lRet 	:= .T.
	Local aArea 	:= GetArea()

	DEFAULT ::WSNULL := ""

	If PrtChkUser( ::UserCode, "PLSXFUN","getDiaRetro" )
		::WSNULL := PLSDIARET(PLSINTPAD(),::RDACode,::CodLoc,::cUsr, ::DatGuia)
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRet


//---------------------------------------------------------------------------------------
/*/{Protheus.doc} 	getArqRel
metodo da listagem de arquivos nos relatorios de pagamento PPLRELMOV

@author	Rogério Tabosa
@since		01/2016
@version	P11
/*/

WSMETHOD getArqRel WSRECEIVE userCode, RDACode WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL aArea 	:= getArea()
	LOCAL lRetorno	:= .t.
	LOCAL cMsg		:= ""
	LOCAL nQtdReg 	:= 0
	LOCAL nPaginaAtu:= 0
	LOCAL nRegPagina:= 20
	LOCAL xHeader 	:= "[{name:'Arquivo'},{name:'Tipo'},{name:'Data Geração'},{name:'Download'}]"
	LOCAL xCols		:= "[]"
	LOCAL nI		:= 0
	LOCAL aFiles	:= {}
	LOCAL cPathSrv 	:= lower(getMV("MV_RELT"))
	LOCAL cTipoRel	:= ""
	LOCAL cQtdDiArq	:= SuperGetMv("MV_QTDIARQ",.F.,"0")
	LOCAL dDatCut	:= dDataBase - Val(cQtdDiArq)
	LOCAL lOk		:= .F.
	local lFrmCompac	:= getNewPar("MV_PLSRARZ",.T.)
	local cExtCompac	:= iif(lFrmCompac, '*.rar*', '*.zip*')

	DEFAULT ::WSNULL 	:= ""

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Se tem direito para executar o metodo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	if prtChkUser( ::UserCode ,"PLSXFUN","getArqRel" )
		//Busco os arquivos no diretorio
		aFiles := Directory(cPathSrv+cExtCompac)
		aFiles := aSort(aFiles,,, { |x, y| x[3] > y[3] })

		If Len(aFiles) > 0
			xCols := "["
			for nI := 1 to len(aFiles)

				If !("_" + RDACode $ aFiles[nI,1]) .OR. aFiles[nI,3] < dDatCut//Somente arquivos da RDA selecionada e data determinada no parametro
				Loop
			EndIf

			If "RELDAC" $ aFiles[nI,1]
				cTipoRel := "Analise de Contas"
			ElseIf "RELDPM" $ aFiles[nI,1]
				cTipoRel := "Demonstrativo Pagamento"
			ElseIf "RELDPO" $ aFiles[nI,1]
				cTipoRel := "Pagamento Odonto"
			ElseIf "RELEPM" $ aFiles[nI,1]
				cTipoRel := "Extrato de Pagamento"
			ElseIf "RELPLAN" $ aFiles[nI,1]
				cTipoRel := "Planilha de Produção"
			Else
				Loop //cTipoRel := "NI" // Não identificado
			Endif

			lOk := .T.
			xCols += ""
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Monta acols
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			xCols += "{	0:{field:'FileName', value:'" + aFiles[nI,1] + "'},"
			xCols += "  1:{field:'TipRel', value:'" + cTipoRel +  "'},"
			xCols += "  2:{field:'cData', value:'" + dToc(aFiles[nI,3]) +  "'},"
			xCols += "  3:{field:'Download', value:'0#" + '"' + aFiles[nI,1] + '"' +  "'},"
			xCols += "	4:{field: 'IDENLINHA', value:'" + aFiles[nI,1] + "'} } " + Iif( Len(aFiles) != nI ,",","" )

			nQtdReg ++
			next
			xCols += "]"
		Else
			cMsg 		:= "Não existe registro para esta consulta!"
			::WSNULL 	:= "false|Não existe registro para esta consulta!"
		EndIf
		If !lOk
			cMsg 		:= "Não existe registro para esta consulta!"
			::WSNULL 	:= "false|Não existe registro para esta consulta!" // Retorno
		Else
			// Retorno
			::WSNULL := "true|true|" + cValToChar(nQtdReg) + "|1|" + cValToChar(nRegPagina) + "|" + xHeader + "|" +	xCols + "|" + cMsg + "|true|" + cValToChar(nPaginaAtu) + "||false|"
		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )
Return lRetorno

/*/{Protheus.doc} 	BloqReem
metodo que verifica se o usuário está bloqueado, e se a data informada é superior a data de bloqueio

@author	Lucas Nonato
@since		03/2016
@version	P12
/*/

WSMETHOD BloqReem WSRECEIVE UserCode, ItemReemb, DocObrig WSSEND WSNULL WSSERVICE PLSXFUN
	local lRetorno := .T.
	local aRetorno := nil
	local cProc	  := ""
	local aArea	  := GetArea()
	local cNumProt  := ""
	default ::WSNULL := ""

	if PrtChkUser( ::UserCode, "PLSXFUN", "BloqReem" )
		aRetorno := PLCHKDUPRE(::ItemReemb, ::DocObrig)
		If !aRetorno[1]
			cNumProt := aRetorno[2]
			cProc	  := aRetorno[3]
			::WSNULL := "false|A despesa " + cProc + " já foi solicitada no protocolo " + cNumProt
		ElseIf !PLBLOQREEM(::ItemReemb:Matric, ::ItemReemb:DATDOC)
			::WSNULL := "false|Usuário bloqueado na data " + cValToChar(::ItemReemb:DATDOC)
		Elseif existblock("PLVLDITREE")
			aRetorno	:=  execBlock("PLVLDITREE",.F.,.F.,{ ::ItemReemb })
			if !aRetorno[1]
				::WSNULL := "false|" + aRetorno[2]
			endIf
		endIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf
	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³UsoConsDel ³Autor  ³ Karine Riquena Limp   ³ Data ³05.04.2016 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Exclui uma solicitação não concluida  de uso constante        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD UsoConsDel WSRECEIVE UserCode, cRecno, Alias WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea    		:= GetArea()

	If PrtChkUser( "MSALPHA", "PLSXFUN", "UsoConsDel" )

		PLSDELUSOC(::Alias, val(::cRecno))

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
//-------------------------------------------------------------------
/*/{Protheus.doc} VLDBA1MATEMP
Valida se o número informado na digitação de guias off-line refere-se à matrícula do beneficiário na empresa.
Caso positivo, retorna os dados da carteirinha do mesmo.
Caso negativo, permanece com o número informado e procede para as validações da carteirinha.

@author Rodrigo Morgon
@since 05/05/2016
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD VLDBA1MATEMP WSRECEIVE UserCode, UserCardNumber WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno	:= .T.
	Default WSNULL	:= ""

	If PrtChkUser( ::UserCode, "PLSXFUN", "VLDBA1MATEMP" )
		BA1->(DbSetOrder(6)) //BA1_FILIAL+BA1_MATEMP

		If (BA1->(MsSeek(xFilial("BA1")+::UserCardNumber))) .and. (AllTrim(BA1->BA1_MATEMP) == AllTrim(::UserCardNumber))
			::WSNULL := BA1->BA1_CODINT + BA1->BA1_CODEMP + BA1->BA1_MATRIC + BA1->BA1_TIPREG + BA1->BA1_DIGITO
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do método" )
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RETMEMOGEN³Autor  ³Karine Riquena Limp    ³ Data ³05.05.2016 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna o conteído memo de um campo posicionando pelo recno  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RETMEMOGEN WSRECEIVE UserCode, cRecno, Alias, Campos WSSEND DadObsProt WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea 		:= GetArea()
	LOCAL cObs := ""
	LOCAL nI := 1
	Local cAlias := ::Alias
	Local cCampo := ::Campos
	If PrtChkUser( ::UserCode, "PLSXFUN", "RETOBSGEN" )

		&(cAlias)->(dbSetOrder(1))
		&(cAlias)->(dbGoto(val(::cRecno)))


		nLines := MLCount( &(cAlias+"->"+cCampo ) )

		For nI := 1 to nLines
			if !(empty(memoLine(&(cAlias+"->"+cCampo ),,nI)))
			cObs += alltrim(strTran(strTran(memoLine(&(cAlias+"->"+cCampo ),,nI), chr(10), ""), chr(13),""))
		endIf
		Next nI

		AaDd( ::DadObsProt, WsClassNew( "SRetObsProt" ) )
		::DadObsProt[1]:cMsg  := IIf(EMPTY(cObs), "false|0", "true|"+cObs)
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AltStatusB4F ³Autor  ³ Karine Riquena Limp   ³ Data ³05.04.2016 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Exclui uma solicitação não concluida  de uso constante        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD AltStatusB4F WSRECEIVE UserCode, cRecno, StProc WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aArea    		:= GetArea()

	If PrtChkUser( "MSALPHA", "PLSXFUN", "UsoConsDel" )

		begin transaction
			B4F->(dbSelectArea("B4F"))
			B4F->(dbgoto(val(::cRecno)))
			B4F->(Reclock("B4F", .F.))
			B4F->B4F_STATUS := ::StProc
			B4F->(msUnlock())
		end transaction
		::WSNULL := "true|"

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} AltStTissG
Altera o status da guia para em análise

@author Karine Riquena Limp
@since 20/07/2016
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD AltFlaInt WSRECEIVE UserCode, Chave, Alias, Pendente, Sequen WSSEND WSNULL WSSERVICE PLSXFUN
	local cAliasPai := iif(::Alias == "BE2", "BEA", iif(::Alias == "BEJ" .OR. ::Alias == "BQV", "BE4", "B4A"))
	local lRet := .T.
	local lIntRespo := .F.
	local cSetorAt  := GetNewPar("MV_SETORAT","00")
	local cTipoGuia := ''

	If cAliasPai = 'BEA'
		cTipoGuia := '1'

	ElseIf cAliasPai = 'BE4'
		cTipoGuia := '2'

	else
		cTipoGuia := '3'
	endif

	If PrtChkUser( ::UserCode , "PLSXFUN", "AltFlaInt" )

		Begin Transaction

			BBR->(dbSetOrder(1))
			BBR->(msSeek(xFilial("BBR") + ::Chave))
			while (BBR->(!Eof()) .AND. BBR->(BBR_FILIAL+BBR_CODOPE+BBR_ANOAUT+BBR_MESAUT+BBR_NUMAUT) == (xFilial("BBR") + ::Chave))

				If !BBR->BBR_RESPRE .AND. BBR->BBR_SEQPRO == ::Sequen

					BBR->(RecLock("BBR",.F.))
					BBR->BBR_ANEXAD := .T. //ALTERO A FLAG PARA ATUALIZAR TODAS A INTERAÇÕES DO PROCEDIMENTO
					BBR->BBR_TPDIRP := ""
					BBR->(MsUnLock())
				EndIf

				If BBR->BBR_RESPRE .AND. EMPTY(BBR->BBR_RESPOS) .AND. !lIntRespo
					lIntRespo := .T.
				Endif

				BBR->(dbSkip())
			endDo

			If lIntRespo
				::WSNULL := "true|Existem interações em aberto que necessitam de uma resposta descritiva.|PENDENDESCRI"
			Else
				::WSNULL := "true|Anexos confirmados!"

				if(!(::Pendente))
					if(cAliasPai == "BEA")
						BEA->(DbSetOrder(1))
						If BEA->(MsSeek(xFilial("BEA") + ::Chave))
							BEA->(RecLock("BEA",.F.))
							BEA->BEA_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
							BEA->(MsUnLock())
						EndIf
					elseif(cAliasPai == "BE4")
						BE4->(DbSetOrder(2))
						If BE4->(MsSeek(xFilial("BE4") + ::Chave))
							BE4->(RecLock("BE4",.F.))
							BE4->BE4_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
							BE4->(MsUnLock())
						EndIf
					elseif(cAliasPai == "B4A")
						B4A->(DbSetOrder(1))
						If B4A->(MsSeek(xFilial("B4A") + ::Chave))
							B4A->(RecLock("B4A",.F.))
							B4A->B4A_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
							B4A->(MsUnLock())
						EndIf
					endIf
					::WSNULL += "|STTISS"

					B53->(dbSetOrder(1))

					If B53->(MsSeek(xFilial('B53') + ::Chave + cTipoGuia))
						B53->(RecLock("B53",.F.))
						B53->B53_CODDEP := cSetorAt
						B53->(MsUnLock())

						IF B53->B53_ALIMOV=="B4Q"
							B4Q->(DbSetOrder(1))
							If B4Q->(MsSeek(xFilial("B4Q")+B53->(B53_NUMGUI)))
								B4Q->(RecLock("B4Q",.F.))
								B4Q->B4Q_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
								B4Q->(MsUnLock())
							EndIf

						Endif
						//Atualizar tabela de Encaminhamento - B71
						If !Empty(cSetorAt)

							PLSICB71(B53->B53_ALIMOV, B53->B53_RECMOV, cSetorAt, "Arquivo enviado com sucesso." )
						EndIf
					EndIf
				endIf
			EndIf

		End Transaction

	Else

		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )

	EndIf

return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} ATGUIAAAUT
Atualiza guia após autorização

@author Renan Martins
@since 06/2016
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD ATGUIAAAUT	 WSRECEIVE Chave, CmdChave WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL aDados   		:= {}

	If PrtChkUser( "MSALPHA", "PLSXFUN", "ATGUIAAAUT" )

		aDados := SEPARA (Chave, '|', .F.)
		aItens := SEPARA(CmdChave, '|', .F.)
		IF PLSPGDRECN (aDados, aItens)
			::WSNULL := "true|"
		ELSE
			::WSNULL := "false|"
		ENDIF
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf


Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getDiaRetro ³Autor  ³       ³ Data ³25.11.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Pegar Permissão Digitação de Guia Retroativa e os dias       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GETDIGP WSRECEIVE UserCode WSSEND WSNULL WSSERVICE PLSXFUN
	Local lRet 	:= .T.
	Local aArea 	:= GetArea()

	DEFAULT ::WSNULL := ""

	If PrtChkUser( ::UserCode, "PLSXFUN","GETDIGP" )
		::WSNULL := PLSRETLDP(4)
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRet

/*/{Protheus.doc} GRVALTOFF
Gravar Alteração OFFLine

@author Roberto Vanderlei
@since 23.06.2016
@version P12
@obs DigiGui para verificar digitação de guias Off-Line e Tipo para verificar se deve ou não finalizar a guia editada.
/*/
WSMETHOD GRVALTOFF WSRECEIVE UserCode, CamposAlterados, ItensAlterados, Tipo, RecnoBD5, TableCode, DigiGui, TipoAut WSSEND WSNULL WSSERVICE PLSXFUN
	Local aArea 			:= GetArea()
	Local lRet 				:= .T.
	Local aCriticas			:= {}
	local cCritica			:= ""
	local cEsp 				:= ""
	local nFor				:= 0
	local nItem				:= 0
	local cTpCon			:= ''
	local cTpSai			:= ''
	local cIndAcid			:= ''
	local aTabDup 			:= PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))
	local objGuia			:= nil
	local aCampoCabec 		:= {}
	local aCampoItem 		:= {}
	local aCampoTela 		:= {}
	local aCamposAlterados  := StrTokArr(::CamposAlterados, ";" )
	local aItensAlterados  	:= IIF(ValType(::ItensAlterados) <> "U",StrTokArr(::ItensAlterados, "#"),{})
	local cStringItem 		:= ""
	local aCampos 			:= {}
	local aItens 			:= {}
	local aObjProcedimentos := {}
	local oCoGuia 			:= CO_Guia():New()
	local oObjGuia 			:= nil
	local cCodPro  			:= ""
	local nI				:= 0

	local dDtExe        	:= ""
	local cHorIniSExe   	:= ""
	local cHorFimSExe   	:= ""
	local cCodPadSExe   	:= ""
	local cCodProSExe   	:= ""
	local cQtdSExe      	:= ""
	local cViaSExe      	:= ""
	local cTecSExe      	:= ""
	local nVlrUniSExe   	:= ""
	local cSequencial   	:= "0"

	local cCodPadOriginal 	:= ""
	local cCodProOriginal 	:= ""
	local nGuia 			:= 0
	local aRetGui			:= {.F.,""}
	local lSaveOk 			:= .T.
	local lTiss4New 		:= BD5->(FieldPos("BD5_COBESP")) > 0 .and. BD5->(FieldPos("BD5_SAUOCU")) > 0 .AND. BD5->(FieldPos("BD5_TMREGA")) > 0

	DEFAULT ::WSNULL		:= ""
	DEFAULT TipoAut			:= "2"	//Sem mudança de fase

	If PrtChkUser( ::UserCode, "PLSXFUN","GETCMPALT" )

		//Realiza o tratamento para alteração dos campos do cabeçalho
		for nFor := 1 to len(aCamposAlterados)

			aCampoTela := StrTokArr(aCamposAlterados[nFor], "$")

			if len(aCampoTela) = 1
				aadd(aCampoTela, "")
			endif

			if alltrim(aCampoTela[1]) <> ""

				if ::Tipo == "1"

					Do Case

						Case aCampoTela[1] == 'cAtendRN'

							aadd(aCampoCabec, {"BD5_ATERNA", aCampoTela[2]})

						Case aCampoTela[1]  == 'cObs'

							aadd(aCampoCabec, {"BD5_OBSGUI", Alltrim(aCampoTela[2])})

						Case aCampoTela[1] == 'cCbosExe'

							cCbos	:= aCampoTela[2]
							cEsp 	:= SubString(cCbos,1,3)

							aadd(aCampoCabec, {"BD5_CODESP", cEsp})
							aadd(aCampoItem,  {"BD6_CODESP", cEsp})

						Case aCampoTela[1] == 'cTpCon'

							cTpCon := alltrim(PLSVARVINC('52', nil, aCampoTela[2]) )

							aadd(aCampoCabec, {"BD5_TIPCON", cTpCon})
							aadd(aCampoItem,  {"BD6_TIPCON", cTpCon})

						Case aCampoTela[1] == 'cProSol' //Verificar Prestador

							cProExe := aCampoTela[2]
							aAdd(aCampoCabec,  {"BD5_CDPFRE", cProExe})
							aAdd(aCampoItem,   {"BD6_CDPFRE", cProExe})

						Case aCampoTela[1] == 'cTpSai'

							cTpSai := alltrim(PLSVARVINC('39','BEA', aCampoTela[2]))

							aadd(aCampoCabec, {"BD5_TIPSAI", cTpSai})

						Case aCampoTela[1] == 'cTpDoe'

							aadd(aCampoCabec, {"BD5_TIPDOE", aCampoTela[2]})

						Case aCampoTela[1] == 'cTmpDoe'

							aadd(aCampoCabec, {"BD5_TPODOE", aCampoTela[2]})

						Case aCampoTela[1] == 'cTmpDoeC'

							aadd(aCampoCabec, {"BD5_UTPDOE", aCampoTela[2]})

						Case aCampoTela[1] == 'cIndAcid'

							cIndAcid := alltrim(PLSVARVINC('36', nil, aCampoTela[2]))
							aadd(aCampoCabec, {"BD5_INDACI", cIndAcid})

						Case aCampoTela[1] == 'cCodPad'

							cCodPad := AllTrim(PLSVARVINC('87','BR4', aCampoTela[2]))
							aadd(aCampoItem, {"BD6_CODPAD", cCodPad})

						Case aCampoTela[1] == 'cCodPro'

							cCodPad := AllTrim(PLSVARVINC('87','BR4', ::TableCode))
							cCodPro := AllTrim(PLSVARVINC(::TableCode,'BR8',aCampoTela[2] ,::TableCode+aCampoTela[2],,aTabDup,@CCODPAD))

							aadd(aCampoItem, {"BD6_CODPRO", cCodPro})

						Case aCampoTela[1]  == 'cVlrPro'

							aadd(aCampoItem, {"BD6_VLRAPR", Val(AllTrim(StrTran(aCampoTela[2],",","")))})
							aadd(aCampoItem, {"BD6_VALORI", Val(AllTrim(StrTran(aCampoTela[2],",",""))) } )

						Case lTiss4New .and. aCampoTela[1]  == 'cCobertEsp'

							aadd(aCampoCabec, {"BD5_COBESP", aCampoTela[2]})

						Case lTiss4New .and. aCampoTela[1]  == 'cRegAtendim'

							aadd(aCampoCabec, {"BD5_TMREGA", aCampoTela[2]})

						Case lTiss4New .and. aCampoTela[1]  == 'cSaudeOcupac'

							aadd(aCampoCabec, {"BD5_SAUOCU", aCampoTela[2]})

					EndCase

				elseif ::Tipo == "6"

					Do Case
						Case aCampoTela[1] == 'cAtendRN'
							aadd(aCampoCabec, {"BD5_ATERNA", aCampoTela[2]})
					EndCase

				elseif ::Tipo == "2"

					Do Case
						Case aCampoTela[1] == 'cAtendRN'

							aAdd(aCampoCabec,  {"BD5_ATERNA", aCampoTela[2]})

						Case aCampoTela[1]  == 'cObs'

							aadd(aCampoCabec, {"BD5_OBSGUI", Alltrim(aCampoTela[2])})

						Case aCampoTela[1]  == 'cProSol'

							aAdd(aCampoCabec,  {"BD5_CDPFSO", aCampoTela[2] })
							aAdd(aCampoItem,   {"BD6_CDPFSO", aCampoTela[2] })

						Case aCampoTela[1]  == 'cCodSigSol'

							aAdd(aCampoCabec,  {"BD5_SIGLA", aCampoTela[2] })
							aAdd(aCampoItem,   {"BD6_SIGLA", aCampoTela[2] })

						Case aCampoTela[1] == 'cNumCrSol'

							aAdd(aCampoCabec,  {"BD5_REGSOL", aCampoTela[2]})
							aAdd(aCampoItem,   {"BD6_REGSOL", aCampoTela[2]})

						Case aCampoTela[1] == 'cEstSigSol'

							aAdd(aCampoCabec,  {"BD5_ESTSOL", aCampoTela[2]})
							aAdd(aCampoItem,   {"BD6_ESTSOL", aCampoTela[2]})

						Case aCampoTela[1] == 'cCbosSol'

							cCbosSol := aCampoTela[2]
							aAdd(aCampoCabec,  {"BD5_ESPSOL", SubString(cCbosSol,1,3)})
							aAdd(aCampoCabec,  {"BD5_CODESP", SubString(cCbosSol,1,3)})
							aAdd(aCampoItem,   {"BD6_CODESP", SubString(cCbosSol,1,3)})

						Case aCampoTela[1] == 'cCarSolicit'

							aAdd(aCampoCabec,  {"BD5_TIPADM", aCampoTela[2]})

						Case aCampoTela[1] == 'dDtSolicit'

							aAdd(aCampoCabec,  {"BD5_DATSOL", aCampoTela[2]})

						Case aCampoTela[1] == 'cIndCliSol'

							nTaman	 := (TamSX3("BD5_INDCLI")[1])
							cIndCliSol := aCampoTela[2]

							aAdd(aCampoCabec,  {"BD5_INDCLI", SubStr(AllTrim(cIndCliSol),1, nTaman) })
							aAdd(aCampoCabec,  {"BD5_INDCL2", IIF (Len(cIndCliSol) > nTaman, SubStr(cIndCliSol,nTaman+1,Len(cIndCliSol) ), "")})

						Case aCampoTela[1] == 'cCnesExe'

							aAdd(aCampoCabec,  {"BD5_CNES", aCampoTela[2] })

						Case aCampoTela[1] == 'cTpAteExe'   //De/Para

							cTpAteExe := alltrim(PLSVARVINC('50', nil, aCampoTela[2]) )
							aAdd(aCampoCabec,  {"BD5_TIPATE", cTpAteExe})

						Case aCampoTela[1] == 'cIndAcid'   //De/Para

							cIndAcid := alltrim(PLSVARVINC('36', nil, aCampoTela[2]) )
							aAdd(aCampoCabec,  {"BD5_INDACI", cIndAcid})

						Case aCampoTela[1] == 'cTpCon'    //De/Para

							cTpCon := alltrim(PLSVARVINC('52', nil, aCampoTela[2]) )
							aAdd(aCampoCabec,  {"BD5_TIPCON", cTpCon})
							aAdd(aCampoItem,   {"BD6_ESTSOL", cTpCon})

						Case aCampoTela[1] == 'cTpSai'    //De/Para

							cTpSai := alltrim( PLSVARVINC('39', nil, aCampoTela[2]) )
							aAdd(aCampoCabec,  {"BD5_TIPSAI", cTpSai})

						Case aCampoTela[1] == 'cTpDoe'

							aadd(aCampoCabec, {"BD5_TIPDOE", aCampoTela[2]})

						Case aCampoTela[1] == 'cTmpDoe'

							aadd(aCampoCabec, {"BD5_TPODOE", aCampoTela[2]})

						Case aCampoTela[1] == 'cTmpDoeC'

							aadd(aCampoCabec, {"BD5_UTPDOE", aCampoTela[2]})

						Case aCampoTela[1] == 'cNumInt'

							cNumInt := aCampoTela[2]
							aadd(aCampoCabec, {"BD5_NRLBOR", cNumInt})
							aadd(aCampoItem,  {"BD6_NRLBOR", cNumInt})

					EndCase

				endif

			endif

		next

		objGuia := CO_Guia():New()
		aRetGui := objGuia:altGuia(aCampoCabec, aCampoItem, ::RecnoBD5)
		lSaveOk := aRetGui[1]

		// Realiza o tratamento para alteração dos campos da grid de itens
		for nItem := 1 to len(aItensAlterados)

			cStringItem := aItensAlterados[nItem]
			aCampos     := StrTokArr(cStringItem, ";" )

			if StrTokArr(aCampos[1], "$")[2] == "A"

				// ALTERACAO
				aCmpOrg  := retCmpIte(cStringItem, ::TableCode, aTabDup)
				aRetGui := oCoGuia:altItem(aCmpOrg, ::RecnoBD5)
				lSaveOk := aRetGui[1]

			else

				// INCLUSAO
				if StrTokArr(aCampos[1], "$")[2] == "I"

					if len(StrTokArr(aCampos[2], "$")) > 1
						dDtExe         := StrTokArr(aCampos[2], "$")[2]
					endif

					if len(StrTokArr(aCampos[3], "$")) > 1
						cHorIniSExe    := StrTokArr(aCampos[3], "$")[2]
					endif

					if len(StrTokArr(aCampos[4], "$")) > 1
						cHorFimSExe    := StrTokArr(aCampos[4], "$")[2]
					endif

					if len(StrTokArr(aCampos[5], "$")) > 1
						cCodPadSExe    := StrTokArr(aCampos[5], "$")[2]
					endif

					if len(StrTokArr(aCampos[6], "$")) > 1
						cCodProSExe    := StrTokArr(aCampos[6], "$")[2]
					endif

					if len(StrTokArr(aCampos[7], "$")) > 1
						cQtdSExe       := StrTokArr(aCampos[7], "$")[2]
					endif

					if len(StrTokArr(aCampos[8], "$")) > 1
						cViaSExe       := StrTokArr(aCampos[8], "$")[2]
					endif

					if len(StrTokArr(aCampos[9], "$")) > 1
						cTecSExe       := StrTokArr(aCampos[9], "$")[2]
					endif

					if len(StrTokArr(aCampos[10], "$")) > 1
						nVlrUniSExe    := StrTokArr(aCampos[10], "$")[2]
					endif

					oObjGuia := oCoGuia:loadGuiaRecno(val(::RecnoBD5), .F., .T.)

					for nGuia  := 1 to len(oObjGuia:getProcedimentos())
						if nGuia = 1
							cSequencial := strzero(val(oObjGuia:getProcedimentos()[nGuia]:getSeqMov()) + 1, 3)
						else
							if val(oObjGuia:getProcedimentos()[nGuia]:getSeqMov()) >= val(cSequencial)
								cSequencial := strzero(val(oObjGuia:getProcedimentos()[nGuia]:getSeqMov()) + 1, 3)
							endif
						endif
					next

					mntaIte(dDtExe, cHorIniSExe, cHorFimSExe, cCodPadSExe, cCodProSExe, cQtdSExe, cViaSExe, cTecSExe, nVlrUniSExe, cSequencial, aItens)

					aObjProcedimentos:= oCoGuia:getLstProcedimentos(oObjGuia:getDadBenef():getMatric(), aItens, oObjGuia)

					aRetGui := oCoGuia:incIteGuia(oObjGuia, aObjProcedimentos, .F.)
					lSaveOk := aRetGui[1]

				else

					// EXCLUSAO
					if StrTokArr(aCampos[1], "$")[2] == "E"

						cCodPadOriginal := AllTrim(PLSVARVINC('87','BR4', StrTokArr(aCampos[3], "$")[2]))
						cCodProOriginal := AllTrim(PLSVARVINC(StrTokArr(aCampos[3], "$")[2],'BR8',StrTokArr(aCampos[2], "$")[2] ,StrTokArr(aCampos[3], "$")[2]+StrTokArr(aCampos[2], "$")[2],,aTabDup,@cCodPadOriginal))

						aRetGui := oCoGuia:excIteGuia(cCodPadOriginal, cCodProOriginal, ::RecnoBD5)
						lSaveOk := aRetGui[1]

					endif
				endif
			endif
		next

		IF (::TipoAut == "1")

			aCriticas := PLSMDFSGDIG (::RecnoBD5, ::TipoAut)

			IF !aCriticas[1]
				cCritica := "<br>Foram encontradas críticas no processamento: <br>"
				For nI := 3  TO Len(aCriticas)
					If (aCriticas[nI,1,1] <> "")
					aRet := PLSRETCRI( AllTrim( aCriticas[nI,1,1]))

					If EMPTY(aRet[1][2])
						aRet[1][1] := aCriticas[nI][1][1]
						aRet[1][2] := aCriticas[nI][1][2]
					EndIf

				ENDIF
				cCritica += "Procedimento: <br>"+ aCriticas[nI,1,7] + " -- Cód. Glosa: " + aRet[1,1] + " -- " + PadR( AllTrim(aRet[1,2]),75 ) + "<br>"
				NEXT
				cCritica := "|-|"+cCritica
			ENDIF
		ENDIF

	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	::WSNULL := IIF(lSaveOk,aRetGui[2]+cCritica,"")

	RestArea( aArea )

Return lRet

/*/{Protheus.doc} retCmpIte
@author PLSTEAM
@since 23.06.2016
@version P12
/*/
function retCmpIte(cStringItem, cTableCode, aTabDup)
	local nFor
	local cCampo
	local cValor
	local cCodPad
	local cCodPro
	local cTecUti
	local aCampos  := StrTokArr(cStringItem, ";" )
	local aRetorno := {}
	local cCodPadOriginal := ""
	local cCodProOriginal := ""


	cCodPadOriginal := AllTrim(PLSVARVINC('87','BR4', StrTokArr(aCampos[3], "$")[2]))
	cCodProOriginal := AllTrim(PLSVARVINC(StrTokArr(aCampos[3], "$")[2],'BR8',StrTokArr(aCampos[2], "$")[2] ,StrTokArr(aCampos[3], "$")[2]+StrTokArr(aCampos[2], "$")[2],,aTabDup,@cCodPadOriginal))

	aadd(aRetorno, {"PROCED", cCodProOriginal })
	aadd(aRetorno, {"TAB", cCodPadOriginal })

	for nFor := 1 to len(aCampos)
		if nFor > 3 //Despreza o Tipo Código proc original e Código Tab Original
			cCampo := StrTokArr(aCampos[nFor], "$")[1]
			cValor := Iif(Len(StrTokArr(aCampos[nFor], "$")) > 1,StrTokArr(aCampos[nFor], "$")[2],"")

			Do Case
				Case cCampo == 'dDtExe'
					aadd(aRetorno,  {"BD6_DATPRO", ctod(cValor)})

				Case cCampo == 'cHorIniSExe'
					aadd(aRetorno,  {"BD6_HORPRO", cValor})

				Case cCampo == 'cHorFimSExe'
					aadd(aRetorno,  {"BD6_HORFIM", StrTran(cValor,":","")}) //Tratamento para retirar o ":" da hora, pois o tamanho do campo é 4.

				Case cCampo == 'cCodPadSExe'

					cCodPad := AllTrim(PLSVARVINC('87','BR4', cValor))
					aadd(aRetorno, {"BD6_CODPAD", cCodPad})

				Case cCampo == 'cCodProSExe'

					cCodPad := AllTrim(PLSVARVINC('87','BR4', cTableCode))
					cCodPro := AllTrim(PLSVARVINC(cTableCode,'BR8',cValor ,cTableCode+cValor,,aTabDup,@CCODPAD))

					aadd(aRetorno, {"BD6_CODPRO", cCodPro})

				Case cCampo == 'cDesProSExe'
					aadd(aRetorno,  {"BD6_DESPRO", left(alltrim(cValor), TamSx3("BD6_DESPRO")[1]) })

				Case cCampo == 'cQtdSExe'
					aadd(aRetorno,  {"BD6_QTDSOL", val(alltrim(cValor))})
					aadd(aRetorno,  {"BD6_QTDPRO", val(alltrim(cValor))})

				Case cCampo == 'cViaSExe'

					aadd(aRetorno,  {"BD6_VIA", cValor})
					aadd(aRetorno,  {"BD6_PERVIA", plRtPerV(cValor)})

				Case cCampo == 'cTecSExe' //Verificar

					cTecUti := alltrim(PLSVARVINC('48', nil, cValor) )
					aadd(aRetorno,  {"BD6_TECUTI", cTecUti})

				Case cCampo == 'nVlrUniSExe'
					aadd(aRetorno,  {"BD6_VLRAPR", val(cValor)})

			endcase
		endif
	next

return aRetorno

/*/{Protheus.doc} mntaIte
@author PLSTEAM
@since 23.06.2016
@version P12
/*/
function mntaIte(dDtExe, cHorIniSExe, cHorFimSExe, cCodPadSExe, cCodProSExe, cQtdSExe, cViaSExe, cTecSExe, nVlrUniSExe, cSequencial, aItens)
	local cCodPro
	local cCodPad
	local aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))
	local cTecUti

	cCodPad  := AllTrim(PLSVARVINC('87','BR4', cCodPadSExe))
	cCodPro  := AllTrim(PLSVARVINC(cCodPadSExe,'BR8',cCodProSExe,cCodPadSExe+cCodProSExe,,aTabDup,@CCODPAD))

	cTecUti := alltrim(PLSVARVINC('48', nil, cTecSExe) )

	AaDd( aItens, {{ "SEQMOV", strzero(val(cSequencial), 3)},;
		{ "CODPRO", cCodPro },;
		{ "CODPAD", cCodPad },;
		{ "QTD"	 , VAL(cQtdSExe) },;
		{ "QTDAUT", VAL(cQtdSExe) },;
		{ "VLRAPR", VAL(nVlrUniSExe) },;
		{ "HORINI", cHorIniSExe },;
		{ "HORFIM", strTran(cHorFimSExe,":","")},;
		{ "VIAAC",  cViaSExe },;
		{ "TECUT",  cTecUti },;
		{ "STPROC", "" } ,;
		{ "SLVPRO", "" } ,;
		{ "SLVPAD", "" } ,;
		{ "STPROC", "" } ,;
		{ "DATPRO", CTOD(dDtExe) } } )

return

/*/{Protheus.doc} RETCRIMF
Retorna as críticas para o usuário

@author Renan Martins
@since 06/2016
@version P12
/*/
WSMETHOD RETCRIMF WSRECEIVE UserCode, Chave WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 	:= .T.
	LOCAL aCrit		:= {}
	LOCAL ctexto	:= ""
	LOCAL nI		:= 0

	IF PrtChkUser( ::UserCode, "PLSXFUN", "RETCRIMF" )

		aCrit := PLSMFCRITP(::Chave)
		IF len(aCrit) > 0
			cTexto +="<div width: 30px; height: 30px; overflow-y: scroll;>"
			cTexto += '<table border = 1 bordercolor=#DDDDDD>'
			For nI := 1 TO Len(aCrit)
				//cTexto += "<li>Procedimento: "+ aCrit[nI,1] + " --- Código Glosa: " + aCrit[nI,2,1,1] + " ---  Descrição: " + aCrit[nI,2,1,2] + "</li>"
				cCor := IIF((nI%2 == 0), '#E8F6F8', '#F7FCFC')
				cTexto += '<tr BGCOLOR='+cCor+'>'
				cTexto += "<td><strong>Procedimento:</strong> "+ Alltrim(aCrit[nI,1]) + "<br><strong>Motivo:</strong> " + aCrit[nI,2,1,1] + "<br><strong>Descrição:</strong> " + aCrit[nI,2,1,2] + "</td>"
				cTexto += '</tr>'
			Next
			cTexto+= '</table>'
			cTexto+= '</div>'
		ELSE
			cTexto += "Glosas não encontradas"
		ENDIF
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	::WSNULL := cTexto
Return lRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} RETCRIAUT
Retorna as críticas para o beneficiário

@author Renan Martins
@since 06/2016
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD RETCRIAUT WSRECEIVE UserCode, Chave WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 	:= .T.
	LOCAL aCrit		:= {}
	LOCAL ctexto	:= ""
	LOCAL nI		:= 0

	IF PrtChkUser( ::UserCode, "PLSXFUN", "RETCRIAUT" )

		aCrit := PLSCRIBNF(::Chave)
		IF len(aCrit) > 0
			cTexto +="<div width: 30px; height: 30px; overflow-y: scroll;>"
			cTexto += '<table border = 1 bordercolor=#DDDDDD>'
			For nI := 1 TO Len(aCrit)
				cCor := IIF((nI%2 == 0), '#E8F6F8', '#F7FCFC')
				cTexto += '<tr BGCOLOR='+cCor+'>'
				cTexto += "<td><strong>Motivo:</strong> " + aCrit[nI,1,1,1] + " ---  <strong>Descrição:</strong> " + aCrit[nI,1,1,2] + "</td>"
				cTexto += '</tr>'
			Next
			cTexto+= '</table>'
			cTexto+= '</div>'
		ELSE
			cTexto += "Glosas não encontradas"
		ENDIF
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	::WSNULL := cTexto
Return lRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} VBlqBen
Verifica se o beneficiário está bloqueado
@author Oscar Zanin
@since 08/2016
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD VBlqBen WSRECEIVE UserCode, Benef, DataString WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno := .T.
	Local cChave	:= Left(::Benef, 14)
	Local cTipReg	:= SubStr(::Benef, 15, 2)
	Local dData	:= CtoD(::DataString)
	Local aAreaBA1	:= BA1->(GetArea())
	//BA1_FILIAL+BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO
	BA1->(DbSetOrder(2))
	BA1->(MsSeek(xFilial("BA1") + ::Benef))

	IF PrtChkUser( ::UserCode, "PLSXFUN", "VBlqBen" )

		If dData > dDataBase
			::WSNULL := "false|Data de Atendimento inserida é maior que a data atual!"
		ElseIf dData < BA1->BA1_DATINC
			::WSNULL = "false|Data de Atendimento anterior à data de inclusão do Beneficiário!"
		ElseIf PlChHiBlo("BCA",dData,cChave,cTipReg) .AND. !(PLSPACINT(::Benef,dData)) //Também tem que ver se está internado
			::WSNULL := "false|Usuário bloqueado na data informada!"
		else
			::WSNULL := "true|Ok"
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea(aAreaBA1)

Return lRetorno


//---------------------------------------------------------------------------------------
/*/{Protheus.doc} getNumProtoc
WS que retorna o número do protocolo de atendimento.

@author	Lucas Nonato
@since		08/08/2016
@version	P11


/*/
//---------------------------------------------------------------------------------------

wsMethod getNumProtoc wsReceive userCode wsSend NumProtoc wsService PLSXFUN
	Local lRet := .T.

	If prtChkUser( ::UserCode ,"PLSXFUN","getNumProtoc" )

		::NumProtoc := P773GerPro("")

		If Empty(::NumProtoc)
			lRet := .F.
		EndIF

	EndIF

Return lRet

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} VldNumProtoc
WS que valida o número do protocolo de atendimento, somente quando for intercambio

@author	Lucas Nonato
@since		08/08/2016
@version	P11

/*/
//---------------------------------------------------------------------------------------

wsMethod VldNumProtoc wsReceive userCode,NumProtoc,MatUsu wsSend CritProtoc wsService PLSXFUN
	Local lRet 	:= .T.
	Local aResult	:= {}

	If prtChkUser( ::UserCode ,"PLSXFUN","VldNumProtoc" )
		aResult := PLVldProtInt(::MatUsu,::NumProtoc)
		If !aResult[1]
			::CritProtoc 	:= AllTrim(aResult[2])
		Else
			::CritProtoc :=	""
		EndIf

	EndIf

Return lRet

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} Protocolo
WS que faz a comunicação com a Unimed Origem para pegar o número do protocolo

@author	Lucas Nonato
@since		08/08/2016
@version	P11

/*/
//---------------------------------------------------------------------------------------

wsMethod Protocolo wsReceive UserCode,DDD,Telefone,ProtAnt,Sentimento,TxtLivre,Matric wsSend WSNULL wsService PLSXFUN
	Local lRet 	:= .T.
	Local aResult	:= {}
	Local aDados	:= {::DDD,::Telefone,::ProtAnt,::Sentimento,::TxtLivre}

	If prtChkUser( ::UserCode ,"PLSXFUN","Protocolo" )
		aResult := PL773WEBRN("",::Matric,,,,.T.,aDados)
		If aResult[1]
			::WSNULL := "true|" + aResult[3]
		Else
			::WSNULL := "false|[" + aResult[2][1][1] +"] " + aResult[2][1][2]
		EndIf
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} VlDtFut
Verifica se a data não é futura (servidor)
@author Oscar Zanin
@since 08/2016
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD VlDtFut WSRECEIVE UserCode, DataString WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno := .T.
	Local dData	:= CtoD(::DataString)

	IF PrtChkUser( ::UserCode, "PLSXFUN", "VlDtFut" )

		If dData > dDataBase
			::WSNULL := "false|Data de Atendimento inserida é maior que a data atual!"

		else
			::WSNULL := "true|Ok"
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

//-------------------------------------------------------------------
/*/{Protheus.doc} UpdB1N

@author Karine Riquena Limp
@since 28/09/2016
@version P12
@description Atualiza todas os itens da B1N quando altera o cabeçalho
               no reembolso
/*/
//-------------------------------------------------------------------
WSMETHOD UpdB1N WSRECEIVE UserCode, CodSol, CPFCNPJ, NomRdaNRef, Tipo, NumDoc, DocEmi WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno := .T.

	IF PrtChkUser( ::UserCode, "PLSXFUN", "UpdB1N" )
		PLSUPDB1N(::CodSol, ::CPFCNPJ, ::NomRdaNRef, ::Tipo, ::NumDoc, ctod(::DocEmi))
		::WSNULL := "true|Ok"
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getDiaRetro ³Autor  ³ Geraldo Félix Júnior³ Data ³25.11.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna uma lista de procedimento com base no tipo de serviço do reembolso online
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetReembProc WSRECEIVE UserCode, TipSer, Pesquisa WSSEND StMPctIteGui WSSERVICE PLSXFUN
	Local lRet 	:= .T.
	Local aArea 	:= GetArea()
	LOCAL cSql 	:= ""
	LOCAL cTipSer	:= ::TipSer
	LOCAL cDesPro := ::Pesquisa
	LOCAL nCnt := 0

	If !PrtChkUser( ::UserCode, "PLSXFUN","GetReembProc" )
		RestArea( aArea )
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	If Empty(cTipSer)
		RestArea( aArea )
		lRet := .F.
		SetSoapFault( "", "Tipo de serviço não informado" )
	Endif

	If lRet
		cSql := "SELECT BR8_CODPAD, BR8_CODPSA, BR8_DESCRI FROM "+RetSqlName("BR8")+" BR8 WHERE BR8_FILIAL = '"+xFilial("BR8")+"' "
		cSql += "AND BR8_CLASSE = '"+cTipSer+"' "
		cSql += "AND BR8_EXPBEN = '1' "
		cSql += "AND D_E_L_E_T_ = '' "
		If !Empty(cDesPro)
			cSql += "AND BR8_DESCRI LIKE '%"+Alltrim(Upper(cDesPro))+"%' "
		Endif
		cSql += "ORDER BY BR8_DESCRI "
		cSql := ChangeQuery(cSql)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TRB1",.T.,.F.)

		If !TRB1->( Eof() )
			::StMPctIteGui := {}

			While !TRB1->( Eof() )
				nCnt ++

				// Limita 30 registros. O aplicativo vai emitir alerta para refinar a busca quando houver mais de 30 itens.
				If nCnt > 30
					Exit
				Endif

				AaDd( ::StMPctIteGui, WsClassNew( "MPctIteGui" ) )

				::StMPctIteGui[nCnt]:CodPad			:= TRB1->BR8_CODPAD
				::StMPctIteGui[nCnt]:CodPro			:= TRB1->BR8_CODPSA
				::StMPctIteGui[nCnt]:DesPro			:= Alltrim(TRB1->BR8_DESCRI)

				TRB1->( dbSkip() )
			Enddo
		Else
			lRet := .f.
			setSoapFault( "", "Não existem registros para essa consulta" )
		EndIf

		TRB1->( dbCloseArea() )
	Endif

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getDiaRetro ³Autor  ³ Geraldo Félix Júnior³ Data ³25.11.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna uma lista de procedimento com base no tipo de serviço do reembolso online
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PesqReembProc WSRECEIVE UserCode, TipSer, cCodPro WSSEND StMPctIteGui WSSERVICE PLSXFUN
	Local lRet 	:= .T.
	Local aArea 	:= GetArea()
	LOCAL cSql 	:= ""
	LOCAL cTipSer	:= ::TipSer
	LOCAL cCodPro := ::cCodPro

	If !PrtChkUser( ::UserCode, "PLSXFUN","PesqReembProc" )
		RestArea( aArea )
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	If Empty(cTipSer)
		RestArea( aArea )
		lRet := .F.
		SetSoapFault( "", "Tipo de serviço não informado" )
	Endif

	If Empty(cCodPro)
		RestArea( aArea )
		lRet := .F.
		SetSoapFault( "","Código do procedimento não informado" )
	Endif

	If lRet
		cSql := "SELECT * FROM "+RetSqlName("BR8")+" BR8 WHERE BR8_FILIAL = '"+xFilial("BR8")+"' "
		cSql += "AND BR8_CLASSE = '"+cTipSer+"' "
		cSql += "AND BR8_EXPBEN = '1' "
		cSql += "AND BR8_CODPSA = '"+cCodPro+"' "
		cSql += "AND D_E_L_E_T_ = '' "
		cSql := ChangeQuery(cSql)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TRB1",.T.,.F.)

		::StMPctIteGui := {}
		If !TRB1->( Eof() )
			Aadd(::StMPctIteGui, WsClassNew( "MPctIteGui" ))
			::StMPctIteGui[1]:CodPad			:= TRB1->BR8_CODPAD
			::StMPctIteGui[1]:CodPro			:= TRB1->BR8_CODPSA
			::StMPctIteGui[1]:DesPro			:= Alltrim(TRB1->BR8_DESCRI)
		Else
			lRet := .f.
			setSoapFault( "", "Não existem registros para essa consulta." )
		EndIf

		TRB1->( dbCloseArea() )
	Endif

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetCarVirt ³Autor  ³ Totvs   ³ Data ³05.04.2016 				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Exclui uma solicitação não concluida  de uso constante        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetCarVirt WSRECEIVE UserCode,lista_de_cartoes  WSSEND ret_cartao_virtual WSSERVICE PLSXFUN

	LOCAL cSql 		:= ""
	LOCAL cCodInt		:= ""
	LOCAL cCodEmp   	:= ""
	LOCAL cMatric		:= ""
	LOCAL cTipReg		:= ""
	LOCAL cDigito		:= ""

	local cCodPla		:= ""
	LOCAL cVerPla 	:= ""
	LOCAL cDesPla		:= ""

	LOCAL nCnt			:= 0
	LOCAL cTelefone	:= ""

	LOCAL cTitular 			:= GetNewPar("MV_PLCDTIT", "T")
	LOCAL aRetRede			:= {}

	LOCAL cOpcional			:= ""
	LOCAL oObjBackup			:= nil
	LOCAL aAux					:= {}

	LOCAL cMatTit	    		:= ""
	LOCAL aEndTitular			:= {}
	LOCAL lExistTitular		:= .F.
	LOCAL aUsr					:= {}
	LOCAL cLogUsr				:= ::lista_de_cartoes:cLogin
	LOCAL nCount				:= 0
	local lMSCVOPC := Existblock("MSCVOPC")
	local lMSCVREDE := Existblock("MSCVREDE")
	local lMSLOGFIM := Existblock("MSLOGFIM")

	// Validação de usuário
	If !PrtChkUser( ::UserCode, "PLSXFUN", "RetCarVirt" )
		SetSoapFault( "", "Não autorizado a utilização do método" )

		Return .f.
	EndIf
	// Inicializa o objeto.
	::ret_cartao_virtual := WsClassNew( "st_cartao_virtual" )
	::ret_cartao_virtual:retorno_dados 		:= {}
	::ret_cartao_virtual:mensagem			 	:= ""

	lExistTitular := .F.
	For nCnt := 1 to len (::lista_de_cartoes:cart_usuarios)
		// Cria uma matriz mais simples de usar
		Aadd(aUsr, {	::lista_de_cartoes:cart_usuarios[nCnt]:mat_usuario,;
			::lista_de_cartoes:cart_usuarios[nCnt]:tip_usuario})

		// Verifica se o titular está presente na lista de usuários
		If ::lista_de_cartoes:cart_usuarios[nCnt]:tip_usuario == cTitular
			lExistTitular := .T.

			cMatTit := ::lista_de_cartoes:cart_usuarios[nCnt]:mat_usuario
		Endif
	Next

	If Len(aUsr) == 0
		::ret_cartao_virtual:retorno_status 	:= .F.
		::ret_cartao_virtual:mensagem			:= "Inconsistencias no cadastro. Lista vazia."

		Return .T.
	Endif

	// Ordena o array
	Asort(aUsr,,, {|x, y| x[1] < y[1]})

	// Posiciona familia do usuário
	BA3->(DbSetOrder(1))
	If !BA3->(MsSeek(xFilial("BA3")+SubStr(aUsr[1][1],1,14)))
		::ret_cartao_virtual:retorno_status 	:= .F.
		::ret_cartao_virtual:mensagem			:= "Inconsistencias no cadastro. Familia não existe"

		Return .T.
	Endif

	If !BG9->( dbSeek(xFilial("BG9")+BA1->BA1_CODINT+BA1->BA1_CODEMP) )
		::ret_cartao_virtual:retorno_status 	:= .F.
		::ret_cartao_virtual:mensagem			:= "Inconsistencias no cadastro. Empresa não existe"

		Return .T.
	Endif

	If !BQC->(dbSeek(xFilial("BQC")+BA3->BA3_CODINT+BA3->BA3_CODEMP+BA3->BA3_CONEMP+BA3->BA3_VERCON+BA3->BA3_SUBCON+BA3->BA3_VERSUB))
		::ret_cartao_virtual:retorno_status 	:= .F.
		::ret_cartao_virtual:mensagem			:= "Inconsistencias no cadastro. Sub não existe"

		Return .T.
	Endif

	If lExistTitular
		// Se o titular estiver presente na lista de usuários, armazena os dados dele.
		BA1->( dbSetorder(02) )
		BA1->( dbSeek(xFilial("BA1")+cMatTit) )
		cNomTit := Alltrim(BA1->BA1_NOMUSR)
		aEndTitular :={BA1->BA1_ENDERE,;
			BA1->BA1_NR_END,;
			BA1->BA1_COMEND,;
			BA1->BA1_BAIRRO,;
			BA1->BA1_MUNICI,;
			BA1->BA1_ESTADO,;
			BA1->BA1_CEPUSR}

	Else
		// Se o titular não estiver presente na lista de usuários, vou precisar descobrir quem ele é para armazenar os dados dele.
		cSql := "SELECT BA1_CODINT,BA1_CODEMP,BA1_MATRIC,BA1_TIPREG,BA1_DIGITO,BA1_ENDERE,BA1_NR_END,BA1_COMEND,BA1_BAIRRO,BA1_MUNICI,BA1_ESTADO,BA1_CEPUSR,BA1_NOMUSR "
		cSql += " FROM "+RetSqlName("BA1")+" WHERE BA1_FILIAL = '"+xFilial("BA1")+"' "
		cSql += " AND BA1_CODINT = '"+BA3->BA3_CODINT+"' "
		cSql += " AND BA1_CODEMP = '"+BA3->BA3_CODEMP+"' "
		cSql += " AND BA1_MATRIC = '"+BA3->BA3_MATRIC+"' "
		cSql += " AND BA1_TIPUSU = '"+cTitular+"' "
		cSql += " AND D_E_L_E_T_ = ' '"
		PlsQuery(cSql, "TRBBA1")

		If !TRBBA1->(Eof())
			cMatTit := Alltrim(TRBBA1->BA1_CODINT + TRBBA1->BA1_CODEMP + TRBBA1->BA1_MATRIC + TRBBA1->BA1_TIPREG + TRBBA1->BA1_DIGITO)
			cNomTit := Alltrim(TRBBA1->BA1_NOMUSR)

			aEndTitular := {	BA1->BA1_ENDERE,;
				BA1->BA1_NR_END,;
				BA1->BA1_COMEND,;
				BA1->BA1_BAIRRO,;
				BA1->BA1_MUNICI,;
				BA1->BA1_ESTADO,;
				BA1->BA1_CEPUSR}
		Endif

		TRBBA1->( dbCloseArea() )
	Endif

	BA1->( dbSetorder(02) )
	BIH->(dbSetorder(01))
	BRP->(dbSetorder(01))
	BT6->(DbSetOrder(1))
	BI3->(dbSetorder(01))
	BB6->(DbSetOrder(1))
	BTS->(dbSetorder(1))
	BQC->(dbSetorder(1))
	BG9->(dbSetorder(1))
	GCM->(dbSetorder(02))

	// Chegou neste ponto, é porque está tudo OK.
	::ret_cartao_virtual:retorno_status 	:= .T.

	For nCount := 1 to len(aUsr)

		If !BA1->( dbSeek(xFilial("BA1")+aUsr[nCount][1]) )
			Loop
		Endif

		// Registra o codigo do produto do usu'ario
		If !Empty(BA1->BA1_CODPLA) .and. !Empty(BA1->BA1_VERSAO)
			cCodPla := BA1->BA1_CODPLA
			cVerPla := BA1->BA1_VERSAO
			cCodInt := BA1->BA1_CODINT
		Else
			cCodPla := BA3->BA3_CODPLA
			cVerPla := BA3->BA3_VERSAO
			cCodInt := BA3->BA3_CODINT
		Endif

		// Posiciona o plano da famila
		If BI3->(dbSeek(xFilial("BI3")+cCodInt+cCodPla+cVerPla))
			cDesPla := BI3->BI3_DESCRI
			cPlaHsp := BI3->BI3_HSPPLA
		Else
			cDesPla := ""
			cPlaHsp := ""
		Endif

		// Agora busca o convenio do paciente, se houver integração com HSP.
		If GCM->(dbSeek(xFilial("GCM")+cPlaHsp))
			cCodCon := GCM->GCM_CODCON

		Else
			cCodCon := GCM->GCM_CODCON

		Endif

		GBH->(dbSetorder(8))
		GD4->(DbSetOrder(3))

		// Faz um backup dos dados do usuário que fez o login porque o BA1 será movido.
		cCodInt := BA1->BA1_CODINT
		cCodEmp := BA1->BA1_CODEMP
		cMatric := BA1->BA1_MATRIC
		cTipReg := BA1->BA1_TIPREG
		cDigito := BA1->BA1_DIGITO

		// Garante que o os bloqueados serão desconsiderados
		If !Empty(BA1->BA1_DATBLO) .and. BA1->BA1_DATBLO < dDataBase
			TRB->( dbSkip())
		Endif

		aAdd(::ret_cartao_virtual:retorno_dados, WsClassNew( "cartao_virtual" ) )
		nI := Len(::ret_cartao_virtual:retorno_dados)

		// Marca o flag que indica que foi este o usuário do login.
		If BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG) == (cCodInt + cCodEmp + cMatric + cTipReg)
			::ret_cartao_virtual:retorno_dados[nI]:login := cLogUsr

		Else
			::ret_cartao_virtual:retorno_dados[nI]:login := ""
		Endif

		// Flag que indica que este usuario é o titular
		If BA1->BA1_TIPUSU == cTitular
			::ret_cartao_virtual:retorno_dados[nI]:titular	:= "S"

		Else
			::ret_cartao_virtual:retorno_dados[nI]:titular	:= "N"
		Endif

		::ret_cartao_virtual:retorno_dados[nI]:titular_matricula := cMatTit

		// Flag que indica que o beneficiário está bloqueado no sistema.
		If (!Empty(BA1->BA1_DATBLO) .and. BA1->BA1_DATBLO < dDataBase)
			::ret_cartao_virtual:retorno_dados[nI]:bloqueado			:= "S"
			::ret_cartao_virtual:retorno_dados[nI]:motivo_bloqueio		:= "Usuário bloqueado no sistema"
		Else
			::ret_cartao_virtual:retorno_dados[nI]:bloqueado			:= "N"
			::ret_cartao_virtual:retorno_dados[nI]:motivo_bloqueio		:= ""
		Endif

		// Se houver integração com HSP, torna-se obrigatório ter o vinculo entre o GBH e BTS.
		// Se o relacionamento não estiver integro, trata o beneficiário com se não tivesse acesso.
		If GBH->(dbSeek(xFilial("GBH")+BA1->BA1_MATVID))
			::ret_cartao_virtual:retorno_dados[nI]:prontuario_id			:= GBH->GBH_CODPAC

		Else
			::ret_cartao_virtual:retorno_dados[nI]:prontuario_id			:= ""
		Endif

		// Tipo de usuário
		::ret_cartao_virtual:retorno_dados[nI]:tipo_beneficiario_id				:= Alltrim(BA1->BA1_TIPUSU)
		If BIH->(dbSeek(xFilial("BIH")+BA1->BA1_TIPUSU))
			::ret_cartao_virtual:retorno_dados[nI]:tipo_beneficiario_descricao	:= Alltrim(BIH->BIH_DESCRI)
		Else
			::ret_cartao_virtual:retorno_dados[nI]:tipo_beneficiario_descricao	:= ""
		Endif

		// Grau de parentesco
		::ret_cartao_virtual:retorno_dados[nI]:grau_parentesco_id					:= Alltrim(BA1->BA1_TIPREG)
		If BRP->(dbSeek(xFilial("BRP")+BA1->BA1_GRAUPA))
			::ret_cartao_virtual:retorno_dados[nI]:grau_parentesco_descricao		:= Alltrim(BRP->BRP_DESCRI)
		Else
			::ret_cartao_virtual:retorno_dados[nI]:grau_parentesco_descricao		:= ""
		Endif

		// Cartão de identificação: dados básicos
		If !Empty(BA1->BA1_DTVLCR)
			::ret_cartao_virtual:retorno_dados[nI]:cartao_validade					:= BA1->BA1_DTVLCR
		Endif
		::ret_cartao_virtual:retorno_dados[nI]:cartao_via						:= Alltrim(Str(BA1->BA1_VIACAR))
		::ret_cartao_virtual:retorno_dados[nI]:data_cpt							:= dtoc(BA1->BA1_DATCPT)

		// Cartão de identificação: numero CNS
		If BTS->( dbSeek(xFilial("BTS")+BA1->BA1_MATVID))
			If BTS->(FieldPos("BTS_NRCRNA")) > 0
				::ret_cartao_virtual:retorno_dados[nI]:numero_cns	:= BTS->BTS_NRCRNA
			Else
				::ret_cartao_virtual:retorno_dados[nI]:numero_cns	:= ""
			Endif
		Else
			::ret_cartao_virtual:retorno_dados[nI]:numero_cns	:= ""
		Endif

		// Dados pessoais
		cTelefone := Alltrim(BA1->BA1_DDD) + Alltrim(BA1->BA1_TELEFO)
		::ret_cartao_virtual:retorno_dados[nI]:matricula				:= Alltrim(BA1->BA1_CODINT + BA1->BA1_CODEMP + BA1->BA1_MATRIC + BA1->BA1_TIPREG + BA1->BA1_DIGITO)
		::ret_cartao_virtual:retorno_dados[nI]:matricula_funcionario	:= BA3->BA3_AGMTFU
		::ret_cartao_virtual:retorno_dados[nI]:matricula_sis_antigo	:= BA1->BA1_MATANT

		::ret_cartao_virtual:retorno_dados[nI]:nome						:= Alltrim(BA1->BA1_NOMUSR)
		::ret_cartao_virtual:retorno_dados[nI]:sexo						:= Alltrim(BA1->BA1_SEXO)
		::ret_cartao_virtual:retorno_dados[nI]:cpf						:= Alltrim(BA1->BA1_CPFUSR)
		::ret_cartao_virtual:retorno_dados[nI]:nascimento				:= BA1->BA1_DATNAS
		::ret_cartao_virtual:retorno_dados[nI]:telefone					:= cTelefone
		::ret_cartao_virtual:retorno_dados[nI]:celular					:= cTelefone
		::ret_cartao_virtual:retorno_dados[nI]:email					:= Alltrim(BA1->BA1_EMAIL)
		::ret_cartao_virtual:retorno_dados[nI]:dependencia_id			:= Alltrim(BA1->BA1_TIPREG)
		::ret_cartao_virtual:retorno_dados[nI]:inclusao					:= BA1->BA1_DATINC
		::ret_cartao_virtual:retorno_dados[nI]:empresa_id				:= Alltrim(cCodEmp)

		If BG9->BG9_TIPO == '1' // Pessoa Física
			::ret_cartao_virtual:retorno_dados[nI]:tipo_pessoa_contratante	:= "FISICA"
			::ret_cartao_virtual:retorno_dados[nI]:empresa_nome		:= cNomTit
		Else
			::ret_cartao_virtual:retorno_dados[nI]:tipo_pessoa_contratante	:= "JURIDICA"
			::ret_cartao_virtual:retorno_dados[nI]:empresa_nome			:= BQC->BQC_NREDUZ
		Endif
		::ret_cartao_virtual:retorno_dados[nI]:numero_contrato			:= Alltrim(BA3->BA3_NUMCON)

		// Endereço
		If !Empty(BA1->BA1_ENDERE)
			::ret_cartao_virtual:retorno_dados[nI]:endereco				:= Alltrim(BA1->BA1_ENDERE)
			::ret_cartao_virtual:retorno_dados[nI]:numero				:= Alltrim(BA1->BA1_NR_END)
			::ret_cartao_virtual:retorno_dados[nI]:complemento			:= Alltrim(BA1->BA1_COMEND)
			::ret_cartao_virtual:retorno_dados[nI]:bairro				:= Alltrim(BA1->BA1_BAIRRO)
			::ret_cartao_virtual:retorno_dados[nI]:cidade				:= Alltrim(BA1->BA1_MUNICI)
			::ret_cartao_virtual:retorno_dados[nI]:estado				:= Alltrim(BA1->BA1_ESTADO)
			::ret_cartao_virtual:retorno_dados[nI]:cep					:= Alltrim(BA1->BA1_CEPUSR)

		Else
			::ret_cartao_virtual:retorno_dados[nI]:endereco				:= Alltrim(aEndTitular[1])
			::ret_cartao_virtual:retorno_dados[nI]:numero				:= Alltrim(aEndTitular[2])
			::ret_cartao_virtual:retorno_dados[nI]:complemento			:= Alltrim(aEndTitular[3])
			::ret_cartao_virtual:retorno_dados[nI]:bairro				:= Alltrim(aEndTitular[4])
			::ret_cartao_virtual:retorno_dados[nI]:cidade				:= Alltrim(aEndTitular[5])
			::ret_cartao_virtual:retorno_dados[nI]:estado				:= Alltrim(aEndTitular[6])
			::ret_cartao_virtual:retorno_dados[nI]:cep					:= Alltrim(aEndTitular[7])
		Endif

		// Dados do plano
		If !Empty(cCodPla)
			::ret_cartao_virtual:retorno_dados[nI]:convenio_id						:= Alltrim(cCodPla)+Alltrim(cVerPla)
			::ret_cartao_virtual:retorno_dados[nI]:convenio_descricao				:= Alltrim(cDesPla)
			::ret_cartao_virtual:retorno_dados[nI]:convenio_versao					:= Alltrim(cVerPla)

			::ret_cartao_virtual:retorno_dados[nI]:convenio_abrangencia				:= Alltrim(Posicione("BF7",1,xFilial("BF7")+BI3->BI3_ABRANG,"BF7_DESORI"))
			::ret_cartao_virtual:retorno_dados[nI]:convenio_acomodacao				:= Alltrim(Posicione("BI4",1,xFilial("BI4")+BI3->BI3_CODACO,"BI4_DESCRI"))
			::ret_cartao_virtual:retorno_dados[nI]:convenio_segmentacao				:= alltrim(Posicione("BI6",1,xFilial("BI6")+BI3->BI3_CODSEG,"BI6_DESCRI"))
			::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_contrato			:= Alltrim(Posicione("BII",1,xFilial("BII")+BI3->BI3_TIPCON,"BII_DESCRI"))
			::ret_cartao_virtual:retorno_dados[nI]:convenio_padrao_conforto		:= Alltrim(Posicione("BN5",1,xFilial("BN5")+BI3->BI3_PADSAU,"BN5_DESCRI"))
			::ret_cartao_virtual:retorno_dados[nI]:convenio_modalidade_cobranca	:= Alltrim(PLSTXTSX3("BI3_MODPAG", BI3->BI3_MODPAG))
			::ret_cartao_virtual:retorno_dados[nI]:convenio_participativo			:= Alltrim(PLSTXTSX3("BI3_CPFM", BI3->BI3_CPFM))
			::ret_cartao_virtual:retorno_dados[nI]:convenio_regulamentacao			:= Alltrim(PLSTXTSX3("BI3_APOSRG", BI3->BI3_APOSRG))
			::ret_cartao_virtual:retorno_dados[nI]:convenio_ANS						:= BI3->BI3_SUSEP

			// Opcional
			If lMSCVOPC
				cOpcional := Execblock("MSCVOPC", .F., .F., {cCodPla,cVerPla})
				If ValType(cOpcional) == "C" .and. !Empty(cOpcional)
					::ret_cartao_virtual:retorno_dados[nI]:convenio_opcional	:= cOpcional
				Else
					::ret_cartao_virtual:retorno_dados[nI]:convenio_opcional	:= ""
				Endif
			Else
				::ret_cartao_virtual:retorno_dados[nI]:convenio_opcional		:= ""
			Endif

			// Dados sobre o tipo de rede
			If lMSCVREDE
				aRetRede := Execblock("MSCVREDE", .F., .F., {cCodPla,cVerPla})
				If ValType(aRetRede) == "A" .and. Len(aRetRede) > 0
					::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_rede_id				:= aRetRede[1]
					::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_rede_descricao		:= aRetRede[2]

				Else
					::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_rede_id				:= ""
					::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_rede_descricao		:= ""

				Endif
			Else
				::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_rede_id				:= ""
				::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_rede_descricao		:= ""
			Endif

			// Cartão de identificação: carencias
			aCarencias := {}

			// Carencias padrões
			aAux := PLSLISMSGC(BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO),PlsIntPad()+cCodPla,cVerPla,BA1->BA1_DATCAR,BA1->BA1_SEXO,"1")
			For nCnt := 1 To Len(aAux)
				Aadd(aCarencias, {aAux[nCnt][2],;
					Iif(aAux[nCnt][3]<dDataBase,; // Carencia cumprida ?
					"Cumprida",;
					dToc(aAux[nCnt][3]))})
			Next

			If ValType(aCarencias) == "A" .and. Len(aCarencias) > 0
				::ret_cartao_virtual:retorno_dados[nI]:convenio_carencias := {}

				For nCnt := 1 to len(aCarencias)
					Aadd(::ret_cartao_virtual:retorno_dados[nI]:convenio_carencias,WsClassNew( "carencias"))

					::ret_cartao_virtual:retorno_dados[nI]:convenio_carencias[nCnt]:tipo_servico	:= aCarencias[nCnt][1]
					::ret_cartao_virtual:retorno_dados[nI]:convenio_carencias[nCnt]:carencia	  	:= aCarencias[nCnt][2]
				Next
			Endif

		Else
			::ret_cartao_virtual:retorno_dados[nI]:convenio_id							:= ""
			::ret_cartao_virtual:retorno_dados[nI]:convenio_descricao					:= ""
			::ret_cartao_virtual:retorno_dados[nI]:convenio_versao						:= ""
			::ret_cartao_virtual:retorno_dados[nI]:convenio_abrangencia				:= ""
			::ret_cartao_virtual:retorno_dados[nI]:convenio_acomodacao				:= ""
			::ret_cartao_virtual:retorno_dados[nI]:convenio_segmentacao				:= ""
			::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_contrato				:= ""
			::ret_cartao_virtual:retorno_dados[nI]:convenio_padrao_conforto			:= ""
			::ret_cartao_virtual:retorno_dados[nI]:convenio_modalidade_cobranca		:= ""
			::ret_cartao_virtual:retorno_dados[nI]:convenio_participativo				:= ""
			::ret_cartao_virtual:retorno_dados[nI]:convenio_permite_reembolso		:= ""
		Endif

		// Cartão de identificação: inicializa o array de layout de cartões
		::ret_cartao_virtual:retorno_dados[nI]:layout_cartoes := {}

		If lMSLOGFIM
			oObjBackup := Execblock("MSLOGFIM", .F., .F., {::ret_cartao_virtual,nI,cMatTit,lExistTitular})
			If ValType(oObjBackup) == "O"
				::ret_cartao_virtual := oObjBackup
			Endif
		Endif

	Next

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    GetLieCon  ³Autor ³ Leandro de Faria     ³ Data ³07.10.2016 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna o texto para exibição do li e concordo   		   		±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetLieCon WSRECEIVE UserCode WSSEND RetLieCon WSSERVICE PLSXFUN
	Local lRetorno 	:= .T.
	Local cCodInt	:= PlsIntPad()
	Local aAreas 	:= BA0->(getArea())
	Local nLines    := 0
	Local nI		:= 0

	if PrtChkUser( ::UserCode, "PLSXFUN", "GetLieCon" )

		if BA0->(FieldPos("BA0_LIECON") ) > 0

			//Localiza a operadora padrão
			BA0->(dbSetOrder(1))
			If BA0->(dbSeek(xFilial("BA0")+cCodInt))

				nLines := MLCount( BA0->BA0_LIECON )

				for nI := 1 to nLines

					if ! empty(memoLine(BA0->BA0_LIECON,,nI))

						::RetLieCon:cLieCon += alltrim(strTran(strTran(memoLine(BA0->BA0_LIECON,,nI), chr(10), ""), chr(13),"")) + " "

					endIf

				Next nI

			else
				::RetLieCon:cLieCon := ""
			endIf

			BA0->( restArea(aAreas) )

		else
			::RetLieCon:cLieCon := ""
		endIf

	else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf

Return (lRetorno)

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} RetItercamb
WS que retorna se é um usuário de intercambio

@author		Lucas Nonato
@since		14/09/2016
@version	P11

/*/
//---------------------------------------------------------------------------------------

wsMethod RetItercamb wsReceive UserCode, UserCardNumber wsSend WSNULL wsService PLSXFUN
	Local lRet 	:= .T.

	BA1->( DbSetOrder(2) ) //BA1_FILIAL + BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO

	If prtChkUser( ::UserCode ,"PLSXFUN","RetItercamb" )
		//Caso a empresa do beneficiario for igual a empresa de intercambio retorna true
		If SubStr(::UserCardNumber,5,4) == GetNewPar("MV_PLSGEIN",'')
			::WSNULL := "true|"
		Else
			::WSNULL := ""
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} RetDadBen
WS que retorna os dados do usuário

@author		Lucas Nonato
@since		07/12/2016
@version	P11

/*/
//---------------------------------------------------------------------------------------
wsMethod RetDadBen wsReceive UserCode,Matric wsSend dados_benef wsService PLSXFUN
	local lRet 	:= .T.
	local aRet	:= {}

	if( prtChkUser( ::UserCode,"PLSXFUN","RetItercamb" ) )
		aRet := PLSA271( ::Matric )

		if( len( aRet ) > 0 )
			::dados_benef := wsClassNew( "st_dados_benef" )
			::dados_benef:CNOMEUSUARI		:= aRet[ 1 ][ 01 ]
			::dados_benef:CMATRICULA		:= aRet[ 1 ][ 02 ]
			::dados_benef:DDTNACTO			:= aRet[ 1 ][ 03 ]
			::dados_benef:CCNESUSU			:= aRet[ 1 ][ 04 ]
			::dados_benef:CSUSEP			:= aRet[ 1 ][ 05 ]
			::dados_benef:CSEGASSPL			:= aRet[ 1 ][ 06 ]
			::dados_benef:CNUMREGOPE		:= aRet[ 1 ][ 07 ]
			::dados_benef:CCONTATOOPE		:= aRet[ 1 ][ 08 ]
			::dados_benef:CCONTATOANS		:= aRet[ 1 ][ 09 ]
			::dados_benef:DCPT				:= aRet[ 1 ][ 10 ]
			::dados_benef:CTPACOMODA		:= aRet[ 1 ][ 11 ]
			::dados_benef:CCONTRATACA		:= aRet[ 1 ][ 12 ]
			::dados_benef:CABRANG			:= aRet[ 1 ][ 13 ]
			::dados_benef:CNOMPRO			:= aRet[ 1 ][ 14 ]
			::dados_benef:CNFANTAZOPE		:= aRet[ 1 ][ 15 ]
			::dados_benef:CNFAADMBENE		:= aRet[ 1 ][ 16 ]
			::dados_benef:CRZSOCIAL			:= aRet[ 1 ][ 17 ]
			::dados_benef:DDTVIGPL			:= aRet[ 1 ][ 18 ]
			::dados_benef:CNUMCON			:= aRet[ 1 ][ 19 ]
			::dados_benef:DDATCON			:= aRet[ 1 ][ 20 ]
			::dados_benef:DDTMAXCON			:= aRet[ 1 ][ 21 ]
			::dados_benef:CINFOPLAN			:= aRet[ 1 ][ 22 ]
			::dados_benef:CINFORMACOE		:= aRet[ 1 ][ 23 ]
			::dados_benef:CCARENCAMB		:= aRet[ 1 ][ 24 ]
			::dados_benef:CCARENCHOS		:= aRet[ 1 ][ 25 ]
			::dados_benef:CCARENCPAT		:= aRet[ 1 ][ 26 ]
			::dados_benef:CCARENCODO		:= aRet[ 1 ][ 27 ]
		endIf
	endIf
return lRet
//---------------------------------------------------------------------------------------
/*/{Protheus.doc} HabBotao
WS Verifica se foi anexado uma receita no Uso constante

@author	Robson Nayland
@since		22/02/2017
@version	P12

/*/
//---------------------------------------------------------------------------------------

wsMethod HabBotao wsReceive UserCode,cRecno,Chave wsSend WSNULL wsService PLSXFUN
	Local lRet 	:= .T.


	If prtChkUser( ::UserCode ,"PLSXFUN","HabBotao" )

		B4F->( DbSetOrder(1) )
		AC9->( DbSetOrder(2) )

		If AC9->(MsSeek(xFilial("AC9")+"B4F"+xFilial("B4F")+xFilial("B4F")+Chave))
			::WSNULL := "true|"
		Else
			::WSNULL := "false"

		EndIf
	EndIf

Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getLancam³Autor  ³ Alexander Santos      ³ Data ³18.05.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina Lista de Lançamentos	                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getLancam WSRECEIVE UserCode WSSEND DadosLanc WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL nI		:= 1
	LOCAL lRet 		:= .T.

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se tem direito para executar o metodo								   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode , "PLSXFUN", "getLancam" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona no lançamento									   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BFQ->(dbGoTop())

		While !BFQ->(EOF())

			If BFQ->BFQ_EXTFIN == "1"

				AaDd( ::DadosLanc, WsClassNew( "STipGui" ))
				::DadosLanc[nI]:Cod    := BFQ->(BFQ_PROPRI+BFQ_CODLAN)
				::DadosLanc[nI]:Descri := BFQ->BFQ_DESCRI
				nI++
			EndIf

			BFQ->(DbSkip())
		EndDo
	Else
		lRet := .F.
		SetSoapFault( "", "Usuário não autorizado" )
	EndIf

	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim do metodo														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} VldItReemb
Valida itens negados para reembolso

@author Francisco Edcarlo
@since 03/2017
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD VldItReemb WSRECEIVE UserCode, CodSol WSSEND WSNULL WSSERVICE PLSXFUN
	local lRetorno := .T.
	local cCodSol := ::CodSol
	::WSNULL := "true|"

	If PrtChkUser( ::UserCode, "PLSXFUN", "VldItReemb" )
		if cCodSol != "ZZZZX"

			If BCT->(FieldPos("BCT_VALREE")) > 0

				//verifica se existem itens negados e deleta do banco de dados.
				aDadRet := PLDELITEM(cCodSol)

				//Se na primeir posição retornar true, significa que existe pelo menos um item aprovado no protocolo.
				If aDadRet[1]

					//se na segunda posição retornar false significa que não existem itens negados.
					If aDadRet[2]
						//se na segunda posição retornar true significa existem itens negados e aprovados no protocolo.
						::WSNULL := "true|<b>Os itens negados não serão gravados ou contabilizados no protocolo!</b>"
						::WSNULL += "|false"
					EndIf
				Else
					//se na primeira posição retornar false significa que todos os itens foram negados.
					::WSNULL := "true|Solicitação não concluída pois todos os itens foram negados!|false"
				EndIf
			Else

				::WSNULL := "true|"
			EndIf
		Else
			::WSNULL := "false|"
		EndIf
	else
		lRetorno := .F.
		::WSNULL := "false|"
		setSoapFault("", "Não autorizado a utilização do método" )
	EndIF

Return lRetorno

//-------------------------------------------------------------------
/*/{Protheus.doc} getFamBloq

Traz beneficiarios da familia para realizacao do bloqueio
@author  Renan Sakai
@version P11
@since   28/03/17
/*/
//-------------------------------------------------------------------
WSMETHOD getFamBloq WSRECEIVE UserCode, cUsrLogin WSSEND ListFamBloq WSSERVICE PLSXFUN
	LOCAL nI        := 1
	LOCAL aArea	    := GetArea()
	LOCAL lRetorno  := .T.
	LOCAL lOpen     := .F.
	LOCAL cSQL
	LOCAL cCodFam
	LOCAL cTitular  := GetNewPar("MV_PLCDTIT","T")
	Local oMulta := Nil
	Local nVlrMulta := 0
	Local oDetMulta
	Local nPosBenef := 0
	Local cBenefTit := ""
	Local cRetBA3 := ""
	Local aPesqBA3 := {}
	Local cFil := ""
	Local nFor:= ""
	Local nTam := 0
	Local lRet := ""

	// Checa Usuario
	If PrtChkUser( ::UserCode, "PLSXFUN", "getFamBloq" )

		// Retorna a matricula do beneficiario que esta cadastrado para o login
		cSQL := " SELECT B49_BENEFI "
		cSQL += " FROM " + RetSQLName("B49")
		cSQL += " WHERE B49_CODUSR = '" + cUsrLogin + "' AND "
		cSQL += " D_E_L_E_T_ = ' ' "
		cSql := ChangeQuery(cSql)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TrbRetTit",.T.,.F.) //PLSQuery(cSQL,"TrbRetTit")

		If !TrbRetTit->(EOF())

			cCodFam := SUBSTR(TrbRetTit->B49_BENEFI,1,14)
			::ListFamBloq  := {}

			If FindClass("PLBenefMulta")  
				oMulta := PLBenefMulta():New()

				If oMulta:SetFamilia(cCodFam)
					nVlrMulta := oMulta:Calcular()

					If nVlrMulta > 0
						oDetMulta := oMulta:GetDetalhe()
					EndIf
				EndIf
			EndIf

			BA1->(DbSetOrder(2))

			If BA1->(MsSeek(xFilial("BA1")+TrbRetTit->B49_BENEFI)) .And. BA1->BA1_TIPUSU != cTitular

            	if PLIsFamHldAct(substr(TrbRetTit->B49_BENEFI, 1, 4), substr(TrbRetTit->B49_BENEFI, 5, 4), substr(TrbRetTit->B49_BENEFI, 9, 6))
		    		lRet := .F.
		    	else
		    	    BA3->(DbSetOrder(1))
		    	    if BA3->(msSeek(xFilial("BA3")+substr(TrbRetTit->B49_BENEFI, 1, 14))) .and. !empty(BA3->BA3_GRPFAM)
		    		    if PLIsFamHldAct(substr(BA3->BA3_GRPFAM, 1, 4), substr(BA3->BA3_GRPFAM, 5, 4), substr(BA3->BA3_GRPFAM, 9, 6))
		    				lRet := .F.
		    		    endif
            	    endif
		    	endif
				
				If lRet .And. BA1->BA1_RESFAM = '1'
					AaDd( ::ListFamBloq,wsClassNew("FamBloqList") )
					nI := 1

					If nVlrMulta > 0
						nPosBenef := aScan(oDetMulta["beneficiarios"], {|x| x["idMatricula"] == BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO) })
					EndIf

					::ListFamBloq[nI]:Recno     := BA1->(Recno())
					::ListFamBloq[nI]:Matricula := Transform(BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO), "@R !!!!.!!!!.!!!!!!-!!-!")
					::ListFamBloq[nI]:Nome      := Alltrim(BA1->BA1_NOMUSR)
					::ListFamBloq[nI]:CPF       := Transform(BA1->BA1_CPFUSR, "@R 999.999.999-99")
					::ListFamBloq[nI]:DataNasc  := BA1->BA1_DATNAS
					::ListFamBloq[nI]:DataInc   := BA1->BA1_DATINC
					::ListFamBloq[nI]:TipoBenef := IIf(BA1->BA1_TIPUSU == cTitular,"TITULAR","DEPENDENTE")
					::ListFamBloq[nI]:DataBloq	 := BA1->BA1_DATBLO
					::ListFamBloq[nI]:PrazoFidel := IIF(nVlrMulta > 0, STR(oDetMulta["fidelidade"]["quantidadeMeses"]) + " meses", "")
					::ListFamBloq[nI]:DataFimFid := IIF(nVlrMulta > 0, STOD(oDetMulta["fidelidade"]["dataFinal"]), CToD(" / / "))
					::ListFamBloq[nI]:ValorMulta := IIF(nVlrMulta > 0 .And. nPosBenef > 0, Alltrim(Transform(oDetMulta["beneficiarios"][nPosBenef]["valorMulta"], "@E 9,999,999,999,999.99")), "")
					::ListFamBloq[nI]:HtmlMulta  := IIF(nVlrMulta > 0, oMulta:GetHtmlMulta(.F.), "")

					lOpen := .F.
					B5K->(DbSetOrder(2))
					If B5K->(MsSeek(xFilial("B5K")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)))
						While B5K->(B5K_FILIAL+B5K_MATUSU) == xFilial("B5K")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO) .And. !B5K->(Eof())
							B5J->(DbSetOrder(1))
							If B5J->(MsSeek(xFilial("B5J")+B5K->B5K_CODIGO)) .And. B5J->B5J_STATUS == "0"
								lOpen := .T.
								Exit
							EndIf
							B5K->(DbSkip())
						EndDo
					EndIf
					::ListFamBloq[nI]:SolicAbert := IIf(lOpen,"Sim","Não")
				EndIf
			Else
				// Retorna os beneficiarios da familia
				If BA1->(MsSeek(xFilial("BA1")+cCodFam))
					While BA1->(BA1_FILIAL+BA1_CODINT+BA1_CODEMP+BA1_MATRIC) == xFilial("BA1")+cCodFam .And. !BA1->(Eof())

						If nVlrMulta > 0
							nPosBenef := aScan(oDetMulta["beneficiarios"], {|x| x["idMatricula"] == BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO) })
						EndIf

						If BA1->BA1_TIPUSU == cTitular
							cBenefTit := BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)
						EndIf

						AaDd( ::ListFamBloq,wsClassNew("FamBloqList") )
						::ListFamBloq[nI]:Recno     := BA1->(Recno())
						::ListFamBloq[nI]:Matricula := Transform(BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO), "@R !!!!.!!!!.!!!!!!-!!-!")
						::ListFamBloq[nI]:Nome      := Alltrim(BA1->BA1_NOMUSR)
						::ListFamBloq[nI]:CPF       := Transform(BA1->BA1_CPFUSR, "@R 999.999.999-99")
						::ListFamBloq[nI]:DataNasc  := BA1->BA1_DATNAS
						::ListFamBloq[nI]:DataInc   := BA1->BA1_DATINC
						::ListFamBloq[nI]:TipoBenef := IIf(BA1->BA1_TIPUSU == cTitular,"TITULAR","DEPENDENTE")
						::ListFamBloq[nI]:DataBloq	 := BA1->BA1_DATBLO
						::ListFamBloq[nI]:PrazoFidel := IIF(nVlrMulta > 0, STR(oDetMulta["fidelidade"]["quantidadeMeses"]) + " meses", "")
						::ListFamBloq[nI]:DataFimFid := IIF(nVlrMulta > 0, STOD(oDetMulta["fidelidade"]["dataFinal"]), CToD(" / / "))
						::ListFamBloq[nI]:ValorMulta := IIF(nVlrMulta > 0 .And. nPosBenef > 0, Alltrim(Transform(oDetMulta["beneficiarios"][nPosBenef]["valorMulta"], "@E 9,999,999,999,999.99")), "")
						::ListFamBloq[nI]:HtmlMulta := IIF(nVlrMulta > 0, oMulta:GetHtmlMulta(.F.), "")

						lOpen := .F.
						B5K->(DbSetOrder(2))
						If B5K->(MsSeek(xFilial("B5K")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)))
							While B5K->(B5K_FILIAL+B5K_MATUSU) == xFilial("B5K")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO) .And. !B5K->(Eof())
								B5J->(DbSetOrder(1))
								If B5J->(MsSeek(xFilial("B5J")+B5K->B5K_CODIGO)) .And. B5J->B5J_STATUS == "0"
									lOpen := .T.
									Exit
								EndIf
								B5K->(DbSkip())
							EndDo
						EndIf
						::ListFamBloq[nI]:SolicAbert := IIf(lOpen,"Sim","Não")
						BA1->(DbSkip())
						nI++
					EndDo
				EndIf

				cRetBA3 := BA3->(RetSQLName("BA3"))

				cFil := "SELECT BA3_CODINT, BA3_CODEMP, BA3_MATRIC FROM " + cRetBA3 
				cFil +=  " WHERE BA3_GRPFAM = '" + cBenefTit + "' AND D_E_L_E_T_ = ' '"

				dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cFil),"TrbPes",.F.,.T.)

				TrbPes->(DbGoTop())
				While ! TrbPes->(Eof())

					aAdd(aPesqBA3, {TrbPes->BA3_CODINT, TrbPes->BA3_CODEMP, TrbPes->BA3_MATRIC})

					TrbPes->(DbSkip())
				Enddo
 				TrbPes->(DbCloseArea())

				For nFor := 1 To Len(aPesqBA3)
	 				BA1->(DbSetOrder(2))
					If BA1->(MsSeek(xFilial("BA1")+ aPesqBA3[nFor, 1] + aPesqBA3[nFor, 2]+ aPesqBA3[nFor, 3]))
				
						AaDd( ::ListFamBloq,wsClassNew("FamBloqList") )
						nTam := Len(self:ListFamBloq)
						::ListFamBloq[nTam]:Recno     := BA1->(Recno())
						::ListFamBloq[nTam]:Matricula := Transform(BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO), "@R !!!!.!!!!.!!!!!!-!!-!")
						::ListFamBloq[nTam]:Nome      := Alltrim(BA1->BA1_NOMUSR)
						::ListFamBloq[nTam]:CPF       := Transform(BA1->BA1_CPFUSR, "@R 999.999.999-99")
						::ListFamBloq[nTam]:DataNasc  := BA1->BA1_DATNAS
						::ListFamBloq[nTam]:DataInc   := BA1->BA1_DATINC
						::ListFamBloq[nTam]:TipoBenef := IIf(BA1->BA1_TIPUSU == cTitular,"TITULAR","DEPENDENTE")
						::ListFamBloq[nTam]:DataBloq	 := BA1->BA1_DATBLO
						::ListFamBloq[nTam]:PrazoFidel := IIF(nVlrMulta > 0, STR(oDetMulta["fidelidade"]["quantidadeMeses"]) + " meses", "")
						::ListFamBloq[nTam]:DataFimFid := IIF(nVlrMulta > 0, STOD(oDetMulta["fidelidade"]["dataFinal"]), CToD(" / / "))
						::ListFamBloq[nTam]:ValorMulta := IIF(nVlrMulta > 0 .And. nPosBenef > 0, Alltrim(Transform(oDetMulta["beneficiarios"][nPosBenef]["valorMulta"], "@E 9,999,999,999,999.99")), "")
						::ListFamBloq[nTam]:HtmlMulta  := IIF(nVlrMulta > 0, oMulta:GetHtmlMulta(.F.), "")
						::ListFamBloq[nTam]:SolicAbert := "Não"
					Endif
				Next
			EndIf

		EndIf
		TrbRetTit->(dbCloseArea())
	
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} procSolicBloq

Traz beneficiarios da familia para realizacao do bloqueio
@author  Renan Sakai
@version P11
@since   28/03/17
/*/
//-------------------------------------------------------------------
WSMETHOD procSolicBloq WSRECEIVE UserCode, cUsrLogin, cRecno WSSEND NumProtoc WSSERVICE PLSXFUN
	LOCAL lRetorno  := .T.
	LOCAL aRecnos   := StrTokArr(cRecno,",")
	LOCAL nX        := 0

	//Monta arrau com os recnos dos beneficiarios que serao cancelados
	For nX := 1 to len(aRecnos)
		aRecnos[nX] := Val(StrTran(aRecnos[nX],"'",""))
	Next

	// Checa Usuario
	If PrtChkUser( ::UserCode, "PLSXFUN", "procSolicBloq" )
		// Retorna a matricula do beneficiario que esta cadastrado para o login
		cSQL := " SELECT B49_BENEFI "
		cSQL += " FROM " + RetSQLName("B49")
		cSQL += " WHERE B49_CODUSR = '" + cUsrLogin + "' AND "
		cSQL += " D_E_L_E_T_ = ' ' "
		cSql := ChangeQuery(cSql)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TrbRetTit",.T.,.F.) //PLSQuery(cSQL,"TrbRetTit")

		If !TrbRetTit->(EOF())
			::NumProtoc := PL99BGRVRP(TrbRetTit->B49_BENEFI,aRecnos)
		EndIf

		TrbRetTit->(dbCloseArea())

	EndIf

Return lRetorno

//-------------------------------------------------------------------
/*/{Protheus.doc} getSolCanPla

Traz informacoes de uma solicitacao de cancelamento de plano ja realizada
@author  Renan Sakai
@version P11
@since   28/03/17
/*/
//-------------------------------------------------------------------
WSMETHOD getSolCanPla WSRECEIVE UserCode, cUsrLogin, cRecno WSSEND ListSolicCanPla WSSERVICE PLSXFUN
	LOCAL cStatus   := ""
	LOCAL nI        := 1
	LOCAL aArea	    := GetArea()
	LOCAL lRetorno  := .T.
	LOCAL cSQL
	LOCAL cOrigem   := ""

	// Checa Usuario
	If PrtChkUser( ::UserCode, "PLSXFUN", "getSolCanPla" )


		// Retorna a matricula do beneficiario que esta cadastrado para o login
		cSQL := " SELECT B49_BENEFI "
		cSQL += " FROM " + RetSQLName("B49")
		cSQL += " WHERE B49_CODUSR = '" + cUsrLogin + "' AND "
		cSQL += " D_E_L_E_T_ = ' ' "
		cSql := ChangeQuery(cSql)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TrbRetTit",.T.,.F.) //PLSQuery(cSQL,"TrbRetTit")

		If !TrbRetTit->(EOF())

			::ListSolicCanPla  := {}

			//Se matricula informada, carrego todos os protocolos do beneficiario
			If cRecno <> "0"
				BA1->(DbGoTo(Val(cRecno)))
				B5K->(DbSetOrder(2))
				B5J->(DbSetOrder(1))
				If B5K->(MsSeek(xFilial("B5K")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)))

					While B5K->(B5K_FILIAL+B5K_MATUSU) == xFilial("B5K")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO) .And. !B5K->(Eof())

						If B5J->(MsSeek(xFilial("B5J")+B5K->B5K_CODIGO))
							Do Case
								Case B5J->B5J_STATUS ==  "0"
									cStatus := "Pendente"
								Case B5J->B5J_STATUS == "1"
									cStatus := "Bloqueio Efetuado"
								Case B5J->B5J_STATUS == "2"
									cStatus := "Confim.Emitida"
							EndCase

							Do Case
								Case B5J->B5J_ORISOL ==  "1"
									cOrigem := "Presencial"
								Case B5J->B5J_ORISOL == "2"
									cOrigem := "Call-Center"
								Case B5J->B5J_ORISOL == "3"
									cOrigem := "Portal Web"
							EndCase

							AaDd( ::ListSolicCanPla,wsClassNew("SolicCanPlaList") )
							::ListSolicCanPla[nI]:Recno     := B5J->(Recno())
							::ListSolicCanPla[nI]:Protocolo := B5J->B5J_PROTOC
							::ListSolicCanPla[nI]:DataSolic := B5J->B5J_DATSOL
							::ListSolicCanPla[nI]:DataBloq  := B5J->B5J_DATBLO
							::ListSolicCanPla[nI]:Status    := cStatus
							::ListSolicCanPla[nI]:Origem    := cOrigem
							B5J->(DbSkip())
							nI++
						EndIf
						B5K->(DbSkip())
					EndDo
				EndIf

			Else
				B5J->(DbSetOrder(3))
				If B5J->(MsSeek(xFilial("B5J")+TrbRetTit->B49_BENEFI))
					While B5J->(B5J_FILIAL+B5J_MATSOL) == xFilial("B5J")+TrbRetTit->B49_BENEFI .And. !B5J->(Eof())
						Do Case
							Case B5J->B5J_STATUS ==  "0"
								cStatus := "Pendente"
							Case B5J->B5J_STATUS == "1"
								cStatus := "Bloqueio Efetuado"
							Case B5J->B5J_STATUS == "2"
								cStatus := "Confim.Emitida"
						EndCase

						Do Case
							Case B5J->B5J_ORISOL ==  "1"
								cOrigem := "Presencial"
							Case B5J->B5J_ORISOL == "2"
								cOrigem := "Call-Center"
							Case B5J->B5J_ORISOL == "3"
								cOrigem := "Portal Web"
						EndCase

						AaDd( ::ListSolicCanPla,wsClassNew("SolicCanPlaList") )
						::ListSolicCanPla[nI]:Recno     := B5J->(Recno())
						::ListSolicCanPla[nI]:Protocolo := B5J->B5J_PROTOC
						::ListSolicCanPla[nI]:DataSolic := B5J->B5J_DATSOL
						::ListSolicCanPla[nI]:DataBloq  := B5J->B5J_DATBLO
						::ListSolicCanPla[nI]:Status    := cStatus
						::ListSolicCanPla[nI]:Origem    := cOrigem
						B5J->(DbSkip())
						nI++
					EndDo
				EndIf
			EndIf
		EndIf
		TrbRetTit->(dbCloseArea())

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno


/*/{Protheus.doc} RetCriTXT
Retorna as críticas em base 64
@author Renan Martins
@since 06/2017
/*/
wsMethod RetCriTXT wsReceive UserCode, Busca wsSend WSNULL wsService PLSXFUN
	Local lRet	:= .T.

	If prtChkUser( ::UserCode ,"PLSXFUN","RetCriTXT" )
		::WSNULL := "true|"+PLSRCRIT(::Busca, "", .T.)
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRet

/*/{Protheus.doc} DupGui
Verifica se a guia prestes a ser digitada pode estar sendo duplicada
@author victor.silva
@since 22/06/2017
@version P12
/*/
WSMETHOD isDupGui WSRECEIVE UserCode, RdaCode, TipGui, NumGuiRef, UserCardNumber, DatGuia WSSEND WSNULL WSSERVICE PLSXFUN
	local cMsg		:= ""
	local lRetorno 	:= .T.
	local lIsDup	:= .F.

	default ::WSNULL 	:= ""

	If PrtChkUser( ::UserCode, "PLSXFUN", "isDupGui" )

		// Busca guias com a mesma chave realizadas no mesmo dia
		lIsDup := RetGuiDup(::TipGui,::DatGuia,@cMsg,::RdaCode,::NumGuiRef,UserCardNumber)

		if lIsDup
			::WSNULL := "true|S|" + cMsg
		else
			::WSNULL := "true|N|--"
		endIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Usuário não autorizado" )
	EndIf

Return lRetorno

/*/{Protheus.doc} RetGuiDup
retorna se tem guia duplicada
@author victor.silva
@since 22/06/2017
@version P12
/*/
Static Function RetGuiDup(cTipGui,cDatGui,cMsg,cCodRda,cGuiSol,cMatUsr)
	local cAliasQry	:= GetNextAlias()
	local lRet 		:= .F.
	local cNumGui	:= ""
	local cCampos	:= ""
	local cSql		:= ""

	default cMsg	:= ""

	//TODO - Tratar Guia de Honorarios
	if cTipGui == "6"
		Return lRet
	endif

	//TODO - Tratar Guia de Resumo de Internação
	If cTipGui == '5'
		return lRet
	endif

	If cTipGui == '3' .and. ValType(cCodRda) == "U"
		return lRet
	endif

	cSql	:= "%"
	do case
		case cTipGui $ "1/2/4/13"	//GUIA DE CONSULTA/SADT/ODONTO

			cCampos	:= "% BEA_OPEMOV OPEMOV, BEA_ANOAUT ANOAUT, BEA_MESAUT MESAUT, BEA_NUMAUT NUMAUT %"
			cSql	+= RetSqlName("BEA") + " BEA WHERE "
			cSql	+= "BEA_FILIAL = '" + xFilial("BEA") + "' AND "
			cSql	+= "BEA_OPEUSR = '" + SubStr(cMatUsr,1,4) + "' AND "
			cSql	+= "BEA_CODEMP = '" + SubStr(cMatUsr,5,4) + "' AND "
			cSql	+= "BEA_MATRIC = '" + SubStr(cMatUsr,9,6) + "' AND "
			cSql	+= "BEA_TIPREG = '" + SubStr(cMatUsr,15,2) + "' AND "
			cSql	+= "BEA_DATPRO = '" + cDatGui + "' AND "
			cSql	+= "BEA_CODRDA = '" + cCodRda + "' AND "
			If cTipGui == '13'
				cSql	+= "BEA_TIPGUI = '" + cTipGui + "' AND "
			Else
				cSql	+= "BEA_TIPGUI = '" + ("0" + cTipGui) + "' AND "
			EndIf

			cSql	+= "BEA.D_E_L_E_T_ = ' '"

		case cTipGui == "3"		//GUIA DE SOL. INTERNACAO

			cCampos	:= "% BE4_CODOPE OPEMOV, BE4_ANOINT ANOAUT, BE4_MESINT MESAUT, BE4_NUMINT NUMAUT %"
			cSql	+= RetSqlName("BE4") + " BE4 WHERE "
			cSql	+= "BE4_FILIAL = '" + xFilial("BE4") + "' AND "
			cSql	+= "BE4_OPEUSR = '" + SubStr(cMatUsr,1,4) + "' AND "
			cSql	+= "BE4_CODEMP = '" + SubStr(cMatUsr,5,4) + "' AND "
			cSql	+= "BE4_MATRIC = '" + SubStr(cMatUsr,9,6) + "' AND "
			cSql	+= "BE4_TIPREG = '" + SubStr(cMatUsr,15,2) + "' AND "
			cSql	+= "BE4_DATPRO = '" + cDatGui + "' AND "
			cSql	+= "BE4_CODRDA = '" + cCodRda + "' AND "
			cSql	+= "BE4.D_E_L_E_T_ = ' '"

		case cTipGui $ "7/8/9"	//ANEXOS

			cCampos	:= "% B4A_OPEMOV OPEMOV, B4A_ANOAUT ANOAUT, B4A_MESAUT MESAUT, B4A_NUMAUT NUMAUT %"
			cSql	+= RetSqlName("B4A") + " B4A WHERE "
			cSql	+= "B4A_FILIAL = '" + xFilial("BD5") + "' AND "
			cSql	+= "B4A_GUIREF = '" + cGuiSol + "' AND "
			cSql	+= "B4A_TIPGUI = '" + ("0" + cTipGui) + "' AND "
			cSql	+= "B4A_DATSOL = '" + cDatGui + "' AND "
			cSql	+= "B4A.D_E_L_E_T_ = ' '"

		case cTipGui == "11"	//GUIA DE SOL.PRORROGAÇÃO DE INT

			cCampos	:= "% B4Q_OPEMOV OPEMOV, B4Q_ANOAUT ANOAUT, B4Q_MESAUT MESAUT, B4Q_NUMAUT NUMAUT %"
			cSql	+= RetSqlName("B4Q") + " B4Q WHERE "
			cSql	+= "B4Q_FILIAL = '" + xFilial("B4Q") + "' AND "
			cSql	+= "B4Q_GUIREF = '" + cGuiSol + "' AND "
			cSql	+= "B4Q_DATPRO = '" + cDatGui + "' AND "
			cSql	+= "B4Q.D_E_L_E_T_ = ' '"

	endcase

	cSql	+= "%"

	//Realiza a consulta
	BeginSql alias cAliasQry
		SELECT
			%exp:cCampos%
		FROM
			%exp:cSql%
	EndSql

	//Caso ache algum resultado, significa que houve inclusao de guia com os mesmos dados no dia
	if (cAliasQry)->(!Eof())
		lRet 	:= .T.
		cNumGui := Transform(AllTrim((cAliasQry)->(OPEMOV + ANOAUT + MESAUT + NUMAUT)), "@R 9999.9999.99-99999999" )
	endif

	(cAliasQry)->(DbCloseArea())

	// Compoe a mensagem
	if lRet
		cMsg := "Identificamos que recentemente foi realizada "
		if cTipGui $ '7/8/9'
			cMsg += "a inclusão do anexo '"
		else
			cMsg += "a inclusão da guia '"
		endif
		cMsg += cNumGui
		cMsg += "' para o mesmo beneficiário, tem certeza que deseja prosseguir?"
	endif

Return lRet


//--------------------------------------------------------------------
/*/{Protheus.doc} VerGuiInt

Atualiza os status da BD5, BD6 e BD7 para cancelado quando chamada a função do Portal, do módulo de Digitação de Guias Off-Line
@author Renan Martins
@since 03/2017
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD VerGuiInt WSRECEIVE UserCode, NumGuiRef, DatGuia, RDACode WSSEND WsNull WSSERVICE PLSXFUN
	LOCAL aArea 	:= GetArea()
	LOCAL lRet 	:= .T.
	Local cRet		:= ""
	Local cNumGuiTrc
	Local cMatric

	Set Century On
	//³Se tem direito para executar o metodo								   ³
	If PrtChkUser( ::UserCode , "PLSXFUN", "VerGuiInt" )
		cRet := PlsVrIntAl(::NumGuiRef, ::DatGuia, @cNumGuiTrc, @cMatric, ::RDACode)
		If !Empty(cRet)
			::WSNULL := "false|" + cRet
		Else
			::WSNULL:= "true|S|" +  cNumGuiTrc +'|'+ cMatric
		EndIf
	Else
		lRet := .F.
		SetSoapFault( "", "Usuário não autorizado" )
	EndIf

	RestArea( aArea )
Return lRet

/*/{Protheus.doc} RetProSau
Retorna codigo do profissional de saude para internacao
@author TOTVS Team
@since 06/2017
/*/
WSMETHOD RetProSau WSRECEIVE UserCode,CpfCnpj,CodProf WSSEND WSNULL WSSERVICE PLSXFUN
	local lRetorno := .T.

	if( prtChkUser( ::UserCode,"PLSXFUN","RetProSau" ) )
		BB0->( dbSetOrder( 3 ) ) // bb0_filial + bb0_cgc
		if( BB0->( dbSeek( xFilial( "BB0" ) + ::CpfCnpj ) ) )
			::WSNULL := BB0->BB0_CODIGO
		else
			::WSNULL := ::CodProf
		endIf
	else
		lRetorno := .F.
		SetSoapFault( "", "Usuário não autorizado" )
	endif

return lRetorno

/*/{Protheus.doc} RetCriPROT
Protocolo
@author André Dini
@since 07/2017
/*/
wsMethod RetCriPROT wsReceive UserCode, Busca, TipBusca wsSend WSNULL wsService PLSXFUN
	Local lRet	:= .T.
	Local cChave := ""

	If prtChkUser( ::UserCode ,"PLSXFUN","RetCriPROT" )

		If TipBusca == "UpXML"

			cChave := If( valtype(::Busca) <> 'U', plsintpad() + ::Busca , nil )

			::WSNULL := "true|" + PLSRCPRT(cChave, "", .T.,,,,.T., .T.) + "|" + ::Busca

		elseif TipBusca == "UpXMLA"
			cChave := If( valtype(::Busca) <> 'U', plsintpad() + ::Busca , nil )

			::WSNULL := "true|" + PLSRCPRT(cChave, "", .T.,,,,.T., .T.)

		Else

			::WSNULL := "true|" + PLSRCPRT("", "", .T.,::Busca,,,.T.) + "|" + ::Busca

		EndIf


	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRet

/*/{Protheus.doc} RetVldDent
Retorna se existe uma face para determinado dente.
@author andre.dini
@since 04/01/2017
/*/
wsMethod RetVldDent wsReceive UserCode, CodDente, CodPad, CodPro wsSend WSNULL wsService PLSXFUN
	Local lRet 		:= .T.
	LOCAL aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB", .F. ,"87"))
	LOCAL cCodPad := ""
	LOCAL cCodPro := ""

	If prtChkUser( ::UserCode ,"PLSXFUN","RetVldDent" )
		::WSNULL := "true|"

		cCodPad		:= AllTrim(PLSVARVINC('87','BR4',::CodPad))
		cCodPro		:= AllTrim(PLSVARVINC(::CodPad,'BR8', ::CodPro, cCodPad+::CodPro,,aTabDup,@cCodPad))

		// Faz a verificação
		If BYL->( MsSeek( xFilial("BYL")+AllTrim(cCodPad)+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) )+CodDente ) )
			::WSNULL += "1"
		Else
			::WSNULL += "0"
		EndIf
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRet


/*/{Protheus.doc} getCboxGen
Retorna os valores para combo box generico.
@author francisco.edcarlo
@since 21/12/2017
/*/
wsMethod getCboxGen wsReceive UserCode, Alias, Dados, Where, AliAux, IndiceAux, ChaveAux, CampoAux , CodLogin,TpPortal,MatricPrt,ContPrt  wsSend WSNULL wsService PLSXFUN
	Local lRet 		:= .T.
	Local cRet 		:= ""
	Local aDadB40   := {}
	Local cSQL 		:= ""

	If prtChkUser( ::UserCode ,"PLSXFUN","getCboxGen" )
		::WSNULL := "true|"
		If !Empty(CodLogin) .and. Alias $("BT5,BQC,BT6")
			If TpPortal == "2"
				B40->(DbSetORder(1))

				If B40->(MsSeek(xFilial("B40") + CodLogin))

					While !B40->(EOF())	.AND. B40->B40_CODUSR == CodLogin

						aAdd(aDadB40, {"Dados", B40->B40_CODINT+B40->B40_CODEMP+B40->B40_NUMCON+B40->B40_SUBCON })
						B40->(DbSkip())
					EndDo
				EndIf

			ElseIf TpPortal == "3"
				cSQL := " SELECT BA1_CODINT||BA1_CODEMP||BA1_CONEMP||BA1_SUBCON MATRIC"
				cSQL += " FROM "+ RetSQLName("BA1")
				cSQL += " WHERE BA1_FILIAL = '" + xFilial("BA1") + "' "
				cSQL += " AND BA1_CODINT =   '" + SUBSTR(MatricPrt,1,4) + "' "
				cSQL += " AND BA1_CODEMP =   '" +  SUBSTR(ContPrt,5,4) + "' "
				cSQL += " AND BA1_MATRIC =   '" + SUBSTR(MatricPrt,9,6) + "' "
				cSQL += " AND BA1_TIPREG =   '" + SUBSTR(MatricPrt,15,2) + "' "
				cSQL += " AND BA1_DIGITO =   '" + SUBSTR(MatricPrt,17,1) + "' "
				cSQL += " AND BA1_CONEMP =   '" + SUBSTR(ContPrt,9,12) + "' "
				cSQL += " AND BA1_VERCON =   '" + SUBSTR(ContPrt,21,3) + "' "
				cSQL += " AND BA1_SUBCON =   '" + SUBSTR(ContPrt,24,9) + "' "
				cSQL += " AND BA1_VERSUB =   '" + SUBSTR(ContPrt,33,3) + "' "
				cSQL += " AND D_E_L_E_T_ = ' ' "
				cSql := ChangeQuery(cSql)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TRB",.T.,.F.)

				While !TRB->(EOF())
					aAdd(aDadB40, {"Dados", TRB->MATRIC})
					TRB->(DbSkip())
				Enddo
				TRB->( dbCloseArea() )
			EndIF
		EndIF
		cRet := PLSCBOXGEN(::Alias, ::Dados, ::Where, ::AliAux, ::IndiceAux, ::ChaveAux, ::CampoAux, aDadB40)

		// Faz a verificação
		If Empty(cRet)
			::WSNULL := "false|"
		Else
			::WSNULL += cRet
		EndIf
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRet

/*/{Protheus.doc} VldDente
Verifica se o dente informado existe
@author Renan Sakai
@since 20/07/2018
/*/
wsMethod VldDente wsReceive UserCode, CodPad, CodPro, CodDente wsSend WSNULL wsService PLSXFUN
	Local lRet 	  := .T.
	LOCAL aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB", .F. ,"87"))
	LOCAL cCodPad := ""
	LOCAL cCodPro := ""
	LOCAL aRet    := {}

	if prtChkUser( ::UserCode ,"PLSXFUN","VldDente" )
		::WSNULL := "true|"
		cCodPad		:= AllTrim(PLSVARVINC('87','BR4',::CodPad))
		cCodPro		:= AllTrim(PLSVARVINC(::CodPad,'BR8', ::CodPro, cCodPad+::CodPro,,aTabDup,@cCodPad))

		// Faz a verificação
		aRet := P90ODVldDF("D",cCodPad,cCodPro,::CodDente)

		iif(aRet[1],::WSNULL += "1|",::WSNULL += "0|")  //Indica que tem dente parametrizado

		if aRet[1] .And. aRet[2] //Dente informado corretamente
			::WSNULL += "true||"+aRet[3]
		elseIf aRet[1] .And. empty(::CodDente)//Usuario nao digitou o dente
			::WSNULL += "true||"
		elseIf aRet[1] .And. !aRet[2]//O evento tem dente, mas o digitado pelo usuario e invalido
			::WSNULL += "false|Dente informado não foi encontrado.|"
		elseif !aRet[1]
			::WSNULL += "false|O procedimento informado não tem dentes parametrizados.|"
		endIf

	else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf

Return lRet



/*/{Protheus.doc} VldFace
Verifica se a face informada existe
@author Renan Sakai
@since 20/07/2018
/*/
wsMethod VldFace wsReceive UserCode, CodPad, CodPro, CodDente, CodFace wsSend WSNULL wsService PLSXFUN
	Local lRet 	  	:= .T.
	LOCAL aTabDup 	:= PlsBusTerDup(SuperGetMv("MV_TISSCAB", .F. ,"87"))
	LOCAL cCodPad 	:= ""
	LOCAL cCodPro 	:= ""
	LOCAL aRet    	:= {}
	LOCAL aCodFace	:= {}	//guarda codigos das faces digitadas em array para melhor manipulação³¹²³
	LOCAL cCodFace	:= ""	//guarda o conjunto de faces

	if prtChkUser( ::UserCode ,"PLSXFUN","VldFace" )
		::WSNULL := "true|"
		cCodPad		:= AllTrim(PLSVARVINC('87','BR4',::CodPad))
		cCodPro		:= AllTrim(PLSVARVINC(::CodPad,'BR8', ::CodPro, cCodPad+::CodPro,,aTabDup,@cCodPad))
		aCodFace 	:= StrTokArr(::CodFace, ",")	//Distribui no array os digitos separados por vírgula
		ASIZE(aRet,5)

		cCodFace := ArrTokStr(aCodFace)
		aRet := P90ODVldDF("F",cCodPad,cCodPro,::CodDente,cCodFace)	// Faz a verificação em PLSA090OD.PRW

		iif(aRet[1],::WSNULL += "1|",::WSNULL += "0|")  //Indica que tem face parametrizada

		if aRet[1] .And. aRet[2] 	//Dente informado corretamente
			::WSNULL += "true||"+aRet[3]
		elseIf aRet[1] .And. empty(::CodFace)	//Usuario nao digitou a face
			::WSNULL += "true||"
		elseIf aRet[1] .And. !aRet[2]	//O evento tem dente, mas o digitado pelo usuario e invalido
			::WSNULL += "false|
			if aRet[5] == ""
				::WSNULL += "Conjunto não cadastrado na tabela de faces (B09)|"
			else
				::WSNULL += "Face(s) informada(s) não encontrada(s) -> '"+aRet[5]+"'|"
			endif
		elseif !aRet[1]
			::WSNULL += "false|O procedimento informado não tem faces parametrizadas.|"
		endIf
		::WSNULL += "|" + aRet[4]
	else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³ PreAte   ³ Autor ³ Alexander Santos	     ³ Data ³ 2.05.07  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Inclusao do pre-atendimento								   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getRadio WSRECEIVE UserCode, NumAut, Tipo WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL cChave        := NumAut
	LOCAL aArea			:= GetArea()

	//Checa Usuário
	If PrtChkUser( ::UserCode, "PLSXFUN", "getRadio" )

		// Retorno a guia de radioterapia
		B4A->( DbSetOrder(1) )
		If B4A->(MsSeek(xFilial("B4A") + cChave))
			If (B4A->B4A_TIPGUI == "08" .and. iif( !empty(::Tipo), B4A->B4A_STTISS == ::Tipo, .t. ))
				::WSNULL := "true|S|" + cChave
			else
				::WSNULL := "true|N"
			EndIf
		else
			::WSNULL := "true|N"
		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/{Protheus.doc} CarenBenefi

Traz informacoes das classes de carencia do Beneficiario
@author  Roberto Barbosa
@version P11
@since   28/03/17
/*/
//-------------------------------------------------------------------
WSMETHOD CarenBenefi WSRECEIVE UserCode, cUsrLogin, cRecno WSSEND ListCarenBene WSSERVICE PLSXFUN
	LOCAL nI        := 0
	LOCAL aArea	    := GetArea()
	LOCAL lRetorno  := .T.
	LOCAL cSQL      := ""
	LOCAL aCarBen	:= {}
	LOCAL cMatric   := ""
	LOCAL cOpe		:= ""
	LOCAL dDatCar	:= CTOD('')
	// Checa Usuario
	If PrtChkUser( ::UserCode, "PLSXFUN", "CarenBenefi" )

		// Retorna a matricula do beneficiario que esta cadastrado para o login
		cSQL := " SELECT B49_BENEFI "
		cSQL += " FROM " + RetSQLName("B49")
		cSQL += " WHERE B49_CODUSR = '" + cUsrLogin + "' AND "
		cSQL += " D_E_L_E_T_ = ' ' "
		cSql := ChangeQuery(cSql)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TrbRet",.T.,.F.)

		If !TrbRet->(EOF())

			::ListCarenBene  := {}
			If cRecno <> "0"
				BA1->(DbGoTo(Val(cRecno)))
				cMatric := BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG)
				cOpe    := BA1->BA1_CODINT
				dDatCar := BA1->BA1_DATCAR

				aCarBen := PLSCLACAR(cOpe,cMatric,dDatCar,.T.)

				If Len(aCarBen[2]) > 0
					For nI := 1 to Len(aCarBen[2])
						AaDd( ::ListCarenBene,wsClassNew("CarenBenList") )
						::ListCarenBene[nI]:Recno      := 1
						::ListCarenBene[nI]:CodClasse  := aCarBen[2][nI][1]
						::ListCarenBene[nI]:DataFimCar := aCarBen[2][nI][3]
						::ListCarenBene[nI]:DesClasse  := aCarBen[2][nI][2]
						::ListCarenBene[nI]:Status     := aCarBen[2][nI][4]
						::ListCarenBene[nI]:NomeBenef  := CAPITAL( ALLTRIM( BA1->BA1_NOMUSR ) )
					Next
				EndIf
			EndIf
			TrbRet->(dbCloseArea())
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno


/*/{Protheus.doc} GrvUplGui
Realiza a gravação do protocolo de solicitação upload de guias
@version P12
@since 22/11/18
/*/
//-------------------------------------------------------------------
WSMETHOD GrvUplGui WSRECEIVE UserCode, cUsrLogin, MonSol, NumCrm, SgCrm, TpEst, ProtocUpl, Benef, Matric WSSEND WSNULL WSSERVICE PLSXFUN

	Local aArea	    := GetArea()
	Local lRetorno  := .T.

	Default ::WSNULL 	:= "true|"

	// Checa Usuario
	If PrtChkUser( ::UserCode, "PLSXFUN", "GrvUplGui" )

		//Gravação
		Begin Transaction
			BKU->(RecLock("BKU", .T.))
			BKU->BKU_FILIAL := xFilial("BKU")
			BKU->BKU_NRPRO  := ProtocUpl
			BKU->BKU_SIGLA  := SgCrm
			BKU->BKU_REGSOL := NumCrm
			BKU->BKU_UF     := TpEst
			BKU->BKU_NOMSOL := MonSol
			BKU->BKU_NOMUSR := Benef
			BKU->BKU_MATUSR := Matric
			BKU->BKU_STATUS := "7"  // Solicitação em Analise
			BKU->(MsUnlock())
			::WSNULL :=  "true|S"
		End Transaction
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno



/*/{Protheus.doc} ConsSolProf
Consulta o Profisional solicitante ou executante.
@version P12
@since 04/12/2018
/*/
//-------------------------------------------------------------------
WSMETHOD ConsSolProf WSRECEIVE UserCode, cUsrLogin, NumCrm, SgCrm, MonSol,CodEst WSSEND WSNULL WSSERVICE PLSXFUN

	Local aArea	    := GetArea()
	Local cNome     := ""
	Local cEstado   := ""
	Local lRetorno  := .T.
	Local cQuery    := ""

	Default ::WSNULL := "true|"

	// Checa Usuario
	If PrtChkUser( ::UserCode, "PLSXFUN", "ConsSolProf" )

		//Lista todos os profissionais da base (BB0).
		cQuery := " SELECT BB0_NOME, BB0_ESTADO  "
		cQuery += " FROM " + RetSqlName("BB0") + " "
		cQuery += " WHERE BB0_FILIAL = '" + xFilial("BB0") + "' "
		If  (!Empty(::NumCrm) .And. !Empty(::SgCrm) .and. !Empty(::CodEst))
			cQuery += " AND BB0_NUMCR = '" + allTrim(UPPER(::NumCrm)) + "' "
			cQuery += " AND BB0_CODSIG = '" + allTrim(UPPER(::SgCrm)) + "' "
			cQuery += " AND BB0_ESTADO = '" + allTrim(UPPER(::CodEst)) + "' "
		Else
			cQuery += " AND BB0_NOME = '" + allTrim(UPPER(::MonSol)) + "' "
		EndIf
		cQuery += " AND (BB0_DATBLO = '' OR BB0_DATBLO > '" + dtos(dDataBase) + "')"
		cQuery += " AND D_E_L_E_T_ = ' ' "
		cQuery += " GROUP BY BB0_NOME,BB0_ESTADO ORDER BY BB0_NOME "
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"TrbRet",.T.,.F.)

		If !TrbRet->(EOF())
			cNome := TrbRet->BB0_NOME
			cEstado := TrbRet->BB0_ESTADO
			::WSNULL := "true|S|"
			::WSNULL += cNome + "|" + cEstado
		Else
			::WSNULL := "true|N"

		EndIf

		TrbRet->(dbCloseArea())

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/{Protheus.doc} relTissOn
gera xml do demonstrativo através do tiss online
@version P12
@since 13/02/2019
/*/
//-------------------------------------------------------------------
WSMETHOD relTissOn WSRECEIVE UserCode, cCodRDA, Tipo, Tipbusca, Busca, Protocolo WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno  := .T.
	local lControl  := .T.
	local aDadDemons := { ::cCodRDA, ::Tipo, ::Tipbusca, ::Busca, ::Protocolo }
	Default ::WSNULL := "true|"

	// Checa Usuario
	If PrtChkUser( ::UserCode, "PLSXFUN", "relTissOn" )

		cXml := PLDempgOnl(.t., @lControl, aDadDemons)

		if lControl
			::WSNULL := "true|" + cXml//cNomeArq
		else
			::WSNULL := "false|Não existe pagamento no período selecionado"
		endif

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

/*/{Protheus.doc} VldCpfB2n
Verifica se o cpf ja existe na mesma solicitação
@version P12
@since 13/02/2019
/*/
//-------------------------------------------------------------------
WSMETHOD VldCpfB2n WSRECEIVE UserCode, NumCpf, Protoc WSSEND WSNULL WSSERVICE PLSXFUN
	Local lRetorno:=.T.
	Local lExiste:=.F.

	// Checa Usuario
	If PrtChkUser( ::UserCode, "PLSXFUN", "VldCpfB2n" )

		If ::Protoc <> "000000" .OR. ::Protoc <> ""// 000000 = primeira chamada

			B2N->(DbSetOrder(1))
			If B2N->(DbSeek(xFilial()+Protoc))

				While !B2N->(Eof("B2N")) .and. B2N->B2N_PROTOC == ::Protoc

					If Alltrim(B2N->B2N_CPFUSR) == ::NumCpf
						lExiste:=.T.
						EXIT
					EndIf

					B2N->(dbskip())
				Enddo
			Endif
		Else
			lExiste:=.F.
		Endif

		if lExiste
			::WSNULL := "true|true"
		else
			::WSNULL := "true|false"
		endif

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

/*/{Protheus.doc} getObs
retorna observação de peg glosada integralmente
@version P12
@since 13/02/2019
/*/
//-------------------------------------------------------------------
WSMETHOD getObs WSRECEIVE UserCode, Protoc WSSEND WSNULL WSSERVICE PLSXFUN
	local lRetorno := .T.
	local lExiste  := .F.
	local cObs     := ""

	// Checa Usuario
	If PrtChkUser( ::UserCode, "PLSXFUN", "getObs" )

		If ::Protoc <> "000000" .OR. ::Protoc <> ""

			BCI->(DbSetOrder(14))
			If BCI->(MsSeek(xFilial("BCI")+::Protoc))
				BDX->(DbSetOrder(1))
				if BDX->(MsSeek(xFilial("BDX")+BCI->(BCI_CODOPE+BCI_CODLDP)+::Protoc))
					cObs := cValToChar(BDX->BDX_OBS)
					lExiste := .t.
				endif
			Endif
		Endif

		if lExiste
			::WSNULL := "true|" + cObs
		else
			::WSNULL := "false|Não foi encontrado nenhum registro."
		endif

	Else
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³USRRECBLQ  ³Autor  ³Victor Alves      	 ³ Data ³25.06.20   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³³Valida se o usuário está bloqueado na tela de cadadstro de medicamento  ±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD USRRECBLQ WSRECEIVE UserCode, Benef WSSEND WSNULL WSSERVICE PLSXFUN

	Local lRetorno := .T.
	Local aAreaBa1 := BA1->(GetArea())
	Local lCritica := .F.
	Local cNomeBeneficiario := ""

	If PrtChkUser( ::UserCode , "PLSXFUN","USRRECBLQ" )
		IF !Empty(::Benef)
			BA1->(DbSetOrder(2)) //BA1_FILIAL+BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO
			If !BA1->(MsSeek(xFilial("BA1") + ::Benef)) .Or. Len(Alltrim(::Benef)) <> 17
				BA1->(DbSetOrder(5))
				If !BA1->(MsSeek(xFilial("BA1") + ::Benef)) //BA1_FILIAL+BA1_MATANT+BA1_TIPANT
					lCritica := .T.
				Endif
			Endif

			If !lCritica
				lCritica := PlChHiBlo("BCA",dDataBase,BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC),BA1->BA1_TIPREG)
				cNomeBeneficiario := BA1->BA1_NOMUSR
			EndIf
		EndIf

		::WSNULL := IIF(lCritica, "false|", "true|"+cNomeBeneficiario)
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea(aAreaBa1)

Return lRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} LogLGPD
Loga os webservices acionados pelo Portal

@author sakai
@since 10/12/2020
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD LogLGPD WSRECEIVE UserCode,UserLGPD,RotinLGPD WSSEND WSNULL WSSERVICE PLSXFUN

	LOCAL aArea 	:= GetArea()
	LOCAL lRetorno := .T.

	if PrtChkUser( self:UserCode , "PLSXFUN","LogLGPD" )
		if !empty(self:UserLGPD) .And. !empty(self:RotinLGPD)
			PLogPortLG(self:RotinLGPD,self:UserLGPD)
			::WSNULL := "true|true"
		else
			::WSNULL := "true|false"
		endif
	else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf

	RestArea( aArea )

Return lRetorno

/*/{Protheus.doc} PlsProRecAne
Altera a matrícula da função PPLPROREC caso a matrícula for de matrícula antiga.
@author Rafael Soares da Silva
@since 19/07/2021
@version P12
/*/
Function PlsProRecAne(cChave, cFilAlias)

	Local cChaveAux := ""
	Local cMatricula := ""
	Local nTamFilial := 0

	Default cFilAlias := ""

	If !Empty(cFilAlias)
		nTamFilial := Len(cFilAlias)
		cChaveAux := substr(cChave, nTamFilial+1, Len(Space(TamSX3("B4F_CODREC")[1])))
		cMatricula := AllTrim(substr(cChave, nTamFilial+Len(cChaveAux)+1, Len(cChave)))
	Else
		cChaveAux := substr(cChave, 1, Len(Space(TamSX3("B4F_CODREC")[1])))
		cMatricula := AllTrim(substr(cChave, Len(cChaveAux)+1, Len(cChave)))
	EndIf

	BA1->(DBSetOrder(5)) //BA1_FILIAL+BA1_MATANT
	If BA1->(DbSeek(xFilial("BA1")+cMatricula))
		If !Empty(cFilAlias)
			cChave := cFilAlias + cChaveAux + BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)
		Else
			cChave := cChaveAux + BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)
		EndIf
	EndIf

Return cChave
