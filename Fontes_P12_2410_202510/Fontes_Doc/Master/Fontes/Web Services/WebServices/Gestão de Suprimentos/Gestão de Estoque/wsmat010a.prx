#INCLUDE "wsmat010a.ch"
#INCLUDE "APWEBSRV.CH"
#INCLUDE "PROTHEUS.CH"
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³WSMAT010A ³ Autor ³Eduardo Riera          ³ Data ³08.07.2004  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Web Service responsavel pelo catalogo de produtos de um      ³±±
±±³          ³ cliente                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³                                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Atualizacoes sofridas desde a Construcao Inicial.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Programador  ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³              ³        ³      ³                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao do Web Service de Controle do Usuario                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT ExternalInvoiceView
	WSDATA Status           As String
	WSDATA InvoiceShipment  As InvoiceHeaderView
	WSDATA InvoiceReturn    As Array Of InvoiceHeaderView OPTIONAL
ENDWSSTRUCT

WSSERVICE MtCustomerProduct  DESCRIPTION STR0001 NAMESPACE "http://webservices.microsiga.com.br/mtcustomerproduct.apw" //"Serviço de consulta a tabela de produtos e seus vinculos. (<b> Restrição de cliente/produto </b>)"
   WSDATA UserCode                 AS String
   WSDATA CustomerID               AS String
   WSDATA ProductCode              AS String
   WSDATA WareHouse                As String      
   WSDATA Header                   AS Array Of BrwHeader
   WSDATA HeaderType               AS String
   WSDATA Inventory                As Array Of InventoryView OPTIONAL
   WSDATA ExternalInventory        As Array Of InventoryCustomerView OPTIONAL
   WSDATA InventoryDate            As Date    OPTIONAL
   WSDATA TypeOfInventory          As Integer OPTIONAL      
   WSDATA TypeOfProductIn          As String  OPTIONAL
   WSDATA GroupOfProductIn         As String  OPTIONAL
   WSDATA PageLen                  AS Integer OPTIONAL
   WSDATA PageFirst                AS Integer OPTIONAL
   WSDATA DescriptionLike          AS String  OPTIONAL
   WSDATA ProductCodeLike          As String  OPTIONAL
   WSDATA QueryAddWhere            As String  OPTIONAL
   WSDATA IndexKey                 As String  OPTIONAL   
   WSDATA Stock                    As Array Of InventoryView OPTIONAL   
   WSDATA Products                 AS Array Of ProductView
   WSDATA ImageProduct             AS Base64Binary   
   WSDATA PriceTable               AS Array Of PriceView
   WSDATA PriceTableCode           As String
   WSDATA Quantity                 As Float
   WSDATA PaymentPlanCode          As String
   WSDATA DiscountType             As Integer
   WSDATA BasePrice                 As Float 
   WSDATA DisCountPercentage       As Float
   WSDATA TypeOfProductCollection  As Array Of GenericStruct
   WSDATA RegisterDateFrom         AS Date OPTIONAL
   WSDATA RegisterDateTo   	       AS Date OPTIONAL
   WSDATA ExternalInvoices         As Array Of ExternalInvoiceView
   WSDATA TypeOfMovement           As String

   WSMETHOD GetHeader             DESCRIPTION STR0002 //"Método que descreve as estruturas de retorno do serviço"
   WSMETHOD GetExternalInventory  DESCRIPTION STR0003 //"Método de consulta a posição de estoque de/em terceiro "
   WSMETHOD GetCatalog            DESCRIPTION STR0004 //"Método de consulta ao catalogo de produtos"
   WSMETHOD GetImage              DESCRIPTION STR0005    //"Método de recuperacao da imagem de um produto"
   WSMETHOD GetPrice              DESCRIPTION STR0006 //"Método de consulta as tabelas de precos do produto"
   WSMETHOD GetStock              DESCRIPTION STR0007 //"Método de consulta a posição atual de estoque de um produto"
   WSMETHOD GetDisCount           DESCRIPTION STR0008 //"Método de consulta a regra de desconto"
   WSMETHOD GetTypeOfProduct      DESCRIPTION STR0009    //"Método de consulta aos tipos de produto"
   WSMETHOD GetInventory          DESCRIPTION STR0010 //"Método de consulta a posição de inventário de um produto"
   WSMETHOD BrwExternalInvoice    DESCRIPTION STR0011 //"Método de listagem dos documentos do controle de poder de/em terceiro"
ENDWSSERVICE

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetHeader ³Autor  ³ Eduardo Riera         ³ Data ³08.07.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao do header do catalogo de produtos      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Nome da estrutura                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve o header de uma estrutura                ³±±
±±³          ³                                                             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetHeader WSRECEIVE HeaderType WSSEND Header WSSERVICE MtCustomerProduct

::Header := MtHeader(::HeaderType)

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetExterna³Autor  ³ Eduardo Riera         ³ Data ³08.07.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de consulta a posicao de estoque                      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±³          ³ExpC2: Codigo do cliente                                     ³±±
±±³          ³ExpC3: Codigo do produto                                     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Consulta aos saldos em estoque em nosso poder                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetExternalInventory WSRECEIVE UserCode,CustomerID,ProductCode WSSEND ExternalInventory WSSERVICE MtCustomerProduct

Local aArea     := GetArea()
Local lRetorno  := .T.
Local lQuery    := .F.
Local cQuery    := ""
Local cAliasSB2 := "SB2"
Local cAliasSB6 :="SB6"
Local nX        := 0
Local nY        := 0
Local aStruSB6  :={}
Local cCliente  := SubStr(::CustomerID,1,Len(SA1->A1_COD))
Local cLoja     := SubStr(::CustomerID,Len(SA1->A1_COD)+1)
Local lFirst := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Valida o acesso                                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser(::UserCode,"MtCustomerProduct","GetExternalInventory","SA1",::CustomerID)
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Pesquisa o saldo em estoque atraves da amarração ProdutoxCliente        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	#IFDEF TOP
		cAliasSB2 := "GETExternalINVENTORY"
		lQuery    := .T.
		cQuery := "SELECT B2_FILIAL,B2_COD,B2_LOCAL "
		cQuery += "FROM "+RetSqlName("SB2")+" SB2 "
		cQuery += "WHERE SB2.B2_FILIAL='"+xFilial("SB2")+"' AND "
		cQuery += "SB2.B2_COD='"+::ProductCode+"' AND "
		cQuery += "SB2.D_E_L_E_T_=' ' AND "
		cQuery  += "SB2.B2_COD IN ( "
		cQuery  += "SELECT SA7.A7_PRODUTO "
		cQuery  += "FROM "+RetSqlName("SA7")+" SA7 "
		cQuery  += "WHERE A7_FILIAL = '"+xFilial("SA7")+"' AND "
		cQuery  += "A7_CLIENTE = '"+cCliente+"' AND "
		cQuery  += "A7_LOJA = '"+cLoja+"' AND "
		cQuery  += "D_E_L_E_T_=' ' ) "
		
		cQuery += "ORDER BY "+SqlOrder(SB2->(IndexKey()))

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB2)

	#ELSE
	
		MsSeek(xFilial("SB2")+::ProductCode)
		dbSelectArea("SB2")
		
	#ENDIF
	
	While (!Eof() .And. (cAliasSB2)->B2_FILIAL == xFilial("SB2") .And.;
		(cAliasSB2)->B2_COD == ::ProductCode )
		If !lQuery
			dbSelectArea("SA7")
			dbSetOrder(1)
			MsSeek(xFilial("SA7")+cCliente+cLoja+(cCursor)->B1_COD)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calcula o saldo em estoque em nosso poder                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lQuery .Or. (!lQuery .And. SA7->(Found()))
			#IFDEF TOP
				lQuery := .T.
				cAliasSB6 := "SALDOTERC"
				aStruSB6  := SB6->(dbStruct())
	
				cQuery := "SELECT * FROM "
				cQuery += RetSqlName("SB6")+" SB6 "
				cQuery += "WHERE SB6.B6_FILIAL='"+xFilial("SB6")+"' AND "
				cQuery += "SB6.B6_PRODUTO='"+(cAliasSB2)->B2_COD+"' AND "
				cQuery += "SB6.B6_TIPO ='D' AND "
				cQuery += "SB6.B6_LOCAL='"+(cAliasSB2)->B2_LOCAL+"' AND"
				cQuery += "SB6.D_E_L_E_T_=' ' "
				cQuery := ChangeQuery(cQuery)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6,.F.,.T.)
				For nX := 1 To Len(aStruSB6)
					If aStruSB6[nX][2]<>"C" .And. FieldPos(aStruSB6[nX][1])<>0
						TcSetField(cAliasSB6,aStruSB6[nX][1],aStruSB6[nX][2],aStruSB6[nX][3],aStruSB6[nX][4])
					EndIf
				Next nX
			#ELSE
	
			#ENDIF
			lFirst := .T.
			
			While (cAliasSB6)->(!Eof())
				If lFirst
					aadd(::ExternalInventory,WsClassNew("InventoryCustomerView"))
					nY++
					::ExternalInventory[nY]:ProductCode := (cAliasSB2)->B2_COD
					::ExternalInventory[nY]:WareHouse   := (cAliasSB2)->B2_LOCAL
					::EXternalInventory[nY]:Currency       := 1
					::ExternalInventory[nY]:CurrencySimbol := SuperGetMV("MV_SIMB"+AllTrim(Str(1,2)))	
					lFirst := .F.
	        	EndIf
				If (cAliasSB6)->B6_PODER3 == "R"
					::ExternalInventory[nY]:Quantity   += (cAliasSB6)->B6_QUANT
					::ExternalInventory[nY]:Cost       += (cAliasSB6)->B6_CUSTO1
				Else
					::ExternalInventory[nY]:Quantity   -= (cAliasSB6)->B6_QUANT
					::ExternalInventory[nY]:Cost       -= (cAliasSB6)->B6_CUSTO1
				EndIf
			
				dbSelectArea(cAliasSB6)
				dbSkip()
			EndDo
	    	If lQuery
	    		dbSelectArea(cAliasSB6)
				dbCloseArea()
				dbSelectArea("SB6")
		    EndIf
		EndIf			
		dbSelectArea(cAliasSB2)
		dbSkip()
	EndDo
	If lQuery
		dbSelectArea(cAliasSB2)
		dbCloseArea()
		dbSelectArea("SB2")
	EndIf
Else
	lRetorno := .F.
EndIf
RestArea(aArea)
Return(lRetorno)


Return(.T.)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetCatalog³Autor  ³ Eduardo Riera         ³ Data ³19.07.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao da tabela de produtos                  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±³          ³ExpC2: Codigo do cliente                                     ³±±
±±³          ³ExpC3: Tipo de Produto para operação Like                    ³±±
±±³          ³ExpC4: Grupo de Produto para operação Like                   ³±±
±±³          ³ExpC5: Codigo de produto para operação Like                  ³±±
±±³          ³ExpC6: Descrição de Produto para operação Like               ³±±
±±³          ³ExpN7: Tamanho da pagina                                     ³±±
±±³          ³ExpN8: Numero do registro da primeira pagina.                ³±±
±±³          ³ExpC9: Expressao a ser adicionada na query                   ³±±
±±³          ³ExpCA: Expressao utilizada para ordenação                    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve a tabela de produtos conforme a estrutura³±±
±±³          ³da mesma                                                     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetCatalog WSRECEIVE UserCode,CustomerID,TypeOfProductIn,GroupOfProductIn,ProductCodeLike,DescriptionLike,PageLen,PageFirst,QueryAddWhere,IndexKey WSSEND Products WSSERVICE MtCustomerProduct

Local aArea    := GetArea()
Local cCursor  := "SB1"
Local cCursor2 := "SB5"
Local cArquivo := ""
Local lQuery   := .F.
Local lRetorno := .T.
Local cTipoIn  := ::TypeOfProductIn
Local cGrupoIn := ::GroupOfProductIn
Local nX       := 0
Local nY       := 0
Local cCliente  := SubStr(::CustomerID,1,Len(SA1->A1_COD))
Local cLoja     := SubStr(::CustomerID,Len(SA1->A1_COD)+1)
#IFDEF TOP
	Local aStruct  := {}
	Local cQuery   := ""
#ENDIF

SB1->(dbSetOrder(1))

DEFAULT ::PageLen   := 0
DEFAULT ::PageFirst := 0
DEFAULT ::IndexKey  := SB1->(IndexKey())
DEFAULT cTipoIn     := ""
DEFAULT cGrupoIn    := ""

dbSelectArea("SB1")
dbSelectArea("SB5")
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento do In                                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !"'" $ cTipoIn .And. !Empty(cTipoIn)
	cTipoIn := StrTran(cTipoIn,",","','")
	cTipoIn := "'"+AllTrim(cTipoIn)+"'"
EndIf
If !"'" $ cGrupoIn .And. !Empty(cGrupoIn)
	cGrupoIn := StrTran(cGrupoIn,",","','")
	cGrupoIn := "'"+AllTrim(cGrupoIn)+"'"
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Valida o acesso                                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser(::UserCode,"MTCustomerPRODUCT","GetCatalog","SA1",::CustomerID)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Pesquisa o catalogo de produto em função da amarraçao Produto x Cliente ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB1")
	dbSetOrder(1)
	#IFDEF TOP
		lQuery  := .T.
		cCursor := "GetCatalog"
		cCursor2:= "GetCatalog"
		cQuery  := "SELECT B1_FILIAL,B1_TIPO,B1_GRUPO,B1_COD,B1_DESC,B1_UM,B1_SEGUM,B1_POSIPI,"
		cQuery  += "B1_QE,B1_EMIN,B1_PESO,B1_PESBRU,B1_PE,B1_TIPE,B1_LE,B1_LM,B1_NOTAMIN,B1_PRVALID,"
		cQuery  += "B1_CODBAR,B1_LOCPAD,B5_CEME,B5_COMPRLC,B5_LARGLC,B5_ALTURLC,B5_FATARMA "
		cQuery  += GetUserFields("SB1")+GetUserFields("SB5")
		cQuery  += "FROM "
		cQuery  += RetSqlName("SB1")+" SB1 LEFT JOIN "
		cQuery  += RetSqlName("SB5")+" SB5 ON (SB5.B5_FILIAL='"+xFilial("SB5")+"' AND SB1.B1_COD=SB5.B5_COD AND SB5.D_E_L_E_T_=' ') "
		cQuery  += "WHERE SB1.B1_FILIAL='"+xFilial("SB1")+"' AND "
		If !Empty(cTipoIn)
			cQuery  += "SB1.B1_TIPO IN("+cTipoIn+") AND "
		EndIf
		If !Empty(cGrupoIn)
			cQuery  += "SB1.B1_GRUPO IN("+cGrupoIn+") AND "
		EndIf
		If !Empty(::ProductCodeLike)
			cQuery  += "SB1.B1_COD LIKE '%"+::ProductCodeLike+"%' AND "
		EndIf		
		If !Empty(::DescriptionLike)
			cQuery  += "SB1.B1_DESC LIKE '%"+::DescriptionLike+"%' AND "
		EndIf
		cQuery  += "SB1.D_E_L_E_T_=' ' AND "
		cQuery  += "SB1.B1_COD IN ( "
		cQuery  += "SELECT SA7.A7_PRODUTO "
		cQuery  += "FROM "+RetSqlName("SA7")+" SA7 "
		cQuery  += "WHERE A7_FILIAL = '"+xFilial("SA7")+"' AND "
		cQuery  += "A7_CLIENTE = '"+cCliente+"' AND "
		cQuery  += "A7_LOJA = '"+cLoja+"' AND "
		cQuery  += "D_E_L_E_T_=' ' ) "
		cQuery  := WsQueryAdd(cQuery,::QueryAddWhere)
		cQuery  += "ORDER BY "+SqlOrder(::IndexKey)
		
		cQuery := ChangeQuery(cQuery)
		
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor)
		aStruct := SB1->(dbStruct())
		For nX := 1 To Len(aStruct)
			If aStruct[nX][2]<>"C" .And. FieldPos(aStruct[nX][1])<>0
				TcSetField(cCursor,aStruct[nX][1],aStruct[nX][2],aStruct[nX][3],aStruct[nX][4])
		    EndIf
		Next nX
	#ELSE
		cArquivo := CriaTrab( , .F. )
		
		cQuery := "B1_FILIAL == '" + xFilial( "SB1" ) + "' "

		If !Empty( cTipoIn )
			cQuery  += ".AND. B1_TIPO == " + cTipoIn + " "
		EndIf

		If !Empty( cGrupoIn )
			cQuery  += ".AND. B1_GRUPO == " + cGrupoIn + " "
		EndIf

		If !Empty( ::ProductCodeLike )
			cQuery += ".AND. B1_COD = '" + ::ProductCodeLike + "' "
		EndIf		

		If !Empty( ::DescriptionLike )
			cQuery += ".AND. B1_DESC = '" + ::DescriptionLike + "'"
		EndIf
		
		IndRegua("SB1",cArquivo,::IndexKey,,cQuery)
		dbGotop()
	#ENDIF
	::Products := {}
	nX := 0
	While !Eof() .And. (cCursor)->B1_FILIAL == xFilial("SB1")
		If !lQuery
			dbSelectArea("SA7")
			dbSetOrder(1)
			MsSeek(xFilial("SA7")+cCliente+cLoja+(cCursor)->B1_COD)
		EndIf	
	
		If ((cCursor)->B1_TIPO $ cTipoIn .Or. Empty(cTipoIn)).And.;
			((cCursor)->B1_GRUPO $ cGrupoIn .Or. Empty(cGrupoIn)).And.;
			IIf(!Empty(::ProductCodeLike).And.!lQuery,::ProductCodeLike$(cCursor)->B1_COD,.T.) .And.;
			IIf(!Empty(::DescriptionLike).And.!lQuery,::DescriptionLike$(cCursor)->B1_DESC,.T.) .And.;
			IIf(!lQuery,SA7->(Found()),.T.)
					
			nY++
			
			If ::PageFirst==0 .Or. nY >= ::PageFirst

				nX++
						
				dbSelectArea("SAH")
				dbSetOrder(1)
			
				dbSelectArea("SBM")
				dbSetOrder(1)
	
				dbSelectArea("SX5")
				dbSetOrder(1)
				MsSeek(xFilial("SX5")+'02'+(cCursor)->B1_TIPO)
				
				If !lQuery
					dbSelectArea("SB5")
					dbSetOrder(1)
					MsSeek(xFilial("SB5")+(cCursor)->B1_COD)
				EndIf
	
				aadd(::Products,WSClassNew("ProductView"))
				::Products[nX]:ProductCode                  := (cCursor)->B1_COD
				::Products[nX]:Description                  := (cCursor)->B1_DESC
				::Products[nX]:ScienceDescription           := (cCursor2)->B5_CEME
				::Products[nX]:MeasureUnit                  := (cCursor)->B1_UM
				::Products[nX]:DescriptionMeasureUnit       := IIf(SAH->(MsSeek(xFilial("SAH")+(cCursor)->B1_UM)),SAH->AH_DESCPO,"")
				::Products[nX]:SecondMeasureUnit            := (cCursor)->B1_SEGUM
				::Products[nX]:DescriptionSecondMeasureUnit := IIf(SAH->(MsSeek(xFilial("SAH")+(cCursor)->B1_SEGUM)),SAH->AH_DESCPO,"")
				::Products[nX]:TypeOfProduct                := (cCursor)->B1_TIPO
				::Products[nX]:DescriptionTypeOfProduct     := X5Descri()
				::Products[nX]:GroupOfProduct               := (cCursor)->B1_GRUPO
				::Products[nX]:DescriptionGroupOfProduct    := IIf(SBM->(MsSeek(xFilial("SBM")+(cCursor)->B1_GRUPO)),SBM->BM_DESC,"")
				::Products[nX]:NCM	                         := (cCursor)->B1_POSIPI
				::Products[nX]:QuantityPerPackage           := (cCursor)->B1_QE
				::Products[nX]:OrderPoint                   := (cCursor)->B1_EMIN
				::Products[nX]:NetWeight                    := (cCursor)->B1_PESO
				::Products[nX]:GrossWeight                  := (cCursor)->B1_PESBRU
				::Products[nX]:LeadTime                     := (cCursor)->B1_PE
				::Products[nX]:TypeOfLeadTime               := (cCursor)->B1_TIPE
				::Products[nX]:EconomicLot                  := (cCursor)->B1_LE
				::Products[nX]:MinimumLot                   := (cCursor)->B1_LM
				::Products[nX]:MinimumGrade                 := (cCursor)->B1_NOTAMIN
				::Products[nX]:TermOfValidaty               := (cCursor)->B1_PRVALID
				::Products[nX]:BarCode                      := (cCursor)->B1_CODBAR
				::Products[nX]:StorageLenght                := (cCursor2)->B5_COMPRLC
				::Products[nX]:StorageWidth                 := (cCursor2)->B5_LARGLC
				::Products[nX]:StorageHeight                := (cCursor2)->B5_ALTURLC
				::Products[nX]:StorageMaximumPiling         := (cCursor2)->B5_FATARMA
				::Products[nX]:StandardWareHouse            := (cCursor)->B1_LOCPAD 
				UserFields("SB1",@::Products[nX]:UserFields,cCursor)
						
				If nX >= ::PageLen .And. ::PageLen <> 0
					Exit
				EndIf
			EndIf
		EndIf
		dbSelectArea(cCursor)
		dbSkip()
			
	EndDo
	If lQuery
		dbSelectArea(cCursor)
		dbCloseArea()
		dbSelectArea("SB1")
	Else
		RetIndex("SB1")
		FErase(cArquivo+OrdBagExt())
	EndIf
	If Len(::Products) == 0
		lRetorno := .F.
		SetSoapFault("GETCATALOG",STR0012)	 //"Nenhum produto foi encontrado"
	EndIf
Else
	lRetorno := .F.
EndIf
RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetImage  ³Autor  ³ Eduardo Riera         ³ Data ³19.07.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao da imagem de um produto do catalogo    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±³          ³ExpC2: Codigo do cliente                                     ³±±
±±³          ³ExpC3: Codigo do produto                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve a imagem de um produto                   ³±±
±±³          ³                                                             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetImage WSRECEIVE UserCode,CustomerID,ProductCode WSSEND ImageProduct WSSERVICE MtCustomerProduct

Local aArea    := GetArea()
Local lRetorno := .T.
Local cBmpPict := ""
Local cPathPict:= GetSrvProfString("Startpath","")
Local cBitMap  := ""
Local cLeitura := ""
Local cExtensao:= ".BMP"
Local nHandle  := 0
Local nLidos   := 0
Local cCliente  := SubStr(::CustomerID,1,Len(SA1->A1_COD))
Local cLoja     := SubStr(::CustomerID,Len(SA1->A1_COD)+1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Valida o acesso                                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser(::UserCode,"MTCUSTOMERPRODUCT","GetImage","SA1",::CustomerID)
	dbSelectArea("SA7")
	dbSetOrder(1)
	If MsSeek(xFilial("SA7")+cCliente+cLoja+::ProductCode)
	
		dbSelectArea("SB1")
		dbSetOrder(1)
		If MsSeek(xFilial("SB1")+::ProductCode) .And. SA7->(Found())
			If !Empty( cBmpPict := Upper( AllTrim( SB1->B1_BITMAP ) ) )
				If RepExtract(cBmpPict,cPathPict+cBmpPict)
					If !File(cPathPict+cBmpPict+cExtensao)
						cExtensao := ".JPG"
					EndIf
					nHandle := FOpen(cPathPict+cBmpPict+cExtensao)
					If nHandle <> 0
						nLidos := 1
						While nLidos > 0
							cLeitura := ""
							nLidos := Fread(nHandle,@cLeitura,4096)
							cBitMap += cLeitura
						EndDo
						::ImageProduct := cBitMap
					Else
						lRetorno := .F.
						SetSoapFault("GETIMAGE",STR0013) //"Erro de leitura no repositorio de imagem"
					EndIf
					FClose(nHandle)
					Ferase(cPathPict+cBmpPict+cExtensao)
				Else
					lRetorno := .F.
					SetSoapFault("GETIMAGE",STR0013) //"Erro de leitura no repositorio de imagem"
				EndIf
			EndIf
		Else
			lRetorno := .F.
			SetSoapFault("GETIMAGE",STR0014) //"Produto nao cadastrado"
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault("GETIMAGE",STR0015) //"Produto nao cadastrado para este cliente"
	EndIf		
Else
	lRetorno := .F.
EndIf
RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetPrice  ³Autor  ³ Eduardo Riera         ³ Data ³19.07.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao da tabela de precos de um produto      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±³          ³ExpC2: Codigo do cliente                                     ³±±
±±³          ³ExpC3: Codigo do produto                                     ³±±
±±³          ³ExpC4: Expressa a ser adicionada na query                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve a tabela de preco em sua respectiva estru³±±
±±³          ³tura                                                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetPrice WSRECEIVE UserCode,CustomerID,ProductCode,QueryAddWhere WSSEND PriceTable WSSERVICE MtCustomerProduct

Local aArea   := GetArea()
Local nX      := 0
Local cCursor := "DA1"
Local lQuery  := .F.
Local lRetorno := .T.
Local cCliente  := SubStr(::CustomerID,1,Len(SA1->A1_COD))
Local cLoja     := SubStr(::CustomerID,Len(SA1->A1_COD)+1)

#IFDEF TOP
Local aStru   := {}
Local cQuery  := ""
Local nY      := 0
#ENDIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Valida o acesso                                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser(::UserCode,"MTCUSTOMERPRODUCT","GETPRICE","SA1",::CustomerID)

	dbSelectArea("SA7")
	dbSetOrder(1)
	If MsSeek(xFilial("SA7")+cCliente+cLoja+::ProductCode)

		dbSelectArea("SB1")
		dbSetOrder(1)
		If MsSeek(xFilial("SB1")+::ProductCode) .And. SA7->(Found())
			::PriceTable := {}
			nX := 0
			If SB1->B1_PRV1 <> 0
				aadd(::PriceTable,WSClassNew("PriceView"))
				nX++
				::PriceTable[nX]:ProductCode    := SB1->B1_COD
				::PriceTable[nX]:PaymentPlanCode := ""
				::PriceTable[nX]:PriceTableCode := "1  "
				::PriceTable[nX]:Price          := SB1->B1_PRV1
				::PriceTable[nX]:QuantityLimit  := 0
				::PriceTable[nX]:Currency       := 1
				::PriceTable[nX]:CurrencySimbol := SuperGetMV("MV_SIMB"+AllTrim(Str(1,2)))
			EndIf
			dbSelectArea("DA1")
			dbSetOrder(2)
			#IFDEF TOP
				lQuery  := .T.
				cCursor := "GetPrice"
				aStru   := DA1->(dbStruct())
				
				cQuery := "SELECT DA1_FILIAL,DA1_CODPRO,DA1_CODTAB,DA1_PRCVEN,DA1_QTDLOT,DA1_MOEDA,DA1_VLRDES "
				cQuery += GetUserFields("DA1")
				cQuery += "FROM "+RetSqlName("DA1")+" DA1 "
				cQuery += "WHERE "
				cQuery += "DA1.DA1_FILIAL='"+xFilial("DA1")+"' AND "
				cQuery += "DA1.DA1_CODPRO='"+SB1->B1_COD+"' AND "
				cQuery += "( DA1_DATVIG <= '"+Dtos(dDataBase)+ "' OR DA1_DATVIG = '"+Dtos(Ctod(""))+ "' ) AND "
				cQuery += "DA1_ATIVO = '"+"1"+"' AND  "
				cQuery += "DA1.D_E_L_E_T_=' ' "
				cQuery := WsQueryAdd(cQuery,::QueryAddWhere)
				cQuery += "ORDER BY "+SqlOrder(DA1->(IndexKey()))
				
				cQuery := ChangeQuery(cQuery)
				
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor)
				
				For nY := 1 To Len(aStru)
					If aStru[nY][2]<>"C".And. FieldPos(aStru[nY][1])<>0
						TcSetField(cCursor,aStru[nY][1],aStru[nY][2],aStru[nY][3],aStru[nY][4])
					EndIf
				Next nY		
			#ELSE
			    MsSeek(xFilial("DA1")+SB1->B1_COD)
			#ENDIF
			While !Eof() .And. xFilial("DA1") == (cCursor)->DA1_FILIAL .And.;
				SB1->B1_COD == (cCursor)->DA1_CODPRO			
				If MaVldTabPrc((cCursor)->DA1_CODTAB,"","sem help",dDatabase)
					dbSelectArea("DA0")
					dbSetOrder(1)
					MsSeek(xFilial("DA0")+(cCursor)->DA1_CODTAB)
					aadd(::PriceTable,WSClassNew("PriceView"))
					nX++
					::PriceTable[nX]:ProductCode    := SB1->B1_COD
					::PriceTable[nX]:PaymentPlanCode:= DA0->DA0_CONDPG
					::PriceTable[nX]:PriceTableCode := (cCursor)->DA1_CODTAB
					::PriceTable[nX]:Price          := (cCursor)->DA1_PRCVEN
					::PriceTable[nX]:QuantityLimit  := (cCursor)->DA1_QTDLOT
					::PriceTable[nX]:Currency       := (cCursor)->DA1_MOEDA
					::PriceTable[nX]:CurrencySimbol := SuperGetMV("MV_SIMB"+AllTrim(Str((cCursor)->DA1_MOEDA,2)))
					::PriceTable[nX]:DiscountValue  := (cCursor)->DA1_VLRDES
				EndIf
				dbSelectArea(cCursor)
				dbSkip()
			EndDo
			If lQuery
				dbSelectArea(cCursor)
				dbCloseArea()
				dbSelectArea("DA1")
			EndIf
		Else
			lRetorno := .F.
			SetSoapFault("GETPRICE",STR0016) //"Produto nao encontrado"
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault("GETPRICE",STR0015) //"Produto nao cadastrado para este cliente"
	EndIf
Else
	lRetorno := .F.
EndIf
RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetTypeOfP³Autor  ³ Eduardo Riera         ³ Data ³19.07.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao dos tipode de produto                  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve o estrutura de tipos de produto          ³±±
±±³          ³                                                             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetTypeOfProduct WSRECEIVE UserCode WSSEND TypeOfProductCollection WSSERVICE MtCustomerProduct

Local aArea     := GetArea()
Local lRetorno  := .T.
Local lQuery    := .F.
Local cAliasSX5 := "SX5"
Local nX        := 0 
#IFDEF TOP
Local cQuery    := ""
#ENDIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Valida o acesso                                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser(::UserCode,"MTCUSTOMERPRODUCT","GetTypeOfProduct")

	dbSelectArea("SX5")
	dbSetOrder(1)
	#IFDEF TOP
	
		lQuery    := .T.
		cAliasSX5 := "GetTypeOfProduct"
		
		cQuery := "SELECT * "
		cQuery += "FROM "+RetSqlName("SX5")+" SX5 "
		cQuery += "WHERE SX5.X5_FILIAL='"+xFilial("SX5")+"' AND "
		cQuery += "SX5.X5_TABELA='02' AND "
		cQuery += "SX5.D_E_L_E_T_=' ' "
		cQuery += "ORDER BY "+SqlOrder(SX5->(IndexKey()))
		
		cQuery := ChangeQuery(cQuery)
		
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSX5)	
	
	#ELSE
		dbSeek(xFilial("SX5")+"02")
	#ENDIF
	While !Eof() .And. (cAliasSX5)->X5_FILIAL == xFilial("SX5") .And. (cAliasSX5)->X5_TABELA == "02"
		
		aadd(::TypeOfProductCollection,WsClassNew("GenericStruct"))
		nX++
		::TypeOfProductCollection[nX]:Code        := ( cAliasSX5 )->X5_CHAVE
		::TypeOfProductCollection[nX]:Description := X5Descri(cAliasSX5)
	
		dbSelectArea(cAliasSX5)
		dbSkip()
		
	EndDo
	If lQuery
		dbSelectArea(cAliasSX5)
		dbCloseArea()
		dbSelectArea("SX5")
	EndIf
Else
	lRetorno := .F.
EndIf

RestArea(aArea)
Return(lRetorno)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetStock  ³Autor  ³ Eduardo Riera         ³ Data ³19.07.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao do saldo em estoque                    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±³          ³ExpC2: Codigo do Cliente                                     ³±±
±±³          ³ExpC3: Codigo do produto                                     ³±±
±±³          ³ExpC4: Almoxarifado                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve o saldo em stock de um almoxarifado      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetStock WSRECEIVE UserCode,CustomerID,ProductCode,WareHouse WSSEND Stock WSSERVICE MtCustomerProduct

Local aArea    := GetArea()
Local lRetorno := .T.
Local nX       := 0
Local cCliente  := SubStr(::CustomerID,1,Len(SA1->A1_COD))
Local cLoja     := SubStr(::CustomerID,Len(SA1->A1_COD)+1)

DEFAULT WareHouse := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Valida o acesso                                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser(::UserCode,"MTCUSTOMERPRODUCT","GetStock","SA1",::CustomerID)

	dbSelectArea("SA7")
	dbSetOrder(1)
	If MsSeek(xFilial("SA7")+cCliente+cLoja+::ProductCode)

		dbSelectArea("SB1")
		dbSetOrder(1)
		If MsSeek(xFilial("SB1")+::ProductCode)
		
			dbSelectArea("SA7")
			dbSetOrder(1)
			MsSeek(xFilial("SA7")+cCliente+cLoja+::ProductCode)
		
			dbSelectArea("SB2")
			dbSetOrder(1)
	
			If MsSeek(xFilial("SB2")+::ProductCode+::WareHouse) .And. SA7->(Found())
				While !Eof() .And. xFilial("SB2") == SB2->B2_FILIAL .And.;
					::ProductCode == SB2->B2_COD .And.;
					(::WareHouse == "" .Or. ::WareHouse == SB2->B2_LOCAL)
				
					aadd(::Stock,WsClassNew("InventoryView"))
					nX++
					::Stock[nX]:ProductCode              := SB2->B2_COD
					::Stock[nX]:WareHouse                := SB2->B2_LOCAL
					::Stock[nX]:Quantity                 := SaldoSB2()
					::Stock[nX]:Cost                     := SB2->B2_VATU1
					::Stock[nX]:Currency                 := 1
					::Stock[nX]:CurrencySimbol           := SuperGetMV("MV_SIMB"+AllTrim(Str(1,2)))
					::Stock[nX]:TypeofBalance            := 1
					::Stock[nX]:DescriptiontypeofBalance := STR0017 //"Estoque proprio em poder do contribuinte"
		
					dbSelectArea("SB2")
					dbSkip()
				EndDo
			EndIf
		Else
			lRetorno := .F.
			SetSoapFault("GETSTOCK",STR0016) //"Produto nao encontrado"
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault("GETSTOCK",STR0015) //"Produto nao cadastrado para este cliente"
	EndIf
Else
	lRetorno := .F.
EndIf
RestArea(aArea)
Return(lRetorno)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ-ÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³GetDisCount³ Autor ³Eduardo Riera         ³ Data ³19.07.2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ-ÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Metodo de avaliacao da regra de desconto para os modulos    ³±±
±±³          ³que possuem pedido de venda                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                    ³±±
±±³          ³ExpC2: Cliente/Loja                                         ³±±
±±³          ³ExpC3: Produto                                              ³±±
±±³          ³ExpC4: Tabela de Preco                                      ³±±
±±³          ³ExpC5: Quantidade                                           ³±±
±±³          ³ExpC6: Condicao de Pagamento                                ³±±
±±³          ³ExpN7: Tipo de Desconto                                     ³±±
±±³          ³       1 - Desconto por Item                                ³±±
±±³          ³       2 - Desconto por Total                               ³±±
±±³          ³ExpN8: Preco base do Item  (Unitario)                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: Percentual de Desconto da Regra                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo avaliar a regra de descontos  ³±±
±±³          ³conforme os parametros da rotina                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³                                                            ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetDisCount WSRECEIVE UserCode,CustomerID,ProductCode,PriceTableCode,Quantity,PaymentPlanCode,DiscountType,BasePrice WSSEND DisCountPercentage WSSERVICE MtCustomerProduct

Local cCliente  := SubStr(::CustomerID,1,Len(SA1->A1_COD))
Local cLoja     := SubStr(::CustomerID,Len(SA1->A1_COD)+1)
Local lRetorno  := .T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Valida o acesso                                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser(::UserCode,"MTCUSTOMERPRODUCT","GETDISCOUNT","SA1",::CustomerId)
	::DisCountPercentage := MaRgrDesc(::ProductCode,cCliente,cLoja,::PriceTableCode,::Quantity,::PaymentPlanCode,,::DiscountType,/*aProds*/,/*aExc*/, /*cCodRegDe*/, ::BasePrice)
Else
	lRetorno := .F.
EndIf

Return(lRetorno)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetInvento³Autor  ³ Eduardo Riera         ³ Data ³19.07.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de recuperacao dos saldos em estoque                  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±³          ³ExpC2: Codigo do cliente                                     ³±±
±±³          ³ExpC3: Codigo do produto                                     ³±±
±±³          ³ExpD4: Data do estoque                                       ³±±
±±³          ³       Se a data de estoque for igual a data base sera retor-³±±
±±³          ³       nado o saldo atual, caso contrario o historico        ³±±
±±³          ³ExpN5: [1] - Estoque por empresa                             ³±±
±±³          ³       [2] - Estoque por almoxarifado                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve a tabela de preco em sua respectiva estru³±±
±±³          ³tura                                                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetInventory WSRECEIVE UserCode,CustomerID,ProductCode,InventoryDate,TypeOfInventory,QueryAddWhere WSSEND Inventory WSSERVICE MtCustomerProduct

Local aArea     := GetArea()
Local aSaldo    := {}
Local aTipo     := {STR0017,STR0018,STR0019} //"Estoque proprio em poder do contribuinte"###"Estoque proprio em poder de terceiros"###"Estoque de terceiros em poder do contribuinte"
Local aRetorno  := {}
Local lRetorno  := .T.
Local lQuery    := .F.
Local dData     := ::InventoryDate
Local cQuery    := ""
Local cChave    := ""
Local cIndSB6   := ""
Local cAliasSB2 := "SB2"
Local nX        := 0
Local nY        := 0
Local lLocal    := .F.
Local cCliente  := SubStr(::CustomerID,1,Len(SA1->A1_COD))
Local cLoja     := SubStr(::CustomerID,Len(SA1->A1_COD)+1)

DEFAULT ::TypeOfInventory := 1
dData := IIf(Empty(dData),dDataBase,dData)
lLocal    := ::TypeOfInventory == 2
::Inventory := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Valida o acesso                                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser(::UserCode,"MTCUSTOMERPRODUCT","GETINVENTORY","SA1",::CustomerID)

	dbSelectArea("SA7")
	dbSetOrder(1)
	If MsSeek(xFilial("SA7")+cCliente+cLoja+::ProductCode)
	
		dbSelectArea("SB2")
		dbSetOrder(1)
		#IFDEF TOP
			cAliasSB2 := "GETINVENTORY"
			lQuery    := .T.
			cQuery := "SELECT B2_FILIAL,B2_COD,B2_LOCAL "
			cQuery += "FROM "+RetSqlName("SB2")+" SB2 "
			cQuery += "WHERE SB2.B2_FILIAL='"+xFilial("SB2")+"' AND "
			cQuery += "SB2.B2_COD='"+::ProductCode+"' AND "
			cQuery += "SB2.D_E_L_E_T_=' ' "
			cQuery := WsQueryAdd(cQuery,::QueryAddWhere)
			cQuery += "ORDER BY "+SqlOrder(SB2->(IndexKey()))
	
			cQuery := ChangeQuery(cQuery)
	
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB2)
	
		#ELSE
		
			MsSeek(xFilial("SB2")+::ProductCode)	
			PRIVATE nIndSb6 := 0
			dbSelectArea("SB6")
			cIndSB6 := CriaTrab(Nil,.F.)
			cChave := "B6_FILIAL+B6_PRODUTO+B6_LOCAL+B6_TIPO+DTOS(B6_DTDIGIT)"
			cQuery := 'B6_FILIAL="'+xFilial("SB6")+'" .And. DtoS(B6_DTDIGIT)<="'+Dtos(SuperGetMV("MV_ULMES"))+'"'
			IndRegua("SB6",cIndSB6,cChave,,cQuery)
			nIndSB6:=RetIndex("SB6")
			dbSetIndex(cIndSB6+OrdBagExt())
			dbSetOrder(nIndSB6+1)
			dbGoTop()
	
			dbSelectArea("SB2")
		#ENDIF
		While (!Eof() .And. (cAliasSB2)->B2_FILIAL == xFilial("SB2") .And.;
			(cAliasSB2)->B2_COD == ::ProductCode )
			
			aRetorno := CalcEst(::ProductCode,(cAliasSB2)->B2_LOCAL,dData)
	
			If !lLocal
				nY := aScan(aSaldo,{|x| x[3] == 1 .And. x[4]==""})
				If nY==0
					aadd(aSaldo,{aRetorno[1],aRetorno[2],1,""})
				Else
					aSaldo[nY][1] += aRetorno[1]
					aSaldo[nY][2] += aRetorno[2]
					aSaldo[nY][3] := 1
					aSaldo[nY][4] := ""
				EndIf
			Else
				aadd(::Inventory,WsClassNew("InventoryView"))
				::Inventory[nX]:ProductCode              := Self:ProductCode
				::Inventory[nX]:Quantity                 := aRetorno[1]
				::Inventory[nX]:Cost                     := aRetorno[2]
				::Inventory[nX]:Currency                 := 1
				::Inventory[nX]:CurrencySimbol           := SuperGetMV("MV_SIMB"+AllTrim(Str(1,2)))
				::Inventory[nX]:typeofBalance            := 1
				::Inventory[nX]:DescriptiontypeofBalance := aTipo[1]
				::Inventory[nX]:WareHouse                := (cAliasSB2)->B2_LOCAL
			EndIf
			aRetorno := SaldoTerc(::ProductCode,(cAliasSB2)->B2_LOCAL,"T",dData,(cAliasSB2)->B2_LOCAL,.F.) //De terceiro
			If !lLocal
				nY := aScan(aSaldo,{|x| x[3] == 2 })
				If nY==0
					aadd(aSaldo,{aRetorno[1],aRetorno[2],2,""})
				Else
					aSaldo[nY][1] += aRetorno[1]
					aSaldo[nY][2] += aRetorno[2]
					aSaldo[nY][3] := 2
				EndIf			
			Else
				aadd(::Inventory,WsClassNew("InventoryView"))
				::Inventory[nX]:ProductCode              := Self:ProductCode
				::Inventory[nX]:Quantity                 := aRetorno[1]
				::Inventory[nX]:Cost                     := aRetorno[2]
				::Inventory[nX]:Currency                 := 1
				::Inventory[nX]:CurrencySimbol           := SuperGetMV("MV_SIMB"+AllTrim(Str(1,2)))
				::Inventory[nX]:typeofBalance            := 2
				::Inventory[nX]:DescriptiontypeofBalance := aTipo[2]
				::Inventory[nX]:WareHouse                := (cAliasSB2)->B2_LOCAL
			EndIf
			aRetorno := SaldoTerc(::ProductCode,(cAliasSB2)->B2_LOCAL,"D",dData,(cAliasSB2)->B2_LOCAL,.f.) //Em terceiro
			If !lLocal
				nY := aScan(aSaldo,{|x| x[3] == 3})
				If nY==0
					aadd(aSaldo,{aRetorno[1],aRetorno[2],3,""})
				Else
					aSaldo[nY][1] += aRetorno[1]
					aSaldo[nY][2] += aRetorno[2]
					aSaldo[nY][3] := 3
					aSaldo[nY][4] := ""
				EndIf
			Else
				aadd(::Inventory,WsClassNew("InventoryView"))
				::Inventory[nX]:ProductCode              := Self:ProductCode
				::Inventory[nX]:Quantity                 := aRetorno[1]
				::Inventory[nX]:Cost                     := aRetorno[2]
				::Inventory[nX]:Currency                 := 1
				::Inventory[nX]:CurrencySimbol           := SuperGetMV("MV_SIMB"+AllTrim(Str(1,2)))
				::Inventory[nX]:typeofBalance            := 3
				::Inventory[nX]:DescriptiontypeofBalance := aTipo[3]
				::Inventory[nX]:WareHouse                := (cAliasSB2)->B2_LOCAL
			EndIf
	
			dbSelectArea(cAliasSB2)
			dbSkip()
		EndDo
		If lQuery
			dbSelectArea(cAliasSB2)
			dbCloseArea()
			dbSelectArea("SB2")
		EndIf
		If !lLocal
			If Empty(aSaldo)
				aSaldo := {{0,0,1,""}}
			EndIf
		Else
			If Empty(::Inventory)
				aSaldo := {{0,0,1,""}}
			EndIf
		EndIf
		For nX := 1 To Len(aSaldo)
			aadd(::Inventory,WsClassNew("InventoryView"))
			::Inventory[nX]:ProductCode              := Self:ProductCode
			::Inventory[nX]:Quantity                 := aSaldo[nX][1]
			::Inventory[nX]:Cost                     := aSaldo[nX][2]
			::Inventory[nX]:Currency                 := 1
			::Inventory[nX]:CurrencySimbol           := SuperGetMV("MV_SIMB"+AllTrim(Str(1,2)))
			::Inventory[nX]:TypeofBalance            := aSaldo[nX][3]
			::Inventory[nX]:DescriptiontypeofBalance := aTipo[aSaldo[nX][3]]
		Next nX
	Else
		lRetorno := .F.
		SetSoapFault("GETINVENTORY",STR0015) //"Produto nao cadastrado para este cliente"
	EndIf
Else
	lRetorno := .F.
EndIf	
RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³BrwExterna³Autor  ³ Eduardo Riera         ³ Data ³19.07.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de listagem dos documentos de poder de terceiro       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do usuario                                     ³±±
±±³          ³ExpC2: Codigo do cliente                                     ³±±
±±³          ³ExpC3: Codigo do produto                                     ³±±
±±³          ³ExpD4: Data de Emissao de                                    ³±±
±±³          ³ExpD5: Data de emissao ate                                   ³±±
±±³          ³ExpC6: Tipo de movimento  ( D-De terceiro/E-Em terceiro )    ³±±
±±³          ³ExpN7: Tamanho da pagina                                     ³±±
±±³          ³ExpN8: Numero do registro da primeira pagina.                ³±±
±±³          ³ExpC9: Expressao a ser adicionada na query                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo devolve a relacao de notas de poder de/em terceir³±±
±±³          ³o de um periodo                                              ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ CRM/Materiais/Portais                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD BrwExternalInvoice WSRECEIVE UserCode,CustomerID,ProductCode,RegisterDateFrom,RegisterDateTo,TypeOfMovement,PageLen,PageFirst,QueryAddWhere WSSEND ExternalInvoices WSSERVICE MtCustomerProduct

Local aArea     := GetArea()
Local lRetorno  := .T.
Local cCliente  := SubStr(::CustomerID,1,Len(SA1->A1_COD))
Local cLoja     := SubStr(::CustomerID,Len(SA1->A1_COD)+1)
Local cAliasSB6 := "SB6"
Local cAliasTMP := "SB6"
Local lQuery    := .F.
Local nX        := 0
Local nY        := 0
Local nSaldo    := 0
Local aNotas    := {}
#IFDEF TOP
	Local cQuery   := ""
	Local aStruSB6 := {}
#ENDIF
DEFAULT ::PageLen   := 0
DEFAULT ::PageFirst := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Valida o acesso                                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser(::UserCode,"MTCUSTOMERPRODUCT","BrwExternalInvoice","SA1",::CustomerID)

	dbSelectArea("SA7")
	dbSetOrder(1)
	If MsSeek(xFilial("SA7")+cCliente+cLoja+::ProductCode)
                   
		dbSelectArea("SB6")
		dbSetOrder(2)
		#IFDEF TOP
			lQuery    := .T.
			cAliasSB6 := GetNextAlias()
			aStruSB6  := SB6->(dbStruct())

			cQuery := "SELECT * "
			cQuery += "FROM "+RetSqlName("SB6")+" SB6 "
			cQuery += "WHERE SB6.B6_FILIAL='"+xFilial("SB6")+"' AND "
			cQuery += "SB6.B6_PRODUTO='"+::ProductCode+"' AND "
			cQuery += "SB6.B6_TIPO = '"+::TypeOfMovement+"' AND "
			If !Empty(::RegisterDateFrom)
				cQuery += "SB6.B6_EMISSAO >= '"+Dtos(::RegisterDateFrom)+"' AND "
			EndIf
			If !Empty(::RegisterDateTo)
				cQuery += "SB6.B6_EMISSAO <= '"+Dtos(::RegisterDateTo)+"' AND "
			EndIf
			cQuery += "SB6.B6_PODER3 = 'R' AND "
			cQuery += "SB6.D_E_L_E_T_=' ' "
			cQuery := WsQueryAdd(cQuery,::QueryAddWhere)
			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6,.T.,.T.)
			For nX := 1 To Len(aStruSB6)
				If aStruSB6[nX][2] <> "C" .And. FieldPos(aStruSB6[nX][1])<>0
					TcSetField(cAliasSB6,aStruSB6[nX][1],aStruSB6[nX][2],aStruSB6[nX][3],aStruSB6[nX][4])
				EndIf
			Next nX

		#ENDIF
		nX := 0		
		While !Eof() .And. xFilial("SB6")==SB6->B6_FILIAL
			
			If nX == 0
				::ExternalInvoices := {}
			EndIf
			nX++			
			aadd(::ExternalInvoices,WsClassNew("ExternalInvoiceView"))
			::ExternalInvoices[nX]:Status := "OPEN"
			nSaldo := (cAliasSB6)->B6_QUANT
			
			If (cAliasSB6)->B6_TIPO == 'D' //SD1
				 
				dbSelectArea("SD1")
				dbSetOrder(4)
				MsSeek(xFilial("SD1")+(cAliasSB6)->B6_IDENT)

				dbSelectArea("SF1")
				dbSetOrder(1)
				MsSeek(xFilial("SF1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_TIPO)
				
				DEFAULT ::ExternalInvoices[nX]:InvoiceShipment := WsClassNew("InvoiceHeaderView")
				                                                                                            
				GetNfeHead(::ExternalInvoices[nX]:InvoiceShipment,"SF1")
				
			Else                            //SD2
		
				dbSelectArea("SD2")
				dbSetOrder(4)
				MsSeek(xFilial("SD2")+(cAliasSB6)->B6_IDENT)

				dbSelectArea("SF2")
				dbSetOrder(1)
				MsSeek(xFilial("SF2")+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA)

				DEFAULT ::ExternalInvoices[nX]:InvoiceShipment := WsClassNew("InvoiceHeaderView")
				                                                                                            
				GetNfsHead(::ExternalInvoices[nX]:InvoiceShipment,"SF2")
				
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Procura os documentos de retorno de material                            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SB6")
			dbSetOrder(2)
			#IFDEF TOP
				lQuery    := .T.
				cAliasTMP := GetNextAlias()

				cQuery := "SELECT * "
				cQuery += "FROM "+RetSqlName("SB6")+" SB6 "
				cQuery += "WHERE SB6.B6_FILIAL='"+xFilial("SB6")+"' AND "
				cQuery += "SB6.B6_PRODUTO='"+(cAliasSB6)->B6_PRODUTO+"' AND "
				cQuery += "SB6.B6_IDENT='"+(cAliasSB6)->B6_IDENT+"' AND "
				cQuery += "SB6.B6_PODER3 = 'D' AND "
				If !Empty(::RegisterDateTo)
					cQuery += "SB6.B6_EMISSAO <= '"+Dtos(::RegisterDateTo)+"' AND "
				EndIf
				cQuery += "SB6.D_E_L_E_T_=' ' "
				
				cQuery := ChangeQuery(cQuery)

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTmp,.T.,.T.)

				For nY := 1 To Len(aStruSB6)
		  			If aStruSB6[nY][2] <> "C" .And. FieldPos(aStruSB6[nY][1])<>0
						TcSetField(cAliasTmp,aStruSB6[nY][1],aStruSB6[nY][2],aStruSB6[nY][3],aStruSB6[nY][4])
					EndIf
				Next nY

			#ENDIF
			nY := 0		
			While !Eof() .And. xFilial("SB6")==SB6->B6_FILIAL
			
				If aScan(aNotas,(cAliasTMP)->B6_DOC+(cAliasTMP)->B6_SERIE+(cAliasTMP)->B6_CLIFOR+(cAliasTMP)->B6_LOJA)==0
				
					aadd(aNotas,(cAliasTMP)->B6_DOC+(cAliasTMP)->B6_SERIE+(cAliasTMP)->B6_CLIFOR+(cAliasTMP)->B6_LOJA)
			
					If nY == 0
						::ExternalInvoices[nX]:InvoiceReturn := {}
					EndIf
					nY++				
					aadd(::ExternalInvoices[nX]:InvoiceReturn,WsClassNew("InvoiceHeaderView"))
					nSaldo -= (cAliasTmp)->B6_QUANT
					
					If (cAliasTmp)->B6_TIPO == 'E' //SD1
					 
						dbSelectArea("SF1")
						dbSetOrder(1)
						MsSeek(xFilial("SF1")+(cAliasTMP)->B6_DOC+(cAliasTMP)->B6_SERIE+(cAliasTMP)->B6_CLIFOR+(cAliasTMP)->B6_LOJA+IIf((cAliasTMP)->B6_TPCF=="C","B","N"))
					                                                                                            
						GetNfeHead(::ExternalInvoices[nX]:InvoiceReturn[nY],"SF1")
					
					Else                            //SD2
	
						dbSelectArea("SF2")
						dbSetOrder(1)
						MsSeek(xFilial("SF2")+(cAliasTMP)->B6_DOC+(cAliasTMP)->B6_SERIE+(cAliasTMP)->B6_CLIFOR+(cAliasTMP)->B6_LOJA)
					                                                                                            
						GetNfsHead(::ExternalInvoices[nX]:InvoiceReturn[nY],"SF2")
					
					EndIf
					
				EndIf				
				dbSelectArea(cAliasTMP)
				dbSkip()
				
			EndDo
			
			If nSaldo <= 0
				::ExternalInvoices[nX]:Status := "CLOSE"
			EndIf
			
			dbSelectArea(cAliasSB6)
			dbSkip()		
		EndDo
		
	Else
		lRetorno := .F.
		SetSoapFault("BRWEXTERNALINVOICE",STR0015) //"Produto nao cadastrado para este cliente"
	EndIf
Else
	lRetorno := .F.
EndIf
RestArea(aArea)
Return(lRetorno)

Function WsMt010a()
Return
