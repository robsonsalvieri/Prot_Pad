#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "TOTVS.CH"  
#include "rh.sigapon.integration.dashbh.ch"  

NameSpace totvs.protheus.rh.sigapon.dashbh

/*/{Protheus.doc} DbHrDepartaments
@type Function
@description Serviço para retorna o grupo de empresa
@author Marco Nakazawa
@since 06/03/2025
/*/
@GET("api/rh/v1/DbHrCompanyName")
Function DbHrCompanyName()
Local cCompany	:= ""					as Character
Local oResp		:= JsonObject():New()	as Json

cCompany := AllTrim(FWGrpName())

If (Empty(cCompany), cCompany := "TOTVS S.A", Nil)

oResp["company"] := cCompany

Return oRest:setResponse(oResp)

/*/{Protheus.doc} DbHrDepartaments
@type Function
@description Serviço para retornar os Departamentos
@author Marco Nakazawa
@since 06/03/2025
/*/
@GET("api/rh/v1/DbHrDepartaments")
Function DbHrDepartaments()
Local oResp			:= JsonObject():New()						as Json
Local aDeptos		:= {}										as Json
Local cAliasSQB		:= GetNextAlias()							as Character
Local cValidFil		:= fValidFil("SQB")							as Character
Local cAcesso		:= fSFiltrSQL(ChkRH("PONA500", "SQB", "1"))	as Character
Local cWhere		:= "%D_E_L_E_T_ = ' '"						as Character

If (!Empty(cAcesso), cWhere += " AND " + cAcesso + "%", cWhere += "%")

BeginSql alias cAliasSQB
	SELECT
	  QB_FILIAL,
	  QB_DEPTO,
	  QB_DESCRIC
	FROM %table:SQB% SQB
	WHERE %exp:cWhere%
	ORDER BY QB_FILIAL, QB_DEPTO, QB_DESCRIC
EndSql

While (cAliasSQB)->(!Eof())
	If (cAliasSQB)->QB_FILIAL $ cValidFil
		aAdd(aDeptos,{"label": AllTrim((cAliasSQB)->QB_DESCRIC) + " (" + AllTrim((cAliasSQB)->QB_FILIAL) + ")", "value": (cAliasSQB)->QB_DEPTO + "-" + (cAliasSQB)->QB_FILIAL})
	EndIf
	(cAliasSQB)->(dbSkip())
Enddo

(cAliasSQB)->(dbCloseArea())

oResp["departaments"] := aDeptos
oResp := oResp:ToJson()
Return oRest:setResponse(oResp)

/*/{Protheus.doc} DbHrCostCenters
@type Function
@description Serviço para retornar os Centros de Custos
@author Marco Nakazawa
@since 06/03/2025
/*/
@GET("api/rh/v1/DbHrCostCenters")
Function DbHrCostCenters()
Local oResp			:= JsonObject():New()						as Json
Local aCc			:= {}										as Json
Local cAliasCTT		:= GetNextAlias()							as Character
Local cValidFil		:= fValidFil("CTT")							as Character
Local cAcesso		:= fSFiltrSQL(ChkRH("PONA500", "CTT", "1"))	as Character
Local cWhere		:= "%D_E_L_E_T_ = ' '"						as Character

If (!Empty(cAcesso), cWhere += " AND " + cAcesso + "%", cWhere += "%")

BeginSql alias cAliasCTT
	SELECT
	  CTT_FILIAL,
	  CTT_CUSTO,
	  CTT_DESC01
	FROM %table:CTT% CTT
	WHERE %exp:cWhere%
	ORDER BY CTT_FILIAL, CTT_CUSTO, CTT_DESC01
EndSql

While (cAliasCTT)->(!Eof())
	If (cAliasCTT)->CTT_FILIAL $ cValidFil
		aAdd(aCc,{"label": AllTrim((cAliasCTT)->CTT_DESC01) + " (" + AllTrim((cAliasCTT)->CTT_FILIAL) + ")", "value": (cAliasCTT)->CTT_CUSTO + "-" + (cAliasCTT)->CTT_FILIAL})
	EndIf
	(cAliasCTT)->(dbSkip())
Enddo

(cAliasCTT)->(dbCloseArea())

oResp["costCenters"] := aCc
oResp := oResp:ToJson()
Return oRest:setResponse(oResp)

/*/{Protheus.doc} DbHrBalanceIndicator
@type Function
@description Serviço para retornar o saldo do banco de horas dos funcionários
@author Marco Nakazawa
@since 06/03/2025
/*/
@POST("api/rh/v1/DbHrBalanceIndicator")
Function DbHrBalanceIndicator()
Local oResp			:= JsonObject():New()						as Json
Local oJparams		:= JsonObject():New()						as Json
Local aFiliais		:= {}										as Array
Local aGestores		:= {}										as Array
Local aDeptos		:= {}										as Array
Local aCc			:= {}										as Array
Local aTotFunSld	:= {}										as Array
Local aTotFunPos	:= {}										as Array
Local aTotFunNeg	:= {}										as Array
Local cBody	    	:= oRest:getBodyRequest()					as Character
Local cAlias		:= GetNextAlias()							as Character
Local cJoiFilSPI	:= "%" + FWJoinFilial("SPI", "SRA") + "%"	as Character
Local cJoiFilSP9	:= "%" + FWJoinFilial("SP9", "SPI") + "%"	as Character
Local cJoiFilSQB	:= "%" + FWJoinFilial("SQB", "SRA") + "%"	as Character
Local cJoiFilCTT	:= "%" + FWJoinFilial("CTT", "SRA") + "%"	as Character
Local cDataDe		:= ""										as Character
Local cDataAte		:= "" 										as Character
Local cWhereFil		:= ""										as Character
Local cWhere		:= ""										as Character
Local cQryGestor	:= ""										as Character
Local cResp			:= ""										as Character
Local cWhereVnc		:= "%%"										as Character
Local cNomeSGDB 	:= Upper(TCGetDB())							as Character
Local lTemDtVnc		:= .F.										as Logical
Local nSaldoAtu		:= 0										as Numeric
Local nSaldoPer		:= 0										as Numeric
Local nSaldoPos		:= 0										as Numeric
Local nSaldoNeg		:= 0										as Numeric
Local oFilTemp		:= Nil										as Object

oJparams:FromJSON(cBody)

If checkParams(oJparams, .F.)
	cDataDe		:= StrTran(oJparams["startDate"],"-","")
	cDataAte	:= StrTran(oJparams["endDate"],"-","")
	aFiliais	:= oJparams["branch"]
	aDeptos		:= oJparams["departament"]
	aCc			:= oJparams["costCenter"]
	aGestores	:= oJparams["manager"]

	// Verifica se o campo PI_DTVENC existe
	lTemDtVnc := fChkDtVenc()

	// Se tiver o campo PI_DTVENC adiciona na Query
	If lTemDtVnc
		If Alltrim(cNomeSGDB) == "ORACLE" .Or. Alltrim(cNomeSGDB) == "POSTGRES"
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH IS NULL) %"
		Else
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH = ' ') %"
		EndIf
	EndIf
	// Montagem do Where das filais	e controle de acesso da SRA
	cWhere := cWhereFil := fFilQuery(aFiliais, @oFilTemp)
	
	// Montagem do Where dos departamentos
	cWhereDpto := fDptoQuery(aDeptos)
	If !Empty(cWhereDpto)
		cWhere += " AND " + cWhereDpto
	EndIf

	// Montagem do Where dos Centros de Custos
	cWhereCc := fCcQuery(aCc)
	If !Empty(cWhereCc)
		cWhere += " AND " + cWhereCc
	EndIf

	cWhere := "%" + cWhere + "%"

	// Montagem da query dos gestores
	cQryGestor := fGstQuery(aGestores, cWhereFil)

	BeginSql alias cAlias
		SELECT
		  SRA.RA_FILIAL,
		  SRA.RA_MAT,
		  SPI.PI_DATA,
		  SPI.PI_QUANT,
		  SP9.P9_TIPOCOD
		FROM %table:SRA% SRA
		%exp:cQryGestor%
		INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
		INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
		INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
		INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
		WHERE SRA.%notDel%
		  AND SPI.PI_STATUS = ' '
		  %exp:cWhereVnc%
		  AND %exp:cWhere%
		ORDER BY SRA.RA_FILIAL, SRA.RA_MAT
	EndSql

	While (cAlias)->(!Eof())
		If (cAlias)->P9_TIPOCOD $ "1*3"
			nSaldoAtu := SomaHoras(nSaldoAtu, (cAlias)->PI_QUANT)
			If (cAlias)->PI_DATA >= cDataDe .And. (cAlias)->PI_DATA <= cDataAte
				nSaldoPer := SomaHoras(nSaldoPer, (cAlias)->PI_QUANT)
				nSaldoPos := SomaHoras(nSaldoPos, (cAlias)->PI_QUANT)
				
				If aScan(aTotFunSld, {|x| x[1] == (cAlias)->RA_FILIAL .And. x[2] == (cAlias)->RA_MAT}) == 0
					aAdd(aTotFunSld,{(cAlias)->RA_FILIAL, (cAlias)->RA_MAT})
				EndIf
				
				If aScan(aTotFunPos, {|x| x[1] == (cAlias)->RA_FILIAL .And. x[2] == (cAlias)->RA_MAT}) == 0
					aAdd(aTotFunPos,{(cAlias)->RA_FILIAL, (cAlias)->RA_MAT})
				EndIf
			EndIf
		ElseIf (cAlias)->P9_TIPOCOD $ "2*4"
			nSaldoAtu := SubHoras(nSaldoAtu, (cAlias)->PI_QUANT)
			
			If (cAlias)->PI_DATA >= cDataDe .And. (cAlias)->PI_DATA <= cDataAte
				nSaldoPer := SubHoras(nSaldoPer, (cAlias)->PI_QUANT)
				nSaldoNeg := SubHoras(nSaldoNeg, (cAlias)->PI_QUANT)
				
				If aScan(aTotFunSld, {|x| x[1] == (cAlias)->RA_FILIAL .And. x[2] == (cAlias)->RA_MAT}) == 0
					aAdd(aTotFunSld,{(cAlias)->RA_FILIAL, (cAlias)->RA_MAT})
				EndIf
				
				If aScan(aTotFunNeg, {|x| x[1] == (cAlias)->RA_FILIAL .And. x[2] == (cAlias)->RA_MAT}) == 0
					aAdd(aTotFunNeg,{(cAlias)->RA_FILIAL, (cAlias)->RA_MAT})
				EndIf
			EndIf
		EndIf
		
		(cAlias)->(dbSkip())
	Enddo

	cResp := '{"results": [{"indicatorType": "CurrentBalance","hours": ' + cValToChar(nSaldoAtu) + '},{"indicatorType": "balance","hours": ' + cValToChar(nSaldoPer) + ',"totalEmployees": ' + cValToChar(Len(aTotFunSld)) + '},{"indicatorType": "positiveBalance","hours": ' + cValToChar(nSaldoPos) + ',"totalEmployees": ' + cValToChar(Len(aTotFunPos)) + '},{"indicatorType": "negativeBalance","hours": ' + cValToChar(nSaldoNeg) + ',"totalEmployees": ' + cValToChar(Len(aTotFunNeg)) + '}]}'

	oResp:FromJson(cResp)

	If ValType(oFilTemp) == "O"
		oFilTemp:Delete()
		FwFreeObj(oFilTemp)
	EndIf

	(cAlias)->(dbCloseArea())
Else
	SetRestFault(400, EncodeUTF8(STR0001))  // "Parâmetros inválidos: Verifique se os Parâmetros startDate, endDate, branch, departament, costCenter e manager foram enviados."
	oResp["return"] := "Error"
EndIf
Return oRest:setResponse(oResp)

/*/{Protheus.doc} DbHrHoursIndicator
@type Function
@description Serviço para retornar o saldo das horas a vencer e horas vencidas
@author Marco Nakazawa
@since 13/03/2025
/*/
@POST("api/rh/v1/DbHrHoursIndicator")
Function DbHrHoursIndicator()
Local oResp			:= JsonObject():New()						as Json
Local oJparams		:= JsonObject():New()						as Json
Local aFiliais		:= {}										as Array
Local aGestores		:= {}										as Array
Local aDeptos		:= {}										as Array
Local aCc			:= {}										as Array
Local aTotVencer	:= {}										as Array
Local aTotVencid	:= {}										as Array
Local cBody	    	:= oRest:getBodyRequest()					as Character
Local cAlias		:= GetNextAlias()							as Character
Local cJoiFilSPI	:= "%" + FWJoinFilial("SPI", "SRA") + "%"	as Character
Local cJoiFilSQB	:= "%" + FWJoinFilial("SQB", "SRA") + "%"	as Character
Local cJoiFilCTT	:= "%" + FWJoinFilial("CTT", "SRA") + "%"	as Character
Local cJoiFilSP9	:= "%" + FWJoinFilial("SP9", "SPI") + "%"	as Character
Local cDataDe		:= ""										as Character
Local cDataAte		:= "" 										as Character
Local cWhereFil		:= ""										as Character
Local cWhere		:= ""										as Character
Local cQryGestor	:= ""										as Character
Local cResp			:= ""										as Character
Local cNomeSGDB 	:= Upper(TCGetDB())							as Character
Local nVencidas		:= 0										as Numeric
Local nAVencer		:= 0										as Numeric
Local lTemDtVnc		:= .F.										as Logical
Local oFilTemp		:= Nil										as Object

oJparams:FromJSON(cBody)

If checkParams(oJparams, .F.)
	cDataDe		:= StrTran(oJparams["startDate"],"-","")
	cDataAte	:= StrTran(oJparams["endDate"],"-","")
	aFiliais	:= oJparams["branch"]
	aDeptos		:= oJparams["departament"]
	aCc			:= oJparams["costCenter"]
	aGestores	:= oJparams["manager"]

	// Montagem do Where das filais	e controle de acesso da SRA
	cWhere := cWhereFil := fFilQuery(aFiliais, @oFilTemp)
	
	// Verifica se o campo PI_DTVENC existe
	lTemDtVnc := fChkDtVenc()

	// Se tiver o campo PI_DTVENC adiciona o campo PI_MESESBH na Query
	If lTemDtVnc		
		If Alltrim(cNomeSGDB) == "ORACLE" .Or. Alltrim(cNomeSGDB) == "POSTGRES"
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH IS NULL) %"
		Else
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH = ' ') %"
		EndIf
	EndIf
	
	// Montagem do Where dos departamentos
	cWhereDpto := fDptoQuery(aDeptos)
	If !Empty(cWhereDpto)
		cWhere += " AND " + cWhereDpto
	EndIf

	// Montagem do Where dos Centros de Custos
	cWhereCc := fCcQuery(aCc)
	If !Empty(cWhereCc)
		cWhere += " AND " + cWhereCc
	EndIf

	cWhere := "%" + cWhere + "%"

	// Montagem da query dos gestores
	cQryGestor := fGstQuery(aGestores, cWhereFil)
	If lTemDtVnc
		BeginSql alias cAlias
			SELECT
			  SRA.RA_FILIAL,
			  SRA.RA_MAT,
			  SPI.PI_DATA,
			  SPI.PI_DTVENC,
			  SPI.PI_QUANT,
			  SP9.P9_TIPOCOD
			FROM %table:SRA% SRA
			%exp:cQryGestor%
			INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
			INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
			INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
			INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
			WHERE SRA.%notDel%
			  AND SPI.PI_STATUS = ' '
			  %exp:cWhereVnc%
			  AND SPI.PI_DTVENC <> ' '
			  AND %exp:cWhere%
			ORDER BY SRA.RA_FILIAL, SRA.RA_MAT
		EndSql

		While (cAlias)->(!Eof())
			If (cAlias)->PI_DTVENC <= cDataAte
				If ((cAlias)->P9_TIPOCOD $ "1*3", nVencidas := SomaHoras(nVencidas, (cAlias)->PI_QUANT), nVencidas := SubHoras(nVencidas, (cAlias)->PI_QUANT))

				If aScan(aTotVencid, {|x| x[1] == (cAlias)->RA_FILIAL .And. x[2] == (cAlias)->RA_MAT}) == 0
					aAdd(aTotVencid,{(cAlias)->RA_FILIAL, (cAlias)->RA_MAT})
				EndIf
			Else
				If ((cAlias)->P9_TIPOCOD $ "1*3", nAVencer := SomaHoras(nAVencer, (cAlias)->PI_QUANT), nAVencer := SubHoras(nAVencer, (cAlias)->PI_QUANT))

				If aScan(aTotVencer, {|x| x[1] == (cAlias)->RA_FILIAL .And. x[2] == (cAlias)->RA_MAT}) == 0
					aAdd(aTotVencer,{(cAlias)->RA_FILIAL, (cAlias)->RA_MAT})
				EndIf
			EndIf
			(cAlias)->(dbSkip())
		Enddo

		(cAlias)->(dbCloseArea())
	EndIf

	cResp := '{"results": [{"indicatorType": "hoursToExpire","hours": ' + cValToChar(nAVencer) +',"totalEmployees": ' + cValToChar(Len(aTotVencer)) + '},{"indicatorType": "expiredHours","hours": ' + cValToChar(nVencidas) + ',"totalEmployees": ' + cValToChar(Len(aTotVencid)) + '}]}'

	oResp:FromJson(cResp)

	If ValType(oFilTemp) == "O"
		oFilTemp:Delete()
		FwFreeObj(oFilTemp)
	EndIf
Else
	SetRestFault(400, EncodeUTF8(STR0001))  // "Parâmetros inválidos: Verifique se os Parâmetros startDate, endDate, branch, departament, costCenter e manager foram enviados."
	oResp["return"] := "Error"
EndIf
Return oRest:setResponse(oResp)

/*/{Protheus.doc} DbHrDetailsBalance
@type Function
@description Serviço para retornar o detalhamento do saldo, horas positivas, negativas, a vencer e vencidas
@author Marco Nakazawa
@since 06/03/2025
/*/
@POST("api/rh/v1/DbHrDetailsBalance")
Function DbHrDetailsBalance()
Local oResp			:= JsonObject():New()						as Json
Local oJparams		:= JsonObject():New()						as Json
Local oBuscaAvnd	:= JsonObject():New()						as Json
Local aFiliais		:= {}										as Array
Local aGestores		:= {}										as Array
Local aDeptos		:= {}										as Array
Local aCc			:= {}										as Array
Local cBody	    	:= oRest:getBodyRequest()					as Character
Local cAlias		:= GetNextAlias()							as Character
Local cAliasTot		:= GetNextAlias()							as Character
Local cJoiFilSPI	:= "%" + FWJoinFilial("SPI", "SRA") + "%"	as Character
Local cJoiFilSQB	:= "%" + FWJoinFilial("SQB", "SRA") + "%"	as Character
Local cJoiFilCTT	:= "%" + FWJoinFilial("CTT", "SRA") + "%"	as Character
Local cJoiFilSRJ	:= "%" + FWJoinFilial("SRJ", "SRA") + "%"	as Character
Local cJoiFilSP9	:= "%" + FWJoinFilial("SP9", "SPI") + "%"	as Character
Local cDataDe		:= ""										as Character
Local cDataAte		:= "" 										as Character
Local cWhereFil		:= ""										as Character
Local cWhere		:= ""										as Character
Local cQryGestor	:= ""										as Character
Local cTipoInd		:= ""										as Character
Local cDtVenc		:= "%%"										as Character
Local cWhereInd		:= ""										as Character
Local cResp			:= ""										as Character
Local cMatFunc		:= ""										as Character
Local cFilFunc		:= ""										as Character
Local cEmpNome		:= ""										as Character
Local cRows			:= ""										as Character
Local cWhereVnc		:= "%%"										as Character
Local cPaginacao	:= "%%"										as Character
Local cQryBuscAd	:= ""										as Character
Local cBuscEmp		:= ""										as Character
Local cLastFil		:= ""										as Character
Local cNomeSGDB 	:= Upper(TCGetDB())							as Character
Local nPage			:= 0										as Numeric
Local nPageSize		:= 0										as Numeric
Local nTotFuncs		:= 0										as Numeric
Local nTotHoras		:= 0										as Numeric
Local nTotPags		:= 0										as Numeric
Local lTemDtVnc		:= .F.										as Logical
Local lBuscEmp		:= .F.										as Logical
Local oFilTemp		:= Nil										as Object

oJparams:FromJSON(cBody)

If checkParams(oJparams, .F.)
	cDataDe		:= StrTran(oJparams["startDate"],"-","")
	cDataAte	:= StrTran(oJparams["endDate"],"-","")
	aFiliais	:= oJparams["branch"]
	aDeptos		:= oJparams["departament"]
	aCc			:= oJparams["costCenter"]
	aGestores	:= oJparams["manager"]
	oBuscaAvnd	:= oJparams["advancededSearch"]

	If (oJparams["indicatorType"] == Nil, cTipoInd := "balance", cTipoInd := oJparams["indicatorType"])
	If (oJparams["page"] == Nil, nPage := 1, nPage := oJparams["page"])
	If (oJparams["pageSize"] == Nil, nPageSize := 10, nPageSize := oJparams["pageSize"])

	// Verifica se o campo PI_DTVENC existe
	lTemDtVnc := fChkDtVenc()

	// Se tiver o campo PI_DTVENC adiciona na Query
	If lTemDtVnc
		cDtVenc := "%SPI.PI_DTVENC,%"

		If Alltrim(cNomeSGDB) == "ORACLE" .Or. Alltrim(cNomeSGDB) == "POSTGRES"
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH IS NULL) %"
		Else
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH = ' ') %"
		EndIf
	EndIf
	
	// Montagem do Where das filais	e controle de acesso da SRA
	cWhere := cWhereFil := fFilQuery(aFiliais, @oFilTemp)
		
	// Montagem do Where dos departamentos
	cWhereDpto := fDptoQuery(aDeptos)
	If !Empty(cWhereDpto)
		cWhere += " AND " + cWhereDpto
	EndIf

	// Montagem do Where dos Centros de Custos
	cWhereCc := fCcQuery(aCc)
	If !Empty(cWhereCc)
		cWhere += " AND " + cWhereCc
	EndIf

	// Montagem da query da busca avançada
	If oBuscaAvnd:HasProperty("company")
		cQryBuscAd := fQryBuscAd(oBuscaAvnd)

		If !Empty(cQryBuscAd)
			cWhere += cQryBuscAd
		EndIf

		If oBuscaAvnd:HasProperty("company") .And. !Empty(oBuscaAvnd["company"])
			lBuscEmp := .T.
			cBuscEmp := Upper(AllTrim(oBuscaAvnd["company"]))
		EndIf
	EndIf

	cWhere := "%" + cWhere + "%"

	// Montagem da query dos gestores
	cQryGestor := fGstQuery(aGestores, cWhereFil)
	
	If cTipoInd == "balance"
		cWhereInd := "% AND (SPI.PI_DATA >= '" + cDataDe + "' AND SPI.PI_DATA <= '" + cDataAte + "')%"
	ElseIf cTipoInd == "positive"
		cWhereInd := "% AND (SP9.P9_TIPOCOD IN ('1','3') AND (SPI.PI_DATA >= '" + cDataDe + "' AND SPI.PI_DATA <= '" + cDataAte + "'))%"
	ElseIf cTipoInd == "negative"
		cWhereInd := "% AND (SP9.P9_TIPOCOD IN ('2','4') AND (SPI.PI_DATA >= '" + cDataDe + "' AND SPI.PI_DATA <= '" + cDataAte + "'))%"
	ElseIf cTipoInd == "hoursToExpire"
		If (lTemDtVnc, cWhereInd := "% AND (SPI.PI_DTVENC > '" + cDataAte + "' AND SPI.PI_DTVENC <> ' ')%", cWhereInd := "%%")
	ElseIf cTipoInd == "expiredHours"
		If (lTemDtVnc, cWhereInd := "% AND (SPI.PI_DTVENC <= '" + cDataAte + "' AND SPI.PI_DTVENC <> ' ')%", cWhereInd := "%%")
	Else
		// Qualquer texto diferente do definido irá filtrar o saldo do banco de horas, apenas para não gerar error log na query que será executada.
		cWhereInd := "% AND (SPI.PI_DATA >= '" + cDataDe + "' AND SPI.PI_DATA <= '" + cDataAte + "')%"
	EndIf
	
	If (lTemDtVnc .And. (cTipoInd == "hoursToExpire" .Or. cTipoInd == "expiredHours")) .Or. (cTipoInd $ "balance*positive*negative")
		BeginSql alias cAliasTot
			SELECT 
				SRA.RA_FILIAL,
				SRA.RA_MAT
			FROM %table:SRA% SRA
			%exp:cQryGestor%
			INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
			INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
			INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
			INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
			LEFT JOIN %table:SRJ% SRJ ON %exp:cJoiFilSRJ% AND SRJ.RJ_FUNCAO = SRA.RA_CODFUNC AND SRJ.%notDel%
			WHERE SRA.%notDel%
			%exp:cWhereVnc%
			AND SPI.PI_STATUS = ' '
			%exp:cWhereInd%
			AND %exp:cWhere%
			GROUP BY SRA.RA_FILIAL, SRA.RA_MAT
		EndSql

		While (cAliasTot)->(!Eof())
			If lBuscEmp
				If cFilFunc <> (cAliasTot)->RA_FILIAL
					cEmpNome := Upper(AllTrim(FWCompanyName(cEmpAnt,(cAliasTot)->RA_FILIAL)))
					cFilFunc := (cAliasTot)->RA_FILIAL
				EndIf

				If cBuscEmp $ cEmpNome
					nTotFuncs++
				EndIf
			Else
				nTotFuncs++
			EndIf
			(cAliasTot)->(dbSkip())
		Enddo

		cEmpNome := ""
		cFilFunc := ""

		(cAliasTot)->(dbCloseArea())
	EndIf

	If nTotFuncs > 0
		If Alltrim(cNomeSGDB) == "ORACLE" .Or. Alltrim(cNomeSGDB) == "MSSQL"
			cPaginacao := "% OFFSET " + cValToChar((nPage-1) * nPageSize) + " ROWS FETCH NEXT " + cValToChar(nPageSize) + " ROWS ONLY %"
		ElseIf Alltrim(cNomeSGDB) == "POSTGRES"
			cPaginacao := "% LIMIT " + cValToChar(nPageSize) + " OFFSET " + cValToChar((nPage-1) * nPageSize) + " %"
		EndIf

		nTotPags := Int(nTotFuncs / nPageSize)

		If (nTotFuncs % nPageSize != 0, nTotPags++, Nil)

		BeginSql alias cAlias
			SELECT
			  FUNC.RA_FILIAL,
			  FUNC.RA_MAT,
			  FUNC.RA_NOME,
			  FUNC.RJ_DESC,
			  FUNC.QB_DESCRIC,
			  FUNC.RA_CC,
			  FUNC.CTT_DESC01,
			  FUNC.GESTOR,
			  SPI.PI_DATA,
			  %exp:cDtVenc%
			  SPI.PI_QUANT,
			  SP9.P9_TIPOCOD
			FROM %table:SPI% SPI
			INNER JOIN (
				SELECT 
				  SRA.RA_FILIAL,
				  SRA.RA_MAT,
				  SRA.RA_NOME,
				  SRA.RA_CC,
				  SRJ.RJ_DESC,
				  SQB.QB_DESCRIC,
				  CTT.CTT_DESC01,
				  SRAGEST.GESTOR,
				  SRAGEST.FILGESTOR,
				  SRAGEST.MATGESTOR
				FROM %table:SRA% SRA
				%exp:cQryGestor%
				INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
				INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
				INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
				INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
				LEFT JOIN %table:SRJ% SRJ ON %exp:cJoiFilSRJ% AND SRJ.RJ_FUNCAO = SRA.RA_CODFUNC AND SRJ.%notDel%
				WHERE SRA.%notDel%
				  %exp:cWhereVnc%
				  AND SPI.PI_STATUS = ' '
				  %exp:cWhereInd%
			 	  AND %exp:cWhere%
				GROUP BY SRA.RA_FILIAL, SRA.RA_MAT, SRA.RA_NOME, SRA.RA_CC, SRJ.RJ_DESC, SQB.QB_DESCRIC, CTT.CTT_DESC01, SRAGEST.GESTOR, SRAGEST.FILGESTOR, SRAGEST.MATGESTOR
				ORDER BY SRA.RA_FILIAL, SRA.RA_MAT, SRA.RA_NOME, SRA.RA_CC, SRJ.RJ_DESC, SQB.QB_DESCRIC, CTT.CTT_DESC01, SRAGEST.GESTOR, SRAGEST.FILGESTOR, SRAGEST.MATGESTOR
				%exp:cPaginacao%
			) FUNC ON FUNC.RA_FILIAL = SPI.PI_FILIAL AND FUNC.RA_MAT = SPI.PI_MAT
			INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD
			WHERE SPI.%notDel%
			  %exp:cWhereVnc%
			  AND SP9.%notDel%
			  %exp:cWhereInd%
			ORDER BY FUNC.RA_FILIAL, FUNC.RA_MAT
		EndSql

		While (cAlias)->(!Eof())
			If cLastFil <> (cAlias)->RA_FILIAL
				cEmpNome := AllTrim(FWCompanyName(cEmpAnt, (cAlias)->RA_FILIAL))
				cLastFil := (cAlias)->RA_FILIAL
			EndIf

			If lBuscEmp
				If !(cBuscEmp $ Upper(cEmpNome))
					(cAlias)->(dbSkip())
					Loop
				EndIf
			EndIf

			If Empty(cFilFunc)
				nTotHoras := 0

				cFilFunc := (cAlias)->RA_FILIAL
				cMatFunc := (cAlias)->RA_MAT
				
				cRows := '"rows": [{'
				cRows += '"company": "' + cEmpNome + '",'
				cRows += '"branch": "' + AllTrim((cAlias)->RA_FILIAL) + '",'
				cRows += '"name": "' + AllTrim((cAlias)->RA_NOME) + '",'
				cRows += '"registration": "' + (cAlias)->RA_MAT + '",'
				cRows += '"position": "' + AllTrim((cAlias)->RJ_DESC) + '",'
				cRows += '"costCenters": "' + AllTrim((cAlias)->CTT_DESC01) + '",'
				cRows += '"manager": "' + AllTrim((cAlias)->GESTOR) + '",'
				cRows += '"departament": "' + AllTrim((cAlias)->QB_DESCRIC) + '",'
				cRows += '"totalHours": ***TotHoras***,'
				cRows += '"details": ['
				cRows += '{'
				cRows += '"hours": ' + If((cAlias)->P9_TIPOCOD $ "1*3", cValToChar((cAlias)->PI_QUANT), cValToChar((cAlias)->PI_QUANT * -1)) + ','
				cRows += '"deadLine": "' + If(lTemDtVnc, fFormtDt((cAlias)->PI_DTVENC), '') + '"'
				cRows += '}'

				If((cAlias)->P9_TIPOCOD $ "1*3", nTotHoras := SomaHoras(nTotHoras,(cAlias)->PI_QUANT), nTotHoras := SubHoras(nTotHoras,(cAlias)->PI_QUANT))				
			ElseIf (cFilFunc <> (cAlias)->RA_FILIAL .Or. cMatFunc <> (cAlias)->RA_MAT)
				cRows := StrTran(cRows, "***TotHoras***", cValToChar(nTotHoras))

				nTotHoras := 0

				If cFilFunc <> (cAlias)->RA_FILIAL
					cEmpNome := AllTrim(FWCompanyName(cEmpAnt,(cAlias)->RA_FILIAL))
				EndIf

				cRows += ']},'
				cRows += '{'
				cRows += '"company": "' + cEmpNome + '",'
				cRows += '"branch": "' + AllTrim((cAlias)->RA_FILIAL) + '",'
				cRows += '"name": "' + AllTrim((cAlias)->RA_NOME) + '",'
				cRows += '"registration": "' + (cAlias)->RA_MAT + '",'
				cRows += '"position": "' + AllTrim((cAlias)->RJ_DESC) + '",'
				cRows += '"costCenters": "' + AllTrim((cAlias)->CTT_DESC01) + '",'
				cRows += '"manager": "' + AllTrim((cAlias)->GESTOR) + '",'
				cRows += '"departament": "' + AllTrim((cAlias)->QB_DESCRIC) + '",'
				cRows += '"totalHours": ***TotHoras***,'
				cRows += '"details": ['
				cRows += '{'
				cRows += '"hours": ' + If((cAlias)->P9_TIPOCOD $ "1*3", cValToChar((cAlias)->PI_QUANT), cValToChar((cAlias)->PI_QUANT * -1)) + ','
				cRows += '"deadLine": "' + If(lTemDtVnc, fFormtDt((cAlias)->PI_DTVENC), '') + '"'
				cRows += '}'
				
				If((cAlias)->P9_TIPOCOD $ "1*3", nTotHoras := SomaHoras(nTotHoras,(cAlias)->PI_QUANT), nTotHoras := SubHoras(nTotHoras,(cAlias)->PI_QUANT))

				cFilFunc := (cAlias)->RA_FILIAL
				cMatFunc := (cAlias)->RA_MAT
			Else
				cRows += ',{'
				cRows += '"hours": ' + If((cAlias)->P9_TIPOCOD $ "1*3", cValToChar((cAlias)->PI_QUANT), cValToChar((cAlias)->PI_QUANT * -1)) + ','
				cRows += '"deadLine": "' + If(lTemDtVnc, fFormtDt((cAlias)->PI_DTVENC), '') + '"'
				cRows += '}'
			
				If((cAlias)->P9_TIPOCOD $ "1*3", nTotHoras := SomaHoras(nTotHoras,(cAlias)->PI_QUANT), nTotHoras := SubHoras(nTotHoras,(cAlias)->PI_QUANT))
			EndIf

			(cAlias)->(dbSkip())
		Enddo

		(cAlias)->(dbCloseArea())
	EndIf

	If !Empty(cRows)
		cRows := StrTran(cRows, "***TotHoras***", cValToChar(nTotHoras))
		cRows += "]}]"
	Else
		cRows := '"rows": []'
	EndIf

	cResp := '{"totalPages":' + cValToChar(nTotPags) + ', ' + cRows + '}'

	oResp:FromJson(cResp)

	If ValType(oFilTemp) == "O"
		oFilTemp:Delete()
		FwFreeObj(oFilTemp)
	EndIf
Else
	SetRestFault(400, EncodeUTF8(STR0001))  // "Parâmetros inválidos: Verifique se os Parâmetros startDate, endDate, branch, departament, costCenter e manager foram enviados."
	oResp["return"] := "Error"
EndIf
Return oRest:setResponse(oResp)

/*/{Protheus.doc} DbHrCharts
@type Function
@description Serviço para retornar os destaques do banco de horas e o saldo por período para montagem dos gráficos
@author Marco Nakazawa
@since 18/03/2025
/*/
@POST("api/rh/v1/DbHrCharts")
Function DbHrCharts()
Local oResp			:= JsonObject():New()						as Json
Local oJparams		:= JsonObject():New()						as Json
Local aFiliais		:= {}										as Array
Local aGestores		:= {}										as Array
Local aDeptos		:= {}										as Array
Local aCc			:= {}										as Array
Local aPeriodos		:= {}										as Array
Local aDestqFil		:= {}										as Array
Local aDestqCc		:= {}										as Array
Local aDestqDpto	:= {}										as Array
Local aDestqGstr	:= {}										as Array
Local aChartFil		:= {}										as Array
Local aChartDpto	:= {}										as Array
Local aChartCc		:= {}										as Array
Local aChartGstr	:= {}										as Array
Local cBody	    	:= oRest:getBodyRequest()					as Character
Local cAlias		:= GetNextAlias()							as Character
Local cJoiFilSPI	:= "%" + FWJoinFilial("SPI", "SRA") + "%"	as Character
Local cJoiFilSQB	:= "%" + FWJoinFilial("SQB", "SRA") + "%"	as Character
Local cJoiFilCTT	:= "%" + FWJoinFilial("CTT", "SRA") + "%"	as Character
Local cJoiFilSRJ	:= "%" + FWJoinFilial("SRJ", "SRA") + "%"	as Character
Local cJoiFilSP9	:= "%" + FWJoinFilial("SP9", "SPI") + "%"	as Character
Local cDataDe		:= ""										as Character
Local cDataAte		:= "" 										as Character
Local cWhereFil		:= ""										as Character
Local cWhere		:= ""										as Character
Local cQryGestor	:= ""										as Character
Local cResp			:= ""										as Character
Local cWhereVnc		:= "%%"										as Character
Local cNomeSGDB 	:= Upper(TCGetDB())							as Character
Local lTemGestor	:= .F.										as Logical
Local lTemDtVnc		:= .F.										as Logical
Local oFilTemp		:= Nil										as Object

oJparams:FromJSON(cBody)

If checkParams(oJparams, .F.)
	cDataDe		:= StrTran(oJparams["startDate"],"-","")
	cDataAte	:= StrTran(oJparams["endDate"],"-","")
	aFiliais	:= oJparams["branch"]
	aDeptos		:= oJparams["departament"]
	aCc			:= oJparams["costCenter"]
	aGestores	:= oJparams["manager"]
	lTemGestor	:= !oJparams["managerIsEmpty"]
	aPeriodos	:= fMontaPer(cDataDe, cDataAte)

	// Verifica se o campo PI_DTVENC existe
	lTemDtVnc := fChkDtVenc()

	// Se tiver o campo PI_DTVENC adiciona na Query
	If lTemDtVnc		
		If Alltrim(cNomeSGDB) == "ORACLE" .Or. Alltrim(cNomeSGDB) == "POSTGRES"
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH IS NULL) %"
		Else
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH = ' ') %"
		EndIf
	EndIf

	// Montagem do Where das filais	e controle de acesso da SRA
	cWhere := cWhereFil := fFilQuery(aFiliais, @oFilTemp)
	
	// Montagem do Where dos departamentos
	cWhereDpto := fDptoQuery(aDeptos)
	If !Empty(cWhereDpto)
		cWhere += " AND " + cWhereDpto
	EndIf

	// Montagem do Where dos Centros de Custos
	cWhereCc := fCcQuery(aCc)
	If !Empty(cWhereCc)
		cWhere += " AND " + cWhereCc
	EndIf

	cWhere := "%" + cWhere + "%"

	// Montagem da query dos gestores
	cQryGestor := fGstQuery(aGestores, cWhereFil)
	
	BeginSql alias cAlias
		SELECT 
			SRA.RA_FILIAL,
			SRA.RA_MAT,
			SRA.RA_NOME,
			SRJ.RJ_DESC,
			SQB.QB_FILIAL,
			SQB.QB_DEPTO,
			SQB.QB_DESCRIC,
			CTT.CTT_FILIAL,
			CTT.CTT_CUSTO,
			CTT.CTT_DESC01,
			SRAGEST.GESTOR,
			SRAGEST.FILGESTOR,
			SRAGEST.MATGESTOR,
			SPI.PI_DATA,
			SPI.PI_QUANT,
			SP9.P9_TIPOCOD
		FROM %table:SRA% SRA
		%exp:cQryGestor%
		INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
		INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
		INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
		INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
		LEFT JOIN %table:SRJ% SRJ ON %exp:cJoiFilSRJ% AND SRJ.RJ_FUNCAO = SRA.RA_CODFUNC AND SRJ.%notDel%
		WHERE %exp:cWhere%
		  AND SRA.%notDel%
		  AND (SPI.PI_DATA >= %exp:cDataDe% AND SPI.PI_DATA <= %exp:cDataAte%)
		  AND SPI.PI_STATUS = ' '
		  %exp:cWhereVnc%
		ORDER BY SRA.RA_FILIAL, SPI.PI_DATA
	EndSql

	While (cAlias)->(!Eof())
		// Atualiza os saldos dos graficos por período
		fAtuGrafic(@aChartFil, sToD((cAlias)->PI_DATA), (cAlias)->PI_QUANT, (cAlias)->P9_TIPOCOD, AllTrim((cAlias)->RA_FILIAL), aPeriodos)
		
		fAtuGrafic(@aChartDpto, sToD((cAlias)->PI_DATA), (cAlias)->PI_QUANT, (cAlias)->P9_TIPOCOD, AllTrim((cAlias)->QB_DESCRIC) + " (" + AllTrim((cAlias)->QB_FILIAL) + " - " + AllTrim((cAlias)->QB_DEPTO) + ")", aPeriodos)
		
		fAtuGrafic(@aChartCc, sToD((cAlias)->PI_DATA), (cAlias)->PI_QUANT, (cAlias)->P9_TIPOCOD, AllTrim((cAlias)->CTT_DESC01) + " (" + AllTrim((cAlias)->CTT_FILIAL) + " - " + AllTrim((cAlias)->CTT_CUSTO) + ")", aPeriodos)
		
		If lTemGestor
			If !Empty((cAlias)->MATGESTOR)
				fAtuGrafic(@aChartGstr, sToD((cAlias)->PI_DATA), (cAlias)->PI_QUANT, (cAlias)->P9_TIPOCOD, AllTrim((cAlias)->GESTOR) + " (" + AllTrim((cAlias)->FILGESTOR) + " - " + AllTrim((cAlias)->MATGESTOR) + ")", aPeriodos)
			EndIf
		EndIf
		
		(cAlias)->(dbSkip())
	Enddo

	// Atualiza o saldo dos períodos que não tiveram qualquer lançamento com o ultimo saldo que possui lançamentos.
	fAtuSaldo(@aChartFil)
	fAtuSaldo(@aChartDpto)
	fAtuSaldo(@aChartCc)
	
	If lTemGestor
		fAtuSaldo(@aChartGstr)
	EndIf

	// Gera os detaques dos gráficos
	aDestqFil	:= fCalcDestq(aChartFil)
	aDestqDpto	:= fCalcDestq(aChartDpto)
	aDestqCc	:= fCalcDestq(aChartCc)

	If lTemGestor
		aDestqGstr	:= fCalcDestq(aChartGstr)
	EndIf

	cResp := '{'
	cResp += 	'"highlights": ['
	cResp += 		fJsonDestq(aDestqFil, "branches")
	cResp += 		','
	cResp += 		fJsonDestq(aDestqDpto, "departaments")
	cResp += 		','
	cResp += 		fJsonDestq(aDestqCc, "costCenters")
	
	If lTemGestor
		cResp += 		','
		cResp += 		fJsonDestq(aDestqGstr, "managers")
	EndIf
	
	cResp += 	'],'
	cResp += 	'"charts": ['
	cResp += 		fJsonChart(aChartFil, "branches", .F.)
	cResp += 		','
	cResp += 		fJsonChart(aChartDpto, "departaments", .F.)
	cResp += 		','
	cResp += 		fJsonChart(aChartCc, "costCenters", .F.)

	If lTemGestor
		cResp += 		','
		cResp += 		fJsonChart(aChartGstr, "managersPieChart", .T.)
		cResp += 		','
		cResp += 		fJsonChart(aChartGstr, "managers", .F.)
	EndIf

	cResp += 	']'
	cResp += "}"

	oResp:FromJson(cResp)

	If ValType(oFilTemp) == "O"
		oFilTemp:Delete()
		FwFreeObj(oFilTemp)
	EndIf

	(cAlias)->(dbCloseArea())
Else
	SetRestFault(400, EncodeUTF8(STR0001))  // "Parâmetros inválidos: Verifique se os Parâmetros startDate, endDate, branch, departament, costCenter e manager foram enviados."
	oResp["return"] := "Error"
EndIf
Return oRest:setResponse(oResp)

/*/{Protheus.doc} DbHrDetailsCharts
@type Function
@description Serviço para retornar o detalhamento dos gráficos de saldo de horas Filial, Departamento e Centro de Custo.
@author Marco Nakazawa
@since 06/03/2025
/*/
@POST("api/rh/v1/DbHrDetailsCharts")
Function DbHrDetailsCharts()
Local oResp			:= JsonObject():New()						as Json
Local oJparams		:= JsonObject():New()						as Json
Local oBuscaAvnd	:= JsonObject():New()						as Json
Local aFiliais		:= {}										as Array
Local aGestores		:= {}										as Array
Local aDeptos		:= {}										as Array
Local aCc			:= {}										as Array
Local aPeriodos		:= {}										as Array
Local aDados		:= {}										as Array
Local cBody	    	:= oRest:getBodyRequest()					as Character
Local cAlias		:= GetNextAlias()							as Character
Local cAliasTot		:= GetNextAlias()							as Character
Local cJoiFilSPI	:= "%" + FWJoinFilial("SPI", "SRA") + "%"	as Character
Local cJoiFilSQB	:= "%" + FWJoinFilial("SQB", "SRA") + "%"	as Character
Local cJoiFilCTT	:= "%" + FWJoinFilial("CTT", "SRA") + "%"	as Character
Local cJoiFilSP9	:= "%" + FWJoinFilial("SP9", "SPI") + "%"	as Character
Local cDataDe		:= ""										as Character
Local cDataAte		:= "" 										as Character
Local cWhereFil		:= ""										as Character
Local cWhere		:= ""										as Character
Local cQryGestor	:= ""										as Character
Local cTipoGrf		:= ""										as Character
Local cResp			:= ""										as Character
Local cRows			:= ""										as Character
Local cCampos		:= ""										as Character
Local cJoin			:= ""										as Character
Local cOrder		:= ""										as Character
Local cWhereVnc		:= "%%"										as Character
Local cLastFil		:= ""										as Character
Local cEmpNome		:= ""										as Character
Local cQryBuscAd	:= ""										as Character
Local cNomeSGDB 	:= Upper(TCGetDB())							as Character
Local nPage			:= 0										as Numeric
Local nPageSize		:= 0										as Numeric
Local nItens		:= 0										as Numeric
Local nTotPags		:= 0										as Numeric
Local lTemDtVnc		:= .F.										as Logical
Local lBuscEmp		:= .F.										as Logical
Local oFilTemp		:= Nil										as Object

oJparams:FromJSON(cBody)

If checkParams(oJparams, .F.)
	cDataDe		:= StrTran(oJparams["startDate"],"-","")
	cDataAte	:= StrTran(oJparams["endDate"],"-","")
	aFiliais	:= oJparams["branch"]
	aDeptos		:= oJparams["departament"]
	aCc			:= oJparams["costCenter"]
	aGestores	:= oJparams["manager"]
	oBuscaAvnd	:= oJparams["advancededSearch"]
	aPeriodos	:= fMontaPer(cDataDe, cDataAte)

	If (oJparams["chartType"] == Nil, cTipoGrf := "branches", cTipoGrf := oJparams["chartType"])
	If (oJparams["page"] == Nil, nPage := 1, nPage := oJparams["page"])
	If (oJparams["pageSize"] == Nil, nPageSize := 10, nPageSize := oJparams["pageSize"])

	// Verifica se o campo PI_DTVENC existe
	lTemDtVnc := fChkDtVenc()

	// Se tiver o campo PI_DTVENC adiciona o campo PI_MESESBH na Query
	If lTemDtVnc		
		If Alltrim(cNomeSGDB) == "ORACLE" .Or. Alltrim(cNomeSGDB) == "POSTGRES"
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH IS NULL) %"
		Else
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH = ' ') %"
		EndIf
	EndIf
	
	// Montagem do Where das filais	e controle de acesso da SRA
	cWhere := cWhereFil := fFilQuery(aFiliais, @oFilTemp)
		
	// Montagem do Where dos departamentos
	cWhereDpto := fDptoQuery(aDeptos)
	If !Empty(cWhereDpto)
		cWhere += " AND " + cWhereDpto
	EndIf

	// Montagem do Where dos Centros de Custos
	cWhereCc := fCcQuery(aCc)
	If !Empty(cWhereCc)
		cWhere += " AND " + cWhereCc
	EndIf
	
	// Montagem da query da busca avançada
	If oBuscaAvnd:HasProperty("company")
		cQryBuscAd := fQryBuscAd(oBuscaAvnd)

		If !Empty(cQryBuscAd)
			cWhere += cQryBuscAd
		EndIf

		If oBuscaAvnd:HasProperty("company") .And. !Empty(oBuscaAvnd["company"])
			lBuscEmp := .T.
			cBuscEmp := Upper(AllTrim(oBuscaAvnd["company"]))
		EndIf
	EndIf

	cWhere := "%" + cWhere + "%"

	// Montagem da query dos gestores
	cQryGestor := fGstQuery(aGestores, cWhereFil)

	If cTipoGrf == "branches"
		cCampos := "%SRA.RA_FILIAL%"
		cJoin	:= "%FUNC.RA_FILIAL = ITENS.RA_FILIAL%"
		cOrder	:= "%SRA.RA_FILIAL "
	ElseIf cTipoGrf == "departaments"
		cCampos := "%SRA.RA_FILIAL, SQB.QB_FILIAL, SQB.QB_DEPTO%"
		cJoin	:= "%FUNC.QB_FILIAL = ITENS.QB_FILIAL AND FUNC.QB_DEPTO = ITENS.QB_DEPTO%"
		cOrder 	:= "%SRA.RA_FILIAL, SQB.QB_FILIAL, SQB.QB_DEPTO "
	ElseIf cTipoGrf == "costCenters"
		cCampos := "%SRA.RA_FILIAL, CTT.CTT_FILIAL, CTT.CTT_CUSTO%"
		cJoin	:= "%FUNC.CTT_FILIAL = ITENS.CTT_FILIAL AND FUNC.CTT_CUSTO = ITENS.CTT_CUSTO%"
		cOrder 	:= "%SRA.RA_FILIAL, CTT.CTT_FILIAL, CTT.CTT_CUSTO "
	Else
		cCampos := "%SRA.RA_FILIAL%"
		cJoin	:= "%FUNC.RA_FILIAL = ITENS.RA_FILIAL%"
		cOrder	:= "%SRA.RA_FILIAL "
	EndIf

	BeginSql alias cAliasTot
		SELECT 
			%exp:cCampos%
		FROM %table:SRA% SRA
		%exp:cQryGestor%
		INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
		INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
		INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
		INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
		WHERE SRA.%notDel%
			AND SPI.PI_STATUS = ' '
			%exp:cWhereVnc%
			AND (SPI.PI_DATA >= %exp:cDataDe% AND SPI.PI_DATA <= %exp:cDataAte%)
			AND %exp:cWhere%
		GROUP BY %exp:cCampos%
	EndSql

	While (cAliasTot)->(!Eof())
		If lBuscEmp
			If cLastFil <> (cAliasTot)->RA_FILIAL
				cEmpNome := Upper(AllTrim(FWCompanyName(cEmpAnt,(cAliasTot)->RA_FILIAL)))
				cLastFil := (cAliasTot)->RA_FILIAL
			EndIf

			If cBuscEmp $ cEmpNome
				nItens++
			EndIf
		Else
			nItens++
		EndIf
		(cAliasTot)->(dbSkip())
	Enddo

	cEmpNome := ""
	cLastFil := ""
	
	If nItens > 0
		If Alltrim(cNomeSGDB) == "ORACLE" .Or. Alltrim(cNomeSGDB) == "MSSQL"
			cOrder += "OFFSET " + cValToChar((nPage-1) * nPageSize) + " ROWS FETCH NEXT " + cValToChar(nPageSize) + " ROWS ONLY %"
		ElseIf Alltrim(cNomeSGDB) == "POSTGRES"
			cOrder += "LIMIT " + cValToChar(nPageSize) + " OFFSET " + cValToChar((nPage-1) * nPageSize) + " %"
		EndIf

		nTotPags := Int(nItens / nPageSize)

		If (nItens % nPageSize != 0, nTotPags++, Nil)

		BeginSql alias cAlias
			SELECT
			  FUNC.RA_FILIAL,
			  FUNC.RA_MAT,
			  FUNC.RA_NOME,
			  FUNC.QB_FILIAL,
			  FUNC.QB_DEPTO,
			  FUNC.QB_DESCRIC,
			  FUNC.CTT_FILIAL,
			  FUNC.CTT_CUSTO,
			  FUNC.CTT_DESC01,
			  FUNC.FILGESTOR,
			  FUNC.MATGESTOR,
			  FUNC.GESTOR,
			  SPI.PI_DATA,
			  SPI.PI_QUANT,
			  SP9.P9_TIPOCOD
			FROM (
				SELECT 
				  SRA.RA_FILIAL,
				  SRA.RA_MAT,
				  SRA.RA_NOME,
				  SRA.RA_CC,
				  SQB.QB_FILIAL,
				  SQB.QB_DEPTO,
				  SQB.QB_DESCRIC,
				  CTT.CTT_FILIAL,
				  CTT.CTT_CUSTO,
				  CTT.CTT_DESC01,
				  SRAGEST.GESTOR,
				  SRAGEST.FILGESTOR,
				  SRAGEST.MATGESTOR
				FROM %table:SRA% SRA
				%exp:cQryGestor%
				INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
				INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
				INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
				INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
				WHERE SRA.%notDel%
				  AND SPI.PI_STATUS = ' '
				  %exp:cWhereVnc%
				  AND (SPI.PI_DATA >= %exp:cDataDe% AND SPI.PI_DATA <= %exp:cDataAte%)
			 	  AND %exp:cWhere%
				GROUP BY SRA.RA_FILIAL, SRA.RA_MAT, SRA.RA_NOME, SRA.RA_CC, SQB.QB_FILIAL, SQB.QB_DEPTO, SQB.QB_DESCRIC, CTT.CTT_FILIAL, CTT.CTT_CUSTO, CTT.CTT_DESC01, SRAGEST.GESTOR, SRAGEST.FILGESTOR, SRAGEST.MATGESTOR
			) FUNC
			INNER JOIN (
				SELECT 
				%exp:cCampos%
				FROM %table:SRA% SRA
				%exp:cQryGestor%
				INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
				INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
				INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
				INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
				WHERE SRA.%notDel%
				  AND SPI.PI_STATUS = ' '
				  %exp:cWhereVnc%
				  AND (SPI.PI_DATA >= %exp:cDataDe% AND SPI.PI_DATA <= %exp:cDataAte%)
				  AND %exp:cWhere%
				  GROUP BY %exp:cCampos%
				  ORDER BY %exp:cOrder%
			) ITENS ON %exp:cJoin%
			INNER JOIN %table:SPI% SPI ON FUNC.RA_FILIAL = SPI.PI_FILIAL AND FUNC.RA_MAT = SPI.PI_MAT
			INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD
			WHERE SPI.%notDel%
			  AND SP9.%notDel%
			  %exp:cWhereVnc%
			  AND (SPI.PI_DATA >= %exp:cDataDe% AND SPI.PI_DATA <= %exp:cDataAte%)
			ORDER BY FUNC.RA_FILIAL, FUNC.RA_MAT
		EndSql

		While (cAlias)->(!Eof())
			If cLastFil <> (cAlias)->RA_FILIAL
				cEmpNome := AllTrim(FWCompanyName(cEmpAnt,(cAlias)->RA_FILIAL))
				cLastFil := (cAlias)->RA_FILIAL
			EndIf

			If lBuscEmp
				If !(cBuscEmp $ Upper(cEmpNome))
					(cAlias)->(dbSkip())
					Loop
				EndIf
			EndIf

			// Atualiza os saldos dos graficos por período
			If cTipoGrf == "branches"
				fAtuGrafic(@aDados, sToD((cAlias)->PI_DATA), (cAlias)->PI_QUANT, (cAlias)->P9_TIPOCOD, AllTrim((cAlias)->RA_FILIAL), aPeriodos, .T., {AllTrim((cAlias)->RA_FILIAL), AllTrim((cAlias)->RA_MAT), AllTrim((cAlias)->RA_NOME)})
			ElseIf cTipoGrf == "departaments"
				fAtuGrafic(@aDados, sToD((cAlias)->PI_DATA), (cAlias)->PI_QUANT, (cAlias)->P9_TIPOCOD, AllTrim((cAlias)->QB_DESCRIC) + " (" + AllTrim((cAlias)->QB_FILIAL) + " - " + AllTrim((cAlias)->QB_DEPTO) + ")", aPeriodos, .T., {AllTrim((cAlias)->RA_FILIAL), AllTrim((cAlias)->RA_MAT), AllTrim((cAlias)->RA_NOME)})
			ElseIf cTipoGrf == "costCenters"
				fAtuGrafic(@aDados, sToD((cAlias)->PI_DATA), (cAlias)->PI_QUANT, (cAlias)->P9_TIPOCOD, AllTrim((cAlias)->CTT_DESC01) + " (" + AllTrim((cAlias)->CTT_FILIAL) + " - " + AllTrim((cAlias)->CTT_CUSTO) + ")", aPeriodos, .T., {AllTrim((cAlias)->RA_FILIAL), AllTrim((cAlias)->RA_MAT), AllTrim((cAlias)->RA_NOME)})
			Else
				fAtuGrafic(@aDados, sToD((cAlias)->PI_DATA), (cAlias)->PI_QUANT, (cAlias)->P9_TIPOCOD, AllTrim((cAlias)->RA_FILIAL), aPeriodos, .T., {AllTrim((cAlias)->RA_FILIAL), AllTrim((cAlias)->RA_MAT), AllTrim((cAlias)->RA_NOME)})
			EndIf
			(cAlias)->(dbSkip())
		Enddo
	EndIf

	// Atualiza o saldo do gráfico e dos funcionários
	fAtuSaldo(@aDados, .T.)

	// Gera o Json do detalhamento do gráfico somente se houver dados
	If Len(aDados) > 0
		cRows := fJsonDtCht(aDados)
	Else
		cRows := '"rows": []'
	EndIf

	cResp := '{"totalPages":' + cValToChar(nTotPags) + ', ' + cRows + '}'

	oResp:FromJson(cResp)

	If ValType(oFilTemp) == "O"
		oFilTemp:Delete()
		FwFreeObj(oFilTemp)
	EndIf

	(cAliasTot)->(dbCloseArea())
	If (nItens > 0, (cAlias)->(dbCloseArea()), Nil)
Else
	SetRestFault(400, EncodeUTF8(STR0001))  // "Parâmetros inválidos: Verifique se os Parâmetros startDate, endDate, branch, departament, costCenter e manager foram enviados."
	oResp["return"] := "Error"
EndIf
Return oRest:setResponse(oResp)

/*/{Protheus.doc} DbHrDetailsManagersCharts
@type Function
@description Serviço para retornar o detalhamento dos gráficos dos gestores.
@author Marco Nakazawa
@since 06/03/2025
/*/
@POST("api/rh/v1/DbHrDetailsManagersCharts")
Function DbHrDetailsManagersCharts()
Local oResp			:= JsonObject():New()						as Json
Local oJparams		:= JsonObject():New()						as Json
Local oBuscaAvnd	:= JsonObject():New()						as Json
Local aFiliais		:= {}										as Array
Local aGestores		:= {}										as Array
Local aDeptos		:= {}										as Array
Local aCc			:= {}										as Array
Local aPeriodos		:= {}										as Array
Local aDados		:= {}										as Array
Local cBody	    	:= oRest:getBodyRequest()					as Character
Local cAlias		:= GetNextAlias()							as Character
Local cAliasTot		:= GetNextAlias()							as Character
Local cJoiFilSPI	:= "%" + FWJoinFilial("SPI", "SRA") + "%"	as Character
Local cJoiFilSQB	:= "%" + FWJoinFilial("SQB", "SRA") + "%"	as Character
Local cJoiFilCTT	:= "%" + FWJoinFilial("CTT", "SRA") + "%"	as Character
Local cJoiFilSP9	:= "%" + FWJoinFilial("SP9", "SPI") + "%"	as Character
Local cDataDe		:= ""										as Character
Local cDataAte		:= "" 										as Character
Local cWhereFil		:= ""										as Character
Local cWhere		:= ""										as Character
Local cQryGestor	:= ""										as Character
Local cResp			:= ""										as Character
Local cRows			:= ""										as Character
Local cWhereVnc		:= "%%"										as Character
Local cPaginacao	:= ""										as Character
Local cFilFunc	 	:= ""										as Character
Local cEmpNome	 	:= ""										as Character
Local cLastFil	 	:= ""										as Character
Local cQryBuscAd	:= ""										as Character
Local cBuscEmp		:= ""										as Character
Local cNomeSGDB 	:= Upper(TCGetDB())							as Character
Local nPage			:= 0										as Numeric
Local nPageSize		:= 0										as Numeric
Local nTotGestor	:= 0										as Numeric
Local nTotPags		:= 0										as Numeric
Local nLenDados		:= 0										as Numeric
Local nLenFuncs		:= 0										as Numeric
Local nI			:= 0										as Numeric
Local nX			:= 0										as Numeric
Local lTemDtVnc		:= .F.										as Logical
Local lBuscEmp		:= .F.										as Logical
Local oFilTemp		:= Nil										as Object

oJparams:FromJSON(cBody)

If checkParams(oJparams, .F.)
	cDataDe		:= StrTran(oJparams["startDate"],"-","")
	cDataAte	:= StrTran(oJparams["endDate"],"-","")
	aFiliais	:= oJparams["branch"]
	aDeptos		:= oJparams["departament"]
	aCc			:= oJparams["costCenter"]
	aGestores	:= oJparams["manager"]
	oBuscaAvnd	:= oJparams["advancededSearch"]
	aPeriodos	:= fMontaPer(cDataDe, cDataAte)

	If (oJparams["page"] == Nil, nPage := 1, nPage := oJparams["page"])
	If (oJparams["pageSize"] == Nil, nPageSize := 10, nPageSize := oJparams["pageSize"])

	// Verifica se o campo PI_DTVENC existe
	lTemDtVnc := fChkDtVenc()

	// Se tiver o campo PI_DTVENC adiciona o campo PI_MESESBH na Query
	If lTemDtVnc		
		If Alltrim(cNomeSGDB) == "ORACLE" .Or. Alltrim(cNomeSGDB) == "POSTGRES"
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH IS NULL) %"
		Else
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH = ' ') %"
		EndIf
	EndIf
	
	// Montagem do Where das filais	e controle de acesso da SRA
	cWhere := cWhereFil := fFilQuery(aFiliais, @oFilTemp)
		
	// Montagem do Where dos departamentos
	cWhereDpto := fDptoQuery(aDeptos)
	If !Empty(cWhereDpto)
		cWhere += " AND " + cWhereDpto
	EndIf

	// Montagem do Where dos Centros de Custos
	cWhereCc := fCcQuery(aCc)
	If !Empty(cWhereCc)
		cWhere += " AND " + cWhereCc
	EndIf
	
	// Montagem da query da busca avançada
	If oBuscaAvnd:HasProperty("company")
		cQryBuscAd := fQryBuscAd(oBuscaAvnd)

		If !Empty(cQryBuscAd)
			cWhere += cQryBuscAd
		EndIf

		If oBuscaAvnd:HasProperty("company") .And. !Empty(oBuscaAvnd["company"])
			lBuscEmp := .T.
			cBuscEmp := Upper(AllTrim(oBuscaAvnd["company"]))
		EndIf
	EndIf

	cWhere := "%" + cWhere + "%"

	// Montagem da query dos gestores
	cQryGestor := fGstQuery(aGestores, cWhereFil)
	cQryGestor := StrTran(cQryGestor, "LEFT", "INNER")

	BeginSql alias cAliasTot
		SELECT
			SRA.RA_FILIAL,
			FILGESTOR,
			MATGESTOR
		FROM %table:SRA% SRA
		%exp:cQryGestor%
		INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
		INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
		INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
		INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
		WHERE SRA.%notDel%
			AND SPI.PI_STATUS = ' '
			%exp:cWhereVnc%
			AND (SPI.PI_DATA >= %exp:cDataDe% AND SPI.PI_DATA <= %exp:cDataAte%)
			AND %exp:cWhere%
		GROUP BY SRA.RA_FILIAL, FILGESTOR, MATGESTOR
	EndSql

	While (cAliasTot)->(!Eof())
		If lBuscEmp
			If cLastFil <> (cAliasTot)->RA_FILIAL
				cEmpNome := Upper(AllTrim(FWCompanyName(cEmpAnt,(cAliasTot)->RA_FILIAL)))
				cLastFil := (cAliasTot)->RA_FILIAL
			EndIf

			If cBuscEmp $ cEmpNome
				nTotGestor++
			EndIf
		Else
			nTotGestor++
		EndIf
		(cAliasTot)->(dbSkip())
	Enddo

	cEmpNome := ""
	cLastFil := ""
	
	If nTotGestor > 0
		If Alltrim(cNomeSGDB) == "ORACLE" .Or. Alltrim(cNomeSGDB) == "MSSQL"
			cPaginacao += "% OFFSET " + cValToChar((nPage-1) * nPageSize) + " ROWS FETCH NEXT " + cValToChar(nPageSize) + " ROWS ONLY %"
		ElseIf Alltrim(cNomeSGDB) == "POSTGRES"
			cPaginacao += "% LIMIT " + cValToChar(nPageSize) + " OFFSET " + cValToChar((nPage-1) * nPageSize) + " %"
		EndIf

		nTotPags := Int(nTotGestor / nPageSize)

		If (nTotGestor % nPageSize != 0, nTotPags++, Nil)

		BeginSql alias cAlias
			SELECT
			  FUNC.RA_FILIAL,
			  FUNC.RA_MAT,
			  FUNC.RA_NOME,
			  FUNC.QB_FILIAL,
			  FUNC.QB_DEPTO,
			  FUNC.QB_DESCRIC,
			  FUNC.FILGESTOR,
			  FUNC.MATGESTOR,
			  FUNC.GESTOR,
			  SPI.PI_DATA,
			  SPI.PI_QUANT,
			  SP9.P9_TIPOCOD
			FROM (
				SELECT 
				  SRA.RA_FILIAL,
				  SRA.RA_MAT,
				  SRA.RA_NOME,
				  SRA.RA_CC,
				  SQB.QB_FILIAL,
				  SQB.QB_DEPTO,
				  SQB.QB_DESCRIC,
				  CTT.CTT_FILIAL,
				  CTT.CTT_CUSTO,
				  CTT.CTT_DESC01,
				  SRAGEST.GESTOR,
				  SRAGEST.FILGESTOR,
				  SRAGEST.MATGESTOR
				FROM %table:SRA% SRA
				%exp:cQryGestor%
				INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
				INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
				INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
				INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
				WHERE SRA.%notDel%
				  AND SPI.PI_STATUS = ' '
				  %exp:cWhereVnc%
				  AND (SPI.PI_DATA >= %exp:cDataDe% AND SPI.PI_DATA <= %exp:cDataAte%)
			 	  AND %exp:cWhere%
				GROUP BY SRA.RA_FILIAL, SRA.RA_MAT, SRA.RA_NOME, SRA.RA_CC, SQB.QB_FILIAL, SQB.QB_DEPTO, SQB.QB_DESCRIC, CTT.CTT_FILIAL, CTT.CTT_CUSTO, CTT.CTT_DESC01, SRAGEST.GESTOR, SRAGEST.FILGESTOR, SRAGEST.MATGESTOR
			) FUNC 
			INNER JOIN (
				SELECT 
				  FILGESTOR,
				  MATGESTOR
				FROM %table:SRA% SRA
				%exp:cQryGestor%
				INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
				INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
				INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
				INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
				WHERE SRA.%notDel%
				  AND SPI.PI_STATUS = ' '
				  %exp:cWhereVnc%
				  AND (SPI.PI_DATA >= %exp:cDataDe% AND SPI.PI_DATA <= %exp:cDataAte%)
				  AND %exp:cWhere%
				  GROUP BY FILGESTOR, MATGESTOR
				  ORDER BY FILGESTOR, MATGESTOR
				  %exp:cPaginacao%
			) ITENS ON ITENS.FILGESTOR = FUNC.FILGESTOR AND ITENS.MATGESTOR = FUNC.MATGESTOR
			INNER JOIN %table:SPI% SPI ON FUNC.RA_FILIAL = SPI.PI_FILIAL AND FUNC.RA_MAT = SPI.PI_MAT
			INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD
			WHERE SPI.%notDel%
			  AND SP9.%notDel%
			  %exp:cWhereVnc%
			  AND (SPI.PI_DATA >= %exp:cDataDe% AND SPI.PI_DATA <= %exp:cDataAte%)
			ORDER BY FUNC.RA_FILIAL, FUNC.RA_MAT, FUNC.QB_FILIAL, FUNC.QB_DEPTO
		EndSql

		While (cAlias)->(!Eof())
			If cLastFil <> (cAlias)->RA_FILIAL
				cEmpNome := AllTrim(FWCompanyName(cEmpAnt,(cAlias)->RA_FILIAL))
				cLastFil := (cAlias)->RA_FILIAL
			EndIf

			If lBuscEmp
				If !(cBuscEmp $ Upper(cEmpNome))
					(cAlias)->(dbSkip())
					Loop
				EndIf
			EndIf

			fMontaGst(@aDados, AllTrim((cAlias)->FILGESTOR), AllTrim((cAlias)->MATGESTOR), AllTrim((cAlias)->GESTOR), AllTrim((cAlias)->QB_FILIAL), AllTrim((cAlias)->QB_DEPTO), AllTrim((cAlias)->QB_DESCRIC), AllTrim((cAlias)->RA_FILIAL), AllTrim((cAlias)->RA_MAT), AllTrim((cAlias)->RA_NOME), (cAlias)->P9_TIPOCOD, (cAlias)->PI_QUANT)
			(cAlias)->(dbSkip())
		Enddo
	EndIf

	// Gera o Json do detalhamento do gráfico somente se houver dados
	nLenDados := Len(aDados)

	If nLenDados > 0
		cRows := '"rows": ['
		For nI := 1 To nLenDados
			nLenFuncs := Len(aDados[nI,8])

			If (nI == 1, cRows += '{', cRows += ',{')

			If cFilFunc <> aDados[nI,1]
				cFilFunc := aDados[nI,1]
				cEmpNome := AllTrim(FWCompanyName(cEmpAnt, aDados[nI,1]))
			EndIf

			cRows += '"company": "' + cEmpNome + '",'
			cRows += '"branch": "' + aDados[nI, 1] + '",'
			cRows += '"departament": "' + aDados[nI, 6] + '",'
			cRows += '"manager": "' + aDados[nI, 3] + '",'
			cRows += '"totalBalance": ' + cValToChar(aDados[nI, 7]) + ','
			cRows += '"details": ['

			For nX := 1 To nLenFuncs
				If (nX == 1, cRows += '{', cRows += ',{')
				cRows +=	'"employeeName": "' + aDados[nI, 8, nX, 3] + '",'
				cRows +=	'"balance": ' + cValToChar(aDados[nI, 8, nX, 4])
				cRows += '}'
			Next

			cRows += 	']'
			cRows += '}'
		Next

		cRows += ']'
	Else
		cRows := '"rows": []'
	EndIf

	cResp := '{"totalPages":' + cValToChar(nTotPags) + ', ' + cRows + '}'

	oResp:FromJson(cResp)

	If ValType(oFilTemp) == "O"
		oFilTemp:Delete()
		FwFreeObj(oFilTemp)
	EndIf

	(cAliasTot)->(dbCloseArea())
	If (nTotGestor > 0, (cAlias)->(dbCloseArea()), Nil)
Else
	SetRestFault(400, EncodeUTF8(STR0001))  // "Parâmetros inválidos: Verifique se os Parâmetros startDate, endDate, branch, departament, costCenter e manager foram enviados."
	oResp["return"] := "Error"
EndIf
Return oRest:setResponse(oResp)

/*/{Protheus.doc} DbHrBhGetExcel
@type Function
@description Serviço para retornar os dados do dashboard banco de horas em excel.
@author Marco Nakazawa
@since 06/03/2025
/*/
@POST("api/rh/v1/DbHrBhGetExcel")
Function DbHrBhGetExcel()
Local oResp			:= JsonObject():New()						as Json
Local oJparams		:= JsonObject():New()						as Json
Local oBuscaAvnd	:= JsonObject():New()						as Json
Local aFiliais		:= {}										as Array
Local aGestores		:= {}										as Array
Local aDeptos		:= {}										as Array
Local aCc			:= {}										as Array
Local aPeriodos		:= {}										as Array
Local aColsInd		:= {}										as Array
Local aColsFil		:= {}										as Array
Local aColsDpt		:= {}										as Array
Local aColsCc		:= {}										as Array
Local aColsGst		:= {}										as Array
Local aSaldo		:= {}										as Array
Local aHrsPosit		:= {}										as Array
Local aHrsNegat		:= {}										as Array
Local aHrsVencer	:= {}										as Array
Local aHrsVencds	:= {}										as Array
Local aGrfFilial	:= {}										as Array
Local aGrfDepart	:= {}										as Array
Local aGrfCentrC	:= {}										as Array
Local aGrfGestor	:= {}										as Array
Local aResp			:= {}										as Array
Local aAbasExcel	:= Array(9)									as Array
Local cBody	    	:= oRest:getBodyRequest()					as Character
Local cAlias		:= GetNextAlias()							as Character
Local cJoiFilSPI	:= "%" + FWJoinFilial("SPI", "SRA") + "%"	as Character
Local cJoiFilSQB	:= "%" + FWJoinFilial("SQB", "SRA") + "%"	as Character
Local cJoiFilCTT	:= "%" + FWJoinFilial("CTT", "SRA") + "%"	as Character
Local cJoiFilSRJ	:= "%" + FWJoinFilial("SRJ", "SRA") + "%"	as Character
Local cJoiFilSP9	:= "%" + FWJoinFilial("SP9", "SPI") + "%"	as Character
Local cDataDe		:= ""										as Character
Local cDataAte		:= "" 										as Character
Local cWhereFil		:= ""										as Character
Local cWhere		:= ""										as Character
Local cQryGestor	:= ""										as Character
Local cDtVenc		:= "%%"										as Character
Local cWhereVnc		:= "%%"										as Character
Local cEmpNome		:= ""										as Character
Local cTipoExcel 	:= ""										as Character
Local cLastFil	 	:= ""										as Character
Local cLastMat	 	:= ""										as Character
Local cDataVnc	 	:= ""										as Character
Local cQryBuscAd	:= ""										as Character
Local cBuscEmp	 	:= ""										as Character
Local cNomeSGDB 	:= Upper(TCGetDB())							as Character
Local nI			:= 0										as Numeric
Local nY			:= 0										as Numeric
Local nLenArray		:= 0										as Numeric
Local nLenGstr		:= 0										as Numeric
Local lTemDtVnc		:= .F.										as Logical
Local lTemGestor	:= .F.										as Logical
Local lNovoFunc		:= .F.										as Logical
Local lBuscEmp		:= .F.										as Logical
Local oFilTemp		:= Nil										as Object

oJparams:FromJSON(cBody)

If checkParams(oJparams, .T.)
	cDataDe		:= StrTran(oJparams["startDate"],"-","")
	cDataAte	:= StrTran(oJparams["endDate"],"-","")
	aFiliais	:= oJparams["branch"]
	aDeptos		:= oJparams["departament"]
	aCc			:= oJparams["costCenter"]
	lTemGestor	:= !oJparams["managerIsEmpty"]
	aGestores	:= oJparams["manager"]
	cTipoExcel	:= oJparams["excelType"]
	oBuscaAvnd	:= oJparams["advancededSearch"]
	aPeriodos	:= fMontaPer(cDataDe, cDataAte)

	// Montagem do Array para gerar o excel.
	aAbasExcel[1] := {{STR0034, STR0015}} // "Saldo" / "Saldo Banco de Horas"
	aAbasExcel[2] := {{STR0016, STR0016}} // "Horas Positivas" / "Horas Positivas"
	aAbasExcel[3] := {{STR0017, STR0017}} // "Horas Negativas" / "Horas Negativas"
	aAbasExcel[4] := {{STR0018, STR0018}} // "Horas à Vencer" / "Horas à Vencer"
	aAbasExcel[5] := {{STR0019, STR0019}} // "Horas Vencidas" / "Horas Vencidas"
	aAbasExcel[6] := {{STR0036, STR0020}} // "Gráfico Filiais" / "Saldo do Banco de Horas Por Filial"
	aAbasExcel[7] := {{STR0037, STR0021}} // "Gráfico Departamentos" / "Saldo do Banco de Horas Por Departamento"
	aAbasExcel[8] := {{STR0038, STR0022}} // "Gráfico Centros de Custo" / "Saldo do Banco de Horas Por Centro de Custo"
	aAbasExcel[9] := {{STR0039, STR0023}} // "Gráfico Gestores" / "Saldo do Banco de Horas Por Gestor"
	
	// Verifica se o campo PI_DTVENC existe
	lTemDtVnc := fChkDtVenc()

	// Se tiver o campo PI_DTVENC adiciona o campo PI_MESESBH na Query
	If lTemDtVnc		
		cDtVenc := "%SPI.PI_DTVENC,%"

		If Alltrim(cNomeSGDB) == "ORACLE" .Or. Alltrim(cNomeSGDB) == "POSTGRES"
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH IS NULL) %"
		Else
			cWhereVnc := "% AND (SPI.PI_MESESBH = 0 OR SPI.PI_MESESBH = ' ') %"
		EndIf
	EndIf
	
	// Montagem do Where das filais	e controle de acesso da SRA
	cWhere := cWhereFil := fFilQuery(aFiliais, @oFilTemp)
		
	// Montagem do Where dos departamentos
	cWhereDpto := fDptoQuery(aDeptos)
	If !Empty(cWhereDpto)
		cWhere += " AND " + cWhereDpto
	EndIf

	// Montagem do Where dos Centros de Custos
	cWhereCc := fCcQuery(aCc)
	If !Empty(cWhereCc)
		cWhere += " AND " + cWhereCc
	EndIf

	// Montagem da query da busca avançada
	If oBuscaAvnd:HasProperty("company")
		cQryBuscAd := fQryBuscAd(oBuscaAvnd)

		If !Empty(cQryBuscAd)
			cWhere += cQryBuscAd
		EndIf

		If oBuscaAvnd:HasProperty("company") .And. !Empty(oBuscaAvnd["company"])
			lBuscEmp := .T.
			cBuscEmp := Upper(AllTrim(oBuscaAvnd["company"]))
		EndIf
	EndIf

	cWhere := "%" + cWhere + "%"

	// Montagem da query dos gestores
	cQryGestor := fGstQuery(aGestores, cWhereFil)

	// Monta as colunas dos indicadores, tamanho da coluna e adiciona no array que será utilizado na montagem do excel.
	aAdd(aColsInd, {STR0024, 14}) // "Empresa"
	aAdd(aColsInd, {STR0025, 12}) // "Filial"
	aAdd(aColsInd, {STR0026, 35}) // "Nome"
	aAdd(aColsInd, {STR0027, 15}) // "Matrícula"
	aAdd(aColsInd, {STR0028, 25}) // "Cargo"
	aAdd(aColsInd, {STR0029, 45}) // "Centro de Custo"
	aAdd(aColsInd, {STR0030, 35}) // "Gestor"
	aAdd(aColsInd, {STR0031, 45}) // "Departamento"
	aAdd(aColsInd, {STR0032, 11}) // "Horas"
	aAdd(aColsInd, {STR0033, 17}) // "Vencimento"
		
	aAdd(aAbasExcel[1], aColsInd)
	aAdd(aAbasExcel[2], aColsInd)
	aAdd(aAbasExcel[3], aColsInd)
	aAdd(aAbasExcel[4], aColsInd)
	aAdd(aAbasExcel[5], aColsInd)

	// Monta as colunas para cada gráfico e adiciona no array que será utilizado na montagem do excel.
	// Gráfico Filiais
	aAdd(aColsFil, {STR0024, 14}) // "Empresa"
	aAdd(aColsFil, {STR0025, 12}) // "Filial"
	aAdd(aColsFil, {STR0026, 35}) // "Nome"

	For nI := 1 To Len(aPeriodos)
		aAdd(aColsFil, {aPeriodos[nI,1], 16})
	Next

	aAdd(aAbasExcel[6], aColsFil)

	// Gráfico Departamentos
	aAdd(aColsDpt, {STR0024, 14}) // "Empresa"
	aAdd(aColsDpt, {STR0031, 45}) // "Departamento"
	aAdd(aColsDpt, {STR0026, 35}) // "Nome"
	
	For nI := 1 To Len(aPeriodos)
		aAdd(aColsDpt, {aPeriodos[nI,1], 16})
	Next

	aAdd(aAbasExcel[7], aColsDpt)

	// Gráfico Centros de Custo
	aAdd(aColsCc, {STR0024, 14}) // "Empresa"
	aAdd(aColsCc, {STR0029, 45}) // "Centro de Custo"
	aAdd(aColsCc, {STR0026, 35}) // "Nome"
	
	For nI := 1 To Len(aPeriodos)
		aAdd(aColsCc, {aPeriodos[nI,1], 16})
	Next

	aAdd(aAbasExcel[8], aColsCc)

	// Gráfico Gestores
	aAdd(aColsGst, {STR0024, 14}) // "Empresa"
	aAdd(aColsGst, {STR0025, 12}) // "Filial"
	aAdd(aColsGst, {STR0031, 45}) // "Departamento"
	aAdd(aColsGst, {STR0030, 35}) // "Gestor"
	aAdd(aColsGst, {STR0026, 35}) // "Nome"
	aAdd(aColsGst, {STR0034, 11}) // "Saldo"
	aAdd(aAbasExcel[9], aColsGst)

	// Só executa a query se tiver que gerar todas as informações do dashboard ou saldo ou horas positivas ou horas negativas ou algum gráfico
	If cTipoExcel == "allInformations" .Or. cTipoExcel == "balance" .Or. cTipoExcel == "positive" .Or. cTipoExcel == "negative" .Or. "chart" $ cTipoExcel
		// Query para buscar os eventos do banco, sem considerar vencidos e à vencer.
		BeginSql alias cAlias
			SELECT 
				SRA.RA_FILIAL,
				SRA.RA_MAT,
				SRA.RA_NOME,
				SRJ.RJ_DESC,
				SQB.QB_FILIAL,
				SQB.QB_DEPTO,
				SQB.QB_DESCRIC,
				CTT.CTT_FILIAL,
				CTT.CTT_CUSTO,
				CTT.CTT_DESC01,
				SRAGEST.GESTOR,
				SRAGEST.FILGESTOR,
				SRAGEST.MATGESTOR,
				%exp:cDtVenc%
				SPI.PI_DATA,
				SPI.PI_QUANT,
				SP9.P9_TIPOCOD
			FROM %table:SRA% SRA
			%exp:cQryGestor%
			INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
			INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
			INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
			INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
			LEFT JOIN %table:SRJ% SRJ ON %exp:cJoiFilSRJ% AND SRJ.RJ_FUNCAO = SRA.RA_CODFUNC AND SRJ.%notDel%
			WHERE SRA.%notDel%
				AND SPI.PI_STATUS = ' '
				%exp:cWhereVnc%
				AND (SPI.PI_DATA >= %exp:cDataDe% AND SPI.PI_DATA <= %exp:cDataAte%)
				AND %exp:cWhere%
			ORDER BY SRA.RA_FILIAL, SRA.RA_MAT
		EndSql
		
		// Monta os Arrays do indicadores e gráficos, sem considerar horas vencidas e à vencer.
		While (cAlias)->(!Eof())
			If cLastFil <> (cAlias)->RA_FILIAL .Or. cLastMat <> (cAlias)->RA_MAT
				If cLastFil <> (cAlias)->RA_FILIAL
					cEmpNome := AllTrim(FWCompanyName(cEmpAnt,(cAlias)->RA_FILIAL))
				EndIf

				If lBuscEmp
					If !(cBuscEmp $ Upper(cEmpNome))
						(cAlias)->(dbSkip())
						Loop
					EndIf
				EndIf

				lNovoFunc := .T.
				cLastFil := (cAlias)->RA_FILIAL
				cLastMat := (cAlias)->RA_MAT
			EndIf

			If cTipoExcel == "allInformations" .Or. cTipoExcel == "balance"
				aAdd(aSaldo, {cEmpNome,(cAlias)->RA_FILIAL, (cAlias)->RA_NOME, (cAlias)->RA_MAT, (cAlias)->RJ_DESC, AllTrim((cAlias)->CTT_DESC01) + " (" + AllTrim((cAlias)->CTT_FILIAL) + " - " + AllTrim((cAlias)->CTT_CUSTO) + ")", (cAlias)->GESTOR, AllTrim((cAlias)->QB_DESCRIC) + " (" + AllTrim((cAlias)->QB_FILIAL) + " - " + AllTrim((cAlias)->QB_DEPTO) + ")", fNumToHr(If((cAlias)->P9_TIPOCOD $ "1*3", (cAlias)->PI_QUANT, (cAlias)->PI_QUANT * -1)), If(lTemDtVnc, dToC(sToD((cAlias)->PI_DTVENC)), "")})
			EndIf

			If (cTipoExcel == "allInformations" .Or. cTipoExcel == "positive") .And. (cAlias)->P9_TIPOCOD $ "1*3"				
				aAdd(aHrsPosit, {cEmpNome,(cAlias)->RA_FILIAL, (cAlias)->RA_NOME, (cAlias)->RA_MAT, (cAlias)->RJ_DESC, AllTrim((cAlias)->CTT_DESC01) + " (" + AllTrim((cAlias)->CTT_FILIAL) + " - " + AllTrim((cAlias)->CTT_CUSTO) + ")", (cAlias)->GESTOR, AllTrim((cAlias)->QB_DESCRIC) + " (" + AllTrim((cAlias)->QB_FILIAL) + " - " + AllTrim((cAlias)->QB_DEPTO) + ")", fNumToHr(If((cAlias)->P9_TIPOCOD $ "1*3", (cAlias)->PI_QUANT, (cAlias)->PI_QUANT * -1)), If(lTemDtVnc, dToC(sToD((cAlias)->PI_DTVENC)), "")})
			EndIf

			If (cTipoExcel == "allInformations" .Or. cTipoExcel == "negative") .And. (cAlias)->P9_TIPOCOD $ "2*4"
				aAdd(aHrsNegat, {cEmpNome,(cAlias)->RA_FILIAL, (cAlias)->RA_NOME, (cAlias)->RA_MAT, (cAlias)->RJ_DESC, AllTrim((cAlias)->CTT_DESC01) + " (" + AllTrim((cAlias)->CTT_FILIAL) + " - " + AllTrim((cAlias)->CTT_CUSTO) + ")", (cAlias)->GESTOR, AllTrim((cAlias)->QB_DESCRIC) + " (" + AllTrim((cAlias)->QB_FILIAL) + " - " + AllTrim((cAlias)->QB_DEPTO) + ")", fNumToHr(If((cAlias)->P9_TIPOCOD $ "1*3", (cAlias)->PI_QUANT, (cAlias)->PI_QUANT * -1)), If(lTemDtVnc, dToC(sToD((cAlias)->PI_DTVENC)), "")})
			EndIf

			If cTipoExcel == "allInformations" .Or. cTipoExcel == "chartBranch"
				fArrExcel(@aGrfFilial, cEmpNome, (cAlias)->RA_FILIAL, AllTrim((cAlias)->RA_NOME), If((cAlias)->P9_TIPOCOD $ "1*3", (cAlias)->PI_QUANT, (cAlias)->PI_QUANT * -1), sToD((cAlias)->PI_DATA), aPeriodos, lNovoFunc)
			EndIf

			If cTipoExcel == "allInformations" .Or. cTipoExcel == "chartDepartament"
				fArrExcel(@aGrfDepart, cEmpNome, AllTrim((cAlias)->QB_DESCRIC) + " (" + AllTrim((cAlias)->QB_FILIAL) + " - " + AllTrim((cAlias)->QB_DEPTO) + ")", AllTrim((cAlias)->RA_NOME), If((cAlias)->P9_TIPOCOD $ "1*3", (cAlias)->PI_QUANT, (cAlias)->PI_QUANT * -1), sToD((cAlias)->PI_DATA), aPeriodos, lNovoFunc)
			EndIf

			If cTipoExcel == "allInformations" .Or. cTipoExcel == "chartCostCenter"
				fArrExcel(@aGrfCentrC, cEmpNome, AllTrim((cAlias)->CTT_DESC01) + " (" + AllTrim((cAlias)->CTT_FILIAL) + " - " + AllTrim((cAlias)->CTT_CUSTO) + ")", AllTrim((cAlias)->RA_NOME), If((cAlias)->P9_TIPOCOD $ "1*3", (cAlias)->PI_QUANT, (cAlias)->PI_QUANT * -1), sToD((cAlias)->PI_DATA), aPeriodos, lNovoFunc)
			EndIf

			If (cTipoExcel == "allInformations" .Or. cTipoExcel == "chartManager") .And. !Empty(AllTrim((cAlias)->GESTOR))
				If Empty(aGrfGestor) .Or. lNovoFunc
					If lNovoFunc .And. !Empty(aGrfGestor)
						nLenGstr := Len(aGrfGestor)
						aGrfGestor[nLenGstr, Len(aGrfGestor[nLenGstr])] := fNumToHr(aGrfGestor[nLenGstr, Len(aGrfGestor[nLenGstr])])
					EndIf

					aAdd(aGrfGestor, {cEmpNome, (cAlias)->RA_FILIAL, AllTrim((cAlias)->QB_DESCRIC) + " (" + AllTrim((cAlias)->QB_FILIAL) + " - " + AllTrim((cAlias)->QB_DEPTO) + ")", AllTrim((cAlias)->GESTOR), AllTrim((cAlias)->RA_NOME), If((cAlias)->P9_TIPOCOD $ "1*3", (cAlias)->PI_QUANT, (cAlias)->PI_QUANT * -1)})
				Else
					nLenGstr := Len(aGrfGestor)
					aGrfGestor[nLenGstr, Len(aGrfGestor[nLenGstr])] := SomaHoras(aGrfGestor[nLenGstr, Len(aGrfGestor[nLenGstr])], If((cAlias)->P9_TIPOCOD $ "1*3", (cAlias)->PI_QUANT, (cAlias)->PI_QUANT * -1))
				EndIf				
			EndIf

			lNovoFunc := .F.

			(cAlias)->(dbSkip())
		Enddo

		// Converte a hora para string do ultimo funcionário incluído de todos os gráficos
		If !Empty(aGrfFilial)
			nLenArray := Len(aGrfFilial)

			For nI := nLenArray To nLenArray
				For nY := 4 To Len(aGrfFilial[nI])
					aGrfFilial[nI, nY] := fNumToHr(aGrfFilial[nI, nY])
				Next
			Next
		EndIf

		If !Empty(aGrfDepart)
			nLenArray := Len(aGrfDepart)

			For nI := nLenArray To nLenArray
				For nY := 4 To Len(aGrfDepart[nI])
					aGrfDepart[nI, nY] := fNumToHr(aGrfDepart[nI, nY])
				Next
			Next
		EndIf

		If !Empty(aGrfCentrC)
			nLenArray := Len(aGrfCentrC)

			For nI := nLenArray To nLenArray
				For nY := 4 To Len(aGrfCentrC[nI])
					aGrfCentrC[nI, nY] := fNumToHr(aGrfCentrC[nI, nY])
				Next
			Next
		EndIf

		If !Empty(aGrfGestor)
			nLenArray := Len(aGrfGestor)
			aGrfGestor[nLenArray, Len(aGrfGestor[nLenArray])] := fNumToHr(aGrfGestor[nLenArray, Len(aGrfGestor[nLenArray])])
		EndIf
		(cAlias)->(dbCloseArea())
	EndIf

	// Só executa a query se possui a data de vencimento e se tiver que gerar todas as informações do dashboard ou horas à vencer
	If lTemDtVnc .And. (cTipoExcel == "allInformations" .Or. cTipoExcel == "hoursToExpire")		
		// Query para buscar os eventos à vencer do banco.
		cAlias := GetNextAlias()

		BeginSql alias cAlias
			SELECT
				SRA.RA_FILIAL,
				SRA.RA_MAT,
				SRA.RA_NOME,
				SRJ.RJ_DESC,
				SQB.QB_FILIAL,
				SQB.QB_DEPTO,
				SQB.QB_DESCRIC,
				CTT.CTT_FILIAL,
				CTT.CTT_CUSTO,
				CTT.CTT_DESC01,
				SRAGEST.GESTOR,
				SRAGEST.FILGESTOR,
				SRAGEST.MATGESTOR,
				SPI.PI_DTVENC,
				SPI.PI_DATA,
				SPI.PI_QUANT,
				SP9.P9_TIPOCOD
			FROM %table:SRA% SRA
			%exp:cQryGestor%
			INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
			INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
			INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
			INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
			LEFT JOIN %table:SRJ% SRJ ON %exp:cJoiFilSRJ% AND SRJ.RJ_FUNCAO = SRA.RA_CODFUNC AND SRJ.%notDel%
			WHERE SRA.%notDel%
			  AND SPI.PI_STATUS = ' '
			  %exp:cWhereVnc%
			  AND SPI.PI_DTVENC <> ' '
			  AND SPI.PI_DTVENC > %exp:cDataAte%
			  AND %exp:cWhere%
			ORDER BY SRA.RA_FILIAL, SRA.RA_MAT
		EndSql

		// Monta os arrays de horas à vencer.
		While (cAlias)->(!Eof())
			If cLastFil <> (cAlias)->RA_FILIAL
				cEmpNome := AllTrim(FWCompanyName(cEmpAnt,(cAlias)->RA_FILIAL))
			EndIf

			cDataVnc := dToC(sToD((cAlias)->PI_DTVENC))

			aAdd(aHrsVencer, {cEmpNome,(cAlias)->RA_FILIAL, (cAlias)->RA_NOME, (cAlias)->RA_MAT, (cAlias)->RJ_DESC, AllTrim((cAlias)->CTT_DESC01) + " (" + AllTrim((cAlias)->CTT_FILIAL) + " - " + AllTrim((cAlias)->CTT_CUSTO) + ")", (cAlias)->GESTOR, AllTrim((cAlias)->QB_DESCRIC) + " (" + AllTrim((cAlias)->QB_FILIAL) + " - " + AllTrim((cAlias)->QB_DEPTO) + ")", fNumToHr(If((cAlias)->P9_TIPOCOD $ "1*3", (cAlias)->PI_QUANT, (cAlias)->PI_QUANT * -1)), If(!Empty((cAlias)->PI_DTVENC), cDataVnc, "")})
			
			(cAlias)->(dbSkip())
		Enddo
		
		(cAlias)->(dbCloseArea())
	EndIf

	// Só executa a query se possui a data de vencimento e se tiver que gerar todas as informações do dashboard ou horas vencidas
	If lTemDtVnc .And. (cTipoExcel == "allInformations" .Or. cTipoExcel == "expiredHours")
		// Query para buscar os eventos vencidos do banco.
		cAlias := GetNextAlias()

		BeginSql alias cAlias
			SELECT
				SRA.RA_FILIAL,
				SRA.RA_MAT,
				SRA.RA_NOME,
				SRJ.RJ_DESC,
				SQB.QB_FILIAL,
				SQB.QB_DEPTO,
				SQB.QB_DESCRIC,
				CTT.CTT_FILIAL,
				CTT.CTT_CUSTO,
				CTT.CTT_DESC01,
				SRAGEST.GESTOR,
				SRAGEST.FILGESTOR,
				SRAGEST.MATGESTOR,
				SPI.PI_DTVENC,
				SPI.PI_DATA,
				SPI.PI_QUANT,
				SP9.P9_TIPOCOD
			FROM %table:SRA% SRA
			%exp:cQryGestor%
			INNER JOIN %table:SPI% SPI ON %exp:cJoiFilSPI% AND SPI.PI_MAT = SRA.RA_MAT AND SPI.%notDel%
			INNER JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
			INNER JOIN %table:CTT% CTT ON %exp:cJoiFilCTT% AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.%notDel%
			INNER JOIN %table:SP9% SP9 ON %exp:cJoiFilSP9% AND SP9.P9_CODIGO = SPI.PI_PD AND SP9.%notDel%
			LEFT JOIN %table:SRJ% SRJ ON %exp:cJoiFilSRJ% AND SRJ.RJ_FUNCAO = SRA.RA_CODFUNC AND SRJ.%notDel%
			WHERE SRA.%notDel%
			  AND SPI.PI_STATUS = ' '
			  %exp:cWhereVnc%
			  AND SPI.PI_DTVENC <> ' '
			  AND SPI.PI_DTVENC <= %exp:cDataAte%
			  AND %exp:cWhere%
			ORDER BY SRA.RA_FILIAL, SRA.RA_MAT
		EndSql

		// Monta os arrays de horas vencidas.
		While (cAlias)->(!Eof())
			If cLastFil <> (cAlias)->RA_FILIAL
				cEmpNome := AllTrim(FWCompanyName(cEmpAnt,(cAlias)->RA_FILIAL))
			EndIf

			cDataVnc := dToC(sToD((cAlias)->PI_DTVENC))

			aAdd(aHrsVencds, {cEmpNome,(cAlias)->RA_FILIAL, (cAlias)->RA_NOME, (cAlias)->RA_MAT, (cAlias)->RJ_DESC, AllTrim((cAlias)->CTT_DESC01) + " (" + AllTrim((cAlias)->CTT_FILIAL) + " - " + AllTrim((cAlias)->CTT_CUSTO) + ")", (cAlias)->GESTOR, AllTrim((cAlias)->QB_DESCRIC) + " (" + AllTrim((cAlias)->QB_FILIAL) + " - " + AllTrim((cAlias)->QB_DEPTO) + ")", fNumToHr(If((cAlias)->P9_TIPOCOD $ "1*3", (cAlias)->PI_QUANT, (cAlias)->PI_QUANT * -1)), If(!Empty((cAlias)->PI_DTVENC), cDataVnc, "")})
			
			(cAlias)->(dbSkip())
		Enddo
		
		(cAlias)->(dbCloseArea())
	EndIf

	// Reordena os arrays de acordo com o tipo
	If !Empty(aGrfFilial)
		aSort(aGrfFilial, , , {|x,y| x[1]+x[2]+x[3] < y[1]+y[2]+y[3]})
	EndIf

	If !Empty(aGrfDepart)
		aSort(aGrfDepart, , , {|x,y| x[1]+x[2]+x[3] < y[1]+y[2]+y[3]})
	EndIf

	If !Empty(aGrfCentrC)
		aSort(aGrfCentrC, , , {|x,y| x[1]+x[2]+x[3] < y[1]+y[2]+y[3]})
	EndIf

	If !Empty(aGrfGestor)
		aSort(aGrfGestor, , , {|x,y| x[1]+x[2]+x[3] < y[1]+y[2]+y[3]})
	EndIf

	// Adiciona os resultados no array que será utilizado para a montagem do Excel
	aAdd(aAbasExcel[1], aSaldo)
	aAdd(aAbasExcel[2], aHrsPosit)
	aAdd(aAbasExcel[3], aHrsNegat)
	aAdd(aAbasExcel[4], aHrsVencer)
	aAdd(aAbasExcel[5], aHrsVencds)
	aAdd(aAbasExcel[6], aGrfFilial)
	aAdd(aAbasExcel[7], aGrfDepart)
	aAdd(aAbasExcel[8], aGrfCentrC)
	aAdd(aAbasExcel[9], aGrfGestor)

	// Chama a função responsável por montar o excel.
	If cTipoExcel == "allInformations"
		aResp := fExcelBh(aAbasExcel, .T.)
	ElseIf cTipoExcel == "balance"
		aResp := fExcelBh({aAbasExcel[1]}, .T.)
	ElseIf cTipoExcel == "positive"
		aResp := fExcelBh({aAbasExcel[2]}, .T.)
	ElseIf cTipoExcel == "negative"
		aResp := fExcelBh({aAbasExcel[3]}, .T.)
	ElseIf cTipoExcel == "hoursToExpire"
		aResp := fExcelBh({aAbasExcel[4]}, .T.)
	ElseIf cTipoExcel == "expiredHours"
		aResp := fExcelBh({aAbasExcel[5]}, .T.)
	ElseIf cTipoExcel == "chartBranch"
		aResp := fExcelBh({aAbasExcel[6]}, .T.)
	ElseIf cTipoExcel == "chartDepartament"
		aResp := fExcelBh({aAbasExcel[7]}, .T.)
	ElseIf cTipoExcel == "chartCostCenter"
		aResp := fExcelBh({aAbasExcel[8]}, .T.)
	ElseIf cTipoExcel == "chartManager"
		aResp := fExcelBh({aAbasExcel[9]}, .T.)
	EndIf
	
	If !Empty(aResp)
		oResp["fileName"]	:= aResp[1,1]
		oResp["file"]		:= aResp[1,2]
	EndIf

	If ValType(oFilTemp) == "O"
		oFilTemp:Delete()
		FwFreeObj(oFilTemp)
	EndIf

Else
	SetRestFault(400, EncodeUTF8(STR0035))  // "Parâmetros inválidos: Verifique se os Parâmetros startDate, endDate, branch, departament, costCenter, manager e excelType foram enviados."
	oResp["return"] := "Error"
EndIf
Return oRest:setResponse(oResp)

/*/{Protheus.doc} DbHrNotifyManager
@type Function
@description Serviço para enviar e-mail para os gestores.
@author Marco Nakazawa
@since 17/03/2025
/*/
@POST("api/rh/v1/DbHrNotifyManager")
Function DbHrNotifyManager()
Local aRespApi		:= {}										as Array
Local oResp			:= JsonObject():New()						as Json
Local oJparams		:= JsonObject():New()						as Json
Local cBody	    	:= oRest:getBodyRequest()					as Character
Local nI			:= 0										as Numeric

oJparams:FromJSON(cBody)

If checkParams(oJparams, .F.)
	aRespApi := PONA500A(.T.,oJparams)

	If !aRespApi[1]
		If aRespApi[3]
			oResp["status"] := 400
			oResp["message"] := aRespApi[2,1]
		Else
			oResp["status"] := 400
			oResp["message"] := STR0040 // "Falha no envio do e-mail, verifique o log do Protheus para mais detalhes."
			For nI := 1 To Len(aRespApi[2])
				Conout(aRespApi[2, nI])
			Next
		EndIf
		
		oRest:setStatusCode(400)
		oRest:setResponse(oResp)
	Else
		oResp["status"] := 200
		oResp["message"] := STR0041 // "Gestores notificados com sucesso."
		oRest:setStatusCode(200)
		oRest:setResponse(oResp)
	EndIf
Else
	oResp["status"] := 400
	oResp["message"] := STR0001 // "Parâmetros inválidos: Verifique se os Parâmetros startDate, endDate, branch, departament, costCenter e manager foram enviados."
	
	oRest:setStatusCode(400)
	oRest:setResponse(oResp)
EndIf
Return

/*/{Protheus.doc} checkParams
@type Function
@description Validação dos parâmetros recebidos.
@author Marco Nakazawa
@Return Logico .T. = Todos os parâmetros obrigatórios foram informados, .F. = Algum parâmetro obrigatório não foi informado
@since 07/03/2025
/*/
Static Function checkParams(oJparams, lExcel)
Local lRet 	:= .T. 		as Logical

Default oJparams = ""
Default lExcel = .F.

If ValType(oJparams) == "J" .And. (oJparams["startDate"] == Nil .Or. oJparams["endDate"] == Nil .Or. oJparams["branch"] == Nil .Or. oJparams["departament"] == Nil .Or. oJparams["costCenter"] == Nil .Or. oJparams["manager"] == Nil)
	lRet := .F.
EndIf

If lExcel 
	If ValType(oJparams) == "J" .And. oJparams["excelType"] == Nil
		lRet := .F.
	EndIf
EndIf

Return lRet

/*/{Protheus.doc} fFilQuery
@type Function
@description Validação filtro de filial e validação do controle de acesso da SRA
@author Marco Nakazawa
@Return String com a query do filtro das filias
@since 07/03/2025
/*/
Function fFilQuery(aFiliais, oFilTemp)
Local aGetFil		:= {}										as Array
Local aFilAcesso	:= {}										as Array
Local cQueryRet 	:= "" 										as Character
Local cAcesso		:= fSFiltrSQL(ChkRH("PONA500", "SRA", "1"))	as Character
Local cValidFil		:= fValidFil()								as Character
Local nI			:= 0										as Numeric
Local nLenFil		:= 0										as Numeric
Local nLenGetFil	:= 0										as Numeric

Default aFiliais := {}
Default oFilTemp := Nil

If !Empty(aFiliais)
	nLenFil := Len(aFiliais)
	If nLenFil == 1 .And. Empty(aFiliais[1])
		aGetFil		:= GetFilRecnos(cEmpAnt , Space(FWGETTAMFILIAL), Replicate("Z", FWGETTAMFILIAL))
		nLenGetFil	:= Len(aGetFil)
		
		For nI := 1 To nLenGetFil
			If aGetFil[nI,1] $ cValidFil
				aAdd(aFilAcesso, aGetFil[nI,1])
			EndIf
		Next
		
		CreateTmpFil(aFilAcesso, @oFilTemp)

		cQueryRet := "(SRA.RA_FILIAL IN (SELECT TMP_FIL FROM " + oFilTemp:GetRealName() + "))"
	ElseIf nLenFil > 1
		For nI := 1 To nLenFil
			If aFiliais[nI] $ cValidFil
				aAdd(aFilAcesso, aFiliais[nI])
			EndIf
		Next
		
		CreateTmpFil(aFilAcesso, @oFilTemp)

		cQueryRet := "(SRA.RA_FILIAL IN (SELECT TMP_FIL FROM " + oFilTemp:GetRealName() + "))"
	ElseIf nLenFil == 1 .And. !Empty(aFiliais[1])
		If (aFiliais[1] $ cValidFil, cQueryRet := "(SRA.RA_FILIAL = '" + aFiliais[1] + "')", cQueryRet := "(SRA.RA_FILIAL = ' ')")
	EndIf

	If (!Empty(cAcesso), cQueryRet += " AND " + cAcesso, Nil)
EndIf
Return cQueryRet

/*/{Protheus.doc} fGstQuery
@type Function
@description Montagem da query de gestores
@author Marco Nakazawa
@Return String com a query do filtro dos gestores
@since 07/03/2025
/*/
Function fGstQuery(aGestores, cWhereFil)
Local cQueryRet		:= "" as Character

Default aGestores	:= {""}
Default cWhereFil	:= ""

// Validação do filtro de gestores
If Len(aGestores[1]) > 0 .And. !Empty(aGestores[1])
	cQueryRet := totvs.protheus.rh.dashboard.sigapon.fGestFunc(aGestores, cWhereFil)
Else
	cQueryRet := totvs.protheus.rh.dashboard.sigapon.fGestFunc({"todos"}, cWhereFil)
EndIf
Return cQueryRet

/*/{Protheus.doc} fDptoQuery
@type Function
@description Montagem da query do Departamentos
@author Marco Nakazawa
@Return String com a query do filtro dos departamentos
@since 07/03/2025
/*/
Function fDptoQuery(aDeptos)
Local aCodDep		:= {}										as Array
Local cQueryRet		:= ""										as Character
Local cAcesso		:= fSFiltrSQL(ChkRH("PONA500", "SQB", "1"))	as Character
Local nLenDpto		:= 0										as Numeric
Local nI			:= 0										as Numeric

Default aDeptos	:= {}

nLenDpto := Len(aDeptos)

// Validação do filtro de departamento
If (nLenDpto == 1 .And. !Empty(aDeptos[1])) .Or. (nLenDpto > 1)
	cQueryRet := "("

	For nI := 1 To nLenDpto
		aCodDep := StrTokArr(aDeptos[nI],"-")
		If Len(aCodDep) == 2
			If nLenDpto == 1
				cQueryRet += "SQB.QB_FILIAL = '" + xFilial("SQB",aCodDep[2]) + "' AND SQB.QB_DEPTO = '" + aCodDep[1] + "')"
			ElseIf nI == nLenDpto
				cQueryRet += "(SQB.QB_FILIAL = '" + xFilial("SQB",aCodDep[2]) + "' AND SQB.QB_DEPTO = '" + aCodDep[1] + "'))"
			Else
				cQueryRet += "(SQB.QB_FILIAL = '" + xFilial("SQB",aCodDep[2]) + "' AND SQB.QB_DEPTO = '" + aCodDep[1] + "') OR "
			EndIf
		EndIf
	Next

	If (!Empty(cAcesso), cQueryRet += " AND " + cAcesso, Nil)
EndIf


If !Empty(cAcesso) .And. nLenDpto == 1 .And. Empty(aDeptos[1])
	cQueryRet := cAcesso
EndIf
Return cQueryRet

/*/{Protheus.doc} fCcQuery
@type Function
@description Montagem da query do Centro de Custo
@author Marco Nakazawa
@Return String com a query do filtro dos centros de custos
@since 07/03/2025
/*/
Function fCcQuery(aCc)
Local aCodCc		:= {}										as Array
Local cQueryRet		:= ""										as Character
Local cAcesso		:= fSFiltrSQL(ChkRH("PONA500", "CTT", "1"))	as Character
Local nLenCc		:= 0										as Numeric
Local nI			:= 0										as Numeric

Default aCc	:= {}

nLenCc := Len(aCc)

// Validação do filtro de centro de custo
If (nLenCc == 1 .And. !Empty(aCc[1])) .Or. (nLenCc > 1)
	cQueryRet := "("

	For nI := 1 To nLenCc
		aCodCc := StrTokArr(aCc[nI],"-")
		If Len(aCodCc) == 2
			If nLenCc == 1
				cQueryRet += "CTT.CTT_FILIAL = '" + xFilial("CTT",aCodCc[2]) + "' AND CTT.CTT_CUSTO = '" + aCodCc[1] + "')"
			ElseIf nI == nLenCc
				cQueryRet += "(CTT.CTT_FILIAL = '" + xFilial("CTT",aCodCc[2]) + "' AND CTT.CTT_CUSTO = '" + aCodCc[1] + "'))"
			Else
				cQueryRet += "(CTT.CTT_FILIAL = '" + xFilial("CTT",aCodCc[2]) + "' AND CTT.CTT_CUSTO = '" + aCodCc[1] + "') OR "
			EndIf
		EndIf
	Next

	If (!Empty(cAcesso), cQueryRet += " AND (" + cAcesso + ")", Nil)
EndIf

If !Empty(cAcesso) .And. nLenCc == 1 .And. Empty(aCc[1])
	cQueryRet := cAcesso
EndIf
Return cQueryRet

/*/{Protheus.doc} fChkDtVenc
@type Function
@description Verifica se o campo PI_DTVENC exite no banco.
@author Marco Nakazawa
@Return Logico .T. = Possui o campo PI_DTVENC, .F. = Não possui o campo PI_DTVENC
@since 13/03/2025
/*/
Function fChkDtVenc()
Local lRet := .F.		as Logical

dbSelectArea("SPI")

lRet := SPI->(ColumnPos("PI_DTVENC")) > 0

SPI->(DbCloseArea())
Return lRet

/*/{Protheus.doc} fFormtDt
@description Formata a data para o padrão YYYY-MM-DD
@author Marco Nakazawa
@Return String da data formatada (2025-03-13)
@since 13/03/2025
/*/
Static Function fFormtDt(cData)
Local cDataFrt := ""	as Character

Default cData := ""

If !Empty(cData)
	cDataFrt := SubStr(cData,1,4) + '-' + SubStr(cData,5,2) + '-' + SubStr(cData,7,2)
EndIf
Return cDataFrt

/*/{Protheus.doc} fMontaPer
@type Function
@description Monta o período que será utilizado na montagem do gráfico, pode ser semanas ou meses.
@author Marco Nakazawa
@Return aPeriodos, [1] = Descrição do período, [2] = Data Inicial do Período, [3] = Data Final do Período, [4] = Saldo, [5] = Possui evento no período
@since 18/03/2025
/*/
Static Function fMontaPer(cDataIni, cDataFim)
Local aPeriodos		:= {}				as Array
Local aMeses 		:= {}				as Array
Local nLoops		:= 0				as Numeric
Local nI			:= 0				as Numeric
Local nDifDays		:= 0				as Numeric
Local nTotSemana	:= 0				as Numeric
Local dDataIni		:= sToD(" / / ")	as Date
Local dDatafim		:= sToD(" / / ")	as Date

Default cDataIni := ""
Default cDataFim := ""

If !Empty(cDataIni) .And. !Empty(cDataFim)

	aMeses := {STR0002,STR0003,STR0004,STR0005,STR0006,STR0007,STR0008,STR0009,STR0010,STR0011,STR0012,STR0013} // "Janeiro","Fevereiro","Março","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"
	dDataIni := sToD(cDataIni)
	dDatafim := sToD(cDataFim)
	nLoops := DateDiffMonth(dDataIni, dDatafim)

	If nLoops > 0
		For nI := 0 To nLoops
			If nI == 0 
				dDataIni := FirstDate(dDataIni)
				dDatafim := LastDate(dDataIni)
			EndIf

			aAdd(aPeriodos, {aMeses[Month(dDataIni)] + "/" + cValToChar(Year(dDataIni)), dDataIni, dDatafim, 0, .F.})
			dDataIni := MonthSum(FirstDate(dDataIni),1)
			dDatafim := LastDate(dDataIni)
		Next
	Else
		nDifDays := DateDiffDay(dDataIni, dDatafim) + 1
		nTotSemana := Int(nDifDays / 7)
		
		If (nDifDays % 7 != 0, nTotSemana++, Nil)

		If nTotSemana > 1
			For nI := 1 To nTotSemana
				aAdd(aPeriodos, {cValToChar(nI) + STR0014, dDataIni, If (dDataIni + 6 >= dDataFim, dDataFim, dDataIni + 6), 0, .F.})

				dDataIni := dDataIni + 7
			Next
		Else
			aAdd(aPeriodos, {"1" + STR0014, dDataIni, dDatafim, 0, .F.})
		EndIf
	EndIf
EndIf
Return aPeriodos

/*/{Protheus.doc} fAtuGrafic
@type Function
@description Atualiza ou cria array dos gráficos de acordo com o grafico passado (Filial, Departamento ou Centro de Custo)
@author Marco Nakazawa
@Return Nil
@since 18/03/2025
/*/
Static Function fAtuGrafic(aArrGenrc, dDataEvt, nQtdHoras, cTipoEvt, cBusca, aPeriodos, lGrvFunc, aFunc)
Local nPos			:= 0				as Numeric
Local nPosPer		:= 0				as Numeric
Local nPosFunc		:= 0				as Numeric
Local nLenPosGen	:= 0				as Numeric
Local nLenFunc		:= 0				as Numeric

Default aArrGenrc	:= {}
Default dDataEvt	:= sToD(" / / ")
Default nQtdHoras	:= 0
Default cBusca		:= ""
Default cTipoEvt	:= ""
Default aPeriodos	:= {}
Default lGrvFunc	:= .F.
Default aFunc		:= {}

If !Empty(dDataEvt) .And. nQtdHoras > 0 .And. !Empty(cTipoEvt) .And. !Empty(cBusca) .And. !Empty(aPeriodos)
	If Empty(aArrGenrc)
		aAdd(aArrGenrc, {"", aClone(aPeriodos)})
		aArrGenrc[1, 1] := cBusca
		
		If (nPosPer := aScan(aArrGenrc[1, 2], {|x| dDataEvt >= x[2] .And. dDataEvt <= x[3]})) > 0
			If(cTipoEvt $ "1*3", aArrGenrc[1, 2, nPosPer, 4] := SomaHoras(aArrGenrc[1, 2, nPosPer, 4], nQtdHoras), aArrGenrc[1, 2, nPosPer, 4] := SubHoras(aArrGenrc[1, 2, nPosPer, 4], nQtdHoras))
			aArrGenrc[1, 2, nPosPer, 5] := .T.

			If lGrvFunc .And. !Empty(aFunc)
				aAdd(aArrGenrc[1], {{aFunc[1], aFunc[2], aFunc[3], aClone(aPeriodos)}})

				If(cTipoEvt $ "1*3", aArrGenrc[1, 3, 1, 4, nPosPer, 4] := SomaHoras(aArrGenrc[1, 3, 1, 4, nPosPer, 4], nQtdHoras), aArrGenrc[1, 3, 1, 4, nPosPer, 4] := SubHoras(aArrGenrc[1, 3, 1, 4, nPosPer, 4], nQtdHoras))
				aArrGenrc[1, 3, 1, 4, nPosPer, 5] := .T.			
			EndIf
		EndIf
	Else
		If (nPos := aScan(aArrGenrc, {|x| x[1] == cBusca})) > 0
			If (nPosPer := aScan(aArrGenrc[nPos, 2], {|x| dDataEvt >= x[2] .And. dDataEvt <= x[3]})) > 0
				aArrGenrc[nPos, 2, nPosPer, 4] := If(cTipoEvt $ "1*3", aArrGenrc[nPos, 2, nPosPer, 4] := SomaHoras(aArrGenrc[nPos, 2, nPosPer, 4], nQtdHoras), aArrGenrc[nPos, 2, nPosPer, 4] := SubHoras(aArrGenrc[nPos, 2, nPosPer, 4], nQtdHoras))
				aArrGenrc[nPos, 2, nPosPer, 5] := .T.
				
				If lGrvFunc .And. !Empty(aFunc)
					If (nPosFunc := aScan(aArrGenrc[nPos, 3], {|x| x[1] == aFunc[1] .And. x[2] == aFunc[2]})) > 0
						If(cTipoEvt $ "1*3", aArrGenrc[nPos, 3, nPosFunc, 4, nPosPer, 4] := SomaHoras(aArrGenrc[nPos, 3, nPosFunc, 4, nPosPer, 4], nQtdHoras), aArrGenrc[nPos, 3, nPosFunc, 4, nPosPer, 4] := SubHoras(aArrGenrc[nPos, 3, nPosFunc, 4, nPosPer, 4], nQtdHoras))
						aArrGenrc[nPos, 3, nPosFunc, 4, nPosPer, 5] := .T.
					Else
						aAdd(aArrGenrc[nPos, 3], {aFunc[1], aFunc[2], aFunc[3], aClone(aPeriodos)})

						nLenFunc := Len(aArrGenrc[nPos, 3])

						If(cTipoEvt $ "1*3", aArrGenrc[nPos, 3, nLenFunc, 4, nPosPer, 4] := SomaHoras(aArrGenrc[nPos, 3, nLenFunc, 4, nPosPer, 4], nQtdHoras), aArrGenrc[nPos, 3, nLenFunc, 4, nPosPer, 4] := SubHoras(aArrGenrc[nPos, 3, nLenFunc, 4, nPosPer, 4], nQtdHoras))
						aArrGenrc[nPos, 3, nLenFunc, 4, nPosPer, 5] := .T.
					EndIf
				EndIf
			EndIf
		Else
			aAdd(aArrGenrc, {"", aClone(aPeriodos)})
			
			nLenPosGen := Len(aArrGenrc)

			aArrGenrc[nLenPosGen, 1] := cBusca

			If (nPosPer := aScan(aArrGenrc[nLenPosGen, 2], {|x| dDataEvt >= x[2] .And. dDataEvt <= x[3]})) > 0
				If(cTipoEvt $ "1*3", aArrGenrc[nLenPosGen, 2, nPosPer, 4] := SomaHoras(aArrGenrc[nLenPosGen, 2, nPosPer, 4], nQtdHoras), aArrGenrc[nLenPosGen, 2, nPosPer, 4] := SubHoras(aArrGenrc[nLenPosGen, 2, nPosPer, 4], nQtdHoras))
				aArrGenrc[nLenPosGen, 2, nPosPer, 5] := .T.

				If lGrvFunc .And. !Empty(aFunc)
					aAdd(aArrGenrc[nLenPosGen], {{aFunc[1], aFunc[2], aFunc[3], aClone(aPeriodos)}})

					If(cTipoEvt $ "1*3", aArrGenrc[nLenPosGen, 3, 1, 4, nPosPer, 4] := SomaHoras(aArrGenrc[nLenPosGen, 3, 1, 4, nPosPer, 4], nQtdHoras), aArrGenrc[nLenPosGen, 3, 1, 4, nPosPer, 4] := SubHoras(aArrGenrc[nLenPosGen, 3, 1, 4, nPosPer, 4], nQtdHoras))
					aArrGenrc[nLenPosGen, 3, 1, 4, nPosPer, 5] := .T.			
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
Return

/*/{Protheus.doc} fAtuSaldo
@type Function
@description Atualiza o saldo dos períodos ou funcionários
@author Marco Nakazawa
@Return Nil
@since 18/03/2025
/*/
Static Function fAtuSaldo(aArrGenrc, lAtuFunc)
Local nLenArrGen	:= 0				as Numeric
Local nLenDados		:= 0				as Numeric
Local nLenFunc		:= 0				as Numeric
Local nI			:= 0				as Numeric
Local nX			:= 0				as Numeric
Local nY			:= 0				as Numeric
Local nSaldoAnt		:= 0				as Numeric

Default aArrGenrc	:= {}
Default lAtuFunc	:= .F.

If !Empty(aArrGenrc)
	nLenArrGen := Len(aArrGenrc)
	
	If nLenArrGen > 0
		For nI := 1 To nLenArrGen
			nLenDados := Len(aArrGenrc[nI,2])
			nSaldoAnt := 0

			For nX := 1 To nLenDados
				If nX == 1 
					nSaldoAnt := aArrGenrc[nI,2,nX,4]
					Loop
				EndIf

				If aArrGenrc[nI,2,nX,5]
					aArrGenrc[nI,2,nX,4] := SomaHoras(aArrGenrc[nI,2,nX,4], nSaldoAnt)
					nSaldoAnt := aArrGenrc[nI,2,nX,4]
				Else
					aArrGenrc[nI,2,nX,4] := nSaldoAnt
				EndIf
			Next

			If lAtuFunc		
				nLenFunc := Len(aArrGenrc[nI,3])
				
				For nX := 1 To nLenFunc
					nSaldoAnt := 0
					nLenDados := Len(aArrGenrc[nI,3,nX,4])

					For nY := 1 To nLenDados
						If nY == 1 
							nSaldoAnt := aArrGenrc[nI,3,nX,4,nY,4]
							Loop
						EndIf

						If aArrGenrc[nI,3,nX,4,nY,5]
							aArrGenrc[nI,3,nX,4,nY,4] := SomaHoras(aArrGenrc[nI,3,nX,4,nY,4], nSaldoAnt)
							nSaldoAnt := aArrGenrc[nI,3,nX,4,nY,4]
						Else
							aArrGenrc[nI,3,nX,4,nY,4] := nSaldoAnt
						EndIf
					Next
				Next
			EndIf			
		Next
	EndIf
EndIf
Return

/*/{Protheus.doc} fCalcDestq
@type Function
@description Cria os destaques dos gráficos
@author Marco Nakazawa
@Return Array com os destaques [1] = Item, [2] = Array com o item que teve maior aumento no banco e sua porcentagem, [3] = [2] = Array com o item que teve maior redução no banco e sua porcentagem
@since 18/03/2025
/*/
Static Function fCalcDestq(aArrGenrc)
Local aRet			:= {}				as Array
Local aMaiorAumt	:= {}				as Array
Local aMaiorRedu	:= {}				as Array
Local nLenArrGen	:= 0				as Numeric
Local nLenPerds		:= 0				as Numeric
Local nI			:= 0				as Numeric
Local nSaldIni		:= 0				as Numeric
Local nSaldFim		:= 0				as Numeric
Local nPorcent		:= 0				as Numeric
Local nSldTotIni	:= 0				as Numeric
Local nSldTotFim	:= 0				as Numeric
Local nPcntTotal	:= 0				as Numeric

Default aArrGenrc	:= {}

nLenArrGen := Len(aArrGenrc)

aMaiorRedu := {"", 0, 0}
aMaiorAumt := {"", 0, 0}

If nLenArrGen > 0
	For nI := 1 To nLenArrGen
		nLenPerds := Len(aArrGenrc[nI,2])
		nSaldIni := 0
		nSaldFim := 0
		nPorcent := 0

		nSaldIni := aArrGenrc[nI,2,1,4]
		nSaldFim := aArrGenrc[nI,2,nLenPerds,4]
		nSldTotIni := SomaHoras(nSldTotIni,nSaldIni)
		nSldTotFim := SomaHoras(nSldTotFim,nSaldFim)

		If nSaldIni == 0 .And. nSaldFim <> 0
			If (100 >= aMaiorAumt[2]) .And. (Abs(nSaldFim) > Abs(aMaiorAumt[3]))
				aMaiorAumt[1] := aArrGenrc[nI,1]
				aMaiorAumt[2] := 100
				aMaiorAumt[3] := nSaldFim
			EndIf
		ElseIf nSaldFim == 0 .And. nSaldIni <> 0
			If (100 >= aMaiorRedu[2]) .And. Abs(nSaldIni) > Abs(aMaiorRedu[3])
				aMaiorRedu[1] := aArrGenrc[nI,1]
				aMaiorRedu[2] := -100
				aMaiorRedu[3] := nSaldIni
			EndIf
		Else
			If (nSaldIni < 0, nSaldIni := nSaldIni * -1, Nil)
			If (nSaldFim < 0, nSaldFim := nSaldFim * -1, Nil)
			
			nSaldIni := fConvHr(nSaldIni, "D", .T., 5)
			nSaldFim := fConvHr(nSaldFim, "D", .T., 5)

			nPorcent := ((nSaldFim * 100) / nSaldIni) - 100

			If nPorcent > 0
				If (nPorcent > aMaiorAumt[2]) .Or. (nPorcent == aMaiorAumt[2] .And. (nSaldFim - nSaldIni) > aMaiorAumt[3])
					aMaiorAumt[1] := aArrGenrc[nI,1]
					aMaiorAumt[2] := nPorcent
					aMaiorAumt[3] := nSaldFim - nSaldIni
				EndIf
			ElseIf nPorcent < 0
				If (nPorcent < aMaiorRedu[2]) .Or. (nPorcent == aMaiorRedu[2] .And. (nSaldFim - nSaldIni) > aMaiorRedu[3])
					aMaiorRedu[1] := aArrGenrc[nI,1]
					aMaiorRedu[2] := nPorcent
					aMaiorRedu[3] := nSaldFim - nSaldIni
				EndIf
			EndIf
		EndIf
	Next

	If (aMaiorRedu[3] < 0, aMaiorRedu[3] := fConvHr(Abs(aMaiorRedu[3]),"H") * -1, aMaiorRedu[3] := fConvHr(aMaiorRedu[3],"H"))
	If (aMaiorAumt[3] < 0, aMaiorAumt[3] := fConvHr(Abs(aMaiorAumt[3]),"H") * -1, aMaiorAumt[3] := fConvHr(aMaiorAumt[3],"H"))
	nPcntTotal := ((nSldTotFim * 100) / nSldTotIni) - 100
EndIf

aRet := {nSldTotFim, nPcntTotal, aMaiorAumt, aMaiorRedu}
Return aRet

/*/{Protheus.doc} fJsonDestq
@type Function
@description Retorna o Json de destaques no formato esperado para utilização do Dashboard
@author Marco Nakazawa
@Return String Json com os destaques
@since 18/03/2025
/*/
Static Function fJsonDestq(aArrGenrc,cDestaque)
Local cJson	:= ""	as Character

Default aArrGenrc := {}
Default cDestaque := ""

If !Empty(aArrGenrc)
	cJson += 		'{'
	cJson += 			'"highlight": "' + cDestaque + '",'
	cJson += 			'"totalHours": ' + cValToChar(aArrGenrc[1]) + ','
	cJson += 			'"percentage": ' + cValToChar(aArrGenrc[2]) + ','
	cJson +=	 		'"biggestIncrease":'
	cJson +=	 			'{'
	cJson +=	 				'"data": "' + aArrGenrc[3,1] + '",'
	cJson +=	 				'"value": ' + cValToChar(aArrGenrc[3,2]) + ','
	cJson +=	 				'"hours": ' + cValToChar(aArrGenrc[3,3])
	cJson +=	 			'},'
	cJson +=	 		'"biggestReduction":'
	cJson +=	 			'{'
	cJson +=	 				'"data": "' + aArrGenrc[4,1] + '",'
	cJson +=	 				'"value": ' + cValToChar(aArrGenrc[4,2]) + ','
	cJson +=	 				'"hours": ' + cValToChar(aArrGenrc[4,3])
	cJson +=	 			'}'
	cJson += 		'}'
EndIf
Return cJson

/*/{Protheus.doc} fJsonChart
@type Function
@description Retorna o Json dos gráficos no formato esperado para utilização o Dashboard
@author Marco Nakazawa
@Return String Json com os dados dos gráficos
@since 18/03/2025
/*/
Static Function fJsonChart(aArrGenrc, cTipo, lGrfPizza)
Local cJson			:= ""	as Character
Local nI			:= 0	as Numeric
Local nX			:= 0	as Numeric
Local nLenArrGen	:= 0	as Numeric
Local nLenArrPer	:= 0	as Numeric

Default aArrGenrc	:= {}
Default cTipo 		:= ""
Default lGrfPizza	:= .F.

If !lGrfPizza .And. !Empty(aArrGenrc)
	nLenArrGen := Len(aArrGenrc)
	
	cJson +=	'{'
	cJson +=		'"chartType": "' + cTipo + '",'
	cJson +=		'"data": ['

	For nI := 1 To nLenArrGen
		nLenArrPer := Len(aArrGenrc[nI,2])

		cJson +=		'{'
		cJson +=			'"item": "' + aArrGenrc[nI,1] + '",'
		cJson +=			'"data": ['

		For nX := 1 To nLenArrPer
			cJson +=					'["' + aArrGenrc[nI, 2, nX, 1] + '", ' + cValToChar(aArrGenrc[nI, 2, nX, 4]) + ']'
			If nX < nLenArrPer
				cJson +=				','
			EndIf
		Next

		cJson +=			']'
		cJson +=		'}'
		If nI < nLenArrGen
			cJson +=	','
		EndIf
	Next
	cJson +=		']'
	cJson +=	'}'
ElseIf lGrfPizza .And. !Empty(aArrGenrc)
	nLenArrPer := Len(aArrGenrc)

	cJson +=	'{'
	cJson +=		'"chartType": "' + cTipo + '",'
	cJson +=		'"data": ['
	For nI := 1 To nLenArrPer
		cJson +=		'{'
		cJson +=			'"manager": "' + aArrGenrc[nI, 1] + '",'
		cJson +=			'"hours": ' + cValToChar(aArrGenrc[nI, 2, Len(aArrGenrc[nI, 2]), 4])
		cJson +=		'}'
		If nI < nLenArrPer
			cJson +=	','
		EndIf
	Next
	cJson += 		']'
	cJson += 	'}'
EndIf
Return cJson

/*/{Protheus.doc} fJsonDtCht
@type Function
@description Retorna o Json com o detalhamento do gráfico
@author Marco Nakazawa
@Return String Json com o detalhamento do gráfico
@since 21/03/2025
/*/
Static Function fJsonDtCht(aArrGenrc)
Local cJson			:= ""	as Character
Local cEmpNome		:= ""	as Character
Local nI			:= 0	as Numeric
Local nX			:= 0	as Numeric
Local nY			:= 0	as Numeric
Local nLenDados		:= 0	as Numeric
Local nLenSaldo		:= 0	as Numeric
Local nLenFunc		:= 0	as Numeric

Default aArrGenrc	:= {}

If !Empty(aArrGenrc)
	nLenDados := Len(aArrGenrc)

	For nI := 1 To nLenDados
		If nI == 1
			cJson := '"rows": ['
			nLenSaldo := Len(aArrGenrc[nI,2])
			cJson += '{'
		Else
			cJson += ',{'
		EndIf
		
		nLenFunc := Len(aArrGenrc[nI,3])

		cJson += 	'"company": "***EmpName***",'
		cJson += 	'"data": "' + aArrGenrc[nI,1] + '",'
		cJson += 	'"totalBalance": ['
		For nX := 1 To nLenSaldo
			If nX == 1
				cJson += '["' + aArrGenrc[nI,2,nX,1] + '", ' + cValToChar(aArrGenrc[nI,2,nX,4]) + ']'
			Else
				cJson += ',["' + aArrGenrc[nI,2,nX,1] + '", ' + cValToChar(aArrGenrc[nI,2,nX,4]) + ']'
			EndIf
		Next

		cJson += 	'],'
		cJson += 	'"details": ['

		For nX := 1 To nLenFunc
			If nX == 1
				cJson	+= '{'
				cJson	+= '"employeeName": "' + aArrGenrc[nI,3,nX,3] + '",'
				cJson	+= '"balance": ['

				cEmpNome := AllTrim(FWCompanyName(cEmpAnt, aArrGenrc[nI,3,nX,1]))
				cJson	:= StrTran(cJson, "***EmpName***", cEmpNome)
			Else
				cJson	+= ',{'
				cJson	+= '"employeeName": "' + aArrGenrc[nI,3,nX,3] + '",'
				cJson	+= '"balance": ['
			EndIf

			For nY := 1 To nLenSaldo
				If nY == 1
					cJson 	+= '["' + aArrGenrc[nI,3,nX,4,nY,1] + '", ' + cValToChar(aArrGenrc[nI,3,nX,4,nY,4]) + ']'
				Else
					cJson 	+= ',["' + aArrGenrc[nI,3,nX,4,nY,1] + '", ' + cValToChar(aArrGenrc[nI,3,nX,4,nY,4]) + ']'
				EndIf
			Next
			cJson		+= ']'
			cJson		+= '}'
		Next
		cJson += ']'
		cJson += '}'
	Next
	cJson += ']'
EndIf
Return cJson

/*/{Protheus.doc} fMontaGst
@type Function
@description Monta o array de gestores e seus funcionários para utilização do detalhamento do gráfico de gestores.
@author Marco Nakazawa
@Return Nil
@since 24/03/2025
/*/
Static Function fMontaGst(aArrGenrc, cFilialGst, cMatGst, cGestor, cFilDepto, cCodDepto, cDepto, cFilFunc, cMatFunc, cNomeFunc, cTipoEvt, nQtdHoras)
Local nPosGst		:= 0	as Numeric
Local nPosFunc		:= 0	as Numeric

Default aArrGenrc	:= {}
Default cFilialGst	:= ""
Default cMatGst		:= ""
Default cGestor		:= ""
Default cFilDepto	:= ""
Default cCodDepto	:= ""
Default cDepto		:= ""
Default cFilFunc	:= ""
Default cMatFunc	:= ""
Default cNomeFunc	:= ""
Default cTipoEvt	:= ""
Default nQtdHoras	:= 0

If !Empty(cFilDepto) .And. !Empty(cCodDepto) .And. !Empty(cDepto) .And. !Empty(cFilFunc) .And. !Empty(cMatFunc) .And. !Empty(cNomeFunc) .And. !Empty(cTipoEvt) 
	If Empty(aArrGenrc)
		aAdd(aArrGenrc, {cFilialGst, cMatGst, cGestor, cFilDepto, cCodDepto, cDepto, If(cTipoEvt $ "1*3", SomaHoras(0, nQtdHoras), SubHoras(0, nQtdHoras))})
		aAdd(aArrGenrc[1], {{cFilFunc, cMatFunc, cNomeFunc, aArrGenrc[1, 7]}})
	Else
		If (nPosGst := aScan(aArrGenrc, {|x| x[1] == cFilialGst .And. x[2] == cMatGst .And. x[4] == cFilDepto .And. x[5] == cCodDepto})) > 0
			If(cTipoEvt $ "1*3", aArrGenrc[nPosGst, 7] := SomaHoras(aArrGenrc[nPosGst, 7], nQtdHoras), aArrGenrc[nPosGst, 7] := SubHoras(aArrGenrc[nPosGst, 7], nQtdHoras))

			If (nPosFunc := aScan(aArrGenrc[nPosGst, 8], {|x| x[1] == cFilFunc .And. x[2] == cMatFunc})) > 0
				If(cTipoEvt $ "1*3", aArrGenrc[nPosGst, 8, nPosFunc, 4] := SomaHoras(aArrGenrc[nPosGst, 8, nPosFunc, 4], nQtdHoras), aArrGenrc[nPosGst, 8, nPosFunc, 4] := SubHoras(aArrGenrc[nPosGst, 8, nPosFunc, 4], nQtdHoras))
			Else
				aAdd(aArrGenrc[nPosGst, 8], {cFilFunc, cMatFunc, cNomeFunc, If(cTipoEvt $ "1*3", SomaHoras(0, nQtdHoras), SubHoras(0, nQtdHoras))})
			EndIf
		Else
			aAdd(aArrGenrc, {cFilialGst, cMatGst, cGestor, cFilDepto, cCodDepto, cDepto, If(cTipoEvt $ "1*3", SomaHoras(0, nQtdHoras), SubHoras(0, nQtdHoras))})
			aAdd(aArrGenrc[Len(aArrGenrc)], {{cFilFunc, cMatFunc, cNomeFunc, aArrGenrc[Len(aArrGenrc), 7]}})
		EndIf
	EndIf
EndIf
Return

/*/{Protheus.doc} fArrExcel
@type Function
@description Monta o array que será utilizado na geração do Excel.
@author Marco Nakazawa
@Return Nil
@since 23/05/2025
/*/
Static Function fArrExcel(aArrGenrc, cEmpresa, cItem, cFun, nHoras, dData, aPeriodos, lNovoFunc)
Local nI 			:= 0		as Numeric
Local nAtuPos		:= 0		as Numeric
Local nLenArray		:= 0		as Numeric

Default aArrGenrc	:= {}
Default aPeriodos	:= {}
Default cEmpresa	:= ""
Default cItem		:= ""
Default cFun		:= ""
Default dData		:= cToD("")
Default nHoras		:= 0
Default lNovoFunc	:= .F.

If Empty(aArrGenrc) .Or. lNovoFunc
	If lNovoFunc .And. !Empty(aArrGenrc)
		nLenArray := Len(aArrGenrc)

		For nI := 4 To Len(aArrGenrc[nLenArray])
			aArrGenrc[nLenArray, nI] := fNumToHr(aArrGenrc[nLenArray, nI])
		Next
	EndIf

	aAdd(aArrGenrc, {cEmpresa, cItem, cFun})

	nLenArray := Len(aArrGenrc)

	For nI := 1 To Len(aPeriodos)		
		aAdd(aArrGenrc[nLenArray], 0)
	Next
	
	nAtuPos := aScan(aPeriodos, {|x| dData >= x[2] .And. dData <= x[3]})

	If nAtuPos > 0
		nAtuPos := nAtuPos + 3

		For nI := nAtuPos To Len(aArrGenrc[nLenArray])
			aArrGenrc[nLenArray, nI] := SomaHoras(aArrGenrc[nLenArray, nI], nHoras)
		Next
	EndIf
ElseIf !lNovoFunc
	nLenArray := Len(aArrGenrc)
	
	nAtuPos := aScan(aPeriodos, {|x| dData >= x[2] .And. dData <= x[3]})

	If nAtuPos > 0
		nAtuPos := nAtuPos + 3

		For nI := nAtuPos To Len(aArrGenrc[nLenArray])
			aArrGenrc[nLenArray, nI] := SomaHoras(aArrGenrc[nLenArray, nI], nHoras)
		Next
	EndIf
EndIf
Return

/*/{Protheus.doc} fNumToHr
@description Retorna a hora em formato string ("01:30")
@author Marco Nakazawa
@since 23/05/2025
@version 1.0
@return NIL
@type function
/*/
Function fNumToHr(nHoras)
Local cHoras	:= ""
Local nHoraAbs	:= 0
Local nTamanho	:= 3

Default nHoras := 0

If nHoras < 0
	nHoraAbs := Abs(nHoras)
	nTamanho += Len(cValToChar(Int(nHoraAbs)))
	nTamanho := Max(5,nTamanho)
	cHoras := StrZero(nHoraAbs, nTamanho, 2)
	cHoras := StrTran(cHoras,".",":")
	cHoras := "-" + cHoras
Else
	nTamanho += Len(cValToChar(Int(nHoras)))
	nTamanho := Max(5,nTamanho)	
	cHoras := StrZero(nHoras, nTamanho, 2)
	cHoras := StrTran(cHoras,".",":")
EndIf
Return cHoras

/*/{Protheus.doc} fQryBuscAd
@description Retorna a query da busca avançada
@author Marco Nakazawa
@since 30/05/2025
@version 1.0
@return NIL
@type function
/*/
Function fQryBuscAd(aParams)
local cQuery		:= ""

Default aParams := {}

If !Empty(aParams["branch"])
	If (Empty(cQuery), cQuery += "UPPER(SRA.RA_FILIAL) LIKE '%" + Upper(AllTrim(aParams["branch"])) + "%'", cQuery += " AND UPPER(SRA.RA_FILIAL) LIKE '%" + Upper(AllTrim(aParams["branch"])) + "%'")
EndIf

If !Empty(aParams["name"])
	If (Empty(cQuery), cQuery += "UPPER(SRA.RA_NOME) LIKE '%" + Upper(AllTrim(aParams["name"])) + "%'", cQuery += " AND UPPER(SRA.RA_NOME) LIKE '%" + Upper(AllTrim(aParams["name"])) + "%'")
EndIf

If !Empty(aParams["registration"])
	If (Empty(cQuery), cQuery += "UPPER(SRA.RA_MAT) LIKE '%" + Upper(AllTrim(aParams["registration"])) + "%'", cQuery += " AND UPPER(SRA.RA_MAT) LIKE '%" + Upper(AllTrim(aParams["registration"])) + "%'")
EndIf

If !Empty(aParams["position"])
	If (Empty(cQuery), cQuery += "UPPER(SRJ.RJ_DESC) LIKE '%" + Upper(AllTrim(aParams["position"])) + "%'", cQuery += " AND UPPER(SRJ.RJ_DESC) LIKE '%" + Upper(AllTrim(aParams["position"])) + "%'")
EndIf

If !Empty(aParams["costCenters"])
	If (Empty(cQuery), cQuery += "UPPER(CTT.CTT_DESC01) LIKE '%" + Upper(AllTrim(aParams["costCenters"])) + "%'", cQuery += " AND UPPER(CTT.CTT_DESC01) LIKE '%" + Upper(AllTrim(aParams["costCenters"])) + "%'")
EndIf

If !Empty(aParams["manager"])
	If (Empty(cQuery), cQuery += "UPPER(SRAGEST.GESTOR) LIKE '%" + Upper(AllTrim(aParams["manager"])) + "%'", cQuery += " AND UPPER(SRAGEST.GESTOR) LIKE '%" + Upper(AllTrim(aParams["manager"])) + "%'")
EndIf

If !Empty(aParams["departament"])
	If (Empty(cQuery), cQuery += "UPPER(SQB.QB_DESCRIC) LIKE '%" + Upper(AllTrim(aParams["departament"])) + "%'", cQuery += " AND UPPER(SQB.QB_DESCRIC) LIKE '%" + Upper(AllTrim(aParams["departament"])) + "%'")
EndIf

If (!Empty(cQuery), cQuery := " AND (" + cQuery + ")", Nil)

Return cQuery

/*/{Protheus.doc} fExcelBh
@description Monta o Excel do Dashboard Banco de Horas
@author Marco Nakazawa
@since 23/05/2025
@version 1.0
@return NIL
@type function
/*/
Function fExcelBh(aExcel, lDeleta)
local aRet			:= {}									as Array
Local cFont			:= FwPrinterFont():Calibri()			as Character
Local cLogPatch		:= GetSrvProfString("Startpath","")		as Character
local cFilename		:= ""									as Character
local cHorAlign		:= ""									as Character
local cVertAlign	:= ""									as Character
local cBlob			:= ""									as Character
Local nI			:= 0									as Numeric
Local nY			:= 0									as Numeric
Local nX			:= 0									as Numeric
Local nLenExcel		:= 0									as Numeric
Local nLenDados		:= 0									as Numeric
Local nLenLinhas	:= 0									as Numeric
Local nLinha		:= 0									as Numeric
local oPrtXlsx		:= FwPrinterXlsx():New()				as Object
local oFile			:= Nil									as Object
Local oCellHorAl	:= FwXlsxCellAlignment():Horizontal()	as Object
Local oCellVerAl	:= FwXlsxCellAlignment():Vertical()		as Object

Default aExcel		:= {}
Default lDeleta		:= .F.

cFilename	:= cLogPatch + "dashboard_bh.rel"
cHorAlign	:= oCellHorAl:Center()
cVertAlign	:= oCellVerAl:Center()

If !Empty(aExcel)
	nLenExcel := Len(aExcel)
	
	oPrtXlsx:Activate(cFilename)

	For nI := 1 To nLenExcel
		// Cria a Aba do excel
		oPrtXlsx:AddSheet(aExcel[nI, 1, 1])
		
		// Define a fonte do título
		oPrtXlsx:SetFont(cFont, 16, .F., .T., .F.)
		oPrtXlsx:SetCellsFormat(cHorAlign, cVertAlign, .F., 0, "000000", "FFFFFF")

		// Pega o total de colunas para poder mesclar as colunas do título
		nLenDados := Len(aExcel[nI, 2])

		// Mescla as colunas da primeira linha (Título)
		oPrtXlsx:MergeCells(1, 1, 1, nLenDados)

		// Imprime o título
		oPrtXlsx:SetText(1, 1, aExcel[nI, 1, 2])

		// Define a fonte do cabeçalho
		oPrtXlsx:SetFont(cFont, 12, .F., .T., .F.)

		// Define o tamanho das colunas e imprime o cabeçalho
		For nY := 1 To nLenDados
			oPrtXlsx:SetColumnsWidth(nY, nY, aExcel[nI, 2, nY, 2])
			oPrtXlsx:SetText(2, nY, aExcel[nI, 2, nY, 1])
		Next

		// Incluir o filtro nas colunas
		oPrtXlsx:ApplyAutoFilter(2, 1, 2, nLenDados)

		// Define a fonte dos dados
		oPrtXlsx:SetFont(cFont, 11, .F., .F., .F.)

		// Imprime os dados
		nLenLinhas := Len(aExcel[nI, 3])
		
		// Linha inicial para preenchimento dos dados
		nLinha := 3
		If nLenLinhas > 0
			// Reseta as configuraçãos da celula do excel para o padrão
			oPrtXlsx:ResetCellsFormat()

			For nY := 1 To nLenLinhas
				nLenDados := Len(aExcel[nI, 3, nY])
				
				For nX := 1 To nLenDados
					oPrtXlsx:SetText(nLinha, nX, aExcel[nI, 3, nY, nX])
				Next

				nLinha++
			Next
		Else
			oPrtXlsx:MergeCells(3, 1, 3, nLenDados)
			oPrtXlsx:SetText(3, 1, "Não existem dados")
		EndIf
	Next 
EndIF

oPrtXlsx:toXlsx()
oPrtXlsx:EraseBaseFile()

oFile := FwFileReader():New(cLogPatch + "dashboard_bh.xlsx")

If (oFile:Open())
	cBlob := oFile:FullRead() 
	cBlob := Encode64(cBlob)

	aAdd(aRet,{"dashboard_bh.xlsx", cBlob, cLogPatch + "dashboard_bh.xlsx"})

	oFile:Close()

	If (lDeleta, fErase(cLogPatch + "dashboard_bh.xlsx"), Nil)
	If (lDeleta, fErase(cLogPatch + "dashboard_bh.rel"), Nil)
EndIf

oPrtXlsx:DeActivate()
oPrtXlsx:Destroy()

Return aRet
