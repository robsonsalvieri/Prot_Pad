#INCLUDE "GPEM690.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "RWMAKE.CH"
#INCLUDE "REPORT.CH"
#INCLUDE "PARMTYPE.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "FWMBROWSE.CH"

Static __cPeriodCalc
Static __cProcesCalc
Static __cNumPgCalc
Static __lMemCalc
Static lIntegDef 	:= FindFunction("GETROTINTEG") .And. FindFunction("FWHASEAI")
Static cFilAnterior	:= cFilAnt
Static cRotVerDiss
Static lValInfo		:= .T.
Static lTemCCT
Static nTpPerg

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Funcao vI ³ GPECR010 ³ Autor ³ Advanced RH                    ³ Data ³ 17/05/01 ³±±
±±³ Funcao vII³ GPEM690  ³ Autor ³ Advanced RH                    ³ Data ³ 23/11/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descricao ³ Calculo de dissidio retroativo.                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe   ³ GPEM690()                                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³ Especifico.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³	    		ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Programador ³ Data   ³ Chamado/FNC³             Motivo da alteracao             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Flavio S.    ³25/04/14³M_RH003     ³Unificacao Folha de Pagamento Versao 12      ³±±
±±³             ³        ³253401      ³                                             ³±±
±±³Flavio S.    ³29/04/14³TIEYG9      ³Criada variavel CFILRCJ para ser utilizada no³±±
±±³             ³        ³            ³no gpem020.                                  ³±±
±±³Raquel Hager ³29/07/14³TPZUF8      ³Inclusao de replicas versao 11 eSocial.      ³±±
±±³Flavio Corr. ³29/08/14³TPZSG6      ³Ajuste na query qdo parametros vazios        ³±±
±±³Thiago Y.M.N ³10/02/15³TRJYGA      ³Ajuste para calcular dissidio retroativo cor-³±±
±±³             ³        ³            ³retamente, quando há 2 alterações salariais  ³±±
±±³             ³        ³            ³referentes a mesma data porem com datas do   ³±±
±±³             ³        ³            ³calculo do dissidio diferentes.              ³±±
±±³Flavio Corr  ³19/03/15³PCREQ-4163  ³Integração Mensagem Unica                    ³±±
±±³Allyson M    ³14/12/15³TUAI32      ³Ajuste na geracao dos lancamentos em valores ³±±
±±³             ³        ³            ³futuros p/ gravar o campo RK_STATUS.         ³±±
±±³Raquel Hager ³07/01/16³TUCDBH      ³Carga na variavel dPerFim usada no filtro da ³±±
±±³             ³        ³            ³Gpm020Processa para roteiro 13.		        ³±±
±±³Allyson M    ³07/01/16³TUBROB      ³Incluida validacao de uso do alias QSRA      ³±±
±±³Gustavo M    ³27/05/16³TVFFAD      ³Ajuste para respeitar o acesso do usuario.   ³±±
±±³Eduardo K M  ³02/06/16³TVHJSM      ³Ajuste no impresso para que seja demonstrada ³±±
±±³             ³        ³            ³a filial corretada do sub totais das verbas. ³±±
±±³Cícero Alves ³15/07/16³TVQDYI      ³Ajuste para caso seja feito o calculo do		³±±
±±³             ³        ³      	  ³dissidio para mais de um mes, mas com % 		³±±
±±³             ³        ³      	  ³diferentes, a rotina só atualizava o 		³±±
±±³             ³        ³      	  ³historico com o valor do 1o. mes e a SRA 	³±±
±±³             ³        ³      	  ³ficava com o salario atualizado do ultimo mes³±±
±±³João Balbino ³20/09/16³TWCFE4      ³Ajuste para não efetuar o calculo para fun - ³±±
±±³             ³        ³            ³cionários de filial distinta da permissão do ³±±
±±³             ³        ³            ³usuário que processou o calculo.             ³±±
±±³Renan Borges ³29/11/16³            ³Ajuste para calcular dissidio com grid corre-³±±
±±³             ³        ³            ³tamente.                                     ³±±
±±³Oswaldo Leite³24/02/17³MRH-7378   ³Tratativa para campos utilizados somente pelo ³±±
±±³             ³        ³            ³Brasil                                       ³±±
±±³Eduardo K.	³27/03/18³MPRIMESP	  ³Ajuste p/ imprimir corretamente caso utilize ³±±
±±³             ³        ³-14477      ³indice diferente da ordem "1"                ³±±
±±³WinstonCosta	³03/01/19³            ³Retirado trecho que trata o banco AS/400     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GPEM690(nPosaRotina, aItens)
	Local aOfusca	:= If(FindFunction('ChkOfusca'), ChkOfusca(), { .T., .F. }) //[2]Ofuscamento
	Local aFldRel	:= If(aOfusca[2], FwProtectedDataUtil():UsrNoAccessFieldsInList( {"RA_NOME"} ), {})
    Local cFiltraRH	:= ChkRh("GPEM690", "SRA", "1")

	// Inicializa variaveis de execucao.
	Private lOfusca		:= Len(aFldRel) > 0
	Private aErrProc	:= Array(2, 0)
	Private aRotina		:= {}						// ajuste para versao 9.12 - chamada da funcao MenuDef() que contem aRotina
	Private cCadastro	:= OemToAnsi( STR0006 )
	Private bFiltraBrw	:= {|| Nil}					// Variavel para Filtro
	Private lGP690SAL	:= ExistBlock("GP690SAL")
	Private lGP690Fil	:= ExistBlock("GP690FIL")
	Private cProcesso 	:= ""
	Private cFilRCJ		:= ""
	Private aMnemo		:= {}
	Private lAuto
	Private nDisSalInc	:= 0
	Private lSegPlan    := FwIsInCallStack("WFLAUNCHER") .or. FwIsInCallStack("FWBOSCHDEXECUTE")
	/*********************************************************************************************************************/
	/*AO DECLARAR VARIAVEL PRIVATE AQUI SE ATENTAR SE SERA NECESSARIO DECLARÁ-LA NO GPEM020 POR CONTA DO GRID(Gpem020Amb)*/
	/*********************************************************************************************************************/

	Static aDados		:= {}

	DEFAULT nPosaRotina := 0
	DEFAULT __lMemCalc 	:= cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc() // Memória de Cálculo

	aDados       := If(Empty(aItens), {}, aItens)
	cFilAnterior := cFilAnt
	aRotina		 := MenuDef()

	If lSegPlan
		nPosaRotina := 2
		aDados      := {MV_PAR01}
	EndIf

	// Verifica se o arquivo esta vazio.
	If ! ChkVazio( 'SRA' )
		Return
	EndIf

	dbSelectArea("SRV")
	If Len(SRV->(RV_CODFOL)) == 3
		//"Atenção" "Antes de prosseguir, é necessario executar os procedimentos do boletim técnico - Alteração do campo Id de Cálculo"
		Help("", 1, OemToAnsi(STR0019), Nil, STR0137, 1, 0 )
		Return
	EndIf

	// Carrega mnemônicos
	SetMnemonicos(NIL, @aMnemo, .T.)

	If lAuto := !Empty(nPosaRotina) .And. (! Empty(aDados) .Or. (Empty(aDados) .And. nPosaRotina != 2))
		If nPosArotina > 4
			&(aRotina[nPosArotina, 2])
		Else
			&(aRotina[nPosArotina, 2] + "()")
		EndIf
	Else
		// Endereca a funcao de BROWSE.
		oBrwSRA := FwMBrowse():New()

		oBrwSRA:SetAlias( 'SRA' )
		oBrwSRA:SetDescription(OeMtoAnsi(cCadastro))
        oBrwSRA:SetFilterDefault(cFiltraRh)
		oBrwSRA:SetMenuDef( 'GPEM690' )

		GpLegMVC(@oBrwSRA)	// Adicionar a Legenda no Browse

		oBrwSRA:Activate()
	EndIf

Return

/*/{Protheus.doc} GP690CALC
Realiza a verificacao de calculo.
@author Advanced RH
@since 17/05/2001
@type function
/*/
Function GP690CALC()

	Local aSalva	:= GetArea()	// Area atual
	Private cPerg	:= ''

	DEFAULT lTemCCT := cPaisLoc == "BRA" .and. RCE->(ColumnPos("RCE_CCT")) > 0

	nTpPerg := 1

	cPerg	:= If(lTemCCT,'GPCR13','GPCR12')

	// Carrega parametros.
	Pergunte( cPerg, .F. )

	// Monta tela de dialogo.
	cCadastro	:= OemToAnsi( STR0006 )
	cDescricao 	:= OemToAnsi( STR0051 )
	bProcesso 	:= {|oSelf| GP690CAL(oSelf) }
	cProcesso 	:= MV_PAR01

	If !Empty(cProcesso)
		dbSelectArea("RCJ")
		RCJ->(dbSetOrder(1))
		If RCJ->(dbSeek(xFilial("RCJ")+cProcesso))
			cFilRCJ := xFilial("RCH",SRA->RA_FILIAL)
		EndIf
	EndIf

	aErrProc:= Array(2, 0)
	cFilAnt := cFilAnterior

	If(!lAuto, tNewProcess():New( "GPEM690", cCadastro, bProcesso, cDescricao, cPerg, , .T., 20, cDescricao, .T.), GP690Cal())

	RestArea( aSalva )

Return

/*/{Protheus.doc} GP690CAL
Calculo do dissidio retroativo
@author Advanced RH
@since 17/05/2001
@param oSelf, object, Objeto TNewProcess
@type function
/*/
Function GP690CAL(oSelf,aItens,lRecalculo)

	Local aArea			:= GetArea()
	Local aSR7Area		:= SR7->(GetArea())
	Local aSR3Area		:= SR3->(GetArea())
	Local aRHHArea		:= RHH->(GetArea())

	// Declara variaveis locais de trabalho.
	Local aMes			:= { STR0093, STR0094, STR0095, STR0096, STR0097, STR0098, STR0099, STR0100, STR0101, STR0102, STR0103, STR0104 }
	Local aMeses		:= {}
	Local aAdvSize		:= {}
	Local aInfoAdvSize	:= {}
	Local aObjSize		:= {}
	Local aObjCoords	:= {}
	Local aAdv1Size		:= {}
	Local aInfo1AdvSize	:= {}
	Local aObj1Size		:= {}
	Local aObj1Coords	:= {}
	Local aAdv11Size	:= {}
	Local aInfo11AdvSize:= {}
	Local aObj11Size	:= {}
	Local aObj11Coords	:= {}
	Local aCcTrans		:= {}
	Local aPerAberto	:= {}
	Local aPerFechado	:= {}
	Local aPerTodos		:= {}
	Local aProcessoLog	:= {}
	Local aSavMsgLog	:= {}
	Local aSavProcLog	:= {}
	Local aIndex		:= {}
	Local aIRMV			:= {}
	Local aHdrMestre	:= {}
	Local aSalva 		:= GetArea()	// Area atual
	Local aConvoc		:= {}
	Local aFaixasBkp	:= {}
	Local cMesAnoDe
	Local cMesAnoAte
	Local nIndReaj
	Local cMesCabec
	Local cMesDiss		:= ""
	Local cMsgLog
	Local cCcTrans		:= ""
	Local cSituaAtu		:= ""
	Local cQuery		:= ""
	Local cUltDia		:= ""
	Local cExpFiltro	:= ""					//variavel com o retorno do filtro
	Local cAuxFiltro	:= ""					//retorno do filtro com a filial
	Local cTabMestra	:= "SRA"				//nome da Tabela Mestra
	Local cAliasSRA		:= "QSRA"
	Local cSit	   		:= ""
	Local cCat	   		:= ""
	Local cFilRange		:= ""
	Local cCCRange		:= ""
	Local cMatRange		:= ""
	Local cSindRange	:= ""
	Local cNomeRange	:= ""
	LOcal cFuncRange	:= ""
	Local cWhere		:= ""
	Local _nQtd			:= 0
	Local nPos	   		:= 0
	Local nRecCount		:= 0
	Local nI			:= 0
	Local nJ			:= 0
	Local nQtPer		:= 0
	Local nLog			:= 0
	Local nBaseMes  	:= 0
	Local nMesAux		:= 0
	Local nDiaAux 		:= 0
	Local nDifer		:= 0
	Local nTReg			:= 0
	Local lFirst		:= .T.
	Local lConsidera	:= .T.
	Local lRet			:= .T.
	Local lAjProp 		:= ExistBlock("GPREAJPROP")
	Local l690Perc 		:= ExistBlock("GPM690PERC")
	Local lErroVDiss	:= .F.
	Local lNewMultV		:= .F.
	Local oGet
	Local oDlg
	Local oFont
	Local dDataDe		:= CtoD("//")
	Local dDataDis		:= CtoD("//")
	Local dDataProj		:= CtoD("//")
	Local dDtMesApur	:= CtoD("//")
	Local dDtFimAcord	:= CtoD("//")

	Local uRet

	Local cRoteiro		:= MV_PAR02				//codigo do roteiro
	Local cAnoMesCal	:= MV_PAR03
	Local cFilFOL		:= MV_PAR08
	Local cCCFOL		:= MV_PAR09
	Local cMatFOL		:= MV_PAR10
	Local cNomeFOL		:= MV_PAR11
	Local cCategoria	:= MV_PAR13
	Local cSindFOL
	Local nCriterio
	Local nArredonda
	Local nProdAdm
	Local cFuncFOL
	Local cCompl
	Local cCodCCT		:= ""
	Local cSindCCT		:= ""
	Local cArqInf		:= ""
	Local cFilRot		:= ""
	Local lIntegr		:= .F.
	Local nPisoAux		:= 0
	Local nSalAux       := 0
	Local oProfile		:= FwProfile():New()
	Local cCatX			:= ""
	Local cCat_Atu		:= ""
	Local lClose        := .T.
	Local nX            := 0
	Local aParams       := {}

	Private nMesProp
	Private nVlPiso
	
	DEFAULT lTemCCT := cPaisLoc == "BRA" .and. RCE->(ColumnPos("RCE_CCT")) > 0

	If lTemCCT
		cCodCCT		:= MV_PAR14
	EndIf

	cSindFOL	:= MV_PAR15
	nCriterio 	:= MV_PAR17
	nArredonda	:= MV_PAR18
	nProdAdm	:= MV_PAR19
	nMesProp    := Val(MV_PAR20)
	nVlPiso		:= MV_PAR21
	cFuncFOL	:= MV_PAR22
	cCompl		:= MV_PAR23
	If lValInfo
		cArqInf		:= MV_PAR24
	EndIf

	Private cAxTabMestra	:= ""
	Private lCalIRMV		:= .F.	// Variavel utilizada para determinar se existe calculo de IRMV
	Private aGpem020Log		:= {}
	Private aGpem020TitLog	:= {}
	Private cFterAux		:= ""
	Private nMinGrid 		:= GetMvRH("MV_MINGRID",, 0)
	Private lDissidio 		:= .T.
	If Type( "lGrid" ) == "U"
		Private lGrid := GetMvRH("MV_GRID", , .F.) // Se o parametro esta configurado para utilizacao do GRID
	EndIf

	Private cSvProcesCalc
	Private cSvPeriodCalc
	Private cSvNumPgCalc
	Private cSvRoteiro
	Private cPergEspec 	:= ""
	Private cPergBen	:= ""
	Private cCompPer	:= ""	// Competencia do Periodo

	Private nBaseMesAux	:= 0
	Private cSemana 	:= "  " //If( cSemPerg == 2, "01", "  " ) 			// 1=nao calcula ; 2=calcula para semanalistas
	Private cSemPag		:= MV_PAR04 //Semana Pagamento  UTILIZADADO NA FUNCAO GRAVADISSIDIO
	Private cSituacao	:= MV_PAR12
	Private cTipoAum	:= If(lTemCCT,MV_PAR25,MV_PAR14)
	Private lProAdm     := If(nProdAdm	 == 1, .F. , .T.)	//Proporcional Admissao(1-Nao;2-Sim)
	Private cMesAnoCalc	:= MV_PAR03 // usado na funcao fSalDiss
	Private cMesAnoDiss	:= MV_PAR03
	Private cIdCmpl		:= cCompl
	Private aHeader		:= {}
	Private aTELA		:= { 0, 0 }
	Private aGETS		:= { 0 }
	Private nUsado		:= 0
	Private aCols		:= { {} }
	Private nLinGetD	:= 0
	Private cTitPerc	:= STR0008
	Private aC			:= {}
	Private aR			:= {}
	Private aCGD		:= {}
	Private cExclui		:= ''
	Private aFaixas		:= {}
	Private aCodFol		:= {}
	Private aPercDif	:= {}
	Private aFilRCH		:= {}
	Private lAbortPrint := .F.
	
	Private nPisoMes	:= nVlPiso
	Private nPisoDia	:= (nVlPiso) / 30
	Private nPisoHora	:= (nVlPiso) / 220
	Private nPercDif 	:= 0
	Private nPercProp	:= 0
	Private nValAum  	:= 0
	Private cDatArq  	:= ""
	Private dDInicioTar := ctod("//")

	Private aSalInc		:= {}
	Private aTotRegs  	:= array(2)
	Private aLog		:= {}
	Private aTitle		:= {}
	Private cAnoMesProp	:= ""
	Private nOrigHor	:= 0
	Private nOrigVal	:= 0
	Private nOrigHrMat	:= 0
	Private nOrigVlMat	:= 0

	Private lContrInt	:= If(SRC->(ColumnPos( 'RC_CONVOC' )) > 0,.T.,.F.)
	Private oPercDif

	DEFAULT aItens		:= {}
	DEFAULT lRecalculo  := .F.

	If lRecalculo //Se for recalculo, não executa GRID, pois é apenas um funcionário
		lGrid := .F.
	EndIf

	MakeSqlExpr( cPerg ) //Transforma perguntas do tipo Range em expressao SQL

	//Verifica se o processo foi selecionado para validacao do periodo correspondente
	If !IsBlind() .And. ( Empty(cFilRCJ) .And. !Empty(xFilial("RCJ")) )
		aSolucao := {}
		cMsgAlert := OemToAnsi(STR0152) //"Não foi possível localizar o período de cálculo."
		aAdd( aSolucao, { OemToAnsi(STR0153) } ) //"Selecione novamente o Processo para que o sistema atualize os dados do período."
		Help( ,, OemToAnsi(STR0019),, OemToAnsi(cMsgAlert) , 1,,,,,,, aSolucao )	//"Atencao"
		Return .F.
	Else
		cFilRCJ	:= If( Empty(cFilRCJ), xFilial("RCH"), cFilRCJ )
	EndIf

	//Valida os periodos de calculo das demais filiais definidas na pergunta Filial
	aFilRCH := fGP690Per(cRoteiro)
	If Len( aFilRCH ) > 0
		For nQtPer := 1 To Len(	aFilRCH )
			If !Empty( aFilRCH[nQtPer,2] )
				Help( ' ', 1, 'PER_FECHADO' )
				Return .F.
			EndIf
			aPerAtual := {}
			If fGetPerAtual( @aPerAtual, aFilRCH[nQtPer,1], cProcesso, cRoteiro)
				If aFilRCH[nQtPer,4] != aPerAtual[1,1]
					aSolucao := {}
					aAdd( aSolucao, { OemToAnsi(STR0153)}) //"Selecione novamente o Processo para que o sistema atualize os dados do per?odo."
					Help( ,, OemToAnsi(STR0019),, OemToAnsi(STR0196) + aFilRCH[nQtPer,3], 1,,,,,,, aSolucao )	//"Atencao"
					Return .F.
				EndIf
			Else
				HELP( " ",1,"GPCALEND",  ) // Não existe período cadastrado
				Return(.F.)
			EndIf
		Next nQtPer
	Else
		HELP( " ", 1, "GPCALEND",  )	// Não existe período cadastrado
		Return .F.
	EndIf

	If Empty( MV_PAR03 )
		//"Atencao"##'Preencha o parâmetro "Mes/Ano do calculo"'
		Help("", 1, OemToAnsi(STR0019), Nil, STR0090, 1, 0 )
		Return .F.
	EndIf

	dDtMesApur	:= CTOD('01/'+Substr(cAnoMesCal,5,2)+"/"+Substr(cAnoMesCal,1,4),"DDMMYYYY")
	cUltDia		:= STR(Last_Day(dDtMesApur))
	dDtFimAcord	:= CTOD(cUltDia+'/'+Substr(cAnoMesCal,5,2)+"/"+Substr(cAnoMesCal,1,4),"DDMMYYYY")
	If MV_PAR16 > dDtFimAcord
		//"Atencao"# Data Acordo # "maior que período Mês/Ano Cálculo" # "Data Acordo Inválida"
		Help("", 1, OemToAnsi(STR0019), Nil, OemToAnsi(STR0133) + " (" + DTOC(MV_PAR16) + ") " + OemToAnsi(STR0134) + " (" + cAnoMesCal + ").", 1, 0 )
		Return .F.
	ElseIf MV_PAR16 > dDataBase
		//"Atencao" # Data Acordo" # maior que database do sistema" # "Data Acordo Inválida"
		Help("", 1, OemToAnsi(STR0019), Nil, OemToAnsi(STR0133) + " " + OemToAnsi(STR0135) + ".", 1, 0 )
		Return .F.
	EndIf

	If cPaisLoc == "BRA" .And. Empty( cTipoAum )
		//"Atencao"##'Efetue o preenchimento da pergunta "Tipo Aumento"'
		Help("", 1, OemToAnsi(STR0019), Nil, STR0202, 1, 0 )
		Return .F.
	EndIf

	If !Empty(cCodCCT)
		cSindCCT := fLoadSind(cCodCCT)
	EndIf

	Afill(aTotRegs,0)

	If !lAuto
		// Monta as Dimensoes dos Objetos
		aAdvSize		:= MsAdvSize()
		aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
		aAdd( aObjCoords , { 000 , 045 , .T. , .F. } )
		aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
		aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

		aAdv1Size		:= aClone(aObjSize[1])
		aInfo1AdvSize	:= { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 5 , 5 }
		aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
		aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
		aObj1Size		:= MsObjSize( aInfo1AdvSize , aObj1Coords )

		aAdv11Size		:= aClone(aObj1Size[2])
		aInfo11AdvSize	:= { aAdv11Size[2] , aAdv11Size[1] , aAdv11Size[4] , aAdv11Size[3] , 1 , 1 }
		aAdd( aObj11Coords , { 030 , 000 , .F. , .T. } )
		aAdd( aObj11Coords , { 015 , 000 , .F. , .T. } )
		aAdd( aObj11Coords , { 000 , 000 , .T. , .T. } ) //-Espaco
		aAdd( aObj11Coords , { 030 , 000 , .F. , .T. } )
		aAdd( aObj11Coords , { 015 , 000 , .F. , .T. } )
		aAdd( aObj11Coords , { 000 , 000 , .T. , .T. } )//-Espaco
		aAdd( aObj11Coords , { 030 , 000 , .F. , .T. } )
		aAdd( aObj11Coords , { 015 , 000 , .F. , .T. } )
		aAdd( aObj11Coords , { 000 , 000 , .T. , .T. } ) //-Espaco
		aObj11Size		:= MsObjSize( aInfo11AdvSize , aObj11Coords,,.T. )
	EndIf

	// Ajusta variaveis de trabalho.
	If Empty(MV_PAR05) .or. Empty( MV_PAR06 )
		//"Atencao" # "Preencha o periodo de calculo do dissidio" # "Data em branco"
		Help("", 1, OemToAnsi(STR0019), Nil, STR0062, 1, 0 )
		Return .F.
	EndIf

	cMesCabec	:= SubStr( MV_PAR05, 3, 4 ) + SubStr( MV_PAR05, 1, 2 )
	cMesAnoDe	:= SubStr( MV_PAR05, 3, 4 ) + SubStr(MV_PAR05, 1, 2 )
	cMesAnoAte	:= SubStr( MV_PAR06, 3, 4 ) + SubStr( MV_PAR06, 1, 2 )
	nIndReaj	:= If( Empty( mv_par07 ), 2, mv_par07 )

	If cAnoMesCal+MV_PAR04 == cMesAnoDe+'01' .or. cAnoMesCal+MV_PAR04 == cMesAnoAte+'01'
		//"Atenção","Corrija o mês e ano de/até informado nos parâmetros pois ambos devem pertencer a períodos fechados."
		Help("", 1, OemToAnsi(STR0019), Nil, STR0195, 1, 0 )
		Return .F.
	EndIf

	If cMesAnoDe <= cMesAnoAte
		If ( Right(cMesAnoDe, 2) < "01" .Or. Right(cMesAnoDe, 2) > "12" ) .Or. ;
		( Right(cMesAnoAte, 2) < "01" .Or. Right(cMesAnoAte, 2) > "12" )
			//"Atenção","Corrija o mês e ano de/até informado nos parâmetros pois ambos tem que estar entre 01 (Janeiro) e 12 (Dezembro)."
			Help("", 1, OemToAnsi(STR0019), Nil, STR0058, 1, 0 )
			Return .F.
		EndIf
	Else
		Help("", 1, OemToAnsi(STR0019), Nil, STR0061, 1, 0 )
		Return .F.
	EndIf

	If !lRecalculo
		// Verifica se o calculo ja foi efetuado.
		dbSelectArea( "RHH" )
		RHH->(dbSetOrder( RetOrder( "RHH", "RHH_FILIAL+RHH_MAT+RHH_DATA+RHH_MESANO+RHH_VB+RHH_CC+RHH_ITEM+RHH_CLVL" )))
		nTReg := 0

		cQuery := "SELECT RHH_FILIAL, RHH_DATA, RHH_MAT, RHH_MESANO, RHH_VB, RHH_CC, RHH_ITEM, RHH_CLVL, RHH_INTEGR"
		cQuery += "  FROM " + RetSqlName( "RHH" ) + " RHH "
		cQuery += " INNER JOIN " + RetSqlName( "SRA" )  + " SRA "
		cQuery += " ON RA_FILIAL = RHH_FILIAL AND RA_MAT = RHH_MAT "
		cQuery += " WHERE RHH.RHH_DATA BETWEEN '" + cMesAnoDe + "' AND '" + cMesAnoAte + "' "
		cQuery += " AND RHH.RHH_MESANO = '" + cMesAnoCalc + "' "

		If ! Empty(MV_PAR08)
			cQuery += " AND " + Replace(MV_PAR08, "RA_", "RHH_")
		EndIf

		If ! Empty(MV_PAR09)
			cQuery += " AND " + Replace(MV_PAR09, "RA_", "RHH_")
		EndIf

		If ! Empty(MV_PAR10)
			cQuery += " AND " + Replace(MV_PAR10, "RA_", "RHH_")
		EndIf

		If !Empty(MV_PAR15)
			cQuery += " AND " + Replace(MV_PAR15, "RA_SINDICA", "RHH_SINDIC")
		EndIf
		If !Empty(cSindCCT)
			cQuery += " AND RHH_SINDIC IN (" + cSindCCT + ")"
		EndIf

		If !Empty(MV_PAR22)
			cQuery += " AND " + MV_PAR22
		EndIf

		If !Empty(MV_PAR12) //SitFOL
			cSitQuery	:= ""
			cSituacao 	:= MV_PAR12
			For nI:=1 to Len(cSituacao)
				cSitQuery += "'"+Subs(cSituacao,nI,1)+"'"
				If ( nI+1 ) <= Len(cSituacao)
					cSitQuery += ","
				Endif
			Next nI
			If !Empty(cSitQuery)
				cQuery += " AND "
				cQuery += "( RA_SITFOLH IN ("+ cSitQuery +"))"
			EndIF
		EndIf

		If !Empty(MV_PAR13) //Categoria
			cCatQuery	:= ""
			cCat_Atu	:= ""
			cCategoria	:= MV_PAR13
			For nI:=1 to Len(cCategoria)
				cCatX := Subs(cCategoria,nI,1)
				cCatX := If( cCatX $("EG"), "#", cCatX )
				cCatQuery += "'"+cCatX+"'"
				cCat_Atu += cCatX
				If ( nI+1 ) <= Len(cCategoria)
					cCatQuery += ","
				Endif
			Next nI
			cCategoria := cCat_Atu
			If !Empty(cCatQuery)
				cQuery += " AND "
				cQuery += "( RA_CATFUNC IN ("+ cCatQuery +"))"
			EndIf
		EndIf

		If ! Empty(cProcesso)
			cQuery += " AND RHH_PROCES = '" + cProcesso + "' "
		Endif

		cQuery += "   AND RHH.D_E_L_E_T_ = ' ' "
		cQuery += "	ORDER BY RHH_FILIAL, RHH_DATA, RHH_MAT, RHH_MESANO, RHH_VB, RHH_CC, RHH_ITEM, RHH_CLVL "

		cQuery := ChangeQuery( cQuery )

		dbUseArea( .T., "TOPCONN", TcGenQry( ,,cQuery ), "RHH2" )

		If Select( "RHH2" ) > 0
			While ( "RHH2" )->(!Eof())
				If ( "RHH2" )->RHH_INTEGR == "S"
					lIntegr := .T.
				EndIf
				nTReg++
				( "RHH2" )->(dbSkip())
			Enddo
			( "RHH2" )->( dbCloseArea() )
		EndIf

		dbSelectArea( "RHH" )
		RHH->(dbSetOrder( RetOrder( "RHH", "RHH_FILIAL+RHH_MAT+RHH_DATA+RHH_MESANO+RHH_VB+RHH_CC+RHH_ITEM+RHH_CLVL" ) ))

		If nTReg > 0
			If ! lAuto .And. Aviso( STR0019, STR0043, { STR0044, STR0045 } ) == 2	// "Ja existe um calculo efetuado, deseja recalcular?"
				RestArea( aSalva )
				Return .F.
			ElseIf lIntegr
				MsgAlert(OemToansi(STR0198),  OemToAnsi( STR0197 )  )
				// "Não é possível recalcular pois o período selecionado já foi integrado à Folha de Pagamento, revise os parâmetros."
				// "Período integrado!"
				RestArea( aSalva )
				Return .F.
			Endif
		Endif
	EndIf

	dbSelectArea( "RHH" )
	RHH->(dbSetOrder( RetOrder( "RHH", "RHH_FILIAL+RHH_MAT+RHH_DATA+RHH_MESANO+RHH_VB+RHH_CC+RHH_ITEM+RHH_CLVL" ) ))

	// Monta tabela de reajuste.
	Aadd( aHeader, { STR0009, 'SALDE' , '@E 9,999,999,999.99', 16, 2, 'positivo()', 'û', 'N', '  ', ' ' } )	//'Faixa De'
	Aadd( aHeader, { STR0010, 'SALATE', '@E 9,999,999,999.99', 16, 2, 'positivo()', 'û', 'N', '  ', ' ' } )	//'Faixa Ate'
	Aadd( aHeader, { STR0052, 'VALFIX', '@E 99,999,999.99', 13, 2, 'positivo()', 'û', 'N', '  ', ' ' } )	//'Valor Aumento'

	Aadd( aHeader, { STR0059, "ADMISSADT1" ,""                 , 08, 0, "naovazio()", "û", "D", "  "," ","",""})	//"Data Admissao de "
	Aadd( aHeader, { STR0060, "ADMISSADT2" ,""                 , 08, 0, "naovazio()", "û", "D", "  "," ","","" })	//"Data Admissao Ate"

	If nIndReaj = 2
		Aadd( aHeader, { STR0011, 'SALPERC', '@E 999.999999'       , 10, 6, 'positivo()', 'û', 'N', '  ', ' ' } )	//'% Aumento'
	Else
		Do While .t.
			Aadd( aHeader, { '( % )  ' + aMes[ Val( Right( cMesCabec, 2 ) ) ] + '/' + Left( cMesCabec, 4 ), 'SALP'+cMesCabec, '@E 999.999999'       , 10, 6, 'positivo()', 'û', 'N', '  ', ' ' } )	//'% Aumento'
			If cMesCabec = cMesAnoAte
				Exit
			EndIf
			If Right( cMesCabec, 2 ) = '12'
				cMesCabec := StrZero( Val( Left( cMesCabec, 4 ) ) + 1, 4, 0 ) + '01'
			Else
				cMesCabec := Left( cMesCabec, 4 ) + StrZero( Val( Right( cMesCabec, 2 ) ) + 1, 2, 0 )
			EndIf
		Enddo
	Endif

	For nI := 1 To Len( aHeader )
		If lRecalculo
			If nI <= Len(aItens)
				aAdd(aCols[1], aItens[nI,2])
			Else
				aAdd(aCols[1], aItens[Len(aItens),2])
			EndIf
		Else
			If nI == 4 .Or. nI == 5
				Aadd( aCols[1], ctod("  /  /  ") )
			Else
				Aadd( aCols[1], 0 )
			EndIf
		EndIf
	Next

	Aadd( aCols[1], .f. )
	If !lRecalculo
		aCols[1, 1]	:= 0.01
	EndIf
	nUsado := Len( aCols[1] )

	If !lAuto
		While .T.

			If !lRecalculo
				oProfile:SetUser( RetCodUsr() )
				oProfile:SetProgram( "GPEM690" )
				oProfile:SetTask( "GPEM690PARAM" )

				aFaixasBkp := oProfile:Load()
				If !Empty(aFaixasBkp) .And. Len(aFaixasBkp[1])-1 == Len(aHeader)
					aCols := aClone(aFaixasBkp)
				EndIf
			EndIf

			nOpca := 0

			DEFINE MSDIALOG oDlg TITLE OemtoAnsi(STR0067) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL	 //"Informe as Faixas"

			oGroup:= tGroup():New(aObjSize[1,1],aObjSize[1,2],aObjSize[1,3],aObjSize[1,4],'',oDlg,,,.T.)

			@ aObj1Size[1,1],aObj1Size[1,2] say STR0068 SIZE 200,10 of oDlg PIXEL FONT oFont COLOR CLR_HBLUE  //"Piso Salarial: Valores calculados considerando 220h/mes."

			@ aObj11Size[1,1],aObj11Size[1,2] say ALLTRIM(SUBSTR(STR0069,1,(LEN(STR0069)-1)))+":"  SIZE 55,7 of oDlg PIXEL  // //"Piso/Mes    :"
			@ aObj11Size[2,1],aObj11Size[2,2] MsGet nPisoMes SIZE 57,11 OF oDlg PIXEL PICTURE "@E 999,999,999.99"  HASBUTTON when cCategoria $ "M*C*P*A*E*S*I" valid r200Piso(nPisomes,@nPisoHora,@nPisoDia)

			@ aObj11Size[4,1],aObj11Size[4,2] say ALLTRIM(SUBSTR(STR0070,1,(LEN(STR0070)-1)))+":"  SIZE 55,7 of oDlg PIXEL  //"Piso/Hora   :"
			@ aObj11Size[5,1],aObj11Size[5,2] MsGet nPisoHora SIZE 57,11 OF oDlg PIXEL PICTURE "@E 999,999,999.99" HASBUTTON when cCategoria $ "H*T*G*J" valid r200Piso(@nPisomes,nPisoHora,@nPisoDia)

			@ aObj11Size[7,1],aObj11Size[7,2] say ALLTRIM(SUBSTR(STR0071,1,(LEN(STR0071)-1)))+":"  SIZE 55,7 of oDlg PIXEL  //"Piso/Dia    :"
			@ aObj11Size[8,1],aObj11Size[8,2] MsGet nPisoDia  SIZE 57,11 OF oDlg PIXEL PICTURE "@E 999,999,999.99" HASBUTTON when cCategoria $ "D" valid r200Piso(@nPisomes,@nPisoHora,nPisoDia)

			oGet  := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],2,'M690ChkTab','M690ChkTab',"",.T.)

			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,If(oGet:TudoOk(),oDlg:End(),nOpca:=0)},{||oDlg:End()}) CENTERED

			If	nOpca == 1
				Exit
			Else
				Return .F.
			EndIf
		EndDo
	Else
		For nI := 1 To Len(aDados) //	Linhas
			If nI > 1
				Aadd(aCols, {0, 0, 0, cTod("//"), cTod("//"), 0, .F.})
			EndIf

			For nJ := 1 To Len(aDados[nI]) // Campos
				aCols[nI][aScan(aHeader, {|x| x[2] == aDados[nI][nJ][1] })] := aDados[nI][nJ][2]
			Next
		Next
		nOpca := 1
	EndIf

	For nI := 1 To Len( aCols )
		If aCols[nI, nUsado] == .F.
			Aadd( aFaixas, aCols[nI] )
		EndIf
	Next

	If !lAuto .And. !lRecalculo	
    	oProfile:SetProfile( aFaixas )
        oProfile:Save()
        oProfile:DeActivate()
	EndIf

	cFilRange	:=	MV_PAR08
	cCCRange	:= 	MV_PAR09
	cMatRange	:=  MV_PAR10
	cFuncRange	:=  MV_PAR22
	cSindRange	:=  MV_PAR15
	cNomeRange	:= 	MV_PAR11


	If !Empty(cFilRange)
		cWhere += cFilRange + " AND "
	EndIf

	If !Empty(cCCRange)
		cWhere += cCCRange + " AND "
	EndIf

	If !Empty(cMatRange)
		cWhere += cMatRange + " AND "
	EndIf

	If !Empty(cSindRange)
		cWhere += cSindRange + " AND "
	EndIf

	If !Empty(cFuncRange)
		cWhere += cFuncRange + " AND "
	EndIf

	If !Empty(cProcesso)
		cWhere += " (RA_PROCES = '" + cProcesso + "') AND "
	Endif


	For nPos := 1 To Len(cSituacao)
		If substr(cSituacao,nPos,1) <> "*"
			cSit += "'" + substr(cSituacao, nPos, 1) + "',"
		EndIf
	Next nPos
	If Len(cSit)>1
		cSit := substr(cSit,1,Len(cSit)-1)
		cWhere += " RA_SITFOLH IN(" + cSit + ") AND "
		nPos := 0
	EndIf

	For nPos := 1 To Len(cCategoria)
		If SubStr(cCategoria, nPos, 1) <> "*" .And. ! Empty(substr(cCategoria, nPos, 1))
			cCat += "'" + substr(cCategoria, nPos, 1) + "',"
		EndIf
	Next nPos
	If Len(cCat)>1
		cCat := substr(cCat, 1, Len(cCat) - 1)
		cWhere += " RA_CATFUNC IN(" + cCat + ") AND "
		nPos := 0
	EndIf
	//Carrega apenas sindicatos associadas a CCT
	If !Empty(cSindCCT)
		cWhere += " RA_SINDICA IN(" + cSindCCT + ") AND "
	EndIf

	If ! Empty(cWhere)
		cWhere := "%" + cWhere + "%"
	Else
		cWhere := "% %"
	EndIf

	If Select("QSRA") > 0
		QSRA->( dbCloseArea() )
	EndIF

	If lGP690Fil
		cWhere := ExecBlock("GP690FIL", .F., .F., {1, cWhere} )
	EndIf

	BeginSQL Alias cAliasSRA
		SELECT RA_FILIAL, RA_MAT, RA_NOME, RA_CC, R_E_C_N_O_ RECNO
		FROM %table:SRA% SRA
		WHERE %exp:cWhere%
		SRA.%notDel%
		ORDER BY RA_FILIAL, RA_MAT
	EndSQL

	// Posiciona ponteiros do arquivo SRA.
	DbSelectArea(cAliasSRA)
	Count To _nQtd
	dbSelectArea(cAliasSRA)
	(cAliasSRA)->( DbGoTop() )

	If !lAuto .and. !lRecalculo
		ProcRegua( (cAliasSRA)->( RecCount() ) )
		oSelf:SetRegua1((cAliasSRA)->(RecCount()))
	EndIf

	cFilAnte := Replicate("!", FWGETTAMFILIAL)
	cFilSRVant :=  Replicate("!", FWGETTAMFILIAL)
	aCodFol := {}

	If ValType(oPercDif) == "O"
		HMClean(oPercDif)
		FreeObj(oPercDif)
		oPercDif := Nil
	EndIf

	oPercDif := HMNew() //Cria hash map

	If !lRecalculo
		aDissInf := {}
	EndIf

	Do While !(cAliasSRA)->(Eof()) .And. (cAliasSRA)->(RA_FILIAL) $ fValidFil()

		dbSelectArea("SRA")
		SRA->(dbGoTo((cAliasSRA)->RECNO))

		If SRA->RA_FILIAL != cFilAnte .AND. (FWxFilial("SRV", SRA->RA_FILIAL) != cFilSRVant )
			aCodFol := {}
			cFilAnte := SRA->RA_FILIAL
			cFilSRVant := FWxFilial("SRV", SRA->RA_FILIAL)
			If !Fp_CodFol( @aCodFol, cFilSRVant )
				Exit
			Endif

			SetMnemonicos(xFilial("RCA", SRA->RA_FILIAL),NIL,.T.,"P_DISSPAVP")
			P_DISSPAVP	:= If( Type("P_DISSPAVP") == "U", .F. , P_DISSPAVP)

			If cPaisLoc == "BRA"
				SetMnemonicos(xFilial("RCA", SRA->RA_FILIAL),NIL,.T.,"P_MULTV")
				lNewMultV := P_MULTV //Guarda valor original, se cálculo da folha foi efetuado com padrão de MULTV antigo, o mnemônico será alterado no GPEXINI e deve ser retornado o valor original para o próximo mês
			EndIf
			
			// Verifica cadastro de verbas.
			dbSelectArea( 'SRV' )
			dbGoTop()
			If DbSeek(cFilSRVant)
				Do While SRV->(!Eof() .And. SRV->RV_FILIAL == cFilSRVant)
					If SRV->RV_COMPL_ == 'S' .and. Empty( SRV->RV_CODCOM_ )
						//"Atencao" # "Filial " # Informe o codigo de pagamento em todas as verbas com incidencia para o dissidio. Somente apos este procedimento o calculo podera ser efetuado."
						Help("", 1, OemToAnsi(STR0019), Nil, STR0023  + " " + SRV->RV_FILIAL + Chr(13) + Chr(10) + STR0050, 1, 0 )
						lErroVDiss := .T.
					EndIf
					SRV->(dbSkip())
				Enddo
			EndIf

			If cPaisLoc == "BRA" .And. (Empty( aCodFol[337,1]) .or. empty( aCodFol[338,1]) .or. empty( aCodFol[339,1]) .or. empty( aCodFol[340,1]))
				//"Atencao" # "Filial " # Cadastre os identificadores de Calculo 337 a 340"
				Help("", 1, OemToAnsi(STR0019), Nil, STR0023 + SRA->RA_FILIAL + STR0056, 1, 0 )
				lErroVDiss := .T.
			EndIf
			If lErroVDiss
				While (cAliasSRA)->( !Eof()) .and. SRA->RA_FILIAL == cFilAnte
					(cAliasSRA)->( dbSkip())
					dbSelectArea("SRA")
					SRA->(dbGoTo((cAliasSRA)->RECNO))
				EndDo
				dbSelectArea("SRV") // se o cadastro de verbas for compartilhado nao precisa checar as outras filiais
				If Empty(cFilial)
					dbSelectArea( 'SRA' )
					Return .F.
				Else
					Loop
					lErroVDiss := .F.
				EndIf
			EndIf
		EndIf

		// Atualiza exibicao da regua de visualizacao.
		If( !lAuto .and. !lRecalculo, oSelf:IncRegua1( SRA->RA_FILIAL + ' - ' + SRA->RA_MAT + If(lOfusca, "", ' - ' + SRA->RA_NOME) ), Nil )

		// Pesquisa Salario Anterior no SR3, Se nao achar utiliza salario atual.
		aConvoc		:= {}
		nPercDif 	:= 0
		nValAum		:= 0
		nSalario	:= SRA->RA_SALARIO
		cCateg		:= SRA->RA_CATFUNC
		nNovoSal	:= 0
		nBaseMes	:= 0
		nMesAux		:= 0
		nDiaAux 	:= 0
		nSalAux     := 0
		dDataProj	:= cToD("//")
		nPercProp	:= 0

		cDatArq 	:= cMesAnoDe
		cAnoMesBase	:= cDatArq
		lFirst		:= .T.
		lConsidera	:= .T.
		dDataDis 	:= ctod("//")

		cMesDiss := StrZero( Val( fDesc( "RCE", SRA->RA_SINDICA, "RCE_MESDIS", Nil, SRA->RA_FILIAL ) ), 2 )
		If !Empty(cMesDiss) .And. cMesDiss <> "00"
			If cMesDiss == "01"
				cAnoMesProp	:= StrZero(Val(Left( cMesAnoAte, 4 ))-1, 4) + "12"
			ElseIf SubStr(cAnoMesBase, 1, 4) + cMesDiss > AnoMes( SRA->RA_ADMISSA )
				cAnoMesProp	:= Left( cMesAnoDe, 4) + StrZero(Val(cMesDiss)-1, 2)
			Else
				cAnoMesProp	:= Left( cMesAnoAte, 4) + StrZero(Val(cMesDiss)-1, 2)
			EndIf
		Else
			If SubStr( mv_par05, 1, 2 ) == "01"
				cAnoMesProp	:= strzero(val(SubStr( mv_par05, 3, 4 )) -1, 4) + "12"
			Else
				cAnoMesProp	:= SubStr( mv_par05, 3, 4 ) + strZero(Val(SubStr( mv_par05, 1, 2 )) -1, 2)
			EndIf
		EndIf
		
		While .T.
			// Verifica a situacao do func. no periodo de calculo. Nao permitira o cal
			// culo para func.demitidos fora do periodo desejado
			dDataDe 	:= Stod(cDatArq + "01" )
			cSituaAtu 	:= fBuscaSituacao(SRA->RA_FILIAL, SRA->RA_MAT, dDataDe )

			If cSituaAtu == "D" .And. P_DISSPAVP
				SRG->( dbSetOrder(3) )//RG_FILIAL+RG_MAT+DTOS(RG_DATADEM)+DTOS(RG_DATAHOM)+RG_EFETIVA
				If SRG->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + dToS(SRA->RA_DEMISSA) ) )
					dDataProj := SRG->RG_DTPROAV
				EndIf
				If Empty(dDataProj)
					dDataProj := SRA->RA_DEMISSA
				EndIf
			EndIf

			If cSituaAtu == "D" .And. ( ( !P_DISSPAVP .And. SRA->RA_DEMISSA < dDataDe ) .Or. ( P_DISSPAVP .And. !Empty(dDataProj) .and. dDataProj < dDataDe ) )
				Exit
			Endif
								
			If cAnoMesBase < MesAno( SRA->RA_ADMISSA )
				If Right( cDatArq, 2 ) = '12'
					cDatarq := StrZero( Val( Left( cDatarq, 4 ) ) + 1, 4, 0 ) + '01'
				Else
					cDatarq := Left( cDatarq, 4 ) + StrZero( Val( Right( cDatarq, 2 ) ) + 1, 2, 0 )
				Endif
				cAnoMesBase := cDatArq
				If cDatArq > cMesAnoAte
					Exit
				Endif
				Loop
			Endif

			lAchou := .F.

			dbSelectArea( 'SR7' )
			If ! Empty(SR7->(INDEXKEY(2)))
				SR7->(dbSetorder(2))
			EndIf

			dbSelectArea( 'SR3' )
			If ! Empty(SR3->(INDEXKEY(2)))
				SR3->(dbSetorder(2))
			EndIf

			If SR3->(dbSeek( SRA->RA_FILIAL + SRA->RA_MAT ))

				While SR3->(! EOF()) .AND. SR3->R3_FILIAL + SR3->R3_MAT == SRA->RA_FILIAL + SRA->RA_MAT

					If SR3->R3_PD == '000' .and. mesAno(SR3->R3_DATA) <= cDatarq
						If MesAno(SR3->R3_DATA) > "199406"

							/*
							Ponto de entrada GP690SAL

							Neste momento temos o registro do historico salarial posicionado pode-se
							testa-lo e decidir se deve ser considerado ou nao.
							Retorne .T. caso o registro deva ser considerado e .F. para depreza-lo. */
							If lGP690SAL
			      				lConsidera := ExecBlock("GP690SAL",.F.,.F.)
			      				If !lConsidera
			      					SR3->(dbskip())
			      					loop
			      				EndIf
			      			EndIf

							If SR3->R3_DATA < dDataDis .AND. ( (Empty(SR3->R3_DTCDISS) .And. nSalario > SR3->R3_VALOR) .OR. ( ! EMPTY(SR3->R3_DTCDISS) .AND. SR3->R3_DTCDISS < dDataDis) )
								SR3->(dbskip())
								Loop
							Endif

							cCatFunc := fDesc( "SR7", SR3->R3_MAT+DTOS(SR3->R3_DATA), "R7_CATFUNC", , SRA->RA_FILIAL )

							nSalario := IIf(SR3->R3_ANTEAUM > 0, IIf( !Empty(SR3->R3_DTCDISS) .And. AnoMes(SR3->R3_DTCDISS) <= cDatArq, SR3->R3_VALOR, If(( !EMPTY(dDataDis) .And. SR3->R3_DATA < dDataDis), MAX(SR3->R3_VALOR, nSalario), SR3->R3_ANTEAUM) ), SR3->R3_VALOR)
							nSalAux  := SR3->R3_VALOR //Guarda o valor do último salário calculado

							cCateg := cCatFunc
							lAchou := .T.
							lFirst := .F.
							dDataDis := SR3->R3_DTCDISS
						Endif
					EndIf
					SR3->(dbskip())
				EndDo

				If ! lAchou
					cAnoMesBase := StrZero(Val(Substr(cAnoMesBase,1,4) )-1,4)+substr(cAnoMesBase,5,2)
					If cAnoMesBase >= MesAno( SRA->RA_ADMISSA )
						Loop
					EndIf
				EndIf
			Else
				cAnoMesBase := StrZero(Val(Substr(cAnoMesBase,1,4) )-1,4)+substr(cAnoMesBase,5,2)
				If cAnoMesBase >= MesAno( SRA->RA_ADMISSA )
					Loop
				EndIf
			Endif
			
			If lContrInt .and. SRA->RA_TPCONTR == "3" .and. SRA->RA_SALARIO == 0
				aConvoc		:= BuscaConv(dDataDe, StoD(cDatArq + AllTrim(STR(Last_Day(dDataDe)))))
			EndIf

			cSeq:= " "
			nJ 	:= Max(Len(aConvoc),1)
		
			For nI := 1 To nJ
				If nI > 1
					cSeq := Soma1(cSeq)
				EndIf
				If Len(aConvoc) > 0
					nSalario := aConvoc[nI,4]
				EndIf

				If Indice( aFaixas, nSalario, nIndreaj, cDatArq, aHeader, @nPercDif, @nValAum )

					// P.E. para alterar percentual ou valor do aumento aplicado
					If l690Perc
						ExecBlock("GPM690PERC",.F.,.F.)
					EndIf

					// Proporcional a Admissao
					If lProAdm
						nBaseMes  := ((val(substr(cAnoMesProp,1,4)) * 12) + val(substr(cAnoMesProp,5,2))) - ((Year(SRA->RA_ADMISSA) * 12) + Month(SRA->RA_ADMISSA))
						nMesAux   := StrZero(Month(SRA->RA_ADMISSA),2)
						If nMesAux $ "01*03*05*07*08*10*12"
							nDiaAux = 31
						ElseIf nMesAux $ "04*06*09*11"
							nDiaAux = 30
						Else
							If Mod(Year(SRA->RA_ADMISSA),4) = 0
								nDiaAux = 29
							Else
								nDiAaux = 28
							Endif
						Endif

						If nDiaAux - Day(SRA->RA_ADMISSA) + 1 >= 15
							nBaseMes := nBaseMes + 1
						Endif
						nBaseMes  := If(nBaseMes < 0,0, nBaseMes)

						// P.E. para alterar os meses proporcionais  - nBaseMes
						If lAjProp
							ExecBlock("GPREAJPROP",.F.,.F.,nBaseMesAux)
							nBaseMes := 	If( nBaseMesAux > 0, nBaseMesAux, nBaseMes)
						Endif

						If nBaseMes == 0 //Funcionario não tem direiro a nenhum Avo
							nPisoAux := IIf(cCateg $ "M*C*P*A*E*S*I" , nPisoMes, IIf(cCateg $ "D" , nPisoDia, nPisoHora ))
							If nSalario >= nPisoAux
								Exit
							EndIf
						EndIf

						If nBaseMes < nMesProp .and. nPercDif > 0
							nPercProp	:= Round(nPercDif / nMesProp * nBaseMes,6)
							nNovoSal	:= nSalario * (1 + ( nPercDif / nMesProp * nBaseMes / 100 ))

							If nNovoSal == 0
								nNovoSal	:= nSalario * (1+ (nPercDif/100))
							EndIf
						Else
							nNovoSal	:= nSalario * (1+ (nPercDif/100))
						EndIf

						If nBaseMes < nMesProp .and. nValAum > 0
							nValAum  := round( ( nValAum / nMesProp * nBaseMes ),2)
						EndIf
					Else
						nNovoSal	:= nSalario * (1+ (nPercDif/100))
					EndIf

					nNovoSal += nValAum

					If cCateg $ "M*C*P*A*E*S*I"
						nNovoSal := If( nPisoMes > nNovoSal, nPisoMes, nNovoSal)
					ElseIf cCateg $ "D"
						nNovoSal := If( nPisoDia > nNovoSal, nPisoDia, nNovoSal)
					Else
						nNovoSal := If( nPisoHora > nNovoSal, nPisoHora, nNovoSal)
					EndIf

					If nCriterio == 1
						nNovoSal := NoRound(nNovoSal)
					ElseIf nCriterio == 2
						nNovoSal := Round(nNovoSal,2)
					Else
						If nNovoSal - Round(nNovoSal,2) > 0.00
							nNovoSal := NoRound((nNovoSal + .01),2)
						Else
							nNovoSal := Round(nNovoSal,2)
						Endif
					EndIf

					If nArredonda # 0
						nValArre := 0
						Calc_Arre(@nNovoSal,nArredonda, nValArre)
					EndIf

					nNovoSal := If( cPaisLoc == "PAR", Round(nNovoSal, MsDecimais(1)), nNovoSal)

					// Atualizando nova tabela RHH - Alteracao Salarial
					// Despreza caso nao haja indice para a faixa de salario selecionada e categoria for diferente de I/J
					If (nPercDif > 0 .Or. nValAum > 0) .or. (cCateg $ "I*J")
						//Se salário novo for menor que o do mês fechado, iguala para não gerar valores negativos.
						If nNovoSal < nSalAux
							nNovoSal := nSalAux
						EndIf
						//Efetua busca no hash
						If !(HMGet(oPercDif, SRA->RA_FILIAL+SRA->RA_MAT+cDatarq, uRet))
							//--Busca as verbas de base salarial que foi paga à época do cálculo.
							//--Será necessário para saber o c.custo utilizado como pagamento à época do cálculo para não realizar rateios incorretamente.
							aCcTrans := fBuscaAcmPer(aCodFol[31,1] + "/" + aCodFol[32,1] + "/" + aCodFol[318,1],,,,,cDatarq,cDatarq,"01","01",cRoteiro,.T.)
							If Len(aCcTrans) > 0 .And. Len(aCcTrans[1]) > 4
								//--Busca o centro de custo.
								cCcTrans := aCcTrans[1][5]
							Else
								cCcTrans := SRA->RA_CC
							EndIf
							Aadd( aPercDif,{SRA->RA_FILIAL+SRA->RA_MAT+cDatarq,nPercDif, nValAum, cCcTrans})
							HMSet(oPercDif, SRA->RA_FILIAL+SRA->RA_MAT+cDatarq, aPercDif[Len(aPercDif)])
						EndIF
						
						If nI == 1
							// Deleta todos os calculos da Fil+Mat anterior na tabela de dissidio acumulado
							dbSelectArea( "RHH" )
							RHH->(dbSetOrder( 2 ))	// RHH_FILIAL + RHH_MAT + RHH_DATA + RHH_MESANO + RHH_VB + RHH_CC + RHH_ITEM + RHH_CLVL
							If dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cDatarq + cMesAnoCalc )
								While RHH->(! Eof()) .and. (RHH->(RHH_FILIAL+RHH_MAT) == SRA->(RA_FILIAL+RA_MAT)) .and. (RHH->RHH_DATA == cDatarq)
									If lValInfo .and. !lRecalculo .and. RHH->RHH_VALINF > 0 //Se já foi informada a verba, guarda para continuar utilizando-a. Caso queira o cálculo original deverá, primeiramente, efetuar o cancelamento.
										aAdd(aDissInf, {SRA->RA_FILIAL, SRA->RA_MAT, RHH->RHH_ROTEIR, cDatarq, RHH->RHH_SEMANA, RHH->RHH_VB, RHH->RHH_VALINF, RHH->RHH_TIPO3, RHH->RHH_DTPGT})
									EndIf
									RecLock( "RHH", .F., .T. )
									dbDelete()
									RHH->(MsUnlock())
									DbSkip()
								Enddo
							Endif
						EndIf

						RHH->(dbSetOrder( 1 ))

						RecLock( "RHH", .T., .T. )
						RHH->RHH_FILIAL	:= SRA->RA_FILIAL
						RHH->RHH_MAT	:= SRA->RA_MAT
						RHH->RHH_CC		:= cCcTrans
						RHH->RHH_VB		:= "000"
						RHH->RHH_DATA	:= cDatArq
						RHH->RHH_VERBA	:= ""
						RHH->RHH_VL		:= nSalario
						RHH->RHH_CALC	:= nNovoSal
						nDifer			:= RHH->RHH_CALC - RHH->RHH_VL
						RHH->RHH_VALOR	:= Iif( nDifer <> 0, nDifer, 0 )
						RHH->RHH_INDICE	:= If(nPercProp > 0 , nPercProp, nPercDif)
						RHH->RHH_VLRAUM	:= nValAum
						RHH->RHH_TPOAUM	:= cTipoAum
						RHH->RHH_COMPL_	:= "N"

						If cPaisLoc == "BRA"
							RHH->RHH_SINDIC	:= SRA->RA_SINDICA
						EndIf

						RHH->RHH_MESANO		:= cMesAnoCalc

						If !Empty(cIdCmpl)
							RHH->RHH_IDCMPL		:= cIdCmpl
						EndIf

						If cPaisLoc == "BRA"
							RHH->RHH_DTACOR	:= MV_PAR16
						EndIf

						RHH->RHH_PROCES := cProcesso
						RHH->RHH_SEMANA := MV_PAR04
						RHH->RHH_ROTEIR := cRoteiro
						RHH->RHH_SEQ    := cSeq
						
						RHH->(MsUnLock())
					EndIf

					If Ascan( aMeses, ctod("01	/"+substr(cDatArq,5,2)+"/"+substr(cDatArq,1,4) )) == 0
						Aadd( aMeses, ctod("01	/"+substr(cDatArq,5,2)+"/"+substr(cDatArq,1,4) ))
					EndIf
					
				EndIf
			Next

			If Right( cDatArq, 2 ) = '12'
				cDatarq := StrZero( Val( Left( cDatarq, 4 ) ) + 1, 4, 0 ) + '01'
			Else
				cDatarq := Left( cDatarq, 4 ) + StrZero( Val( Right( cDatarq, 2 ) ) + 1, 2, 0 )
			Endif

			cAnoMesBase	:= cDatArq

			If cDatArq > cMesAnoAte
				Exit
			Endif
		EndDo

		(cAliasSRA)->(dbSkip())
	Enddo
	(cAliasSRA)->(dbCloseArea())

	If !lRecalculo
		If !Empty(cArqInf) //Carrega as informações do arquivo CSV
			fLoadCSV(cArqInf,@aDissInf)
		EndIf
		If Len(aDissInf) > 0
			aSort(aDissInf, , , {|x, y| x[1]+x[2]+x[4]+x[5]+x[6]+x[8] < y[1]+y[2]+y[4]+y[5]+x[6]+y[8]} )//Ordena por funcionário e período
		EndIf
	EndIf

	// Recalcula a Folha com base nos Salarios Reajustados
	dDtBsOld := dDataBase

	MV_PAR15 := cSindFOL
	MV_PAR22 := cFuncFOL
	MV_PAR11 := cNomeFOL
	MV_PAR10 := cMatFOL
	MV_PAR09 := cCCFOL
	MV_PAR08 := cFilFOL

	MakeAdvplExpr(cPerg)

	cExpFiltro := " "
	If ! Empty(MV_PAR08) //Filial
		If At("$", MV_PAR08) > 0
			cExpFiltro += StrTran(MV_PAR08, " $ ", " $(") + ")"
			cExpFiltro := StrTran(cExpFiltro, ",", "','")
		Else
			cExpFiltro += MV_PAR08
		EndIf
	EndIf
	If ! Empty(MV_PAR10) //Matricula
		If ! Empty(cExpFiltro)
			cExpFiltro += " .AND. "
		EndIf
		If At("$", MV_PAR10) > 0
			MV_PAR10 := StrTran(MV_PAR10, " $ ", " $(") + ")"
			cExpFiltro += StrTran(MV_PAR10, ",", "','")
		Else
			cExpFiltro += MV_PAR10
		EndIf
	EndIf
	If ! Empty(MV_PAR09) //CC
		If !Empty(cExpFiltro)
			cExpFiltro += " .AND. "
		EndIf
		If At("$",MV_PAR09) > 0
			MV_PAR09 := StrTran(MV_PAR09," $ "," $(") + ")"
			cExpFiltro += StrTran(MV_PAR09,",","','")
		Else
			cExpFiltro += MV_PAR09
		EndIf
	EndIf
	If !Empty(MV_PAR11) //Nome
		If !Empty(cExpFiltro)
			cExpFiltro += " .AND. "
		EndIf
		If At("$",MV_PAR11) > 0
			MV_PAR11 := StrTran(MV_PAR11," $ "," $(") + ")"
			cExpFiltro += StrTran(MV_PAR11,",","','")
		Else
			cExpFiltro += MV_PAR11
		EndIf
	EndIf

	If !Empty(MV_PAR22) //FUNCAO
		If !Empty(cExpFiltro)
			cExpFiltro += " .AND. "
		EndIf
		If At("$",MV_PAR22) > 0
			MV_PAR22 := StrTran(MV_PAR22," $ "," $(") + ")"
			cExpFiltro += StrTran(MV_PAR22,",","','")
		Else
			cExpFiltro += MV_PAR22
		EndIf
	EndIf
	If !Empty(MV_PAR12) //SitFOL
		cSitQuery	:= ""
		cSituacao 	:= MV_PAR12
		For nI:=1 to Len(cSituacao)
			cSitQuery += "'"+Subs(cSituacao,nI,1)+"'"
			If ( nI+1 ) <= Len(cSituacao)
				cSitQuery += ","
			Endif
		Next nI
		If !Empty(cSitQuery)
			If !Empty(cExpFiltro)
				cExpFiltro += " .AND. "
			EndIf
			cExpFiltro += "( RA_SITFOLH $ ("+ cSitQuery +"))"
		EndIF
	EndIf

	If !Empty(MV_PAR13) //Categoria
		cCatQuery	:= ""
		cCat_Atu	:= ""
		cCategoria	:= MV_PAR13
		For nI:=1 to Len(cCategoria)
			cCatX := Subs(cCategoria,nI,1)
			cCatX := If( cCatX $("EG"), "#", cCatX )
			cCatQuery += "'"+cCatX+"'"
			cCat_Atu += cCatX
			If ( nI+1 ) <= Len(cCategoria)
				cCatQuery += ","
			Endif
		Next nI
		cCategoria := cCat_Atu
		If !Empty(cCatQuery)
			If !Empty(cExpFiltro)
				cExpFiltro += " .AND. "
			EndIf
			cExpFiltro += "( RA_CATFUNC $ ("+ cCatQuery +"))"
		EndIf
	EndIf
	If !Empty(MV_PAR15) //Sindicato
		If !Empty(cExpFiltro)
			cExpFiltro += " .AND. "
		EndIf
		If At("$",MV_PAR15) > 0
			MV_PAR15 := StrTran(MV_PAR15," $ "," $(") + ")"
			cExpFiltro += StrTran(MV_PAR15,",","','")
		Else
			cExpFiltro += MV_PAR15
		EndIf
	EndIf

	If lGP690Fil
		cExpFiltro := ExecBlock("GP690FIL", .F., .F., {2, cExpFiltro} )
	EndIf

	lClose := Len( aMeses ) > 0

	For nI := 1 to Len( aMeses )

		For nQtPer := 1 To Len( aFilRCH )

			aPerFechado := {}
			aPerAberto := {}
			aPerTodos := {}
			RstGpexIni() //Zera variaveis a cada troca de fililal
			fRetPerComp( 	strZero(Month(aMeses[nI]),2)		,;		// Obrigatorio - Mes para localizar as informacoes
							StrZero(Year(aMeses[nI]),4)			,;		// Obrigatorio - Ano para localizar as informacoes
							aFilRCH[nQtPer,1]					,;		// Opcional - Filial a Pesquisar
							cProcesso							,;		// Obrigatorio - Filtro por Processo
							,;											// Opcional - Filtro por Roteiro
							@aPerAberto							,;		// Por Referencia - Array com os periodos Abertos
							@aPerFechado						,;		// Por Referencia - Array com os periodos Fechados
							@aPerTodos   						 ;		// Por Referencia - Array com os periodos Abertos e Fechados em Ordem Crescente
						)

			If Len(aPerFechado) == 0
				aAdd( aSavMsgLog, STR0149 ) //"Erro no Cadastro de periodos"
				aAdd( aSavProcLog, STR0155 + aFilRCH[nQtPer,1] )	//"Filial processada: "
				aAdd( aSavProcLog, STR0150 + AnoMes(aMeses[nI]) + STR0151 + cProcesso + "." ) //"Não há período cadastrado para a competência x do processo y."
			EndIf

			aSort(aPerFechado, , , {|x, y| x[1] + x[2] + x[8] < y[1] + y[2] + y[8]} ) //Deve executar o roteiro 132 antes de FOL para calcular a diferença baseado na RHH

			cRotOrig := ""

			For nJ := 1 To Len(aPerFechado)
				//somente FOLHA e 13
				If fGetTipoRot(aPerFechado[nJ][8]) == "1" .Or. fGetTipoRot(aPerFechado[nJ][8]) == "6"

					If cPaisLoc == "BRA"
						P_MULTV := lNewMultV //--Reseta mnemônico para o valor original.
					EndIf

					// Seta o Processo para Calculo
					cSvProcesCalc := SetProcesCalc( aPerFechado[nJ][7] )

					// Seta o Periodo para Calculo
					cSvPeriodCalc := SetPeriodCalc( aPerFechado[nJ][1] )

					// Inicializa variavel para filtro de 13 Salario usada em Gpm020Processa
					If fGetTipoRot(aPerFechado[nJ][8]) == "6"
						dPerFim := aPerFechado[nJ][6]
					EndIf

					// Seta o Numero de Pagamento do Calculo
					cSvNumPgCalc := SetNumPgCalc( aPerFechado[nJ][2] )

					// Seta o Roteiro de Calculo
					cRoteiro 				:= aPerFechado[nJ][8]
					If cRotOrig <> cRoteiro
						cRot					:= ""
						cFilCalc				:= "######"
					EndIf
					cRotOrig        		:= cRoteiro
					cSvRoteiro				:= SetRotExec( aPerFechado[nJ][8] )
					cPeriodo := cCompPer 	:= aPerFechado[nJ][1]

					dbSelectArea("SRY")
					SRY->(dbSetOrder(1))
					If 	SRY->(DbSeek( xFilial("SRY", aFilRCH[nQtPer,3]) + cRoteiro )  )
						If !Empty(SRY->RY_PERGUNT)
							If nQtPer > 1 .and. cFilRot == xFilial("SRY", aFilRCH[nQtPer,3]) + cRoteiro
								Pergunte(SRY->RY_PERGUNT, .F. )
							Else
								Pergunte(SRY->RY_PERGUNT, .T. )
							EndIf
							cFilRot := xFilial("SRY", aFilRCH[nQtPer,3]) + cRoteiro
							cPergEspec := SRY->RY_PERGUNT
						EndIf
					EndIf

					cMsgLog 		:= ""
					aProcessoLog	:= {}
					aIndex			:= {}
					nRecCount		:= 0
					aIRMV			:= {}
					aHdrMestre		:= {}
					cAxTabMestra	:= ""
					lCalIRMV		:= .F.	// Variavel utilizada para determinar se existe calculo de IRMV
					aGpem020Log		:= {}
					aGpem020TitLog	:= {}

					//Atribui a filial que esta sendo processada ao filtro
					cAuxFiltro := cExpFiltro + If( !Empty(cExpFiltro), " AND ", " " ) + "RA_FILIAL = '" + aFilRCH[nQtPer,3] + "'"

					M020FilFun(@lGrid, @nRecCount, cTabMestra, cProcesso, cAuxFiltro, aFilRCH[nQtPer,1], cRoteiro, cFterAux, @cMsgLog, @aProcessoLog, @aIndex, @lCalIRMV, @aIRMV, @aHdrMestre)

					If nRecCount > 0
						// Recalcula a Folha com base nos Salarios Reajustados e
						// grava diferencas no arquivo de dissidio(RHH)
						If lGrid
							MsAguarde( {|lEnd| Gpem020Processa( cAuxFiltro , cTabMestra , cRoteiro, .T. ,cFterAux,nRecCount,cMsgLog,aProcessoLog,aIndex,lCalIRMV,aIRMV,aHdrMestre) }, "", OemToAnsi(STR0148) ) //"Aguarde..."###"Preparando Informações para o GRID..."
						Else
							If ! lAuto
								If !lSegPlan .And. !Empty(SuperGetMV("MV_RHSCHED")) .And. Substr(SuperGetMV("MV_RHSCHED"), 1, 1) <> "2"
									For nX := 1 To Len(aHeader)
										aAdd(aParams, {aHeader[nX,2], aCols[1,nX], Nil})
									Next nX
								EndIf
								If !GPESmartViewUtils():ValidBackGExec("GPEM690", 7, {aParams})
									Proc2BarGauge( { |lEnd| Gpem020Processa( cAuxFiltro, cTabMestra, cRoteiro, .T., cFterAux, nRecCount, cMsgLog, aProcessoLog, aIndex, lCalIRMV, aIRMV, aHdrMestre) }, NIL, NIL, NIL, .T., .T., .F., .F. )
									lClose := .F.
								EndIf
							Else
								Gpem020Processa( cAuxFiltro, cTabMestra, cRoteiro, .T., cFterAux, nRecCount, cMsgLog, aProcessoLog, aIndex, lCalIRMV, aIRMV, aHdrMestre, lAuto)
							EndIf
						EndIf
					Else
						If Select(cAxTabMestra) > 0
							(cAxTabMestra)->(DbCloseArea())
						EndIf
					EndIf

					If nRecCount == 0 .Or. Len(aProcessoLog) > 0
						If Empty(aSavMsgLog)
							aAdd( aSavMsgLog, STR0154 ) //"LOG de Processamento"
						EndIf

						aAdd( aSavProcLog, STR0155 + aFilRCH[nQtPer,1] )	//"Filial processada: "
						aAdd( aSavProcLog, STR0157 + StrZero(Year(aMeses[nI]),4) +"/"+strZero(Month(aMeses[nI]),2) ) //"Competência calculada: "

						For nLog := 1 To Len( aProcessoLog )
							If !Empty( aProcessoLog[nLog] )
								aAdd( aSavProcLog, aProcessoLog[nLog] )
							EndIf
						Next nLog
						aAdd( aSavProcLog, "" )
						aAdd( aSavProcLog, Replicate("-",220) )
					EndIf

				EndIf
			Next nJ
		Next nQtPer
	Next

	If ! Empty( aSavProcLog )
		aAdd( aSavProcLog, "" )
		aAdd( aSavProcLog, Replicate("-",220) )
		aAdd( aSavProcLog, STR0156 + StrZero(Len(aFilRCH),5)  ) //"Total de filiais processadas: "
		fMakeLog( {aSavProcLog} , aSavMsgLog , cPerg , NIL , FunName() , STR0073 , NIL, NIL, NIL, .F.) //"Log de Ocorrencias no Processo de Calculo"
	EndIf

	If ! Empty( aErrProc[2] ) .And. Empty(aProcessoLog)
		fMakeLog( aErrProc[2] , aErrProc[1] , cPerg , NIL , FunName() , STR0073 , NIL, NIL, NIL, .F.) //"Log de Ocorrencias no Processo de Calculo"
	EndIf

	dDataBase := dDtBsOld

	If ValType(oPercDif) == "O"
		HMClean(oPercDif)
		FreeObj(oPercDif)
		oPercDif := Nil
	EndIf

	RestArea(aSR7Area)
	RestArea(aSR3Area)
	RestArea(aRHHArea)
	RestArea(aArea)

	If !lAuto .And. !lSegPlan .And. lClose
		CloseBrowse()   //Fecha browse
	EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPECR010  ºAutor  ³ Advanced RH        º Data ³  17/05/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao M690ChkTab() - Checagem da digitacao da tabela de   º±±
±±º          ³                      reajuste.                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP5                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function M690ChkTab
	Local nI := 0

	nLinGetD := n
	lRetorna := .T.

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se as faixas estao coerentes.									³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If aCols[nLinGetD, nUsado] == .F.
		If aCols[nLinGetD, 1] > aCols[nLinGetD, 2]
			Help( ' ', 1, 'GR200FAIXA' )
			lRetorna := .F.
		Endif
		If nLinGetD > 1
			If aCols[nLinGetD, 1] <= aCols[nLinGetD-1, 2] .And. ( empty(aCols[nLinGetD, 4]) .or. empty(aCols[nLinGetD, 5]) .or. aCols[nLinGetD, 4] <= aCols[nLinGetD-1, 5] )
				Help( ' ', 1, 'GR200FAIXA' )
				lRetorna := .F.
			Endif
		Endif
		For nI = 4 To Len( aCols[nLinGetD] ) - 1
			If nI <> 4 .And. nI <> 5
				If ( aCols[nLinGetD, nI] == 0 ) .and. (aCols[nLinGetD,3] == 0)
					Help( ' ', 1, 'GR200ZEROS' )
					lRetorna := .F.
					Exit
				Endif
			Else
				If empty(aCols[nLinGetD, nI]) .or. aCols[nLinGetD, 4] > aCols[nLinGetD, 5]
					Help( ''  , 1 , 'NVAZIO' , STR0019 , STR0061 , 5 , 0 ) // "Atenção"#"Verifique se as datas informadas são coerentes."
					lRetorna := .F.
				EndIf
				If nLinGetD > 1
					If empty(aCols[nLinGetD, nI]) .or. ( aCols[nLinGetD, 4] <= aCols[nLinGetD-1, 5] .And. aCols[nLinGetD, 1] <= aCols[nLinGetD-1, 2] )
						Help( ''  , 1 , 'NVAZIO' , STR0019 , STR0061 , 5 , 0 ) // "Atenção"#"Verifique se as datas informadas são coerentes."
						lRetorna := .F.
					Endif
				Endif
				If !lRetorna
					Exit
				Endif
			EndIf
		Next
	Endif

	Return( lRetorna )

	/*
	ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
	±±ºPrograma  ³GPECR010  ºAutor  ³ Advanced RH        º Data ³  17/05/01   º±±
	±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
	±±ºDesc.     ³ Funcao Indice() - Pega o indice de reajuste conforme o ti- º±±
	±±º          ³                   po de calculo.                           º±±
	±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
	±±ºUso       ³ Estatica                                                   º±±
	±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
	Static Function Indice( aTabela	,;	// Matriz da tabela
	nSalario,;	// Valor do salario
	nTipReaj,;	// Tipo de reajuste
	cAnomes	,;	// Data
	aCabec 	,;	// Matriz de cabecalho
	nPerDif	,;	// Percentual de aumento
	nValAum ;	// Valor do Aumento
	)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Declara variaveis locais de execucao.									³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Local nLinha	:= Ascan( aTabela, { |X| nSalario >= X[1] .and. nSalario <= X[2] .And. ;
	If(!empty(x[4]),(SRA->RA_ADMISSA >=X[4] .AND. SRA->RA_ADMISSA <=X[5]),.T.) } )
	Local cMesAno	:= { STR0093, STR0094, STR0095, STR0096, STR0097, STR0098, STR0099, STR0100, STR0101, STR0102, STR0103, STR0104, STR0104 }[ Val( Right( cAnoMes, 2 ) )] + '/' + Left( cAnoMes, 4 )
	Local lRet		:= .T.

	If nLinha > 0

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se tipo de indice de reajuste e unico.							³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nValAum := aTabela[nLinha, 3]

		If nTipReaj = 2
			nPerDif := aTabela[nLinha, 6]
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Busca o indice indicado para o mes que esta sendo calculado.			³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( nColuna := Ascan( aCabec, { | X | cMesAno$X[1] } ) ) > 0
				nPerDif := aTabela[nLinha, nColuna]
			Endif
		Endif
	Else
		lRet := .F.
	Endif

Return( lRet )


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ GP690EXC ³ Autor ³ TOTVS				 ³ Data ³ 04/07/2012  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Rotina de Exclusao Individual ou Coletiva do Calculo de	  º±±
±±º          ³ Dissidido dos Funcionarios.								  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Gpem690													  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GP690EXC( cAlias, nReg, nOpcx )
	Local aArea			:= GetArea()
	Local oSX1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Declara variaveis locais de execucao.									³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Private aTELA[0,0], aGETS[0], nUsado := 0

	Private cMesAnoIni	:= ""
	Private cMesAnoFim	:= ""
	Private cFilDe		:= ""
	Private cFilAte		:= ""
	Private cMatDe		:= ""
	Private cMatAte		:= ""
	Private cCcDe		:= ""
	Private cCcAte		:= ""
	Private cSituacao	:= ""
	Private cCategoria	:= ""
	Private cSindicato	:= "99"
	Private cFuncDe		:= ""
	Private cFuncAte	:= ""
	Private cPerg       := ""

	DEFAULT lTemCCT := cPaisLoc == "BRA" .and. RCE->(ColumnPos("RCE_CCT")) > 0

	If lTemCCT
		//Verifica se existe a pergunta GPCR14
		oSX1 := FWSX1Util():New()
		oSX1:AddGroup("GPCR14")
		oSX1:SearchGroup()
		
		If !(Len(oSX1:aGrupo) >= 1 .And. Len(oSX1:aGrupo[1][2]) >= 1)
			lTemCCT := .F.
		EndIf

		FreeObj(oSX1)
	EndIf
	
	nTpPerg := 2

	cPerg	:= If(lTemCCT,'GPCR14','GPCR10')

	Pergunte( cPerg, .F. )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta tela de dialogo.													³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cCadastro	:= OemToAnsi( STR0006 )
	cDescricao 	:= OemToAnsi( STR0125 )
	bProcesso 	:= {|oSelf| ExcluiCalc(oSelf,nOpcx) }

	If( !lAuto, tNewProcess():New( "GPEM690", cCadastro, bProcesso, cDescricao, cPerg,,.T.,20,cDescricao,.T.), ExcluiCalc(,nOpcx))

	restArea(aarea)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ ExcluiCalc ³ Autor ³ TOTVS				 ³ Data ³ 04/07/2012  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Rotina de Exclusao Individual ou Coletiva do Calculo de	  º±±
±±º          ³ Dissidido dos Funcionarios.								  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Gpem690													  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function ExcluiCalc(oSelf,nOpcx)
	Local aArea			:= GetArea()

	Local oFont
	Local oGroup
	Local oDlg1
	Local cDescVbOr		:= ""
	Local cDescVbPg		:= ""
	Local cUsdNor		:= ""
	Local cNotCods		:= ""
	Local aAlter		:= {}

	Local aAdvSize		:= {}
	Local aInfoAdvSize	:= {}
	Local aObjSize		:= {}
	Local aObjCoords	:= {}

	Local aAdv1Size		:= {}
	Local aInfo1AdvSize	:= {}
	Local aObj1Size		:= {}
	Local aObj1Coords	:= {}

	Local aAdv2Size		:= {}
	Local aInfo2AdvSize	:= {}
	Local aObj2Size		:= {}
	Local aObj2Coords	:= {}

	Local aDelCols		:= {}
	Local aCodFol		:= {}
	Local aRFCDel		:= {}
	Local bSet15		:= { || NIL }
	Local bSet24		:= { || NIL }

	aHeader := {}
	aCols 	:= {}

	If !lAuto

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta as Dimensoes dos Objetos         					   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aAdvSize		:= MsAdvSize()
		aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
		aAdvSize		:= MsAdvSize()
		aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
		aAdd( aObjCoords , { 000 , 025 , .T. , .F. } )
		aAdd( aObjCoords , { 000 , 015 , .T. , .F. } )
		aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
		aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

		aAdv1Size		:= aClone(aObjSize[1])
		aInfo1AdvSize	:= { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 1 , 2 }
		aAdd( aObj1Coords , { 045 , 000 , .F. , .T. } )
		aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
		aAdd( aObj1Coords , { 045 , 000 , .F. , .T. } )
		aObj1Size		:= MsObjSize( aInfo1AdvSize , aObj1Coords,,.T. )

		aAdv2Size		:= aClone(aObjSize[2])
		aInfo2AdvSize	:= { aAdv2Size[2] , aAdv2Size[1] , aAdv2Size[4] , aAdv2Size[3] , 5 , 2 }
		aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
		aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
		aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )

		aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
		aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )


		aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
		aObj2Size		:= MsObjSize( aInfo2AdvSize , aObj2Coords,,.T. )
	EndIf

	dbSelectArea( "SX3" )
	SX3->(dbSetOrder( 2 ))
	If dbSeek( "RA_NOME" )
		cUsdNor := SX3->X3_USADO
	Endif

	SX3->(dbSetOrder(1))

	aHeader := { 	{ STR0014			, 'DATREFE', '@R 99/9999'			, 07, 0, '.F.', cUsdNor	, 'C', '  ', ''  }, ;	//"Mes Referencia"
	{ STR0082			, 'SEMANA' , '@!'					, 02, 0, '.F.', 'û'		, 'C', '  ', ' ' }, ;	//"Semana"
	{ STR0012			, 'VERBORI', '@!'					, 03, 0, '.F.', 'û'		, 'C', '  ', ' ' }, ;	//"Verba Origem"
	{ STR0057+ STR0012	, 'DESCVOR', '@!'					, 20, 0, '.F.', 'û'		, 'C', '  ', ' ' }, ;	//"Desc. Verba Origem"
	{ STR0015			, 'VERBPGT', '@!'					, 03, 0, ''   , 'û'		, 'C', '  ', ' ' }, ;	//"Verba Pagto"
	{ STR0057+ STR0015	, 'DESCVPG', '@!'					, 20, 0, ''   , 'û'		, 'C', '  ', ' ' }, ;	//"Desc. Verba Pagto"
	{ STR0016			, 'INDICE' , '@E 999.999999'		, 10, 6, '.F.', 'û'		, 'N', '  ', ' ' }, ;	//"Indice"
	{ STR0013			, 'VALORI' , '@E 999,999,999.99'	, 12, 2, ''   , 'û'		, 'N', '  ', ' ' }, ;	//"Valor Origem"
	{ STR0017			, 'VALCAL' , '@E 999,999,999.99'	, 12, 2, ''   , 'û'		, 'N', '  ', ' ' }, ;	//"Valor Calculado"
	{ STR0018			, 'VALPAG' , '@E 999,999,999.99'	, 12, 2, ''   , 'û'		, 'N', '  ', ' ' }, ;	//"Valor a pagar"
	{ STR0053			, 'COMPL_' , '@!'					, 01, 0, ''   , 'û'		, 'C', '  ', ' ' }, ;	//"Selecionado"
	{ STR0124			, 'INTEGR' , '@!'					, 01, 0, ''   , 'û'		, 'C', '  ', ' ' }, ;	//"Geração Folha?"
	{ STR0140			, 'ROTEIR' , '@!'					, 03, 0, ''   , 'û'		, 'C', '  ', ' ' }}		//"Roteiro Orig."

	aAlter := {"VALPAG"}


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega Perguntas para Periodo a Ser Excluido.		³
	//³ mv_par01 - Periodo De - Ate(MMAAAA) ?				³
	//³ mv_par02 - Periodo De - Ate(MMAAAA) ?				³
	//³ mv_par03 - Filial De - Ate ?						³
	//³ mv_par04 - Matricula De - Ate ?						³
	//³ mv_par05 - Centro de Custo De - Ate ?				³
	//³ mv_par06 - Situacoes ?								³
	//³ mv_par07 - Categorias ?								³
	//³ mv_par08 - Sindicato De - Ate?						³
	//³ mv_par09 - Funcao De  - Ate?						³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	cMesAnoIni	:= Right( MV_PAR01, 4 ) + Left( MV_PAR01, 2 )
	cMesAnoFim	:= Right( MV_PAR02, 4 ) + Left( MV_PAR02, 2 )
	cSituacao	:= MV_PAR06
	cCategoria	:= MV_PAR07

	If Empty( cMesAnoIni ) .or. Empty( cMesAnoFim )
		//"Atencao" # "Preencha o periodo de calculo do dissidio" # "Data em branco"
		Help("", 1, OemToAnsi(STR0019), Nil, STR0062, 1, 0 )
		Return
	EndIf

	// Exclusao de Calculo somente para um funcionario quando Filial De e Ate + Matricula De e Ate forem IGUAIS.
	// Primeiro mostra os registros para depois confirmar a exclusao.
	If(!lAuto, oSelf:SetRegua1(SRA->(RecCount())), Nil)

	TrataPerg(MV_PAR03 ,@cFilDe,@cFilAte)
	TrataPerg(MV_PAR04 ,@cMatDe,@cMatAte)

	cFilDe  := PadR(substr(cFilDe,1,TamSX3("RA_FILIAL")[1]),TamSX3("RA_FILIAL")[1])
	cFilAte := PadR(substr(cFilAte,1,TamSX3("RA_FILIAL")[1]),TamSX3("RA_FILIAL")[1])
	cMatDe  := Alltrim(cMatDe)
	cMatAte	:= Alltrim(cMatAte)

	If !lAuto .and. cFilDe == cFilAte .and. cMatDe == cMatAte .and. (!Empty(cFilDe) .and. !Empty(cMatDe))

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona ponteiro do arquivo SRA.										³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea( 'SRA' )
		SRA->(dbSetOrder( 1 ))
		SRA->(dbSeek( cFilDe + cMatDe, .T. ))

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se o calculo foi executado.									³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea( "RHH" )
		RHH->(dbSetOrder( 2 ))				// RHH_FILIAL+RHH_MAT+RHH_DATA+RHH_MESANO+RHH_VB+RHH_CC+RHH_ITEM+RHH_CLVL
		RHH->( dbGoTop() )

		// Na exclusao procura a partir do primeiro registro que encontrar referente ao ANO do dissidio do funcionario selecionado
		RHH->( dbSeek( SRA->(RA_FILIAL+RA_MAT) + cMesAnoIni, .T. ) )

		If RHH->(Eof()) .or. ( SRA->(RA_FILIAL+RA_MAT) # RHH->(RHH_FILIAL+RHH_MAT) ) .or.  (SRA->(RA_FILIAL+RA_MAT) # cFilDe + cMatDe)
			//"Atencao" # "Nao foi executado o calculo do dissidio retroativo"
			Help("", 1, OemToAnsi(STR0019), Nil, STR0024, 1, 0 )
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega cadastro de verbas para posterior filtro						³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Fp_CodFol( @aCodFol, xFilial( "SRA", cFilDe ) )
				Return
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta cNotCods com os codigos que nao devem ser listados				³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cNotCods := FiltraVb(aCodFol)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta matriz de visualizacao.											³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			While RHH->(!Eof()) .and. (RHH->(RHH_FILIAL+RHH_MAT) == SRA->(RA_FILIAL+RA_MAT)) .and. (RHH->RHH_DATA >= cMesAnoIni .and. RHH->RHH_DATA <= cMesAnoFim)
				cDescVbOr := FDESC("SRV",RHH->RHH_VB,"RV_DESC")
				cDescVbOr := If( empty(cDescVbOr) .and. RHH->RHH_VB == "000", STR0074, cDescVbOr )		//"Salario Base"
				cDescVbOr := If( empty(cDescVbOr),STR0075, cDescVbOr )									//"** Nao cadastrada **"

				cDescVbPg := FDESC( "SRV", RHH->RHH_VERBA, "RV_DESC" )

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Criacao do aCols excluindo as verbas que nao devem aparecer em tela,   	³
				//³ que sao as verbas referentes ao IRRF.                                  	³
				//³ Porem no array de exclusao sao preservados todos os lancamentos.       	³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aAdd( aDelCols, { Right(RHH->RHH_DATA,2)+Left(RHH->RHH_DATA,4),RHH->RHH_SEMANA,RHH->RHH_VB,cDescVbOr,RHH->RHH_VERBA,cDescVbPg,RHH->RHH_INDICE,RHH->RHH_VL,RHH->RHH_CALC, Iif(!Empty(RHH->RHH_VALOR),RHH->RHH_VALOR,0),RHH->RHH_COMPL_, Iif(RHH->RHH_INTEGR#'S','N','S'), .f. } )
				If !Empty(RHH->RHH_IDCMPL) .and. RHH->RHH_INTEGR # "S"
					If ( aScan( aRFCDel, { | X | X[1]+X[2]+X[3]+X[4] == RHH->RHH_FILIAL + RHH->RHH_MAT + RHH->RHH_IDCMPL + RHH->RHH_MESANO } ) ) == 0
						aAdd(aRFCDel,{RHH->RHH_FILIAL, RHH->RHH_MAT, RHH->RHH_IDCMPL, RHH->RHH_MESANO})
					EndIf
				EndIf
				RHH->(dbSkip())
			Enddo

			aEval( aDelCols, { |x| If( x[3] $ cNotCods, , aAdd( aCols, x ) ) } )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se existe verbas calculadas.									³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Len( aCols ) = 0
				//"Atencao"##"Nao existe verbas calculadas para este funcionario"##"Ok"
				Help("", 1, OemToAnsi(STR0019), Nil, STR0020, 1, 0 )
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Exibe as verbas calculadas.												³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nOpca := 0

				SetaPilha()

				RHH->( dbGoTop() )
				DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
				DEFINE MSDIALOG oDlg1 TITLE STR0076  From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainwnd PIXEL	//"" //"Diferencas"

				@ aObj1Size[1,1] , aObj1Size[1,2] GROUP oGroup TO aObj1Size[1,3], aObj1Size[1,4] LABEL OemToAnsi(STR0028) OF oDlg1 PIXEL		// "Matricula:"
				oGroup:oFont:= oFont
				@ aObj1Size[2,1] , aObj1Size[2,2] GROUP oGroup TO aObj1Size[2,3], aObj1Size[2,4] LABEL OemToAnsi(STR0030) OF oDlg1 PIXEL		// "Nome:"
				oGroup:oFont:= oFont
				@ aObj1Size[3,1] , aObj1Size[3,2] GROUP oGroup TO aObj1Size[3,3], aObj1Size[3,4] LABEL OemToAnsi(STR0079) OF oDlg1 PIXEL		// "Admissao:"
				oGroup:oFont:= oFont

				@ aObj1Size[1,1]+10 , aObj1Size[1,2]+5	SAY StrZero(Val(SRA->RA_MAT),TamSx3("RA_MAT    ")[1]) 	SIZE 050,10 OF oDlg1 PIXEL FONT oFont
				@ aObj1Size[2,1]+10 , aObj1Size[2,2]+5	SAY If(lOfusca, Replicate('*',30), OemToAnsi(SRA->RA_NOME))	SIZE 146,10 OF oDlg1 PIXEL FONT oFont
				@ aObj1Size[3,1]+10 , aObj1Size[3,2]+5	SAY Dtoc(SRA->RA_ADMISSA)								SIZE 050,10 OF oDlg1 PIXEL FONT oFont

				oGroup:= tGroup():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],'',oDlg1,,,.T.)

				@ aObj2Size[1,1]+2 , aObj2Size[1,2] SAY STR0078+SPACE(2)+TRANSFORM(RHH->RHH_VLRAUM,"@E 999,999,999.99") SIZE 200,10 of oDlg1 PIXEL FONT oFont //COLOR CLR_HBLUE //"Valor Fixo do Aumento: "
				@ aObj2Size[3,1]+2 , aObj2Size[3,2] SAY Alltrim(STR0080)+":"+SPACE(2)+TRANSFORM(SRA->RA_SALARIO,"@E 999,999,999.99")  SIZE 200,10 of oDlg1 PIXEL FONT oFont //COLOR CLR_HBLUE  //"Salario  "
				@ aObj2Size[4,1]+2 , aObj2Size[4,2] SAY OemToAnsi(STR0131)+": "+RHH->RHH_TPOAUM SIZE 100,10 of oDlg1 PIXEL FONT oFont //"Tipo Aumento"

				If cPaisLoc == "BRA"
					@ aObj2Size[5,1]+2 , aObj2Size[5,2] SAY OemToAnsi(STR0132)+": "+ RHH->RHH_SINDIC  SIZE 100,10 of oDlg1 PIXEL FONT oFont //"Sindicato"
					@ aObj2Size[6,1]+2 , aObj2Size[6,2] SAY OemToAnsi(STR0133)+": "+DTOC(RHH->RHH_DTACOR)SIZE 100,10 of oDlg1 PIXEL FONT oFont //"Data Acordo"
				EndIf

				oGet	:= MSGetDados():New(aObjSize[3,1],aObjSize[3,2],aObjSize[3,3],aObjSize[3,4],nOpcx,"","","",If(nOpcx=4 ,Nil,.F.),,)

				bSet15	:= {|| nOpca:=If(nOpcx=4,2,1),If(oGet:TudoOk(),oDlg1:End(),nOpca:=0)}
				bSet24	:= {||oDlg1:End()}

				ACTIVATE MSDIALOG oDlg1 ON INIT EnchoiceBar( oDlg1 , bSet15 , bSet24 ) CENTERED


				If nOpca == 2 .and. nOpcx == 4		//-- Exclusao
					Begin Transaction
						GpCr01Dele( aDelCols )
						If !Empty(aRFCDel)
							Gp690DelRFC(aRFCDel)
						EndIf
					End Transaction
				Endif

				SetaPilha()
			Endif
		Endif
	Else
		// Chamada do Processamento para Multiplas Exclusoes de Dissidio Retroativo
		MultExcDis(oSelf)
	EndIf

	RestArea( aArea )
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ MultExcDis ³ Autor ³ TOTVS			   ³ Data ³ 29/06/2012  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Rotina de Multipla Exclusao do Calculo de Dissidido Retroat.	º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GP690EXC														º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function MultExcDis( oSelf )
	Local aArea 	:= GetArea()
	Local aRFCDel   := {}
	Local cAliasSRA	:= "QSRA"
	Local cSit		:= ""
	Local nPos		:= 0
	Local cCat		:= ""
	Local cFilRange	:= ""
	Local cCCRange	:= ""
	Local cMatRange	:= ""
	Local cSindRange:= ""
	Local cFuncRange:= ""
	Local cWhere	:= ""
	Local cCodCCT 	:= ""
	Local cSindCCT	:= ""
	Local _nQtd		:= 0

	MakeSqlExpr( cPerg ) //Transforma perguntas do tipo Range em expressao SQL

	cFilRange	:=	MV_PAR03
	cMatRange	:= 	MV_PAR04
	cCCRange	:= 	MV_PAR05
	
	If lTemCCT
		cCodCCT     :=  MV_PAR08
		cSindRange	:= 	MV_PAR09
		cFuncRange	:= 	MV_PAR10
	Else 
		cSindRange	:= 	MV_PAR08
		cFuncRange	:= 	MV_PAR09
	EndIf

	If !Empty(cFilRange)
		cWhere += cFilRange + " AND "
	EndIf

	If !Empty(cCCRange)
		cWhere += cCCRange + " AND "
	EndIf

	If !Empty(cMatRange)
		cWhere += cMatRange + " AND "
	EndIf

	If !Empty(cSindRange)
		cWhere += cSindRange + " AND "
	EndIf

	If !Empty(cFuncRange)
		cWhere += cFuncRange + " AND "
	EndIf

	If !Empty(cCodCCT)
		cSindCCT := fLoadSind(cCodCCT)
	EndIf

	For nPos := 1 To Len(cSituacao)
		If substr(cSituacao,nPos,1) <> "*"
			cSit += "'" + substr(cSituacao,nPos,1) + "',"
		EndIf
	Next nPos

	If Len(cSit)>1
		cSit := substr(cSit,1,Len(cSit)-1)
		cWhere += " RA_SITFOLH IN("+cSit+") AND "
		nPos := 0
	EndIf

	For nPos := 1 To Len(cCategoria)
		If substr(cCategoria,nPos,1) <> "*" .And. !Empty(substr(cCategoria,nPos,1))
			cCat += "'" + substr(cCategoria,nPos,1) + "',"
		EndIf
	Next nPos

	If Len(cCat)>1
		cCat := substr(cCat,1,Len(cCat)-1)
		cWhere += " RA_CATFUNC IN("+cCat+") AND "
		nPos := 0
	EndIf

	//Carrega apenas sindicatos associadas a CCT
	If !Empty(cSindCCT)
		cWhere += " RA_SINDICA IN(" + cSindCCT + ") AND "
	EndIf

	cWhere		:= "%" + cWhere + "%"

	If Select("QSRA") > 0
		QSRA->( dbCloseArea() )
	EndIF

	BeginSql alias cAliasSRA
		SELECT RA_FILIAL,RA_MAT,RA_NOME,RA_CC,RA_ITEM,RA_CLVL,RA_DEPTO, R_E_C_N_O_ RECNO,RA_DEPIR
		FROM %table:SRA% SRA
		WHERE  %exp:cWhere%
		SRA.%notDel%
		ORDER BY RA_FILIAL, RA_MAT
	EndSql

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona ponteiros do arquivo SRA.										³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	DbSelectArea(cAliasSRA)
	Count To _nQtd
	dbSelectArea(cAliasSRA)
	(cAliasSRA)->( DbGoTop() )

	If(!lAuto, ProcRegua( (cAliasSRA)->( RecCount() ) ), Nil)

	Begin Transaction
		While (cAliasSRA)->(! EOF())

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza exibicao da regua de visualizacao.								³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If(!lAuto, oSelf:IncRegua1( (cAliasSRA)->RA_FILIAL + ' - ' + (cAliasSRA)->RA_MAT + If(lOfusca, "", ' - ' + (cAliasSRA)->RA_NOME) ), Nil)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se o calculo foi executado.	³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea( "RHH" )
			RHH->( dbSetOrder( 2 ) )	// RHH_FILIAL+RHH_MAT+RHH_DATA+RHH_MESANO+RHH_VB+RHH_CC+RHH_ITEM+RHH_CLVL
			RHH->( dbGoTop() )

			// Na exclusao procura a partir do primeiro registro que
			// encontrar referente ao ANO do dissidio do funcionario posicionado
			RHH->( dbSeek( (cAliasSRA)->(RA_FILIAL+RA_MAT) + cMesAnoIni, .T. ) )

			While RHH->(! Eof()) .and. (RHH->(RHH_FILIAL+RHH_MAT) == (cAliasSRA)->(RA_FILIAL+RA_MAT)) .and. (RHH->RHH_DATA >= cMesAnoIni .and. RHH->RHH_DATA <= cMesAnoFim)
				If RHH->RHH_INTEGR # "S"
					RHH->( RecLock( "RHH", .F., .T. ) )
					If !Empty(RHH->RHH_IDCMPL)
						If ( aScan( aRFCDel, { | X | X[1]+X[2]+X[3]+X[4] == RHH->RHH_FILIAL + RHH->RHH_MAT + RHH->RHH_IDCMPL + RHH->RHH_MESANO } ) ) == 0
							aAdd(aRFCDel,{RHH->RHH_FILIAL, RHH->RHH_MAT, RHH->RHH_IDCMPL, RHH->RHH_MESANO})
						EndIf
					EndIf
					RHH->( dbDelete( ) )
					RHH->( MsUnlock() )
				EndIf
				RHH->( DbSkip() )
			EndDo
			(cAliasSRA)->( dbSkip() )
		EndDo
		(cAliasSRA)->(dbCloseArea())

		If !Empty(aRFCDel)
			Gp690DelRFC(aRFCDel)
		EndIf

	End Transaction

	RestArea( aArea )
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gp690DelRFCºAutor  ³ Leandro Drumond    º Data ³  16/08/12  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Exclui sintetica do RRA									  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP5                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Gp690DelRFC(aRFCDel)
	Local aArea		:= GetArea()
	Local cQuery	:= ''
	Local nX		:= 0
	Local cRetSqlName 	:= InitSqlName("RFC")

	For nX := 1 to Len(aRFCDel)
		cQuery := "DELETE FROM " + cRetSqlName + " WHERE "
		cQuery += " RFC_FILIAL = '" + aRFCDel[nX,01] + "' AND "
		cQuery += " RFC_MAT = '" + aRFCDel[nX,02] + "' AND "
		cQuery += " RFC_IDCMPL = '" + aRFCDel[nX,03] + "' AND "
		cQuery += " RFC_DATARQ = '" + aRFCDel[nX,04] + "' "

		TcSqlExec( cQuery )

		TcRefresh( cRetSqlName )
	Next nX

	RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GP690Imp  ºAutor  ³ Tatiane Matias     º Data ³  24/07/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao GP690Imp() - Efetua a impressao do relatorio de dis-º±±
±±º          ³                    sidio retroativo.                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP5                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GP690Imp()
	Local oReport

	Pergunte( "GPC02R", .F. )
	oReport := ReportDef()
	oReport:PrintDialog()

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ReportDef³ Autor ³ R.H. - Tatiane Matias ³ Data ³ 24.07.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Definicao do relatorio                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function ReportDef()

	Local oReport
	Local oSection1
	Local oSection2

	Local	cDesc		:=		STR0025 + ". " + STR0026 + " " + STR0027		// "Complemento de Aumento Salarial"	# "Ser  impresso de acordo com os parametros solicitados pelo" # "usuario."
	Local 	aOrd		:= {	STR0028,;	//"Matricula"
	STR0029,; 	//"Centro de custo"
	STR0030}  	//"Nome"

	//-- Inicio definicao do Relatorio
	DEFINE REPORT oReport NAME "RELDSRT" TITLE OemToAnsi(STR0025) PARAMETER "GPC02R" ACTION {|oReport| PrintReport(oReport)} DESCRIPTION cDesc

	//-- Section de Funcionarios
	DEFINE SECTION oSection1 OF oReport TABLES "SRA" ORDERS aOrd TITLE STR0077
	oSection1:SetHeaderBreak(.T.)

	DEFINE CELL NAME "RA_MAT" 			OF oSection1 ALIAS "SRA"
	DEFINE CELL NAME "RA_NOME"			OF oSection1 ALIAS "SRA"

	//-- Section da Tabela Temporaria - Dissidio Retroativo
	DEFINE SECTION oSection2 OF oReport TABLES "RHH" TITLE STR0006

	DEFINE CELL NAME "RHH_DATA" 		OF oSection2 ALIAS "RHH" TITLE STR0083	BLOCK {|| Right( RHH_DATA, 2 ) + '/' + Left( RHH_DATA, 4 )}
	DEFINE CELL NAME "RHH_INDICE"		OF oSection2 ALIAS "RHH" TITLE STR0011	PICTURE "@E 999.999999"   SIZE 15
	DEFINE CELL NAME "RHH_VB"			OF oSection2 ALIAS "RHH" TITLE STR0012 BLOCK {|| RHH->RHH_VB + " - " + If(RHH_VB =="000", Left("SALARIO"+space(20),20), Left(RetValSRV( RHH_VB,SRA->RA_FILIAL, 'RV_DESC' )+space(20),20))} SIZE 27
	DEFINE CELL NAME "RHH_VL"			OF oSection2 ALIAS "RHH" TITLE STR0013 PICTURE "@E 9,999,999.99" SIZE 15
	DEFINE CELL NAME "RHH_CALC"   		OF oSection2 ALIAS "RHH" TITLE STR0084 PICTURE "@E 9,999,999.99" SIZE 15
	DEFINE CELL NAME "RHH_VALOR"		OF oSection2 ALIAS "RHH" TITLE STR0076 PICTURE "@E 999,999.99"  SIZE 12
	DEFINE CELL NAME "RHH_VERBA"		OF oSection2 ALIAS "RHH" TITLE STR0085
	DEFINE CELL NAME "RHH_COMPL_"		OF oSection2 ALIAS "RHH" TITLE STR0086

Return oReport

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³PrintReport³ Autor ³ R.H. - Tatiane Matias   ³ Data ³ 24.07.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Dissidio retroativo - Release 4                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ PrintReport(void)                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function PrintReport(oReport)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Declaracao de Variaveis Locais                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//-- Numerico
	Local nOrdem   	:= oReport:Section(1):GetOrder()
	Local nReg		:= 0
	Local nI        := 0

	//-- Objeto
	Local oSection1	:= oReport:Section(1)
	Local oSection2	:= oReport:Section(2)

	//-- String
	Local cFiltro		:= ""
	Local cFil			:= ""
	Local cCC			:= ""
	Local cDescTot		:= ""
	Local cDtaAnt       := ""

	//-- Array
	Local aTotal		:= {}
	Local aTotPD		:= {}
	Local aFilial 		:= {}
	Local aCC			:= {}
	Local aFunc			:= {}
	Local cPeriodo		:= ""

	//-- Logica
	Local lImpTot       := .F.

	If mv_par01 == 3 .And. nOrdem != 1
		//"Ordem de impressão inválida para o formato Sintetico Detalhado. Escolha Matrícula como ordem de impressão."
		Help("", 1, OemToAnsi(STR0019), Nil, STR0107, 1, 0 )
		Return( Nil )
	Endif

	//Ordena e posiciona no inicio da SRA
	SRA->(dbSetOrder(nOrdem))
	SRA->( DBGoTop() )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ajusta variaveis de trabalho.											³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nTipo		:= mv_par01
	mv_par06	:= substr( mv_par06, 3, 4 ) + substr( mv_par06, 1, 2 )
	cPeriodo	:= mv_par06

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Faz filtro no arquivo...                                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//Transforma parametros do tipo Range em expressao ADVPL para ser utilizada no filtro
	MakeAdvplExpr( "GPC02R" )

	//-- Adiciona no filtro o parametro tipo Range
	//-- Filial
	If !Empty(mv_par02)
		cFiltro += mv_par02
	EndIf

	//-- Centro de Custo
	If !Empty(mv_par03)
		If !Empty(cFiltro)
			cFiltro +=  " .AND. "
		EndIf
		cFiltro += mv_par03
	EndIf

	//-- Matricula
	If !Empty(mv_par04)
		If !Empty(cFiltro)
			cFiltro +=  " .AND. "
		EndIf
		cFiltro += mv_par04
	EndIf

	//-- Nome
	If !Empty(mv_par05)
		If !Empty(cFiltro)
			cFiltro +=  " .AND. "
		EndIf
		cFiltro += mv_par05
	EndIf

	//-- Filtra a tabela de Funcionarios conforme perguntes
	If ! Empty( cFiltro )
		oSection1:SetFilter(cFiltro)
	EndIf

	//-- Filtra Dissidio conforme parametro de Mes/Ano Dissidio
	If ! Empty( cPeriodo )
		oSection2:SetFilter( ' ( RHH_MESANO == "' + cPeriodo + '" )' )
	EndIf

	//-- Seleciona tabela de funcionarios
	dbSelectArea("SRA")

	//-- Define o total da regua da tela de processamento do relatorio
	oReport:SetMeter(SRA->( RecCount() ))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa variaveis de controle de impressao.							³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aTotal	:= {}
	aTotPD	:= {}
	aFilial := {}
	aCC		:= {}
	cFil	:= SRA->RA_FILIAL
	cCC		:= SUBSTR(SRA->RA_CC+SPACE(20),1,20)

	While !Eof()

		If nTipo != 3
			aFunc	:= {}
		EndIf

		//-- Incrementa a régua da tela de processamento do relatório
		oReport:IncMeter()

		//-- Verifica se o usuário cancelou a impressão do relatorio
		If oReport:Cancel()
			Exit
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se houve calculo para o funcionario.						³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea( "RHH" )
		If dbSeek( SRA->RA_FILIAL + SRA->RA_MAT )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Imprime os calculos do funcionario.										³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			//-- Incializa impressão
			If nTipo != 3
				oSection1:Init()
				oSection1:PrintLine()
				oSection1:Finish()
			EndIf

			oSection2:Init()
			cFunc := SRA->RA_MAT+"-"+If(lOfusca, Replicate('*',30), SRA->RA_NOME)

			Do While !Eof() .and. RHH_FILIAL + RHH_MAT = SRA->RA_FILIAL + SRA->RA_MAT
				//-- Analitico
				If nTipo = 1
					oSection2:PrintLine()
				Endif

				If RHH->RHH_COMPL_ == "S"

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza matriz de total dos funcionarios para impressao dos SubTotais. ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If nTipo == 3
						If ( nLinha := Ascan( aFunc, { | X | X[3] + X[1] = RHH_DATA + RHH_VERBA } ) ) > 0
							aFunc[nLinha,2] += RHH_VALOR
						Else
							Aadd( aFunc, { RHH_VERBA, RHH_VALOR, RHH_DATA } )
						Endif
					Else
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza matriz de total do funcionario.								³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If ( nReg := Ascan( aFunc, { | X | X[1] = RHH_VERBA } ) ) > 0
							aFunc[nReg,2] += Iif(!Empty(RHH_VALOR),RHH_VALOR,0)
						Else
							Aadd( aFunc, { RHH_VERBA, Iif(!Empty(RHH_VALOR),RHH_VALOR,0) } )
						Endif
					Endif

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza matriz de total da filial.										³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ( nReg := Ascan( aFilial, { | X | X[1] = RHH_VERBA } ) ) > 0
						aFilial[nReg,2] += Iif(!Empty(RHH_VALOR),RHH_VALOR,0)
					Else
						Aadd( aFilial, { RHH_VERBA, Iif(!Empty(RHH_VALOR),RHH_VALOR,0), RHH_FILIAL } )
					Endif

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza matriz de total do centro de custo.							³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ( nReg := Ascan( aCC, { | X | X[1] = RHH_VERBA } ) ) > 0
						aCC[nReg,2] += Iif(!Empty(RHH_VALOR),RHH_VALOR,0)
					Else
						Aadd( aCC, { RHH_VERBA, Iif(!Empty(RHH_VALOR),RHH_VALOR,0) } )
					Endif

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza matriz de totalizacao geral.									³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ( nReg := Ascan( aTotal, { | X | X[1] = RHH_VERBA } ) ) > 0
						aTotal[nReg,2] += Iif(!Empty(RHH_VALOR),RHH_VALOR,0)
					Else
						Aadd( aTotal, { RHH_VERBA, Iif(!Empty(RHH_VALOR),RHH_VALOR,0) } )
					Endif
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza matriz de total de Verbas.     								³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( nReg := Ascan( aTotPd, { | X | X[1] = RHH_VB } ) ) > 0
					aTotPd[nReg,2] += RHH_VL
					aTotPd[nReg,3] += RHH_CALC
					aTotPd[nReg,4] += Iif(!Empty(RHH_VALOR),RHH_VALOR,0)
				Else
					Aadd( aTotPd, { RHH_VB , RHH_VL, RHH_CALC, Iif(!Empty(RHH_VALOR),RHH_VALOR,0), Left(RetValSRV( RHH_VB,SRA->RA_FILIAL, 'RV_DESC' )+space(20),20),RHH_VERBA,RHH_COMPL_} )
				Endif

				dbSkip()
			Enddo

			oSection2:Finish()

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Imprime total do funcionario.											³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nTipo != 3
				If Len( aFunc ) > 0
					cDescTot := ""
					If Len( aFunc ) = 1
						cDescTot := Pad( STR0034+": "+cFunc, 57 )		// "Total geral do funcionario"
					Else
						cDescTot := Pad( STR0035 + " " + cFunc, 90 )	// "Total de valores por verba do funcionario: "
					EndIf

					oReport:SkipLine()
					oReport:PrintText(cDescTot)
					oSection2:SetHeaderSection(.F.)
					oSection2:Init(.F.)

					For nReg := 1 to Len( aFunc )
						If !Empty(aFunc[nReg,1])
							//-- Altera valores da Section
							oSection2:Cell( "RHH_DATA"		):SetValue("")
							oSection2:Cell( "RHH_INDICE"	):SetValue(0)
							oSection2:Cell( "RHH_VB"		):SetValue(aFunc[nReg,1] + " - " + RetValSRV( aFunc[nReg,1],SRA->RA_FILIAL, 'RV_DESC' ) )
							oSection2:Cell( "RHH_VL"		):SetValue(0)
							oSection2:Cell( "RHH_CALC" 		):SetValue(0)
							oSection2:Cell( "RHH_VALOR"		):SetValue(aFunc[nReg,2])
							oSection2:Cell( "RHH_VERBA"		):SetValue("")
							oSection2:Cell( "RHH_COMPL_"	):SetValue("")

							oSection2:PrintLine()
						EndIf
					Next
					oSection2:Finish()
					oSection2:SetHeaderSection(.T.)
				EndIf
				oReport:ThinLine()
				oReport:SkipLine()
			EndIf
		Endif

		dbSelectArea( 'SRA' )
		dbSkip()

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Imprime os SubTotais mensais.                                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nTipo = 3 .And. !(SRA->( &( cFiltro) ) ) .and. ! Empty( aFunc )
			aFunc := aSort( aFunc ,,, { |x,y| x[3]+x[1] < y[3]+y[1] } )
			For nI := 1 to Len( aFunc )
				If !Empty(aFunc[nI,1])

					If !(cDtaAnt == aFunc[nI,3]) .And. ( nI > 1 )
						oReport:SkipLine()
					EndIf

					//-- Altera valores da Section
					oSection2:Cell( "RHH_DATA"		):SetValue("")
					oSection2:Cell( "RHH_INDICE"	):SetValue(0)
					oSection2:Cell( "RHH_VB"		):SetValue(aFunc[nI,1] + " - " + RetValSRV( aFunc[nI,1],SRA->RA_FILIAL, 'RV_DESC' ))
					oSection2:Cell( "RHH_VL"		):SetValue(0)
					oSection2:Cell( "RHH_CALC"		):SetValue(0)
					oSection2:Cell( "RHH_VALOR"		):SetValue(aFunc[nI,2])
					oSection2:Cell( "RHH_VERBA"		):SetValue("")
					oSection2:Cell( "RHH_COMPL_"	):SetValue("")
					oSection2:Cell( "RHH_DATA"		):SetBlock({|| Right( aFunc[nI,3], 2 ) + '/' + Left( aFunc[nI,3], 4 )})

					oSection2:PrintLine()

					cDtaAnt  := aFunc[nI,3]
					lImpTot  := .T.  //Determina se os totais poderao ser impressos
				EndIf
			Next
		Endif

		If cCC != SRA->RA_CC .and. nOrdem = 2 .and. Len( aCC ) > 0 .And. lImpTot
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Imprime total do Centro de custo.										³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			oReport:SkipLine()
			oReport:PrintText(Pad( STR0046 + cCC, 57 ))
			oSection2:Init(.F.)

			For nReg := 1 to Len( aCC )
				If !Empty(aCC[nReg,1])

					//-- Altera valores da Section
					oSection2:Cell( "RHH_DATA"		):SetValue("")
					oSection2:Cell( "RHH_INDICE"	):SetValue(0)
					oSection2:Cell( "RHH_VB"		):SetValue(aCC[nReg,1] + " - " + RetValSRV( aCC[nReg,1],SRA->RA_FILIAL, 'RV_DESC' ))
					oSection2:Cell( "RHH_VL"		):SetValue(0)
					oSection2:Cell( "RHH_CALC"		):SetValue(0)
					oSection2:Cell( "RHH_VALOR"		):SetValue(aCC[nReg,2])
					oSection2:Cell( "RHH_VERBA"		):SetValue("")
					oSection2:Cell( "RHH_COMPL_"	):SetValue("")

					oSection2:PrintLine()
				EndIf
			Next

			oSection2:Finish()

			oReport:ThinLine()
			oReport:EndPage()

			cCC	:= SUBSTR(SRA->RA_CC+SPACE(20),1,20)
			aCC	:= {}
		Endif

		If cFil != SRA->RA_FILIAL .and. Len( aFilial ) > 0 .Or. lImpTot
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Imprime total da filial.												³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cDescTot := ""
			If Len( aFilial ) = 1
				cDescTot := Pad( STR0037 + aFilial[1,3], 57 ) //"Sub-Total da filial: "
			Else
				cDescTot := Pad( STR0038 + aFilial[1,3], 57 ) //"Sub-Total de valores por verba da filial: "
			EndIf

			oReport:SkipLine()
			oReport:PrintText(cDescTot)
			oSection2:Init(.F.)

			For nReg := 1 to Len( aFilial )
				If !Empty(aFilial[nReg,1])

					//-- Altera valores da Section
					oSection2:Cell( "RHH_DATA"		):SetValue("")
					oSection2:Cell( "RHH_INDICE"	):SetValue(0)
					oSection2:Cell( "RHH_VB"		):SetValue(aFilial[nReg,1] + " - " + RetValSRV( aFilial[nReg,1],SRA->RA_FILIAL, 'RV_DESC' ))
					oSection2:Cell( "RHH_VL"		):SetValue(0)
					oSection2:Cell( "RHH_CALC"		):SetValue(0)
					oSection2:Cell( "RHH_VALOR"		):SetValue(aFilial[nReg,2])
					oSection2:Cell( "RHH_VERBA"		):SetValue("")
					oSection2:Cell( "RHH_COMPL_"	):SetValue("")

					oSection2:PrintLine()
				EndIf
			Next

			oSection2:Finish()
			oReport:ThinLine()
			oReport:EndPage()

			cFil 		:= SRA->RA_FILIAL
			aFilial 	:= {}
		Endif

		oSection2:Cell( "RHH_DATA"		):SetValue()
		oSection2:Cell( "RHH_INDICE"	):SetValue()
		oSection2:Cell( "RHH_VB"		):SetValue()
		oSection2:Cell( "RHH_VL"		):SetValue()
		oSection2:Cell( "RHH_CALC"		):SetValue()
		oSection2:Cell( "RHH_VALOR"		):SetValue()
		oSection2:Cell( "RHH_VERBA"		):SetValue()
		oSection2:Cell( "RHH_COMPL_"	):SetValue()

		oSection2:Cell( "RHH_DATA"	):SetBlock({|| Right( RHH_DATA, 2 ) + '/' + Left( RHH_DATA, 4 )})
		oSection2:Cell( "RHH_VB"	):SetBlock({|| RHH->RHH_VB + " - " + If(RHH_VB =="000", Left("SALARIO"+space(20),20), Left(RetValSRV( RHH_VB,SRA->RA_FILIAL, 'RV_DESC' )+space(20),20))})
	Enddo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Imprime total geral.													³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Len( aTotPD ) > 0
		aSort(aTotPD,,,{|x,y|x[1]<y[1]})

		oReport:EndPage()
		oReport:SkipLine(2)
		oReport:PrintText(Pad( STR0081,57))
		oReport:SkipLine()
		oSection2:Init(.F.)

		For nReg := 1 to Len(aTotPD)
			If aTotPD[nReg,1] # "000"

				//-- Altera valores da Section
				oSection2:Cell( "RHH_DATA"		):SetValue("")
				oSection2:Cell( "RHH_INDICE"	):SetValue(0)
				oSection2:Cell( "RHH_VB"		):SetValue(aTotPd[nReg,1] + " - " + aTotPd[nReg,5])
				oSection2:Cell( "RHH_VL"		):SetValue(aTotPD[nReg,2])
				oSection2:Cell( "RHH_CALC"		):SetValue(aTotPD[nReg,3])
				oSection2:Cell( "RHH_VALOR"		):SetValue(Iif(!Empty(aTotPD[nReg,4]),aTotPD[nReg,4],0))
				oSection2:Cell( "RHH_VERBA"		):SetValue(aTotPD[nReg,6])
				oSection2:Cell( "RHH_COMPL_"	):SetValue(aTotPD[nReg,7])

				oSection2:PrintLine()
			EndIf
		Next nReg

		oSection2:Finish()
		oReport:ThinLine()
		oReport:SkipLine()
	EndIf

	If Len( aTotal ) > 0

		oReport:EndPage()

		If Len( aTotal ) = 1
			cDescTot := Pad( STR0040, 57 ) //"Total geral a pagar"
		Else
			cDescTot := Pad( STR0041, 57 ) //"Total geral de valores por verba"
		Endif

		oReport:SkipLine(2)
		oReport:PrintText(cDescTot)
		oReport:SkipLine()
		oSection2:Init(.F.)

		For nReg := 1 to Len( aTotal )
			If !Empty(aTotal[nReg,1])

				//-- Altera valores da Section
				oSection2:Cell( "RHH_DATA"		):SetValue("")
				oSection2:Cell( "RHH_INDICE"	):SetValue(0)
				oSection2:Cell( "RHH_VB"		):SetValue(aTotal[nReg,1] + " - " + RetValSRV( aTotal[nReg,1],SRA->RA_FILIAL, 'RV_DESC' ))
				oSection2:Cell( "RHH_VL"		):SetValue(0)
				oSection2:Cell( "RHH_CALC"		):SetValue(0)
				oSection2:Cell( "RHH_VALOR"		):SetValue(aTotal[nReg,2])
				oSection2:Cell( "RHH_VERBA"		):SetValue("")
				oSection2:Cell( "RHH_COMPL_"	):SetValue("")

				oSection2:PrintLine()
			EndIf
		Next

		oSection2:Finish()
		oReport:ThinLine()
	Endif

Return NIL

/*/{Protheus.doc} GP690Grv
Grava valores a serem pagos futuramente.
@author Advanced RH
@since 17/05/2001
@type function
/*/
Function GP690Grv()

	// Declara variaveis locais de trabalho.
	Local cPerg    		:= ""
	Local cGrpUsr		:= ""
	Local aArea			:= GetArea()
	Local aSRAArea 		:= SRA->( GetArea() )
	Local aFilterExp	:= {} //Expressao de filtro
	Local aInfoCustom 	:= {}
	Local aGrpUsr		:= {}
	Local nLoop  		:= 0
	Local oProcess
	Local oSX1

	Private aRetFiltro
	Private cSraFilter
	Private lSindicato:= .F.

	DEFAULT lTemCCT := cPaisLoc == "BRA" .and. RCE->(ColumnPos("RCE_CCT")) > 0

	nTpPerg := 3

	If lTemCCT
		//Verifica se existe a pergunta GPCR14
		oSX1 := FWSX1Util():New()
		oSX1:AddGroup("GPCR15")
		oSX1:SearchGroup()
		
		lTemCCT := (Len(oSX1:aGrupo) >= 1 .And. Len(oSX1:aGrupo[1][2]) >= 1)

		FreeObj(oSX1)
	EndIf

	cPerg := If(lTemCCT, 'GPCR15', 'GPCR09')

	DbSelectArea("RHH")

	If cPaisLoc == "BRA"
		If FieldPos("RHH_SINDIC") # 0
			lSindicato := .T.
		Endif
	EndIf

	Pergunte( cPerg, .F. )
	
	cProcesso 	:= MV_PAR01

	// Monta tela de dialogo.
	/* Retorne os Filtros que contenham os Alias Abaixo */
	aAdd( aFilterExp , { "FILTRO_ALS" , "SRA"     	, .T. } )

	/* Que Estejam Definidos para a Função */
	aAdd( aFilterExp , { "FILTRO_PRG" , FunName() 	, NIL , NIL    } )

	aGrpUsr := UsrRetGrp( cUserName)
	For nLoop := 1 To Len(aGrpUsr)
		cGrpUsr := aGrpUsr[nLoop]
		aAdd( aFilterExp , {  "FILTRO_GRP", cGrpUsr 	, NIL , NIL    } )
	Next nLoop

	cCadastro	:= OemToAnsi( STR0048 )
	cDescricao 	:= OemToAnsi( STR0048 )
	bProcesso 	:= {|oSelf| GP690Proc(oSelf) }
	Aadd(aInfoCustom,{"Filtrar", {|oCenterPanel| aRetFiltro := FilterBuildExpr( aFilterExp )}, "TK_FIND" })

	cFilAnt := cFilAnterior

	If ! lAuto
		oProcess := tNewProcess():New( "GPEM690", cCadastro, bProcesso, cDescricao, cPerg, aInfoCustom, .T., 20, cDescricao, .T.)
	Else
		GP690Proc()
	EndIf

	SRA->( RestArea(aSRAArea) )
	RestArea( aArea )

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPECR010  ºAutor  ³Advanced - RH       º Data ³  17/05/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao GP690Proc() - Faz o processamento da geracao das parº±±
±±º          ³                     celas.                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP5                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GP690Proc(oSelf)

	Local aArea			:= GetArea()
	Local aAreaSR3		:= SR3->( GetArea() )
	Local aAreaSRA		:= SRA->( GetArea() )
	Local nParcela		:= 0
	Local nMinimo		:= 0
	Local nI			:= 0
	Local aFunc			:= {}
	Local cFilDe		:= ""
	Local cFilAte		:= ""
	Local cCcDe			:= ""
	Local cCcAte		:= ""
	Local cMatDe		:= ""
	Local cMatAte		:= ""
	Local cFun			:= ""
	Local cDescCar		:= ""
	Local cChave		:= ""
	Local aTransfFun	:= {}
	Local aDados		:= {}
	Local nX			:= 0
	Local cChvRHH		:= ""
	Local lAtualiza		:= .T.
	Local cBusca		:= ""
	Local nPosDt		:= 0
	Local nPosTp		:= 0
	Local nR7SeqTam
	Local lAchouAlt		:= .T.
	Local aR7AllRecs	:= {}
	Local lGera			:= .T.
	Local lAtuSRK		:= .F.
	Local dDtCDiss		:= Ctod("//")
	Local dDatDiss		:= Ctod("//")			// Data do Dissidio Retroativo
	Local cDtCompDis	:= Space( 06 )			// Data da Competencia do Dissidio
	Local lGpAltSal		:= ExistBlock( "GPALTSAL" )
	Local cNotCods		:= ""
	Local cAntFil		:= ""
	Local aCodFol		:= {}
	Local dDtReaj		:= Ctod("//")
	Local dR7Dta		:= Ctod("//")
	Local dTransf		:= CtoD("//")
	Local nFirstRec		:= 0
	Local nValAnt		:= 0
	Local nValHist		:= 0
	Local lHaAlt		:= .F.
	Local lHaReaj		:= .F.
	Local lHaExatoReaj	:= .F.
	Local lHaAltAnt		:= .T.
	Local lR7Cargo 		:= SR7->(ColumnPos("R7_CARGO")) > 0
	Local lR7DescCar 	:= SR7->(ColumnPos("R7_DESCCAR")) > 0
	Local lR7Seq 		:= SR7->(ColumnPos("R7_SEQ")) > 0
	Local lR3AnteAum 	:= SR3->(ColumnPos("R3_ANTEAUM")) > 0
	Local lR3Seq 		:= SR3->(ColumnPos("R3_SEQ")) > 0
	Local lR3DtcDiss 	:= SR3->(ColumnPos("R3_DTCDISS")) > 0
	Local nEnvFunc		:= 3

	Local aRFCGrv		:= {}
	Local aPdRGB 		:= {}
	Local cFilRFC		:= ""
	Local cMatRFC		:= ""
	Local cCCRFC		:= ""
	Local lClasse		:= GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "13"
	Local cQuery		:= ""
	Local nTReg			:= 0
	Local cAliasSRA		:= "QSRA"
	Local cSit	   		:= ""
	Local nPos	   		:= 0
	Local cFilRange		:=	""
	Local cCCRange		:= 	""
	Local cMatRange		:= 	""
	Local cSindRange	:= ""
	Local cNomeRange	:= 	""
	Local cWhere		:= ""
	Local _nQtd			:= 0
	Local cFuncAnt		:= ""
	Local cCargAnt		:= ""
	Local cCatAnt		:= ""
	Local cPgtAnt		:= ""
	Local cSitFolAtu	:= ""
	Local cResRAISAt	:= ""
	Local cCodConvoc	:= ""
	
	Local cFilMatAnt	:= ""
	Local cSeq			:= " "
	Local cCodCCT 		:= ""
	Local cSindCCT 		:= ""
	Local lEmpDif		:= .F.
	Local lTemRGB		:= .F.
	Local lTrfEmp		:= .F.
	Local nRecSRA		:= 0
	Local nSalario		:= 0
	Local aConvoc		:= {}
	Local cIdNoRRA		:= ''

	Private cExclui		:= ""
	Private aLog		:= {}
	Private aTitle		:= {}
	Private aTotRegs	:= array(04)
	Private nIndSRK		:= 0
	Private aPdv		:= {}
	Private aPd			:= {}
	Private cProcesso	:= ""
	Private cRoteiro	:= ""
	Private lContrInt	:= If(SRC->(ColumnPos( 'RC_CONVOC' )) > 0,.T.,.F.)
	
	RHH->( dbGoTop() )
	If RHH->( FieldPos( "RHH_MESANO" ) ) == 0 .or. Empty( RHH->RHH_MESANO )
		//"Atencao" # "Estrutura de dados incorreta. Calcule novamente o dissidio."
		Help("", 1, OemToAnsi(STR0019), Nil, STR0110, 1, 0 )
		Return
	EndIf

	aFill( aTotRegs, 0 )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ajusta variaveis de trabalho.											³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cProcesso	:= MV_PAR01
	cRoteiro	:= MV_PAR02
	nParcela 	:= Iif( MV_PAR05 = 0, 1, MV_PAR05 )
	nMinimo  	:= MV_PAR06
	dDatVen	 	:= Iif( Empty( MV_PAR07 ), dDataBase, MV_PAR07 )
	cFilDe  	:= ""
	cFilAte 	:= ""
	cCcDe		:= ""
	cCcAte		:= ""
	cMatDe		:= ""
	cMatAte		:= ""
	cDocumento	:= MV_PAR12
	nAtuSalario := MV_PAR13
	nAtuLanc    := MV_PAR14
	cSemana		:= MV_PAR04
	cSituacao	:= MV_PAR15
	lTransfAtu	:= .T. // Opcao '2-Nao' descontinuada
	cAnoMes		:=  MV_PAR03
	lRateio		:= If(MV_PAR17==1, .T.,.F.)
	lIncluiNovo	:= If(MV_PAR18==1, .T.,.F.)
	
	If lTemCCT
		cCodCCT := MV_PAR19
		cIdCmpl	:= MV_PAR21 
	Else 
		cIdCmpl	:= MV_PAR19
	EndIf

	If Empty( cAnoMes )
		//"Atencao" # 'Preencha o parâmetro "Mes/Ano do calculo"'
		Help("", 1, OemToAnsi(STR0019), Nil, STR0090, 1, 0 )
		Return
	Endif

	If Empty( MV_PAR03 )
		//"Atencao" # "Preencha o periodo de calculo do dissidio" # "Data em branco"
		Help("", 1, OemToAnsi(STR0019), Nil, STR0062, 1, 0 )
		Return
	EndIf

	If Empty(cDocumento) .and. nAtuLanc == 1
		//"Atencao" # "Para geração de valores futuros é necessário o preenchimento do Número do Documento"
		Help("", 1, OemToAnsi(STR0019), Nil, STR0158, 1, 0 )
		Return
	EndIf

	If !Empty(cCodCCT)
		cSindCCT := fLoadSind(cCodCCT)
	EndIf

	MakeSqlExpr( "GPCR09" ) //Transforma perguntas do tipo Range em expressao SQL

	cQuery := "SELECT RHH_FILIAL, RHH_DATA, RHH_MESANO, RHH_MAT, RHH_VB, RHH_CC, RHH_ITEM, RHH_CLVL"
	cQuery += "  FROM " + RetSqlName( "RHH" ) + " RHH "
	cQuery += "	WHERE RHH.D_E_L_E_T_ = ' ' "

	If !Empty(MV_PAR08)
		cQuery += " AND " +Replace(MV_PAR08,"RA_","RHH_")
	EndIf

	If !Empty(MV_PAR10)
		cQuery += " AND " + Replace(MV_PAR10,"RA_","RHH_")
	EndIf

	If !Empty(MV_PAR09)
		cQuery += " AND " + Replace(MV_PAR09,"RA_","RHH_")
	EndIf

	If !Empty(cSindCCT)
		cQuery += " AND RHH_SINDIC IN (" + cSindCCT + ")"
	EndIf

	cQuery += "	  AND RHH.RHH_MESANO = '"	+ cAnoMes	+ "' "
	cQuery += "	  AND RHH.RHH_SEMANA = '"	+ cSemana	+ "' "
	cQuery += "	  AND RHH.RHH_PROCES = '"	+ cProcesso	+ "' "
	cQuery += "	  AND RHH.RHH_ROTEIR = '"	+ cRoteiro	+ "' "
	cQuery += "	ORDER BY RHH_FILIAL,RHH_MESANO,RHH_CC,RHH_MAT,RHH_DATA,RHH_VB,RHH_ITEM,RHH_CLVL "

	cQuery := ChangeQuery( cQuery )

	dbUseArea( .T., "TOPCONN", TcGenQry( ,,cQuery ), "RHH2" )

	If Select( "RHH2" ) > 0
		Count To nTReg		// Conta os registros retornados
		( "RHH2" )->( dbCloseArea() )
	Endif

	dbSelectArea( "RHH" )
	RHH->(dbSetOrder( 3 ))			// RHH_FILIAL+RHH_MESANO+RHH_CC+RHH_MAT+RHH_DATA+RHH_VB+RHH_ITEM+RHH_CLVL
	If nTReg <= 0
		// "Atencao" # "Nao foi executado o calculo do dissidio retroativo"
		Help("", 1, OemToAnsi(STR0019), Nil, STR0024, 1, 0 )
		return
	Endif

	If !Empty(cIdCmpl)
		DbSelectArea('RF1')
		If !(DbSeek(xFilial('RF1')+cIdCmpl))
			//"Atencao" # 'Complemento não encontrado'
			Help("", 1, OemToAnsi(STR0019), Nil, STR0123, 1, 0 )
			Return
		Else
			nParcela := Max(RF1->RF1_TPARC,1)
			If nParcela > 1 .and. nAtuLanc == 2
				If MsgYesNo( OemToAnsi( STR0127 ), OemToAnsi( STR0019 ) ) //"Complemento foi calculado parcelado e a geração de parcelas esta definida para 'lançamento mensal'. Alterar geração? "##"Atencao"
					nAtuLanc := 1
				Else
					Return
				EndIf
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existe o campo R3_DTCDISS       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nAtuSalario == 1  //Atualiza historico Salarial
		dbSelectArea("SR3")
		If FieldPos("R3_DTCDISS") == 0
			//"Atencao" # "Antes de prosseguir, é necessário executar os procedimentos do boletim técnico -Gravação da data de cálculo do dissídio retroativo no histórico salarial- para criação do campo R3_DTCDISS."
			Help("", 1, OemToAnsi(STR0019), Nil, STR0108, 1, 0 )
			Return
		EndIf
	EndIf

	//Incluir os funcionarios demitidos por transferidos, qdo selecionado a situacao "Normal"
	//Nao incluir os funcionarios transferidos, qdo selecionado apenas a opcao "Demitido"
	If  ( !("D" $ cSituacao) .and. (" "$cSituacao) )
		cSituacao += "D"
		nEnvFunc := 1
	elseIf ("D" $ cSituacao) .and. (" "$cSituacao)
		nEnvFunc	:= 3
	elseIf ("D" $ cSituacao) .and. !(" "$cSituacao)
		nEnvFunc := 2
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona ponteiros do arquivo SRA.										³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	cFilRange	:=	MV_PAR08
	cCCRange	:= 	MV_PAR09
	cMatRange	:= 	MV_PAR10
	cSindRange	:= 	MV_PAR20
	cNomeRange	:= 	MV_PAR11

	If !Empty(cFilRange)
		cWhere += cFilRange + " AND "
	EndIf

	If !Empty(cCCRange)
		cWhere += cCCRange + " AND "
	EndIf

	If !Empty(cMatRange)
		cWhere += cMatRange + " AND "
	EndIf

	If !Empty(cSindCCT)
		cWhere += "RA_SINDICA IN (" + cSindCCT + ") AND "
	EndIf

	If lSindicato
		If !Empty(cSindRange)
			cWhere += cSindRange + " AND "
		EndIf
	EndIf

	If !Empty(cNomeRange)
		cWhere += cNomeRange + " AND "
	EndIf

	For nPos := 1 To Len(cSituacao)
		If substr(cSituacao,nPos,1) <> "*"
			cSit += "'" + substr(cSituacao,nPos,1) + "',"
		EndIf
	Next nPos
	If Len(cSit)>1
		cSit := substr(cSit,1,Len(cSit)-1)
		cWhere += " RA_SITFOLH IN("+cSit+") AND "
		nPos := 0
	EndIf
	cWhere		:= "%" + cWhere + "%"

	If Select("QSRA") > 0
		QSRA->( dbCloseArea() )
	EndIF

	BeginSql alias cAliasSRA
	SELECT RA_FILIAL,RA_MAT,RA_NOME,RA_CC, R_E_C_N_O_ RECNO
	FROM %table:SRA% SRA
	WHERE  %exp:cWhere%
	SRA.%notDel%
	ORDER BY RA_FILIAL, RA_MAT
	EndSql

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona ponteiros do arquivo SRA.										³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	DbSelectArea(cAliasSRA)
	Count To _nQtd
	dbSelectArea(cAliasSRA)
	(cAliasSRA)->( DbGoTop() )
	SRA->( dbSetOrder(1) )

	If ! lAuto
		oSelf:SetRegua1((cAliasSRA)->(RecCount()))
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega os Filtros                                 	 	     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cSraFilter	:= GpFltAlsGet( aRetFiltro , "SRA" )
	Do While (cAliasSRA)->( !Eof() )

		dbSelectArea("SRA")
		SRA->(dbGoto((cAliasSRA)->RECNO))

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica acesso do usuário a filial do funcionário.						³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !(SRA->RA_FILIAL $ fValidFil())
			(cAliasSRA)->( dbSkip() )
			Loop
		EndIf

		If ! lAuto
			// Movimenta cursor para movimentacao da barra.
			oSelf:IncRegua1( SRA->RA_FILIAL + ' - ' + SRA->RA_MAT + If(lOfusca, "", ' - ' + SRA->RA_NOME) )
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica exclusao de registro conforme parametros.						³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty( cSraFilter )
			If !( &( cSraFilter ) )
				(cAliasSRA)->( dbSkip() )
				Loop
			EndIf
		EndIf

		cSitFolAtu	:= SRA->RA_SITFOLH
		cResRAISAt	:= SRA->RA_RESCRAI
		nRecSRA		:= SRA->( Recno() )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se houve calculo para o funcionario.							³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea( "RHH" )
		RHH->(dbSetOrder(RetOrder('RHH','RHH_FILIAL+RHH_PROCES+RHH_MAT+RHH_MESANO+RHH_SEMANA+RHH_ROTEIR+RHH_IDCMPL')))
		cChvRHH := SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cAnoMes + cSemana

		If dbSeek( cChvRHH )

			If lTransfAtu
				aDados 		:= {}
				aTransfFun 	:= {}
				lEmpDif		:= .F.
				lTrfEmp		:= .F.
				cFilMatAnt 	:= ""
				cSeq		:= ""
				dTransf     := CtoD("")
				
				fTransfAll( @aTransfFun,,,.T.)
				For nX := 1 to len( aTransfFun )
					If AnoMes(aTransfFun[nx,7]) >= RHH->RHH_DATA
						If aTransfFun[nX,1] == aTransfFun[nX,4] //nao houve transferencia entre empresas
							If nX > 1
								If aTransfFun[nX,7] > dTransf
									aDados := {	aTransfFun[nX,10],; 	//Filial
									aTransfFun[nX,11],; 	//Matricula
									aTransfFun[nX,06],;		//Centro de Custo
									aTransfFun[nX,04]}		//Empresa
								EndIf
							Else
								aDados := {	aTransfFun[nX,10],; 	//Filial
								aTransfFun[nX,11],; 	//Matricula
								aTransfFun[nX,06],;		//Centro de Custo
								aTransfFun[nX,04]}		//Empresa
							EndIf
						Else 									//houve transferencia entre empresas
							If nX > 1
								If aTransfFun[nX,7] > dTransf
									aDados := {	aTransfFun[nX,10],; 	//Filial
									aTransfFun[nX,11],; 	//Matricula
									aTransfFun[nX,06],;		//Centro de Custo
									aTransfFun[nX,04]}		//Empresa
									If cEmpAnt != aTransfFun[nX,4]
										cFilMatAnt	:= aTransfFun[nX,1]+aTransfFun[nX,2]
										lEmpDif		:= .T.
									EndIf
								EndIf
							Else
								aDados := {	aTransfFun[nX,10],; 	//Filial
								aTransfFun[nX,11],; 	//Matricula
								aTransfFun[nX,06],;		//Centro de Custo
								aTransfFun[nX,04]}		//Empresa
								If cEmpAnt != aTransfFun[nX,4]
									cFilMatAnt 	:= aTransfFun[nX,1]+aTransfFun[nX,2]
									lEmpDif		:= .T.
								EndIf
							EndIf
							lTrfEmp := .T.
						EndIf
						dTransf := aTransfFun[nx,7]
						If Len(aDados) > 0 .And. SRA->(dbSeek( aDados[1]+aDados[2] ))
							cSitFolAtu	:= SRA->RA_SITFOLH
							cResRAISAt	:= SRA->RA_RESCRAI						
							SRA->( dbGoto(nRecSRA) )
						EndIf
					EndIf
				Next
				If len(aDados) > 0
					If 	((aDados[1] < cFilDe .or. aDados[1] > cFilAte) .and. !Empty(cFilAte)) .or. ;
					((aDados[2] < cMatDe .or. aDados[2] > cMatAte) .and. !Empty(cMatAte)) .or. ;
					((aDados[3] < cCcDe  .or. aDados[3] > cCCAte ) .and. !Empty(cCCAte))
						If aTotRegs[2] == 0
							cLog := STR0087+STR0088 //"Nao Gerado - "##"Filial/Matricula/Centro de custo nao encontra-se dentro dos parametros selecionados"
							Aadd(aTitle,cLog)
							Aadd(aLog,{})
							aTotRegs[2] := len(aLog)
						EndIf

						cBusca := aDados[1]+"-"+aDados[2]+" - "+SRA->RA_NOME
						If len( aLog[1] ) > 0
							If Ascan( aLog, {|x| x[1] == cBusca}) == 0
								Aadd( aLog[aTotRegs[2]], cBusca )
							EndIf
						Else
							Aadd( aLog[aTotRegs[2]], cBusca )
						EndIf

						(cAliasSRA)->(dbSkip())
						Loop
					EndIf
				EndIf
			EndIf

			//Incluir os funcionarios demitidos por transferidos, qdo selecionado a situacao "Normal"
			//Nao incluir os funcionarios transferidos, qdo selecionado apenas a opcao "Demitido"
			If (cSitFolAtu =="D" .and. ((nEnvFunc == 1 .and. !(cResRAISAt$'30/31') ) .or. (nEnvFunc == 2 .and. (cResRAISAt$'30/31') ) ) )
				(cAliasSRA)->(dbSkip())
				Loop
			EndIf

			If nAtuLanc == 2 .and. ( cSitFolAtu =="D" .and. !(cResRAISAt$'30/31') )   //Gerar em Lancamento Mensal e o funcionario esta demitido
				If aTotRegs[1] == 0
					cLog := STR0087+"Funcionario demitido nao pode ser enviado para lancamentos mensais" //"Nao Gerado - "##"Funcionario demitido nao pode ser enviado pra lancamentos mensais"
					Aadd(aTitle,cLog)
					Aadd(aLog,{})
					aTotRegs[1] := len(aLog)
				EndIf

				cBusca := SRA->RA_FILIAL+"-"+SRA->RA_MAT+" - "+SRA->RA_NOME
				If len( aLog[1] ) > 0
					If Ascan( aLog,{|x| x[1] == cBusca}) == 0
						Aadd( aLog[aTotRegs[1]], cBusca )
					EndIf
				Else
					Aadd( aLog[aTotRegs[1]], cBusca )
				EndIf

				(cAliasSRA)->(dbSkip())
				Loop
			EndIf

			//-- Guarda a primeira "ordem" de aumento para registra-la se nao houver aumento na data (qualquer tipo
			//-- de aumento ou qualquer registro de aumento para qualquer data).
			nFirstRec := RHH->( Recno() )
			nValAnt		:= 0

			If lEmpDif
				nRecSRA		:= SRA->( Recno() )
				// Abre as tabelas do grupo de empresas destino
				ChangeNew({"SRA", "RGB", "SRK", "RFC", "SR3", "SR7", "SRJ", "SQ3", "SRV"}, aDados[4], aDados[1])		
				SRA->( dbSetOrder(1) )
				SRA->( dbSeek( aDados[1] + aDados[2] ) )
			EndIf

			aPdRGB := {}

			Begin Transaction

				While RHH->( ! Eof() )
					If !(RHH->( RHH_FILIAL+RHH_PROCES+RHH_MAT+RHH_MESANO+RHH_SEMANA ) == cChvRHH)
						Exit
					EndIf

					If !Empty(cIdCmpl) .and. RHH->RHH_IDCMPL <> cIdCmpl
						RHH->( dbSkip() )
						Loop
					EndIf

					If RHH->RHH_INTEGR == "S"
						If RHH->RHH_COMPL_ == "S" .and. nAtuLanc == 2 .And. !( RHH->RHH_VB $ cNotCods )
							RHH->( aAdd(aPdRGB, { RHH_FILIAL, RHH_MAT, RHH_VERBA, RHH_CC, RHH_VALOR, RHH_DATA, RHH_ITEM, RHH_CLVL}) )
						EndIf
						RHH->( dbSkip() )
						Loop
					EndIf

					//-- Considera a data de Admissao para funcionarios admitidos no mes do dissidio
					IF  Substr(DtoS(SRA->RA_ADMISSA),1,6) >= RHH->RHH_DATA
						dDtReaj 	:= SRA->RA_ADMISSA
					Else
						dDtReaj 	:= Ctod( "01/" + substr(RHH->RHH_DATA,5,2) + "/" + substr(RHH->RHH_DATA,1,4))
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza matriz de total do funcionario.								³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If RHH->RHH_VB == "000"
						cFuncAnt := ""
						cCargAnt := ""
						cCatAnt	 := ""
						cPgtAnt	 := ""
						cDescCar := ""
						nValHist := 0

						If nAtuSalario == 1		//Atualiza historico Salarial

							lAtualiza := If(lTransfAtu,If(len(adados) >0, (aDados[1]==SRA->RA_FILIAL),.T.),.T.)

							If lAtualiza
								
								fSeqHistSal( @aR7AllRecs, @nR7SeqTam,@dR7Dta )
								If AnoMes(dR7Dta) == AnoMes(dDtReaj)
									dDtReaj := dR7Dta
								EndIf
								
								SR3->(DbSetOrder(2))
								If SR3->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + DtoS(dDtReaj),.T.))
									//Verifica se já houve alteração salarial no mesmo mês com valor inferior ao atual
									If AnoMes(SR3->R3_DATA) == AnoMes(dDtReaj)
										While SR3->(!Eof() .and. R3_FILIAL + R3_MAT + AnoMes(R3_DATA) == SRA->RA_FILIAL+SRA->RA_MAT+AnoMes(dDtReaj))
											If SR3->R3_TIPO == RHH->RHH_TPOAUM //Dissidio
												nValHist := 0
											Else
												nValHist := SR3->R3_VALOR
											EndIf
											SR3->(DbSkip())
										EndDo
									EndIf
								EndIf
								SR3->(DbSetOrder(1))

								If RHH->RHH_CALC != nValAnt .or. ( nValHist > 0 .and. nValHist < RHH->RHH_CALC )

									nSalario := SRA->RA_SALARIO

									If lContrInt .and. SRA->RA_TPCONTR == "3" .and. SRA->RA_SALARIO == 0
										aConvoc		:= BuscaConv(StoD(AnoMes(dDtReaj) + "01"), StoD(AnoMes(dDtReaj) + AllTrim(STR(Last_Day(dDtReaj)))))
										If !Empty(aConvoc)
											nSalario := aConvoc[1,4]
										EndIf
									EndIf

									dDatDiss := Ctod("//")

									If SQ3->( dbSeek(xFilial("SQ3")+SRA->RA_CARGO+SRA->RA_CC)) .or. SQ3->( dbSeek(xFilial("SQ3")+SRA->RA_CARGO))
										cDescCar := SQ3->Q3_DESCSUM
									EndIf

									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³-Verifica se ja teve alguma alteracao salarial se nao grava a anterior como Primeira³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									IF SR7->( !dbSeek(SRA->RA_FILIAL+SRA->RA_MAT) )
										//-- monta data da alteracao como mes anterior da ultima
										cMes := If ( Val(substr(RHH->RHH_DATA,5,2))-1 > 0,StrZero(val(substr(RHH->RHH_DATA,5,2))-1,2) , "12")
										cAno := If (cMes = "12", StrZero(val(substr(RHH->RHH_DATA,1,4))-1,4),substr(RHH->RHH_DATA,1,4) )
										cFun := DescFun( SRA->RA_CODFUNC , SRA->RA_FILIAL )
										fSeqHistSal( @aR7AllRecs, @nR7SeqTam,@dR7Dta ) //Funcao para preenchimento dos campos R7_SEQ e R3_SEQ

										//--grava o Salario anterior quando nao existir alteracao
										IF SR7->( RecLock("SR7",.T.,.T.) )
											SR7->R7_FILIAL   := SRA->RA_FILIAL
											SR7->R7_MAT      := SRA->RA_MAT
											SR7->R7_DATA     := SRA->RA_ADMISSA
											SR7->R7_TIPO     := "001"
											SR7->R7_FUNCAO   := SRA->RA_CODFUNC
											SR7->R7_DESCFUN  := cFun
											SR7->R7_TIPOPGT  := SRA->RA_TIPOPGT
											SR7->R7_CATFUNC  := SRA->RA_CATFUNC
											SR7->R7_USUARIO  := "Sistema"
											If lR7Cargo
												SR7->R7_CARGO   := SRA->RA_CARGO
											EndIf
											If lR7DescCar
												SR7->R7_DESCCAR	:= cDescCar
											EndIf
											If lR7Seq .And. ValType(nR7SeqTam) == "N"
												SR7->R7_SEQ		:= Strzero( 1, nR7SeqTam )
											EndIf

											SR7->( MsUnLock() )
											SR7->( FKCOMMIT() )
										EndIF

										IF RecLock("SR3",.T.,.T.)
											SR3->R3_FILIAL   := SRA->RA_FILIAL
											SR3->R3_MAT      := SRA->RA_MAT
											SR3->R3_DATA     := SRA->RA_ADMISSA
											SR3->R3_PD       := "000"
											SR3->R3_DESCPD   := "SALARIO BASE"
											SR3->R3_VALOR    := nSalario
											SR3->R3_TIPO     := "001"
											If lR3AnteAum
												SR3->R3_ANTEAUM	:= SRA->RA_ANTEAUM
											EndIf
											If lR3Seq
												SR3->R3_SEQ		:= SR7->R7_SEQ
											EndIf

											SR3->( MsUnLock() )
										EndIF
									EndIF

									fSeqHistSal( @aR7AllRecs, @nR7SeqTam,@dR7Dta ) //Funcao para preenchimento dos campos R7_SEQ e R3_SEQ

									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Atualizando SR7 - Alteracao Salarial                         ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									cFun := DescFun(SRA->RA_CODFUNC,SRA->RA_FILIAL)

									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Verifica se ja teve um aumento no mesmo mes e ano do dissidio.	³
									//³ Caso ja existe utilizar a maior data entre eles e considera-lo 	³
									//³ como data do reajuste.									   	    ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									If !Empty(dR7Dta) .and. MesAno(dDtReaj) == MesAno(dR7Dta)
										dDtReaj := Max(dDtReaj,dR7Dta)
									EndIf

									dbSelectArea( "SR7" )

									lHaAltAnt 		:= .T.
									cChave 			:= SRA->RA_FILIAL+SRA->RA_MAT+Dtos(dDtReaj)+RHH->RHH_TPOAUM+"000"
									lHaAlt			:= dbSeek( substr(cChave,1,(Len(SRA->RA_FILIAL+SRA->RA_MAT))) + cAnoMes )
									If lHaAlt // Busca se existe alteracao na mesma data
										dbSkip(-1)
										If SR7->R7_FILIAL+SR7->R7_MAT == SRA->RA_FILIAL+SRA->RA_MAT
											cFuncAnt	:= SR7->R7_FUNCAO
											cCargAnt	:= SR7->R7_CARGO
											cCatAnt 	:= SR7->R7_CATFUNC
											cPgtAnt 	:= SR7->R7_TIPOPGT
											cFun 		:= DescFun(cFuncAnt,SRA->RA_FILIAL)
										EndIf
										SR3->(dbSeek( substr(cChave,1,(Len(SRA->RA_FILIAL+SRA->RA_MAT))) + cAnoMes ))
										While SR3->(!Eof() .and. R3_FILIAL + R3_MAT + AnoMes(R3_DATA) == SubStr(cChave,1,(Len(SRA->RA_FILIAL+SRA->RA_MAT))) + cAnoMes)
											If RHH->RHH_CALC > SR3->R3_VALOR
												lHaAlt := .F. //Força alteração salarial
											EndIf
											If lR3AnteAum .and. RHH->RHH_CALC > SR3->R3_ANTEAUM
												lHaAltAnt := .F.
											EndIf
											SR3->(DbSkip())
										EndDo
									Else // Caso nao existe alteracao na mesma data
										If SR7->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT))
											While SR7->(!Eof() .and. R7_FILIAL + R7_MAT == SRA->RA_FILIAL+SRA->RA_MAT)
												If AnoMes(SR7->R7_DATA) <= AnoMes(dDtReaj)
													// Verifica se Funcao mudou
													If SR7->R7_FUNCAO <> cFuncAnt
														cFuncAnt := SR7->R7_FUNCAO
													EndIf

													// Verifica se Cargo mudou
													If SR7->R7_CARGO <> cCargAnt
														cCargAnt := SR7->R7_CARGO
													EndIf

													// Verifica se Categoria mudou
													If SR7->R7_CATFUNC <> cCatAnt
														cCatAnt := SR7->R7_CATFUNC
													EndIf

													// Verifica se Tipo de Pagamento mudou
													If SR7->R7_TIPOPGT <> cPgtAnt
														cPgtAnt := SR7->R7_TIPOPGT
													EndIf
												EndIf

												cFun := If(Empty(cFuncAnt),cFun, DescFun(cFuncAnt,SRA->RA_FILIAL))

												SR7->(DbSkip())
											EndDo
										EndIf
									EndIf
									
									lHaReaj			:= dbSeek( substr(cChave,1,(Len(SRA->RA_FILIAL+SRA->RA_MAT+Dtos(dDtReaj))) ))
									lHaExatoReaj	:= dbSeek( substr(cChave,1,(Len(SRA->RA_FILIAL+SRA->RA_MAT+Dtos(dDtReaj)+RHH->RHH_TPOAUM)) ))

									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Altera registro: se encontrou reajuste na data para o tipo de	³
									//³ aumento informado (busca integral).							 	³
									//³ Inclui registro: se encontrou reajuste na data (busca parcial)  ³
									//³                  ou registrar a primeira ocorrencia.            ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									IF 	(lHaExatoReaj .or. lHaReaj) .or.   ;
									(!lHaExatoReaj .and. !lHaReaj)
										IF lHaExatoReaj
											RecLock("SR7",.F.,.T.)
											lAchouAlt := .T.
										Else
											RecLock("SR7",.T.,.T.)
											lAchouAlt := .F.
										Endif
										SR7->R7_FILIAL   := SRA->RA_FILIAL
										SR7->R7_MAT      := SRA->RA_MAT
										SR7->R7_DATA     := dDtReaj
										SR7->R7_TIPO     := RHH->RHH_TPOAUM
										SR7->R7_FUNCAO   := If(Empty(cFuncAnt), SRA->RA_CODFUNC,cFuncAnt)
										SR7->R7_DESCFUN  := cFun
										SR7->R7_TIPOPGT  := If(Empty(cPgtAnt), SRA->RA_TIPOPGT,cPgtAnt)
										SR7->R7_CATFUNC  := If(Empty(cCatAnt), SRA->RA_CATFUNC,cCatAnt)
										SR7->R7_USUARIO  := cUserName
										If lR7Cargo
											SR7->R7_CARGO   := If(Empty(cCargAnt), SRA->RA_CARGO,cCargAnt)
										EndIf
										If lR7DescCar
											SR7->R7_DESCCAR	:= cDescCar
										EndIf

										If lR7Seq
											If Len( aR7AllRecs ) > 0 .And. ( ( nPosDt := aScan( aR7AllRecs, { |x| x[ 1 ] == SR7->R7_DATA } ) ) > 0 ) //Existe alteracao salarial para a data informada
												If lAchouAlt //Mesmo tipo de aumento, entao localiza seq. e substitui
													nPosTp 	:= aScan( aR7AllRecs[ nPosDt, 2 ], { |x| x[ 2 ] == SR7->R7_TIPO } ) //Localiza registro do mesmo tipo de aumento
													SR7->R7_SEQ	:= aR7AllRecs[ nPosDt, 2, nPosTp, 3 ]
												Else //Tipo de aumento diferente, entao atualiza seq. como sendo a ultima
													aSort( @aR7AllRecs[ nPosDt, 2 ], , , { | x, y | x[ 3 ] < y[ 3 ] } )
													SR7->R7_SEQ	:= StrZero( Val( Soma1( aR7AllRecs[ nPosDt, 2, Len( aR7AllRecs[ nPosDt, 2 ] ), 3 ] ) ), nR7SeqTam )
												EndIf
											Else //Nao existem quaisquer alteracoes salariais p/ a data informada, logo eh a primeira seq.
												If( ValType(nR7SeqTam) == "N", SR7->R7_SEQ := StrZero( 1, nR7SeqTam ), )
											EndIf
											cR3Seq := SR7->R7_SEQ
										EndIf

										SR7->(MsUnLock())
										SR7->(FkCommit())

										//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										//³ Atualizando SR3 - Alteracao Salarial                         ³
										//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										If SR3->(dbSeek( cChave ))
											RecLock("SR3",.F.,.T.)
										Else
											RecLock("SR3",.T.,.T.)
										EndIf

										SR3->R3_FILIAL   := SRA->RA_FILIAL
										SR3->R3_MAT      := SRA->RA_MAT
										SR3->R3_DATA     := dDtReaj
										SR3->R3_PD       := "000"
										SR3->R3_DESCPD   := "SALARIO BASE"
										SR3->R3_VALOR    := RHH->RHH_CALC
										SR3->R3_TIPO     := RHH->RHH_TPOAUM

										If lR3AnteAum
											SR3->R3_ANTEAUM := RHH->RHH_CALC
										EndIf

										If lR3Seq
											SR3->R3_SEQ		:= SR7->R7_SEQ
										EndIf

										If lR3DtcDiss
											// A data do dissidio sempre eh gerada como o dia 1o. do mes de inicio do dissidio retroativo.
											// Logo, a data do calculo do reajuste pelo dissidio retroativo deve ser sempre a data imediatamente
											// posterior a todas as alteracoes existentes no SR7/SR3.
											// Aqui efetua-se a gravacao da data de calculo do dissidio para identificar que a partir desse
											// mes efetivamente o funcionario comecou a receber o novo salario.
											If	Len( aR7AllRecs ) > 0 .And. MesAno( aR7AllRecs[ Len( aR7AllRecs ), 1 ] ) ==  RHH->RHH_MESANO
												dDtCDiss		:= aR7AllRecs[ Len( aR7AllRecs ), 1 ]
												SR3->R3_DTCDISS	:= If( f_UltDia(dDtCDiss) == Day(dDtCDiss), dDtCDiss, dDtCDiss + 1 )
											Else
												SR3->R3_DTCDISS	:= Stod( RHH->RHH_MESANO + "01", "DDMMYY" )
											EndIf
										EndIf
										cDtCompDis	:= 	RHH->RHH_DATA		// Data da Competencia do Dissidio
										dDatDiss	:= 	SR3->R3_DTCDISS
										SR3->(MsUnLock())
										SR3->(FkCommit())
									Endif

									If lIntegDef
										SetRotInteg("GPEA250")
										FwIntegDef("GPEA250")
									EndIf

									/*
									ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									³ Ponto de Entrada para atualizar tabela personalizada        ³
									ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
									If lGpAltSal
										Execblock("GPALTSAL",.F.,.F.,)
									Endif

									If !lHaAlt .and. !lHaReaj
										If nSalario > RHH->RHH_CALC
											lHaAlt := .T.
											If RHH->RHH_CALC > SRA->RA_ANTEAUM
												lHaAltAnt := .F.
											EndIf
										EndIf
									EndIf

									nValAnt := RHH->RHH_CALC
									If ( !lHaAlt .or. !lHaAltAnt ) .and. !( lContrInt .and. SRA->RA_TPCONTR == "3" .and. SRA->RA_SALARIO == 0 ) //Não alterar RA_SALARIO de intermitente
										dbSelectArea( "SRA" )
										RecLock( "SRA" , .F. )
										If !lHaAlt
											SRA->RA_SALARIO := RHH->RHH_CALC
											SRA->RA_ANTEAUM := RHH->RHH_CALC
										Else
											SRA->RA_ANTEAUM := RHH->RHH_CALC
										EndIf
										MsUnLock()
									EndIf
								EndIf
							EndIf
						EndIf
					Else
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Carrega cadastro de verbas para posterior filtro						³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If cAntFil <> RHH->RHH_FILIAL
							If !Fp_CodFol(@aCodFol,xFilial("SRA", RHH->RHH_FILIAL))
								Exit
							Endif
							cAntFil := RHH->RHH_FILIAL
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Alimenta cNotCods com os codigos que nao devem ser listados				³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							cNotCods := FiltraVb(aCodFol)
						EndIf

						cIdNoRRA := FiltraNoRRA(aCodFol)

						//Gera movimento somente se registro nao for de RRA
						If (cPaisLoc != "BRA")  .or.  (cPaisLoc == "BRA" .And.  !(RHH->RHH_RRA == '1') ) .or. (cPaisLoc == "BRA" .And.  RHH->RHH_RRA == '1' .And. RHH->RHH_VERBA $ cIdNoRRA )

							If RHH->RHH_COMPL_ == "S" .And. !( RHH->RHH_VB $ cNotCods )
								If lTransfAtu .and. len(adados) >0
									nLinha := Ascan( aFunc, { | X | X[1]+X[2]+X[3]+X[4] = aDados[1]+aDados[2]+RHH->RHH_VERBA+If( lRateio, aDados[3], "") } )
								Else
									nLinha := Ascan( aFunc, { | X | X[1]+X[2]+X[3]+X[4] = SRA->(RA_FILIAL+RA_MAT)+RHH->RHH_VERBA+If( lRateio, RHH->RHH_CC,"") } )
								EndIf

								If nLinha  > 0
									aFunc[nLinha,5] += RHH->RHH_VALOR
								Else
									If lTransfAtu .and. len(adados) >0
										Aadd( aFunc, { aDados[1], aDados[2], RHH->RHH_VERBA, aDados[3], RHH->RHH_VALOR, RHH->RHH_DATA,;
										SRA->RA_ITEM,SRA->RA_CLVL } )
									Else
										Aadd( aFunc, { SRA->RA_FILIAL, SRA->RA_MAT, RHH->RHH_VERBA, RHH->RHH_CC, RHH->RHH_VALOR, RHH->RHH_DATA,;
										SRA->RA_ITEM,SRA->RA_CLVL} )
									EndIf
								EndIf
							EndIf
						EndIf

						If lTransfAtu .and. len(adados) >0
							cFilRFC := aDados[1]
							cMatRFC := aDados[2]
							cCCRFC	:= aDados[3]
						Else
							cFilRFC := SRA->RA_FILIAL
							cMatRFC := SRA->RA_MAT
							cCCRFC	:= SRA->RA_CC
						EndIf

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualizacao referente as verbas que incorporam salario no mes do dissidio.    ³
						//³ Somente registrar o Historico qdo a variavel da data do dissidio (dDatDiss)	  ³
						//³ estiver preenchida, indicando a necessidade de registrar o historico conforme ³
						//³ a condicao oposta a este bloco de ELSE.										  ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If ! Empty( dDatDiss ) .AND. RHH->RHH_DATA == cDtCompDis .AND. fIncide(RHH->RHH_VB)
							If ( nPos := aScan(  aPdv, { |x| x[1] == RHH->RHH_VB  }  ) ) > 0 .And. aPdv[nPos,18] == "S"
								dbSelectArea( "SR3" )

								If dbSeek( SRA->(RA_FILIAL+RA_MAT) + Dtos( dDtReaj ) + RHH->RHH_TPOAUM + RHH->RHH_VB )
									RecLock("SR3",.F.)
									SR3->R3_VALOR := RHH->RHH_CALC
								Else
									RecLock("SR3",.T.,.T.)
									SR3->R3_FILIAL   := SRA->RA_FILIAL
									SR3->R3_MAT      := SRA->RA_MAT
									SR3->R3_DATA     := dDtReaj
									SR3->R3_PD       := RHH->RHH_VB
									SR3->R3_DESCPD   := DescPd(RHH->RHH_VB,SRA->RA_FILIAL)
									SR3->R3_VALOR    := RHH->RHH_CALC
									SR3->R3_TIPO     := SR7->R7_TIPO

									If lR3Seq
										SR3->R3_SEQ		:= SR7->R7_SEQ
									EndIf
									If lR3DtcDiss
										SR3->R3_DTCDISS	:= dDatDiss
									EndIf
								Endif
								SR3->( MsUnLock() )
							EndIf
						EndIf
					EndIf

					dbSelectArea( "RHH" )
					RecLock( "RHH", .F., .F. )
					RHH->RHH_INTEGR := "S"
					RHH->(msUnlock())

					RHH->( dbSkip() )
				Enddo

				//Grava RFC
				fLoadRFC(@aRFCGrv,SRA->RA_FILIAL,SRA->RA_MAT,cIdCmpl,cAnoMes)

				//Se foi feito dois cálculos no mesmo período em momentos distintos, com geraçao de verbas também em momentos distintos
				//soma as verbas da primeira geração na atual
				If Len(aPdRGB) > 0
					For nX := 1 to Len(aPdRGB)
						nLinha := Ascan( aFunc, { | X | X[1]+X[2]+X[3] == aPdRGB[nX,1] + aPdRGB[nX,2] + aPdRGB[nX,3]  .and. (!lRateio .or. X[4] == aPdRGB[nX,4]) } )

						If nLinha  > 0
							aFunc[nLinha,5] += aPdRGB[nX,5]
						EndIf
					Next nX 
				EndIf

				For nX := 1 to Len(aRFCGrv)
					If lTransfAtu .and. len(adados) >0
						nLinha := Ascan( aFunc, { | X | X[1]+X[2]+X[3]+X[4] = aDados[1]+aDados[2]+aRFCGrv[nX,1]+If( lRateio, aDados[3], "") } )
					Else
						nLinha := Ascan( aFunc, { | X | X[1]+X[2]+X[3]+X[4] = SRA->(RA_FILIAL+RA_MAT)+aRFCGrv[nX,1]+If( lRateio, aRFCGrv[nX,2],"") } )
					EndIf

					If nLinha  > 0
						aFunc[nLinha,5] += aRFCGrv[nX,3]
					Else
						If lTransfAtu .and. len(adados) >0
							Aadd( aFunc, { aDados[1], aDados[2], aRFCGrv[nX,1], aDados[3], aRFCGrv[nX,3], aRFCGrv[nX,4] ,;
							SRA->RA_ITEM,SRA->RA_CLVL } )
						Else
							Aadd( aFunc, { SRA->RA_FILIAL, SRA->RA_MAT, aRFCGrv[nX,1], aRFCGrv[nX,2], aRFCGrv[nX,3], aRFCGrv[nX,4] ,;
							SRA->RA_ITEM,SRA->RA_CLVL } )
						EndIf
					EndIf
				Next nX
				aRFCGrv := {}

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava valores calculados no arquivo de lancamentos futuros.				³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				For nI := 1 To Len( aFunc )
					If aFunc[nI,5] <= 0
						Loop
					EndIf

					If lTransfAtu .and. len(adados) >0
						cChave := aDados[1]+aDados[2]
					Else
						cChave := SRA->RA_FILIAL+SRA->RA_MAT
					EndIf

					If cChave # aFunc[ni,1]+aFunc[ni,2]
						Loop
					EndIf

					If nAtuLanc == 1	//Lancamento Futuro
						nIndSRK := RetOrder("SRK","RK_FILIAL+RK_MAT+RK_PD+RK_CC")

						dbSelectArea("SRK")
						SRK->( DBSETORDER(nIndSRK) )

						If lTransfAtu .and. len(adados) >0
							cChave := aDados[1]+aDados[2]+aFunc[ni,3]+If( lRateio, aFunc[nI,4],"" )
							cChave1:= aDados[1]+aDados[2]+aFunc[ni,3]
						Else
							cChave := SRA->RA_FILIAL+SRA->RA_MAT+aFunc[ni,3]+If( lRateio, aFunc[nI,4],"" )
							cChave1:= SRA->RA_FILIAL+SRA->RA_MAT+aFunc[ni,3]
						EndIf

						If !SRK->( dbSeek(cChave) )
							RecLock( 'SRK', .T. )
						Else
							If lIncluiNovo
								While SRK->( !EOF() ) .and. SRK->RK_FILIAL+SRK->RK_MAT+SRK->RK_PD == cChave1
									If SRK->RK_DTMOVI <> dDataBase .or. ( SRK->RK_STATUS == '3' .or. SRK->RK_PERINI <> cAnoMes )
										If SRK->RK_CC+SRK->RK_DOCUMEN == If(lTransfAtu .and. len(adados) >0,	aDados[3],SRA->RA_CC)+cDocumento
											If aTotRegs[4]== 0
												cLog := STR0087+STR0105 //"Nao Gerado - ##"Ja existe um registro com esta chave"
												Aadd(aTitle,cLog)
												Aadd(aLog,{})
												aTotRegs[4] := len(aLog)
											EndIf

											cBusca := STR0023+": "+SRK->RK_FILIAL+" / "+STR0028+": "+ SRK->RK_MAT+" / "+STR0085+": "+SRK->RK_PD+" / "+STR0029+": "+SRK->RK_CC+" / "+STR0106+": "+SRK->RK_DOCUMEN //"Filial: "## Matricula: #VERBA:# c.cUSTO:#Documento
											If len(aLog[aTotRegs[4]]) > 0
												If Ascan( aLog[aTotRegs[4] ],{|x| x == cBusca})==0
													Aadd(aLog[aTotRegs[4]],cBusca)
												EndIf
											Else
												Aadd(aLog[aTotRegs[4]],cBusca)
											EndIf
											lGera := .F.
											DisarmTransaction()
											Exit
										EndIf
									Else
										If SRK->RK_DOCUMEN == cDocumento
											lAtuSRK := .T.
											Exit
										EndIf
									EndIf
									SRK->( dbSkip() )
								EndDo

								If lGera
									If !lAtuSRK
										If lTransfAtu .and. len(adados) >0
											If SRA->RA_FILIAL == aDados[1]
												RecLock( 'SRK', .T. )
											Else
												Loop
											EndIf
										Else
											RecLock( 'SRK', .T. )
										EndIf
									Else
										RecLock( 'SRK', .F. )
									EndIf
								Else
									Loop
								EndIf
							Else
								RecLock( 'SRK', .F. )
							EndIf
						Endif

						If lTransfAtu .and. len(adados) >0
							SRK->RK_FILIAL 	:= 	aDados[1]
							SRK->RK_MAT 	:= 	aDados[2]
							SRK->RK_CC		:= 	aDados[3]
						Else
							SRK->RK_FILIAL	:= SRA->RA_FILIAL
							SRK->RK_MAT		:= SRA->RA_MAT
							SRK->RK_CC		:= If( lRateio, aFunc[nI,4], SRA->RA_CC )
						EndIf
						SRK->RK_PD		:= aFunc[nI,3]
						SRK->RK_VALORTO	:= aFunc[nI,5]
						SRK->RK_DTVENC	:= dDatVen
						SRK->RK_DTMOVI	:= dDataBase
						SRK->RK_DOCUMEN	:= cDocumento

						If nParcela = 1 .or. aFunc[nI,5] <= nMinimo .or. ( SRA->RA_SITFOLH =="D" .and. !(SRA->RA_RESCRAI$'30/31') )
							SRK->RK_PARCELA := 1
							SRK->RK_VALORPA := aFunc[nI,5]
						Else
							nValParcela		:= NoRound( aFunc[nI,5] / nParcela, 2 )
							nValResiduo		:= NoRound( afunc[nI,5] - ( nValParcela * nParcela ), 2 )
							SRK->RK_PARCELA	:= nParcela
							SRK->RK_VALORPA	:= nValParcela
							SRK->RK_VALORAR	:= nValResiduo
						Endif

						If cPaisLoc="BRA"
							SRK->RK_IDCMPL	:= cIdCmpl
							SRK->RK_MESDISS	:= SubStr(aFunc[nI, 6],5,2) + SubStr(aFunc[nI,6],1,4)
							SRK->RK_NUMID   := If( !lEmpDif, "SRK" + SRA->RA_FILIAL + SRA->RA_MAT + aFunc[nI,3] + cDocumento, "SRK" + cFilMatAnt + aFunc[nI,3] + cDocumento)
						EndIf

						SRK->RK_PROCES := cProcesso
						SRK->RK_PERINI := cAnoMes
						SRK->RK_NUMPAGO :=	cSemana
						SRK->RK_STATUS := "2"
						If ( lClasse .AND. (!Empty(aFunc[nI , 7]) .OR. !Empty(aFunc[nI , 8])) )
							fGravaItem("SRK" , aFunc[nI] , 7)
							/*O terceiro parametro refere-se a posicao de aFunc, que corresponde ao item contabil. */
						EndIf

						SRK->(MsUnLock())

					Elseif nAtuLanc == 2	//Lancamento Mensal

						dbSelectArea("RGB")
						RGB->(DbSetOrder( RetOrder( "RGB", "RGB_FILIAL+RGB_MAT+RGB_PD+RGB_CC+RGB_ITEM+RGB_CLVL+RGB_SEMANA+RGB_SEQ" )))

						If lTransfAtu .and. len(adados) >0
							cChave := aDados[1]+aDados[2]+aFunc[ni,3]+If( lRateio, aFunc[ni,4],"")
						Else
							cChave := SRA->RA_FILIAL+SRA->RA_MAT+aFunc[ni,3]+If( lRateio, aFunc[ni,4], "" )
						EndIf

						lTemRGB := .F.

						cCodConvoc := ""

						If lContrInt .and. SRA->RA_TPCONTR == "3" .and. SRA->RA_SALARIO == 0
							aConvoc		:= BuscaConv(StoD(cAnoMes + "01"), StoD(cAnoMes + AllTrim(STR(Last_Day(StoD(cAnoMes + "01"))))))
							cCodConvoc  := If(!Empty(aConvoc),aConvoc[1,1],"") //Código da convocação
						EndIf

						If ! RGB->( dbSeek(cChave))
							RecLock( 'RGB', .T. )
						Else
							If cSemana <> RGB->RGB_SEMANA .Or. lTrfEmp
								If lTrfEmp .And. cSemana == RGB->RGB_SEMANA
									While RGB->( !EoF() ) .And. RGB->RGB_FILIAL+RGB->RGB_MAT+RGB->RGB_PD+Iif( lRateio, RGB->RGB_CC, "" ) == cChave
										If RGB->RGB_VALOR == aFunc[nI,5]
											lTemRGB := .T.
											Exit
										EndIf
										RGB->( dbSkip() )
									EndDo
									If lTemRGB
										Loop
									EndIf
									cSeq	:= Soma1(RGB->RGB_SEQ)
								EndIf
								RecLock( 'RGB', .T. )
							Else
								RecLock( 'RGB', .F. )
							Endif
						Endif

						If lTransfAtu .and. len(adados) >0
							RGB->RGB_FILIAL := 	aDados[1]
							RGB->RGB_MAT 	:= 	aDados[2]
							RGB->RGB_CC		:= 	aDados[3]
						Else
							RGB->RGB_FILIAL := 	SRA->RA_FILIAL
							RGB->RGB_MAT 	:= 	SRA->RA_MAT
							RGB->RGB_CC		:= 	If( lRateio,aFunc[nI,4], SRA->RA_CC )
						EndIf

						RGB->RGB_PD		:= 	aFunc[nI,3]
						RGB->RGB_SEMANA :=	cSemana
						RGB->RGB_TIPO1	:= 	"V"
						RGB->RGB_TIPO2	:= 	"G"
						RGB->RGB_HORAS	:= 	0
						RGB->RGB_VALOR	:= 	aFunc[nI,5]
						RGB->RGB_PARCEL	:= 	0
						RGB->RGB_SEQ	:= 	cSeq
						RGB->RGB_PROCES := cProcesso
						RGB->RGB_PERIOD := cAnoMes
						RGB->RGB_ROTEIR := cRoteiro
						RGB->RGB_DTREF 	:= dDatVen
						RGB->RGB_DEPTO 	:= SRA->RA_DEPTO
						RGB->RGB_IDCMPL	:= cIdCmpl

						If ( lClasse .AND. (!Empty(aFunc[nI , 7]) .OR. !Empty(aFunc[nI , 8])), fGravaItem("RGB" , aFunc[nI] , 7), Nil ) // A rotina encontra-se no fonte: GPEM700
						If(!Empty(cCodConvoc), RGB->RGB_CONVOC := cCodConvoc, Nil)

						RGB->(MsUnLock())
					EndIf
				Next

				If lEmpDif
					// Reabre as tabelas do grupo de empresas origem
					ChangeNew({"SRA", "RGB", "SRK", "RFC", "SR3", "SR7", "SRJ", "SQ3", "SRV"}, cEmpAnt, cFilAnt)
					SRA->( dbGoTo(nRecSRA) )
				EndIf

			End Transaction
		EndIf 

		(cAliasSRA)->(dbSkip())
	Enddo
	(cAliasSRA)->(dbCloseArea())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Chama rotina de Log de Ocorrencias. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	fMakeLog(aLog,aTitle,,,"DS"+DTOS(dDatVen),STR0073,"M","P",,.F.) //"LOG de Ocorrencias - Dissidio"

	RestArea( aAreaSRA )
	RestArea( aAreaSR3 )
	RestArea( aArea )
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GpCr01DeleºAutor  ³Microsiga           º Data ³  01/11/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Delecao do calculo                                         º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Estatica                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static function GpCr01Dele( aDelCols )
	Local NX		:= 0
	Local aArea		:= GetArea()
	Local cChaveMem	:= ""
	
	DEFAULT __lMemCalc  := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc() // Memória de Cálculo

	// Excluir registros da tabela RHH a partir do primeiro registro que encontrar referente ao dissidio
	dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cMesAnoIni, .T. )

	While RHH->(! Eof()) .and. (RHH->(RHH_FILIAL+RHH_MAT) == SRA->(RA_FILIAL+RA_MAT)) .and. (RHH->RHH_DATA >= cMesAnoIni .and. RHH->RHH_DATA <= cMesAnoFim)
		If RHH->RHH_INTEGR # "S"
			If __lMemCalc .and. cChaveMem <> RHH->RHH_FILIAL + RHH->RHH_MAT + RHH->RHH_PROCES + RHH->RHH_DATA + RHH->RHH_ROTEIR + RHH->RHH_SEMANA
				cChaveMem := RHH->RHH_FILIAL + RHH->RHH_MAT + RHH->RHH_PROCES + RHH->RHH_DATA + RHH->RHH_ROTEIR + RHH->RHH_SEMANA
				fDelMemCalc(RHH->RHH_FILIAL , RHH->RHH_MAT , RHH->RHH_PROCES , RHH->RHH_DATA , RHH->RHH_ROTEIR , RHH->RHH_SEMANA)
			EndIf
			RecLock( "RHH", .F., .T. )
			dbDelete( )
			RHH->(MsUnlock())
		EndIf
		DbSkip()
	EndDo

	// Apos excluir os registros da tabela RHH, marca como excluidos os elementos do vetor
	For nx = 1 to Len( aDelCols )
		aDelCols[ Nx, 11 ] := .T.		//-- Deleta verba do aDelCols
	Next nx

	RestArea( aArea )
Return

/*/{Protheus.doc} MenuDef
Isola opcoes de menu para que as opcoes da rotina possam ser lidas pelas bibliotecas Framework da Versao 9.12
@author Luiz Gustavo
@since 18/12/2006
@type function
/*/
Static Function MenuDef()

	Local aRotina 		:=  {}
	
	ADD OPTION aRotina TITLE STR0001 ACTION 'PesqBrw'				OPERATION 1 ACCESS 0 // Pesquisar
	ADD OPTION aRotina TITLE STR0002 ACTION 'GP690CALC'				OPERATION 4 ACCESS 0 // Calculo
	ADD OPTION aRotina TITLE STR0159 ACTION 'VIEWDEF.GPEM690'		OPERATION 4 ACCESS 0 //Manutenção
	ADD OPTION aRotina TITLE STR0065 ACTION 'GP690Exc'				OPERATION 5 ACCESS 0 // Excluir
	ADD OPTION aRotina TITLE STR0004 ACTION 'GP690Imp()'			OPERATION 4 ACCESS 0 // Relatorio
	ADD OPTION aRotina TITLE STR0118 ACTION 'GP690RRA()'			OPERATION 4 ACCESS 0 // Gerar IR RRA
	ADD OPTION aRotina TITLE STR0005 ACTION 'GP690Grv()'			OPERATION 4 ACCESS 0 // Gravar

	If ((FWIsInCallStack("GPEM690") .And. __lMemCalc) .Or. Alltrim( Upper( funname() ) ) == "CFGA530") // Valida se está sendo chamado pelo GPEM690 e tbm pelo configurado
		ADD OPTION aRotina Title OemToAnsi(STR0203) Action 'GPEA091(1)' OPERATION 6 ACCESS 0 //'Consultar Memória de Cálculo'
		ADD OPTION aRotina Title OemToAnsi(STR0204) Action 'GPER091()' OPERATION 6 ACCESS 0 //'Relatório Memória de Cálculo'
	EndIf

Return aRotina

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ FiltraVb ºAutor  ³Jonatas A. T. Alves º Data ³  12/08/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Filtra codigos de verbas que nao devem ser visualizados em º±±
±±º          ³ tela ou listados no relatorio.                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Estatica                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FiltraVb( aCodFol )

	cNotCods := aCodFol[009,1] + "," + aCodFol[010,1] + "," + aCodFol[011,1] + "," + aCodFol[012,1] + "," + aCodFol[015,1] + ","
	cNotCods += aCodFol[016,1] + "," + aCodFol[027,1] + "," + aCodFol[059,1] + "," + aCodFol[060,1] + "," + aCodFol[061,1] + ","
	cNotCods += aCodFol[066,1] + "," + aCodFol[067,1] + "," + aCodFol[071,1] + "," + aCodFol[106,1] + "," + aCodFol[107,1] + ","
	cNotCods += aCodFol[152,1] + "," + aCodFol[167,1] + "," + aCodFol[168,1] + "," + aCodFol[169,1] + "," + aCodFol[236,1] + ","
	cNotCods += aCodFol[237,1] + "," + aCodFol[300,1] + "," + aCodFol[659,1]

Return( cNotCods )

//FILTRAR cIdNoRRA
Static Function FiltraNoRRA( aCodFol ) 

	cIdNoRRA := aCodFol[337,1] + "," + aCodFol[338,1] + "," + aCodFol[339,1] + "," + aCodFol[398,1] + "," + aCodFol[399,1] + ","
	cIdNoRRA += aCodFol[400,1] + "," + aCodFol[943,1] + "," + aCodFol[944,1] + "," + aCodFol[945,1] + ","

Return( cIdNoRRA )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³GP690RRA		³ Autor ³ Leandro Drumond   ³ Data ³ 02.07.12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera verbas para RRA.                     				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM690                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Function GP690RRA()

	Local aArea 	:= GetArea()	// Area atual

	Private cPerg 	:= 'GPCR11'

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega parametros.														³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Pergunte( cPerg, .F. )

	If !fVerPdRRA()
		Return
	EndIf


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta tela de dialogo.													³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cCadastro	:= OemToAnsi( STR0120 ) //Apuração de RRA
	cDescricao 	:= OemToAnsi( STR0121 ) //Cálculo de IR sobre RRA
	bProcesso 	:= {|oSelf| GPRRACALC(oSelf) }
	cFilAnt 	:= cFilAnterior

	If(!lAuto, tNewProcess():New( "GPEM690", cCadastro, bProcesso, cDescricao, cPerg,,.T.,20,cDescricao,.T.), GPRRACALC())

	RestArea( aArea )

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³GPRRACalc		³ Autor ³ Leandro Drumond   ³ Data ³ 02.07.12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Processa Geracao de RRA.                   				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM690                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Function GpRRACalc(oSelf)
	Local aArea 	:= GetArea()
	Local aCodFol	:= {}
	Local aRFCGrv	:= {}
	Local aMesRRA	:= {}
	Local aRecRHH	:= {}
	Local aLogRFC	:= {}
	Local aTitleLog	:= {}
	Local cIdCmpl	:= 	MV_PAR01
	Local cSitFunc	:= 	MV_PAR06
	Local dDataPag	:= 	MV_PAR07
	Local cQuery	:= ''
	Local cAliasRHH	:= ''
	Local cFilAux	:= ''
	Local cDtRef	:= ''
	Local cFilRF1	:= ''
	Local nParcela	:= 0
	Local nPos		:= 0
	Local lVazio	:= .T.
	Local cAliasSRA	:= "QSRA"
	Local cSit		:= ""

	Local cFilRange	:=	""
	Local cCCRange	:= 	""
	Local cMatRange	:= 	""
	Local cNomeRange:= 	""
	Local cWhere	:= ""
	Local _nQtd		:= 0

	Private aPdv	:= {}
	Private aPd		:= {}
	Private aTab_Fol:= {}
	Private cSemana	:= ''

	MakeSqlExpr( "GPCR11" ) //Transforma perguntas do tipo Range em expressao SQL

	cFilRange	:=	MV_PAR02
	cCCRange	:= 	MV_PAR03
	cMatRange	:= 	MV_PAR04
	cNomeRange	:= 	MV_PAR05
	dDataAte	:=  dDataPag

	If Empty( cIdCmpl )
		//"Atencao" # 'Preencha o parâmetro "Complemento"'
		Help("", 1, OemToAnsi(STR0019), Nil, STR0122, 1, 0 )
		Return
	EndIf

	If Empty( dDataPag )
		//"Atencao" # 'Preencha o parâmetro "Data de Pagamento"'
		Help("", 1, OemToAnsi(STR0019), Nil, STR0126, 1, 0 )
		Return
	EndIf

	SetMnemonicos(Nil,Nil,.T.)

	DbSelectArea('RF1')
	RF1->(DbSetOrder(1))

	fCarrTab( @aTab_Fol, "S034")

	If !Empty(cFilRange)
		cWhere += cFilRange + " AND "
	EndIf

	If !Empty(cCCRange)
		cWhere += cCCRange + " AND "
	EndIf

	If !Empty(cMatRange)
		cWhere += cMatRange + " AND "
	EndIf

	If !Empty(cNomeRange)
		cWhere += cNomeRange + " AND "
	EndIf

	For nPos := 1 To Len(cSitFunc)
		If substr(cSitFunc,nPos,1) <> "*"
			cSit += "'" + substr(cSitFunc,nPos,1) + "',"
		EndIf
	Next nPos
	If Len(cSit)>1
		cSit := substr(cSit,1,Len(cSit)-1)
		cWhere += " RA_SITFOLH IN("+cSit+") AND "
		nPos := 0
	EndIf

	cWhere		:= "%" + cWhere + "%"

	If Select("QSRA") > 0
		QSRA->( dbCloseArea() )
	EndIF

	BeginSql alias cAliasSRA
	SELECT RA_FILIAL,RA_MAT,RA_NOME,RA_CC,RA_ITEM,RA_CLVL,RA_DEPTO, R_E_C_N_O_ RECNO,RA_DEPIR
	FROM %table:SRA% SRA
	WHERE  %exp:cWhere%
	SRA.%notDel%
	ORDER BY RA_FILIAL, RA_MAT
	EndSql

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona ponteiros do arquivo SRA.										³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	DbSelectArea(cAliasSRA)
	Count To _nQtd
	dbSelectArea(cAliasSRA)
	(cAliasSRA)->( DbGoTop() )

	If(!lAuto, oSelf:SetRegua1(_nQtd), Nil)

	Do While (cAliasSRA)->( !Eof() )

		dbSelectArea("SRA")
		SRA->(dbGoto((cAliasSRA)->RECNO))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Movimenta cursor para movimentacao da barra.							³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If( !lAuto, oSelf:IncRegua1( (cAliasSRA)->RA_FILIAL + ' - ' + (cAliasSRA)->RA_MAT + ' - ' + If(lOfusca, "", (cAliasSRA)->RA_NOME) ), Nil) 

		If cFilAux <> (cAliasSRA)->RA_FILIAL
			If !Fp_CodFol(@aCodFol,xFilial("SRA", (cAliasSRA)->RA_FILIAL))
				Exit
			Endif

			If !Empty(cIdCmpl) .and. ( cFilRF1 <> xFilial('RF1',(cAliasSRA)->RA_FILIAL) .or. Empty(cFilAux) )
				cFilRF1 := xFilial('RF1',(cAliasSRA)->RA_FILIAL)

				If !RF1->((DbSeek(cFilRF1+cIdCmpl)))
					If ( nPos := Ascan( aTitleLog, {|x| x == STR0123 + ": " } ) ) == 0
						aAdd(aTitleLog, STR0123 + ": " ) //"Complemento não encontrado: " NNNNNN
						aAdd(aLogRFC,{cFilRF1 + " - " + cIdCmpl})
					Else
						aAdd(aLogRFC[nPos],cFilRF1 + " - " + cIdCmpl)
					EndIf
					(cAliasSRA)->(dbSkip())
					Loop
				Else
					nParcela := Max(RF1->RF1_TPARC,1)
				EndIf
			EndIf
			cFilAux := (cAliasSRA)->RA_FILIAL
		EndIf

		aMesRRA := {}

		If Select( "RHHTMP" ) > 0
			dbSelectArea('RHHTMP')
			DbCloseArea()
		EndIf

		If cPaisLoc == "BRA"
			cQuery := "SELECT RHH_FILIAL,RHH_DATA,RHH_MAT,RHH_MESANO,RHH_VB,RHH_CC,RHH_ITEM,RHH_CLVL,RHH_RRA,RHH_IDCMPL,RHH_GRRA,RHH_VERBA,RHH_VALOR,RHH_PROCES,RHH_ROTEIR,R_E_C_N_O_ AS RECNUM"
		Else
			cQuery := "SELECT RHH_FILIAL,RHH_DATA,RHH_MAT,RHH_MESANO,RHH_VB,RHH_CC,RHH_ITEM,RHH_CLVL,RHH_IDCMPL,RHH_VERBA,RHH_VALOR,RHH_PROCES,RHH_ROTEIR,R_E_C_N_O_ AS RECNUM"
		EndIf

		cQuery += "  FROM " + RetSqlName( "RHH" ) + " RHH "
		cQuery += "	WHERE "
		cQuery += " RHH.RHH_FILIAL = '"	+ (cAliasSRA)->RA_FILIAL	+ "' AND  "
		cQuery += "	RHH.RHH_MAT = '"	+ (cAliasSRA)->RA_MAT	+ "' AND  "
		cQuery += "	RHH.RHH_IDCMPL = '"	+ cIdCmpl	+ "' AND  "
		cQuery += " RHH.D_E_L_E_T_ = ' ' "
		cQuery += "	ORDER BY RHH_FILIAL,RHH_MAT,RHH_IDCMPL,RHH_DATA "

		cQuery := ChangeQuery( cQuery )

		dbUseArea( .T., "TOPCONN", TcGenQry( ,,cQuery ), "RHHTMP" )

		If Select( "RHHTMP" ) > 0
			cAliasRHH := 'RHHTMP'
			(cAliasRHH)->(dbGoTop())
		EndIf

		While((cAliasRHH)->(!Eof()))

			If cPaisLoc == "BRA"
				If !(cAliasRHH)->(RHH_RRA) == "1"
					(cAliasRHH)->(dbSkip())
					Loop
				EndIf
			EndIf

			cDtRef := (cAliasRHH)->(RHH_MESANO)

			If (cAliasRHH)->(fGeraRRA(aCodFol,@aRFCGrv,@aMesRRA,RHH_DATA,(cAliasSRA)->RA_FILIAL,(cAliasSRA)->RA_MAT,(cAliasSRA)->RA_CC,RHH_VERBA,RHH_VALOR,nParcela,RHH_IDCMPL,.F.,.T.,dDataPag,cDtRef,@aLogRFC,@aTitleLog,RHH_PROCES,RHH_ROTEIR,RHH_MESANO,	(cAliasSRA)->RA_ITEM,(cAliasSRA)->RA_CLVL,(cAliasSRA)->RA_DEPTO))
				lVazio := .F.
				aAdd(aRecRHH,(cAliasRHH)->(RECNUM))
			EndIf

			(cAliasRHH)->(dbSkip())
		EndDo

		fGeraRRA(aCodFol,@aRFCGrv,@aMesRRA,,(cAliasSRA)->RA_FILIAL,(cAliasSRA)->RA_MAT,(cAliasSRA)->RA_CC,,,nParcela,cIdCmpl,.T.,.T.,dDataPag,cDtRef,@aLogRFC,@aTitleLog,"","","",	(cAliasSRA)->RA_ITEM,(cAliasSRA)->RA_CLVL,(cAliasSRA)->RA_DEPTO)
		aRFCGrv := {}

		(cAliasSRA)->(DbSkip())

	EndDo

	(cAliasSRA)->(DbCloseArea())

	If lVazio
		aAdd(aTitleLog, STR0128) //"Nenhum registro de RRA foi gerado"
		aAdd(aLogRFC,{' '})
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Chama rotina de Log de Ocorrencias. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	fMakeLog(aLogRFC,aTitleLog,,,"DS"+DTOS(dDataBase),STR0073,"M","P",,.F.) //"LOG de Ocorrencias - Dissidio"

	fUpdRHH(aRecRHH)

	RestArea(aArea)

Return Nil
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³fGeraRRA		³ Autor ³ Leandro Drumond   ³ Data ³ 27.06.12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera verbas para RRA.                     				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM690                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Function fGeraRRA(aCodFol,aRFCGrv,aMesRRA,cAnoMes,cFilAux,cMatAux,cCC,cVerba,nValor,nParcela,cIdCmpl,lAtuRFC,lDissidio,dDataPag,cDtRef,aLog,aTitle,cProcesso,cRoteiro,cPeriodo,cItem,cCLVL,cDepto)
	Local aArea			:= GetArea()
	Local cLog			:= ''
	Local nPosTab		:= 0
	Local nLinha		:= 0

	DEFAULT lDissidio := .F.
	DEFAULT dDataPag  := dDataBase
	DEFAULT aLog	  := {}
	DEFAULT aTitle	  := {}

	If Empty(cAnoMes) .and. !Empty(aMesRRA)
		cAnoMes := aMesRRA[Len(aMesRRA)]
	EndIf

	//Carrega tabela de IR para RRA somente se o periodo nao tiver sido carregado
	nLinha := fPosTab( "S034",AnoMes(dDataPag),">=",4,AnoMes(dDataPag),"<=",5 )

	If nLinha > 0 
		nPosTab := Ascan( aTab_Fol, { | X | X[1]+X[4] = "S034"+Strzero(nLinha,3) } )
	EndIf

	If nPosTab == 0
		If Empty(aTitle)
			cLog := STR0129 //"Tabela de IR RRA não encontrada: "
			Aadd(aTitle,cLog)
		EndIf

		cLog := STR0130 + AnoMes(dDataPag) //"Período: "
		If Ascan( aLog, {|x| x[1] == cLog } ) == 0
			aAdd(aLog,{cLog})
		EndIf

		Return .F.
	EndIf

	If aScan( aMesRRA, {|x| x == cAnoMes }) == 0
		aAdd(aMesRRA , cAnoMes )
	EndIf

	If lAtuRFC
		If nPosTab > 0
			fGeraRFC(aCodFol,@aRFCGrv,aTab_Fol[nPosTab],aMesRRA,cFilAux,cCC,lDissidio,cDtRef)
		EndIf
		If lAtuRFC .and. Len(aRFCGrv) > 0
			fGrvRFC(aRFCGrv,nParcela,cFilAux,cMatAux,cCC,cIdCmpl,dDataPag,Len(aMesRRA),cProcesso,cRoteiro,cPeriodo,cItem,cCLVL,cDepto)
		EndIf
		aPd 	:= {}
		aMesRRA := {}
	EndIf

	If !lAtuRFC
		nPos := Ascan(aPd, { |X| X[1] = cVerba .And. X[2] = SRA->RA_CC } )

		If nPos == 0
			fMatriz(cVerba,nValor)
		Else
			aPD[nPos,5] += nValor
		EndIf
	EndIf

	RestArea(aArea)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³fGeraRFC		³ Autor ³ Leandro Drumond   ³ Data ³ 27.06.12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera os registros de RRA para RFC          				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM690                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function fGeraRFC(aCodFol,aRFCGrv,aTabS034,aMesRRA,cFilAux,cCC,lDissidio,cAnoMes)
	Local aArea		:= GetArea()
	Local aCodBenef	:= {}
	Local cVerbAux	:= ''
	Local cPDBenef	:= ''
	Local nX		:= 0
	Local nPos		:= 0
	Local nDifProv	:= 0.00
	Local nDifDesc	:= 0.00

	DEFAULT lDissidio := .F.

	nValor			:= 0.00
	nVal_Peal		:= 0.00
	nVal_Bas		:= 0.00
	nbaseRed 		:= 0.00
	nValIr 			:= 0.00
	nAliq			:= 0.00
	nVal_DedDep 	:= VAL(SRA->RA_DEPIR)

	//Calcula total de proventos e descontos
	For nX := 1 to Len(aPd)
		If (nPos := Ascan(aPdv, { |Y| Y[1] = aPd[nX,1] .and. Y[27] $ "12" })) > 0
			//Validacao para nao descontar o valor de INSS em duplicidade
			If aPdv[nPos,27] == "2" .And. ( aPd[nX,1] == aCodFol[340,1] .Or. aPd[nX,1] == aCodFol[401,1] )
				Loop
			EndIf
			If( aPdv[nPos,27] == "1", nDifProv += aPd[nX,5], nDifDesc += aPd[nX,5] )
		EndIf
	Next nX

	If nDifProv > 0
		//- Dif. Diss. RRA - Provento - ID: 986
		aAdd(aRFCGrv,{aCodFol[986,1],cCC,nDifProv,cAnoMes})
	EndIf

	If nDifDesc > 0
		//- Dif. Diss. RRA - Desconto - ID: 987
		aAdd(aRFCGrv,{aCodFol[987,1],cCC,nDifDesc,cAnoMes})
	EndIf

	aBkCodFol:= aClone(aCodFol)
	fBusCadBenef(@aCodBenef, "FOL",,,,,StoD(aMesRRA[1] + "01"))

	For nX := 1 To Len(aCodBenef)
		cPDBenef += If(lDissidio,RetValSRV(aCodBenef[nX,1],cFilAux,"RV_CODCOM_"),aCodBenef[nX,1]) + "|"
		aEval( aPD , { |x| nVAL_PEAL += IF( x[1] $ cPDBenef .And. x[9] # "D", x[5] , 0.00 ) } )
	Next nX

	/* Calcula verbas de IR para RRA*/
	//Soma Base IR/RRA
	Aeval( aPd ,{ |X| If(x[1] $ cPDBenef , 0, SomaInc(X,5,@nValor,11,"N",12,"N",,,aCodFol) ) } )

	//- Base IR/RRA - ID: 974
	If nValor > 0
		//-- Procura Cod. Base Deducao Previdencia Privada Ferias
		If aCodfol[216,1] # "   "
			cVerbAux := If(lDissidio,RetValSRV(aCodFol[216,1],cFilAux,"RV_CODCOM_"),aCodFol[216,1])
			cVerbAux := If(Empty(cVerbAux),aCodFol[216,1],cVerbAux)
			If RetValSRV(cVerbAux,cFilAux,"RV_IR") == "S"
				Aeval(aPd,{ |X| nValor -= If ( X[1]==aCodFol[216,1] .And. X[9] # "D" ,X[5] ,0)})
			EndIf
			cVerbAux	:= ''
		EndIf

		aAdd(aRFCGrv,{aCodFol[974,1],cCC,nValor,cAnoMes})

		nVal_Bas := nValor
	EndIf

	If !Empty(cPDBenef) // Pensao Alimenticia Folha
		nValor := 0
		Aeval(aPd,{ |X| nValor += If ( X[1]$cPDBenef .And. X[9] # "D" ,X[5] ,0)})
		If nValor > 0
			//- Pensao Aliment. RRA - ID: 976
			aAdd(aRFCGrv,{aCodFol[976,1],cCC,nValor,cAnoMes})
		EndIf
	EndIf

	If aCodFol[064,1] # "   " // INSS
		nValor := 0
		cVerbAux := If(lDissidio,RetValSRV(aCodFol[064,1],cFilAux,"RV_CODCOM_"),aCodFol[064,1])
		cVerbAux := If(Empty(cVerbAux),aCodFol[216,1],cVerbAux)
		Aeval(aPd,{ |X| nValor += If ( X[1]==cVerbAux .And. X[9] # "D" ,X[5] ,0)})
		If nValor > 0
			//- Contr. Previdenciaria RRA - ID: 975
			aAdd(aRFCGrv,{aCodFol[975,1],cCC,nValor,cAnoMes})
		EndIf
		cVerbAux := ''
	EndIf

	If nVal_Bas > 0.00
		CALC_IRRRA(nVal_Bas,nVal_Peal,@nValIr,@nBaseRed,@nVAL_DEDDEP,,aTabS034,.F.,@nAliq,Len(aMesRRA))
		//- Liquido IR/RRA - ID: 977
		aAdd(aRFCGrv,{aCodFol[977,1],cCC,nBaseRed-nValIr,cAnoMes})
		If nValIr > 0
			//- IR/RRA - ID: 978
			aAdd(aRFCGrv,{aCodFol[978,1],cCC,nValIr,cAnoMes})
		EndIf
	EndIf

	/* Calcula verbas de IR 13o para RRA*/
	//Soma Base IR/RRA 13o
	nValor 		:= 0
	nVAL_PEAL 	:= 0
	nVal_Bas	:= 0
	nValIr 		:= 0
	nBaseRed	:= 0
	nAliq		:= 0
	cPDBenef	:= ''

	fBusCadBenef(@aCodBenef, "131",,,,,StoD(aMesRRA[1] + "01"))
	For nX := 1 To Len(aCodBenef)
		cPDBenef += If(lDissidio,RetValSRV(aCodBenef[nX,1],cFilAux,"RV_CODCOM_"),aCodBenef[nX,1]) + "|"
		aEval( aPD , { |x| nVAL_PEAL += IF( x[1] $ cPDBenef .And. x[9] # "D", x[5] , 0.00 ) } )
	Next nX

	fBusCadBenef(@aCodBenef, "132",,,,,StoD(aMesRRA[1] + "01"))
	For nX := 1 To Len(aCodBenef)
		cVerbAux := If(lDissidio,RetValSRV(aCodBenef[nX,1],cFilAux,"RV_CODCOM_"),aCodBenef[nX,1])
		//Se for a mesma verba, nao soma pela segunda vez.
		If !(cVerbAux $ cPDBenef)
			cPDBenef += If(lDissidio,RetValSRV(aCodBenef[nX,1],cFilAux,"RV_CODCOM_"),aCodBenef[nX,1]) + "|"
			aEval( aPD , { |x| nVAL_PEAL += IF( x[1] $ cPDBenef .And. x[9] # "D", x[5] , 0.00 ) } )
		EndIf
	Next nX

	cVerbAux := ''

	//- Base IR/RRA 13o - ID: 979
	Aeval( aPd ,{ |X| If(x[1] $ cPDBenef , 0, SomaInc(X,5,@nValor,12,"S", , , , ,aCodFol) ) })

	If nValor > 0
		//-- Procura Cod. Base Deducao Previdencia Privada
		If aCodfol[302,1]  # "   "
			cVerbAux := If(lDissidio,RetValSRV(aCodFol[302,1],cFilAux,"RV_CODCOM_"),aCodFol[302,1])
			cVerbAux := If(Empty(cVerbAux),aCodFol[216,1],cVerbAux)
			If RetValSRV(cVerbAux,cFilAux,"RV_IR") == "S"
				Aeval(aPd,{ |X| nValor -= If ( X[1]==aCodFol[302,1] .And. X[9] # "D" ,X[5] ,0)})
			EndIf
			cVerbAux := ''
		EndIf

		nVal_Bas := nValor

		aAdd(aRFCGrv,{aCodFol[979,1],cCC,nValor,cAnoMes})

	EndIf

	If aCodFol[070,1] # "   " // INSS 13o
		nValor := 0
		cVerbAux := If(lDissidio,RetValSRV(aCodFol[070,1],cFilAux,"RV_CODCOM_"),aCodFol[070,1])
		cVerbAux := If(Empty(cVerbAux),aCodFol[216,1],cVerbAux)
		Aeval(aPd,{ |X| nValor += If ( X[1]==cVerbAux .And. X[9] # "D" ,X[5] ,0)})
		If nValor > 0
			//- Contr. Previdenciaria 13o RRA - ID: 980
			aAdd(aRFCGrv,{aCodFol[980,1],cCC,nValor,cAnoMes})
		EndIf
		cVerbAux := ''
	EndIf

	If !Empty(cPDBenef) // Pensao Alimenticia 13o
		nValor := 0
		Aeval(aPd,{ |X| nValor += If ( X[1]$cPDBenef .And. X[9] # "D" ,X[5] ,0)})
		If nValor > 0
			//- Pensao Aliment. 13o RRA - ID: 981
			aAdd(aRFCGrv,{aCodFol[981,1],cCC,nValor,cAnoMes})
		EndIf
	EndIf

	If nVal_Bas > 0.00
		CALC_IRRRA(nVal_Bas,nVal_Peal,@nValIr,@nBaseRed,@nVAL_DEDDEP,,aTabS034,.F.,@nAliq,1)

		//- Liquido IR/RRA 13o - ID: 982
		aAdd(aRFCGrv,{aCodFol[982,1],cCC,nBaseRed-nValIr,cAnoMes})

		If nValIr > 0
			//- IR/RRA 13o - ID: 983
			aAdd(aRFCGrv,{aCodFol[983,1],cCC,nValIr,cAnoMes})
		EndIf
	EndIf

	RestArea(aArea)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³fGrvRFC		³ Autor ³ Leandro Drumond   ³ Data ³ 28.06.12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava os registros de RRA na RFC          				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM690                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Function fGrvRFC(aRFCGrv,nParcelas,cFilAux,cMatAux,cCC,cIdCmpl,dDataPag,nMeses,cProcesso,cRoteiro,cPeriodo,cItem,cCLVL,cDepto)

	Local aRFCAux	:= {}
	Local nX 		:= 0
	Local nPos		:= 0
	Local nParc		:= 1
	Local nMesAux	:= 0
	Local nPosDec	:= 0
	Local cMesAux	:= ''
	Local lNewRFC	:= .T.

	DEFAULT dDataPag := dDataBase

	For nX := 1 to Len(aRFCGrv)
		If ( nPos := aScan( aRFCAux,{|x| x[1] == aRFCGrv[nX,1]}) ) == 0
			aAdd(aRFCAux , {aRFCGrv[nX,01] , aRFCGrv[nX,3] , 1 , aRFCGrv[nX,4]} )
		Else
			aRFCAux[nPos,2] += aRFCGrv[nX,3]
			aRFCAux[nPos,3] += 1
		EndIf
	Next nX

	dbSelectArea("RFC")
	RFC->(DbSetOrder(RetOrder("RFC","RFC_FILIAL+RFC_MAT+RFC_IDCMPL+RFC_PD+RFC_CC+RFC_DATARQ+RFC_SEQ")))

	For nX := 1 to Len (aRFCAux)

		nValor 	:= aRFCAux[nX,02] / nParcelas
		nMesAux	:= nMeses * NoRound( nValor / aRFCAux[nX,02])

		/*	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Aplica regra de arredondamento																							³
		³a) menor que 5, permanecera o algarismo da 1a casa decimal;                                                            ³
		³b) maior que 5, sera acrescentada uma unidade ao algarismo da 1a casa decimal;                                         ³
		³c) igual a 5, devera ser analisada a 3a casa decimal da seguinte maneira:                                              ³
		³c1) quando o algarismo estiver compreendido entre 0 e 4 permanecera o algarismo da 1a casa decimal;                    ³
		³c2) quando o algarismo estiver compreendido entre 5 e 9, sera acrescentada uma unidade ao algarismo da 1a casa decimal.³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */

		cMesAux := AllTrim(STR(nMesAux))

		nPosDec := At('.',cMesAux)

		If nPosDec == 0
			nPosDec := At(',',cMesAux)
		EndIf

		If !(nPosDec == 0)
			cMesAux := SubStr(cMesAux,nPosDec+1,Len(cMesAux))
			If Len(cMesAux) > 1
				If !Val(SubStr(cMesAux,2,1) ) == 5
					nMesAux := Round(nMesAux,1)
				Else
					If Len(cMesAux) > 2
						If Val(SubStr(cMesAux,3,1)) >= 5
							nMesAux := Round(nMesAux,1)
						Else
							nMesAux := Val(SubStr(AllTrim(Str(nMesAux)),1,nPosDec+1))
						EndIf
					Else
						nMesAux := Val(SubStr(AllTrim(Str(nMesAux)),1,nPosDec+1))
					EndIf
				EndIf
			Else
				nMesAux := Round(nMesAux,1)
			EndIf
		EndIf

		For nParc := 1 to nParcelas

			lNewRFC := !(DbSeek(cFilAux+cMatAux+cIdCmpl+aRFCAux[nX,01]+cCC+aRFCAux[nX,4]+AllTrim(Str(nParc))))
			RecLock("RFC",lNewRFC)
			RFC->RFC_FILIAL	:= cFilAux
			RFC->RFC_MAT	:= cMatAux
			RFC->RFC_PD		:= aRFCAux[nX,01]
			RFC->RFC_CC		:= cCC
			RFC->RFC_SEQ	:= AllTrim(Str(nParc))
			RFC->RFC_EMPRES	:= cEmpAnt
			RFC->RFC_PARC	:= nParc
			RFC->RFC_MESES	:= nParcelas
			RFC->RFC_VALOR	:= nValor
			RFC->RFC_IDCMPL	:= cIdCmpl
			RFC->RFC_DATARQ	:= aRFCAux[nX,4]
			RFC->RFC_DATPGT	:= dDataPag
			RFC->RFC_RRA	:= "1"
			RFC->RFC_PROCES	:= cProcesso
			RFC->RFC_ROTEIR	:= cRoteiro
			RFC->RFC_PERIOD	:= cPeriodo
			RFC->RFC_ITEM	:= cItem
			RFC->RFC_CLVL	:= cCLVL
			RFC->RFC_DEPTO	:= cDepto

			RFC->(MsUnLock())
		Next nParc
	Next nX

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³fLoadRFC		³ Autor ³ Leandro Drumond   ³ Data ³ 02.07.12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega dados da RFC para o funcionario					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM690                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Static Function fLoadRFC(aRFCGrv,cFilAux,cMatAux,cIdCmpl,cAnoMes)
	Local aArea	:= GetArea()
	Local nPos	:= 0

	DbSelectArea('RFC')
	RFC->(DbSetOrder(RetOrder('RFC','RFC_FILIAL+RFC_MAT+RFC_IDCMPL+RFC_DATARQ')))
	If DbSeek(cFilAux + cMatAux + cIdCmpl + cAnoMes)
		While RFC->(!Eof() .and. RFC_FILIAL + RFC_MAT + RFC_IDCMPL + RFC_DATARQ == cFilAux + cMatAux + cIdCmpl + cAnoMes)
			If ( nPos := aScan( aRFCGrv,{|x| x[1] == RFC_PD}) ) == 0
				aAdd(aRFCGrv,{RFC_PD,RFC_CC,RFC_VALOR,RFC_DATARQ})
			Else
				aRFCGrv[nPos,3] += RFC_VALOR
			EndIf
			DbSkip()
		EndDo
	EndIf

	RestArea(aArea)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³fUpdRHH		³ Autor ³ Leandro Drumond   ³ Data ³ 02.07.12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza registros do RHH		          				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM690                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Static Function fUpdRHH(aRecRHH)
	Local aArea := GetArea()
	Local nX	:= 0

	DbSelectArea('RHH')

	If cPaisLoc == "BRA"
		For nX := 1 to Len(aRecRHH)
			DbGoTo(aRecRHH[nX])
			RecLock('RHH',.F.)
			RHH->RHH_GRRA := '1'
			RHH->(MsUnLock())
		Next nX
	EndIf

	RestArea(aArea)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³fVerPdRRA		³ Autor ³ Leandro Drumond   ³ Data ³ 29.06.12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se as verbas de RRA foram criadas				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM690                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Function fVerPdRRA()
	Local aArea		:= GetArea()
	Local cVerbas	:= "0974, 0975, 0976, 0977, 0978, 0979, 0980, 0981, 0982, 0983, 0986, 0987"
	Local lRet		:= .T.

	DbSelectArea("SRV")
	SRV->(DbSetOrder(2))

	If !DbSeek(xFilial('SRV')+"0974")
		lRet := .F.
	ElseIf !DbSeek(xFilial('SRV')+"0975")
		lRet := .F.
	ElseIf !DbSeek(xFilial('SRV')+"0976")
		lRet := .F.
	ElseIf !DbSeek(xFilial('SRV')+"0977")
		lRet := .F.
	ElseIf !DbSeek(xFilial('SRV')+"0978")
		lRet := .F.
	ElseIf !DbSeek(xFilial('SRV')+"0979")
		lRet := .F.
	ElseIf !DbSeek(xFilial('SRV')+"0980")
		lRet := .F.
	ElseIf !DbSeek(xFilial('SRV')+"0981")
		lRet := .F.
	ElseIf !DbSeek(xFilial('SRV')+"0982")
		lRet := .F.
	ElseIf !DbSeek(xFilial('SRV')+"0983")
		lRet := .F.
	ElseIf !DbSeek(xFilial('SRV')+"0986")
		lRet := .F.
	ElseIf !DbSeek(xFilial('SRV')+"0987")
		lRet := .F.
	EndIf

	If !lRet
		//"Atencao" # "E necessario a criacao das verbas de RRA com os seguintes Identificadores de cálculo: 974, 975, 976, 977, 978, 979, 980, 981, 982, 983"
		Help("", 1, OemToAnsi(STR0019), Nil, STR0119 + " " + cVerbas, 1, 0 )
	EndIf

	RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ModelDef  ºAutor  ³Flavio Correa       º Data ³  24/03/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Definicao do modelo de dados                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function ModelDef()
	Local oModel
	Local oStructSRA
	Local oStructRHH
	Private cMesAnoIni	:= ""
	Private cMesAnoFim	:= ""

	oModel:= MpFormModel():New("GPEM690", /*Pre-Validacao*/, , /*Commit*/, /*bCancel*/)

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Estrutura do Cabecalho - SRA             		                         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	oStructSRA := FWFormStruct(1,"SRA",{|cCampo| AllTrim(cCampo)+"|" $ "RA_FILIAL|RA_MAT|RA_NOME|RA_ADMISSA|"})
	oStructSRA := GP690StrSRA( 1,oStructSRA  )
	oModel:AddFields("GPEM690_MSRA", /*cOwner*/, oStructSRA , /*Pre-Validacao*/,/*Pos-Validacao*/,{|oFieldModel| ViewRHH(oFieldModel,1) }/*Carga*/)
	oModel:GetModel("GPEM690_MSRA"):SetOnlyView( .T. )
	oModel:GetModel("GPEM690_MSRA"):SetOnlyQuery( .T. )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Estrutura do Grid - RHH											     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	oStructRHH := GP690StrRHH(1)//FWFormStruct(1, "RHH")
	oModel:AddGrid("GPEM690_MRHH", "GPEM690_MSRA", oStructRHH,/*bLinePre*/, /* bLinePost*/{|oGrid| Gp690LinOK(oGrid) }, /*bPre*/{|oGrid,nLine,cAction| Gp690VldDel(oGrid,nLine,cAction)},  /*bPost*/{ |oGrid| Gp690Close(oGrid) },{|oGrid| ViewRHH(oGrid,2) }/*bLoad*/)
	oModel:GetModel( "GPEM690_MRHH" ):SetDescription( STR0006 )

	If lValInfo
		oStructRHH:AddTrigger( "VERBORI", "DESCVOR", {|| .T. }, {|oModel| RetValSRV( oModel:GetValue("VERBORI") ,xFilial("SRV"), 'RV_DESC' ) }  )
		oStructRHH:SetProperty("VERBORI", MODEL_FIELD_VALID, { |oModel| ExistCpo("SRV")  })
	EndIf

	//Se não existe o campo novo (requisito de recalculo), não permite inclusão de linha
	oModel:GetModel( "GPEM690_MRHH" ):SetNoInsertLine(!lValInfo)
	oModel:GetModel( "GPEM690_MRHH" ):SetNoDeleteLine(!lValInfo)
	oModel:GetModel( "GPEM690_MRHH" ):SetNoUpdateLine(!lValInfo)
	oModel:GetModel( "GPEM690_MRHH" ):SetOptional(.T.)

	oModel:SetRelation( "GPEM690_MRHH", { { 'RHH_FILIAL', 'xFilial( "RHH" )' }, { 'RHH_MAT', 'RA_MAT' }}, RHH->( IndexKey( 1 ) ) )

	//Se não existe o campo novo (requisito de recalculo), não permite alteração
	If !lValInfo
		oModel:GetModel("GPEM690_MRHH"):SetOnlyView ( .T. )
	EndIf
	oModel:GetModel("GPEM690_MRHH"):SetOnlyQuery( .T. )

Return(oModel)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ViewDef   ºAutor  ³Leandro Drumond     º Data ³  03/04/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Definicao da tela                                 		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function ViewDef()

	Local bVerMedia		:= {|| fMedHist() }
	Local oModel
	Local oStructSRA
	Local oStructRHH
	Local oView

	Private bRecalc		:= {|| If(!IsInCallStack("EDITCELL"), MsAguarde( { || Gp690Recalc(oModel) }, STR0160, STR0161), Nil ) } //"Aguarde..."###"Recalculando Dissídio..."

	oModel:= FwLoadModel("GPEM690")

	oView := FWFormView():New()

	oView:SetModel(oModel)

	oStructSRA := FWFormStruct(2,"SRA",{|cCampo| AllTrim(cCampo)+"|" $ "RA_MAT|RA_NOME|RA_ADMISSA|"})
	oStructSRA:SetNoFolder()
	oStructSRA := GP690StrSRA( 2,oStructSRA  )

	oStructSRA:AddGroup( 'A', OemToAnsi(STR0139) , '', 2 )   	//SRA
	oStructSRA:AddGroup( 'EFD', OemToAnsi(STR0006) , '', 2 )   	//EFD
	oStructSRA:SetProperty( "RA_MAT" , MVC_VIEW_GROUP_NUMBER , 'A' )
	oStructSRA:SetProperty( "RA_NOME" , MVC_VIEW_GROUP_NUMBER , 'A' )
	oStructSRA:SetProperty( "RA_ADMISSA" , MVC_VIEW_GROUP_NUMBER , 'A' )

	oView:AddField( "GPEM690_VSRA" , oStructSRA, "GPEM690_MSRA"  )

	oStructRHH := GP690StrRHH( 2 )//FWFormStruct(2, "RHH")
	oView:AddGrid("GPEM690_VRHH", oStructRHH, "GPEM690_MRHH" )

	oView:CreateHorizontalBox("SRA_HEAD", 35)
	oView:createHorizontalBox("FORMGRID",65)

	oView:SetOwnerView( "GPEM690_VSRA", "SRA_HEAD" )
	oView:SetOwnerView( "GPEM690_VRHH", "FORMGRID" )

	If lValInfo
		oView:addUserButton(STR0162 + " <F6>","MAGIC_BMP", bRecalc, STR0162, VK_F6, {MODEL_OPERATION_UPDATE} ) //"Recalcular"
	EndIf

	oView:addUserButton(OemToAnsi(STR0205), "MAGIC_BMP", bVerMedia, OemToAnsi(STR0206), VK_F4, { MODEL_OPERATION_INSERT, MODEL_OPERATION_UPDATE, MODEL_OPERATION_VIEW } )//"Visualizar Médias <F4>"##"Médias"

	oView:SetOnlyView("GPEM690_VSRA")

	If !lValInfo //Se não existe o campo novo (requisito de recalculo), não permite alteração
		oView:SetOnlyView("GPEM690_VRHH")
	EndIf

	oView:SetCloseOnOk({ || .T. })

	oView:showUpdateMsg(.F.)

	oView:SetViewCanActivate( { |oModel| GPM690VldIni(oModel,oModel:GetOperation()) } )

Return(oView)

//-------------------------------------------------------------------
/*/{Protheus.doc} GP690StrRHH
Estrutura RHH
nTipo 1=Model;2=View
@author Flavio Correa
@since 24/03/14
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function GP690StrRHH( nTipo  )
	Local aArea    := GetArea()
	Local bValid   := Nil
	Local bWhen    := {|| .F. }
	Local bNewWhen := {|oModel| Gp690When(oModel) }
	Local bRelac   := Nil
	Local aTit 		:= {}
	Local nI		:= 1
	Local oStruct
	If nTipo == 1
		oStruct := FWFormModelStruct():New()
	Else
		oStruct :=  FWFormViewStruct():New()
	EndIf

	If lValInfo
		aTit := { 	{ STR0014		,STR0014		   		, 'DATREFE', 'C', 07, 0 , '@R 99/9999' 			, .T., Nil,bNewWhen}, ;	//"Mes Referencia"
					{ STR0082		,STR0082		   		, 'SEMANA' , 'C', 02, 0 , '@!'					, .T., Nil,bNewWhen}, ;	//"Semana"
					{ STR0012		,STR0012		   		, 'VERBORI', 'C', 03, 0 , '@!'	   				, .T., 'SRV',bNewWhen}, ;	//"Verba Origem"
					{ STR0057 + STR0012	,STR0057 + STR0012	, 'DESCVOR', 'C', 20, 0 , '@!'					, .F., Nil,bWhen}, ;	//"Desc. Verba Origem"
					{ STR0015		,STR0015		   		, 'VERBPGT', 'C', 03, 0 , '@!'					, .F., Nil,bWhen}, ;	//"Verba Pagto"
					{ STR0057 + STR0015	,STR0057 + STR0015	, 'DESCVPG', 'C', 20, 0 , '@!'					, .F., Nil,bWhen}, ;	//"Desc. Verba Pagto"
					{ STR0016		,STR0016		   		, 'INDICE' , 'N', 10, 6 , '@E 999.999999'  		, .F., Nil,bWhen}, ;	//"Indice"
					{ STR0013		,STR0013		  		, 'VALORI' , 'N', 12, 2 , '@E 999,999,999.99'	, .F., Nil,bWhen}, ;	//"Valor Origem"
					{ STR0017		,STR0017		  		, 'VALCAL' , 'N', 12, 2 , '@E 999,999,999.99'	, .F., Nil,bWhen}, ;	//"Valor Calculado"
					{ STR0163   	,STR0163				, 'VALINF' , 'N', 12, 2 , '@E 999,999,999.99'	, .T., Nil,{|oModel| oModel:GetValue('VERBORI') <> '000' }}, ;//"Valor Informado"
					{ STR0018		,STR0018		  		, 'VALPAG' , 'N', 12, 2 , '@E 999,999,999.99'	, .F., Nil,bWhen}, ;	//"Valor a pagar"
					{ STR0053		,STR0053		  		, 'COMPL_' , 'C', 01, 0 , '@!'					, .F., Nil,bWhen}, ;	//"Selecionado"
					{ STR0124		,STR0124		  		, 'INTEGR' , 'C', 01, 0 , '@!'					, .F., Nil,bWhen}, ;	//"Geração Folha?"
					{ STR0140		,STR0140		  		, 'ROTEIR' , 'C', 03, 0 , '@!'					, .T., 'SRYDES',bNewWhen},;//"Roteiro Orig."
					{ STR0199		,STR0199		  		, 'DATPGT' , 'D', 08, 0 , ''					, .F., Nil,bWhen},;		//"Data de Pagto"
					{ STR0201		,STR0201		  		, 'MESANO' , 'D', 08, 0 , ''					, .F., Nil,bWhen}}		//"Refer. Pagto"
	Else
		aTit := { 	{ STR0014		,STR0014		   		, 'DATREFE', 'C', 07, 0 , '@R 99/9999' 			}, ;	//"Mes Referencia"
					{ STR0082		,STR0082		   		, 'SEMANA' , 'C', 02, 0 , '@!'					}, ;	//"Semana"
					{ STR0012		,STR0012		   		, 'VERBORI', 'C', 03, 0 , '@!'	   				}, ;	//"Verba Origem"
					{ STR0057 + STR0012	,STR0057 + STR0012	, 'DESCVOR', 'C', 20, 0 , '@!'					}, ;	//"Desc. Verba Origem"
					{ STR0015		,STR0015		   		, 'VERBPGT', 'C', 03, 0 , '@!'					}, ;	//"Verba Pagto"
					{ STR0057 + STR0015	,STR0057 + STR0015	, 'DESCVPG', 'C', 20, 0 , '@!'					}, ;	//"Desc. Verba Pagto"
					{ STR0016		,STR0016		   		, 'INDICE' , 'N', 10, 6 , '@E 999.999999'  		}, ;	//"Indice"
					{ STR0013		,STR0013		  		, 'VALORI' , 'N', 12, 2 , '@E 999,999,999.99'	}, ;	//"Valor Origem"
					{ STR0017		,STR0017		  		, 'VALCAL' , 'N', 12, 2 , '@E 999,999,999.99'	}, ;	//"Valor Calculado"
					{ STR0018		,STR0018		  		, 'VALPAG' , 'N', 12, 2 , '@E 999,999,999.99'	}, ;	//"Valor a pagar"
					{ STR0053		,STR0053		  		, 'COMPL_' , 'C', 01, 0 , '@!'					}, ;	//"Selecionado"
					{ STR0124		,STR0124		  		, 'INTEGR' , 'C', 01, 0 , '@!'					}, ;	//"Geração Folha?"
					{ STR0140		,STR0140		  		, 'ROTEIR' , 'C', 03, 0 , '@!'					}} 		//"Roteiro Orig."
	EndIf


	For nI := 1 To Len(aTit)
		If nTipo = 1
			oStruct:AddField( ;
			aTit[nI][1]               	, ;              // [01] Titulo do campo
			aTit[nI][2]               	, ;              // [02] ToolTip do campo
			aTit[nI][3]           		, ;              // [03] Id do Field
			aTit[nI][4]                 , ;              // [04] Tipo do campo
			aTit[nI][5]                 , ;              // [05] Tamanho do campo
			aTit[nI][6]                 , ;              // [06] Decimal do campo
			bValid                		, ;              // [07] Code-block de validação do campo
			If(lValInfo,aTit[nI][10],bWhen), ;           // [08] Code-block de validação When do campo
			Nil                   		, ;              // [09] Lista de valores permitido do campo
			.F.                   		, ;              // [10] Indica se o campo tem preenchimento obrigatório
			bRelac                		, ;              // [11] Code-block de inicializacao do campo
			NIL                   		, ;              // [12] Indica se trata-se de um campo chave
			.F.							, ;	             // [13] Indica se o campo não pode receber valor em uma operação de update.
			.F.)          		                   		 // [14] Indica se o campo é virtual
		Else

			oStruct:AddField( 			  ;
			aTit[nI][3]         	    , ;              // [01] Campo
			alltrim(strzero(nI,2))      , ;              // [02] Ordem
			aTit[nI][1]                 , ;              // [03] Titulo
			aTit[nI][1]                 , ;              // [04] Descricao
			NIL                    		, ;              // [05] Help
			"GET"                  		, ;              // [06] Tipo do campo   COMBO, Get ou CHECK
			aTit[nI][7]                 , ;              // [07] Picture
										, ;              // [08] PictVar
			If(lValInfo,aTit[nI][9],Nil), ;              // [09] F3
			If(lValInfo,aTit[nI][8],.F.), ;              // [10] Editavel
										, ;              // [11] Folder
										, ;              // [12] Group
										, ;              // [13] Lista Combo
										, ;              // [14] Tam Max Combo
										, ;              // [15] Inic. Browse
			.F.)     		                             // [16] Virtual

		EndIf

	Next nI

	RestArea( aArea )

Return oStruct


//-------------------------------------------------------------------
/*/{Protheus.doc} GP690StrSRA
Estrutura Adicional do Header
nTipo 1=Model;2=View
@author Flavio Correa
@since 24/03/14
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function GP690StrSRA( nTipo,oStruct  )
	Local aArea    	:= GetArea()
	Local bValid   	:= Nil
	Local bWhen    	:= Nil
	Local bRelac   	:= Nil
	Local aTit 		:= {}
	Local nI		:= 1

	aTit := { 	{ OemToAnsi(STR0078)	,OemToAnsi(STR0078)		, 'cVLRAUM', 'N', 12, 2 , '@E 999,999,999.99'	}, ;
				{ OemToAnsi(STR0131)	,OemToAnsi(STR0131)		, 'cTPOAUM', 'C', 03, 0 , '@!'		}, ;
				{ OemToAnsi(STR0132)	,OemToAnsi(STR0132)		, 'cSINDIC', 'C', 03, 0 , '@!'		}, ;
				{ OemToAnsi(STR0133)	,OemToAnsi(STR0133)		, 'cDTACOR', 'D', 8	, 0 , '@!'		}}


	For nI := 1 To Len(aTit)
		If nTipo = 1
			oStruct:AddField( ;
			aTit[nI][1]           , ;              // [01] Titulo do campo
			aTit[nI][2]           , ;              // [02] ToolTip do campo
			aTit[nI][3]           , ;              // [03] Id do Field
			aTit[nI][4]           , ;              // [04] Tipo do campo
			aTit[nI][5]           , ;              // [05] Tamanho do campo
			aTit[nI][6]           , ;              // [06] Decimal do campo
			bValid                , ;              // [07] Code-block de validação do campo
			bWhen                 , ;              // [08] Code-block de validação When do campo
			Nil                   , ;              // [09] Lista de valores permitido do campo
			.F.                   , ;              // [10] Indica se o campo tem preenchimento obrigatório
			bRelac	              , ;              // [11] Code-block de inicializacao do campo
			NIL                   , ;              // [12] Indica se trata-se de um campo chave
			.F.                   , ;              // [13] Indica se o campo não pode receber valor em uma operação de update.
			.F.)          		                   // [14] Indica se o campo é virtual
		Else

			oStruct:AddField( 				      ;
			aTit[nI][3]                 , ;              // [01] Campo
			alltrim(strzero(nI+3,2))  	, ;              // [02] Ordem
			aTit[nI][1]                 , ;              // [03] Titulo
			aTit[nI][1]                 , ;              // [04] Descricao
			NIL                    		, ;              // [05] Help
			"GET"                  		, ;              // [06] Tipo do campo   COMBO, Get ou CHECK
			aTit[nI][7]                 , ;              // [07] Picture
										, ;              // [08] PictVar
										, ;              // [09] F3
			.F.   	               		, ;              // [10] Editavel
										, ;              // [11] Folder
			"EFD"		                , ;              // [12] Group
										, ;              // [13] Lista Combo
										, ;              // [14] Tam Max Combo
										, ;              // [15] Inic. Browse
			.F.)                    	                 // [16] Virtual

		EndIf

	Next nI

	RestArea( aArea )

Return oStruct

//-------------------------------------------------------------------
/*/{Protheus.doc} ViewRHH
Busca dados na RHH
@author Flavio Correa
@since 24/03/14
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function ViewRHH(oGrid,nTipo)
	Local aRet       	:= {}
	Local aArea      	:= GetArea()
	Local aAreaAnt      := RHH->(GetArea())
	Local aCodFol		:= {}
	Local cDescVbOr 	:= ""
	Local cDescVbPg 	:= ""
	Local cMesAnoIni	:= ""
	Local cMesAnoFim	:= ""
	Local nVLRAUM		:= 0
	Local cTPOAUM		:= ""
	Local cSINDIC		:= ""
	Local cDTACOR		:= ""

	cMesAnoIni	:= Right( mv_par01, 4 ) + Left( mv_par01, 2 )
	cMesAnoFim	:= Right( mv_par02, 4 ) + Left( mv_par02, 2 )

	If nTipo == 1
		aRet := FormLoadField(oGrid,.T.)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega cadastro de verbas para posterior filtro						³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Fp_CodFol(@aCodFol,xFilial("SRA", SRA->RA_FILIAL))
		Return aRet
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Alimenta cNotCods com os codigos que nao devem ser listados				³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cNotCods := FiltraVb(aCodFol)
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta matriz de visualizacao.											³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	While RHH->(!Eof()) .and. (RHH->(RHH_FILIAL+RHH_MAT) == SRA->(RA_FILIAL+RA_MAT)) .and. (RHH->RHH_DATA >= cMesAnoIni .and. RHH->RHH_DATA <= cMesAnoFim)
		cDescVbOr := FDESC("SRV",RHH->RHH_VB,"RV_DESC")
		cDescVbOr := If( Empty(cDescVbOr) .and. RHH->RHH_VB == "000", STR0074, cDescVbOr )		//"Salario Base"
		cDescVbOr := If( Empty(cDescVbOr),STR0075, cDescVbOr )									//"** Nao cadastrada **"

		cDescVbPg := FDESC("SRV",RHH->RHH_VERBA,"RV_DESC")
		If RHH->RHH_VB == "000" .AND. Empty(nVLRAUM) 

			nVLRAUM := RHH->RHH_VLRAUM
			cTPOAUM := RHH->RHH_TPOAUM

			If cPaisLoc == "BRA"
				cSINDIC := RHH->RHH_SINDIC
				cDTACOR := RHH->RHH_DTACOR
			EndIf

			If nTipo == 1
				aRet[1,5] := nVLRAUM
				aRet[1,6] := cTPOAUM
				aRet[1,7] := cSINDIC
				aRet[1,8] := cDTACOR
				Exit
			EndIf

		EndIf
		If nTipo == 2 .and. !(RHH->RHH_VB $ cNotCods)
			If lValInfo
				aAdd(aRet,{RHH->( Recno() ),	{  Right(RHH->RHH_DATA,2)+Left(RHH->RHH_DATA,4),RHH->RHH_SEMANA,RHH->RHH_VB,cDescVbOr,RHH->RHH_VERBA,cDescVbPg,RHH->RHH_INDICE,RHH->RHH_VL,RHH->RHH_CALC,RHH->RHH_VALINF, Iif(!Empty(RHH->RHH_VALOR),RHH->RHH_VALOR,0),RHH->RHH_COMPL_, Iif(RHH->RHH_INTEGR#'S','N','S'),RHH->RHH_ROTEIR, RHH->RHH_DTPGT, RHH->RHH_MESANO}})
			Else
				aAdd(aRet,{RHH->( Recno() ),	{  Right(RHH->RHH_DATA,2)+Left(RHH->RHH_DATA,4),RHH->RHH_SEMANA,RHH->RHH_VB,cDescVbOr,RHH->RHH_VERBA,cDescVbPg,RHH->RHH_INDICE,RHH->RHH_VL,RHH->RHH_CALC, Iif(!Empty(RHH->RHH_VALOR),RHH->RHH_VALOR,0),RHH->RHH_COMPL_, Iif(RHH->RHH_INTEGR#'S','N','S'),RHH->RHH_ROTEIR}})
			EndIf
		EndIf

		RHH->(dbSkip())
	Enddo

	If Empty(aRet)
		If lValInfo
			aAdd(aRet,{0,	{ "","","","","","",0,0,0,0, 0,"", "N","",Ctod("//"),""}})
		Else
			aAdd(aRet,{0,	{ "","","","","","",0,0,0, 0,"", "N","" }})
		EndIf
	EndIf
	
	RestArea( aAreaAnt )
	RestArea( aArea )

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} GPM690VldIni
Validação inicial da View
@author Flavio Correa
@since 24/03/14
@version 1.0
/*/
//-------------------------------------------------------------------
Function GPM690VldIni(oModel,nOperacao)
	Local aArea		:= GetArea()
	Local lRet		:= .T.
	Local cMesAnoIni	:= ""
	Local cMesAnoFim	:= ""

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega Perguntas para Periodo a Ser Visualizado.			 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !IsInCallStack("BUTTONOKACTION")
		If !Pergunte( "GPCR04", .T. )
			Return .F.
		EndIf
	EndIf

	cMesAnoIni	:= Right( mv_par01, 4 ) + Left( mv_par01, 2 )
	cMesAnoFim	:= Right( mv_par02, 4 ) + Left( mv_par02, 2 )

	If Empty( mv_par01 ) .or. Empty( mv_par02 )
		//"Atencao" # "Preencha o periodo de calculo do dissidio" # "Data em branco"
		Help("", 1, OemToAnsi(STR0019), Nil, STR0062, 1, 0 )
		Return .F.
	EndIf

	cMesAnoIni	:= Right( mv_par01, 4 ) + Left( mv_par01, 2 )
	cMesAnoFim	:= Right( mv_par02, 4 ) + Left( mv_par02, 2 )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o calculo foi executado.									³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea( "RHH" )
	RHH->(dbSetOrder( 2 ))			// RHH_FILIAL+RHH_MAT+RHH_DATA+RHH_MESANO+RHH_VB+RHH_CC+RHH_ITEM+RHH_CLVL

	RHH->( dbGoTop() )

	// Na visualizacao procura a partir do primeiro registro que encontrar
	// referente ao ANO do dissidio do funcionario posicionado
	RHH->(dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cMesAnoIni, .T. ))

	If RHH->(Eof()) .or. ( SRA->(RA_FILIAL+RA_MAT) # RHH->(RHH_FILIAL+RHH_MAT) ) .or. RHH->RHH_DATA < cMesAnoIni .or. RHH->RHH_DATA > cMesAnoFim
		//"Atencao"##"Nao foi executado o calculo do dissidio retroativo"##"Ok"
		Help("", 1, OemToAnsi(STR0019), Nil, STR0024, 1, 0 )
		Return .F.
	EndIf
	RestArea(aArea)
Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³ TrataPerg  ³ Autor ³ Flavio Correa           ³ Data ³ 21/03/2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Separa oRange De ATE dos pergunte		         		  	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM690                                                    	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Static Function TrataPerg(cPervar,cVar01,cVar02)
	Local aTemp := {}
	If ";" $ cPervar
		aTemp := Separa(cPervar,";")
		If Len(atemp) == 1
			cVar01 :=   aTemp[1]
			cVar02 :=   aTemp[1]
		ElseIf Len(aTemp) == 2
			cVar01 :=   aTemp[1]
			If !EMpty(aTemp[2])
				cVar01 :=  aTemp[2]
			Else
				cVar02 :=  cVar01
			EndIf
		EndIf
	EndIf
	If "-" $ cPervar
		aTemp := Separa(cPervar,"-")
		If Len(atemp) == 1
			cVar01 :=   aTemp[1]
			cVar02 :=   aTemp[1]
		ElseIf Len(aTemp) == 2
			cVar01 :=   aTemp[1]
			If !EMpty(aTemp[2])
				cVar02 :=  aTemp[2]
			Else
				cVar02 :=  cVar01
			EndIf
		EndIf
	EndIf
If (Empty(cVar01) .and. empty(cVar02)) .and. !EMpty(cPervar)
	cVar01 :=  cPervar
	cVar02 :=  cPervar
EndIf

Return

/*/{Protheus.doc} Gpem690Rot
Validação do roteiro e carga das demais perguntas
@author Leandro Drumond
@since 04/01/17
@version 1.0
/*/
Function Gpem690Rot(cProcesso)
	Local aPerAtual	:= {}
	Local cRotCalc 	:= &( ReadVar() )
	Local cPerg		:= ""

	DEFAULT lTemCCT := cPaisLoc == "BRA" .and. RCE->(ColumnPos("RCE_CCT")) > 0

	cPerg	:= If(lTemCCT,'GPCR13','GPCR12')

	If Empty(cRotCalc)
		Return .T.
	EndIf

	If Empty(cProcesso)
		Help( ' ', 1, 'GPER20PROC' )
		Return .F.
	EndIf

	If !fGetPerAtual( @aPerAtual, cFilRCJ, cProcesso, cRotCalc )
		HELP( " ",1,"GPCALEND",  )
		Return(.F.)
	Else
		SetMVValue(cPerg,"MV_PAR01",cProcesso)
		SetMVValue(cPerg,"MV_PAR02",cRotCalc)
		SetMVValue(cPerg,"MV_PAR03",aPerAtual[1,1])
		SetMVValue(cPerg,"MV_PAR04",aPerAtual[1,2])

		Pergunte(cPerg,.F.)
	EndIf

Return .T.

/*/{Protheus.doc} Gp690Trf
Validação da transferencia de processos no cálculo do Dissídio para carga dos dados nos acumulados
@author Marcelo Silveira
@since 20/02/18
@version 1.0
/*/
Function Gp690Trf(cFilDis, cMatDis, cPerDis )

	Local cFilAux		:= SRA->RA_FILIAL
	Local cMatAux		:= SRA->RA_MAT
	Local cPrcAux		:= SRA->RA_PROCES
	Local nX			:= 0
	Local nNumTRF		:= 0
	Local aArea	 	    := {}
	Local aAreaSRD	    := {}
	Local aTransf	 	:= {}
	Local aDados	 	:= {}

	fTransfAll( @aTransf,,,.T.)
	aSort(aTransf,,,{|x,y| x[7]>y[7]} ) //Ordena a partir da transferencia mais recente

	nNumTRF := Len(aTransf)

	If nNumTRF > 0
		aArea       := GetArea()
		aAreaSRD    := SRD->( GetArea() )
        SRD->( DBSetOrder(5) )//RD_FILIAL+RD_MAT+RD_PROCES+RD_ROTEIR+RD_PERIODO+RD_SEMANA+RD_PD
        
        For nX := 1 to nNumTRF
			If aTransf[nX,1] == aTransf[nX,4] //Nao houve transferencia entre empresas
				//Houve alteracao de Filial, Matricula ou Processo
				If ( MesAno(aTransf[nX,7]) > cPerDis .And. !( aTransf[nX,08] == aTransf[nX,10] .And. aTransf[nX,09] == aTransf[nX,11] .And. aTransf[nX,14] == aTransf[nX,15]) ) .Or.;
                    ( cTipoRot == "6" .And. MesAno(aTransf[nX,7]) == cPerDis .And. SRD->( !DBSeek( SRA->RA_FILIAL + SRA->RA_MAT + cProcesso + cRot + cPeriodo ) ) )
					If cTipoRot != "3"
						cFilAux := aTransf[nX,08]
						cMatAux := aTransf[nX,09]
						cPrcAux := aTransf[nX,14]
					Else
						cFilAux	:= aTransf[nx,10]
						cMatAux	:= aTransf[nx,11]
						cPrcAux := aTransf[nX,15]
						Exit
					EndIf
				EndIf
			EndIf
		Next nX
        
        RestArea( aAreaSRD )
        RestArea( aArea )
	EndIf

	aDados := { cFilAux, cMatAux, cPrcAux }

Return( aDados )

/*/{Protheus.doc} fGP690Per
Valida os periodos de calculo das demais filiais que serao processadas no dissidio.
Obs.: a pergunta Filial no dissidio e do tipo Range, entao foi criada uma query retornar os periodos das filiais selecionadas.
Porem, a RCH pode ser exclusiva ou nao, entao vinculamos com a SRA para restringir a consulta usando a expressao SQL da pergunta Filial
@author Marcelo Silveira
@since 16/04/18
@version 1.0
/*/
Static Function fGP690Per(cRoteiro)

Local cFilJoin	:= ""
Local cWhere	:= ""
Local cAliasRCH	:= "QRCH"
Local aFilRCH	:= {}

//Tratamento abaixo devido ao problema do embedded SQL nao converter clausula "SUBSTRING" no INNER JOIN
//ao usar banco de dados ORACLE. E segundo sustentacao FRAMEWORK, devemos alterar consulta SQL
cFilJoin := "% " + FWJoinFilial("SRA","RCH") + " %"

cFilJoin := If( TCGETDB() $ 'DB2|ORACLE|POSTGRES|INFORMIX', STRTRAN(cFilJoin, "SUBSTRING", "SUBSTR"), cFilJoin )

If !Empty( MV_PAR08 )
	cWhere += MV_PAR08 + " AND "
EndIf
cWhere += "RCH_PROCES = '" + cProcesso + "' AND "
cWhere += "RCH_PER = '" + cMesAnoCalc + "' AND "
cWhere += "RCH_NUMPAG = '" + cSemPag + "' AND "
cWhere += "RCH_ROTEIR = '" + cRoteiro + "' AND "
cWhere := "%" + cWhere + "%"

BeginSQL Alias cAliasRCH
	SELECT DISTINCT RCH_FILIAL, RCH_PER, RA_PROCES, RCH_DTFECH, RA_FILIAL
	FROM %table:RCH% RCH
	INNER JOIN %table:SRA% SRA
	ON RCH_PROCES = RA_PROCES AND %exp:cFilJoin%
	WHERE %exp:cWhere%
	RCH.%notDel% AND SRA.%notDel%
	ORDER BY RCH_FILIAL, RCH_PER, RA_PROCES
EndSQL

If (cAliasRCH)->( !EOF() )
	While (cAliasRCH)->(! EOF())
		aAdd( aFilRCH, { (cAliasRCH)->RCH_FILIAL, (cAliasRCH)->RCH_DTFECH, (cAliasRCH)->RA_FILIAL, RCH_PER } )
		(cAliasRCH)->( dbSkip() )
	EndDo
EndIf

(cAliasRCH)->(dbCloseArea())

Return( aFilRCH )

/*/{Protheus.doc} Gp690Close
Fecha a tela sem perguntar se deseja salvar
@author Leandro Drumond
@since 15/05/19
@version 1.0
/*/
Static Function Gp690Close(oGrid)
Local lRet		:= .T.
Local lDissInf	:= .F.
Local aAlter	:= oGrid:GetLinesChanged()
Local nX		:= 0

For nX := 1 to Len(aAlter)
	oGrid:Goline(aAlter[nX])
	If !oGrid:IsDeleted()//Linha excluída
		lDissInf := .T.
		Exit
	EndIf
Next nX

If lDissInf
	If !MsgYesNo( STR0164 , STR0165 ) //"As alterações não serão gravadas sem a execução do recálculo." ### "Encerrar mesmo assim?"
		Help( ,, STR0019,, STR0166 , 1 )	//"Atencao" #### "Cancelado pelo usuário."
		lRet := .F.
	EndIf
EndIf

Return lRet

/*/{Protheus.doc} Gp690VldDel
Valida se linha pode ser excluída. Apenas linhas incluídas no grid podem ser excluídas, as linhas calculadas pelo sistema não podem ser apagadas.
@author Leandro Drumond
@since 14/05/19
@version 1.0
/*/
Static Function Gp690VldDel(oGrid,nLine,cAction)
Local lRet	:= .T.

If cAction == "DELETE" .and. ( !oGrid:IsInserted() .and. !Empty(oGrid:GetValue("VALORI")))
	Help(" ","1","NODELETA")
	lRet := .F.
EndIf

Return lRet

/*/{Protheus.doc} Gp690LinOk
Valida linha incluída
@author Leandro Drumond
@since 14/05/19
@version 1.0
/*/
Static Function Gp690LinOK(oGrid)
Local lRet			:= .T.
Local cPdAux		:= ""
Local cSemAux		:= ""
Local cDtAux		:= ""
Local cDtAux2		:= ""
Local cDtAux3		:= ""
Local cRotAux		:= ""
Local cDatIni		:= "999999"
Local cDatFim		:= "000000"
Local nValInf		:= 0
Local nValCal		:= 0
Local nLinAtual		:= oGrid:GetLine()
Local nX			:= 0

If lValInfo
	nValInf := oGrid:GetValue("VALINF")
	nValCal := oGrid:GetValue("VALCAL")
	If oGrid:IsInserted() //Validação de nova linha
		cPdAux  := oGrid:GetValue("VERBORI")
		cSemAux := oGrid:GetValue("SEMANA")
		cDtAux2	:= oGrid:GetValue("DATREFE")
		cDtAux	:= AllTrim(oGrid:GetValue("DATREFE"))
		cDtAux  := Right( cDtAux, 4 ) + Left( cDtAux, 2 )
		cRotAux := oGrid:GetValue("ROTEIR")

		Begin Sequence
			If Empty(cPdAux) .or. cPdAux == "000" .or. Empty(RetValSRV( cPdAux,xFilial("SRV"), 'RV_DESC' ))
				lRet := .F.
				Help( ,, STR0019,, STR0167, 1,,,,,,, {STR0168} )	//"Atencao" #### "Verba de Origem não informada ou inválida."  ### "Preencha a verba de origem com uma verba válida."
				Break
			EndIf
			For nX := 1 to oGrid:Length()
				If nX <> nLinAtual
					oGrid:GoLine(nX)
					If !oGrid:IsDeleted() .and. oGrid:GetValue("VERBORI") == cPdAux .and. AllTrim(oGrid:GetValue("DATREFE")) == AllTrim(cDtAux2) .and. oGrid:GetValue("SEMANA") == cSemAux .and. oGrid:GetValue("ROTEIR") == cRotAux
						lRet := .F.
						Help( ,, STR0019,, STR0169 , 1,,,,,,, {STR0170} )	//"Atencao" ### "Verba informada já existe no grid, não poderá ser incluída outra." ### "Efetue a alteração da verba já existente."
						oGrid:GoLine(nLinAtual)
						Break
					EndIf
					cDtAux3 := AllTrim(oGrid:GetValue("DATREFE"))
					cDtAux3 := Right( cDtAux3, 4 ) + Left( cDtAux3, 2 )
					If cDtAux3 < cDatIni
						cDatIni := cDtAux3
					EndIf
					If cDtAux3 > cDatFim
						cDatFim := cDtAux3
					EndIf
				EndIf
			Next nX
			oGrid:GoLine(nLinAtual)
			If Empty(cDtAux) .or. cDtAux > cDatFim .or. cDtAux < cDatIni
				lRet := .F.
				Help( ,, STR0019,, STR0173 , 1,,,,,,, {STR0174} )	//"Atencao" ### "Data de referência não informada ou fora do range de cálculo." ### "Informe uma data de referência equivalente ao período consultado."
				Break
			EndIf
			If Empty(cSemAux)
				lRet := .F.
				Help( ,, STR0019,, STR0171 , 1,,,,,,, {STR0172} )	//"Atencao" ### "Semana não foi informada" ### "Informe a semana de cálculo."
				Break
			EndIf
			If Empty(cRotAux) .or. Empty(fGetTipoRot(cRotAux))
				lRet := .F.
				Help( ,, STR0019,, STR0175 , 1,,,,,,, {STR0176} )	//"Atencao" ### "Código do roteiro não informado ou inexistente." ### "Informe um roteiro de cálculo válido."
				Break
			EndIf
			If Empty(nValInf)
				lRet := .F.
				Help( ,, STR0019,, STR0177 , 1,,,,,,, {STR0178} )	//"Atencao" ### "Valor do lançamento não foi informado." ### "Informe um valor para o campo 'Valor Informado'."
				Break
			EndIf
		End Sequence
	Else
		cPdAux  := oGrid:GetValue("VERBORI")
		If nValInf > 0 .and. cPdAux $ fGetCodFol( "0013" ) + "/" + fGetCodFol( "0019" ) + "/" + fGetCodFol( "0064" ) + "/" + fGetCodFol( "0065" ) + "/" + fGetCodFol( "0070" )  //Base INSS e INSS
			MsgInfo(STR0190,STR0019) //"A alteração do INSS deve ser efetuado tanto na verba de base quanto na de desconto. O sistema não irá recalcular o valor informado em apenas uma das verbas."
		ElseIf cPdAux $ fGetCodFol( "0018" ) + "/" + fGetCodFol( "0109" ) .and. nValInf > 0 //FGTS
			lRet := .F.
			Help( ,, STR0019,, STR0191 , 1,,,,,,, {STR0192} )	//"Atencao" ### "A alteração desta verba não surirá efeito no cálculo." ### "Deve ser alterada a verba de base do FGTS para que o sistema recalcule."
		EndIf
	EndIf
EndIf

Return lRet

/*/{Protheus.doc} Gp690When
Se estiver incluindo uma nova linha, permite a edição de determinados campos
@author Leandro Drumond
@since 14/05/19
@version 1.0
/*/
Static Function Gp690When(oGrid)

Return oGrid:IsInserted()

/*/{Protheus.doc} Gp690Recalc
Efetua recalculo do dissídio com base nas verbas informadas
@author Leandro Drumond
@since 14/05/19
@version 1.0
/*/
Static Function Gp690Recalc(oModel)
Local aArea		:= GetArea()
Local aItens	:= {}
Local aDatAux	:= {}
Local aPerAtual	:= {}
Local cIdCompl	:= ""
Local cTpAum	:= ""
Local cDatarq	:= ""
Local cDatAux	:= ""
Local cPdAux	:= ""
Local cSemAux	:= ""
Local cRotAux	:= ""
Local cMesAnoIni:= ""
Local cMesAnoFim:= ""
Local dDtAcor	:= CtoD("")
Local lTemInf	:= .F.
Local oGrid		:= oModel:GetModel( 'GPEM690_MRHH' )
Local nTamGrid	:= oGrid:Length()
Local nPercAux	:= 0
Local nValAux	:= 0
Local nX		:= 0
Local nVlrAum	:= oModel:GetModel("GPEM690_MSRA"):GetValue("cVLRAUM")
Local lBase		:= .F.
Local lDesc		:= .F.

Pergunte( "GPCR04", .F. )

cMesAnoIni	:= Right( mv_par01, 4 ) + Left( mv_par01, 2 )
cMesAnoFim	:= Right( mv_par02, 4 ) + Left( mv_par02, 2 )

DEFAULT lTemCCT := cPaisLoc == "BRA" .and. RCE->(ColumnPos("RCE_CCT")) > 0

Private	cPerg	:= If(lTemCCT,'GPCR13','GPCR12')

fGetPerAtual( @aPerAtual, xFilial("RCJ"), SRA->RA_PROCES, fGetCalcRot("1") )

If Empty(aPerAtual)
	HELP( " ",1,"GPCALEND",  )
	Return(.F.)
EndIf

aDissInf := {}

For nX := 1 to nTamGrid
	oGrid:GoLine(nX)
	If (!oGrid:IsDeleted() .and. ( oGrid:GetValue("VALINF") > 0 .OR. oGrid:IsFieldUpdated("VALINF") ) ) .OR. (oGrid:IsDeleted() .and. !Empty(oGrid:GetValue("VALCAL"))) //Indica que uma verba infomada foi calculada e agora esta sendo excluída.
		cDatarq := AllTrim(oGrid:GetValue("DATREFE"))
		cDatAux := Right( cDatarq, 4 ) + Left( cDatarq, 2 )
		If cDatAux >= cMesAnoIni .and. cDatAux <= cMesAnoFim
			cPdAux  := oGrid:GetValue("VERBORI")
			cSemAux := oGrid:GetValue("SEMANA")
			cRotAux := oGrid:GetValue("ROTEIR")
			nValAux := oGrid:GetValue("VALINF")
		 	If Ascan( aDatAux, {|x| x == cDatarq}) == 0
		 		aAdd(aDatAux, cDatarq)
		 	EndIf
		 	If !oGrid:IsDeleted() //Só inclui a verba que não estiver deletada
		 		aAdd(aDissInf,{SRA->RA_FILIAL,SRA->RA_MAT,cRotAux,Right(cDatarq,4)+Left(cDatarq,2),cSemAux,cPdAux,nValAux,"I", oGrid:GetValue("DATPGT")}) //Carrega mnemonico
		 	EndIf
		 	lTemInf := .T.

			lBase := nValAux > 0 .and. cPdAux $ fGetCodFol( "0013" ) + "/" + fGetCodFol( "0019" )
			lDesc := nValAux > 0 .and. cPdAux $ fGetCodFol( "0064" ) + "/" + fGetCodFol( "0065" ) + "/" + fGetCodFol( "0070" )  //Base INSS e INSS
		 EndIf
	EndIf
Next nX

If lTemInf .And. ((lBase .And. !lDesc) .Or. (!lBase .And. lDesc))
	If !MsgYesNo(STR0190,STR0194) //"A alteração do INSS deve ser efetuado tanto na verba de base quanto na de desconto. O sistema não irá recalcular o valor informado em apenas uma das verbas."
		Return .F.
	EndIf
EndIf

If !lTemInf
	MsgAlert(STR0179)//"O recálculo não será efetuado pois não existem alterações no cálculo original."
	Return .F.
EndIf

aSort(aDatAux,,,{|x,y| x < y})

RHH->(DbSetOrder(1)) //RHH_FILIAL+RHH_MAT+RHH_MESANO+RHH_DATA+RHH_VB+RHH_CC+RHH_ITEM+RHH_CLVL+RHH_SEMANA+RHH_SEQ+RHH_ROTEIR

If RHH->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + aPerAtual[1,1] + Right(aDatAux[1],4)+Left(aDatAux[1],2) + "000"))
	nPercAux := RHH->RHH_INDICE
	cIdCompl := RHH->RHH_IDCMPL
	cTpAum	 := RHH->RHH_TPOAUM
	dDtAcor	 := RHH->RHH_DTACOR
EndIf

SetMVValue(cPerg,"MV_PAR01",SRA->RA_PROCES)
SetMVValue(cPerg,"MV_PAR02",fGetCalcRot("1"))
SetMVValue(cPerg,"MV_PAR03",aPerAtual[1,1])
SetMVValue(cPerg,"MV_PAR04",aPerAtual[1,2])
SetMVValue(cPerg,"MV_PAR05",aDatAux[1])
SetMVValue(cPerg,"MV_PAR06",aDatAux[Len(aDatAux)])
SetMVValue(cPerg,"MV_PAR07",2)
SetMVValue(cPerg,"MV_PAR08",SRA->RA_FILIAL)
SetMVValue(cPerg,"MV_PAR09",'')
SetMVValue(cPerg,"MV_PAR10",SRA->RA_MAT)
SetMVValue(cPerg,"MV_PAR11",'')
SetMVValue(cPerg,"MV_PAR12"," ADFT")
SetMVValue(cPerg,"MV_PAR13","ACDEGHIJMPST***")

SetMVValue(cPerg,"MV_PAR15","")
SetMVValue(cPerg,"MV_PAR16",dDtAcor)
SetMVValue(cPerg,"MV_PAR17",1)
SetMVValue(cPerg,"MV_PAR18",0.0)
SetMVValue(cPerg,"MV_PAR19",2)
SetMVValue(cPerg,"MV_PAR20","12")
SetMVValue(cPerg,"MV_PAR21",0.0)
SetMVValue(cPerg,"MV_PAR22","")
SetMVValue(cPerg,"MV_PAR23",cIdCompl)
SetMVValue(cPerg,If(lTemCCT,"MV_PAR25","MV_PAR14"),cTpAum)

Pergunte(cPerg,.F.) //Grava as informações

Pergunte(cPerg,.T.) //Abre o grupo de perguntas para conferência

aAdd(aItens, {"SALDE", 0.01})						// Faixa De
aAdd(aItens, {"SALATE", 9999999999.99})				// Faixa Ate
aAdd(aItens, {"VALFIX", nVlrAum})					// Valor Aumento
aAdd(aItens, {"ADMISSADT1", SRA->RA_ADMISSA})		// Data Admissao de
aAdd(aItens, {"ADMISSADT2", SRA->RA_ADMISSA})		// Data Admissao Ate
aAdd(aItens, {"SALPERC", nPercAux})					// % Aumento

If GP690Cal(,aItens,.T.) //Efetua o cálculo

	RHH->( dbSetOrder( 2 ) )
	RHH->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cMesAnoIni ) )

	Pergunte( "GPCR04", .F. )

	oModel:DeActivate()
	oModel:Activate()
EndIf

//Restaura hotkey
SetKey(VK_F6, {||bRecalc})

RestArea(aArea)

Return .T.

/*/{Protheus.doc} fDissInf
Inclui as verbas informas no aPd
@author Leandro Drumond
@since 16/05/19
@version 1.0
/*/
Function fDissInf()

Local aAreaRHH	:= RHH->( GetArea() )
Local lItemClVl	:= GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "13"
Local nX		:= 0
Local nPos		:= 0
Local nPosAux	:= 0

If Len(aDissInf) > 0 .and. ( nPosAux := aScan( aDissInf, { |x| x[1]+x[2]+x[4]+x[5] == SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + cSemana } ) ) > 0
	For nX := nPosAux to Len(aDissInf)
		If ( nPos := aScan( aPd, { | X | SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + cSemana + X[1] == aDissInf[nX,1] + aDissInf[nX,2] + aDissInf[nX,4] + aDissInf[nX,5] + aDissInf[nX,6] .And. (Empty(aDissInf[nX,9]) .or. x[10] == aDissInf[nX,9] ) } ) ) > 0
			If cRot == aDissInf[nX,3] .or. ( cTipoRot == "3" .and. RetValSRV( aDissInf[nX,6],SRA->RA_FILIAL, 'RV_REFFER' ) == "S" )
			 	If aDissInf[nX,8] <> "X" .or. nX == 1 .or. aScan( aDissInf, { |x| x[1]+x[2]+x[4]+x[5]+x[6]+x[8] == SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + cSemana + aDissInf[nX,6] + "I" } ) == 0
					aPd[nPos,4] := 0
					aPd[nPos,5] := aDissInf[nX,7]
					aPd[nPos,6] := "V"
					aPd[nPos,7] := "I"
				EndIf
			EndIf
		ElseIf SRA->RA_FILIAL + SRA->RA_MAT == aDissInf[nX,1] + aDissInf[nX,2] .and. ( cTipoRot == "3" .or. cPeriodo + cSemana == aDissInf[nX,4] + aDissInf[nX,5] )
			If cRot == aDissInf[nX,3] .or. ( cTipoRot == "3" .and. RetValSRV( aDissInf[nX,6],SRA->RA_FILIAL, 'RV_REFFER' ) == "S" .And. SRH->RH_DTRECIB == aDissInf[nX,9] )
				fGeraVerba(aDissInf[nX,6], aDissInf[nX,7], 0, aDissInf[nX,5], Nil, "V", "I", Nil, Nil, aDissInf[nX,9])
			EndIf
		ElseIf SRA->RA_FILIAL + SRA->RA_MAT <> aDissInf[nX,1] + aDissInf[nX,2]
			Exit
		EndIf
	Next nX
EndIf

//Verificação de cálculos realizados para o período em outra database
dbSelectArea( "RHH" )
RHH->(dbSetOrder( 2 ))	// RHH_FILIAL + RHH_MAT + RHH_DATA + RHH_MESANO + RHH_VB + RHH_CC + RHH_ITEM + RHH_CLVL
If dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo )
	While RHH->( !Eof() ) .And. RHH->RHH_FILIAL+RHH->RHH_MAT+RHH->RHH_DATA == SRA->RA_FILIAL+SRA->RA_MAT+cPeriodo
		If RHH->RHH_MESANO != cMesAnoCalc .And. RHH->RHH_INTEGR == "S" .And. RHH->RHH_VB != "000" .And. cRot == RHH->RHH_ROTEIR .And. ( nPos := aScan(aPdOld, { |x| x[1]+x[2]+x[3]+x[11] == RHH->RHH_VB+RHH->RHH_CC+RHH->RHH_SEMANA+RHH->RHH_SEQ .And. Iif(lItemClVl, x[13]+x[14] == RHH->RHH_ITEM+RHH->RHH_CLVL, .T.) }) ) > 0
			aPdOld[nPos, 5] += RHH_VALOR
		EndIf
		RHH->( dbSkip() )
	Enddo
Endif

RestArea( aAreaRHH )

Return Nil

/*/{Protheus.doc} fArqDiss
Seleciona o arquivo para importação de valores informados para o dissídio
@author Leandro Drumond
@since 06/06/19
@version 1.0
/*/
Function fArqDiss()
Local mvRet := Alltrim(ReadVar())
Local cFile := ''

oWnd   := GetWndDefault()

cFile  := cGetFile(STR0180, STR0181) //"Arquivos CSV|*.csv" ### "Selecione o arquivo para importação de valores informados"

&(mvRet) := cFile

If( oWnd != Nil, 	GetdRefresh(), Nil)

Return( .T. )

/*/{Protheus.doc} fLoadCSV
Carrega informações do arquivo CSV
@author Leandro Drumond
@since 07/06/19
@version 1.0
/*/
Static Function fLoadCSV(cArquivo,aDissInf)
Local aArea		:= GetArea()
Local aAreaSRA	:= SRA->(GetArea())
Local aErroAux	:= {}
Local aDados	:= {}
Local cLine		:= ""
Local cFilAux	:= ""
Local cPdFGTS 	:= fGetCodFol( "0018" ) + "/" + fGetCodFol( "0109" )
Local cPdINSS   := fGetCodFol( "0013" ) + "/" + fGetCodFol( "0019" ) + "/" + fGetCodFol( "0064" ) + "/" + fGetCodFol( "0065" ) + "/" + fGetCodFol( "0070" )
Local cMesAnoDe	:= SubStr( MV_PAR05, 3, 4 ) + SubStr( MV_PAR05, 1, 2 )
Local cMesAnoAte:= SubStr( MV_PAR06, 3, 4 ) + SubStr( MV_PAR06, 1, 2 )
Local nHandle	:= 0
Local nLinha	:= 0
Local nX		:= 0
Local nPos		:= 0
Local lBuscaAnt	:= .F.

Begin Sequence

	If File(cArquivo)

		nHandle := FT_FUse(cArquivo)

		// Se houver erro de abertura abandona processamento
		If nHandle = -1
			aAdd(aErroAux, STR0182) //"Falha na abertura do aquivo. "
			Break
		EndIf

		FT_FGoTop()

		While !FT_FEOF()

			cLine  := FT_FReadLn() // Retorna a linha corrente
			nLinha++

		    If Empty( Strtran( cLine , ";" ) )
		    	aAdd(aErroAux, STR0183 + AllTrim(Str(nLinha)) + " - " + cLine) //"Linha inválida: "
		    	Loop
		    EndIf

		    aAdd( aDados , StrTokArr2( cLine, ";") )

			FT_FSKIP()
		EndDo

		// Fecha o Arquivo
		FT_FUSE()

		lBuscaAnt := aScan( aDissInf, { |x| x[8] == "X" } ) > 0 //Performance, só fara buscas se já houver registros importados anteriormente
		SRA->( dbSetOrder(1) )

		For nX := 1 to Len(aDados)
			cFilAux := Padr(aDados[nX,1],FWGETTAMFILIAL)
			If !SRA->(DbSeek(cFilAux+aDados[nX,2]))
		    	aAdd(aErroAux, STR0184 + cFilAux + " - " + aDados[nX,2] + " / " + STR0185 + AllTrim(Str(nX))) //"Funcionário inexistente: " ### "Linha: "
		    	Loop
			EndIf
			If !SRV->(DbSeek(xFilial("SRV",cFilAux) + aDados[nX,6]))
				aAdd(aErroAux, STR0186 + cFilAux + " - " + aDados[nX,6] + " / " + STR0185 + AllTrim(Str(nX))) //"Verba inválida: " ### "Linha: "
				Loop
			EndIf
			If aDados[nX,4] < cMesAnoDe .or. aDados[nX,4] > cMesAnoAte
				aAdd(aErroAux, STR0187 + aDados[nX,4] + " / " + STR0185 + AllTrim(Str(nX)))  //"Período diferente do calculado: "###"Linha: "
				Loop
			EndIf
			If Val(aDados[nX,7]) <= 0
				aAdd(aErroAux, STR0188 + aDados[nX,7] + " / " + STR0185 + AllTrim(Str(nX))) //"Valor informado deve ser maior que zero: "###"Linha: "
				Loop
			EndIf

			If aDados[nX,6] $ cPdINSS  //Base INSS e INSS
				aAdd(aErroAux, STR0190 + " / " + STR0185 + AllTrim(Str(nX))) //"A alteração do INSS deve ser efetuado tanto na verba de base quanto de desconto. O sistema não irá recalcular o valor informado em apenas um das verbas."###"Linha: "
			EndIf
			If aDados[nX,6] $ cPdFGTS //FGTS
				aAdd(aErroAux, STR0193 + " / " + STR0185 + AllTrim(Str(nX))) //"A alteraçao da verba de FGTS não surtirá efeito no cálculo. Deve ser alterado a verba de base de FGTS para que o sistema efetue o recálculo."
				Loop
			EndIf
			If lBuscaAnt .and. ( nPos := aScan( aDissInf, { |x| x[1]+x[2]+x[3]+x[4]+x[5]+x[6]+x[8] == cFilAux+aDados[nX,2]+aDados[nX,3]+aDados[nX,4]+aDados[nX,5]+aDados[nX,6] + "X" } ) ) > 0
				aDissInf[nPos,7] := Val(aDados[nX,7])
			Else
				aAdd(aDissInf, {cFilAux, aDados[nX,2], aDados[nX,3], aDados[nX,4], aDados[nX,5], aDados[nX,6], Val(aDados[nX,7]), "X", cToD("//")})
			EndIf

		Next nX
	EndIf

End Sequence

If !Empty(aErroAux)
	aAdd(aErrProc[1], STR0189 + cArquivo) //"Log do arquivo de valores informados: "
	aAdd(aErrProc[2], aErroAux)
EndIf

RestArea(aAreaSRA)
RestArea(aArea)

Return Nil

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ChangeNew ³ Autor ³                       ³ Data ³03/01/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Abrir tabelas para Consulta via Tecla F3                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cEmp - Empresa de Destino                                  ³
³          ³ cFil - Filial  de Destino                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function ChangeNew(uAliasNewEmp, cEmp, cFil)
    Local nX        := 0
    Local cModo     := ""
    Local cAliaAux    := ""

    fOpenSx2(cEmp)
    FWClearXFilialCache()

    For nX := 1 to Len(uAliasNewEmp)
        cAliaAux:= uAliasNewEmp[nX]
        UniqueKey( NIL , cAliaAux , .T. )
        EmpOpenFile(cAliaAux,cAliaAux,1,.T.,cEmp,@cModo)
    Next Nx

Return( .T. )

/*/{Protheus.doc} fOpenSx2
Função para abrir a SX2 de outra empresa
@author Rafael Reis
@since 29/12/2017
/*/
Static Function fOpenSx2(cEmp)
    Local lOk    :=    .T.

    SX2->(DBCloseArea())
    OpenSxs(,,,,cEmp,"SX2","SX2",,.F.)
    lOk := !(Select("SX2") == 0)

Return lOk

/*/{Protheus.doc} Gp690FilCCT
Filtra sindicatos de acordo com a CCT selecionada
@author Leandro Drumond
@since 08/04/2022
/*/
Function Gp690FilCCT()
Local cFiltro		:= ""
Local cCodCCT		:= If(IsInCallStack("GPER200"),MV_PAR16,If(nTpPerg == 1 .or. IsInCallStack("GP690RECALC"), MV_PAR14, If(nTpPerg == 2, MV_PAR08, MV_PAR19)))

If(!Empty(cCodCCT),	cFiltro := " RCE->RCE_CCT == '" + cCodCCT + "' ", Nil)

cFiltro := "@#" + cFiltro + "@#"

Return(cFiltro)

/*/{Protheus.doc} fLoadSind
Carrega os sindicatos de acordo com o código da CCT
@author Leandro Drumond
@since 08/04/2022
/*/
Static Function fLoadSind(cCodCCT)
Local aArea			:= GetArea()
Local cRet 			:= ""
Local cAliasRCE		:= GetNextAlias()

BeginSQL Alias cAliasRCE
	SELECT RCE_CODIGO
	FROM %table:RCE% RCE
	WHERE RCE.RCE_CCT = %Exp:cCodCCT% AND 
	RCE.%notDel% 
	ORDER BY RCE_FILIAL, RCE_CODIGO
EndSQL

If (cAliasRCE)->( !Eof() )
	While (cAliasRCE)->(! Eof())
		cRet += If(!Empty(cRet), ",", "")
		cRet += "'" + (cAliasRCE)->RCE_CODIGO + "'"
		(cAliasRCE)->( dbSkip() )
	EndDo
EndIf

(cAliasRCE)->(dbCloseArea())

RestArea(aArea)

Return cRet

/*/{Protheus.doc} fMedHist
Verifica se há histórico de médias para impressão
@author Allyson Luiz Mesashi
@since 16/01/2023
/*/
Static Function fMedHist()

Local aAreaRJK		:= RJK->( GetArea() )
Local cPerIni		:= SubStr( MV_PAR01, 3, 4 ) + SubStr( MV_PAR01, 1, 2 )
Local cPerFim		:= SubStr( MV_PAR02, 3, 4 ) + SubStr( MV_PAR02, 1, 2 )
Local lTemHist		:= .F.
Local lverSV	    := FindFunction("fConfigSV")

DEFAULT cRotVerDiss	:= fGetCalcRot("3")+"/"+fGetCalcRot("6")

RJK->( dbSetOrder(1) )//RJK_FILIAL+RJK_PROCES+RJK_MAT+RJK_PERIOD+RJK_SEMANA+RJK_ROTEIR+DTOS(RJK_DTREF)+RJK_DISSI

While cPerIni <= cPerFim
	If RJK->( dbSeek( SRA->RA_FILIAL+SRA->RA_PROCES+SRA->RA_MAT+cPerIni )  )
		While RJK->( !EoF() ) .And. RJK->RJK_FILIAL+RJK->RJK_PROCES+RJK->RJK_MAT+RJK->RJK_PERIOD == SRA->RA_FILIAL+SRA->RA_PROCES+SRA->RA_MAT+cPerIni
			If RJK->RJK_ROTEIR $ cRotVerDiss .And. RJK->RJK_DISSI == "1"
				lTemHist := .T.
				Exit
			EndIf
			RJK->( dbSkip() )
		End
	EndIf
	If lTemHist
		Exit
	EndIf	
	cPerIni := SomaMesAno( cPerIni )
End

If lTemHist
	If lverSV .And. fConfigSV()
		IF !fCallMediaSV("I", SToD(cPerIni+"01"), SToD(cPerFim+"01"))
			fVerHistMed( Nil, Nil, Nil, .T., cPerIni, cPerFim )
		EndIf
	Else		
		fVerHistMed( Nil, Nil, Nil, .T., cPerIni, cPerFim )
	EndIf	
Else
	Aviso( STR0019, STR0207 )//Atenção##"Sem dados para imprimir!"
EndIf

RestArea( aAreaRJK )

Return

/*/{Protheus.doc} SchedDef
Definiç?es de agendamento do Schedule.
@author Maria Luísa de Souza Arcanjo Bastos
@since 11/02/2025
/*/
Static Function SchedDef()

    Local aParam As Array
    // Inicializaç?o das variáveis
    aParam := {}

    // Montagem da estrutura do vetor de retorno
    AAdd(aParam, "P")       // Tipo do agendamento: "P" = Processo | "R" = Relatório
    AAdd(aParam, "GPEM690") // Pergunte (SX1) (usar "PARAMDEF" caso n?o tenha conjunto de perguntas)
    AAdd(aParam, "")        // Alias principal (exclusivo para relatórios)
    AAdd(aParam, {})        // Vetor de ordenaç?o (exclusivo para relatórios)
    AAdd(aParam, "")        // Título (exclusivo para relatórios)

Return aParam
