#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEA1100.CH"
#INCLUDE "FONT.CH"
#INCLUDE "COLORS.CH"
#INCLUDE "HEADERGD.CH"

Static lBloqPON		:= ("2" $ SuperGetMv( "MV_BLOQPON",,"" ))
Static lGP100CHK	:= ExistBlock( "GP100CHK" )
Static lGP100Ok		:= ExistBlock( "GP100OK" )
Static lGP100ALT	:= ExistBlock( "GP100ALT" )
Static lIntegDef 	:= FindFunction("GETROTINTEG") .And. FindFunction("FWHASEAI")
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ gpea100  ³ Autor ³ M. Stiefano         			  ³ Data ³ 19.10.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cadastro Valores Variaveis por C¢digo			                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                  			                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL. 			            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ FNC 			 ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Leandro Dr. ³07/11/12³M12RH01_RQ0008  |Unificacao da folha.                      ³±±
±±³Raquel Hager|20/09/13|M12RH01-196001  |Inclusao da funcao fVldAccess na funcao   ³±±
±±³            |        |                |Gp100LinOk para vld de per. bloqueado.    ³±±
±±³Sidney O.   |08/04/14|M_RH007   TPCBNG|Alteracao da funcao GP100F3 - Filtro      ³±±
±±³            |        |                |dos elementos da consulta padrao.         ³±±
±±³            |        |                |Alteracao da expressao top/bottom da      ³±±
±±³            |        |                |consulta padrao em Gp100TopSXB            ³±±
±±³Esther V.   |22/04/14|    M_RH003     |Replica V11 para V12. Tratamento do para- ³±±
±±³            |        |                |metro MV_ITMCLVL para aceitar '3', nao    ³±±
±±³            |        |                |obrigando o preenchimento dos campos.     ³±±
±±³Raquel Hager|25/07/14|TPZMHB		      |Correcao no bloco bGotFocus do perg. ROT. ³±±
±±³Esther V.   |26/09/14|    TQPYXX      |Tratameno na funcao GpValidPer() para     ³±±
±±³            |        |                |verificar existencia do objeto antes      ³±±
±±³            |        |                |de modifica-lo.                           ³±±
±±³PHILIPE     |09/04/15|    TPPAI7      |Adicionadas as opções de Atualização e     ±±
±±³POMPEU      |        |                |Visualização de Lançamentos natabela RGB no±±
±±³            |        |                |menu Outras Opções. Criada função ChamaRGB.±±
±±³Gustavo M.  |08/06/15|    TSMNFS      |Ajuste no posicionamento do F3 de funcion  ±±
±±³Emerson Camp|09/06/15|    TSNSIJ      |Alterar ALIAS RC por RGB na função GP100STR±±
±±³Mariana M.  |15/10/15|    TSYHHA      |Efetuado ajuste no filtro da função Gp100F3±±
±±³            |        |                |para que ele busque filial + processo e não±±
±±³            |        |                |somente o processo						 ±±
±±³Allyson M.  |07/12/15|    TTXJN2      |Efetuado ajuste no filtro da GetDados p/   ±±
±±³            |        |                |apenas listar os lancamentos de filiais que±±
±±³            |        |                |o usuario logado tem acesso,				 ±±
±±³Flavio C.    |16/02/16|    TUHAQJ      |Ajuste p/ validar data de referencia de   ³±±
±±³             |        |                |acordo com a configuracao de RV_LCTODIA	 ³±±
±±³Renan Borges|02/03/16|    TUMJG1      |Ajuste para integrar os lançamentos mensa-³±±
±±³            |        |                |is corretamente, independentemente se o   ³±±
±±³            |        |                |funcionário já possui lançamentos.        ³±±
±±³Gustavo M.   |13/03/16|    TUNXUL      |Ajuste no bloqueio do lançamento.		 ³±±
±±³Raquel Hager |22/06/16|TVAIZA          |Remoção de opções de Manutenção/Cálculo  ³±±
±±³             |        |                |nas rotinas de consulta.                 ³±±
±±³Raquel Hager |29/06/16|TVFOB3 		  |Aumento do limite de linhas na GetDados. ³±±
±±³Esther V.    |01/08/16|    TVOJVI      |Alterada funcao Gp100F3 que cria filtro  ³±±
±±³             |        |                |do campo RGB_MAT. Permitido alterar campo³±±
±±³             |        |                |RGB_FILIAL. Incluida validacao de acesso.³±±
±±³Cícero Alves |17/08/16|TVMYBA	      |Alterada funcao GPValMatRGB para procurar³±±
±±³             |        |                |a mesma matricula em filiais diferentes  ³±±
±±³Esther V.    |17/08/16|    TVVHM2      |Inclusao dos PEs GP100OK e GP100ALT.     ³±±
±±³Cícero Alves |25/10/16|TVZZCJ	      |Ajuste para que o ponto de entrada 		³±±
±±³             |        |                |GP100CHK seja executado ao salvar 		³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gpea100

Local cFiltraSRV:= 'SRV->RV_FILIAL == "' + xFilial("SRV") + '"' 	//Variavel para filtro
Local bFiltro := { || &(cFiltraSRV) }

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define Variaveis Private                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private aCRA		:= { STR0001 , STR0002 , STR0003}  //"Confirma"###"Redigita"###"Abandona"
Private aColsAnt	:= {}
Private bFiltraBrw	:= {|| NIL }		//Variavel para Filtro
Private cDigLancam	:= Upper( AllTrim( GetMv("MV_DIGLANC") ) )
Private cDigHoras	:= Upper( AllTrim( GetMv("MV_HORASDE") ) )
Private cLancDemi	:= Upper( AllTrim( GetMv("MV_DEMISRC") ) )
Private lInclu		:= .F.
Private lSRCLock	:= .F.
Private aArray      := {}
Private cLancAlias  := "SRC"
Private lGetFilial	:= .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define array contendo as Rotinas a executar do programa      ³
//³ ----------- Elementos contidos por dimensao ------------     ³
//³ 1. Nome a aparecer no cabecalho                              ³
//³ 2. Nome da Rotina associada                                  ³
//³ 3. Usado pela rotina                                         ³
//³ 4. Tipo de Transa‡„o a ser efetuada                          ³
//³    1 - Pesquisa e Posiciona em um Banco de Dados             ³
//³    2 - Simplesmente Mostra os Campos                         ³
//³    3 - Inclui registros no Bancos de Dados                   ³
//³    4 - Altera o registro corrente                            ³
//³    5 - Remove o registro corrente do Banco de Dados          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private aRotina := MenuDef() // ajuste para versao 9.12 - chamada da funcao MenuDef() que contem aRotina

cCadastro := OemToAnsi(STR0009)  //"Lancamentos Valores Verba"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o Arquivo Esta Vazio                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !ChkVazio("SRV")
	Return( NIL )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa o filtro utilizando a funcao FilBrowse                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aArray := {"SRV","SRA", "SRC" }
ffiltro("GPEA100",aArray, 2)

//-> So executara o filtro no primeiro elemento do array
ffiltro("GPEA100",aArray, 1 /* Exec Filtro*/, 1 /*Inicio*/, 1/*Fim*/)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Endereca a funcao de BROWSE                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SRV")
SRV->(DbSetfilter( bFiltro, cFiltraSRV ))
mBrowse( 6, 1,22,75,"SRV")


dbSelectArea("SRC")
dbSetOrder(1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Deleta todos os filtros utilizando a funcao FilBrowse       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ffiltro("GPEA100",aArray,0)//0- Limpa os filtros

Return
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp100Mnt  ³ Autor ³ Mauro			        ³ Data ³ 28.11.05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de alteracao de Valores Variaveis                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Gp100Alt(ExpC1,ExpN1,ExpN2)                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do Arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Opcao selecionada no menu                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gp100Mnt(cAlias,nReg,nOpcx)

Local cDesc      	:= SRV->RV_DESC
Local nCnt			:= 0
Local nSavRec		:= 0.00
Local cFilSrv		:= xFilial("SRV")
Local cPrefixo      := ""
Local aGrupos		:= UsrRetGrp( cUserName )
Local lRet := .T.

Private aSRCCols	:= {}		// vetor com os registros
Private cCond		:= "1"
Private cRot		:= ""
Private cLctoDiario	:= SRV->RV_LCTODIA
Private cProcesso
Private cMatricula	:= Space(6)
Private cPeriodo
Private cSemana
Private cNumPagto	:= ""
Private cRoteiro
Private cRoteiroAnt
Private cDataPer
Private cProcessoAnt
Private cPeriodoAnt
Private cSemanaAnt
Private oGet
Private aHeader	:= {}	   		// vetor com o cabecalho da GetDados SRC
Private nSRCUsado	:= 0.00		// variavel que retorna a quantidade de campos da tabela
Private aSRCVirtGd	:= {}		// vetor com os campos virtuais
Private aSRCVisualGD:= {}		// vetor com os campos visuais
Private aSRCColsRec	:= {}		// vetor que contem os Recnos da tabela
Private aGhColsRec	:= {}
Private aGhCols		:= {}
Private lSetF3		:= .F.		//Variavel para saber se passou no f3 da matricula
Private aIndexSrv	:= {}
Private nSRVPos
Private lItemClVl	:= SuperGetMv("MV_ITMCLVL ",NIL,"2")  $ "1*3"   //variavel que define se os campos "Item Contabil" e Classe de Valor" estão ativos
Private cCod       	:= SRV->RV_COD
Private nValLanc	:= 0
Private cKeyRCH 	:= ""
Private cCodUser 	:= RetCodUsr()
Private cGrupos		:= ""
Private lExiMsgPl   := .T.

Private nModAuto	:= 1

aColsAnt			:= {}
If Type("lGetFilial") == "U"
	_SetOwnerPrvt( 'lGetFilial', .F. )
EndIf
_SetOwnerPrvt( "nOpcNewGd", IF( nOpcX == 2 .or. nOpcX == 5 , 0 , GD_INSERT + GD_UPDATE + GD_DELETE))

nSavRec          := RecNo()
nValLanc         := 0.00
nValCalc         := 0.00
cAlias           := cLancAlias
cPrefixo         := ( PrefixoCpo( cAlias ) + "_" )

aEval( aGrupos , { |x| ( cGrupos += ( x + "/" ) ) } )

Begin Sequence

	//-- Ponto de entrada p/ verificar se pode fazer manutencao
	If lGP100CHK
		lRet := ExecBlock( "GP100CHK", .F., .F., {cCodUser, cGrupos, SRV->RV_COD} )
		If !lRet
			Break
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se a Verba esta' autorizada a Receber Lancamentos   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF !fNoLancPD( SRV->RV_COD )
		dbGoTo( nSavRec )
		Return( NIL )
	EndIF

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existe algum registros no Arquivo                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ! Empty(cFilSrv)
		dbSelectArea(cAlias)
		( cAlias )->( dbSetOrder( RetOrdem( cAlias , cPrefixo+"FILIAL+"+cPrefixo+"PD+"+cPrefixo+"PROCES+"+cPrefixo+if(cAlias=="SRC","PERIODO+","PERIOD+")+cPrefixo+"ROTEIR" ) ) )
		If dbSeek( (xFilial(cAlias)) + cCod )
			nCnt ++
		Endif
	Else
		dbSelectArea(cAlias)
		(cAlias)->( dbSetOrder( RetOrdem( cAlias , cPrefixo+"PD+"+cPrefixo+"PROCES+"+cPrefixo+if(cAlias=="SRC","PERIODO+","PERIOD+")+cPrefixo+"ROTEIR" ) ) )
		If dbSeek( cCod )
			nCnt ++
		Endif
	Endif


	nSRVPos:= SRV->(Recno())

	//Seleciona periodo aberto
	cRoteiro 	:= fGetRotOrdinar()		// traz o roteiro padrao
	cProcesso 	:= gp240RetCont("RCH", 1, xFilial("RCH"), "RCH_PROCES", "Empty(RCH->RCH_DTFECH)")
	cFilterRot 	:= If( !Empty(cRoteiro), ".AND. ( RCH->RCH_ROTEIR == '" + cRoteiro + "')", "")
	cPeriodo  	:= gp240RetCont("RCH", 1, xFilial("RCH") + cProcesso, "RCH_PER"	, "Empty(RCH->RCH_DTFECH) .AND. (RCH->RCH_PROCES == '" + cProcesso + "') " + cFilterRot )
	If Empty( cPeriodo )
		cFilterRot 	:= ""
		cPeriodo  	:= gp240RetCont("RCH", 1, xFilial("RCH") + cProcesso, "RCH_PER"	, "Empty(RCH->RCH_DTFECH) .AND. (RCH->RCH_PROCES == '" + cProcesso + "')" + cFilterRot )
	EndIf
	cNumPagto 	:= gp240RetCont("RCH", 1, xFilial("RCH") + cProcesso, "RCH_NUMPAG"	, "Empty(RCH->RCH_DTFECH) .AND. (RCH->RCH_PROCES == '" + cProcesso + "')" + cFilterRot )
	If Empty(cRoteiro)
		cRoteiro	:= gp240RetCont("RCH", 1, xFilial("RCH") + cProcesso, "RCH_ROTEIR"	, "Empty(RCH->RCH_DTFECH) .AND. (RCH->RCH_PROCES == '" + cProcesso + "')" + cFilterRot )
	EndIf
	cPeriodoAnt	:= cPeriodo
	cSemana := cSemanaAnt	:= cNumPagto


	If ( Empty(cPeriodo) .and. Empty(cPeriodoAnt) )
		MsgAlert( OemToAnsi(STR0039), OemToAnsi(STR0030) ) //"Não existe período cadastrado!" //"Atencao"
		Break
	EndIf
	If !( lSRCLock := Gpea100Locks( nOpcx , cAlias ) )
		Break
	EndIf
	aSRCCols:={}
	aColsAnt:={}
	gp100MontaGetDados(cCod, cAlias, @aSRCCols, nOpcx, .F.)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Mostra Tela para Informar Total do Lan‡amento MV_DIGLANC="S" ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 If cDigLancam == "S"
		fTotLanc()
	 Endif

	nOpcA := 0

	gp100Tela(cCod, cDesc, cAlias, nOpcx, @aSRCCols)

	SetaPilha()

	//-- Ponto de entrada criado para alteracao dos registros gravados
	If lRet .and. lGP100ALT
	   ExecBlock("GP100ALT",.F.,.F.)
	EndIf

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Libera Locks						                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If ( lSRCLock )
	FreeLocks( cAlias , NIL , .T. )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a integridade da janela                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea(cAlias)
dbSetOrder(1)
cAlias := "SRV"
dbSelectArea(cAlias)
dbGoTo( nSavRec )

nOpcA := 0

Return( nOpcA )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³                                                                       ³±±
±±³                                                                       ³±±
±±³                   ROTINAS DE CRITICA DE CAMPOS                        ³±±
±±³                                                                       ³±±
±±³                                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp100Grava³ Autor ³ M. Stiefano           ³ Data ³ 19.10.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava no arquivo de Valores Variaveis                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Gp100Grava                                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gp100Grava(cCod, cAlias, nOpcx, lMontaGetDados, lPerg)

Local lTudoIgual	:= .F.
Local nHorDec		:= 0.00
Local nHor1			:= 0.00
Local nX			:= 0.00
Local nY			:= 0.00
Local nRegAltera	:= 0.00
Local cPrefixo      := ( PrefixoCpo( cAlias ) + "_" )
Local nPosSeq		:= GdFieldPos( cPrefixo+"SEQ", aHeader )
Local xConteudo
Local lRetorno		:= .T.
Local aColsDel		:= {}
Local aRecDel		:= {}
Local lRet			:= .T.
Local nPosRegWT     := GdFieldPos( cPrefixo+"REC_WT"	, aHeader)
Local nLinAnt		:= 0
Private cCampo		:= ""

aSRCCols		:= ( oGet:aCols )

//Esta alteracao foi feita para compatibilizar o modo de exclusao
//conforme o nOpcx passado pela rotina GPEA590
If ( FunName() == "GPEA590" .and. nOpcx == 4 )
	nOpcx := 5
EndIf

//-- Ponto de entrada p/ verificar se pode fazer manutencao
If lGP100CHK
	lRet := ExecBlock( "GP100CHK", .F., .F., {cCodUser, cGrupos, SRV->RV_COD} )
Endif

If lRet
	Begin Transaction

		If ( nOpcx == 5 )

			If !( Gp090VldDel(@cKeyRCH,nOpcx) )
		        lRetorno := .F.
			EndIf
			// A funcao Gp100Grava e' chamada na inclusao, alteracao e exclusao atraves
			// do botao bSet15 ou quando o usuario trocar a chave de pesquisa (processo e
			// periodo). No modo excluir, podera ser realizada a exclusao somente quando a
			// funcao Gp100Grava for chamada atraves do botao bSet15 (lVerAlt = .F.).
			If lRetorno .And. !lMontaGetDados .And. Len( aSRCColsRec ) > 0
				// Exclui os registros do processo/periodo selecionado.
				PonDelRecnos( cAlias , aSRCColsRec )
				EvalTrigger()
			EndIf
		Else
			IF !fCompArray( aSRCCols , aColsAnt )
				// Se teve alteracao em algum registro e o usuario mudou o processo ou periodo,
				// sera feita a pergunta se deseja salvar as alteracoes antes da tela ser
				// remontada com as novas chaves informadas.
				If (lPerg)
					If !(MsgYesNo( OemToAnsi( STR0019 ) ) )	//"Deseja salvar as alteracoes?"
						DisarmTransaction()//Finaliza transacao para nao ficar pendente
						gp100MontaGetDados(cCod, cAlias, @aSRCCols, nOpcx, .F.)

						Break
					EndIf
				EndIf

				dbSelectArea(cAlias)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Por causa da sequencia foi separado os registros deletados ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				GdSplitDel( aHeader , @aSRCCols , aSRCColsRec , @aColsDel , @aRecDel)

				If !Empty(aRecDel)
					For nX := 1 To Len(aRecDel)
						( cAlias )->( dbGoto( aRecDel[nX] ) )
						RecLock(cAlias,.F.,.T.)
						If aColsDel[nX,nSRCUsado+1]
							( cAlias )->( dbDelete() )
						Endif
		 				(cAlias)->( MsUnlock() )
			        Next
			    Endif

				If !Empty( aSRCColsRec )   .AND. Len(aHeader) > 0
					nRegAltera := Len(aSRCColsRec)
					For nX := 1 To nRegAltera

						If !aSRCCols[nX,nSRCUsado+1] .and. ( lTudoIgual := fCompArray( aSRCCols[nX] , aColsAnt[nX]  ) )
							Loop
						Endif

						( cAlias )->( dbGoto( aSRCColsRec[nX] ) )
						RecLock(cAlias,.F.,.T.)

						If aSRCCols[nX,nSRCUsado+1]
							( cAlias )->( dbDelete() )
						Else
							For nY := 1 To Len(aHeader)
								cCampo := AllTrim(aHeader[nY,2])

								/* Os campo horas e valor serao gravados no momento da gravacao
								dos campos horinfo e valinfo. */
								If cAlias == "SRC"
									If cCampo == (cPrefixo+"HORAS") .OR. cCampo ==(cPrefixo+"VALOR")
									    Loop
									EndIf
								EndIf

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Se MV_HORASDE = "S" e Campo RC_HORINFO Converte Horas 		   ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If cDigHoras == "S" .And. (cCampo == cPrefixo+"HORINFO" .or. cCampo == cPrefixo+"HORAS")
									nHorDec := aSRCCols[nX,nY]
									nHor1 := nHorDec - Int(nHorDec)
									nHor1 := ( nHor1 / 60 ) * 100
									nHor1 := Round( Int(nHorDec) + nHor1 , 2 )
									xConteudo := nHor1
								Else
									xConteudo := aSRCCols[nX,nY]
								Endif

								&cCampo := xConteudo

							    /*Gravar em horas e valor o mesmo valor informado em horinfo e
							    valinfo. */
					 		    If cCampo == (cPrefixo+"HORINFO")
									&(cPrefixo+"HORAS") := xConteudo
							    ElseIf cCampo == (cPrefixo+"VALINFO")
				    				&(cPrefixo+"VALOR") := xConteudo
							    EndIf

							Next nY
							//Se Teve Apenas alteracao na sequencia de lancamento nao altera o Flag de Origem
							For nY := 1 To Len( aSRCCols[ nX ] )
								lTudoIgual := .T.
								IF !( nY == nPosSeq )

									// Linha/Posição ocupada no aCols antes da ALTERAÇÃO - faz a busca pelo recno.
									nLinAnt := aScan( aColsAnt, { |x| ( x[nPosRegWT] == aSRCCols[ nX , nPosRegWT ] ) } )

									IF !( lTudoIgual := nLinAnt == 0 .Or. aSRCCols[ nX , nY ] == aColsAnt[ nLinAnt , nY ] )
										(cAlias)->(&(cPrefixo+"TIPO2")) := "I"
										Exit
									EndIF
								EndIF
							Next nY
						Endif
		 				(cAlias)->( MsUnlock() )
					Next nX
					If Len(aSRCCols) > nRegAltera  // Se Trata de Inclusao de Itens
						Gp100GrInc( cAlias , nRegAltera+1,cCod )
					Endif
				Else
					Gp100GrInc( cAlias , 1, cCod )
				Endif

				// Remonta a tela
				If ( lMontaGetDados )
					gp100MontaGetDados(cCod, cAlias, @aSRCCols, nOpcx, .F.)
				EndIf
			EndIf

			If (lIntegDef)
				SetRotInteg("GPEA090")
				FwIntegDef("GPEA090")
			EndIf

		EndIf

		//Se excluiu algum item integrado, retirada a data de integração do roteiro
		If !Empty(cKeyRCH)
			RCH->(DbSetOrder(1))//RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR
			If RCH->(DbSeek(cKeyRCH))
				RecLock("RCH",.F.)
				RCH->RCH_DTINTE := CtoD("")
				RCH->(MsUnLOck())
			EndIf
		EndIf
	End Transaction
EndIf

Return(lRetorno)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp100LinOk³ Autor ³ M. Stiefano           ³ Data ³ 19.10.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Critica linha digitada                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gp100LinOk(o)

Local lRet			:= .T.
Local cTipo1		:= " "
Local cTipo2		:= " "
Local nHoras		:= 0.00
Local nValorC		:= 0.00
Local nHorasC		:= 0.00
Local nValor		:= 0.00
Local nCont			:= 0.00
Local cPrefixo		:= ( PrefixoCpo( cLancAlias ) + "_" )
Local nPosFil		:= GdFieldPos( cPrefixo+"FILIAL", aHeader)
Local nPosMa		:= GdFieldPos( cPrefixo+"MAT"	, aHeader)
Local nPosCC		:= GdFieldPos( cPrefixo+"CC"	, aHeader)
Local nPosSe		:= GdFieldPos( cPrefixo+"SEMANA", aHeader)
Local nPosSq		:= GdFieldPos( cPrefixo+"SEQ"	, aHeader)
Local nPosTp1		:= GdFieldPos( cPrefixo+"TIPO1"	, aHeader)
Local nPosTp2		:= GdFieldPos( cPrefixo+"TIPO2"	, aHeader)
Local nPosItem		:= GdFieldPos( cPrefixo+"ITEM"	, aHeader)
Local nPosClvl		:= GdFieldPos( cPrefixo+"CLVL"	, aHeader)
Local nPosHor		:= If(cLancAlias=="SRC", GdFieldPos("RC_HORINFO", aHeader),GdFieldPos("RGB_HORAS", aHeader))
Local nPosVal		:= If(cLancAlias=="SRC", GdFieldPos("RC_VALINFO", aHeader),GdFieldPos("RGB_VALOR", aHeader))
Local nPosHorC		:= GdFieldPos( cPrefixo+"HORAS"	, aHeader)
Local nPosValC		:= GdFieldPos( cPrefixo+"VALOR"	, aHeader)
Local nPosMat		:= GdFieldPos( cPrefixo+"MAT"	, aHeader)
Local nPosDtRef		:= GdFieldPos( cPrefixo+"DTREF"	, aHeader)
Local nPosRegWT     := GdFieldPos( cPrefixo+"REC_WT"	, aHeader)
Local nPosFun   	:= If(cLancAlias=="SRC", GdFieldPos("RC_CODFUNC", aHeader), GdFieldPos("RGB_CODFUN", aHeader) )
Local aCriterio		:= {}
Local nPosIN		:= GdFieldPos(cPrefixo+"IN2110")
Local nPosLOTPLS	:= GdFieldPos(cPrefixo+"LOTPLS")
Local nPosCODRDA	:= GdFieldPos(cPrefixo+"CODRDA")
Local nAuxPLS		:= 0 //Variável para controle na integração do SIGAPLS
Local lLinPla		:= .T.

Private aAcumulados := {}
Private cAnoAcuIni 	:= ""
Private cAnoAcuFim 	:= ""

If Type("lGetFilial") == "U"
	_SetOwnerPrvt( 'lGetFilial', .F. )
EndIf
aCols  := oGet:aCols
aSRCCols:= aClone(aCols)

// Variavel n nao estara criada quando a funcao de validacao
// for chamada pelo LostFocus da GetDados. Se estiver criada,
// continua com o valor de n, senao, recebe a linha que estava
// selecionada da GetDados no momento que perdeu o foco.
n := If(Type("n")="U",oGet:nat, n)

Begin Sequence

	// So valida a linha se tiver alguma alteracao
	If fCompArray( aSRCCols , aColsAnt )
		Break
	Endif


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se periodo de lancamento esta bloqueado			     ³
	//³Se for roteiro de Adiantamento, realiza validacao por verbas  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cRoteiro $ fGetCalcRot('2') // Roteiro de Adiantamento
		If !fVldAccess( aSRCCols[n,nPosFil],cPeriodo, cNumPagto,.T.,cRoteiro, "3", "V" )
			lRet:= .F.
			Break
		EndIf
	ElseIf !fVldAccess( aSRCCols[n,nPosFil],cPeriodo, cNumPagto,.T., cRoteiro)
		lRet := .F.
		Break
	EndIf


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Monta a Sequencia da Verba "Chave Inicial Matricula"          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !( lRet := fMontaSeq( cPrefixo+"MAT", cCod, cPrefixo, aGhCols ) )
		Break
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//|Bloqueia Verbas vindas do SIGAPON                             |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lBloqPON .And. Upper(aSRCCols[n,nPosTp2]) == "E"
		If n <= Len( aColsAnt ) .And. !fCompArray( aColsAnt[n], aCols[n] )
			fVldAltPon( "1" )	//?-Apresenta Mensagem
			lRet := .F.
			Break
		EndIf
	EndIf

	If cLancAlias == "RGB"
		If nPosLOTPLS > 0 .AND. nPosCODRDA > 0 .AND. !(EmpTy(aCols[n,nPosLOTPLS]))
			nAuxPLS := aScan( aColsAnt, { |x| ( x[nPosRegWT] == aCols[n,nPosRegWT] ) } )
			If nAuxPLS > 0 .AND. !PLSxGPEVLD(aCols[n], aColsAnt[nAuxPLS])
				MsgInfo(STR0045 + aCols[n,nPosLOTPLS] + STR0046) //"O registro não pode ser Alterado, pois sua origem é um lote de pagamento [ " ### " ] do módulo SIGAPLS."
				lRet := .F.
				Break
			EndIf
		EndIf
	EndIf

	If !aSRCCols[n,nSRCUsado+1]

		If Empty(aSRCCols[n][nPosMat])
			Help(" ",1,"A100CMAT")
			lRet := .F.
			Break
		Endif
		If cLctoDiario == "S" .And. Empty(aSRCCols[n][nPosDtRef])
			Help( "", 1, OemToAnsi( STR0030 ), NIL, OemToAnsi( STR0041 ), 1, 0 )//"Atenção"##"Lançamento sem data de referência informada."
			lRet := .F.
			Break
		ElseIf nPosIN > 0 .And. aSRCCols[n, nPosIN] == "1"
			If Empty(aSRCCols[n, nPosDtRef])
				Help( "", 1, OemToAnsi( STR0030 ), NIL, OemToAnsi( STR0047 ), 1, 0 )//"Atenção"##"Para lançamento relativo à IN 2110, a data de referência deve ser informada."
				lRet := .F.
				Break
			Endif
		ElseIf cLctoDiario != "S" .And. !Empty(aSRCCols[n, nPosDtRef]) .And. aSRCCols[n, nPosTp2] == "I"
			Help( "", 1, OemToAnsi( STR0030 ), NIL, OemToAnsi( STR0048 ), 1, 0 )//"Atenção"##"Data de referência não deve ser informada pois a verba não possui configuração para lançamento diário"
			lRet := .F.
			Break
		Endif
		If cPaisLoc == "BRA" .And. !IsBlind() .And. aSRCCols[n, nPosTp2] == "I"
			If FindFunction("ValidaPlaIR")
				lLinPla := ValidaPlaIR( @lExiMsgPl, cCod)
				If !lLinPla
					lRet := .F.
					Break
				Endif	
			Endif	
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se esta cadastrando a verba em duplicidade          					 ³
		//³ -Matricula, Centro de Custo, Numero de Pagamento, Sequencia e Data de Referencia ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF nPosMa # 0 .and. nPosSe # 0 .and. nPosCC # 0 .and. nPosSq # 0 .And.;
		   (nPosFun # 0 .or. (nPosFun == 0 .and. cLancAlias == "SRC" .and. (cLancAlias)->(FieldPos("RC_CODFUNC")) == 0))
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se verba tem opcao de lancamento diario, so sera permitido   ³
			³ um lancamento por dia para cada funcionario.                 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If (cLctoDiario == "S")
				aEval(aSRCCols,{ |X| If(If(nPosFil > 0, X[nPosFil] == aSRCCols[N,nPosFil] ,.T.) .and.;
										X[nPosMa]==aSRCCols[N,nPosMa] .and.;
							   			X[nPosDtRef]==aSRCCols[N,nPosDtRef] .and.;
							   			If(nPosFun > 0, X[nPosFun] == aSRCCols[N,nPosFun],.T.) .and.;
							   			!x[nSRCUsado+1],;
							   			nCont ++ ,;
						   				nCont;
						   			    );
							    };
					  )
			Else
				If nPosSe # 0
					If !lItemClvl
						aEval(aSRCCols,{ |X| If(If(nPosFil > 0, X[nPosFil] == aSRCCols[N,nPosFil] ,.T.) .and.;
											X[nPosMa]==aSRCCols[N,nPosMa] .and.;
											X[nPosCC]==aSRCCols[N,nPosCC] .and.;
								   			X[nPosSq]==aSRCCols[N,nPosSq] .and.;
								   			X[nPosDtRef]==aSRCCols[N,nPosDtRef] .and.;
								   			If(nPosFun > 0, X[nPosFun] == aSRCCols[N,nPosFun] ,.T.) .and.;
								   			!x[nSRCUsado+1],;
								   			nCont ++ ,;
							   				nCont;
							   			 );
								 };
						  )
					Else
						aEval(aSRCCols,{ |X| If(If(nPosFil > 0, X[nPosFil] == aSRCCols[N,nPosFil] ,.T.) .and.;
												X[nPosMa]==aSRCCols[N,nPosMa] .and.;
												X[nPosCC]==aSRCCols[N,nPosCC] .and.;
												X[nPosItem]==aSRCCols[N,nPosItem] .and.;
												X[nPosClvl]==aSRCCols[N,nPosClvl] .and.;
									   			X[nPosSq]==aSRCCols[N,nPosSq] .and.;
									   			X[nPosDtRef]==aSRCCols[N,nPosDtRef] .and.;
									   			If(nPosFun > 0, X[nPosFun] == aSRCCols[N,nPosFun] ,.T.) .and.;
									   			!x[nSRCUsado+1],;
									   			nCont ++ ,;
								   				nCont;
								   			 );
									 };
							  )
					Endif
				EndIf
			EndIf

			If !( lRet := !( nCont > 1 ) )
				Help(" ",1,"A100CVERBA")
				lRet := .F.
				Break
			EndIf
		EndIf


		If lRet
			SRA->(DBSetOrder(1))

			If !SRA->(DBSeek(aSRCCols[n, nPosFil] + aSRCCols[n, nPosMat]))
				Help(" ", 1, "REGNOIS")
				lRet := .F.
				Break
			Endif
		Endif

		If !lGetFilial
			dbSelectArea("SRV")
			SRV->(DBSetOrder(1))
			If !SRV->(DBSeek(xFilial("SRV") + cCod))
				Help(" ", 1, "A100NOPDFIL")     //Não existe o código da verba para a filial selecionada.
				lRet := .F.
				Break
			Endif
		Endif

		If !( lRet := !Empty(aSRCCols[n,nPosTp1]) )
			Help(" ",1,"A100STIPO1")
			Break
		Endif

		cTipo1 := aSRCCols[n,nPosTp1]
		cTipo2 := aSRCCols[n,nPosTp2]
		nHoras := aSRCCols[n,nPosHor]
		nValor := aSRCCols[n,nPosVal]
		nHorasC:= aSRCCols[n,nPosHorC]
		nValorC:= aSRCCols[n,nPosValC]

		//Checar campos horas para lancamentos em dias ou Horas
		If cTipo1 $ "DH" .and. cTipo2 = "I" .and. nHoras == 0.00
			Help(" ",1,"A100SHORAS")
			lRet := .F.
			Break
		Endif

		//--Checar campo valor para lancamentos em valor
		If cTipo1 $ "V" .and. cTipo2 = "I" .and. nValor = 0.00
			Help(" ",1,"A040SVAHOR")
			lRet := .F.
			Break
		Endif

		//--Checar campo valor ou horas para lancamentos diferentes de calculad
		If nValor == 0 .and. nHoras == 0.00 .and. cTipo2 #  "C"
			Help(" ",1,"A040SVAHOR")
			lRet := .F.
			Break
		Endif

		//--Checar campo valor ou horas para lancamentos diferentes de calculad
		If nValorC == 0 .and. nHorasC == 0.00 .and. cTipo2 ==  "C"
			Help(" ",1,"A040SVAHOR")
			lRet := .F.
			Break
		Endif

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica Se a Quantidade de Horas ou Valor Estao  conforme os³
		³ limites do cadastro de verbas.							   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		// Valor
		IF (cTipo1 $ "V")
			nLimDe  := PosSRV(cCod , cFilial , "RV_VLIMDE" )
			nLimAte := PosSRV(cCod , cFilial , "RV_VLIMATE" )

			If (nLimDe != 0) .OR. (nLimAte != 0)
		   		If !(nValor >= nLimDe .AND. nValor <= nLimAte)
					Help(" ",1,"GPA120LIM")
					lRet := .F.
					Break
				EndIf
			EndIf

  		// Horas
  		ElseIf (cTipo1 $ "DH")
  			nLimDe  := PosSRV(cCod , cFilial , "RV_RLIMDE" )
			nLimAte := PosSRV(cCod , cFilial , "RV_RLIMATE" )

			If (nLimDe != 0) .OR. (nLimAte != 0)
				If !(nHoras >= nLimDe .AND. nHoras <= nLimAte)
					Help(" ",1,"GPA120LIM")
					lRet := .F.
					Break
				EndIf
			EndIf
  		EndIF




		If (lRet)

			//Periodo e Numero de Pagamento
			lRet := gp090NrPagtoValid(cNumPagto,cPrefixo)
		EndIf

		If !lItemClVl
			nPos := ASCAN(aColsAnt, { |X| X[nPosFil]+cProcesso+X[nPosMa]+cPeriodo+;
							cNumPagto+cRoteiro+cCod+X[nPoscc]+X[nPosSq]+;
							DTOS(X[nPosDtRef]) = oGet:aCols[ n, nPosFil ]+;
							cProcesso+oGet:aCols[ n, nPosMa ]+cPeriodo+;
				  			cNumPagto+cRoteiro+cCod+;
							oGet:aCols[ n, nPosCC ]+oGet:aCols[ n, nPosSq ]+;
							Dtos(oGet:aCols[ n, nPosDtRef ]) } )
		Else
			nPos := ASCAN(aColsAnt, { |X| X[nPosFil]+cProcesso+X[nPosMa]+cPeriodo+;
							cNumPagto+cRoteiro+cCod+X[nPoscc]+X[nPosItem]+X[nPosClvl]+X[nPosSq]+;
							DTOS(X[nPosDtRef]) = oGet:aCols[ n, nPosFil ]+;
							cProcesso+oGet:aCols[ n, nPosMa ]+cPeriodo+;
				  			cNumPagto+cRoteiro+cCod+;
							oGet:aCols[ n, nPosCC ]+oGet:aCols[ n, nPosItem ]+;
							oGet:aCols[ n, nPosClvl ]+oGet:aCols[ n, nPosSq ]+;
							Dtos(oGet:aCols[ n, nPosDtRef ]) } )
		EndIf

		If ( lRet .and. nPos <> n )

			If FindFunction("SPFilTerOff")
				SPFilTerOff( { "SRA", cLancAlias } )
			Endif

			If !lItemClVl
		    	( cLancAlias )->( dbSetOrder( RetOrdem( cLancAlias , cPrefixo+"FILIAL+"+cPrefixo+"PROCES+"+cPrefixo+"MAT+"+cPrefixo+if(cLancAlias=="SRC","PERIODO+","PERIOD+")+cPrefixo+"SEMANA+"+cPrefixo+"ROTEIR+"+cPrefixo+"PD+"+cPrefixo+"CC+"+cPrefixo+"SEQ+DTOS("+cPrefixo+"DTREF)" ) ) )
      			//RGB->(dbSetOrder( RetOrdem( "RGB", "RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_PD+RGB_CC+RGB_SEQ+DTOS(RGB_DTREF)" ) ) )
		    Else
		    	( cLancAlias )->( dbSetOrder( RetOrdem( cLancAlias, cPrefixo+"FILIAL+"+cPrefixo+"PROCES+"+cPrefixo+"MAT+"+cPrefixo+if(cLancAlias=="SRC","PERIODO+","PERIOD+")+cPrefixo+"SEMANA+"+cPrefixo+"ROTEIR+"+cPrefixo+"PD+"+cPrefixo+"CC+"+cPrefixo+"ITEM+"+cPrefixo+"CLVL+"+cPrefixo+"SEQ+DTOS("+cPrefixo+"DTREF)" ) ) )
      			//RGB->(dbSetOrder( RetOrdem( "RGB", "RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_PD+RGB_CC+RGB_ITEM+RGB_CLVL+RGB_SEQ+DTOS(RGB_DTREF)" ) ) )
		    EndIf

			If !lItemClVl
				cKeyPes	:= 	oGet:aCols[ n, nPosFil ]+cProcesso+oGet:aCols[ n, nPosMa ]+;
							cPeriodo+cNumPagto+cRoteiro+cCod+;
							oGet:aCols[ n, nPosCC ]+oGet:aCols[ n, nPosSq ]+Dtos(oGet:aCols[ n, nPosDtRef ])
		    Else
		    	cKeyPes	:= 	oGet:aCols[ n, nPosFil ]+cProcesso+oGet:aCols[ n, nPosMa ]+;
					   		cPeriodo+cNumPagto+cRoteiro+cCod+;
							oGet:aCols[ n, nPosCC ]+oGet:aCols[ n, nPosItem ]+oGet:aCols[ n, nPosClvl ]+;
							oGet:aCols[ n, nPosSq ]+Dtos(oGet:aCols[ n, nPosDtRef ])
		    EndIf
			If ( cLancAlias )->(dbSeek(cKeyPes))
				Help(" ",1,"A100CVERBA")
				lRet := .F.
			EndIf

			If FindFunction("SPFilTerOff")
				SPFilTerOff( { "SRA", cLancAlias }, .F. )
			Endif
		Endif
	Endif

	// Validação para lançamento de faltas quando usa o cálculo outomático de benefícios
	If lRet
		If ( SRV->RV_CODFOL == "0054" )
			CargaCrit("VA', 'VR", @aCriterio, cDataIni, cDataFim)
			If Len(aCriterio) > 0
				If( aCols[n, nPosHor] > 1) .Or. ( Empty(aCols[n, nPosDtRef]) )
					MsgAlert(OemToAnsi(STR0043))	// Para que as faltas sejam consideradas corretamente no cálculo automático de benefícios devem ser informadas em dias, um dia por lançamento e com a data de referência preenchida.
					lRet := .F.
				EndIf
			EndIf
		EndIf
	EndIf

	If lRet .And. lGP100OK
		lRet := ExecBlock( "GP100OK", .F., .F., {aCols[n]} )
	EndIf

End Sequence

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp100TudOk³ Autor ³ M. Stiefano           ³ Data ³ 19.10.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gp100TudOk(o)

Local lRetorna  := .T.
Local cPrefixo  := ( PrefixoCpo( cLancAlias ) + "_" )
Local nPosMat	:= GdFieldPos( cPrefixo+"MAT"  , aHeader)
Local nPosHor	:= If(cLancAlias=="SRC", GdFieldPos("RC_HORINFO", aHeader),GdFieldPos("RGB_HORAS", aHeader))
Local nPosVal	:= If(cLancAlias=="SRC", GdFieldPos("RC_VALINFO", aHeader),GdFieldPos("RGB_VALOR", aHeader))

Continua        := .F.
nValCalc        := 0


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Testa Total do Lan‡amento com Total Calculado                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nValLanc # 0
		nValCalc := Val(cCod)
		aEval( aSRCCols, { |X| nValCalc += Val(X[nPosMat]) + X[nPosVal] + X[nPosHor] } )
		If Len(aColsAnt) > 0
			aEval( aColsAnt, { |X| nValCalc -=( Val(X[nPosMat]) + X[nPosVal] + X[nPosHor] ) } )
		Endif
		If Round(nValCalc,3) # Round(nValLanc,3)
			Help(" ",1,"NAOBATELAW")
			lRetorna	:= .F.
		Endif
	Endif

Return( lRetorna )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp100Str  ³ Autor ³ M. Stiefano           ³ Data ³ 19.10.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gp100Str(nTam)

Local cStrMat   := GetMv("MV_STRMATR")
Local lRetorna  := .T.
Local nPosMat   := GdFieldPos( "RGB_MAT", aHeader)

DEFAULT nTam := 6

IF cStrMat == "S"
	aCols[n,nPosMat] := StrZero(Val(M->RGB_MAT),nTam)
	M->RGB_MAT        := StrZero(Val(M->RGB_MAT),nTam)
EndIF

Return( lRetorna )


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³gp100MontaGetDados³ Autor ³ Tatiane Matias        ³ Data ³09.08.2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta dados para a GetDados                           	          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ gp100MontaGetDados(cCod, cAlias, aSRCCols, nOpcx, lGravarAntes)    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Gp100Vis                                                           ³±±
±±³          ³ Gp100Inc                                                           ³±±
±±³          ³ Gp100Alt                                                           ³±±
±±³          ³ Gp100Del                                                           ³±±
±±³          ³ Gp100Grava                                                         ³±±
±±³          ³ Campos Processo e Periodo                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß */
Function gp100MontaGetDados(cCod, cAlias, aSRCCols, nOpcx, lGravarAntes)
	Local a100Field		:= {}
	Local aFilVld		:= {}
	Local cKey
	Local cQueryCond	:= ""
	Local cQueryGh		:= ""
	Local cFilVld		:= ""
	Local nLinha		:= 0
	Local nPosHoras		:= 0
	Local nPosNome		:= 0
	Local nPosPosto		:= 0
	Local nPosMat		:= 0
	Local nPosFil		:= 0
	Local nPosSemana	:= 0
	Local cFilSrv		:= xFilial("SRV")
	Local cPrefixo      := ( PrefixoCpo( cAlias ) + "_" )
	Local lNotIn		:= .F.
	Local lNotProv		:= SRV->RV_TIPOCOD != "1"

	Static cDataIni
	Static cDataFim

	//--Verifica se deve pode digitar a filial no momento do lancamento
	//--Se filial do cadastro de verbas compartilhada e o usuario tem a opcao de todas as filiais
	If Empty(cFilSrv) .And. ( VerSenha(114) .Or. VerSenha(115) )
		lGetFilial	:= .T.
	Endif

	// vetor com os campos que nao serao Usados
	a100Field	:= {cPrefixo+"SEMANA",cPrefixo+"DESCPD",cPrefixo+"PD",cPrefixo+"QTDSEM", cPrefixo+"PROCES", If(cAlias=="SRC",cPrefixo+"PERIODO",cPrefixo+"PERIOD"), cPrefixo+"NUMID", cPrefixo+"ROTEIR" }

	If cAlias == "RGB"
		aAdd(a100Field, "RGB_DUM")
		aAdd(a100Field, "RGB_DDOIS")
		aAdd(a100Field, "RGB_DTRES")
		aAdd(a100Field, "RGB_DQUATR")
		aAdd(a100Field, "RGB_DCINCO")
		aAdd(a100Field, "RGB_DSEIS")
		aAdd(a100Field, "RGB_DSETE")
	ElseIf cAlias == "SRC"
		aAdd(a100Field, "RC_NODIA")
		aAdd(a100Field, "RC_DIACTB")
		aAdd(a100Field, "RC_PLNUCO")
		aAdd(a100Field, "RC_CODB1T")
		aAdd(a100Field, "RC_VALORBA")
	EndIf

	If !lItemClVl
		AAdd(a100Field, cPrefixo+"ITEM")
		AAdd(a100Field, cPrefixo+"CLVL")
	EndIf


	// Antes de montar a tela, verifica se deseja gravar ... caso tenha tido alguma alteracao.
	If (lGravarAntes) .AND. (nOpcx <> 2)
		MsAguarde( { || Gp100Grava(cCod, cAlias, nOpcx, .T., .T.) }, OemToAnsi(STR0018))
	EndIf


	If ( cProcesso  <> cProcessoAnt ) .or. ( cPeriodo <> cPeriodoAnt ) .or. (cNumPagto <> cSemanaAnt) .or. cRoteiro <> cRoteiroAnt
		// Recupera o Roteiro do Periodo Informado.
		If (cRoteiro <> RCH->RCH_ROTEIR .and. !Empty(RCH->RCH_ROTEIR)) .or. Empty(cRoteiro)
			DbSelectArea( cAlias )
			cRoteiro	:= gp240RetCont("RCH", 1, xFilial("RCH") + cProcesso + cPeriodo + cNumPagto, "RCH_ROTEIR")
			If Empty(cRoteiro)
				cRoteiro := fGetRotOrdinar()
			EndIf
		ElseIf cRoteiro <> RCH->RCH_ROTEIR .and. Empty(RCH->RCH_ROTEIR)
			// somente posicionar na tabela RCH e nao atualizar o roteiro
			DbSelectArea( cAlias )
			gp240RetCont("RCH", 1, xFilial("RCH") + cProcesso + cPeriodo + cNumPagto, "RCH_ROTEIR")
		Else
			DbSelectArea( cAlias )
			gp240RetCont("RCH", 1, xFilial("RCH") + cProcesso + cPeriodo + cNumPagto + cRoteiro, "RCH_ROTEIR")
		EndIf
		SetNumPgCalc( cNumPagto ) // setar em variavel estatica para retorno do inicializador padrao
	EndIf

	cDataIni  := gp090RetDtRef(.T.)
	cDataFim  := gp090RetDtRef(.F.)

	If Empty(cDataIni) .OR. Empty(cDataFim)
		cDataPer  := "  /  /   a   /  /  "
	Else
		cDataPer  := DTOC(cDataIni) + " a "  + DTOC(cDataFim)
	EndIf

	If Versenha(114) .And. Versenha(115)
		If FWModeAccess("SRV",3) == "E"
			cQueryCond	:= cPrefixo+"FILIAL='" + xFilial("SRV",cFilAnt) + "' AND "
		Else
			cFilVld := fValidFil()
			If Len(cFilVld) > 50000
				// Filtra pelas Filiais que NÃO POSSUI acesso
				//Quando a lista de filias que POSSUI acesso for muito grande
				cFilVld := fValidFil(,.T.)
				lNotIn	:= .T.
			Endif
			aFilVld := Separa(cFilVld,"/")
			cIn := ""
			aEval(aFilVld,{|x|IIF(Empty(x),,cIn+= "'" + xFilial("RGB",x) + "',")})
			cIn := SubStr(cIn,1,Len(cIn)- 1)
			If lNotIn
				cQueryCond	:= IIf(Empty(cIn), "", cPrefixo+"FILIAL NOT IN ("+ cIn + ")" + " AND ")
			Else
				cQueryCond := cPrefixo+"FILIAL IN ("+ cIn + ")" + " AND "
			EndIf
		EndIf
	Else
		cQueryCond	:= cPrefixo+"FILIAL='" + cFilAnt + "' AND "
	EndIf

    cQueryCond += cPrefixo+"PD='" + cCod + "'"
	cQueryCond += " AND "
	cQueryCond += cPrefixo+"PROCES='" + cProcesso + "'"
	cQueryCond += " AND "
	cQueryCond += iIf(cAlias=="SRC",cPrefixo+"PERIODO='",cPrefixo+"PERIOD='")+ cPeriodo + "'"
	cQueryCond += " AND "
	cQueryCond += cPrefixo+"ROTEIR='" + cRoteiro + "'"

	If cAlias == "RGB"
		//Clona a query para diferenciacao mais abaixo
		cQueryGh := cQueryCond

		cQueryCond += " AND("
		cQueryCond += " RGB_DUM = 0 AND"
		cQueryCond += " RGB_DDOIS = 0 AND"
		cQueryCond += " RGB_DTRES = 0 AND"
		cQueryCond += " RGB_DQUATR = 0 AND"
		cQueryCond += " RGB_DCINCO = 0 AND"
		cQueryCond += " RGB_DSEIS = 0 AND"
		cQueryCond += " RGB_DSETE = 0 ) "

		//Query para abertura de aCols Ghost
		cQueryGh += " AND("
		cQueryGh += " RGB_DUM != 0 OR"
		cQueryGh += " RGB_DDOIS != 0 OR"
		cQueryGh += " RGB_DTRES != 0 OR"
		cQueryGh += " RGB_DQUATR!= 0 OR"
		cQueryGh += " RGB_DCINCO!= 0 OR"
		cQueryGh += " RGB_DSEIS != 0 OR"
		cQueryGh += " RGB_DSETE != 0 ) "
	EndIf

	If FWModeAccess("SRV",3) == "E"
		cKey	 := ( xFilial(cAlias) + cCod + cProcesso + cPeriodo + cRoteiro)
		(cAlias)->( dbSetOrder( RetOrdem( cAlias , cPrefixo+"FILIAL+"+cPrefixo+"PD+"+cPrefixo+"PROCES+"+cPrefixo+If(cAlias=="SRC","PERIODO+","PERIOD+")+cPrefixo+"ROTEIR" ) ) )
	Else
		cKey	 := ( cCod + cProcesso + cPeriodo + cRoteiro)
		(cAlias)->( dbSetOrder( RetOrdem( cAlias , cPrefixo+"PD+"+cPrefixo+"PROCES+"+cPrefixo+If(cAlias=="SRC","PERIODO+","PERIOD+")+cPrefixo+"ROTEIR" ) ) )
	Endif

	If Empty(cFilVld)
		bSkip := { || (cAlias)->(&(cPrefixo+"SEMANA")) <> cNumPagto  }
	Else
		If lNotIn
			bSkip := { || (cAlias)->(&(cPrefixo+"SEMANA")) <> cNumPagto  .or. ((cAlias)->(&(cPrefixo+"FILIAL")) $ cFilVld)}
		Else
			bSkip := { || (cAlias)->(&(cPrefixo+"SEMANA")) <> cNumPagto  .or. !((cAlias)->(&(cPrefixo+"FILIAL")) $ cFilVld)}
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿//
	//³Troca a posição do campo SEMANA         ³//
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ//
	aHeader		:= GdMontaHeader(NIL, NIL, NIL, cAlias, a100Field, , , , , .F. )
	nPosSemana	:= AScan(aHeader, { |aColumn| aColumn[__AHEADER_FIELD__] == cPrefixo + "SEMANA"} )
	nPosNome	:= AScan(aHeader, { |aColumn| aColumn[__AHEADER_FIELD__] == cPrefixo + "NOME"} )

	If nPosNome > 0
		a100Field	:= NIL
	Else
		aHeader	:= {}
	EndIf
	//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ//

	aSRCCols := (cAlias)->( GdMontaCols(	@aHeader		,;	//01 -> Array com os Campos do Cabecalho da GetDados
						   	  				@nSRCUsado		,;	//02 -> Numero de Campos em Uso
									  		@aSRCVirtGd		,;	//03 -> [@]Array com os Campos Virtuais
									 		@aSRCVisualGd	,;	//04 -> [@]Array com os Campos Visuais
		                	          		cAlias			,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
									  		a100Field		,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
									  		@aSRCColsRec	,;	//07 -> [@]Array unidimensional contendo os Recnos
								  			cAlias			,;	//08 -> Alias do Arquivo Pai
								  			cKey			,;	//09 -> Chave para o Posicionamento no Alias Filho
								  			Nil				,;	//10 -> Bloco para condicao de Loop While
								  			bSkip			,;	//11 -> Bloco para Skip no Loop While
								  			NIL				,;	//12
								  			NIL				,;	//13
								  			NIL				,;	//14
						  					NIL				,;	//15
								  			NIL				,;	//16
								  			NIL				,;	//17
								  			cQueryCond		,;	//18
						  					.F.				,;	//19
											.F.				,;	//20
		   									.T.				))	//21
	If cAlias == "RGB"
		aGhCols := GdMontaCols(	@aHeader		,;	//01 -> Array com os Campos do Cabecalho da GetDados
								@nSRCUsado		,;	//02 -> Numero de Campos em Uso
						  		@aSRCVirtGd		,;	//03 -> [@]Array com os Campos Virtuais
						 		@aSRCVisualGd	,;	//04 -> [@]Array com os Campos Visuais
	           	          		cAlias			,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
						  		a100Field		,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
						  		@aGhColsRec		,;	//07 -> [@]Array unidimensional contendo os Recnos
					  			cAlias			,;	//08 -> Alias do Arquivo Pai
					  			cKey			,;	//09 -> Chave para o Posicionamento no Alias Filho
					  			Nil				,;	//10 -> Bloco para condicao de Loop While
					  			bSkip  			,;	//11 -> Bloco para Skip no Loop While
					  			NIL				,;
					  			NIL				,;
					  			NIL				,;
					  			NIL				,;
					  			NIL				,;
					  			NIL				,;
					  			cQueryGh		,;
					  			.F.				,;
					  			.F.				,;
					  			.T.  			)




		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Coloca o campo de filial e numero de Pagto, como Visual      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
        nPosFil		:= GdFieldPos(cPrefixo+"FILIAL", aHeader)
		nPosSemana	:= GdFieldPos(cPrefixo+"SEMANA", aHeader)

		If ( nPosSemana > 0 )
			aAdd(aSRCVisualGd, cPrefixo + "SEMANA")
			aHeader[ nPosSemana, __AHEADER_VISUAL__ ] := "V"
			aHeader[ nPosSemana, __AHEADER_INITPAD__] := "cNumPagto"
		EndIf

	EndIf

	(cAlias)-> (dbSetOrder( RetOrdem( cAlias , cPrefixo+"FILIAL+"+cPrefixo+"PD+"+cPrefixo+"MAT+"+cPrefixo+"SEQ" ) ))

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se verba nao tem opcao de lancamento diario, nao deixar      ³
	³ alterar o campo data de referencia.                          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If (cLctoDiario != "S" .And. lNotProv)
		aAdd(aSRCVisualGd, cPrefixo+"DTREF")
		aHeader[GdFieldPos( cPrefixo+"DTREF" , aHeader ), 14] := "V"
		aHeader[GdFieldPos( cPrefixo+"DTREF" , aHeader ), 12] := "CTOD('//')"
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Limpar o Inicializador padrao do Campo "RC_Fililal", para essa tela		³
	³ porque no dicioanrio nao pode apagar, por ser utilizado em outro programa ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If lGetFilial
		aAdd(aSRCVisualGd, cPrefixo+"FILIAL")
		IF GdFieldPos( cPrefixo+"FILIAL" , aHeader ) > 0
			aHeader[GdFieldPos( cPrefixo+"FILIAL" , aHeader ), 12] := Space(FwSizeFilial())
		ENDIF
	Endif

	If cAlias == "RGB" .And. FunName() == "GPEA590"
		IF GdFieldPos( cPrefixo+"FILIAL" , aHeader ) > 0
			aHeader[GdFieldPos( cPrefixo+"FILIAL" , aHeader ), 12] := "xFilial('RGB')"
			If !VerSenha(114) .And. !VerSenha(115)
				aHeader[GdFieldPos( cPrefixo+"FILIAL" , aHeader ), 14] := "V"
			EndIf
		ENDIF

		If GdFieldPos( cPrefixo+"DTREF", aHeader) > 0
			aHeader[GdFieldPos( cPrefixo+"DTREF", aHeader), __AHEADER_INITPAD__] := 'CtoD("//")'
		EndIf
	EndIf

	nPosFil		:= GdFieldPos( cPrefixo+"FILIAL", aHeader )
	nPosMat		:= GdFieldPos( cPrefixo+"MAT"	, aHeader )
	nPosNome	:= GdFieldPos( cPrefixo+"NOME"	, aHeader )
	nPosPosto	:= GdFieldPos( cPrefixo+"POSTO"	, aHeader )
	nPosHoras	:= If(cLancAlias=="SRC", GdFieldPos(cPrefixo+"HORINFO", aHeader), GdFieldPos(cPrefixo+"HORAS", aHeader))
	nPosTp1		:= GdFieldPos( cPrefixo+"TIPO1"	, aHeader )
	nPosSemana	:= GdFieldPos( cPrefixo+"SEMANA", aHeader )

	For nLinha := 1 To Len(aSRCCols)
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o Nome do funcionario          					   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aSRCCols[nLinha,nPosNome] := fDesc("SRA",aSRCCols[nLinha,nPosMat],"RA_NOME",,If (nPosFil > 0,aSRCCols[nLinha,nPosFil], Nil) )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se MV_HORASDE = "S" e Campo RC_HORINFO Converte Horas        ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF (cDigHoras == "S") .And. (aSRCCols[nLinha,nPosTp1] == "H" )
			aSRCCols[nLinha,nPosHoras] := fConvHr(aSRCCols[nLinha,nPosHoras] , "H" )
		EndIF

	Next nLinha

	fAcolsSPF(@aSRCCols)
	//--- Copia o vetor aCols
	aColsAnt 	 := aClone(aSRCCols)
	cProcessoAnt := cProcesso
	cPeriodoAnt  := cPeriodo
	cRoteiroAnt  := cRoteiro
	cSemanaAnt	 := cNumPagto

	// atualiza a getdados
	If !(oGet == nil)
		oGet:SetArray(aClone(aSRCCols))
		oGet:lModified := .F.
		If ( Type("oGet:oBrowse") == "O" )
			oGet:Refresh()
		EndIf
	EndIf

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp100GrInc³ Autor ³ M. Stiefano           ³ Data ³ 24.05.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava os registros Incluidos na GetDados                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GpA100GRAVA                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function Gp100GrInc( cAlias , nIniciar, cCod )

Local nX		:= 0.00
Local nY		:= 0.00
Local nHor1     := 0.00
Local nHorDec   := 0.00
Local nLenCols	:= Len( aSRCCols )
Local nLenHead	:= Len( aHeader )
Local cPrefixo  := ( PrefixoCpo( cAlias ) + "_" )
Local nPosFil	:= GdFieldPos(cPrefixo+"FILIAL")
Local cFilSrc	:= xFilial(cPrefixo)

Private cCampo	:= ""

Default cCod 	:= SRV->RV_COD

dbSelectArea( cAlias )
For nX := nIniciar To nLenCols

	//--Gravar a Filial do Registro Informado quando a Filial estiver no aCols
	If nPosFil > 0
		cFilSrc := aSRCCols[nX,nPosFil]
	Endif

	If !aSRCCols[nX,nSRCUsado+1]
		RecLock(cAlias,.T.)

		(cAlias)->(&(cPrefixo+"FILIAL"))	:= cFilSrc
		(cAlias)->(&(cPrefixo+"PD"))		:= cCod
		(cAlias)->(&(cPrefixo+"PROCES"))	:= cProcessoAnt
		(cAlias)->(&(cPrefixo+If(cAlias=="SRC","PERIODO","PERIOD")))	:= cPeriodoAnt
		(cAlias)->(&(cPrefixo+"ROTEIR")) 	:= cRoteiroAnt
		(cAlias)->(&(cPrefixo+"TIPO2")) 	:= "I"
		(cAlias)->(&(cPrefixo+"SEMANA")) 	:= cSemanaAnt

		For nY := 1 To nLenHead
			cCampo := AllTrim(aHeader[nY,2])

			/* Os campo horas e valor serao gravados no momento da gravacao
			dos campos horinfo e valinfo. */
			If cAlias == "SRC"
				If cCampo == ("RC_HORAS") .OR. cCampo ==("RC_VALOR")
				    Loop
				EndIf
			EndIf

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se MV_HORASDE = "S" e Campo RC_HORINFO Converte Horas 		 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If cDigHoras = "S" .and. ( cCampo = cPrefixo+"HORINFO" .or. cCampo = cPrefixo+"HORAS")
				nHorDec := aSRCCols[nX,nY]
				nHor1 := nHorDec - Int(nHorDec)
				nHor1 := ( nHor1 / 60 ) * 100
				nHor1 := Round( Int(nHorDec) + nHor1 , 2 )
				xConteudo := nHor1
			Else
				xConteudo := aSRCCols[nX,nY]
			Endif

			IF !( AllTrim( cCampo ) == cPrefixo+"NOME" )
				&cCampo := xConteudo

			    /*Gravar em horas e valor o mesmo valor informado em horinfo e
			    valinfo. */
	 		    If cCampo == (cPrefixo+"HORINFO")
					&(cPrefixo+"HORAS") := xConteudo
			    ElseIf cCampo == (cPrefixo+"VALINFO")
    				&(cPrefixo+"VALOR") := xConteudo
			    EndIf

			EndIF
		Next nY
	 	(cAlias)->( MsUnlock() )
    Endif
Next nX

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³gp100Tela³ Autor ³ Tatiane Matias        ³ Data ³09.08.2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta tela                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ gp100Tela(cCod, cDesc, cAlias, nOpcx, aSRCCols)           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Gp100Vis                                                  ³±±
±±³          ³ Gp100Inc                                                  ³±±
±±³          ³ Gp100Alt                                                  ³±±
±±³          ³ Gp100Del                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß */
Function gp100Tela(cCod, cDesc, cAlias, nOpcx, aSRCCols)
	Local aKeys			:= GetKeys()
	Local aAdvSize		:= {}
	Local aInfoAdvSize	:= {}
	Local aObjSize		:= {}
	Local aObjCoords	:= {}
	Local aButtons		:= {}
	Local oGroup
	Local oFont
	Local bFreeLocks	:= {|| FreeLocks(cAlias , NIL , .T. ), .T.}
	Local bGravar		:= {}
	Local lValPer		:= .T.

	Local oDlg	:= Nil

	Private oProcesso
	Private oPeriodo
	Private oNrPagto
	Private oRoteiro

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta as Dimensoes dos Objetos         					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 2 , 2 }
	aAdd( aObjCoords , {000 , 020, .T., .F.} )
	aAdd( aObjCoords , {000 , 027, .T., .F.} )
	aAdd( aObjCoords , {000 , 000, .T., .T.} )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

	If (nOpcx = 3) .OR. (nOpcx = 4)
		bGravar	:=  { || If(oGet:oBrowse:lActive .AND. oGet:TudoOK(), ;
	   				MsAguarde( { || Gp100Grava(cCod, cAlias, nOpcx, .T., .F.)},OemToAnsi(STR0018)), .F.) }
		aAdd(;
				aButtons	,;
								{;
									"SALVAR" 			,;
	   								bGravar				,;
	       	   						OemToAnsi( STR0021 ),;	//"Gravar"
	       	   						"<F7> "+ OemToAnsi( STR0021 ) ;	//"Gravar"
		           				};
	    	 )

		SetKey(VK_F7,bGravar )
	EndIf



	SetaPilha()

	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0011 ) FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL	//"Valores por Verba"

		@ aObjSize[1,1], aObjSize[1,2] GROUP oGroup TO aObjSize[1,3] ,aObjSize[1,4]*0.20  LABEL OemToAnsi(STR0012) OF oDlg PIXEL		//"Verba: "
		oGroup:oFont:= oFont
		@ aObjSize[1,1], aObjSize[1,4]*0.21 GROUP oGroup TO aObjSize[1,3] , aObjSize[1,4]  LABEL OemToAnsi(STR0013) OF oDlg PIXEL		// "Nome:"
		oGroup:oFont:= oFont

		@ aObjSize[2,1], aObjSize[2,2]	GROUP oGroup TO aObjSize[2,3], aObjSize[2,4]*0.20 LABEL OemToAnsi(STR0016) OF oDlg PIXEL	// Processo:
		oGroup:oFont:= oFont
		@ aObjSize[2,1], aObjSize[2,4]*0.21 GROUP oGroup TO aObjSize[2,3], aObjSize[2,4]*0.40 LABEL OemToAnsi(STR0017) OF oDlg PIXEL	// Periodo:
		oGroup:oFont:= oFont
		@ aObjSize[2,1], aObjSize[2,4]*0.41 GROUP oGroup TO aObjSize[2,3], aObjSize[2,4]*0.60 LABEL OemToAnsi(STR0023) OF oDlg PIXEL	// Nro de Pagamento:
		oGroup:oFont:= oFont
		@ aObjSize[2,1], aObjSize[2,4]*0.61 GROUP oGroup TO aObjSize[2,3], aObjSize[2,4]*0.80 LABEL OemToAnsi(STR0022) OF oDlg PIXEL	// Roteiro:
		oGroup:oFont:= oFont
		@ aObjSize[2,1], aObjSize[2,4]*0.81 GROUP oGroup TO aObjSize[2,3], aObjSize[2,4] LABEL OemToAnsi(STR0017) OF oDlg PIXEL	// Periodo:
		oGroup:oFont:= oFont

		@ aObjSize[1,1]+10, aObjSize[1,2]+10	   SAY OemToAnsi(cCod)	SIZE  50, 10 OF oDlg PIXEL FONT oFont
		@ aObjSize[1,1]+10, aObjSize[1,4]*0.21+10  SAY OemToAnsi(cDesc) SIZE 146, 10 OF oDlg PIXEL FONT oFont

		// A variavel LVALPER foi criada para controlar as mensagens de erros, evitando assim 2 ou mais mensagens
		// repetidas - 1 em ExistCpo e outra da funcao GotFocus() da Getdados


		// Se o usuario mudou o processo, remontar a tela com a nova chave de pesquisa (processo e periodo)
		@ aObjSize[2,1]+10, aObjSize[2,2]+10 ;
		  MSGET oProcesso Var cProcesso PICTURE GetSx3Cache( "RCJ_CODIGO" , "X3_PICTURE" ) F3 "RCJ" HASBUTTON  ;
	      SIZE 50,10 OF oDlg PIXEL ;
	      VALID (lValPer := ExistCpo("RCJ", cProcesso))									.AND. ;
		  		If(cProcesso <> cProcessoAnt, If(lSRCLock, Eval(bFreeLocks), .T.), .T.)							.AND. ;
	  			If(cProcesso <> cProcessoAnt, If((lSRCLock := Gpea100Locks(nOpcx , cAlias)) , .T., .F.), .T.) 	.AND. ;
	        	If(cProcesso <> cProcessoAnt, GP100MontaGetDados(cCod, cAlias, @aSRCCols, nOpcx, .T.), .T.)


		// Se o usuario mudou o periodo, remontar a tela com a nova chave de pesquisa (processo e periodo)
		@ aObjSize[2,1]+10, aObjSize[2,4]*0.21+10;
		  MSGET oPeriodo Var cPeriodo PICTURE GetSx3Cache( "RCH_PER" , "X3_PICTURE" ) F3 "RCH" HASBUTTON;
	      SIZE 50,10 OF oDlg PIXEL  ;
		  VALID  ;
		  	If( lValPer, lValPer := (Vazio() .OR. ExistCpo( "RCH", cProcesso + cPeriodo + "        ", 2)), lValPer := .T. )	.AND. ;
  	  	    fAtualRot()																							.AND. ;
		  	If(cPeriodo <> cPeriodoAnt, If(lSRCLock, Eval(bFreeLocks), .T.), .T.)								.AND. ;
	  		If(cPeriodo <> cPeriodoAnt, If((lSRCLock := Gpea100Locks(nOpcx , cAlias)) , .T., .F.), .T.) 		.AND. ;
	        If(cPeriodo <> cPeriodoAnt, gp100MontaGetDados(cCod, cAlias, @aSRCCols, nOpcx, .T.), .T.)


   		@ aObjSize[2,1]+10, aObjSize[2,4]*0.41+10;
   		  MSGET oNrPagto Var cNumPagto PICTURE GetSx3Cache( "RCH_NUMPAG" , "X3_PICTURE" ) F3 "RCH01" HASBUTTON;
   	   	  SIZE 50,10 OF oDlg PIXEL;
	  	  VALID fValNrPago(@lValPer, cCod, cAlias, @aSRCCols, nOpcx)

		oNrPagto:bHelp := {|| ShowHelpCpo("cNumPagto",{GetHlpSoluc("RCH_NUMPAG")[1]},2,{GetHlpSoluc("RCH_NUMPAG")[2]},2)}

		@ aObjSize[2,1]+10, aObjSize[2,4]*0.61+10;
		  MSGET oRoteiro Var cRoteiro PICTURE GetSx3Cache( "RCH_ROTEIR" , "X3_PICTURE" ) F3 "SRY" HASBUTTON	;
		  SIZE 50,10 OF oDlg PIXEL;
		  VALID	If (lValPer, lValPer := (Vazio() .OR. ExistCpo("SRY", cRoteiro)), lValPer:= .T.)	.AND. ;
				If ((cRoteiro <> cRoteiroAnt), gp100MontaGetDados(cCod, cAlias, @aSRCCols, nOpcx, .F.), .T.)

		oRoteiro:bHelp := {|| ShowHelpCpo("cRoteiro",{GetHlpSoluc("RCH_ROTEIR")[1]},2,{GetHlpSoluc("RCH_ROTEIR")[2]},2)}

		// Data Inicio e Data Fim do processo/periodo selecionado
		@ aObjSize[2,1]+10, aObjSize[2,4]*0.81+10;
		  SAY cDataPer SIZE 60,10 OF oDlg PIXEL

  		oGet := MsNewGetDados():New(aObjSize[3,1],;// nTop
								 aObjSize[3,2],;   	// nLelft
								 aObjSize[3,3],;	// nBottom
	                             aObjSize[3,4],;	// nRright
								 nOpcNewGd,;		// controle do que podera ser realizado na GetDado - nstyle
								 "Gp100LinOk",;		// funcao para validar a edicao da linha - ulinhaOK
								 "Gp100TudOk",;		// funcao para validar todas os registros da GetDados - uTudoOK
  								 NIL,;				// cIniCPOS
								 NIL,;				// aAlter
								 0,; 				// nfreeze
								 99999,;  			// nMax
								 NIL,;		 		// cFieldOK
								 NIL,;				// usuperdel
								 If(nOpcx=2.Or.nOpcx=5,.F.,{||Gp090VldDel(@cKeyRCH,nOpcx)}),;		// udelOK
								 @oDlg,;        	// objeto de dialogo - oWnd
								 @aHeader,;			// Vetor com Colunas - AparHeader
								 @aSRCCols;			// Vetor com Header - AparCols
								)

	oGet:oBrowse:bLostFocus := { || If(!Gp100TudOk(), (oGet:oBrowse:SetFocus()), Gp100Grava(cCod, cAlias, nOpcx, .T., .T.)) }

   	oGet:oBrowse:bGotFocus := { || If(Empty(cRoteiro), oRoteiro:SetFocus(), If( lValPer := GpValidPer( NIL, cProcesso, cPeriodo, cNumPagto, cRoteiro), .T., (oRoteiro:SetFocus(), cRoteiro := Space(3), oRoteiro:Refresh()))) }

	bSet15	:= {|| nOpca:=1, ;
				If(oGet:TudoOk(), (Gp100Grava(cCod, cAlias, nOpcx, .F., .F.),RestKeys(aKeys,.T.), oDlg:End()), If(cDigLancam=="S", fTotLanc(),nOpca:=0) ) }
	bSet24	:= {|| RestKeys(aKeys,.T.), oDlg:End()}


	ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg , bSet15 , bSet24, NIL , aButtons )

RestKeys(aKeys,.T.)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fValNrPago ³ Autor ³ Microsiga		   ³ Data ³10.08.2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta tela                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fValNrPago(lValPer, cCod, cAlias, aSRCCols, nOpcx)        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ fValNrPago                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß */
Static Function fValNrPago(lValPer, cCod, cAlias, aSRCCols, nOpcx)
	Local lAtualRot:= .T.
	Local lNumPago:= .T.

	lValPer := ExistCpo("RCH", cProcesso + cPeriodo + cNumPagto + "        ", 3)

	If lValPer
		lAtualRot:= fAtualRot()
	EndIf

	If lValPer .AND. lAtualRot
		If cNumPagto <> cSemanaAnt
			lNumPago:= gp100MontaGetDados(cCod, cAlias, @aSRCCols, nOpcx, .T.)
		EndIf
	EndIf
Return (lValPer .AND. lAtualRot .AND. lNumPago)


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GPEA100Locks    ³Autor³Tatiane Matias      ³ Data ³29/09/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Bloqueia Lancamentos                                         ³
³          ³(por Verba, Processo e Periodo)                              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL		                                               	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gp100Inc                                                     ³
³          ³Gp100Alt                                                     ³
³          ³Gp100Del                                                     ³
³          ³Gp100Tela                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GPEA100Locks( nOpc , cAlias , aRecnos )

Local lLocks	:= .T.

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se nao For Visualizacao				 					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( nOpc == 3 )
		Break
	EndIF

	IF !( lLocks := WhileNoLock( cAlias , aRecnos , { xFilial( cAlias ) + SRV->RV_COD + cProcesso + cPeriodo} , 1 , 1 , .T. , NIL ) )
		Break
	EndIF

End Sequence

Return( lLocks )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³gp100ValidMat   ³Autor³                    ³ Data ³          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validacao da matricula									     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Boolean                                             	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³campo oRoteiro da tela.                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gp100ValidMat()

Local aAreaSRA	:= SRA->( GetArea() )
Local aAreaSRV	:= SRV->( GetArea() )
Local aSitFunc	:= {}
Local nNumMat 	:= 0
Local nPosFil 	:= GdFieldPos( "RC_FILIAL", aHeader)
Local lConPad	:= .T.
Local nRegSra	:= 0
Local lRet		:= .T.
Local lChgMat	:= .T.

Begin Sequence

	If nPosFil == 0
		SRA->( dbSetOrder( 1 ) )
		lRet := SRA->(dbSeek(xFilial("SRC")+M->RC_MAT))
	Else
		//--Quando campo Selecionado por F3 não é necessario pesquisa para achar filial
		IF ! lSetF3
			//--Valida a Matricula Digitada pela ordem somente de matricula
			//--Se existir mais de uma apresenta a Conpad para selecao do funcioanrio com a matricula informada
			//--e preenche o campo matricula da getdados.
			SRA->( dbSetOrder( RetOrdem( "SRA" , "RA_MAT" ) ) )
			lRet 	:=  SRA->(dbSeek(M->RC_MAT))
			If lRet
				nRegSra	:= SRA->(RECNO())
				//Verifica no numero de matriculas similares no SRA
				While ! Eof() .And. Sra->RA_MAT == M->RC_MAT
					If cProcesso == SRA->RA_PROCES
						nRegSra	:= SRA->(RECNO())
						nNumMat ++
					Endif
					If nNumMat > 1
						Exit
					Endif
					SRA->(dbSkip())
				Enddo

				//--Se houver apenas uma matricula preenche a filial da getdados com  a filial do cadastro
				If nNumMat <= 1 .And. nPosFil > 0
		 			SRA->(dbGoTo(nRegSra))
				//--Janela para selecionar funcionario de qual filial da matricula informada
				Elseif nNumMat > 1 .And. nPosFil > 0
					lConPad := ConPad1( NIL , NIL , NIL , "SRA03" , NIL , NIL , .F. )
				Endif
			Endif
		Endif
	Endif

	If ! lRet
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Matricula Nao Existe                		                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 	Help(" ",1,"A100NMAT")
	 	Break
	Endif

	//--Valida o Processo do Funcionario com o informado na tela
	If SRA->RA_PROCES # cProcesso
	 	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Funcionario Nao pertence ao Processo Selecionado             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 	Help(" ",1,"A100NPROC")
	 	lRet := .F.
	 	Break
	Endif

	//--Preenche o Campo Filial do Funcioanrio Selecionado
	If nPosFil > 0
		GdFieldPut("RC_FILIAL",SRA->RA_FILIAL)
	Endif

	//--Preenche o Campo NOme da Getdados com o Funcioanrio Selecionado
	//--Se mudar de matricula no registro da getdados ou for uma inclusao, alterar centro de custo e funcao
	If GdFieldPos("RC_NOME") > 0
		lChgMat := GdFieldGet( "RC_NOME") <> SRA->RA_NOME
		GdFieldPut("RC_NOME",SRA->RA_NOME)
	Endif

	//--Preenche o Campo C.Custo da Getdados com o Funcioanrio Selecionado
	If GdFieldPos("RC_CC") > 0 .And. lChgMat
		GdFieldPut("RC_CC",SRA->RA_CC)
	Endif

	//--Preenche o Funcao se exister na tabela
	If GdFieldPos("RC_CODFUNC") > 0 .and. lChgMat
		GdFieldPut("RC_CODFUNC",SRA->RA_CODFUNC)
	Endif

	If lItemCLVL
		If GdFieldPos("RC_ITEM") > 0 .And. lChgMat
			GdFieldPut("RC_ITEM",SRA->RA_ITEM)
		Endif
		If GdFieldPos("RC_CLVL") > 0 .And. lChgMat
			GdFieldPut("RC_CLVL",SRA->RA_CLVL)
		Endif
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Carrega o Conteudo do campo RC_SEMANA                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(cNumPagto)
		GdFieldPut("RC_SEMANA", cNumPagto)
	EndIf

	//--Verifica a Situacao do Empregado
	SRA->( dbSetOrder( RetOrdem("SRA") ) )
	aSitFunc := RetSituacao( SRA->RA_FILIAL, M->RC_MAT , .F. )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o Funcionario Esta Demitido                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF aSitFunc[1] == "D"
	    IF !( lRetorna := ( cLancDemi == "S" ) )

		 	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Nao Permite o Lancamento Para o Funcionario                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		 	Help(" ",1,"NOLANCDEMI")
		 	lRet := .F.
		 	Break
	    Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Permite o Lancamento Para o Funcionario                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    	Help(" ",1,"A090DEMITI")
	    EndIF

		IF aSitFunc[1] == "A"
		   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Funcionario Esta Afastado.                                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Help(" ",1,"A090AFASTA")
		ElseIF aSitFunc[1] == "F"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Funcionario Esta de F‚rias                                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Help(" ",1,"A090FERIAS")
        ElseIF aSitFunc[1] == "T"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se o Funcionario Esta de Transferido                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Help(" ",1,"A090TRANSF")
		EndIF
	EndIF

End Sequence

lSetF3	:= .F.   //--Retorna a Variavel do F3 para nova consulta
RestArea( aAreaSRA )
RestArea( aAreaSRV )

Return (lRet)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GpValidPer      ³Autor³Mauricio T. Takakura³ Data ³05/09/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validacao dos periodos - funcao Existcpo esta falhando	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Boolean                                             	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Validacao dos Periodos                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GpValidPer( cFilRCH, cProcesso, cPeriodo, cNumPagto, cRoteiro,lFocus )
Local lRet 		:= .F.
Local nOrdem 	:= 0

DEFAULT cFilRCH := xFilial( "RCH" )
DEFAULT lFocus	:= .F.

If Empty( cProcesso ) .Or. Empty( cPeriodo ).Or. Empty( cRoteiro )
	Return( lRet )
EndIf

If !(oGet == nil)  .AND. oGet:oBrowse:lActive .And. oGet:lModified .AND. !(oGet:LinhaOK())
	If !lFocus
		oGet:oBrowse:Refresh()
		Return( lRet )
	Else
		Return( .T. )
	EndIf
Else
	DbSelectArea( "RCH" )
	nOrdem := RetOrder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR")
	lRet := fPosPeriodo( cFilRCH, cProcesso, cPeriodo, cNumPagto, cRoteiro, NIL, NIL, nOrdem )
	If !lRet
		cHelp := OemToAnsi( STR0026 )//"O periodo selecionado nao Existe!        "
		Help( ' ' , 1 , "REGNOIS" , , cHelp , 1 , 0 )
	ElseIf !Empty(RCH->RCH_DTFECH)
		cHelp := OemToAnsi( STR0025 )//"O periodo selecionado ja esta fechado!"
		Help( ' ' , 1 , "PERISCLOSE" , , cHelp , 1 , 0 )
		lRet := .F.
	EndIf

EndIF

If IsInCallStack("GPEA580")
	If cRoteiro $ fGetCalcRot('2') // Roteiro de Adiantamento
		If !fVldAccess( SRA->RA_FILIAL,cPeriodo,cNumPagto,.T.,cRoteiro, "3", "V" )
			lRet := .F.
		EndIf
	ElseIf !fVldAccess( SRA->RA_FILIAL,cPeriodo,cNumPagto,.T., cRoteiro)
		lRet := .F.
	EndIf
EndIf

If !lRet
	cPeriodo:=""
	cNumPagto:=""
	cRoteiro:=""
EndIf

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GP100Filial     ³Autor³Mauro			   ³ Data ³25/11/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna a Variavel cFilial da GedDados para ser utilizada na ³
³          ³consulta SXB da Matricula									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³cFilFunc                                             	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³gpea100 e sxb			                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gp100Filial()

Local cFilFunc

If xFilial("SRV") == Space(FwSizeFilial())
	cFilFunc := GdFieldGet("RC_FILIAL")
Else
	cFilFunc := xFilial("SRA")
Endif
Return(cFilFunc)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GP100Cpo        ³Autor³Mauro			   ³ Data ³25/11/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna a Matricula informada na getdados  ser utilizada na  ³
³          ³consulta SXB da Filial										 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Campo envado do parametro da linha da getdados         	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³gpea100 e sxb			                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gp100Mat

If ( ReadVar() == "M->RC_MAT" )
	cMatricula := M->RC_MAT
ElseIf ( ReadVar() == "M->RGB_MAT" )
	cMatricula := M->RGB_MAT
EndIf

Return(cMatricula)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GP100F3         ³Autor³Mauro			   ³ Data ³25/11/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³FUNCAO PARA SETAR UMA VARIAVEL SE PASSOU NO F3				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Campo envado do parametro da linha da getdados         	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³gpea100 e sxb			                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gp100F3

Local cFiltro		:= " "
Local lGPEA100		:= isincallstack("gp100tela")

If lGPEA100
	If Versenha(114) .And. Versenha(115)
	//Caso campo Filial esteja preenchido, faz filtro pela filial escolhida.
	//Caso contrario nao filtra filial
		If !Empty(GdFieldGet("RGB_FILIAL"))
			cFiltro	:= "SRA->RA_FILIAL == '" + GdFieldGet("RGB_FILIAL") + "' .and. SRA->RA_PROCES == '" + cProcesso + "' "
		Else
			cFiltro	:= "SRA->RA_PROCES == '" + cProcesso + "' "
		EndIf
	Else
		cFiltro	:= "SRA->RA_FILIAL $ '" + cFilAnt + "' .and. SRA->RA_PROCES == '" + cProcesso + "' "
	EndIf
EndIf

If !Empty(SRV->RV_FILIAL)
	cFiltro += " .AND. AllTrim(SRV->RV_FILIAL) $ SRA->RA_FILIAL"
EndIf

lSetF3	:= .T.

cFiltro := "@#" + cFiltro + "@#"

Return(cFiltro)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GPValMatRGB  	³Autor³Igor Franzoi        ³ Data ³17/09/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validacao da matricula									     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Boolean                                             	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³campo oRoteiro da tela.                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GPValMatRGB()

Local aAreaSRA	:= SRA->( GetArea() )
Local aAreaSRV	:= SRV->( GetArea() )
Local aSitFunc	:= {}
Local nNumMat 	:= 0
Local nPosFil 	:= GdFieldPos( "RGB_FILIAL", aHeader)
Local lConPad	:= .T.
Local nRegSra	:= 0
Local lRet		:= .T.
Local lChgMat	:= .T.

Begin Sequence

	If nPosFil == 0
		SRA->( dbSetOrder( 1 ) )
		lRet := SRA->(dbSeek(xFilial("RGB")+M->RGB_MAT))
	Else
		//--Quando campo Selecionado por F3 não é necessario pesquisa para achar filial
		IF ! lSetF3
			//--Valida a Matricula Digitada pela ordem somente de matricula
			//--Se existir mais de uma apresenta a Conpad para selecao do funcioanrio com a matricula informada
			//--e preenche o campo matricula da getdados.
			SRA->( dbGoTop())
			SRA->( dbSetOrder( RetOrdem( "SRA" , "RA_MAT" ) ) )
			lRet 	:=  SRA->(dbSeek(M->RGB_MAT))
			If lRet
				//Verifica no numero de matriculas similares no SRA
				While ! SRA->(Eof()) .And. SRA->RA_MAT == M->RGB_MAT
					If cProcesso == SRA->RA_PROCES
						If Empty(GdFieldGet("RGB_FILIAL")) .OR. GdFieldGet("RGB_FILIAL") == SRA->RA_FILIAL

							If Empty(SRV->RV_FILIAL) .OR. AllTrim(SRV->RV_FILIAL) $ SRA->RA_FILIAL
								nNumMat ++
								nRegSra	:= SRA->(RECNO())
							EndIf
						EndIf

					Endif
					If nNumMat > 1
						Exit
					Endif
					SRA->(dbSkip())
				Enddo

				//--Se houver apenas uma matricula preenche a filial da getdados com  a filial do cadastro
				If nNumMat <= 1
		 			SRA->(dbGoTo(nRegSra))
				//--Janela para selecionar funcionario de qual filial da matricula informada
				ElseIf ( (nNumMat > 1) .and. (nPosFil > 0) )
					SRA->(dbGoTop())
					SRA->(dbSeek(M->RGB_MAT))
					lConPad := ConPad1( NIL , NIL , NIL , GetSx3Cache( "RGB_MAT" , "X3_F3" ) , NIL , NIL , .F. )
				EndIf
			Else
				SRA->(dbGoTo(1))
			Endif
		Endif
	Endif

	If !lRet
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Matricula Nao Existe                		                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 	Help(" ",1,"A100NMAT")
	 	Break
	Endif

	//--Valida o Processo do Funcionario com o informado na tela
	If SRA->RA_PROCES # cProcesso
	 	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Funcionario Nao pertence ao Processo Selecionado             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 	Help(" ",1,"A100NPROC")
	 	lRet := .F.
	 	Break
	Endif

	//--Preenche o Campo Filial do Funcioanrio Selecionado
	If nPosFil > 0
		//Validacao de acesso de filial do usuario
		If lRet .AND. !( AllTrim(SRA->RA_FILIAL) $ fValidFil() )
			MsgAlert(OemToansi(STR0042) ,  OemToAnsi( STR0030 ) ) //Usuario sem acesso a filial escolhida. Favor escolher outra filial.###Atencao
			lRet := .F.
		Else
			GdFieldPut("RGB_FILIAL",SRA->RA_FILIAL)
		EndIf
	Endif

	If lRet
		//--Preenche o Campo NOme da Getdados com o Funcioanrio Selecionado
		//--Se mudar de matricula no registro da getdados ou for uma inclusao, alterar centro de custo e funcao
		If GdFieldPos("RGB_NOME") > 0
			lChgMat := GdFieldGet( "RGB_NOME") <> SRA->RA_NOME
			GdFieldPut("RGB_NOME",SRA->RA_NOME)
		Endif

		If GdFieldPos("RGB_SEMANA") > 0 .AND. !Type("cNumPagto")== "U"
			GdFieldPut("RGB_SEMANA",cNumPagto)
		Endif

		//--Preenche o Campo C.Custo da Getdados com o Funcioanrio Selecionado
		If GdFieldPos("RGB_CC") > 0 .And. lChgMat
			GdFieldPut("RGB_CC",SRA->RA_CC)
		Endif

		//--Preenche o Funcao se exister na tabela
		If GdFieldPos("RGB_CODFUN") > 0 .and. lChgMat
			GdFieldPut("RGB_CODFUN",SRA->RA_CODFUNC)
		Endif

		//--Verifica a Situacao do Empregado
		SRA->( dbSetOrder( RetOrdem("SRA") ) )
		aSitFunc := RetSituacao( SRA->RA_FILIAL, M->RGB_MAT , .F. )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se o Funcionario Esta Demitido                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF aSitFunc[1] == "D"
		    IF !( lRetorna := ( cLancDemi == "S" ) )

			 	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Nao Permite o Lancamento Para o Funcionario                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			 	Help(" ",1,"NOLANCDEMI")
			 	lRet := .F.
			 	Break
		    Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Permite o Lancamento Para o Funcionario                      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		    	Help(" ",1,"A090DEMITI")
		    EndIF

			IF aSitFunc[1] == "A"
			   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Funcionario Esta Afastado.                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Help(" ",1,"A090AFASTA")
			ElseIF aSitFunc[1] == "F"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Funcionario Esta de F‚rias                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Help(" ",1,"A090FERIAS")
	        ElseIF aSitFunc[1] == "T"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se o Funcionario Esta de Transferido                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Help(" ",1,"A090TRANSF")
			EndIF
		EndIf
	EndIf

If lRet
	lRet := ( gp520PreencheDesc("FUNC_COMPLETO", M->RGB_MAT, NIL,SRA->RA_FILIAL, NIL,"F3") .AND. RgbSeqClear() )
EndIf

End Sequence

lSetF3	:= .F.   //--Retorna a Variavel do F3 para nova consulta

RestArea( aAreaSRA )
RestArea( aAreaSRV )

Return ( lRet )



/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ MenuDef		³Autor³  Luiz Gustavo     ³ Data ³03/01/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Isola opcoes de menu para que as opcoes da rotina possam    ³
³          ³ser lidas pelas bibliotecas Framework da Versao 9.12 .      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA100                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³aRotina														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

Static Function MenuDef()
	Local aRotina :=  	{}

	aAdd( aRotina, { STR0004, "PesqBrw",  0, 1} )  	//"Pesquisar"
	aAdd( aRotina, { STR0005, "Gp100Mnt", 0, 2} )  	//"Visualizar"
	aAdd( aRotina, { STR0015, "GP100Print",  0, 2} )		//"Imprimir"

Return aRotina
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fAcolsSPF ºAutor  ³Marcio Barretos     º Data ³  04/03/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se o usuario tem alguma restricao no SRA ref a    º±±
±±º          ³a matricula que sera apresentada no ACOLS (RGB)             º±±
±±º          ³se tiver tira a matricula do ACOLS                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ gpea520                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fAcolsSPF(aSRCCols)

Local aArea    := GetArea()
Local aAreaSRA := SRA->(GetArea())
Local Nx       := 0
Local Nx1      := 1
Local lDel     := .F.
Local nPos     := 0
Local cPrefixo      := ( PrefixoCpo( cLancAlias ) + "_" )
Local nPosRegWT     := GdFieldPos( cPrefixo+"REC_WT"	, aHeader)

Local nPosFil	:= IIF(cPrefixo=="RGB_",GdFieldPos( "RGB_FILIAL"		, aHeader ),GdFieldPos( "RC_FILIAL"		, aHeader ))
Local nPosMat	:= IIF(cPrefixo=="RGB_",GdFieldPos( "RGB_MAT"		, aHeader ),GdFieldPos( "RC_MAT"		, aHeader ))

Nx := Len(aSRCCols)
Do While Nx1 <= Nx
    If !Empty(aSRCCols[Nx1,nPosMat])
   	    SRA->(dbSetOrder(1))
		If !SRA->(dbSeek(aSRCCols[Nx1,nPosFil]+aSRCCols[Nx1,nPosMat]))
			nPos := ASCAN(aSRCColsRec, { |X| X == aSRCCols[Nx1][nPosRegWT] } )
			If nPos > 0
				Adel(aSRCColsRec,nPos)
				aSize(aSRCColsRec,Nx-1)
			Endif

			Adel(aSRCCols,Nx1)
			ASize(aSRCCols,Nx-1)
			lDel := .T.
			Nx := Len(aSRCCols)

		Endif
	End If
	Iif(!lDel,++Nx1,Nx1 := Nx1)
	lDel := .F.
Enddo

RestArea(aAreaSRA)
RestArea(aArea)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gp100TopSXBºAutor  ³Leandro Drumond     º Data ³  02/04/14  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Monta expressao top e botton da consulta padrao.      	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SigaGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Gp100TopSXB(nTipo)

Local cTopFun

If FunName() == "GPEA590"
	cTopFun := If(nTipo==1,"      " + xFilial("SRV"),"ZZZZZZ" + SubStr(AllTrim(xFilial("SRV")) + Replicate('Z',FWGETTAMFILIAL),1,FWGETTAMFILIAL))
Else
	cTopFun := xFilial("SRA")
EndIf

Return cTopFun


/*/{Protheus.doc} ChamaRGB
	Faz chamada de Inclusão/Alteração e Exclusão da tabela RGB
@author philipe.pompeu
@since 09/04/2015
@version P12
@param nOpcao, numérico, Opção à ser chamada
@return Nil, Valor Nulo
/*/
Static Function ChamaRGB(nOpcao)
	Local aAreaSRV	:= SRV->( GetArea() )
	Local aAreaRGB	:= RGB->( GetArea() )
	Local cValAnt	:= "SRC"

	if(Type("cLancAlias") == "U")
		Private cLancAlias:="RGB"
	Else
		cValAnt := cLancAlias
		cLancAlias:="RGB"
	endIf

	Gp100Mnt( cLancAlias , 0 , nOpcao)

	cLancAlias:=cValAnt

	RestArea(aAreaRGB)
	RestArea(aAreaSRV)
Return Nil

/*/{Protheus.doc} GP100Print
	Faz chamada da rotina de impressão
@author flavio.scorrea
@since 06/10/2018
@version P12
/*/
Function GP100Print()
	GPER101(1)
Return


/*/{Protheus.doc} PLSxGPEVLD
Verifica se algum campo de um determinado lançamento teve alteração, caso algum tenha, retorna .F.
para a validação da Linha na verificação de alteração de registro gravado pelo SIGAPLS
@type Static function
@author Oscar Zanin
@since 08/05/2019
@version 1.0
/*/
Static Function PLSxGPEVLD(aColsZ, aColsAntZ)

Local lRet	:= .T.
Local nI	:= 0

Default aColsZ 		:= {}
Default aColsAntZ	:= {}

For nI := 1 To Len(aColsZ)
	If aColsZ[nI] <> aColsAntZ[nI]
		lRet := .F.
		Exit
	endIf
Next

Return lRet
