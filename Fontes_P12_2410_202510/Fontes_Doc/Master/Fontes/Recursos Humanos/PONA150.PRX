#INCLUDE 'PONA150.CH'
#INCLUDE "PROTHEUS.CH"
#INCLUDE "PONCALEN.CH"

#DEFINE Confirma 1
#DEFINE Redigita 2
#DEFINE Abandona 3
/*
Ŀ
 Static Utilizadas na GetTabRef()	  					   	   
*/
Static __aTabRef
Static cFilStatic		//Para uso em DEFAULTFIL
/*


Ŀ
Funo     Pona150   Autor  Fernando Joly Siquini  Data  14.08.97 
Ĵ
Descrio  Manutencao das Refeies                                   
Ĵ
 Uso       Generico                                                   
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
Leandro Dr. 14/04/14      Retirada de ajustes, database e FieldPos  
                          que nao serao utilizados na P12.		  
Luis Artuso 11/02/15TRCDC1Valida abert.arqs.do Fecham.: Pn090Open() 
ٱ

*/

Function Pona150()
Private aRotina	:= MenuDef()

// - Valida se o usurio tem acesso
If BloqPer()

	Return (Nil)

EndIf

NewPona150("PONA150")
Return(Nil)

/*
Ŀ
Funo     NewPona150()	Autor                    Data 30/03/2007
Ĵ
Descrio  Programa principal separado para tratamento da funcao      
           MenuDef().                                                 
Ĵ
Sintaxe   < Vide Parametros Formais >									
Ĵ
 Uso      PONA150, PONA270                                            
Ĵ
 Retorno  aRotina														
Ĵ
Parametros< Vide Parametros Formais >									
*/
Function NewPona150(cChamada)

Local aArea			:= GetArea()
Local aIndexSRA		:= {}
Local cFiltraSRA	   := ""

Private dPerIni  	:= CtoD("//")
Private dPerFim  	:= CtoD("//")
Private cProg		:= IF( cChamada == NIL , FunName() , cChamada )
Private lPona270	:= fContemStr( cProg , "PONA270" , .T. )
Private lContinua	:= .T.

/*
Ŀ
So executa se o Modo de Acesso do SP5 e SRA foram iguais e se este  ulti
mo nao estiver vazio													 
*/
IF ( ValidArqPon() .and. ChkVazio("SRA") )

	Private bFiltraBrw	:= {|| NIL }
	Private cCadastro	:= ""
	Private cAliasP		:= ""


	IF !( lPona270 )

		cCadastro	:= OemToAnsi(STR0011) // 'Manuteno das Refeies'
		cAliasP		:=	'SP5'
	Else

		cCadastro	:= OemToAnsi(STR0021 ) // 'Manutencao Acumulado Refeies'
		cAliasP		:=	'SPN'
	EndIF


	/*
	Ŀ
	 Define o Prefixo dos Campos											 
	*/
	cPrefixo := ( PrefixoCpo( cAliasP ) + "_" )

	/*
	Ŀ
	 Inicializa o filtro utilizando a funcao FilBrowse                      
	*/
	cFiltraRh := CHKRH("PONA150","SRA","1")
	bFiltraBrw 	:= {|| FilBrowse("SRA",@aIndexSRA,@cFiltraRH) }
	Eval(bFiltraBrw)

	/*
	Ŀ
	 Endereca a funcao de BROWSE                                  
	*/
	dbSelectArea('SRA')
	mBrowse( 6, 1,22,75,"SRA",,,,,,fCriaCor() )

	/*
	Ŀ
	 Deleta o filtro utilizando a funcao FilBrowse                     	 
	*/
	EndFilBrw("SRA",aIndexSra)

	/*
	Ŀ
	 Restaura a Integridade do Sistema                            
	*/
	dbSelectArea(cAliasP)
	dbSetOrder(1)
	dbSelectArea('SRA')
	dbSetOrder(1)

EndIF

RestArea( aArea )

Return( NIL )

/*


Ŀ
Funo    PN150Atu   Autor  Fernando Joly Siquini  Data  14.08.97 
Ĵ
Descrio  Programa de Vis.,Inc.,Alt. e Del. de  Refeies            
Ĵ
Sintaxe    pn150Atu(ExpC1,ExpN1,ExpN2)                                
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       Pona150                                                    
ٱ

*/
Function pn150Atu(cAlias,nReg,nOpcx)

/*
Ŀ
Tratamento dos limites do periodo para o trabalhador corrente			 
*/
Local aMarcacoes	:= {}
Local aTabCalend	:= {}
Local aTabPadrao	:= {}

/*
Ŀ
Demais variaveis														 
*/
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aGDCoord		:= {}
Local aArea		 	:= GetArea()
Local aAreaSP	 	:= ( cAliasP)->(GetArea())
Local a150Field  	:= { cPrefixo+'FILIAL', cPrefixo+'MAT'}
Local cCC        	:= SRA->RA_CC
Local cMat       	:= SRA->RA_MAT
Local cNome      	:= SRA->RA_NOME
Local cTnoTrab   	:= SRA->RA_TNOTRAB
Local dPerIniPar	:= Ctod("//")
Local dPerFimPar	:= Ctod("//")
Local oDlg			:= NIL
Local oFont			:= NIL
Local oGroup		:= NIL
Local oPanel
Local cMsg			:= ""
Local cAviso		:= ""
Local lOfuscaNom	:= .F.
Local lOfuscaAdm	:= .F.
Local lBloqOk		:= .F.

LOCAL aFldRot 	 := {'RA_NOME', 'RA_ADMISSA'}
Local aOfusca	 := If(FindFunction('ChkOfusca'), ChkOfusca(), {.T. , .F.}) //[1] Acesso; [2]Ofusca
LOCAL aFldOfusca := {}

/*
Ŀ
Verifica se continua a Execucao apos Inclusao							 
*/
IF ( nOpcX == 3 ) .and. !( lContinua )
	lContinua := .T.
	Return( NIL )
EndIF

/*
Ŀ
Tratamento dos limites do periodo para o trabalhador corrente			 
*/
Private uPerIni
Private uPerFim

/*
Ŀ
Demais variaveis														 
*/
Private aAC       		:= {STR0003 , STR0001 } // 'Abandona'###'Confirma'
Private aColsAnt  		:= {}
Private aColsRec  		:= {}
Private aVirtual  		:= {}
Private cPD		  		:= ""
Private cPDEmpr	  		:= ""
Private oGet

//Bloco para reorganizar as linhas por Hora Final + Hora Inicio
Private bSort	  := { |x,y|	Dtos(x[nPosData])		+ 	;
									 x[nPosTipoRef]		+   ;
									 x[nPosSeqMarc]		< 	;
								Dtos(y[nPosData])		+ 	;
									 y[nPosTipoRef]	  	+	;
									 y[nPosSeqMarc]	 }

/*
Ŀ
Quando For Acumulado Verifica o Periodo que foi previamente  Selecionado
pelo Usuario													 		 
*/
IF ( lPona270 )
	dPerIni := SPO->PO_DATAINI
	dPerFim := SPO->PO_DATAFIM
	IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		Help( "" , 1 , "SPONOTPERC" )
		Return( .F. )
	EndIF
Else
	/*
	Ŀ
	Caso Contrario Verifica se o Periodo eh Valido atraves de CheckPonmes() 
	*/
	IF !( CheckPonMes( @dPerIni , @dPerFim , .F. , .T. , !lPona270 ) )
		Return( .F. )
	EndIF

	//-- Verifica se foi possivel abrir os arquivos sem exclusividade
	If ! Pn090Open(@cMsg, @cAviso, .T.,DtoS(dPerIni) + DtoS(dPerFim))
		MsgStop( cMsg, cAviso )
		Return( .F. )
	Else
		lBloqOk := .T.
	EndIf
EndIF

/*
Ŀ
Valida o Periodo de Apontamento para Digitacao das Informacoes          
*/
IF !( GetPonMesDat( @dPerIniPar , @dPerFimPar ) .and. ValidPonData(dPerIni,"P",dPerIniPar,dPerFimPar,lPona270,.T.) )
	Return( .F. )
EndIF

//--Restaura Alias com o Alias em Manutencao
cAlias:=cAliasP

dbSelectArea(cAliasP)
dbSetOrder(2)

//Carrega Codigo de Evento Desc.Parte Funcionario com identificador igual a "016A"
cPD		:=	PosSP9("016A",SRA->RA_FILIAL,"P9_CODIGO",2)
//Carrega Codigo de Evento Desc.Parte Empresa com identificador igual a "015A"
cPDEmpr :=	PosSP9("015A",SRA->RA_FILIAL,"P9_CODIGO",2)

/*
Ŀ
 Monta as Dimensoes dos Objetos         					   
*/
aAdvSize		:= MsAdvSize()
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 000 , 020 , .T. , .F. } )
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

//Ŀ
// Monta a entrada de dados do arquivo                          
//
Private nUsado   	:= 0
Private aHeader  	:= {}
Private aCols    	:= {}

/*/
Ŀ
 Carrega o Calendario de Marcacoes do Funcionario            
/*/
IF !GetMarcacoes(	@aMarcacoes							,;	//01 -> Marcacoes dos Funcionarios
					@aTabCalend							,;	//02 -> Calendario de Marcacoes
					@aTabPadrao							,;	//03 -> Tabela Padrao
					NIL     							,;	//04 -> Turnos de Trabalho
					dPerIni					 			,;	//05 -> Periodo Inicial
					dPerFim								,;	//06 -> Periodo Final
					SRA->RA_FILIAL						,;	//07 -> Filial
					SRA->RA_MAT							,;	//08 -> Matricula
					SRA->RA_TNOTRAB						,;	//09 -> Turno
					SRA->RA_SEQTURN						,;	//10 -> Sequencia de Turno
					SRA->RA_CC							,;	//11 -> Centro de Custo
					If(cAliasP=="SP5", "SP8", "SPG")	,;	//12 -> Alias para Carga das Marcacoes
					.T.									,;	//13 -> Se carrega Recno em aMarcacoes
					.T.		 							;	//14 -> Se considera Apenas Ordenadas
				  )
	Help(" ",1,"TPADNCAD")
	Return( .F. )
EndIF

/*/
Ŀ
 Limite Periodo Incicial											  
/*/
uPerIni	:= GetInfoPosTab( CALEND_POS_LIM_MARCACAO , "1E" , dPerIni , aTabCalend )
uPerIni	:= DataHora2Str( uPerIni[1] , uPerIni[2] )
/*/
Ŀ
 Limite Periodo Final    											  
/*/
uPerFim	:= GetInfoPosTab( CALEND_POS_LIM_MARCACAO , "__LASTMARC__" , dPerFim , aTabCalend )
uPerFim	:= DataHora2Str( uPerFim[1] , uPerFim[2] )
//Ŀ
// Inicializa os Campos para o aHeader							 
//
aHeader := GdMontaHeader( @nUsado , @aVirtual , NIL , cAliasP , a150Field )

//Ŀ
// Inicializa Variaveis de Localizacao de Campos no aHeader     
//
Private nPosTipoRef	:= GdFieldPos( cPrefixo+"TIPOREF" 	)
Private nPosData	:= GdFieldPos( cPrefixo+"DATA" 		)
Private nPosDescRef	:= GdFieldPos( cPrefixo+"DESCREF" 	)
Private nPosSeqMarc	:= GdFieldPos( cPrefixo+"SEQMARC" 	)
Private nPosSeq		:= GdFieldPos( cPrefixo+"SEQ" 		)
Private nPosFlag	:= GdFieldPos( cPrefixo+"FLAG" 		)
Private nPosValRef	:= GdFieldPos( cPrefixo+"VALREF"		)
Private nPosDescFun	:= GdFieldPos( cPrefixo+"DESCFUN"		)
Private nPosPD		:= GdFieldPos( cPrefixo+"PD" 			)
Private nPosPDEmpr	:= GdFieldPos( cPrefixo+"PDEMPR"		)
Private nPosGeraFol	:= GdFieldPos( cPrefixo+"GERAFOL" 	)
Private nPosCodRef	:= GdFieldPos( cPrefixo+"CODREF"		)
Private nPosHora	:= GdFieldPos( cPrefixo+"HORA"		)
Private nPosAponta	:= GdFieldPos( cPrefixo+"APONTA"		)
Private nPosRelogio	:= GdFieldPos( cPrefixo+"RELOGIO"		)


//Ŀ
// Gerar o array aCols com os Eventos                          
//
If !Pn150aCols( A150fIELD , nOpcX )
	Return( NIL )
EndIf

//Ŀ
// Posiciona ponteiro do arquivo cabeca e inicializa variaveis  
//
nOpcA := 0

//Ordena as Linhas de Registros
aSort(aCols,,, bSort )
aColsAnt := aClone(aCols)

nOpca := 0

//Tratamento dados sensveis
If aOfusca[2]
	aFldOfusca 	:= FwProtectedDataUtil():UsrNoAccessFieldsInList( aFldRot ) // CAMPOS SEM ACESSO
	IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_NOME" } ) > 0 
		lOfuscaNom	:= FwProtectedDataUtil():IsFieldInList( "RA_NOME" )
	ENDIF
	IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_ADMISSA" } ) > 0 
		lOfuscaAdm := FwProtectedDataUtil():IsFieldInList( "RA_ADMISSA" )
	ENDIF	
EndIf

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg TITLE cCadastro From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL	// "Manuteno das Refeies"

	@ aObjSize[1,1] , aObjSize[1,2] GROUP oGroup TO ( aObjSize[1,3] ),(( aObjSize[1,4])*0.18 )			LABEL OemToAnsi(STR0017) OF oDlg PIXEL	// "Matricula:"
	oGroup:oFont:= oFont
	@ aObjSize[1,1] , (( aObjSize[1,4])*0.185 ) GROUP oGroup TO aObjSize[1,3],((aObjSize[1,4])*0.87)	LABEL OemToAnsi(STR0018) OF oDlg PIXEL	// "Nome:"
	oGroup:oFont:= oFont
	@ aObjSize[1,1] , ((aObjSize[1,4])*0.875) GROUP oGroup TO aObjSize[1,3] ,aObjSize[1,4]				LABEL OemToAnsi(STR0012) OF oDlg PIXEL	// "Admisso:"
	oGroup:oFont:= oFont

	@ ((aObjSize[1,1]) +10) , ((aObjSize[1,2]) * 2.5)	SAY StrZero(Val(SRA->RA_MAT),TamSx3("RA_MAT    ")[1])	SIZE 050,10 OF oDlg PIXEL FONT oFont
	@ ((aObjSize[1,1]) +10) , ((aObjSize[1,4]) * 0.2)	SAY If(lOfuscaNom,Replicate('*',15),OemToAnsi(SRA->RA_NOME)) 	SIZE 146,10 OF oDlg PIXEL FONT oFont
	@ ((aObjSize[1,1]) +10) , ((aObjSize[1,4]) * 0.89)	SAY If(lOfuscaAdm,Replicate('*',10),Dtoc(SRA->RA_ADMISSA))		SIZE 050,10 OF oDlg PIXEL FONT oFont

	oGet := MsGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],nOpcx,'aPont150Ok' ,'pn150TudOk' ,'',If(nOpcx=2.Or.nOpcx=5,NIL,.T.),,1,,1000)

ACTIVATE MSDIALOG oDlg ON INIT ( EnchoiceBar(oDlg,{|| nOpca:=1,If(oGet:TudoOk(),oDlg:End(),nOpca:=0)},{||oDlg:End()}),)

IF ( nOpcA == Confirma ) .And. ( nOpcx # 2 )
	If ( ( nOpcX == 3 ) .Or. ( nOpcX == 4 ) )
		//-- Gravao
		pn150Grava(cAliasP)
	Else
		//-- Excluso
		pn150Exclu(cAliasP)
	EndIf
	//--Processa Gatilhos
	EvalTrigger()
EndIF

//Exclui registro de bloqueio lgico
If lBloqOk
	Pnm090UnlockPer( SRA->RA_FILIAL, .F., DtoS(dPerIni) + DtoS(dPerFim), SRA->RA_MAT )
EndIf

//Ŀ
// Restaura a integridade da janela                             
//
RestArea(aAreaSP)
RestArea(aArea)

dbSelectArea("SRA")

/*
Ŀ
 Nao retorna para a inclusao confirmacao                      
*/
IF ( ( Type( "Inclui" ) == "L" ) .and. ( Inclui ) )
	lContinua := .F.
EndIF

RstGetRefeicao()
Return( NIL )

/*


Ŀ
Funo    Pn150aCols Autor  Fernando Joly          Data  14/08/97 
Ĵ
Descrio  Criar o Array aCols da Refeies                           
Ĵ
 Uso       Pona150o                                                   
ٱ

*/
Static Function Pn150aCols( a150Field , nOpcX )

Local aQueryCond	:= {}

Local bSkip			:= {|| NIL }
Local cFil			:= xFilial( cAliasP  , SRA->RA_FILIAL )
Local cMat			:= SRA->RA_MAT
Local nLenRec		:= 0.00
Local nX	 		:= 0.00
Local lRet			:= .T.

/*/
Ŀ
 Condicao         											  
/*/
bSkip	:= { |cDataHora| cDataHora := DataHora2Str( ( &(cPrefixo+"DATA")) , (&(cPrefixo+"HORA")) ) , ( ( cDataHora < uPerIni ) .or. ( cDataHora > uPerFim ) ) }

/*
Ŀ
 Monta Query para a Selecao das Informacoes                   
*/
aQueryCond		:= Array( 09 )
aQueryCond[01]	:= cPrefixo + "FILIAL='"+cFil+"'"
aQueryCond[02]	:= " AND "
aQueryCond[03]	:= cPrefixo + "MAT='"+cMat+"'"
aQueryCond[04]	:= " AND "
aQueryCond[05]	:= cPrefixo + "DATA>='"+Dtos( dPerIni - 7 ) +"'"
aQueryCond[06]	:= " AND "
aQueryCond[07]	:= cPrefixo + "DATA<='"+Dtos( dPerFim + 7) +"'"
aQueryCond[08]	:= " AND "
aQueryCond[09]	:= "D_E_L_E_T_=' ' "

/*
Ŀ
 Monta Detalhe                                  			   
*/
aCols := GdMontaCols(aHeader,nUsado,aVirtual,NIL,cAliasP,a150Field,@aColsRec,cAliasP,(cFil+cMat),NIL,bSkip,NIL,NIL,NIL,NIL,NIL,NIL,aQueryCond,.F.,.T.)

//Carrega a Descricao das Refeicoes
IF ( ( nLenRec := Len(aColsRec) ) > 0.00 )
	For nX := 1 To nLenRec
		aCols[ nX , nPosDescRef ] := fDesc("SPM",aCols[ nX , nPosTipoRef ],"PM_DESCREF",TamSx3(cPrefixo+"DESCREF")[1] )
	Next nX
EndIF

//-- Incluso com Registros
If ( ( nOpcX == 3 ) .and. ( nLenRec > 0 ) )
	Help(" ",1,"a150CAPO")
	lRet := .F.
//-- Visualizao, Alterao ou Excluso sem Registros
ElseIf ( ( nOpcX == 2 ) .and. ( nLenRec == 0 ) ) .or. ;
	   ( ( nOpcX == 4 ) .and. ( nLenRec == 0 ) ) .or. ;
	   ( ( nOpcX == 5 ) .and. ( nLenRec == 0 ) )
	Help(" ",1,"a150SAPO")
	lRet := .F.
EndIf

If ( ( nOpcX == 3 ) .and. ( lRet ) )
	aAdd( aColsRec , 0 ) //-- Guarda localizao do registro
	//-- Preenche Flag de Refeicao com informado "I"
	If ( nPosFLAG > 0 )
		aCols[Len(aCols), nPosFlag] := "I"
	EndIf
	//-- Preenche PD com o Codigo da Folha com identificador "016A"
	If ( nPosPD > 0 )
		aCols[Len(aCols), nPosPD] := cPD
	EndIf
	//-- Preenche PDEmpr com o Codigo da Folha com identificador "015A"
	If ( nPosPDEmpr > 0 )
		aCols[Len(aCols), nPosPDEmpr] := cPDEmpr
	EndIf
EndIf

Return(lRet)

/*


Ŀ
Funo    PN150Grava Autor  Fernando Joly          Data  14.08.97 
Ĵ
Descrio  Grava no arquivo de Refeies                              
Ĵ
 Uso       Pona150                                                    
ٱ

*/
Function pn150Grava(cAlias)

Local aArea   		:= GetArea()
Local nX      		:= 0
Local nY      		:= 0
Local cCampo  		:= ''
Local cChave		:= ''
Local cFil    		:= If(Empty(xFilial(cAliasP)),xFilial(cAliasP),SRA->RA_FILIAL)
Local cDataTipo		:=	''
Local cTraba  		:= ''
Local cMsgErr		:= ""
Local dData   		:= CtoD('  /  /  ')
Local lLock			:= .F.
Local naColsAnt		:= Len(aColsAnt)
Local naCols		:= Len(aCols)
Local nSeqMarc		:= 0
//-- Verifica se Houve Alguma Alteracao para prosseguir com alteracoes
If (fCompArray(aCols,aColsAnt))
	RestArea(aArea)
   	Return(Nil)
Endif

dbSelectArea(cAliasP)


//-- Altera Flag de Refeicao se necessario
For nX := 1 to naCols //-- Linhas
   	If  nX  <=naColsAnt

        //fCompArray retorna .T. se nao houve alteracao nas informacoes do registro
        //Para informacao alterada seta flag para informado "I"
        //Para informacao NAO alterada permanece FLAG
        //Se For Marcacao Nova
        If Empty(aColsRec[nX])
           	aCols[nX,nPosFlag]:="I"
        Else
           	If fCompArray(aCols[nX],aColsAnt[nX])
           	    	aCols[nX,nPosFlag]:=aColsAnt[nX,nPosFlag]
           	Else
           		aCols[nX,nPosFlag]:="M"
           	Endif
        Endif
	Else
        //Se foram adicionados outras refeicoes, campo Flag setado para informado "I"
        	aCols[nX,nPosFlag]:="I"
	Endif

Next nX

//Ordena as Linhas do aCols (Registros)
aSort(aCols,,, bSort )

Begin Transaction

	For nX := 1 to Len(aCols) //-- Linhas

		nReg := If(nX<=Len(aColsAnt),aColsRec[nX],0)

		//-- Incluses j deletadas so ignoradas
		If nReg == 0 .And. aCols[nX,Len(aCols[nX])]
			Loop
		EndIf

		//-- Determina se  Alterao ou Incluso
		If nReg > 0
			( cAliasP )->( dbGoto(nReg) )
			lLock := RecLock(cAliasP)
		Else
			lLock := RecLock(cAliasP,.T.)
		EndIf

		IF !( lLock )
			Loop
		EndIF


		//-- Inclui / Altera
		If !aCols[nX,Len(aCols[nX])]

			For nY := 1 to ( Len(aCols[nX]) - 1 ) //-- Colunas
				cCampo    := aHeader[nY,2]
				xConteudo := aCols[nX,nY]
				If aScan(aVirtual, cCampo) == 0
					&cCampo := xConteudo
				EndIf
			Next nY

			//-- Campos no mostrados na Tela ( a150Field )
			// -- { 'P5_FILIAL', 'P5_MAT' }
			IF nReg == 0
				&(cAliasP+"->"+cPrefixo+"FILIAL") 	:= cFil
				&(cAliasP+"->"+cPrefixo+"MAT")	 	:= SRA->RA_MAT
			EndIF

			//--	ReGera Sequencia
			   cChave:= Dtos(aCols[nX,nPosData]) + aCols[nX,nPosTipoRef]

				If  cChave # cDataTipo
					cDataTipo 	:= cChave
					nSeqMarc		:=	0
				Endif

				nSeqMarc++

				//Regrava Seq Marcacao de Refeicao
				&(cAliasP+"->"+cPrefixo+"SeqMarc") := StrZero(nSeqMarc,2)

			//-- Deleta
		Else
			IF !( cAliasP )->( FkDelete( @cMsgErr ) )
				( cAliasP )->( RollBackDelTran( cMsgErr ) )
			EndIF
		EndIf

		( cAliasP )->( MsUnLock() )

	Next nX

End Transaction

RestArea(aArea)

Return( NIL )

/*


Ŀ
Funo    PN150Exclu Autor  Fernando Joly          Data  14.08.97 
Ĵ
Descrio  Exclui registros de refeies                              
Ĵ
 Uso       Pona150                                                    
ٱ

*/
Function Pn150Exclu(cAlias)

Local aArea		:= GetArea()
Local cMsgErr	:= ""
Local nX		:= 0
Local nXs		:= Len(aCols)

dbSelectArea(cAliasP)
For nX := 1 To nXs //-- Linhas

	nReg := If(nX<=Len(aColsAnt),aColsRec[nX],0)

	IF nReg > 0
		( cAliasP )->( dbGoto(nReg) )
		IF ( cAliasP )->( RecLock( cAliasP ) )
			IF !( cAliasP )->( FkDelete( @cMsgErr ) )
				( cAliasP )->( RollBackDelTran( cMsgErr ) )
			EndIF
			( cAliasP )->( MsUnLock() )
		EndIF
	EndIF

Next nX

RestArea( aArea )

Return( NIL )

/*


Ŀ
                   ROTINAS DE CRITICA DE CAMPOS                        
ٱ




Ŀ
Funo    aPont150Ok Autor  Fernando Joly Siquini  Data  14/08/97 
Ĵ
Descrio Critica linha digitada                                      
Ĵ
 Uso       Generico                                                   
ٱ

*/
Function Apont150Ok(o)

Local aArea		:=	GetArea()
Local aAreaSP1	:=	SP1->(GetArea())
Local aTabRef	:= {}
Local cHora    	:= ''
Local cDataHora := ''
Local cRelogio 	:= ''
Local cHelp		:= ""
Local dData    	:= CtoD('  /  /  ')
Local lRet     	:= .T.
Local cFilSP1   := fFilFunc("SP1")
Local nPos     	:= 0.00
Local nPosRef	:= 0.00
Local nErroRef 	:= 0.00
Local naHeader	:= LEN(aHeader)
Local nW		:= 0
Local nX		:= 0


If !aCols[n,Len(aCols[n])]
    Begin Sequence


		//-- Nao permite campos em branco
	   	If  fVazio(n)
			lRet := .F.
			Break
		Endif

		//Nao permite Informar Data Fora do Periodo
		IF nPosData > 0 .and. nPosHora > 0
		 	cDataHora:= DataHora2Str( aCols[n,nPosData], aCols[n,nPosHora] )
			If !(lRet := ( ( cDataHora <= uPerFim  ) .AND. ( cDataHora >= uPerIni )  ) )
				cHelp += ( OemToAnsi( STR0026 ) + Space(1)+ CRLF )							//'Data e Hora do lanamento no esto'   	'
				cHelp += ( OemToAnsi( STR0027 ) + Space(1)+ CRLF )							//'compreendidos pelos limites do'
				cHelp += ( OemToAnsi( STR0028 )	 + Space(1)+ CRLF )							//'perodo de apontamento:'
				cHelp +=  Dtoc( STR2DataHora(uPerIni)[1] ) + SPACE(1) + (STRZERO(STR2DataHora(uPerIni)[2] ,5,2))+  OemToAnsi( STR0030 ) + Space(1) + CRLF
				cHelp +=  STR0029 + Space(1) + CRLF  	//' a '
				cHelp +=  Dtoc( STR2DataHora(uPerFim)[1] ) + SPACE(1) + (STRZERO(STR2DataHora(uPerFim)[2] ,5,2))+  OemToAnsi( STR0030 ) + Space(1) + CRLF
				Help( " " , 1 , "NOVALIDPER" , , cHelp , 1 , 0 )
			Endif
		EndIF

		//Nao permite duplicidade de Data + Tipo Ref + Seq.Marcacao
		If !Pna150VTp()
		  	lRet := .F.
			Help(' ',1,'PONA15001')
			Break
		Endif

		//-- Preenche PD com o Codigo da Folha Parte Funcionario com identificador "016A"
		If nPosPD > 0
			If Empty(aCols[n,nPosPD])
				aCols[n, nPosPD] := cPD
			Endif
		EndIf
		//-- Preenche PDEmpr com o Codigo da Folha Parte Empresa com identificador "015A"
		If nPosPDEmpr > 0
			If Empty(aCols[n,nPosPDEmpr])
				aCols[n, nPosPDEmpr] := cPDEmpr
			Endif
		EndIf

		//-- Preenche APONTA com "NAO"
		If nPosAponta > 0
			If Empty(aCols[n,nPosAponta])
				aCols[n, nPosAponta] := "N"
			Endif
		EndIf

		//-- Tipos diferentes de ZZ sao consistidos
		If aCols[n, nPosTipoRef]<>"ZZ"
		    //-- Carrega a Tabela de Refeicao conforme o Codigo informado
		    GetTabRef(@aTabRef, cFilSP1,aCols[n, nPosCodRef])
	        cRelogio:= aCols[n,nPosRelogio]
	    	//-- Verifica se a Hora esta no intervalo de acordo com CodRef+TipoRef+Relogio
	        nPosRef:=Ascan(aTabRef,{|xTab| ( xTab[2] == aCols[n, nPosTipoRef] ) .AND. ;
	        					            xTab[6] == aCols[n,nPosRelogio];
	        			            };
	        	          )
	       	If Empty(nPosRef)
	       	    cRelogio:= SPACE(LEN(aCols[n,nPosRelogio]))
	       		//-- Verifica se a Hora esta no intervalo de acordo com CodRef+TipoRef+Relogio
	        	nPosRef:=Ascan(aTabRef,{|xTab| ( xTab[2] == aCols[n, nPosTipoRef] ) .AND. ;
	        						              xTab[6] == SPACE(Len(xTab[6]));
	        				            };
	        		          )
	       Endif
	       //-- Se Encontrou o Tipo de Refeicao
	       lRet:= .F.
	       If ( nPosRef > 0.00 )
		      nLenRef:= Len(aTabRef)

		      For nX:=nPosRef To nLenRef
				  	If (aTabRef[nX,2] == aCols[n,nPosTipoRef]) .AND. ;
				  		If(!EMPTY(cRelogio), aCols[n,nPosRelogio]==cRelogio, .T.)
					  	If (lRet:=Pna150Hor(Ctod("01/05/01"),aTabRef[nX,3], aTabRef[nX,4], aCols[n,nPosHora]) )
					  	   Exit
					  	Endif
					Endif
		      Next nX
	       Endif

	       //-- Se nao foi encontrado o codigo da refeicao ou se a hora informada nao esta contida nos horarios
	       //-- do codigo da refeicao encontrado
	       If !lRet
	          If ( Empty(nPosRef) )
	           	    cHelp:=STR0025
           	    	cHelp += Space(01) + CRLF
           	    	cHelp += Space(01) + CRLF
           	    	cHelp += Space(01) + CRLF
           	    	cHelp += Space(01) + CRLF
           	    	cHelp += Space(01) + CRLF

					Help( ' ' , 2 , 'PONA15003' ,,  OemToAnsi( cHelp ),1,0)
	          Else
		      		Help(' ',1,'PONA15003')
		      Endif
			  Break
		   Endif
	    Endif
	End Sequence
	oGet:Refresh()
EndIf

RestArea(aAreaSP1)
RestArea(aArea)

Return( lRet )

/*


Ŀ
Funo    pn150TudOk Autor  Fernando joly Siquini  Data  14/08/97 
Ĵ
Descrio Critica tudo antes de salvar                                
Ĵ
 Uso       Generico                                                   
ٱ

*/
Function pn150TudOk(o)

Local aArea	   := GetArea()
Local lRet     := .T.
Local nX       := 0
Local cHelp    := ""

For nX := 1 to Len(aCols)
	If !aCols[nX,Len(aCols[nX])]



		//-- Nao permite campos em branco
	   	If  fVazio(nX)
			lRet := .F.
			Break
		Endif

		//-- Preenche PD com o Codigo da Folha com identificador "016A"
		If nPosPD > 0
			If Empty(aCols[nX,nPosPD])
				aCols[nX, nPosPD] := cPD
			Endif
		EndIf

		//-- Preenche PDEmpr com o Codigo da Folha Parte Empresa com identificador "015A"
		If nPosPDEmpr > 0
			If Empty(aCols[nX,nPosPDEmpr])
				aCols[nX, nPosPDEmpr] := cPDEmpr
			Endif
		EndIf

		//-- Preenche APONTA com "NAO"
		If nPosAponta > 0
			If Empty(aCols[nX,nPosAponta])
				aCols[nX, nPosAponta] := "N"
			Endif
		EndIf

		//Nao permite Informar Data Fora do Periodo
		IF nPosData > 0
			IF nPosData > 0
		 		cDataHora:= ( DataHora2Str( aCols[nX,nPosData], aCols[nX,nPosHora] ) )

				If !(lRet := ( ( cDataHora <= uPerFim  ) .AND. ( cDataHora >= uPerIni )  ) )
					cHelp += ( OemToAnsi( STR0026 ) + Space(1)+ CRLF )							//'Data e Hora do lanamento no esto'   	'
					cHelp += ( OemToAnsi( STR0027 ) + Space(1)+ CRLF )							//'compreendidos pelos limites do'
					cHelp += ( OemToAnsi( STR0028 )	 + Space(1)+ CRLF )							//'perodo de apontamento:'
					cHelp +=  Dtoc( STR2DataHora(uPerIni)[1] ) + SPACE(1) + (STRZERO(STR2DataHora(uPerIni)[2] ,5,2))+  OemToAnsi( STR0030 ) + Space(1) + CRLF
					cHelp +=  STR0029 + Space(1) + CRLF  	//' a '
					cHelp +=  Dtoc( STR2DataHora(uPerFim)[1] ) + SPACE(1) + (STRZERO(STR2DataHora(uPerFim)[2] ,5,2))+  OemToAnsi( STR0030 ) + Space(1) + CRLF
					Help( " " , 1 , "NOVALIDPER" , , cHelp , 1 , 0 )
				Endif

			EndIF
		EndIF

	EndIf
Next nX

RestArea(aArea)

Return( lRet )

/*


Ŀ
Funo    fVazio     Autor  Mauricio MR            Data  18/06/04 
Ĵ
Descrio  Valida Colunas em Branco                                   
Ĵ
 Uso       Generico                                                   
ٱ

*/
Static Function fVazio(nline)
Local lRet		:= .F.
Local aCampos	:= {'P5_DATA','P5_GERAFOL','P5_TIPOREF'}

If !( aCols[nLine][nPosTipoRef] == 'ZZ')
   aCpoNEmpty:= {'P5_CODREF','P5_SEQ'}
   Aeval(aCpoNEmpty,{|cCpo| AADD(aCampos, cCpo) } )
Endif

If  !GDNOEMPTY(aCampos,nline)
    lRet:= .T.
Endif

Return lRet

/*


Ŀ
Funo    Pna150Dtp  Autor  Mauricio MR            Data  10.08.01 
Ĵ
Descrio  Retorna a Descricao dos Tipos de Refeicoes        		  
Ĵ
 Uso       Pna150                                                     
Ĵ
Retorno   .T./.F.													  
ٱ

*/
Function Pna150Dtp()

Local cVar := 	&(ReadVar())
Local lRet :=	.T.

//--Alimenta a Descricao do Tipo de Refeicao
aCols[ n , nPosDescRef ] := fDesc("SPM",cVar,"PM_DESCREF",TamSx3(cPrefixo+"DESCREF")[1] )

Return( lRet )

/*


Ŀ
Funo    Pna150VTp  Autor  Maurico MR             Data  04.08.01 
Ĵ
Descrio  Valida  Tipo de Ref. 				  					  
Ĵ
 Uso       PonA150                                                    
Ĵ
Retorno   .T./.F.													  
ٱ

*/
Function Pna150VTp()
Local cRelAtual	:= ''
Local cRelOutros:= ''
Local nElem		:=	0
Local nTotElem	:= Len(aCols)
Local lRet		:=	.T.

For nElem:=1 to nTotElem

	If nPosRelogio > 0.00
	   cRelAtual := aCols[n     ,nPosRelogio]
	   cRelOutros:= aCols[nElem ,nPosRelogio]
	Endif

	If 	( (Dtos(aCols[n    ,nPosData]) +  aCols[n    ,nPosTipoRef] +  aCols[n    ,nPosSeqMarc] + cRelAtual) == ;
	      (Dtos(aCols[nElem,nPosData]) +  aCols[nElem,nPosTipoRef] +  aCols[nElem,nPosSeqMarc] + cRelOutros) ) ;
	 	.and. nElem<> n   .And.  !aCols[nElem][Len(aCols[1])] ;
	 	.AND. !EMPTY(aCols[n,nPosSeqMarc])
	   lRet:=.F.
	   Exit
	Endif
Next

Return( lRet )

/*


Ŀ
Funo    Pna150Seq  Autor  Maurico MR             Data  09/08/01 
Ĵ
Descrio  Busca Seq de Refeicao de acordo com CodRef+TipoRef         
Ĵ
 Uso       PonA150                                                    
ٱ

*/
Function Pna150Seq()
Local aColsTipo		:= {}
Local lRet			:= .T.
Local cDataTipo		:= ''
Local cVariavel		:= ReadVar()
Local cVar			:= &(cVariavel)
Local cVarTipo		:= ''
Local dVarData		:= Ctod('')
Local cChave		:= ''
Local cSP1Fil		:= xFilial("SP1")
Local nX			:= 0.00
Local nLenaCols		:= 0.00
Local nSeqMarc		:= 0.00
Local nPos			:= 0.00

If cVariavel=="M->"+cPrefixo+"CODREF"
   	cChave	:= cVar+aCols[n,nPosTipoRef]
ElseIf cVariavel=="M->"+cPrefixo+"TIPOREF"
    cChave	:= aCols[n,nPosCodRef]+cVar
Endif

If ( cVariavel=="M->"+cPrefixo+"TIPOREF" )
	cVar					:= aCols[n,nPosSeq]
	cVarTipo				:= &( cVariavel )
	dVarData				:= aCols[n, nPosData]
	aCols[n,nPosSeq]		:= fDesc("SP1",cChave,"P1_SEQ",TamSx3("P1_SEQ")[1],NIL,2)
	aCols[n,nPosGeraFol]	:= fDesc("SP1",cChave,"P1_GERAFOL",TamSx3("P1_GERAFOL")[1],NIL,2)

ElseIf (cVariavel == "M->"+cPrefixo+"DATA" )
	   cVarTipo				:= aCols[n, nPosTipoRef]
       dVarData				:= &( cVariavel )

Endif


If ( ( ( cVariavel=="M->"+cPrefixo+"TIPOREF")  .AND.   ( cVarTipo <> aCols[n, nPosTipoRef] ) ) .OR.  ;
     ( ( cVariavel=="M->"+cPrefixo+"DATA"   )  .AND.   ( dVarData <> aCols[n, nPosData]    )  .AND. !EMPTY(aCols[n,nPosTipoRef] ) ) ;
   )



	aColsTipo	:={}
	aAux		:={}
	nPos		:=0.00
	Aeval(aCols,{|X|nPos++, If(x[nPosTipoRef] == cVarTipo .AND. ;
	                            x[nPosData]    == dVarData .AND. npos <> n,;
	                            (aAux:=aclone(x),AADD(aColsTipo,aAux),AADD(aColsTipo[Len(aColsTipo)],nPos)), Nil)})
	nLenaCols	:= Len(aColsTipo)
	nSeqMarc	:= 0.00

	If !Empty(nLenaCols)
		aSort(aColsTipo,,, bSort )
		nPos		:=Len(aColsTipo[1])
		For nX:=1 To 	nLenaCols
		   //--	ReGera Sequencia
		   cChave:= Dtos(aColsTipo[nX,nPosData]) + aColsTipo[nX,nPosTipoRef]
		   If  cChave # cDataTipo
	           cDataTipo 	:= cChave
	           nSeqMarc		:=	0
	       Endif

	       nSeqMarc++

		    //Regrava Seq Marcacao de Refeicao
		    aCols[aColsTipo[nX,nPos],nPosSeqMarc] := StrZero(nSeqMarc,2)
		Next nX
	Endif

	aCols[n,nPosSeqMarc]:=StrZero(nSeqMarc+1,2)

Endif

Return( lRet )

/*


Ŀ
Funo    Pna150VSeq Autor  Maurico MR             Data  09/08/01 
Ĵ
Descrio  Valida Seq de Refeicao de acordo com CodRef+TipoRef        
Ĵ
 Uso       PonA150                                                    
ٱ

*/
Function Pna150VSeq()

Local lRet := .T.
Local cVar := &(ReadVar())

//-- Para Tipos Ref diferentes de 'ZZ' consite sequencia
If cVar # "ZZ"
	//Se a Chave CodRef+TipoRef nao e valida retorna False
	If Empty(aCols[n,nPosSeq])
		Help(' ',1,'PONA15002') //Combinacao CodRef+TipoRef Nao Cadastrada
		lRet:=.F.
	Endif
Endif

If lRet
	//Preenche Codigo PD - Funcionario
	//Se deixado em branco  ou  for nova marcacao
	If  Empty(aCols[ n , nPosPD]) .OR. ;
	    ( (Empty(aColsRec[1]) .OR. n>Len(aColsRec)) .AND. aCols[ n , nPosFlag] == "I" )
		aCols[ n , nPosPD] := fDesc("SPM",cVar,"PM_PD",TamSx3("PM_PD")[1])
	Endif
	//Preenche Codigo PD - Empresa
	//Se deixado em branco  ou  for nova marcacao
	If  Empty(aCols[ n , nPosPDEmpr]) .OR.;
	    ( (Empty(aColsRec[1]) .OR. n>Len(aColsRec)) .AND. aCols[ n , nPosFlag] == "I" )
		aCols[ n , nPosPDEmpr] := fDesc("SPM",cVar,"PM_PDEMPR",TamSx3("PM_PDEMPR")[1])
	Endif
Endif

Return( lRet )

/*


Ŀ
Funo    Pna150VRef Autor  Maurico MR             Data  09/08/01 
Ĵ
Descrio  Gatilho Valor da Refeicao de acordo com CodRef+TipoRef     
Ĵ
 Uso       PonA150                                                    
ٱ

*/
Function Pna150VRef()

Local cVar		:=	(ReadVar())
Local nValRef	:=	0
Local lRet		:= .T.

//Se for Gatilho a Partir do Tipo Ref
If cVar == "M->"+cPrefixo+"TIPOREF"
    //Conteudo de cVar igual a M->P?_TipoRef
    cVar := &cVar

	// Obtem Valor Integral da Refeicao
	// Somente Para Nova Marcacao e Flag igual a Informado
	If  (Empty(aColsRec[1]) .OR. n>Len(aColsRec)) .AND. aCols[ n , nPosFlag] == "I"
	   	aCols[ n , nPosValRef] := Posicione("SPM",1,fFilFunc("SPM")+cVar,"PM_VALREF")
	Endif
	nValRef	:=	aCols[ n , nPosValRef]
Else
    //Se For Valid a Partir do P?_Valref
    //Conteudo de cVar igual ao de  P?_TipoRef armazenado no Acols correspondente
    cVar 	:= 	aCols[n, nPosTipoRef]
    nValRef	:= &("M->"+cPrefixo+"VALREF"    )
Endif

//Calcula Valor de Desc Parte Funcionario
If  (Empty(aColsRec[1]) .OR. n>Len(aColsRec)) .AND. aCols[ n , nPosFlag] == "I"
     	aCols[ n , nPosDescFun] := ROUND(nValRef *;
	         ( Posicione("SPM",1,fFilFunc("SPM")+cVar,"PM_PERCFUN") / 100),2)
Endif

Return( lRet )

/*


Ŀ
Funo    Pna150Hor  Autor  Maurico MR             Data  15.08.01 
Ĵ
Descrio  Localiza Hora dentro de um Intervalo de Horas   		      
Ĵ
 Uso       PonA150                                                    
Ĵ
Parametros dData -> Data ficticia                        		      
           nHoraI-> Hora Iniicio do Intervalo               	      
           nHoraF-> Hora Fim do Intervalo                		      
           nHora -> Hora a ser enquadrada                		      
ٱ

*/
Function Pna150Hor(dDate,nHoraI, nHoraF, nHora)

Local dDDay     := CtoD('01/01/95','ddmmyy')
Local lRet		:= 	.T.
Local nSerIni   := 	0.00
Local nSerFim	:=	0.00
Local nSerHora	:=	0.00

IF dDate == Nil
	dDate := dDDay
ElseIF ValType(dDate) # 'D'
	dDate := dDDay
ElseIF dDate < dDDay
	dDate := dDDay
EndIF

nSerHora:= fDhToNs(dDate , nHora)
nSerIni := fDhToNs(dDate , nHoraI)
nSerFim := fDhToNs(dDate , nHoraF)

//-- Caso o intervalo abrange de um dia a outro soma mais um na data da hora fim
If nSerFim<nSerIni
   nSerFim := fDhToNs(dDate+1 , nHoraF)
Endif

//-- Caso a Hora seja do Dia Seguinte
If nSerHora<nSerIni
   nSerHora := fDhToNs(dDate+1 , nHora)
Endif

//-- Verifica se Hora Esta dentro do Intervalo
If !(nSerHora >= nSerIni .And. nSerHora <= nSerFim )
   lRet:=.F.
Endif

Return( lRet )

/*


Ŀ
Funo    Pna150Cod  Autor  Maurico MR             Data  20/08/01 
Ĵ
Descrio  Consiste Codigo de Refeicao 						          
Ĵ
 Uso       PonA150                                                    
ٱ

*/
Function Pna150Cod()
Local lRet			:= .T.
Local cVariavel		:= 	&(ReadVar())

//-- Qdo o CodRef Informado estiver "Vazio"
If Empty(cVariavel)
   //-- Para Tipo "ZZ" permite
   If aCols[n, nPosTipoRef] == 'ZZ'
      lRet	:=	.T.
   Else
      //-- Para Tipos # "ZZ" nao permite
      lRet	:=	.F.
   Endif
Else
	//-- Verifica se Cod.Ref. existe na Tabela de Refeicao
	If !ExistCpo('SP1',cVariavel)
	  	lRet	:=	.F.
	Endif
Endif

Return( lRet )

/*


Ŀ
Funo    Pna150DFun Autor  Maurico MR             Data  24/08/01 
Ĵ
Descrio  Valida Valor Desc.Ref. Funcionario					      
Ĵ
 Uso       PonA150                                                    
ٱ

*/
Function Pna150DFun()

Local cVar	:=	&(ReadVar()) //Desconto Refeicao Parte Funcionario
Local lRet	:= .T.

//-- Nao Permite Desconto negativo ou Desconto maior que o Valor Integral da Refeicao
IF ( cVar < 0 .OR. cVar > aCols[ n , nPosValRef] )
   lRet:=.F.
Endif

Return (lRet)
/*
Ŀ
Funo    GetTabRef	 Autor Mauricio MR            Data 11/10/2003
Ĵ
Descrio Carrega Array com os Tipos de Refeicao                       
Ĵ
Sintaxe   <Vide Parametros Formais>									 
Ĵ
Parametros<Vide Parametros Formais>									 
Ĵ
Retorno   lRet      -> True se Conseguir Carregar os Tipos de Refeicao 
Ĵ
Uso       Apontamento e Manutencao de Refeicoes                        
*/
Function GetTabRef(		aTabRef			,;	//Array a ser Carregado com os Tipos de H.E.
						cFil			,;	//Filial para Pesquisa
						cCodRef			;   //Codigo da Refeicao a Pesquisar
				 )

Local baScan		:= { || .T. }
Local cAlias		:= "SP1"
Local cAliasQuery	:= cAlias
Local cPrefixo		:= ( PrefixoCpo( cAlias ) + "_" )
Local lRet			:= .F.
Local lModFil		:= .F.
Local nPos			:= 0.00
Local nOrder		:= 2
Local nSvOrder		:= SP1->( IndexOrd() )

Local cQuery		:= ""
Local cSvAlias		:= Alias()
Local lQueryOpened	:= .F.
Local nX			:= 0.00

Static aSp1Fields
Static cQrySp1Fields
Static nSp1Fields

DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT __aTabRef	:= {}

cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )

DEFAULT aSp1Fields := ( cAlias )->( dbStruct() )
DEFAULT nSp1Fields := Len( aSp1Fields )

IF ( cQrySp1Fields == NIL )
	cQrySp1Fields := ""
	For nX := 1 To nSp1Fields
		cQrySp1Fields += aSp1Fields[ nX , 01 ] + ", "
	Next nX
EndIF

/*
Ŀ
Se eh a primeira vez ou ocorreu quebra de filial E NAO    foi
para escalonar Obtem o parametro de escalonamento			  
*/
IF ( lModFil := ( ( cFilStatic == NIL )  .or. ( cFilStatic != cFil    ) ) )
	cFilStatic 		:= 	cFil
EndIF

aTabRef		:= {}

baScan		:= { |x| ( x[1] == cFil .or. Empty( x[1] ) )	;
					  .and.									;
					 ( x[2] == cCodRef )    				;
			   }

cFil := xFilial( cAlias , cFil )

IF ( Empty( __aTabRef ) .or. ( ( nPos := aScan( __aTabRef , baScan ) ) == 0.00 ) )


	IF !( nOrder == nSvOrder )
		( cAlias )->( dbSetOrder( nOrder ) )
	EndIF

    //-- Monta Query para Top
	cQuery := "SELECT "
	cQuery += cQrySp1Fields
	cQuery := SubStr( cQuery , 1 , Len( cQuery ) - 2 )
	cQuery += " FROM "
	cQuery += InitSqlName( cAlias )
	cQuery += " WHERE "
	cQuery += cPrefixo+"FILIAL='"+cFil+"'"
	cQuery += " AND "
	cQuery += cPrefixo+"CODREF='"+cCodRef+"'"
	cQuery += " AND "
	cQuery += "D_E_L_E_T_=' ' "
	cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
	cQuery		:= ChangeQuery( cQuery )
	IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
		For nX := 1 To nSp1Fields
			IF !( aSp1Fields[ nX , 02 ] == "C" )
				TcSetField(cAliasQuery,aSp1Fields[nX,01],aSp1Fields[nX,02],aSp1Fields[nX,03],aSp1Fields[nX,04])
			EndIF
		Next nX
		lRet := ( cAliasQuery )->( !Eof() )
	Else
		cAliasQuery := cAlias
		lRet := ( cAliasQuery )->( dbSeek( cFil + cCodRef ) )
	EndIF

	IF ( ( lRet ) .and. ( Select( cAliasQuery ) > 0.00 ) )
		aAdd( __aTabRef , { cFil , cCodRef , {} } )
		While ( cAliasQuery )->( !Eof() .and. ( cFil == P1_FILIAL .and. cCodRef == P1_CODREF ) )
			/*
			Ŀ
			Carrega a Tabela de Refeicao								  
			*/
			( cAliasQuery )->( aAdd( __aTabRef[ Len( __aTabRef ) , 3 ] , {P1_SEQ , P1_TIPOREF , P1_HORAINI , P1_HORAFIM , P1_GERAFOL } ) )

			//-- Se Existir o Campo Relogio adiciona-o
			( cAliasQuery )->( aAdd( __aTabRef[ Len( __aTabRef ) , 3, LEN( __aTabRef[ Len( __aTabRef ) , 3] )] , P1_RELOGIO ) )

			( cAliasQuery )->( dbSkip() )
		End While

		/*
		Ŀ
		Se Estiver Ok Posiciona na Tabela de Refeicao Solicitada 	  
		*/
		IF ( lRet )
		 	nPos := aScan( __aTabRef , baScan )
		EndIF
	EndIF

	IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0.00 ) )
		( cAliasQuery )->( dbCloseArea() )
	EndIF

	IF !( nOrder == nSvOrder )
		( cAlias )->( dbSetOrder( nSvOrder ) )
	EndIF

EndIF

IF ( lRet := ( nPos > 0.00 ) )
	aTabRef := aClone( __aTabRef[ nPos , 3 ] )
EndIF

/*
Ŀ
Garante o Fechamento da Query no retorno da funcao           
*/
IF ( Select( cAliasQuery ) > 0.00 )
	( cAliasQuery )->( dbCloseArea() )
EndIF
/*
Ŀ
Restaura dados de Entrada                                    
*/
IF Select( cSvAlias ) > 0.00
	dbSelectArea( cSvAlias )
EndIF

Return( lRet )

/*
Ŀ
Funo    RstGetRefeicao 	AutorMauricio MR 		   Data 11/11/2003
Ĵ
Descrio Reinicializa as Staticas utilizadas em GetTabRef()   		
Ĵ
Sintaxe   <Vide Parametros Formais>									
Ĵ
Parametros<Vide Parametros Formais>									
Ĵ
Uso       Generico													
*/
Function RstGetRefeicao()

__aTabRef			:= NIL
cFilStatic			:= NIL

Return( NIL )
/*


Ŀ
Funo    Pn150XP1   Autor  Maurico MR             Data  30/04/04 
Ĵ
Descrio  Trata Retorno do SXB									      
Ĵ
 Uso       PonA150                                                    
ٱ

*/
Function Pn150XP1()

aCols[n,nPosGeraFol]	:= SP1->P1_GERAFOL
aCols[n,nPosRelogio]	:= SP1->P1_RELOGIO

Return(SP1->P1_SEQ)

/*
Ŀ
Funo     MenuDef		Autor  Luiz Gustavo      Data 29/11/2006
Ĵ
Descrio Isola opcoes de menu para que as opcoes da rotina possam    
          ser lidas pelas bibliotecas Framework da Versao 9.12 .      
Ĵ
Sintaxe   < Vide Parametros Formais >									
Ĵ
 Uso      PONA150                                                     
Ĵ
 Retorno  aRotina														
Ĵ
Parametros< Vide Parametros Formais >									
*/

Static Function MenuDef()
/*
	Ŀ
	 Define array contendo as Rotinas a executar do programa      
	 ----------- Elementos contidos por dimensao ------------     
	 1. Nome a aparecer no cabecalho                              
	 2. Nome da Rotina associada                                  
	 3. Usado pela rotina                                         
	 4. Tipo de Transao a ser efetuada                          
	    1 - Pesquisa e Posiciona em um Banco de Dados             
	    2 - Simplesmente Mostra os Campos                         
	    3 - Inclui registros no Bancos de Dados                   
	    4 - Altera o registro corrente                            
	    5 - Remove o registro corrente do Banco de Dados          
	*/
Local aRotina	:= {}

aRotina		:= {	{ STR0004 , 'PesqBrw'  		, 0 , 1 , ,.F.},;	//'Pesquisar'
					{ STR0005 , 'pn150Atu' 		, 0 , 2 },;			//'Visualizar'
					{ STR0007 , 'pn150Atu' 		, 0 , 3,,,.T. },;	//'Incluir'
					{ STR0009 , 'pn150Atu' 		, 0 , 4 },;			//'Alterar'
					{ STR0010 , 'pn150Atu' 		, 0 , 5 },;			//'Excluir'
					{ STR0020 , "gpLegend" 		, 0 , 6 , ,.F.};	//'Legenda'
				}

Return aRotina
