#INCLUDE "TOTVS.CH"
#INCLUDE "HEADERGD.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "GPEA161.CH"

Static nTamSeq			:= GetSx3Cache( "RM_SEQ" , "X3_TAMANHO" )
Static lExibeGetDados	:= .T.
Static lManutence	    := ( FunName() == "GPEA160M")
Static lCopia			:= .F.
Static aTempLine		:= {}
	
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GPEA161  ³ Autor ³ Leandro Drumond       ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Cadastro de Verbas por Processo - Modelo 2                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³M. Silveira ³15/09/15³TTCQQ8³Inclusao de validacao na linha do roteiro ³±±
±±³            ³        ³      ³p/ impedir o cadastro de verbas iguais com³±±
±±³            ³        ³      ³geracao de acumulacao diferente.          ³±±
±±³gSantacruz  ³09/12/15³pcdef2³Se corrigio que los conceptos borrados    ³±±
±±³            ³        ³015_20³en el grid los borrara de la tabla srm    ³±±
±±³            ³        ³16-773³                                          ³±±
±±³Alf. Medrano³31/10/16³TSSERM³Merge 12.1.14                             ³±±
±±³            ³        ³I01-27³se modifica tamaño cuadro dialogo,se      ³±±
±±³            ³        ³      ³agrega título combos en func fRelacProc   ³±±
±±³            ³        ³      ³se agrega Validación índice para Chile en ³±±
±±³            ³        ³      ³func Gp160NewAtu. se modifica funcion     ³±±
±±³            ³        ³      ³Gp160ValidSelect se agrega condicion      ³±±
±±³            ³        ³      ³para Colombia no imprime RM_LEEBEN .      ³±±
±±³            ³        ³      ³Genera cChave antes de Borrar en func.    ³±±
±±³            ³        ³      ³OnCommit                                  ³±±
±±³Oscar Garcia³05/12/18³DMINA-³En función OnCommit() se realiza ajuste de³±±
±±³            ³        ³4677  ³la secuencia al guardar, así como la elim-³±±
±±³            ³        ³      ³inación de registros de la tabla SRM      ³±±
±±³Luis Eduardo³08/11/19³DMINA-³Ajuste para importación de tipos de proce-³±±
±±³            ³        ³7533  ³dimientos y conceptos por procesos están- ³±±
±±³            ³        ³      ³dar para paíse de MI.                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Gpea161()
	         
Local oBrwRGA
Local cFiltraRh
Local cMsgYesNo
Local cFuncion	:= "FCARGRGX" //Función utilizada para cargar Estándar de Periodos de MI.

lExibeGetDados := !( FunName() == "GPEA161A" )
lManutence	   := ( FunName() == "GPEA160M")

If( MV_MODFOL != "2" )
	Help("",1,"NAO_DISPONIVEL",,OemToAnsi(STR0003),5,0 ) //"Verifique o parametro MV_MODFOL!"
	Return( NIL )
EndIf

If lManutence
	If lImpForm
		fCarVPP()
		IIf(cPaisLoc <> "BRA" .And. FindFunction(cFuncion), fCargRGX(Nil,Nil,Nil,.T.), Help("", 1, "OBJECTRPO", , STR0081 + cFuncion + "().", 1, 0)) //"Rutina desactualizada, solicite paquete con actualizaciones: "
	EndIf
ElseIf lExibeGetDados
	If !ChkVazio("RC3",.F.)
	/*/ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	   ³ Formulas Padroes              										 ³
	   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		MsAguarde({|| GpIniForm()}, OemToAnsi(STR0050))	//"Inicializando as Fórmulas Padrões..."
	EndIf
	If !ChkVazio("SRM",.F.)
		cMsgYesNo	:= OemToAnsi(;
									STR0051 + ;	// "Não há dados na tabela SRM"
									CRLF	+ ;	
									STR0052 ;	// "Deseja importar os dados padrões?"
	                                )
		If MsgYesNo(OemToAnsi(cMsgYesNo) , If(lExibeGetDados,OemToAnsi(STR0001),OemToAnsi(STR0002)) + " - " + OemToAnsi(STR0013)) // "Atenção"	
			If FindFunction("GPVPP" + cPaisLoc)
				fCarVPP(Nil,Nil,Nil,.T.)
			Else
				MsgAlert( OemToAnsi(STR0070) + cPaisLoc + OemToAnsi(STR0033) + CRLF + OemToAnsi(STR0023), OemToAnsi(STR0013)) // "El programa GPVPP" + cPaisLoc +".PRX não está compilado."  ### "Favor verificar!" ###"Atenção!"
			EndIf

			IIf(cPaisLoc <> "BRA" .And. FindFunction(cFuncion), fCargRGX(Nil,Nil,Nil,.T.), Help("", 1, "OBJECTRPO", , STR0081 + cFuncion + "().", 1, 0)) //"Rutina desactualizada, solicite paquete con actualizaciones: "
			
		EndIf
	EndIf
EndIf

oBrwRGA := FwMBrowse():New()
oBrwRGA:SetAlias( 'RGA' )
oBrwRGA:SetDescription(If(lExibeGetDados,OemToAnsi(STR0001),OemToAnsi(STR0002))) 		//"Verbas por Processo"	### "Roteiros por Processo"

cFiltraRh	:= CHKRH(FunName(),"RGA","1")

oBrwRGA:SetFilterDefault(cFiltraRh)   
    
oBrwRGA:Activate()

Return NIL

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³Gpea161	|Autor	|Leandro Drumond		 |Data|12/11/12	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Executa rotina Roteiros por Processo.               		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³Gpea161A()												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Generico 					  	   				          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gpea161A()

lExibeGetDados := .F.
aRotina := FWLoadMenuDef( 'GPEA161' )

Gpea161() //Chamada da rotina Roteiros por processo, getdados nao sera exibida.

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MenuDef    ³ Autor ³ Leandro Drumond       ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Menu Funcional                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MenuDef()                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MenuDef()

	Local aRotina   := {}

	ADD OPTION aRotina TITLE STR0004	ACTION 'PesqBrw'			OPERATION 1 ACCESS 0 	//"Pesquisar"
	ADD OPTION aRotina TITLE STR0005	ACTION 'VIEWDEF.GPEA161'	OPERATION 2 ACCESS 0	//"Visualizar"
	ADD OPTION aRotina TITLE STR0006	ACTION 'VIEWDEF.GPEA161'	OPERATION 3 ACCESS 0	//"Incluir"
	ADD OPTION aRotina TITLE STR0007	ACTION 'VIEWDEF.GPEA161'	OPERATION 4 ACCESS 0	//"Alterar"
	ADD OPTION aRotina TITLE STR0008	ACTION 'VIEWDEF.GPEA161'	OPERATION 5 ACCESS 0	//"Excluir"
	
	If lExibeGetDados
		ADD OPTION aRotina TITLE STR0010	ACTION 'fCarVPP'	OPERATION 6 ACCESS 0	//"Carrega Verbas por Processo"
		ADD OPTION aRotina TITLE STR0009	ACTION 'Gpea161Cpy'	OPERATION 9 ACCESS 0		//"Copiar"		
		If ( FunName() == "GPEA160M")
			ADD OPTION aRotina TITLE STR0011	ACTION 'Gp160GerVPP'		OPERATION 10 ACCESS 0	//"Gerar Verbas por Processo"
		EndIf
	EndIf

Return aRotina

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ModelDef   ³ Autor ³ Leandro Drumond       ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Modelo de dados e Regras de Preenchimento               		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ModelDef()                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function ModelDef()
Local oStructRGA
Local oStructSRM
Local oModel
Local bOnCommit:= {|oModel|OnCommit(oModel)}
Local bLinePre := {|oModelGrid, nLine, cAction, cField| If(cField == "RM_VERBA",Gpea161MkLin(oModelGrid, nLine, cAction, cField),.T.)}
Local bLinePost:= {|oModelGrid, nLine| Gpea161lOk(oModelGrid, nLine)}

oModel:= MpFormModel():New("GPEA161", /*Pre-Validacao*/, { |oModel| Gpea161ExistKey( oModel ) } /*Pos-Validacao*/, bOnCommit/*Commit*/, /*Cancel*/)

oStructRGA := FWFormStruct(1,"RGA")
oModel:AddFields("GPEA161_RGA", /*cOwner*/, oStructRGA , /*Pre-Validacao*/,/*Pos-Validacao*/,/*Carga*/)

oStructRGA:SetProperty( 'RGA_PROCES' , MODEL_FIELD_WHEN , {||oModel:GetOperation() == MODEL_OPERATION_INSERT})
oStructRGA:SetProperty( 'RGA_CALCUL' , MODEL_FIELD_WHEN , {||oModel:GetOperation() == MODEL_OPERATION_INSERT})
oStructRGA:SetProperty( 'RGA_MODULO' , MODEL_FIELD_WHEN , {||oModel:GetOperation() == MODEL_OPERATION_INSERT})

oModel:SetPrimaryKey( { "RGA_FILIAL", "RGA_PROCES", "RGA_CALCUL" } )

If lExibeGetDados
	If cPaisLoc == "PAR"
		oStructSRM := FWFormStruct(1,"SRM",{|cCampo| AllTrim(cCampo)+"|" $ "RM_FILIAL|RM_VERSAO|RM_PROCES|RM_CALCULO|RM_SUBSEQ|RM_CHAVE|RM_SEQ|RM_DESCFOR|RM_DESCPD|RM_VERBA|RM_CODFOR|RM_CODCRI|RM_GERAACU|RM_LEEINC|RM_LEEPRE|RM_LEEACU|RM_LEEAUS|RM_LEEBEN|RM_LEEFIX|RM_HABILIT|"})
	Else
		oStructSRM := FWFormStruct(1,"SRM",{|cCampo| AllTrim(cCampo)+"|" $ "RM_FILIAL|RM_VERSAO|RM_PROCES|RM_CALCULO|RM_SUBSEQ|RM_CHAVE|RM_SEQ|RM_DESCFOR|RM_DESCPD|RM_VERBA|RM_CODFOR|RM_CODCRI|RM_GERAACU|RM_LEEINC|RM_LEEPRE|RM_LEEACU|RM_LEEAUS|RM_LEEBEN|RM_LEEFIX|"})
	EndIf
	oModel:AddGrid("GPEA161_SRM", "GPEA161_RGA"/*cOwner*/, oStructSRM , bLinePre, bLinePost, /*bPre*/, /*bPost*/,/*bLoad*/)
	oModel:GetModel('GPEA161_SRM'):SetOptional(.T.)
	oModel:GetModel('GPEA161_SRM'):SetUseOldGrid()
	oModel:SetRelation("GPEA161_SRM",{{"RM_FILIAL",'xFilial("SRM")'},{"RM_PROCES","RGA_PROCES"},{"RM_CALCULO","RGA_CALCUL"}},SRM->(IndexKey(2)))
EndIf

Return(oModel)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ViewDef    ³ Autor ³ Leandro Drumond       ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Visualizador de dados da rotina.               				³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ViewDef()                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function ViewDef()

Local oModel
Local oStructRGA
Local oStructSRM
Local oView

oModel     := FwLoadModel("GPEA161")

oView := FWFormView():New()

oView:SetModel(oModel)

oStructRGA := FWFormStruct(2,"RGA")
oStructRGA:SetNoFolder()

oView:AddField( "GPEA161_RGA" , oStructRGA )

If lExibeGetDados
	If cPaisLoc == "PAR"
		oStructSRM := FWFormStruct(2,"SRM",{|cCampo| AllTrim(cCampo)+"|" $ "RM_SEQ|RM_CHAVE|RM_DESCFOR|RM_DESCPD|RM_VERBA|RM_CODFOR|RM_CODCRI|RM_GERAACU|RM_LEEINC|RM_LEEPRE|RM_LEEACU|RM_LEEAUS|RM_LEEBEN|RM_LEEFIX|RM_HABILIT|"})
	Else
		oStructSRM := FWFormStruct(2,"SRM",{|cCampo| AllTrim(cCampo)+"|" $ "RM_SEQ|RM_CHAVE|RM_DESCFOR|RM_DESCPD|RM_VERBA|RM_CODFOR|RM_CODCRI|RM_GERAACU|RM_LEEINC|RM_LEEPRE|RM_LEEACU|RM_LEEAUS|RM_LEEBEN|RM_LEEFIX|"})
	EndIf
	oView:AddGrid(  "GPEA161_SRM" , oStructSRM )
	oStructSRM:RemoveField('RM_CHAVE')
	oView:AddIncrementField( 'GPEA161_SRM', 'RM_SEQ' )
	
	oView:createHorizontalBox("FORMFIELD",20)
	oView:createHorizontalBox("GRID"     ,80)
Else
	oView:createHorizontalBox("FORMFIELD",60)
EndIf

oView:SetOwnerView( "GPEA161_RGA","FORMFIELD")

oView:AddUserButton(OemToAnsi(STR0062), 'CLIPS', {|oView|InsertLine(oView)} )//Inserir Linha
oView:AddUserButton(OemToAnsi(STR0063), 'CLIPS', {|oView|fLocaliza("", "SRM", {"RM_FORMULA" } ) } ) //Localizar referencia cruzada
oView:AddUserButton(OemToAnsi(STR0064), 'CLIPS', {|oView|CopyLine(oView)} )//Copiar
oView:AddUserButton(OemToAnsi(STR0065), 'CLIPS', {|oView|PasteLine(oView)} ) //Colar
oView:AddUserButton(OemToAnsi(STR0004), 'CLIPS', {|oView|FindRecord(oView)} ) //Buscar


If lExibeGetDados
	oView:SetOwnerView( "GPEA161_SRM","GRID")
EndIf

Return(oView)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea161Cpy     ³ Autor ³ Leandro Drumond    ³ Data ³ 13/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ 									              				³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Gpea161Cpy()			                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ GPEA161          		                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Gpea161Cpy()
Local cTitulo		:= If(lExibeGetDados,OemToAnsi(STR0001),OemToAnsi(STR0002)) 		//"Verbas por Processo"	### "Roteiros por Processo"
Local nOperation 	:= 9 // Define o modo de operacao como ALTERACAO
lCopia := .T.

FWExecView(cTitulo,'VIEWDEF.GPEA161',nOperation,/*oDlg*/,{||.T.}/*bCloseOnOk*/,/*bOk*/,/*nPercReducao*/)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea161MkLin   ³ Autor ³ Leandro Drumond    ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ 									              				³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Gpea161MkLin(oModel)                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ GPEA161          		                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Gpea161MkLin(oGrid, nLine, cAcao, cField)
Local oModel 	:= FWModelActivate()
Local nOperacao := oModel:GetOperation()
Local oGridRGA 	:= oModel:GetModel("GPEA161_RGA")

If oGrid:IsInserted() .and. !(nOperacao == MODEL_OPERATION_DELETE)
	oGrid:LoadValue("RM_CALCULO",oGridRGA:GetValue("RGA_CALCUL"))
EndIf

Return .T.

/*/{Protheus.doc} Gpea161lOk
	Valida a Linha incluida ou alterada no Grid
@author JOSE.SILVEIRA
@since 15/09/2015
@version P12
@param oView, objeto, instância de FWFormView
@return lRet, lógico, se é valido
@obs	TTE665, função reformulada, gerava stack overflow, além disso função
SeekLine estava sendo usada errôneamente.
/*/
Static Function Gpea161lOk(oGrid, nLine )
	Local oModel 	:= FWModelActivate()
	Local cCodPd 	:= ""
	Local cCodCrit	:= 0
	Local aArea		:= {}
	Local aSaveLin	:= {}
	Local nLinAtu	:= 0
	Local lRet 		:= .T.
	Local bTemp		:= {||.T.}
	Local nTemp		:= 0

	nLinAtu := oGrid:nLine
	 	
	If !oGrid:IsDeleted() .And. nLinAtu > 0 
		
		/*Impede que ocorra um stack overflow por mudarmos de linha no bloco de código
		que valida a mudança de linha.*/
		bTemp := oGrid:bLinePost
		oGrid:bLinePost := {||.T.}
			
		cCodPd 	:= oGrid:GetValue("RM_VERBA")
		cCodCrit 	:= oGrid:GetValue("RM_CODCRI")
		nCodAcu 	:= oGrid:GetValue("RM_GERAACU")
		aArea		:= GetArea()
		aSaveLin	:= FWSaveRows()
			
		for nTemp:= 1 to oGrid:Length()
			oGrid:GoLine(nTemp)		
			if(!oGrid:IsDeleted() .And. oGrid:nLine != nLinAtu)
				if(oGrid:GetValue("RM_VERBA") == cCodPd .And. oGrid:GetValue("RM_CODCRI") == cCodCrit)
					if !(cPaisLoc $ "ARG*COL") .And. (oGrid:GetValue("RM_GERAACU") != nCodAcu)
						//Essa verba ja está cadastrada com geração de acumulação diferente.
						Help(" ",1,"Help",,cCodPd + ' -  ' + OemToAnsi(STR0066) ,2,0)
						lRet := .F.
						Exit
					ElseIf cPaisLoc == "COL" .And.  oGrid:GetValue("RM_GERAACU") == nCodAcu
						//Essa verba ja está cadastrada com o mesmo valor de geração de acumulação.
						Help(,1,"Help",,cCodPd + '  -  ' + OemToAnsi(STR0080),1,0)
						lRet := .F.
						Exit
					endIf
				endIf
			endIf	
		next
	
		FWRestRows(aSaveLin)
		aSize(aSaveLin,0)
		aSaveLin := Nil
		
		oGrid:bLinePost :=  bTemp
		RestArea(aArea)
				
	EndIf
Return(lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea161ExistKey³ Autor ³ Leandro Drumond    ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ 									              				³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Gpea161ExistKey(oModel)                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ GPEA161          		                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Gpea161ExistKey(oModel)
Local cQuery	:= ''
Local cProcSRM 	:= ''
Local cCalcSRM 	:= ''
Local cVersao 	:= Replicate( "0" , GetSx3Cache( "RM_VERSAO" , "X3_TAMANHO" ) )
Local lRet 		:= .T.
Local nOperacao := oModel:GetOperation()
Local nCnt		:= 0
Local nSeqSRM	:= 0
Local oGridRGA 	:= oModel:GetModel("GPEA161_RGA")
Local oGridSRM 	:= If(lExibeGetDados,oModel:GetModel("GPEA161_SRM"),Nil)

Private cKeySRM			:= ""

If Empty(cKeySRM)
	cKeySRM			:= fGetLastKeySRM()
EndIf

If nOperacao == MODEL_OPERATION_INSERT
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existe algum dado no arquivo                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cQuery := " SELECT COUNT(*) TOTAL "
	cQuery += " FROM "+	RetSqlName("RGA")
	cQuery += " WHERE RGA_FILIAL = '" + xFilial("RGA") + "' AND "
	cQuery += "       RGA_PROCES = '" + oGridRGA:GetValue("RGA_PROCES") + "' AND "
	cQuery += "       RGA_CALCUL = '" + oGridRGA:GetValue("RGA_CALCUL") + "' AND "
	cQuery += " D_E_L_E_T_ = ' ' "		
			
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), 'QRGA', .F., .T.)
	dbSelectArea("QRGA")
	nCnt := QRGA->TOTAL
	dbCloseArea()
		
	If nCnt > 0
		MsgAlert( OemToAnsi(STR0012) , OemToAnsi( STR0013 ) ) // "Chave ja existe. Por favor, selecionar outro Processo e Roteiro."#"Atencao"
	    lRet := .F.
	EndIf
ElseIf nOperacao == MODEL_OPERATION_DELETE .and. !lExibeGetDados
	lRet := Gpea161ExcluChk( oGridRGA , nOperacao )
EndIf

If lRet .and. ( nOperacao == MODEL_OPERATION_INSERT .or. nOperacao == MODEL_OPERATION_UPDATE ) .and. lExibeGetDados
    
	If lCopia
		cProcSRM := oGridRGA:GetValue("RGA_PROCES")
		cCalcSRM := oGridRGA:GetValue("RGA_CALCUL")
	EndIf
	
	For nCnt := 1 To oGridSRM:Length()
		oGridSRM:GoLine( nCnt )
		If lCopia
			oGridSRM:LoadValue("RM_PROCES",cProcSRM)
			oGridSRM:LoadValue("RM_CALCULO",cCalcSRM)
		EndIf
		
		If lManutence .and. oGridSRM:IsUpdated()
			If (Empty(oGridSRM:GetValue("RM_CHAVE",nCnt)))
				cKeySRM := Soma1(cKeySRM)
				oGridSRM:LoadValue("RM_CHAVE","NI"+cKeySRM)
			EndIf
			
			If nOperacao == MODEL_OPERATION_UPDATE
				cVersao := oGridSRM:GetValue("RM_VERSAO",nCnt)
				If Empty( cVersao )
					cVersao := Replicate( "0" , GetSx3Cache( "RM_VERSAO" , "X3_TAMANHO" ) )
				EndIf
			EndIf
			cVersao := Soma1(cVersao)
			oGridSRM:LoadValue("RM_VERSAO",cVersao)
		EndIf
		
		nSeqSRM := Val( oGridSRM:GetValue("RM_SEQ",nCnt) )
		
		If ( ( nSeqSRM % 10 ) # 0 )
			oGridSRM:LoadValue("RM_SEQ",StrZero( nSeqSRM , nTamSeq ))
		EndIf
	Next nCnt
EndIf

If lRet .and. lCopia
	lCopia := .F.
EndIf
	
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RmVerbaVld     ³ Autor ³ Leandro Drumond    ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Validar o conteudo do campo RM_VERBA (Mexico)					³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ RmVerbaVld()       		                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ X3_VALID do campo RM_VERBA                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function RmVerbaVld()
Local lRet      := .T.
Local lGpea160	:= .F.
Local oModel 	:= FWModelActivate()
Local oGrid  	:= Nil

lGpea160 := ValType(oModel) == "U"  //GPEA160 nao eh MVC

If!lGpea160
	oGrid := oModel:GetModel("GPEA161_SRM")
EndIf

Begin Sequence
	
	If MV_MODFOL == "2"
		If !( lRet := NaoVazio() )
			Break
		EndIf
	Else
		If ( lRet := Vazio() )
			Break
		EndIf	
	EndIf

	If !( lRet := ExistCpo("SRV", If(lGpea160, &(ReadVar()),oGrid:GetValue("RM_VERBA")) ) )
		Break
	EndIf

End Sequence

Return( lRet  )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RmCodForVld    ³ Autor ³ Leandro Drumond    ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Validar o conteudo do campo RM_CODFOR (Mexico)				³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³RmCodForVld()       		                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³X3_VALID do campo RM_CODFOR                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function RmCodForVld()

Local lRet
Local oModel := FWModelActivate()
Local oGrid  := oModel:GetModel("GPEA161_SRM")

Begin Sequence
	
	If !( lRet := NaoVazio() )
		Break
	EndIf

	If !( lRet := ExistCpo("RC2", oGrid:GetValue("RM_CODFOR"),2,"NOEXISTFRM") )
		Break
	EndIf

End Sequence

Return( lRet  )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fVldDtInic     ³ Autor ³ Leandro Drumond    ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida o campo RGA_DTINIC 									³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fVldDtInic()       		                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³SX3- RGA_DTINIC			                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function  fVldDtInic() 

Local lRet		:= .T.
Local dDtInic	:= &(Readvar()) 
                    
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Dt de inicio do periodo nao pode ser maior que a data inicial³
³ do ano + dias do periodo                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If (MV_MODFOL=="2") 
	If Empty( M->RGA_PDPERI) .and. !Empty(dDtInic) 
		MsgAlert( OemToAnsi( STR0020 ) , OemToAnsi( STR0013 ) ) 				//-- "Informe o Padrao de Periodos utilizado."
		lRet	:= .F.
	EndIf 
EndIf 

Return(lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp160GerVPP    ³ Autor ³ Leandro Drumond    ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Chamar Programa Gerador de Programa de Verbas P/ Processo		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Gp160GerVPP()       		                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEA161					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Gp160GerVPP()
Return( MsAguarde( { || GerGpexVPP() } ) )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GerGpexVPP()   ³ Autor ³ Leandro Drumond    ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gerar o Programa de Verbas por Processo						³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³GerGpexVPP()       		                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEA161					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GerGpexVPP()

Local aLinesProg 	:= {}				// array com as linhas dos programas  
Local aLinProg2		:= {}				// array com as linhas dos programas
Local aRGAMemo	 	:= {}				// campos memos da tabela RGA
Local aSRMMemo		:= {}				// campos memos da tabela SRM
Local aSRYMemo		:= {}				// campos memos da tabela SRY
Local aIniHdrRGA						// cabecalho da tabela RGA com os campos
Local aRGAVirtual						// campos virtuais de RGA
Local aIniHdrSRM						// cabecalho da tabela SRM com os campos
Local aSRMVirtual						// campos virtuais de SRM 
Local aIniHdrSRY						// cabecalho da tabela SRY com os campos
Local aSRYVirtual						// campos virtuais de SRY

Local cArquivo 		:= ""			 	// nome do arquivo a ser gerado
Local cArquivo2		:= ""			 	// nome do arquivo a ser gerado
Local cPath 		:= ""				// Path a gravar o arquivo

Local cMsg								// mensagem de erro na geracao do arquivo PRX
Local cProg								// string a ser enviado ao arquivo PRX
Local cValueCampo						// montagem da string a ser enviado ao array
Local cTexto							// valor do campo do Header

Local lSetCentury	:= __SetCentury("on")

Local nArq								// situacao do arquivo
Local nArq2								// situacao do arquivo
Local nUsado							// campos utilizados

Local nLineMemo							// numero de linhas existentes no campo memo
Local nPosMemo							// posicao do campo memo virtual
Local nX
Local nY
Local nPosSeqFil

Local aListaArch	:= {}
Local cNomArch1		:= ""
Local cNomArch2		:= ""
Local nLoop			:= 0
Local cMsgArcGen	:= ""

cArquivo 	:= ("GPVPP" + cPaisLoc + ".PRX")
cArquivo2 	:= ("GPSRY" + cPaisLoc + ".PRX")
cNomArch1	:= cArquivo
cNomArch2	:= cArquivo2

aIniHdrRGA	:= RGA->( GdMontaHeader( @nUsado, @aRGAVirtual, NIL, NIL, NIL, .T.,.T. ) )
aIniHdrSRM	:= SRM->( GdMontaHeader( @nUsado, @aSRMVirtual, NIL, NIL, NIL, .T.,.T. ) ) 
aIniHdrSRY	:= SRY->( GdMontaHeader( @nUsado, @aSRYVirtual, NIL, NIL, NIL, .T.,.T. ) )

nPosSeqFil := GdFieldPos("RY_SEQFIL",aIniHdrSRY)

If nPosSeqFil > 0
	aDel(aIniHdrSRY,nPosSeqFil)
	aSize(aIniHdrSRY,Len(aIniHdrSRY)-1)
EndIf

Begin Sequence
			  								       // MOSTRA DRIVES   MOSTRA HARD DISK RETORNA DIRETORIO
	cPath := cGetFile("",OemToAnsi(STR0014),0,,.F.,GETF_LOCALHARD + GETF_RETDIRECTORY,,) //"Selecione o Diretorio"
	
	If Empty(cPath)
		Break
	EndIf

	cArquivo  := cPath + cArquivo
	cArquivo2 := cPath + cArquivo2

	If File(cArquivo)
		If !(MsgYesNo(STR0082 + cNomArch1 + STR0083 + cArquivo, STR0084)) //"¡El archivo " - " ya existe!, ¿Desea sobreescribir?" - " ya existe!, ¿Desea sobreescribir? " - "¡Atención!"
			Break
		EndIf
	EndIf 

	If File(cArquivo2)
		If !(MsgYesNo(STR0082 + cNomArch2 + STR0083 + cArquivo2, + STR0084)) //"¡El archivo " - " ya existe!, ¿Desea sobreescribir?" - " ya existe!, ¿Desea sobreescribir? " - "¡Atención!"
			Break
		EndIf
	EndIf

	nArq := MSFCREATE(cArquivo, 0)
	If Ferror() # 0 .And. nArq = -1
		cMsg := STR0016 + STR(Ferror(),3) //-- "Erro de Gravacao do Arquivo - Codigo DOS: "
		MsgInfo( cMsg, STR0013 )
		Return(.F.)
	EndIf
	
	nArq2 := MSFCREATE(cArquivo2, 0)
	If Ferror() # 0 .And. nArq2 = -1
		cMsg := STR0016 + STR(Ferror(),3) //-- "Erro de Gravacao do Arquivo - Codigo DOS: "
		MsgInfo( cMsg, STR0013 )
		Return(.F.)
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cabecalho da funcao                                          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdd(aLinesProg, '#INCLUDE "PROTHEUS.CH"' + CRLF + CRLF)
	aAdd(aLinesProg, "/*/" + CRLF)
	aAdd(aLinesProg, "ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿" + CRLF)
	aAdd(aLinesProg, "³Fun‡…o    ³GpVPP" + cPaisLoc + "      " + "³Autor³ Gerado pelo sistema ³ Data ³" + SubStr(DtoS(date()),7,2)+"/"+SubStr(DtoS(date()),5,2)+"/"+SubStr(DtoS(date()),1,4) + "³" + CRLF)
	aAdd(aLinesProg, "ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´" + CRLF)
	aAdd(aLinesProg, "³Descri‡…o ³Verbas por Processo                                         ³" + CRLF)
	aAdd(aLinesProg, "ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´" + CRLF)
	aAdd(aLinesProg, "³Sintaxe   ³                                                            ³" + CRLF)
	aAdd(aLinesProg, "ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´" + CRLF)
	aAdd(aLinesProg, "³Parametros³<Vide Parametros Formais>                                   ³" + CRLF)
	aAdd(aLinesProg, "ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´" + CRLF)
	aAdd(aLinesProg, "³ Uso      ³Generico                                                    ³" + CRLF)
	aAdd(aLinesProg, "ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/" + CRLF)
	aAdd(aLinesProg, "Function GpVPP" + cPaisLoc + "(aItensSRM, aSRMHeader, aItensRGA,aRGAHeader)" + CRLF)
	aAdd(aLinesProg, "Local lRet		:= .T." + CRLF)
	aAdd(aLinesProg, "DEFAULT aItensSRM		:= {}" + CRLF)
	aAdd(aLinesProg, "DEFAULT aSRMHeader	:= {}" + CRLF)
	aAdd(aLinesProg, "DEFAULT aItensRGA		:= {}" + CRLF)
	aAdd(aLinesProg, "DEFAULT aRGAHeader	:= {}" + CRLF+ CRLF)	
	aAdd(aLinesProg, "/*/" + CRLF)
	aAdd(aLinesProg, "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿" + CRLF)
	aAdd(aLinesProg, "³ Cabecalho de SRM gerado pelo Roteiro padrao                 ³" + CRLF)
	aAdd(aLinesProg, "ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/" + CRLF)

	For nX := 1 To Len(aIniHdrSRM)
		cProg := ""
		For nY := 1 To Len(aIniHdrSRM[nX])
			cTexto := If(ValType(aIniHdrSRM[nX,nY])=="N", AllTrim(Str(aIniHdrSRM[nX,nY])),;
						   	If(ValType(aIniHdrSRM[nX,nY])=="L", Transform(aIniHdrSRM[nX, nY],"@!"),;
						   	   aIniHdrSRM[nX, nY]))
			cTexto := StrTran(cTexto, "'", '"')
			cProg += "'" + cTexto + "'"
			If nY < Len(aIniHdrSRM[nX])
				cProg += ","
			EndIf
		Next nY
		If !Empty(cProg)
			aAdd(aLinesProg, "aAdd(aSRMHeader, " + '{ ' + cProg + ' })' + CRLF)
		EndIf
	Next nX
	aAdd(aLinesProg, CRLF)
        
    //Itens do SRM
	DbSelectArea("SRM")
	SRM->( dbSetOrder( RetOrder( "SRM", "RM_FILIAL+RM_PROCES+RM_CALCULO+RM_SEQ" ) ) )
	SRM->(DBGOTOP())

	While !SRM->(Eof())

	 	cProg := "	aAdd(aItensSRM, { "
		For nX := 1 To Len(aIniHdrSRM)
			cValueCampo := ""

			// CAMPOS MEMO NORMAL //
			If aIniHdrSRM[nX,8] == "M" .and. (aScan(aSRMVirtual, aIniHdrSRM[nX,2]) == 0)
				nLineMemo := MlCount(aIniHdrSRM[nX,2], 254)
				For nY := 1 To nLineMemo
					cValueCampo += AllTrim(MemoLine(aIniHdrSRM[nX,2], 254, nY))
					If nY < nLineMemo
						cValueCampo += ' '
					EndIf
				Next nY

			// CAMPO MEMO VIRTUAL - GRAVACAO REALIZADA EM SYP //
			ElseIf aIniHdrSRM[nX,8] == "M" .and. (aScan(aSRMVirtual, aIniHdrSRM[nX,2]) > 0)
				If ((nPosMemo := Ascan(aSRMMemo, { |x|  Upper(x[2]) == aIniHdrSRM[nX,2] })) > 0)
					cValueCampo += MSMM(&(SRM->(aSRMMemo[nPosMemo,1])),80)
					cValueCampo := StrTran(cValueCampo, CRLF, "\13\10")
				EndIf
			ElseIf aIniHdrSRM[nX,8] == "N"
				cValueCampo += AllTrim(Str(&(aIniHdrSRM[nX,2])))
			ElseIf aIniHdrSRM[nX,8] == "D"
				cValueCampo += 'Ctod("' + DtoC(&(aIniHdrSRM[nX,2])) + '")'
			ElseIf aIniHdrSRM[nX,8] == "L"
				If &(aIniHdrSRM[nX,2])
					cValueCampo += ".T."
				Else
					cValueCampo += ".F."
				EndIf
			ElseIf "FILIAL" $ aIniHdrSRM[nX,2]
				cValueCampo += ""
			ElseIf "PROCES" $ aIniHdrSRM[nX,2]
	                 	cValueCampo += fDesc('RCJ', SRM->RM_PROCES, 'RCJ_DESCRI', NIL, SRM->RM_FILIAL)
			ElseIf "CALCULO" $ aIniHdrSRM[nX,2]
	                 	cValueCampo += fDesc('SRY', SRM->RM_CALCULO, 'RY_DESC', NIL, SRM->RM_FILIAL)
			Else
				cValueCampo += &(aIniHdrSRM[nX,2])
			EndIf
			cValueCampo := StrTran(cValueCampo, "'", '"')
	
			If (aIniHdrSRM[nX,8] != "N") .and. (aIniHdrSRM[nX,8] != "D") .and. (aIniHdrSRM[nX,8] != "L")
				cValueCampo := "'" + cValueCampo
				cValueCampo += "'"
			EndIf
	
			cProg += cValueCampo
			If nX < Len(aIniHdrSRM)
				cProg += ","
			EndIf
		Next nX
		cProg += "} )"
		aAdd(aLinesProg, cProg + CRLF)
		SRM->(dbSkip())

	EndDo 
	
	aAdd(aLinesProg, "" + CRLF)
	aAdd(aLinesProg, "" + CRLF)
	aAdd(aLinesProg, "" + CRLF)
	                                                      
    
	// Monta cabeçalho da RGA
	For nX := 1 To Len(aIniHdrRGA)
		cProg := ""
		For nY := 1 To Len(aIniHdrRGA[nX])
			cTexto := If(ValType(aIniHdrRGA[nX,nY])=="N", AllTrim(Str(aIniHdrRGA[nX,nY])),;
						   	If(ValType(aIniHdrRGA[nX,nY])=="L", Transform(aIniHdrRGA[nX, nY],"@!"),;
						   	   aIniHdrRGA[nX, nY]))
			cTexto := StrTran(cTexto, "'", '"')
			cProg += "'" + cTexto + "'"
			If nY < Len(aIniHdrRGA[nX])
				cProg += ","
			EndIf
		Next nY
		If !Empty(cProg)
			aAdd(aLinesProg, "aAdd(aRGAHeader, " + '{ ' + cProg + ' })' + CRLF)
		EndIf
	Next nX
	aAdd(aLinesProg, CRLF)
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Itens do RGA                                       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	DbSelectArea("RGA")
	RGA->(dbGoTop())
	RGA->(dbSetOrder(RetOrder("RGA", "RGA_FILIAL+RGA_PROCES+RGA_CALCUL")))

	While !RGA->(Eof())

	 	cProg := "	aAdd(aItensRGA, { "
		For nX := 1 To Len(aIniHdrRGA)
			cValueCampo := ""

			// CAMPOS MEMO NORMAL //
			If aIniHdrRGA[nX,8] == "M" .and. (aScan(aRGAVirtual, aIniHdrRGA[nX,2]) == 0)
				nLineMemo := MlCount(aIniHdrRGA[nX,2], 254)
				For nY := 1 To nLineMemo
					cValueCampo += AllTrim(MemoLine(aIniHdrRGA[nX,2], 254, nY))
					If nY < nLineMemo
						cValueCampo += ' '
					EndIf
				Next nY

			// CAMPO MEMO VIRTUAL - GRAVACAO REALIZADA EM SYP //
			ElseIf aIniHdrRGA[nX,8] == "M" .and. (aScan(aRGAVirtual, aIniHdrRGA[nX,2]) > 0)
				If ((nPosMemo := Ascan(aRGAMemo, { |x|  Upper(x[2]) == aIniHdrRGA[nX,2] })) > 0)
					cValueCampo += MSMM(&(SRM->(aRGAMemo[nPosMemo,1])),80)
					cValueCampo := StrTran(cValueCampo, CRLF, "\13\10")
				EndIf
			ElseIf aIniHdrRGA[nX,8] == "N"
				cValueCampo += AllTrim(Str(&(aIniHdrRGA[nX,2])))
			ElseIf aIniHdrRGA[nX,8] == "D"
				cValueCampo += 'Ctod("' + DtoC(&(aIniHdrRGA[nX,2])) + '")'
			ElseIf aIniHdrRGA[nX,8] == "L"
				If &(aIniHdrRGA[nX,2])
					cValueCampo += ".T."
				Else
					cValueCampo += ".F."
				EndIf
			ElseIf "FILIAL" $ aIniHdrRGA[nX,2]
				cValueCampo += ""
			ElseIf "PROCES" $ aIniHdrRGA[nX,2]
	                 	cValueCampo += fDesc('RCJ', RGA->RGA_PROCES, 'RCJ_DESCRI', NIL, RGA->RGA_FILIAL)
			ElseIf "CALCUL" $ aIniHdrRGA[nX,2]
	                 	cValueCampo += fDesc('SRY', RGA->RGA_CALCUL, 'RY_DESC', NIL, RGA->RGA_FILIAL)
			Else
				cValueCampo += &(aIniHdrRGA[nX,2])
			EndIf
			cValueCampo := StrTran(cValueCampo, "'", '"')

			If (aIniHdrRGA[nX,8] != "N") .and. (aIniHdrRGA[nX,8] != "D") .and. (aIniHdrRGA[nX,8] != "L")
				cValueCampo := "'" + cValueCampo
				cValueCampo += "'"
			EndIf
	
			cProg += cValueCampo
			If nX < Len(aIniHdrRGA)
				cProg += ","
			EndIf
		Next nX
		cProg += "} )"
		aAdd(aLinesProg, cProg + CRLF)
		RGA->(dbSkip())

	EndDo

	aAdd(aLinesProg, CRLF)
	aAdd(aLinesProg, 'Return ( lRet )' + CRLF + CRLF)  

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cabecalho da funcao                                          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdd(aLinProg2, '#INCLUDE "PROTHEUS.CH"' + CRLF + CRLF)
	aAdd(aLinProg2, "/*/" + CRLF)
	aAdd(aLinProg2, "ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿" + CRLF)
	aAdd(aLinProg2, "³Fun‡…o    ³GpSRY" + cPaisLoc + "      " + "³Autor³ Gerado pelo sistema ³ Data ³" + SubStr(DtoS(date()),7,2)+"/"+SubStr(DtoS(date()),5,2)+"/"+SubStr(DtoS(date()),1,4) + "³" + CRLF)
	aAdd(aLinProg2, "ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´" + CRLF)
	aAdd(aLinProg2, "³Descri‡…o ³Tipos de Calculo                                            ³" + CRLF)
	aAdd(aLinProg2, "ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´" + CRLF)
	aAdd(aLinProg2, "³Sintaxe   ³                                                            ³" + CRLF)
	aAdd(aLinProg2, "ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´" + CRLF)
	aAdd(aLinProg2, "³Parametros³<Vide Parametros Formais>                                   ³" + CRLF)
	aAdd(aLinProg2, "ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´" + CRLF)
	aAdd(aLinProg2, "³ Uso      ³Generico                                                    ³" + CRLF)
	aAdd(aLinProg2, "ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/" + CRLF)
	aAdd(aLinProg2, "Function GpSRY" + cPaisLoc + "(aItensSRY, aSRYHeader)" + CRLF)
	aAdd(aLinProg2, "Local lRet		:= .T." + CRLF)
	aAdd(aLinProg2, "DEFAULT aItensSRY		:= {}" + CRLF)
	aAdd(aLinProg2, "DEFAULT aSRYHeader	:= {}" + CRLF+ CRLF)                          
	aAdd(aLinProg2, "/*/" + CRLF)
	aAdd(aLinProg2, "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿" + CRLF)
	aAdd(aLinProg2, "³ Cabecalho de SRY gerado pelo Roteiro padrao                 ³" + CRLF)
	aAdd(aLinProg2, "ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/" + CRLF)

	For nX := 1 To Len(aIniHdrSRY)
		cProg := ""
		For nY := 1 To Len(aIniHdrSRY[nX])
			cTexto := If(ValType(aIniHdrSRY[nX,nY])=="N", AllTrim(Str(aIniHdrSRY[nX,nY])),;
						   	If(ValType(aIniHdrSRY[nX,nY])=="L", Transform(aIniHdrSRY[nX, nY],"@!"),;
						   	   aIniHdrSRY[nX, nY]))
			cTexto := StrTran(cTexto, "'", '"')
			cProg += "'" + cTexto + "'"
			If nY < Len(aIniHdrSRY[nX])
				cProg += ","
			EndIf
		Next nY
		If !Empty(cProg)
			aAdd(aLinProg2, "aAdd(aSRYHeader, " + '{ ' + cProg + ' })' + CRLF)
		EndIf
	Next nX
	aAdd(aLinProg2, CRLF)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Itens do Tipo de Calculo                                     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

	DbSelectArea("SRY")
	SRY->( dbSetOrder( RetOrder( "SRY", "RY_FILIAL+RY_CALCULO" ) ) )
	SRY->(DBGOTOP())
		
	While !SRY->(Eof())
	 
	 	cProg := "	aAdd(aItensSRY, { "
		For nX := 1 To Len(aIniHdrSRY)
			cValueCampo := ""

	
			// CAMPOS MEMO NORMAL //
			If aIniHdrSRY[nX,8] == "M" .and. (aScan(aSRYVirtual, aIniHdrSRY[nX,2]) == 0)
				nLineMemo := MlCount(aIniHdrSRY[nX,2], 254)
				For nY := 1 To nLineMemo
					cValueCampo += AllTrim(MemoLine(aIniHdrSRY[nX,2], 254, nY))
					If nY < nLineMemo
						cValueCampo += ' '
					EndIf
				Next nY
	
			// CAMPO MEMO VIRTUAL - GRAVACAO REALIZADA EM SYP //
			ElseIf aIniHdrSRY[nX,8] == "M" .and. (aScan(aSRYVirtual, aIniHdrSRY[nX,2]) > 0)
				If ((nPosMemo := Ascan(aSRYMemo, { |x|  Upper(x[2]) == aIniHdrSRY[nX,2] })) > 0)
					cValueCampo += MSMM(&(SRY->(aSRYMemo[nPosMemo,1])),80)
					cValueCampo := StrTran(cValueCampo, CRLF, "\13\10")
				EndIf
			ElseIf aIniHdrSRY[nX,8] == "N"
				cValueCampo += AllTrim(Str(&(aIniHdrSRY[nX,2])))
			ElseIf aIniHdrSRY[nX,8] == "D"
				cValueCampo += 'Ctod("' + DtoC(&(aIniHdrSRY[nX,2])) + '")'
			ElseIf aIniHdrSRY[nX,8] == "L"
				If &(aIniHdrSRY[nX,2])
					cValueCampo += ".T."
				Else
					cValueCampo += ".F."
				EndIf
			ElseIf "FILIAL" $ aIniHdrSRY[nX,2]
				cValueCampo += ""
			Else
				cValueCampo += &(aIniHdrSRY[nX,2])
			EndIf
			cValueCampo := StrTran(cValueCampo, "'", '"')
	
			If (aIniHdrSRY[nX,8] != "N") .and. (aIniHdrSRY[nX,8] != "D") .and. (aIniHdrSRY[nX,8] != "L")
				cValueCampo := "'" + cValueCampo
				cValueCampo += "'"
			EndIf

			cProg += cValueCampo
			If nX < Len(aIniHdrSRY)
				cProg += ","
			EndIf
		Next nX
		cProg += "} )"
		aAdd(aLinProg2, cProg + CRLF)
		SRY->(dbSkip())

	EndDo

	aAdd(aLinProg2, "" + CRLF)

	aAdd(aLinProg2, CRLF)
	aAdd(aLinProg2, 'Return ( lRet )' + CRLF + CRLF)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Transferir as linhas para dentro do programa                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    For nX := 1 To Len(aLinesProg)
	    Fwrite( nArq, aLinesProg[nX] )
	Next nX

	FClose(nArq)  

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Transferir as linhas para dentro do programa                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    For nX := 1 To Len(aLinProg2)
	    Fwrite( nArq2, aLinProg2[nX] )
	Next nX

	FClose(nArq2)

	aAdd(aListaArch, cNomArch1) //"GPVPP" + cPaisLoc + ".PRX"
	aAdd(aListaArch, cNomArch2) //"GPSRY" + cPaisLoc + ".PRX"

End Sequence

//Se llama función que genera PRX (GPRG9 + cPaisLoc y GPRGX + cPaisLoc)
If cPaisLoc <> "BRA"
	If !Empty(cPath)
		GerGpexRGX(cPath, aListaArch)
	EndIf
EndIf

IF !(lSetCentury)
	__SetCentury("off")
EndIF

If Len(aListaArch) > 0
	For nLoop := 1 To Len(aListaArch)
		cMsgArcGen += CRLF + aListaArch[nLoop]
	Next nLoop
EndIf

If !Empty(cMsgArcGen)
	MsgInfo(STR0085 + cPath + ":" + CRLF + cMsgArcGen) //"Los siguientes programas, se generaron con éxito en el directorio "
EndIf

Return(Nil)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCarVPP        ³ Autor ³ Leandro Drumond    ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Carrega o Programa de Verbas por Processo						³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fCarVPP(cAlias,nReg,nOpcx)                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEA161					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fCarVPP(cAlias,nReg,nOpcx,lAtuRGA,lAtuRG9)
Local aArea			:= GetArea()
Local aKeys			:= GetKeys()
Local aObjFolder	:= Array( 02 )
Local aButtons		:= {}
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aGDCoord		:= {}
Local aAlter		:= {}
Local aHeader 		:= {}
Local aCols 		:= {}
Local aAux			:= {}
Local aSvHeader		:= {}
Local aSRMHeader	:= {}
Local aAuxRGA		:= {}
Local aRGAHeader	:= {}
Local aRGHeader		:= {}
Local aAllFilial	:= {}
Local aFields		:= {}
Local aColumns		:= {}
Local aSRMAux		:= {}
Local bSet15
Local bSet24
Local bDialogInit
Local bFunc			:= {|| NIL}
Local bMarkAll 		:= { || RhMkAll( 'SRMAUX' , .F., .T. , 'RM_OKTRANS', @cMarkAll ,cMarkTransf ),oDlg:Refresh() }
Local cVerbasPP		:= ""
Local cFunction		:= ""
Local cMsg 			:= ""
Local cProcAux		:= ""
Local cRotAux		:= ""
Local cMarkAll		:= ""
Local lSetCentury	:= __SetCentury( "on" )	//altero o estado de SetCentury
Local lNewAtu		:= .T.
Local lContinua		:= .T.
Local lSRYPadr 		:= .F.
Local nLin
Local nI 			:= 0
Local nX    		:= 0
Local nPos1 		:= 0
Local nPos2 		:= 0
Local nPos3 		:= 0
Local nAcols 		:= 0
Local nCntFor		:= 0
Local nUsado 		:= 0
Local nPosVerba 	:= 0
Local nCol			:= 1
Local nPosCodRot 	:= 0
Local nPosRot 		:= 0
Local nRotPos 		:= 0
Local nPosSeq 		:= 0
Local nPosDescPd 	:= 0
Local nPosFor 		:= 0
Local nPosDFor 		:= 0
Local nPosVersao 	:= 0
Local nPosChave		:= 0
Local oDlg
Local oProces
Local oGeralEnch
Local oRangoEnch
Local oConfigEnch
Local oChkHabGrab
Local oRadStatus
Local oEnchoice
Local oGetDados
Local oFWLayer
Local oPanelUp
Local oPanelDR
Local oPanelDL
Local oMsSelect
Local lContinua := .T. 

Private aSRYAux 	 	:= {}
Private aSRYAuxHdr 	 	:= {}
Private aRG9Aux 	 	:= {}
Private aRG9AuxHdr 	 	:= {}
Private cMarkTransf		:= GetMark()
Private nPosRMProces 	:= 0
Private nPosCalculo  	:= 0
Private lSRYPrx         := .T.
Private lRG9Prx         := .T.

DEFAULT lAtuRGA			:= .F.
DEFAULT lAtuRG9			:= .F.

cMarkAll 	:= cMarkTransf
cFunction	:= ("GPVPP" + cPaisLoc)

If !ChkVazio("RCJ",.F.)
	MsgInfo( OemToAnsi(STR0022) + CRLF + OemToAnsi(STR0023) , OemToAnsi(STR0013)) //"A tabela de Processos está vazia."  ### "Favor verificar!" ###"Atenção!"
	Return
EndIf

If lAtuRGA
	lNewAtu := .F.
EndIf

If !ChkVazio("SRY",.F.)
	If lAtuRGA
		MsAguarde( { || fCarSRY(@aSRYAux, @aSRYAuxHdr)} , OemToAnsi(STR0028) ) // "Carregando Tipos de Folha"
	Else //So pergunta se nao for a primeira atualizacao
		cMsgYesNo	:= OemToAnsi(;
									STR0024 + ;	// "Não há dados na tabela SRY"
									CRLF	+ ;	
									STR0025 + ;	// "Deseja importar dados de Tipo de Folha?"
									CRLF	+ ;
									STR0026  + cPaisLoc + STR0027 ;	// "Obs: Necessário que o programa GPSRY" ### ".PRX esteja compilado."
	                                )
		If MsgYesNo(OemToAnsi(cMsgYesNo) , If(lExibeGetDados,OemToAnsi(STR0001),OemToAnsi(STR0002)) + " - " + OemToAnsi(STR0013)) // "Atenção"
			MsAguarde( { || fCarSRY(@aSRYAux, @aSRYAuxHdr)} , OemToAnsi(STR0028) ) // "Carregando Tipos de Folha"
	    Else
	    	Return(Nil)
	    EndIf
	EndIf
EndIf

If cPaisLoc <> "BRA"
	If !ChkVazio("RG9",.F.)
		If lAtuRG9
			MsAguarde( { || fCargRG9(@aRG9Aux, @aRG9AuxHdr)} , OemToAnsi(STR0072) ) // "Carregando Criterios de Acumulación"
		Else //So pergunta se nao for a primeira atualizacao
			cMsgYesNo	:= OemToAnsi(;
									STR0073 + ;	// "Não há dados na tabela RG9"
									CRLF	+ ;	
									STR0074 + ;	// "Deseja importar dados de Criterios de Acumulación?"
									CRLF	+ ;
									STR0075  + cPaisLoc + STR0076 ;	// "Obs: Necessário que o programa GPRG9" ### ".PRX esteja compilado."
	                                )
	        If MsgYesNo(OemToAnsi(cMsgYesNo) , If(lExibeGetDados,OemToAnsi(STR0001),OemToAnsi(STR0002)) + " - " + OemToAnsi(STR0013)) // "Atenção"
	        	MsAguarde( { || fCargRG9(@aRG9Aux, @aRG9AuxHdr)} , OemToAnsi(STR0072) ) // "Carregando Criterios de Acumulación"
	        Else
	        	Return(Nil)
	        EndIf
	    EndIf
	EndIf
EndIf

If lManutence .and. !lAtuRGA 
	If !Empty(cAlias)
		lNewAtu := !MsgYesNo(OemToAnsi(STR0045) , If(lExibeGetDados,OemToAnsi(STR0001),OemToAnsi(STR0002)) + " - " + OemToAnsi(STR0013))  //"Deseja atualizar todas as fórmulas ou apenas o processo/roteiro selecionado?"
	Else
		lNewAtu := .F.
	EndIf
EndIf

If lAtuRGA .or. (!lNewAtu .and. MsgYesNo(OemToAnsi(STR0029)))  // "Deseja utilizar os Tipos de Folha padrão?"
	If Empty(aSRYAux) .And. lSRYPrx
		MsAguarde( { || fCarSRY(@aSRYAux, @aSRYAuxHdr)} , OemToAnsi(STR0028) ) // "Carregando Tipos de Folha"
	EndIf
	lSRYPadr := .T.
EndIf

If cPaisLoc <> "BRA" .And. !ChkVazio("SRY",.F.)
	 MsgInfo(STR0067, OemToAnsi(STR0013)) //"No se encuentran cargados los tipos de Procedimientos de Cálculo (SRY), datos requeridos para continuar con el proceso." //"Atención!"
	 lContinua := .F.
EndIf

If cPaisLoc <> "BRA"
	If lManutence .and. !lAtuRG9
		If !lNewAtu .and. MsgYesNo(OemToAnsi(STR0077))  // "Deseja utilizar os Criterios de Acumulacion padrão?"
			If Empty(aRG9Aux) .And. lRG9Prx
				MsAguarde( { || fCargRG9(@aRG9Aux, @aRG9AuxHdr)} , OemToAnsi(STR0072) ) // "Carregando Criterios de Acumulación"
			EndIf
		EndIf	
	EndIf
EndIf

// Verifica a Existencia da Funcao do Pais Corrente
If FindFunction(cFunction) .And. lContinua
	bFunc := __ExecMacro("{ ||  " + cFunction + "( @aAux , @aSvHeader, @aAuxRGA, @aRGAHeader ) }")
	Eval(bFunc)

	aSRMHeader := GdMontaHeader(NIL,NIL,NIL,"SRM",NIL,.T.,.F.,.F.,.F.,.F.,.F.,.F.)
	aRGHeader  := GdMontaHeader(NIL,NIL,NIL,"RGA",NIL,.T.,.T.,.F.,.F.,.F.,.F.,.F.)
	
	nPosRMProces := GdFieldPos("RM_PROCES", aSvHeader)
	nPosCalculo  := GdFieldPos("RM_CALCULO", aSvHeader)
	nPosSeq		 := GdFieldPos("RM_SEQ", aSvHeader)
	
	aAux := ASort(aAux,,,{|x,y| x[nPosRMProces]+x[nPosCalculo]+x[nPosSeq] < y[nPosRMProces]+y[nPosCalculo]+y[nPosSeq]}) // ORDENA aAux
	
	If !lNewAtu .or. lAtuRGA //Se RGA estiver vazia, relaciona itens para geracao.
	
		nPos1 := GdFieldPos("RM_PROCES", aSRMHeader)
		nPos2 := GdFieldPos("RM_CALCULO", aSRMHeader)
		aAdd( aHeader, aClone(aSrMHeader[nPos1]))
		aAdd( aHeader, aClone(aSrMHeader[nPos2]))
		aAdd( aHeader, aClone(aSrMHeader[nPos1]))
		aAdd( aHeader, aClone(aSrMHeader[nPos2]))
	
	    aHeader[1,__AHEADER_WIDTH__]	:= 15
	    aHeader[2,__AHEADER_WIDTH__]	:= 25
	
		aHeader[3,__AHEADER_TITLE__]	:= OemToAnsi(STR0030) // "Processo a importar"
		aHeader[3,__AHEADER_FIELD__]	:= "RM_PROC2"
		aHeader[3,__AHEADER_PICTURE__]  := "@!"
		aHeader[3,__AHEADER_VALID__]  	:= "GP160VLDCAMPOS('RCJ')"
		aHeader[3,__AHEADER_F3__] 		:= "RCJ"
		aHeader[3,__AHEADER_VISUAL__] 	:= "A"
		aHeader[3,__AHEADER_TYPE__] 	:= "C"
	
		aHeader[4,__AHEADER_TITLE__]	:= OemToAnsi(STR0031) // "Roteiro a importar"
		aHeader[4,__AHEADER_FIELD__]	:= "RM_CALC2"
		aHeader[4,__AHEADER_PICTURE__]  := "@!"
		aHeader[4,__AHEADER_VALID__]  	:= "GP160VLDCAMPOS('SRY')"
		aHeader[4,__AHEADER_F3__] 		:= "SRY"
		aHeader[4,__AHEADER_VISUAL__] 	:= "A"
		aHeader[4,__AHEADER_TYPE__] 	:= "C"
	
		aAlter :={aHeader[3][2], aHeader[4][2]}
		aSvCols 	:= gdRmkAcols( aHeader )
	
		// Realiza a carga das verbas por Processo padrão para apresentar ao usuario //
		If lSRYPadr
			nPosRot		 := GdFieldPos("RY_DESC", aSRYAuxHdr)
			nPosCodRot	 := GdFieldPos("RY_CALCULO", aSRYAuxHdr)
		EndIf
	
		// ATRIBUI PRIMEIRO REGISTRO
		aAdd( aCols, aClone( aSvCols[1] ) )
		aCols[1][1] := aAux[1][nPosRMProces]
		aCols[1][2] := aAux[1][nPosCalculo]
		If lSRYPadr
			nRotPos := aScan( aSRYAux, { |x| x[nPosRot] == aCols[nCol][2] } )
			If nRotPos <> 0
				aCols[nCol][4] := aSRYAux[nRotPos][nPosCodRot]
			EndIf
		EndIf
		// A PARTIR DO SEGUNDO ITEM COMPARA COM O ANTERIOR PARA ADICIONAR SOMENTE OS DISTINTOS
		nCol := 2
		For nAcols := 2 To Len(aAux)
			If aAux[nAcols - 1][nPosRMProces] <> aAux[nAcols][nPosRMProces] .OR. aAux[nAcols - 1][nPosCalculo] <> aAux[nAcols][nPosCalculo]
				aAdd( aCols, aClone( aSvCols[1] ) )
		  		aCols[nCol][1] := aAux[nAcols][nPosRMProces]
				aCols[nCol][2] := aAux[nAcols][nPosCalculo]
				If lSRYPadr
					nRotPos := aScan( aSRYAux, { |x| x[nPosRot] == aCols[nCol][2] } )
					If nRotPos <> 0
						aCols[nCol][4] := aSRYAux[nRotPos][nPosCodRot]
					EndIf
				EndIf				
				nCol++
			EndIf
		Next nAcols
	    /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta as Dimensoes dos Objetos         					   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aAdvSize		:= MsAdvSize()
		aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
		aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
		aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords)

		Define MsDialog oDlg Title If(lExibeGetDados,OemToAnsi(STR0001),OemToAnsi(STR0002)) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] PIXEL
			If lAtuRGA .and. lNewAtu
				bSet15	:=  {|| MsAguarde({|| If(lContinua := Gp160ATURGA(aAux, aAuxRGA, oGetDados:aCols, aSvHeader),oDlg:End(),oDlg:End())})}
				bSet24	:= 	{|| lContinua := .F., oDlg:End()}
			Else
				bSet15	:=  {|| Processa({|| If(GP160ATUVPP(aAux, aAuxRGA, oGetDados:aCols, aSvHeader),oDlg:End(),Nil)}, STR0071)} //"Cargando Conceptos por Proceso"
				bSet24	:= 	{|| RestKeys(aKeys,.T.), oDlg:End()}
			EndIf

			oDlg:lEscClose := .F. // Nao permite sair ao se pressionar a tecla ESC.

			oGetDados := MsNewGetDados():New( aObjSize[1,1],;	// nsuperior
											  aObjSize[1,2],;   // nEsquerda
											  aObjSize[1,3],;	// nInferior
											  aObjSize[1,4],;	// nDireita
											  GD_UPDATE,;		// opcao de operacao
											  Nil,;				// Função executada para validar o contexto da linha atual do acols 
											  Nil,;				// Função executada para validar o contexto geral da MsNewGetDados (todo aCols
											  Nil,;				// Nome dos campos do tipo caracter que utilizarão incremento automático.
											  aAlter,;				// Campos alteráveis da GetDados
											  Nil,;				// Campos estáticos na GetDados, partindo sempre da posição inicial da getdados aonde:
											  Nil,;				// Número máximo de linhas permitidas. Valor padrão 99
											  Nil,;				// Função executada na validação do campo
											  Nil,;				// Função executada quando pressionada as teclas <Ctrl>+<Delete>
											  Nil,;				// Função executada para validar a exclusão de uma linha do aCols
											  oDlg,;				// Objeto no qual a MsNewGetDados será criada
											  @aHeader,;
											  @aCols)


		ACTIVATE DIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24) CENTERED		
	EndIf
	
	If lNewAtu .and. lContinua	
		//Relaciona processos e roteiros
		If (lContinua := fRelacProc(@cProcAux,@cRotAux,aAux,aSvHeader) )
		
			DbSelectArea('SRM')
			DbSetOrder(2) //RM_FILIAL + RM_PROCES + RM_CALCULO + RM_SEQ
			aCols := {}
			
			nPosChave  	:= GdFieldPos("RM_CHAVE"  , aSvHeader)
			nPosVersao 	:= GdFieldPos("RM_VERSAO" , aSvHeader)
			
			If MsSeek(xFilial('SRM')+RGA->RGA_PROCES+RGA->RGA_CALCUL)
				While SRM->(!Eof() .and. ( RM_PROCES + RM_CALCULO == RGA->RGA_PROCES+RGA->RGA_CALCUL ) )
					If !Empty(SRM->RM_CHAVE )
						If ( nAcols := aScan( aAux, { |x| x[nPosChave] == SRM->RM_CHAVE } ) ) > 0
							If aAux[nAcols,nPosVersao] > SRM->RM_VERSAO
								aAdd(aCols,{SRM->RM_SEQ,SRM->RM_VERBA,fDesc("SRV",SRM->RM_VERBA,"RV_DESC"),SRM->RM_CODFOR,fDesc("RC2",SRM->RM_CODFOR,"RC2_DESC",,,2),SRM->RM_VERSAO, SRM->RM_CHAVE, .F.})
								aAdd(aSRMAux,{SRM->RM_CHAVE, .T.})
							Else
								aAdd(aSRMAux,{SRM->RM_CHAVE, .F.})
							EndIf
						Else
							aAdd(aCols,{SRM->RM_SEQ,SRM->RM_VERBA,fDesc("SRV",SRM->RM_VERBA,"RV_DESC"),SRM->RM_CODFOR,fDesc("RC2",SRM->RM_CODFOR,"RC2_DESC",,,2),SRM->RM_VERSAO, SRM->RM_CHAVE, .F.})
							aAdd(aSRMAux,{SRM->RM_CHAVE, .T.})
						EndIf
					EndIf
					DbSkip()
				EndDo
			EndIf
			
			//Cria temporario para utilizacao no MsSelect
			If !fCriaTmp(aAux,aSvHeader,cProcAux,cRotAux,aSRMAux)
				MsgAlert( OemToAnsi( STR0053 ) , OemToAnsi( STR0013 ) ) 	//-- "Nenhuma atualizacao disponivel para este processo e roteiro."#Atencao
				lContinua := .F.
			EndIf
			
			nPosSeq 	:= GdFieldPos("RM_SEQ" , aSRMHeader)
			nPosVerba 	:= GdFieldPos("RM_VERBA" , aSRMHeader)
			nPosDescPd 	:= GdFieldPos("RM_DESCPD" , aSRMHeader)
			nPosFor 	:= GdFieldPos("RM_CODFOR" , aSRMHeader)
			nPosDFor 	:= GdFieldPos("RM_DESCFOR" , aSRMHeader)
			nPosVersao 	:= GdFieldPos("RM_VERSAO" , aSRMHeader)
			
			aAdd( aHeader , aClone(aSRMHeader[nPosSeq]))
			aAdd( aHeader , aClone(aSRMHeader[nPosVerba]))
			aAdd( aHeader , aClone(aSRMHeader[nPosDescPd]))
			aAdd( aHeader , aClone(aSRMHeader[nPosFor]))
			aAdd( aHeader , aClone(aSRMHeader[nPosDFor]))
			aAdd( aHeader , aClone(aSRMHeader[nPosVersao]))
			
		EndIf		
	EndIf
	             
	Begin Sequence
	
		If lNewAtu .and. lContinua
		
			aColumns := {}
			aAdd( aColumns, { "RM_OKTRANS"	,,''						,"@!"})
			aAdd( aColumns, { "RM_SEQ"		,,TitSX3("RM_SEQ")[1]  		,GetSx3Cache( "RM_SEQ" , "X3_PICTURE" ) })
			aAdd( aColumns, { "RM_VERBA"	,,TitSX3("RM_VERBA")[1]		,GetSx3Cache( "RM_VERBA" , "X3_PICTURE" )})
			aAdd( aColumns, { "RM_DESCPD"	,,TitSX3("RM_DESCPD")[1]	,GetSx3Cache( "RM_DESCPD" , "X3_PICTURE" )})
			aAdd( aColumns, { "RM_CODFOR"	,,TitSX3("RM_CODFOR")[1]	,GetSx3Cache( "RM_CODFOR" , "X3_PICTURE" )})
			aAdd( aColumns, { "RM_DESCFOR"	,,TitSX3("RM_DESCFOR")[1]	,GetSx3Cache( "RM_DESCFOR" , "X3_PICTURE" )})
			aAdd( aColumns, { "RM_VERSAO"	,,TitSX3("RM_VERSAO")[1]	,GetSx3Cache( "RM_VERSAO" , "X3_PICTURE" )})
				
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Monta as Dimensoes dos Objetos         					   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			aAdvSize		:= MsAdvSize()
			aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
			aObjCoords		:= {}					 
			aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
			aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
			oDlg			:= Nil
				
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta Dialog...                                                          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DEFINE MSDIALOG oDlg TITLE If(lExibeGetDados,OemToAnsi(STR0001),OemToAnsi(STR0002)) FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME PIXEL
	
				oFWLayer := FWLayer():New()
				oFWLayer:Init( oDlg, .F., .T. )
				
				// Define Painel Superior
				oFWLayer:AddLine( 'UP', 20, .F. )                       // Cria uma "linha" com 15% da tela
				oFWLayer:AddCollumn( 'ALL', 100, .T., 'UP' )            // Na "linha" criada eu crio uma coluna com 100% da tamanho dela
				oPanelUp := oFWLayer:GetColPanel( 'ALL', 'UP' )         // Pego o objeto desse pedaço do container
				
				// Paineis Inferiores
				oFWLayer:AddLine( 'DOWN', 80, .F. )                     // Cria uma "linha" com 85% da tela
				oFWLayer:AddCollumn( 'DOWNL', 50, .T., 'DOWN' )       	 // Na "linha" criada eu crio uma coluna com 50% da tamanho dela
				oFWLayer:AddCollumn( 'DOWNR', 50, .T., 'DOWN' )       	 // Na "linha" criada eu crio uma coluna com 50% da tamanho dela
				oPanelDL  := oFWLayer:GetColPanel( 'DOWNL' , 'DOWN' )  	 // Pego o objeto desse pedaço do container
				oPanelDR  := oFWLayer:GetColPanel( 'DOWNR' , 'DOWN' )  	 // Pego o objeto desse pedaço do container
				
				//Cria variaveis de tela para exibição na enchoice
				&( "M->RGA_PROCES" ) := RGA->RGA_PROCES
				&( "M->RGA_DESPRO" ) := fDesc('RCJ', RGA->RGA_PROCES, 'RCJ_DESCRI', NIL, RGA->RGA_FILIAL)
				&( "M->RGA_CALCUL" ) := RGA->RGA_CALCUL
				&( "M->RGA_DESCAL" ) := fDesc('SRY', RGA->RGA_CALCUL, 'RY_DESC', NIL, RGA->RGA_FILIAL)
			    
				oEnchoice	:= MsmGet():New( "RGA" , nReg , 1 , NIL , NIL , NIL , {'RGA_PROCES','RGA_DESPRO','RGA_CALCUL','RGA_DESCAL'} , {aObjSize[1][1],aObjSize[1][2],aObjSize[1][3]*0.2,aObjSize[1][4]} , {} , NIL , NIL , NIL , oPanelUp , NIL , .F. )
				
				dbSelectArea("SRMAUX")
				DbGoTop()
	
			    bSet15 := {|| MsAguarde({|| If(Gp160NewAtu(aAux,aAuxRGA,cMarkTransf),oDlg:End(),Nil)})}
			    bSet24 := {|| oDlg:End()}
				
				oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.
			
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Monta MarkBrowse...                                                      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				oMsSelect := MsSelect():New(;
												"SRMAUX"			,;	//Alias	do Arquivo de Filtro
												"RM_OKTRANS"		,;	//Campo para controle do mark
												NIL					,;	//Condicao para o Mark
												aColumns			,;	//Array com os Campos para o Browse
												NIL					,;	//
												cMarkTransf			,;	//Conteudo a Ser Gravado no campo de controle do Mark
												{aObjSize[1][1],aObjSize[1][2],aObjSize[1][3]*0.7,aObjSize[1][4]/2}	,;	//Coordenadas do Objeto
												NIL					,;  //
												NIL					,;	//
												oPanelDL			 ;	//Objeto Dialog
											)
				oMsSelect:oBrowse:lAllMark := .T.
				oMsSelect:oBrowse:bAllMark := bMarkAll
				
				//Cria linha vazia e deletada caso nao exista dados no aCols
				If Empty(aCols)
					aAdd(aCols,{'','','','','','','', .T.})
				EndIf
				
				oGetDados := MsNewGetDados():New( aObjSize[1,1],;		// nsuperior
												  aObjSize[1,2],;   	// nEsquerda
												  aObjSize[1,3]*0.7,;	// nInferior
												  aObjSize[1,4]/2,;	// nDireita
												  GD_UPDATE,;		// opcao de operacao
												  Nil,;				// Função executada para validar o contexto da linha atual do acols 
												  Nil,;				// Função executada para validar o contexto geral da MsNewGetDados (todo aCols
												  Nil,;				// Nome dos campos do tipo caracter que utilizarão incremento automático.
												  aAlter,;			// Campos alteráveis da GetDados
												  Nil,;				// Campos estáticos na GetDados, partindo sempre da posição inicial da getdados aonde:
												  Nil,;				// Número máximo de linhas permitidas. Valor padrão 99
												  Nil,;				// Função executada na validação do campo
												  Nil,;				// Função executada quando pressionada as teclas <Ctrl>+<Delete>
												  Nil,;				// Função executada para validar a exclusão de uma linha do aCols
												  oPanelDR,;		// Objeto no qual a MsNewGetDados será criada
												  @aHeader,;
												  @aCols)			
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ativa o Dialogo...                                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 , Nil , aButtons ) CENTERED
		EndIf
	
		MBrChgLoop(.F.) // Desabilita a chamada da tela de inclusão novamente.
	
	End Sequence       

	If lNewAtu .and. Select('SRMAUX') > 0
		DbSelectArea('SRMAUX')
		DbCloseArea()
	EndIf 

EndIf

RestKeys(aKeys,.T.)

Return(Nil) 
 
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RhMkAll     ³ Autor ³ Leandro Drumond     ³ Data ³ 28/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Marca/Desmarca todos os elementos do browse                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEA161                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Static Function RhMkAll( cAlias, lInverte, lTodos, cCpoCtrl, cMark, cMarkAux ) 
  
Local nRecno		:= (cAlias)->(Recno())

(cAlias)->( dbGotop() )

While (cAlias)->( !Eof() )  
	
	RhMkMrk( cAlias , lInverte , lTodos, cCpoCtrl, cMark, {})
	
	(cAlias)->( dbSkip() )
End While

(cAlias)->( MsGoto( nRecno ) )

If cMark == cMarkAux
	cMark := ""
Else
	cMark := cMarkAux
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fRelacProc  ³ Autor ³ Leandro Drumond     ³ Data ³ 27/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Relaciona processos e roteiros.                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEA161                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Function fRelacProc(cProcesso,cRoteiro,aColsAux,aHeaderAux)

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aGDCoord		:= {}
Local aProcArq		:= {}
Local aRotArq		:= {}
Local aSvKeys		:= GetKeys()
Local aButtons 		:= {}
Local bSet15
Local bSet24
Local cTitJan 		:= ""
Local cProcArq		:= ""
Local cRotArq		:= ""
Local cProcRGA		:= AllTrim(RGA->RGA_PROCES) + " - " + fDesc('RCJ', RGA->RGA_PROCES, 'RCJ_DESCRI', NIL, xFilial('SRM'))
Local cRotRGA		:= AllTrim(RGA->RGA_CALCUL) + " - " + fDesc('SRY', RGA->RGA_CALCUL, 'RY_DESC', NIL, xFilial('SRM'))
Local lRet    		:= .F.
Local nPosProc 	 	:= GdFieldPos("RM_PROCES" , aHeaderAux)
Local nPosCalc 	 	:= GdFieldPos("RM_CALCULO" , aHeaderAux)
Local oDlg
Local oGroup
Local oSay
Local oFont
Local oProcesso
Local oRoteiro
Local oProcNew
Local oRotNew

//Carrega os arrays aProcArq e aRotArq
aEval( aColsAux ,{ |X| If(X[nPosProc] $ cProcArq, Nil, ( cProcArq += X[nPosProc] + "|" , aAdd(aProcArq,X[nPosProc] ) ) ) } )

aEval( aColsAux ,{ |X| If(X[nPosCalc] $ cRotArq, Nil, ( cRotArq += X[nPosCalc] + "|" , aAdd(aRotArq,X[nPosCalc] ) ) ) } )
 
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta as Dimensoes dos Objetos         					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdvSize		:= MsAdvSize(,.T.,55)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }					 
aAdd( aObjCoords , { 000 , 50 , .T. , .F. } )
aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM  aAdvSize[7]-30,0 TO (aAdvSize[6]/1.45),aAdvSize[5]/1.3 TITLE OemToAnsi(STR0046) PIXEL

bSet15 := {|| lRet := .T., oDlg:End()}
bSet24 := {|| lRet := .F., oDlg:End()}

@ aObjSize[1,1],aObjSize[1,2] GROUP oGroup TO aObjSize[1,3],aObjSize[1,4]/1.3 OF oDlg PIXEL

//Se roteiro ou processo estiver vazio, nao esta posicionado em nenhum registro, desta forma, abre o combo para que possa selecionar dentre os existentes
If !Empty(cProcRGA) .and. !Empty(cRotRGA)
	@ aObjSize[1,1]+10,aObjSize[1,2]+15 GET oProcesso VAR cProcRGA SIZE 100,10 OF oDlg PIXEL WHEN .F.
	@ aObjSize[1,1]+30,aObjSize[1,2]+15 GET oRoteiro VAR cRotRGA SIZE 100,10 OF oDlg PIXEL WHEN .F.
	oSay	:= tSay():New(38,20,{||OemToAnsi(STR0036)},oDlg,,,,,,.T.) // Proceso:
	oSay	:= tSay():New(58,20,{||OemToAnsi(STR0037)},oDlg,,,,,,.T.) // Procedimiento:
EndIf

oProcNew := TComboBox():New(aObjSize[1,1]+10,aObjSize[1,2]+120,{|u|if(PCount()>0,cProcesso:=u,cProcesso)}, aProcArq ,100,20,oDlg,,{|| Nil /*mudanca de item no combo*/},,,,.T.,,,,,,,,,'cProcesso')

oRotNew := TComboBox():New(aObjSize[1,1]+30,aObjSize[1,2]+120,{|u|if(PCount()>0,cRoteiro:=u,cRoteiro)}, aRotArq ,100,20,oDlg,,{|| Nil /*mudanca de item no combo*/},,,,.T.,,,,,,,,,'cRoteiro')

@0,0 BUTTON oBtnConfirm PROMPT "" SIZE 00,00 PIXEL ACTION Eval({|| iif(Empty(cProcesso) .or. Empty(cRoteiro),Nil,oDlg:End()) })
                                                                     
ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 , Nil , aButtons ) CENTERED

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCriaTmp       ³ Autor ³ Leandro Drumond    ³ Data ³ 27/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Cria tabela temporaria para uso no MsSelect       			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fCriaTmp(aColsAux,aHeaderAux)                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEA161					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fCriaTmp(aColsAux,aHeaderAux,cProcAux,cRotAux,aSRMAux)
Local aColumns	 := {}

Local cAliasCnt	 := ''
Local lRet		 := .F.
Local nX 		 := 0
Local nPosSRM	 := 0
Local nPosFilial := GdFieldPos("RM_FILIAL" , aHeaderAux)
Local nPosProc 	 := GdFieldPos("RM_PROCES" , aHeaderAux)
Local nPosCalc 	 := GdFieldPos("RM_CALCULO", aHeaderAux)
Local nPosSeq 	 := GdFieldPos("RM_SEQ"    , aHeaderAux)
Local nPosVerba  := GdFieldPos("RM_VERBA"  , aHeaderAux)
Local nPosFor 	 := GdFieldPos("RM_CODFOR" , aHeaderAux)
Local nPosVersao := GdFieldPos("RM_VERSAO" , aHeaderAux)
Local nPosChave  := GdFieldPos("RM_CHAVE"  , aHeaderAux)
Local nPosCri    := GdFieldPos("RM_CODCRI" , aHeaderAux)
Local nPosGerAcu := GdFieldPos("RM_GERAACU", aHeaderAux)
Local nPosLeeInc := GdFieldPos("RM_LEEINC" , aHeaderAux)
Local nPosLeePre := GdFieldPos("RM_LEEPRE" , aHeaderAux)
Local nPosLeeAcu := GdFieldPos("RM_LEEACU" , aHeaderAux)
Local nPosLeeAus := GdFieldPos("RM_LEEAUS" , aHeaderAux)
Local nPosLeeBen := GdFieldPos("RM_LEEBEN" , aHeaderAux)
Local nPosLeeFix := GdFieldPos("RM_LEEFIX" , aHeaderAux)
	
If Select('SRMAUX') > 0
	DbSelectArea('SRMAUX')
	DbCloseArea()
EndIf 
aAdd( aColumns, { "RM_OKTRANS"	,"C",02,00 })
aAdd( aColumns, { "RM_FILIAL"	,"C",TAMSX3("RM_FILIAL")[1],TAMSX3("RM_FILIAL")[2]})
aAdd( aColumns, { "RM_PROCES"	,"C",TAMSX3("RM_PROCES")[1],TAMSX3("RM_PROCES")[2]})
aAdd( aColumns, { "RM_CALCULO"	,"C",TAMSX3("RM_CALCULO")[1],TAMSX3("RM_CALCULO")[2]})
aAdd( aColumns, { "RM_SEQ"		,"C",TAMSX3("RM_SEQ")[1],TAMSX3("RM_SEQ")[2]})
aAdd( aColumns, { "RM_VERBA"	,"C",TAMSX3("RM_VERBA")[1],TAMSX3("RM_VERBA")[2]})
aAdd( aColumns, { "RM_DESCPD"	,"C",TAMSX3("RM_DESCPD")[1],TAMSX3("RM_DESCPD")[2]})
aAdd( aColumns, { "RM_CODFOR"	,"C",TAMSX3("RM_CODFOR")[1],TAMSX3("RM_CODFOR")[2]})
aAdd( aColumns, { "RM_DESCFOR"	,"C",TAMSX3("RM_DESCFOR")[1],TAMSX3("RM_DESCFOR")[2]})
aAdd( aColumns, { "RM_VERSAO"	,"C",TAMSX3("RM_VERSAO")[1],TAMSX3("RM_VERSAO")[2]})
aAdd( aColumns, { "RM_CHAVE"	,"C",TAMSX3("RM_CHAVE")[1],TAMSX3("RM_CHAVE")[2]})
aAdd( aColumns, { "RM_CODCRI"	,"C",TAMSX3("RM_CODCRI")[1],TAMSX3("RM_CODCRI")[2]})
aAdd( aColumns, { "RM_GERAACU"	,"C",TAMSX3("RM_GERAACU")[1],TAMSX3("RM_GERAACU")[2]})
aAdd( aColumns, { "RM_LEEINC"	,"C",TAMSX3("RM_LEEINC")[1],TAMSX3("RM_LEEINC")[2]})
aAdd( aColumns, { "RM_LEEPRE"	,"C",TAMSX3("RM_LEEPRE")[1],TAMSX3("RM_LEEPRE")[2]})
aAdd( aColumns, { "RM_LEEACU"	,"C",TAMSX3("RM_LEEACU")[1],TAMSX3("RM_LEEACU")[2]})
aAdd( aColumns, { "RM_LEEAUS"	,"C",TAMSX3("RM_LEEAUS")[1],TAMSX3("RM_LEEAUS")[2]})
aAdd( aColumns, { "RM_LEEBEN"	,"C",TAMSX3("RM_LEEBEN")[1],TAMSX3("RM_LEEBEN")[2]})
aAdd( aColumns, { "RM_LEEFIX"	,"C",TAMSX3("RM_LEEFIX")[1],TAMSX3("RM_LEEFIX")[2]})
aAdd( aColumns, { "RM_PROCAUX"	,"C",30,0})
aAdd( aColumns, { "RM_ROTAUX"	,"C",30,0})

oTmpTbl := FWTemporaryTable():New("SRMAUX")
oTmpTbl:SetFields(aColumns)
oTmpTbl:Create()

DbSelectArea('SRMAUX')

For nX := 1 to Len(aColsAux)
	
	If AllTrim(aColsAux[nX,nPosProc]) == cProcAux .and. AllTrim(aColsAux[nX,nPosCalc]) == cRotAux

		nPosSRM := aScan( aSRMAux, { |x| x[1] == aColsAux[nX,nPosChave] } )
		
		//Se nao encontrar chave no array auxiliar ou se a chave estiver marcada com verdadeiro no array, inclui registro.
		If nPosSRM == 0 .or. aSRMAUX[nPosSRM,2]

			RecLock('SRMAUX',.T.)
			SRMAUX->RM_FILIAL 	:= aColsAux[nX,nPosFilial]
			SRMAUX->RM_PROCES 	:= RGA->RGA_PROCES
			SRMAUX->RM_CALCULO	:= RGA->RGA_CALCUL
			SRMAUX->RM_SEQ	    := aColsAux[nX,nPosSeq]
			SRMAUX->RM_VERBA	:= aColsAux[nX,nPosVerba]
			SRMAUX->RM_DESCPD	:= fDesc("SRV",aColsAux[nX,nPosVerba],"RV_DESC")
			SRMAUX->RM_CODFOR	:= aColsAux[nX,nPosFor]
			SRMAUX->RM_DESCFOR	:= fDesc("RC2",aColsAux[nX,nPosFor],"RC2_DESC",,,2)
			SRMAUX->RM_VERSAO	:= aColsAux[nX,nPosVersao]
			SRMAUX->RM_CHAVE	:= aColsAux[nX,nPosChave]
			SRMAUX->RM_PROCAUX	:= aColsAux[nX,nPosProc]
			SRMAUX->RM_ROTAUX	:= aColsAux[nX,nPosCalc]
			SRMAUX->RM_CODCRI	:= aColsAux[nX,nPosCri]
			SRMAUX->RM_GERAACU 	:= aColsAux[nX,nPosGerAcu]
			SRMAUX->RM_LEEINC  	:= aColsAux[nX,nPosLeeInc]
			SRMAUX->RM_LEEPRE	:= aColsAux[nX,nPosLeePre]
			SRMAUX->RM_LEEACU	:= aColsAux[nX,nPosLeeAcu]
			SRMAUX->RM_LEEAUS	:= aColsAux[nX,nPosLeeAus]
			SRMAUX->RM_LEEBEN	:= aColsAux[nX,nPosLeeBen]
			SRMAUX->RM_LEEFIX	:= aColsAux[nX,nPosLeeFix]
			
			MsUnLock()
		EndIf
	EndIf
Next nX

If Select("SRMAUX") > 0
	If ("SRMAUX")->(RECCOUNT()) > 0
		lRet := .T.
	EndIf
	dbSelectArea("SRMAUX")
EndIf

Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp160NewAtu    ³ Autor ³ Leandro Drumond    ³ Data ³ 28/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Atualiza roteiros/verbas.                       				³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Gp160NewAtu(aAuxRGA)			                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEA161					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Gp160NewAtu(aAux,aAuxRGA,cMark)
Local aArea				:= GetArea()
Local aLog				:= {} // Array contendo todos os detalhes a serem impressos no Log
Local aLogGrv			:= {} // Array contendo os registros importados 
Local aLogInc			:= {} // Array contendo os registros já existentes
Local aLogBra			:= {} // Array contendo os registros que não possuem Processo ou Roteiro preenchidos
Local aLogVer			:= {} // Array contendo os registros que possuem versao inferior a atual
Local aLogCri			:= {} // Array contendo os registros de criterios inexistentes na RG9
Local aTitle			:= {}
Local aSRMGrv			:= {}
Local cProcesso			:= ""
Local cRoteiro			:= ""
Local cLog				:= ""
Local cMsg				:= ""
Local cChave			:= ""
Local cLogCri			:= ""
Local cFilRGA			:= FwxFilial("RGA", CFILANT)
Local cFilSRM			:= FwxFilial("SRM", CFILANT)
Local lRet 				:= .T. 
Local nI				:= 0
Local nX				:= 0
Local nInc				:= 0
Local nBra				:= 0
Local nAux				:= 0
Local nVer				:= 0
Local nPosTole			:= 0
Local nPosProRot		:= 0
Local nPosInc			:= 0
Local nPosGrv			:= 0 
Local nPosBra			:= 0
Local nRegSRM			:= 0
Local cSeek			:= ''
DbSelectArea('SRMAUX')
DbGoTop()

While SRMAUX->(!Eof())

	If !(SRMAUX->RM_OKTRANS == cMark)
		SRMAUX->(DbSkip())
		Loop
	Else
		cProcesso := SRMAUX->RM_PROCES
		cRoteiro  := SRMAUX->RM_CALCULO
		cChave	  := SRMAUX->RM_CHAVE
		If Empty(AllTrim(cProcesso)) .OR. Empty(AllTrim(cRoteiro))
			nPosBra := aScan(aLogBra, OemToAnsi(STR0036) + AllTrim(SRMAUX->RM_PROCAUX) + OemToAnsi(STR0037) + AllTrim(SRMAUX->RM_ROTAUX))//"Processo: " ### " Roteiro: "
			If nPosBra == 0
				aAdd(aLogBra,OemToAnsi(STR0036) + AllTrim(SRMAUX->RM_PROCAUX) + OemToAnsi(STR0037) + AllTrim(SRMAUX->RM_ROTAUX)) //"Processo: " ### " Roteiro: "
				nBra++
			EndIf
			SRMAUX->(DbSkip())
			Loop
		EndIf
		
		If !(SRMAUX->RM_CODCRI $ cLogCri)
			DbSelectArea('RG9')
			If !(MsSeek(xFilial('RG9') + SRMAUX->RM_CODCRI))
				aAdd(aLogCri,SRMAUX->RM_CODCRI)
			EndIf
			DbCloseArea()
			cLogCri += SRMAUX->RM_CODCRI + "|" 
		EndIf
		
		DbSelectArea("RGA")
		DbSetOrder(1)
		
		If !MsSeek(cFilRGA+cProcesso+cRoteiro)
			RGA->(RecLock("RGA" , .T.))
			RGA->RGA_FILIAL := cFilRGA
			RGA->RGA_PROCES := cProcesso
			RGA->RGA_CALCUL := cRoteiro
	        // Compara Processo e Tipo de Cálculo da RGA com aAux para atribuir RGA_TOLEPG e RGA_TOLECT à tabela RGA
			nPosTole := aScan( aAuxRGA, { |x| AllTrim(x[2]) == AllTrim(SRMAUX->RM_PROCAUX) .AND. AllTrim(x[3]) == AllTrim(SRMAUX->RM_ROTAUX)} )
			If nPosTole <> 0
				RGA->RGA_TOLEPG := aAuxRGA[nPosTole][5] // RGA_TOLEPG
				RGA->RGA_TOLECT := aAuxRGA[nPosTole][6] // RGA_TOLECT
			EndIf
			RGA->(MsUnLock())
			cLog := OemToAnsi(STR0036) + cProcesso + OemToAnsi(STR0037) + cRoteiro // "Processo: " ### " Roteiro: "
			aAdd(aLogGrv,cLog)// Grava os importados
		Else
			cLog := OemToAnsi(STR0036) + cProcesso + OemToAnsi(STR0037) + cRoteiro // "Processo: " ### " Roteiro: "
			nPosGrv := aScan(aLogGrv, cLog)
			nPosInc := aScan(aLogInc, cLog)
			If nPosGrv == 0 .and. nPosInc == 0
		        // Compara Processo e Tipo de Cálculo da RGA com aAux para atribuir RGA_TOLEPG e RGA_TOLECT à tabela RGA
				nPosTole := aScan( aAuxRGA, { |x| AllTrim(x[2]) == AllTrim(SRMAUX->RM_PROCAUX) .AND. AllTrim(x[3]) == AllTrim(SRMAUX->RM_ROTAUX)} )
				If nPosTole <> 0
					RGA->(RecLock("RGA" , .F.))
					RGA->RGA_TOLEPG := aAuxRGA[nPosTole][5] // RGA_TOLEPG
					RGA->RGA_TOLECT := aAuxRGA[nPosTole][6] // RGA_TOLECT
					RGA->(MsUnLock())
					cLog := OemToAnsi(STR0036) + cProcesso + OemToAnsi(STR0037) + cRoteiro // "Processo: " ### " Roteiro: "
					aAdd(aLogGrv,cLog)// Grava os importados
				EndIf
			EndIf
		EndIf		

		dbCloseArea()

		DbSelectArea("SRM")
		IF cPaisLoc == "CHI"
			DbSetOrder(RetOrdem('SRM','RM_FILIAL+RM_PROCES+RM_CALCULO+RM_SEQ'))
			cSeek:= cFilSRM+cProcesso+cRoteiro+SRMAUX->RM_SEQ
		Else
			DbSetOrder(RetOrdem('SRM','RM_FILIAL+RM_PROCES+RM_CALCULO+RM_CHAVE'))
			cSeek := cFilSRM+cProcesso+cRoteiro+SRMAUX->RM_CHAVE
		EndIf
		If !SRM->(MsSeek(cSeek))//FILIAL+PROCESSO+CALCULO+ // cSeek RM_SEQ o RM_CHAVE
			RecLock("SRM" , .T.)
			SRM->RM_FILIAL 	:= cFilSRM
			SRM->RM_PROCES 	:= cProcesso
			SRM->RM_CALCULO	:= cRoteiro
			SRM->RM_CHAVE 	:= cChave
			SRM->RM_SEQ 	:= SRMAUX->RM_SEQ
			SRM->RM_VERBA 	:= SRMAUX->RM_VERBA
			SRM->RM_VERSAO 	:= SRMAUX->RM_VERSAO
			SRM->RM_CODFOR 	:= SRMAUX->RM_CODFOR
			SRM->RM_CODCRI 	:= SRMAUX->RM_CODCRI
			SRM->RM_GERAACU	:= SRMAUX->RM_GERAACU
			SRM->RM_LEEINC 	:= SRMAUX->RM_LEEINC
			SRM->RM_LEEPRE 	:= SRMAUX->RM_LEEPRE
			SRM->RM_LEEACU 	:= SRMAUX->RM_LEEACU
			SRM->RM_LEEAUS 	:= SRMAUX->RM_LEEAUS
			SRM->RM_LEEBEN 	:= SRMAUX->RM_LEEBEN
			SRM->RM_LEEFIX 	:= SRMAUX->RM_LEEFIX
			MsUnLock()
			nX++
		Else
			If SRMAUX->RM_VERSAO >= SRM->RM_VERSAO
				nRegSRM := Recno()
				DbSetOrder(RetOrdem('SRM','RM_FILIAL+RM_PROCES+RM_CALCULO+RM_SEQ'))
				If MsSeek(cFilSRM+cProcesso+cRoteiro+SRMAUX->RM_SEQ)
					If Recno() == nRegSRM
						RecLock("SRM",.F.)
						SRM->RM_SEQ 	:= SRMAUX->RM_SEQ
						SRM->RM_VERBA 	:= SRMAUX->RM_VERBA
						SRM->RM_VERSAO 	:= SRMAUX->RM_VERSAO
						SRM->RM_CODFOR 	:= SRMAUX->RM_CODFOR
						SRM->RM_CODCRI 	:= SRMAUX->RM_CODCRI
						SRM->RM_GERAACU	:= SRMAUX->RM_GERAACU
						SRM->RM_LEEINC 	:= SRMAUX->RM_LEEINC
						SRM->RM_LEEPRE 	:= SRMAUX->RM_LEEPRE
						SRM->RM_LEEACU 	:= SRMAUX->RM_LEEACU
						SRM->RM_LEEAUS 	:= SRMAUX->RM_LEEAUS
						SRM->RM_LEEBEN 	:= SRMAUX->RM_LEEBEN
						SRM->RM_LEEFIX 	:= SRMAUX->RM_LEEFIX
						MsUnLock()
						nX++
					Else
						aAdd(aSRMGrv,{cFilSRM,;
									  cProcesso,;
									  cRoteiro,;
									  cChave,;
									  SRMAUX->RM_SEQ,;
									  SRMAUX->RM_VERBA,;
									  SRMAUX->RM_VERSAO,;
									  SRMAUX->RM_CODFOR,;
									  SRMAUX->RM_CODCRI,;
									  SRMAUX->RM_GERAACU,;
									  SRMAUX->RM_LEEINC,;
									  SRMAUX->RM_LEEPRE,;
									  SRMAUX->RM_LEEACU,;
									  SRMAUX->RM_LEEAUS,;
									  SRMAUX->RM_LEEBEN,;
									  SRMAUX->RM_LEEFIX})
					EndIf
				Else
					DbGoTo(nRegSRM)
					RecLock("SRM",.F.)
					SRM->RM_SEQ 	:= SRMAUX->RM_SEQ
					SRM->RM_VERBA 	:= SRMAUX->RM_VERBA
					SRM->RM_VERSAO 	:= SRMAUX->RM_VERSAO
					SRM->RM_CODFOR 	:= SRMAUX->RM_CODFOR
					SRM->RM_CODCRI 	:= SRMAUX->RM_CODCRI
					SRM->RM_GERAACU	:= SRMAUX->RM_GERAACU
					SRM->RM_LEEINC 	:= SRMAUX->RM_LEEINC
					SRM->RM_LEEPRE 	:= SRMAUX->RM_LEEPRE
					SRM->RM_LEEACU 	:= SRMAUX->RM_LEEACU
					SRM->RM_LEEAUS 	:= SRMAUX->RM_LEEAUS
					SRM->RM_LEEBEN 	:= SRMAUX->RM_LEEBEN
					SRM->RM_LEEFIX 	:= SRMAUX->RM_LEEFIX
					MsUnLock()
					nX++
				EndIf
			Else
				cLog := OemToAnsi(STR0036) + cProcesso + OemToAnsi(STR0037) + cRoteiro + OemToAnsi(STR0047) + SRMAUX->RM_SEQ // "Processo: ###  Roteiro: ### Sequencia: ###
				aAdd(aLogVer,cLog)
				nVer++			
			EndIf
		EndIf		
		
		dbCloseArea()
	EndIf
	SRMAUX->(DbSkip())
EndDo

If !Empty(aSRMGrv)
	nRegSRM := Len(aSRMGrv)
	While nRegSRM >= 1
		DbSelectArea("SRM")
		DbSetOrder(RetOrdem('SRM','RM_FILIAL+RM_PROCES+RM_CALCULO+RM_CHAVE'))
		If MsSeek(aSRMGrv[nRegSRM,1]+aSRMGrv[nRegSRM,2]+aSRMGrv[nRegSRM,3]+aSRMGrv[nRegSRM,4])//FILIAL+PROCESSO+CALCULO+CHAVE
			RecLock("SRM",.F.)
			SRM->RM_SEQ 	:= aSRMGrv[nRegSRM,05]
			SRM->RM_VERBA 	:= aSRMGrv[nRegSRM,06]
			SRM->RM_VERSAO 	:= aSRMGrv[nRegSRM,07]
			SRM->RM_CODFOR 	:= aSRMGrv[nRegSRM,08]
			SRM->RM_CODCRI 	:= aSRMGrv[nRegSRM,09]
			SRM->RM_GERAACU	:= aSRMGrv[nRegSRM,10]
			SRM->RM_LEEINC 	:= aSRMGrv[nRegSRM,11]
			SRM->RM_LEEPRE 	:= aSRMGrv[nRegSRM,12]
			SRM->RM_LEEACU 	:= aSRMGrv[nRegSRM,13]
			SRM->RM_LEEAUS 	:= aSRMGrv[nRegSRM,14]
			SRM->RM_LEEBEN 	:= aSRMGrv[nRegSRM,15]
			SRM->RM_LEEFIX 	:= aSRMGrv[nRegSRM,16]
			MsUnLock()
			nX++
		EndIf
		nRegSRM--
	EndDo
EndIf

If !Empty(aLogGrv)
	aAdd(aLog,aLogGrv)
	aAdd(aTitle , OemToAnsi(STR0038) + AllTrim(Str(nX))) // "Registros importados: "
EndIf
If !Empty(aLogInc)
	aAdd(aLog,aLogInc)
	aAdd(aTitle , OemToAnsi(STR0039) + AllTrim(Str(nInc))) // "Inconsistências (Registros já existentes): "
EndIf
If !Empty(aLogBra)
	aAdd(aLog,aLogBra)
	aAdd(aTitle , OemToAnsi(STR0040) + AllTrim(Str(nBra))) // "Inconsistências (Processo a importar ou Roteiro a importar em branco): "
EndIf
If !Empty(aLogVer)
	aAdd(aLog,aLogVer)
	aAdd(aTitle , OemToAnsi(STR0048) + AllTrim(Str(nVer))) // "Inconsistências (Registro da base com versão superior ao do arquivo de atualizaçao): "
EndIf
If !Empty(aLogCri)
	aAdd(aLog,aLogCri)
	aAdd(aTitle , OemToAnsi(STR0049)) // "Inconsistências (Os seguintes critérios devem ser cadastrados): "
EndIf

fMakeLog(aLog,aTitle,,,,,,,,.F.)

RestArea(aArea)

Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCarSRY        ³ Autor ³ Leandro Drumond    ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Carrega dados da tabela SRY p/cadastro de Verbas				³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fCarSRY(aSRYAux, aSRYAuxHdr)                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEA161					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fCarSRY(aSRYAux, aSRYAuxHdr)
Local aAux		:= {}
Local aSRYHeader:= {}
Local bFunc		:= {|| NIL}
Local cCampo	:= ""
Local cFilSRY	:= xFilial("SRY")
Local cCalculos	:= ""
Local cFunction	:= ("GPSRY" + cPaisLoc)
Local cMsg 		:= ""
Local cSrySeqFil:= ""
Local nFieldPos
Local nPosField
Local nPosCalculo
Local nPosAcumul
Local nAux
Local nAuxs
Local nX
Local uCnt
Local lRet := .F.

// Verifica a Existencia da Funcao do Pais Corrente
If FindFunction(cFunction)
	bFunc := __ExecMacro("{ ||  " + cFunction + "( @aAux , @aSRYHeader ) }")
	Eval(bFunc)
	DbSelectarea("SRY")
	DbSetOrder(1) //RY_FILIAL + RY_CALCULO
	SRY->(DbGoTop())
	
	ProcRegua(Len(aAux))

	nPosCalculo := GdFieldPos("RY_CALCULO" , aSRYHeader)
	aSRYAux := aClone(aAux)
	aSRYAuxHdr := aClone(aSRYHeader)
	nAuxs := Len(aAux)
	DbSelectarea("SRY")
	DbSetOrder(1) //RY_FILIAL + RY_CALCULO
	For nAux := 1 To nAuxs
		IncProc(Str(nAux))
		cCalculos	:= Padr(Upper(AllTrim(aAux[ nAux, nPosCalculo ])),TamSX3("RY_CALCULO")[1])
		If SRY->(MsSeek(cFilSRY + cCalculos))
			If Empty(SRY->RY_SEQFIL)
				cSrySeqFil := GetSrySeqFil(cFilSRY)
			EndIf
			RecLock("SRY",.F.,.T.)
		Else
			RecLock("SRY",.T.,.T.)
			cSrySeqFil := GetSrySeqFil(cFilSRY)
		EndIf
		For nX := 1 To Len(aSRYHeader)
		   	cCampo := Upper(aSRYHeader[nX, 2])
			nFieldPos := SRY->(ColumnPos(cCampo))
			If (nFieldPos > 0)
				If (aSRYHeader[nX, 2] == "RY_FILIAL")
					uCnt := cFilSRY
				Else
			    	nPosField := GdFieldPos(cCampo , aSRYHeader)
			    	If (nPosField == 0)
			    		Loop
			    	EndIF
			    	uCnt := aAux[nAux , nPosField]
				Endif
				SRY->(FieldPut(nFieldPos , uCnt))
			EndIF
		Next nX
		If !Empty(cSrySeqFil)
			SRY->RY_SEQFIL := cSrySeqFil
		EndIf
		SRY->(MsUnlock())

	Next nAux
	lRet := .T.
Else
	MsgInfo( OemToAnsi(STR0032) + cPaisLoc + OemToAnsi(STR0033) + CRLF + OemToAnsi(STR0023), OemToAnsi(STR0013)) // "O programa GPSRY" + cPaisLoc +".PRX não está compilado."  ### "Favor verificar!" ###"Atenção!"
	lSRYPrx := IIf(cPaisLoc <> "BRA", .F., .T.)
EndIf

Return(lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GP160VLDCAMPOS ³ Autor ³ Leandro Drumond    ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Atualiza dados das tabelas RGA e SRM							³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³GP160VLDCAMPOS(cAlias)	                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEA161					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GP160VLDCAMPOS(cAlias)
Local lRet	:= .T.

If cAlias == "RCJ"

	If !Empty(M->RM_PROC2)
		DbSelectArea("RCJ")
		RCJ->(DbSetOrder(1))
		If !RCJ->(MsSeek(xFilial("RCJ") + M->RM_PROC2))
			MsgAlert( OemToAnsi(STR0034) ) // "Processo Inválido!"
			lRet := .F.
		EndIf
	EndIf
ElseIf cAlias == "SRY"
   	If !Empty(M->RM_CALC2)
		DbSelectArea("SRY")
		SRY->(DbSetOrder(1))
		If !SRY->(MsSeek(xFilial("SRY") + M->RM_CALC2))
			MsgAlert(OemToAnsi(STR0035)) // "Roteiro Inválido!"
			lRet := .F.
		EndIf
	EndIf
EndIf							

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GP160ATUVPP    ³ Autor ³ Leandro Drumond    ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Atualiza dados das tabelas RGA e SRM							³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³GP160ATUVPP(aAux, aAuxRGA, aCols, aHeader)                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEA161					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GP160ATUVPP(aAux, aAuxRGA, aCols, aHeader)
Local aArea				:= GetArea()
Local aLog				:= {} // Array contendo todos os detalhes a serem impressos no Log
Local aLogGrv			:= {} // Array contendo os registros importados 
Local aLogInc			:= {} // Array contendo os registros já existentes
Local aLogBra			:= {} // Array contendo os registros que não possuem Processo ou Roteiro preenchidos
Local aLogCri			:= {}
Local aTitle			:= {}
Local cProcesso			:= ""
Local cRoteiro			:= ""
Local cLog				:= ""
Local cMsg				:= ""
Local cLogCri			:= ""
Local cFilRGA			:= FwxFilial("RGA", CFILANT)
Local cFilSRM			:= FwxFilial("SRM", CFILANT)
Local lRet 				:= .T. 
Local nI				:= 0
Local nX				:= 0
Local nInc				:= 0
Local nBra				:= 0
Local nAux				:= 0
Local nPosTole			:= 0
Local nPosProRot		:= 0
Local nPosInc			:= 0
Local nPosGrv			:= 0 
Local nPosBra			:= 0
Local nPosSEQ    		:= GdFieldPos( "RM_SEQ"		, aHeader )
Local nPosVERBA			:= GdFieldPos( "RM_VERBA"	, aHeader )
Local nPosCODFOR		:= GdFieldPos( "RM_CODFOR"	, aHeader )
Local nPosCODCRI		:= GdFieldPos( "RM_CODCRI"	, aHeader )
Local nPosGERAACU		:= GdFieldPos( "RM_GERAACU"	, aHeader )
Local nPosLEEINC		:= GdFieldPos( "RM_LEEINC"	, aHeader )
Local nPosLEEPRE		:= GdFieldPos( "RM_LEEPRE"	, aHeader )
Local nPosLEEAUS		:= GdFieldPos( "RM_LEEAUS"	, aHeader )
Local nPosLEEBEN		:= GdFieldPos( "RM_LEEBEN"	, aHeader )
Local nPosLEEFIX		:= GdFieldPos( "RM_LEEFIX"	, aHeader )
Local nPosLEEACU		:= GdFieldPos( "RM_LEEACU"	, aHeader )
Local nPosVERSAO		:= GdFieldPos( "RM_VERSAO"	, aHeader )
Local nPosCHAVE			:= GdFieldPos( "RM_CHAVE"	, aHeader )
Local nPosHabil 		:= GdFieldPos( "RM_HABILIT"	, aHeader )
Local nTotDatos         := Len(aAux)
Local nVacios           := 0

If cPaisLoc <> "BRA"
	AEval(aCols, {|x,y| If(Empty(aCols[y][3]), nVacios++,.T.)})
	
	If nVacios == Len(aCols)
		MsgAlert(STR0068, OemToAnsi(STR0013)) //"Para todos los registros, no se indicó la columna de proceso a importar." //"Atención!"
		Return .F.
	Else
		If nVacios > 0
			MsgInfo(STR0069, OemToAnsi(STR0013)) //"Para algunos registros no se informó la columna de proceso a importar, y no serán tomados en cuenta para el proceso de importación." //"Atención!"
		EndIf
	EndIf
EndIf

ProcRegua(Len(aAux))

For nI := 1 To Len(aAux)	
	// Compara Processo e Tipo de Cálculo do aCols com aAux para atribuir RM_PROCES e RM_CALCULO à tabela SRM
	nPosProRot := aScan( aCols, { |x| x[1] == aAux[nI][nPosRMProces] .AND. x[2] == aAux[nI][nPosCalculo]} )
	If nPosProRot == 0
		Loop
	Else
		cProcesso := aCols[nPosProRot][3]
		cRoteiro  := aCols[nPosProRot][4]
		IncProc()
		If Empty(AllTrim(cProcesso)) .OR. Empty(AllTrim(cRoteiro))
			nPosBra := aScan(aLogBra, OemToAnsi(STR0036) + aAux[nI][nPosRMProces] + OemToAnsi(STR0037) + aAux[nI][nPosCalculo])//"Processo: " ### " Roteiro: "
			If nPosBra == 0
				aAdd(aLogBra,OemToAnsi(STR0036) + aAux[nI][nPosRMProces] + OemToAnsi(STR0037) + aAux[nI][nPosCalculo]) //"Processo: " ### " Roteiro: "
				nBra++
			EndIf
			Loop
		EndIf
		If !Empty(nPosCodCri)		
			If !(aAux[nI][nPosCODCRI] $ cLogCri)
				DbSelectArea('RG9')
				If !(MsSeek(xFilial('RG9') + aAux[nI][nPosCODCRI]))
					aAdd(aLogCri,aAux[nI][nPosCODCRI])
				EndIf
				DbCloseArea()
				cLogCri += aAux[nI][nPosCODCRI] + "|" 
			EndIf
		EndIf
		
		DbSelectArea("RGA")
		RGA->(DbSetOrder(1)) //RGA_FILIAL+RGA_PROCES+RGA_CALCUL
		
		If !RGA->(MsSeek(cFilRGA+cProcesso+cRoteiro))
			RGA->(RecLock("RGA" , .T.))
			RGA->RGA_FILIAL := cFilRGA
			RGA->RGA_PROCES := cProcesso
			RGA->RGA_CALCUL := cRoteiro
	        // Compara Processo e Tipo de Cálculo da RGA com aAux para atribuir RGA_TOLEPG e RGA_TOLECT à tabela RGA
			nPosTole := aScan( aAuxRGA, { |x| x[2] == aAux[nI][nPosRMProces] .AND. x[3] == aAux[nI][nPosCalculo]} )
			If nPosTole <> 0
				RGA->RGA_TOLEPG := aAuxRGA[nPosTole][5] // RGA_TOLEPG
				RGA->RGA_TOLECT := aAuxRGA[nPosTole][6] // RGA_TOLECT

				If !(cPaisLoc $ "RUS|BRA")
					If ColumnPos("RGA_PDPERI") > 0
						RGA->RGA_PDPERI := aAuxRGA[nPosTole][4] //RGA_PDPERI
					EndIf
					If ColumnPos("RGA_DTINIC") > 0
						RGA->RGA_DTINIC := aAuxRGA[nPosTole][7] //RGA_DTINIC
					EndIf
					If ColumnPos("RGA_MODULO") > 0
						RGA->RGA_MODULO := aAuxRGA[nPosTole][8] //RGA_MODULO
					EndIf
				EndIf
			EndIf
			RGA->(MsUnLock())
			nX++
			cLog := OemToAnsi(STR0036) + cProcesso + OemToAnsi(STR0037) + cRoteiro // "Processo: " ### " Roteiro: "
			aAdd(aLogGrv,cLog)// Grava os importados
		Else
			cLog := OemToAnsi(STR0036) + cProcesso + OemToAnsi(STR0037) + cRoteiro // "Processo: " ### " Roteiro: "
			nPosGrv := aScan(aLogGrv, cLog)
			nPosInc := aScan(aLogInc, cLog)
			If nPosGrv == 0 .and. nPosInc == 0
				nInc++
				aAdd(aLogInc,cLog)// Grava os que já existem (Inconsistências)
			EndIf
		EndIf		

		dbCloseArea()
        
		DbSelectArea("SRM")
		DbSetOrder(2) //RM_FILIAL+RM_PROCES+RM_CALCULO+RM_SEQ
	   	If !MsSeek(cFilSRM+cProcesso+cRoteiro+aAux[nI][nPosSEQ])//FILIAL+PROCESSO+CALCULO+SEQ
		
			SRM->(RecLock("SRM" , .T.))
			SRM->RM_FILIAL := cFilSRM
			If !Empty(nPosCHAVE)
				SRM->RM_CHAVE := aAux[nI][nPosCHAVE]
			EndIf
			If !Empty(nPosSEQ)
				SRM->RM_SEQ := aAux[nI][nPosSEQ]
			EndIf
			If !Empty(nPosVERBA)
				SRM->RM_VERBA := aAux[nI][nPosVERBA]
			EndIf

			// PROCESSO
			SRM->RM_PROCES := cProcesso
            // ROTEIRO
			SRM->RM_CALCULO := cRoteiro
			
			If !Empty(nPosVERSAO)
				SRM->RM_VERSAO := aAux[nI][nPosVERSAO]
			EndIf
			If !Empty(nPosCODFOR)
				SRM->RM_CODFOR := aAux[nI][nPosCODFOR]
			EndIf
			If !Empty(nPosCODCRI)
				SRM->RM_CODCRI := aAux[nI][nPosCODCRI]
			EndIf
			If !Empty(nPosGERAACU)
				SRM->RM_GERAACU := aAux[nI][nPosGERAACU]
			EndIf			
			If !Empty(nPosLEEINC)
				SRM->RM_LEEINC := aAux[nI][nPosLEEINC]
			EndIf
			If !Empty(nPosLEEPRE)
				SRM->RM_LEEPRE := aAux[nI][nPosLEEPRE]
			EndIf
			If !Empty(nPosLEEACU)
				SRM->RM_LEEACU := aAux[nI][nPosLEEACU]
			EndIf
			If !Empty(nPosLEEAUS)
				SRM->RM_LEEAUS := aAux[nI][nPosLEEAUS]
			EndIf
			If !Empty(nPosLEEBEN)
				SRM->RM_LEEBEN := aAux[nI][nPosLEEBEN]
			EndIf
			If !Empty(nPosLEEFIX)
				SRM->RM_LEEFIX := aAux[nI][nPosLEEFIX]
			EndIf

			If cPaisLoc <> "BRA" .and. nPosHabil > 0
				SRM->RM_HABILIT:= aAux[nI][nPosHabil]
			EndIf
		EndIf
		SRM->(MsUnLock())
		dbCloseArea()
	EndIf
Next nI

If !Empty(aLogGrv)
	aAdd(aLog,aLogGrv)
	aAdd(aTitle , OemToAnsi(STR0038) + AllTrim(Str(nX))) // "Registros importados: "
EndIf
If !Empty(aLogInc)
	aAdd(aLog,aLogInc)
	aAdd(aTitle , OemToAnsi(STR0039) + AllTrim(Str(nInc))) // "Inconsistências (Registros já existentes): "
EndIf
If !Empty(aLogBra)
	aAdd(aLog,aLogBra)
	aAdd(aTitle , OemToAnsi(STR0040) + AllTrim(Str(nBra))) // "Inconsistências (Processo a importar ou Roteiro a importar em branco): "
EndIf
If !Empty(aLogCri)
	aAdd(aLog,aLogCri)
	aAdd(aTitle , OemToAnsi(STR0049)) // "Inconsistências (Os seguintes critérios devem ser cadastrados): "
EndIf	

fMakeLog(aLog,aTitle,,,,,,,,.F.)

RestArea(aArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GP160ATURGA    ³ Autor ³ Leandro Drumond    ³ Data ³ 28/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Atualiza dados das tabelas RGA    							³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³GP160ATURGA(aAux, aAuxRGA, aCols, aHeader)                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEA161					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function GP160ATURGA(aAux, aAuxRGA, aCols, aHeader)
Local aArea				:= GetArea()
Local cProcesso			:= ""
Local cRoteiro			:= ""
Local cFilRGA			:= FwxFilial("RGA", CFILANT)
Local lRet 				:= .F. 
Local nI				:= 0
Local nPosTole			:= 0
Local nPosProRot		:= 0

For nI := 1 To Len(aAux)

	// Compara Processo e Tipo de Cálculo do aCols com aAux para atribuir RM_PROCES e RM_CALCULO à tabela SRM
	nPosProRot := aScan( aCols, { |x| x[1] == aAux[nI][nPosRMProces] .AND. x[2] == aAux[nI][nPosCalculo]} )
	If nPosProRot == 0
		Loop
	Else
		If !(cProcesso == aCols[nPosProRot][3]) .or. !(cRoteiro == aCols[nPosProRot][4])
			cProcesso := aCols[nPosProRot][3]
			cRoteiro  := aCols[nPosProRot][4]
			If Empty(AllTrim(cProcesso)) .OR. Empty(AllTrim(cRoteiro))
				Loop
			EndIf
			
			DbSelectArea("RGA")
			DbSetOrder(1)
			
			If !MsSeek(cFilRGA+cProcesso+cRoteiro)
				RGA->(RecLock("RGA" , .T.))
				RGA->RGA_FILIAL := cFilRGA
				RGA->RGA_PROCES := cProcesso
				RGA->RGA_CALCUL := cRoteiro
		        // Compara Processo e Tipo de Cálculo da RGA com aAux para atribuir RGA_TOLEPG e RGA_TOLECT à tabela RGA
				nPosTole := aScan( aAuxRGA, { |x| x[2] == aAux[nI][nPosRMProces] .AND. x[3] == aAux[nI][nPosCalculo]} )
				If nPosTole <> 0
					RGA->RGA_TOLEPG := aAuxRGA[nPosTole][5] // RGA_TOLEPG
					RGA->RGA_TOLECT := aAuxRGA[nPosTole][6] // RGA_TOLECT
				EndIf
				RGA->(MsUnLock())
				lRet := .T.
			EndIf
		EndIf
	EndIf
Next nI

DbSelectArea('RGA')
DbGoTop()

RestArea(aArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp160ValidSelect³ Autor ³ Leandro Drumond   ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Regra de validacao para selecao dos criterios de leitura   	³±±
±±³          ³para os seguintes campos 									  	³±±
±±³          ³  Le Incidencias = Sim, Le Ausencias = Nao, Le Emprest=Nao  	³±±
±±³          ³	Le Ausencias = Sim, Le Incidencias = Nao, Le Emprest=Nao  	³±±
±±³          ³	Le Emprestimos = Sim, Le Inc=Nao, Le Aus=Nao, Le Fix = Não	³±± 
±±³          ³	Le Lacto.Fixos = Sim, Le Emprestimos = Nao                	³±± 
±±³          ³	Le Acumuladores -> Sempre pode ser selecionado			  	³±±	
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Gp160ValidSelect()						                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEA161					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Gp160ValidSelect()
Local cRet	  	:= &(ReadVar())
Local cVarTrab 	:= ""
Local oModel	:= FWModelActivate() 
Local oGridSRM 	:= oModel:GetModel("GPEA161_SRM")

If cRet == "1"
    cVarTrab := ReadVar()
	Do case
		Case cVarTrab == "M->RM_LEEAUS"
			oGridSRM:LoadValue("RM_LEEBEN", "2")
			oGridSRM:LoadValue("RM_LEEFIX", "2")
			oGridSRM:LoadValue("RM_LEEINC", "2")
			oGridSRM:LoadValue("RM_LEEPRE", "2")
		Case cVarTrab == "M->RM_LEEBEN"
			oGridSRM:LoadValue("RM_LEEAUS", "2")
			oGridSRM:LoadValue("RM_LEEFIX", "2")
			oGridSRM:LoadValue("RM_LEEINC", "2")
			IF !(cPaisLoc $ "COL|CHI|")
				oGridSRM:LoadValue("RM_LEEPRE", "2")
			End IF
		Case cVarTrab == "M->RM_LEEFIX"
			oGridSRM:LoadValue("RM_LEEAUS", "2")
			oGridSRM:LoadValue("RM_LEEBEN", "2")
			oGridSRM:LoadValue("RM_LEEINC", "2")
			oGridSRM:LoadValue("RM_LEEPRE", "2")
		Case cVarTrab == "M->RM_LEEINC"
			oGridSRM:LoadValue("RM_LEEAUS", "2")
			oGridSRM:LoadValue("RM_LEEBEN", "2")
			oGridSRM:LoadValue("RM_LEEFIX", "2")
			oGridSRM:LoadValue("RM_LEEPRE", "2")
		Case cVarTrab == "M->RM_LEEPRE"
			IF cPaisLoc <> "CHI"
				oGridSRM:LoadValue("RM_LEEAUS", "2")
				IF cPaisLoc <> "COL"
					oGridSRM:LoadValue("RM_LEEBEN", "2")
				End IF
				oGridSRM:LoadValue("RM_LEEINC", "2")
				oGridSRM:LoadValue("RM_LEEFIX", "2")
			ENDIF
	EndCase
EndIf

Return cRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea161ExcluChk³ Autor ³ Leandro Drumond    ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o Roteiro Pode Ser Excluido						³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Gpea161ExcluChk( oModel, nOpc )			                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEA161					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Gpea161ExcluChk( oGrid, nOpc )

Local aArea			:= GetArea()
Local aAreas		:= {}

Local cRGAFil
Local cChave
Local cMsgYesNo
Local cTitLog

Local nAreas

Local lDelOk

//SRM
aAdd( aAreas , Array( 04 ) )
nAreas := Len( aAreas )
aAreas[nAreas,01] := SRM->( GetArea() )
aAreas[nAreas,02] := Array( 3 )
				aAreas[nAreas,02,01] := "RM_FILIAL"
				aAreas[nAreas,02,02] := "RM_PROCES"
				aAreas[nAreas,02,03] := "RM_CALCULO"
aAreas[nAreas,03] := RetOrdem( "SRM"  , "RM_FILIAL+RM_PROCES+RM_CALCULO+RM_SEQ" , .T. )

aAdd( aAreas , Array( 04 ) )
nAreas := Len( aAreas )
aAreas[nAreas,01] := RCH->( GetArea() )
aAreas[nAreas,02] := Array( 3 )
				aAreas[nAreas,02,01] := "RCH_FILIAL"
				aAreas[nAreas,02,02] := "RCH_PROCES"
				aAreas[nAreas,02,03] := "RCH_ROTEIR"
aAreas[nAreas,03] := RetOrdem( "RCH"  , "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG" , .T. )

cMsgYesNo := STR0041	//"O Sistema irá verificar se o Roteiro por Processo"
cMsgYesNo += CRLF
cMsgYesNo += STR0042	//"selecionado para exclusao esta sendo utilizada. A verificacao pode ser demorada !!"
cMsgYesNo += CRLF
cMsgYesNo += CRLF
cMsgYesNo += STR0043	//"Confirma a exclus„o do Roteiro por Processo?"

cTitLog := STR0044		//"Log de Ocorrencias na Exclusao de Roteiro por Processo"

cRGAFil	    := xFilial( "RGA" )
cChave	    := Upper( AllTrim( oGrid:GetValue("RGA_PROCES") + oGrid:GetValue("RGA_CALCUL") ) )

lDelOk		:= ChkDelRegs(	"RGA"			,;	//01 -> Alias de Dominio
							oGrid:nDataID	,;	//02 -> Registro do Dominio
							nOpc			,;	//03 -> Opcao para a AxDeleta
							cRGAFil			,;	//04 -> Filial do do Dominio
							cChave		    ,;	//05 -> Chave do do Dominio
							aAreas			,;	//06 -> Array contendo informacoes dos arquivos a serem pesquisados
							cMsgYesNo		,;	//07 -> Mensagem para MsgYesNo
							cTitLog			,;	//08 -> Titulo do Log de Delecao
							NIL				,;	//09 -> Mensagem para o corpo do Log
							.F.				,;	//10 -> Se executa AxDeleta
							.T.				,;	//11 -> Se deve Mostrar o Log
							NIL				,;	//12 -> Array com o Log de Exclusao
							NIL				,;	//13 -> Array com o Titulo do Log
							NIL				,;	//14 -> Bloco para Posicionamento no Arquivo
							NIL				,;	//15 -> Bloco para a Condicao While
							NIL				,;	//16 -> Bloco para Skip/Loop no While
							.T.				,;	//17 -> Verifica os Relacionamentos no SX9
							NIL     		,;	//18 -> Alias que nao deverao ser Verificados no SX9
							NIL				 ;	//19 -> Se faz uma checagem soft
					 	 )

RestArea( aArea )

Return( lDelOk )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fGetLastKeySRM ³ Autor ³ Leandro Drumond    ³ Data ³ 12/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Obtem a ultima chave da SRM (RM_CHAVE) 						³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fGetLastKeySRM()							                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEA161					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fGetLastKeySRM()

Local cChave	:= ""
Local cDelete 	:= "%D_E_L_E_T_ = ' '%"
Local cAliasSRM := GetNextAlias()

BeginSql alias cAliasSRM
	SELECT MAX(RM_CHAVE) AS CHAVE
	FROM %table:SRM%
	WHERE %exp:cDelete%
EndSql

If !Empty((cAliasSRM)->CHAVE)
	cChave := SubStr((cAliasSRM)->CHAVE,3,4)
Else
	cChave := "0000"
EndIf

(cAliasSRM)->(dbCloseArea())

Return cChave

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RmVerbaWhen    ³ Autor ³ Leandro Drumond    ³ Data ³ 13/09/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³When do campo RM_VERBA				 						³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³RmVerbaWhen()								                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEA160					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function RmVerbaWhen()
Local lRet      := .T.
Local lGpea160	:= IsInCallStack( "GPEA160" )

If!lGpea160 .or. lManutence
	lRet := .T.
Else
	If Empty(M->RM_VERBA)    //Só permite alteracao no caso de ja existir verba oriunda do roteiro padrao
		lRet := .F.
	EndIf
EndIf

Return( lRet  )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fFindCF	  ³ Autor ³ Igor Franzoi     	³ Data ³16/09/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Funcao para pesquisa de Verba e Formula			  		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEA160 													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Static Function fFindCF( aColsFind, aHeaderFind )

Local lPesq

Local nOpcAux
Local nOpcRadio

Local cFormula

Local oRadio
Local oVerba
Local oFormula
Local oDlg
Local oGroup
Local oFont

Local bFind
Local aRetCoords

//Essa variaveis são utilizadas na pesquisa F3 do campo verba,
//para mostrar o conteúdo de forma filtrada
Private cCodProcesso
Private cCodRoteiro
Private cVerba

Private aIndexSRV			:= {}

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta as Dimensoes dos Objetos         					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aRetCoords := RetCoords(1,2,10,35)
aButtons   := {}

If ( Len(aColsFind) > 0 )

	lPesq		:= .F.

	nOpcRadio := 1
	nOpcAux   := nOpcRadio
	nOpcRadio := 0

	cVerba				:= Space( GetSx3Cache( "RV_COD" 			, "X3_TAMANHO" ) )
	cFormula			:= Space( GetSx3Cache( "RC2_CODIGO"	, "X3_TAMANHO" ) )
	cCodProcesso	:= M->RGA_PROCES
	cCodRoteiro		:= M->RGA_CALCUL

	bFind		:= { || Nil }

	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0002 ) FROM 0,0 TO 200,430 OF oMainWnd PIXEL //Pesquisar

	@ aRetCoords[1,1] , aRetCoords[1,2] GROUP oGroup TO aRetCoords[1,1]+50,135 LABEL OemToAnsi(STR0054) OF oDlg PIXEL //"Selecione a opção de Pesquisa:"
	oGroup:oFont:=oFont

	@ aRetCoords[1,1]+10 , aRetCoords[1,2]+10 RADIO oRadio VAR nOpcAux ITEMS 	OemToAnsi(STR0055), OemToAnsi(STR0056),OemToAnsi(STR0055) +" + "+ OemToAnsi(STR0056) ;
		SIZE 115,010 OF oDlg PIXEL

	bSet15		:= { ||nOpcRadio := nOpcAux, lPesq := .T., oDlg:End() }
	bSet24		:= { ||oDlg:End() }

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15 , bSet24 , Nil , aButtons ) CENTERED

	If !( nOpcRadio == 0 )

		bFind := { || If ( fPesqCF( nOpcRadio, cVerba, cFormula, aColsFind, aHeaderFind ), oDlg:End(), .F. ) }

		DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD

		DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0002 ) FROM 0,0 TO 215,400 OF oMainWnd PIXEL //Pesquisar

		If ( nOpcRadio == 1 .or. nOpcRadio == 3 )
		 	@ aRetCoords[1,1] , aRetCoords[1,2] GROUP oGroup TO aRetCoords[1,1] + 30,110 LABEL OemToAnsi(STR0055) OF oDlg PIXEL  //Verba
		 	@ aRetCoords[1,1]+10 , aRetCoords[1,2]+10 MsGet oVerba Var cVerba Picture GetSx3Cache("RV_COD", "X3_PICTURE") F3 "SRV-RM" SIZE 060,010 OF oDlg PIXEL
		EndIf
		If ( nOpcRadio == 2 .or. nOpcRadio == 3 )
			If ( nOpcRadio == 2 )
				@ aRetCoords[1,1]    , aRetCoords[1,2] GROUP oGroup TO aRetCoords[1,1]+30,110 LABEL OemToAnsi(STR0056) OF oDlg PIXEL  //Formula
				@ aRetCoords[1,1]+10 , aRetCoords[1,2]+10 MsGet oFormula Var cFormula Picture GetSx3Cache("RC2_CODIGO", "X3_PICTURE") F3 "RC201" SIZE 060,010 OF oDlg PIXEL
			Else
				@ aRetCoords[2,1]    , aRetCoords[2,2] GROUP oGroup TO aRetCoords[2,1]+30,110 LABEL OemToAnsi(STR0056) OF oDlg PIXEL  //Formula
				@ aRetCoords[2,1]+10 , aRetCoords[2,2]+10 MsGet oFormula Var cFormula Picture GetSx3Cache("RC2_CODIGO", "X3_PICTURE") F3 "RC201" SIZE 060,010 OF oDlg PIXEL
			EndIf
		EndIf

		bSet15		:= { ||oDlg:End() , Eval(bFind) }
		bSet24		:= { ||oDlg:End() }

		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15 , bSet24 , Nil , aButtons ) CENTERED

	EndIf

EndIf

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fPesqCF     ³ Autor ³ Igor Franzoi        ³ Data ³ 16/09/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Valida e localiza as informações na GetDados	   	          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEA160                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Static Function fPesqCF( nOpcRadio, cVerba, cFormula, aColsFind, aHeaderFind )

Local lRet := .T.

Local cMsgAll	:= ""

Local nPosVer	:= GdFieldPos( "RM_VERBA"		, aHeaderFind )
Local nPosFor	:= GdFieldPos( "RM_CODFOR"	, aHeaderFind )
Local nPosSeq	:= GdFieldPos( "RM_SEQ"			, aHeaderFind )

Local nCont

//Valida as informações de verba e formula conforme a seleção
//nOpcRadio = 1 Verba
//nOpcRadio = 2 Formula
//nOpcRadio = 3 Verba + Formula
If ( nOpcRadio == 1 )
	If Empty(cVerba)
		lRet := .F.
		cMsgAll := OemToAnsi(STR0057) + CRLF + OemToAnsi(STR0055)
		MsgAlert( cMsgAll, OemToAnsi(STR0014) ) // "O conteúdo não pode ser branco!" - Atenção
	EndIf
ElseIf ( nOpcRadio == 2 )
	If Empty(cFormula)
		lRet := .F.
		cMsgAll := OemToAnsi(STR0057) + CRLF + OemToAnsi(STR0056)
		MsgAlert( cMsgAll, OemToAnsi(STR0014) )// "O conteúdo não pode ser branco!" - Atenção
	EndIf
ElseIf ( nOpcRadio == 3 )
	If Empty(cVerba) .or. Empty(cFormula)
		lRet := .F.
		cMsgAll := OemToAnsi(STR0057) + CRLF + OemToAnsi(STR0055) + CRLF + OemToAnsi(STR0056)
		MsgAlert( cMsgAll, OemToAnsi(STR0014) )	// "O conteúdo não pode ser branco!" - Atenção
	EndIf
EndIf

If ( lRet )

	cMsgAll := ""

	Do Case
		Case ( nOpcRadio == 1 )
			For nCont := 1 To Len(aColsFind)
				If !(aColsFind[ nCont, Len(aColsFind[nCont]) ])
					If ( AllTrim(aColsFind[ nCont, nPosVer ]) == AllTrim(cVerba) )
						cMsgAll += CRLF + aColsFind[ nCont, nPosSeq ]
					EndIf
				EndIf
			Next
		Case ( nOpcRadio == 2 )
			For nCont := 1 To Len(aColsFind)
				If !(aColsFind[ nCont, Len(aColsFind[nCont]) ])
					If ( AllTrim(aColsFind[ nCont, nPosFor ]) == AllTrim(cFormula) )
						cMsgAll += CRLF + aColsFind[ nCont, nPosSeq ]
					EndIf
				EndIf
			Next
		Case ( nOpcRadio == 3 )
			For nCont := 1 To Len(aColsFind)
				If !(aColsFind[ nCont, Len(aColsFind[nCont]) ])
					If ( AllTrim(aColsFind[ nCont, nPosVer ]) == AllTrim(cVerba) ) .and. ( AllTrim(aColsFind[ nCont, nPosFor ]) == AllTrim(cFormula) )
						cMsgAll += CRLF + aColsFind[ nCont, nPosSeq ]
					EndIf
				EndIf
			Next
	EndCase

	If !Empty(cMsgAll)
		MsgAlert( OemToAnsi(STR0058) + cMsgAll, OemToAnsi(STR0014) ) // "Já existe o conteúdo na(s) sequência(s):" - Atenção
	Else
		MsgAlert( OemToAnsi(STR0059), OemToAnsi(STR0014) ) // "Resultado não localizado!" - Atenção
	EndIf

EndIf

Return lRet

/*/{Protheus.doc} FindRecord
	Procura um registro
@author PHILIPE.POMPEU
@since 04/09/2015
@version P12
@param oView, objeto, instância de FWFormView
@return Nil, Valor nulo
/*/
Static Function FindRecord(oView)
	Local aArea	:= GetArea()
	Local oGrdModel:= Nil
	Local aSaveLines := {}
							
	aSaveLines:= FWSaveRows()
	oGrdModel := oView:GetModel("GPEA161_SRM")				
	fFindCF( oGrdModel:aCols, oGrdModel:aHeader )
	FWRestRows(aSaveLines)
	oView:Refresh()
	
	RestArea(aArea)
Return (Nil)

/*/{Protheus.doc} InsertLine
	Insere Linha no Grid
@author PHILIPE.POMPEU
@since 04/09/2015
@version P12
@param oView, objeto, instância de FWFormView
@return nResult, número da linha que foi inserida.
/*/
Static Function InsertLine(oView,lRefresh)
	Local aArea	:= GetArea()
	Local oGrdModel:= Nil
	Local oFldsModel	:= Nil
	Local nOperation:= 0
	Local nLinhaAnt := 0
	Local nResult := 0
	Local xTemp
	Local nI := 0
	Default oView := Nil
	Default lRefresh:= .T.
	
	if(oView <> Nil)
		nOperation := oView:GetOperation()
		
		if(nOperation == 4) //.Or. (nOperation == 3)
		
			if(oView:CanInsertLine('GPEA161_SRM'))				

				oGrdModel := oView:GetModel("GPEA161_SRM")
				oFldsModel := oView:GetModel("GPEA161_RGA")
				nLinhaAnt := oGrdModel:nLine 
				xTemp := Val(oGrdModel:GetValue('RM_SEQ'))
				xTemp := StrZero(xTemp,nTamSeq)	
			
				
				for nI:= nLinhaAnt to oGrdModel:Length()
					oGrdModel:GoLine(nI)
					
					nValor := Val(oGrdModel:GetValue("RM_SEQ")) + 1
					
					oGrdModel:LoadValue("RM_SEQ",StrZero(nValor,nTamSeq))						
							
				next nI
				oGrdModel:AddLine()
				oGrdModel:LoadValue("RM_FILIAL"	,xFilial('SRM'))
				oGrdModel:LoadValue("RM_PROCES"	,oFldsModel:GetValue("RGA_PROCES"))
				oGrdModel:LoadValue("RM_CALCULO",oFldsModel:GetValue("RGA_CALCUL"))	
							
				oGrdModel:LoadValue("RM_SEQ",xTemp)
				
				aSort(oGrdModel:aCols,/*<nInicio>*/,/*<nCont>*/,{|x,y|x[2] < y[2]})
				
				
				for nI:= oGrdModel:Length() to nLinhaAnt + 1 Step - 1
					if((nI - 1) > 0)						
						oGrdModel:LineShift(nI - 1, nI)
					endIf
				next nI
				
				for nI:= 0 to oGrdModel:Length()
					oGrdModel:GoLine(nI)
					
					if(oGrdModel:GetValue("RM_SEQ") == xTemp)
						nResult := nI	
						Exit
					endIf						
							
				next nI
				
			Else
				Help(" ",1,"Help",,OemToAnsi(STR0061),1,0)
			endIf	
			
			if(lRefresh)				
				oView:Refresh()
			endIf
		Else
			Help(" ",1,"Help",,OemToAnsi(STR0060),1,0)
		endIf
	endIf

	RestArea(aArea)
Return (nResult)

/*/{Protheus.doc} CopyLine
 Copia uma Linha
@author PHILIPE.POMPEU
@since 04/09/2015
@version P11
@param oView, objeto, instância de FWFormView
@return Nil, Valor nulo
/*/
Static Function CopyLine(oView)
	Local aArea	:= GetArea()	
	Local oGrdModel:= Nil
	Local nOperation:= 0
	Local nLinhaAnt := 0
	Local aLine := {}
	Local oStruct
	Local aTemp := {}
	Local aCampos:= {}
	Local nI := 0
	Local aSaveLines := {}
	Default oView := Nil
	
	if(oView <> Nil)
		nOperation := oView:GetOperation()
		
		if(nOperation == 4) 
			
			oGrdModel := oView:GetModel("GPEA161_SRM")				
			aLine := aClone(oGrdModel:aDataModel[oGrdModel:nLine,1,1])
			oStruct := oGrdModel:GetStruct()
										
			aEval(oStruct:GetFields(),{|x|aAdd(aCampos,{x[3]})})
			
			for nI:= 1 to Len(aCampos)
				aAdd(aCampos[nI],aLine[nI])
			next nI			
			
			aSize(aTempLine,0)
			aTempLine:= aClone(aCampos)
			
			oStruct := Nil
			oGrdModel := Nil
			aSize(aLine,0)
			aLine := Nil
		Else
			Help(" ",1,"Help",,OemToAnsi(STR0060),1,0)
		endIf
	endIf
	
	RestArea(aArea)
Return (Nil)

/*/{Protheus.doc} PasteLine
	Cola uma linha
@author PHILIPE.POMPEU
@since 04/09/2015
@version P12
@param oView, objeto, instância de FWFormView
@return Nil, Valor nulo
/*/
Static Function PasteLine(oView)
	Local aArea	:= GetArea()
	Local oGrdModel:= Nil
	Local nOperation:= 0
	Local nLinhaAnt := 0
	Local aSaveLines := {}
	Local nI := 0
	Local nValor := 0	
	Default oView := Nil
	
	if(oView <> Nil)
		nOperation := oView:GetOperation()
		
		if(nOperation == 4)
		
			if(oView:CanInsertLine('GPEA161_SRM') .And. (Len(aTempLine) > 0))			
				oGrdModel := oView:GetModel("GPEA161_SRM")
				nLinhaAnt := InsertLine(oView,.F.) 				
				oGrdModel:GoLine(nLinhaAnt)				
				aEval(aTempLine,{|x|IIF(x[1] != 'RM_SEQ',oGrdModel:LoadValue(x[1],x[2]),)})				
				
				aSize(aTempLine,0)
			Else
				Help(" ",1,"Help",,OemToAnsi(STR0061),1,0)
			endIf
		Else
			Help(" ",1,"Help",,OemToAnsi(STR0060),1,0)
		endIf
	endIf
	
	RestArea(aArea)
Return (Nil)
/*/{Protheus.doc} OnCommit
	Função que executa o commit do formulário.
@author PHILIPE.POMPEU
@since 25/09/2015
@version P12
@param oModel, objeto, (Descrição do parâmetro)
@return lResult, ${return_description}
/*/
Static Function OnCommit(oModel)
	Local aAreas	:= {RGA->(GetArea()),SRM->(GetArea())}
	Local lResult	:= .T.
	Local oFldModel:= Nil
	Local oGrdModel:= Nil
	Local nI := 0
	Local oStruct
	Local aCampos := {}
	Local cChave	:= ''
	Local nOperation	:= 0
	Local cChave, cAuxChv	:= ''
	Local nAux		:= 1
	Local nAux2		:= 0
	Local nPosSeq	:= 0
	Local cFilSRM	:= xFilial('SRM')
	Local cFilRGA	:= xFilial('RGA')
	Local cProces	:= ''
	Local cCalcu	:= ''
	
	Default oModel := FwModelActive()	
	
	oFldModel := oModel:GetModel("GPEA161_RGA")	
	nOperation := oFldModel:GetOperation() 
	
	if(nOperation == 5 .Or. nOperation == 3)
		lResult := FWFormCommit(oModel)
	Else
		oStruct := oFldModel:GetStruct()
		aCampos := oStruct:GetFields()		
		
		Begin Transaction
		
			if(nOperation == 3)
				RecLock('RGA',.T.)
			Else					
				RGA->(dbSetOrder(1))
				cChave := xFilial('RGA')
				cChave += oFldModel:GetValue("RGA_PROCES")
				cChave += oFldModel:GetValue("RGA_CALCUL")		 
				
				if(RGA->(MsSeek(cChave)))				
					RecLock('RGA',.F.)
				Else
					RecLock('RGA',.T.)
				endIf
				
			endIf
			
			aEval(aCampos,{|x|RGA->&(x[3]) := oFldModel:GetValue(x[3])})									
			RGA->(MsUnlock())	
			
			oGrdModel := oModel:GetModel("GPEA161_SRM")
			oStruct := oGrdModel:GetStruct()
			aCampos := oStruct:GetFields()
			
			cProces := oFldModel:GetValue("RGA_PROCES")
			cCalcu	:= oFldModel:GetValue("RGA_CALCUL")
			
			SRM->(dbSetOrder(2))	
			
			nPosSeq:= aScan(oGrdModel:aHeader, { |x,y| x[2] == "RM_SEQ"	} )
			
			cAuxChv:= cFilSRM
			cAuxChv+= cProces
			cAuxChv+= cCalcu
			
			//Cuenta los registros no borrados en el modelo
			For nI := 1 To oGrdModel:Length()
				oGrdModel:GoLine(nI)
				If!(oGrdModel:IsDeleted())
					nAux2++
				EndIf
			Next nI
			
			//Elimina todos los registros de SRM que no seran reutilizados para el guardado
			For nI:= nAux2 + 1 To Val(oGrdModel:aCols[oGrdModel:Length()][nPosSeq])
				cChave:= cAuxChv + strzero((nI),5)
				
				If(SRM->(MsSeek( cChave )))
					RecLock('SRM',.F.)	
					SRM->(DBDelete())
					SRM->(MsUnlock())
				EndIf
			Next nI
			
			//Actualizar en SRM con informacion de modelo
			For nI:= 1 To oGrdModel:Length()
				oGrdModel:GoLine(nI)
				If(!oGrdModel:IsDeleted())	
					oGrdModel:LoadValue("RM_FILIAL"		,cFilSRM)
					oGrdModel:LoadValue("RM_PROCES"		,cProces)
					oGrdModel:LoadValue("RM_CALCULO"	,cCalcu)
					If nAux != Val(oGrdModel:GetValue("RM_SEQ"))
						oGrdModel:LoadValue("RM_SEQ"		, strzero((nAux),5)) //Actualiza secuencia
					EndIf
					cChave:= cAuxChv + oGrdModel:GetValue("RM_SEQ")
					If (SRM->(MsSeek( cChave )))
						RecLock('SRM',.F.)	//Atualiza registro en SRM
					Else
						RecLock('SRM',.T.)  //Crea registro en SRM
					EndIf
						
					aEval(aCampos,{|x|SRM->&(x[3]) := oGrdModel:GetValue(x[3])})																
					SRM->(MsUnlock())
					
					nAux++
				EndIf
			Next nI

		End Transaction	
	EndIf
	
	aEval(aAreas,{|aArea|RestArea(aArea)})	
Return (lResult)
