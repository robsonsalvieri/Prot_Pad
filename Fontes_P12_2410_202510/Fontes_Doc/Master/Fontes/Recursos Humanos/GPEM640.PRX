#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEM1640.CH"

/*


Ŀ
Funo     GPEM640     Autor  Emerson Rosa de Souza  Data  04/08/01 
Ĵ
Descrio  Cadastro de definicoes de Titulos                            
Ĵ
Sintaxe    GPEM640()                                                    
Ĵ
 Uso       Generico                                                     
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.               
Ĵ
Programador  Data      FNC     Motivo da Alteracao                    
Ĵ
Cecilia H Y  15/05/13 MP12RH01Unificacao da Folha de Pagamento        
Alberto M    19/08/14 TPXWQ2  Incluso do campo de Cod. Retencao para 
                               geracao de titulo e integracao com Finan
                               ceiro                                   
Renan Borges 29/11/16 MRH-2160Ajuste na seleo da tabela RGB na defi-
                               nio de titulos.                       
Oswaldo L.  01/02/17  MRH-5505Trativa para que o sistema apenas utiliz
                              os campos de acordo com o pais conectado
Raquel Hager12/01/17  MRH-4110Agrupamento por beneficiario na         
                                ger. de Tit. Penso Ali.              
ٱ 

*/ 
Function GPEM640() 

Private aIndexRC0  := {}		    //Variavel Para Filtro
Private bFiltraBrw := {|| Nil} 	//Variavel para Filtro

Private aRotina    := MenuDef() // ajuste para versao 9.12 - chamada da funcao MenuDef() que contem aRotina

//Ŀ
// Define o cabecalho da tela de atualizacoes                   
//
PRIVATE cCadastro := OemToAnsi(STR0009)  //"Definicao de Titulos"

                                  
//Ŀ
// Inicializa o filtro utilizando a funcao FilBrowse                      
//
cFiltraRh  := CHKRH("GPEM640","RC0","1")
cFiltraRh  := "RC0->RC0_SEQUEN == '01'" + If(Empty(cFiltraRh), "", " .And. " + cFiltraRh)
bFiltraBrw := {|| FilBrowse("RC0",@aIndexRC0,@cFiltraRH) }
Eval(bFiltraBrw)

//Ŀ
// Endereca a funcao de BROWSE                                  
//
dbSelectArea ("RC0")
dbGoTop()
mBrowse(06,01,22,75,"RC0")

//Ŀ
// Deleta o filtro utilizando a funcao FilBrowse                     	   
//
EndFilBrw("RC0",aIndexRC0)

Return Nil

/*/


Ŀ
Funo    gp640Atu   Autor  Emerson Rosa de Souza  Data  04.08.01 
Ĵ
Descrio  Programa de Atualizacao dos tipos de titulos               
Ĵ
Sintaxe    gp640Atu(ExpC1,ExpN1,ExpN2)                                
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       GPEM640                                                    
ٱ

/*/
Function gp640Atu(cAlias,nReg,nOpc)
Local oBtn
Local nCntCpo
Local nOpca      := 0
Local GetList    := {}
Local aAltera    := {}
Local lTemPadrao := .F.
Local nPosTit    := 0
Local nRegAtu
Local cCpoBox
Local cFilAlt
Local cCodAlt
Local cCampo
Local cNaoAltera
Local aMesPgt    := {}
Local aDsVenc    := {}
Local aDiaUtil   := {}
Local aTpRetIR	:= {}
Local lChkBox1
Local lChkBox2

//Ŀ
// Declarao de arrays para dimensionar tela		               
//
Local aAdvSize			:= {}
Local aInfoAdvSize		:= {}
Local aObjSize			:= {}
Local aObjCoords		   := {}

Local aAdv1Size			:= {}
Local aInfo1AdvSize		:= {}
Local aObj1Size			:= {}
Local aObj1Coords		:= {}

Local aAdv2Size	   		:= {}
Local aInfo2AdvSize		:= {}
Local aObj2Size			:= {}
Local aObj2Coords  		:= {}

Local aAdv21Size   		:= {}
Local aInfo21AdvSize	   := {}
Local aObj21Size	  	   := {}
Local aObj21Coords		:= {}   

Local aAdv211Size		:= {}
Local aInfo211AdvSize	:= {}
Local aObj211Size		:= {}
Local aObj211Coords		:= {}

Local aAdv22Size		   := {}
Local aInfo22AdvSize	   := {}
Local aObj22Size		   := {}
Local aObj22Coords		:= {}

//Ŀ
// Define variaveis privates do programa			               
//
Private aVerbRec  := {}   //--Array que contem o Recno() dos registros da aVbCompl
Private aVbCompl  := {}
Private aLbx1     := {}
Private aLbx2     := {}
Private aLbxT     := {}
Private aLbxV1    := {}
Private aLbxV2    := {}
Private aArqSRV   := {}
Private oGet
Private oLbxT,cLbxT
Private aTELA		:= {}
Private aGETS		:= {}
Private oFont1
Private oFont2
Private lVisExc  := ( nOpc == 2 .Or. nOpc == 5 )
Private oChkBox1
Private oChkBox2
Private oDmVenc
Private oMesPgt
Private oDsVenc
Private oDiaUtil
Private bCampo   := {|nCPO| Field(nCPO) }
Private oOk      := LoadBitmap( GetResources(), "LBOK" )
Private oNo      := LoadBitmap( GetResources(), "LBNO" )
Private oDlg
Private oTpRetIR 	 := nil
Private oGerBen	:= nil
Private aGerBen	:= {}
Private nTitSelect	:= 0

Private oRadio1 	
Private nRadio1	 := 1
Private bBlock1	 := {|| Nil } 
Private bClick1	 := {|| Nil }  

//Ŀ
// Preserva Registro Corrente 					                     
//
dbSelectArea( cAlias )
nRegAtu := Recno()
cFilAlt := RC0->RC0_FILIAL
cCodAlt := RC0->RC0_CODTIT

//Ŀ
// Novos campos que nao deverao ser acessados pela Enchoice     
//
cNaoAltera := "RC0_ALIADV/RC0_CPODTV/RC0_FILTDV/RC0_CPODTR"

//Ŀ
// Cancela filtro para tratamento dos registro sequenciais      
//
EndFilBrw("RC0",aIndexRC0)
aIndexRC0 := {}
dbSelectArea("RC0")
dbSetOrder(1)
dbGoTo(nRegAtu)

//Ŀ
// Inicializa variaveis de memoria                              
//
If nOpc == 3 // Inclusao
	FOR nCntCpo := 1 TO FCount()
		dbSelectArea(cAlias)
		cCampo := EVAL(bCampo,nCntCpo)
		lInit := .F.
		If ExistIni(cCampo)
			lInit := .T.
			M->&(cCampo) := InitPad(SX3->X3_RELACAO)
			If ValType(M->&(cCampo)) = "C"
				M->&(cCampo) := PADR(M->&(cCampo),SX3->X3_TAMANHO)
			EndIf
			If M->&(cCampo) == NIL
				lInit := .F.
			EndIf
		EndIf
		If !lInit
			M->&(cCampo) := FieldGet(nCntCpo)
			If ValType(M->&(cCampo)) = "C"
				M->&(cCampo) := SPACE(LEN(M->&(cCampo)))
			ElseIf ValType(M->&(cCampo)) = "N"
				M->&(cCampo) := 0
			ElseIf ValType(M->&(cCampo)) = "D"
				M->&(cCampo) := CtoD("")
			ElseIf ValType(M->&(cCampo)) = "L"
				M->&(cCampo) := .F.
			EndIf
		EndIf
		If cCampo == "RC0_PREFIX"
			M->RC0_PREFIX := "GPE"
		EndIf
		If !(cCampo $ cNaoAltera)
			Aadd(aAltera, cCampo)
		EndIf
	Next nCntCpo
Else // Alteracao/Visualizacao/Exclusao
	FOR nCntCpo := 1 TO FCount()
		cCampo := EVAL(bCampo,nCntCpo)
		M->&(cCampo) := FieldGet(nCntCpo)
		If !(cCampo $ cNaoAltera)
			Aadd(aAltera, cCampo)
		EndIf
	NEXT nCntCpo
EndIf

//Ŀ
// Carrega as variaveis do COMBOBOX                             
//
dbSelectArea( "SX3" )
dbSetOrder(2)
If dbSeek("RC0_MESPGT")
   cCpoBox  := AllTrim(X3CBOX())
   cCpoBox  := '{"'+StrTran(cCpoBox,';','","')+'"}'
   aMesPgt  := &(cCpoBox)
   Aadd( aMesPgt, "  " )
EndIf
If dbSeek("RC0_DSVENC")
   cCpoBox  := AllTrim(X3CBOX())
   cCpoBox  := '{"'+StrTran(cCpoBox,';','","')+'"}'
   aDsVenc  := &(cCpoBox)
   Aadd( aDsVenc, "  " )
EndIf
If dbSeek("RC0_DIAUTI")
   cCpoBox  := AllTrim(X3CBOX())
   cCpoBox  := '{"'+StrTran(cCpoBox,';','","')+'"}'
   aDiaUtil := &(cCpoBox)
   Aadd( aDiaUtil, "  " )
EndIf
If dbSeek("RC0_TPRET")
   cCpoBox  := AllTrim(X3CBOX())
   cCpoBox  := '{"'+StrTran(cCpoBox,';','","')+'"}'
   aTpRetIR := &(cCpoBox)
   Aadd( aTpRetIR, "  " )
EndIf
If dbSeek("RC0_GERBEN")
   cCpoBox  := AllTrim(X3CBOX())
   cCpoBox  := '{"'+StrTran(cCpoBox,';','","')+'"}'
   aGerBen := &(cCpoBox)
   Aadd( aGerBen, "  " )
EndIf


dbSetOrder(1)
lChkBox1 := If(Empty(M->RC0_DMVENC), .F., .T.)
lChkBox2 := If(Empty(M->RC0_DSVENC), .F., .T.)
dbSelectArea(cAlias)
If lChkBox2 
	nRadio1 := 2
EndIf
//Ŀ
// Carrega o array com os tipos de titulos(Padrao) disponiveis  
//
aLbxT := { {.F., OemToAnsi(STR0017), "001" },; //"INSS Folha de Pagamento
		   {.F., OemToAnsi(STR0018), "002" },; //"INSS 13o Salario
		   {.F., OemToAnsi(STR0019), "003" },; //"Imposto de Renda"
		   {.F., OemToAnsi(STR0020), "004" },; //"Pensao Alimenticia"
		   {.F., OemToAnsi(STR0021), "005" },; //"DEFINIDO PELO USUARIO"
		   {.F., OemToAnsi(STR0068), "006" } } //"INSS - Dissdio"

aAdd(aLbxT,{ .F., OemToAnsi(STR0069), "007" } ) //"INSS - RRA"		
aAdd(aLbxT,{ .F., OemToAnsi(STR0070), "008" } ) //"Imposto de Renda - RRA"

// Inclusao Titulo Darf - Desoneracao
aAdd(aLbxT,{ .F., OemToAnsi(STR0071), "009" } ) //"DARF - Desonerao"

If M->RC0_TIPTIT == "1"     // Titulo do Padrao
	nPosTit := Ascan( albxT, { |x| Left(M->RC0_VERBAS,3) == x[3] } )
	If nPosTit > 0
		nTitSelect        := Val( aLbxT[nPosTit,3] )
		aLbxT[nPosTit,1]  := .T.
	EndIf
ElseIf M->RC0_TIPTIT == "2" // Titulo do Usuario
	aLbxT[5,1] := .T.
	nTitSelect := 5
EndIf

//Ŀ
// Carrega os demais registros que se referem ao registro atual 
//
dbSelectArea( "RC0" )
While RC0->RC0_FILIAL + RC0->RC0_CODTIT == xFilial("RC0") + M->RC0_CODTIT .And. !Eof()
	If RC0->RC0_SEQUEN > "01"
        Aadd(aVbCompl, RC0->RC0_VERBAS )
        Aadd(aVerbRec, Recno() )
	EndIf
	dbSkip()
EndDo
dbGoTo(nRegAtu)

//Ŀ
// Carrega o arquivo SRV no array aArqSRV			               
//
fMontArray(@aArqSRV)  

//Ŀ
// Monta as Dimensoes dos Objetos         			               
//
aAdvSize	 := MsAdvSize()
aInfoAdvSize := { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }					 
aAdd( aObjCoords , { 000 , 060 , .T. , .F. } ) 				//1-Enchoice
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )					//2-Vencimento-Titulos
aObjSize	 := MsObjSize( aInfoAdvSize , aObjCoords )    

aAdv1Size	 := aClone(aObjSize[2])
aInfo1AdvSize := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 1 , 5 }					 
aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } ) 				//1-Group Vencimento
aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )				//2-Group Titulos
aObj1Size	 := MsObjSize( aInfo1AdvSize , aObj1Coords,,.T. )

aAdv21Size	 := aClone(aObj1Size[1])
aInfo21AdvSize := { aAdv21Size[2] , aAdv21Size[1] , aAdv21Size[4] , aAdv21Size[3] , 10 , 2 }					 
aAdd( aObj21Coords , { 000 , 010 , .T. , .F. } )				//1-Espaco
aAdd( aObj21Coords , { 000 , 020 , .T. , .F. } )				//2-Radio
aAdd( aObj21Coords , { 000 , 100 , .T. , .F. } ) 				//3-Say e ComboBox 
aAdd( aObj21Coords , { 000 , 000 , .T. , .T. } )				//4-Espaco livre
aObj21Size	 := MsObjSize( aInfo21AdvSize , aObj21Coords)


aAdv211Size	 := aClone(aObj21Size[3])
aInfo211AdvSize := { aAdv211Size[2] , aAdv211Size[1] , aAdv211Size[4] , aAdv211Size[3] , 0 , 0 }					 
aAdd( aObj211Coords , { 030 , 000 , .F. , .T. } )				//1-Col1
aAdd( aObj211Coords , { 005 , 000 , .F. , .T. } ) 				//2-Espaco separacao
aAdd( aObj211Coords , { 000 , 000 , .T. , .T. } )				//3-Col3
aObj211Size	 := MsObjSize( aInfo211AdvSize , aObj211Coords,,.T.)


aAdv22Size	 := aClone(aObj1Size[2])
aInfo22AdvSize := { aAdv22Size[2] , aAdv22Size[1] , aAdv22Size[4] , aAdv22Size[3] , 10 , 10 }					 
aAdd( aObj22Coords , { 000 , 000 , .T. , .T. , .T. } ) 		//2-ListBox
aAdd( aObj22Coords , { 000 , 015 , .T. , .F. } )				//3-Button-Definir Titulo
aObj22Size	 := MsObjSize( aInfo22AdvSize , aObj22Coords)

//Ŀ
// Define as fontes que serao usados na elaboracao das telas    
//
DEFINE FONT oFont1  NAME "Arial" SIZE 0,-13 BOLD
DEFINE FONT oFont2  NAME "Arial" SIZE 0,-13

//Ŀ
// Monta a tela de dialogo					                         
//

DEFINE MSDIALOG oDlg TITLE cCadastro FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] of oMainWnd PIXEL
 
	oEnchoice	:= MsmGet():New( 	cAlias,;   			// 1  Tabela a consultar
				nReg,;				// 2  Nro do Recno do Registro
				nOpc,;				// 3  Tipo de operacao
				Nil,;				// 4
				Nil,;				// 5
				Nil,; 				// 6
				,;		// 7  Vetor com nome dos campos que serao exibidos
				aObjSize[1],; 		// 8  Posicao da Enchoice na tela
				aAltera,;		// 9  Campos que permitem alteracao
				Nil,;				// 10
				Nil,;				// 11
				Nil,;				// 12 Funcao para validacao da Enchoice
				oDlg,;  				// 13  Objeto
				,;
				.F.						;
			)

	//Ŀ
	// Edicao dos campos de vencimento do titulo                
	//
	@ aObj1Size[1,1],aObj1Size[1,2] GROUP oGroup TO aObj1Size[1,3],aObj1Size[1,4] PROMPT OemtoAnsi(STR0043) OF oDlg; //"Vencimento do titulo"
					       PIXEL COLOR CLR_BLUE
	oGroup:SetFont(oFont1)

	bBlock1	:= { |x| If(ValType(x)=='U', nRadio1 , nRadio1 := x ) }
	bClick1	:= { || fRadio(nRadio1,@M->RC0_DMVENC,@M->RC0_DSVENC,@M->RC0_MESPGT,@M->RC0_DIAUTI) }	
	oRadio1	:= TRadMenu():New( aObj21Size[2,1],aObj21Size[2,2], {oEmToAnsi(STR0046), oEmToAnsi(STR0045)},bBlock1,oDlg,,bClick1,,,,,,80,38 )	//"Dia do Mes"###"Dia da Semana"
	nRadio1	:= oRadio1:nOption

	// --- Dia do Mes ---
	@  aObj211Size[1,1],aObj211Size[1,2] MSGET oDmVenc VAR M->RC0_DMVENC PICT "99" Valid (M->RC0_DMVENC < "32") SIZE 15,10 OF oDlg PIXEL
	@  aObj211Size[3,1],aObj211Size[3,2]+55 MSCOMBOBOX oMesPgt VAR M->RC0_MESPGT ITEMS aMesPgt SIZE 70,12 OF oDlg PIXEL
    
	//"Vencto Dia Nao Util"
	@ aObj211Size[1,1]+15,aObj211Size[1,2] SAY OemtoAnsi(STR0067) SIZE 80,15 OF oDlg PIXEL
	@ aObj211Size[3,1]+15,aObj211Size[3,2]+55 MSCOMBOBOX oDiaUtil VAR M->RC0_DIAUTI ITEMS aDiaUtil SIZE 70,10 OF oDlg PIXEL

	
	// --- Dia da Semana ---
	@ aObj211Size[1,1]+30,aObj211Size[1,2] SAY OemtoAnsi(STR0045) SIZE 60,10 OF oDlg PIXEL
	@ aObj211Size[3,1]+30,aObj211Size[3,2]+55 MSCOMBOBOX oDsVenc VAR M->RC0_DSVENC ITEMS aDsVenc SIZE 70,10 OF oDlg PIXEL

	//Ŀ
	// Monta LisBox Para Selecao do Titulo		                 
	//
	@ aObj1Size[2,1],aObj1Size[2,2] GROUP oGroup TO aObj1Size[2,3],aObj1Size[2,4] PROMPT OemtoAnsi(STR0022) OF oDlg; //"Titulos disponiveis para selecao"
					       PIXEL COLOR CLR_BLUE
	oGroup:SetFont(oFont1)
	@ aObj22Size[1,1],aObj22Size[1,2] LISTBOX oLbxT VAR cLbxT FIELDS HEADER  "", OemtoAnsi(STR0023); //"Selecao do Titulo"
	          SIZE (aObjSize[2,4] - (aObjSize[2,4]/100*51))-20,((aObjSize[2,3]-65) - (aObjSize[2,3]/100*46))ON DBLCLICK (aLbxT:=fSelLbT(oLbxT:nAt,aLbxT,@nTitSelect),oLbxT:Refresh(),;
	          If (aLbxT[3,1],oTpRetIR:Enable(), oTpRetIR:Disable()),;
	          If (aLbxT[5,1],oBtn:Enable(),oBtn:Disable()) ) OF oDlg PIXEL
	oLbxT:SetArray(aLbxT)                 
	oLbxT:LHSCROLL := .F. 
	oLbxT:LVSCROLL := .F.
	oLbxT:nFreeze  := 1
	oLbxT:bLine    := { || {If(aLbxT[oLbxT:nAt,1],oOk,oNo),aLbxT[oLbxT:nAt,2]}}
   	oLbxT:nAt      := Max(nTitSelect,1)
	oLbxT:nRowPos  := 5
	
		@ (aObjSize[2,3]-30),(aObjSize[2,4]/100*55) SAY OemtoAnsi(STR0077) SIZE 85,10 OF oDlg PIXEL FONT oFont2 COLOR CLR_BLUE //"Tp Ret. Imp. Renda:"
		@ (aObjSize[2,3]-30),(aObjSize[2,4]/100*70) MSCOMBOBOX oTpRetIR VAR M->RC0_TPRET ITEMS aTpRetIR SIZE 55,10 OF oDlg ON CHANGE fVldTpRet(1)  PIXEL
		If !(aLbxT[3,1])
			oTpRetIR:Disable()
		EndIf
		
	If !Empty(aGerBen)
		@ (aObjSize[2,3]-50),(aObjSize[2,4]/100*55) SAY OemtoAnsi(STR0079) SIZE 85,10 OF oDlg PIXEL FONT oFont2 COLOR CLR_BLUE //"Gerar p/ Beneficirio"
		@ (aObjSize[2,3]-50),(aObjSize[2,4]/100*70) MSCOMBOBOX oGerBen VAR M->RC0_GERBEN ITEMS aGerBen SIZE 55,10 OF oDlg /*ON CHANGE fVldGerBen(1)*/  PIXEL
		If M->RC0_AGRUPA == "4" .And. nTitSelect == 4 
			oGerBen:enable()
		Else
			oGerBen:disable()
		EndIf
	EndIf

	@ aObjSize[2,3]-55,(aObjSize[2,4]/100*88) BUTTON oBtn PROMPT OemToAnsi( STR0024 ) SIZE 40,15; //"Definir Titulo"
		           ACTION ( If(aLbxT[5,1], fSelVerb(),) ) Of oDlg PIXEL  

		
fRadio(nRadio1,@M->RC0_DMVENC,@M->RC0_DSVENC,@M->RC0_MESPGT,@M->RC0_DIAUTI)	

ACTIVATE MSDIALOG oDlg ON INIT ( EnchoiceBar(oDlg,{||If(Obrigatorio(oEnchoice:aGets,oEnchoice:aTela) .And. fObrigVenc() .and. fVldForn(),(nOpca:=1 ,oDlg:End()),(nOpca:=2,.F.))},{||nOpca:=2,oDlg:End()} ),;
							        If(nTitSelect==5,oBtn:Enable(),oBtn:Disable()) ) CENTERED

//Ŀ
// nOpc:  2-Visualizar, 3-Incluir, 4-Alterar, 5-Excluir         
//
If nOpcA == 1 .And. nOpc > 2
	dbSelectArea( "RC0" )
	If nOpc == 3 .Or. nOpc == 4
		Begin Transaction
			gp640Grava( nOpc )
		End Transaction
	ElseIf nOpc == 5
		Begin Transaction
			While RC0->RC0_FILIAL+RC0->RC0_CODTIT == cFilAlt+cCodAlt
				RecLock(cAlias,.F.,.T.)
				dbDelete()
				MsUnlock()
				dbSkip()
			EndDo
		End Transaction
	EndIf
Endif

//Ŀ
// Restaura o filtro para nao apresentar sequenciais            
//
bFiltraBrw := {|| FilBrowse("RC0",@aIndexRC0,@cFiltraRH) }
Eval(bFiltraBrw)

//Ŀ
// Restaura a integridade da janela                             
//
dbSelectArea("RC0")
dbGoTo(nRegAtu)
nOpca := 0
Return nOpca

/*

Ŀ
Funo    gp640Grava Autor  Emerson Rosa de Souza  Data  04.08.01 
Ĵ
Descrio  Grava os dados no arquivo de titulos						     
Ĵ
 Uso       gp640Grava(nTipOp)                                         
ٱ

/*/
Function gp640Grava(nTipOp)
Local nZ       :=0
Local nSeq     := 0
Local nPosVerba := 0
Local cCpoGrav  := 0
Local nCntCpo   := 0
Local lRet      := .T.
Local xConteudo := ""

dbSelectArea( "RC0" )               

If nTipOp == 3 // Inclusao
	RecLock("RC0",.T.,.T.)
Else
	RecLock("RC0",.F.,.T.)
EndIf

For nCntCpo  := 1 TO FCount()
	cCpoGrav := EVAL(bCampo,nCntCpo)
	If cCpoGrav 	== "RC0_FILIAL"
		RC0->RC0_FILIAL  := xFilial("RC0")
	ElseIf cCpoGrav == "RC0_SEQUEN"
		RC0->RC0_SEQUEN  := "01"
	//removido pois nao ter mais uso: 
	//ElseIf cCpoGrav == "RC0_ORDEMB"
	//	RC0->RC0_ORDEMB  := Left(M->RC0_ORDEMB,1) //Grava apenas o numero da Ordem
	Else
		xConteudo := M->&(cCpoGrav) 
		FieldPut(nCntCpo,xConteudo)
	EndIf
Next nCntCpo

If !aLbxT[5,1] // Titulo Padrao
	nPosVerba := Ascan(aLbxT, { |x| x[1] == .T. })
	RC0->RC0_VERBAS  := If(nPosVerba > 0, aLbxT[nPosVerba,3], StrZero(nPosVerba,3) )
	RC0->RC0_TIPTIT  := If(Val(RC0->RC0_VERBAS) > 0, "1", "0")
	RC0->RC0_FILTRV  := ""
	RC0->RC0_FILTRF  := ""
	RC0->RC0_FILTRD  := ""
	RC0->RC0_ALIAS   := ""
	RC0->RC0_ALIADV := ""
	RC0->RC0_CPODTV := ""
	RC0->RC0_FILTDV := ""
	RC0->RC0_CPODTR := ""
	Afill( aVbCompl, "" )
Else           // Titulo do Usuario
	RC0->RC0_VERBAS  := M->RC0_VERBAS
	RC0->RC0_TIPTIT  := "2"
EndIf
MsUnLock()

//Ŀ
// Grava as verbas complementares em novos registros            
//
If Len(aVbCompl) > 0
	nSeq   := 2
	For nZ := 1 To Len(aVbCompl)
   		If Len(aVerbRec) >= nZ
	    	dbGoTo(aVerbRec[nZ])
	        RecLock("RC0",.F.,.T.)
	        If Empty(aVbCompl[nZ])
	        	dbDelete()
	        	MsUnLock()
    	    	Loop
        	EndIf
		Else
	       RecLock("RC0",.T.,.T.)
  	  	    RC0->RC0_FILIAL  := xFilial("RC0")
        	RC0->RC0_CODTIT  := M->RC0_CODTIT
    	EndIf
      	RC0->RC0_SEQUEN := StrZero(nSeq,2)
		RC0->RC0_DESCRI := STR0041 // "SEQUENCIAL"
		RC0->RC0_AGRUPA := ""
		RC0->RC0_FILTRV := ""
		RC0->RC0_ALIAS  := ""
		RC0->RC0_VERBAS := aVbCompl[nZ]
		RC0->RC0_FORNEC := ""
		RC0->RC0_NATURE := ""
		RC0->RC0_ALIADV := ""
		RC0->RC0_CPODTV := ""
		RC0->RC0_FILTDV := ""
		RC0->RC0_CPODTR := ""
		RC0->RC0_LOJA	:= ""
      	MsUnLock()
		nSeq ++
	Next nZ
EndIf

Return Nil

/*/


Ŀ
Funo    fSelVerb   Autor  Emerson Rosa de Souza  Data  05.12/00 
Ĵ
Descrio  Seleciona as verbas para geracao do titulo                 
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Static Function fSelVerb()
Local aArea		:=GetArea()
Local cAlias    := ALIAS()
Local cAliasVerb:= M->RC0_ALIAS
Local cDescAVerb:= ""
Local aCpoDtVerb:= {}
Local aButtons	:= {}
Local bSet15	:= { || NIL } 
Local bSet24	:= { || NIL }
Local aCores    := { LoadBitmap( GetResources(), "BR_VERDE" ),;     // PROVENTO
				     LoadBitmap( GetResources(), "BR_VERMELHO" ),;  // DESCONTO
 				     LoadBitmap( GetResources(), "BR_CINZA" ) }     // BASE 

//Ŀ
// Declarao de arrays para dimensionar tela		               
//
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

Local aAdv1Size		:= {}
Local aInfo1AdvSize	:= {}
Local aObj1Size		:= {}
Local aObj1Coords	:= {}

Local aAdv2Size		:= {}
Local aInfo2AdvSize	:= {}
Local aObj2Size		:= {}
Local aObj2Coords	:= {}

Local aAdv22Size	:= {}
Local aInfo22AdvSize:= {}
Local aObj22Size	:= {}
Local aObj22Coords	:= {}

Local aAdv3Size		:= {}
Local aInfo3AdvSize	:= {}
Local aObj3Size		:= {}
Local aObj3Coords	:= {}

Local aAdv4Size		:= {}
Local aInfo4AdvSize	:= {}
Local aObj4Size		:= {}
Local aObj4Coords	:= {}

Local aGDCoord		:= {}

Private oLbx1
Private oLbx2
Private cLbx1
Private cLbx2
Private oCpoDtVerb
Private nLbxAtiva
Private nNulo := 3

Private oDlg1
PRIVATE oBtn1		:= LoadBitmap( GetResources(),"NEXT")
PRIVATE oBtn2		:= LoadBitmap( GetResources(),"PREV")
PRIVATE oBtn3		:= LoadBitmap( GetResources(),"EDITABLE")
PRIVATE oBtn4		:= LoadBitmap( GetResources(),"FILTRO")
PRIVATE oBtn5		:= LoadBitmap( GetResources(),"FILTRO")  				       

//Ŀ
// Busca a descricao do arquivo gravado no campo RC0_ALIAS      
//
fBusNomSx2(cAliasVerb,@cDescAVerb)

//Ŀ
// Carrega o array com os campos data do alias selecionado  	   
//
fCarrDat(M->RC0_ALIAS, @M->RC0_FILTRD, @aCpoDtVerb,,1)

//Ŀ
// Monta os ListBox aLbx1 e aLbx2				                     
//
gp640MontaLbx(@aLbx1,@aLbx2)

//Ŀ
// Monta as Dimensoes dos Objetos         			               
//
aAdvSize	  := MsAdvSize(,.T.,490)
aInfoAdvSize := { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }					 
aAdd( aObjCoords , { 000 , 018 , .T. , .F. } )   			//1-Cabecalho Conceitos
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )				//2-ListBox Conceitos
aAdd( aObjCoords , { 000 , 060 , .T. , .F. } )  			//3-Informacoes para busca
aAdd( aObjCoords , { 000 , 025 , .T. , .F. } )				//4-Filtro
aObjSize	 := MsObjSize( aInfoAdvSize , aObjCoords )

//Divisao Linha 1-Cabecalho Conceitos em 3 colunas
aAdv1Size	   := aClone(aObjSize[1])
aInfo1AdvSize := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 0 , 0 }					 
aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )			//1-Cabecalho esquerdo
aAdd( aObj1Coords , { 015 , 000 , .F. , .T. } )			//2-Espaco
aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )			//3-Cabecalho direito
aObj1Size	 := MsObjSize( aInfo1AdvSize , aObj1Coords,, .T. )

//Divisao Linha 2-ListBox Conceitos em 3 colunas 
aAdv2Size	   := aClone(aObjSize[2])
aInfo2AdvSize := { aAdv2Size[2] , aAdv2Size[1] , aAdv2Size[4] , aAdv2Size[3] , 1 , 1 }					 
aAdd( aObj2Coords , { 000 , 000 , .T. , .T. , .T. } )		//1-Listbox esquerdo
aAdd( aObj2Coords , { 015 , 000 , .F. , .T. } ) 			//2-Coluna para botoes centrais
aAdd( aObj2Coords , { 000 , 000 , .T. , .T. , .T. } )		//3-Listbox esquerdo
aObj2Size	 := MsObjSize( aInfo2AdvSize , aObj2Coords,, .T. )  

//Divisao Linha 2 - Coluna 2 -Coluna para botoes centrais - em linhas
aAdv22Size	    := aClone(aObj2Size[2])
aInfo22AdvSize := { aAdv22Size[2] , aAdv22Size[1] , aAdv22Size[4] , aAdv22Size[3] , 1 , 1 }					 
aAdd( aObj22Coords , { 000 , 000 , .T. , .T. } )		//1-
aAdd( aObj22Coords , { 000 , 000 , .T. , .T. } )		//2-Botao 1
aAdd( aObj22Coords , { 000 , 000 , .T. , .T. } )		//3-Botao 2
aAdd( aObj22Coords , { 000 , 000 , .T. , .T. } )		//4-
aObj22Size	 := MsObjSize( aInfo22AdvSize , aObj22Coords )

//Divisao Linha 3- Filtro em 3 linhas iguais
aAdv3Size	   := aClone(aObjSize[3])
aInfo3AdvSize := { aAdv3Size[2] , aAdv3Size[1] , aAdv3Size[4] , aAdv3Size[3] , 5 , 10}				 
aAdd( aObj3Coords , { 000 , 000 , .T. , .T. } )		
aAdd( aObj3Coords , { 000 , 000 , .T. , .T. } ) 		
aAdd( aObj3Coords , { 000 , 000 , .T. , .T. } )		
aObj3Size	 := MsObjSize( aInfo3AdvSize , aObj3Coords )  

//Divisao Linha 4- Filtro em 3 colunas 
aAdv4Size	   := aClone(aObjSize[4])
aInfo4AdvSize := { aAdv4Size[2] , aAdv4Size[1] , aAdv4Size[4] , aAdv4Size[3] , 5 , 10 }					 
aAdd( aObj4Coords , { 020 , 000 , .F. , .T. } )		//1- Say Filtro
aAdd( aObj4Coords , { 000 , 000 , .T. , .T. } ) 		//2-
aAdd( aObj4Coords , { 000 , 000 , .T. , .T. } ) 		//2-
aAdd( aObj4Coords , { 000 , 000 , .T. , .T. } ) 		//2-
aAdd( aObj4Coords , { 015 , 000 , .F. , .T. } )		//3-Icone Filtro
aObj4Size	 := MsObjSize( aInfo4AdvSize , aObj4Coords,, .T. )  

aGdCoord	 := { (aObjSize[1,1]+14), (aObjSize[1,2]+5), (((aObjSize[1,3])/100)*70), (((aObjSize[1,4])/100)*75) }
       
DEFINE MSDIALOG oDlg1 FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi(STR0011) PIXEL //##"Definicao das regras para geracao do titulo"
	
	@ aObj1Size[1,1],aObj1Size[1,2] 		GROUP oGroup TO aObj1Size[1,3],aObj1Size[1,4] OF oDlg1 PIXEL
	@ aObj1Size[1,1]+5,aObj1Size[1,2]+5 	SAY OemToAnsi(STR0012) SIZE 120,10 PIXEL FONT oFont1 COLOR CLR_BLUE //##"Verbas Disponiveis Para Selecao"

    @ aObj1Size[3,1],aObj1Size[3,2] 		GROUP oGroup TO aObj1Size[3,3],aObj1Size[3,4] OF oDlg1 PIXEL
	@ aObj1Size[3,1]+5,aObj1Size[3,2]+5 	SAY OemToAnsi(STR0013) SIZE 120,10 PIXEL FONT oFont1 COLOR CLR_BLUE //##"Verbas Selecionadas Para Geracao"
	
	//Ŀ
	// Monta ListBox aLbx1 e aLbx2 para selecao por verbas			   
	//
	@ aObj2Size[1,1],aObj2Size[1,2] LISTBOX oLbx1 VAR cLbx1 FIELDS HEADER  Space(2), OemtoAnsi(STR0014),;  //##"Verba"
			    											  OemtoAnsi(STR0015);   //##"Descricao"
	            COLSIZES GetTextWidth(0,"B"),;
			             GetTextWidth(0,"BBB"),;
	                     GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB");
	          SIZE aObj2Size[1,3],aObj2Size[1,4] OF oDlg1 PIXEL  
	oLbx1:SetArray(aLbx1)
	oLbx1:nFreeze := 1
	oLbx1:bLine   := { ||  { aCores[ aLbx1[oLbx1:nAt,1] ],aLbx1[oLbx1:nAt,2],aLbx1[oLbx1:nAt,3] }}
	
	@ aObj2Size[3,1],aObj2Size[3,2] LISTBOX oLbx2 VAR cLbx2 FIELDS HEADER " +", " --", OemtoAnsi(STR0014),; //##"Verba"
												                 OemtoAnsi(STR0015);  //##"Descricao"
	            COLSIZES GetTextWidth(0,"BBB"),;
			             GetTextWidth(0,"BBB"),;
	   		             GetTextWidth(0,"BBB"),;
	                     GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB");
	          SIZE aObj2Size[3,3],aObj2Size[3,4] ON DBLCLICK aLbx2:=fSelLb2(oLbx2:nAt,aLbx2),oLbx2:Refresh() OF oDlg1 PIXEL
	oLbx2:SetArray(aLbx2)
	oLbx2:bLine    := { || { aCores[ aLbx2[oLbx2:nAt,4] ],aCores[ aLbx2[oLbx2:nAt,5] ],aLbx2[oLbx2:nAt,2],aLbx2[oLbx2:nAt,3]}}
	
	@ aObj22Size[2,1],aObj22Size[2,2] BITMAP oBtn1 RESOURCE "NEXT"   NO BORDER SIZE 25,25 OF oDlg1 ;
					ON CLICK (fMoveLbx(@aLbx1,@aLbx2,@oLbx1,@oLbx2,2,4)) FONT oFont2 PIXEL WHEN {||oDlg1:ldisponivel}	
	oBtn1:CTOOLTIP := STR0016 //##"Mover a verba selecionada"  
	
	@ aObj22Size[3,1],aObj22Size[3,2] BITMAP oBtn2 RESOURCE "PREV"   NO BORDER SIZE 25,25 OF oDlg1 ;
					ON CLICK fMoveLbx(@aLbx2,@aLbx1,@oLbx2,@oLbx1,2,4) FONT oFont2 PIXEL WHEN {||oDlg1:ldisponivel}	
	oBtn2:CTOOLTIP := STR0016 //##"Mover a verba selecionada"
	nOpca := 0

	@ aObjSize[3,1],aObjSize[3,2] GROUP oGroup TO aObjSize[3,3],aObjSize[3,4] PROMPT OemtoAnsi(STR0025) OF oDlg1; //"Informacoes para busca das verbas selecionadas"
						    PIXEL COLOR CLR_BLUE
	oGroup:SetFont(oFont1)
	
	@ aObj3Size[1,1],aObj4Size[1,2] SAY OemtoAnsi(STR0026)  SIZE 40,10 PIXEL OF oDlg1   //"Arquivo"
	@ aObj3Size[1,1],aObj4Size[2,2] MSGET oAliasVerb VAR cDescAVerb WHEN .F. SIZE 250,10 OF oDlg1 PIXEL//100,10
	@ aObj3Size[1,1],aObj4Size[5,2] BITMAP oBtn3 RESOURCE "EDITABLE"   NO BORDER SIZE 25,25 ;
						OF oDlg1	;
						ON CLICK fAtuCpos(@cAliasVerb,@cDescAVerb,@aCpoDtVerb,@oCpoDtVerb,@M->RC0_FILTRD,.T.)  FONT oFont2 PIXEL WHEN {||oDlg1:ldisponivel}	
						oBtn3:MovetoTop()

	@ aObj3Size[2,1],aObj4Size[1,2] SAY OemtoAnsi(STR0027)  SIZE 80,10 PIXEL OF oDlg1  //"Campo Data Para o Filtro"
	@ aObj3Size[2,1],aObj4Size[3,2] MSCOMBOBOX oCpoDtVerb VAR M->RC0_FILTRD ITEMS aCpoDtVerb SIZE 165,10 OF oDlg1 PIXEL
	
	@ aObj3Size[3,1],aObj4Size[1,2] SAY OemtoAnsi(STR0028) SIZE 40,08 PIXEL OF oDlg1  //"Filtro"
	@ aObj3Size[3,1],aObj4Size[2,2] MSGET oFiltrV VAR M->RC0_FILTRV WHEN .F. SIZE 250,10 OF oDlg1 PIXEL//200,10
	@ aObj3Size[3,1],aObj4Size[5,2] BITMAP oBtn4 RESOURCE "FILTRO" NO BORDER SIZE 25,25 ;
							OF oDlg1 ;	
					       	ON CLICK ( If(Empty(cAliasVerb), MsgStop(OemtoAnsi(STR0029)),; //"Arquivo de filtro nao informado"
						    fValFiltro(cAliasVerb,@M->RC0_FILTRV,oDlg1)) ) FONT oFont2 PIXEL WHEN {||oDlg1:ldisponivel}	
							oBtn4:MovetoTop() 

	@ aObjSize[4,1],aObjSize[4,2] GROUP oGroup TO aObjSize[4,3],aObjSize[4,4] PROMPT OemtoAnsi(STR0036) OF oDlg1; //"Filtro para o cadastro de funcionarios [SRA]"
						    PIXEL COLOR CLR_BLUE
	oGroup:SetFont(oFont1)  
	@ aObj4Size[1,1],aObj4Size[1,2] SAY OemtoAnsi(STR0028) SIZE 40,08 PIXEL OF oDlg1  //"Filtro"
	@ aObj4Size[2,1],aObj4Size[2,2] MSGET oFiltrF VAR M->RC0_FILTRF WHEN .F. SIZE 250,10 OF oDlg1 PIXEL
	@ aObj4Size[3,1],aObj4Size[5,2] BITMAP oBtn5 RESOURCE "FILTRO" NO BORDER SIZE 25,25 ;
							OF oDlg1  ;
							On CLICK ( If(Empty(cAliasVerb), MsgStop(OemtoAnsi(STR0029)),; //"Arquivo de filtro nao informado"
						    fValFiltro("SRA",@M->RC0_FILTRF,oDlg1)) ) FONT oFont2 PIXEL WHEN {||oDlg1:ldisponivel}	
							oBtn5:MovetoTop() 

	bSet15   := {||nopca:=1,If(fInfArq(),oDlg1:End(),"")}
	bSet24   := {||oDlg1:End(),DeleteObject(oBtn1),DeleteObject(oBtn2),DeleteObject(oBtn3), DeleteObject(oBtn4),DeleteObject(oBtn5)}
	aButtons := { {"PMSRELA",{||fRelaArq(cAliasVerb)},OeMToAnsi(STR0047)}} //"Informacoes para busca data de vencimento"

ACTIVATE MSDIALOG oDlg1 ON INIT ( EnchoiceBar(oDlg1, bSet15, bSet24, NIL , aButtons ) ) CENTERED

If nOpca == 1
	fLbxGrav()
EndIf

dbSelectArea(cAlias)   
RestArea(aArea)

DeleteObject(oBtn1)
DeleteObject(oBtn2)
DeleteObject(oBtn3)
DeleteObject(oBtn4)
DeleteObject(oBtn5)

Return .T.

/*

Ŀ
Funo    gp640Monta Autor  Emerson Rosa de Souza  Data  02.01.01 
Ĵ
Descrio Funcao que efetua a montagem dos listbox                    
Ĵ
Parametros 							                                        
Ĵ
 Uso                                                                  
ٱ

*/
Static Function gp640MontaLbx(aLbx1,aLbx2)
Local nCntVerba
Local nMaxVerba
Local cCodVerba
Local nCnt2
Local nCnt3
Local nCnt4 
Local nVbSrv
Local cTipVerba
Local aTotVerba := {}

//Ŀ
// Limpa arrays para uma nova montagem.                         
//
aLbx1 := {}
aLbx2 := {}

//Ŀ
// Inclui verbas no array que sera processado (aTotVerba)       
//
Aadd(aTotVerba, M->RC0_VERBAS )

//Ŀ
// Verifica se existem outras verbas no array aVbCompl          
//
If Len(aVbCompl) > 0
	For nCnt2 := 1 To Len(aVbCompl)
		Aadd(aTotVerba, aVbCompl[nCnt2])
	Next nCnt2
EndIf

//Ŀ
// Monta o array aLbx2 a partir das verbas do aVbCompl          
//
For nCnt2 := 1 To Len(aTotVerba)
    nMaxVerba := Len(Trim(aTotVerba[nCnt2]))
    For nCntVerba := 1 To nMaxVerba Step 4
		cCodVerba := Substr(aTotVerba[nCnt2], nCntVerba, 3)
		cTipVerba := Substr(aTotVerba[nCnt2], nCntVerba+3,1)
		nVbSrv    := Ascan( aArqSRV, { |x| x[2] == cCodVerba } )
		If nVbSrv > 0
			//Ŀ
			// Se verba nao definida "P*D" busca tipo original da verba     
			//
			If !(cTipVerba $ "P*D")
				cTipVerba := If(aArqSRV[nVbSrv,1]==2, "D", "P")
			EndIf
			Aadd(aLbx2, { aArqSRV[nVbSrv,1], aArqSRV[nVbSrv,2], aArqSRV[nVbSrv,3],;
				          If(cTipVerba=="P",1,nNulo), If(cTipVerba=="D",2,nNulo) })
	    EndIf
	Next nCntVerba
Next nCnt2

If Len(aLbx2) == 0
	Aadd(aLbx2, { nNulo, Space(3), Space(20), nNulo, nNulo })
EndIf

//Ŀ
// Montagem de aLbx1                                            
//
For nCnt3 := 1 To Len(aArqSRV)
	If Ascan( aLbx2, { |x| x[2] == aArqSRV[nCnt3,2] } ) == 0
		Aadd(aLbx1, { aArqSRV[nCnt3,1], aArqSRV[nCnt3,2], aArqSRV[nCnt3,3],;
		              If(aArqSRV[nCnt3,1]#2, 1, nNulo), If(aArqSRV[nCnt3,1]==2, 2, nNulo) })
	EndIf
Next nCnt3

If Len(aLbx1) == 0
	Aadd(aLbx1, { nNulo, Space(3), Space(20), nNulo, nNulo })
EndIf

Return Nil
           
/*

Ŀ
Funo    A640LbGrav Autor  Emerson Rosa de Souza  Data  26.12.00 
Ĵ
Descrio Funcao para gravacao do campo de verbas a partir da listbox 
Ĵ
Parametros                                                            
Ĵ
 Uso      fLbxGrav	                                                  
ٱ

*/
Static Function fLbxGrav()
Local cVerbas   := ""
Local nNroVerba := 0
Local nPosVb    := 0
Local nCnt2
Local lPriVez   := .T.

//Ŀ
// Limpa as verbas que estao sendo editadas para nova montagem  
//
If Len(aVbCompl) > 0
	For nCnt2 := 1 To Len(aVbCompl)
		aVbCompl[nCnt2] := ""
	Next nCnt2
EndIf

M->RC0_VERBAS := If(Len(aLbx2) == 0, "", M->RC0_VERBAS)
For nCnt2 := 1 To Len(aLbx2)
	cVerbas   += If(Empty(aLbx2[nCnt2,2]), "", aLbx2[nCnt2,2] + If(aLbx2[nCnt2,4]==1, "P", "D"))
    nNroVerba ++
	If nCnt2 == Len(aLbx2) .Or. nNroVerba == 30 // Maximo de trinta verbas por registro do arquivo
		If lPriVez
			M->RC0_VERBAS := cVerbas
			lPriVez      := .F.
		Else
			nPosVb ++
   			If nPosVb > Len(aVbCompl)
				Aadd(aVbCompl, cVerbas)
			Else	
				aVbCompl[nPosVb] := cVerbas
			EndIf
		EndIf
		cVerbas   := ""
		nNroVerba := 0
    EndIf
Next nCnt2

Return .T.

/*

Ŀ
Funo    aArqSRV()  Autor  Emerson Rosa de Souza  Data  28.02.01 
Ĵ
Descrio Carrega o arquivo SRV no array aArqSRV.                     
Ĵ
Parametros                                                            
Ĵ
 Uso      Generico                                                    
ٱ

*/
Static Function fMontArray(aArqSRV,aAlias)
Local cAlias  := ALIAS()
Local cFilAtu := xFilial( "SRV" )

dbSelectArea("SRV")
dbSetOrder(1)
dbSeek( cFilAtu )
//Ŀ
// Incluir todas as verbas do SRV								         
//
While SRV->RV_FILIAL == cFilAtu .And. !Eof()
	Aadd(aArqSRV, { If(SRV->RV_TIPOCOD=="2", 2, 1), SRV->RV_COD, SRV->RV_DESC } )
	dbSkip()
EndDo
dbSelectArea( cAlias )

Return

/*

Ŀ
Funo     fMoveLbx  Autor  Emerson Rosa de Souza  Data  12.03.01 
Ĵ
Descrio Move verbas de um Listbox para o outro                      
Ĵ
Parametros nLBx        - Indica o LisBox origem                       
Ĵ
 Uso      Generico                                                    
ٱ

*/
Function fMoveLbx(aLbxOrig,aLbxDest,oLbxOrig,oLbxDest,nNroCpoInd,nLiLbx)
Local nPosCod
Local cCpoChave

//Ŀ
// Retornar se opcao de visualizacao/exclusao ou ListBox vazio  
//
If lVisExc .Or. Len(aLbxOrig) == 0 .Or. (Len(aLbxOrig) == 1 .And. Empty(aLbxOrig[1,nNroCpoInd]))
	Return .T.
EndIf

//Ŀ
// Campo chave para posicionar o elemento selecionado           
//
cCpoChave := aLbxOrig[oLbxOrig:nAt,nNroCpoInd]

//Ŀ
// Caso a ListBox destino esteja vazia, exclui o elemento vazio 
//
If Len(aLbxDest) == 1 .And. Empty(aLbxDest[1,nNroCpoInd])
	Adel(aLbxDest,1)
	ASize(aLbxDest,Len(aLbxDest)-1)
EndIf

//Ŀ
// Inclui na ListBox destino e exclui da origem                 
//
Aadd(aLbxDest, aLbxOrig[oLbxOrig:nAt])
Adel(aLbxOrig,oLbxOrig:nAt)
ASize(aLbxOrig,Len(aLbxOrig)-1)

aSort(aLbxOrig,,,{|x,y| x[nNroCpoInd] < y[nNroCpoInd] })
aSort(aLbxDest,,,{|x,y| x[nNroCpoInd] < y[nNroCpoInd] })

//Ŀ
// Posiciona o ListBox destino na verba movida a partir da orig.
//
nPosCod := Ascan(aLbxDest, { |x| x[nNroCpoInd] == cCpoChave })
If nPosCod > 0
	oLbxDest:nAt     := nPosCod
	oLbxDest:nRowPos := nLiLbx  //Ultima linha da ListBox apresentada em tela
	oLbxOrig:nAt     := Min(oLbxOrig:nAt, Len(aLbxOrig))
	oLbxDest:nAt     := Min(oLbxDest:nAt, Len(aLbxDest))
EndIf

oLbxOrig:Refresh(.T.)
oLbxDest:Refresh(.T.)

Return .T.

/*

Ŀ
Funo    fValFiltro Autor  Emerson Rosa de Souza  Data  05.08.01 
Ĵ
Descrio  Monta um filtro para o tipo de titulo incluido		         
Ĵ
Parametros 								                                     
Ĵ
 Uso      Generico                                                    
ٱ

*/
Static Function fValFiltro(cAliasFiltro,cCpoFiltro,oWnd)
Local  nTamCpo    := Len(RC0->RC0_FILTRV)
Local  cFiltroRet := BuildExpr(cAliasFiltro,oWnd,cCpoFiltro)

If Len(cFiltroRet) > nTamCpo
	Aviso(STR0030, STR0031 + StrZero(nTamCpo,3), {STR0032})//"Aviso"##"O numero de maximo de caracteres permitido no filtro e "##"Ok"
Else
	cCpoFiltro := cFiltroRet
EndIf

Return Nil

/*

Ŀ
Funo      fSelLbT  Autor  Emerson Rosa de Souza  Data  08.08.01 
Ĵ
Descrio  Marca e desmarca itens da ListBox			                  
Ĵ
Parametros 								                                     
Ĵ
 Uso      Generico                                                    
ٱ

*/
Static Function fSelLbT(nAt,aArray,nTitSelect)
Local nCnt := 0  

nTitSelect := 0
For nCnt  := 1 To Len(aArray)
	If nCnt = nAt
		aArray[nAt,1]   := If(aArray[nAt,1], .F., .T.)
		nTitSelect      := If(aArray[nAt,1], nAt, 0)
	Else
		aArray[nCnt,1] := .F. 
	Endif
Next nCnt
If !Empty(aGerBen)
	If M->RC0_AGRUPA == "4" .And. nTitSelect == 4 
		oGerBen:enable()
	Else
		oGerBen:disable()
	EndIf
EndIf

Return aArray

/*

Ŀ
Funo      fSelLb2  Autor  Emerson Rosa de Souza  Data  13.05.02 
Ĵ
Descrio  Marca e desmarca itens da ListBox			                  
Ĵ
Parametros 								                                     
Ĵ
 Uso      Generico                                                    
ٱ

*/
Static Function fSelLb2(nAt,aArray)

aArray[nAt,4] := If(aArray[nAt,4] ==1, 3, 1)
aArray[nAt,5] := If(aArray[nAt,5] ==2, 3, 2)

Return aArray

/*


Ŀ
Funo    fAtuCpos() Autor  Emerson Rosa de Souza  Data  09/08/01 
Ĵ
Descrio  Atualiza os campos de filtro                               
Ĵ
 Uso                                                                  
ٱ

*/
Static Function fAtuCpos(cNomeAlias,cDescAlias,aFiltrD,oFiltroD,cCpoFiltDt,lCpoVerb)
Local cAlias := Alias()
Local cCpoFil
Local cCpoCC
Local cCpoPD 
Local cCpoVerba
Local cCpoMat
Local cCpoValor
Local cCpoVal
Local lLimpaCpos := .F.
Local cPrefCpo := ""
Local cAliasPerm := "SRC|SRD|RGB|SRR"

If !fSeleArq(@cNomeAlias,.T.)
	Return .F.
ElseIf !(cNomeAlias $ cAliasPerm)
	MsgStop(OemtoAnsi(STR0037 + " (" + cNomeAlias  + ") " +;	// "O arquivo selecionado (XXX)"
							  STR0080 +; //  invlido, escolha uma das tabelas permitidas: "
							  StrTran(cAliasPerm,"|",", ") + "."))
	cNomeAlias := ""
EndIf

//Ŀ
// Se alias vazio, marca para limpar campos de filtro		      
//
If Empty(cNomeAlias)
	lLimpaCpos  := .T.
//Ŀ
// Verifica se o alias escolhido e valido						      
//
Else
	//Ŀ
	// Verifica a existencia dos campos FILIAL/CC/PD/VERBA/MAT      
	//
	dbSelectArea(cNomeAlias)
	cPrefCpo  := PrefixoCpo(cNomeAlias)
	cCpoFil   := cPrefCpo+"_FILIAL"
	cCpoCC    := cPrefCpo+"_CC"
	cCpoPD    := cPrefCpo+"_PD"
	cCpoVerba := cPrefCpo+"_VERBA"
	cCpoValor := cPrefCpo+"_VALOR"
	cCpoVal   := cPrefCpo+"_VAL"
	cCpoValRK := cPrefCpo+"_VALORTO"
	cCpoMat   := cPrefCpo+"_MAT"
	If lCpoVerb
		If FieldPos(cCpoFil) == 0 .Or. FieldPos(cCpoCC) == 0 .Or.;
		   (FieldPos(cCpoPD) == 0 .And. FieldPos(cCpoVerba) == 0) .Or.;
		   (FieldPos(cCpoValor) == 0 .And. FieldPos(cCpoVal) == 0 .And. FieldPos(cCpoValRK) == 0)
			MsgStop(OemtoAnsi(STR0037 + " (" + cNomeAlias  + ") " +; // "O arquivo selecionado"
							  STR0038 +; 							  // deve obrigatoriamente conter os campos "
							  cCpoFil + ", " + cCpoCC + ", " + cCpoPD + ", " + cCpoValor + "."))
			lLimpaCpos  := .T.
		EndIf
	Else
		If FieldPos(cCpoFil) == 0
			MsgStop(OemtoAnsi(STR0037 + " (" + cNomeAlias  + ") " +; // "O arquivo selecionado"
							  STR0038 + cCpoFil + ".")) 			  // deve obrigatoriamente conter os campos "
			lLimpaCpos  := .T.
		EndIf
	EndIf
	//Ŀ
	// Verifica a existencia do campo _MAT no arquivo selecionado   
	//
	If M->RC0_AGRUPA == "4" .And. FieldPos(cCpoMat) == 0
		MsgStop(OemtoAnsi(STR0039 + cCpoMat + " " +;//"Para a geracao do titulo por agrupamento de funcionarios, o campo "
					      STR0040))                 // "deve existir no arquivo selecionado."
		lLimpaCpos  := .T.
	EndIf
EndIf

//Ŀ
// Limpa campos de filtro para nova definicao					 
//
If lCpoVerb
	M->RC0_FILTRF := Space(Len(RC0->RC0_FILTRF))
	M->RC0_FILTRV := Space(Len(RC0->RC0_FILTRV))
Else
	M->RC0_FILTDV := Space(Len(RC0->RC0_FILTDV))
EndIf

//Ŀ
// Verifica se deve limpar campos de alias e data de vencimento 
//
If lLimpaCpos
	cNomeAlias    := ""
	cDescAlias    := ""
	M->RC0_ALIADV := Space(Len(RC0->RC0_ALIADV))
	M->RC0_CPODTV := Space(Len(RC0->RC0_CPODTV))
	M->RC0_CPODTR := Space(Len(RC0->RC0_CPODTR))
	If lCpoVerb
		M->RC0_ALIAS    := Space(Len(RC0->RC0_ALIAS))
		M->RC0_FILTRD   := Space(Len(RC0->RC0_FILTRD))
	EndIf
Else
	//Ŀ
	// Se alterou o Alias busca no arquivo, descricao e data        
	//
	fBusNomSx2(cNomeAlias,@cDescAlias)
	If lCpoVerb
		M->RC0_ALIAS  := cNomeAlias
	Else
		M->RC0_ALIADV := cNomeAlias
	EndIf
EndIf
//Ŀ
// Carrega o array com os campos data do alias selecionado      
//
fCarrDat(cNomeAlias,@cCpoFiltDt,@aFiltrD,@oFiltroD,If(lLimpaCpos,2,1))

dbSelectArea( cAlias )

Return .T.

/*


Ŀ
Funo     fCarrDat  Autor  Emerson Rosa de Souza  Data  09/08/01 
Ĵ
Descrio  Carrega arrya com campos do alias selecionado		         
Ĵ
 Uso                                                                  
ٱ

*/
Static Function fCarrDat(cAlias,cCpoFiltDt,aFiltrD,oFiltrD,nCarrLimp)
//Ŀ
// Carrega no Array os campos tipo DATA do arquivo selecionado	
//
aFiltrD := {}
If nCarrLimp == 1
	DbSelectArea("SX3")
	dbSetOrder(1)
	dbSeek( cAlias )
	While !Eof() .And. X3_ARQUIVO == cAlias
		If SX3->X3_TIPO == "D"
			AADD(aFiltrD, SX3->X3_CAMPO )
		EndIf
		DbSkip()
	EndDo
	If Len(aFiltrD) == 1
		cCpoFiltDt := aFiltrD[1]
	EndIf
EndIf
If Len(aFiltrD) == 0
	aFiltrD := { Space(Len(cCpoFiltDt)) }
EndIf
If oFiltrD # Nil
	oFiltrD:aItems := aFiltrD
EndIf

Return Nil

/*


Ŀ
Funo    fBusNomSx2 Autor  Emerson Rosa de Souza  Data  09/08/01 
Ĵ
Descrio  Busca a descricao do arquivo gravado no campo RC0_ALIAS    
Ĵ
 Uso                                                                  
ٱ

*/
Static Function fBusNomSx2(cAliasNom,cAliasDesc)
Local cAlias := ALIAS()

If !Empty(cAliasNom)
	dbSelectArea( "SX2" )
	dbSeek( cAliasNom )
	cAliasDesc := cAliasNom + " - " + AllTrim(X2Nome())
	dbSelectArea( cAlias )
EndIf
Return Nil

/*


Ŀ
Funo     fInfArq   Autor  Emerson Rosa de Souza  Data  09/08/01 
Ĵ
Descrio  Verifica se foram digitados os campos arquivo e campo data.
Ĵ
 Uso                                                                  
ٱ

*/
Static Function fInfArq()
Local lRet := .T.

If Empty(M->RC0_ALIAS)
	MsgStop(OemtoAnsi(STR0042))  //"Informe o arquivo para a busca das verbas"
	lRet := .F.
EndIf

Return lRet

/*


Ŀ
Funo     fRadio    Autor  Kelly Soares           Data  11/05/06 
Ĵ
Descrio  Habilita/desabilita os campos de acordo com a opcao de     
           vencimento escolhida.                                      
Ĵ
 Uso                                                                  
ٱ

*/
Static Function fRadio(nRadio,cDmVenc,cDsVenc,cMesPgt,cDiaUtil)

If nRadio == 1 // Dia do Mes
	cDsVenc:=Space(1)
	oDsVenc:Disable()
	oDmVenc:Enable()
	oMesPgt:Enable()
	oDiautil:Enable()
	oDmVenc:Setfocus()
Else
	cDmVenc:=Space(2)
	cMesPgt:=Space(1)
	cDiaUtil:=Space(1)
	oDsVenc:Enable()
	oDmVenc:Disable()
	oMesPgt:Disable()
	oDiautil:Disable()
	oDsVenc:Setfocus()
Endif			
oDsVenc:Refresh()
oDmVenc:Refresh()
oMesPgt:Refresh()
oDiautil:Refresh()

Return .T.

/*


Ŀ
Funo    fObrigVenc Autor  Emerson Rosa de Souza  Data  09/08/01 
Ĵ
Descrio  Verifica se o campo de vencimento foi informado		         
Ĵ
 Uso                                                                  
ٱ

*/
Static Function fObrigVenc()
Local lRet  := .T.
Local cText := ""

If (Empty(M->RC0_DMVENC) .And. Empty(M->RC0_MESPGT) .And. Empty(M->RC0_DSVENC) .AND. If(Empty(M->RC0_ALIADV),Empty(M->RC0_DIAUTI),.F.)) .Or.;
   (Empty(M->RC0_DSVENC) .And. (Empty(M->RC0_DMVENC) .Or. Empty(M->RC0_MESPGT) .OR. If(Empty(M->RC0_ALIADV),Empty(M->RC0_DIAUTI),.F.))) .And.;
   (Empty(M->RC0_ALIADV) .Or. Empty(M->RC0_CPODTV) .Or. Empty(M->RC0_CPODTR))
	cText := STR0043 //"Vencimento do titulo"
ElseIf (!Empty(M->RC0_DMVENC) .Or. !Empty(M->RC0_DSVENC)) .And. !Empty(M->RC0_ALIADV)
	Aviso(STR0030, STR0056, {STR0032})//"Aviso"##"O vencimento do titulo devera ser informado uma unica vez."##"Ok"
	lRet := .F.
ElseIf Ascan(aLbxT, { |x| x[1] == .T. }) == 0
	cText := STR0022 //"Titulos disponiveis para selecao"
EndIf
If !Empty(cText)
	cText := cText + Space(50-Len(cText))
	Help(1," ","OBRIGAT",,cText,3,0)
	lRet := .F.
EndIf
Return lRet

/*


Ŀ
Funo    fCpoForn() Autor  Emerson Rosa de Souza  Data  25/10/02 
Ĵ
Descrio  Valida a inclusao de um campo de arquivo no cpo RC0_FORNEC.
Ĵ
 Uso                                                                  
ٱ

*/
Function fCpoForn()
Local lRet     := .F.
Local aArea	  := GetArea()
Local cNomCpo  := AllTrim(M->RC0_FORNEC)
Local nTamForn := Len(RC1->RC1_FORNEC) //Campo com tamanho compativel com E2_FORNECE
Local cAliasCC := "CTT"

//Ŀ
// Verifica se o conteudo do campo fornecedor e campo de arquivo
//
If "_" $ cNomCpo
	If M->RC0_AGRUPA $ "2*3"
		dbSelectArea( cAliasCC )
		If FieldPos( cNomCpo ) == 0
			MsgStop(OemToAnsi(STR0053 + cNomCpo + " " + STR0054 + " [" + cAliasCC + "]")) //"O campo "###"deve existir no arquivo"
		Else
			lRet := .T.
		EndIf
	ElseIf M->RC0_AGRUPA == "4"
		dbSelectArea( "SRA" )
		If FieldPos( cNomCpo ) == 0
			MsgStop(OemToAnsi(STR0053 + cNomCpo + " " + STR0054 + " [SRA]"))  //"O campo "###"deve existir no arquivo"
		Else
			lRet := .T.
		EndIf
	EndIf
Else
	M->RC0_FORNEC := Left(cNomCpo + Space(nTamForn), nTamForn)
EndIf
RestArea( aArea )

Return lRet

/*


Ŀ
Funo     fRelaArq  Autor  Emerson Rosa de Souza  Data  03/02/03 
Ĵ
Descrio  Define relacionamento de arquivo para busca data vencimento
Ĵ
 Uso                                                                  
ٱ

*/
Static Function fRelaArq(cAliasVerb)

local aArea		 := GetArea()
Local aCpoDtVenc := {}
Local aCpoDtRela := {}
Local bSet15	    := { || NIL } 
Local bSet24	    := { || NIL }
Local cAliasVenc := M->RC0_ALIADV
Local cDescAVenc := ""
Local oCpoDtVenc
Local oCpoDtRela       

//Ŀ
// Declarao de arrays para dimensionar tela		               
//
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

Local aAdv1Size		:= {}
Local aInfo1AdvSize	:= {}
Local aObj1Size		:= {}
Local aObj1Coords	:= {}

Local aAdv2Size		:= {}
Local aInfo2AdvSize	:= {}
Local aObj2Size		:= {}
Local aObj2Coords	:= {}

Local  oBtnA	:= LoadBitmap( GetResources(), "EDITABLE" )
Local  oBtnB	:= LoadBitmap( GetResources(), "FILTRO" )
Local  oDlg2


//Ŀ
// Busca a descricao do arquivo gravado no campo RC0_ALIADV     
//
fBusNomSx2(cAliasVenc,@cDescAVenc)

//Ŀ
// Carrega o array com os campos data do alias selecionado  	   
//
fCarrDat(M->RC0_ALIADV, @M->RC0_CPODTV, @aCpoDtVenc,,1)
fCarrDat(M->RC0_ALIADV, @M->RC0_CPODTR, @aCpoDtRela,,1)

//Ŀ
// Monta as Dimensoes dos Objetos         		                  
//
aAdvSize	   := MsAdvSize(,.T.,300)
aInfoAdvSize := { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 20, 20 }					 
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize	 := MsObjSize( aInfoAdvSize , aObjCoords )

aAdv1Size	 := aClone(aObjSize[1])
aInfo1AdvSize := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 0, 0 }					 
aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
aObj1Size	 := MsObjSize( aInfo1AdvSize , aObj1Coords )   


aAdv2Size	 := aClone(aObj1Size[1])
aInfo2AdvSize := { aAdv2Size[2] , aAdv2Size[1] , aAdv2Size[4] , aAdv2Size[3] , 10, 0 }					 
aAdd( aObj2Coords , { 030 , 000 , .F. , .T. } )
aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
aAdd( aObj2Coords , { 015 , 000 , .F. , .T. } )
aObj2Size	 := MsObjSize( aInfo2AdvSize , aObj2Coords,,.T. )

DEFINE MSDIALOG oDlg2 FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi(STR0048) PIXEL // "Definicao do Relacionamento para busca do Vencimento"
    
   	oGroup1:= tGroup():New(aObjSize[1,1], aObjSize[1,2],aObjSize[1,3], aObjSize[1,4],OemtoAnsi(STR0049),oDlg2,,,.T.)
	oGroup1:SetFont(oFont1) 
	
	@ aObj1Size[2,1],aObj2Size[1,2] SAY OemtoAnsi(STR0026)  SIZE 40,10 OF oDlg2 PIXEL //FONT oFont2 //"Arquivo"
	@ aObj1Size[2,1],aObj2Size[2,2] MSGET oAliasVenc VAR cDescAVenc WHEN .F. SIZE 195,10 OF oDlg2 PIXEL

	oBtnA := TBtnBmp2():New( aObj1Size[2,1]*2,aObjSize[1,4]+242, 25, 25, 'EDITABLE' , , , , ;
					{||( fAtuCpos(@cAliasVenc,@cDescAVenc,@aCpoDtVenc,@oCpoDtVenc,@M->RC0_CPODTV,.F.),;
  					fCarrDat(cAliasVenc, @M->RC0_CPODTR, @aCpoDtRela,@oCpoDtRela,1) )} , ;
					oDlg2)
	

	@ aObj1Size[3,1],aObj2Size[1,2] SAY OemtoAnsi(STR0050)  SIZE 80,10 OF oDlg2 PIXEL //FONT oFont2 //"Campo Data Para Vencto"
	@ aObj1Size[3,1],aObj2Size[4,2] MSCOMBOBOX oCpoDtVenc VAR M->RC0_CPODTVD ITEMS aCpoDtVenc SIZE 60,10 OF oDlg2 PIXEL
	
	@ aObj1Size[4,1],aObj2Size[1,2] SAY OemtoAnsi(STR0055 + " " + AllTrim(M->RC0_ALIAS) + " (" + AllTrim(M->RC0_FILTRD) + ")")  SIZE 260,10 OF oDlg2 PIXEL //FONT oFont2 //"Campo data que relaciona o Arquivo atual ao Arquivo"
	@ aObj1Size[4,1],aObj2Size[4,2] MSCOMBOBOX oCpoDtRela VAR M->RC0_CPODTR ITEMS aCpoDtRela SIZE 60,10 OF oDlg2 PIXEL
	
	@ aObj1Size[5,1],aObj2Size[1,2] SAY OemtoAnsi(STR0028) SIZE 40,08 OF oDlg2 PIXEL //FONT oFont2 //"Filtro"
	@ aObj1Size[5,1],aObj2Size[2,2] MSGET oFiltrDv VAR M->RC0_FILTDV WHEN .F. SIZE 195,10 OF oDlg2 PIXEL
	  
	oBtnB := TBtnBmp2():New( aObj1Size[5,1]*2,aObjSize[1,4]+242, 25, 25, 'FILTRO' , , , , ;
					{||( If(Empty(cAliasVenc), MsgStop(OemtoAnsi(STR0029)),; //"Arquivo de filtro nao informado"
	  				fValFiltro(cAliasVenc,@M->RC0_FILTDV,oDlg)) )} , ;
					oDlg2)

	bSet15 := {||nopca:=1, oDlg2:End(),DeleteObject(oBtnA),DeleteObject(oBtnB)}
	bSet24 := {||oDlg2:End(),DeleteObject(oBtnA),DeleteObject(oBtnB)}

ACTIVATE MSDIALOG oDlg2 ON INIT ( EnchoiceBar(oDlg2, bSet15, bSet24 ) ) CENTERED

DeleteObject(oBtnA)
DeleteObject(oBtnB)
RestArea(aArea)

Return( .T. )

/*


Ŀ
Funo    RC0MESBOX  Autor  Ricardo Duarte Costa   Data  30/01/06 
Ĵ
Descrio  Define as opcoes a serem mostradas no campo RC0_MESPGT     
Ĵ
 Uso                                                                  
ٱ

*/
Function RC0MESBOX()

Local cString	:= ""

cString	:= STR0057+";"+STR0058+";"+STR0059 //"1=Mes Competencia"###"2=Mes Seguinte"###"3=Mes Seguinte Pagto"

Return(cString)

/*


Ŀ
Funo    fRc0VldTipo Autor  Tania Bronzeri        Data 08/03/2006
Ĵ
Descrio  Valida a inclusao do campo RC0_TIPO.                       
Ĵ
 Uso                                                                  
ٱ

*/
Function fRc0VldTipo()
Local cTipo		:=	AllTrim(M->RC0_TIPO)

IF Empty(cTipo) 
	Aviso( STR0060, STR0061, { "OK" } )		// "Atencao!"###"Tipo do Titulo Invalido ou Nao Informado. Informe tipo valido."
	Return .F.
Else
	If !EXISTCPO("SX5","05"+cTipo)
		Return .F.
	Endif
EndIF

Return .T.

/*


Ŀ
Funo    Gp640Fornec Autor  Tania Bronzeri        Data 16/03/2006
Ĵ
Descrio  Consiste Fornecedor / loja.                                
Ĵ
 Uso                                                                  
ٱ

*/
Function Gp640Fornec(cCodPesq)
Local cAlias	   := Alias()				// Alias atualmente em uso
Local aArea		:=(cAlias)->(GetArea()) 	// Registro atual posicionado
Local lRetorno	:= .T.
                                     
dbSelectArea( "SA2" )
dbSetOrder(1)
IF !(SA2->(DbSeek (xFilial("SA2") + cCodPesq)))
	Aviso( OemToAnsi(STR0060), OemToAnsi(STR0063) + OemToAnsi(STR0064) + OemToAnsi(STR0065),{"OK"},,OemToAnsi(STR0066))
	//"Atencao" ### "Nao sera possivel a integracao deste titulo com o Financeiro. 
	// E necessaria a criacao do campo Loja. Verifique Boletim Tecnico 'Definicao de Titulos para o Financeiro', 
	// de 01/09/2005." ### "Estrutura do Titulo Incompleta"
	lRetorno	:= .F.
EndIf	

(cAlias)->( RestArea( aArea ) )
dbSelectArea( cAlias )

Return lRetorno

/*                                	
Ŀ
Funo     MenuDef	      Autor  Luiz Gustavo      Data 08/01/2007
Ĵ
Descrio Isola opcoes de menu para que as opcoes da rotina possam    
          ser lidas pelas bibliotecas Framework da Versao 9.12 .      
Ĵ
Sintaxe   < Vide Parametros Formais >					
Ĵ
 Uso      GPEM630                                                     
Ĵ
 Retorno  aRotina							
Ĵ
Parametros< Vide Parametros Formais >					
*/   

Static Function MenuDef()
//Ŀ
// Define Array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada                          
//    1 - Pesquisa e Posiciona em um Banco de Dados             
//    2 - Simplesmente Mostra os Campos                         
//    3 - Inclui registros no Bancos de Dados                   
//    4 - Altera o registro corrente                            
//    5 - Remove o registro corrente do Banco de Dados          
//
Local aRotina :=   { {  STR0004 ,'PesqBrw'  , 0 , 1, ,.F.},;  //'Pesquisar'
                      { STR0005 ,'gp640Atu', 0 , 2},;   //'Visualizar'
					  { STR0006 ,'gp640Atu', 0 , 3},;   //'Incluir'
					  { STR0007 ,'gp640Atu', 0 , 4},;   //'Alterar'
					  { STR0008 ,'gp640Atu', 0 , 5} }   //'Excluir'


Return aRotina

/*


Ŀ
Funo    fRc0VldLoja Autor  Tania Bronzeri        Data 16/05/2006
Ĵ
Descrio  Valida a inclusao do campo RC0_LOJA.                       
Ĵ
 Uso                                                                  
ٱ

*/
Function fRc0VldLoja()

Local cLoja		:=	AllTrim(M->RC0_LOJA)
Local cForn		:=  M->RC0_FORNEC
Local lRet		:=	.T.

cLoja	:=	If(Empty(cForn),VAZIO(),cLoja)
                                    
lRet	:=	If(!("_" $ cForn),Existcpo("SA2",cForn+cLoja),.T.)

Return lRet

/*


Ŀ
Funcao    fVldForn   Autor  Renata Elena           Data  12/06/07 
Ĵ
Descricao   Apresenta mensagem para Agrupamento = Filial e            
			      cod.fornec = RA_MAT										         
Ĵ
 Uso                                                                  
ٱ

*/
Static Function fVldForn()
Local lRet := .T.

If(M->RC0_AGRUPA == "1" .and. "_" $ M->RC0_FORNEC)
	MsgStop(OemtoAnsi(STR0073))
	lRet := .F.
EndIf

If cpaisloc == "BRA"
	If (M->RC0_AGRUPA <> "1" .and. M->RC0_TPRET == "2")
		MsgStop(OemtoAnsi(STR0078)) //"Para este Agrupamento somente  permitido por Cod. Reteno Informado!"
		lRet := .F.
	EndIf
EndIf

Return lRet

/*


ͻ
Programa  ValidAgrupAutor  Luciana Silveira     Data   04/23/10   
͹
Desc.       Alertar ao usuario a nao utilizacao da opcao de           
            agrupamento por Nivel de Centro de Custo.                 
͹
Uso        AP                                                         
ͼ

*/
Function fValidAgrup()

Local lRet	:= .T. 

	If M->RC0_AGRUPA == "3"
		MsgAlert( OemToAnsi(STR0072), OemToAnsi(STR0060) ) 	//"Opo no disponvel. Favor selecionar a opo por Centro de Custo" ##"Ateno"
		lRet := .F.  
	EndIf
	
	//Verifica se  Imposto de Renda
	If ((aLbxT[3,1]),oTpRetIR:Enable(), oTpRetIR:Disable())
	
	If !Empty(aGerBen)
		If M->RC0_AGRUPA == "4" .And. nTitSelect == 4 
			oGerBen:enable()
		Else
			oGerBen:disable()
		EndIf
	EndIf
				
Return lRet	


/*


ͻ
Programa  fVldTpRet Autor  Mauricio Takakura    Data   02/05/14   
͹
Desc.       Tratamento para os campos de Codigo de Retencao.          
͹
Uso        AP                                                         
ͼ

*/
Function fVldTpRet(nTipo)

Local lRet	:= .T.

	If nTipo == 2
		If M->RC0_TPRET == "2"  //ja protegido para apenas Brasil antes da chamada desta funcao
			lRet := .F.
		EndIf
	ElseIf nTipo == 1
		If M->RC0_TPRET == "2" .and. !Empty(M->RC0_CODRET)  //ja protegido para apenas Brasil antes da chamada desta funcao 
			IF MsgYesNo( 	OemToAnsi( STR0074 ) + CRLF +; 		//"Para o Tipo de Reteno por Funcionrios "
							OemToAnsi( STR0075 ) + CRLF +; 		//"o Cdigo de Reteno dever estar em branco!"
							OemToAnsi( STR0076 ), cCadastro ) 	//"A confirmao ir limpar este campo. Confirma a Alterao?"
				M->RC0_CODRET := Space( GetSx3Cache("RC0_CODRET", "X3_TAMANHO") )
			Else
				lRet := .F.
			EndIf
		EndIf
	EndIf


Return( lRet )

/*{Protheus.doc} fVldGerBen
Tratamento para os campos de Gerar p/ Beneficirio.
 @author Raquel Hager
@since 06/01/2017
@version P12.1.16
*/
Function fVldGerBen(nTipo)
Local lRet	:= .F.


	If nTipo == 2
		If M->RC0_AGRUPA == "4"
			lRet := .T.
		EndIf	
	EndIf

Return( lRet )
