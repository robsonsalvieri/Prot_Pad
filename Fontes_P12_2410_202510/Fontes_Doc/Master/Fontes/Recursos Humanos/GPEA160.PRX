#INCLUDE "GPEA160.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "HEADERGD.CH"
#INCLUDE "COMPILE.CH"

Static lFirst := .T.

/*
зддддддддддбддддддддддбдддддбддддддддддддддддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGPEA160   ЁAutorЁMarinaldo de Jesus       			 Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддадддддаддддддддддддддддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCadastro de Roteiros de Calculo						 			       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    		   Ё
цддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё         ATUALIZACOES SOFRIDAS DESDE A CONSTRU─AO INICIAL.            			   Ё
цддддддддддддбддддддддбддддддддддддддддбддддддддддддддддддддддддддддддддддддддддддд╢
ЁProgramador Ё Data   Ё FNC / Chamado  Ё  Motivo da Alteracao                      Ё
цддддддддддддеддддддддеддддддддддддддддеддддддддддддддддддддддддддддддддддддддддддд╢
ЁLeandro Dr. Ё29/11/12ЁM12RH01         ЁProtheus 12 - Separacao de modelo 1 e 2.   Ё
Ё            Ё        Ё          RQ2005ЁGPEA160 - Mod.1 / GPEA161 - Mod. 2         Ё
ЁMohanad OdehЁ13/03/13ЁM12RH01         ЁAlteracao na aba para preenchimento de     Ё
Ё            Ё        Ё          RQ2002Ёdados para os Periodos Padroes.De enchoice Ё
Ё            Ё        Ё                Ёpara Getdados                              Ё
ЁFlavio C.   Ё05/06/14ЁTPPCUQ          ЁPermissao de alteraГЦo dos campos Orniario Ё
Ё            Ё        Ё                ЁGrupo de perguntas e Integra               Ё
ЁRaquel HagerЁ09/09/14ЁTQLZZ8          ЁRemocao de tratamento para Dt. Corte(RGA). Ё
ЁFlavio C    Ё27/07/15ЁTSWORN          ЁPermitir alterar o campo RY_CONTAB 		   Ё
ЁMariana M.  Ё12/08/15ЁTSURMD          ЁAjuste na tabela RGA para que possa ser graЁ
Ё            Ё        Ё                Ёvadas as informaГУes corretamente, respei- Ё
Ё            Ё        Ё                Ёtando compartilhamento das tabelas SRY/SRM Ё
ЁM. Silveira Ё07/01/16ЁTTXXWE          ЁCorrigidos os parametros xFilial da tabela Ё
Ё            Ё        Ё                ЁRGA para retornar o valor correto.         Ё
ЁRicardo D.  Ё24/11/16ЁMRH-1814/TWJZQT ЁInclusao de validacao para compilacao dos  Ё
Ё            Ё        Ё                Ёroteiros em caso de inexistencia no RPO.   Ё
ЁRenan BorgesЁ22/02/17ЁMRH-6779/7501   ЁAjuste para gerar o repositСrio de formulasЁ
Ё            Ё        Ё                Ёcorretamente, quando for gerado a partir deЁ
Ё            Ё        Ё                Ёuma rotina de cАlculo. AlИm disso foi dispoЁ
Ё            Ё        Ё                Ёnibilizado a opГЦo de recompilar tudo na roЁ
Ё            Ё        Ё                Ёtina de Roteiros de cАlculos, que sС serА  Ё
Ё            Ё        Ё                ЁpossМvel a recompilaГЦo quando estiver ex- Ё
Ё            Ё        Ё                Ёclusivo o rpo de fСrmulas.                 Ё
ЁPaulo O.    Ё08/08/17Ё                ЁAlteraГЦo para o entrar no D-1             Ё
юддддддддддддаддддддддаддддддддддддддддаддддддддддддддддддддддддддддддддддддддддддды
*/ 


/*
╠╠иммммммммммяммммммммммямммммммяммммЁ╠╠
╠╠ЁData Fonte SustentaГЦoЁ ChangeSet Ё╠╠
╠╠ЁддддддддддддаддддддддаддддддддддддЁ╠╠  
╠╠Ё    27/05/2015        Ё  304483   Ё╠╠ 
╠╠иммммммммммяммммммммммямммммммяммммм╠╠
*/

Function Gpea160()
Local aArea			:= GetArea()
Local aAreaSRY
Local aIndex		:= {}
Local cFiltra		:= ""
Local lOpeSoc		:= SuperGetMv("MV_OPESOC", NIL, .F.) 

Private lModPadrao	:= (MV_MODFOL == '1')
Private aRotina 	:= {}
Private aColsClone	:= {}
Private aIdErro		:= {}
Private cCadastro
Private cModAlias	:= ""
Private cFilSRV		:= xFilial("SRV")

Private lManutence := ( FunName() == "GPEA160M" )

If lModPadrao

	aRotina 	:= MenuDef()
	
	cModAlias	:= 'SRY'
	aAreaSRY 	:= (cModAlias)->( GetArea() )
	
	aAdd(aRotina, { STR0007 , "Gpea160Cpy" , 0 , 6, ,.F. } ) //"Copiar"	
	aAdd(aRotina, { STR0008, "Gpea160Leg", 0, 7, ,.F.} )     //"Legenda"
	aAdd(aRotina, { STR0056, "Gpea160Mnt", 0, 8, ,.F.} )     //"Ver Codigo"
	aAdd(aRotina, { STR0158, "GPCompAll", 0, 8, ,.F.} )     //"Recompilar Tudo"
	
	cCadastro   := OemToAnsi( STR0001 ) //"Cadastro de Roteiros de Calculo"
	
	lManutence := ( FunName() == "GPEA160M" )
	
	If lManutence
		aAdd(aRotina, { STR0047 , "Gpea160Ger" , 0 , 9 } ) //"Gerar Procedimentos"
	Else
		Private lImpForm := .T.
	EndIF    
	
	Private bFiltraBrw	:= { || NIL }
	
	Private lGpea160Cpy := .F.
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica o Modo de Acesso do SRY e SRM. Ambos Tem que ser Iguais       Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF xRetModo( cModAlias , "SRM" )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se Deve Adicionar as Formulas Padroes                         Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !GpeGerFrm()
			Break
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega os Roteiros Padroes											 Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		If lImpForm
			Gpea160RotGer( .T. )
		EndIf
		GPCallCmpAll(cModAlias,.T.,.F.,,.T.)

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Inicializa o filtro utilizando a funcao FilBrowse                      Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cFiltra		:= ChkRh( FunName() , cModAlias , "1" )
		If cPaisLoc == "BRA" .And. !lOpeSoc
			If !Empty(cFiltra)
				cFiltra	+= " .And. "
			EndIf
			cFiltra += "RY_TIPO != 'O'"
		EndIf
		bFiltraBrw 	:= { || FilBrowse( cModAlias , @aIndex , @cFiltra ) }
		Eval( bFiltraBrw )
		
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Chama a Funcao de Montagem do Browse                                   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		mBrowse( 6 , 1 , 22 , 75 , cModAlias , , , , , , Gpea160Marks(),,,,,,,,,,,MV_MODFOL )
		
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Deleta o filtro utilizando a funcao FilBrowse                     	 Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		EndFilBrw( cModAlias , aIndex )
	
	EndIF
		
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Restaura os Dados de Entrada 											 Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	RestArea( aAreaSRY )
	RestArea( aArea )
Else
	//Se folha for modelo 2, deve utilizar o GPEA161.
	aRotina := FWLoadMenuDef( 'GPEA161' )
	GPEA161()
EndIf

Return( NIL )

/*                                	
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    Ё MenuDef		ЁAutorЁ  Luiz Gustavo     Ё Data Ё04/01/2007Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁIsola opcoes de menu para que as opcoes da rotina possam    Ё
Ё          Ёser lidas pelas bibliotecas Framework da Versao 9.12 .      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGPEA160                                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁaRotina														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/   
Static Function MenuDef()
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё ----------- Elementos contidos por dimensao ---------------  Ё
	//Ё 1. Nome a aparecer no cabecalho                              Ё
	//Ё 2. Nome da Rotina associada                                  Ё
	//Ё 3. Usado pela rotina                                         Ё
	//Ё 4. Tipo de Transa┤└o a ser efetuada                          Ё
	//Ё    1 - Pesquisa e Posiciona em um Banco de Dados             Ё
	//Ё    2 - Simplesmente Mostra os Campos                         Ё
	//Ё    3 - Inclui registros no Bancos de Dados                   Ё
	//Ё    4 - Altera o registro corrente                            Ё
	//Ё    5 - Remove o registro corrente do Banco de Dados          Ё
	//Ё    6 - Copiar                                                Ё
	//Ё    7 - Legenda                                               Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Local aRotina :=     {;
							{ STR0002, "PesqBrw",    0, 1, NIL, .F.},;	//"Pesquisar"
							{ STR0003, "Gpea160Mnt", 0, 2},;			//"Visualizar"
							{ STR0004, "Gpea160Mnt", 0, 3},;			//"Incluir"
							{ STR0005, "Gpea160Mnt", 0, 4},;			//"Alterar"
							{ STR0006, "Gpea160Mnt", 0, 5};				//"Excluir"
						}
Return aRotina

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGpea160MntЁ Autor ЁMarinaldo de Jesus     Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160Mnt( cAlias , nReg , nOpcX )							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcAlias = Alias do arquivo                                   Ё
Ё          ЁnReg   = Numero do registro                                 Ё
Ё          ЁnOpc   = Numero da opcao selecionada                        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGPEA160()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gpea160Mnt( cAlias , nReg , nOpc )

Local aArea				:= GetArea()
Local aAreaRGA
Local aSvKeys			:= GetKeys()
Local aSvSrmCols		:= {}
Local aSRYCols			:= {}
Local aSvSRYCols		:= {}
Local aSryEnchoice		:= {}
Local aFields			:= {}
Local aAltera			:= {}
Local aNaoAltera		:= {}
Local aSrmRecnos		:= {}
Local aSrmChave			:= {}
Local aNotFields		:= {}
Local aSryVirtChoice	:= {}
Local aSrmVirtual		:= {}
Local aSrmVisual		:= {}
Local aAdvSize			:= {}
Local aInfoAdvSize		:= {}
Local aObjSize			:= {}
Local aObjCoords		:= {}
Local aInfo1AdvSize		:= {}
Local aObj1Coords		:= {}
Local aObj1Size			:= {}
Local aObj2Coords		:= {}
Local aObj2Size			:= {}
Local aMnemos			:= {}
Local aGhost			:= {}
Local aAlter			:= {}

Local bSet15			:= { || NIL }
Local bSet24			:= { || NIL }
Local bCancel			:= { || NIL }
Local bOK				:= { || NIL }
Local bRef				:= { || NIL }

Local cFilRCA			:= xFilial( "RCA" )

Local nOpcAlt			:= 0
Local nUsado			:= 0
Local nX				:= 0
Local nXs				:= 0
Local nH				:= 0
Local nPosSeq			:= 0
Local nTamSeq			:= GetSx3Cache( "RM_SEQ" , "X3_TAMANHO" )

Local oDlg				:= NIL
Local oSryEnchoice		:= NIL	
Local aCopyRot			:= {}

Local aFolders			:= Array (02)
Local aPages			:= Array (02)
Local aRGACols			:= {}
Local aSvRGACols		:= {}
Local aRGAVisual		:= {}
Local aRGAEnchoice		:= {}
Local aRGAVirtChoice	:= {}
Local aRGAFields		:= {}
Local cRGAKeySeek		:= "" 
Local lSRYModulo 	    := SRY->(ColumnPos("RY_MODULO")) > 0

Private oFolders		:= NIL
Private aGets
Private aTela
Private aHeader			:= {}
Private aCols			:= {}
Private cRotOrd			:= ""
Private lExecPerg		:= .T.
Private oSrmGetDados	:= NIL
Private oRGAGet			:=NIL
Private nAba				:= 0
/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Define o Conteudo do aFolders								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
aFolders[01] 		:= "&"+STR0001	// "Cadastro de Roteiros de Calculo"
aFolders[02] 		:= "&"+STR0134	// "Periodos Padroes"

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Define o Conteudo do aPages								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
aPages[01]   		:= "&"+STR0001		// "Cadastro de Roteiros de Calculo"
aPages[02]			:= "&"+STR0134	// "Periodos Padroes"


Begin Sequence

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Inicializa a Static em Gpea290AliasGet()					   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	Gpea290AliasGet()

	If ( nOpc == 8 )	//Ver Codigo Fonte
		Gpea160SwCod( nReg , .F. )
		Break		
	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verificar se ja possui um roteiro ordinario            	   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cRotOrd		:= fGetRotOrdinar()

	If ( nOpc == 3  ) //Inclusao

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Quando For Inclusao Posiciona o SRY No Final do Arquivo	   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aRotSetOpc( cAlias , @nReg , nOpc , .T. )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Quando Inclusao Sempre Reinicializa n quando este ja tiver siЁ
		Ё do Criado de forma a Manter o Sequenciamento das formulas corЁ
		Ё reto														   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		If ( Type("n") != "U" )
			n := 1
		EndIf

	ElseIf ( lGpea160Cpy )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Altera opcao para Inclusao                                   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nOpc := 3	//Inclusao

	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta os Dados para a Enchoice							   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/                                              
	aSRYCols	:= (cAlias)->( GdBuildCols( @aSryEnchoice , NIL , @aSryVirtChoice , @aSrmVisual , cAlias , { PrefixoCpo(cAlias)+"_FILIAL" } , NIL , cAlias, , , , , ,) )
	aSvSRYCols	:= aClone( aSRYCols )
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Cria as Variaveis de Memoria e Carrega os Dados Conforme o arЁ
	Ё quivo														   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nXs := Len( aSryEnchoice )	
	For nX := 1 To nXs
			aAdd( aFields , aSRYEnchoice[ nX , 02 ] )
				SetMemVar( aSRYEnchoice[ nX , 02 ] , aSRYCols[ 1 , nX ]  , .T. )
	Next nX			
	// Monta os Dados para a Enchoice para segunda aba (RGA)
	aAreaRGA := GetArea()
	cRGAKeySeek := RY_FILIAL + RY_CALCULO + cModulo
	aRGACols	:= ("RGA")->(GdBuildCols( @aRGAEnchoice , NIL , @aRGAVirtChoice , @aRGAVisual , "RGA" , {"RGA_FILIAL"},	 NIL , "SRY", cRGAKeySeek, NIL,; //10
					 NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,;//30
					 NIL,NIL,"RGA_FILIAL+RGA_CALCUL+RGA_MODULO"))
	aSvRGACols	:= aClone(aRGACols)
	nXs := Len(aRGAEnchoice)
	For nX := 1 To nXs
			aAdd( aRGAFields , aRGAEnchoice[ nX , 02 ] )
			SetMemVar( aRGAEnchoice[ nX , 02 ] , aRGACols[ 1 , nX ]  , .T. )
	Next nX	
	RestArea(aAreaRGA)

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁDefine os Campos Editaveis na Enchoice Apenas na Inclusao( 3 )Ё
	Ёou Alteracao(4)											   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If (;
			( nOpc == 3 );
			.or.;
			( nOpc == 4 );
		)

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Modelo Padrao => Reinicializa M->RY_CALCULO/M->RY_ORIGEM Qdo. Copia de FormulaЁ
		Ё Modelo Mexico => Reinicializa M->RGA_PROCES/M->RGA_CALCULO Qdo. Copia de FormulaЁ
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		If ( lGpea160Cpy )
			SetMemVar( "RY_CALCULO" , Space( Len( GetMemVar( "RY_CALCULO" ) ) ) )
			SetMemVar( "RY_ORIGEM"  , CriaVar( "RY_ORIGEM" ) )
		EndIf
		
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Inclusao pelo Prog. Manutencao, sempre sera de Sistema.      Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		If ( lManutence ) .and. nOpc == 3
			M->RY_ORIGEM := "1"
		EndIf

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Inicializa os Mneumonicos Para uso em Formulas			   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		SetMnemonicos( cFilRCA , @aMnemos , .T. )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Inicializa as Verbas Para uso em Formulas			           Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		If FindFunction("fCarPD")
			fCarPD()
		EndIf

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Define os Campos Editaveis								   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nXs := Len( aSrmVisual )
		For nX := 1 To nXs
			aAdd( aNaoAltera , aSrmVisual[ nX ] )
		Next nX               
		If ( nOpc == 4 )                              
			aAdd( aNaoAltera , "RY_CALCULO" )
		EndIf

		aAdd( aAltera , "RY_INTEGRA" )
		aAdd( aAltera , "RY_PERGUNT" )
		aAdd( aAltera , "RY_ORDINAR" )
		aAdd( aAltera , "RY_CONTAB" )
		If lSRYModulo
			aAdd( aAltera , "RY_MODULO" )
		EndIf
		
		lAddFields := ( SRY->RY_ORIGEM == "1" .and. lManutence ) .or. ( SRY->RY_ORIGEM == "2" ) .Or. nOpc == 3
		If lAddFields
			nXs := Len( aFields )
			For nX := 1 To nXs
				If ( aScan( aNaoAltera , { |cNaoA| cNaoA == aFields[ nX ] } ) == 0 ) 
					aAdd( aAltera , aFields[ nX ] )
				EndIf
			Next nX
		EndIf
	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta os Dados para a GetDados							   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aAdd( aNotFields , "RM_FILIAL"  )
	aAdd( aNotFields , "RM_CALCULO"	)
	aAdd( aNotFields , "RM_IF"		)
	aAdd( aNotFields , "RM_FALSE"	)
	aAdd( aNotFields , "RM_SUBSEQ"	)
	aAdd( aNotFields , "RM_CODFOR"  )

	If (;
		( nOpc == 3 );
		.or.;
		( nOpc == 4 );
	)	
		aAdd( aNotFields , "RM_VERSAO"	)
	EndIf
	aAdd( aNotFields , "RM_CHAVE"	)

	aGhost := {{'GHOSTCOL',"GdNumItem('GHOSTCOL',,1)",GHOSTCOLSIZE}}
	
	aCols := SRM->( GdMontaCols( @aHeader 		,;	// 01 -> Array com os Campos do Cabecalho da GetDados
								 @nUsado 		,;	// 02 -> Numero de Campos em Uso
								 @aSrmVirtual 	,;	// 03 -> [@]Array com os Campos Virtuais
								 @aSrmVisual 	,;	// 04 -> [@]Array com os Campos Visuais
								 NIL			,;	// 05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
								 aNotFields 	,;	// 06 -> Opcional, Campos que nao Deverao constar no aHeader
								 @aSrmRecnos 	,;	// 07 -> [@]Array unidimensional contendo os Recnos
								 cAlias			,;	// 08 -> Alias do Arquivo Pai
								 NIL			,;	// 09 -> Chave para o Posicionamento no Alias Filho
								 NIL			,;	// 10 -> Bloco para condicao de Loop While
								 NIL			,;	// 11 -> Bloco para Skip no Loop While
								 NIL			,;	// 12 -> Se Havera o Elemento de Delecao no aCols 
								 NIL			,;	// 13 -> Se cria variaveis Publicas
								 NIL			,;	// 14 -> Se Sera considerado o Inicializador Padrao
								 NIL			,;	// 15 -> Lado para o inicializador padrao
								 NIL			,;	// 16 -> Opcional, Carregar Todos os Campos
								 NIL			,;	// 17 -> Opcional, Nao Carregar os Campos Virtuais
								 NIL			,;	// 18 -> Opcional, Utilizacao de Query para Selecao de Dados
								 NIL			,;	// 19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP ) - utilizado com o parametro 10
								 NIL			,;	// 20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP ) - utilizado com o parametro 11
								 aGhost			,;	// 21 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
								 NIL			,;	// 22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
								 NIL			,;	// 23 -> Verifica se Deve Checar se o campo eh usado
								 NIL			,;	// 24 -> Verifica se Deve Checar o nivel do usuario
								 NIL			,;	// 25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
								 NIL			,;	// 26 -> [@]Array que contera as chaves conforme recnos
								 NIL			,;	// 27 -> [@]Se devera efetuar o Lock dos Registros
								 NIL			,;	// 28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
						         NIL			,;	// 29 -> Numero maximo de Locks a ser efetuado
								 .T.			 ;	// 30 -> Utiliza Numeracao na GhostCol								 
							     ) )

	If Empty(aColsClone)
		aColsClone := aCols
	EndIf

	For nH := 1 To Len(aHeader)
		If  ( aScan( aSrmVirtual    	, { |cNaoA| cNaoA == aHeader[nH, 2] } ) == 0 )
			aAdd( aAlter , aHeader[nH, 2] )
		EndIf			   
	Next nH   

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁVerifica se o Campo de Roteiro esta ou nao Habilitado e ModifiЁ
	Ёca Sequencia com StrZero()									   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nPosSeq	  := GdFieldPos( "RM_SEQ" )
	aEval( @aCols , { |x| ;
					 		x[ nPosSeq	 ] := StrZero( Val( x[ nPosSeq	 ] ) , nTamSeq );
					 };
		  )
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁPara nao mostrar ao usuario na getdados o campo RM_CHAVE foi  Ё
	Ёcriado este array para utilizar na gravacao                   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	For nX := 1 To Len( aSrmRecnos )
		SRM->( DbGoTo( aSrmRecnos[ nX ] ) )
		aAdd( aSrmChave, SRM->RM_CHAVE ) 
	Next nX

	If !( lGpea160Cpy )
		aSvSrmCols := aClone( aCols )
	EndIf	

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para o Botao Confirma           			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSet15		:= { || lExecPerg := .F. , ;
							IF(;
									( nOpc == 3 );
									.or.;
									( nOpc == 4 );
									.or.;
									( nOpc == 5 ),;
									IF(;
											EnchoTudOk( oSryEnchoice );
											.and.;
											Gpea160TudOk(oSrmGetDados);
											.and.;
											G160RGATOK();
											.and.;
											( nOpcAlt := 1 , Eval( bGpea160GvTudOk ) );
											,;
											(;
												nOpcAlt := 1,;
												GetKeys(),;
												oDlg:End(),;
												.T.;
											),;
											( lExecPerg := .T., nOpcAlt := 0 , .F. );
										 ),;
										( nOpcAlt := 0 , .F. ); 
								);	
					 }
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para a Gravacao                 			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bGpea160GvTudOk := { || Gpea160GvTudOk(	@nOpcAlt		,;
											nOpc			,;
											@nReg			,;
											aSRYCols		,;
											aSvSRYCols		,;
											aSryEnchoice	,;
											aSryVirtChoice 	,;
											aHeader			,;
											aCols			,;
											aSrmVirtual		,;
											@aSrmRecnos		,;
											nUsado			,;
											aSvSrmCols		,;
											cAlias			,;
											aSrmChave		,;
											aRGACols		,;
											aSvRGACols		,;
											aRGAEnchoice	,;
											aRGAVirtChoice	;
							  			  );
						}

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para o Botao Cancela            			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSet24		:= { || ( lExecPerg := .F., nOpcAlt := 0 , GetKeys() , oDlg:End() ) }

	/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta as Dimensoes dos Objetos         					   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 1 , 1}
	aAdd( aObjCoords , { 000 , 000 , .T. , .T., .T.  } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

	aAdvSize		:= MsAdvSize(.T.)
	aAdvSize[4]		-=	43 // ALTURA
	aAdvSize[3]		-=	4 // Largura

	aInfo1AdvSize	:= { aAdvSize[1] , 1 , aAdvSize[3] , aAdvSize[4] , 1 , 1 }
	aAdd( aObj1Coords , { 000 , 110 , .T. , .F. } )
	aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
	
	aObj1Size 		:= MsObjSize( aInfo1AdvSize , aObj1Coords )
	
	aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )	
	aObj2Size 		:= MsObjSize( aInfo1AdvSize , aObj2Coords )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta o Dialogo Principal para a Manutencao das Formulas	   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nOpcAlt := 0
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( cCadastro ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() PIXEL

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega o Objeto Folder               					   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		oFolders := TFolder():New(	aObjSize[ 1 , 1 ]		,;
									aObjSize[ 1 , 2 ]		,;
									aFolders				,;
									aPages					,;
									oDlg					,;
									NIL						,;
									NIL						,;
									NIL						,;
									.T.						,;
									.F.						,;
									aObjSize[ 1 , 3 ]		,;
									aObjSize[ 1 , 4 ]		 ;
								 )
		oFolders:bChange := { ||  ,If( oFolders:nOption == 1, nAba := 1, nAba := 2) } // Controle sobre qual aba estА ativa

		oSryEnchoice	:= MsmGet():New( cAlias , nReg , nOpc , NIL , NIL , NIL , aFields , aObj1Size[1] , aAltera , NIL , NIL , NIL , , oFolders:aDialogs[01] , .F.,,,,,,,,,,AllTrim(MV_MODFOL))

		oRGAGet:=	MsNewGetDados():New(aObj2Size[1,1],; 						// 1-Top
										  aObj2Size[1,2],; 						// 2-nLelft
										  aObj2Size[1,3],;						// 3-nBottom	
										  aObj2Size[1,4],;						// 4-nRright
										  If(nOpc != 2 .and. nOpc != 5, GD_INSERT+GD_UPDATE+GD_DELETE,0),;	// 5-controle do que podera ser realizado na GetDado
										  "G160RGALOK",;							// 6-funcao para validar a edicao da linha - ulinhaOK
										  "G160RGATOK",;							// 7-funcao para validar todos os registros da GetDados -uTudoOK
										  "",;										// 8-cIniCPOS
										  aRGAFields,;							// 9-aAlter
										  0,;										//10-nFreeze
										  99999,;									//11-nMax
										  NIL,;									//12-cFieldOk
										  NIL,;									//13-usuperdel
										  NIL,;									//14-bloco com funcao para validar registros deletados
										  oFolders:aDialogs[02],;				//15-Objeto de dialogo
										  @aRGAEnchoice,;							//16-Vetor com aHeader
										  @aRGACols;								//17-Vetor com colunas 							  
										  )

		oSrmGetDados	:= MsGetDados():New(aObj1Size[2,1],aObj1Size[2,2],aObj1Size[2,3],aObj1Size[2,4],nOpc,"Gpea160LinOk","Gpea160TudOk","+RM_SEQ",.T.,aAlter,NIL,NIL,99999,,,,,oFolders:aDialogs[01],,AllTrim(MV_MODFOL))

		// Foi inserido esse tratamento para a inclusЦo, pois 
		// o controle de sequenciais esta no objeto da Getdados e 
		// sempre inicia em 0. Como tratamos para iniciar com > 0
		// inserido essa carga.
		If nOpc == 3
			aCols[1, nPosSeq] := StrZero( 1, nTamSeq )
		EndIf

		bCancel		:= { || oDlg:End() }
		bOK			:= bGpea160GvTudOk 
		bCopy		:= { || aCopyRot := Gpea160Copy() }
		bPaste		:= { || Gpea160Paste( aCopyRot ) }
		bInsert		:= { || Gpea160Insert(), oSrmGetDados:oBrowse:SetFocus(), oSrmGetDados:oBrowse:Refresh() }
		bSet24		:= { || ( lEnd	:= Eval(bCancel) ) }
		bRef		:= { || fLocaliza("", "SRM", {"RM_FORMULA" } ) }
		bFind       := { || fFindCF( aCols, aHeader ) }

		aButtons	:=	{;
						{"COPY"  ,{||Eval( bCopy )} ,STR0036,STR0036},;	//"Copiar"
						{"PASTE" ,{||Eval( bPaste )}  ,STR0037,STR0037},;	//"Colar"
						{"REF" ,{||Eval( bRef )}  ,STR0083,STR0083} ;	//"Localizar Referencia Cruzada"
					}

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15 , bSet24 , Nil , aButtons ) CENTERED

End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁRestaura os Dados de Entrada								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
lGpea160Cpy := .F.
RestKeys( aSvKeys )
RestArea( aArea )

Return( nOpcAlt )

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддддд©╠╠
╠╠ЁFun┤└o    ЁGpea160InsertЁ Autor Ё Equipe RH       	 Ё Data Ё22/02/2013  Ё╠╠
╠╠цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддддд╢╠╠
╠╠ЁDescri┤└o Ё                                                               Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё GPEA160 													               Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/

Function Gpea160Insert()

Local nNumRec := n
Local nTotRec := Len(aCols)
Local nIndex  := 0
Local nCampos := 0
Local cIndice := StrZero(1,TamSx3('RM_SEQ')[1])
Local nPosSeq := Ascan(aHeader,{|x| Alltrim(x[2])== 'RM_SEQ'})
Local aTmpAcols:= {}   
Local nQtCampos := 0 
Local nI		:= 0
Local nPosDescPD:= GdFieldPos("RM_DESCPD")
Local nPosCodFor:= GdFieldPos("RM_DESCFOR")

If Gpea160LinOk(oSrmGetDados:oBrowse)
	
	Aadd( aCols, Array( Len(aCols[1]) ) )

	aEval(aCols,{|x,nI| aCols[nI][nPosSeq]:=cIndice,cIndice:=Soma1(cIndice)  } )
	nQtCampos := Len(aCols[1])
	For nIndex := nTotRec TO nNumRec STEP -1
		For nCampos:=2 To nQtCampos
			aCols[nIndex+1][nCampos]	:=	aCols[nIndex][nCampos]
		Next nCampos
	Next nIndex
		
	nCampos:=2
	aEval(aCols[nNumRec],{||if(ValType(aCols[nNumRec][nCampos])=="C",aCols[nNumRec][nCampos]:=Space(aHeader[nCampos][4]),aCols[nNumRec][nCampos]:=0),++nCampos},2,Len(aHeader)-1)
	
	//start nos inicializadores padrao e os inclui no aCols
	aTmpAcols 	:= gdRmkAcols( aHeader )
	nNumRec		:= oSrmGetDados:oBrowse:nAt
	aTmpAcols[1,nPosDescPD] := ""
	aTmpAcols[1,nPosCodFor] := ""	

	For nI:= 1 To nQtCampos
		If !Empty(aTmpAcols[1,nI])
			aCols[nNumRec, nI] := aTmpAcols[1,nI]
		EndIf		
	Next nI                                       

EndIf

Return

/*/
зддддддддддбддддддддддддбдддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGpea160LinOkЁAutorЁMarinaldo de Jesus     Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддддадддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160LinOk( oBrowse )									    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA160()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gpea160LinOk( oBrowse , lNotTudoOk, lTudOk )

Local cSeq		:= ""
Local cHab		:= ""
Local lLinOk	:= .T.
Local nPosSeq	:= GdFieldPos("RM_SEQ")
Local nPosCodFor:= GdFieldPos("RM_FORMULA")
Local nPosHab	:= GdFieldPos("RM_HABILIT")
Local nX		:= 0
Local nAch		:= 0
Local nLenCols	:= 0

DEFAULT lTudOk	:= .F.

Begin Sequence
                    
	If !aCols[ n , Len( aCols[ n ] ) ]
		nLenCols := Len( aCols )
		For nX := 1 To nLenCols
			IF aCols[ n , nPosSeq ] == aCols[ nX , nPosSeq ] .and.;
				!aCols[ nX , Len( aCols[ nX ] ) ] .and. n # nX
				MsgAlert( OemToAnsi( STR0015 ) , OemToAnsi( STR0014 ) ) // "Sequencia ja cadastrada."#"Atencao"
				lLinOk := .F.
				Break
			EndIf
		Next nX
		If ( Val( aCols[ n , nPosSeq ] ) ==  0 )
			MsgAlert( OemToAnsi( STR0016 ) , OemToAnsi( STR0014 ) ) // "Sequencia deve ser preenchida."#"Atencao"
			lLinOk := .F.
			Break
		EndIf

		If Empty( aCols[ n , nPosHab ] )
			MsgAlert( OemToAnsi( STR0027 ) , OemToAnsi( STR0014 ) ) //"Faltou Definir se o Roteiro Esta ou Nao Habilitado."#"Atencao"
			lLinOk := .F.
			Break
		EndIf

		If Empty( aCols[ n , nPosCodFor ] )
			MsgAlert( OemToAnsi( STR0144 ) , OemToAnsi( STR0014 ) ) //"FСrmula deve ser preenchida."#"Atencao"
			lLinOk := .F.
			Break
		EndIf		

	ElseIF ( ( Val( aCols[ n , nPosSeq ] ) % 10 == 0 ) .and. ( Val( aCols[ n , nPosSeq ] ) != 0 ) )
		If !( lManutence )
			aCols[ n , Len( aCols[ n ] ) ] := .F.
			MsgAlert( OemToAnsi( STR0017 ) ) // "Roteiro Padrao do Sistema, nao pode ser Excluido."
			lLinOk := .F.
			Break
		EndIf
	EndIf

	DEFAULT lNotTudoOk := .T.
	If ( lNotTudoOk )
	
	   	cSeq := aCols[ n , nPosSeq ]
	    // Habilitar / Desabilitar todas as Sequencias alterada.
	   	cHab := aCols[ n , nPosHab ]
		nAch :=	aScan( aCols , { |x| x[ nPosSeq ] == cSeq } )
		For nX := nAch To nLenCols
			If ( cSeq != aCols[ nX , nPosSeq ] )
				Exit 
			EndIf
			aCols[ nX  , nPosHab ] := cHab
		Next nX

		// Coloca Sequencia do novo item em ordem
		aSort( aCols , NIL , NIL , { |x,y| x[ nPosSeq ] < y[ nPosSeq ] } )
		n := aScan( aCols , { |x| x[nPosSeq]  == cSeq } )
		oBrowse:nAt := Max( n , 1 )
		oBrowse:Refresh()

	EndIf           
		
End Sequence

Return( lLinOk )

/*/
зддддддддддбддддддддддддбдддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGpea160TudOkЁAutorЁMarinaldo de Jesus     Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддддадддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160TudOk( oBrowse )									    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA160()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gpea160TudOk(oBrowse)

Local lTudoOk	:= .T.

Local nLoop
Local nLoops

Begin Sequence

	nLoops := Len( aCols )
	For nLoop := 1 To nLoops
		n := nLoop
		If !( lTudoOk := Gpea160LinOk( oBrowse , .F., .T. ) )
			Break
		EndIf
	Next nLoop

End Sequence

Return( lTudoOk )

/*/
зддддддддддбддддддддддддбдддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGpea160MarksЁAutorЁMarinaldo de Jesus     Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддддадддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160Marks()											    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA160()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Gpea160Marks()

Local aMarks := {}

aMarks	:=	{	                                    	 	 ;
				{ "SRY->RY_ORIGEM=='2'" , "BR_VERDE"	}	,;
				{ "SRY->RY_ORIGEM=='1'" , "BR_AZUL"		}	 ;
			 }

Return( aClone( aMarks ) )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGpea160Leg   ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160Leg()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA160()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gpea160Leg()

Local aLegenda	:= {}
Local aSvKeys	:= GetKeys()

aLegenda := {;
				{ "BR_AZUL"  , OemToAnsi( STR0009 ) } ,; //"Roteiro Definido Pelo Sistema"
				{ "BR_VERDE" , OemToAnsi( STR0010 ) }  ; //"Roteiro Definido Pelo Usuario"
			}

BrwLegenda(	cCadastro ,	STR0011 , aLegenda )			 //"Legenda do Cadastro de Roteiros"

RestKeys( aSvKeys )

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGpea160SwCod ЁAutorЁMarinaldo de Jesus    Ё Data Ё14/11/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMostra Codigo Fonte do Roteiro                              Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA160()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Gpea160SwCod( nReg , lMsgNoYes, lSimula )

Local aSvKeys		:= GetKeys()
Local aAdvSize		:= MsAdvSize( .T. , .F. )
Local aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
Local aObjCoords	:= { { 000 , 095 , .T. , .F. } , { 000 , 000 , .T. , .T. } }
Local aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
Local aSource		:= {}
Local aRotErr		:= {}
Local aListbox		:= {}

Local bSet15		:= { || RestKeys() , oDlg:End() }
Local bSet24		:= { || RestKeys() , oDlg:End() }
Local bDialogInit	:= { || ( AlignObject( oDlg , { oGroup , oLbxSource } , 1 , 2 , { 40 } ) , EnchoiceBar( oDlg , bSet15 , bSet24 ) ) }

Local cPrg
Local cMsgInfo

Local lCompileOk	:= .T.

Local nHandle
Local nOpenOk
Local nLoop
Local nLoops

Local oGroup
Local oLbxSource
Local oFont
Local oDlg

Local oRpoForm

DEFAULT lMsgNoYes := .T.
DEFAULT lSimula := .F.

CursorWait()

Begin Sequence

	SRY->( MsGoto( nReg ) )
	IF SRY->( Eof() )
		Break
	EndIf

	cPrg := ( SRY->( RotGetFunc( RY_FILIAL , RY_CALCULO, RY_ORIGEM ) ) + ".PRG" )
	cPrg := Lower( GetRpoForm( .F. , .T. ) + cPrg )
	If (;
			( SRY->RY_RECOMP <> "2" );
			.or.;
			!File( cPrg, 1 );
			.or.;
			lSimula;
		)
		If !SRY->( RecLock( "SRY" ) )
			Break
		EndIf
		SRY->RY_RECOMP := "1"
		SRY->( MsUnLock() )
		MsAguarde( { || SRY->( GetFunRot( RY_FILIAL , RY_CALCULO , .T. , NIL , .F. , @oRpoForm,,,, lSimula) ) } , OemToAnsi( STR0048 ) )	//"Compilando Novo(s) Roteiro(s)..."
		lCompileOk := !ErrorInRot()
		If lSimula
			SRY->(RecLock( "SRY"))
			SRY->RY_RECOMP := "2"
			SRY->( MsUnLock() )			
		EndIf			
		If !( lCompileOk )
			If ( ValType( oRpoForm ) == "O" )
				Gpea160SwErr( cPrg , oRpoForm:ErrLine , oRpoForm:ErrCol , oRpoForm:ErrStr )
			Else
				aRotErr 	:= RotGetErr()
				cLogErro 	:= ""
				For nLoop := 1 To Len( aRotErr )
					cLogErro += aRotErr[nLoop] + CRLF
				Next nY
				MsgInfo( cLogErro, STR0014 )	// Log ### "Atencao"
			EndIf
			Break
		EndIf
		If lSimula
			Return lCompileOk
		EndIf	
		If nAba == 2 .OR. (lMsgNoYes .and. !MsgNoYes(STR0049)) //"Deseja Consultar o Codigo Compilado?"
			Break
		EndIf		
	EndIf

	CursorWait()

	If !File( cPrg, 1 )
		cMsgInfo := STR0050	//"Nao foi possivel encontrar o arquivo:"
		cMsgInfo += CRLF
		cMsgInfo += cPrg
		cMsgInfo += CRLF
		Break
	EndIf

	If ( ( nHandle := fOpen( cPrg,,1 ) ) < 0 )
		nOpenOk := 0
		While (;
				!( fError() == 0 );
				.and.;
				( ++nOpenOk <= 50 );
			  )
			Sleep( 1000 )
			If ( ( nHandle := fOpen( cPrg,,1 ) ) > 0 )
				Exit
			EndIf
		End While
	EndIf

	If ( nHandle < 0 )
		cMsgInfo := STR0051 //"Nao foi possivel abrir o arquivo:"
		cMsgInfo += CRLF
		cMsgInfo += cPrg
		cMsgInfo += CRLF
		Break
	EndIf
	fClose( nHandle )

	aSource := FileSrvToArr( cPrg, 1 )
	If ( Empty( aSource ) )
		cMsgInfo := STR0066 //"O programa nЦo contИm dados a serem apresentados"
		cMsgInfo += CRLF
		cMsgInfo += cPrg
		cMsgInfo += CRLF
		Break
	EndIf

	nLoops	:= Len( aSource )
	For nLoop := 1 To nLoops
		aAdd( aListbox , { nLoop , aSource[ nLoop ] } )
	Next nLoop

	DEFINE FONT oFont NAME "Courier New" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE cCadastro From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME STATUS PIXEL 
	
		@ aObjSize[1,1] , aObjSize[1,2] GROUP oGroup TO aObjSize[1,3],aObjSize[1,4] LABEL OemToAnsi( STR0052 ) OF oDlg PIXEL						//"Programa:"
		oGroup:oFont:= oFont

		@ aObjSize[1,1] + 10 , aObjSize[1,2] + 5	SAY OemToAnsi( cPrg )	SIZE 500,10 OF oGroup PIXEL FONT oFont
	
		oLbxSource				:= TWBrowse():New( aObjSize[2,1],aObjSize[2,2],aObjSize[2,4],aObjSize[2,3],NIL,{ OemToAnsi( STR0054 ) , OemtoAnsi( STR0052 ) },NIL,oDlg,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,.F.,NIL,.T.,NIL,.F.,NIL,NIL,NIL)
		oLbxSource:SetArray( aListbox )
		oLbxSource:bLine 		:= { || LineLstBox( oLbxSource , .F. ) }
		oLbxSource:bLdblClick	:= { || Gpea160EdSource( oLbxSource , cCadastro ) }
	
	ACTIVATE MSDIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED
	RestKeys( aSvKeys , .T. )

End Sequence

SRY->( MsGoto( nReg ) )

If !Empty( cMsgInfo )
	lCompileOk := .F.
	MsgInfo( cMsgInfo, STR0014 )	// Log ### "Atencao"
EndIf

CursorArrow()

Return( lCompileOk )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGpea160SwErr ЁAutorЁMarinaldo de Jesus    Ё Data Ё10/11/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMostra o Erro de Compilacao para o Usuario                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA290()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Gpea160SwErr( cPrg , nLine , nCol , cErrStr )

Local aSource		:= FileSrvToArr( cPrg, 1 )

Local aSvKeys
Local aAdvSize
Local aInfoAdvSize
Local aObjCoords
Local aObjSize
Local aListbox
Local aOkNo

Local bSet15
Local bSet24
Local bDialogInit

Local cMsgInfo
Local cStrErr
Local cString
Local cNumCol
Local cMulCol

Local nLoop
Local nLoops

Local oLbxSource
Local oSource
Local oLine
Local oCol
Local oExpr
Local oNumCol
Local oMulCol
Local oErrStr
Local oErrLine
Local oGroup1
Local oGroup2
Local oGroup3
Local oGroup4
Local oFont
Local oDlg
Local oPanel

Begin Sequence

	IF Empty( aSource )
		cMsgInfo := STR0051 //"Nao foi possivel abrir o arquivo:"
		cMsgInfo += CRLF
		cMsgInfo += cPrg
		cMsgInfo += CRLF
		Break
	EndIf

	aListbox	:= {}
	nLoops		:= Len( aSource )
	For nLoop := 1 To nLoops
		aAdd( aListbox , { ( nLoop <> nLine ) , nLoop , aSource[ nLoop ] } )
	Next nLoop

	If (;
			( nLine > 0 );
			.and.;
			( nLine <= nLoops );
		)
		cString	:= aSource[ nLine ]
		If ( nCol > 0 )
			nCol 	:= Min( nCol , Len( cString ) )
			cStrErr	:= SubStr( cString , nCol )
		Else
			cStrErr	:= cString
		EndIf
	Else
		cStrErr		:= ""
		cString		:= ""
	EndIf

	cNumCol	:= GetStrSeq( cString	, .T. )
	cMulCol := GetStrSeq( cNumCol	, .F. )

	aSvKeys			:= GetKeys()
	aAdvSize		:= MsAdvSize( .T. , .F. )
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
	aObjCoords		:= { { 000 , 27 , .T. , .F. } , { 000 , 27 , .T. , .F. } , { 000 , 15 , .T. , .F. } , { 000 , 15 , .T. , .F. } , { 000 , 000 , .T. , .T. } }
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
	
	aObjSize[1,1] -= 10
	aObjSize[2,1] -= 10
	aObjSize[3,1] -= 10
	aObjSize[4,1] -= 10

	aObjSize[1,3] -= 10
	aObjSize[2,3] -= 10
	aObjSize[3,3] -= 10
	aObjSize[4,3] -= 10

	aOkNo			:= Array( 02 )
	aOkNo[1]		:= LoadBitmap( GetResources() , "BR_VERDE"		)
	aOkNo[2]		:= LoadBitmap( GetResources() , "BR_VERMELHO"	)

	bSet15			:= { || RestKeys() , oDlg:End() } 
	bSet24			:= { || RestKeys() , oDlg:End() }
	bDialogInit		:= { || ( AlignObject( oDlg , { oPanel , oLbxSource } , 1 , 0 , { 167 } ) , EnchoiceBar( oDlg , bSet15 , bSet24 ) ) }

	DEFINE FONT oFont NAME "Courier New" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE cCadastro + OemToAnsi( " - " + cPrg ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME STATUS PIXEL 

		@ 000,000 MSPANEL oPanel OF oDlg

		@ aObjSize[1,1] , aObjSize[1,2] GROUP oGroup1 TO aObjSize[1,3],aObjSize[1,4] LABEL OemToAnsi(STR0067) OF oPanel PIXEL										//"Erro de CompilaГЦo"
		oGroup1:oFont:= oFont

		@ aObjSize[1,1] + 06 , aObjSize[1,2] + 5	SAY oSource VAR OemToAnsi( STR0052 + " " + cPrg ) 						SIZE 500,10	OF oGroup1 PIXEL FONT oFont	//"Programa:	"
		@ aObjSize[1,1] + 12 , aObjSize[1,2] + 5	SAY oLine	VAR OemToAnsi( STR0054 + " " + AllTrim( Str( nLine ) ) )	SIZE 500,10	OF oGroup1 PIXEL FONT oFont	//"Linha:		"
		@ aObjSize[1,1] + 18 , aObjSize[1,2] + 5	SAY oCol	VAR OemToAnsi( STR0055 + " " + AllTrim( Str( nCol ) ) )		SIZE 500,10	OF oGroup1 PIXEL FONT oFont	//"Coluna:		"

		@ aObjSize[2,1] , aObjSize[2,2] GROUP oGroup2 TO aObjSize[2,3],aObjSize[2,4] LABEL OemToAnsi(STR0057) OF oPanel PIXEL										//"Expressao:"
		oGroup2:oFont:= oFont
		@ aObjSize[2,1] + 06 , aObjSize[2,2] + 5	SAY oExpr VAR OemToAnsi( cString )				 						SIZE 500,10	OF oGroup2 PIXEL FONT oFont	
		@ aObjSize[2,1] + 12 , aObjSize[2,2] + 5	SAY oNumCol VAR OemToAnsi( cNumCol )				 					SIZE 500,10	OF oGroup2 PIXEL FONT oFont	
		@ aObjSize[2,1] + 18 , aObjSize[2,2] + 5	SAY oMulCol VAR OemToAnsi( cMulCol ) COLOR CLR_RED	 					SIZE 500,10	OF oGroup2 PIXEL FONT oFont

		@ aObjSize[3,1] , aObjSize[3,2] GROUP oGroup3 TO aObjSize[3,3],aObjSize[3,4] LABEL OemToAnsi(STR0058) OF oPanel PIXEL										//"Erro:"
		oGroup3:oFont:= oFont
		@ aObjSize[3,1] + 06 , aObjSize[3,2] + 5	SAY oErrStr VAR OemToAnsi( cErrStr ) COLOR CLR_RED							SIZE 500,10	OF oGroup3 PIXEL FONT oFont	

		@ aObjSize[4,1] , aObjSize[4,2] GROUP oGroup4 TO aObjSize[4,3],aObjSize[4,4] LABEL OemToAnsi(STR0068) OF oPanel PIXEL										//"Conteudo do Erro:"
		oGroup4:oFont:= oFont
		@ aObjSize[4,1] + 06 , aObjSize[4,2] + 5	SAY oErrLine VAR OemToAnsi( cStrErr ) COLOR CLR_RED							SIZE 500,10	OF oGroup4 PIXEL FONT oFont
		
		oLbxSource				:= TWBrowse():New( aObjSize[5,1],aObjSize[5,2],aObjSize[5,4],aObjSize[5,3],NIL,{ "" , OemToAnsi( STR0054 ) , OemtoAnsi( STR0052 ) },NIL,oDlg,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,.F.,NIL,.T.,NIL,.F.,NIL,NIL,NIL)
		oLbxSource:SetArray( aListbox )
		oLbxSource:bLine 		:= { || LineLstBox( oLbxSource , .T. , aOkNo , 1 ) }
		oLbxSource:bLdblClick	:= { || Gpea160EdSource( oLbxSource , cCadastro ) }
		If (;
				( nLine > 0 );
				.and.;
				( nLine <= nLoops );
			)	
			oLbxSource:nAt		:= nLine
		EndIf

	ACTIVATE MSDIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED
	RestKeys( aSvKeys , .T. )

End Sequence

If !Empty( cMsgInfo )
	MsgInfo( cMsgInfo )
EndIf

Return( NIL )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGpea160EdSource  ЁAutorЁMarinaldo de JesusЁ Data Ё01/12/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁEditar a Coluna do Codigo Fonte			 					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁoListBox:blDblClick							   				Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Gpea160EdSource( oListBox , cTitulo )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aSvKeys
Local aAdvSize
Local aInfoAdvSize
Local aObjSize
Local aObjCoords

Local bSet15
Local bSet24

Local cMemoEdit
Local oMemoEdit

Local oFont
Local oDlg

Begin Sequence

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Apenas se o ListBox nao Estiver Vazio      				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF Empty( oListBox:aArray )
		Break
	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem o Memo                               				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cMemoEdit := oListBox:aArray[ oListBox:nAt , oListBox:nColPos ]
	If ( ValType( cMemoEdit ) <> "C" )
		Break
	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta as Dimensoes dos Objetos             				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aAdvSize		:= MsAdvSize( .T. , .T. )
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
	aObjCoords		:= { { 0 , 0 , .T. , .T. } }
	aObjSize := MsObjSize( aInfoAdvSize , aObjCoords )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Salva as Teclas de Atalho                  				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aSvKeys := GetKeys()

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para a Tecla <CTRL-O>						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSet15	:= { || GetKeys() , oDlg:End() }

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para a Tecla <CTRL-X>     	   				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSet24	:= { || GetKeys() , oDlg:End() }

	DEFINE FONT oFont NAME "Arial" SIZE 0,-15 //BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( cTitulo ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME STATUS PIXEL 
			
		@ aObjSize[1,1],aObjSize[1,2] GET oMemoEdit VAR cMemoEdit MEMO SIZE aObjSize[1,4],(aObjSize[1,3]-15) FONT oFont HSCROLL CENTERED DESIGN NO VSCROLL OF oDlg PIXEL WHEN ( .T. )
		oMemoEdit:lReadOnly := .F.

		oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 ) CENTERED
	RestKeys( aSvKeys , .T. )

End Sequence

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGpea160GvTudOkЁAutorЁMarinaldo de Jesus   Ё Data Ё08/11/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGravacao das Informacoes no banco                           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA160()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Gpea160GvTudOk(	nOpcAlt			,;
								nOpc			,;
								nReg			,;
								aSRYCols		,;
								aSvSRYCols		,;
								aSryEnchoice	,;
								aSryVirtChoice	,;
								aHeader			,;
								aCols			,;
								aSrmVirtual		,;
								aSrmRecnos		,;
								nUsado			,;
								aSvSrmCols		,;
								cAlias			,;
								aSrmChave		,;
								aRGACols		,;
								aSvRGACols		,;
								aRGAEnchoice	,;
								aRGAVirtChoice	;
							  )

Local lGrvTudOk := .T.

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁQuando Confirmada a Opcao e Nao for Visualizacao Grava ou   ExЁ
Ёclui as Informacoes do SRY e SRM							   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If (;
		( nOpcAlt == 1 );	//Confirmou
		.and.;
		( nOpc != 2 );		//Nao eh Visualizacao
	)

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Quando For Copia Posiciona o SRY No Final do Arquivo 	       Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If ( lGpea160Cpy  )
		nOpc := 3 //Inclusao
		aRotSetOpc( cAlias , @nReg , nOpc , .T. )
		aSrmRecnos := {}
	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Removendo a Formula do Repositorio                           Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If ( nOpc == 5 )	//Exclusao
		(cAlias)->( MsGoto( nReg ) )
		(cAlias)->( DelFunRot( RY_FILIAL , RY_CALCULO ) )
	EndIf

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Simula compilaГЦo do roteiro antes de efetuar a gravaГЦo, para verificar se estА em uso   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/	
	If !(lGrvTudOk := Gpea160SwCod(nReg, .T., .T.))
		return lGrvTudOk
	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Gravando/Incluido ou Excluindo Informacoes do SRY/SRM        Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF Gpea160Grava(;
						nOpc			,;
						@nReg			,;
						aSRYCols		,;
						aSvSRYCols		,;
						aSryEnchoice	,;
						aSryVirtChoice	,;
						aRGACols		,;
						aSvRGACols		,;
						aRGAEnchoice	,;
						aRGAVirtChoice	,;						
						aHeader			,;
						aCols			,;
						aSrmVirtual		,;
						@aSrmRecnos		,;
						nUsado			,;
						aSvSrmCols	 	,;
						aSrmChave		,;
						cAlias			;
				 	)
		(cAlias)->( MsGoto( nReg ) )
		If (cAlias)->( !Eof() )
			If !(lGrvTudOk := Gpea160SwCod(nReg, .T.))
				lGpea160Cpy	:= .F.
				nOpcAlt		:= 0
			EndIf
		EndIf	
		
	EndIf	

EndIf

Return( lGrvTudOk )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGpea160Grava ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA160()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Gpea160Grava(	nOpc			,;	//Opcao de Acordo com aRotina
							 	nReg			,;	//Numero do Registro do Arquivo Pai ( SRY )
								aSRYCols		,;	//Itens do SRY
								aSvSRYCols		,;	//Conteudo inicial do SRY
							 	aSryEnchoice	,;	//Campos do Arquivo Pai ( SRY ) Mesma Estrutrua do aHeader
							 	aSryVirtChoice	,;	//Campos Virtuais do Arquivo Pai ( SRY )
								aRGACols		,;	//Itens do RGA 
								aSvRGACols		,;	//Conteudo inicial do RGA
								aRGAEnchoice	,;	//Campos do Arquivo Pai ( RGA ) Mesma Estrutrua do aHeader
								aRGAVirtChoice	,;	//Campos Virtuais do Arquivo Pai ( RGA )					 	
							 	aHeader			,;	//Campos do Arquivo Filho ( SRM )
							 	aCols			,;	//Itens do Arquivo Filho ( SRM )
							 	aSrmVirtual		,;	//Campos Virtuais do Arquivo Filho ( SRM )
							 	aSrmRecnos		,;	//Recnos do Arquivo Filho ( SRM )
							 	nUsado			,;	//Campos em uso na GetDados ( SRM )
							 	aSvSrmCols     	,;	//Copia inicial do acols
							 	aSrmChave		,;  //Array com os itens de chave - Para controle de atualizacao
							 	cAlias			;
							  )

Local aNewRecnos		:= {}
Local aColsDel			:= {}
Local aSvRecnos			:= aClone( aSrmRecnos )

Local cChave			:= ""
Local cNewChave			:= ""
Local cRyFilial			:= ""
Local cRyCalculo		:= ""
Local cKeySeek			:= ""
Local cCodFor			:= ""                  
Local cSrySeqFil		:= ""

Local lAlter			:= .F.
Local lSRYAlter			:= .F.
Local lSRMAlter			:= .F.
Local lRGAAlter			:= .F.
Local lAddNew			:= .F.

Local nChoice			:= 0
Local nChoices			:= 0
Local nHeader			:= 0
Local nHeaders			:= 0
Local nCol				:= 0
Local nCols				:= 0
Local nRecno			:= 0
Local nRecnos			:= 0
Local nDeleted			:= 0
Local nTamSeq			:= 0 
Local nSRMReg			:= 0
Local nChave			:= 0
Local nSrmNewSeq		:= 0
Local nSrmSeq			:= 0
Local nSrmFormula		:= 0
Local nPosGhostCol		:= 0
Local nx					:= 0
Local nPosRec				:= Len(aRGAEnchoice)+1 // POSICAO QUE INDICA SE ESTA DELETADO OU NAO
Local nRGARec				:= GdFieldPos( "RGA_REC_WT", aRGAEnchoice) //RECNO DO REGISTRO

DEFAULT nOpc			:= 0
DEFAULT nReg			:= 0
DEFAULT aSryEnchoice	:= {}
DEFAULT aSryVirtChoice	:= {}
DEFAULT aHeader			:= {}
DEFAULT aCols			:= {}
DEFAULT aSrmVirtual		:= {}
DEFAULT aSrmRecnos		:= {}
DEFAULT nUsado			:= 0

nPosGhostCol := GdFieldPos( "GHOSTCOL"	, aHeader )
Begin Sequence

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Se for Exclusao ( nOpc == 5 )								   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If ( nOpc == 5 )
		If !Empty( nReg )
			Begin Transaction
				(cAlias)->( dbGoto( nReg ) )
				IF RecLock( cAlias , .F. , .F. )
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁDeleto os Registros do SRM									   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					DelRecnos( "SRM" , @aSrmRecnos )
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁDeleto os Registros do SRY									   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					DelRecnos( cAlias , { nReg } , NIL , NIL , { { "RY_DESOBS" , "RY_CODOBS" } } , "SYP" )
					(cAlias)->( MsUnLock() )
				EndIf

			  	DbSelectArea("RGA")
			  	Dbsetorder(Retorder("RGA", "RGA_FILIAL+RGA_CALCUL"))
			  	While RGA->(!Eof())
					If DbSeek(SRY->RY_FILIAL + SRY->RY_CALCULO)
						If RGA->(RecLock("RGA", .F., .F.))
							RGA->(dbDelete())
							RGA->(MsUnLock())
						EndIf					
					EndIf
					RGA->(DbSkip())
				EndDo
				DbCloseArea()					
			End Transaction
		EndIf
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se for Inclusao/Alteracao ( nOpc == 3 .or. nOpc == 4 )	   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	ElseIF (;
				( nOpc == 3 );
				.or.;
				( nOpc == 4 );
			)	

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Atualiza o aSRYCols com o Conteudo das Variaveis de   MemoriaЁ
		Ё para comparacao											   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nChoices	:= Len(	aSryEnchoice )
		For nChoice := 1 To nChoices
			aSRYCols[ 1 , nChoice ] := GetMemVar( aSryEnchoice[ nChoice , 2 ] )
		Next nChoice

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Atualiza o aRGACols com o Conteudo das Variaveis de   MemoriaЁ
		Ё para comparacao											   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		oRGAGet:Refresh()
		aRGACols := aClone(oRGAGet:ACOLS)
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se Houveram Modificacoes no RGA                     Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lRGAAlter := !( ArrayCompare( aSvRGACols , aRGACols ) )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se Houveram Modificacoes no SRY                     Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lSRYAlter := !( ArrayCompare( aSvSRYCols , aSRYCols ) )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se Houveram Modificacoes no SRM                     Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lSRMAlter := !ArrayCompare( aCols , aSvSrmCols )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se Houveram Modificacoes                            Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lAlter	:= ((lSRYAlter) .OR. (lSRMAlter) .OR. (lRGAAlter))

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se nao Houveram Modificacoes, Abandona                       Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		If !( lAlter )
			Break
		EndIf
		
		// Iniciar a gravacao dos itens //
		Begin Transaction

			If ( lSRYAlter )
				If !( lAddNew := Empty( nReg ) )
					(cAlias)->( dbGoto( nReg ) )
					lAddNew := (cAlias)->( Eof() )
				EndIf
				If cAlias == "SRY"
					cSrySeqFil := ""
					If Empty(SRY->RY_SEQFIL) .or. lAddNew
						cSrySeqFil := GetSrySeqFil(If(lAddNew,xFilial(cAlias),SRY->RY_FILIAL))
					EndIf
				EndIf
				If (cAlias)->( RecLock( cAlias , lAddNew , .F. ) )
					(cAlias)->( FieldPut( FieldPos(PrefixoCpo(cAlias)+"_FILIAL") , xFilial(cAlias)) )
					For nChoice := 1 To nChoices
						If ( aScan( aSryVirtChoice , { |cCpo| ( cCpo == aSryEnchoice[ nChoice , 02 ] ) } ) == 0 )
							(cAlias)->( FieldPut( FieldPos( aSryEnchoice[ nChoice , 02 ] ) , aSRYCols[ 1 , nChoice ] ) )
						ElseIF ( aSryEnchoice[ nChoice , 02 ] == "RY_DESOBS" )
							MsMm((cAlias)->RY_CODOBS,NIL,NIL,aSRYCols[ 1 , nChoice ],1,NIL,NIL,cAlias,"RY_CODOBS")
							/*/
							здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							ЁGaranto Lock para o SRY que pode ter sido Liberado pela MsMm()Ё
							юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							(cAlias)->( RecLock( cAlias , .F. ) )
						EndIf
					Next nChoice
					If cAlias == "SRY" .and. !Empty(cSrySeqFil)
						SRY->RY_SEQFIL := cSrySeqFil
					EndIf
					(cAlias)->( MsUnLock() )
					nReg := (cAlias)->( Recno() )
				EndIf
			EndIf

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Pegar o ultimo codigo da chave - apenas qdo for manutencao   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			If ( lManutence )	// apenas para manutencao do roteiro - realizado pela Microsiga
				nSRMReg := SRM->( Recno() )
				SRM->( dbGoTop() )
				While SRM->( !Eof() )
					nChave := Max( Val( SubStr( SRM->RM_CHAVE , 3 , 4 ) ) , nChave )
					SRM->( dbSkip() )
				Enddo
				SRM->( dbGoto( nSRMReg ) )
			EndIf

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Garanto o Posicionamento do SRY       					   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			(cAlias)->( MsGoto( nReg ) )
			cRyFilial		:= &(cAlias + "->" + PrefixoCpo(cAlias) + "_FILIAL")
			cRyCalculo		:= &(cAlias + "->" + PrefixoCpo(cAlias) + "_CALCULO")
			cKeySeek := ( cRyFilial + cRyCalculo )

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem o Posicionamento do RM_SEQ        					   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			nSrmSeq 	:= GdFieldPos( "RM_SEQ" , aHeader )
         	nSrmFormula := GdFieldPos( "RM_FORMULA" , aHeader )
			nDeleted	:= ( nUsado + 1 )

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Excluir os itens de Usuario da gravacao                      Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			If ( lManutence )		// apenas para manutencao do roteiro - realizado pela Microsiga
				For nRecno := 1 To Len( aCols )
					If Substr( aCols[ nRecno, nSrmFormula ], 1, 2 ) == "U_"
						aCols[ nRecno , nDeleted ] := .T.
					EndIf
				Next nRecno
			EndIf

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Deleto todos os Itens que nao Estao OK					   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			GdSuperDel( aHeader , @aCols , NIL , .T. , GdGetBlock( "SRM" , aHeader , .F. ) ) 

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Separa os Itens que foram Deletados     					   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			SRM->( dbSetOrder( RetOrder( "SRM" , "RM_FILIAL+RM_CALCULO+RM_SEQ" ) ) )

			IF GdSplitDel( aHeader , @aCols , aSrmRecnos , @aColsDel )
				nCols	:= Len( aColsDel )
				For nCol := 1 To nCols
					IF SRM->( dbSeek( cKeySeek + aColsDel[ nCol , nSrmSeq ] , .F. ) )
                    		IF SRM->( RecLock( "SRM" , .F. ) )
                    			SRM->( dbDelete() )
                    			SRM->( MsUnLock() )
                    	EndIf
					EndIf
				Next nCol
			EndIf

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁObtenho os Recnos conforme Informacoes do aCols para a IntegriЁ
			Ёdade Referencial											   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aSrmRecnos := {}
			nCols := Len( aCols )
			For nCol := 1 To nCols
				if SRM->( dbSeek( cKeySeek + aCols[ nCol , nSrmSeq ] , .F. ) )
					SRM->( aAdd( aSrmRecnos , Recno() ) )
				Else            
					IF Val(aCols[ nCol , nPosGhostCol ]) > 0 .and. !Empty( aSvRecnos )
						aAdd( aSrmRecnos , aSvRecnos[ Val( aCols[ nCol , nPosGhostCol ] ) ] )          
					EndIf
				EndIf
			Next nCol

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Inicializa as Variaveis                 					   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			nHeaders	:= Len(	aHeader )
			nCols		:= Len(	aCols	)
			nRecnos		:= Len( aSrmRecnos )
			nTamSeq		:= aHeader[ nSrmSeq , 4 ]

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Reorganizar Sequencia quando pertencer a Manutencao e atuali-Ё
			Ё o array de recnos.                                           Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			For nRecno := 1 To nCols
				If ( lManutence ) // apenas para manutencao do roteiro - realizado pela Microsiga
					nSrmNewSeq += 10
					aCols[ nRecno , nSrmSeq ] := StrZero( nSrmNewSeq , nTamSeq )
				EndIf

				IF nRecno > nRecnos
					aAdd( aSrmRecnos , 0 )
				EndIf
			Next nRecno
			nRecnos		:= Len( aSrmRecnos )

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Gravando as Informacoes no SRM							   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			For nRecno := 1 To nRecnos
				nSRMReg := aSrmRecnos[ nRecno ]
				lAddNew := Empty( nSRMReg )
				If !( lAddNew )
					SRM->( dbGoto( nSRMReg ) )
					lAddNew := SRM->( Eof() )
				EndIf
				If ( lManutence ) // apenas para manutencao do roteiro - realizado pela Microsiga
					If ( Val( aCols[ nRecno , nPosGhostCol ] ) == 0 )
						nChave++
						cNewChave := ( "NI" + StrZero( nChave , 4 ) )
					EndIf
				EndIf
				If SRM->( RecLock( "SRM" , lAddNew ) )
					SRM->RM_FILIAL	:= cRyFilial
					SRM->RM_CALCULO := cRyCalculo

					For nHeader := 1 To nHeaders
						If ( aScan( aSrmVirtual , { |cCpo| ( cCpo == aHeader[ nHeader , 02 ] ) } ) == 0 )
							SRM->( FieldPut( FieldPos( aHeader[ nHeader , 02 ] ) , aCols[ nRecno , nHeader ] ) )
						EndIf
					Next nHeader

				    If ( Val( aCols[ nRecno , nPosGhostCol ] ) == 0 )
   				    	IF lManutence
					    	cChave	:= ( cNewChave + SubStr( cChave , 7 ) )
	   					Else
							cChave := ""
						EndIf
				    Else
				    	If Empty( aSrmChave )
			 				cChave := ""
			 			Else
			 				cChave := aSrmChave[ Val( aCols[ nRecno , nPosGhostCol ] ) ]
			 			EndIf
				 	EndIf         

				    cNewChave := ""
   					SRM->( FieldPut( FieldPos( "RM_CHAVE" ) , cChave ) )

					cCodFor :=  aCols[ nRecno, GdFieldPos( "RM_FORMULA" , aHeader ) ]
					SRM->( FieldPut( FieldPos( "RM_CODFOR" ) , Substr( cCodFor, 1, Len( AllTrim(cCodFor))-2) ) )

					SRM->( MsUnlock() )
					SRM->( aAdd( aNewRecnos , Recno() ) )
				EndIf
			Next nRecno

			// GRAVANDO AS INFORMACOES DE RGA
			If (lRGAAlter)
				For nx:= 1 to Len(aRGACols)

					DbSelectArea("RGA")
					Dbsetorder(Retorder("RGA", "RGA_FILIAL+RGA_PROCES+RGA_CALCUL"))
					If DbSeek(SRY->RY_FILIAL + aRGACols[nx, GdFieldPos("RGA_PROCES",aRGAEnchoice)] +SRY->RY_CALCULO)
						lAddNew := .F.
					Else
						lAddNew := .T.
					EndIf	

					If aRGACOLS[nx, nPosRec] == .T.	// VERIFICA SE LINHA ESTA DELETADA NO ACOLS
						If aRGAcols[nx,nRGARec] > 0		// SE RECNO EXISTIR EFETUA A DELECAO NA BASE
							("RGA")->(RecLock("RGA" , lAddNew , .F.))
							 DBDelete()
							 Loop
						Else
							Loop
						EndIf
					EndIf

					If ("RGA")->(RecLock( "RGA" , lAddNew , .F.))
						("RGA")->(FieldPut(FieldPos(PrefixoCpo("RGA")+"_FILIAL") , xFilial("RGA")))
						("RGA")->(FieldPut(FieldPos("RGA_CALCUL") , RY_CALCULO))
						For nChoice := 1 To Len(aRGAEnchoice)
							If (aScan(aRGAVirtChoice , { |cCpo| (cCpo == aRGAEnchoice[ nChoice , 02 ]) }) == 0)
								("RGA")->(FieldPut(FieldPos(aRGAEnchoice[ nChoice , 02 ]) , aRGACols[ nx , nChoice ]))
							EndIf
						Next nChoice
						("RGA")->(MsUnLock())
					EndIf
					Dbclosearea()
				Next nx
			EndIf

			If ( lAlter )
				cSrySeqFil := ""
				If Empty((cAlias)->RY_SEQFIL)
					cSrySeqFil := GetSrySeqFil(SRY->RY_FILIAL)
				EndIf
				IF RecLock( cAlias , .F. , .F. )
					(cAlias)->RY_RECOMP := "1" //Altero para Recompilar
					If ( lManutence )
						cVersao := Replicate( "0" , GetSx3Cache( "RY_VERSAO" , "X3_TAMANHO" ) )
						If ( nOpc == 3 )
							(cAlias)->RY_VERSAO := Soma1( cVersao )
						ElseIF ( nOpc == 4 )
							cVersao := (cAlias)->RY_VERSAO
							IF Empty( cVersao )
								cVersao := Replicate( "0" , GetSx3Cache( "RY_VERSAO" , "X3_TAMANHO" ) )
							EndIf
							(cAlias)->RY_VERSAO := Soma1( cVersao )
						EndIf
					EndIf
					If !Empty(cSrySeqFil)
						(cAlias)->RY_SEQFIL := cSrySeqFil
					EndIf	
					(cAlias)->( MsUnLock() )
				EndIf
	        EndIf

		End Transaction

	EndIf

End Sequence

aSrmRecnos := aClone( aNewRecnos )

Return( lAlter )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfGeraSalIncЁ Autor ЁMauricio T. Takakura  Ё Data Ё26/12/2005Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGeracao da Formula Salario Incorporado                      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfGeraSalInc()                     							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGenerico 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fGeraSalInc(cRotOrd, aHeader, aCols)

Local aRC3Recnos	:= {}
Local aRc3Header
Local aGetTreeFrm

Local cPrg
Local cRC3Key
Local cMsgErr
Local cRc3Opera3
Local cCodSalInc := "SALINC"

Local lNewReg
Local lCompileOk
Local lEndSalInc := .F.

Local nX
Local nReg
Local nRecnos
Local nTamSeqFor
Local nPosFormula
Local nPosHabilit

DEFAULT cRotOrd := fGetRotOrdinar()
DEFAULT aHeader	:= {}
DEFAULT aCols	:= {}

Begin Sequence

	If Empty(aCols) .and. Empty(aHeader)
		cSRMKey := xFilial( "SRM" ) + cRotOrd

		aCols := SRM->( GdMontaCols(	@aHeader	 								,;	// 01 -> Array com os Campos do Cabecalho
				 						NIL											,;	// 02 -> Numero de campos em uso
										NIL											,;	// 03 -> Array com os campos virtuais
								 		NIL											,;	// 04 -> Array com os campos visuais
								 		"SRM" 										,;	// 05 -> Opcional, Alias do Arquivo Carga dos itens do aCols
								 		NIL											,;	// 06 -> Opcional, campos que nao deverao constar do aHedder (NotFields)
								 		NIL											,;  // 07 -> [@]Array unidimensional contendo os Recnos
								 		"SRY"										,;	// 08 -> Alias do Arquivo Pai
								 		cSRMKey										,;	// 09 -> Chave para o Posicionamento no Alias Filho
								 		NIL											,;	// 10 -> Bloco para condicao de Loop While
								 		NIL											,;	// 11 -> Bloco para Skip no Loop While
								 		NIL											,;	// 12 -> Se Havera o Elemento de Delecao no aCols
								 		NIL											,;	// 13 -> Se cria variaveis Publicas
								 		NIL											,;	// 14 -> Se Sera considerado o Inicializador Padrao
								 		NIL											,;	// 15 -> Lado para o inicializador Padrao
								 		.T.											 ;	// 16 -> Opcional, Carregar Todos os Campos
									);
					  )
	EndIf

	If cPaisLoc <> "MEX" .and. !Empty(cRotOrd) .and. cRotOrd == SRY->RY_CALCULO

		DbSelectArea( "RC2" )
		DbSetOrder( 1 )		// RC2_FILIAL + RC2_ORIGEM + RC2_CODIGO
		If DbSeek( xFilial("RC2") + "S_" + cCodSalInc, .F.)
			lNewReg := .F.

			cRC3Key := RC2->RC2_FILIAL + RC2->RC2_ORIGEM + RC2->RC2_CODIGO

			RC3->( GdMontaCols(	@aRc3Header 								,;	// 01 -> Array com os Campos do Cabecalho
								NIL											,;	// 02 -> Numero de campos em uso
								NIL											,;	// 03 -> Array com os campos virtuais
						 		NIL											,;	// 04 -> Array com os campos visuais
						 		"RC3" 										,;	// 05 -> Opcional, Alias do Arquivo Carga dos itens do aCols
						 		NIL											,;	// 06 -> Opcional, campos que nao deverao constar do aHedder (NotFields)
						 		@aRC3Recnos									,;  // 07 -> [@]Array unidimensional contendo os Recnos
						 		"RC2"										,;	// 08 -> Alias do Arquivo Pai
						 		cRC3Key										,;	// 09 -> Chave para o Posicionamento no Alias Filho
						 		NIL											,;	// 10 -> Bloco para condicao de Loop While
						 		NIL											,;	// 11 -> Bloco para Skip no Loop While
						 		NIL											,;	// 12 -> Se Havera o Elemento de Delecao no aCols
						 		NIL											,;	// 13 -> Se cria variaveis Publicas
						 		NIL											,;	// 14 -> Se Sera considerado o Inicializador Padrao
						 		NIL											,;	// 15 -> Lado para o inicializador Padrao
						 		.T.											 ;	// 16 -> Opcional, Carregar Todos os Campos
							  );
				)
		Else
			lNewReg := .T.
	    EndIf

		IF RecLock( "RC2", lNewReg, .T. )
			If lNewReg
				RC2->RC2_FILIAL := xFilial( "RC2" )
				RC2->RC2_ORIGEM := "S_"
				RC2->RC2_CODIGO := "SALINC"
				RC2->RC2_DESC   := OemToAnsi(STR0082)	// "Formula Salario Incorporado"
			EndIf
			RC2->RC2_VERSAO := "001"
			RC2->RC2_RECOMP := "1"
			RC2->( MsUnLock() )
		Else
			cMsgErr := OemToAnsi(STR0079)	// "Nao foi possivel gerar a Formula Salario Incorporado!"
			Break
		EndIf

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁGravacao dos itens da formula.                                  Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nPosFormula := GdFieldPos( "RM_FORMULA", aHeader )
		nPosHabilit	:= GdFieldPos( "RM_HABILIT", aHeader )
		DbSelectArea( "RC3" )
		nRecnos := Len( aRC3Recnos )
		nTamSeqFor := GetSx3Cache( "RC3_SEQFOR" , "X3_TAMANHO" )
		For nX := 1 To Len( aCols )
			If nX == Len( aCols )
				cRc3Opera3 := ".END."
			Else
				cRc3Opera3 := ".CNT."
			EndIf
	
			If nX <= nRecnos
				nReg := aRC3Recnos[nX]
			Else
				nReg := 0
			EndIf
			lNewReg := .T.
			If nReg > 0
				lNewReg := .F.
				DbGoTo( nReg )
			EndIf
			
			If lEndSalInc .Or. aCols[nX, nPosHabilit] == "2"
				If !lNewReg
					RecLock( "RC3", lNewReg, .T. )
					RC3->( dbDelete() )
					RC3->( MsUnLock() )
				EndIf
				Loop
			EndIf
	
			If AllTrim( aCols[ nX, nPosFormula ] ) == "S_PROCSRC"
				cRc3Opera3 := ".END."
				lEndSalInc := .T.
			EndIf
			
			RecLock( "RC3", lNewReg, .T. )
			RC3->RC3_FILIAL	:= RC2->RC2_FILIAL
			RC3->RC3_ORIGEM := RC2->RC2_ORIGEM
			RC3->RC3_CODIGO := "SALINC"
			RC3->RC3_DESCR  := AllTrim( aCols[ nX, nPosFormula ] ) + "     " + cRc3Opera3
			RC3->RC3_SEQFOR := StrZero(	nX, nTamSeqFor )
			RC3->RC3_SEQPAI := StrZero(	0, nTamSeqFor )
			RC3->RC3_TIPO 	:= ".EXE."
			RC3->RC3_TPRESU	:= "5"
			RC3->RC3_RESULT := aCols[ nX, nPosFormula ]
			RC3->RC3_OPERA1	:= ""
			RC3->RC3_TPFM01	:= "5"
			RC3->RC3_FORM01	:= ""
			RC3->RC3_OPERA2 := ""
			RC3->RC3_TPFM02 := "5"
			RC3->RC3_FORM02 := ""
			RC3->RC3_OPERA3 := cRc3Opera3
			RC3->RC3_RESOU1	:= "PMSTASK4"
			RC3->RC3_RESOU2 := "PMSTASK4"
			RC3->( MsUnLock() )
		Next nX	
	
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁCompilar a Formula do Salario Incorporado                       Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cPrg := ( RC2->( RC2_ORIGEM + AllTrim( RC2_CODIGO ) ) + ".PRG" )
		cPrg := Lower( GetRpoForm( .F. , .T. ) + cPrg )
		MsAguarde( { || lCompileOk := RC2->( GetTreeFrm( @aGetTreeFrm , RC2_FILIAL , RC2_ORIGEM , RC2_CODIGO , .F. ) ) } , OemToAnsi( STR0080 ) )	//"Compilando Formula do Salario Incorporado (SalInc)..."
		RpoFormInit( NIL, .T. )
		If !lCompileOK
			If Empty( aGetTreeFrm )
				cMsgErr := STR0081	//"Nao foi possivel compilar o Programa da Formula Salario Incorporado (SalInc)!"
			EndIf
		EndIf
	EndIf

End Sequence

If !Empty( cMsgErr )
	MsgInfo( cMsgErr )
EndIf

Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGpea160CpyЁ Autor ЁMarinaldo de Jesus     Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160Cpy( cAlias , nReg , nOpc )							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcAlias = Alias do arquivo                                   Ё
Ё          ЁnReg   = Numero do registro                                 Ё
Ё          ЁnOpc   = Numero da opcao selecionada                        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGPEA160()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gpea160Cpy( cAlias , nReg , nOpc )

lGpea160Cpy := .T.

Return( Gpea160Mnt( cAlias , nReg , 4 ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGpea160ChkRot	ЁAutorЁMarinaldo de Jesus Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁMontar Dialogo para Edicao dos Campos do Roteiro de Calculo Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160ChkRot()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGPEA160														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁlRet														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                           									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gpea160ChkRot()

Local lRet 		 := .F.
Local lManutence := ( FunName() == "GPEA160M" )
Local lGpea161	 := IsInCallStack("GPEA161")
Local nSrmSeq 	 := 0
Local cSeqAux	 := ""
Local cCpo		 := Upper( AllTrim( SubStr( ReadVar() , 4 ) ) )
Local cCalculo	 := GetMemVar( "RY_CALCULO" )
Local oModel
Local oGrid

If lGpea161
	oModel 	:= FWModelActive()
	oGrid	:= oModel:GetModel( "GPEA161_SRM" )
	cSeqAux :=  oGrid:GetValue("RM_SEQ")
Else
	nSrmSeq := GdFieldPos( "RM_SEQ" )
	cSeqAux	:= aCols[n,nSrmSeq]
EndIf

lRet := !( Val(cSeqAux)%10 == 0 .and. Val(cSeqAux) != 0 )

If !( lManutence )
	If ( cCpo $ "RM_FORMULA" )
		If !( lRet )
			Gpea160EditRot( cCalculo , cCpo , .F. )
		EndIf
	ElseIF !lRet
		//"O Roteiro: " " e um Roteiro Padrao e nao pode ser alterado"###"Atencao"
		Help( "" , 1 , STR0014 , NIL , OemToAnsi(STR0012) + cCalculo + " - " + cSeqAux + OemToAnsi(STR0013) , 1 , 0 )
	EndIf
Else
 	If cCpo != "RM_SEQ"
  		lRet := .T.
 	EndIf
EndIf                

Return( lRet )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGpea160EditRot	ЁAutorЁMarinaldo de Jesus Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁMontar Dialogo para Edicao dos Campos do Roteiro de Calculo Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160EditRot(cRot,cCpo)								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGpea160ChkRot() em GPEA160                                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  Ё.T. 														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcRot	-> Copdigo do Roteiro								Ё
Ё          ЁcCpo	-> Campo a Ser Editado								Ё
Ё          ЁlModify	-> Possibilita a Alteracao							Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Gpea160EditRot(cRot,cCpo,lModify)

Local cDesc 	:= aCols[ n , GdFieldPos("RM_DESCRIC") ]
Local cSeq		:= aCols[ n , GdFieldPos("RM_SEQ") ]
Local cSep		:= " - "
Local cMemo		:= AllTrim( &( ReadVar() ) )
Local cTitulo	:= aHeader[ GdFieldPos( cCpo ) , 01 ]
Local cInit		:= "3"
Local lOk		:= .T.
Local lValid	:= .F.
Local nSize		:= aHeader[ GdFieldPos( cCpo ) , 04 ]
Local nInit		:= IF( cInit == "1" , Val( cInit ) , Val( cInit ) + 1  )
Local oDlg
Local oFont
Local oMemo

DEFAULT cRot	:= ""
DEFAULT cCpo	:= ""
DEFAULT lModify := .F.

If !( lModify )
	DEFINE FONT oFont  NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( cCadastro + cSep +cTitulo ) From 196,042 TO 400,580 OF oMainWnd PIXEL //"Roteiro de Calculo: "
		
		@ 12,05 TO 025,265 OF oDlg PIXEL
		@ 16,15	SAY cRot + cSep + cSeq + cSep + cSep + cDesc  SIZE 200,007 PIXEL FONT oFont COLOR CLR_HBLUE
		
		@ 027 , 005 GET oMemo VAR cMemo MEMO SIZE 260 , 070 FONT oFont OF oDlg PIXEL WHEN lModify VALID ( lValid := Gpea160ValidRot( cTitulo , @cMemo , nSize ) )
		
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||lOk:=lValid,oDlg:End()},{||oDlg:End()}) CENTERED
Else
	cMemo := fCamposForm( nInit , @cInit )
EndIf
		
If ( lOk )
	SetMemVar( cCpo , IF( Empty( cMemo ) , Space( nSize ) , cMemo + ( Space( nSize - Len( cMemo ) ) ) ) )
	aCols[ n , GdFieldPos( cCpo ) ] := GetMemVar( cCpo )
EndIf

Return( .T. )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGpea160ValidRot	ЁAutorЁMarinaldo de Jesus Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValida o Tamanho da Expressao digitada no Roteiro           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160ValidRot( cTitulo , cMemo , nSizeCpo )				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGpea160EditRot() em GPEA160                                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁlValid 														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcTitulo		-> Titulo do Campo a ser Validado				Ё
Ё          ЁcMemo		-> Expressao para Validacao						Ё
Ё          ЁnSizeCpo	-> Tamanho do Campo para Validacao				Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Gpea160ValidRot( cTitulo , cMemo , nSizeCpo )

Local lValid := ValidRot( cTitulo , @cMemo , nSizeCpo )

Return( lValid )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRyCalculoVld	ЁAutorЁMarinaldo de Jesus Ё Data Ё01/12/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar o conteudo do campo RY_CALCULO                      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRyCalculoVld()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_VALID do campo RY_CALCULO                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRyCalculoVld												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁNIL                                        					Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RyCalculoVld()

Local lRyCalculoVld

Begin Sequence

	If !( lRyCalculoVld := NaoVazio() )
		Break
	EndIf
                                      
	If MV_MODFOL <> '2'
	 	If !( lRyCalculoVld := Gpea160SRot( M->RY_CALCULO ) )
	 		Break
	 	EndIf
	EndIf
	
	If !( lRyCalculoVld := ExistChav( "SRY", M->RY_CALCULO, 1 ) )
		Break
	EndIf

	If !( lRyCalculoVld := FreeForUse( "SRY" , M->RY_CALCULO ) )
		Break
	EndIf

End Sequence

Return( lRyCalculoVld  )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRyDescVld		ЁAutorЁMarinaldo de Jesus Ё Data Ё07/12/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar o conteudo do campo RY_DESC		                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRyCalculoVld()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_VALID do campo RY_DESC                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRyDescVld													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁNIL                                        					Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RyDescVld()

Local lRyDescVld := .T.

Begin Sequence

	If !( lRyDescVld := NaoVazio() )
		Break
	EndIf

End Sequence

Return( lRyDescVld )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRyOrigemVld		ЁAutorЁMarinaldo de Jesus Ё Data Ё07/12/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar o conteudo do campo RY_ORIGEM	                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRyCalculoVld()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_VALID do campo RY_ORIGEM                                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRyDescVld													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁNIL                                        					Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RyOrigemVld()

Local lRyOrigemVld := .T.

Begin Sequence

	If !( lRyOrigemVld := NaoVazio() )
		Break
	EndIf
	
	If !( lRyOrigemVld := Pertence( RyOrigemBox( .T. ) ) )
		Break
	EndIf

End Sequence

Return( lRyOrigemVld )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRyOrigemBox  ЁAutorЁMarinaldo de Jesus    Ё Data Ё07/12/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁFuncao para Retornar as Opcoes do Campo RY_ORIGEM         	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_CBOX para o campo RY_ORIGEM	                         	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RyOrigemBox( lValid , lRetDesc , cOpcDesc )

Local cOpcBox

DEFAULT lValid		:= .F.
DEFAULT lRetDesc	:= .F.

If !( lValid )

	If !( lRetDesc )

		cOpcBox := ( "1=" + STR0062 + ";"	)	//"Sistema"
		cOpcBox += ( "2=" + STR0063			)	//"Usuario"

	Else

		Do Case
			Case ( cOpcDesc == "1" ) ; ( cOpcBox := STR0062 )	//"Sistema"
			Case ( cOpcDesc == "2" ) ; ( cOpcBox := STR0063 )	//"Usuario"
		End Case

	EndIf

Else

	cOpcBox := "12"

EndIf

Return( cOpcBox )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRyOrigemInit ЁAutorЁMarinaldo de Jesus    Ё Data Ё07/12/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInicializadora padrao do campo RY_ORIGEM                  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_RELACAO para o campo RY_ORIGEM	                        Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RyOrigemInit()
Return( SubStr( RyOrigemBox( .T. ) , -1 ) )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRyTipoBox    ЁAutorЁMauricio T. Takakura  Ё Data Ё11/02/2005Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁFuncao para Retornar as Opcoes do Campo RY_TIPO           	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_CBOX para o campo RY_TIPO  	                         	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RyTipoBox( lValid , lRetDesc , cOpcDesc )

Local cOpcBox
Local lGestPubl := IIF(ExistFunc("fUsaGFP"),fUsaGFP(),.F.)
Local lOpeSoc	:= SuperGetMv("MV_OPESOC", NIL, .F.) 

DEFAULT lValid		:= .F.
DEFAULT lRetDesc	:= .F.

If !( lValid )

	If !( lRetDesc )

	   	cOpcBox := ( "1=" + OemToAnsi(STR0071) + ";"	)	//"Folha de Pagamento"
		cOpcBox += ( "2=" + OemToAnsi(STR0072) + ";"	)	//"Adiantamento"
		cOpcBox += ( "3=" + OemToAnsi(STR0073) + ";"	)	//"Ferias"
		cOpcBox += ( "4=" + OemToAnsi(STR0074) + ";"	)	//"Rescisao"
		If cPaisLoc == "VEN"
			cOpcBox += ( "5=" + OemToAnsi(STR0095) + ";"	)	//"Antecipacao Utilidade"
			cOpcBox += ( "6=" + OemToAnsi(STR0096) + ";"	)	//"Pagamento Final Utilidade"
		Else		
			cOpcBox += ( "5=" + OemToAnsi(STR0075) + ";"	)	//"13o. Salario (1a. Parcela)"
			cOpcBox += ( "6=" + OemToAnsi(STR0076) + ";"	)	//"13o. Salario (2a. Parcela)"
		EndIf		
		cOpcBox += ( "7=" + OemToAnsi(STR0077) + ";"	)	//"Outros"
		cOpcBox += ( "8=" + OemToAnsi(STR0078) + ";"	)	//"Vale Transporte"
		cOpcBox += ( "9=" + OemToAnsi(STR0084) 	+ ";"  	)	//"Autonomos"          
		If MV_MODFOL=="2"
			cOpcBox += ( "A=" + OemToAnsi(STR0093) 	+ ";"  	)	//"Aplicacao de Rescisao"
		Elseif MV_MODFOL=="1"
			cOpcBox += ( "A=" + OemToAnsi(STR0097) 	+ ";"  	)	//"Provisao"
		EndIf
		If cPaisLoc == "BOL"
			cOpcBox += ( "B=" + OemToAnsi(STR0133) 	+ ";"  	)	//"Quinquenio"
		EndIf
		cOpcBox += ( "C=" + OemToAnsi(STR0140) + ";"	)	//"Plano de Saude"
		cOpcBox += ( "D=" + OemToAnsi(STR0141) + ";"	)	//"Vale Refeicao"
		cOpcBox += ( "E=" + OemToAnsi(STR0142) + ";"	)	//"Vale Alimentacao"
		If cPaisLoc == "BRA"
			cOpcBox += ( "F=" + OemToAnsi(STR0143) + ";"	)	//"PLR"  
			cOpcBox += ( "G=" + OemToAnsi(STR0148) + ";"	)	//"Salario Incorporado"
		EndIf
		cOpcBox += ( "H=" + OemToAnsi(STR0149) + ";"	)	//"Ponto ELetronico"
		cOpcBox += ( "I=" + OemToAnsi(STR0150) + ";"   )   //"Outros Beneficios"
		cOpcBox += ( "K=" + OemToAnsi(STR0155) + ";"   )   //"Valores Extras"
		If lGestPubl
			cOpcBox += ( "L=" + OemToAnsi(STR0161) + ";"	)	//"FИrias Servidores"
			cOpcBox += ( "M=" + OemToAnsi(STR0162) + ";"   )   //"FИrias Indenizadas"
		EndIf
		If cPaisLoc == "BRA" .And. !lGestPubl
			cOpcBox += ( "N=" + OemToAnsi(STR0163) + ";"   )   //"Complementar"
		EndIf
		If cPaisLoc == "BRA" .And. lOpeSoc
			cOpcBox += ( "O=" + OemToAnsi(STR0164) + ";"   )   //"BenefМcios Org. PЗblicos."
		EndIf

		If cPaisLoc == "RUS"
			cOpcBox := ( "1=" + OemToAnsi(STR0071) + ";"	)	//"Folha de Pagamento"
			cOpcBox += ( "2=" + OemToAnsi(STR0072) + ";"	)	//"Adiantamento"
			cOpcBox += ( "3=" + OemToAnsi(STR0073) + ";"	)	//"Ferias"
			cOpcBox += ( "4=" + OemToAnsi(STR0074) + ";"	)	//"Rescisao"
			cOpcBox += ( "7=" + OemToAnsi(STR0077) + ";"	)	//"Outros"
		EndIf
	Else

		Do Case
			Case ( cOpcDesc == "1" ) ; ( cOpcBox := OemToAnsi(STR0071) )	//"Folha de Pagamento"
			Case ( cOpcDesc == "2" ) ; ( cOpcBox := OemToAnsi(STR0072) )	//"Adiantamento"
			Case ( cOpcDesc == "3" ) ; ( cOpcBox := OemToAnsi(STR0073) )	//"Ferias"
			Case ( cOpcDesc == "4" ) ; ( cOpcBox := OemToAnsi(STR0074) )	//"Rescisao"
			Case ( cOpcDesc == "5" ) ; ( cOpcBox := OemToAnsi(STR0075) )	//"13o. Salario (1a. Parcela)"
			Case ( cOpcDesc == "6" ) ; ( cOpcBox := OemToAnsi(STR0076) )	//"13o. Salario (2a. Parcela)"
			Case ( cOpcDesc == "7" ) ; ( cOpcBox := OemToAnsi(STR0077) )	//"Outros"
			Case ( cOpcDesc == "8" ) ; ( cOpcBox := OemToAnsi(STR0078) )	//"Vale Transporte"
			Case ( cOpcDesc == "9" ) ; ( cOpcBox := OemToAnsi(STR0084) )	//"Autonomos"
			Case ( cOpcDesc == "A" ) ; ( cOpcBox := OemToAnsi(STR0093) )	//"Aplicacao de Rescisao"
			Case ( cOpcDesc == "B" ) ; ( cOpcBox := OemToAnsi(STR0133) )	//"Quinquenio"
			Case ( cOpcDesc == "C" ) ; ( cOpcBox := OemToAnsi(STR0140) )	//"Plano de Saude"
			Case ( cOpcDesc == "D" ) ; ( cOpcBox := OemToAnsi(STR0141) )	//"Vale Refeicao"
			Case ( cOpcDesc == "E" ) ; ( cOpcBox := OemToAnsi(STR0142) )	//"Vale Alimentacao"
			Case ( cOpcDesc == "F" ) ; ( cOpcBox := OemToAnsi(STR0143) )	//"PLR"     
			Case ( cOpcDesc == "G" ) ; ( cOpcBox := OemToAnsi(STR0148) )	//"Salario Incorporado"
			Case ( cOpcDesc == "H" ) ; ( cOpcBox := OemToAnsi(STR0149) )	//"Ponto Eletronico"
			Case ( cOpcDesc == "I" ) ; ( cOpcBox := OemToAnsi(STR0150) )	//"Outros Beneficios"
			Case ( cOpcDesc == "K" ) ; ( cOpcBox := OemToAnsi(STR0155) )	//"Valores Extras"
			Case ( cOpcDesc == "L" ) ; ( cOpcBox := OemToAnsi(STR0161) )	//"FИrias Servidores"
			Case ( cOpcDesc == "M" ) ; ( cOpcBox := OemToAnsi(STR0162) )	//"FИrias Indenizadas"
			Case ( cOpcDesc == "N" ) ; ( cOpcBox := OemToAnsi(STR0163) )	//"Complementar"
			Case ( cOpcDesc == "O" ) ; ( cOpcBox := OemToAnsi(STR0164) )	//"BenefМcios Org. PЗblicos."
		End Case

	EndIf

Else

	cOpcBox := "123456789ACDEHIK"
	If cPaisLoc == "BOL"
		cOpcBox += "B"		
	EndIf
	If cPaisLoc == "BRA"
		cOpcBox += "FG"
	EndIf
	If lGestPubl
		cOpcBox += "LM"
	EndIf
	If cPaisLoc == "BRA" .And. !lGestPubl
		cOpcBox += "N"
	EndIf
	If cPaisLoc == "BRA" .And. lOpeSoc
		cOpcBox += "O"
	EndIf
EndIf

Return( cOpcBox )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRyTipoVld		ЁAutorЁMauricio Takakura  Ё Data Ё11/02/2005Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar o conteudo do campo RY_TIPO  	                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRyTipoVld()   												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_VALID do campo RY_TIPO                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё           													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁNIL                                        					Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RyTipoVld()

Local lRyTipoVld := .T.

Begin Sequence

	If !( lRyTipoVld := NaoVazio() )
		Break
	EndIf

	If !( lRyTipoVld := Pertence( RyTipoBox( .T. ) ) )
		Break
	EndIf

End Sequence

Return( lRyTipoVld )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRyDesObsInit ЁAutorЁMarinaldo de Jesus    Ё Data Ё07/12/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInicializadora padrao do campo RY_DESOBS				    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_RELACAO para o campo RY_DESOBS	                        Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RyDesObsInit()
Return( IF( Inclui , "" , MsMm(SRY->RY_CODOBS , 80 ) ) )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRyAliasVld   ЁAutorЁMarinaldo de Jesus    Ё Data Ё07/12/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁValidar o conteudo do campo RY_ALIAS					    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_VALID para o campo RY_ALIAS								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RyAliasVld()

Local lRyAliasVld := .T.

Begin Sequence

	If !( lRyAliasVld := NaoVazio() )
		Break
	EndIf

	If !( lRyAliasVld := ExistCpo("SX2") )
		Break
	EndIf

End Sequence

Return( lRyAliasVld )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRyAliasSX2InitЁAutorЁMauricio Takakura    Ё Data Ё30/12/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInicializadora padrao do campo RY_ALIAS                   	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_RELACAO para o campo RY_ALIAS 	                        Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RyAliasSX2Init()
Return( SubStr( RyGetAliasSX2( .T. ) , 2, 3 ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRyGetAliasSX2   ЁAutorЁMauricio Takakura  Ё Data Ё30/12/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarregar em ListBox os arquivos abertos do SX2              Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRyGetAliasSX2()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_CBOX do campo RY_ALIAS                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁcOpcBox														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁNIL                                        					Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RyGetAliasSX2( lValid , lRetDesc , cOpcDesc )

Local aListAlias 	:= {}

Local cOpcBox		:= ""
Local cAliasSX2		:= ""
Local cArqSX2		:= ""

Local nX

DEFAULT lValid		:= .F.
DEFAULT lRetDesc	:= .F.

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Carregar o Alias em SX2                                                Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
fSeleArq( "" 			,;	// utilizado na janela (nesta opcao estara desativado)
		 .T. 			,;	// se carrega um item em branco
		 @aListAlias	,;	// array com os Alias
		 .F.			,;	// se mostra janela com os alias
		)				// funcao em GpexFun

If !( lValid )

	If !( lRetDesc )
		For nX := 1 To Len(aListAlias)
			cAliasSX2 := aListAlias[nX, 1]
			cArqSX2	:= aListAlias[nX, 2]
			If !Empty( cAliasSX2 )
				cOpcBox += ( cAliasSX2 + "=" + cArqSX2 + "; ")
			EndIf
		Next nX

		cOpcBox := SubStr( cOpcBox , 1 , Len( cOpcBox ) - 2 )
	Else
		nX := aScan( aListAlias, { |x| x[1] == cOpcDesc })
		If nX > 0
			( cOpcBox := aListAlias[nX, 2] )
		EndIf
	EndIf
Else
	cOpcBox := '"'
	For nX := 1 To Len(aListAlias)
		cAliasSX2 := aListAlias[nX, 1]
		cOpcBox += ( cAliasSX2 )
	Next nX
	cOpcBox += '"'
EndIf

Return( cOpcBox )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRmCalculoVld	ЁAutorЁMarinaldo de Jesus Ё Data Ё01/12/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar o conteudo do campo RM_CALCULO                      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRmCalculoVld()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_VALID do campo RM_CALCULO                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRmCalculoVld												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁNIL                                        					Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RmCalculoVld()

Local lRmCalculoVld

Begin Sequence

	If !( lRmCalculoVld := NaoVazio() )
		Break
	EndIf

	If !( lRmCalculoVld := ExistCpo( "SRY" ) )
		Break
	EndIf

End Sequence

Return( lRmCalculoVld  )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRmHabilitVld	ЁAutorЁMarinaldo de Jesus Ё Data Ё07/12/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar o conteudo do campo RM_HABILIT	                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRyCalculoVld()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_VALID do campo RM_HABILIT                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRyDescVld													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁNIL                                        					Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RmHabilitVld()

Local lRmHabilitVld := .T.

Begin Sequence

	If !( lRmHabilitVld := NaoVazio() )
		Break
	EndIf
	
	If !( lRmHabilitVld := Pertence( RmHabilitBox( .T. ) ) )
		Break
	EndIf

End Sequence

Return( lRmHabilitVld )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRmHabilitBox ЁAutorЁMarinaldo de Jesus    Ё Data Ё07/12/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁFuncao para Retornar as Opcoes do Campo RM_HABILIT         	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_CBOX para o campo RM_HABILIT	                         	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RmHabilitBox( lValid , lRetDesc , cOpcDesc )

Local cOpcBox

DEFAULT lValid		:= .F.
DEFAULT lRetDesc	:= .F.

If !( lValid )

	If !( lRetDesc )

		cOpcBox := ( "1=" + STR0064 + ";"	)	//"Sim"
		cOpcBox += ( "2=" + STR0065			)	//"Nao"

	Else

		Do Case
			Case ( cOpcDesc == "1" ) ; ( cOpcBox := STR0064 )	//"Sim"
			Case ( cOpcDesc == "2" ) ; ( cOpcBox := STR0065 )	//"Nao"
		End Case

	EndIf

Else

	cOpcBox := "12"

EndIf

Return( cOpcBox )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRmHabilitInitЁAutorЁMarinaldo de Jesus    Ё Data Ё07/12/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInicializadora padrao do campo RM_HABILIT                  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_RELACAO para o campo RM_HABILIT	                        Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RmHabilitInit()
Return( SubStr( RmHabilitBox( .T. ) , 1, 1 ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRmSeqVld		ЁAutorЁMarinaldo de Jesus Ё Data Ё01/12/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar o conteudo do campo RM_SEQ                      	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRmSeqVld()													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_VALID do campo RM_SEQ                                	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRmSeqVld													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁNIL                                        					Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RmSeqVld()

Local lRmSeqVld

Begin Sequence

	If !( lRmSeqVld := NaoVazio() )
		Break
	EndIf

	If !( FunName() == "GPEA160M" )
		If !( lRmSeqVld := ( ( Val( M->RM_SEQ ) % 10 ) # 0 ) )
			Break
		EndIf
	EndIf
	If !( lRmSeqVld := Gpea160SeqRot() )
		Break
	EndIf
	
End Sequence

Return( lRmSeqVld  )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRmDescricVld    ЁAutorЁMarinaldo de Jesus Ё Data Ё01/12/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar o conteudo do campo RM_DESCRIC                  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRmDescricVld ()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_VALID do campo RM_DESCRIC                              	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRmDescricVld 												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁNIL                                        					Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RmDescricVld()

Local lRmDescricVld

Begin Sequence

	If !( lRmDescricVld := NaoVazio() )
		Break
	EndIf

	If !( lRmDescricVld := Texto() )
		Break
	EndIf

End Sequence

Return( lRmDescricVld )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRmFormulaVld	ЁAutorЁMarinaldo de Jesus Ё Data Ё01/12/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar o conteudo do campo RM_FORMULA                      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRmFormulaVld()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_VALID do campo RM_FORMULA                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRmFormulaVld												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁNIL                                        					Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RmFormulaVld()

Local cRmFormula
Local lRmFormulaVld

Begin Sequence

	If !( lRmFormulaVld := NaoVazio() )
		Break
	EndIf

	cRmFormula := SubStr( M->RM_FORMULA , 1 , ( At( "(" , M->RM_FORMULA ) - 1 ) )
	If !( lRmFormulaVld := ExistCpo("RC2", Padr( cRmFormula ,TamSx3("RC2_ORIGEM")[1]+TamSx3("RC2_CODIGO")[1]),1,"NOEXISTFRM") )
		Break
	EndIf

End Sequence

Return( lRmFormulaVld  )

/*/
зддддддддддбддддддддддддддддбдддддбддддддддддддддддддддбдддддбдддддддддд©
ЁFun┤└o    ЁRyOrdinarVld	ЁAutorЁMauricio T. TakakuraЁData Ё07/12/2004Ё
цддддддддддеддддддддддддддддадддддаддддддддддддддддддддадддддадддддддддд╢
ЁDescri┤└o ЁValidar o conteudo do campo RY_ORDINAR                      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRyOrdinarVld()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_VALID do campo RY_ORDINAR                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRyOrdinarVld												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁNIL                                        					Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RyOrdinarVld()

Local cMsgHelp

Local lRyOrdinarVld := .T.

Begin Sequence
	If !Pertence('12')
		lRyOrdinarVld := .F.
		Break
	EndIf
	If !Empty(cRotOrd) .and. M->RY_ORDINAR == "1" .and. ( M->RY_CALCULO != cRotOrd)
		cMsgHelp := STR0094 //'O Roteiro OrdinАrio jА esta cadastrado!'
		Help( "" , 1 , "ORDINAR" , NIL , OemToAnsi( cMsgHelp ) , 1 , 0 )
		lRyOrdinarVld := .F.
	EndIf
End Sequence
	
Return( lRyOrdinarVld )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGpea160SRot     ЁAutorЁMarinaldo de Jesus Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁVerifica se o Roteiro que esta sendo incluido e Padrao      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160SRot( cRot )											Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGPEA160														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁlRet														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                           									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gpea160SRot( cRot )

Local lNotSistem	:= .T.
Local lManutence    := ( FunName() == "GPEA160M" )

Local aRotPadrao

Local cRotPadrao
Local cMsgHelp

Local nPosRot
Local nRot
Local nRots

Begin Sequence

	If ( Type( "Inclui" ) <> "L" )
		Private Inclui := .F.
	EndIf

	If ( Inclui )
	
		If !( lManutence );

			aRotPadrao		:= {}
			cRotPadrao		:= ""
			fGeraRoteiro( NIL , @aRotPadrao , .T. )
			DEFAULT cRot	:= &( ReadVar() )
			cRot := Upper( AllTrim( cRot ) )
			nRots := Len( aRotPadrao )
			lNotSistem := !( nPosRot := aScan( aRotPadrao , { |x| x[1] == cRot } ) > 0 )
			If !( lNotSistem )
				cMsgHelp	:= STR0059	//"Nao И Possivel a InclusЦo de Roteiros Padroes."
				cMsgHelp	+= CRLF
				cMsgHelp	+= STR0060	//"Selecione um Nome do Roteiro que nЦo conste na"
				cMsgHelp	+= CRLF
				cMsgHelp	+= STR0061	//"Listagem abaixo:"
				cMsgHelp	+= CRLF
				cMsgHelp	+= CRLF
				For nRot := 1 To nRots
					cMsgHelp	+= ( aRotPadrao [ nRot , 1 ] + " -> " + aRotPadrao [ nRot , 2 ] )
					cMsgHelp	+= CRLF
				Next nRot
				Help( "" , 1 , "NOROTPAD" , NIL , OemToAnsi( cMsgHelp ) , 1 , 0 )
				Break
			EndIf

		EndIf
		
		If !( lNotSistem := !FindFunction( GetFunRot( xFilial( "SRY" ) , cRot , .F. , NIL , .F. , NIL , Inclui ) ) )
			cMsgHelp := STR0069	//"Ja Existe FunГЦo Compilada com o Nome Deste Roteiro"
			cMsgHelp += CRLF
			cMsgHelp += STR0070	//"Informe um Novo Nome."
			Help( "" , 1 , "NOROTVALID" , NIL , OemToAnsi( cMsgHelp ) , 1 , 0 )
			Break
		EndIf               
	
	EndIf

End Sequence
	
Return( lNotSistem )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGpea160Copy	    ЁAutorЁMarinaldo de Jesus Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCopia Linha do Roteiro										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160Copy()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGPEA160														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁArray contendo a Copia da Linha aTual				 		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                           									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Gpea160Copy()
Return( aClone( aCols[ n ] ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGpea160Paste    ЁAutorЁMarinaldo de Jesus Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCopia Linha do Roteiro										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160Paste( aPaste )										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGPEA160														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁlRet														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                           									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Gpea160Paste( aPaste )

Local nSrmSeq 	:= GdFieldPos( "RM_SEQ" )
Local cSeq		:= aCols[ n , nSrmSeq ]
Local cCalculo	:= GetMemVar( "RY_CALCULO" )

If !Empty( aPaste )
	If ( ( Val( cSeq )%10 != 0 ) .or. Empty( cSeq ) )
		aCols[n] 			 := aClone( aPaste )
		aCols[ n , nSrmSeq ] := cSeq
	Else
		//"O Roteiro: " " e um Roteiro Padrao e nao pode ser alterado"###"Atencao"
		MsgAlert( OemToAnsi(STR0012) + cCalculo + " - " + aCols[ n , nSrmSeq ] + OemToAnsi(STR0013) , OemToAnsi(STR0014) )
	EndIf
EndIf

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGpea160SeqRot ЁAutorЁMarinaldo de Jesus   Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁSequencia dos Roteiros										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160SeqRot()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁInicializador Padrao do RC3_SEQFOR                          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁSequencia da Formula										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gpea160SeqRot()

Local cVar		:= ""
Local cSeq		:= ""
Local lRet		:= .T.
Local lGpea161	:= IsInCallStack("GPEA161")
Local nTamSx3	:= GetSx3Cache( "RM_SEQ" , "X3_TAMANHO" )
Local nSrmSeq	:= 0
Local nPos		:= 0
Local nLinAux	:= 0
Local nX		:= 0
Local oModel
Local oGrid

cVar := &( ReadVar() )
cSeq := StrZero( Val( cVar ) , nTamSX3 )

If lGPea161
	oModel 	:= FWModelActive()
	oGrid	:= oModel:GetModel( "GPEA161_SRM" )
	nLinAux	:= oGrid:GetLine()
	For nX := 1 to oGrid:Length()
		If !(nX == nLinAux)
			oGrid:GoLine(nX)
			If oGrid:GetValue("RM_SEQ") == cSeq
				nPos := nX
				Exit
			EndIf
		EndIf
		n := nLinAux
	Next nX
	oGrid:GoLine(nLinAux)
Else
	nSrmSeq := GdFieldPos( "RM_SEQ" )
	nPos := aScan( aCols , { |x,y| x[ nSrmSeq ] == cSeq .and. y != n } )
EndIf

If ( lRet := ( nPos == 0 .or. nPos == n ) )
	&( ReadVar() ) := cSeq
Else
	//"Ja Existe a Sequencia Informada. Digite uma nova sequencia"###"Sequencia Invalida"
	Help( "" , 1 , STR0029 , NIL , OemToAnsi( STR0028 ) , 1 , 0 )
EndIf

Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGpea160RotGer ЁAutorЁMarinaldo de Jesus   Ё Data Ё14/04/2003Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁGerar os Roteiros Padroes									Ё	
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160RotGer( lInitProc )									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGPEA160                                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁNIL                 										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gpea160RotGer( lInitProc, lProc2BarG, lGP290REPL, aRotBkp, aSRYHBKP, aSRMHBkp, aSYPHBkp, cRoteiro, lForcaComp )

Local aRotPadrao	:= {}
Local aTitleLog		:= {}
Local aRotAmbos		:= {}

Local cMsg			:= OemToAnsi( STR0035 )	//"Carregando o Roteiro Padr└o: "
Local cTimeIni		:= Time()

Local nPos			:= 0
Local nPosIni		:= 1
Local nRot			:= 0
Local nRots			:= 0

Local lGestPubl		:= IIF(ExistFunc("fUsaGFP"),fUsaGFP(),.F.)

DEFAULT lInitProc 	:= .F.
DEFAULT lGP290REPL	:= .F.
DEFAULT lForcaComp  := .F.
DEFAULT aRotBkp		:= {}
DEFAULT aSRYHBKP	:= {}
DEFAULT aSRMHBkp	:= {}
DEFAULT aSYPHBkp	:= {}
DEFAULT cRoteiro	:= ""

lManutence := If(Type("lManutence") == "U",.F.,lManutence)

If ( lInitProc )
	lInitProc := .F.
	//"Carregando Roteiros Padr■es."###"Aguarde..."
	Proc2BarGauge( { || Gpea160RotGer( lInitProc , .T. ) } , OemToAnsi( STR0034 +  STR0033 ) , NIL , NIL , .F. , .T. , .F. , .F. )
	
	If lManutence .and. !Empty(aIdErro)
		aAdd( aTitleLog, STR0145 )   //"Identificadores utilizados nos roteiros que nЦo possuem relacionamento com verbas:"
		aAdd(aIdErro,{})
		aAdd(aIdErro,STR0146 ) //"Crie as verbas antes de gerar um novo fonte de roteiro para que o novo arquivo esteja integro."
		MsAguarde( { || fMakeLog( {aIdErro} , aTitleLog , "GPEA160" , NIL , FunName() , STR0147 ) } ,  STR0147 ) //"Log de OcorrЙncias na CriaГЦo dos Roteiros"
	Else
		RotGetErr() //aPAGA LOG
	EndIf	

	Return( NIL )
EndIf

Private c__Roteiro := ""

fGeraRoteiro( NIL , @aRotPadrao , .T., Nil, Nil, lGP290REPL, @aRotBkp, @aSRYHBKP, @aSRMHBkp, @aSYPHBkp )
If ( ( nRots := Len( aRotPadrao ) ) > 0 )
	DEFAULT lProc2BarG := .F.
	If ( lProc2BarG )
		BarGauge1Set( nRots )
	EndIf
	If lGP290REPL .And. !Empty(cRoteiro)
		If (nPos := aScan( aRotPadrao, { |x| x[1] == cRoteiro } )) > 0
			nPosIni := nPos
			nRots 	:= nPos
		EndIf
	EndIf

	For nRot := nPosIni To nRots
		c__Roteiro := aRotPadrao[ nRot , 01 ]
		If ( lProc2BarG )
			IncPrcG1Time( cMsg + c__Roteiro , nRots , cTimeIni , .T. , 1 , 1 , .T. )
		EndIf
		If lManutence
			fGeraRoteiro( cFilAnt,,,@aIdErro )
		Else
			fGeraRoteiro( cFilAnt, @aRotPadrao, Nil, Nil, Nil, lGP290REPL, aRotBkp, aSRYHBKP, aSRMHBkp, aSYPHBkp, lForcaComp )
		EndIf
	Next nRot
EndIf

If lGestPubl
	fGeraRoteiro( NIL , @aRotAmbos , .T.,,.T. )
	For nRot := 1 To LEN(aRotAmbos)
		c__Roteiro := aRotAmbos[ nRot , 01 ]
		If lManutence
			fGeraRoteiro( cFilAnt,,,@aIdErro,.T. )
		Else
			fGeraRoteiro( cFilAnt , , , , .T. )
		EndIf
	Next nRot
EndIf

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGpea160BoxOpc ЁAutorЁMarinaldo de Jesus   Ё Data Ё15/04/2003Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁSequencia dos Roteiros										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё#Gpea160BoxOpc()											Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁX3_CBOX do campo RM_CHAVE                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁOpcoes para o ComboBox da Enchoice/GetDados					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gpea160BoxOpc()

Local cOpcBox := ""

cOpcBox += ( "0=" + STR0031 + ";"	)	//"Nao"	 
cOpcBox += ( "1=" + STR0032			)	//"Sim"

Return( cOpcBox )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRyPergVld		 ЁAutorЁTatiane Matias     Ё Data Ё23/11/2005Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar o conteudo do campo RY_PERGUNT                      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRyPergVld()						               						Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_VALID do campo RY_PERGUNT                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRyPergVld																	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁNIL                                        				  		Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RyPergVld(cGrupo)

Local lRyPergVld := .T.

Begin Sequence

If Empty(cGrupo)
	Break
EndIf
	
dbSelectArea("SX1")   
dbSetOrder(1)
If !dbSeek(cGrupo)
	Help( " ", 1, "REGNOIS" )
	lRyPergVld 	 := .F.
EndIf

End Sequence

Return( lRyPergVld )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o	 ЁfPergunte Ё Autor Ё Tatiane Matias        Ё Data Ё 05/12/05 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o ЁSelecionar a Pergunte                              		     Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe	 Ё fPergunte() 												  			  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso		 Ё Generico 												  				  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function fPergunte(l1Elem, lTipoRet, lExecPerg)

Local cTitulo	:="Pergunte"
Local nFor		:= 0
Local MvPar
Local MvParDef	:=""
Local MvRetor	:= ""

Private aSit:={}
l1Elem := If (l1Elem = Nil , .F. , .T.)

DEFAULT lTipoRet 	:= .T.
Default lExecPerg	:= .F.

cAlias := Alias() 					// Salva Alias Anterior

If lExecPerg
	IF lTipoRet
		MvPar:=&(Alltrim(ReadVar()))	// Carrega Nome da Variavel do Get em Questao
		mvRet:=Alltrim(ReadVar())		// Iguala Nome da Variavel ao Nome variavel de Retorno
	EndIf

	dbSelectArea("SX1")
	If dbSeek("GP")
		CursorWait()
		While !Eof() .And. substr(SX1->X1_GRUPO,1,2) == "GP"
			If SX1->X1_ORDEM == "01"
				Aadd(aSit, SX1->X1_GRUPO + " - ")
				MvParDef += SX1->X1_GRUPO
			EndIf
			dbSkip()
		Enddo  
		CursorArrow()
	EndIf
	
	IF lTipoRet
		IF f_Opcoes(@MvPar,cTitulo,aSit,MvParDef,,,l1Elem, 6)  // Chama funcao f_Opcoes
			CursorWait()
			For nFor := 1 To Len( mVpar ) Step 3
				If ( SubStr( mVpar , nFor , 3 ) # "***" )
					mvRetor += SubStr( mVpar , nFor , 3 )
				EndIf
			Next nFor
			&MvRet := Alltrim(Mvretor)
			CursorArrow()	
		EndIf	
	EndIf
EndIf
	
dbSelectArea(cAlias) // Retorna Alias

Return( IF( lTipoRet , .T. , MvParDef ) )
/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
F U N C O E S   U T I L I Z A D A S   P A R A   G E R A C A O  D O  C O D I G O
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ/*/

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGpea160Ger	  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё19/11/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁChamar Programa Gerador de Programa de Roteiros Padrao    	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGpea160Ger()	          									Ё
цддддддд.дддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico      												Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gpea160Ger()
Return( MsAguarde( { || GerGpexRot() } ) )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGerGpexRot()  ЁAutorЁ Mauricio T. TakakuraЁ Data Ё09/11/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGerar o Programa de Roteiro                                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGerGpexRot()	          									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso	   ЁGenerico      												Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GerGpexRot()

Local aLinesProg 	:= {}				// array com as linhas dos programas
Local aLinesFunc 	:= {}			 	// array com as linhas das funcoes dos itens SRM
Local aSRYMemo	 	:= {}				// campos memos da tabela SRY
Local aSRMMemo		:= {}				// campos memos da tabela SRM
Local aIniHdrSRY						// cabecalho da tabela SRY com os campos
Local aSRYVirtual						// campos virtuais de SRY
Local aIniHdrSRM						// cabecalho da tabela SRM com os campos
Local aSRMVirtual						// campos virtuais de SRM
Local aIniHdrSYP 						// Cabecalho da tabela SYP - Observacoes 
Local aSYPVirtual						// campos virtuais da tabela SYP

Local cArquivo 		:= ""			 	// nome do arquivo a ser gerado
Local cPath 		:= ""				// Path a gravar o arquivo
Local cRotNum 		:= "0000"			// numeracao do nome da funcao

Local cMsg								// mensagem de erro na geracao do arquivo PRX
Local cProg								// string a ser enviado ao arquivo PRX
Local cValueCampo						// montagem da string a ser enviado ao array
Local cNameFunc							// nome da funcao 
Local cTexto							// valor do campo do Header
Local cCodObs							// Codigo do Campo Memo
Local cFilSYP							// Filial do SYP - Codigo de Observacao

Local lSetCentury	:= __SetCentury("on")
Local lUsaGFP		:= IIF(ExistFunc("fUsaGFP"),fUsaGFP(),.F.)		//define se usa Folha PЗblica
Local lSRYModulo 	:= SRY->(ColumnPos("RY_MODULO")) > 0
Local aModRot		:= {}

Local nArq								// situacao do arquivo
Local nUsado							// campos utilizados

Local nRecno 		:= 0				// controla o numero do vetor a cada registro inserido

Local nLineMemo							// numero de linhas existentes no campo memo
Local nPosMemo							// posicao do campo memo virtual
Local nX
Local nY
Local nPosSeqFil
Local nPosMod		:= 0
Local cIdioma		:= FWRetIdiom()		//Retorna Idioma Atual

If lUsaGFP
	cArquivo 	:= ( "GPROT" + "GFP" + ".PRX" )
Else
	cArquivo 	:= ( "GPROT" + cPaisLoc + ".PRX" )
EndIf

If !lSRYModulo
	aAdd(aModRot, { '131','1'} )
	aAdd(aModRot, { '132','1'} )
	aAdd(aModRot, { 'ADI','1'} )
	aAdd(aModRot, { 'AUT','1'} )
	aAdd(aModRot, { 'BEN','3'} )
	aAdd(aModRot, { 'FER','1'} )
	aAdd(aModRot, { 'FOL','1'} )
	aAdd(aModRot, { 'INC','1'} )
	aAdd(aModRot, { 'MUV','1'} )
	aAdd(aModRot, { 'PLA','3'} )
	aAdd(aModRot, { 'PLR','1'} )
	aAdd(aModRot, { 'RES','1'} )
	aAdd(aModRot, { 'VAL','3'} )
	aAdd(aModRot, { 'VEX','1'} )
	aAdd(aModRot, { 'VRF','3'} )
	aAdd(aModRot, { 'VTR','3'} )
Endif

aIniHdrSRY	:= SRY->( GdMontaHeader( @nUsado, @aSRYVirtual, NIL, NIL, NIL, .T.,.T. ) )
aIniHdrSRM	:= SRM->( GdMontaHeader( @nUsado, @aSRMVirtual, NIL, NIL, NIL, .T.,.T. ) )
aIniHdrSYP  := SYP->( GdMontaHeader( @nUsado, @aSYPVirtual, NIL, NIL, NIL, .T.,.T. ) )
cFilSYP 	:= xFilial("SYP")

nPosSeqFil := GdFieldPos("RY_SEQFIL",aIniHdrSRY)

If nPosSeqFil > 0
	aDel(aIniHdrSRY,nPosSeqFil)
	aSize(aIniHdrSRY,Len(aIniHdrSRY)-1)
EndIf

Begin Sequence
			  								       // mostra drives   mostra hard disk retorna diretorio
	cPath := cGetFile("",OemToAnsi(STR0042),0,,.F.,GETF_LOCALFLOPPY + GETF_LOCALHARD + GETF_RETDIRECTORY,,) //"Selecione o Diretorio"
	If Empty(cPath)
		Break
	EndIf
	cArquivo := cPath + cArquivo

	If File(cArquivo)
		If !(MsgYesNo( OemToAnsi( STR0043 ),;	// "O Arquivo ja Existe !! Deseja Sobrescrer?"
 		 			   OemToAnsi( STR0014 ) ;	//"Aten┤└o"
					))
			Break
		EndIf
	EndIf

	nArq := MSFCREATE(cArquivo, 0)
	IF Ferror() # 0 .And. nArq = -1 
		cMsg := STR0044 + STR(Ferror(),3) //-- "Erro de Gravacao do Arquivo - Codigo DOS: "
		MsgInfo( cMsg, STR0014 )
		Return(.F.)
	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Cabecalho da funcao                                          Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aAdd(aLinesProg, '#INCLUDE "PROTHEUS.CH"' + CRLF + CRLF)
	aAdd(aLinesProg, "/*/" + CRLF)
	aAdd(aLinesProg, "зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©" + CRLF)
	aAdd(aLinesProg, "ЁFun┤┘o    ЁGpRot" + If(lUsaGFP,"GFP",cPaisLoc) + "      " + "ЁAutorЁ Gerado pelo sistema Ё Data Ё" + SubStr(DtoS(date()),7,2)+"/"+SubStr(DtoS(date()),5,2)+"/"+SubStr(DtoS(date()),1,4) + "Ё" + CRLF)
	aAdd(aLinesProg, "цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢" + CRLF)
	aAdd(aLinesProg, "ЁDescri┤┘o ЁRoteiros padroes                                            Ё" + CRLF)
	aAdd(aLinesProg, "цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢" + CRLF)
	aAdd(aLinesProg, "ЁSintaxe   Ё                                                            Ё" + CRLF)
	aAdd(aLinesProg, "цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢" + CRLF)
	aAdd(aLinesProg, "ЁParametrosЁ<Vide Parametros Formais>                                   Ё" + CRLF)
	aAdd(aLinesProg, "цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢" + CRLF)
	aAdd(aLinesProg, "Ё Uso      ЁGenerico                                                    Ё" + CRLF)
	aAdd(aLinesProg, "юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/" + CRLF)
	aAdd(aLinesProg, "Function GpRot" + If(lUsaGFP,"GFP",cPaisLoc) + "(aRotSRY, aFatherHeader, aChildHeader, aMemoHeader)" + CRLF)
	aAdd(aLinesProg, 'Local lRet		:= .T.' + CRLF)
	aAdd(aLinesProg, "Local aItensSRY	:= {}" + CRLF) 
	aAdd(aLinesProg, "Local aSYPHeader	:= {}" + CRLF)
	aAdd(aLinesProg, "Local aSRYHeader	:= {}" + CRLF)	
	aAdd(aLinesProg, "Local aSRMHeader	:= {}" + CRLF + CRLF)
	
	aAdd(aLinesProg, "/*/" + CRLF)
	aAdd(aLinesProg, "здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©" + CRLF)
	aAdd(aLinesProg, "Ё Cabecalho de SRY e SRM gerado pelo Roteiro padrao            Ё" + CRLF)
	aAdd(aLinesProg, "юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/" + CRLF)
	cMyCampo := ""
	For nX := 1 To Len(aIniHdrSRY)
		cProg := ""
		For nY := 1 To Len(aIniHdrSRY[nX])
		
			If ValType(aIniHdrSRY[nX,nY])=="C" .And. SubStr(aIniHdrSRY[nX,nY],1,3) == "RY_"
				cMyCampo := Alltrim(aIniHdrSRY[nX,nY])
			EndIf
			If !Empty(cMyCampo) .And. ValType(aIniHdrSRY[nX,nY])=="C" .And. Len(aIniHdrSRY[nX,nY]) > 130
				
				aSvAreaSX3 := SX3->(GetArea())
				SX3->(DbSetOrder(2))
				SX3->(DbSeek(cMyCampo))
				
				cTexto := Iif( cIdioma =="pt-br", Alltrim(SX3->X3_CBOX), Iif( cIdioma =="es", Alltrim(SX3->X3_CBOXSPA), Alltrim(SX3->X3_CBOXENG) ))
				
				RestArea(aSvAreaSX3)
			Else
				cTexto := If(ValType(aIniHdrSRY[nX,nY])=="N", AllTrim(Str(aIniHdrSRY[nX,nY])),;
							   	If(ValType(aIniHdrSRY[nX,nY])=="L", Transform(aIniHdrSRY[nX, nY],"@!"),;
							   	   aIniHdrSRY[nX, nY]))
			EndIf
			cTexto := StrTran(cTexto, "'", '"')
			cProg += "'" + cTexto + "'"
			If nY < Len(aIniHdrSRY[nX])
				cProg += ","
			EndIf
		Next nY

		If !Empty(cProg)
			aAdd(aLinesProg, "aAdd(aSRYHeader, " + '{ ' + cProg + ' })' + CRLF)
		EndIf
	Next nX
	
	//Quando o campo RY_MODULO nЦo existe na base, a rotina 'ForГa' a geraГЦo do campo e conteudo nas rotinas de geracao de roteiro
	If !lSRYModulo .And. !Empty(cProg) .And. cPaisLoc == "BRA" .And. cModulo == "GPE"
		cProg := "'Modulo','RY_MODULO','9','1','0','Pertence("+'" 123")'+"'"+",'──────────────═','C','      ','R','1=GPE;2=GFP;3=Ambos                                                                                                             ','','','A','','','.F.' "
		aAdd(aLinesProg, "aAdd(aSRYHeader, " + '{ ' + cProg + ' })' + CRLF)     
	Endif   
	
	aAdd(aLinesProg, CRLF)
         
	For nX := 1 To Len(aIniHdrSRM)
		cProg := ""
		For nY := 1 To Len(aIniHdrSRM[nX])
			cTexto := If(ValType(aIniHdrSRM[nX,nY])=="N", AllTrim(Str(aIniHdrSRM[nX,nY])),;
						   	If(ValType(aIniHdrSRM[nX,nY])=="L", Transform(aIniHdrSRM[nX, nY],"@!"),;
						   	   aIniHdrSRM[nX, nY]))
			cTexto := StrTran(cTexto, "'", '"')
			cProg += "'" + cTexto + "'"
			If nY < Len(aIniHdrSRM[nX])
				cProg += ","
			EndIf
		Next nY
		If !Empty(cProg)
			aAdd(aLinesProg, "aAdd(aSRMHeader, " + '{ ' + cProg + ' })' + CRLF)
		EndIf
	Next nX
	aAdd(aLinesProg, CRLF)

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Cabecalho das Observacoes                                    Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	For nX := 1 To Len(aIniHdrSYP)
		cProg := ""
		For nY := 1 To Len(aIniHdrSYP[nX])
			cTexto := If(ValType(aIniHdrSYP[nX,nY])=="N", AllTrim(Str(aIniHdrSYP[nX,nY])),;
						   	If(ValType(aIniHdrSYP[nX,nY])=="L", Transform(aIniHdrSYP[nX, nY],"@!"),;
						   	   aIniHdrSYP[nX, nY]))
			cTexto := StrTran(cTexto, "'", '"')
			cProg += "'" + cTexto + "'"
			If nY < Len(aIniHdrSYP[nX])
				cProg += ","
			EndIf
		Next nY
		If !Empty(cProg)
			aAdd(aLinesProg, "aAdd(aSYPHeader, " + '{ ' + cProg + ' })' + CRLF)
		EndIf
	Next nX
	aAdd(aLinesProg, CRLF )

	aAdd(aLinesProg, "/*/" + CRLF)
	aAdd(aLinesProg, "зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©" + CRLF)
	aAdd(aLinesProg, "Ё Validar a Estrutura das Tabela SRY e SRM com a do Cliente     Ё" + CRLF)
	aAdd(aLinesProg, "юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/" + CRLF)
	aAdd(aLinesProg, 'lRet := fNewOldSx3(aSRYHeader, aSRMHeader, "SRY", "SRM",.F.)' + CRLF)
	aAdd(aLinesProg, 'lRet := fNewOldSx3(aSYPHeader, NIL, "SYP")' + CRLF + CRLF)

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Itens do Roteiro                                             Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	SRY->(dbGoTop())
	SRY->( dbSetOrder( RetOrder( "SRY" , "RY_FILIAL+RY_CALCULO" ) ) )
	While !SRY->(Eof())

		DbSelectArea("SRY")
		If SRY->RY_Origem != "1" .OR. (lUsaGFP .AND. lSRYModulo .AND. SRY->RY_MODULO <> "2") 
		   SRY->(dbSkip())
		   Loop
		EndIf
		
		nRecno++
		
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Adiciona o cabecalho - SRY                                   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cProg := "aAdd(aItensSRY, { "

		For nX := 1 To Len(aIniHdrSRY)
			cValueCampo := ""

			// campo memo normal //
			If aIniHdrSRY[nX,8] == "M" .and. (aScan(aSRYVirtual, aIniHdrSRY[nX,2]) == 0)
				nLineMemo := MlCount(aIniHdrSRY[nX,2], 80)

				For nY := 1 To nLineMemo
					cValueCampo += AllTrim(MemoLine(aIniHdrSRY[nX,2], 80, nY))
					If nY < nLineMemo
						cValueCampo += ' '
					EndIf
				Next nY

			// campo memo gravado em SYP - Virtual //
			ElseIf aIniHdrSRY[nX,8] == "M" .and. (aScan(aSRYVirtual, aIniHdrSRY[nX,2]) > 0)
				If ((nPosMemo := Ascan(aSRYMemo, { |x|  Upper(x[2]) == aIniHdrSRY[nX,2] })) > 0)
					cValueCampo += MSMM(&(SRY->(aSRYMemo[nPosMemo,1])),80)
					cValueCampo := StrTran(cValueCampo, CRLF, "\13\10")
				EndIf				
			ElseIF ( aScan( aSRYVirtual , aIniHdrSRY[nX,2]) > 0 )
				Loop
			ElseIf aIniHdrSRY[nX,8] == "N"
				cValueCampo += AllTrim(Str(&(aIniHdrSRY[nX,2])))
			ElseIf aIniHdrSRY[nX,8] == "D"
				cValueCampo += 'Ctod("' + DtoC(&(aIniHdrSRY[nX,2])) + '")'
			ElseIf aIniHdrSRY[nX,8] == "L"
				If &(aIniHdrSRY[nX,2])
					cValueCampo += ".T."
				Else
					cValueCampo += ".F."
				EndIf
			ElseIf "FILIAL" $ aIniHdrSRY[nX,2]
				cValueCampo += ""
			Else
				cValueCampo += AllTrim(&(aIniHdrSRY[nX,2]))
			EndIf
			cValueCampo := StrTran(cValueCampo, "'", '"')

			If (aIniHdrSRY[nX,8] != "N") .and. (aIniHdrSRY[nX,8] != "D") .and. (aIniHdrSRY[nX,8] != "L")
				cValueCampo := "'" + cValueCampo
				cValueCampo += "'"
			EndIf
			cProg += cValueCampo
			If nX < Len(aIniHdrSRY)
				cProg += ","
			EndIf
		Next nX
        
		If !lSRYModulo .And. !Empty(cProg) .And. cPaisLoc == "BRA" .And. cModulo == "GPE"
			nPosMod := Ascan(aModRot,{|x| Alltrim(x[1])== SRY->RY_CALCULO })
			If nPosMod > 0
				cProg += ",'" + aModRot[nPosMod,2] + "'"
			Endif	
		Endif
		
		cProg += "} )"
		aAdd(aLinesProg, cProg + CRLF)
		
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Adiciona os Itens do Roteiro - Tabela SRM, por funcao        Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		DbSelectArea("SRM")
		SRM->( dbSetOrder( RetOrder( "SRM", "RM_FILIAL+RM_CALCULO+RM_SEQ" ) ) )
        DbSeek(SRY->RY_FILIAL + SRY->RY_CALCULO)
		If SRM->(!Eof())
			cRotNum := Soma1( cRotNum )
			cNameFunc := "Rot" + If(lUsaGFP,"GFP",cPaisLoc) + cRotNum
			aAdd(aLinesFunc, "/*/" + CRLF)
			aAdd(aLinesFunc, "зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©" + CRLF)
			aAdd(aLinesFunc, "ЁFun┤┘o    Ё"+cNameFunc + "    ЁAutorЁ Gerado pelo sistema Ё Data Ё" + "          " + "Ё" + CRLF)
			aAdd(aLinesFunc, "юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/" + CRLF)
		
			cNameFunc := "Function Rot" + If(lUsaGFP,"GFP",cPaisLoc) + cRotNum + "(cROTEIRO , c__Roteiro , aItensSRM, aItensSYP)"
			aAdd(aLinesFunc, cNameFunc + CRLF)
			aAdd(aLinesFunc, "If c__Roteiro == cRoteiro " + CRLF)

		EndIf
		
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Codigo do campo de Observacoes                               Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cCodObs := SRY->RY_CODOBS

        While !(SRM->(Eof())) .and. SRM->RM_FILIAL == SRY->RY_FILIAL .and. SRM->RM_CALCULO == SRY->RY_CALCULO
        
        	If Mod(Val(SRM->(RM_SEQ)), 10) != 0
        		SRM->(dbSkip())
        		Loop
        	EndIf
        	
	        cProg := "	aAdd(aItensSRM, { "
			For nX := 1 To Len(aIniHdrSRM)
				cValueCampo := ""

				// campos memo normal //
				If aIniHdrSRM[nX,8] == "M" .and. (aScan(aSRMVirtual, aIniHdrSRM[nX,2]) == 0)
					nLineMemo := MlCount(aIniHdrSRM[nX,2], 254)
					For nY := 1 To nLineMemo
						cValueCampo += AllTrim(MemoLine(aIniHdrSRM[nX,2], 254, nY))
						If nY < nLineMemo
							cValueCampo += ' '
						EndIf
					Next nY
				
				// campo memo virtual - gravacao realizada em SYP //
				ElseIf aIniHdrSRM[nX,8] == "M" .and. (aScan(aSRMVirtual, aIniHdrSRM[nX,2]) > 0)
					If ((nPosMemo := Ascan(aSRMMemo, { |x|  Upper(x[2]) == aIniHdrSRM[nX,2] })) > 0)
						cValueCampo += MSMM(&(SRM->(aSRMMemo[nPosMemo,1])),80)
						cValueCampo := StrTran(cValueCampo, CRLF, "\13\10")
					EndIf
				ElseIF ( aScan(aSRMVirtual, aIniHdrSRM[nX,2]) > 0 )
					Loop
				ElseIf aIniHdrSRM[nX,8] == "N"
					cValueCampo += AllTrim(Str(&(aIniHdrSRM[nX,2])))
				ElseIf aIniHdrSRM[nX,8] == "D"
					cValueCampo += 'Ctod("' + DtoC(&(aIniHdrSRM[nX,2])) + '")'
				ElseIf aIniHdrSRM[nX,8] == "L"
					If &(aIniHdrSRM[nX,2])
						cValueCampo += ".T."
					Else
						cValueCampo += ".F."
					EndIf
				ElseIf "FILIAL" $ aIniHdrSRM[nX,2]
					cValueCampo += ""
				ElseIf "VERBA" $ aIniHdrSRM[nX,2]
					If Empty(&(aIniHdrSRM[nX,2]))
						cValueCampo += &(aIniHdrSRM[nX,2])
					Else						
						cValueCampo += PosAlias( "SRV" , &(aIniHdrSRM[nX,2]) , xFilial("SRV") , "RV_CODFOL" , 1 , .T. )
					EndIf
				Else
					cValueCampo += &(aIniHdrSRM[nX,2])
				EndIf
				cValueCampo := StrTran(cValueCampo, "'", '"')

				If (aIniHdrSRM[nX,8] != "N") .and. (aIniHdrSRM[nX,8] != "D") .and. (aIniHdrSRM[nX,8] != "L")
					cValueCampo := "'" + cValueCampo
					cValueCampo += "'"
				EndIf
	
				cProg += cValueCampo
				If nX < Len(aIniHdrSRM)
					cProg += ","
				EndIf
			Next nX
			cProg += "} )"
			aAdd(aLinesFunc, cProg + CRLF)
			SRM->(dbSkip())
	    Enddo
		aAdd(aLinesFunc, "" + CRLF)
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Adiciona os Itens do campo de Observacoes                    Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		If !Empty(SRY->(RY_CODOBS))
			DbSelectArea("SYP")  
			DbSetOrder( 1 ) // YP_FILIAL+YP_CHAVE+YP_SEQ
			DbSeek(xFilial( "SYP")+SRY->(RY_CODOBS), .F.)
			Do while !Eof() .and. SYP->(YP_FILIAL+YP_CHAVE) == (xFilial( "SYP")+SRY->(RY_CODOBS))
				cProg := "	aAdd(aItensSYP, { "
				For nX := 1 To Len(aIniHdrSYP)
					cValueCampo := ""
					If ( aScan( aSYPVirtual , aIniHdrSYP[nX,2]) > 0 )
						Loop
					ElseIf aIniHdrSYP[nX,8] == "N"
						cValueCampo += AllTrim(Str(&(aIniHdrSYP[nX,2])))
					ElseIf aIniHdrSYP[nX,8] == "D"
						cValueCampo += 'Ctod("' + DtoC(&(aIniHdrSYP[nX,2])) + '")'
					ElseIf aIniHdrSYP[nX,8] == "L"
						If &(aIniHdrSYP[nX,2])
							cValueCampo += ".T."
						Else
							cValueCampo += ".F."
						EndIf
					ElseIf "FILIAL" $ aIniHdrSYP[nX,2]
						cValueCampo += ""
					Else
						cValueCampo += &(aIniHdrSYP[nX,2])
					EndIf

					cValueCampo := StrTran(cValueCampo, "'", '"')

					If (aIniHdrSYP[nX,8] != "N") .and. (aIniHdrSYP[nX,8] != "D") .and. (aIniHdrSYP[nX,8] != "L")
						cValueCampo := "'" + cValueCampo
						cValueCampo += "'"
					EndIf
	
					cProg += cValueCampo
					If nX < Len(aIniHdrSYP)
						cProg += ","
					EndIf
				Next nX
				cProg += "} )"
				aAdd(aLinesFunc, cProg + CRLF)
				SYP->( DbSkip() )
			EndDo
			aAdd(aLinesFunc, "" + CRLF)
		EndIf
		
		aAdd(aLinesFunc, "EndIf" + CRLF + CRLF)
		aAdd(aLinesFunc, "Return( Nil )" + CRLF + CRLF)

		DbSelectArea( "SRY" )
		SRY->( dbSkip() )
	Enddo

	aAdd(aLinesProg, CRLF)
	aAdd(aLinesProg, "aRotSRY := aClone(aItensSRY) " + CRLF)
	aAdd(aLinesProg, "aFatherHeader := aClone(aSRYHeader) " + CRLF)
	aAdd(aLinesProg, "aChildHeader := aClone(aSRMHeader) " + CRLF)
	aAdd(aLinesProg, "aMemoHeader := aClone(aSYPHeader) " + CRLF + CRLF)
	
	aAdd(aLinesProg, 'Return ( lRet )' + CRLF + CRLF)

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Transferir as linhas para dentro do programa                 Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    For nX := 1 To Len(aLinesProg)
	    Fwrite( nArq, aLinesProg[nX] )
	Next nX
	
    For nX := 1 To Len(aLinesFunc)
	    Fwrite( nArq, aLinesFunc[nX] )
	Next nX

	FClose(nArq)

	MsgInfo( STR0045 + cArquivo + CRLF + STR0046 ) // "O Programa " #### "para Cadastro de Roteiros Padroes foi Gerado com Sucesso"

End Sequence 

If !( lSetCentury )
	__SetCentury("off")
EndIf

Return( NIL )

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfFindCF	  Ё Autor Ё Igor Franzoi     	Ё Data Ё16/09/2009Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o ЁFuncao para pesquisa de Verba e Formula			  		  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё GPEA160 													  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Static Function fFindCF( aColsFind, aHeaderFind )

Local lPesq

Local nOpcAux
Local nOpcRadio

Local cFormula

Local oRadio
Local oVerba
Local oFormula
Local oDlg
Local oGroup
Local oFont

Local bFind
Local aRetCoords

//Essa variaveis sЦo utilizadas na pesquisa F3 do campo verba, 
//para mostrar o conteЗdo de forma filtrada
Private cCodProcesso
Private cCodRoteiro
Private cVerba				

Private aIndexSRV			:= {}

/*
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Monta as Dimensoes dos Objetos         					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
aRetCoords := RetCoords(1,2,10,35)
aButtons   := {}

If ( Len(aColsFind) > 0 )

	lPesq		:= .F.
	
	nOpcRadio := 1
	nOpcAux   := nOpcRadio
	nOpcRadio := 0
	
	cVerba				:= Space( GetSx3Cache( "RV_COD" 			, "X3_TAMANHO" ) )
	cFormula			:= Space( GetSx3Cache( "RC2_CODIGO"	, "X3_TAMANHO" ) )
	cCodProcesso	:= M->RGA_PROCES
	cCodRoteiro		:= M->RGA_CALCUL
	
	bFind		:= { || Nil }
	
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0002 ) FROM 0,0 TO 170,430 OF oMainWnd PIXEL //Pesquisar
	
	@ aRetCoords[1,1] , aRetCoords[1,2] GROUP oGroup TO aRetCoords[1,1]+50,135 LABEL OemToAnsi(STR0100) OF oDlg PIXEL //"Selecione a opГЦo de Pesquisa:"
	oGroup:oFont:=oFont
	
	@ aRetCoords[1,1]+10 , aRetCoords[1,2]+10 RADIO oRadio VAR nOpcAux ITEMS 	OemToAnsi(STR0101), OemToAnsi(STR0102),OemToAnsi(STR0101) +" + "+OemToAnsi(STR0102) ;
		SIZE 115,010 OF oDlg PIXEL

	bSet15		:= { ||nOpcRadio := nOpcAux, lPesq := .T., oDlg:End() }
	bSet24		:= { ||oDlg:End() }

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15 , bSet24 , Nil , aButtons ) CENTERED

	If !( nOpcRadio == 0 )
	
		bFind := { || If ( fPesqCF( nOpcRadio, cVerba, cFormula, aColsFind, aHeaderFind ), oDlg:End(), .F. ) }
	
		DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD

		DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0002 ) FROM 0,0 TO 190,430 OF oMainWnd PIXEL //Pesquisar
		
		If ( nOpcRadio == 1 .or. nOpcRadio == 3 )
		 	@ aRetCoords[1,1] , aRetCoords[1,2] GROUP oGroup TO aRetCoords[1,1] + 30,110 LABEL OemToAnsi(STR0101) OF oDlg PIXEL  //Verba
		 	@ aRetCoords[1,1]+10 , aRetCoords[1,2]+10 MsGet oVerba Var cVerba Picture GetSx3Cache("RV_COD", "X3_PICTURE") F3 "SRV-RM" SIZE 060,010 OF oDlg PIXEL	
		EndIf
		If ( nOpcRadio == 2 .or. nOpcRadio == 3 )
			If ( nOpcRadio == 2 )
				@ aRetCoords[1,1]    , aRetCoords[1,2] GROUP oGroup TO aRetCoords[1,1]+30,110 LABEL OemToAnsi(STR0102) OF oDlg PIXEL  //Formula
				@ aRetCoords[1,1]+10 , aRetCoords[1,2]+10 MsGet oFormula Var cFormula Picture GetSx3Cache("RC2_CODIGO", "X3_PICTURE") F3 "RC201" SIZE 060,010 OF oDlg PIXEL	
			Else
				@ aRetCoords[2,1]    , aRetCoords[2,2] GROUP oGroup TO aRetCoords[2,1]+30,110 LABEL OemToAnsi(STR0102) OF oDlg PIXEL  //Formula
				@ aRetCoords[2,1]+10 , aRetCoords[2,2]+10 MsGet oFormula Var cFormula Picture GetSx3Cache("RC2_CODIGO", "X3_PICTURE") F3 "RC201" SIZE 060,010 OF oDlg PIXEL	
			EndIf
		EndIf

		bSet15		:= { ||oDlg:End() , Eval(bFind) }
		bSet24		:= { ||oDlg:End() }

		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15 , bSet24 , Nil , aButtons ) CENTERED
	
	EndIf

EndIf

Return( NIL )

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfPesqCFЁ Autor Ё Igor Franzoi     Ё Data Ё 16/09/2009 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o ЁValida e localiza as informaГУes na GetDados			Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё GPEA160 Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Static Function fPesqCF( nOpcRadio, cVerba, cFormula, aColsFind, aHeaderFind )

Local lRet := .T.

Local cMsgAll	:= ""

Local nPosVer	:= GdFieldPos( "RM_VERBA"		, aHeaderFind )
Local nPosFor	:= GdFieldPos( "RM_CODFOR"	, aHeaderFind )
Local nPosSeq	:= GdFieldPos( "RM_SEQ"			, aHeaderFind )

Local nCont

//Valida as informaГУes de verba e formula conforme a seleГЦo
//nOpcRadio = 1 Verba
//nOpcRadio = 2 Formula
//nOpcRadio = 3 Verba + Formula
If ( nOpcRadio == 1 )
	If Empty(cVerba)
		lRet := .F.
		cMsgAll := OemToAnsi(STR0103) + CRLF + OemToAnsi(STR0101)
		MsgAlert( cMsgAll, OemToAnsi(STR0014) ) // "O conteЗdo nЦo pode ser branco!" - AtenГЦo
	EndIf
ElseIf ( nOpcRadio == 2 )
	If Empty(cFormula)
		lRet := .F.
		cMsgAll := OemToAnsi(STR0103) + CRLF + OemToAnsi(STR0102)
		MsgAlert( cMsgAll, OemToAnsi(STR0014) )// "O conteЗdo nЦo pode ser branco!" - AtenГЦo		
	EndIf
ElseIf ( nOpcRadio == 3 )
	If Empty(cVerba) .or. Empty(cFormula)
		lRet := .F.
		cMsgAll := OemToAnsi(STR0103) + CRLF + OemToAnsi(STR0101) + CRLF + OemToAnsi(STR0102)
		MsgAlert( cMsgAll, OemToAnsi(STR0014) )	// "O conteЗdo nЦo pode ser branco!" - AtenГЦo
	EndIf
EndIf

If ( lRet )
	
	cMsgAll := ""

	Do Case
		Case ( nOpcRadio == 1 )
			For nCont := 1 To Len(aColsFind)
				If !(aColsFind[ nCont, Len(aColsFind[nCont]) ])
					If ( AllTrim(aColsFind[ nCont, nPosVer ]) == AllTrim(cVerba) )
						cMsgAll += CRLF + aColsFind[ nCont, nPosSeq ]
					EndIf
				EndIf
			Next
		Case ( nOpcRadio == 2 )
			For nCont := 1 To Len(aColsFind)
				If !(aColsFind[ nCont, Len(aColsFind[nCont]) ])			
					If ( AllTrim(aColsFind[ nCont, nPosFor ]) == AllTrim(cFormula) )
						cMsgAll += CRLF + aColsFind[ nCont, nPosSeq ]
					EndIf
				EndIf
			Next
		Case ( nOpcRadio == 3 )
			For nCont := 1 To Len(aColsFind)
				If !(aColsFind[ nCont, Len(aColsFind[nCont]) ])
					If ( AllTrim(aColsFind[ nCont, nPosVer ]) == AllTrim(cVerba) ) .and. ( AllTrim(aColsFind[ nCont, nPosFor ]) == AllTrim(cFormula) )
						cMsgAll += CRLF + aColsFind[ nCont, nPosSeq ]
					EndIf						
				EndIf
			Next		
	EndCase		

	If !Empty(cMsgAll)
		MsgAlert( OemToAnsi(STR0104) + cMsgAll, OemToAnsi(STR0014) ) // "JА existe o conteЗdo na(s) sequЙncia(s):" - AtenГЦo
	Else
		MsgAlert( OemToAnsi(STR0105), OemToAnsi(STR0014) ) // "Resultado nЦo localizado!" - AtenГЦo
	EndIf

EndIf

Return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁG160RGALOK  Ё Autor Ё Mohanad Odeh     	Ё Data Ё20/02/2013Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o ЁLINOK PARA GET DA RGA  	                                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё GPEA160 													  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function G160RGALOK()
Local nPosRec		:= Len(oRGAGet:aHeader)+1 // POSICAO DO AHEADER EM QUE INDICA SE ESTA DELETADO
Local aRGACols	:= aClone(oRGAGet:ACOLS)
Local aCposKey	:= {}
Local aCposObrig	:= {}

aCposKey	:= {"RGA_PROCES", "RGA_MODULO"}
aCposObrig	:= {"RGA_PROCES", "RGA_PDPERI", "RGA_DTINIC"}
// VERIFICAR SE JA EXISTE UM REGISTRO QUE TENHA A CHAVE FORMADA PELA MESMA 
// PROCESSO + MODULO
If !aRGACols[oRGAGet:nAt, nPosRec]
	If !(GDVALIDGET(aCposKey, 4, aCposObrig,.T.,oRGAGet:aHeader, aRGACols, oRGAGet:nat))
		Return .F.
	EndIf
EndIf

Return .T.
/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁG160RGATOK  Ё Autor Ё Mohanad Odeh     	Ё Data Ё20/02/2013Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o ЁTUDOOK PARA GET DA RGA   		                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё GPEA160 													  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function G160RGATOK()
Return If(nAba == 2, G160RGALOK(), .T.) //SO VALIDA SE ESTIVER NA ABA DE PERIODO PADRAO 

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁGPCompAll  Ё Autor Ё Ricardo Duarte 		Ё Data Ё21/11/2016Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o ЁValidar e Recompilar todos Roteiros                     	Ё╠╠ 
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё GPEA160 													  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function GPCallCmpAll(cModAlias,lLog,lRecFrm,lForca,lEmptyRpo, aFilExec)
DEFAULT cModAlias := "SRY"
DEFAULT lLog	  := .T.
DEFAULT lRecFrm   := .T.
DEFAULT lForca    := .F.
DEFAULT lEmptyRpo := .F.
DEFAULT aFilExec  := {}

If lFirst
	If !IsBlind()
		MsAguarde( { || lRetRot :=  GPCompAll(cModAlias,0,0,lLog,lRecFrm,lForca,lEmptyRpo, aFilExec) } , OemToAnsi( STR0157 ) )	//"Validando a CompilaГЦo de Roteiros e Formulas..."
	Else
		lRetRot :=  GPCompAll(cModAlias,0,0,lLog,lRecFrm,lForca)
	EndIf
	lFirst := .F.
EndIf

Return

Function f160RstSt()
	lFirst := .T.
Return

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁGPCompAll  Ё Autor Ё Ricardo Duarte 		Ё Data Ё21/11/2016Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o ЁValidar e Recompilar todos Roteiros                     	Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё GPEA160 													  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function GPCompAll( cAlias , nReg , nOpc, lLog,lRecFrm, lForca, lEmptyRpo, aFilExec)
Local aArea 	  := GetArea()
Local aLog		  := {}
Local aRotComp	  := {}
Local cFunct	  := ""
Local cPrg		  := ""
Local cLogErro	  := ""
Local cFilAux	  := ""
Local nLoop	      := 0
Local oRpoForm
Local lRet		  := .T.
Local lErroComp   := .F.
Local lSkipRot    := .T.
Local lGP290REPL  := IsInCallStack("U_GP290REPL")
Local lGPEM020    := IsInCallStack("GPEM020PROCESSA")
Local lRpoFil	  := SuperGetMv('MV_RPOFIL',, .F.)
Local aChaveSRY   := {}

Static lFilRPO

DEFAULT lLog	  := .T.
DEFAULT lRecFrm   := .T.
DEFAULT lForca    := .F.
DEFAULT lEmptyRpo := .F.
DEFAULT aFilExec  := {}
DEFAULT lFilRPO   := SuperGetMv('MV_RPOFIL',, .F.) .and. xFilial("SRY") <> xFilial("RC2") 

IF !( RpoFormInit() )
	aAdd( aLog, OemToAnsi(STR0156) ) //"Nao Foi Possivel Inicializar o Repositorio para Carga dos Roteiros."
Else
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica se Deve Adicionar as Formulas Padroes                         Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If lRecFrm
		Gpea290FrmInit(lRecFrm)
	EndIf
	If !lFilRPO .or. Empty(aFilExec)
		IF !GpeGerFrm(lForca)
			Break
		EndIF
	Else
		cFilAux := cFilAnt
		For nLoop := 1 to Len(aFilExec)
			If SRA->(DbSeek(AllTrim(aFilExec[nLoop]))) //Posiciona no primeiro funcionАrio para obter a filial completa
				cFilAnt := SRA->RA_FILIAL
			EndIf
			Gpea290FrmInit( .T. )
			IF !GpeGerFrm(lForca)
				Break
			EndIF
		Next nLoop
		cFilAnt := cFilAux
	EndIf

	// Efetua uma simulaГЦo de compilaГЦo para verificar se o RPO de formulas estА em uso por outro processo
	If !lEmptyRpo .And. !Empty(aFilExec)
		Compile( @oRpoForm , {""} , .T. , @aLog, .T. )
		If !Empty(aLog)
			lErroComp := .T.
			aLog := {}
		EndIf	
		RpoFormInit( NIL, .T. )
	EndIf
	
	DbSelectArea( "SRY" )
	SRY->( DbGoTop() )
	If lRpoFil .And. ( lGP290REPL .or. ( lEmptyRpo .and. IsInCallStack("EXECROT") ) )
		SRY->( dbSeek(FWxFilial("SRY") ) )
	EndIf
	While !Eof() .And. Iif(lRpoFil, SRY->RY_FILIAL == FWxFilial("SRY"), .T.)
		If lRpoFil .And. lGPEM020 .And. !Empty(aFilExec) .And. SRY->RY_FILIAL != FWxFilial("SRY", aFilExec[1])
			SRY->( DbSkip() )
			Loop
		EndIf
		cFunct	:= ( SRY->( RotGetFunc( RY_FILIAL , RY_CALCULO, RY_ORIGEM ) ) )
		cPrg 	:= cFunct + ".PRG"
		cPrg 	:= Lower( GetRpoForm( .F. , .T. ) + cPrg )
		lSkipRot := .T.
		
		If lRecFrm .OR. (( SRY->RY_RECOMP == "1" ) .Or. !FindFunction(cFunct))

			// Caso tenha ocorrido erro na simulaГЦo de compilaГЦo no RPO de formulas e o roteiro pendente de compilaГЦo nЦo seja da empresa/filial que estА sendo processada, 
			// nЦo tenta realizar a compilaГЦo para que o processo nЦo seja interrompido.
			If !lEmptyRpo .And. lErroComp .And. SRY->RY_RECOMP == "1"
				For  nLoop := 1 to Len(aFilExec)
					If SRY->RY_FILIAL == FWxFilial("SRY", aFilExec[nLoop])
						lSkipRot := .F.
					EndIf		
				Next
				If lSkipRot
					SRY->( DbSkip() )
					Loop
				EndIf				
			EndIf

			SRY->( GetFunRot( RY_FILIAL , RY_CALCULO , .T. , NIL , .F. , @oRpoForm, ,lEmptyRpo, @aRotComp) )
			aAdd(aChaveSRY, SRY->(RY_FILIAL+RY_CALCULO))
			If !lEmptyRpo
				lCompileOk := !ErrorInRot()
				If !( lCompileOk )
					If Empty( aLog )
						aAdd( aLog, STR0160 ) // "Falha na CompilaГЦo dos seguintes Roteiros: "
					EndIf
					aAdd( aLog, SRY->( RY_FILIAL + " - " + RY_CALCULO + " - " + RY_DESC ) )
				EndIf
			EndIf
		EndIf
		
		SRY->( DbSkip() )
	EndDo
	If lEmptyRpo .and. !Empty(aRotComp)
		Compile( @oRpoForm , @aRotComp , .T. , @aLog )
		lCompileOk := !ErrorInRot()
		If !lCompileOk
			For nLoop := 1 to Len(aRotComp)
				If !aRotComp[ nLoop , COMPILE_OK ] //Falha na compilaГЦo
					cLogErro := ""
					cLogErro += "Error Prg: " + aRotComp[nLoop,COMPILE_PRG]
					cLogErro += " - Error Str: " + aRotComp[nLoop, COMPILE_ERROR_STR]
		   			cLogErro += " - Error Col: " + aRotComp[nLoop, COMPILE_ERROR_COL]
		   			cLogErro += " - Error Line: " + aRotComp[nLoop, COMPILE_ERROR_LINE]
					aAdd(aLog, cLogErro)
				EndIf
			Next
		ElseIf Empty(aLog)
			For nLoop := 1 to Len(aChaveSRY)
				If SRY->(DbSeek(aChaveSRY[nLoop]))
					SRY->( RecLock( "SRY" , .F. ) )
					SRY->RY_RECOMP := "2"		//Compilado
					SRY->( MsUnLock() )					
				EndIf
			Next nLoop
		EndIf
	EndIf
	If !IsInCallStack("EXECROT")
		RpoFormInit( NIL, .T. )
	EndIf
EndIf
If lLog .and. Len(aLog) > 1
	cLogErro 	:= ""
	For nLoop := 1 To Len( aLog )
		cLogErro += aLog[nLoop]  + CHR(13)
	Next nLoop
	lRet := .F.
	If !IsBlind()
		MsgInfo( cLogErro, STR0014 )	// Log ### "Atencao"
	EndIf
EndIf	

RestArea( aArea )

Return( lRet )
