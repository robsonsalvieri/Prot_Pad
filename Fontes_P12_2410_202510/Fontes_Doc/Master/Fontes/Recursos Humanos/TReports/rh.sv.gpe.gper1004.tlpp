#Include "TOTVS.FRAMEWORK.TREPORTS.INTEGRATEDPROVIDER.th"
#Include "TLPP-CORE.th"
#Include "TLPP-REST.th"
#Include "rh.sv.gpe.gper1004.ch"

namespace totvs.protheus.rh.treportsintegratedprovider

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAGPE", tables="SRO,SRA", name="Relatório Reajuste de Tarefas", country="ALL", initialRelease="12.1.2410")
class GPER1004TReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider
    public method new() as object
    public method getData() as object
    public method getSchema() as object

    @Get("/api/rh/smartview/v1/options/GPER1004/:param")
    public method getComboBox() as Variant
endclass

method new() class GPER1004TReportsBusinessObject
    _Super:new()
    self:appendArea(STR0001)
    self:setDisplayName(STR0002)
    self:setDescription(STR0003)
return self

method getData(nPage as numeric, oFilter as object) as object class GPER1004TReportsBusinessObject
    Local cFilExec              As Character
    Local cEmpExec              As Character
    Local cTaskCodeFrom         As Character
    Local cTaskCodeTo           As Character
    Local nRoundingType         As Numeric
    Local nRoundingValue        As Numeric
    Local nUpdateType           As Numeric
    Local nReportType           As Numeric
    Local cBranchCodeFrom       As Character
    Local cBranchCodeTo         As Character
    Local cCostCenterCodeFrom   As Character
    Local cCostCenterCodeTo     As Character
    Local cEmployeeCodeFrom     As Character
    Local cEmployeeCodeTo       As Character
    Local cFunctionCodeFrom     As Character
    Local cFunctionCodeTo       As Character
    Local cCategory             As Character
    Local dAdjustmentDate       As Date
    Local nUpdateSubsequent     As Numeric
    Local cIncreaseType         As Character
    Local aSalaryRanges         As Array
    Local jParams               As JSON
    Local aTabS070              As Array
    Local aColsTar              As Array
    Local aTarReaj              As Array
    Local aFaixas               As Array
    Local nI                    As Numeric
    Local cTip                  As Character
    Local nTamS070              As Numeric
    Local nCnt                  As Numeric
    Local nPosTab               As Numeric
    Local nPos                  As Numeric
    Local nTarAnti              As Numeric
    Local nTarNova              As Numeric
    Local nTarPerc              As Numeric
    Local nValArred             As Numeric
    Local nResto                As Numeric
    Local nLimite               As Numeric
    Local cNumero               As Character
    Local aCodigo               As Array
    Local jTask                 As JSON
    Local jData                 As JSON
    Local nTotalTasks           As Numeric
    Local nTotalOldValue        As Numeric
    Local nTotalNewValue        As Numeric
    Local nTotalAdjustment      As Numeric
    Local nTotalPercentual      As Numeric
    Local nTotalRounding        As Numeric
    Local aLogFile              As Array
    Local aErrorTar             As Array
    Local cReportTypeDesc       As Character
    Local nTotalAdicional       As Numeric
    
    Private cTarDe              As Character
    Private cTarAte             As Character
    Private dReajuste           As Date
    Private nCriterio           As Numeric
    Private nArredonda          As Numeric
    Private nAtulTar            As Numeric
    Private cTipAum             As Character
    Private nNumRegs            As Numeric

    // Inicialização das variáveis
    cFilExec            := AllTrim(FwFilialName())
    cEmpExec            := AllTrim(FwEmpName(cEmpAnt))
    cTaskCodeFrom       := ""
    cTaskCodeTo         := ""
    nRoundingType       := 1
    nRoundingValue      := 0
    nUpdateType         := 1
    nReportType         := 1
    cBranchCodeFrom     := ""
    cBranchCodeTo       := ""
    cCostCenterCodeFrom := ""
    cCostCenterCodeTo   := ""
    cEmployeeCodeFrom   := ""
    cEmployeeCodeTo     := ""
    cFunctionCodeFrom   := ""
    cFunctionCodeTo     := ""
    cCategory           := ""
    dAdjustmentDate     := dDataBase
    nUpdateSubsequent   := 1
    cIncreaseType       := "001"
    aSalaryRanges       := {}
    jParams             := NIL
    jData               := JSONObject():New()
    aTabS070            := {}
    aColsTar            := {}
    aTarReaj            := {}
    aFaixas             := {}
    cTip                := "S070"
    nTamS070            := 0
    nCnt                := 0
    nPosTab             := 1
    nPos                := 0
    nTarAnti            := 0
    nTarNova            := 0
    nTarPerc            := 0
    nValArred           := 0
    nResto              := 0
    aCodigo             := {}
    nTotalTasks         := 0
    nTotalOldValue      := 0
    nTotalNewValue      := 0
    nTotalAdjustment    := 0
    nTotalPercentual    := 0
    nTotalRounding      := 0
    aLogFile            := {}
    aErrorTar           := {}
    nNumRegs            := 0
    nTotalAdicional     := 0

    // Parâmetros
    If (oFilter != NIL)
        jParams := oFilter:getParameters()
        
        If (jParams != NIL)
            cTaskCodeFrom       := IIf(jParams:hasProperty("PAR_CODTARDE")       .AND. Len(jParams["PAR_CODTARDE"])       > 0 .AND. !Empty(jParams["PAR_CODTARDE"][1]),       jParams["PAR_CODTARDE"][1], "")
            cTaskCodeTo         := IIf(jParams:hasProperty("PAR_CODTARATE")      .AND. Len(jParams["PAR_CODTARATE"])      > 0 .AND. !Empty(jParams["PAR_CODTARATE"][1]),      jParams["PAR_CODTARATE"][1], Replicate("Z", 3))
            nRoundingType       := IIf(jParams:hasProperty("PAR_CRITOARRED")     .AND. Len(jParams["PAR_CRITOARRED"])     > 0 .AND. !Empty(jParams["PAR_CRITOARRED"][1]),     Val(jParams["PAR_CRITOARRED"][1]), 1)
            nRoundingValue      := IIf(jParams:hasProperty("PAR_ARREDVLR")       .AND. Len(jParams["PAR_ARREDVLR"])       > 0 .AND. !Empty(jParams["PAR_ARREDVLR"][1]),       jParams["PAR_ARREDVLR"][1], 0)
            nUpdateType         := IIf(jParams:hasProperty("PAR_ATUTAR")         .AND. Len(jParams["PAR_ATUTAR"])         > 0 .AND. !Empty(jParams["PAR_ATUTAR"][1]),         Val(jParams["PAR_ATUTAR"][1]), 1)
            nReportType         := IIf(jParams:hasProperty("PAR_TIPOREL")        .AND. Len(jParams["PAR_TIPOREL"])        > 0 .AND. !Empty(jParams["PAR_TIPOREL"][1]),        Val(jParams["PAR_TIPOREL"][1]), 1)
            cBranchCodeFrom     := IIf(jParams:hasProperty("PAR_FILDE")          .AND. Len(jParams["PAR_FILDE"])          > 0 .AND. !Empty(jParams["PAR_FILDE"][1]),          jParams["PAR_FILDE"][1], "")
            cBranchCodeTo       := IIf(jParams:hasProperty("PAR_FILATE")         .AND. Len(jParams["PAR_FILATE"])         > 0 .AND. !Empty(jParams["PAR_FILATE"][1]),         jParams["PAR_FILATE"][1], Replicate("Z", GetSX3Cache("RA_FILIAL", "X3_TAMANHO")))
            cCostCenterCodeFrom := IIf(jParams:hasProperty("PAR_CCDE")           .AND. Len(jParams["PAR_CCDE"])           > 0 .AND. !Empty(jParams["PAR_CCDE"][1]),           jParams["PAR_CCDE"][1], "")
            cCostCenterCodeTo   := IIf(jParams:hasProperty("PAR_CCATE")          .AND. Len(jParams["PAR_CCATE"])          > 0 .AND. !Empty(jParams["PAR_CCATE"][1]),          jParams["PAR_CCATE"][1], Replicate("Z", GetSX3Cache("RA_CC", "X3_TAMANHO")))
            cEmployeeCodeFrom   := IIf(jParams:hasProperty("PAR_MATDE")          .AND. Len(jParams["PAR_MATDE"])          > 0 .AND. !Empty(jParams["PAR_MATDE"][1]),          jParams["PAR_MATDE"][1], "")
            cEmployeeCodeTo     := IIf(jParams:hasProperty("PAR_MATATE")         .AND. Len(jParams["PAR_MATATE"])         > 0 .AND. !Empty(jParams["PAR_MATATE"][1]),         jParams["PAR_MATATE"][1], Replicate("Z", GetSX3Cache("RA_MAT", "X3_TAMANHO")))
            cFunctionCodeFrom   := IIf(jParams:hasProperty("PAR_FUNCDE")         .AND. Len(jParams["PAR_FUNCDE"])         > 0 .AND. !Empty(jParams["PAR_FUNCDE"][1]),         jParams["PAR_FUNCDE"][1], "")
            cFunctionCodeTo     := IIf(jParams:hasProperty("PAR_FUNCATE")        .AND. Len(jParams["PAR_FUNCATE"])        > 0 .AND. !Empty(jParams["PAR_FUNCATE"][1]),        jParams["PAR_FUNCATE"][1], Replicate("Z", GetSX3Cache("RA_CODFUNC", "X3_TAMANHO")))
            cCategory           := IIf(jParams:hasProperty("PAR_CATEGORIA")      .AND. Len(jParams["PAR_CATEGORIA"])      > 0 .AND. !Empty(jParams["PAR_CATEGORIA"][1]),      jParams["PAR_CATEGORIA"][1], "H*T*G*J*M*C*P*A*E*S*I*D")
            nUpdateSubsequent   := IIf(jParams:hasProperty("PAR_ATUSUBSEQ")      .AND. Len(jParams["PAR_ATUSUBSEQ"])      > 0 .AND. !Empty(jParams["PAR_ATUSUBSEQ"][1]),      Val(jParams["PAR_ATUSUBSEQ"][1]), 1)
            cIncreaseType       := IIf(jParams:hasProperty("PAR_TIPAUM")         .AND. Len(jParams["PAR_TIPAUM"])         > 0 .AND. !Empty(jParams["PAR_TIPAUM"][1]),         jParams["PAR_TIPAUM"][1], "001")
            
            dAdjustmentDate := IIf(jParams:hasProperty("PAR_DTREAJ") .AND. Len(jParams["PAR_DTREAJ"]) > 0 .AND. !Empty(jParams["PAR_DTREAJ"][1]), ;
                fConvertIsoToDate(jParams["PAR_DTREAJ"][1]), dDataBase)

            // Captura as faixas salariais da tabela RUG
            aSalaryRanges := fGetFaixasFromTableTasks()
        EndIf
    EndIf

    cTarDe      := IIf(Empty(cTaskCodeFrom), "", cTaskCodeFrom)
    cTarAte     := IIf(Empty(cTaskCodeTo), Replicate("Z", 3), cTaskCodeTo)
    dReajuste   := dAdjustmentDate
    nCriterio   := nRoundingType
    nArredonda  := nRoundingValue
    nAtulTar    := nUpdateSubsequent
    cTipAum     := cIncreaseType

    // Configuração da descrição do tipo de relatório
    Do Case
        Case nReportType == 1
            cReportTypeDesc := "PARAMETROS"
        Case nReportType == 2
            cReportTypeDesc := "FUNCIONARIO"
        Case nReportType == 3
            cReportTypeDesc := "AMBOS"
    EndCase

    // Cria a estrutura
    jData["FilialExec"]     := RTrim(cFilExec)
    jData["EmpresaExec"]    := RTrim(cEmpExec)
    jData["ReportTypeDesc"] := cReportTypeDesc
    jData["Tasks"]          := {}
    jData["Employees"]      := {}
    jData["Totals"]         := {}

    // Configuração das faixas salariais
    aFaixas := aClone(aSalaryRanges)

    // Limite para validação do valor
    cNumero := Replicate('9', TamSx3('RO_VALOR')[1] - TamSx3('RO_VALOR')[2] - 1)
    cNumero := cNumero + '.' + Replicate('9', TamSx3('RO_VALOR')[2])
    nLimite := Val(cNumero)

    // Carrega tabela de tarefas
    fCarrTab(@aTabS070, cTip, CtoD(""), .T.)
    nTamS070 := Len(aTabS070)

    If nTamS070 > 0
        // Monta aColsTar com os dados da tarefa
        aColsTar := Array(nTamS070, 11)
        nCnt := 0
        nPosTab := 1

        While .T.
            nCnt++
            aColsTar[nCnt,1] := fTabela(cTip, nPosTab, 4)  // Código
            aColsTar[nCnt,2] := fTabela(cTip, nPosTab, 5)  // Descrição
            aColsTar[nCnt,3] := fTabela(cTip, nPosTab, 6)  // Valor Antigo
            aColsTar[nCnt,4] := fTabela(cTip, nPosTab, 7)  // Verba
            aColsTar[nCnt,5] := fTabela(cTip, nPosTab, 8)  // Data Reajuste
            aColsTar[nCnt,6] := fTabela(cTip, nPosTab, 9)
            aColsTar[nCnt,7] := fTabela(cTip, nPosTab, 10)
            aColsTar[nCnt,8] := fTabela(cTip, nPosTab, 11)
            aColsTar[nCnt,9] := fTabela(cTip, nPosTab, 12)
            aColsTar[nCnt,10]:= fTabela(cTip, nPosTab, 1)  // RCC_FIL
            aColsTar[nCnt,11]:= fTabela(cTip, nPosTab, 3)  // RCC_SEQUEN

            nPosTab++
            If nPosTab > nTamS070
                Exit
            EndIf
        EndDo

        // Reajusta as tarefas
        fReajTarefaSV(@aErrorTar, @aLogFile, aColsTar, aFaixas, aCodigo, @aTarReaj, nLimite)

        // Se não houve reajustes mas há tarefas, processa mesmo assim para manter compatibilidade
        If nReportType == 2 .Or. nReportType == 3 // Funcionários ou Ambos
            // Processa relatório de funcionários 
            fProcessEmployeeTasksSV(@nTotalTasks, @nTotalOldValue, @nTotalNewValue, @nTotalAdjustment, @nTotalPercentual, @nTotalRounding, @nTotalAdicional, aTarReaj, cBranchCodeFrom, cBranchCodeTo, cCostCenterCodeFrom, cCostCenterCodeTo, cEmployeeCodeFrom, cEmployeeCodeTo, cFunctionCodeFrom, cFunctionCodeTo, cCategory, @jData)
        EndIf

        If Len(aTarReaj) > 0
            // Processa relatório de parâmetros (tarefas)
            If nReportType == 1 .Or. nReportType == 3 // Tarefas ou Ambos
                For nI := 1 To Len(aTarReaj)
                    jTask := {;
                        "Empresa":            cEmpExec,;
                        "Filial":             cFilExec,;
                        "CodigoTarefa":       aTarReaj[nI, 1],;
                        "DescricaoTarefa":    AllTrim(aTarReaj[nI, 2]),;
                        "CodigoVerba":        aTarReaj[nI, 4],;
                        "ValorAntigo":        aTarReaj[nI, 3],;
                        "Percentual":         aTarReaj[nI, 5],;
                        "ValorAdicional":     aTarReaj[nI, 6],;
                        "ValorReajuste":      (aTarReaj[nI, 7] - aTarReaj[nI, 3]),;
                        "NovoValor":          aTarReaj[nI, 7],;
                        "Arredondamento":     aTarReaj[nI, 8],;
                        "DataReajuste":       DtoC(dReajuste),;
                        "TipoRelatorio":      "Tarefa";
                    }

                    // Apenas acumula totais se não for relatório de funcionários puro
                    If nReportType == 1
                        nTotalTasks++
                        nTotalOldValue      += aTarReaj[nI, 3]
                        nTotalNewValue      += aTarReaj[nI, 7]
                        nTotalAdjustment    += (aTarReaj[nI, 7] - aTarReaj[nI, 3])
                        nTotalPercentual    += aTarReaj[nI, 5]
                        nTotalRounding      += aTarReaj[nI, 8]
                        nTotalAdicional     += aTarReaj[nI, 6]
                    EndIf

                    AAdd(jData["Tasks"], jTask)
                Next nI
            EndIf

            // Atualiza as tarefas se solicitado
            If nUpdateType == 2 // Atualizar
                fGravaReajSV(aTarReaj, aColsTar)
            EndIf

            // Adiciona totalizadores conforme o tipo de relatório
            If nReportType == 3 // Ambos - cria estrutura aninhada
                jData["Totals"] := {{;
                    "TaskTotals":       [],;
                    "EmployeeTotals":   [];
                }}

                // Calcula totais separados para tarefas e funcionários
                fCalculateSeparatedTotals(@jData, aTarReaj, cEmpExec, cFilExec, dReajuste, nTotalTasks, nTotalOldValue, nTotalNewValue, nTotalAdjustment, nTotalPercentual, nTotalRounding, nTotalAdicional)
            
            ElseIf nTotalTasks > 0 .And. nReportType == 1 // Apenas Tarefas
                jData["Totals"] := {{;
                    "TaskTotals":       [],;
                    "EmployeeTotals":   [];
                }}

                jTaskTotal := {;
                    "Empresa":          cEmpExec,;
                    "Filial":           cFilExec,;
                    "CodigoTarefa":     "TOTAL_TAREFAS",;
                    "DescricaoTarefa":  "TOTAL GERAL",;
                    "CodigoVerba":      "",;
                    "ValorAntigo":      nTotalOldValue,;
                    "Percentual":       nTotalPercentual,;
                    "ValorAdicional":   nTotalAdicional,;
                    "ValorReajuste":    nTotalAdjustment,;
                    "NovoValor":        nTotalNewValue,;
                    "Arredondamento":   nTotalRounding,;
                    "DataReajuste":     DtoC(dReajuste),;
                    "TipoRelatorio":    "TotalTarefa",;
                    "QtdTarefas":       nTotalTasks;
                }

                AAdd(jData["Totals"][1]["TaskTotals"], jTaskTotal)

            ElseIf nTotalTasks > 0 .And. nReportType == 2 // Apenas Funcionários
                jData["Totals"] := {{;
                    "TaskTotals":       [],;
                    "EmployeeTotals":   [];
                }}

                jEmployeeTotal := {;
                    "Empresa":          cEmpExec,;
                    "Filial":           cFilExec,;
                    "QtdFuncionarios":  Len(jData["Employees"]),;
                    "QtdTarefas":       nTotalTasks,;
                    "ValorAntigo":      nTotalOldValue,;
                    "Percentual":       nTotalPercentual,;
                    "ValorAdicional":   nTotalAdicional,;
                    "ValorReajuste":    nTotalAdjustment,;
                    "NovoValor":        nTotalNewValue,;
                    "Arredondamento":   nTotalRounding,;
                    "DataReajuste":     DtoC(dReajuste),;
                    "TipoRelatorio":    "TotalFuncionario";
                }

                AAdd(jData["Totals"][1]["EmployeeTotals"], jEmployeeTotal)
            EndIf
        EndIf
    EndIf

    // Adiciona o registro ao vetor de dados do objeto de negócio
    self:oData:appendData(jData)

    // Limpa objetos da memória
    FwFreeObj(jParams)
    FwFreeArray(aSalaryRanges)
    FwFreeObj(jData)

return self:oData

/*/{Protheus.doc} fCalculateSeparatedTotals
    Calcula totais separados para tarefas e funcionários no relatório "Ambos"
    @type Static Function
    @param jData JSON dos dados
    @param aTarReaj Array das tarefas reajustadas
    @param cEmpExec Empresa de execução
    @param cFilExec Filial de execução
    @param dReajuste Data do reajuste
    @param nTotalTasks Total de tarefas
    @param nTotalOldValue Total valor antigo
    @param nTotalNewValue Total novo valor
    @param nTotalAdjustment Total ajuste
    @param nTotalPercentual Total percentual
    @param nTotalRounding Total arredondamento
    @param nTotalAdicional Total adicional
    @author guilherme.suttanni
    @since 07/08/2025
/*/
Static Function fCalculateSeparatedTotals(jData, aTarReaj, cEmpExec, cFilExec, dReajuste, nTotalTasks, nTotalOldValue, nTotalNewValue, nTotalAdjustment, nTotalPercentual, nTotalRounding, nTotalAdicional)
    Local jTaskTotal        As JSON
    Local jEmployeeTotal    As JSON
    Local nI                As Numeric
    Local nJ                As Numeric
    Local nTaskOldValue     As Numeric
    Local nTaskNewValue     As Numeric
    Local nTaskAdjustment   As Numeric
    Local nTaskPercentual   As Numeric
    Local nTaskRounding     As Numeric
    Local nTaskAdicional    As Numeric
    Local nEmpOldValue      As Numeric
    Local nEmpNewValue      As Numeric
    Local nEmpAdjustment    As Numeric
    Local nEmpPercentual    As Numeric
    Local nEmpRounding      As Numeric
    Local nEmpAdicional     As Numeric
    Local nQtdEmployees     As Numeric
    Local nEmpTasks         As Numeric

    jTaskTotal := JSONObject():New()
    jEmployeeTotal := JSONObject():New()

    // Inicializa totais de tarefas
    nTaskOldValue     := 0
    nTaskNewValue     := 0
    nTaskAdjustment   := 0
    nTaskPercentual   := 0
    nTaskRounding     := 0
    nTaskAdicional    := 0

    // Calcula totais das tarefas
    For nI := 1 To Len(aTarReaj)
        nTaskOldValue     += aTarReaj[nI, 3]
        nTaskNewValue     += aTarReaj[nI, 7]
        nTaskAdjustment   += (aTarReaj[nI, 7] - aTarReaj[nI, 3])
        nTaskPercentual   += aTarReaj[nI, 5]
        nTaskRounding     += aTarReaj[nI, 8]
        nTaskAdicional    += aTarReaj[nI, 6]
    Next nI

    // Inicializa totais dos funcionários
    nEmpOldValue     := 0
    nEmpNewValue     := 0
    nEmpAdjustment   := 0
    nEmpPercentual   := 0
    nEmpRounding     := 0
    nEmpAdicional    := 0
    nQtdEmployees    := Len(jData["Employees"])
    nEmpTasks        := 0

    // Calcula totais dos funcionários baseado nas tarefas dos funcionários
    For nI := 1 To Len(jData["Employees"])
        If jData["Employees"][nI]:hasProperty("EmployeeTasks")
            For nJ := 1 To Len(jData["Employees"][nI]["EmployeeTasks"])
                nEmpOldValue     += jData["Employees"][nI]["EmployeeTasks"][nJ]["ValorAntigo"]
                nEmpNewValue     += jData["Employees"][nI]["EmployeeTasks"][nJ]["NovoValor"]
                nEmpAdjustment   += jData["Employees"][nI]["EmployeeTasks"][nJ]["ValorReajuste"]
                nEmpPercentual   += jData["Employees"][nI]["EmployeeTasks"][nJ]["Percentual"]
                nEmpRounding     += jData["Employees"][nI]["EmployeeTasks"][nJ]["Arredondamento"]
                nEmpAdicional    += jData["Employees"][nI]["EmployeeTasks"][nJ]["ValorAdicional"]
                nEmpTasks++
            Next nJ
        EndIf
    Next nI

    // Cria total de tarefas
    jTaskTotal := {;
        "Empresa":          cEmpExec,;
        "Filial":           cFilExec,;
        "CodigoTarefa":     "TOTAL_TAREFAS",;
        "DescricaoTarefa":  "TOTAL TAREFAS",;
        "CodigoVerba":      "",;
        "ValorAntigo":      nTaskOldValue,;
        "Percentual":       nTaskPercentual,;
        "ValorAdicional":   nTaskAdicional,;
        "ValorReajuste":    nTaskAdjustment,;
        "NovoValor":        nTaskNewValue,;
        "Arredondamento":   nTaskRounding,;
        "DataReajuste":     DtoC(dReajuste),;
        "TipoRelatorio":    "TotalTarefa",;
        "QtdTarefas":       Len(aTarReaj);
    }

    // Cria total de funcionários
    jEmployeeTotal := {;
        "Empresa":          cEmpExec,;
        "Filial":           cFilExec,;
        "QtdFuncionarios":  nQtdEmployees,;
        "QtdTarefas":       nEmpTasks,;
        "ValorAntigo":      nEmpOldValue,;
        "Percentual":       nEmpPercentual,;
        "ValorAdicional":   nEmpAdicional,;
        "ValorReajuste":    nEmpAdjustment,;
        "NovoValor":        nEmpNewValue,;
        "Arredondamento":   nEmpRounding,;
        "DataReajuste":     DtoC(dReajuste),;
        "TipoRelatorio":    "TotalFuncionario";
    }

    // Adiciona aos arrays aninhados
    AAdd(jData["Totals"][1]["TaskTotals"], jTaskTotal)
    AAdd(jData["Totals"][1]["EmployeeTotals"], jEmployeeTotal)

Return

Static Function fReajTarefaSV(aErrorTar, aLogFile, aColsTar, aFaixas, aCodigo, aTarReaj, nLimite)
    Local nk                 As Numeric
    Local nTarNova          As Numeric
    Local nTarAnti          As Numeric
    Local nTarPerc          As Numeric
    Local nValArred         As Numeric
    Local nPos              As Numeric
    Local nResto            As Numeric
    Local nValorAdicional   As Numeric 
    Local nValorReajuste    As Numeric  

    nTarNova        := 0
    nTarAnti        := 0
    nTarPerc        := 0
    nValArred       := 0
    nPos            := 0
    nValorAdicional := 0
    nValorReajuste  := 0

    For nk := 1 To Len(aColsTar)
        // Verifica se a tarefa está na faixa de códigos definida
        If aColsTar[nk,1] >= cTarDe .And. aColsTar[nk,1] <= cTarAte
            // Verifica se a data de reajuste da tarefa não é posterior à data de reajuste informada
            If !(aColsTar[nk,5] > dReajuste)
                // Verifica se a tarefa ainda não foi processada (evita duplicatas)
                If AScan(aCodigo, {|X| aColsTar[nk,1] == X[1]}) == 0

                    nTarAnti := aColsTar[nk,3] // Valor antigo da tarefa

                    // Busca a faixa correspondente ao valor antigo
                    nPos := AScan(aFaixas, {|X| nTarAnti >= X[1] .And. nTarAnti <= X[2]})
                    
                    If nPos > 0
                        nTarPerc        := aFaixas[nPos,3]  // Percentual de aumento
                        nValorAdicional := aFaixas[nPos,4]  // Valor adicional (RUG_VALOR)
                        
                        // Calcula o novo valor seguindo a lógica EXATA do original
                        nTarNova := nTarAnti
                        nTarNova := nTarAnti * ( 1 + ( nTarPerc / 100 ) )
                        nTarNova := nTarNova + nValorAdicional
                        
                        // Aplica o critério de arredondamento
                        If nCriterio == 1      // Não arredonda
                            nTarNova := NoRound(nTarNova, 4)
                        ElseIf nCriterio == 2  // Arredondamento padrão
                            nTarNova := Round(nTarNova, 4)
                        Else                   // Arredondamento para cima
                            If nTarNova - Round(nTarNova, 4) > 0.00
                                nTarNova := NoRound((nTarNova + .01), 4)
                            Else
                                nTarNova := Round(nTarNova, 4)
                            EndIf
                        EndIf
                        
                        // Aplica arredondamento adicional se especificado
                        If nArredonda != 0
                            nResto := Mod(nTarNova, nArredonda)
                            If Round(nResto, 4) > 0.00
                                nValArred := nArredonda - nResto
                                nTarNova := nTarNova + nValArred
                            Else
                                nValArred := 0.00
                            EndIf
                        EndIf
                        
                        // Verifica se o valor não ultrapassa o limite do campo
                        If nLimite < nTarNova
                            AAdd(aLogFile, STR0004 + aColsTar[nk,1] + ' - ' + AllTrim(aColsTar[nk,2]))
                            AAdd(aErrorTar, aColsTar[nk,1])
                        Else
                            // Adiciona a tarefa reajustada ao array
                            // Estrutura: {Código, Descrição, Valor Antigo, Verba, Percentual, Valor Adicional, Valor Novo, Arredondamento}
                            AAdd(aTarReaj, {aColsTar[nk,1], aColsTar[nk,2], aColsTar[nk,3], aColsTar[nk,4], nTarPerc, nValorAdicional, nTarNova, nValArred})

                            // Atualiza o array aColsTar com os novos valores (importante para posterior gravação)
                            aColsTar[nk,3] := nTarNova  // Atualiza valor antigo para o novo valor
                            aColsTar[nk,5] := dReajuste // Atualiza data do reajuste

                            // Adiciona o código ao array de processados para evitar duplicatas
                            AAdd(aCodigo, {aColsTar[nk,1]})
                        EndIf
                    EndIf
                EndIf
            EndIf
        EndIf
    Next nk

Return

/*/{Protheus.doc} fGravaReajSV
    Grava as tarefas reajustadas no arquivo de parâmetros e SRO
    @type Static Function
    @param aTarReaj Array das tarefas reajustadas
    @param aColsTar Array das tarefas
    @author guilherme.suttanni
    @since 29/07/2025
/*/
Static Function fGravaReajSV(aTarReaj, aColsTar)
    Local nCont     As Numeric
    Local nX        As Numeric
    Local cTxt      As Character
    Local cChave    As Character
    Local lTemSeq   As Logical
    Local lTemItem  As Logical
    Local lTemClVl  As Logical
    Local cNewSeq   As Character
    Local cFilMat   As Character
    Local aSROSeq   As Array
    Local nPos      As Numeric
    Local aSRO      As Array
    Local cAjFilMat As Character

    cChave  := Space(TamSX3("RCC_CHAVE")[1])
    lTemSeq := SRO->(FieldPos("RO_SEQ") * FieldPos("RO_CONTSEQ")) # 0
    lTemItem:= SRO->(FieldPos("RO_ITEM")) # 0
    lTemClVl:= SRO->(FieldPos("RO_CLVL")) # 0
    cNewSeq := StrZero(0, 5)
    cFilMat := Space(FwSizeFilial()) + Space(TamSX3("RA_MAT")[1])
    aSRO    := {}
    aSROSeq := {}

    DbSelectArea("RCC")
    DbSetOrder(1)

    // Grava a tarefa reajustada no cadastro de parâmetros
    For nCont := 1 To Len(aColsTar)
        If AScan(aTarReaj, {|X| X[1] == aColsTar[nCont,1]}) > 0
            cTxt := ""
            
            RCC->(dbSeek(xFilial("RCC") + "S070" + aColsTar[nCont,10] + cChave + aColsTar[nCont,11]))

            For nX := 1 To 9
                If ValType(aColsTar[nCont,nX]) == "D"
                    If Empty(aColsTar[nCont,nX])
                        cTxt += DtoC(aColsTar[nCont,nX])
                    Else
                        cTxt += DtoS(aColsTar[nCont,nX])
                    EndIf
                ElseIf ValType(aColsTar[nCont,nX]) == "N"
                    cTxt += STR(aColsTar[nCont,nX], 12, 4)
                Else
                    cTxt += aColsTar[nCont,nX]
                EndIf
            Next nX

            If Len(AllTrim(cTxt)) > 0
                RecLock("RCC", .F.)
                RCC->RCC_CONTEU := cTxt
                MsUnlock()
            EndIf
        EndIf
    Next nCont

    // Grava a tarefa reajustada nos lançamentos dos funcionários
    dbSelectArea("SRO")
    dbSetOrder(2)
    dbGoTop()

    While SRO->(!Eof())
        If cFilMat # SRO->(RO_FILIAL + RO_MAT)
            cFilMat := SRO->(RO_FILIAL + RO_MAT)
            cAjFilMat := "a" + StrTran(cFilMat, " ", "_")
            &(cAjFilMat) := {}

            If SRA->(dbSeek(cFilMat))
                If !fGPA190Atu()
                    Exit
                EndIf
            EndIf
        EndIf

        If lTemSeq
            cAjFilMat := "a" + StrTran(cFilMat, " ", "_")
            AAdd(&(cAjFilMat), SRO->RO_SEQ)
        EndIf

        nPos := AScan(aTarReaj, {|X| X[1] == SRO->RO_CODTAR})

        If nPos > 0
            // Atualização da tarefa dentro do mês corrente
            If (AnoMes(SRO->RO_DATA) == AnoMes(dReajuste)) .And. (Empty(SRO->RO_DATAATE) .Or. AnoMes(SRO->RO_DATAATE) >= AnoMes(dReajuste))
                RecLock("SRO", .F.)
                SRO->RO_VALOR := aTarReaj[nPos, 7]  // D_NOVO = 7
                SRO->RO_VALTOT := (aTarReaj[nPos, 7] * SRO->RO_QUANT)
                If lTemSeq
                    SRO->RO_TPALT := cTipAum
                EndIf
                MsUnLock()
                nNumRegs++
            //Atualizacao da tarefa com quebra entre meses distintos - DATA DE < REAJUSTE e DATA ATE >= REAJUSTE Ou " "
            ElseIf	( AnoMes( SRO->RO_DATA ) < AnoMes( dReajuste ) ) .And. ( Empty(SRO->RO_DATAATE) .Or. AnoMes( SRO->RO_DATAATE ) >= AnoMes( dReajuste ) )
                RecLock( "SRO", .F. )
                aAdd(aSro, ( {SRO->RO_FILIAL, SRO->RO_MAT, SRO->RO_TIPO, dReajuste, If( SRO->RO_DATAATE >= dReajuste, SRO->RO_DATAATE, ""), SRO->RO_CODTAR, SRO->RO_QTDSEM, SRO->RO_QUANT, aTarReaj[nPos,7], (aTarReaj[nPos,7] * SRO->RO_QUANT), SRO->RO_CC, SRO->RO_VERBA, If( lTemSeq, SRO->RO_SEQ, cNewSeq ), If( lTemItem, SRO->RO_ITEM, "" ), If( lTemClVl, SRO->RO_CLVL, "" )  } ) )
                SRO->RO_DATAATE := If( ( dReajuste-1 ) < SRO->RO_DATA, SRO->RO_DATA,( dReajuste-1 ) )
                MsUnLock()
                nNumRegs++

            //Atualizacao das tarefas dos meses subsequentes quando escolhido pelo Usuario
            ElseIf	( AnoMes( SRO->RO_DATA ) > AnoMes( dReajuste ) ) .And. ( Empty(SRO->RO_DATAATE) .Or. AnoMes( SRO->RO_DATAATE ) > AnoMes( dReajuste ) ) .And. nAtulTar == 2
                RecLock( "SRO", .F. )
                SRO->RO_VALOR   := ( aTarReaj[nPos,7] )  // D_NOVO = 7
                SRO->RO_VALTOT  := ( aTarReaj[nPos,7] * SRO->RO_QUANT )
                If lTemSeq
                    SRO->RO_TPALT		:= cTipAum
                EndIf
                MsUnLock()
                nNumRegs++
            EndIf
        EndIf

        SRO->(dbSkip())
    EndDo

    // Processa array aSRO para inserir novos registros se necessário
    For nx := 1 to len(aSRO)
        If aSro[nx,1] + aSro[nx,2] # cFilMat
            cFilMat := aSro[nx,1] + aSro[nx,2]
            cAjFilMat:= "a" + StrTran(cFilMat," ","_")
            aSROSeq := aClone( &( cAjFilMat ) )
        EndIf
        aSort( aSROSeq,,, { |x,y| x > y } )
        
        // Verifica se já existe um registro com essa chave única
        dbSelectArea("SRO")
        dbSetOrder(1) // RO_FILIAL + RO_MAT + RO_DATA + RO_CODTAR + RO_CC + RO_ITEM + RO_CLVL
        
        If !dbSeek(aSro[nx,1] + aSro[nx,2] + DtoS(aSro[nx,4]) + aSro[nx,6] + aSro[nx,11] + aSro[nx,14] + aSro[nx,15])
            // Se não encontrou, pode inserir
            RecLock("SRO",.T.)
            SRO->RO_FILIAL   := aSro[nx,1]
            SRO->RO_MAT      := aSro[nx,2]
            SRO->RO_TIPO     := aSro[nx,3]
            SRO->RO_DATA     := aSro[nx,4]
            If  !Empty(aSro[nx,5])
                SRO->RO_DATAATE  := (aSro[nx,5])
            EndIf
            SRO->RO_CODTAR 	 := aSro[nx,6]
            SRO->RO_QTDSEM 	 := aSro[nx,7]
            SRO->RO_QUANT  	 := aSro[nx,8]
            SRO->RO_VALOR  	 := aSro[nx,9]
            SRO->RO_VALTOT 	 := aSro[nx,10]
            SRO->RO_CC		 := aSro[nx,11]
            SRO->RO_VERBA 	 := aSro[nx,12]
            If lTemSeq .And. !Empty( aSROSeq )
                cNewSeq 			:= Soma1( aSROSeq[1] )
                SRO->RO_SEQ			:= cNewSeq
                aAdd( aSROSeq, cNewSeq )

                SRO->RO_CONTSEQ		:= aSro[nx,13]
                SRO->RO_TPALT		:= cTipAum
            EndIf
            If lTemItem
                SRO->RO_ITEM := aSro[nx,14]
            EndIf

            If lTemClVl
                SRO->RO_CLVL := aSro[nx,15]
            EndIf
            MsUnLock()
        Else
            // Se já existe, atualiza o registro existente
            RecLock("SRO", .F.)
            SRO->RO_VALOR  	 := aSro[nx,9]
            SRO->RO_VALTOT 	 := aSro[nx,10]
            If lTemSeq
                SRO->RO_TPALT := cTipAum
            EndIf
            If !Empty(aSro[nx,5])
                SRO->RO_DATAATE := aSro[nx,5]
            EndIf
            MsUnLock()
        EndIf
    Next

Return

Static Function fProcessEmployeeTasksSV(nTotalTasks, nTotalOldValue, nTotalNewValue, nTotalAdjustment, nTotalPercentual, nTotalRounding, nTotalAdicional, aTarReaj, cBranchCodeFrom, cBranchCodeTo, cCostCenterCodeFrom, cCostCenterCodeTo, cEmployeeCodeFrom, cEmployeeCodeTo, cFunctionCodeFrom, cFunctionCodeTo, cCategory, jData)
    Local jEmp              As JSON
    Local jEmpTask          As JSON
    Local nPos              As Numeric
    Local nOldValue         As Numeric
    Local nNewValue         As Numeric
    Local nPercentual       As Numeric
    Local nValorAdicional   As Numeric
    Local nArredondamento   As Numeric
    Local cAcessaSRA        As Character
    Local cChaveFunc        As Character
    Local aEmployees        As Array
    Local nPosEmp           As Numeric

    jEmp              := JSONObject():New()
    jEmpTask          := JSONObject():New()
    nPos              := 0
    nPosEmp           := 0
    
    // Variáveis de acesso do usuário
    cAcessaSRA := &( " { || " + ChkRH( "REAJTAR" , "SRA" , "2" ) + " } " )
    
    // Array para agrupar funcionários
    aEmployees := {}
    
    // Posiciona nas tabelas
    dbSelectArea("SRA")
    dbSetOrder(1)
    dbSelectArea("SRO")
    dbSetOrder(1)
    dbGoTop()

    While SRO->(!Eof())
        // Usa a mesma lógica do original para filtros de data
        If SRO->RO_CODTAR >= cTarDe .And. SRO->RO_CODTAR <= cTarAte .And. nAtulTar == 2
            If !(Empty(SRO->RO_DATAATE) .Or. (SRO->RO_DATAATE >= dReajuste))
                SRO->(dbSkip())
                Loop
            EndIf
            // Busca o funcionário
            dbSelectArea("SRA")
            If !dbSeek(SRO->RO_FILIAL + SRO->RO_MAT)
                dbSelectArea("SRO")
                dbSkip()
                Loop
            EndIf
        ElseIf SRO->RO_CODTAR >= cTarDe .And. SRO->RO_CODTAR <= cTarAte .And. nAtulTar == 1
            If !(Empty(SRO->RO_DATAATE) .Or. ((SRO->RO_DATAATE >= dReajuste) .And. (Month(dReajuste) == Month(SRO->RO_DATAATE))))
                SRO->(dbSkip())
                Loop
            EndIf
            // Busca o funcionário
            dbSelectArea("SRA")
            If !dbSeek(SRO->RO_FILIAL + SRO->RO_MAT)
                dbSelectArea("SRO")
                dbSkip()
                Loop
            EndIf
        Else
            SRO->(dbSkip())
            Loop
        EndIf

        // Verifica parâmetros de filtro (mesma lógica do original)
        If (SRA->RA_MAT < cEmployeeCodeFrom) .Or. (SRA->RA_MAT > cEmployeeCodeTo) .Or. ;
           (SRA->RA_CC < cCostCenterCodeFrom) .Or. (SRA->RA_CC > cCostCenterCodeTo) .Or. ;
           (SRA->RA_CODFUNC < cFunctionCodeFrom) .Or. (SRA->RA_CODFUNC > cFunctionCodeTo)
            dbSelectArea("SRO")
            dbSkip()
            Loop
        EndIf

        // Verifica filiais e acessos (como no original)
        If !(SRA->RA_FILIAL $ fValidFil() .and. Eval(cAcessaSRA))
            dbSelectArea("SRO")
            dbSkip()
            Loop
        EndIf

        // Verifica situação do funcionário (como no original)
        If !(SRA->RA_SITFOLH $ " *F*A")
            dbSelectArea("SRO")
            dbSkip()
            Loop
        EndIf

        // Verifica categoria do funcionário (como no original)
        If !(SRA->RA_CATFUNC $ cCategory)
            dbSelectArea("SRO")
            dbSkip()
            Loop
        EndIf

        // Processa apenas se a tarefa foi reajustada
        nPos := AScan(aTarReaj, {|X| X[1] == SRO->RO_CODTAR})
        
        If nPos > 0
            // Usa os valores ORIGINAIS da tarefa (antes do reajuste) do array aTarReaj
            nOldValue       := aTarReaj[nPos, 3]  // D_ANTIGO = 3 (valor original da tarefa)
            nPercentual     := aTarReaj[nPos, 5]  // D_PERC = 5 (percentual aplicado)
            nValorAdicional := aTarReaj[nPos, 6]  // Valor adicional aplicado
            nNewValue       := aTarReaj[nPos, 7]  // D_NOVO = 7 (novo valor da tarefa)
            nArredondamento := aTarReaj[nPos, 8]  // D_ARRE = 8 (valor do arredondamento)

            // Chave única do funcionário
            cChaveFunc := SRA->RA_FILIAL + SRA->RA_MAT

            // Busca se o funcionário já foi adicionado ao array
            nPosEmp := AScan(aEmployees, {|x| x[1] == cChaveFunc})
            
            // Cria o objeto da tarefa com os valores exatos do relatório original
            jEmpTask := {;
                "CodigoTarefa":        AllTrim(SRO->RO_CODTAR),;
                "CodigoVerba":         AllTrim(SRO->RO_VERBA),;
                "DataTarefaDe":        DtoC(SRO->RO_DATA),;
                "DataTarefaAte":       IIf(SRO->(FieldPos("RO_DATAATE")) > 0 .And. !Empty(SRO->RO_DATAATE), DtoC(SRO->RO_DATAATE), ""),;
                "ValorAntigo":         nOldValue,;
                "Percentual":          nPercentual,;
                "ValorAdicional":      nValorAdicional,;
                "ValorReajuste":       (nNewValue - nOldValue),;
                "NovoValor":           nNewValue,;
                "Arredondamento":      nArredondamento;
            }

            If nPosEmp > 0
                // Funcionário já existe, adiciona a tarefa ao array de tarefas
                AAdd(aEmployees[nPosEmp][2], jEmpTask)
            Else
                // Novo funcionário, cria registro completo
                jEmp := {;
                    "Empresa":             AllTrim(FwEmpName(cEmpAnt)),;
                    "Filial":              AllTrim(SRA->RA_FILIAL),;
                    "NomeFilial":          AllTrim(FwFilialName(SRA->RA_FILIAL)),;
                    "Matricula":           AllTrim(SRA->RA_MAT),;
                    "NomeFuncionario":     AllTrim(SRA->RA_NOME),;
                    "CentroCusto":         AllTrim(SRA->RA_CC),;
                    "CodigoFuncao":        AllTrim(SRA->RA_CODFUNC),;
                    "Categoria":           AllTrim(SRA->RA_CATFUNC),;
                    "Sindicato":           AllTrim(SRA->RA_SINDICA),;
                    "DataAdmissao":        DtoC(SRA->RA_ADMISSA),;
                    "TipoRelatorio":       "Funcionario",;
                    "EmployeeTasks":       {jEmpTask};
                }
                
                AAdd(aEmployees, {cChaveFunc, {jEmpTask}, jEmp})
            EndIf

            // Acumula totais usando os valores corretos
            nTotalTasks++
            nTotalOldValue += nOldValue
            nTotalNewValue += nNewValue
            nTotalAdjustment += (nNewValue - nOldValue)
            nTotalPercentual += nPercentual
            nTotalRounding += nArredondamento
            nTotalAdicional += nValorAdicional
        EndIf

        dbSelectArea("SRO")
        dbSkip()
    EndDo

    // Adiciona todos os funcionários ao jData
    For nPosEmp := 1 To Len(aEmployees)
        AAdd(jData["Employees"], aEmployees[nPosEmp][3])
    Next nPosEmp

Return

/*/{Protheus.doc} fGetFaixasFromTableTasks
    Busca as faixas salariais da tabela RUG para tarefas
    @type Static Function
    @return Array, Array com as faixas configuradas
    @author guilherme.suttanni
    @since 29/07/2025
/*/
Static Function fGetFaixasFromTableTasks()
    Local aFaixas   As Array
    Local cCodigo   As Character
    
    aFaixas := {}
    
    // Busca o último código inserido pelo usuário atual para origem = 2 (tarefas)
    cCodigo := PADR(fGetLastUserCodeTasks(), TAMSX3("RUG_CODIGO")[1])
    
    If !Empty(cCodigo)
        DbSelectArea("RUG")
        RUG->(DbSetOrder(1)) // RUG_FILIAL + RUG_CODIGO + RUG_ITEM
        
        If RUG->(DbSeek(xFilial("RUG") + cCodigo))
            While RUG->(!Eof()) .And. RUG->RUG_FILIAL == xFilial("RUG") .And. ;
                  RUG->RUG_CODIGO == cCodigo .And. RUG->RUG_ORIGEM == "2" // Origem 2 = Tarefas
                
                // Adiciona a faixa ao array
                If RUG->RUG_FAIXAD > 0 .Or. RUG->RUG_FAIXAA > 0 .Or. RUG->RUG_PERCEN > 0 .Or. RUG->RUG_VALOR > 0
                    AAdd(aFaixas, {RUG->RUG_FAIXAD, RUG->RUG_FAIXAA, RUG->RUG_PERCEN, RUG->RUG_VALOR, RUG->RUG_ADMDE, RUG->RUG_ADMATE, .F.})
                EndIf
                
                RUG->(DbSkip())
            EndDo
        EndIf
    EndIf
    
Return aFaixas

/*/{Protheus.doc} fGetLastUserCodeTasks
    Busca o último código de faixa de tarefas inserido pelo usuário atual
    @type Static Function
    @return Character, Último código UUID utilizado pelo usuário
    @author guilherme.suttanni
    @since 29/07/2025
/*/
Static Function fGetLastUserCodeTasks()
    Local cQuery    As Character
    Local cAlias    As Character
    Local cCodigo   As Character
    Local oStatement As Object
    
    cCodigo := ""
    
    cQuery := " SELECT RUG_CODIGO "
    cQuery += " FROM " + RetSqlName("RUG") + " RUG "
    cQuery += " WHERE RUG.RUG_FILIAL = ? "
    cQuery += "   AND RUG.RUG_USER = ? "
    cQuery += "   AND RUG.RUG_ORIGEM = ? " // Origem 2 = Tarefas
    cQuery += "   AND RUG.D_E_L_E_T_ = ? "
    cQuery += " ORDER BY RUG.RUG_DATA DESC, RUG.RUG_HORA DESC "
    
    // Instancia a classe FwExecStatement
    oStatement := FwExecStatement():New(cQuery)
    
    // Define o valor dos bind parameters
    oStatement:SetString(1, xFilial("RUG"))
    oStatement:SetString(2, __cUserID)
    oStatement:SetString(3, "2")
    oStatement:SetString(4, " ")
    
    // Executa a query e retorna o alias criado
    cAlias := oStatement:OpenAlias()
    
    If (cAlias)->(!Eof())
        cCodigo := AllTrim((cAlias)->RUG_CODIGO)
    EndIf
    
    (cAlias)->(DbCloseArea())
    
    // Limpa o objeto da memória
    FwFreeObj(oStatement)

Return cCodigo

/*/{Protheus.doc} fConvertIsoToDate
    Converte uma string de data no formato ISO para tipo Date
    @param cIsoDate String no formato ISO
    @return Date Data convertida
    @author guilherme.suttanni
    @since 29/07/2025
/*/
Static Function fConvertIsoToDate(cIsoDate)
    Local dRetDate  As Date
    Local cDatePart As Character
    Local cYear     As Character
    Local cMonth    As Character
    Local cDay      As Character
    
    dRetDate := CtoD("//")
    
    If !Empty(cIsoDate) .And. "T" $ cIsoDate
        cDatePart := SubStr(cIsoDate, 1, At("T", cIsoDate) - 1)
        
        cYear  := SubStr(cDatePart, 1, 4)
        cMonth := SubStr(cDatePart, 6, 2)
        cDay   := SubStr(cDatePart, 9, 2)
        
        dRetDate := CtoD(cDay + "/" + cMonth + "/" + cYear)
    EndIf
    
Return dRetDate

/*/{Protheus.doc} GPER1004TReportsBusinessObject::getComboBox
    Retorna os valores de ComboBox do parâmetro requisitado
    @type Method
    @author guilherme.suttanni
    @since 29/07/2025
/*/
Method getComboBox() As Variant Class GPER1004TReportsBusinessObject
    Local jPath     As JSON
    Local jResponse As JSON
    Local jItem     As JSON
    Local aValues   As Array
    Local cParam    As Character
    Local nValues   As Numeric

    jPath     := oRest:getPathParamsRequest()
    jResponse := JSONObject():New()
    aValues   := {}
    cParam    := ""

    If (jPath != NIL)
        cParam := jPath["param"]
    EndIf

    jResponse["data"]        := {}
    jResponse["nextPageUrl"] := NIL

    If cParam == "getRoundingType"
        AAdd(aValues, STR0092)
        AAdd(aValues, STR0094)
        AAdd(aValues, STR0095)
    ElseIf cParam == "getUpdateType"
        AAdd(aValues, STR0092)
        AAdd(aValues, STR0093)
    ElseIf cParam == "getReportType"
        AAdd(aValues, STR0096)
        AAdd(aValues, STR0097)
        AAdd(aValues, STR0098)
    ElseIf cParam == "getUpdateSubsequent"
        AAdd(aValues, STR0092)
        AAdd(aValues, STR0093)
    ElseIf cParam == "getIncreaseType"
        // Tipo de Aumento - busca da tabela SX5 (tabela 41)
        cQuery := " SELECT X5_CHAVE, X5_DESCRI "
        cQuery += " FROM " + RetSqlName("SX5") + " SX5 "
        cQuery += " WHERE SX5.X5_FILIAL = ? "
        cQuery += "   AND SX5.X5_TABELA = ? "
        cQuery += "   AND SX5.D_E_L_E_T_ = ? "
        cQuery += " ORDER BY SX5.X5_CHAVE "
        
        // Instancia a classe FwExecStatement
        oStatement := FwExecStatement():New(cQuery)
        
        // Define o valor dos bind parameters
        oStatement:SetString(1, xFilial("SX5"))
        oStatement:SetString(2, "41")
        oStatement:SetString(3, " ")
        
        // Executa a query e retorna o alias criado
        cAlias := oStatement:OpenAlias()
        
        While (cAlias)->(!Eof())
            cKey   := AllTrim((cAlias)->X5_CHAVE)
            cLabel := AllTrim((cAlias)->X5_DESCRI)
            
            If !Empty(cKey) .And. !Empty(cLabel)
                jItem := {;
                    "key":   cKey,;
                    "label": cLabel;
                }
                AAdd(jResponse["data"], jItem)
            EndIf
            
            (cAlias)->(DbSkip())
        EndDo
        
        (cAlias)->(DbCloseArea())
        
        // Limpa o objeto da memória
        FwFreeObj(oStatement)
    EndIf

    For nValues := 1 To Len(aValues)
        jItem := {"key": CValToChar(nValues), "label": aValues[nValues]}
        AAdd(jResponse["data"], jItem)
    Next nValues

    oRest:setResponse(jResponse)
    oRest:setStatusCode(200)

    FwFreeObj(jPath)
    FwFreeObj(jResponse)
    FwFreeObj(jItem)
    FwFreeArray(aValues)

Return NIL

method getSchema() as object class GPER1004TReportsBusinessObject
    Local cCodeSizeS070 As Character // Tamanho do código da tabela S070
    Local cDescSizeS070 As Character // Tamanho da descrição da tabela S070
    Local nFieldSize    As Numeric   // Tamanho do campo RCB_CAMPOS
    Local cRCBBranch    As Character // Filial da RCB
    Local aFields       As Array     // Campos das propriedades aninhadas
    Local aTaskFields   As Array     // Campos das tarefas dentro de funcionários

    // Inicialização das variáveis para buscar tamanhos da tabela S070
    nFieldSize    := GetSX3Cache("RCB_CAMPOS", "X3_TAMANHO")
    cRCBBranch    := FwXFilial("RCB")
    cCodeSizeS070 := CValToChar(Posicione("RCB", 3, cRCBBranch + PadR("CodTarefa", nFieldSize) + "S070", "RCB_TAMAN"))
    cDescSizeS070 := CValToChar(Posicione("RCB", 3, cRCBBranch + PadR("Descricao",   nFieldSize) + "S070", "RCB_TAMAN"))

    // Propriedades principais do objeto
    self:oSchema:addProperty("FilialExec",      STR0005,      "string",   STR0005)
    self:oSchema:addProperty("EmpresaExec",     STR0006,      "string",   STR0006)
    self:oSchema:addProperty("ReportTypeDesc",  STR0007,      "string",   STR0007)

    aFields := {}
    AAdd(aFields, {"Empresa",             STR0008,  "string", STR0008})
    AAdd(aFields, {"Filial",              STR0009,  "string", STR0009})
    AAdd(aFields, {"CodigoTarefa",        STR0010,  "string", STR0010})
    AAdd(aFields, {"DescricaoTarefa",     STR0011,  "string", STR0011})
    AAdd(aFields, {"CodigoVerba",         STR0012,  "string", STR0012})
    AAdd(aFields, {"ValorAntigo",         STR0013,  "number", STR0013})
    AAdd(aFields, {"Percentual",          STR0014,  "number", STR0014})
    AAdd(aFields, {"ValorAdicional",      STR0015,  "number", STR0015})
    AAdd(aFields, {"ValorReajuste",       STR0016,  "number", STR0016})
    AAdd(aFields, {"NovoValor",           STR0017,  "number", STR0017})
    AAdd(aFields, {"Arredondamento",      STR0018,  "number", STR0018})
    AAdd(aFields, {"DataReajuste",        STR0019,  "string", STR0019})
    AAdd(aFields, {"TipoRelatorio",       STR0020,  "string", STR0020})
    self:addNestedProperty("Tasks", STR0021, STR0021, NIL, aFields)

    aFields := {}
    AAdd(aFields, {"Empresa",             STR0022,  "string", STR0022})
    AAdd(aFields, {"Filial",              STR0023,  "string", STR0023})
    AAdd(aFields, {"NomeFilial",          STR0024,  "string", STR0024})
    AAdd(aFields, {"Matricula",           STR0025,  "string", STR0025})
    AAdd(aFields, {"NomeFuncionario",     STR0026,  "string", STR0026})
    AAdd(aFields, {"CentroCusto",         STR0027,  "string", STR0027})
    AAdd(aFields, {"CodigoFuncao",        STR0028,  "string", STR0028})
    AAdd(aFields, {"Categoria",           STR0029,  "string", STR0029})
    AAdd(aFields, {"Sindicato",           STR0030,  "string", STR0030})
    AAdd(aFields, {"DataAdmissao",        STR0031,  "string", STR0031})
    AAdd(aFields, {"TipoRelatorio",       STR0032,  "string", STR0032})
    AAdd(aFields, {"EmployeeTasks",       STR0033,  "string", STR0033})
    self:addNestedProperty("Employees", STR0034, STR0034, NIL, aFields)

    aTaskFields := {}
    AAdd(aTaskFields, {"CodigoTarefa",      STR0035,  "string", STR0035})
    AAdd(aTaskFields, {"CodigoVerba",       STR0036,  "string", STR0036})
    AAdd(aTaskFields, {"DataTarefaDe",      STR0037,  "string", STR0037})
    AAdd(aTaskFields, {"DataTarefaAte",     STR0038,  "string", STR0038})
    AAdd(aTaskFields, {"ValorAntigo",       STR0039,  "number", STR0039})
    AAdd(aTaskFields, {"Percentual",        STR0040,  "number", STR0040})
    AAdd(aTaskFields, {"ValorAdicional",    STR0041,  "number", STR0041})
    AAdd(aTaskFields, {"ValorReajuste",     STR0042,  "number", STR0042})
    AAdd(aTaskFields, {"NovoValor",         STR0043,  "number", STR0043})
    AAdd(aTaskFields, {"Arredondamento",    STR0044,  "number", STR0044})
    self:transformInNested("EmployeeTasks", NIL, aTaskFields)

    aFields := {}
    AAdd(aFields, {"TaskTotals",          STR0045,       "string", STR0045})
    AAdd(aFields, {"EmployeeTotals",      STR0046,       "string", STR0046})
    self:addNestedProperty("Totals", STR0091, STR0091, NIL, aFields)

    // Definir estrutura dos totais de tarefas
    aTaskTotalsFields := {}
    AAdd(aTaskTotalsFields, {"Empresa",         STR0047,              "string", STR0047})
    AAdd(aTaskTotalsFields, {"Filial",          STR0048,              "string", STR0048})
    AAdd(aTaskTotalsFields, {"CodigoTarefa",    STR0049,              "string", STR0049})
    AAdd(aTaskTotalsFields, {"DescricaoTarefa", STR0050,              "string", STR0050})
    AAdd(aTaskTotalsFields, {"CodigoVerba",     STR0051,              "string", STR0051})
    AAdd(aTaskTotalsFields, {"ValorAntigo",     STR0052,              "number", STR0052})
    AAdd(aTaskTotalsFields, {"Percentual",      STR0053,              "number", STR0053})
    AAdd(aTaskTotalsFields, {"ValorAdicional",  STR0054,              "number", STR0054})
    AAdd(aTaskTotalsFields, {"ValorReajuste",   STR0055,              "number", STR0055})
    AAdd(aTaskTotalsFields, {"NovoValor",       STR0056,              "number", STR0056})
    AAdd(aTaskTotalsFields, {"Arredondamento",  STR0057,              "number", STR0057})
    AAdd(aTaskTotalsFields, {"DataReajuste",    STR0058,              "string", STR0058})
    AAdd(aTaskTotalsFields, {"TipoRelatorio",   STR0059,              "string", STR0059})
    AAdd(aTaskTotalsFields, {"QtdTarefas",      STR0060,              "number", STR0060})
    self:transformInNested("TaskTotals", NIL, aTaskTotalsFields)

    // Definir estrutura dos totais de funcionários
    aEmployeeTotalsFields := {}
    AAdd(aEmployeeTotalsFields, {"Empresa",             STR0061,              "string", STR0061})
    AAdd(aEmployeeTotalsFields, {"Filial",              STR0062,              "string", STR0062})
    AAdd(aEmployeeTotalsFields, {"QtdFuncionarios",     STR0063,              "number", STR0063})
    AAdd(aEmployeeTotalsFields, {"QtdTarefas",          STR0064,              "number", STR0064})
    AAdd(aEmployeeTotalsFields, {"ValorAntigo",         STR0065,              "number", STR0065})
    AAdd(aEmployeeTotalsFields, {"Percentual",          STR0066,              "number", STR0066})
    AAdd(aEmployeeTotalsFields, {"ValorAdicional",      STR0067,              "number", STR0067})
    AAdd(aEmployeeTotalsFields, {"ValorReajuste",       STR0068,              "number", STR0068})
    AAdd(aEmployeeTotalsFields, {"NovoValor",           STR0069,              "number", STR0069})
    AAdd(aEmployeeTotalsFields, {"Arredondamento",      STR0070,              "number", STR0070})
    AAdd(aEmployeeTotalsFields, {"DataReajuste",        STR0071,              "string", STR0071})
    AAdd(aEmployeeTotalsFields, {"TipoRelatorio",       STR0072,              "string", STR0072})
    self:transformInNested("EmployeeTotals", NIL, aEmployeeTotalsFields)

    // Parâmetros do relatório
    self:oSchema:addParameter("PAR_CODTARDE",       STR0073,     "string", .F.)
    self:oSchema:addParameter("PAR_CODTARATE",      STR0074,     "string", .F.)
    self:oSchema:addParameter("PAR_CRITOARRED",     STR0075,     "string", .F.)
    self:oSchema:addParameter("PAR_ARREDVLR",       STR0076,     "number", .F.)
    self:oSchema:addParameter("PAR_ATUTAR",         STR0077,     "string", .F.)
    self:oSchema:addParameter("PAR_TIPOREL",        STR0078,     "string", .F.)
    self:oSchema:addParameter("PAR_FILDE",          STR0079,     "string", .F.)
    self:oSchema:addParameter("PAR_FILATE",         STR0080,     "string", .F.)
    self:oSchema:addParameter("PAR_CCDE",           STR0081,     "string", .F.)
    self:oSchema:addParameter("PAR_CCATE",          STR0082,     "string", .F.)
    self:oSchema:addParameter("PAR_MATDE",          STR0083,     "string", .F.)
    self:oSchema:addParameter("PAR_MATATE",         STR0084,     "string", .F.)
    self:oSchema:addParameter("PAR_FUNCDE",         STR0085,     "string", .F.)
    self:oSchema:addParameter("PAR_FUNCATE",        STR0086,     "string", .F.)
    self:oSchema:addParameter("PAR_CATEGORIA",      STR0087,     "string", .F.)
    self:oSchema:addParameter("PAR_DTREAJ",         STR0088,     "date",   .F.)
    self:oSchema:addParameter("PAR_ATUSUBSEQ",      STR0089,     "string", .F.)
    self:oSchema:addParameter("PAR_TIPAUM",         STR0090,     "string", .F.)

    // Endpoints para lookup
    self:setCustomURL("PAR_CODTARDE",           "/api/rh/smartview/v1/options/GPEParams/getRCC/S070/" + cCodeSizeS070 + "/" + cDescSizeS070, 2)
    self:setCustomURL("PAR_CODTARATE",          "/api/rh/smartview/v1/options/GPEParams/getRCC/S070/" + cCodeSizeS070 + "/" + cDescSizeS070, 2)
    self:setCustomURL("PAR_FILDE",              "/api/rh/smartview/v1/options/GPEParams/getBranches", 2)
    self:setCustomURL("PAR_FILATE",             "/api/rh/smartview/v1/options/GPEParams/getBranches", 2)
    self:setCustomURL("PAR_MATDE",              "/api/framework/v1/genericLookupService/smartview/SRA", 2)
    self:setCustomURL("PAR_MATATE",             "/api/framework/v1/genericLookupService/smartview/SRA", 2)
    self:setCustomURL("PAR_CCDE",               "/api/framework/v1/genericLookupService/smartview/CTT", 2)
    self:setCustomURL("PAR_CCATE",              "/api/framework/v1/genericLookupService/smartview/CTT", 2)
    self:setCustomURL("PAR_FUNCDE",             "/api/framework/v1/genericLookupService/smartview/SRJ", 2)
    self:setCustomURL("PAR_FUNCATE",            "/api/framework/v1/genericLookupService/smartview/SRJ", 2)
    self:setCustomURL("PAR_CRITOARRED",         "/api/rh/smartview/v1/options/GPER1004/getRoundingType", 1)
    self:setCustomURL("PAR_ATUTAR",             "/api/rh/smartview/v1/options/GPER1004/getUpdateType", 1)
    self:setCustomURL("PAR_TIPOREL",            "/api/rh/smartview/v1/options/GPER1004/getReportType", 1)
    self:setCustomURL("PAR_ATUSUBSEQ",          "/api/rh/smartview/v1/options/GPER1004/getUpdateSubsequent", 1)
    self:setCustomURL("PAR_TIPAUM",             "/api/rh/smartview/v1/options/GPER1004/getIncreaseType", 1)
    self:setCustomURL("PAR_CATEGORIA",          "/api/rh/smartview/v1/options/GPEParams/getSX5/28", 1)

return self:oSchema
