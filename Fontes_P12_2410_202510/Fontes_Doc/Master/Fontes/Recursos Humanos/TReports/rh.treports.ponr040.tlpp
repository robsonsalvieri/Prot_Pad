#Include "msobject.ch"
#Include "totvs.framework.treports.integratedprovider.th"
#Include "tlpp-core.th"
#Include "tlpp-rest.th"
#Include "PONCALEN.CH"
#Include "rh.treports.ponr040.ch"

namespace totvs.protheus.rh.treportsintegratedprovider
 
@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAPON", tables="SRA,CTT,SR6", name="Rel. de Divergências do Ponto Eletrônico", country="ALL", initialRelease="12.1.2210")
Class PONR040TReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider
    Public Method new() as object
    Public Method getDescription() as character
    Public Method getData() as object
    Public Method getSchema() as object
EndClass

Method new() Class PONR040TReportsBusinessObject
    _Super:new()

    //Define a Área
    self:appendArea(STR0001) // RH
    
    //Define o nome do Objeto de Negócio
    self:setDisplayName(STR0002) // Rel. de Divergências do Ponto Eletrônico

Return self

/*/{Protheus.doc} getDescription
Metodo que retorna a descrição do objeto de negócio.
@type   Method
@author Marco Nakazawa
@since  21/08/2023
/*/
Method getDescription() as character class PONR040TReportsBusinessObject 
Return (STR0003) // Emite um relatório de divergências nas marcacoes do ponto eletrônico

Method getData(nPage as numeric, oFilter as object) as object class PONR040TReportsBusinessObject
Local aHENaoAut     := {}											as Array
Local aTabCalend    := {}											as Array
Local aTabPadrao    := {}											as Array
Local aTurnos       := {}											as Array
Local aMarcacoes    := {}											as Array
Local aNewMarc      := {}											as Array
Local aIntervalo    := {}											as Array
Local aSiglaMarc    := {}											as Array
Local aDivergs      := {}											as Array
Local aSitFil		:= {}											as Array
Local aCatFil		:= {}											as Array
Local lHExtr        := .T.											as Logical
Local lDivgMarc     := .T.											as Logical
Local lDivgInt      := .T.											as Logical
Local lDivgFun      := .T.											as Logical
Local lIntMaior     := .F.											as Logical
Local lIntMenor     := .F.											as Logical
Local cSitParam     := ""											as Character
Local cCatParam     := ""											as Character
Local cFilialAnt    := ""											as Character
Local cTnoAnt       := ""											as Character
Local cTipAfas      := ""											as Character
Local cMotivo       := ""											as Character
Local cMarcs        := ""											as Character
Local cFilDe        := ""											as Character
Local cFilAte       := ""											as Character
Local cMatDe      	:= ""											as Character
Local cMatAte      	:= ""											as Character
Local cCcDe      	:= ""											as Character
Local cCcAte 	    := ""											as Character
Local cTurnoDe 	    := ""											as Character
Local cTurnoAte	    := ""											as Character
Local cNomeDe	    := ""											as Character
Local cNomeAte	    := ""											as Character
Local cDataIni      := ""											as Character
Local cOrdem        := ""											as Character
Local cAliasQry     := ""											as Character
Local cValidFil		:= fValidFil()									as Character
Local cAcessaSRA	:= &("{|| " + ChkRH("PONR110","SRA","2") + "}")	as Character
local dDataIni      := sToD("  /  /  ")								as Date
local dDataFim      := sToD("  /  /  ")								as Date
local dData         := sToD("  /  /  ")								as Date
local dDtAfas       := sToD("  /  /  ")								as Date
local dDtRet        := sToD("  /  /  ")								as Date
local nI            := 0											as Numeric
local nX            := 0											as Numeric
local nY            := 0											as Numeric
local nW            := 0											as Numeric
local nTolInt 	    := 0											as Numeric
local nLenMarc 	    := 0											as Numeric
local nLenCalend 	:= 0											as Numeric
local nPos1E        := 0											as Numeric
local nTabMarc      := 0											as Numeric
local nQuant        := 0											as Numeric
local nIntReal      := 0											as Numeric
local nIntProg      := 0											as Numeric
local nHrReal       := 0											as Numeric
local nPosInt       := 0											as Numeric
local nDivergs      := 0											as Numeric
local nParamOrder	:= 1											as numeric
local oJparams														as Json
local oStatement													as Object

Private dPerIni		:= cToD("  /  /  ")
Private dPerFim		:= cToD("  /  /  ")

// Carrega as siglas das marcações
TabMarc('SPJ',@aSiglaMarc)

// Carrega os parâmetros informados
oJParams := oFilter:getParameters()

dDataIni    := If(!Empty(oJParams["data1",1]), sToD(StrTran(SubStr(oJParams["data1",1],1,10),"-","")),Date())
dDataFim    := If(!Empty(oJParams["data2",1]), sToD(StrTran(SubStr(oJParams["data2",1],1,10),"-","")),Date())
cSitParam   := oJParams["situacoes",1]
cCatParam   := oJParams["categorias",1]
lHExtr      := If(oJParams["heNAut",1], .T., .F.)
lDivgMarc   := If(oJParams["divergMarcs",1], .T., .F.)
lDivgInt    := If(oJParams["divergInt",1], .T., .F.)
lDivgFun    := If(oJParams["divergFunc",1], .T., .F.)
cDataIni    := dToS(dDataIni)

// Filtro das datas
If(dDataIni > dDataFim, dDataFim := dDataIni, Nil)

// Validação do filtro "Filial De" e "Filial Até" para utilização na Query
If (!Empty(oJParams['filial1', 1]), cFilDe := oJParams['filial1', 1], cFilDe := Space(GetSX3Cache("RA_FILIAL", "X3_TAMANHO")))
If (!Empty(oJParams['filial2', 1]), cFilAte := oJParams['filial2', 1], cFilAte := Replicate("Z", GetSX3Cache("RA_FILIAL", "X3_TAMANHO")))

// Validação do filtro "Matrícula De" e "Matrícula Até" para utilização na Query
If (!Empty(oJParams['mat1', 1]), cMatDe := oJParams['mat1', 1], cMatDe := Space(GetSX3Cache("RA_MAT", "X3_TAMANHO")))
If (!Empty(oJParams['mat2', 1]), cMatAte := oJParams['mat2', 1], cMatAte := Replicate("Z", GetSX3Cache("RA_MAT", "X3_TAMANHO")))

// Validação do filtro "Centro de Custo De" e "Centro de Custo Até" para utilização na Query
If (!Empty(oJParams['cc1', 1]), cCCDe := oJParams['cc1', 1], cCCDe := Space(GetSX3Cache("RA_CC", "X3_TAMANHO")))
If (!Empty(oJParams['cc2', 1]), cCCAte := oJParams['cc2', 1], cCCAte := Replicate("Z", GetSX3Cache("RA_CC", "X3_TAMANHO")))

// Validação do filtro "Turno De" e "Turno Até" para utilização na Query
If (!Empty(oJParams['turno1', 1]), cTurnoDe := oJParams['turno1', 1], cTurnoDe := Space(GetSX3Cache("RA_TNOTRAB", "X3_TAMANHO")))
If (!Empty(oJParams['turno2', 1]), cTurnoAte := oJParams['turno2', 1], cTurnoAte := Replicate("Z", GetSX3Cache("RA_TNOTRAB", "X3_TAMANHO")))

// Validação do filtro "Nome De" e "Nome Até" para utilização na Query
If (!Empty(oJParams['nome1', 1]), cNomeDe := oJParams['nome1', 1], cNomeDe := Space(GetSX3Cache("RA_NOME", "X3_TAMANHO")))
If (!Empty(oJParams['nome2', 1]), cNomeAte := oJParams['nome2', 1], cNomeAte := Replicate("Z", GetSX3Cache("RA_NOME", "X3_TAMANHO")))

// Filtro da Situação dos funcionários
If (!Empty(cSitParam), aSitFil := StrTokArr(cSitParam,","), aSitFil := StrTokArr(" ,A,D,F,T",","))

// Filtro da Categoria dos funcionários
If (!Empty(cCatParam), aCatFil := StrTokArr(cCatParam,","), aCatFil := StrTokArr("A,C,D,E,G,H,I,J,M,P,S,T,*",","))

cQuery :=	"SELECT "
cQuery +=		"SRA.RA_FILIAL, "
cQuery +=		"SRA.RA_MAT, "
cQuery +=		"SRA.RA_NOME, "
cQuery +=		"SRA.RA_CC, "
cQuery +=		"SRA.RA_TNOTRAB, "
cQuery +=		"SRA.RA_DEMISSA, "
cQuery +=		"SRA.RA_ADMISSA, "
cQuery +=		"SRA.RA_SITFOLH, "
cQuery +=		"SRA.RA_SEQTURN, "
cQuery +=		"SRA.R_E_C_N_O_, "
cQuery +=		"CTT.CTT_DESC01, "
cQuery +=		"SR6.R6_TURNO, "
cQuery +=		"SR6.R6_DESC "
cQuery +=	"FROM " + RetSQLName("SRA") + " SRA "
cQuery +=	"INNER JOIN " + RetSQLName("CTT") + " CTT ON " + FWJoinFilial("CTT", "SRA") + " AND CTT.CTT_CUSTO = SRA.RA_CC AND CTT.D_E_L_E_T_ = ? "		// 1
cQuery +=	"INNER JOIN " + RetSQLName("SR6") + " SR6 ON " + FWJoinFilial("SR6", "SRA") + " AND SR6.R6_TURNO = SRA.RA_TNOTRAB AND SR6.D_E_L_E_T_ = ? "	// 2
cQuery +=	"WHERE SRA.RA_FILIAL BETWEEN ? AND ? "					// 3 e 4
cQuery +=		"AND SRA.RA_CC BETWEEN ? AND ? "					// 5 e 6
cQuery +=		"AND SRA.RA_MAT BETWEEN ? AND ? "					// 7 e 8
cQuery +=		"AND SRA.RA_NOME BETWEEN ? AND ? "					// 9 e 10
cQuery +=		"AND SRA.RA_SITFOLH IN (?) "						// 11
cQuery +=		"AND SRA.RA_CATFUNC IN (?) "						// 12
cQuery +=		"AND (SRA.RA_DEMISSA = ? OR SRA.RA_DEMISSA >= ?) "	// 13 e 14
cQuery +=		"AND SRA.D_E_L_E_T_ = ? "							// 15

cQuery := ChangeQuery(cQuery)

oStatement := FwExecStatement():New(cQuery)

oStatement:SetString(nParamOrder++,  " ")		// 1
oStatement:SetString(nParamOrder++,  " ")		// 2
oStatement:SetString(nParamOrder++,  cFilDe)	// 3
oStatement:SetString(nParamOrder++,  cFilAte)	// 4
oStatement:SetString(nParamOrder++,  cCCDe)		// 5
oStatement:SetString(nParamOrder++,  cCCAte)	// 6
oStatement:SetString(nParamOrder++,  cMatDe)	// 7
oStatement:SetString(nParamOrder++,  cMatAte)	// 8
oStatement:SetString(nParamOrder++,  cNomeDe)	// 9
oStatement:SetString(nParamOrder++,  cNomeAte)	// 10
oStatement:SetIn(nParamOrder++,  aSitFil)		// 11
oStatement:SetIn(nParamOrder++,  aCatFil)		// 12
oStatement:SetString(nParamOrder++,  " ")		// 13
oStatement:SetString(nParamOrder++,  cDataIni)	// 14
oStatement:SetString(nParamOrder++,  " ")		// 15

// Abre a tabela SRA para a criação do calendário
DbSelectArea("SRA")
DbSelectArea("SPC")

dDataBase := If(!Empty(dDataFim), dDataFim, dDataBase)

cAliasQry := oStatement:OpenAlias()

While !(cAliasQry)->(Eof())

	// Consiste controle de acessos e filiais válidas
	If !(cAliasQry)->RA_FILIAL $ cValidFil .Or. !Eval(cAcessaSRA)
		(cAliasQry)->(DBSkip())
		Loop
	EndIf

	// Posiciona o registro da query na SRA (necessário para a criação do calendário)
	SRA->(dbGoto((cAliasQry)->R_E_C_N_O_))

    // Verifica se precisa pegar novamente os eventos de HE não autorizada e o conteúdo do parâmetro MV_DIVTINT
    If (cAliasQry)->RA_FILIAL <> cFilialAnt .Or. (cAliasQry)->RA_TNOTRAB <> cTnoAnt
        If (cAliasQry)->RA_FILIAL <> cFilialAnt
            nTolInt := __Min2Hrs((SuperGetMv("MV_DIVTINT", NIL, 0, (cAliasQry)->RA_FILIAL)))
			//-- Define o periodo de Apuracao, de acordo com MV_PAPONTA
			If !PerAponta(@dPerIni, @dPerFim)
				Return( NIL )
			EndIf
        EndIf
            
        cFilialAnt     := (cAliasQry)->RA_FILIAL
        cTnoAnt     := (cAliasQry)->RA_TNOTRAB
        aHENaoAut   := fBuscHENA((cAliasQry)->RA_FILIAL, (cAliasQry)->RA_TNOTRAB)
    EndIf

	aPeriodos := Monta_Per( dDataIni, dDataFim, (cAliasQry)->RA_FILIAL, (cAliasQry)->RA_MAT, dPerIni, dPerFim)

	For nW := 1 To Len(aPeriodos)
		// Busca as marcações e monta o calendário para analise das divergências
		aTabCalend	:= {}
		aTabPadrao	:= {}
		aTurnos		:= {}
		aMarcacoes	:= {}
		aNewMarc    := {}
		
		GetMarcacoes(	@aMarcacoes				,;	//Marcacoes dos Funcionarios
						aTabCalend				,;	//Calendario de Marcacoes
						@aTabPadrao				,;	//Tabela Padrao
						@aTurnos				,;	//Turnos de Trabalho
						aPeriodos[nW, 1]		,;	//Periodo Inicial
						aPeriodos[nW, 2]		,;	//Periodo Final
						(cAliasQry)->RA_FILIAL	,;	//Filial
						(cAliasQry)->RA_MAT		,;	//Matricula
						(cAliasQry)->RA_TNOTRAB	,;	//Turno
						(cAliasQry)->RA_SEQTURN	,;	//Sequencia de Turno
						(cAliasQry)->RA_CC		,;	//Centro de Custo
						"SP8"					,;	//Alias para Carga das Marcacoes
						.F.    					,;	//Se carrega Recno em aMarcacoes
						.T.      				,;	//Se considera Apenas Ordenadas
						.T. 					,;	//Se Verifica as Folgas Automaticas
						.F.    			 		,;	//Se Grava Evento de Folga Automatica Periodo Anterior
						Nil						,;	//17 -> Se Carrega as Marcacoes Automaticas
						Nil	    				,;	//18 -> Registros de Marcacoes Automaticas que deverao ser Desprezadas
						Nil						,;	//19 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
						Nil						,;	//20 -> Se Considera o Periodo de Apontamento das Marcacoes
						Nil						,;	//21 -> Se Efetua o Sincronismo dos Horarios na Criacao do Calendario
						Nil						,;  //22 -> Se carrega as marcacoes desconsideradas (Uso com lPort1510)
						.T.						 ;  //23 -> Se carrega as marcacoes das duas tabelas SP8 e SPG
		)
		
		If (Empty(aMarcacoes), (cAliasQry)->(dbSkip()), Nil)

		nLenMarc := Len(aMarcacoes)

		For nI := 1 To nLenMarc
			IF (cOrdem := aMarcacoes[nI , 03]) == "ZZ"
				Loop
			EndIf	
			
			aAdd(aNewMarc , {})

			For nX := nI To nLenMarc
				IF aMarcacoes[nX , 03] == cOrdem .And. aMarcacoes[nX , 03] != "ZZ"
					aAdd(aNewMarc[Len(aNewMarc)] , aClone(aMarcacoes[nX]))
					aMarcacoes[nX , 03] := "ZZ"
				Else
					Exit
				EndIf
			Next nX
		Next nI
		
		aMarcacoes  := aClone(aNewMarc)
		//-- Monta o Array aImp com as ocorrências do período
		nLenMarc    := Len(aMarcacoes)
		nLenCalend  := Len(aTabCalend)

		For nI := 1 to nLenMarc
			//-- Reinicializa Variaveis
			aIntervalo  := {}
			cOrdem      := aMarcacoes[nI, 1, 3]
			cMotivo     := ""
			cTraba      := ''
			cTipAfas    := ""
			cMarcs      := ""
			dData       := aMarcacoes[nI, 1, 1]
			dDtAfas     := CtoD("  /  /  ")
			dDtRet      := CtoD("  /  /  ")
			nQuant      := 0
			nPos1E      := 0
			
			//--Se Existe Calendario para a Ordem Obtem Numero de Marcacoes Possiveis
			nPos1E := aScan(aTabCalend, {|x| x[1] == aMarcacoes[nI, 1, 1] .And. x[4] == '1E'})

			If nPos1E > 0
				//-- Calcula a Quantidade de Marcacoes possiveis de acordo com o Calendario do Funcionario
				nTabMarc := 0
				For nY := nPos1E to nLenCalend
					If aTabCalend[nY,2] <> cOrdem
						Exit
					EndIf
					nTabMarc++
				Next
			EndIf
			
			If nPos1E > 0
				cTraba := aTabCalend[nPos1E, 6]
				//-- Corre Todas as Marcacoes realizadas de acordo com a Ordem
				For nY := nPos1E to nLenCalend
					If aTabCalend[nY,2] <> cOrdem
						Exit
					EndIf
					nQuant++                                                
					//-- Se segundo a Tabela Padrao Existir Intervalo
					//-- Armazena-o para posterior verificacao
					If aTabCalend[nY,9] > 0
						aAdd(aIntervalo, {fNsToDh(fDhToNs(aTabCalend[nY + 1, CALEND_POS_DATA], aTabCalend[nY + 1, CALEND_POS_HORA]) - fDHtoNS(aTabCalend[nY, CALEND_POS_DATA], aTabCalend[nY, CALEND_POS_HORA]),"H"),aTabCalend[nY,4]})
					EndIf
				Next
			EndIf
			
			//-- Vailidação das quantidade de marcações (Marcações ímpares, mais marcações ou menos marcações do programado)
			If lDivgMarc
				cMotivo := ""

				//-- Marcações ímpares
				If Len(aMarcacoes[nI]) % 2 > 0
					cMotivo := STR0004 // Número de marcações Impar
					cMarcs  := fFormtMarc(aMarcacoes[nI])
					aAdd(aDivergs,{;
						(cAliasQry)->RA_FILIAL,;
						AllTrim((cAliasQry)->RA_MAT),;
						AllTrim((cAliasQry)->RA_NOME),;
						AllTrim((cAliasQry)->RA_CC),;
						AllTrim((cAliasQry)->CTT_DESC01),;
						AllTrim((cAliasQry)->RA_TNOTRAB),;
						AllTrim((cAliasQry)->R6_DESC),;
						dData,; 
						cMarcs,;
						cMotivo;
					})
					cMotivo := ""
				EndIf
				
				//-- Mais ou menos marcações que o programado
				If Len(aMarcacoes[nI]) < nQuant
					cMotivo := STR0005 // Menos marcações que o programado
				ElseIf Len(aMarcacoes[nI]) > nQuant .And. nQuant > 0
					cMotivo := STR0006 // Mais marcações que o programado
				EndIf

				If !Empty(cMotivo)
					cMarcs := fFormtMarc(aMarcacoes[nI])
					aAdd(aDivergs,{;
						(cAliasQry)->RA_FILIAL,;
						AllTrim((cAliasQry)->RA_MAT),;
						AllTrim((cAliasQry)->RA_NOME),;
						AllTrim((cAliasQry)->RA_CC),;
						AllTrim((cAliasQry)->CTT_DESC01),;
						AllTrim((cAliasQry)->RA_TNOTRAB),;
						AllTrim((cAliasQry)->R6_DESC),;
						dData,; 
						cMarcs,;
						cMotivo;
					})
				EndIf
			EndIf
			
			//-- Validação da horas extras não autorizadas
			If lHExtr .And. Len(aHENaoAut) > 0
				cMotivo := ""

				For nY := 1 to Len(aHENaoAut)
					If SPC->(dbSeek(fFilFunc('SPC')+(cAliasQry)->RA_MAT+aHENaoAut[nY]+DtoS(dData), .F.))
						cMotivo := STR0007 // Hora Extra não autorizada
						Exit
					EndIf
				Next

				If !Empty(cMotivo)
					cMarcs := fFormtMarc(aMarcacoes[nI])
					aAdd(aDivergs,{;
						(cAliasQry)->RA_FILIAL,;
						AllTrim((cAliasQry)->RA_MAT),;
						AllTrim((cAliasQry)->RA_NOME),;
						AllTrim((cAliasQry)->RA_CC),;
						AllTrim((cAliasQry)->CTT_DESC01),;
						AllTrim((cAliasQry)->RA_TNOTRAB),;
						AllTrim((cAliasQry)->R6_DESC),;
						dData,; 
						cMarcs,;
						cMotivo;
					})
				EndIf
			EndIf
			
			//-- Validação do Intervalo (Intervalo realizado é maior ou menor que o planejado)
			If lDivgInt
				For nY := 1 To Len(aIntervalo)
					cMotivo     := ""
					nIntReal    := 0
					nIntProg    := 0 
					nHrReal     := 0
					
					//-- Localiza o numero da posicao da marcacao pela sigla.
					nPosInt := Ascan(aSiglaMarc, {|x| x == aIntervalo[nY, 2]})
					
					lIntMenor := lIntMaior := .F.
					If nPosInt + 1 <= Len(aMarcacoes[nI])
						If  Empty(nTolInt)
							nIntReal    := fDhToNs(aMarcacoes[nI, nPosInt + 1, 1], aMarcacoes[nI, nPosInt + 1, 2]) - fDhToNs(aMarcacoes[nI, nPosInt, 1], aMarcacoes[nI, nPosInt, 2])
							nIntProg    := fDhToNs(,aIntervalo[nY,1])
							lIntMenor   := (nIntReal) < (nIntProg)  
							lIntMaior   :=	(nIntReal) > (nIntProg)
						Else 
							
							CalcHours(  aMarcacoes[nI, nPosInt + 1, 1]		,;	//01 -> Data 1
										aMarcacoes[nI, nPosInt + 1, 2]		,;	//02 -> Hora 1
										aMarcacoes[nI, nPosInt, 1]			,;	//03 -> Data 2
										aMarcacoes[nI, nPosInt, 2]			,;	//04 -> Hora 2
										@nHrReal							,;	//05 -> <@>Horas Normais Apontadas
										Nil									,;	//06 -> <@>Horas Noturnas Apontadas
										.F.									;	//07 -> Apontar Horas Noturnas
									)  
							If nHrReal > SomaHoras(aIntervalo[nY, 1],nTolInt)
								lIntMaior:=.T.
							ElseIf aIntervalo[nY, 1] > SomaHoras(nHrReal,nTolInt)
								lIntMenor:=.T.
							EndIf							 
						EndIf
					EndIf
					
					If lIntMenor
						cMotivo := AllTrim(Str(nY, 2)) + "o. " + STR0008 // Intervalo menor que o programado
					ElseIf lIntMaior
						cMotivo := AllTrim(Str(nY, 2)) + "o. " + STR0009 // Intervalo maior que o programado
					EndIf

					If !Empty(cMotivo)
						cMarcs := fFormtMarc(aMarcacoes[nI])
						aAdd(aDivergs,{;
							(cAliasQry)->RA_FILIAL,;
							AllTrim((cAliasQry)->RA_MAT),;
							AllTrim((cAliasQry)->RA_NOME),;
							AllTrim((cAliasQry)->RA_CC),;
							AllTrim((cAliasQry)->CTT_DESC01),;
							AllTrim((cAliasQry)->RA_TNOTRAB),;
							AllTrim((cAliasQry)->R6_DESC),;
							dData,; 
							cMarcs,;
							cMotivo;
						})
					EndIf
				Next
			EndIf
			
			//-- Validação da situação do funcionário (Marcações antes da admissão ou após a demissão)
			If lDivgFun
				cMotivo := ""

				//-- Marcações Anteriores a Admisssão ou Posteriores a Demissão
				If !Empty((cAliasQry)->RA_DEMISSA) .And. dToS(dData) > (cAliasQry)->RA_DEMISSA
					cMotivo :=  STR0010 // Marcações após a demissão

					cMarcs := fFormtMarc(aMarcacoes[nI])
					aAdd(aDivergs,{;
						(cAliasQry)->RA_FILIAL,;
						AllTrim((cAliasQry)->RA_MAT),;
						AllTrim((cAliasQry)->RA_NOME),;
						AllTrim((cAliasQry)->RA_CC),;
						AllTrim((cAliasQry)->CTT_DESC01),;
						AllTrim((cAliasQry)->RA_TNOTRAB),;
						AllTrim((cAliasQry)->R6_DESC),;
						dData,; 
						cMarcs,;
						cMotivo;
					})
				EndIf
				
				//-- Marca‡”es durante Ferias ou Afastamentos
				If fAfasta((cAliasQry)->RA_FILIAL, (cAliasQry)->RA_MAT, dData, @dDtafas, @dDtRet, @cTipAfas) .And. aTabCalend[nPos1E,10] # 'E'
					If (cTipAfas == 'F', cMotivo := STR0011, cMotivo := STR0012)
					
					cMarcs := fFormtMarc(aMarcacoes[nI])
					
					aAdd(aDivergs,{;
						(cAliasQry)->RA_FILIAL,;
						AllTrim((cAliasQry)->RA_MAT),;
						AllTrim((cAliasQry)->RA_NOME),;
						AllTrim((cAliasQry)->RA_CC),;
						AllTrim((cAliasQry)->CTT_DESC01),;
						AllTrim((cAliasQry)->RA_TNOTRAB),;
						AllTrim((cAliasQry)->R6_DESC),;
						dData,; 
						cMarcs,;
						cMotivo;
					})
				EndIf
			EndIf
			
		Next
	Next

    (cAliasQry)->( dbSkip())
EndDo

nDivergs    := Len(aDivergs)

If nDivergs > 0
    For nI := 1 To nDivergs
        self:oData:appendData({;
            "RA_FILIAL": aDivergs[nI, 1],;
            "RA_MAT": aDivergs[nI, 2],;
            "RA_NOME": aDivergs[nI, 3],;
            "RA_CC": aDivergs[nI, 4],;
            "CTT_DESC01": aDivergs[nI, 5],;
            "RA_TNOTRAB": aDivergs[nI, 6],;
            "R6_DESC": aDivergs[nI, 7],;
            "DATA": totvs.framework.treports.date.dateToTimeStamp(aDivergs[nI, 8]),;
            "MARCACOES": AllTrim(aDivergs[nI, 9]),;
            "OCORRENCIAS": aDivergs[nI, 10];
        })
    Next
EndIf

SRA->(DbCloseArea())
SPC->(DbCloseArea())
(cAliasQry)->( DBCloseArea())

Return self:oData
 
/*/{Protheus.doc} getSchema
Metodo que retorna a estrutura dos campos que serão enviados para o Smart View
@type   Method
@author Marco Nakazawa
@since  21/08/2023
/*/
Method getSchema() as object class PONR040TReportsBusinessObject
local aFildsSRA as array
local aFildsCTT as array
local aFildsSR6 as array

aFildsSRA := {"RA_FILIAL", "RA_MAT", "RA_NOME", "RA_CC", "CTT_DESC01", "RA_TNOTRAB", "R6_DESC"}
aFildsCTT := {"CTT_DESC01"}
aFildsSR6 := {"R6_DESC"}

self:oSchema:aliasToSchema("SRA", aFildsSRA)
self:oSchema:aliasToSchema("CTT", aFildsCTT)
self:oSchema:aliasToSchema("SR6", aFildsSR6)

self:addParameter("filial1",        STR0013,    "string",   .F.)
self:addParameter("filial2",        STR0014,    "string",   .F.)
self:addParameter("cc1",            STR0015,    "string",   .F.)
self:addParameter("cc2",            STR0016,    "string",   .F.)
self:addParameter("turno1",         STR0017,    "string",   .F.)
self:addParameter("turno2",         STR0018,    "string",   .F.)
self:addParameter("mat1",           STR0019,    "string",   .F.)
self:addParameter("mat2",           STR0020,    "string",   .F.)
self:addParameter("nome1",          STR0021,    "string",   .F.)
self:addParameter("nome2",          STR0022,    "string",   .F.)
self:addParameter("situacoes",      STR0023,    "string",   .F.)
self:addParameter("categorias",     STR0024,    "string",   .F.)
self:addParameter("divergFunc",     STR0025,    "boolean",  .F.)
self:addParameter("divergMarcs",    STR0026,    "boolean",  .F.)
self:addParameter("divergInt",      STR0027,    "boolean",  .F.)
self:addParameter("heNAut",         STR0028,    "boolean",  .F.)
self:addParameter("data1",          STR0029,    "date",     .F.)
self:addParameter("data2",          STR0030,    "date",     .F.)

self:oSchema:addProperty("DATA"         , STR0031   , "date"    , STR0031   , "DATA")
self:oSchema:addProperty("MARCACOES"    , STR0032   , "string"  , STR0032   , "MARCACOES")
self:oSchema:addProperty("OCORRENCIAS"  , STR0033   , "string"  , STR0033   , "OCORRENCIAS")

Return self:oSchema

/*/{Protheus.doc} fFormtMarc
Função para retornar todas as marcações em uma string
@type   Function
@author Marco Nakazawa
@since  21/08/2023
/*/
Static Function fFormtMarc(aMarcacoes)
Local cMarcRet      := ""   as Character
Local nI            := 0    as Numeric
Local nLenMarcs     := 0    as Numeric

Default aMarcacoes := {}

nLenMarcs := Len(aMarcacoes)

For nI := 1 to nLenMarcs
    If nI == nLenMarcs
        cMarcRet += StrZero(aMarcacoes[nI, 2], 5, 2)
    Else
        cMarcRet += StrZero(aMarcacoes[nI, 2], 5, 2) + "-"
    EndIf
Next

cMarcRet := StrTran(cMarcRet,".",":")

Return cMarcRet

/*/{Protheus.doc} fBuscHENA
Função para retornar os eventos de hora extra não autorizada
@type   Function
@author Marco Nakazawa
@since  21/08/2023
/*/
Static Function fBuscHENA(cFil,cTurno)
Local aHENaoARet    := {}               as Array
Local cChaveSP4     := ""               as Character

Default cFil        := ""
Default cTurno      := ""

DbSelectArea("SP4")

SP4->(dbSetOrder(1))

If SP4->(DbSeek(xFilial("SP4",cFil) + cTurno)) .Or.;
    SP4->(DbSeek(xFilial("SP4",cFil) + Space(Len(cTurno)))) .Or.;
	SP4->(DbSeek(Space(Len(cFil)) + cTurno)) .Or. ;
	SP4->(DbSeek(Space(Len(cFil)) + Space(Len(cTurno))))
	
    cChaveSP4 := SP4->P4_FILIAL + SP4->P4_TURNO

	While !SP4->(Eof()) .And. SP4->P4_FILIAL + SP4->P4_TURNO == cChaveSP4
		If Len(aHENaoARet) == 0 .Or. aScan(aHENaoARet, SP4->P4_CODNAUT) == 0
			aAdd(aHENaoARet, SP4->P4_CODNAUT)
		EndIf	
		SP4->(DbSkip())
	EndDo								
EndIf

SP4->(DbCloseArea())

Return aHENaoARet

/*/{Protheus.doc} Monta_Per
Cria Array com os Periodos de apontamento conforme as datas passadas
@type  Static Function
@author Cícero Alves
@since 21/03/2022
@param dDataIni, Data, Data inicial para montagem dos períodos
@param dDataFim, Data, Data final para montagem dos períodos
@param cFil, Caractere, Filial do funcionário
@param cMat, Caractere, Matrícula do funcionário
@param dIniAtu, Data, Data inicial do período de apontamento atual 
@param dFimAtu, Data, Data final do período de apontamento atual 
@return aPeriodos, Array, Array com os períodos de apontamento
/*/
Static Function Monta_Per( dDataIni, dDataFim, cFil, cMat, dIniAtu, dFimAtu )
	Local aPeriodos := {}
	Local dAdmissa	:= SRA->RA_ADMISSA
	Local dPerIni   := Ctod("//")
	Local dPerFim   := Ctod("//")
	
	If dDataIni < dIniAtu 
		PerAponta(@dPerIni, @dPerFim, dDataIni)
		If aScan( aPeriodos, { |x| x[1] == dPerIni .And. x[2] == dPerFim } ) == 0.00
			aAdd(aPeriodos, { dPerIni, dPerFim, dPerIni, Min(dPerFim, dDataFim)})
		EndIf
		
	EndIf
	
	If ( aScan( aPeriodos, { |x| x[1] == dIniAtu .And. x[2] == dFimAtu } ) == 0.00 ) // Período atual
		dPerIni := dIniAtu
		dPerFim	:= dFimAtu 
		
		IF !(dPerFim < dDataIni .Or. dPerIni > dDataFim)
			IF ( dPerFim >= dAdmissa )
				aAdd(aPeriodos, { dIniAtu, dFimAtu, Max(dPerIni, dDataIni), Min(dPerFim, dDataFim)})
			EndIF
		Endif
	EndIF
Return( aPeriodos )
