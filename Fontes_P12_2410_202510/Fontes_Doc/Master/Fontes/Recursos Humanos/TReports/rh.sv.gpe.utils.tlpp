#Include "TLPP-CORE.TH"
#Include "TOTVS.CH"
#Include "FWLIBVERSION.ch"
#Include "rh.sv.gpe.utils.ch"
#Include "FILEIO.ch"

/*/{Protheus.doc} GPESmartViewUtils
    Definição de métodos que são comuns em diferentes objetos de negócio do Smart View ou para a execução em segundo plano do Schedule.
    @type Class
    @version 12.1.2310
    @author arthur.sales
    @since 22/04/2024
/*/
Class GPESmartViewUtils
    // Declaração dos métodos da classe
    Static Method GetSQLIN()        As Character
    Static Method GetCustomFields() As Character
    Static Method SetCustomFields() As Variant
    Static Method CreateLog()       As Variant
    Static Method ValidBackGExec()  As Logical
    Static Method getLogoSV()       As Character
EndClass

/*/{Protheus.doc} GetSQLIN
    Monta uma string para uma expressão IN para o SQL.
    @type Method
    @version 12.1.2310
    @author arthur.sales
    @since 22/04/2024
    @param cCont, Character, Conteúdo que será transformado na expressão IN
    @param nSize, Numeric, Tamanho do campo
    @return Character, Expressão IN do SQL
/*/
Method GetSQLIN(cCont As Character, nSize As Numeric) As Character Class GPESmartViewUtils
    // Declaração das variáveis locais
    Local cSQLIN As Character // Expressão IN do SQL
    Local nCont  As Numeric   // Contador auxiliar do conteúdo

    // Define o valor padrão dos parâmetros
    DEFAULT nSize := 1

    // Inicialização das variáveis
    cSQLIN := ""
    nCont  := 0

    If (Len(cCont) > 0)
        For nCont := 1 To Len(cCont) Step nSize
            cSQLIN += "'" + SubStr(cCont, nCont, nSize) + "'"

            If (nCont + nSize <= Len(cCont))
                cSQLIN += ","
            EndIf
        Next nCont
    EndIf
Return cSQLIN

/*/{Protheus.doc} GetCustomFields
    Retorna os campos customizados filtrados conforme as tabelas informadas, separados por vírgula.
    @type Method
    @version 12.1.2310
    @author arthur.sales
    @since 22/04/2024
    @param aCustomFields, Array, Campos customizados do ON
    @param aTables, Array, Tabelas para filtrar os campos customizados
    @return Character, Campos customizados filtrados separados por vírgula
/*/
Method GetCustomFields(aCustomFields As Array, aTables As Array) As Character Class GPESmartViewUtils
    // Declaração das variáveis locais
    Local cFields As Character // Campos separados por vírgula
    Local nFields As Numeric   // Contador para percorrer os campos

    // Inicialização das variáveis
    cFields := ""
    nFields := 1

    // Percorre os campos customizados e os filtra conforme as tabelas informadas
    For nFields := 1 To Len(aCustomFields)
        cFields += IIf(AScan(aTables, aCustomFields[nFields][5]) > 0, IIf(!Empty(cFields), ",", "") + aCustomFields[nFields][1], "")
    Next nFields
Return cFields

/*/{Protheus.doc} SetCustomFields
    Define os campos customizados no JSON de dados do ON.
    @type Method
    @version 12.1.2310
    @author arthur.sales
    @since 22/04/2024
    @param aAllFields, Array, Todos os campos do ON
    @param jData, JSON, Dados do ON
    @param cAlias, Character, Alias da tabela temporária
    @param aPDFields, Array, Campos que podem ser exibidos de acordo com a LGPD
    @param lObfuscated, Logical, Indica se tem algum campo para ofuscar
    @return Variant, Retorno nulo pré-fixado
/*/
Method SetCustomFields(aAllFields As Array, jData As JSON, cAlias As Character, aPDFields As Array, lObfuscated As Logical) As Variant Class GPESmartViewUtils
    // Declaração das variáveis locais
    Local nFields   As Numeric   // Contador para percorrer os campos
    Local cName     As Character // Nome do campo (nome da propriedade do ON)
    Local cRealName As Character // Nome real do campo (nome da coluna na tabela a que ele pertence)
    Local cType     As Character // Tipo do campo
    Local xContent  As Variant   // Conteúdo do campo
    Local lCustomField As Logical 

    // Inicialização das variáveis
    nFields   := 1
    cName     := ""
    cRealName := ""
    cType     := ""
    xContent  := ""
    lCustomField := .F.

    // Percorre todos os campos para adicionar os customizados ao JSON
    For nFields := 1 To Len(aAllFields)
        cName     := aAllFields[nFields]:getName()
        cRealName := aAllFields[nFields]:getRealName()
        cType     := aAllFields[nFields]:getType()
        lCustomField := aAllFields[nFields]:getCustomField()

        // Verifica se o campo já não está no JSON das informações
        // (se não estiver significa que é um campo customizado que foi adicionado pelo usuário, e,
        // neste caso, é necessário adicioná-lo ao JSON)
        If (!jData:hasProperty(cName)) .and. lCustomField
            If (lObfuscated .and. AScan(aPDFields, cName) <= 0)
                xContent := IIf(cType == "number", 0, FwProtectedDataUtil():ValueAsteriskToAnonymize((cAlias)->&(cRealName)))
            ElseIf (cType == "date")
                xContent := totvs.framework.treports.date.stringToTimeStamp((cAlias)->&(cRealName))
            ElseIf (cType == "string")
                xContent := Trim((cAlias)->&(cRealName))
            Else
                xContent := (cAlias)->&(cRealName)
            EndIf

            // Atribui valor ao campo do JSON
            jData[cName] := xContent
        EndIf
    Next nFields
Return NIL

/*/{Protheus.doc} CreateLog
    Cria o log da execução em segundo plano.
    @type Method
    @version 12.1.2410
    @author arthur.sales
    @since 09/10/2024
    @param aLogs, Array, Mensagens de logs
    @param aTitle, Array, Títulos das mensagens de log
    @param cRoutine, Character, Rotina executada em segundo plano
    @return Variant, Retorno nulo pré-fixado
/*/
Method CreateLog(aLogs As Array, aTitle As Array, cRoutine As Character) As Variant Class GPESmartViewUtils
    // Declaração e inicialização das variáveis
    Local cFile   := "" As Character
    Local nLogs   := 0  As Numeric
    Local nLogs2  := 0  As Numeric
    Local nHandle := 0  As Numeric
    Local nAux    := 0  As Numeric
    Local xTit    := "" As Variant

    // Monta o caminho e nome do arquivo de log
    cFile := "spool\Log_" + cRoutine + "_" + Replace(STR0001, " ", "_") + ".##R" // "Segundo Plano"

    // Verifica a existência do arquivo
    If (!File(cFile))
        // Cria o arquivo
        nHandle := FCreate(cFile)
    Else
        // Abre o arquivo para uso
        nHandle := FOpen(cFile, FO_READWRITE + FO_SHARED) // Aberto para leitura e gravação com modo compartilhado

        // Verifica se foi aberto com sucesso
        If (nHandle >= 0)
            // Posiciona no final do arquivo
            FSeek(nHandle, 0, FS_END)

            // Escreve 99 linhas para simular salto de página
            For nAux := 1 To 99
                FWrite(nHandle, CRLF)
            Next nAux
        EndIf
    EndIf

    // Verifica se o arquivo foi criado ou aberto com sucesso
    If (nHandle >= 0)
        // Escreve o título do arquivo
        FWrite(nHandle, Replicate("*", 134) + CRLF)
        FWrite(nHandle, STR0002 + " - " + cRoutine + CRLF + CRLF)                            // "Log de Ocorrências da Execução em Segundo Plano"
        FWrite(nHandle, AllTrim(FwEmpName(cEmpAnt)) + "/" + AllTrim(FwFilialName()) + CRLF)
        FWrite(nHandle, STR0003 + ": v." + cVersao + CRLF)                                   // "Versão"
        FWrite(nHandle, STR0004 + ": "   + DToC(dDataBase) + CRLF)                           // "Data de Referência"
        FWrite(nHandle, STR0005 + ": "   + Time() + CRLF)                                    // "Hora"
        FWrite(nHandle, STR0006 + ": "   + DToC(MsDate()) + CRLF)                            // "Emissão"
        FWrite(nHandle, Replicate("*", 134) + CRLF + CRLF + CRLF)

        // Percorre o vetor de logs para escrever no arquivo
        For nLogs := 1 To Len(aLogs)
            If (Len(aLogs[nLogs]) > 0)
                // Escreve o título da seção
                If (Len(aTitle) >= nLogs)
                    xTit := aTitle[nLogs]
                    FWrite(nHandle, IIf(ValType(xTit) == "A", xTit[1], xTit) + CRLF + CRLF)
                EndIf

                // Escreve as linhas da seção
                For nLogs2 := 1 To Len(aLogs[nLogs])
                    FWrite(nHandle, IIf(Empty(aLogs[nLogs][nLogs2]), "", aLogs[nLogs][nLogs2]) + CRLF)
                Next nLogs2

                // Pula de linha
                FWrite(nHandle, CRLF + CRLF)
            EndIf
        Next nLogs

        // Fecha o arquivo
        FClose(nHandle)
    EndIf
Return NIL

/*/{Protheus.doc} ValidBackGExec
    Realiza toda a lógica de perguntar ao usuário, validar e executar o processamento em segundo plano.
    @type Method
    @version 12.1.2410
    @author arthur.sales
    @since 09/10/2024
    @param cRoutine, Character, Rotina a ser chamada em segundo plano
    @param nModule, Numeric, Módulo da rotina
    @param aMVPar, Array, Parâmetros para a execução em segundo plano
    @return Logical, Se foi possível criar a tarefa a ser executa em segundo plano, é retornado .T.
/*/
Method ValidBackGExec(cRoutine As Character, nModule As Numeric, aMVPar As Array) As Logical Class GPESmartViewUtils
    // Declaração das variáveis locais
    Local cLibVersion As Character // Versão da lib do sistema
    Local lBackground As Logical   // .T. se o usuário escolheu executar em segundo plano
    Local lValid      As Logical   // .T. se será possível executar em segundo plano
    Local lShowPerg   As Logical
    Local oTask       As Object    // Instância da classe do método createTask()
    Local cShowPerg   As Character
    Local aShowPerg   As Array
    Local nRoutine    As Numeric
    Local cOpcMV      As Character
    Local lSchedIsOn  As Logical
	Local aRotinas    As Array

    // Inicialização das variáveis
    cLibVersion := FwLibVersion()
    lBackground := .F.
    lValid      := .F.
    lShowPerg   := .F.
    nRoutine    := 0
    cShowPerg   := SuperGetMV("MV_RHSCHED", NIL, "2,2,2,2,2,2,2,2,2,2,2")
    aShowPerg   := StrTokArr(cShowPerg, ",")
    cOpcMV      := ""
    lSchedIsOn  := totvs.framework.smartschedule.startSchedule.smartSchedIsRunning() 
	aRotinas := {"GPEM034",;	//1
				"GPEM650",;		//2
				"GPEM670",;		//3
				"GPEM110",;		//4
				"GPEM120",;		//5
				"GPEM070",;		//6
				"GPEM023",;		//7
				"GPEM060",;		//8
				"GPEM690",;		//9
				"GPEM020",;		//10
				"GPEM925"}		//11

	nRoutine := aScan(aRotinas, { |x| x == cRoutine })

    //Se o tamanho for maior ou igual, podemos pegar a opção do parâmetro
    If Len(aShowPerg) >= nRoutine .AND. nRoutine != 0
        cOpcMV := aShowPerg[nRoutine]
    Endif

    //0 -> Mostra pergunta sempre
    //1 -> Executa sempre em segundo plano
    //2 -> Nunca executa em segundo plano    

    lShowPerg   := lSchedIsOn .And. (Empty(cOpcMV) .OR. cOpcMV == '0')
    lBackground := cOpcMV == '1'

    BEGIN SEQUENCE
        If lShowPerg
            // Pergunta ao usuário se ele deseja executar o processamento em segundo plano
            lBackground := MsgYesNo(STR0007 + CRLF + CRLF + ; // "Deseja executar o processamento em segundo plano?"
                STR0008 + CRLF + CRLF + ;                     // "Caso selecionado SIM, a execução será feita em segundo plano e serão enviadas notificações de progresso do processamento."
                STR0009)                                      // "Caso selecionado NÃO, a execução seguirá o fluxo normal com o acompanhamento do processo em tela."
        Endif
        
        If (!lBackground)
            BREAK
        EndIf

        // Se o usuário escolher SIM, cria a tarefa a ser executa em segundo plano
        // Pré validações: versão da lib, se o Smart Scheduler está habilitado e rodando e
        // se o sistema está apto para enviar notificações pelo Event Viewer
        If (cLibVersion >= "20240408" .and. lSchedIsOn .and. totvs.framework.eventviewer.checkNewEventViewer())
            oTask := totvs.framework.schedule.utils.createTask(GetEnvServer(), cEmpAnt, cFilAnt, cRoutine, nModule, RetCodUsr(), NIL, aMVPar)

            // Verifica se a tarefa foi criada com sucesso
            If (oTask != NIL .and. !Empty(oTask:cID))
                lValid := .T.
                FwAlertSuccess(STR0010, STR0011) // "Tarefa a ser executada em segundo plano adicionada à fila de processamento." | "Sucesso"
            EndIf
        Else
            cMsg := IIf(cLibVersion < "20240408", STR0012 + ' "20240408".' + CRLF + CRLF + STR0013 + ' "20240408".',;     // "A versão da lib do sistema é inferior a" | "A execução em segundo plano somente está disponível a partir da lib"
                IIf(!totvs.framework.smartschedule.startSchedule.smartSchedIsRunning(), STR0014 + CRLF + CRLF + STR0015,; // "O Smart Scheduler não está ativo." | "Para a execução em segundo plano, é necessário estar com o Smart Scheduler ativo."
                STR0016 + CRLF + CRLF + STR0017))                                                                         // "A versão do Event Viewer está desatualizada." | "Para executar em segundo plano, é necessário atualizar o Event Viewer (basta executar a rotina FwRebuildIndex)."
            FwAlertWarning(cMsg, STR0018) // "Atenção"
        EndIf
    END SEQUENCE
Return lValid

/*/{Protheus.doc} getLogoSV
    Busca o logo da empresa ou filial para uso no cabeçalho dos relatórios do Smart View
    Logo com nomenclatura LGROSV + Código da empresa ou Código da empresa + filial
    @type Method
    @version 12
    @author Bruno Costa
    @since 20/05/2025
    @param cEmpSV, Character, Empresa que será buscado o logo
    @param cFilSV, Character, Filial que será buscado o logo
    @return Character, Retonra a imagem do logo no formato base64
/*/
method getLogoSV(cEmpSV as character, cFilSV as character) as character class GPESmartViewUtils
Local oFile as object
Local cImgB64 as character
Local cImg as character
Local cPath as character
Local aFile := {} as array

DEFAULT cFilSV := ""

//Usa sempre o da filial, caso não exista será usado o da empresa
aFile := Directory(cPath + "LGROSV" + cEmpSV + cFilSV + ".*")  
cPath := GetSrvProfString("Startpath", "")

If Len(aFile) > 0
    cImg := cPath + aFile[1][1]
    If File(cImg)
        oFile := FWFileReader():new(cImg)
        oFile:open()
        cImgB64 := Encode64(oFile:FullRead())
        oFile:close()
        FWFreeVar(@oFile)
    EndIf
Else 
    aFile := Directory(cPath + "LGROSV" + cEmpSV + ".*")  //Logo Empresa
    If Len(aFile) > 0
        cImg := cPath + aFile[1][1]
        If File(cImg)
            oFile := FWFileReader():new(cImg)
            oFile:open()
            cImgB64 := Encode64(oFile:FullRead())
            oFile:close()
            FWFreeVar(@oFile)
        EndIf
    EndIf    
EndIf

Return cImgB64
