#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEA415.CH"
#INCLUDE "PONCALEN.CH"
#INCLUDE "HEADERGD.CH"

/*
зддддддддддбддддддддддбдддддбдддддддддддддддддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    Ёgpea415   ЁAutorЁGuadalupe Santacruz                  Ё Data Ё08/07/2004Ё
цддддддддддеддддддддддадддддадддддддддддддддддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁAmortizaciones   									     	            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                                Ё
цддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё            ACTUALIZACIONES DESDE LA CONTRUCCION INICIAL                           Ё
цддддддддддддбддддддддддбддддддддддддддддбдддддддддддддддддддддддддддддддддддддддддд╢
ЁProgramador ЁData      Ё   BOPS/FNC     ЁMotivo da Alteracao                       Ё
цддддддддддддеддддддддддеддддддддддддддддедддддддддддддддддддддддддддддддддддддддддд╢
ЁMauricio T. Ё11/09/2006Ё----------------ЁPermitir Nro de Parcelas pagas seja       Ё
Ё            Ё          Ё                Ёmaior que Nro de Parcelas a Pagar         Ё
ЁLuiz Gustavo|05/01/2007ЁMelhoria        ЁInclusao da funcao MenuDef() para         Ё
Ё      	     Ё----------Ё----------------Ёversao 9.12.                              Ё
ЁValdeci LiraЁ30/01/2008Ё140682          ЁAlteracao na forma de chamada da funcao   Ё
Ё            Ё          Ё                Ёffiltro e filtragem apenas da SRA e SRK   Ё
Ё            Ё          Ё                Ёe SRV ja que a somente estes campos sao   Ё
Ё            Ё          Ё                Ёexibidos em tela                          Ё
ЁAbel        Ё12/03/2009Ё06352           |Testar Paisloc, para inibir campo desati  |
Ё            Ё          Ё                ЁlocalizaГЦo Colombia                      Ё
ЁRogerio R.  Ё21/05/2009Ё00000012812/2009ЁRemovido da tela os campos "RCK_PDJURO",  Ё
Ё            Ё          Ё                Ё"RK_PDJUROS" e "RK_VLJUROS" para ArgentinaЁ
|Valdeci Lira|24/08/2009|00000021149/2009|Criado 3 pontos de entrada que poderao    |
Ё            Ё          Ё                Ёser executados no LinOk do RCK, linOk do  Ё
Ё            Ё          Ё                ЁSRK e no tudoOk, no fechamaento da tela   Ё
|Marcelo     |28/09/2009|00000022944/2009|Validacao no campo RCK_PD p/aceitar verbas|
Ё            Ё          Ё                Ёde acordo com o lancamento da tabela SRK. Ё
Ё            Ё          Ё                ЁCorrecao na avaliacao dos campos para     Ё
Ё            Ё          Ё                Ёmontagem do aHeader RCK.                  Ё
Ё            Ё          Ё                ЁCriacao da funcao AjustaSX3 para realizar Ё
Ё            Ё          Ё                Ёajustes nos campos: RCK_PD, RCK_DESCPD e  Ё
Ё            Ё          Ё                ЁRCK_REFERE.                               Ё
Ё            Ё          Ё                ЁAjuste na gpea415Mnt() para exibir a      Ё
Ё            Ё          Ё                Ёdescricao das verbas na GetDados da RCK.  Ё
ЁMarcelo     Ё26/10/2009Ё00000026155/2009ЁAjuste para nao adicionar zeros a esquerdaЁ
Ё            Ё          Ё                Ёno campo matricula.                       Ё
ЁAllyson M.  Ё18/11/2009Ё00000028024/2009ЁCriado PE GP415GRV para executar processosЁ
Ё            Ё          Ё                Ёapos gravar dados da amortizacao.         Ё
ЁChristiane  Ё15/01/2010Ё00000000333/2010ЁInclusao tratamento de Item ContАbil e    Ё
Ё            Ё          Ё                ЁClasse de Valor                           Ё
ЁAlceu P.    Ё15/10/2010Ё00000023767/2010ЁInclusao aviso ao usuario referente ao 	Ё
Ё            Ё          Ё                Ёvalor pago do saldo devedor. Ajuste do    Ё
Ё			 Ё			Ё				 Ёsaldo devedor de acordo com o valor pago. Ё
ЁRaquel HagerЁ04/06/2012Ё00000011093/2012ЁAjuste nas funcoes Gp415RCKLinOk e devido Ё
Ё            Ё          Ё          TEXMZYЁGpea415Grava devido a nao utilizacao do   Ё
Ё            Ё          Ё                Ёcampo RK_DTVENC para para Cos/Dom.        Ё
ЁRaquel HagerЁ02/07/2012Ё00000011093/2012ЁCorrecao na funcao Gpea415Grava para correЁ
Ё            Ё          Ё          TEXMZYЁta gravacao na RCK quando SRK for alteradaЁ
Ё            Ё          Ё                ЁDOM/COS Tratamento para remocao dos camposЁ
Ё            Ё          Ё                ЁRCK_PXVCTO e RCK_PDJURO do aHeader.       Ё
ЁGSantacruz  Ё26/11/2016Ёpcreq-7944      ЁPara Chile no debe visualizar el campo    Ё
Ё            Ё          Ё                ЁRCK_CALCUL.                               Ё
ЁAllyson M.  Ё14/01/2016Ё          TUFKWXЁ-Ajuste p/ permitir a alteracao do campo  Ё
Ё            Ё          Ё                ЁRCK_PARCPG devido ao processo de estorno  Ё
Ё            Ё          Ё                Ёde lancamento.                            Ё
Ё            Ё          Ё                Ё-Ajuste na atualizacao da SRK p/ quando o Ё
Ё            Ё          Ё                Ёlancamento ser de estorno p/ subtrair o   Ё
Ё            Ё          Ё                Ёvalor pago  								Ё
ЁCМcero AlvesЁ19/07/2016Ё          TVJTASЁAjuste na funГЦo Gpea415Grava para alterarЁ
Ё            Ё          Ё                Ёcorretamente o registro na SRK			Ё
ЁMarcos Cout.Ё22/12/2016Ё         MRH-237ЁAjustes para possibilitar a exclusЦo de   Ё
Ё            Ё          Ё                Ёvalores futuros lanГados incorretamente   Ё
ЁJaqueline L.Ё05/01/2017Ё DRHPAG-11185   ЁAjuste para quando nЦo estiver preenchido Ё
Ё            Ё          Ё                Ёa coluna valor pago, preencha com 0 para  Ё
Ё            Ё          Ё                ЁnЦo gerar errorlog.                       Ё
юддддддддддддаддддддддддаддддддддддддддддадддддддддддддддддддддддддддддддддддддддддды/*/
Function GPEA415( cAlias , nReg , nOpc )

Local aIndexSRA		:= {}

Begin Sequence

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSi Empleados   No esta vacio            								 Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	/*/
   	IF  !ChkVazio("SRA")   //en GPEXFUN1.PRX
		Break
	EndIF

	Private aRotina := MenuDef() // ajuste para versao 9.12 - chamada da funcao MenuDef() que contem aRotina

	Private bFiltraBrw	:= { || NIL }
	Private cCadastro   := OemToAnsi( STR0005 )
	Private aArray		:= {}

	Private lItemClVl   := SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "13" // Define se trabalha com item e classe contabil

	/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Inicializa o filtro utilizando a funcao FilBrowse                      Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	*/
	aArray := {"SRA", "RCK" , "SRK" }
	ffiltro("GPEA415",aArray, 2) //Cria todas as variaveis para filtro
	//Executa Apenas o Primeiro Filtro
	ffiltro("GPEA415",aArray, 1 /* Exec Filtro*/, 1 /*Inicio*/, 1/*Fim*/)

	/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Chama a Funcao de Montagem do Browse                                   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	*/
	mBrowse( 6 , 1 , 22 , 75 , "SRA"  , NIL , NIL , NIL , NIL , NIL , fCriaCor() )

   	/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Deleta o filtro utilizando a funcao FilBrowse                     	 Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	fFiltro("GPEA415", aArray, 0)//-> Deleta todos os filtros

End Sequence

Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ёgpea415MntЁ Autor ЁGpe Santacruz          Ё Data Ё08/07/2004Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ёgpea415Mnt( cAlias , nReg , nOpc )							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcAlias = Alias do arquivo                                   Ё
Ё          ЁnReg   = Numero do registro                                 Ё
Ё          ЁnOpc   = Numero da opcao selecionada                        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      Ёgpea415()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
/*/
Function gpea415Mnt( cAlias , nReg , nOpc )

Local aArea			:= GetArea()
Local aSvKeys		:= GetKeys()
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aSRKVirtGd	:= {}
Local aSRKVisuGd	:= {}
Local aSRKNotFields	:= {}
Local aSRKRecnos	:= {}
Local aSRKQuery		:= {}
Local aRCKNotFields	:= {}
Local aRCKQuery		:= {}
Local aSRKCols		:= {}
Local aVirtualRC	:= {}
Local aVisualRC		:= {}
Local aRecnosRC		:= {}
Local aLstRCaColsAll:= {}
Local aNaoAltRC     := {}

Local aAlteraRC		:= {}
Local aSRKGdNaoAlt	:= {}
Local aSRKGdAltera  := {}
Local aOfusca		:= If(FindFunction('ChkOfusca'), ChkOfusca(), {.T. , .F.}) //[1] Acesso; [2]Ofusca
Local aFldRot 		:= {'RA_NOME'}
Local aFldOfusca 	:= {}

Local bSet15		:= { || NIL }
Local bSet24		:= { || NIL }
Local bSRKTudOk		:= {}
Local bSRKLinOk		:= {}
Local bRCKTudOk		:= {}
Local bSRKLinDelOk	:= {}
Local bRCKLinOk		:= {}
Local cSRAKeySeek	:= ""
Local lSRKLock		:= .F.
Local lOfuscaNom	:= .F.
Local oDlg			:= NIL
Local oFont
Local oGroup
Local nSRKUsado		:= 0
Local nUsadoRC		:= 0
Local nLoop			:= 0
Local nPosPd		:= 0
Local nPosDesc		:= 0
Local nOpcAlt		:= 0
Local nOpcSRK		:= IF( ( ( nOpc == 2 ) .or. ( nOpc ==5 ) ) , 0 , GD_UPDATE + GD_DELETE )  //ESTA OPCION DEJAMODIFICAR Y DEBE ESTAR EN 2 O EN 3 SEGUN ORDEN
Local nOpcRCK		:= IF( ( ( nOpc == 2 )) , 0 , GD_INSERT + GD_UPDATE + GD_DELETE )  //ESTA OPCION DEJAMODIFICAR Y DEBE ESTAR EN 2 O EN 3 SEGUN ORDEN
Local bSkip         := {|| SRK->RK_VLRPAGO == 0 .And. SRK->RK_PARCPAG == 0 }

Private aColsRCAll		:= {}
Private aHeaderRCAll	:= {}
Private aRCKHeader		:= {}
Private aSvRCKCols		:= {}
Private aSRKHeader		:= {}
Private aSvSRKCols		:= {}
Private aColsAtivos		:= {}
Private __nSRKAtAnt		:= 0
Private cFilSRA			:= ""
Private cMatSRA			:= ""
Private oGetSuper		:= NIL
Private oGetInfer		:= NIL

Private nOpcX			:= nOpc
Private lPeRckLinOk		:= ExistBlock("G415RCKLOK")
Private lPeSrkLinOk		:= ExistBlock("G415SRKLOK")
Private lPeGp415TudOk	:= ExistBlock("G415TUDOK")

Begin Sequence

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta los Datos para el Enchoice							   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cFilSRA		:= xfilial("SRA")
	cMatSRA		:= SRA->RA_MAT
	cSRAKeySeek	:= ( cFilSRA + 	cMatSRA )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁBloqueia Chaves Logicas de Prestamos                          Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( lSRKLock := gpea415Locks( nOpc , "SRK", NIL, { cFilSRA + cMatSRA } ) )
		Break
	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define los Campos que no seran cargados en el grid		   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aAdd( aSRKNotFields , "RK_FILIAL")
	aAdd( aSRKNotFields , "RK_MAT"	 )

	If (cPaisLoc $ "ARG")
		aAdd( aSRKNotFields , "RK_PDJUROS")
		aAdd( aSRKNotFields , "RK_VLJUROS")
	EndIf

	If !lItemClVl
		AAdd(aSRKNotFields, "RK_ITEM")
		AAdd(aSRKNotFields, "RK_CLVL")
	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta os Dados para a GetDados							   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aSRKQuery		:= Array( 05 )
	aSRKQuery[01]	:= "RK_FILIAL='"+cFilSRA+"'"
	aSRKQuery[02]	:= " AND "
	aSRKQuery[03]	:= "RK_MAT='"+cMatSRA+"'"
	aSRKQuery[04]	:= " AND "
	aSRKQuery[05]	:= "D_E_L_E_T_=' ' "

	SRK->( dbSetOrder( RetOrdem( "SRK" , "RK_FILIAL+RK_MAT" ) ) )
	ffiltro("GPEA415",aArray, 1 /* Exec Filtro*/, 2 /*Inicio*/, 3/*Fim*/, .T.)
	aSRKCols	:= SRK->(GdMontaCols(	@aSRKHeader		,;
										@nSRKUsado		,;
										@aSRKVirtGd		,;
										@aSRKVisuGd		,;
										"SRK"			,;
										aSRKNotFields	,;
										@aSRKRecnos		,;
										"SRA"			,;
										cSRAKeySeek		,;
										NIL				,;
										bSkip			,;
										NIL				,;
										NIL				,;
										NIL				,;
										NIL				,;
										NIL				,;
										NIL				,;
										aSRKQuery		,;
										.F.				,;
										.F.				,;
										.T.				))

    If Len(aSRKRecnos) = 0
		MsgInfo(  OemToAnsi( STR0009 ) , cCadastro ) // Nao existem lancamento para esse funcionario
		Break
    EndIf

	/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega a Descricao das Verbas         					   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	nPosPd		:= GdFieldPos( "RK_PD"		, aSRKHeader )
	nPosDesc	:= GdFieldPos( "RK_DESCPD"	, aSRKHeader )
	For nLoop := 1 to len(aSRKCols)
		aSRKCols[nLoop,nPosDesc] := fDesc( "SRV" , aSRKCols[ nLoop , nPosPd ] , "RV_DESC" )
	Next nLoop

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁEfetuo Copia para Comparacao na Saida						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aSvSRKCols	:= aClone( aSRKCols )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define los Campos que no se alteraran solo se visualizaran   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
/*  aAdd( aSRKGdNaoAlt , "RK_NUMID"		)
	aAdd( aSRKGdNaoAlt , "RK_PD"		)
	aAdd( aSRKGdNaoAlt , "RK_DESCPD"	)
	aAdd( aSRKGdNaoAlt , "RK_VALORTO"	)
	aAdd( aSRKGdNaoAlt , "RK_PARCELA"	)
	aAdd( aSRKGdNaoAlt , "RK_JUROANO"	)
	aAdd( aSRKGdNaoAlt , "RK_JUROMES"	)
	aAdd( aSRKGdNaoAlt , "RK_VALORPA"	)
	aAdd( aSRKGdNaoAlt , "RK_PARCPAG"	)
	aAdd( aSRKGdNaoAlt , "RK_VLRPAGO"	)
	aAdd( aSRKGdNaoAlt , "RK_VALORAR"	)
	aAdd( aSRKGdNaoAlt , "RK_DTVENC" 	)
	aAdd( aSRKGdNaoAlt , "RK_DTMOVI"	)
	aAdd( aSRKGdNaoAlt , "RK_DOCUMEN"	)
	aAdd( aSRKGdNaoAlt , "RK_CC"		)
	aAdd( aSRKGdNaoAlt , "RK_PERINI"	)
	aAdd( aSRKGdNaoAlt , "RK_NUMPAGO"	)
    aAdd( aSRKGdNaoAlt , "RK_VLSALDO"	)
	aAdd( aSRKGdNaoAlt , "RK_QTDE"		)
	aAdd( aSRKGdNaoAlt , "RK_QTDEDES"	)
	aAdd( aSRKGdNaoAlt , "RK_QTDESDO"	)
*/
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carga los Campos Editables para a GetDados				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	/*For nLoop := 1	To nSRKUsado
		IF (;
			 ( aScan( aSRKVirtGd,		PADR(aSRKHeader[nLoop, 2], 10) ) == 0 ) .and.	;
		   	 ( aScan( aSRKVisuGd,		PADR(aSRKHeader[nLoop, 2], 10) ) == 0 ) .and.	;
		   	 ( aScan( aSRKNotFields,	PADR(aSRKHeader[nLoop, 2], 10) ) == 0 ) .and.	;
		   	 ( aScan( aSRKGdNaoAlt,		PADR(aSRKHeader[nLoop, 2], 10) ) == 0 )		;
		   	)
			aAdd( aSRKGdAltera , aSRKHeader[ nLoop , 02 ] )
		EndIF
	Next nLoop */

	aAdd( aSRKGdAltera , "RK_STATUS" )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define os Campos que nao serao carregados					   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aAdd( aRCKNotFields , "RCK_FILIAL"	)
	aAdd( aRCKNotFields , "RCK_MAT"	 	)
	aAdd( aRCKNotFields , "RCK_POSTO"	)
	aAdd( aRCKNotFields , "RCK_NUMID"	)

	If (cPaisLoc $ "ARG*COS*DOM")
		aAdd( aRCKNotFields , "RCK_PDJURO")
	EndIf

	If (cPaisLoc $ "MEX")
		aAdd( aRCKNotFields , "RCK_REFERE"	)
	EndIf

	If cPaisLoc $ "COS*DOM"
		aAdd( aRCKNotFields , "RCK_PXVCTO"	)
	EndIf
	If cPaisLoc $ "CHI"
		aAdd( aRCKNotFields , "RCK_CALCUL"	)
	EndIf
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta Query para a Selecao das Informacoes em GdMontaCols    Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aRCKQuery	:= Array( 05 )
	aRCKQuery[01] := "RCK_FILIAL='"+cFilSRA+"'"
	aRCKQuery[02] := " AND "
	aRCKQuery[03] := "RCK_MAT='"+cMatSRA+"'"
	aRCKQuery[04] := " AND "
	aRCKQuery[05] := "D_E_L_E_T_=' ' "

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Seleciona a Ordem para a Obtencao dos Dados                  Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	RCK->( dbSetOrder( RetOrdem( "RCK" , "RCK_FILIAL+RCK_MAT+RCK_NUMID+STR(RCK_SEQUEN)" ) ) )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega todas as Informacoes do RCK para o funcaionario	   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	ffiltro("GPEA415",aArray, 1 /* Exec Filtro*/, 2 /*Inicio*/, 3/*Fim*/, .T.)
	aColsRCAll := RCK->(GdMontaCols(@aHeaderRCAll	,;	//01 -> Array com os Campos do Cabecalho da GetDados
				  				     @nUsadoRC  	,;	//02 -> Numero de Campos em Uso
				  					 @aVirtualRC	,;	//03 -> [@]Array com os Campos Virtuais
				  					 @aVisualRC		,;	//04 -> [@]Array com os Campos Visuais
				  					 "RCK"		    ,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
			  						 Nil  			,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
			  						 @aRecnosRC		,;	//07 -> [@]Array unidimensional contendo os Recnos
			  						 "SRA"			,;	//08 -> Alias do Arquivo Pai
			  						 cSRAKeySeek	,;	//09 -> Chave para o Posicionamento no Alias Filho
				  					 NIL			,;	//10 -> Bloco para condicao de Loop While
				  					 NIL			,;	//11 -> Bloco para Skip no Loop While
				  					 NIL			,;	//12 -> Se Havera o Elemento de Delecao no aCols
				  					 NIL			,;	//13 -> Se cria variaveis Publicas
				  					 NIL			,;	//14 -> Se Sera considerado o Inicializador Padrao
				  					 NIL			,;	//15 -> Lado para o inicializador padrao
			  						 .T.			,;	//16 -> Opcional, Carregar Todos os Campos
				  					 NIL 			,;	//17 -> Opcional, Nao Carregar os Campos Virtuais
									 aRCKQuery		,;	//18 -> Opcional, Utilizacao de Query para Selecao de Dados
									 .F.			,;	//19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
									 .F.			,;	//20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
									 .T.		 	,;	//21 -> Carregar Coluna Fantasma
									 NIL			,;	//22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
	 								 NIL			,;	//23 -> Verifica se Deve Checar se o campo eh usado
									 NIL			,;	//24 -> Verifica se Deve Checar o nivel do usuario
									 NIL			,;	//25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
									 NIL			,;	//26 -> [@]Array que contera as chaves conforme recnos
									 NIL			,;	//27 -> [@]Se devera efetuar o Lock dos Registros
									 NIL			,;	//28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
									 NIL			,;	//29 -> Numero maximo de Locks a ser efetuado
									 .T.			 ;	//30 -> Utiliza Numeracao na GhostCol
							)  )

	// O inicializador padrao da GHOSTCOL e retirado para verificar quais linhas
	// foram incluidas e quais ja foram gravadas. Registros ja gravados nao poderam
	// ser alterados.
	aHeaderRCAll[ GdFieldPos( "GHOSTCOL" , aHeaderRCAll ) , __AHEADER_INITPAD__ ] := ""
	//Altera o campo RCK_PARCPG para alteravel
	aHeaderRCAll[ GdFieldPos( "RCK_PARCPG", aHeaderRCAll ) , __AHEADER_VISUAL__ ] := "A"

	/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega a Descricao das Verbas na GetDados RCK               Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	nPosPdRC	:= GdFieldPos( "RCK_PD"		, aHeaderRCAll )
	nPosDescRC	:= GdFieldPos( "RCK_DESCPD"	, aHeaderRCAll )

	For nLoop := 1 to Len(aColsRCAll)
		aColsRCAll[nLoop,nPosDescRC] := fDesc( "SRV" , aColsRCAll[ nLoop , nPosPdRC ] , "RV_DESC" )
	Next nLoop

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define los Campos que no se alteraran solo se visualizaran   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aAdd( aNaoAltRC , "RCK_FILIAL"	)
	aAdd( aNaoAltRC , "RCK_MAT"		)
	aAdd( aNaoAltRC , "RCK_NUMID"	)
	aAdd( aNaoAltRC , "RCK_DESROT"	)
	aAdd( aNaoAltRC , "RCK_PER"		)
	aAdd( aNaoAltRC , "RCK_NUMPAGO"	)
	aAdd( aNaoAltRC , "RCK_CALCULO"	)
	aAdd( aNaoAltRC , "RCK_SEQUEN"	)


	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁMontar o aHeader para Uso e Definir os Campos Editaveis 	   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	For nLoop := 1 To nUsadoRC
		IF (;
				( aScan( aVirtualRC, 	{|x| PADR(x, 10) == PADR( aHeaderRCAll[nLoop, 2], 10)} ) ) == 0 .and. ;
		   		( aScan( aVisualRC, 	{|x| PADR(x, 10) == PADR( aHeaderRCAll[nLoop, 2], 10)} ) ) == 0 .and. ;
				( aScan( aNaoAltRC, 	{|x| PADR(x, 10) == PADR( aHeaderRCAll[nLoop, 2], 10)} ) )	 == 0 ;
		  	)
			aAdd( aAlteraRC , aHeaderRCAll[ nLoop , 02 ] )
		EndIF

		IF ( aScan(aRCKNotFields , {|x| PADR(x, 10) == PADR(aHeaderRCAll[nLoop, 2], 10)} ) ) == 0
	       	aAdd( aRCKHeader ,	 aClone(aHeaderRCAll[nLoop] ) )
		EndIF
	Next nLoop

	If aScan( aAlteraRC, { |x| x == "RCK_PARCPG" } ) == 0
		aAdd( aAlteraRC , "RCK_PARCPG" )
	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Salva Conteudo Inicial dos aColsAll para comparacao antes  daЁ
	Ё Gravacao													   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aLstRCaColsAll := aClone( aColsRCAll )

	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 015 , 020 , .T. , .F. } )
	aAdd( aObjCoords , { 000 , 100 , .T. , .F. } )
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para validacao da GetDados SRK (oGetSuper)   Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSRKTudOk := {|| oGetSuper:TudoOk() }

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para validacao da GetDados RCK (oGetInfer)   Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bRCKTudOk := { || oGetInfer:TudoOk() }

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para a Tecla <CTRL-O>						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSet15		:= { || IF(;
								Eval( bSRKTudOk );					//Valida as Informacoes da GetDados
								.and.;
								Eval( bRCKTudOk );					//Valida as Informacoes da GetDados
								.and.;
								iIf(lPeGp415TudOk, ExecBlock( "G415TUDOK",.F.,.F.), .T.),; //Se tiver o ponto de entrada TudoOk, executa
								(;
									Eval( oGetSuper:bChange , .T. ),;	//Transere as informacoes Atuais para o aRCKCols
									aSRKCols := oGetSuper:aCols,;		//Redireciona o Ponteiro do aSRKCols
									nOpcAlt := 1 ,;
									RestKeys( aSvKeys , .T. ),;
									oDlg:End();
							 	),;
							 	(;
							 		nOpcAlt := 0 ,;
							 		.F.;
							 	);
						   );
					 }

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para a Tecla <CTRL-X>     	   				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSet24		:= { || ( nOpcAlt := 0 , RestKeys( aSvKeys , .T. ) , oDlg:End() ) }

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta o Dialogo Principal para a Manutencao das Marcacoes    Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0005 ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL

	//Protecao de Dados Sensiveis
	If aOfusca[2]
		aFldOfusca := FwProtectedDataUtil():UsrNoAccessFieldsInList( aFldRot) // CAMPOS SEM ACESSO
		IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_NOME" } ) > 0 
			lOfuscaNom	:= FwProtectedDataUtil():IsFieldInList( "RA_NOME" )
		ENDIF
	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Sustituye al Enchoice para o SRA                      	   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	@ aObjSize[1,1] , aObjSize[1,2] GROUP oGroup TO ( aObjSize[1,3] ),( ( aObjSize[1,4]*0.18 ) ) LABEL OemToAnsi(STR0007) OF oDlg PIXEL				// "Matricula:"
	oGroup:oFont:= oFont
	@ aObjSize[1,1] , ( ( aObjSize[1,4]*0.185 ) ) GROUP oGroup TO ( aObjSize[1,3] ),( aObjSize[1,4] * 0.87 ) LABEL OemToAnsi(STR0008) OF oDlg PIXEL	// "Nome:"
	oGroup:oFont:= oFont
	@ aObjSize[1,1]+10 , aObjSize[1,2]* 2.5				SAY OemToAnsi(SRA->RA_MAT)		SIZE 050,10 OF oDlg PIXEL FONT oFont
	@ aObjSize[1,1]+10 , aObjSize[1,4]* 0.2	SAY If(lOfuscaNom,Replicate('*',15),OemToAnsi(SRA->RA_NOME)) 	SIZE 146,10 OF oDlg PIXEL FONT oFont

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para validacao da GetDados SRK (oGetSuper)   Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSRKTudOk := {|| Gp415SRKTudOk()}

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para validacao de linha da GetDados SRK (oGetSuper)   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSRKLinOk := {|| Gp415SRKLinOk()}

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para validacao de linha da excluida GetDados SRK (oGetSuper)   Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSRKLinDelOk := {|| Gp415SRKDelOk()}

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para validacao da GetDados RCK (oGetInfer)   Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bRCKTudOk := { || Gp415RCKTudOk( ) }

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para validacao de linha da GetDados RCK (oGetInfer)   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bRCKLinOk := { || Gp415RCKLinOk( ) }

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta o Objeto GetDados para o SRK						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	oGetSuper	:= MsNewGetDados():New(	aObjSize[2,1]	,; // Linha Inicial
										aObjSize[2,2]	,; // Coluna Inicial
										aObjSize[2,3]	,; // Linha Final
										aObjSize[2,4]	,; // Coluna Final
										nOpcSRK			,;
									 	bSRKLinOk		,;	// funcao para validar a edicao da linha - ulinhaOK
								 		bSRKTudOk		,;	// funcao para validar todas os registros da GetDados - uTudoOK
										""				,;
										aSRKGdAltera	,;
										0				,;
										NIL				,;
										NIL				,;
										NIL				,;
										bSRKLinDelOk	,; // funcao para validar a deleГЦo da linha - ulinhaDelOk
										oDlg			,;
										aSRKHeader		,;
										aSRKCols 		 )

	oGetSuper:oBrowse:bGotFocus := { || SRKGotFocus() }
	oGetSuper:bChange := { |lColsToAll| Gpea415AllTrf( nOpc, oGetSuper , @oGetInfer , lColsToAll) }

	oGetInfer   := MsNewGetDados():New(	aObjSize[3,1]			,;
										aObjSize[3,2]			,;
										aObjSize[3,3]			,;
										aObjSize[3,4]			,;
										nOpcRCK					,;
									 	bRCKLinOk				,;	// funcao para validar a edicao da linha - ulinhaOK
										bRCKTudOk				,;
										"+RCK_PARCPG"			,;
										aAlteraRC				,;
										0						,;
										99999					,;
										NIL						,;
										NIL						,;
										NIL						,;
										oDlg					,;
										aRCKHeader				,;
										GdRmkaCols( aRCKHeader ) ;
										)

	oGetInfer:bDelOk:= {|| gp415ChkDel()}

	ACTIVATE MSDIALOG oDlg ON INIT	EnchoiceBar( oDlg , bSet15 , bSet24 , NIL , NIL )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁQuando Confirmada a Opcao e Nao for Visualizacao Grava ou   ExЁ
	Ёclui as Informacoes do CTT e RCL							   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF( nOpcAlt == 1 )
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Apenas se nao For Visualizacao              				   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
 		IF ( nOpc != 2 )
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Gravando/Incluido ou Excluindo Informacoes do SRY/RCL        Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			MsAguarde({ ||;
						Gpea415Grava(nOpc			,;	//Opcao de Acordo com aRotina
									 aRecnosRC  	,;
									 aLstRCaColsAll ,;
									 aVirtualRC		 ;
									);
						},cCadastro)
	   EndIF
	EndIF

End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Libera Locks						                           Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If lSRKLock
	FreeLocks( "SRK" , NIL , .T. )
	FreeLocks( "SRA" , NIL , .T. )
EndIf

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁRestaura as Teclas de Atalho								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
RestKeys( aSvKeys )

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁRestaura os Dados de Entrada								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
RestArea( aArea )

Return( nOpcAlt )

/*/
зддддддддддбддддддддддддддддбдддддбддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    Ёgpea415Locks    ЁAutorЁMauricio MR         Ё Data Ё14/04/2004Ё
цддддддддддеддддддддддддддддадддддаддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁBloqueia Lancamentos de Marcacoes /Apont/Abonos		         Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide parametros formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide parametros formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL		                                               	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ёgpea415                                                      Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function gpea415Locks( nOpc , cAlias , aRecnos, aKeys )

Local lLocks	:= .T.

Begin Sequence

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSe nao For Visualizacao				 					   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( nOpc == 2 )
		Break
	EndIF

	IF !( lLocks := WhileNoLock( cAlias , aRecnos , aKeys , 1 , 1 , .T. , NIL ) )
		Break
	EndIF

End Sequence

Return( lLocks )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁSRKGotFocus	 	 ЁAutorЁTatiane Matias    Ё Data Ё21/10/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGotFocus para os Objetos GetDados do SRK (oGetSuper)		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA415()													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function SRKGotFocus()

IF Empty( __nSRKAtAnt )
	__nSRKAtAnt := oGetSuper:oBrowse:nAt
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGp415SRKLinOkЁAutorЁTatiane Matias        Ё Data Ё21/10/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁLinha Ok do SRK(oGetSuper)                                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGp415SRKLinOk( aSvCols ) 			    					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA415()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gp415SRKLinOk()

Local lLinOk		:= .T.
Local nPosStatus	:= 0
Local nPosSaldo	:= 0
Local nPosVlTot	:= 0
Local nSaldo		:= 0
Local nValTot		:= 0


/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Altera o Estado do Cursor  								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
CursorWait()

Begin Sequence

	If !fCompArray(aCols[n] , aSvSRKCols[n])
		//Declarando variaveis de auxilio quanto a posicao dos campos
		nPosStatus	:= GdFieldPos( "RK_STATUS" , aHeader )
		nPosSaldo	:= GdFieldPos( "RK_VLSALDO" , aHeader )
		nPosVlTot	:= GdFieldPos( "RK_VALORTO" , aHeader )

		//Declarando variaveis de valores
		nSaldo		:= aCols[n,nPosSaldo]
		nValTot	:= aCols[n,nPosVlTot]
		nPosDel	:= LEN(aHeader)+1

		// Verifica se houve alguma alteracao no SRK - situacao (RK_STATUS)
		// 1)Solicitado 	-> 2)Ativo
		// 2)Ativo			-> 4)Suspenso
		// 3)Pago			-> Nao pode alterar
		// 4)Suspenso 	-> 2)Ativo
		If ((aSvSRKCols[n,nPosStatus] = "1")  .AND. (aCols[n,nPosStatus] <> "2")) .OR. ;
		   ((aSvSRKCols[n,nPosStatus] = "2")  .AND. (aCols[n,nPosStatus] <> "4")) .OR. ;
		   ((aSvSRKCols[n,nPosStatus] = "3")  .AND. (aCols[n,nPosStatus] <> "3")) .OR. ;
		   ((aSvSRKCols[n,nPosStatus] = "4")  .AND. (aCols[n,nPosStatus] <> "2"))
		   lLinOk := .F.
			//Verifica se STATUS И diferente de PAGO + Saldo И igual a valor total + Registro esta apagado
			//STATUS: Pode ser apagado se for ativo, suspenso ou solicitado sem lanГamentos
			//SALDO : Se o Saldo == Valor Total, significa que nao houve lancamentos para aquele registro de Val. Futuro
			//APAGA : Faz a validaГЦo na Gp415SRKDelOk.
			If((aCols[n,nPosStatus] <> "3") .AND. (nValTot == nSaldo) .AND. (aCols[n,nPosDel] == .T.))
				lLinOk := .T.
			Else
				Help(" ",1,"GPA415SIT")
			Endif
		EndIf

	EndIf

	If(lLinOk .and. lPeSrkLinOk)
		lLinOk := lLinOk .And. ExecBlock("G415SRKLOK", .F., .F.)
	EndIf

End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Estado do Cursor								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
CursorArrow()

Return( lLinOk )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGp415SRKDelOkЁAutorЁMarcos Coutinho    Ё Data Ё21/12/2016Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁLinha Deletada Ok do SRK(oGetSuper)                       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGp415SRKLinDelOk( aSvCols ) 			    					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA415()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gp415SRKDelOk()

Local lLinOk		:= .T.
Local nPosStatus	:= 0

Local nPosValTo  := GdFieldPos( "RK_VALORTO"	, aHeader	)
Local nPosValPg  := GdFieldPos( "RK_VLRPAGO"	, aHeader	)
Local nPosStatus := GdFieldPos( "RK_STATUS"	, aHeader	)
Local nPosSaldo  := GdFieldPos( "RK_VLSALDO"	, aHeader	)

Local lStatus    := aCols[n,nPosStatus]
Local nSaldo     := aCols[n,nPosSaldo]
Local nValorTotal:= aCols[n,nPosValTo]
Local nValorPago := aCols[n,nPosValPg]

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Altera o Estado do Cursor  								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
CursorWait()

Begin Sequence
		// (1)Solicitado / (2)Ativo / (3)Pago / (4)Suspenso
	If ((lStatus == "2") .AND. (nSaldo <> nValorTotal)) .OR. ;		//Se Status == Ativo e Saldo for diferente do ValorTotal
	   ((lStatus == "3")) .OR. ;										//Se Status == Pago
	   ((lStatus == "2") .AND. (nSaldo <> nValorTotal))				//Se Status == Suspenso e Saldo for diferente do ValorTotal

		Help(" ",1,STR0016)
		lLinOk := .F.
	EndIf

End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Estado do Cursor								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
CursorArrow()

Return( lLinOk )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGp415SRKTudOkЁAutorЁTatiane Matias        Ё Data Ё21/10/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁTudo Ok do SRK(oGetSuper)                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGp415SRKTudOk( aSvCols )									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA415()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gp415SRKTudOk()

Local lTudoOk := .T.

Local nLoop

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Altera o Estado do Cursor  								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
CursorWait()

Begin Sequence

	aCols 	:= oGetSuper:aCols
	aHeader := oGetSuper:aHeader

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Percorre Todas as Linhas para verificar se Esta Tudo OK      Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	For nLoop := 1 To Len( aCols )
		n := nLoop
		IF !( lTudoOk := Gp415SRKLinOk() )
			oGetSuper:oBrowse:Refresh()
			Break
		EndIF
	Next nLoop

End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Estado do Cursor								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
CursorArrow()

Return( lTudoOk  )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGp415RCKLinOkЁAutorЁTatiane Matias        Ё Data Ё21/10/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁLinha Ok do RCK(oGetInfer)                                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGp415RCKLinOk( )		    								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA415()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gp415RCKLinOk( )

Local lLinOk		:= .T.
Local lNParc		:= .F.
Local lValidar		:= .F.
Local cNParc		:= ""
Local cStatus		:= ""
Local nLinha		:= 0
Local nX			:= 0
Local nValPar		:= 0
Local nPosSRKStatus	:= GdFieldPos( "RK_STATUS" 	, aSRKHeader)
Local nPosSRKDtVenc	:= GdFieldPos( "RK_DTVENC" 	, aSRKHeader)
Local nPosRCKStatus	:= GdFieldPos( "RCK_STATUS"	, aHeader)
Local nPosNParc		:= GdFieldPos( "RCK_PARCPG"	, aHeader)
Local nPosDtPagto	:= GdFieldPos( "RCK_DTPAGO"	, aHeader)
Local nPosDtVenc	:= GdFieldPos( "RCK_PXVCTO"	, aHeader)
Local nPosRCKVlPago	:= GdFieldPos( "RCK_VLPAGO"	, aHeader)
Local nPosQtdPg     := GdFieldPos( "RCK_QTDEPG"	, aHeader)
Local nPosSRKSaldo  := GdFieldPos( "RK_VLSALDO"	, aSRKHeader)
Local nPosGhostCol	:= GdFieldPos( "GHOSTCOL" 	, oGetInfer:aHeader )
Local nPosDelRCK    := GdFieldPos( "GDDELETED"	, aHeader)
Local cMsgNoYes		:= ""

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Altera o Estado do Cursor  								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
CursorWait()

Begin Sequence

	// Se for inclusao de linha ...
	If Len(aSvRCKCols) < n
		lValidar := !GdDeleted()

	// Se houve alguma alteracao no registro ....
	ElseIf !fCompArray( aCols[n], aSvRCKCols[n] )
		lValidar := !GdDeleted()
	Else
		lValidar := .T.
	EndIf

	If lValidar .And. ( (aSvSRKCols[__nSRKAtAnt][nPosSRKStatus] == '2' .And. oGetSuper:aCols[ oGetSuper:nAt , nPosSRKStatus ] == '4') .Or. (aSvSRKCols[__nSRKAtAnt][nPosSRKStatus] == '4' .And. oGetSuper:aCols[ oGetSuper:nAt , nPosSRKStatus ] == '2'))
		lValidar := .F.
	EndIf

	If ( lValidar )
		cNParc  := aCols[ n , nPosNParc ]
		cStatus	:= aCols[ n , nPosRCKStatus ]

		/*
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica Se o Campos Estao Devidamente Preenchidos		   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
		If Len(aSvRCKCols) < n .Or.  !(aSvRCKCols[n][nPosNParc] == cNParc .And. aSvRCKCols[n][nPosRCKVlPago] == aCols[ n ,nPosRCKVlPago])
			aCposKey := {"RCK_PD", "RCK_PARCPG", "RCK_VLPAGO"}
			IF !( lLinOk := GdNoEmpty( aCposKey ) )
				Break
			EndIF
		EndIf

		If  !(cStatus # "3/5" )
			If ( iif(!empty(aCols[ n , nPosQtdPg ]), aCols[ n , nPosQtdPg ],0) * iif(!empty(aCols[ n, nPosRCKVlPago ]),aCols[ n, nPosRCKVlPago ],0)  )  > aSvSRKCols[__nSRKAtAnt][nPosSRKSaldo]
				cMsgNoYes := STR0011
				cMsgNoYes += CRLF
				cMsgNoYes += STR0012
				cMsgNoYes += STR0014
				IF !( MsgNoYes( OemToAnsi( cMsgNoYes )  , STR0013 ) )
					lLinOk := .F.
					Break
				EndIF
			Endif
		Endif
		// Se nao for exclusao de uma determinada parcela ...
		If═(!(cStatus #═"3/5"═))═.AND.═( lLinOk )

			// A situacao do RCK devera ser igual a situacao do SRK.
			If ( oGetSuper:aCols[ oGetSuper:nAt , nPosSRKStatus ] <> cStatus )
				Help( " " , 1 , "GPA415SITR" )
				lLinOk := .F.
			EndIf

			// Data de pagamento obrigatorio.
			If Empty( aCols[ n , nPosDtPagto ] ) .AND. ( lLinOk )
				Help( " " , 1 , "GPA415DTPG" )
				lLinOk := .F.
			EndIf

			// Verificar se a data do proximo vencimento da 1a parcela informada eh menor
			// que a data do proximo vencimento informado no emprestimo.
			If(!cPaisLoc $ "COS*DOM")
				If ( lLinOk ) .AND. !Empty(aCols[ n , nPosDtVenc]) .AND. ( oGetSuper:aCols[ oGetSuper:nAt , nPosSRKDtVenc ] > aCols[ n , nPosDtVenc] )
					Help( " " , 1 , "GPA415VENC" )
					lLinOk := .F.
				EndIf
			EndIf
		EndIf

		// Se existir mais de um registro em RCK ...
		If ( n > 1 ) .AND. ( lLinOk )
			// Percorre as linhas anteriores para verificar se a parcela informada
			// ja existe.
			// Quando for exclusao, devera informar uma parcela ja existente.
			lNParc := .F.
			For nLinha := ( n - 1 ) to 1 step -1
				If ( aCols[ nLinha , nPosNParc ] == cNParc ) .AND. !GdDeleted(nLinha)
					If ( aCols[ nLinha , nPosRCKStatus ] == cStatus )
						Help( " " , 1 , "GPA415DUPL" )
						lLinOk := .F.
					EndIf
					lNParc	:= .T.
					Exit
				EndIf
			Next nLinha

			If !( lNParc ) .AND. ( cStatus = "5" )
				Help( , , OemToAnsi( STR0013 ), , OemToAnsi(STR0015), 1, 0 )//"AtenГЦo"##"NЗmero da parcela informada para exclusЦo nЦo existente."
				lLinOk := .F.
			EndIf
		EndIf

		If lLinOk

			nValPar := 0
			// Precisa do FOR caso seja a primeira modificacao - unico momento em que ele pode adicionar 2 registros
			For nX := 1 to Len(aCols)
				If Empty(aCols[ nX , nPosGhostCol ]) .And. !(aCols[ nX , nPosRCKStatus ] $ "3*4*5") .AND. ValType(aCols[ nX, nPosRCKVlPago ]) == "N"
					nValPar += Round( (aCols[ nX , nPosQtdPg ] * aCols[ nX, nPosRCKVlPago ] ),2)
				Endif
			Next nX

			If  nValPar  > aSvSRKCols[__nSRKAtAnt][nPosSRKSaldo]
				cMsgNoYes := STR0011
				cMsgNoYes += CRLF
				cMsgNoYes += STR0012
				cMsgNoYes += CRLF
				cMsgNoYes += STR0014
				IF !( MsgNoYes( OemToAnsi( cMsgNoYes ) , STR0013 ))
					lLinOk := .F.
					Break
				ENDIF
			Endif
		Endif
		If ( lLinOk )
			gp415CarregaAtivos(aHeader, aCols, n, nPosRCKStatus, nPosNParc, nPosDtPagto, Len(aCols))
		EndIf

		If(lLinOk .and. lPeRckLinOk)
			lLinOk := lLinOk .AND. ExecBlock("G415RCKLOK", .F.,.F.)
		EndIf

	EndIf


End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Estado do Cursor								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
CursorArrow()

Return( lLinOk )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGp415RCKTudOkЁAutorЁTatiane Matias        Ё Data Ё21/10/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁTudo Ok do RCK(oGetInfer)                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGp415RCKTudOk( )		    								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA415()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gp415RCKTudOk()

Local lTudoOk := .T.

Local nLoop
Local nNrAtivos 	:= 0
Local nPosSituacao 	:= 0
Local nPosQtdParc	:= 0

aCols 			:= oGetInfer:aCols
aHeader 		:= oGetInfer:aHeader
nPosSituacao	:= GdFieldPos( "RCK_STATUS"	, aHeader)
nPosQtdParc		:= GdFieldPos( "RCK_QTDEPG"	, aHeader)
nPosPDJuros		:= GdFieldPos( "RCK_PDJURO"	, aHeader)

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Altera o Estado do Cursor  								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
CursorWait()

Begin Sequence

    /*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Percorre Todas as Linhas para verificar se Esta Tudo OK      Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	For nLoop := 1 To Len( aCols )
		n := nLoop

		If !( GdDeleted() )
			// Contador de registros "Ativos"
			If (nPosPDJuros == 0) .OR. Empty(aCols[n, nPosPDJuros])
				If aCols[n, nPosSituacao] == "2"
					nNrAtivos := nNrAtivos + aCols[n, nPosQtdParc]
				Else
					nNrAtivos := nNrAtivos - aCols[n, nPosQtdParc]
				EndIf
			EndIf
		EndIf

		IF !( lTudoOk := Gp415RCKLinOk( ) )
			oGetInfer:oBrowse:Refresh()
			Break
		EndIF
	Next nLoop

End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Estado do Cursor								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
CursorArrow()

Return( lTudoOk  )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGpea415AllTrf	ЁAutorЁTatiane Matias     Ё Data Ё21/10/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁTransfere Informacoes do aCols para o aColsAll              Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>     								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA415                                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Gpea415AllTrf( nOpc , oGetSRK , oGetRCK , lColsToAll )

Local nSRKSvAt
Local nLinha
Local aRCKCposPes
Local aRCKCposSrt
Local bColsToAll
Local bAllToCols
Local cChave
Local nPosStatus	:= GdFieldPos( "RCK_STATUS"	, oGetRCK:aHeader )
Local nPosNParc		:= GdFieldPos( "RCK_PARCPG"	, oGetRCK:aHeader )
Local nPosDtPagto	:= GdFieldPos( "RCK_DTPAGO"	, oGetRCK:aHeader )

DEFAULT lColsToAll	:= .F.

Begin Sequence

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁGaranto que o Ponteiro Estara no Final do Arquivo para que naoЁ
	ЁCarregue Conteudo Invalido nos Inicializadores Padroes        Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	PutFileInEof( "RCK" )

	nSRKSvAt	:= oGetSRK:nAt

	If ( !Empty( __nSRKAtAnt ) .and. ( __nSRKAtAnt <> nSRKSvAt ) )

		If ValType(oGetSRK:oBrowse) == "O"
			oGetSRK:Goto( __nSRKAtAnt )

			If !( oGetRCK:TudoOk() )
				oGetRCK:oBrowse:SetFocus()
				oGetSRK:Refresh()
				Break
			EndIF
		EndIf

		lColsToAll	:= .T.
	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Altera o Estado do Cursor  								   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	CursorWait()

	If ( lColsToAll ) .AND. (!fCompArray( aSvRCKCols , oGetRCK:aCols ))

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁObtem as Informacoes para o GdColsExChange para o RCK         Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		RCKInfTrf(	oGetSRK			,;
					oGetRCK			,;
					@cChave			,;
					@aRCKCposPes	,;
					@aRCKCposSrt	,;
					@bColsToAll		,;
					@bAllToCols		 ;
			  )

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁTransfere os Dados Entre aCols        					  	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		GdColsExChange(	@aColsRCAll   	,;	//01 -> Array com a Estrutura do aCols Contendo todos os Dados
						@oGetRCK:aCols	,;	//02 -> Array com a Estrutura do aCols Contendo Dados Especificos
						oGetRCK:aHeader	,;	//03 -> Array com a Estrutura do aHeader Contendo Informacoes dos Campos
						NIL				,;	//04 -> Array com as Posicoes dos Campos para Pesquisa
						cChave			,;	//05 -> Chave para Busca
						aRCKCposSrt		,;	//06 -> Array com as Posicoes dos Campos para Ordenacao
						aRCKCposPes		,;	//07 -> Array com as Posicoes dos Campos e Chaves para Pesquisa
						aHeaderRCAll	,;	//08 -> Array com a Estrutura do aHeaderAll Contendo Informacoes dos Campos
						.F.				,;	//09 -> Se Carrega o Elemento como Deletado na Remontagem do aCols
						.T.				,;	//10 -> Se deve Transferir do aCols para o aColsAll
						.F.   			,;	//11 -> Se deve Transferir do aColsAll para o aCols
						.T.				,;	//12 -> Se Existe o Elemento de Delecao no aCols
						.T.				 ;	//13 -> Se deve Carregar os Inicializadores padroes
					   )
	EndIF

	If ( __nSRKAtAnt <> nSRKSvAt )

		If ValType(oGetSRK:oBrowse) == "O"
			oGetSRK:Goto( nSRKSvAt )
		EndIf

		__nSRKAtAnt := nSRKSvAt

	EndIf

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁObtem as Informacoes para o GdColsExChange para o Rdj         Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	RCKInfTrf(	oGetSRK			,;
				oGetRCK			,;
				@cChave			,;
				@aRCKCposPes	,;
				@aRCKCposSrt	,;
				@bColsToAll		,;
				@bAllToCols		 ;
	 	 )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁTransfiro os Dados do aColsAll para o aCols				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/

	GdColsExChange(	@aColsRCAll		,;	//01 -> Array com a Estrutura do aCols Contendo todos os Dados
					@oGetRCK:aCols 	,;	//02 -> Array com a Estrutura do aCols Contendo Dados Especificos
					oGetRCK:aHeader	,;	//03 -> Array com a Estrutura do aHeader Contendo Informacoes dos Campos
					NIL				,;	//04 -> Array com as Posicoes dos Campos para Pesquisa
					cChave			,;	//05 -> Chave para Busca no aColsAll para Carga do aCols
					aRCKCposSrt		,;	//06 -> Array com as Posicoes dos Campos para Ordenacao
					aRCKCposPes		,;	//07 -> Array com as Posicoes dos Campos e Chaves para Pesquisa
					aHeaderRCAll	,;	//08 -> Array com a Estrutura do aHeaderAll Contendo Informacoes dos Campos
					.F.				,;	//09 -> Conteudo do Elemento "Deleted" a ser Carregado na Remontagem dos aCols
					.F.				,;	//10 -> Se deve Transferir do aCols para o aColsAll
					.T.				,;	//11 -> Se deve Transferir do aColsAll para o aCols
					.T.				,;	//12 -> Se Existe o Elemento de Delecao no aCols
					.T.				 ;	//13 -> Se deve Carregar os Inicializadores padroes
				 )

	If ( nOpc == 3 ) // alteracao
		nPosSit	:= GdFieldPos( "RK_STATUS", oGetSRK:aHeader )
		// So ira permitir a inclusao e alteracao quando a situacao estiver Ativo.
		If aSvSRKCols[oGetSRK:nAt, nPosSit] == "2"
			oGetRCK:lInsert 	:= .T.
			oGetRCK:lUpdate 	:= .T.
		Else
			oGetRCK:lInsert 	:= .F.
			oGetRCK:lUpdate 	:= .F.
		EndIf
	EndIf

	If ValType(oGetRCK:oBrowse) == "O"
		oGetRCK:Goto( 1 )
		oGetRCK:Refresh()
	EndIf

	aSvRCKCols 	:= aClone(oGetRCK:aCols)
	aColsAtivos := {}
	For nLinha := 1 to Len(aSvRCKCols)
		gp415CarregaAtivos(oGetRCK:aHeader, aSvRCKCols, nLinha, nPosStatus, nPosNParc, nPosDtPagto, nLinha)
	Next nLinha


End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Estado do Cursor								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
CursorArrow()

Return ( NIL )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRCKInfTrf		 ЁAutorЁMarinaldo de JesusЁ Data Ё05/08/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMonta as informacoes que serao utilizadas para a  transferenЁ
Ё          Ёcia de informacoes no GdColsExChange do RCK                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA415()													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function RCKInfTrf(	oGetSRK		,;
							oGetRCK		,;
							cChave		,;
							aRCKCposPes	,;
							aRCKCposSrt	,;
							bColsToAll	,;
							bAllToCols	 ;
				  		)

Local nPosFilial	:= GdFieldPos( "RCK_FILIAL"	, aHeaderRCAll )
Local nPosMatric  	:= GdFieldPos( "RCK_MAT"	, aHeaderRCAll )
Local nPosNumid   	:= GdFieldPos( "RCK_NUMID"	, aHeaderRCAll )
Local nPosSeq		:= GdFieldPos( "RCK_SEQUEN"	, aHeaderRCAll )
Local cNumid 		:= GdFieldGet( "RK_NUMID"  	, oGetSRK:nAt , .F. , oGetSRK:aHeader , oGetSRK:aCols )

/*
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁCarrega Array a Posicao dos Campos para o "Sort"			  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
aRCKCposSrt := {}
aAdd( aRCKCposSrt , nPosFilial )
aAdd( aRCKCposSrt , nPosMatric )
aAdd( aRCKCposSrt , nPosNumid  )
aAdd( aRCKCposSrt , nPosSeq    )

/*
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁCarrega Array com a Posicao dos Campos e as Chaves  CorresponЁ
Ёdentes														  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
aRCKCposPes := {}
aAdd( aRCKCposPes , { nPosFilial , cFilSRA } )
aAdd( aRCKCposPes , { nPosMatric , cMatSRA } )
aAdd( aRCKCposPes , { nPosNumid  , cNumid  } )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁMonta a chave para busca no aColsAll e Transferencia para   oЁ
ЁRespectivo aCols											  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cChave := ( cFilSRA + cMatSRA + cNumid)

Return( NIL )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ёgp415Inic	     ЁAutorЁTatiane Matias    Ё Data Ё22/10/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInicializador Padrao 										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_RELACAO dos campos RCK_STATUS e RCK_VLPAGO				Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function gp415Inic( cColuna )

Local cConteudo 	:= ""

Local nPosColuna	:= GdFieldPos( cColuna		, aSRKHeader )
Local nPosPdRk		:= GdFieldPos( "RK_PD"		, aSRKHeader )
Local nPosVlRes		:= GdFieldPos( "RK_VALORAR"	, aSRKHeader )
Local nPosNParc		:= GdFieldPos( "RK_PARCELA"	, aSRKHeader )
Local nPosParcPg	:= GdFieldPos( "RCK_PARCPG"	, aRCKHeader)
Local nPosPdRck		:= GdFieldPos( "RCK_PD"		, aRCKHeader)

	If Len( aColsRCAll ) > 0 .And. nPosPdRck > 0 //.And. aScan( aColsRCAll, { |x| !Empty( x[ nPosPdRck ] ) } ) > 0
		Do Case
			Case ( cColuna == "RK_VALORPA" )
				If Len(oGetInfer:aCols) > 0
					If ( oGetSuper:aCols[oGetSuper:nAt, nPosNParc] == oGetInfer:aCols[ Len(oGetInfer:aCols) , nPosParcPg ] )
						cConteudo := oGetSuper:aCols[oGetSuper:nAt, nPosColuna] + oGetSuper:aCols[oGetSuper:nAt, nPosVlRes]
					Else
						cConteudo := oGetSuper:aCols[oGetSuper:nAt, nPosColuna]
					EndIf
				Else
					cConteudo := oGetSuper:aCols[oGetSuper:nAt, nPosColuna]
				EndIf

			Case ( cColuna == "RK_DTVENC" )
				cConteudo := Gp010RetCont("RCH_DTINI",,SRA->RA_PROCES)

				If Empty( cConteudo )
					cConteudo := oGetSuper:aCols[oGetSuper:nAt, nPosColuna]
				EndIf

			Case ( cColuna == "RK_STATUS" )
				cConteudo := aSvSRKCols[oGetSuper:nAt, nPosColuna]

			Case ( cColuna == "RK_PD" )
				cConteudo := oGetSuper:aCols[oGetSuper:nAt, nPosColuna]

			Case ( cColuna == "RK_DESCPD" )
				cConteudo := fDesc("SRV", oGetSuper:aCols[oGetSuper:nAt, nPosPdRk] , "RV_DESC" )

			OtherWise
				cConteudo := oGetSuper:aCols[oGetSuper:nAt, nPosColuna]
		EndCase
	EndIf
Return ( cConteudo )

/*
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ёgp415NParcInic   ЁAutorЁTatiane Matias    Ё Data Ё22/10/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInicializador Padrao 										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_RELACAO do campo RCK_PARCPG								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
Function gp415NParcInic(cColuna)

Local cConteudo := ""
Local nNParc	:= 0
Local nLinha	:= 0
Local nPosNum	:= GdFieldPos( cColuna		, oGetInfer:aHeader )
Local nPosStatus:= GdFieldPos( "RCK_STATUS"	, oGetInfer:aHeader )
Local aColsRCK	:= oGetInfer:aCols

	If Len(aColsRCK) > 0
		nNParc := aColsRCK[1, nPosNum]
		For nLinha := 2 to (Len(aColsRCK) - 1)
			If !GdDeleted(nLinha)
				If aColsRCK[nLinha, nPosStatus] = "2"
					If nNParc < aColsRCK[nLinha, nPosNum]
						nNParc := aColsRCK[nLinha, nPosNum]
					EndIf
				ElseIf aColsRCK[nLinha, nPosStatus] = "5"
					If nNParc = aColsRCK[nLinha, nPosNum]
						nNParc := nNParc - 1
					EndIf
				EndIf
			EndIf
		Next nLinha

		cConteudo := nNParc + 1
	Else
		cConteudo := 1
	EndIF

Return ( cConteudo )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ёgp415SeqInic     ЁAutorЁTatiane Matias    Ё Data Ё22/10/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInicializador Padrao 										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁX3_RELACAO do campo RCK_SEQUEN								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function gp415SeqInic()
Local nTotal	:= 0
Local nLinha	:= 0

	If Len(oGetInfer:aCols) = 0
		cConteudo := 1
	Else
		For nLinha := 1 To Len(oGetInfer:aCols) - 1
			If !GdDeleted(nLinha, oGetInfer:aHeader, oGetInfer:aCols)
				nTotal := nTotal + 1
			EndIf
		Next nLinha
		cConteudo := nTotal + 1
	EndIf

Return ( cConteudo )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGpea415Grava ЁAutorЁTatiane Matias        Ё Data Ё26/10/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGEPA415()	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Gpea415Grava(nOpc			,; // Opcao de Acordo com aRotina
							 aRecnosRC  	,; // Recnos do Arquivo Filho (RCK)
							 aLstRCaColsAll ,; // Itens Anteriores do Arquivo Filho ( RCK )
							 aVirtualRC		 ; // Campos Virtuais do Arquivo Filho ( RCK )
							  )
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis de Inicializacao Obrigatoria					  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aSubItens		:= {}
Local aItens		:= {}
Local aMestre		:= GdPutIStrMestre( 01 )
Local aArea
Local cOpcao		:= IF( (nOpc == 3) , "PUT" , NIL )
Local lGp415Grv		:= ExistBlock("GP415GRV")
Local lModItens		:= .F.
Local lGravouRCK    := .F.
Local lAltPago      := .F.
Local lAltSRK       := .F.
Local cSRKStatus    := ""
Local nLinha		:= 0
Local nIndex		:= 1
Local nSubItens		:= 0
Local nItens		:= 0
Local nValorJuros   := 0
Local nPosGhostCol	:= GdFieldPos( "GHOSTCOL" 	, oGetInfer:aHeader )
Local nPosFecVen    := GdFieldPos( "RCK_PXVCTO"	, oGetInfer:aHeader )
Local nPosVlPago    := GdFieldPos( "RCK_VLPAGO"	, oGetInfer:aHeader	)
Local nPosSitua 	:= GdFieldPos( "RCK_STATUS"	, oGetInfer:aHeader	)
Local nPosRCKPdJur	:= GdFieldPos( "RCK_PDJURO"	, oGetInfer:aHeader	)
Local nPosQtdPg		:= GdFieldPos( "RCK_QTDEPG"	, oGetInfer:aHeader	)
Local nPosRCFil		:= GdFieldPos( "RCK_FILIAL"	, aHeaderRCAll 	)
Local nPosRCMat		:= GdFieldPos( "RCK_MAT"	, aHeaderRCAll 	)
Local nPosRCNmi		:= GdFieldPos( "RCK_NUMID"	, aHeaderRCAll	)
Local nPosDtPag		:= GdFieldPos( "RCK_DTPAGO"	, aHeaderRCAll	)
Local nPosNumid     := GdFieldPos( "RK_NUMID"	, aSRKHeader	)
Local nPosSRKSit 	:= GdFieldPos( "RK_STATUS"	, aSRKHeader	)
Local nPosSRKPd  	:= GdFieldPos( "RK_PD"		, aSRKHeader	)
Local sChave 		:= ""
Local nValorPago	:= 0
Local nApaga		:= LEN(aSRKHeader)+1
Local lApaga		:= .F.
Local bValorPago 	:= {|x, y| If( x[nPosSitua] <> "5" .and. (nPosRCKPdJur == 0 .OR. Empty(x[nPosRCKPdJur]) ), ;
									If(x[nPosQtdPg] ==0, nValorPago += x[nPosVlPago], nValorPago += ( x[nPosVlPago] * x[nPosQtdPg] )), ;
									If( (nPosRCKPdJur == 0 .OR. Empty(x[nPosRCKPdJur])),;
										If(x[nPosQtdPg] ==0, nValorPago -= x[nPosVlPago], nValorPago -= ( x[nPosVlPago] * x[nPosQtdPg] )),;
										0 );
									) }
Local bValorJuros 	:= {|x, y| If( x[nPosSitua] <> "5" .and. (nPosRCKPdJur != 0 .AND. !Empty(x[nPosRCKPdJur])), ;
									If(x[nPosQtdPg] ==0, nValorJuros += x[nPosVlPago], nValorJuros += ( x[nPosVlPago] * x[nPosQtdPg] )), ;
									If( (nPosRCKPdJur != 0 .AND. !Empty(x[nPosRCKPdJur])),;
										If(x[nPosQtdPg] ==0, nValorJuros -= x[nPosVlPago], nValorJuros -= ( x[nPosVlPago] * x[nPosQtdPg] )),;
										0 );
									) }
Local nParcPago		:= 0
Local bParcPago 	:= {|x, y| If( (nPosRCKPdJur == 0 .OR. Empty(x[nPosRCKPdJur])), nParcPago += x[nPosQtdPg], 0 ) }
Local dDtVenc		:= CTOD("//")
Local aSvAtivos		:= {}
Local cUsrRCK 		:= UsrRetName(RetCodUsr())

#IFNDEF TOP
	Local lTopDelItens	:= .F.
	Local lExecSort		:= .T.
#ELSE
	Local lTopDelItens	:= .T.
	Local lExecSort		:= .F.
#ENDIF

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Altera o Estado do Cursor  								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
CursorWait()

Begin Sequence

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Transfere os Dados do aCols para o aColsAll     			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	Gpea415AllTrf( nOpc, oGetSuper , @oGetInfer, .T.)

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Preparando Gravacao										   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	Gpea415PreGrv()

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica se Houve alteracoes nos Itens					   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	lModItens := (( nOpc == 5 ).or.!fCompArray( aColsRCAll , aLstRCaColsAll ))

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega os Itens Apenas se Houveram Alteracoes ou na ExclusaoЁ
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lModItens )

		aAdd( aSubItens , GdPutIStrSItens() )
		nSubItens := Len( aSubItens )
		aSubItens[ nSubItens , 01 ] := "RCK"
		aSubItens[ nSubItens , 02 ] := aClone( aRecnosRC )
		aSubItens[ nSubItens , 03 ] := NIL
		aSubItens[ nSubItens , 04 ] := { |nElem|	( RCK_FILIAL	== aColsRCAll[ nElem , nPosRCFil ]	) .and. ;
													( RCK_MAT		== aColsRCAll[ nElem , nPosRCMat ]	) .and. ;
													( RCK_NUMID		== aColsRCAll[ nElem , nPosRCNmi ] 	)       ;
					 		 			}
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega os Itens Apenas se Houveram Alteracoes ou na ExclusaoЁ
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/

		aAdd( aItens , GdPutIStrItens() )
		nItens := Len( aItens )

		aItens[ nItens , 01 ] := "RCK"
		aItens[ nItens , 02 ] := {}
		aItens[ nItens , 03 ] := aClone( aHeaderRCAll )
		aItens[ nItens , 04 ] := aClone( aColsRCAll	  )
		aItens[ nItens , 05 ] := aClone( aVirtualRC   )
		aItens[ nItens , 06 ] := aClone( aRecnosRC	  )

	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Seta a Gravacao ou Exclusao Apenas se Houveram Alteracoes  ouЁ
	Ё se foi Selecionada a Exclusao								   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aMestre[ 01 , 01 ]	:= "SRA"
	aMestre[ 01 , 02 ]	:= SRA->( Recno() )
	aMestre[ 01 , 03 ]	:= .F.
	aMestre[ 01 , 04 ]	:= NIL
	aMestre[ 01 , 05 ]	:= NIL
	aMestre[ 01 , 06 ]	:= NIL
	aMestre[ 01 , 07 ]	:= aClone( aItens )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Grava as Informacoes                        				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	GdPutInfoData( aMestre , cOpcao , lTopDelItens , lExecSort )

	// 1)Solicitado -> 2)Ativo
	// 2)Ativo	 	-> 4)Suspenso
	// 4)Suspenso 	-> 2)Ativo
	// Gravar um registro em RCK contendo o usuario, a data de alteracao da situacao
	// e para qual situacao o registro SRK foi alterado.
	// Atualizar o SRK com a nova situacao

		dbSelectArea( "SRK" )
		nIndex	:= IndexOrd()
		SRK->( dbSetOrder( RetOrdem( "SRK" , "RK_FILIAL+RK_MAT+RK_NUMID" ) ) )
		ffiltro("GPEA415",aArray, 1 /* Exec Filtro*/, 2 /*Inicio*/, 3/*Fim*/)

		For nLinha := 1 to Len(oGetSuper:aCols)
			sChave := cFilSRA + cMatSRA + oGetSuper:aCols[nLinha, nPosNumid ]
			lApaga := oGetSuper:aCols[nLinha, nApaga]
			//Faz a pesquisa no pai
			If( SRK->( dbSeek( sChave  )))
				//Verifica se o registro pai esta apagado
				If(lApaga)
					//Verifica se o pai possui filhos na RCK
					DBSELECTAREA("RCK")
					RCK->(DBSETORDER( 2 )) //RCK_FILIAL+RCK_MAT+RCK_NUMID+STR(RCK_SEQUEN, 5, 0)

					cChaveRCK := sChave + STR(nLinha,5,0)
					//Se encontrar os filhos, comeГa a apagar 1 por 1 e apСs isso
					If(RCK->(dbSeek(cChaveRCK)))
						While(RCK->RCK_NUMID == oGetSuper:aCols[nLinha, nPosNumid ])
							RCK->( RecLock( "RCK" , .F.) )
								RCK->(DBDELETE())
							MSUnlock()
							dbSkip()
						endDo
					Endif
					//Apaga o pai
					SRK->( RecLock( "SRK" , .F.) )
						SRK->(DBDELETE())
					MSUnlock()
				Else
				//Pai nЦo esta apagado, entЦo И sС alteraГЦo
						SRK->( RecLock( "SRK" , .F. , .T.) )
						oGetSuper:nAt := nLinha
                     Gpea415AllTrf( nOpc, oGetSuper , @oGetInfer, .F. )
						cSRKStatus := oGetSuper:aCols[nLinha, nPosSRKSit ]
						cSequen:= Len(oGetInfer:aCols)

			            // Verifica se houve alteracao na SRK
						lAltSRK := !fCompArray(oGetSuper:aCols[nLinha] , aSvSRKCols[nLinha])

						// Verifica se houve alteracao na RCK
						aArea := GetArea()
						dbSelectArea("RCK")
					    dbSetOrder(2)
					    If dbSeek(cFilSRA + cMatSRA + oGetSuper:aCols[nLinha, nPosNumid ])
					       If dbSeek(cFilSRA + cMatSRA + RCK->RCK_NUMID + STR(cSequen, 5, 0))
							   	lGravouRCK := .T.
				    	   Else
			         	   	lGravouRCK := .F.
			         	   Endif
			         	Else
			         		lGravouRCK := .F.
			         	EndIf

						RestArea(aArea)

			            If ( lGravouRCK .And. cSRKStatus == "2" )
							nValorPago := 0
							aEval(aColsAtivos, bValorPago)
							SRK->RK_VLRPAGO := nValorPago
							SRK->RK_VLSALDO	:= If( ( SRK->RK_VALORTO - nValorPago ) > 0, ( SRK->RK_VALORTO - nValorPago ), 0)

							nValorJuros := 0
							aEval( aColsAtivos, bValorJuros )
							SRK->RK_PGJUROS	:= nValorJuros

							nParcPago := 0
							aEval(aColsAtivos, bParcPago)
							SRK->RK_PARCPAG := nParcPago

							dDtVenc	:= CTOD("//")
							If Len( aColsAtivos ) > 0  .and. nPosFecVen > 0
								aSvAtivos := aClone(aColsAtivos)
								aSort( aSvAtivos, NIL, NIL, {|x,y| x[nPosFecVen] > y[nPosFecVen]})
								dDtVenc	:= aSvAtivos[1, nPosFecVen]
								If !Empty(dDtVenc)
									SRK->RK_DTVENC	= dDtVenc
								EndIf
							EndIf
			            EndIf

						If cPaisLoc <> "COL"

							If  SRK->RK_VLSALDO <= 0 .OR. (SRK->RK_VLJUROS > 0 .AND. SRK->RK_PGJUROS >= SRK->RK_VLJUROS)
								SRK->RK_STATUS := "3"
								lAltPago := .T.
							EndIf

					    ElseIf SRK->RK_VLSALDO <= 0
							   SRK->RK_STATUS := "3"
							   lAltPago := .T.
					    EndIf


					   	If lAltSRK // SRK Alterada

							// Atualizar SRK
							SRK->RK_STATUS := cSRKStatus

						    If !lGravouRCK // Se RCK nao foi gravada, criar novo registro na RCK
								RCK->( RecLock("RCK",.T.) )
								RCK->RCK_FILIAL	:= cFilSRA
								RCK->RCK_MAT	:= cMatSRA
								RCK->RCK_PD		:= oGetSuper:aCols[nLinha, nPosSRKPd  ]
								RCK->RCK_STATUS	:= cSRKStatus
								RCK->RCK_USUARI	:= cUsrRCK
								RCK->RCK_DTALTE	:= MsDate()
								RCK->RCK_NUMID	:= oGetSuper:aCols[nLinha, nPosNumid ]
								RCK->RCK_SEQUEN	:= If(Len(oGetInfer:aCols) == 1 .And. Empty(oGetInfer:aCols[1,nPosGhostCol]),cSequen,cSequen+1)
								RCK->( MsUnLock() )
							EndIf
						ElseIf lAltPago // Se quitou o emprestimo
								aArea := GetArea()
								dbSelectArea("RCK")
							    dbSetOrder(2)
							    If dbSeek(cFilSRA+cMatSRA+oGetSuper:aCols[nLinha, nPosNumid ])
								    While !RCK->(Eof()) .And. RCK->(RCK_FILIAL+RCK_MAT+RCK_NUMID) == cFilSRA+cMatSRA+oGetSuper:aCols[nLinha, nPosNumid ]
									    RCK->( RecLock("RCK",.F.) )
										RCK->RCK_STATUS := "3"
										RCK->( MsUnLock() )

										RCK->(dbSkip())
									EndDo
					         	EndIf
								RestArea(aArea)
						EndIf

			    	  	SRK->( MsUnlock() )

			    	  	lAltPago := .F.
				Endif
			Endif
		Next nLinha

		//PE apos a gravacao dos dados da amortizacao
		If lGp415Grv
			ExecBlock("GP415GRV", .F., .F.)
		EndIf

		SRK->( dbSetOrder(nIndex) )
		ffiltro("GPEA415",aArray, 1 /* Exec Filtro*/, 2 /*Inicio*/, 3/*Fim*/)
End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Estado do Cursor								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
CursorArrow()

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGpea415PreGrv ЁAutorЁMarinaldo de Jesus   Ё Data Ё13/06/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁPrepara os Arrays  RCK para la gravacion                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGPEA415                                                     Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Gpea415PreGrv()

Local aAux			:= {}
Local bAscan		:= { || NIL }
Local nPosFil 		:= 0
Local nPosMat 		:= 0
Local nPosIni		:= 0
Local nLenArray		:= 0

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Define o Bloco para Procura de Informacoes invalidas		   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
bAscan := { |x| ( x[nPosFil] <> cFilSRA ) .and. ( x[nPosMat] <> cMatSRA ) }

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Remonta Array do RCK eliminando Informacoes Invalidas		   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nPosFil := GdFieldPos( "RCK_FILIAL"	, aHeaderRCAll )
nPosMat := GdFieldPos( "RCK_MAT"	, aHeaderRCAll )
IF ( aScan( aColsRCAll , bAscan ) > 0 )
	nLenArray := Len( aColsRCAll )
	For nPosIni := 1 To nLenArray
		IF ( ( aColsRCAll[nPosIni,nPosFil] == cFilSRA ) .and. ( aColsRCAll[nPosIni,nPosMat] == cMatSRA ) )
			aAdd( aAux , aClone( aColsRCAll[ nPosIni ] ) )
		EndIF
	Next nPosIni
	aColsRCAll	:= aClone( aAux )
	aAux		:= {}
EndIF

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ёgp415ChkAlt   ЁAutorЁTatiane Matias       Ё Data Ё27/10/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se o registro pode ser alterado.                   Ё
Ё          ЁO registro so podera ser alterado se for uma inclusao.      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁTodos os campos do SX3 da tabela RCK.                       Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function gp415ChkAlt()

Local lRet 			:= .F.
Local nPosGhostCol	:= GdFieldPos( "GHOSTCOL" 	, aHeader )
Local nPosSituacao	:= GdFieldPos( "RCK_STATUS" , aHeader )

	If Val(aCols[n, nPosGhostCol]) == 0
		If ((aCols[n, nPosSituacao] == "5") .AND. ((ReadVar() == "M->RCK_STATUS") .OR. (ReadVar() == "M->RCK_PARCPG")));
			.OR.;
			(aCols[n, nPosSituacao] <> "5")
			   	lRet := .T.
		EndIf
	EndIf
Return ( lRet )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ёgp415QtdePg   ЁAutorЁTatiane Matias       Ё Data Ё27/10/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna a quantidade de parcelas pagas do numero de         Ё
Ё          Ёpagamento informado. Utilizado para o Mexico.               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGatilho no campo RCK_NUMPAG, para preencher o campo         Ё
Ё          ЁRCK_QTDEPG.                                                 Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function gp415QtdePg()

Local nQtdeParc		:= 1
Local nLinha		:= 0
Local nPosSit 		:= GdFieldPos( "RCK_STATUS" , aHeader)
Local nPosNParc		:= GdFieldPos( "RCK_PARCPG"	, aHeader)
Local nPosQtde		:= GdFieldPos( "RCK_QTDEPG"	, aHeader)
Local nPosValor		:= GdFieldPos( "RCK_VLPAGO"	, aHeader)
Local nPosDtPago	:= GdFieldPos( "RCK_DTPAGO"	, aHeader)

	If aCols[ n , nPosSit ] == "5"
		For nLinha := ( n - 1 ) to 1 step -1
			If ( aCols[ nLinha , nPosNParc ] == aCols[ n , nPosNParc ] )
		 		nQtdeParc 				:= aCols[ nLinha , nPosQtde ]
		 		aCols[ n , nPosValor ] 	:= aCols[ nLinha , nPosValor ]
		 		aCols[ n , nPosDtPago ]	:= aCols[ nLinha , nPosDtPago ]
				Exit
			EndIf
		Next nLinha
	EndIf

Return ( nQtdeParc )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ёgp415ChkDel   ЁAutorЁTatiane Matias       Ё Data Ё27/10/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se o registro pode ser excluido.                   Ё
Ё          ЁO registro so podera ser excluido se for uma inclusao.      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁNo bDelOk da oGetInfer.				                        Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function gp415ChkDel()
Local lRet		:= .T.
Local nPosPxVcto	:= GdFieldPos( "RCK_PXVCTO"	, aHeader	)
Local nPosStatus	:= GdFieldPos( "RCK_STATUS"	, aHeader	)
Local nPosGhostCol	:= GdFieldPos( "GHOSTCOL" 	, aHeader )
Local cPxVcto 		:= CtoD("//")
Local cStatus    	:= 0
Local aPerAtual		:={}
Local cFolMes 		:= ""

fGetPerAtual( @aPerAtual, xFilial("RCH"), SRA->RA_PROCES, fGetRotOrdinar() )
If Empty(aPerAtual)
	fGetPerAtual( @aPerAtual, xFilial("RCH"), SRA->RA_PROCES, fGetCalcRot('9') )
EndIf					

If !(Empty(aPerAtual))
	cFolMes := AnoMes(aPerAtual[1,6])
Else
	cFolMes := AnoMes(Date())
EndIf

If nPosPxVcto > 0 .And. nPosStatus > 0
	cPxVcto := AnoMes(aCols[n,nPosPxVcto])
	cStatus := aCols[n,nPosStatus]
EndIf

// (1)Solicitado / (2)Ativo / (3)Pago / (4)Suspenso
If (cFolMes == cPxVcto) .And. (cStatus <> "2")   // NЦo permite excluir se for status diferente de ativo e nЦo for dentro do perМodo ativo
	Help(,,OemToAnsi(STR0013),,OemToAnsi(STR0017),1,0) // ExclusЦo И permitida somente para lanГamentos com Status ativo e Data de Vencimento dentro do periodo ativo."  
	lRet := .F.
EndIf

Return ( lRet )


Static Function gp415CarregaAtivos(aRCKHeader, aRCKCols, nLinha, nPosStatus, nPosNParc, nPosDtPagto, nTamanho)
Local nParcela	:= 0
Local nPosNIL	:= 0

	If !GdDeleted(nLinha, aRCKHeader, aRCKCols)	.AND. ;
	   !Empty(aRCKCols[nLinha, nPosNParc]) 		.AND. ;
	   !Empty(aRCKCols[nLinha, nPosDtPagto])

		nParcela := aScan( aColsAtivos , { |x| x[nPosStatus] == "2" .AND. x[nPosNParc] == aRCKCols[ nLinha , nPosNParc]})

		// Adicionar no array as parcelas ativas.
		If aRCKCols[nLinha, nPosStatus] == "2" .AND. nParcela == 0
			aAdd( aColsAtivos , aRCKCols[nLinha] )

		// Atualizar os dados da parcela no array
		ElseIf aRCKCols[nLinha, nPosStatus] == "2" .AND. nParcela > 0 .AND. nLinha >= nTamanho
			aColsAtivos[nParcela] := aClone(aRCKCols[nLinha])

		// Deletar do array as parcelas excluidas.
		ElseIf aRCKCols[nLinha, nPosStatus] == "5" .AND. nParcela > 0 .AND. nLinha >= nTamanho
			aDel( aColsAtivos, nParcela )
		EndIf

		// Redimensiona o array caso algum elemento foi deletado.
		nPosNIL := aScan(aColsAtivos, NIL)
		If nPosNIL > 0
			aSize( aColsAtivos, nPosNIL - 1)
		EndIf
	EndIf

	// Ordena por parcela
	aSort( aColsAtivos, NIL, NIL, {|x,y| x[2] < y[2]})

Return ( NIL )

// --
// --

Function GPEA415Mult (cReadVar,xConteudo,lHelp)

Local nPosRCNmi		:= GdFieldPos( "RCK_NUMID"	, aRCKHeader)
Local nPosRCVpa		:= GdFieldPos( "RCK_VLPAGO"	, aRCKHeader)
Local nPosRCPcp		:= GdFieldPos( "RCK_PARCPG"	, aRCKHeader)
Local nValorPar     := 0
Local sChave := ""
Local nPosRen := 0

DEFAULT cReadVar := ReadVar()
DEFAULT xConteudo:= &(cReadVar)
DEFAULT lHelp    := .T.

IF cReadVar = "M->RCK_PARCPG"

	sChave = cFilSRA + cMatSRA+aCols[n,nPosRCNmi]
	dbSelectArea( "SRK" )
	SRK->( dbSetOrder( RetOrdem( "SRK" , "RK_FILIAL+RK_MAT+RK_NUMID" ) ) )
	ffiltro("GPEA415",aArray, 1 /* Exec Filtro*/, 2 /*Inicio*/, 3/*Fim*/)
	IF  SRK->( dbSeek( sChave  ) )
	    nValorPar = SRK->RK_VALORPA
	ENDIF
	aCols[n,nPosRCVpa] =  nValorPar * xConteudo

ENDIF

Return .t.

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ёgpa415ValPD   ЁAutorЁMauricio T. Takakura Ё Data Ё29/09/2005Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se a verba informada esta vinculada com o SRK      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSX3                    				                        Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function gpa415ValPD()

Local cCampoAtu		:= ReadVar()
Local cPDJuros 		:= &( ReadVar() )

Local lRet := .T.

Local nPosVlPago
Local nPosPcJuros
Local nPosSRKPd  	:= GdFieldPos( "RK_PDJUROS"		, aSRKHeader	)
Local nPosRCKPd  	:= GdFieldPos( "RCK_PD"			, aRCKHeader	)
Local nLinhaSRK     := oGetSuper:oBrowse:nAt
Local nLinhaRCK		:= oGetInfer:oBrowse:nAt

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Validar a verba informada pelo usuario.                	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If "RCK_PDJURO" $ cCampoAtu
	If oGetSuper:aCols[ nLinhaSRK, nPosSRKPd  ] != cPDJuros
		MsgInfo( OemToAnsi( STR0010 )  )  //"A Verba informada nao eh a mesma informada no Cadastro de Valores Futuros!"
		lRet := .F.
	EndIf
/*ElseIf "RCK_PD" $ cCampoAtu .and. !empty(cPDJuros)
	If ( oGetSuper:aCols[ nLinhaSRK, nPosRCKPd  ] != cPDJuros ) .And. ( oGetSuper:aCols[ nLinhaSRK, nPosSRKPd  ] != cPDJuros )
		MsgInfo( OemToAnsi( STR0010 )  )  //"A Verba informada nao eh a mesma informada no Cadastro de Valores Futuros!"
		lRet := .F.
	EndIf
	*/
EndIf

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Trocar o valor da Parcela - Trazer do campo Juros   		   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If lRet .And. "RCK_PDJURO" $ cCampoAtu
   IF cPaisLoc <> "COL"
      nPosVlPago  := GdFieldPos( "RCK_VLPAGO"	, aRCKHeader )
	  nPosPcJuros := GdFieldPos( "RK_PCJUROS"	, aSRKHeader )
	  oGetInfer:aCols[ nLinhaRCK, nPosVlPago ] := oGetSuper:aCols[ nLinhaSRK, nPosPcJuros ]
   ENDIF
EndIf

Return( lRet )

/*
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    Ё MenuDef		ЁAutorЁ  Luiz Gustavo     Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁIsola opcoes de menu para que as opcoes da rotina possam    Ё
Ё          Ёser lidas pelas bibliotecas Framework da Versao 9.12 .      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGPEA390                                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁaRotina														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/

Static Function MenuDef()

/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define Array q contiene las Rutinas a ejecutar del programa  Ё
	Ё ----------- Elementos contidos por dimensao ------------     Ё
	Ё 1. Nome a aparecer no cabecalho                              Ё
	Ё 2. Nome da Rotina associada                                  Ё
	Ё 3. Usado pela rotina                                         Ё
	Ё 4. Tipo de Transa┤└o a ser efetuada                          Ё
	Ё    1 - Pesquisa e Posiciona em um Banco de Dados             Ё
	Ё    2 - Simplesmente Mostra os Campos                         Ё
	Ё    3 - Inclui registros no Bancos de Dados                   Ё
	Ё    4 - Altera o registro corrente                            Ё
	Ё    5 - Remove o registro corrente do Banco de Dados          Ё
	Ё    6 - Legenda                                               Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	Local aRotina :=   {	{ STR0001 , "PesqBrw"	 , 0 , 01,,.F. } ,; //"Pesquisar"
							{ STR0002 , "gpea415Mnt" , 0 , 02 } ,;		 //"Visualizar"
							{ STR0003 , "gpea415Mnt" , 0 , 04 } ,; 		 //"Alterar"
							{ STR0004 , "GpLegend"   , 0 , 05,,.F. } ;  //"Legenda"
						}


Return aRotina
