#INCLUDE "TOTVS.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "GPEM1030.CH"

Static lGrvCalc  	:= .F.
Static lWorkFlow	:= .F.
Static lSeleFer 	:= .T.
Static lTerFerMP	:= .F.
Static aStructSRH   := Nil
Static aStructSRR	:= Nil
Static lIntegDef
Static lRefTrab
Static lIntTAF
Static lMiddleware
Static lAposInv    := .F.

Static aPdUmTSRK
Static cAboAnt
Static cPerFeAc    	:= ""
Static dDtIniProg	:= CtoD("//")
Static lItemClVl
Static nBkpDFer		:= 0
Static nDiasAux 	:= 0
Static nDiasProg	:= 0
Static nPosFer		:= 0 //  Poscisao do array aPerFerias com as ferias que esta sendo calculada
Static n2DFerave   	:= 0
Static n2DFerVen 	:= 0
Static nQtdSRH		:= 0
Static __lMemCalc
Static cIdHistMed 	:= ""
Static lCtrlTit
Static lAltFalt		:= .F.
Static nBkpFalt		:= 0
Static nRHTAEEX
Static lTemPostUmT
Static lTemREQ
Static lTribIR
Static lConsig
Static aRotFer      := {}
Static lTemRU6
Static lTemRF13

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GPEM030  ³ Autor ³ Leandro Drumond   			     ³ Data ³ 21/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo de Ferias                                  			           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GPEM030()                                                   			   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                    			   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador  ³   Data   ³ FNC            ³  Motivo da Alteracao                     ³±±
±±³Christiane V.³23/06/2014³TPUQER	        ³ Replicas da P11.80 para P12			   ³±±
±±³Antonio Carmo³26/06/2014³TPUQER	        ³ Correcao na funcao fIntegraFer.		   ³±±
±±³Raquel Hager ³24/07/2014³TPZLMC          ³ Inclusao da gravacao do cpo R8_TPEFD.    ³±±
±±³Allyson M.   ³23/09/2014³TQL000			³ Ajuste para calcular ferias em dobro na  ³±±
±±³             ³          ³    	   		³ rescisao da mesma forma que nas ferias.  ³±±
±±³Renan Borges ³24/09/2014³TQEEUK          ³Ajuste para impedir exclusão de férias pa-³±±
±±³             ³          ³                ³gas em meses anteriores ao da folha corren³±±
±±³             ³          ³                ³te.                                       ³±±
±±³Renan Borges ³05/01/2015³TQMH75          ³Ajuste para impedir visualização de férias³±±
±±³             ³          ³      		    ³pagas em meses anteriores ao da folha cor-³±±
±±³             ³          ³      		    ³rente.                                    ³±±
±±³Henrique V.  ³16/01/2015³TRJIV7          ³Ajuste para validar dias de férias + abono³±±
±±³             ³          ³                ³e exibir mensagem ao usuário quando for   ³±±
±±³             ³          ³                ³menor que 10 dias                         ³±±
±±³             ³          ³                ³Incluída a função fVerDFer que faz esta   ³±±
±±³             ³          ³                ³validação                                 ³±±
±±³Wagner Mobile³21/01/2015³TRIIKI          ³Ajuste na atualização do TSS após calculo ³±±
±±³             ³          ³                ³ou exclusão de férias                     ³±±
±±³Allyson M.   ³28/01/2015³TRJBBV    		³Ajuste em fInssFer() p/ apurar correta-   ³±±
±±³			    ³          ³          		³mente a deducao da base de IR quando o    ³±±
±±³			    ³          ³          		³parametro MV_DINSSFM estiver com S. 	   ³±±
±±³Allyson M.   ³28/01/2015³TRIZBF    		³Ajuste em fFerCal() p/ ordernar correta-  ³±±
±±³			    ³          ³          		³mente a tabela SRH. 					   ³±±
±±³Allyson M.   ³04/03/2015³TRHKQ3   		³Ajuste em fIntegraFer() p/ validar a data ³±±
±±³			    ³          ³          		³das ferias p/ permitir o pagamento de 2 ou³±±
±±³			    ³          ³          		³mais ferias no mesmo periodo   		   ³±±
±±³Claudinei S. ³18/03/2015³TRDIG0          ³ Ajuste no retorno da fVerDFer() para     ³±±
±±³             ³          ³                ³ apresentar mensagem ao clicar em nao     ³±±
±±³Flavio Corr ³19/03/2015 ³PCREQ-4163      ³Integração Mensagem Unica                 ³±±
±±³             ³          ³                ³ 										   ³±±
±±³Thiago Y.M.N ³10/04/2015³TQKKGJ          ³Inclusão do novo controle para o calculo  ³±±
±±³             ³          ³                ³do INSS MV_DINSSFM = 'R'				   ³±±
±±³Claudinei S. ³15/05/2015³TQKKGJ          ³Ajustado o novo controle para o calculo   ³±±
±±³             ³          ³                ³do INSS MV_DINSSFM = 'R'				   ³±±
±±³M. Silveira  ³22/05/2015³TSHTD2          ³Ajuste para obter o tempo de admissao do  ³±±
±±³             ³          ³                ³que foi atribuido nas ferias coletivas.   ³±±
±±³EstherViveiro³02/06/2015³PCDEF-36040     ³Ajuste para considerar faltas existentes  ³±±
±±³             ³          ³                ³na RGB no momento do calculo.			   ³±±
±±³Claudinei S. ³19/06/2015³TQKKGJ          ³fIntegraFer() ajustado o envio das verbas ³±±
±±³             ³          ³                ³de INSS de ferias e deducao Inss IR.      ³±±
±±³Flavio Correa³22/06/2015³TSRHGG          ³Ajuste na busca da SR para ferias,        ³±±
±±³             ³          ³                ³RR_DATA = RH_DATAINI                      ³±±
±±³Allyson M.   ³24/06/2015³TSEUGU          ³Ajuste em fDiasDobra() p/ verificar       ³±±
±±³             ³          ³                ³continuidade de afastamento.              ³±±
±±³M. Silveira  ³21/07/2015³TSRHYV          ³Ajuste para gerar o liquido do 13o. quando³±±
±±³             ³          ³                ³houver antecipacao do pagamento nas ferias³±±
±±³Allyson M.   ³04/08/2015³TSVQSF          ³Ajuste em fMedFer() p/ considerar o valor ³±±
±±³             ³          ³                ³das verbas de medias incluidas manualmente³±±
±±³             ³          ³                ³na RGB p/ calculo de ferias.              ³±±
±±³Allyson M.   ³06/08/2015³TSWIXW          ³Ajuste p/ exibir mensagem de help quando  ³±±
±±³             ³          ³                ³nao tiver verba de id obrigatorio, assim  ³±±
±±³             ³          ³                ³como e' efetuado no calculo da rescisao   ³±±
±±³Allyson M.   ³04/09/2015³TTEWLB          ³Ajuste em fPOutFer() p/ quando MV_DINSSFM ³±±
±±³             ³          ³                ³estiver configurado com R p/ verificar    ³±±
±±³             ³          ³                ³toda a base de INSS e nao somente a do mes³±±
±±³Mauricio T.  ³04/09/2015³TTATEJ          ³Ajuste em fMedFer() excluindo a parte refe³±±
±±³             ³          ³                ³rente ao lacto manual de medias. Tratament³±±
±±³             ³          ³                ³foi realizado na forula S_GRMEDFER        ³±±
±±³Allyson M.   ³25/09/2015³TTJADU          ³Adicionada validacao quando nao houver um ³±±
±±³             ³          ³                ³registro na SRF p/ o id 0072              ³±±
±±³Raquel H     ³28/09/2015³TTBFXG          ³Remocao de validacao de Dt. Corte do perio³±±
±±³             ³          ³                ³Esse campo nao e mais usado na v12.       ³±±
±±³Raquel H     ³05/10/2015³TTNHGI          ³Remocao de validacao de Dt. Corte do      ³±±
±±³             ³          ³                ³periodo - campo nao e mais usado na v12.  ³±±
±±³Ricardo D.   ³13/10/2015³TTNVCJ          ³Replica chamado TTATEJ do Release 12.1.6  ³±±
±±³             ³          ³                ³para 12.1.7                               ³±±
±±³Allyson M.   ³03/12/2015³TTRFOY			³Ajuste em fInssFer() p/ apurar correta-   ³±±
±±³			    ³          ³          		³mente a deducao da base de IR quando o    ³±±
±±³			    ³          ³          		³parametro MV_DINSSFM estiver com S. 	   ³±±
±±³Cícero Alves ³08/12/2015³TTZBO5 		    ³Correções dos chamados TTZBO5, TTWXNN	   ³±±
±±³             ³          ³      	    	³ e TTYSSE								   ³±±
±±³Allyson M.   ³21/12/2015³TUAWMQ    		³Ajuste p/ carregar o salario no inicio do ³±±
±±³			    ³          ³          		³calculo p/ evitar erro no demonstrativo de³±±
±±³			    ³          ³          		³medias									   ³±±
±±³Allyson M.   ³28/12/2015³TUBES2			³Ajuste p/calcular a data final com os dias³±±
±±³             ³          ³          		³de Lic.Remunerada informada pelo usuario e³±±
±±³             ³          ³          		³para considerar os dias de ferias ja pagos³±±
±±³             ³          ³          		³do periodo ao informar as faltas.         ³±±
±±³Allyson M.   ³07/01/2016³TUBROB    		³Ajuste em fMedFer() p/ verificar o valor  ³±±
±±³			    ³          ³          		³das medias que foram pagas no movimento   ³±±
±±³			    ³          ³          		³quando for dissidio   					   ³±±
±±³Mariana M.   ³18/01/2016³TUA962    		³Ajustada na função Gpm030VldIni, retirando³±±
±±³			    ³          ³          		³a mensagem quando for visualização		   ³±±
±±³Allyson M.   ³18/01/2016³TUBROB    		³Ajuste no relacionamento do model da SRH  ³±±
±±³			    ³          ³          		³p/ tratar corretamente a visualizacao de  ³±±
±±³			    ³          ³          		³calculos no mesmo periodo aquisitivo	   ³±±
±±³Allyson M.   ³22/01/2016³TUDHS0    		³Ajuste em fPOutFer() p/ restaurar o recno ³±±
±±³			    ³          ³          		³da SRH devido ao calculo do dissidio      ³±±
±±³Renan Borges ³17/02/2016³TUEMC7    		³Ajuste para ao calcular férias seja grava-³±±
±±³			    ³          ³          		³do R8_NUMID também, igual é realizado ao  ³±±
±±³			    ³          ³          		³atualizar o registro de ausência.         ³±±
±±³Raquel Hager³19/02/2016³TUKE03    		³Removida carga de mnemonicos de salario.  ³±±
±±³P. Pompeu...³13/04/2016³TUUESB    		³Correção func. fGFerSR8 add. MsUnlock     ³±±
±±³Raquel Hager³14/04/2016³TUXOYU    		³Ajuste para carregar aTabFer caso esteja  ³±±
±±³			    ³          ³          		³vazia(execucao pelo MULTV).               ³±±
±±³Allyson M.   ³02/06/2016³TUVLGI    		³Ajuste em fInssFer() p/ nao gerar deducao ³±±
±±³			    ³          ³          		³se nao houver desconto de INSS (quando ja ³±±
±±³			    ³          ³          		³houve desconto em outra empresa) 		   ³±±
±±³Allyson M.   ³24/06/2016³TUHU85    		³Ajuste em FDatafer() p/ recalcular os dias³±±
±±³			    ³          ³          		³de direito. Isso ocorre pois pode ser que ³±±
±±³			    ³          ³          		³o funcionario tenha mais dias de direito  ³±±
±±³			    ³          ³          		³na data em que ocorre o inicio das ferias ³±±
±±³			    ³          ³          		³do que o que estava informado no controle ³±±
±±³			    ³          ³          		³de dias de direito, uma vez que esse      ³±±
±±³			    ³          ³          		³cadastro guarda os dias de direito quando ³±±
±±³			    ³          ³          		³o fechamento é realizado				   ³±±
±±³Gabriel A.   ³24/06/2016³TVJSOG          ³Ajuste para guardar o valor do salario    ³±±
±±³             ³          ³                ³incorporado para o relatorio de medias    ³±±
±±³Gabriel A.   ³29/06/2016³TVIBY6          ³Ajuste para exibir mensagem quando as     ³±±
±±³             ³          ³                ³médias forem calculadas a partir de 2     ³±±
±±³             ³          ³                ³meses antes do período atual de férias.   ³±±
±±³Allyson M.   ³29/06/2016³TTTCK2    		³Ajuste em fMedFer() p/ separar a periculo-³±±
±±³			    ³          ³          		³sidade e insalubridade calculada sobre a  ³±±
±±³			    ³          ³          		³media devido separação dos Ids 		   ³±±
±±³Allyson M.   ³30/06/2016³TVFXPQ    		³Ajuste em fIntegraFer() p/ integrar a     ³±±
±±³			    ³          ³          		³verda do Id 0168 e 0065 p/ nao ficar com  ³±±
±±³			    ³          ³          		³data de pagamento incorreta na folha  	   ³±±
±±³Claudinei S. ³05/07/2016³TUQEO7    		³Ajustes em m030VldCalc() e fVerDias() para³±±
±±³			    ³          ³          		³emitir mensagens quando os dias de abono  ³±±
±±³			    ³          ³          		³forem maiores que 1/3 das férias, data de ³±±
±±³			    ³          ³          		³inicio das férias for um feriado, sabado  ³±±
±±³			    ³          ³          		³ou domingo.                               ³±±
±±³Allyson M.   ³11/07/2016³TVNKCX    		³Ajuste em FDatafer() p/ nao sobreescrever ³±±
±±³			    ³          ³          		³os dias de férias caso tenha sido informa-³±±
±±³			    ³          ³          		³do uma quantidade maior que os de direito ³±±
±±³Cícero Alves ³19/07/2016³TVERJT     		³Ajuste em fIntegraFer, adicionado um sepa-³±±
±±³			    ³          ³          		³rador entre as verbas variável cBaseINSS  ³±±
±±³Cícero Alves ³28/07/2016³TVIVN2     		³Implemtado o PE GP030MNU para customizar  ³±±
±±³			    ³          ³          		³o menu da rotina						   ³±±
±±³Allyson M.   ³01/08/2016³TVQVE5    		³Ajuste em fInssFer() p/ gerar deducao de  ³±±
±±³			    ³          ³          		³INSS corretamente 						   ³±±
±±³Claudinei S. ³02/08/2016³TUQEO7    		³Ajustes em fVerDias() para considerar     ³±±
±±³			    ³          ³          		³corretamente as faltas ao emitir mensagem ³±±
±±³			    ³          ³          		³quando o abono for maior que 1/3 de férias³±±
±±³			    ³          ³          		³férias.                                   ³±±
±±³Raquel H.   ³22/08/2016³TVQJGF    		³Réplica do PE GPM030CO para impedir execu-³±±
±±³			    ³          ³          		³ção do cálculo de Férias.                 ³±±
±±³Renan Borges³22/08/2016 ³TVUX16 	        ³Ajuste para ao realizar o fechamento possu³±±
±±³            ³           ³   		        ³indo 2 calculos de férias dentro do mes   ³±±
±±³            ³           ³   		        ³sistema totalize dias pagos corretamente. ³±±
±±³Allyson M.   ³24/08/2016³TVVBG2    		³Ajuste em fPOutFer() p/ buscar os dados de³±±
±±³			    ³          ³          		³outros cálculos corretamente 			   ³±±
±±³			    ³          ³          		³Ajuste em FDatafer() p/ considerar os dias³±±
±±³			    ³          ³          		³antecipados corretamente				   ³±±
±±³Allyson M.   ³31/08/2016³TVNEZC			³Ajuste em fInssFer() p/ gerar aliquota    ³±±
±±³			    ³          ³          		³correta na verba quando tem mais de um    ³±±
±±³			    ³          ³          		³calculo (MV_DINSSFM com R).          	   ³±±
±±³Allyson M.   ³20/09/2016³TVUGMX			³Ajustes p/ execução no robô de automação  ³±±
±±³Allyson M.   ³21/09/2016³TVYUWQ    		³Ajuste p/ considerar os dias antecipados  ³±±
±±³			    ³          ³          		³corretamente 			   				   ³±±
±±³Allyson M.   ³06/10/2016³TWDYBF			³Ajuste em fInssFer() p/ MV_DINSSFM com S  ³±±
±±³			    ³          ³          		³p/ a somatória do desconto do mês + mês   ³±±
±±³			    ³          ³          		³seguinte não ultrapassar o teto.      	   ³±±
±±³			    ³          ³          		³Ajuste em fPOutFer() p/ não gerar error   ³±±
±±³			    ³          ³          		³log quando tem o MULTV habilitado  	   ³±±
±±³Cícero Alves ³11/10/2016³TWCVHH			³Alteração na fVldMsgMed para carregar o   ³±±
±±³			    ³          ³          		³roteiro correto 						   ³±±
±±³Eduardo K.   ³03/11/2016³TWKM35    		³Ajuste para validar afastamento sem data  ³±±
±±³			    ³          ³          		³de termino definida.                      ³±±
±±³Renan Borges ³09/11/2016³TWHFVH    		³Ajuste para somente mostrar a mensagem de ³±±
±±³			    ³          ³          		³que há rescisão calculada quando ela for  ³±±
±±³			    ³          ³          		³efetiva e não simulada.                   ³±±
±±³Allyson M.   ³09/11/2016³TWJFZ6			³Ajuste em fInssFer() p/ MV_DINSSFM com S  ³±±
±±³			    ³          ³          		³p/ a somatória do desconto do mês + mês   ³±±
±±³			    ³          ³          		³seguinte não ultrapassar o teto caso o MNE³±±
±±³			    ³          ³          		³P_LIMTET estiver ativo.				   ³±±
±±³Renan Borges ³14/12/2016³MRH-2445   		³Ajuste para que o calculo do dissidio re- ³±±
±±³			    ³          ³          		³troativo considere a diferença de férias  ³±±
±±³			    ³          ³          		³já pagas no calculo da folha.             ³±±
±±³Gabriel A.   ³05/01/2017³MRH-3701        ³Ajuste na geração de médias para o cálculo³±±
±±³             ³          ³                ³de férias quando o parâmetro MV_DTMDFER   ³±±
±±³             ³          ³                ³está como "1".                            ³±±
±±³Allyson M.   ³03/02/2017³MRH-5876		³Ajuste em fInssFer() na proporiconalização³±±
±±³			    ³          ³          		³do INSS mês/mês seguinte quando há outro  ³±±
±±³			    ³          ³          		³cálculo de férias no período			   ³±±
±±³Allyson M.   ³03/02/2017³MRH-57			³Ajuste em fDiasDobra() p/ verificar os    ³±±
±±³			    ³          ³          		³codigos corretos para versão 12  		   ³±±
±±³Isabel N.    ³14/02/2017³ MRH-4662       ³Ajuste nos nomes dos campos,de RH_DABONPEC³±±
±±³             ³          ³                ³p/ RH_DABONPE, RH_SALHORA para RH_SALHRS, ³±±
±±³             ³          ³                ³e RH_SALHOR1 para RH_SALHRS1, conforme    ³±±
±±³             ³          ³                ³cadastrados no Atusx.                     ³±±
±±³Oswaldo L.   ³01/02/17  ³MRH-5778        ³Trativa para que o sistema apenas utilize ³±±
±±³             ³          ³                ³os campos de acordo com o pais conectado  ³±±
±±³Cícero Alves ³09/03/2017³        MRH-8150³Ajuste na fVerDFer para não apresentar a  ³±±
±±³             ³          ³                ³mensagem quando não tiver interface	   ³±±
±±³             ³          ³                ³- teste automatizado - 				   ³±±
±±³Claudinei S. |28/04/2017|MRH-482         |Implementado o cálculo para funcionários  ³±±
±±³             |          |                |com regime parcial.                       ³±±
±±³Gabriel A.   ³08/05/2017³DRHPAG-1263     ³Melhora de performance na integração de   ³±±
±±³             ³          ³                ³férias.                                   ³±±
±±³Eduardo K.   ³29/05/2017³MPRIMESP-10173  ³Ajuste no calculo de dias de férias de    ³±±
±±³             ³          ³                ³acordo com a programação.                 ³±±
±±³Paulo O.		³04/07/2017³	DRHPAG-2009	³Ajuste para correção de erro log ao 	   ³±±
±±³Inzonha      ³          ³                ³visualizar medias de ferias 			   ³±±
±±³Eduardo K.   ³22/09/2017³MPRIMESP-11357  ³Ajuste na ViewDef para zerar o array      ³±±
±±³             ³          ³                ³aStructSRR.				               ³±±
±±³Eduardo K.   ³10/10/2017³MPRIMESP-11591  ³Ajuste Gp030RstDat p/ não carregar valid  ³±±
±±³             ³          ³                ³do RH_DATAINI na abertura da tela.        ³±±
±±³Oswaldo L    ³01/12/2017³DRHPAG-9006     ³Subir ajuste realizado - Mensagem Unica   ³±±
±±³Tiago B		  ³09/03/2018³MPRIMESP-9006 ³Ajsute referente a geração do ID0202      ³±±
±±³				  ³							³na integração do processo de ferias	   ³±±
±±³Eduardo Vicen³19/03/2018³DRHESOCP-2383   ³Inclusão de evento S-2230				   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function GPEM030(xRotAuto,nOpcAuto,lRotAuto)

Local cFiltraRH		:= ""
Local aArea			:= GetArea()
Local aKeys			:= GetKeys()
Local aAutoCab		:= {}
Local cMatAux		:= ""
Local cFilAux		:= ""
Local oBrwSRA

Private nVez 		:= 1
Private lTemVenc	:= .F.

Private nDiasFer 	:= 0	//# Dias de Direito do funcionario
Private nColPro     := 2

Private nVacRCH 	:= 0 //Variavel que contem o recno do RCH
Private nRecRCHVac  := 0 //Guarda o recno para confirmar que ira ser gravado

Private cAboPec  	:= " "                   //-- Abono antes ferias

Private cMat  		:= SRA->RA_MAT
Private cNome 		:= SRA->RA_NOME
Private cMesAnoRef	:= ''				//-- Mes ano de processamento
Private cSemana 	:= Space(2)
Private nRecSrh     := 0

Private aRotAuto	:= xRotAuto

Private aRoteiro    := {}
Private aTabFer     := {}     // Tabela para calculo dos dias de ferias
Private aTabFer2    := {}     // Tabela para calculo dos dias de ferias para regime de tempo parcial
Private aLogErros	:= {}	  // Array com os logs de erros de processamento

Private dNDataBas	:= CtoD("")
Private nDAbProg	:= 0
Private nPercProg	:= 0
Private dDtFim		:= CtoD("")
Private nFaltas     := nDescFal := 0
Private nDBonave    := nDBonVen := 0
Private nFalBon		:= 0
Private nDVenPen    := 0
Private dIVenPen    := dFVenPen := dDtBasFim := Ctod("")
Private nDferV    	:= 0
Private nDFerP	    := 0
Private cDescTipAfa := ""
Private cPeriAnt    := ""
Private cNpagAnt    := ""
Private nDDobro     := 0

Private nVacMens    := 0
Private nSusMens    := 0
Private dRch_DtIni  := CtoD("")
Private dRch_DtFim  := CtoD("")
Private dRch_DtCort := CtoD("")
//Variavel auxiliar na integracao da Mensagem Unica, na mensagem de exclusao.
Private lExcFerPIMS   := .F.

Private nSalaMed 	:= 0
Private nSMesMed  	:= 0
Private nSDiaMed  	:= 0
Private nSHorMed 	:= 0

Private cVersEnvio	:= ""
Private cVersGPE	:= ""

Private lIntNGRJP	:= SUPERGETMV('MV_RHNG', .F., .F.) // Integração NG x Quírons

DEFAULT __lMemCalc := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc() // Memória de Cálculo
DEFAULT lRotAuto   := .F.
DEFAULT lIntTAF	   := (GetMv("MV_RHTAF",.T., .F.) == .T. .AND. Val(GetMv('MV_FASESOC',.T.,' ')) >= 1  )
DEFAULT lMiddleware:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )
DEFAULT cAboAnt    := If(GetMvRH("MV_ABOPEC") == "S", "1", "2") //-- Abono antes ferias
DEFAULT lItemClVl  := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3" // Define se trabalha com item e classe contabil

If !(cPaisLoc $ "BRA|CHI|PAR")
	Private oSRCClone
	Private oSRC
EndIf

/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
  ³Funcao verifica se existe alguma restrição de acesso para o³
  ³usuário que impeça a execução da rotina.                   |
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If !(fValidFun({"SQB","SRJ","RCO",;
				"CTT","RGC","SRC","RCE","SR6","SR3",;
				"SR7","RGB","SRV","SRK","RCP",;
				"RG7","SRR","SRH","RCM"}))
	Return
EndIf

lMetadeFal := .F.
lTempoParc := .F.

lWorkFlow	:= !Empty(aRotAuto)

If IsBlind() .Or. IsInCallStack("FwMyTestRunner") .Or. IsInCallStack("EXECSUITE") .Or. IsInCallStack("EXECSUITEBLIND") .Or. IsInCallStack("AUTJOBRUNCT")
	//--Seta e Carrega os Mnemonicos.
	SetMnemonicos(NIL,NIL,.T.)
EndIf

cPerFeAc := If(cPaisLoc=="BRA","",P_FERPAC)	//-- Ferias Por Ano Civil

If FindFunction("ESocMsgVer") .And. lIntTaf .And. !lMiddleware
	If FindFunction("fVersEsoc")
		fVersEsoc( "S2230", .F., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio, @cVersGPE)
	EndIf
	If cVersGPE <> cVersEnvio .And. (cVersGPE >= "9.0" .Or. cVersEnvio >= "9.0")
		//"Atenção! A versão do leiaute GPE é xxx e a do TAF é xxx, sendo assim, estão divergentes. O Evento xxx não será integrado com o TAF, e consequentemente, não será enviado ao RET.
		//Caso prossiga a informação será atualizada somente na base do GPE. Deseja continuar?"
		If ESocMsgVer(.F.,"S-2230", cVersGPE, cVersEnvio)
			lIntTaf := .F.
		Else
			Return
		EndIf
	EndIf
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carregando Filtro de BROWSE                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cFiltraRh 	:= CHKRH("GPEM030","SRA","1")

If lRotAuto

	FWExecView(If(nOpcAuto == MODEL_OPERATION_UPDATE,STR0089,If(nOpcAuto == MODEL_OPERATION_VIEW,STR0015,STR0014)), "GPEM030", nOpcAuto ,,{||.T.})

ElseIf lWorkFlow
	aEval(aRotAuto,{|x| If(X[1] == "RH_MAT", cMatAux := X[2] , (If(X[1] == "RH_FILIAL", cFilAux := X[2],))) })
	dbSelectArea("SRA")
	DbSetOrder(1)
	If !dbSeek(cFilAux+cMatAux)
		AutoGrLog(STR0092 + " " + Alias() + " " + Dtoc(MsDate()) + ' ' + Time() ) // "Tabela "
		AutoGrLog("RA_FILIAL: " + cFilAux)
		AutoGrLog("RA_MAT: " + cMatAux)
		AutoGrLog(STR0093) // "Funcionário não encontrado com dados acima"
		AutoGrLog(Replicate("-",80))
	Else
		aAdd(aAutoCab,{"RA_FILIAL",cFilAux,NIL})
		aAdd(aAutoCab,{"RA_MAT",cMatAux,NIL})
		aRotina 	:= MenuDef()
		If GPM030VldIni(ModelDef(),MODEL_OPERATION_UPDATE)
			FWMVCRotAuto(ModelDef(),"SRA",MODEL_OPERATION_UPDATE,{{"GPEM030_MSRA",aAutoCab},{"GPEM030_MSRH",aRotAuto}})
		EndIf
	EndIf
Else

	oBrwSRA := FwMBrowse():New()

	oBrwSRA:SetAlias( 'SRA' )
	oBrwSRA:SetDescription(OeMtoAnsi(STR0008)) 	  //"Calculo de F‚rias "
	oBrwSRA:SetmenuDef( 'GPEM030' )

	//Filtro padrao do Browse conforme tabela SRW (Controle de Restricoes de Usuarios)
	oBrwSRA:SetFilterDefault(cFiltraRh)

	GpLegMVC(@oBrwSRA)	// Adicionar a Legenda no Browse

	oBrwSRA:Activate()
EndIf

aStructSRH := Nil //Zera static

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura os Dados de Entrada 											 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
RestKeys(aKeys,.T.)
RestArea( aArea )

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MenuDef   ºAutor  ³Leandro Drumond     º Data ³  17/09/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Menu Funcional                                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function MenuDef()

Private aRotina :=  {}

DEFAULT lIntTAF	   := (GetMv("MV_RHTAF",.T., .F.) == .T. .AND. Val(GetMv('MV_FASESOC',.T.,' ')) >= 1  )
DEFAULT lMiddleware:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )
DEFAULT lTemREQ    := GetRPORelease() >= "12.1.033" .OR. ( ChkFile("REQ") .and. FindFunction("fDelDocTAE") .and. FindFunction("FwTotvsSign") )

ADD OPTION aRotina TITLE STR0011 ACTION 'PesqBrw'          	OPERATION 1 ACCESS 0 //"Pesquisar"

If cPaisLoc == "VEN"
	ADD OPTION aRotina TITLE STR0012 ACTION 'VIEWDEF.GPEM030' 	OPERATION 4 ACCESS 0 //"Calculo"
	ADD OPTION aRotina TITLE STR0013 ACTION 'GPER131'		 	OPERATION 6 ACCESS 0 //"Impressao"
ElseIf cPaisLoc == "EQU"
	ADD OPTION aRotina TITLE STR0070 ACTION 'GPFERIAS' 	OPERATION 4 ACCESS 0 //"Individual"
	ADD OPTION aRotina TITLE STR0071 ACTION 'GPFERIAS' 	OPERATION 4 ACCESS 0 //"Coletiva"
ElseIf cPaisLoc == "PTG"
	ADD OPTION aRotina TITLE STR0064 ACTION 'GPFERIAS' 	OPERATION 4 ACCESS 0 //"Gera Progr."
Else
	ADD OPTION aRotina TITLE STR0012 ACTION 'VIEWDEF.GPEM030' 	OPERATION 4 ACCESS 0 //"Calculo"
	ADD OPTION aRotina TITLE STR0013 ACTION 'GPER130'		 	OPERATION 6 ACCESS 0 //"Impressao"
EndIf

If lTemREQ
	ADD OPTION aRotina TITLE STR0180 ACTION 'GPER1033'		 	OPERATION 6 ACCESS 0 //"Assinatura Eletrônica"
	ADD OPTION aRotina TITLE STR0181 ACTION 'fUserTAE()'		OPERATION 6 ACCESS 0 //"Config. Assina. Eletr."
EndIf

ADD OPTION aRotina TITLE STR0086 ACTION 'GPEM019'			OPERATION 2 ACCESS 0 //"Integracao"
ADD OPTION aRotina TITLE STR0015 ACTION 'VIEWDEF.GPEM030'	OPERATION 2 ACCESS 0 //"Visualizar"
ADD OPTION aRotina TITLE STR0014 ACTION 'VIEWDEF.GPEM030' 	OPERATION 5 ACCESS 0 //"Excluir"
If __lMemCalc  .Or. Alltrim( Upper( funname() ) ) == "CFGA530" //Par aparecer na rotina de privilégios do configurador
	ADD OPTION aRotina TITLE OemToAnsi(STR0127) ACTION 'GPEA091(3)' 	OPERATION 4 ACCESS 0 //"Consultar Memória de Calculo"
	ADD OPTION aRotina TITLE OemToAnsi(STR0128) ACTION 'GPER091()' 	OPERATION 6 ACCESS 0 //"Relatório Memória de Cálculo"
EndIf
If cPaisLoc == "BRA" .And. (lIntTaf .Or. lMiddleware) .And. FindFunction("fIntM030Lot")
	ADD OPTION aRotina Title OemToAnsi(STR0148) Action 'fIntM030Lot()' OPERATION 9  ACCESS 0 DISABLE MENU//"Integ. eSocial em lote"
EndIf

If ExistBlock("GP030MNU")
	ExecBlock("GP030MNU", .F., .F.)
EndIf

Return aRotina

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ModelDef  ºAutor  ³Leandro Drumond     º Data ³  03/04/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Definicao do modelo de dados                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function ModelDef()
Local bWhen			:= { || fWhenSRH() } //Antes do calculo, campos podem ser editados, apos o calculo, nenhum campo deve ser editado
Local nX			:= 0
Local oModel
Local oStructSRA
Local oStructSRH
Local oStructSRR

DEFAULT lTemPostUmT    := SRH->( ColumnPos( "RH_POSTUMT" ) ) > 0

oModel:= MpFormModel():New("GPEM030", /*Pre-Validacao*/, {|oModel|VldCalc(oModel)}/*Pos-Validacao*/, {|oModel|m030IniCalc(oModel)}/*Commit*/,/*bCancel*/)

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Estrutura do Cabecalho - SRA             		                         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
oStructSRA := FWFormStruct(1,"SRA",{|cCampo| AllTrim(cCampo)+"|" $ "RA_FILIAL|RA_MAT|RA_NOME|RA_ADMISSA|"})
oModel:AddFields("GPEM030_MSRA", /*cOwner*/, oStructSRA , /*Pre-Validacao*/,/*Pos-Validacao*/,/*Carga*/)
oModel:GetModel("GPEM030_MSRA"):SetOnlyView( .T. )
oModel:GetModel("GPEM030_MSRA"):SetOnlyQuery( .T. )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Estrutura do Cabecalho - SRH             		                         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
oStructSRH := FWFormStruct(1,"SRH")
oModel:AddFields("GPEM030_MSRH", "GPEM030_MSRA", oStructSRH , /*Pre-Validacao*/,/*Pos-Validacao*/,/*Carga*/)

oStructSRH:SetProperty( "RH_PERIODO", MODEL_FIELD_WHEN, { || .F. } )
oStructSRH:SetProperty( "RH_ROTEIR" , MODEL_FIELD_WHEN, { || .F. } )
oStructSRH:SetProperty( "RH_NPAGTO" , MODEL_FIELD_WHEN, { || .F. } )
oStructSRH:SetProperty( "RH_SALARDF", MODEL_FIELD_WHEN, { || .F. } )
If lTemPostUmT
    oStructSRH:SetProperty( "RH_POSTUMT", MODEL_FIELD_WHEN, { || .F. } )
EndIf

// Desabilita quando o tipo do contrato for intermitente
oStructSRH:SetProperty( "RH_DABONPE", MODEL_FIELD_WHEN, { || SRA->RA_TPCONTR != "3" } )
oStructSRH:SetProperty( "RH_ABOPEC",  MODEL_FIELD_WHEN, { || SRA->RA_TPCONTR != "3" } )
oStructSRH:SetProperty( "RH_DFALTAS", MODEL_FIELD_WHEN, { || SRA->RA_TPCONTR != "3" } )
oStructSRH:SetProperty( "RH_PERC13S", MODEL_FIELD_WHEN, { || SRA->RA_TPCONTR != "3" } )
oStructSRH:SetProperty( "RH_DAFASTA", MODEL_FIELD_WHEN, { || SRA->RA_TPCONTR != "3" } )

If cPaisLoc == "BRA"
	oStructSRH:SetProperty("RH_DFERIAS",MODEL_FIELD_VALID,FwBuildFeature( STRUCT_FEATURE_VALID,'( NaoVazio() .or. VldVazioMP() ) .And. fVerDias()'))
EndIf

If aStructSRH == Nil
	aStructSRH := oStructSRH:GetFields()
EndIf

//Garante o WHEN somente nos campos usados para cada pais.
For nX := 1 to Len(aStructSRH)
	If aStructSRH[nX,8] == Nil
		oStructSRH:SetProperty( aStructSRH[nX,3], MODEL_FIELD_WHEN, bWhen )
	EndIf
Next nX

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Estrutura do Grid - SRR											     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
oStructSRR := FWFormStruct(1, "SRR")
IncidCpos(oStructSRR)

oModel:AddGrid("GPEM030_MSRR", "GPEM030_MSRH", oStructSRR,/*bLinePre*/, /* bLinePost*/, /*bPre*/,  /*bPost*/,/*{|oGrid| CargaSRR(oGrid) }*//*bLoad*/)

oStructSRR:SetProperty( 'RR_DESCPD' , MODEL_FIELD_INIT,{|oGrid|FDESC("SRV",If(oGrid:Length()>0,oGrid:GetValue("RR_PD"),SRR->RR_PD),"RV_DESC")})

If aStructSRR == Nil
	aStructSRR := oStructSRR:GetFields()
EndIf

//Nao sera permitido a alteracao/inclusao de valores na grid, qualquer lancamento devera ser incluso atraves da rotina de incidencias
//Garante o WHEN somente nos campos usados para cada pais.
For nX := 1 to Len(aStructSRR)
	oStructSRR:SetProperty( aStructSRR[nX,3], MODEL_FIELD_WHEN, {|| .F. } )
Next nX

oModel:GetModel( "GPEM030_MSRH" ):SetDescription( OemToAnsi(STR0010) ) //"Cálculo de Férias"
oModel:GetModel( "GPEM030_MSRR" ):SetNoInsertLine(.T.)
oModel:GetModel( "GPEM030_MSRR" ):SetNoDeleteLine(.T.)
oModel:GetModel( "GPEM030_MSRR" ):SetOptional(.T.)
oModel:GetModel( "GPEM030_MSRR" ):SetUniqueLine( { 'RR_PD', 'RR_CC', 'RR_SEQ', 'RR_DATA' } )

oModel:SetRelation( "GPEM030_MSRH", { { 'RH_FILIAL', 'xFilial( "SRA" )' }, { 'RH_MAT', 'RA_MAT' }, { 'RH_DATABAS', 'SRH->RH_DATABAS'}, { "RH_DATAINI", "SRH->RH_DATAINI" } }, SRH->( IndexKey( 1 ) ) )
oModel:SetRelation( "GPEM030_MSRR", { { 'RR_FILIAL', 'xFilial( "SRH" )' }, { 'RR_MAT', 'RH_MAT' }, { 'RR_PERIODO', 'RH_PERIODO' }, { "RR_ROTEIR", 'RH_ROTEIR' }, { "RR_SEMANA", 'RH_NPAGTO' }, { "RR_DATA", "RH_DATAINI" }}, SRR->( IndexKey( 4 ) ) )

//Funcao a ser chamada antes da ativacao do Modelo de Dados.
//Pode ser utilizada para inibir a inicializacao do model.
//Se o retorno for negativo, o Model nao sera exibido e a rotina sera abortada
If !lWorkFlow
	oModel:SetVldActivate( { |oModel| GPM030VldIni(oModel,oModel:GetOperation()) } )
EndIf

oModel:SetActivate( { |oModel| Gp030RstDat(oModel,oModel:GetOperation()) } )

Return(oModel)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ViewDef   ºAutor  ³Leandro Drumond     º Data ³  03/04/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Definicao da tela                                 		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function ViewDef()

Local bLancRGB		:= {|| Gpea580(4)}
Local bFverMedia	:= {|| fVerMedia("F")	}
Local bCalcM30		:= {|| MsAguarde( { || lGrvCalc := m030VldCalc(oModel) .and. CalcFer( oModel ) }, OemToAnsi(STR0017), OemToAnsi(STR0037)) } //"Aguarde..."###"Calculando Ferias..."
Local bIntTAF		:= {|| fIntM030Off( oModel ) }
Local bImpRecib		:= {|| GPER130( /*cAlias*/,/*nRecno*/,/*nOpc*/, 1 ) }
Local bImpAviso		:= {|| GPER130( /*cAlias*/,/*nRecno*/,/*nOpc*/, 2 ) }

Local nX			:= 0
Local oModel
Local oStructSRA
Local oStructSRH
Local oStructSRR
Local oView
Local lHistMed		:= AliasInDic("RJK") .And. AliasInDic("SRP")

DEFAULT lIntTAF	   := (GetMv("MV_RHTAF",.T., .F.) == .T. .AND. Val(GetMv('MV_FASESOC',.T.,' ')) >= 1  )
DEFAULT lMiddleware:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )
DEFAULT lItemClVl  := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3" // Define se trabalha com item e classe contabil

oModel:= FwLoadModel("GPEM030")

oView := FWFormView():New()

oView:SetModel(oModel)

oStructSRA := FWFormStruct(2,"SRA",{|cCampo| AllTrim(cCampo)+"|" $ "RA_MAT|RA_NOME|RA_ADMISSA|"})
oStructSRA:SetNoFolder()

oView:AddField( "GPEM030_VSRA" , oStructSRA, "GPEM030_MSRA"  )

oStructSRH := FWFormStruct(2, "SRH")
oStructSRH:SetNoFolder()
oView:AddField("GPEM030_VSRH", oStructSRH, "GPEM030_MSRH" )

oStructSRH:RemoveField("RH_SALARIO")
oStructSRH:RemoveField("RH_PROCES")
oStructSRH:RemoveField("RH_MAT")
oStructSRH:RemoveField("RH_NOME")
oStructSRH:RemoveField("RH_TIPCAL")
oStructSRH:RemoveField("RH_SALMIN")
oStructSRH:RemoveField("RH_SALMIND")

oStructSRR := FWFormStruct(2, "SRR")
IncidCpos(oStructSRR,.T.)

For nX := 1 to Len(aStructSRR)
	If AllTrim(aStructSRR[nX,3]) $ "RR_MAT*RR_TIPO2*RR_TIPO3*RR_NUMID*RR_AUXIL*RR_PERIODO*RR_ROTEIR*RR_SEMANA*RR_PROCES*RR_IDCMPL"
		oStructSRR:RemoveField(aStructSRR[nX,3])
	EndIf
Next nX

If !lItemClVl
	oStructSRR:RemoveField("RR_ITEM")
	oStructSRR:RemoveField("RR_CLVL")
EndIf

oView:AddGrid("GPEM030_VSRR", oStructSRR, "GPEM030_MSRR" )

oView:CreateHorizontalBox("SRA_HEAD", 09)
oView:createHorizontalBox("FORMFIELD",50)
oView:createHorizontalBox("FORMGRID",41)

oView:SetOwnerView( "GPEM030_VSRA", "SRA_HEAD" )
oView:SetOwnerView( "GPEM030_VSRH", "FORMFIELD" )
oView:SetOwnerView( "GPEM030_VSRR", "FORMGRID" )

oView:addUserButton(OemToAnsi(STR0089) + " <F6>","MAGIC_BMP", bCalcM30,   OemToAnsi(STR0089),VK_F6, {MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE} ) //"Calcular"
oView:addUserButton(OemToAnsi(STR0075),"MAGIC_BMP", bLancRGB, OemToAnsi(STR0075),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE,MODEL_OPERATION_VIEW } )	//"Incidências"

If !cPaisLoc $ "PER|ANG"
	oView:addUserButton(OemToAnsi(STR0058),"MAGIC_BMP", bFverMedia, OemToAnsi(STR0059),VK_F4,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE,iif(lHistMed,MODEL_OPERATION_VIEW,)} )	//"Visualizar Medias <F4>..." ## Medias
	oView:addUserButton(OemToAnsi(STR0204),"MAGIC_BMP", bImpRecib, OemToAnsi(STR0205),VK_F7,{MODEL_OPERATION_VIEW} )	//"Imp.Recib.Férias <F7>..." ## Recibo de Férias	
	oView:addUserButton(OemToAnsi(STR0206),"MAGIC_BMP", bImpAviso, OemToAnsi(STR0207),VK_F8,{MODEL_OPERATION_VIEW} )	//"Imp.Aviso Féiras <F8>..." ## Aviso de Férias
EndIf

//Botão auxiliar para integração no TAF
If cPaisLoc == "BRA" .And. (lIntTaf .Or. lMiddleware) .And. FunName() == "GPEM030" .And. FindFunction("fIntM030Off")
	oView:addUserButton( OemToAnsi(STR0149), "MAGIC_BMP", bIntTAF, OemToAnsi(STR0149), , {MODEL_OPERATION_VIEW} )	//"Integração com eSocial"
EndIf

oView:SetCloseOnOk({ || .T. })		//Apos COMMIT gravacao fecha a tela

oView:SetViewCanActivate({ |oView| Gp30VldView(oView)})

oView:SetViewAction( 'BUTTONCANCEL', { |oView| fDelHist( .F.,oView ), fDelRU6( .F.,oView ) } )


aStructSRR := Nil //Zera static

Return(oView)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gp30VldView ºAutor  ³Leandro Drumond   º Data ³  23/07/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida view			                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Gp30VldView(oView)
cIdHistMed := ""
Return lSeleFer //Se cancelou a seleção de periodos de ferias, desabilita view sem exibir erro.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gpm030VldIniºAutor  ³Leandro Drumond   º Data ³  17/09/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida model			                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Gpm030VldIni(oModel,nOperacao)
Local aArea		:= GetArea()
Local aFerDisp	:= {}
Local aTabVen	:= {}
Local aFerProg  := {}
Local cSeekSRF	:= ""
Local dNDataIni	:= CtoD("")
Local dNDataBas	:= CtoD("")
Local dDtAteNew := CtoD("")
Local lFound	:= .F.
Local lRet		:= .T.
Local nRet      := 0
Local lUltSemana
Local nTempoParc	:= 0
Local lRobo 	:= IsBlind() .Or. IsInCallStack("FwMyTestRunner") .Or. IsInCallStack("EXECSUITE") .Or. IsInCallStack("EXECSUITEBLIND") .Or. IsInCallStack("AUTJOBRUNCT")
Local aRotCalc  := {}
Local nI        := 0

DEFAULT lCtrlTit   := !Empty(GetNewPar("MV_BTITFER", "" )) .And. ChkFile("RJ1") .And. RJ1->(ColumnPos( "RJ1_ROTEIR")) > 0 .And. RJ1->(ColumnPos( "RJ1_PROCES")) > 0 .And. RJ1->(ColumnPos( "RJ1_TIPO")) > 0
DEFAULT nRHTAEEX   := GetMvRH( "MV_RHTAEEX",,3 )
DEFAULT lTemREQ    := GetRPORelease() >= "12.1.033" .OR. ( ChkFile("REQ") .and. FindFunction("fDelDocTAE") .and. FindFunction("FwTotvsSign") )
DEFAULT lTemRF13   := SRF->( ColumnPos( "RF_PER13S2" ) ) > 0

If !lRobo .AND. FWIsInCallStack("GPEM030")
	RstlDefaut()
	SetMnemonicos(NIL,NIL,.T.,,,"GPEM030")
EndIf

P_REGPARCI	:= If( Type("P_REGPARCI") == "U", .F. , P_REGPARCI)

cTipoRot	:= "3"
lSeleFer 	:= .T.
lTerFerMP   := .F.
lGrvCalc	:= .F.
lAposInv    := .F.

If nOperacao == MODEL_OPERATION_DELETE
	//?- Verifica se o calculo esta Liberado
	If !fVldAccess( cFilAnt, SRH->RH_DATAINI, SRH->RH_NPAGTO, .T., fGetCalcRot("3") )
	   Return( .F. )
	EndIf
EndIf

If lRobo
	RstMnemonicos()
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega tabela de Identificadores 							 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Fp_CodFol( @aCodFol, SRA->RA_FILIAL, .T. )
	Help( ,, OemToAnsi(STR0088),, OemToAnsi(STR0097), 1, 0 ) //"Atenção" ## "Falha na carga de verbas"
   	Return( .F. )
EndIf

If nOperacao <> MODEL_OPERATION_UPDATE //Diferente de Calculo
	cAboPec  	:= " "                   //-- Abono antes ferias

	cMat  		:= SRA->RA_MAT
	cNome 		:= SRA->RA_NOME
	cMesAnoRef	:= cAnoMes				//-- Mes ano de processamento
	cSemana 	:= ''
	nRecSrh     := 0

	aTabFer     := {}     // Tabela para calculo dos dias de ferias
	nPosFer		:= 0	  //  Poscisao do array aPerFerias com as ferias que esta sendo calculada
	aLogErros	:= {}	  // Array com os logs de erros de processamento

	nFaltas     := nDescFal := 0
	n2DFerave   := n2DFerVen := 0
	nDBonave    := nDBonVen := 0
	nFalBon		:= 0
	nDAntPer    := 0
	nDVenPen    := 0
	dIVenPen    := dFVenPen := dDtBasFim := Ctod("")
	nDferV    	:= 0
	nDFerP	    := 0
	cDescTipAfa := ""
	cPeriAnt    := ""
	cNpagAnt    := ""
	nDDobro     := 0
	nVacMens    := 0
	nSusMens    := 0
	dRch_DtIni  := dDataDe
	dRch_DtFim  := DDataAte
	dRch_DtCort := CtoD("")

	aFerDisp := {}
	dbSelectArea( "SRH" )
	SRH->(DbSetOrder(1))
	dbSeek(SRA->RA_FILIAL+SRA->RA_MAT)
	While !Eof() .And. SRH->RH_FILIAL+SRH->RH_MAT == SRA->RA_FILIAL+SRA->RA_MAT
		aAdd(aFerDisp, { SRH->RH_DATABAS, SRH->RH_DBASEAT, SRH->RH_DATAINI,;
			SRH->RH_DATAFIM, SRH->RH_DFERIAS, SRH->RH_DABONPE })
		dbSkip()
	EndDo
	If Len(aFerDisp) > 1
		aSort( aFerDisp ,,, { |x,y| x[3]> y[3] } )
		If !fSeleFer(aFerDisp,@dNDataBas,@dNDataIni)
			lSeleFer := .F.
			Return( .T. )
		EndIf
	ElseIf Len(aFerDisp) == 1
		dNDataBas := aFerDisp[1,1]
		dNDataIni := aFerDisp[1,3]
	EndIf

	If Empty(dNDataIni)
		lFound := dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+DTOS(dNDataBas))
	Else
		lFound := dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+DTOS(dNDataBas)+DTOS(dNDataIni))
	EndIf

	// Não realiza validação sobre dados de cálculo de Férias coletivas ou programadas
	If  lCtrlTit .And. nOperacao != 1 // Quando não for visualização
		If !(SRH->RH_TIPCAL $ "P*C") .And. fExisTitFe() .And. Len( aLogErros ) > 0
			// "Atenção"###"Ação cancelada - título(s) encontrado(s) sobre essa férias."###"Consulte os títulos listados no log."
			Help( ,, OemToAnsi(STR0088),, OemToAnsi(STR0152), 1, 0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0154)})
			// Imprime Log
			fCtrTitLg()
			Return(.F.)
		EndIf
	EndIf

	If !lFound
		If GetRemoteType() == -1 .or. lWorkFlow						//-- Verifica se origem foi job
			MsgLogGrid( Ap5GetHelp("GPEM30NCA"), .F. )  //-- Retornar string da funcao Help
		Else
			Help(" ",1,"GPEM30NCA")
		EndIf
		Return( .F. )
	EndIf

	If nOperacao == MODEL_OPERATION_DELETE

		fRetPerComp(SubStr(Dtos(dNDataIni),5,2), SubStr(Dtos(dNDataIni),1,4),, SRA->RA_PROCES,fGetCalcRot("3"),@aPeriodo )
		
		If Empty(aPeriodo)	// O período dessas férias já foi fechado.
			Help(,,STR0088,, STR0091,1,0 ) //"Aviso","Período referente as férias escolhidas para serem excluidas já foi fechado.   "###"Confirma"
			If lCtrlTit  .And. Len( aLogErros ) > 0
				fCtrTitLg()
			EndIf
			Return( .F. )
		ElseIf !Empty(aPeriodo[1][11]) .AND. nOperacao == MODEL_OPERATION_DELETE // Data de Integração
			Help(,,STR0088,, STR0087,1,0 ) //"Aviso","Período de Férias já foi integrado.   "###"Confirma"
			If lCtrlTit  .And. Len( aLogErros ) > 0
				fCtrTitLg()
			EndIf
			Return( .F. )
		EndIf

		If lTemREQ .and. nRHTAEEX <> 3
			//Verifica se existe integração do documento no TAE e se ele pode ser excluído
			nRet := fChkDocTAE(SRA->RA_FILIAL, SRA->RA_MAT, , "1", SRH->RH_DATAINI)
			
			If nRet == 2
				Return( .F. )
			ElseIf nRet == 3
				If nRHTAEEX == 1
					Help(,,STR0088,, STR0176,1,0 ) //"Atenção" ### "O recibo de férias integrado ao TAE já foi assinado e conforme parametrização do MV_RHTAEEX o cálculo não poderá ser excluído."
					Return( .F. )
				ElseIf nRHTAEEX == 2 
					If !MsgYesNo(STR0178, STR0177) //"O recibo de férias integrado ao TAE já foi assinado e não poderá ser excluído."   ### "Prosseguir com a exclusão do cálculo? "
						Help( ,, STR0088,, STR0179 , 1,,,,,,, {""} ) //"Atenção" ### "Ação cancelada"
						Return( .F. )
					EndIf
				EndIf 
			EndIf	
		EndIf
	EndIf

	nRecSrh := SRH->(Recno())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria Temporario para Calculo de Medias                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Cria_Trp()

Else  // Calculo
	aPeriodo	:= {}
	nFaltas     := nDescFal := 0
	n2DFerave   := n2DFerVen := 0
	nDBonave    := nDBonVen := 0
	SalMes		:= SalDia	:= SalHora	:= 0
	nFalBon		:= 0
	nDAntPer    := 0
	nDVenPen    := 0
	dIVenPen    := dFVenPen := dDtBasFim := Ctod("")
	nDferV    	:= 0
	nDFerP	    := 0
	cDescTipAfa := ""
	cPeriAnt    := ""
	cNpagAnt    := ""
	nDDobro     := 0
	nQtdSRH		:= 0

	If cPaisLoc == "VEN"
		aTabVen := {}
		fRetTab(@aTabVen,"S006",4,,dDataBase,SRA->RA_SINDICA)
		If Empty(aTabVen)
			If Empty(SRA->RA_SINDICA)
				FMSGFORM( {32,12} , {"","."} , 1 , , .F. , .F. )
			Else
				FMSGFORM( {32} , {SRA->RA_SINDICA + "."} , 1 , , .F. , .F. )
			EndIf
			Return(.F.)
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o Funcionario Esta Demitido                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SRA->RA_SITFOLH == "D"
		If GetRemoteType() == -1 .or. lWorkFlow	//-- Quando estiver utilizando JOB
			MsgLogGrid( Ap5GetHelp("GPEM30AFAS"), .F. ) //-- Retornar string da função Help
		Else
			Help(" ","1","GPEM30AFAS")
		EndIf
		Return(.F.)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o Funcionario possui rescisão calculada          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea("SRG")
	If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT)
		While SRG->(!Eof()) .and. SRG->(RG_FILIAL+RG_MAT) == SRA->RA_FILIAL + SRA->RA_MAT
			If SRG->RG_EFETIVA == 'S'
				Help(,,STR0088,, STR0100,1,0 ) //"Funcionário possui rescisão calculada. Deve excluir a rescisão antes de prosseguir como cálculo de férias."
				//Help(" ","1","GPEM30DEM") Utilizar este no release que o help estiver disponível - Incluído em 12/05/16
				Return(.F.)
			EndIf
			SRG->(dbSkip())
		EndDo
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o Funcionario Esta Afastado                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SRA->RA_SITFOLH == "A"
		If !(GetRemoteType() == -1) .and. !lWorkFlow	//-- Executa quando não for job
			AVISO(STR0034,STR0076,{STR0001})  //"Aviso","Funcionário está com situação de afastado no cadastro.   "###"Confirma"
		EndIf
	EndIf

	DbSelectArea("RCM")
	RCM->(DbSetOrder(3))
	If !DbSeek(FwxFilial("RCM") + fGetCodFol( "0072", .F. ) )
		Help( ,, OemToAnsi(STR0088),, OemToAnsi(STR0060) , 1,,,,,,, {OemToAnsi(STR0132)} ) //"Não existe Tipo de Ausencia Cadastrada" //"Vincular uma verba com ID 0072 no Tipo de Ausência - Férias"
		RCM->(DbSetOrder(1))
		Return(.F.)
	Else
		If cPaisLoc == 'COL' .And. RCM->RCM_TIPODI == "1" .And. (Empty(SRA->RA_REGRA) .Or. Empty(SRA->RA_SEQTURN))
			Help(,,STR0088,, STR0065, 1, 0 )  // "Para ferias que utilizam dias uteis, e necessario que os campos Regra e Sequencia de Turno estejam registradas no Cadastro de Funcionarios.
			RCM->(DbSetOrder(1))
			Return(.F.)
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Carrega tabela para apuracao dos dias de ferias - aTabFer    |
	//| 1-Meses Periodo    2-Nro Periodos   3-Dias do Mes    4-Fator |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Verifica a existecia do array aTabFer p/ o calculo de ferias |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("aTabFer") # "A" .Or. Len(aTabFer) == 0 .Or. (cPaisLoc == "PER" .And. Type("aTabFer[5]") == "U")
		aTabFer := {}
		If cPaisLoc == "PER"
			fRetTab(@aTabFer,"S017",,,fCalcFimAq(Iif(dDataRef==Nil,dDataAte,dDataRef)),)

		ElseIf cPaisLoc == "COL"
			nDiasFer := If(fTabela("S021", 1, 8) <> Nil, fTabela("S021", 1, 8), 15)
			nFator	 := nDiasFer/12
			nTotDiaPer := nDiasFer
			aTabFer := {12, 0, nDiasFer, nFator}
		ElseIf cPaisLoc == "PAR"
			If !LOC_IPS(@nIPSPatr,@nIPSFunc,MesAno(dDataAte))
				Return .F.
			EndIf
        ElseIf cPaisLoc == "CHI"
			// Carregando a Tabela de UF e UTM
			If !SetValUNS(@nValUF,@nValUTM)
				Return .F.
			EndIf
		Else
			If !(cPaisLoc $ 'ANG')
				fTab_Fer(@aTabFer,,@aTabFer2)
				//Se as horas semanais forem inferiores a 26, e o Mnemonico P_REGPARCI estiver ativo,
				//utiliza os dias de férias da tabela S065 - Tabela de férias tempo parcial (Artigo 130A da CLT)
				If cPaisLoc == "BRA"
					nTempoParc := SRA->RA_HRSEMAN
					If ( ( SRA->RA_HOPARC == "1" .And. nTempoParc <= 25 ) .And. nTempoParc  > 0 .And. Len(aTabFer2) > 0	.And. P_REGPARCI )
						nPosTbFer := Ascan(aTabFer2, { |X|  nTempoParc <= X[6] .And. nTempoParc > X[5] })
						If nPosTbFer > 0
							aTabFer := aClone(aTabFer2[nPosTbFer])
						Endif
					Endif
				EndIf
			EndIf
		EndIf
	EndIf

	If cPaisLoc == "PAR"
		If !LOC_IPS(@nIPSPatr,@nIPSFunc,MesAno(dDataBase))
			Return .F.
		EndIf
  	ElseIf cPaisLoc == "CHI"
		// Carregando a Tabela de UF e UTM
		If !SetValUNS(@nValUF,@nValUTM)
			Return .F.
		EndIf
  	EndIf

	If cPaisLoc == "PER"
		If SRA->RA_MEIOPER == "1" //# Part Time
			nDiasFer := aTabFer[6]
		Else
			nDiasFer := aTabFer[5]
		EndIf
		nDiasAux := nDiasFer
	ElseIf !(cPaisLoc $ 'ANG')
		nDiasFer := aTabFer[4]
		nDiasAux := aTabFer[3]
	EndIf

	aPerFerias := {}

	nSavRec := RecNo()
	cAlias  := "SRH"

	cProcesso 	:= SRA->RA_PROCES
	aRotCalc 	:= fGetCalcRot(cTipoRot, Nil, Nil, .T.) //Retorna o(s) roteiro(s) 

	For nI := 1 to Len(aRotCalc)
		If aRotCalc[nI,2] == cTipoRot
			cRot := aRotCalc[nI, 3]
			fGetLastPer( @cPeriodo,@cSemana , cProcesso, cRot , .T., .F., @cAnoMes ) //Carrega o último período aberto
			aPeriodo := {}
			fCarPeriodo( cPeriodo , cRot , @aPeriodo, @lUltSemana, @nPosSem)	//Carrega todos os dados do periodo
			
			RCH->(DbSetOrder(4))//RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG
			If(RCH->(DbSeek(xFilial("RCH")+cProcesso+cRot+cPeriodo+cSemana)))
				If (aScan(aRotFer, {|x| AllTrim(Upper(x[1])) == SRA->RA_PROCES})) == 0
					aAdd(aRotFer, {cProcesso, cRot}) 
				EndIf
				Exit
			EndIf
		EndIf
	Next
	If !Empty(RCH->RCH_DTINTE)
		RCH->(DbSkip())
		If (RCH->(RCH_FILIAL+RCH_PROCES+RCH_ROTEIR) == xFilial("RCH")+cProcesso+cRot)
			cPeriodo := ""
			While RCH->(!Eof() .and. RCH_FILIAL+RCH_PROCES+RCH_ROTEIR == xFilial("RCH")+cProcesso+cRot)
				If Empty(RCH->RCH_DTINTE)
					cPeriodo := RCH->RCH_PER
					cSemana  := RCH->RCH_NUMPAG
					Exit
				EndIf
				RCH->(DbSkip())
			EndDo
			If Empty(cPeriodo)
				Help(,,STR0088,, STR0087,1,0 ) //"Período de Férias ja foi integrado"
				Return(.F.)
			EndIf
		Else
			Help(,,STR0088,, STR0087,1,0 ) //"Período de Férias ja foi integrado"
			Return(.F.)
		EndIf
		aPeriodo := {}
		fCarPeriodo( cPeriodo , cRot , @aPeriodo, @lUltSemana, @nPosSem)
	EndIf

	If ( Len(aPeriodo) > 0 )

	    dDataDe 	:= aPeriodo[nPosSem,3]
	    dDataAte 	:= aPeriodo[nPosSem,4]
	    NSVNORMAL 	:= NORMAL 	:= aPeriodo[nPosSem,14]
	    NSVDESCAN 	:= DESCANSO	:= aPeriodo[nPosSem,13]
	    cAnoMes  	:= aPeriodo[nPosSem,15] + aPeriodo[nPosSem,16]
	    dData_Pgto 	:= aPeriodo[nPosSem,17]
	    dDataRef 	:= CtoD("01/" + aPeriodo[nPosSem,16] + "/" + aPeriodo[nPosSem,15])
	Else
		Help(,,STR0088,, STR0077,1,0 ) //"A configuração dos períodos esta incorreta ou não existe período válido para o roteiro de férias. Verifique o cadastro de períodos."
		Return(.F.)
	EndIf

	Private lQuitMes := .F.

	dDtFim	   := CtoD("//")
	dDtIniProg := CtoD("//")
	nDAbProg   := 0
	nDiasProg  := 0
	nPercProg  := 0

	DbSelectArea("SRF")
	DbSetOrder(2)

	cSeekSRF := SRA->RA_FILIAL + SRA->RA_MAT + fGetCodFol("0072")

	If DbSeek(cSeekSRF)
		While SRF->(!Eof() .and. RF_FILIAL + RF_MAT + RF_PD == cSeekSRF )
			If SRF->RF_STATUS $ " 1" .and. ( SRF->RF_DFERVAT > 0 .or. SRF->RF_DFERAAT > 0  .or. SRF->RF_DVENPEN > 0 .Or. lQuitMes ) .And. !fQuitadMes() //Carrega o primeiro periodo aquisitivo com dias vencidos ou a vencer
				aAdd(aPerFerias,{	SRF->RF_DATABAS	,;										  		 			// 01 - Inicio Database de Ferias
									If(Empty(SRF->RF_DATAFIM),fCalcFimAq(SRF->RF_DATABAS),SRF->RF_DATAFIM),;  // 02 - Final Database de Ferias
									SRF->RF_DFERVAT	,;															// 03 - Dias de ferias vencidas
									SRF->RF_DFERAAT	,;															// 04 - Dias de ferias a vencer
									0.00			,;															// 05 - Dias totais de afastamento por periodo
									SRF->RF_OBSERVA	,;															// 06 - Descricao do tipo de afastamento do periodo
									CtoD("")		,;															// 07 - Data de original de termino do p.aquisitivo quando houver prorrogacao do mesmo RWX
									If(Empty(SRF->RF_STATUS),"1",SRF->RF_STATUS),;								// 08 - Status do periodo de ferias:  1-Ativo (Vencidos/A vencer)/2-Prescrito (Perdido)/3-Pago
									CtoD("")		,;															// 09 - Data de Inicio do Proximo periodo caso seja um periodo perdido.
									0				,;															// 10 - Quantidade dias de deducao para o direito apurado no periodo
									SRF->RF_DVENPEN ,;     														// 11 - Dias Vencidos Pendentes
									SRF->RF_IVENPEN ,;     														// 12 - Data Inicia Vencido Pendente
									SRF->RF_FVENPEN ,;															// 13 - Data Inicia Vencido Pendente
									SRF->RF_DFERANT ,;     														// 14 - Dias de Ferias Antecipadas
									SRF->RF_DFALVAT ,;     														// 15 - Dias de Faltas Vencidas
									SRF->RF_DFALAAT ,; 				    										// 16 - Dias de Faltas a Vencer
									If(cPaisLoc$"VEN|EQU",SRF->RF_DBONVAT,NIL),;				 				// 17 - Dias de bono vencido
									If(cPaisLoc$"VEN|EQU",SRF->RF_DBONAAT,NIL),; 								// 18 - Dias de bono a Vencer
									0				,;															// 19 - Total de dias de ferias
									0				,;															// 20 - Total de dias de bonificacao
									0				,;															// 21 - Dias de Faltas vencidas bonificacao
									0				,;															// 22 - Dias de ¦Faltas a Vencer bonificacao
									0				,;															// 23 - Dias de ausencia convertidos em ferias
									0				,;      													// 24 - Total de Dias de Ferias do Periodo
									SRF->RF_DIASANT ,;					      									// 25 - Dias Gozados Vencidos
									SRF->RF_DIASANT	,;	    													// 26 - Dias Gozados a Vencer
									0               ,;      													// 27 - Dias Subsid. Vencidos
									0               ,;   														// 28 - Dias Subsid. a Vencer
									0				,; 															// 29 - Dias de Pagto. Minimo na Adm/Dem (cpo. RF_PAGOFER desabilitado 08/2012)
									SRF->( RECNO() ),;															// 30 - Recno do aquivo
									Iif ( (cPaisLoc == "BOL" .or. cPaisLoc == "COL") , Iif(Type("SRF->RF_FERPAGA")<>"U",  SRF->RF_FERPAGA, 0), 0 )        ,;					// 31 - Dias pagos em R$ na folha
									SRF->RF_DATAATU	,;
									0                ;                                                  		// 33 - Dias de suspensão do período
									})
				If SRF->RF_DVENPEN > 0
					fVldFerPen( @aPerFerias[Len(aPerFerias)] )
				EndIf
				
				aFerProg := {}

				If SRF->RF_DATAINI >= dDataDe
					aAdd(aFerProg, {SRF->RF_DATAINI,SRF->RF_DFEPRO1,SRF->RF_DABPRO1,SRF->RF_PERC13S})
					dDtFim	   := SRF->RF_DATAFIM
				EndIf
				If SRF->RF_DATINI2 >= dDataDe
					aAdd(aFerProg, {SRF->RF_DATINI2,SRF->RF_DFEPRO2,SRF->RF_DABPRO2,If(lTemRF13, SRF->RF_PER13S2,SRF->RF_PERC13S)})
				EndIf 
				If SRF->RF_DATINI3 >= dDataDe
					aAdd(aFerProg, {SRF->RF_DATINI3,SRF->RF_DFEPRO3,If( cPaisloc $ "BRA*PTG", SRF->RF_DABPRO3, 0),If(lTemRF13, SRF->RF_PER13S3,SRF->RF_PERC13S)})
				EndIf

				lQuitMes := .F.
				If !Empty(aFerProg)
					SRH->( dbSetOrder(2) )//RH_FILIAL+RH_MAT+DTOS(RH_DATAINI)

					For nI := 1 to Len(aFerProg)
						If !(SRH->( DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + DtoS(aFerProg[nI,1])) ) .And. SRH->RH_DFERIAS == aFerProg[nI,2])
							dDtIniProg := aFerProg[nI,1]
							nDiasProg  := aFerProg[nI,2]
							nDAbProg   := aFerProg[nI,3]
							nPercProg  := If(cPaisLoc == "BRA" .and. P_M13FER > 1 .and. Month(dDtIniProg) < P_M13FER, 0, aFerProg[nI,4])
							Exit
						EndIf
					Next nI
				EndIf
				Exit
			ElseIf SRF->RF_STATUS $ "2" .And. SRF->RF_DFALAAT > 32 .And. SRF->RF_DATAFIM >=  dDataAte // Período Aquisitivo Prescrito por Faltas em relação ao Período Ativo da Folha
					dDtAteNew	:= YearSum(SRF->RF_DATAFIM, 1)
			EndIf
			SRF->(DbSkip())
		EndDo
	Else
		Help( ,, OemToAnsi(STR0088),, OemToAnsi(STR0098), 1, 0 ) //"Atenção" ## "Funcionário não tem registro cadastrado para o ID 0072 no cadastro de Controle de Dias de Direito."
		Return( .F. )
	EndIf

	If !Empty(dDtIniProg) //Se existir programcao de ferias, posiciona no periodo
		fRetPerComp(SubStr(Dtos(dDtIniProg),5,2), SubStr(Dtos(dDtIniProg),1,4),, cProcesso,cRot,@aPeriodo )
		If Empty(aPeriodo) .or. !Empty(aPeriodo[1,11])
			dDtIniProg := CtoD("")
		Else
			cPeriodo := aPeriodo[1,1]
			cSemana  := aPeriodo[1,2]
		EndIf

		//Carrega novo periodo
		aPeriodo := {}

		//Carrega todos os dados do periodo
		fCarPeriodo( cPeriodo , cRot , @aPeriodo, @lUltSemana, @nPosSem)

		RCH->(DbSetOrder(4))//RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG
		RCH->(DbSeek(xFilial("RCH")+cProcesso+cRot+cPeriodo+cSemana))

		If !Empty(RCH->RCH_DTINTE)
			RCH->(DbSkip())
			If (RCH->(RCH_FILIAL+RCH_PROCES+RCH_ROTEIR) == xFilial("RCH")+cProcesso+cRot)
				cPeriodo := ""
				While RCH->(!Eof() .and. RCH_FILIAL+RCH_PROCES+RCH_ROTEIR == xFilial("RCH")+cProcesso+cRot)
					If Empty(RCH->RCH_DTINTE)
						cPeriodo := RCH->RCH_PER
						cSemana  := RCH->RCH_NUMPAG
						Exit
					EndIf
					RCH->(DbSkip())
				EndDo
				If Empty(cPeriodo)
					Help(,,STR0088,, STR0087,1,0 ) //"Período de Férias ja foi integrado"
					Return(.F.)
				EndIf
			Else
				Help(,,STR0088,, STR0087,1,0 ) //"Período de Férias ja foi integrado"
				Return(.F.)
			EndIf
			aPeriodo := {}
			fCarPeriodo( cPeriodo , cRot , @aPeriodo, @lUltSemana, @nPosSem)
		EndIf

		If ( Len(aPeriodo) > 0 )

		    dDataDe 	:= aPeriodo[nPosSem,3]
		    dDataAte 	:= aPeriodo[nPosSem,4]
		    NSVNORMAL 	:= NORMAL 	:= aPeriodo[nPosSem,14]
		    NSVDESCAN 	:= DESCANSO	:= aPeriodo[nPosSem,13]
		    cAnoMes  	:= aPeriodo[nPosSem,15] + aPeriodo[nPosSem,16]
		    dData_Pgto 	:= aPeriodo[nPosSem,17]
		    dDataRef 	:= CtoD("01/" + aPeriodo[nPosSem,16] + "/" + aPeriodo[nPosSem,15])
		Else
			Help(,,STR0088,, STR0077,1,0 ) //"A configuração dos períodos esta incorreta ou não existe período válido para o roteiro de férias. Verifique o cadastro de períodos."
			Return(.F.)
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se Periodo de F‚rias ja foi Calculado totalmente     ³
	//³abre novo Periodo Verifica se o Funcionario Esta Afastado     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(aPerFerias)
		nPosFer		:= aScan(aPerFerias,{ |X| X[8] == "1" })
		If !fFerCal(2,aPerFerias[nPosFer][1],Iif(cPaisLoc=="COL" .And. Type("aPerFerias[nPosFer][31]")<>"U", aPerFerias[nPosFer][31], 0),cPerFeAc,aPerFerias[nPosFer][1],.F.)
			aPerFerias := {}
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Funcao Para Calcular Dias Ferias Vencidas e Proporcionais  ³
	³ Achar os dias de Ferias                                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If Empty(aPerFerias) .or. ( !Empty(dDtIniProg) .and. Len(aPerFerias) == 1 .and. AnoMes(aPerFerias[1,2]) < AnoMes(dDtIniProg))
		If !(cPaisLoc $ "PER|PTG|ANG") .Or. StrZero(Year(SRA->RA_ADMISSA),4) == StrZero(Year(dDataAte),4)
			If Len(aPerFerias) == 0 .And. !Empty(dDtAteNew)
				dDataAte := dDtAteNew
			EndIf
			Calc_Fer(@aPerFerias,dDataAte,,,,,,.f.)
		ElseIf cPaisLoc == "ANG"
			Calc_Fer(@aPerFerias,LastDate(CtoD("01/"+Substr(cMesAnoRef,5,2)+"/"+Substr(cMesAnoRef,1,4))),@n2Dferven,,,,,.f.)
		ElseIf cPaisLoc == "PER"
	   		Calc_Fer(@aPerFerias,dDataAte,,,,,,.f.)
		Else
			Calc_Fer(@aPerFerias,Ctod("31/12/"+StrZero(Year(dDataAte),4)),,,,,,.f.)
		EndIf
	EndIf

	// Posicionar no periodo aberto atual
	nPosFer		:= aScan(aPerFerias,{ |X| X[8] == "1" })
	//--Help de Periodo aberto nao encotrado no SRF
	If nPosFer = 0
		If GetRemoteType() == -1 .or. lWorkFlow						//-- Quando estiver utilizando JOB
			MsgLogGrid( Ap5GetHelp("GPEM30PER"), .F. )  //-- Retornar string da funcao Help
		Else
			Help(" ","1","GPEM30PER")
		EndIf
		Return( .F. )
	EndIf

	fFerCal(2,aPerFerias[nPosFer][1],Iif(cPaisLoc=="COL" .And. Type("aPerFerias[nPosFer][31]")<>"U", aPerFerias[nPosFer][31], 0),cPerFeAc,aPerFerias[nPosFer][1],.F.)

	SRF->(DBSetOrder(1))
	SRF->(DBSeek(SRA->RA_FILIAL + SRA->RA_MAT + DToS(aPerFerias[nPosFer][1] )))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria Temporario para Calculo de Medias                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Cria_Trp()

	n2Dferven  := aPerFerias[nPosFer][3]
    n2Dferave  := aPerFerias[nPosFer][4]


	n2Dferven := If (n2DferVen <= 0,n2Dferave,n2Dferven)
	If cPaisLoc = "BRA"
		n2Dferven := If (n2DferVen>nDiasAux,nDiasAux,n2Dferven)
	EndIf


	// Verifica as Faltas e Calcula as Medias do Periodo
	Ver_med(@nfaltas)

	If nFaltas == 0
		//--Quando as Ferias for a Vencer deve proporcionalizar as Ferias
		If n2Dferven < aTabFer[3]
			If cPaisLoc=="BRA" .and. cPerFeAc=='S' .and. n2Dferven > 0
				nFaltas  := SRF->RF_DFALVAT
			Else
				nFaltas  := SRF->RF_DFALAAT
			EndIf
		Else
			nFaltas  := SRF->RF_DFALVAT
		Endif
	Endif

	nBkpFalt := nFaltas

	// Se funcionário possuir mais de 32 faltas, atualiza status do período aquisitivo para Prescrito e cria um novo
	If nFaltas > 32
		Reclock("SRF",.F.)
		SRF->RF_STATUS := "2"
		MSUnlock()

		MkNewPerSRF(SRA->RA_FILIAL, SRA->RA_MAT, fGetCodFol("0072"), SRF->RF_DATAFIM + 1)
		dDataAte := YearSum(SRF->RF_DATAFIM, 1)
		If !IsBlind()
			Aviso( STR0088 , "O funcionário perdeu o direito a ferias no periodo aquisitivo de " + DToC(SRF->RF_DATABAS) + " - " + DToC(SRF->RF_DATAFIM) +  " por ter mais de 32 faltas. O controle de dias de direito foi atualizado.", { "OK" }, 2) // Atenção #
		Endif
		aPerFerias	:=	{}
		nFaltas		:=	0
		Calc_Fer(@aPerFerias,dDataAte,,,,,,.f.)
		nPosFer		:= aScan(aPerFerias,{ |X| X[8] == "1" })

		n2Dferven  := aPerFerias[nPosFer][3]
		n2Dferave  := aPerFerias[nPosFer][4]

	Endif

	//--Armazena data do Periodo e Dias Antecipados.
	dDtBasFer := aPerFerias[nPosFer][1]
	nDAntPer  := Iif(cPaisLoc=="COL" .And. Type("aPerFerias[nPosfer][31]")<>"U", aPerFerias[nPosfer][31], 0)
	dNDataBas := aPerFerias[nPosFer][1]
    dDT1      := dDtBasFer	 // dDt1 - Mnemonico Tipo Publico utilizado no GPEXMED


    If cPaisLoc == "VEN"
	    nDBonVen  := aPerFerias[nPosFer][17]
	    nDBonave  := aPerFerias[nPosFer][18]
    EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se Periodo de F‚rias ja foi Calculado totalmente     ³
	//³abre novo Periodo Verifica se o Funcionario Esta Afastado     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !fFerCal(2, @dDtBasFer, @nDAntPer, cPerFeAc, dNDataBas, Nil, nFaltas)
		Return(.F.)
	EndIf

	//Caso não existam férias calculadas no sistema (SRH), a variável nDAntPer será 0,
	//No caso, verifica se há quantidade informadas manualmente no campo RF_DFERANT
	//Caso exista, insere o valor na variável para o abatimento do cálculo das férias.
	If cPaisLoc == "BRA"
		If nDAntPer == 0 .And. aPerFerias[nPosFer][14] > 0
			nDAntPer += aPerFerias[nPosFer][14]
		EndIf
	EndIf
	n2Dferven := If (n2DferVen <= 0,n2Dferave,n2Dferven)

	SRH->(DbSeek(xFilial("SRH")+"XXXXXX"))

EndIf

RestArea(aArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp030RstDat³ Autor ³ Leandro Drumond 		³ Data ³ 03/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Preenche model com os dados calculados					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function Gp030RstDat(oModel,nOperacao)

Local aArea		:= GetArea()
Local aStruct	:= {}
Local aOldPerFer:= {}
Local cX3Campo	:= ""
Local nElem		:= 0
Local nTamGrid	:= 0
Local nExecRot  := 0
Local nPosTipo	:= 0
Local oGrid		:= oModel:GetModel("GPEM030_MSRR")

DEFAULT cAboAnt    := If(GetMvRH("MV_ABOPEC") == "S", "1", "2") //-- Abono antes ferias

If nOperacao == MODEL_OPERATION_UPDATE

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria objeto oSRC e oSRCClone, sendo que este ultimo sera     ³
	³ alimentado pela formula SALINC com os mesmos dados do oSRC.  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !(cPaisLoc $ "BRA|CHI|PAR")
		oSRC	  := GetDetFormula():New( "SRC" ,,, "0 = 1" )
		oSRCClone := GetDetFormula():New( "SRC" ,,, "0 = 1" )
	EndIf

    SetPeriodCalc(cPeriodo)
	SetNumPgCalc(cSemana)

	aOldPerFer := aClone(aPerFerias)

	If ExistBlock("SAL_USUA")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Executar formula para retornar os salarios Incorporados a partir de Formula de Usuario  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nExecRot := EXECBLOCK("SAL_USUA",.F.,.F.)
	ElseIf !( cPaisLoc == "BRA" )
		If cPaisLoc $ "CHI|PAR"
			Salario := SalHora := SalDia := SalMes := 0.00

			fSalInc(@Salario,@SalMes,@SalHora,@Saldia)

		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Executar formula para retornar os salarios Incorporados      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			MsAguarde( {|| nExecRot := ExecForm( SRA->RA_FILIAL, "SALINC", cRot ) }, OemToAnsi(STR0017), OemToAnsi(STR0037) ) //"Aguarde..."###"Calculando Ferias..."
   		EndIf
   	EndIf

	aPerFerias := aOldPerFer

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Transferir dados clonados do oSRC para o objeto oSRCClone    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !(cPaisLoc $ "BRA|CHI|PAR")
		oSRC:aCols := aClone(oSRCClone:aCols)
	EndIf

	dbSelectArea("SX3")
	SX3->(DbSetOrder(1))
	dbSeek("SRH")

	//--Carrega os Valores do cabeçalho para a memoria 	SRH
	While ! Eof() .and. (X3_ARQUIVO == "SRH")

		cX3Campo := "SRH->"+X3_CAMPO

	    If !X3USADO(X3_CAMPO)
	    	SX3->( DBSKIP() )
	    	Loop
	    EndIf

	    If !(AllTrim(X3_CAMPO)+"|" $ "RH_FILIAL|RH_MAT|RH_NOME|")
			If ValType(&cX3Campo) = "C"
				oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,Space(Len(&cX3Campo)))
			ElseIf ValType(&cX3Campo) = "N"
				oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,0)
			ElseIf ValType(&cX3Campo) = "D"
				oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,CtoD(""))
			ElseIf ValType(&cX3Campo) = "L"
				oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,.F.)
			EndIf
		EndIf

		If X3_CAMPO = "RH_SALMES "
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,SalMes)
		ElseIf X3_CAMPO = "RH_SALDIA "
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,SalDia)
		ElseIf X3_CAMPO = "RH_ROTEIR "
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,cRot)
		ElseIf X3_CAMPO = "RH_PERIODO"
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,cPeriodo)
   			cPeriAnt := cPeriodo
		ElseIf X3_CAMPO = "RH_PROCES"
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,cProcesso)
		ElseIf X3_CAMPO = "RH_NPAGTO "
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,cSemana)
			cNPagAnt := cSemana
		ElseIf X3_CAMPO = "RH_SALHRS "
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,SalHora)
		ElseIf X3_CAMPO = "RH_DATABAS"
			If !Empty(dIVenPen)
				oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,dIVenPen)
			Else
				oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,dDtBasFer)
			EndIf
		ElseIf X3_CAMPO = "RH_DBASEAT"

			If !Empty(dFVenPen)
				DTBASATE := dFVenPen              //--Final Periodo Aquisitivo
			ElseIf !Empty(dDtBasFim	)
				DTBASATE := dDtBasFim             //--Final Periodo Aquisitivo
			ElseIf nPosFer > 0
				DTBASATE := aPerFerias[nPosFer][2]//--Final Periodo Aquisitivo
			EndIf
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,DTBASATE)
		ElseIf (X3_CAMPO) == "RH_DFERVEN"



			n2Dferven := If(!Empty(dFVenPen),nDVenPen,n2Dferven)  // - Ajusta os dias de ferias vencidas quando existirem dias pendentes do periodo

			dbSelectArea("SX3")
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,n2Dferven)

			If cPaisLoc == "PER"
				nValAux := 0
				dPerCad := CtoD( Substr( DtoS(dRch_DtFim) ,7,2) + "/" + Substr( DtoS(dRch_DtFim) ,5,2) + "/" + AllTrim(Str( Year(dRch_DtFim) - 2 )) )
				aEval( aPerFerias , { |x| iif( x[1] < dRch_Dtini .and. x[2] >= dPerCad , nValAux += (x[3] - x[14]) , ) } )
				oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,nValAux)
			EndIf

		ElseIf (X3_CAMPO) == "RH_DFERIAS"

			If cPaisLoc $ "ANG*VEN*COL"
				oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,n2DFerVen)
			ElseIf cPaisLoc == "PER"
				nValAux := 0
			    aEval( aPerFerias , { |x| iif( x[1] < dRch_Dtini .and. x[2] >= dPerCad , nValAux += (x[3] - x[14]) , ) } )
			    oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,nValAux)
			Else
				nDescFal := nFaltas
				TabFaltas(@nDescFal)

				//--Quando as Ferias for a Vencer deve proporcionalizar as Ferias
				If n2DferVen < nDiasAux .And. !lMetadeFal .And. !lTempoParc
					nDescFal := ((nDescFal / 30) * n2DferVen)
				EndIf

				//--A prioridade sera sempre para os dias de vencidas pendentes
		       If nDVenPen > 0 .And. !Empty(dIVenPen)
					If nDiasProg > 0
						If lMetadeFal
							oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,Min((nDVenPen / 2),nDiasProg))
						Else
							oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,Min((nDVenPen - nDescFal),nDiasProg))
						Endif
					Else
						If lMetadeFal
							oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,(nDVenPen / 2))
						Else
							oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,(nDVenPen - nDescFal))
						Endif
					EndIf
					If Type("nDFalt") != "U"
						nDFalt := nDescFal
					EndIf

				Else
					If nDiasProg > 0
						If ( oModel:GetValue("GPEM030_MSRH","RH_DFERVEN") - nDescFal ) > 0
							If Empty(oModel:GetValue("GPEM030_MSRH","RH_DATAINI")) .and. oModel:GetValue("GPEM030_MSRH","RH_DFERVEN") < nDiasProg
								oModel:SetValue("GPEM030_MSRH","RH_DATAINI",dDtIniProg) //Atualiza data de inicio para ajustar dias de férias vencidas
							EndIf
							If nDAbProg > 0
								If !lMetadefal
									nDiasProg := nDiasProg - ( ( nDescFal / oModel:GetValue("GPEM030_MSRH","RH_DFERVEN") ) * nDiasProg )
									nDAbProg  := nDAbProg - ( ( nDescFal / oModel:GetValue("GPEM030_MSRH","RH_DFERVEN") ) * nDAbProg )
								Else
									nDiasProg := nDiasProg / 2
									nDAbProg  := nDAbProg / 2
								EndIf
							Else
								nDiasProg := Min(nDiasProg, If(!lMetadefal, oModel:GetValue("GPEM030_MSRH","RH_DFERVEN") - nDescFal, oModel:GetValue("GPEM030_MSRH","RH_DFERVEN") / 2) )
							EndIf
							If nDiasProg + nDAntPer <= aTabFer[3] - nDescFal //Se programação de férias mais dias antecipados for maior que a quantidade de dias de direito, não carrega o campo.
								oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,Max(nDiasProg,0))
							Else
								oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,aTabFer[3] - nDescFal - nDAntPer )
							EndIf
						EndIf
					ElseIf nDAntPer > 0 .And. If(cPaisLoc == "ARG", dDtBasFer <= aPerFerias[nPosFer][1], dDtBasFer == aPerFerias[nPosFer][1])
						oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,Max(oModel:GetValue("GPEM030_MSRH","RH_DFERVEN") - nDescFal - nDAntPer,0))
					Else
						If !lMetadefal
							oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,Max(oModel:GetValue("GPEM030_MSRH","RH_DFERVEN") - nDescFal,0))
						Else
							oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,Max(oModel:GetValue("GPEM030_MSRH","RH_DFERVEN") / 2 ,0))
						Endif
					EndIf
				EndIf
			EndIf
			nBkpDFer := oModel:GetValue("GPEM030_MSRH","RH_DFERIAS")
		ElseIf cPaisLoc == "PER" .And. (X3_CAMPO) ==  "RH_DFERPRO"

			nValAux := 0
			aEval( aPerFerias , { |x| nValAux += x[4] } )
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,nValAux)

		ElseIf cPaisLoc == "PER" .And. (X3_CAMPO) ==  "RH_DBONIFI"

			dPerCad  := CtoD( Substr( DtoS(dRch_DtFim) ,7,2) + "/" + Substr( DtoS(dRch_DtFim) ,5,2) + "/" + AllTrim(Str( Year(dRch_DtFim) - 2 )) )

		    nValAux := 0
		    aEval( aPerFerias , { |x| iif( dPerCad >= x[2] , nValAux += x[3] - x[14] , ) } )
		    oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,nValAux)

		ElseIf cPaisLoc == "VEN" .And. (X3_CAMPO) == "RH_DBONIFI"
	 		If !Empty(nDBonVen)
		 		oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,nDBonVen)
		 	Else
		 		oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,nDBonAve)
		 	EndIf
		ElseIf AllTrim((X3_CAMPO)) = "RH_NOME"
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,SRA->RA_NOME)
		ElseIf (X3_CAMPO) = "RH_MAT    "
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,SRA->RA_MAT)
		ElseIf (X3_CAMPO) = "RH_DFALTAS"
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,nFaltas)
		ElseIf cPaisLoc == "VEN" .And. X3_CAMPO == "RH_DFALBON"
			nFalBon := aPerFerias[nPosFer][21] + aPerFerias[nPosFer][22]
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,nFalBon)
		ElseIf (X3_CAMPO) = "RH_MEDATU"
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO, AllTrim( StrTran( SX3->X3_RELACAO, '"', "" ) ))
		ElseIf (X3_CAMPO) = "RH_OBSERVA" .and. nFaltas > 32
			// Caso o Funcionário possua quantidade de FALTAS ACIMA DE 32 DIAS, DEVE-SE GERAR A OBSERVACAO CORRESPONDENTE.
			oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,STR0073)
		ElseIf cPaisLoc == "VEN" .And. (X3_CAMPO) = "RH_VACBON"
			nPosTipo := GdFieldPos("RH_VACBON", aSrhHeader)
			If nPosTipo > 0
				oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,aSrhHeader[nPosTipo][12]	)
			EndIf
		Else
			If (!Empty(SX3->X3_RELACAO))
				oModel:LoadValue("GPEM030_MSRH",X3_CAMPO,&(SX3->X3_RELACAO))
			Endif
		EndIf

		dbSkip()
	EndDo

	If !Empty(dDtIniProg) .AND. nFaltas < 32 //Se existir programcao de ferias e número de faltas for inferior a 32
		If nDiasProg > 0 .and. nDiasProg + nDAntPer <= aTabFer[3] - nFaltas
			oModel:LoadValue("GPEM030_MSRH","RH_DFERIAS",nDiasProg)
		EndIf
		If nDAbProg > 0
			oModel:LoadValue("GPEM030_MSRH","RH_DABONPE",nDAbProg)
		EndIf
		oModel:SetValue("GPEM030_MSRH","RH_DATAINI",dDtIniProg)
		If nPercProg > 0
			oModel:LoadValue("GPEM030_MSRH","RH_PERC13S",nPercProg)
			M->RH_PERC13S := nPercProg
		EndIf
		oModel:LoadValue("GPEM030_MSRH","RH_ABOPEC",cAboAnt)
	EndIf
EndIf

	nTamGrid := oGrid:Length()

	DbSelectArea("SX3")
	SX3->(DbSetOrder(1))
	dbSeek("SRR")

	//--Carrega os Valores do cabeçalho para a memoria 	SRH
	While ! Eof() .and. (X3_ARQUIVO == "SRR")
	    If ( X3USADO(X3_CAMPO) .or. AllTrim(X3_CAMPO) == "RR_FILIAL" )
	    	aAdd(aStruct,{X3_CAMPO,If(Empty(X3_RELACAO),Nil,InitPad( X3_RELACAO ))})
	    	nElem := Len(aStruct)

	    	If aStruct[nElem,2] == Nil
	    		cX3Campo := "SRR->"+X3_CAMPO
	    		If X3_CONTEXT == "V"
	    			aStruct[nElem,2] := ""
				ElseIf ValType(&cX3Campo) == "C"
					aStruct[nElem,2] := Space(Len(&cX3Campo))
				ElseIf ValType(&cX3Campo) == "N"
					aStruct[nElem,2] := 0
				ElseIf ValType(&cX3Campo) == "D"
					aStruct[nElem,2] := CtoD("")
				ElseIf ValType(&cX3Campo) == "L"
					aStruct[nElem,2] := .F.
				EndIf
	    	EndIf
	    EndIf
	    DbSkip()
	EndDo

oGrid:GoLine(1)

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³m030VldCalc ºAutor  ³Leandro Drumond   º Data ³  17/09/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida calculo		                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function m030VldCalc(oModel)
Local aArea 	:= GetArea()
Local lUltSemana
Local nLicRem
Local nOperacao := oModel:GetOperation()
Local oGrid 	:= oModel:GetModel( 'GPEM030_MSRH' )
Local lFeriado	:= .F.
Local nQtdFer		:= 0
Local nQtdDias		:= 0
Local nFalAux		:= 0
Local nTCodFol      := Len(aCodFol)
Local lMaior14		:= .F.
Local lDiaDom		:= .F.
Local lDiaSab		:= .F.
Local lAntFer		:= .F.
Local lDSR			:= .F.
Local leSocSimpl	:= (GetMvRH( "MV_VLESOC", Nil, "" ) >= "S_01_00_00")
Local lMsg			:= .F.
Local lTemPd        := !Empty(aCodFol[236,1]) .and. !Empty(aCodFol[237,1]) .and. !Empty(aCodFol[396,1]) .and. !Empty(aCodFol[397,1])
Local lTemPdESoc	:= ( leSocSimpl .And. nTCodFol >= 1870 .And. ( Empty(aCodFol[1870,1]) .Or. Empty(aCodFol[1871,1]) .Or. Empty(aCodFol[1872,1]) ) )
Local lTemPd1891	:= nTCodFol >= 1891 .And. !Empty(aCodFol[1891,1])
Local lTemPd1892	:= nTCodFol >= 1892 .And. !Empty(aCodFol[1892,1])
Local lPdPIS1969	:= (leSocSimpl .And. nTCodFol >= 1969 .And. !Empty(aCodFol[1969, 1]))
Local lPdPIS1970	:= (leSocSimpl .And. nTCodFol >= 1970 .And. !Empty(aCodFol[1970, 1]))
Local lOkFer		:= .T.
Local dDSR			:= CtoD("//")
Local dFer			:= CtoD("//")

DEFAULT lRefTrab		:= FindFunction("fRefTrab") .And. fRefTrab("F")

If nOperacao == MODEL_OPERATION_UPDATE

	If !( cPaisLoc $ 'ANG|PTG' )
		If Empty(M->RH_DATAINI) .Or. Empty(M->RH_DATAFIM)
			Help(" ","1","GPEM30DATA")
			Return(.F.)
		EndIf
	EndIf

	If !(fVerDFer())
		Return(.F.)
	EndIf

	If !( cPaisLoc $ 'ANG|PTG' )
		nLicRem := oGrid:GetValue("RH_DIALREM") + oGrid:GetValue("RH_DIALRE1")
		If M->RH_DFERIAS > 0 .and. !( (M->RH_DATAFIM - M->RH_DATAINI) + 1 - nLicRem == ROUND(M->RH_DFERIAS,2))
			If !(M->RH_DFERIAS > ROUND(M->RH_DFERIAS,0) .and. (M->RH_DATAFIM - M->RH_DATAINI) == ROUND(M->RH_DFERIAS - nLicRem,2))
				Help(,,STR0088,, STR0085 ,1,0 )	//"Fim das férias não corresponde a quantidade de dias de férias."
				Return(.F.)
			EndIf
		EndIf
	EndIf

	If cPaisLoc == "BRA"
		//Verifica se o dia de inicio das férias sera em um feriado, sabado ou domingo.
		lFeriado 	:= !Empty(dFer := fVldDSR(SRA->RA_FILIAL, SRA->RA_MAT, M->RH_DATAINI, 0, "F")) //Feriado
		lDiaDom 	:= If( Alltrim(DiaSemana( M->RH_DATAINI )) == "Domingo", .T., .F.)	//Domingo
		lDiaSab 	:= If( Alltrim(DiaSemana( M->RH_DATAINI )) == "Sabado"	, .T., .F.)	//Sabado

		If lRefTrab
			lAntFer	:= !Empty(dFer := fVldDSR(SRA->RA_FILIAL, SRA->RA_MAT, M->RH_DATAINI, 2, "F")) //verifica se antecede feriado em menos de 2 dias
			dDSR	:= fVldDSR(SRA->RA_FILIAL, SRA->RA_MAT, M->RH_DATAINI, 2, "D")
			lDSR	:= !Empty(dDSR)//verifica se antecede DSR em menos de 2 dias
			nFalAux := M->RH_DFALTAS
			TabFaltas(@nFalAux)

			If (SRF->RF_DIASDIR - nDAntPer - M->RH_DFERIAS - M->RH_DABONPE - nFalAux ) < 5 .And. (SRF->RF_DIASDIR - nDAntPer - M->RH_DFERIAS - M->RH_DABONPE - nFalAux) > 0
				Help(,,STR0034 ,,STR0135 + STR0117 ,1,0 ) //"O saldo de férias que restará é inferior a 5 dias. Conforme Artigo 134 parágrafo 1º da CLT, as férias não devem ser concedidas com menos de 5 dias de gozo."
				Return(.F.)
			EndIf

			If M->RH_DFERIAS + oGrid:GetValue("RH_DIALREM") + oGrid:GetValue("RH_DIALRE1") < 5 .and. !lTerFerMP
				Help(,,STR0034,,STR0117 ,1,0 ) //"Conforme Artigo 134 parágrafo 1º da CLT, as férias não devem ser concedidas com menos de 5 dias de gozo."
				Return(.F.)
			EndIf

			If M->RH_DFERIAS < 14
				SRH->(DbSetOrder(1))
				If SRH->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + DtoS(M->RH_DATABAS)))
					While SRH->(RH_FILIAL + RH_MAT + DtoS(RH_DATABAS) == SRA->RA_FILIAL + SRA->RA_MAT + DtoS(M->RH_DATABAS))
						nQtdFer++
						nQtdDias += SRH->RH_DFERIAS + SRH->RH_DABONPE
						If SRH->RH_DFERIAS >= 14
							lMaior14 := .T.
						EndIf
						SRH->(DbSkip())
					EndDo
				EndIf
				If !lMaior14 .And. nDVenPen == 0 //Quando for quitacao de saldo a quantidade pode ser menor
					If nQtdFer == 2
						Help(,,STR0034,,STR0118 ,1,0 ) //"Conforme Artigo 134 parágrafo 1º da CLT, ao menos uma férias por período aquisitivo deve ter no mínimo 14 dias. Já foram efetuados dois cálculos com menos de 14 dias para este periodo aquisitivo."
						Return(.F.)
					ElseIf !( Round((aTabFer[1] * aTabFer[4] - nDescFal), 2) == ( nQtdDias + M->RH_DFERIAS + M->RH_DABONPE )) //Se estiver quitando o período não efetua validação
						If ( ( aTabFer[1] * aTabFer[4] - nDescFal ) - ( nQtdDias + M->RH_DFERIAS + M->RH_DABONPE ) ) < 14
							Help(,,STR0034,,STR0119 ,1,0 ) //"Conforme Artigo 134 parágrafo 1º da CLT, ao menos uma férias por período aquisitivo deve ter no mínimo 14 dias. A configuraçao atual das férias não permitirá que esta premissa seja cumprida."
							Return(.F.)
						EndIf
					EndIf
				EndIf
				RestArea(aArea)
			EndIf

			If nQtdSRH == 2 .And. (SRF->RF_DIASDIR - nDAntPer - M->RH_DFERIAS - M->RH_DABONPE - nFalAux) > 0
				Help(,,STR0034,,STR0170 ,1,0 )//"Conforme Artigo 134 parágrafo 1º da CLT, as férias devem ser concedidas em até 3 (três) períodos."
				Return(.F.)
			EndIf

		EndIf

		SRH->(DbSetOrder(1))

		If SRH->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + DtoS(M->RH_DATABAS)))
			While SRH->(RH_FILIAL + RH_MAT + DtoS(RH_DATABAS) == SRA->RA_FILIAL + SRA->RA_MAT + DtoS(M->RH_DATABAS))
                If ((M->RH_DATAINI >= SRH->RH_DATAINI .AND. M->RH_DATAINI <= SRH->RH_DATAFIM) .OR. (M->RH_DATAFIM >= SRH->RH_DATAINI .AND. M->RH_DATAFIM <= SRH->RH_DATAFIM)) // Verifica se os dias de férias selecionados para calculo não estão compreendidos dentro de outro periodo calculado
                    Help( ,, OemToAnsi(STR0088),, STR0147, 1, 0 ) //"Atenção"##"Os dias de férias coincidem com férias já calculadas, reveja o período de cálculo informado."
                    Return .F.
                EndIf
                IF ((SRH->RH_DATAINI >= M->RH_DATAINI .AND. SRH->RH_DATAINI <= M->RH_DATAFIM) .OR. (SRH->RH_DATAFIM >= M->RH_DATAINI .AND. SRH->RH_DATAFIM <= M->RH_DATAFIM)) // Verifica se os dias de férias calculados não estão compreendidos dentro do periodo selecionado, para contemplar outros cenários de calculo
                    Help( ,, OemToAnsi(STR0088),, STR0147, 1, 0 ) //"Atenção"##"Os dias de férias coincidem com férias já calculadas, reveja o período de cálculo informado."
                    Return .F.
                EndIf

			    SRH->(DbSkip())
			EndDo
        EndIf

		If !lTemPd //Se não existir as verbas de período anterior, verifica se houve pagamento de férias no mesmo Ano/Mes da atual
			If SRH->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT))
				While SRH->(RH_FILIAL + RH_MAT == SRA->RA_FILIAL + SRA->RA_MAT)
					If AnoMes(M->RH_DTRECIB) == AnoMes(SRH->RH_DTRECIB)
						Help( ,, OemToAnsi(STR0088),, STR0169, 1, 0 ) //"Atenção"##"Os identificadores de cálculo 0236, 0237, 0396 e 0397 são obrigatórios quando existe duas férias com pagamento no mesmo mês."
						Return .F.
					EndIf
					SRH->(DbSkip())
				EndDo
			EndIf		
		EndIf

		If lTemPdESoc 
			If !IsBlind()
				fMsg1870()
			EndIf
			Help( ,, OemToAnsi(STR0088),, STR0172, 1, 0 ) //"Atenção"##"É obrigatório possuir verbas vinculadas aos IDs 1870, 1871 e 1872 devido exigência do eSocial"
			Return .F.
		EndIf

		If leSocSimpl
			If !lTemPd1891 .And. fVlIdsFer(.F., "91")
				If !IsBlind()
					fMsg1891()
				EndIf
				If dDatabase > cToD("15/08/2022")
					Help( ,, OemToAnsi(STR0088),, STR0191, 1, 0 ) //"Atenção"##"É obrigatório possuir verba vinculada ao ID 1891 devido exigência do eSocial"
					Return .F.			
				EndIf
			EndIf
			If !lTemPd1892 .And. fVlIdsFer(.F., "95")
				If !IsBlind()
					fMsg1892()
				EndIf
				If dDatabase > cToD("15/08/2022")
					Help( ,, OemToAnsi(STR0088),, STR0192, 1, 0 ) //"Atenção"##"É obrigatório possuir verba vinculada ao ID 1892 devido exigência do eSocial"
					Return .F.
				EndIf
			EndIf
			//Obriga a ter os Ids 1969 e 1970 caso exista verba com incidência no PIS para o eSocial, pois o PIS não é obrigatório para todas as empresas
			If !lPdPIS1969 .And. fVlIdsFer(.T., "11")
				If !IsBlind()
					fMsgPIS(.T.)
				EndIf
				Help( ,, OemToAnsi(STR0088),, STR0219, 1, 0) //"Atenção"##"É obrigatório possuir verba vinculada ao ID 1969 devido exigência do eSocial.
				Return .F.
			EndIf
			If !lPdPIS1970 .And. fVlIdsFer(.T., "91")
				If !IsBlind()
					fMsgPIS(.F.)
				EndIf
				Help( ,, OemToAnsi(STR0088),, STR0220, 1, 0) //"Atenção"##"É obrigatório possuir verba vinculada ao ID 1970 devido exigência do eSocial.
				Return .F.
			EndIf
		EndIf

		If !lWorkFlow .And. !(IsBlind())
			If !lRefTrab .And. lFeriado
				lMsg:=(MsgYesNo(OemToAnsi(STR0102)+ OemToAnsi(STR0105),OemToAnsi(STR0034))) //"Aviso"# "As ferias do funcionario irao iniciar em um Feriado." # OK
				If !lMsg
					Help(,,STR0034,,STR0102 ,1,0 )		//"Aviso"# "As ferias do funcionario irao iniciar em um Feriado." # OK
					Return(.F.)
				Endif
			Endif

			If lDiaSab .And. !lDSR .And. !lFeriado
				lMsg:=(MsgYesNo(OemToAnsi(STR0103)+ OemToAnsi(STR0105),OemToAnsi(STR0034))) //"Aviso"# "As ferias do funcionario irao iniciar em um sábado." # OK
				If !lMsg
					Help(,,STR0034,,STR0103 ,1,0 )		//"Aviso"# "As ferias do funcionario irao iniciar em um sabado." # OK
					Return(.F.)
				Endif
			Endif

			If lDiaDom .And. !lDSR .And. !lFeriado
				lMsg:=(MsgYesNo(OemToAnsi(STR0104)+ OemToAnsi(STR0105),OemToAnsi(STR0034))) //"Aviso"# "As ferias do funcionario irao iniciar em um domingo." # OK
				If !lMsg
					Help(,,STR0034,,STR0104 ,1,0 )		//"Aviso"# "As ferias do funcionario irao iniciar em um domingo." # OK
					Return(.F.)
				Endif
			Endif
			If lAntFer
				lMsg:=(MsgYesNo(OemToAnsi(STR0125) + CRLF + oemToAnsi(STR0120) + "(" + dToC(M->RH_DATAINI) + "). " + OemToAnsi(STR0121) + "(" + dToC(dFer) +"). " + CRLF + OemToAnsi(STR0126),OemToAnsi(STR0034)))
				If !lMsg
					Help(,,STR0034,,OemToAnsi(STR0125) + CRLF + oemToAnsi(STR0120) + "(" + dToC(M->RH_DATAINI) + "). " + OemToAnsi(STR0121) + "(" + dToC(dFer) +"). " ,1,0 )
					Return(.F.)
				Endif
				//"Aviso"##"Conforme Artigo 134 parágrafo 3º da CLT, é vedado o início das férias no período de dois dias que antecede feriado ou DSR."##"Data inicial do período de gozo: "##Feriado
			Endif

			If lDSR
				lMsg:=(MsgYesNo(OemToAnsi(STR0125) + CRLF + oemToAnsi(STR0120) + "(" + dToC(M->RH_DATAINI) + "). " + OemToAnsi(STR0122) + "(" + dToC(dDSR) +"). " + CRLF + OemToAnsi(STR0126),OemToAnsi(STR0034)))
				If !lMsg
					Help(,,STR0034,,OemToAnsi(STR0125) + CRLF + oemToAnsi(STR0120) + "(" + dToC(M->RH_DATAINI) + "). " + OemToAnsi(STR0122) + "(" + dToC(dDSR) +"). " ,1,0 )
					Return(.F.)
				Endif
				//"Aviso"# "A data inicial do periodo de gozo (//) deve anteceder em 2 dias ao DSR (//)# OK
			Endif
		EndIf

        GpIniTab()
	Endif

	cPeriodo 	:= oGrid:GetValue("RH_PERIODO")
	cSemana  	:= oGrid:GetValue("RH_NPAGTO")
	cProcesso 	:= SRA->RA_PROCES
	cRot 		:= oGrid:GetValue("RH_ROTEIR")

	aPeriodo := {}

	//Carrega dados do periodo de acordo com a data inicial de ferias informada no cabecalho.
	fCarPeriodo( cPeriodo , cRot , @aPeriodo, @lUltSemana, @nPosSem)

	If ( Len(aPeriodo) > 0 )

	    dDataDe 	:= aPeriodo[nPosSem,3]
	    dDataAte 	:= aPeriodo[nPosSem,4]
	    NSVNORMAL 	:= NORMAL 	:= aPeriodo[nPosSem,14]
	    NSVDESCAN 	:= DESCANSO	:= aPeriodo[nPosSem,13]
	    cAnoMes  	:= aPeriodo[nPosSem,15] + aPeriodo[nPosSem,16]
	    dData_Pgto 	:= aPeriodo[nPosSem,17]
	    nDiasC 		:= aPeriodo[nPosSem,20]
	    dDataRef 	:= CtoD("01/" + aPeriodo[nPosSem,16] + "/" + aPeriodo[nPosSem,15])
	Else
		Help(,,STR0088,, STR0077 ,1,0 )  //"A configuração dos períodos esta incorreta ou não existe período válido para o roteiro de férias. Verifique o cadastro de períodos."
		Return(.F.)
	EndIf

	If !fChkDtFer( M->RH_DATAINI )
		Return(.F.)
	EndIf

	If !FVerDAbon(oModel)
		Return(.F.)
	EndIf

	//?- Verifica se o calculo esta Liberado
	If !fVldAccess( cFilAnt, oGrid:GetValue("RH_DATAINI"), cSemana, .T., cRot )
	   Return( .F. )
	EndIf

	If fVldMsgMed()
		MsgInfo(OemToAnsi(STR0101) + fPerFech(cProcesso, "FOL", SRA->RA_FILIAL) + ".")
	EndIf

	// Ponto de Entrada para usuario definir se deve ou nao calcular ferias, deve retornar .T. ou .F.
	If ExistBlock("GPM030CO")
		lOkFer := Execblock("GPM030CO",.F.,.F.)
		Return(lOkFer)
	Endif
EndIf

If nOperacao == MODEL_OPERATION_DELETE
	//?- Verifica se o calculo esta Liberado
	If !fVldAccess( cFilAnt, SRH->RH_DATAINI, SRH->RH_NPAGTO, .T., cRot )
	   Return( .F. )
	EndIf
EndIf

RestArea(aArea)

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³m030IniCalc ºAutor  ³Leandro Drumond   º Data ³  17/09/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inicia calculo		                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function m030IniCalc(oModel)

Local aArea		:= GetArea()
Local nOperacao := oModel:GetOperation()
Local cMesAnoAux:= ""
Local lRet		:= .T.
Local cSitFol	:= ""
Local dFimAux   := oModel:GetModel("GPEM030_MSRH"):GetValue("RH_DATAFIM")

DEFAULT lIntegDef 	:= FindFunction("GETROTINTEG") .And. FindFunction("FWHASEAI")
DEFAULT lTemPostUmT := SRH->( ColumnPos( "RH_POSTUMT" ) ) > 0

If nOperacao == MODEL_OPERATION_UPDATE
	Begin Transaction
	FWFormCommit( oModel, {|| .T.} ) //Grava novo registro

	If !(cPaisLoc $ "PTG|VEN") .Or. ;
	    (cPaisLoc == "VEN" .And. oModel:GetModel("GPEM030_MSRH"):GetValue("RH_VACBON") <> "2")
		//-- Grava os afastamentos de ferias e licenca remunerada no SR8
		if !(lRet:= fGFerSR8(oModel:GetModel("GPEM030_MSRH"):GetValue("RH_DATAINI"), oModel:GetModel("GPEM030_MSRH"):GetValue("RH_DATAFIM")))
			DisarmTransaction()
			Break
		EndIf
	EndIf

	If lRet .And. ((cPaisLoc <> "VEN") .Or. (cPaisLoc == "VEN" .And. oModel:GetModel("GPEM030_MSRH"):GetValue("RH_VACBON") <> "2"))
		fGetLastPer( , , SRA->RA_PROCES, fGetRotOrdinar() , .T., .F., @cMesAnoAux )

		SRH->(DbSetOrder(1))
		SRH->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+Dtos(M->RH_DATABAS)))

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Monta Array com  os dados para envio de e-mail              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		fMontaMail("015")

		If AnoMes(oModel:GetModel("GPEM030_MSRH"):GetValue("RH_DATAINI")) == cMesAnoAux
			cSitFol	:= SRA->RA_SITFOLH
			RetSituacao()
			If lIntNGRJP .And. cSitFol <> SRA->RA_SITFOLH
				fSendSRAApi("A")
			EndIf
		EndIf
	EndIf

	If cPaisLoc == "BRA"
		Gp030Estab(.T.,dFimAux)
	EndIf

	End Transaction

    If lTemPostUmT .And. !Empty(aPdUmTSRK)
        fGrvL14457( aPdUmTSRK, oModel:GetModel("GPEM030_MSRH"):GetValue("RH_DATAINI") )
        If !IsBlind()
            fMsgL14457(2)
            Aviso(STR0034, STR0209, {"OK"})//"Aviso"##"Empregado(a) com postergação do pagamento do 1/3 (um terço) conforme Lei 14.457/2022. Verba(s) gravadas em valores futuros (tabela SRK) com data de pagamento em 20/12. Caso deseje antecipar o pagamento em outra data, deve-se efetuar a alteração manual da data de pagamento em Lançamentos Futuros."
        EndIf
    EndIf

	If lIntegDef
		lExcFerPIMS := .F.
		SetRotInteg("GPEM040")
		FwIntegDef("GPEM040")
	EndIf
	If ExistBlock("GP030FER")
		ExecBlock("GP030FER",.F.,.F.)
	Endif
ElseIf nOperacao == MODEL_OPERATION_DELETE
	DbSelectArea("SRH")
	lRet := Fm030Can(Recno())

	fDelHist(.T.) //deleta historico de medias
	fDelRU6(.T.) //Deleta deduções dos dependentes
EndIf

RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CalcFer   ºAutor  ³Leandro Drumond     º Data ³  25/09/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Rotina de Calculo de Ferias                                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function CalcFer(oModel)

Local aTitleLog		:= {}
Local aLog			:= {}
Local aArea			:= GetArea()
Local cPostUmT      := "1"
Local nX
Local nCount

Local oGrid			:= Nil
Local lSeqMv        := SRR->(ColumnPos("RR_SEQMV")) > 0
Local lLogProc 		:= !IsBlind() .and. SuperGetMV("MV_LOGPROC",,.F.) 
Local aCposSRV 		:= {'RV_INSS','RV_FGTS','RV_IR','RV_INCORP'}

DEFAULT oModel      := FWModelActive()
DEFAULT lItemClVl   := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3" // Define se trabalha com item e classe contabil
DEFAULT lTribIR     := SRR->( ColumnPos( 'RR_TRIBIR' ) ) > 0
DEFAULT lTemPostUmT := SRH->( ColumnPos( "RH_POSTUMT" ) ) > 0

oGrid := oModel:GetModel( 'GPEM030_MSRR' )

Private aConvencao		:= {}

SRV->(DbSetOrder(1))

Begin Sequence

    aPD  := {}
    aPDV := {}
    If lTemPostUmT
        aPDUmT      := {}
        aPdUmTSRK   := {}
    EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Criar o objeto oSrr que sera utilizado na formula          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !cPaisLoc $ "BRA|CHI|PAR"
		oSrr := Nil
		GetSRR( @oSrr, "1 = 0" )	// Expressao de filtro para criar um objeto em branco
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Transferir o aCols para o Objeto oSrr 					 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		TrfColsObj( @aCols )
	EndIf

    If lTemPostUmT .And. fVldL14457( oModel:GetValue("GPEM030_MSRH", "RH_DATAINI"), oModel:GetValue("GPEM030_MSRH", "RH_DFERIAS"), oModel:GetValue("GPEM030_MSRH", "RH_DABONPE"), oModel:GetValue("GPEM030_MSRH", "RH_DFERVEN"), oModel:GetValue("GPEM030_MSRH", "RH_DATABAS") )
        If !IsBlind()
            fMsgL14457(1)
            cPostUmT := Iif( MsgYesNo( OemToAnsi(STR0208), OemToAnsi(STR0088) ), "3", "2" )//"Deseja postergar o pagamento do 1/3 (um terço) para 20/12 conforme Lei 14.457/2022?"###"Atenção."
        Else
            cPostUmT := "3"
        EndIf

        oModel:LoadValue("GPEM030_MSRH", "RH_POSTUMT", cPostUmT)
        M->RH_POSTUMT := cPostUmT
    EndIf

	M->RH_ABOPEC 	:= oModel:GetValue("GPEM030_MSRH","RH_ABOPEC")
	cRot			:= M->RH_ROTEIR
	cPeriodo		:= M->RH_PERIODO
	cNumPag			:= M->RH_NPAGTO

	cSvSetRot 		:= SetRotExec( cRot )
	cSvSetPer 		:= SetPeriodCalc( cPeriodo )
	cSvSetNumPago 	:= SetNumPgCalc( cNumPag )

    /*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Variavel que define se considera o Mes para media por 	 ³
	³ sindicato.												 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF !(cPaisLoc $ "ANG|PTG")
		lMesAtu := ( M->RH_MEDATU == "S" )
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Soma as verbas de provento                                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nValProv := 0.00
	nValDesc := 0.00

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Limpa Arquivo par Calcular Medias						     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	DbSelectArea(cTBLXMED)
	Zap

	If SRA->RA_TPCONTR != "3" .And. !(SRA->RA_CATEFD $ '107/108')
		// Executa as formulas roteiro

		//Memória de Cálculo
		If __lMemCalc
			fSetMemCalc()
		EndIf

		nRet := ExecRot( SRA->RA_FILIAL , cRot )

		If __lMemCalc
			fAddMemLog("",2) //grava parametros na memoria de calculo
			fGrvLogFun(cRot, cPeriodo, cNumPag,"GPEM030", aMenLog)
			aMenLog := {}
		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Fecha o Repositorio Auxiliar                                 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		RpoFormInit( NIL , .T. )

		If nRet < 0 .or. nRet == 2 //Retorna 2 quando calcculo eh abortado
			cFilCalc	:= ""
			lErrExecRot	:= .T.

			// Carregando Informacoes para o Log
			aLogInit := LogExecRot()
			For nX := 1 To Len( aLogInit )
				If !Empty(aLogInit[ nX, 2 ])
					If nX == 1
						aAdd( aTitleLog, STR0052 ) //"Erro de Carga de Mnemonicos"
					ElseIf nX == 2
						aAdd( aTitleLog, STR0054 ) //"Erro de Carga de Formulas"
					ElseIf nX == 3
					aAdd( aTitleLog, STR0055 ) //"Ocorreu erro na compilacao ou Execucao do Roteiro"
					ElseIf nX == 4
						aAdd( aTitleLog, STR0056 ) //"Erros ocasionados durante o Calculo da Ferias"
					EndIf
					aAdd( aLog, aLogInit[nX, 2] )
				EndIf
			Next nX

			If Len( aLogErros ) > 0
				If Empty( aLog )
					aAdd( aTitleLog, STR0053 )	// "Log de Ocorrencias do Calculo de Ferias"
					aAdd( aLog, {} )
				EndIf

				nPosLog := Len( aLog )
				For nX := 1 To Len( aLogErros )
					aAdd( aLog[ nPosLog ], aLogErros[ nX ] )
				Next nX
			EndIf

			If !Empty( aLog )
				// Mostrar o Log
				MsAguarde( { || fMakeLog( aLog , aTitleLog , "GPEXIDC" , NIL , FunName() , STR0053 ) } ,  STR0053 ) //"Log de Ocorrencias do Calculo de Ferias"
			EndIf
			RstExecCalc()
			aMsgLog := {}
			Return( .F. )
		EndIf
	ElseIf ! IsBlind()
		If SRA->RA_TPCONTR == "3"
			MsgAlert(oemToAnsi(STR0124), OemToAnsi(STR0123)) // "O funcionário possui contrato intermitente. O cálculo das férias não irá gerar valores, pois estes foram pagos na folha de pagamento." # "Contrato intermitente"
		Else
			MsgAlert(oemToAnsi(STR0146), OemToAnsi(STR0145)) // "O funcionário possui contrato verde/amarelo. O cálculo das férias não irá gerar valores, pois estes foram pagos na folha de pagamento." # ""Contrato verde/amarelo"
		EndIf
	EndIf

	SetRotExec( cSvSetRot )
	SetPeriodCalc( cSvSetPer )
	SetNumPgCalc( cSvSetNumPago )

	oModel:LoadValue("GPEM030_MSRH","RH_SALMES",nSalM1)
	oModel:LoadValue("GPEM030_MSRH","RH_SALDIA",nSalD1)
	oModel:LoadValue("GPEM030_MSRH","RH_SALHRS",nSalH1)
	oModel:LoadValue("GPEM030_MSRH","RH_SALDIA1",nSalD2)  // Salario Dia Prox. Mes
	oModel:LoadValue("GPEM030_MSRH","RH_SALHRS1",nSalH2) //  Salario Hora Prox. Mes
	oModel:LoadValue("GPEM030_MSRH","RH_TIPCAL","N")
	oModel:LoadValue("GPEM030_MSRH","RH_SALMIN",Val_SalMin)

	nSalaMed	:= Salario
	nSMesMed 	:= SalMes
	nSDiaMed 	:= SalDia
	nSHorMed	:= SalHora

	If cPaisLoc $ "BRA|CHI|PAR"
		
		nElem := Len(aPd)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ CONTA OS ELEMENTOS VALIDOS PARA MONTAR O NOVO aCols        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nElem1 := 0
		aEval(aPd,{ |X| nElem1 += If( Round(x[5],2) = 0.00 .Or. X[9]=="D" ,0 ,1) })

		If nElem1 > 0

			If cPaisLoc == "BRA" .And. !Empty(SRA->RA_FECREI) .and. SRA->RA_FECREI >= GetMemVar("RH_DBASEAT")
				//"Atenção"##"O funcionário foi reintegrado em data posterior ao fim do período aquisitivo calculado. É necessário conferir se existem descontos que devem ser realizados."
				If (!IsBlind(),	Aviso( STR0088, OemToAnsi(STR0218), { "OK" }, 2), Nil) 
			EndIf 

			aSort( aPD ,,, { |x,y| x[1] + x[11] < y[1] + y[11] } )

			nElem1 := 0

			For nCount = 1 To nElem
				If Round(aPd[nCount,5],2) = 0.00 .Or. aPd[nCount,9] == "D"
					Loop
				EndIf

				nElem1++

				If nElem1 > oGrid:Length()
					oGrid:AddLine(.T.)
				EndIf

				oGrid:GoLine(nElem1)

				oGrid:LoadValue("RR_FILIAL"	,SRA->RA_FILIAL)
				oGrid:LoadValue("RR_MAT"	,SRA->RA_MAT)
				oGrid:LoadValue("RR_PD"		,aPd[nCount,01])
				oGrid:LoadValue("RR_DESCPD"	,DescPd( aPd[nCount,01] ))
				oGrid:LoadValue("RR_VALOR"	,Round(aPd[nCount,05],2))
				oGrid:LoadValue("RR_HORAS"	,aPd[nCount,04])
				oGrid:LoadValue("RR_TIPO1"	,aPd[nCount,06])
				oGrid:LoadValue("RR_TIPO2"	,aPd[nCount,07])
				oGrid:LoadValue("RR_DATA"	,M->RH_DATAINI)
				oGrid:LoadValue("RR_DATAPAG",M->RH_DTRECIB)
				oGrid:LoadValue("RR_CC"		,aPD[nCount,02])
				oGrid:LoadValue("RR_PROCES"	,SRA->RA_PROCES)
				oGrid:LoadValue("RR_PERIODO",cPeriodo)
				oGrid:LoadValue("RR_ROTEIR"	,cRot)
				oGrid:LoadValue("RR_SEMANA"	,cNumPag)
				oGrid:LoadValue("RR_TIPO3"	,"F")
				oGrid:LoadValue("RR_SEQ"	,aPd[nCount,11])
				oGrid:LoadValue("RR_VALORBA",aPd[nCount,20])
				oGrid:LoadValue("RR_CODB1T"	,aPd[nCount,21])
				oGrid:LoadValue("RR_NUMID"	,AllTrim(aPd[nCount,15]))
				if(SRV->(DbSeek(xFilial('SRV') + oGrid:GetValue('RR_PD'))))
					aEval(aCposSRV,{|x|oGrid:LoadValue("RR" + SubStr( x, At('_',x)),SRV->(&(x)))})
				endIf
				If lItemClVl
					oGrid:LoadValue("RR_ITEM"	,SRA->RA_ITEM)
					oGrid:LoadValue("RR_CLVL"	,SRA->RA_CLVL)
				EndIf
				If lSeqMv
					oGrid:LoadValue("RR_SEQMV"	,cSeqMV)
				EndIf
                If lTribIR
                    oGrid:LoadValue("RR_TRIBIR"	, aPd[nCount, 28])
                EndIf
			Next
			oGrid:GoLine(1) //Posiciona na primeira linha
		Else
			nElem1 := 1

			If nElem1 > oGrid:Length()
				oGrid:AddLine(.T.)
			EndIf

			oGrid:GoLine(nElem1)

			oGrid:LoadValue("RR_FILIAL"	,SRA->RA_FILIAL)
			oGrid:LoadValue("RR_MAT"	,SRA->RA_MAT)
			oGrid:LoadValue("RR_PD"		,aCodFol[102,1])
			oGrid:LoadValue("RR_DESCPD"	,DescPd(aCodFol[102,1]))
			oGrid:LoadValue("RR_VALOR"	,0.00)
			oGrid:LoadValue("RR_HORAS"	,0.00)
			oGrid:LoadValue("RR_TIPO1"	,"V")
			oGrid:LoadValue("RR_TIPO2"	,"C")
			oGrid:LoadValue("RR_DATA"	,M->RH_DATAINI)
			oGrid:LoadValue("RR_DATAPAG",M->RH_DTRECIB)
			oGrid:LoadValue("RR_CC"		,SRA->RA_CC)
			oGrid:LoadValue("RR_PROCES"	,SRA->RA_PROCES)
			oGrid:LoadValue("RR_PERIODO",cPeriodo)
			oGrid:LoadValue("RR_ROTEIR"	,cRot)
			oGrid:LoadValue("RR_SEMANA"	,cNumPag)
			oGrid:LoadValue("RR_TIPO3"	,"F")
			oGrid:LoadValue("RR_VALORBA",SalMes)
			oGrid:LoadValue("RR_CODB1T"	,"1")

			if(SRV->(DbSeek(xFilial('SRV') + oGrid:GetValue('RR_PD'))))
				aEval(aCposSRV,{|x|oGrid:LoadValue("RR" + SubStr( x, At('_',x)),SRV->(&(x)))})
			endIf

			If lItemClVl
				oGrid:LoadValue("RR_ITEM"	,SRA->RA_ITEM)
				oGrid:LoadValue("RR_CLVL"	,SRA->RA_CLVL)
			EndIf

		EndIf

	Else
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Conta os Elementos Validos para Montar o Novo aCols.  Descon³
		³sidera Verbas com Valores Zerados cuja verba nao corresponda³
		³a de Liquido de Rescisao Anterior ou que nao seja  Provenien³
		³te do Ponto "E"letronico, "I"nformada ou "G"erada ou que  es³
		³teja "D"eletada em aPd ou que a Semana nao corresponta a se-³
		³mana Digitada												 ³
		³A troca do Tipo2 de " " para I sera feita para que identifi-³
		³car que foi desmarcado pelo usuario.                        ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		fo_GoTop( @oSrr )

		nElem1 := 0

		For nX := 1 To Len( oSrr:aCols )

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Nao foi necessario a inclusao da Condicao de Valor Informado³
			³porque ja foi passado pela execucao do roteiro de calculo.  ³
			³Os valores nao poderao ser zerados apos a execucao calculo  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If !fo_Deleted( @oSrr, nX ) .And.;
			   ( (  fo_GetVal( @oSrr, "RR_VALOR", nX ) == 0.00 .And. !(fo_GetVal( @oSrr, "RR_TIPO2",  nX ) $ "EGI") ) .or.;
			     	fo_GetVal( @oSrr, "RR_VALOR", nX ) > 0.00 .Or. fo_GetVal( @oSrr, "RR_HORAS", nX ) > 0.00 )

				nElem1++

				If nElem1 > oGrid:Length()
					oGrid:AddLine(.T.)
				EndIf

				oGrid:GoLine(nElem1)

				oGrid:LoadValue("RR_FILIAL"	,SRA->RA_FILIAL)
				oGrid:LoadValue("RR_MAT"	,SRA->RA_MAT)
				oGrid:LoadValue("RR_PD"		,fo_GetVal( @oSrr, "RR_PD", nX ))
				oGrid:LoadValue("RR_DESCPD"	,DescPd(fo_GetVal( @oSrr, "RR_PD", nX )))
				oGrid:LoadValue("RR_VALOR"	,Round(fo_GetVal( @oSrr, "RR_VALOR", nX ),2))
				oGrid:LoadValue("RR_HORAS"	,If( fo_GetVal( @oSrr, "RR_TIPO1", nX )=="H", fConvHoras( fo_GetVal( @oSrr, "RR_HORAS", nX ),"1"), fo_GetVal( @oSrr, "RR_HORAS", nX )))
				oGrid:LoadValue("RR_TIPO1"	,fo_GetVal( @oSrr, "RR_TIPO1", nX ))
				oGrid:LoadValue("RR_TIPO2"	,If( fo_GetVal( @oSrr, "RR_TIPO2", nX ) $ " ", "I", If( fo_GetVal( @oSrr, "RR_TIPO2", nX ) $ "C", "R", fo_GetVal( @oSrr, "RR_TIPO2", nX )) ))
				oGrid:LoadValue("RR_DATA"	,M->RH_DATAINI)
				oGrid:LoadValue("RR_DATAPAG",If( Empty( fo_GetVal( @oSrr, "RR_DATAPAG", nX )), M->RH_DTRECIB, fo_GetVal( @oSrr, "RR_DATAPAG", nX )))
				oGrid:LoadValue("RR_CC"		,fo_GetVal( @oSrr, "RR_CC", nX ))
				oGrid:LoadValue("RR_PROCES"	,SRA->RA_PROCES)
				oGrid:LoadValue("RR_PERIODO",cPeriodo)
				oGrid:LoadValue("RR_ROTEIR"	,cRot)
				oGrid:LoadValue("RR_SEMANA"	,cNumPag)
				oGrid:LoadValue("RR_TIPO3"	,"F")
				oGrid:LoadValue("RR_SEQ"	,fo_GetVal( @oSrr, "RR_SEQ", nX ))
				oGrid:LoadValue("RR_VALINFO",fo_GetVal( @oSrr, "RR_VALINFO", nX ))
				oGrid:LoadValue("RR_CODB1T"	,aPd[nCount,21])
				oGrid:LoadValue("RR_NUMID"	,fo_GetVal( @oSrr, "RR_NUMID", nX ))

				if(SRV->(DbSeek(xFilial('SRV') + oGrid:GetValue('RR_PD'))))
					aEval(aCposSRV,{|x|oGrid:LoadValue("RR" + SubStr( x, At('_',x)),SRV->(&(x)))})
				endIf

				If lItemClVl
					oGrid:LoadValue("RR_ITEM"	,SRA->RA_ITEM)
					oGrid:LoadValue("RR_CLVL"	,SRA->RA_CLVL)
				EndIf

			EndIf

		Next nX

		oGrid:GoLine(1) //Posiciona na primeira linha

	EndIf

	If nElem1 > 1 .and. oGrid:Length() > nElem1
		oModel:GetModel( "GPEM030_MSRR" ):SetNoDeleteLine(.F.)//Altera model para permitir excluir as linhas do calculo anterior
		For nX := nElem1+1 to oGrid:Length()
			oGrid:GoLine(nX)
			oGrid:DeleteLine()
		Next nX
		oModel:GetModel( "GPEM030_MSRR" ):SetNoDeleteLine(.T.)//Retorna bloqueio de exclusão de linha
		oGrid:GoLine(1) //Posiciona na primeira linha
	EndIf

	//grava historico de médias
	cIdHistMed := fHistMed(M->RH_DATAINI)

	If cPaisLoc == "ANG" // Tratamento para filtro na consulta padrão RCH
		cRot := ""
	EndIf

    If lTemPostUmT
        aPdUmTSRK  := aClone( aPDUmT )
    EndIf

End Sequence

If !lWorkFlow .And. IsBlind()
	lGrvCalc := .T.
EndIf

RestArea(aArea)

If FindFunction("TecConfAlo") .AND. SuperGetMV("MV_TECXRH", NIL, .F. ) .AND. !IsBlind()
	TecConfAloc( oModel )
EndIf

If lLogProc .and. MsgYesNo(OemToAnsi(STR0202), OemToAnsi(STR0088))//"O parâmetro MV_LOGPROC esta ativo. Deseja consultar os parâmetros utilizados no cálculo? "### Atenção.
	aAdd( aTitleLog, OemToAnsi(STR0203) )	// "Log de Execução do Cálculo de Ferias"
	aAdd(aLog, {""})
	MsAguarde( { || fMakeLog( aLog , aTitleLog , "" , NIL , FunName() , OemToAnsi(STR0203) ) } ,  "Log de Execução do Cálculo de Ferias" ) //"Log de Execução do Cálculo de Ferias"
EndIf 

RstExecCalc() //Restaurar as Static apos o calculo
RstGpexIni()
RestXCIMP()

Return( .T. )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³GravaFer 	³ Autor ³ Equipe Advanced RH  ³ Data ³04/03/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gravar as Ferias calculada                					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GravaFer()													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL 														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³GPEM030   												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function GravaFer( aSRHVirtual, aSRHHeader, aSRRVirtual )

Local lFound
Local nP			:= 0.00
Local nX			:= 0.00
Local nChoice 		:= 0.00
Local nChoices		:= 0.00
Local nLenaCols		:= Len( aCols )
Local nPosPd		:= GdFieldPos("RR_PD", aSrrHeader)
Local nPosCc		:= GdFieldPos("RR_CC", aSrrHeader)
Local nPosData		:= GdFieldPos("RR_DATA", aSrrHeader)
Local nPosTipo1		:= GdFieldPos("RR_TIPO1", aSrrHeader)
Local nPosTipo2		:= GdFieldPos("RR_TIPO2", aSrrHeader)
Local nDataPag		:= GdFieldPos("RR_DATAPAG", aSrrHeader)
Local nPosSeq		:= GdFieldPos("RR_SEQ", aSrrHeader)
Local nPosDelete	:= Len( aSrrHeader ) + 1
Local nLenaColsFer  := Len( aColsFer )

DEFAULT lItemClVl  := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3" // Define se trabalha com item e classe contabil

nChoices			:= Len(	aSRHHeader )

Begin Transaction

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inicio da Gravacao do Cabecalho da Rescisao                  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	DbSelectArea("SRH")
	DbSetOrder( RetOrder( "SRH", "RH_FILIAL+RH_MAT+DTOS(RH_DATABAS)+ DTOS(RH_DATAINI)" ) )
	If ( lFound := SRH->( dbSeek(SRA->RA_FILIAL + SRA->RA_MAT + Dtos(M->RH_DATABAS) + DTOS(M->RH_DATAINI)  ) ) )
		RecLock("SRH",.F.,.T.)
	Else
		RecLock("SRH",.T.,.T.)
	EndIf

	If !lFound

		For nChoice := 1 To nChoices
			If ( aScan( aSRHVirtual , { |cCpo| ( cCpo == aSRHHeader[ nChoice , 02 ] ) } ) == 0.00 )
				SRH->( &( aSRHHeader[ nChoice , 02 ] ) ) := &( "M->"+aSRHHeader[ nChoice , 02 ] )
			EndIf
		Next nChoice
		nPosFer	:= Ascan(aPerFerias,{ |X| X[8] == "1" })
		SRH->RH_FILIAL	:= SRA->RA_FILIAL
		SRH->RH_MAT		:= SRA->RA_MAT
		SRH->RH_TIPCAL 	:= "N"
		SRH->RH_SALMIN 	:= Val_SalMin
		SRH->RH_OBSERVA	:= aPerFerias[nPosFer,6]
		SRH->RH_SALMES	:= nSalM1
		SRH->RH_SALDIA	:= Round(nSalD1,2)
		SRH->RH_SALHRS	:= Round(nSalH1,2)
		SRH->RH_SALARIO	:= Salmes
		SRH->RH_SALDIA1	:= Round(nSalD2,2)  // Salario Dia Prox. Mes
		SRH->RH_SALHRS1	:= Round(nSalH2,2) //  Salario Hora Prox. Mes
		SRH->RH_SALDIF 	:= SRA->RA_SALARIO //Grava salario atual do funcionario para comparacao no calculo da folha

	EndIf

	If cPaisLoc == "PTG"  .or. cPaisLoc == "ANG"
		SRH->RH_TIPO := "1"
	EndIf

	SRH->( MsUnLock() )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Deletar no SRR as Verbas Excluidas de aCols                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	dbSelectArea("SRR")
	If !lItemCLVL
		DbSetOrder( RetOrder( "SRR", "RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC" ) )
	Else
		DbSetOrder( RetOrder( "SRR", "RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC+RR_ITEM+RR_CLVL" ) )
	EndIf

	For nP := 1 To nLenaColsFer
		If aScan( aCols,{ |x| ( aColsFer[ nP , nPosPd ] + aColsFer[ nP , nPosCC ] + aColsFer[nP, nPosSeq] ) ==  ( x[ nPosPd ] + x [ nPosCc ] + x[ nPosSeq ]) } ) == 0
			lFound := SRR->( dbSeek(SRA->(RA_FILIAL+RA_MAT) + "F" + Dtos(aColsFer[nP, nPosData]) + aColsFer[nP,nPosPd] + aColsFer[nP,nPosCc]) )
		    If !Empty(aColsFer[nP,nPosSeq])
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Inclusao para o Controle de Sequencia - Indice nao possui Seq³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				While !Eof() .and. (SRR->(RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC) == SRA->(RA_FILIAL+RA_MAT) + "F" + Dtos(aColsFer[nP, nPosData]) + aColsFer[nP, nPosPd] + aColsFer[nP, nPosCc])
					If SRR->RR_SEQ == aColsFer[nP, nPosSeq]
							lFound := .T.
							Exit
					Else
							lFound := .F.
					EndIf
					SRR->(DbSkip())
				EndDo
			EndIf
			If lFound
				RecLock("SRR",.F.,.T.)
				SRR->( dbDelete() )
				SRR->( MsUnLock() )
			EndIf
		EndIf
	Next nP

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Gravacao dos Itens das Férias                                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	DbSelectArea("SRR")
	If !lItemCLVL
		DbSetOrder( RetOrder( "SRR", "RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC" ) )
	Else
		DbSetOrder( RetOrder( "SRR", "RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC+RR_ITEM+RR_CLVL" ) )
	EndIf
	For nP := 1 To nLenaCols
		If !Empty( aCols[nP, nPosPd] ) .And. !aCols[nP, nPosDelete]
			lFound := DbSeek( SRA->(RA_FILIAL+RA_MAT) + "F" + Dtos(aCols[nP, nPosData]) + aCols[nP, nPosPd] + aCols[nP, nPosCc])
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Inclusao para o Controle de Sequencia - Indice nao possui Seq³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			While !Eof() .and. (SRR->(RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC) == SRA->(RA_FILIAL+RA_MAT) + "F" + Dtos(aCols[nP, nPosData]) + aCols[nP, nPosPd] + aCols[nP, nPosCc])
				If SRR->RR_SEQ == aCols[nP, nPosSeq]
					lFound := .T.
					Exit
				Else
					lFound := .F.
				EndIf
				SRR->(DbSkip())
			EndDo

			If lFound
				RecLock("SRR",.F.,.T.)
			Else
				RecLock("SRR",.T.,.T.)
			EndIf

			SRR->RR_FILIAL	:= SRA->RA_FILIAL											//Filial
			SRR->RR_MAT		:= SRA->RA_MAT												//Matricula
			SRR->RR_TIPO3	:= "F"														// Tipo do Movimento - R(escisao) K(Ferias)

			//Integracao com Modulo SIGAPCO
			PcoDetLan("000089","01","GPEM030")

			SRR->RR_PROCES	:= SRA->RA_PROCES										//Processo do Funcionario
			SRR->RR_DATA 	:= M->RH_DATAINI

			For nX := 1 To Len( aSrrHeader )
				If ( aScan( aSRRVirtual , { |cCpo| ( cCpo == aSRRHeader[ nX , 02 ] ) } ) != 0.00 ) .Or. aSrrHeader[ nX , 02 ] == "RR_PROCES"
					Loop
				EndIf
				If aSrrHeader[ nX , 02 ] == "RR_HORAS"
					SRR->RR_HORAS	:= If (aCols[nP, nPosTipo1]=="H",fConvHoras(aCols[nP, nX],"2"),aCols[nP, nX])//Horas da Verba
				ElseIf aSrrHeader[ nX , 02 ] == "RR_HORINFO"
					SRR->RR_HORINFO	:= If (aCols[nP, nPosTipo1]=="H",fConvHoras(aCols[nP, nX],"2"),aCols[nP, nX])//Horas Informadas da Verba
				Else
					If aSrrHeader[ nX , 02 ] == "RR_DATA"
						Loop
					ElseIf aSrrHeader[ nX , 02 ] == "RR_DATAPAG"
						SRR->RR_DATAPAG	:= If( aCols[ nP, nDataPag ] == Nil .or. Empty( aCols[ nP , nDataPag ] ) , M->RH_DTRECIB , aCols[ nP , nDataPag ] )
					ElseIf aSrrHeader[ nX , 02 ] == "RR_TIPO2"
						SRR->RR_TIPO2:= If( aCols[ nP , nPosTipo2 ] $ " C", "K" , aCols[ nP, nPosTipo2 ] )
					Else
						SRR->( &( aSRRHeader[ nX , 02 ] ) ) := aCols[ nP, nX ]
					EndIf
				EndIf
			Next nX
			SRR->( MsUnLock() )

			//Integracao com Modulo SIGAPCO
			PcoDetLan("000089","01","GPEM030")

		ElseIf	aCols[nP, nPosDelete]	 													//Deletada
			If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + "F" + Dtos(aCols[nP, nPosData]) + aCols[nP, nPosPd] + aCols[nP, nPosCc])
				RecLock("SRR",.F.,.T.)
				SRR->( dbDelete() )
				SRR->( MsUnLock() )
			EndIf
		EndIf
	Next nP

	If (cPaisLoc <> "VEN") .Or. (cPaisLoc == "VEN" .And. GetMemVar("RH_VACBON") <> "2")
		dbSelectArea("SRA")
		RecLock("SRA",.F.,.T.)
		SRA->RA_SITFOLH := "F"
		SRA->( MsUnLock() )
	EndIf

	If !(cPaisLoc $ "PTG|VEN") .Or. ;
	    (cPaisLoc == "VEN" .And. GetMemVar("RH_VACBON") <> "2")
		//-- Grava os afastamentos de ferias e licenca remunerada no SR8
		if !(lRet:= fGFerSR8(M->RH_DATAINI, M->RH_DATAFIM))
			DisarmTransaction()
			Break
		EndIf
	EndIf

End Transaction
Return( Nil )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fdatafer  ºAutor  ³Microsiga           º Data ³  12/29/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FDatafer()

Local aArea		 := GetArea()
Local aPerAberto := {}
Local cTipoDia 	 := "2"
Local cTipoAfas  := ""
Local cCampo	 := ReadVar()
Local DATAINI	 := CtoD("")
Local DATAFIM	 := CtoD("")
Local DTAVISOF	 := CtoD("")
Local DTRECIBO	 := CtoD("")
Local dDtRetAf 	 := CtoD("")
Local dDataIni 	 := CtoD("")
Local dDatafim 	 := CtoD("")
Local lHabiles	 := .T.
Local lSabNUtil  := .F.
Local lParSab    := .F.
Local nDMes12  	 := nDMes01 := 0
Local nDLicQ1  	 := nDLicQ2 := 0
Local nRCMOrder  := 0
Local nAvisFer	 := GetNewPar("MV_AVISFER",0)
Local oModel	 := FwModelActive()
Local nBkpFalt	 := 0
Local lJaDescFal := Type("nDescFal") <> "U" .And. nDescFal > 0
Local aPerFERBkp := AClone(aPerFerias)
Local nPosFerBkp := 0
Local nPosAuto	 := 0
Local lPerQuit   := .F.
Local lApInvAux  := .F.
Local nPosRot    := 0

Private cCpo	:= ""

DEFAULT cAboAnt    := If(GetMvRH("MV_ABOPEC") == "S", "1", "2") //-- Abono antes ferias

lAposInv   := .F.

//--Verifica se nao tem Afastamento no Inicio das Ferias
fChkAfas(SRA->RA_FILIAL,SRA->RA_MAT,M->RH_DATAINI,@dDataIni,@dDtRetAf,,M->RH_DATAINI,M->RH_DATAINI+M->RH_DFERIAS,,,@cTipoAfas)

If dDtRetAf >= M->RH_DATAINI .and. dDataIni < (M->RH_DATAINI+M->RH_DFERIAS)
	Help(,,STR0088,, STR0035+Dtoc(dDtRetAf),1,0 )
	Return( .F. )
EndIf

//--Verifica se o Afastamento possuí data final
If !Empty(dDataIni) .and. Empty(dDtRetAf) .and. dDataIni < (M->RH_DATAINI+M->RH_DFERIAS)
	If cPaisLoc == "BRA" .and. cTipoAfas == "U3" .and. M->RH_DBASEAT <= dDataIni //Aposentadoria por invalidez - Permitir apenas calculo de férias vencidas
		lApInvAux := .T.		
	Else 
		Help(,,STR0088,, STR0112,1,0 )
		Return(.F.)
	EndIf
EndIf

If cPaisLoc == "PAR" .And. !LocChecData(M->RH_DATAINI)
	AVISO(STR0034,STR0045,{STR0002})  //"Aviso","Las vacaciones deben comezar en LUNES o en el proximo dia util en el caso de ser feriado"###"Redigita"
	Return(.F.)
EndIf

If cPaisLoc $ "PTG|COL|VEN|PER|ANG"
	nRCMOrder := RetOrder( "RCM", "RCM_FILIAL+RCM_PD" )
	cTipoDia := gp240RetCont(;
					"RCM", 									; 			// cAlias
  					nRCMOrder, 								; 			// nIndex
					xFilial("RCM") + fGetCodFol( "0072"),	; 			// cKey
					"RCM_TIPODI")
EndIf

If cPaisLoc == "BRA"
	cAboPec  := If(!Empty(M->RH_ABOPEC),M->RH_ABOPEC, cAboAnt )
EndIf

DATAINI  := M->RH_DATAINI

//Faz o recálculo dos dias de direito a férias e atualiza o cabeçalho das férias com os dias de direito
aPerFerias := {}
If !(cPaisLoc $ "PER|PTG|ANG") .Or. StrZero(Year(SRA->RA_ADMISSA),4) == StrZero(Year(dDataAte),4)
	Calc_Fer(@aPerFerias,If(M->RH_DATABAS >= M->RH_DATAINI,M->RH_DBASEAT,DATAINI),,,,,,.F.,If(cPaisLoc=="BRA",M->RH_DATABAS,CtoD('')))
ElseIf cPaisLoc == "ANG"
	Calc_Fer(@aPerFerias,LastDate(CtoD("01/"+Substr(cMesAnoRef,5,2)+"/"+Substr(cMesAnoRef,1,4))),@n2Dferven,,,,,.F.)
ElseIf cPaisLoc == "PER"
	Calc_Fer(@aPerFerias,DATAINI,,,,,,.F.)
Else
	Calc_Fer(@aPerFerias,Ctod("31/12/"+StrZero(Year(DATAINI),4)),,,,,,.F.)
EndIf

//Posicionar no periodo aberto atual
nPosFer	   := aScan(aPerFerias,{ |X| X[8] == "1" })
nPosFerBkp := aScan(aPerFERBkp,{ |X| X[8] == "1" })

If nPosFer == 0
	Help(,,STR0088,, STR0078,1,0 )		//"Não existe período de cálculo aberto para a competência"
	Return(.F.)
EndIf

If Len(aPerFerias) > 0 .And. Len(aPerFERBkp) > 0 .And. nPosFerBkp > 0 .And. Len(aPerFerias) == Len(aPerFERBkp) .And. aPerFerias[nPosFer,1] < aPerFERBkp[nPosFerBkp,1]
	aPerFerias := AClone(aPerFERBkp)
	lPerQuit   := .T.
EndIf

If !lPerQuit
	n2Dferven  := aPerFerias[nPosFer][3]
	n2Dferave  := aPerFerias[nPosFer][4]

	n2Dferven := If (n2DferVen <= 0,n2Dferave,n2Dferven)

	If cPaisLoc = "BRA"
		n2Dferven := If (n2DferVen>nDiasAux,nDiasAux,n2Dferven)
	EndIf

	nBkpFalt := oModel:GetValue("GPEM030_MSRH","RH_DFALTAS")
	// Verifica as Faltas e Calcula as Medias do Periodo
	If !lAltFalt
		Ver_med(@nfaltas)

		If nFaltas == 0
			//--Quando as Ferias for a Vencer deve proporcionalizar as Ferias
			If n2Dferven < aTabFer[3]
				If cPaisLoc=="BRA" .and. cPerFeAc=='S' .and. n2Dferven > 0
					nFaltas  := SRF->RF_DFALVAT
				Else
					nFaltas  := SRF->RF_DFALAAT
				EndIf
			Else
				nFaltas  := SRF->RF_DFALVAT
			Endif
		Endif

		If nFaltas == 0 .And. nBkpFalt > 0
			nFaltas	:= nBkpFalt
		EndIf
	EndIf

	M->RH_DFALTAS := nFaltas
	n2Dferven := If(!Empty(dFVenPen),nDVenPen,n2Dferven)  // - Ajusta os dias de ferias vencidas quando existirem dias pendentes do periodo

	If ValType(oModel) == "O"
		oModel:LoadValue("GPEM030_MSRH","RH_DFERVEN",n2Dferven)
	EndIf

	If cPaisLoc == "PER"
		dRch_DtIni	:= dDataDe
		dRch_DtFim	:= DDataAte
		nValAux	:= 0
		dPerCad 	:= CtoD( Substr( DtoS(dRch_DtFim) ,7,2) + "/" + Substr( DtoS(dRch_DtFim) ,5,2) + "/" + AllTrim(Str( Year(dRch_DtFim) - 2 )) )
		aEval( aPerFerias , { |x| iif( x[1] < dRch_Dtini .and. x[2] >= dPerCad , nValAux += (x[3] - x[14]) , ) } )
		If ValType(oModel) == "O"
			oModel:LoadValue("GPEM030_MSRH","RH_DFERVEN",nValAux)
		EndIf
	EndIf

	M->RH_DFERVEN := oModel:GetValue("GPEM030_MSRH","RH_DFERVEN")

	If lApInvAux
		nBkpDFer := M->RH_DFERIAS := M->RH_DFERVEN
		M->RH_DABONPE := 0
	EndIf

	//Atualiza o cabeçalho das férias com os dias de férias que serão gozados
	If nBkpDFer == M->RH_DFERIAS
		If Empty(aRotAuto) .OR. (nPosAuto := aScan(aRotAuto, {|x| x[1] == "RH_DFERIAS"})) == 0
			If cPaisLoc $ "ANG*VEN*COL"
				oModel:LoadValue("GPEM030_MSRH","RH_DFERIAS",n2DFerVen)
			ElseIf cPaisLoc == "PER"
				nValAux := 0
				aEval( aPerFerias , { |x| iif( x[1] < dRch_Dtini .and. x[2] >= dPerCad , nValAux += (x[3] - x[14]) , ) } )
				oModel:LoadValue("GPEM030_MSRH","RH_DFERIAS",nValAux)
			Else
				nDescFal := nFaltas
				TabFaltas(@nDescFal)

				//--Quando as Ferias for a Vencer deve proporcionalizar as Ferias
				If n2DferVen < nDiasAux .And. !lMetadeFal .And. !lTempoParc
					nDescFal := ((nDescFal / 30) * n2DferVen)
				EndIf

				//--A prioridade sera sempre para os dias de vencidas pendentes
				If nDVenPen > 0 .And. !Empty(dIVenPen)
					If nDiasProg > 0
						oModel:LoadValue("GPEM030_MSRH","RH_DFERIAS",Min((nDVenPen - nDescFal),nDiasProg))
					Else
						oModel:LoadValue("GPEM030_MSRH","RH_DFERIAS",(nDVenPen - nDescFal))
					EndIf
					If Type("nDFalt") != "U"
						nDFalt := nDescFal
					EndIf
				ElseIf !lMetadeFal .And. !lTempoParc
					If nDiasProg > 0
						If ( oModel:GetValue("GPEM030_MSRH","RH_DFERVEN") - nDescFal ) > 0 .And. !lJaDescFal
							nDiasProg := Min(nDiasProg  - nDescFal , oModel:GetValue("GPEM030_MSRH","RH_DFERVEN") - nDescFal )
							If nDiasProg + nDAntPer <= aTabFer[3]
								oModel:LoadValue("GPEM030_MSRH","RH_DFERIAS",Max(nDiasProg,0))
							EndIf
						EndIf
					ElseIf nDAntPer > 0 .And. If(cPaisLoc == "ARG", dDtBasFer <= aPerFerias[nPosFer][1], dDtBasFer == aPerFerias[nPosFer][1])
						oModel:LoadValue("GPEM030_MSRH","RH_DFERIAS",Max(oModel:GetValue("GPEM030_MSRH","RH_DFERVEN") - nDescFal - nDAntPer,0))
					Else
						oModel:LoadValue("GPEM030_MSRH","RH_DFERIAS",Max(oModel:GetValue("GPEM030_MSRH","RH_DFERVEN") - nDescFal,0))
					EndIf
				EndIf
			EndIf
			M->RH_DFERIAS := oModel:GetValue("GPEM030_MSRH","RH_DFERIAS")
			If !(cCampo $ "M->RH_DIALREM*M->RH_DIALRE1")
				M->RH_DIALREM := 0
				M->RH_DIALRE1 := 0
			EndIf
			nBkpDFer := M->RH_DFERIAS
		Else
			oModel:LoadValue("GPEM030_MSRH","RH_DFERIAS", aRotAuto[nPosAuto,2])
			M->RH_DFERIAS := oModel:GetValue("GPEM030_MSRH","RH_DFERIAS")
		EndIf
	EndIf

	If cPaisLoc $ "PTG|COL|VEN|PER|ANG"

		If cTipoDia == "2"
			DATAFIM  :=(M->RH_DATAINI + Round(M->RH_DFERIAS,0)) - 1
		Else
			GpeCalend(,,,,,DATAINI,@dDataFim,M->RH_DFERIAS,"F",cCampo,.F.)
			DATAFIM  := dDataFim
		EndIf
	Else
		DATAFIM  := If(cPaisLoc == "BRA".Or.!lHabiles,(M->RH_DATAINI + Round(M->RH_DFERIAS+M->RH_DIALREM+M->RH_DIALRE1,0)) - 1,LocFimFer(M->RH_DATAINI, Round(M->RH_DFERIAS,0),'1',.T.,.T.,.T.)-1)
	EndIf

	If cPaisloc <> "BRA"
		If cPaisLoc == "PAR"
			lParSab := If(SRA->RA_SABUTIL == "1",.T.,.F.)
		EndIf
		If cPaisLoc == "CHI"
			lSabNUtil := .T.
		ElseIf cPaisLoc == "PAR" .And. !lParSab
			lSabNUtil := .T.
		EndIf
	EndIf
Else
	DATAFIM  := If(cPaisLoc == "BRA".Or.!lHabiles,(M->RH_DATAINI + Round(M->RH_DFERIAS+M->RH_DIALREM+M->RH_DIALRE1,0)) - 1,LocFimFer(M->RH_DATAINI, Round(M->RH_DFERIAS,0),'1',.T.,.T.,.T.)-1)
EndIf

//Se os dias forem quebrados por conta de faltas (0.1 ou 1.2 ou 2.3, etc), soma um dia.
If ( cPaisLoc == "BRA" .Or. !lHabiles ) .and. M->RH_DFERIAS > Round(M->RH_DFERIAS,0)
	DATAFIM := DATAFIM + 1 
EndIf

DATAFIM  := If (DATAFIM < DATAINI,DATAINI,DATAFIM)
DTAVISOF := fVerData(M->RH_DATAINI - (If (nAvisFer > 0, nAvisFer, Max(aTabFer[3],30))))

If !(cPaisLoc == "PER") .And. cAboPec =="1" .and.  M->RH_DABONPE > 0  //--  Considera Abono Pecuniario antes da Dt Inicial de Ferias para o caluclo da data de pagamento
	DTRECIBO := DataValida(DataValida((M->RH_DATAINI-M->RH_DABONPE)-1,.F.)-1,.F.)
ElseIf cPaisLoc == "COL"
	DTRECIBO := DataValida(M->RH_DATAINI-0,.F.)
Else
	DTRECIBO := DataValida(DataValida(M->RH_DATAINI-1,.F.)-1,.F.)
EndIf

If cPaisLoc == "ANG"
	If Type("lDUtilFer") # "U"
		lDUtilFer := cTipoDia == "1"
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se Deve Considerar dias 24/12, 25/12, 31/12 e 01/01 ³
//| como licenca remunerada.                                     |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
fChkLicRem(DATAINI,DATAFIM,@nDMes12,@nDMes01)

If nDMes12 + nDMes01 > 0 .and. nDMes12 + nDMes01 > M->RH_DIALREM + M->RH_DIALRE1
	DATAFIM += nDMes12 + nDMes01
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se houver dias de ferias = 0.5, lancar 0.5 em Lic. Remunerda ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
fChkFQueb(DATAINI,DATAFIM,@nDLicQ1,@nDLicQ2)

//Ajuste nos dias de licença para quando dias são quebrados por conta de faltas
If ( cPaisLoc == "BRA" .Or. !lHabiles ) .and. M->RH_DFERIAS > Round(M->RH_DFERIAS,0) .and. M->RH_DFERIAS - nDLicQ1 == Round(M->RH_DFERIAS,0)
	nDLicQ1 -= ( M->RH_DFERIAS - Round(M->RH_DFERIAS,0) ) 
	nDLicQ1 += ( 1 - ( M->RH_DFERIAS - Round(M->RH_DFERIAS,0) ) ) 
EndIf

nPosRot := aScan(aRotFer, {|x| AllTrim(Upper(x[1])) == SRA->RA_PROCES})

//Procura periodo de calculo aberto para o fim das ferias
If AnoMes(DATAINI) <> AnoMes(DATAFIM)
	fRetPerComp(SubStr(Dtos(DATAFIM),5,2), SubStr(Dtos(DATAFIM),1,4), Nil, SRA->RA_PROCES, Iif(nPosRot > 0, aRotFer[nPosRot, 2], fGetCalcRot("3")), @aPerAberto )
	If Empty(aPerAberto)
		Help(,,STR0088,, STR0078,1,0 )		//"Não existe período de cálculo aberto para a competência"
		Return(.F.)
	EndIf
EndIf

//Procura periodo de calculo de acordo com a data digitada
aPerAberto := {}
fRetPerComp(SubStr(Dtos(DATAINI),5,2), SubStr(Dtos(DATAINI),1,4), Nil, SRA->RA_PROCES, Iif(nPosRot > 0, aRotFer[nPosRot, 2], fGetCalcRot("3")), @aPerAberto )
If Empty(aPerAberto)
	Help(,,STR0088,, STR0078,1,0 )		//"Não existe período de cálculo aberto para a competência"
	Return(.F.)
EndIf

If !Empty(aPerAberto[1,11])
	Help(,,STR0088,, STR0087,1,0 )		//"Período de Férias já foi integrado"
	Return(.F.)
EndIf

lAposInv := lApInvAux

M->RH_DIALREM := If(lAposInv, 0, If( Empty(M->RH_DIALREM), nDMes12 + nDLicQ1, M->RH_DIALREM ))
M->RH_DIALRE1 := If(lAposInv, 0, If( Empty(M->RH_DIALRE1), nDMes01 + nDLicQ2, M->RH_DIALRE1 ))
M->RH_DATAFIM := DATAFIM
M->RH_DTAVISO := DTAVISOF
M->RH_DTRECIB := DTRECIBO
M->RH_SALARIO := SRA->RA_SALARIO
M->RH_PERIODO := aPerAberto[1,1]
M->RH_ROTEIR  := aPerAberto[1,8]
M->RH_NPAGTO  := aPerAberto[1,2]

If ValType(oModel) == "O"
	oModel:LoadValue("GPEM030_MSRH","RH_DIALREM", If(lAposInv, 0, If( Empty(M->RH_DIALREM), nDMes12 + nDLicQ1, M->RH_DIALREM )) )
	oModel:LoadValue("GPEM030_MSRH","RH_DIALRE1", If(lAposInv, 0, If( Empty(M->RH_DIALRE1), nDMes01 + nDLicQ2, M->RH_DIALRE1 )) )
	oModel:LoadValue("GPEM030_MSRH","RH_DATAFIM",DATAFIM)
	oModel:LoadValue("GPEM030_MSRH","RH_DTAVISO",DTAVISOF)
	oModel:LoadValue("GPEM030_MSRH","RH_DTRECIB",DTRECIBO)
	oModel:LoadValue("GPEM030_MSRH","RH_SALARIO",SRA->RA_SALARIO)
	oModel:LoadValue("GPEM030_MSRH","RH_PERIODO",aPerAberto[1,1])
	oModel:LoadValue("GPEM030_MSRH","RH_ROTEIR",aPerAberto[1,8])
	oModel:LoadValue("GPEM030_MSRH","RH_NPAGTO",aPerAberto[1,2])
EndIf

If !(GetRemoteType() == -1) .and. !lWorkFlow .and. lAposInv
	AVISO(STR0034,"Funcionário aposentado por invalidez. O cálculo deve ser feito integralmente para quitação das férias do período aquisitivo.",{STR0001})  //"Aviso","Funcionário aposentado por invalidez. O cálculo deve ser feito integralmente para quitação das férias do período aquisitivo."###"Confirma"
EndIf

RestArea(aArea)

Return( .T. )
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fDiasFer  ºAutor  ³Microsiga           º Data ³  12/29/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza dias de ferias no cabecalho                        º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fDiasFer()

Local nDFal
Local oModel	 := FwModelActive()

If cPaisLoc == "BRA"
	If IsBlind() .Or. nBkpFalt != M->RH_DFALTAS .And. MsgYesNo(OemToAnsi(STR0159), OemToAnsi(STR0088))//"Confirma a alteração nas faltas?"
		nBkpFalt 		:= M->RH_DFALTAS
		nfaltas			:= M->RH_DFALTAS
		lAltFalt		:= .T.
		If ValType(oModel) == "O"
			oModel:LoadValue("GPEM030_MSRH", "RH_DFALTAS", M->RH_DFALTAS)
		EndIf
	Else
		Return( .F. )
	EndIf
	nDFal := M->RH_DFALTAS
	TabFaltas(@nDFal)
	If M->RH_DFERVEN <= aTabFer[3]
		If !lMetadeFal .And. !lTempoParc
			nDFal := ((nDFal / 30) * M->RH_DFERVEN)
		ElseIf lMetadefal
			nDFal := M->RH_DFERVEN / 2
		Else
			nDFal := 0
		Endif
	EndIf
	dFerVen := M->RH_DFERVEN - nDAntPer
	M->RH_DFERIAS := Max( If(!lMetadefal, If(!lTempoParc, dFerVen - nDFal, 0), dFerVen / 2 ), 0 )
	M->RH_DABONPE := 0.00
	nBkpDFer := M->RH_DFERIAS
Else
	M->RH_DFERIAS := M->RH_DFERVEN
EndIf

Return( .T. )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fVerDias  ºAutor  ³Microsiga           º Data ³  12/29/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVerDias()

Local aArea			:= GetArea()
Local nDFal
Local nIdade
Local nFer := 0
Local lMsg := .T.
Local nTempoParc 	:= 0
Local nQtdFer		:= 0
Local nQtdDias		:= 0
Local lMaior14		:= .F.
Local lSimNao		:= .T.
Local oModel	    := FwModelActive()

DEFAULT lRefTrab		:= FindFunction("fRefTrab") .And. fRefTrab("F")

oModel:SetValue("GPEM030_MSRH","RH_DIALREM", 0 )
oModel:SetValue("GPEM030_MSRH","RH_DIALRE1", 0 )

nDFal := M->RH_DFALTAS
TabFaltas(@nDFal)
If cPaisLoc =="BRA"
	If lRefTrab
		If M->RH_DFERIAS < 5 .and. !lTerFerMP
			If lWorkFlow
				AutoGrLog(STR0117) //"Conforme Artigo 134 parágrafo 1º da CLT, as férias não devem ser concedidas com menos de 5 dias de gozo."
			Else
				Help(,,STR0034,,STR0117 ,1,0 ) //"Conforme Artigo 134 parágrafo 1º da CLT, as férias não devem ser concedidas com menos de 5 dias de gozo."
			EndIf
			Return(.F.)
		EndIf

		If M->RH_DFERIAS < 14 .and. !lTerFerMP
			SRH->(DbSetOrder(1))
			If SRH->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + DtoS(M->RH_DATABAS)))
				While SRH->(RH_FILIAL + RH_MAT + DtoS(RH_DATABAS) == SRA->RA_FILIAL + SRA->RA_MAT + DtoS(M->RH_DATABAS))
					nQtdFer++
					nQtdDias += SRH->RH_DFERIAS + SRH->RH_DABONPE
					If SRH->RH_DFERIAS >= 14
						lMaior14 := .T.
					EndIf
					SRH->(DbSkip())
				EndDo
			EndIf
			If !lMaior14 .And. nDVenPen == 0 //Quando for quitacao de saldo a quantidade pode ser menor
				If nQtdFer == 2
					If lWorkFlow
						AutoGrLog(STR0118) //"Conforme Artigo 134 parágrafo 1º da CLT, ao menos uma férias por período aquisitivo deve ter no mínimo 14 dias. Já foram efetuados dois cálculos com menos de 14 dias para este periodo aquisitivo."
					Else
						Help(,,STR0034,,STR0118 ,1,0 ) //"Conforme Artigo 134 parágrafo 1º da CLT, ao menos uma férias por período aquisitivo deve ter no mínimo 14 dias. Já foram efetuados dois cálculos com menos de 14 dias para este periodo aquisitivo."
					EndIf
					Return(.F.)
				ElseIf !( ( aTabFer[1] * aTabFer[4] - nDescFal ) == ( nQtdDias + M->RH_DFERIAS + M->RH_DABONPE ) ) //Se estiver quitando o período não efetua validação
					If ( ( aTabFer[1] * aTabFer[4] - nDescFal ) - ( nQtdDias + M->RH_DFERIAS + M->RH_DABONPE ) ) < 14
						If lWorkFlow
							AutoGrLog(STR0119) //"Conforme Artigo 134 parágrafo 1º da CLT, ao menos uma férias por período aquisitivo deve ter no mínimo 14 dias. A configuraçao atual das férias não permitirá que esta premissa seja cumprida."
						Else
							Help(,,STR0034,,STR0119 ,1,0 ) //"Conforme Artigo 134 parágrafo 1º da CLT, ao menos uma férias por período aquisitivo deve ter no mínimo 14 dias. A configuraçao atual das férias não permitirá que esta premissa seja cumprida."
						EndIf
						Return(.F.)
					EndIf
				EndIf
			EndIf
			RestArea(aArea)
		EndIf
	EndIf

	If M->RH_DABONPE > 0
		nTempoParc := SRA->RA_HRSEMAN
		If ( SRA->RA_HOPARC == "1" .And. nTempoParc <= 25 .And. nTempoParc  > 0 .And. Len(aTabFer2) > 0 .And. P_REGPARCI )
			nPosTbFer := Ascan(aTabFer2, { |X|  nTempoParc <= X[6] .And. nTempoParc > X[5] })
			If lWorkFlow
				AutoGrLog(STR0079 + STR0080)
			Else
				//Funcionário em regime de empo parcial e dias de abono preenchidos. Conforme o Artigo 143, inciso 3º da CLT,
				//o abono pecuniário não se aplica aos empregados sob o regime de tempo parcial, deseja continuar mesmo assim?
				lSimNao:= MsgYesNo(OemToAnsi(STR0079) + CRLF + OemToAnsi(STR0080) , OemToAnsi(STR0064 ))
			EndIf
			If !lSimNao
				Return ( .F. )
			Endif
		Endif
	EndIf

	If (ROUND(M->RH_DFERIAS,2) + M->RH_DABONPE + If(!lMetadeFal, If(!lTempoParc, nDFal, 0) , M->RH_DFERVEN / 2 ) ) >  nDiasAux
		Help(" ","1","GPEM30DFER")
		Return( .F. )
	EndIf

	If (ROUND(M->RH_DFERIAS,2) + M->RH_DABONPE + If(!lMetadeFal, If(!lTempoParc, nDFal, 0) , M->RH_DFERVEN / 2 ) + nDAntPer) >  nDiasAux
		Aviso(STR0034,;								                      //"Aviso"
		      STR0046 + "[" + AllTrim(Str(nDAntPer,3))       + "] + " +; //"Dias Antecipados"
			  STR0043 + "[" + AllTrim(Str(M->RH_DFERIAS,3))  + "] + " +; //"Dias Ferias"
			  STR0044 + "[" + AllTrim(Str(M->RH_DABONPE,3))  + "] + " +; //"Dias Abono"
			  STR0047 + "[" + AllTrim(Str(nDFal,3))          + "] "   +;  //Faltas
			  STR0048 + " " + AllTrim(Str(nDiasAux,3))     + " "    +; //"nao podem ultrapassar"
			  STR0049 + ".",{STR0002}) 						      	       //"Dias"###"Redigita"
		Return( .F. )
	EndIf

	//Tratamento para férias antecipadas
	If nDVenPen > 0 .and. (ROUND(M->RH_DFERIAS,2) + M->RH_DABONPE + If(!lMetadeFal, If(!lTempoParc, nDFal, 0) , M->RH_DFERVEN / 2 ) + nDAntPer) >  SRF->RF_DFERVAT
		Aviso(STR0034,;								                      //"Aviso"
		      STR0046 + "[" + AllTrim(Str(nDAntPer,3))       + "] + " +; //"Dias Antecipados"
			  STR0043 + "[" + AllTrim(Str(M->RH_DFERIAS,3))  + "] + " +; //"Dias Ferias"
			  STR0044 + "[" + AllTrim(Str(M->RH_DABONPE,3))  + "] + " +; //"Dias Abono"
			  STR0047 + "[" + AllTrim(Str(nDFal,3))          + "] "   +;  //Faltas
			  STR0048 + " " + AllTrim(Str(SRF->RF_DFERVAT,3))     + " "    +; //"nao podem ultrapassar"
			  STR0049 + ".",{STR0002}) 						      	       //"Dias"###"Redigita"
		Return( .F. )
	EndIf

	nIdade := Int((dDataBase - SRA->RA_NASC) / 365)
	If !lRefTrab .And. (nIdade < 18 .Or. nIdade > 50) .And. ((ROUND(M->RH_DFERIAS,2) + M->RH_DABONPE + nDFal) < nDiasAux)
		MsgInfo(STR0036)  //"Funcionario menor de 18 Anos ou Maior que 50 Anos, devem tirar Ferias em Periodo Unico."
	EndIf

	If !lWorkFlow .And. !(IsBlind())
		nFer := (M->RH_DFERVEN - If(!lMetadeFal, If(!lTempoParc, nDFal, 0), M->RH_DFERVEN / 2) - nDAntPer)
		If M->RH_DABONPE > ( nFer / 3 )
			cAviso := 	STR0108 + "[ " + AllTrim(Str(M->RH_DFERVEN,3))		+ " ] - " 	+;	//"Dias Ferias"
						STR0046 + "[ " + AllTrim(Str(nDAntPer,3))			+ " ] - " 	+;	//"Dias Antecipados"
				  		STR0047 + "[ " + AllTrim(Str(nDFal,3))				+ " ] )" 	+;	//Faltas
				  		STR0107 + ""   + AllTrim(Str((nFer),3))				+ ""	 	+;	//"que totalizam"
				  		STR0049 + "." 	//"Dias"
			lMsg:=(MsgYesNo(OemToAnsi(STR0106)+ cAviso + CRLF + OemToAnsi(STR0110),OemToAnsi(STR0034))) //"Aviso"# "De acordo com a CLT, os dias de abono devem corresponder a 1/3 do total de dias de férias." # OK
			If !lMsg
				Help(,,STR0034,,STR0106 + cAviso ,1,0 ) //"Aviso"# "As ferias do funcionario irao iniciar em um Feriado." # OK
				Return(.F.)
			Endif
		Endif
	Endif

	//Se dias de ferias, ou ferias mais abono for igual a 30 zera os campos licenca remunerada
	If ( M->RH_DFERIAS == 30 .Or. ((M->RH_DFERIAS + M->RH_DABONPE) == 30)  ) .And. ( M->RH_DIALREM + M->RH_DIALRE1 ) > 0
		M->RH_DIALREM := 0
		M->RH_DIALRE1 := 0
	EndIf

EndIf

If M->RH_DFERIAS < 0
	Help(" ","1","GPEM30DFNE")
	Return( .F. )
EndIf

M->RH_DATAINI := CtoD("")
M->RH_DATAFIM := CtoD("")

Return( .T. )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Ver_med   ºAutor  ³Microsiga           º Data ³  12/29/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Ver_Med(nFaltas)

Local aPerBkp   := AClone(aPerFerias)
Local aPerAux   := {}
Local aArea     := GetArea()
Local dDtBasIni := Iif( !Empty(aPerFerias), aPerFerias[nPosFer][1], dDataDe )
Local dDtBasFim := Iif( !Empty(aPerFerias), aPerFerias[nPosFer][2], dDataDe )
Local nContPer 	:= 0

If nPosFer > 1 .And. !Empty(aPerFerias)
    For nContPer := nPosFer To Len(aPerFerias)
        AAdd( aPerAux, aClone(aPerFerias[nContPer]) )
    Next nContPer
    aPerFerias := AClone(aPerAux)
EndIf

dbSelectArea(cTBLXMED)
Zap

GPEXMED(dDtBasIni,CTOD(" "),dDataDe,CTOD(""),If(cPerFeAc == "S", fCalcFimAq(dDtBasFer), dDtBasFim),SalHora,Val_BInsal,aCodfol,.T.,.F.,.T.)
If nPosFer > 1 .And. !Empty(aPerFerias)
    aPerFerias := AClone(aPerBkp)
EndIf

// Faltas do Periodo
nFaltas := 0
dbSelectArea(cTBLXMED)
If n2dFerven >= nDiasAux .Or. nDVenPen > 0 .Or. lTemVenc
	If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"1"+"998"+"9698")
		nFaltas := (cTBLXMED)->RP_HORAS
	EndIf
Else
	If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"2"+"998"+"9698")
		nFaltas := (cTBLXMED)->RP_HORAS
	EndIf
EndIf
dbSelectArea("SRH")
M->RH_DFALTAS := nFaltas

dbSelectArea("SX3")

RestArea(aArea)

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³gp030Pula ³ Autor ³ Marcos Stiefano       ³ Data ³ 28/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Move o cursor para posicionamento pelo tipo Horas           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gp030Pula(lPul)

Local cCampo 	:= ReadVar()
Local oModel 	:= FWModelActivate()
Local oGrid 	:= oModel:GetModel("GPEM030_MSRR")

lPul := IIF(lPul == Nil,.F.,lPul)

If !lPul
	Return( .T. )
EndIf

If !(oGrid:GetValue("RR_TIPO1") $ "VHFD")
	HELP(" ",1,"GP090TIPO")
	Return( .F. )
EndIf

If oGrid:GetValue("RR_TIPO1") == "V" .and. "RR_HORAS" $ cCampo
	HELP(" ",1,"GP090TPERR")
	Return( .F. )
EndIf

If oGrid:GetValue("RR_TIPO1") $ "HD" .and. "RR_VALOR" $ cCampo
	HELP(" ",1,"GP090TPERR")
	Return( .F. )
EndIf

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fMedFer  ³ Autor ³ Equipe - RH     		³ Data ³ 15/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Buscar as medias no TRP									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fMedFer(nMediaOut,nMediaHrs,nMedia13s,nAntec13o,lFerias)
Local nIdade,lIdade,lProp
Local nDsrHrsAtiv 	:= 0
Local nPosPd	  	:= 0
Local nReajDis		:= 0
Local cCodPgMed		:= ""
Local cCodMedFMs 	:= ""
Local nMedHrDis 	:= 0
Local nMedVlDis 	:= 0
Local nMedVlAnt		:= 0
Local nMedHrAnt 	:= 0
Local aPerFOL		:= {}
Local lDiasVenc		:= ( SRA->RA_ADMISSA+365 ) > GetMemVar("RH_DATAINI")
Local cMedDir		:= P_MEDDIREN
Local nFerVen 		:= GETMEMVAR("RH_DFERVEN")
Local lMedFer 		:= IF(TYPE('P_MEDFER') <> "U", P_MEDFER, .T.)
Local nMedAuxM    	:= 0
Local nMedAuxMS   	:= 0
Local nMedAuxABM  	:= 0
Local nMedAuxABMS 	:= 0
Local nAuxComis     := 0

DEFAULT lFerias := .T.
DEFAULT NDIASFM := 0

//Tratamento para P_MEDDIREN = "M" - Misto. Calcula como se fosse "S" para funcionário com menos de um ano de contrato por tempo determinado.
If cMedDir == "M"
	cMedDir := If(SRA->RA_TPCONTR == "2" .and. DateDiffYear( SRA->RA_DTFIMCT , SRA->RA_ADMISSA ) < 1, "S", "N")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Calcula a Idade do Funcionario								 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nIdade := Int((dDataBase - SRA->RA_NASC) / 365)
lIdade := If (nIdade < 18 .Or. nIdade > 50,.T.,.F.)
lProp  := .F.

//Uso de variavel private porque o mnemonico lMenUmAno tem o valor redefinido na executacao do roteiro.
lMenUmAno := If( Type("lSvMen1Ano") == "U", lMenUmAno, lSvMen1Ano )

//Calcula adicionais sobre medias quando configuracao do sindicato e Salario + Verbas
P_ADISMED := If( Type("P_ADISMED") == "U", .T., P_ADISMED )

If lMenUmAno .And. nColPro == 1 .And. cPerFeAc # "S"
	lProp := .T.
ElseIf MesAno(GetMemVar("RH_DATAINI")) <= MesAno(GetMemVar("RH_DBASEAT"))
	lProp := .T.
ElseIf P_DTMDFER == "1"
	FGetPerAtual(@aPerFOL,XFilial( "RCH",SRA->RA_FILIAL),cProcesso,fGetCalcRot("1"))
	If Len(aPerFOL) > 0 .And. MesAno(GetMemVar("RH_DBASEAT")) == MesAno(aPerFOL[1][6])
		lProp := .T.
	EndIf
EndIf

dbSelectArea(cTBLXMED)

// Medias
If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"1"+"999"+"97MD")   // Outros Adic.
	nMediaOut := (cTBLXMED)->RP_VALATU
ElseIf lProp
	If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"2"+"999"+If(cMedDir == "S", "9799", "97MD"))
		nMediaOut := (cTBLXMED)->RP_VALATU
	EndIf
EndIf

//Memória de Cálculo
If (!Empty(nMediaOut) .And. __lMemCalc,	fAddMemLog("Média outros adicionais (nMediaOut) :" + cValToChar(nMediaOut),1,2), "")

If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"1"+"999"+"98MD")   // H.Extras
	nMediaHrs := (cTBLXMED)->RP_VALATU
ElseIf lProp
	If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"2"+"999"+If(cMedDir == "S", "9899", "98MD"))
		nMediaHrs := (cTBLXMED)->RP_VALATU
	EndIf
EndIf

//Memória de Cálculo
If (!Empty(nMediaHrs) .And. __lMemCalc,	fAddMemLog("Média horas extras (nMediaHrs) :" + cValToChar(nMediaHrs),1,2), "")

If GetMvRH("MV_MED1OP") == "S"
	If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"3"+"999"+If(cMedDir == "S", "9999", "99MD"))
		nMedia13s := (cTBLXMED)->RP_VALATU + fDsrHrsAtiv("3",aCodFol)
	EndIf
	// Calcula Peric. / Insalub Sobre Verba de Medias 13.Salario que tem Incidencia
	nMedPer13 := nMedIns13 := 0.00
	FMedPerIns(@nMedPer13,@nMedIns13,'3',SalHora,Val_BInsal,aCodFol,,,,P_ADISMED)
	nMedia13s += (nMedPer13+nMedIns13)

	If ( SRA->RA_CATFUNC == "C" .And. SRA->RA_SALARIO == 0.00 )
		fPropGComis('3',@nAuxComis )
		If nAuxComis > nMedia13s
			nMedia13s += ( nAuxComis - nMedia13s )
		EndIf
	EndIf

	//Memória de Cálculo
	If (!Empty(nMedia13s) .And. __lMemCalc,	fAddMemLog("Média 13 (nMedia13s) :" + cValToChar(nMedia13s),1,2), "")
	
EndIf

If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"1"+"999"+"99MD")
	nDsrHrsAtiv := fDsrHrsAtiv("1",aCodFol,"99MD") //Calculo do DSR / Horas Atividade de professores
ElseIf lProp
	If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"2"+"999"+If(cMedDir == "S", "9999", "99MD"))
		nDsrHrsAtiv := fDsrHrsAtiv("2",aCodFol,If(cMedDir == "S", "9999", "99MD")) //Calculo do DSR / Horas Atividade de professores
	EndIf
EndIf

nMediaOut += nDsrHrsAtiv //Soma DSR / Horas Atividade p/ gerar na verba de media de professores(id.636)

//Memória de Cálculo
If (!Empty(nMediaOut) .And. __lMemCalc,	fAddMemLog("Média outros adicionais + Horas atividade p/ gerar na verba de media de professores(id.636) --> (nMediaOut + nDsrHrsAtiv) :" + cValToChar(nMediaOut),1,2), "")

// Calcula Peric. / Insalub Sobre Verba de Medias Ferias que tem Incidencia
nMedPer := nMedIns := 0.00
FMedPerIns(@nMedPer,@nMedIns,'1',SalHora,Val_BInsal,aCodFol,,,,P_ADISMED)

//Memória de Cálculo
If __lMemCalc
	If(!Empty(nMedPer), fAddMemLog("Média periculosidade (nMedPer) :" + cValToChar(nMedPer),1,2), "")
	If(!Empty(nMedIns), fAddMemLog("Média insalubridade (nMedIns) :" + cValToChar(nMedIns),1,2), "")
EndIf

If Type("nMedAdcI") != "U" .And. (!Empty(aCodFol[639,1]) .Or. !Empty(aCodFol[640,1]))//Pagto Peric. Sobre Medias Ferias##Pagto Insalub. Sobre Medias Ferias
	nMedAdcI := nMedIns
	nMedAdcP := nMedPer
Else
	nMediaHrs += (nMedPer+nMedIns)

	//Memória de Cálculo
	If (!Empty(nMediaHrs) .And. __lMemCalc,fAddMemLog("Média horas extras + periculosidade + insalubridade (nMediaHrs+nMedPer+nMedIns) :" + cValToChar(nMediaHrs),1,2),"")
EndIf


// Antecipacao 13o Salario
If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"3"+"997"+"9598") .And. !lDissidio
	nAntec13o := (cTBLXMED)->RP_VALATU
EndIf

If !lDissidio .and. cTipoRot == "3"
	SRR->(DbSetOrder(RetOrder("SRR","RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR+RR_SEMANA+RR_PD+RR_CC+RR_ITEM+RR_CLVL+RR_SEQ+DTOS(RR_DATA)")))
	//Se existir férias calculadas no mesmo período, verifica se foi pago adiantamento de 13º e soma na vairável de antecipação
	If SRR->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + cRot + cSemana + aCodFol[22,1]))
		While SRR->(!Eof() .and. RR_FILIAL+RR_MAT+RR_ROTEIR+RR_SEMANA+RR_PD == SRA->RA_FILIAL + SRA->RA_MAT + cRot + cSemana + aCodFol[22,1])
			nAntec13o += SRR->RR_VALOR
			SRR->(DbSkip())
		EndDo
	Else
		//Tratativa para verificar se existem férias futuras calculadas, sem a informação da verba id 022 na SRD.
		// Dessa forma, busca a verba na SRR conforme o período da folha.
		FGetPerAtual(@aPerFOL,XFilial( "RCH",SRA->RA_FILIAL),cProcesso,fGetCalcRot("1"))
		//Busca pagamentos no mesmo ano, que podem ou não terem sido calculados no período da folha
		If Len(aPerFOL) > 0 .And. SubStr(aPerFol[1][1],1,4) <= SubStr(cPeriodo,1,4) .And. SRR->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + Iif(SubStr(aPerFol[1][1],1,4) == SubStr(cPeriodo,1,4), SubStr(aPerFol[1][1],1,4), SubStr(cPeriodo,1,4))))
			While SRR->(!Eof() .And. RR_FILIAL+RR_MAT == SRA->RA_FILIAL + SRA->RA_MAT .And. SubStr(RR_PERIODO,1,4) >= SubStr(aPerFol[1][1],1,4))
				If SRR->RR_ROTEIR == cRot .And. SRR->RR_PD == aCodFol[22,1]
					nAntec13o += SRR->RR_VALOR
				EndIf
				SRR->(DbSkip())
			EndDo
		EndIf
	EndIf
EndIf

//Caso seja dissidio, valida se a media apurada e' menor do que a media paga no mes original ou se foi selecionado para nao apurar a diferenca da media
If lDissidio .And. ( cPaisLoc != "BRA" .Or. !(SRA->RA_CATEFD $ "107/108") ) .And. SRA->RA_TPCONTR != "3" 
	If SRA->RA_CATFUNC == "C" .And. !Empty(aCodFol[343,1])
		cCodPgMed	:= aCodFol[343,1]//Media Ferias de Comissiao no Mes
		cCodMedFMs	:= aCodFol[344,1]//Media Ferias de Comissiao no Mes Seguinte
	ElseIf SRA->RA_CATFUNC == "T" .And. !Empty(aCodFol[345,1])
		cCodPgMed	:= aCodFol[345,1]//Media Ferias de Tarefa no Mes
		cCodMedFMs	:= aCodFol[346,1]//Media Ferias de Tarefa no Mes Seguinte
	ElseIf SRA->RA_CATFUNC $ "I*J" .And. !Empty(aCodFol[636,1])
		cCodPgMed	:= aCodFol[636,1]//Media Ferias (calculo professor)
		cCodMedFMs	:= aCodFol[637,1]//Media Ferias Mes Seguinte (calculo professor)
	Else
		cCodPgMed	:= aCodFol[075,1]//Media Ferias Valor
		cCodMedFMs	:= aCodFol[076,1]//Media Ferias Valor Mes Seguinte
	EndIf

	//Verifica o valor da media de valor que foi paga no mes original
	aEval( aDif_Fer, { |x| nMedVlDis += If( x[1] $ cCodPgMed + "/" + cCodMedFMs + "/" + aCodFol[623,1] + "/" + aCodFol[634,1], x[2], 0 ) } )
	//Verifica o valor da media de horas que foi paga no mes original
	aEval( aDif_Fer, { |x| nMedHrDis += If( x[1] $ aCodFol[082,1] + "/" + aCodFol[083,1] + "/" + aCodFol[622,1] + "/" + aCodFol[633,1], x[2], 0 ) } )
	//Subtrai do valor antecipado o que foi pago no mes original para calcular a diferença corretamente
	aEval( aDif_Fer, { |x| nAntec13o -= If( x[1] == aCodFol[022,1], x[2], 0 ) } )

	nAntec13o := Max(nAntec13o,0)

	//Soma o valor da diferença de médias de férias
	If Type( "nDfMedVl" ) != "U"
		//Guarda o valor sem as diferenças
		nMedVlAnt := nMedVlDis
		nMedHrAnt := nMedHrDis
		If !lDfMedPMes .and. nDfMedVl + nDfMedHr > 0 .and. NDIASFMS > 0
			nMedVlDis += ROUND( ((nDfMedVl + nDfMedVlA) * IF(lMedFer,nFerVen,30)) / NDIASFMS, 2)
			nMedHrDis += ROUND( ((nDfMedHr + nDfMedHA) * IF(lMedFer,nFerVen,30)) / NDIASFMS, 2)
		Else
			nMedVlDis += nDfMedVl + nDfMedVlA
			nMedHrDis += nDfMedHr + nDfMedHA
		EndIf
	EndIf

	If Type( "P_LMEDFERD" ) != "U" .And. P_LMEDFERD

		//Se houve pagamento de diferença de férias, houve pagamento de abono mas não foi calculada a diferença de abono, 
		//Tira a proporcionalização pois ela deve ser feita com o valor integral na fórmula GRMEDFER
		If nDfMedHA + nDfMedVlA == 0 .and. nDfMedVl + nDfMedHr > 0 .and. nDiasAbM+nDiasAbMS > 0
			nMedVlDis   := nMedVlAnt + ( ( (nMedVlDis - nMedVlAnt) / (nDiasFM ) ) * IF(lDiasVenc .Or. P_MEDFER, GetMemVar("RH_DFERVEN"), 30) )
			nMedHrDis   := nMedHrAnt + ( ( (nMedHrDis - nMedHrAnt) / (nDiasFM ) ) * IF(lDiasVenc .Or. P_MEDFER, GetMemVar("RH_DFERVEN"), 30) )
		EndIf

		nReajDis	:= If(RHH->RHH_INDICE > 0, 1 + (RHH->RHH_INDICE/100), RHH->RHH_CALC / RHH->RHH_VL)
		nMediaOut	:= nReajDis * ( nMedVlDis / (SRH->RH_DFERIAS + SRH->RH_DABONPE) * IF(lDiasVenc .Or. P_MEDFER, GetMemVar("RH_DFERVEN"), 30) )
		nMediaHrs	:= nReajDis * ( nMedHrDis / (SRH->RH_DFERIAS + SRH->RH_DABONPE) * IF(lDiasVenc .Or. P_MEDFER, GetMemVar("RH_DFERVEN"), 30) )
	Else
		If nMediaOut > 0 .Or. nMedVlDis > 0
			If PosSrv(cCodPgMed, xFilial("SRV", SRA->RA_FILIAL), "RV_COMPL_") <> "S" .Or. nMediaOut < nMedVlDis
				
				If Type( "nDfMedVl" ) != "U"
					nMedAuxM    := ROUND( ( nDfMedVl / If(lMedFer,nFerVen,30)) * NDIASFM, 2)
					nMedAuxMS   := ROUND( ( nDfMedVl / If(lMedFer,nFerVen,30)) * NDIASFMS, 2)
					nMedAuxABM  := ROUND( ( nDfMedVlA / If(lMedFer,nFerVen,30)) * NDIASFM, 2)
					nMedAuxABMS := ROUND( ( nDfMedVlA / If(lMedFer,nFerVen,30)) * NDIASFMS, 2)
				EndIf

				nPosPd := aScan( aDif_Fer, { |x| x[1] == cCodPgMed } )
				If nPosPd > 0
					fGeraVerba(cCodPgMed, aDif_Fer[nPosPd, 2] + nMedAuxM)
				EndIf

				nPosPd := aScan( aDif_Fer, { |x| x[1] == cCodMedFMs } )
				If nPosPd > 0
					fGeraVerba(cCodMedFMs, aDif_Fer[nPosPd, 2] + nMedAuxMS)
				EndIf

				nPosPd := aScan( aDif_Fer, { |x| x[1] == aCodFol[623,1] } )//Media Valor sobre Abono
				If nPosPd > 0
					fGeraVerba(aCodFol[623,1], aDif_Fer[nPosPd, 2] + nMedAuxABM)
				EndIf

				nPosPd := aScan( aDif_Fer, { |x| x[1] == aCodFol[634,1] } )//Media valor sobre Abono Mes seguinte
				If nPosPd > 0
					fGeraVerba(aCodFol[634,1], aDif_Fer[nPosPd, 2] + nMedAuxABMS)
				EndIf
			Else
				nMediaOut	:=  Max(nMediaOut,( nMedVlDis / (SRH->RH_DFERIAS + SRH->RH_DABONPE) * IF(lDiasVenc, GetMemVar("RH_DFERVEN"), 30) ))
			EndIf
		EndIf

		If nMediaHrs > 0 .Or. nMedHrDis > 0
			If PosSrv(aCodFol[082,1], xFilial("SRV", SRA->RA_FILIAL), "RV_COMPL_") != "S" .Or. nMediaHrs < nMedHrDis

				If Type( "nDfMedHr" ) != "U"
					nMedAuxM    := ROUND( ( nDfMedHr / If(lMedFer,nFerVen,30)) * NDIASFM, 2)
					nMedAuxMS   := ROUND( ( nDfMedHr / If(lMedFer,nFerVen,30)) * NDIASFMS, 2)
					nMedAuxABM  := ROUND( ( nDfMedHA / If(lMedFer,nFerVen,30)) * NDIASFM, 2)
					nMedAuxABMS := ROUND( ( nDfMedHA / If(lMedFer,nFerVen,30)) * NDIASFMS, 2)
				EndIf

				nPosPd := aScan( aDif_Fer, { |x| x[1] == aCodFol[082,1] } )//Medias s/ Horas Extras Mes
				If nPosPd > 0
					fGeraVerba(aCodFol[082,1], aDif_Fer[nPosPd, 2] + nMedAuxM)
				EndIf

				nPosPd := aScan( aDif_Fer, { |x| x[1] == aCodFol[083,1] } )//Medias s/ Horas Mes Seguinte
				If nPosPd > 0
					fGeraVerba(aCodFol[083,1], aDif_Fer[nPosPd, 2] + nMedAuxMS)
				EndIf

				nPosPd := aScan( aDif_Fer, { |x| x[1] == aCodFol[622,1] } )//Media Horas sobre Abono
				If nPosPd > 0
					fGeraVerba(aCodFol[622,1], aDif_Fer[nPosPd, 2] + nMedAuxABM)
				EndIf

				nPosPd := aScan( aDif_Fer, { |x| x[1] == aCodFol[633,1] } )//Media Horas sobre Abono Mes seguinte
				If nPosPd > 0
					fGeraVerba(aCodFol[633,1], aDif_Fer[nPosPd, 2] + nMedAuxABMS)
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fVerAntec ³ Autor ³ Mauro Sergio - RH     ³ Data ³ 20/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verificar se ja existe 13o nos valores variaveis            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fVerAntec()

Local lRet := .T.

dbSelectArea("SRC")

If M->RH_PERC13S > 0 .And. dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+aCodFol[22,1])
	Help(" ","1","GPM30ANT13")
	lRet := .F.
EndIf

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fDiasDobra³ Autor ³ Mauro Sergio - RH     ³ Data ³ 22/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se deve pagar Dias Ferias Dobradas                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fDiasDobra( nDDobra, nDiasAbo, lIsGPEM030, nDiasFerC, dDtBaseCal, dDtMinCal, dDtMaxCal, nTotDDobra, aFaltasPer, nDFerAnt, dDtDemiss, nDiasAvP )
Local aArea			:= {}
Local aAfast		:= {}
Local cCodAfa		:= ""
Local dBkpPerAq		:= CtoD("//")
Local dDtDobra		:= CtoD("")
Local dIniPeriodo	:= CtoD("")
Local dFimPeriodo	:= CtoD("")
Local dDtAux2		:= CtoD("")
Local dDataLimite	:= CtoD("")
Local dDtIniPen		:= SRF->RF_IVENPEN	//Inicio do periodo aquisitivo de ferias pendente
Local dDtFimPen		:= SRF->RF_FVENPEN	//Fim do periodo aquisitivo de ferias pendente
Local dIniFer		:= CtoD("")
Local lMudaPer		:= .F.
Local lNFerDob		:= .F.
Local lAquisitivo	:= .T.
Local lFerPend		:= ( SRF->RF_DVENPEN > 0 .And. !Empty(SRF->RF_IVENPEN) .And. !Empty(SRF->RF_FVENPEN) )
Local lSusPConc     := GetMvRH('MV_SUSPCON',NIL,.T.)    // Suspende o periodo concessivo por tempo igual ao afastado ocorrido no periodo concessivo sem perda do mesmo.
Local nAvosAf  		:= 0
Local nDiasAf 		:= 0
Local nTotDFer 		:= 0
Local nNroPer		:= 0
Local nDt			:= 0
Local nData			:= 0
Local nDiasAux 		:= 0
Local nQtdPer		:= 0
Local nPeriodo		:= 0
Local nPosFalta		:= 0
Local nDiasFal		:= 0
Local nPosAfas		:= 0
Local nPosConAf		:= 0
Local nPosPer		:= 0
Local nPosUltAf		:= 0
Local nQtDiasOP		:= 0
Local nDFerPen 		:= SRF->RF_DVENPEN

Local bCondFer		:= { || If( lFerPend, If( nPeriodo == 2, "1", Alltrim( Str( nPeriodo + 2 ) ) ), If( nPeriodo == 1, "1", Alltrim( Str( nPeriodo + 3 ) ) ) )}

DEFAULT lIsGPEM030	:= .T.				//Chamada pelo calculo de ferias
DEFAULT nDiasFerC	:= ROUND(M->RH_DFERIAS,2)	//Dias de ferias vencidas
DEFAULT dDtBaseCal	:= M->RH_DATABAS	//Data base inicial do periodo aquisitivo
DEFAULT dDtMinCal	:= M->RH_DATAINI	//Data de referencia para calculo do dobro [1]
DEFAULT dDtMaxCal	:= M->RH_DATAFIM - (M->RH_DIALREM + M->RH_DIALRE1)	//Data de referencia para calculo do dobro [2]
DEFAULT aFaltasPer	:= {}
DEFAULT nDFerAnt	:= 0
DEFAULT dDtDemiss	:= dDtMinCal
DEFAULT nDiasAvP	:= nDiasAvP
DEFAULT cAboAnt     := If(GetMvRH("MV_ABOPEC") == "S", "1", "2") //-- Abono antes ferias

dIniFer		:= Iif(lIsGPEM030,GetMemVar("RH_DATAINI"),dDataDem)
dBkpPerAq	:= dDtBaseCal

Iif( lIsGPEM030, nQtdPer := 1, nQtdPer := Int( ( nDiasFerC - nDFerPen ) / aTabFer[ 3 ] ) + ;
Iif( Mod( ( nDiasFerC - nDFerPen ), aTabFer[ 3 ] ) == 0, 0, 1 ) + Iif( lFerPend, 1, 0 ))

P_LDOBRES	:= If( Type("P_LDOBRES") == "U", .T. , P_LDOBRES)

aPerDobra := {}

nDiasAbo := If(nDiasAbo == Nil, M->RH_DABONPE, nDiasAbo)
nTotDFer := nDiasFerC + nDiasAbo

For nPeriodo := 1 To nQtdPer
	//Calculo da data base de ferias por periodo nos casos em que nao houve modificacao do periodo
	//aquisitivo por motivo de afastamento
	If !lIsGPEM030
		If !lMudaPer .and. lFerPend .And. nPeriodo == 2
			dDtBaseCal := ( dDtFimPen + 1 )
		EndIf
		lAquisitivo := .T.
	EndIf

	If cPaisLoc <> "PAR"
		nNroPer     := 0
		dFimPeriodo := dDtBaseCal - 1 //Subtrai para utilizacao no While

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	  	//³ Avaliar ate que encontre dois periodos validos(nao perdidos) ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lFerPend .And. dDtBaseCal == dDtIniPen
			dDtAux  := dDtFimPen
			dDtAux1 := dDtIniPen
		Else
			dDtAux  := fCalcFimAq( dFimPeriodo + 1 )
			dDtAux1 := dFimPeriodo + 1
		EndIf
		dDataLimite := fCalcFimAq(dDtAux+1)
		While nNroPer < 2

			dIniPeriodo := dFimPeriodo + 1
			If ( lFerPend .And. dIniPeriodo == dDtIniPen, dFimPeriodo := dDtFimPen, dFimPeriodo := fCalcFimAq( dIniPeriodo ) )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		   	//³ Busca dias de afastamento do Periodo(O-Acidente,P-Doenca). Se|
		   	//³ afastado por mais de 180 dias nao conta p/ Pgto Ferias Dobro |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nAvosAf := nDiasAf := nQtDiasOP := 0
			aAfast	:= {}

			//Nao retorna os afastamentos para periodo aquisitivo pendente
			If !lFerPend .Or. If( nPeriodo == 1, nNroPer > 0, .T. )
				fRetAfas(dIniPeriodo,If( nNroPer == 1 , dIniFer, dFimPeriodo ),"F",@nAvosAf,@nDiasAf,,@aAfast,,,,,,,,,,.F.)
				If Len( aAfast ) > 0
					For	nPosAfas := 1 To Len( aAfast )
						If aAfast[nPosAfas,16] $ "O1*P1"
							nQtDiasOP += aAfast[ nPosAfas, 2 ] //Qtde. de dias de afastamento no periodo
						EndIf
					Next nPosAfas
				EndIf
			EndIf

			If  lSusPConc .Or. nQtDiasOP <= 180
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Somar os dias que o funcion. ficou afastado no ultimo periodo³
				//³ ao fim do ultimo periodo evitando o pagamento em dobro.	     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nDiasAux += nDiasAf

				//Se a data limite cair em novo afastamento calculamos a data auxiliar como sendo
				//o fim do afastamento em questao
				nPosUltAf := aScan( aAfast, { | x | ( x[ 3 ] <= dDataLimite .And. dDataLimite <= x[ 4 ] ) } )

				//Data limite igual a data de retorno do afastamento localizado
				If nPosUltAf > 0
					cCodAfa	:= aAfast[ nPosUltAf, 7 ]
					If ( nPosConAf := aScan( aAfast, { |x| x[8] == cCodAfa } ) ) > 0
				   		dDtAux	:= aAfast[ nPosConAf, 4 ]
					Else
						dDtAux  := aAfast[ nPosUltAf, 4 ]
					EndIf
				EndIf

				//Calculo da data base do periodo aquisitivo utilizada no calculo da rescisao, onde sao
				//apurados todos os periodos aquisitivos
				If lAquisitivo
					dDtBaseCal := dFimPeriodo + 1 + nDiasAux
				EndIf
			Else
				//Na perda do periodo aquisitivo/concessivo a data limite eh o retorno do afastamento que
				//ocasionou a perda do periodo mais os dias de afastamento do periodo original
				dFimPeriodo := dDtAux := aAfast[ nPosAfas-1, 4 ]

				//Calculo da data base do periodo aquisitivo utilizada no calculo da rescisao, onde sao
				//apurados todos os periodos aquisitivos
				If lAquisitivo
					dDtBaseCal := dFimPeriodo + 1
				EndIf
			EndIf

			//Identificacao da mudanca do periodo aquisitivo em virtude de afastamento
			If lAquisitivo .And. nDiasAf > 0
				lMudaPer := .T.
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se o total de dias afast. dentro do periodo aquisitivo for   ³
			//³ > 180 dias, entao perde o periodo                     	     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nNroPer ++
			lAquisitivo := .F.
		EndDo

		//-- Se nao perdeu periodo, soma dias de afastamento no final do periodo
		If lSusPConc
			If Type("aPerFerias") != "U" .And. ( nPosPer := aScan( aPerFerias, { |x| x[1] == dBkpPerAq } ) ) > 0 .And. Len(aPerFerias) >= (nPosPer+1) .And. ( aPerFerias[nPosPer+1, 1] - aPerFerias[nPosPer, 2] ) > 1
				dDtDobra := If(lIsGPEM030 .or. ( aPerFerias[nPosPer+1, 1] -  aPerFerias[nPosPer+1, 5] - aPerFerias[nPosPer, 2] ) > 1 , aPerFerias[nPosPer+1, 2], If( dDataLimite >= dDtAux, dDataLimite + nDiasAux, dDtAux + nDiasAux ))
			Else
				dDtDobra := If( dDataLimite >= dDtAux, dDataLimite + nDiasAux, dDtAux + nDiasAux )
			EndIf
		Else
			// Se nao suspende o periodo concessivo em decorrencia do afastamento
			// nao prorroga a data limite para o estabelecimento do pagamento em dobro
			dDtDobra := dDataLimite
		EndIf

	Else
		If (Type("dDtAux") == "U",dDtAux := cTod("//"),dDtAux)
		If (Type("dDtAux1") == "U",dDtAux1 := cTod("//"),dDtAux1)
		If Month(dDtBaseCal) <= 6
			dDtDobra := CtOD(Subs(Dtoc(dDtBaseCal),1,3)+STRZERO(Month(dDtBaseCal)+6,2)+'/'+StrZero(Year(dDtBaseCal)+1,4) ) - 1
		Else
			dDtDobra := CtOD(Subs(Dtoc(dDtBaseCal),1,3)+STRZERO(Month(dDtBaseCal)-6,2)+'/'+StrZero(Year(dDtBaseCal)+2,4) ) - 1
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³  Calcula Dias de Ferias em dobro;                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( Type("M->RH_ABOPEC") # "U" .And. !Empty( M->RH_ABOPEC ) )
		cAboPec := M->RH_ABOPEC
	ElseIf Type("M->RH_ABOPEC") # "U"
		cAboPec := cAboAnt 				//-- cAboPec = 1 -> considera abono antes do periodo de gozo de ferias
	EndIf

	nDDobra  := 0

	cMat	:= SRA->RA_MAT
	dDtAux2	:= dDtAux + 1

	While nDt == 0
		IF DateWorkDay( dDtAux , dDtAux2 , .F. , .F. , .F. ) > 0
			nDt:= 1
			nData:= 1
		Else
			nData ++
			dDtAux2 ++
		EndIf
	EndDo

	aArea := GetArea()
	dbSelectArea('SR8')
	dbSetOrder(1)
		If dbSeek(xFilial('SR8')+ cMat + DtoS(dDtAux+nData)+'1')
	         If ((dDataDem1 - SR8->R8_DATAFIM) < 30)
	         	lNFerDob := .T.
	         EndIf
	 	EndIf
	RestArea(aArea)

	If lNFerDob .And. dDtMinCal > dDtDobra
		nDDobra := 0
	ElseIf dDtMinCal > dDtDobra
		If ndiasAbo > 0	.and. cAboPec == "1" 										//--  Considera Abono Pecuniario antes da Dt Inicial de Ferias
			//-- Verifica se Abono eh antes ou depois da dt inicial de ferias
			If (dDtMinCal - ndiasAbo)  <= dDtDobra
				nDDobra	:= ( dDtMinCal - dDtDobra ) + nDiasFerC  - 1				//-- Total de Dias de Ferias em dobro
			Else
				nDDobra	:=  nTotDFer												//-- Total de Dias de Ferias em dobro sera o total de dias de direito de ferias
			EndIf
		ElseIf !lIsGPEM030
			If dDtDemiss < dDtDobra .And. nDiasAvP > 0
				nDDobra := Min( Iif( lFerPend .And. nPeriodo == 1, nDFerPen, aTabFer[3] - nDFerAnt), ( dDtMaxCal + Iif( P_LDOBRES, Iif( lFerPend .And. nPeriodo == 1, nDFerPen, aTabFer[3] - nDFerAnt ), 0 ) - dDtDobra ) )
			Else
				nDDobra := If( lFerPend .And. nPeriodo == 1, nDFerPen, aTabFer[ 3 ] )
			EndIf
		Else
			nDDobra := nTotDFer
		EndIf
	Else    																		//--Dt Inicial menor ou igual a dtDobra
		If nDiasAbo > 0 .and. cAboPec == "1"
			ndDobra	:= If( dDtMaxCal > dDtDobra, ( dDtMaxCal - dDtDobra ),0 )
		ElseIf !lIsGPEM030
			If dDtMinCal <= dDtDobra .and. dDtMaxCal +  If( P_LDOBRES, If( lFerPend .And. nPeriodo == 1, nDFerPen, aTabFer[ 3 ] - nDFerAnt ), 0 ) >= dDtDobra
				nDDobra := ( dDtMaxCal + If( P_LDOBRES, If( lFerPend .And. nPeriodo == 1, nDFerPen, aTabFer[ 3 ] ), 0 ) - dDtDobra )
			EndIf
		Else
			If dDtMinCal <= dDtDobra .and. dDtMaxCal + nDiasAbo >= dDtDobra
				nDDobra := ( dDtMaxCal + nDiasAbo ) - dDtDobra
			EndIf
		EndIf
	EndIf

	If !lIsGPEM030
		If Len( aFaltasPer ) > 0 .And. ( ( nPosFalta := aScan( aFaltasPer,{ |x| ( x[ 1 ] == Eval( bCondFer ) ) } ) ) > 0 )
			//Dias de falta do periodo proporcional aos dias em dobro para abatimento nas ferias em dobro
			nDiasFal := aFaltasPer[ nPosFalta, 2 ] * nDDobra / 30
		EndIf

		//Abate dias de ferias antecipadas ou gozadas dentro do mes
		If !(dDtDemiss < dDtDobra .And. nDiasAvP > 0)
			If ( lFerPend .And. nPeriodo == 2) .or. ( !lFerPend .And. nPeriodo == 1 )
				nDDobra := Max( nDDobra - nDFerAnt, 0 )
			EndIf
		EndIf

       	If Type("aPerDobra") != "U" .and. nDDobra > 0
       		aAdd(aPerDobra, {dDtAux1, dDtAux, Max( ( nDDobra - nDiasFal ), 0 ), nPeriodo, 0})
       	EndIf

   		nTotDDobra += Max( ( nDDobra - nDiasFal ), 0 )
	EndIf
Next nPeriodo

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se nDDobra resultar ".05",indica que o resultado esta correto|
//³ e nao deve apurar a parte de fracao (Problema no Protheus).  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nDDobra == Int(nDDobra)
	nDDobra -= (nTotDFer - Int(nTotDFer))
EndIf

//Limita em 30 dias de ferias em dobro por periodo(calculo de ferias-GPEM030)
If( lIsGPEM030, nDDobra := If( nDDobra > aTabFer[ 3 ], aTabFer[ 3 ], nDDobra), )

Return( Nil )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fPOutFer ³ Autor ³ Mauro Sergio - RH     ³ Data ³ 28/10/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se Houve Pagamento de Ferias na Mesma data da Atual³±±
±±³          ³se houver gerar verba p/somar a Base de Ir/INSS das Atuais. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fPOutFer(lInss,lTrunca,nDFerOut)
Local nBaseFerAnt := 0.00
Local nDescFerAnt := 0.00
Local nPos 		  := 0.00
Local nDedAnt     := nDedAtu := nDedMSeg    := 0
Local nBsInssOut  := nBsInssAtu := 0
Local nCont		  := 0
Local nDedFerInss := 0
Local nDedInss	  := 0
Local dDtBusFer,  dPerBusca
Local dDtPer
Local cIdBseCalc, cIdDesCalc
Local cIdBseGera, cIdDesGera
Local cCpoArqBus, cCpoMemBus
Local cTribIR 	  := ""
Local cIdDedFer   := ""
Local cIdDesFer	  := ""
Local cIdDedFeMs  := ""
Local lGerou 	  := .F.
Local lVerMultv	  := .F.
Local aAreaSRH	  := SRH->( GetArea() )

DEFAULT lInss     := .F.
DEFAULT lTrunca   := .T.
DEFAULT lTribIR   := SRR->( ColumnPos( 'RR_TRIBIR' ) ) > 0
DEFAULT nDFerOut  := 0


If lInss
	cIdBseCalc := aCodFol[013,1]  //Identificador de base de INSS calculado
	cIdDesCalc := aCodFol[065,1]  //Identificador de desconto de INSS calculado
	cIdBseGera := aCodFol[396,1]  //Identificador de base de INSS a ser gerado
	cIdDesGera := aCodFol[397,1]  //Identificador de desconto de INSS a ser gerado
	cCpoArqBus := &( "{ || SubStr(Dtos( SRH->RH_DATAINI ), 1, 6 ) }" )
	cCpoMemBus := MesAno( M->RH_DATAINI )
Else
	cIdBseCalc := aCodFol[016,1]  //Identificador de base de IR calculado
	cIdDesCalc := aCodFol[067,1]  //Identificador de desconto de IR calculado
	cIdBseGera := aCodFol[236,1]  //Identificador de base de IR a ser gerado
	cIdDesGera := aCodFol[237,1]  //Identificador de desconto de IR a ser gerado
	cIdDedFer  := aCodFol[065,1]  //Identificador de desconto de INSS calculado 
	cIdDedFeMs := aCodFol[232,1]  //Identificador de desconto de INSS calculado mes seguinte
	cIdDesFer  := aCodFol[397,1]  //Identificador de desconto de INSS a ser gerado para cálculo completo do IR
	cCpoArqBus := &( "{ || SubStr(Dtos( SRH->RH_DTRECIB ), 1, 6 ) }" )
	cCpoMemBus := MesAno( M->RH_DTRECIB )
EndIf

If Empty(dDtBasFer)
	If Type("aPerFerias") != "U"
		If (nPos := aScan(aPerFerias, { |X| X[8] == "1" })) > 0
			dDtPer := aPerFerias[nPos][1]
		Else
			dDtPer := SRA->RA_ADMISSA
		EndIf
	Else
		dDtPer := SRA->RA_ADMISSA
	EndIf
Else
	dDtPer := dDtBasFer
EndIf

dbSelectArea("SRH")
dPerBusca := Ctod(Subs(Dtoc(dDtPer),1,6)+StrZero(Year(dDtPer)-1,4), "DDMMYY")
If !IsInCallStack("U_CalcMVProcessa") .Or. !lInss
	DbSeek(SRA->RA_FILIAL+SRA->RA_MAT+Dtos(dPerBusca),.T.)
	While ! Eof() .And. SRH->RH_FILIAL+SRH->RH_MAT == SRA->RA_FILIAL+SRA->RA_MAT
		If Eval(cCpoArqBus) == cCpoMemBus
			dDtBusFer := fDtBusFer() // Busca RH_DTRECIB ou RH_DTITENS
			dbSelectArea("SRR")
			dbSetOrder(RetOrdem("SRR","RR_FILIAL+RR_MAT+DTOS(RR_DATAPAG)+RR_PD"))
			If dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + DTOS(dDtBusFer)+ cIdBseCalc ) .And. SRR->RR_TIPO3 == 'F'
		    	nBaseFerAnt += SRR->RR_VALOR
				If !lInss .and. lTribIR
					cTribIR := SRR->RR_TRIBIR
				EndIf
		    EndIf
			If dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + DTOS(dDtBusFer)+ cIdDesCalc ) .And. SRR->RR_TIPO3 == 'F'
		    	nDescFerAnt += SRR->RR_VALOR
		    EndIf
			If dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + DTOS(dDtBusFer)+ aCodFol[72,1] ) .And. SRR->RR_TIPO3 == 'F'
		    	nDFerOut += SRR->RR_HORAS
		    EndIf
			If !lInss .And. lTribIR .And. !lDissidio .And. aScan(aPd,{ |X| X[1] == aCodFol[397,1] .And. X[9] # "D" }) == 0 .And. dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + DTOS(dDtBusFer)+ cIdDedFer ) .And. SRR->RR_TIPO3 == 'F'  
		    	nDedFerInss += SRR->RR_VALOR
		    EndIf
			If !lInss .And. lTribIR .And. !lDissidio .And. aScan(aPd,{ |X| X[1] == aCodFol[232,1] .And. X[9] # "D" }) == 0 .And. dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + DTOS(dDtBusFer)+ cIdDedFeMs) .And. SRR->RR_TIPO3 == 'F'  
		    	nDedFerInss += SRR->RR_VALOR
		    EndIf
		EndIf
		dbSelectArea("SRH")
	    dbSkip()
	EndDo
Else
	DbSeek(SRA->RA_FILIAL+SRA->RA_MAT+Dtos(dPerBusca),.T.)
	While ! Eof() .And. SRH->RH_FILIAL+SRH->RH_MAT == SRA->RA_FILIAL+SRA->RA_MAT
		If Eval(cCpoArqBus) == cCpoMemBus
			dDtBusFer := fDtBusFer() // Busca RH_DTRECIB ou RH_DTITENS
			dbSelectArea("SRR")
			dbSetOrder(RetOrdem("SRR","RR_FILIAL+RR_MAT+DTOS(RR_DATAPAG)+RR_PD"))
			If dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + DTOS(dDtBusFer)+ cIdDesCalc ) .And. SRR->RR_TIPO3 == 'F'
		    	lVerMultv := .T.
		    EndIf
		EndIf
		dbSelectArea("SRH")
	    dbSkip()
	EndDo

	If lVerMultv
		aEval( aPd, { |x| x[1] $ cIdBseGera+cIdDesGera, x[9] := "D", Nil } )
		For nCont := 1 to Len(aCPFAll)
			DbSeek(aCPFAll[nCont, 2]+aCPFAll[nCont, 3]+Dtos(dPerBusca),.T.)
			While ! Eof() .And. SRH->RH_FILIAL+SRH->RH_MAT == aCPFAll[nCont, 2]+aCPFAll[nCont, 3]
				If Eval(cCpoArqBus) == cCpoMemBus
					dDtBusFer := fDtBusFer() // Busca RH_DTRECIB ou RH_DTITENS
					dbSelectArea("SRR")
					dbSetOrder(RetOrdem("SRR","RR_FILIAL+RR_MAT+DTOS(RR_DATAPAG)+RR_PD"))
					If dbSeek( aCPFAll[nCont, 2]+aCPFAll[nCont, 3] + DTOS(dDtBusFer)+ cIdBseCalc ) .And. SRR->RR_TIPO3 == 'F'
				    	nBaseFerAnt += SRR->RR_VALOR
				    EndIf
					If dbSeek( aCPFAll[nCont, 2]+aCPFAll[nCont, 3] + DTOS(dDtBusFer)+ cIdDesCalc ) .And. SRR->RR_TIPO3 == 'F'
				    	nDescFerAnt += SRR->RR_VALOR
				    EndIf
					If dbSeek( aCPFAll[nCont, 2]+aCPFAll[nCont, 3] + DTOS(dDtBusFer)+ aCodFol[72,1] ) .And. SRR->RR_TIPO3 == 'F'
				    	nDFerOut += SRR->RR_HORAS
				    EndIf
				EndIf
				dbSelectArea("SRH")
			    dbSkip()
			EndDo
		Next nCont
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gerar Base e Desconto (INSS ou IR)das ferias pagas em periodo|
//³ anterior, para ser utilizado no calculo das ferias atuais.	 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nBaseFerAnt > 0 .And. cIdBseGera # Space(3)
	FMatriz(cIdBseGera, nBaseFerAnt,,,,,,,,,,,,,,,,,,,,,,,,,,,,Iif(!lInss .and. lTribIR, cTribIR, "") )
	lGerou := .T.
EndIf
If nDescFerAnt > 0 .And. cIdDesGera # Space(3)
	FMatriz(cIdDesGera, nDescFerAnt,,,,,,,,,,,,,,,,,,,,,,,,,,,,Iif(!lInss .and. lTribIR, cTribIR, "") )
    lGerou := .T.
EndIf
If nDedFerInss > 0 .And. cIdDesFer # Space(3)
	FMatriz(cIdDesFer, nDedFerInss,,,,,,,,,,,,,,,,,,,,,,,,,,,,Iif(!lInss .And. lTribIR, cTribIR, "") )
    lGerou := .T.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a Base e o Desconto do INSS das ferias pagas em	 |
//³ periodo anterior, foi informado ou gerado no movimento.		 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aScan(aPd,{|X| x[1] == aCodFol[396,1] .and. x[9] <> "D"}) > 0
	lGerou	:= .T.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Chama a funcao para recalcular o Inss para Deducao do IR	 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lINSS .And. lGerou
	nBsInssOut := fBuscaPd(aCodFol[396, 1])
	nDedInss   := fBuscaPd(aCodFol[397, 1])

	If cInssFm == "R"
		aEval( aPd, { |X| SomaInc(X, 35, @nBsInssAtu, Nil, Nil, Nil, Nil, Nil, Nil ,aCodFol) } )
	Else
		nBsInssAtu := fBuscaPd( aCodFol[013,1] )
		If (nPos := aScan(aPd,{|X| x[1] == aCodFol[232,1] .and. x[9] <> "D"})) > 0
			nDedMSeg := aPd[nPos, 5]
		EndIf
	EndIf
	If nDedInss > 0 .And. nBsInssOut > 0
		nDedAnt := nDedInss
	Else
		Calc_Inss(aTInss,nBsInssOut,,@nDedAnt,,,,,lTrunca) //Deducao Anterior
	EndIf
	Calc_Inss(aTInss,nBsInssOut+nBsInssAtu,,@nDedAtu,,,,,lTrunca) //Deducao Atual
	If ((nDedAtu+nDedMSeg)-nDedAnt) > 0
	    FMatriz(aCodfol[168,1],((nDedAtu+nDedMSeg)-nDedAnt),,,,,,,,,.T.)
	Else
		fDelPd( aCodfol[168,1] )
	EndIf
EndIf

RestArea( aAreaSRH )

Return( lGerou )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fferCal  ³ Autor ³ Mauro Sergio - RH     ³ Data ³ 28/10/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se Houve Pagamento de Ferias do periodo atual e    ³±±
±±³          ³soma os dias para pagar saldo ou troca p/ novo periodo se   ³±±
±±³          ³periodo atual j  foi calculado pelo total de dias.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Gpem030                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fFerCal(nOpc, dDtBasFer, nDAntPer, cPerFeAc, dNDataBas, lHelp, nFaltasAcum)
Local aArea		:= GetArea()
Local cPerAux   := ""
Local lRet      := .T.
Local lSubPag	:= .T.
Local nRecSRH   := 0
Local _ndiasFER := 0
Local _nFaltas	:= 0

DEFAULT lHelp 		:= .T.
DEFAULT nFaltasAcum := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Visualizacao ou Exclusao mostrar as ferias selecionadas	     |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nDferV    := 0
nDFerP    := 0

fGetLastPer( @cPerAux, , cProcesso, cRot , .T., .F. )

//-- Verifica se Ferias ja Foi Calculada Na Opcao de Calculo
dbSelectArea("SRH")
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Verifica se existe o periodo pendente (dias que sobraram das |
//| ferias coletivas concedidas com menos de um ano)             |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aPerFerias[nPosFer][11] > 0 .And. !Empty(aPerFerias[nPosFer][12])
	//-- Verifica se Ferias ja Foi Calculada Na Opcao de Calculo
	dbSelectArea("SRH")
	dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+DtoS(aPerFerias[nPosFer][12]))

	If Eof() .Or. ( !Eof() .And. ( SRH->RH_DFERIAS # aPerFerias[nPosFer][11] .and. SRH->RH_PERIODO >= cPerAux ) )
  		nDVenPen := aPerFerias[nPosFer][11]
		dIVenPen := aPerFerias[nPosFer][12]
		dFVenPen := aPerFerias[nPosFer][13]
	Else
		nRecnoSRH	:= SRH->(RECNO())
		While SRH->(!Eof()) .AND. SRF->RF_FILIAL+SRF->RF_MAT+Dtos(SRF->RF_IVENPEN) == SRH->( RH_FILIAL + RH_MAT + DTOS(RH_DATABAS) )
			If SRH->RH_PERIODO >= cPerAux
				_nFaltas 	+= SRH->RH_DFALTAS
				_ndiasFER	+= SRH->(RH_DFERIAS + RH_DABONPE)
				nRecnoSRH	:= SRH->(RECNO())
			EndIf
		 	SRH->(DBSKIP())
		EndDo

		dbGoTo(nRecnoSRH)

		//Verifica se tem faltas e proprocionaliza quando funcionário tem menos 01 ano
		TabFaltas(@_nFaltas)
		If SRH->RH_DFERVEN < aTabFer[3]
	   		If !lMetadefal .And. !lTempoParc
	       	_nFaltas := ((_nFaltas / 30) * SRH->RH_DFERVEN  )
	      	ElseIf lMetadeFal
				_nFaltas := (( (SRH->RH_DFERVEN / 2) / aTabFer[3]) * SRH->RH_DFERVEN  )
			Else
				_nFaltas := 0
			Endif
		EndIf
		_ndiasFER     += 	_nFaltas

		If  _ndiasFER < SRH->RH_DFERVEN
	       nDVenPen := aPerFerias[nPosFer][11]
	       dIVenPen := aPerFerias[nPosFer][12]
	       dFVenPen := aPerFerias[nPosFer][13]
	    ElseIf _nDiasFer + aPerFerias[nPosFer][14] >= aPerFerias[nPosFer][3] //Período quitado
	    	If Len(aPerFerias) > nPosFer
	    		//--Achar data inicio proximo Periodo de Ferias
				nPosFer ++
				dDtBasFer 	:= aPerFerias[nPosfer][1]
			    dDT1      	:= dDtBasFer	 // dDt1 - Mnemonico Tipo Publico utilizado no GPEXMED
			    n2Dferven  	:= aPerFerias[nPosFer][3]
			    n2Dferave  	:= aPerFerias[nPosFer][4]
	            //--Procura o Proximo periodo para saber se ja existe calculo
				If SRH->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+DtoS(dDtBasFer)))
					If lHelp
						If GetRemoteType() == -1 .or. lWorkFlow						//-- Verifica se origem foi job
							MsgLogGrid( Ap5GetHelp("GPM30PXCAL"), .F. )  //-- Retornar string da funcao Help
						Else
							Help(" ",1,"GPM30PXCAL")
						EndIf
					EndIf
					lRet := .F.
				EndIf
				nDAntPer := 0  // Zerar Antecipadas para novo periodo
			Else
				lRet := .F.
			EndIf
		EndIf
	EndIf
Else
	dbSetOrder(1)
	dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+DtoS(dDtBasFer))
	nQtdSRH := 0
	If !Eof() .And. SRH->RH_FILIAL+SRH->RH_MAT+DtoC(SRH->RH_DATABAS) == SRA->RA_FILIAL+SRA->RA_MAT+DtoC(dDtBasFer) .AND. ;
		IIF( cPaisLoc $ 'ANG|PTG' , SRH->RH_TIPO == '1', .T. )
		lSubPag := .T.
		//-- Somar os Dias do Mesmo Periodo do Srh
		dbSelectArea("SRH")
		While ! Eof() .And.  SRH->RH_FILIAL+SRH->RH_MAT+DtoC(SRH->RH_DATABAS) =  SRA->RA_FILIAL+SRA->RA_MAT+DtoC(dDtBasFer)
			IF !( cPaisLoc $ 'ANG|PTG' ) .OR. ( cPaisLoc $ 'ANG|PTG' .AND. SRH->RH_TIPO == '1' )
				nDAntPer += SRH->RH_DFERIAS+SRH->RH_DABONPE
				nQtdSRH++
				If SRH->RH_PERIODO < cPerAux
					lSubPag := .F.
				EndIf
				nRecSRH := Recno()
			EndIf
			dbSkip()
		Enddo
		If lSubPag
			nDAntPer += aPerFerias[nPosFer][14]
		EndIf
		If nRecSRH > 0
			dbGoTo(nRecSRH)
		EndIf
  	    nDescFal := SRH->RH_DFALTAS
	    TabFaltas(@nDescFal)
		TabFaltas(@nFaltasAcum)
		If nOpc = 2 .And. ( ( nDAntPer+Max(nFaltasAcum, nDescFal) >= Iif(cPerFeAc<>"N",nDiasAux,Min(nDFerV,nDiasAux)) ) .Or. ( !Empty( aPerFerias[nPosFer][12] ) .And. aPerFerias[nPosFer][11] == 0 .And. aPerFerias[nPosFer][14] == aPerFerias[nPosFer][3] ) )

			If nDAntPer+Max(nFaltasAcum, nDescFal) >= Iif(cPerFeAc<>"N",nDiasAux,Min(nDFerV,nDiasAux)) .And. nDAntPer+nDescFal < Iif(cPerFeAc<>"N",nDiasAux,Min(nDFerV,nDiasAux))
				SRF->( dbSetOrder(1) )
				If SRF->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+dToS(dDtBasFer) ) ) .And. SRF->RF_STATUS == "1"
					If SRF->( Reclock("SRF",.F.) )
						SRF->RF_STATUS := "3"
						SRF->( MsUnlock() )
						If !IsBlind()
							Aviso( STR0088, OemToAnsi(STR0160) + DToC(SRF->RF_DATABAS) + " - " + DToC(SRF->RF_DATAFIM) + OemToAnsi(STR0161), { "OK" }, 2) //"Atenção"##"O funcionário perdeu o direito ao restante das férias no período aquisitivo de "##" por ter faltas. O controle de dias de direito foi atualizado."
						Endif
						MkNewPerSRF(SRA->RA_FILIAL, SRA->RA_MAT, fGetCodFol("0072"), SRF->RF_DATAFIM + 1)
						dDataAte 	:= YearSum(SRF->RF_DATAFIM, 1)
						aPerFerias	:=	{}
						Calc_Fer(@aPerFerias,dDataAte,,,,,,.f.)
						If !Empty(aPerFerias)
							dDtBasFer := aPerFerias[1][1]
							nFaltas	  := 0
							nDAntPer  := 0
							Return .T.
						EndIf
					EndIf
				EndIf
			EndIf

			If lHelp
				If GetRemoteType() == -1 .or. lWorkFlow						//-- Verifica se origem foi job
					MsgLogGrid( Ap5GetHelp("GPEM30CAL"), .F. )  //-- Retornar string da funcao Help
				Else
					Help(" ",1,"GPEM30CAL")
				EndIf
			EndIf

			If cPaisloc == "BRA" .And. P_LFERANTEC .And. nPosFer+1 > Len(aPerFerias)
				DbSelectArea("SRF")
				DbSetOrder(2)

				cSeekSRF := SRA->RA_FILIAL + SRA->RA_MAT + fGetCodFol("0072")+Dtos(aPerferias[nPosFer,1])

				If DbSeek(cSeekSRF)
					While SRF->(!Eof() .and. RF_FILIAL + RF_MAT + RF_PD ==  SRA->RA_FILIAL + SRA->RA_MAT + fGetCodFol("0072") )
						If SRF->RF_STATUS $ " 1" .And. SRF->RF_DATABAS > aPerferias[nPosFer,1]
							aAdd(aPerFerias,{	SRF->RF_DATABAS	,;										  		 			// 01 - Inicio Database de Ferias
												If(Empty(SRF->RF_DATAFIM),fCalcFimAq(SRF->RF_DATABAS),SRF->RF_DATAFIM),;  // 02 - Final Database de Ferias
												SRF->RF_DFERVAT	,;															// 03 - Dias de ferias vencidas
												SRF->RF_DFERAAT	,;															// 04 - Dias de ferias a vencer
												0.00			,;															// 05 - Dias totais de afastamento por periodo
												SRF->RF_OBSERVA	,;															// 06 - Descricao do tipo de afastamento do periodo
												CtoD("")		,;															// 07 - Data de original de termino do p.aquisitivo quando houver prorrogacao do mesmo RWX
												If(Empty(SRF->RF_STATUS),"1",SRF->RF_STATUS),;								// 08 - Status do periodo de ferias:  1-Ativo (Vencidos/A vencer)/2-Prescrito (Perdido)/3-Pago
												CtoD("")		,;															// 09 - Data de Inicio do Proximo periodo caso seja um periodo perdido.
												0				,;															// 10 - Quantidade dias de deducao para o direito apurado no periodo
												SRF->RF_DVENPEN ,;     														// 11 - Dias Vencidos Pendentes
												SRF->RF_IVENPEN ,;     														// 12 - Data Inicia Vencido Pendente
												SRF->RF_FVENPEN ,;															// 13 - Data Inicia Vencido Pendente
												SRF->RF_DFERANT ,;     														// 14 - Dias de Ferias Antecipadas
												SRF->RF_DFALVAT ,;     														// 15 - Dias de Faltas Vencidas
												SRF->RF_DFALAAT ,; 				    										// 16 - Dias de Faltas a Vencer
												NIL,;				 				// 17 - Dias de bono vencido
												NIL,; 								// 18 - Dias de bono a Vencer
												0				,;															// 19 - Total de dias de ferias
												0				,;															// 20 - Total de dias de bonificacao
												0				,;															// 21 - Dias de Faltas vencidas bonificacao
												0				,;															// 22 - Dias de ¦Faltas a Vencer bonificacao
												0				,;															// 23 - Dias de ausencia convertidos em ferias
												0				,;      													// 24 - Total de Dias de Ferias do Periodo
												SRF->RF_DIASANT ,;					      									// 25 - Dias Gozados Vencidos
												SRF->RF_DIASANT	,;	    													// 26 - Dias Gozados a Vencer
												0               ,;      													// 27 - Dias Subsid. Vencidos
												0               ,;   														// 28 - Dias Subsid. a Vencer
												0				,; 															// 29 - Dias de Pagto. Minimo na Adm/Dem (cpo. RF_PAGOFER desabilitado 08/2012)
												SRF->( RECNO() ),;															// 30 - Recno do aquivo
												0        ,;					// 31 - Dias pagos em R$ na folha
												SRF->RF_DATAATU	,;
												0                ;                                                  		// 33 - Dias de suspensão do período
												})
							Exit
						EndIf
						SRF->(DbSkip())
					EndDo
				EndIf
			EndIf


			//--Achar data inicio proximo Periodo de Ferias
			If nPosFer+1 <= Len(aPerFerias)
				nPosFer ++
				dDtBasFer 	:=	aPerFerias[nPosfer][1]
			    dDT1      	:= dDtBasFer	 // dDt1 - Mnemonico Tipo Publico utilizado no GPEXMED
			    n2Dferven  	:= aPerFerias[nPosFer][3]
			    n2Dferave  	:= aPerFerias[nPosFer][4]
	            //--Procura o Proximo periodo para saber se ja existe calculo
				If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+DtoS(dDtBasFer))
					If lHelp
						If GetRemoteType() == -1 .or. lWorkFlow						//-- Verifica se origem foi job
							MsgLogGrid( Ap5GetHelp("GPM30PXCAL"), .F. )  //-- Retornar string da funcao Help
						Else
							Help(" ",1,"GPM30PXCAL")
						EndIf
					EndIf
					lRet := .F.
				EndIf
				nDAntPer := 0  // Zerar Antecipadas para novo periodo
			Else
				lRet := .F.
			EndIf
		ElseIf nOpc = 2 .And. nDAntPer < Iif(cPerFeAc != "S", nDiasAux, Min(nDFerV,nDiasAux))
			If lHelp
				If GetRemoteType() == -1 .or. lWorkFlow						//-- Verifica se origem foi job
					MsgLogGrid( Ap5GetHelp("GPM030SDO"), .F. )  //-- Retornar string da funcao Help
				Else
					Aviso(STR0034, STR0111, {STR0001})  //"Aviso"###"Férias do período atual já possui dias calculados, será calculado o saldo do período."###"Confirma"
				EndIf
			EndIf

			dbSelectArea("SRH")
			dbGoBottom()
			dbSkip()
   	   	EndIf
	EndIf
EndIf

SRH->(DbCloseArea())

RestArea(aArea)

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fSeleFer()³ Autor ³ Emerson Rosa de Souza ³ Data ³ 01/10/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Disponibiliza as ferias calculadas para Visual/Exclusao    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fSeleFer(aLbxF,dNDataBas,dNDataIni)
Local aObjCoords	:= {}
Local aAdvSize		:= {}
Local aObjSize		:= {}
Local aInfoAdvSize	:= {}
Local bSet15		:= { || NIL }
Local bSet24		:= { || NIL }
Local cAlias   		:= ALIAS()
Local lOK      		:= .F.
Local nPosLbxF		:= 0
Local oDlg

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta as Dimensoes dos Objetos         					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdvSize	:= MsAdvSize(,.T.,380)
aInfoAdvSize:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. , .T. } )
aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0038 ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL //"Selecione o Periodo de Ferias"

@ aObjSize[1,1] , aObjSize[1,2] LISTBOX oLbxF FIELDS HEADER OemToAnsi(STR0039),; 		//"Inicio Aquisitivo" 6,7
										OemToAnsi(STR0040),;     						//"Fim Aquisitivo"
										OemToAnsi(STR0041),;     						//"Inicio Ferias"
										OemToAnsi(STR0042),;     						//"Fim Ferias"
										OemToAnsi(STR0043),;     						//"Dias Ferias"
										OemToAnsi(STR0044);      						//"Dias Abono"
										FIELDSIZES 45,45,45,45 SIZE aObjSize[1,3] , aObjSize[1,4];
										OF oDlg PIXEL ON DBLCLICK ( lOk := .T., nPosLbxF:=oLbxF:nAt,oDlg:End() )

	oLbxF:SetArray(aLbxF)
	oLbxF:bLine := { || {aLbxF[oLbxF:nAt,1],aLbxF[oLbxF:nAt,2],aLbxF[oLbxF:nAt,3],aLbxF[oLbxF:nAt,4],aLbxF[oLbxF:nAt,5],aLbxF[oLbxF:nAt,6]}}

	bSet15 := {|| lOk := .T., nPosLbxF:=oLbxF:nAt,oDlg:End() }
	bSet24 := {|| oDlg:End() }

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 ) CENTERED

If lOk
	dNDataBas := aLbxF[nPosLbxF,1]
	dNDataIni := aLbxF[nPosLbxF,3]
EndIf

dbSelectArea( cAlias )

Return( lOk )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fGFerSR8()³ Autor ³ Emerson Rosa de Souza ³ Data ³ 30/10/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava afastamento de ferias e licenca remunerada no SR8    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGFerSR8(dDtIniFer, dDtFimFer, nDiasLRem, nDiasLNRem, cMsgTAF, lProgram, lIntFerCol)
Local aPerAfast := {}
Local lRet		:= .T.
Local lAhgora	:= SuperGetMv("MV_RHAHGOR",, .F.) .And. ChkFile("RUM")
Local aErros    := {}
Local cSeq  	:= ""
Local cTipoDia	:= ""
Local cSitRev	:= ""
Local cVerbaFer	:= fGetCodFol("0072", .F.)
Local cVerbaLic	:= fGetCodFol("0103", .F.)
Local cFilRcm	:= FwxFilial("RCM")
Local dIniNovAf	:= CtoD("")
Local dFimNovAf	:= CtoD("")
Local nCnt		:= 0
Local nDias 	:= 0
Local cTafKey	:= ""
Local cVersEnvio := ""

DEFAULT cMsgTAF    := ""
DEFAULT lProgram   := .F.
DEFAULT lIntFerCol := .T.
DEFAULT lIntTAF	   := (GetMv("MV_RHTAF",.T., .F.) == .T. .AND. Val(GetMv('MV_FASESOC',.T.,' ')) >= 1  )
DEFAULT lMiddleware:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )

If lAposInv //Se for férias de aposentado por invalidez, não grava SR8 
	Return .T.
EndIf 

If !lIntFerCol .And. lIntTAF
	lIntTAF := .F.
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta array p/ gravacao do periodo de afastamento das ferias ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("RCM")
dbSetOrder(3)
If dbSeek( cFilRcm + cVerbaFer )

	cTipoDia := RCM->RCM_TIPODI
	If cPaisLoc == "ARG"
		cSitRev  := Iif( RCM->(Type("RCM_SITUAC"))#"U", RCM->RCM_SITUAC, "")
	EndIf
	If cTipoDia == "2" .OR. cPaisLoc == "VEN"
		aPerAfast := {{ cVerbaFer, ;				//-01
						dDtIniFer, ;				//-02
						dDtFimFer, ;				//-03
						RCM->RCM_TIPO, ;			//-04
						(dDtFimFer-dDtIniFer)+1,;	//-05
						RCM->RCM_TIPOAF,;           //-06
						Iif(cPaisLoc == "BRA", RCM->RCM_TPEFD, "")			}}  //-07
	Else
		GpeCalend(,,,,,dDtIniFer,dDtFimFer,@nDias, "D", cCampo,.F.)
		aPerAfast := {{ cVerbaFer, ;		//-01
						dDtIniFer, ;		//-02
						dDtFimFer, ;		//-03
						RCM->RCM_TIPO, ;	//-04
						nDias ,;			//-05
						RCM->RCM_TIPOAF, ;  //-06
						Iif(cPaisLoc == "BRA", RCM->RCM_TPEFD, "") 	}}  //-07
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Abre novo afastamento p/ Licenca Remunerada ou nao Remunerada³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nDiasLRem # Nil .And. nDiasLRem > 0
	dbSelectArea("RCM")
	dbSetOrder(3)
	If dbSeek( cFilRcm + cVerbaLic )
		dIniNovAf := aPerAfast[1,2] + 1
		dFimNovAf := dIniNovAf + nDiasLRem - 1
		Aadd( aPerAfast , { cVerbaLic, ;				//-01
							dIniNovAf, ;				//-02
							dFimNovAf, ;				//-03
							RCM->RCM_TIPO, ;			//-04
							(dFimNovAf-dIniNovAf),; 	//-05
							RCM->RCM_TIPOAF }) 			//-06
	EndIf

ElseIf nDiasLNRem # Nil .And. nDiasLNRem > 0
	dIniNovAf := aPerAfast[1,2] + 1
	dFimNovAf := dIniNovAf + nDiasLNRem - 1
	Aadd( aPerAfast , { cVerbaLic, ;   		//-01
						dIniNovAf, ;   		//-02
						dFimNovAf, ;   		//-03
						"X", ;		   		//-04
						0, ; 		   		//-05
						RCM->RCM_TIPOAF })  //-06
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava os afastamentos de ferias e licenca remunerada		 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
BEGIN TRANSACTION
	dbSelectArea( "SR8" )
	For nCnt := 1 To Len(aPerAfast)
		If SR8->( Type("R8_SEQ") ) # "U" .And. lRet
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Busca a ultima sequencia de afastamento cadastrada para³
			//³gerar a numeracao da proxima.                          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSetOrder(RetOrdem("SR8","R8_FILIAL+R8_MAT+R8_PER+R8_NUMPAGO"))
			dbSeek(SRA->RA_FILIAL+SRA->RA_MAT)
			While SR8->( !EOF()) .AND. SRA->RA_FILIAL+SRA->RA_MAT == SR8->R8_FILIAL+SR8->R8_MAT
				cSeq :=  SR8->R8_SEQ
				SR8->( dbSkip())
			EndDo
			cSeq :=	If( val(cSeq) > 0, strzero(val(cSeq)+1,3),"001")
			dbSetOrder(RetOrdem("SR8","R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPOAFA+STR(R8_DIASEMP)"))
		EndIf

		If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+Dtos(aPerAfast[nCnt,02])+aPerAfast[nCnt,04])
			RecLock("SR8",.F.,.T.)
		Else
			RecLock("SR8",.T.,.T.)
			SR8->R8_FILIAL 	:= SRA->RA_FILIAL
			SR8->R8_MAT   	:= SRA->RA_MAT
			SR8->R8_DATA   	:= dDataBase
			SR8->R8_PROCES	:= SRA->RA_PROCES
			If SR8->( Type("R8_SEQ") ) # "U"
				SR8->R8_SEQ		:= cSeq
			EndIf
		EndIf
		SR8->R8_PD		 := aPerAfast[nCnt,01]
		SR8->R8_DATAINI  := aPerAfast[nCnt,02]
		SR8->R8_DATAFIM  := aPerAfast[nCnt,03]
		SR8->R8_TIPOAFA	 := aPerAfast[nCnt,04]
		SR8->R8_DURACAO	 := aPerAfast[nCnt,05]
		SR8->R8_DPAGAR	 := aPerAfast[nCnt,05]
		SR8->R8_DIASEMP	 := RCM->RCM_DIASEM

		If cPaisLoc =="BRA"
			SR8->R8_TPEFD	 := aPerAfast[nCnt,07]
		EndIf

		SR8->R8_PER      := cPeriodo
		SR8->R8_NUMPAGO  := cSemana

		If cPaisLoc =="ARG"
			If SR8->(Type("R8_SITUAC"))#"U"
				SR8->R8_SITUAC	:= cSitRev
			EndIf
		EndIf

		If cPaisLoc =="BRA"
			If aPerAfast[nCnt,06] == "4"
				SR8->R8_TPEFD := "15" //Gozo de Ferias
			Endif
		EndIf

		SR8->R8_NUMID  := "SR8" + SRA->RA_MAT + aPerAfast[nCnt,01] + DTOS(aPerAfast[nCnt,02])

		If (lIntTAF .Or. lMiddleware) .And. !lProgram .And. ( SR8->(ColumnPos("R8_TAFKI")) > 0 .AND. SR8->(ColumnPos("R8_TAFKF")) > 0)
			cTafKey := Substr(FWUUId(SR8->(R8_FILIAL + R8_MAT + R8_SEQ)), 1, 60)
			SR8->R8_TAFKI	 := cTafKey
			SR8->R8_TAFKF 	 := cTafKey
		Endif

		If FindFunction("fVersEsoc")
			fVersEsoc( "S2230", .F., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio)
		EndIf
		If cVersEnvio >= "9.0.00"
			If ( SR8->(ColumnPos("R8_DTINIF")) > 0 .AND. SR8->(ColumnPos("R8_DTFMF")) > 0)
				SR8->R8_DTINIF	 := M->RH_DATABAS
				SR8->R8_DTFMF 	 := M->RH_DBASEAT
			EndIf
		EndIf

		SR8->(MsUnlock())
		If (lIntTAF .Or. lMiddleware) .And. !lProgram
			lRet:= IntFerTAF(aErros,@cMsgTAF)
			If Funname() $ 'GPEM060/GPEM020A' .And. !lMiddleware
				lRet := .T.
			Endif
		EndIf
		If lAhgora
			fFerAhgora("I")
		EndIf
	Next nCnt
	If !lRet
		DisarmTransaction()
		Break
	EndIf
END TRANSACTION
RCM->(DbSetOrder(1))

Return(lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Fm030Can ºAutor  ³MICROSIGA           º Data ³  30/11/99   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cancelamento de ferias normais/coletivas/programadas        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Generico                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Fm030Can(nRecSRH, lRegNovo)

Local cAlias    := Alias()
Local cFilRcm	:= FwxFilial("RCM")	//#IF (xFilial("RCM") == Space(FWGETTAMFILIAL), Space(FWGETTAMFILIAL), SRA->RA_FILIAL)
Local cTipoAfas := ""
Local dDtBusFer := CtoD("")
Local lTSREP	:= GetMvRH( "MV_TSREP" , NIL , .F. )
Local lAhgora	:= SuperGetMv("MV_RHAHGOR",, .F.) .And. ChkFile("RUM")
Local nDiasSR8  := 0
Local aErros	:= {}
Local lRet		:= .T.
Local cSitFol	:= ""

Private oObjREP   := Nil

DEFAULT lRegNovo    := .T.
DEFAULT lIntegDef 	:= FindFunction("GETROTINTEG") .And. FindFunction("FWHASEAI")
DEFAULT lIntTAF	    := (GetMv("MV_RHTAF",.T., .F.) == .T. .AND. Val(GetMv('MV_FASESOC',.T.,' ')) >= 1  )
DEFAULT lMiddleware := If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )
DEFAULT nRHTAEEX    := GetMvRH( "MV_RHTAEEX",,3 )
DEFAULT lTemREQ     := GetRPORelease() >= "12.1.033" .OR. ( ChkFile("REQ") .and. FindFunction("fDelDocTAE") .and. FindFunction("FwTotvsSign") )
DEFAULT lTemPostUmT := SRH->( ColumnPos( "RH_POSTUMT" ) ) > 0
DEFAULT __lMemCalc  := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc() // Memória de Cálculo

dbSelectArea( "SRH" )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona no registro do SRH caso venha das ferias normais   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nRecSRH # Nil .And. nRecSRH > 0
	dbGoTo(nRecSRH)
	dDtBusFer := SRH->RH_DATAINI
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PcoIniLan("000089")

//-- Inicializa a integracao via WebServices TSA
If lTSREP
	oObjREP := PTSREPOBJ():New()
	SX5->(dbSetOrder(1))
EndIf

Begin Transaction

	If cPaisLoc <> "EQU"
		dbSelectArea("SRR")
		If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT)
			While ! Eof() .And. SRA->RA_FILIAL+SRA->RA_MAT == SRR->RR_FILIAL+SRR->RR_MAT
				If dDtBusFer == SRR->RR_DATA .And. SRR->RR_TIPO3 == "F"
					RecLock("SRR",.F.,.T.)
					SRR->( dbDelete() )
					SRR->( MsUnLock() )
					//Integracao com modulo SIGAPCO
					PcoDetLan("000089","01","GPEM030", .T.)
				EndIf
				SRR->( dbSkip() )
			Enddo
		EndIf
	EndIf

	If !(cPaisLoc == "PTG") // Ajuste Gozo de Ferias Separado para Portugal

		dbSelectArea("RCM")
		dbSetOrder(3)
		If dbSeek( cFilRcm + fGetCodFol( "0072", .F. ) )
			cTipoAfas := RCM->RCM_TIPO
		EndIf

		dbSelectArea("SR8")
		dbSetOrder(RetOrdem("SR8","R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPOAFA+STR(R8_DIASEMP)"))
		If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+Dtos(SRH->RH_DATAINI)+cTipoAfas)

			RecLock("SR8",.F.,.T.)
			SR8->( dbDelete() )
			SR8->( MsUnLock() )
			If (lIntTAF .Or. lMiddleware)
				If !Empty(SR8->R8_TAFKI) .And. !Empty(SR8->R8_TAFKF)
					lRet := IntFerTAF(aErros)
				ElseIf FunName() == "GPEM030"
					Help(,,STR0088,, STR0134,1,0 )//"Atenção"##"Após a alteração ou exclusão do registro efetue a manutenção no TAF : eSocial\Eventos Não periodicos\Afastamentos"
				Else
					lRegNovo := .F.
				EndIf
				If !lRet
					DisarmTransaction()
					Break
				EndIf
			EndIf
			If lAhgora
				fFerAhgora("E")
			EndIf
		EndIf

	Else
		dbSelectArea("RCM")
		dbSetOrder(3)
		If dbSeek( cFilRcm + fGetCodFol( "0786", .F. ) )
			cTipoAfas := RCM->RCM_TIPO
		EndIf

		dbSelectArea("SR8")
		dbSetOrder(RetOrdem("SR8","R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPOAFA+STR(R8_DIASEMP)"))
		If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+Dtos(SRH->RH_DATAINI)+cTipoAfas)

			nDiasSR8 := R8_DURACAO

			RecLock("SR8",.F.,.T.)
			SR8->( dbDelete() )
			SR8->( MsUnLock() )
		EndIf

		/* -- Atualiza registro no SRF -- */
		dbSelectArea("SRF")
		dbSetOrder(RETORDER("SRF","RF_FILIAL, RF_MAT, RF_DATABAS") )
		If SRF->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + Dtos(RH_DATABAS) ))
			RecLock("SRF",.F.)
			SRF->RF_DIASANT -= nDiasSR8
			SRF->(MsUnlock())
		EndIf
	EndIf

	If lTSREP
		If SX5->( dbSeek( xFilial("SX5", SRA->RA_FILIAL) + "31" + "F" ) )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Executa o WebServices TSA - Situacao de Afastamento          ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			oObjREP:WSAbsenceReason( 6 , , If(SRH->RH_DATAINI < SRH->RH_DATABAS, SRH->RH_DATABAS, SRH->RH_DATAINI), , cEmpAnt + SRA->RA_FILIAL + SRA->RA_MAT )
		EndIf
	EndIf

	//Deleta lançamentos da RGB se ja tiverem sido integrados
	fDeleteRGB(SRA->RA_FILIAL, SRA->RA_MAT, SRH->RH_PERIODO, SRH->RH_NPAGTO, SRH->RH_ROTEIR)

	If lTemPostUmT .And. SRH->RH_POSTUMT == "3"
        fExcL14457(nRecSRH)
    EndIf

	If lRet .and. cPaisLoc == "BRA"
		Gp030Estab(.F.,SRH->RH_DATAFIM)
	EndIf

	If __lMemCalc //Exclui informações da memória de cálculo, quando existir
		fDelMemCalc(SRA->RA_FILIAL, SRA->RA_MAT, SRH->RH_PROCES, SRH->RH_PERIODO, SRH->RH_ROTEIR, SRH->RH_NPAGTO)
	EndIf

	dbSelectArea("SRH")
	RecLock("SRH",.F.,.T.)
	SRH->( dbDelete() )
	SRH->( MsUnLock() )

	//Se existir a tabela de gerencimaneto de documento do TAE e o mnemonico estiver ativo, verifica se foi enviado o recibo para assinatura e exclui o documento do TAE
	If lTemREQ .and. nRHTAEEX <> 3
		fDelDocTAE(SRA->RA_FILIAL, SRA->RA_MAT, , "1", dDtBusFer) //Exclui Recibo
		fDelDocTAE(SRA->RA_FILIAL, SRA->RA_MAT, , "2", dDtBusFer) //Exclui Aviso
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Retorna a Atual Situacao do Funcionario                       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cPaisLoc <> "PTG"
		cSitFol	:= SRA->RA_SITFOLH
		RetSituacao()
		If lIntNGRJP .And. cSitFol <> SRA->RA_SITFOLH
			fSendSRAApi("A")
		EndIf
	Else
		dbSelectArea( "SRA" )
		RecLock("SRA",.F.,.T.)
		SRA->RA_SITFOLH := " "
		MsUnlock()
	EndIf

	If lIntegDef
		lExcFerPIMS := .T.
		SetRotInteg("GPEM040")
		FwIntegDef("GPEM040")
	EndIf

End Transaction

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada Cancelamento de Ferias 					 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("GPM030EX")
	EXECBLOCK("GPM030EX",.F.,.F.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Finaliza a gravacao dos lancamentos do SIGAPCO          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PcoFinLan("000089")

dbSelectArea(cAlias)

RCM->(DbSetOrder(1))

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fVerData  ³ Autor ³ Mauro Sergio - RH     ³ Data ³ 15/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Achar Data Valida para pagamento de Ferias e Aviso          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fVerData(dData)

dData := DataValida(dData,.F.)

Return( dData )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fChkDtFer ³ Autor ³ Leandro Drumond       ³ Data ³ 04/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Checar a Data de Ferias do Funcionario 				      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GPEM030                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fChkDtFer( dDataIniFer )

Local aArea 	:= GetArea()
Local lRet		:= .T.

If (SRA->RA_TIPOPGT == "S" .and. dDataIniFer < firstdate(aPeriodo[nPosSem,3]) ) .Or. ( SRA->RA_TIPOPGT <> "S"  .And. dDataIniFer < aPeriodo[nPosSem,3] )
	cMsgData := STR0062 // "Data Inicio das Férias menor que Inicio do Periodo Aberto"
	lRet := .F.
EndIf

If !lRet
   Help(,,STR0088,, cMsgData,1,0 )
EndIf

RestArea(aArea)

Return( lRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o      ³ fMSeqFer   ³ Autor ³ Gisele Varandas        ³ Data ³  20/07/2006  ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o   ³ Monta sequencia de verbas nas férias                              ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe     ³ fMSeqFer()                  						     		  	 ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno     ³ LOGICO                                     				         ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Obs.:       ³ Fórmula baseada na fMontSeqRes do GPEM040   				         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

Function fMSeqFer()

Local aSRRCols		:= ( oGet:aCols )
Local aColsAnt		:= aClone( aSRRCols )
Local aColsCopy		:= aClone( aSRRCols )
Local cNumSeq		:= ""
Local cStrCols 		:= ""
Local cStrCopy		:= ""
Local lRet			:= .T.
Local nX			:= 0
Local nSeq			:= 0
Local nPosOrd		:= 0
Local nPosCc		:= GdFieldPos( "RR_CC" 		)
Local nPosSe		:= GdFieldPos( "RR_SEMANA"	)
Local nPosSq		:= GdFieldPos( "RR_SEQ"		)
Local nPosPd		:= GdFieldPos( "RR_PD"		)
Local nPosDeleted	:= GdFieldPos( "GDDELETED"	)
Local nLenCols		:= Len( aSRRCols )
Local nSvn			:= n
Local cCod			:= aSRRCols[ n , nPosPd ]

cNumSeq		:= PosSrv( aSRRCols[ n , nPosPD ] , SRA->RA_FILIAL, "RV_QTDLANC" )
cStrCols 	:= aSRRCols[ n , nPosPd ] + aSRRCols[ n , nPosCc ] + aSRRCols[ n , nPosSe ]

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³O Numero Minimo de Lancamentos Permitidos e sempre "1"        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
// Se a verba tem a opcao de lancamento diario, nao tratar sequencia.
// So podera ter um lancamento da verba por dia.
cLcto := PosSRV(cCod , cFilial , "RV_LCTODIA" )

// Foi desativado a validacao de Lancamento diario pois nao existe o campo de Data de Referencia
IF ( Empty( cNumSeq ) .or. ( cNumSeq == "1" ) .or. Empty( cCod ) ) //.or. ;
//   ( cLcto == "S" )

	If Val(cNumSeq) <= 1
		If ( cLcto == "S" )
			aCposKey := { "RR_PD" , "RR_DATA"}
		Else
			aCposKey := { "RR_PD" , "RR_CC" , "RR_SEQ", "RR_DATA" }
		EndIf

		IF !( GdCheckKey( aCposKey , 4 ) )
			Return( .F. )
		EndIf
	EndIf

	aSRRCols[n, nPosSq] :=	" "
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica se Existe o Objeto oGet:oBrowse para o Refresh()	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF ( Type("oGet:oBrowse") == "O" )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Compara o Conteudo para verificar se Houve Alteracao          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !ArrayCompare( aColsAnt , aSRRCols )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Repintando o Browse da GetDados							   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			oGet:oBrowse:Refresh()
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Restaura Posicao de n Apos Refresh do Browse da GetDados	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			n := nSvn
		EndIf
	EndIf
	Return( lRet )
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Salva Sequencia inicial de aCols para poder restaura-la na mes³
³ma ordem.                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nX := 1 To nLenCols
	aAdd( aColsCopy[ nX ] , StrZero( nX , 4 ) )
Next nX

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Posicao da Ordem de Entrada								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
nPosOrd := Len( aColsCopy[ nX - 1 ] )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Ordena aColsCopy com as Chaves Respectivas                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aSort( aColsCopy ,,, { |x,y| x[ nPosPd ] + x[ nPosCc ] + x[ nPosSe ] + x[ nPosSq ] < ;
							 y[ nPosPd ] + y[ nPosCc ] + y[ nPosSe ] + y[ nPosSq ]   ;
				 }																 				    ;
	  )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Renumera Sequencia de Lancamentos                             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nX := 1 To nLenCols
	cStrCopy := aColsCopy[ nX , nPosPd ] + aColsCopy[ nX , nPosCc ] + aColsCopy[ nX , nPosSe ]
	IF !( aColsCopy[ nX , nPosDeleted ] )
		IF ( cStrCopy == cStrCols )
			nSeq++
			IF ( lRet := ( nSeq <= Val( cNumSeq ) ) )
				aColsCopy[ nX , nPosSq ] := StrZero( nSeq , aHeader[ nPosSq , 4 ] )
		   	 /*	If ctipo2 $ "K"
	   				Aviso(STR0014,STR0043,{'OK'}) // + CRLF +;
	   		  //	  		  STR0044, {'OK'}) //"Atencao" ##"Verba já existe no movimento, por favor altere o valor da mesma!"###"Se esse novo registro não for excluído, ao confirmar o cálculo substituirá o anterior."
				EndIf  */
			Else
				Help(" ",1,"A090MAXSEQ")
				Return( lRet )
			EndIf
		EndIf
	Else
		aColsCopy[ nX , nPosSq ] := Space( aHeader[ nPosSq , 4 ] )
	EndIf
Next nX

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Restaura Sequencia original de aColsCopy                      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aSort( aColsCopy ,,, { |x,y| x[ nPosOrd  ] < y[ nPosOrd  ] } )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Atualiza a Sequencia de Lancamentos                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nX := 1 To Len( aSRRCols )
	aSRRCols[ nX , nPosSq ] := aColsCopy[ nX , nPosSq ]
Next nX

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se Existe o Objeto oGet:oBrowse para o Refresh()	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF ( Type("oGet:oBrowse") == "O" )
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Compara o Conteudo para verificar se Houve Alteracao          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF !ArrayCompare( aColsAnt , aSRRCols )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Repintando o Browse da GetDados							   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		oGet:oBrowse:Refresh()
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Restaura Posicao de n Apos Refresh do Browse da GetDados	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		n := nSvn
	EndIf
EndIf

Return( lRet )


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gp030ValDiºAutor  ³Tiago Malta         º Data ³  09/02/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³  Função que valida a quantidade de dias antecipados de     º±±
±±º          ³  ferias com a data fim do periodo                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Gp030ValDi()

Local lRet := .F.

	If Empty(M->RH_PERANTE)
		Aviso(STR0034,STR0066,{"OK"})
		Return(.F.)
	EndIf

	RCH->( DbSetOrder(9) )
	If RCH->( DbSeek(xFilial("RCH")+M->RH_PERANTE) )
	    If M->RH_DIASANT <= ( Max(Day(RCH->RCH_DTFIM),30) )
			lRet := .T.
		Else
			Aviso(STR0034,STR0067,{"OK"})
			Return(.F.)
		EndIf
	EndIf

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gp030DtIniºAutor  ³Microsiga           º Data ³  08/18/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Gp030DtIni()

Local aArea	  	:= GetArea()
Local nIndex	:= RCH->(IndexOrd())
Local lRet      := .T.
Local cRotFer   := fGetCalcRot('3')

dbSelectArea("RCH")
DbSetOrder( RetOrder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG" ) )

If RCH->(DbSeek(xFilial("RCH")+cProcesso+cRotFer+M->RH_PERIODO))
	If M->RH_DATAINI > RCH->RCH_DTFIM
		Aviso(STR0034,STR0068,{"OK"})
		lRet := .F.
	ElseIf M->RH_DATAINI < RCH->RCH_DTINI
		Aviso(STR0034,STR0069,{"OK"})
		lRet := .F.
	EndIf
EndIf

DbSetOrder(nIndex)
RestArea(aArea)

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FVerDAbon ºAutor  ³Microsiga           º Data ³  08/09/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FVerDAbon(oModel)
Local lRet		:= .T.
Local cABoPec 	:= If(GetMvRH("MV_ABOPEC")=="S","1","2")

/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
  ³ Nao permite que seja calculada ferias qdo:            	     ³
  ³-Se tiver dias de abono antes do periodo de ferias e a data de³
  ³ inicio das ferias + dias de abono(antes) cair no mes anterior³
  ³ ao das ferias.Neste caso o periodo de abono(antes) deve estar³
  ³ inteiro no mesmo mes das ferias.                             ³
  ³-Se o mes de inicio das ferias for de um mes jah fechado; ou  |
  ³ se os dias de abono cairem em um mes jah fechado             ³
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If !Empty(oModel:GetValue("GPEM030_MSRH","RH_ABOPEC"))
	cAboPec := oModel:GetValue("GPEM030_MSRH","RH_ABOPEC")
EndIf

If cAboPec =="1" .and.  ( MesAno( M->RH_DATAINI - M->RH_DABONPE ) < MesAno(M->RH_DATAINI) .Or.;    // Abono Antes
	cMesAnoRef > MesAno( M->RH_DATAINI - M->RH_DABONPE ) )
	Aviso(OemToAnsi(STR0034), OemToAnsi(STR0079)+oemToAnsi(STR0080)+OemToAnsi(STR0081)+OemToAnsi(STR0082), {OemToAnsi(STR0001)})	 	//"O Abono Pecuniário esta sendo concedido antes do início do gozo de férias.     "
																																		//"Neste caso deve-se informar a data de início de gozo de férias de forma que    "
																																		//"todo o período do abono pecuniário pertença ao mês de início do gozo de férias."
																																		//"Verificar o pârametro MV_ABOPEC alem do campo 'Per.de Abono' ."
	lRet:= .F.
ElseIf cMesAnoRef > MesAno (M->RH_DATAINI)
	Aviso(OemToAnsi(STR0034), OemToAnsi(STR0083)+OemToAnsi(STR0084), {OemToAnsi(STR0001)})												//"O mês para o cálculo de férias selecionado já foi fechado."
																																		//"Por favor, indique uma data válida para o início das férias."
	lRet:= .F.
EndIf

Return(lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fInssFer ³ Autor ³ Equipe - RH     		³ Data ³ 15/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula o INSS das Ferias								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fInssFer(lTrunca)
Local nAliq 	:= 0
Local nAliqBkp 	:= 0
Local nDiasMes  := 0
Local nDiasMse  := 0
Local nInssAux  := 0
Local nDFerOut  := 0
Local nInssOut  := 0
Local nBaseOut  := 0
Local nBaseOutI := 0
Local nInssMSOut  := 0
Local nBaseMSOut  := 0
Local nBaseTeto := 0
Local nTetoInss := 0
Local nUltDFer 	:= F_ULTDIA(M->RH_DATAINI)
Local lInfTeto  := .F.
Local lResExt	:= .F.
Local nId168	:= 0
Local nInssMes	:= 0
Local nInssMS  	:= 0
Local nInssMS1  := 0
Local nInssOM  	:= 0
Local lLimDesc	:= If (cInssFm == "S" .And. Type("P_LIMTET") # "U" .And. P_LIMTET, .T., .F. )
Local aInssFx	:= {}
Local aInssFxMs := {}
Local aPdFx		:= {aCodFol[1738,1], aCodFol[1739,1], aCodFol[1740,1], aCodFol[1741,1]}
Local lImpCalc  := .F.

DEFAULT lTrunca := .T.

lDedInssEx	:= If(Type("lDedInssEx") == "U", .F., lDedInssEx)
lIrResExt	:= If(Type("lIrResExt") == "U", .T., lIrResExt)

If(Len(aTInss) > 0)
	nBaseTeto := aTinss[Len(aTinss), 1]
	nTetoInss := fRetTetIns(aTinss)
Else
	Help( ,, OemToAnsi(STR0088),, OemToAnsi(STR0099), 1, 0 )//"Atenção"##"Tabela de Inss Vazia. Preencher antes de prosseguir."
	Return .F.
EndIf

If cPaisLoc == "BRA"
 	// Para os casos em que o funcionário não é autonomo, pode haver acordo
 	// Entre o Brasil e outros paises, para o não desconto do INSS.
	// Para tratar esses acordos o campo RA_INSSAUT é utilizad.
	// Se estiver com NÃO, NÃO deverá calcular INSS, independente do RA_CATFUNC.
	If SRA->RA_INSSAUT == "N"
		Return
	EndIf
EndIf

aEval( aPd, { |x| nBaseOutI += Iif( x[1] == aCodFol[396,1] .And. x[9] # "D", x[5], 0) } )
lInfTeto := (nBaseTeto == nBaseOutI)

If cPaisLoc = "BRA"
	lResExt := If(SRA->RA_RESEXT=="1",.T.,.F.)
EndIf

If cPaisLoc = "BRA" .And. Type("aTabFer") # "A" .Or. Len(aTabFer) == 0
	fTab_Fer(@aTabFer)
EndIf

//--Achar Dias Referentes a cada Mes para Calc. Inss Separado
If MesAno(M->RH_DATAINI)== MesAno(M->RH_DATAFIM)
	nDiasMes := ( Day(M->RH_DATAFIM) - Day(M->RH_DATAINI) - M->RH_DIALREM ) + 1
	nDiasMse := 0
	If ( nDiasMes + M->RH_DIALREM ) > aTabFer[3]
		nDiasMes := aTabFer[3] - M->RH_DIALREM
	EndIf
Else
	nDiasMes := ( nUltDFer - Day(M->RH_DATAINI) - M->RH_DIALREM ) + 1
	nDiasMse := Day(M->RH_DATAFIM) - M->RH_DIALRE1
EndIf

//-- Calculo do INSS
nInss_b := 0.00
If __lMemCalc
	fAddMemLog("MV_DINSSFM: " + cInssFM + " ("+retX6Desc("MV_DINSSFM")+")", 1, 2)
	fAddMemLog("Verbas com incidência para INSS: ", 1, 2)
EndIf
//-- Soma Incidencia Para Base de INSS
Aeval( aPd ,{ |X| SomaInc(X,35,@nInss_b, , , , , , ,aCodFol,Nil,Nil,Nil,Nil,Nil,Nil,.T.) }) //VERIFICA CAMPO RV_INSSFER AO INVES DE RV_INSS

//--Verifica se Deve Descontar Inss Mes e Mes Seguinte
If (cInssFm== "S" .OR. cInssFm== "R") .And. aCodFol[232,1] # Space(3) .And. nDiasMse > 0
	nInss_b1 := 0
	Aeval( aPd ,{ |X| SomaInc(X,35,@nInss_b1,36,"2", , , , ,aCodFol) })
	nInss_b2 := nInss_b - nInss_b1
Else
	nInss_b1 := nInss_b
	nInss_b2 := 0
Endif
If cInssFm== "R"
	nInssOM := nInssMes := nInssMs := nInss := nInss1 := nBaseAt := nBaseAc := 0.00
	If nInss_b1 > 0.00
		If !lInfTeto
			// Busca Valor do INSS Ferias Outros Periodos
			If !lDissidio .And. fPOutFer(.T.,lTrunca,@nDFerOut) //Gera Identificadores - 396/397 - Base e Valor do INSS
				nBaseOut := nInssOut := 0.00
				Aeval(aPd,{ |X| nBaseOut += If( X[1]==aCodFol[396,1] .And. X[9] # "D" ,X[5] ,0)})
				Aeval(aPd,{ |X| nInssOut += If( X[1]==aCodFol[397,1] .And. X[9] # "D" ,X[5] ,0)})
				Calc_Inss(aTInss,nInss_b+nBaseOut,@nInss,,,,@nAliq,,lTrunca,,@aInssFx)
				nAliqBkp  := nAliq
				nInssOM   := nInss
			EndIf
	    	Calc_Inss(aTInss,nInss_b,@nInss,@nInss1,@nBaseAt,@nBaseAc,@nAliq,,lTrunca,,@aInssFx)
			If nInss_b2 > 0.00
				If nInssOM > 0
					nAliq  := nAliqBkp
					nInss	:= nInssOM
				EndIf
				nInssAux := nInss - nInssOut
				nInssMes := Round(( nInssAux / (M->RH_DFERIAS) * (nDiasFM) ),2)
				nInssMs  := Round(( nInssAux / (M->RH_DFERIAS) * nDiasFMS ),2)
				If __lMemCalc
					fAddMemLog("INSS mês: ("+cValToChar(nInssAux)+" / ("+cValToChar(M->RH_DFERIAS)+" * " +cValToChar(nDiasFM)+")) = "+ AllTrim(Transform(nInssMes, "@E 999,999,999,999.99" )), 1, 2)
					fAddMemLog("INSS mês seguinte: ("+cValToChar(nInssAux)+" / ("+cValToChar(M->RH_DFERIAS)+" * " +cValToChar(nDiasFMS)+")) = "+ AllTrim(Transform(nInssMs, "@E 999,999,999,999.99" )), 1, 2)
				EndIf
				If nInssMes + nInssMs > nTetoInss
					nInssMes := nTetoInss - nInssMs
				EndIf
				nInssMs1 := nInss - nInssMes - nInssMs - nInssOut
			Else
				If nInssOM > 0
					nAliq := nAliqBkp
					nInss := nInssOM - nInssOut
				EndIf
				nInssMes := nInss
			EndIf
			FMatriz(aCodfol[065,1],nInssMes,nAliq)
			If nInssMS > 0
				FMatriz(aCodfol[232,1], IIf(nInssMs1 > 0, nInssMS+nInssMs1, nInssMS) ,nAliq,Nil,Nil,Nil,Nil,Nil,Nil,Nil,Nil,"1")
			EndIf
			
			// Recalcula a deducao total de INSS para IR no mes
			nInss := nInss1 := nBaseAt := nBaseAc := 0.00
			Calc_Inss(aTInss,nInss_b1+nInss_b2,nInss,@nInss1,nBaseAt,nBaseAc,nAliq,,lTrunca, Nil, Nil, Nil, Nil, Nil, lImpCalc)
			If !lResExt .Or. (lDedInssEx .And. lIrResExt)
				FMatriz(aCodfol[168,1],nInss1-nInssOut)
			EndIf		
			If nInss_b2 > 0
				lImpCalc := .T.				
			EndIf			
			// Recalcula para achar a base do mess
			nInss := nInss1 := nBaseAt := nBaseAc := 0.00
			Calc_Inss(aTInss,nInss_b1,nInss,@nInss1,@nBaseAt,@nBaseAc,nAliq,,lTrunca, Nil, Nil, Nil, Nil, Nil, lImpCalc)
			FMatriz(aCodfol[013,1],nBaseAt)
			FMatriz(aCodfol[014,1],nBaseAc)
		Else
			FMatriz(aCodfol[014,1],nInss_b1)
		EndIf
	Endif
Else
	nInss := nInss1 := nBaseAt := nBaseAc := 0.00

	If nInss_b1 > 0.00
	    If !lInfTeto
			Calc_Inss(aTInss,nInss_b1,@nInss,@nInss1,@nBaseAt,@nBaseAc,@nAliq,,lTrunca,,@aInssFx)

			// Busca Valor do INSS Ferias Outros Periodos
			If !lDissidio .And. fPOutFer(.T.,lTrunca) //Gera Identificadores - 396/397 - Base e Valor do INSS
				If !Empty(aCodFol[396,1]) .And. Empty(aCodFol[397,1])
					Help( ,, OemToAnsi(STR0088),, OemToAnsi(STR0150), 1, 0 )//"Atenção"##"É necessário possuir o cadastro da verba de Id 0397 pois houve o cadastro da verba de Id 0396 e há cálculo(s) de férias realizadas no mesmo periodo. Esse passo é necessário para a correta apuração do desconto de INSS"
					FINALCALC()
					Return .F.
				EndIf
				nBaseOut := nInssOut := 0.00
				Aeval(aPd,{ |X| nBaseOut += If( X[1]==aCodFol[396,1] .And. X[9] # "D" ,X[5] ,0)})
				Aeval(aPd,{ |X| nInssOut += If( X[1]==aCodFol[397,1] .And. X[9] # "D" ,X[5] ,0)})
				nTetoInss := fRetTetIns(aTinss)
				Calc_Inss(aTInss,nInss_b1+nBaseOut,@nInss,@nInss1,,,@nAliq,,lTrunca,,@aInssFx)
				nInss     := Max(nInss-nInssOut,0)
				nInss1    := Max(nInss1-nInssOut,0)
			EndIf
			FMatriz(aCodfol[065,1],nInss,nAliq)
			If !lResExt .Or. (lDedInssEx .And. lIrResExt)
				FMatriz(aCodfol[168,1],nInss1)
			EndIf
			FMatriz(aCodfol[013,1],nBaseAt)
			FMatriz(aCodfol[014,1],nBaseAc)
			nInssAux := (nInss1 + nInssOut)
		Else
			FMatriz(aCodfol[014,1],nInss_b1)
		EndIf
	EndIf
	nInss := nInss1 := nBaseAt := nBaseAc := 0.00
	If nInss_b2 > 0.00 .And. cInssFm == "S" .And. ( !lLimDesc .Or. (lLimDesc .And. nInssAux < nTetoInss .And. !lInfTeto) )
	    nBaseMSOut := nInssMSOut := 0.00
		If len(aCodFol) > 1859
			Aeval(aPd,{ |X| nBaseMSOut += If( X[1]==aCodFol[1860,1] .And. X[9] # "D" ,X[5] ,0)})
			Aeval(aPd,{ |X| nInssMSOut += If( X[1]==aCodFol[1861,1] .And. X[9] # "D" ,X[5] ,0)})
		Endif
		lInfTeto := (nBaseTeto == nBaseMSOut)
		If !lInfTeto
			Calc_Inss(aTInss,nInss_b2+nBaseMSOut,@nInss,@nInss1,@nBaseAt,@nBaseAc,@nAliq,,lTrunca,,@aInssFxMs)
			If lLimDesc
				nInss	:= Min(nInss, nTetoInss-nInssAux)
				nInss1	:= Min(nInss1, nTetoInss-nInssAux)
			EndIf
			nInss     := Max(nInss-nInssMSOut,0)
			nInss1    := Max(nInss1-nInssMSOut,0)
			FMatriz(aCodfol[232,1],nInss,nAliq)
			If PosSrv(aCodfol[232,1], xFilial("SRV", SRA->RA_FILIAL), "RV_TIPOCOD") != "2"
				nId168 := nInssAux
			Else
				nId168 := nInss1 + nInssAux
			EndIf
			If !lResExt .Or. (lDedInssEx .And. lIrResExt)
				// Verifica se o parametro de apuração do INSS está ativado
				If cInssFm == "S"
					//Se estiver ativado, verifica se quer limitar o teto de desconto.
					// Em caso afirmativo, limita também a dedução
					If lLimDesc
						FMatriz(aCodfol[168,1], Min(nId168, nTetoInss) , Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, .T.)
					Else
						FMatriz(aCodfol[168,1], nId168 , Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, .T.)
					EndIf
				Else
					FMatriz(aCodfol[168,1], Min(nId168, nTetoInss), Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, .T.)
				EndIf
			EndIf
		EndIf 
	EndIf
EndIf

//Gera as verbas de INSS por faixa
If !Empty(aInssFx) .and. !Empty(aPdFx[1])
	fCInssFx(aInssFx,aPdFx)
	If Len(aInssFxMs) > 0
		fCInssFx(aInssFxMs,aPdFx,"1")
	EndIf
EndIf

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fLiqFer  ³ Autor ³ Equipe - RH     		³ Data ³ 15/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula o Liquido das Ferias								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fLiqFer()

// Calcula Arrredondamento
nVAL_ARRE := VLR_INS := 0.00

If nValArrFe > 0.00
    nLiquido := Round(nValProv - nValDesc ,2)
    // Procura Arredondamento
    nSALV_ARR := nValArrFe
    CALC_ARRE(@nLiquido, @nValArrFe, @nVal_Arre)
    nValArrFe := nSalv_Arr
    FMatriz(aCodfol[104,1],nVal_Arre)
    nValProv += nVal_Arre
EndIf

// Gravacao do Liquido de Ferias
FMatriz(aCodfol[102,1],nValProv - nValDesc)

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fIntegraFer³ Autor ³ Leandro Drumond 		³ Data ³ 29/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Integra ferias com a RGB									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fIntegraFer(cFilFun,cMatFun,cProcesso,cRotDe,cRotPara,cPerDe,cPerPara,cNPagDe,cNPagPara,aCodFol)

Local aArea		:= GetArea()
Local cInfESoc	:= ""
Local cInssFMS	:= aCodFol[0232,1]
Local cInssFM	:= GetMvRH("MV_DINSSFM",.F.,"N")
Local cBaseINSS	:= aCodFol[0013,1] + "|" + aCodFol[0014,1]
Local cSeq		:= ""
Local cRotRes	:= fGetCalcRot("4")
Local cPdFerMes	:= ""
Local cPdFerMSeg:= ""
Local cPdFolMes	:= ""
Local cPdFolMSeg:= ""
Local cPdInteg	:= ""
Local dDtRefAux := CtoD("")
Local aValDes13	:= {}
Local aRecLiq	:= {}
Local aTabS137	:= {}
Local aVlEmpMes	:= {}
Local aVlEmpMS	:= {}
Local aValECAux := {}
Local nValECons := 0
Local nValSRR	:= 0
Local nCount	:= 0
Local nCount1	:= 0
Local nLiq13	:= 0
Local nPos		:= 0
Local nTCodFol  := Len(aCodFol)
Local lRet		:= .T.
Local lGrv13	:= .T.
Local lTemPD	:= nTCodFol >= 1870
Local lTemPD2	:= nTCodFol >= 1903
Local lTemPdPis := nTCodFol >= 1970
Local lTemPdInt := nTCodFol >= 1978
Local lTem1979  := nTCodFol >= 1979 .and. !Empty(aCodFol[1979,1])
Local lVerS137	:= .F.
Local lCpoContP := SRV->(ColumnPos("RV_CONTRAP")) > 0

DEFAULT lConsig		:= GetMvRH("MV_CONSIG",, .F.)
DEFAULT lTribIR	    := SRR->( ColumnPos( "RR_TRIBIR" ) ) > 0

If lTemPD
	cInfESoc := aCodFol[1870, 1] + "|" + aCodFol[1871, 1] + "|" + aCodFol[1872, 1] + "|" + aCodFol[1882, 1] + "|" + aCodFol[1891, 1] + "|" + aCodFol[1892, 1] + "|" + aCodFol[1893, 1] +;
	 IIf( lTemPD2, "|" + aCodFol[1903, 1], "" ) + IIf(lTemPdPis, "|" + aCodFol[1969, 1] + "|" + aCodFol[1970, 1], "") + IIf(lTemPdInt, "|" + aCodFol[1978, 1], "")
EndIf

If lConsig
	fCarrTab( @aTabS137, "S137", Nil, .T. )
	If !Empty(aTabS137)
		nPos := aScan( aTabS137, { |x| x[2] == cFilFun } )
		If nPos == 0
			nPos := aScan( aTabS137, { |x| x[2] == Space(FwGetTamFilial) } )
		EndIf
		If nPos > 0
			cPdFerMes 	:= aTabS137[nPos, 08]
			cPdFerMSeg 	:= aTabS137[nPos, 09]
			cPdFolMes 	:= aTabS137[nPos, 10]
			cPdFolMSeg 	:= aTabS137[nPos, 11]
			lVerS137	:= !Empty(cPdFerMes) .And. !Empty(cPdFolMes)
		EndIf
	EndIf
EndIf

SRH->(DbSetOrder(3))
DbSelectArea("SRR")
DbSetOrder(RetOrder("SRR","RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR+RR_SEMANA+RR_PD+RR_CC+RR_SEQ+DTOS(RR_DATA)"))
If DbSeek(cFilFun+cMatFun+cPerDe+cRotDe+cNPagDe)

	nValECons := 0

	While SRR->(!Eof() .and. RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR+RR_SEMANA == cFilFun+cMatFun+cPerDe+cRotDe+cNPagDe)
		lGrv13	:= .T.
		nValSRR := SRR->RR_VALOR

		If SRR->RR_PD $ cBaseINSS .Or. (cPaisLoc == "BRA" .And. SRR->RR_PD $ cInfESoc)
			SRR->(DbSkip())
			Loop
		EndIf

		//Codigo de INSS de Ferias Mes Seguinte
		If SRR->RR_PD == cInssFMS
			If !(cInssFM $ "S*R")
				SRR->(DbSkip()) //Nao transfere verba de INSS
				Loop
			EndIf
		//13o. Salario
		ElseIf (SRR->RR_PD == aCodFol[0022,1] .or. ( RetValSrv(SRR->RR_PD, cFilFun, "RV_REF13") == "S" .and. RetValSrv(SRR->RR_PD, cFilFun, "RV_REFFER") <> "S" )) .And. !Empty(aCodFol[202, 1]) //Se a verba for de 13º, abate do liquido de 13º
			If Empty(aValDes13) .or. ( nLiq13 := aScan(aValDes13, {|x| x[3] == SRR->RR_DATA } ) ) == 0
				aAdd( aValDes13, { If( RetValSrv(SRR->RR_PD, cFilFun, "RV_TIPOCOD") == "2", SRR->RR_VALOR * -1, SRR->RR_VALOR), SRR->RR_HORAS ,SRR->RR_DATA } )
			Else
				If RetValSrv(SRR->RR_PD, cFilFun, "RV_TIPOCOD") == "2"
					aValDes13[nLiq13,1] -= SRR->RR_VALOR
				Else
					aValDes13[nLiq13,1] += SRR->RR_VALOR
				EndIf
			EndIf
		//Liq pago Ferias
		ElseIf SRR->RR_PD == aCodFol[0102,1]

			If SRR->RR_VALOR == 0 .And. Posicione("SRA", 1, cFilFun + cMatFun, "RA_TPCONTR") == "3" // Contrato intermitente
				SRR->(DbSkip())
				Loop
			EndIf

			aAdd(aRecLiq, Recno())
			SRR->(DbSkip())
			Loop
		
		ElseIf SRR->RR_PD $ aCodFol[1971,1] + "/" + aCodFol[1972,1]
			nValECons += SRR->RR_VALOR

    		If(nPos := aScan(aValECAux, {|x| x[1] == SRR->RR_DATAPAG }) ) == 0
    		    AAdd(aValECAux, { SRR->RR_DATAPAG, SRR->RR_VALOR }) //Adiciona no array a data de pagamento e valor do ID 1971 de todas as ferias
			Else 	
				aValECAux[nPos][2] += SRR->RR_VALOR //Adiciona no array o valor do ID 1972 em caso de ferias partidas
    		EndIf

			dDtRefAux := SRR->RR_DATAPAG

			If !(aCodFol[1972,1] $ SRR->RR_PD)
    			SRR->(DbSkip())
    			Loop
			EndIf
		EndIf
			
		If lConsig .And. lVerS137
			If SRR->RR_PD == cPdFerMes
				If (nPos := aScan(aVlEmpMes, { |x| x[1]+x[2]+x[3] == SRR->RR_CC+SRR->RR_ITEM+SRR->RR_CLVL } )) == 0
					aAdd( aVlEmpMes, { SRR->RR_CC, SRR->RR_ITEM, SRR->RR_CLVL, SRR->RR_DATAPAG, SRR->RR_TIPO1, SRR->RR_VALOR, SRR->RR_NUMID } )
				Else
					aVlEmpMes[nPos, 6] += SRR->RR_VALOR
				EndIf				
			ElseIf SRR->RR_PD == cPdFerMSeg
				If (nPos := aScan(aVlEmpMS, { |x| x[1]+x[2]+x[3] == SRR->RR_CC+SRR->RR_ITEM+SRR->RR_CLVL } )) == 0
					aAdd( aVlEmpMS, { SRR->RR_CC, SRR->RR_ITEM, SRR->RR_CLVL, SRR->RR_DATAPAG, SRR->RR_TIPO1, SRR->RR_VALOR, SRR->RR_NUMID } )
				Else
					aVlEmpMS[nPos, 6] += SRR->RR_VALOR
				EndIf	
			EndIf
		EndIf

		cPdInteg := SRR->RR_PD

		//Previdência Privada Férias ou Suspensão da previdência férias troca a verba pela informada no RV_CONTRAP
		If lCpoContP .And. "48" $ RetValSrv(cPdInteg, cFilFun, "RV_INCIRF") 
			cPdInteg := If(Empty(cPdInteg := RetValSrv(cPdInteg, cFilFun, "RV_CONTRAP")), SRR->RR_PD, cPdInteg)
		EndIf

		cSeq := SRR->RR_SEQ

		If RGB->(DbSeek( cFilFun + cProcesso + cMatFun + cPerPara + cNPagPara + cRotPara + cPdInteg + SRR->RR_CC + SRR->RR_ITEM + SRR->RR_CLVL + SRR->RR_SEQ + dTos(SRR->RR_DATAPAG) ))
			If RGB->RGB_ROTORI == cRotRes //Se verba já foi integrada pela rotina de rescisão, ignora
				SRR->(DbSkip())
				Loop
			EndIf
			For nCount := (Val(cSeq) + 1) to 9
				cSeq := Alltrim(Str(nCount))
				If !RGB->(DbSeek( cFilFun + cProcesso + cMatFun + cPerPara + cNPagPara + cRotPara + cPdInteg + SRR->RR_CC + SRR->RR_ITEM + SRR->RR_CLVL + cSeq + dTos(SRR->RR_DATAPAG) ))
					RGB->( RecLock( "RGB" , .T. ) )
					Exit
				End
			Next nCount
			If nCount == 10
				aAdd( aLog[Len(aLog)], cFilFun + "  " + cMatFun + " - " + cPdInteg + " " + fDesc( "SRV" , cPdInteg  , "RV_DESC" ) )
				SRR->(DbSkip())
				Loop
			EndIf
		Else
			RGB->( RecLock( "RGB" , .T. ) )
		EndIf

		RGB->RGB_FILIAL	:= SRR->RR_FILIAL
		RGB->RGB_MAT 	:= SRR->RR_MAT
		RGB->RGB_CC		:= SRR->RR_CC
		RGB->RGB_PD		:= cPdInteg
		RGB->RGB_HORAS	:= SRR->RR_HORAS
		RGB->RGB_DTREF	:= SRR->RR_DATAPAG
		RGB->RGB_TIPO1	:= SRR->RR_TIPO1
		RGB->RGB_TIPO2	:= "K"
		RGB->RGB_VALOR	:= nValSRR
		RGB->RGB_PARCEL	:= 0
		RGB->RGB_SEQ	:= cSeq
		RGB->RGB_ITEM 	:= SRR->RR_ITEM
		RGB->RGB_CLVL 	:= SRR->RR_CLVL
		RGB->RGB_PROCES	:= cProcesso
		RGB->RGB_PERIOD	:= cPerPara
		RGB->RGB_ROTEIR	:= cRotPara
		RGB->RGB_SEMANA	:= cNPagPara
		RGB->RGB_ROTORI	:= cRotDe
		RGB->RGB_NUMID  := SRR->RR_NUMID
		If cPaisLoc == "BRA"
			RGB->RGB_IDCMPL	:= SRR->RR_IDCMPL
		EndIf
        If lTribIR
            RGB->RGB_TRIBIR	:= SRR->RR_TRIBIR
        EndIf

		RGB->(MsUnLock())

		SRR->(DbSkip())
	EndDo

	If nValECons > 0

		SRA->(DbSeek(cFilFun+cMatFun))

		//Se existir já foi integrado pela rescisão
		If !RGB->(DbSeek( cFilFun + cProcesso + cMatFun + cPerPara + cNPagPara + cRotPara + aCodFol[1973,1] + SRR->RR_CC + SRR->RR_ITEM + SRR->RR_CLVL ))

			RGB->( RecLock( "RGB" , .T. ) )

			RGB->RGB_FILIAL	:= cFilFun
			RGB->RGB_MAT 	:= cMatFun
			RGB->RGB_CC		:= SRA->RA_CC
			RGB->RGB_PD		:= aCodFol[1973,1]
			RGB->RGB_DTREF	:= dDtRefAux
			RGB->RGB_TIPO1	:= "V"
			RGB->RGB_TIPO2	:= "K"
			RGB->RGB_VALOR	:= nValECons
			RGB->RGB_PARCEL	:= 0
			RGB->RGB_SEQ	:= cSeq
			RGB->RGB_ITEM 	:= SRA->RA_ITEM
			RGB->RGB_CLVL 	:= SRA->RA_CLVL
			RGB->RGB_PROCES	:= cProcesso
			RGB->RGB_PERIOD	:= cPerPara
			RGB->RGB_ROTEIR	:= cRotPara
			RGB->RGB_SEMANA	:= cNPagPara
			RGB->RGB_ROTORI	:= cRotDe
			RGB->(MsUnLock())
		EndIf
	EndIf
EndIf

If Len(aRecLiq) > 0 
	For nCount := 1 to Len(aRecLiq)
		SRR->(DbGoTo(aRecLiq[nCount]))

		nValSRR := SRR->RR_VALOR 

		//Se não houver a verba 1979, altera liquido para desconsiderar o E-Consignado
		If !lTem1979 .and. Len(aValECAux) > 0
			If(nPos := aScan(aValECAux, {|x| x[1] == SRR->RR_DATAPAG }) ) > 0
				nValSRR += aValECAux[nPos][2] //Soma no Liquido das ferias o valor de provisionamento
			EndIf
		EndIf

		If Len(aValDes13) > 0 .And. ( nLiq13 := aScan(aValDes13, {|x| x[3] == SRR->RR_DATA } ) ) > 0
			cSeq := SRR->RR_SEQ

			//Se existir já foi integrado pela rescisão
			If !RGB->(DbSeek( SRR->RR_FILIAL + cProcesso + SRR->RR_MAT + cPerPara + cNPagPara + cRotPara + aCodFol[202,1] + SRR->RR_CC + SRR->RR_ITEM + SRR->RR_CLVL + cSeq + DtoS(SRR->RR_DATAPAG) ))

				RGB->( RecLock( "RGB" , .T. ) )

				RGB->RGB_FILIAL	:= SRR->RR_FILIAL
				RGB->RGB_MAT 	:= SRR->RR_MAT
				RGB->RGB_CC		:= SRR->RR_CC
				RGB->RGB_PD		:= aCodFol[202,1]
				RGB->RGB_HORAS	:= aValDes13[nLiq13,2]
				RGB->RGB_DTREF	:= SRR->RR_DATAPAG
				RGB->RGB_TIPO1	:= SRR->RR_TIPO1
				RGB->RGB_TIPO2	:= "K"
				RGB->RGB_VALOR	:= aValDes13[nLiq13,1]
				RGB->RGB_PARCEL	:= 0
				RGB->RGB_SEQ	:= cSeq
				RGB->RGB_ITEM 	:= SRR->RR_ITEM
				RGB->RGB_CLVL 	:= SRR->RR_CLVL
				RGB->RGB_PROCES	:= cProcesso
		      	RGB->RGB_PERIOD	:= cPerPara
				RGB->RGB_ROTEIR	:= cRotPara
				RGB->RGB_SEMANA	:= cNPagPara
		      	RGB->RGB_ROTORI	:= cRotDe
		      	If cPaisLoc == "BRA"
			      	RGB->RGB_IDCMPL	:= SRR->RR_IDCMPL
			 	EndIf

			 	RGB->(MsUnLock())
			EndIf

		 	nValSRR -= aValDes13[nLiq13,1]
		EndIf

		cSeq := SRR->RR_SEQ

		//Se existir já foi integrado pela rescisão
		If RGB->(DbSeek( SRR->RR_FILIAL + cProcesso + SRR->RR_MAT + cPerPara + cNPagPara + cRotPara + SRR->RR_PD + SRR->RR_CC + SRR->RR_ITEM + SRR->RR_CLVL + cSeq + DtoS(SRR->RR_DATAPAG) ))
			If RGB->RGB_ROTORI == cRotRes //Se verba já foi integrada pela rotina de rescisão, ignora
				Loop
			EndIf
			For nCount1 := (Val(cSeq) + 1) to 9
				cSeq := Alltrim(Str(nCount1))
				If !RGB->(DbSeek( SRR->RR_FILIAL + cProcesso + SRR->RR_MAT + cPerPara + cNPagPara + cRotPara + SRR->RR_PD + SRR->RR_CC + SRR->RR_ITEM + SRR->RR_CLVL + cSeq + DtoS(SRR->RR_DATAPAG) ))
					RGB->( RecLock( "RGB" , .T. ) )
					Exit
				End
			Next nCount1
			If nCount1 == 10
				aAdd( aLog[Len(aLog)], SRR->RR_FILIAL + "  " + SRR->RR_MAT + " - " + SRR->RR_PD + " " + fDesc( "SRV" , SRR->RR_PD  , "RV_DESC" ) )
				Loop
			EndIf
		Else
			RGB->( RecLock( "RGB" , .T. ) )
		EndIf

		RGB->RGB_FILIAL	:= SRR->RR_FILIAL
		RGB->RGB_MAT 	:= SRR->RR_MAT
		RGB->RGB_CC		:= SRR->RR_CC
		RGB->RGB_PD		:= SRR->RR_PD
		RGB->RGB_HORAS	:= SRR->RR_HORAS
		RGB->RGB_DTREF	:= SRR->RR_DATAPAG
		RGB->RGB_TIPO1	:= SRR->RR_TIPO1
		RGB->RGB_TIPO2	:= "K"
		RGB->RGB_VALOR	:= nValSRR
		RGB->RGB_PARCEL	:= 0
		RGB->RGB_SEQ	:= cSeq
		RGB->RGB_ITEM 	:= SRR->RR_ITEM
		RGB->RGB_CLVL 	:= SRR->RR_CLVL
		RGB->RGB_PROCES	:= cProcesso
		RGB->RGB_PERIOD	:= cPerPara
		RGB->RGB_ROTEIR	:= cRotPara
		RGB->RGB_SEMANA	:= cNPagPara
		RGB->RGB_ROTORI	:= cRotDe
		If cPaisLoc == "BRA"
			RGB->RGB_IDCMPL	:= SRR->RR_IDCMPL
		EndIf

		RGB->(MsUnLock())
	 Next nCount
EndIf

//Gera o total descontado no eConsignado na verba 1979 para devolução na folha
If lTem1979	.and. Len(aValECAux) > 0
	nValSRR := 0
	aEval(aValECAux, {|x| nValSRR += x[2] })

	//Se existir já foi integrado pela rescisão
	If !RGB->(DbSeek( cFilFun + cProcesso + cMatFun + cPerPara + cNPagPara + cRotPara + aCodFol[1979,1] + SRR->RR_CC + SRR->RR_ITEM + SRR->RR_CLVL ))
	
		RGB->( RecLock( "RGB" , .T. ) )

		RGB->RGB_FILIAL	:= cFilFun
		RGB->RGB_MAT 	:= cMatFun
		RGB->RGB_CC		:= SRA->RA_CC
		RGB->RGB_PD		:= aCodFol[1979,1]
		RGB->RGB_DTREF	:= dDtRefAux
		RGB->RGB_TIPO1	:= "V"
		RGB->RGB_TIPO2	:= "K"
		RGB->RGB_VALOR	:= nValSRR
		RGB->RGB_PARCEL	:= 0
		RGB->RGB_SEQ	:= " "
		RGB->RGB_ITEM 	:= SRA->RA_ITEM
		RGB->RGB_CLVL 	:= SRA->RA_CLVL
		RGB->RGB_PROCES	:= cProcesso
		RGB->RGB_PERIOD	:= cPerPara
		RGB->RGB_ROTEIR	:= cRotPara
		RGB->RGB_SEMANA	:= cNPagPara
		RGB->RGB_ROTORI	:= cRotDe
		RGB->(MsUnLock())
	EndIf
EndIf

If lConsig .And. lVerS137
	If !Empty(aVlEmpMes)
		For nCount := 1 To Len(aVlEmpMes)
			If !RGB->( dbSeek( cFilFun + cProcesso + cMatFun + cPerPara + cNPagPara + cRotPara + cPdFolMes + aVlEmpMes[nCount, 1] + aVlEmpMes[nCount, 2] + aVlEmpMes[nCount, 3] + Space(1) + dToS(aVlEmpMes[nCount, 4]) ) )
				If RGB->( RecLock( "RGB", .T. ) )
					RGB->RGB_FILIAL	:= cFilFun
					RGB->RGB_MAT 	:= cMatFun
					RGB->RGB_CC		:= aVlEmpMes[nCount, 1]
					RGB->RGB_PD		:= cPdFolMes
					RGB->RGB_DTREF	:= aVlEmpMes[nCount, 4]
					RGB->RGB_TIPO1	:= aVlEmpMes[nCount, 5]
					RGB->RGB_TIPO2	:= "K"
					RGB->RGB_VALOR	:= aVlEmpMes[nCount, 6]
					RGB->RGB_ITEM 	:= aVlEmpMes[nCount, 2]
					RGB->RGB_CLVL 	:= aVlEmpMes[nCount, 3]
					RGB->RGB_PROCES	:= cProcesso
					RGB->RGB_PERIOD	:= cPerPara
					RGB->RGB_ROTEIR	:= cRotPara
					RGB->RGB_SEMANA	:= cNPagPara
					RGB->RGB_ROTORI	:= cRotDe
					RGB->RGB_NUMID  := aVlEmpMes[nCount, 7]
			 	EndIf
			 	RGB->(MsUnLock())
			EndIf
		Next nCount
	EndIf
	If !Empty(aVlEmpMS)
		For nCount := 1 To Len(aVlEmpMS)
			If !RGB->( dbSeek( cFilFun + cProcesso + cMatFun + cPerPara + cNPagPara + cRotPara + cPdFolMSeg + aVlEmpMS[nCount, 1] + aVlEmpMS[nCount, 2] + aVlEmpMS[nCount, 3] + Space(1) + dToS(aVlEmpMS[nCount, 4]) ) )
				If RGB->( RecLock( "RGB", .T. ) )
					RGB->RGB_FILIAL	:= cFilFun
					RGB->RGB_MAT 	:= cMatFun
					RGB->RGB_CC		:= aVlEmpMS[nCount, 1]
					RGB->RGB_PD		:= cPdFolMSeg
					RGB->RGB_DTREF	:= aVlEmpMS[nCount, 4]
					RGB->RGB_TIPO1	:= aVlEmpMS[nCount, 5]
					RGB->RGB_TIPO2	:= "K"
					RGB->RGB_VALOR	:= aVlEmpMS[nCount, 6]
					RGB->RGB_ITEM 	:= aVlEmpMS[nCount, 2]
					RGB->RGB_CLVL 	:= aVlEmpMS[nCount, 3]
					RGB->RGB_PROCES	:= cProcesso
					RGB->RGB_PERIOD	:= cPerPara
					RGB->RGB_ROTEIR	:= cRotPara
					RGB->RGB_SEMANA	:= cNPagPara
					RGB->RGB_ROTORI	:= cRotDe
					RGB->RGB_NUMID  := aVlEmpMS[nCount, 7]
			 	EndIf
			 	RGB->(MsUnLock())
			EndIf
		Next nCount
	EndIf
EndIf

RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fDeleteRGBºAutor  ³Leandro Drumond     º Data ³  26/11/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Deleta registros da RGB diretamente no Banco                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fDeleteRGB(cFilSRA, cMatSRA, cPeriodo, cNumPag, cRotOri)

Local cAliasRGB	:= GetNextAlias()
Local cFilter 	:= ""
Local cRGBSqlName
Local cQuery
Local cCpoRecno

If ( Select( cAliasRGB ) > 0 )
	( cAliasRGB )->( dbCloseArea() )
EndIf

cRGBSqlName := InitSqlName( "RGB" )
cCpoRecno 	:= "R_E_C_N_O_"

cFilter += "     RGB_PERIOD = '" + cPeriodo + "'"
cFilter += " AND RGB_SEMANA = '" + cNumPag  + "'"
cFilter += " AND RGB_ROTORI = '" + cRotOri  + "'"
cFilter += " AND RGB_FILIAL = '" + cFilSRA  + "'"
cFilter += " AND RGB_MAT 	= '" + cMatSRA  + "'"

cFilter := "%" + cFilter +"%"

cFilter := Substr( cFilter, 2, (Len(cFilter)-2) )
cQuery := "DELETE FROM "  + cRGBSqlName + " WHERE "

cQueryDelet := ( cQuery + cFilter )
TcSqlExec( cQueryDelet )
TcRefresh( cRGBSqlName )

Return

/*/{Protheus.doc} fDelMemCalc
Exclui informações de memória de cálculo, quando existir
@author Leandro Drumond
@since 14/08/2024
/*/
Function fDelMemCalc(cFil, cMat, cProc, cPer, cRot, cSem)
Local cQuery 	:= ""
Local cSqlName  := ""
Local cNameDB	:= ""

RFT->(DbSetOrder(1)) //// RFT_FILIAL, RFT_MAT, RFT_PROCES, RFT_PERIOD, RFT_SEMANA, RFT_ROTEIR, RFT_DATA, RFT_HORA

If RFT->(DbSeek(cFil + cMat + cProc + cPer + cSem + cRot ))

	cNameDB	:= Upper(TcGetDb())

	cSqlName := InitSqlName( "RFV" )

	cQuery	:= "DELETE " + If(!( cNameDB $ "DB2_ORACLE_INFORMIX_POSTGRES" ), cSqlName, "")
	
	cQuery += " FROM " + InitSqlName( "RFV" ) + " RFV "
	cQuery += " WHERE RFV.RFV_FILIAL = '" + cFil + "'"
	cQuery += " AND RFV.RFV_MAT = '" + cMat + "'"
	cQuery += " AND RFV.RFV_PROCES = '" + cProc + "'"
	cQuery += " AND RFV.RFV_ROTEIR = '" + cRot + "'" 
	cQuery += " AND RFV.RFV_PERIOD = '" + cPer + "'"
	cQuery += " AND RFV.RFV_SEMANA = '" + cSem + "'"

	TcSqlExec( cQuery )	

	cSqlName := InitSqlName( "RFT" ) 

	cQuery	:= "DELETE " + If(!( cNameDB $ "DB2_ORACLE_INFORMIX_POSTGRES" ), cSqlName, "")

	cQuery += " FROM " + InitSqlName( "RFT" ) + " RFT "
	cQuery += " WHERE RFT.RFT_FILIAL = '" + cFil + "'"
	cQuery += " AND RFT.RFT_MAT = '" + cMat + "'"
	cQuery += " AND RFT.RFT_PROCES = '" + cProc + "'"
	cQuery += " AND RFT.RFT_ROTEIR = '" + cRot + "'" 
	cQuery += " AND RFT.RFT_PERIOD = '" + cPer + "'"
	cQuery += " AND RFT.RFT_SEMANA = '" + cSem + "'"

	TcSqlExec( cQuery )	
	
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³VldCalc   ºAutor  ³Leandro Drumond     º Data ³  19/09/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida se calculo foi efetuado			                  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function VldCalc(oModel)

Local lRet	:= .T.

If !(oModel:GetOperation() == MODEL_OPERATION_DELETE)
	lRet := lGrvCalc

	If !lRet
		If lWorkFlow //Se for chamado pela rotina automatica efetua o calculo das férias
			lRet := lGrvCalc := m030VldCalc(oModel) .and. CalcFer( oModel )
		Else
			Help( ,, OemToAnsi(STR0088),, OemToAnsi(STR0090), 1, 0 ) //"Atenção"##"Antes de gravar é necessário calcular as férias."
		EndIf
	EndIf
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fVldPerc13ºAutor  ³Leandro Drumond     º Data ³  03/11/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida se ja foi efetuado calculo de 13º	                  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVldPerc13()
Local aArea		:= GetArea()
Local nValAux	:= &(ReadVar())
Local lRet		:= .T.
Local cPerAux   := If(Empty(M->RH_PERIODO), cPeriodo, M->RH_PERIODO)

If nValAux > 0
	DbSelectArea("SRD")
	DbSetOrder(5) //RD_FILIAL+RD_MAT+RD_PROCES+RD_ROTEIR+RD_PERIODO+RD_SEMANA

	If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cProcesso + fGetCalcRot("5") + SubStr(cPerAux,1,4))
		If !lWorkFlow .And. !(IsBlind()) .and. !MsgYesNo(STR0094, STR0088) //"A primeira parcela do 13ºsalário já foi calculada anteriormente. Confirma?"#"Aviso"
			lRet := .F.
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fVerDFer  ºAutor  ³Claudinei Soares    º Data ³ 27/11/2014  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida se os dias de ferias sao menores que 10, caso seja   º±±
±±º          ³sera emitida uma mensagem avisando e solicitando confirmacaoº±±
±±º          ³Conforme Artigo 34 da CLT as ferias nao podem ser inferioresº±±
±±º          ³a 10 dias corridos.                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE - GPEM030.                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fVerDFer()
Local lRet := .T.

DEFAULT lRefTrab		:= FindFunction("fRefTrab") .And. fRefTrab("F")

If !lRefTrab .and. ! IsBlind() .AND. cPaisLoc == "BRA" .AND. ((M->RH_DABONPE + M->RH_DFERIAS) < 10)
	lRet:=(MsgYesNo(OemToAnsi(STR0095)+ CRLF + OemToAnsi(STR0115),OemToAnsi(STR0088))) //Conforme Artigo 134 parágrafo 1º da CLT,
	//	Os dias de férias + abono não podem ser inferiores a 10 dias, deseja continuar?.
	//Salvo pelo Artigo 130 A da CLT, que trata da modalidade de regime de tempo parcial.
Endif

//Se já foi pago férias referente ao período, informa que período deve ser quitado. Exceto se já foi feito mais que um pagamento, indicando que os cálculos foram feitos antes das alterações.
If !lRefTrab .and. lRet .and. cPaisLoc == "BRA" .and. !lWorkFlow .And. !(IsBlind()) .and. nDAntPer > 0 .and. nQtdSRH < 2
	If (M->RH_DFERIAS + M->RH_DABONPE + nDAntPer) <  aTabFer[3]
		lRet:=(MsgYesNo(OemToAnsi(STR0116) ,OemToAnsi(STR0088))) //"Conforme Artigo 134 parágrafo 1º da CLT, as férias devem ser concedidas em um máximo de 2 periodos. Deseja continuar?"
	EndIf
EndIf

Return(lRet)

/*/{Protheus.doc}fVldMsgMed()
Valida se deve ser exibida a mensagem para aviso das médias
Obs: Será exibida apenas se o cálculo das médias for considerar a partir de dois meses anteriores ao do período de férias
@author Gabriel de Souza Almeida
@since 02/06/2016
@version P12
/*/
Static Function fVldMsgMed()

	Local lRet    	:= P_DTMDFER == "1" .And. M->RH_MEDATU == "N"
	Local aPerFER 	:= {}
	Local aPerFOL 	:= {}
	Local cRtFer	:= fGetCalcRot("3")
	LOcal cRtFol	:= fGetRotOrdinar()

	If lRet
		fGetPerAtual( @aPerFER, , cProcesso, cRtFer )
		fGetPerAtual( @aPerFOL, , cProcesso, cRtFol )
		If Len(aPerFER) > 0 .And. Len(aPerFOL) > 0 .And. Len(aPerFER[1][1]) > 0
			lRet := lRet .And. aPerFOL[1][1] < aPerFER[1][1]
		Else
			lRet := .F.
		EndIf
	EndIf

Return lRet

Static Function IncidCpos(oStruct,lIsView)
	Local aArea	:= SX3->(GetArea())
	Local aCampos := {'RV_INSS','RV_FGTS','RV_IR','RV_INCORP'}
	Local nI := 0
	Local cCpNome := ''
	Local cPrefixo := ''
	Local cOrdem := ''
	Local cCpoPD := ''
	Local bIniPad := {||}
	Local cIniPad := ''
	Local cTabela := "SRR"
	Default lIsView := .F.

	cPrefixo := PrefixoCpo(cTabela)
	cCpoPD := cPrefixo + '_PD'

	SX3->(dbSetOrder(2))
	dbSelectArea('SX3')
	for nI:= 1 to Len(aCampos)
		cCpNome := cPrefixo + SubStr( aCampos[nI], At('_',aCampos[nI]))
		if(dbSeek(aCampos[nI]))
			if(lIsView)
				cOrdem := aTail(oStruct:aFields)[2]
				cOrdem := Val(cOrdem) + 1
				cOrdem := StrZero(cOrdem,2)

				oStruct:AddField(	cCpNome, cOrdem, AllTrim(X3_TITULO), AllTrim(X3_TITULO), {}, X3_TIPO, AllTrim(X3_PICTURE),;
				/*bPictVar*/, /*cLookUp*/, /*lCanChange*/, /*cFolder*/, /*cGroup*/, /*aComboValues*/,;
				/*nMaxLenCombo*/, /*cIniBrow*/, .T.)
			else
				cIniPad := 'POSICIONE( "SRV", 1, xFilial("SRV")+'+ cTabela + '->'+ cCpoPD + ',"'+ aCampos[nI] +'")'
				bIniPad := FwBuildFeature( STRUCT_FEATURE_INIPAD, cIniPad )
				oStruct:AddField(AllTrim(X3_TITULO), AllTrim(X3_TITULO), cCpNome, X3_TIPO, X3_TAMANHO, X3_DECIMAL,;
			  	/*bValid*/, /*bWhen*/, /*aValues*/, /*lObrigat*/, bIniPad, /*lKey*/, /*lNoUpd*/,.T.)

			endIf
		endIf
	next nI

	RestArea(aArea)
Return nil

/*/{Protheus.doc} IntFerTAF
Rotina responsável pela integração com o TAF
@type function
@author Eduardo
@since 06/03/2018
@version 1.0
@param aErros, Array, Dados de erros
@param cMsgErro, Caracter, Mensagem de erro para férias coletivas
@param lOffline, Logico, Indica se é geração offline
@param lLote, Logico, Indica se é geração offline em lote
@return lRet, retorno lógico se deu certo ou não a integração
/*/
Function IntFerTAF(aErros, cMsgErro, lOffline, lLote)
	Local aAreaSRA      := SRA->(GetArea())
	Local aAreaSR8      := SR8->(GetArea())
	Local aAreaCM6      := {}
	Local cXml          := ""
	Local cTrabVincu    := fCatTrabEFD("TCV") //"101|102|103|104|105|106|111|301|302|303|304|306|701|702|703|711|712|713" //Trabalhador com vinculo

	Local aFilInTaf     := {}
	Local cFilEnv       := ""
	Local lContinua     := .T.
	Local lRet          := .T.

	Local nOperation    := 0

	Local cFilBkp       := cFilAnt
	Local cStatus,cStat2230:= ""
	Local lExec			:= .T.
	Local oModel        := Nil
	Local lNT15			:= .F.
	Local cVersEnvio	:= ""
	Local cEFDAviso		:= If(cPaisLoc == 'BRA' .And. Findfunction("fEFDAviso"), fEFDAviso(), SuperGetMv("MV_EFDAVIS",, "0")) //Integracao com TAF)
	Local cVersMw	 	:= ""
	Local cId		 	:= ""
	Local cChaveS2230 	:= ""
	Local cMsgRJE	 	:= ""
	Local aInfoC		:= {}
	Local cChaveMid		:= ""
	Local cNrInsc		:= ""
	Local cTpInsc		:= ""
	Local lAdmPubl		:= .F.
	Local aDados	 	:= {}
	Local cOperNew 	 	:= ""
	Local cOper2230	 	:= "I"
	Local cRecib2230 	:= ""
	Local cRecibAnt  	:= ""
	Local cRecibXML  	:= ""
	Local cRetf2230	 	:= "1"
	Local nRec2230   	:= 0
	Local cRetfNew	 	:= ""
	Local cStatNew	 	:= ""
	Local lNovoRJE	 	:= .F.
	Local lS1000 	 	:= .T.
	Local nTamC9VMat	:= FWSX3Util():GetFieldStruct( "C9V_MATRIC")[3]

	DEFAULT aErros      := {}
	DEFAULT cMsgErro	:= ""
	DEFAULT lOffline	:= .F.
	DEFAULT lLote		:= .F.
	DEFAULT lMiddleware := If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )

	If !lMiddleware
		aAreaCM6    := CM6->(GetArea())
		cFilAnt		:= SRA->RA_FILIAL
		fGp23Cons(@aFilInTaf, {cFilAnt},@cFilEnv)
		cFilAnt:= cFilBkp

		//tratamento para empresa configurada como 1x1 ou 1xN
		If ( Len(aFilInTaf) > 0 .And. Len(aFilInTaf[1,3]) > 1 ) .AND. !EMPTY(cFilEnv) //1XN
			cFilAnt := cFilEnv
		EndIf
	EndIf

	If Type ('ALTERA') == 'U'
		ALTERA:= .T.
		INCLUI:= .F.
	EndIF

	nOperation:= Iif(ALTERA, 4, Iif(INCLUI .Or. lOffline, 3, 5))

	If Empty(cFilEnv)
		cFilEnv:= cFilAnt
	EndIf
	DbSelectArea("SRA")
	SRA->(dbSetOrder(1))
	If !lMiddleware
		DbSelectArea("CM6")
		CM6->(dbSetOrder(2))
	EndIf

	//------------------------------------------
	//VERIFICA SE FUNCIONÁRIO JÁ FOI INTEGRADO
	//------------------------------------------
	If !lMiddleware
		cStatus := TAFGetStat( "S-2200", SRA->RA_CIC+";"+SRA->RA_CODUNIC,cEmpAnt,cFilEnv)//ADMISSAO POR CADASTRO
	Else
		fPosFil( cEmpAnt, SRA->RA_FILIAL )
		aInfoC   := fXMLInfos()
		If Len(aInfoC) >= 4
			cTpInsc  := aInfoC[1]
			lAdmPubl := aInfoC[4]
			cNrInsc  := aInfoC[2]
			cId  	 := aInfoC[3]
		Else
			cTpInsc  := ""
			lAdmPubl := .F.
			cNrInsc  := "0"
			cId  	 := ""
		EndIf
		cChaveMid	:= cTpInsc + PADR( Iif( !lAdmPubl .And. cTpInsc == "1", SubStr(cNrInsc, 1, 8), cNrInsc), 14) + "S2200" + Padr(SRA->RA_CODUNIC, 36, " ")
		cStatus 	:= "-1"
		//RJE_TPINSC+RJE_INSCR+RJE_EVENTO+RJE_KEY+RJE_INI
		GetInfRJE( 2, cChaveMid, @cStatus )
	EndIf

	//----------------------------------------
	//Verificação de trabalhador com vínculo,
	//checagem de integração de admissão
	//----------------------------------------
	If !SRA->RA_CATEFD $ cTrabVincu //Validacao vinculo do funcionario
		lContinua   := .F.
	ElseIf cStatus != "4"
		lRet        := .F.
		lContinua   := .F.
		If !lMiddleware
			cMsgErro := STR0131 //"Não será possível integrar o afastamento com o TAF pois o registro de Admissão/Carga Inicial deste funcionário ainda não foi efetivado no TAF ou não foi transmitido para o RET"
		Else
			cMsgErro := STR0136 //"Não será possível integrar o afastamento com o Middleware pois o registro de Admissão/Carga Inicial deste funcionário ainda não foi efetivado no Middleware ou não foi transmitido para o RET"
		EndIf
	EndIf

	If lMiddleware .And. lRet
		cStatus:= "-1"
		lS1000 := fVld1000( If(Empty(cPeriodo), SRH->RH_PERIODO, cPeriodo), @cStatus )
		If !lS1000 .And. cEFDAviso != "2"
			Do Case
				Case cStatus == "-1" // nao encontrado na base de dados
					cMsgRJE := STR0137 //"Registro do evento S-1000 não localizado na base de dados"
				Case cStatus == "1" // nao enviado para o governo
					cMsgRJE := STR0138 //"Registro do evento S-1000 não transmitido para o governo"
				Case cStatus == "2" // enviado e aguardando retorno do governo
					cMsgRJE := STR0139 //"Registro do evento S-1000 aguardando retorno do governo"
				Case cStatus == "3" // enviado e retornado com erro
					cMsgRJE := STR0140 //"Registro do evento S-1000 retornado com erro do governo"
			Endcase

			// Se tornar impeditivo o prosseguimento devido a presenca de inconsistencias
			If cEFDAviso == "0"
				MsgInfo(cMsgRJE, OemToAnsi(STR0007))//"Atenção"
			ElseIf cEFDAviso == "1"
				lRet      := .F.
				lContinua := .F.
				cMsgErro  := cMsgRJE
			EndIf
		EndIf
	EndIf

	//------------------------------------------
	//Efetua a integracao com TAF
	//------------------------------------------
	If !Empty(cFilEnv) .AND. lContinua

		If FindFunction("fVersEsoc")
			fVersEsoc( "S2230", .F., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio, Nil, @cVersMw, @lNT15  )
		EndIf

		If lMiddleware
			cChaveS2230	:= SRA->RA_CODUNIC + dToS(SR8->R8_DATAINI) + "C"
			cChaveBus	:= cTpInsc + PADR( Iif( !lAdmPubl .And. cTpInsc == "1", SubStr(cNrInsc, 1, 8), cNrInsc), 14) + "S2230" + Padr(cChaveS2230, 40, " ")
			cStat2230 	:= "-1"
			GetInfRJE( 2, cChaveBus, @cStat2230, @cOper2230, @cRetf2230, @nRec2230, @cRecib2230, @cRecibAnt, Nil, Nil, .T. )

			//Retorno pendente impede o cadastro
			If cStat2230 == "2" .And. cEFDAviso != "2"
				cMsgErro 	:= STR0141//"Operação não será realizada pois o evento S-2230 foi transmitido, mas o retorno está pendente"
				lRet      	:= .F.
				lContinua 	:= .F.
			//Evento com exclusão sem transmissão
			ElseIf cStat2230 == "99"
				cMsgErro 	:= STR0143//"A operação não pode ser realizada porque há um evento de exclusão (S-3000) relacionado ao S-2230 que está pendente de transmissão."
				lRet      	:= .F.
				lContinua 	:= .F.
			//Evento sem transmissão, irá sobrescrever o registro na fila
			ElseIf cStat2230 $ "1/3"
				cOperNew 	:= cOper2230
				cRetfNew	:= cRetf2230
				cStatNew	:= "1"
				lNovoRJE	:= .F.
			//Evento diferente de exclusão transmitido, irá gerar uma retificação
			ElseIf cOper2230 != "E" .And. cStat2230 == "4"
				cOperNew 	:= "A"
				cRetfNew	:= "2"
				cStatNew	:=  "1"
				lNovoRJE	:= .T.
			//Será tratado como inclusão
			Else
				cOperNew 	:= "I"
				cRetfNew	:= "1"
				cStatNew	:= "1"
				lNovoRJE	:= .T.
			EndIf
			If cRetfNew == "2"
				If cStat2230 == "4"
					cRecibXML 	:= cRecib2230
					cRecibAnt	:= cRecib2230
					cRecib2230	:= ""
				Else
					cRecibXML 	:= cRecibAnt
				EndIf
			EndIf
		Else
			cStat2230 := TAFGetStat( "S-2230", SRA->RA_CIC + PADR(SRA->RA_CODUNIC, nTamC9VMat) + ";" + dToS(SR8->R8_DATAINI) + ";" + "COMP")
			//Retorno pendente impede o cadastro
			If cStat2230 == "2"
				cMsgErro 	:= STR0141//"Operação não será realizada pois o evento S-2230 foi transmitido, mas o retorno está pendente"
				lRet      	:= .F.
				lContinua 	:= .F.
			ElseIf cStat2230 == "6"
				cMsgErro 	 := STR0143//"A operação não pode ser realizada porque há um evento de exclusão (S-3000) relacionado ao S-2230 que está pendente de transmissão."
				lRet      	 := .F.
				lContinua 	 := .F.
			EndIf
		EndIf

		cXml := ""
		If nOperation <> 5
			If lContinua
				If !lMiddleware
					cXml +='<eSocial>'
					cXml +='<evtAfastTemp>'
					If cStat2230 == "4"
						cXml +='<ideEvento>'
						cXml +='	<indRetif>2</indRetif>'
						cXml +='</ideEvento>'
					EndIf
				Else
					aAdd( aDados, { xFilial("RJE", cFilAnt), cFilAnt, cTpInsc, Iif( cTpInsc == "1" .And. !lAdmPubl, SubStr(cNrInsc, 1, 8), cNrInsc ), "S2230", Space(6), cChaveS2230, cId, cRetfNew, "12", cStatNew, Date(), Time(), cOperNew, cRecib2230, cRecibAnt } )

					cXML := "<eSocial xmlns='http://www.esocial.gov.br/schema/evt/evtAfastTemp/v" + cVersMw + "'>"
					cXML += "<evtAfastTemp Id='" + cId + "'>"
					fXMLIdEve( @cXML, { cRetfNew, Iif(cRetfNew == "2", cRecibXML, Nil), Nil, Nil, 1, 1, "12" } )
					fXMLIdEmp( @cXML, { cTpInsc, Iif( cTpInsc == "1" .And. !lAdmPubl, SubStr(cNrInsc, 1, 8), cNrInsc ) } )
				EndIf
				cXml +='<ideVinculo>'
				cXml +='    <cpfTrab>'+SRA->RA_CIC+'</cpfTrab>'
				If cVersEnvio < "9.0"
					If !lMiddleware
						cXml +='    <nisTrab>'+SRA->RA_PIS+'</nisTrab>'
					Else
						cXml +='    <nisTrab>'+AllTrim(SRA->RA_PIS)+'</nisTrab>'
					EndIf
				EndIf
				if SRA->RA_CATEFD != "901"
					cXml +='    <matricula>'+SRA->RA_CODUNIC+'</matricula>'
				EndIf
				cXml +='</ideVinculo>'
				cXml +='<infoAfastamento>'
				cXml +='<iniAfastamento>'
				If !lMiddleware
					cXml +='<dtIniAfast>'+ DTOS(SR8->R8_DATAINI)+'</dtIniAfast>'
				Else
					cXml +='<dtIniAfast>'+ SubStr( DTOS(SR8->R8_DATAINI), 1, 4 ) + "-" + SubStr( DTOS(SR8->R8_DATAINI), 5, 2 ) + "-" + SubStr( DTOS(SR8->R8_DATAINI), 7, 2 )+'</dtIniAfast>'
				EndIf
				cXml +='<codMotAfast>'+ SR8->R8_TPEFD+'</codMotAfast>'

				If Empty(SR8->R8_CONTAFA) .or. Alltrim(SR8->R8_CONTAFA) $ "0/000/00/"
					cXml +='<infoMesmoMtv>N</infoMesmoMtv>'
				Else
					cXml +='<infoMesmoMtv>S</infoMesmoMtv>'
				EndIf
				If SR8->R8_TPEFD $ "01/03" .And. (!lMiddleware .Or. !Empty(SR8->R8_TIPOAT))
					cXml += '<tpAcidTransito>'+ SR8->R8_TIPOAT+'</tpAcidTransito>'
				EndIf
				If !lMiddleware .Or. !Empty(SR8->R8_OBSAFAS)
					cXml +='<observacao>'+ SR8->R8_OBSAFAS +'</observacao>'
				EndIf
				If cVersEnvio >= "9.0"
					If SR8->(ColumnPos( "R8_DTINIF")) > 0
						If SR8->R8_TPEFD == "15" .And. SR8->R8_DATAINI >= CtoD("19/07/2021") .And. ;
						SRA->RA_CATEFD $ fCatTrabEFD("TCV")+"304|310|312|410" .And. !(SRA->RA_VIEMRAI $ "30|31|35") //Ferias
							cXml +='<perAquis>'
							If !lMiddleware
								cXml +='<dtInicio>'+ DTOS(SR8->R8_DTINIF)+'</dtInicio>'
							Else
								cXml +='<dtInicio>'+ SubStr( DTOS(SR8->R8_DTINIF), 1, 4 ) + "-" + SubStr( DTOS(SR8->R8_DTINIF), 5, 2 ) + "-" + SubStr( DTOS(SR8->R8_DTINIF), 7, 2 )+'</dtInicio>'
							EndIf
							If !Empty(SR8->R8_DTFMF)
								If !lMiddleware
									cXml +='<dtFim>'+ DTOS(SR8->R8_DTFMF)+'</dtFim>'
								Else
									cXml +='<dtFim>'+ SubStr( DTOS(SR8->R8_DTFMF), 1, 4 ) + "-" + SubStr( DTOS(SR8->R8_DTFMF), 5, 2 ) + "-" + SubStr( DTOS(SR8->R8_DTFMF), 7, 2 )+'</dtFim>'
								EndIf
							EndIf
							cXml +='</perAquis>'
						ElseIf SR8->R8_TPEFD == "22" //Mandato eletivo
							cXml +='<infoMandElet>'
							cXml +='<cnpjMandElet>'+ SR8->R8_CNPJE +'</cnpjMandElet>'
							If SRA->RA_CATEFD == "301"
								If SR8->R8_REMUN == "1"
									cXml +='<indRemunCargo>S</indRemunCargo>'
								ElseIf SR8->R8_REMUN == "2"
									cXml +='<indRemunCargo>N</indRemunCargo>'
								EndIf
							EndIf
							cXml +='</infoMandElet>'
						EndIf
					EndIf
				ElseIf SR8->R8_TPEFD $ "01/03"
					If !lNT15
						cXml +='<infoAtestado>'
						cXml +='    <codCID>'+ SR8->R8_CID+'</codCID>'
						cXml +='    <qtdDiasAfast>'+ Alltrim(Str(SR8->R8_DURACAO))+'</qtdDiasAfast>'
						cXml +='    <emitente>'
						cXml +='        <nmEmit>'+ SubStr(SR8->R8_NMMED,1,70)+'</nmEmit>'
						cXml +='        <ideOC>'    + SR8->R8_IDEOC  +   '</ideOC>'
						cXml +='        <nrOc>'     + SR8->R8_CRMMED +   '</nrOc>'
						cXml +='        <ufOC>'     + SR8->R8_UFCRM  +   '</ufOC>'
						cXml +='    </emitente>'
						cXml +='</infoAtestado>'
					Else
						cXml +='<infoAtestado>'
						If !Empty(SR8->R8_CID)
							cXml +='    <codCID>'+ SR8->R8_CID+'</codCID>'
						Endif
						cXml +='    <qtdDiasAfast>'+ Alltrim(Str(SR8->R8_DURACAO))+'</qtdDiasAfast>'
						If !Empty(SR8->R8_IDEOC) .And. !Empty(SR8->R8_NMMED) .And. !Empty(SR8->R8_CRMMED) .And. !Empty(SR8->R8_UFCRM)
							cXml +='    <emitente>'
							cXml +='        <nmEmit>'+ SubStr(SR8->R8_NMMED,1,70)+'</nmEmit>'
							cXml +='        <ideOC>'    + SR8->R8_IDEOC  +   '</ideOC>'
							cXml +='        <nrOc>'     + SR8->R8_CRMMED +   '</nrOc>'
							cXml +='        <ufOC>'     + SR8->R8_UFCRM  +   '</ufOC>'
							cXml +='    </emitente>'
						Endif
					Endif
				EndIf
				If SR8->R8_TPEFD == "14"
					cXml +='<infoCessao>'
					cXml +='<cnpjCess>'+ SR8->R8_CNPJCES+'</cnpjCess>'
					cXml +='<infOnus>'+ SR8->R8_TPCES+'</infOnus>'
					cXml +='</infoCessao>'
				EndIf
				If SR8->R8_TPEFD == "24" .Or. ( SR8->R8_TPEFD $ "22/23/24" .And. cVersEnvio < "9.0" )
					cXml +='<infoMandSind>'
					cXml +='    <cnpjSind>'+ SR8->R8_CNPJSIN+'</cnpjSind>'
					cXml +='    <infOnusRemun>'+ SR8->R8_TPSIND+'</infOnusRemun>'
					cXml +='</infoMandSind>'
				EndIf
				cXml +='</iniAfastamento>'
				cXml +='<fimAfastamento>'
				If !lMiddleware
					cXml +='<dtTermAfast>'+ dtos(SR8->R8_DATAFIM)+' </dtTermAfast>'
				Else
					cXml +='<dtTermAfast>'+ SubStr( DTOS(SR8->R8_DATAFIM), 1, 4 ) + "-" + SubStr( DTOS(SR8->R8_DATAFIM), 5, 2 ) + "-" + SubStr( DTOS(SR8->R8_DATAFIM), 7, 2 )+'</dtTermAfast>'
				EndIf
				If !lMiddleware
					cXml +='<codMotAfast>'+ SR8->R8_TPEFD+' </codMotAfast>'
					if Empty(SR8->R8_CONTAFA) .or. Alltrim(SR8->R8_CONTAFA) $ "0/000/00/   "
						cXml +='<infoMesmoMtv>N</infoMesmoMtv>'
					else
						cXml +='<infoMesmoMtv>S</infoMesmoMtv>'
					EndIf
				EndIf
				cXml +='</fimAfastamento>'
				cXml +='</infoAfastamento>'
				cXml +='</evtAfastTemp>'
				cXml +='</eSocial>'
			EndIf
		Else//Exclusão
			If lContinua
				cStatNew := ""
				cOperNew := ""
				cRetfNew := ""
				cRecibAnt:= ""
				cKeyMid	 := ""
				nRecEvt	 := 0
				lNovoRJE := .T.
				aDados	 := {}
				InExc3000(@cXml,'S-2230',Iif(!lMiddleware, Alltrim(SR8->R8_TAFKI), cRecibXML),SRA->RA_CIC,SRA->RA_PIS, Nil, Nil, Nil, Nil, cFilEnv, lAdmPubl, cTpInsc, cNrInsc, cId, @cStatNew, @cOperNew, @cRetfNew, @nRecEvt, @lNovoRJE, @cKeyMid, @aErros)
			EndIf
		EndIf
	EndIf

	If !Empty(cXml)
		GrvTxtArq(Alltrim(cXml), IIf(nOperation != 5, "S2230", "S3000"), SRA->RA_CIC)
	EndIf

	If lExec .And. !Empty(cXml)
		If nOperation <> 5
			If !lMiddleware
				aErros := TafPrepInt( cEmpAnt, cFilEnv, cXml, Alltrim(SR8->R8_TAFKI) , "3", "S2230", , /*cTicket*/, , , , "GPE", , /*cPredeces*/ )
			Else
				If !( lRet := fGravaRJE( aDados, cXml, lNovoRJE, nRec2230 ) )
					cMsgErro := STR0142//"Ocorreu um erro na gravação do registro na tabela RJE"
				EndIf
			EndIf
		Else
			If !lMiddleware
				aErros := TafPrepInt( cEmpAnt, cFilEnv, cXml, Alltrim(SR8->R8_TAFKI) , "3", "S3000", , /*cTicket*/, , , , "GPE", , /*cPredeces*/ )
			Else
				If cStat2230 != "4"
					If !( lRet := fExcluiRJE( nRec2230 ) )
						cMsgErro := STR0144//"Ocorreu um erro na exclusão do registro na tabela RJE"
					EndIf
				Else
					aAdd( aDados, { xFilial("RJE", cFilEnv), cFilEnv, cTpInsc, Iif( cTpInsc == "1" .And. !lAdmPubl, SubStr(cNrInsc, 1, 8), cNrInsc ), "S3000", Space(6), cRecibXML, cId, cRetfNew, "12", cStatNew, Date(), Time(), cOperNew, NIL, NIL } )
					If !(fGravaRJE( aDados, cXML, lNovoRJE, nRecEvt ))
						cMsgErro := STR0142//"Ocorreu um erro na gravação do registro na tabela RJE"
					EndIf
				EndIf
			EndIf
		EndIf

		If Len(aErros) > 0
			FeSoc2Err( aErros[1], @cMsgErro ,IIF(aErros[1]!='000026',1,2))
			If !Funname() $ 'GPEM060/GPEM020A'
				fEFDMsgErro(cMsgErro)
			EndIf
			lRet:= IIF(aErros[1]!='000026',.F.,.T.)
		Elseif nOperation <> 5
			If lOffline
				SR8->( RecLock("SR8", .F.) )
			EndIf
			SR8->R8_INTGTAF := DDATABASE
			SR8->R8_TPEFDAN := SR8->R8_TPEFD
			If lOffline
				SR8->( MsUnlock() )
			EndIf
		EndIf
	EndIf

	If !IsBlind() .And. !Funname()  $ 'GPEM060/GPEM020A'
		If !Empty(cXml) .And. lRet .And. (Empty(aErros) .Or. aErros[1] != '000026') .And. !lLote
			fEFDMsg()
		EndIf
		If !Empty(cMsgErro)
			If !lOffline
				oModel := FwModelActive()
				oModel:SetErrorMessage("",,oModel:GetId(),"","",cMsgErro)
			Else
				Help( ,, OemToAnsi(STR0088),, OemToAnsi(cMsgErro), 1, 0 ) //"Atenção"
			EndIf
		EndIf
	EndIf

	//Restaura cFilAnt
	cFilAnt	:= cFilBkp

	RestArea(aAreaSRA)
	RestArea(aAreaSR8)
	If !lMiddleware
		RestArea(aAreaCM6)
	EndIf
Return lRet

/*/{Protheus.doc} fQuitadMes
Verifica se o período aquisitivo foi quitado no mês atual ainda em aberto
@author gabriel.almeida
@since 14/09/2018
@version 1.0
@return lQuitado, retorno lógico que informa se o período foi quitado no mês ou não
/*/
Static Function fQuitadMes()
	Local nDiasFerM := 0

	SRH->(DbSetOrder(1))
	If SRH->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + DToS(SRF->RF_DATABAS) + cPeriodo ) )
		While SRH->(RH_FILIAL + RH_MAT + DToS(RH_DATABAS) == SRA->(RA_FILIAL + RA_MAT) + DToS(SRF->RF_DATABAS))
			nDiasFerM += SRH->RH_DFERIAS + SRH->RH_DABONPE
			SRH->( DbSkip() )
		EndDo
	EndIf
Return ( lQuitMes := ( ( SRF->RF_DFERANT + nDiasFerM ) == aTabFer[3] ) )

/*/{Protheus.doc} fgp030GetDVen
Verifica os dias vencidos de calculos anteriores do mesmo periodo para o calculo proporcional das medias
@author M. Silveira
@since 28/11/2018
@version 1.0
@return nDVenc, traz a quantidade de dias
/*/
Function fgp030GetDVen()

Local nDVenc := 0
Local aAreaSRH := SRH->( getArea() )

SRH->(DbSetOrder(1))
If SRH->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + DToS(SRF->RF_DATABAS) ) )
	While SRH->(RH_FILIAL + RH_MAT + DToS(RH_DATABAS) == SRA->(RA_FILIAL + RA_MAT) + DToS(SRF->RF_DATABAS))
		If cPeriodo >= SRH->RH_PERIODO
			nDVenc += SRH->RH_DFERVEN
		EndIf	
		SRH->( DbSkip() )
	EndDo
	nDVenc := Min( 30, nDVenc )
EndIf

RestArea( aAreaSRH )

Return ( nDVenc )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RstGpm030	  ³Autor ³Marco Nakazawa	   ³ Data ³06/02/2019³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Reinicializar os valores das variáveis Statics utilizadas    ³
³          ³para o eSocial .			 									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                    	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstGpm030()

lIntegDef 	:= FindFunction("GETROTINTEG") .And. FindFunction("FWHASEAI")
lRefTrab	:= FindFunction("fRefTrab") .And. fRefTrab("F")
lIntTAF		:= (GetMv("MV_RHTAF",.T., .F.) == .T. .AND. Val(GetMv('MV_FASESOC',.T.,' ')) >= 1  )
lMiddleware := If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )

Return( NIL )


/*/{Protheus.doc} fDelHist
/Delete historico de medias
@author flavio.scorrea
@since 23/10/2019
/*/
Static Function fDelHist(lDel, oView)
Local lHistMed		:= AliasInDic("RJK") .And. AliasInDic("SRP")

If (lDel .Or. (oView:GetModel():nOperation != 1 .And. oView:GetModel():nOperation != 5) )
	If lHistMed .And. Empty(cIdHistMed)
		If fTemHMed(M->RH_DATAINI,,M->RH_PERIODO,M->RH_NPAGTO,M->RH_ROTEIR)
			cIdHistMed := RJK->RJK_ID
		Endif
	EndIf
	If lHistMed .And. !Empty(cIdHistMed)
		fDelHMedId(cIdHistMed)
	EndIf
	If !lDel .and. __lMemCalc //Exclui informações da memória de cálculo, quando existir
		fDelMemCalc(M->RH_FILIAL, M->RH_MAT, M->RH_PROCES, M->RH_PERIODO, M->RH_ROTEIR, M->RH_NPAGTO)
	EndIf
EndIf
Return

/*/{Protheus.doc} fCtrTitLg
Imprime log com títulos existentes do funcionário (quando existe controle de títulos na base MV_BTITFER igual a 1 ou 2)
@author		raquel.anrade
@since		04/08/2020
@version 1.0
/*/
Static Function fCtrTitLg()
Local aLog			:= {}
Local aTitleLog		:= {}
Local nX			:= 0
Local nPosLog		:= 0
Local lRet			:= .T.

	If !IsBlind()
		If Empty( aLog )
			aAdd( aTitleLog, STR0156 )	//"Log de Ocorrencias do Calculo de Férias"
			aAdd( aLog, {} )
		EndIf

		nPosLog := Len( aLog )
		For nX := 1 To Len( aLogErros )
			aAdd( aLog[ nPosLog ], aLogErros[ nX ] )
		Next nX
		MsAguarde( { || fMakeLog( aLog , aTitleLog , "GPEM030" , NIL , FunName() , STR0156 ) } ,  STR0156 ) //"Log de Ocorrencias do Cálculo de Férias"
		aLogErros	:= {}
	EndIf

Return lRet

/*/{Protheus.doc} fExisTitFE
// Verifica se existe Título Definido pelo Usuário para Férias
@author raquel.andrade
@since 05/08/2020
@version 1.0
@return Logico, Retorna .T. se encontrou o titulo e .F. se não encontrou
@type function
/*/
Function fExisTitFE()
Local lRet 		:= .F.
Local cCtrlTit	:= ""
Local nIndex	:= 0

// Utiliza conteúdo do parâmetro MV_BTITFER (variavel cCtrlTit)
// 0 - Não realiza tratamento
// 1 - Exibe mensagem para o usuário mas não bloqueia, usuário escolhe prosseguir ou não - gera log com Títulos
// 2 - Exibe mensagem para o usuário e bloqueia - gera log com Títulos
cCtrlTit 	:= SuperGetMv("MV_BTITFER",,"0")

If cCtrlTit == "0"
	lRet := .F.
ElseIf cCtrlTit == "1"
	If TCCanOpen(RetSqlname("RJ1")) .and. Retorder("RJ1","RJ1_FILIAL+RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT") > 0
		nIndex	:= Retorder("RJ1","RJ1_FILIAL+RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT")

		dbSelectArea("RJ1")
		RJ1->(dbSetOrder(nIndex)) // RJ1_FILIAL+ RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT
		If RJ1->(dbSeek(SRH->RH_FILIAL+SRH->RH_PROCES+SRH->RH_ROTEIR+SRH->RH_PERIODO+SRH->RH_NPAGTO+DTOS(SRH->RH_DATAINI)+SRH->RH_FILIAL+SRH->RH_MAT))
			aAdd( aLogErros, OemToAnsi(STR0155) + OemToAnsi(STR0151) ) // "Existe(m) Título(s) gerado(s) sobre essas Férias."###"Consulte o(s) Título(s) abaixo em Manutenção de Títulos:"
			While RJ1->(!Eof()) .And. (	RJ1->RJ1_FILIAL+RJ1->RJ1_PROCES+RJ1->RJ1_ROTEIR+RJ1->RJ1_PERIOD+RJ1->RJ1_SEMANA+DTOS(RJ1->RJ1_DTGERA)+RJ1->RJ1_FILFUN+RJ1->RJ1_MAT == SRH->RH_FILIAL+SRH->RH_PROCES+SRH->RH_ROTEIR+SRH->RH_PERIODO+SRH->RH_NPAGTO+DTOS(SRH->RH_DATAINI)+SRH->RH_FILIAL+SRH->RH_MAT )
				aAdd( aLogErros, OemToAnsi(STR0158) + RJ1->RJ1_FILIAL + " " + OemToAnsi(STR0153) + RJ1->RJ1_NUMTIT ) // Filial:###Número do Título:
				("RJ1")->(DbSkip())
			EndDo

			lRet := !MsgNoYes(OemToAnsi(STR0155) + OemToAnsi(STR0157),OemToAnsi(STR0088)) //"Existe(m) Título(s) gerado(s) sobre essas Férias. A Exclusão ou Recálculo das Férias sem a exclusão do título anterior pode gerar duplicidade de titulos. Deseja Continuar?"                                                                                                                                                                                                                                                                                                                                                                                      "

		EndIf
		RJ1->(dbCloseArea())
	EndIf
ElseIf cCtrlTit == "2"
	If TCCanOpen(RetSqlname("RJ1")) .and. !Empty(RJ1->(INDEXKEY(3)))
		dbSelectArea("RJ1")
		RJ1->(dbSetOrder(3)) // RJ1_FILIAL+ RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT
		If RJ1->(dbSeek(SRH->RH_FILIAL+SRH->RH_PROCES+SRH->RH_ROTEIR+SRH->RH_PERIODO+SRH->RH_NPAGTO+DTOS(SRH->RH_DATAINI)+SRH->RH_FILIAL+SRH->RH_MAT))
			aAdd( aLogErros, OemToAnsi(STR0155) + OemToAnsi(STR0151) ) // "Existe Título(s) gerado(s) sobre essas Férias."###"Consulte o(s) Título(s) abaixo em Manutenção de Títulos:"
			While RJ1->(!Eof()) .And. (	RJ1->RJ1_FILIAL+RJ1->RJ1_PROCES+RJ1->RJ1_ROTEIR+RJ1->RJ1_PERIOD+RJ1->RJ1_SEMANA+DTOS(RJ1->RJ1_DTGERA)+RJ1->RJ1_FILFUN+RJ1->RJ1_MAT == SRH->RH_FILIAL+SRH->RH_PROCES+SRH->RH_ROTEIR+SRH->RH_PERIODO+SRH->RH_NPAGTO+DTOS(SRH->RH_DATAINI)+SRH->RH_FILIAL+SRH->RH_MAT )
				aAdd( aLogErros, OemToAnsi(STR0158) + RJ1->RJ1_FILIAL + " " + OemToAnsi(STR0153) + RJ1->RJ1_NUMTIT ) // Filial:###Número do Título:
				("RJ1")->(DbSkip())
			EndDo

			lRet := .T.
		EndIf
		RJ1->(dbCloseArea())
	EndIf

EndIf

Return lRet

/*/{Protheus.doc} VldVazioMP
// Valida se poderá efetuar o cálculo apenas do abno pecuniário referente a MP 927/2020
@author Leandro Drumond
@since 18/12/2020
@version 1.0
@return Logico
@type function
/*/
Function VldVazioMP()
Local aArea     := GetArea()
Local cRotFer	:= fGetCalcRot("3")
Local dIniMP	:= CtoD("22/03/2020") //Inicio da vigência da MP
Local dFimMP    := CtoD("19/07/2020") //Fim da vigência da MP
Local cPdTer    := aCodFol[77,1]
Local lRet      := .F.

DbSelectArea("SRH")
DbSetOrder(3)

DbSelectArea("SRR")
DbSetOrder(4) //RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR+RR_SEMANA+RR_PD+RR_CC+RR_SEQ+DTOS(RR_DATA)

If SRH->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cRotFer))
	While SRH->( !Eof() .and. RH_FILIAL + RH_MAT + RH_ROTEIR == SRA->RA_FILIAL + SRA->RA_MAT + cRotFer )
		If SRH->RH_DATAINI >= dIniMP .and. SRH->RH_DATAINI <= dFimMP
			lRet := .T.
			If SRR->(dbSeek(SRH->RH_FILIAL + SRH->RH_MAT + SRH->RH_PERIODO + SRH->RH_ROTEIR + SRH->RH_NPAGTO))
				While SRR->(!Eof() .and. RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR+RR_SEMANA == SRH->RH_FILIAL + SRH->RH_MAT + SRH->RH_PERIODO + SRH->RH_ROTEIR + SRH->RH_NPAGTO )
					If SRR->RR_PD == cPdTer
						lRet := .F. //Se foi pago 1/3 de férias não utilizou a MP
						Exit
					EndIf
					SRR->(DbSkip())
				EndDo
			EndIf
		EndIf
		SRH->(DbSkip())
	EndDo
EndIf

RestArea(aArea)

lTerFerMP := lRet

Return lRet

/*/{Protheus.doc} fVldFerPen
Valida período quando houve férias coletivas para funcionário com menos de um ano para verificar período correto
@author Allyson Mesashi
@since 08/06/2021
@version 1.0
/*/
Static Function fVldFerPen( aPerFerias ) 

Local aAreaSRH	:= SRH->( GetArea() )
Local nDiasDir 	:= SRF->RF_DIASDIR
Local nFerAnt	:= 0

SRH->( dbSetOrder(1) )

If SRH->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + dToS(aPerFerias[1]) ) )
	While SRH->( !Eof() ) .And. SRH->RH_FILIAL+SRH->RH_MAT+dToS(SRH->RH_DATABAS) == SRA->RA_FILIAL+SRA->RA_MAT+dToS(aPerFerias[1])
		nFerAnt	+= (SRH->RH_DFERIAS+SRH->RH_DABONPE)
		SRH->( dbSkip() )
	EndDo
	aPerFerias[11] := nDiasDir - nFerAnt
	aPerFerias[14] := nFerAnt
EndIf

RestArea(aAreaSRH)

Return

/*/{Protheus.doc} fMsg1870
Mensagem de alerta sobre o ID 1870
@author Allyson Mesashi
@since 07/10/2021
/*/
Static Function fMsg1870()

Local oButton1
Local oCheckBo1
Local lCheckBo1 	:= .F.
Local oGroup1
Local oPanel1
Local oSay1
Local oSay2
Local lChkMsg 		:= .F.
Local oDlg
Local oProfile 		:= FWProfile():New()

Default lTemCampo 	:= .F.

oProfile:SetUser( RetCodUsr() )
oProfile:SetProgram( "GPEM020" )
oProfile:SetTask( "MSGID1870" )
oProfile:Load()

lChkMsg := (oProfile:GetStringProfile() == "")

If lChkMsg
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0010) FROM 000, 000  TO 200, 500 COLORS 0, 16777215 PIXEL //#STR0010 = "Cálculo de Férias"

		@ 000, 000 MSPANEL oPanel1 SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
		@ 005, 012 GROUP oGroup1 TO 055, 237 PROMPT OemToAnsi(STR0088) OF oPanel1 COLOR 0, 16777215 PIXEL //#STR0088 = "Atenção"
		@ 017, 017 SAY oSay1 PROMPT OemToAnsi(STR0172 + CRLF + STR0173) SIZE 215, 035 OF oPanel1 COLORS 0, 16777215 PIXEL //#STR0172 = "É obrigatório possuir verbas vinculadas aos IDs 1870, 1871 e 1872 devido exigência do eSocial"|STR0107 = "Verifique a documentação conforme orientações no link abaixo"
		@ 063, 012 SAY oSay2 PROMPT "https://tdn.totvs.com/x/uk0wJg" SIZE 095, 007 OF oPanel1 COLORS 0, 16777215 PIXEL
		@ 080, 012 CHECKBOX oCheckBo1 VAR lCheckBo1 PROMPT OEMToAnsi(STR0171) SIZE 067, 008 OF oPanel1 COLORS 0, 16777215 PIXEL //#STR0171 = "Não exibir novamente"
		@ 070, 200 BUTTON oButton1 PROMPT "OK" SIZE 037, 012 OF oPanel1 PIXEL

		oSay2:bLClicked := {|| ShellExecute("open", "https://tdn.totvs.com/x/uk0wJg", "", "", 1) }

		oButton1:bLClicked := {|| oDlg:End() }

	ACTIVATE MSDIALOG oDlg CENTERED

	If lCheckBo1		
		oProfile:SetStringProfile("*")
		oProfile:Save()
	EndIf
EndIf

Return

/*/{Protheus.doc}fUserTAE
Cria tela para informar usuário e senha para acesso ao TAE
@author Allyson Luiz Mesashi
@since 27/01/2022
@version P12
/*/
Function fUserTAE()

Local cMsg1			:= ""
Local cSenha		:= Space(50)
Local cUsuario		:= Space(50)
Local nOpca			:= 0
Local oDlg			:= Nil
Local oSenha		:= Nil
Local oUsr			:= Nil

cMsg1 := OemToAnsi(STR0183) + CRLF //"Essa rotina permite configurar o usuário e senha para integração no" 
cMsg1 += OEMToAnsi(STR0184) + CRLF //"Totvs Assinatura Eletrônica." 

DEFINE MSDIALOG oDlg TITLE STR0182 From 10,30 To 200,500 OF oMainWnd PIXEL//"Configuração Totvs Assinatura Eletrônica"

	@ 6,4  SAY OemToAnsi(cMsg1) OF oDlg  PIXEL

	@ 35,4  SAY OemToAnsi(STR0185) OF oDlg  PIXEL //"Usuário:"
	@ 34,30 MSGET oUsr VAR cUsuario  SIZE 140,08 PICTURE  VALID .T. OF oDlg PIXEL 

	@ 49,4  SAY OemToAnsi(STR0186) OF oDlg PIXEL //"Senha:"
	@ 48,30 MSGET oSenha VAR cSenha  SIZE 140,08 PICTURE  VALID .T. OF oDlg PIXEL PASSWORD 

	DEFINE SBUTTON FROM 75,10 TYPE 1 ACTION (nOpca := 1, Iif(fGrvUSTAE(cUsuario, cSenha), oDlg:End(), .F.)) ENABLE OF oDlg
	DEFINE SBUTTON FROM 75,40 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg
	
ACTIVATE MSDIALOG oDlg CENTERED
Return

/*/{Protheus.doc}fGrvUSTAE
Efetua gravacao dos dados no parametro
@author Allyson Luiz Mesashi
@since 27/01/2022
@version P12
/*/
Static Function fGrvUSTAE(cUsuario, cSenha)

Local lRet := .T.

If !Empty(cUsuario) .And. !Empty(cSenha)
	PutMv( "MV_RHTAEUS", rc4crypt( AllTrim(cUsuario), "123456789", .T.) )
	PutMv( "MV_RHTAEPW", rc4crypt( AllTrim(cSenha), "123456789", .T.) )
Else
	MsgAlert(OEMToAnsi(STR0187), STR0088)//"Efetue o preenchimento do usuário e da senha"##"Atenção"
	lRet := .F.
EndIf

Return lRet

/*/{Protheus.doc} fMsg1891
Mensagem de alerta sobre o ID 1891
@author Suelen Ferreira de Lima
@since 25/07/2022
/*/
Static Function fMsg1891()
Local oButton1
Local oCheckBo1
Local lCheckBo1 	:= .F.
Local oGroup1
Local oPanel1
Local oSay1
Local lChkMsg 		:= .F.
Local oDlg
Local oProfile 		:= FWProfile():New()
Local cMsg 			:= ""

Default lTemCampo 	:= .F.

oProfile:SetUser( RetCodUsr() )
oProfile:SetProgram( "GPEM030" )
oProfile:SetTask( "MSGID1891" )
oProfile:Load()

lChkMsg := (oProfile:GetStringProfile() == "")

If lChkMsg

	cMsg := (STR0194)

	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0197) FROM 000, 000  TO 200, 500 COLORS 0, 16777215 PIXEL 

		@ 000, 000 MSPANEL oPanel1 SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
		@ 005, 012 GROUP oGroup1 TO 060, 237 PROMPT OemToAnsi(STR0088) OF oPanel1 COLOR 0, 16777215 PIXEL 
		@ 022, 017 SAY oSay1 PROMPT OemToAnsi(cMsg)  SIZE 215, 025 OF oPanel1 COLORS 0, 16777215 PIXEL 
		@ 063, 017 SAY oSay1 PROMPT OemToAnsi(STR0201 + "https://tdn.totvs.com/x/uk0wJg")  SIZE 215, 025 OF oPanel1 COLORS 0, 16777215 PIXEL 

		@ 070, 160 BUTTON oButton1 PROMPT (STR0200) SIZE 037, 012 OF oPanel1 PIXEL
		@ 070, 200 BUTTON oButton2 PROMPT (STR0006) SIZE 037, 012 OF oPanel1 PIXEL

		@ 080, 012 CHECKBOX oCheckBo1 VAR lCheckBo1 PROMPT OEMToAnsi(STR0171) SIZE 067, 008 OF oPanel1 COLORS 0, 16777215 PIXEL

		oButton1:bLClicked := {|| ShellExecute("open","https://tdn.totvs.com/x/uk0wJg","","",1) }
		oButton2:bLClicked := {|| oDlg:End() }

	ACTIVATE MSDIALOG oDlg CENTERED

	If lCheckBo1		
		oProfile:SetStringProfile("*")
		oProfile:Save()
	EndIf

EndIf

Return

/*/{Protheus.doc} fMsg1892
Mensagem de alerta sobre o ID 1892
@author Suelen Ferreira de Lima
@since 29/06/2022
/*/
Static Function fMsg1892()
Local oButton1
Local oCheckBo1
Local lCheckBo1 	:= .F.
Local oGroup1
Local oPanel1
Local oSay1
Local lChkMsg 		:= .F.
Local oDlg
Local oProfile 		:= FWProfile():New()
Local cMsg 			:= ""

Default lTemCampo 	:= .F.

oProfile:SetUser( RetCodUsr() )
oProfile:SetProgram( "GPEM030" )
oProfile:SetTask( "MSGID1892" )
oProfile:Load()

lChkMsg := (oProfile:GetStringProfile() == "")

If lChkMsg

	cMsg := (STR0195)

	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0198) FROM 000, 000  TO 200, 500 COLORS 0, 16777215 PIXEL 

		@ 000, 000 MSPANEL oPanel1 SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
		@ 005, 012 GROUP oGroup1 TO 060, 237 PROMPT OemToAnsi(STR0088) OF oPanel1 COLOR 0, 16777215 PIXEL 
		@ 022, 017 SAY oSay1 PROMPT OemToAnsi(cMsg)  SIZE 215, 025 OF oPanel1 COLORS 0, 16777215 PIXEL 
		@ 063, 017 SAY oSay1 PROMPT OemToAnsi(STR0201 + "https://tdn.totvs.com/x/uk0wJg")  SIZE 215, 025 OF oPanel1 COLORS 0, 16777215 PIXEL 

		@ 070, 160 BUTTON oButton1 PROMPT (STR0200) SIZE 037, 012 OF oPanel1 PIXEL
		@ 070, 200 BUTTON oButton2 PROMPT (STR0006) SIZE 037, 012 OF oPanel1 PIXEL

		@ 080, 012 CHECKBOX oCheckBo1 VAR lCheckBo1 PROMPT OEMToAnsi(STR0171) SIZE 067, 008 OF oPanel1 COLORS 0, 16777215 PIXEL

		oButton1:bLClicked := {|| ShellExecute("open","https://tdn.totvs.com/x/uk0wJg","","",1) }
		oButton2:bLClicked := {|| oDlg:End() }

	ACTIVATE MSDIALOG oDlg CENTERED

	If lCheckBo1		
		oProfile:SetStringProfile("*")
		oProfile:Save()
	EndIf

EndIf

Return

/*/{Protheus.doc} fSendSRAApi
Processo para enviar atualização de status de Férias
integração via API REST.
@since	13/06/2023
@autor	raquel.andrade
@version 1.0
/*/
Static Function fSendSRAApi(cOperacao)
Local dDtBase   := dDataBase
Local cHoraAt   := Time()
Local cTmpEmp   := cEmpAnt
Local cProces   := "SRA"
Local cUserId   := SubStr(cUsuario,7,15)
Local cTmpMat   := SRA->RA_MAT
Local cTmpFil   := xFilial ("SRA",SRA->RA_FILIAL)
Local cChave    := cTmpEmp + "|" + cTmpFil + "|" + cTmpMat

fSetInforRJP(cTmpFil, cTmpMat, cProces, cChave, cOperacao,  dDtBase, cHoraAt, cUserId)

Return (.T.)

/*/{Protheus.doc} fVldL14457
Validação se a empregada se enquandra nas regras da Lei 14.457/2022 referente antecipação das férias e postergação do 1/3
@since	01/08/2023
@autor	Allyson Luiz Mesashi
/*/
Function fVldL14457( dDtIniFer, nDiasFer, nDiasAbo, nDFerVen, dDataBas )

Local aAreaSRB  := SRB->( GetArea() )
Local lRet      := .F.
Local nIdade    := 0
Local nGuarda   := 99

If nDiasFer+nDiasAbo > nDFerVen .Or. dDtIniFer < dDataBas
    SRB->( dbSetOrder(1) )//RB_FILIAL+RB_MAT+RB_COD

    If SRB->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT ) )
        While SRB->( !EoF() ) .And. SRB->RB_FILIAL+SRB->RB_MAT == SRA->RA_FILIAL+SRA->RA_MAT
            nGuarda := 99
            nIdade  := Calc_Idade( dDtIniFer, SRB->RB_DTNASC )
            If !Empty(SRB->RB_DTINIVI)
                nGuarda := Calc_Idade( dDtIniFer, SRB->RB_DTINIVI )
            EndIf
            If ( SRB->RB_TPDEP $ "03/04/05/13/99" .And. nIdade <= 2 ) .Or. ( SRB->RB_TPDEP $ "03/04/05/06/07/08/10/13/99" .And. nGuarda <= 2 )
                lRet := .T.
                Exit
            EndIf
            SRB->( dbSkip() )
        End
    EndIf
    RestArea( aAreaSRB )
EndIf

Return lRet

/*/{Protheus.doc} fGrvL14457
Efetua gravação dos lançamentos de 1/3 na tabela SRK
@since	01/08/2023
@autor	Allyson Luiz Mesashi
/*/
Function fGrvL14457( aPdUmTSRK, dDataIni )

Local aAreaSRK  := SRK->( GetArea() )
Local cPerIni   := cValToChar( Year( dDataIni ) )+"12"
Local dDtVenc   := sToD( cValToChar( Year( dDataIni ) )+"1220" )
Local lNovo     := .F.
Local nCont     := 0

DEFAULT lItemClVl  := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3" // Define se trabalha com item e classe contabil

SRK->( dbSetOrder(4) )//RK_FILIAL+RK_MAT+RK_PD+RK_PERINI+RK_NUMPAGO

For nCont := 1 To Len(aPdUmTSRK)
    lNovo := SRK->( !dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+aPdUmTSRK[nCont, 1]+cPerIni+"01" ) ) .Or. SRK->RK_NUMID != "FER-"+cValToChar( SRH->( Recno() ) )
    If SRK->( RecLock( "SRK", lNovo ) )
        SRK->RK_FILIAL	:= SRA->RA_FILIAL
        SRK->RK_MAT		:= SRA->RA_MAT
        SRK->RK_PD		:= aPdUmTSRK[nCont, 1]
        SRK->RK_VALORTO	:= aPdUmTSRK[nCont, 2]
        SRK->RK_PARCELA := 1
        SRK->RK_VALORPA := aPdUmTSRK[nCont, 2]
        SRK->RK_DOCUMEN	:= cValToChar( SRH->( Recno() ) )
        SRK->RK_DTVENC	:= dDtVenc
        SRK->RK_VLSALDO := aPdUmTSRK[nCont, 2]
        SRK->RK_EMPCONS	:= "2"
        SRK->RK_CC		:= SRA->RA_CC
		If lItemClVl
			SRK->RK_ITEM	:= SRA->RA_ITEM
			SRK->RK_CLVL	:= SRA->RA_CLVL
		EndIf
        SRK->RK_DTMOVI	:= dDataIni
        SRK->RK_PERINI  := cPerIni
        SRK->RK_NUMPAGO := "01"
        SRK->RK_PROCES  := SRA->RA_PROCES
        SRK->RK_STATUS  := "2"
        SRK->RK_NUMID   := "FER-"+cValToChar( SRH->( Recno() ) )
        SRK->RK_DTREF	:= dDataIni

        SRK->( MsUnLock() )
    EndIf
Next nCont

RestArea( aAreaSRK )

Return

/*/{Protheus.doc} fExcL14457
Efetua exclusão dos lançamentos de 1/3 na tabela SRK
@since	03/08/2023
@autor	Allyson Luiz Mesashi
/*/
Static Function fExcL14457(nRecSRH)

Local aAreaSRK  := SRK->( GetArea() )
Local cChave    := SRH->RH_FILIAL+SRH->RH_MAT+"FER-"+cValToChar( nRecSRH )

SRK->( dbSetOrder(2) )//RK_FILIAL+RK_MAT+RK_NUMID

If SRK->( dbSeek( cChave ) )
    While SRK->( !EoF() ) .And. SRK->RK_FILIAL+SRK->RK_MAT+RTrim(SRK->RK_NUMID) == cChave
        If SRK->RK_STATUS == "2" .And. SRK->( RecLock( "SRK", .F. ) )
            SRK->( dbDelete() )
            SRK->( MsUnLock() )
        EndIf
        SRK->( dbSkip() )
    End
EndIf

RestArea( aAreaSRK )

Return

/*/{Protheus.doc} fOpcPostUmT
X3_CBOX do campo RH_POSTUMT
@author Allyson Luiz Mesashi
@since 03/08/2023
/*/
Function fOpcPostUmT()

Local cOpcBox := STR0210//"1=Sem direito;2=Com direito, mas sem postergar;3=Com direito e 1/3 postergado"

Return cOpcBox

/*/{Protheus.doc} fVldPostUmT
X3_VALID do campo RH_POSTUMT
@author Allyson Luiz Mesashi
@since 03/08/2023
/*/
Function fVldPostUmT()

Local lRet := &( ReadVar() ) $ "1/2/3"

Return lRet

/*/{Protheus.doc} fMsgL14457
Mensagem de alerta sobre a Lei 14.457/2022
@author Allyson Mesashi
@since 28/08/2023
/*/
Static Function fMsgL14457( nMsg )

Local oButton1
Local oCheckBo1
Local lCheckBo1 	:= .F.
Local oGroup1
Local oPanel1
Local oSay1
Local oSay2
Local lChkMsg 		:= .F.
Local oDlg
Local oProfile 		:= FWProfile():New()

Default lTemCampo 	:= .F.

oProfile:SetUser( RetCodUsr() )
oProfile:SetProgram( "GPEM030" )
oProfile:SetTask( Iif( nMsg == 1, "MSGLEI14457_1", "MSGLEI14457_2" ) )
oProfile:Load()

lChkMsg := (oProfile:GetStringProfile() == "")

If lChkMsg
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0211) FROM 000, 000  TO 200, 500 COLORS 0, 16777215 PIXEL//"Lei 14.457/2022"

		@ 000, 000 MSPANEL oPanel1 SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
		@ 005, 012 GROUP oGroup1 TO 055, 237 PROMPT OemToAnsi(STR0088) OF oPanel1 COLOR 0, 16777215 PIXEL //"Atenção"
		@ 017, 017 SAY oSay1 PROMPT OemToAnsi( Iif( nMsg == 1, STR0212, STR0213 ) + CRLF + STR0173) SIZE 215, 035 OF oPanel1 COLORS 0, 16777215 PIXEL //"Empregado(a) se enquadra nas regras da Lei 14.457/2022 que permite a postergação do pagamento do 1/3 (um terço)."##"Empregado(a) com postergação do pagamento do 1/3 (um terço) conforme Lei 14.457/2022."##"Verifique a documentação conforme orientações no link abaixo"
		@ 063, 012 SAY oSay2 PROMPT "https://tdn.totvs.com/x/t1WQLg" SIZE 095, 007 OF oPanel1 COLORS 0, 16777215 PIXEL
		@ 080, 012 CHECKBOX oCheckBo1 VAR lCheckBo1 PROMPT OEMToAnsi(STR0171) SIZE 067, 008 OF oPanel1 COLORS 0, 16777215 PIXEL //"Não exibir novamente"
		@ 070, 200 BUTTON oButton1 PROMPT "OK" SIZE 037, 012 OF oPanel1 PIXEL

		oSay2:bLClicked := {|| ShellExecute("open", "https://tdn.totvs.com/x/t1WQLg", "", "", 1) }

		oButton1:bLClicked := {|| oDlg:End() }

	ACTIVATE MSDIALOG oDlg CENTERED

	If lCheckBo1		
		oProfile:SetStringProfile("*")
		oProfile:Save()
	EndIf
EndIf

Return

/*/{Protheus.doc} fDelRU6
/Delete dependente da RU6
@author Bruno Costa
@since 15/09/2023
/*/
Static Function fDelRU6(lDel, oView)
DEFAULT lTemRU6 := AliasInDic("RU6") 

If ( lTemRU6 .AND. lDel .AND. VAL(SRA->RA_DEPIR) >= 1 .Or. (lTemRU6 .AND. VAL(SRA->RA_DEPIR) >= 1 .AND. oView:GetModel():nOperation != 1 .And. oView:GetModel():nOperation != 5) )
	
	TcSqlExec("DELETE FROM " + RetSqlName("RU6") + " WHERE RU6_FILIAL = '" + SRA->RA_FILIAL + "' AND RU6_MAT = '" + SRA->RA_MAT + "' AND RU6_DTPGTO = '" + DTOS(M->RH_DTRECIB) + "' AND RU6_TPREND = '3'")

EndIf	

Return

/*/{Protheus.doc} Gp030Estab
Inclui/Exclui período e estabilidade
@author Leandro Drumond
@since 14/02/2024
/*/
Function Gp030Estab(lInclui,dFimFer)
Local aArea 		:= GetArea()
Local dDataEstab	:= CtoD("//")
Local lTemRFX       := .T.

dbSelectArea("RCM")
dbSetOrder(3)

If dbSeek( xFilial("RCM") + fGetCodFol( "0072", .F. ) )
	If RCM->RCM_DIAEST > 0
		dDataEstab := dFimFer + RCM->RCM_DIAEST
		RecLock("SRA",.F.)
		SRA->RA_DTVTEST := If(lInclui,Max(SRA->RA_DTVTEST,dDataEstab),If(SRA->RA_DTVTEST > dDataEstab, SRA->RA_DTVTEST, CtoD("//")))
		MsUnLock()

		DbSelectArea("RFX")
	
		If !lInclui
			lTemRFX := RFX->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + DtoS(dFimFer + 1)))
		EndIf

		If lTemRFX
			RecLock("RFX",lInclui)

			If lInclui 
				RFX->RFX_FILIAL  := SRA->RA_FILIAL 
				RFX->RFX_MAT     := SRA->RA_MAT 
				RFX->RFX_DATAI   := dFimFer + 1 
				RFX->RFX_DATAF   := dDataEstab 
				RFX->RFX_TPESTB  := "S99" //Férias
				RFX->RFX_OBSEST  := "Inclusão automática pelo cálculo de férias"
			Else 
				DbDelete() 
			EndIf 

			MsUnLock()
		EndIf
	EndIf
EndIf

RestArea(aArea)
Return Nil

/*/{Protheus.doc} fFerAhgora
Processo para gerar afastamento de férias na tabela de integração com Ahgora
@since 10/09/2024
@autor	Bruno Costa
@version 1.0
/*/
Static Function fFerAhgora(cOpc)
Local aAreaSRA    := SRA->(GetArea())
Local aAreaSR8    := SR8->(GetArea())
Local cChave      := ""
Local cVldPonto   := SuperGetMv("MV_INTEGPW",, "1")
Local aCodInterno := {}

If cVldPonto <> "1" 
	If !GPEAhGora():fAhgoraPW(cVldPonto)
		RestArea(aAreaSRA)
		RestArea(aAreaSR8)
		Return
	EndIf
EndIf

cChave := cEmpAnt + "|" + SRA->RA_FILIAL + "|" + SRA->RA_MAT + "|" + SR8->R8_SEQ + "|" + SR8->R8_TIPOAFA + "|" + dToS(SR8->R8_DATAINI) + "|" + dToS(SR8->R8_DATAFIM)
aAdd(aCodInterno, {SRA->RA_FILIAL, SRA->RA_MAT, cEmpAnt+SRA->RA_FILIAL+SRA->RA_MAT+SR8->R8_SEQ, SR8->R8_SEQ, SR8->R8_DATAINI, cOpc})

GPEAhGora():gravaRUM("I", "SR8", cChave, aCodInterno, "2")

RestArea(aAreaSRA)
RestArea(aAreaSR8)

Return Nil


/*/{Protheus.doc} fMsgPIS
Mensagem de alerta sobre os IDs 1969 e 1970
@author Bruno Costa
@since 18/02/2025
/*/
Static Function fMsgPIS(lPISCp11)

Local oButton1
Local oCheckBo1
Local oGroup1
Local oPanel1
Local oSay1
Local oSay2
Local oDlg
Local oProfile 	:= FWProfile():New()
Local lChkMsg 	:= .F.
Local lCheckBo1 := .F.
Local cTask     := If(lPISCp11, "MSGID1969", "MSGID1970")

oProfile:SetUser(RetCodUsr())
oProfile:SetProgram("GPEM030")
oProfile:SetTask(cTask)
oProfile:Load()

lChkMsg := (oProfile:GetStringProfile() == "")

If lChkMsg
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0010) FROM 000, 000  TO 200, 500 COLORS 0, 16777215 PIXEL //"Cálculo de Férias"

		@ 000, 000 MSPANEL oPanel1 SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
		@ 005, 012 GROUP oGroup1 TO 055, 237 PROMPT OemToAnsi(STR0088) OF oPanel1 COLOR 0, 16777215 PIXEL //"Atenção"
		@ 017, 017 SAY oSay1 PROMPT OemToAnsi(If(lPISCp11, STR0219, STR0220) + CRLF + STR0173) SIZE 215, 035 OF oPanel1 COLORS 0, 16777215 PIXEL //"É obrigatório possuir verba vinculada ao ID 1969/1970 devido exigência do eSocial." ### "Verifique a documentação conforme orientações no link abaixo"
		@ 063, 012 SAY oSay2 PROMPT "https://tdn.totvs.com/x/aRCfNg" SIZE 095, 007 OF oPanel1 COLORS 0, 16777215 PIXEL
		@ 080, 012 CHECKBOX oCheckBo1 VAR lCheckBo1 PROMPT OEMToAnsi(STR0171) SIZE 067, 008 OF oPanel1 COLORS 0, 16777215 PIXEL //"Não exibir novamente"
		@ 070, 200 BUTTON oButton1 PROMPT "OK" SIZE 037, 012 OF oPanel1 PIXEL

		oSay2:bLClicked := {|| ShellExecute("open", "https://tdn.totvs.com/x/aRCfNg", "", "", 1) }

		oButton1:bLClicked := {|| oDlg:End() }

	ACTIVATE MSDIALOG oDlg CENTERED

	If lCheckBo1		
		oProfile:SetStringProfile("*")
		oProfile:Save()
	EndIf
EndIf

Return

/*/{Protheus.doc} fMsgPIS
Valida obrigatoriedade dos IDs eSocial para férias
@author Bruno Costa
@since 18/02/2025
/*/
Function fVlIdsFer(lPis, cInc)
Local cWhere    := "%"
Local cAliasSRV := "QSRV"
Local lTemCp    := .F.

cWhere += "SRV.RV_FILIAL = '" + xFilial('SRV') + "' AND "
cWhere += If(lPis, "SRV.RV_INCPIS = '" + cInc + "' ", "SRV.RV_INCCP = '" + cInc + "' ")
cWhere += "AND SRV.RV_REFFER = 'S' "
cWhere += "%"   

BeginSql alias cAliasSRV
	SELECT SRV.RV_COD
	FROM %table:SRV% SRV
	WHERE %Exp:cWhere%
	AND SRV.%notDel%
EndSql

lTemCp := (cAliasSRV)->(!Eof())
(cAliasSRV)->(dbCloseArea())

Return lTemCp

/*/{Protheus.doc} fWhenSRH
Valida edição dos campos (WHEN)
@author Leandro Drumond
@since 24/06/2025
/*/
Function fWhenSRH(lGrvCalc)
Local lRet := !lGrvCalc

If lRet .and. lAposInv //Não permite alteração dos campos se for férias de aposentado por invalidez
	lRet := .F. 
EndIf

Return lRet

/*/{Protheus.doc} fCFApInv
Verifica se esta calculando férias de aposentado por invalidez
@author Leandro Drumond
@since 24/06/2025
/*/
Function fCFApInv()

DEFAULT lAposInv := .F.

Return lAposInv
