#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEM022.CH"
#INCLUDE "DBTREE.CH"
#INCLUDE "TBICODE.CH"
#INCLUDE "TBICONN.CH"

Static __lSrvShowMsg	// Mostrar no Server as mensagens referentes ao GRID quando o ShowStatus estiver configurado como 1 no SERVER.INI
Static __cORGSPFL		// Verifica se utiliza o Superfiltro
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³GPEM022   ³ Autor ³Mauricio T. Takakura      ³ Data ³24/09/2007  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ROTINA PARA CHAMADA DO CALCULO DE ROTEIROS - VERSAO MEXICO	     ³
ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 		     ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.			  	 ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Programador ³ Data	  ³ FNC       ³Motivo da Alteracao			  	         ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Mauricio T. ³24/09/07³-----------³Criacao do Programa.                 	 ³
³Mauricio T. ³28/03/08³-----------³Alteracoes para calculo de Rescisao.      ³
³Mauricio T. ³17/04/08³-----------³Nao estava reinicializando as variaveis de³
³            ³        ³           ³de carga de Incidencias, Val. Fut. e Ausen³
³Mauricio T. ³19/04/08³-----------³Nao estava desconsiderando os excluidos.  ³
³Tatiane V.M.³16/07/08³-----------³Problema na consulta do log gerado. Nao   ³
³            ³        ³           ³estava fechando o arquivo.                ³
³Tatiane V.M.³12/09/08³-----------³Criacao da variavel oPeriodo para ser uti-³
³            ³        ³           ³lizado no operador DIAS_HAB_PROG          ³
³Mauricio T. ³30/09/08³-----------³Quando usuarios de terminais diferentes re³
³Tatiane V.M.³        ³           ³alizavam o calculo nao apresentava o LOG  ³
³Mauricio T. ³07/10/08³-----------³Inclusao do Alltrim no nome do arquivo no ³
³            ³        ³           ³momento de abrir o arquivo.               ³
³Mauricio T. ³10/10/08³-----------³Zerar as variaveis STATICS do Gpexfor1 ao ³
³            ³        ³           ³solicitar um novo calculo.                ³
³Valdeci Lira³10/11/08³006285/2008|Cancelar a pendencia de transacao de num. ³
³            ³        ³           ³automatica no SX8 p/ melhor performance.  ³
³Valdeci Lira³10/06/09³014248/2009|Alterada a forma de passagem de parametro ³
³            ³        ³           ³para o grid pois estava dando erro de     ³
³            ³        ³           ³string size overflow quando tentava passar³
³            ³        ³           ³o parametro para a inicilizacao do GRID.  ³
³Valdeci Lira³06/08/09³018749/2009|Corrigida a contagem de funcionarios cal- ³
³            ³        ³           ³culados quando se esta com o grid ativo.  ³
³Mauricio T./³02/12/09³027676/2009|Ajustes para exibir no server mensagens do³
³Marcelo     ³        ³           ³Grid e correcao na avaliacao do array do  ³
³            ³        ³           ³com as informacoes do processamento.      ³
³Reginaldo GR³10/12/09³028390/2009³ajuste para criar mnemonicos do tipo      ³
³            ³        ³           ³tabela com as tabelas SRV e SRJ           ³
³Francisco Jr³09/02/10³002446/2010³Compatibilizar fonte  para Gestao Corpora-³
³            ³        ³           ³tiva.                                     ³  
³Alex Fagunde³09/01/11³000171/2011³Adaptacao Novas Interfaces 11.5. Controle ³
³            ³        ³           ³MsAdvSize, para redimensionamento telas.  ³  
³Marcelo     ³12/01/11³000793/2011³Correcao no contador dos arquivos de Log. ³
³Tiago Malta ³30/05/11³000171/2011³Ajustes das telas usando a func. retcoords³  
³Christiane V³01/07/11³015549/2011³Leitura Automática de Lançamento Fixos    ³            
³Christiane V³26/07/11³018149/2011³Validação do pais para leitura das tabelas³
³            ³        ³           ³RCO e RGC                                 ³
³Erika K.    ³09/09/11³016466/2011³Aleracoes para calculo de ferias e resci- ³
³            ³        ³           ³sao para modelo 2.                        ³ 
³Mohanad Odeh³19/10/11³015786/2011³Inclusao da chamada da função fCarPD(),pa_³
³            ³        ³     TDGHWQ³ra carga das verbas padrões               ³
³Christiane V³12/12/11³029163/2011³Posicionamento da tabela SQ3              ³  
³Glaucia M.  ³14/12/11³			  ³Correcao quando busca_tabla esta vazia,   ³
³            ³        ³           ³calculo sera abortado e RCH_STATUS so sera³
³            ³        ³           ³sera atualizado somente se ha necessidade ³ 
³Christiane V³19/12/11³031568/2011³Criação da opção para habilitar trace.    ³
³Silvia      ³09/02/12³ARG116     ³REQ001									 ³
³Glaucia M.  ³09/04/12³ARG116RH   ³-ARG- Ajuste funcao Gpem022grd - 		 ³
³            ³        ³REQ007     ³chamada fGetLanFix, com problema GRID	 ³
³Mohanad Odeh³11/05/12³			  ³											 ³
³Glaucia M.  ³14/05/12³010440/2012³Disponibilizar pergunta Localidade de Pago³
³            ³        ³TEWM57     ³somente para "COL|COS|DOM|MEX", pois 	 ³
³            ³        ³           ³possuem em menu a rotina RGC-GPEA660.	 ³
³Claudinei S.³30/05/12³     TFALWQ³Alterada Gpem022Processa para so validar a³
³            ³        ³           ³RGE qdo nao for MEX para evitar error.log.³
³M. Silveira ³23/01/11³     TGKDXH³Melhorias da P10 que nao foram replicadas:³
³            ³        ³           ³Controle para bloqueio de registros	     ³
³            ³        ³           ³Parametro MV_MINGRID	                     ³
³            ³        ³           ³Posicionamento correto da tabela de RCH.  ³
³            ³        ³           ³Melhoria na juncao dos Logs do GRID.      ³
³Glaucia M.  ³31/01/13³002516/2013³Ajuste para permitir execucao             ³
³            ³        ³TGOUG0     ³Gpem022Processa das rotinas GPEM031, 	 ³
³            ³        ³           ³GPEM032,GPEM042 e GPEM043.                ³
³Glaucia M.  ³31/01/13³024107/2012³Ajuste para não executar superfiltro, se o³
³            ³        ³TFQLPT     ³parametro MV_ORGSPFL for diferente de 'S'.³
³Glaucia M.  ³04/02/13³000689/2013³Ajuste para calculo de ferias coletivas   ³
³            ³        ³TGJMGL     ³Modelo 2.                                 ³
³Glaucia M.  ³22/02/13³024107/2012³Rejeicao-Correcao tela de Log com problema³
³            ³        ³TFQLPT     ³ao acessar a mesma duas vezes.            ³
|M. Silveira ³26/04/13³TGQEB3     ³Ajustes p/ melhoria performance - Modelo 2³
|M. Silveira ³13/09/13³THMNQX     ³Ajuste para permitir habilitar o Trace e a³
³            ³        ³           ³gravacao na rescisao.                     ³
|M. Silveira ³09/01/14³TIDPQK     ³Incluidas variaveis p/ tratar campos dias ³
³            ³        ³           ³da RGB e tornar a leitura mais eficiente. ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³M.Camargo   ³24/11/13³Proyecto:  ³Se agregan variables __nSRQNuID  ,        ³
|            ³		  ³COL11.8_RH ³__nRG1NuID para ser llevados a la SRC     ³
³            ³        ³Requisito: ³por lo que se crean como privadas.		 ³
³            ³        ³239601     ³                                			 ³
|Cícero Alves³02/03/15³           ³Retirada da função AjustaSx6				 ³
³            ³        ³           ³para ficar de acordo com a versão 12.     ³
|gSantacruz  ³28/09/15³PCREQ-5930 ³Se elimina el uso de la variable cTipCalc ³             
³            ³        ³           ³para ficar de acordo com a versão 12.     ³
|M.Camargo   ³18/12/15³PCREQ-7944 ³SAjsutes Localización CHI.                ³
³            ³        ³           ³Se modifica retorno de la  gpem022Processa³
³            ³        ³           ³para envio de termino de proceso usado    ³
|            ³		  ³           ³para el cálculo de Reliquidación de Chile ³
³            ³        ³           ³Se modifica función VldCalculo para cuando³
³            ³        ³           ³se llame al calculo de finiquito no envié ³
|            ³		  ³           ³mensaje de periodos no cerrados.          ³
|M.Camargo   ³22/11/16³MMI-4222   ³Ajustes Localización Colombia/Chile       ³
|Oscar G.    ³21/06/19³DMINA-6900 ³Se localiza el uso de variable lVarios en ³
³            ³        ³           ³función VldPeriodo e incializa en func.   ³
³            ³        ³           ³Gpem022Processa. (COL)                    ³
|Diego Rivera³26/02/20³DMINA-8529 ³Ajuste en las funciones GPEM022 y         ³
³            ³        ³           ³Gpem022Processa para cuando es rutina     ³
³            ³        ³           ³automática. (MEX)                         ³
|Alf. Medrano³28/10/20³DMINA-8758 ³En fun Gpem022Processa se decrementa varia³
³            ³        ³           ³nNumEmp por cada empleado procesado y se  ³
³            ³        ³           ³asigna su valor a variable nTotReg para   ³
³            ³        ³           ³informar el núm de empleados procesados.  ³                    
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  

Function GPEM022(cProcCalc, cTipoNom, nPosStatus, lGraba, cMatr, cDep, cCc, cLocal, lDisable)

Local aArea			:= GetArea()
Local aPages		:= Array( 02 )
Local aFolders		:= Array( 02 )
Local aObjFolder	:= Array( 02 )
Local aButtons		:= {}

Local bSet15
Local bSet24
Local bDialogInit
                 
Local cSvFilAnt		:= cFilAnt

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aGDCoord		:= {}
Local aRetcoords    := {}
Local aTabsSPFil	:= {}

Local lSetCentury	:= __SetCentury( "on" )	//altero o estado de SetCentury

Local nLin
Local nOpca			:= 0

Local oDlg
Local oFolders
Local oGeralEnch
Local oRangoEnch
Local oConfigEnch
Local oChkHabGrab
Local oChkHabTrace
Local oRadStatus   
Local lRescM2		:= .F. //Permite habilitar o Trace/Gravacao na Rescisao

DEFAULT lDisable := .F.

Private cCadastro		:= OemToAnsi(STR0005) // "Processos de Cálculo"
Private lAbortPrint 	:= .F.

Private aFilter		:= {}	// Array com os Filtros 
Private nStatus		:= 1
Private cProcDesc	:= Space( TamSX3( "RCJ_DESCRI" )[1] )
Private cRotDesc 	:= Space( TamSX3( "RY_DESC" )[1] )
Private dDataIni	:= Ctod("//")
Private dDataFim	:= Ctod("//")

// Variaveis Privates que deverão ser levados para o calculo - Implementacao GRID //
Private cProces		:= Space( TamSX3( "RCJ_CODIGO" )[1] )
Private cRoteiro 	:= Space( TamSX3( "RY_CALCULO" )[1] )
Private cPeriodo	:= Space( TamSX3( "RCH_PER" )[1] )
Private cNumPag		:= Space( TamSX3( "RCH_NUMPAG" )[1] )
Private cFilMat 	:= Space(99)	// Filtro de Matricula
Private cFilDep 	:= Space(99)	// Filtro de Departamento
Private cFilPosto 	:= Space(99)	// Filtro de Posto
Private cFilCC		:= Space(99)	// Filtro de Centro de Custo
Private cFilLocPag	:= Space(99)	// Filtro de Localidade de Pago
Private cAtual		:= ""
Private lHabGrab	:= .F.
Private lHabTrace	:= .F.
Private lVarios		:= .F.
Private __aFormulas	:= {}
Private oPeriodo	:= RHPERIODO():New()
Private aRotMark   	:= {}
Private cAliasMark 	:= "TABAUX"
Private oProces
Private oRoteir
Private oAtual

//Variaveis de controle - QTD Minima para calculo com GRID (MV_MINGRID)
Private nRecRCHAux	:= 0
Private nTotCalFunc	:= 0
Private nTotCalReg	:= 1

/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Funcao verifica se existe alguma restricao de acesso para o³
//³usuario que impeca a execucao da rotina.                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If( Type("__cORGSPFL") == "U" )
	__cORGSPFL := GetMvRH( "MV_ORGSPFL", .F., 'N' )		
Endif

If __cORGSPFL == 'S' 
	aTabsSPFil	:= {"SQB","SRJ","RCP","CTT","RG7","RCE","SR6","SR3","SR7","SRC","RGB","SRV","SRK" }	
	
	If cPaisLoc <> "ARG"
		aAdd( aTabsSPFil, "RGC" )
		aAdd( aTabsSPFil, "RCO" )	
	Endif

	If !( fValidFun(aTabsSPFil) )
		RestArea(aArea)
		Return
	EndIf
Endif	        

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Quando os perguntes vierem preechidos								       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/                             
If !Empty(cProcCalc)
	cProces 	:= cProcCalc
	If ExistCpo("RCJ", cProces)
		cProcDesc := Posicione("RCJ",1,xFilial("RCJ")+cProces, "RCJ_DESCRI")
	EndIf
EndIf
If !Empty(cTipoNom)
	cRoteiro := cTipoNom
	If ExistCpo("SRY", cRoteiro)
		cRotDesc := Posicione("SRY",1,xFilial("SRY")+cRoteiro, "RY_DESC")
	EndIf
  	lRescM2 := fGetTipoRot( cTipoNom ) == "4"
EndIf
If (!Empty(cProcCalc) .and. !Empty(cTipoNom)) .or. lDisable
	lRet := VldPeriodo()
	If !lRet 
		Aviso( OemToAnsi(STR0027), OemToAnsi(STR0025), {STR0003} ) // "Atenção"##"Não foi possivel carregar as Manutenções de Tabelas!"##"OK"
		Return
	EndIf
EndIf
If !Empty(nPosStatus)
	nStatus := nPosStatus
EndIf
If !Empty(lGraba)
	lHabGrab := lGraba
EndIf                             

If !Empty(cMatr)
	cFilMat := cMatr
EndIf
If !Empty(cDep)
	cFilDep	:= cDep
EndIf
If !Empty(cCC)
	cFilCc := cCC
EndIf
If !Empty(cLocal)
	cFilLocPag := cLocal
EndIf

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
							PROCESSAMENTO EM GRID
--> Quando declarar variaveis PRIVATES nas Funcoes ate o Nivel GpmProcessa e  neces-
sitar utiliza-los no roteiro de calculo, devera enviar no array aPARAMB  e rede-
clarar na Preparacao do Ambiente com a funcao _SetOwnerPrvt. 
--> Para as variaveis PRIVATES declaradas para o funcionario, enviar atraves  do ar-
ray aCall e redeclarar na GPEM022GRD. 
---> Vide Exemplos de ambas as situacoes
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ*/

// Tratar GRID Somente para TOP Connect
Private lGrid := .F. // Se o parametro esta configurado para utilizacao do GRID

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Desliga o GRID automaticamente se o numero de funcionarios a  ³
³ser processado for menor que o numero do parametro MV_MINGRID ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Private nMinGrid := GetMvRH("MV_MINGRID",, 0)

Begin Sequence

	aAdd(aButtons, {NIL,{||TelaLog()}, OemToAnsi(STR0053), OemToAnsi(STR0060)}) //"Consulta Logs de Calculo"##"Logs"	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Conteudo do aPages								   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aPages[ 01 ] := OemToAnsi( "&" + STR0001 )	//"Gerais"
	aPages[ 02 ] := OemToAnsi( "&" + STR0002 )	//"Faixas"

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Conteudo do aFolders								   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aFolders[ 01 ] := OemToAnsi( "&" + STR0001 ) //"Gerais"
	aFolders[ 02 ] := OemToAnsi( "&" + STR0002 ) //"Faixas"
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define os Elementos para o Array do Objeto Folder        	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aObjFolder[ 01 ]	:= Array( 01 , 04 )
	aObjFolder[ 02 ]	:= Array( 02 , 04 )
	
	// Em GRID havera uma Barra de processamento da LIB //
	bSet15			:= { || fLoadCalc() }
	bSet24			:= { || oDlg:End() }

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para a Inicializacao do Dialog            	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bDialogInit		:= { ||;
								CursorWait()													,;
								oProces:SetFocus()												,;
								EnchoiceBar( oDlg , bSet15 , bSet24, NIL , aButtons )			,;
								CursorArrow()												 	 ;
					   }
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta as Dimensoes dos Objetos         					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
	
	If !isBlind() //Tratamiento para automatizacion

		// Función para mostrar Aviso sobre legislaciones que apliquen para MI
		If FindFunction("MsgAvisoMI")
			MsgAvisoMI()
		EndIf

		Define MsDialog oDlg Title cCadastro From aAdvSize[7],000 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL
	
			oDlg:lEscClose := .F. // Nao permite sair ao se pressionar a tecla ESC.
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega o Objeto Folder               					   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			oFolders := TFolder():New(	aObjSize[1,1]			,;
										aObjSize[1,2]			,;
										aFolders				,;
										aPages					,;
										oDlg					,;
										NIL						,;
										NIL						,;
										NIL						,;
										.T.						,;
										.F.						,;
										aObjSize[1,4]			,;
										aObjSize[1,3]			 ;
									 )
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Dados do folder - Gerais 											       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	       
			aRetcoords := RetCoords(4,6,55,15,2,40,,oFolders:OWND:NTOP)
			       
			//
			@aRetcoords[1][1]	,aRetcoords[1][2] SAY   OemToAnsi(STR0004) SIZE 033,007 OF oFolders:aDialogs[ 01 ] PIXEL	//"Processo: "
		  	@aRetcoords[2][1]	,aRetcoords[2][2] MSGET oProces VAR cProces   SIZE 040,007	OF oFolders:aDialogs[ 01 ] PIXEL WHEN GpemValDis(lDisable, lVarios) PICTURE ;
										   							   PesqPict("RCJ","RCJ_CODIGO") F3 "RCJ" VALID;
																	    ( If( Empty(cProces),;
														    			  	(cProcDesc := "", lRet := .T.),;
																    	  	If( lRet := ExistCpo("RCJ", cProces),;
																    			  cProcDesc := Posicione("RCJ",1,xFilial("RCJ")+cProces, "RCJ_DESCRI"),;
																	    		  "")),;
																	    lRet := VldPeriodo(),;
																	    lRet ) HASBUTTON
			@aRetcoords[3][1]	,aRetcoords[3][2] SAY   OemToAnsi(STR0006) SIZE 033,007 OF oFolders:aDialogs[ 01 ] PIXEL	//"Descricao: "																    
		  	@aRetcoords[4][1]	,aRetcoords[4][2] MSGET cProcDesc SIZE 140,007	OF oFolders:aDialogs[ 01 ] PIXEL WHEN .F.
	
			
			@aRetcoords[5][1]	,aRetcoords[5][2] SAY   OemToAnsi(STR0007) SIZE 060,007 OF oFolders:aDialogs[ 01 ] PIXEL	//"Tipo Folha: "
	
			@aRetcoords[6][1]	,aRetcoords[6][2] MSGET oRoteir VAR cRoteiro  SIZE 040,007	OF oFolders:aDialogs[ 01 ] PIXEL WHEN GpemValDis(lDisable, lVarios) PICTURE ;
																		PesqPict("SRY","RY_CALCULO") F3 "SRY" VALID;
																	    ( If( Empty(cRoteiro),;
														    			  	(cRotDesc := "", lRet := .T.),;
																    	  	If( lRet := ExistCpo("SRY", cRoteiro),;
																    			  cRotDesc := Posicione("SRY",1,xFilial("SRY")+cRoteiro, "RY_DESC"),;
																	    		  "")),;
																	    lRet := VldPeriodo(),;
																	    lRet ) HASBUTTON
		  	@aRetcoords[7][1]	,aRetcoords[7][2] SAY   OemToAnsi(STR0006) SIZE 033,007 OF oFolders:aDialogs[ 01 ] PIXEL	//"Descricao: "																    
			@aRetcoords[8][1]  ,aRetcoords[8][2] MSGET cRotDesc SIZE 140,007	OF oFolders:aDialogs[ 01 ] PIXEL WHEN .F.
	          
			
			@aRetcoords[9][1]	,aRetcoords[9][2] SAY   OemToAnsi(STR0008) SIZE 033,007 OF oFolders:aDialogs[ 01 ] PIXEL	//"Periodo: "
			@aRetcoords[10][1]	,aRetcoords[10][2] MSGET cPeriodo SIZE 040,007	OF oFolders:aDialogs[ 01 ] PIXEL WHEN .F.
	
	
			@aRetcoords[11][1]	,aRetcoords[11][2] SAY   OemToAnsi(STR0009) SIZE 038,007 OF oFolders:aDialogs[ 01 ] PIXEL	//"Nro Pagto: "
			@aRetcoords[12][1]	,aRetcoords[12][2] MSGET cNumPag SIZE 040,007	OF oFolders:aDialogs[ 01 ] PIXEL WHEN .F.
	
			@aRetcoords[13][1]	,aRetcoords[13][2] SAY   OemToAnsi(STR0010) SIZE 038,007 OF oFolders:aDialogs[ 01 ] PIXEL	//"Data Inicio: "
			@aRetcoords[14][1]	,aRetcoords[14][2] MSGET dDataIni SIZE 050,007	OF oFolders:aDialogs[ 01 ] PIXEL WHEN .F. HASBUTTON
			
			@aRetcoords[15][1]	,aRetcoords[15][2] SAY   OemToAnsi(STR0011) SIZE 033,007 OF oFolders:aDialogs[ 01 ] PIXEL	//"Data Fim: "
			@aRetcoords[16][1]	,aRetcoords[16][2] MSGET dDataFim SIZE 050,007	OF oFolders:aDialogs[ 01 ] PIXEL WHEN .F. HASBUTTON
	
			@aRetcoords[17][1]	,aRetcoords[17][2] SAY   OemToAnsi(STR0012) SIZE 033,007 OF oFolders:aDialogs[ 01 ] PIXEL	//"Status: "
	
			oRadStatus			:= TRadMenu():New( aRetcoords[18][1]	,aRetcoords[18][2] , {STR0013,STR0014,STR0015} , NIL , oFolders:aDialogs[ 01 ] , NIL , NIL , NIL , NIL , NIL , NIL , NIL , 115 , 010 , NIL , NIL , NIL , .T. ) //"Ativos"##"Inativos"##"Ambos"
			oRadStatus:bSetGet	:= { |nItem| IF( nItem <> NIL , nStatus := nItem , nStatus ) }
			If lDisable // Nao permitir alteracao
				oRadStatus:SetDisable()
			EndIf
					
			@aRetcoords[19][1]	,aRetcoords[19][2] CHECKBOX oChkHabGrab VAR lHabGrab PROMPT OemToAnsi( STR0021 ) SIZE 100,08 OF oFolders:aDialogs[ 01 ] PIXEL //"Habilitar Gravacao"
			@aRetcoords[23][1]	,aRetcoords[23][2] CHECKBOX oChkHabTrace VAR lHabTrace PROMPT OemToAnsi( STR0087 ) SIZE 100,08 OF oFolders:aDialogs[ 01 ] PIXEL //"Habilitar TRACE"
			If lDisable .And. !lRescM2 // Nao permitir alteracao
				oChkHabGrab:SetDisable()                    
				oChkHabTrace:SetDisable()
			EndIf
	
			If !lDisable
				@aRetcoords[21][1]+15	,aRetcoords[21][2] BUTTON oBtn1 PROMPT STR0089 SIZE 343,010	ACTION (fSelProc()) OF oFolders:aDialogs[ 01 ] PIXEL//"Seleccionar varios procesos o tipos de procedimientos"
				@aRetcoords[21][1]+30	,aRetcoords[21][2] MSGET oAtual VAR cAtual  SIZE 343,007	OF oFolders:aDialogs[ 01 ] PIXEL WHEN .F. PIXEL		
			EndIf
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Dados do folder - Filtros 										       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	
			@aRetcoords[1][1]	,aRetcoords[1][2] SAY   OemToAnsi(STR0016) SIZE 045,007 OF oFolders:aDialogs[ 02 ] PIXEL	//"Funcionarios: "
			@aRetcoords[2][1]	,aRetcoords[2][2] MSGET cFilMat   SIZE 200,007 OF oFolders:aDialogs[ 02 ] PIXEL WHEN GpemValDis(lDisable) F3 "SRA" HASBUTTON
	
			@aRetcoords[5][1]	,aRetcoords[5][2] SAY   OemToAnsi(STR0017) SIZE 045,007 OF oFolders:aDialogs[ 02 ] PIXEL	//"Departamentos: "
			@aRetcoords[6][1]	,aRetcoords[6][2] MSGET cFilDep   SIZE 200,007 OF oFolders:aDialogs[ 02 ] PIXEL WHEN GpemValDis(lDisable) F3 "SQB" HASBUTTON
	
			//-- Nao foi definido como sera implementado o filtro de Postos. Se o 
			//-- calculo devera vir da Arquitetura e com seus respectivos filtros ou 
			//-- se teremos um novo filtro na tabela SRA atraves de seus postos.
			//		nLin:=nLin+13
			//		@nLin	,004 SAY   OemToAnsi(STR0018) SIZE 045,007 OF oFolders:aDialogs[ 02 ] PIXEL	//"Postos: "
			//		@nLin	,055 MSGET cFilPosto   SIZE 200,007 OF oFolders:aDialogs[ 02 ] PIXEL F3 "RCL"
	
			@aRetcoords[9][1]	,aRetcoords[9][2] SAY   OemToAnsi(STR0019) SIZE 045,007 OF oFolders:aDialogs[ 02 ] PIXEL	//"Centro de Custos: "
			@aRetcoords[10][1]	,aRetcoords[10][2] MSGET cFilCC   SIZE 200,007 OF oFolders:aDialogs[ 02 ] PIXEL WHEN GpemValDis(lDisable) F3 "CTT" HASBUTTON 
	
			If cPaisLoc $ "COL|COS|DOM|MEX|CHI"   
				@aRetcoords[13][1]	,aRetcoords[13][2] SAY   OemToAnsi(STR0020) SIZE 045,007 OF oFolders:aDialogs[ 02 ] PIXEL	//"Local de Pagamento: "
				@aRetcoords[14][1]	,aRetcoords[14][2] MSGET cFilLocPag SIZE 200,007 OF oFolders:aDialogs[ 02 ] PIXEL WHEN GpemValDis(lDisable) F3 "RGC" HASBUTTON
			EndIf
			
			If ( FunName() == "GPEM040" )
				If ExistBlock( "GPM040CAL" )	
					ExecBlock("GPM040CAL")
				EndIf
			EndIf
					
		ACTIVATE DIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED
	Else
				
		aRetAuto := GetParAuto("GPEM020TestCase") //Se obtienen parametros definidos en caso de prueba
		
		//Generales
		cProces		:= aRetAuto[1] //Proceso
		cRoteiro	:= aRetAuto[2] //Tipo de Procedimiento
		cPeriodo	:= aRetAuto[3] //Periodo
		cNumPag		:= aRetAuto[4] //Numero de Pago
		dDataIni	:= aRetAuto[5] //Fecha Inicial
		dDataFim	:= aRetAuto[6] //Fecha Final
		nStatus		:= aRetAuto[7] //Estatus
		lHabGrab	:= aRetAuto[8] //Habilita grabacion
		lHabTrace	:= aRetAuto[9] //Habilita TRACE
		
		//Rangos
		cFilMat		:= aRetAuto[10] //Rango matriculas
		cFilDep		:= aRetAuto[11] //Rango departamentos
		cFilCC		:= aRetAuto[12] //Rango Centro de Costos
		cFilLocPag	:= aRetAuto[13] //Rango de Localidades de Pago
		
		//Inicia el calculo
		fLoadCalc()
		
	EndIf
                                              	
End Sequence

IF !( lSetCentury )
	__SetCentury( "off" )
EndIF
cFilAnt	:= cSvFilAnt

RestArea( aArea )

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Gpem022Processa³ Autor ³Mauricio T. Takakura³Data³28/09/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³REALIZA O CALCULO ATRAVES DA VERSAO MEXICO                 	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function Gpem022Processa()

Local lGPEM031      := IsInCallStack("GPEM031")
Local lGPEM032      := IsInCallStack("GPEM032")
Local lGPEM042      := IsInCallStack("GPEM042") .Or. FunName() == "GPEM042"
Local lGPEM630     	:= IsInCallStack("GPEM630")
Local lOrigem		:= !( lGPEM031 .Or. lGPEM032 .Or. lGPEM042 .Or. (cPaisLoc =="MEX" .And. lGPEM630) .Or. IsInCallStack("GPEM043") )

Local aArea			:= GetArea()
Local aTables 		:= {}
Local aIncid		:= {}
Local aSvCols		:= {}
Local aRecsBarG		:= {}
Local lAutomato     := isblind()

// Variaveis somente utilizadas no GRID
Local aCall			:= {}
Local aProces		:= { "", "", "", "", "" }
Local nRegGrid 		:= 0
Local nLoteGrid		:= 0

Local cTabMestra	:= "SRA"
Local cAliasMestra	:= cTabMestra
Local cFilter		:= ""      
Local cFilterAux    := ""
Local cExp 			:= ""
Local cMod1			:= ""
Local cCalcFun		:= ""
Local cFilFun		:= ""

Local nOrdRch	:= RetOrder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR" )
Local nOrdSqb	:= RetOrder( "SQB", "QB_FILIAL+QB_DEPTO" )
Local nOrdSrj	:= RetOrder( "SRJ", "RJ_FILIAL+RJ_FUNCAO" )
Local nOrdCtt	:= RetOrder( "CTT", "CTT_FILIAL+CTT_CUSTO" )
Local nOrdSr6	:= RetOrder( "SR6", "R6_FILIAL+R6_TURNO" )
Local nOrdSr3	:= RetOrder( "SR3", "R3_FILIAL+R3_MAT+R3_DATA+R3_TIPO+R3_PD" )
Local nOrdSr7	:= RetOrder( "SR7", "R7_FILIAL+R7_MAT+R7_DATA+R7_TIPO" )
Local nOrdSq3	:= RetOrder( "SQ3", "Q3_FILIAL+Q3_CARGO+Q3_CC" )
Local nOrdRce	:= RetOrder( "RCE", "RCE_FILIAL+RCE_CODIGO" )
Local nOrdRco	:= 1
Local nOrdRcg	:= 1
Local nOrdRge	:= 1
Local nOrdRhi	:= 1

Local cRCJFilTab := ""
Local cRCHFilTab := ""
Local cSQBFilTab := ""
Local cSRJFilTab := ""
Local cCTTFilTab := ""
Local cRCEFilTab := ""
Local cSR6FilTab := ""
Local cSR3FilTab := ""
Local cSR7FilTab := ""
Local cSQ3FilTab := ""

Local cModRCJ
Local cModRCH
Local cModSQB
Local cModSRJ
Local cModRCO
Local cModCTT
Local cModSRC
Local cModRGC
Local cModRGE
Local cModRCE
Local cModSR6
Local cModSR3
Local cModSR7
Local cModSQ3

Local cFilTab
Local cTimeCalc

Local nX    
Local nAux
Local nTotReg		:= 1
Local nTotFunc		:= 0

Local nTimeCalc
Local nTimeIni
Local nTimeFunc
Local nTraceOn		:= 0
Local nRet			:= 0
Local nRecRCH		:= 0

Local lCalcula		:= .T. 
Local lDelMov		:= .T.
Local cMsgErro      := ""
Local nRecRGE		:= 0
Local cEmpPr		:= ""

Local lVarColeti	:= Type("lColetiva") <> "U"

Private aPd			:= {}
Private aRotPd 		:= {}
Private aMnemonicos	:= {}
Private aOperador  	:= {}
Private aDefTab		:= {}
Private aValFut		:= {}
Private aAfast		:= {}
Private aBenef		:= {}
Private aLanFix		:= {}
Private nCountReg	:= 0
Private nRetCalc	:= 0
Private aTypAus		:= {}
Private aNCalcCol	:= {}

//Posicao dos campos que serao utilizados nas formulas (GPEXFOR1)
Private __nSRMTab	:= 0
Private __nSRMPd
Private __nSRMIncid
Private __nSRMValFut
Private __nSRMAcumul
Private __nSRMAusenc
Private __nSRMForm
Private __nSRMCodCrit
Private __nSRMBenef
Private __nSRMLanFix
Private __nRGBTab
Private __nRGBPD
Private __nRGBFun
Private __nRGBDtR
Private __nRGBCc
Private __nRGB3Tp
Private __nRGB2Tp
Private __nRGB1Tp
Private __nRGBQtS
Private __nRGBParc
Private __nRGBSem
Private __nRGBNuId
Private __nRGBPos
Private __nRGBDept
Private __nPosD1
Private __nPosD2
Private __nPosD3
Private __nPosD4
Private __nPosD5
Private __nPosD6
Private __nPosD7
Private __nSRKTab
Private __nSRKPD
Private __nSRKDtM
Private __nSRKNuId
Private __nSR8Tab
Private __nSR8PD
Private __nSR8Tipo
Private __nSR8DtIni
Private __nSR8NuId
Private __nRCMTab
Private __nRCMPD
Private __nRCMTipo
Private __nSRQTab
Private __nSRQPD
Private __nSRQNuID  //Para Colombia
Private __nRG1Tab
Private __nRG1PD
Private __nRG1NuId	//Para Colombia
Private __nSRCTab
Private __nSR7Tab
Private __nSR3Tab

Private __lDtRefAcm 		//Indica se a pesquisa nos acumulados sera por Data de Referencia
Private __lSrvAs400	:= .F.

//Ordem das tabelas utilizadas no calculo - CALCPROC
Private nOrdSrv		:= RetOrder( "SRV", "RV_FILIAL+RV_COD" )
Private nOrdRcj		:= RetOrder( "RCJ", "RCJ_FILIAL+RCJ_CODIGO" )
Private nCalRg9Ord	:= RetOrder( "RG9", "RG9_FILIAL+RG9_CODCRI" )
Private nCalRcpOrd	:= RetOrder( "RCP", "RCP_FILIAL+RCP_MAT+DTOS(RCP_DTMOV)+RCP_TPMOV" )
Private nCalRgbOrd	:= RetOrder( "RGB", "RGB_FILIAL+RGB_PROCES+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_MAT+RGB_PD+RGB_SEQ" )
Private nCalSrkOrd	:= RetOrder( "SRK", "RK_FILIAL+RK_MAT+RK_PD+DTOS(RK_DTMOVI)" )
Private nCalRg7Ord	:= RetOrder( "RG7", "RG7_FILIAL+RG7_MAT+RG7_PD+RG7_PROCES+RG7_ROTEIR+RG7_ANOFIM+RG7_ANOINI" )
Private nCalSr7Ord	:= RetOrder( "SR7", "R7_FILIAL+R7_MAT+DTOS(R7_DATA)+R7_TIPO" )
Private nCalSr3Ord	:= RetOrder( "SR3", "R3_FILIAL+R3_MAT+DTOS(R3_DATA)+R3_SEQ+R3_TIPO+R3_PD" )
Private nCalRcmOrd	:= RetOrder( "RCM", "RCM_FILIAL+RCM_TIPO" )
Private nCalSrqOrd	:= RetOrder( "SRQ", "RQ_FILIAL+RQ_MAT" )

If Type("lVarios") == "U"
	lVarios := .F.
EndIf

If Type("lGPEM040B") == "U"
	lGPEM040B := .F.
EndIf
If cPaisLoc=="MEX" .and. lGPEM040B
	nStatus := 3
	nTotReg := nNumEmp
EndIf
If lOrigem
	nTotReg		:= nTotCalFunc
	nTotFunc	:= nTotCalReg
	nRecRCH		:= nRecRCHAux
Endif

If !(cPaisLoc $ "ARG*DOM")
	nOrdRco	:= RetOrder( "RCO", "RCO_FILIAL+RCO_CODIGO+RCO_NREPAT" )
	nOrdRgc	:= RetOrder( "RGC", "RGC_FILIAL+RGC_KEYLOC" )
Endif
	
If cPaisLoc <> "MEX"
	nOrdRge	:= RetOrder( "RGE", "RGE_FILIAL+RGE_MAT" )
EndIf

If (cPaisLoc $ "ARG*DOM")
	If lGPEM031
		nOrdRhi	:= RetOrder( "RHI", "RHI_FILIAL+RHI_MAT+DTOS(RHI_DTINI)" )
	Else
		nOrdRhi	:= RetOrder( "RHI", "RHI_FILIAL+RHI_MAT+RHI_PERIOD" )
	Endif
	
	If lGPEM042
		nOrdSrg	:= RetOrder( "SRG", "RG_FILIAL+RG_MAT+DTOS(RG_DTPAGO)" )
	Else
		nOrdSrg	:= RetOrder( "SRG", "RG_FILIAL+RG_MAT+RG_PERIODO)" )
	Endif	
Endif

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Possibilitar o disparo do ponto de entrada padrao disponivel em telas no ³
³ botao OK, atraves do FrameWork. Disparo do Ponto de Entrada Padrao	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
EvalTrigger()

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Limpar as Variaveis Statics do Calculo - Declaradas em GPEXFOR1          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
RstNewCalc()

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Tratamento do Arquivo de Log										       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
nTimeIni := Seconds()
cTimeIni := Time()
If !CreateLog()
	Aviso( OemToAnsi(STR0027), OemToAnsi(STR0032), {STR0003} ) // "Atenção"##"Não foi possivel criar o arquivo de Log!"##"OK"
	Return
EndIf

If lGrid
	AddMsgLog(OemToAnsi(STR0033)+CRLF)	// "Efetuando o Calculo utilizando o GRID (Multi-Threads)"
	AddMsgLog(Replicate( "-", 100)+CRLF)
	
	// Identifica o Nro de Registros a processar por Thread	
	nLoteGrid	:= GetMvRH("MV_REGGRID",,20) 
EndIf
AddMsgLog(Replicate("-", 80))
AddMsgLog(OemToAnsi(STR0046)) 										//"Preparando Ambiente para o calculo"

AddMsgLog(Replicate("-", 80))
AddMsgLog(STR0001) //"Gerais"
AddMsgLog(Replicate("-", 80))
AddMsgLog(OemToAnsi(STR0004) + Space(20-len(STR0004)) + Alltrim(cProces)  + " - " + Alltrim(cProcDesc))//"Processo: "
AddMsgLog(OemToAnsi(STR0007) + Space(20-len(STR0007)) + Alltrim(cRoteiro) + " - " + Alltrim(cRotDesc)) //"Tipo de Folha: "
AddMsgLog(OemToAnsi(STR0008) + Space(20-len(STR0008)) + Alltrim(cPeriodo)) //"Periodo: "
AddMsgLog(OemToAnsi(STR0009) + Space(20-len(STR0009)) + Alltrim(cNumPag)) 	//"Nro Pagto: "
AddMsgLog(OemToAnsi(STR0012) + Space(20-len(STR0012)) + Replace(if(nStatus == 1, STR0013, if(nStatus == 2,STR0014,STR0015)),"&", "") )//"Status: "##"Ativos"##"Inativos"##"Ambos"
AddMsgLog(Replace(OemToAnsi(STR0021),"&","") + ":" + Space(20-len(STR0021)) + if(lHabGrab,STR0022,STR0023))

AddMsgLog(Replicate("-", 80))
AddMsgLog(STR0002) //"Faixas"
AddMsgLog(Replicate("-", 80))
If cPaisLoc == "MEX" .and. lGPEM040B
	cEmpPr := SUBSTR(cExpFiltro, 11, len(cExpFiltro)-11 )
	AddMsgLog(OemToAnsi(STR0016) + Space(20-len(STR0016)) + STRTRAN( cEmpPr , "'" , "" ))//"Funcionarios: "
Else
	AddMsgLog(OemToAnsi(STR0016) + Space(20-len(STR0016)) + aFilter[1,2])//"Funcionarios: "
Endif
AddMsgLog(OemToAnsi(STR0017) + Space(20-len(STR0017)) + aFilter[2,2])//"Departamentos: "
AddMsgLog(OemToAnsi(STR0019) + Space(20-len(STR0019)) + aFilter[3,2])//"Centro de Custos: "
AddMsgLog(OemToAnsi(STR0020) + Space(20-len(STR0020)) + aFilter[4,2])//"Local de Pagamento: "

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Montagem do Array de Tabelas/Campos e Chaves						       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
AddMsgLog(Replicate("-", 80))
If !lGrid
	AddMsgLog(OemToAnsi(STR0041))	//"Carga das Tabelas de Calculo..."
EndIf
GetTableCalc( @aTables )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Bloqueia o registro do RCH											   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If !fLockRCH( xFilial("RCH"), cProces, , cRoteiro )
	Return (NIL)
EndIf

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carregar os mnemonicos que serao utilizados no calculo			       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !lGrid
		AddMsgLog(OemToAnsi(STR0042))	//"Carga dos Mnemonicos..."
		If !fGetMnem(@aMnemonicos, @aOperador, cProces, cRoteiro,,, aTables )
			Aviso( OemToAnsi(STR0027), OemToAnsi(STR0035), {STR0003} ) // "Atenção"##"Não foi possivel carregar os Mnemonicos e/ou Operadores!"##"OK"
			AddMsgLog(OemToAnsi(STR0035))
			nRet := -1
			break
		EndIf
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carregar o array de verbas e verbas por Processo					       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !lGrid

		AddMsgLog(OemToAnsi(STR0086))	// "Carga das Verbas..."
		fCarPD()

		AddMsgLog(OemToAnsi(STR0043))	//"Carga das Verbas por Processo..."
		If !fGetPdRot(@aPd, @aRotPd, aTables, cProces, cRoteiro, cPaisLoc $ "PAR" )
			Aviso( OemToAnsi(STR0027), OemToAnsi(STR0034), {STR0003} ) // "Atenção"##"Não foi possivel carregar as Verbas por Processo!"##"OK"
			AddMsgLog(OemToAnsi(STR0034))
			nRet := -1
			break
		EndIf
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carregar o array da Definicao de Tabelas - Em HRP Tabelas Numericas 	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !lGrid
		AddMsgLog(OemToAnsi(STR0044))	//"Carga das Tabelas de Parametros (Definicao de Tabelas)..."
		If !fGetDefTab(@aDefTab, cProces, cRoteiro, dDataIni, @cMsgErro)
			Aviso( OemToAnsi(STR0027), OemToAnsi(STR0037) + " " + cMsgErro, {STR0003} ) // "Atenção"##"Não foi possivel carregar as Manutenções de Tabelas!"##"OK"
			AddMsgLog(OemToAnsi(STR0037) + " " + cMsgErro)
			nRet := -1
			break
		EndIf
	EndIf
	         
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carregar o Array de Formulas                          		   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If !lGrid
		AddMsgLog(OemToAnsi(STR0063))	//"Carga das Formulas ..."
		__aFormulas := fGetForm(aRotPd, aTables)
		If Len(__aFormulas) == 0
			Aviso( OemToAnsi(STR0027), OemToAnsi(STR0064), {STR0003} ) // "Atenção"##"Não foi possivel carregar as Formulas!"##"OK"
			AddMsgLog(OemToAnsi(STR0064))
			nRet := -1
			break
		EndIf
		AddMsgLog("")
		AddMsgLog("")
	EndIf
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carregar o Array de Tipos de Ausencia						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/	
	If !lGrid
		fGetTypeAus( @aTypAus, aTables )
	EndIf
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Atualizar o campo de Status para 2 - Calculando					       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If lOrigem
		RCH->(dbGoTo(nRecRCH))
	EndIf
	
	RecLock("RCH",.F.)
	RCH->RCH_STATUS := "2"
	
	nRecRCH := RCH->(Recno())
	If !lOrigem
		nRecRCH := RCH->(Recno())
	EndIf	
	RCH->( MsUnlock() )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Filtro do Browse                                             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	DbSelectArea( cTabMestra )

	If !Empty(cFilter)
		cFilter += " and "
	EndIf
	cFilter		+= "RA_PROCES" + " = '" + cProces + "'"
	If lGPEM040B .and. cPaisLoc== "MEX"
		If !Empty(cExpFiltro)
			cFilter += " and " + cExpFiltro 
		EndIf
	EndIf
	If nStatus == 1
		cFilter		+= " and RA_SITFOLH" + " <> 'D'"
	ElseIf nStatus == 2
		cFilter		+= " and RA_SITFOLH" + " = 'D'"
	EndIf

	
	cFilterAux := "%" + cFilter + " and SRA.D_E_L_E_T_ = ' '" + "%"

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Contagem de Registros para Barra de Movimentacao  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cAliasMestra:= "Q"+cTabMestra

	MakeStrExp(@aFilter)
	cFilter := "(" + cFilter + ")"

	cExp := "("
	For nX := 1 To Len(aFilter)
		If !Empty(aFilter[nX,3])
			If len(cExp) > 1
				cExp += " and "
			EndIf
		    cExp += aFilter[nX,3]
		EndIf		
	Next nX
	cExp += ")"
	If cExp <> "()"
		cFilter += " and " + cExp
	EndIf
	cFilter := "%" + cFilter + "%"

	//Caso o trace estiver ativo e o numero de funcionários selecionados
	// for maior que 50% dos funcionarios, nao prosseguir com o calculo, pois
	// o arquivo de log ficara muito grande. 
	nTraceOn := 0
	AeVal(__aFormulas,{ |X| nTraceOn += aScan(x, { |y| y[3] = "TRACE_ON" } )})
	if (nTotFunc > 50 .and. (nTotReg > (nTotFunc/2))) .and. (nTraceOn > 0 .Or. lHabTrace)
		Aviso( OemToAnsi(STR0027), OemToAnsi(STR0045+STR0065), {STR0003} ) // "Atenção"##"Proceso de Calculo Abortado..."##"Muitos funcionarios selecionados com o trace ativado."##"OK"
		AddMsgLog(OemToAnsi(STR0045+STR0065))

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Atualiza o campo de Status para 0 - Normal					           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		RecLock("RCH",.F.)
		RCH->RCH_STATUS := "0"
		RCH->( MsUnlock() )

		nRet := -1
		break
	EndIf
	
	If SELECT(cAliasMestra) > 0
		(cAliasMestra)->(DbCloseArea())
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Geracao da Query com os Registros a serem processados        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	BeginSql alias cAliasMestra
		SELECT SRA.RA_FILIAL, SRA.RA_MAT, SRA.RA_PROCES, SRA.R_E_C_N_O_ SRARecno
		FROM %table:SRA% SRA
		WHERE %exp:cFilter%
		and SRA.D_E_L_E_T_ = ' '
	    ORDER BY SRA.RA_MAT
	EndSql

	// Verificar do GRID sera feito no Prepare Enviromnent //
	// Quando Incluir um novo item nesta lista devera ser declarado no GRID //
	If !lGrid 
		Sx2ChkModo( "RCJ", NIL, .F., @cMod1, NIL )
		cModRCJ := cMod1
		Sx2ChkModo( "RCH", NIL, .F., @cMod1, NIL )
		cModRCH := cMod1
		Sx2ChkModo( "SQB", NIL, .F., @cMod1, NIL )
		cModSQB := cMod1
		Sx2ChkModo( "SRJ", NIL, .F., @cMod1, NIL )
		cModSRJ := cMod1
		If cPaisLoc <> "ARG"
			Sx2ChkModo( "RCO", NIL, .F., @cMod1, NIL )
			cModRCO := cMod1
			Sx2ChkModo( "RGC", NIL, .F., @cMod1, NIL )
			cModRGC := cMod1
		Endif
		If cPaisLoc <> "MEX" .And. cPaisLoc <> "ARG"
			cMod1:= ""
			Sx2ChkModo( "RGE", NIL, .F., @cMod1, NIL )
			cModRGE := cMod1
		EndIf
		Sx2ChkModo( "CTT", NIL, .F., @cMod1, NIL )
		cModCTT := cMod1		
		Sx2ChkModo( "SRC", NIL, .F., @cMod1, NIL )
		cModSRC := cMod1
		Sx2ChkModo( "RCE", NIL, .F., @cMod1, Nil )
		cModRCE := cMod1
		Sx2ChkModo( "SR6", NIL, .F., @cMod1, Nil )
		cModSR6 := cMod1
		Sx2ChkModo( "SR3", NIL, .F., @cMod1, Nil )
		cModSR3 := cMod1
		Sx2ChkModo( "SR7", NIL, .F., @cMod1, Nil )
		cModSR7 := cMod1 
		Sx2ChkModo( "SQ3", NIL, .F., @cMod1, NIL )
		cModSQ3 := cMod1		
		DbSelectArea("SRC")
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seta o Valor para a Funcao de Incremento                     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !lGrid .And. !isBlind()
		BarGauge1Set( nTotReg )
	EndIf  
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Exclui os Registros da Tabela de Movimentos.                 ³
	³ Para calculo de ferias e rescisao individual so exclui regis-³
	³ tros referentes ao cabecalho de ferias/rescisao que se esta  ³
	³ calculando.                                                  ³
	³ Nao apaga nada para rescisao/ferias coletivas.               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !lOrigem 
		IF ( Type("lColetiva") == "U" ) 
			cFilter:= Substr( cFilterAux, 2, (Len(cFilterAux)-2) )
			cFilter+= " And "  
			cFilter+= "RC_FILIAL = '" + SRA->RA_FILIAL + "'" 
			cFilter+= " And "  
			cFilter+= "RC_MAT = '" + SRA->RA_MAT + "'" 
			cFilter+= " And "  
			cFilter+= "RC_DTREF = '" + DtoS(dDataKey) + "'"
			cFilter:= "%" + cFilter + "%"
		Elseif lVarColeti .and. lGPEM040B .and. cPaisLoc=="MEX"
			cFilter:= Substr( cFilterAux, 2, (Len(cFilterAux)-2) )
			cFilter+= " And "  
			cFilter+= "RC_FILIAL = '" + SRA->RA_FILIAL + "'"  
			cFilter:= "%" + cFilter + "%"
		Elseif lColetiva
			lDelMov:= .F.		
		Endif
   	Endif       
   	
          
   	If lDelMov 
   		fDelMovSRC(cRoteiro, cPeriodo, cNumPag, cFilter)
   	Endif

	While (cAliasMestra)->( !Eof() )
  
		IF ( lAbortPrint )
			Break
		EndIF
		
		
		DbSelectArea("SRA")
		DbGoTo( (cAliasMestra)->( SRARecno ) )
		If lGPEM040B .and. cPaisLoc=="MEX" 
			If !GRSRG630()
				//Estaus Aplicado y Periodo aplicacion abierto
				//no realizar ninguna actualización (SRG y SRC) 
				(cAliasMestra)->( DbSkip() )
				Loop
			EndIF
		EndIF
		If !lGrid
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Movimenta cursor para movimentacao da barra 				   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If !isBlind()
				IncPrcG1Time(if(nTraceOn > 0 .Or. lHabTrace,OemToAnsi(STR0066),OemToAnsi(STR0067)) + " -> " + SRA->RA_MAT + "-" + SRA->RA_NOME , nTotReg , cTimeIni , .T. , 1 , 1 , .T. ) //"TRACE ATIVADO"#"TRACE DESATIVADO"
	        EndIf
			If cCalcFun	<> SRA->RA_FILIAL + SRA->RA_MAT
				For nX := 1 To Len(aTables)
					If aTables[nX, 4] == 1
						aSvCols := GdRmkaCols(aTables[nX, 2]) // Gera uma linha do aCols para a tabela com os inicializadores padrão
						aTables[nX,5] := aClone(aSvCols[1])
						RollBackSx8()//Despreza os numeros gerados por sx8 para inicializadores padrão
					EndIf
				Next nX 
			EndIf

			If cFilFun	<> SRA->RA_FILIAL
				cRCJFilTab := If( cModRCJ=="E", SRA->RA_FILIAL, xFilial("RCJ"))
				cRCHFilTab := If( cModRCH=="E", SRA->RA_FILIAL, xFilial("RCH"))
				cSQBFilTab := If( cModSQB=="E", SRA->RA_FILIAL, xFilial("SQB"))
				cSRJFilTab := If( cModSRJ=="E", SRA->RA_FILIAL, xFilial("SRJ"))
				cCTTFilTab := If( cModCTT=="E", SRA->RA_FILIAL, xFilial("CTT"))
				cRCEFilTab := If( cModRCE=="E", SRA->RA_FILIAL, xFilial("RCE"))
				cSR6FilTab := If( cModSR6=="E", SRA->RA_FILIAL, xFilial("SR6"))
				cSR3FilTab := If( cModSR3=="E", SRA->RA_FILIAL, xFilial("SR3"))
				cSR7FilTab := If( cModSR7=="E", SRA->RA_FILIAL, xFilial("SR7"))
				cSQ3FilTab := If( cModSQ3=="E", SRA->RA_FILIAL, xFilial("SQ3"))

				If !(cPaisLoc $ "ARG*DOM")
					cRCOFilTab := If( cModRCO=="E", SRA->RA_FILIAL, xFilial("RCO"))
					cRGCFilTab := If( cModRGC=="E", SRA->RA_FILIAL, xFilial("RGC"))
				Endif
				
				If cPaisLoc <> "MEX" .And. cPaisLoc <> "ARG" .AND. !Empty(cModRge)
					cRGEFilTab := If( cModRGE=="E", SRA->RA_FILIAL, xFilial("RGE"))
				EndIf				
			EndIf
			
			cCalcFun := SRA->RA_FILIAL + SRA->RA_MAT
			cFilFun	 := SRA->RA_FILIAL
            
            /*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Para calculos coletivos, valida se pode ou nao realizar o	   ³
			³ calculo para o funcionario posicionado.                  	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If (cPaisLoc $ "ARG*DOM") .And. ( lVarColeti .And. lColetiva )
				If lGPEM031 .Or. lGPEM032 //ferias coletivas
					If !(fValFerCol())
						lCalcula:= .F.
					Else
						lCalcula:= .T.
					Endif
				Else //rescisao coletiva
					If !(fValResCol())
						lCalcula:= .F.
					Else
						lCalcula:= .T.
					Endif				
				Endif
			Elseif (cPaisLoc $ "ARG") .And. ( lVarColeti .And. lColetInd ) 
					If !(fValFerCol())
						lCalcula:= .F.
					Else
						lCalcula:= .T.
					Endif
			Endif 
			
			If lCalcula
					
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carga no array (aIncid) de incidencias - Tabela RGB          ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				aIncid := {}
			 	fGetIncid(@aIncid, SRA->RA_FILIAL, SRA->RA_MAT, cProces, cRoteiro, cPeriodo, cNumPag, aTables )
	
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega o array (aValFut) de Valores Futuros - Tabela SRK    ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				aValFut := {}
				fGetValFut(@aValFut, SRA->RA_FILIAL, SRA->RA_MAT, cPeriodo, cNumPag, aTables, cRoteiro )
	
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega o array (aAfast) de Afastamentos - Tabela SR8		   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				aAfast := {}
				fGetAfast(@aAfast, SRA->RA_FILIAL, SRA->RA_MAT, aTables )
	
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega o array (aBenef) de Beneficiários - Tabela SRQ	   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/			
				aBenef := {}
				fGetBenef( SRA->RA_FILIAL, SRA->RA_MAT, @aBenef, aTables )               
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega o array (aLanFix) de Lançamentos Fixos - Tabela RG1    ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				aLanFix := {}
				fGetLanFix(@aLanFix, SRA->RA_FILIAL, SRA->RA_MAT, aTables )
	
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Posicionar os arquivos nos respectivos registros do funciona-³
				³ rio.                                                         ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				DbSelectArea( "RCJ" )	// Cadastro de Processos
				DbSetOrder( nOrdRcj )
				DbSeek( cRCJFilTab + SRA->RA_PROCES, .F. )
	
				DbSelectArea( "RCH" )	// Cadastro de Periodos
				DbSetOrder( nOrdRch )
				DbSeek( cRCHFilTab + cProces + cPeriodo + cNumPag + cRoteiro, .F. )
	
				DbSelectArea( "SQB" )	// Cadastro de Departamentos
				DbSetOrder( nOrdSqb )
				DbSeek( cSQBFilTab + SRA->RA_DEPTO, .F. )
	                 
				DbSelectArea( "SRJ" )	// Cadastro de Postos/Funcoes
				DbSetOrder( nOrdSrj )
				DbSeek( cSRJFilTab + SRA->RA_CODFUNC, .F. )
	
				DbSelectArea( "CTT" )	// Cadastro de Centro de Custos
				DbSetOrder( nOrdCtt )
				DbSeek( cCTTFilTab + SRA->RA_CC, .F. )
	
				If !(cPaisLoc $ "ARG*DOM")
					If cPaisLoc != "CHI"
						DbSelectArea( "RCO" )	// Registro Patronal
						DbSetOrder( nOrdRco )
						DbSeek( cRCOFilTab + SRA->RA_CODRPAT, .F. )
					EndIf
					DbSelectArea( "RGC" )	// Localidade de Pago
					DbSetOrder( nOrdRgc )
					DbSeek( cRGCFilTab + SRA->RA_KEYLOC, .F. )           
				Endif
				
				If cPaisLoc <> "MEX" .And. cPaisLoc <> "ARG" .AND. !Empty(cModRge)
					DbSelectArea( "RGE" )	// Contratos de Trabalho
					DbSetOrder( nOrdRge )
					DbSeek( cRGEFilTab + SRA->RA_MAT, .F. )
				EndIf

				DbSelectArea( "RCE" )	// Sindicatos
				DbSetOrder( nOrdRce )
				DbSeek( cRCEFilTab + SRA->RA_SINDICA, .F. )
				
				DbSelectArea( "SR6" )	// Turnos de Trabalho
				DbSetOrder( nOrdSr6 )
				DbSeek( cSR6FilTab + SRA->RA_TNOTRAB, .F. )
				
				DbSelectArea( "SR3" )	// Historico de Valores Salariais
				DbSetOrder( nOrdSr3 )
				DbSeek( cSR3FilTab + SRA->RA_MAT, .F. )
				
				DbSelectArea( "SR7" )	// Historico de Alteracoes Salariais
				DbSetOrder( nOrdSr7 )
				DbSeek( cSR7FilTab + SRA->RA_MAT, .F. )    
				
				DbSelectArea( "SQ3" )	// Cadastro de Postos/Funcoes
				DbSetOrder( nOrdSq3 )
				DbSeek( cSQ3FilTab + SRA->RA_CARGO, .F. )				
				
			 	DbSelectArea( "SRV" )	// CADASTRO DE VERBAS
			 	DbSetOrder( nOrdSrv )
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Cria cabecalho de ferias e itens de ferias para o funcionario (se calculo³
				³ coletivo) e posiciona no registro corretamente.                          ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If (cPaisLoc $ "ARG*DOM")
					If ( lGPEM031 .Or. lGPEM032 ) .And. lVarColeti .And. lColetiva 
						fCriaCabFer()
					Endif
					
					DbSelectArea( "RHI" )	// Cabeçalho de ferias
					cFilTab := If( cModSR3=="E", SRA->RA_FILIAL, xFilial("RHI"))
					If lGPEM031 .Or. lGPEM032
						DbSetOrder( nOrdRhi )
						DbSeek( cFilTab + SRA->RA_MAT + DtoS(dDataKey), .F. )
					Else
						DbSetOrder( nOrdRhi )
						DbSeek( cFilTab + SRA->RA_MAT + cPeriodo, .F. )
					Endif
				Endif	
				     
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Cria cabecalho de rescisao para o funcionario (se calculo coletivo)      ³
				³ e posiciona no registro corretamente.                                    ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If cPaisLoc $ "DOM*ARG" 
					If lGPEM042 .And. lVarColeti .And. lColetiva
						fCriaCabRes()
					Endif
					
					DbSelectArea( "SRG" )	// Cabeçalho de rescisao
					cFilTab := If( cModSR3=="E", SRA->RA_FILIAL, xFilial("SRG"))
					If lGPEM042
						DbSetOrder( nOrdSrg )
						DbSeek( cFilTab + SRA->RA_MAT + DtoS(dDataKey), .F. )
					Else
						DbSetOrder( nOrdSrg )
						DbSeek( cFilTab + SRA->RA_MAT + cPeriodo, .F. )
					Endif	
				Endif	
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Restaurar as Variaveis statics do calculo por funcionario	   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				RstCalFun()
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Execucao da Rotina do Calculo do Funcionario           	   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				nRet := CalcProc( aPd			,;
								  aRotPd		,;
								  aMnemonicos	,;
								  aOperador		,;
								  aDefTab		,;
								  aIncid		,;
								  aValFut		,;
								  aAfast		,;
								  aTables		,;
								  aTypAus		,;
								  aBenef		 ;
								 )
				If nRet < 0
					AddMsgLog(OemToAnsi(STR0045)) //"Processo de Calculo Abortado..."
					If !lVarios
						Aviso( OemToAnsi(STR0027), OemToAnsi(STR0045 + STR0061), {STR0003} ) // "Atenção"##"Processo de Calculo Abortado..."##"Favor Consultar o Log de Calculo."##"OK"
					Else
						aAdd(aLog, STR0004 + cProces + " | " + OemToAnsi(STR0045 + STR0061))//"Proceso: "##"Processo de Calculo Abortado..."##"Favor Consultar o Log de Calculo."##"OK"
					EndIf
					(cAliasMestra)->(DbCloseArea())
					Break
				Else
					nCountReg++
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Atualizar o campo de Status do cabecalho de ferias/rescisao para 2 - Calculado    ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If lGPEM031 .Or. lGPEM032
						If !RHI->(Eof())
							RecLock("RHI", .F.)      
							RHI->RHI_STATUS := "2"
							RHI->(MsUnlock())
							RHI->(dbCloseArea())	 
						EndIf		
						If SRA->RA_SITFOLH # 'F'
							RecLock("SRA", .F.) 
								SRA->RA_SITFOLH := 'F'
							SRA->(MsUnlock())
						EndIf
					ElseIf lGPEM042 .or. (lGPEM630 .and. cPaisLoc=="MEX")
						RecLock("SRG", .F.)      
						SRG->RG_EFETIVA := "2"  // If(cTipCalc=="1","2","1")
						SRG->(MsUnlock())
					EndIf
					
				EndIf
		   
			Endif			
		// Calculo com utilizacao do GRID //
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Gerar Array para Calculo em GRID                                       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If nCountReg == 0 .Or. nCountReg >= nLoteGrid
				Aadd(aCall, {} )
				nRegGrid++
				nCountReg := 0
			EndIf
			nCountReg++

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Adiciona ao grid variaveis para garantir falha na thread caso o RCH nao³
			³esteja posicionado no registro correto									³			
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/			
			If (nCountReg == 1)
				aProces		:= { "", "", "", "", "" }
				aProces[1] := cProces 
				aProces[2] := cRoteiro
				aProces[3] := cPeriodo
				aProces[4] := cNumPag
				aProces[5] := nRecRCH
			Else
				aProces := { "" }
			EndIf			
			Aadd(aCall[nRegGrid], {nRegGrid, "SRA", (cAliasMestra)->( SRARecno ), Len(aCall), aProces } )
			
        EndIf
		(cAliasMestra)->( DbSkip() )
	EndDo
	
	#IFDEF TOP
		// Start do Calculo em GRID //
		If lGRID
			CalcGrid(aCall, aTables)
			nRet := nRetCalc
			If nRet < 0 
				If !lVarios
					If !lAutomato
						Aviso( OemToAnsi(STR0027), OemToAnsi(STR0045 + STR0061), {STR0003} ) // "Atenção"##"Processo de Calculo Abortado..."##"Favor Consultar o Log de Calculo."##"OK"
					Else
						Conout(OemToAnsi(STR0027), OemToAnsi(STR0045 + STR0061), {STR0003}) // Console- "Atenção"##"Processo de Calculo Abortado..."##"Favor Consultar o Log de Calculo."##"OK"
					EndIf
				Else
					aAdd(aLog, STR0004 + cProces + " | " + OemToAnsi(STR0045 + STR0061))//"Proceso: "##"Processo de Calculo Abortado..."##"Favor Consultar o Log de Calculo."##"OK"
				EndIf
			EndIf
		EndIf
	#ENDIF

	(cAliasMestra)->(DbCloseArea())

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Atualiza o campo de Status para 0 - Finalizando					       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If lOrigem .and. !(nRecRCH == nRecRCHAux)
	nRecRCH := nRecRCHAux	
EndIf                      

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Libera o registro														   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
fLockRCH( xFilial("RCH"), cProces, , cRoteiro, , .T. )

RCH->(dbGoTo(nRecRCH))
If !empty(RCH->RCH_STATUS ) .and. RCH->RCH_STATUS != "0" 	//Garante que ha necessidade de alterar o RCH_STATUS
	RecLock("RCH",.F.)
	RCH->RCH_STATUS := "0"
	RCH->( MsUnlock() ) 
Endif

//-- Gera log exclusivo do calculo de ferias 
If !(len(aNCalcCol) < 1)
	AddMsgLog("")
	AddMsgLog("")
	AddMsgLog(Replicate("-", 100) )
	AddMsgLog( OemToAnsi(STR0085) )	//"As ferias coletivas nao foram calculadas para os seguintes funcionarios:"
	For nAux:= 1 to len(aNCalcCol)
		AddMsgLog(aNCalcCol[nAux, 1] + Space(10-len(aNCalcCol[nAux, 1])) + aNCalcCol[nAux, 2])
	End	
Endif

//-- Gerar no arquivo de Log as estatisticas do calculo
nTimeCalc := Seconds() - nTimeIni
cTimeCalc := SecsToTime( nTimeCalc )
nTimeFunc := MediumTime( cTimeCalc, nTotReg, .T. )
AddMsgLog("")
AddMsgLog("")
AddMsgLog(Replicate("-", 100) )
AddMsgLog( OemToAnsi(STR0052) + ' ' + SecsToTime(nTimeIni))	//"Inicio do Calculo:"
AddMsgLog( OemToAnsi(STR0047) + ' ' + Time() ) 				//"Final do Calculo:"
AddMsgLog( OemToAnsi(STR0048) + ' ' + cTimeCalc ) 			//"Duracao do Processo de Calculo:"
AddMsgLog( OemToAnsi(STR0049) + ' ' + Str(nTotReg,6)) 		//"Total de Funcionarios a Processar:"
AddMsgLog( OemToAnsi(STR0050) + ' ' + Str(nCountReg,6)) 	//"Total de Funcionarios Processados:"
AddMsgLog( OemToAnsi(STR0051) + ' ' + nTimeFunc) 			//"Tempo Medio por Funcionario:"
AddMsgLog(Replicate("-", 100) )

CloseLogCalc()

If nRet == 0
	If (FunName() == "GPEM039CHI")
		If lGpem039Chi
			Aviso( OemToAnsi(STR0027), OemToAnsi(STR0062 + " " + STR0061), {STR0003} ) // "Atenção"##"Processo de Calculo Finalizado!"##"Favor Consultar o Log de Calculo."##"OK"			
		EndIF
	Else
		If !lAutomato
			Aviso( OemToAnsi(STR0027), OemToAnsi(STR0062 + " " + STR0061), {STR0003} ) // "Atenção"##"Processo de Calculo Finalizado!"##"Favor Consultar o Log de Calculo."##"OK"
		Else
			ConOut(OemToAnsi(STR0027), OemToAnsi(STR0062 + " " + STR0061), {STR0003})// "Atenção"##"Processo de Calculo Finalizado!"##"Favor Consultar o Log de Calculo."##"OK"
		EndIf
	EndIf
endif

RestArea( aArea )

Return Iif(FunName() == "GPEM039CHI",nRet,Nil)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³CalcGrid	 ³ Autor ³ Mauricio Takakura  ³ Data ³16/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Inclusao do Calculo Atraves de GRID - Multiprocessamento   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³CalcGrid 													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³ Gpem022 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
#IFDEF TOP
	Static Function CalcGrid(aCall, aTables)
	Local aParAmb	:= {}
	Local aEtiquetas:= {}
	Local aDirectory
	Local cTextLog
	Local cMsgGrid
	Local cDirect
	Local cArchive
	Local cFileLog
	Local cThread
	Local aMneParm 	:= {}
	Local aOpeParm	:= {}
	Local aPdParm	:= {}
	Local aRotParam	:= {}
	Local aDefParam	:= {}
	Local aTypAusP	:= {}

	Local lRet 		:= .T.
	Local lFirst
	Local lMsgUser

	Local nI, nT, nX, nJ, nTG, nTamanho
	Local nHdl
	Local nLinha
	Local nTamArq
	Local nPosRetorno

	Private oGrid

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Criacao do Objeto GRID e Processamento				       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	oGrid := GridClient():New()
	oGrid:nWAIT4AGENTS	:= 3600		//-- 600 segundos = 10 minutos
	oGrid:nEndTimeOut	:= 0		//-- 0 desativa o time-out para a inicializacao do novo processo de grid
	
	If ValType(oGrid) == "U"
		nRetCalc := -1
		AddMsgLog(OemToAnsi(STR0070)+CRLF) //"Falha na criacao do Objeto GridClient. Impossivel executar processo em GRID."
		lRet := .F.
	EndIf
	
	// Execucao do GRID
	If lRet    
		cLogPrinc := RetNameLog()                                                             
        
		// Verifica se no SERVER.INI esta configurado o showstatus para envio ao Server as msgs do Grid
		If __lSrvShowMsg = NIL
			__lSrvShowMsg := ( getpvprofstring("GridAgent","ShowStatus","0",getadv97()) == "1" )
		Endif


		Gp022Pamb(__lSrvShowMsg,cProces, cRoteiro,aTables,@aMneParm,@aOpeParm,@aPdParm,@aRotParam,@aDefParam,@aTypAusP)

        aParAmb := {cEmpAnt,cFilAnt,dDataBase,aEmpresas,cUsuario,;  // Parametros Public do sistemas
				   {cProces, cRoteiro, cPeriodo, cNumPag, lHabGrab, cLogPrinc, dDataIni, __lSrvShowMsg},{aMneParm,aOpeParm,aPdParm,aRotParam,aDefParam,aTypAusP};
					}

		// Chama a execucao em Grid. Caso ela retorne .F., ou o grid nao pode ser iniciado, 
		// ou algum processo deu erro, ou um ou mais itens nao foram processados.
		lRet := oGrid:BatchExec("GPEM022AMB",aParAmb,"GPEM022GRD",aCall, "FinishGrid")

		If !lRet .and. Empty(oGrid:aGridThreads)
			nRetCalc := -1
			AddMsgLog( OemToAnsi(STR0071) ) // "Nenhum Agente do GRID disponivel no Momento."
			lRet := .F.
		EndIf

		// Mensagens de Erros gerados pelo GRID //
		cTextLog := oGrid:GetError()
		If !Empty(cTextLog)
			AddMsgLog(CRLF + Replicate( "-", 100))
			AddMsgLog( OemToAnsi(STR0072) ) // "Inconsistencias geradas pela Biblioteca GRID"
			AddMsgLog(Replicate( "-", 100))
			AddMsgLog(OemToAnsi(cTextLog))
		EndIf

		// Buscar o codigo de Error - nRet //
		If !empty(oGrid:aErrorProc)
			// [1] : Numero sequencial da instrucao enviada que nao foi processada
			// [2] : Parametro enviado para processamento 
			// [3] : String contendo informacoes do ERRO
			nT := Len(oGrid:aErrorProc)
			For nI := 1 to nT

				nTamanho := MlCount(oGrid:aErrorProc[nI][3], 150)
				// Verificar se existem mensagem do usuario ou ocorreu erro fatal do sistema //
				cTextLog := ""
				lMsgUser := .F.
				For nX := 2 To nTamanho
					cMsgGrid := MemoLine( oGrid:aErrorProc[nI][3], 150, nX )
					If Substr(cMsgGrid,1,9) == 'ERRORNRET'
						lMsgUser := .F.
                    EndIf
					If lMsgUser
						cTextLog += cMsgGrid
					EndIf
					If Substr(cMsgGrid,1,11) == '##ERRORNRET'
					   nRetCalc := Val(Substr(cMsgGrid,12,2))
					   lMsgUser := .T.
					EndIf
				Next nX
			Next nI
		Endif

		// Requisicoes que nao foram processadas //
		If !Empty(oGrid:aSendProc)

			AddMsgLog(CRLF + Replicate( "-", 100))
			AddMsgLog(OemToAnsi(STR0075) ) // "Requisições não processadas pelo GRID"
			AddMsgLog(Replicate( "-", 100))

			// [1] : Numero sequencial da instrucao enviada que nao foi processada
			// [2] : Parametro enviado para processamento 
			// [3] : Retorno da execuçao
			nT := len(oGrid:aSendProc)
			For nI := 1 to nT  
				AddMsgLog( OemToAnsi( STR0074 ) + " " + Str(oGrid:aSendProc[nI,1],5)) // "Requisição:"
			Next nI
		EndIf
	
		// Recupera retornos das chamadas - Mensagens de Log do Calculo (Retorno diferente de NIL da funcao GPEM022GRD)
		// Esta sendo utilizando no momento para geracao da quantidade de funcionarios processados
		// e para retorno dos arquivos de LOG
		If !empty(oGrid:aInfoProc)  
		    If FindFunction("GridCliVersion")
		        // fonte  novo - terceiro elemento = identificador
       			// [1]: Numero sequencial da instrucao enviada que nao foi processada
				// [2]: Parametro enviado para processamento
				// [3]: identificador
				// [4]: Retorno da execuçao 
				nPosRetorno := 4					        	
		    Else
       			// [1] : Numero sequencial da instrucao enviada que nao foi processada
				// [2] : Parametro enviado para processamento
				// [3] : Retorno da execuçao     
				nPosRetorno := 3
		    Endif                        
		    
 			nTG:= Len(oGrid:aInfoProc) 					    
 			nT := Len(oGrid:aInfoProc[1,nPosRetorno])
			nCountReg := 0
 			For nJ:=1 To nTG
				For nI := 1 To nT 
					nCountReg += oGrid:aInfoProc[nJ,nPosRetorno,nI]
				Next nI
			Next nJ
		Endif

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Unificar os Logs das Threads no LOG Principal			       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		// Retornar os arquivos de Log de cada Thread
		cDirect		:= Substr(cLogPrinc,1,AT('\LOG',cLogPrinc))
		cArchive 	:= Substr(cLogPrinc,1,AT('.LOG',cLogPrinc)-1)
		cArchive 	+= 'THR*.THR'
		aDirectory := Directory(cArchive)
		
		For nX := 1 To Len( aDirectory )

	        lFirst := .T.
			cFileLog := aDirectory[nX,1]
			cThread := Substr(cFileLog, AT('THR',cFileLog)+3, AT('.THR',cFileLog)-4)

			For nI := 1 To 60
				nHdl := FOpen(cDirect + cFileLog, 1+64)
        		If nHdl > 0
        			Exit
        		EndIf
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Nao aguardar mais para juntar os logs das threads			   ³
				³ Identificado muita demora em liberar recursos ao final do	   ³
				³ processamento do GRID										   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/        		
	            //Sleep( 1000 )
	   		Next nI
	   		
			If nHdl <= 0
				AddMsgLog("")
				AddMsgLog(Replicate("-", 80))
				AddMsgLog( OemToAnsi(STR0076) + " " + cThread ) //"Log do GRID processado no Servidor com Thread "
				AddMsgLog(Replicate("-", 80))
				AddMsgLog(OemToAnsi(STR0081))
				fErase(cDirect + cFileLog)
				Loop
			EndIf

			//Verifica o tamanho do arquivo
			nTamArq := fSeek(nHdl,0,2)     

			//Posiciona no inicio do arquivo
			fSeek(nHdl,0,0)

			For nLinha := 1 to nTamArq
				cString := Space(100)
				fRead(nHdl,@cString,100)
				If !Empty(AllTrim(cString))
					If lFirst
						AddMsgLog("")
						AddMsgLog(Replicate("-", 80))
						AddMsgLog( OemToAnsi(STR0076) + " " + cThread ) //"Log do GRID processado no Servidor com Thread "
						AddMsgLog(Replicate("-", 80))
						lFirst := .F.
					EndIf
					AddMsgLog( cString )
				EndIf
			Next nLinha

			fClose( nHdl )
			fErase(cDirect + cFileLog)

		Next nX
	EndIf

	Return
#ENDIF


Function Gp022PAmb(lSrvShowMsg,cProces, cRoteiro,aTables,aMneParm,aOpeParm,aPdParm,aRotParam,aDefParam,aTypAusP)
Local lRet			:= .T.
Local cLogServer
Local nQtdTime		:= 0
Local cTimeIni		:= Time()
Local nTimeIni		:= Seconds()
Local cTimeFim		:= ""
Local nTimeFim		:= 0

Local cMsgErro      := ""

If lSrvShowMsg
	cLogServer := "================================== RH LOG ==================================" + CRLF
	cLogServer += "[SIGAGPE-Gp022PAmb] " + CRLF
	cLogServer += "Start Time: " + cTimeIni + CRLF
EndIf


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carregar os mnemonicos que serao utilizados no calculo			       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

nQtdTime := Seconds()
AddMsgLog(OemToAnsi(STR0042))	//"Carga dos Mnemonicos..."
If !fGetMnem(@aMneParm, @aOpeParm, cProces, cRoteiro,,, aTables ) 
	AddMsgLog( OemToAnsi(STR0035) ) // "Atenção"##"Não foi possivel carregar os Mnemonicos e/ou Operadores!"##"OK"
	lRet := .F.
EndIf
If lSrvShowMsg
	cLogServer += OemToAnsi(STR0042) + "  :" + SecsToTime(Seconds() - nQtdTime) + CRLF
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carregar o array de verbas e verbas por Processo					       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If lRet
	nQtdTime := Seconds()
	AddMsgLog(OemToAnsi(STR0043))	//"Carga das Verbas por Processo..."
	If !fGetPdRot(@aPdParm, @aRotParam, aTables, cProces, cRoteiro )
		AddMsgLog(OemToAnsi(STR0034))
		lRet := .F.   
	EndIf
	If lSrvShowMsg
		cLogServer += OemToAnsi(STR0043) + "  :" + SecsToTime(Seconds() - nQtdTime) + CRLF
	EndIf
EndIf
	
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carregar o array da Definicao de Tabelas - Em HRP Tabelas Numericas 	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If lRet
	nQtdTime := Seconds()
	AddMsgLog(OemToAnsi(STR0044))	//"Carga das Tabelas de Parametros (Definicao de Tabelas)..."
	If !fGetDefTab(@aDefParam, cProces, cRoteiro, dDataIni, cMsgErro)
		AddMsgLog(OemToAnsi(STR0037) + " " + cMsgErro)
		lRet := .F.		
	EndIf
	If lSrvShowMsg
		cLogServer += OemToAnsi(STR0044) + "  :" + SecsToTime(Seconds() - nQtdTime) + CRLF
	EndIf
EndIf	
	          

If lRet
	nQtdTime := Seconds()
	AddMsgLog(OemToAnsi(STR0088))	//"Carga das Ausencias"
	fGetTypeAus( @aTypAusP, aTables )
	If lSrvShowMsg
		cLogServer += OemToAnsi(STR0088) + "  :" + SecsToTime(Seconds() - nQtdTime) + CRLF
	EndIf
EndIf	

cTimeFim		:= Time()
nTimeFim		:= Seconds()
	
If lSrvShowMsg
	cLogServer += "Finish Time: " + cTimeFim + CRLF
	cLogServer += "Exec Time: " + SecsToTime(nTimeFim - nTimeIni) + CRLF
	cLogServer += "============================================================================"
	Conout( cLogServer )
EndIf

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Gpem020Amb   ³ Autor ³ Mauricio Takakura  ³ Data ³11/07/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Preparacao do Ambiente para as Threads                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpem020Amb()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³ Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
#IFDEF TOP
	Function Gpem022Amb(aParms)
	Local aTime			:= {}
	Local cEmpParm  	:= aParms[1]	// Empresa conectada 	--> cEmpAnt
	Local cFilParm  	:= aParms[2]	// Filial conectada 	--> cFilAnt
	Local dDataParm 	:= aParms[3]	// Data Base			--> dDataBase
	Local aEmpParm		:= aParms[4]	// Array com empresas 	--> aEmpresas
	Local cUsuaParm 	:= aParms[5]	// Usuario conectado	--> cUsuario
	Local cLogPrinc 	:= aParms[6,06]	// Log Principal do Arquivo
	Local dDataIni		:= aParms[6,07]  
	Local lSrvShowMsg	:= aParms[6,08]// Configuracao do Server
	Local aMneParm		:= aParms[7][1]	// Array com empresas 	--> aMnemonicos
	Local aOpeParm		:= aParms[7][2]	// Array com empresas 	--> aOperadores
	Local aPdParm		:= aParms[7][3]
	Local aRotParam		:= aParms[7][4]
	Local aDefParam		:= aParms[7][5]
	Local aTypAusP		:= aParms[7][6]
	
	Local lRet			:= .T.
	Local cMod1
	Local cLogServer
	
	Local cTimeIni		:= Time()
	Local nTimeIni		:= Seconds()
	Local cTimeFim		:= ""
	Local nTimeFim		:= 0
	Local nQtdTime		:= 0
	Local cMsgErro      := ""

	If lSrvShowMsg
		cLogServer := "================================== RH LOG ==================================" + CRLF
		cLogServer += "[SIGAGPE-GPEM022AMB] Prepare Environment " + CRLF
		cLogServer += "Start Time: " + cTimeIni + CRLF
	EndIf
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Preparacao de novo ambiente - Tabelas e Variaveis.           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	RpcSetType(3)
	PREPARE ENVIRONMENT EMPRESA (cEmpParm) FILIAL (cFilParm) MODULO "GPE" FUNNAME "GPEM022"

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Funcoes de Carga do Sistema              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	RstMvBuff()
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Parametros a declara                                         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	_SetOwnerPrvt( 'cProces'   	, aParms[6,01] )			// Processo a ser calculado
	_SetOwnerPrvt( 'cRoteiro' 	, aParms[6,02] )			// Roteiro de Calculo
	_SetOwnerPrvt( 'cPeriodo' 	, aParms[6,03] )			// Periodo de calculo
	_SetOwnerPrvt( 'cNumPag'	, aParms[6,04] )			// Numero de Pagamento
	_SetOwnerPrvt( 'lHabGrab'	, aParms[6,05] )			// Se devera atualizar as tabelas 
    _SetOwnerPrvt( '__aFormulas', {} )
	_SetOwnerPrvt( 'aPd'		, aPdParm )			// Array com todas as verbas
	_SetOwnerPrvt( 'aRotPd'		, aRotParam )			// Array com todas as verbas por Processo
	_SetOwnerPrvt( 'aMnemonicos', aMneParm )			// Array com os mnemonicos
	_SetOwnerPrvt( 'aOperador'	, aOpeParm )			// Array com os operadores utilizados nas formulas
	_SetOwnerPrvt( 'aDefTab'	, aDefParam )			// Array com as Definicoes de Tabela
	_SetOwnerPrvt( 'aTables'	, {} )			// Array com as tabelas que podem ser utilizadas no calculo
	_SetOwnerPrvt( 'aTypAus'	, aTypAusP )			// Array com os Tipos de Ausencia
	_SetOwnerPrvt( 'aBenef'		, {} )			// Array com os Tipos de Ausencia	

	_SetOwnerPrvt( '__nSRMTab' 		, 0 )
	_SetOwnerPrvt( '__nSRMPd' 		, Nil )
	_SetOwnerPrvt( '__nSRMIncid' 	, Nil )
	_SetOwnerPrvt( '__nSRMValFut' 	, Nil )
	_SetOwnerPrvt( '__nSRMAcumul' 	, Nil )
	_SetOwnerPrvt( '__nSRMAusenc' 	, Nil )
	_SetOwnerPrvt( '__nSRMForm' 	, Nil )
	_SetOwnerPrvt( '__nSRMCodCrit' 	, Nil )
	_SetOwnerPrvt( '__nSRMBenef' 	, Nil )
	_SetOwnerPrvt( '__nSRMLanFix' 	, Nil )
	_SetOwnerPrvt( '__nRGBTab' 		, Nil )
	_SetOwnerPrvt( '__nRGBPD' 		, Nil )
	_SetOwnerPrvt( '__nRGBFun' 		, Nil )
	_SetOwnerPrvt( '__nRGBDtR' 		, Nil )
	_SetOwnerPrvt( '__nRGBCc' 		, Nil )
	_SetOwnerPrvt( '__nRGB3Tp' 		, Nil )
	_SetOwnerPrvt( '__nRGB2Tp' 		, Nil )
	_SetOwnerPrvt( '__nRGB1Tp' 		, Nil )
	_SetOwnerPrvt( '__nRGBQtS' 		, Nil )
	_SetOwnerPrvt( '__nRGBParc' 	, Nil )
	_SetOwnerPrvt( '__nRGBSem' 		, Nil )
	_SetOwnerPrvt( '__nRGBNuId' 	, Nil )
	_SetOwnerPrvt( '__nRGBPos' 		, Nil )
	_SetOwnerPrvt( '__nRGBDept' 	, Nil )	
	_SetOwnerPrvt( '__nPosD1' 		, Nil )
	_SetOwnerPrvt( '__nPosD2'  		, Nil )
	_SetOwnerPrvt( '__nPosD3'  		, Nil )
	_SetOwnerPrvt( '__nPosD4'  		, Nil )
	_SetOwnerPrvt( '__nPosD5'  		, Nil )
	_SetOwnerPrvt( '__nPosD6'  		, Nil )
	_SetOwnerPrvt( '__nPosD7'  		, Nil )	
	_SetOwnerPrvt( '__nSRKTab' 		, Nil )
	_SetOwnerPrvt( '__nSRKPD' 		, Nil )
	_SetOwnerPrvt( '__nSRKDtM' 		, Nil )
	_SetOwnerPrvt( '__nSRKNuId' 	, Nil )
	_SetOwnerPrvt( '__nSR8Tab' 		, Nil )
	_SetOwnerPrvt( '__nSR8PD' 		, Nil )
	_SetOwnerPrvt( '__nSR8Tipo' 	, Nil )
	_SetOwnerPrvt( '__nSR8DtIni' 	, Nil )
	_SetOwnerPrvt( '__nSR8NuId' 	, Nil )
	_SetOwnerPrvt( '__nRCMTab' 		, Nil )
	_SetOwnerPrvt( '__nRCMPD' 		, Nil )
	_SetOwnerPrvt( '__nRCMTipo' 	, Nil )
	_SetOwnerPrvt( '__nSRQTab' 		, Nil )
	_SetOwnerPrvt( '__nSRQPD' 		, Nil )
	_SetOwnerPrvt( '__nRG1Tab' 		, Nil )
	_SetOwnerPrvt( '__nRG1PD' 		, Nil )
	_SetOwnerPrvt( '__nSRCTab' 		, Nil )
	_SetOwnerPrvt( '__nSR7Tab' 		, Nil )
	_SetOwnerPrvt( '__nSR3Tab' 		, Nil )
	_SetOwnerPrvt( '__nRG1NuId' 	, Nil )
	_SetOwnerPrvt( '__nSRQNuId' 	, Nil )

	_SetOwnerPrvt( 'nOrdSrv'		, Nil )
	_SetOwnerPrvt( 'nOrdRcj'		, Nil )
	_SetOwnerPrvt( 'nCalRg9Ord'		, Nil )
	_SetOwnerPrvt( 'nCalRcpOrd'		, Nil )
	_SetOwnerPrvt( 'nCalRgbOrd'		, Nil )
	_SetOwnerPrvt( 'nCalSrkOrd'		, Nil )
	_SetOwnerPrvt( 'nCalRg7Ord'		, Nil )
	_SetOwnerPrvt( 'nCalSr7Ord'		, Nil )
	_SetOwnerPrvt( 'nCalSr3Ord'		, Nil )
	_SetOwnerPrvt( 'nCalRcmOrd'		, Nil )
	_SetOwnerPrvt( 'nCalSrqOrd'		, Nil )
	
	_SetOwnerPrvt( 'lHabLogCal'		, .F. )
	_SetOwnerPrvt( 'aTimes'			, {} )	
	_SetOwnerPrvt( '__lSrvAs400'	, .F. )
	
	GetTableCalc( @aTables )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Geracao do arquivo de Log para cada Thread ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
  	cArchive 	:= Substr(cLogPrinc,AT('\LOG', cLogPrinc)+1)
	cArchive 	:= Substr(cArchive ,1,AT('.LOG', cArchive)-1)
  	cArchive 	:= cArchive + 'THR' +AllTrim(Str(ThreadId(),12,0)) + ".THR"
  	CreateLog(cArchive, .F.)         

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carregar o Array de Formulas                          		   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If lRet
		nQtdTime := Seconds()
		AddMsgLog(OemToAnsi(STR0063))	//"Carga das Formulas ..."
		__aFormulas := fGetForm(aRotPd, aTables)
		If Len(__aFormulas) == 0 
			AddMsgLog(OemToAnsi(STR0064))
			lRet := .F.
		EndIf
		If lSrvShowMsg
			cLogServer += OemToAnsi(STR0063) + "  :" + SecsToTime(Seconds() - nQtdTime) + CRLF
		EndIf
	EndIf	
	
	If lRet 
		AddMsgLog("")
		AddMsgLog("")
			
		nQtdTime := Seconds()
		aEtiquetas  := fGetEtiquetas()
		fSetEtiquetas(aEtiquetas) 							// Array com as etiquetas utilizadas nas formulas
		If lSrvShowMsg
			cLogServer += OemToAnsi("Tempo da Carga Etiquetas ") + "  :" + SecsToTime(Seconds() - nQtdTime) + CRLF
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Valida o tipo de compartilhamento da tabela  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		Sx2ChkModo( "RCJ", NIL, .F., @cMod1, NIL )
		_SetOwnerPrvt( 'cModRCJ', cMod1 )
		Sx2ChkModo( "RCH", NIL, .F., @cMod1, NIL )
		_SetOwnerPrvt( 'cModRCH', cMod1 )
		Sx2ChkModo( "SQB", NIL, .F., @cMod1, NIL )
		_SetOwnerPrvt( 'cModSQB', cMod1 )
		Sx2ChkModo( "SRJ", NIL, .F., @cMod1, NIL )
		_SetOwnerPrvt( 'cModSRJ', cMod1 )
		Sx2ChkModo( "CTT", NIL, .F., @cMod1, NIL )
		_SetOwnerPrvt( 'cModCTT', cMod1 )
		If cPaisLoc <> "ARG"		
			Sx2ChkModo( "RCO", NIL, .F., @cMod1, NIL )
			_SetOwnerPrvt( 'cModRCO', cMod1 )
			Sx2ChkModo( "RGC", NIL, .F., @cMod1, NIL )
			_SetOwnerPrvt( 'cModRGC', cMod1 )
		Endif
		If cPaisLoc <> "MEX" .And. cPaisLoc <> "ARG"
			Sx2ChkModo( "RGE", NIL, .F., @cMod1, NIL )
			_SetOwnerPrvt( 'cModRGE', cMod1 )
		EndIf
		Sx2ChkModo( "SRC", NIL, .F., @cMod1, NIL )
		_SetOwnerPrvt( 'cModSRC', cMod1 )
		Sx2ChkModo( "RCE", NIL, .F., @cMod1, Nil )
		_SetOwnerPrvt( 'cModRCE', cMod1 )
		Sx2ChkModo( "SR6", NIL, .F., @cMod1, Nil )
		_SetOwnerPrvt( 'cModSR6', cMod1 )
		Sx2ChkModo( "SR3", NIL, .F., @cMod1, Nil )
		_SetOwnerPrvt( 'cModSR3', cMod1 )
		Sx2ChkModo( "SR7", NIL, .F., @cMod1, Nil )	
		_SetOwnerPrvt( 'cModSR7', cMod1 )
		Sx2ChkModo( "SQ3", NIL, .F., @cMod1, NIL )
		_SetOwnerPrvt( 'cModSQ3', cMod1 )
		 
		DbSelectArea("SRC")	
	
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Variaveis publicas do Sistema            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aEmpresas := aClone(aEmpParm)
		dDataBase := dDataParm
		cUsuario  := cUsuaParm
	EndIf
     
	cTimeFim		:= Time()
	nTimeFim		:= Seconds()
	
	If lSrvShowMsg
		cLogServer += "Finish Time: " + cTimeFim + CRLF
		cLogServer += "Exec Time: " + SecsToTime(nTimeFim - nTimeIni) + CRLF
		cLogServer += "============================================================================"
		Conout( cLogServer )
	EndIf
		
     
Return(lRet)
#ENDIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Gpem020Grd   ³ Autor ³ Mauricio Takakura  ³ Data ³12/07/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Rotina para execucao do GRID.                              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpem020Grd()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³ Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
#IFDEF TOP
Function GPEM022GRD(aCall)
	Local aIncid
	Local aValFut	:= {}
	Local aLogRet	:= {}
	    	
	Local cFilTab
	Local cMsgLog
	Local cLogServer
	
	Local nX
	Local nY 
	Local nTotReg
	Local nCountReg := 0
    Local nOrdRch	:= RetOrder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR" )
    Local nOrdSqb	:= RetOrder( "SQB", "QB_FILIAL+QB_DEPTO" )
    Local nOrdSrj	:= RetOrder( "SRJ", "RJ_FILIAL+RJ_FUNCAO" )
    Local nOrdCtt	:= RetOrder( "CTT", "CTT_FILIAL+CTT_CUSTO" )
	Local nOrdSr6	:= RetOrder( "SR6", "R6_FILIAL+R6_TURNO" )
	Local nOrdSr3	:= RetOrder( "SR3", "R3_FILIAL+R3_MAT+R3_DATA+R3_TIPO+R3_PD" )
	Local nOrdSr7	:= RetOrder( "SR7", "R7_FILIAL+R7_MAT+R7_DATA+R7_TIPO" )
	Local nOrdSq3	:= RetOrder( "SQ3", "Q3_FILIAL+Q3_CARGO+Q3_CC" )
	Local nOrdRce	:= RetOrder( "RCE", "RCE_FILIAL+RCE_CODIGO" )

    Local nOrdRco
    Local nOrdRgc

    //Variaveis de testes
    Local cAuxProces	:= ""
    Local cAuxRoteiro	:= ""
    Local cAuxPeriodo	:= ""
    Local cAuxNumPag	:= ""      
    Local nAuxRecRCH	:= 0

    //Ordem das tabelas usadas no calculo
	nOrdSrv	   := RetOrder( "SRV", "RV_FILIAL+RV_COD" )
	nOrdRcj	   := RetOrder( "RCJ", "RCJ_FILIAL+RCJ_CODIGO" )
	nCalRg9Ord := RetOrder( "RG9", "RG9_FILIAL+RG9_CODCRI" )
	nCalRcpOrd := RetOrder( "RCP", "RCP_FILIAL+RCP_MAT+DTOS(RCP_DTMOV)+RCP_TPMOV" )
	nCalRgbOrd := RetOrder( "RGB", "RGB_FILIAL+RGB_PROCES+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_MAT+RGB_PD+RGB_SEQ" )
	nCalSrkOrd := RetOrder( "SRK", "RK_FILIAL+RK_MAT+RK_PD+DTOS(RK_DTMOVI)" )
	nCalRg7Ord := RetOrder( "RG7", "RG7_FILIAL+RG7_MAT+RG7_PD+RG7_PROCES+RG7_ROTEIR+RG7_ANOFIM+RG7_ANOINI" )
	nCalSr7Ord := RetOrder( "SR7", "R7_FILIAL+R7_MAT+DTOS(R7_DATA)+R7_TIPO" )
	nCalSr3Ord := RetOrder( "SR3", "R3_FILIAL+R3_MAT+DTOS(R3_DATA)+R3_SEQ+R3_TIPO+R3_PD" )
	nCalRcmOrd := RetOrder( "RCM", "RCM_FILIAL+RCM_TIPO" )
	nCalSrqOrd := RetOrder( "SRQ", "RQ_FILIAL+RQ_MAT" )

    If cPaisLoc <> "ARG"
	    nOrdRco	:= RetOrder( "RCO", "RCO_FILIAL+RCO_CODIGO+RCO_NREPAT" )
	    nOrdRgc	:= RetOrder( "RGC", "RGC_FILIAL + RGC_KEYLOC" ) 
	Endif    
	
	nTotReg := Len(aCall)
	For nX := 1 to nTotReg
		cTabMestra 	:= aCall[nX,2]	// Nome da Tabela Mestre
		nPosRecno	:= aCall[nX,3]	// Posicao do recno na tabela Mestre
		nLote		:= aCall[nX,4]	// Numero do Lote da Requisicao

		If Empty(cAuxProces) .or. Empty(cAuxRoteiro) .or. Empty(cAuxPeriodo) .or. Empty(cAuxNumPag) .or. (nAuxRecRCH == 0)
			cAuxProces	:= aCall[1,5,1]
			cAuxRoteiro	:= aCall[1,5,2]
			cAuxPeriodo	:= aCall[1,5,3]
			cAuxNumPag	:= aCall[1,5,4]
			nAuxRecRCH	:= aCall[1,5,5]
		EndIf
  
		dbSelectArea( cTabMestra )  
		(cTabMestra)->(DbGoTo( nPosRecno )) 

		// Carrega/Gera acols com os inicializadores padroes. 		
		For nY := 1 To Len(aTables)
			If aTables[nY, 4] == 1 
				aSvCols := GdRmkaCols(aTables[nY, 2]) // Gera uma linha do aCols para a tabela com os inicializadores padrão
				aTables[nY,5] := aClone(aSvCols[1])                     
				RollBackSx8()//Despreza numeracoes inicializadas com sx8	
			EndIf
		Next nX

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carga no array (aIncid) de incidencias - Tabela RGB          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aIncid := {}
	 	fGetIncid(@aIncid, SRA->RA_FILIAL, SRA->RA_MAT, cProces, cRoteiro, cPeriodo, cNumPag, aTables)

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o array (aValFut) de Valores Futuros - Tabela SRK    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aValFut := {}
		fGetValFut(@aValFut, SRA->RA_FILIAL, SRA->RA_MAT, cPeriodo, cNumPag, aTables, cRoteiro)
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o array (aAfast) de Afastamentos - Tabela SR8		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aAfast := {}
		fGetAfast(@aAfast, SRA->RA_FILIAL, SRA->RA_MAT, aTables)

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o array (aBenef) de Beneficiários - Tabela SRQ	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aBenef := {}
		fGetBenef( SRA->RA_FILIAL, SRA->RA_MAT, @aBenef, aTables )		
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o array (aLanFix) de Lançamentos Fixos - Tabela RG1    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aLanFix := {}
		fGetLanFix(@aLanFix, SRA->RA_FILIAL, SRA->RA_MAT, aTables )
			
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Posicionar os arquivos nos respectivos registros do funciona-³
		³ rio.                                                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		DbSelectArea( "RCJ" )	// Cadastro de Processos
		DbSetOrder( nOrdRcj )
		cFilTab := If( cModRCJ=="E", SRA->RA_FILIAL, xFilial("RCJ"))
		DbSeek( cFilTab + SRA->RA_PROCES, .F. )

		DbSelectArea( "RCH" )	// Cadastro de Periodos
		DbSetOrder( nOrdRch )
		cFilTab := If( cModRCH=="E", SRA->RA_FILIAL, xFilial("RCH"))
		DbSeek( cFilTab + cProces + cPeriodo + cNumPag + cRoteiro, .F. )

		DbSelectArea( "SQB" )	// Cadastro de Departamentos
		DbSetOrder( nOrdSqb )
		cFilTab := If( cModSQB=="E", SRA->RA_FILIAL, xFilial("SQB"))
		DbSeek( cFilTab + SRA->RA_DEPTO, .F. )
                 
		DbSelectArea( "SRJ" )	// Cadastro de Postos/Funcoes
		DbSetOrder( nOrdSrj )
		cFilTab := If( cModSRJ=="E", SRA->RA_FILIAL, xFilial("SRJ"))
		DbSeek( cFilTab + SRA->RA_CODFUNC, .F. )
		
		DbSelectArea( "CTT" )	// Cadastro de Centro de Custos
		DbSetOrder( nOrdCtt )
		cFilTab := If( cModCTT=="E", SRA->RA_FILIAL, xFilial("CTT"))
		DbSeek( cFilTab + SRA->RA_CC, .F. )

		If !(cPaisLoc $ "ARG*DOM")
			If cPaisLoc != "CHI"
				DbSelectArea( "RCO" )	// Registro Patronal
				DbSetOrder( nOrdRco )
				cFilTab := If( cModRCO=="E", SRA->RA_FILIAL, xFilial("RCO"))
				DbSeek( cFilTab + SRA->RA_CODRPAT, .F. )
			Endif
			DbSelectArea( "RGC" )	// Localidade de Pago
			DbSetOrder( nOrdRgc )
			cFilTab := If( cModRGC=="E", SRA->RA_FILIAL, xFilial("RGC"))
			DbSeek( cFilTab + SRA->RA_KEYLOC, .F. ) 
		Endif

		DbSelectArea( "RCE" )	// Sindicatos
		DbSetOrder( nOrdRce )
		cFilTab := If( cModRCE=="E", SRA->RA_FILIAL, xFilial("RCE"))
		DbSeek( cFilTab + SRA->RA_SINDICA, .F. )
		
		DbSelectArea( "SR6" )	// Turnos de Trabalho
		DbSetOrder( nOrdSr6 )
		cFilTab := If( cModSR6=="E", SRA->RA_FILIAL, xFilial("SR6"))
		DbSeek( cFilTab + SRA->RA_TNOTRAB, .F. )
		
		DbSelectArea( "SR3" )	// Historico de Valores Salariais
		DbSetOrder( nOrdSr3 )
		cFilTab := If( cModSR3=="E", SRA->RA_FILIAL, xFilial("SR3"))
		DbSeek( cFilTab + SRA->RA_MAT, .F. )
		
		DbSelectArea( "SR7" )	// Historico de Alteracoes Salariais
		DbSetOrder( nOrdSr7 )
		cFilTab := If( cModSR7=="E", SRA->RA_FILIAL, xFilial("SR7"))
		DbSeek( cFilTab + SRA->RA_MAT, .F. )		                
		
		DbSelectArea( "SQ3" )	// Cadastro de Postos/Funcoes
		DbSetOrder( nOrdSq3 )
		cFilTab := If( cModSQ3=="E", SRA->RA_FILIAL, xFilial("SQ3"))
		DbSeek( cFilTab + SRA->RA_CARGO, .F. )
		
		DbSelectArea( "SRV" )	// Cadastro de Verbas
  		DbSetOrder( nOrdSrv )
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Consiste parametros do Ambiente com os Parametros do Funcionario³
		³Quando forem diferentes, aborta o processo					     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If ( !(cProces == cAuxProces ) .or. !(cRoteiro == cAuxRoteiro) .or. !(cPeriodo == cAuxPeriodo) .or. !(cNumPag == cAuxNumPag) .or. !(RCH->(Recno()) == nAuxRecRCH) )
			cLogServer := "================================== RH LOG ==================================" + CRLF
			cLogServer += "                              Variables Comparations" + CRLF
			cLogServer += 'cProces == ' +cProces+ " - cAuxProces == "+ cAuxProces + CRLF
			cLogServer += 'cRoteiro == ' +cRoteiro+ " - cAuxRoteiro == "+ cAuxRoteiro + CRLF
			cLogServer += 'cPeriodo == ' +cPeriodo+ " - cAuxPeriodo == "+ cAuxPeriodo + CRLF
			cLogServer += 'cNumPag == ' +cNumPag+ " - cAuxNumPag == "+ cAuxNumPag + CRLF
			cLogServer += 'RecnoRCH == ' +Str(RCH->(Recno()))+ " - VarRCH == "+ Str(nAuxRecRCH) + CRLF		
			cLogServer += "============================================================================" + CRLF
			Conout(cLogServer)
		Endif		 		
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Restaurar as Variaveis statics do calculo por funcionario	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		RstCalFun()
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Execucao da Rotina do Calculo do Funcionario           	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		
		nRet := CalcProc( aPd			,;
						  aRotPd		,;
						  aMnemonicos	,;
						  aOperador		,;
						  aDefTab		,;
						  aIncid		,;
						  aValFut		,;
						  aAfast		,;
						  aTables		,;
						  aTypAus		,;
						  aBenef		 ;
						 )                                                
						 
		If nRet < 0
			nX := nTotReg	// Forcar a saida do Laco For..Next
			
			cMsgLog := CRLF + CRLF
			cMsgLog += "##ERRORNRET"+Str(nRet,2)+CRLF
			cMsgLog += CRLF + "Aborted by UserException  " // Complemento da Mensagem que sera enviado pelo Gerenciamento do GRID
			cMsgLog += CRLF+"##ERRORNRET"+Str(nRet,2)+CRLF 
			UserException(cMsgLog)		// Abortado o calculo pela execucao do Calculo
		Else
			nCountReg++
		EndIf
	Next nX 
	aAdd( aLogRet, nCountReg )

	Return( aLogRet )
#ENDIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³FinishGrid ³ Autor ³Mauricio T. Takakura  ³ Data ³23/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Funcao para finalizar o GRID					            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpem022                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function FinishGrid()

CloseLogCalc()

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fGeraFilter³ Autor ³Mauricio T. Takakura  ³ Data ³27/09/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Gera o Array com os Campos de Filtros                      	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpem022                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fGeraFilter(aFilter,cFilMat,cFilDep,cFilPosto,cFilCC,cFilLocPag)

aFilter := {}

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Inclusao do Filtro das perguntes                             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdd( aFilter, {"RA_MAT"	, cFilMat		, ""} )	// Matricula do Funcionario
aAdd( aFilter, {"RA_DEPTO"	, cFilDep		, ""} )	// Departamento
//aAdd( aFilter, {"RCS_POSTO"	, cFilPosto		, ""} )	// Departamento
aAdd( aFilter, {"RA_CC"		, cFilCC		, ""} )	// Centro de Custos
aAdd( aFilter, {"RA_KEYLOC"	, cFilLocPag	, ""} )	// Localidade de Pago

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³VldPeriodo³ Autor ³Mauricio T. Takakura   ³ Data ³27/09/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³VALIDACAO DO PROCESSO E ROTEIRO PARA CARREGAR O PERIODO    	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpem022                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function VldPeriodo()
Local lRet 		:= .F.
Local aPerAtual := {}

If Type("lVarios") == "U"
	lVarios := .F.
EndIf

If (Empty(cProces) .and. Empty(cRoteiro)) .Or. lVarios
	Return(.T.)
EndIf

lRet := fGetPerAtual( @aPerAtual, xFilial("RCH"), cProces, cRoteiro ) // Busca o periodo aberto para trabalho
If lRet 
	cPeriodo	:= aPerAtual[1,1]
	cNumPag		:= aPerAtual[1,2]
	dDataIni	:= aPerAtual[1,6]
	dDataFim	:= aPerAtual[1,7]
Else
	cPeriodo	:= Space( TamSX3( "RCH_PER" )[1] )
	cNumPag		:= Space( TamSX3( "RCH_NUMPAG" )[1] )
	dDataIni	:= Ctod("//")
	dDataFim	:= Ctod("//")
EndIf

Return(.T.)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³VldCalculo³ Autor ³Mauricio T. Takakura   ³ Data ³27/09/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³VALIDACAO DO ITEMS PARA INICIO DO CALCULO                  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpem022                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function VldCalculo()
//Local aArea 	:= GetArea()
Local aPerAtual	:= {}

Local cChar 	:= ""
Local cString	:= ""

Local lRet

Local nX 
Local nY

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Validar o Periodo a Calcular 										       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
lRet := fGetPerAtual( @aPerAtual, xFilial("RCH"), cProces, cRoteiro ) // Busca o periodo aberto para trabalho
If !lRet 
	Aviso( OemToAnsi(STR0027), OemToAnsi(STR0025), {STR0003} ) // "Atenção"##"Nao possui Periodo para o Processo e Roteiro Selecionado!"##"OK"
	lRet := .F.
Else
	If cPeriodo	<> aPerAtual[1,1] .Or. cNumPag <> aPerAtual[1,2]
		Aviso( OemToAnsi(STR0027), OemToAnsi(STR0024), {STR0003} ) // "Atenção"##"Periodo Selecionado esta diferente do Periodo Autorizado!"##"OK"
		lRet := .F.
	EndIf
	If lRet .and. !Empty(RCH->RCH_DTFECH)
		Aviso( OemToAnsi(STR0027), OemToAnsi(STR0026), {STR0003} ) // "Atenção"##"O periodo selecionado ja foi Fechado!"##"OK"
		lRet := .F.
	EndIf
	If lRet .and. RCH->RCH_STATUS == "1"
		Aviso( OemToAnsi(STR0027), OemToAnsi(STR0028), {STR0003} ) // "Atenção"##"O periodo selecionado ja esta Pré-Fechado!"##"OK"
		lRet := .F.
	EndIf
	If lRet .and. RCH->RCH_STATUS == "2"
		Aviso( OemToAnsi(STR0027), OemToAnsi(STR0029), {STR0003} ) // "Atenção"##"O periodo selecionado esta sendo Calculado!"##"OK"
		lRet := .F.
	EndIf
	If lRet .and. RCH->RCH_STATUS == "3"
		Aviso( OemToAnsi(STR0027), OemToAnsi(STR0030), {STR0003} ) // "Atenção"##"Os Recibos de Pagamento deste periodo já foram Impressos!"##"OK"
		lRet := .F.
	EndIf
	If lRet .and. RCH->RCH_STATUS == "4"
		Aviso( OemToAnsi(STR0027), OemToAnsi(STR0031), {STR0003} ) // "Atenção"##"O periodo selecionado esta em Processo de Fechamento!"##"OK"
		lRet := .F.
	EndIf	
    If (lRet)
    	IF !(VerPerAnt(RCH->(RECNO()))) .and. (FunName() <> "GPEM042")
	    	cMsgInfo := OemToAnsi(STR0079) + CRLF	//"Periodo anterior não esta fechado pode gerar inconcistencia nos acumulados"
	    	cMsgInfo += OemToAnsi(STR0080)          //Deseja Continuar?
	    	lRet := MsgYesNo( cMsgInfo , OemToAnsi(STR0027))
        EndIf
    
    EndIf
 EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Validar o Conteudo do Filtro 										       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If lRet 
	For nX := 1 To Len(aFilter)
		cString := aFilter[nX,2]
		For nY := 1 To Len(cString)
			cChar := Substr( cString, nY, 1)
			If !UPPER(cChar) $ "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-; "
				Aviso( OemToAnsi(STR0027), OemToAnsi(STR0038), {STR0003} ) // "Atenção"##"Existem caracteres inválidos no campos de Filtros!"##"OK"
				lRet := .F.				
				Exit
			EndIf
		Next nY	
		If !lRet
			Exit
		EndIf
	Next nX
EndIf

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³MakeExpr		³ Autor ³Mauricio Takakura ³ Data ³08/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem a Expressao de Filtro com Parse          				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function MakeStrExpr(aFilter,lTOP)

Local aItens

Local cExp
Local cExp1
Local cExp2
Local cField
Local cExpIn	
Local cString

Local nX
Local nY
Local nAt
Local nItens
Local nFields

DEFAULT aFilter := {}
DEFAULT lTOP	:= .T.

nFields := Len( aFilter )
For nX := 1 To nFields
	cField  := aFilter[nX,1]
	cString := AllTrim(aFilter[nX,2])
	cExp	:= ""
	cExpIn	:= ""
	If !Empty(cString)

		aItens := StrToArray(cString,";")
		nItens := Len( aItens )
		If nItens > 0
			
			For nY := 1 To nItens
				cString := AllTrim(aItens[ nY ])
				nAt := At("-", cString)
				If nAt > 0
      				cExp1 := Subs(cString,1,nAt-1)
					cExp2 := Subs(cString,nAt+1)
	
					If lTop
						If !Empty(cExp)
							cExp += " OR "
						EndIf
						cExp += cField + " BETWEEN '" + cExp1 + "' AND '" + cExp2 + "'"
					Else
						If !Empty(cExp)
							cExp += " .OR. "
						EndIf

						cExp += "(" + cField + " >= '" + cExp1 + "' .AND. " + cField + " <= '" + cExp2 + "')"
					EndIf
				Else
					If !Empty(cExpIn)
						cExpIn += ","
					EndIf
					If lTop
						cExpIn += "'" + cString + "'"
					Else
						cExpIn += cString
					EndIf
				EndIf
			Next nY

			If !Empty(cExpIn)
				If lTop
					If !Empty(cExp)
						cExp += " OR "
					EndIf

					cExp += cField + " IN(" + cExpIn + ")"
				Else
					If !Empty(cExp)
						cExp += " .OR. "
					EndIf

					cExp += "(Trim("
					cExp += cField
					cExp += ") $ '" + cExpIn + "')"
				EndIf
			EndIf

			If !Empty(cExp)
				cExp := "("+cExp+")"
			EndIf			
			aFilter[nX,3] := cExp
		EndIf
	EndIf	
Next nX 

Return


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³TELALOG   ³Autor³Tatiane Vieira Matias    ³ Data ³27/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Tela de consulta de logs do calculo.                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function TelaLog()
Local aArea			:= GetArea()
Local oDlg1    
Local oMemo
Local cMemo			:= ""
Local aAdvSize1		:= {}		
Local aInfoAdvSize	:= {}
Local aObjCoords	:= {}
Local aObjSize		:= {}                    
Local oTree
Local cLogPath		:= GetPvProfString( GetEnvServer() , "RootPath" , "" , GetAdv97() )
Local cLogDir 		:= "LOG_CALC\"
Local aDirectory	:= {}
Local nElem 		:= 0                            
Local nTamanho      := 0
Local cData			:= ""
Local cAux			:= ""
Local oFont
Local aButton1      := {}
Local bSet15		:= { || .T. }
Local bSet24		:= { || .T. }
Local lVer115       := GetMvRH('MV_ECMFTPP',.T.)
Local nPosDbTree    := 0

Private aFiles		:= {}

Begin Sequence

	cLogPath		+= GetPvProfString( GetEnvServer() , "StartPath" , "" , GetAdv97() )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Trocar as barras para evitar inconsistencia no Linux 				    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cLogPath := StrTran(cLogPath, "/", "\" )
	IF ( SubStr( cLogPath, -1 ) <> "\" )
		cLogPath += "\"
	EndIF
	cLogPath += cLogDir
	cLogPath := Lower( cLogPath )

	aDirectory := DIRECTORY(cLogPath + "*.LOG",,1)
	if !(len(aDirectory) > 0)
		Aviso( OemToAnsi(STR0027), "Nao existem arquivos de log disponiveis!", {STR0003} ) // "Atenção"##"Existem caracteres inválidos no campos de Filtros!"##"OK"
		Return
	EndIf

                                      
	aAdvSize1		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize1[1] , aAdvSize1[2] , aAdvSize1[3] , aAdvSize1[4] ,10,0,10,10}
	aAdd( aObjCoords , {  100,100 , .T. , .T. } )   
   	aAdd( aObjCoords , {  100,100 , .T. , .T. } ) 
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords , .T. , .T. )
	  	
	aAdd(aButton1, {NIL, {|| DelLog(cLogPath, oTree:GetCargo(), @cMemo, @oMemo, @oTree) }, OemToAnsi(STR0054), OemToAnsi(STR0054)}) //"Consulta Logs de Calculo"##"Logs"
	aAdd(aButton1, {NIL, {|| PrintLog(cMemo, cLogPath, oTree:GetCargo()) }, OemToAnsi(STR0055), OemToAnsi(STR0055)}) //"Consulta Logs de Calculo"##"Logs"
			   
					   
	DEFINE FONT oFont NAME "Courier New" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg1 TITLE OemToAnsi(STR0053) From aAdvSize1[7],0 TO aAdvSize1[6],aAdvSize1[5] OF oMainWnd PIXEL //"Consulta Log de Calculo"

		// Cria o DbTree
		IF lVer115					   
			nPosDbTree := (oDlg1:nBottom/2)-50
		ELSE
			nPosDbTree := (oDlg1:nBottom/2)-38
		ENDIF
	
	   	DEFINE DBTREE oTree FROM aObjSize[1][1],aObjSize[1][2] to nPosDbTree,aObjSize[1][4] OF oDlg1 CARGO       //oDlg:nBottom*0.38 //aRetcoords[1][3]*0.9
		                      
				//Retorna o nome de todos os arquivos de extensao .LOG do diretorio informado
				aDirectory := DIRECTORY(cLogPath + "*.LOG",,1)
				if len(aDirectory) > 0
					AEVAL( aDirectory, {|x| aAdd(aFiles, {  x[1],                          						 ;   //Nome do arquivo
					substr(x[1], len(x[1])-13, 4) +substr(x[1], len(x[1])-15, 2) +substr(x[1], len(x[1])-17, 2), ;   //Data
																				  substr(x[1], len(x[1])-9, 6),  ;   //Hora
																				  substr(x[1], 5, 6),            ;   //Usuario
																				  substr(x[1], 11, len(x[1])-28)})}) //Terminal

					//Ordena por data, hora e nome do arquivo
					aSort( aFiles ,,, { |x,y| x[2] + x[3] + x[1] < y[2] + y[3] + y[1]})
					aEval( aFiles, { |x| If(nTamanho<len(x[1]),nTamanho:=len(x[1]), Nil)})

					//Monta a Tree
					// - Data -> mes, dia ano (dia da semana)
					//		- Hora -> HHhMMmSSs - Usuario
					cData := ""
					for nElem := 1 to len(aFiles)
						
						if cData <> aFiles[nElem,2]
							if !Empty(cData)
								DBENDTREE oTree
							endif
							cData := aFiles[nElem,2]
                                        
							cAux :=  substr(MesExtenso(substr(cData,5,2)),1,3) + ", " + substr(cData,7,2) + " " + substr(cData,1,4) + ;
							         " (" + DiaSemana(STOD(substr(cData,1,4) + substr(cData,5,2) + substr(cData,7,2))) + ")"

            	
							//Adiciona o node
							DBADDTREE oTree PROMPT cAux CARGO Padr("*"+cData, nTamanho)
						endif                                       
                                 
						cAux := substr(aFiles[nElem,3],1,2) + "h" + substr(aFiles[nElem,3],3,2) + "m" + ;
								substr(aFiles[nElem,3],5,2) + "s - " + UsrRetName( aFiles[nElem,4] )
						DBADDITEM oTree PROMPT cAux CARGO ( aFiles[nElem,1] )
					next nElem 
					DBENDTREE oTree

					//Carrega o memo com o conteudo do arquivo selecionado
					oTree:bLClicked := { || LoadMemo(cLogPath, oTree:GetCargo(), @cMemo), oMemo:Refresh()}
				endif
                    
   	 	@ aObjSize[2][1], aObjSize[2][2] GET oMemo VAR cMemo MEMO SIZE aObjSize[2][4]*0.49,(oDlg1:nBottom/2)-60 FONT oFont HSCROLL CENTERED OF oDlg1 PIXEL WHEN ( .T. )
   		oMemo:lReadOnly := .T.
	    
	    bSet15	:= {|| oDlg1:End()}
		bSet24	:= {|| oDlg1:End()}
                
	ACTIVATE MSDIALOG oDlg1 On Init Enchoicebar( oDlg1, bSet15, bSet24 ) CENTERED

End Sequence
	
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura os Dados de Entrada 											 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
RestArea( aArea )

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³LoadMemo  ³Autor³Tatiane Vieira Matias    ³ Data ³27/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega o conteudo do arquivo no objeto memo                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function LoadMemo(cPath, cArquivo, cRetorno)
Local nHdl    := 0
Local nTamArq := 0
Local cString := "" 
Local nFor	  := 0
Local nLinha  := 0      
//Local lRet    := .T.

DEFAULT cRetorno := ""
DEFAULT cPath    := ""
DEFAULT cArquivo := ""                              

	cRetorno := ""
	cArquivo := AllTrim(cArquivo)
	
	//Verifica se o arquivo existe
	if File( cPath + cArquivo,1 )
               
		//Abre o arquivo
		nHdl := fOpen(cPath + cArquivo,,1)
		If nHdl <= 0  
			return NIL
		EndIf       
		                
		//Posiciona no inicio do arquivo
		fSeek(nHdl,0,0)
		
		//Verifica o tamanho do arquivo
		nTamArq := fSeek(nHdl,0,2)     
		
		//Posiciona no inicio do arquivo
		fSeek(nHdl,0,0)

		nFor 	:= nTamArq / 100
		For nLinha := 1 to nFor
			cString := Space(100)
			fRead(nHdl,@cString,100)    
			cRetorno += cString       
			//Devido performance, armazena ate o tamanho de 500000.
			if len(cRetorno) >= 500000
				cRetorno += CRLF + Replicate("*", 10) + OemToAnsi(STR0057) + Replicate("*", 10) + CRLF //"ATENCAO: Interrupcao na visualizacao do conteudo do arquivo, pois este e maior que o permitido para visualizacao."
				
 				If ExistBlock("GPM022LOG")	// P.E guardado de log de forma local	
					cRetorno += ExecBlock("GPM022LOG",.F.,.F.,{ cPath, cArquivo,cRetorno } )
				Endif

				exit
			endif
		Next nLinha

		if (nLinha > nFor)
			cString := Space(100)
			fRead(nHdl,@cString,100)    
			cRetorno += cString
		endif
		
		fClose( nHdl )
	Endif

Return NIL              

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PrintLog  ³Autor³Tatiane Vieira Matias    ³ Data ³27/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Imprime o conteudo do arquivo selecionado                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function PrintLog(cMemo, cPath, cArquivo)
Local wnrel
Local lRet		   := .T.

PRIVATE aReturn  := { "Zebrado", 1,"Administracao", 2, 1, 1, "",1 }
Private LI 	     := 8
PRIVATE nTamanho := "P"

	if File( cPath + cArquivo )    
		if len(cMemo) >= 500000
			if !MsgYesNo(OemToAnsi(STR0059)) //"O processo de impressao deste arquivo podera demorar.Deseja Continuar?"
				return NIL			
			endif
		endif

		wnrel:=SetPrint(NIL,substr(alltrim(cArquivo), 1, len(alltrim(cArquivo))-4),NIL,OemToAnsi(STR0058),OemToAnsi(STR0058),,,.F.,,,nTamanho) //"Impressão Log de Calculo"

		If ( ValType(aReturn[6]) == "C" )
		
			SetDefault( aReturn ,,,,, 1 ) 
			
			//Pula Pagina
			Impr("","P")
	                      
			//Abre o arquivo
			fT_fUse( cPath + cArquivo )
	
			//Posiciona no inicio do arquivo
			fT_fGotop()
			                                
			//Verifica se existe alguma informacao no arquivo
			lRet := !( fT_fEof() )
			IF !( lRet )
				Break
			EndIF
			                                                 
			While ( !fT_fEof() )
	
				If Li >= 58
					Impr("","P")
				Endif
	
				//Le linha
				cDet := fT_fReadLn()
	
				//Imprime linha
				Impr(if(empty(cDet),"",cDet),"C")
				               
				//Pula para proxima linha
				fT_fSkip()
			End While
			                             
			//Fecha arquivo
			fT_fUse()
		    
			//Gera rodape no final da impressao
			Li := 58
			Impr("","F")
		
		    Set device to Screen
	
			If aReturn[5] == 1
				Set Printer To
				dbCommit()
				OurSpool(WnRel)
			Endif
		
			MS_Flush()

		EndIf
		
	EndIf

Return NIL

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³DelLog    ³Autor³Tatiane Vieira Matias    ³ Data ³27/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Deleta o log selecionado ou todos os logs da data seleciona-³
³          ³da                                                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function DelLog(cLogPath, cArquivo, cMemo, oMemo, oTree)
Local nFile := 0                 
Local cData := ""
          
	//Deleta todos os arquivos da Data selecionada ('*22112007')
	if substr(cArquivo,1,1) == "*"
		cData := substr(cArquivo,2)
		for nFile := 1 to Len(aFiles)
			if Alltrim(aFiles[nFile,2]) == Alltrim(cData)                 
				if File( cLogPath + aFiles[nFile,1] )
					//Deleta o arquivo
					fErase(cLogPath + aFiles[nFile,1])
					
					//Deleta Item da Tree                      
					oTree:TreeSeek(aFiles[nFile,1])
					oTree:DelItem()
				endif
			endif
		next nFile

		//Deleta Item da Pai da Tree
		oTree:TreeSeek(cArquivo)
		oTree:DelItem()
	else
		if File( cLogPath + cArquivo )
			//Deleta o arquivo
			fErase(cLogPath + oTree:GetCargo())
			
			//Deleta Item da Tree
			oTree:TreeSeek(cArquivo)
			oTree:DelItem()
		endif
	endif
	
	oTree:Refresh()
	                     
	//Limpa campo Memo
	cMemo := ""
	oMemo:Refresh()   
	
Return NIL
         
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GpemValDis³Autor³Mauricio Takakura        ³ Data ³25/03/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Deleta o log selecionado ou todos os logs da data seleciona-³
³          ³da                                                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GpemValDis(lDisable, lVarios)

DEFAULT lDisable := .F.
DEFAULT lVarios  := .F.

If !lDisable .And. lVarios
	lDisable := .T.
EndIf

Return( !lDisable )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fValidGrid³Autor³Mauricio Takakura        ³ Data ³22/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Com TRACE executara em modo normal devido ao tamanho do LOG ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fValidGrid(cRoteiro, cProcesso)
Local cAlias := Alias()
Local nRet := 0

BeginSql alias 'QFOR'
	SELECT RC3_CODIGO, RC3_FORM01, RC3_OPERA1 
	FROM %table:RC3% RC3
	INNER JOIN %table:SRM% SRM
	ON SRM.RM_CALCULO = %exp:cRoteiro%
	  AND SRM.RM_PROCES = %exp:cProcesso% 
	  AND SRM.D_E_L_E_T_ = ' '
	  AND RC3.RC3_CODIGO = SRM.RM_CODFOR
	WHERE RC3_OPERA1 = 'TRACE_ON'
	  AND RC3_FORM01 = ' '
	  AND RC3.D_E_L_E_T_ = ' '
EndSql

If !Eof()
	If MsgYesNo(OemToAnsi(STR0078)) //"Não é possível Calcular em GRID com Trace Ativo. Deseja Calcular sem GRID?"
		nRet := 1
	Else
		nRet := 2
	EndIf
EndIf

QFOR->(DbCloseArea())

If !Empty(cAlias)
	DbSelectArea(cAlias)
EndIf

Return(nRet)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³VerPerAnt	   ³ Autor ³Reginaldo G. Ribeiro³Data³22/10/2009³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida se o príodo anterior está fechado					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEM022														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ nRecRCH - Recno de posicionamento do RCH atual				³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function VerPerAnt(nRecRCH )

Local lRet:=		.T.  
Local cFil:=		xFilial("RCH")             
Local aAreaRCH:=	RCH->(GetArea())

	dbSelectArea("RCH")
	dbSetOrder(4)
	dbSeek(cFil+cProces+cRoteiro+cPeriodo+cNumPag)
	While (!BOF() .And. lRet == .T.)
		RCH->(DBSKIP(-1))
		If (cProces+cRoteiro==RCH->(RCH_PROCESS+RCH_ROTEIR) .And. EMPTY(RCH_DTFECH))
			lRet:=.F.
		EndIf	
    
    EndDo

   	RestArea( aAreaRCH )
   	RCH->( dbGoto( nRecRCH ) )

Return (lRet)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Posiciona o RCH³ Autor ³Igor Franzoi	    ³Data³07/05/2010³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Posiciona o RCH depois dos parametros escolhidos			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEM022														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³nRecno - Recno do RCH selecionado							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fPosRCHTes()

Local nRecno := 0
Local cAlias := "RCH"

	DbSelectArea( cAlias )	// Cadastro de Periodos
	(cAlias)->( DbSetOrder( RetOrder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR" ) ) )
	(cAlias)->( DbSeek( xFilial("RCH") + cProces + cPeriodo + cNumPag + cRoteiro, .F. ) )
	nRecno := (cAlias)->(Recno())

Return nRecno

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³	fLoadGrid  ³ Autor ³Igor Franzoi	    ³Data³26/05/2010³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega a variavel lGrid									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEM022														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³lRet - Grid ativado/desativado								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fLoadGrid()

lGrid := GetMvRH("MV_GRID",, .F.)

#IFNDEF TOP
	lGrid	:= .F.
#ENDIF

// Nao calcular a Rescisao com GRID - Somente 1 funcionario por vez //
If FunName() == "GPEM040" 
	lGrid := .F.
EndIf

Return (Nil)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³	fCalFun	   ³ Autor ³Igor Franzoi	    ³Data³26/05/2010³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Conta os registros a serem processados						³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEM022														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³lRet - Grid ativado/desativado								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fCalFun()

Local lRet			:= .F.

Local nX			:= 0

Local cAliasMestra	:= "QUERYSRA"

Local cFilter		:= ""
Local cFilterAux	:= ""

lRet := GetMvRH("MV_GRID",, .F.)

If !Empty(cFilter)
	cFilter += " and "
EndIf
cFilter		+= "RA_PROCES" + " = '" + cProces + "'"
If nStatus == 1
	cFilter		+= " and RA_SITFOLH" + " <> 'D'"
ElseIf nStatus == 2
	cFilter		+= " and RA_SITFOLH" + " = 'D'"
EndIf
cFilterAux := "%" + cFilter + " and SRA.D_E_L_E_T_ = ' '" + "%"

MakeStrExp(@aFilter)
cFilter := "(" + cFilter + ")"

cExp := "("
For nX := 1 To Len(aFilter)
	If !Empty(aFilter[nX,3])
		If len(cExp) > 1
			cExp += " and "
		EndIf
	    cExp += aFilter[nX,3]
	EndIf		
Next nX
cExp += ")"
If cExp <> "()"
	cFilter += " and " + cExp
EndIf
cFilter := "%" + cFilter + "%"

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Contagem de Registros para Barra de Movimentacao 	           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
BeginSql alias cAliasMestra
	SELECT COUNT(*) TOTALREG
	FROM %table:SRA% SRA
	WHERE %exp:cFilter%
	and SRA.D_E_L_E_T_  = ' '
EndSql
nTotCalReg	:= (cAliasMestra)->TOTALREG
nTotCalFunc	:= (cAliasMestra)->TOTALREG
(cAliasMestra)->(DbCloseArea())

If ( (nMinGrid > 0) .and. lRet )
	If ( nTotCalReg <= nMinGrid )
		lRet := .F.
	EndIf
EndIf

Return lRet

/*/{Protheus.doc} fSelProc
Permite a seleção dos processos a serem calculados
@author Allyson Mesashi
@since 30/04/2019
@version 1.0
/*/
Static Function fSelProc()

Local aColsMark		:= {}
Local cIdCab
Local cIdGrid
Local cTitulo		:= ""
Local lMarcar     	:= .F.
Local oPanelUp
Local oTela
Local oPanelDown
Local oGroup
LOcal oFont
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local bCalcula 		:= {|| If( GPM020IniProc(), oDlgMark:End(), Nil) }

Private cFilCalc	:= Space( GetSx3Cache("RCH_FILIAL", "X3_TAMANHO") )
Private cFilFiltr	:= cFilCalc
Private cProc		:= Space( GetSx3Cache("RCH_PROCES", "X3_TAMANHO") )
Private cRote		:= Space( GetSx3Cache("RCH_ROTEIR", "X3_TAMANHO") )
Private cPeri		:= Space( GetSx3Cache("RCH_PER", "X3_TAMANHO") )
Private cSemPag		:= Space( GetSx3Cache("RCH_NUMPAG", "X3_TAMANHO") )
Private oMark
Private oDlgMark	:= Nil
Private oTmpTable
Private nOpcao		:= 0

If !fCriaTmp()
	Help( ,, "Atencion",, STR0090, 1, 0) //"Ninguno de los procesos aptos para cálculo tienen período activo."
EndIf

SX3->(DBSetOrder(2))//X3_CAMPO
SX3->(DBSeek("RCH_FILIAL"))
cTitFil := X3Titulo()
SX3->(DBSeek("RCH_PROCES"))
cTitProc := X3Titulo()	
SX3->(DBSeek("RCH_ROTEIR"))
cTitRot := X3Titulo()	
SX3->(DBSeek("RCH_PER"))
cTitPer := X3Titulo()	
SX3->(DBSeek("RCH_NUMPAG"))
cTitSem := X3Titulo()	

DbSelectArea(cAliasMark)
SET FILTER TO TAB_PROC  == ""

aColsMark	:= fMntColsMark()
aRotMark	:= {}

aAdvSize	:= MsAdvSize( .F.,.F.,370)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 15 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )

Define MsDialog oDlgMark FROM 0, 0 To 500, 800 Title STR0091 Pixel  //"Procesos"

// Cria o conteiner onde serão colocados os paineis
oTela     := FWFormContainer():New( oDlgMark )
cIdCab	  := oTela:CreateHorizontalBox( 13 )
cIdGrid   := oTela:CreateHorizontalBox( 80 )

oTela:Activate( oDlgMark, .F. )

//Cria os paineis onde serao colocados os browses
oPanelUp  	:= oTela:GeTPanel( cIdCab )
oPanelDown  := oTela:GeTPanel( cIdGrid )
 	
	@ 0 , aObjSize[1,2]	GROUP oGroup TO 26,aObjSize[1,4]*0.62 LABEL OemToAnsi(STR0092) OF oPanelUp PIXEL	//"Selecione os filtros para cálculo"
	oGroup:oFont:=oFont

	@ aObjSize[1,1]*0.5, aObjSize[1,2]+1 		SAY   OemToAnsi(cTitFil) SIZE 038,007 OF oPanelUp PIXEL
	@ (aObjSize[1,1]*0.5)+6, aObjSize[1,2]+1 	MSGET cFilCalc SIZE 010,007	OF oPanelUp F3 'SM0' PIXEL PICTURE "@!" WHEN .T. VALID Gp20FilMark()

	@ aObjSize[1,1]*0.5, aObjSize[1,2]+80 		SAY   OemToAnsi(cTitProc) SIZE 038,007 OF oPanelUp PIXEL
	@ (aObjSize[1,1]*0.5)+6, aObjSize[1,2]+80 	MSGET cProc SIZE 010,007 OF oPanelUp F3 "RCJ" PIXEL PICTURE "@!" WHEN .T. VALID Gp20FilMark()

	@ aObjSize[1,1]*0.5	, aObjSize[1,2]+160 	SAY   OemToAnsi(cTitRot) SIZE 038,007 OF oPanelUp PIXEL
	@ (aObjSize[1,1]*0.5)+6, aObjSize[1,2]+160	MSGET cRote SIZE 010,007	OF oPanelUp F3 "SRY" PIXEL PICTURE "@!" WHEN .T. VALID Gp20FilMark()

	@ aObjSize[1,1]*0.5	, aObjSize[1,2]+240		SAY   OemToAnsi(cTitPer) SIZE 038,007 OF oPanelUp PIXEL
	@ (aObjSize[1,1]*0.5)+6, aObjSize[1,2]+240	MSGET cPeri SIZE 010,007	OF oPanelUp PIXEL WHEN .T. VALID Gp20FilMark()

	@ aObjSize[1,1]*0.5	, aObjSize[1,2]+320		SAY   OemToAnsi(cTitSem) SIZE 038,007 OF oPanelUp PIXEL
	@ (aObjSize[1,1]*0.5)+6, aObjSize[1,2]+320	MSGET cSemPag SIZE 010,007	OF oPanelUp PIXEL  WHEN .T.	VALID Gp20FilMark()
	
	oMark := FWMarkBrowse():New()
	
	oMark:SetAlias(cAliasMark)
	oMark:SetFields(aColsMark)
	
	//Indica o container onde sera criado o browse
	oMark:SetOwner(oPanelDown)
	
	oMark:AddButton(STR0093, bCalcula,,,, .F., 2 ) //"Confirmar"
	
	oMark:bAllMark := { || SetMarkAll(oMark:Mark(),lMarcar := !lMarcar ), oMark:Refresh(.T.)  }
	
	// Define o campo que sera utilizado para a marcação
	oMark:SetFieldMark( 'TAB_OK')
	
	oMark:Activate()

ACTIVATE MSDIALOG oDlgMark CENTERED

If oTmpTable <> NIL
	oTmpTable:Delete()
	oTmpTable := Nil
Endif

If nOpcao == 1
	cProces		:= Space( TamSX3( "RCJ_CODIGO" )[1] )
	cProcDesc	:= ""
	cRoteiro 	:= Space( TamSX3( "RY_CALCULO" )[1] )
	cRotDesc	:= ""
	cPeriodo	:= Space( TamSX3( "RCH_PER" )[1] )
	cNumPag		:= Space( TamSX3( "RCH_NUMPAG" )[1] )
	cAtual		:= ""
	dDataIni	:= cToD("//")
	dDataFim	:= cToD("//")
Else
	lVarios		:= .F.
	aRotMark	:= {}
EndIf

oProces:Refresh()
oRoteir:Refresh()
oAtual:Refresh()

Return Nil

/*/{Protheus.doc} fCriaTmp
Cria tabela temporária para uso do FwMarkBrowse
@author Leandro Drumond
@since 16/05/2016
@version 1.0
/*/
Static Function fCriaTmp()
Local aArea		 := GetArea()
Local aColumns	 := {}
Local cQuery	 := ''
Local cKeyAux	 := ''
Local cAliasRCH	 := 'QRCH'
Local lRet		 := .F.
	
If Select(cAliasMark) > 0
	DbSelectArea(cAliasMark)
	DbCloseArea()
EndIf 

aAdd( aColumns, { "TAB_OK"		,"C",02,00 })
aAdd( aColumns, { "TAB_ROT"		,"C",TAMSX3("RY_CALCULO")[1],TAMSX3("RY_CALCULO")[2]})
aAdd( aColumns, { "TAB_DESC"	,"C",TAMSX3("RY_DESC")[1],TAMSX3("RY_DESC")[2]})
aAdd( aColumns, { "TAB_PROC"	,"C",TAMSX3("RCH_PROCES")[1],TAMSX3("RCH_PROCES")[2]})
aAdd( aColumns, { "TAB_PER"		,"C",TAMSX3("RCH_PER")[1],TAMSX3("RCH_PER")[2]})
aAdd( aColumns, { "TAB_NPAG"	,"C",TAMSX3("RCH_NUMPAG")[1],TAMSX3("RCH_NUMPAG")[2]})
aAdd( aColumns, { "TAB_TPROT"	,"C",TAMSX3("RY_TIPO")[1],TAMSX3("RY_TIPO")[2]})
aAdd( aColumns, { "TAB_FIL"		,"C",TAMSX3("RCH_FILIAL")[1],TAMSX3("RCH_FILIAL")[2]})

//Efetua a criacao do arquivo temporario
oTmpTable := FWTemporaryTable():New(cAliasMark)
oTmpTable:SetFields( aColumns )
oTmpTable:Create()

dbSelectArea( "RCH" )
DbSetOrder(RetOrdem("RCH","RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG"))

cQuery := "SELECT RY_DESC, RY_TIPO, RCH_FILIAL, RCH_PROCES, RCH_ROTEIR, RCH_PER, RCH_NUMPAG, RCH_DTINI"
cQuery += 		" FROM " + RetSqlName("RCH") + " RCH"
cQuery +=			" INNER JOIN " + RetSqlName("SRY") + " SRY"
cQuery +=			" ON RCH_ROTEIR = RY_CALCULO AND "
cQuery +=			FWJoinFilial( "RCH", "SRY" )
cQuery +=		" WHERE"
cQuery +=			" RCH_PERSEL = '1' AND"
cQuery +=			" RCH_STATUS = '0' AND"
cQuery +=			" SRY.D_E_L_E_T_ <> '*' AND RCH.D_E_L_E_T_ <> '*'"
cQuery += 		" ORDER BY " + SqlOrder(RCH->(IndexKey()))

cQuery := ChangeQuery( cQuery )

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasRCH)

DbSelectArea(cAliasRCH)

DbSelectArea(cAliasMark)

While (cAliasRCH)->(!Eof())
	If cKeyAux <> (cAliasRCH)->(RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG)

		If ( !(Empty((cAliasRCH)->RCH_FILIAL)) .And. !(AllTrim((cAliasRCH)->RCH_FILIAL) $ fValidFil()) )
			dbSelectArea(cAliasRCH)
			dbSkip()
			Loop
		EndIf

		lRet := .T.
	
		RecLock(cAliasMark,.T.)
		(cAliasMark)->TAB_FIL 	:= (cAliasRCH)->RCH_FILIAL
		(cAliasMark)->TAB_ROT 	:= (cAliasRCH)->RCH_ROTEIR
		(cAliasMark)->TAB_DESC 	:= (cAliasRCH)->RY_DESC
		(cAliasMark)->TAB_PROC	:= (cAliasRCH)->RCH_PROCES
		(cAliasMark)->TAB_PER	:= (cAliasRCH)->RCH_PER
		(cAliasMark)->TAB_NPAG	:= (cAliasRCH)->RCH_NUMPAG
		(cAliasMark)->TAB_TPROT	:= (cAliasRCH)->RY_TIPO
		
		MsUnLock()
		cKeyAux := (cAliasRCH)->(RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG)
	EndIf

	(cAliasRCH)->(DbSkip())

EndDo

( cAliasRCH )->( dbCloseArea() )

RestArea(aArea)

Return lRet

/*/{Protheus.doc} FMntColsMark
Carrega tabela temporária com dados para exibição na MarkBrowse
@author Leandro Drumond
@since 16/05/2016
@version 1.0
/*/
Static Function fMntColsMark()
Local aArea		:= GetArea()
Local aColsAux 	:=`{}
Local aColsSX3	:= {}
Local aCampos  	:= {"RCH_FILIAL","RCH_PROCES","RCH_PER","RY_CALCULO","RY_DESC","RCH_NUMPAG"}
Local aDados	:= {{||(cAliasMark)->TAB_FIL},{||(cAliasMark)->TAB_PROC},{||(cAliasMark)->TAB_PER},{||(cAliasMark)->TAB_ROT}, {||(cAliasMark)->TAB_DESC},{||(cAliasMark)->TAB_NPAG}}
Local nX		:= 0

DbSelectArea("SX3")
DbSetOrder(2)

For nX := 1 to Len(aCampos)
	If SX3->( dbSeek(aCampos[nX]) )
	    aColsSX3 := {X3Titulo(),aDados[nX], SX3->X3_TIPO, SX3->X3_PICTURE,1,SX3->X3_TAMANHO,SX3->X3_DECIMAL,.F.,,,,,,,,1}
	    aAdd(aColsAux,aColsSX3)
	    aColsSX3 := {}
	EndIf
Next nX

RestArea(aArea)

Return aColsAux

/*/{Protheus.doc} SetMarkAll
Marca/Desmarca todos os itens da markbrowse
@author Leandro Drumond
@since 16/05/2016
@version 1.0
/*/
Static Function SetMarkAll(cMarca,lMarcar )

Local aAreaMark  := (cAliasMark)->( GetArea() )

dbSelectArea(cAliasMark)
(cAliasMark)->( dbGoTop() )

While !(cAliasMark)->( Eof() )
	RecLock( (cAliasMark), .F. )
	(cAliasMark)->TAB_OK := IIf( lMarcar, cMarca, '  ' )
	MsUnLock()
	(cAliasMark)->( dbSkip() )
EndDo

RestArea( aAreaMark )

Return .T.

/*/{Protheus.doc} GP20FilMark
Filtra dados da MarkBrowse de acordo com opções preenchidas
@author Leandro Drumond
@since 16/05/2016
@version 1.0
/*/
Static Function Gp20FilMark()

	cFilFiltr := cFilCalc
	If !Empty(cFilFiltr)
		cFilFiltr := xFilial("RCH",cFilFiltr) //Altera o cFilCalc para ficar de acordo com o compartilhamento utilizado.
	EndIf

	DbSelectArea(cAliasMark)
	SET FILTER TO

	DbSelectArea(cAliasMark)
	
	If Empty(cFilFiltr)
		If !Empty(cProc) .and. !Empty(cPeri) .and. !Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO TAB_PROC == cProc .And.  TAB_PER ==  cPeri .And. TAB_NPAG ==cSemPag .And.  TAB_ROT  ==   cRote
		ElseIf !Empty(cProc) .and. !Empty(cPeri) .and. !Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_PROC == cProc .And.  TAB_PER ==  cPeri .And. TAB_NPAG ==cSemPag 
		ElseIf !Empty(cProc) .and. !Empty(cPeri) .and. Empty(cSemPag) .and. !Empty(cRote)
		 	SET FILTER TO TAB_PROC == cProc .And.  TAB_PER ==  cPeri .And.  TAB_ROT  ==   cRote
		ElseIf !Empty(cProc) .and. Empty(cPeri) .and. !Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO TAB_PROC == cProc .And. TAB_NPAG == cSemPag .And. TAB_ROT == cRote
		ElseIf !Empty(cProc) .and. Empty(cPeri) .and. !Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_PROC == cProc .And. TAB_NPAG ==cSemPag 
		ElseIf !Empty(cProc) .and. Empty(cPeri) .and. Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO TAB_PROC == cProc .And. TAB_ROT  == cRote
		ElseIf !Empty(cProc) .and. !Empty(cPeri) .and. Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_PROC == cProc .And.  TAB_PER == cPeri
		ElseIf !Empty(cProc) .and. Empty(cPeri) .and. Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_PROC == cProc
		ElseIf Empty(cProc) .and. !Empty(cPeri) .and. Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_PER == cPeri
		ElseIf Empty(cProc) .and. !Empty(cPeri) .and. !Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO TAB_PER == cPeri .And. TAB_NPAG == cSemPag .And. TAB_ROT == cRote
		ElseIf Empty(cProc) .and. !Empty(cPeri) .and. !Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_PER == cPeri .And. TAB_NPAG == cSemPag
		ElseIf Empty(cProc) .and. !Empty(cPeri) .and. Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO  TAB_PER ==  cPeri .And.  TAB_ROT  ==   cRote
		ElseIf Empty(cProc) .and. Empty(cPeri) .and. !Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO  TAB_NPAG == cSemPag .And.  TAB_ROT == cRote
		ElseIf Empty(cProc) .and. Empty(cPeri) .and. !Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_NPAG == cSemPag
		ElseIf Empty(cProc) .and. Empty(cPeri) .and. Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO TAB_ROT == cRote
		EndIf
	Else
		If !Empty(cProc) .and. !Empty(cPeri) .and. !Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_PROC == cProc .And.  TAB_PER ==  cPeri .And. TAB_NPAG ==cSemPag .And.  TAB_ROT  ==   cRote
		ElseIf !Empty(cProc) .and. !Empty(cPeri) .and. !Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_PROC == cProc .And.  TAB_PER ==  cPeri .And. TAB_NPAG ==cSemPag 
		ElseIf !Empty(cProc) .and. !Empty(cPeri) .and. Empty(cSemPag) .and. !Empty(cRote)
		 	SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_PROC == cProc .And.  TAB_PER ==  cPeri .And. TAB_ROT  ==   cRote
		ElseIf !Empty(cProc) .and. Empty(cPeri) .and. !Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_PROC == cProc .And. TAB_NPAG == cSemPag .And. TAB_ROT == cRote
		ElseIf !Empty(cProc) .and. Empty(cPeri) .and. !Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_PROC == cProc .And. TAB_NPAG ==cSemPag 
		ElseIf !Empty(cProc) .and. Empty(cPeri) .and. Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_PROC == cProc .And. TAB_ROT  == cRote
		ElseIf !Empty(cProc) .and. !Empty(cPeri) .and. Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_PROC == cProc .And.  TAB_PER == cPeri
		ElseIf !Empty(cProc) .and. Empty(cPeri) .and. Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_PROC == cProc
		ElseIf Empty(cProc) .and. !Empty(cPeri) .and. Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_PER == cPeri
		ElseIf Empty(cProc) .and. !Empty(cPeri) .and. !Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_PER == cPeri .And. TAB_NPAG == cSemPag .And. TAB_ROT == cRote
		ElseIf Empty(cProc) .and. !Empty(cPeri) .and. !Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_PER == cPeri .And. TAB_NPAG == cSemPag
		ElseIf Empty(cProc) .and. !Empty(cPeri) .and. Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_PER ==  cPeri .And.  TAB_ROT  ==   cRote
		ElseIf Empty(cProc) .and. Empty(cPeri) .and. !Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_NPAG == cSemPag .And.  TAB_ROT == cRote
		ElseIf Empty(cProc) .and. Empty(cPeri) .and. !Empty(cSemPag) .and. Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_NPAG == cSemPag
		ElseIf Empty(cProc) .and. Empty(cPeri) .and. Empty(cSemPag) .and. !Empty(cRote)
			SET FILTER TO TAB_FIL == cFilFiltr .And. TAB_ROT == cRote
		Else
			SET FILTER TO TAB_FIL == cFilFiltr
		EndIf	
	EndIf	
	
	oMark:Refresh(.T.)	
	
Return .T.

/*/{Protheus.doc} GPM020IniProc
Inicia o processo de cálculo
@author Leandro Drumond
@since 16/05/2016
@version 1.0
/*/
Static Function GPM020IniProc()
Local cMarca 		:= oMark:Mark()
Local lRet			:= .T.
Local lRetPerg		:= .T.
Local lRotFer		:= .F.
Local lRot131		:= .F.
Local lRot132		:= .F.
Local lRotVTR		:= .F.
Local lRotVRF		:= .F.
Local lRotVAL		:= .F.

DbSelectArea(cAliasMark)
DbGoTop()

While !Eof()
	If oMark:IsMark(cMarca)
		aAdd(aRotMark,{TAB_PROC, TAB_ROT, TAB_PER, TAB_NPAG, TAB_TPROT, TAB_FIL})
	EndIf	
	DbSkip()
EndDo

If Empty(aRotMark)
	Help( ,, STR0094,, STR0095, 1, 0) //"Atencion"//"¡Ningun proceso seleccionado!"
	lRet := .F.
Else
	lVarios	:= .T.
	nOpcao	:= 1
EndIf

Return lRet

/*/{Protheus.doc} fLoadCalc
Permite a execução do cálculo de vários processos
@author Allyson Mesashi
@since 30/04/2019
@version 1.0
/*/
Static Function fLoadCalc()

Local cFilBkp	:= cFilAnt
Local nCont 	:= 0
Local aTitle	:= {OemToAnsi(STR0096)}//"Log de procesos"

Private aLog	:= {}

fLoadGrid()

If !lVarios
	nRecRCHAux := fPosRCHTes()
	fGeraFilter( aFilter, cFilMat, cFilDep, cFilPosto, cFilCC, cFilLocPag)
	If lGrid 
		lGrid := fCalFun(nMinGrid)
	Else
		fCalFun(nMinGrid)
	EndIf
	If VldCalculo()
		If lGrid
			If (nGrid := fValidGrid(cRoteiro, cProces ) == 0)
				MsAguarde( {|lEnd| Gpem022Processa() }, OemToAnsi(STR0068), OemToAnsi(STR0069) ) //"Aguarde..."###"Preparando Informações para o GRID..." */
			ElseIf nGrid == 1
				lGrid := .F.
				Proc2BarGauge({|lEnd| Gpem022Processa()},,,, .T. , .T. , .F. , .F. )
			EndIf
		Else
			Proc2BarGauge({|lEnd| Gpem022Processa()},,,, .T. , .T. , .F. , .F. )	
		EndIf
	EndIf
Else
	For nCont := 1 To Len(aRotMark)	
		If SRA->( DbSeek(AllTrim(aRotMark[nCont, 6])) )
			cFilAnt := SRA->RA_FILIAL
		EndIf
		fLoadGrid()
		cProces		:= aRotMark[nCont, 1]
		If ExistCpo("RCJ", cProces)
			cProcDesc := Posicione("RCJ",1,xFilial("RCJ")+cProces, "RCJ_DESCRI")
		EndIf
		cRoteiro	:= aRotMark[nCont, 2]
		If ExistCpo("SRY", cRoteiro)
			cRotDesc := Posicione("SRY",1,xFilial("SRY")+cRoteiro, "RY_DESC")
		EndIf
		cPeriodo	:= aRotMark[nCont, 3]
		cNumPag		:= aRotMark[nCont, 4]
		nRecRCHAux	:= fPosRCHTes()
		dDataIni	:= RCH->RCH_DTINI
		cAtual		:= Replicate( "-", 65 ) + "> " + STR0097 + cProces + " <" + Replicate( "-", 65 )
		oAtual:Refresh()
		fGeraFilter( aFilter, cFilMat, cFilDep, cFilPosto, cFilCC, cFilLocPag)
		If lGrid 
			lGrid := fCalFun(nMinGrid)
		Else
			fCalFun(nMinGrid)
		EndIf
		If lGrid
			If (nGrid := fValidGrid(cRoteiro, cProces ) == 0)
				MsAguarde( {|lEnd| Gpem022Processa() }, OemToAnsi(STR0068), OemToAnsi(STR0069) ) //"Aguarde..."###"Preparando Informações para o GRID..." */
			ElseIf nGrid == 1
				lGrid := .F.
				Proc2BarGauge({|lEnd| Gpem022Processa()},,,, .T. , .T. , .F. , .F. )
			EndIf
		Else
			Proc2BarGauge({|lEnd| Gpem022Processa()},,,, .T. , .T. , .F. , .F. )	
		EndIf
	Next nCont
	
	If Len(aLog) > 0	
		fMakeLog({aLog}, aTitle, Nil, Nil, , OemToAnsi(STR0096), "M", "L",, .F.) //"Log de procesos"
		aLog := {}
    Endif

	cFilAnt 	:= cFilBkp
	cProces		:= Space( TamSX3( "RCJ_CODIGO" )[1] )
	cProcDesc	:= ""
	cRoteiro 	:= Space( TamSX3( "RY_CALCULO" )[1] )
	cRotDesc	:= ""
	cPeriodo	:= Space( TamSX3( "RCH_PER" )[1] )
	cNumPag		:= Space( TamSX3( "RCH_NUMPAG" )[1] )
	cAtual		:= ""
	dDataIni	:= cToD("//")
	dDataFim	:= cToD("//")
	aRotMark	:= {}
	lVarios		:= .F.
	
	oProces:Refresh()
	oRoteir:Refresh()
	oAtual:Refresh()
EndIF

Return
/*/{Protheus.doc} GRSRG630
Agrega o actualiza encabezado de rescisión (SRG)
@author Alfredo Medrano
@since 23/03/2020
@version 1.0
/*/
Static Function GRSRG630()
Local aArea		:= GetArea()
Local nDFerVen	:= 0 
Local nDFerAVe	:= 0   
Local lStaPer   := .T.
Local cAliasQry	:= GetNextAlias()
Local cCampos 	:= ""
Local cFrmTab	:= ""
Local cWhere	:= ""
Local cOrder 	:= ""
Local nRecno 	:= 0

	cCampos := "% SRG.RG_MAT, SRG.RG_EFETIVA, SRG.RG_DATADEM, SRG.RG_PROCES, SRG.RG_APLPER, SRG.RG_APLNPG, SRG.RG_APLROT, SRG.R_E_C_N_O_ RECNO %"
	cWhere 	:= "% SRG.RG_FILIAL = '" + xFilial("SRG") +"' AND SRG.RG_MAT = '" + SRA->RA_MAT+ "' AND %"
	cFrmTab := "% " + RetSqlName("SRG") + " SRG %"	
	cOrder 	:= "% SRG.RG_DATADEM DESC %"
	BeginSql alias cAliasQry
		SELECT 		%exp:cCampos%
		FROM 		%exp:cFrmTab%
		WHERE 		%exp:cWhere%
				    SRG.%NotDel%
		ORDER BY    %exp:cOrder%
	EndSql
	(cAliasQry)->(dbGoTop()) // se posiciona en el primer registro	
	If (cAliasQry)->( !Eof() )
		nRecno := (cAliasQry)->RECNO
		If (cAliasQry)->RG_EFETIVA $ "1*2"
			SRG->( dbGoto( nRecno ) )
			RecLock( "SRG", .F.) //modifica 
		Else 	
			DbSelectArea( "RCH" )	//Periodos
			RCH->(DbSetOrder( 1 )) //"RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR"
			//Estaus cerrado 
			If RCH->(MsSeek( xFilial("RCH") + (cAliasQry)->RG_PROCES + (cAliasQry)->RG_APLPER +(cAliasQry)->RG_APLNPG + (cAliasQry)->RG_APLROT))//busca periodo aplicacion Finiquito
				IF !Empty(RCH->RCH_DTFECH) // Periodo aplicacion cerrado
					RecLock( "SRG", .T.) // inserta Registro en SRG
				Else
					//Estaus Aplicado y Periodo aplicacion abierto
					//no realizar ninguna actualización
					lStaPer := .F.
				EndIf
			Else
				lStaPer := .F.
			EndIf
		EndIf
	Else
			RecLock( "SRG", .T.) // inserta Registro en SRG
	Endif

	
	If lStaPer
		SRG->RG_FILIAL:= xFilial("SRG")
		SRG->RG_MAT:=SRA->RA_MAT
		SRG->RG_EFETIVA:='1' //Estado  1 = Aprobado (No Calculado)
		SRG->RG_RESCOMP :='1' //Conceptos Res. 1 = Todos
		SRG->RG_DTGERAR:= dDataGer //Fecha Generacióm 
		SRG->RG_DATADEM:= dDataRes //Fecha Despido 
		SRG->RG_TIPORES:= cTipoRes //tipo Rescisión
		SRG->RG_DATAHOM:= dDataHom //Fecha Homologación
		SRG->RG_MEDATU:= 'N'//Considerar Mes para Prom 
		SRG->RG_DTPAGO:=  dDataKey //Fecha Pago
		SRG->RG_PERIODO:=cPerAux //Periodo
		SRG->RG_ROTEIR:=cRotAux //Proced. Calc
		SRG->RG_SEMANA:=cSemAux //Num Pago
		SRG->RG_PROCES:=cProcAux //Proceso
		SRG->RG_APLROT:=cRotAux //Procedimiento Aplicacion 
		SRG->RG_PDRESC:='1' //Conceptos Res. Complement
		
		FvacRes022(dDataRes, @nDFerVen, @nDFerAVe )
		
		SRG->RG_DFERVEN:=nDFerVen //Dias vacaciones vencidas 
		SRG->RG_DFERPRO:=nDFerAVe //Dias de Ferias Proporc.  
		SRG->RG_TIPOAFA:= cCauBaja //Causa Baja
		
		MsUnlock()
		
	EndIf
(cAliasQry)->(dbCloseArea())
RestArea( aArea )
Return lStaPer
/*/{Protheus.doc} FvacRes022
Obtiene dias vencidos y dias proporcionales
@author Alfredo Medrano
@since 23/03/2020
@version 1.0
/*/
Static Function FvacRes022(dDataDes, nDFerVen, nDFerAVe )    
Local aPerFerias:= {}
Local nDFerVen	:= 0 
Local nDFerAVe	:= 0         
Local nDFerPag	:= 0    
default  dDataDes  := Ctod("//") // fecha rescisión

	CargaFerias(@aPerFerias,dDataDes)
	If Len(aPerFerias)> 0 
		Aeval(aPerFerias,{|x| (nDFerVen += x[5], nDFerAVe += x[4], nDFerPag += x[7])})
		//descuenta dias pagados
		If nDFerVen > nDFerPag
			nDFerVen:= nDFerVen - nDFerPag
		Else
			nDFerVen:= 0
			nDFerPag:= nDFerPag - nDFerVen
			nDFerAVe:= Max(nDFerAVe - nDFerPag, 0)
		Endif                                     	
	EndIf	
		
Return
