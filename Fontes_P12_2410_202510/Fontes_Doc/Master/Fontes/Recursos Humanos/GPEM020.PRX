#INCLUDE "PROTHEUS.CH"     
#INCLUDE "SCOPECNT.CH"
#INCLUDE "GPEM1020.CH"
#INCLUDE "HEADERGD.CH"
#INCLUDE "TBICODE.CH"
#INCLUDE "TBICONN.CH"
#INCLUDE "FWLIBVERSION.CH"

Static __cPeriodCalc
Static __cProcesCalc
Static __cNumPgCalc
Static __cConvocCalc
Static __aConvoc
Static __cBenOP
Static __aBenOp
Static __lImpMsg 	:= .T.	//# Indica se imprime a Msg de FinalFun() no Log
Static __cFilPer	:= ""
Static lWorkFlow 	:= .F.
Static lVldCons		:= .T.
Static __lFilRPO
Static __lMemCalc
Static lF3Proc		:= .F.
Static aLogExt      := {}
Static cThreadGrid  := ""
Static lTemMultInt
Static lGpm020Rot
Static lVerMetrics
Static nContDur
Static nOrdSRD

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	    ³GPEM020   ³ Autor ³Equipe Advanced RH     		     ³ Data ³22/03/1995³
ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o  ³ROTINA PARA CHAMADA DO CALCULO DE ROTEIROS					    	   ³
ÃÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 		  ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO2 INICIAL.			  		   ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Programador  ³ Data   ³ FNC      	³  Motivo da Alteracao			     		   ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
|Leandro Dr.  ³19/03/13³RHU210_03_07³Unificacao da Folha. Calculo Plano de Saude.  ³ 
³Raquel Hager |20/09/13|M12RH01     |Inclusao da funcao fVldAccess na funcao       ³
³             |        |196001      |Gpem020Processa para vld de per. bloqueado.   ³  
³Raquel Hager |27/09/13|M12RH01     |Inclusao de tratamento Rel. Demons. de Horas  ³
³             |        |RQ3005      |para uso de consulta F3 fixo para FOL.        ³
³Gustavo M.   |29/09/13|TQS551      |Ajuste de funcao de consulta do cadastro de   ³
³             |        |		    |periodos.									   ³
³Christiane V.|30/01/15|PCDEF-12041 |Alteração para posicionar no periodo da filial³
³             |        |            |corrente.                                     ³
³Cícero Alves |24/03/15|TRYQYB		|Inclusão da função fValidPercent para	 	   ³
³             |        |            |validação do parametro MV_PAR02 no calculo    ³
³             |        |            |1ª parcela do 13º							   ³
³L.Trombini   |16/07/15|TSWHEB		|Inclusão da função GpIniTab() para que o sis- ³
³             |        |            |tema verifique se existe ajustes nas tabelas  ³
³             |        |            |por alguma atualização e assim não ocassionan-³
³             |        |            |do erro pelo tamanho da tabela(Array)         ³
³Renan Borges |01/09/15|TTETKO		|Ajuste para calcular folha corretamente nos   ³
³             |        |            |lançamentos por funcionário. Carregar a data  ³
³             |        |            |final do período atual para verificar se fun- ³
³             |        |            |cionário foi admitido antes desta data.       ³
³Raquel Hager |22/10/15|TTLCLB      |Ajuste para permitir calculo de Plano de Saude³
³             |        |            |sem o periodo anterior estar fechado.         ³
³Allyson M    |30/10/15|TTKZLQ		|Ajuste no filtro padrao da rotina p/ sempre   ³
³             |        |            |verificar a data de admissao caso seja os     ³
³             |        |            |roteiros de 13º (conceito da P11)			   ³
³Renan Borges |04/12/15|TTOHWC		|Ajuste para que ao realizar o calculo da folha³
³             |        |            | utilizando o parametro MV_GRID, sejá realiza-³
³             |        |            |do o calculo corretamente.                    ³
³Allyson M    |15/12/15|TUAVQN		|Ajuste na validacao de existencia de lancto na³
³             |        |            |RGB de funcionario demitido				   ³
³Renan Borges |16/12/15|TUAYQO		|Ajuste para atualizar filtro padrão que estava³
³             |        |            |incorreto, realizando o calculo corretamente. ³
³Allyson M    |07/01/16|TUBROB      |Incluida validacao de uso do alias QSRA       ³
³Leandro Dr.  |14/01/16|TUBL91      |Ajuste no parse do filtro.                    ³
³Raquel Hager |10/02/16|TUJQLJ      |Ajuste no parse do filtro.                    ³
³Raquel Hager |15/02/16|TUJQLJ      |Ajuste no parse do filtro.                    ³
³Raquel Hager |24/02/16|TUNV61      |Inclusao da variaval cFterAux como parametro  ³
³             |        |            |na funcao Gpem020Processa em caso de Dissidio ³
³             |        |            |ne Provisao.								   ³
³Raquel Hager |04/03/16|TUKV34      |Ajuste para filtro de filial usando lWork     ³
³Gustavo M.   |25/05/16|TUVJUO      |Ajuste na consulta padrão de roteiro e no log ³
³             |        |            |do calculo de VT.							   ³  
³Gabriel A.   |03/06/16|TVHLTV      |Ajuste na inclusão do filtro padrão.          ³
³Allyson M    |16/06/16|TVKMN9		|Tratamento p/ preservar variavel aPergunte p/ ³
³             |        |            |cálculo correto em GRID					   ³
³Leandro Dr.  |22/06/16|TVGI88		|Retirado utilizacao indevida do CHKRH tipo "1"³
³             |        |            |da montagem da query.  					   ³
³Esther V.    |27/06/16|TVIAMO		|Tratamento no log dos roteiros VTR/VRF/VAL	   ³
³Allyson M    |12/07/16|TURHSE		|Ajuste no cálculo de VT para comissionista p/ ³
³             |        |            |efetuar o cálculo da folha antes do de VT p/  ³
³             |        |            |composição do salário p/ o desconto do VT     ³
³Esther V.    |19/07/16|   TVN862   |Tratamento para nao ocorrer error.log ao rea- ³
³			  |		   |		    |lizar o calculo pela rotina de Calc.Integrado.³
³Allyson M    |12/08/16|TURHSE		|Ajuste no cálculo de VT para comissionista p/ ³
³             |        |            |buscar as verbas do movimento da Folha do     ³
³             |        |            |período em aberto; caso não possua, será feito³
³             |        |            |cálculo da folha     	   					   ³
³Allyson M    |24/08/16|TVTVLV		|Ajuste p/ não deprezar funcionário sem % de   ³
³             |        |            |adiantamento preenchidos pois existe um item  ³
³             |        |            |no roteiro p/ essa verificação			   	   ³
³Allyson M    |09/09/16|TVXOK7		|Ajuste no cálculo de VT para comissionista p/ ³
³             |        |            |reinicializar as variáveis do período antes de³
³             |        |            |executar o cálculo de VT		   	   		   ³
³Allyson M    |20/09/16|TVYDXQ		|Ajuste no cálculo de VA e VR p/ não efetuar o ³
³             |        |            |filtro pela SR0, pois quando há integração com³
³             |        |            |Gestão de Serviços, os benefícios são defini- ³
³             |        |            |no local de atendimento e não na SR0 (réplica ³
³             |        |            |da branc 12.1.13) 							   ³
³Cícero Alves |13/10/16|TVZXET		|Ajuste para permitir o clculo de VAL e VRF em ³
³             |        |            |períodos futuros							   ³
³Renan Borges |29/11/16|     		|Ajuste para calcular dissidio com grid correta³
³             |        |            |mente.                                        ³
³Flavio C.    |22/12/16|     		|Quando calculo finalizado pela EndCalc ou     ³
³             |        |            |FinalCalc(), alterada a ordem do log          ³
³Allyson M    |18/01/17|MRH-382		|Ajuste p/ permitir o calculo do roteiro BEN em³
³             |        |            |períodos futuros							   ³
³Jônatas A.   |28/04/17|DRHPAG-1082 |Detalhamento da filail e matrícula não proces.³
³             |        |            |no cálculo com GRID.           			   ³
³Cícero Alves |17/08/17|DRHPAG-4716 |Disponibilizado o ponto de entrada VERLOGFL   ³
³João Balbino |28/12/17|MPRIMESP1301|Ajuste para não gerar error log no calculo de ³
³             |        |            |VT/VR autonomo quando houver demitido		   ³
ÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/
Function GPEM020(lWork,cProcWF,cRotWF,cExpFil)

Local aArea			:= GetArea()
Local aFilterExp	:=  {} 					//expressao do filtro
Local aRetFiltro							//retorno do filtro
                                    	
Local bDialogInit							//bloco de inicializacao da janela

Local cSvFilAnt		:= cFilAnt
Local cExpFiltro	:= ""					//variavel com o retorno do filtro
Local cRoteiro		:= ""					//codigo do roteiro
Local cTabMestra	:= ""					//nome da Tabela Mestra
Local cSays			:= OemToAnsi(STR0002)	//"Este programa realiza processos de calculos"

Local lShowDlgFilt	:= .T.					//visualizar a dialog de filtros
Local lSetCentury	:= __SetCentury( "on" )	//altero o estado de SetCentury

Local nOpca 		:= 0

Local oDlg
Local oBtnNewFil
Local oBtnAltFil
Local oBtnFastFil
Local oBtnCalcule
Local oBtnEnd
Local oBtnPergunte
Local oSize
Local cORGSPFL 		:= GetMvRH( "MV_ORGSPFL", .F., 'N' )
Local cMsgLog		:= ""
Local aProcessoLog	:= {}
Local aIndex		:= {}
Local nRecCount		:= 0
Local nPos			:= 0
Local aIRMV			:= {}
Local aHdrMestre	:= {}

Private cAxTabMestra	:= ""
Private lCalIRMV		:= .F.	// Variavel utilizada para determinar se existe calculo de IRMV
Private aGpem020Log		:= {}
Private aGpem020TitLog	:= {}
Private lGestPubl 		:= if(ExistFunc("fUsaGFP"),fUsaGFP(),.f.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
Private lCtrlTit		:= !Empty(GetNewPar("MV_BTITFOL", "" )) .And. !Empty(GetNewPar("MV_BTITADT", "" )) .And. RJ1->(ColumnPos( "RJ1_ROTEIR")) > 0 .And. RJ1->(ColumnPos( "RJ1_PROCES")) > 0 .And. RJ1->(ColumnPos( "RJ1_TIPO")) > 0 
Private lSegPlan		:= FwIsInCallStack("WFLAUNCHER") .or. FwIsInCallStack("FWBOSCHDEXECUTE")

DEFAULT lWork    := .F.

Static bNewFiltro							//bloco para inclusao de novos filtros
Static bAltFilter							//bloco para Alteracao do filtro selecionado
Static bFastFilter							//bloco para Filtro Rapido
Static bBtnCalcule							//bloco do botão OK
Static bPergunte								//bloco para o pergunte

DEFAULT __lMemCalc := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc() //Memória de Cálculo.

lWorkFlow := If(lSegPlan, .T., lWork)

//Inclui Filtro Padrão
fInclFP()

/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Funcao verifica se existe alguma restrição de acesso para o³
//³usuário que impeça a execução da rotina.                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If cORGSPFL!= 'N' .AND. !(fValidFun({"SRA","SRJ","RCO","CTT","RGC","RCE",;
				"SR6","SR3","SR7","SRC","RGB",;
				"SQB","SRV","SRK","RCP","RG7"}))
	RestArea(aArea)
	Return
EndIf	

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Calculo da Folha com Versao Mexico                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If MV_MODFOL == '2'
	Gpem022()
	RestArea( aArea )
	Return( NIL )	
EndIf

If !lWorkFlow
	fLimpaSX1() //Limpa os mv_par, forcanddo uma nova selecao
ElseIf !lSegPlan		
	fSX1Work(cProcWF , cRotWF) //Carrega os parametros com os dados informados no WF
Else 
	cExpFil := MV_PAR03
EndIf

Private aMnemo								//Carrega os mnemonicos em array para ser utilizado no GRID
Private cSvProcesCalc
Private cSvPeriodCalc
Private cSvNumPgCalc
Private cSvRoteiro

Private cCadastro		:= OemToAnsi(STR0001) // "Processos de Cálculo"
Private lAbortPrint 	:= .F.

// Variaveis utilizadas somente para controle da consulta F3
Private cProcesso 	:= ""
Private cCond		:= "1"	// 1 - Somente periodos abertos					
Private cPeriodo 	:= ""
Private dPerFim		:= CtoD("")
Private dDtPago		:= CtoD("")
Private cPergEspec 	:= ""
Private cPergBEN 	:= ""
Private cCompPer	:= ""	// Competencia do Periodo
Private cFilRCJ		:= ""

Private lGrid		:= GetMvRH("MV_GRID",, .F.) // Se o parametro esta configurado para utilizacao do GRID
Private cRotOrig    := ""
Private nMinGrid 	:= GetMvRH("MV_MINGRID",, 0)
// Filtro auxiliar para FilBrowse caso exp Nao Contido/Nao contem
Private cFterAux		:= ""

Public aInssOut		:= {}
                             
Begin Sequence           
    
	Pergunte("GPEM020",.F.)			// trazer os ultimos parametros
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carregar tabelas padroes 	                                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	GpIniTab()
 
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carregar os Mnemonicos 	                                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	SetMnemonicos(NIL,@aMnemo,.T.)
   
	// Variavel pertence aos mnemonicos. Para evitar erros no sistema para os paises que nao possuem esse mnemonico cadastrado
	If Type( "lDissidio" ) == "U"
		lDissidio := .F.
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Documantacao das Variaveis Retornadas pelo Pergunte	       ³
	³															   ³
	³MV_PAR01 -> Codigo do Processo								   ³
	³MV_PAR02 -> Codigo do Roteiro de Calculo					   ³
	³MV_PAR03 -> Codigo do Periodo								   ³
	³MV_PAR04 -> Numero de Pagamento							   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/          
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seta o Processo para Calculo                                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cSvProcesCalc	:= SetProcesCalc( MV_PAR01 )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seta o Periodo para Calculo                                  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cSvPeriodCalc	:= SetPeriodCalc( MV_PAR03 )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seta o Numero de Pagamento do Calculo                        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cSvNumPgCalc	:= SetNumPgCalc( MV_PAR04 )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seta o Roteiro de Calculo                                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cRotOrig        := MV_PAR02
	cSvRoteiro		:= SetRotExec( MV_PAR02 )

	If !lWorkFlow
	
		If !ChkVazio( "SRY" , .F. )
			Help(,,'HELP',, OemToAnsi(STR0109),1,0 ) //"Nenhum roteiro de cálculo cadastrado, verifique o cadastro de Roteiros e Fórmulas"
			Return 
		EndIf
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Bloco de Inicializacao da Janela						       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		bDialogInit 	:= { || CursorWait(),;
								Gpem020Arq(	@cTabMestra	,;
											oBtnNewFil	,;
											oBtnAltFil	,;
											oBtnFastFil	,;
											oBtnCalcule	 ;
										 )								,;	// seta o arquivo Mestre
								lShowDlgFilt := .T.,;
								CursorArrow();
						   }
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta as Dimensoes dos Objetos         					   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		oSize := FwDefSize():New(.F.)             
		oSize:AddObject( "CABECALHO",(oSize:aWindSize[3]*1.1),(oSize:aWindSize[3]*0.4) , .F., .F. ) // Não dimensionavel
		oSize:aMargins 	:= { 0, 0, 0, 0 } // Espaco ao lado dos objetos 0, entre eles 3		
		oSize:lProp 	:= .F. // Proporcional             
		oSize:Process() 	   // Dispara os calculos   	
		
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Funcoes em GpFiltro  - Blocos de Execucao dos filtros                    ³
			³ GpFiltro - Chama a janela principal do cadastro de filtros               ³
			³ GpFltAlsGet - Retorna a expressao para elaborar o filtro                 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			bNewFiltro 		:= { || aRetFiltro := GpFiltro( aFilterExp ), If(!Empty(aRetFiltro), cExpFiltro := GpFltAlsGet( aRetFiltro , cTabMestra ), Nil) }
			bAltFilter 		:= { || Gpem020Filter( aFilterExp, cTabMestra, @cExpFiltro, lShowDlgFilt ) }
			bFastFilter 	:= { || GpFltBldExp( cTabMestra , NIL , @cExpFiltro , NIL ) }
			bBtnCalcule		:= { || nOpca := 1, IF( Gpem020Ok( cExpFiltro, @cRoteiro , @aProcessoLog ),oDlg:End(), nOpca:=0 ) }
			bPergunte 		:= { || If(Pergunte("GPEM020",.T.), (Gpem020VerPerg(xFilial("SRY") + MV_PAR02 , .T.), Gpem020Arq(@cTabMestra, oBtnNewFil, oBtnAltFil, oBtnFastFil, oBtnCalcule), Gpem020SetFil(@aFilterExp, cTabMestra), lShowDlgFilt := .F., Gpem020Filter( aFilterExp, cTabMestra, @cExpFiltro, lShowDlgFilt ), (If(!Empty(__cFilPer),LoadFilPer(@cExpFiltro),.T.)), lShowDlgFilt := .T.), NIL) }

		
		DEFINE MSDIALOG oDlg TITLE OemToAnsi( cCadastro ) From 0,0 TO (oSize:aWindSize[3]*0.4),(oSize:aWindSize[3]*1.1) OF oMainWnd PIXEL
	
			oDlg:lEscClose := .F. // Nao permite sair ao se pressionar a tecla ESC.
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Descricao da Janela                                                      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
	
	 		@ oSize:GetDimension("CABECALHO","LININI")+3 , oSize:GetDimension("CABECALHO","COLINI")+3	GROUP oGroup TO oSize:GetDimension("CABECALHO","LINEND") * 0.49471 ,oSize:GetDimension("CABECALHO","COLEND") * 0.5   LABEL "" OF oDlg PIXEL
			@ oSize:GetDimension("CABECALHO","LININI")+20 , oSize:GetDimension("CABECALHO","COLINI")+13 SAY cSays Of oDlg Pixel
			
	
			oBtnFastFil 	:= TButton():New( oSize:GetDimension("CABECALHO","LINEND") * 0.412 , 022 , "&"+OemToAnsi(STR0008),NIL,bFastFilter		, 040 , 012 , NIL , NIL , NIL , .T. )	// "Filtro Rapido"
			oBtnAltFil  	:= TButton():New( oSize:GetDimension("CABECALHO","LINEND") * 0.412 , 066 , "&"+OemToAnsi(STR0006),NIL,bAltFilter		, 040 , 012 , NIL , NIL , NIL , .T. )	// "Alterar Filtro"
			oBtnNewFil  	:= TButton():New( oSize:GetDimension("CABECALHO","LINEND") * 0.412 , 110 , "&"+OemToAnsi(STR0007),NIL,bNewFiltro		, 040 , 012 , NIL , NIL , NIL , .T. )	// "Incluir Filtro"
			oBtnPergunte	:= TButton():New( oSize:GetDimension("CABECALHO","LINEND") * 0.412 , 154 , "&"+OemToAnsi(STR0010),NIL,bPergunte 		, 040 , 012 , NIL , NIL , NIL , .T. )	// "Parametros"
			oBtnCalcule		:= TButton():New( oSize:GetDimension("CABECALHO","LINEND") * 0.412 , 198 , "&"+OemToAnsi(STR0003),NIL,bBtnCalcule 		, 040 , 012 , NIL , NIL , NIL , .T. )	// "Calcular"
			oBtnEnd			:= TButton():New( oSize:GetDimension("CABECALHO","LINEND") * 0.412 , 242 , "&"+OemToAnsi(STR0004),NIL,{ || oDlg:End() }	, 040 , 012 , NIL , NIL , NIL , .T. )	// "Sair"
	
			Eval( bDialogInit )
		
		ACTIVATE DIALOG oDlg CENTERED
	Else
		If !Empty(cExpFil)
			cExpFiltro := cExpFil
		EndIf

		cTabMestra := "SRA"
		nOpcA := 1
		cRoteiro := MV_PAR02
		cCompPer := MV_PAR03
		
		// Trazer os ultimos parametros do grupo de perguntas relacionado ao roteiro, se existir
		Gpem020VerPerg( xFilial("SRY") + MV_PAR02 , IsInCallStack("GPEA090") .Or. IsInCallStack("GPEA580") )

		// Valida existência de Detalhes de Títulos por Roteiro (RJ1)
		If  lCtrlTit 
			If  fExisTitFA(__cProcesCalc,cCompPer,cRoteiro,__cNumPgCalc,@aProcessoLog) 
				If Len( aProcessoLog ) > 0	
					// "Atenção"###"Ação cancelada - título(s) encontrado(s) sobre esse cálculo."###"Consulte os Títulos listados no log." 
					Help( ,, OemToAnsi(STR0005),, OemToAnsi(STR0113), 1, 0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0115)}) 
					If Len( aProcessoLog ) > 0	
						// Imprime Log
						fCtrTitLg(aProcessoLog)
					EndIf
					nOpca := 0
				EndIf
			EndIf
		EndIf


	EndIf

End Sequence

IF ( nOpca == 1 )
	// Em GRID havera uma Barra de processamento da LIB //
	
	If lWorkFlow
		M020FilFun(@lGrid,@nRecCount,cTabMestra,cProcesso,cExpFiltro,xFilial("RCH", cFilRCJ),cRoteiro,cFterAux,@cMsgLog,@aProcessoLog,@aIndex,@lCalIRMV,@aIRMV,@aHdrMestre)
	Else	
		MsAguarde( {|lEnd| M020FilFun(@lGrid,@nRecCount,cTabMestra,cProcesso,cExpFiltro,xFilial("RCH", cFilRCJ),cRoteiro,cFterAux,@cMsgLog,@aProcessoLog,@aIndex,@lCalIRMV,@aIRMV,@aHdrMestre) }, OemToAnsi(STR0061), OemToAnsi(STR0098) ) //"Aguarde..."###"Filtrando funcionários..."
	EndIf
	
	If nRecCount == 0
		If lWorkFlow
			//Grava o log em arquivo texto
			For nPos := 1 to Len(aProcessoLog)
				AutoGrLog(aProcessoLog[nPos])
				AAdd( aLogExt,aProcessoLog[nPos] )
			Next nPos
		Else
			fMakeLog( {aProcessoLog} , {STR0031} , FunName() , NIL , FunName()+cRoteiro , STR0016 )
		EndIf  
	Else
		If lWorkFlow
			Gpem020Processa( cExpFiltro , cTabMestra , cRoteiro, , cFterAux ,nRecCount,cMsgLog,aProcessoLog,aIndex,lCalIRMV,aIRMV,aHdrMestre)
		Else
			If lGrid
				MsAguarde( {|lEnd| Gpem020Processa( cExpFiltro , cTabMestra , cRoteiro ,  , cFterAux  ,nRecCount,cMsgLog,aProcessoLog,aIndex,lCalIRMV,aIRMV,aHdrMestre) }, OemToAnsi(STR0061), OemToAnsi(STR0062) ) //"Aguarde..."###"Preparando Informações para o GRID..."
			Else
				If !GPESmartViewUtils():ValidBackGExec("GPEM020", 7, {cProcesso, cRoteiro, cExpFiltro})
					Proc2BarGauge( { || Gpem020Processa( cExpFiltro , cTabMestra , cRoteiro , , cFterAux  ,nRecCount,cMsgLog,aProcessoLog,aIndex,lCalIRMV,aIRMV,aHdrMestre) } , NIL , NIL , NIL , .T. , .T. , .F. , .F. )
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

IF !( lSetCentury )
	__SetCentury( "off" )
EndIf
cFilAnt	:= cSvFilAnt
If Select("QSRD") > 0
	QSRD->(DbCloseArea())
EndIf                  

RestArea( aArea )

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpem020Processa³Autor³Equipe Advanced RH    ³Data³22/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Executar o processo de calculo                				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEM020														³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpem020Processa( cFilterRot, cTabMestra, cRoteiro, lDiss, cFterAux, nRecCount, cMsgLog, aProcessoLog, aIndex, lCalIRMV, aIRMV, aHdrMestre, lWorkFl)

Local aArea				:= GetArea()
Local aAreaTabMestra	:= ( cTabMestra )->( GetArea() )
Local aAreaRCH			:= RCH->( GetArea() )
Local aAreaSM0			:= SM0->( GetArea() )
Local aAuxIndex			:= {}
Local aBkpPerg			:= {}
Local aLastRegProc
Local aLogInit
Local aLogVbs			:= {}
Local aNotExistIndex
Local aProcessoTit		:= {}
Local aVerbas			:= {}
Local aPergAux			:= {}
Local aRecnoRCH			:= {}

Local cAcessa			:= ChkRH( "GPEM020" , cTabMestra , "2" )
Local cSvFilAnt			:= cFilAnt
Local cSvAlias			:= ""
Local cCampoFil			:= ""
Local cKeyMestra		:= ""
Local cCpyChave			:= ""
Local cValue			:= ""
Local cTitle			:= ""
Local cMsgIncPrc		:= ""
Local cCpoProcesso		:= ""
Local cDesc				:= ""
Local cTimeIni			:= Time()
Local cDuracaoProcesso	:= ""
Local cFunExec          := "GetSrvVersion"
Local cRotFol 			:= fGetCalcRot('1')
Local cRotAdi 			:= fGetCalcRot('2')
Local cRot131 			:= fGetCalcRot('5')
Local cRot132 			:= fGetCalcRot('6')
Local cRotVtr 			:= fGetCalcRot('8')
Local cRotAut 			:= fGetCalcRot('9')
Local cRotPLA 			:= fGetCalcRot('C')
Local cRotVrf 			:= fGetCalcRot('D')
Local cRotVal 			:= fGetCalcRot('E') 
LOcal cRotBen			:= fGetCalcRot('I')
LOcal cRotPLR			:= fGetCalcRot('F')
Local cDtHrProc

Local cFilExec
Local cFilExAux			:= "#####"
Local cFilNoExec		:= ""
Local cFilMestre

Local lCampoFil
Local lChkProcesso
Local lProcDem			:= .F.

Local nCampos 			:= 1
Local nRet				:= 0
Local nRegsProc			:= 0
Local nPosRecno			:= 0

Local nFieldFil
Local nOrder
Local nRecno
Local nRecnoRCH
Local nNextRecno
Local nLoop

Local aCall			:= {}

Local nRegGrid 		:= 0
Local nLoteGrid		:= 0
Local nCountReg		:= 0
Local nX, nY
Local nPos
Local aBkpFol		:= {}
Local aPerAtual 	:= {}    
Local aPerAtFol 	:= {}    
Local aPerAberto	:= {}
Local aPerFechado	:= {}
Local cNumPag   	:= ""
Local cPerFol		:= ""
Local cPerVT		:= ""
Local cRotCalc  	:= ""
Local nExecRot   
Local nPosFiltr := 0
Local nPosFinal := 0
Local cTmpTit := ""
Local aTmpLog := {}
Local lNovoCalc 	:= NovoCalcBEN()
Local lVerProcAdi	:= .T. 
Local aLogCC		:= {}
Local lGP690Fil		:= ExistBlock("GP690FIL")
Local lLogInDB 		:= .F.
Local lSaltaFunc 	:= .F.
Local cAdtoPro      := GetMvRH("MV_ADTOPRO",, "N") 
Local cMotivo    	:= ""

// Variaveis para calculo de PLR do Equador
Local lPlrEqu := (cPaisLoc == "EQU") .and. (cRoteiro == "UTI")
Local lExeRot := .T.
Local nRecTab
Local cMatExec := ""

Local cBkpKeyVld:= ""
Local lValidCal	:= .T.
Local nOrdemSRA	:= RetOrder( "SRA", "RA_FILIAL+RA_MAT" )
Local nOrdemSRG	:= RetOrdem( "SRG", "RG_FILIAL+RG_MAT+DTOS(RG_DTGERAR)")
Local nOrdemSRN	:= RetOrdem( "SRN", "RN_FILIAL+RN_COD")
Local nOrdemSM7	:= 0
Local nOrdemSR0	:= RetOrdem( "SR0", "R0_FILIAL+R0_MAT+R0_MEIO" )
Local nOrdemSR03:= RetOrder( "SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO+R0_PEDIDO" )
Local dDataAdm
Local nI		:= 0
Local aBenOP	:= {}
Local aConvoc	:= {}

// Roteiros que NÃO serão calculados para funcionários com contrato intermitente
// PLA, BEN,131, 132, ADI, PLR
Local cRotInter	:= ( fGetCalcRot('C') + "*" + fGetCalcRot('I') + "*" + fGetCalcRot('5') + "*" + fGetCalcRot('6') + "*" + fGetCalcRot('2') + "*" + fGetCalcRot('F') )
Local cRotVerAm	:= ( fGetCalcRot('5') + "*" + fGetCalcRot('6'))

Local aTransf
Local lTemSRD

DEFAULT lDiss := .F.
DEFAULT cFterAux := ""
DEFAULT __lMemCalc := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc() // Memória de Cálculo

Private aBkpPd			:= {}	// Copia do array aPd para calculo do VT
Private aRegBlqPerLog	:= {}	// Registros que nao foram processados por periodo bloqueado
Private aNoPrcRegLog	:= {}	// Registros que nao foram processados
Private aLogReint		:= {}
Private lContrInt		:= If(SRC->(ColumnPos( 'RC_CONVOC' )) > 0,.T.,.F.)
Private cNomeForm		:= ""
Private lSegPlan        := FwIsInCallStack("WFLAUNCHER") .or. FwIsInCallStack("FWBOSCHDEXECUTE")

lWorkFlow := If(lWorkFl == Nil, lWorkFlow, lWorkFl)

DEFAULT lGpm020Rot := ExistBlock("GPM020ROT")
DEFAULT __lFilRPO  := GetMvRH("MV_RPOFIL",, .F.) //Gera repositórios auxiliares por filial? -- TMF
DEFAULT lVerMetrics:= FwLibVersion() >= "20200727" .And. FindClass( "FWCustomMetrics" ) .And. FindFunction( cFunExec ) .And. &cFunExec.() >= "19.3.0.6"

If Type( "lGrid" ) == "U"
	Private lGrid := GetMvRH("MV_GRID",, .F.) // Se o parametro esta configurado para utilizacao do GRID
EndIf

//Mnemonico para exibir ou não os funcionários demitidos no log de cálculo
P_LOGDEM := If( Type( "P_LOGDEM" ) == "U", .F., P_LOGDEM)

nLoteGrid := GetMvRH("MV_REGGRID",,20) // Identifica o Nro de Registros a processar por Thread
nRecnoRCH := 0

If lGpm020Rot
	cRotInter := ExecBlock("GPM020ROT", .F., .F., {cRotInter})
EndIf

	If Type( "lGrid" ) == "U"
		lGrid := .F.
	EndIf
	
	If lGrid
		Private cNameFile   := "M020" + cEmpAnt
		Private cDbfLog 	:= "M020LOG"
		Private cChaveLog	:= DTOC(MsDate()) + "-" + Time() + cThreadGrid
		Private nRetCalc	:= 0
		
		If ChkFile("RE2")
			lLogInDB := .T.
			cNameFile := RetSqlName("RE2")
			cDbfLog	:= "RE2"
		EndIf
		
		
		If ! lLogInDB
			If !fOpenLog(@cDbfLog)
				If lWorkFlow
					Conout(OemToAnsi(STR0048))
					AutoGrLog(OemToAnsi(STR0048))
					AAdd( aLogExt,OemToAnsi(STR0048) )
				Else
				 	Aviso( OemToAnsi(STR0005), OemToAnsi(STR0048), {STR0046} ) // "Atencion"###"Nao foi possivel abrir arquivo de registro de ocorrencias."##"Ok"
				EndIf
				Return( NIL )
			EndIf
			
			DbSelectArea( cDbfLog )
			
			//Caso o campo roteiro não exista na base, efetua a criação
			If Type("ROTEIRO") == "U"
				DbCloseArea()
				
				MsErase( cNameFile )
				
				If !fOpenLog(@cDbfLog)
					If lWorkFlow
						Conout(OemToAnsi(STR0048))
						AutoGrLog(OemToAnsi(STR0048))
						AAdd( aLogExt,OemToAnsi(STR0048) )
					Else
						Aviso( OemToAnsi(STR0005), OemToAnsi(STR0048), {STR0046} ) // "Atencion"###"Nao foi possivel abrir arquivo de registro de ocorrencias."##"Ok"
					EndIf
					Return( NIL )
				EndIf
				
				DbSelectArea( cDbfLog )
				DbGoTop()
			EndIf
		EndIf
		
		If Select( cDbfLog ) > 0
			DbSelectArea( cDbfLog )
			DbGoTop()
			If ! lLogInDB
				While (cDbfLog)->(!Eof())
					If (cDbfLog)->CONTROL = '1' .And. (cDbfLog)->ROTEIRO == cRoteiro 
						cDtHrProc := AllTrim(Substr( (cDbfLog)->CHAVE, 1)) + " Hrs"
						cMsgLog := OemToAnsi( STR0050 ) + " " + cDtHrProc + " " + OemToAnsi(STR0051) + CRLF // "O processamento realizado em:" ## "não foi concluído com Sucesso."
						exit						
					EndIf
					(cDbfLog)->( Dbskip() )
				EndDo
			Else 
				While (cDbfLog)->(!Eof())
					If (cDbfLog)->RE2_CONTRO = '1' .And. (cDbfLog)->RE2_ROTEIR == cRoteiro 
						cDtHrProc := AllTrim(Substr( (cDbfLog)->RE2_CHAVE, 1)) + " Hrs"
						cMsgLog := OemToAnsi( STR0050 ) + " " + cDtHrProc + " " + OemToAnsi(STR0051) + CRLF // "O processamento realizado em:" ## "não foi concluído com Sucesso."
						EXIT
					EndIf
					(cDbfLog)->(Dbskip())
				EndDo
			EndIf
			
			If !Empty(cMsgLog)
				cMsgLog += CRLF + CRLF + OemToAnsi( STR0058 ) // "Deseja Continuar com o Calculo?"
				If lWorkFLow
					cQuery := " DELETE FROM "
					cQuery += " "+ cNameFile
					cQuery += If(lLogInDB, " WHERE RE2_ROTEIR = '", " WHERE ROTEIRO = '")  + cRoteiro + "'"
					TcSqlExec( cQuery )
				Else
					If MsgYesNo(cMsgLog, OemToAnsi( STR0005 ) ) //"Aten‡„o"			
						cQuery := " DELETE FROM "
						cQuery += " "+ cNameFile
						cQuery += If(lLogInDB, " WHERE RE2_ROTEIR = '", " WHERE ROTEIRO = '")  + cRoteiro + "'"
						TcSqlExec( cQuery )
					Else
						Return
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	
cTimeIni	:= Time()

cAcessa := If(!Empty(cAcessa),cAcessa,".T.")

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Adiciona Informacoes no Log de Processamento							³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdd( aProcessoTit , STR0031 )	//"Informacoes do Processo de Calculo"
aAdd( aProcessoLog , STR0032 + " " + cTimeIni + " " + STR0023 + " " + Dtoc( MsDate() ) ) //"Inicio do Processo de Calculo:"###" de "

// Variavel pertence aos mnemonicos. Para evitar erros no sistema para os paises que nao possuem esse mnemonico cadastrado
If Type( "lDissidio" ) == "U"
	lDissidio := .F.
EndIf

lDissidio := lDiss

If !lDissidio
	cProcesso := GetProcesCalc()
EndIf	
If !Empty(cPergEspec)
	If Type("aPergunte") <> "U"
		aPergunte := {}
		dbSelectArea("SX1")
		dbSetOrder(1)
		pergunte(cPergEspec,.F.)
		If dbSeek(cPergEspec)
			While !Eof() .And. AllTrim(SX1->X1_GRUPO) == AllTrim(cPergEspec)
				If !( (AllTrim(cPergEspec) $ "GP021VAL/GP021VRF" .And. X1_ORDEM $ "07/08") .Or. (AllTrim(cPergEspec) == "GP021VTR" .And. X1_ORDEM $ "11/12") )
					aAdd(aPergunte, {SX1->X1_VAR01, AllTrim(X1PERGUNT()), &(SX1->X1_VAR01), SX1->X1_TIPO, SX1->X1_TAMANHO})
				EndIf
				dbSkip()
			EndDo
		EndIf
	EndIf
EndIf
If lNovoCalc
	If !Empty(cPergBen)	
		If Type("aPergunte") <> "U"
			dbSelectArea("SX1")
			dbSetOrder(1)
			pergunte(cPergBen,.F.)
			If dbSeek(cPergBen)
				While !Eof() .And. AllTrim(SX1->X1_GRUPO) == AllTrim(cPergBen)
					aAdd(aPergunte, {SX1->X1_VAR01, AllTrim(X1PERGUNT()), &(SX1->X1_VAR01),SX1->X1_TIPO, SX1->X1_TAMANHO})
					dbSkip()
				EndDo
			EndIf
		EndIf
	EndIf
	
	nOrdemSM7 := RetOrdem( "SM7", "M7_FILIAL+M7_MAT+M7_MEIO" )
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Seta MayIExecRot()														³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If !lGrid .And. !__lFilRPO
	MayIExecRot()
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar se existe relacionamento entre a tabela de Processo³
³ e a tabela a ser processada.                                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
lChkProcesso := ChkSx9Proc( cTabMestra, @cCpoProcesso )

Begin Sequence

	//Filtro

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica se Existe o Campo de Filial no Arquivo a ser processa³
	³do															   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	lCampoFil 		:= FilExistField( cTabMestra , @cCampoFil )// pegar o nome do campo Filial
	IF ( lCampoFil )
		nFieldFil	:= ( cTabMestra )->( FieldPos( cCampoFil ) )
	EndIf	
	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Campos Chaves e totalizar o numero de campos                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cKeyMestra	:= GetSx2Unico( cTabMestra )
	IF Empty( cKeyMestra )
		cKeyMestra := ( cAxTabMestra )->( IndexKey() )
	EndIf
	cKeyMestra	:= StrTran( cKeyMestra , " " , "" )
	aKeyMestra  := StrToArray( cKeyMestra , "+" )
	nCampos		:= Len( aKeyMestra )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem a Mensagem para a Funcao de Incremento                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cDesc		:=  Alltrim( GetCache( "SRY" , cRoteiro , NIL , "RY_DESC" , Retorder( "SRY" , "RY_FILIAL+RY_CALCULO" ) , .F. ))

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seta o Valor para a Funcao de Incremento                     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If lSegPlan
		ProcRegua(nRecCount)
	ElseIf !lGrid .and. !lWorkFlow
		BarGauge1Set( nRecCount )
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem a Ordem do arquivo a ser processado                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nOrder := ( cAxTabMestra )->( IndexOrd() )
	
	//--------------------------------------------------------------//
	// PLR Equador - Inicializa cálculo   							//
	//--------------------------------------------------------------//
	If lPlrEqu
		PLRANO  := aPergunte[1,3]
		nRecTab := ( cAxTabMestra )->( RECNO() )
		lExeRot := .F.
	EndIf
	
	If cPaisLoc == "BRA" .And. GetNewPar("MV_DF13NEG","S") == "S"
		Fp_Codfol(@aCodFol , , .F.,.F. ,)//.and. Empty(FGETCODFOL("0348")
		If Empty(aCodFol) .OR. aCodFol[348,1] == "   "
			aAdd( aProcessoLog , STR0089 ) //"O parâmetro MV_DF13NEG esta preenchido com 'S' e não existe verba com ID 0348, deverá cadastrar a verba ou alterar o parâmetro."
			Break
		EndIf
	EndIf
	
	//Memória de Cálculo
	If __lMemCalc
		fSetMemCalc()
	EndIf

	RGB->(DbSetOrder(1))
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Percorre os Registros para Efetuar o Calculo                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	While ( cAxTabMestra )->( !Eof() )
	
		If lDissidio .And. lGP690Fil
			If !ExecBlock("GP690FIL", .F., .F., {3, cAxTabMestra} )
				( cAxTabMestra )->( dbSkip() )
				Loop
			EndIf
		EndIf
	
		If cRoteiro == cRotAdi .and. lVerProcAdi//Adiantamento
			lVerProcAdi := .F.
			fGetPerAtual( @aPerAtual,xFilial("RCH",( cAxTabMestra )->RA_FILIAL) , cProcesso , fGetRotOrdinar() )
			If !Empty(aPerAtual)
				If aPerAtual[1, 1] < __cPeriodCalc
					aAdd( aProcessoLog , "")
					aAdd( aProcessoLog , OemToAnsi(STR0070) ) //"A folha do periodo anterior ainda não foi fechada, nao poderá calcular o adiantamento deste período"
					Break
				EndIf
			EndIf
		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se for Multiplos Vinculos, posicionar no SRA                 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		DbSelectArea( cTabMestra )
		DbSetOrder( nOrdemSRA )
		DbSeek( (cAxTabMestra)->( RA_FILIAL + RA_MAT ) )

		//Verifica se houve cálculo da segunda parcela para o funcionário no períoo de cálculo
		If lDissidio .and. cRoteiro == cRot132
			DEFAULT nOrdSRD := RetOrder("SRD","RD_FILIAL+RD_MAT+RD_PROCES+RD_ROTEIR+RD_PERIODO+RD_SEMANA+RD_PD")

			lTemSRD := .F.

			SRD->(DbSetOrder(nOrdSRD))
			
			If SRD->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cProcesso + cRoteiro + cPeriodo))
				lTemSRD := .T.
			EndIf
			
			If !lTemSRD .and. fTransf(@aTransf,cPeriodo,,,.F.,,,.T.)
				If !Empty(aTransf)
					For nX := 1 to Len(aTransf)
						//Se houve transferencia de filial ou matrícula no ano
						If ( aTransf[nX,8] != aTransf[nX,10] .or. aTransf[nX,9] != aTransf[nX,11] )
							If SRD->(DbSeek(aTransf[nX,2] + aTransf[nX,14] + cRoteiro + cPeriodo))
								lTemSRD := .T.
							EndIf
						EndIf
					Next nX
				EndIf
			EndIf

			//Se não existiu cálculo da segunda parcela no período, não recalcula no dissídio
			If !lTemSRD
				( cAxTabMestra )->( dbSkip() )
				Loop
			EndIf			
		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Obtem o Proximo Registro                    				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If cTabMestra <> "SRA" 
			If !GetNextRecno( cAxTabMestra, @nNextRecno , @nRecno , nOrder )
				Exit
			EndIf
		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Filtro do Browse                                             ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lAbortPrint )
			Break
		EndIf
		
		aBkpPd	:= {}
		nRet 	:= 0  
		
		If !lGrid //Será tratado dentro da função GPEM020GRD() para ganho de performance
			//verifica centro de custo
			If Empty((cAxTabMestra)->(RA_CC)) .Or. ! ValidCPO("CTT", 1, xFilial( "CTT", (cAxTabMestra)->(RA_FILIAL)) + (cAxTabMestra)->(RA_CC))
				aAdd( aLogCC, OemToAnsi(STR0092) + (cAxTabMestra)->(RA_FILIAL) + " - " +  (cAxTabMestra)->(RA_MAT) + OemToAnsi(STR0093)) //"Funcionário "#" está com Centro de custo em branco, atualize cadastro."
				(cAxTabMestra)->(DbSkip())
				Loop
			EndIf
			
			// Tratamento para funcionários com tipo de contrato intermitente
			If cPaisLoc == "BRA" .And. cTabMestra == 'SRA' .And. ( ((cAxTabMestra)->RA_TPCONTR == "3" .And. cRoteiro $ cRotInter) .Or. (SRA->RA_CATEFD $ "107/108" .And. cRoteiro $ cRotVerAm) )
				For nLoop := 1 To nCampos
					cCpyChave	:= aKeyMestra[nLoop]
					cValue		+= ( cTabMestra )->( Gpem020ValCpo( cTabMestra , cCpyChave , @cTitle , aHdrMestre ) )
				Next nLoop
				If Empty( aNoPrcRegLog )
					aAdd( aNoPrcRegLog, STR0029 )
					aAdd( aNoPrcRegLog, "" )
				EndIf
				If (cAxTabMestra)->RA_TPCONTR == "3"
					Aadd( aNoPrcRegLog, cValue + STR0097 ) // "Contrato intermitente"
				Else
					Aadd( aNoPrcRegLog, cValue + STR0125 ) // "Contrato verde e amarelo"
				EndIf
				(cAxTabMestra)->(DbSkip())
				Loop
			EndIf
		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Tratamento para verificacao de periodo bloqueado			   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !lDissidio .And. cBkpKeyVld <> (cAxTabMestra)->RA_FILIAL + cProcesso + __cPeriodCalc + __cNumPgCalc + cRoteiro

			cBkpKeyVld := (cAxTabMestra)->RA_FILIAL + cProcesso + __cPeriodCalc + __cNumPgCalc + cRoteiro

			// Verifica se o calculo esta liberado
			lValidCal := fVldAccess( (cAxTabMestra)->RA_FILIAL,__cPeriodCalc,__cNumPgCalc,.F.,cRoteiro,"2" )

			If !lValidCal
				// Inclui no arquivo de registros nao processados       
				cValue 		:= ( Str( ( cTabMestra )->( Recno() ) , 8 ) + "      " )
				cTitle 		:= STR0029 //"Registro      "
				For nLoop := 1 To nCampos
					cCpyChave	:= aKeyMestra[nLoop]
					cValue		+= ( cTabMestra )->( Gpem020ValCpo( cTabMestra , cCpyChave , @cTitle , aHdrMestre ) )
				Next nLoop
				IF Empty( aRegBlqPerLog )
					aAdd( aRegBlqPerLog , cTitle )
					aAdd( aRegBlqPerLog , "" )
				EndIf
			    aAdd( aRegBlqPerLog, cValue )			
				(cAxTabMestra)->(DbSkip()) 		    			
				Loop
			ElseIf cPaisLoc == "BRA" .And. fGetTipoRot( cRoteiro ) $ "1/9"
				fAtuRCHSt( 1, xFilial("RCH", (cAxTabMestra)->RA_FILIAL)+cProcesso+__cPeriodCalc+__cNumPgCalc+cRoteiro, @aRecnoRCH )
			EndIf
		EndIf
		
		If !lValidCal
			(cAxTabMestra)->(DbSkip()) 		    			
			Loop
		EndIf

		dData := StoD(cCompPer+"01")
		dDataAdm := (cAxTabMestra)->RA_ADMISSA
		
		If !lDissidio
			cSitFolh := If(!Empty(SRA->RA_DEMISSA) .or. SRA->RA_SITFOLH == "D", "D", " ")
		Else
			cSitFolh := fBuscaSituacao(SRA->RA_FILIAL,SRA->RA_MAT,dData,,,@dDataAdm,lDissidio)
		EndIf

		//checa data de admissao de funcionario transferido no dissidio
		If lDissidio .And. MesAno(dDataAdm) > MesAno(dData) .And. dDataAdm <> (cAxTabMestra)->RA_ADMISSA
			(cAxTabMestra)->(DbSkip()) 		    			
			Loop
		EndIf
  		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Tratamento para performance da Folha de Pagamento			   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF cPaisLoc == "BRA" .and. (cRoteiro $ cRotFol + "*" + cRotAut ) .and. cTabMestra == 'SRA'
			IF cSitFolh == "D"
				lProcDem := .F.
				cSvAlias := Alias()

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verificar se existe lancamento em SRG                        ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				DbSelectArea( "SRG" )
				DbSetOrder( nOrdemSRG )	// Ordem 1
				DbSeek( (cAxTabMestra)->RA_FILIAL + (cAxTabMestra)->RA_MAT, .F. )

				While SRG->( !Eof() ) .and. SRG->(RG_FILIAL+RG_MAT) == (cAxTabMestra)->RA_FILIAL + (cAxTabMestra)->RA_MAT

                    If !lDissidio
						If cCompPer	== MesAno( SRG->RG_DTGERAR ) .Or. cCompPer == MesAno( SRG->RG_DATADEM ) // Excluir essa variavel quando desativar essa condicao
							lProcDem := .T.
							Exit
						EndIf
					Else
						If cCompPer	< MesAno( SRG->RG_DTGERAR ) // Excluir essa variavel quando desativar essa condicao
							lProcDem := .T.
						Else
							lProcDem := .F.							
						EndIf
						Exit //Avalia apenas a primeira rescisão no dissidio
					EndIf
					DbSkip()

				EndDo

				IF !lProcDem
					DbSelectArea( cSvAlias )
					If cTabMestra <> "SRA"
						If !GotoNextRecno( cAxTabMestra , nNextRecno , nOrder )
							Exit
						EndIf
					Else
						(cAxTabMestra)->(DbSkip())
					EndIf
					If P_LOGDEM
						cValue 		:= ( Str( ( cTabMestra )->( Recno() ) , 8 ) + "      " )
						cTitle 		:= STR0029 //"Registro      "
						For nLoop := 1 To nCampos
							cCpyChave	:= aKeyMestra[nLoop]
							cValue		+= ( cTabMestra )->( Gpem020ValCpo( cTabMestra , cCpyChave , @cTitle , aHdrMestre ) )
						Next nLoop
						IF Empty( aNoPrcRegLog )
							aAdd( aNoPrcRegLog , cTitle )
							aAdd( aNoPrcRegLog , "" )
						EndIf
						cValue += STR0096 //(Demitido)
						aAdd( aNoPrcRegLog, cValue )
					EndIf
					
					If !lGrid .AND. !lWorkFlow
						IncPrcG1Time( cMsgIncPrc , nRecCount , cTimeIni , .T. , 1 , 1 , .T., .F. )
					EndIf
					Loop
				EndIf

				DbSelectArea( cSvAlias )
			EndIf
		EndIf                                                                   
		
		IF cPaisLoc == "PTG" .and. ( cRoteiro == "NAT" .OR. cRoteiro == "PRV" )
		    
		    cRotCalc  := cRotFol
		
			fPerAtual( @aPerAtual , cRotCalc )
			If !Empty( aPerAtual )
		            cPeriodo := aPerAtual[1, 1]
		            cNumPag  := aPerAtual[1, 2]
			EndIf
		        
		 	SetPeriodCalc(cPeriodo)
			SetNumPgCalc(cNumPag)
		    
			nExecRot := ExecForm( (cAxTabMestra)->RA_FILIAL, "SALINC", cRotCalc )
		
			If nExecRot < 0
				Break
			EndIf

		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Tratamento para performance do VAL/VRF/BEN/PLA              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF cPaisLoc == "BRA" .and. cRoteiro $ ( cRotVrf + "*" + cRotVal + "*" + cRotBen + "*" + cRotPLA ).and. cTabMestra == 'SRA' 
			lProcdem:= .T.
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verificar se o funcionario esta demitido e se deve calcular  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If cSitFolh == "D"
				fPerAtual( @aPerAtual , IIf( SRA->RA_CATFUNC $ "A*P",cRotAut,cRotFol ) )
				//verifica se a demissao ocorreu antes do periodo atual da folha, pois caso seja calculo do mes seguinte,
				// é necessario reprocessar o demitido para não gerar valores a pagar.
			   	If ( !Empty(aPerAtual) .And. ( MESANO(SRA->RA_DEMISSA) <= aPerAtual[1, 1] .OR. MESANO(SRA->RA_ADMISSA) > MESANO(dDtPago)) )
					lProcDem := .F.
					/// Para PLA, verifica se foi incluído lançamento de coparticipação/reembolso no período
					If cRoteiro == cRotPLA
						RHO->(DbSetOrder(RetOrdem("RHO","RHO_FILIAL+RHO_MAT+RHO_COMPPG")))
						If (RHO->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + aPerAtual[1, 1], .F.)))
							lProcDem := .T.
						EndIf
					EndIf					
			   EndIf	
			EndIf	
			
			If !lProcDem
				If cTabMestra <> "SRA"
					If !GotoNextRecno( cAxTabMestra , nNextRecno , nOrder )
						Exit
					EndIf
				Else
					(cAxTabMestra)->(DbSkip())
				EndIf				
				If !lGrid .AND. !lWorkFlow
					IncPrcG1Time( cMsgIncPrc , nRecCount , cTimeIni , .T. , 1 , 1 , .T., .F. )
				EndIf
				Loop
			EndIf
		EndIf
		
  		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Tratamento para performance do VTR           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF cPaisLoc == "BRA" .and. cRoteiro == cRotVtr  .and. cTabMestra == 'SRA' 
		   lProcdem:= .T.
	  		/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verificar se existe lancamento em SRN                        ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			DbSelectArea( "SRN" )
			SRN->(DbSetOrder( nOrdemSRN ))	// Ordem 1
			SRN->( DbGoTop() )
			If SRN->( EOF() )
			   (cAxTabMestra)->( DbGoBottom() )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Adiciona Informacoes no Log de  Processamento							³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				aAdd( aProcessoLog , STR0039 ) //"Tabela de meios de transporte esta vazia - VALE TRANSPORTE NAO CALCULADO"
			   Exit
			EndIf

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verificar se o funcionario esta demitido e se deve calcular  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If cSitFolh == "D"
				fPerAtual( @aPerAtual , IIf( SRA->RA_CATFUNC $ "A*P",cRotAut,cRotFol ) )
				//verifica se a demissao ocorreu antes do periodo atual da folha, pois caso seja calculo do mes seguinte,
				// é necessario reprocessar o demitido para não gerar valores a pagar.
			   If ( !Empty(aPerAtual) .And. (MESANO((cAxTabMestra)->RA_DEMISSA) < aPerAtual[1, 1] .OR. MESANO((cAxTabMestra)->RA_ADMISSA) > MESANO(dDtPago) .Or. MESANO((cAxTabMestra)->RA_DEMISSA) <> MESANO(dDtPago)) )
					lProcDem := .F.
			   EndIf
			EndIf	
			If lProcDem
				If lNovoCalc
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Verificar se existe lancamento em sM7                        ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					DbSelectArea( "SM7" )
					SM7->(DbSetOrder( nOrdemSM7 ))	// Ordem 1
					If ! (SM7->( DbSeek( (cAxTabMestra)->RA_FILIAL + (cAxTabMestra)->RA_MAT, .F. ) ) )
					   lProcDem := .F.
					Else
						lProcDem:= .F. 
						While  (cAxTabMestra)->RA_FILIAL + (cAxTabMestra)->RA_MAT == SM7->M7_FILIAL + SM7->M7_MAT  .And. !lProcDem 
							If SM7->M7_TPVALE == '0' //VTR
								lProcDem := .T.
							Endif
							
							SM7->(dbSkip())
							Loop
						EndDo

						If lProcDem .and. cSitFolh == "D" .and. AnoMes((cAxTabMestra)->RA_DEMISSA) <= aPerAtual[1, 1] .and. aPerAtual[1, 1] < __cPeriodCalc //Verifica se houve cálculo para o funcionário demitido, se sim, recalcula, senão, pula e não efetua o cálculo.
							/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³ Verificar se existe lancamento em sr0                        ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							DbSelectArea( "SR0" )
							SR0->(DbSetOrder( nOrdemSR03 )) //R0_FILIAL, R0_MAT, R0_TPVALE, R0_CODIGO, R0_PEDIDO, R_E_C_N_O_, D_E_L_E_T_
							If ! (SR0->( DbSeek( (cAxTabMestra)->RA_FILIAL + (cAxTabMestra)->RA_MAT + "0", .F. ) ) )
								lProcDem := .F.
							Else
								lProcDem := .T. 
							EndIf
						EndIf 
						If !lProcDem //Verifica se existe cálculo e exclui
							DbSelectArea( "SR0" )
							SR0->(DbSetOrder( nOrdemSR03 ))	// Ordem 3
							If SR0->(dbSeek( (cAxTabMestra)->RA_FILIAL + (cAxTabMestra)->RA_MAT + "0"))
								While SR0->(R0_FILIAL + R0_MAT + R0_TPVALE) == (cAxTabMestra)->RA_FILIAL + (cAxTabMestra)->RA_MAT + "0"
									//Somente deleta o cálculo se for recálculo. Caso o pedido já tenha sido emitido, não deleta.
									If SR0->R0_PERIOD + SR0->R0_NROPGT == __cPeriodCalc + __cNumPgCalc .And. SR0->R0_PEDIDO == "1"
										Reclock("SR0", .F.)
										SR0->(dbDelete())
										SR0->(MsUnlock())
									EndIf
									SR0->(dbSkip())
								EndDo
							EndIf						
						EndIf						
					EndIf
				Else
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Verificar se existe lancamento em sr0                        ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					DbSelectArea( "SR0" )
					SR0->(DbSetOrder( nOrdemSR0 ))	// Ordem 1
					If ! (SR0->( DbSeek( (cAxTabMestra)->RA_FILIAL + (cAxTabMestra)->RA_MAT, .F. ) ) )
					   lProcDem := .F.
					Else
						lProcDem:= .F. 
						While  (cAxTabMestra)->RA_FILIAL + (cAxTabMestra)->RA_MAT == SR0->R0_FILIAL + SR0->R0_MAT  .And. !lProcDem 
							If cRoteiro == cRotVtr .AND. SR0->R0_TPVALE == '0' //VTR
								lProcDem := .T.
							Endif
							If cRoteiro == cRotVrf .AND. SR0->R0_TPVALE == '1' //VRF
								lProcDem := .T.
							Endif
							If cRoteiro == cRotVal .AND. SR0->R0_TPVALE == '2' //VAL
								lProcDem := .T.
							Endif
							SR0->(dbSkip())
							Loop
						EndDo
					EndIf
				EndIf
			EndIf
			If !lProcDem
				If cTabMestra <> "SRA"
					If !GotoNextRecno( cAxTabMestra , nNextRecno , nOrder )
						Exit
					EndIf
				Else
					(cAxTabMestra)->(DbSkip())
				EndIf
				If !lGrid .AND. !lWorkFlow
					IncPrcG1Time( cMsgIncPrc , nRecCount , cTimeIni , .T. , 1 , 1 , .T., .F. )
				EndIf
				Loop
			EndIf
		EndIf

		lSaltaFunc := .F.
		cMotivo    := ""	
		
  		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Tratamento para performance - Roteiros 13o Sal./Adiantamento ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If cPaisLoc == "BRA" .and. cTabMestra == 'SRA' .and. cSitFolh == "D" .and. cRoteiro $ cRot132+"*"+cRot131+"*"+cRotAdi
			cMotivo 	:= STR0096 //(Demitido)
			lSaltaFunc 	:= .T.
		ElseIf cRoteiro $ cRotFol + "*" + cRotAut .and. !lDissidio .and. (cAxTabMestra)->RA_ADMISSA > dPerFim
			//Se funcionário foi admitido após o periodo de calculo, despreza -- Calc. Folha/Autonomo
			cMotivo 	:= STR0136 + DtoC((cAxTabMestra)->RA_ADMISSA) //Admissão: 
			lSaltaFunc 	:= .T.
		ElseIf cRoteiro == cRotAdi .and. (cTabMestra)->RA_ADMISSA >= dDtPago .And. !( cAdtoPro == "S" .And. (cTabMestra)->RA_ADMISSA == dDtPago )//Não calcula adiantamento se funcionário foi admitido no dia ou após o pagamento do Adiantamento
			cMotivo 	:= STR0136 + DtoC((cAxTabMestra)->RA_ADMISSA) //Admissão: 
			lSaltaFunc 	:= .T.
		ElseIf cRoteiro == cRotFol .and. (cAxTabMestra)->(RA_CATFUNC) $ "A*P" //Se roteiro de Folha e funcionário for autonomo ou pró-labore, não calcula.
			cMotivo 	:= STR0138 //Funcionário autônomo/pró-labore
			lSaltaFunc 	:= .T.
		EndIf

		If lSaltaFunc
			If P_LOGDEM .or. cMotivo <> STR0096 //(Demitido)
				cValue 		:= ( Str( ( cTabMestra )->( Recno() ) , 8 ) + "      " )
				cTitle 		:= STR0029 //"Registro      "
				For nLoop := 1 To nCampos
					cCpyChave	:= aKeyMestra[nLoop]
					cValue		+= ( cTabMestra )->( Gpem020ValCpo( cTabMestra , cCpyChave , @cTitle , aHdrMestre ) )
				Next nLoop
				IF Empty( aNoPrcRegLog )
					aAdd( aNoPrcRegLog , cTitle )
					aAdd( aNoPrcRegLog , "" )
				EndIf
				cValue += cMotivo
				aAdd( aNoPrcRegLog, cValue )
			EndIf
			(cAxTabMestra)->(DbSkip())
			If !lGrid .AND. !lWorkFlow
				IncPrcG1Time( cMsgIncPrc , nRecCount , cTimeIni , .T. , 1 , 1 , .T., .F. )
			EndIf
			Loop
		EndIf
		//------------------------------------------------------------------------------//
		// PLR Equador - Verifica se o funcionario deve ser considerado para o calculo	//
		//------------------------------------------------------------------------------//
		If lPlrEqu .and. !fChkFunc(CtoD("31/12/"+PLRANO),MV_PAR04)
			(cAxTabMestra)->(DbSkip()) 
			If nRecno = nRecCount .and. !lExeRot
				(cAxTabMestra)->( DbGoTo(nRecTab) )
				(cTabMestra)->( DbGoTo(nRecTab) ) 
				nRegsProc := 0
				If cTabMestra <> "SRA" .and. !GetNextRecno( cAxTabMestra, @nNextRecno , @nRecno , nOrder )
					Exit
				EndIf								
				lExeRot := .T.
			Else
				Loop
			EndIf				
		EndIf
        
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Consiste Codigo do Processo                                            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If lChkProcesso
			If (cTabMestra)->(&(cCpoProcesso)) != cProcesso
				If cTabMestra <> "SRA"
					If !GotoNextRecno( cAxTabMestra , nNextRecno , nOrder )
						Exit
					EndIf
				Else
					(cAxTabMestra)->(DbSkip())
				EndIf
				If !lGrid .AND. !lWorkFlow
					IncPrcG1Time( cMsgIncPrc , nRecCount , cTimeIni , .T. , 1 , 1 , .T., .F. )
				EndIf
				Loop
		   EndIf
		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Consiste Filiais                                                       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If ( lCampoFil )
			cFilMestre	:= ( cTabMestra )->( FieldGet( nFieldFil ) )
			cFilExec	:= xFilial( cTabMestra , cFilMestre )
			If cFilExec <> cFilExAux
				cFilExAux := cFilExec
				If ( cTabMestra )->( !( cFilExec $ fValidFil() ) )
					cFilNoExec += cFilExec + "/"
					If cTabMestra <> "SRA"
						If !GotoNextRecno( cAxTabMestra , nNextRecno , nOrder )
							Exit
						EndIf
					Else
						(cAxTabMestra)->(DbSkip())
					EndIf
					If !lGrid .AND. !lWorkFlow
						IncPrcG1Time( cMsgIncPrc , nRecCount , cTimeIni , .T. , 1 , 1 , .T., .F. )
					EndIf
					Loop
				EndIf
			ElseIf !Empty(cFilExec) .and. cFilExec $ cFilNoExec
				If cTabMestra <> "SRA"
					If !GotoNextRecno( cAxTabMestra , nNextRecno , nOrder )
						Exit
					EndIf
				Else
					(cAxTabMestra)->(DbSkip())
				EndIf
				If !lGrid .AND. !lWorkFlow
					IncPrcG1Time( cMsgIncPrc , nRecCount , cTimeIni , .T. , 1 , 1 , .T., .F. )
				EndIf
				Loop			
			EndIf
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Atualiza Mnemonicos
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	
			If !lDissidio
				If !Empty( cFilMestre ) .And. FwxFilial("RCA", cFilMestre) <> FwxFilial("RCA", cFilAnt)
					aPergAux := aClone(aPergunte)
					RstMnemonicos()
					SetMnemonicos(cFilMestre ,@aMnemo,.T.)
					aPergunte := aClone(aPergAux)
				EndIf	
				If FindFunction("RstNroPed") .And. xFilial("RCB", cFilMestre) != xFilial("RCB", cFilAnt)
					RstNroPed()
				EndIf
			EndIf
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Atualiza cFilAnt                                                       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If !Empty( cFilMestre )
				cFilAnt := cFilMestre
			EndIf
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Garanto o Posicionamento no SIGAMAT.EMP                                ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			GetCache( "SM0" , ( cEmpAnt + cFilAnt ) , NIL , NIL , 1 , .T. )
		EndIf
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Consiste Acesso                                                        ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If (cTabMestra)->( !(&(cAcessa)) )
			If cTabMestra <> "SRA"
				If !GotoNextRecno( cAxTabMestra , nNextRecno , nOrder )
					Exit
				EndIf
			Else
				(cAxTabMestra)->(DbSkip())
			EndIf
			If !lGrid .AND. !lWorkFlow
				IncPrcG1Time( cMsgIncPrc , nRecCount , cTimeIni , .T. , 1 , 1 , .T., .F. )
			EndIf
			Loop
		EndIf
		
		//------------------------------------------------------------------------------//
		// PLR Equador - Acumula qtde de dias trabalhados e qtde de dependentes			//
		//------------------------------------------------------------------------------//
		If lPlrEqu .and. !lExeRot
			EQUTOTFUN()
			If nRecno = nRecCount
				(cAxTabMestra)->( DbGoTo(nRecTab) )
				(cTabMestra)->( DbGoTo(nRecTab) ) 
				nRegsProc := 0
				If cTabMestra <> "SRA" .and. !GetNextRecno( cTabMestra, @nNextRecno , @nRecno , nOrder )
					Exit
				EndIf								
				lExeRot := .T.
			EndIf
		EndIf

		If lExeRot
			//Tratamento para informar no log que funcionário foi reintegrado no período referente ao cálculo
			If cPaisLoc == "BRA" .And. !Empty(SRA->RA_FECREI) .and. cRoteiro $ cRot132+"*"+cRot131+"*"+cRotPLR
				If Year(SRA->RA_FECREI) == Year(StoD(cCompPer+"01"))
					cValue 		:= ( Str( ( cTabMestra )->( Recno() ) , 8 ) + "      " )
					cTitle 		:= STR0029 //"Registro      "
					For nLoop := 1 To nCampos
						cCpyChave	:= aKeyMestra[nLoop]
						cValue		+= ( cTabMestra )->( Gpem020ValCpo( cTabMestra , cCpyChave , @cTitle , aHdrMestre ) )
					Next nLoop
					IF Empty( aNoPrcRegLog )
						aAdd( aNoPrcRegLog , cTitle )
						aAdd( aNoPrcRegLog , "" )
					EndIf
					cValue += STR0140 //" foi reintegrado durante o período de referência do cálculo. É necessário conferir se existem descontos que devem ser realizados."
					aAdd( aLogReint, cValue )
				EndIf
			EndIf
		
			If !lGrid
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Movimenta cursor para movimentacao da barra 				   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cMsgIncPrc	:=	STR0030 //"Calculando Roteiro"
				cMsgIncPrc	+=	" -> "
				cMsgIncPrc	+=	cRoteiro
				cMsgIncPrc	+=	" - " 
				cMsgIncPrc	+=	cDesc
				If cPaisLoc == "BRA" .And. cTabMestra == 'SRA'
					cMsgIncPrc	+=	" - Matricula: " + SRA->(RA_FILIAL + "-" + RA_MAT)
				EndIf
				If lSegPlan
					IncProc()
				ElseIf !lWorkFlow
					IncPrcG1Time( cMsgIncPrc , nRecCount , cTimeIni , .T. , 1 , 1 , .T., .F. )
				EndIf
	
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Executando o Roteiro de Calculo                                        ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				__lImpMsg := .T.	//# Indica se imprime a Msg de FinalFun() no Log

				If cRoteiro == cRotVtr .And. SRA->RA_CATFUNC == "C"
					If fGetPerAtual( @aPerAtFol, , cProcesso, fGetRotOrdinar() )
						cPerFol := aPerAtFol[1,1]
						RetPerAbertFech(cProcesso, fGetRotOrdinar(), cPerFol, __cNumPgCalc, Nil, Nil, @aPerAberto, @aPerFechado )	
						aBkpFol := RetornaVerbasFunc( SRA->RA_FILIAL, SRA->RA_MAT, Nil, fGetRotOrdinar(), NIL, aPerAberto, aPerFechado, __cNumPgCalc )
							
						If Empty(aBkpFol)
							aBkpPerg 	:= aClone(aPergunte)
							cPerVT		:= SetPeriodCalc( cPerFol )
							ExecRot( @cFilExec, fGetRotOrdinar() )
							SetPeriodCalc( cPerVT )
							aBkpPd 		:= aClone(aPd)					
							aPergunte 	:= aClone(aBkpPerg)
							aPeriodo 	:= {}
							cPeriodo 	:= ""
							cRot 		:= ""
						Else
							aEval( aBkpFol, { |x| aAdd( aBkpPd, { x[3], x[12], x[8], x[6], X[7] } ) } )
						EndIf
					EndIf
				EndIf
				
				cNomeForm	:= ""
				
				If cRoteiro != "BOP"
					aConvoc		:= BuscaConv()

					If SRA->RA_TPCONTR == "3" .And. SRA->RA_SITFOLH != "D" .And. Empty(aConvoc[1,1]) //Performance - Não possui convocação
						cValue 		:= ( Str( ( cTabMestra )->( Recno() ) , 8 ) + "      " )
						cTitle 		:= STR0029 //"Registro      "
						For nLoop := 1 To nCampos
							cCpyChave	:= aKeyMestra[nLoop]
							cValue		+= ( cTabMestra )->( Gpem020ValCpo( cTabMestra , cCpyChave , @cTitle , aHdrMestre ) )
						Next nLoop
						IF Empty( aNoPrcRegLog )
							aAdd( aNoPrcRegLog , cTitle )
							aAdd( aNoPrcRegLog , "" )
						EndIf
						cValue += STR0137 //Contrato intermitente - sem convocação
						aAdd( aNoPrcRegLog, cValue )		
						(cAxTabMestra)->(DbSkip())
						Loop					
					EndIf
					
					NSFINTERM	:= 0
					aPdConvoc	:= {}
					
					For nI := 1 To Len(aConvoc)
						//Executa cálculo de VT do intermitente apenas se for a última convocação do mês
						If SRA->RA_TPCONTR == "3" .and. cRoteiro $ ( cRotVtr + "/" + cRotVrf + "/" + cRotVal ) .and. !aConvoc[nI,6]
							Loop
						EndIf
						//Quando há rescisão de contrato intermitente, o campo RGB_CONVOC não é preenchido, pois não existe o camp de convocação na SRR.
						//Com a tratativa abaixo, caso for cálculo de folha após cálculo de rescisão, será gravada a convocação ativa da competência do cálculo.
						If cPaisLoc == "BRA" .and. (cRoteiro $ cRotFol + "*" + cRotAut ) .and. cTabMestra == 'SRA'
							If cSitFolh == "D" .and. nI > 1
								Loop
							EndIf
						EndIf
						SetConvocCalc( aConvoc[nI][1],aConvoc[nI])
						
						nRet := ExecRot( @cFilExec , @cRoteiro, Nil, @cNomeForm )
			
						If nRet == 0
							If fGetTipoRot( cRoteiro ) $ "1/5/6/9"
                                //grava historico de médias
							    fHistMed(,iif(lDiss,"1","2"))
                            EndIf
						EndIf
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Valores Positivos ( Nao ocorrencia de Erros )				   ³
						³         													   ³
						³nRet == 0 	-> ExecRot() TudoOk								   ³
						³nRet == 1 	-> Desprezar o Registro duranto o Processamento	   ³
						³nRet == 2 	-> Forcar a Finalizacao do Calculo           	   ³
						³         													   ³
						³Valores Negativos ( Ocorrencia de Erros )				   	   ³
						³         													   ³
						³nRet == -1	-> Erro ao Carregar os Mnemonicos              	   ³
						³nRet == -2	-> Erro ao Carregar as Formulas					   ³
						³nRet == -3	-> Erro ao Carregar o Roteiro					   ³
						³nRet == -4	-> Erro ao Compilar a Funcao de Roteiro			   ³
						³nRet == -5	-> Erro ao Executar o Roteiro					   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						If (;
								( nRet < 0 );	//Ocorreu Erro
								.or.;
								( nRet == 2 );	//Forcou a Finalizacao do Calculo
							)	
							nPosRecno := (cTabMestra)->(Recno())
							Break
						ElseIf ( nRet == 1 .And. __lImpMsg )	//Desprezou o Registro durante o Processamento
							cValue 		:= ( Str( ( cTabMestra )->( Recno() ) , 8 ) + "      " )
							cTitle 		:= STR0029 //"Registro      "
							For nLoop := 1 To nCampos
								cCpyChave	:= aKeyMestra[nLoop]
								cValue		+= ( cTabMestra )->( Gpem020ValCpo( cTabMestra , cCpyChave , @cTitle , aHdrMestre ) )
							Next nLoop
							IF Empty( aNoPrcRegLog )
								aAdd( aNoPrcRegLog , cTitle )
								aAdd( aNoPrcRegLog , "" )
							EndIf
							If cSitFolh == "D" //Se esta demitido, informa no log
								cValue += STR0096 //(Demitido)
							EndIf
							aAdd( aNoPrcRegLog, cValue )
						EndIf
					Next nI
				Else
					aBenOP		:= fBuscaBOP()
					aPdBenOp	:= {}
					
					For nI := 1 To Len(aBenOP)
						SetBenOP( aBenOP[nI][1], aBenOP[nI])
						
						nRet := ExecRot( @cFilExec, @cRoteiro, Nil, @cNomeForm )
			
						If (;
								( nRet < 0 );	//Ocorreu Erro
								.or.;
								( nRet == 2 );	//Forcou a Finalizacao do Calculo
							)	
							nPosRecno := (cTabMestra)->( Recno() )
							Break
						ElseIf ( nRet == 1 .And. __lImpMsg )	//Desprezou o Registro durante o Processamento
							cValue 		:= ( Str( ( cTabMestra )->( Recno() ) , 8 ) + "      " )
							cTitle 		:= STR0029 //"Registro      "
							For nLoop := 1 To nCampos
								cCpyChave	:= aKeyMestra[nLoop]
								cValue		+= ( cTabMestra )->( Gpem020ValCpo( cTabMestra , cCpyChave , @cTitle , aHdrMestre ) )
							Next nLoop
							IF Empty( aNoPrcRegLog )
								aAdd( aNoPrcRegLog , cTitle )
								aAdd( aNoPrcRegLog , "" )
							EndIf
						EndIf
					Next nI
				EndIf
			Else
				// Tratamento para IR Multiplos vinculos //
				nPos := 0
				If lCalIRMV // Somente para Tabela de Funcionarios
					nPos := aScan( aIRMV, { |x| x[1] = SRA->RA_CIC } )
				EndIf
				
				cMatExec	:= ""
				If cPaisLoc == "BRA" .and. cTabMestra == 'SRA'
					cMatExec	:= (cTabMestra)->RA_MAT
				EndIf
				If nPos == 0 
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Gerar Array para Calculo em GRID                                       ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If nCountReg == 0 .Or. nCountReg >= nLoteGrid
						Aadd(aCall, {} )
						nRegGrid++
						nCountReg := 0
					EndIf
					nCountReg++
					Aadd(aCall[nRegGrid], {nRegGrid, cTabMestra, (cTabMestra)->(Recno()), cFilExec, cMatExec } )
				Else
					aAdd( aIRMV[ nPos ], {0, cTabMestra, (cTabMestra)->(Recno()), cFilExec, cMatExec } )
				EndIf
			EndIf      
			
		EndIf
	    
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Utilizado para retornar a posicao do ultimo registro na FinalCalc()    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nPosRecno := (cTabMestra)->(Recno())
        
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica o Numero Efetivo de Registros Processados                     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nRegsProc := nRegsProc + 1
		
		If cTabMestra <> "SRA"
			If !GotoNextRecno( cAxTabMestra , nNextRecno , nOrder )
				Exit
			EndIf
		Else
			(cAxTabMestra)->(DbSkip())
		EndIf
		
	EndDo
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Execucao do Calculo da Folha atraves do GRID		       	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If lGrid .and. lCalIRMV
		nCountReg := 0

		For nX := 1 To Len( aIRMV )
			If Len( aIRMV[nX] ) == 1 	// Nao possui funcionarios de IRMV para calculo
				Loop
			EndIf
			
			// Tratamento para o Numero de Funcionarios com o mesmo CPF //			
			If nCountReg == 0 .Or. nCountReg >= nLoteGrid .Or. ( (Len(aIRMV[nX])-1) + nCountReg) >= nLoteGrid
				Aadd(aCall, {} )
				nRegGrid++
				nCountReg := 0
			EndIf
			For nY := 2 To Len( aIRMV[nX] )
				aIRMV[nX, nY,1] := nRegGrid
				nCountReg++
				Aadd(aCall[nRegGrid], aIRMV[nX, nY] )
			Next nY
		Next nX
	EndIf
	
	If lGrid

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Execucao do Calculo da Folha atraves do GRID		       	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !lWorkflow //caso o calculo venha por workflow nao ha objeto da tela de aviso e nao atualiza mensagem
			MsProcTxt( OemToAnsi(STR0063) ) // "Finalizando o Calculo com GRID..."
		EndIf
		CalcGrid(cRoteiro, aCall, aKeyMestra, aHdrMestre)
		nRet := nRetCalc
	EndIf

End Sequence

If !lDissidio
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Libera MayIExecRot()													³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !lGrid .And. !__lFilRPO
		LeaveExecRot()
	EndIf
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Fecha o Repositorio Auxiliar                                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	RpoFormInit( NIL , .T. )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaura o Processo para Calculo                             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	SetProcesCalc( cSvProcesCalc )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaura o Periodo para Calculo                              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	SetPeriodCalc( cSvPeriodCalc )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaura o Numero de Pagamento do Calculo                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	SetNumPgCalc( cSvNumPgCalc )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaura o Roteiro de Calculo                                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	SetRotExec( cSvRoteiro )

	If cPaisLoc == "BRA"
		fAtuRCHSt( 2, Nil, aRecnoRCH )
	EndIf
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Adiciona Informacoes no Log de Processamento							³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If lGrid 
	cDuracaoProcesso := ElapTime( cTimeIni, Time() )
Else
	DEFAULT nContDur := 2
	cDuracaoProcesso	:= RemainingTime( cTimeIni , nContDur , .F. )
	nContDur++
EndIf

aAdd( aProcessoLog , STR0022 + " " + Time() + " " + STR0023 + " "  + Dtoc( MsDate() ) )//"Final do Processo de Calculo:"###"de"
aAdd( aProcessoLog , STR0024 + " " + cDuracaoProcesso )	//"Duracao do Processo de Calculo:"
aAdd( aProcessoLog , STR0025 + " " + MediumTime( cDuracaoProcesso , nRegsProc , .T. ) ) //"Tempo Medio de Calculo:"
aAdd( aProcessoLog , STR0026 + " " + AllTrim( Str( nRegsProc ) ) )	//"Numero de Registros Processados:"

If fGetTipoRot( cRoteiro ) $ "1/9" .And. lVerMetrics .And. nRegsProc >= 100
    FwCustomMetrics():setAverageMetric( Iif( !lDissidio, "FOLHA", "DISSIDIO" ), "totvs-rh-protheus_processamento-calculos_average", TimeToSeconds( cDuracaoProcesso )/60  )
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Adiciona Informacoes do Processamento no Log Geral           			³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdd( aGpem020TitLog	, aProcessoTit[1] )
aAdd( aGpem020Log		, aClone( aProcessoLog ) )

If !Empty(aLogCC)
	aAdd( aGpem020TitLog	, STR0091 )//"Inconsistências"
	aAdd( aGpem020Log		, aClone( aLogcc ) )
EndIf


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Se existir tabelas que nao possuem indice da chave unica, informar ao  ³
³usuario.                                                               ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aNotExistIndex := fGetLogIndex()
If !Empty(aNotExistIndex)
	aAdd( aGpem020TitLog , OemToAnsi(STR0040) + " " + OemToAnsi(STR0041) )	//"Tabelas que nao possuem indice igual a chave unica " ### "compromete a performance de calculo"
	For nLoop := 1 To Len(aNotExistIndex)
		aAdd( aAuxIndex, aNotExistIndex[nLoop,1] + "  -  " + aNotExistIndex[nLoop,2] )
	Next nLoop
	aAdd( aGpem020Log, aClone( aAuxIndex ) )
EndIf

aVerbas := {}

If cPaisLoc == "BRA" .and. !IsBlind() .and. !lDissidio .And. fVldFerPd(@aVerbas)
	aAdd( aGpem020TitLog , OemToAnsi(STR0105) )
	aLogVbs := {}
	For nX := 1 To Len(aVerbas)
		aAdd( aLogVbs, aVerbas[nX] )
	Next nX
	aAdd( aGpem020Log, aClone( aLogVbs ) )
EndIf 
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Adiciona, no Log,  ultimo Registro Processado                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF (;
		( nRet <> 0 );
		.or.;
		( lAbortPrint );
	)	
	IF ( cTabMestra)->( !Eof() )
		IF ( lAbortPrint )
			aAdd( aGpem020TitLog	, STR0027 + " " + Dtoc( MsDate() ) + " " + STR0028 + " " + Time() ) //"Cancelado Pelo Usuario em:"###"as"
		Else
			aAdd( aGpem020TitLog	, STR0034 + " - " + cNomeForm) //"Calculo Finalizado Pela FinalCalc() ou Pela EndCalc()"
		EndIf
		If nPosRecno > 0
			(cTabMestra)->(DbGoTo(nPosRecno))

			aLastRegProc := {}
			aAdd( aLastRegProc , STR0035 )		//"Ultimo Registro Processado"
			aAdd( aLastRegProc , "" )
			cValue 		:= ( Str( ( cTabMestra )->( Recno() ) , 8 ) + "      " )
			cTitle 		:= STR0029 //"Registro      "
			For nLoop := 1 To nCampos
				cCpyChave	:= aKeyMestra[nLoop]					
				cValue		+= ( cTabMestra )->( Gpem020ValCpo( cTabMestra , cCpyChave , @cTitle , aHdrMestre ) )
			Next nLoop
			aAdd( aLastRegProc	, cTitle )
			aAdd( aLastRegProc	, "" )
			aAdd( aLastRegProc	, cValue )
			aAdd( aGpem020Log	, aClone( aLastRegProc ) )
		Else
			aAdd( aGpem020Log	, {''} )
		EndIf
	
	EndIf
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carregando Informacoes para o Log                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aLogInit := LogExecRot()
For nLoop := 1 To Len( aLogInit )
   IF (;
   			!Empty( aLogInit[ nLoop , 2 ] );
   			.and.;
   			( Len( aLogInit[ nLoop , 2 ] ) > 0 );
   		)
   		aAdd( aGpem020TitLog	, aLogInit[ nLoop , 1 ] )
   		aAdd( aGpem020Log		, aClone( aLogInit[ nLoop , 2 ] ) )
   EndIf
Next nLoop

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Aciona o Log de Registros nao Processados                              ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF !Empty( aNoPrcRegLog )
	aAdd( aGpem020TitLog	, STR0021 )	//"Registros Nao Processados"
	aAdd( aGpem020Log		, aClone( aNoPrcRegLog ) )
EndIf 

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Aciona o Log de Funcionários reintegrados                              ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF !Empty( aLogReint )
	aAdd( aGpem020TitLog	, STR0139 )	//"Funcionários reintegrados"
	aAdd( aGpem020Log		, aClone( aLogReint ) )
EndIf 

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Aciona o Log de Registros com Periodo Bloqueado                        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If !Empty( aRegBlqPerLog )
	aAdd( aGpem020TitLog	, STR0069 )	//"Registros Nao Processados - Periodo Bloqueado para Filial"
	aAdd( aGpem020Log		, aClone( aRegBlqPerLog ) )
EndIf  

// Ponto de entrada VERLOGFL 
// @See http://tdn.totvs.com/x/wMJc
If ExistBlock("VERLOGFL")
	ExecBlock("VERLOGFL", .F., .F.)
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Mostrar o Log                                                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If !lDissidio
	If lWorkFlow
		//Grava o log em arquivo texto
		For nX := 1 to Len(aGpem020TitLog)
			AutoGrLog(aGpem020TitLog[nX])
			For nY := 1 to Len(aGpem020Log[nX])
				AutoGrLog(aGpem020Log[nX,nY])
			Next nY
		Next nX
    Else
    	nPosFiltr := ascan(aGpem020TitLog,{|x| "Expressao de Filtro Utilizada no Calculo:" $ x })
    	nPosFinal := ascan(aGpem020TitLog,{|x| "FinalCalc()" $ x .or. "EndCalc()"  $ x  })
    	If nPosFinal > 0 .And. nPosFiltr > 0
    		cTmpTit := aGpem020TitLog[nPosFiltr]
    		aTmpLog := aClone(aGpem020Log[nPosFiltr])
    		aDel(aGpem020TitLog,nPosFiltr)
    		aDel(aGpem020Log,nPosFiltr)
    		aSize(aGpem020TitLog,Len(aGpem020TitLog)-1)
    		aSize(aGpem020Log,Len(aGpem020Log)-1)
    		aadd(aGpem020Log,aTmpLog)
    		aadd(aGpem020TitLog,cTmpTit)
    	EndIf
		If !lGrid 
			MsAguarde( { || fMakeLog( aGpem020Log , aGpem020TitLog , FunName() , NIL , FunName()+cRoteiro , STR0016 ) } ,  STR0016 ) //"Log de Ocorrencias no Processo de Calculo"
		Else		
			fMakeLog( aGpem020Log , aGpem020TitLog , FunName() , NIL , FunName()+cRoteiro , STR0016 ) //"Log de Ocorrencias no Processo de Calculo"		
		EndIf
	EndIf
	If lSegPlan
		GPESmartViewUtils():CreateLog( aGpem020Log , aGpem020TitLog , FunName() , NIL , FunName()+cRoteiro , STR0016 )  //"Log de Ocorrencias no Processo de Calculo"
	EndIf
Else
   	aProcessoLog := {}
	For nLoop := 1 To Len( aGpem020TitLog )
	   	aadd(aErrProc[1],aGpem020TitLog[ nLoop  ])
	Next nLoop
	
	For nLoop := 1 To Len( aGpem020Log )
	   	aadd(aErrProc[2],aGpem020Log[ nLoop ])
	Next nLoop
	If lSegPlan
		GPESmartViewUtils():CreateLog( aGpem020Log , aGpem020TitLog , FunName() , NIL , FunName()+cRoteiro , STR0016 )  //"Log de Ocorrencias no Processo de Calculo"
	EndIf
EndIf	

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Fechar a Tabela Auxiliar do SRA                                        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If lCalIRMV .or. cTabMestra == "SRA" 
	IF ( Select( cAxTabMestra ) > 0 )
		(cAxTabMestra)->( DbCloseArea() )
	EndIf
Else
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Finalizando o Filtro                                                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	EndFilBrw( cAxTabMestra, @aIndex )
EndIf

lWorkFlow := Nil

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Restaura os Ponteiros de Entrada                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cFilAnt := cSvFilAnt
RestArea( aAreaTabMestra )
RestArea( aAreaRCH )
RestArea( aAreaSM0 )
RestArea( aArea )
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³CalcGrid	 ³ Autor ³ Mauricio Takakura  ³ Data ³11/07/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Inclusao do Calculo Atraves de GRID - Multiprocessamento   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³CalcGrid 													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³ Gpem020 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function CalcGrid(cRot, aCall, aKeyMestra, aHdrMestre)
Local aParAmb	:= {}
Local cMsgGrid 	:= ''	// Variavel para retorno de Log
Local cTextLog	:= ""
Local lNewGrid	:= FindFunction("GridCliVersion")
Local lTitle	:= .F.
Local lMsgUser	:= .F.
Local lNoError	:= .T.
Local lCompileOk
Local lRet 		:= .T.
Local nI, nT, nX, nZ, nY, nW
Local nTamanho  
Local nGridLog	:= If( lNewGrid, 4, 3 )
Local aParDiss := {}

Default aMnemo := {}

Private oGrid

If !lDissidio .and. Empty(aMnemo)
	SetMnemonicos(NIL,@aMnemo,.T.)
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Criacao do Objeto GRID e Processamento				       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
oGrid := GridClient():New()
If ValType(oGrid) == "U"
	AddLogExecRot( OemToAnsi(STR0043) ) // "Falha na criacao do Objeto GridClient. Impossivel executar processo em GRID."
	lRet := .F.
EndIf

If lRet

	MayIExecRot()
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Compilar as formulas, pois com o GRID nao permite, pois tera ³
	³ mais de uma Thread utilizando e nao estara em modo exclusivo.³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	lCompileOk := GetTreeFrm( NIL, xFilial( "RC2" ), NIL , NIL , .T. , NIL, .T. )
	IF !lCompileOk
		LeaveExecRot()
		AddLogExecRot(OemToAnsi(STR0043)) // "Não foi possível compilar as fórmulas para o Cálculo."
		Return
	Else
		GetFunRot( xFilial( "SRY" ) , cRot )
	EndIf
	RpoFormInit( NIL, .T. )
	
	LeaveExecRot()
	
	If lDissidio
	
		aParDiss := {lDissidio,cMesAnoCalc,cMesAnoDiss,aSalInc,cCompPer,dDInicioTar,nVlPiso,aCGD,aR,aC,nBaseMesAux,cSemPag,lProAdm,;
					   nMesProp,cIdCmpl,cExclui,aPercDif,nVlPiso,nPisoMes,nPisoDia,nPisoHora,nPercDif,nValAum,cDatArq,dDInicioTar,;
					   	cAnoMesProp,cRotOrig,cTipoAum}
	Else
		aParDiss := {lDissidio}
	EndIf
	
	aParAmb:={cEmpAnt,cFilAnt,dDataBase,aEmpresas,cUsuario,;						// Parametros Public do sistemas
		  {aMnemo, cRot, GetPeriodCalc(), GetProcesCalc(), GetNumPgCalc(),; 	// Parametros Privates da Rotina
		  cDbfLog, cNameFile, cChaveLog, aKeyMestra, aHdrMestre,;
		  If( Type("aPergunte") <> "U", aPergunte, {} ), date(), time() },aParDiss}

	// Chama a execucao em Grid. Caso ela retorne .F., ou o grid nao pode ser iniciado, 
	// ou algum processo deu erro, ou um ou mais itens nao foram processados.	
	lRet := oGrid:BatchExec("GPEM020AMB",aParAmb,"GPEM020GRD",aCall,"GPEM020FIM")

	If !lRet .and. Empty(oGrid:aGridThreads)
		AddLogExecRot( OemToAnsi(STR0044) ) // "Nenhum Agente do GRID disponivel no Momento."
		lRet := .F.
	EndIf

	// Erro no processamento do GRID - Erros Fatais //
	If !empty(oGrid:aErrorProc)
		// [1] : Numero sequencial da instrucao enviada que nao foi processada
		// [2] : Parametro enviado para processamento 
		// [3] : String contendo informacoes do ERRO
		nT := Len(oGrid:aErrorProc)

		For nI := 1 to nT

			nTamanho := MlCount(oGrid:aErrorProc[nI][3], 150)

			// Verificar se existem mensagem do usuario ou ocorreu erro fatal do sistema //
			cTextLog := ""
			lMsgUser := .F.
			lNoError := .T.
			For nX := 2 To nTamanho
				cMsgGrid := MemoLine( oGrid:aErrorProc[nI][3], 150, nX )
				If Substr(cMsgGrid,1,9) == 'ERRORNRET'
					lMsgUser := .F.
                EndIf
				If lMsgUser
					cTextLog += cMsgGrid
				EndIf
				If Substr(cMsgGrid,1,11) == '##ERRORNRET'
				   nRetCalc := Val(Substr(cMsgGrid,12,2))
				   lMsgUser := .T.
				   lNoError := .F.
				EndIf					
			Next nX
			If lNoError
				AddLogExecRot( OemToAnsi( STR0045 ) + " " + Str(oGrid:aErrorProc[nI,1],5) ) // "Requisição: "
				cTextLog := oGrid:aErrorProc[nI][3]
			EndIf
			nTamanho := MlCount(cTextLog, 150)
			For nX := 1 To nTamanho
				cMsgGrid := MemoLine(cTextLog, 150, nX )
			  	AddLogExecRot( cMsgGrid )
			Next nX
		Next nI
	EndIf

	// Requisicoes que nao foram processadas //
	If !Empty(oGrid:aSendProc)

		AddLogExecRot( CRLF+CRLF )
		AddLogExecRot( OemToAnsi( STR0047 ) ) // "Informações não processadas no GRID"

		// [1] : Numero sequencial da instrucao enviada que nao foi processada
		// [2] : Parametro enviado para processamento 
		// [3] : Retorno da execuçao 
		nT := len(oGrid:aSendProc)
		For nI := 1 to nT  
			AddLogExecRot( CRLF + OemToAnsi( STR0045 ) + " " + Str(oGrid:aSendProc[nI,1],5)) // "Requisição:"

			For nW := 1 To Len(oGrid:aSendProc[nI,2])
				AddLogExecRot( Space(10) + OemToAnsi("Filial") + " " + oGrid:aSendProc[nI,2,nW,4] + "   " + OemToAnsi("Matrícula") + " " + oGrid:aSendProc[nI,2,nW,5]) // "Filial" ## "Matrícula"
			Next nW
		Next nI
	EndIf

	// Recupera retornos das chamadas - Mensagens de Log do Calculo (Retorno diferente de NIL da funcao GPEM020GRD
	If !empty(oGrid:aInfoProc)
		// [1] : Numero sequencial da instrucao enviada que nao foi processada
		// [2] : Parametro enviado para processamento
		// [3] : Retorno da execuçao
		nT := Len(oGrid:aInfoProc)
		For nI := 1 To nT
			For nY := 1 To Len(oGrid:aInfoProc[nI,nGridLog])
				For nZ := 1 To Len(oGrid:aInfoProc[nI][nGridLog][nY][2])
					If (oGrid:aInfoProc[nI][nGridLog][nY][1] == '__NOPRCREG')
						If nZ = 1 .and. lTitle	// Controle para nao repetir o titulo
							Loop
						Else
							lTitle := .T.
						EndIf
						aAdd( aNoPrcRegLog, oGrid:aInfoProc[nI][nGridLog][nY][2][nZ] )
					Else
						AddLogExecRot( oGrid:aInfoProc[nI][nGridLog][nY][2][nZ] )
					EndIf
				Next nZ
			Next nY
		Next nI
		
	EndIf
	
	// Excluir os Processos que Terminaram com Sucesso.
	cQuery := " DELETE FROM "
	cQuery += " " + cNameFile + " "
	If cDbfLog == "RE2"
		cQuery += " WHERE RE2_CHAVE = '" + cChaveLog + "'"
	Else
		cQuery += " WHERE CHAVE = '" + cChaveLog + "'"
	EndIf
	TcSqlExec( cQuery )
EndIf

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Gpem020Amb   ³ Autor ³ Mauricio Takakura  ³ Data ³11/07/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Preparacao do Ambiente para as Threads                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpem020Amb()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³ Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function Gpem020Amb(aParms)
Local cEmpParm  	:= aParms[1]	// Empresa conectada 	--> cEmpAnt
Local cFilParm  	:= aParms[2]	// Filial conectada 	--> cFilAnt
Local dDataParm 	:= aParms[3]	// Data Base			--> dDataBase
Local aEmpParm		:= aParms[4]	// Array com empresas 	--> aEmpresas
Local cUsuaParm 	:= aParms[5]	// Usuario conectado	--> cUsuario
Local aMnemonicos	:= aClone(aParms[6,1])	// Array dos Mnemonicos

Local cType	
Local lRet 			:= .T.
Local lSetDef
Local lShowErr		:= .F.
Local nMnemo
Local nMnemos
Local uVar
Local nX
Local __lMemCalc //Memória de cálculo

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Preparacao de novo ambiente - Tabelas e Variaveis.           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
RpcSetType(3)
PREPARE ENVIRONMENT EMPRESA (cEmpParm) FILIAL (cFilParm) MODULO "GPE" FUNNAME "GPEM020"

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Funcoes de Carga do Sistema              ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
RstMvBuff()

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Parametros a declara                                         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
_SetOwnerPrvt( 'cDbfLog'   , aParms[6,06] )			// Alias do Arquivo de Log
_SetOwnerPrvt( 'cNameFile' , aParms[6,07] )			// Nome do Arquivo de Log
_SetOwnerPrvt( 'cChaveLog' , aParms[6,08] )			// Chave do Arquivo de Log
_SetOwnerPrvt( 'aKeyMestra', aParms[6,09] )			// Chave para mostrar os dados no Log 
_SetOwnerPrvt( 'aHdrMestre', aParms[6,10] )			// Array do aHeader da tabela Mestre
_SetOwnerPrvt( 'aBkpPd', {} )			// Array com copia do aPd
_SetOwnerPrvt( '__aMVLog', {} )
_SetOwnerPrvt( 'lContrInt', If(SRC->(ColumnPos( 'RC_CONVOC' )) > 0,.T.,.F.))
_SetOwnerPrvt( 'aTotRegs', array(2))
_SetOwnerPrvt( 'nOrigVal', 0)
_SetOwnerPrvt( 'nOrigHor', 0)
_SetOwnerPrvt( 'nOrigVlMat', 0)
_SetOwnerPrvt( 'nOrigHrMat', 0)
_SetOwnerPrvt( 'nDisSalInc', 0)
_SetOwnerPrvt( 'aTitle', {} )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis Staticas que devem ser setadas para o calculo     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
SetRotExec(aParms[6,2])		// Seta o Roteiro de Calculo
SetPeriodCalc(aParms[6,3])  // Seta Período de Calculo de Pagamento
SetProcesCalc(aParms[6,4])	// Seta Processo de Calculo
SetNumPgCalc(aParms[6,5])	// Seta o Nro de Pagamento

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Setar os mnemonicos para nao declarar a cada requisicao as   ³
³ PRIVATES e tardar o tempo de processo.                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
nMnemos := Len(aMnemonicos)
If nMnemos > 0 
	For nMnemo := 1 to nMnemos
		lSetDef := .F.

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Inicializa e carrega os valores Padroes declarando como       ³
		³Privates na Funcao que Chamou( 1 nivel acima )				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !Empty( uVar := AllTrim( aMnemonicos[ nMnemo , 03 ] ) )
			IF ( aMnemonicos[ nMnemo , 04 ] == "D" .and. ( "/" $ uVar ) )
				IF CheckExecForm( { || uVar := Ctod( uVar ) },lShowErr )
					IF ( ( cType := ValType( uVar ) ) == aMnemonicos[ nMnemo , 04 ] )
						_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ], uVar )
					Else
						lSetDef := .T.
					EndIf
				Else
					lSetDef := .T.
				EndIf
			ElseIf CheckExecForm( @uVar , lShowErr ) 
				_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ], uVar )
			Else
				lSetDef := .T.
			EndIf
		Else
			lSetDef := .T.
		EndIf
		If lSetDef
			_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ], GetValType( aMnemonicos[ nMnemo , 04 ] ) )
		EndIf

	Next nMnemo
EndIf
_SetOwnerPrvt( 'lDissidio', aParms[7,1] )
_SetOwnerPrvt( 'oPercDif', HMNew() ) //Cria novo hashmap, não é possível transportá-lo via batchexec
	
If lDissidio
	Afill(aTotRegs,0)
EndIf

If aParms[7,1]
	_SetOwnerPrvt( 'cMesAnoCalc', aParms[7,2] )
	_SetOwnerPrvt( 'cMesAnoDiss', aParms[7,3] )
	_SetOwnerPrvt( 'aSalInc', aParms[7,4] )
	_SetOwnerPrvt( 'cCompPer', aParms[7,5] )
	_SetOwnerPrvt( 'dDInicioTar', aParms[7,6] )
	_SetOwnerPrvt( 'nVlPiso', aParms[7,7] )
	_SetOwnerPrvt( 'aCGD', aParms[7,8] )
	_SetOwnerPrvt( 'aR', aParms[7,9] )
	_SetOwnerPrvt( 'aC', aParms[7,10] )
	_SetOwnerPrvt( 'nBaseMesAux', aParms[7,11] )
	_SetOwnerPrvt( 'cSemPag', aParms[7,12] )
	_SetOwnerPrvt( 'lProAdm', aParms[7,13] )
	_SetOwnerPrvt( 'nMesProp', aParms[7,14] )
	_SetOwnerPrvt( 'cIdCmpl', aParms[7,15] )
	_SetOwnerPrvt( 'cExclui', aParms[7,16] )
	_SetOwnerPrvt( 'aPercDif', aParms[7,17] )
	_SetOwnerPrvt( 'nVlPiso', aParms[7,18] )
	_SetOwnerPrvt( 'nPisoMes', aParms[7,19] )
	_SetOwnerPrvt( 'nPisoDia', aParms[7,20] )
	_SetOwnerPrvt( 'nPisoHora', aParms[7,21] )
	_SetOwnerPrvt( 'nPercDif', aParms[7,22] )
	_SetOwnerPrvt( 'nValAum', aParms[7,23] )
	_SetOwnerPrvt( 'cDatArq', aParms[7,24] )
	_SetOwnerPrvt( 'dDInicioTar', aParms[7,25] )
	_SetOwnerPrvt( 'cAnoMesProp', aParms[7,26] )
	_SetOwnerPrvt( 'cRotOrig', aParms[7,27] )
	_SetOwnerPrvt( 'cTipoAum', aParms[7,28] )
	
	//Carrega hashmap
	For nX := 1 to Len(aPercDif)
		HMSet(oPercDif, aPercDif[nX,1], aPercDif[nX])
	Next nX	
EndIf
aPergunte := aClone( aParms[6,11] )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variaveis publicas do Sistema            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aEmpresas := aClone(aEmpParm)
dDataBase := dDataParm
cUsuario  := cUsuaParm
__lMemCalc := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc()
	If __lMemCalc
		fSetMemCalc(aParms[6,12],aParms[6,13])
	EndIf

Return(lRet)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Gpem020Grd   ³ Autor ³ Mauricio Takakura  ³ Data ³12/07/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Rotina para execucao do GRID.                              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpem020Grd()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³ Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function GPEM020GRD(aCall)
Local aLogCalc
Local aRetLog 		:= {}
Local aNoPrcRegLog 	:= {}
Local aBkpPerg		:= {}

Local cTabMestra
Local cFilExec
Local cRoteiro		:= GetRotExec()
Local cMsgLog
Local cRdd			:= "TOPCONN"
Local cRotInter		:= ( fGetCalcRot('C') + "*" + fGetCalcRot('I') + "*" + fGetCalcRot('5') + "*" + fGetCalcRot('6') + "*" + fGetCalcRot('2') + "*" + fGetCalcRot('F') )
Local cRotVerAm		:= ( fGetCalcRot('5') + "*" + fGetCalcRot('6'))
Local cCpyChave
Local cValue		:= ""
Local cTitle		:= ""
Local cRequis
Local cQuery
Local cRotFol 		:= fGetCalcRot('1')
Local cRotAut 		:= fGetCalcRot('9')
Local cRotVtr 		:= fGetCalcRot('8')
Local cRotVrf 		:= fGetCalcRot('D')
Local cRotVal 		:= fGetCalcRot('E') 

Local cSvFilAnt		:= cFilAnt
Local nY
Local nT
Local nZ
Local nRet			:= 0
Local nTotReg
Local nPosRecno
Local nLoop 
Local nCampos		:= 1
Local nRequis		:= 0
Local nX			:= 0

Local lRet			:= .T.
Local lExist		:= .F.

Local aBenOP		:= {}
Local aConvoc		:= {}
Local nI			:= 1

DEFAULT lGpm020Rot := ExistBlock("GPM020ROT")

If lGpm020Rot
	cRotInter := ExecBlock("GPM020ROT", .F., .F., {cRotInter})
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Tratamento para Arquivo de Log           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
nRequis 	:= aCall[1,1]	// Numero da Requisicao
cTabMestra 	:= aCall[1,2]	// Nome da Tabela Mestre
If cTabMestra == "SRA"
	If ! (cDbfLog == "RE2")
		If !(lRet := MsOpenDbf( .T. , cRdd, cNameFile , cDbfLog , .T. , .F. , .F. , .F. ))
			cMsgLog := CRLF + OemToAnsi(STR0042) // "Nao foi possivel abrir o Arquivo de Log de Registros"
			UserException(cMsgLog)		// Abortado o calculo pela execucao do Calculo
		EndIf
		IF !( lRet := ( Select( cDbfLog ) > 0 ) )
			cMsgLog := CRLF + OemToAnsi(STR0042) // "Nao foi possivel abrir o Arquivo de Log de Registros"
			UserException(cMsgLog)		// Abortado o calculo pela execucao do Calculo
		EndIf
	EndIf
	
	//Incluir o Registro da Requisicao no LOG
	DbSelectArea( cDbfLog )
	cRequis := StrZero( aCall[1,1] , 8)
	RecLock( cDbfLog , .T., .T. )
	
	If (cDbfLog == "RE2")
		(cDbfLog)->RE2_CHAVE := cChaveLog
		(cDbfLog)->RE2_REQUIS := cRequis
		(cDbfLog)->RE2_ROTEIR := cRoteiro
	Else
		(cDbfLog)->CHAVE 	:= cChaveLog
		(cDbfLog)->REQUIS 	:= cRequis
		(cDbfLog)->ROTEIRO	:= cRoteiro
	EndIf
	
	(cDbfLog)->( MsUnLock() )
EndIf

nTotReg := Len(aCall)
For nX := 1 to nTotReg
	cTabMestra 	:= aCall[nX,2]	// Nome da Tabela Mestre
	nPosRecno	:= aCall[nX,3]	// Posicao do recno na tabela Mestre
	cFilExec	:= aCall[nX,4]	// Filial de execucao do calculo

	dbSelectArea( cTabMestra )
	(cTabMestra)->(DbGoTo( nPosRecno ))
	
	//verifica centro de custo
	If Empty((cTabMestra)->(RA_CC)) .Or. ! ValidCPO("CTT", 1, xFilial( "CTT", (cTabMestra)->(RA_FILIAL)) + (cTabMestra)->(RA_CC))
		AddLogExecRot(OemToAnsi(STR0092) + (cTabMestra)->(RA_FILIAL) + " - " +  (cTabMestra)->(RA_MAT) + OemToAnsi(STR0093)) //"Funcionário "#" está com Centro de custo em branco, atualize cadastro."
		Loop
	EndIf
		
	// Tratamento para funcionários com tipo de contrato intermitente
	If cPaisLoc == "BRA" .And. cTabMestra == 'SRA' .And. ( ((cTabMestra)->(RA_TPCONTR) == "3" .And. cRoteiro $ cRotInter) .Or. (SRA->RA_CATEFD $ "107/108" .And. cRoteiro $ cRotVerAm) )
		nCampos := Len(aKeyMestra)
		For nLoop := 1 To nCampos
			cCpyChave	:= aKeyMestra[nLoop]
			cValue		+= ( cTabMestra )->( Gpem020ValCpo( cTabMestra , cCpyChave , @cTitle , aHdrMestre ) )
		Next nLoop
		If Empty( aNoPrcRegLog )
			aAdd( aNoPrcRegLog, STR0029 )
			aAdd( aNoPrcRegLog, "" )
		EndIf
		If (cTabMestra)->RA_TPCONTR == "3"
			Aadd( aNoPrcRegLog, cValue + STR0097 ) // "Contrato intermitente"
		Else
			Aadd( aNoPrcRegLog, cValue + STR0125 ) // "Contrato verde e amarelo"
		EndIf
		Loop
	EndIf	
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Atualiza cFilAnt                                                       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF !Empty( cFilExec )
		cFilAnt := cFilExec
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Executa o Calculo  								           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cRoteiro == cRotVtr .And. SRA->RA_CATFUNC == "C"
		aBkpPerg 	:= aClone(aPergunte)
		ExecRot( @cFilExec , fGetRotOrdinar() )
		aBkpPd 		:= aClone(aPd)					
		aPergunte 	:= aClone(aBkpPerg)
		cRot 		:= ""					
	EndIf
	
	cSitFolh := If(!Empty(SRA->RA_DEMISSA) .or. SRA->RA_SITFOLH == "D", "D", " ")	
	If cRoteiro != "BOP"
		aConvoc := BuscaConv()
		aPdConvoc := {}
		For nI := 1 To Len(aConvoc)

			//Executa cálculo de VT do intermitente apenas se for a última convocação do mês
			If SRA->RA_TPCONTR == "3" .and. cRoteiro $ ( cRotVtr + "/" + cRotVrf + "/" + cRotVal ) .and. !aConvoc[nI,6]
				Loop
			EndIf
		
			//Quando há rescisão de contrato intermitente, o campo RGB_CONVOC não é preenchido, pois não existe o camp de convocação na SRR.
			//Com a tratativa abaixo, caso for cálculo de folha após cálculo de rescisão, será gravada a convocação ativa da competência do cálculo.
			IF cPaisLoc == "BRA" .and. (cRoteiro $ cRotFol + "*" + cRotAut ) .and. cTabMestra == 'SRA'
				IF cSitFolh == "D" .and. nI > 1
					Loop
				Endif
			Endif
			SetConvocCalc( aConvoc[nI][1],aConvoc[nI])
			
			nRet := ExecRot( @cFilExec , @cRoteiro )
			cFilAnt := cSvFilAnt	

			If nRet == 0 .And. fGetTipoRot(cRoteiro) $ "1/5/6/9"
                //Grava historico de médias
				fHistMed(, IIf(lDissidio, "1", "2"))
            EndIf
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Valores Positivos ( Nao ocorrencia de Erros )				   ³
			³         													   ³
			³nRet == 0 	-> ExecRot() TudoOk								   ³
			³nRet == 1 	-> Desprezar o Registro duranto o Processamento	   ³
			³nRet == 2 	-> Forcar a Finalizacao do Calculo           	   ³
			³         													   ³
			³Valores Negativos ( Ocorrencia de Erros )				   	   ³
			³         													   ³
			³nRet == -1	-> Erro ao Carregar os Mnemonicos              	   ³
			³nRet == -2	-> Erro ao Carregar as Formulas					   ³
			³nRet == -3	-> Erro ao Carregar o Roteiro					   ³
			³nRet == -4	-> Erro ao Compilar a Funcao de Roteiro			   ³
			³nRet == -5	-> Erro ao Executar o Roteiro					   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF (;
					( nRet < 0 );	//Ocorreu Erro
					.or.;
					( nRet == 2 );	//Forcou a Finalizacao do Calculo
				)
		
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Carregando Informacoes para o Log                                      ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				aLogCalc := LogExecRot() // Funcao limpa a variavel static de LOG
		
				nX := nTotReg	// Sair do Laco For..Next
				cMsgLog := CRLF + CRLF 
				cMsgLog += "##ERRORNRET"+Str(nRet,2)+CRLF
				For nT := 1 To Len( aLogCalc )
					If ValType( aLogCalc[nT] ) == "A"
						For nY := 1 To Len( aLogCalc[nT] )
							If ValType( aLogCalc[nT,2] ) == "A" .and. Len( aLogCalc[nT,2] ) > 0
								If ValType( aLogCalc[nT,nY] ) == "C"
									cMsgLog += aLogCalc[nT, nY] + CRLF
								Else
									For nZ := 1 To Len( aLogCalc[nT, nY] )
										If ValType( aLogCalc[nT, nY, nZ] ) == "C"
											cMsgLog += aLogCalc[nT, nY, nZ] + CRLF
										EndIf			
									Next nZ
								EndIf
							EndIf
						Next nY
					EndIf
				Next nT
				cMsgLog += CRLF + "ERRORNRET"+Str(nRet,2)+"##"+CRLF
				If nRet == 2
					cMsgLog += CRLF + 'Calculate Process Aborted with UserException by' // Complemento da Mensagem que sera enviado pelo Gerenciamento do GRID
				Else
					cMsgLog += CRLF + "Aborted by UserException" // Complemento da Mensagem que sera enviado pelo Gerenciamento do GRID				
				EndIf
				AddLogExecRot(cMsgLog)
				//UserException(cMsgLog)		// Abortado o calculo pela execucao do Calculo
				
			ElseIf ( nRet == 1 )	//Desprezou o Registro durante o Processamento
				nCampos		:= Len( aKeyMestra )
				cValue 		:= ( Str( ( cTabMestra )->( Recno() ) , 8 ) + "      " )
				cTitle 		:= STR0029 //"Registro      "
				For nLoop := 1 To nCampos
					cCpyChave := aKeyMestra[nLoop]
					cValue		+= ( cTabMestra )->( Gpem020ValCpo( cTabMestra , cCpyChave , @cTitle , aHdrMestre ) )
				Next nLoop
				IF Empty( aNoPrcRegLog )
					aAdd( aNoPrcRegLog , cTitle )
				EndIf
				aAdd( aNoPrcRegLog, cValue )
			EndIf
		Next nI
	Else
		aBenOP		:= fBuscaBOP()
		aPdBenOp	:= {}

		For nI := 1 To Len(aBenOP)
			SetBenOP( aBenOP[nI][1], aBenOP[nI])
			
			nRet := ExecRot( @cFilExec , @cRoteiro )
			cFilAnt := cSvFilAnt
		
			IF (;
					( nRet < 0 );	//Ocorreu Erro
					.or.;
					( nRet == 2 );	//Forcou a Finalizacao do Calculo
				)
		
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Carregando Informacoes para o Log                                      ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				aLogCalc := LogExecRot() // Funcao limpa a variavel static de LOG
		
				nX := nTotReg	// Sair do Laco For..Next
				cMsgLog := CRLF + CRLF 
				cMsgLog += "##ERRORNRET"+Str(nRet,2)+CRLF
				For nT := 1 To Len( aLogCalc )
					If ValType( aLogCalc[nT] ) == "A"
						For nY := 1 To Len( aLogCalc[nT] )
							If ValType( aLogCalc[nT,2] ) == "A" .and. Len( aLogCalc[nT,2] ) > 0
								If ValType( aLogCalc[nT,nY] ) == "C"
									cMsgLog += aLogCalc[nT, nY] + CRLF
								Else
									For nZ := 1 To Len( aLogCalc[nT, nY] )
										If ValType( aLogCalc[nT, nY, nZ] ) == "C"
											cMsgLog += aLogCalc[nT, nY, nZ] + CRLF
										EndIf			
									Next nZ
								EndIf
							EndIf
						Next nY
					EndIf
				Next nT
				cMsgLog += CRLF + "ERRORNRET"+Str(nRet,2)+"##"+CRLF
				If nRet == 2
					cMsgLog += CRLF + 'Calculate Process Aborted with UserException by' // Complemento da Mensagem que sera enviado pelo Gerenciamento do GRID
				Else
					cMsgLog += CRLF + "Aborted by UserException" // Complemento da Mensagem que sera enviado pelo Gerenciamento do GRID				
				EndIf
				AddLogExecRot(cMsgLog)
				//UserException(cMsgLog)		// Abortado o calculo pela execucao do Calculo
				
			ElseIf ( nRet == 1 )	//Desprezou o Registro durante o Processamento
				nCampos		:= Len( aKeyMestra )
				cValue 		:= ( Str( ( cTabMestra )->( Recno() ) , 8 ) + "      " )
				cTitle 		:= STR0029 //"Registro      "
				For nLoop := 1 To nCampos
					cCpyChave := aKeyMestra[nLoop]
					cValue		+= ( cTabMestra )->( Gpem020ValCpo( cTabMestra , cCpyChave , @cTitle , aHdrMestre ) )
				Next nLoop
				IF Empty( aNoPrcRegLog )
					aAdd( aNoPrcRegLog , cTitle )
				EndIf
				aAdd( aNoPrcRegLog, cValue )
			EndIf
		Next nI	
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Atualizar o LOG com o ultimo funcion. processado da Requisicao³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cTabMestra == "SRA"
		cQuery := " UPDATE "
		cQuery += " " + cNameFile + " "
		If (cDbfLog == "RE2")
			cQuery += " SET RE2_CONTRO = '1', "
			cQuery += " RE2_FILIAL = '" + SRA->RA_FILIAL + "', "
			cQuery += " RE2_MAT = '" + SRA->RA_MAT + "', "
			cQuery += " RE2_DTGRAV = '" + DTOC(MsDate()) + "', "
			cQuery += " RE2_HRGRAV = '"  + Time() + "' "
			cQuery += " WHERE RE2_CHAVE = '" + cChaveLog + "'"
			cQuery += " AND RE2_REQUIS = '" + cRequis + "'"
		Else 
			cQuery += " SET   CONTROL = '1',  "
			cQuery += " FILIAL = '" + SRA->RA_FILIAL + "', "
			cQuery += " MAT = '" + SRA->RA_MAT + "', "
			cQuery += " DT_GRAVA = '" + DTOC(MsDate()) + "', "
			cQuery += " HR_GRAVA = '" + Time() + "' "
			cQuery += " WHERE CHAVE = '" + cChaveLog + "'"
			cQuery += "   AND REQUIS = '" + cRequis + "'"
		EndIf
		TcSqlExec( cQuery )
	EndIf
Next nX

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carregando Informacoes para o Log                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aLogCalc := LogExecRot() // Funcao limpa a variavel static de LOG

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verifica se existem Log para serem enviado ao usuario         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If !Empty(aNoPrcRegLog)
    aAdd( aLogCalc, { "__NOPRCREG", aNoPrcRegLog } )
EndIf
lExist := .F.
For nT := 1 To Len(aLogCalc)
	If Len(aLogCalc[nT,2]) > 0
		aAdd( aRetLog, aLogCalc[nT] )
		lExist := .T.
	EndIf
Next nT
If !lExist 
	aRetLog := NIL
EndIf

Return(aRetLog)

/*/{Protheus.doc} GPEM020FIM
//Executado ao finalizar uma thread do GRID
@author flavio.scorrea
@since 10/06/2019
@version undefined
@return return, return_description
@example
(examples)
@see (links_or_references)
/*/
Function GPEM020FIM()

If ValType(oPercDif) == "O"
	HMClean(oPercDif)
	FreeObj(oPercDif)
	oPercDif := Nil
EndIf


Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	  ³Gpem020ValCpo³ Autor ³ Equipe de RH       ³ Data ³19/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Validacao do campo chave para elaboracao do log            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpem020ValCpo()															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	     ³ Generico 												    				³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function Gpem020ValCpo(	cTabMestra , cCampo, cTitle , aHdrMestre )

Local cValCampo	:= ""

Local nPosCampo	:= 0
Local nTamTitle	:= 0 

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Obtem o Posicionamento do Campo no aHdrMestre				   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
nPosCampo := GdFieldPos( cCampo , aHdrMestre )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Caso nao encontre no aHeader, verificar se possui funcoes.    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( nPosCampo == 0 )
	cCampo		:= SubStr( cTexto , At( "(" , cTexto ) + 1 , At( ")" , cTexto ) - 1 )
	nPosCampo	:= GdFieldPos( cCampo , aHdrMestre )
EndIf

If ( nPosCampo > 0 )
	cValCampo := ( cTabMestra )->( FieldGet( FieldPos( cCampo ) ) )
	cValCampo := AllToChar( cValCampo , aHdrMestre[ nPosCampo , __AHEADER_PICTURE__ ] , .F. )
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Equiparar o tamanho do campo com o titulo                     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nTamTitle := Len( aHdrMestre[ nPosCampo , __AHEADER_TITLE__ ] )
	cValCampo := cValCampo + "      "
	If ( nTamTitle > Len( cValCampo ) )
		cValCampo := ( cValCampo + Replicate( " ", nTamTitle - Len( cValCampo ) ) )
	Else
		cTitle += ( aHdrMestre[ nPosCampo , __AHEADER_TITLE__ ] + Replicate( " " , Len( cValCampo ) - nTamTitle ) )
	EndIf
EndIf

Return( cValCampo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpem020Ok ³ Autor ³ Equipe de RH       	³ Data ³19/12/2004  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Confirmar as Configuracoes dos Parametros                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpem020Ok()												  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	     ³ Generico 											   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function Gpem020Ok(cExpFiltro, cRoteiro,aProcessoLog)

Local cLstPer
Local cLstNroPagto
Local cProc
Local cPeri
Local cNroPgto
Local cMsg
Local cTipoRot

DEFAULT aProcessoLog := {}

If lRet := MsgYesNo(OemToAnsi(STR0011),OemToAnsi(STR0005)) //"Confirma configura‡„o dos parƒmetros?"###"Aten‡„o"
	If Empty(cExpFiltro)
		lRet := MsgYesNo(OemToAnsi(STR0015),OemToAnsi(STR0005)) //"Nenhum filtro foi selecionado! Processar toda a tabela?"###"Aten‡„o"
	EndIf	
EndIf
If lRet
	cRoteiro	:= AllTrim(GetRotExec())
	If FunName() == "GPEM016"
		cTipoRot 	:= fGetTipoRot( cRoteiro)
		If cTipoRot <> 'C' .and. !Empty(cRoteiro)
			MsgInfo( OemToAnsi(STR0019) + " " + cRoteiro, OemToAnsi(STR0005)) //O Roteiro Selecionado para Calculo e invalido: ##Atencao!
			Return(.F.)
		EndIf
	ELseIf FunName() == "GP131CALC"  //Vale transporte,refeicao,alimentacao
		cTipoRot 	:= fGetTipoRot( cRoteiro)
		If !(cTipoRot $ "8*D*E*I") .and. !Empty(cRoteiro)
			MsgInfo( OemToAnsi(STR0019) + " " + cRoteiro, OemToAnsi(STR0005)) //O Roteiro Selecionado para Calculo e invalido: ##Atencao!
			Return(.F.)
		EndIf
	ElseIf FunName() == "GPEA001" //Plano de Saude
		cTipoRot 	:= fGetTipoRot( cRoteiro)
		If cTipoRot <> 'C' .and. !Empty(cRoteiro)
			MsgInfo( OemToAnsi(STR0019) + " " + cRoteiro, OemToAnsi(STR0005)) //O Roteiro Selecionado para Calculo e invalido: ##Atencao!
			Return(.F.)
		EndIf
	EndIf
	
EndIf

If Empty(cRoteiro)
	MsgInfo( OemToAnsi(STR0017), OemToAnsi(STR0005))		// "Nenhum Roteiro Selecionado!" ## "Atencao!"
	lRet := .F.
EndIf

/*/		
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Validar o Periodo do Parametro                                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
If !Empty( RCH->RCH_DTFECH )
	MsgInfo( OemToAnsi(STR0037), OemToAnsi(STR0005))		// "Periodo Selecionado no Parametro esta fechado!" ## "Atencao!"
	lRet := .F.
EndIf

/*/		
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar se eh o ultimo periodo do roteiro aberto                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
cProc 	:= cProcesso
cPeri 	:= __cPeriodCalc
cNroPgto:= __cNumPgCalc
cCompPer:= RCH->RCH_ANO + RCH->RCH_MES
lRet := fGetLastPer( @cLstPer, @cLstNroPagto, cProc, cRoteiro, .T., .T., Nil, xFilial("RCH", cFilRCJ))
If lRet

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Validar apenas o Codigo do Periodo, pois para Nro de Pagamento o usuario ³
	³ podera calcular periodos futuros.                                        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
	If cPeri <> cLstPer .and. !(cRoteiro $ "VTR*VRF*VAL*PLA*BEN*VEX")
		MsgInfo( OemToAnsi(STR0038), OemToAnsi(STR0005)) // "O Periodo Selecionado eh diferente ao Ultimo Periodo em Aberto!" # "Atencäo"
		lRet := .F.
	EndIf
	//# Para semanalistas apenas apresenta a mensagem de alerta
	If !Empty(cNroPgto) .and. cNroPgto <> cLstNroPagto
		cMsg := OemToAnsi(STR0038)	// "O Periodo Selecionado é diferente do Último Período em Aberto!"
		cMsg += CRLF + CRLF
		cMsg += OemToAnsi(STR0036)	// "Deseja Continuar o Processo de Calculo ?"
		lRet := MsgYesNo( cMsg, OemToAnsi(STR0005) )	// "Atencäo"
	EndIf
EndIf

/*/		
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Validar a Data do Pagamento do 13o Salario para Roteiros 131 e 132       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
If lRet .And. cRoteiro $ "131/132" .And. Empty( RCH->RCH_DTPAGO )
	MsgInfo( OemToAnsi(STR0064), OemToAnsi(STR0005))		// "Data de Pagamento do 13o Salário não Informada!" ## "Atencao!"
	lRet := .F.
EndIf

// Valida existência de Detalhes de Títulos por Roteiro (RJ1)
If  lCtrlTit 
	If  fExisTitFA(cProc,cPeri,cRoteiro,cNroPgto,@aProcessoLog) 
		If Len( aProcessoLog ) > 0	
			// "Atenção"###"Ação cancelada - título(s) encontrado(s) sobre esse cálculo."###"Consulte os Títulos listados no log." 
			Help( ,, OemToAnsi(STR0005),, OemToAnsi(STR0113), 1, 0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0115)}) 
			If Len( aProcessoLog ) > 0	
				// Imprime Log
				fCtrTitLg(aProcessoLog)
			EndIf
			lRet := .F.
		EndIf
	EndIf
EndIf


Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpem020SetFil³Autor³Mauricio T. Takakura    ³Data³25/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Setar as opcoes do Filtro									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpem020SetFil( aFilterExp , cTabMestra ) // MUDEI AQUI

Local aGrpUsr		:= {}	// Grupo dos Usuarios
Local cGrpUsr		:= ""	// string com o Grupo de usuario
Local cPrefix		:= "FILTRO_"
Local lTemRE7 		:= AliasInDic("RE7")
Local nLoop			:= 0	

If lTemRE7
	cPrefix			:= "RE7_"
EndIf

aAdd( aFilterExp , {  cPrefix+"ALS", cTabMestra 	, NIL , NIL    } )

/*/		
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Localizar os grupos a que o usuario pertence                             ³
'ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
aGrpUsr := UsrRetGrp( cUserName)
For nLoop := 1 To Len(aGrpUsr)
	cGrpUsr := aGrpUsr[nLoop]
	aAdd( aFilterExp , {  cPrefix+"GRP", cGrpUsr 	, NIL , NIL    } )
Next nLoop

aAdd( aFilterExp, { cPrefix+"PRG", FunName(), Nil, Nil } )
If FunName() != "GPEM020"
    aAdd( aFilterExp, { cPrefix+"PRG", "GPEM020", Nil, Nil } )
EndIf

Return( NIL )
             
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpem020Arq³Autor³Mauricio T. Takakura       ³Data³18/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retona o arquivo mestre cadastrado em RC2    				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpem020Arq(	cTabMestra		,;	// nome do arquivo mestre  // MUDEI AQUI
							oBtnNewFil		,;	// botao de novo filtro
							oBtnAltFil		,;  // botao de alteracao do filtro
							oBtnFastFil		,;	// botao de filtro rapido
							oBtnCalcule		 ;	// botao OK
						  )

Local cOldAlias := Alias()
Local cAliasQry	:= "QRCH"
Local cJoin		:= ""
Local cWhere	:= ""
Local cTipoRot
Local lBtn		:= .T.

// Tabela de Processos //
DbSelectArea("RCJ")
RCJ->( DbSetOrder( Retorder( "RCJ" , "RCJ_FILIAL+RCJ_CODIGO" ) ) )
RCJ->( DbSeek( xFilial("RCJ") + cProcesso , .F. ) )
	
//Verifica se o tipo de Roteiro eh para autonomos
cTipoRot := fGetTipoRot( GetRotExec()) 
// Tabela de Periodos //
DbSelectArea("RCH")
RCH->( DbSetOrder( Retorder( "RCH" , "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR" ) ) )

DbSelectArea("SRY")
SRY->( DbSetOrder( Retorder( "SRY" , "RY_FILIAL+RY_CALCULO" ) ) )

cJoin := "% "
cJoin += FWJoinFilial( "RCH", "SRY" ) + " AND "
cJoin += " RCH.RCH_ROTEIR 	  = SRY.RY_CALCULO "
cJoin += "%"

cWhere := "%"
cWhere += " RCH.RCH_PROCES	= '" + cProcesso + "' AND "
cWhere += " RCH.RCH_PER = '" + __cPeriodCalc + "' AND "
cWhere += " RCH.RCH_NUMPAG = '" + __cNumPgCalc + "' AND "
cWhere += " RCH.RCH_ROTEIR = '" + GetRotExec() + "' "
cWhere += "%"

BeginSql alias cAliasQry
	SELECT 		RCH_FILIAL, RCH_DTFECH, RY_FILIAL, RY_ALIAS 
	FROM 		%table:RCH% RCH
	INNER JOIN  %table:SRY% SRY
	ON 			%exp:cJoin%
	WHERE 		%exp:cWhere% AND
				RCH.%NotDel% AND
				SRY.%NotDel%
	ORDER BY RCH_FILIAL, RCH_PROCES, RCH_PER				
EndSql

lBtn := .F.

While (cAliasQry)->( !Eof() )
	If Empty( (cAliasQry)->( RCH_DTFECH ) )
		lBtn := .T.
		cTabMestra := (cAliasQry)->RY_ALIAS
		RCH->( DbSeek( (cAliasQry)->RCH_FILIAL + cProcesso + __cPeriodCalc + __cNumPgCalc + GetRotExec() , .F. ) )
		SRY->( DbSeek( (cAliasQry)->RY_FILIAL + GetRotExec() , .F. ) )
		Exit
	EndIf
	(cAliasQry)->( dbSkip() )
EndDo

(cAliasQry)->(DbCloseArea())

DbSelectArea( cOldAlias )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Ativar / Desativar os botoes conforme arquivo selecionado     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lBtn
	lBtn := !Empty( cTabMestra )
EndIf

oBtnNewFil:lActive 	:= lBtn
oBtnAltFil:lActive 	:= lBtn
oBtnFastFil:lActive := lBtn
oBtnCalcule:lActive	:= lBtn

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpem020Filter³Autor³Mauricio T. Takakura    ³Data³22/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Botao de alteracao do filtro                 				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpem020Filter(	aFilterExp 	,;		// opcoes do filtro  // MUDEI AQUI
								cTabMestra	,;		// alias do filtro
					 			cExpFiltro	,;		// string com o filtro - passado por referencia
								lShowDlg	 ;		// Se visualiza janela de filtros
					  		 )
Local aRetFiltro 	:= {}
Local aHeader 		:= {}

Local cTxtFil 		:= ""

DEFAULT lShowDlg	:= .T.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Elabora o cabecalho do arquivo Mestre                 	       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aHeader := GdMontaHeader(NIL,NIL,NIL,cTabMestra,NIL,.T.,.T.,.F.,.F.,.F.,.F.,.F.)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Retorna os filtros selecionados                       	       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aRetFiltro := GpFiltro( aFilterExp, .F. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Se for na inicializacao da dialog, nao mostrar a janela       ³
³Caso possua mais de 1 filtro selecionado-retornar filtro Vazio³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If (;
		( Len(aRetFiltro) > 1 );
		.And.;
		( lShowDlg );
	)	
	aRetFiltro := GpFiltro( aFilterExp )
ElseIf (;
			( Len(aRetFiltro) > 1 );
			.And.;
			!( lShowDlg );
		)	
	aRetFiltro := NIL
EndIf

If !Empty(aRetFiltro)
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Retorna a expressao dos filtros                      	       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cExpFiltro := GpFltAlsGet( aRetFiltro , cTabMestra )

	If lShowDlg
		cTxtFil    := GpFltBldDesc( cExpFiltro, @aHeader, cTabMestra )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Janela para alteracao dos valores do filtro          	       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		AltValExp( cTabMestra , @cExpFiltro , @cTxtFil , NIL , aHeader )
	EndIf
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³ChkSx9Proc   ³Autor³Mauricio T. Takakura    ³Data³05/10/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verificar se existe relacionamento entre Processo e tabela  ³
³          ³Mestre, para o filtro de processo.                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Gpem020             				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ChkSx9Proc( cTabMestra		,;	// Tabela Mestre
							cCpoProcesso	 ;	// Campo relacionado com Processo da tabela Mestre
						  )
Local aArea := GetArea()

Local cTabRCJ := "RCJ"

Local lRet  := .F.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Localizar o campo de Processo na tabela de Relacionamento    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
DbSelectArea( "SX9" )
DbSetOrder( 2 ) // X9_CDOM + X9_DOM
DbSeek( cTabMestra + cTabRCJ, .F. )
While SX9->( !Eof() ) .And. SX9->(X9_CDOM) = cTabMestra .And. SX9->(X9_DOM) = cTabRCJ
	If AllTrim( SX9->(X9_EXPDOM) ) == "RCJ_CODIGO"
	   cCpoProcesso := AllTrim( SX9->(X9_EXPCDOM) )
	   lRet := .T.
	EndIf
	SX9->( DbSkip() )
EndDo

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Validar se o Campo de Contra Dominio esta correto    	       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lRet
	If Empty( AliasCpo( cCpoProcesso ) )
		cCpoProcesso := ""
		lRet := .F.
	EndIf
EndIf
               
RestArea( aArea )

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
					F U N C O E S     U T I L I Z A D A S    E M     S X B 
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ/*/

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpem020Per³Autor³Mauricio T. Takakura       ³Data³18/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Periodo digitado na Consulta Padrao				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpem020Per( nTipo, cPeriodo, cNumPag, cReturn, lPergNumPag, lAberto )	// 1 - Campo RCH_PER e 2 - RCH_NUMPAG

Local cOldAlias := Alias()
Local cFilRCH	:= xFilial("RCH")
Local cMsg
Local lRet 		:= .T.

DEFAULT lPergNumPag := .T.
DEFAULT lAberto := .T.

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Devido nova diretriz dos fontes de PAISES (na LIB): GPEM020 + PAIS(PERU) = GPEM020PER() ³
³que coincide com nome de funcao preexistente generica.    								 ³
³O paliativo abaixo impede que ocorra error log no PERU ao chamar a rotina de Calculo da ³
³Folha (GPEM020), onde executava diretamente a GPEM020PER(valida periodo), indevidamente.³										 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If cPeriodo == Nil

	GPEM020()

	Return( NIL )
EndIf

Begin Sequence

	IF ( nTipo == 1 )
		IF !( lRet := NaoVazio() )
			Break
		EndIf
	EndIf

	DbSelectArea("RCH")
	If ( nTipo == 1 )
		RCH->( dbsetOrder( Retorder( "RCH" , "RCH_FILIAL+RCH_PROCES+RCH_PER+DTOS(RCH_DTFECH)" ) ) )
		If FunName() == "GPEM020" .and. lAberto
			RCH->( dbSeek( cFilRCH + cProcesso + cPeriodo + SPACE(8) , .F. ) )
		ElseIf FunName() $ ("GPEM690|GPEM760|GPEM691") .or. !lAberto
			RCH->( dbSeek( cFilRCH + cProcesso + cPeriodo, .F. ) )	
		EndIf	
	Else
		RCH->( dbsetOrder( Retorder( "RCH" , "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR" ) ) )
		RCH->( dbSeek( cFilRCH + cProcesso + cPeriodo + cNumPag, .F. ) )
		While RCH->(;
						!Eof();
						.and.;
						(;
							( RCH_FILIAL + RCH_PROCES + RCH_PER + RCH_NUMPAG );
							==;
							( cFilRCH + cProcesso + cPeriodo + cNumPag );
						);
					)		
			If Empty(RCH->RCH_DtFech)
				Exit
			EndIf
			RCH->( dbSkip() )
		EndDo
		If RCH->(;
					!Empty( RCH_DTFECH );
					.and.;
					(;
						( RCH_FILIAL + RCH_PROCES + RCH_PER + RCH_NUMPAG );
						==;
						( cFilRCH + cProcesso + cPeriodo + cNumPag );
					);
				)		
			RCH->(DbGoBottom())
			RCH->(dbSkip())
		EndIf
	EndIf
	If RCH->( Eof() )
		lRet := .F.
		If nTipo == 1
			cMsg := STR0012	// "Periodo nao Cadastrado!"
			MsgInfo( cMsg, STR0005)
		Else
			cMsg := STR0013	// "No. Pagamento nao Cadastrado para este Periodo!"
			If lPergNumPag
				cMsg += CRLF + CRLF
				cMsg += STR0036	// "Deseja Continuar o Processo de Calculo ?"
				lRet := MsgYesNo( cMsg )
			Else
				MsgInfo( cMsg, STR0005)	
			EndIf
		EndIf
	Else
		If nTipo == 1
			&cReturn := cPeriodo
		Else
			If !Empty( RCH->( RCH_Roteir ) )
				&cReturn := RCH->( RCH_Roteir )
			EndIf
		EndIf
	EndIf

End Sequence

DbSelectArea(cOldAlias)

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpem020Rot³Autor³Mauricio T. Takakura       ³Data³18/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Roteiro digitado na Consulta Padrao				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpem020Rot( cProcesso, cPeriodo, cNumPag, cVarRet, lPergRot, lTelaCalc )

Local aPerAtual	:= {}
Local cFilRCH
Local lRet 		:= .T.
Local lFound 	:= .F.
Local lOpeSoc	:= SuperGetMv("MV_OPESOC", NIL, .F.)  
Local cTipoRot  := "" 

MV_PAR02 := Upper(MV_PAR02)
cTipoRot := fGetTipoRot( &cVarRet )

DEFAULT lPergRot  := .T.
DEFAULT lTelaCalc := .F.

// Variavel pertence aos mnemonicos. Para evitar erros no sistema para os paises que nao possuem esse mnemonico cadastrado
If Type( "lDissidio" ) == "U"
	lDissidio := .F.
EndIf

If lTelaCalc
	If Empty(&cVarRet)
		Return(.T.)
	EndIf
	If ValType(cTipoRot) <> "U"
		If FunName() == "GPEM016"  //Plano de Saude
			If cTipoRot <> 'C'
				Return(.F.)
			EndIf
		ElseIf FunName() == "GP131CALC"  //Vale transporte, refeicao, alimentacao
			If !(cTipoRot $ "8*D*E*I")
				Return(.F.)
			EndIf
		ElseIf FunName() == "GPEA001" //Plano de Saude
			If cTipoRot <> 'C'
				Return(.F.)
			EndIf
		ElseIf FunName() == "GPER330" //Demonst.Horas
		    cFilRCJ := Iif(Type("cFilRCJ") != "U", cFilRCJ, xFilial("RCJ", RCJ->RCJ_FILIAL))
			If cTipoRot <> '1'
				Return(.F.)
			EndIf
		ElseIf FunName() == "GPER520" //Seguro de Vida
			If (cTipoRot <> '1' .And. cTipoRot <> '4')
				Return(.F.)
			EndIf
		ElseIf ( cTipoRot $ "3*4*G*J" .And. ( Type("lGestPubl") <> "U" .And. !lGestPubl ) ) .Or.;
				( cPaisLoc == "BRA" .And. !lOpeSoc .And. cTipoRot == "O" )
			MsgInfo( OemToAnsi(STR0019) + " " + cRoteiro, OemToAnsi(STR0005)) //O Roteiro Selecionado para Calculo e invalido: ##Atencao!
			Return(.F.)
		EndIf
	EndIf
	
	cFilRCJ := Iif(Type("cFilRCJ") != "U", cFilRCJ, xFilial("RCJ", RCJ->RCJ_FILIAL))

	If !fGetPerAtual( @aPerAtual, cFilRCJ, cProcesso, &cVarRet )
		MsgInfo( STR0066 , STR0005 ) // "Nenhum Periodo Ativo para este Roteiro!" ## "Atencao"
		Return(.F.)
	Else
		If fGetTipoRot( &cVarRet ) $ "8*C*D*E*I*K" //VT/Saude/Refeicao/Alimentacao/Outros Benef./Valores Extras
			If !Empty(aPerAtual[1,10])
				MsgInfo( STR0071 , STR0005 ) // "O período ativo do roteiro selecionado já foi integrado."
				Return(.F.)
			EndIf
		EndIf
		If FunName() == "GPER330" //Demonst.Horas
				SetMVValue("GPR330","MV_PAR03",aPerAtual[1,1])
				SetMVValue("GPR330","MV_PAR04",aPerAtual[1,2])
		Else
			If lVldCons
				SetMVValue("GPEM020","MV_PAR01",cProcesso)
				SetMVValue("GPEM020","MV_PAR02",&cVarRet)
				SetMVValue("GPEM020","MV_PAR03",aPerAtual[1,1])
				SetMVValue("GPEM020","MV_PAR04",aPerAtual[1,2])
			Else
				SetMVValue("GPEM020","MV_PAR01",cProcesso)
				SetMVValue("GPEM020","MV_PAR02",MV_PAR02)
				SetMVValue("GPEM020","MV_PAR03",MV_PAR03)
				SetMVValue("GPEM020","MV_PAR04",MV_PAR04)		
			EndIf
			dPerFim := aPerAtual[1,7]
			dDtPago := aPerAtual[1,11]
			Pergunte("GPEM020",.F.)
		Endif
		lVldCons := .T.
		Return(.T.)
	EndIf
EndIf

Begin Sequence

 	If Empty( cProcesso ) .Or. !( lRet := ExistCpo( "SRY" ) )
		lRet := .F.
		Break
	EndIf

	cFilRCH	:= xFilial("RCH")

	DbSelectArea("RCH")
	RCH->( dbsetOrder( Retorder( "RCH" , "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR" ) ) )
	If cTipoRot <> "9"   //Roteiro Diferente de Autonomos
		RCH->( dbSeek( cFilRCH + cProcesso + cPeriodo + cNumPag, .F. ) )
		While RCH->(;
						!Eof();
						.and.;
						(;
						( RCH_FILIAL + RCH_PROCES + RCH_PER + RCH_NUMPAG );
						==;
						( cFilRCH + cProcesso + cPeriodo + cNumPag );
					);	
				)	
			If RCH->(;
						(;
							RCH_ROTEIR == &cVarRet;
							.and.;
							Empty( RCH_DTFECH);
						);
						.Or.;
						(;
							Empty( RCH_ROTEIR );
							.and.;
							Empty( RCH_DTFECH );
						);
					)
				lFound := .T.
				Exit
			EndIf
			RCH->( dbSkip() )
		EndDo
	Else	
		RCH->( dbSeek( cFilRCH + cProcesso + cPeriodo , .F. ) )
		While RCH->(;
						!Eof();
						.and.;
						(;
						( RCH_FILIAL + RCH_PROCES + RCH_PER  );
						==;
						( cFilRCH + cProcesso + cPeriodo  );
					);	
				)	
			If RCH->(;
						(;
							RCH_ROTEIR == &cVarRet;
							.and.;
							Empty( RCH_DTFECH);
						);
						.Or.;
						(;
							Empty( RCH_ROTEIR );
							.and.;
							Empty( RCH_DTFECH );
						);
					)
				lFound := .T.
				Exit
			EndIf
			RCH->( dbSkip() )
		EndDo
   	EndIf
	If ( lFound )
		lFound := ExistCpo( "SRY" )
	EndIf

	If !( lFound ) .And. !lDissidio
		If lPergRot
			If MsgNoYes( STR0018 ) //"Utiliza Periodo para a Execucao do Roteiro"
				lRet := .F.
				MsgInfo( STR0014 , STR0005 ) // "Nenhum Roteiro Cadastrado com este Periodo!" ## "Atencao"
			EndIf
		Else
			lRet := .F.
			MsgInfo( STR0014 , STR0005 ) // "Nenhum Roteiro Cadastrado com este Periodo!" ## "Atencao"
		EndIf
	EndIf

End Sequence
		
Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpem020VldPrc³Autor³Mauricio T. Takakura    ³Data³18/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Periodo digitado na Consulta Padrao				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpem020VldPrc()
	
	Local aArea		:= GetArea()
	Local lFound	:= .F.
	Local cProc		:= &(ReadVar())
	
	If !Empty(cProc)
		
		DbSelectArea("RCJ")
		DbSetOrder(1)
		
		If Empty(RCJ->RCJ_FILIAL) .Or. !lF3Proc //caso o usuario esteja digitando o valor do processo, considerar filial logada
			RCJ->(DbGoTop())
			DbSeek(RCJ->(xFilial("RCJ")))
		EndIf
		
		If DbSeek(xFilial("RCJ",RCJ->RCJ_FILIAL) + cProc)
			lFound := .T.
		Else
			Help(" ", 1, "REGNOIS")
		EndIf
	Else
		Help(" ", 1, "NVAZIO")
	EndIf
	lF3Proc		:= .F.
RestArea(aArea)

Return( lFound )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³SetPeriodCalc	³Autor³Marinaldo de Jesus ³ Data ³13/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Seta o Periodo que Esta Sendo Calculado          			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SetPeriodCalc( cPeriodCalc )

Local cLastPeriodCalc := GetPeriodCalc()

__cPeriodCalc	:= cPeriodCalc

Return( cLastPeriodCalc )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³GetPeriodCalc   ³Autor³Marinaldo de Jesus ³ Data ³13/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Obtem o Periodo que Esta Sendo Calculado          			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPeriodCalc()
DEFAULT __cPeriodCalc := Space( GetSx3Cache( "RCH_PER" , "X3_TAMANHO" ) )
Return( __cPeriodCalc )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³SetProcesCalc	³Autor³Marinaldo de Jesus ³ Data ³13/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Seta o Processo que Esta Sendo Calculado          			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SetProcesCalc( cProcesCalc )

Local cLastProcesCalc := GetProcesCalc()

__cProcesCalc	:= cProcesCalc

Return( cLastProcesCalc )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³GetProcesCalc	³Autor³Marinaldo de Jesus ³ Data ³22/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Obtem o Processo que Esta Sendo Calculado          			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetProcesCalc()
DEFAULT __cProcesCalc := Space( GetSx3Cache( "RCH_PROCES" , "X3_TAMANHO" ) )
Return( __cProcesCalc )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³SetNumPgCalc	³Autor³Marinaldo de Jesus ³ Data ³22/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Seta o Numero de Pagamento do Calculo						³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SetNumPgCalc( cNumPgCalc )

Local cLastNumPgCalc := GetNumPgCalc()

__cNumPgCalc	:= cNumPgCalc

Return( cLastNumPgCalc )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³GetNumPgCalc	³Autor³Marinaldo de Jesus ³ Data ³22/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Obtem o Numero de Pagamento do Calculado          			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetNumPgCalc()
DEFAULT __cNumPgCalc := Space( GetSx3Cache( "RCH_NUMPAG" , "X3_TAMANHO" ) )
Return( __cNumPgCalc )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Gpem020Proc 	³Autor³Mauricio Takakura  ³ Data ³30/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Transferir o parametro MV_PAR01 para cProcess    			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpm020SetVar()

cProcesso := &( ReadVar() )

If Type( "cFilRCJ" ) <> "U"
	cFilRCJ := If(Empty(cFilRCJ) .or. FunName() $ "GPEM690|GPEM020|GPEM691|", RCJ->RCJ_FILIAL, cFilRCJ) //Guarda a filial do processo selecionado
EndIf

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Gpem020VerPerg  ³Autor³Tatiane Matias     ³ Data ³24/11/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Transferir os parametros da  pergunte GPM020 para as        ³
³          ³ variaveis e abre o grupo de perguntas associado ao roteiro,³
³          ³ se existir.                                				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpem020VerPerg(cPerg)										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cPerg - Grupo de Perguntas									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Gpem020       										        ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpem020VerPerg(cChave, lAbrir)

Local cOldAlias := Alias()
Local lBen 		:= MV_PAR02 $ fGetCalcRot("8") + "/" + fGetCalcRot("D") + "/" + fGetCalcRot("E")
Local lVT		:= MV_PAR02 == fGetCalcRot("8")
Local lNovoCalc := NovoCalcBEN() 

MV_PAR02 := Upper(MV_PAR02)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Seta o Processo para Calculo                                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
SetProcesCalc( MV_PAR01 )
cProcesso	 	:= MV_PAR01

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Seta o Periodo para Calculo                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
SetPeriodCalc( MV_PAR03 )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Seta o Numero de Pagamento do Calculo                        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
SetNumPgCalc( MV_PAR04 )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Seta o Roteiro de Calculo                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
SetRotExec( MV_PAR02 )
If cPaisLoc == "BRA" .And. P_CCOMP13 == 'S'.AND. MV_PAR02 == FGETCALCROT('1') .And. fTemROT132(,cProcesso,MV_PAR03,MV_PAR04)
	cChave := XFilial("SRY") + fGetcalcRot('6')
EndIf
dbSelectArea("SRY")
dbSetOrder(1)
If DbSeek( cChave )
	If !Empty(SRY->RY_PERGUNT)
      	cPergEspec := SRY->RY_PERGUNT
		If Alltrim(cPergEspec) == "GPEM016P" .And. !FWSX1Util():ExistPergunte("GPEM016P") 
			DbSelectArea( cOldAlias )
			Return Nil
		EndIf
      	If lNovoCalc
      		cPergEspec := Replace(cPergEspec,"GP020","GP021")
      		Pergunte(cPergEspec, lAbrir )
	      	cPergBen := ""
			If lBen	.And. ( (lVT .And. MV_PAR01 == 3) .Or. (!lVT .And. MV_PAR06 == 1) )
				Pergunte("GP020CPL", lAbrir )
				cPergBen := "GP020CPL"
			EndIf
		Else
			Pergunte(cPergEspec, lAbrir )
		EndIf
    EndIf
EndIf

DbSelectArea( cOldAlias )

Return ( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fOpenLog	³ Autor ³Mauricio Takakura     ³ Data ³05/07/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Cria/Abre arquivo de LOG								     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
	Static Function fOpenLog(cDbfLog)
	Local lRet			:= .T.
	Local aFields		:= {}
	Local cRdd			:= "TOPCONN"
	
	Begin Sequence
		IF ( !MsFile( cNameFile , NIL , cRdd ) )
			AADD(aFields, { "CHAVE"		,"C",20							,0} )	// Chave do Processamento
			AADD(aFields, { "REQUIS"	,"C",8							,0} )	// Nro da Requisicao em Processamento
			AADD(aFields, { "CONTROL"	,"C",1							,0} )	// Codigo de Controle -> 1-Processando/2-Finalizado
			AADD(aFields, { "FILIAL"	,"C",TamSX3("RA_FILIAL")[1]		,0} )	// Filial do ultimo Funcionario processado
			AADD(aFields, { "MAT"		,"C",TamSX3("RA_MAT")[1]		,0} )	// Matricula do ultimo Funcionario Processado
			AADD(aFields, { "NOME"		,"C",TamSX3("RA_NOME")[1]		,0} )	// Nome do ultimo Funcionario
			AADD(aFields, { "ROTEIRO"	,"C",TamSX3("RY_CALCULO")[1]	,0} )  	// Roteiro do calculo
			AADD(aFields, { "DT_GRAVA"	,"C",8							,0} )	// Data da ultima gravacao
			AADD(aFields, { "HR_GRAVA"	,"C",8							,0} )	// Hora da ultima gravacao
			IF !( lRet := MsCreate( cNameFile , aFields , cRdd ) )
				Break
			EndIf
		EndIf
		
		IF !( lRet := MsOpenDbf( .T. , cRdd, cNameFile , cDbfLog , .T. , .F. , .F. , .F. ) )
			Break
		EndIf
		
		IF !( lRet := ( Select( cDbfLog ) > 0 ) )
			Break
		EndIf
	End
	
Return (lRet)  

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fChkIRMV	³ Autor ³Mauricio Takakura     ³ Data ³27/07/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica a existencia de funcionarios para IRMV			     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
Static Function fChkIRMV(aIRMV)
Local aArea		:= SRA->(GetArea())
Local cDtIniPer := RCH->RCH_DTINI
Local cDtFimPer := RCH->RCH_DTFIM
Local lCalIRMV	:= .F.

cDtIniPer := "%'"+DTOS(cDtIniPer)+"'%"
cDtFimPer := "%'"+DTOS(cDtFimPer)+"'%"

If Select("QSRA") > 0
	QSRA->( dbCloseArea() )
EndIF

BeginSql alias "QSRA"
	SELECT SRA.RA_CIC, COUNT(*)
	FROM %table:SRA% SRA 
	WHERE ( SRA.RA_DEMISSA = ' '
	   OR ( SRA.RA_DEMISSA BETWEEN %exp:cDtIniPer% AND %exp:cDtFimPer%
      AND SRA.RA_RESCRAI <> '31' ) ) // transferencia de funcionarios
      AND SRA.RA_ADMISSA <= %exp:cDtFimPer%
	GROUP BY SRA.RA_CIC
	HAVING COUNT(*) > 1	
EndSql

QSRA->( DbGoTop())

If QSRA->(!Eof())
	lCalIRMV := .T.
	While QSRA->( !Eof() )
		aAdd( aIRMV, {QSRA->(RA_CIC) } )
		QSRA->( DbSkip() )
	Enddo
EndIf

QSRA->( dbCloseArea() )

RestArea( aArea )

Return( lCalIRMV )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³          º Autor ³ Ademar Fernandes   º Data ³  08/12/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Soma os valores ja pagos de Subsidio de Transporte para o  º±±
±±º          ³ funcionario posicionado.                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Roteiro de Calculo                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fSumTransp(lExcSem)
Local aRet	:= {}
Local nSoma	:= 0
Local cMes	:= SubStr(CANOMES,5,2)
Local cAno	:= SubStr(CANOMES,1,4)
Local cProcesso	:= CPROCESSO
Local cRoteiro	:= C__ROTEIRO

Local aVerbas		:= {}
Local aVerbasFunc	:= {}
Local aPerAberto	:= {}
Local aPerFechado	:= {}
Local nB

DEFAULT lExcSem := .T.

/*
//fRetPerComp( 	cMes		,;		//01 Obrigatorio - Mes para localizar as informacoes
				cAno		,;		//02 Obrigatorio - Ano para localizar as informacoes
				cRCHFil		,;		//03 Opcional - Filial a Pesquisar
				cProcesso	,;		//04 Obrigatorio - Filtro por Processo
				cRoteiro	,;		//05 Opcional - Filtro por Roteiro
				aPerAberto	,;		//06 Por Referencia - Array com os periodos Abertos
				aPerFechado, ;		//07 Por Referencia - Array com os periodos Fechados
				aPerTodos    ;		//08 Por Referencia - Array com os periodos Abertos e Fechados em Ordem Crescente
				 )
*/
fRetPerComp(cMes, cAno, NIL, cProcesso, cRoteiro, @aPerAberto, @aPerFechado)
aAdd(aRet, (Len(aPerAberto)+Len(aPerFechado)))

//# Exclui a Semana processada
If lExcSem
	nPos := aScan(aPerAberto, {|x| x[01]+x[02] == MV_PAR03+MV_PAR04})
	If nPos > 0
		aDel(aPerAberto, nPos)
		aSize(aPerAberto, Len(aPerAberto)-1)
	EndIf
EndIf

/*	
//RetornaVerbasFunc(	cFil		,;
						cMatricula	,;
						cCCusto		,;
						cRoteiro	,;
						aVerbas		,;
						aPerAberto	,;
						aPerFechado	 )
*/
aAdd(aVerbas, {FGETCODFOL("0052")})
aVerbasFunc := RetornaVerbasFunc(SRA->RA_FILIAL, SRA->RA_MAT, NIL, cRoteiro, aVerbas, aPerAberto, aPerFechado)

nSoma := 0
For nB := 1 to Len(aVerbasFunc)
	
	nSoma += aVerbasFunc[Nb,07]
	
Next nB
aAdd(aRet, nSoma)

Return(aRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ gpRCH2Filtro  º Autor ³ Kelly Soares    º Data ³ 16/11/09  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Filtro no RCH para periodos fechados.                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Consulta Padrao (SXB) - Argentina                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function gp2RCHFiltro()

cCond := '2'
Return gpRCHFiltro()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³NaoImpMsg º Autor ³ Ademar Fernandes   º Data ³ 13/11/2009  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Altera o variavel Static __lImpMsg para não permitir impri-º±±
±±º          ³ mir no Log de Calculo do Adto o funcionario como Nao Proc. º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Roteiro de Calculo                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NaoImpMsg()
__lImpMsg := .F.
Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ EQUTOTFUN     º Autor ³ Kelly Soares    º Data ³ 09/12/10  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Acumula total de dias trabalhados e de dependentes dos     º±±
±±º          ³ funcionarios selecionados para o calculo de PLR.           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ EQUADOR                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function EQUTOTFUN()

Local nDep   := 0
Local nDias  := 0
Local nTot   := 0
Local aAfast := {}      

aAdd(AFUNPLR,{SRA->RA_MAT,0,0})

If !Empty(PLRANO)
	DtIni := Max(CTOD("01/01/" + PLRANO),SRA->RA_ADMISSA)
	DtFim := If(!Empty(SRA->RA_DEMISSA),Min(CTOD("31/12/" + PLRANO),SRA->RA_DEMISSA),CTOD("31/12/" + PLRANO))
	nDias := DateDiffDay(DtIni,DtFim) + 1	    
	fBuscaAfast(DtIni,DtFim,@aAfast)
	If !Empty(aAfast)
		aEval(aAfast, {|x| If(x[15] = "1", nDias -= x[11], 0)})
	EndIf
	AFUNPLR[Len(AFUNPLR),2] := nDias
	PLRTOTDIA += nDias	
EndIf

If nDias > 0 .and. fPosReg("SRB",1,xFilial("SRB")+SRA->RA_MAT)
	While !(SRB->(EOF())) .and. SRB->(RB_FILIAL+RB_MAT) == SRA->(RA_FILIAL+RA_MAT)
		If SRB->RB_DEPPLR = '1' .OR. (SRB->RB_DEPPLR = '2' .and. Empty(SRB->RB_DTBAIXA))
			nDep++
		EndIf
		SRB->(DbSkip())
	Enddo
	nTot := nDias * nDep
	AFUNPLR[Len(AFUNPLR),3] := nTot
	PLRTOTDEP += nTot
EndIf

Return nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ FCHKFUNC      º Autor ³ Kelly Soares    º Data ³ 13/12/10  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Verificacoes iniciais do funcionario.                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Formula S_CHKFUNC do Equador                               º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FCHKFUNC(DtLimite,cNPag)

Local lRet := .T.  

If ( SRA->RA_ADMISSA > DtLimite ) .OR. ;
   ( !Empty(cNPag) .and. SRA->RA_TIPOPGT  = "M" ).OR. ;
   (  Empty(cNPag) .and. SRA->RA_TIPOPGT != "M" )

	lRet := .F.
	
EndIf

Return lRet

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gpSRYFiltro³Autor³Leandro Drumond           ³Data³26/03/2013³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Filtro da Consulta Padrao									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ExpC1 - Filtro de Tipo de roteiro (RY_TIPO) 				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gpSRYFiltro(cTipo, cTpRot)

	Local aArea		:= GetArea()
	Local cFiltro	:= ''
	Local cFilRot	:= ""
	Local lOpeSoc	:= SuperGetMv("MV_OPESOC", NIL, .F.)
	
	Private lGestPubl := fUsaGFP() //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

	cFiltro := "SRY->RY_FILIAL == '" + xFilial("SRY") + "' .AND. SRY->RY_TIPO <> '3' .AND. SRY->RY_TIPO <> '4' " //Ferias e rescisao deve ser calculada em rotina especifica

	cFilRCJ := Iif(Type("cFilRCJ") != "U", cFilRCJ, xFilial("RCJ", RCJ->RCJ_FILIAL))

	If FunName() == "GPEM016"  //Plano de Saude
		cFiltro += ".AND. SRY->RY_TIPO == 'C' "
	ElseIf FunName() == "GPEA001" //Plano de Saude
		cFiltro += ".AND. SRY->RY_TIPO == 'C' "
	ElseIf FunName() == "GPER330" //Demonst.Horas
		cFiltro += ".AND. SRY->RY_TIPO == '1' "
	ElseIf FunName() == "GPER520" //Seguro de Vida
		cFiltro += ".AND. (SRY->RY_TIPO == '1' .OR. SRY->RY_TIPO == '4')"
	ElseIf FunName() == "GP131CALC"
		cFiltro += ".AND. (SRY->RY_TIPO $ '8*D*E')"
	ElseIf FunName() $ "GP131CALCA*GP068FECH" 
		cFiltro += ".AND. (SRY->RY_TIPO = 'I')"
	ElseIf FunName() $ ("GPEM690|GPEM691") //Dissidio
		cFiltro += ".AND. SRY->RY_TIPO == '1' "
	EndIf

	If Type("cProcesso") <> "U" .and. !Empty(cProcesso)
		DbSelectArea("RCH")
		DbSetOrder(1)
		If(DbSeek(xFilial("RCH", cFilRCJ) + cProcesso))
			cFilRot := ""
			While RCH->(! Eof() .And. RCH_PROCES == cProcesso)
				If RCH_PERSEL = "1" .And. ! (RCH->RCH_ROTEIR $ cFilRot) .And. (!(FunName() $ "GPEM690|GPEM691") .Or. Empty(cFilRCJ) .Or. AllTrim(RCH->RCH_FILIAL) == AllTrim(cFilRCJ))
					cFilRot += RCH->RCH_ROTEIR + "*"
				EndIf
				RCH->(DbSkip())
			EndDo
			cFiltro += " .AND. (SRY->RY_CALCULO $ '" + cFilRot + "')"
		EndIf
	EndIf

	// Independente da rotina, nunca exibir roteiro de salario incorporado
	cFiltro += ".AND. !(SRY->RY_TIPO $ 'G*J')"

	If cPaisLoc == "BRA" .And. !lOpeSoc
		cFiltro += " .AND. SRY->RY_TIPO != 'O'"
	EndIf

	cFiltro := "@#" + cFiltro + "@#"

	RestArea(aArea)

Return ( cFiltro )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpm20Retorno³Autor³Leandro Drumond          ³Data³27/03/2013³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorno da Consulta Padrao									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ExpC1 - Filtro de Tipo de retorno			 				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpm20Retorno(cTipo)
Local aPerAtual := {}
Local cCpoRet 	:= ""

If fGetPerAtual( @aPerAtual, , MV_PAR01, MV_PAR02 )
	If cTipo == "PERIODO"
		cCpoRet := aPerAtual[1,1]
	Else
		cCpoRet := aPerAtual[1,2]
	EndIf
EndIf

Return (cCpoRet)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fChkInteg   ³Autor³Leandro Drumond          ³Data³04/12/2013³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se existem dados que nao foram integrados			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEM020								                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fChkInteg(cMsgLog,cFiltro)

Local aAreaRCH	:= RCH->( GetArea() )
Local aLogAux	:= {}
Local cQuery	:= ""
Local cAliasQRY	:= GetNextAlias()
Local cKeyRCH	:= xFilial("RCH") + cProcesso + GetRotExec() + __cPeriodCalc
Local cUltSemana:= __cNumPgCalc
Local lRet 		:= .T.

DbSelectArea("RCH")
DbSetOrder(4) //RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG
DbSeek( cKeyRCH  + __cNumPgCalc )

While !Eof() .and. RCH_FILIAL + RCH_PROCES + RCH_ROTEIR + RCH_PER == cKeyRCH
	If RCH_NUMPAG <>  __cNumPgCalc
		cUltSemana  := RCH_NUMPAG
	EndIf
	RCH->(DbSkip())
EndDo

cQuery := "SELECT RY_CALCULO, RY_DESC FROM " + RetSqlName("RCH") + " RCH "
cQuery += "INNER JOIN " + RetSqlName("SRY") + " SRY "
cQuery += "ON RCH.RCH_ROTEIR = SRY.RY_CALCULO AND "
cQuery += FWJoinFilial( "RCH", "SRY" )
If !Empty(cFilRCJ)
	cQuery += " INNER JOIN " + RetSqlName("RCJ") + " RCJ "
	cQuery += "ON RCH.RCH_PROCES = RCJ.RCJ_CODIGO AND "
	cQuery += FWJoinFilial( "RCH", "RCJ" )
EndIf
If !Empty(cFiltro)
	If !lDissidio //Quando a rotina é chamada pelo calculo dissidio, o filtro já vem montado corretamente.
		cFiltro := fPrepExpIn(If(!Empty(cFterAux), cFterAux, cFiltro))
	EndIf
	cQuery += " INNER JOIN " + RetSqlName("SRA") + " SRA "
	cQuery += "ON " + FWJoinFilial( "RCH", "SRA" ) + " AND "
	cQuery += GPEParSQL(cFiltro) 
EndIf
cQuery += " WHERE ((RCH_PROCES = '" + cProcesso + "' AND RCH_PER = '" + __cPeriodCalc + "' AND RCH_DTINTE = ''"
cQuery += " AND RY_INTEGRA = '1'" //Nao valida folha, adiantamento, 13o., Autonomo e PLR pois nao sao integraveis

If cUltSemana <> __cNumPgCalc //Se for a ultima semana, todos as demais semanas devem estar fechadas
	cQuery += " AND RCH_NUMPAG = '" + __cNumPgCalc + "'"
EndIf

cQuery += ")"
If !lDissidio
	cQuery += " OR (RCH_PROCES = '" + cProcesso + "' AND RCH_DTINTE = '' AND RY_TIPO = 'N' AND RCH_PERSEL = '1')"
EndIf
cQuery += ")"

If !Empty(cFilRCJ)
	cQuery += " AND RCJ_FILIAL = '" + cFilRCJ + "' AND RCJ.D_E_L_E_T_ = ' '"
EndIf

cQuery += " AND RCH.D_E_L_E_T_ = ' ' AND SRY.D_E_L_E_T_ = ' '"

cQuery := ChangeQuery(cQuery)
     
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQRY)

dbSelectArea(cAliasQRY)

cMsgLog := ""

While !((cAliasQRY)->(EOF()))
	lRet := .F.
	If (aScan(aLogAux, {|x| x[01]+x[02] == (cAliasQRY)->RY_CALCULO + (cAliasQRY)->RY_DESC })) == 0
		cMsgLog += (cAliasQRY)->RY_CALCULO + " - " + (cAliasQRY)->RY_DESC + CRLF
		aAdd(aLogAux, {(cAliasQRY)->RY_CALCULO , (cAliasQRY)->RY_DESC})
	EndIf
	(cAliasQRY)->(DbSkip())
EndDo

(cAliasQRY)->(dbCloseArea())

RestArea(aAreaRCH)

Return lRet


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fChkADI     ³Autor³Leandro Drumond          ³Data³04/12/2013³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se existem dados que nao foram integrados			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEM020								                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fChkADI(cMsgLog,cFiltro)
Local aArea		:= GetArea()
Local aLogAux	:= {}
Local cQuery	:= ""
Local cAliasQRY	:= GetNextAlias()
Local cKeyRCH	:= xFilial("RCH") + cProcesso + GetRotExec() + __cPeriodCalc
Local cUltSemana:= __cNumPgCalc
Local lRet 		:= .T.

DbSelectArea("RCH")
DbSetOrder(4) //RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG
DbSeek( cKeyRCH  + __cNumPgCalc )

While !Eof() .and. RCH_FILIAL + RCH_PROCES + RCH_ROTEIR + RCH_PER == cKeyRCH
	If RCH_NUMPAG <>  __cNumPgCalc
		cUltSemana  := RCH_NUMPAG
	EndIf
	RCH->(DbSkip())
EndDo

cQuery := "SELECT RY_CALCULO, RY_DESC FROM " + RetSqlName("RCH") + " RCH "
cQuery += "INNER JOIN " + RetSqlName("SRY") + " SRY "
cQuery += "ON RCH.RCH_ROTEIR = SRY.RY_CALCULO AND "
cQuery += FWJoinFilial( "RCH", "SRY" )
If !Empty(cFilRCJ)
	cQuery += " INNER JOIN " + RetSqlName("RCJ") + " RCJ "
	cQuery += "ON RCH.RCH_PROCES = RCJ.RCJ_CODIGO AND "
	cQuery += FWJoinFilial( "RCH", "RCJ" )
EndIf
If !Empty(cFiltro)
	If !lDissidio
		cFiltro := fPrepExpIn(If(!Empty(cFterAux), cFterAux, cFiltro))
	EndIf
	cQuery += " INNER JOIN " + RetSqlName("SRA") + " SRA "
	cQuery += "ON " + FWJoinFilial( "RCH", "SRA" ) + " AND "
	cQuery += GPEParSQL(cFiltro) 
EndIf
cQuery += " WHERE RCH_PROCES = '" + cProcesso + "' AND RCH_PER = '" + __cPeriodCalc + "' AND RCH_DTFECH = ''"
cQuery += " AND RY_TIPO = '2'" 

If cUltSemana <> __cNumPgCalc //Se for a ultima semana, todos as demais semanas devem estar fechadas
	cQuery += " AND RCH_NUMPAG = '" + __cNumPgCalc + "'"
EndIf

If !Empty(cFilRCJ)
	cQuery += " AND RCJ_FILIAL = '" + cFilRCJ + "' AND RCJ.D_E_L_E_T_ = ' '"
EndIf

cQuery += " AND RCH.D_E_L_E_T_ = ' ' AND SRY.D_E_L_E_T_ = ' '"

cQuery := ChangeQuery(cQuery)
     
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQRY)

dbSelectArea(cAliasQRY)

cMsgLog := ""

While !((cAliasQRY)->(EOF()))
	lRet := .F.
	If (aScan(aLogAux, {|x| x[01]+x[02] == (cAliasQRY)->RY_CALCULO + (cAliasQRY)->RY_DESC })) == 0
		cMsgLog += (cAliasQRY)->RY_CALCULO + " - " + (cAliasQRY)->RY_DESC + CRLF
		aAdd(aLogAux, {(cAliasQRY)->RY_CALCULO , (cAliasQRY)->RY_DESC})
	EndIf
	(cAliasQRY)->(DbSkip())
EndDo

(cAliasQRY)->(dbCloseArea())

RestArea(aArea)

Return lRet
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fTopFunRCJ  ³Autor³Leandro Drumond          ³Data³17/04/2014³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Filtra filiais da consulta padrao							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEM020								                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fTopFunRCJ(nTipo)
 
Local cTopFun := ""

If nTipo == 1
	If Type("cFilDe") <> "U" .and. !Empty(cFilDe) .and. Len(AllTrim(cFilDe)) == Len(AllTrim(xFilial("RCJ")))
		cTopFun := SubStr(cFilDe + Space(FWGETTAMFILIAL),FWGETTAMFILIAL)
	Else
		cTopFun := Space(FWGETTAMFILIAL)
	EndIf
Else
	If Type("cFilAte") <> "U" .and. !Empty(cFilAte) .and. Len(AllTrim(cFilAte)) == Len(AllTrim(xFilial("RCJ")))
		cTopFun := SubStr(cFilAte + Replicate("Z",FWGETTAMFILIAL),FWGETTAMFILIAL)
	Else
		cTopFun := Replicate("Z",FWGETTAMFILIAL)
	EndIf
EndIf
lF3Proc		:= .T.
cFilRCJ := ""

Return cTopFun

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fLimpaSX1   ³Autor³Leandro Drumond          ³Data³17/04/2014³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Limpa dados gravados na consulta padrao						³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEM020								                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fLimpaSX1()

//Carrega o pergunte
Pergunte("GPEM020",.F.)
//Zera os parametros
SetMVValue("GPEM020","MV_PAR01","")
SetMVValue("GPEM020","MV_PAR02","")
SetMVValue("GPEM020","MV_PAR03","")
SetMVValue("GPEM020","MV_PAR04","")
//Grava as alteracoes
Pergunte("GPEM020",.F.)

Return Nil

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fSX1Work    ³Autor³Leandro Drumond          ³Data³01/06/2014³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Carrega SX1 com dados dos parametros WF						³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEM020								                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fSX1Work(cProcAux,cRotAux)
	Local aPerAtual := {}
	Local cPer
	Local cSem

	//Carrega o pergunte
	Pergunte("GPEM020",.F.)
	//Zera os parametros
	SetMVValue("GPEM020","MV_PAR01",cProcAux)
	SetMVValue("GPEM020","MV_PAR02",cRotAux)

	If SuperGetMv( "MV_SIGAGFP",.F.,"1" ) == "2" .And. Type("cPeriodo") <> "U" .And. Type("cSemana") <> "U"
		cPer := cPeriodo
		cSem := cSemana
	EndIf

	If fGetPerAtual( @aPerAtual, , cProcAux, cRotAux,,,cPer,cSem )
		SetMVValue("GPEM020","MV_PAR03",aPerAtual[1,1])
		SetMVValue("GPEM020","MV_PAR04",aPerAtual[1,2])
	EndIf

	//Grava as alteracoes
	Pergunte("GPEM020",.F.)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp020Fields ³ Autor ³ Leandro Drumond       ³ Data ³ 17/07/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consulta especifica do cadastro de periodos                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Gp020Fields()		                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Gp020Fields()
Local aArea		:= GetArea()
Local aObjCoords:= {}
Local aAdvSize	:= {}
Local aInfoAdvSize	:= {}
Local aObjSize 	:= {}
Local cAliasQry	:= "QRCH"
Local cJoin		:= ""
Local cJoinRCJ	:= ""
Local cWhere	:= ""
Local cTipo		:= ""
Local lOK     	:= .F.
Local lOpeSoc	:= SuperGetMv("MV_OPESOC", NIL, .F.) 
Local lPerComp	:= Empty(xFilial("RCH"))
Local nPosLbxA	:= 0.00
Local oDlg		:= NIL
Local oLbxA		:= NIL
Local nOpca		:= 0

Local bSet15 := {|| NIL}
Local bSet24 := {|| NIL}     

aLbxA := {}

VAR_IXB := {"","",""}

If FunName() == "GPEM016"  //Plano de Saude
	cTipo := "'C'"
ElseIf FunName() == "GPEA001" //Plano de Saude
	cTipo := "'C'"
ElseIf FunName() == "GPER330" //Demonst.Horas
	cTipo := "'1'"
ElseIf FunName() == "GPER520" //Seguro de Vida
	cTipo := "'1','4'"
ElseIf FunName() == "GP131CALC"
	cTipo := "'8','D','E'"
ElseIf FunName() $ "GP131CALCA*GP068FECH" 
	cTipo := "'I'"
ElseIf FunName() $ "GPEM690|GPEM691" //Dissidio
	cTipo := "'1'"
EndIf

cJoin := "% "
cJoin += FWJoinFilial( "RCH", "SRY" ) + " AND "
cJoin += " RCH.RCH_ROTEIR 	  = SRY.RY_CALCULO "
cJoin += "%"

cJoinRCJ := "% "
cJoinRCJ += FWJoinFilial( "RCH", "RCJ" ) + " "
cJoinRCJ += "%"

cWhere := "%"
cWhere += " ( RCH.RCH_PERSEL = '1') AND "
cWhere += " RCH.RCH_PROCES = '" + cProcesso + "' AND "
cWhere += " SRY.RY_TIPO NOT IN ('3','4','G','J') "

If cPaisLoc == "BRA" .And. !lOpeSoc
	cWhere += " AND SRY.RY_TIPO NOT IN ('O')"
EndIf

If !Empty(cTipo)
	cWhere += " AND SRY.RY_TIPO IN (" + cTipo + ") "
EndIf

If Type( "cFilRCJ" ) <> "U" .and. !Empty(cFilRCJ)
	cWhere += " AND RCJ.RCJ_FILIAL = '" + cFilRCJ + "' "
EndIf

cWhere += "%"

BeginSql alias cAliasQry
	SELECT 		RCH_FILIAL, RCH_ROTEIR, RCH_PER, RCH_NUMPAG, RY_DESC
	FROM 		%table:RCH% RCH
	INNER JOIN  %table:SRY% SRY
	ON 			%exp:cJoin%
	INNER JOIN 	%table:RCJ% RCJ
	ON			%exp:cJoinRCJ%
	WHERE 		%exp:cWhere% AND
				RCH.%NotDel% AND
				RCJ.%NotDel% AND
				SRY.%NotDel%
	ORDER BY RCH_FILIAL, RCH_PROCES, RCH_PER				
EndSql

While (cAliasQry)->( !Eof() )
	If lPerComp
		If AsCAN(aLbxA,{ |X| X[1] + X[2] + X[3] + X[4] = RCH_ROTEIR + RY_DESC + RCH_PER + RCH_NUMPAG}) == 0
			(cAliasQry)->( aAdd( aLbxA, { RCH_ROTEIR, RY_DESC, RCH_PER, RCH_NUMPAG } ) )
		Endif
	Else
		If AsCAN(aLbxA,{ |X| X[1] + X[2] + X[3] + X[4] + x[5] = RCH_FILIAL+ RCH_ROTEIR + RY_DESC + RCH_PER + RCH_NUMPAG}) == 0
			(cAliasQry)->( aAdd( aLbxA, { RCH_FILIAL, RCH_ROTEIR, RY_DESC, RCH_PER, RCH_NUMPAG } ))
		Endif
	Endif
	(cAliasQry)->( dbSkip() )
EndDo

If Empty(aLbxA)
	If lPerComp
		aAdd( aLbxA , {'','','','','' } )
	Else
		aAdd( aLbxA , {'','','','','','' } )
	EndIf
EndIf

( cAliasQry )->( dbCloseArea() )

aAdvSize		:= MsAdvSize( , .T., 390)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 15 , 5 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize := MsObjSize( aInfoAdvSize , aObjCoords )

//Abaixo utilizamos o tamanho da janela como na versão 10, pois cada objeto tem seu posicionamento específico, 
//o cada qual eh realocado conforme a resolução da tela do usuário 
DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD 
DEFINE MSDIALOG oDlg FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi(STR0029) PIXEL		// "Selecione o periodo de destino"
    
    If lPerComp
		@ aObjSize[1,1], aObjSize[1,2] LISTBOX oLbxA FIELDS HEADER GetSx3Cache("RCH_ROTEIR", "X3_TITULO"), GetSx3Cache("RY_DESC", "X3_TITULO"),;
		GetSx3Cache("RCH_PER", "X3_TITULO"), GetSx3Cache("RCH_NUMPAG", "X3_TITULO") SIZE 290,130;	
		OF oDlg PIXEL ON DBLCLICK ( lOk := .T., nPosLbxA:=oLbxA:nAt,oDlg:End() )
	Else
		@ aObjSize[1,1], aObjSize[1,2] LISTBOX oLbxA FIELDS HEADER GetSx3Cache("RCH_FILIAL", "X3_TITULO"),GetSx3Cache("RCH_ROTEIR", "X3_TITULO"), GetSx3Cache("RY_DESC", "X3_TITULO"),;
		GetSx3Cache("RCH_PER", "X3_TITULO"), GetSx3Cache("RCH_NUMPAG", "X3_TITULO") SIZE 290,130;	
		OF oDlg PIXEL ON DBLCLICK ( lOk := .T., nPosLbxA:=oLbxA:nAt,oDlg:End() )
	EndIf
	
	oLbxA:SetArray(aLbxA)
	If lPerComp
		oLbxA:bLine := { || {aLbxA[oLbxA:nAt,1],aLbxA[oLbxA:nAt,2],aLbxA[oLbxA:nAt,3],aLbxA[oLbxA:nAt,4]}}
	Else
		oLbxA:bLine := { || {aLbxA[oLbxA:nAt,1],aLbxA[oLbxA:nAt,2],aLbxA[oLbxA:nAt,3],aLbxA[oLbxA:nAt,4],aLbxA[oLbxA:nAt,5]}}
	EndIf
	
	bSet15 := { || nOpca := 1, lOk := .T., nPosLbxA:=oLbxA:nAt,oDlg:End()}
	bSet24 := { || nOpca := 0, lOk := .F., oDlg:End() }
	
ACTIVATE MSDIALOG oDlg CENTERED ON INIT (EnchoiceBar(oDlg, bSet15, bSet24))

If ( lOk )
	If lPerComp
		VAR_IXB[1]	:= aLbxA[nPosLbxA,1]
		VAR_IXB[2] 	:= aLbxA[nPosLbxA,3]
		VAR_IXB[3] 	:= aLbxA[nPosLbxA,4]
	Else
		VAR_IXB[1]	:= aLbxA[nPosLbxA,2]
		VAR_IXB[2] 	:= aLbxA[nPosLbxA,4]
		VAR_IXB[3] 	:= aLbxA[nPosLbxA,5]
	EndIf
	lVldCons   	:= .F.
	
	cJoin := "% "
	cJoin += FWJoinFilial( "RCH", "SRA" ) + " AND "
	cJoin += " RCH.RCH_FILIAL = '" + aLbxA[nPosLbxA,1] + "'"
	cJoin += "%"

	BeginSql alias cAliasQry
		SELECT 		DISTINCT RA_FILIAL
		FROM 		%table:SRA% SRA
		INNER JOIN  %table:RCH% RCH
		ON 			%exp:cJoin%
		WHERE 		RCH.%NotDel% AND
					SRA.%NotDel%
		ORDER BY RA_FILIAL				
	EndSql
	
	__cFilPer := ""
	
	While (cAliasQry)->( !Eof() )
		If !Empty(__cFilPer)
			__cFilPer += "*/"
		EndIf
		__cFilPer +=  (cAliasQry)->RA_FILIAL 
		(cAliasQry)->( dbSkip() )
	EndDo
	( cAliasQry )->( dbCloseArea() )
	If !Empty(__cFilPer)
		__cFilPer := 'SRA->RA_FILIAL $ ("' + __cFilPer + '")'
	EndIf
EndIf
	
RestArea( aArea )

Return lOk

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³LoadFilPer  ³ Autor ³ Leandro Drumond       ³ Data ³ 12/09/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Altera Filtro se periodos forem exclusivos                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LoadFilPer()			                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function LoadFilPer(cFiltro)

Local nPos		:= 0
Local cAuxIni	:= ""
Local cAuxFim	:= ""
Local lContinua	:= .T.

If Empty(cFiltro)
	cFiltro := __cFilPer
Else
	While lContinua
		nPos := At("(SRA->RA_FILIAL",cFiltro)
		If nPos == 0
			nPos := At("SRA->RA_FILIAL",cFiltro)
		EndIf
		If nPos > 0
			If nPos > 1
				cAuxIni := SubStr(cFiltro,1,nPos-1)
				cAuxFim := SubStr(cFiltro,nPos)
				nPos := At(".",cAuxFim)
				If nPos > 0
					cAuxFim := SubStr(cAuxFim,nPos+1)
					cAuxFim := SubStr(cAuxFim,At(".",cAuxFim)+1)
				Else
					cAuxFim := ""
				EndIf
				cFiltro := cAuxIni + cAuxFim
			Else
				nPos := At(".",cFiltro)
				cAuxIni := ""
				If nPos > 0
					cAuxIni := SubStr(cFiltro,nPos+1)
					cAuxIni := SubStr(cAuxIni,At(".",cAuxIni)+1)
				EndIf
				cFiltro := cAuxIni 
			EndIf
		Else
			lContinua := .F.
		EndIf
	EndDo
	If Empty(cFiltro)
		cFiltro += " (" + __cFilPer + ")"
	Else
		cFiltro += " .AND. (" + __cFilPer + ")"
	EndIf
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fValidPercet³ Autor ³Cíceror Alves³ Data ³ 23/03/2015	      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida se o Parametro MV_PAR02 é menor que 100			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fValidPercet(PAR02)                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³PAR02, numerico, valor para ser validado                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fValidPercent(PAR02)
	Local lRetorno := .F.
	
	If PAR02 <= 100 
		lRetorno := .T.
	Else
		Help(" ",1,"PERCENT")	
	EndIf

Return lRetorno

/*/{Protheus.doc}fInclFP
Inclui filtro padrão na rotina de Cálculo
@author Gabriel de Souza Almeida
@since 12/10/2015
@version P12
/*/
Function fInclFP()
	Local lRet 			:= .T.
	Local lTemRE7 		:= AliasInDic("RE7")	
	
	Local cKeyFilter 	:= "GPEPADRAO0"
	Local cDesc 		:= 'FILTRO PADRAO GPE'
	Local cFiltro 		:= '(SRA->RA_FILIAL >= "        ").AND.(SRA->RA_FILIAL <= "ZZZZZZZZ").AND.(SRA->RA_CC >= "         ").AND.(SRA->RA_CC <= "ZZZZZZZZZ").AND.(SRA->RA_MAT >= "      ").AND.(SRA->RA_MAT <= "999999").AND.(SRA->RA_CATFUNC $ ( "A*/C*/D*/E*/G*/H*/I*/J*/M*/P*/S*/T" ))'
	Local cAliasFilter 	:= ""
	Local cUser 		:= RetCodUsr()
	Local cGrp 			:= IIf(Len(UsrRetGrp()) > 0,UsrRetGrp()[1],"")
	Local cPrefix		:= "FILTRO_"

	Private lGestPubl  	:= IF(ExistFunc("fUsaGFP"),fUsaGFP(),.f.)	//Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

	If lTemRE7
		cPrefix			:= "RE7_"
	EndIf

	OpenFileFilter( @cAliasFilter )
	
	( cAliasFilter )->( DbSetOrder( RetOrdFileFilter( "CRIT_SEL2" ) ) )
	
	IF !lGestPubl
		If !( cAliasFilter )->( MsSeek( cUser + cKeyFilter + "SRA       " + "GPEM020   " + cGrp ) )
			PutFilterFile(cKeyFilter, cDesc, cFiltro, cUser, "SRA", FunName(), cGrp)
		EndIf
	Else
		PutFilterFile(cKeyFilter, cDesc, cFiltro, cUser, "SRA", FunName(), cGrp, "")
	Endif
Return lRet


/*/{Protheus.doc}fPrepExpIn
Prepara expressão IN para transformar em SQL
@author Gabriel de Souza Almeida
@since 18/11/2015
@version P12
/*/
Function fPrepExpIn(cFiltro)
	Local cFiltRet  := ""
	Local cFiltAux  := ""
	Local cFiltAux2 := ""
	Local cAux      := ""
	Local nAndx     := 0
	Local nOrx      := 0
	Local nPos      := 1
	Local nPos2     := 1
	Local nAux      := 0
	
	cFiltro := StrTran(cFiltro ,"*/" ,"','")
	
	While nPos2 > 0
		nAndx := AT('.AND.',Upper(cFiltro))
		nOrx := AT('.OR.',Upper(cFiltro))
		nPos := IIf(nAndx == 0, nOrx, IIf(nOrx == 0,nAndx,Min(nAndx,nOrx)))
		nAux := IIf(nPos == nAndx,nPos+4,nPos+3)
		cFiltAux := SubStr(cFiltro,1, nAux)
		
		If AT('$',cFiltAux) > 0
			cFiltAux :=StrTran(cFiltAux			,"->"   ,".")
			cFiltAux := StrTran(cFiltAux ,"-" ,"','")
			cFiltAux2 := AllTrim(SubStr(cFiltAux,AT('$',cFiltAux)+1))
			nAt := AT(')',SubStr(cFiltAux2,2))
			If nAt == 0
				nAt := AT('"',SubStr(cFiltAux2,2))
			EndIf
			cFiltAux2 := SubStr(cFiltAux2,1,nAt+1)
			cAux := cFiltAux2
			cAux := StrTran(cAux ,")" ,"")
			cAux := StrTran(cAux ,"(" ,"")
			cFiltAux2 := StrTran(cFiltAux2 ,'"' ,'')
			cFiltAux2 := StrTran(cFiltAux2 ,"(" ,"")
			cFiltAux2 := StrTran(cFiltAux2 ,")" ,"")
			cFiltAux2 := If(AT("SRA.RA",cFiltAux2)>0,"(" + AllTrim(cFiltAux2) + ")","('" + AllTrim(cFiltAux2) + "')")
			cFiltAux := StrTran(cFiltAux , cAux, cFiltAux2)
			If "((" $ cFiltAux
				cFiltAux := StrTran(cFiltAux ,"((" ,"(")
				cFiltAux := StrTran(cFiltAux ,"))" ,")")
			ElseIf "(((" $ cFiltAux
				cFiltAux := StrTran(cFiltAux ,"(((" ,"((")
				cFiltAux := StrTran(cFiltAux ,")))" ,"))")
			EndIf
		EndIf
		
		cFiltRet += cFiltAux
		cFiltro := SubStr(cFiltro, nAux+1)
		nPos2 := Max(AT('.AND.',Upper(cFiltro)),AT('.OR.',Upper(cFiltro)))
	EndDo
	
	If AT('$',cFiltro) > 0
		cFiltAux2 := AllTrim(SubStr(cFiltro,AT('$',cFiltro)+1))
		cFiltAux2 := SubStr(cFiltAux2,1,AT(')',SubStr(cFiltAux2,2))+1)
		cAux := cFiltAux2
		cAux := StrTran(cAux ,")" ,"")
		cAux := StrTran(cAux ,"(" ,"")
		cFiltAux2 := StrTran(cFiltAux2 ,'"' ,'')
		cFiltAux2 := StrTran(cFiltAux2 ,"(" ,"")
		cFiltAux2 := StrTran(cFiltAux2 ,")" ,"")
		cFiltAux2 := If(AT("->",cFiltAux2)>0,"(" + AllTrim(cFiltAux2) + ")","('" + AllTrim(cFiltAux2) + "')")
		cFiltro := StrTran(cFiltro , cAux, cFiltAux2)
		If "((" $ cFiltro
			cFiltro := StrTran(cFiltro ,"((" ,"(")
			cFiltro := StrTran(cFiltro ,"))" ,")")
		ElseIf "(((" $ cFiltro
			cFiltro := StrTran(cFiltro ,"(((" ,"((")
			cFiltro := StrTran(cFiltro ,")))" ,"))")
		EndIf
	EndIf
	
	cFiltRet += cFiltro
	
Return cFiltRet
Function fValidPBen(dData)
Local lRet	:= Anomes(dData) ==__cPeriodCalc
If !lRet
	MsgInfo( OemToAnsi(STR0085) , OemToAnsi(STR0005)) //Data inválida!: ##Atencao!
EndIf
Return lRet

/*/{Protheus.doc} ValidCPO
Busca por um registro em uma tabela, retornando se existe ou não, sem exibir mensgens
Criada originalmente para validar o centro de custo do funcionário durante os cálculos
@author cicero.pereira
@type function
@since 14/07/2017
@version 12.1.16
@param cTable, characters, Tabela para busca
@param nOrder, numeric, Indice utilizado na busca
@param cKey, characters, Chave para busca
@example
ValidCPO("CTT", "D MG 01 " + "000000001")
/*/
Static Function ValidCPO(cTable, nOrder, cKey)

	Local lRet	:= .F.
	Local aArea	:= GetArea()

	dbSelectArea(cTable)
	dbSetOrder(nOrder)

	lRet := (cTable)->(dbSeek(cKey))

	RestArea(aArea)

Return lRet

Function M020FilFun(lGrid,nRecCount,cTabMestra,cProcesso,cFilterRot,cFilRCJ,cRoteiro,cFterAux,cMsgLog,aProcessoLog,aIndex,lCalIRMV,aIRMV,aHdrMestre)
Local aPerAtual 	:= {}
Local aFields 		:= {}
Local cFilter		:= ""
Local cFilAux		:= ""
Local cFilCat9		:= "%%"
Local cCalcAut		:= ""
Local cCpoProcesso 	:= ""
Local cFiltAuxRA	:= ""
Local lChkProcesso 	:= ChkSx9Proc( cTabMestra, @cCpoProcesso )
Local lAutMovSRC	:= GetMvRH("MV_AUTOSRC",, .F. ) // Calculo autonomo com movimento
Local aRecsBarG		:= {}
Local aExprFiltro
Local aNewExprFiltro
Local aTitleFilter 	:= {}
Local aItensFilter
Local cExprFiltro
Local cExprFilAux
Local nField		:= 0
Local nLoops
Local nLoop
Local nLoopL 	    := 0
Local nRecGrid 		:= 0
Local lFiltVEX 		:= .F.
Local lNovoCalc 	:= NovoCalcBEN()
Local lRetBreak		:= .F.

Private lGestPubl	:= If(ExistFunc("fUsaGFP"),fUsaGFP(),.f.)

If Type( "lDissidio" ) == "U"
	lDissidio := .F.
EndIf

If Type( "P_FILTVEX" ) == "U"
	P_FILTVEX := .F.
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Posiciono no Inicio do Arquivo                               ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
( cTabMestra )->( dbGotop() )

If lChkProcesso .And. !lDissidio
	cFilter		+= IF(!Empty(cFilter), " .and. " + cCpoProcesso + " = '" + cProcesso + "'", cCpoProcesso + " = '" + cProcesso + "'" )
	cFiltAuxRA	:= cFilter
EndIf
cFilter		+= IF(!Empty(cFilter), If(Empty(cFilterRot),""," .and. ") + cFilterRot , cFilterRot )
If !Empty(cFterAux)
	cFiltAuxRA	+= IF(!Empty(cFiltAuxRA), " .and. " + cFterAux , cFterAux )
Else
	cFiltAuxRA 	:= cFilter
EndIf

If !Empty(cFilRCJ)
	cFilter += " .and. RA_FILIAL >= '" + SubStr(AllTrim(cFilRCJ)+Space(FWGETTAMFILIAL),1,FWGETTAMFILIAL) + "'"
	cFilter += " .and. RA_FILIAL <= '" + SubStr(AllTrim(cFilRCJ)+Replicate("Z",FWGETTAMFILIAL),1,FWGETTAMFILIAL) + "'"
EndIf

If lWorkFlow
	If !fGetPerAtual( @aPerAtual, , cProcesso, cRoteiro )
		AutoGrLog(OemToAnsi(STR0066))
		AAdd( aLogExt,OemToAnsi(STR0066) )
		Return(0)
	Else
		dPerFim   := aPerAtual[1][7]
		dDtPago   := aPerAtual[1][11]
	EndIf
EndIf

If cRoteiro $ (fGetCalcRot('5')+ "*" + fGetCalcRot('6'))
	cFilter		+= If(!Empty(cFilter), " .and. (DTOS(SRA->RA_ADMISSA) <= '" + dToS(dPerFim) + "')", "(DTOS(SRA->RA_ADMISSA <= '" + dToS(dPerFim) + "')" )
EndIf

If cFiltAuxRA $ cFilter
	cFiltAuxRA 	:= cFilter
EndIf

cAxTabMestra := cTabMestra

If cRoteiro $ (fGetCalcRot('1')+ "*" + fGetCalcRot('9'))
	lRetBreak := .F.
	If !fChkInteg(@cMsgLog,If(!Empty(cFterAux), cFterAux, cFilter))
		aAdd( aProcessoLog , "")
		aAdd( aProcessoLog , OemToAnsi(STR0068) ) //"Existem roteiro que nao foram integrados com a folha. Execute a integração antes do calculo"
		aAdd( aProcessoLog , cMsgLog )
		lRetBreak := .T.
	EndIf
	If !fChkAdi(@cMsgLog,cFilter)
		aAdd( aProcessoLog , "")
		aAdd( aProcessoLog , OemToAnsi(STR0072) ) //"Roteiro de Adiantamento desse periodo ainda não foi fechado, favor verificar!"
		aAdd( aProcessoLog , cMsgLog )
		lRetBreak := .T.
	EndIf
	
	If lRetBreak
		Return 0
	EndIf
EndIf	

If ! lNovoCalc .And.  cRoteiro $ (fGetCalcRot('E') + "*" + fGetCalcRot('D') + "*" + fGetCalcRot('8'))
	aAdd( aProcessoLog , "")
	aAdd( aProcessoLog , OemToAnsi(STR0110) ) //"A partir da release 12.1.27 esta versão do cálculo de benefícios (VT / VR / VA) será descontinuada, consulte o TDN : http://tdn.totvs.com/x/ikyZDg "
	aAdd( aProcessoLog , cMsgLog )
EndIf

If !lDissidio
	cFilter :=  StrTran( cFilter, "','", "*" )
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Tratamento para existencia de Multiplos Vinculos             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/	
If cTabMestra == "SRA"

	cAxTabMestra := GetNextAlias()
	lFiltVEX 	 := P_FILTVEX .And. cRoteiro == fGetCalcRot('K')
	
	If (lAutMovSRC .And. cRoteiro == fGetCalcRot('9')) .Or. lFiltVEX
		cCalcAut := "% "
		cCalcAut += FWJoinFilial( "SRA", "RGB" ) + " AND "
		cCalcAut += " SRA.RA_MAT = RGB.RGB_MAT "
		If lFiltVEX
			cCalcAut += "AND RGB.RGB_ROTEIR = '" + fGetCalcRot('K') + "'"
		EndIf
		cCalcAut += "%"

		If !Empty(cFilter)
			If !lDissidio
				cFilAux := GPEParSQL(fPrepExpIn(If(!Empty(cFiltAuxRA), cFiltAuxRA, cFilter)))
			Else
				cFilAux := GPEParSQL(fPrepExpIn(cFilter))
			EndIf
			cFilAux := "%" + cFilAux + "%"
			BeginSql alias cAxTabMestra
				SELECT RA_FILIAL, RA_MAT, RA_CC, RA_TPCONTR, RA_ADMISSA, RA_DEMISSA, RA_CATFUNC
				FROM %table:SRA% SRA 
				INNER JOIN %table:RGB% RGB
				ON %exp:cCalcAut% AND RGB.%NotDel%
				WHERE %Exp:cFilAux%
				AND SRA.%NotDel%
				ORDER BY RA_FILIAL, RA_MAT
			EndSql		
		Else
			BeginSql alias cAxTabMestra
				SELECT RA_FILIAL, RA_MAT, RA_CC, RA_TPCONTR, RA_ADMISSA, RA_DEMISSA, RA_CATFUNC
				FROM %table:SRA% SRA 
				INNER JOIN %table:RGB% RGB
				ON %exp:cCalcAut% AND RGB.%NotDel%
				WHERE SRA.%NotDel%
				ORDER BY RA_FILIAL, RA_MAT
			EndSql
		EndIf
    Else	
		If cRoteiro == fGetCalcRot('O')
			cFilCat9 := "%AND SRA.RA_CATFUNC = '9'%"
		EndIf
		If !Empty(cFilter)
			If !lDissidio
				cFilAux := GPEParSQL(fPrepExpIn(If(!Empty(cFiltAuxRA), cFiltAuxRA, cFilter)))
			Else
				cFilAux := cFilter := GPEParSQL(cFilter)
			EndIf
			cFilAux := "%" + cFilAux + "%"
			BeginSql alias cAxTabMestra
				SELECT RA_FILIAL, RA_MAT, RA_CC, RA_TPCONTR, RA_ADMISSA, RA_DEMISSA, RA_CATFUNC
				FROM %table:SRA% SRA 
				WHERE %Exp:cFilAux%
				AND SRA.%NotDel% %exp:cFilCat9%
				ORDER BY RA_FILIAL, RA_MAT
			EndSql		
		Else
			BeginSql alias cAxTabMestra
				SELECT RA_FILIAL, RA_MAT, RA_CC, RA_TPCONTR, RA_ADMISSA, RA_DEMISSA, RA_CATFUNC
				FROM %table:SRA% SRA 
				WHERE SRA.%NotDel%
				ORDER BY RA_FILIAL, RA_MAT
			EndSql
		EndIf
	EndIf
	aFields 	:= SRA->( dbStruct() )
	For nField := 1 To Len( aFields )
		If !( aFields[ nField , 02 ] == "C" )
			TcSetField(cAxTabMestra, aFields[nField,01], aFields[nField,02], aFields[nField,03], aFields[nField,04])
		EndIf
	Next nField	

	If !(cPaisLoc $ "MEX|COL")
		lCalIRMV := fChkIRMV(@aIRMV)
	EndIf
	
	// Obtenho o número de Registros a serem processados
	If !Empty(cFilter)
		If !lDissidio
			cFilAux := GPEParSQL(fPrepExpIn(If(!Empty(cFiltAuxRA), cFiltAuxRA, cFilter)))
		Else
			cFilAux := GPEParSQL(fPrepExpIn(cFilter))
		EndIf
		cFilAux := StrTran(cFilAux, "SRA", "CNTSRA")
		If cRoteiro == fGetCalcRot('O')
			cFilAux += " AND RA_CATFUNC = '9'"
		EndIf
		cFilAux := "%" + cFilAux + "%"
		If Empty(cCalcAut)
			BeginSql alias "CNTSRA"
				SELECT COUNT(*) AS CONTADOR
				FROM %table:SRA% CNTSRA 
				WHERE %Exp:cFilAux%
			EndSql
		Else
			cCalcAut:= StrTran(cCalcAut,"SRA","CNTSRA")
			BeginSql alias "CNTSRA"
				SELECT COUNT(*) CONTADOR
				FROM ( SELECT DISTINCT RA_FILIAL, RA_MAT 
				FROM %table:SRA% CNTSRA 
				INNER JOIN %table:RGB% RGB
				ON %exp:cCalcAut% AND RGB.%NotDel%
				WHERE %Exp:cFilAux% ) FUNCIONARIO
			EndSql
		EndIf		
	Else
		If Empty(cCalcAut)
			BeginSql alias "CNTSRA"
				SELECT COUNT(*) AS CONTADOR
				FROM %table:SRA% CNTSRA
			EndSql
		Else
			cCalcAut:= StrTran(cCalcAut,"SRA","CNTSRA")
			BeginSql alias "CNTSRA"
				SELECT COUNT(*) CONTADOR 
				FROM ( SELECT DISTINCT RA_FILIAL, RA_MAT 
				FROM %table:SRA% CNTSRA
				INNER JOIN %table:RGB% RGB
				ON %exp:cCalcAut% AND RGB.%NotDel%) FUNCIONARIO
			EndSql
		EndIf
	EndIf
	nRecCount := CNTSRA->(CONTADOR)
	CNTSRA->( dbCloseArea() )
Else
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Aplicar o filtro na tabela                                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	bFiltraBrw 	:= { || FilBrowse( cAxTabMestra, @aIndex , @cFilter ) }
	Eval( bFiltraBrw )

	IF !Empty( cFilter )
		CREATE SCOPE aRecsBarG FOR __ExecMacro( cFilter )
		nRecCount := ( cAxTabMestra )->( ScopeCount( aRecsBarG ) )
	Else
		nRecCount := ( cAxTabMestra )->( RecCount() )
	EndIf
EndIf

DbSelectArea(cAxTabMestra)

If nRecCount == 0
	cMsgLog += OemToAnsi( STR0057 ) + CRLF // "Nenhum Funcionário Processado nessa Requisição"
	aAdd( aProcessoLog , "")
	aAdd( aProcessoLog , "")
	aAdd( aProcessoLog , cMsgLog )
Else
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Obtem a Estrutura do Arquivo Mestre						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aHdrMestre  := GdMontaHeader(NIL,NIL,NIL,cTabMestra,NIL,.T.,.T.,.F.,.F.,.F.,.F.,.F.)

EndIf

If  (nMinGrid > 0) .and. lGrid

	cFilAux := If(!lDissidio, GPEParSQL(fPrepExpIn(If(!Empty(cFiltAuxRA), cFiltAuxRA, cFilter))),GPEParSQL(fPrepExpIn(cFilter)))
	cFilAux := StrTran(cFilAux, "SRA", "CNTGRID")
	cFilAux += If(cRoteiro == fGetCalcRot('O')," AND RA_CATFUNC = '9'","")
	cFilAux += " AND ( RA_DEMISSA = ' ' OR RA_DEMISSA >= '" + __cPeriodCalc + "01" + "' )"
	cFilAux := "%" + cFilAux + "%"
	If Empty(cCalcAut)
		BeginSql alias "CNTGRID"
			SELECT COUNT(*) AS CONTADOR
			FROM %table:SRA% CNTGRID 
			WHERE %Exp:cFilAux%
		EndSql
	Else
		cCalcAut:= StrTran(cCalcAut,"CNTSRA","CNTGRID")
		BeginSql alias "CNTGRID"
			SELECT COUNT(*) CONTADOR
			FROM ( SELECT DISTINCT RA_FILIAL, RA_MAT 
			FROM %table:SRA% CNTGRID 
			INNER JOIN %table:RGB% RGB
			ON %exp:cCalcAut% AND RGB.%NotDel%
			WHERE %Exp:cFilAux% ) FUNCIONARIO
		EndSql
	EndIf

	nRecGrid := CNTGRID->(CONTADOR)	
	
	CNTGRID->( dbCloseArea() )

	If ( nRecGrid < nMinGrid )
		lGrid := .F.
	EndIf
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Adiciona Expressao de Filtro utilizada no Log de Processamento³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF !Empty( cFilter )
	aTitleFilter := {}
	aAdd( aTitleFilter , STR0033 )	//"Expressao de Filtro Utilizada no Calculo:"
	cExprFiltro 	:= Upper( AllTrim( cFilter ) )
	cExprFiltro 	:= StrTran( cExprFiltro , ".AND."	, "@__CCONCAT__@" )
	cExprFiltro 	:= StrTran( cExprFiltro , ".OR."	, "@__CCONCAT__@" )
	aExprFiltro 	:= StrToArray( cExprFiltro , "@__CCONCAT__@" )
	cExprFiltro 	:= Upper( AllTrim( cFilter ) )
	aNewExprFiltro  := {}
	aAdd( aNewExprFiltro,  "Roteiro = "+ "'" + AllTrim(cRoteiro) + "'"  )
	aAdd( aNewExprFiltro,  "Periodo = "+ "'" + AllTrim(cCompPer) + "'"  )
	nLoops		:= Len( aExprFiltro )
	For nLoop := 1 To nLoops
		cExprFilAux := AllTrim( aExprFiltro[ nLoop ] )
		nAt			:= At( cExprFilAux , cExprFiltro )
		nAt			+= Len( cExprFilAux )
		IF ( nAt > 0 )
			IF !Empty( cExprFilAux )
				If lGestPubl .And. lDissidio
					For nLoopL := 1 To  nAt Step 90
						aAdd( aNewExprFiltro , SubStr( cExprFilAux , nLoopL, 90) )
					Next nLoopL
				Else
				aAdd( aNewExprFiltro , cExprFilAux )
				Endif
			EndIf
			cExprFiltro := AllTrim( SubStr( cExprFiltro , nAt ) )
			IF ( ".AND." == SubStr( cExprFiltro , 1 , 5 ) )
				aAdd( aNewExprFiltro , ".AND." )
				cExprFiltro := AllTrim( SubStr( cExprFiltro , 6 ) )
			ElseIf ( ".OR." == SubStr( cExprFiltro , 1 , 4 ) )
				aAdd( aNewExprFiltro , ".OR." )
				cExprFiltro := AllTrim( SubStr( cExprFiltro , 5 ) )
			EndIf
		EndIf
	Next nLoop
	aExprFiltro		:= NIL
	cExprFiltro		:= NIL
	cExprFilAux		:= NIL
	aItensFilter	:= {}
	aEval( aNewExprFiltro , { |cParseFiltro| aAdd( aItensFilter , GpFltBldDesc( cParseFiltro , @aHdrMestre, cTabMestra ) + " ->" + cParseFiltro ) } )
	aNewExprFiltro	:= NIL

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Adiciona Informacoes de Filtro no Log Geral           					³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aAdd( aGpem020TitLog	, aTitleFilter[1] )
	aAdd( aGpem020Log		, aClone( aItensFilter ) )

EndIf

Return nRecCount

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³SetConvocCalc	³Autor³Marinaldo de Jesus ³ Data ³13/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Seta a Convocação que Esta Sendo Calculado          			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SetConvocCalc( cConvocCalc ,aConvoc )

Local cLastConvocCalc := GetConvocCalc()

__cConvocCalc	:= cConvocCalc
__aConvoc := aClone(aConvoc)

Return( cLastConvocCalc )

/*/{Protheus.doc} SetBenOp
Seta variáveis __cBenOp e __aBenOP com a informação do número do benefício de órgãos públicos
@author jallyson.mesashi
@since 18/02/2022
/*/
Function SetBenOp( cBenOP, aBenOP )

__cBenOp	:= cBenOP
__aBenOP 	:= aClone(aBenOP)

Return()

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³GetConvocCalc   ³Autor³Marinaldo de Jesus ³ Data ³13/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Obtem o Convocação que Esta Sendo Calculado          			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetConvocCalc()
DEFAULT __cConvocCalc := If(SRC->(ColumnPos( 'RC_CONVOC' )) > 0,Space( GetSx3Cache("RC_CONVOC"	, "X3_TAMANHO") )," ")
Return( __cConvocCalc )

/*/{Protheus.doc} GetBenOP
Retorna valor da variável __cBenOp com informação do número do benefício de órgãos públicos
@author jallyson.mesashi
@since 18/02/2022
/*/
Function GetBenOP()

DEFAULT __cBenOp := Iif( SRC->( ColumnPos('RC_NRBEN') ) > 0, Space( GetSx3Cache("RC_NRBEN", "X3_TAMANHO") ), " " )

Return( __cBenOp )

Function RetConvoc()
DEFAULT __aConvoc := {"", Ctod(" / / "), Ctod(" / / "), 0, 0, .T., 0}
Return( __aConvoc )

/*/{Protheus.doc} RetBenOp
Retorna valor da variável __aBenOp com informação do benefício de órgãos públicos
@author jallyson.mesashi
@since 18/02/2022
/*/
Function RetBenOp()

DEFAULT __aBenOp := { "", "", 0, .T. }

Return( __aBenOp )

/*/{Protheus.doc} BuscaConv
Busca as covocações ativas no período
@author cicero.pereira
@since 21/12/2017
@version 12.1.17
@param dIniPer, date, Data inicial para busca, o default será o dia inicial do período
@param dPerFim, date, Data final para busca, o default será o último dia do período
@param lPonto, logical, Define se a chamada veio do Ponto
@param leSocial, logical, Define se a chamada veio do eSocial (S-1200)
@return aConvoc, Array multidimensional contendo as convocações do funcionário para o período informado
@obs	estrutura do array aConvoc:
	[n][1] Código da convocação
	[n][2] Data inicial da atividade
	[n][3] Data final da atividade
	[n][4] Salário Hora
	[n][5] Dias trabalhados
	[n][6] Indica de é a última convocação do período
	[n][7] Horas trabalhadas por dia
	[n][8] Data inicial da atividade
	[n][9] Data final da atividade
	[n][10] ? (Sempre .T.)
	[n][11] Multa
	[n][12] Centro de Custo 
	[n][13] Turno de trabalho
	[n][14] Seq. de Inicio do Turno
	[n][15] Regra de Apontamento
/*/
Function BuscaConv(dIniPer, dPerFim, lPonto, leSocial, lChkAfast)
	
	Local aConvoc		:= {}
	Local cAliasConv	:= ""
	Local cCposQry		:= "SV7.V7_COD, SV7.V7_DTINI, SV7.V7_DTFIM, SV7.V7_SALAR, SV7.V7_HRSDIA, SV7.V7_CCUS, SV7.V7_TURNO, SV7.V7_REGRA, SV7.V7_SEQTURN"
	Local nDias			:= 0
	Local dDtFim
	Local dDtIni
	Local dDtAuxI
	Local dDtAuxF
	Local cPeriod       := ""
	Local cMes			:= ""
	Local cAno   		:= ""
	Local cSem          := ""
	Local aPerAberto    := {}
	Local aBuscaAf		:= {}
	Local aAuxConvoc    := {}
	Local nPos          := 0
	Local nX 			:= 0
	Local nSalMinH      := 0 // Salário hora do salário mínimo, de acordo com as publicações do D.O.U
	
	DEFAULT lPonto		:= .F.
	DEFAULT lTemMultInt	:= SV7->( ColumnPos( "V7_MULTINT" ) ) > 0
	DEFAULT leSocial	:= .F.
	DEFAULT lChkAfast   := .T.
	
	If (SRA->RA_TPCONTR == "3" .Or. leSocial) .And. lContrInt
		If lTemMultInt
			cCposQry += ", SV7.V7_MULTINT"
		EndIf
		cCposQry := "%" + cCposQry + "%"
		If !lPonto
			nSalMinH 	:= Round(Val_SalMin / 220, 2) // Para achar o salário mínimo, sempre divide por 220.
			If Type("cTipoRot") <> "U" .and. cTipoRot == "4" .and. cCompl == "S"
				cPeriod 			:= SRG->RG_PERIODO
				DEFAULT dPerFim 	:= LastDate(Stod(cPeriod + "01"))
				DEFAULT dIniPer		:= FirstDate(dPerFim)
			Else
				cPeriod 	:= GetPeriodCalc()
				cMes 		:= SubStr(cPeriod,5,2)
				cAno 		:= SubStr(cPeriod,1,4)
				cSem        := GetNumPgCalc()
				fRetPerComp(cMes, cAno, NIL, cProcesso, fGetCalcRot("1"), @aPerAberto)
				nPos 		:= aScan(aPerAberto, {|x| x[01]+x[02] == cPeriod+cSem})
				If nPos > 0
					Default dPerFim		:= aPerAberto[nPos,6]
					Default dIniPer		:= aPerAberto[nPos,5]
				Else
					Default dPerFim 	:= LastDate(Stod(cPeriod + "01"))
					Default dIniPer		:= FirstDate(dPerFim)
				EndIf
			EndIf
		EndIf
		
		cAliasConv := GetNextAlias()
		
		BeginSQL Alias cAliasConv
			column V7_DTINI AS Date
			column V7_DTFIM AS Date
			SELECT %Exp:cCposQry%
			
			FROM %Table:SV7% SV7
			
			WHERE SV7.V7_FILIAL = %Exp:SRA->RA_FILIAL%
			AND SV7.V7_MAT = %Exp:SRA->RA_MAT%
			AND ( SV7.V7_DTINI BETWEEN  %Exp:Dtos(dIniPer)% AND %Exp:Dtos(dPerFim)% 
			OR ( SV7.V7_DTINI < %Exp:Dtos(dIniPer)% AND SV7.V7_DTFIM = '' )
			OR (SV7.V7_DTINI < %Exp:Dtos(dIniPer)% AND SV7.V7_DTFIM >= %Exp:Dtos(dIniPer)% ))
			AND SV7.%NotDel%
			ORDER BY V7_DTINI, V7_DTFIM
		EndSQL
		
		While !(cAliasConv)->(Eof())
			If Empty((cAliasConv)->V7_DTFIM)
				dDtFim := dPerFim 
			Else
				dDtFim := Min((cAliasConv)->V7_DTFIM, dPerFim)	// Data fim do periodo de calculo ou data fim da convocação... o que for menor
			EndIf
			dDtIni := (cAliasConv)->V7_DTINI 
			If dDtIni < dIniPer
				dDtIni := dIniPer
			EndIf
			
			nDias := (dDtFim - dDtIni) + 1
			//Se o valor do salário hora do salário mínimo for maior que o salário hora a ser pago, então deve pagar o salário hora referente ao salário mínimo
			Aadd( aConvoc, { (cAliasConv)->V7_COD,; 														// Código da convocação
							dDtIni,; 																		// Data inicial da atividade (ou do período, o que for maior)
							dDtFim,; 																		// Data final da atividade (ou do período, o que for menor)
							Iif( nSalMinH > (cAliasConv)->V7_SALAR, nSalMinH, (cAliasConv)->V7_SALAR),; 	// Salário Hora
							nDias,; 																		// Dias trabalhados
							.F.,; 																			// Indica de é a última convocação do período
							(cAliasConv)->V7_HRSDIA,; 														// Horas trabalhadas por dia
							(cAliasConv)->V7_DTFIM,; 														// Data inicial da atividade
							(cAliasConv)->V7_DTINI,; 														// Data final da atividade
							.T.,;																			// ?
							Iif( lTemMultInt, (cAliasConv)->V7_MULTINT, " " ),;								// Multa
							(cAliasConv)->V7_CCUS,; 														// Centro de Custo 
							(cAliasConv)->V7_TURNO,;														// Turno de trabalho
							(cAliasConv)->V7_SEQTURN,;														// Seq. de Inicio do Turno
							(cAliasConv)->V7_REGRA;															// Regra de Apontamento
						} )
			(cAliasConv)->(dbSkip())
		EndDo
		
		(cAliasConv)->(dbCloseArea())
		
		/*
		Se não possuir convocação mas estiver afastado por acidente de trabalho com data em branco ou posterior ao inicio do período atual. 
		Efetua o cálculo para gerar Base de FGTS		
		*/
		If Len(aConvoc) == 0 .and. lChkAfast .And. !lPonto
			dDtAuxF := CtoD("")
			dDtAuxI := CtoD("")
			fRetAfas(dIniPer , dPerFim,,,,,@aBuscaAf)
			For nX := 1 to Len(aBuscaAf)
				If aBuscaAf[nX,3] <= dPerFim .and. aBuscaAf[nX,16] == "O1" .and. ( Empty(aBuscaAf[nX,4]) .or. aBuscaAf[nX,4] >= dIniPer )
					dDtAuxF := If(Empty(aBuscaAf[nX,4]),dPerFim, Min(dPerFim,aBuscaAf[nX,4]))
					dDtAuxI := If(Empty(dDtAuxI),StoD(AnoMes(aBuscaAf[nX,3])+"01"),dDtAuxI)
				EndIf
			Next nX
			If !Empty(dDtAuxf)
				aAuxConvoc := BuscaConv(dDtAuxI, dPerFim, , , .F.)
				If Len(aAuxConvoc) > 0
					aAdd(aConvoc, aAuxConvoc[Len(aAuxConvoc)]) //Obtém a última convocação
					aConvoc[1,2] := dIniPer
					aConvoc[1,3] := dDtAuxF					
					aConvoc[1,5] := (dDtAuxF - dIniPer ) + 1
					aConvoc[1,8] := dDtAuxF
					aConvoc[1,9] := dIniPer
				EndIf
			EndIf
		EndIf
		
	Endif
	
	If Len(aConvoc) == 0
		Aadd( aConvoc, { Iif( lContrInt, Space( GetSx3Cache("RC_CONVOC" , "X3_TAMANHO") ), Space(6) ), ctod(" / / "), Ctod(" / / "), 0, 0, .T., 0, Ctod(" / / "), Ctod(" / / "), .T., " ", " ", " ", " ", " " } )
	Else
		aConvoc[Len(aConvoc)][6] := .T.	// Última convocação do periodo
	EndIf
	
Return aConvoc

/*/{Protheus.doc} fBuscaBOP
Busca os benefícios ativos no período
@author allyson.mesashi
@since 21/12/2017
@version 12
@param dIniPer, date, Data inicial para busca, o default será o dia inicial do período
@param dPerFim, date, Data final para busca, o default será o último dia do período
@return aBenOp, Array multidimensional contendo os benefícios do funcionário para o período informado
@obs	estrutura do array aBenOp:
	[n][1] Código do benefício
	[n][2] Verba do pagamento do benefício
	[n][3] Valor do benefício
/*/
Function fBuscaBOP()

	Local aAreaRI0		:= RI0->( GetArea() )
	Local aBenOp		:= {}
	Local dPerFim		:= LastDate( sToD(GetPeriodCalc() + "01") )
	Local dIniPer		:= FirstDate( dPerFim )

	If RI0->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT ) )
		While RI0->( !Eof() ) .And. RI0->RI0_FILIAL+RI0->RI0_MAT == SRA->RA_FILIAL+SRA->RA_MAT
			If ( AnoMes( RI0->RI0_DTINIB ) <= AnoMes( dIniPer ) ) .And. ;
				( Empty( RI0->RI0_DTTERM ) .Or. AnoMes( RI0->RI0_DTTERM ) >= AnoMes( dPerFim ) )
				aAdd(aBenOp, { RI0->RI0_NRBEN, RI0->RI0_PD, RI0->RI0_VALOR, .F. } )	
			EndIf
			RI0->( dbSkip()) 
		EndDo
	EndIf

	If !Empty(aBenOp)
		aBenOp[1, 4] := .T.
	EndIf

	RestArea( aAreaRI0 )
	
Return aBenOp

/*/{Protheus.doc}fVldFerPd
Verifica verbas especificas de férias que estão sem incidência
@author Leandro Drumond
@since 15/05/2018
@version P12
/*/
Static Function fVldFerPd(aVerbas)
Local lRet 		:= .F.
Local aPdAux	:= {}
Local nX		:= 0
Local nPosPdv	:= 0
Local cPdAux	:= ""

DEFAULT aVerbas := {}

aAdd(aPdAux, "0072") //Pagto Ferias
aAdd(aPdAux, "0073") //Pagto Ferias Mes Seguinte
aAdd(aPdAux, "0074") //Abono Pecun. Ferias
aAdd(aPdAux, "0075") //Media Ferias Valor
aAdd(aPdAux, "0076") //Media Ferias Valor Mes Seguinte
aAdd(aPdAux, "0077") //Adicional 1/3 sobre Ferias
aAdd(aPdAux, "0078") //Adicional 1/3 Mes Seguinte
aAdd(aPdAux, "0079") //Adic. 1/3 Sobre Abono Pecun.
aAdd(aPdAux, "0082") //Medias s/ Horas Extras Mes
aAdd(aPdAux, "0083") //Medias s/ Horas Mes Seguinte
aAdd(aPdAux, "0104") //Prov. Arred. Ferias
aAdd(aPdAux, "0205") //Abono Mes Seguinte
aAdd(aPdAux, "0206") //1/3 Abono Mes. Seg.
aAdd(aPdAux, "0622") //Media Horas sobre Abono
aAdd(aPdAux, "0623") //Media Valor sobre Abono
aAdd(aPdAux, "0633") //Media Horas sobre Abono Mes seguinte
aAdd(aPdAux, "0634") //Media valor sobre Abono Mes seguinte

For nX := 1 to Len(aPdAux)
	cPdAux := fGetCodFol(aPdAux[nX])
	If !Empty(cPdAux) .AND. fIncide(cPdAux) //Verifica se a verba existe
		nPosPdv 	:=  Ascan(aPdv, { |X| X[1] = cPdAux } )
		If nPosPdv > 0
			//Se não possuir referência para férias, inclui no log
			If !aPdv[nPosPdv][11] == "S"
				lRet := .T.
				aAdd(aVerbas, cPdAux + " - " + fGetCodFol(aPdAux[nX],,,.T.))
			EndIf
		EndIf
	EndIf
Next nX

Return lRet

/*/{Protheus.doc}fTem132Per
Verifica se existe cálculo de 132 no ano até o período atual
@author gabriel.almeida
@since 15/10/2018
@version P12
/*/
Function fTem132Per(cFil,cMat,cPer)
	Local aArea     := GetArea()
	Local aTransf   := {}
	Local lTem132   := .F.
	Local cAliasSRD := GetNextAlias()
	Local cFilMat   := ""
	Local nX 		:= 0

	Static cKeyAnt := ""
	Static lRetAnt := .F.

	DEFAULT cFil := SRA->RA_FILIAL
	DEFAULT cMat := SRA->RA_MAT
	DEFAULT cPer := cPeriodo

	If cKeyAnt == cFil + cMat + cPer 
		lTem132 := lRetAnt
	Else

		fTransf(@aTransf,cPeriodo,,,.F.,,,.T.)

		If !Empty(aTransf)
			For nX := 1 to Len(aTransf)
				//Se houve transferencia de filial ou matrícula no ano
				If ( aTransf[nX,8] != aTransf[nX,10] .or. aTransf[nX,9] != aTransf[nX,11] )
					cFilMat += If(Empty(cFilMat),""," OR ") + "( SRD.RD_FILIAL = '" + aTransf[nX,8] + "' AND SRD.RD_MAT = '" + aTransf[nX,9] + "')"
				EndIf
			Next nX
		EndIf

		cFilMat += If(Empty(cFilMat),""," OR ") + "( SRD.RD_FILIAL = '" + cFil + "' AND SRD.RD_MAT = '" + cMat + "') "
		
		cFilMat := "%( " + cFilMat + ")%"

		BeginSql Alias cAliasSRD
			SELECT COUNT(*) AS CONTADOR
			FROM %table:SRD% SRD 
			WHERE %exp:cFilMat%
			AND SRD.RD_ROTEIR = %exp:'132'%
			AND SRD.RD_PERIODO >= %exp:SubStr(cPer,1,4)+"01"% AND SRD.RD_PERIODO <= %exp:cPer%
			AND SRD.%notDel%
		EndSql

		If ( cAliasSRD )->( !Eof() )
			If ( cAliasSRD )->CONTADOR > 0
				lTem132 := .T.
			EndIf
		EndIf

		(cAliasSRD)->( DbCloseArea() )

		RestArea(aArea)

		cKeyAnt := cFil + cMat + cPer 
		lRetAnt := lTem132

	EndIf

Return lTem132

/*/{Protheus.doc}fTemROT132
Verifica se existe o roteiro 132 no período
@author gabriel.almeida
@since 17/10/2018
@version P12
/*/
Function fTemROT132(cFil,cProc,cPer,cSem)
	Local aArea   := GetArea()
	Local aAreaRCH:= RCH->( GetArea() )
	Local lTem132 := .F.
	
	Default cFil  := cFilAnt
	Default cProc := cProcesso
	Default cPer  := cPeriodo
	Default cSem  := cSemana

	DbSelectArea("RCH")
	RCH->( DbSetOrder(1) ) //RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR
	lTem132 := RCH->( DbSeek( xFilial("RCH",cFil) + cProc + cPer + cSem + fGetCalcRot('6') ) )

	RestArea(aAreaRCH)
	RestArea(aArea)
Return lTem132

/*/{Protheus.doc} fExisTitFA
// Verifica se existe Título Definido pelo Usuário para Folha de Pagamento ou Adiantamento
@author raquel.andrade
@since 06/08/2020
@version 1.0
@return Logico, Retorna .T. se encontrou o titulo e .F. se não encontrou 
@type function
/*/
Function fExisTitFA(cProc,cPeri,cRoteiro,cNroPgto,aProcessoLog)
Local lRet 		:= .F.
Local cCtrlTit	:= ""
Local nIndex 	:= 0

// Utiliza conteúdo do parâmetro MV_BTITFOL/MV_BTITADT (variavel cCtrlTit)
// 0 - Não realiza tratamento
// 1 - Exibe mensagem para o usuário mas não bloqueia, usuário escolhe prosseguir ou não - gera log com Títulos
// 2 - Exibe mensagem para o usuário e bloqueia - gera log com Títulos
If fGetTipoRot(cRoteiro) $ "1" // Folha de Pagamento
	cCtrlTit 	:=  SuperGetMv("MV_BTITFOL",,"0")
ElseIf fGetTipoRot(cRoteiro) $ "2" // Adiantamento
	cCtrlTit 	:=  SuperGetMv("MV_BTITADT",,"0")
EndIf

If cCtrlTit == "0"
	lRet := .F.
ElseIf cCtrlTit == "1"
	If TCCanOpen(RetSqlname("RJ1")) .and. Retorder("RJ1","RJ1_FILIAL+RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT") > 0
	
		nIndex	:= Retorder("RJ1","RJ1_FILIAL+RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT")

		dbSelectArea("RJ1")
		RJ1->(dbSetOrder(nIndex)) // RJ1_FILIAL+ RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT 
		If RJ1->(dbSeek(cFilAnt+cProc+cRoteiro+cPeri+cNroPgto))			
			aAdd( aProcessoLog , "")
			aAdd( aProcessoLog, OemToAnsi(STR0116) + OemToAnsi(STR0112) ) // "Existe(m) Título(s) gerado(s) sobre esse cálculo."###"Consulte o(s) Título(s) abaixo em Manutenção de Títulos:"
			While RJ1->(!Eof()) .And. (	RJ1->RJ1_FILIAL+RJ1->RJ1_PROCES+RJ1->RJ1_ROTEIR+RJ1->RJ1_PERIOD+RJ1->RJ1_SEMANA == cFilAnt+cProc+cRoteiro+cPeri+cNroPgto ) 
				aAdd( aProcessoLog, OemToAnsi(STR0118) + RJ1->RJ1_FILIAL + " " + OemToAnsi(STR0114) + RJ1->RJ1_NUMTIT ) // Filial:###Número do Título:
				("RJ1")->(DbSkip())
			EndDo
			aAdd( aProcessoLog , "")					
			lRet := !MsgNoYes(OemToAnsi(STR0116) + OemToAnsi(STR0117),OemToAnsi(STR0005)) //"Existe(m) Título(s) gerado(s) sobre esse cálculo. A Exclusão ou Recálculo desse cálculo sem a exclusão do(s) título(s) pode gerar duplicidade de titulos. Deseja Continuar? "                                                                                                                                                                                                                                                                                                                                                                                      "  
			
		EndIf 		
		RJ1->(dbCloseArea())
	EndIf
ElseIf cCtrlTit == "2"
	If TCCanOpen(RetSqlname("RJ1")) .and. !Empty(RJ1->(INDEXKEY(3)))
		dbSelectArea("RJ1")
		RJ1->(dbSetOrder(3)) // RJ1_FILIAL+ RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT
		If RJ1->(dbSeek(cFilAnt+cProc+cRoteiro+cPeri+cNroPgto))	
			aAdd( aProcessoLog , "")
			aAdd( aProcessoLog, OemToAnsi(STR0116) + OemToAnsi(STR0112) ) // "Existe(m) Título(s) gerado(s) sobre esse cálculo."###"Consulte o(s) Título(s) abaixo em Manutenção de Títulos:"
			While RJ1->(!Eof()) .And. (	RJ1->RJ1_FILIAL+RJ1->RJ1_PROCES+RJ1->RJ1_ROTEIR+RJ1->RJ1_PERIOD+RJ1->RJ1_SEMANA == cFilAnt+cProc+cRoteiro+cPeri+cNroPgto ) 
				aAdd( aProcessoLog, OemToAnsi(STR0118) + RJ1->RJ1_FILIAL + " " + OemToAnsi(STR0114) + RJ1->RJ1_NUMTIT ) // Filial:###Número do Título:
				("RJ1")->(DbSkip())
			EndDo
			aAdd( aProcessoLog , "")
			lRet := .T.
		EndIf 		
		RJ1->(dbCloseArea())
	EndIf

EndIf


Return lRet

/*/{Protheus.doc} fCtrTitLg
Imprime log com títulos existentes do funcionário (quando existe controle de títulos na base MV_BTITFOL/MV_BTITADT igual a 1 ou 2)
@author		raquel.anrade
@since		06/08/2020
@version 1.0
/*/
Static Function fCtrTitLg(aLogErros)
Local aLog			:= {}
Local aTitleLog		:= {}
Local nX			:= 0
Local nPosLog		:= 0
Local lRet			:= .T.

	If !IsBlind()	
		If lWorkFlow
			//Grava o log em arquivo texto
			For nPosLog := 1 to Len(aLogErros)
				AutoGrLog(aLogErros[nPosLog])
				AAdd( aLogExt,aLogErros[nPosLog] )
			Next nPosLog
		Else
			If Empty( aLog )
				aAdd( aTitleLog, STR0016 )	//"Log de Ocorrencias no Processo de Calculo"
				aAdd( aLog, {} )
			EndIf

			nPosLog := Len( aLog )
			For nX := 1 To Len( aLogErros )
				aAdd( aLog[ nPosLog ], aLogErros[ nX ] )
			Next nX
			
			MsAguarde( { || fMakeLog( aLog , aTitleLog , FunName() , NIL , FunName()+cRoteiro , STR0016 ) } ,  STR0016 ) 
		EndIf
		aLogErros	:= {}	
	EndIf	

Return lRet

/*/{Protheus.doc} fRstaLogExt
	Zera variável estática aLogExt
	@author gabriel.almeida
	@since 12/11/2020
	@version 1.0
	/*/
Function fRstaLogExt()
	aLogExt := {}
Return

/*/{Protheus.doc} fGetaLogExt
	Retorna o conteúdo do array aLogExt
	@type  Function
	@author gabriel.almeida
	@since 12/11/2020
	@version 1.0
	@return aLog, array, Clone do log retornado no cálculo
	/*/
Function fGetaLogExt()
	Default aLogExt := {}
Return aLogExt

/*/{Protheus.doc} fAtuRCHSt
Função para atualizar RCH_STATUS quando calcular roteiro
@author Allyson Mesashi
@since 11/03/2021
@version 1.0
/*/
Function fAtuRCHSt( nTipo, cChaveRCH, aRecnoRCH )

Local nCont			:= 0
Local nRecno		:= 0

Default nTipo		:= 1
Default cChaveRCH	:= ""
Default aRecnoRCH	:= {}

RCH->( dbSetOrder(1) )

If nTipo == 1 .And. !Empty(cChaveRCH)
	If RCH->( dbSeek( cChaveRCH ) )
		If RCH->( RecLock("RCH", .F.) )								
			RCH->RCH_STATUS  := "2"
			RCH->( MsUnlock() )
		EndIf
		nRecno	:= RCH->( Recno() )
		If aScan( aRecnoRCH, { |x| x == nRecno } ) == 0
			aAdd( aRecnoRCH, nRecno )
		EndIf
	EndIf
ElseIf nTipo == 2 .And. !Empty(aRecnoRCH)
	For nCont := 1 To Len(aRecnoRCH)
		RCH->( dbGoTo(aRecnoRCH[nCont]) )
		If RCH->( RecLock("RCH", .F.) )								
			RCH->RCH_STATUS  := "0"
			RCH->( MsUnlock() )
		EndIf
	Next nCont
EndIf

Return

/*/{Protheus.doc} fSetThdGrid
Seta o númeor da thread que esta sendo executada. Uso apenas em multi-thread com grig (GPEM020A)
@author Leandro Drumond
@since 14/06/2021
@version 1.0
/*/
Function fSetThdGrid(cPar)

cThreadGrid := cPar

Return Nil

/*/{Protheus.doc} SchedDef
Definiç?es de agendamento do Schedule.
@author Maria Luísa de Souza Arcanjo Bastos
@since 12/02/2025
/*/
Static Function SchedDef()

    Local aParam As Array
    // Inicializaç?o das variáveis
    aParam := {}

    // Montagem da estrutura do vetor de retorno
    AAdd(aParam, "P")       // Tipo do agendamento: "P" = Processo | "R" = Relatório
    AAdd(aParam, "GPEM020") // Pergunte (SX1) (usar "PARAMDEF" caso n?o tenha conjunto de perguntas)
    AAdd(aParam, "")        // Alias principal (exclusivo para relatórios)
    AAdd(aParam, {})        // Vetor de ordenaç?o (exclusivo para relatórios)
    AAdd(aParam, "")        // Título (exclusivo para relatórios)

Return aParam
