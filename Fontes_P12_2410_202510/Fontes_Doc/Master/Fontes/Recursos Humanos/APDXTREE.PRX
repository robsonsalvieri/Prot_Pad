#INCLUDE "PROTHEUS.CH"
#INCLUDE "DBTREE.CH"
#INCLUDE "APDXTREE.CH"
#INCLUDE "APDTREEN.CH"

Static aMainTree
Static aLstMainTree
Static aTreeNodes
Static aCutTreeNodes
Static aCopyTreeNodes
Static nPosMainGrp
Static nLstMainGrp
Static nSeedTree
Static cLastSeq
Static lTreeUseSeq
Static aCombo
Static cAllCargo	:= ""

/*/
зддддддддддбддддддддддбдддддбдддддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁAPDXTREE  ЁAutorЁMarinaldo de Jesus       Ё Data Ё16/07/2003Ё
цддддддддддеддддддддддадддддадддддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁBiblioteca de Funcoes para Uso de Tree Estruturado          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
цддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё            ATUALIZACOES SOFRIDAS DESDE A CONSTRU─AO INICIAL           Ё
цддддддддддддбддддддддддбдддддддддддбддддддддддддддддддддддддддддддддддд╢
ЁProgramador ЁData      ЁFNC        ЁMotivo da Alteracao                Ё
цддддддддддддеддддддддддедддддддддддеддддддддддддддддддддддддддддддддддд╢
ЁCecilia Car.Ё04/07/2014ЁTPZWF1     ЁIncluido o fonte da 11 para a 12 e Ё
Ё            Ё          Ё           Ёefetuada a limpeza.                Ё  
ЁCecilia Car.Ё26/08/2014ЁTQIF53     ЁEmitir mensagem de alerta quando   Ё
Ё            Ё          Ё           Ёnao existir item a ser incluido a- Ё  
Ё            Ё          Ё           Ёtraves da opcao Estrutura/Incluir/ Ё  
Ё            Ё          Ё           ЁItem da Lista.                     Ё
юддддддддддддаддддддддддадддддддддддаддддддддддддддддддддддддддддддддддды/*/


/*/
зддддддддддбддддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁInApdxTreeExecЁAutor ЁMarinaldo de Jesus   Ё Data Ё24/08/2004Ё
цддддддддддеддддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁExecutar Funcoes Dentro de APDXTREE                          Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁInApdxTreeExec( cExecIn , aFormParam )						 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁuRet                                                 	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 													 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function InApdxTreeExec( cExecIn , aFormParam )

Local uRet

DEFAULT cExecIn		:= ""
DEFAULT aFormParam	:= {}

IF !Empty( cExecIn )
	cExecIn	:= BldcExecInFun( cExecIn , aFormParam )
	uRet	:= __ExecMacro( cExecIn )
EndIF

Return( uRet )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdBldTreeЁ Autor ЁMarinaldo de Jesus     Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMontar Tree Estruturado                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerica 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ApdBldTree( 	aDbTreeInfo		,;
						cTreeTitle		,;
						bTreeOk			,;
						bTreeChange		,;
						bTreeInit		,;
						lGrava			,;
						aObjSize		,;
						nWidthTree		,;
						oDlg		 	,;
						lMenuPopUp		,;
						aMenuDisable	,;
						aMenuPopUp		,;
						bTreeRClicked	,;
						aFormalAdvSize	,;
						bMenuItemEnable ,;
						bPesquisa		,;
						bTreeDbClick	,;
						oTree			,;
						aButtons		,;
						adbTree			,;
						lFullTree		,;
						lOk				;
				 )

Local aSvKeys				:= GetKeys()
Local aAreaAnt				:= GetArea()
Local aAdvSize				:= IF( !Empty( aFormalAdvSize ) , aFormalAdvSize , MsAdvSize( .T. ) )
Local aObjects				:= {}

Local bMenuVldExc			:= { || .T. }
Local bMenuVldCut			:= { || .T. }
Local bTreeGetDet			:= { || .T. }
Local bRes1Field			:= { || "PMSTASK1" }
Local bRes2Field			:= { || "PMSTASK2" }
Local bDialogInit			:= { || .T. }

Local lTudoOk				:= .F.
Local lNewDialog			:= !( ValType( oDlg ) == "O" )
Local oTreeDlg				:= oDlg

Local aInfo
Local bFilField
Local bCodField
Local bTreeField
Local bItemField
Local bDescField
local bAddTodos				:= If( IsInCallStack("ORGA060"), { || CursorWait() , ApdTreeSelec( @oTree, @aTreeNodes, cKeyFather, cdbTreeAlias, bItemField, bDescField, nItemOrder, cSetFilConPad, .F., bTreeGetDet, bRes1Field, bRes2Field, cdbTreeF3 , abDados), CursorArrow() },  { || CursorWait(), ApdTreeInc( @oTree, @aTreeNodes, cKeyFather, cdbTreeAlias, bItemField, bDescField, nItemOrder, cSetFilConPad, .F., bTreeGetDet, bRes1Field, bRes2Field, cdbTreeF3, abDados), CursorArrow() } )
Local bAddNewItem  
Local bAddNodes
Local bTreeClick

Local cAliasFather
Local cFilFather
Local cKeyFather
Local cFldDescFather
Local cFldRes1Father
Local cFldRes2Father
Local cdbTreeAlias
Local cFilField
Local cCodField 

Local abDados:= {}
Local acDados:= {}
Local nX

Local cItemField
Local cTreeField
Local cDescField
Local cSetFilConPad
Local cRes1Field
Local cRes2Field
Local cRes1Cut
Local cRes2Cut
Local cLastItemNum
Local cdbTreeF3

Local nTreeOrder
Local nItemOrder
Local nRegFather

Local oMenu

ApdTreeCacheClear()

aCutTreeNodes	:= {}
aCopyTreeNodes  := {}

DEFAULT bTreeDbClick		:= {|| }
DEFAULT aObjects			:= { { 100, 100, .T., .T. } }
DEFAULT aButtons			:= {}
DEFAULT oDlg				:= NIL
DEFAULT lMenuPopUp			:= .T.
DEFAULT lFullTree			:= .T.
DEFAULT aMenuDisable		:= {}
DEFAULT bPesquisa			:= NIL
DEFAULT aMenuPopUp			:= {;
									{;
										OemToAnsi( STR0001 ),;	//'Pesquisar'
										If(bPesquisa == Nil, { || CursorWait() , ApdTreeSeek( oTree , "+-" , cdbTreeF3 , Len( ( cdbTreeAlias )->( Eval( bItemField ) ) ) ) , CursorArrow() },bPesquisa),;
										.T.;
									},;
									{;
										OemToAnsi( STR0002 ),;	//'Visualizar'
										{ || CursorWait() , ApdTreeVis( oTree , cKeyFather , cdbTreeAlias , nItemOrder ) , CursorArrow() },;
										.T.;
									},;
									{;
										OemToAnsi( STR0003 ),;	//'Incluir'
										NIL,;
										.T.,;
										{;
											{;
												OemToAnsi( STR0043 ),;	//'Novo(s) Item(ns) na Lista'
												{ || CursorWait() , Eval( bAddNewItem , cLastItemNum ) , CursorArrow() },;
												.T.;
											},;
											{;
												OemToAnsi( STR0024 ),;	//'Itens da Lista'
											   ; //Alterado em 15/01/2013 para chamdar nova funcionalidade - By Adilson Silva 
											   ; //{ || CursorWait() , ApdTreeInc( @oTree , @aTreeNodes , cKeyFather , cdbTreeAlias , bItemField , bDescField , nItemOrder , cSetFilConPad , .F. , bTreeGetDet , bRes1Field , bRes2Field , cdbTreeF3   , abDados) , CursorArrow() },;
											 	 { || CursorWait() , Eval( bAddTodos ) , CursorArrow() },;
												.T.;
											},;
											{;
												OemToAnsi( STR0041 ),;	//'Todos os Itens da Lista'
												{ || CursorWait() , ApdTreeInc( @oTree , @aTreeNodes , cKeyFather , cdbTreeAlias , bItemField , bDescField , nItemOrder , cSetFilConPad , .T. , bTreeGetDet , bRes1Field , bRes2Field ,/*cdbTreeF3*/, abDados) , CursorArrow() },;
												.T.;
											};
										};
									},;
									{;
										OemToAnsi( STR0004 ),;	//'Excluir'
										{ || CursorWait() , ApdTreeExc( @oTree , @aTreeNodes , bMenuVldExc ) , CursorArrow() },;
										.T.;
									},;
									{;
										OemToAnsi( STR0017 ),;	//'Recortar'
										NIL,;
										.T.,;
										{;
											{;
												OemToAnsi( STR0028 ),;	//'Marcar'
												{ || CursorWait() , ApdCutTree( @oTree , @aTreeNodes , @aCutTreeNodes , @aMenuPopUp , 6 , bMenuVldCut , .T. , cRes1Cut , cRes2Cut , aCopyTreeNodes ) , CursorArrow() },;
												.T.;
											},;
											{;
												OemToAnsi( STR0029 ),;	//'Desmarcar'
												{ || CursorWait() , ApdCutTree( @oTree , @aTreeNodes , @aCutTreeNodes , @aMenuPopUp , 6 , bMenuVldCut , .F. , cRes1Cut , cRes2Cut , aCopyTreeNodes ) , CursorArrow() },;
												.T.;
											};
										};
									},;
									{;
										OemToAnsi( STR0018 ),;	//'Colar Recorte'
										{ || CursorWait() , ApdPstRecTree( @oTree , @aTreeNodes , @aCutTreeNodes , @aMenuPopUp , 6 , NIL , aCopyTreeNodes ) , CursorArrow() },;
										.F.;
									},;
									{;
										OemToAnsi( STR0036 ),;	//'Copiar'
										NIL,;
										.T.,;
										{;
											{;
												OemToAnsi( STR0028 ),;	//'Marcar'
												{ || CursorWait() , ApdTreeCpy( @oTree , @aTreeNodes , @aCopyTreeNodes , @aMenuPopUp , 8 , NIL , .T. , cRes1Cut , cRes2Cut , aCutTreeNodes ) , CursorArrow() },;
												.T.;
											},;
											{;
												OemToAnsi( STR0029 ),;	//'Desmarcar'
												{ || CursorWait() , ApdTreeCpy( @oTree , @aTreeNodes , @aCopyTreeNodes , @aMenuPopUp , 8 , NIL , .F. , cRes1Cut , cRes2Cut , aCutTreeNodes ) , CursorArrow() },;
												.T.;
											};
										};
									},;
									{;
										OemToAnsi( STR0037 ),;	//'Colar CСpia'
										{ || CursorWait() , ApdPstCpyTree( @oTree , @aTreeNodes , @aCopyTreeNodes , @aMenuPopUp , 8 , { || GetNewCodigo( cdbTreeAlias , cItemField , GetSx2Unico( cdbTreeAlias ) , { || cLastItemNum := Soma1( cLastItemNum ) } , NIL , NIL , cKeyFather ) } , aCutTreeNodes ) , CursorArrow() },;
										.F.;
									};
								}
DEFAULT bTreeRClicked	:= { |o,x,y| ApdTreeMenu( o , oMenu , x , y , aMenuPopUp, bMenuItemEnable ) } // PosiГЦo x,y em relaГЦo a Dialog
DEFAULT lGrava			:= .T.

cAliasFather			:= aDbTreeInfo[ 01 , 01 ]	//01 , 01 -> Alias Mestre do Tree
nRegFather				:= aDbTreeInfo[ 01 , 02 ]	//01 , 02 -> Recno para o Posicionamento do Tree
cFilFather				:= aDbTreeInfo[ 01 , 03 ]	//01 , 03 -> Filial para a Montagem do Tree
cKeyFather				:= aDbTreeInfo[ 01 , 04 ]	//01 , 04 -> Chave para a Montagem do Tree
cFldDescFather			:= aDbTreeInfo[ 01 , 05 ]	//01 , 05 -> Descricao do Tree
cAllCargo				:= ""

IF ( Len( aDbTreeInfo[ 01 ] ) >= 06 )
	cFldRes1Father		:= aDbTreeInfo[ 01 , 06 ]	//01 , 06 -> Campo que Contem o Resource1
EndIF

IF ( Len( aDbTreeInfo[ 01 ] ) >= 07 )
	cFldRes2Father		:= aDbTreeInfo[ 01 , 07 ]	//01 , 07 -> Campo que Contem o Resource2
EndIF

cdbTreeAlias			:= aDbTreeInfo[ 02 , 01 ]	//02 , 01 -> Alias Filho do Tree
cItemField				:= aDbTreeInfo[ 02 , 02 ]	//02 , 02 -> Item
nItemOrder				:= aDbTreeInfo[ 02 , 03 ]	//02 , 03 -> Ordem do Item
cTreeField				:= aDbTreeInfo[ 02 , 04 ]	//02 , 04 -> Tree (Grupo Superior)
nTreeOrder				:= aDbTreeInfo[ 02 , 05 ]	//02 , 05 -> Ordem do Tree
cDescField				:= aDbTreeInfo[ 02 , 06 ]	//02 , 06 -> Descricao do Item

IF ( Len( aDbTreeInfo[ 02 ] ) >= 07 )
	IF ( ValType( aDbTreeInfo[ 02 , 07 ]  ) == "B" )
		bMenuVldExc		:= aDbTreeInfo[ 02 , 07 ]	//02 , 07 -> Bloco para o DelOk
	EndIF
EndIF

IF ( Len( aDbTreeInfo[ 02 ] ) >= 08 )
	cSetFilConPad		:= aDbTreeInfo[ 02 , 08 ]	//02 , 08 -> Funcao Para Setar o Filtro
EndIF

IF ( Len( aDbTreeInfo[ 02 ] ) >= 09 )
	IF ( ValType( aDbTreeInfo[ 02 , 09 ]  ) == "B" )
		bMenuVldCut		:= aDbTreeInfo[ 02 , 09 ]	//02 , 09 -> Bloco para Validar o Cut
	EndIF
EndIF
IF ( Len( aDbTreeInfo[ 02 ] ) >= 10 )
	IF ( ValType( aDbTreeInfo[ 02 , 10 ]  ) == "B" )
		bTreeGetDet		:= aDbTreeInfo[ 02 , 10 ]	//02 , 10 -> Bloco para Get das Informacoes
	EndIF
EndIF
IF ( Len( aDbTreeInfo[ 02 ] ) >= 11 )
	cRes1Field		:= aDbTreeInfo[ 02 , 11 ]		//02 , 11 -> Campo para Get do Resource1
EndIF
IF ( Len( aDbTreeInfo[ 02 ] ) >= 12 )
	cRes2Field		:= aDbTreeInfo[ 02 , 12 ]		//02 , 12 -> Campo para Get do Resource2
EndIF
IF ( Len( aDbTreeInfo[ 02 ] ) >= 13 )
	cFilField := aDbTreeInfo[ 02 , 13 ]				//02 , 13 -> Campo de Filial
EndIF
IF ( Len( aDbTreeInfo[ 02 ] ) >= 14 )
	cCodField := aDbTreeInfo[ 02 , 14 ]				//02 , 14 -> Campo de Codigo
EndIF
IF ( Len( aDbTreeInfo[ 02 ] ) >= 15 )
	bAddNewItem := aDbTreeInfo[ 02 , 15 ]			//02 , 15 -> Bloco para Adicao de Novo Item
EndIF
DEFAULT bAddNewItem := { || MsgInfo( OemToAnsi( STR0042 ) /*"OpГЦo nЦo disponМvel"*/ , OemToAnsi( STR0007 )/*"AtenГДo!"*/ ) }
IF ( Len( aDbTreeInfo[ 02 ] ) >= 16 )
	cdbTreeF3 := aDbTreeInfo[ 02 , 16 ]				//02 , 16 -> Alias para consulta Padrao
EndIF
IF ( Len( aDbTreeInfo[ 02 ] ) >= 17 )
	IF ( ValType( aDbTreeInfo[ 02 , 17 ]  ) == "B" )
		bAddNodes		:= aDbTreeInfo[ 02 , 17 ]	//02 , 17 -> Bloco para verificar se deve incluir o node na tree
	EndIF
EndIF

bTreeClick			:= If( lFullTree, {||}, {||  ApdLoadTree(adbTree , oTree, , bAddNodes) })

IF ( Len( aDbTreeInfo[ 02 ] ) >= 18 )
	cRes1Cut:= aDbTreeInfo[ 02, 18 ]
EndIF

IF ( Len( aDbTreeInfo[ 02 ] ) >= 19 )
	cRes2Cut:= aDbTreeInfo[ 02, 19 ]
EndIF

IF ( Len( aDbTreeInfo[ 02 ] ) >= 20 )  
	acDados:=Array(Len(aDbTreeInfo[ 02, 20 ]))
	abDados:=Array(Len(aDbTreeInfo[ 02, 20 ]))
    For nX:=1 to Len(aDbTreeInfo[ 02, 20 ])
		acDados[nX]:= aDbTreeInfo[ 02, 20, nX ]  
		abDados[nX]	:= FieldWBlock( acDados[nX]	, Select( cdbTreeAlias ) )
	Next nX	
EndIF

DEFAULT bAddNodes := { || .T. }

IF ( cFilField <> NIL )
	bFilField	:= FieldWBlock( cFilField	, Select( cdbTreeAlias ) )
EndIF
IF ( cCodField <> NIL )
	bCodField	:= FieldWBlock( cCodField	, Select( cdbTreeAlias ) )
EndIF
bItemField	:= FieldWBlock( cItemField	, Select( cdbTreeAlias ) )
bTreeField	:= FieldWBlock( cTreeField	, Select( cdbTreeAlias ) )  

IF ValType(cDescField) == "B"
	bDescField	:= cDescField
Else
	bDescField	:= FieldWBlock( cDescField	, Select( cdbTreeAlias ) )
Endif

IF ( cRes1Field <> NIL )
	If ValType(cRes1Field) == "B"
		bRes1Field	:= cRes1Field
	Else
		bRes1Field	:= FieldWBlock( cRes1Field , Select( cdbTreeAlias ) )
	EndIf
EndIF

IF ( cRes2Field <> NIL )
	If ValType(cRes1Field) == "B"
		bRes2Field	:= cRes1Field
	Else
		bRes2Field := FieldWBlock( cRes2Field , Select( cdbTreeAlias ) )
	EndIf
EndIF


aObjects			:= { { 100 , 100 , .T. , .T. } }
aInfo				:= { aAdvSize[1], aAdvSize[2], aAdvSize[3], aAdvSize[4], 3, 3 }
DEFAULT aObjSize	:= MsObjSize( aInfo , aObjects , NIL , .T. )
DEFAULT nWidthTree	:= 100

CursorWait()
	adbTree := ApdGetNodes(	cAliasFather				,;
							cFilFather					,;
							@cKeyFather					,;
							cFldDescFather				,;
							nRegFather					,;
							cFldRes1Father				,;
							cFldRes2Father				,;
							cdbTreeAlias		 		,;
							bItemField					,;
							bDescField					,;
							nTreeOrder					,;
							bTreeField					,;
							nItemOrder	 				,;
							bTreeGetDet		 			,;
							bRes1Field					,;
							bRes2Field					,;
							@cLastItemNum				,;
							bAddNodes                   ,;
							abDados	                    ,;
							lFullTree					;
			 			)
CursorArrow()

IF Empty( cLastItemNum )
	cLastItemNum := Replicate( "0" , GetSx3Cache( cItemField , "X3_TAMANHO" ) )
EndIF

IF ( lNewDialog )
	DEFINE MSDIALOG oTreeDlg FROM aAdvSize[7],00 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi( cTreeTitle ) OF GetWndDefault() PIXEL
EndIF

oTree := ApdDbTree( adbTree , oTreeDlg , bTreeInit , bTreeRClicked , bTreeChange , aObjSize , nWidthTree, bTreeDbClick, bTreeClick, lFullTree )

IF ( lMenuPopUp )
	oMenu := ApdBldMnuTree( aMenuPopUp , aMenuDisable )
EndIF

IF ( lNewDialog )
	bDialogInit := { || ApdTreeBar( oTreeDlg , @lTudoOk , NIL,  NIL , NIL , aButtons , bTreeOk ) }
	IF ( ValType( oTreeDlg ) == "O" )
		oTreeDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.
		ACTIVATE MSDIALOG oTreeDlg ON INIT Eval( bDialogInit ) CENTERED
	EndIF
EndIF

IF ( lTudoOk )
	lOk := .T.
	IF ( lGrava )
		cKeyFather 	:= aDbTreeInfo[ 01 , 04 ]
		
		MsAguarde(;
						{ || lGrava := ApdTreeGrv(;
														aTreeNodes,;
														aLstMainTree[ nLstMainGrp , 4 ],;
														cdbTreeAlias,;
														bFilField,;
														bCodField,;
														bItemField,;
														bTreeField,;
														bDescField,;
														cFilFather,;
														cKeyFather,;
														nItemOrder,; 
														abDados	;
												  );
						 },;
						 NIL,;
						 OemToAnsi( STR0006 );	//'Gravando Estrutura...'
				 )
		IF ( lGrava )
			aMainTree[ nLstMainGrp		, 4 ]	:= aClone( aTreeNodes )
			aLstMainTree[ nLstMainGrp	, 4 ]	:= aClone( aTreeNodes )
		EndIF
	EndIF
Else
	lOk := .F.
	aMainTree[ nLstMainGrp , 4 ] := aClone( aLstMainTree[ nLstMainGrp , 4 ] )
EndIF

RestKeys( aSvKeys , .T. )
RestArea( aAreaAnt )

Return( IF( ( lNewDialog ) , ( lNewDialog ) , ( oTree ) ) )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreeCacheClearЁAutorЁMarinaldo de JesusЁ Data Ё17/08/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁBarrasa do Tree ( Equivalente a EnchoiceBar )               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ApdTreeCacheClear()

aMainTree		:= NIL
aLstMainTree	:= NIL
aTreeNodes		:= NIL
aCutTreeNodes	:= NIL
aCopyTreeNodes	:= NIL
nPosMainGrp		:= NIL
nLstMainGrp		:= NIL
nSeedTree		:= NIL
ApdTSetSeq( 0 , 0 , .F. )

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTSetSeq	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInclusao de novo Grupo/Item no Tree                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ApdTSetSeq( nLastSeq , nSizeSeq , lUseSeq )

Local nSeq
Local cSeq

DEFAULT nSizeSeq := 06
DEFAULT lUseSeq  := .T.

lTreeUseSeq := lUseSeq

IF ( lTreeUseSeq )
	DEFAULT nLastSeq := 0
	cSeq := Replicate( "0" , nSizeSeq )
	nSeq := 0
	While ( nLastSeq <> nSeq )
		++nSeq
		cSeq := Soma1( cSeq )
	End While
EndIF
cLastSeq := cSeq

Return( cLastSeq )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTUseSeq	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё20/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Esta Utilizando Sequencia na Montagem do Tree   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ApdTUseSeq()
DEFAULT lTreeUseSeq := .F.
Return( lTreeUseSeq )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdGetNodes  ЁAutorЁMarinaldo de Jesus    Ё Data Ё17/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCarrega os Nodes para a Montagem do dbTree                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ApdGetNodes(	cAliasFather				,;
						cFilFather					,;
						cKeyFather					,;
						cFldDescFather				,;
						nRegFather					,;
						cFldRes1Father				,;
						cFldRes2Father				,;
						cdbTreeAlias		 		,;
						bItemField					,;
						bDescField					,;
						nTreeOrder					,;
						bTreeField					,;
						nItemOrder	 				,;
						bTreeGetDet		 			,;
						bRes1Field					,;
						bRes2Field					,;
						cLastItemNum				,;
						bAddNodes                   ,;
						abDados                     ,;
						lFullTree					;
				 )

Local bAscanMain
Local cMainGroup
Local cFirstNodeName
Local cResource1
Local cResource2

aTreeNodes				:= {}

DEFAULT aMainTree		:= {}
DEFAULT aLstMainTree	:= {}
DEFAULT aTreeNodes		:= {}
DEFAULT nPosMainGrp		:= 0
DEFAULT nLstMainGrp		:= 0  

DEFAULT abDados			:= {}
DEFAULT lFullTree		:= .T.

cFilFather := xFilial( cAliasFather , cFilFather )
bAscanMain := { |x| ( x[1] == cAliasFather );
					.and.;
					( x[2] == cFilFather );
					.and.;
					( x[3] == cKeyFather );
			  }

nPosMainGrp := aScan( aMainTree , bAscanMain )
IF ( nLstMainGrp <> nPosMainGrp )
	nLstMainGrp := aScan( aLstMainTree , bAscanMain )
	nPosMainGrp := nLstMainGrp
Else
	nLstMainGrp := nPosMainGrp
EndIF

IF (;
		( nPosMainGrp == 0 );
		.or.;
		Empty( aMainTree[ nPosMainGrp , 4 ] );
	)

	aAdd( aMainTree 	, { cAliasFather , cFilFather , cKeyFather , {} } )
	aAdd( aLstMainTree	, { cAliasFather , cFilFather , cKeyFather , {} } )
	nLstMainGrp  := ( nPosMainGrp := Len( aMainTree ) )

	( cAliasFather )->( MsGoto( nRegFather ) )
	cFirstNodeName	:= Eval( FieldWBlock( cFldDescFather , Select( cAliasFather ) ) )
	cFirstNodeName	:= PadR( OemToAnsi( cFirstNodeName ) , NODE_DESC_SIZE )

	IF ( cFldRes1Father <> NIL )
		If ValType(cFldRes1Father) == "B"
			cResource1	:= Eval(cFldRes1Father)
		Else
			cResource1	:= Eval( FieldWBlock( cFldRes1Father, Select( cAliasFather ) ) )
		EndIf
	Else
		cResource1	:= "PMSTASK1"
	EndIF

	IF ( cFldRes2Father <> NIL )
		If ValType(cFldRes1Father) == "B"
			cResource2	:= Eval(cFldRes2Father)
		Else
			cResource2	:= Eval( FieldWBlock( cFldRes2Father , Select( cAliasFather ) ) )
		EndIF
	Else
		cResource2	:= "PMSTASK2"
	EndIF

	cMainGroup	:= Replicate( "0" , Len( ( cdbTreeAlias )->( Eval( bTreeField ) ) ) )
	BldTreeNodes( @aTreeNodes , cMainGroup , cMainGroup , cFirstNodeName , NIL , cResource1 , cResource2 , .F. , nRegFather )

	( cdbTreeAlias )->( dbSetOrder( nItemOrder ) )
	cKeyFather	:= ( xFilial( cdbTreeAlias , cFilFather ) + cKeyFather )
	( cdbTreeAlias )->( MsSeek( cKeyFather , .F. ) )

	ApdSupNodes(;
					cMainGroup		,;
					cdbTreeAlias	,;
					cKeyFather		,;
					bItemField		,;
					bDescField		,;
					nTreeOrder		,;
					bTreeField		,;
					nItemOrder	 	,;
					bTreeGetDet		,;
					bRes1Field		,;
					bRes2Field		,;
					@cLastItemNum	,;
					bAddNodes       ,;
					abDados			,;
					lFullTree		;
				 )

	aMainTree[ nPosMainGrp , 4 ] := aClone( aTreeNodes )

Else

	aTreeNodes	:= aClone( aMainTree[ nPosMainGrp , 4 ] )
	cKeyFather	:= ( xFilial( cdbTreeAlias , cFilFather ) + cKeyFather )

EndIF

aLstMainTree[ nLstMainGrp , 4 ] := aClone( aTreeNodes )

Return( aTreeNodes )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdSupNodes  ЁAutorЁMarinaldo de Jesus    Ё Data Ё17/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMonta os Grupos para a Montagem do dbTree                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdSupNodes(	cMainGroup		,;
								cdbTreeAlias	,;
								cKeyFather		,;
								bItemField		,;
								bDescField		,;
								nTreeOrder		,;
								bTreeField		,;
								nItemOrder		,;
								bTreeGetDet		,;
								bRes1Field		,;
								bRes2Field		,;
								cLastItemNum	,;
						   		bAddNodes       ,;
								abDados			,;
								lFullTree		;
						    )

Local aAreaAnt		:= GetArea()
Local aArea			:= ( cdbTreeAlias )->( GetArea() )
Local aRecnos		:= {}
Local bWhile		:= { || .F. }

Local cSeek
Local cSeekItem
Local cIndexKey
Local nSizeSeek
Local nLoop
Local nLoops
DEFAULT lFullTree		:= .T.

( cdbTreeAlias )->( dbSetOrder( nTreeOrder ) )
cIndexKey := ( cdbTreeAlias )->( IndexKey() )
IF ( ( cdbTreeAlias )->( MsSeek( cSeek := ( cKeyFather + cMainGroup ) , .F. ) ) )
	bWhile	:= { || ( cSeekItem := SubStr( __ExecMacro( cIndexKey ) , 1 , nSizeSeek ) ) == cSeek }
	nSizeSeek := Len( cSeek )
	While ( ( cdbTreeAlias )->( !Eof() .and. Eval( bWhile ) ) )
		IF ( ( cdbTreeAlias )->( Eval( bTreeGetDet ) ) )
			aAdd( aRecnos , ( cdbTreeAlias )->( Recno() ) )
		EndIF
		( cdbTreeAlias )->( dbSkip() )
	End While
EndIF

IF ( ( nLoops := Len( aRecnos ) ) > 0 )
	For nLoop := 1 To nLoops
		( cdbTreeAlias )->( dbGoTo( aRecnos[ nLoop ] ) )
		ApdSubNodes(	cdbTreeAlias		,;
						bItemField			,;
						bDescField			,;
						cKeyFather			,;
						nTreeOrder			,;
						bTreeField			,;
						bTreeGetDet			,;
						bRes1Field			,;
						bRes2Field		 	,;
						@cLastItemNum		,;
						bAddNodes           ,;
						abDados				,;
						lFullTree			,;
						.T.					;
					 )
	Next nLoop
EndIF

RestArea(aArea)
RestArea(aAreaAnt)

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdSubNodes  ЁAutorЁMarinaldo de Jesus    Ё Data Ё17/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMonta os Sub-Grupos para a Montagem do dbTree               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdSubNodes(	cdbTreeAlias	,;
								bItemField		,;
								bDescField		,;
								cKeyFather		,;
								nTreeOrder		,;
								bTreeField		,;
								bTreeGetDet		,;
								bRes1Field		,;
								bRes2Field		,;
								cLastItemNum	,;
								bAddNodes       ,;
								abDados			,;
								lFullTree		,;
								lFirst			;
							 )
Local aRecnos	:= {}

Local cDesc
Local cSeek
Local cSeekItem
Local cIndexKey
Local cGrupoInc
Local cGrupoSup
Local cResource1
Local cResource2
Local nSizeSeek
Local nLoop
Local nLoops             	
Local acDados
Local nX

DEFAULT bRes1Field		:= { || "PMSTASK1" }
DEFAULT bRes2Field		:= { || "PMSTASK2" }
DEFAULT bAddNodes       := { || .T. }
DEFAULT lFullTree		:= .T.
DEFAULT lFirst			:= .F.

cGrupoInc		:= ( cdbTreeAlias )->( Eval( bItemField ) )
DEFAULT cLastItemNum	:= cGrupoInc
cLastItemNum    := IF( ( cGrupoInc > cLastItemNum ) , cGrupoInc , cLastItemNum )

cDesc 			:= ( PadR(( cdbTreeAlias )->( Eval( bDescField ) ) , NODE_DESC_SIZE ) )  //cDesc 			:= ( PadR( cGrupoInc + " - " + ( cdbTreeAlias )->( Eval( bDescField ) ) , NODE_DESC_SIZE ) )

IF Len(abDados) > 0
	acDados:= Array(Len(abDados))
	For nX:= 1 to Len(abDados)
		acDados[nX] := (cdbTreeAlias )->( Eval( abDados[nX] ) ) 
	Next nX
Endif

cGrupoSup		:= ( cdbTreeAlias )->( Eval( bTreeField ) )
cResource1		:= Upper( AllTrim( ( cdbTreeAlias )->( Eval( bRes1Field ) ) ) )
cResource2		:= Upper( AllTrim( ( cdbTreeAlias )->( Eval( bRes2Field ) ) ) )

If Eval( bAddNodes )
	BldTreeNodes( @aTreeNodes , cGrupoSup , cGrupoInc , cDesc , NIL , cResource1 , cResource2 , .F. , ( cdbTreeAlias )->( Recno() ) ,;
					acDados;
					)
EndIf

If !lFullTree .And. !lFirst
	Return
EndIf

( cdbTreeAlias )->( dbSetOrder( nTreeOrder ) )
cIndexKey	:= ( cdbTreeAlias )->( IndexKey() )
cSeek		:= ( cKeyFather + cGrupoInc )
IF ( ( cdbTreeAlias )->( dbSeek( cSeek , .F. ) ) )

	nSizeSeek := Len( cSeek )

	While (( cdbTreeAlias )->(!Eof() .and. (( cSeekItem := SubStr( __ExecMacro( cIndexKey ), 1, nSizeSeek ) ) == cSeek )))
		IF ( ( cdbTreeAlias )->( Eval( bTreeGetDet ) ) )
			aAdd( aRecnos , ( cdbTreeAlias )->( Recno() ) )
		EndIF
		( cdbTreeAlias )->( dbSkip() )
	End While

	nLoops := Len( aRecnos )
	For nLoop := 1 To nLoops
		( cdbTreeAlias )->( dbGoTo( aRecnos[ nLoop ] ) )
		ApdSubNodes(	cdbTreeAlias		,;
						bItemField			,;
						bDescField			,;
						cKeyFather			,;
						nTreeOrder			,;
						bTreeField			,;
						bTreeGetDet			,;
						bRes1Field			,;
						bRes2Field		 	,;
						@cLastItemNum		,;
						bAddNodes			,;
						abDados				,;
						lFullTree			;
					 )
	Next nLoop

EndIf

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGetTreeNodes ЁAutorЁMarinaldo de Jesus    Ё Data Ё24/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna aTreeNodes                                          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGENERICO 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetTreeNodes()
Return( aTreeNodes )

/*/
зддддддддддбдддддддддддддддбдддддбддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGetCutTreeNodesЁAutorЁMarinaldo de Jesus  Ё Data Ё24/08/2004Ё
цддддддддддедддддддддддддддадддддаддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna aCutTreeNodes                                       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGENERICO 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetCutTreeNodes()
Return( aCutTreeNodes )

/*/
зддддддддддбдддддддддддддддбдддддбддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁClsCutTreeNodesЁAutorЁMarinaldo de Jesus  Ё Data Ё01/09/2004Ё
цддддддддддедддддддддддддддадддддаддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa aCutTreeNodes                                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGENERICO 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ClsCutTreeNodes()
aCutTreeNodes := {}
Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGetCopyTreeNodesЁAutorЁMarinaldo de Jesus Ё Data Ё25/08/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna aCopyTreeNodes                                      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGENERICO 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetCopyTreeNodes()
Return( aCopyTreeNodes )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁClsCopyTreeNodesЁAutorЁMarinaldo de Jesus Ё Data Ё01/09/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa aCopyTreeNodes                                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGENERICO 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ClsCopyTreeNodes()
aCopyTreeNodes := {}
Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeMaxItem   ЁAutorЁMarinaldo de Jesus   Ё Data Ё31/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna a Maior Numeracao do Item do Tree                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeMaxItem( aTreeNodes , cMaxItem )

Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	DEFAULT cMaxItem := aTreeNodes[ nLoop , NODE_INFERIOR ]
	IF ( cMaxItem < aTreeNodes[ nLoop , NODE_INFERIOR ] )
		cMaxItem := aTreeNodes[ nLoop , NODE_INFERIOR ]
	EndIF
	cMaxItem := NodeMaxItem( aTreeNodes[ nLoop , NODE_TREE ] , cMaxItem )
Next nLoop

Return( cMaxItem )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeMaxSeq	  ЁAutorЁMarinaldo de Jesus   Ё Data Ё31/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna a Maior Sequencia Tree                   		    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeMaxSeq( aTreeNodes , cMaxSeq )

Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	DEFAULT cMaxSeq := aTreeNodes[ nLoop , NODE_SEQ ]
	IF ( cMaxSeq < aTreeNodes[ nLoop , NODE_SEQ ] )
		cMaxSeq := aTreeNodes[ nLoop , NODE_SEQ ]
	EndIF
	cMaxSeq := NodeMaxSeq( aTreeNodes[ nLoop , NODE_TREE ] , cMaxSeq )
Next nLoop

Return( cMaxSeq )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetSup    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Node Superior                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeGetSup( aTreeNodes , cNode )

Local cNodeSup := cNode

NodeExtSup( aTreeNodes , @cNodeSup )

Return( cNodeSup )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeExtSup    ЁAutorЁMarinaldo de Jesus   Ё Data Ё01/01/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Existe Node Superior e Retorna-o por Referencia Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeExtSup( aTreeNodes , cNode , cSeq )

Local lSeq		:= ( cSeq <> NIL )
Local lExtSup	:= .F.

Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			lExtSup := (;
							( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
							.and.;
							IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
						);
		)
		cNode := aTreeNodes[ nLoop , NODE_SUPERIOR ]
		Exit
	Else
		IF ( lExtSup := ( NodeExtSup( aTreeNodes[ nLoop , NODE_TREE ] , @cNode , cSeq ) ) )
			Exit
		EndIF
	EndIF
Next nLoop

Return( lExtSup )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetPrompt ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Conteudo do Resource2 do Node                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeGetPrompt( aTreeNodes , cNode , cSeq )

Local lSeq	:= ( cSeq <> NIL )

Local cPrompt
Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
			.and.;
			IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
		)
		cPrompt := aTreeNodes[ nLoop , NODE_PROMPT ]
    	Exit
    Else
    	cPrompt := NodeGetPrompt( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
		IF ( cPrompt <> NIL )
			Exit
		EndIF
    EndIF
Next nLoop

Return( cPrompt )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeSetPrompt ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSeta Conteudo do Resource2 do Node                          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeSetPrompt( aTreeNodes , cNode , cSeq , cPrompt )

Local lSetRes	:= .F.
Local lSeq		:= ( cSeq <> NIL )

Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			lSetRes := (;
							( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
							.and.;
							IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
						);
		)
		aTreeNodes[ nLoop , NODE_PROMPT ] := cPrompt
    	Exit
    Else
    	IF ( lSetRes := NodeSetPrompt( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq , cPrompt ) )
    		Exit
    	EndIF
    EndIF
Next nLoop

Return( lSetRes )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeSetSeq    ЁAutorЁMarinaldo de Jesus   Ё Data Ё02/09/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSeta a Sequencia do Node                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeSetSeq( aTreeNodes , cNode , cSeq )

Local lSetSeq := .F.

Local nLoop
Local nLoops


nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			( aTreeNodes[ nLoop , NODE_ACTIVE ] );
			.and.;
			( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
		)
		lSetSeq := .T.
		aTreeNodes[ nLoop , NODE_SEQ ] := cSeq
		Exit
	EndIF
	lSetSeq := NodeSetSeq( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
	IF ( lSetSeq )
		Exit
	EndIF
Next nLoop

Return( lSetSeq )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetSeq    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna a Sequencia do Node                                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeGetSeq( aTreeNodes , cNode , aNotSeqs )

Local lNoSeq := ( aNotSeqs <> NIL )

Local cSeq
Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
			.and.;
			IF( lNoSeq , ( aScan( aNotSeqs , aTreeNodes[ nLoop , NODE_SEQ ] ) == 0 ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
		)
		cSeq := aTreeNodes[ nLoop , NODE_SEQ ]
		IF ( lNoSeq )
			aAdd( aNotSeqs , cSeq )
		EndIF
		Exit
	Else
		cSeq := NodeGetSeq( aTreeNodes[ nLoop , NODE_TREE ] , cNode , @aNotSeqs )
		IF !Empty( cSeq )
			Exit
		EndIF
	EndIF
Next nLoop

Return( cSeq )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetTree   ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Tree de Sub-Itens do Node		                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeGetTree( aTreeNodes , cNode , cSeq )

Local lSeq		:= ( cSeq <> NIL )

Local aTreeSup
Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
			.and.;
			IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
		)
			aTreeSup := aClone( aTreeNodes[ nLoop , NODE_TREE ] )
			Exit
	Else
		aTreeSup := NodeGetTree( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
		IF ( aTreeSup <> NIL )
			Exit
		EndIF
	EndIF
Next nLoop

Return( aTreeSup )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetSub    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Array com Todos os Sub-Itens do Node		        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeGetSub( aTreeNodes , cNode , cSeq , lAddTree , aNodeGetSub )

Local lSeq	:= ( cSeq <> NIL )

Local nLoop
Local nLoops

DEFAULT aNodeGetSub := {}
DEFAULT lAddTree	:= .F.

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			( aTreeNodes[ nLoop , NODE_SUPERIOR ] == cNode );
			.and.;
			IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
		)
		aAdd( aNodeGetSub , { aTreeNodes[ nLoop , NODE_INFERIOR ] , IF( lAddTree , aClone( aTreeNodes[ nLoop , NODE_TREE ] ) , {} ) } )
	EndIF
	NodeGetSub( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq , lAddTree , @aNodeGetSub )
Next nLoop

Return( aNodeGetSub )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetAct    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Status do Node                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeGetAct( aTreeNodes , cNode , cSeq )

Local lSeq	:= ( cSeq <> NIL )

Local lNodeAct
Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
			.and.;
			IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
		)
		lNodeAct := aTreeNodes[ nLoop , NODE_ACTIVE ]
    	Exit
    Else
    	lNodeAct := NodeGetAct( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
		IF ( lNodeAct <> NIL )
			Exit
		EndIF
    EndIF
Next nLoop

Return( lNodeAct )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeRetCol    ЁAutorЁMarinaldo de Jesus   Ё Data Ё01/09/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna aCols com Todos os Itens de aCols do aTreeNodes     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeRetCol( aTreeNodes , aCols )

Local nLoop
Local nLoops

DEFAULT aCols := {}

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF !Empty( aTreeNodes[ nLoop , NODE_ACOLS ] )
		aAdd( aCols , aClone( aTreeNodes[ nLoop , NODE_ACOLS ] ) )
	EndIF
	NodeRetCol( aTreeNodes[ nLoop , NODE_TREE ] , @aCols )
Next nLoop

Return( aCols )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetCol    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Conteudo do aCols do Node                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeGetCol( aTreeNodes , cNode , cSeq )

Local lSeq	:= ( cSeq <> NIL )

Local aCols
Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
			.and.;
			IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
		)
		IF !Empty( aTreeNodes[ nLoop , NODE_ACOLS ] )
			aCols := aClone( aTreeNodes[ nLoop , NODE_ACOLS ] )
		Else
			aCols := {}
		EndIF
    	Exit
    Else
    	aCols := NodeGetCol( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
		IF ( aCols <> NIL )
			Exit
		EndIF
    EndIF
Next nLoop

Return( aCols )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeSetCol    ЁAutorЁMarinaldo de Jesus   Ё Data Ё20/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSeta o Conteudo do aCols do Node                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeSetCol( aTreeNodes , cNode , cSeq , aCols )

Local lSeq		:= ( cSeq <> NIL )
Local lSetaCols	:= .F.

Local nLoop
Local nLoops

DEFAULT aCols := {}

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			lSetaCols := (;
								( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
								.and.;
								IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
						 );
		)
		aTreeNodes[ nLoop , NODE_ACOLS ] := aClone( aCols )
    	Exit
    Else
		lSetaCols := NodeSetCol( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq , aCols )
		IF ( lSetaCols )
			Exit
		EndIF
    EndIF
Next nLoop

Return( lSetaCols )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetRs1    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Conteudo do Resource1 do Node                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeGetRs1( aTreeNodes , cNode , cSeq )

Local lSeq	:= ( cSeq <> NIL )

Local cResource
Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
			.and.;
			IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
		)
		cResource := aTreeNodes[ nLoop , NODE_RESOURCE1 ]
    	Exit
    Else
    	cResource := NodeGetRs1( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
		IF ( cResource <> NIL )
			Exit
		EndIF
    EndIF
Next nLoop

Return( cResource )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeSetRs1    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSeta o Conteudo do Resource1 do Node                        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeSetRs1( aTreeNodes , cNode , cSeq , cResource )

Local lSetRes	:= .F.
Local lSeq		:= ( cSeq <> NIL )

Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			lSetRes := (;
							( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
							.and.;
							IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
						);
		)
		aTreeNodes[ nLoop , NODE_RESOURCE1 ] := cResource
    	Exit
    Else
    	IF ( lSetRes := NodeSetRs1( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq , cResource ) )
    		Exit
    	EndIF
    EndIF
Next nLoop

Return( lSetRes )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetRs2    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Conteudo do Resource2 do Node                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeGetRs2( aTreeNodes , cNode , cSeq )

Local lSeq	:= ( cSeq <> NIL )

Local cResource
Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
			.and.;
			IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
		)
		cResource := aTreeNodes[ nLoop , NODE_RESOURCE1 ]
    	Exit
    Else
    	cResource := NodeGetRs2( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
		IF ( cResource <> NIL )
			Exit
		EndIF
    EndIF
Next nLoop

Return( cResource )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeSetRs2    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSeta Conteudo do Resource2 do Node                          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function NodeSetRs2( aTreeNodes , cNode , cSeq , cResource )

Local lSetRes	:= .F.
Local lSeq		:= ( cSeq <> NIL )

Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			lSetRes := (;
							( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
							.and.;
							IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
						);
		)
		aTreeNodes[ nLoop , NODE_RESOURCE1 ] := cResource
    	Exit
    Else
    	IF ( lSetRes := NodeSetRs2( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq , cResource ) )
    		Exit
    	EndIF
    EndIF
Next nLoop

Return( lSetRes )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁBldTreeNodes ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInclusao de novo Grupo/Item no Tree                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function BldTreeNodes(	aTreeNodes		,;
						cSuperior		,;
						cInferior		,;
						cPrompt			,;
						aCols			,;
						cResource1		,;
						cResource2		,;
						lForceAddNew	,;
						nRecno			,; 
						acDados			;
					 )

Local lAddOk	:= .F.

Local nLoop
Local nLoops

DEFAULT lForceAddNew	:= .F.
DEFAULT acDados			:= {}

Begin Sequence

	IF ( lAddOk := (( ( nLoops := Len( aTreeNodes ) ) == 0 ) .or. ( lForceAddNew )))
			AddNewNode( aTreeNodes, cInferior, cSuperior, cPrompt, aCols, cResource1, cResource2, nRecno, acDados)
		Break
	Else
		For nLoop := 1 To nLoops
			IF ( aTreeNodes[ nLoop , NODE_ACTIVE ] )
				IF ( lAddOk := ( aTreeNodes[ nLoop , NODE_INFERIOR ] == cSuperior ) )
						AddNewNode( @aTreeNodes[ nLoop , NODE_TREE ] , cInferior , cSuperior , cPrompt , aCols , cResource1 , cResource2 , nRecno ,;
					acDados;
					)
					Break
				EndIF
				IF ( Len( aTreeNodes[ nLoop , NODE_TREE ] ) > 0 ) .And. ApdNoExistNode(aTreeNodes,cInferior)
					IF ( lAddOk := BldTreeNodes( @aTreeNodes[ nLoop , NODE_TREE ] , cSuperior , cInferior , cPrompt , aCols , cResource1 , cResource2 , .F. , nRecno ,;
												acDados;
												) )
						Break
					EndIF
				EndIF
			EndIF
		Next nLoop
	EndIF

End Sequence

Return( lAddOk )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁAddNewNode	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInclusao de novo Grupo/Item no Tree                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function AddNewNode(		aTreeNodes	,;
								cInferior	,;
								cSuperior	,;
								cPrompt		,;
								aCols		,;
								cResource1	,;
								cResource2	,;
								nRecno		,; 
								acDados		;
						  )

Local aNode := Array( NODE_ELEMENTS )

DEFAULT aCols := {}
DEFAULT acDados	:= {}

aNode[ NODE_INFERIOR 	]	:= cInferior
aNode[ NODE_SUPERIOR 	]	:= cSuperior
aNode[ NODE_PROMPT   	]	:= cPrompt
aNode[ NODE_ACOLS	 	]	:= aClone( aCols )
aNode[ NODE_ACTIVE   	]	:= .T.
aNode[ NODE_TREE     	]	:= {}
IF ( ApdTUseSeq() )
	cLastSeq := Soma1( cLastSeq )
EndIF
aNode[ NODE_SEQ			]	:= cLastSeq
aNode[ NODE_RESOURCE1	]	:= cResource1
aNode[ NODE_RESOURCE2	]	:= cResource2
aNode[ NODE_RECNO		] 	:= nRecno
aNode[ NODE_DADOS		] 	:= acDados

aAdd( aTreeNodes , aClone( aNode ) )

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁDelTreeNodes ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁExclusao de novo Grupo/Item no Tree                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function DelTreeNodes( aTreeNodes , cNodeExc , lRemove )

Local nDeleted	:= 0

Local nLoop
Local nLoops

DEFAULT lRemove := .F.

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF ( aTreeNodes[ nLoop , NODE_ACTIVE ] )
		IF ( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNodeExc )
			aTreeNodes[ nLoop , NODE_ACTIVE ] := .F.
			IF ( lRemove )
				aDel( aTreeNodes ,  nLoop )
				++nDeleted
				Exit
			EndIF
			IF ( Len( aTreeNodes[ nLoop , NODE_TREE ] ) > 0 )
				DelTreeNodes( @aTreeNodes[ nLoop , NODE_TREE ] , aTreeNodes[ nLoop , NODE_TREE , 01 , NODE_INFERIOR ] , lRemove )
			EndIF
		Else
			DelTreeNodes( aTreeNodes[ nLoop , NODE_TREE ] , cNodeExc , lRemove )
		EndIF
	EndIF
Next nLoop

IF (;
		( lRemove );
		.and.;
		( nDeleted > 0 );
	)
	aSize( aTreeNodes , ( nLoops - nDeleted ) )
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdDbTree    ЁAutorЁMarinaldo de Jesus    Ё Data Ё17/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁChamada a dbTree com Carga das Informacoes Iniciais         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdDbTree(	adbTree			,;
							oTreeDlg		,;
							bTreeInit		,;
							bTreeRClicked	,;
							bTreeChange		,;
							aObjSize		,;
							nWidthTree		,;
							bTreeDbClick	,;
							bTreeClick		,;
							lFullTree		;
						 )

Local oTree			:= dbTree():New( aObjSize[01,01] , aObjSize[01,02] , aObjSize[01,03] , ( aObjSize[01,04] / 100 * nWidthTree ) , oTreeDlg , NIL , NIL , .T. )

Local cMainGroup
Local nLoop
Local nLoops

DEFAULT bTreeDbClick := {||}
DEFAULT bTreeClick	 := {||}

oTree:lVisibleControl := .F.	//:Hide()
	nLoops := Len( adbTree )
	For nLoop := 1 To nLoops
		cMainGroup := ( "*-" + adbTree[ nLoop , NODE_SUPERIOR ] )
		DBADDTREE oTree PROMPT adbTree[ nLoop , NODE_PROMPT ] RESOURCE adbTree[ nLoop , NODE_RESOURCE1 ],adbTree[ nLoop , NODE_RESOURCE2 ] CARGO cMainGroup OPEN
			Proc2BarGauge( { || ApdSupTree( adbTree[ nLoop , NODE_TREE ] , @oTree , cMainGroup , Time(), lFullTree ) } , OemToAnsi(STR0005) , NIL , NIL , .F. , .T. , .T. , .T. )
		DBENDTREE oTree
	Next nLoop
oTree:lVisibleControl := .T.	//:Show()

oTree:bRClicked  		:= bTreeRClicked
oTree:bChange			:= bTreeChange
oTree:blDblClick		:= bTreeDbClick
oTree:blClicked			:= bTreeClick

IF ( ValType( bTreeInit ) == "B" )
	Eval( bTreeInit )
EndIF

Return( oTree )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdSupTree   ЁAutorЁMarinaldo de Jesus    Ё Data Ё17/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMonta os Grupos do Tree                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdSupTree( adbTree , oTree , cMainGroup , cTimeIni, lFullTree )

Local nLoop
Local nLoops
Local nContPrc
Local nSubTree

oTree:TreeSeek( cMainGroup )

DEFAULT nSeedTree := 1000

IF ( ( nLoops := Len( adbTree ) ) > 0 )
	BarGauge1Set( nLoops )
	IncProcG1( STR0034 , .F. )	 //'Incluindo Grupo'
	nContPrc := Aleatorio( 15000 , @nSeedTree )
	oTree:BeginUpdate()
		For nLoop := 1 To nLoops
			IncPrcG1Time( STR0034 + ": " + AllTrim( Str( nLoop ) ) , nLoops , cTimeIni , .F. , nContPrc , 1 ) //'Incluindo Grupo'
			ApdSubTree(;
							adbTree[ nLoop , NODE_TREE ],;
							@oTree,;
							cMainGroup,;
							adbTree[ nLoop , NODE_PROMPT ],;
							( "+-" + adbTree[ nLoop , NODE_INFERIOR ] ),;
			 				adbTree[ nLoop , NODE_RESOURCE1 ],;
			 				adbTree[ nLoop , NODE_RESOURCE2 ],;
							cTimeIni,;
							@nSubTree,;
							lFullTree;
						)
		Next nLoop
	oTree:EndUpdate()
EndIF

oTree:TreeSeek( cMainGroup )

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdSubTree	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё17/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMonta os Sub-Grupos do Tree                                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdSubTree(		adbTree		,;
								oTree		,;
								cSupTree	,;
								cNewDesc	,;
								cNewItem	,;
								cResource1	,;
								cResource2	,;
								cTimeIni	,;
								nSubTree	,;
								lFullTree	,;
								lPula		;
						  )

Local a2BarSet
Local nLoop
Local nLoops
Local nContPrc

DEFAULT cResource1	:= "PMSTASK1"
DEFAULT cResource2	:= "PMSTASK2"
DEFAULT nSubTree	:= 0
DEFAULT lPula		:= .F.

If !lPula
	oTree:TreeSeek( cSupTree )
	oTree:AddItem( cNewDesc , cNewItem , cResource1 , cResource2 , NIL , NIL , 2 )
	//oTree:TreeSeek( cNewItem )
EndIf

IF ( ( nLoops := Len( adbTree ) ) > 0 )
	BarGauge2Set( nLoops )
	IncProcG2( STR0035 , .F. )	//'Incluindo Sub-Grupo'
	nContPrc	:= Aleatorio( 15000 , @nSeedTree )
	If !lFullTree //Carrega apenas o primeiro item para que nС seja criado, os demais itens nЦo serao carregados para melhoria de performance, e deverА ser atualizado quando o nС for expandido. 
		nLoops := 1
	EndIf
	For nLoop := 1 To nLoops
		If lPula .and. nLoop == 1
			Loop
		EndIf
		++nSubTree
		IncPrcG2Time( STR0035 + ": " + AllTrim( Str( nSubTree ) ) , nLoops , cTimeIni , .F. , nContPrc , 1 )	//'Incluindo Sub-Grupo'
		a2BarSet := Get2BarSet()
			ApdSubTree(;
			 				adbTree[ nLoop , NODE_TREE ],;
			 				@oTree,;
			 				cNewItem,;
			 				adbTree[ nLoop , NODE_PROMPT ],;
			 				( "+-" + adbTree[ nLoop , NODE_INFERIOR ] ),;
			 				adbTree[ nLoop , NODE_RESOURCE1 ],;
			 				adbTree[ nLoop , NODE_RESOURCE2 ],;
			 				cTimeIni,;
			 				@nSubTree,;
			 				lFullTree;
			 			)
		Rst2BarSet( a2BarSet )
	Next nLoop
EndIF

oTree:TreeSeek( cSupTree )
If !lFullTree
	oTree:ptcollapse() //Deixa os itens filhos recolhidos por DEFAULT
EndIf

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdBldMnuTreeЁAutorЁMarinaldo de Jesus    Ё Data Ё12/09/2003Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCria e Retorna Menu para Estruturacao do Tree               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdBldMnuTree( aMenuPopUp , aMenuDisable )

Local aDsbMenu
Local nMenu
Local nMenus
Local nLoop
Local nLoops
Local oMenu

oMenu := MenuBegin( NIL , NIL , NIL , NIL , .T. , NIL , NIL , NIL )
	nMenus := Len( aMenuPopUp )
    For nMenu := 1 To nMenus
		MenuAddItem(;
						aMenuPopUp[ nMenu , 01 ],;
						NIL	,;
						.F.	,;
						NIL	,;
						aMenuPopUp[ nMenu , 02 ],;	//5
						NIL	,;
						NIL	,;
						NIL	,;
						NIL	,;
						NIL	,;						//10
						NIL	,;
						.F.	,;
						NIL	,;
						NIL	,;
						.F.	 ;
					 )
		IF (;
				( Len( aMenuPopUp[ nMenu ] ) >= 04 );
				.and.;
				( ValType( aMenuPopUp[ nMenu , 04 ] ) == "A" );
			)
			MenuBegin( NIL , NIL , NIL , NIL , .T. , NIL , NIL , NIL )
				aDsbMenu := {}
				IF ( aScan( aMenuDisable , { |x| ( x == nMenu ) } ) > 0 )
					nLoops := Len( aMenuPopUp[ nMenu , 04 ] )
					For nLoop := 1 To nLoops
						aAdd( aDsbMenu , nLoop )
					Next nLoop
				EndIF
				ApdBldMnuTree( aMenuPopUp[ nMenu , 04 ] , aDsbMenu )
			MenuEnd()
		EndIF

		IF ( aScan( aMenuDisable , { |x| ( x == nMenu ) } ) > 0 )
			aMenuPopUp[ nMenu , 03 ] := .F.
		EndIF

		IF !( aMenuPopUp[ nMenu , 03 ] )
			oMenu:aItems[ nMenu ]:Disable()
		EndIF

		oMenu:aItems[ nMenu ]:bValid := { || Alert( aMenuPopUp[ nMenu , 01 ] ) , .T. }
		//oMenu:aItems[ nMenu ]:SetCheck(.F.)
	Next nMenu
MenuEnd()

Return( oMenu )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreeSeek  ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁEfetua pesquisa no Tree                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdTreeSeek( oTree , cGrp , cdbTreeF3 , nSize )

Local aSvKeys	:= GetKeys()
Local cKeySeek	:= Space( nSize )

Local nOpcA		:= 0
Local aAdvSize		:= {}
Local aObjCoords	:= {}
Local aObjSize		:= {}
Local aGdsCoords	:= {}
Local bSet15		:= { || NIL }
Local bSet24		:= { || NIL }

Local oDlg
Local oBut1
Local oBut2
Local oGetPesq

DEFAULT cGrp := ""

aAdvSize		:= MsAdvSize( .T. , .T. , 50 )
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
aObjCoords		:= { { 0 , 0 , .T. , .T. } }
aObjSize 		:= MsObjSize( aInfoAdvSize , aObjCoords )

DEFINE MSDIALOG oDlg FROM 0,0 TO 100,440 TITLE OemToAnsi( STR0001 ) PIXEL //'Pesquisar' 0,0 TO 005,035 

	DEFINE FONT oBold NAME "Arial" 			SIZE  0, -13 BOLD

	@ aObjSize[1][1]+5,aObjSize[1][2]+10 SAY OemToAnsi(STR0011)		SIZE 040,010 PIXEL FONT oBold //'Item:'  012.5,005 
	@ aObjSize[1][1]+5,aObjSize[1][2]+50 MSGET oGetPesq VAR cKeySeek	SIZE nSize,010 VALID .T. PIXEL  //010.0,025
	IF !Empty( cdbTreeF3 )
		oGetPesq:cF3 := cdbTreeF3
	EndIF

	bSet15	:= { || nOpcA := 1 , oDlg:End() }
	bSet24	:= { || nOpcA := 0 , oDlg:End() }

ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 )

IF ( nOpcA == 1 )
	IF !( oTree:TreeSeek( cGrp + AllTrim( cKeySeek ) ) )
		MsgInfo( OemToAnsi( STR0010 ) , OemToAnsi( STR0007 ) ) //'N└o existe ║tem pesquisado...'###'Aten┤└o!'
	EndIF
EndIF

RestKeys( aSvKeys , .T. )

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreeVis   ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVisualizar Detalhes do Item do Tree                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdTreeVis(	oTree , cKeyFather , cdbTreeAlias , nItemOrder )

Local aSvKeys	:= GetKeys()

Local cCargo

IF ( Left( ( cCargo := oTree:GetCargo() ) , 1 ) == "+" )

	( cdbTreeAlias )->( dbSetOrder( nItemOrder ) )

	IF ( ( cdbTreeAlias )->( MsSeek( cKeyFather + SubStr( cCargo , 3 ) , .F. ) ) )
		SetMemoFields( cdbTreeAlias , GetMemoDb( cdbTreeAlias ) )	//Seta os Campos Memos Virtuais
		AxVisual( cdbTreeAlias, ( cdbTreeAlias )->( Recno() ) , 2 )
	EndIF

EndIF

RestKeys( aSvKeys , .T. )

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreeInc	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInclui Novo Item no Tree                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdTreeInc( oTree			,; //01
							aTreeNodes		,; //02
							cKeyFather		,; //03
							cdbTreeAlias	,; //04
							bItemField		,; //05
							bDescField		,; //06
							nItemOrder		,; //07
							cSetFilConPad	,; //08
							lAllRegs		,; //09
							bTreeGetDet		,; //10 
							bRes1Field		,; //11
							bRes2Field		,; //12
							cdbTreeF3		,; //13
							abDados			;  //14	
						   )

Local aSvKeys		:= GetKeys()
Local nAddCount		:= 0


Local bIncOption
Local bCnPdFilter
Local cbCnPdFilter
Local cDesc 

Local acDados  
Local nX

Local cCargo
Local cNewInc
Local cAddItem
Local cGrpInc
Local cItemSeekKey
Local cIndexKey
Local cFilterKey
Local cLastAddItem
Local cResource1:= Eval(bRes1Field)
Local cResource2:= Eval(bRes2Field)
Local lFound
Local lMaster
Local lConPad1
Local nIncOption
Local nAt
Local nItenSeekKey

DEFAULT lAllRegs	:= .F.
DEFAULT abDados		:= {}

Begin Sequence

	IF !( lAllRegs )

		IF (;
				!Empty( cSetFilConPad );
				.and.;
				FindFunction( cSetFilConPad );
			)
			Public aApdFltTree	:= aClone( aTreeNodes ) //Public aqui para Set Filter em ConPad1, nao retirar (by naldo)
			Public bGetDetTree	:= bTreeGetDet			//Public aqui para Set Filter em ConPad1, nao retirar (by naldo)
			Public cApdFltKey	:= ""                  	//Public aqui para Set Filter em ConPad1, nao retirar (by naldo)
			cbCnPdFilter		:= "{ |cKeyFilter| cApdFltKey := cKeyFilter , ApdNoExistNode( aApdFltTree , cApdFltKey ) .and. Eval( bGetDetTree ) }"
			IF ( ( nAt := At( "(" , cSetFilConPad ) ) > 0 )
				cSetFilConPad := SubStr( cSetFilConPad , 1 , --nAt )
			EndIF
			__ExecMacro( cSetFilConPad + "(" + cbCnPdFilter + ")" )
		EndIF

		MsAguarde( { || lConPad1 := ConPad1( NIL , NIL , NIL , IIF(Empty(cdbTreeF3), cdbTreeAlias, cdbTreeF3) , NIL , NIL , .F. ) } )
		IF ( !( lConPad1 ) )
			Break
		EndIF

		cCargo	:= oTree:GetCargo()

		lMaster		:= ( "*-" $ cCargo )

		oTree:TreeSeek( cCargo )

		bIncOption	:= { || IF( ( lMaster ) , 2 /*/Sempre um Nivel Abaixo*/ , Aviso( OemToAnsi( STR0013 ) /*/'Inclus└o de novo ║tem'*/, OemToAnsi( STR0014 ) /*/'Selecione o n║vel'*/ , { OemToAnsi( "&"+STR0015 ) /*/'Novo Item'*/ , OemToAnsi( "&"+STR0016 ) /*/'Sub-Item'*/ } ) ) }

	Else

		CursorWait()

		( cdbTreeAlias )->( dbSetOrder( nItemOrder ) )
		cIndexKey		:= ( cdbTreeAlias )->( IndexKey() )

		cItemSeekKey	:= cKeyFather
		nItenSeekKey	:= Len( cItemSeekKey )

		( cdbTreeAlias )->( dbSeek( cItemSeekKey , .F. ) )

		oTree:TreeSeek( "*-" )
		cCargo			:= oTree:GetCargo()

		nIncOption      := 2

	EndIF

	bCnPdFilter	:= { |cKeyFilter| cFilterKey := cKeyFilter , !( ApdNoExistNode( aTreeNodes , cFilterKey ) ) }

	cGrpInc	:= SubStr( cCargo , 3 )
	While (;
				IF( lAllRegs ,;
								(;
									( cdbTreeAlias )->(;
														!Eof();
														.and.;
														( SubStr( __ExecMacro( cIndexKey ) , 1 , nItenSeekKey ) == cItemSeekKey );
													  );
								),;
								lConPad1;
					);
			)

		IF ( ( cdbTreeAlias )->( !( Eval( bTreeGetDet ) ) ) )
			( cdbTreeAlias )->( dbSkip() )
			Loop
		EndIF

		IF ( Empty( cNewInc := Eval( bItemField ) ) )
			//'N└o ┌ permitida a inser┤└o de ║tem em branco.'###'Aten┤└o!'
			IF ( !( lAllRegs ) )
				MsgInfo( OemToAnsi( STR0023  ) , OemToAnsi( STR0007 ) )
				Break
			Else
				( cdbTreeAlias )->( dbSkip() )
				Loop
			EndIF
		EndIF

		cAddItem := ( "+-" + cNewInc )

		IF ( lFound	:= Eval( bCnPdFilter , cNewInc ) )
			//'J═ existe o ║tem...'###'Aten┤└o!'
			IF ( !( lAllRegs ) )
				MsgInfo( OemToAnsi( STR0009 ) , OemToAnsi( STR0007 ) )
				Break
			Else
				( cdbTreeAlias )->( dbSkip() )
				Loop
			EndIF
		EndIF

		cDesc := PadR( Eval( bDescField ) , NODE_DESC_SIZE )//cDesc := PadR( cNewInc + " - " + Eval( bDescField ) , NODE_DESC_SIZE )
       
  		IF Len(abDados) > 0 
	        acDados:= Array(Len(abDados))
			For nX:= 1 to Len(abDados)
				acDados[nX] := (cdbTreeAlias )->( Eval( abDados[nX] ) ) 
			Next nX
		Endif

		IF ( !( lAllRegs ) )
			nIncOption	:= Eval( bIncOption )
		EndIF

		cResource1 := IF( Empty( cResource1 ) , "PMSTASK1" , cResource1 )
		cResource2 := IF( Empty( cResource2 ) , "PMSTASK2" , cResource2 )

		oTree:AddItem( cDesc , cAddItem , cResource1 , cResource2 , NIL , NIL , nIncOption )
		cLastAddItem	:= cAddItem
		++nAddCount

		IF ( !( lAllRegs ) )
			IF (;
					!( lMaster );
					.and.;
					( nIncOption == 1 );
				)
				cGrpInc := NodeGetSup( aTreeNodes , cGrpInc )
			EndIF
		EndIF

			BldTreeNodes( @aTreeNodes , cGrpInc , cNewInc , cDesc , NIL , cResource1 , cResource2 , .F. , ( cdbTreeAlias )->( Recno() ) ,;
						acDados;
					)

		IF ( lAllRegs )
			( cdbTreeAlias )->( dbSkip() )
		Else
			lConPad1 := .F.
		EndIF

	End While

	IF ( lAllRegs )
		CursorArrow()
	EndIF

	IF ( nAddCount > 0 )
		oTree:TreeSeek( cLastAddItem )
		IF ( lAllRegs )
			//'Novos Itens Foram Incluidos.'###'Aten┤└o!'
			//'Novo Item Foi Incluido.'
			MsgInfo( Str( nAddCount ) + " " + OemToAnsi( IF( nAddCount > 1 , STR0026 , STR0027 ) ) , OemToAnsi( STR0007 ) )
		EndIF
	Else
		oTree:TreeSeek( cCargo )
		IF ( lAllRegs )
			//'N└o existem itens a serem Incluidos.'###'Aten┤└o!'
			MsgInfo( OemToAnsi( STR0025  ) , OemToAnsi( STR0007 ) )
		EndIF
	EndIF

End Sequence

RestKeys( aSvKeys , .T. )

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdNoExistNodeЁAutorЁMarinaldo de Jesus   Ё Data Ё01/01/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Ja Existe o Node                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ApdNoExistNode( aApdFltTree , cApdFltKey )

Local lNoExistNode := .T.

Local nLoop
Local nLoops

nLoops := Len( aApdFltTree )
For nLoop := 1 To nLoops
	IF ( aApdFltTree[ nLoop , NODE_ACTIVE ] )
		IF !( lNoExistNode := !( aApdFltTree[ nLoop , NODE_INFERIOR ] == cApdFltKey ) )
			Exit
		Else
			IF ( !( lNoExistNode := ( ApdNoExistNode( aApdFltTree[ nLoop , NODE_TREE ] , cApdFltKey ) ) ) )
				Exit
			EndIF
		EndIF
	EndIF
Next nLoop

Return( lNoExistNode )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreeExc	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁExclui Item e Sub-Itens do Tree                             Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdTreeExc( oTree , aTreeNodes , bMenuVldExc , lRemove )

Local aLogGer		:= {}
Local aLogGerTitle	:= {}
Local cGrupoExc		:= SubStr( oTree:GetCargo() , 3 )
Local lExcluOk		:= .T.

Begin Sequence

	IF (;
			!( lExcluOk := ApdTreeCkExc(	@aTreeNodes		,;
											cGrupoExc		,;
											bMenuVldExc 	,;
											@aLogGer		,;
											@aLogGerTitle	 ;
								  );
		 	);
		)
		Break
	EndIF

	oTree:DelItem()
	DelTreeNodes( @aTreeNodes , cGrupoExc , lRemove )

End Sequence

IF ( !( lExcluOk ) )
	CursorArrow()
	//'Este Grupo/Sub-Grupo nЦo pode ser Excluido. Deseja visualizar o Log?'###*'Aten┤└o!'
	IF ( MsgNoYes( OemToAnsi( STR0033 ) , OemToAnsi( STR0007 ) ) )
		CursorWait()
		//'Log de Inconsistencia na Exclusao de Grupo/Sub-Grupo'
		fMakeLog( aLogGer , aLogGerTitle , NIL , NIL , FunName() , STR0012 )
	EndIF
EndIF

Return( lExcluOk )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreeCkExc ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Item e Sub-Item(ns) podem ser Excluidos         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdTreeCkExc(	aTreeNodes	,;
								cGrupoExc	,;
								bMenuVldExc ,;
								aLogGer		,;
								aLogGerTitle ;
							)

Local aLog			:= {}
Local aLogTitle		:= {}
Local lTreeChkExc	:= .T.

Local aNodesAux
Local cGrpExc
Local nLoop
Local nLoops
Local nLoop1
Local nLoops1

DEFAULT bMenuVldExc := { || .T. }

Begin Sequence

	nLoops := Len( aTreeNodes )
	For nLoop := 1 To nLoops
		IF ( aTreeNodes[ nLoop , NODE_ACTIVE ] )
			IF ( aTreeNodes[ nLoop , NODE_INFERIOR ] == cGrupoExc )
				IF ( !( lTreeChkExc := Eval( bMenuVldExc , cGrupoExc , @aLog , @aLogTitle ) ) )
					aAdd( aLogGer , aClone( aLog ) )
					If Len(aLogTitle) > 0
						aAdd( aLogGerTitle , aLogTitle[1] )
					Endif
					Break
				EndIF
				aNodesAux := aTreeNodes[ nLoop , NODE_TREE ]
				nLoops1 := Len( aNodesAux )
				For nLoop1 := 1 To nLoops1
					cGrpExc := aNodesAux[ nLoop1 , NODE_INFERIOR ]
					IF (;
							!( lTreeChkExc := ApdTreeCkExc(	aNodesAux		,;
															cGrpExc 		,;
															bMenuVldExc		,;
															@aLogGer		,;
															@aLogGerTitle	 ;
														 );
							);
						)
						Break
					EndIF
				Next nLoops1
			Else
				IF (;
						!( lTreeChkExc := ApdTreeCkExc(	aTreeNodes[ nLoop , NODE_TREE ]	,;
														cGrupoExc						,;
														bMenuVldExc						,;
														@aLogGer						,;
														@aLogGerTitle					 ;
													 );
						  );
					)
					Break
				EndIF
			EndIF
		EndIF
	Next nLoop

End Sequence

Return( lTreeChkExc )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreeCpy	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё25/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRecortar Informacoes do Tree                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdTreeCpy(	oTree			,;
							aTreeNodes		,;
							aCopyTreeNodes	,;
							aMenuPopUp		,;
							nIndEnable		,;
							bMenuVldCut 	,;
							lCut			,;
							cRes1ChgCut		,;
							cRes2ChgCut		,;
							aCutTreeNodes	 ;
						  )

Local cCargo	:= oTree:GetCargo()
Local cGrpSup	:= SubStr( cCargo , 3 )

Local cMsgInfo

Begin Sequence

	IF ( ApdExistCut( aCutTreeNodes , cGrpSup ) )
		cMsgInfo := STR0019	//'Aviso de Inconsist┬ncia!'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0039	//"N└o ┌ possivel copiar informa┤└o(■es) de ║tem(ns) recortados.'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0021	//'A opera┤└o nao ser═ efetuada.'
		Break
	EndIF

	oTree:TreeSeek( cCargo )

	DEFAULT cRes1ChgCut := "note"
	DEFAULT cRes2ChgCut := "note"

	ApdTreeCut(;
					@oTree,;
					@aTreeNodes,;
					@aCopyTreeNodes,;
					@aMenuPopUp,;
					@nIndEnable,;
					@bMenuVldCut,;
					@lCut,;
					@cRes1ChgCut,;
					@cRes2ChgCut;
				)

End Sequence

IF !Empty( cMsgInfo )
	MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0007 ) /*/'Aten┤└o!'*/ )
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdPstCpyTreeЁAutorЁMarinaldo de Jesus    Ё Data Ё25/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCola as Informacoes da Copia 								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdPstCpyTree(	oTree 			,;
								aTreeNodes		,;
								aCopyTreeNodes	,;
								aMenuPopUp		,;
								nIndDisable		,;
								bChangeValue	,;
								aCutTreeNodes	,;
								nIncOption		 ;
							 )

Local aNewNodes
Local aNodeUnCopy
Local cCargo
Local cGrpSup
Local cMsgInfo
Local nLoop
Local nLoops

Begin Sequence

	IF Empty( aCopyTreeNodes )
		Break
	EndIF

	cCargo	  	:= oTree:GetCargo()
	cGrpSup		:= SubStr( cCargo , 3 )

	IF ( ApdExistCut( aCutTreeNodes , cGrpSup ) )
		cMsgInfo := STR0019	//'Aviso de Inconsist┬ncia!'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0020	//'N└o ┌ possivel colar informa┤└o(■es) sobre ║tem(ns) recortados.'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0021	//'A opera┤└o nao ser═ efetuada.'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0022	//'Selecione outro n║vel para colar a(s) informa┤└o(■es).'
		Break
	EndIF

	CursorWait()
		aNewNodes	:= aClone( aCopyTreeNodes )
		ApdChgInfValue( @aNewNodes , bChangeValue , @aNodeUnCopy )
	CursorArrow()
	ApdTreePst(	@oTree , @aTreeNodes , @aNewNodes , @aMenuPopUp , nIndDisable , .F. , @nIncOption )
	cCargo := oTree:GetCargo()

	oTree:lVisibleControl := .F.	//:Hide()
		CursorWait()
			nLoops := Len( aNodeUnCopy )
			For nLoop := 1 To nLoops
				ApdTreeGrCut( @oTree , @aTreeNodes , @aCopyTreeNodes , aNodeUnCopy[ nLoop ] , .F. )
			Next nLoops
			oTree:TreeSeek( cCargo )
		CursorArrow()
	oTree:lVisibleControl := .T.	//:Show()

	aCopyTreeNodes := {}
	ClsCopyTreeNodes()

End Sequence

IF !Empty( cMsgInfo )
	MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0007 ) /*/'Aten┤└o!'*/ )
EndIF

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdChgInfValueЁAutorЁMarinaldo de Jesus   Ё Data Ё25/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁAltera o conteudo do Node Inferior							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdChgInfValue( aNewNodes , bChangeValue , aNodeUnCopy )

Local cLastNode
Local cNewNode
Local cLastDesc
Local cNewDesc

Local nLoop
Local nLoops

DEFAULT aNodeUnCopy := {}

nLoops := Len( aNewNodes )
For nLoop := 1 To nLoops
	cNewNode	:= Eval( bChangeValue , aNewNodes , nLoop )
	IF Empty( cNewNode )
		Loop
	EndIF
	cLastNode	:= aNewNodes[ nLoop , NODE_INFERIOR ]
	aAdd( aNodeUnCopy , cLastNode )
	aNewNodes[ nLoop , NODE_INFERIOR ] := cNewNode
	cLastDesc	:= aNewNodes[ nLoop , NODE_PROMPT ]
	IF ( cLastNode == SubStr( cLastDesc , 1 , Len( cLastNode ) ) )
		cNewDesc := ( cNewNode + SubStr( cLastDesc , Len( cLastNode ) + 1 ) )
		aNewNodes[ nLoop , NODE_PROMPT ] := cNewDesc
	EndIF
	ApdChgSupValue( aNewNodes[ nLoop , NODE_TREE ] , bChangeValue , cLastNode , cNewNode )
	ApdChgInfValue( aNewNodes[ nLoop , NODE_TREE ] , bChangeValue , @aNodeUnCopy )
Next nLoop

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdChgInfValueЁAutorЁMarinaldo de Jesus   Ё Data Ё25/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁAltera o conteudo do Node Superior							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdChgSupValue( aNewNodes , bChangeValue , cLastNode , cNewNode )

Local nLoop
Local nLoops

nLoops := Len( aNewNodes )
For nLoop := 1 To nLoops
	IF ( aNewNodes[ nLoop , NODE_SUPERIOR ] == cLastNode )
		aNewNodes[ nLoop , NODE_SUPERIOR ] := cNewNode
	EndIF
Next nLoop

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdCutTree	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRecortar Informacoes do Tree                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdCutTree(	oTree			,;
							aTreeNodes		,;
							aCutTreeNodes	,;
							aMenuPopUp		,;
							nIndEnable		,;
							bMenuVldCut 	,;
							lCut			,;
							cRes1ChgCut		,;
							cRes2ChgCut		,;
							aCopyTreeNodes	 ;
						  )

Local cCargo	:= oTree:GetCargo()
Local cGrpSup	:= SubStr( cCargo , 3 )

Local cMsgInfo

Begin Sequence

	IF ( ApdExistCut( aCopyTreeNodes , cGrpSup ) )
		cMsgInfo := STR0019	//'Aviso de Inconsist┬ncia!'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0040	//"N└o ┌ possivel recortar informa┤└o(■es) de ║tem(ns) copiados.'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0021	//'A opera┤└o nao ser═ efetuada.'
		Break
	EndIF

	oTree:TreeSeek( cCargo )

	DEFAULT cRes1ChgCut := "excluir"
	DEFAULT cRes2ChgCut := "excluir"

	ApdTreeCut(	@oTree			,;
				@aTreeNodes		,;
				@aCutTreeNodes	,;
				@aMenuPopUp		,;
				@nIndEnable		,;
				@bMenuVldCut 	,;
				@lCut			,;
				@cRes1ChgCut	,;
				@cRes2ChgCut	 ;
			  )

End Sequence

IF !Empty( cMsgInfo )
	MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0007 ) /*/'Aten┤└o!'*/ )
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreeCut	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRecortar Informacoes do Tree                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdTreeCut(	oTree			,;
							aTreeNodes		,;
							aCutTreeNodes	,;
							aMenuPopUp		,;
							nIndEnable		,;
							bMenuVldCut 	,;
							lCut			,;
							cRes1ChgCut		,;
							cRes2ChgCut		 ;
						  )

Local aLogGer		:= {}
Local aLogGerTitle	:= {}
Local cCargo       	:= oTree:GetCargo()
Local cGrupoCut		:= SubStr( cCargo , 3 )

Local cMsgInfo

oTree:lVisibleControl := .F.	//:Hide()

	Begin Sequence

		IF ( "*-" $ cCargo )
			MsgInfo( OemToAnsi( STR0044 ) )	//"Este Item NЦo Pode Ser Recortado e Nem Copiado"
			Break
		EndIF

		IF ( lCut )
			IF (;
					!( ApdTreeCkExc(	aTreeNodes		,;
										cGrupoCut		,;
										bMenuVldCut 	,;
										@aLogGer		,;
										@aLogGerTitle	 ;
								    );
					 );
				)
				Break
			EndIF
		Else
			IF Empty( aCutTreeNodes )
				Break
			EndIF
			IF !( ApdChkUnCut( aCutTreeNodes , cGrupoCut ) )
				cMsgInfo	:= STR0030	//'Este ║tem n└o pode ser "Desmarcado".
				cMsgInfo	+= CRLF + CRLF
				cMsgInfo	+= STR0031	//'Desmarque a partir do(s) ║tem(ns) superiores que est└o "Marcados" para serem recortados."
				MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0007 ) ) //'Aten┤└o!'
				Break
			EndIF
		EndIF

		IF !RD4ValidCut(cGrupoCut)
			MsgInfo( OemToAnsi( STR0058 ) )	//"Este Item NЦo Pode Ser Recortado, pois existem aprovaГУes pendentes amarradas a este departamento!"
			Break
		Endif

		oTree:TreeSeek( cCargo )

		ApdTreeGrCut( @oTree , @aTreeNodes , @aCutTreeNodes , cGrupoCut , lCut , NIL , cRes1ChgCut , cRes2ChgCut )

		oTree:TreeSeek( cCargo )

		aMenuPopUp[ nIndEnable  , 03 ] := !Empty( aCutTreeNodes )

	End Sequence

oTree:lVisibleControl := .T.	//:Show()

IF ( !Empty( aLogGer ) )
	CursorArrow()
	//'Este Grupo/Sub-Grupo nЦo pode ser Excluido. Deseja visualizar o Log?'###*'Aten┤└o!'
	IF ( MsgNoYes( OemToAnsi( STR0033 ) , OemToAnsi( STR0007 ) ) )
		CursorWait()
		//'Log de Inconsistencia na Exclusao de Grupo/Sub-Grupo'
		fMakeLog( aLogGer , aLogGerTitle , NIL , NIL , FunName() , STR0012 )
	EndIF
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreeGrCut ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁAdiciona o Item e Sub-Itens que foram recortados            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdTreeGrCut(	oTree			,;
								aTreeNodes		,;
								aCutTreeNodes	,;
								cGrupoCut		,;
								lCut			,;
								lChangeBmp		,;
								cRes1ChgCut		,;
								cRes2ChgCut		 ;
							)

Local aNodesAux
Local lForceAddNew
Local nLoop
Local nLoops
Local nLoop1
Local nLoops1

DEFAULT lChangeBmp := .T.

Begin Sequence

	nLoops := Len( aTreeNodes )
	For nLoop := 1 To nLoops
		IF ( aTreeNodes[ nLoop , NODE_ACTIVE ] )
			IF ( aTreeNodes[ nLoop , NODE_INFERIOR ] == cGrupoCut )
				IF ( lChangeBmp )
					oTree:TreeSeek( ( "+-" + cGrupoCut ) )
				EndIF
				IF ( lCut )
					IF ( ApdExistCut( aCutTreeNodes , cGrupoCut ) )
						DelTreeNodes( @aCutTreeNodes , cGrupoCut , .T. )
					EndIF
					IF ( lChangeBmp )
						oTree:ChangeBmp( cRes1ChgCut , cRes2ChgCut )
					EndIF
					lForceAddNew := !( ApdExistCut( aCutTreeNodes , aTreeNodes[ nLoop , NODE_SUPERIOR ] ) )
					BldTreeNodes(	@aCutTreeNodes,;
									aTreeNodes[ nLoop , NODE_SUPERIOR	],;
									aTreeNodes[ nLoop , NODE_INFERIOR	],;
									aTreeNodes[ nLoop , NODE_PROMPT 	],;
									aTreeNodes[ nLoop , NODE_ACOLS		],;
									aTreeNodes[ nLoop , NODE_RESOURCE1	],;
									aTreeNodes[ nLoop , NODE_RESOURCE2	],;
									lForceAddNew,;
						 			aTreeNodes[ nLoop , NODE_RECNO		],;
									aTreeNodes[ nLoop , NODE_DADOS		];
								)
				Else
					DelTreeNodes( @aCutTreeNodes , cGrupoCut , .T. )
					IF ( lChangeBmp )
						oTree:ChangeBmp( aTreeNodes[ nLoop , NODE_RESOURCE1	] , aTreeNodes[ nLoop , NODE_RESOURCE2 ] )
					EndIF
				EndIF
				aNodesAux := aTreeNodes[ nLoop , NODE_TREE ]
				nLoops1 := Len( aNodesAux )
				For nLoop1 := 1 To nLoops1
					cGrupoCut := aNodesAux[ nLoop1 , NODE_INFERIOR ]
					ApdTreeGrCut( @oTree , aNodesAux , @aCutTreeNodes , cGrupoCut , lCut , lChangeBmp , cRes1ChgCut , cRes2ChgCut )
				Next nLoop1
				Exit
			Else
				aNodesAux := aTreeNodes[ nLoop , NODE_TREE ]
				ApdTreeGrCut( @oTree , aNodesAux , @aCutTreeNodes , cGrupoCut , lCut , lChangeBmp , cRes1ChgCut , cRes2ChgCut )
			EndIF
		EndIF
	Next nLoop

End Sequence

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdChkUnCut  ЁAutorЁMarinaldo de Jesus    Ё Data Ё05/01/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Pode Desmarcar o Node                           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdChkUnCut( aCutTreeNodes , cNodeUnCut )

Local lChkUnCutOk := .T.

IF ( NodeExtSup( aCutTreeNodes , @cNodeUnCut ) )
	lChkUnCutOk := !( ApdExistCut( aCutTreeNodes , cNodeUnCut ) )
EndIF

Return( lChkUnCutOk )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdPstRecTreeЁAutorЁMarinaldo de Jesus    Ё Data Ё26/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁColar Informacoes no Tree                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdPstRecTree(	oTree 			,;
								aTreeNodes		,;
								aCutTreeNodes	,;
								aMenuPopUp		,;
								nIndDisable		,;
								lTreePstExc		,;
								aCopyTreeNodes	,;
								nIncOption		 ;
					  	  	)

Local cCargo
Local cGrpSup
Local cMsgInfo

Local nLoop
Local nLoops

Begin Sequence

	IF ( ( nLoops := Len( aCutTreeNodes ) ) == 0 )
		Break
	EndIF

	cCargo		:= oTree:GetCargo()
	cGrpSup		:= SubStr( cCargo , 3 )

	IF ( ApdExistCut( aCutTreeNodes , cGrpSup ) )
		cMsgInfo := STR0019	//'Aviso de Inconsist┬ncia!'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0020	//'N└o ┌ possivel colar informa┤└o(■es) sobre ║tem(ns) recortados.'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0021	//'A opera┤└o nao ser═ efetuada.'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0022	//'Selecione outro n║vel para colar a(s) informa┤└o(■es).'
		Break
	EndIF

	IF ( ApdExistCut( aCopyTreeNodes , cGrpSup ) )
		cMsgInfo := STR0019	//'Aviso de Inconsist┬ncia!'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0038	//'N└o ┌ possivel colar informa┤└o(■es) sobre ║tem(ns) copiados.'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0021	//'A opera┤└o nao ser═ efetuada.'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0022	//'Selecione outro n║vel para colar a(s) informa┤└o(■es).'
		Break
	EndIF

	aNewNodes	:= aClone( aCutTreeNodes )
	CursorWait()
		ApdChgInfValue( @aNewNodes , { | aNewNodes , nLoop | aNewNodes[ nLoop , NODE_SEQ ] } )
		IF !ArrayCompare( aNewNodes , aCutTreeNodes )
			ApdPstExc( @oTree , @aTreeNodes , aCutTreeNodes )
		EndIF
	CursorArrow()

	oTree:TreeSeek( cCargo )
	ApdTreePst(	@oTree , @aTreeNodes , @aNewNodes , @aMenuPopUp , @nIndDisable , @lTreePstExc , @nIncOption )

	aCutTreeNodes	:= {}
	ClsCutTreeNodes()

End Sequence

IF !Empty( cMsgInfo )
	MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0007 ) /*/'Aten┤└o!'*/ )
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreePst	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁColar Informacoes no Tree                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdTreePst(	oTree 			,;
							aTreeNodes		,;
							aCutTreeNodes	,;
							aMenuPopUp		,;
							nIndDisable		,;
							lTreePstExc		,;
							nIncOption		 ;
					  	  )

Local cCargo		:= oTree:GetCargo()
Local cGrpSup		:= SubStr( cCargo , 3 )

Local bIncOption
Local cPstCargo
Local lMaster
Local lTreeSeek
Local nLoop
Local nLoops

Begin Sequence

	IF ( ( nLoops := Len( aCutTreeNodes ) ) == 0 )
		Break
	EndIF

	lMaster		:= ( "*-" $ cCargo )
	bIncOption	:= { ||;
							IF( ( lMaster ),;
								2,;	//Sempre um Nivel Abaixo
								IF( ( nIncOption == NIL ) ,;
									Aviso(;
											OemToAnsi( STR0013 ),;	//'Inclus└o de novo ║tem'
											OemToAnsi( STR0014 ),;	//'Selecione o n║vel'
											{;
												OemToAnsi( "&"+STR0015 ),;	//'Novo Item'
												OemToAnsi( "&"+STR0016 );	//'Sub-Item'
											};
										 ),;
									nIncOption;
								  );
							   );
					}
	nIncOption	:= Eval( bIncOption )

	oTree:lVisibleControl := .F.	//:Hide()

		CursorWait()

			DEFAULT lTreePstExc := .T.
			IF ( lTreePstExc )
				ApdPstExc( @oTree , @aTreeNodes , aCutTreeNodes )
			EndIF

			oTree:TreeSeek( cCargo )

			lTreeSeek := .T.
			IF (;
					!( lMaster );
					.and.;
					( nIncOption == 1 );
				)
				IF ( lTreeSeek := !( NodeExtSup( aTreeNodes , @cGrpSup ) ) )
					nIncOption := 2
				EndIF
			EndIF

			cPstCargo	:= CutSub2NextPst( @oTree , @aTreeNodes , @aCutTreeNodes , nIncOption )

			ApdPstTree( @oTree , @aTreeNodes , aCutTreeNodes , cGrpSup , nIncOption , lTreeSeek )

			IF !Empty( cPstCargo )
				oTree:TreeSeek( cPstCargo )
			EndIF

			IF (;
					( lTreeSeek );
					.and.;
					( nIncOption == 2 );
				)
				oTree:TreeSeek( cCargo )
			EndIF

			oTree:Refresh()

			aMenuPopUp[ nIndDisable , 03 ] := .F.

		CursorArrow()

	oTree:lVisibleControl := .T.	//:Show()

End Sequence

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁCutSub2NextPstЁAutorЁMarinaldo de Jesus   Ё Data Ё20/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRecorta os Itens Posteriores para que o item ser inserido enЁ
Ё          Ёtre um e outro e retorna-os na ordem em que foram recortadosЁ
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApdTreePst() em APDXTREE                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function CutSub2NextPst( oTree , aTreeNodes , aCutTreeNodes , nIncOption )

Local aSvCutTreeNodes
Local aNodeGetSub
Local cPstCargo
Local cAuxCargo

Local nLoop
Local nLoops

IF ( nIncOption == 1 ) //Mesmo Nivel
	cPstCargo 		:= oTree:GetCargo()
	aSvCutTreeNodes	:= aClone( aCutTreeNodes )
	IF ( SuperGetMv( "MV_SUPCTSB" , NIL , "N" ) == "S" )
		SuperCutSub2NextPst( @oTree , @aTreeNodes , @aCutTreeNodes , cPstCargo )
	Else
		cAuxCargo		:= SubStr( cPstCargo , 3 )
		aNodeGetSub		:= NodeGetSub( aTreeNodes , NodeGetSup( aTreeNodes , cAuxCargo ) )
		nLoop			:= ( aScan( aNodeGetSub , { |x| ( x[1] == cAuxCargo ) } ) + 1 )
		nLoops			:= Len( aNodeGetSub )
		For nLoop := nLoop To nLoops
			ApdTreeGrCut( @oTree , @aTreeNodes , @aCutTreeNodes , aNodeGetSub[ nLoop , 1 ] , .T. , .F. )
		Next nLoop
	EndIF
	IF !ArrayCompare( aSvCutTreeNodes , aCutTreeNodes )
		ApdPstExc( @oTree , @aTreeNodes , aCutTreeNodes )
	EndIF
	oTree:TreeSeek( cPstCargo )
EndIF

Return( cPstCargo )

/*/
зддддддддддбдддддддддддддддддддбдддддбддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁSuperCutSub2NextPstЁAutorЁMarinaldo de JesusЁDataЁ20/08/2004Ё
цддддддддддедддддддддддддддддддадддддаддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁEfetua o mesmo processo que a CutSub2NextPst() mas e mais raЁ
Ё          Ёpida														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁCutSub2NextPst() em ApdTreePst() em APDXTREE                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function SuperCutSub2NextPst( oTree , aTreeNodes , aCutTreeNodes , cPstCargo )

Local cAlias		:= oTree:cArqTree

Local cT_IdTree
Local cT_Cargo
Local nNextRecno
Local nOrder
Local nSvOrder

cT_IdTree	:= ( cAlias )->( T_IDTREE )
nOrder		:= 2 //T_IDTREE
nSvOrder	:= ( cAlias )->( IndexOrd() )
( cAlias )->( dbSetorder( nOrder ) )
( cAlias )->( dbSkip() )
While (;
			( cAlias )->(;
							!Eof();
							.and.;
							( T_IDTREE == cT_IdTree );
						 );
		)
	IF !GetNextRecno( cAlias , @nNextRecno , NIL , nOrder )
		Exit
	EndIF
	cT_Cargo := SubStr( ( cAlias )->( T_CARGO ) , 3 )
	ApdTreeGrCut( @oTree , @aTreeNodes , @aCutTreeNodes , cT_Cargo , .T. , .F. )
	IF !GotoNextRecno( cAlias , nNextRecno , nOrder )
		Exit
	EndIF
End While

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdExistCut   ЁAutorЁMarinaldo de Jesus   Ё Data Ё01/01/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Ja Existe o Elemento Recortado                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdExistCut( aCutTreeNodes , cItem )

Local lExistCut := .F.

Local nLoop
Local nLoops

nLoops := Len( aCutTreeNodes )
For nLoop := 1 To nLoops
	IF ( aCutTreeNodes[ nLoop , NODE_ACTIVE ] )
		IF ( lExistCut := ( aCutTreeNodes[ nLoop , NODE_INFERIOR ] == cItem ) )
			Exit
		Else
			IF ( lExistCut := ApdExistCut( aCutTreeNodes[ nLoop , NODE_TREE ] , cItem ) )
				Exit
			EndIF
		EndIF
	EndIF
Next nLoop

Return( lExistCut )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdPstExc     ЁAutorЁMarinaldo de Jesus   Ё Data Ё01/01/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁExclui os Elementos antes de efetuar o Past					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdPstExc( oTree , aTreeNodes , aCutTreeNodes )

Local cTreeSeek
Local nLoop
Local nLoops

nLoops := Len( aCutTreeNodes )
For nLoop := 1 To nLoops
	IF ( aCutTreeNodes[ nLoop , NODE_ACTIVE ] )
		cTreeSeek := aCutTreeNodes[ nLoop , NODE_INFERIOR ]
		IF ( oTree:TreeSeek( "+-" + cTreeSeek ) )
			ApdTreeExc( @oTree , @aTreeNodes ,  { || .T. } , .T. )
		EndIF
		ApdPstExc( @oTree , @aTreeNodes , aCutTreeNodes[ nLoop , NODE_TREE ] )
	EndIF
Next nLoop

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdPstTree    ЁAutorЁMarinaldo de Jesus   Ё Data Ё01/01/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁEfetua o Past do Node                  						Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdPstTree( oTree 			,;
							aTreeNodes		,;
							aCutTreeNodes	,;
							cGrpSup			,;
							nIncOption		,;
							lTreeSeek		 ;
						  )

Local aCols

Local cNewInc
Local cDesc
Local cAddItem
Local cResource1
Local cResource2

Local nRecno
Local nLoop
Local nLoops

DEFAULT lTreeSeek	:= .T.

IF ( lTreeSeek )
	oTree:TreeSeek( ( "+-" + cGrpSup ) )
EndIF
nLoops := Len( aCutTreeNodes )
For nLoop := 1 To nLoops
	IF ( aCutTreeNodes[ nLoop , NODE_ACTIVE ] )
		cNewInc 	:= aCutTreeNodes[ nLoop , NODE_INFERIOR 	]
		cDesc		:= aCutTreeNodes[ nLoop , NODE_PROMPT		]
		aCols		:= aCutTreeNodes[ nLoop , NODE_ACOLS		]
		cResource1	:= aCutTreeNodes[ nLoop , NODE_RESOURCE1	]
		cResource2	:= aCutTreeNodes[ nLoop , NODE_RESOURCE2	]
		nRecno		:= aCutTreeNodes[ nLoop , NODE_RECNO		]
		cAddItem	:= ( "+-" + cNewInc )
		DEFAULT cResource1	:= "PMSTASK1"
		DEFAULT cResource2	:= "PMSTASK2"
		oTree:AddItem( cDesc , cAddItem , cResource1 , cResource2 , NIL , NIL , nIncOption )
		BldTreeNodes( @aTreeNodes , cGrpSup , cNewInc , cDesc , aCols , cResource1 , cResource2 , .F. , nRecno, ;
					 aCutTreeNodes[ nLoop , NODE_DADOS		];	
					 )
		IF ( Len( aCutTreeNodes[ nLoop , NODE_TREE ] ) > 0 )
			ApdPstTree(	@oTree													,;
						@aTreeNodes 											,;
						aCutTreeNodes[ nLoop , NODE_TREE ] 						,;
						aCutTreeNodes[ nLoop , NODE_TREE , 01 , NODE_SUPERIOR ]	,;
						2														,;
						.T.														 ;
					  )
		Else
			oTree:TreeSeek( cAddItem )
		EndIF
		IF ( lTreeSeek )
			oTree:TreeSeek( ( "+-" + cGrpSup ) )
		EndIF
	EndIF
Next nLoop

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreeMenu  ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁHabilitar e Desabilitar as Opcoes do Menu                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdTreeMenu( oTree , oMenu , nX , nY , aMenuPopUp, bMenuItemEnable )

Local nMenu
Local nMenus

DEFAULT aMenuPopUp	    := {}
DEFAULT bMenuItemEnable := {|| .T.}

IF ( ValType( oMenu ) == "O" )

	aEval( oMenu:aItems, { |o| o:Disable() } )

	cCargo := oTree:GetCargo()
	
	If !Eval(bMenuItemEnable)
		Return NIL
	EndIf

	nMenus := Len( aMenuPopUp )
	IF ( Left( cCargo , 1 ) == "+" )
		For nMenu := 1 To nMenus
			IF ( aMenuPopUp[ nMenu , 3 ] )
				oMenu:aItems[nMenu]:Enable()
			EndIF
		Next nMenu
	ElseIF ( Left( cCargo, 1 ) == "*" )
		IF (;
				( nMenus >= 3 );
				.and.;
				( aMenuPopUp[ 3 , 3 ] );
			)
			oMenu:aItems[ 3 ]:Enable()
		EndIF
		IF (;
				( nMenus >= 4 );
				.and.;
				( aMenuPopUp[ 4 , 3 ] );
			)
			oMenu:aItems[ 4 ]:Enable()
		EndIF
	EndIF

	IF (;
			( nMenus >= 1 );
			.and.;
			( aMenuPopUp[ 1 , 3 ] );
		)
		oMenu:aItems[1]:Enable()
	EndIF

	oMenu:Activate( nX-40 , nY-205 , oTree )

EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreeGrv	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGrava as Informacoes do Tree                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdTreeGrv(	aTreeNodes		,;
							aLstMainTree	,;
							cdbTreeAlias	,;
							bFilField		,;
							bCodField		,;
							bItemField		,;
							bTreeField		,;
							bDescField		,;
							cFilFather		,;
							cKeyFather		,;
							nItemOrder		,;
							abDados			;
						  )

Local cGrpBranco := Space( Len( Eval( bTreeField ) ) )

Local cIndexKey
Local lApdTreeGrv

Begin Sequence

	IF !( lApdTreeGrv := !ArrayCompare( aTreeNodes , aLstMainTree ) )
		Break
	EndIF
    
DEFAULT abDados		:= {}

	Begin Transaction
		( cdbTreeAlias )->( dbSetOrder( nItemOrder ) )
		cIndexKey := ( cdbTreeAlias )->( IndexKey() )
		ApdExcSup(	aTreeNodes		,;
					cdbTreeAlias	,;
					bTreeField		,;
					cFilFather		,;
					cKeyFather		,;
					cIndexKey		,;
					cGrpBranco		 ;
				 )
		ApdGrvSup(	aTreeNodes		,;
					cdbTreeAlias	,;
					bFilField		,;
					bCodField		,;
					bItemField		,;
					bTreeField		,;
					bDescField		,;
					cFilFather		,;
					cKeyFather		,;
					abDados			;
				)
	End Transaction

End Sequence

Return( lApdTreeGrv )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdExcSup	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё01/01/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁElimina os Grupos Superiores								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdExcSup(	aTreeNodes 		,;
							cdbTreeAlias	,;
							bTreeField		,;
							cFilFather		,;
							cKeyFather		,;
							cIndexKey		,;
							cGrpBranco		 ;
						 )

Local cFilTreeAlias := xFilial( cdbTreeAlias , cFilFather )
Local cKeySeek		:= ( cFilTreeAlias + cKeyFather )

Local cGrupoExc
Local cItemSeekKey
Local nLoop
Local nLoops
Local nSizeKey

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF ( !( aTreeNodes[ nLoop , NODE_ACTIVE ] ) )
		cGrupoExc		:= aTreeNodes[ nLoop , NODE_INFERIOR ]
		cItemSeekKey	:= ( cdbTreeAlias )->( cKeySeek + cGrupoExc )
		nSizeKey		:= Len( cItemSeekKey )
		IF ( ( cdbTreeAlias )->( MsSeek( cItemSeekKey , .F. ) ) )
			While (;
						( cdbTreeAlias )->(;
												!Eof();
												.and.;
												( SubStr( __ExecMacro( cIndexKey ) , 1 , nSizeKey ) == cItemSeekKey );
										   );
				  )
				IF ( cdbTreeAlias )->( RecLock( cdbTreeAlias , .F. ) )
					( cdbTreeAlias )->( Eval( bTreeField , cGrpBranco ) )
					( cdbTreeAlias )->( MsUnLock() )
				EndIF
				( cdbTreeAlias )->( dbSkip() )
			End While
		EndIF
	EndIF
	ApdExcSup(	aTreeNodes[ nLoop , NODE_TREE ] ,;
				cdbTreeAlias					,;
				bTreeField						,;
				cFilFather						,;
				cKeyFather						,;
				cIndexKey						,;
				cGrpBranco						 ;
			 )
Next nLoop

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdGrvSup	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё01/01/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGrava os Grupos Superiores									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdGrvSup(	aTreeNodes		,;
							cdbTreeAlias	,;
							bFilField		,;
							bCodField		,;
							bItemField		,;
							bTreeField		,;
							bDescField		,;
							cFilFather		,;
							cKeyFather		,; 
							abDados			;
						)

Local cFilTreeAlias := xFilial( cdbTreeAlias , cFilFather )
Local cKeySeek		:= ( cFilTreeAlias + cKeyFather )
Local lExecAddNew	:= ( ( bFilField <> NIL ) .and. ( bCodField <> NIL ) )
Local cMaster		:= Replicate( "0" , Len( ( cdbTreeAlias )->( Eval( bTreeField ) ) ) )

Local cItem
Local cTree
Local cDesc
Local lAddNew
Local nLoop
Local nLoops

Local acDados 
Local nX

DEFAULT abDados		:= {}
nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF ( aTreeNodes[ nLoop , NODE_ACTIVE ] )
		cItem := aTreeNodes[ nLoop , NODE_INFERIOR ]
		IF ( cItem <> cMaster )
			lAddNew := ( cdbTreeAlias )->( !MsSeek( cKeySeek + cItem , .F. ) )
			IF (;
					( lAddNew );
					.and.;
					!( lExecAddNew );
				)
				Loop
			EndIF
			IF ( cdbTreeAlias )->( RecLock( cdbTreeAlias , lAddNew ) )
				IF ( lAddNew )
					cDesc 	:= aTreeNodes[ nLoop , NODE_PROMPT ]
					acDados	:= aTreeNodes[ nLoop , NODE_DADOS  ]
					( cdbTreeAlias )->( Eval( bFilField  , cFilTreeAlias	) )
					( cdbTreeAlias )->( Eval( bCodField  , cKeyFather		) )
					( cdbTreeAlias )->( Eval( bItemField , cItem			) )
					( cdbTreeAlias )->( Eval( bDescField , cDesc			) ) 
				   
					IF Len(acDados) > 0
						For nX:= 1 to Len(abDados)						
							( cdbTreeAlias )->( Eval( abDados[nX]  , acDados[nX]	) )
						Next nX
					Endif
					
				EndIF
				cTree := aTreeNodes[ nLoop , NODE_SUPERIOR ]
				( cdbTreeAlias )->( Eval( bTreeField , cTree ) )
				( cdbTreeAlias )->( MsUnLock() )
			EndIF
		EndIF
	EndIF
	ApdGrvSup(	aTreeNodes[ nLoop , NODE_TREE ]	,;
				cdbTreeAlias					,;
				bFilField						,;
				bCodField						,;
				bItemField						,;
				bTreeField						,;
				bDescField						,;
				cFilFather						,;
				cKeyFather		 				,;  
				abDados			                ;
			)
Next nLoop

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreeBar   ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁBarrasa do Tree ( Equivalente a EnchoiceBar )               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdTreeBar(	oDlg			,;	//Objeto Dialog
							lTudoOk			,;	//Tudo Ok por Referencia
							oEnchoice		,;	//Objeto Enchoice
							oGetDados		,;	//Objeto GetDados (New)
							aCols			,;	//aCols
							aButtons		,;	//aButtons
							bTreeOk			,;	//Bloco Tudo Ok para o Tree
							lExecValid		,;	//Se deve Executar os Valids
							bTrfaCols		 ;	//Bloco Para Transferencia de Informacoes do aCols
						)

Local bGdOk			:= { || .T. }
Local bEnOk			:= { || .T. }
Local bOk			:= { || oDlg:End() }
Local bCancel		:= { || oDlg:End() }
Local lGdIsObject	:= ( ValType( oGetDados ) == "O" )
Local lEnIsObject	:= ( ValType( oEnchoice ) == "O" )

DEFAULT lTudoOk		:= .F.
DEFAULT aCols		:= {}
DEFAULT aButtons	:= {}
DEFAULT bTreeOk		:= { || .T. }
DEFAULT lExecValid	:= .T.
DEFAULT bTrfaCols	:= { || aCols := oGetDados:aCols }

IF ( lExecValid )
	bGdOk	:= { || ( !( lGdIsObject ) .or. oGetDados:TudoOk() ) }
	bEnOk	:= { || ( !( lEnIsObject ) .or. EnchoTudOk( oEnchoice ) ) }
	bOk		:= { |lGdOk,lEnOk,lTreeOk|;
					lGdOk	:= Eval( bGdOk )	,;
					lEnOk	:= Eval( bEnOk )	,;
					lTreeOk := Eval( bTreeOk )	,;
					lTudoOk := ( ( lGdOk ) .and. ( lEnOk ) .and. ( lTreeOk ) ),;
					IF( ( lTudoOk ) , (;
											IF( lGdIsObject , Eval( bTrfaCols ) , NIL ),;
											oDlg:End();
					  			  	   ),;
			 						  NIL;
			 		  );
			   }
	bCancel	:= { || ( lTudoOk := .F. ) , oDlg:End() }
EndIF

Return( EnchoiceBar( oDlg , bOK , bCancel , NIL , aButtons ) )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁApdTreeSelec ЁAutorЁ Adilson Silva        Ё Data Ё14/01/2013Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInclui Multiplos Itens na Tree                              Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁAPDXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ApdTreeSelec( oTree			,; //01
					   		aTreeNodes		,; //02
							cKeyFather		,; //03
							cdbTreeAlias	,; //04
							bItemField		,; //05
							bDescField		,; //06
							nItemOrder		,; //07
							cSetFilConPad	,; //08
							lAllRegs		,; //09
							bTreeGetDet		,; //10 
							bRes1Field		,; //11
							bRes2Field		,; //12
							cdbTreeF3		,; //13
							abDados			;  //14	
						   )

Local aSvKeys		:= GetKeys()
Local aListAux		:= {}
Local cAliasTMP		:= GetNextAlias()
Local bAction 		:= { || CursorWait(), fAtuItVisao( oDlg, aList, oTree ), CursorArrow()}
Local oOk     		:= LoadBitmap( GetResources(), "LBOK" )	//"CHECKED"
Local oNo     		:= LoadBitmap( GetResources(), "LBNO" )	//"UNCHECKED"
Local lChk1   		:= .F.
Local lChk2   		:= .F.
Local aList 		:= {}
Local cCombo		:= ""
Local cStatus		:= ""
Local cPesq			:= Space(20)
Local nX, nPos
Local bSkip			:= {|| }

Local oList, oGroup
Local oDlg, oConfirma
Local oExit, oChk1, oChk2, oPesq, oCombo

Private aItVisao 	:= {}

// Busca os Itens da Visao
fItensVisao( aTreeNodes, @aItVisao )

If RDK->RDK_HIERAR == "1"
	cStatus := "2"
	BEGINSQL ALIAS cAliasTMP
		SELECT RD4_ITEM,RD4_EMPIDE,RD4_FILIDE,RD4_CODIDE,RD4_DESC,RD4_STATUS, RD4.R_E_C_N_O_ AS RECNORD4
		FROM %table:RD4% RD4
		WHERE RD4_FILIAL = %exp:RDK->RDK_FILIAL% AND
		RD4_CODIGO = %exp:RDK->RDK_CODIGO% 	AND RD4.%notDel%
	ENDSQL
Else
	cStatus := "3*4"
	BEGINSQL ALIAS cAliasTMP
		SELECT RD4_ITEM,RD4_EMPIDE,RD4_FILIDE,RD4_CODIDE,RD4_DESC,RCL_STATUS AS RD4_STATUS, RD4.R_E_C_N_O_ AS RECNORD4
		FROM %table:RD4% RD4
		INNER JOIN %table:RCL% RCL ON RD4_FILIDE = RCL_FILIAL AND	RD4_CODIDE = RCL_POSTO AND RCL_STATUS <> '4' AND RCL.%NotDel%
		WHERE RD4_FILIAL = %exp:RDK->RDK_FILIAL% AND
		RD4_CODIGO = %exp:RDK->RDK_CODIGO% AND RD4_TREE = '' AND RD4.%notDel%
	ENDSQL
EndIf

While !(cAliasTMP)->(Eof())
	If  Ascan(aItVisao,{|x| x==(cAliasTMP)->RD4_ITEM}) > 0
		(cAliasTMP)->(DbSkip())
		Loop
	EndIf
	(cAliasTMP)->(aAdd(aList,{.F.,RD4_ITEM,RD4_EMPIDE,RD4_FILIDE,RD4_CODIDE,RD4_DESC,RECNORD4,!(RD4_STATUS $ cStatus)}))
	(cAliasTMP)->(DbSkip())
EndDo

aListAux := aList

(cAliasTMP)->(DbCloseArea())

If Len( aList ) == 0
   Aviso(STR0007,STR0045,{STR0046})		//"ATENCAO"###"NЦo existem visУes a serem atualizadas!"###"Sair"

   Return
EndIf

If aCombo == Nil
	aCombo := {}
	aAdd( aCombo, Alltrim(Posicione("SX3",2,Padr("RD4_ITEM" ,10),"X3_TITULO") ) )
	aAdd( aCombo, Alltrim(Posicione("SX3",2,Padr("RD4_EMPIDE" ,10),"X3_TITULO") ) )
	aAdd( aCombo, Alltrim(Posicione("SX3",2,Padr("RD4_FILIDE" ,10),"X3_TITULO") ) )
	aAdd( aCombo, Alltrim(Posicione("SX3",2,Padr("RD4_CODIDE" ,10),"X3_TITULO") ) )
	aAdd( aCombo, Alltrim(Posicione("SX3",2,Padr("RD4_DESC" ,10),"X3_TITULO") ) )
EndIf

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Criacao da Interface                                                Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
DEFINE MSDIALOG oDlg TITLE STR0047 FROM 069,236 To 492,936 PIXEL	// "InclusЦo de Itens nas VisУes"

@ 010,010 GROUP oGroup TO 200,340 LABEL OemToAnsi( STR0048 ) OF oDlg PIXEL	// "Atualizar VisУes"
oConfirma := SButton():New(180 , 260 , 1 , { || Eval( bAction )} , oDlg , .T. )
oConfirma:cCaption := STR0049		// "Confirmar"
oExit := SButton():New(180 , 300 , 1 , { || oDlg:End() } , oDlg , .T. )
oExit:cCaption := STR0050			// "Cancelar"

@ 020,195 MSCOMBOBOX oCombo VAR cCombo ITEMS aCombo SIZE 050,010 VALID (ApdOrd(cCombo,@aList,@aListAux),oList:Refresh(),.T.) OF oDlg PIXEL
@ 020,250 MSGET oPesq VAR cPesq PICTURE "@!" VALID Iif(!Empty(cPesq),(ApdPesq(cPesq,cCombo,aList,@oList),oList:Refresh(),.T.),.T.) SIZE 80,10 OF oDlg PIXEL			
@ 040,013 ListBox oList Fields HEADER " ", STR0052, STR0053, STR0054, STR0055, STR0056, " ", " " SIZE 324,130 OF oDlg PIXEL ON dblClick(If(!Empty(aList[oList:nAt,2]),((aList[oList:nAt,1] := !aList[oList:nAt,1]), (aListAux[Ascan(aListAux,{|x| x[7]==aList[oList:nAt,7]}),1] := aList[oList:nAt,1])),))	// "Item"###"Empresa"###"Filial"###"Cod Item"###"Desc ITem"
@ 180,013 CheckBox oChk1 VAR lChk1 PROMPT STR0051 SIZE 70,7 PIXEL OF oDlg ON CLICK( aEval( aList, {|x| x[1] := lChk1 } ),aEval( aListAux, {|x| x[1] := lChk1 } ),oList:Refresh() )	// "Marca/Desmarca Todos"
@ 180,100 CheckBox oChk2 VAR lChk2 PROMPT STR0057 SIZE 70,7 PIXEL OF oDlg ON CLICK( ApdFilList(@aList,aListAux,@oList,lChk2,oOk,oNo),oList:Refresh() )	// "Exibir inativos"

oList:SetArray( aList )
oList:bLine := {|| {If(aList[oList:nAt,1],oOk,oNo), ;
                        aList[oList:nAt,2], ;
                        aList[oList:nAt,3], ;
                        aList[oList:nAt,4], ;
                        aList[oList:nAt,5], ;
                        aList[oList:nAt,6], ;
                        aList[oList:nAt,7], ;
                        aList[oList:nAt,8]} }
                        
//Filtra lista
ApdFilList(@aList,aListAux,@oList,lChk2,oOk,oNo)
oList:Refresh()
                        
oList:SetFocus()

ACTIVATE MSDIALOG oDlg CENTERED

RestKeys( aSvKeys , .T. )

Return( NIL )

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁAPDXTREE  ╨Autor  Ё Adilson Silva      ╨ Data Ё 14/01/2013  ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё                                                            ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP                                                         ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/

Static Function fItensVisao( aTreeNodes, aItVisao )

Local nLoop
Local nLoops
Local nPos

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF ( aTreeNodes[ nLoop , NODE_ACTIVE ] )
		If ( nPos := Ascan(aItVisao,{|x| x==aTreeNodes[nLoop,NODE_INFERIOR]}) ) == 0
		   Aadd(aItVisao,aTreeNodes[nLoop,NODE_INFERIOR])
		EndIf
        fItensVisao( aTreeNodes[ nLoop , NODE_TREE ], @aItVisao )
	EndIF
Next nLoop

Return

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁAPDXTREE  ╨Autor  Ё Adilson Silva      ╨ Data Ё 14/01/2013  ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё                                                            ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP                                                         ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/

Static Function fAtuItVisao( oDlg, aList, oTree )

 Local cCargo
 Local lMaster
 Local bIncOption
 Local nIncOption
 Local cGrpInc
 Local bRes1Field	:= { || "BR_BRANCO"}
 Local bRes2Field	:= { || "BR_BRANCO"}
 Local cResource1 := Eval( bRes1Field )
 Local cResource2 := Eval( bRes2Field )
 Local nRecnoRd4
 Local cDesc
 Local cAddItem
 Local nX

 cCargo  := oTree:GetCargo()
 lMaster := ( "*-" $ cCargo )
 oTree:TreeSeek( cCargo )
 cGrpInc	:= SubStr( cCargo , 3 )
 
 bIncOption	:= { || IF( ( lMaster ) , 2 /*/Sempre um Nivel Abaixo*/ , Aviso( OemToAnsi( STR0013 ) /*/'Inclus└o de novo ║tem'*/, OemToAnsi( STR0014 ) /*/'Selecione o n║vel'*/ , { OemToAnsi( "&"+STR0015 ) /*/'Novo Item'*/ , OemToAnsi( "&"+STR0016 ) /*/'Sub-Item'*/ } ) ) }
 nIncOption	:= Eval( bIncOption )

 cResource1 := IF( Empty( cResource1 ) , "PMSTASK1" , cResource1 )
 cResource2 := IF( Empty( cResource2 ) , "PMSTASK2" , cResource2 )

 For nX := 1 To Len( aList )
 	
     If !aList[nX,1] .or. Empty(aList[nX,2])
        Loop
     EndIf
     
     cAddItem  := "+-" + aList[nX,2]
     cNewInc   := aList[nX,2]
     cDesc     := Alltrim(aList[nX,5]) + " - " + aList[nX,6]
     nRecnoRd4 := aList[nX,7]

     oTree:AddItem( cDesc , cAddItem , cResource1 , cResource2 , NIL , NIL , nIncOption )
     cLastAddItem	:= cAddItem
 
     IF ( !( lMaster ) .and. ( nIncOption == 1 ) )
	    cGrpInc := NodeGetSup( aTreeNodes , cGrpInc )
     EndIF

     BldTreeNodes( @aTreeNodes , cGrpInc , cNewInc , cDesc , NIL , cResource1 , cResource2 , .F. , nRecnoRd4 , /*acDados*/ )
 Next nX

 oDlg:End()
 oTree:Refresh()

Return

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁApdFilList╨Autor  Ё Leandro Drumond    ╨ Data Ё 19/11/2014  ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё Filtra itens ativos.                                       ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP                                                         ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function ApdFilList(aList,aListAux,oList,lChk,oOk,oNo)

If lChk
	aList := aListAux
Else
	aList := {}
	Aeval(aListAux,{|x| If(x[8],Aadd(aList,{x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8]}),)})
EndIf

If Empty(aList)
	aAdd(aList,{.F.,'','','','','',0,''})
EndIf

oList:SetArray( aList )
oList:bLine := {|| {If(aList[oList:nAt,1],oOk,oNo), ;
                        aList[oList:nAt,2], ;
                        aList[oList:nAt,3], ;
                        aList[oList:nAt,4], ;
                        aList[oList:nAt,5], ;
                        aList[oList:nAt,6], ;
                        aList[oList:nAt,7], ;
                        aList[oList:nAt,8]} }
oList:Refresh(.T.)

Return Nil

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁApdOrd    ╨Autor  Ё Leandro Drumond    ╨ Data Ё 20/11/2014  ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё Ordena ListBox.		                                      ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP                                                         ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function ApdOrd(cCombo,aList,aListAux)

Local nPos := aScan( aCombo , { |x| ( x == cCombo ) } )
 
ASort(@aList,,,{|x,y| x[nPos+1] < y[nPos+1]})
aListAux := aList

Return .T.

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁApdPesq   ╨Autor  Ё Leandro Drumond    ╨ Data Ё 20/11/2014  ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё Pesquisa listbox.	                                      ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP                                                         ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function ApdPesq(cPesq,cCombo,aList,oList)

Local nPos 		:= aScan( aCombo , { |x| ( x == cCombo ) } )
Local nPosAux	:= aScan( aList , { |x| AllTrim(x[nPos+1]) == AllTrim(cPesq) } )

If nPosAux > 0
	oList:nAt := nPosAux
else
    nPosAux	:= aScan( aList , { |x| AllTrim(cPesq) $ AllTrim(x[nPos+1]) } )
    
    If nPosAux > 0
	    oList:nAt := nPosAux
    EndIf
EndIf

Return .T.

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁApdLoadTree╨Autor  Ё Leandro Drumond    ╨ Data Ё 28/12/2014 ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё Carrega restante da tree.                                  ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP                                                         ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function ApdLoadTree(adbTree , oTree, cCargo, bAddNodes)

Local aArea			:= GetArea()
Local cChaveRD4		:= ""
Local cChaveFilho	:= ""
Local cDescTree		:= ""
Local cAliasTmp		:= ""
Local nRecAux		:= 0
Local nRecAux2		:= 0

DEFAULT cCargo		:= StrTran(oTree:GetCargo(),"+-","")
DEFAULT bAddNodes 	:= {|| .T. }

If cCargo $ cAllCargo
	Return Nil
Else
	cAllCargo += cCargo + "*"
EndIf

cAliasTmp := "RD4"
cChaveRD4	:= xFilial("RD4")+RDK->RDK_CODIGO+cCargo
DbSelectArea(cAliasTmp) 
DbSetOrder(2)// RD4_FILIAL+RD4_CODIGO+RD4_TREE+RD4_ITEM+DTOS(RD4_DATA)
If DbSeek(cChaveRD4) .And. Eval( bAddNodes )

	cResource1	:= IIf(RDK->RDK_HIERAR == "1", 'BR_BRANCO', 'BR_AMARELO')
	cResource2	:= IIf(RDK->RDK_HIERAR == "1", 'BR_BRANCO', 'BR_AMARELO')
	nSubTree	:= 0

	oTree:BeginUpdate()

	While (cAliasTmp)->(!Eof() .and. RD4_FILIAL + RD4_CODIGO + RD4_TREE == cChaveRD4) .And. Eval( bAddNodes )

		If oTree:TreeSeek("+-"+(cAliasTmp)->RD4_ITEM) //Ja foi carregado
		//verifico se o item carregado possui filhos carregados 
		//- necessario pois ha um limite na carga dos filhos dos "primogenitos" 
		//- limite de 3 niveis, exemplo: A -> B -> C -> D -> E (nesse caso sera carreado ate o D, ignorando seu "filho" E)
			nRecAux2 := (cAliasTmp)->(Recno()) //guarda recno do item original
			cChaveFilho := (cAliasTmp) -> (RD4_FILIAL + RD4_CODIGO + RD4_ITEM)
				If (DbSeek(cChaveFilho)) .AND. !(oTree:TreeSeek("+-"+(cAliasTmp)->RD4_ITEM)) //Se existe filho e nao esta na Tree, adiciono o item no oTree
					oTree:TreeSeek( "+-"+(cAliasTmp)->RD4_TREE )
					If RDK->RDK_HIERAR == "1"
						cDescTree := (cAliasTmp)->(RD4_CODIDE + " - " + AllTrim(RD4_DESC)) 
					Else
						cDescTree := (cAliasTmp)->(RD4_CODIDE + " - " + AllTrim(RD4_DESC) + " (" + AllTrim(Posicione("SQB", 1, xFilial("SQB", RD4_FILIDE) + Posicione("RCL", 2, xFilial("RCL", RD4_FILIDE) + RD4_CODIDE, "RCL_DEPTO"), "QB_DESCRIC")) + ")")
					EndIf
					oTree:AddItem( cDescTree , "+-"+(cAliasTmp)->RD4_ITEM , cResource1 , cResource2 , NIL , NIL , 2 )
					BldTreeNodes( @aTreeNodes , (cAliasTmp)->RD4_TREE  ,(cAliasTmp)->(RD4_ITEM) ,  cDescTree , {} , cResource1 , cResource2 ,, recno() ,{(cAliasTmp)->(AllTrim(RD4_DESC)),(cAliasTmp)->RD4_EMPIDE,(cAliasTmp)->RD4_FILIDE,(cAliasTmp)->RD4_ITEM})
				EndIf
			(cAliasTmp)->(DbGoTo(nRecAux2)) //reposiciona RD4
			oTree:TreeSeek("+-"+(cAliasTmp)->RD4_ITEM) //reposciona oTree
			oTree:ptcollapse()
			(cAliasTmp)->(DbSkip())
			Loop
		EndIf

		oTree:TreeSeek( "+-"+(cAliasTmp)->RD4_TREE )
		If RDK->RDK_HIERAR == "1"
			cDescTree := (cAliasTmp)->(RD4_CODIDE + " - " + AllTrim(RD4_DESC)) 
		Else
			cDescTree := (cAliasTmp)->(RD4_CODIDE + " - " + AllTrim(RD4_DESC) + " (" + AllTrim(Posicione("SQB", 1, xFilial("SQB", RD4_FILIDE) + Posicione("RCL", 2, xFilial("RCL", RD4_FILIDE) + RD4_CODIDE, "RCL_DEPTO"), "QB_DESCRIC")) + ")")
		EndIf
		oTree:AddItem( cDescTree , "+-"+(cAliasTmp)->RD4_ITEM , cResource1 , cResource2 , NIL , NIL , 2 )
		BldTreeNodes( @aTreeNodes ,  (cAliasTmp)->RD4_TREE  ,(cAliasTmp)->(RD4_ITEM), cDescTree , {} , cResource1 , cResource2 ,, nRecAux ,{(cAliasTmp)->(AllTrim(RD4_DESC)),(cAliasTmp)->RD4_EMPIDE,(cAliasTmp)->RD4_FILIDE,(cAliasTmp)->RD4_ITEM})

		nRecAux := (cAliasTmp)->(Recno())
		AddFirst(cAliasTmp,@oTree,nRecAux,,bAddNodes)
	
		(cAliasTMP)->(DbSkip())
	EndDo

	oTree:EndUpdate()

	//Volta para posicao inicial
	oTree:TreeSeek("+-"+cCargo)
EndIf

RestArea(aArea)

Return Nil
/*--------------------------------------------------------------------------------------------------------------------------------------------------------*/
Static Function AddFirst(cAliasTmp,oTree,nRecAux,lSub,bAddNodes)
Local cDescTree := ""
Local cPai	:= ""
DEFAULT lSub := .F.
DEFAULT bAddNodes := {|| .T.}

//Cria o primeiro filho para aparecer o sinal para expandir
If (cAliasTmp)->(DbSeek(xFilial("RD4")+(cAliasTmp)->(RD4_CODIGO+RD4_ITEM))) .And. Eval( bAddNodes )
	cPai	:= (cAliasTmp)->RD4_TREE
	oTree:TreeSeek( "+-"+(cAliasTmp)->RD4_TREE )
	If RDK->RDK_HIERAR == "1"
		cDescTree := (cAliasTmp)->(RD4_CODIDE + " - " + AllTrim(RD4_DESC)) 
	Else
		cDescTree := (cAliasTmp)->(RD4_CODIDE + " - " + AllTrim(RD4_DESC) + " (" + AllTrim(Posicione("SQB",1,xFilial("SQB", RD4_FILIDE) + Posicione("RCL",2,xFilial("RCL", RD4_FILIDE) + RD4_CODIDE, "RCL_DEPTO"), "QB_DESCRIC")) + ")")
	EndIf

	oTree:AddItem( cDescTree , "+-"+(cAliasTmp)->RD4_ITEM , cResource1 , cResource2 , NIL , NIL , 2 )
	BldTreeNodes( @aTreeNodes ,  (cAliasTmp)->RD4_TREE  ,(cAliasTmp)->(RD4_ITEM) , cDescTree , {} , cResource1 , cResource2 ,, Recno() ,{(cAliasTmp)->(AllTrim(RD4_DESC)),(cAliasTmp)->RD4_EMPIDE,(cAliasTmp)->RD4_FILIDE,(cAliasTmp)->RD4_ITEM})
	
	oTree:ptcollapse()
EndIf

If !lSub
	AddFirst(cAliasTmp,@oTree,nRecAux,.T.,bAddNodes)
	oTree:ptcollapse()
EndIf

oTree:TreeSeek( "+-"+cPai )
oTree:ptcollapse()

(cAliasTmp)->(DbGoTo(nRecAux))

oTree:TreeSeek( "+-"+(cAliasTmp)->RD4_TREE )
oTree:ptcollapse()
	
Return


/*/{Protheus.doc} RD4ValidCut
//Valida se o departamento pode ser recortado
@author fernando luis guilherme
@since 14/10/2022
@version 1.0
@return return, return_description
@example
(examples)
@see (links_or_references)
/*/

Static Function RD4ValidCut(cGrupoCut)
Local lRet := .T.
Local aKey := {}
Local cAliasRH3 := GetNextAlias()
Local cFiltroKey := ""

cChaveRD4	:= xFilial("RD4")+RDK->RDK_CODIGO+cGrupoCut
DbSelectArea("RD4") 
DbSetOrder(1)// RD4_FILIAL+RD4_CODIGO+RD4_ITEM+RD4_TREE+DTOS(RD4_DATA)

If DbSeek(cChaveRD4)
	While ("RD4")->(!Eof() .and. RD4_FILIAL + RD4_CODIGO + RD4_ITEM == cChaveRD4)
		If !Empty(RD4->RD4_CHAVE)
			aadd (aKey, Alltrim(RD4->RD4_CHAVE))
		EndIf
		("RD4")->(DbSkip())
	EndDo
	If Len(aKey) > 0
		cFiltroKey := "%'" + ArrTokStr(aKey,"','") + "'%"

		BeginSql alias cAliasRH3
			SELECT Count(*) SOLICITACAO
			FROM %table:RH3% RH3
			WHERE RH3.RH3_FILIAL = %xfilial:RH3% 
			AND RH3.RH3_KEYINI IN (%exp:cFiltroKey%)
			AND RH3.RH3_STATUS IN ('1','4','5')
			AND RH3.%notDel%
		EndSql

		If (cAliasRH3)->SOLICITACAO > 0
			lRet := .F.
		EndIf

		(cAliasRH3)->( dbCloseArea() )
	Endif
EndIf

Return lRet
