#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEA1090.CH"
#INCLUDE "FONT.CH"
#INCLUDE "COLORS.CH"
#INCLUDE "HEADERGD.CH"
#Include 'fwmvcdef.ch'

Static lGP090CHK	:= ExistBlock("GP090CHK")
Static lGP090ALT	:= ExistBlock("GP090ALT")
Static lGP090Ok		:= ExistBlock("GP090OK")
Static lIntegDef	:= FindFunction("GETROTINTEG") .And. FindFunction("FWHASEAI")
Static __lMemCalc
Static lExibMsg   := .T.
Static lExiMsgPl  := .T.
Static lFuncRst

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GPEA090  ³ Autor ³ J.Ricardo                        ³ Data ³ 20.02.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cadastro Valores Variaveis                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador  ³ Data   ³ BOPS           ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Leandro Dr.  |29/10/12|    M12RH01     |Unificacao das folhas. Tratamento para    ³±±
±±³             |        | REQ.0008       |utilizacao de RGB no Brasil.              ³±±
±±³Esther V.    |22/04/14|    M_RH003     |Replica V11 para V12. Tratamento do para- ³±±
±±³             |        |                |metro MV_ITMCLVL para aceitar '3', nao    ³±±
±±³             |        |                |obrigando o preenchimento dos campos.     ³±±
±±³ Esther V.   |21/10/14|    TQWCM8      |Adicionada opcao 'Calcular Folha' no menu ³±±
±±³             |        |                |de 'Outras Acoes' nas telas de 'Incluir' e³±±
±±³             |        |                |'Alterar'. Criada a funcao fCalcLanc().   ³±±
±±³PHILIPE      |09/04/15|    TPPAI7      |Adicionadas as opções de Inclusão,Alteração±±
±±³POMPEU       |        |                |e Visualização de Lançamentos tabela RGB no±±
±±³             |        |                |menu Outras Opções. Criada função ChamaRGB.±±
±±³Gustavo M.   |08/06/15|    TSMXXC      |Ajuste para buscar o roteiro correto.     ³±±
±±³Allyson M.   |29/07/18|    TSXEG1      |Ajuste p/ nao obrigar o preenchimento da  ³±±
±±³             |        |                |data de pagamento (conceito da P11).      ³±±
±±³Allyson M.   |05/08/15|    TSUT35      |Ajuste na consulta padrao do roteiro      ³±±
±±³M.Camargo    |06/10/15|PDR_SER_MI001152|Ajuste periodo y num pago cuando se llama ³±±
±±³             |        |PCREQ-5930      |desde GPEM042.                            ³±±
±±³Allyson M.   |19/10/15|    TTJJCZ      |Ajuste p/ validar alteracao/exclusao de   ³±±
±±³             |        |                |verba gerada por outro roteiro.           ³±±
±±³Cecilia Carv.|03/12/15|PCDEF-86832     |Ajuste para nao permitir exclusao verba ge³±±
±±³             |        |                |rada pelo Ponto Eletronico.               ³±±
±±³Allyson M.   |15/01/16|    TUETN1      |Ajuste p/ validar exclusao de verba que   ³±±
±±³             |        |                |esta na SRC. 	 		 				 ³±±
±±³Flavio C.    |16/02/16|    TUHAQJ      |Ajuste p/ validar data de referencia de   ³±±
±±³             |        |                |acordo com a configuracao de RV_LCTODIA	 ³±±
±±³Renan Borges |17/02/16|    TTSRTF      |Ajuste para integrar os lançamentos mensa-³±±
±±³             |        |                |is corretamente, independentemente se o   ³±±
±±³             |        |                |funcionário já possui lançamentos.        ³±±
±±³Renan Borges |26/02/16|    TUMJG1      |Ajuste para integrar os lançamentos mensa-³±±
±±³             |        |                |is corretamente, independentemente se o   ³±±
±±³             |        |                |funcionário já possui lançamentos.        ³±±
±±³Gustavo M.   |13/03/16|    TUNXUL      |Ajuste para corrigir erro ao entrar via   ³±±
±±³             |        |                |rescisão nos lancaments.					 ³±±
±±³Renan Borges |15/03/16|    TUQZKS      |Ajuste para carregar registros na consulta³±±
±±³             |        |                |padrão do campo de periodo.               ³±±
±±³Renan Borges |28/04/16|    TUTJKP      |Ajuste para acessar a consulta de calculo ³±±
±±³             |        |                |corretamente mesmo que seja acessado pelo ³±±
±±³             |        |                |menu funcional.                           ³±±
±±³Raquel Hager |22/06/16|TVAIZA          |Remoção de opções de Manutenção/Cálculo   ³±±
±±³             |        |                |nas rotinas de consulta. Incluída função  ³±±
±±³             |        |                |Gp090Src para exclusão do cálculo caso    ³±±
±±³             |        |                |verba do tipo Informada seja deletada.    ³±±
±±³Raquel Hager |23/06/16|TVAIZA          |Ajuste no Protheus.Doc da função Gp090Src.³±±
±±³Renan Borges |23/06/16|TVMEVB          |Ajuste para não gerar o error.log  quando ³±±
±±³             |        |                |tentar incluir registro para funcionários ³±±
±±³             |        |                |que já possuem dados na RGB.              ³±±
±±³Raquel Hager |04/07/16|TVNUM0          |Ajuste para visualização dos dados da RGB ³±±
±±³             |        |                |na rotina de Consulta de Cálculos por Fun-³±±
±±³             |        |                |cionários. Ajuste para visualização dos   ³±±
±±³             |        |                |dados da SRC na rotina de Lançamentos por ³±±
±±³             |        |                |Funcionários. Correção na exclusão de ver-³±±
±±³             |        |                |ba informada e alerta para recalculo.     ³±±
±±³Raquel Hager |05/07/16|TVNUM0          |Correção de ajustes indevidos.            ³±±
±±³Gabriel A.   |28/07/16|TVDYO9          |Alteração na validação p/ mensagem ùnica. ³±±
±±³Esther V.    |17/08/16|     TVVHM2     |Ajuste na chamada do PE GP090OK.          ³±±
±±³             |        |                |Ajuste na validacao do campo RGB_DTREF.   ³±±
±±³Renan Borges |29/09/16|TWDTE6          |Ajuste para ao mudar de funcionário seja  ³±±
±±³             |        |                |calculado os valores corretos, independen-³±±
±±³             |        |                |temente da alteração de filial ou processo³±±
±±³Allyson M.   |26/10/16|TWHDNC      	  |Ajuste p/ não matar a atalho da tecla F6  ³±±
±±³             |        |                |quando rotina executada pelo GPEM040.	 ³±±
±±³M.Camargo    ³22/11/16|MMI-4222        |Ajustes Loc. Chile: Se anexa función      ³±±
±±³             |        |                |fGetRotRes para obtener el roteiro de tipo³±±
±±³             |        |                |resición									 ³±±
±±³Renan Borges |03/12/16|MRH-1899        |Ajuste para não gerar access violation    ³±±
±±³             |        |                |quando for executar o bblock e melhoria de³±±
±±³             |        |                |performance.                              ³±±
±±³Marcos Cout. |08/12/16|MRH-180         |Ajustes na rotina para salvar e voltar a  ³±±
±±³             |        |                |tela de lançamentos por funcionários de   ³±±
±±³             |        |                |modo automatico. Ajustes na consulta de   ³±±
±±³             |        |                |calculo setando para o roteiro ativo.     ³±±
±±³Claudinei S. |28/04/17|DRHPAG-410      |Ajuste em gp090MontaGetDados() para que em³±±
±±³             |        |                |caso de Rescisão carregar o roteiro RES.  ³±±
±±³Paulo O.     |05/05/17|DRHPAG-1279     |correção de error log caso seja incluso um³±±
±±³Inzonha      |        |                |novo registro após clicar em não na msg   ³±±
±±³             |        |                |"Deseja gravar as alterações"			 ³±±
±±³Paulo O.     |08/05/17|DRHPAG-1269     |Ajuste no valor inicial da variavel       ³±±
±±³Inzonha      |        |                |bCalcular de array para bloco de codigo   ³±±
±±³Eduardo.     |24/05/17|DRHESOCP-293/273|Merge de fontes de Inovação e Sustentação ³±±
±±³			    |        |                |Ajustes e Chamada de Tela de MultiVinc.   ³±±
±±³Cícero Alves |05/07/17|DRHPAG-3520     |Ajuste na gpRCHFiltro para atualizar a	 ³±±
±±³				|		 |				  |variável cFilRCJ							 ³±±
±±³M. Silveira  ³28/07/17|DRHPAG-4531     |Ajustes na Gpea090Mnt para nao perder a   ³±±
±±³             |        |                |referencia da SRA no calculo da rescisao. ³±±
±±³Gabriel A.   |29/08/17|DRHPAG-5108     |Retirada alteração que gerou "error.log"  ³±±
±±³             |        |                |para análise posterior.                   ³±±
±±³WinstonCosta |02/01/19|DRHPAG-22991    |Retirada do trecho que trata o AS/400     ³±±
±±³Diego Rivera |04/12/19|DMINA-7856      |Se reactiva la opción "borrar" en la fun- ³±±
±±³             |        |                |ción menuDef para MI.                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function GPEA090(nOpcAuto)

	Local aSvRotSetOpc	:= {}
	Local bblock		:= Nil
	Local nPos			:= 0
	Local lGestPubl:= IIF(ExistFunc("fUsaGFP"), fUsaGFP(), .F.)
	Local cFiltraRH     := ""
	Local oBrowse

	DEFAULT __lMemCalc := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc() // Memória de Cálculo

	Private aArray		:= {}
	Private cLancAlias  := "SRC"
	Private cCRLF       := CHR(13) + CHR(10)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define array contendo as Rotinas a executar do programa      ³
	//³ ----------- Elementos contidos por dimensao ------------     ³
	//³ 1. Nome a aparecer no cabecalho                              ³
	//³ 2. Nome da Rotina associada                                  ³
	//³ 3. Usado pela rotina                                         ³
	//³ 4. Tipo de Transa‡„o a ser efetuada                          ³
	//³    1 - Pesquisa e Posiciona em um Banco de Dados             ³
	//³    2 - Simplesmente Mostra os Campos                         ³
	//³    3 - Inclui registros no Bancos de Dados                   ³
	//³    4 - Altera o registro corrente                            ³
	//³    5 - Remove o registro corrente do Banco de Dados          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Private aRotina    := MenuDef() // ajuste para versao 9.12 - chamada da funcao MenuDef() que contem aRotina

	cCadastro := Iif(FWIsInCallStack("GPEA090"), Iif(cModulo == "GFP", OemToAnsi(STR0097), OemToAnsi(STR0076)), OemToAnsi(STR0010))  //"Consulta de Cálculos por Funcionário"###"Lançamentos por Funcionários / Servidor

	If nOpcAuto <> Nil
		aSvRotSetOpc := aRotSetOpc( NIL , NIL , nOpcAuto )
		dbSelectArea('SRA')
		nPos := Ascan(aRotina,{|x| x[4]== nOpcAuto})
		If ( nPos <> 0 )
			bBlock := &( "{ |a,b,c,d,e| " + aRotina[ nPos,2 ] + "(a,b,c,d,e) }" )
			Eval( bBlock, Alias(), (Alias())->(Recno()),nPos)
		EndIf
		aRotReSetOpc( aSvRotSetOpc )
	Else

		If !lGestPubl

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se o Arquivo Esta Vazio                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !ChkVazio("SRA")
				Return( NIL )
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Inicializa o filtro utilizando a funcao FilBrowse, Faltara um filtro   ³
			//³ da tabela SRC que sera executado depois do dbSetOrder pois o dbSetOrder|
			//³ elimina o filtro do FilBrowse                                          |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aArray := {"SRA", "SRV", cLancAlias }
			ffiltro("GPEA090",aArray,2)//2- Cria as variaveis
			ffiltro("GPEA090",aArray,1,1)//1- Executa os Filtros

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Endereca a funcao de BROWSE                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SRA")
			mBrowse( 6, 1,22,75,"SRA",,,,,,fCriaCor() )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Deleta o filtro utilizando a funcao FilBrowse                     	   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ffiltro("GPEA090",aArray,0)//0- Limpa os filtros
		Else
			oBrowse := FWMBrowse():New()
			oBrowse:SetAlias('SRA')
			oBrowse:SetDescription(STR0097) //"Consulta de Cálculo por Servidor"
			GpLegend(@oBrowse,.T.) //Cria legenda
			oBrowse:SetMenuDef( 'GPEA090' )
			oBrowse:SetChgAll(.F.)

			//------------------------------------------
			//Busca o filtro a ser utilizado no Browse
			//------------------------------------------
			cFiltraRh 	:= CHKRH("GPEA090","SRA","1")
			cFiltraRh += IF(!Empty(cFiltraRh),' .and. ','')
			If cModulo $ "GFP*VDF"
				cFiltraRh += " (SRA->RA_REGIME == '2' ) "
			ElseIf cModulo == "GPE"
				cFiltraRh += " (SRA->RA_REGIME == '1' .OR. Empty(SRA->RA_REGIME) ) "
			EndIf
			//Filtro padrao do Browse conforme tabela SRW (Controle de Restricoes de Usuarios)
			oBrowse:SetFilterDefault(cFiltraRh)
			oBrowse:Activate()
		EndIf
	EndIf

Return( NIL )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea090Mnt	 ³ Autor ³Marinaldo de Jesus   ³ Data ³05/05/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Lancamentos Mensais     									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONA170  													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function Gpea090Mnt( cAlias , nReg , nOpcx, aFields, cRotCalculo, nTipo, lDisable )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define Variaveis Local                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Local aButtons		:= {}
	Local aArea			:= GetArea()
	Local aAreaSRA		:= SRA->( GetArea() )
	Local aAdvSize		:= {}
	Local aInfoAdvSize	:= {}
	Local aObjSize		:= {}
	Local aObjCoords	:= {}
	Local aVirtual		:= {}
	Local aSRCCols		:= {}
	Local aColsRec		:= {}
	Local aGrupos		:= UsrRetGrp( cUserName )
	Local aSitFunc		:= ""
	Local cNome    		:= ""
	Local cLancDemi		:= SuperGetMv("MV_DEMISRC" )
	Local cDigLancam	:= SuperGetmv("MV_DIGLANC")
	Local cCodUser 		:= RetCodUsr()
	Local cGrupos 		:= ""
	Local dPerIniPar	:= Ctod("//")
	Local dPerFimPar	:= Ctod("//")
	Local nOpca			:= 0
	Local uSvMvPar01	:= IF( Type("MV_PAR01") <> "U" , MV_PAR01 , NIL )
	Local nCoordLin		:= 0
	Local bFreeLocks	:= {|| FreeLocks(cAlias , NIL , .T. ), .T.}
	Local bGravar		:= {}
	Local bCalcular		:= {||}
	Local bApliFin 		:= {}
	Local bRevAplFin 	:= {}
	Local aPesqIdx 		:= {}
	Local aPesqOrd		:= {}
	Local lSeeAll		:= .T.
	Local lRet 			:= .T.
	Local lOfuscaNom	:= .F.
	Local lOfuscaAdm	:= .F.
	Local lOfuscaFun	:= .F.
	Local cPesqOrd
	Local cPesqCampo	:= space(40)
	Local lAxPesqui 	:=.F.
	Local lValPer		:= .T.
	Local cPrefixo		:= ""
	Local nPosStatus:= If( SRA->RA_SITFOLH = 'D', 2, 1)
	Local nX			:= 0
	Local nY			:= 0
	Local aColsRecx		:= {}
	Local lGP042Reg		:= (cPaisLoc $ "COL" .And. FunName() == "GPEM042" .And. !IsBlind())

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Objetos          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	Local oFont
	Local oGroup
	Local oDlg
	Local oBtnPgNext
	Local oBtnPgPrev
	Local oBntNext
	Local oBntPrev
	Local oPesqCbx
	Local oPesqGet
	Local oPeriodo
	Local oNrPagto
	Local oRoteiro
	Local oFunc
	Local oPers

	Local bRetrocOne := {|| .T. }
	Local bRetrocAll := {|| .T. }
	Local bAvancaOne := {|| .T. }
	Local bAvancaAll := {|| .T. }
	Local bFica      := {|| .T. }
	Local bImpr      := {|| .T. }

	Local bVisuali := {||ChamaRGB(2),gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.),oGet:ForceRefresh()}
	Local bIncluir := {||ChamaRGB(3),gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.),oGet:ForceRefresh()}
	Local bAlterar := {||ChamaRGB(4),gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.),oGet:ForceRefresh()}
	Local bBotaoCalc2	:= {|| fCalcLanc(cFil, cMat),lCalcExec := .T., gp090MontaGetDados(cAlias, nOpcX, @cFil, @cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.),oGet:ForceRefresh()}

	Local oBrwAux
	Local oFilAux
	Local cFilterAux

	Local cRoteiroAux := Iif(TYPE("cRoteiro") == "U", "",cRoteiro) //Variavel para auxiliar na abertura do Consultar Calculo
	Local lDelOk := .T.

	Local nPosPD	:= 0
	Local nPosCC	:= 0
	Local nPosSEQ	:= 0
	Local nPosDTREF	:= 0
	Local nPosRec	:= 0
	Local nPosNumId := 0 
	Local lHistMed	:= AliasInDic("RJK") .And. AliasInDic("SRP") .And. FindFunction("fVerHistMed") .And. FindFunction("fTemHMed")

	Local aOfusca	 := If(FindFunction('ChkOfusca'), ChkOfusca(), {.T.,.F.}) //[1] Acesso; [2]Ofusca
	Local aFldOfusca := {}
	Local aFldRot	 := {}
	Local cNumId		:= If (Type("cNumId") == "U", "", cNumId) //Recebida no GPEA580() para tratamento do Consignado.
	Local lSemDtRef := .F.

	nModAuto := If (Type("nModAuto") == "U", 1, nModAuto)
	lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)

	Private cFil := ""
	Private cMat
	Private lCalcExec	:= .F.

	//--> Variável para controlar o texto do título que será adicionado à janela.
	If Type("lTitCalc") == "U"
		Private lTitCalc	:= .F.
	EndIf

	//--> Variável para controlar o texto do título que será adicionado à janela.
	If Type("lTitLanc") == "U"
		Private lTitLanc	:= .F.
	EndIf

	If lGp580Auto

		cFil :=	xFilial("SRA")
		If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='RA_MAT'})) > 0
			cMat :=	aAutoCab[nT,2]
		EndIf

		dbSelectArea("SRA")
		dbSetOrder(1)
		If !dbSeek(cFil+cMat)
			Help( " ", 1, "REGNOIS" )
			Return
		EndIf
		cFil		:= SRA->RA_FILIAL
		cMat     	:= SRA->RA_MAT
		cNome    	:= SRA->RA_NOME

	Else
		If !IsInCallStack("GPEM040") .AND. !IsInCallStack("GPEM042")
			oBrwAux 		:= GetMBrowse()
			If !oBrwAux:lNoBrowse
				oFilAux 		:= oBrwAux:FwFilter()
				cFilterAux		:= oFilAux:GetExprADVPL()

				If !Empty(cFilterAux)
					DbSelectArea("SRA")
					cFilterAux := StrTran(cFilterAux, 'RA_SITFOLH== ""', 'RA_SITFOLH== " "')
				EndIf

				If Len(fValidFil()) <= 2000
					cFilterAux += If( !( Empty( cFilterAux ) ), ' .And. SRA->RA_FILIAL $ fValidFil() ', ' SRA->RA_FILIAL $ fValidFil() ' )
				Else
					cFilterAux += If( !( Empty( cFilterAux ) ), ' .And. !( SRA->RA_FILIAL $ fValidFil(,.T.) ) ', ' !( SRA->RA_FILIAL $ fValidFil(,.T.) ) ' )
				EndIf

				DbSetFilter({||&cFilterAux},cFilterAux)
			EndIf
		Endif

		cFil		:= SRA->RA_FILIAL
		cMat    	:= SRA->RA_MAT
		cNome   	:= SRA->RA_NOME

	EndIf

	aSitFunc		:= RetSituacao( SRA->RA_FILIAL , SRA->RA_MAT , .F. )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Blocos de Codigo                                            ³
	//³================                                            ³
	//³Serao utilizados na acao do botoes de movimentacao, "Avanca"³
	//³"Retrocede", "Avanca Todos" e "Retrocede Todos".            ³
	//³O Bloco "bFica" sera utilizado quando forem alterados os    ³
	//³campos data de referencia, semana e tipo de lancamento.     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	bRetrocOne := {|| SRA->( dbskip(-1))	 ,gp090MontaGetDados(cAlias, nOpcX, @cFil, @cMat, @aVirtual, @aColsRec, @aSRCCols, .T., .F.), oGet:oBrowse:Refresh(),oDLG:Refresh()}
	bRetrocAll := {|| SRA->( dbGoTop())	 ,gp090MontaGetDados(cAlias, nOpcX, @cFil, @cMat, @aVirtual, @aColsRec, @aSRCCols, .T., .F.), oGet:oBrowse:Refresh(),oDLG:Refresh()}
	bAvancaOne := {|| SRA->( dbskip())	 ,If( SRA->(! EOF()),aCols:= {},.T.), gp090MontaGetDados(cAlias, nOpcX, @cFil, @cMat, @aVirtual, @aColsRec, @aSRCCols, .T., .F.), oGet:oBrowse:Refresh(),oDLG:Refresh()}
	bAvancaAll := {|| SRA->( dbGoBottom()),gp090MontaGetDados(cAlias, nOpcX, @cFil, @cMat, @aVirtual, @aColsRec, @aSRCCols, .T., .F.),oGet:oBrowse:Refresh(),oDLG:Refresh()}
	bFica      := {|| gp090MontaGetDados(cAlias, nOpcX, @cFil, @cMat, @aVirtual, @aColsRec, @aSRCCols, .T., .F.),If(lDaRefresh,(oGet:oBrowse:Refresh(),oDLG:Refresh()),.t.)}

	If Type("cLancAlias") == "U"
		cLancAlias := "SRC"
	EndIf

	cAlias   := cLancAlias
	cPrefixo := ( PrefixoCpo( cAlias ) + "_" )

	If cAlias == "SRC" .and. ( MV_MODFOL == '2' .Or. cPaisLoc $ "PTG|COL|VEN" )
		If nOpcx > 2
			nOpcx += 2
		EndIf
	ElseIf ( cPaisLoc == "PER" .and. nOpcX == 3 .and. !( IsInCallStack("GPEA580") .or. IsInCallStack("GPEA590") ) )
		nOpcX := 5
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define Variaveis Privadas                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Private aTELA			:= {}
	Private aGETS			:= {}
	Private aHeader 		:= {}
	Private aCols			:= {}
	Private aColsAnt		:= {}
	Private aGdAltera		:= {}
	Private aIndexSrv		:= {}
	Private bBlkGravar		:= {||;
									 If(Gpea090LinOk() .AND. If(cPaisLoc $ "PTG",Gpea090TudOk(),.T.) ,;
									 Gpea090Grava(cAlias,cFil,cMat,aVirtual,aColsRec,nOpcx,.F.,.F.), .T.) ;
								}
	Private bBotaoGravar	:= {||;
									 If(Gpea090LinOk() .AND. If(cPaisLoc $ "PTG",Gpea090TudOk(),.T.) ;
									 .AND. If(lGP090CHK,ExecBlock( "GP090CHK", .F., .F., {cCodUser, cGrupos, aClone( aColsAnt ), aClone( aCols )} ),.T.),;
									 Gpea090Grava(cAlias,cFil,cMat,aVirtual,aColsRec,nOpcx,.T.,.F.), .T.) ;
								}


	Private bBotaoCalc		:= {|| fCalcLanc(cFil, cMat)}
	Private cDigSemana		:= SuperGetmv("MV_DIGSEMA")
	Private cDigHoras		:= SuperGetmv("MV_HORASDE")
	Private cSemana  		:= Space( TamSx3(cPrefixo+"SEMANA")[1] )
	Private cCategoria		:= SRA->RA_CATFUNC
	Private cProcesso		:= SRA->RA_PROCES
	Private cPosto 			:= SRA->RA_POSTO
	Private cPeriodo
	Private cPeriodoAnt
	Private cNumPagto		:= ""
	Private cSemanaAnt
	Private cDataIni
	Private cDataFim
	Private cRoteiro		:= If( !Empty(cRotCalculo), cRotCalculo, (Iif(TYPE("cRoteiro") == "U" ,"",cRoteiro)))
	Private cRoteiroAnt
	Private cCodRoteiro		:= ""
	Private cCodProcesso	:= ""
	Private cKeyRCH 		:= ""
	Private aGhCols			:= {}
	Private nValLanc		:= 0
	Private nValCalc		:= 0
	Private oGet
	Private lSRCLock		:= .F.
	Private cCond			:= "1"
	Private lDaRefresh		:= .F.
	Private lAchouMsg 		:= .T.
	Private nAchou 				:= 0
	Private nUsado  		:= 0
	Private lVerificaMes	:= .F.
	Private nTotHorAcm		:= 0
	Private lItemClVl		:= SuperGetMv("MV_ITMCLVL",NIL,"2")  $ "1*3" //variavel que define se os campos "Item Contabil" e Classe de Valor" estão ativos
	Private lDelCalc		:= .F.   // flag para exclusao de calculo quando existir exclusao de verba do tipo I-Informado.
	lM2Modif				:= .F.   //flag para saber se houve alteracoes (utilizado em chamada de rotinas a partir da tela de rescisao)

	//variaveis localizacao arg
	Private cAnoAcuIni := ""
	Private cAnoAcuFim := ""

	Static lHabBtF6 := .F.

	_SetOwnerPrvt( "nOpcNewGd", IF( nOpcX == 2 .or. nOpcX == 5 , 0 , GD_INSERT + GD_UPDATE + GD_DELETE))

	DEFAULT nTipo	 := 1
	DEFAULT lDisable := .F.

	//Inicializa as variaveis da chave quando for execauto
	If lGp580Auto
		If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='CROTEIRO'})) > 0
			cRoteiro :=	aAutoCab[nT,2]
		EndIf
		If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='CNUMPAGTO'})) > 0
			cNumPagto :=	aAutoCab[nT,2]
		EndIf
		If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='CPERIODO'})) > 0
			cPeriodo :=	aAutoCab[nT,2]
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta as Dimensoes dos Objetos         					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !lGp580Auto
		aAdvSize		:= MsAdvSize()
		aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
		aAdd( aObjCoords , { 000, 020, .T. , .F. } )
		aAdd( aObjCoords , { 000, 020, .T. , .F. } )
		aAdd( aObjCoords , { 000, 000, .T. , .T. } )
		aAdd( aObjCoords , { 000, 025, .T. , .F. } )
		aObjSize := MsObjSize( aInfoAdvSize , aObjCoords )
	EndIf
	If (!lGp580Auto) .AND. (nOpcx == 2)  .AND. (cPaisLoc == 'BRA' .AND. fGP90MultV("A"))
		Aadd(aButtons, {"VINCULO", {|| fGP90MultV("V") },  OemToAnsi(STR0082) }) //"Multiplos Vinculos"
	EndIf
	If (nOpcx = 3) .OR. (nOpcx = 4)

		bGravar	:= { || (;
			 			 MsAguarde( bBotaoGravar, OemToAnsi(STR0024)),;
						 NIL;
						);
					}

		if cPaisLoc != "RUS"
			aAdd(;
					aButtons	,;
									{;
										"SALVAR" 			,;
										bGravar				,;
										OemToAnsi( STR0028 ),;	//"Gravar"
										OemToAnsi( STR0028 ) ;	//"Gravar"
									};
				)
		endif

		If((IsInCallStack("GPEA580") .Or. IsInCallStack("GPEA090")) .and. !(IsInCallStack("GPEM040")) .and. !(IsInCallStack("GPEM042")) .and. !(IsInCallStack("GPEM030"))) //Não deve exibir o botão para cálculo quando rotina for aberta pela rotina de rescisão ou férias.
			bCalcular	:= { || (;
								MsAguarde( bBotaoCalc, OemToAnsi(STR0024)),;
								NIL;
								);
							}
			If cPaisLoc != "RUS"
				aAdd(;
					aButtons	,;
								{;
									"CALCULAR" 			,;
									bCalcular			,;
									OemToAnsi( STR0062 ),;	//"Calcular Lancamento"
									OemToAnsi( STR0062 ) + " (F6)" ;	//"Calcular Lancamento"
								};
					)
			EndIf

			//--> Adicionado HotKey para cálcular o lançamento
			SetKey(VK_F6, bCalcular)
			lHabBtF6 := .T. 
		EndIf
	EndIf
    
	If nOpcx == 2 .And. FWIsInCallStack("GPEA090") .And. lHabBtF6
		bCalcular := {||(MsAguarde( bBotaoCalc, OemToAnsi(STR0024)), NIL)}
	EndIf

	//--> Consulta dos lançamentos na SRC. O registro ja está posicionado no Recno correto para efetuar a consulta.
	If FWIsInCallStack("GPEA580") .And. !FWIsInCallStack("GPEA090")
		Aadd(aButtons, {"CARGA", {|| lTitCalc:= .T.,  SetKey(VK_F6, {||Nil}), Gpea090(2), SetKey(VK_F6, bCalcular) }, OemToAnsi( STR0075 )+" (F7)" }) //"Consultar Calculo"
		bConsultar	:= { || (;
								MsAguarde( Gpea090(2), OemToAnsi(STR0024)),;
								NIL;
								);
							}
		SetKey(VK_F7, bConsultar)
		Aadd(aButtons, {"CARGA", {|| Gpea630(2,2) }, OemToAnsi( STR0099 ) }) //"Recibo Pgto."
	EndIf

	If cPaisLoc != "RUS"
		bImpr	:= { || lTitLanc:= .T.,GPER101(2) }

		//--> Consulta dos lançamentos na RGB. O registro ja está posicionado no Recno correto para efetuar a consulta..
		If FWIsInCallStack("GPEA090") .And. !FWIsInCallStack("GPEA580")
			Aadd(aButtons, {"CARGA", {|| lTitLanc:= .T.,Gpea580(2) }, OemToAnsi( STR0077 ) }) //"Consultar Lançamentos"
			Aadd(aButtons, {"CARGA", {|| eval(bImpr) }, OemToAnsi( STR0095 ) })  //"Imprimir"
			SetKey( VK_F10 , bImpr )
		EndIf

		//--> Consulta LOG de Calculo. -- Outras Ações parte de dentro
		If (FWIsInCallStack("GPEA090"))
			fSetVK()
			If __lMemCalc
				Aadd(aButtons, {"LOG", {|| GPEA091(1) }, OemToAnsi( STR0087 ) }) //"Consultar Memória de Calculo"
			EndIf	
		EndIf
		If lHistMed
			Aadd(aButtons, {"CARGA", {|| fMedHist() }, OemToAnsi( STR0117 ) }) //"Médias"
		EndIf
	EndIf

	// Visualizacao de Finiquitos - Mexico
	If cPaisLoc == "MEX" .and. nTipo == 2
		If nOpcx <> 5
			bApliFin 	:= { || If( Gpm040Fin(1, @cRoteiro, @cPeriodo, @cNumPagto), (;
															   	gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.),;
															   	oGet:Refresh();
																), .F.) }
			bRevAplFin 	:= { || If( Gpm040Fin(2, @cRoteiro, @cPeriodo, @cNumPagto), (;
															   	gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.),;
															   	oGet:Refresh();
																), .F.) }
			bGPEA550 	:= { || GpeA550(),;
			 					If( lM2Modif, IF( MsgNoYes(	OemToAnsi(	STR0051 + CRLF + CRLF + STR0052), OemToAnsi( STR0040 ) ),GPEM022(cProcesso, cRoteiro, nPosStatus, .T., SRA->RA_MAT,,,, .T.), ), );
							, lM2Modif:= .F., oGet:Refresh()}   //"Estas modificações só terão efeito se a rescisão for recalculada." ## "Deseja recalcular agora?" ## "Attention"

			bGPEA580 	:= { || ;
			 					If(GPEA580(), IF( MsgNoYes(	OemToAnsi(	STR0051 + CRLF + CRLF + STR0052), OemToAnsi( STR0040 ) ),GPEM022(cProcesso, cRoteiro, nPosStatus, .T., SRA->RA_MAT,,,, .T.), ), );
							, oGet:Refresh()}   //"Estas modificações só terão efeito se a rescisão for recalculada." ## "Deseja recalcular agora?" ## "Attention"

			bGPEA240 	:= { || GpeA240(),;
			 					If(lM2Modif, IF( MsgNoYes(	OemToAnsi(	STR0051 + CRLF + CRLF + STR0052), OemToAnsi( STR0040 ) ),GPEM022(cProcesso, cRoteiro, nPosStatus, .T., SRA->RA_MAT,,,, .T.), ), );
							, lM2Modif:= .F., oGet:Refresh()}   //"Estas modificações só terão efeito se a rescisão for recalculada." ## "Deseja recalcular agora?" ## "Attention"

			bGPEA110 	:= { || Gpea110(),;
			 					If(lM2Modif, IF( MsgNoYes(	OemToAnsi(	STR0051 + CRLF + CRLF + STR0052), OemToAnsi( STR0040 ) ),GPEM022(cProcesso, cRoteiro, nPosStatus, .T., SRA->RA_MAT,,,, .T.), ), );
							, lM2Modif:= .F., oGet:Refresh()}   //"Estas modificações só terão efeito se a rescisão for recalculada." ## "Deseja recalcular agora?" ## "Attention"

			bGPEA640 	:= { || Gpea640(),;
			 					If(lM2Modif, IF( MsgNoYes(	OemToAnsi(	STR0051 + CRLF + CRLF + STR0052), OemToAnsi( STR0040 ) ),GPEM022(cProcesso, cRoteiro, nPosStatus, .T., SRA->RA_MAT,,,, .T.), ), );
							, lM2Modif:= .F., oGet:Refresh()}   //"Estas modificações só terão efeito se a rescisão for recalculada." ## "Deseja recalcular agora?" ## "Attention"

			aAdd(aButtons, { "E5" , bApliFin  , OemToAnsi( STR0033 ), OemToAnsi( STR0032 ) } ) // "Aplicacão de Finiquitos"
			aAdd(aButtons, { "ATALHO", bRevAplFin, OemToAnsi( STR0035 ) , OemToAnsi( STR0034 ) } ) // "Reversao de Aplicação de Finiquitos"
			aAdd(aButtons, { "Fixos"      , bGPEA550, , OemToAnsi( STR0053 ) } ) //"Lançamentos Fixos"
			aAdd(aButtons, { "Incidencias", bGPEA580, , OemToAnsi( STR0054 ) } ) //"Incidências por funcionário"
			aAdd(aButtons, { "Ausencias"  , bGPEA240, , OemToAnsi( STR0055 ) } ) //"Ausências"
			aAdd(aButtons, { "Prestamos"  , bGPEA110, , OemToAnsi( STR0056 ) } ) //"Valores Futuros"
			aAdd(aButtons, { "Extra"      , bGPEA640, , OemToAnsi( STR0057 ) } ) //"Tempo Extra"

		EndIf
	EndIf

	//Monta o título da janela de acordo com a chamada
	If nOpcx == 2 .And. FunName() == "GPEA580" .And. lTitCalc
		cCadastro := If(cModulo == "GFP", OemToAnsi(STR0097), OemToAnsi(STR0076)) //"Consulta de Cálculo por Funcionário" / Servidor
	ElseIf nOpcx == 2 .And. FunName() == "GPEA090"
		cCadastro := If(!lTitLanc,If(cModulo == "GFP", OemToAnsi(STR0097), OemToAnsi(STR0076)),If(cModulo == "GFP", OemToAnsi(STR0098), OemToAnsi(STR0079))) //"Consulta de Cálculo por Funcionário/Servidor"###"Consulta de Lançamentos por Funcionário\Servidor"
	Else
		if cPaisLoc == "RUS"
			cCadastro := OemToAnsi(STR0090)
		else
			cCadastro := OemToAnsi(STR0010)
		endif
	EndIf

	aEval( aGrupos , { |x| ( cGrupos += ( x + "/" ) ) } )

	Begin Sequence

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Cria Array de Campos Alteraveis                              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		dbSelectArea(cAlias)


		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se o Funcionario Esta Demitido                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If ( aSitFunc[1] == "D" ) .And. !FWIsInCallStack("GPEA090")
			If !( cLancDemi == "S" )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Nao Permite o Lancamento Para o Funcionario                  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If FunName() <> "GPEM040" .and. FunName() <> "GPEM042"
					fSetVK()
					Help(" ",1,"NOLANCDEMI")
					Break
				EndIf
			Else
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Permite o Lancamento Para o Funcionario                      ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If MV_MODFOL <> "2"
					If FunName() <> "GPEM040" .and. FunName() <> "GPEM042"
						If !lGp580Auto
							fSetVK()
							Help(" ",1,"A090DEMITI")
							fSetVK(bCalcular, bConsultar)
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		If !lGp580Auto .And. !FWIsInCallStack("GPEA090") .And. !Empty(aSitFunc[1]) .And. aSitFunc[1] $ "A*F*T"
			fSetVK()
			Help(" ", 1, If(aSitFunc[1] == "A", "A090AFASTA", If(aSitFunc[1] == "F", "A090FERIAS", "A090TRANSF")))
			fSetVK(bCalcular, bConsultar)
		EndIf

		//Seleciona periodo aberto
		If Empty(cRoteiro)
			if cPaisLoc == "CHI" .AND. FunName() == "GPEM042"
				cRoteiro 	:= fGetRotRes()
			EndIf
		EndIf
		//Seleciona periodo aberto
		If Empty(cRoteiro)
			If IsInCallStack("GPEM040")
				cRot := cRoteiro := fGetCalcRot('4')
			//ElseiF IsInCallStack("GPEM042")
				//cRoteiro 	:= fGetCalcRot('4')
			Else
				If SRA->RA_CATFUNC $ "A*P"
					cRoteiro := fGetCalcRot("9")
				Else
					cRoteiro := Iif(cRoteiroAux == "VEX", cRoteiroAux, fGetRotOrdinar())
				EndIf
			EndIf
		EndIf

		If !lGp580Auto
			If FunName() == "GPEM030" .and. !Empty(M->RH_PERIODO)
				cPeriodoAnt := cPeriodo := M->RH_PERIODO
				cSemanaAnt := cNumPagto:= M->RH_NPAGTO
				cRoteiroAnt := cRoteiro := M->RH_ROTEIR
				RCH->(DbSetORder(1))//RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR
				RCH->(DbSeek(xFilial("RCH")+cProcesso+cPeriodo+cNumPagto+cRoteiro))
			Else
				If lGP042Reg .And. !Empty(M->RG_ROTEIR) .And. !Empty(M->RG_PERIODO) .And. !Empty(M->RG_SEMANA)
					cRoteiro	:= M->RG_ROTEIR
					cPeriodo	:= M->RG_PERIODO
					cNumPagto	:= M->RG_SEMANA
				Else
					cPeriodo	:= gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_ROTEIR = '" + cRoteiro + "' AND RCH_DTFECH = '' ", "RCH_PER" ,,.T. )
					cNumPagto 	:= gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_ROTEIR = '" + cRoteiro + "' AND RCH_DTFECH = '' ", "RCH_NUMPAG" ,,.T. )
				EndIf
				If Empty( cPeriodo )
					cPeriodo	:= gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_DTFECH = '' ", "RCH_PER" ,,.T. )
					cNumPagto 	:= gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_DTFECH = '' ", "RCH_NUMPAG" ,,.T. )
				EndIf
				If Empty(cRoteiro)
					cRoteiro	:= gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_ROTEIR = '" + cRoteiro + "' AND RCH_DTFECH = '' ", "RCH_ROTEIR" ,,.T. )
				EndIf
			EndIf
		EndIf

		If IsInCallStack("GPEM040")
			If !Empty(GetMemVar("RG_PERIODO"))
				cPeriodo := GetMemVar("RG_PERIODO")
				cNumPagto := GetMemVar("RG_SEMANA")
				RCH->(DbSetORder(1))//RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR
				RCH->(DbSeek(xFilial("RCH")+cProcesso+cPeriodo+cNumPagto+cRoteiro))
			EndIf
		EndIf

		//Para nao buscar um novo roteiro na entrada - Funcao Gp090MontaGetDados
		cPeriodoAnt := cPeriodo
		cSemanaAnt	:= cNumPagto

		If ( Empty(cPeriodo) .and. Empty(cPeriodoAnt) )
			Help(" ", 1, OemToAnsi(STR0136), Nil, OemToAnsi(STR0049),1,0)
			Return .F.
		EndIf

		gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.)

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Mostra Tela para Informar Total do Lan‡amento MV_DIGLANC="S"³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If lGp580Auto
			cDigLancam:="N"
		EndIf

		If ( ( nOpcx <> 5 ) .and. ( nOpcx <> 2 ) )
			If ( cDigLancam == "S" )
				fTotLanc()
			EndIf
		EndIf

		If !lGp580Auto
			DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
			DEFINE MSDIALOG oDlg TITLE cCadastro From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL
			//Protecao de Dados Sensiveis
			If aOfusca[2]
				aFldRot := {'RA_NOME', 'RA_ADMISSA', 'RA_CODFUNC'}
				aFldOfusca 	:= FwProtectedDataUtil():UsrNoAccessFieldsInList( aFldRot ) // CAMPOS SEM ACESSO

				IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_NOME" } ) > 0
					lOfuscaNom	:= FwProtectedDataUtil():IsFieldInList( "RA_NOME" )
				ENDIF

				IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_ADMISSA" } ) > 0
					lOfuscaAdm	:= FwProtectedDataUtil():IsFieldInList( "RA_ADMISSA" )
				ENDIF

				IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_CODFUNC" } ) > 0
					lOfuscaFun	:= FwProtectedDataUtil():IsFieldInList( "RA_CODFUNC" )
				ENDIF
			EndIf
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Define grupo do cabecalho       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Matricula, Nome, Admissao, Processo e Posto       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			@ aObjSize[1,1],aObjSize[1,2] 			GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.1 	LABEL OemToAnsi(STR0013) OF oDlg PIXEL // Matricula:
			oGroup:oFont:= oFont
			If cPaisLoc == "RUS"
				@ aObjSize[1,1],aObjSize[1,4]*0.105	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.20 	LABEL OemToAnsi(STR0096) OF oDlg PIXEL // Personal Registration Number
				oGroup:oFont:= oFont
				@ aObjSize[1,1],aObjSize[1,4]*0.205 	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.7 	LABEL OemToAnsi(STR0014) OF oDlg PIXEL // Nome:
				oGroup:oFont:= oFont
			Else
				@ aObjSize[1,1],aObjSize[1,4]*0.105 	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.7 	LABEL OemToAnsi(STR0014) OF oDlg PIXEL // Nome:
				oGroup:oFont:= oFont
			EndIf
			@ aObjSize[1,1],aObjSize[1,4]*0.705 	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.8	LABEL OemToAnsi(STR0019) OF oDlg PIXEL	// Admiss„o:
			oGroup:oFont:= oFont
			@ aObjSize[1,1],aObjSize[1,4]*0.805 	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.9 	LABEL OemToAnsi(STR0021) OF oDlg PIXEL // Processo:
			oGroup:oFont:= oFont

			If cPaisLoc != "RUS"
				@ aObjSize[1,1],aObjSize[1,4]*0.905 	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4] 		LABEL OemToAnsi(STR0043) OF oDlg PIXEL // Função:
				oGroup:oFont:= oFont
			EndIf

			/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Codigo do Periodo, Numero de Pagamento, Roteiro, Data Inicio e Data Fim do periodo ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			@ aObjSize[2,1],aObjSize[2,2] 			GROUP oGroup TO aObjSize[2,3], aObjSize[2,4]*0.18  LABEL OemToAnsi(STR0027) OF oDlg PIXEL	// Codigo do Periodo:
			oGroup:oFont:= oFont
			@ aObjSize[2,1],aObjSize[2,4]*0.185	GROUP oGroup TO aObjSize[2,3], aObjSize[2,4]*0.36 	LABEL OemToAnsi(STR0026) OF oDlg PIXEL	// Numero de Pagamento:
			oGroup:oFont:= oFont
			@ aObjSize[2,1],aObjSize[2,4]*0.365	GROUP oGroup TO aObjSize[2,3], aObjSize[2,4]*0.54 	LABEL OemToAnsi(STR0029) OF oDlg PIXEL  // Roteiro:
			oGroup:oFont:= oFont
			@ aObjSize[2,1],aObjSize[2,4]*0.545	GROUP oGroup TO aObjSize[2,3], aObjSize[2,4]*0.76 	LABEL OemToAnsi(STR0023) OF oDlg PIXEL	// Periodo:
			oGroup:oFont:= oFont

			@ aObjSize[1,1]+10,aObjSize[1,2]*2.5 	SAY oFunc Var cMat	SIZE 050,10 OF oDlg PIXEL FONT oFont
			If cPaisLoc == "RUS"
				@ aObjSize[1,1]+10,aObjSize[1,4]*0.12 	SAY oPers Var OemToAnsi(SRA->RA_CODUNIC)				SIZE 050,10 OF oDlg PIXEL FONT oFont
				@ aObjSize[1,1]+10,aObjSize[1,4]*0.22	SAY AllTrim(OemToAnsi(SRA->RA_NOME))	SIZE 196,10 OF oDlg PIXEL FONT oFont
			Else
				@ aObjSize[1,1]+10,aObjSize[1,4]*0.12	SAY If(lOfuscaNom,Replicate('*',15),OemToAnsi(SRA->RA_NOME))			SIZE 146,10 OF oDlg PIXEL FONT oFont
			EndIf
			@ aObjSize[1,1]+10,aObjSize[1,4]*0.72	SAY If(lOfuscaAdm,Replicate('*',10),Dtoc(SRA->RA_ADMISSA)) 			SIZE 050,10 OF oDlg PIXEL FONT oFont
			@ aObjSize[1,1]+10,aObjSize[1,4]*0.82	SAY OemToAnsi(SRA->RA_PROCES) 		SIZE 050,10 OF oDlg PIXEL FONT oFont

			If cPaisLoc != "RUS"
				@ aObjSize[1,1]+10,aObjSize[1,4]*0.92	SAY If(lOfuscaFun,Replicate('*',5),OemToAnsi(SRA->RA_CODFUNC))		SIZE 050,10 OF oDlg PIXEL FONT oFont
			EndIf

			@ aObjSize[2,1]+8 , aObjSize[2,2]*2 MSGET oPeriodo Var cPeriodo WHEN !lDisable PICTURE "@E 999999" F3 "RCH" HASBUTTON;
			VALID If( lValPer, lValPer := (Vazio() .OR. ExistCpo( "RCH", cProcesso + cPeriodo + "        ", 2)), lValPer := .T. )	.AND. ;
				fAtualRot() 																			    .AND. ;
				If( ExistBlock("GP090VLD"), ExecBlock("GP090VLD",.F.,.F.), .T.)						    .AND. ;
				If(cPeriodo <> cPeriodoAnt, If(lSRCLock, Eval(bFreeLocks), .T.), .T.)						.AND. ;
				If(cPeriodo <> cPeriodoAnt, If((lSRCLock := Gpea090Locks(nOpcx , cAlias)) , .T., .F.), .T.) 	.AND. ;
				If(cPeriodo <> cPeriodoAnt, gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .T.), .T.) ;
			SIZE 50,7 OF oDlg PIXEL

			@ aObjSize[2,1]+8 , aObjSize[2,4]*0.20  MSGET oNrPagto Var cNumPagto;
				PICTURE GetSx3Cache( "RCH_NUMPAG" , "X3_PICTURE" ) HASBUTTON;
				VALID If( lValPer, lValPer := ExistCpo( "RCH", cProcesso + cPeriodo + cNumPagto + "        ", 3),lValPer := .T.) 	.AND. ;
					fAtualRot() 														 .AND. ;
					If(cNumPagto <> cSemanaAnt, gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .T.), .T.) ;
				SIZE 50,7 OF oDlg PIXEL;
				WHEN If(cPaisLoc == "RUS", .F.,!lDisable);
				F3  If(cPaisLOc == "RUS",,"RCH01")

			oNrPagto:bHelp := {|| ShowHelpCpo("cNumPagto",{GetHlpSoluc("RCH_NUMPAG")[1]},2,{GetHlpSoluc("RCH_NUMPAG")[2]},2)}

			@ aObjSize[2,1]+8 , aObjSize[2,4]*0.38 MSGET oRoteiro Var cRoteiro;
				PICTURE "@N NNN"  HASBUTTON;
				VALID If( lValPer, lValPer := (Vazio() .OR. ( ExistCpo("SRY", cRoteiro) .and. Gp090VldRot(cRoteiro) )), lValPer := .T. )	.AND. ;
					If(cRoteiro <> cRoteiroAnt, gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .T.), .T.) ;
				SIZE 50,7 OF oDlg PIXEL;
				WHEN If(cPaisLoc == "RUS", .F.,!lDisable);
				F3  If(cPaisLOc == "RUS",,"SRYREL")

			@ aObjSize[2,1]+10, aObjSize[2,4]*0.56 SAY DTOC(cDataIni) + " - "  + DTOC(cDataFim) SIZE 060,10 OF oDlg PIXEL FONT oFont

			oGet := MsNewGetDados():New(aObjSize[3,1],;// nTop
										 aObjSize[3,2],;   	// nLelft
										 aObjSize[3,3],;	// nBottom
			                             aObjSize[3,4],;	// nRright
										 nOpcNewGd,;		// controle do que podera ser realizado na GetDado - nstyle
										 "Gpea090LinOk",;	// funcao para validar a edicao da linha - ulinhaOK
										 "Gpea090TudOk",;	// funcao para validar todas os registros da GetDados - uTudoOK
		  								 NIL,;				// cIniCPOS
										 aGdAltera,;		// aAlter
										 0,; 				// nfreeze
										 99999,;  			// nMax
										 NIL,;		 		// cFieldOK
										 NIL,;				// usuperdel
										 If(nOpcx=2.Or.nOpcx=5,.F.,{||Gp090VldDel(@cKeyRCH,nOpcx)}),;		// udelOK
										 @oDlg,;        	// objeto de dialogo - oWnd
										 @aHeader,;			// Vetor com Colunas - AparHeader
										 @aSRCCols;			// Vetor com Header - AparCols
										)

			// Validar a linha atual quando a GetDados perder o foco.
			oGet:oBrowse:bLostFocus := { || If(!Gpea090LinOk(), oGet:oBrowse:SetFocus(), .T.) }

			// Verificar se o roteiro foi informado antes de incluir a linha.
			oGet:oBrowse:bGotFocus := { || If(Empty(cRoteiro), oRoteiro:SetFocus(), If( lValPer := GpValidPer( NIL, cProcesso, cPeriodo, cNumPagto, cRoteiro,.T.), .T., (oRoteiro:SetFocus(), cRoteiro := Space(3), oRoteiro:Refresh()))) }

			If Type( "lNoShowFunc" ) == "U" .Or. !lNoShowFunc //Tratamento para chamada da rotina atraves de tela de rescisão (Modelo 2)
				/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Define grupo do rodape          ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				@ aObjSize[4,1], aObjSize[4,2] GROUP oGroup TO  aObjSize[4,3], aObjSize[4,4] LABEL OemToAnsi(STR0030) OF oDlg PIXEL	 //"Pesquisar Funcionarios"
				oGroup:oFont:= oFont

				/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Lista Botoes de posicionamento do funcionario ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				@ aObjSize[4,1]+10, aObjSize[4,2]+08.96 BUTTON oBtnPgPrev 	PROMPT OemToAnsi("<<")	 SIZE 021.5, 10 DESIGN ACTION Gp090Movimenta(bRetrocAll) OF oDlg PIXEL
				@ aObjSize[4,1]+10, aObjSize[4,2]+29.96	BUTTON oBtnPrev		PROMPT OemToAnsi("<")	 SIZE 021.5, 10 DESIGN ACTION Gp090Movimenta(bRetrocOne) OF oDlg PIXEL
				@ aObjSize[4,1]+10, aObjSize[4,2]+50.96	BUTTON oBntNext 	PROMPT OemToAnsi(">")	 SIZE 021.5, 10 DESIGN ACTION Gp090Movimenta(bAvancaOne) OF oDlg PIXEL
				@ aObjSize[4,1]+10, aObjSize[4,2]+71.96	BUTTON oBtnPgNext 	PROMPT OemToAnsi(">>")	 SIZE 021.5, 10 DESIGN ACTION Gp090Movimenta(bAvancaALL) OF oDlg PIXEL

				AxPesqOrd("SRA",@aPesqIdx,,lSeeAll,@aPesqOrd)

				cPesqOrd := aPesqOrd[1]

				@ aObjSize[4,1]+10,aObjSize[4,4]*0.28 			COMBOBOX oPesqCbx 	VAR cPesqOrd ITEMS aPesqOrd SIZE 100,	36 	PIXEL OF oDlg ON CHANGE If(lAxPesqui,(DbSelectArea(cAlias),DbSetOrder(aPesqIdx[oPesqCbx:nAt][1]),__oObjBrow:Refresh()),)
				@ aObjSize[4,1]+10,(aObjSize[4,4]*0.28)+110 	MSGET    oPesqGet 	VAR cPesqCampo 				SIZE 100,	09 	PIXEL OF oDlg
				@ aObjSize[4,1]+10,(aObjSize[4,4]*0.28)+220 	BUTTON   "Ok" 									SIZE 021.5,	10 	PIXEL OF oDlg ACTION (AxPesqSeek("SRA",.F.,cPesqCampo,,aPesqIdx,oPesqCbx:nAt,lSeeAll,),Gp640Movimenta(bFica))
			Endif

			bSet15	:= {|| nOpca:=1, ;
						If(oGet:TudoOk(), oDlg:End(), If(cDigLancam=="S", fTotLanc(),nOpca:=0) ) }
			bSet24	:= {|| oDlg:End()}

			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24, NIL , aButtons ) CENTERED

		Else

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//|Valid do cPeriodo				                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistCpo( "RCH", cProcesso + cPeriodo, 2)				 .And.;
				If(lGp580Auto .And. !Empty(cRoteiro), .T.,fAtualRot()) 																	 .AND. ;
				If( ExistBlock("GP090VLD"), ExecBlock("GP090VLD",.F.,.F.), .T.) .AND. ;
				If(cPeriodo <> cPeriodoAnt, If(lSRCLock, Eval(bFreeLocks), .T.), .T.) .AND. ;
				If(cPeriodo <> cPeriodoAnt, If((lSRCLock := Gpea090Locks(nOpcx , cAlias)) , .T., .F.), .T.) 	.AND. ;
				If(cPeriodo <> cPeriodoAnt, gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F.), .T.)
				nOpcA:=1
			Else
				nOpcA:=0
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//|Valid do cNumPagto  			                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistCpo( "RCH", cProcesso + cPeriodo + cNumPagto + "        ", 3) .AND. ;
				If(lGp580Auto .And. !Empty(cRoteiro), .T.,fAtualRot()) 	 														 				 .AND. ;
				If(cNumPagto <> cSemanaAnt, gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F.), .T.)
				nOpcA:=1
			Else
				nOpcA:=0
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//|Valid do cRoteiro  			                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistCpo("SRY", cRoteiro) .AND. ;
				GpValidPer( NIL, cProcesso, cPeriodo, cNumPagto, cRoteiro) .AND.;
				If(cRoteiro <> cRoteiroAnt, gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F.), .T.)
				nOpcA:=1
			Else
				nOpcA:=0
			EndIf

			If nOpcA==1
				If !MsGetDAuto(aAutoItens,"Gpea090LinOk","Gpea090TudOk",,nOpcNewGd)
					nOpcA:=0
				EndIf
			EndIf

		EndIf

		nPosPD := GdFieldPos(cPrefixo + "PD")
		nPosCC := GdFieldPos(cPrefixo + "CC")
		nPosSEQ := GdFieldPos(cPrefixo + "SEQ")
		nPosDTREF := GdFieldPos(cPrefixo + "DTREF")
		nPosRec := GdFieldPos( cPrefixo + "REC_WT" )
		nPosNumId := GdFieldPos(cPrefixo + "NUMID")

		If ( ( nOpcA == 1 ) .and. ( nOpcX <> 2 ) )
			If lGp580Auto
				If Len(aColsAnt) > 0 .And. nOpcx == 3
					nOpcx := 4
				Endif

				If nOpcx == 4 // Alteração
					aColsRecx := aClone(aColsAnt)

					For nX := 1 To Len(aCols)
						If !Empty(cNumId) .And. !Empty(aCols[nx][12])
							If (nPos := aScan( aColsRecx, { |x| x[nPosPD] == aCols[nX][nPosPD] .And. x[nPosCC] == aCols[nX][nPosCC] .And.  x[nPosNumId] == aCols[nX][nPosNumId] } )) == 0
								Aadd( aColsRecx, aCols[nX] )
							Else
								aCols[nX][nPosRec] := aColsRecx[nPos][nPosRec]
								aCols[nX][nPosSEQ] := aColsRecx[nPos][nPosSEQ]
								aColsRecx[nPos] := aCols[nX]
							EndIf 
						Else
							lSemDtRef := Type("aAutoItens") == "A" .And. !Empty(aAutoItens) .And. aScan( aAutoItens[nX], { |x| AllTrim(x[1]) == "RGB_DTREF" } ) == 0
							If (nPos := aScan( aColsRecx, { |x| x[nPosPD] == aCols[nX][nPosPD] .And. x[nPosCC] == aCols[nX][nPosCC] .And. (x[nPosSEQ] == aCols[nX][nPosSEQ] .Or. ( Empty(x[nPosSEQ]) .And. aCols[nX][nPosSEQ] == "0" ) ) .And. ( lSemDtRef .Or. x[nPosDTREF] == aCols[nX][nPosDTREF] )} )) == 0
								Aadd( aColsRecx, aCols[nX] )
							Else
								aCols[nX][nPosRec] := aColsRecx[nPos][nPosRec]
								aColsRecx[nPos] := aCols[nX]
							EndIf 
						Endif
					Next

					aCols := aClone(aColsRecx)
					For nY := 1 to Len(aCols)
						n := nY
						Gpea090LinOk()
					Next nY
				EndIf

				If nModAuto == 2
					If nOpcx == 5	// Exclusão
						For nX := 1 To Len(aCols)
							If (nPos := aScan( aColsAnt, { |x| x[nPosPD] == aCols[nX][nPosPD] .And. x[nPosCC] == aCols[nX][nPosCC] .And. (x[nPosSEQ] == aCols[nX][nPosSEQ] .Or. ( Empty(x[nPosSEQ]) .And. aCols[nX][nPosSEQ] == "0" ) ).And. x[nPosDTREF] == aCols[nX][nPosDTREF] } )) > 0
								Aadd( aColsRecx, aColsAnt[nPos][nPosRec] )
							EndIf
						Next
						aColsRec := aClone(aColsRecx)
					EndIf
				EndIf

				If Gpea090LinOk() .And. If(cPaisLoc $ "PTG", Gpea090TudOk(), .T.) .And. (If(lGP090CHK, ExecBlock( "GP090CHK", .F., .F., {cCodUser, cGrupos, aClone( aColsAnt ), aClone( aCols )} ),.T.))
					Gpea090Grava(cAlias, cFil, cMat, aVirtual, aColsRec, nOpcx, .F., .F.)
					//-- Ponto de entrada criado alteracao dos registros gravados
					If lGP090ALT
						ExecBlock("GP090ALT",.F.,.F.)
					EndIf
				EndIf
			Else
				lRet := .T.
				MsAguarde( { || If(Gpea090LinOk() .and. If(cPaisLoc $ "PTG",Gpea090TudOk(),.T.) .and. (If(lGP090CHK,ExecBlock( "GP090CHK", .F., .F., {cCodUser, cGrupos, aClone( aColsAnt ), aClone( aCols )} ),.T.)), lDelOk := Gpea090Grava(cAlias,cFil,cMat,aVirtual,aColsRec,nOpcx,.F.,.F.), lRet := .F.) }, OemToAnsi(STR0024))

				lExibMsg := .T.

				If nOpcX == 5 .And. lDelOk
					DelRecnos( cAlias , aColsRec )
					( cAlias )->( EvalTrigger() )
				EndIf

				//-- Ponto de entrada criado alteracao dos registros gravados
				If lRet .and. lGP090ALT
					ExecBlock("GP090ALT",.F.,.F.)
				EndIf
			EndIf
		EndIf

	End Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Libera Locks						                           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If ( lSRCLock .And. !lGp580Auto )
		FreeLocks( cAlias , NIL , .T. )
	ElseIf(lGp580Auto)
		(cAlias)->(MsUnlock())
	EndIf
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaura o Conteudo do Parametro mv_par01       			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !Empty( uSvMvPar01 )
		mv_par01 := uSvMvPar01
	EndIf

	RestArea( aArea )

	//Na rescisao mantem a SRA posicionada no funcionario
	If ( IsInCallStack("GPEM040") .or. IsInCallStack("GPEM042") ) .And. Len(aAreaSRA) > 0
		RestArea( aAreaSRA )
	EndIf

	If ( nOpcX == 3 )
		MBrChgLoop(.F.)
	EndIf

	//Libera a HotKey utilizada
	If (IsInCallStack("GPEA580") .and. !(IsInCallStack("GPEM040")) .and. !(IsInCallStack("GPEM042")) .and. !(IsInCallStack("GPEM030")))
		If IsInCallStack("GPEA090")
			fSetVK(bCalcular, bConsultar)
		Else
			fSetVK()
			lHabBtF6 := .F.
		EndIf	
	EndIf

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³                                                                       ³±±
±±³                                                                       ³±±
±±³                   ROTINAS DE CRITICA DE CAMPOS                        ³±±
±±³                                                                       ³±±
±±³                                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea090Grava³ Autor ³ Equipe Advanced RH  ³ Data ³26/05/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava no arquivo de Valores Variaveis   	                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GPEA090                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function Gpea090Grava( cAlias , cFil , cMat , aVirtual , aRegAltera , nOpc, lMontaGetDados, lPerg )
	Local aArea			:= GetArea()
	Local aSRCCols		:= {}
	Local cPrefixo		:= ( PrefixoCpo( cAlias ) + "_" )
	Local cCampo		:= ""
	Local lTudoIgual	:= .F.
	Local lAlteraOrig	:= .F.
	Local nX 			:= 0
	Local nY 			:= 0
	Local nLenHeader	:= Len( aHeader 	)
	Local nLenCols		:= Len( aSRCCols   	)
	Local nLenRegAlt	:= Len( aRegAltera	)
	Local nPosSeq		:= GdFieldPos( cPrefixo+"SEQ" )
	Local nPosDeleted	:= GdFieldPos( "GDDELETED" )
	Local nPosTp1		:= GdFieldPos( cPrefixo+"TIPO1"	, aHeader )
	Local nPosTp2		:= GdFieldPos( cPrefixo+"TIPO2"	, aHeader )
	Local aColsDel		:= {}
	Local aRecAux		:= {}
	Local aRecAux2		:= {}
	Local aRecDel		:= {}
	Local nCont			:= 0
	Local nCols			:= 0
	Local nPos			:= 0
	Local nPosRec 		:= GdFieldPos( cPrefixo + "REC_WT", aHeader )
	Local lBloqPON		:= ("1" $ SuperGetMv( "MV_BLOQPON",,"" ))
	Local nPosCC 		:= 0
	Local nPosItem 		:= 0
	Local nPosClvl 		:= 0
	Local nPosPd 		:= 0
	Local lSalvaAlt		:= .T.
	Local lContinua		:= .T.

	cNumId		:= If (Type("cNumId") == "U", "", cNumId) //Recebida no GPEA580() para tratamento do Consignado.
	lGp580Auto 	:= If (Type("lGp580Auto") == "U", .F., lGp580Auto)

	If lGp580Auto
		aSRCCols		:= aCols
		lPerg := .F.
		nPosPd := GdFieldPos(cPrefixo + "PD")
	Else
		aSRCCols		:= ( oGet:aCols )
	EndIF

	If !Empty(cNumId)
		fAjustAcols(@aSRCCols)
	EndIf

	nLenCols		:= Len( aSRCCols   	)

	Begin Transaction

		IF ( nOpc == 5 ) //Exclusao
			If !( Gp090VldDel(@cKeyRCH,nOpc) )
				lContinua := .F.
			EndIf

			// Multiplos vinculos desabilitado
			If (cPaisLoc == 'BRA' .AND. !lGp580Auto )
				fGP90ExcMV()
			EndIf

				/* Bloqueia a exclusão de verbas vindas do SIGAPON */
				If cPrefixo == "RGB_" .And. lBloqPON
					For nX := 1 To nLenCols
						If aSRCCols[nX, nPosTp2] == "E"
							Help(" ", 1, OemToAnsi(STR0040), Nil, OemToAnsi(STR0067), 1, 0 )
							lContinua := .F.
							Exit
						EndIF
				Next nX
			EndIf

			If lContinua

					If !lMontaGetDados
						If cAlias == "RGB" .And. cPaisLoc == "BRA"

							nPosCC 		:= GdFieldPos("RGB_CC")
							nPosItem 	:= GdFieldPos("RGB_ITEM")
							nPosClvl 	:= GdFieldPos("RGB_CLVL")
							nPosPd 		:= GdFieldPos("RGB_PD")

							If !lItemClVl
								SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)" ) ) )
							Else
								SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)" ) ) )
							EndIf

							For nCont := 1 To Len(aRegAltera)

								If lGp580Auto
									RGB->(DbGoTo(aRegAltera[nCont]))
									If !lItemClVl
										lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + RGB->RGB_PD + RGB->RGB_CC ) )
									Else
										lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + RGB->RGB_PD + RGB->RGB_CC + RGB->RGB_ITEM + RGB->RGB_CLVL ) )
									EndIf
								Else
									If ( nPos := aScan( aSRCCols, { |x| x[nPosRec] == aRegAltera[nCont] } ) ) > 0
										If !lItemClVl
											lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + aSRCCols[nPos, nPosPd] + aSRCCols[nPos, nPosCC] ) )
										Else
											lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + aSRCCols[nPos, nPosPd] + aSRCCols[nPos, nPosCC] + aSRCCols[nPos, nPosItem] + aSRCCols[nPos, nPosClvl] ) )
										EndIf
									EndIf
								EndIf

								If !lAchou
									aAdd( aRecAux, aRegAltera[nCont] )
								Else
									aAdd( aRecAux2, aRegAltera[nCont])
								EndIf
							Next nCont

							aRegAltera := aClone(aRecAux)
						EndIf

						If !Empty(aRegAltera)
							PonDelRecnos( cAlias , aRegAltera )
							( cAlias )->( EvalTrigger() )
						EndIf

						If !Empty(aRecAux2)
							Help(" ", 1, OemToAnsi(STR0040), Nil, OemToAnsi(STR0069), 1, 0 )//"Atenção"##"Há verbas que não foram excluídas pois foram encontradas na tabela SRC"
						EndIf
					EndIf

					If ( cPaisLoc =="ARG" )
						fDelRH8MAT( cRoteiro,cNumPagto, cFil, cMat  )
					EndIf

				EndIf

		Else //Inclusao ou Alteracao

			IF !ArrayCompare( aSRCCols , aColsAnt )
				lM2Modif := .T.

				If lPerg //Se deve fazer a pergunta ...
					If !(MsgYesNo( OemToAnsi( STR0025 ) ) )	//"Deseja salvar as alteracoes?"
						lSalvaAlt := .F.
					EndIf
				EndIf

				If lSalvaAlt
				dbSelectArea(cAlias)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Por causa da sequencia foi separado os registros deletados ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				GdSplitDel( aHeader , @aSRCCols , aRegAltera , @aColsDel , @aRecDel)

				// Elimina os registros deletados do aColsAnt
				If !Empty(aColsAnt)
					nCols := Len(aColsAnt)
					For nX := 1 To Len(aColsAnt)
						If Ascan(aColsDel,{|x| x[nPosRec]==aColsAnt[nX,nPosRec]}) > 0
							aColsAnt[nX,nPosRec] := NIL
						EndIf
					Next nX
					Do While ( nPos := Ascan(aColsAnt,{|x| x[nPosRec]==NIL}) ) > 0
						aDel(aColsAnt,nPos)
						Asize(aColsAnt,--nCols)
					EndDo
				EndIf
				If !Empty(aRecDel)
					For nX := 1 To Len(aRecDel)
						( cAlias )->( dbGoto( aRecDel[nX] ) )
						RecLock(cAlias,.F.,.T.)
						If aColsDel[nX,nPosDeleted]
							( cAlias )->( dbDelete() )
						Endif
						(cAlias)->( MsUnlock() )
					Next
				Endif

				If !Empty( aRegAltera )
					nLenRegAlt := Len(aRegAltera)
					For nX := 1 To nLenRegAlt
						lTudoIgual := ArrayCompare( aSRCCols[ nX ] , aColsAnt[nX] )
						IF ( lTudoIgual ) .and. !( aSRCCols[nX,nPosDeleted] )
							Loop
						EndIF

						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Se Teve Apenas alteracao na sequencia de lancamento nao altera³
						³o Flag de Origem											   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						lAlteraOrig := .F.
						For nY := 1 To Len( aSRCCols[ nX ] )
							IF !( nY == nPosSeq )
								IF !( lTudoIgual := aSRCCols[ nX , nY ] == aColsAnt[ nX , nY ] )
									lAlteraOrig := .T.
								EndIF
							EndIF
						Next nY
						( cAlias )->( dbGoto( aRegAltera[nX] ) )
						( cAlias )->( RecLock( cAlias , .F.))
						IF ( aSRCCols[nX,nPosDeleted] )
							(cAlias)->( dbDelete() )
						Else
							(cAlias)->(&(cPrefixo+"FILIAL"))	:= cFil
							(cAlias)->(&(cPrefixo+"MAT"))		:= cMat
							(cAlias)->(&(cPrefixo+"PROCES"))	:= cProcesso
							(cAlias)->(&(cPrefixo+"ROTEIR")) 	:= cRoteiroAnt
							(cAlias)->(&(cPrefixo+"POSTO")) 	:= cPosto
							(cAlias)->(&(cPrefixo+"TIPO2") ) 	:= If(! lGp580Auto, "I", aSRCCols[nX][nPosTp2])
							(cAlias)->(&(cPrefixo+"SEMANA"))	:= cNumPagto

							//Precisa verificar se o campo existe, pois este fonte é
							//utilizado para lançamentos nas tabelas SRC e RGB e o nome do campo
							//periodo é diferente nessas tabelas (RC_PERIODO e RGB_PERIOD)
							If (cAlias)->( FieldPos(cPrefixo+"PERIODO") ) > 0
								(cAlias)->(&(cPrefixo+"PERIODO")) 	:= cPeriodoAnt
							ElseIf (cAlias)->( FieldPos(cPrefixo+"PERIOD") ) > 0
								(cAlias)->(&(cPrefixo+"PERIOD")) 	:= cPeriodoAnt
							EndIf

							For nY := 1 To nLenHeader
								/*
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³Obtem o Campo para Gravacao  							       ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
								cCampo := aHeader[nY,2]

								/*
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³Os campo horas e valor serao gravados no momento da gravacao  ³
								³dos campos horinfo e valinfo.                                 ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
								//Para lançamentos na tabela SRC o campo horas e valor não devem ser atualizados.
								//Para a tabela RGB estes campos devem ser atualizados.
								If cAlias == "SRC"
									If cCampo == (cPrefixo+"HORAS") .OR. cCampo == (cPrefixo+"VALOR")
										Loop
									EndIf
								EndIf

								/*
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³Nao Grava Campo Virtual									   ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
								IF ( aScan(aVirtual,cCampo) # 0 )
									Loop
								EndIF

								/*
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³ Se MV_HORASDE = "S" e Campo _HORINFO/_HORAS Converte Horas   ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
								IF ( cDigHoras == "S" ) .And. ;
								( (cCampo == (cPrefixo+"HORINFO")) .OR. (cCampo == (cPrefixo+"HORAS")) ) .And. ;
								(aSRCCols[nX,nPosTp1] == "H" )
									xConteudo := fConvHr( aSRCCols[nX,nY] , "D" )
								Else
									xConteudo := aSRCCols[nX,nY]
								EndIF
								(cAlias)->( &cCampo ) := xConteudo

								/*
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³Gravar em horas e valor o mesmo valor informado em horinfo e  ³
								³valinfo.                                                      ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
								If cCampo == (cPrefixo+"HORINFO") .And. lAlteraOrig
									(cAlias)->( &(cPrefixo+"HORAS") ) := xConteudo
								ElseIf cCampo == (cPrefixo+"VALINFO") .And. lAlteraOrig
									(cAlias)->( &(cPrefixo+"VALOR") ) := xConteudo
								EndIf

							Next nY
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Se Teve Apenas alteracao na sequencia de lancamento nao altera³
							³o Flag de Origem											   ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							If ! lGp580Auto
								For nY := 1 To Len( aSRCCols[ nX ] )
									lTudoIgual := .T.
									IF !( nY == nPosSeq )
										IF !( lTudoIgual := aSRCCols[ nX , nY ] == aColsAnt[ nX , nY ] )
											(cAlias)->(&(cPrefixo+"TIPO2")) := "I"
										EndIF
									EndIF
								Next nY
							EndIf
						EndIF
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Destrava o Registro										   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						( cAlias )->( MsUnLock() )
					Next nX
					IF ( nLenCols > nLenRegAlt ) // Se Trata de Inclusao de Itens
						Gpea090GrInc( cAlias , cPrefixo , cFil , cMat , aVirtual , ( nLenRegAlt + 1 ) )
					EndIF
				Else
					Gpea090GrInc( cAlias , cPrefixo , cFil , cMat , aVirtual , 1 )
				EndIF

				( cAlias )->( EvalTrigger() )

				If ( lMontaGetDados )
					gp090MontaGetDados(cAlias, nOpc, cFil, cMat, @aVirtual, @aRegAltera, @aSRCCols, .F.)
				EndIf

				If lDelCalc
					Gp090Src() // Exclui dados da SRC
				EndIf
			EndIF

		EndIF
	EndIF
		if lSalvaAlt .And. (lIntegDef) .And. (!IsInCallStack("GPEI090"))
			FwIntegDef("GPEA090")
		endIf
	End Transaction

	If Type( "lResM2" ) <> "U" .And. lResM2 .And. Type( "lAltRGB" ) <> "U"  //Tratamento para chamada da rotina atraves de tela de rescisão (Modelo 2)
		lAltRGB:= .T.
	EndIf

	//Se excluiu algum item integrado, retirada a data de integração do roteiro
	If !Empty(cKeyRCH)
		RCH->(DbSetOrder(1))//RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR
		If RCH->(DbSeek(cKeyRCH))
			RecLock("RCH",.F.)
			RCH->RCH_DTINTE := CtoD("")
			RCH->(MsUnLOck())
		EndIf
	EndIf
	RestArea(aArea)
Return( lContinua )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea090GrInc³ Autor ³Equipe Advanced RH   ³ Data ³ 24.05.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava os registros Incluidos na GetDados	                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Gpea090GrInc                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function Gpea090GrInc( cAlias , cPrefixo , cFil , cMat , aVirtual , nIniciar )

	Local aSRCCols		:= {}
	Local cCampo		:= ""
	Local nLenHeader	:= Len( aHeader )
	Local nLenCols		:= Len( aSRCCols )
	Local nPosDeleted	:= GdFieldPos( "GDDELETED" )
	Local nX			:= 0
	Local nY 			:= 0
	Local nPosTp1		:= GdFieldPos( cPrefixo+"TIPO1"	, aHeader )
	Local nPosPd		:= GdFieldPos( cPrefixo+"PD"	, aHeader )
	lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)
	If lGp580Auto
		aSRCCols		:= aCols
	Else
		aSRCCols		:= ( oGet:aCols )
	EndIF
	nLenCols		:= Len( aSRCCols )

	//Passa o valor do periodo para evitar erros
	cPeriodoAnt := cPeriodo

	For nX := nIniciar To nLenCols
		IF !( aSRCCols[nX,nPosDeleted] ) .And. !Empty(aSRCCols[nx,nPosPd])

			If !lItemClVl
				(cAlias)->( dbSetOrder( RetOrder( cAlias , cPrefixo+"FILIAL+"+cPrefixo+"MAT+"+cPrefixo+"PD+"+cPrefixo+"CC+"+cPrefixo+"SEMANA+"+cPrefixo+"SEQ" ) ) )
			Else
				(cAlias)->( dbSetOrder( RetOrder( cAlias , cPrefixo+"FILIAL+"+cPrefixo+"MAT+"+cPrefixo+"PD+"+cPrefixo+"CC+"+cPrefixo+"ITEM+"+cPrefixo+"CLVL+"+cPrefixo+"SEMANA+"+cPrefixo+"SEQ" ) ) )
			EndIf

			(cAlias)->( RecLock(cAlias,.T.) )
			(cAlias)->(&(cPrefixo+"FILIAL"))	:= cFil
			(cAlias)->(&(cPrefixo+"MAT"))		:= cMat
			(cAlias)->(&(cPrefixo+"PROCES"))	:= cProcesso
			(cAlias)->(&(cPrefixo+"ROTEIR")) 	:= cRoteiroAnt
			(cAlias)->(&(cPrefixo+"POSTO")) 	:= cPosto
			(cAlias)->(&(cPrefixo+"TIPO2")) 	:= "I"
			(cAlias)->(&(cPrefixo+"SEMANA"))	:= cNumPagto

			//Precisa verificar se o campo existe, pois este fonte é
			//utilizado para lançamentos nas tabelas SRC e RGB e o nome do campo
			//periodo é diferente nessas tabelas (RC_PERIODO e RGB_PERIOD)
			If (cAlias)->( FieldPos(cPrefixo+"PERIODO") ) > 0
				(cAlias)->(&(cPrefixo+"PERIODO")) 	:= cPeriodoAnt
			ElseIf (cAlias)->( FieldPos(cPrefixo+"PERIOD") ) > 0
				(cAlias)->(&(cPrefixo+"PERIOD")) 	:= cPeriodoAnt
			EndIf

			For nY := 1 To nLenHeader
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Obtem o Campo para Gravacao  							       ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cCampo := aHeader[nY,2]

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Os campo horas e valor serao gravados no momento da gravacao  ³
				³dos campos horinfo e valinfo.                                 ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				//Para lançamentos na tabela SRC o campo horas e valor não devem ser atualizados.
				//Para a tabela RGB estes campos devem ser atualizados.
				If cAlias == "SRC"
					If cCampo == (cPrefixo+"HORAS") .OR. cCampo == (cPrefixo+"VALOR")
						Loop
					EndIf
				EndIf

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Nao Grava Campo Virtual									   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				IF ( aScan(aVirtual,cCampo) # 0 )
					Loop
				EndIF
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Se MV_HORASDE = "S" e Campo _HORINFO/_HORAS Converte Horas   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				IF ( cDigHoras == "S" ) .And. ;
				( (cCampo == (cPrefixo+"HORINFO")) .OR. (cCampo == (cPrefixo+"HORAS")) ) .And. ;
				(aSRCCols[nX,nPosTp1] == "H" )
					xConteudo := fConvHr( aSRCCols[nX,nY] , "D" )
				Else
					xConteudo := aSRCCols[nX,nY]
				EndIF
				(cAlias)->( &cCampo ) := xConteudo

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Gravar em horas e valor o mesmo valor informado em horinfo e  ³
				³valinfo.                                                      ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If cCampo == (cPrefixo+"HORINFO")
					(cAlias)->( &(cPrefixo+"HORAS") ) := xConteudo
				ElseIf cCampo == (cPrefixo+"VALINFO")
					(cAlias)->( &(cPrefixo+"VALOR") ) := xConteudo
				EndIf

			Next nY
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Destrava o Registro										   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			( cAlias )->( MsUnLock() )
		EndIF
	Next nX

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea090LinOk³ Autor ³ Marinaldo de Jesus  ³ Data ³26/05/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Critica linha digitada                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GPEA090                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gpea090LinOk( oBrowse )

	Local aCriterio		:= {}
	Local aCposKey		:= {}
	Local lLinOk		:= .T.
	Local cPrefixo		:= ( PrefixoCpo( cLancAlias ) + "_" )
	Local nPosSeq		:= GdFieldPos(cPrefixo+"SEQ") //If(cLancAlias=="RGB", GdFieldPos("RGB_SEQ"), 0 )
	Local nPosTipo  	:= GdFieldPos(cPrefixo+"TIPO1")
	Local nPosTipo2  	:= GdFieldPos(cPrefixo+"TIPO2")
	Local nPosHoras 	:= If(cLancAlias=="SRC", GdFieldPos("RC_HORINFO"), GdFieldPos("RGB_HORAS"))
	Local nPosValor 	:= If(cLancAlias=="SRC", GdFieldPos("RC_VALINFO"), GdFieldPos("RGB_VALOR"))
	Local nPosHorasC 	:= GdFieldPos(cPrefixo+"HORAS")
	Local nPosValorC 	:= GdFieldPos(cPrefixo+"VALOR")
	Local nPosDtRef 	:= GdFieldPos(cPrefixo+"DTREF")
	Local nPosPD 		:= GdFieldPos(cPrefixo+"PD")
	Local nPosOri		:= GdFieldPos(cPrefixo+"ROTORI")
	Local nPosRec		:= GdFieldPos(cPrefixo+"REC_WT" )
	Local nPosItem 	 	:= GdFieldPos(cPrefixo+"ITEM" )
	Local nPosClVl   	:= GdFieldPos(cPrefixo+"CLVL" )
	Local nPosCc     	:= GdFieldPos(cPrefixo+"CC" )
	Local nPosNumId		:= GdFieldPos("RGB_NUMID")
	Local nLimHorDia 	:= gp090GetRCA("P_LIMEXDIA")
	Local nLimDe		:= 0
	Local nLimAte		:= 0
	Local dDataAtual	:= Ctod("")
	Local nHoraAtual	:= 0
	Local dDataNX       := Ctod("")
	Local nHoraNX       := 0
	Local nPosDeleted	:= GdFieldPos( "GDDELETED" )
	Local Nx            := 1
	lOCAL nOrdem		:= 1
	Local aArea			:= getArea()
	Local nCount		:= 1
	Local nCount1		:= 1
	Local nQuant		:=  0
	Local nQuant1		:=  0
	Local cVerba		:= ""
	Local cMensg		:= ""
	Local lDataOk		:= .T.
	Local lAchou		:= .F.
	Local lBloqPON		:= ("1" $ SuperGetMv( "MV_BLOQPON",,"" ))
	Local nAux			:= 0
	Local nPosLOTPLS	:= GdFieldPos(cPrefixo+"LOTPLS") //Variável para controle na integração do SIGAPLS
	Local nPosCODRDA	:= GdFieldPos(cPrefixo+"CODRDA") //Variável para controle na integração do SIGAPLS
	Local nPosIN		:= GdFieldPos("RGB_IN2110")
	Local nAuxPLS		:= 0 //Variável para controle na integração do SIGAPLS
	//Local lGrupo        := IIF(!Empty(cGrupo),Posicione("RGF",1,xFILIAL("RGF"),"RGF_CODIGO") )                                          //Busca Qual Grupo Pertence a Verba
	Local lIntPFS    := SuperGetMV("MV_JINTGPE", .F., "1") == "2"
	Local lLinPla       := .T.

	// Variavel n nao estara criada quando a funcao de validacao
	// for chamada pelo LostFocus da GetDados. Se estiver criada,
	// continua com o valor de n, senao, recebe a linha que estava
	// selecionada da GetDados no momento que perdeu o foco.
	n 	   := If(Type("n")="U" .or. n > Len(aCols),oGet:nat, n)

	lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)
	If !lGp580Auto
		aCols  := oGet:aCols
	ElseIf !IsInCallStack("MSGETDAUTO") .And. Type("aAutoItens") == "A" .And. !Empty(aAutoItens) .And. nPosDTREF > 0 .And. Len(aAutoItens) >= n .And. aScan( aAutoItens[n], { |x| AllTrim(x[1]) == "RGB_DTREF" } ) == 0 
		If Empty(aCols[n, nPosRec]) .And. aCols[n, nPosTipo2] <> "F"
			aCols[n, nPosDTREF] := cToD("//")
		EndIf
	ElseIf IsInCallStack("MSGETDAUTO") .And. Type("aAutoItens") == "A" .And. !Empty(aAutoItens) .And. nPosDTREF > 0 .And. Len(aAutoItens) >= n .And.;
		aScan( aAutoItens[n], { |x| AllTrim(x[1]) == "RGB_DTREF" } ) == 0 .And.  aCols[n, nPosTipo2] ==  "I" 
		aCols[n, nPosDTREF] := cToD("//")
	EndIf



	Begin Sequence

		If ArrayCompare( aCols , aColsAnt )
			Break
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se periodo de lancamento esta bloqueado			     ³
		//³Se for roteiro de Adiantamento, realiza validacao por verbas  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cRoteiro $ fGetCalcRot('2') // Roteiro de Adiantamento
			If !fVldAccess( SRA->RA_FILIAL,IIF(!Empty( aCols[n, nPosDtRef]), aCols[n, nPosDtRef], dDataBase ),cNumPagto,.T.,cRoteiro, "3", "V" )
				lLinOk := .F.
				Break
			EndIf
		ElseIf !fVldAccess( SRA->RA_FILIAL,IIF(!Empty( aCols[n, nPosDtRef]), aCols[n, nPosDtRef], dDataBase ),cNumPagto,.T., cRoteiro)
			lLinOk := .F.
			Break
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		|Bloqueia Verbas vindas do SIGAPON							   |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If (nPosTipo2 > 0)
			If lBloqPON .And. Upper(aCols[n, nPosTipo2]) == "E"
				If n <= Len( aColsAnt ) .And. !fCompArray( aColsAnt[n], aCols[n] )
					fVldAltPon( "1" )	//?-Apresenta Mensagem
					lLinOk := .F.
					Break
				EndIf
			EndIf
		EndIf

		If cPaisLoc == "BRA" .And. !IsBlind() .And. (nPosNumId == 0 .Or. Empty(acols[n,nPosNumId])) .And. aCols[n, nPosTipo2] == "I" .And. RetValSrv( aCols[n, nPosPD], SRA->RA_FILIAL, 'RV_CODFOL', 1 ) $ '0086/0248'
			Aviso(STR0040,STR0116)  //"ATENCAO !"###""Necessário preencher campo Num. Identif (RGB) com as datas inicial e final do período aquisitivo correspondente à verba lançada, no formato AAAAMMDD - AAAAMMDD para que o lançamento seja impresso corretamente no TRCT. Este lançamento deve ser feito pela tela de rescisão"
			lLinOk := .F.
			Break
		EndIf
		If cPaisLoc == "BRA" .And. !IsBlind() .And. aCols[n, nPosTipo2] == "I" .And.  aCols[n, nPosDeleted] == .F.
			lLinPla := ValidaPlaIR( @lExiMsgPl,aCols[n, nPosPD])
			If !lLinPla
				lLinOk := .F.
				Break
			Endif	
		Endif

		//Se a verba for oriunda de outro roteiro
		If ! lGp580Auto
			If ( ( nPosOri > 0 .And. ! Empty(aCols[n, nPosOri]) ) .Or. aCols[n, nPosTipo2] == "A" ) .and. n <= Len( aColsAnt ) .And. !fCompArray( aColsAnt[n], aCols[n] )
				If lExibMsg
					lExibMsg := .F.
					If ! (MsgYesNo( OemToAnsi( STR0065 )))	// "Esta verba foi gerada por outro roteiro. Deseja confirmar a alteração?"
						lLinOk := .F.
						Break
					EndIf
				Endif
			EndIf
		EndIf

		If cLancAlias == "RGB"
			If nPosLOTPLS > 0 .AND. nPosCODRDA > 0 .AND. !(EmpTy(aCols[n,nPosLOTPLS])) .and. nModulo <> 77
				nAuxPLS := aScan( aColsAnt, { |x| ( x[nPosRec] == aCols[n,nPosRec] ) } )
				If nAuxPLS > 0 .AND. !PLSxGPEVLD(aCols[n], aColsAnt[nAuxPLS])
					If lIntPFS
						MsgInfo(STR0111 + aCols[n,nPosLOTPLS] + STR0119) //"O registro não pode ser Alterado, pois sua origem é um lote de pagamento [ " ### " ] do módulo SIGAPFS."
					Else

						MsgInfo(STR0111 + aCols[n,nPosLOTPLS] + STR0112) //"O registro não pode ser Alterado, pois sua origem é um lote de pagamento [ " ### " ] do módulo SIGAPLS."

					EndIf
					lLinOk := .F.
					Break
				EndIf
			EndIf
		EndIf
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Monta a Sequencia da Verba "Chave Inicial Codigo da Verba"    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !( lLinOk := fMontaSeq( cPrefixo+"PD", ,cPrefixo, aGhCols ) )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Para Linhas Deletadas o Retorno devera ser "True"             ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( GdDeleted() )
				lLinOk := .T.
			EndIF
			Break
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		|Bloqueia Verbas vindas do SIGAPON							   |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	//	If lBloqPON .And. Upper(aCols[n, nPosTipo2]) == "E"
	//		If n <= Len( aColsAnt ) .And. !fCompArray( aColsAnt[n], aCols[n] )
	//			fVldAltPon( "1" )	//?-Apresenta Mensagem
	//			lLinOk := .F.
	//			Break
	//		EndIf
	//	EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se a Linha da GetDados Nao Estiver Deletada				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !( GdDeleted() )
			If cPaisLoc == "PER"
				If !(lLinOk := RGBRucValid())
					Break
				EndIf
				If lLinOk .And. !GP090VlVac(SRA->RA_FILIAL, cMat, cProcesso, cPeriodo, cNumPagto, aCols[n, nPosPd], aCols[n, nPosHoras])
					lLinOk := .F.
					Break
				EndIf
			EndIf
			If (FwOnSpFilter(cLancAlias))
				dbSelectArea(cLancAlias)
				nPosCC	   := GdFieldPos(cPrefixo + "CC")
				nPosItem   := GdFieldPos(cPrefixo + "ITEM")
				nPosClvl   := GdFieldPos(cPrefixo + "CLVL")

					cKey := xFilial(cLancAlias)
					cKey += cProcesso
					cKey += cMat
					cKey += cPeriodo
					cKey += cNumPagto
					cKey += cRoteiro
					cKey += aCols[n, nPosPd]
					cKey += aCols[n, nPosCC]
					If lItemClVl
						cKey += aCols[n, nPosItem]
						cKey += aCols[n, nPosClvl]
					EndIf
					cKey += aCols[n, nPosSeq]
					cKey += DToS(aCols[n, nPosDtRef])

				SpFilterOff( { "SRA", cLancAlias } )

				If (cLancAlias == "RGB")
					If !lItemClVl
						nOrdem := RetOrder(cLancAlias, "RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_PD+RGB_CC+RGB_SEQ+DTOS(RGB_DTREF)")
					Else
						nOrdem := RetOrder(cLancAlias, "RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_PD+RGB_CC+RGB_ITEM+RGB_CLVL+RGB_SEQ+DTOS(RGB_DTREF)")
					EndIf
				elseif(cLancAlias == "SRC")
					If !lItemClVl
						nOrdem := RetOrder(cLancAlias, "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)")
					Else
						nOrdem := RetOrder(cLancAlias, "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)")
					EndIf
				endif

				(cLancAlias)->(dbSetOrder( nOrdem ))
				If (cLancAlias)->(dbSeek(cKey))
					nPosRec := GdFieldPos( cLancAlias + "_REC_WT" )
					cKeyAux := cKey
					While (cLancAlias)->(!Eof()) .AND. cKey == cKeyAux

						If nPosRec > 0 .AND. aCols[n, nPosRec] <> (cLancAlias)->(Recno())
							lLinOk := .F.
							SpFilterOff( { "SRA", cLancAlias }, .F. )
							MsgAlert(OemToAnsi(STR0042))	 //Registro já gravado
							Break
						EndIF

						(cLancAlias)->(dbSkip())
						//Monta nova chave auxiliar para verificar se ainda continua no seek
							cKeyAux := (cLancAlias) ->&(cPrefixo + "FILIAL" )
							cKeyAux += (cLancAlias) ->&(cPrefixo + "PROCES" )
							cKeyAux += (cLancAlias) ->&(cPrefixo + "MAT" )
							cKeyAux += (cLancAlias) ->&(cPrefixo + iif(cLancAlias == "SRC", "PERIODO", "PERIOD" ))
							cKeyAux += (cLancAlias) ->&(cPrefixo + "SEMANA" )
							cKeyAux += (cLancAlias) ->&(cPrefixo + "ROTEIR" )
							cKeyAux += (cLancAlias) ->&(cPrefixo + "PD" )
							cKeyAux += (cLancAlias) ->&(cPrefixo + "CC" )
							If lItemClVl
								cKeyAux += (cLancAlias) ->&(cPrefixo + "ITEM" )
								cKeyAux += (cLancAlias) ->&(cPrefixo + "CLVL" )
							EndIf
							cKeyAux += (cLancAlias) ->&(cPrefixo + "SEQ" )
							cKeyAux += DtoS((cLancAlias) ->&(cPrefixo + "DTREF" ))
					EndDo
				EndIf
				SpFilterOff( { "SRA", cLancAlias }, .F. )
			Endif
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica Itens Duplicados na GetDados						   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If ( PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_LCTODIA" ) == "S" )
				aCposKey := { cPrefixo+"PD" , cPrefixo+"DTREF" , If(cLancAlias=="SRC","RC_CODFUNC","RGB_CODFUN")}
			Else
				If ( cDigSemana == "S" )
					If !lItemClvl
						aCposKey := { cPrefixo+"PD" , cPrefixo+"CC" , cPrefixo+"SEQ", cPrefixo+"DTREF", If(cLancAlias=="SRC","RC_CODFUNC","RGB_CODFUN") }
					Else
						aCposKey := { cPrefixo+"PD" , cPrefixo+"CC" ,cPrefixo+"ITEM",cPrefixo+"CLVL", cPrefixo+"SEQ", cPrefixo+"DTREF", If(cLancAlias=="SRC","RC_CODFUNC","RGB_CODFUN") }
					EndIf
				Else
					If !lItemClvl
						aCposKey := { cPrefixo+"PD" , cPrefixo+"CC" , cPrefixo+"SEMANA" , cPrefixo+"SEQ", cPrefixo+"DTREF", If(cLancAlias=="SRC","RC_CODFUNC","RGB_CODFUN") }
					Else
						aCposKey := { cPrefixo+"PD" , cPrefixo+"CC" ,cPrefixo+"ITEM",cPrefixo+"CLVL", cPrefixo+"SEMANA" , cPrefixo+"SEQ", cPrefixo+"DTREF", If(cLancAlias=="SRC","RC_CODFUNC","RGB_CODFUN") }
					EndIf
				EndIf
			EndIf

			IF !( lLinOk := GdCheckKey( aCposKey , 4 ) )
				Break
			EndIF

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica Se o Campos Estao Devidamente Preenchidos		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF !( SRA->RA_TIPOPGT == "S" ) .or. ( cDigSemana == "S" )
				aCposKey := { cPrefixo+"PD" , cPrefixo+"CC" , cPrefixo+"TIPO1" }
			Else
				aCposKey := { cPrefixo+"PD" , cPrefixo+"CC" , cPrefixo+"TIPO1" , cPrefixo+"SEMANA" }
			EndIF
			IF !( lLinOk := GdNoEmpty( aCposKey ) )
				Break
			EndIF

			//Não valida se foi digitado horas ou valor na rescisão complementar para possibilitar zerar uma verba no cálculo.
			If !(fGetTipoRot(cRoteiro) == "4" .and. !Empty(SRA->RA_DEMISSA))
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica Se a Quantidade de Horas Esta Devidamente Preenchida³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				IF !( lLinOk := !( ( aCols[n, nPosTipo] $ "DH" ) .and. ( aCols[n, nPosHoras] == 0 ) ) )
					Help(" ",1,"A040SHORAS")
					Break
				EndIF

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica Se a Quantidade de Horas ou Valor Estao  Devidamente³
				³ Preenchidos												   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				IF !( lLinOk := !( aCols[n, nPosTipo] $ "V"  .and. ( aCols[n, nPosValor] == 0 ) ) )
					Help(" ",1,"A040SVAHOR")
					Break
				EndIF

				//--Checar campo valor ou horas para lancamentos diferentes de calculad
				If aCols[n, nPosValor] == 0 .and. aCols[n, nPosHoras] == 0.00 .and. aCols[n, nPosTipo2] #  "C"
					Help(" ",1,"A040SVAHOR")
					lRet := .F.
					Break
				Endif

				//--Checar campo valor ou horas para lancamentos diferentes de calculad
				If aCols[n, nPosValorC] == 0 .and. aCols[n, nPosHorasC] == 0.00 .and. aCols[n, nPosTipo2] ==  "C"
					Help(" ",1,"A040SVAHOR")
					lRet := .F.
					Break
				EndIF
			EndIf

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica Se a Quantidade de Horas ou Valor Estao  conforme os³
			³ limites do cadastro de verbas.							   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			// Valor
			IF (aCols[n, nPosTipo] $ "V")
				nLimDe  := PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_VLIMDE" )
				nLimAte := PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_VLIMATE" )
				If (nLimDe != 0) .OR. (nLimAte != 0)
					If !(aCols[n, nPosValor] >= nLimDe .AND. ;
						aCols[n, nPosValor] <= nLimAte)
						Help(" ",1,"GPA120LIM")
						lLinOk := .F.
						Break
					EndIf
				EndIf
			// Horas
			ElseIf (aCols[n, nPosTipo] $ "DH")
				nLimDe  := PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_RLIMDE" )
				nLimAte := PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_RLIMATE" )
				If (nLimDe != 0) .OR. (nLimAte != 0)
					If !(aCols[n, nPosHoras] >= nLimDe .AND.;
						aCols[n, nPosHoras] <= nLimAte)
						Help(" ",1,"GPA120LIM")
						lLinOk := .F.
						Break
					EndIf
				EndIf
			EndIF

			If !Empty(aCols[n, nPosPD])
				If PosSRV(aCols[n, nPosPD], SRA->RA_FILIAL, "RV_LCTODIA" ) == "S" .And. Empty(aCols[n, nPosDtRef])
					Help( "", 1, OemToAnsi( STR0040 ), NIL, OemToAnsi( STR0070 ), 1, 0 )//"Atenção"##"Lançamento sem data de referência informada."
					lLinOk := .F.
					Break
				ElseIf nPosIN > 0 .And. aCols[n, nPosIN] == "1"
					If Empty(aCols[n, nPosDtRef])
						Help( "", 1, OemToAnsi( STR0040 ), NIL, OemToAnsi( STR0125 ), 1, 0 )//"Atenção"##"Para lançamento relativo à IN 2110, a data de referência deve ser informada."
						lLinOk := .F.
						Break
					EndIf
				ElseIf aCols[n][nPosTipo2] == "I" .AND. PosSRV(aCols[n, nPosPD], SRA->RA_FILIAL, "RV_LCTODIA" ) != "S" .And. !Empty(aCols[n, nPosDtRef])  //valida apenas verbas informadas
					Help( "", 1, OemToAnsi( STR0040 ), NIL, OemToAnsi( STR0071 ), 1, 0 )//"Atenção"##"Data de referência não deve ser informada pois a verba não possui configuração para lançamento diário"
					lLinOk := .F.
					Break
				EndIf
			EndIf

			//-
			//- Localização para Portugal - verificação de Limites de Horas Extras Dia
			//-

			If cPaisLoc == "PTG"
			If ( PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_HE" ) == "S" )
				dDataAtual := aCols[n,nPosDtRef]
				nHoraAtual := aCols[n,nPosHoras]
				nTotHora   := 0
				For nx := 1 to Len(aCols)
					dDataNx := aCols[nx,nPosDtRef]
					nHoraNx := aCols[nx,nPosHoras]
					If dDataNx == dDataAtual .and. Nx <> n .and. !Acols[nx,nPosDeleted]
						nTotHora += nHoraNx
					EndIf
				Next


				If !Empty(nLimHorDia)
					If nHoraAtual+nTotHora > VAL(nLimHorDia)
						cMsgHelp	:= OemtoAnsi(STR0037)                            //"Limite de Horas Extras Diarias
						cMsgHelp    += CHR(13)+CHR(10)
						cMsgHelp    += OemtoAnsi(STR0038) + " " + DTOC(dDataAtual)   //Excedido para o Dia:
						cMsgHelp    += CHR(13)+CHR(10)
						cMsgHelp    += OemtoAnsi(STR0039) + " P_LIMEXDIA" + "= "+nLimHorDia
						Help( "" , 1 , "LIMHEXCED" , NIL , OemToAnsi( cMsgHelp ) , 1 , 0 )
						lLinOk := .F.
					EndIf
				EndIf
			EndIf
			EndIf

			If lLinOk
				// Se o campo de filtro numero de pagamento estiver preenchido, o
				// campo RC_SEMANA da GetDados devera ser o informado no filtro.
				// Se o campo de filtro numero de pagamento nao estiver preenchido, o
				// campo RC_SEMANA da GetDados podera ser qualquer numero de pagamento
				// da consulta padrao.
				lLinOk := gp090NrPagtoValid(cNumPagto, cPrefixo)
			EndIf

			If lLinOk
				If aCols[n, nPosTipo2] == "I" .And. !( PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_LEEINC" ) == "1" )
					MsgAlert(OemToAnsi(STR0061))	 //Não permitido a inclusão de lançamentos para esta verba.
					lLinOk := .F.
				EndIf
			EndIf
		EndIF
		//Realiza chamada do PE para todas as linhas, inclusive as deletadas.
		If lLinOk .And. lGP090Ok
			lLinOk := ExecBlock( "GP090OK", .F., .F., {aCols[n]} )
		EndIf

		// Validação para lançamento de faltas quando usa o cálculo outomático de benefícios
		If lLinOk
			If ( PosSRV(aCols[n, nPosPD], xFilial("SRV", SRA->RA_FILIAL), "RV_CODFOL" ) == "0054" )
				CargaCrit("VA', 'VR", @aCriterio, cDataIni, cDataFim)
				If Len(aCriterio) > 0
					If( aCols[n, nPosHoras] > 1) .Or. ( Empty(aCols[n, nPosDtRef]) )
						MsgAlert(OemToAnsi(STR0086))	// Para que as faltas sejam consideradas corretamente no cálculo automático de benefícios devem ser informadas em dias, um dia por lançamento e com a data de referência preenchida.
						lLinOk := .F.
					EndIf
				EndIf
			EndIf
		EndIf

		If lLinOk .and. !lGp580Auto
			If !Empty(aCols[n,nPosRec])
				If ( nAux := aScan( aColsAnt, { |x| ( x[nPosRec] == aCols[n,nPosRec] ) } ) ) > 0
					If !ArrayCompare(aColsAnt[nAux], aCols[n])
						Iif(nAchou == 0 .OR. nAchou != n, lAchouMsg := .T., lAchouMsg := .F. )

						If !lItemClVl
							SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)" ) ) )
							lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + aCols[n,nPosPD] + aCols[n,nPosCC] ) )
						Else
							SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)" ) ) )
							lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + aCols[n,nPosPD] + aCols[n,nPosCC] + aCols[n,nPosItem] + aCols[n,nPosClvl] ) )
						EndIf

						If lAchou	.and. lAchouMsg
							MsgInfo( OemToAnsi(STR0089) + Chr(13)+ Chr(10) +;  //"Esta verba já foi calculada e encontra-se na tabela de movimento (SRC). Para que a alteração tenha efeito, deverá efetuar o recalculo.
							OemToAnsi(STR0078))			//"Para recalcular os lançamentos use a tecla F6 (Calcular)."
							lAchouMsg := .F.
							nAchou := n
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

	End Sequence

	RestArea(aArea)

Return( lLinOk )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea090TudOk³ Autor ³Equipe Advanced RH   ³ Data ³09/01/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica o Tudo OK                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GPEA090                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gpea090TudOk( oBrowse )

	LOCAL aAreaRCH
	Local aSRVMult	 := {}
	Local aSRCCols   := {}
	Local cBkpPer	 := cPeriodo
	Local cBkpRot	 := cRoteiro
	Local cPrefixo   := ( PrefixoCpo( cLancAlias ) + "_" )
	Local lRetorna   := .T.
	Local dDataAtual := Ctod("")
	Local dDataNX    := Ctod("")
	Local nHoraAtual := 0
	Local Nx         := 1
	Local nY         := 1
	Local nPosDel	:= len(aHeader)+1
	Local nPosItem 	 := GdFieldPos( cPrefixo+"ITEM" )
	Local nPosClVl   := GdFieldPos( cPrefixo+"CLVL" )
	Local nPosPd     := GdFieldPos( cPrefixo+"PD" )
	Local nPosCc     := GdFieldPos( cPrefixo+"CC" )
	Local nPosTipo2  := GdFieldPos( cPrefixo+"TIPO2" )
	Local nPosHor 	 := If(cLancAlias=="SRC", GdFieldPos("RC_HORINFO"), GdFieldPos("RGB_HORAS"))
	Local nPosVal 	 := If(cLancAlias=="SRC", GdFieldPos("RC_VALINFO"), GdFieldPos("RGB_VALOR"))
	Local nPosDtRef  := GdFieldPos(cPrefixo+"DTREF")
	Local nLimHorMes := gp090GetRCA("P_LIMEXMES")
	Local nHoraNX    := 0
	Local nPosDeleted:= GdFieldPos( "GDDELETED" )
	Local cRotPermit := ""
	Local nOrdem	 := 0
	Local lRetRot	 := .T.
	n 	             := If(Type("n")="U",oGet:nat, n)

	lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)

	If lGp580Auto
		aSRCCols   := aCols
	Else
		aSRCCols   := ( oGet:aCols )
	EndIf
	Continua         := .F.
	nValCalc         := 0

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Testa Total do Lan‡amento com Total Calculado                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nValLanc # 0
		nValCalc := Val( SRA->RA_MAT )
		If !lItemClvl
			aEval( aSRCCols, { |X| nValCalc += Val(X[nPosPd]) + X[nPosVal] + X[nPosHor] + Val(X[nPosCc]) } )
		Else
			aEval( aSRCCols, { |X| nValCalc += Val(X[nPosPd]) + X[nPosVal] + X[nPosHor] + Val(X[nPosCc]) + Val(X[nPosItem]) + Val(X[nPosClVl]) } )
		EndIf
		If Len(aColsAnt) > 0
			If !lItemClvl
				aEval( aColsAnt, { |X| nValCalc -=( Val(X[nPosPd]) + X[nPosVal] + X[nPosHor] + Val(X[nPosCc] ) ) } )
			Else
				aEval( aColsAnt, { |X| nValCalc -=( Val(X[nPosPd]) + X[nPosVal] + X[nPosHor] + Val(X[nPosCc]) + Val(X[nPosItem]) + Val(X[nPosClVl] ) ) } )
			EndIf
		Endif
		If Round(nValCalc,3) # Round(nValLanc,3)
			Help(" ",1,"NAOBATELAW")
			lRetorna := .F.
		Endif
	Endif
	//-
	//- Localização para Portugal - verificação de Limites de Horas Extras no Mês
	//-
	IF cPaisLoc == "PTG"

	IF ( PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_HE" ) == "S" )
		dDataAtual := aCols[n,nPosDtRef]
		nHoraAtual := aCols[n,nPosHor]
		nTotHora   := 0
		For nx := 1 to Len(aCols)
			dDataNx := aCols[nx,nPosDtRef]
			nHoraNx := aCols[nx,nPosHor]
			IF dDataAtual >= cDataIni .AND. dDataAtual <= cDataFim .and. Nx <> n .and. !Acols[nx,nPosDeleted]
				nTotHora += nHoraNx
			ENDIF
		Next


		If !Empty(nLimHorMes)                      //Se o Parametro não For Vazio
			If nHoraAtual+nTotHora > VAL(nLimHorMes)
				cMsgHelp	:= OemtoAnsi(STR0036)   // "Limite de Horas Extras Mensal Excedido
				cMsgHelp    += CHR(13) + CHR(10)
				cMsgHelp    += OemtoAnsi(STR0023) + " "+DTOC(cDataIni)+" - "+DTOC(cDataFim)   //Periodo:
				cMsgHelp    += CHR(13) + CHR(10)
				cMsgHelp    += OemtoAnsi(STR0039) + " P_LIMEXMES" + "= "+nLimHorMes
				Help( "" , 1 , "LIMHEXCEM" , NIL , OemToAnsi( cMsgHelp ) , 1 , 0 )
				lRetorna := .F.
			EndIf
		EndIF
	ENDIF
	ENDIF
	//Condicao eSocial para apresentar a tela de Multiplos Vinculos
	//Se Cliente quiser usar execAuto para Multiplos Vinculos, devera usar o model diretamente
	//Multiplos vinculos desabilitado

	If !Empty( cProcesso ) .AND. !Empty( cPeriodo ).AND. !Empty( cRoteiro )
		aAreaRCH := RCH->(GETAREA())
		DbSelectArea( "RCH" )
		nOrdem := RetOrder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR")
		lRetRot := fPosPeriodo( xFilial( "RCH" ), cProcesso, cPeriodo, cNumPagto, cRoteiro, NIL, NIL, nOrdem )
		RESTAREA(aAreaRCH)
	EndIf


	If !lGp580Auto .AND. lRetorna .AND. cPaisLoc=="BRA" .AND. lRetRot
		aEval( aCols, {|x| aAdd( aSRVMult, {x[nPosDel], PosSrv(x[nPosPd],FwxFilial("SRV",SRA->RA_FILIAL),{"RV_CODFOL"}), x[nPosTipo2] }  ) } )
		If cRoteiro == "132"
			cPeriodo 	:= SubStr(cPeriodo, 1, 4)+"13"
		ElseIf cRoteiro == "FER"
			cRoteiro	:= If(SRA->RA_CATFUNC $ "P*A", fGetCalcRot("9"), fGetRotOrdinar())
		EndIf

		cRotPermit := fGetTipoRot(cRoteiro)
		//Somente irá abrir a tela de Multiplos vínculos se for para os roteiros FOL, AUT ou Segunda parcela do 13 (132)
		If (!EMPTY(cRotPermit) .AND. cRotPermit $ "1|6|9") .AND. (aScan(aSRVMult, {|y| y[2][1] $ '288|0288|289|0289|290|0290|291|0291|396|0396|397|0397' .And. !y[1] .And. y[3] != "K"})) > 0
			oModel     	:= FWLoadModel( "GPEA924")
			cAliasRAW	:= "RAW"
			dbSelectArea("RAW")
			(cAliasRAW)->(dbSetOrder(1))
			If (cAliasRAW)->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cPeriodo+IIF(cRotPermit == "6", "2", "1")+cProcesso+cRoteiro) )
				oModel:SetOperation( MODEL_OPERATION_UPDATE )
				oModel:Activate()
				FWExecView(OemtoAnsi(STR0030), "GPEA924", MODEL_OPERATION_UPDATE,,{||.T.},,,,,,,oModel) //"Multiplos Vinculos"
			Else
				oModel:SetOperation( MODEL_OPERATION_INSERT )
				oModel:Activate()
				FWExecView(OemtoAnsi(STR0030), "GPEA924", MODEL_OPERATION_INSERT,,{||.T.}) //"Multiplos Vinculos"
			EndIf
			// Desativando o Model
			oModel:DeActivate()
		ElseIf aScan(aSRVMult, {|y|y[2][1] $ '288|0288|289|0289|290|0290|291|0291|396|0396|397|0397' .And. y[1] .And. y[3] != "K"}) > 0
			fGP90ExcMV()
		Endif
		cPeriodo := cBkpPer
		cRoteiro := cBkpRot
	EndIf

	For nY := 1 to Len(aSRCCols)
		n := nY
		If !Gpea090LinOk()
			lRetorna := .F.
		EndIf
	Next nY

Return( lRetorna )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp090Mov  ³ Autor ³ Marcos Stiefano       ³ Data ³ 28/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Move o cursor para posicionamento pelo tipo                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gp090Mov(lMov)

	Local ni		:= 0
	Local nPosicao	:= 0
	Local nPosTip	:= 0
	Local nStep		:= 0
	Local nPulos	:= 0
	Local cCampo	:= cCampo := &(ReadVar())

	DEFAULT lMov := .F.

	lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)
	If !lMov
		Return( .T. )
	Endif

	nPosTip	:= GdFieldPos( "RC_TIPO1" )
	IF ( cCampo == "H" .Or. cCampo == "D" )
		nPosicao := GdFieldPos( "RC_HORINFO" )
	ElseIF ( cCampo == "V" .Or. cCampo == "F" )
		nPosicao := GdFieldPos( "RC_VALINFO" )
	EndIF

	nStep  := IF(nPosTip > nPosicao , -1 , 1)
	nPulos := Abs( nPosicao - nPosTip )

	If ( nStep > 0 )
		nPulos--
	Else
		If ( nPostip != Len(aHeader) )
			nPulos++
		Endif
	Endif

	IF ( Alltrim(Substr(readvar(),4)) == "RC_TIPO1" )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Garante o Posicionamento na Coluna Chamadora da Funcao.       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !lGp580Auto
			While ( oGet:oBrowse:nColPos <> nPosTip )
				IF ( oGet:oBrowse:nColPos > nPosTip )
						oGet:oBrowse:GoLeft()
				ElseIF ( oGet:oBrowse:nColPos < nPosTip )
						oGet:oBrowse:GoRight()
				EndIF
			End While
		EndIf

	EndIF

	If !lGp580Auto
		For ni := 1 to nPulos
			If ( nStep > 0 )
				oGet:oBrowse:GoRight()
			Else
				oGet:oBrowse:GoLeft()
			Endif
		Next
	EndIf

	IF ( nPulos <= 0 )
		oGet:oBrowse:bEditCol:= { || AllWaysTrue() }
	EndIF

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp090Pula ³ Autor ³ Marcos Stiefano       ³ Data ³ 28/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Move o cursor para posicionamento pelo tipo Horas           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gp090Pula(lPul)

	Local nPosTip	:= GdFieldPos( "RC_TIPO1" )
	Local nPosh		:= GdFieldPos( "RC_HORA" )
	Local nPosv		:= GdFieldPos( "RC_VALOR" )

	DEFAULT lPul := .F.

	lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)
	If !lPul
		Return( .T. )
	Endif

	if !(aCols[n,nPosTip] $ "VHFD")
		HELP(" ",1,"GP090TIPO")
		Return( .F. )
	Endif

	If !lGp580Auto
		IF aCols[n,nPosTip] $ "HD" .And. nPosv <= nPosh+1
			oGet:oBrowse:GoRight()
		Endif

		IF aCols[n,nPosTip] == "V" .And. nPosh <= nPosv+1
			oGet:oBrowse:GoRight()
		Endif
	EndIf

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fTotLanc()³ Autor ³ M. Stiefano           ³ Data ³ 27/06/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta tela para informar Total do Lote.                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fTotLanc()

	Local oDlg1
	Local bSet15		:= { || NIL }
	Local bSet24		:= { || NIL }
	Local aAdvSize		:= {}
	Local aInfoAdvSize	:= {}
	Local aObjSize		:= {}
	Local aObjCoords	:= {}

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta as Dimensoes dos Objetos         					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aAdvSize		:= MsAdvSize( , .T., 390)
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 15 , 5 }
	aAdd( aObjCoords , { 000 , 005 , .T. , .F. } )
	aAdd( aObjCoords , { 000 , 020 , .T. , .F. } )
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize := MsObjSize( aInfoAdvSize , aObjCoords )

	DEFINE MSDIALOG oDlg1 FROM aAdvSize[7],0 TO aAdvSize[6]*0.40,aAdvSize[5] TITLE OemToAnsi(STR0016) PIXEL  //"Lan‡amentos"

		@ aObjSize[2,1], aObjSize[2,2] SAY STR0017 SIZE 48, 7 OF oDlg1 PIXEL // "Total do Lote:"
		@ aObjSize[2,1], aObjSize[2,2]+45 MSGET nValLanc SIZE 46, 10 OF oDlg1 PIXEL Picture "@E 999,999,999.99"
		@ aObjSize[2,1], (aObjSize[2,4]*0.50) SAY STR0018 SIZE 48, 7 OF oDlg1 PIXEL // "Total Calculado:"
		@ aObjSize[2,1], (aObjSize[2,4]*0.50)+50 MSGET nValCalc SIZE 46, 10 OF oDlg1 PIXEL Picture "@E 999,999,999.99" WHEN .F.

		bSet15 := {||nOpcA := 1, oDlg1:End()}
		bSet24 := {||nOpcA := 0, oDlg1:End()}

	ACTIVATE MSDIALOG oDlg1 ON INIT EnchoiceBar( oDlg1 , bSet15 , bSet24 ) CENTERED

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fLimEdit()³ Autor ³ Mauro                 ³ Data ³ 05/08/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Voltar o bDitcol ao Padrao apos pular coluna.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fLimEdit()

	oGet:oBrowse:bEditCol:= { || AllWaysTrue() }

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gp090MovPD³ Autor ³ Marinaldo de Jesus    ³ Data ³11/05/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Posiciona Cursor de Acordo com o Tipo da Verba.             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³lMov - Logico define se devera haver Movimentacao em aCols  ³
³          ³cCod - Campo Disparador da Validacao                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Logico por se Tratar de Validacao                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function Gp090MovPD(lMov,cCod)

	Local cPD		:= IF( ValType(cCod) != "U" , cCod , &(ReadVar() ) )
	Local cTipo		:= ""
	Local nPosPD	:= GdFieldPos( IF( ValType(cCod) = "U" , "RC_PD" , "RC_MAT" ) )
	Local nPosTip	:= GdFieldPos( "RC_TIPO1" )
	Local nPosHrs 	:= GdFieldPos( "RC_HORINFO" )
	Local nPosVal	:= GdFieldPos( "RC_VALINFO" )
	Local nPulos	:= 0
	Local nSalta	:= 0
	Local lRet		:= .T.

	DEFAULT lMov	:= .F.

	lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)
	Begin Sequence
		IF !( lMov )
			Break
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se a Verba nao Estiver Cadastrada.                            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF  ( cTipo := AllTrim(PosSRV(  cPD , SRA->RA_FILIAL , "RV_TIPO" )) ) == "@"
			Break
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Altera Tipo da Verba em aCols para Substituir na  Redigitacao ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aCols[n,nPosTip] := cTipo

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Quantidade de Vezes a Saltar                                  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF Empty(cTipo)				//Se o Tipo da Verba nao Estiver Definido
			nPulos :=  ( ( nPosTip - nPosPD ) - 1 )
		ElseIF ( cTipo $ "H_D" )	//Se o Tipo da Verba For Horas ou Dias
			nPulos := ( ( nPosHrs - nPosPD ) - 1 )
		ElseIF ( cTipo $ "F_V" )	//Se o Tipo da Verba For Fixo ou Valor
			nPulos :=  ( ( nPosVal - nPosPD ) - 1 )
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Posiciona Ponteiro na Coluna Correspondente                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !lGp580Auto
			While ( nPulos <> 0 )
				IF ( nPulos-- > 0 )
					oGet:oBrowse:GoRight()
				ElseIF ( nPulos++ < 0 )
					oGet:oBrowse:GoLeft()
				EndIF
			End While
		EndIf

	End Sequence

Return( lRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fNaoLancPD³ Autor ³ Marinaldo de Jesus    ³ Data ³04/08/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Verifica se Verba Pode Ser Lancada no Movimento            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fNoLancPD( cCodVerba , cFil , lShowHelp , @nQtdLanc )		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cCodVerba	- Codigo da Verba                               ³
³          ³ cFil		- Codigo da Filial                              ³
³          ³ lShowHelp	- Logico Mostrar Help                           ³
³          ³ nQtdLanc   - Quantidade de Lancametos Possiveis            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Logico por se Tratar de Validacao                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fNoLancPD( cCodVerba , cFil , lShowHelp , nQtdLanc )
Return( fNotLancPD( @cCodVerba , @cFil , @lShowHelp , @nQtdLanc ) )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fMontaSeq ³ Autor ³ Marinaldo de Jesus    ³ Data ³04/08/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Montar Sequencia Automatica das Verbas                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fMontaSeq( cCampo )                                         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cCampo -> Campo para a Chave da Sequencia "RC_PD ou RC_MAT" ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Logico por se Tratar de Validacao                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fMontaSeq( cCampo, cCod, cPrefixo, aGhostCols )

	Local aSRCCols		:= {}
	Local aColsAnt		:= {}
	Local aColsCopy		:= {}
	Local cNumSeq		:= ""
	Local cStrCols 		:= ""
	Local cStrCopy		:= ""
	Local lRet			:= .T.
	Local nX			:= 0
	Local nY			:= 0
	Local aNSeq			:= {}
	Local nProxSeq		:= 0
	Local nSeq			:= 0
	Local nPosOrd		:= 0
	Local nPosCc		:= 0
	Local nPosSe		:= 0
	Local nPosSq		:= 0
	Local nPosPd		:= 0
	Local nPosMat		:= 0
	Local nPosFil		:= 0
	Local nPosDeleted	:= GdFieldPos( "GDDELETED" )
	//Local nLenCols		:= Len( aSRCCols )
	//Local nSvn			:= n
	Local nLenCols		:= 0
	//Local n				:= oGet:nAt
	Local nSvn			:= 0
	Local nLenGhCols	:= 0
	Local nPosRecRgb	:= 0
	Local nIndexOf		:= 0
	Local cNomeFunc		:= FunName()
	Local nCount 		:= 0
	Local nCount1 		:= 0
	Local nQuant		:= 0
	Local cVerba		:= ""
	Local nPosDtRef 	:= 0
	Local lDataOk		:= .T.
	Local nPosItem		:= 0
	Local nPosClvl		:= 0
	Local nConta		:= 0


	DEFAULT cPrefixo    := ( Iif(MV_MODFOL!="2", PrefixoCpo( "SRC" ) + "_", PrefixoCpo( "RGB" ) + "_" ))
	Default aGhostCols := {}
	lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)

	If !lGp580Auto
		n		:= oGet:nAt
		nSvn	:= n
	EndIf

	If lGp580Auto
		aSRCCols		:= aCols
	Else
		aSRCCols		:= ( oGet:aCols )
	EndIf

	aColsAnt		:= aClone( aSRCCols )
	aColsCopy		:= aClone( aSRCCols )

	//DEFAULT cPrefixo    := ( PrefixoCpo( "SRC" ) + "_" )

	nPosCc		:= GdFieldPos( cPrefixo+"CC" )
	nPosSe		:= GdFieldPos( cPrefixo+"SEMANA" )
	nPosSq		:= GdFieldPos( cPrefixo+"SEQ" )
	nPosPd		:= GdFieldPos( IF( Upper( AllTrim( cCampo ) ) == cPrefixo+"PD" , cPrefixo+"PD" , cPrefixo+"MAT"  ) )
	nPosMat		:= GdFieldPos( cPrefixo+"MAT" )
	nPosFil		:= GdFieldPos( cPrefixo+"FILIAL" )
	nPosDtRef	:= GdFieldPos(cPrefixo+"DTREF")
	nPosItem	:= GdFieldPos( cPrefixo+"ITEM" )
	nPosClvl	:= GdFieldPos( cPrefixo+"CLVL" )

	DEFAULT cCod		:= aSRCCols[ n , nPosPd ]

	IF ( Upper( AllTrim( cCampo ) ) == cPrefixo+"PD" )
		cNumSeq		:= PosSrv( aSRCCols[ n , nPosPD ] , SRA->RA_FILIAL, "RV_QTDLANC" )
		If !lItemClVl
			cStrCols 	:= aSRCCols[ n , nPosPd ] + aSRCCols[ n , nPosCc ]+ cNumPagto
		Else
			cStrCols 	:= aSRCCols[ n , nPosPd ] + aSRCCols[ n , nPosCc ]+ aSRCCols[ n , nPosItem ]+aSRCCols[ n , nPosClvl ] + cNumPagto
		EndIf

		If cNomeFunc=="GPEA520"
			cStrCols+= aSRCCols[ n , nPosMat ]
		EndIf
	Else
		cNumSeq		:= SRV->RV_QTDLANC
		If !lItemClVl
			cStrCols 	:= aSRCCols[ n , nPosMat ] + aSRCCols[ n , nPosCc ]+ cNumPagto
		Else
			cStrCols 	:= aSRCCols[ n , nPosMat ] + aSRCCols[ n , nPosCc ]+ aSRCCols[ n , nPosItem ]+aSRCCols[ n , nPosClvl ] + cNumPagto
		EndIf
	EndIF

	nLenCols:= Len(aColsCopy)

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³O Numero Minimo de Lancamentos Permitidos e sempre "1"        ³
	³ ->Se a verba tem a opcao de lancamento diario, nao tratar    ³
	³ sequencia pois so podera ter um lancamento da verba por dia. ³
	³ Se for lancamento de tempo extra, sempre validar a     	   ³
	³ sequencia de lancamentos.                                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If (!(FunName()=="GPEA640"))
		If ( Empty( cNumSeq ) .or. ( cNumSeq == "1" ) .or. Empty( cCod ) ) .or. ;
		( PosSRV(cCod , SRA->RA_FILIAL , "RV_LCTODIA" ) == "S" )
			For nConta:=1 to Len(aSRCCols)
				If !(aSRCCols[nConta, nPosDeleted] == .T. .or. aSRCCols[n, nPosDeleted] == .T.)
					If nPosMat > 0
						If	aSRCCols[nConta, nPosPd] == aSRCCols[n, nPosPd] .and. aSRCCols[nConta,nPosMat] == aSRCCols[n, nPosMat] .and.;
							( nPosFil > 0 .and. aSRCCols[nConta, nPosFil] == aSRCCols[n, nPosFil]) .and.;
							(n <> nConta)
							If (aSRCCols[nConta, nPosDtRef] == aSRCCols[n, nPosDtRef]).or.;
								( ( Empty( cNumSeq ) .or. ( cNumSeq == "1" ) ) .And. ( PosSRV(cCod , SRA->RA_FILIAL , "RV_LCTODIA" ) == "N" ) ) // qdo a verba possui lançamento diário, a sequencia é sempre 1
								Help(" ",1,"A090MAXSEQ")
								lRet:=.F.
								Return(lRet)
							Endif
						ElseIf !Empty(aSRCCols[n, nPosSq])
							aSRCCols[n, nPosSq] :=	" "
						EndIf
					Else
						If	aSRCCols[nConta, nPosPd]== aSRCCols[n, nPosPd] .and. (n <> nConta)
							If (aSRCCols[nConta, nPosDtRef] == aSRCCols[n, nPosDtRef]) .or.;
								( ( Empty( cNumSeq ) .or. ( cNumSeq == "1" ) ) .And. ( PosSRV(cCod , SRA->RA_FILIAL , "RV_LCTODIA" ) == "N" ) ) // qdo a verba possui lançamento diário, a sequencia é sempre 1
								Help(" ",1,"A090MAXSEQ")
								lRet:=.F.
								Return(lRet)
							Endif
						ElseIf !Empty(aSRCCols[n, nPosSq])
							aSRCCols[n, nPosSq] :=	" "
						EndIf
					EndIf
				EndIf
			Next

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Verifica se Existe o Objeto oGet:oBrowse para o Refresh()	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If ( Type("oGet:oBrowse") == "O" )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Compara o Conteudo para verificar se Houve Alteracao          ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If !ArrayCompare( aColsAnt , aSRCCols )
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Repintando o Browse da GetDados							   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					oGet:oBrowse:Refresh()
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Restaura Posicao de n Apos Refresh do Browse da GetDados	   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					n := nSvn
				EndIf
			EndIf
			Return( lRet )
		EndIf
	EndIf
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Salva Sequencia inicial de aCols para poder restaura-la na mes³
	³ma ordem.                                                     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	For nX := 1 To nLenCols
		aAdd( aColsCopy[ nX ] , StrZero( nX , 4 ) )
	Next nX

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Posicao da Ordem de Entrada								   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nPosOrd := Len( aColsCopy[ nX - 1 ] )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Ordena aColsCopy com as Chaves Respectivas                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF ( Upper( AllTrim( cCampo ) ) == cPrefixo+"PD" )
		If !lItemClvl
			aSort( aColsCopy ,,, { |x,y| x[ nPosPd ] + x[ nPosCc ] + cNumPagto + x[ nPosSq ] < ;
										y[ nPosPd ] + y[ nPosCc ] + cNumPagto + y[ nPosSq ]   ;
								}																 				    ;
				)
		Else
			aSort( aColsCopy ,,, { |x,y| x[ nPosPd ] + x[ nPosCc ] + x[ nPosItem ]+ x[ nPosClVl ]+ cNumPagto + x[ nPosSq ] < ;
										y[ nPosPd ] + y[ nPosCc ] + y[ nPosItem ]+ y[ nPosClVl ]+ cNumPagto + y[ nPosSq ]   ;
								}																 				    ;
				)
		EndIf
	Else
		If !lItemClvl
			aSort( aColsCopy ,,, { |x,y| x[ nPosMat ] + x[ nPosCc ] + cNumPagto + x[ nPosSq ] < ;
										y[ nPosMat ] + y[ nPosCc ] + cNumPagto + y[ nPosSq ]   ;
						}												                  				 	 ;
			)
		Else
			aSort( aColsCopy ,,, { |x,y| x[ nPosMat ] + x[ nPosCc ] + x[ nPosItem ] +  x[ nPosClVl ]+ cNumPagto + x[ nPosSq ] < ;
										y[ nPosMat ] + y[ nPosCc ] + y[ nPosItem ] +  y[ nPosClVl ]+ cNumPagto + y[ nPosSq ]   ;
						}												                  				 	 ;
			)
		EndIf
	EndIF

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Renumera Sequencia de Lancamentos                             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	For nX := 1 To nLenCols
		IF ( Upper( AllTrim( cCampo ) ) == cPrefixo+"PD" )
			If !lItemClvl
				cStrCopy := aColsCopy[ nX , nPosPd ] + aColsCopy[ nX , nPosCc ] + cNumPagto
			Else
				cStrCopy := aColsCopy[ nX , nPosPd ] + aColsCopy[ nX , nPosCc ] + aColsCopy[ nX , nPosItem ] + aColsCopy[ nX , nPosClVl ] + cNumPagto
			EndIf
			If cNomeFunc=="GPEA520"
				cStrCopy+= aColsCopy[ nX , nPosMat ]
			EndIf
		Else
			If !lItemClvl
				cStrCopy := aColsCopy[ nX , nPosMat ] + aColsCopy[ nX , nPosCc ]+ cNumPagto
			Else
				cStrCopy := aColsCopy[ nX , nPosMat ] + aColsCopy[ nX , nPosCc ]+ aColsCopy[ nX , nPosItem ] + aColsCopy[ nX , nPosClVl ] + cNumPagto
			EndIf
		EndIF
		IF !( aColsCopy[ nX , nPosDeleted ] )
			IF ( cStrCopy == cStrCols )
				If cPrefixo == "RGB_"
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Se estiver trabalhando com a tabela RGB, a numeracao de       ³
					³sequencia das verbas e controlada por varias telas de lanca-  ³
					³mentos(GPEA090,GPEA100,GPEA520,GPEA640) sendo que a tela de   ³
					³lancamento GPEA640 nao exibe os mesmos lancamentos de GPEA090 ³
					³por ex. Sendo assim quando uma montagem de sequencia e soli-  ³
					³tada um array chamado aGhCols e somado ao array da getDados   ³
					³e a sequencia e entao gerada, mas lembre se que o aGhostCols  ³
					³e um array de visualizacao e portanto suas sequencias nao po- ³
					³dem ser alteradas ou duplicadas.                              ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If Empty(aColsCopy[ nX , nPosSq ])
						/*Gera array com todas sequencias ja existentes*/
						aNSeq := {}
						For nY:=1 To nLenCols
							IF ( Upper( AllTrim( cCampo ) ) == cPrefixo+"PD" )
								If !lItemClvl
									cStrCopy := aColsCopy[ nY , nPosPd ] + aColsCopy[ nY , nPosCc ] + cNumPagto
								Else
									cStrCopy := aColsCopy[ nY , nPosPd ] + aColsCopy[ nY , nPosCc ] + aColsCopy[ nY , nPosItem ] + aColsCopy[ nY , nPosClVl ] + cNumPagto
								EndIf
								If cNomeFunc=="GPEA520"
									cStrCopy+= aColsCopy[ nY , nPosMat ]
								EndIf
							Else
								If !lItemClvl
									cStrCopy := aColsCopy[ nY , nPosMat ] + aColsCopy[ nY , nPosCc ] + cNumPagto
								Else
									cStrCopy := aColsCopy[ nY , nPosMat ] + aColsCopy[ nY , nPosCc ] + aColsCopy[ nY , nPosItem ] + aColsCopy[ nY , nPosClVl ] + cNumPagto
								EndIf
							EndIF
							If ( cStrCopy == cStrCols ) .AND. !( aColsCopy[ nY , nPosDeleted ] )
								aAdd(aNSeq, aColsCopy[ nY , nPosSq ])
							EndIf
						Next nY

						/*Encontra o primeiro intervalo de sequencia valido*/
						nSeq:=0
						cNumSeq := if( Val(cNumSeq) = 0, "1", cNumSeq)
						For nY:=1 To Val(cNumSeq)
							If  aScan(aNSeq, StrZero( nY , aHeader[ nPosSq , 4 ]) ) == 0
								nSeq:= nY
								nY:=Val(cNumSeq)+1
							EndIf
						Next nY
						If nSeq==0
							nSeq:=Val(cNumSeq)+1
						EndIf
					Else
						nSeq := Val(aColsCopy[ nX , nPosSq ])
					EndIf
				Else
					nSeq++
				EndIf

				If Len(aNSeq) == 1
					lRet := .T.
					aColsCopy[ nX , nPosSq ] := " "
				Else
					IF ( lRet := ( nSeq <= Val( cNumSeq ) ) )
						If cPrefixo=="RGB_"
							If Empty(aColsCopy[ nX , nPosSq ])
								aColsCopy[ nX , nPosSq ] := StrZero( nSeq , aHeader[ nPosSq , 4 ] )
							EndIf
						Else
							aColsCopy[ nX , nPosSq ] := StrZero( nSeq , aHeader[ nPosSq , 4 ] )
						EndIf
					Else
						Help(" ",1,"A090MAXSEQ")
						Return( lRet )
					EndIF
				EndIf
			EndIF
		Else
			aColsCopy[ nX , nPosSq ] := Space( aHeader[ nPosSq , 4 ] )
		EndIF
	Next nX

	If Len(aGhostCols)> 0
		//Elimina os Itens de aGhostCols que foram somados anteriormente
		For nX:=1 To nLenGhCols
			nIndexOf := aScan(aColsCopy, { |x| x[nPosRecRgb]==aGhostCols[nX,nPosRecRgb]})
			If nIndexOf > 0
				ADel(aColsCopy, nIndexOf)
				ASize(aColsCopy, Len(aColsCopy)-1)
			EndIf
		Next
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Restaura Sequencia original de aColsCopy                      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nPosOrd := iIf(Len(aColsCopy)>0, Len(aColsCopy[1]), nPosOrd)
	aSort( aColsCopy ,,, { |x,y| x[ nPosOrd  ] < y[ nPosOrd  ] } )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Atualiza a Sequencia de Lancamentos                           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	For nX := 1 To Len( aSRCCols )
		aSRCCols[ nX , nPosSq ] := aColsCopy[ nX , nPosSq ]
	Next nX

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica se Existe o Objeto oGet:oBrowse para o Refresh()	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF ( Type("oGet:oBrowse") == "O" )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Compara o Conteudo para verificar se Houve Alteracao          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !ArrayCompare( aColsAnt , aSRCCols )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Repintando o Browse da GetDados							   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			oGet:oBrowse:Refresh()
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Restaura Posicao de n Apos Refresh do Browse da GetDados	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			n := nSvn
		EndIF
	EndIF

Return( lRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RcPdValid ³ Autor ³ Marinaldo de Jesus    ³ Data ³04/08/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Conteudo do RC_PD                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RcPdValid( lMovPd )                                         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³lMovPd para a funcao Gp090MovPd( lMovPd )					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Logico por se Tratar de Validacao                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RC_PD                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function RcPdValid( lMovPd )

	Local cPd			:= &( ReadVar() )
	Local cDescPd		:= ""
	Local cDigSema		:= Upper( AllTrim( SuperGetMv( "MV_DIGSEMA" , NIL , "N" ) ) )
	Local lRcPdValid	:= .T.

	DEFAULT lMovPd		:= .F.

	Begin Sequence
		if Type( "aCols" ) != "U"
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Verifica se Verba Aceita Lancamentos                          ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF !( lRcPdValid := fNoLancPD() )
				Break
			EndIF

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Carrega a Descricao da Verba                                  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cDescPd := fDesc( "SRV" , cPd , "RV_DESC" )
			GdFieldPut( "RC_DESCPD" , cDescPd )

			SRV->(dbSetOrder(1))
			if(SRV->(dbSeek(xFilial('SRV') + cPd)))
				GdFieldPut( "RC_INSS", SRV->RV_INSS )
				GdFieldPut( "RC_FGTS", SRV->RV_FGTS )
				GdFieldPut( "RC_IR"	, SRV->RV_IR )
			endIf

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Carrega o Conteudo do campo RC_SEMANA                         ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If !Empty(cNumPagto)
				GdFieldPut("RC_SEMANA", cNumPagto)
			EndIf

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Posiciona Cursor na Coluna Correspondente                     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			Gp090MovPd( lMovPd )
		EndIf
	End Sequence

Return( lRcPdValid )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp090MontaGetDados ³ Autor ³ Tatiane Matias        ³ Data ³27/07/2004							   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Montar a GetDados de acordo com o periodo informado             						           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
³Sintaxe   ³gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, aVirtual, aColsRec, aSRCCols, lGravarAntes, lEntrada)³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cAlias                                                                               		       ³
³          ³nOpcX  																							   ³
³          ³cFil - Filial.																					   ³
³          ³cMat - Matricula.																				   ³
³          ³aVirtual - array dos campos virtuais.															   ³
³          ³aColsRec - array que contem o Recno() dos registros da aCols.									   ³
³          ³aSRCCols 																					       ³
³          ³lGravarAntes - indica se deve chamar a funcao de gravacao antes de montar a tela.				   ³
³          ³lEntrada - indica se a funcao gp090MontaGetDados esta sendo chamada na entrada da rotina de lanca- ³
³          ³           mentos por periodo.                                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Logico                                                          								   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpea090Mnt                                                            							   ³
³          ³Na alteracao do campo periodo                                         							   ³
³          ³Gpea090Grava                                                           							   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, aVirtual, aColsRec, aSRCCols, lGravarAntes, lEntrada)

	Local lUseGhClm		:= .T.
	Local aGdNaoAltera	:= {}
	Local bSkip			:= { || .F. }
	Local cQueryCond	:= ""
	Local cQueryGh		:= ""
	Local cAcessaSrc    := ""
	Local aNotFields	:= {}
	Local aVisual		:= {}
	Local cKeySeek		:= ""
	Local nPosPd		:= 0
	Local nPosDesc		:= 0
	Local nPosHoras		:= 0
	Local nPosTp1		:= 0
	Local nPosDtRef		:= 0	
	Local nX			:= 0
	Local cChkNrPagto	:= Getmv("MV_CATNPGT")
	Local cPrefixo      := ( PrefixoCpo( cAlias ) + "_" )
	Local bSaveBefore   := { || iif(Gpea090TudOk(),Gpea090Grava(cAlias,cFil,cMat,aVirtual,aColsRec,nOpcx, .T.,.T.),) }
	Local lGP042Reg		:= (cPaisLoc $ "COL" .And. FunName() == "GPEM042")
	lVerificaMes        := .F.
	Default lEntrada 	:= .F.

	cNumId	:= If (Type("cNumId") == "U", "", cNumId) //Recebida no GPEA580() para tratamento do Consignado.

	// Antes de montar a tela, verifica se deseja gravar ... caso tenha tido alguma alteracao.
	If lGravarAntes
		MsAguarde( bSaveBefore, OemToAnsi(STR0024))
	EndIf

	If Empty(SRA->RA_MAT)
		SRA->( DbSkip(-1) )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza os dados do Funcionario.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFil		:= SRA->RA_FILIAL
	cMat		:= SRA->RA_MAT
	cCategoria	:= SRA->RA_CATFUNC
	cProcesso	:= SRA->RA_PROCES
	cPosto 		:= SRA->RA_POSTO

	lDaRefresh := .F.
	If !lGp580Auto
		If (cPeriodo <> cPeriodoAnt) .or. (cNumPagto <> cSemanaAnt) .or. cRoteiro <> cRoteiroAnt
			lDaRefresh := .T.

			// Recupera o roteiro do periodo/numero de pagamento informado.
			If (cRoteiro <> RCH->RCH_ROTEIR .and. !Empty(RCH->RCH_ROTEIR)) .or. Empty(cRoteiro)
				DbSelectArea( cAlias )
				cRoteiro	:= gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_ROTEIR = '" + cRoteiro + "' AND RCH_NUMPAG ='" + cNumPagto + "'", "RCH_ROTEIR" ,,.T. )
				If Empty(cRoteiro)
					cRoteiro := fGetRotOrdinar()
				EndIf
			ElseIf cRoteiro <> RCH->RCH_ROTEIR .and. Empty(RCH->RCH_ROTEIR)
				// somente posicionar na tabela RCH e nao atualizar o roteiro
				DbSelectArea( cAlias )
				gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_NUMPAG ='" + cNumPagto + "'", "RCH_ROTEIR" ,,.T. )
			Else
				DbSelectArea( cAlias )
				gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_ROTEIR = '" + cRoteiro + "' AND RCH_NUMPAG ='" + cNumPagto + "'", "RCH_ROTEIR" ,,.T. )
			EndIf
			//Recarrega o array de validacao das verbas para a GetDados
			MontaF3SRV(.T., cRoteiro, cProcesso, @aIndexSrv, .T.)
		EndIf
	EndIf

	// Recupera a data de inicio e a data fim do periodo informado.
	cDataIni := gp090RetDtRef(.T.)
	cDataFim := gp090RetDtRef()

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta Bloco para Skip em GdMontaCols                         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	bSkip := { || .F. }
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta Query para a Selecao das Informacoes em GdMontaCols    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cQueryCond	:= cPrefixo+"FILIAL='"+cFil+"'"
	cQueryCond	+= " AND "
	cQueryCond	+= cPrefixo+"MAT='"+cMat+"'"
	cAcessaSrc	:= ChkRH(If(cAlias=="SRC","GPEA090","GPEA580"),cAlias,"1")
	cAcessaSrc	:= fSFiltrSQL(cAcessaSrc)

	If (!Empty(cAcessaSrc))
		cQueryCond	+= " AND "
		cAcessaSrc := StrTran(cAcessaSrc, cAlias+".","")
		cQueryCond	+= cAcessaSrc
	EndIf

	cQueryCond	+= " AND "
	cQueryCond	+= "D_E_L_E_T_ = ' ' "

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define os Campos que nao serao Mostrados                     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aNotFields	:= {cPrefixo+"FILIAL"	, ;
						cPrefixo+"MAT" 	, ;
						cPrefixo+"NOME" 	, ;
						If(cAlias=="SRC",cPrefixo+"PERIODO",cPrefixo+"PERIOD"), ;
						cPrefixo+"PROCES"	, ;
						cPrefixo+"POSTO"	, ;
						If ( (IsInCallStack("GPEM040") .Or. IsInCallStack("GPEA580") .Or. !Empty(cNumId)) ,"", cPrefixo+"NUMID" ), ;
						cPrefixo+"ROTEIR" , ;
						cPrefixo+"SEMANA" , }

	If cAlias == "RGB"
		aAdd(aNotFields, "RGB_DUM")
		aAdd(aNotFields, "RGB_DDOIS")
		aAdd(aNotFields, "RGB_DTRES")
		aAdd(aNotFields, "RGB_DQUATR")
		aAdd(aNotFields, "RGB_DCINCO")
		aAdd(aNotFields, "RGB_DSEIS")
		aAdd(aNotFields, "RGB_DSETE")
		If cPaisLoc == "RUS"
			aAdd(aNotFields, "RGB_DEPTO")
		EndIf
	EndIf

	If !lItemClVl
		AAdd(aNotFields, cPrefixo+"ITEM")
		AAdd(aNotFields, cPrefixo+"CLVL")
	EndIf

	// Se esta entrando na tela, verifica se existe algum lancamento, independente do periodo,
	// para o funcionario selecionado. Se for inclusao, nao deve ter nenhum registro. Se for
	// alteracao, deve ter pelo menos um registro.
	If lEntrada
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta a chave para Pesquisa em GdMontaCols                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cKeySeek := ( cFil + cMat )

		//Limpa array para não ocasionar erro na navegação de registros devido aos campos virtuais inseridos (RC_INSS, RC_IR, RC_FGTS, RC_INCORP)
		aHeader := {}

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta os Detalhes                                    		 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aSRCCols := GdMontaCols(	@aHeader,;
									@nUsado,;
									@aVirtual,;
									@aVisual,;
									cAlias,;
									aNotFields,;
									@aColsRec,;
									cAlias,;
									cKeySeek,;
									NIL,;
									bSkip,;
									NIL,;
									NIL,;
									NIL,;
									NIL,;
									NIL,;
									NIL,;
									cQueryCond,;
									.F.,;
									.F.,;
									.T.)

		If ( nOpcX == 2 .Or. nOpcX == 5 ) .and. ( Len( aColsRec ) == 0 ) .And. (Type( "lResM2" ) == "U" .Or. !lResM2) .And. !( IsInCallStack("GPEI090") )  .and. !lCalcExec  .And. !lGp580Auto//Quando Nao for Inclusao
			Help(" ",1,"A040SLANC")
			Break
		EndIF
	EndIf

	If !( lSRCLock := Gpea090Locks( nOpcx , cAlias ) )
		Break
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define os Campos que nao Serao Alterados                     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If ! lGp580Auto
		aGdNaoAltera := { cPrefixo + "TIPO2", cPrefixo + "SEMANA"}
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Define os Campos para a GetDados										 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	//cChkNrPagto -> Categorias que não deverao validar o número de pagamento informado
	If !(cCategoria $ cChkNrPagto) .OR. (cCategoria $ cChkNrPagto .AND. !Empty(cNumPagto))

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega a Semana para Digitacao                              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cSemana := cNumPagto

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta Bloco para Skip em GdMontaCols                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		bSkip := { || &(cAlias+"->"+cPrefixo+"SEMANA") <> cNumPagto }

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta Query para a Selecao das Informacoes em GdMontaCols    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

		cQueryCond	:= cPrefixo+"FILIAL='"+cFil+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= cPrefixo+"MAT='"+cMat+"'"

		IF !Empty( cPeriodo )
			cQueryCond	+= " AND "
			cQueryCond	+= cPrefixo + If(cAlias == "SRC","PERIODO","PERIOD")+ "='" + cPeriodo + "'"
		EndIF

		IF !Empty( cSemana )
			cQueryCond	+= " AND "
			cQueryCond	+= cPrefixo+"SEMANA='"+cSemana+"'"
		EndIF

		IF !Empty( cRoteiro )
			cQueryCond	+= " AND "
			cQueryCond	+= cPrefixo+"ROTEIR='"+cRoteiro+"'"
		EndIF

		cAcessaSrc	:= ChkRH(If(cAlias=="SRC","GPEA090","GPEA580"),cAlias,"1")
		cAcessaSrc	:= fSFiltrSQL(cAcessaSrc)

		If (!Empty(cAcessaSrc))
			cQueryCond += " AND "
			cAcessaSrc := StrTran(cAcessaSrc, cAlias+".","")
			cQueryCond	+= cAcessaSrc
		EndIf

		cQueryCond	+= " AND "
		cQueryCond	+= "D_E_L_E_T_ = ' ' "

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta a chave para Pesquisa em GdMontaCols                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cKeySeek := ( cFil + cMat + cPeriodo + cRoteiro + cSemana )

	Else
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta Bloco para Skip em GdMontaCols                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		bSkip := { || .F. }
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta Query para a Selecao das Informacoes em GdMontaCols    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

		cQueryCond	:= cPrefixo+"FILIAL='"+cFil+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= cPrefixo+"MAT='"+cMat+"'"

		IF !Empty( cPeriodo )
			cQueryCond	+= " AND "
			cQueryCond	+= cPrefixo + If(cAlias == "SRC","PERIODO","PERIOD")+ "='" + cPeriodo + "'"
		EndIF

		IF !Empty( cRoteiro )
			cQueryCond	+= " AND "
			cQueryCond	+= cPrefixo+"ROTEIR='"+cRoteiro+"'"
		EndIF

		cQueryCond	+= " AND "
		cQueryCond	+= "D_E_L_E_T_ = ' ' "

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta a chave para Pesquisa em GdMontaCols                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cKeySeek := ( cFil + cMat + cPeriodo + cRoteiro )

    EndIf

    /*
    	Se for referente a tabela RGB entao nao exibe campos que tem os dados
      de lancamento de tempos extra, serao exibidas em outras telas, GPEA520 e GPEA640
    */
	If cAlias == "RGB"
		/* Clona a query de abertura, considerando todos os calculos,
			para o calculo de chequencia de verbas
		*/

		cCodRoteiro		:= cRoteiro
		cCodProcesso 	:= cProcesso
		cQueryGh 		:= cQueryCond

		cQueryCond += " AND ("
		cQueryCond += " RGB_DUM = 0 AND"
		cQueryCond += " RGB_DDOIS = 0 AND"
		cQueryCond += " RGB_DTRES = 0 AND"
		cQueryCond += " RGB_DQUATR = 0 AND"
		cQueryCond += " RGB_DCINCO = 0 AND"
		cQueryCond += " RGB_DSEIS = 0 AND"
		cQueryCond += " RGB_DSETE = 0 ) "

		//Query para abertura de aCols Ghost
		cQueryGh += " AND ("
		cQueryGh += " RGB_DUM != 0 OR"
		cQueryGh += " RGB_DDOIS != 0 OR"
		cQueryGh += " RGB_DTRES != 0 OR"
		cQueryGh += " RGB_DQUATR!= 0 OR"
		cQueryGh += " RGB_DCINCO!= 0 OR"
		cQueryGh += " RGB_DSEIS != 0 OR"
		cQueryGh += " RGB_DSETE != 0 ) "
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta os Detalhes                                    		   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	(cAlias)->( dbSetOrder( RetOrder( cAlias , cPrefixo+"FILIAL+"+cPrefixo+"MAT+"+cPrefixo+If(cAlias=="SRC","PERIODO+","PERIOD+")+cPrefixo+"ROTEIR+"+cPrefixo+"SEMANA" ) ) )


	//Limpa array para não ocasionar erro na navegação de registros devido aos campos virtuais inseridos (RC_INSS, RC_IR, RC_FGTS, RC_INCORP)
	aHeader := {}

 	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Executa o filtro depois do dbSetOrder pois o mesmo tira o fil|
	³ tro de FilBrowse, que a funcao ffiltro executa               |
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
  	If Len(aArray)>0
		ffiltro(If(cAlias=="SRC","GPEA090","GPEA580"),aArray,1,1,3)//1- Executa os Filtros
	Endif

	If (cPaisLoc == "RUS")
		lUseGhClm := .F.
	EndIf

	//Coluna Oculta para o calculo da sequencia, com todos os dados
	If (cAlias == "RGB" .AND. IsInCallStack("GPEA580"))
		aGhCols	 := GdMontaCols(@aHeader, @nUsado, @aVirtual, @aVisual, cAlias, aNotFields, @aColsRec, cAlias, ;
									 NIL, NIL, bSkip, NIL, NIL, NIL, NIL, NIL, NIL, cQueryGh, .F., .F., lUseGhClm )
		MontaF3Srv(.F., cRoteiro, cProcesso, @aIndexSrv, .T.)
	EndIf

	aSRCCols := GdMontaCols(	@aHeader,;		//01
								@nUsado,;
								@aVirtual,;
								@aVisual,;
								cAlias,;		//05
								aNotFields,;
								@aColsRec,;
								cAlias,;
								cKeySeek,;
								NIL,;			//10
								bSkip,;
								NIL,;
								NIL,;
								NIL,;
								NIL,;			//15
								NIL,;
								NIL,;
								cQueryCond,;
								.F.,;
								.F.,;			//20
								lUseGhClm)

	nPosSemana	:= GdFieldPos( cPrefixo+"SEMANA", aHeader)

	If nPosSemana > 0
		aAdd(aVisual, cPrefixo+"SEMANA")
		aHeader[nPosSemana, __AHEADER_VISUAL__]  := "V"
		aHeader[nPosSemana, __AHEADER_INITPAD__] := "cNumPagto"

		For nX:= 1 To Len(aSRCCols)
			If Empty(aSRCCols[nX,nPosSemana])
				aSRCCols[nX, nPosSemana] := cNumPagto
			EndIf
		Next
	EndIf

	If (cAlias == "RGB" .AND. IsInCallStack("GPEA580"))
		nPosDtRef	:= GdFieldPos( cPrefixo+"DTREF", aHeader)
		If nPosDtRef > 0
			aHeader[nPosDtRef, __AHEADER_INITPAD__] := 'CtoD("//")'
		EndIf
	EndIf

	If !lItemClVl
		(cAlias)->( dbSetOrder( RetOrder( cAlias , cPrefixo+"FILIAL+"+cPrefixo+"MAT+"+cPrefixo+"PD+"+cPrefixo+"CC+"+cPrefixo+"SEMANA+"+cPrefixo+"SEQ" ) ) )
    Else
    	(cAlias)->( dbSetOrder( RetOrder( cAlias , cPrefixo+"FILIAL+"+cPrefixo+"MAT+"+cPrefixo+"PD+"+cPrefixo+"CC+"+cPrefixo+"ITEM+"+cPrefixo+"CLVL+"+cPrefixo+"SEMANA+"+cPrefixo+"SEQ" ) ) )
    EndIf
	//(cAlias)->( dbSetOrder(1))
	If Len(aArray)>0
		ffiltro(If(cAlias=="SRC","GPEA090","GPEA580"),aArray,1,1,3)//1- Executa os Filtros
	Endif

	nPosPd		:= GdFieldPos( cPrefixo+"PD"		, aHeader )
	nPosDesc	:= GdFieldPos( cPrefixo+"DESCPD"	, aHeader )
	nPosHoras	:= If(cAlias=="SRC", GdFieldPos( cPrefixo+"HORINFO", aHeader ), GdFieldPos( cPrefixo+"HORAS", aHeader ))
	nPosTp1		:= GdFieldPos( cPrefixo+"TIPO1"	, aHeader )


	//Guarda campos virtuais que não são do X3, são adicionados manualmente.
	If cPaisLoc != "RUS"
		addVirtCpo(aHeader,aSRCCols,aVirtual,cPrefixo,@aGhCols)
	EndIf

	For nX := 1 To Len( aSRCCols )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega a Descricao das Verbas         					   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aSRCCols[ nX , nPosDesc ] := fDesc( "SRV" , aSRCCols[ nX , nPosPd ] , "RV_DESC" )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se MV_HORASDE = "S" e Campo RC_HORINFO Converte Horas          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( cDigHoras == "S" ) .And. (aSRCCols[nX,nPosTp1] == "H" )
			//Se o campo HORINFO nao for usado no pais, utiliza o campo HORAS
			If nPosHoras == 0
				nPosHoras := GdFieldPos( cPrefixo+"HORAS", aHeader )
			EndIf
			aSRCCols[ nX , nPosHoras ] := fConvHr( aSRCCols[ nX , nPosHoras ] , "H" )
		EndIF
	Next nX

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega, apenas, os Campos Editaveis            			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aGdAltera := {}
	For nX := 1	To nUsado
		IF (;
				( aScan( aVirtual 		, aHeader[ nX , 02 ] ) == 0 );
				.and.;
		   		( aScan( aVisual  		, aHeader[ nX , 02 ] ) == 0 );
		   		.and.;
		   		( aScan( aNotFields	, aHeader[ nX , 02 ] ) == 0 );
		   		.and.;
		   		( aScan( aGdNaoAltera	, aHeader[ nX , 02 ] ) == 0 );
		  	)
			aAdd( aGdAltera , aHeader[ nX , 02 ] )
		EndIF
	Next nX

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ salva o acols e o periodo antes da alteracao 	 			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aColsAnt	:= aClone( aSRCCols )
	cPeriodoAnt := cPeriodo
	cSemanaAnt	:= cNumPagto
	cRoteiroAnt := cRoteiro

	// atualiza a getdados
	If !(oGet == nil)
		oGet:SetArray(aClone(aSRCCols))
		oGet:lModified := .F.
 		If ( Type("oGet:oBrowse") == "O" )
			oGet:Refresh()
		EndIf
	EndIf

	If !lGP042Reg .And. !lGp580Auto .And. !Empty(RCH->RCH_ROTEIR) .AND. cRoteiro <> "VEX" .And. RCH->RCH_PER <> cPeriodo
		cRoteiro := RCH->RCH_ROTEIR
	EndIf

Return (.T.)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp090RetDtRef ³ Autor ³ Tatiane Matias        ³ Data ³27/07/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³retorna data de referencia do periodo informado             	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
³Sintaxe   ³gp090RetDtRef(lDataIni)											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³lDataIni - indica se retorna o primeiro dia do periodo (.T.).   ³
³          ³        Se esse parametro nao for passado (NIL ou .F.) essa  	³
³          ³  		funcao ira retornar o ultimo dia do periodo informado.  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Data de referencia. Primeiro dia do periodo, se lDataIni = .T.  ³                                                          								   ³
³          ³ ou ultimo dia do periodo.                                   	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpea090LinOk                                                    ³
³          ³GPEA100                                                         ³
³          ³gp090MontaGetDados                                              ³
³          ³X3_RELACAO (SX3) do campo RC_DTREF                              ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function gp090RetDtRef(plDataIni)

	Local aArea := RCH->( GetArea() )
	Local dDataRef   := CTOD("")
	Default plDataIni  := .F.

		// retorna ano e mes do periodo informado.
		If plDataIni
			dDataRef := RCH->RCH_DTINI
		Else
			dDataRef := RCH->RCH_DTFIM
		EndIf

	RestArea( aArea )
Return (dDataRef)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gpRetorno ³Autor³Tatiane Vieira Matias      ³Data³31/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorno da Consulta Padrao									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gpRCHRetorno(cTipo)

	//cTipo == "NUMPAGO"
	//	    == "PERIODO"
	//      == "PROCESSO"

	Local cCpoRet		:= ""

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Essa variavel determina se na Consulta RCH devera ou nao reto³
	³ rnar o Nro de Pagamento. Quando nao quer o retorno devera    ³
	³ criar a variavel lNumPago como .F. no programa que executa a ³
	³ a consulta Padrao.                                           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If Type( "lNumPago" ) == "U"
		lNumPago := .T.
	EndIf

	If cTipo == "NUMPAGO"
		If lNumPago
			cCpoRet := "RCH->RCH_NUMPAG"
		Else
			cCpoRet := Space( GetSx3Cache( "RCH_NUMPAG", "X3_TAMANHO" ) )
		EndIf
	ElseIf  cTipo =="PROCES"
		If ( Type("oGetRG8") == "O" )
			cCpoRet := "RCH->RCH_PROCES"
		Endif
	ElseIf  cTipo =="ROTEIR"
		If ( Type("oGetRG8") == "O" )
			cCpoRet := "RCH->RCH_ROTEIR"
		Endif
	ElseIf  cTipo =="MES"
		If ( Type("oGetRG8") == "O" )
			cCpoRet := "RCH->RCH_MES"
		Endif
	ElseIf  cTipo =="ANO"
		If ( Type("oGetRG8") == "O" )
			cCpoRet := "RCH->RCH_ANO"
		Endif
	Else
		cCpoRet := "RCH->RCH_PER"
	EndIf

	cCpoRet := If ( Empty(&(cCpoRet)), "",  &(cCpoRet) )

Return ( cCpoRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gpFiltro  ³Autor³Tatiane Vieira Matias      ³Data³31/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Filtro da Consulta Padrao									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ExpC2 - Filtro de Tipo de roteiro (RY_TIPO) 				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gpRCHFiltro(cTipo, cTpRot)

	Local cFiltro		:= ""
	Local cRotFiltro	:= ""
	Local lPonto		:= FWIsInCallStack("PONA180") .Or. FWIsInCallStack("PONA240") .Or. FWIsInCallStack("PONA190") .Or. FWIsInCallStack("PONA270") .Or. FWIsInCallStack("PONA220")

	DEFAULT cTipo 		:= ""
	DEFAULT cTpRot 		:= ""

	If Type("cFilRCJ") <> "U" .and. !Empty(cFilRCJ)
		If FWModeAccess("RCJ",1) == "E" .AND. FWModeAccess("RCJ",2) == "E" .AND. FWModeAccess("RCJ",3) == "E"
			cFilAnt := cFilRCJ
		Else
			cFilAnt := FWArrFilAtu(cEmpAnt,Padr(cFilRCJ,FwSizeFilial()))[2]
		EndIf
	EndIf

	cFiltro		:= "(RCH->RCH_FILIAL == '" + xFilial("RCH") + "')"

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Criar as variaveis DEFAULT 								   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If Type( "cCond" ) == "U"
		cCond := "3"
	EndIf

	If Type( "cProcesso" ) == "U"
		cProcesso := ""
	EndIf

	If Type( "cPeriodo" ) == "U"
		cPeriodo := ""
	EndIf

	If Type( "cRot" ) == "U"
		cRot := ""
	EndIf

	If Type( "lRotEmpty" ) == "U"
		lRotEmpty := .F.
	EndIf

	If Type( "cModuloFlt" ) == "U"
		cModuloFlt := ""
	EndIf

	If Len(cTpRot) > 0
		DbSelectArea("SRY")
		DbSetOrder(1)
		dbSeek(xFilial("SRY"))
		While (!Eof()) .And. (SRY->RY_FILIAL == xFilial("SRY") )
			//Condicao para separar todos roteiros, que são do tipo estipulado no 2. parametro desta função
			//usado na consulta padrao RCH11
			If 	!Empty(SRY->RY_TIPO) .AND. 	(SRY->RY_TIPO == (cTpRot))
				If Len(cRotFiltro)= 0
					cRotFiltro += " .AND. (RCH->RCH_ROTEIR == '" + SRY->RY_CALCULO + "'"
				Else
					cRotFiltro += " .OR. RCH->RCH_ROTEIR == '" + SRY->RY_CALCULO + "'"
				EndIf
			EndIf
			dbSkip()
		EndDo

		cRotFiltro		:= IIf ( Len(cRotFiltro) > 0,cRotFiltro + ")","")

	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Documentacao das Variaveis 								   ³
	³															   ³
	³cCond == 1 -> Periodos Abertos 							   ³
	³      == 2 -> Periodos Fechados							   ³
	³      == 3 -> Ambos	         							   ³
	³cTipo == "NUMPAGO"                         				   ³
	³      == "PERIODO"                         				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cCond == "1" .OR. cCond == "2" // Periodo aberto ou fechado
		If !Empty(cFiltro)
			cFiltro	+= " .AND. "
		EndIf
		If cCond == "2" // Periodo fechado
			cFiltro := "!"
		EndIf
		cFiltro	+= "EMPTY(RCH->RCH_DTFECH) "
		If !lPonto .And. !(cPaisLoc == "RUS" .And. IsInCallStack("GPEA580"))
			cFiltro	+= ".AND. RCH_PERSEL = '1'"
		EndIf
	EndIf

	If cTipo == "NUMPAGO"
		If !Empty(cFiltro)
			cFiltro	+= " .AND. "
		EndIf
		cFiltro += " (RCH->RCH_PER == '" + cPeriodo + "')"
	EndIf

	If !Empty(cProcesso)
		If !Empty(cFiltro)
			cFiltro	+= " .AND. "
		EndIf
		cFiltro	+= " (RCH->RCH_PROCES == '" + cProcesso + "')"
	EndIf

	If len(cRotFiltro)>0
		cFiltro	+= cRotFiltro
	EndIf

	If !Empty(cRot)
		If !Empty(cFiltro)
			cFiltro	+= " .AND. "
		EndIf

		cFiltro	+= " (RCH->RCH_ROTEIR == '" + cRot + "'"

		If lRotEmpty
			cFiltro	+= " .OR. RCH->RCH_ROTEIR == '" + Space(3) + "'"
		EndIf

		if(IsIntegracao())
			cFiltro	+= " .OR. RCH->RCH_ROTEIR == 'AUT'"
		endIf

		cFiltro += ")"
	Else
		if(IsIntegracao())
			If !Empty(cFiltro)
				cFiltro	+= " .AND. "
			EndIf
			cFiltro	+= " ((RCH->RCH_ROTEIR == 'AUT') .OR. (RCH->RCH_ROTEIR == '"  + FGETROTORDINAR() + "')) "
		endIf
	EndIf

	If !Empty(cModuloFlt)
		If !Empty(cFiltro)
			cFiltro	+= " .AND. "
		EndIf
		cFiltro	+= " (RCH->RCH_MODULO== '" + cModuloFlt + "')"
	EndIf
	cFiltro := "@#" + cFiltro + "@#"

Return ( cFiltro )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp090NrPagtoValid ³ Autor ³ Tatiane Matias        ³ Data ³31/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Valida o numero de pagamento informado 	                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
³Sintaxe   ³gp100NrPagtoValid()					    		                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RC_SEMANA                                         ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function GP090NrPagtoValid(cNrPag, cPrefixo)
	Local lRet			:= .T.
	Local cChkNrPagto	:= Getmv("MV_CATNPGT")
	Local cMatricula	:= ""
	Local cFilMat
	Local nPosMat
	Local nPosFil
	DEFAULT cPrefixo    := ( PrefixoCpo( "SRC" ) + "_" )

	lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)
	If IsInGetDados( { cPrefixo + "MAT" } )
		nPosMat 	:= GdFieldPos(cPrefixo + "MAT" )
		nPosFil 	:= GdFieldPos(cPrefixo + "FILIAL" )
		cMatricula 	:= If(lGp580Auto,aCols[n, nPosMat],oGet:aCols[n, nPosMat])
		cFilMat		:= If(lGp580Auto,aCols[n, nPosMat],oGet:aCols[n, nPosFil])
	Else
		cMatricula	:= SRA->RA_MAT
		cFilMat 	:= xFilial("SRA", SRA->RA_FILIAL)
	EndIf

	cCategoria 	:= gp240RetCont("SRA", 1, "RA_FILIAL = '" + cFilMat + "' AND RA_MAT = '" + cMatricula + "'", "RA_CATFUNC", ,.T.)

	If !Empty(cCategoria) .AND. !(cCategoria $ cChkNrPagto)
		If Type( "cNumPagto" ) = "U"
		    lRet := ExistCpo("RCH", cProcesso + cPeriodo + cNrPag + "        ", 3)
		Else
			// Se o campo de filtro numero de pagamento estiver preenchido, o
			// campo RC_SEMANA da GetDados devera ser o informado no filtro.
			// Se o campo de filtro numero de pagamento nao estiver preenchido, o
			// campo RC_SEMANA da GetDados podera ser qualquer numero de pagamento
			// da consulta padrao.
			If ( cNumPagto <> cNrPag )
				Help(" ",1,"GPA120NPGT")
				lRet := .F.
			Else
			    lRet := ExistCpo("RCH", cProcesso + cPeriodo + cNrPag + "        ", 3)
			EndIf
		EndIf
	EndIf
Return ( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GPEA090Locks    ³Autor³Tatiane Matias      ³ Data ³28/09/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Bloqueia Lancamentos                                         ³
³          ³(por Funcionario e Periodo)                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL		                                               	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³gp090MontaGetDados                                           ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GPEA090Locks( nOpc , cAlias , aRecnos )

	Local lLocks	:= .T.

	Begin Sequence

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se nao For Visualizacao				 					   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If ( nOpc == 3 )
			Break
		EndIf

		If !( lLocks := WhileNoLock( cAlias , aRecnos , { xFilial( cAlias ) + SRA->RA_MAT + cPeriodo} , 1 , 1 , .T. , NIL ) )
			Break
		EndIf

	End Sequence

Return( lLocks )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcFilialInit	³Autor³Marinaldo de jesus  ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_FILIAL					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_FILIAL                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_FILIAL                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcFilialInit()
	If Type("cLancAlias") == "U"
		cLancAlias := "SRC"
	EndIf

Return( xFilial( cLancAlias , SRA->RA_FILIAL ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcMatInit		³Autor³Marinaldo de jesus  ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_MAT					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_MAT		                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_MAT		                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcMatInit()

	Local cRcMatInit

	IF ( FunName() == "GPEA100" ) //Lancamentos por Verba
		cRcMatInit := Space( GetSx3Cache( "RC_MAT" , "X3_TAMANHO" ) )
	Else
		cRcMatInit := SRA->RA_MAT
	EndIF

Return( cRcMatInit )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcCcInit		³Autor³Marinaldo de jesus  ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_CC						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_CC		                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_CC		                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcCcInit()
Return( SRA->RA_CC )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcProcesInit	³Autor³Marinaldo de jesus  ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_PROCES					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_PROCES	                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_PROCES	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcProcesInit()
Return( SRA->RA_PROCES )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcPeriodoInit	³Autor³Marinaldo de jesus  ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_PERIODO				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_PERIODO	                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_PERIODO	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcPeriodoInit()

	Local cRcPeriodoInit

	IF ( GetRotExec() == "__cRotInExec" )
		cRcPeriodoInit := Space( GetSx3Cache( "RC_PERIODO" , "X3_TAMANHO" ) )
	Else
		cRcPeriodoInit := GetPeriodCalc()
	EndIF

Return( cRcPeriodoInit )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcRoteirInit	³Autor³Marinaldo de jesus  ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_ROTEIR				 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_ROTEIR	                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_ROTEIR	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcRoteirInit()

	Local cRcRoteirInit

	IF ( GetRotExec() == "__cRotInExec" )
		cRcRoteirInit := Space( GetSx3Cache( "RC_ROTEIR" , "X3_TAMANHO" ) )
	Else
		cRcRoteirInit := GetRotExec()
	EndIF

Return( cRcRoteirInit )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcTipo2Init		³Autor³Marinaldo de jesus  ³ Data ³18/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_TIPO2					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_TIPO2	                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_TIPO2	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcTipo2Init()
Return( GetTipo2( fGetTipoRot( RcRoteirInit() ) ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcPostoInit		³Autor³Marinaldo de jesus  ³ Data ³20/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_POSTO					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_POSTO							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_POSTO	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcPostoInit()

	Local cRcPostoInit

	IF ( GetRotExec() == "__cRotInExec" )
		cRcPostoInit := Space( GetSx3Cache( "RC_POSTO" , "X3_TAMANHO" ) )
	Else
		cRcPostoInit := SRA->RA_POSTO
	EndIF

Return( cRcPostoInit )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcDataInit		³Autor³Marinaldo de jesus  ³ Data ³22/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_DATA					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_DATA								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_DATA		                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcDataInit()

	Local aArea := RCH->( GetArea() )
	Local cRchIndexOrd
	Local cRchKeySeek
	Local cPeriod		:= GetPeriodCalc()
	Local cNumPag		:= GetNumPgCalc()
	Local cRotExec		:= GetRotExec()

	Local dRcDataInit

	Local nRchIndexOrd

	IF ( GetRotExec() == "__cRotInExec" )
		dRcDataInit := Ctod("//")
	Else
		If RCH->( RCH_PROCES + RCH_PER + RCH_NUMPAG + RCH_ROTEIR ) == ( SRA->RA_PROCES + cPeriod + cNumPag + cRotExec )
			dRcDataInit		:= RCH->RCH_DTPAGO
		Else
			If RCH->( RCH_PROCES + RCH_PER + RCH_NUMPAG + RCH_ROTEIR ) == ( SRA->RA_PROCES + cPeriod + cNumPag + Space( Len( cRotExec ) ) )
				dRcDataInit		:= RCH->RCH_DTPAGO
			Else
				cRchIndexOrd	:= "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR"
				cRchKeySeek		:= ( SRA->RA_PROCES + cPeriod + cNumPag + cRotExec )
				nRchIndexOrd	:= RetOrder( "RCH" , cRchIndexOrd )
				dRcDataInit		:= PosAlias( "RCH" , cRchKeySeek , SRA->RA_FILIAL , "RCH_DTPAGO" , nRchIndexOrd , .F. )
				IF Empty( dRcDataInit ) .and. ( RCH->( RCH_PROCES + RCH_PER + RCH_NUMPAG + RCH_ROTEIR ) != ( SRA->RA_PROCES + cPeriod + cNumPag + cRotExec ) )
					cRchKeySeek		:= ( SRA->RA_PROCES + cPeriod + cNumPag + Space( Len( cRotExec ) ) )
					dRcDataInit		:= PosAlias( "RCH" , cRchKeySeek , SRA->RA_FILIAL , "RCH_DTPAGO" , nRchIndexOrd , .F. )
				EndIF
			EndIF
		EndIF
		IF Empty( dRcDataInit )
			dRcDataInit := dDataBase
		EndIF
	EndIF

	RestArea( aArea )
Return( dRcDataInit )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcDtRefInit		³Autor³Marinaldo de jesus  ³ Data ³27/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_DATA					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_DATA								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_DATA		                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcDtRefInit()

	Local dRcDtRefInit

	dRcDtRefInit := gp090RetDtRef()
	IF Empty( dRcDtRefInit )
		dRcDtRefInit := RcDataInit()
	EndIF

Return( dRcDtRefInit )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcTipo1Init		³Autor³Marinaldo de jesus  ³ Data ³22/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_TIPO1					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_TIPO1							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_TIPO1	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcTipo1Init()
Return( "V" )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcTipo1Vld		³Autor³Marinaldo de jesus  ³ Data ³22/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valid para o Campo RC_TIPO1									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T. or .F.													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RC_TIPO1	                             	 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcTipo1Vld()
Return( Pertence("HVD") .And. GP090MOV(.T.)  )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcNumPgInit 	³Autor³Tatiane Matias      ³ Data ³10/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_SEMANA 				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo do Numero de Pagamento para o RC_SEMANA        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_SEMANA	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcNumPgInit()

	Local cRcNumPgInit

	IF ( GetRotExec() == "__cRotInExec" )
		cRcNumPgInit := Space( GetSx3Cache( "RC_SEMANA" , "X3_TAMANHO" ) )
	Else
		cRcNumPgInit := GetNumPgCalc()
	EndIF

Return( cRcNumPgInit )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao  ³Gp090MovimentaºAutor  ³Tatiane Matias      º Data ³  11/08/05   º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³ Executa bloco de codigo a cada movimentacao dos botoes de      º±±
±±º        ³ movimentacao.                                                  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ AP                                                             º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Gp090Movimenta( bFunc )

	Eval(bFunc)

Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao  ³fAtualRot	  ºAutor  ³Mauricio Takakura   º Data ³  25/10/05   º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³ Atualiza a variavel croteiro quando alterar o codigo do periodoº±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ AP                                                             º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fAtualRot()

	// Validar o Roteiro //
	If !Empty(RCH->RCH_ROTEIR) .OR. (Empty(RCH->RCH_ROTEIR) .AND. cRoteiro <> cRoteiroAnt)
		If cRoteiro <> RCH->RCH_ROTEIR
			If !Empty(RCH->RCH_ROTEIR)
				cRoteiro 	:= RCH->RCH_ROTEIR
			Else
				cRoteiro	:= fGetRotOrdinar()
			EndIf

			// Forcar a carga da getdados //
			cPeriodoAnt := ""
			cSemanaAnt	:= ""
		EndIf
	EndIf

Return( .T. )
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RcFuncInitºAutor  ³Silvia Taguti       º Data ³  07/19/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inicializador Padrao para o campo RC_CODFUNC                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RcFuncInit()

Return( SRA->RA_CODFUNC)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RcDeptoInitºAutor ³Silvia Taguti       º Data ³  03/04/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inicializador Padrao para o campo RC_DEPTO                  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function RcDeptoInit()

Return( SRA->RA_DEPTO )


/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ MenuDef		³Autor³  Luiz Gustavo     ³ Data ³03/01/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Isola opcoes de menu para que as opcoes da rotina possam    ³
³          ³ser lidas pelas bibliotecas Framework da Versao 9.12 .      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA090                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³aRotina														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

Static Function MenuDef()
	Local aRotina :=  {}

	aAdd( aRotina, { STR0004 , "PesqBrw"		, 0 , 1 } )	//"Pesquisar"
	aAdd( aRotina, { STR0005 , "Gpea090Mnt"		, 0 , 2 } ) //"Visualizar"
	If cPaisLoc <> "BRA"
		aAdd( aRotina, { STR0008 , "Gpea090Mnt"		, 0 , 5 } ) //"Excluir"
	EndIf
	aAdd( aRotina, { STR0020 , "GPER101(1)" 	, 0 , 6 } ) //"Imprimir"
	If cPaisLoc != "RUS"
		aAdd( aRotina, { STR0031 , "GpLegend"	, 0 , 6 , ,.F.}	) //"Legenda"
	EndIf
	If (FWIsInCallStack("GPEA090") .And. __lMemCalc) .Or. FWIsInCallStack("CFGA530")
		Aadd(aRotina, {OemToAnsi( STR0087 ), "GPEA091(1)",0,6}) //"Consultar Memória de Calculo"
		Aadd(aRotina, {OemToAnsi( STR0088 ), "GPER091()",0,6}) //"Relatório Memória de Calculo"
	EndIf
Return aRotina
/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp090RetDtRef ³ Autor ³ Tatiane Matias        ³ Data ³27/07/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³retorna data de referencia do periodo informado             	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
³Sintaxe   ³gp090RetDtRef(lDataIni)											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³lDataIni - indica se retorna o primeiro dia do periodo (.T.).   ³
³          ³        Se esse parametro nao for passado (NIL ou .F.) essa  	³
³          ³  		funcao ira retornar o ultimo dia do periodo informado.  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Data de referencia. Primeiro dia do periodo, se lDataIni = .T.  ³                                                          								   ³
³          ³ ou ultimo dia do periodo.                                   	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpea090LinOk                                                    ³
³          ³GPEA100                                                         ³
³          ³gp090MontaGetDados                                              ³
³          ³X3_RELACAO (SX3) do campo RC_DTREF                              ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function gp090GetRCA(pParam)
	Local aArea  := RCH->( GetArea() )
	Local nLimite:= 0

	// retorna Limite de Horas Dia ou Mes
	dbSelectArea("RCA")
	dbSetOrder(RetOrder("RCA","RCA_FILIAL+RCA_MNEMON") )
	dbSeek(xFilial("RCA")+pParam)

	nLimite := Alltrim(RCA->RCA_CONTEU)

	RestArea( aArea )
Return (nLimite)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RGBRUCEMP_WHEN³ Autor ³Leandro Drumond    ³ Data ³11/01/2012³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³When do campo RGB_RUCEMP 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RGBRUCEMP_WHEN()			                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function RGBRUCEMP_WHEN()

	Local aArea		:= GetArea()
	Local cRgbPd 	:= aCols[n,GdFieldPos("RGB_PD")]
	Local lRet 		:= .F.

	If !Empty(cRgbPd) .and. SRV->( dbSeek(xFilial("SRV")+cRgbPd,.F.) )
		If SRV->RV_CODFOL $ "1118|1187"
			lRet := .T.
		EndIf
	EndIf

	RestArea(aArea)

Return (lRet)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RBRucValid³ Autor ³Leandro Drumond        ³ Data ³11/01/2012³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Valid do campo RGB_RUCEMP									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RBRucValid()				                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function RGBRucValid()

	Local aArea		:= GetArea()
	Local cRgbPd 	:= aCols[n,GdFieldPos("RGB_PD")]
	Local cRucEmp	:= ""
	Local nPosRuc   := GdFieldPos("RGB_RUCEMP")
	Local lRet 		:= .T.

	If nPosRuc > 0
		cRucEmp := If (Type('M->RGB_RUCEMP') == "U", aCols[n,nPosRuc],M->RGB_RUCEMP)

		If Empty(cRucEmp) .and. SRV->( dbSeek(xFilial("SRV")+cRgbPd,.F.) )
			If SRV->RV_CODFOL $ "1118|1187"
				lRet := .F.
				If lGp580Auto
					AutoGrLog(OemtoAnsi(STR0060))
				Else
					MsgInfo( OemtoAnsi(STR0060) )  //"RUC do empregador deve ser informado para esta verba"
				EndIf
			EndIf
		EndIf
	EndIf

	RestArea(aArea)

Return (lRet)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gp090VldDel³ Autor ³Leandro Drumond       ³ Data ³03/04/2014³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Valid se verba pode ser deletada							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gp090VldDel()				                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function Gp090VldDel(cKeyRCH,nOpcx)

	Local aArea		:= GetArea()
	Local lAchou 	:= .T.
	Local lRet 		:= .T.
	Local nPosTipo2 := 0
	Local nPosOri	:= 0
	Local lBloqPON	:= ("1" $ SuperGetMv( "MV_BLOQPON",,"" ))
	Local nPosCC 	:= 0
	Local nPosItem 	:= 0
	Local nPosClvl 	:= 0
	Local nPosPd 	:= 0
	Local nPosSRC	:= 0
	Local cPd		:= ""
	Local cEol      := Chr(13) + Chr(10)
	Local lSRC		:= .F.
	Local nPosLOTPLS := 0 //Para controle dos registros que vieram do módulo SIGAPLS
	Local nPosCODRDA := 0 //Para controle dos registros que vieram do módulo SIGAPLS
	Local lIntPFS    := SuperGetMV("MV_JINTGPE", .F., "1") == "2" //Para controle dos registros que vieram do módulo SIGAPFS

	If cLancAlias == "RGB"

		lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)

		If !lGp580Auto
			aCols  := oGet:aCols
		EndIf

		nPosTipo2 	:= GdFieldPos("RGB_TIPO2")
		nPosOri   	:= GdFieldPos("RGB_ROTORI")
		nPosCC		:= GdFieldPos("RGB_CC")
		nPosItem 	:= GdFieldPos("RGB_ITEM")
		nPosClvl 	:= GdFieldPos("RGB_CLVL")
		nPosLOTPLS	:= GdFieldPos("RGB_LOTPLS")
		nPosCODRDA	:= GdFieldPos("RGB_CODRDA")

		If FunName() == "GPEA590"
			cPd		:= cCod	// Código da verba posicionada.
		ElseIf nOpcx # 5
			nPosPd 	:= GdFieldPos("RGB_PD")
			cPd		:= aCols[n,nPosPd]
		EndIf

		If (nOpcx == 5)

			If aScan( aCols, { |x| x[nPosTipo2] == "F" } ) > 0
				MsgInfo( OemtoAnsi(STR0083) ) // "Há uma ou mais verbas provenientes do periodo anterior que não podem ser excluídas. A exclusão não sera realizada."
				lRet := .F.
			Else
				/* 	Bloqueia exclusão de verbas vindas do SIGAPON	*/
				If lBloqPON .And. aScan( aCols, { |x| x[nPosTipo2] == "E" } ) > 0
					lRet := .F.
					If lGp580Auto
						AutoGrLog(OemtoAnsi(STR0066))
					Else
						MsgInfo( OemtoAnsi(STR0066) )  //"As verbas vindas do SIGAPON estão bloqueadas para exclusão! Contate o responsavel do RH!"
					EndIf
				EndIf

				If lRet .And. nModAuto != 2
					If aScan( aCols, { |x| (!Empty( x[nPosOri] ) .AND. x[nPosTipo2] <> "E" ) .Or. x[nPosTipo2] == "A" } ) > 0
						MsgInfo( OemToAnsi( STR0080 ) ) 	//Esta verba foi gerada através da rotina de integração. Para estas verbas é necessário utilizar o Cancelamento de Integração, na rotina de Integração.
						lRet := .F.
					EndIf
				EndIf

				If lRet
					If ( nPosSRC := aScan( aCols, { |x| x[nPosTipo2] == "I" } ) ) > 0

						If !lItemClVl
							SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)" ) ) )
							lSRC := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[nPosSRC,nPosCC] ) )
						Else
							SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)" ) ) )
							lSRC := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[nPosSRC,nPosCC] + aCols[nPosSRC,nPosItem] + aCols[nPosSRC,nPosClvl] ) )
						EndIf

						If lSRC
							If (MsgYesNo( OemToAnsi(STR0074) + cEol+cEol+;  //"Esta verba é do tipo Informado.Se apagá-la, o cálculo também será apagado por motivos de integridade. Deseja continuar?
										OemToAnsi(STR0078))) 				//"Para recalcular os lançamentos use a tecla F6 (Calcular)."
								lRet		:= .T.
								lDelCalc	:= .T.
							Else
								lRet := .F.
							EndIf
						EndIf
					EndIf
				EndIf

				If lRet .And. ( nPosSRC := aScan( aCols, { |x| !( x[nPosTipo2] == "I" ) } ) ) > 0
					If !lItemClVl
						SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)" ) ) )
						lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[nPosSRC,nPosCC] ) )
					Else
						SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)" ) ) )
						lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[nPosSRC,nPosCC] + aCols[nPosSRC,nPosItem] + aCols[nPosSRC,nPosClvl] ) )
					EndIf

					If lAchou
						Help(" ", 1, OemToAnsi(STR0040), Nil, OemToAnsi(STR0068), 1, 0 )//"Atenção"##"Exclusão não permitida pois a verba foi encontrada na tabela SRC"
						lRet := .F.
					EndIf
				EndIf
			EndIf

			If nPosLOTPLS > 0 .AND. nPosCODRDA > 0 .AND. aScan( aCols, { |x| !(empTy(x[nPosLOTPLS])) } ) > 0 .And. nModulo <> 77
				If lIntPFS // Integração conta corrente participante SIGAPFS com SIGAGPE pois é utilizado o mesmo campo do lote do PLS (RGB_LOTPLS)
					MsgInfo(STR0120) //"Não é possível prosseguir a exclusão, pois há pelo menos um lançamento com origem no módulo SIGAPFS."
				Else
					MsgInfo(STR0113) //"Não é possível prosseguir a exclusão, pois há pelo menos um lançamento com origem no módulo SIGAPLS."
				EndIf
				lRet := .F.
			EndIf
		Else
			If aCols[n,nPosTipo2] == "F"
				MsgInfo( OemtoAnsi(STR0083) ) // "Há uma ou mais verbas provenientes do periodo anterior que não podem ser excluídas. A exclusão não sera realizada."
				lRet := .F.
			Else
				/* 	Bloqueia exclusão de verbas vindas do SIGAPON	*/
				If lBloqPON .And. Upper(aCols[n,nPosTipo2]) == "E"
					lRet := .F.
					If lGp580Auto
						AutoGrLog(OemtoAnsi(STR0066))
					Else
						MsgInfo( OemtoAnsi(STR0066) )  //"As verbas vindas do SIGAPON estão bloqueadas para exclusão! Contate o responsavel do RH!"
					EndIf
				EndIf

				If lRet
					If ((!Empty( aCols[n,nPosOri] ) .AND. aCols[n,nPosTipo2] <> "E" ) .Or. aCols[n,nPosTipo2] == "A") .And. (aCols[n,nPosTipo2] != "I" .And. aCols[n,nPosOri] == "PON")
						MsgInfo( OemToAnsi( STR0080 ) ) 	//Esta verba foi gerada através da rotina de integração. Para estas verbas é necessário utilizar o Cancelamento de Integração, na rotina de Integração.
						lRet := .F.
					EndIf
				EndIf

				If lRet
					If !Empty(aCols[n,nPosOri]) .Or. aCols[n,nPosTipo2] == "I"

						If !lItemClVl
							SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)" ) ) )
							lSRC := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[n,nPosCC] ) )
						Else
							SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)" ) ) )
							lSRC := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[n,nPosCC] + aCols[n,nPosItem] + aCols[n,nPosClvl] ) )
						EndIf

						If lSRC
							If (MsgYesNo( OemToAnsi(STR0074) + cEol+cEol+;  //"Esta verba é do tipo Informado.Se apagá-la, o cálculo também será apagado por motivos de integridade. Deseja continuar?
										OemToAnsi(STR0078))) 				//"Para recalcular os lançamentos use a tecla F6 (Calcular)."
								lRet		:= .T.
								lDelCalc	:= .T.
							Else
								lRet := .F.
							EndIf
						EndIf
					EndIf
				EndIf

				If lRet .And. !GdDeleted() .And. !(aCols[n,nPosTipo2] == "I")
					If !lItemClVl
						SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)" ) ) )
						lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[n,nPosCC] ) )
					Else
						SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)" ) ) )
						lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[n,nPosCC] + aCols[n,nPosItem] + aCols[n,nPosClvl] ) )
					EndIf

					If lAchou
						Help(" ", 1, OemToAnsi(STR0040), Nil, OemToAnsi(STR0068), 1, 0 )//"Atenção"##"Exclusão não permitida pois a verba foi encontrada na tabela SRC"
						lRet := .F.
					EndIf
				EndIf
			EndIf

			If nPosLOTPLS > 0 .AND. nPosCODRDA > 0 .AND. !(EmpTy(aCols[n,nPosLOTPLS])) .AND. ( !(EmpTy(aCols[n,nPosCODRDA])) .OR. lIntPFS ) .And. nModulo <> 77
				lRet := .F.
				If lIntPFS
					MsgInfo(STR0114 + aCols[n,nPosLOTPLS] + STR0119) //"O registro não pode ser excluído, pois sua origem é um lote de pagamento [ " ### " ] do módulo SIGAPFS."
				Else
					MsgInfo(STR0114 + aCols[n,nPosLOTPLS] + STR0112) //"O registro não pode ser excluído, pois sua origem é um lote de pagamento [ " ### " ] do módulo SIGAPLS."

				EndIf
			EndIf
		EndIf
	EndIf

	RestArea(aArea)

Return lRet

/*/{Protheus.doc} fCalcLanc
Efetua o cálculo da Folha para o funcionario em edicao.

@author Esther de Viveiro
@since 22/10/2014
@version P12

@param cFil, caractere, Filial do funcionario
@param cMat, caractere, Matricula do funcionario

@return nulo
/*/
Static Function fCalcLanc(cFil, cMat)
	Local aArea		:= GetArea()
	Local cFiltraWF	:= ""
	Local cFilAux	:= ''
	Local aSRCCols	:= {}
	Local aPerAtual := {}
	Local nRecno	:= SRA->(Recno())

	Private lGestPubl	:= fUsaGFP()	 //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

	DEFAULT lFuncRst	:= FindFunction("RstaPerAtu")

	aSRCCols := oGet:aCols

	If !ArrayCompare( aSRCCols , aColsAnt ) //se houve alteracoes
		If !(MsgNoYes ( (STR0063), (STR0040)))
				//As alteracoes nao foram salvas e nao serao consideradas para o calculo. Deseja continuar mesmo assim?
			Return //cancela calculo
		EndIf
	EndIf

	cFiltraWF := "RA_FILIAL == '" + cFil + "' .AND. RA_MAT == '" + cMat + "'"

	If Empty(cRoteiro) .or. fGetTipoRot(cRoteiro) $ "3/4/G/J"
		MsgInfo( OemtoAnsi(STR0072) )  //"Cálculo não disponível para este roteiro."
		Return Nil
	EndIf

	If lFuncRst
		RstaPerAtu()
	EndIf

	If !fGetPerAtual( @aPerAtual, , cProcesso, cRoteiro ) .or. aPerAtual[1,1] <> cPeriodo
		MsgInfo( OemtoAnsi(STR0073) )  //"Período selecionado não corresponde ao período ativo de cálculo."
		Return Nil
	EndIf


	cFilAux:= dbFilter()
	SRA->(DBClearFilter())

	Gpem020(.T.,;			//Define Que a Chamada Esta Sendo Efetuada Atraves do WorkFlow
			cProcesso,;	//Define o processo que sera calculado
			cRoteiro,;	//Define o roteiro que sera calculado
			cFiltraWF;	//Filtro executado na rotina
			)

	If !IsInCallStack("MOSTRAERRO")
		MostraErro() //Mostra Log do Calculo
	EndIf

	Set Filter To &cFilAux

	SRA->(dbGoto(nRecno))
	RstExecCalc() //Restaurar as Static apos o calculo
	RestArea(aArea)
Return (Nil)


/*/{Protheus.doc} ChamaRGB
	Faz chamada de Inclusão/Alteração e Exclusão da tabela RGB
@author philipe.pompeu
@since 09/04/2015
@version P12
@param nOpcao, numérico, Opção à ser chamada
@return Nil, Valor Nulo
/*/
Static Function ChamaRGB(nOpcao)
	Local aArea	:= RGB->( GetArea() )
	Local cValAnt	:= "SRC"

	if(Type("cLancAlias") == "U")
		Private cLancAlias:="RGB"
	Else
		cValAnt := cLancAlias
		cLancAlias:="RGB"
	endIf

	Gpea090Mnt( cLancAlias , 0 , nOpcao)

	cLancAlias:=cValAnt

	RestArea(aArea)
Return Nil


/*/{Protheus.doc} IsIntegracao
Verifica se algum do fonte de Integração estão na Pilha de chamada
@author PHILIPE.POMPEU
@since 29/06/2015
@version P12
@return lReturn, verdadeiro se encontrado
/*/

Static Function IsIntegracao()
	Local lResult := (IsInCallStack("GPEM009") .Or. IsInCallStack("GPEM015") .Or. IsInCallStack("GPEM015A"))
Return lResult

/*/{Protheus.doc} IntegDef
	Rotina responsável pela Mensagem Única da Rotina GPEA090
@author PHILIPE.POMPEU
@since 14/04/2015
@version P12
@param cXML, character, o XML em forma de string
@param nTypeTrans, numérico, Tipo de Transmissão
@param cTypeMessage, character, Tipo da Mensagem
@param cVerMsg, character, Versão da Mensagem
@return aRet, Vetor
/*/

Static Function IntegDef( cXML, nTypeTrans, cTypeMessage,cVerMsg)
	Local aRet := {}
	Default cVerMsg := "1.000"
	aRet:= GPEI090( cXML, nTypeTrans, cTypeMessage, cVerMsg)
Return aRet


/*/{Protheus.doc} Gp090Src()
	Realiza a exclusao do calculo na tabela SRC para quando
	for deletada uma verba do tipo Informada.
@author raquel.andrade
@since 23/06/2016
@version P12.1.7
/*/
Static Function Gp090Src()

	Local aArea    := GetArea()
	Local cQuery
	Local cNameDB
	Local cDelet
	Local cSqlName := InitSqlName( "SRC" )

	//O banco DB2 nao aceita o nome da tabela apos o comando DELETE
	cNameDB	:= Upper(TcGetDb())

	cQuery := "DELETE "

	cDelet := "SRC.D_E_L_E_T_ = ' ' "

	If ( cNameDB $ "INFORMIX" )
		cDelet	:= cSqlName +  ".D_E_L_E_T_ = ' ' "
	EndIf

	If !( cNameDB $ "DB2_ORACLE_INFORMIX_POSTGRES" )
		cQuery += cSqlName
	EndIf

	//O Informix precisa do nome da tabela ao inves do Alias no comando DELETE
	If ( cNameDB $ "INFORMIX" )
		cQuery += " FROM " + cSqlName
	Else
		cQuery += " FROM " + cSqlName + " SRC"
		cSqlName := "SRC"
	EndIf

	cQuery += " WHERE " + cSqlName + ".RC_FILIAL = '" + SRA->RA_FILIAL + "'"
	cQuery += " AND " + cSqlName + ".RC_MAT = '" + SRA->RA_MAT + "'"
	cQuery += " AND " + cSqlName + ".RC_PROCES = '" + cProcesso + "'"
	cQuery += " AND " + cSqlName + ".RC_ROTEIR = '" + cRoteiro + "'"
	cQuery += " AND " + cSqlName + ".RC_PERIODO = '" + cPeriodo + "'"
	cQuery += " AND " + cSqlName + ".RC_SEMANA = '" + cNumPagto + "'"

	cQuery += " AND " + cDelet

	TcSqlExec( cQuery )
	RestArea( aArea )
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGetRotRes  ºAutor  ³Alfredo Medrano   º Data ³  16/06/2015 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna el Procedimiento de calculo Finiquito / Recisión   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEA090                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fGetRotRes(lTransfEmp )
	Local aArea 			:= GetArea()
	Local cRotRes			:= ""
	Local cAliasSRY		:= "SRY"

	DbSelectArea( "SRY" )


	(cAliasSRY)->( DbGoTop() )
	While (cAliasSRY)->( !Eof() )
		If (cAliasSRY)->RY_TIPO == "4"
			cRotRes := (cAliasSRY)->RY_CALCULO
			Exit
		EndIf
		(cAliasSRY)->( DbSkip() )
	EndDo
	RestArea( aArea )

Return( cRotRes )


Static Function addVirtCpo(aHeader,aCols,aVirtual,cPrefixo,aGhCols)
	Local aAreas := {SX3->(GetArea()),SRV->(GetArea())}
	Local nPosGhost := 0
	Local nPosDesc := 0
	Local aCampos := {'RV_INSS','RV_FGTS','RV_IR','RV_INCORP'}
	Local nI := 0
	Local nX := 0
	Local nJ := 0
	Local nT := 0
	Local cCpNome 	:= ''
	Local nCount 	:= 0
	Local lGhCols	:= Len(aGhCols) > 0
	nPosGhost := GdFieldPos("GHOSTCOL", aHeader)
	if(nPosGhost > 0)
		nPosDesc	:= GdFieldPos( cPrefixo + "DESCPD"	, aHeader)
		nPosPd		:= GdFieldPos( cPrefixo + "PD"		, aHeader )
		SRV->(dbSetOrder(1))
		SX3->(dbSetOrder(2))
		for nI:= 1 to Len(aCampos)
			cCpNome := cPrefixo + SubStr( aCampos[nI], At('_',aCampos[nI])+ 1)

			if(GdFieldPos(cCpNome, aHeader) == 0)
				if(SX3->(dbSeek(aCampos[nI])))
					nCount++
					aSize(aHeader,Len(aHeader) + 1)
					nX := nPosGhost + (nCount - 1)
					aIns(aHeader, nX)
					aHeader[nX] := aClone(aHeader[nPosDesc])
					aHeader[nX,1] := AllTrim(SX3->X3_TITULO)
					aHeader[nX,2] := cCpNome
					aHeader[nX,3] := AllTrim(SX3->X3_PICTURE)
					aHeader[nX,4] := SX3->X3_TAMANHO
					aHeader[nX,5] := SX3->X3_DECIMAL
					aHeader[nX,6] := ""
					aHeader[nX,8] := SX3->X3_TIPO
					aHeader[nX,9] := SX3->X3_ARQUIVO
					aHeader[nX,11]:= SX3->X3_CBOX
					aHeader[nX,17]:= .F.

					for nJ:= 1 to Len(aCols)
						If lGhCols
							For nT := 1 to Len(aGhCols)
								aSize(aGhCols[nT],Len(aGhCols[nT]) + 1)
								aIns(aGhCols[nT], nX)
								aGhCols[nT,nX] := ""
								If(Left(aCampos[nI],2) == 'RV')
									If(SRV->(dbSeek(xFilial('SRV')+ aGhCols[nT ,nPosPd])))
										aGhCols[nT,nX]	:= SRV->(&(aCampos[nI]))
									EndIf
								EndIf
							Next nT
						EndIf
						aSize(aCols[nJ],Len(aCols[nJ]) + 1)
						aIns(aCols[nJ], nX)
						aCols[nJ,nX] := ""
						If(Left(aCampos[nI],2) == 'RV')
							If(SRV->(dbSeek(xFilial('SRV')+ aCols[nJ ,nPosPd])))
								If Empty(AllTrim(SRV->(&(aCampos[nI]))))
									aCols[nJ,nX] := "N"
								Else
									aCols[nJ,nX] := SRV->(&(aCampos[nI]))
								EndIf
							EndIf
						EndIf
					next nJ

					aAdd(aVirtual,cCpNome)
				endIf
			endIf
		next nI
	endIf
	aEval(aAreas,{|x|RestArea(x)})
Return Nil
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGP90MultV      ºAutor  ³Equipe RH        º Data ³ 15/10/13 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que avalia se existe no FOLMES em uso, lancamento de º±±
±±º          ³Multiplos Vinculos.                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cTipo:	'A'-avaliar se tem multiplos vinculos             º±±
±±º          ³       	'V'-avaliar e visualizar multiplos vinculos       º±±
±±º          ³ cOrigem:	'1'-Origem Lancamentos Mensais                    º±±
±±º          ³ 			'2'-Lancamentos 13 salario                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEA090 - Acoes relacionas "Multiplos Vinculos"            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fGP90MultV(cTipo,cOrigem)
	Local aArea			:= GetArea()
	Local aRet       	:= {}
	Local lRet			:= .F.
	Local oModel
	Local cAliasRAW		:= "RAW"
	Local cRawFOLMES	:= IIF(cPeriodo==nil, RGB->RGB_PERIOD,cPeriodo)

	DEFAULT cTipo	:= 'A' //A - de Averigua se existe Multiplo Vinculos
	DEFAULT cOrigem	:= '1' //1-Origem Lancamentos Mensais - 2-Lancamentos 13 salario

	If cTipo # 'A'
		oModel     	:= FWLoadModel( "GPEA924")
	EndIf

	dbSelectArea("RAW")
	(cAliasRAW)->(dbSetOrder(1))

	If (cAliasRAW)->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cRawFOLMES) )
		If cTipo $ 'A'
			lRet:= .T.
		Else
			oModel:SetOperation( MODEL_OPERATION_VIEW )
			oModel:Activate()
			FWExecView(OemtoAnsi(STR0030), "GPEA924", MODEL_OPERATION_VIEW,,{||.T.}) 	//"Multiplos Vinculos"
		EndIf
	EndIf

	RestArea(aArea)
Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGP90ExcMV      ºAutor  ³Equipe RH        º Data ³ 24/09/13 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que avalia se existe no FOLMES em uso, lancamento de º±±
±±º          ³Multiplos Vinculos.                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cOrigem:	'1'-Origem Lancamentos Mensais                    º±±
±±º          ³ 			'2'-Lancamentos 13 salario                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEA090 - Acoes relacionas "Multiplos Vinculos"            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fGP90ExcMV(cOrigem)
	Local aArea			:= GetArea()
	Local oModel     	:= FWLoadModel( "GPEA924")
	Local aRet       	:= {}
	Local lRet			:= .F.
	Local cAliasRAW		:= "RAW"
	Local cRawFOLMES	:= cPeriodo

	DEFAULT cOrigem		:= '1'

	dbSelectArea("RAW")
	(cAliasRAW)->(dbSetOrder(1))

	If (cAliasRAW)->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cRawFOLMES+cOrigem) )

		oModel:SetOperation( MODEL_OPERATION_DELETE )
		oModel:Activate()
		If ( lRet := oModel:VldData() )
			lRet := oModel:CommitData()
		EndIf

		If !lRet
			// Se os dados não foram validados obtemos a descrição do erro para gerar LOG ou mensagem de aviso
			aRet   := oModel:GetErrorMessage()
			HELP(2,aRet[5],aRet[6],aRet[7])
		EndIf

		// Desativamos o Model
		oModel:DeActivate()
	EndIf

	RestArea(aArea)
Return lRet

/*/{Protheus.doc} PLSxGPEVLD
Verifica se algum campo de um determinado lançamento teve alteração, caso algum tenha, retorna .F.
para a validação da Linha na verificação de alteração de registro gravado pelo SIGAPLS
@type Static function
@author Oscar Zanin
@since 08/05/2019
@version 1.0
/*/
Static Function PLSxGPEVLD(aColsZ, aColsAntZ)

	Local lRet	:= .T.
	Local nI	:= 0

	Default aColsZ 		:= {}
	Default aColsAntZ	:= {}

	For nI := 1 To Len(aColsZ)
		If aColsZ[nI] <> aColsAntZ[nI]
			lRet := .F.
			Exit
		EndIf
	Next

Return lRet

/*/{Protheus.doc} fMedHist
Geração relatório de médias
@author Flavio Correa
@since 31/10/19
@version 1.0
/*/
Static Function fMedHist()
	Local lTemTransf := .F.
	Local lverSV	 := FindFunction("fConfigSV")

	If fTemHMed(cDataIni, Nil, cPeriodo, cNumPagto, cRoteiro, @lTemTransf)

		If lverSV .And. fConfigSV()
			IF !fCallMediaSV(IIf(cRoteiro $ "131*132", "D", IIF(cRoteiro == "FOL", "O", "5")), cDataIni,, lTemTransf)
				fVerHistMed("", cDataIni, lTemTransf)
			EndIf
		Else
			fVerHistMed("", cDataIni, lTemTransf)
		EndIf	
	Else
		Aviso(STR0040,STR0118) //Atenção##"Sem dados para imprimir!"
	EndIf

Return

/*/{Protheus.doc} fAjustAcols
	Se o RGB_NUMID já existir nos lancamentos sera tratado como Alteração
	@type  Function
	@author Emerson Grassi Rocha
	@since 16/10/2020
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function fAjustAcols(aSRCCols)
	Local nPosRecRgb 	:= GdFieldPos("RGB_REC_WT")
	Local nPosPd		:= GdFieldPos("RGB_PD")
	Local nPosNumId		:= GdFieldPos("RGB_NUMID")
	Local nPosSeq		:= GdFieldPos("RGB_SEQ")
	Local nSRCCols 		:= 0
	Local nColsAnt		:= Len(aColsAnt)
	Local nColsSRC		:= Len(aSRCCols)
	Local nx
	Local cChave
	Local nPos

	// Verificar se a rotina relacionou indevidamente um registro diferente já gravado
	For nx := 1 To nColsAnt
		If nX <= nColsSRC .And.;
			aSRCCols[nx][nPosRecRgb] = aColsAnt[nx][nPosRecRgb] .And.;
			aSRCCols[nx][nPosNumId] <> aColsAnt[nx][nPosNumId]

			Aadd(aSRCCols, Aclone(aSRCCols[nx]))
			aSRCCols[Len(aSRCCols)][nPosRecRgb] := 0
			aSRCCols[Len(aSRCCols)][nPosSeq] := Str(Val(aColsAnt[nx][nPosSeq]) + 1, 1,0)
			aSRCCols[nx]:= Aclone(aColsAnt[nx])
		EndIf
	Next nx

	// Verificar se passou alteração de um contrato já gravado
	nSRCCols := Len(aSRCCols)
	For nx := 1 To nSRCCols
		If aSRCCols[nx][nPosRecRgb] = 0
			cChave := aSRCCols[nx][nPosPd]+aSRCCols[nx][nPosNumId]

			nPos := Ascan(aSRCCols, {|x| ( x[nPosPd]+x[nPosNumId] == cChave .and. x[nPosRecRgb] != 0) })

			If nPos > 0
				aSRCCols[nPos] := aClone(aSRCCols[nx])
				aSRCCols[nx][nPosNumId] := ""
				aSRCCols[nx][nPosRecRgb] := 9999999999
			EndIf
		EndIf
	Next nx

	Do While ( nPos := Ascan(aSRCCols,{|x| x[nPosRecRgb]==9999999999}) ) > 0
		ADel(aSRCCols,nPos)
		Asize(aSRCCols,--nSRCCols)
	EndDo

Return

/*/{Protheus.doc} Gp090VldRot
Valida roteiro selecionado
@author Leandro Drumond
@since 21/12/23
@version 1.0
/*/
Static Function Gp090VldRot(cRoteiro)
	Local aArea 	:= SRY->(GetArea())
	Local lRet 		:= .T.

	SRY->(DbSetOrder(1))

	If SRY->(DbSeek(xFilial("SRY") + cRoteiro))

		If SRY->RY_TIPO $ ('8*C*D*E*G*I*J') //VTR, PLA, VRF, VAL, INC, BEN, MUV
			Help(,, OemToAnsi(STR0040),, + CRLF + OemToAnsi(STR0127) , 1, 0,,,,,, { + CRLF + OemToAnsi(STR0128)})//"Atencao" ## "Roteiro indisponível para lançamento de verbas"  ### "Selecione um roteiro válido"
			lRet := .F.
		EndIf
	EndIf

	RestArea(aArea)

Return lRet

/*/{Protheus.doc} fSetVK
Controle das teclas de cálculo e consulta
@author Bruno Costa
@since 18/02/2025
@version 1.0
/*/
Static Function fSetVK(btnF6, btnF7)

DEFAULT btnF6 := {||Nil}
DEFAULT btnF7 := {||Nil}

SetKey(VK_F6, btnF6)
SetKey(VK_F7, btnF7)

Return 

/*/{Protheus.doc} ValidaPlaIR
Valida se a verba pertence a desconto Plano de Saude
@author Silvia Taguti
@since 28/02/2025
@version 1.0
/*/
Function  ValidaPlaIR( lExiMsgPl,cVerbaPla )

Local nOp			:= 0
Local aOp 			:= {STR0134, STR0135,STR0137} // Confirmar, Abrir Tdn, Cancelar
Local nLinOkPl      := .T.
Default lExiMsgPl 	:= .T.
Default cVerbaPla	:= ""

	If (RetValSrv( cVerbaPla, SRA->RA_FILIAL, 'RV_INCIRF', 1 ) == "67" .Or. RetValSrv( cVerbaPla, SRA->RA_FILIAL, 'RV_NATUREZ', 1 ) == '9219')
	
		//"ATENÇÃO: Para que as informações de Plano de Saúde sejam enviadas corretamente para o eSocial, é necessária a utilização das rotinas de Plano de Saúde para realização dos cálculos. O lançamento manual de verbas de desconto do Plano de Saúde direto na folha de pagamento fará com que o envio do do evento S-1210 seja bloqueado. "
		//"Para correta utilização da rotina de Plano de Saúde, consulte o tópico Cadastro e cálculo de assistência médica e odontológica da documentação abaixo: "
		If lExiMsgPl
			nOp := Aviso(STR0136, STR0129+CRLF+STR0130+CRLF+STR0131, aOp)//Rotina só deve ser utilizada quando parâmetro MV_MID estiver habiltado, pesquise Middleware na página centralizadora de Entregas Legais para maiores informações
			If nOp == 2
				shellExecute("Open","https://tdn.totvs.com/pages/viewpage.action?pageId=904043923", "", "", 1)
			ElseIf nOp == 1   //Confirmar 
				lExiMsgPl := .F.
			ElseIf nOp == 3   //Cancelar 
				nLinOkPl := .F.
			EndIf
		Endif
	Endif	
Return nLinOkPl

/*/{Protheus.doc} GP090VlVac
	Función para validar el concepto
	@type  Function
	@author oscar.lopez
	@since 02/09/2025
	@version 1.0
	@param cFilEmp, caracter, Sucursal de empleado
	@param cMatEmp, caracter, Matrícula de empleado
	@param cProceso, caracter, Proceso del empleado
	@param cPeriodo, caracter, Codigo de periodo
	@param cNumPago, caracter, Semana de pago
	@param cCodCon, caracter, Cófigo de concepto
	@param nHrsVal, número, Horas capturadas
	@return lRet, lógico, Si total días no supera limite entonces .T., de lo contrario .F.
	@example
		GP090VlVac(cFilEmp, cMatEmp, cProceso, cPeriodo, cNumPago, cCodCon, nHrsVal)
	/*/
Function GP090VlVac(cFilEmp, cMatEmp, cProceso, cPeriodo, cNumPago, cCodCon, nHrsVal)

	Local aArea		:= GetArea()
	Local lRet		:= .T.
	Local nCtdDiasCo:= 0
	Local cCodFol	:= ""

	Default cProceso:= ""
	Default cPeriodo:= ""
	Default cNumPago:= ""
	Default cMatEmp	:= ""
	Default cCodCon	:= ""
	Default nHrsVal	:= 0

	cCodFol := PosSRV(cCodCon, cFilEmp, "RV_CODFOL" ) // Id de Cálculo

	If cCodFol == "0074"

		nCtdDiasCo := CtdDiasCom(cProceso, cPeriodo, cNumPago, cMatEmp, cCodCon)

		If (nHrsVal + nCtdDiasCo) > 15
			MsgInfo(STR0138, STR0136) // "Se superó el numero de días permitidos para los días comprados del año." # "Atención"
			lRet := .F.
		Else
			nDiasDer := CtdDiasDer(cMatEmp)
			If nHrsVal > nDiasDer
				MsgInfo(STR0139, STR0136) // "Se superó el número de días disponibles en días derecho." # "Atención"
				lRet := .F.
			EndIf
		EndIf	

	EndIf

	FWRestArea(aArea)

Return lRet

/*/{Protheus.doc} CtdDiasCom
	Obtiene la cantidad de vacaciones compradas para el empleado en periodos del mismo año que
	se está incluyendo.
	@type  Static Function
	@author oscar.lopez
	@since 05/09/2025
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
		nDias := CtdDiasCom(cProceso, cPeriodo, cNumPago, cMatEmp, cCodCon)
/*/
Static Function CtdDiasCom(cProceso, cPeriodo, cNumPago, cMatEmp, cCodCon)
	Local aArea		:= GetArea()
	Local nRet		:= 0
	Local cQuery	:= ""
	Local cAliasVac	:= ""
	Local cFilRCH	:= FWxFilial("RCH")
	Local cFilSRD	:= FWxFilial("SRD")
	Local cAnio		:= ""
	Local nParVacCom:= 1
	Local oQryVacCom:= Nil

	Default cProceso:= ""
	Default cPeriodo:= ""
	Default cNumPago:= ""
	Default cMatEmp	:= ""
	Default cCodCon	:= ""

	cAnio	:= Posicione("RCH",1,cFilRCH+cProceso+cPeriodo+cNumPago,"RCH_ANO") // RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR

	cQuery := " SELECT SRD.RD_FILIAL, SRD.RD_MAT, SRD.RD_PD, SUM(SRD.RD_HORAS) TOTDIAS"
	cQuery += " FROM ? SRD"
	cQuery += " INNER JOIN"
	cQuery += " ? RCH"
	cQuery += " ON SRD.RD_PROCES = RCH.RCH_PROCES"
	cQuery += " AND SRD.RD_PERIODO = RCH.RCH_PER"
	cQuery += " AND SRD.RD_SEMANA = RCH.RCH_NUMPAG"
	cQuery += " WHERE"
	cQuery += " SRD.RD_FILIAL = ?"
	cQuery += " AND SRD.RD_MAT = ?"
	cQuery += " AND SRD.RD_PROCES = ?"
	cQuery += " AND SRD.RD_PD = ?"
	cQuery += " AND RCH.RCH_ANO = ?"
	cQuery += " AND NOT (RCH.RCH_PER = ? AND RCH.RCH_NUMPAG = ?)" //Se deprecia por query por que se validará desde objeto
	cQuery += " AND SRD.D_E_L_E_T_ = ?"
	cQuery += " AND RCH.D_E_L_E_T_ = ?"
	cQuery += " GROUP BY SRD.RD_FILIAL, SRD.RD_MAT, SRD.RD_PD"

	oQryVacCom := FwExecStatement():New(cQuery)

	oQryVacCom:SetUnsafe(nParVacCom++, RetSqlName("SRD")	)
	oQryVacCom:SetUnsafe(nParVacCom++, RetSqlName("RCH")	)
	oQryVacCom:SetString(nParVacCom++, cFilSRD				) // Sucursal SRD
	oQryVacCom:SetString(nParVacCom++, cMatEmp				) // Matrícula
	oQryVacCom:SetString(nParVacCom++, cProceso				) // Proceso
	oQryVacCom:SetString(nParVacCom++, cCodCon				) // Código de Concepto
	oQryVacCom:SetString(nParVacCom++, cAnio				) // Año pago
	oQryVacCom:SetString(nParVacCom++, cPeriodo				) // Periodo que se está capturando
	oQryVacCom:SetString(nParVacCom++, cNumPago				) // Numero de pago que se está capturando
	oQryVacCom:SetString(nParVacCom++, " "					) // SRD.D_E_L_E_T_
	oQryVacCom:SetString(nParVacCom++, " "					) // RCH.D_E_L_E_T_

	cAliasVac := oQryVacCom:OpenAlias()
	(cAliasVac)->(DbGoTop())

	While (cAliasVac)->(!EoF())
		nRet += (cAliasVac)->(TOTDIAS)
		(cAliasVac)->(DbSKip())
	EndDo
	(cAliasVac)->(dbCloseArea())

	FWFreeObj(oQryVacCom)
	FWRestArea(aArea)

Return nRet

/*/{Protheus.doc} CtdDiasDer
	Otiene la cantidad de días derecho con los que cuenta el empleado en periodos activos.
	@type  Static Function
	@author oscar.lopez
	@since 05/09/2025
	@version 1.0
	@param cMatEmp, caracter, Matrícula empleado
	@return nRet, número, Días derecho con los que cuenta el empleado
	@example
		nDias := CtdDiasDer(cMatEmp)
/*/
Static Function CtdDiasDer(cMatEmp)

	Local aArea		:= GetArea()
	Local nRet		:= 0
	Local cQuery	:= ""
	Local cAliasSRF	:= ""
	Local cFilSRF	:= FWxFilial("SRF")
	Local nParSRF	:= 1
	Local oQrySRF	:= Nil

	Default cMatEmp	:= ""

	cQuery := " SELECT SUM(RF_DFERVAT) DFERVAT, SUM(RF_DFERAAT) DFERAAT, SUM(RF_DIASANT) DIASANT, SUM(RF_DFERANT) DFERANT"
	cQuery += " FROM ?"
	cQuery += " WHERE RF_FILIAL = ?"
	cQuery += " AND RF_MAT = ?"
	cQuery += " AND RF_STATUS = ?"
	cQuery += " AND D_E_L_E_T_ = ?"

	oQrySRF := FwExecStatement():New(cQuery)

	oQrySRF:SetUnsafe(nParSRF++, RetSqlName("SRF")	)
	oQrySRF:SetString(nParSRF++, cFilSRF			) // Sucursal SRF
	oQrySRF:SetString(nParSRF++, cMatEmp			) // Matrícula
	oQrySRF:SetString(nParSRF++, '1'				) // Estatus: 1 - Activo
	oQrySRF:SetString(nParSRF++, ' '				) // D_E_L_E_T_

	cAliasSRF := oQrySRF:OpenAlias()
	(cAliasSRF)->(DbGoTop())

	While (cAliasSRF)->(!EoF())
		nRet += ((cAliasSRF)->DFERVAT + (cAliasSRF)->DFERAAT)	// Dias vencidos + Dias proporcionales
		nRet -= ((cAliasSRF)->DIASANT + (cAliasSRF)->DFERANT) // Dias Ant Periodo + Dias pagados
		(cAliasSRF)->(DbSkip())
	EndDo
	(cAliasSRF)->(dbCloseArea())

	FWFreeObj(oQrySRF)
	FWRestArea(aArea)
Return nRet
