#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEA291.CH"
#INCLUDE "HEADERGD.CH"
#INCLUDE "GPEXOPER.CH"

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GPEA291   ³Autor³Tatiane Matias                  ³ Data ³24/09/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Cadastro de Formulas para uso em Roteiro de Calculo                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                           ³
ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³                ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL              ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Programador ³   Data   ³ BOPS/FNC  ³  Motivo da Alteracao                     ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Leandro Dr. ³27/09/2012³    M12RH01³Requisito RHU210 - Unificação das folhas. ³
³Flavio C.   ³22/07/2014³TQAINI     ³Ajuste para o Mexico nao importar For. Pad³
³M.Camargo   ³16/10/2015³PCDEF-71470³Ajuste para o Mexico importar For. Pad    ³
³G.Santacruz ³23/11/2015³pcreq-7944 ³Se corrige Retorder por RetOrdem          ³
³M.Camargo   ³23/11/2016³MMI-4222   ³Se anade versión para Loc. colombia p12   ³
³M.Camargo   ³12/02/2019³DMINA-5295 ³Modificacion ínjdices.                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea291()
Local aArea			:= GetArea()
Local aAreaRC2		:= RC2->(GetArea())
Local aRc2Index		:= {}
Local cRc2Filtra	:= ""
Local lSetDebbug

Private bFiltraBrw	:= {|| NIL}
Private cCadastro   := OemToAnsi(STR0001) //"Cadastro de Formulas para Roteiro"
Private aHotkeys	:= {}
Private aCopyItem	:= {}

aHotkeys := LoadHotkeys()

Private lManutence
Private cOrigem

Private aRotina   := MenuDef()

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Adiciona Opcao para a Geracao de Formulas                              ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
lManutence := (FunName() == "GPEA290M")
If lManutence
	aAdd(aRotina , {OemtoAnsi(STR0087), "Gpea290Ger", 0, 9}) // "Gerar Formulas"
Else
	Private lImpForm := .T.
EndIf

Begin Sequence

	/*/
	?????????????????????????????????????????????????????????????????????????
	? Variavel para Definir se Esta em "Modo de Edicao" Copiar Formula       ?
	??????????????????????????????????????????????????????????????????????????/*/
	Private lGpea291Cpy		:= .F.

	/*/
	?????????????????????????????????????????????????????????????????????????
	? Verifica o Modo de Acesso do RC2 e RC3. Ambos Tem que ser Iguais e  Com?
	? partilhados															 ?
	??????????????????????????????????????????????????????????????????????????/*/
	If xRetModo("RC2", "RC3")

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Deve Adicionar as Formulas Padroes                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If lImpForm //.And. cPaisLoc != "MEX" // MLCM Debe realizar la carga inciial también para México
		/*/ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		   ³ Formulas Padroes              										 ³
		   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			MsAguarde({|| GpIniForm()}, OemToAnsi(STR0115))	//"Inicializando as Fórmulas Padrões..."
		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Inicializa o filtro utilizando a funcao FilBrowse                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cRc2Filtra	:= ChkRh(FunName(), "RC2", "1")
		cRc2Filtra  += If(!Empty(cRc2Filtra),'.and. RC2_MODELO == "' + MV_MODFOL + '"', 'RC2_MODELO == "' + MV_MODFOL + '"')
		bFiltraBrw	:= {|| FilBrowse("RC2" ,@aRc2Index ,@cRc2Filtra)}
		Eval(bFiltraBrw)

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Chama a Funcao de Montagem do Browse                                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		RC2->(dbGotop())
		mBrowse(6 , 1 , 22 , 75 , "RC2" , NIL , NIL , NIL , NIL , NIL , Gpea290Marks(),,,,,,,,,,,MV_MODFOL)

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Deleta o filtro utilizando a funcao FilBrowse                     	 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		EndFilBrw("RC2", @aRc2Index)

	EndIf

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura os Dados de Entrada 											 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
RestArea(aAreaRC2)
RestArea(aArea)

Set key VK_F11 To

Return(NIL)


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea291Mnt³ Autor ³Tatiane Matias         ³ Data ³24/09/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea291Mnt( cAlias , nReg , nOpcX )							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cAlias = Alias do arquivo                                   ³
³          ³nReg   = Numero do registro                                 ³
³          ³nOpc   = Numero da opcao selecionada                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea291Mnt(cAlias, nReg, nOpc)
Local aArea          := GetArea()
Local aSvKeys		 := GetKeys()
Local aAreaRCA       := RCA->(GetArea())
Local aAreaRC3       := RC3->(GetArea())
Local aRC2Cols       := {}
Local aSvRC2Cols     := {}
Local aRc2Enchoice   := {}
Local aRc2VirtChoice := {}
Local aRc2Visual     := {}
Local nXs            := 0
Local nX             := 0
Local aFields        := {}
Local aNaoAltera     := {}
Local aAltera        := {}
Local aRc3Virtual    := {}
Local aRc3Visual     := {}
Local aRc3Recnos     := {}
Local nPosSeq        := 0
Local nTamSeq        := GetSx3Cache("RC3_SEQFOR" , "X3_TAMANHO")
Local aSvRc3Cols     := {}
Local bSet15         := { || NIL }
Local bSet24         := { || NIL }
Local nOpcAlt        := 0
Local aAdvSize 		 := {}
Local aInfo			 := {}
Local aObjects       := {}
Local aPosObj        := {}
Local nUsado         := 0
Local oDlg           := NIL
Local oRc2Enchoice	 := NIL
Local aNotFields     := {}
Local aButtons       := {}

Local bSvSet15		:= { || NIL }
Local bSvSet24		:= { || NIL }
Local bCopyFor		:= { || NIL }
Local bCopy			:= { || NIL }
Local bPaste		:= { || NIL }
Local bInsert		:= { || NIL }
Local bFind         := {|| fLocaliza( If(ValType((&(ReadVar()))) == "U", "", &(ReadVar()) ) ) }

Private aHeader      := Array(5 , __ELEMENTOS_AHEADER__)
Private aCols        := {}
Private oRc3GetDados

Begin Sequence

	If (nOpc == 3 ) //Inclusao

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Quando For Inclusao Posiciona o RC2 No Final do Arquivo	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		PutFileInEof("RC2", @nReg)

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Quando Inclusao Sempre Reinicializa n quando este ja tiver si³
		³ do Criado de forma a Manter o Sequenciamento das formulas cor³
		³ reto														   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If (Type("n") != "U")
			n := 1
		EndIf

	ElseIf !lGpea291Cpy .AND. !lManutence .AND. (RC2->RC2_ORIGEM == "S_") .And. !nOpc == 2
		MsgInfo( OemToAnsi(STR0088) + CRLF + OemToAnsi(STR0089) ) // "As Formulas do Sistema nao Podem Ser Alteradas Pelo Usuario." ### "Est?o Dispon?veis apenas para Visualizacao"
	    nOpc := 2
	ElseIf (lGpea291Cpy)

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Altera opcao para Inclusao                                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nOpc := 3	//Inclusao


	Else
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Quando For Exclusao Verifica se a Formula esta sendo  utiliza³
		³ da Antes de Efetuar a Exclusao							   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
 		If ( nOpc == 5 )
			If (;
					!( WhileExecRot() );
					.or.;
					!( Gpea291ExcluChk( cAlias , nReg , nOpc ) );
				)
				Break
			EndIf
			aRotSetOpc( cAlias , nReg , nOpc )
		EndIf
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta os Dados para a Enchoice							   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdd(aNotFields , "RC2_FILIAL")
	aRC2Cols	:= RC2->(GdBuildCols(@aRc2Enchoice , NIL , @aRc2VirtChoice , @aRc2Visual , "RC2" , aNotFields , NIL , "RC2"))
	aSvRC2Cols	:= aClone(aRC2Cols)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria as Variaveis de Memoria e Carrega os Dados Conforme o ar³
	³ quivo														   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nXs := Len(aRc2Enchoice)
	For nX := 1 To nXs
		aAdd(aFields , aRc2Enchoice[nX, 02])
		SetMemVar(aRc2Enchoice[nX, 02], aRC2Cols[1, nX], .T.)
	Next nX

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Define os Campos Editaveis na Enchoice Apenas na Inclusao( 3 )³
	³ou Alteracao(4)											   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If (;
			( nOpc == 3 );
			.or.;
			(nOpc == 4);
		)


		If (lGpea291Cpy)
			SetMemVar("RC2_CODIGO" , Space(Len(GetMemVar("RC2_CODIGO"))))
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Define os Campos Editaveis								   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nXs := Len(aRc2Visual)
		For nX := 1 To nXs
			aAdd(aNaoAltera, aRc2Visual[nX])
		Next nX
		If (nOpc == 4)
			aAdd(aNaoAltera, "RC2_CODIGO")
		EndIf

		nXs := Len(aFields)
		For nX := 1 To nXs
			If (aScan(aNaoAltera, {|cNaoA| cNaoA == aFields[nX]}) == 0)
				aAdd(aAltera, aFields[nX])
			EndIf
		Next nX
	EndIf

	//INICIALIZA cOrigem
	If lManutence
		If nOpc == 4 .And. !M->RC2_ORIGEM == "S_"
			cOrigem := "U_"
			M->RC2_ORIGEM := cOrigem
		Else
			cOrigem := "S_"
			M->RC2_ORIGEM := cOrigem
		EndIf
	Else
		cOrigem := "U_"
		M->RC2_ORIGEM := cOrigem
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta os Dados para a GetDados							   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdd(aNotFields, "RC2_ORIGEM")
	aAdd(aNotFields, "RC3_FILIAL")
	aAdd(aNotFields, "RC3_CODIGO")

	Gpea291aHead()

	RC2->(dbSetOrder(1)) // RC2_FILIAL+RC2_ORIGEM+RC2_CODIGO
	RC3->(dbSetOrder(2)) // RC3_FILIAL+RC3_ORIGEM+RC3_CODIGO+RC3_SEQFOR

	cKeySeek := RC2->(RC2_FILIAL+RC2->RC2_ORIGEM+RC2_CODIGO)
	aCols := RC3->( GdMontaCols( aHeader 		,;	// 01 -> Array com os Campos do Cabecalho da GetDados
								 @nUsado 		,;	// 02 -> Numero de Campos em Uso
								 @aRc3Virtual 	,;	// 03 -> [@]Array com os Campos Virtuais
								 @aRc3Visual 	,;	// 04 -> [@]Array com os Campos Visuais
								 "RC3"			,;	// 05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
								 aNotFields 	,;	// 06 -> Opcional, Campos que nao Deverao constar no aHeader
								 @aRc3Recnos 	,;	// 07 -> [@]Array unidimensional contendo os Recnos
								 "RC2"			,;	// 08 -> Alias do Arquivo Pai
								 cKeySeek		,;	// 09 -> Chave para o Posicionamento no Alias Filho
								 NIL			,;	// 10 -> Bloco para condicao de Loop While
								 NIL			,;	// 11 -> Bloco para Skip no Loop While
								 NIL			,;	// 12 -> Se Havera o Elemento de Delecao no aCols
								 NIL			,;	// 13 -> Se cria variaveis Publicas
								 NIL			,;	// 14 -> Se Ser	a considerado o Inicializador Padrao
								 NIL			,;	// 15 -> Lado para o inicializador padrao
								 NIL			,;	// 16 -> Opcional, Carregar Todos os Campos
								 NIL			,;	// 17 -> Opcional, Nao Carregar os Campos Virtuais
								 NIL			,;	// 18 -> Opcional, Utilizacao de Query para Selecao de Dados
								 NIL			,;	// 19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP ) - utilizado com o parametro 10
								 NIL			,;	// 20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP ) - utilizado com o parametro 11
								 .T.			,;	// 21 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
								 NIL			,;	// 22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
								 NIL			,;	// 23 -> Verifica se Deve Checar se o campo eh usado
								 NIL			,;	// 24 -> Verifica se Deve Checar o nivel do usuario
								 NIL			,;	// 25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
								 NIL			,;	// 26 -> [@]Array que contera as chaves conforme recnos
								 NIL			,;	// 27 -> [@]Se devera efetuar o Lock dos Registros
								 NIL			,;	// 28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
						        NIL			,;	// 29 -> Numero maximo de Locks a ser efetuado
								 .T.			 ;	// 30 -> Utiliza Numeracao na GhostCol
							     ) )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Chamar novamente a criação do aHeader, pois a GDMontaCols al- ³
	³tera as informacoes do aHeader criado anteriormente.          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	Gpea291aHead()

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Modifica Sequencia com StrZero()				         	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nPosSeq	  := GdFieldPos("RC3_SEQFOR")
	aEval(@aCols , { |x| ;
					 		x[nPosSeq] := StrZero(Val(x[nPosSeq]) , nTamSeq);
					 };
		  )

	If !(lGpea291Cpy)
		aSvRc3Cols := aClone(aCols)
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para a Gravacao                 			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bGpea291GvTudOk := { || Gpea291GvTudOk(	@nOpcAlt		,;
											nOpc			,;
											@nReg			,;
											aRC2Cols		,;
											aSvRC2Cols		,;
											aRC2Enchoice	,;
											aRC2VirtChoice 	,;
											aHeader			,;
											aCols			,;
											aRC3Virtual		,;
											@aRC3Recnos		,;
											nUsado			,;
											aSvRC3Cols		;
							  			  );
						}


	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para o Botao Confirma           			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	//Colocar o foco no 2o campo, pois o 1o eh somente consulta e nao pega o foco.
	bSet15		:= { || oRc2Enchoice:aEntryCtrls[ 2 ]:SetFocus(),;
						IF( ( nOpc == 3 ) .or. ( nOpc == 4 ) .or. ( nOpc == 5 ),;
							IF(EnchoTudOk( oRc2Enchoice ) .and. oRc3GetDados:TudoOk() .and. ( nOpcAlt := 1 , Eval( bGpea291GvTudOk ) ),;
								(nOpcAlt := 1, GetKeys(), oDlg:End(), .T. ),;
								(nOpcAlt := 0 , .F. );
							   ),;
							( nOpcAlt := 0 , .F. );
  						   );
   				   }

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para o Botao Cancela            			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bSet24		:= { || (nOpcAlt := 0, GetKeys(), oDlg:End())}


 	If (nOpc == 3) .or. (nOpc == 4)
  		bCopyFor	:= {|| aCopyRot := Gpea291Cpy()}
  		bCopy		:= {|| aCopyItem := Gpea291CopyItem()}
 		bPaste		:= {|| Gpea291Paste( aCopyItem ) }
 		bInsert		:= {|| Gpea291Insert(), oRc3GetDados:oBrowse:SetFocus(), oRc3GetDados:Refresh() }
	EndIf

	aAdd(aButtons, {"S4WB005N",bCopy,OemToAnsi(STR0003),OemToAnsi(STR0003)})
	SetKey(VK_F4, bCopy)
	aAdd(aButtons, {"S4WB007N",bPaste,OemToAnsi(STR0004),OemToAnsi(STR0004)})
	SetKey(VK_F5, bPaste)
	aAdd(aButtons, {"TK_FIND",bFind,OemToAnsi(STR0014),OemToAnsi(STR0014)})
	aAdd(aButtons , {"SDUGOTO",bInsert,OemToAnsi(STR0015),OemToAnsi(STR0015)})
	SetKey(VK_F6, bInsert)
	SetKey(VK_F11, {|| AtivaF11()})

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta as Dimensoes dos Objetos         					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdvSize := MsAdvSize()
	aInfo	 := {aAdvSize[1], aAdvSize[2], aAdvSize[3], aAdvSize[4], 3, 3}
	AAdd(aObjects, {100, 60, .T., .F.})
	AAdd(aObjects, {100, 100, .T., .T.})
	aPosObj := MsObjSize(aInfo, aObjects)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta o Dialogo Principal para a Manutencao das Formulas	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nOpcAlt := 0
	DEFINE MSDIALOG oDlg TITLE cCadastro From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL

		oRc2Enchoice := MsmGet():New( "RC2" , nReg , nOpc , NIL , NIL , NIL , aFields , aPosObj[1] , aAltera , NIL , NIL , NIL , oDlg , NIL , .F.,,,,,,,,,, Alltrim(MV_MODFOL) )
		oRc3GetDados := MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"Gpea291LinOk","Gpea291TudOk","+RC3_SEQFOR",.T.,NIL,NIL,NIL,99999,"fChangeHk()",,,,,, Alltrim(MV_MODFOL))
		oRc3GetDados:lf3Header := .T.

	ACTIVATE MSDIALOG oDlg ON INIT  EnchoiceBar(oDlg, bSet15, bSet24, NIL, aButtons) CENTERED //Gpea291Bar( oDlg , bSet15 , bSet24 , ( ( nOpc == 3 ) .or. ( nOpc == 4 ) ) )

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Restaura os Dados de Entrada								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
lGpea291Cpy := .F.
RestKeys(aSvKeys)
RestArea(aArea)

Return(nOpcAlt)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³gpea291aHeadºAutor  ³Tatiane Matias    º Data ³  25/09/2007 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Carga el aHeader del RC3 para la getdados                   º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Gpea291                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Gpea291aHead()
Local cAlias := "RC3"
Local cF3	 := ""
Local nPos	 := 0

nUsado :=	0
dbSelectArea("SX3")
dbSetOrder(1)
dbseek(cAlias)

While !Eof() .And. (X3_arquivo == cAlias)
	If X3USO(x3_usado) .AND. cNivel >= x3_nivel
		nPos := 0
		cF3  := ""
		Do Case
			Case (AllTrim(x3_campo) == "RC3_SEQFOR" )
				nPos := 1
				nUsado++
			Case (AllTrim(x3_campo) == "RC3_FORM01" )
				nPos := 2
				cF3  := "RCA02"
				nUsado++
			Case (AllTrim(x3_campo) == "RC3_OPERA1" )
				cF3  := "RCA02"
				nPos := 3
				nUsado++
			Case (AllTrim(x3_campo) == "RC3_FORM02" )
				nPos := 4
				cF3  := "RCA02"
				nUsado++
			Case (AllTrim(x3_campo) == "RC3_RESULT" )
				nPos := 5
				cF3  := "RCA02"
				nUsado++
		EndCase

		If nPos > 0
			aHeader[ nPos , __AHEADER_FIELD__	] := x3_campo
			aHeader[ nPos , __AHEADER_PICTURE__	] := x3_picture
			aHeader[ nPos , __AHEADER_WIDTH__	] := x3_tamanho
			aHeader[ nPos , __AHEADER_DEC__		] := x3_decimal
			aHeader[ nPos , __AHEADER_VALID__	] := X3_VALID
			aHeader[ nPos , __AHEADER_USE__		] := x3_usado
			aHeader[ nPos , __AHEADER_TYPE__	] := x3_tipo
			aHeader[ nPos , __AHEADER_F3__		] := cF3
			aHeader[ nPos , __AHEADER_CONTEXT__	] := x3_context
			aHeader[ nPos , __AHEADER_INITPAD__	] := x3_relacao
			aHeader[ nPos , __AHEADER_WHEN__	] := if(AllTrim(x3_campo) == "RC3_SEQFOR", ".F.", x3_when)
			aHeader[ nPos , __AHEADER_VISUAL__	] := x3_visual
			aHeader[ nPos , __AHEADER_VLDUSR__	] := x3_vlduser
			aHeader[ nPos , __AHEADER_RESERV16__] := ""
			aHeader[ nPos , __AHEADER_RESERV17__] := .F.
			aHeader[ nPos , __AHEADER_TITLE__	] := TRIM(x3titulo())
			aHeader[ nPos , __AHEADER_CBOX__	] := x3cbox()

		EndIf
	EndIf
	dbSkip()
End

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea291TudOk³Autor³Tatiane Matias         ³ Data ³26/09/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea291TudOk( oBrowse )									    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea291TudOk(oBrowse, lLog)

Local lTudoOk	:= .T.

Local nLoop
Local nLoops
Local aEtiquetas := {}
Local aEtqUsadas := {}

DEFAULT lLog := .F.

Begin Sequence
	nLoops := Len( aCols )
	For nLoop := 1 To nLoops
		n := nLoop
		If !( lTudoOk := Gpea291LinOk( oBrowse , .F., lLog, @aEtiquetas, @aEtqUsadas ) )
			If Valtype(oBrowse) == "O"
				oBrowse:nAt := nLoop
				oBrowse:Refresh()
				Break
			EndIf
		EndIf
	Next nLoop

	//VERIFICAR SE TODAS AS ETIQUETAS INFORMADAS EXISTEM
	If !GpEtiquetas(aEtiquetas, aEtqUsadas, lLog)
		lTudoOk := .F.
		If !lLog
			Break
		EndIf
	EndIf

	//Verificar se utiliza o operador BUSCA e se o ELEMENTO- existe na tabela (HASTA-XXX).
	If !GpBusca(lLog)
		lTudoOk := .F.
		If !lLog
			Break
		EndIf
	EndIf

	//Verificar a utilizacao de TRAY
	If !GpTray(lLog)
		lTudoOk := .F.
		If !lLog
			Break
		EndIf
	EndIf

	//Verificar a utilizacao de DEP
	If !GpDepen(lLog)
		lTudoOk := .F.
		If !lLog
			Break
		EndIf
	EndIf

	//Operador BUSCA-PROCESO utilizado juntamente com SUMA-IMPORTES,SUMA-UNIDADES
	/*If !GpBuscaProcesso(lLog)
		lTudoOk := .F.
		If !lLog
			Break
		EndIf
	EndIf*/

End Sequence

Return(lTudoOk)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea291LinOk³Autor³Tatiane Matias         ³ Data ³26/09/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea291LinOk( oBrowse )									    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea291LinOk(oBrowse, lNotTudoOk, lLog, aEtiquetas, aEtqUsadas)

Local lLinOk		:= .T.
Local nPosSeq		:= GdFieldPos("RC3_SEQFOR")
Local nPosRes		:= GdFieldPos("RC3_RESULT")
Local nPosForm1		:= GdFieldPos("RC3_FORM01")
Local nPosForm2		:= GdFieldPos("RC3_FORM02")
Local nPosOpe		:= GdFieldPos("RC3_OPERA1")
Local nPosEtiq  	:= 0
Local nX			:= 0
Local nAch			:= 0
Local nLenCols		:= 0
Local lVld			:= .T.
Local nCpo 			:= 1
Local cMnemonico	:= ""
Local aCposKey 		:= {}
Local cOperador  	:= AllTrim(aCols[n,nPosOpe])
Local cOperando1 	:= AllTrim(aCols[n,nPosForm1])
Local cOperando2 	:= AllTrim(aCols[n,nPosForm2])
Local cResultado 	:= AllTrim(aCols[n,nPosRes])
Local cSeq		 	:= AllTrim(aCols[n,nPosSeq])
Local nDia       	:= 0
Local nMes       	:= 0
Local cTipos     	:= ""
Local aTables    	:= {}
Local cTpMovtos	 	:= ""
Local cTp		 	:= ""
Local cTabela	 	:= ""
Local cPrim      	:= ""
Local cUlti      	:= ""
Local cOperando  	:= ""
Local aFilVal 	 	:= GetFilRecnos(cEmpAnt, replicate('0', FWGETTAMFILIAL), replicate('Z', FWGETTAMFILIAL))
Local cOper1	 	:= ""
Local cSeparador 	:= ""
Local nY		 	:= 0
Local cOper2	 	:= ""
Local cTiposMov		:= ""
Local cMsgTpMov		:= ""
Local lFiltroMovli	:= .F.
DEFAULT aEtiquetas := {}
DEFAULT aEtqUsadas := {}

Begin Sequence

		If !aCols[n, Len(aCols[n])]
			nLenCols := Len(aCols)
			For nX := 1 To nLenCols
				If cSeq == AllTrim(aCols[nX, nPosSeq]) .and.;
					!aCols[nX , Len(aCols[nX])] .and. n # nX
					Message(OemToAnsi(STR0022 + ":" + cSeq), lLog) // "Sequencia ja cadastrada."
					lLinOk := .F.
					If !lLog
						Break
					EndIf
				EndIf
			Next nX
			If ( Val(cSeq) ==  0 )
				Message(OemToAnsi( STR0023 ), lLog) // "Sequencia deve ser preenchida."
				lLinOk := .F.
				If !lLog
					Break
				EndIf
			EndIf

            //Operando 1 comecando com "#" => comentario da formula. Não deve validar a linha
			If !Empty(cOperando1) .and. Substr(cOperando1,1,1) = "#"
				lLinOk := .T.
				Break
			EndIf
			If (Substr(cOperando1,1,1) == '"' .And. Right(cOperando1, 1) != '"') .Or.;
			   (Substr(cOperando1,1,1) == "'" .And. Right(cOperando1, 1) != "'")
				Message(OemToAnsi( STR0109 ) + Substr(cOperando1,1,1) + OemToAnsi( STR0110 ), lLog) //O operador deve ser informado
				lLinOk := .F.
				Break
			EndIf
			If (Substr(cOperando2,1,1) == '"' .And. Right(cOperando2, 1) != '"') .Or.;
			   (Substr(cOperando2,1,1) == "'" .And. Right(cOperando2, 1) != "'")
				Message(OemToAnsi( STR0109 ) + Substr(cOperando2,1,1) + OemToAnsi( STR0110 ), lLog) //O operador deve ser informado
				lLinOk := .F.
				Break
			EndIf
			If Empty(cOperador)
				Message(OemToAnsi( STR0077 ), lLog) //O operador deve ser informado
				lLinOk := .F.
				Break
			EndIf
			If Empty(cOperando1) .and. Empty(cOperando2) .and. Empty(cOperador)
				Message(OemToAnsi( STR0024 ), lLog)
				lLinOk := .F.
				Break
			EndIf

			If cResultado == ME_TP_SUMA_MOVLI
				cPrim := Substr(Alltrim(cOperando2),1,1)
				cUlti := Substr(Alltrim(cOperando2),len(Alltrim(cOperando2)),1)
				If (cPrim == '"' .or. cPrim == "'") .Or. (cUlti == '"' .or. cUlti == "'")
					cOper2 := substr(alltrim(cOperando2),2,len(alltrim(cOperando2))-2)
				EndIf
				If Empty(cOper2) .or. !(cOper2 $ "HDV" ) .or. len(cOper2)>1
					Message(OemToAnsi( STR0080 ), lLog)  //Informe "H" ou "D" para totalização em horas ou "V" para totalização em valores
					lLinOk := .F.
			 	EndIf
			EndIf

			If cResultado == ME_TP_FILTRO
				cPrim := Substr(Alltrim(cOperando2),1,1)
				cUlti := Substr(Alltrim(cOperando2),len(Alltrim(cOperando2)),1)
				If cPrim != cUlti
					Message(OemToAnsi( STR0113), lLog)		//'Informe "1" ou "2" para o tipo de Filtro. 1-Contém ou 2-Contido'
					LinOk := .F.
					Break
				EndIf
				If (cPrim == '"' .or. cPrim == "'") .Or. (cUlti == '"' .or. cUlti == "'")
					cOper2 := substr(alltrim(cOperando2),2,len(alltrim(cOperando2))-2)
				EndIf
				If Empty(cOper2) .or. !(cOper2 $ "12" ) .or. len(cOper2)>1
					Message(OemToAnsi( STR0113), lLog)  //'Informe "1" ou "2" para o tipo de Filtro. 1-Contém ou 2-Contido'
					lLinOk := .F.
			 	EndIf
			EndIf
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica Se o operador existe 								³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If !Empty(cOperador)
				RCA->(dbSetOrder(3))
				If (!(RCA->( dbSeek(xFilial("RCA") + "P" + cOperador) )  .and. (Alltrim(RCA->RCA_MNEMON) == Alltrim(cOperador))).and. Alltrim(cOperador) != OP_PUNTO_ENT )
					Message(OemToAnsi( STR0020 + ":" + cOperador + " (" + STR0058 + cSeq + ")" ), lLog) //"Operador nao cadastrado."
					lLinOk := .F.
					If !lLog
						Break
					EndIf
				Else

					Do Case
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Operadores aritmeticos        							   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						Case cOperador == OP_SUMA
							If !IsMneValid(cOperando1, "R/N/D", .T., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/N"  , .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N/D", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							If IsMneValid(cOperando1, "N", .T., .F., .T., lLog, STR0028, .F.)
								cTipos := "R/N"
							ElseIf IsMneValid(cOperando1, "D", .T., .F., .T., lLog, STR0028, .F.)
								cTipos := "R/D"
							Else
								cTipos := "R/N/D"
							EndIf

							If !Empty(cTipos)
								If !IsMneValid(cResultado, cTipos, .T., .F., .T., lLog, STR0027, .F.)
									Message(OemToAnsi( STR0039 + ":" + STR0028 + "," + STR0027 + " (" + STR0058 + cSeq + ")"), lLog) // "Os campos devem ser do mesmo tipo"
									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf
							EndIf

						Case cOperador == OP_RESTA
							If !IsMneValid(cOperando1, "R/N/D", .T., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/N/D", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N"  , .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							If IsMneValid(cOperando1, "N", .T., .F., .T., lLog, STR0028, .F.)
								cTipos := "R/N"
							ElseIf IsMneValid(cOperando1, "D", .T., .F., .T., lLog, STR0028, .F.)
								cTipos := "R/D"
							Else
								cTipos := "R/N/D"
							EndIf

							If !Empty(cTipos)
								If !IsMneValid(cOperando2, cTipos, .T., .F., .T., lLog, STR0027, .F.)
									Message(OemToAnsi( STR0039 + ":" + STR0028 + "," + STR0029 + " (" + STR0058 + cSeq + ")"), lLog) // "Os campos devem ser do mesmo tipo"
									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf
							EndIf

						Case cOperador == OP_MULTIPLICA .or. cOperador == OP_DIVIDE .or.;
						     cOperador == OP_RESIDUO .or. cOperador == OP_EXPONENTE .or.;
						     cOperador == OP_SUMA_DIAS
							If !IsMneValid(cOperando1, "R/N", .T., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/N", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							If (cOperador == OP_DIVIDE .or. cOperador == OP_RESIDUO) .and. cOperando2 == "0"
								Message(OemToAnsi( STR0034 + " (" + STR0058 + cSeq + ")"), lLog) // "Operação inválida: divisão por 0 (zero)."
							 	lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf
						Case cOperador == OP_UNIDADES_EMPRESA .or. cOperador == OP_IMPORTE_EMPRESA .or.;
						     cOperador == OP_SUMA_IMPORTES  .or. cOperador == OP_SUMA_UNIDADES .or. ;
						     cOperador == OP_IMPORTE_TOTAL .or. cOperador == OP_UNIDADES_TOTAL
							If !IsMneValid(cOperando1, "R/C", .T., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/C", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N", .T., .F., .T., lLog, STR0027)
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf
						Case cOperador == OP_SI_IGUAL .or. cOperador == OP_SI_MAYOR .or.;
						     cOperador == OP_SI_MENOR .or. cOperador == OP_SI_DIFERENTE
							If !IsMneValid(cOperando1, "R/N/D/C/L", .T., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/N/D/C/L", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado,        , .T., .F., .F., lLog, STR0027)
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf

							If IsMneValid(cOperando1, "N", .T., .F., .T., lLog, STR0028, .F.)
								cTipos := "R/N"
							ElseIf IsMneValid(cOperando1, "D", .T., .F., .T., lLog, STR0028, .F.)
								cTipos := "R/D"
							ElseIf IsMneValid(cOperando1, "C", .T., .F., .T., lLog, STR0028, .F.)
								cTipos := "R/C"
							ElseIf IsMneValid(cOperando1, "L", .T., .F., .T., lLog, STR0028, .F.)
								cTipos := "R/L"
							Else
								cTipos := "R/N/D/C"
							EndIf

							If !Empty(cTipos)
								If !IsMneValid(cOperando2, cTipos, .T., .F., .T., lLog, STR0027, .F.)
									Message(OemToAnsi( STR0039 + ":" + STR0028 + "," + STR0029 + " (" + STR0058 + cSeq + ")"), lLog) // "Os campos devem ser do mesmo tipo"
									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf
							EndIf

							If Ascan(aEtqUsadas,{|x| x == cResultado}) == 0
								AADD(aEtqUsadas, cResultado)
							EndIf

						Case cOperador == OP_TRUNCA .or. cOperador == OP_REDONDEA
							If !IsMneValid(cOperando1, "R/N", .F., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/N", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

						Case cOperador == OP_DIAS_DERECHO
							If !(cOperando1 == ME_TODOS_LOS_DIAS .or. cOperando1 == ME_SIN_PROGRAMAR .or. cOperando1 == ME_DIAS_PAGADOS)
								Message(OemToAnsi( STR0037 + " (" + STR0058 + cSeq + ")" ), lLog) // "Para utilizar o operador 'DIAS-DERECHO' o campo 1a expressao deve ser 'TODOS-LOS-DIAS' ou 'SIN-PROGRAMAR'"
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf

							If !IsMneValid(cOperando2, "R/D", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

						Case cOperador == OP_ETIQUETA
							If !IsMneValid(cOperando1,, .T., .F., .F., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2,, .F., .T., .F., lLog, STR0029) .or.;
							   !IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							If Ascan(aEtiquetas,{|x| x[1] == cResultado}) == 0
								AADD(aEtiquetas, {cOperando1, cOperando2})
							Else
								Message(OemToAnsi(STR0041 + cResultado + STR0044 + " (" + STR0058 + cSeq + ")" ), lLog) // " A Etiqueta "#" ja foi definida..."
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf

							nPosEtiq := Ascan( aCols, {|x| Alltrim(x[2]) == cOperando1 })

							If nPosEtiq > 0 .And. nPosEtiq # n
								If AllTrim(acols[nPosEtiq][nPosForm1]) == AllTrim(acols[n][nPosForm1])
									lLinOk := .F.
									cSeq := AllTrim(aCols[nPosEtiq,nPosSeq])
									Message(OemToAnsi(STR0041 + cOperando1 + STR0044 + " (" + STR0058 + cSeq + ")" ), lLog) // " A Etiqueta "#" ja foi definida..."
									lLinOk := .F.
									Break
								EndIf
							EndIf

						Case cOperador == OP_SALTA
							If !IsMneValid(cOperando1,, .F., .T., .F., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2,, .F., .T., .F., lLog, STR0029) .or.;
							   !IsMneValid(cResultado,, .T., .F., .F., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							If Ascan(aEtqUsadas,{|x| x == cResultado}) == 0
								AADD(aEtqUsadas, cResultado)
							EndIf

						Case cOperador == OP_HASTA_IGUAL .or. cOperador == OP_HASTA_MAYOR .or. cOperador == OP_HASTA_MENOR
							If !(IsMneValid(cOperando1, "R", .T., .F., .T., lLog, STR0028) .and.;
								 Substr(cOperando1, 1, (Len(alltrim(cOperando1))-2) ) == ME_ELEMENTO)
								Message(OemToAnsi( STR0036 + " (" + STR0058 + cSeq + ")" ), lLog) // "Para os operadores 'HASTA-IGUAL','HASTA-MAYOR','HASTA-MENOR' o campo 1a expressao deve ser 'ELEMENTO-01' a 'ELEMENTO-99'"
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf

							// Para o Hasta Igual eh permitido Caracter pois na Definicao de Tabelas
							// permite-se os campos em Caracteres.
							If cOperador == OP_HASTA_IGUAL
								If !IsMneValid(cOperando2, "R/N/C/D" , .T., .F., .T., lLog, STR0029) .or.;
								   !IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf
							Else
								If !IsMneValid(cOperando2, "R/N/D" , .T., .F., .T., lLog, STR0029) .or.;
								   !IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf
							EndIf

						Case cOperador == OP_DIAS_HABILES .or. cOperador == OP_DIAS_HAB_PROG .Or. cOperador == OP_HORAS_HABILES
							If !IsMneValid(cOperando1, "R/D", .T., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/D", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf
						Case cOperador == OP_DIAS_FERIADO
							If !IsMneValid(cOperando1, "R/D", .T., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/D", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf
						Case cOperador == OP_TIPO_DIA
							If !IsMneValid(cOperando1,    , .F., .T., .F., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/D", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/C", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf
						Case cOperador == OP_GET_MONEDA
                        	If !IsMneValid(cOperando1, "R/D", .T., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/N/C", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

						Case cOperador == OP_GRABA //.or. cOperador == OP_INCLUI
							If !IsMneValid(cOperando1,    , .F., .T., .F., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "C", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado,    , .F., .T., .F., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							//Verificar se a tabela informada esta disponivel
							aTables := fListTable()

							cPrim := Substr(Alltrim(cOperando2),1,1)
							cUlti := Substr(Alltrim(cOperando2),len(Alltrim(cOperando2)),1)
							If (cPrim == '"' .or. cPrim == "'") .and. (cUlti == '"' .or. cUlti == "'")
								cOperando2 := substr(alltrim(cOperando2),2,len(alltrim(cOperando2))-2)
							EndIf
							If !( cOperando2 == "SR7/SR3" )
								If ( cOperando2 == "SR7" )
									Message(OemToAnsi( STR0038 + " (" + STR0058 + cSeq + ")" ), lLog) // "Tabela não disponivel para utilizar com os operadores 'GRABA' e 'INCLUI'."
									lLinOk := .F.
									If !lLog
										Break
									EndIf
								Else

									If aScan( aTables , { |x| x[1] == cOperando2 .and. x[6] == 1} ) == 0
										Message(OemToAnsi( STR0038 + " (" + STR0058 + cSeq + ")" ), lLog) // "Tabela não disponivel para utilizar com os operadores 'GRABA' e 'INCLUI'."
										lLinOk := .F.
										If !lLog
											Break
										EndIf
									EndIf

								EndIf
							EndIf

						Case cOperador == OP_PRIMER_REG_TRAY 	.or. cOperador == OP_ULTIMO_REG_TRAY .or.;
							 cOperador == OP_PRIMER_REG_DEP 	.or. cOperador == OP_ULTIMO_REG_DEP .or.;
							 cOperador == OP_SIG_TRAY 			.or. cOperador == OP_TRACE_ON 		.or.;
							 cOperador == OP_TRACE_OFF 			.or. cOperador == OP_PAGA_DIA_DER
							If !IsMneValid(cOperando1, , .F., .T., .F., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, , .F., .T., .F., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, , .F., .T., .F., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

						/*Case cOperador == OP_PROM_UNIDADES .or. cOperador == OP_PROM_IMPORTE
							If !IsMneValid(cOperando1, , .F., .T., .F., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/N", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf*/

						Case cOperador == OP_MUEVE
							If !IsMneValid(cOperando1, , .F., .T., .F., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/N/D/C/L", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N/D/C/L", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							If IsMneValid(cOperando2, "N", .T., .F., .T., lLog, STR0028, .F.)
								cTipos := "R/N"
							ElseIf IsMneValid(cOperando2, "D", .T., .F., .T., lLog, STR0028, .F.)
								cTipos := "R/D"
							ElseIf IsMneValid(cOperando2, "C", .T., .F., .T., lLog, STR0028, .F.)
								cTipos := "R/C"
							ElseIf IsMneValid(cOperando2, "L", .T., .F., .T., lLog, STR0028, .F.)
								cTipos := "R/L"
							Else
								cTipos := "R/N/D/C"
							EndIf

							If !Empty(cTipos)
								If !IsMneValid(cResultado, cTipos, .T., .F., .T., lLog, STR0027, .F.)
									Message(OemToAnsi( STR0039 + ":" + STR0029 + "," + STR0027 + " (" + STR0058 + cSeq + ")"), lLog) // "Os campos devem ser do mesmo tipo"
									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf
							EndIf

						Case cOperador == OP_BUSCA
							If !IsMneValid(cOperando1,, .F., .T., .F., lLog, STR0028) .or.;
							   !IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							//Verificar se tabela numerica informada existe
							If !(substr(cOperando2, 1, 6) == ME_TABLA)
								Message(OemToAnsi( STR0040 + " (" + STR0058 + cSeq + ")" ), lLog) // "Definicao de Tabela nao encontrada no cadastro"
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							Else
								cTabela := substr(cOperando2,7,len(cOperando2))
								dbSelectArea("RCB")
								RCB->( dbSetOrder(1) )
								If !(RCB->( dbSeek( xFilial("RCB") + cTabela)))
									Message(OemToAnsi( STR0040 + " (" + STR0058 + cSeq + ")" ), lLog) // "Definicao de Tabela nao encontrada no cadastro"
									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf
							EndIf

						Case cOperador == OP_BUSCA_CRITERIO
							//- IsMneValid(cMnemonico, cTipos, lObrigat, lEmpty, lMnemonico, lLog, cCpo, lMessage)
							If !IsMneValid(cOperando1,    "", .F., .T., .F., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/C", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/C", .T., .F., .F., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							If !Empty(cOperando2) .and. len(cOperando2) < 2
								Message(OemToAnsi( STR0109 + " (" + STR0058 + cSeq + ")" ), lLog) // "O mes informado não é valido. Favor informar no formato 'mm'"
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf
						Case cOperador == OP_LEE_TRAY
							If !IsMneValid(cOperando1, "R/D", .F., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/D", .F., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/C", .F., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							If !Empty(CTOD(cOperando1)) .and. !Empty(CTOD(cOperando2))
								If CTOD(cOperando2) < CTOD(cOperando1)
									Message(OemToAnsi( STR0054 + " (" + STR0058 + cSeq + ")" ), lLog) // "A data informada no campo operando 2 deve ser maior que a data informada no campo operando 1."
									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf
							EndIf

							If IsMneValid(cResultado, "C", .F., .F., .T., lLog, STR0028, .F.)
								cPrim := Substr(Alltrim(cResultado),1,1)
								cUlti := Substr(Alltrim(cResultado),len(Alltrim(cMnemonico)),1)
								If (cPrim == '"' .or. cPrim == "'") .and. (cUlti == '"' .or. cUlti == "'")
									cTpMovtos := substr(alltrim(cResultado),2,len(alltrim(cResultado))-2)
								Else
									cTpMovtos := cResultado
								EndIf

								while len(cTpMovtos) > 0
									cTp := alltrim(if(at(",",cTpMovtos) > 0, substr(cTpMovtos, 1, at(",",cTpMovtos)-1), cTpMovtos))
									If cPaisLoc == "COL"
										cTiposMov := "#01#02#03#04#05#08#09#10#11#12#13#14#"
										cMsgTpMov := (STR0055 + cTp + ". (" + STR0058 + cSeq + ")") // "El tipo de movimiento informado no es valido: " # "SEC."
									Else
										cTiposMov := "#01#02#03#04#05#06#07#20#"
										cMsgTpMov := (STR0055 + cTp + STR0056 + " (" + STR0058 + cSeq + ")") // "El tipo de movimiento informado no es valido: " # "Los tipos validos son 01, 02, 03, 04, 05, 06, 07 e 20. Utilice la coma para informar mas de un tipo. Si quisiera todos los tipos, deje el campo en blanco." # "SEC."
									EndIf
									If !(("#" + cTp + "#") $ cTiposMov)
										Message(OemToAnsi( cMsgTpMov ), lLog)
										lLinOk := .F.
										If !lLog
											Break
										EndIf
									EndIf
									cTpMovtos := if(at(",", cTpMovtos)==0, "", substr(cTpMovtos, at(",", cTpMovtos) + 1))
								end
							EndIf

						Case cOperador == OP_LEE_DEPENDIENTE
							If !IsMneValid(cOperando1, , .F., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/C", .F., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado,, .F., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							If IsMneValid(cOperando2, "C", .F., .F., .T., lLog, STR0028, .F.)
								cPrim := Substr(Alltrim(cOperando2),1,1)
								cUlti := Substr(Alltrim(cOperando2),len(Alltrim(cMnemonico)),1)
								If (cPrim == '"' .or. cPrim == "'") .and. (cUlti == '"' .or. cUlti == "'")
									cTpMovtos := substr(alltrim(cOperando2),2,len(alltrim(cOperando2))-2)
								Else
									cTpMovtos := cOperando2
								EndIf

								while len(cTpMovtos) > 0
									cTp := alltrim(if(at(",",cTpMovtos) > 0, substr(cTpMovtos, 1, at(",",cTpMovtos)-1), cTpMovtos))
									If !(("#" + cTp + "#")$ ("#C#F#O"))
										Message(OemToAnsi( STR0083 + " " + cTp + STR0084 + " (" + STR0058 + cSeq + ")"), lLog) //"O grau de parantesco não é valido: " ### "Os tipos validos são: C (Conjuge), F (Filhos), O (Outros)" ### "SEQ."
										lLinOk := .F.
										If !lLog
											Break
										EndIf
									EndIf
									cTpMovtos := if(at(",", cTpMovtos)==0, "", substr(cTpMovtos, at(",", cTpMovtos) + 1))
								end
							EndIf

						Case cOperador == OP_SIG_TRAY
							If !IsMneValid(cOperando1,, .F., .T., .F., lLog, STR0028) .or.;
							   !IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							If !(Empty(cOperando2) .or. cOperando2 == ME_GEN_MOV)
								Message(OemToAnsi( STR0047 + " (" + STR0058 + cSeq + ")" ), lLog) // "O operador SIG-TRAY so pode ser utilizado com a 2a expressao em branco ou com o mnemonico GEN-MOV"
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf
						Case cOperador == OP_BUSCA_PROCESO
							If !IsMneValid(cOperando1, "", .F., .T., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/N/C", .F., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							If !Empty(cOperando1) .and. len(cOperando1) < 4
								Message(OemToAnsi( STR0057 + " (" + STR0058 + cSeq + ")" ), lLog) // "O ano informado nao eh valido. Favor informar o ano com 4 digitos."
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf
						Case cOperador == OP_BUSCA_SUCURSAL
							If fIsCorpManage() .and. (!empty(cOperando1)  .and. empty(cOperando2))
								If 	(!IsMneValid(cOperando1, "R/C", .T., .F., .F., lLog, STR0028) .or.;
									!IsMneValid(cOperando2,, .F., .T., .F., lLog, STR0029) .or.;
									!IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027))

									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf
							ElseIf fIsCorpManage() .and. (!empty(cOperando1)  .and. !empty(cOperando2))
								If (!IsMneValid(cOperando1, "R/C", .T., .F., .F., lLog, STR0028) .or.;
								 	!IsMneValid(cOperando2, "R/C", .T., .F., .F., lLog, STR0029) .or.;
								  	!IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027))

									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf

							Else
								If !IsMneValid(cOperando1, "", .F., .T., .F., lLog, STR0028) .or.;
								   !IsMneValid(cOperando2, "R/C", .T., .F., .T., lLog, STR0029) .or.;
								   !IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf

							EndIf

							If !empty(cOperando1)
								cPrim := Substr(Alltrim(cOperando1),1,1)
								cUlti := Substr(Alltrim(cOperando1),len(Alltrim(cOperando1)),1)
								If cPrim != cUlti
									Message(OemToAnsi( cOperando1+STR0033 ), lLog) //"## e invalido. //GLAUCIA CRIAR NOVO CH.
									lLinOk := .F.
									Break
								EndIf
								If (cPrim == '"' .or. cPrim == "'") .Or. (cUlti == '"' .or. cUlti == "'")
									cOper1 := substr(alltrim(cOperando1),2,len(alltrim(cOperando1))-2)
								EndIf
								If Empty(cOper1) .or. !(cOper1 $ "12" ) .or. len(cOper1)>1
									Message(OemToAnsi( 'Por favor solamente utilice "1" para Sucursales de la Empresa,  o "2" para Sucursales de la Unidad.' ), lLog)   //GLAUCIA trocar CH
									lLinOk := .F.
									Break
							 	EndIf
							 EndIf


							cPrim := Substr(Alltrim(cOperando2),1,1)
							cUlti := Substr(Alltrim(cOperando2),len(Alltrim(cOperando2)),1)
							If (cPrim == '"' .or. cPrim == "'") .and. (cUlti == '"' .or. cUlti == "'")
								cFilAcum := substr(alltrim(cOperando2),2,len(alltrim(cOperando2))-2)
							Else
								cFilAcum := cOperando2
							EndIf

							While len(cFilAcum) > 0
								cFilVal := alltrim(if(at(",",cFilAcum) > 0, substr(cFilAcum, 1, at(",",cFilAcum)-1), cFilAcum))
								If aScan( aFilVal, { |x| ALLTRIM(x[1]) == ALLTRIM(cFilVal) } )  == 0
									Message(OemToAnsi( STR0076 ) + " " + cFilVal, lLog) // "A Filial informada não é valida: "
									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf
								cFilAcum := If(at(",", cFilAcum)==0, "", substr(cFilAcum, at(",", cFilAcum) + 1))
							Enddo

						Case cOperador == OP_BUSCA_ANO_EMPRESA
							If !IsMneValid(cOperando1, "R/N", .T., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2,, .F., .T., .F., lLog, STR0029) .or.;
							   !IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf


						Case cOperador == OP_CONVIERTE_FECHA
							If !IsMneValid(cOperando1,      , .F., .T., .F., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/N", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/D", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

						Case cOperador == OP_SUMA_IMPHIS .or. cOperador == OP_SUMA_UNIHIS
							If !IsMneValid(cOperando1, "R/C", .T., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/C", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

						Case cOperador == OP_ANO .or. cOperador == OP_MES .or. cOperador == OP_DIA .or. cOperador == OP_DIA_SEMANA
							If !IsMneValid(cOperando1,, .F., .T., .F., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/D", .T., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf
						Case cOperador == OP_STRTOVAL
							If !IsMneValid(cOperando1, "R/C", .T., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/N", .F., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/N", .T., .F., .T., lLog, STR0027)
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf

						Case cOperador == OP_VALTOSTR
							If !IsMneValid(cOperando1, "R/N", .T., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/N", .F., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "R/C", .T., .F., .T., lLog, STR0027)
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf

						//O posicionamento do FILTRO_MOVLI deverá ser antes do SUMA_MOVLI
						Case cOperador == OP_FILTRO_MOVLI
							If !empty(cResultado)
								If  !IsMneValid(cOperando1, "C", .T., .F., .T., lLog, STR0028) .or.;
								   	!IsMneValid(cOperando2, "C", .T., .F., .T., lLog, STR0029) .or.;
							   		!IsMneValid(cResultado,"C", .T., .F., .F., lLog, STR0027) .or. ;
							   		!(cResultado $ ('"LIKE",">=","> =","<=", "< ="'))

									IIf (!(cResultado $ ('"LIKE",">=","> =","<=", "< ="')),Alert(STR0027),)

									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf

							ElseIf	!IsMneValid(cOperando1, "C", .F., .F., .T., lLog, STR0028) .or.;
							   		!IsMneValid(cOperando2, "C", .T., .F., .T., lLog, STR0029) .or.;
							   		!IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf

							For nY:=1 to Len(cOperando1)
			   					cOper1:=Substr(cOperando1,nY,1)
			   					If  (cOper1 $ "-;/|\*:.")
				   			   		Message(OemToAnsi( "("+cOper1+") "+STR0079 ), lLog)//Separador invalido. Favor utilizar virgula (,) ex:'1,2' ou '1','2'
							   		lLinOk := .F.
				   					exit
								EndIf
							next nY

						Case cOperador == OP_FILTRO_ACUM
							If IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)
								If !empty(cOperando1)
									If !IsMneValid(cOperando1, "C", .T., .F., .T., lLog, STR0028) .and.;
										!IsMneValid(cOperando2, "C", .T., .F., .T., lLog, STR0029) .and.;
										!IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)

										lLinOk := .F.
										If !lLog
											Break
										EndIf
									EndIf
								Else
									If empty(cOperando2)
										If  !IsMneValid(cOperando1,, .F., .T., .F., lLog, STR0028) .and.;
											!IsMneValid(cOperando2,, .F., .T., .F., lLog, STR0029) .and.;
									   		!IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)

										   	lLinOk := .F.
											If !lLog
												Break
											EndIf

									   	EndIf

									ElseIf !IsMneValid(cOperando1, "", .F., .T., .F., lLog, STR0028) .and.;
										   !IsMneValid(cOperando2, "C", .T., .F., .T., lLog, STR0029) .and.;
										   !IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)

											lLinOk := .F.
											If !lLog
												Break
											EndIf
									EndIf
								EndIf
							Else
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf

/*							If !IsMneValid(cOperando1, "", .F., .T., .F., lLog, STR0028) .and.;
							   !IsMneValid(cOperando2, "C", .T., .F., .T., lLog, STR0029) .and.;
							   !IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)

								lLinOk := .F.
								If !lLog
									Break
								EndIf
							ElseIf  !IsMneValid(cOperando1,, .F., .T., .F., lLog, STR0028) .and.;
									!IsMneValid(cOperando2,, .F., .T., .F., lLog, STR0029) .and.;
							   		!IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)

									lLinOk := .F.
									If !lLog
										Break
									EndIf

							ElseIf	!IsMneValid(cOperando1, "C", .T., .F., .T., lLog, STR0028) .and.;
									!IsMneValid(cOperando2, "C", .T., .F., .T., lLog, STR0029) .and.;
									!IsMneValid(cResultado,, .F., .T., .F., lLog, STR0027)

									lLinOk := .F.

									If !lLog
										Break
									EndIf
							EndIf                                                                              */

						Case cOperador == OP_SUMA_MOVLI
							//Varredura de todas sequencias anteriores a atual
							If !aCols[n, Len(aCols[n])]
								nLenCols := n-1
								nX:=1
								For nX := 1 To nLenCols
									If cSeq > AllTrim(aCols[nX, nPosSeq])
										//Indicando que existe FILTRO_MOVLI disponível
										IIf (AllTrim(aCols[nX, nPosOpe])== OP_FILTRO_MOVLI, lFiltroMovli:=.T.,)

										//Caso exista algum SUMA_MOVLI que use o FILTRO_MOVLI,
										//Indicaremos que não existe FILTRO_MOVLI disponível para uso
										If (AllTrim(aCols[nX, nPosOpe])== OP_SUMA_MOVLI) .and. empty(aCols[nX, nPosForm1]) .AND. empty(aCols[nX, nPosForm2])
											lFiltroMovli:=.F.
										EndIf

									EndIf
								Next nX
							EndIf


							//Se há FILTRO_MOVLI sem OP_SUMA_MOVLI, poderemos usar SUMA_MOVLI sem Operador1 e Operador2
							If lFiltroMovli   .and. empty(cOperando1) .AND. empty(cOperando2)
								if	!IsMneValid(cOperando1, 	, .F., .T., .F., lLog, STR0028) .or.;
							 		!IsMneValid(cOperando2, 	, .F., .T., .F., lLog, STR0029) .or.;
							   		!IsMneValid(cResultado,"N/R", .T., .F., .T., lLog, STR0027)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf
							Else
								If !Empty(cOperando1)
									If(!IsMneValid(cOperando1,"C/N",.T.,.F.,.T.,lLog, STR0028))
										lLinOk := .F.
										If !lLog
											Break
										EndIf
									EndIf								
								EndIf
								If (!IsMneValid(cOperando2,"C/N/F/R",.T.,.F.,.T.,lLog, STR0029).or.;
									!IsMneValid(cResultado,"N/R",.T.,.F.,.T.,lLog, STR0027))
									lLinOk := .F.
									If !lLog
										Break
									EndIf
								EndIf
								If (IsMneValid(cOperando2,"N", .F., .F., .T., .F., STR0029,.F.) .and. ;
									IsMneValid(cOperando1,"N", .F., .F., .T., .F., STR0028,.F.))
									For nY:=1 to Len(cOperando1)
										cOper1:=Substr(cOperando1,nY,1)
										If (cValToChar(cOper1) == "." )
											cSeparador:=cSeparador+cOper1
											If (Len(cSeparador)>1)
												cMensagem := STR0032 + "'" + cOperando1 + "'" + STR0033 //"O tipo do mnemonico "##" e invalido."
												cMensagem += STR0069 + " " + STR0028 + STR0075+": "+STR0071 //"O campo "##" deve ser preenchido com informações do tipo: Numerica "
												Message(OemToAnsi( cMensagem ), lLog)
												lLinOk := .F.
											EndIf
										EndIf
									Next nY
								ElseIf (IsMneValid(cOperando2,"C", .F., .F., .T., .F., STR0029, .F.) .and.;
										IsMneValid(cOperando1,"C", .F., .F., .T., .F., STR0028, .F.))
									For nY:=1 to Len(cOperando1)
				   						cOper1:=Substr(cOperando1,nY,1)
				   						If  (cOper1 $ "-;/|\*:.")
					   				   		Message(OemToAnsi( "("+cOper1+") "+STR0079 ), lLog)//Separador invalido. Favor utilizar virgula (,) ex:'1,2' ou '1','2'
									   		lLinOk := .F.
					   						exit
										EndIf
									next nY
								EndIf


                            EndIf
							lFiltroMovli	:=	.F.

						Case cOperador == OP_IE_TOTAL_EMP
							If !IsMneValid(cOperando1, "", .F., .T., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "C", .F., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "N/R",.T.,.F.,.T.,lLog, STR0027)
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf
						Case cOperador == OP_IE_TOTAL_CON
							If !IsMneValid(cOperando1, "", .F., .T., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "C", .F., .F., .T., lLog, STR0029) .or.;
							   !IsMneValid(cResultado, "N/R",.T.,.F.,.T.,lLog, STR0027)
								If !lLog
									Break
								EndIf
							EndIf
						Case cOperador == OP_PUNTO_ENT
							If !(Substr(cOperando1,1,2)=="U_")
								cOperando1:="U_"+cOperando1
							EndIf
							If !FindFunction(cOperando1)
								Message(OemToAnsi( cOperando1+ STR0081 ), lLog)// ## " não é uma função RDMAKE ou não esta compilada"
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf
							If !IsMneValid(cResultado,"N/R/C/D/L",.T.,.F.,.T.,lLog, STR0027)
								lLinOk := .F.
								If !lLog
									Break
								EndIf
							EndIf
						Case cOperador == OP_LEE_AST_FIJO
							If !IsMneValid(cOperando1, "R/C", .F., .F., .T., lLog, STR0028) .or.;
							   !IsMneValid(cOperando2, "R/C", .F., .F., .T., lLog, STR0029)
									lLinOk := .F.
									If !lLog
										Break
									EndIf
							EndIf
					EndCase
				EndIf
			EndIf
		EndIf

		DEFAULT lNotTudoOk := .T.
		If ( lNotTudoOk ) .and. valtype(oBrowse) == "O"

			// Coloca Sequencia do novo item em ordem
			aSort( aCols , NIL , NIL , { |x,y| x[ nPosSeq ] < y[ nPosSeq ] } )
			n := aScan( aCols , { |x| x[nPosSeq]  == cSeq } )
			oBrowse:nAt := Max( n , 1 )
			oBrowse:Refresh()

		EndIf

End Sequence

Return(lLinOk)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea291GvTudOk³Autor³Tatiane Matias       ³ Data ³26/09/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gravacao das Informacoes no banco                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea291GvTudOk(	nOpcAlt			,;
								nOpc			,;
								nReg			,;
								aRC2Cols		,;
								aSvRC2Cols		,;
								aRC2Enchoice	,;
								aRC2VirtChoice	,;
								aHeader			,;
								aCols			,;
								aRC3Virtual		,;
								aRC3Recnos		,;
								nUsado			,;
								aSvRC3Cols		;
							  )

Local lGrvTudOk := .T.

Local aNewRecnos		:= {}
Local aColsDel			:= {}
Local cRc2Filial		:= space(FWGETTAMFILIAL)
Local cRc2Formula		:= ""
Local cKeySeek			:= ""
Local cVersao			:= ""
Local lAlter			:= .F.
Local lRC2Alter			:= .F.
Local lRC3Alter			:= .F.
Local lAddNew			:= .F.
Local nChoice			:= 0
Local nChoices			:= 0
Local nHeader			:= 0
Local nHeaders			:= 0
Local nCol				:= 0
Local nCols				:= 0
Local nRecno			:= 0
Local nRecnos			:= 0
Local nDeleted			:= 0
Local nTamSeq			:= 0
Local nRC3Reg			:= 0
Local nRC3Seq			:= 0
Local nPosGhostCol		:= 0
Local nPosRecno			:= Len(aHeader)
Local nRc2Modelo		:= RC2->( FieldPos( "RC2_MODELO" ) )
Local lErrorForm		:= .F.

DEFAULT nOpc			:= 0
DEFAULT nReg			:= 0
DEFAULT aRC2Enchoice	:= {}
DEFAULT aRC2VirtChoice	:= {}
DEFAULT aHeader			:= {}
DEFAULT aCols			:= {}
DEFAULT aRC3Virtual		:= {}
DEFAULT aRC3Recnos		:= {}
DEFAULT nUsado			:= 0

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Quando Confirmada a Opcao e Nao for Visualizacao Grava ou   Ex³
³clui as Informacoes do RC2 e RC3							   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If (;
		( nOpcAlt == 1 );	//Confirmou
		.and.;
		( nOpc != 2 );		//Nao eh Visualizacao
	)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Quando For Copia Posiciona o RC2 No Final do Arquivo 	       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If ( lGpea291Cpy  )
		nOpc := 3 //Inclusao
		PutFileInEof("RC2", @nReg)
		aRC3Recnos := {}
	EndIf

	If ( nOpc == 5 )	//Exclusao
		RC2->( MsGoto( nReg ) )
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Gravando/Incluido ou Excluindo Informacoes do RC2/RC3        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nPosGhostCol := GdFieldPos( "GHOSTCOL"	, aHeader )
	Begin Sequence

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se for Exclusao ( nOpc == 5 )								   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If ( nOpc == 5 )
			If !Empty( nReg )
				Begin Transaction
					RC2->( dbGoto( nReg ) )
					If RecLock( "RC2" , .F. , .F. )
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Deleto os Registros do RC3									   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						DelRecnos( "RC3" , @aRC3Recnos )
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Deleto os Registros do RC2									   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						DelRecnos( "RC2" , { nReg } )
						RC2->( MsUnLock() )
					EndIf
				End Transaction
			EndIf
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se for Inclusao/Alteracao ( nOpc == 3 .or. nOpc == 4 )	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		ElseIf (;
					( nOpc == 3 );
					.or.;
					( nOpc == 4 );
				)

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Atualiza o aRC2Cols com o Conteudo das Variaveis de   Memoria³
			³ para comparacao											   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nChoices	:= Len(aRC2Enchoice)
			For nChoice := 1 To nChoices
				aRC2Cols[1, nChoice ] := GetMemVar(aRC2Enchoice[nChoice, 2])
			Next nChoice

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Houveram Modificacoes no RC2                     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lRC2Alter := !( ArrayCompare( aSvRC2Cols , aRC2Cols ) )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Houveram Modificacoes no RC3                     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lRC3Alter := !ArrayCompare( aCols , aSvRC3Cols )

			// Iniciar a gravacao dos itens //
			Begin Transaction
				If (lRC2Alter)
					If !( lAddNew := Empty( nReg ) )
						RC2->( dbGoto( nReg ) )
						lAddNew := RC2->( Eof() )
					EndIf
					//Se for cópia verifica se existe chave
					If lGpea291Cpy
						RC2->(dbSetOrder(2))
						RC2->(dbGoTop())
						If DbSeek(xFilial("RC2")+aRC2Cols[1 ,2])
							MsgAlert( OemToAnsi(STR0108) , OemToAnsi( STR0021 ) ) //"O código de fórmula informado já existe. Verifique!" ### "Atencao"
							DISARMTRANSACTION()
							lErrorForm := .T.
						EndIf
					EndIf
					If !lErrorForm .And. RC2->(RecLock("RC2", lAddNew, .F.))
						RC2->(FieldPut(FieldPos("RC2_FILIAL") , xFilial("RC2")))
						RC2->(FieldPut(FieldPos("RC2_ORIGEM") , cOrigem))
						For nChoice := 1 To nChoices
							If ( aScan( aRC2VirtChoice , { |cCpo| ( cCpo == aRC2Enchoice[ nChoice , 02 ] ) } ) == 0 )
								RC2->( FieldPut( FieldPos( aRC2Enchoice[ nChoice , 02 ] ) , aRC2Cols[ 1 , nChoice ] ) )
							EndIf
						Next nChoice
						RC2->( MsUnLock() )
					EndIf
				ElseIf lGpea291Cpy
					MsgAlert( OemToAnsi(STR0108) , OemToAnsi( STR0021 ) ) //"O código de fórmula informado já existe. Verifique!" ### "Atencao"
					DISARMTRANSACTION()
					lErrorForm := .T.
				EndIf

				If !lErrorForm

					nReg := RC2->( Recno() )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Garanto o Posicionamento do RC2       					   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					RC2->(MsGoto(nReg))
					cRc2Filial		:= RC2->RC2_FILIAL
					cRc2Formula		:= RC2->RC2_CODIGO
					cKeySeek  := (cRc2Filial + cRc2Formula)

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Obtem o Posicionamento do RC3_SEQFOR        					   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nRC3Seq 	:= GdFieldPos("RC3_SEQFOR", aHeader)
					nDeleted	:= (nUsado + 1)

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Deleto todos os Itens que nao Estao OK					   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					GdSuperDel( aHeader , @aCols , NIL , .T. , GdGetBlock( "RC3" , aHeader , .F. ) )

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Separa os Itens que foram Deletados     					   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					RC3->( dbSetOrder( RetOrdem( "RC3" , "RC3_FILIAL+RC3_CODIGO+RC3_SEQFOR" ) ) )

					If GdSplitDel( aHeader , @aCols , aRC3Recnos , @aColsDel )
						nCols	:= Len( aColsDel )
						For nCol := 1 To nCols
							If RC3->( dbSeek( cKeySeek + aColsDel[ nCol , nRC3Seq ] , .F. ) )
								If RC3->( RecLock( "RC3" , .F. ) )
									RC3->( dbDelete() )
									RC3->( MsUnLock() )
								EndIf
							EndIf
						Next nCol
					EndIf

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Inicializa as Variaveis                 					   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nHeaders	:= Len(	aHeader )
					nCols		:= Len(	aCols	)
					nRecnos		:= Len( aRC3Recnos )
					nTamSeq		:= aHeader[ nRC3Seq , 4 ]

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Reorganizar Sequencia quando pertencer a Manutencao e atuali-³
					³ o array de recnos.                                           ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					For nRecno := 1 To nCols
						If nRecno > nRecnos
							aAdd(aRC3Recnos, 0)
						EndIf
					Next nRecno
					nRecnos		:= Len(aRC3Recnos)

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Gravando as Informacoes no RC3							   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					//If lRC3Alter
					For nRecno := 1 to nCols
						If RC3->( dbSeek(cKeySeek + aCols[nRecno][nRC3Seq]) )
							RC3->( RecLock( "RC3" , .F. ) )
						Else
							RC3->( RecLock( "RC3" , .T. ) )
							RC3->RC3_FILIAL := cRc2Filial
							RC3->RC3_CODIGO := cRc2Formula
							RC3->RC3_ORIGEM := cOrigem
						EndIf

						RC3->RC3_SEQFOR := replicate('0', nTamSeq - len(alltrim(str(nRecno)))) + alltrim(str(nRecno))
						For nHeader := 1 To nHeaders
							If ( aScan( aRC3Virtual , { |cCpo| ( cCpo == aHeader[ nHeader , 02 ] ) } ) == 0 ) .and.;
							aHeader[ nHeader , 02 ] <> 'RC3_SEQFOR'
								RC3->( FieldPut( FieldPos( aHeader[ nHeader , 02 ] ) , aCols[ nRecno , nHeader ] ) )
							EndIf
						Next nHeader

						RC3->(MsUnlock())
						RC3->(aAdd(aNewRecnos, Recno()))
					Next nRecno
					//EndIf
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Verifica se Houveram Modificacoes                            ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					lAlter	:= ( ( lRC2Alter ) .or. ( lRC3Alter ) )

					If (lAlter)
						If Gpea291Lck(nReg)
							/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Grava o Status para Recompilacao ("1")						   ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							RC2->RC2_RECOMP := "1"
							/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³ Grava a Nova Versao do Roteiro							   ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							If (lManutence)
								cVersao	:= Replicate("0", GetSx3Cache("RC2_VERSAO", "X3_TAMANHO"))
								If (nOpc == 3)
									RC2->RC2_VERSAO := __Soma1(cVersao)
								ElseIf (nOpc == 4)
									cVersao := RC2->RC2_VERSAO
									If Empty(cVersao)
										cVersao	:= Replicate("0", GetSx3Cache("RC2_VERSAO", "X3_TAMANHO"))
									EndIf
									RC2->RC2_VERSAO	:= __Soma1(cVersao)
								EndIf
							EndIf

							If nRc2Modelo > 0
								RC2->RC2_MODELO = MV_MODFOL
							EndIf

							RC2->(MsUnLock())
							Rc2RecSry() //Forcar a Recompilacao do Roteiro
							/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Garanto o Lock que so sera Liberado na Saida da Gpea290Mnt()  ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							Gpea291Lck(nReg)
						EndIf
					Else
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Altero Status para Evitar passar pela Rotina de Compilacao uma³
						³vez que não foram feitas modificacoes						   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						nOpcAlt := 0
					EndIf
					
				EndIf

			End Transaction

		EndIf

	End Sequence
	aRC3Recnos := aClone(aNewRecnos)

EndIf

Return(lGrvTudOk)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea291Insert³Autor³                      ³ Data ³          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea291Insert()         								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea291Insert()
Local nNumRec := n
Local nTotRec := Len(aCols)
Local nIndex  := 0
Local nCampos := 0
Local cIndice := StrZero(1,TamSx3('RC3_SEQFOR')[1])
Local nPosSeq := Ascan(aHeader,{|x| Alltrim(x[2])== 'RC3_SEQFOR'})

If Gpea291LinOk(oRc3GetDados:oBrowse)

	Aadd( aCols, Array( Len(aCols[1]) ) )

	aEval(aCols,{|x,nI| aCols[nI][nPosSeq]:=cIndice,cIndice:=Soma1(cIndice)  } )

	For nIndex := nTotRec TO nNumRec STEP -1
		For nCampos:=2 To Len(aCols[1])
			aCols[nIndex+1][nCampos]	:=	aCols[nIndex][nCampos]
		Next nCampos
	Next nIndex

	nCampos:=2
	aEval(aCols[nNumRec],{||if(ValType(aCols[nNumRec][nCampos])=="C",aCols[nNumRec][nCampos]:=Space(aHeader[nCampos][4]),aCols[nNumRec][nCampos]:=0),++nCampos},2,Len(aHeader)-1)
EndIf

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea291Cpy³ Autor ³Tatiane Matias         ³ Data ³01/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea291Cpy( cAlias , nReg , nOpc )							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cAlias = Alias do arquivo                                   ³
³          ³nReg   = Numero do registro                                 ³
³          ³nOpc   = Numero da opcao selecionada                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA160()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea291Cpy( cAlias , nReg , nOpc )

lGpea291Cpy := .T.

Return( Gpea291Mnt( cAlias , nReg , 4 ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea290ExcluChk ³ Autor ³Marinaldo de Jesus³ Data ³29/05/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se a Formula Pode Ser Excluida   					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Gpea290                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea291ExcluChk( cAlias , nReg , nOpc )

Local aArea		:= GetArea()
Local aAreas	:= Array( 01 , 03 )

Local cRc2Fil
Local cFormula
Local cMsgYesNo
Local cTitLog
Local lDelOk


cMsgYesNo := STR0101	//""O Sistema Agora Ira efetuar a Verificacao para ver se a Formula selecionada para"
cMsgYesNo += CRLF
cMsgYesNo += STR0102	//"Exclusao esta sendo utilizada. A verifica‡„o pode ser demorada !!"
cMsgYesNo += CRLF
cMsgYesNo += CRLF
cMsgYesNo += STR0103	//"Confirma a exclus„o da Formula?"

cTitLog := STR0105		//"Log de Ocorrencias na Exclusao de Formulas"


aAreas[01,01] := SRV->( GetArea() )
aAreas[01,02] := {"RV_FILIAL","RV_CODFOR"}
aAreas[01,03] := RetOrdem( "SRV" , "RV_FILIAL+RV_CODFOR" , .T. )


( cAlias )->( MsGoto( nReg ) )
cRc2Fil	    := xFilial( "RC2" )
cFormula	:= Upper( AllTrim( RC2->( RC2_CODIGO ) ) )

lDelOk		:= ChkDelRegs(	cAlias			,;	//01 -> Alias de Dominio
							nReg			,;	//02 -> Registro do Dominio
							nOpc			,;	//03 -> Opcao para a AxDeleta
							cRc2Fil			,;	//04 -> Filial do do Dominio
							cFormula		,;	//05 -> Chave do do Dominio
							aAreas			,;	//06 -> Array contendo informacoes dos arquivos a serem pesquisados
							cMsgYesNo		,;	//07 -> Mensagem para MsgYesNo
							cTitLog			,;	//08 -> Titulo do Log de Delecao
							NIL				,;	//09 -> Mensagem para o corpo do Log
							.F.				,;	//10 -> Se executa AxDeleta
							.T.				,;	//11 -> Se deve Mostrar o Log
							NIL				,;	//12 -> Array com o Log de Exclusao
							NIL				,;	//13 -> Array com o Titulo do Log
							NIL				,;	//14 -> Bloco para Posicionamento no Arquivo
							NIL				,;	//15 -> Bloco para a Condicao While
							NIL				,;	//16 -> Bloco para Skip/Loop no While
							.T.				,;	//17 -> Verifica os Relacionamentos no SX9
							{ "RC3" }		,;	//18 -> Alias que nao deverao ser Verificados no SX9
							NIL				 ;	//19 -> Se faz uma checagem soft
					 	 )

RestArea( aArea )

Return( lDelOk )


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RcaSetFilter³ Autor ³Tatiane Matias       ³ Data ³02/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RcaSetFilter( )												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³consulta padrao RCA                                         ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcaSetFilter()

Local cFiltro	:= ""

//Para modelo padrao, devera ser listado todos os mnemonicos, exceto os
// reservados ("R") e os operadores ("P")
If !(MV_MODFOL == "2")
	cFiltro := "( !(RCA->RCA_TIPO $ ('R/P')) )"

//Para modelo Mexico...
Else
	// quando for campo RC3_OPERA1, listar apenas os operadores
	If ReadVar() == 'M->RC3_OPERA1'
		cFiltro := "(RCA->RCA_TIPO = 'P')"

	// quando for os campos RC3_FORM01, RC3_FORM02 ou RC3_RESULT,
	// listar todos os mnemonicos (inclusive os reservados), exceto os
	// operadores
	ElseIf ReadVar() $ ("M->RC3_FORM01/M->RC3_FORM02/M->RC3_RESULT")
		cFiltro := "( !(RCA->RCA_TIPO = 'P') )"
	EndIf
EndIf

cFiltro := "@#" + cFiltro + "@#"

Return (cFiltro)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³IsMneValid   ³Autor³                      ³ Data ³          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³IsMneValid()            								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function IsMneValid(cMnemonico, cTipos, lObrigat, lEmpty, lMnemonico, lLog, cCpo, lMessage)
Local aArea		:= GetArea()
Local lReturn   := .T.
Local cMensagem := ""
Local cTp       := ""
Local cAuxTipos := cTipos
Local lValid    := .F.
Local cPrim     := ""
Local cUlti     := ""
Local cNumValido :="0123456789." //numeros validos para serem utilizados
Local nAux      := 0

DEFAULT lObrigat   := .T.
DEFAULT lEmpty     := .F.
DEFAULT lMnemonico := .T.
DEFAULT lLog       := .F.
DEFAULT cCpo       := ""
DEFAULT lMessage   := .T.

    If lObrigat .and. Empty(cMnemonico)
		cMensagem := STR0031 + ": " + cCpo
		lReturn := 	.F.
	ElseIf lEmpty .and. !Empty(cMnemonico)
		cMensagem := STR0035 + ": " + cCpo
		lReturn := 	.F.
	ElseIf lMnemonico .and. !Empty(cMnemonico)
		RCA->( dbSetOrder(1) )
		If RCA->( dbSeek(xFilial("RCA") + cMnemonico) )  .and. (Alltrim(RCA->RCA_MNEMON) == Alltrim(cMnemonico))
			If RCA->RCA_TIPO == 'F'
				If Empty(RCA->RCA_ALIAS) .or. Empty(RCA->RCA_CAMPO)
					cMensagem := STR0064 + " " + cMnemonico + STR0065   //"A tabela ou o campo que está relacionado ao mnemonico "###" não foi informado."
					lReturn := .F.
				Else
					dbSelectArea(RCA->RCA_ALIAS)
					If (RCA->RCA_ALIAS)->( FieldPos(RCA->RCA_CAMPO) ) > 0
						If !(GetSx3Cache( RCA->RCA_CAMPO , "X3_TIPO" ) $ cTipos)
							cMensagem := STR0032 + "'" + cMnemonico + "'" + STR0033 //"O tipo do mnemonico "##" e invalido."
							cMensagem += STR0069 + " " + cCpo + STR0075 //"O campo "##" deve ser preenchido com informações do tipo "
							cMensagem += fDescTipos(cTipos)
							lReturn := .F.
						EndIf
					Else
						cMensagem := STR0066 + " " + cMnemonico + " " + STR0026 //"O campo que está relacionado ao mnemonico "
						cMensagem += "( " + STR0067 + " " + AllTrim(RCA->RCA_ALIAS)  //"Tabela:"
						cMensagem += "/ " + STR0068 + " " + AllTrim(RCA->RCA_CAMPO) + ")"  //"Campo:"
						lReturn   := .F.
					EndIf
					(RCA->RCA_ALIAS)->( dbCloseArea() )
				EndIf
			ElseIf RCA->RCA_TIPO == 'R' .and. Substr(cMnemonico,2,3) == "AUX"
				If !(Substr(cMnemonico,1,1) $ cTipos)
					cMensagem := STR0032 + "'" + cMnemonico + "'" + STR0033 //"O tipo do mnemonico "##" e invalido."
					cMensagem += STR0069 + " " + cCpo + STR0075 //"O campo "##" deve ser preenchido com informações do tipo "
					cMensagem += fDescTipos(cTipos)
					lReturn   := .F.
				EndIf
			ElseIf !(RCA->RCA_TIPO == 'F' .or. RCA->RCA_TIPO $ cTipos)
				cMensagem := STR0032 + "'" + cMnemonico + "'" + STR0033 //"O tipo do mnemonico "##" e invalido."
				cMensagem += STR0069 + " " + cCpo + STR0075 //"O campo "##" deve ser preenchido com informações do tipo "
				cMensagem += fDescTipos(cTipos)
				lReturn   := .F.
			EndIf
		Else
			lValid := .F.
			While len(cTipos) > 0

				cTp := If(at("/",cTipos) > 0, substr(cTipos,1,at("/",cTipos)-1), cTipos)
				Do Case
					Case cTp == "D"
						If !Empty(CTOD(cMnemonico))
							lValid := .T.
						EndIf
					Case cTp == "N"
						If cMnemonico == "0" .or. !(val(cMnemonico) == 0)
							lValid := .T.
							For nAux := 1 to len(cMnemonico)
								If nAux == 1 .and. Substr(cMnemonico,1,1) == "-"
									Loop
								EndIf
								If !(Substr(cMnemonico,nAux,1) $ cNumValido)
									lValid := .F.
									Exit
								EndIf
							Next nAux
						EndIf
					Case cTp == "L"
						If type(cMnemonico) == "L"
							lValid := .T.
						EndIf
					Case cTp == "C"
						cPrim := Substr(Alltrim(cMnemonico),1,1)
						cUlti := Substr(Alltrim(cMnemonico),len(Alltrim(cMnemonico)),1)
						If (cPrim == '"' .or. cPrim == "'") .and. (cUlti == '"' .or. cUlti == "'")
							lValid := .T.
						EndIf
				EndCase
				If lValid
					Exit
				EndIf
				cTipos := if(at("/",cTipos) > 0, substr(cTipos,at("/",cTipos)+1), "")
			End
			If !lValid
				cMensagem := STR0032 + "'" + cMnemonico + "'" + STR0033 //"O tipo do mnemonico "##" e invalido."
				cMensagem += STR0069 + " " + cCpo + STR0075 //"O campo "##" deve ser preenchido com informações do tipo "
				cMensagem += fDescTipos(cAuxTipos)
			EndIf
			lReturn := lValid
		EndIf

		/*If !lReturn
			cMensagem := STR0032 + "'" + cMnemonico + "'" + STR0033
		EndIf       */
	EndIf

	If !lReturn .and. lMessage
		cMensagem += " (" + STR0058 + aCols[n, GdFieldPos("RC3_SEQFOR")] + ")"
		Message(OemToAnsi( cMensagem ), lLog)
	EndIf

	RestArea(aArea)

Return lReturn

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Message      ³Autor³                      ³ Data ³          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Message()               								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Message(cMsg, lLog)

If lLog
	AddMsgLog(cMsg)
Else
	MsgAlert( cMsg , OemToAnsi( STR0021 ) ) //"Atencao"
EndIf

Return NIL

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GpEtiquetas  ³Autor³                      ³ Data ³          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea291Insert()         								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GpEtiquetas(aEtiquetas, aEtqUsadas, lLog)
Local lOk  :=.T.
Local nInd := 0
Local cEtq := ""

DEFAULT aEtiquetas := {}
DEFAULT aEtqUsadas := {}

For nInd := 1 To Len(aEtqUsadas)
	cEtq = AllTrim(aEtqUsadas[nInd])
	If aScan(aEtiquetas,{|x| x[1]==cEtq } ) == 0
		Message(OemToAnsi(STR0041  + cEtq + STR0042), lLog) // "A Etiqueta "#" nao esta definida..."
		lOk := .F.
		Exit
	EndIf
Next

Return lOk

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GpBusca      ³Autor³                      ³ Data ³          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GpBusca()               								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GpBusca(lLog)
Local lOk :=.T.
Local nPosOperad := GdFieldPos("RC3_OPERA1")
Local nPosOpera1 := GdFieldPos("RC3_FORM01")
Local nPosOpera2 := GdFieldPos("RC3_FORM02")
Local nPosBUSCA  := 0
Local nPosHASTA  := 0
Local nInd       := 0
Local cTab       := ""
Local cCpo       := ""
Local lFind      := .F.

	// Verificar se existe os operadores "HASTA-XXX"
	// So pode utilizar se o operador "BUSCA" for chamado antes
	If (nPosHASTA := aScan(aCols,{|x| (Alltrim(x[nPosOperad]) == OP_HASTA_IGUAL .or.;
									   Alltrim(x[nPosOperad]) == OP_HASTA_MAYOR .or.;
									   Alltrim(x[nPosOperad]) == OP_HASTA_MENOR .or.;
									   Alltrim(x[nPosOperad]) == OP_HASTA_MAYOR_IGUAL .or.;
									   Alltrim(x[nPosOperad]) == OP_HASTA_MENOR_IGUAL) .and.;
									   x[len(x)]==.F. } )) > 0
		nPosBUSCA := aScan(aCols,{|x| Alltrim(x[nPosOperad]) == OP_BUSCA .and.;
									   x[len(x)]==.F.} )
		If nPosBUSCA == 0 .or. nPosBUSCA > nPosHASTA
 			Message(OemToAnsi(STR0045), lLog) // "Os operadores HASTA-IGUAL,HASTA-MAYOR e HASTA-MENOR so podem ser usados apos o operador BUSCA."
			lOk := .F.
		Else
			For nInd := nPosBUSCA to Len(aCols)
				If !aCols[ nInd , Len( aCols[ nInd ] ) ]
					If Alltrim(aCols[nInd,nPosOperad]) == OP_BUSCA
						cTab := Alltrim(aCols[nInd,nPosOpera2])+ Space(GetSx3Cache( "RCB_CODIGO" , "X3_TAMANHO" )-len(Alltrim(aCols[nInd,nPosOpera2])))
					ElseIf Alltrim(aCols[nInd,nPosOperad]) == OP_HASTA_IGUAL .or.;
						   Alltrim(aCols[nInd,nPosOperad]) == OP_HASTA_MAYOR .or.;
						   Alltrim(aCols[nInd,nPosOperad]) == OP_HASTA_MENOR .or.;
						   Alltrim(aCols[nInd,nPosOperad]) == OP_HASTA_MAYOR_IGUAL .or.;
						   Alltrim(aCols[nInd,nPosOperad]) == OP_HASTA_MENOR_IGUAL
						cCpo := substr(aCols[nInd,nPosOpera1],10,2) //ELEMENTO-XX
						dbSelectArea("RCB")
						RCB->( dbSetOrder(1) ) //Filial + Codigo
						If (RCB->( dbSeek( xFilial("RCB") + cTab)))
							lFind := .F.
							While RCB->( !Eof() .and. RCB_FILIAL + RCB_CODIGO == xFilial("RCB") + cTab )
								If RCB->RCB_ORDEM == cCpo
									lFind := .T.
									exit
								EndIf
								RCB->( dbSkip() )
							end

							If !lFind
								Message(OemToAnsi( STR0046 + cTab), lLog) // "Campo nao encontrado na definicao da tabela "
								lOk := .F.
								Exit
							EndIf
						EndIf
					EndIf
				EndIf
			Next nInd
		EndIf
	EndIf

Return lOk

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GpTray       ³Autor³                      ³ Data ³          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GpTray()                								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GpTray(lLog)
Local nInd       := 0
Local lOk        := .T.
Local nPosOperad := GdFieldPos("RC3_OPERA1")
Local nPosOpera1 := GdFieldPos("RC3_FORM01")
Local nPosOpera2 := GdFieldPos("RC3_FORM02")
Local nLeeTray   := 0
Local nSigTray	 := 0

	For nInd := 1 to Len(aCols)
		If !aCols[ nInd , Len( aCols[ nInd ] ) ]
			If Alltrim(aCols[nInd,nPosOperad]) == OP_LEE_TRAY
				nLeeTray++
			ElseIf Alltrim(aCols[nInd,nPosOperad]) == OP_SIG_TRAY
				nSigTray++
				If nLeeTray < nSigTray
					Message(OemToAnsi(STR0050), lLog) // "O operador SIG-TRAY deve fechar um ciclo iniciado pelo operador LEE-TRAY. Existem mais operadores SIG-TRAY do que LEE-TRAY."
					lOk := .F.
					Exit
				EndIf
			ElseIf (Alltrim(aCols[nInd,nPosOperad]) == OP_PRIMER_REG_TRAY .and. nLeeTray = 0) .or.;
		    	   (Alltrim(aCols[nInd,nPosOperad]) == OP_ULTIMO_REG_TRAY .and. nLeeTray = 0) .or.;
				   ((Alltrim(aCols[nInd,nPosOpera1]) == ME_DIAS_TRAY_SIG .or. Alltrim(aCols[nInd,nPosOpera2]) == ME_DIAS_TRAY_SIG) .and.;
				     nLeeTray = 0)
						Message(OemToAnsi(STR0049), lLog) // "Os operadores PRIMER-REG-TRAY e ULTIMO-REG-TRAY e o mnemonico DIAS-TRAY-SIG devem ser utilizados apos o operador LEE-TRAY"
						lOk := .F.
						Exit
			EndIf
		EndIf
	Next nInd

Return lOk

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GpDepen      ³Autor³                      ³ Data ³          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Validacao Total do Operador LEE_DEPENDIENTES               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GpDepend()              								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GpDepen(lLog)
Local nInd       := 0
Local lOk        := .T.
Local nPosOperad := GdFieldPos("RC3_OPERA1")
Local nLeeDepen	 := 0
Local nSigDepen  := 0

	For nInd := 1 to Len(aCols)
		If !aCols[ nInd , Len( aCols[ nInd ] ) ]
			If Alltrim(aCols[nInd,nPosOperad]) == OP_LEE_DEPENDIENTE
				nLeeDepen++
			ElseIf Alltrim(aCols[nInd,nPosOperad]) == OP_SIG_DEPENDIENTE
				nSigDepen++
				If nLeeDepen < nSigDepen
					Message(OemToAnsi(STR0085), lLog) // "O operador SIG_DEPENDIENTE deve fechar um ciclo iniciado pelo operador LEE_DEP. Existem mais operadores SIG_DEPENDIENTES do que LEE_DEP."
					lOk := .F.
					Exit
				EndIf
			ElseIf (Alltrim(aCols[nInd,nPosOperad]) == OP_PRIMER_REG_DEP .and. nLeeDepen = 0) .or.;
		    	   (Alltrim(aCols[nInd,nPosOperad]) == OP_ULTIMO_REG_DEP .and. nLeeDepen = 0)
					Message(OemToAnsi(STR0086), lLog) // "Os operadores PRIMER_REG_DEP e ULTIMO_REG_DEP devem ser utilizados apos o operador LEE_DEP"
					lOk := .F.
					Exit
			EndIf
		EndIf
	Next nInd

Return lOk

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³AtivaF11    ºAutor  ³Tatiane Matias     º Data ³  09/11/07  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Ativa consulta F11, mostrando todas as tabelas disponiveis  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Gpea291                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function AtivaF11()
Local aTables   := {}
Local aArrayF11	:=	{}
Local MvPar
Local cTitulo   := STR0053
Local nX
Local MvParDef  := ""

If ReadVar() == 'M->RC3_FORM02'
	aTables := fListTable()

	cAlias := Alias() 				// Salva Alias Anterior
	MvPar  := M->RC3_FORM02	        // Carrega Nome da Variavel do Get em Questao
	MvRet  := "M->RC3_FORM02"		// Iguala Nome da Variavel ao Nome variavel de Retorno

	For nX:=1 To Len(aTables)
		If aTables[nX][6] == 1
			Aadd(aArrayF11,aTables[nX][1])
			MvParDef += aTables[nX][1]
		EndIf
	Next

	If f_Opcoes(@MvPar,cTitulo,aArrayF11,MvParDef,,,.T., 3)  // Chama funcao f_Opcoes
		&MvRet := mvpar  // Devolve Resultado
	EndIf

	dbSelectArea(cAlias) // Retorna Alias
EndIf

Return .T.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea291Vld³ Autor ³Tatiane Matias         ³ Data ³21/12/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar todas as formulas                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea291Vld( cAlias , nReg , nOpc )							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cAlias = Alias do arquivo                                   ³
³          ³nReg   = Numero do registro                                 ³
³          ³nOpc   = Numero da opcao selecionada                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea291Vld(cAlias, nReg, nOpc)
Return (ProcGpe({|lEnd| VldFormulas(cAlias, nReg, nOpc)},,,.T.))

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³VldFormulas³ Autor ³Tatiane Matias         ³ Data ³21/12/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Valida todas as formulas e gera log com as inconsistencias  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³VldFormulas( cAlias , nReg , nOpc )							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cAlias = Alias do arquivo                                   ³
³          ³nReg   = Numero do registro                                 ³
³          ³nOpc   = Numero da opcao selecionada                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function VldFormulas(cAlias, nReg, nOpc)

Local cKeySeek    := ""
Local nUsado      := 0
Local aRc3Virtual := {}
Local aRc3Visual  := {}
Local aNotFields  := {}
Local aRc3Recnos  := {}
Local nTamSeq     := GetSx3Cache("RC3_SEQFOR", "X3_TAMANHO")
Local cLogName    := ""
Local cTime 	  := Time()
Local nTotReg	  := 0
Local cAliasMestra := ""

Private aCols     := {}
Private aHeader   := Array(5, __ELEMENTOS_AHEADER__)


	dbSelectArea('RC2')
	RC2->(dbSetOrder(2))

	If !(RC2->(Eof()))

		cAliasMestra:= "QRC2"
		BeginSql alias cAliasMestra
			SELECT COUNT(*) TOTALREG
			FROM %table:RC2% RC2
	 	    WHERE  RC2.%notDel%
		EndSql
		nTotReg := (cAliasMestra)->TOTALREG
		(cAliasMestra)->(DbCloseArea())

		GPProcRegua(nTotReg)
		GPIncProc( OemToAnsi(STR0059) )

		dbSelectArea('RC2')
		RC2->( dbSetOrder(2) )
		RC2->( dbGoTop() )

		dbSelectArea('RC3')
		RC3->( dbSetOrder(3) )
		RC3->( dbGoTop() )

		aAdd(aNotFields, "RC2_ORIGEM")
		aAdd(aNotFields, "RC3_FILIAL")
		aAdd(aNotFields, "RC3_CODIGO")

		//Monta Header RC3
		Gpea291aHead()

		cLogName := "LOG_FORMULAS_"+;
					Replicate("0",2-Len(AllTrim(Str(Day(dDataBase)))))+;
					AllTrim(Str(Day(dDataBase)))+;
					Replicate("0",2-Len(AllTrim(Str(Month(dDataBase)))))+;
					AllTrim(Str(Month(dDataBase)))+Alltrim(Str(Year(dDataBase)))+;
					Substr(cTime,1,2)+Substr(cTime,4,2)+SubStr(cTime,7)+".LOG"

		CreateLog(cLogName)

		While !(RC2->(Eof()))

			//Limpa aCols
			aCols := {}

			AddMsgLog(Replicate("-",50))
			AddMsgLog(OemToAnsi(STR0060) + RC2->RC2_CODIGO)
			GPIncProc(OemToAnsi(STR0060) + RC2->RC2_CODIGO)

			cKeySeek := RC2->(RC2_FILIAL+RC2_CODIGO)
			aCols := RC3->( GdMontaCols( aHeader 		,;	// 01 -> Array com os Campos do Cabecalho da GetDados
										 @nUsado 		,;	// 02 -> Numero de Campos em Uso
										 @aRc3Virtual 	,;	// 03 -> [@]Array com os Campos Virtuais
										 @aRc3Visual 	,;	// 04 -> [@]Array com os Campos Visuais
										 "RC3"			,;	// 05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
										 aNotFields 	,;	// 06 -> Opcional, Campos que nao Deverao constar no aHeader
										 @aRc3Recnos 	,;	// 07 -> [@]Array unidimensional contendo os Recnos
										 "RC2"			,;	// 08 -> Alias do Arquivo Pai
										 cKeySeek		,;	// 09 -> Chave para o Posicionamento no Alias Filho
										 NIL			,;	// 10 -> Bloco para condicao de Loop While
										 NIL			,;	// 11 -> Bloco para Skip no Loop While
										 NIL			,;	// 12 -> Se Havera o Elemento de Delecao no aCols
										 NIL			,;	// 13 -> Se cria variaveis Publicas
										 NIL			,;	// 14 -> Se Ser	a considerado o Inicializador Padrao
										 NIL			,;	// 15 -> Lado para o inicializador padrao
										 NIL			,;	// 16 -> Opcional, Carregar Todos os Campos
										 NIL			,;	// 17 -> Opcional, Nao Carregar os Campos Virtuais
										 NIL			,;	// 18 -> Opcional, Utilizacao de Query para Selecao de Dados
										 NIL			,;	// 19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP ) - utilizado com o parametro 10
										 NIL			,;	// 20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP ) - utilizado com o parametro 11
										 .T.			,;	// 21 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
										 NIL			,;	// 22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
										 NIL			,;	// 23 -> Verifica se Deve Checar se o campo eh usado
										 NIL			,;	// 24 -> Verifica se Deve Checar o nivel do usuario
										 NIL			,;	// 25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
										 NIL			,;	// 26 -> [@]Array que contera as chaves conforme recnos
										 NIL			,;	// 27 -> [@]Se devera efetuar o Lock dos Registros
										 NIL			,;	// 28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
								         NIL			,;	// 29 -> Numero maximo de Locks a ser efetuado
										 .T.			 ;	// 30 -> Utiliza Numeracao na GhostCol
									     ) )


			Gpea291aHead()

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Modifica Sequencia com StrZero()				         	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nPosSeq	  := GdFieldPos( "RC3_SEQFOR" )
			aEval( @aCols , { |x| x[ nPosSeq	 ] := StrZero( Val( x[ nPosSeq	 ] ) , nTamSeq )})

			Gpea291TudOk(NIL,.T.)

			RC2->( dbSkip() )
		end
		CloseLogCalc()
	EndIf

	If MsgNoYes( STR0061 ) //"Finalizada a validacao das Formulas. Deseja consultar o log gerado?"
		Gpea291SwLog(cLogName)
	EndIf
Return(nOpc)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea291SwLog³ Autor ³Tatiane Matias       ³ Data ³27/12/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Mostra as inconsistencias de todas as formulas              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea291SwLog()							                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea291SwLog()
Local aSvKeys		:= GetKeys()
Local aSource       := {}
Local aListbox      := {}
Local aAdvSize		:= MsAdvSize( .T. , .F. )
Local aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
Local aObjCoords	:= {{ 000 , 000 , .T. , .T. }}
Local aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
Local cMsgInfo      := ""
Local cLogName      := RetNameLog()
Local nHandle       := 0
Local nOpenOk       := 0
Local nLoop         := 0
Local oDlg
Local oFont
Local oGroup
Local oLbxSource
Local bSet15		:= { || RestKeys() , oDlg:End() }
Local bSet24		:= { || RestKeys() , oDlg:End() }
Local bDialogInit	:= { || EnchoiceBar( oDlg , bSet15 , bSet24 ) }

	Begin Sequence
		If !File( cLogName, 1 )
			cMsgInfo := STR0062	//"Nao foi possivel encontrar o arquivo:"
			cMsgInfo += CRLF
			cMsgInfo += cLogName
			cMsgInfo += CRLF
			Break
		EndIf

		If ( ( nHandle := fOpen( cLogName,,1 ) ) < 0 )
			nOpenOk := 0
			While (!( fError() == 0 ) .and. ( ++nOpenOk <= 50 ) )
				Sleep( 1000 )
				If ( ( nHandle := fOpen( cLogName,,1 ) ) > 0 )
					Exit
				EndIf
			End While
		EndIf

		If ( nHandle < 0 )
			cMsgInfo := STR0063 //"Nao foi possivel abrir o arquivo:"
			cMsgInfo += CRLF
			cMsgInfo += cLogName
			cMsgInfo += CRLF
			Break
		EndIf
		fClose( nHandle )

		aSource := FileSrvToArr( cLogName, 1 )
		If ( Empty( aSource ) )
			cMsgInfo := STR0063 //"Nao foi possivel abrir o arquivo:"
			cMsgInfo += CRLF
			cMsgInfo += cLogName
			cMsgInfo += CRLF
			Break
		EndIf

		For nLoop := 1 To Len( aSource )
			If substr(aSource[ nLoop ],1,10) = replicate("-", 10)
				cLine := " " + CRLF
			ElseIf substr(aSource[ nLoop ],1,15) = substr(AllTrim(STR0060),1,15)
				cLine := aSource[ nLoop ]
			Else
				cLine := space(10) + aSource[ nLoop ]
			EndIf
			aAdd( aListbox , { nLoop , cLine } )
		Next nLoop

		DEFINE FONT oFont NAME "Courier New" SIZE 0,-11 BOLD
		DEFINE MSDIALOG oDlg TITLE cCadastro From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME STATUS PIXEL

			oLbxSource				:= TWBrowse():New( aObjSize[1,1],aObjSize[1,2],aObjSize[1,4],aObjSize[1,3],NIL,{ "" , "" },NIL,oDlg,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,.F.,NIL,.T.,NIL,.F.,NIL,NIL,NIL)
			oLbxSource:SetArray( aListbox )
			oLbxSource:bLine 		:= { || LineLstBox( oLbxSource , .F. ) }

		ACTIVATE MSDIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED
		RestKeys( aSvKeys , .T. )
	End Sequence

	If !Empty( cMsgInfo )
		MsgInfo( cMsgInfo )
	EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³SeqWhen     ³ Autor ³Tatiane Matias       ³ Data ³28/12/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Habilitar ou desabilitar o campo sequencia conforme a versao³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³SeqWhen()     							                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Campo RC3_SEQFOR                                          ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SeqWhen()
return if(!(MV_MODFOL == "2"), .T., .F.)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fDescTipos  ³ Autor ³Tatiane Matias       ³ Data ³08/05/2008 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna a descricao de todos os tipos passados como parametro³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA291                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fDescTipos(cTipos)
Local cDesc := ""
Local cTp   := ""

	While len(cTipos) > 0
		cTp := if(at("/",cTipos) > 0, substr(cTipos,1,at("/",cTipos)-1), cTipos)
		Do Case
			Case cTp == "D"
				cDesc += " " + STR0070 + "," //"Data"
			Case cTp == "N"
				cDesc += " " + STR0071 + "," //"Numerico"
			Case cTp == "L"
				cDesc += " " + STR0072 + "," //"Logico"
			Case cTp == "C"
				cDesc += " " + STR0073 + "," //"Caracter"
			Case cTp == "R"
				cDesc += " " + STR0074 + "," //"Reservado"
		EndCase
		cTipos := if(at("/",cTipos) > 0, substr(cTipos,at("/",cTipos)+1), "")
	End
	If !Empty(cDesc) .and. at(",",cDesc) > 0
		cDesc := substr(cDesc,1,len(cDesc)-1)
	EndIf

Return cDesc

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Função    ³Gpea290Marks³Autor³MOHANAD ODEH           ³ Data ³01/07/2011³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descrição ³ CONTROLE DAS IMAGENS DA LEGENDA                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea290Marks()											    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea290Marks()

Local aMarks := {}

aMarks	:=	{;
				{"RC2->RC2_ORIGEM=='U_'", "BR_VERDE"},;
				{"RC2->RC2_ORIGEM=='  '", "BR_VERDE"},;
				{"RC2->RC2_ORIGEM=='S_'", "BR_AZUL"};
			 }

Return(aClone(aMarks))


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea291Leg   ³Autor³MOHANAD ODEH          ³ Data ³01/07/2011³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Criacao da Legenda                                         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea291Leg()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA291()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea291Leg()

Local aLegenda	:= {}
Local aSvKeys	:= GetKeys()

aLegenda := {;
				{"BR_AZUL", OemToAnsi(STR0090)} ,; // "Formula Definida Pelo Sistema"
				{"BR_VERDE", OemToAnsi(STR0091)}  ; // "Formula Definida Pelo Usuario"
			}

BrwLegenda(cCadastro,OemToAnsi(STR0092)	, aLegenda)// "Legenda do Cadastro de Formulas"

RestKeys(aSvKeys)

Return(NIL)

Static Function Gpea291Lck(nReg)

Local cMayIUseCode

RC2->(MsGoto(nReg))
If (;
		IsMemVar("RC2_ORIGEM");
		.and.;
		IsMemVar("RC2_CODIGO");
	)
	cMayIUseCode := GetMemVar("RC2_ORIGEM") + GetMemVar("RC2_CODIGO")
Else
	cMayIUseCode := RC2->(RC2_ORIGEM + RC2_CODIGO)
EndIf


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Lock do Registro do RC2                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Return( WhileNoLock( "RC2" , { nReg } , { cMayIUseCode} , 10 , 2 , .T. , 1 , 10 , NIL , .T. ) )


Static Function MenuDef()
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Define Array contendo as Rotinas a executar do programa      ³
³ ----------- Elementos contidos por dimensao ------------     ³
³ 1. Nome a aparecer no cabecalho                              ³
³ 2. Nome da Rotina associada                                  ³
³ 3. Usado pela rotina                                         ³
³ 4. Tipo de Transa‡„o a ser efetuada                          ³
³    1 - Pesquisa e Posiciona em um Banco de Dados             ³
³    2 - Simplesmente Mostra os Campos                         ³
³    3 - Inclui registros no Bancos de Dados                   ³
³    4 - Altera o registro corrente                            ³
³    5 - Remove o registro corrente do Banco de Dados          ³
³    6 - Copiar                                                ³
³    7 - Legenda                                               ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aRotina := {}

	aAdd( aRotina , { OemToAnsi(STR0093), "PesqBrw"	 , 0 , 1 } ) // "Pesquisar"
	aAdd( aRotina , { OemToAnsi(STR0094), "Gpea291Mnt" , 0 , 2 } ) // "Visualizar"
	aAdd( aRotina , { OemToAnsi(STR0095), "Gpea291Mnt" , 0 , 3 } ) // "Incluir"
	aAdd( aRotina , { OemToAnsi(STR0096), "Gpea291Mnt" , 0 , 4 } ) // "Alterar"
	aAdd( aRotina , { OemToAnsi(STR0097), "Gpea291Mnt" , 0 , 5 } ) // "Excluir"
	aAdd( aRotina , { OemToAnsi(STR0098), "Gpea291Cpy" , 0 , 6 } ) // "Copiar"
	aAdd( aRotina , { OemToAnsi(STR0099), "Gpea291Leg" , 0 , 7 } ) // "Legenda"
	aAdd( aRotina , { OemToAnsi(STR0100), "Gpea291Vld" , 0 , 6 } ) // "Val. Formulas"


Return aRotina

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gpRCAFiltro  ³Autor³Christiane Vieira      ³Data³13/12/2011³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Filtro da Consulta Padrao									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gpRCAFiltro()

Local cFiltro	:= "(RCA->RCA_FILIAL == '" + xFilial("RCA") + "')"
Local cVar		:= ReadVar()

If cVar == "M->RC3_OPERA1" .OR. cVar == "M->RC3_FORM01" .OR. cVar == "M->RC3_FORM02" .Or. cVar == "M->RC3_RESULT"
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf
	If !cVar == "M->RC3_OPERA1" // Não é do tipo Parâmetro
		cFiltro := "!"
	EndIf
	cFiltro	+= "(RCA->RCA_TIPO == 'P')"
EndIf

cFiltro := "@#" + cFiltro + "@#"

Return ( cFiltro )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea160Copy	    ³Autor³Christiane Vieira  ³ Data ³29/12/2011³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Copia Linha da Fórmula										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea291CopyItem()											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA291														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³Array contendo a Copia da Linha aTual				 		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                           									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea291CopyItem()
Return( aClone( aCols[ n ] ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea291Paste    ³Autor³Christiane Veira   ³ Data ³29/12/2011³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Cola Linha da Fórmula										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160Paste( aPaste )										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA291														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³lRet														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                           									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea291Paste( aPaste )

Local nPosSeq		:= GdFieldPos("RC3_SEQFOR")
Local cSeq		 	:= AllTrim(aCols[n,nPosSeq])
Local nX

If !Empty( aPaste )
	For nX := 1 To Len( aHeader )
			aCols[n, nX] := aPaste[nX]
	Next nX

    aCols[ n , nPosSeq ] := cSeq
    oRc3GetDados:lNewLine := .F.
    oRc3GetDados:lEditLine := .T.
    oRc3GetDados:oBrowse:Refresh(.T.)

EndIf

Return( NIL )
