#INCLUDE 'PONA210.CH'
#INCLUDE "PROTHEUS.CH"
#INCLUDE "PONCALEN.CH"
    
#DEFINE Confirma 1                  
#DEFINE Redigita 2
#DEFINE Abandona 3

Static lPnaGrv := ExistBlock( "PNA210GRV" )

/*


Ŀ
Funo     PONA210   Autor  Alexsandro Pereira     Data  08.03.00 
Ĵ
Descrio  Manutencao dos abonos                                      
Ĵ
 Uso       Generico                                                   
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
Marinaldo   24/10/01MelhorMelhoria na Tela de Visualizacao dos   abo 
            --------------nos (GetDados) e Inicio da Preparacao para 
            --------------que o Programa possa ser Incluso no   Menu 
            --------------do SIGAPON								   
Marinaldo   25/10/01MelhorIncluida Funcao AcertaSX3 para acerto   no 
            --------------Dicionario de Dados (Devera ser   Excluida 
            --------------para a Proxima Versao) e Permitir que    a 
            --------------Rotina de Abono Possa ser Incluida no Menu 
            --------------do SIGAPON.								   
Mauricio MR 30/10/01------Eliminacao de linha nova na Alteracao.     
Mauricio MR 30/10/01MelhorFornecimento de Horario para o primeiro    
                    ------abono digitado. Compatibilizacao da grava- 
                    ------cao de Horas/Codigo de Abono com manuten-  
                    ------cao direta de abonos via menu.             
Marinaldo   31/10/01MelhorEste Programa nao podera mais ser  chamado 
                    ------a partir do Menu. As Chamadas sempre  deve 
                    ------rao vir do PONA130(Manutencao de Apontamen 
                    ------tos) e terao tratamento diferenciado    de 
                    ------acordo com o Botao Selecionado.            
Mauricio MR 06/12/01MelhorImplementacao do TP_MARCA. Toda Gravacao/  
                    ------Leitura dos abonos estara baseada no CC do 
                    ------arquivo de apontamento(Se ja existir) ou   
                    ------do array de apontamento(caso contrario.    
                    ------Eliminacao do Tratamento de Chamadas Dire  
                    ------tas do Menu nas Rotinas de Gravacao e Dele 
                    ------cao.                                       
                    ------Identificacao do Tp de Marcacao junto ao      
                    ------evento na tela de manut. abonos.           
Marinaldo   11/12/01AcertoNao Recriar o Calendario de Marcacoes    e 
                    ------Nem Redefinir o Periodo de Apontamento   e 
                    ------Restaurar o n no Retorno da Funcao         
======================================================================= 
                         *** Versao 7.10 ***                            
======================================================================= 
Mauricio MR 21/02/02MelhorA)Retirada da Funcao AcertaSX3 em virtude  
                    ------do transporte das alteracoes que ela reali   
                    ------zava para o SX3.                             
Mauricio MR 19/06/02MelhorA)Alterada a funcao pn210Grava para tratar 
                    ------gravacao "em memoria" dos abonos(Pona280)     
Mauricio MR 24/06/02MelhorA)Criadas as funcoes:                      
                    ------Pn210Horas --> Calcula a Hora Final Abono    
                    ------Pn210Evento, PnTpMarca, Pn210CC,Pn210Data    
                    --------> sao funcoes inicializadoras padroes      
                    ------    dos respectivos campos.                  
Mauricio MR 24/06/02MelhorA)Alterada a funcao PnTotAbo, retiradas    
                    ------instrucoes desnecessarias.                    
Mauricio MR 05/09/02MelhorA)Criada a Funcao Pn210VCodAb para tratar  
                    ------especificamente da Validacao do Cod.Abono  
Mauricio MR 15/10/02AcertoA)Substituicao da Funcao SomaHoras por     
                    ------RetFimTab para calculo de hora final a          
                    ------partir da soma de hora ini e abonadas.     
MauricioMR  25/08/03------ Substituicao de Header por Protheus.ch        
|Marinaldo   21/04/04MelhorTratamento nos Lock dos Registros e Delete| 
Mauricio MR 21/06/04 Bops Permite Campos de Usuario em 'Branco'.     
                     72032                                               
Pedro Eloy  17/01/07109644Ajuste na rotina para tratar o WalkThru        
Pedro Eloy  20/03/07109644Tratado o nUsado na rotina de abono.      
			   -------------- 11.5                      				  
Emerson Camp29/12/1029591/Ajuste para nova interface 11. Com a      
			             2010aplicao do parametro MV_ECMFTPP que     
                          afirma ser a verso 11.5 do Protheus      
Glaucia M.  06/07/11015527Readequacao das telas para diversas		  
			           SDTCVWresolucoes.								  
Leandro Dr. 20/12/11TEFHFARestaurado ordem na busca do SX3 evitando 
                          ocorrencia de eror.log.                   
ٱ
*/
Function PONA210(cChamada,_nOpcx,nReg   ,dData,nHoras,cEvento,aHeaderSPC,aColsSPC,nLinSPC,cCCSPC,cTpMarca,cPrefix,cAliasApont,cDeptoSPC,cPostoSPC,cCodFuncSPC,cProces,cRoteiro,cPeriodo,cNrPag)

LOCAL cFiltraSRA			//Variavel para filtro
LOCAL aIndexSRA	:= {}		//Variavel Para Filtro
Local aArea:=GetArea()

Private bFiltraBrw	:= {|| Nil}		//Variavel para Filtro
Private lChamadaNIL := .F.

Private nHrsEve 	:= nHoras
Private cCodEve		:= cEvento  			//-- Utilizado para reter o Codigo do Evento a ser utilizado nas funcoes que no se pode passa-lo.

//-- Variaveis utilizadas como inicializadoras
Private cCCInit   	:= cCCSPC
Private cTpMarcaInit:= cTpMarca 
Private cDeptoInit	:= cDeptoSPC
Private cPostoInit	:= cPostoSPC
Private cCodFuncInit:= cCodFuncSPC
Private cProcesInit := cProces
Private cRoteiroInit:= cRoteiro
Private cPeriodoInit:= cPeriodo
Private cNumPagInit := cNrPag


IF ( lChamadaNIL := ( cChamada == NIL ) )
	/*
	Ŀ
	So executa se o Modo de Acesso do SPC e SRA foram iguais e se este  ulti
	mo nao estiver vazio e se o Periodo de Apontamento e' Valido.           
	*/
	Pn210Atu('SPK',SRA->(Recno()),2) //Apenas Visualizacao
Else
	nOpcx := _nOpcx
	SRA->(dbGoTo(nReg))
	Pn210Atu('SPK' ,nReg,nOpcx,cChamada,dData,nHoras,cEvento,aHeaderSPC,@aColsSPC,nLinSPC,cCCSPC,cTpMarca,cPrefix,cAliasApont,cDeptoSPC,cPostoSPC,cCodFuncSPC,cProces,cRoteiro,cPeriodo,cNrPag)
	n := nLinSPC //Restaura a Posicao Original do n da GetDados da Tela de Manutencao de Apontamentos
EndIF
nUsado := Len(aHeader)
RestArea(aArea)

Return( NIL )

/*/


Ŀ
Funo    PN210Atu   Autor  Alexsandro Pereira     Data  08.03.00 
Ĵ
Descrio  Programa de (Vis.,Inc.,Alt. e Del. de  dependentes         
Ĵ
Sintaxe                                                               
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       Pona210                                                    
ٱ

*/
Function pn210Atu(cAlias,nReg,nOpcx,cChamada,dData,nHoras,cEvento,aHeaderSPC,aColsSPC,nLinSPC,cCCSPC,cTpMarca,cPrefix,cAliasApont,cDeptoSPC,cPostoSPC,cCodFuncSPC,cProces,cRoteiro,cPeriodo,cNrPag)

Local aKeys				:= GetKeys()
Local cFil		   		:= SRA->RA_FILIAL	
Local cMat         		:= SRA->RA_MAT
Local cNome        		:= SRA->RA_NOME
Local aAreaAtual   		:= GetArea()
Local a210Field    		:= {}          

Local oDlgA210, oGeta210 , oFont , oGroup

Local bSeekWhile	:= {|| SPK->PK_FILIAL + SPK->PK_MAT }
Local nSPKOrd		:= RetOrdem( "SPK" , "PK_FILIAL+PK_MAT+DTOS(PK_DATA)+PK_CODABO+STR(PK_HORINI,5,2)+ PK_TPMARCA+PK_CC+PK_DEPTO+PK_POSTO+PK_CODFUNC" )
									  
Local cCod			:= SRA->RA_MAT 
Local bSet15
Local bSet24
//Ŀ
// Declarao de arrays para dimensionar tela		         
//
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

Local aAdv1Size		:= {}
Local aInfo1AdvSize	:= {}
Local aObj1Size		:= {}
Local aObj1Coords	:= {}

IF !lChamadaNIL
	a210Field := {"PK_FILIAL","PK_MAT","PK_CC","PK_CODEVE","PK_TPMARCA","PK_DEPTO","PK_POSTO","PK_CODFUNC","PK_PROCES","PK_PERIODO","PK_ROTEIR","PK_NUMPAG"}  
Else
	a210Field := {"PK_FILIAL","PK_MAT"}
EndIF	

Private a210BrancoField := {"PK_HORINI","PK_HORFIM","PK_FLAG"}
Private aAC        		:= {STR0007 ,STR0008 }	// "Abandona"###"Confirma"
Private aColsRec		:= {}					//--Array que contem o Recno() dos registros da aCols
Private aColsAnt   		:= {}
Private aVirtual   		:= {}  
Private aCols			:= {}
Private nCnt         	:= 0
//Ŀ
// Carrega Array de Campos Alteraveis                           
//
cAlias := "SPK"

While .T.

	//Ŀ
	// Verifica se existe algum dado no arquivo                     
	//

	dbSelectArea( cAlias )
	dbSetOrder(1)
	dbSeek( cFil + cMat )
	nCnt := 0
	While SPK->( !Eof() .and. PK_FILIAL + PK_MAT == cFil + cMat )
		IF !lChamadaNIL
			IF SPK->( (PK_DATA < dData .or. PK_DATA > dData) .or. (PK_CODEVE # cEvento) .or. (PK_TPMARCA # cTpMarca) .or.;
					  (PK_CC # cCCSPC) .or. (PK_DEPTO # cDeptoSPC) .or. (PK_POSTO # cPostoSPC) .or. (PK_CODFUNC # cCodFuncSPC))
				SPK->( dbSkip() )
				Loop
			EndIF
		Else
			IF SPK->( PK_DATA < dPerIni .or. PK_DATA > dPerFim )
				SPK->( dbSkip() )
				Loop
			EndIF
		EndIF	
		nCnt++
		dbSkip()
	EndDo
   
	IF lChamadaNIL .and. nCnt = 0
		MsgInfo(OemToAnsi(STR0012),OemToAnsi(STR0013))
		Exit
	Endif    
	

	//Ŀ
	// Monta a entrada de dados do arquivo                          
	//
	Private aGETS[0],aHeader[0],aAlter[0],Continua:=.F.

	//Ŀ
	// Posiciona ponteiro do arquivo cabeca e inicializa variaveis  
	//
	nOpcA := 0

	//-- Quando for Inclusao criar com 1 elemento
	nCnt := If (nOpcx == 3,1,If(nCnt==0,1,nCnt))

    Private nPosData	:= 0
	Private nPosCodA	:= 0
	Private nPosMotA	:= 0
	Private nPosHrIn	:= 0
	Private nPosHrFm	:= 0
	Private nPosHrAb	:= 0
	Private nPosFlag	:= 0
	Private nPosCODEVE	:= 0
   	Private nPosDepto	:= 0  
   	Private nPosPosto	:= 0  
   	Private nPosCodFunc	:= 0  
   	Private nPosProces	:= 0     	
   	Private nPosRoteir	:= 0     	   	
   	Private nPosPeriodo	:= 0     	   	   	
   	Private nPosNumPag	:= 0     	   	   	
   	   	
	
	Private bSort		:= { |x,y|	DtoS(x[nPosData])			+ ;
									StrZero(x[nPosHrFm],5,2)	+ ;
									StrZero(x[nPosHrAb],5,2)	+ ;
								 	StrZero(x[nPosHrIn],5,2)	< ;
									DtoS(y[nPosData])			+ ;
									StrZero(y[nPosHrFm],5,2)	+ ;
									StrZero(y[nPosHrAb],5,2)	+ ;
									StrZero(y[nPosHrIn],5,2)	  ;
							 }

	bMontCols	:= { || aCols:= pn210Acols(a210Field,nOpcx,dData,nHoras,cEvento,cChamada,aHeaderSPC,aColsSPC,nLinSPC,cCCSPC,cTpMarca,cPrefix,cAliasApont,nCnt,cDeptoSPC,cPostoSPC,cCodFuncSPC,cProces,cRoteiro,cPeriodo,cNrPag) }	//funcao para gerar aCols

	//Ŀ
	// Gerar o array aCols com os Eventos                          
	//

	FillGetDados(nOpcX							,; //1-nOpcX - nmero correspondente  operao a ser executada, exemplo: 3 - incluso, 4 alterao e etc;
				 cAlias							,; //2-cAlias - area a ser utilizada;
				 nSPKOrd						,; //3-nOrder - ordem correspondente a chave de indice para preencher o  acols;
				 xFilial(cAlias)+cCod			,; //4-cSeekKey - chave utilizada no posicionamento da area para preencher o acols;
				 NIL							,; //5-bSeekWhile - bloco contendo a expresso a ser comparada com cSeekKey na condio  do While.
				 NIL							,; //6-uSeekFor - pode ser utilizados de duas maneiras:1- bloco-de-cdigo, condio a ser utilizado para executar o Loop no While;2 - array bi-dimensional contendo N.. condies, em que o 1 elemento  o bloco condicional, o 2  bloco a ser executado se verdadeiro e o 3  bloco a ser executado se falso, exemplo {{bCondicao1, bTrue1, bFalse1}, {bCondicao2, bTrue2, bFalse2}.. bCondicaoN, bTrueN, bFalseN};
				 a210Field	   	    		    ,; //7-aNoFields - array contendo os campos que no estaro no aHeader;
				 NIL							,; //8-aYesFields - array contendo somente os campos que estaro no aHeader;
				 NIL							,; //9-lOnlyYes - se verdadeiro, exibe apenas os campos de usurio;
				 NIL							,; //10-cQuery - query a ser executada para preencher o acols(Obs. Nao pode haver MEMO);
				 bMontCols						,; //11-bMontCols - bloco contendo funo especifica para preencher o aCols; Exmplo:{|| MontaAcols(cAlias)}
				 NIL							,;  
				 NIL 							,;  
				 NIL							,; 
				 NIL							,; 
				 NIL 							)	
				


	aColsAnt := aClone(aCols)
	nOpca := 0
    
	/*
	Ŀ
	 Monta as Dimensoes dos Objetos         					   
	*/

	aAdvSize		:= MsAdvSize(,.T.,380)
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }					 
	aAdd( aObjCoords , { 000 , 020 , .T. , .F. } )		//1-Cabecalho1
	aAdd( aObjCoords , { 000 , 020 , .T. , .F. } )		//2-Cabecalho2
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )		//3-MsGetDados
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords ) 


	//Divisao em colunas Linha 1-Cabecalho Dados Funcionario
	aAdv1Size		:= aClone(aObjSize[1])
	aInfo1AdvSize	:= { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 1 , 1 }
	aAdd( aObj1Coords , { 040 , 000 , .F. , .T. } )	//1-Matricula
	aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )	//2-Nome
	aAdd( aObj1Coords , { 040 , 000 , .F. , .T. } )	//3-Admissao
	aObj1Size		:= MsObjSize( aInfo1AdvSize , aObj1Coords,,.T. )        

	
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlga210 TITLE OemToAnsi(STR0009) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL				    // "Manuteno dos Abonos"
	
	@ aObj1Size[1,1],aObj1Size[1,2] GROUP oGroup TO aObj1Size[1,3],aObj1Size[1,4] LABEL OemToAnsi(STR0010) OF oDlga210 PIXEL									// "Matricula:"
	oGroup:oFont:= oFont
	@ aObj1Size[2,1],aObj1Size[2,2] GROUP oGroup TO aObj1Size[2,3], aObj1Size[2,4] LABEL OemToAnsi(STR0011) OF oDlga210 PIXEL									// "Nome:"
	oGroup:oFont:= oFont
	@ aObj1Size[3,1],aObj1Size[3,2] GROUP oGroup TO aObj1Size[3,3], aObj1Size[3,4] LABEL OemToAnsi(STR0016) OF oDlga210 PIXEL									// "Admisso:"
	oGroup:oFont:= oFont
	
	@ aObj1Size[1,1]+8,aObj1Size[1,2]+5 SAY StrZero(Val(SRA->RA_MAT),TamSx3("RA_MAT    ")[1]) 	SIZE 050,10 OF oDlga210 PIXEL FONT oFont
	@ aObj1Size[2,1]+8,aObj1Size[2,2]+5 SAY OemToAnsi(SRA->RA_NOME) 							SIZE 146,10 OF oDlga210 PIXEL FONT oFont
	@ aObj1Size[3,1]+8,aObj1Size[3,2]+5 SAY Dtoc(fDtaAdmis())									SIZE 050,10 OF oDlga210 PIXEL FONT oFont
	
	IF !lChamadaNIL
		@ aObjSize[2,1],aObjSize[2,2] GROUP oGroup TO aObjSize[2,3], aObjSize[2,4] LABEL OemToAnsi(STR0017) OF oDlga210 PIXEL									// "Evento:"
		oGroup:oFont:= oFont
		@ aObjSize[2,1]+8,aObj1Size[1,2]+5  SAY OemToAnsi(cEvento) + ' - ' + OemToAnsi(DescPDPon(cEvento,SRA->RA_FILIAL,20))+'' + OemToAnsi(cTpMarca) SIZE 146,10 OF oDlga210 PIXEL FONT oFont
		oGeta210 := MSGetDados():New(aObjSize[3,1],aObjSize[3,2],aObjSize[3,3],aObjSize[3,4],nOpcx,"aPont210Ok" ,"pn210TudOk" ,"",If(nOpcx=2.Or.nOpcx=5,Nil,.T.),aAlter,1)
		oGeta210:oBrowse:bChange := { || Pn210Pad(dData,aHeaderSPC,aColsSPC,nLinSPC),oGeta210:oBrowse:Refresh() } 
	Else
		oGeta210 := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[3,3],aObjSize[3,4],nOpcx,"AllWaysTrue","AllWaysTrue" ,"",,,1)

	EndIF	
    
    bSet15 := {|| nOpca:=If(nOpcx=5,2,1),If(oGeta210:TudoOk(),(RestKeys(aKeys,.T.),oDlga210:End()),nOpca:=0)}
    bSet24 := {|| RestKeys(aKeys,.T.), oDlga210:End()}
    
	ACTIVATE MSDIALOG oDlga210 ON INIT EnchoiceBar(oDlga210,bSet15,bSet24,Nil,Nil) CENTERED

   //--Se nao for Exclusao
	IF nOpcA == Redigita
		LOOP
	ElseIF nOpcA == Confirma .And. nOpcx # 2
		Begin Transaction
			//--Gravacao
			pn210Grava(cAlias,nOpcx,aColsRec,aHeaderSPC,@aColsSPC,nLinSPC,cChamada,cEvento,cCCSPC,cTpMarca,cPrefix,cAliasApont,,cDeptoSPC,cPostoSPC,cCodFuncSPC,cProces,cRoteiro,cPeriodo,cNrPag)
			//--Processa Gatilhos
			EvalTrigger()
		End Transaction
   EndIF
	Exit
EndDo
//Ŀ
// Restaura a integridade da janela                             
//
RestArea(aAreaAtual)
RestKeys(aKeys,.T.)

Return

/*/


Ŀ
Funo    PN210aCols Autor  Alexsandro Pereira     Data  09/03/00 
Ĵ
Descrio  Criar os Arrays Aheader e aCols dos abonos                 
Ĵ
 Uso       PONA210                                                    
ٱ

*/
Static Function pn210aCols(a210Field,nOpcx,dDataIni,nHoras,cEvento,cChamada,aHeaderSPC,aColsSPC,nLinSPC,cCCSPC,cTpMarca,cPrefix,cAliasApont,nCnt,cDeptoSPC,cPostoSPC,cCodFuncSPC,cProces,cRoteiro,cPeriodo,cNrPag)
Local cAlias		:= "SPK"
Local dData			:= Ctod('  /  /  ')
Local lSemAbono		:= .T.  
Local lIniPad		:= If (nOpcx == 3 .or. nOpcx == 4 .or. nOpcx == 5 , .T. , .F. )
Local nPosaCols		:= 0
Local naCols		:= 0
Local nPosTab		:= 0
Local nPosOrdem		:= 0
Local cOrdem		:= ''  
Local aRetHrNot		:= {} 
Local aSPKCampos	:= FWSX3Util():GetAllFields("SPK" , .T.)
Local lNoturno		:= .F.
Local nIniHnot		:= 0
Local nFimHnot		:= 0
Local nMinHnot		:= 0
Local nUsado		:= Len(aHeader)
Local aCOLS[nCnt][nUsado+1]
Local nI			:= 0
Local nLenSPK		:= Len(aSPKCampos)

naCols    		:= Len(aCols)

nPosData	:= GdFieldPos( "PK_DATA"   	)
nPosCodA	:= GdFieldPos( "PK_CODABO" 	)
nPosMotA	:= GdFieldPos( "PK_MOTABO" 	) 
nPosHrIn	:= GdFieldPos( "PK_HORINI" 	)
nPosHrFm	:= GdFieldPos( "PK_HORFIM" 	)
nPosHrAb	:= GdFieldPos( "PK_HRSABO" 	)
nPosFlag	:= GdFieldPos( "PK_FLAG" 	)
nPosCODEVE	:= GdFieldPos( "PK_CODEVE" 	)
nPosDepto	:= GdFieldPos( "PK_DEPTO" 	)
nPosPosto	:= GdFieldPos( "PK_POSTO" 	)
nPosCodFunc	:= GdFieldPos( "PK_CODFUNC" )
nPosProces	:= GdFieldPos( "PK_PROCES" 	)
nPosRoteir	:= GdFieldPos( "PK_ROTEIR" 	)
nPosPeriodo	:= GdFieldPos( "PK_PERIODO" )
nPosNumPag	:= GdFieldPos( "PK_NUMPAG" 	)

nCnt := 0

//
//Trata a EXISTENCIA DE ABONOS 
//Realiza a Carga de Dados     
//

dbSelectArea(cAlias)
If dbseek(SRA->( RA_FILIAL + RA_MAT) )
	While (cAlias)->( !Eof() .and. PK_FILIAL + PK_MAT == SRA->( RA_FILIAL + RA_MAT ) )
		IF !lChamadaNIL
			IF (cAlias)->( PK_DATA < dDataIni .or. PK_DATA > dDataIni .or. PK_CODEVE # cEvento ;
			               .or. PK_TPMARCA # cTpMarca .or. PK_CC # cCCSPC ;
						   .or. PK_DEPTO # cDeptoSPC .or. PK_POSTO# cPostoSPC .or. PK_CODFUNC # cCodFuncSPC;			               
			               )
				(cAlias)->( dbSkip() )
				Loop
			EndIF
		Else
			IF SPK->( PK_DATA < dPerIni .or. PK_DATA > dPerFim )
				SPK->( dbSkip() )
				Loop
			EndIF 
		EndIF
		nCnt++
		nUsado:=0
		
		dbSelectArea("SX3")
		For nI := 1 To nLenSPK
			If SX3->( x3uso(GetSx3Cache(aSPKCampos[nI],"X3_USADO")) .and. cNivel >= GetSx3Cache(aSPKCampos[nI],"X3_NIVEL") .and. aScan(a210Field,AllTrim(aSPKCampos[nI])) = 0 )
				If GetSx3Cache(aSPKCampos[nI],"X3_CONTEXT") == "V"
					nUsado++
					aCols[nCnt,nUsado] := CriaVar(Trim(aSPKCampos[nI]))
					Aadd( aVirtual , Trim(aSPKCampos[nI]) )				
				   	  
					If AllTrim(aSPKCampos[nI]) == 'PK_MOTABO'
						If SP6->(dbSeek(fFilFunc('SP6')+SPK->PK_CODABO))
							M->PK_MOTABO := SP6->P6_DESC
							Else
							M->PK_MOTABO := STR0015 //'*** NAO CADASTRADO ***'
						Endif
						aCols[nCnt,nUsado]  := M->PK_MOTABO
					Endif 
				Else
					nUsado++
					aCOLS[nCnt][nUsado] := &(cAlias+"->"+aSPKCampos[nI])
				Endif
				If !(AllTrim(Upper(aSPKCampos[nI])) $ "PK_DATA") .or. lChamadaNIL
					aAdd(aAlter,aSPKCampos[nI])
				Endif
			Endif
			dbSkip()
		Next
        nUsado := Len(aHeader)        
        If nOpcx # 2 .And. nOpcx # 5
			aCOLS[nCnt][nUsado+1] := .F.
		Endif
    	// Gravao do alias e Recno para o WalkTrhu
		aCOLS[nCnt][nUsado-1] := cAlias
		aCOLS[nCnt][nUsado]   := (cAlias)->(Recno())
     
        //Matriz criada para Controlar quais e quantos elementos estao de fato gravados e
        //confrontar com as informacoes na memoria (aCols)
		dbSelectArea( cAlias )
		aAdd(aColsRec,{})
		aAdd(aColsRec[Len(aColsRec)], aCols[nCnt,1])
		aAdd(aColsRec[Len(aColsRec)], aCols[nCnt,4])
		aAdd(aColsRec[Len(aColsRec)], Recno())

	    dbSelectArea("SPK")
        dbSkip()
    EndDo
    If !Empty(nCnt)
       lSemAbono:=.F.
	Endif    

Endif 

//Ŀ
//Preenche LINHA EM BRANCO para Ausencia de Abonos    
//
        
If (!lChamadaNIL .And. lSemAbono ) 
	nUsado:=0

	For nI := 1 To nLenSPK
		If X3USO(GetSx3Cache(aSPKCampos[nI],"X3_USADO")) .AND. cNivel >= GetSx3Cache(aSPKCampos[nI],"X3_NIVEL") .and. ASCAN(a210Field,Trim(aSPKCampos[nI])) = 0
			nUsado++
			//Ŀ
			// Monta Array do 1 Elemento Vazio. Se Inclusao                
			//
			aCOLS[naCols][nUsado]	:= (cAliasApont)->(CriaVar(aSPKCampos[nI],lIniPad))	
					
			If GetSx3Cache(aSPKCampos[nI],"X3_CONTEXT") == "V"		
				Aadd( aVirtual , Trim(aSPKCampos[nI]) )
			Endif
			// tratando os campo alteravel na getdados
			If !(AllTrim(Upper(aSPKCampos[nI])) $ "PK_DATA") .or. lChamadaNIL
				aAdd(aAlter,aSPKCampos[nI])
			Endif
			
		Endif
	Next

	nUsado	:= Len(aHeader)
	// gravacao do elemento no array para o uso do WalkThru
	aCols[naCols][nUsado-1]	:=  cAlias
	aCols[naCols][nUsado]	:=  0
	aCOLS[naCols][nUsado+1]	:= .f.
                                                                 
	//Preenche Campos (Data /Evento   identicos ao Apontamento) 
	//				   Flag sugere-se tipo Informado "I"
	//				   Abono sugere-se o Abono "rapido" se existir no Apontamento
	
	//Obrigatoriamente Garante que Data do Abono seja igual a Data do Apontamento
	If nPosDATA > 0
		aCols[naCols, nPosData] := dDataIni
	EndIf
 	    
    // Preenche Flag de Tipo de Abono (Informado/Gerado) com informado "I"
	If nPosFLAG > 0
		aCols[naCols, nPosFlag] := "I"
	EndIf 

    
	//Preenche Codigo do Abono Somente Qdo nao houver Abonos Anteriores 
	
 	 // Preenche Motivo de Abono a Partir do SPC    
	If (nPos  := GdFieldPos( cPrefix+'ABONO', aHeaderSPC ) ) > 0
		//Cod.Abono em SPK:=Cod.Abono em SPC
		aCols[naCols,nPosCodA] := aColsSPC[nLinSPC,nPos]
  
	    //-- Se o usuario digitou abono "rapido"
	    If !Empty(aCols[naCols,nPosCodA])
	    	//-- Preenche campo virtual "Descricao do motivo de abono"
	    	If SP6->(dbSeek(fFilFunc('SP6')+aCols[naCols,nPosCodA]))
		       aCols[naCols,nPosMotA] := SP6->P6_DESC
		    Else 
		    	aCols[naCols,nPosMotA] := STR0015 //'*** NAO CADASTRADO ***'
		    Endif
		Else 
		   //Sem abono "rapido" digitado
		   aCols[naCols,nPosMotA] := STR0015 //'*** NAO CADASTRADO ***'
		Endif  
	
	Endif                                                  
    
	
	//Calcula Saldo de Horas a Abonar    
	If  !Empty(nPosHrAb)
		dData 			  := If(aCols[naCols,nPosHrFm] < aCols[naCols,nPosHrIn],dData + 1, aCols[naCols,nPosData]) 
		/*/
		Ŀ
		 Obtem a Hora Noturna de Acordo com o Turno                  
		/*/ 
		aRetHrNot:= RetHrNot(dData)
		nIniHnot := aRetHrNot[1]	// Inicio da Hora Noturna
		nFimHnot := aRetHrNot[2]	// Final da Hora Noturna
		nMinHnot := aRetHrNot[3]	// Minutos da Hora Noturna     
		lNoturno := fHorNot(aRetHrNot)			
		aCols[naCols, nPosHrAb] := Max(0,Subhoras(nHrsEve,PnTotAbo(aCols,aHeader,Len(aCols[1]))))
		//Se Existir +1 abono Calcula Horas Inicial e Final para o Abono a ser Informado
		If naCols>1  .AND. !Empty(	aCols[naCols, nPosHrAb])
			//Sugere Hora Inicial do Abono
			If !Empty(nPosHrIn)
			    //Calcula Hora Inicial para o Abono  (Hora_Fim_Abono_Anterior)
				aCols[naCols, nPosHrIn] :=	aCols[naCols-1, nPosHrFm] 
			Endif
			//Calcula e Sugere Hora Final do Abono (Hora Inicial + Saldo de Horas a Abonar)
			If !Empty(nPosHrFm)
			    aCols[naCols, nPosHrFm] := RetFimTab(aCols[naCols,nPosData]  , aCols[naCols,nPosHrIn] , aCols[naCols,nPosHrAB] , NIL, lNoturno, aCols[naCols,nPosData], 	nIniHnot, nFimHnot,  nMinHnot  )[2]
			Endif
		Elseif naCols==1.AND. !Empty(	aCols[naCols, nPosHrAb])
				//-- Sugere Horas a Abonar e Horarios Quando Nao Existirem Abonos
				//-- Cadastrados e horas a Abonar DIGITADAS.
				
				//Obtem a Posicao do Primeiro Elemento com Data Igual do Apontamento e
			    //a primeira entrada de acordo com a ordem.
			    //OBSERVACAO: Para Horarios Noturnos ele pode nao corresponder a primeira Entrada (Entrou as 22 do dia anterior)
			    //O que nos forca a obter a Ordem do elemento e assim posicionar na 1a Entrada
			    //de acordo com a Data.
				nPosTab := Ascan(aTabCalend, { |x| x[1] == dDataIni }) 
				cOrdem  := aTabCalend[nPosTab,2]
				nPosOrdem:= Ascan(aTabCalend, { |x| x[2] == cOrdem })
		
				If  nPosHrIn  > 0
					If nPosOrdem > 0    
					 aCols[naCols, nPosHrIn] := If(nHoras > 0, aTabCalend[nPosOrdem,3],0)
					Endif
				EndIf
			
				If nPosHrAb > 0
					aCols[naCols, nPosHrAb] := nHoras
				EndIf
			
				If  nPosHrFm > 0
					If nPosOrdem > 0
	 					aCols[naCols, nPosHrFm] := RetFimTab(aCols[naCols,nPosData]  , aCols[naCols,nPosHrIn] , aCols[naCols,nPosHrAB] , NIL, lNoturno, aCols[naCols,nPosData], 	nIniHnot, nFimHnot,  nMinHnot  )[2]
					Endif
				EndIf
		EndIf
	EndIf
EndIF

//-- Ordena os lancamentos de abono por Horarios
aSort(aCols,,, bSort )

// -- Coloca os abonos em branco nas ultimas linhas do browse
Pn210Ordem(@aCols)
Return(aCols)

/*

Ŀ
Funo    PN210Grava Autor  Mauricio MR            Data  19.06.02 
Ĵ
Descrio  Grava/Atualiza Abonos                                      
Ĵ
 Uso       PONA210/280                                                
ٱ

/*/          
Function pn210Grava(cAlias,nOpcx,aColsRec,aHeaderSPC,aColsSPC,nLinSPC,cChamada,cEvento,cCCSPC,cTpMarca,cPrefix,cAliasApont,lArquivo,cDeptoSPC,cPostoSPC,cCodFuncSPC,cProces,cRoteiro,cPeriodo,cNrPag)

Local aAreaSPC	  := (cAliasApont)->( GetArea() )
Local cFilMat	  := SRA->( RA_FILIAL + RA_MAT )	
Local cCodAbo	  := CriaVar('PK_CODABO',.T.)
Local cMsgErr	  := ""
Local ny          := 0  
Local nZ          := 0
Local nMaxArray   := Len(aHeader)
Local nHoras      := 0  
Local nZeraHorasAB:= 0
Local dDatant     := Ctod("//")
Local nPosSPCQTab := GdFieldPos( cPrefix+'QTABONO' 	, aHeaderSPC ) 
Local nPosAbono   := GdFieldPos( cPrefix+'ABONO'   	, aHeaderSPC ) 
Local nPos		  := 0
Local lPrimVez    := .T.    
Local naCols      :=Len(aCols) 
Local naColsRec   :=Len(aColsRec)
Local aColsAux	  :={} 
Local aRetHrNot	  :={}	
Local lNoturno	  := .F.	
Local nUsado	  := Len(aHeader)

DEFAULT cEvento := Space(TamSx3("PK_CODEVE")[1])
DEFAULT lArquivo:= .T.                                 
DEFAULT lPnaGrv	:= ExistBlock( "PNA210GRV" )


//-- Abre inicio da transacao de gravacao e eliminacao de itens
Begin Transaction

    dbSelectArea(cAlias)
	For nZ:=1 TO naCols 
	    If Empty(aCols[ nZ , nPosCodA ])
	      Loop
	    Endif
		//-- Elimina os itens do aCols marcados para exclusao e atualiza o SPC
		//-- zerando as horas abonadas dos itens eliminados e eliminado o codigo de abono
		If nZ <= naColsRec    
			If ( lArquivo )
				dbGoto(aColsRec[nZ,3])
				IF !RecLock(cAlias,.F.,.T.)
					Loop
				EndIF
			Endif
			 
			//--Verifica se esta deletado     
			If aCols[nZ,nUsado+1]
				//-- Subtrai a quantidade abonada em SPC->PC_QTABONO
				aColsSPC[nLinSPC,nPosSPCQTab] := Max(0,SubHoras(aColsSPC[nLinSPC,nPosSPCQTAB],aCols[nZ,nPosHrAb]))
				//-- Apaga o codigo de abono na tela de apontamentos somente
				//-- quando nao houver horas abonadas, evitando que em abonos parciais
				//-- o codigo de abono seja eliminado.
				nZeraHorasAB:=aColsSPC[nLinSPC,nPosSPCQTab]
				If 	nZeraHorasAB <= 0
					aColsSPC[nLinSPC,nPosAbono] :=  SPACE( LEN(cCodAbo) )
				Endif
			    
				//--Se a  Quantidade de Horas Abonadas na Manutencao de Abonos for Zero
				//-- Apaga o Codigo do Primeiro Abono(SPK) e a Zera Qtde Horas Abonadas no Evento (SPC)
				IF  Empty(nZeraHorasAB)  
				    If lArquivo
						IF (cAliasApont)->( dbSeek(cFilMat+cEvento+Dtos(aCols[nZ,nPosData])+cTpMarca+cCCSPC+cDeptoSPC+cPostoSPC+cCodFuncSPC,.F.) )					    
							IF RecLock(cAliasApont,.F.,.T.)
				      			//-- Atualiza Codigo e Qtde de Horas
								(cAliasApont)->(&(cPrefix+"ABONO"))	:= SPACE( LEN(cCodAbo) )
								(cAliasApont)->(&(cPrefix+"QTABONO")) := nZeraHorasAB
								(cAliasApont)->( MsUnLock() )
							EndIF
							(cAliasApont)->( dbSkip() )
						EndIF
						RestArea( aAreaSPC )
					Else     
					    //-- Atualiza Memoria 
				    	//-- Atualiza Codigo e Qtde de Horas
						If nPosAbono > 0
							aColsSPC[nLinSPC,nPosAbono] :=  SPACE( LEN(cCodAbo) )
						Endif 
						
						If nPosSPCQTab > 0
							aColsSPC[nLinSPC,nPosSPCQTab] := nZeraHorasAB
						Endif
					Endif
				Endif   
				
				If lArquivo
					IF !( cAlias )->( FkDelete( @cMsgErr ) )
						( cAlias )->( RollBackDelTran( cMsgErr ) )
					EndIF
					(cAlias)->( MsUnLock() )
				Endif
				Loop
			Endif
		Else
			//-- Grava os registros nao excluidos do aCols
			If !aCols[nZ,nUsado+1]
			    If lArquivo
					IF !RecLock(cAlias,.T.,.T.)
						Loop
					EndIF
					SPK->PK_FILIAL := SRA->RA_FILIAL
					SPK->PK_MAT    := SRA->RA_MAT 
				Endif
			Else
				Loop
			Endif
		Endif
		
		
		//Guarda o Primeiro Abono Valido (Nao deletado).
		If lPrimVez
			cCodAbo := aCols[ nZ , nPosCodA ]
  	        dDatant := aCols[ nZ , nPosData] 
            lPrimVez:=.F.	
		Endif            
		
		If lArquivo
			//Corre Todos os elementos(Campos) para gravar o registro
			For ny := 1 To nMaxArray
				cCampo    := Trim(aHeader[ny][2])
				//Grava Campos Nao Virtuais
				If (nPos := Ascan(aVirtual,cCampo)) == 0
					xConteudo := aCols[nZ,ny]
					SPK->&cCampo := xConteudo
				Endif 
			Next ny
		Endif
		
		//-- Regrava a quantidade de horas somando-as por data 
		//-- para atualizacao do campo PC_QTABONO.
		nHoras := SomaHoras(nHoras, aCols[nZ,nPosHrAB])
		
		//Regrava FLAG do Abono como "I" de Informado, Evento e Centro de Custos
	    If  lArquivo
	   		SPK->PK_FLAG	:= Pn210FLAG(SPK->PK_FLAG,aCols,aColsAnt,nZ)
	   		SPK->PK_CODEVE	:= cEvento
   			SPK->PK_CC		:= cCCSPC   
			SPK->PK_DEPTO	:= cDeptoSPC   			
			SPK->PK_POSTO	:= cPostoSPC   						
			SPK->PK_CODFUNC	:= cCodFuncSPC   
			SPK->PK_PROCES	:= cProces
			SPK->PK_ROTEIR	:= cRoteiro
			SPK->PK_PERIODO	:= cPeriodo   
			SPK->PK_NUMPAG	:= cNrPag   												
			         
			           
   			SPK->PK_TPMARCA	:= cTpMarca 
			SPK->( MsUnlock() )
	    Else
	    	aCols[nZ,nPosFlag]		:= Pn210FLAG(aCols[nZ,nPosFlag],aCols,aColsAnt,nZ)
	   		aCols[nZ,nPosCODEVE]	:= cEvento
   			aCols[nZ,nPosCC]		:= cCCSPC     
   			aCols[nZ,nPosTPMARCA]	:= cTpMarca 
			aCols[nZ,nPosDepto]		:= cDeptoSPC 
			aCols[nZ,nPosPosto]		:= cPostoSPC 
   			aCols[nZ,nPosCodfunc]	:= cCodFuncSPC   			            
			aCols[nZ,nPosProces]	:= cProces 
			aCols[nZ,nPosRoteir]	:= cRoteiro    			
			aCols[nZ,nPosPeriodo]	:= cPeriodo 
			aCols[nZ,nPosNumPag]	:= cNrPag
			 
            //-- Adiciona Abono em Matriz Auxiliar
	      //  aAdd(aColsAux,aCols[nz])
	    Endif 
	    
		/*/
		Ŀ
		 Ponto de Entrada para insercao em nova tabela Ex: Log		   
		/*/
		IF ( lPnaGrv )
			ExecBlock("PNA210GRV",.F.,.F.,{ lArquivo } )
		EndIF
	Next nZ
    
    //Atualiza Celulas Cod.Abono , Qtde de Horas Abonadas do Browse Principal
    
	If nPosSPCQTab > 0
		aColsSPC[nLinSPC,nPosSPCQTab] := fArrdAB(nHoras, nHrsEve)
	Endif
	If nPosAbono > 0
		aColsSPC[nLinSPC,nPosAbono] := cCodAbo
	Endif 
   
    //Atualiza Cod.Abono e Horas Abonadas
    If lArquivo
		If (cAliasApont)->(dbSeek(cFilMat+cEvento+Dtos(dDatAnt)+cTpMarca+cCCSPC+cCodFuncSPC))     	
    		aRetHrNot:= RetHrNot(dDatAnt)
			nIniHnot := aRetHrNot[1]	// Inicio da Hora Noturna
			nFimHnot := aRetHrNot[2]	// Final da Hora Noturna
			nMinHnot := aRetHrNot[3]	// Minutos da Hora Noturna     
			lNoturno := fHorNot(aRetHrNot)			
			nHoras := fArrdAB(nHoras, nHrsEve)
			IF RecLock(cAliasApont,.F.,.T.)
				//-- Atualiza Codigo e Qtde de Horas
				(cAliasApont)->(&(cPrefix+'ABONO'))		:= cCodAbo
				(cAliasApont)->(&(cPrefix+'QTABONO'))	:= nHoras
				(cAliasApont)->(MsUnLock())  
			EndIF
			(cAliasApont)->( dbSkip() )
		Endif                  
	Else                        
	    //aAcols:=If(!Empty(aColsAux),Aclone(aColsAux),	P280AboCols(aHeader,@aCols  	,		,aFields , 				,nOpcX,.T.))
	    n:=1
	Endif
	
End Transaction


//-- Restaura a posicao do aCols na tela de apontamentos
If lArquivo
	n := nLinSPC
Endif
	
Return


/*/


Ŀ
Funo    aPont210Ok Autor  J. Ricardo             Data  06.08.94 
Ĵ
Descrio Critica linha digitada                                      
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function Apont210Ok(o)  
Local aRetHrNot	:= {}
Local lNoturno	:= .F.
Local lRet      := .T.
Local nHorasAbo := 0
Local naCols1 	:= Len(aCols[1])
Local nIniHnot  := 0
Local nFimHnot  := 0
Local nMinHnot	:= 0
Local nHoras	:= 0	
Local dData 	:= aCols[n,nPosData]
Begin Sequence
	//-- Consiste total de horas abonadas (informadas) e o recalculo sobre as horas final e inicial
	If !aCols[n,naCols1]
		/*/
		Ŀ
		 Obtem a Hora Noturna de Acordo com o Turno                  
		/*/
	    
		aRetHrNot:= RetHrNot(dData)
		nIniHnot := aRetHrNot[1]	// Inicio da Hora Noturna
		nFimHnot := aRetHrNot[2]	// Final da Hora Noturna
		nMinHnot := aRetHrNot[3]	// Minutos da Hora Noturna
		
		dData 		:= If(aCols[n,nPosHrFm] < aCols[n,nPosHrIn],dData + 1, dData)
		lNoturno 	:= fHorNot(aRetHrNot)			
	   	nHoras		:= fCalHoras(dData,aCols[n,nPosHrFm], aCols[n,nPosData],aCols[n,nPosHrIn], Nil, Nil, lNoturno, aCols[n,nPosData],Nil,	nIniHnot, 	nFimHnot, nMinHnot)
		//nHorasAbo   := fArrdAB(nHoras, nHrsEve, lNoturno)
		nHorasAbo   := nHoras	
	    If aCols[n,nPosHrAb] <>Round(nHorasAbo,2) .AND. !Empty(nHorasAbo)
	       lRet := .F.                      
	       Help('',1,'PNA210HMAIS')
	   	Endif	
	
		If Empty(aCols[n,nPosCodA])  
		   	Help( ' ' , 1 , 'NVAZIO' , , OemToAnsi( aHeader[nPosCodA][1] ) , 5 , 0 )
		   	lRet := .F.
		   	Break
		Endif   
	Endif
	                 
End
	
Return( lRet )

/*/


Ŀ
Funo    pn210TudOk Autor  Alexsandro Pereira     Data  10/04/00 
Ĵ
Descrio                                                             
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function pn210TudOk(o)
Local nX        := 0
Local nY        := 0
Local lRet      := .T.
Local aColsCopy := aClone(aCols)
Local nHrsAbo   := 0 
Local naColsCopy:= 0
Local nUsado	:= Len(aHeader)
naColsCopy		:=	Len(aColsCopy)

//-- Ordena os lancamentos de abono para consistencia
aSort(aColsCopy,,, bSort )

//-- Consiste existencia de abonos em uma mesma faixa horaria
For nX := 1 To naColsCopy

	// Qdo a linha estiver marcada para delecao nao a valida
	If aColsCopy[nX,nUsado+1]
		Loop
	Endif
    
    If Empty(aColsCopy[nX,nPosCodA])  
    	Help( ' ' , 1 , 'NVAZIO' , , OemToAnsi( aHeader[nPosCodA][1] ) , 5 , 0 )
    	lRet := .F.
    	Exit
    Endif
    
	nY := If(nX==1 .Or. aColsCopy[nX-1,nUsado+1],nX,nX-1)

	nSerHrAntI := fDhToNs(aColsCopy[nY, nPosData], aColsCopy[nY,nPosHrIn])
	nSerHrAntF := fDhToNs(If(aColsCopy[nY,nPosHrIn] > aColsCopy[nY,nPosHrFm],aColsCopy[nY, nPosData]+1,aColsCopy[nY,nPosData]),aColsCopy[nY,nPosHrFm])

	nSerHrAtuI := fDhToNs(aColsCopy[nX, nPosData], aColsCopy[nX,nPosHrIn])
	nSerHrAtuF := fDhToNs(If(aColsCopy[nX,nPosHrIn] > aColsCopy[nX,nPosHrFm],aColsCopy[nX, nPosData]+1,aColsCopy[nX,nPosData]),aColsCopy[nX,nPosHrFm])

	//-- Soma as horas abonadas para consistencia
 	nHrsAbo := __TimeSum(nHrsAbo,aColsCopy[nX,nPosHrAB])

	//-- Implementar consistencia de horarios abonados em relacao a 
	//-- tabela de horario.
	If nSerHrAtuI >= nSerHrAntI .And. nSerHrAtuI < nSerHrAntF .And. nX # nY
		Help('',1,'PNA210FHOR')
		lRet := .F.

	ElseIf nSerHrAtuF > nSerHrAntI .And. nSerHrAtuF <= nSerHrAntF .And. nX # nY
		Help('',1,'PNA210FHOR')
		lRet := .F.
	Endif


Next nX

//-- Se a soma das horas abonadas para o evento atual for superior ao numero de horas do
//-- evento, nao valida os dados.
If !lChamadaNIL .and. ( nHrsAbo > nHrsEve )
	lRet := .F.
	Help('',1,'PNA210HMAIS')
Endif

Return( lRet )

/*/


Ŀ
Funo    Pn210Valid Autor  Mauro                  Data  06.08.94 
Ĵ
Descrio Critica a data da linha digitada                            
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function Pn210ValDt()

Local dData	:= &(ReadVar())
Local lRet := .T.

IF n <= Len(aColsAnt) .and. !lChamadaNIL
	IF aCols[n,nPosData] # M->PK_DATA .And. !Empty(aCols[n,nPosData])
	   lRet := .F.
	EndIF
ElseIF lChamadaNIL
	IF dData < dPerIni .or. dData > dPerFim
	   lRet := .F.
	EndIF
EndIF

Return( lRet )

/*


Ŀ
Funo    Pn210Horas Autor  Mauricio MR            Data  07/07/02 
Ĵ
Descrio  Calcula Hora Final Baseada em HoraIni+Abondas              
Ĵ
 Uso       PonA210                                                    
ٱ

*/
Function Pn210Horas()
Local lNoturno	:= .F.
Local nRet  := 0
Local aRetHrNot	:= {} 
Local nIniHnot 	:= 0
Local nFimHnot 	:= 0
Local nMinHnot 	:= 0    

If Type("M->PK_HrsAbo") <> "U"
   If !Empty(M->PK_HrsAbo)
		If !Empty(nPosHrAb) .AND. !Empty(nPosHrIn)
	  	   //Calcula e Sugere Hora Final do Abono (Hora Inicial + Saldo de Horas a Abonar)
		   If !Empty(nPosHrFm)
		   	   	/*/
				Ŀ
				 Obtem a Hora Noturna de Acordo com o Turno                  
				/*/ 
				aRetHrNot:= RetHrNot(dData)
				nIniHnot := aRetHrNot[1]	// Inicio da Hora Noturna
				nFimHnot := aRetHrNot[2]	// Final da Hora Noturna
				nMinHnot := aRetHrNot[3]	// Minutos da Hora Noturna
				lNoturno := fHorNot(aRetHrNot)						
       		    aCols[n, nPosHrFm] := RetFimTab(aCols[n,nPosData]  , aCols[n,nPosHrIn] , M->PK_HrsAbo , NIL, lNoturno, aCols[n,nPosData], 	nIniHnot, nFimHnot,  nMinHnot  )[2]
		        		   
		   	    nRet:=aCols[n, nPosHrFm]
		   Endif
		EndIf
   Endif
EndIf
Return nRet             

/*/


Ŀ
Funo    Pn210Evento  Autor  Mauricio MR            Data  24/06/02 
Ĵ
Descrio  Retorna Evento do Apontamento para ser utilizado na iniciali-
           zacao (X3_RELACAO) de novas linhas em GetDados dos Abonos.   
Ĵ
 Sintaxe   Pn210Evento()                                                
Ĵ
 Uso       Generico                                                     
ٱ

*/


Function Pn210Evento()

If Type("CEVENTO") == "U"
	cEvento :=Space(TamSx3("PK_CODEVE")[1])
Endif
Return cEvento



/*/


Ŀ
Funo    Pn210TpMarca Autor  Mauricio MR            Data  24/06/02 
Ĵ
Descrio  Retorna Tipo de Marcacao do Apontamento para ser utilizado   
           na inicializacao (X3_RELACAO) de novas linhas em GetDados de  
           abonos.                                                      
Ĵ
 Sintaxe   Pn210TpMarca()                                               
Ĵ
 Uso       Generico                                                     
ٱ

*/
Function Pn210TpMarca()
Local cRet := Space(TamSx3("PK_TPMARCA")[1])

If Type("CTPMARCA") <> "U"
	cRet := cTpMarca
else
	If Type("CTPMARCAINIT") <> "U"
		cRet	:= cTpMarcaInit
    Endif
Endif	

Return cRet  



/*


Ŀ
Funo    Pn210CC      Autor  Mauricio MR            Data  24/06/02 
Ĵ
Descrio  Retorna C.C. do Apontamento para ser utilizado na inicializa-
           cao (X3_RELACAO) de novas linhas em GetDados de Abonos.       
Ĵ
 Sintaxe   Pn210CC()                                                    
Ĵ
 Uso       Generico                                                     
ٱ

*/
Function Pn210CC() 
Local cRet := cRet :=SRA->RA_CC

If Type("CCCSPC") <> "U"
	cRet := cCCSPC
else
	If Type("CCCINIT") <> "U"
		cRet	:= cCCInit
    Endif
Endif	

Return cRet

/*


Ŀ
Funo    Pn210Data    Autor  Mauricio MR            Data  02/08/02 
Ĵ
Descrio  Retorna Data do Apontamento para ser utilizado na inicializa-
           cao (X3_RELACAO) de novas linhas em GetDados de Abonos.       
Ĵ
 Sintaxe   Pn210Data()                                                  
Ĵ
 Uso       Generico                                                     
ٱ

*/
Function Pn210DATA()
If Type("DDATASPC") == "U"
   dDataSPC :=Ctod('')
Endif
Return dDataSPC


/*
Ŀ
Funo     PKPostoInit  AutorEquipe Advanced RH  Data 31/01/2007
Ĵ
Descrio Inicializador padrao do campo PK_POSTO					  
Ĵ
Sintaxe   PKPostoInit()											  
Ĵ
 Uso      PONA280                                                   
Ĵ
 Retorno  cPosto													  
Ĵ
Parametros< Vide Parametros Formais >								  
*/
Function PKPostoInit() 
Local cRet:= SRA->RA_POSTO 

If Type("CPOSTOSPC") <> "U" 
	cRet    := cPostoSPC
ElseIf Type("CPOSTOINIT") <> "U" 
	cRet	:= cPostoInit	
Endif

Return( cRet )



/*
Ŀ
Funo     PKDeptoInit  AutorEquipe Advanced RH  Data 31/01/2007
Ĵ
Descrio Inicializador padrao do campo PK_DEPTO					  
Ĵ
Sintaxe   PKDeptoInit()											  
Ĵ
 Uso      PONA280                                                   
Ĵ
 Retorno  |cDepto													  
Ĵ
Parametros< Vide Parametros Formais >								  
*/
Function PKDeptoInit()
Local cRet:= SRA->RA_DEPTO

If Type("CDEPTOSPC") <> "U"
   cRet	:= cDeptoSPC       
ElseIf Type("CDEPTOINIT") <> "U"
	cRet	:=  cDeptoInit
   
Endif      

Return(cRet)

/*
Ŀ
Funo     PKProcesInit AutorEquipe Advanced RH  Data 31/01/2007
Ĵ
Descrio Inicializador padrao do campo PK_PROCES					  
Ĵ
Sintaxe   PKProcesInit()											  
Ĵ
 Uso      PONA280                                                   
Ĵ
 Retorno  |cProcess												  
Ĵ
Parametros< Vide Parametros Formais >								  
*/
Function PKProcesInit()
Local cRet	:= SRA->RA_PROCES

If Type("CPROCESSO") <> "U"
   cRet:= cProcesso
ElseIf Type("CPROCESINIT") <> "U"
	cRet	:= cProcesInit    
Endif
Return( cRet )


/*
Ŀ
Funo     PKFuncInit   AutorEquipe Advanced RH  Data 31/01/2007
Ĵ
Descrio Inicializador padrao do campo PK_CODFUNC				  
Ĵ
Sintaxe   |PKFuncInit()											  
Ĵ
 Uso      PONA280                                                   
Ĵ
 Retorno  |cFunc												  	  
Ĵ
Parametros< Vide Parametros Formais >								  
*/
Function PKFuncInit()
Local cRet:= SRA->RA_CODFUNC

If Type("CCODFUNCSPC") <> "U"
   cRet	:= cCodFuncSPC
ElseIf Type("CCODFUNCINIT") <> "U"  
	cRet:= cCodFuncInit 
Endif

Return( cRet )

/*
Ŀ
Funo     PKRoteirInit AutorEquipe Advanced RH  Data 31/01/2007
Ĵ
Descrio Inicializador padrao do campo PK_ROTEIR					  
Ĵ
Sintaxe   PKRoteirInit()											  
Ĵ
 Uso      PONA280                                                   
Ĵ
 Retorno  |cRoteiro											  	  
Ĵ
Parametros< Vide Parametros Formais >								  
*/
Function PKRoteirInit()
Local cRet	:= 'PON'

If Type("CROTEIRO") <> "U"
   cRet:= cRoteiro
ElseIf Type("CROTEIROINIT") <> "U"
   cRet:= cRoteiroInit 
Endif

Return( cRet )


/*
Ŀ
Funo     PKPeriodoInitAutorEquipe Advanced RH  Data 31/01/2007
Ĵ
Descrio Inicializador padrao do campo PK_PERIODO				  
Ĵ
Sintaxe   PKPeriodoInit()											  
Ĵ
 Uso      PONA280                                                   
Ĵ
 Retorno  |cPer												  	  
Ĵ
Parametros< Vide Parametros Formais >								  
*/
Function PKPeriodoInit()
Local cRet	:=  Space(TamSx3("PK_PERIODO")[1])

If Type("CPERIODO") <> "U"
   cRet:= cPeriodo
ElseIf Type("CPERIODOINIT") <> "U"
   cRet:= cPeriodoInit
Endif

Return( cRet ) 

              
/*
Ŀ
Funo     PKNumPagInit AutorEquipe Advanced RH  Data 31/01/2007
Ĵ
Descrio Inicializador padrao do campo PK_NUMPAG					  
Ĵ
Sintaxe   PKNumPagInit()											  
Ĵ
 Uso      PONA280                                                   
Ĵ
 Retorno  |cNumPag												  	  
Ĵ
Parametros< Vide Parametros Formais >								  
*/
Function PKNumPagInit() 
Local cRet	:=  Space(TamSx3("PK_NUMPAG")[1])

If Type("CNUMPAG") <> "U"
   cRet:= cNumPag
ElseIf Type("CNUMPAGINIT") <> "U"
   cRet:= cNumPagInit   
Endif 

Return( cRet )

/*


Ŀ
Funo    Pn210ValAb Autor  Fernando joly Siquini  Data  22/12/97 
Ĵ
Descrio  Valida o campo "Abono" e altera campos no aCols            
Ĵ
 Uso       PonA210                                                    
ٱ

*/
Function Pn210ValAb()

Local lRet  := .T.

If Empty(M->PK_CODABO)
	If nPosMotA > 0
		aCols[n, nPosMotA] := Space(Len(aCols[n, nPosMotA]))
	EndIf
	If nPosHrAB > 0
		aCols[n, nPosHrAB] := 0
	EndIf	
Else
	lRet := .F.
EndIf
Return lRet

/*


Ŀ
Funo    Pn210ValHr Autor  Alexsandro Pereira     Data  09/03/00 
Ĵ
Descrio  Valida o "Hora Inicial" e "Hora Final"                     
Ĵ
 Uso       PonA210                                                    
ٱ

*/
Function Pn210ValHr

Local lRet  := .T.
Local cVar  := ''
Local dData := Ctod('  /  /  ')
Local lNoturno	:= .T.
Local nHoras	:= 0.00   
Local nHorIni	:= aCols[n, nPosHrIn]  //--	Preserva valor original para comparacao posterior
Local aHorFim	:= {}					 //--	Preserva valor original para comparacao posterior    
Local nAbonar	:= 0.00

Local aRetHrNot	:= {} 
Local nIniHnot 	:= 0
Local nFimHnot 	:= 0
Local nMinHnot 	:= 0      

//Atualiza Campo Horas de Abono
If (cVar := ReadVar()) == 'M->PK_HRSABO'
    aCols[n, nPosHrAb]:= M->PK_HRSABO
Endif  

//Atualiza Campo Hora Inicial
If (cVar := ReadVar()) == 'M->PK_HORINI'
	nHorIni   			:= aCols[n, nPosHrIn]
    aCols[n, nPosHrIn]	:= M->PK_HORINI
Endif                                               

//Atualiza Campo Hora Final
If (cVar := ReadVar()) == 'M->PK_HORFIM'
    aCols[n, nPosHrFm]:= M->PK_HORFIM
Endif

If aCols[n, nPosHrIn] > 24 .Or. aCols[n, nPosHrFm] > 24
	//-- Consiste horas > 24
	Help('',1,'PN210VHMIN')
	lRet := .F.
ElseIf aCols[n, nPosHrIn] - Int(aCols[n, nPosHrIn]) > 0.59 .Or. aCols[n, nPosHrFm] - Int(aCols[n, nPosHrFm]) > 0.59;
    .Or. aCols[n, nPosHrAb] - Int(aCols[n, nPosHrAb]) > 0.59
	//-- Consiste minutos maior que .59
	Help('',1,'PN210VHMIN')
	lRet := .F.
Endif

//-- Se nao houver inconsistencias
If lRet

	//-- Atualiza o campo com as horas abonadas
	//-- verificando se o horario abonado passa de um dia para outro
	dData := aCols[n,nPosData]
	dData := If(aCols[n,nPosHrFm] < aCols[n,nPosHrIn],dData + 1, dData)
	/*/
	Ŀ
	 Obtem a Hora Noturna de Acordo com o Turno                  
	/*/ 
	aRetHrNot:= RetHrNot(dData)
	nIniHnot := aRetHrNot[1]	// Inicio da Hora Noturna
	nFimHnot := aRetHrNot[2]	// Final da Hora Noturna
	nMinHnot := aRetHrNot[3]	// Minutos da Hora Noturna
	lNoturno := fHorNot(aRetHrNot)						
	If (cVar := ReadVar()) == 'M->PK_HRSABO'
		//-- Somente sugere horario Final baseado nas horas abonadas + horario inicial
		//-- (Pode ser abono rapido ou gerado, o que, entao, nao teremos o intervalo de horas
		//-- que gerou as horas abonadas)   
		
		//-- Se Foram Informadas as Horas Abonadas calcula horario final
		If !Empty(cVar) 
		   aCols[n,nPosHrFm] := RetFimTab(aCols[n,nPosData]  , aCols[n,nPosHrIn] , aCols[n,nPosHrAB] , NIL, lNoturno, aCols[n,nPosData], 	nIniHnot, nFimHnot,  nMinHnot  )[2]
		Else    
		   //-- Se Nao foram informadas as horas abonadas calcula-as
		   nHoras 				:= Round(fCalHoras(dData, aCols[n,nPosHrFm], aCols[n,nPosData], aCols[n,nPosHrIn], Nil, Nil, lNoturno, aCols[n,nPosData],Nil,	nIniHnot, 	nFimHnot, nMinHnot), 2) 
		   aCols[n,nPosHrAB] 	:= fArrdAB(nHoras, nHrsEve)
		Endif
	ElseIf (cVar := ReadVar()) == 'M->PK_HORINI'
		//-- Somente sugere horas abonadas se ambas as horas nao forem zeradas
		//-- (Pode ser abono rapido ou gerado, o que, entao, nao teremos o intervalo de horas
		//-- que gerou as horas abonadas) 
		If !Empty(cVar) .OR.  !Empty(aCols[n,nPosHrFm])
	
  	       //	nHorIni := RetIniTab(dData , aCols[n,nPosHrFm] , 	Max(0,Subhoras(nHrsEve,PnTotAbo(aCols,aHeader,Len(aCols[1]), n ))) , NIL, lNoturno, dData, 	nIniHnot, nFimHnot,  nMinHnot  )[2]
		    nAbonar	:= 	Max(0,Subhoras(nHrsEve,PnTotAbo(aCols,aHeader,Len(aCols[1]), n )))    	
		    aHorFim :=  RetFimTab(aCols[n,nPosData] , aCols[n,nPosHrIn] , nAbonar , NIL, lNoturno, aCols[n,nPosData], 	nIniHnot, nFimHnot,  nMinHnot  )
		    
		    nHoras 				:=Round(fCalHoras(dData,  aCols[n,nPosHrFm], aCols[n,nPosData], aCols[n,nPosHrIn], Nil, Nil, lNoturno, aCols[n,nPosData],Nil,	nIniHnot, 	nFimHnot, nMinHnot), 2) 
			aCols[n,nPosHrAB] 	:= fArrdAB(nHoras, nAbonar)   
			aCols[n,nPosHrFm]	:= If(  DataHora2Str(dData, aCols[n,nPosHrFm]) > DataHora2Str(aHorFim[1], aHorFim[2] ) .and.  nHoras > nAbonar,  aHorFim[2],  aCols[n,nPosHrFm] ) 
	
			
		Endif
	ElseIf (cVar := ReadVar()) == 'M->PK_HORFIM'  
		//-- Somente sugere horas abonadas se ambas as horas nao forem zeradas
		//-- (Pode ser abono rapido ou gerado, o que, entao, nao teremos o intervalo de horas
		//-- que gerou as horas abonadas) 
		If !Empty(cVar) .OR.  !Empty(aCols[n,nPosHrIn])
		    nAbonar	:= 	Max(0,Subhoras(nHrsEve,PnTotAbo(aCols,aHeader,Len(aCols[1]), n )))    	
		     
	    	aHorFim := RetFimTab(aCols[n,nPosData] , aCols[n,nPosHrIn] , nAbonar , NIL, lNoturno, aCols[n,nPosData], 	nIniHnot, nFimHnot,  nMinHnot  )
		    
		    nHoras 				:=Round(fCalHoras(dData, M->PK_HORFIM, aCols[n,nPosData], aCols[n,nPosHrIn], Nil, Nil, lNoturno, aCols[n,nPosData],Nil,	nIniHnot, 	nFimHnot, nMinHnot), 2) 
			M->PK_HORFIM		:= If(  DataHora2Str(dData, M->PK_HORFIM) > DataHora2Str(aHorFim[1], aHorFim[2] ) .and.  nHoras > nAbonar,  aHorFim[2], M->PK_HORFIM ) 
			
			aCols[n,nPosHrAB] 	:= fArrdAB(nHoras, nAbonar)   
			aCols[n,nPosHrFm]	:= M->PK_HORFIM
		Endif
	Endif
Endif
Return lRet 

/*


Ŀ
Funo    Pn210VCodAb   Autor  Mauricio MR            Data  05/09/02 
Ĵ
Descrio  Valida o Cod. do Abono                                        
Ĵ
 Uso       PonA210                                                       
ٱ

*/
Function Pn210VCodAB()

Local lRet  := .T.
Local cHelp		:= ''

M->PK_CODABO := If(Type('M->PK_CODABO')=='U',aCols[n,nPosCodA],M->PK_CODABO)

//-- Nao permite campo vazio
If Empty(M->PK_CODABO) .And. !aCols[n,Len(aCols[n])]
	If 	! ASCAN(a210BrancoField,ALLTRIM(aHeader[nPosCodA][2])) > 0
	    	cHelp:=aHeader[nPosCodA][1]
	        Help( ' ' , 1 , 'NVAZIO' , , OemToAnsi( cHelp ) , 5 , 0 )
			Return .F.
	Endif		
Endif

//-- Atualiza campo virtual "Descricao do motivo de abono"
If Type(M->PK_CODABO) # Nil .And. SP6->(dbSeek(fFilFunc('SP6')+M->PK_CODABO))
	aCols[n,nPosMotA] := SP6->P6_DESC
Else
	aCols[n,nPosMotA] := STR0015 //'*** NAO CADASTRADO ***'
	lRet := .F.
Endif

Return lRet

/*


Ŀ
Funo    Pn210Pad   Autor  Maurico MR             Data  25/06/01 
Ĵ
Descrio  Preenche Campos Padraos                                    
Ĵ
 Uso       PonA210                                                    
ٱ

*/
Function Pn210Pad(dDataEvento,aHeaderSPC,aColsSPC,nLinSPC)

Local lRet 		:= .T.
Local naCols 	:=Len(aCols)
Local naCols1 	:=Len(aCols[1])
//Preenche Campos Obrigatorios      

// Data Abono
aCols[naCols,nPosData]:=dDataEvento 

// Flag de Geracao de Abono ("I"  - Informado)
aCols[naCols,nPosFlag]:="I"   
         

// Coluna de Deletados
aCols[naCols,naCols1]:=if(Empty(aCols[naCols,naCols1]),;
                                            .F.,;
                                            aCols[naCols,naCols1])


Return lRet



/*


Ŀ
Funo    PnTotAbo   Autor  Maurico MR             Data  05/07/01 
Ĵ
Descrio  Calcula Horas Abonadas apartir de aAcols                   
Ĵ
 Uso       PonA210                                                    
ٱ

*/

Function PnTotAbo(xCols,xHeader,nDeletado, nElem)

Local nX        := 0
Local nHrsAbo   := 0
Local nxCols	:=Len(xCols)
Local bSkip		:= {|X| If( nElem <> NIL, If(nElem == nX, .T., .F. ), .F.) } 
//-- Calcula Horas Abonadas
For nX := 1 To nxCols

	// Qdo a linha estiver marcada para delecao nao a valida
	If xCols[nX,nDeletado]  .OR. Eval(bSKIP)
		Loop
	Endif
    
   	//-- Soma as horas abonadas para consistencia e informacao
	nHrsAbo := __TimeSum( xCols[nX,nPosHrAB] , nHrsAbo )

Next nX

Return nHrsAbo      

/*


Ŀ
Funo    Pn210Flag  Autor  Maurico MR             Data  27/06/01 
Ĵ
Descrio  Devolve FLAG como "I" se houve alteracao no abono          
Ĵ
 Uso       PonA210                                                    
Ĵ
Retorno   cRet <=> "I para Informado (alteracao) ou "G" para gerado   
ٱ

*/
Function Pn210Flag(cCampo,aColsAtual,aColsCopia,nElem)

Local cRet := "I"         
//Como colocamos alguns Campos Pre-preenchidos, pode ocorrer que a informacao no Array 
//aCols nao esteja grava fisicamente. Temos que verificar se o campo contem a informacao. 
//Se nao havia registro de abono, campo Flag setado para informado  
If  Empty(cCampo)
    cRet:="I"
Else    
	//Se nao foram adicionados novos registros compara conteudo atual com anterior 
	If  nElem  <=LEN(aColsCopia)    
	                     
        //fCompArray retorna .T. se nao houve alteracao nas informacoes do registro
        //Para informacao alterada seta flag para informado "I"
        //Para informacao NAO alterada permanece FLAG
        cRet:=If(fCompArray(aColsAtual[nElem],aColsCopia[nElem]),cCampo,"I" )
    Else
        //Se foram adicionados outros abonos, campo Flag setado para informado "I" 
        cRet:="I"
    Endif
Endif                           

Return cRet

/*


Ŀ
Funo    Pn210Ordem Autor  Maurico MR             Data  1007/01  
Ĵ
Descrio  Coloca os Abonos em branco nas ultimas linhas do browse    
Ĵ
 Uso       PonA210                                                    
Ĵ
Retorno   aCols 													  
ٱ

*/
Function Pn210Ordem(aCols)

Local nX		:=	0
Local nY		:=	0
Local nW		:=	0
Local aSavCols	:=	{}
Local aColsCopy :=	{}

Local naCols	:= Len(aCols)							 
//-- Coloca abonos em branco nas ultimas linhas 
If naCols > 1                  

   //Identifica e Armazena Linhas com Abono em Branco para posterior uso
	For nX:=1 To naCols  
		If Empty(aCols[nX,nPosCodA]) 
	       AADD(aSavCols,Aclone(aCols[nX])) 
	    Else
           AADD(aColsCopy,Aclone(aCols[nX])) 	       
	    Endif
	Next nX   

	//Ordena Matriz com abonos em branco deixando as linhas DELETADAS em primeiro Lugar
	aSort(aSavCols,,, { |x,y|	x[Len(x)]	> y[Len(y)] } ) 
   
	//Ordena Abonos Preenchidos por Data/Hora    
	aSort(aColsCopy,,, bSort )             
	
	   
	//Joga Como ultimas linhas os Abonos em Branco salvos anteriormente  
	aCols:=Aclone(aColsCopy)
	nW:=Len(aSavCols)
	For nX:=1 To nW 
	    AADD(aCols,Aclone(aSavCols[nX])) 	                 
    Next nX
    
Endif

Return aCols
/*


Ŀ
Funo    RetHrNot   Autor  Maurico MR             Data  07/10/05 
Ĵ
Descrio  Retorna Horario e Minutos Noturnos conforme o Turno Atual  
Ĵ
 Uso       PonA210                                                    
Ĵ
Retorno   {nIniHnot, nFimHnot, nMinHnot}							  
ٱ

*/ 
Function RetHrNot(dData) 
Local aSr6Info	:= {}
Local nIniHnot  := 0
Local nFimHnot  := 0
Local nMinHnot	:= 0
Local cTno		:=''

	/*/
	Ŀ
	 Obtem o Turno para o Novo Calendario       			  	  
	/*/
	cTno	:= GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
								"1E"				,;	//02 -> Flag da Marcacao "1E,1S,..."
								dData		   		,;	//03 -> Data em aTabCalend
								aTabCalend			 ;	//04 -> Calendario de Marcacoes
				   		 	)/*/
	Ŀ
	 Obtem as Informacoes em Cache do Turno de Trabalho          
	/*/
	aSr6Info := {;
					"R6_INIHNOT"	,;	//01
					"R6_FIMHNOT"	,;	//02
					"R6_MINHNOT"	,;	//03
					"R6_HNOTFAL"	,;	//04  
					"R6_HNOTATR"	,;	//05										
					"R6_HNOTSAI"	;	//06					
				}
	aSr6Info := PosSR6( cTno , xFilial("SPJ") , aSr6Info , 01 , .F. )

	/*/
	Ŀ
	 Obtem a Hora Noturna de Acordo com o Turno                  
	/*/
	nIniHnot := aSr6Info[1]	// Inicio da Hora Noturna
	nFimHnot := aSr6Info[2]	// Final da Hora Noturna
	nMinHnot := aSr6Info[3]	// Minutos da Hora Noturna
	nHnotFal := aSr6Info[4]	// Indica a consideracao da hora noturna no calculo de falta/1/2 falta e intervalo quando pago
	nHnotAtr := aSr6Info[5]	// Indica a consideracao da hora noturna no calculo de atraso
	nHnotSai := aSr6Info[6]	// Indica a consideracao da hora noturna no calculo de saida antecipada/expediente

Return ( { nIniHnot, nFimHnot, nMinHnot, nHnotFal, nHnotAtr, nHnotSai } )		


/*


Ŀ
Funo    fGetCodNot Autor  Maurico MR             Data  01/03/06 
Ĵ
Descrio  Retorna String com todos os Eventos de Horario Noturno	  
Ĵ
 Uso       PonA210                                                    
Ĵ
Retorno   cStrCodigo -> String com os Eventos Noturnos do Ponto.	  
ٱ

*/ 
Static Function fGetCodNot()
Local aCodigos:= 	{ 	{"007N" ,"F" 	},; 	// 1/2 Falta
					 	{"008A"	,"F"	},;		// 1/2 Falta	
					  	{"009N"	,"F"	},;  	// Falta
					  	{"010A"	,"F"	},;		// Falta
					 	{"011N"	,"A"	},;		// Atraso
					 	{"012A"	,"A"	},;		// Atraso
					 	{"013N"	,"S"	},;		// Saida Antecipada
					 	{"014A"	,"S"	},;		// Saida Antecipada
					 	{"019N"	,"S"	},;		// Saida no Expediente	
					 	{"020A"	,"S"	},;  	// Saida no Expediente 
					 	{"032A"	,"F"	},;  	// Falta Intervalo Pago
					 	{"035N"	,"F"	};		// Falta Intervalo Pago	
					}
Local cCodigo	:= ""					
Local cStrCodigo:= ""	
Local nLoop		:= 0
	
For nLoop:= 1 to Len(aCodigos)
	If !Empty( ( cCodigo	:= PosSP9(aCodigos[nLoop,1],SRA->RA_FILIAL,"P9_CODIGO",2) ) ) 	
		cStrCodigo+=cCodigo+aCodigos[nLoop,2]+"."
	Endif	
Next nLoop	

Return (cStrCodigo)  


/*


Ŀ
Funo    fHorNot    Autor  Maurico MR             Data  02/03/06 
Ĵ
Descrio  Retorna Se Deve ser Aplicado o Horario Noturno na recompo- 
           sicao das horas.                                           
Ĵ
 Uso       PonA210 / Pona280                                          
Ĵ
Retorno   lNoturno   -> .T. Deve ser aplicado horario noturno         
ٱ

*/ 
Function fHorNot( aSR6HorNot)
Local nPos 			:= 0
Local lNoturno		:= .F.
Local cStrCodigo	:= fGetCodNot() // Carrega os codigos de apontamento com uso da hora noturna

If Type("CEVENTO") <> "U" // Para o Pona280 a variavel cEvento eh private dele e contem codigo do evento apontado
   cCodigo	:= cEvento
ElseIf Type("CCODEVE") <> "U" // Para o Pona210/130 a variavel cCodEVE eh private dele e contem codigo do evento apontado
	cCodigo	:= cCodEVE
Endif                 


nPos:= At( cCodigo, cStrCodigo)

If nPos > 0
	//-- Obtem o tipo de Horario Noturno a ser Considerado  
	cTipEve := Substr( cStrCodigo, nPos + 3, 1) 
	If cTipEve == "F"
	   lNoturno := ( aSR6HorNot[4] == "S")
	ElseIf cTipEve == "A"
	   lNoturno := ( aSR6HorNot[5] == "S")	
	ElseIf cTipEve == "S"
	   lNoturno := ( aSR6HorNot[6] == "S")	
	Endif                                    
Endif	
Return (lNoturno)



/*


Ŀ
Funo    fArrdAB    Autor  Maurico MR             Data  03/03/06 
Ĵ
Descrio  Retorna as horas Abonadas "arredondadas" devido ao uso da  
           hora noturna quando for o caso.                            
Ĵ
 Uso       PonA210                                                    
Ĵ
Retorno   lNoturno   -> .T. Deve ser aplicado horario noturno         
ٱ

*/ 
Static function fArrdAB(nHoras, nHrsEve)

nHoras:= If( nHoras > nHrsEve , nHrsEve, nHoras )

Return (nHoras)