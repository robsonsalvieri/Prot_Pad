#INCLUDE "PONR020.CH"
#INCLUDE "PROTHEUS.CH"

/*


Ŀ
Funo     PONR020   Autor  R.H. - J. Ricardo      Data  10.04.96 
Ĵ
Descrio  Totais dos codigos do ponto                                
Ĵ
Sintaxe    PONR020(void)                                              
Ĵ
Parametros                                                            
Ĵ
 Uso       Generico                                                   
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
Marinaldo   24/08/01------Retirada da Carga de Novas Perguntas  pois
            --------------Essas ja se Encontram na Base Oficial     
            --------------Imprimir o Rodape ao Termino do Relatorio 
Mauricio MR 21/12/01Acerto|Implementacao da fAbonos para tratamento  
                    ------de Tp.Marcacao, C.C. e multiplos abonos.  
Mauricio MR 08/02/02012887|Correcao de quebras com uso do fTestaTotal
 Priscila R.27/05/02------Ajuste no relatorio para que seja impresso 
            --------------corretamente o C.C no tamanho 20.          
Mauricio MR 01/10/02Melhor Inclusao de pergunta possibilitando a es- 
                    060139 colha de impressao de horas na base cen-  
                           tesimal e sexagesimal.                   
Mauricio MR 04/12/02------Retirada a restricao de existencia de cra- 
            --------------cha para a emissao do relatorio.	       
Ĵ
                        *** Versao 8.11 ***                            
Ĵ
Mauricio MR 04/04/03------Retirada da chamda da ValidPerg.           
Mauricio MR 30/03/04------Correcao da Referencia aos ABONOS do SPK   
            --------------quando arq Origem for de Acumulados e      
            --------------unificacao das funcoes de fSoma???.       
Ĵ
                        *** Versao 9.12 ***                            
Ĵ 
Leandro Dr  19/03/08------Inclusao de proces/periodo/roteiro/NPagto  
            --------------Inclusao de ordem por depto, impressao por 
            --------------data ou periodo, criacao de dois perguntes 
            --------------novos, PNR020A (impressao por periodo) e   
            --------------PNR020B (impressao por datas)              
Francisco Jr29/01/10000430Compatibilizar Fonte com gesto corporati- 
            ----------2010va.                                       
Luis Artuso 18/08/14024155Ajuste para localizar a filial na tabela   
            ----------2014de eventos.                               
ٱ

*/
Function PONR020()
//Ŀ
// Define Variaveis Locais (Basicas)                            
//
Local cDesc1  := STR0001  // 'Totais dos Codigos do Ponto'
Local cDesc2  := STR0002  // 'Ser impresso de acordo com os parametros solicitados pelo'
Local cDesc3  := STR0003  // 'usuario.'
Local cString := 'SRA' //-- Alias do arquivo principal (Base)
Local aOrd    := {STR0004 , STR0005 , STR0006 , STR0007 , STR0028 , STR0036 } // 'Matricula'###'Centro de Custo'###'Nome'###'Turno'###'C.Custo+Nome'###'Departamento'###
Local wnRel   := ''
Local aRegs   := {}
Local nFor	  := 0.00

//Ŀ
// Define Variaveis Private(Basicas)                            
//
Private aReturn  := {STR0008 , 1, STR0009 , 2, 2, 1, '', 1} // 'Zebrado'###'Administrao'
Private nomeprog := 'PONR020'
Private aLinha   := {}
Private nLastKey := 0
Private cPerg    := ''

//Ŀ
// Variaveis Utilizadas na funcao IMPR                          
//
Private Titulo   := OemToAnsi(STR0011 ) // 'Codigos do Ponto'
Private cCabec   := Titulo
Private AT_PRG   := 'PONR020'
Private wCabec0  := 1
Private wCabec1  := ''
Private CONTFL   := 1
Private LI       := 0
Private nTamanho := 'P'

//Ŀ
// Define Variaveis Private(Programa)                           
//
Private nOrdem
Private aInfo := {}
Private aEmpP := {} //-- Empresa
Private aEmpD := {}
Private aFilP := {} //-- Filial
Private aFilD := {}
Private aCcP  := {} //-- Centro de Custo ou turno
Private aCcD  := {}
Private aFunP := {} //-- Funcionario
Private aFunD := {}
Private aPeriodos := {}
Private lRoda := .F.	
Private cProcesso := Nil
Private cPeriodo  := Nil
Private cRoteiro  := Nil
Private cNumPagto := Nil
Private cDeptoDe
Private cDeptoAte
Private dPerIni   := Ctod("//")
Private dPerFim   := Ctod("//")
Private dInicio   := Ctod("//")
Private dFim      := Ctod("//")
Private dPerIniAux := Ctod("//")
Private dPerFimAux := Ctod("//")
Private lPeriodo   := .F.
Private nColPro
Private oPeriodo   := RHPERIODO():New()
Private oPerAnt    := RHPERIODO():New()

Begin Sequence

	/*
	Ŀ
	 Verifica se deve imprimir por Periodo ou Por Datas           
	*/
	If fOpcRadio(@nColPro, STR0001,;      //"Totais dos Codigos do Ponto"
						   STR0029,;      //"Selecione a opcao de impressao:"
				   		   STR0030,;      //"Por Periodo"
				   		   STR0031 ) == 0 //"Por Datas"
		Return
	EndIf
    
	cPerg := IF(nColPro == 1,"PNR020A","PNR020B")

	Pergunte(cPerg,.F.)
	
	If ( nColPro == 1 ) 
		cProcesso := mv_par01			//Processo
		cPeriodo  := mv_par02			//Periodo
		cRoteiro  := mv_par03			//Roteiro
		cNumPagto := mv_par04			//Numero de Pagamento
	EndIf
	
	//Ŀ
	// Envia controle para a funcao SETPRINT                        
	//
	wnRel := 'PONR020' //-- Nome Default do relatorio em Disco
	wnRel := SetPrint(cString, wnRel, cPerg, @Titulo, cDesc1, cDesc2, cDesc3, .F., aOrd,,nTamanho)

	//Ŀ
	// Ordem do Relatorio                                           
	//
	nOrdem		:= aReturn[8]


	//Ŀ
	// Carregando variaveis mv_par?? para Variaveis do Sistema.     
	//	
	If ( nColPro == 1 ) 
		lPeriodo := .T.	
		cProcesso   := mv_par01										//Processo
		cPeriodo    := mv_par02										//Periodo
		cRoteiro    := mv_par03										//Roteiro
		cNumPagto   := mv_par04										//Numero de Pagamento
		cDeptoDe    := mv_par05										//Depto De
		cDeptoAte   := mv_par06		   								//Depto Ate		
		FilialDe	:= mv_par07										//  Filial  De
		FilialAte	:= mv_par08										//  Filial  Ate
		CcDe		:= mv_par09										//  Centro de Custo De
		CcAte		:= mv_par10										//  Centro de Custo Ate
		TurDe		:= mv_par11										//	Turno De
		TurAte		:= mv_par12										//	Turno Ate
		MatDe		:= mv_par13										//  Matricula De
		MatAte		:= mv_par14										//  Matricula Ate
		NomDe		:= mv_par15										//  Nome De
		NomAte		:= mv_par16										//  Nome Ate
		cSit		:= mv_par17										//  Situacao
		cCat		:= mv_par18										//  Categoria
		lSalta		:= IF(mv_par19 == 1, .T., .F.)					//  Imprime C.C em outra Pagina
		lImpDia		:= IF(mv_par20 == 1, .T., .F.)					//  Imprime Dia a Dia
		cSinAna		:= IF(mv_par21 == 1, "A", "S")					//  Sintetico ou Analitico
		lImpAbon	:= IF(mv_par22 == 1, .T., .F.)					//  Imprime Abonados
		cTipCod		:= StrZero(mv_par23,1)							//  Imprime Autorizados/N.Autorizados/Ambos
		lTodos		:= IF(mv_par24 == 1 , .T. ,.F.)					//  Listar Eventos
		cEventos	:= ""
		For nFor := 1 To 30 Step 3
			IF !Empty( Subst( mv_par25 , nFor , 3 ) )
				cEventos += ( Subst( mv_par25 , nFor , 3 ) + "/" )	//  Eventos a Listar
			EndIF
		Next nFor
    
	    lSexaCent  := mv_par26										//	Horas em  (Sexagenal/Centesimal)
	Else
		lPeriodo := .F.	
		cProcesso   := mv_par01										//Processo
		dPerIni		:= mv_par02										//  Periodo Inicial
		dPerFim		:= mv_par03										//  Periodo Final
		cDeptoDe    := mv_par04										//Depto De
		cDeptoAte   := mv_par05		   								//Depto Ate		
		FilialDe	:= mv_par06										//  Filial  De
		FilialAte	:= mv_par07										//  Filial  Ate
		CcDe		:= mv_par08										//  Centro de Custo De
		CcAte		:= mv_par09										//  Centro de Custo Ate
		TurDe		:= mv_par10										//	Turno De
		TurAte		:= mv_par11										//	Turno Ate
		MatDe		:= mv_par12										//  Matricula De
		MatAte		:= mv_par13										//  Matricula Ate
		NomDe		:= mv_par14										//  Nome De
		NomAte		:= mv_par15										//  Nome Ate
		cSit		:= mv_par16										//  Situacao
		cCat		:= mv_par17										//  Categoria
		lSalta		:= IF(mv_par18 == 1, .T., .F.)					//  Imprime C.C em outra Pagina
		lImpDia		:= IF(mv_par19 == 1, .T., .F.)					//  Imprime Dia a Dia
		cSinAna		:= IF(mv_par20 == 1, "A", "S")					//  Sintetico ou Analitico
		lImpAbon	:= IF(mv_par21 == 1, .T., .F.)					//  Imprime Abonados
		cTipCod		:= StrZero(mv_par22,1)							//  Imprime Autorizados/N.Autorizados/Ambos
		lTodos		:= IF(mv_par23 == 1 , .T. ,.F.)					//  Listar Eventos
		cEventos	:= ""
		For nFor := 1 To 30 Step 3
			IF !Empty( Subst( mv_par24 , nFor , 3 ) )
				cEventos += ( Subst( mv_par24 , nFor , 3 ) + "/" )	//  Eventos a Listar
			EndIF
		Next nFor
    
	    lSexaCent  := mv_par25										//	Horas em  (Sexagenal/Centesimal)
	EndIf

	If	nLastKey == 27
	    Break
	Endif
	
	SetDefault(aReturn,cString)
	
	If nLastKey == 27
		Break
	Endif

    RptStatus({|lEnd| PO020Imp(@lEnd,wnRel,cString)},Titulo)

End Sequence

Return Nil

/*


Ŀ
Funo     PO020Imp  Autor  R.H. - J. Ricardo      Data  10.04.96 
Ĵ
Descrio  Folha de Pagamanto                                         
Ĵ
Sintaxe e  PO020Imp(lEnd,wnRel,cString)                               
Ĵ
Parametros lEnd        - Ao do Codelock                             
           wnRel       - Ttulo do relatrio                          
Parametros cString     - Mensagem                                     
Ĵ
 Uso       Generico                                                   
ٱ


*/
Static Function PO020Imp(lEnd,wnRel,cString)
Local cFil  := ''
Local cTno  := ''
Local cAcessaSRA := &("{ || " + ChkRH("PONR020","SRA","2") + "}")
Local cAcessaSPH := &("{ || " + ChkRH("PONR020","SPH","2") + "}")
Local cAcessaSPC := &("{ || " + ChkRH("PONR020","SPC","2") + "}")
Local naPeriodos := 0
Local nX		 := 0

Private lImpAcum := .F.

cAutorizado := ""

If lPeriodo
	oPeriodo:cProcesso := cProcesso
	oPeriodo:cPeriodo  := cPeriodo
	oPeriodo:cRoteiro  := cRoteiro
	oPeriodo:cNumPagto := cNumPagto
	
	oPeriodo:GetPer()
	
	If !(oPeriodo:lFound )
		MsgInfo( OemToAnsi( oPeriodo:cMsgNotFoundPer ) )    //"Perodo de Apontamento no encontrado."
		Return
	EndIf
	
	dPerIni := oPeriodo:dDataIni
	dPerFim := oPeriodo:dDataFim
	
	/*
	Ŀ
	Verifica se Impressao eh de Acumulado						  
	*/
	lImpAcum := oPeriodo:lFechado		// Se o periodo estiver fechado, imprimira do acumulado
	
	aPeriodos := {}
    
    //Na impressao por periodo, existira apenas um periodo, cuja data inicial e final virao da RCH
	aAdd( aPeriodos , { dPerIni , dPerFim , lImpAcum } )	
EndIf

dbSelectArea( "SRA" )
dbGoTop()
DbSetOrder(nOrdem)

If nOrdem == 1
	dbSeek(FilialDe + MatDe,.T.)
   	cInicio  := "SRA->RA_FILIAL + SRA->RA_MAT"
	cFim     := FilialAte + MatAte
ElseIf nOrdem == 2
	dbSeek(FilialDe + CcDe + MatDe,.T.)
   	cInicio  := "SRA->RA_FILIAL + SRA->RA_CC + SRA->RA_MAT"
	cFim     := FilialAte + CcAte + MatAte
ElseIf nOrdem == 3
	dbSeek(FilialDe + NomDe + MatDe,.T.)
   	cInicio  := "SRA->RA_FILIAL + SRA->RA_NOME + SRA->RA_MAT"
	cFim     := FilialAte + NomAte + MatAte
ElseIf nOrdem == 4
   	dbSeek(FilialDe + TurDe,.T.)
   	cInicio  := "SRA->RA_FILIAL + SRA->RA_TNOTRAB"
   	cFim     := FilialAte + TurAte
ElseIf nOrdem == 5
	dbSetOrder(8)
	dbSeek(FilialDe + CcDe + NomDe,.T.)
	cInicio  := 'SRA->RA_FILIAL + SRA->RA_CC + SRA->RA_NOME'
	cFim     := FilialAte + CcAte + NomAte
ElseIf nOrdem == 6
	dbSetOrder(22)
	dbSeek(FilialDe + cDeptoDe + MatDe,.T.)
	cInicio  := 'SRA->RA_FILIAL + SRA->RA_DEPTO + SRA->RA_MAT'
	cFim     := FilialAte + cDeptoAte + MatAte	
Endif

SetRegua(SRA->(RecCount()))

cFilAnterior := Replicate("@", FWGETTAMFILIAL)
cCcAnt       := "@@@@@@@@@"
cTurnoAnt    := "@@@"

dbSelectArea('SRA')
While !EOF() .And. &cInicio <= cFim

	IncRegua()

	If lEnd
		IMPR(cCancela,"C")
		Exit
	EndIF

	IF SRA->RA_FILIAL # cFilAnterior
    	If cFilAnterior # Replicate("@",FWGETTAMFILIAL)
			fImpFil()    // Totaliza Filial
	   	Endif
  	   	cFilAnterior := SRA->RA_FILIAL
       	If ! fInfo(@aInfo,SRA->RA_FILIAL)
        	Exit
       	Endif
       	cAutorizado := ""
       	dbSelectArea("SP9")
	   	dbSetOrder(1)
       	If ! DbSeek((cFilAnterior,xFilial("SP9")))        	
        	If ! DbSeek(Space(FWGETTAMFILIAL))
            	Exit
          	Endif
       	Endif
	    cFilCompara := SP9->P9_FILIAL
        While ! Eof() .AND. SP9->P9_FILIAL = cFilCompara
      		If Subs(P9_IDPON,4,1) = "A"
            	cAutorizado += P9_CODIGO+"A"
            Endif
            DbSkip()
       	EndDo

	   	//-- Varre o SP4 ( Horas Extras )				 
	   	If SP4->( dbSeek( ( cFil := If(Empty(xFilial('SP4')), xFilial('SP4'), SRA->RA_FILIAL) ) + ( cTno := SRA->RA_TNOTRAB ), .F.) ) .Or. ;
		  	SP4->( dbSeek( ( cFil := If(Empty(xFilial('SP4')), xFilial('SP4'), SRA->RA_FILIAL) ) + ( cTno := Space(3)        ), .F.) )
   		  	Do While !SP4->(Eof()) .And. cFil + cTno == SP4->P4_FILIAL + SP4->P4_TURNO	 
			 	If !Empty(SP4->P4_CODAUT)
					If SP9->( dbSeek(If(Empty(xFilial('SP9')), xFilial('SP9'), SRA->RA_FILIAL)+SP4->P4_CODAUT, .F.) )
				   		cAutorizado += SP4->P4_CODAUT + 'A'
					EndIf
			 	EndIf
			 	SP4->(dbSkip(1))
		  	Enddo
	   	Endif
			
	   	//-- Varre o SP6 (Abonos)
	   	Do While !SP6->(Eof())
		  	If !Empty(SP6->P6_EVENTO)
			 	If SP9->( dbSeek(If(Empty(xFilial('SP9')), xFilial('SP9'), SRA->RA_FILIAL)+SP6->P6_EVENTO, .F.) )
					cAutorizado += SP6->P6_EVENTO + 'A'
			 	EndIf
		  	EndIf
		  	SP6->(dbSkip(1))
	   	Enddo
				
	Endif
	
	
	//Ŀ
	// Consiste controle de acessos e filiais validas               
	//
	If SRA->( !(RA_FILIAL $ fValidFil()) .Or. !Eval(cAcessaSRA) )
		fTestaTotal()
		Loop
	EndIf

	//Ŀ
	// Consiste Parametrizacao do Intervalo de Impressao            
	//
	IF SRA->(;
				(  RA_TNOTRAB	< TurDe ) .or. ( 	RA_TNOTRAB	> TurAte ) .or. ;
				(  RA_NOME 		< NomDe ) .or. ( 	RA_NOME 	> NomAte ) .or. ;
				(  RA_MAT 		< MatDe ) .or. ( 	RA_MAT 		> MatAte ) .or. ;
				(  RA_CC 		< CCDe  ) .or. ( 	RA_CC 		> CCAte	 ) .or. ;
				(  RA_DEPTO		< cDeptoDe) .or. ( 	RA_DEPTO	> cDeptoAte	 ) )
		fTestaTotal()
		Loop
	EndIF

	If !Empty(cProcesso)
		If !( SRA->RA_PROCES == cProcesso )
			fTestaTotal()
			Loop
		EndIf
	EndIf
	
    If (SRA->RA_DEMISSA < dPerIni .AND. ! Empty(SRA->RA_DEMISSA))
  	   	fTestaTotal()
       	Loop
    Endif
 
	
    If !(SRA->RA_SITFOLH $ cSit) .Or. !(SRA->RA_CATFUNC $ cCat)
	   	fTestaTotal()
	   	Loop           // Testa Categoria e Situacao
	Endif

	//Caso impressao seja por data, ira verificar ultimo periodo do funcionario e comparar as datas informadas
	// com as datas do ultimo periodo
	If !lPeriodo
		oPerAnt:cProcesso := If ( Empty(SRA->RA_PRCFCH) , (If (Empty(cProcesso) , SRA->RA_PROCES , cProcesso )) , SRA->RA_PRCFCH )
		oPerAnt:cPeriodo  := If ( Empty(SRA->RA_PERFCH) , "" , SRA->RA_PERFCH )
		oPerAnt:cRoteiro  := If ( Empty(SRA->RA_ROTFCH) , "PON" , SRA->RA_ROTFCH )
		oPerAnt:cNumPagto := If ( Empty(SRA->RA_NUPFCH) , "" , SRA->RA_NUPFCH )
	    
		If Empty(oPerAnt:cPeriodo) .or. Empty(oPerAnt:cNumPagto)
			oPerAnt:PerSel()
		Else
		    oPerAnt:GetPer()
		EndIf

	    dPerIniAux  := oPerAnt:dDataIni
	    dPerFimAux	:= oPerAnt:dDataFim

  	   	aPeriodos := {}
		
		/*Se a data final do periodo anterior for menor que a data inicial informada, entao sera impresso
		  apenas um periodo, com as datas informadas e nao sera do acumulado 
		*/	    
	    If dPerFimAux < dPerIni
			aAdd( aPeriodos , { dPerIni , dPerFim , .F. } )
		Else
			/*Se a data final do periodo anterior for maior ou igual a data final informada, sera impresso
			  apenas um periodo, com as datas informadas.
			  Se o periodo anterior estiver fechado, sera impresso do acumulado.
			*/ 
			If ( dPerFimAux >= dPerFim )
				If ( dPerIniAux <= dPerIni )
					aAdd( aPeriodos , { dPerIni , dPerFim , oPerAnt:lFechado } )
				Else
					aAdd( aPeriodos , { dPerIni , dPerIniAux , .T. } )
					dPerIniAux++
					aAdd( aPeriodos , { dPerIniAux , dPerFim , oPerAnt:lFechado } )
				EndIf					
			Else
				/* Se a data final do periodo anterior for menor que a data final informada, sera impresso
				   dois periodos, o primeiro com inicio da data inicial informada e fim na data final do periodo
				   anterior ( imprimira do acumulado se o periodo anterior estiver fechado ) e o segundo com 
				   inicio na data final do periodo anterior + 1 e termino na data final informada.
				*/
				aAdd( aPeriodos , { dPerIni , dPerFimAux , oPerAnt:lFechado } )
				dPerFimAux++
				aAdd( aPeriodos , { dPerFimAux , dPerFim , .F. } )
			EndIf
		EndIf
	EndIf

	naPeriodos := Len( aPeriodos )
	For nX := 1 To naPeriodos
		dInicio := aPeriodos[ nX , 1 ]
		dFim    := aPeriodos[ nX , 2 ]
		lImpAcum := aPeriodos[ nX , 3 ]
		oPeriodo:dDataIni := dInicio   //-- Data Inicial a considerar para o Calendario
		oPeriodo:dDataFim := dFim   //-- Data Final a considerar para o calendario
		
		If lImpAcum
	
			dbSelectArea( "SPH" )
		   	If dbSeek(SRA->RA_FILIAL + SRA->RA_MAT )
			  	While !Eof() .And. SPH->PH_FILIAL+SPH->PH_MAT == SRA->RA_FILIAL+SRA->RA_MAT
					// Listar Apenas os Eventos Selecionados nos Parametros
			   	    IF !lTodos
					   	IF ! ( IF(!Empty(SPH->PH_PDI),SPH->PH_PDI,SPH->PH_PD) $ cEventos )
					   	  	dbSelectArea("SPH")
						  	dbSkip()
						  	Loop
					   	EndIF
					EndIF
					If SPH->PH_DATA >= dInicio .And. SPH->PH_DATA <= dFim
					   	If SPH->PH_QTABONO <= 0 .Or. ;
						   SPH->PH_QTABONO > 0 .And. lImpAbon
							
						  	//Ŀ
						  	// Consiste controle de acessos e filiais validas               
						  	//
						  	If SPH->( !Eval(cAcessaSPH) )
							   	SPH->(dbSkip())
							 	Loop
						  	EndIf
	
						  	//-- Cdigos Autorizados
						  	If If(!Empty(SPH->PH_PDI),SPH->PH_PDI,SPH->PH_PD) $ cAutorizado
							 	If cTipCod $ '13'
									fSoma(@aFunP,'SPH')
									fSoma(@aCcP ,'SPH')
									fSoma(@aFilP,'SPH')
									fSoma(@aEmpP,'SPH')
							 	EndIf
						  	Else //-- Cdigos no Autorizados
							 	If cTipCod $ '23'
							 		fSoma(@aFunD,'SPH')
									fSoma(@aCcD ,'SPH')
									fSoma(@aFilD,'SPH')
									fSoma(@aEmpD,'SPH')
							 	EndIf
						  	Endif
					   	Endif							
					EndIf							  
					dbSkip()
			  	Enddo
		   	Endif
		Else
			dbSelectArea( "SPC" )
			If dbSeek(SRA->RA_FILIAL + SRA->RA_MAT )
				While !Eof() .And. SPC->PC_FILIAL+SPC->PC_MAT == SRA->RA_FILIAL+SRA->RA_MAT
					// Listar Apenas os Eventos Selecionados nos Parametros
					IF !lTodos
						IF ! ( IF(!Empty(SPC->PC_PDI),SPC->PC_PDI,SPC->PC_PD) $ cEventos )
							dbSelectArea("SPC")
							dbSkip()
							Loop
						EndIF
					EndIF
					If SPC->PC_DATA >= dInicio .And. SPC->PC_DATA <= dFim
						If SPC->PC_QTABONO <= 0 .Or. ;
						   SPC->PC_QTABONO > 0 .And. lImpAbon
	
							//Ŀ
							// Consiste controle de acessos e filiais validas               
							//
							If SPC->( !Eval(cAcessaSPC) )
							   SPC->(dbSkip())
								Loop
							EndIf
	
							//-- Cdigos Autorizados
							If If(!Empty(SPC->PC_PDI),SPC->PC_PDI,SPC->PC_PD) $ cAutorizado
								If cTipCod $ '13'
									fSoma(@aFunP,'SPC')
								   	fSoma(@aCcP ,'SPC')
								    fSoma(@aFilP,'SPC')
								  	fSoma(@aEmpP,'SPC')
								EndIf
							Else //-- Cdigos no Autorizados
								If cTipCod $ '23'
									fSoma(@aFunD,'SPC')
								  	fSoma(@aCcD ,'SPC')
								   	fSoma(@aFilD,'SPC')
								  	fSoma(@aEmpD,'SPC')
								EndIf
							Endif
						EndIf
					Endif
					dbSkip()
				Enddo
			Endif
		Endif
		
		If Len(aFunP) == 0 .And. Len(aFunD) == 0
			fTestaTotal()
			Loop
		Endif
		
		fImpFun()
		
		fTestaTotal()

	Next nX

Enddo

//Ŀ
//Imprime o Rodape ao Termino do Relatorio.                     
//
IF lRoda
	IF Li < 58
		Li := 58
	EndIF
	Impr("","F")		
EndIF

//Ŀ
// Termino do relatorio                                         
//
dbSelectArea("SRA")
dbSetOrder(1)
Set Device To Screen
If aReturn[5] = 1
	Set Printer To
	Commit
	ourspool(wnRel)
Endif
MS_FLUSH()


/*


Ŀ
Funo     fSoma     Autor Leandro Drumond	     Data 19/03/2008
Ĵ
Descrio                                                             
Ĵ
Sintaxe e                                                             
Ĵ
Parametros                                                            
Ĵ
Uso        PONR020                                                    
ٱ
*/
Static Function fSoma(aMatriz, cAlias)
// 1- Matriz onde os dados estao sendo armazenados
// 2- Tipo de Arquivo "C" ou "I"
// 3- Prov/Desc/Base a ser gravado
Local cPrefix	:= ''
Local cProc     := ''
Local cPer		:= ''
Local cRot		:= ''
Local cNPag		:= ''
Local nRet      := 0
Local nVal1 	:= nVal2 := 0
Local nDia 		:= 0
Local aAbonos	:= {}
Local nLenABO	:= 0
Local nW		:= 0

cPrefix := ( PrefixoCpo( cAlias ) + "_" )
	
cCod  := If(!Empty( (cAlias)->&(cPrefix+"PDI") ),(cAlias)->&(cPrefix+"PDI"), (cAlias)->&(cPrefix+"PD") )
cProc := (cAlias)->&(cPrefix+"PROCES")
cPer  := (cAlias)->&(cPrefix+"PERIODO")
cRot  := (cAlias)->&(cPrefix+"ROTEIR")
cNPag := (cAlias)->&(cPrefix+"NUMPAG")

If lImpDia
	nDia := (cAlias)->&(cPrefix+"DATA")
Endif

nVal1 := (cAlias)->&(cPrefix+"QUANTI")
nVal2 := (cAlias)->&(cPrefix+"QUANTC")
nRet  := aScan( aMatriz,{|X| x[1] == cCod .AND. x[4] == nDia .AND. x[5] == cProc .AND. x[6] == cPer .AND. x[7] == cRot .AND. x[8] == cNPag} )   // Testa se ja existe

If	nRet == 0
    Aadd (aMatriz,{cCod,nVal1,nVal2,nDia,cProc,cPer,cRot,cNPag})  // se nao cria elemento
Else                                        // se ja so adiciona
    aMatriz[nRet,2] := SomaHoras(aMatriz[nRet,2],nVal1)
    aMatriz[nRet,3] := SomaHoras(aMatriz[nRet,3],nVal2)
Endif

aAbonos:={}

//-- Adiciona Abonos  coluna de Autorizados
If cCod $ cAutorizado 
	fAbonos((cAlias)->&(cPrefix+"DATA"),(cAlias)->&(cPrefix+"PD"),,@aAbonos,(cAlias)->&(cPrefix+"TPMARCA"),(cAlias)->&(cPrefix+"CC"),,(cAlias)->&(cPrefix+"CODFUNC"),(cAlias)->&(cPrefix+"DEPTO"),(cAlias)->&(cPrefix+"POSTO"),(cAlias)->&(cPrefix+"PROCES"),(cAlias)->&(cPrefix+"PERIODO"),(cAlias)->&(cPrefix+"ROTEIR"),(cAlias)->&(cPrefix+"NUMPAG") )
	nLenABO:=Len(aAbonos)
			
	//-- Se Existirem Abonos		
	If nLenAbo > 0 
		//-- Corre Todos os Abonos e Somente Soma aqueles que tiverem eventos associados
		For nW:=1 TO nLenABO
			//-- Para Cada Abono procura pelo motivo 
	    	If SP6->(dbSeek( fFilFunc('SP6') + aAbonos[nW,1], .F.))
	    	    //-- Se o motivo estiver associado a um evento soma-o
				If !Empty(SP6->P6_EVENTO)
					cCod  := SP6->P6_Evento	
					nVal1 := aAbonos[nW,2]
					nVal2 := 0
					//-- Cria Elemento
					If	( nRet := aScan( aMatriz,{|X| x[1] == cCod .AND. x[4] == nDia .AND. x[5] == cProc .AND. x[6] == cPer .AND. x[7] == cRot .AND. x[8] == cNPag} ) ) == 0
	    				Aadd (aMatriz,{cCod,nVal1,nVal2,nDia,cProc,cPer,cRot,cNPag})
					Else //-- Adiciona Elemento
	    				aMatriz[nRet,2] := SomaHoras(aMatriz[nRet,2],nVal1)
	    				aMatriz[nRet,3] := SomaHoras(aMatriz[nRet,3],nVal2)
					Endif              
				Endif
			Endif
		Next nW	
	Endif		
EndIf

Return Nil

/*


Ŀ
Funo    fTestaTotal Autor Leandro Drumond	     Data 19/03/2008
Ĵ
Descrio Executa Quebras                                             
Ĵ
Sintaxe e                                                             
Ĵ
Parametros                                                            
Ĵ
Uso        PONR020                                                    
ٱ
*/
Static Function fTestaTotal()

cCcAnt  	 := SRA->RA_CC
cTurnoAnt 	 := SRA->RA_TNOTRAB
cFilAnterior := SRA->RA_FILIAL

dbSelectArea( "SRA" )
dbSkip()

If	Eof() .Or. &cInicio > cFim
	fImpCc()
	fImpFil()
	fImpEmp()
Elseif cFilAnterior # SRA->RA_FILIAL
	fImpCc()
	fImpFil()
Elseif (cCcAnt # SRA->RA_CC .AND. (nOrdem == 2 .OR. nOrdem == 5)) .Or. ; 
       (cTurnoAnt # SRA->RA_TNOTRAB .AND. nOrdem == 4) .And. !Eof()
	fImpCc()
Endif

Return Nil

/*


Ŀ
Funo    fImpFun     Autor Leandro Drumond	     Data 19/03/2008
Ĵ
Descrio Imprime um Funcionario                                      
Ĵ
Sintaxe e                                                             
Ĵ
Parametros                                                            
Ĵ
Uso        PONR020                                                    
ٱ
*/
Static Function fImpFun

If	Len(aFunP) == 0 .And. Len(aFunD) == 0 
	Return Nil
Endif

If cSinAna == "A"
   fImprime(aFunP,aFunD,1)
Endif

aFunP := {}
aFunD := {}

Return Nil

/*


Ŀ
Funo    fImpCc      Autor Leandro Drumond	     Data 19/03/2008
Ĵ
Descrio Imprime Centro de Custo                                     
Ĵ
Sintaxe e                                                             
Ĵ
Parametros                                                            
Ĵ
Uso        PONR020                                                    
ٱ
*/
Static Function fImpCc

If Len(aCcP) == 0 .And. Len(aCcD) == 0
	Return Nil
Endif

If nOrdem ==  2 .OR. nOrdem == 4 .Or. nOrdem == 5
   fImprime(aCcP,aCcD,2) // Imprime
Endif

aCcP := {}
aCcD := {}

Return Nil

/*


Ŀ
Funo    fImpFil     Autor Leandro Drumond	     Data 19/03/2008
Ĵ
Descrio Imprime Filial			                                  
Ĵ
Sintaxe e                                                             
Ĵ
Parametros                                                            
Ĵ
Uso        PONR020                                                    
ٱ
*/
Static Function fImpFil

If  Len(aFilP) == 0 .And. Len(aFilD) == 0
	Return Nil
Endif

fImprime(aFilP,aFilD,3)

aFilP := {}
aFilD := {}

Return Nil

/*


Ŀ
Funo    fImpEmp     Autor Leandro Drumond        Data 19/03/2008
Ĵ
Descrio Imprime Empresa   		                                  
Ĵ
Sintaxe e                                                             
Ĵ
Parametros                                                            
Ĵ
Uso        PONR020                                                    
ٱ
*/
Static Function fImpEmp

If Len(aEmpP) == 0 .And. Len(aEmpD) == 0
	Return Nil
Endif

fImprime(aEmpP,aEmpD,4)

aEmpP := {}
aEmpD := {}

Return Nil

/*


Ŀ
Funo    fImprime    Autor Leandro Drumond        Data 19/03/2008
Ĵ
Descrio 							                                  
Ĵ
Sintaxe e                                                             
Ĵ
Parametros                                                            
Ĵ
Uso        PONR020                                                    
ٱ
*/
Static Function fImprime(aProv,aDesc,nTipo)

// nTipo: 1- Funcionario
//        2- Centro de Custo ou Turno
//		  3- Filial
//		  4- Empresa
Local cChave := Nil
Local cChaveAux := Nil
Local nMaximo
Local nConta
Local nX
Local nY
Local nTAC := nTNC := 0   // Totais de Calculado
Local nTAI := nTNI := 0   // Referencias
Local aDescAux := {}

//-- Ordenando os Arrays de Provento / Desconto
If lImpDia
	aProv := ASort (aProv,,,{|x,y| x[5]+x[6]+x[7]+x[8]+DtoS(x[4])+x[1] < y[5]+y[6]+y[7]+y[8]+DtoS(y[4])+y[1] })
	aDesc := ASort (aDesc,,,{|x,y| x[5]+x[6]+x[7]+x[8]+DtoS(x[4])+x[1] < y[5]+y[6]+y[7]+y[8]+DtoS(y[4])+y[1] })
Else
	aProv := ASort (aProv,,,{|x,y| x[5]+x[6]+x[7]+x[8]+x[1] < y[5]+y[6]+y[7]+y[8]+y[1] })
	aDesc := ASort (aDesc,,,{|x,y| x[5]+x[6]+x[7]+x[8]+x[1] < y[5]+y[6]+y[7]+y[8]+y[1] })
EndIf	

nMaximo:= MAX(Len(aProv),Len(aDesc))

nY := Len(aDesc)
nX := 1

//Insere espacos em branco no array a desc quando este no for igual a chave do array aProv
//Procedimento efetuado para nao ficar elementos com uma chave do lado "AUTORIZADO" e outra no "NAO AUTORIZADO"
If ( Len(aProv) > 0 )
	For nConta := 1 to nMaximo	
		If !( nX > nY )
			If !( nConta > Len(aProv) )
				If ( aProv[nConta,05]+aProv[nConta,06]+aProv[nConta,07]+aProv[nConta,08] == aDesc[nX,05]+aDesc[nX,06]+aDesc[nX,07]+aDesc[nX,08] )
					aAdd(aDescAux, aDesc[nX] )
					nX++
				Else
					aAdd(aDescAux, {'','','','','','','',''} )
				EndIf
			Else
				aAdd(aDescAux, {'','','','','','','',''} )
			EndIf
		Else
			aAdd(aDescAux, {'','','','','','','',''} )
		EndIf
	Next nConta
EndIf

If nX <= nY
	For nConta := nX to nY
		aAdd(aProv, {'','','','','','','',''} )
		aAdd(aDescAux, aDesc[nX] )
	Next nConta
EndIf

aDesc := {} 
aDesc := aClone(aDescAux)
		
nMaximo:= MAX(Len(aProv),Len(aDesc))

If	nTipo == 1
	If	Li + nMaximo + 4 >= 60	// Testa somente quando e funcionario
		Impr("","P")            // Salta Pagina caso nao caiba
	Endif
Elseif nTipo == 2
	If lSalta
		Impr("","P")
	Endif
Else
	Impr("","P")
Endif

WCabec1 := STR0012  + DTOC(dInicio) + " - " + DTOC(dFim) // "Periodo de: "

If nTipo == 1
    cDet := STR0013  + SRA->RA_FILIAL + "-" + SRA->RA_MAT + "-" + SRA->RA_NOME // "Func..: "
    cDet += SPACE(5) +STR0014  + SRA->RA_CHAPA // "  Chapa "
    IMPR(cDet,"C")
    cDet := STR0015  + SUBS(SRA->RA_CC+SPACE(20),1,20)+ SPACE(10) //" ### C.C.: "
    cDet += STR0016  + SRA->RA_CODFUNC + "-"+ DescFun(SRA->RA_CodFunc,SRA->RA_Filial) // "Funcao: "
    IMPR(cDet,"C")
    cDet := STR0017  + STR(SRA->RA_HRSMES,6,2) +STR0018  + DescCateg(SRA->RA_CATFUNC,30) // "  Hr.Mes: "###" Categ.: "
    IMPR(cDet,"C")    
    cDet := STR0019  + SRA->RA_TNOTRAB + SPACE(03) + STR0037 + SRA->RA_DEPTO + "-" + fDesc("SQB",SRA->RA_DEPTO,"QB_DESCRIC",40,SRA->RA_FILIAL)// "Tur.: " ### " Depto.: "
Elseif nTipo == 2 .and. (nOrdem == 2 .Or. nOrdem == 5)
    cDet:= STR0020  + cFilAnterior + STR0021  + cCcAnt + DescCc(cCcAnt,SRA->RA_Filial) // "Filial: "###" C.Custo: "
Elseif nTipo == 2 .and. nOrdem == 4
    cDet:= STR0020  + cFilAnterior + STR0022  + cTurnoAnt  // "Filial: "###" Turno: "
Elseif nTipo == 3
    cDet:= STR0020  + cFilAnterior + " " + aInfo[1] // "Filial: "
Elseif nTipo == 4
    cDet:= STR0023  + SM0->M0_NOMECOM // "Empresa: "
Endif

IMPR(cDet,"C")

IMPR("","C")

cDet:= SPACE(10)+STR0024 +SPACE(15)+STR0025  // "A U T O R I Z A D O"###"N A O   A U T O R I Z A D O"

IMPR(cDet,"C")
IMPR(Repl("-",80),"C")

/*
|DD COD DESCRICAO        Calc.    Infor.|DD Cod Descricao        Calc.    Infor.
|99 XXX 123456789012 999999.99 999999.99|99 XXX 123456789012 999999.99 999999.99
*/

cDet := If(lImpDia,"DD","  ")+STR0026  // " Cod Descricao        Calc.    Infor.|"
cDet += If(lImpDia,"DD","  ")+STR0027  // " Cod Descricao        Calc.    Infor."
//       DD 123 123456789012 999999.99 999999.99
IMPR(cDet,"C")

For nConta :=1 To nMaximo
	If !( nConta > Len(aProv) )
		If !Empty(aProv[nConta,1])
			cChaveAux := aProv[nConta,5] + aProv[nConta,6]+aProv[nConta,7]+aProv[nConta,8]
		Else
			cChaveAux := aDesc[nConta,5] + aDesc[nConta,6]+aDesc[nConta,7]+aDesc[nConta,8]
		EndIf
		//Se a chave (processo/periodo/roteiro/num. pag for diferente, imprime linha detalhe
		If !( cChave == cChaveAux )
			If !Empty(aProv[nConta,1])
				cDet := STR0032 + aProv[nConta,5] + ' - ' + STR0033 + aProv[nConta,6] + ' - ' + STR0034 + aProv[nConta,7] + ' - ' + STR0035 + aProv[nConta,8]
				cChave := aProv[nConta,5] + aProv[nConta,6]+aProv[nConta,7]+aProv[nConta,8]
			Else
				cDet := STR0032 + aDesc[nConta,5] + ' - ' + STR0033 + aDesc[nConta,6] + ' - ' + STR0034 + aDesc[nConta,7] + ' - ' + STR0035 + aDesc[nConta,8]
				cChave := aDesc[nConta,5] + aDesc[nConta,6]+aDesc[nConta,7]+aDesc[nConta,8]
			EndIf
			Impr(cDet,'C')
		EndIf
	    cDet := If (nConta > Len(aProv),Space(39),If(ValType(aProv[nConta,4])#'D','  ',;
	            StrZero(Day(aProv[nConta,4]),2)) + ' ' + ;
	            aProv[nConta,1]+" "+Left(DescPdPon(aProv[nConta,1]),12)+" "+;
	            Transform(If( lSexaCent==2, fConvHr(aProv[nConta,3],'D'), aProv[nConta,3] ),'999999.99' )+" "+;
	            Transform(If( lSexaCent==2, fConvHr(aProv[nConta,2],'D'), aProv[nConta,2] ),'999999.99' ))+"|"
    EndIf
    If !Empty(aDesc[nConta,1])
	    cDet += If(nConta > Len(aDesc),Space(39),If(ValType(aDesc[nConta,4])#'D','  ',;
	            StrZero(Day(aDesc[nConta,4]),2)) + ' ' + ;
	            aDesc[nConta,1]+" "+Left(DescPdPon(aDesc[nConta,1]),12) + ' ' + ;
	            Transform(If( lSexaCent==2, fConvHr(aDesc[nConta,3],'D'), aDesc[nConta,3] ),'999999.99' ) + ' ' + ;
	            Transform(If( lSexaCent==2, fConvHr(aDesc[nConta,2],'D'), aDesc[nConta,2] ),'999999.99' ))
	EndIf
    Impr(cDet,'C')
Next

IMPR(Repl("-",80),"C")

If nTipo # 1
    IMPR(REPL("=",80),"C")   // Salta Pagina apos Quebra Cc/Filial/Empresa
	If nTipo # 2 .Or. (nTipo == 2 .And. lSalta)
		Impr("","P")
	Else
		Impr("","C")
	Endif
Endif

lRoda := .T.

Return( NIL )
/*/
Ŀ
Funo	   Pnr020Proc	 	Autor  Leandro Drumond   Data 18/04/2008
Ĵ
Descrio Transferir o parametro MV_PAR01 para variavel private		
|		   |cProcesso    											    |
Ĵ
Sintaxe   <Vide Parametros Formais>									
Ĵ
Parametros<Vide Parametros Formais>									
Ĵ
Retorno   NIL                      									
Ĵ
Uso	   Generica      										    	
/*/
Function Pnr020Proc(cTip)

Local lRet := .T.

cProcesso := &( ReadVar() )

If ( cTip == 'A' )
	lRet := PonX1Valid(cProcesso)
Else
	If !Empty(cProcesso)
		lRet := PonX1Valid(cProcesso)
	EndIf
EndIf

Return( lRet )

/*/
Ŀ
Funo	   Pnr020Proc	 	Autor  Leandro Drumond   Data 18/04/2008
Ĵ
Descrio Transferir o parametro MV_PAR02 para variavel private		
|		   |cPeriodo    											    |
Ĵ
Sintaxe   <Vide Parametros Formais>									
Ĵ
Parametros<Vide Parametros Formais>									
Ĵ
Retorno   NIL                      									
Ĵ
Uso	   Generica      										    	
/*/
Function Pnr020Per()

Local cChave := cProcesso
Local lRet := .T.

If !Empty(cRoteiro)
	cChave += cRoteiro
Else
	cChave += "PON"
EndIf

cPeriodo := &( ReadVar() )

cChave += cPeriodo

lRet := PonX1Valid(cChave)

Return( lRet )

/*/
Ŀ
Funo	   Pnr020Rot	 	Autor  Leandro Drumond   Data 18/04/2008
Ĵ
Descrio Transferir o parametro MV_PAR03 para variavel private		
|		   |cRoteiro    											    |
Ĵ
Sintaxe   <Vide Parametros Formais>									
Ĵ
Parametros<Vide Parametros Formais>									
Ĵ
Retorno   NIL                      									
Ĵ
Uso	   Generica      										    	
/*/
Function Pnr020Rot()

Local lRet := .T.

cRoteiro := &( ReadVar() )

lRet := PonX1Valid(cProcesso+cRoteiro)

Return( lRet )

/*/
Ŀ
Funo	   Pnr020NPag	 	Autor  Leandro Drumond   Data 18/04/2008
Ĵ
Descrio Transferir o parametro MV_PAR04 para variavel private		
|		   |cNumPag	    											    |
Ĵ
Sintaxe   <Vide Parametros Formais>									
Ĵ
Parametros<Vide Parametros Formais>									
Ĵ
Retorno   NIL                      									
Ĵ
Uso	   Generica      										    	
/*/
Function Pnr020NPag()

Local lRet := .T.

cNumPagto := &( ReadVar() )

lRet := PonX1Valid(cProcesso+cRoteiro+cPeriodo+cNumPagto)

Return( lRet )