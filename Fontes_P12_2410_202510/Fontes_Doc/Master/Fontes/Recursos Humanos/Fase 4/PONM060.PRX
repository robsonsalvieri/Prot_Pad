#INCLUDE "PONM060.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "PONCALEN.CH"
     
Static lPnm060CposBlock
Static lPn060SRAAbono	
/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё PONM060  Ё Autor Ё Fernando Joly Siquini Ё Data Ё 22/09/97 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Abono Coletivo                                             Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso  	 Ё SIGAPON													  Ё╠╠
╠╠цддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё         ATUALIZACOES SOFRIDAS DESDE A CONSTRU─AO INICIAL.             Ё╠╠
╠╠цддддддддддддбддддддддбддддддбдддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁProgramador Ё Data   Ё BOPS Ё  Motivo da Alteracao                     Ё╠╠
╠╠цддддддддддддеддддддддеддддддедддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁMauricio MR Ё26/12/01ЁAcertoЁ  Correcao para considerar TpMarca e C.C. Ё╠╠
╠╠Ё            Ё------  Ё------Ё  na Geracao e Eliminacao dos Abonos.     Ё╠╠ 
╠╠Ё            Ё        Ё      Ё  Inclusao da IDTpMarca().	              Ё╠╠  
╠╠Ё=======================================================================Ё╠╠ 
╠╠Ё                         *** Versao 7.10 ***                           Ё╠╠ 
╠╠Ё=======================================================================Ё╠╠ 
╠╠ЁMauricio MR Ё26/02/02ЁMelhorЁA)Retirada da Funcao IDTpMarca apos a alteЁ╠╠ 
╠╠Ё            Ё        Ё------Ёracao do SX3 com a inclusao do campo SPK->Ё╠╠ 
╠╠Ё            Ё        Ё------ЁTpMarca.                                  Ё╠╠ 
╠╠ЁMarinaldo   Ё07/01/03ЁMelhorЁNao Mostrar mais o nome do funcionario masЁ╠╠
╠╠Ё            Ё        Ё      Ёa Evolucao percentual da Geracao de    AboЁ╠╠
╠╠Ё            Ё        Ё      Ёnos para ganho de performance             Ё╠╠
╠╠Ё            Ё        Ё      ЁSubstituicao da processa com uma barra  deЁ╠╠
╠╠Ё            Ё        Ё      ЁGauge pela com duas barras				  Ё╠╠
╠╠ЁMauricio MR Ё19/11/03ЁMelhorЁInclusao do Ponto de Entrada "PNM060SRA"  Ё╠╠
╠╠|Marinaldo   Ё21/04/04ЁMelhorЁTratamento nos Lock dos Registros e Delete|╠╠ 
╠╠|Mauricio MR Ё28/04/04ЁMelhorЁTratamento de cFilAnt para Integridade	  |╠╠
╠╠ЁIgor FranzoiЁ10/05/07Ё      ЁVerificar campos a mais para Query p/ SRA Ё╠╠
╠╠ЁLeandro DR  Ё07/03/08ЁMelhorЁInclusao de controle por processo         Ё╠╠
╠╠ЁErika K     Ё29/05/08Ё------ЁAlteracao nos indices da tabela SPK para  Ё╠╠
╠╠Ё            Ё        Ё      Ёcompatibilizacao de dicionarios.          Ё╠╠
╠╠юддддддддддддаддддддддаддддддадддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Function PONM060()

Local aArea			:= GetArea()
Local aSays			:= {}
Local aButtons		:= {}
Local cSvFilAnt		:= cFilAnt
Local lBarG1ShowTm 	:= .F.
Local lBarG2ShowTm 	:= .F.
Local nOpcA			:= 0

Private lAbortPrint := .F.
Private cCadastro   := OemToAnsi(STR0001 ) // 'Abono Coletivo'

DEFAULT lPnm060CposBlock	:= ExistBlock( "PNM060CPOS" )
DEFAULT lPn060SRAAbono		:= ExistBlock( "PNM060SRA"  )
/*
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё So Executa se os Modos de Acesso dos Arquivos Relacionados esЁ
Ё tiverm OK.												   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
IF ValidArqPon()

	aAdd(aSays,OemToAnsi( STR0003 ) )// 'Este programa tem  como  objetivo  gerar  Abonos para  os  Eventos '
	aAdd(aSays,OemToAnsi( STR0004 ) )// 'escolhidos, no intervalo de Datas e Funcion═rios parametrizado.    '
	
	aAdd(aButtons, { 5,.T.,{|| Pergunte("PONM060",.T. ) } } )
	aAdd(aButtons, { 1,.T.,{|o| nOpcA := 1,IF(gpconfOK(),FechaBatch(),nOpcA := 0 ) }} )
	aAdd(aButtons, { 2,.T.,{|o| FechaBatch() }} )
	
	FormBatch( cCadastro, aSays, aButtons )
	
	IF ( nOpcA == 1 )
		/*
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se deve Mostrar Calculo de Tempo nas BarGauge			 Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
		lBarG1ShowTm := ( SuperGetMv("MV_PNSWTG1",NIL,"N") == "S" )
		lBarG2ShowTm := ( SuperGetMv("MV_PNSWTG2",NIL,"S") == "S" )
		/*                               
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Executa o Processo de Abonos Coletivos                   			 Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
		Proc2BarGauge( { ||PNM060Proc() } , STR0005 , NIL , NIL , .T. , lBarG1ShowTm , lBarG2ShowTm ) // 'Gera┤└o de Abonos Coletivos'
	EndIF

EndIF

cFilAnt := cSvFilAnt
	
RestArea( aArea )

Return( NIL )

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддддддбдддддддбддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё PONM060Processa Ё Autor Ё Fernando Joly  Ё Data Ё 22/09/97 Ё╠╠
╠╠цддддддддддедддддддддддддддддадддддддаддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Processa o Abono de Horas                                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso  	 Ё SIGAPON							             			  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ                                                            Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Static Function PNM060Proc()

Local aAbonos		:= {}     //--  Array com os Abonos de um determinado Apontamento
Local aArea			:= {}
Local aPd			:= {}
Local aInfo			:= {}
Local aRecsBarG		:= {}
Local bSraScope		:= { || .F. }
Local cAcessaSRA	:= &("{ || " + ChkRH("PONM060","SRA","2") + "}")
Local cChave		:= ""      //--  Armazena campos chaves para efeito de pesquisa no SPK
Local cChave1		:= ""      //--  Armazena campos chaves para efeito de pesquisa no SPC
Local cCodABO		:= ""      //--  Contem o codigo do primeiro abono remanescente para atualizar o apontamento
Local cSvFilAnt		:= cFilAnt
Local cFilDe		:= ""
Local cFilAte		:= ""
Local cCCDe			:= ""
Local cCCAte		:= ""
Local cMatDe		:= ""
Local cMatAte		:= ""
Local cTnoDe		:= ""
Local cTnoAte		:= ""
Local cRegDe		:= ""
Local cRegAte		:= ""
Local cSit			:= ""
Local cCat			:= ""
Local cPD			:= ""
Local cMotAbo		:= ""
Local cInicio  		:= ""
Local cFim     		:= ""
Local cLastFil		:= "__cLastFil__"
Local cMsgBarG1		:= ""
Local cTimeIni		:= Time()
Local cMsgErr		:= ""
Local cProcesso		:= ""
Local dDataAtu		:= Ctod("//")
Local dDataIni		:= Ctod("//")
Local dDataFim		:= Ctod("//")
Local lAbonInt		:= .T.
Local lSobrepoe		:= .T.
Local lFoundAbono	:= .F.		//--  Indica que existe abono remanescente para o Apontamento qdo da Eliminacao
Local nExistAb		:= 0.00		//-- Existe evento para o abono (0=Default).
Local nX			:= 0.00
Local nNumHoras		:= 0.00
Local nHorasAbono	:= 0.00		//--  Variavel auxiliar para calculo de horas abonadas
Local naAbonos		:= 0.00		//--  Qtde de Abonos
Local nLastRec		:= 0.00
Local nIncPercG1	:= 0.00
Local nIncPercG2	:= 0.00
Local nRecsBarG		:= 0.00
Local nOrdem		:= 0

#IFDEF TOP
   	Local aStruSRA		:= {}
	Local aCposSRA		:= {}
	Local aTempSRA		:= SRA->( dbStruct() )
	Local cQuery	 	:= ""
	Local cQueryCond	:= ""
	Local lSraQryOpened	:= .F.
	Local lSrvAs400		:= ( TcSrvType() == "AS/400" )	
	Local nContField	:= Len( aTempSRA	)
	Local uRet			:= NIL
#ENDIF

Pergunte( "PONM060" , .F. )

/*
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Carregando as Perguntas 								       Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
nLimpGer   := mv_par01   //1 - Gera Abono  | 2 - Limpa Abono
cTipoAbono := If(mv_par02==1,"G",If(mv_par02==2,"I","G.I")) 
//Tipos de Abonos : 1 - Gerado      | 2 - Informado    | 3 - Ambos

cFilDe     := mv_par03
cFilAte    := mv_par04
cCCDe      := mv_par05
cCCAte     := mv_par06
cMatDe     := mv_par07
cMatAte    := mv_par08
cRegDe     := mv_par09
cRegAte    := mv_par10
cSit       := mv_par11
cCat       := mv_par12
dDataIni   := mv_par13
dDataFim   := mv_par14
cMotAbo    := mv_par15
cPD        := AllTrim(mv_par16)
lSobrepoe  := If(mv_par17==1, .T., .F.)
lAbonInt   := If(mv_par18==1, .T., .F.)
nNumHoras  := mv_par19
cTnoDe     := mv_par20
cTnoAte    := mv_par21
cProcesso  := mv_par22

/*
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Monta Array com as verbas a serem abonadas                   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
aPd    := {}
For nX := 1 To Len( cPd ) Step 3
	aAdd(aPd, SubStr( cPd , nX , 3 ) )
Next nX

/*
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Seta as Ordens do SPC e do SRA                               Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
SPC->( dbSetOrder(RetOrdem( "SPC" ) ) ) //-- PC_Filial + PC_MAT + PC_PD + DtoS(PC_DATA)

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Cria o Bloco dos Funcionarios que atendam ao Scopo	   	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If Empty(cProcesso)
	nOrdem := RetOrdem( "SRA" ) //-- RA_Filial + RA_Mat
	bSraScope	:= { ||;
	 			   			(;
								( RA_FILIAL		>= cFilDe	) .and. ( RA_FILIAL		<= cFilAte	) .and. ;
								( RA_REGRA 		>= cRegDe	) .and. ( RA_REGRA		<= cRegAte	) .and. ;
								( RA_MAT		>= cMatDe	) .and. ( RA_MAT		<= cMatAte	) .and. ;
								( RA_TNOTRAB	>= cTnoDe	) .and. ( RA_TNOTRAB	<= cTnoAte	) .and. ;
								( RA_CC			>= cCCDe	) .and. ( RA_CC			<= cCCAte 	)	    ;
	 			   			);
	 			   }
	/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Posiciona no Funcionario mais proximo						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	cInicio  := "RA_FILIAL + RA_MAT"
	cFim     := cFilAte + cMatAte
Else
	nOrdem := RetOrdem( "SRA" , "RA_FILIAL+RA_MAT+RA_PROCES" ) //-- RA_Filial + RA_Mat + RA_PROCES
	bSraScope	:= { ||;
	 			   			(;
								( RA_FILIAL		>= cFilDe	) .and. ( RA_FILIAL		<= cFilAte	) .and. ;
								( RA_REGRA 		>= cRegDe	) .and. ( RA_REGRA		<= cRegAte	) .and. ;
								( RA_MAT		>= cMatDe	) .and. ( RA_MAT		<= cMatAte	) .and. ;
								( RA_TNOTRAB	>= cTnoDe	) .and. ( RA_TNOTRAB	<= cTnoAte	) .and. ;
								( RA_CC			>= cCCDe	) .and. ( RA_CC			<= cCCAte 	) .and. ;
								( RA_PROCES		 = cProcesso)	    ;
	 			   			);
	 			   }
	/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Posiciona no Funcionario mais proximo						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	cInicio  := "RA_FILIAL + RA_MAT + RA_PROCES"
	cFim     := cFilAte + cMatAte + cProcesso
EndIF

SRA->( dbSetOrder( nOrdem ) )

/*
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Atualiza a Mensagem para a IncProcG1() (Cadastro de Empresas)Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
CREATE SCOPE aInfo FOR ( M0_CODIGO == cEmpAnt )
BarGauge1Set( ( nRecsBarG := SM0->( ScopeCount( aInfo ) ) ) )

#IFNDEF TOP

	/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica o Total de Registros a Serem Processados            Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	aRecsBarG := {}
	CREATE SCOPE aRecsBarG FOR Eval( bSraScope )
	SRA->( dbSeek( cFilDe , .T. ) )
	nLastRec := SRA->( ScopeCount( aRecsBarG ) )

	/*
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Procura primeiro funcion═rio.                               Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	If Empty(cProcesso)
		SRA->( dbSeek( cFilDe + cMatDe , .T. ) )
	Else
		SRA->( dbSeek( cFilDe + cMatDe + cProcesso , .T. ) )
	EndIf

#ELSE
	/*
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Seta apenas os Campos do SRA que serao Utilizados           Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	aAdd( aCposSRA , "RA_FILIAL"	)
	aAdd( aCposSRA , "RA_MAT" 		)	
	aAdd( aCposSRA , "RA_CC"		)
	aAdd( aCposSRA , "RA_TNOTRAB"	)
	aAdd( aCposSRA , "RA_REGRA"		)
	aAdd( aCposSRA , "RA_CATFUNC"	)
	aAdd( aCposSRA , "RA_SITFOLH"	)
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁVerifica e Seta os campos a mais incluidos no Mex             Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/				
	fAdCpoSra(aCposSra)
	
	/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Ponto de Entrada para Campos do Usuario                      Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	IF ( lPnm060CposBlock )
		IF ( ValType( uRet := ExecBlock("PNM060CPOS",.F.,.F.,aCposSRA) ) == "A" )
			IF Len( uRet ) >= Len( aCposSRA )
				aCposSRA := aClone(uRet)
				uRet	 := NIL
			EndIF
		EndIF
	EndIF
	For nX := 1 To nContField
		/*
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega os Campos do SRA para a Montagem da Query			   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
		IF aScan( aCposSRA , { |x| Upper(AllTrim(x)) == Upper( AllTrim( aTempSRA[ nX , 1 ] ) ) } ) > 0.00
			aAdd( aStruSRA , aClone( aTempSRA[ nX ] ) )
		EndIF
	Next nX
	aCposSRA	:= aTempSRA := NIL
	nContField	:= Len( aStruSRA )
	cQuery := "SELECT "
	For nX := 1 To nContField
		/*
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Inclui os Campos na Montagem da Query						   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
		cQuery += aStruSRA[ nX , 1 ] + ", "
	Next nX

	cQuery 		:= SubStr( cQuery , 1 , Len( cQuery ) - 2 )

	cQueryCond	+= "FROM "
	cQueryCond	+= InitSqlName("SRA")+" SRA "
	cQueryCond	+= " WHERE "
	cQueryCond	+= "SRA.RA_FILIAL>='"+cFilDe+"'"
	cQueryCond	+= " AND " 
	cQueryCond	+= "SRA.RA_FILIAL<='"+cFilAte+"'"
	cQueryCond	+= " AND " 
	cQueryCond	+= "SRA.RA_TNOTRAB>='"+cTnoDe+"'"	
	cQueryCond	+= " AND " 
	cQueryCond	+= "SRA.RA_TNOTRAB<='"+cTnoAte+"'"
	cQueryCond	+= " AND " 
	cQueryCond	+= "SRA.RA_MAT>='"+cMatDe+"'"
	cQueryCond	+= " AND " 
	cQueryCond	+= "SRA.RA_MAT<='"+cMatAte+"'"
	cQueryCond	+= " AND " 
	cQueryCond	+= "SRA.RA_CC>='"+cCCDe+"'"
	cQueryCond	+= " AND " 
	cQueryCond	+= "SRA.RA_CC<='"+cCCAte+"'"
	cQueryCond	+= " AND "
	If !Empty(cProcesso)
		cQueryCond	+= "SRA.RA_PROCES='"+cProcesso+"'"
		cQueryCond	+= " AND "
	EndIf
	cQueryCond	+= "SRA.D_E_L_E_T_=' ' "

	cQuery		+= cQueryCond
	cQuery		+= "ORDER BY "+SqlOrder( SRA->( IndexKey() ) )
	cQuery		:= ChangeQuery(cQuery)
	SRA->( dbCloseArea() ) //Fecha o SRA para uso da Query
	IF ( lSraQryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(,,cQuery),"SRA",.T.,.T.) )
		For nX := 1 To nContField
			IF ( aStruSRA[nX,2] <> "C" )
				TcSetField("SRA",aStruSRA[nX,1],aStruSRA[nX,2],aStruSRA[nX,3],aStruSRA[nX,4])
			EndIF
		Next nX
		/*
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica o Total de Registros a Serem Processados            Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
		cQuery := "SELECT COUNT(*) NLASTREC "
		cQuery += cQueryCond
		cQuery := ChangeQuery(cQuery)
        IF ( MsOpenDbf(.T.,"TOPCONN",TcGenQry(,,cQuery),"__QRYCOUNT",.T.,.T.) )
			nLastRec := __QRYCOUNT->NLASTREC
			__QRYCOUNT->( dbCloseArea() )
		Else
			MsAguarde( { || SRA->( dbEval( { || ++nLastRec } ) ) } , STR0006 + STR0007 )	//'Aguarde...'###'Selecionaldo Funcionarios'
			SRA->( dbGotop() )
		EndIF
	Else
		/*
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Restaura Arquivo Padrao e Ordem                             Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
		ChkFile( "SRA" , .F. )
		SRA->( dbSetOrder( nOrdem ) )
		/*
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica o Total de Registros a Serem Processados            Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
		aRecsBarG := {}
		CREATE SCOPE aRecsBarG FOR Eval( bSraScope )
		SRA->( dbSeek( cFilDe , .T. ) )
		nLastRec := SRA->( ScopeCount( aRecsBarG ) )
		/*
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Procura primeiro funcion═rio.                               Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
		If Empty(cProcesso)
			SRA->( dbSeek( cFilDe + cMatDe , .T. ) )
		Else
			SRA->( dbSeek( cFilDe + cMatDe + cProcesso , .T. ) )
		EndIf
	EndIF
#ENDIF

/*
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Inicializa a Mensagem para a IncProcG2() ( Funcionarios )	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
IncProcG2( OemToAnsi( STR0012 ) , .F. )	//'Processando...'

/*
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Inicializa a Regua para a IncProcG2() ( Funcionarios )	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
BarGauge2Set( nLastRec )

Begin Sequence

	While SRA->( !Eof() .and. &( cInicio ) <= cFim )

			/*
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Consiste filtro do intervalo De/At┌ ( SRA )                  Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
			IF SRA->( !Eval( bSraScope ) )
				SRA->(dbSkip())
				Loop
			EndIF

			/*
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Aborta o processamento									   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
			IF ( lAbortPrint )
				Break
			EndIF
	
			/*
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁCarrega as Filiais e Periodos de Apontamento                           Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
		    IF !( cLastFil == SRA->RA_FILIAL )
		    	cLastFil := SRA->RA_FILIAL  
		    	cFilAnt	 := IF( !Empty( cLastFil ) , cLastFil , cFilAnt )
				/*
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Obtem o % de Incremento da 2a. BarGauge					   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
				nIncPercG1 := SuperGetMv( "MV_PONINC1" , NIL , 5 , cLastFil )
				/*
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Obtem o % de Incremento da 2a. BarGauge					   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
				nIncPercG2 := SuperGetMv( "MV_PONINCP" , NIL , 5 , cLastFil )
				/*
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Atualiza a Mensagem para a IncProcG1() ( Turnos )			   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
				fInfo( @aInfo , cLastFil )
				cMsgBarG1 := (  STR0013 + " " + cLastFil + " - " + AllTrim( aInfo[3] ) ) ////"Filial:"
				/*
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Inicializa Mensagem na 1a BarGauge                           Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
				IncProcG1( cMsgBarG1 , .F.  )
				/*
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁIncrementa a Barra de Gauge referente a Filial				   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
				IncPrcG1Time( cMsgBarG1 , nRecsBarG , cTimeIni , .F. , 1 , nIncPercG1 )
		    EndIF
	
			/*
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Movimenta a R┌gua de Processamento                           Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
			IncPrcG2Time( OemToAnsi( STR0019 ) , nLastRec , cTimeIni , .T. , 2 , nIncPercG2 )	//"Processados:"

			/*
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Consiste Situa┤└o na Folha ( SRA )                           Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
			IF !( SRA->RA_SITFOLH $ cSit )
				SRA->( dbSkip() )
				Loop
			EndIF
			
			/*
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Consiste Categoria na Folha ( SRA )                          Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
			IF !( SRA->RA_CATFUNC $ cCat )
				SRA->(dbSkip())
				Loop
			EndIF
			
			/*
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Consiste controle de acessos e filiais validas               Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
			If SRA->( !(RA_FILIAL $ fValidFil()) .Or. !Eval(cAcessaSRA) )
				SRA->(dbSkip())
				Loop
			EndIf
		    
		    /*
		    здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁPonto de Entrada Para Tratar Funcionario 					   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
			IF ( lPn060SRAAbono ) 
				IF ( ValType( uRet := ExecBlock( "PNM060SRA",.F.,.F.)) == 'L')
					IF !uRet
						SRA->(dbSkip())
						Loop
					EndIF
					uRet	:= NIL
				EndIF
			Endif
		    
		    /*
		    здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Gera Abono Coletivo de acordo com os paramentros passados    Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
			If nLimpGer==1
			   /*
			   здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			   Ё Verifica se existem marca┤■es no SPC                         Ё
			   юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
				If SPC->(dbSeek(SRA->RA_Filial + SRA->RA_Mat , .F. ) )
					While SPC->(! Eof() .And. PC_Filial + PC_Mat == SRA->RA_Filial + SRA->RA_Mat )
						/*
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Aborta o processamento									   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
						IF ( lAbortPrint )
							Break
						EndIF
				
						 //здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						 //Ё Consiste filtro De/At┌ ( SPC )                               Ё
						 //юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						 If SPC->PC_Data < dDataIni .Or. SPC->PC_Data > dDataFim
							SPC->(dbSkip())
							Loop
						 EndIf
					
						 //здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						 //Ё Consiste se o Evento pertence aos Parametrizados ( SPC )     Ё
						 //юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If aScan(aPd, { |x| x == SPC->PC_PD } ) == 0
							SPC->(dbSkip())
							Loop
						EndIf
					                
						 //здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						 //Ё Consiste se o Apontamento com Codigo e/ou a Quantidade Informada  nao pode ser     Ё
						 //Ё abonado                                                                            Ё
						 //юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If !Empty(SPC->PC_QUANTI) 
							SPC->(dbSkip())
							Loop
						EndIf


						 //здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						 //Ё Consiste Processo ( SPC )  								  Ё
						 //юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If SPC->PC_PROCES <> SRA->RA_PROCES
							SPC->(dbSkip())
							Loop
						EndIf					
						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Consiste SobreGrava┤└o de Abonos ( SPC )                     Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						aAbonos:={}
						nExistAb := fAbonos(SPC->PC_DATA,SPC->PC_PD,,@aAbonos,SPC->PC_TPMARCA,SPC->PC_CC,,SPC->PC_CODFUNC,SPC->PC_DEPTO,SPC->PC_POSTO,SPC->PC_PROCES,SPC->PC_PERIODO,SPC->PC_ROTEIR,SPC->PC_NUMPAG)
						If !lSobrePoe .And. nExistAb >0
							SPC->(dbSkip())
							Loop
						EndIf

						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Define o Nёmero de Horas a ser Abonado                       Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						nNumH := nNumHoras
						If lAbonInt //-- Abono Integral
							nNumH := SPC->PC_QUANTC
						Else //-- Abono Parcial
							nNumH := Min(SPC->PC_QUANTC,nNumH)
						EndIf
					
						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Processa a Grava┤└o do Motivo e Horas do Abono               Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						IF !RecLock('SPC', .F.)
							SPC->(dbSkip())
							Loop
						EndIF
						
						SPC->PC_QTABONO := nNumH
						SPC->PC_ABONO   := cMotAbo 
					
						SPC->( MsUnLock() )
					                    
				        naAbonos:=Len(aAbonos)
					    //-- Corre Todos os Abonos do Apontamento e Deleta-os
					    For nX:=1 To naAbonos          
					        //-- Posiciona no Registro Segundo aAbonos[,8]
							SPK->(DbGoto(aAbonos[nX,8]))
							IF !RecLock('SPK',.F.,.T.)
								Loop
							EndIF
							IF !SPK->( FkDelete( @cMsgErr ) )
								SPK->( RollBackDelTran( cMsgErr ) )
							EndIF
							SPK->( MsUnlock() )
					    Next nX
					
						//Inclui Novo Abono    
						IF RecLock('SPK',.T.)
							SPK->PK_FILIAL	:= SRA->RA_FILIAL
							SPK->PK_MAT		:= SRA->RA_MAT
							SPK->PK_DATA	:= SPC->PC_DATA
							SPK->PK_CODEVE	:= SPC->PC_PD
							SPK->PK_CODABO	:= cMotAbo
							SPK->PK_HRSABO	:= nNumH
				        	SPK->PK_HORINI  := 0.00
					    	SPK->PK_HORFIM  := 0.00
	                    	SPK->PK_FLAG    := "G"  
	                    	SPK->PK_CC      := SPC->PC_CC
	                    	SPK->PK_TPMARCA := SPC->PC_TPMARCA
	                    	SPK->PK_POSTO   := SPC->PC_POSTO
	                    	SPK->PK_DEPTO	:= SPC->PC_DEPTO
	                    	SPK->PK_PROCES	:= SPC->PC_PROCES
	                    	SPK->PK_ROTEIR	:= SPC->PC_ROTEIR
	                    	SPK->PK_PERIODO := SPC->PC_PERIODO
	                    	SPK->PK_NUMPAG  := SPC->PC_NUMPAG
	                    	SPK->PK_CODFUNC := SPC->PC_CODFUNC
							SPK->( MsUnLock() )
						EndIF	
					
						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Seleciona o Pr╒ximo Evento                                   Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						SPC->(dbSkip())
			  		EndDo
				EndIf
			Else
				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Limpa Abonos de acordo com os parametros passados           Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды        
			
				//Posiciona no arquivo de Abonos
				dbSelectArea('SPK')
				dbSetOrder(RetOrdem( "SPK", "PK_FILIAL+PK_MAT+DTOS(PK_DATA)+PK_CODABO+STR(PK_HORINI,5,2)+PK_TPMARCA+PK_CC+PK_DEPTO+PK_POSTO+PK_CODFUNC"))   //Filial+Mat+Dtos(Data)+PK_CODABO   
				//Inicializa a variavel auxiliar para preencher em brancos o campo Motivo do Abono SPC->PC_ABONO (SPK->PK_CODABO)
				cLimpaMotAbo:=CriaVar('PK_CODABO',.T.)
						
				//Monta Chave de acordo com as opcoes desejadas 
	            cChave := ( xFilial( "SPK" , SRA->RA_FILIAL ) + SRA->RA_MAT )
			                         
				If dbSeek(cChave)
				    
				    //Corre Todos os Abonos da Chave Filial+Matricula+Abono 
					Do While SPK->( !Eof() .And. cChave == ( PK_FILIAL + PK_MAT ) )

						/*
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Aborta o processamento									   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
						IF ( lAbortPrint )
							Break
						EndIF
			            
						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Consiste Processo ( SPK ) 		                             Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If SPK->PK_PROCES <> SRA->RA_PROCES
							SPK->(dbSkip())
							Loop
						EndIf
						
						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Consiste cod. Func. ( SPK ) 		                             Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If SPK->PK_CODFUNC <> SRA->RA_CODFUNC
							SPK->(dbSkip())
							Loop
						EndIf						
			
						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Consiste filtro De/At┌ ( SPK )                               Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If SPK->PK_Data < dDataIni .Or. SPK->PK_Data > dDataFim
							SPK->(dbSkip())
							Loop
						EndIf
						
						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Consiste se o ABONO pertence aos Parametrizados ( SPK )      Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If SPK->PK_CODABO<>cMotAbo
							SPK->(Dbskip())
							Loop
						Endif 
						    	
						//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Consiste se o TIPO ABONO pertence ao Parametrizado ( SPK )   Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If !(SPK->PK_FLAG$cTipoAbono)
							SPK->(Dbskip())
							Loop
						Endif    						
						
						//здддддддддддддддддддддддддд©
						//ЁProcessa Limpeza de AbonosЁ
						//юдддддддддддддддддддддддддды
					    //Bloqueia registro de abono
					    IF !RecLock('SPK',.F.)
							SPK->(Dbskip())
							Loop
					    EndIF
						
					    //Posiciona no Apontamento que Gerou o Abono a ser Eliminado
					    dbSelectArea('SPC')
					    dbSetOrder(1)
						
						//Monta Chave1 de acordo com as opcoes desejadas 
						cChave1    := ( xFilial( 'SPC' , SRA->RA_FILIAL ) + SRA->RA_MAT + SPK->PK_CODEVE + Dtos(SPK->PK_DATA)+ SPK->PK_TPMARCA + SPK->PK_CC )
			                        
						//Procura pelo Apontamento que gerou o(s) Abono(s) a ser(rem) eliminado(s)                       
						//Bloqueia Apontamento e "Atualiza" campos sobre o abono a ser eliminado
						If dbSeek(cChave1) .and. RecLock('SPC', .F.)  

							//Calcula horas abonadas para o evento
							nHorasAbono:=Max(0,SubHoras(SPC->PC_QTABONO,SPK->PK_HRSABO))
							SPC->PC_QTABONO := nHorasAbono
							//Se o Qtde de Horas abonadas for reduzida a zero "nao deve haver" mais registros de abonos
							//para o evento abonado
							//Limpa a referencia ao abono no Apontamento(SPC)
							If Empty(nHorasAbono)
								SPC->PC_ABONO := cLimpaMotAbo
							Endif                                           
			               	   
							//Verifica se ha outros Abonos remanescentes no SPK  
							//para atualizar o codigo do abono no SPC.     
			               	   
							//Posiciona no arquivo de Abonos
							dbSelectArea('SPK') 
							//Armazena status da Area SPK (Area,Ordem e Registro corrente)   
							aArea := GetArea()
			                                   
							//-- Obtem Abonos de Acordo com o Apontamento Bloqueado
							aAbonos:={}
							nExistAb := fAbonos(SPC->PC_DATA,SPC->PC_PD,,@aAbonos,SPC->PC_TPMARCA,SPC->PC_CC,,SPC->PC_CODFUNC,SPC->PC_DEPTO,SPC->PC_POSTO,SPC->PC_PROCES,SPC->PC_PERIODO,SPC->PC_ROTEIR,SPC->PC_NUMPAG)
							naAbonos:=Len(aAbonos)
							//-- Corre Todos os Abonos do Apontamento 
							cCodABO		:=cLimpaMotAbo  //-- Inicializa com BRANCO 
							For nX:=1 To naAbonos          
								//-- Verifica se ha outro abono que nao seja o que foi lido 
								//-- e que pertenca ao mesmo apontamento
								If aAbonos[nX,8] <> aArea[3]
									cCodABO		:=aAbonos[nX,1]	//-- Substitui BRANCO pelo Codigo do Abono
								Endif
							Next nX
							//-- Atualiza o apontamento com BRANCO(Se somente existia um abono para o apontamento)
							//-- ou com o Codigo do primeiro abono remanescente
							dbSelectArea('SPC')              
							SPC->PC_ABONO := cCodABO     
			   				           
							//Libera bloqueio 					           
							SPC->( MsUnLock() )
						   
							//Posiciona no arquivo de Abonos (SPK) na ordem e registro original  
							RestArea(aArea)
						Endif
						
						//Reposiciona no Abono a ser Eliminado
						dbSelectArea('SPK')
						IF !SPK->( FkDelete( @cMsgErr ) )
							SPK->( RollBackDelTran( cMsgErr ) )
						EndIF
						SPK->( MsUnlock() )
				
						SPK->( DbSkip() )
					EndDo
				EndIf	
				//Restaura Area Principal
				dbSelectArea('SRA')
			Endif
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Seleciona pr╒ximo funcion═rio.                              Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			SRA->(dbSkip())
		EndDo

End Sequence

/*
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Fecha a Query do SRA e Restaura o Padrao                    Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
#IFDEF TOP
	IF ( lSraQryOpened )
		SRA->( dbCloseArea() )
		ChkFile( "SRA" )
	EndIF	
#ENDIF

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Restaura a integridade dos arquivos utilizados               Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
dbSelectArea('SPC')
dbSetOrder(1)

dbSelectArea('SRA')
dbSetOrder(1)

cFilAnt := cSvFilAnt

Return( NIL )

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддддддбдддддддбддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё fValidAbon      Ё Autor Ё Fernando Joly  Ё Data Ё 23/09/97 Ё╠╠
╠╠цддддддддддедддддддддддддддддадддддддаддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Verifica a existencia do Motivo de Abono                   Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё SIGAPON                                                    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cMot := Caracter, com 3 posi┤■es para o Motivo de Abono    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Function fValidAbon(cMot)

Local lRet      := .T.
Local nSP6Recno := SP6->(Recno())
Local nSP6Order := SP6->(IndexOrd())

If ValType(cMot) == 'U'
	cMot := &(ReadVar())
EndIf

If Empty(cMot)
	Help(' ',1,'NVAZIO')
	Return( .F. )
EndIf

SP6->(dbSetOrder(1))
If !SP6->(dbSeek(xFilial('SP6')+cMot, .F.))
	lRet := .F.
EndIf

//-- Retorna a Integridade do arquivo SP6
SP6->(dbSetOrder(nSP6Order))
SP6->(dbGoto(nSP6Recno))

Return( lRet )

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддддддбдддддддбддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё fValidHora      Ё Autor Ё Fernando Joly  Ё Data Ё 23/09/97 Ё╠╠
╠╠цддддддддддедддддддддддддддддадддддддаддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Verifica a digita┤└o de Horas em perguntas                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё SIGAPON                                                    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ nHor := Num┌rico, com 5 posi┤■es e 2 decimais para a Hora  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Function fValidHora(nCampo)

Local nHoras	:= 0
Local nMinutos := 0
Local lRet		:= .T.

If ValType(nCampo) == 'U'
	nCampo := &(ReadVar())
EndIf

nHoras	:= Val(Left (StrZero(nCampo,5,2),2))
nMinutos := Val(Right(StrZero(nCampo,5,2),2))

If nMinutos < 0 .Or. nMinutos > 59 .Or. ;
	nHoras < 0 .Or. nHoras > 23	
	lRet := .F.
EndIf

Return( lRet )
