#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEX1FUN.CH"
#INCLUDE "AP5MAIL.CH"
#INCLUDE "FWEVENTVIEWCONSTS.CH"

#define _CRLF CHR(13)+CHR(10)

Static cORGSPFL := GetMvRH( "MV_ORGSPFL", .F., 'N' )
Static lMensPE

/*
Ŀ
 Variaveis utilizadas nos valids e WHEN de datas.                         |
| Para datas passadas (data de nascimento) dever ser utilizado o nEpochOld|
| Para o futuro (data de demissao) devera ser utilizados o nEpochNew       |
*/
Static nEpochNew := Set(_SET_EPOCH,1940)       //1950 (padrao FRAME)
Static nEpochOld := Set(_SET_EPOCH,nEpochNew)

/*/


Ŀ
			ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.			  		    
Ĵ
Programador  Data	 FNC			   Motivo da Alteracao 			        
Ĵ
Flavio Corre25/02/15PCREQ-2898     Inclusao fonte   				   		    
Renan Borges02/09/15TSGAHV      	 Criado ponto de entrada GPM040MAIL, para  
                               	 enviar e-mail utilizando o M-Messenger,   
                               	 somente, para o evento 017 (Desligamento  
                               	 de Funcionrio), ao demitir um func.      
Marcos Perei03/09/15PCREQ-5342      Produtizao GFP (fcriacor e gplegend)	
Allyson M.  14/10/15TTLNPT    	     Ajuste em fGravaS033() p/ gravar os       
                              	     impostos na S033   					    
                               	 Funcao fM350VlPis() replicada da P11      
Gabriel A.  22/06/16TVLVKJ          Ajuste para no gravar valores negativos  
                                    de imposto na S033.                       
Matheus M.  05/10/65TVUVKZ    	     Ajuste em GpLegend() para utilizar os P.E 
                              	     GP010BWLEG e GPBWLEG.					    
|Claudinei S.|28/04/2017|MRH-482       |  Implementado o clculo para funcionrios|
|            |          |              |  com regime parcial. TabFaltas()         |
|Isabel N.   |18/08/2017|DRHPAG-2815   |Ajuste em fChkAfas() p/ limitar parmetro |
|            |          |              |por pas (lDSindAf apenas p/ Brasil).     |
ٱ

*/

/*


Ŀ
Funo	 FpHist82	 Autor  Equipe de RH			 Data  16.02.95 
Ĵ
Descrio  															  
Ĵ
Sintaxe	  															  
Ĵ
Parametros 															  
Ĵ
 Uso		 Generico													  
ٱ

*/
Function FPHIST82(cFil, cTipo, cCodigo, nPos1, nPos2, xNomeVar, xNomHlp)
	Local lFound := .T.
	Local xRetorno
	Local aSaveArea	:= GetArea()

	Default nPos1 := 0
	Default nPos2 := 0

	dbSelectArea("SRX")
	dbSetOrder(1)

	IF Empty(cCodigo) .AND. cCodigo != Nil
		lFound := .F.
		dbSeek(xFilial("SRX") + cTipo + cCodigo, .T.)

		While !Eof() .AND. RX_FILIAL == xFilial("SRX") .AND. RX_TIP == cTipo .AND. Subs(RX_COD, 1, 2) == "  "
			lFound := .T.
			Exit
		End
	ElseIf !dbSeek(xFilial("SRX") + cTipo + If(cCodigo == Nil, "", cCodigo))
		lFound := .F.
	EndIf

	If nPos1 > 0 .AND. nPos2 > 0
		If ! lFound
			If xNomeVar != Nil
				xNomeVar := Subs("** Nao Cadastrado **" + Space(nPos2), 1, nPos2)
				xRetorno := lFound
			Else
				xRetorno := Subs("** Nao Cadastrado **"+ Space(nPos2), 1, nPos2)
			EndIf
		Else
			If xNomeVar != Nil
				xNomeVar := Subs(SRX->RX_TXT, nPos1, nPos2)
				xRetorno := lFound
			Else
				xRetorno := Subs(SRX->RX_TXT, nPos1, nPos2)
			EndIf
		EndIf
	Else
		//---- CASO NAO ENCONTROU E PASSOU O NOME DO HELP ENTRA NO IF
		If !lFound .AND. xNomHlp != Nil
			Help(" ", 1, xNomHlp)
		EndIf

		xRetorno := lFound
	EndIf

	RestArea(aSaveArea)
Return xRetorno

/*/


Ŀ
Funo	 fTpContra  Autor  Equipe Maria		     Data  02/03/98 
Ĵ
Descrio Selecionar Tipo de Contrato 								  
Ĵ
Sintaxe	  fTpContra()											 	  
Ĵ
 Uso		  Generico 												  
ٱ

/*/
Function fTpContra(l1Elem,lForca)
Local cTitulo:=""
Local MvPar
Local MvParDef:=""

Private aCat:={}
Default	lForca	:= .F.
l1Elem := If (l1Elem = Nil , .F. , .T.)

cAlias := Alias() 					 // Salva Alias Anterior
MvPar:=&(Alltrim(ReadVar()))		 // Carrega Nome da Variavel do Get em Questao
mvRet:=Alltrim(ReadVar())			 // Iguala Nome da Variavel ao Nome variavel de Retorno

If lForca // SE PERMITIR SELECIONAR MAIS DE UM ELEMENTO, NAO APRESENTAR A OPCAO DE "AMBOS"
	aCat:={"1 - "+STR0026,"2 - " +STR0027}  //"Indeterminado"###"Determinado"
	MvParDef:="12"
else
	aCat:={"1 - "+STR0026,"2 - " +STR0027,"3 - " +STR0160}  //"Indeterminado"###"Determinado"###"Ambos"
	MvParDef:="123"
EndIf

cTitulo :=STR0028  //"Prazo Tipo Contrato"

IF f_Opcoes(@MvPar,cTitulo,aCat      ,MvParDef,12,49,Iif(lForca,!lForca,l1Elem),Iif(lForca,1,nil),Iif(lForca,2,nil))  // Chama funcao f_Opcoes
	&MvRet := If(Empty(mvpar), "3", mvpar)              // Devolve Resultado
EndIF
dbSelectArea(cAlias) 								 // Retorna Alias
Return( .T. )

/*


Ŀ
Funo    Calc_Idade   Autor  Equipe de RH         Data  16.02.95 
Ĵ
Descrio  Funcao para Calcular Idade dos Dependentes                 
Ĵ
Sintaxe   Calc_Idade( dDataBase , dDataNasc )						  
Ĵ
Parametros                                                            
Ĵ
 Uso      Generico                                                    
ٱ

*/
Function Calc_Idade( dDataBase , dDataNasc )

Local nMesa		:= 0
Local nMesb		:= 0
Local nIdade	:= 0

nIdade := ( Year( dDataBase ) - Year( dDataNasc ) )

IF ( nIdade < 0 )
	Return( 0 )
EndIf

nMesa	:= Month( dDataNasc )
nMesb	:= Month( dDataBase )

IF ( nMesb < nMesa )
	nIdade -= 1
EndIf

Return( nIdade )

/*/


Ŀ
Funcao     fCriaCor  Autor  Marina Shimano         Data 01.08.2000
Ĵ
Descrio  Funcao p/ definir cores p/ as situacoes dos funcionarios.  
Ĵ
Retorno   aCores                                                      
Ĵ
Parametros															  
ٱ

/*/
Function fCriaCor()

Local aCores	:=	{}
Local lGestPubl := if(ExistFunc("fUsaGFP"),fUsaGFP(),.f.)	//Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

If lGestPubl // Modulo Gestao de Folha Publica
	aadd(aCores,{ "SRA->RA_CATFUNC $ '78' .AND. SRA->RA_SITFOLH==' '   " , 'BR_CINZA'	})
	aadd(aCores,{ "SRA->RA_CATFUNC $ '9'  .AND. SRA->RA_SITFOLH==' '   " , 'BR_LARANJA'	})
EndIf

aadd(aCores,{ "SRA->RA_RESCRAI$'30/31'" , 'BR_PINK'		})
aadd(aCores,{ "SRA->RA_SITFOLH==' '" 	, 'BR_VERDE'	})
aadd(aCores,{ "SRA->RA_SITFOLH=='D'" 	, 'BR_VERMELHO'	})
aadd(aCores,{ "SRA->RA_SITFOLH=='A'" 	, 'BR_AMARELO'	})
aadd(aCores,{ "SRA->RA_SITFOLH=='F'" 	, 'BR_AZUL'		})
aadd(aCores,{ "SRA->RA_SITFOLH=='I'" 	, 'BR_LARANJA'	})

/*
Ŀ
 Ponto de Entrada para alterar cores do Browse do Cadastro    
*/
If ExistBlock("GPBWCORES")
	IF ValType( uRet := ExecBlock('GPBWCORES',.F.,.F.,aCores) ) == "A"
		aCores := aClone(uRet)
		uRet	 := NIL
	EndIf
EndIf

Return(aCores)



/*/


Ŀ
Funo    fMontaMail Autor  Natie                  Data  30/07/01 
Ĵ
Descrio  Monta Array com dados para envio de E-Mail por eventos     
Ĵ
Sintaxe    fMontaMail(cTpEvento,CExp1,CExp2,CExp3)                    
Ĵ
 Uso       Generico                                                   
Ĵ
Parametro  cTpEvento - Tipo do Evento a ser tratado                   
           cExp1     - cFilial                                        
           cExp2     - cMat                                           
           cExp3     - cNome                                          
ٱ

*/
Function fMontaMail(cTpEvento, aMsg)

Local aMesseng 		:= {}
Local cPeriodoAq	:= ""
Local cPeriodoGo	:= ""
Local cCargo		:= ""
Local cSetor		:= ""
Local cTitulo		:= ""
Local cMensagem 	:= ""

Local nY
Local lVldPE		:= .F.

DEFAULT aMsg        := {}
DEFAULT lMensPE		:= ( GetRpoRelease() <= "12.1.2310" .And. ExistBlock( "GPM040MAIL" ) )

If cTpEvento == "013"

	//Ŀ
	//  " Foi gerado necessidade de Treinamento para o(s) Funcionario(s): " 
	//  " Funcionario / Treinamento "										 
	//	   999999 - XXXXXXXXXXXXXXXXXX / 9999 - XXXXXXXXXXXXXX "			 
	//
	cMensagem := OemToAnsi(STR0118)+ _CRLF  	// " Foi gerado necessidade de Treinamento para o(s) Funcionario(s): "
	cMensagem += OemToAnsi(STR0119) + _CRLF		// " Funcionario / Treinamento"

	cTitulo := OemToAnsi(STR0133) // "Necessidade de Treinamento"

ElseIf cTpEvento =="015"
	//Aviso de ferias
	cPeriodoAq	:= Dtoc(M->RH_DATABAS) + " - " +Dtoc(M->RH_DBASEAT)				//Periodo Aquisitivo
	cPeriodoGo  := Dtoc(M->RH_DATAINI) + " - " +Dtoc(M->RH_DATAFIM)           	//Periodo Gozo das Ferias
	aAdd(aMesseng,{ SRA->RA_FILIAL,SRA->RA_MAT, LEFT(SRA->RA_NOME,30), cPeriodoAq , cPeriodoGo, str(M->RH_DFERIAS,4,1)  } )

	cTitulo := OemToAnsi(STR0145) // "Aviso de Ferias"

	cMensagem	:= OemToAnsi(STR0145) + _CRLF  												//"AVISO DE FERIAS "
	cMensagem 	+= OemToAnsi(STR0146) + _CRLF 												//"Foram programadas as ferias para o funcionario"
	cMensagem   += OemToAnsi(STR0128) + aMesseng[1][1] + _CRLF								//"Filial: "
	cMensagem   += OemToAnsi(STR0129) + aMesseng[1][2] + " - " + aMesseng[1][3] + _CRLF		//"Funcionario: "
	cMensagem 	+= OemToAnsi(STR0147) + aMesseng[1][4] + _CRLF   							//"Periodo Aquisitivo: "
	cMensagem  	+= OemToAnsi(STR0148) + aMesseng[1][5] +  " -> " + aMesseng[1][6] + _CRLF	//"Periodo de Gozo: "

ElseIf cTpEvento =="016"
	cAliasEv	:= Alias()
	//Admissao
	dbSelectArea("SRJ")
	If(dbSeek(cFilial + SRA->RA_CODFUNC),cCargo:= SRJ->RJ_DESC, cCargo)

	dbSelectArea("CTT")
	If(dbSeek(cFilial + SRA->RA_CC), cSetor:= CTT->CTT_DESC01, cSetor)
	dbSelectArea(cAliasEv)
	aAdd(aMesseng,{ SRA->RA_FILIAL,SRA->RA_MAT,LEFT(SRA->RA_NOME,30) , DtoC( SRA->RA_ADMISSA ),left(cCargo,15),left(cSetor,20)  })

	cTitulo 	:= OemToAnsi(STR0126)																		//"Admissao de Funcionarios"

	cMensagem 	:= OemToAnsi(STR0126) + _CRLF 																//"Admissao de Funcionarios"
	cMensagem 	+= OemToAnsi(STR0127) + _CRLF 		 														//"A partir dessa data, estara integrando ao nosso quadro de funcionarios:"
	cMensagem	+= OemToAnsi(STR0128) + SRA->RA_FILIAL + _CRLF												//"Filial: "
	cMensagem   += OemToAnsi(STR0129) + SRA->RA_MAT + "-" + LEFT(SRA->RA_NOME,30) + _CRLF					//"Funcionario: "
	cMensagem   += OemToAnsi(STR0130) + DtoC( SRA->RA_ADMISSA ) + _CRLF										//"Dt Admissao: "
	cMensagem 	+= OemToAnsi(STR0131) + AllTrim(SRA->RA_CC) + " - " +  left(cSetor,15) + _CRLF  			//"Centro de custo: "
	cMensagem   += OemToAnsi(STR0132) + AllTrim(SRA->RA_CODFUNC) + " - " + left(cCargo,20) + _CRLF 			//"Cargo: "


ElseIf cTpEvento =="017"
	//Rescisao
	cCargo	:= fDesc("SRJ", SRA->RA_CODFUNC, "RJ_DESC")
	cSetor 	:= fDesc("CTT", SRA->RA_CC     , "CTT_DESC01")
	aAdd(aMesseng,{ SRA->RA_FILIAL, SRA->RA_MAT, left(SRA->RA_NOME,30) , DTOC(dDataDem1) , left(cCargo,15), left(cSetor,20)  })

	cMensagem 	:= OemToAnsi(STR0149) + _CRLF 														// "DESLIGAMENTO DE FUNCIONARIO"
	cMensagem 	+= OemToansi(STR0150) + _CRLF														// "Foi efetuado o desligamento do funcionario :"
	cMensagem	+= OemToAnsi(STR0128) + aMesseng[1][1] + _CRLF										// "Filial: "
	cMensagem   += OemToAnsi(STR0121) + aMesseng[1][2] + "-" + aMesseng[1][3] + _CRLF				// "Funcionario: "
	cMensagem   += OemToAnsi(STR0151) + aMesseng[1][4] + _CRLF										// "Data Demissao: "
	cMensagem 	+= OemToAnsi(STR0131) + Alltrim(SRA->RA_CC) + " - " + aMesseng[1][6] + _CRLF    	// "Centro de custo: "
	cMensagem   += OemToAnsi(STR0132) + AllTrim(SRA->RA_CODFUNC) + " - " + aMesseng[1][5] + _CRLF 	// "Cargo: "

	If lMensPE
		If !(Valtype(lVldPE := ExecBlock( "GPM040MAIL", .F.,.F. )) == "L")
			lVldPE := .F.
		EndIf
	EndIf

ElseIf cTpEvento =="018"
	cAliasEv	:= Alias()
	//Afastamento
	cPeriodoAq	:= dtoc(SR8->R8_DATAINI) + " - " + dtoc(SR8->R8_DATAFIM)
	dbSelectArea("RCM")
	dbSeek(xFilial("RCM")+SR8->R8_TIPOAFA)
	If ! eof()
		cTipo := SUBS(RCM->RCM_DESCRI,1,34)
	Else
		cTipo := "Tipo Nao Cadastrado  na  Tabela 30"
	EndIf
	dbSelectArea(cAliasEv)
	cPeriodoAq	:= dtoc(SR8->R8_DATAINI) + " - " + dtoc(SR8->R8_DATAFIM)
	aAdd(aMesseng,{cFilial, SRA->RA_MAT, Left(SRA->RA_NOME,30), 	cPeriodoAq, cTipo} )

	cTitulo 	:= OemToAnsi(STR0142) 		 											//"Funcionario Afastado "
	cMensagem 	:= OemToansi(STR0143) + _CRLF											//"O Funcionario abaixo estara em periodo de afastamento :"
	cMensagem	+= OemToAnsi(STR0128) + aMesseng[1][1] + _CRLF							//"Filial: "
	cMensagem   += OemToAnsi(STR0121) + aMesseng[1][2] + "-" + aMesseng[1][3] + _CRLF	//"Funcionario: "
	cMensagem   += OemToAnsi(STR0144) + aMesseng[1][4] + _CRLF							//"Dt Afastamento: "
	cMensagem   += OemToAnsi(STR0135) + SR8->R8_TIPOAFA + " - " + aMesseng[1][5] +_CRLF	//"Motivo: "

ElseIf  cTpEvento == "019"
	//Transferencia
	cCargo	:= fDesc("SRJ", SRA->RA_CODFUNC, "RJ_DESC")
	cSetorD	:= fDesc("CTT", SRE->RE_CCD    , "CTT_DESC01")
	cSetorP	:= fDesc("CTT", SRE->RE_CCP    , "CTT_DESC01")
	aAdd(aMesseng,{SRA->RA_NOME, cCargo, SRE->RE_EMPD,SRE->RE_FILIALD,SRE->RE_MATD, SRE->RE_CCD,cSetorD,SRE->RE_EMPP,SRE->RE_FILIALP,SRE->RE_MATP, SRE->RE_CCP,cSetorP ,dtoc(SRE->RE_DATA) } )
	dbSelectArea("SRJ")
	dbSetOrder(1)
	cFil := Iif(xFilial("SRJ") == Space(FWGETTAMFILIAL), Space(FWGETTAMFILIAL), xFilial( "SRJ", SRA->RA_FILIAL))
	dbSeek(cFil + SRA->RA_CODFUNC)

	cTitulo 	:= OemToAnsi(STR0136)														//"Empregado transferido "

	cMensagem 	:= OemToAnsi(STR0136) + _CRLF 												//"Empregado transferido "
	cMensagem 	+= OemToansi(STR0137) + _CRLF												//"Foi efetuada transferencia do funcionario: "
	cMensagem   += OemToAnsi(STR0121) +  aMesseng[1][5] + "-" + aMesseng[1][1] + " - " + aMesseng[1][2] + _CRLF  //"Nome: "
	cMensagem   += OemToAnsi(STR0138) + _CRLF												//"Transferido de:"
	cMensagem	+= OemToAnsi(STR0139) + aMesseng[1][3] + _CRLF								//"Empresa: "
	cMensagem	+= OemToAnsi(STR0128) + aMesseng[1][4] + _CRLF								//"Filial: "
	cMensagem   += OemToAnsi(STR0131) + AllTrim(aMesseng[1][6]) + " - " + aMesseng[1][7] + _CRLF  //"Centro de Custo: "

	cMensagem   += OemToAnsi(STR0140) + _CRLF                   							//"Transf. Para: "
	cMensagem   += OemToAnsi(STR0139) + aMesseng[1][8] + _CRLF								//"Empresa: "
	cMensagem   += OemToAnsi(STR0128) + aMesseng[1][9] + _CRLF								//"Filial: "
	cMensagem 	+= OemToAnsi(STR0131) + AllTrim(aMesseng[1][11])+ "-" + aMesseng[1][12] + _CRLF //"Centro Custo: "
	cMensagem   += OemToAnsi(STR0141) + aMesseng[1][13]+ _CRLF								//"Data Alteracao: "

ElseIf  cTpEvento == "020"

	// Admissao de Funcionarios por Recrutamento Interno
    Aadd(aMesseng,{	STR0120 + SQS->QS_VAGA+" - "+SQS->QS_DESCRIC,; 	//"Vaga: "
    			    STR0121 + SRA->RA_NOME,;						//"Nome: "
    			    STR0122 + SRA->RA_CODFUNC+" - "+SRJ->RJ_DESC,;	//"Funcao: "
    			    STR0123 + STR(SRA->RA_SALARIO,12,2)})			//"Salario: "

	cMensagem := OemToAnsi(STR0124) + _CRLF 		// "Funcionario foi aprovado no processo de Recrutamento Interno, "
	cMensagem += OemToAnsi(STR0125) + _CRLF 		// "favor realizar suas alteracoes cadastrais: "

	cMensagem += aMesseng[1,1] + _CRLF
	cMensagem += aMesseng[1,2] + _CRLF
	cMensagem += aMesseng[1,3] + _CRLF
	cMensagem += aMesseng[1,4] + _CRLF

EndIf

If Len(aMesseng)> 0 .Or. !Empty(cMensagem)

	If Len(aMsg) > 0
		For nY := 1 to Len(aMsg)
			cMensagem += aMsg[nY][1] + " / " + aMsg[nY][2] + _CRLF
		Next nY
	EndIf

	If !lVldPE
		// Para a verso 11.5 utilizar o EventViewer e para versoes anteriores o M-Messenger
		EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES , cTpEvento, FW_EV_LEVEL_INFO, "" /*"&[USERID='000001'] - Filtro de Usuario"*/, cTitulo, cMensagem, .T. )
	Else
		mEnviaMail( cTpEvento, aMesseng,,,,.T.)
	EndIf
EndIf

Return( NIL )

/*
Ŀ
Funo	   fPackGpe   Autor  Marinaldo de Jesus 	   Data 07/02/2002
Ĵ
Descrio Limpar os Registros Deletados dos Arquivos do Modulo GPE    
Ĵ
Sintaxe   fPackGpe( cPrefixPack , aAliasNotPack  )					
Ĵ
Parametros                                                            
Ĵ
 Uso	    Generico 												    
*/
Function fPackGpe( cPrefixPack , aAliasNotPack , lChkFile  )

Local cAliasPack		:= ""
Local nAliasPack		:= 0.00
Local nPrefixSize		:= 0.00
Local nFopened			:= Len( cFopened )

Default cPrefixPack		:= "SR"
Default aAliasNotPack	:= {}
Default lChkFile		:= .T.

nPrefixSize := Len( cPrefixPack )

For nAliasPack := 1 To nFopened Step 3

	cAliasPack := Upper( SubStr( cFopened , nAliasPack , 3 ) )

    /*
	Ŀ
	Minimiza o Aparente Congelamento do Remote                    
	*/
    ProcessMessages()

    /*
	Ŀ
	Limpa os Registros Marcados como Deletados                    
	*/
	IF SubStr( cAliasPack , 1 , nPrefixSize ) == cPrefixPack .AND. Select( cAliasPack ) > 0.00 ;
	   .AND. aScan( aAliasNotPack , { |x| x == cAliasPack } ) == 0.00
		Chk_Pack( cAliasPack , -1 , 1 , .F. , .F. , lChkFile )
    EndIf

Next nAliasPack

Return( NIL )

/*

Ŀ
 Funo    GpLegend  Autor  Natie                  Data 21/09/2000
Ĵ
 Descrio Cria uma janela contendo a legenda da mBrowse              
Ĵ
 Uso       GpLegend                                                   
ٱ

*/
Function GpLegend(oBrowse,lMVC)
Local aLegenda  := {}
Local lGestPubl := if(ExistFunc("fUsaGFP"),fUsaGFP(),.f.)	//Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
Local lGPLeg	:= .F.
Local lGpCores	:= .F.
Local nX		:= 0

DEFAULT lMVC := .F.

lMVC := If(ValType(lMVC) == "L",lMVC,.F.)

If !lMVC
	aLegenda := GpeGetLegend()

	IF Type( "cCadastro" ) == "U"
		Private cCadastro := STR0085							//"Legenda"
	EndIf

	BrwLegenda(	OemToAnsi(cCadastro)						,;	//Titulo do Cadastro
				OemToAnsi( STR0085 )						,;	//"Legenda"
				aLegenda ;
			 )

Else //Cria legenda para telas com MVC

	// - Verifica execuo do P.E
	If ExistBlock("GP010BWLEG") .And. !(FunName() == "GPEA011")
   		IF ValType( uRet := ExecBlock('GP010BWLEG',.F.,.F.,aLegenda) ) == "A"
			aLegenda 	:= aClone(uRet)
			lGPLeg := .T.
		Endif
	Endif

	/*
	Ŀ
	 Ponto de Entrada para alterar cores do Browse do Cadastro    
	*/
	If FunName() == "GPEA011" .And. ExistBlock("GPBWCORES") 
		IF ValType( uRet := ExecBlock('GPBWCORES',.F.,.F.,aLegenda) ) == "A"
			aLegenda := aClone(uRet)
			lGpCores:= .T.
		EndIf
	EndIf

	If lGestPubl // Modulo Gestao de Folha Publica
		oBrowse:AddLegend( "RA_SITFOLH=='A'"									 , "YELLOW"	, OemToAnsi(STR0162) ) 	//"Afastado/Licenca"
		oBrowse:AddLegend( "RA_SITFOLH=='F'"									 , "BLUE"	, OemToAnsi(STR0161) ) 	//"Frias/Dias de Direito"
		oBrowse:AddLegend( "SRA->RA_CATFUNC $ '78' .AND. SRA->RA_SITFOLH==' '   ", "GRAY"	, OemToAnsi(STR0163) ) 	//"Aposentado"
		oBrowse:AddLegend( "SRA->RA_CATFUNC $ '9'  .AND. SRA->RA_SITFOLH==' '   ", "ORANGE"	, OemToAnsi(STR0164) ) 	//"Pensionista"
	ElseIf lGPLeg .and. Len(aLegenda) >= 5
		oBrowse:AddLegend( "RA_SITFOLH==' '"	, aLegenda[1,1]	, aLegenda[1,2] )	//"Situao Normal"
		oBrowse:AddLegend( "RA_RESCRAI$'30/31'"	, aLegenda[2,1]	, aLegenda[2,2] )	//"Transferido"
		oBrowse:AddLegend( "RA_SITFOLH=='D'"  	, aLegenda[3,1]	, aLegenda[3,2] )	//"Demitido"
		oBrowse:AddLegend( "RA_SITFOLH=='A'"   	, aLegenda[4,1]	, aLegenda[4,2] )	//"Afastado"
		oBrowse:AddLegend( "RA_SITFOLH=='F'"   	, aLegenda[5,1]	, aLegenda[5,2] )	//"Frias"
	ElseIf lGpCores
		For nX := 1 to Len(aLegenda)
			oBrowse:AddLegend( aLegenda[nX,1]	, aLegenda[nX,2]	, aLegenda[nX,3] )	
		Next nX
	Else
		oBrowse:AddLegend( "RA_SITFOLH=='A'"	, "YELLOW"	, OemToAnsi(STR0088) ) 	//"Afastado"
		oBrowse:AddLegend( "RA_SITFOLH=='F'"	, "BLUE"	, OemToAnsi(STR0089) ) 	//"Frias
	Endif

	If (!lGPLeg  .And. !lGpCores) .Or. lGestPubl
		oBrowse:AddLegend( "RA_SITFOLH==' '"	, "GREEN"	, OemToAnsi(STR0086) ) 	//"Situao Normal"
		oBrowse:AddLegend( "RA_RESCRAI$'30/31'"	, "PINK"	, OemToAnsi(STR0015) ) 	//"Transferido"
		oBrowse:AddLegend( "RA_SITFOLH=='D'"	, "RED"		, OemToAnsi(STR0087) ) 	//"Demitido"
	EndIf

EndIf

Return( .T. )
//---------------------------------------------------------------------
/*/{Protheus.doc} GpeGetLegend
Retornas as cores de Legenda para o Browse

@author Jackson Machado
@since 12/02/2020

@return aLegend, Array, Matriz contendo as informaes de legenda,
sendo posio 1 (um) a cor e posio 2 (dois) a descrio
/*/
//---------------------------------------------------------------------
Function GpeGetLegend()

	Local aLegend   := {}
	Local lGestPubl := IIf( ExistFunc( "fUsaGFP" ), fUsaGFP(), .F. )//Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

	aLegend := {;
					{ "ENABLE",        OemToAnsi( STR0086 )	}, ;//"Situao Normal"
					{ "BR_PINK",       OemToAnsi( STR0015 ) }, ;//"Transferido
					{ "BR_VERMELHO",   OemToAnsi( STR0087 )	};	//"Demitido"
				}

	If lGestPubl //Modulo Gestao de Folha Publica
		aAdd( aLegend, { "BR_AMARELO", OemToAnsi( STR0162 ) } )	//"Afastado/Licena"
		aAdd( aLegend, { "BR_AZUL",    OemToAnsi( STR0161 ) } )	//"Frias/Dias de Direito"
		aAdd( aLegend, { "BR_CINZA",   OemToAnsi( STR0163 ) } ) //"Aposentado"
		aAdd( aLegend, { "BR_LARANJA", OemToAnsi( STR0164 ) } )	//"Pensionista"
	Else
		aAdd( aLegend, { "BR_AMARELO", OemToAnsi( STR0088 ) } )	//"Afastado"
		aAdd( aLegend, { "BR_AZUL",    OemToAnsi( STR0089 ) } )	//"Frias"
	EndIf

	// - Verifica Execuo do P.E
	If ExistBlock( "GPBWLEG" )
		IF ValType( uRet := ExecBlock( "GPBWLEG", .F., .F., aLegend ) ) == "A"
			aLegend := aClone( uRet )
		Endif
	Endif

Return aLegend

/*


ͻ
Programa  MontaMasc Autor  Pedro Eloy           Data   12/05/04   
͹
Desc.      Tratar a quebra de niveis quando definida com mais de um   
           digito. Exemplo: 10-letra A, 11-letra B, etc. 	          
͹
Uso        AP                                                         
ͼ

*/
Function MontaMasc(cMascCus)
Local aNiveis := {}
Local nMapa   := 0
Local nLaco	  := 0
Local cByte	  := ""

For nLaco := 1 to Len(cMascCus)
	cByte := SubStr( cMascCus , nLaco , 1 )
	If Asc(cByte) >= 65
		nMapa += (Asc(cByte) - 55)
	Else
		nMapa += Val( cByte )
	EndIf
	If Asc(cByte) > 48
		Aadd( aNiveis, nMapa )
	EndIf
Next

Return(aNiveis)

/*/


Ŀ
Funo	 fTabRH()   Autor  Equipe RH              Data  10/04/00 
Ĵ
Descrio Monta lista de opcoes para a f_opoes			 			  
Ĵ
Sintaxe	  fTabRH() 												  
Ĵ
 Uso		  Generico 												  
ٱ

/*/
Function fTabRH( cCampo, cTabela, l1Elem )
Local cTitulo  := ""
Local MvParDef := ""
Local lRet     := .T.
Local aArea    := GetArea()
Local aOpcoes  := {}
Local MvParGet

Static nVezCpo := 0

l1Elem := If (l1Elem = Nil , .F. , .T.)

If Alltrim(ReadVar() )= "M->" + cCampo .AND. (nVezCpo = Nil .OR. nVezCpo < 1)
    nVezCpo ++
	cAlias := Alias() 					     // Salva Alias Anterior
	MvParGet := &(Alltrim(ReadVar()))		 // Carrega Nome da Variavel do Get
	mvRet  := Alltrim(ReadVar())			 // Iguala Nome da Variavel ao Nome variavel de Retorno
	dbSelectArea("REK")
	If dbSeek(cFilial+cTabela)
		cTitulo := Alltrim(Left(REK->REK_DESCR, 20))
	EndIf
	dbSelectArea("RE5")
	If dbSeek(cFilial+cTabela)
		CursorWait()
			While !Eof() .AND. RE5->RE5_TABELA == cTabela
				Aadd(aOpcoes, Left(RE5->RE5_CODIGO,1) + " - " + RE5->RE5_DESCR)
				MvParDef += Left(RE5->RE5_CODIGO,1)
				dbSkip()
			Enddo
		CursorArrow()
	EndIf
	IF f_Opcoes(@MvParGet,cTitulo,aOpcoes,MvParDef,12,49,l1Elem)  // Chama funcao f_Opcoes
		&MvRet := MvParGet									       // Devolve Resultado
	EndIf
	dbSelectArea(cAlias) 								   		   // Retorna Alias
	lRet := .F.
ElseIf nVezCpo >= 1
	nVezCpo := 0
	lRet := .T.
EndIf

RestArea( aArea )

Return(lRet)

/*


ͻ
Programa  fAltSal   Autor  Francisco Jr         Data   07/30/09   
͹
Desc.     Verifica se funcionario teve alteracao salarial nos ultimos 
          12 Meses                                                    
͹
Uso        AP                                                         
ͼ


*/
Function fAltSal(cMat, dDataRef, lAltSal, nMeses)

Local aArea

DEFAULT nMeses := 12

lAltSal := .F.

aArea := Getarea()

SR7->(DbSetOrder( RetOrder( "SR7", "R7_FILIAL+R7_MAT" ) ) )
SR7->(dBSeek(xFilial("SR7") + cMat))


Do While SR7->R7_FILIAL+SR7->R7_MAT = xFilial("SR7")+cMat .AND. !SR7->(Eof())

	If Val(Substr(Dtos(dDataRef),1,6)) - Val(Substr(Dtos(SR7->R7_DATA),1,6)) <= Round(nMeses * 8.3333, 0)	//100
		lAltSal := .T.
	EndIf

	SR7->(Dbskip())

Enddo

Restarea(aArea)

Return(@lAltSal)



/*
Ŀ
Funo     fLockRCH		AutorIgor Franzoi		   Data 13/01/2010
Ĵ
Descrio Lock (Semaforo) do Registro no RCH 							
Ĵ
Sintaxe   < Vide Parametros Formais >									
Ĵ
 Uso      GPEM022/GPEA400												
Ĵ
 Retorno  lRet														
Ĵ
Parametros< Vide Parametros Formais >									
*/
Function fLockRCH( cFilRCH, cProcesso, cPeriodo, cRoteiro, cNumPag, lUnLocked )

Local lRet 		:= .T.

Local cKeyBlock	:= ""

DEFAULT cProcesso	:= Space( GetSx3Cache("RCH_PROCES"	, "X3_TAMANHO") )
DEFAULT cPeriodo	:= Space( GetSx3Cache("RCH_PER"		, "X3_TAMANHO") )
DEFAULT cRoteiro	:= Space( GetSx3Cache("RCH_ROTEIR"	, "X3_TAMANHO") )
DEFAULT cNumPag		:= Space( GetSx3Cache("RCH_NUMPAG"	, "X3_TAMANHO") )
DEFAULT lUnLocked	:= .F.

cKeyBlock := "RCH" + cFilRCH + cProcesso + cPeriodo + cRoteiro + cNumPag

If !lUnLocked
	If !LockByName(cKeyBlock)
		MsgAlert(OemToAnsi(STR0115),OemToAnsi(STR0090))	//Registro sendo utilizado por outro usurio!" / "Alerta"
		lRet := .F.
	EndIf
Else
	UnLockByName(cKeyBlock)
EndIf

Return lRet

/*/


Ŀ
Funao     WhenSetEpoch Autor  Leandro Drumond     Data  31.08.12 
Ĵ
Descrio  Altera o SET EPOCH no WHEN do campo do tipo DATA.          
Ĵ
 Uso                                                                  
ٱ
/*/
Function WhenSetEpoch(lOld)

DEFAULT lOld 	:= .F.

If lOld
	SET(_SET_EPOCH,nEpochOld)
Else
	SET(_SET_EPOCH,nEpochNew)
EndIf

Return .T.

/*/


Ŀ
Funao    ValidSetEpoch Autor  Leandro Drumond     Data  31.08.12 
Ĵ
Descrio  Altera o SET EPOCH no VALID do campo do tipo DATA.         
Ĵ
 Uso                                                                  
ٱ
/*/
Function ValidSetEpoch()

SET(_SET_EPOCH,nEpochNew)

Return .T.

/*/


Ŀ
Funao    RetPadEpoch   Autor  Leandro Drumond     Data  31.08.12 
Ĵ
Descrio  Retorna o SET EPOCH padrao do frame. Utilizado nas rotinas 
           que alteram o SET EPOCH pelo WHEN e VALID pois no caso de  
           dar ESC no campo, o VALID nao e executado.                 
Ĵ
 Uso                                                                  
ٱ
/*/
Function RetPadEpoch()

//Funcao utilizada p
If Type( 'nEpochNew' ) == "N"
	SET(_SET_EPOCH,nEpochNew)
EndIf

Return Nil

/*/


Ŀ
Funao     fGravaS033 Autor  Allyson M             Data  22.12.11 
Ĵ
Descrio  Busca opcao do recolhimento na tab. 14-Encargos da Empresa 
Ĵ
 Uso       Generico                                                   
ٱ
*/
Function fGravaS033( cFil, cAnoMes, cCodAtiv, cTpFat, nVlBase, nAliquota, nContr, nVlRec, nVlExcl, nVlExpo, aTabS033, nVlImp, cConta )
Local aArea			:= GetArea()
Local aAreaRCB		:= {}
Local aAreaRCC		:= {}
Local cAliasRCC		:= "RCC"
Local cAliquota		:= ""
Local cFilRCB		:= xFilial("RCB")
Local cFilRCC		:= xFilial("RCC")
Local cContr		:= ""
Local cTab			:= "S033"
Local cVlBase		:= ""
Local cVlExc		:= ""
Local cVlExp		:= ""
Local cVlImp		:= ""
Local cVlRec		:= ""
Local nRegs			:= 0
Local nRet			:= 0
Local nTamAtiv		:= 8
Local nTamConta		:= 70
Local lAchou		:= .F.

Default aTabS033	:= {}
Default cFil		:= FWGETCODFILIAL
Default cAnoMes		:= AnoMes( dDataBase )
Default cCodAtiv	:= Space( nTamAtiv )
Default cTpFat		:= "1"
Default cConta		:= ""

Default nAliquota	:= 0.00
Default nContr		:= 0.00
Default nVlBase		:= 0.00
Default nVlExcl		:= 0.00
Default nVlExpo		:= 0.00
Default nVlImp		:= 0.00
Default nVlRec		:= 0.00

cAliquota	:= PADL( cValToChar( nAliquota ), 6, " " )
cContr		:= PADL( cValToChar( nContr ), 17, " " )
cVlBase  	:= PADL( cValToChar( nVlBase ), 17, " " )
cVlExc		:= PADL( cValToChar( nVlExcl ), 17, " " )
cVlExp		:= PADL( cValToChar( nVlExpo ), 17, " " )
cVlImp		:= PADL( cValToChar( Max(nVlImp,0) ), 17, " " )
cVlRec		:= PADL( cValToChar( nVlRec ), 17, " " )
cConta		:= PADR( cConta, 70, " ")

dbSelectArea("RCB")
dbSetOrder(1)

aAreaRCB := RCB->( GetArea() )

If RCB->( dbSeek( cFilRCB+cTab ) )

	cAliasRCC := GetNextAlias()
	BeginSql alias cAliasRCC
		SELECT RCC.RCC_CODIGO, RCC.RCC_FIL, RCC.RCC_CHAVE, RCC.RCC_CONTEU, R_E_C_N_O_ RECNO
		FROM %table:RCC% RCC
		WHERE RCC.RCC_CODIGO = %exp:cTab% AND RCC.RCC_FIL = %exp:cFil% AND RCC.RCC_CHAVE = %exp:cAnoMes% AND RCC.%notDel%
		ORDER BY RCC.RCC_CODIGO, RCC.RCC_FIL, RCC.RCC_CHAVE, RCC.RCC_CONTEU
	EndSql

	If (cAliasRCC)->RECNO > 0
		lAchou := .T.
	EndIf


	If lAchou
		(cAliasRCC)->( dbEval( { || IF ((SubStr( RCC_CONTEU, 9, 1 ) == cTpFat) .And. (SubStr( RCC_CONTEU, 1, nTamAtiv ) == cCodAtiv) .AND. (SubStr( RCC_CONTEU, 118, nTamConta ) == cConta), nRegs++, Nil) }, , { || (cAliasRCC)->RCC_CODIGO+(cAliasRCC)->RCC_FIL+(cAliasRCC)->RCC_CHAVE == cTab + cFil + cAnoMes } ) )
        //Se nao achou nenhum registro para o NCM, verifica qual a ultima sequencia cadastrada
	 	If nRegs == 0
			(cAliasRCC)->( dbGoTop() )
			(cAliasRCC)->( dbEval( {|| IF (RCC_CHAVE == cAnoMes, nRegs++, nRegs)}, , {|| (cAliasRCC)->RCC_CODIGO + (cAliasRCC)->RCC_FIL + (cAliasRCC)->RCC_CHAVE == cTab + cFil + cAnoMes} ) )
	 	//Se achou um registro marca o flag para atualizacao
		Else
			//Efetua busca pelo Ano/Mes e o codigo do NCM
			If ( nPos := aScan( aTabS033, {|aTabS033| aTabS033[2] + aTabS033[3] + aTabS033[5] + aTabS033[14] + aTabS033[6] == cFil + cAnoMes + cCodAtiv + cConta + cTpFat} ) ) >= 0
				nRet := 1
			EndIf
		EndIf
	EndIf

	//Inclui um registro
	If nRet == 0
		If RCC->( RecLock('RCC', .T.) )
			RCC->RCC_FILIAL := xFilial("RCC")
			RCC->RCC_CODIGO := cTab
			RCC->RCC_FIL    := cFil
			RCC->RCC_CHAVE  := cAnoMes
			RCC->RCC_SEQUEN := PADL( cValToChar(++nRegs), 3, "0" )
			RCC->RCC_CONTEU := ( cCodAtiv + cTpFat + cVlBase + cAliquota + cContr + cVlRec + cVlExc + cVlExp + cVlImp + cConta )
			RCC->( MsUnLock() )
			nRet := 2
		EndIf
	//Atualiza o registro
	ElseIf nRet == 1
       	If RCC->( dbSeek( xFilial("RCC") + cTab + cFil + cAnoMes + aTabS033[nPos, 4] ) )
			If RCC->( RecLock('RCC', .F.) )
				RCC->RCC_FILIAL := xFilial("RCC")
				RCC->RCC_CODIGO := cTab
				RCC->RCC_FIL    := cFil
				RCC->RCC_CHAVE  := cAnoMes
				RCC->RCC_SEQUEN := aTabS033[nPos, 4]
				RCC->RCC_CONTEU := ( cCodAtiv + cTpFat + cVlBase + cAliquota + cContr + cVlRec + cVlExc + cVlExp + cVlImp + cConta )
				RCC->( MsUnLock() )
				nRet := 3
			EndIf
		EndIf
	EndIf

	(cAliasRCC)->( dbCloseArea() )

EndIf

RestArea( aArea )
RestArea( aAreaRCB )

//nRet == 0 -> Nao existe tabela S033 na RCB
//nRet == 1 -> Registro ja existente na RCC porem nao atualizado
//nRet == 2 -> Registro gravado com sucesso na RCC
//nRet == 3 -> Registro atualizado com sucesso na RCC
Return( nRet )

/*


ͻ
Programa  ConsResExtAutor  Jonatas A. T. Alves  Data   25/11/10   
͹
Desc.      Funcao para Consulta Padrao das tabelas referentes a       
           residentes no exterior.                                    
͹
Uso        Generico                                                   
ͼ


*/
Function ConsResExt()

Local cVar 		:= ReadVar()
Local cCons 	:= ""
Local cCpoRet	:= "CODIGO"
Local cConteud 	:= ""
Local nCPn 		:= 0 //variavel utilizada quando  aberta mais de uma getdados ao mesmo tempo
Local xRet
Local aArea		:= GetArea()

If cVar == "M->RGE_CODPAI" .Or. cVar == "RGE->RGE_CODPAI" .or. AllTrim(cVar) == "M->RL_PAIS" .or. AllTrim(cVar) == "SRL->RL_PAIS"
	cCons	:= "S024"		// Codigos dos Paises
ElseIf cVar == "M->RGE_BENREN" .Or. cVar == "RGE->RGE_BENREN" .or. AllTrim(cVar) == "M->RL_BREEX" .or. AllTrim(cVar) == "SRL->RL_BREEX"
	cCons	:= "S023"		// Beneficiarios dos Rendimentos
ElseIf cVar == "M->RGE_TIPREN" .Or. cVar == "RGE->RGE_TIPREN" .or. AllTrim(cVar) == "M->RL_TPREX" .or. AllTrim(cVar) == "SRL->RL_TPREX"
	cCons	:= "S021"		// Rendimentos
ElseIf cVar == "M->RGE_FRMTRB" .Or. cVar == "RGE->RGE_FRMTRB" .or. AllTrim(cVar) == "M->RL_TRBEX" .or. AllTrim(cVar) == "SRL->RL_TRBEX"
	cCons	:= "S022"		// Formas de Tributacao
EndIf

// n - varivel de posicionamento do objeto GetDados
// o trecho abaixo controla para que no haja conflito entre 2 GetDados, caso seja
// disparada uma consulta F3 entre 2 tabelas. Ex.: S008 faz consulta em S016
If Type( 'n' ) == "N"
	nCpn := n
EndIf

xRet := Gp310SXB( cCons, cCpoRet )

If ValType( xRet ) <> "L" .Or. ( ValType( xRet ) == "L" .And. !xRet )
	VAR_IXB := &__READVAR
Endif

If nCpn > 0
	n := nCpn
EndIf

RestArea( aArea )
Return( .T. )

/*/


Ŀ
Funo     TabFaltas Autor  Mauro                  Data 20/05/95  
Ĵ
Descrio TABELA DE FALTAS PARA FERIAS                                
Ĵ
Sintaxe    TABFALTAS(nFaltas)                                         
Ĵ
Parametros                                                            
Ĵ
 Uso       Generico                                                   
ٱ

*/
Function TabFaltas(nFaltas, nDFerias, aPerAq)

Private nGpFaltas := nFaltas

Default aPerAq	  := {}

Static lGpTabFal

If cPaisLoc == "BRA" .And. ( FunName() == "GPER390" .or. ( SRA->RA_HOPARC == "1" .And. SRA->RA_HRSEMAN <= 25 ) )
	//Performance - Carrega o mnemonico apenas se ele for utilizado
	SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_REGPARCI")
EndIf

DEFAULT nDFerias  := 30
DEFAULT lGpTabFal := ExistBlock("GPTABFAL")

If cPaisLoc == "BRA" .and. FunName() == "GPER390" .and. P_REGPARCI
	SRA->( dbSeek( SRF->RF_FILIAL + SRF->RF_MAT ) )
Endif

If cPaisLoc == "BRA" .And. SRA->RA_HOPARC == "1" .And. SRA->RA_HRSEMAN <= 25 .And. P_REGPARCI
	//Art. 130A da CLT, Paragrafo Unico: Se o funcionrio trabalha por regime de tempo parcial
	//e suas faltas forem superiores a 7 os dias de frias caem pela metade.
	lTempoParc := .T.
	lMetadeFal := nFaltas > 7
Else
	If nFaltas >= 6 .And. nFaltas < 15
		nfaltas  := 6
	Elseif nFaltas >= 15 .And. nFaltas < 24
		nFaltas  := 12
	Elseif nFaltas >= 24 .And. nFaltas <= 32
		nFaltas  := 18
	Elseif nFaltas > 32
		nFaltas  := 30
	Else
		nFaltas := 0
	EndIf
	lMetadefal := .F.
	lTempoParc := .F.
EndiF

//Ŀ
// Ponto de Entrada para Alterar numero de Faltas p/ Ferias     |
//
If lGpTabFal
	ExecBlock("GPTABFAL", .F., .F., {aPerAq})
	nFaltas := nGpFaltas  //Passa para nFaltas o conteudo alterado no Ponto de Entrada
EndIf

Return

/*/


Ŀ
Funo	 fchkafas	 Autor  Mauro Sergio			 Data  26.04.96 
Ĵ
Descrio  Verifica se Funcionario esta Afastado					  
Ĵ
Parametros cFilfun = Filial do Funcionario							  
			  cMatFun = Matricula Funcionario							  
			  dDtPesq = Data para Pesquisa								  
			  dDtAafas= Variavel Data Retorno Inicio Afastamento 		  
			  dDtRet  = Variavel dATA Retorno Fim Afastamento 			  
			  cTipAfas= Variavel Retorno Tipo Afastamento				  
			  dDtPqIni= Dt.Pesq.inicio por periodo,qdo Dif.Dt.Referencia 
			  dDtPqFim= Dt.Pesq.Fim por periodo,qdo Dif. Dt.Referencia   
			  cVrbExcep= Verbas que serao ignoradas na busca de ausencias
Ĵ
Sintaxe	  fChkAfas(cFilFun,cMatFun,dDtPesq,@dDtAfas,@dDtRet,		  
			 			@cTipoAfas,dDtPqIni,dDtPqFim)				 	  
Ĵ
 Uso		  Genrico 												  
ٱ

/*/
Function fChkAfas(cFilFun,cMatFun,dDtPesq,dDtafas,dDtRet,cTipAfas,dDtPqIni,dDtPqFim,cVrbExcep,lDSindAf,cTpSEF)

Local lRet		 	:= .F.
Local aAfast	    := {}
Local aPerOrd		:= {}
Local nElemAf		:= 0

DEFAULT cVrbExcep	:= ""

//--Verifica se foram passados os parametros se nao cria vazio
cFilFun	:= If(cFilFun = Nil , SRA->RA_FILIAL , cFilfun)
cMatFun	:= If(cMatFun = Nil , SRA->RA_MAT , cMatFun)

If dDtPesq == Nil .or. Empty(dDtPesq)
	aPerOrd := GpGetPerOrd()
	If Empty(aPerOrd)
		Return( .F. )
	EndIf
	dDtPesq := aPerOrd[1,7]
EndIf

If dDtPqIni == Nil .And. dDtPqFim == Nil
	dDtPqIni := Ctod("01/"+StrZero(Month(dDtPesq),2)+"/"+StrZero(Year(dDtPesq),4),"DDMMYY")
	dDtPqFim := Ctod(StrZero(f_UltDia(dDtPesq),2)+"/"+StrZero(Month(dDtPesq),2)+"/"+StrZero(Year(dDtPesq),4),"DDMMYY")
EndIf

//--Tratamento nas variaveis de retorno
dDtAfas		:= If(dDtAfas = Nil , Ctod("  /  /  ") , dDtAfas)
dDtRet		:= If(dDtRet  = Nil , Ctod("  /  /  ") , dDtRet)
cTipAfas 	:= Space(1)
lDSindAf	:= .F.

//--Funcao que retorna os afastamentos conforme a tabela RCM - Tipo de Afastamento

fBuscaAfast(dDtPqIni,dDtPqFim,@aAfast, , ,cVrbExcep)

//--Retorna o ultimo elemento sobre o periodo para as variaveis de retorno
nElemAf := Len(aAfast)
If nElemAf > 0
	dDtAfas  := aAfast[nElemAf,1]
	dDtRet	 := aAfast[nElemAf,2]
	cTipAfas := AAfast[nElemAf,4]
	cTpSEF   := AAfast[nElemAf,19]
	lDSindAf := If(cPaisLoc == "BRA" .And. aAfast[nElemAf,30] == "2",.T.,.F.)
	lRet 	 := .T.
EndIf

Return lRet

/*/


Ŀ
Funo	 fSitFunc	 Autor  Mauro Sergio			 Data  11.11.05 
Ĵ
Descrio  Retorna a Situao do Funcionario em um determinado Periodo
Ĵ
Parametros cFilfun = Filial do Funcionario							  
			  cMatFun = Matricula Funcionario							  
			  dDtIni  = Periodo Inicio da Pesquisa				 		  
			  dDtFim  = Periodo Fim da Pesquisa						  
			  cTipAfas= Variavel Retorno Tipo Afastamento				  
			  aAfast  = Variavel Retorno Array com os Afastamentos		  
Ĵ
Sintaxe	  fSitFunc(cFilFun,cMatFun,dDtPesq,lAtu,dDtAfas,dDtRet) 	  
Ĵ
 Uso		  Genrico 												  
ٱ

/*/
Function fSitFunc(cFilFun,cMatFun,dDtIni,dDtFim,cSitFunc)

Local aAreaSra	:= SRA->( GetArea() )

//--Verifica se foram passados os parametros se nao cria vazio
cFilFun	:= If(cFilFun = Nil , SRA->RA_FILIAL , cFilfun)
cMatFun	:= If(cMatFun = Nil , SRA->RA_MAT , cMatFun)
dDtIni	:= If(dDtIni = Nil , Ctod("  /  /  ") , dDtIni)
dDtFim	:= If(dDtFim  = Nil , Ctod("  /  /  ") , dDtFim)
cSitFunc:= If(cSitFunc= Nil , " " , cSitFunc)
aAfast	:= {}

//--Verifica se esta pocisionado no funcionario
If SRA->RA_FILIAL+SRA->RA_MAT <> cFilFun+cMatFun
	dbSelectArea("SRA")
	If ! dbSeek(cFilFun+cMatFun)
		cSitFunc := Space(1)
		RestArea( aAreaSRA )
		Return(cSitFunc)
	EndIf
EndIf

//--Verifica se funcioanrio demitido no periodo final recebido
If ( !Empty(SRA->RA_DEMISSA) .And. MesAno(SRA->RA_DEMISSA)<= MesAno(dDtFim) )
	cSitFunc := "D"
Else
	//--Funo que retorna a situao do empregado no periodo solicitado
	cSitFunc := fBuscaAfast(dDtIni,dDtFim)
EndIf

RestArea( aAreaSRA )

Return(cSitFunc)

/*/


Ŀ
Funo	  CompMes	 Autor  R.H. -	             Data  11.03.97 
Ĵ
Descrio  Carregar Parametro Composicao do mes						  
Ĵ
Sintaxe	  CompMes(Normal,Descanso,cAnoMes) 						  
Ĵ
Parametros Normal	- Variavel para retorno das horas normais 		  
			  Descanso - Variavel para retorno das horas de descanso	  
			  cAnoMes	- Ano e Mes Para Pesquisao no arquivo de Param.   
Ĵ
 Uso		  Generico 												  
ٱ

/*/
Function CompMes(Normal, Descanso, cAnoMes)
	If FPHIST82(SRA->RA_FILIAL, "19", RHTamFilial(SRA->RA_FILIAL) + cAnoMes)
		Normal	 := nSvNormal := VAL(SUBSTR(SRX->RX_TXT, 1, 6))
		Descanso := nSvDescan := VAL(SUBSTR(SRX->RX_TXT, 7, 6))
	ElseIf FPHIST82(SRA->RA_FILIAL, "19", RHTamFilial("") + cAnoMes)
		Normal	 := nSvNormal := VAL(SUBSTR(SRX->RX_TXT, 1, 6))
		Descanso := nSvDescan := VAL(SUBSTR(SRX->RX_TXT, 7, 6))
	ElseIf FPHIST82(SRA->RA_FILIAL, "19", RHTamFilial("") + Space(6))
		Normal	 := nSvNormal := VAL(SUBSTR(SRX->RX_TXT, 1, 6))
		Descanso := nSvDescan := VAL(SUBSTR(SRX->RX_TXT, 7, 6))
	Else
		Normal := nSvNormal := Descanso := nSvDescan := 0.00
	EndIf
Return ( .T. )

/*
Ŀ
Funo    UniqueKey	       AutorMarinaldo de JesusData02/04/2002
Ĵ
Descrio Verificar se a Chave Passada eh Unica de Acordo com o  Campo
          ou Campos de uFields										
Ĵ
Sintaxe   UniqueKey( uFields , [ cAlias ] , [ lResetKeys ] )			
Ĵ
ParametrosuFiels		-> String contendo o Campo ou Array  Unidimensio
                     	   nal com as Strings dos Campos que que   serao
                         considerados para Pesquisa da Chave Unica.	
                         Ex.: "M0_CODIGO" ou {"M0_CODIGO","M0_CODFIL"}
                                             							
          cAlias 		-> Alias do Arquivo Para Pesquisa			    
                                             							
          lResetKeys	-> Reinicializa as Chaves						
                                             							
          nMaxRec   	-> Numero Maximo de Elementos					
                                             							
Obs.:     Se Nenhum parametro for passado a Variavel Static sera reini
          cializada ( __aUniqueKey__ := NIL )							
Ĵ
Retorno   lUnique => .T. Se Chave Unica , C.C. .F.					
Ĵ
ObservaoServe como Filtro quando Multiplas Chaves             		
                                     									
          Ex.: M0_CODIGO + M0_CODFIL	 Recno							
                                     									
               01          01 	     01	  							
               01          02			 02								
               01          03			 03								
               02          01			 04								
               02          02			 05								
               02          03			 06								
               02          04			 07								
               03          01			 08								
               03          02			 09								
               03          03			 10								
               03          04			 11								
               04          01			 12								
               04          02			 13								
               04          03			 14								
               04          04			 15								
                                     									
          Utilizando UniqueKey("M0_CODIGO","SM0") Teremos como Filtro:
                                     									
          Ex.: M0_CODIGO + M0_CODFIL	 Recno							
                                     									
               01          01 	     01	  							
               02          01			 04								
               03          01			 08								
               04          01			 12								
Ĵ
 Uso      Generico                                                    
*/
Function UniqueKey( uFields , cAlias , lResetKeys , nMaxRec )

Local lUnique		:= .T.

Local cField
Local cFields
Local cTypeField
Local cFieldsType
Local cFieldKey
Local nPosUnique
Local nPosAlias
Local nField
Local nFields
Local nRecno

Static __aUniqueKey__

If !( Pcount() == 0 )

	DEFAULT uFields			:= {}
	DEFAULT cAlias			:= Alias()
	DEFAULT lResetKeys		:= .F.

	cAlias := Upper( AllTrim( cAlias ) )

	DEFAULT __aUniqueKey__		:= {}

	If ( ( nPosAlias := aScan( __aUniqueKey__ , { |x| x[1] == cAlias } ) ) == 0 )
		DEFAULT nMaxRec := ( cAlias )->( RecCount() )
		aAdd( __aUniqueKey__ , { cAlias , 0 , {} , nMaxRec } )
		nPosAlias := Len( __aUniqueKey__ )
	Else
		DEFAULT nMaxRec := __aUniqueKey__[ nPosAlias , 4 ]
	EndIf

	If !( lResetKeys )

		cFieldsType := ValType( uFields )

		If !Empty( uFields ) .and. ( cFieldsType $ "AC" )

			Begin Sequence

				If ( cFieldsType == "C" )
					cField := Upper( AllTrim( uFields ) )
					If ( ( cAlias )->( FieldPos( cField ) ) == 0 )
	                	Break
	                EndIf
	                If ( ( cTypeField := ( cAlias )->( Type( cField ) ) ) == "N" )
	                	cField := ( "StrZero( " + cField + " , 21 , 08 )" )
	                ElseIf ( cTypeField == "D" )
	                	cField := ( "Dtos( " + cField + ")" )
	                ElseIf !( cTypeField $ "CM" )
	                	Break
	                EndIf
				ElseIf ( cFieldsType == "A" )
					If ( nFields := Len( uFields ) ) == 0
						Break
					Else
						cFields := ""
						For nField := 1 To nFields
							cField := Upper( AllTrim( uFields[ nField ] ) )
							If ( ( cAlias )->( FieldPos( cField ) ) == 0 )
	                			Break
	                		EndIf
   			                If ( ( cTypeField := ( cAlias )->( Type( cField ) ) ) == "N" )
	                			cField := ( "StrZero( " + cField + " , 21 , 08 )" )
	                		ElseIf ( cTypeField == "D" )
	                			cField := ( "Dtos( " + cField + ")" )
	                		ElseIf !( cTypeField $ "CM" )
	                			Break
	                		EndIf
	                		cFields += cField
							If ( nField < nFields )
								cFields += "+"
							EndIf
						Next nField
						cFields := AllTrim( cFields )
						If SubStr( cFields , -1 ) == "+"
							cFields := SubStr( cFields , 1  , Len( cFields ) - 1 )
						EndIf
						cField := cFields
					EndIf
				EndIf

				cFieldKey	:= ( cAlias )->( &( cField ) )
				nRecno		:= ( cAlias )->( Recno() )

				If ( ( nMaxRec > 0 ) .and. ( __aUniqueKey__[ nPosAlias , 02 ] == nMaxRec ) )
					UniqueClearKeys( cAlias , @__aUniqueKey__ , lResetKeys , nMaxRec )
				EndIf

				If ( Empty( __aUniqueKey__[ nPosAlias , 03 ] ) .or. ( lUnique := ( nPosUnique := aScan( __aUniqueKey__[ nPosAlias , 03 ] , { |x| x[1] == cFieldKey } ) ) == 0 ) )
					++__aUniqueKey__[ nPosAlias , 02 ]
					If ( ( nPosUnique := ( aScan( __aUniqueKey__[ nPosAlias , 03 ] , { |x| Empty( x[2] ) } ) ) ) == 0 )
						aAdd( __aUniqueKey__[ nPosAlias , 03 ] , { cFieldKey , nRecno } )
					Else
						__aUniqueKey__[ nPosAlias , 03 , nPosUnique , 01 ] := cFieldKey
						__aUniqueKey__[ nPosAlias , 03 , nPosUnique , 02 ] := nRecno
					EndIf
				Else
					lUnique := ( __aUniqueKey__[ nPosAlias , 03 , nPosUnique , 02 ] == nRecno )
				EndIf

			End Sequence

		EndIf

	Else

		UniqueClearKeys( cAlias , @__aUniqueKey__ , lResetKeys , nMaxRec )

	EndIf

Else

	__aUniqueKey__ 		:= NIL

EndIf

Return( lUnique )

/*
Ŀ
Funo    UniqueClearKeys	   AutorMarinaldo de JesusData02/04/2002
Ĵ
Descrio Limpar as Chaves criadas pela UniqueKey						
Ĵ
Sintaxe   <Vide Parametros Formais>									
Ĵ
Parametros<Vide Parametros Formais>									
Ĵ
Retorno   NIL                                      					
Ĵ
Observao															
Ĵ
 Uso      UniqueKey                                                   
*/
Static Function UniqueClearKeys( cAlias , __aUniqueKey__ , lResetKeys , nMaxRec )

Local nElem
Local nPosAlias

DEFAULT cAlias 			:= ""
DEFAULT __aUniqueKey__	:= {}
DEFAULT lResetKeys		:= .F.
DEFAULT nMaxRec			:= 0

If ( ( nPosAlias := aScan( __aUniqueKey__ , { |x| x[1] == cAlias } ) ) > 0 )
	If !Empty( __aUniqueKey__[ nPosAlias , 03 ] )
		nElem := 0
		aEval( @__aUniqueKey__[ nPosAlias , 03 ] , { |x| If( ( lResetKeys ) .or. ( ( ++nElem ) < nMaxRec ) , (  x[1] := "" , x[2] := 0 ) , NIL ) } )
		If ( ( __aUniqueKey__[ nPosAlias , 02 ] := If( lResetKeys , 0 , Max( ( nMaxRec - ( --nElem ) ) , 0 ) ) ) > 0 )
			__aUniqueKey__[ nPosAlias , 03 , __aUniqueKey__[ nPosAlias , 02 ] ] := aClone( __aUniqueKey__[ nPosAlias , 03 , nMaxRec ] )
			__aUniqueKey__[ nPosAlias , 03 , nMaxRec ] := { "" , 0 }
		EndIf
	EndIf
EndIf

Return( NIL )

/*


Ŀ
Funcao     fP15Terc  Autor  Emerson Rosa de Souza  Data  27.12.02 
Ĵ
Descrio  Busca o percentual da deducao de terceiros no parametro 15 
Ĵ
Sintaxe    fP15Terc(cCusto,aGPSPer,cVerba)							  
Ĵ
Parametros                                                            
Ĵ

*/
Function fP15Terc(cCusto,aGPSPer,cVerba)
Local nPercDed := 0
Local cVbTerc  := aCodFol[184,1] + "/" + aCodFol[185,1] + "/" + aCodFol[186,1] + "/" +;
			      aCodFol[187,1] + "/" + aCodFol[188,1] + "/" + aCodFol[189,1] + "/" +;
			      aCodFol[190,1] + "/" + aCodFol[191,1] + "/" + aCodFol[192,1] + "/" +;
				  aCodFol[193,1] + "/" + aCodFol[200,1] + "/" + aCodFol[201,1] + "/" +;
				  aCodFol[204,1]

//Ŀ
// Soma os percentuais de terceiros definidos no parametro 15			   
//
If Len(aGPSPer) > 0
	If !Empty(cVerba)
		If cVerba == "*"    // Somar os percentuais de todos os convenios
			AEval( aGPSPer, { |X| nPercDed += If(AllTrim(X[1]) == AllTrim(cCusto) .And. X[2] $ cVbTerc, X[4]/100, 0) })
		Else 				// Igualar o percentual da verba passada no parametro
			AEval( aGPSPer, { |X| nPercDed += If(AllTrim(X[1]) == AllTrim(cCusto) .And. X[2] == cVerba .And. X[2] $ cVbTerc, X[4]/100, 0) })
		EndIf
	EndIf
EndIf

Return nPercDed

/*


ͻ
Funcao              Autor  Andreia dos Santos   Data   15/02/07   
͹
Desc.      Verifica qual a situao do funcionario. Quando o campo    
           RA_SITFOLH estiver preenchido com "D", verifica se a demis-
           sao, foi na verdade uma transferencia.                     
           Verifica se a situacao do funcionario esta dentro da sele- 
           cao de situacoes feita pelo usuario.                       
͹
Parametros lElem1 => Indica se deve posicionar o SRA no funcionario   
                    que se deseja verificar a situacao.               
           cElem2 => chave de pesquisa para posicionar o SRA no funcio
                     nario desejado( filial+matricula ).              
           cElem3 => Contem as situacoes selecionadas pelo usuario,   
                     que serao utilizadas como filtro.	              
͹
Uso        AP                                                         
ͼ


*/
Function ChkSituacao(lPosiciona,cChave,cSituacao)
Local lRet 		:= .T.
Local cTipAfas  := ""

If lPosiciona
	SRA->( dbSetOrder(1) )
	SRA->( dbSeek( cChave ))
EndIf

cTipAfas := SRA->RA_SITFOLH
//Tratamento para funcionrios transferidos
If SRA->RA_SITFOLH == "D" .and. SRA->RA_RESCRAI $ "30#31"
	cTipAfas := "T"
EndIf

lRet := (cTipAfas $ cSituacao)

Return( lRet )


/*


ͻ
Programa  GPEXFUN1  Autor  Pedro Eloy           Data   06/05/07   
͹
Desc.      Nome da funcao(ChkSitFolh) pesquisada pela LIB, para tratar
           o status do funcionario quando logada no sistema.          
͹
Uso        Validacao do usuario  - retorno logico (.t. / .f.)         
ͼ


*/

//Tabela de Afastamento
//1 - R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPO
//2 - R8_FILIAL+R8_MAT+R8_SEQ+DTOS(R8_DATA)+R8_TIPO
//--------------------------------------------------
//        SITUACAO NORMAL
//A       AFASTADO TEMP.
//D       DEMITIDO
//F       FERIAS
//T       TRANSFERIDO
//-------------------------
Function ChkSitFolh(cFilMat,cAliasSX2)

Local aAreaCor
Local lRetorno		:= .T.
Local dDataFinal 	:= MsDate()
Local cTipoFolha	:= ""
Local cSitFolha     := FWSFPOLICE("PROTHEUS","USR_VINCFU")
Local aSitFolha     := {}
Local nX
For nX := 1 to Len (cSitFolha)
	aAdd(aSitFolha,subStr(cSitFolha,nX,1))
Next nX

If Empty( aSitFolha )
	Return lRetorno
EndIf

aAreaCor		:= GetArea()

If cAliasSX2 <> Nil
	If Select("SRA") >0
		dbSelectArea("SRA")
		dbCloseArea()
	EndIf
	ChkFile("SRA",.F.,"SRA",,,,,cAliasSX2)
	If Select("SR8") >0
		dbSelectArea("SR8")
		dbCloseArea()
	EndIf
	ChkFile("SR8",.F.,"SR8",,,,,cAliasSX2)
EndIf

dbSelectArea("SRA")
dbSetOrder(1)	//RA_FILIAL+RA_MAT
dbSeek(cFilMat)  // sempre ter matricula vinculada - caso no entra na rotina

cTipoFolha	:= SRA->RA_SITFOLH

nPosSit := aScan( aSitFolha, ( cTipoFolha ) )

If nPosSit > 0

	//------------------------------------------------
	// Caso for tipo D (demitido) / T (transferencia).
	// Verificar a data  MsDate >= RA_DEMISSA
	// caso sim nao libero.
	//------------------------------------------------
	If ( cTipoFolha $ "D/T"  .And. AllTrim( aSitFolha[nPosSit] ) $ "D/T" ) .And. SRA->(!Eof())
		If Dtos(dDataFinal) >= Dtos(SRA->RA_DEMISSA)
			lRetorno	:= .f.
		EndIf
	EndIf

	//--------------------------------------------------
	// Caso o tipo for F(ferias) / A (afastado)
	// busca na tabela de afastamento tratando a
	// faixa de periodo afastado com a data MsDate()
	//--------------------------------------------------
	If ( cTipoFolha $ "F/A" .or. Empty(cTipoFolha) ) .And. AllTrim( aSitFolha[nPosSit] ) $ "F/A"
		dbSelectArea("SR8")
		dbSetOrder(1)
		dbSeek(cFilMat)
		While SR8->(!Eof()) .And. Alltrim(SR8->R8_FILIAL+SR8->R8_MAT) = Alltrim(cFilMat)
			If ( Dtos(dDataFinal) >= Dtos(SR8->R8_DATAINI) .And. Dtos(dDataFinal) <= Dtos(SR8->R8_DATAFIM) ) ;
				.Or. ;
				( Dtos(dDataFinal) >= Dtos(SR8->R8_DATAINI) .And. Empty( Dtos(SR8->R8_DATAFIM) ) )
				lRetorno	:= .f.
				Exit
			EndIf
			SR8->(dbSkip())
		EndDo
	EndIf
EndIf

If cAliasSX2 <> Nil
	dbSelectArea("SRA")
	dbCloseArea()
	dbSelectArea("SR8")
	dbCloseArea()
EndIf

RestArea(aAreaCor)

Return(lRetorno)



/*


ͻ
Programa  |fValFunc	Autor  Marcio Barretos      Data   02/03/09   
͹
Desc.     Verifica se existe alguma restricao, para o usuario que esta
          executando a rotina, que possa afetar o resultado.          
͹
Uso       Principais rotinas do SIGAGPE.                              
ͼ


*/
Function fValidFun(utable,lMens,lProsiga)

Local aAlias :=  Iif(ValType(utable)=="A",utable,"")
Local cAlias :=  Iif(ValType(utable)<>"A",utable,"")
Local lPermi := ""
Local lSayMsg := .F.
Local cFile    		:= 'LogSPFil.LOG'
Local cMask    		:= 'Arquivos Texto (*.TXT) |*.txt|'
Local cTextError    := ""
Local Nx
Local cPrefixTable := ""
Local cValFil := ""
Local uChkRh
Local bOk           := {|| oDlg:End()}
Local bCancel       := {|| oDlg:End()}
Local aButtons		:= {}
Local bGrava 		:= { || (cFile:=cGetFile(cMask,""),If(cFile="",.T.,MemoWrite(cFile,cTextError))) }

//Ŀ
// Declarao de arrays para dimensionar tela		         
//
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

Default lMens    := .T.    //informa se deve apresentar informacao na tela.
Default lProsiga := .F.    //informa se deve continuar  a executar

//Verifica se existe rotina SuperFiltro ou usuario adm
If cORGSPFL == 'N' .Or. ( RetCodUsr() == "000000" ) //Nao verifica restricoes em caso de usuario ser Administrador
	Return .T.
EndIf

If !Empty(aAlias)

	For Nx = 1 TO Len(aAlias)
        If(AliasInDic(aAlias[Nx]))
		    If SELECT(aAlias[Nx]) == 0
	    		dbSelectArea(aAlias[Nx])
		    EndIf
	 		cAlias := aAlias[Nx]
	 		uChkRh := ChkRH("",aAlias[Nx],"1",,,.T.)
			If ( ValtyPe(uChkRh) == "C" )
				lPermi := !Empty(uChkRh)
			ElseIf ( Valtype(uChkRh) == "L" )
				lPermi := uChkRh
			EndIf
			cPrefixTable := ( PrefixoCpo( cAlias ) + "_" )
			cValFil := " ("+cPrefixTable+"FILIAL $'"+fValidFil(cAlias) +"') "
			cPermi := GetGPEXSpFl(cAlias, cPrefixTable)

			If cPermi == cValfil .and. !lPermi
				lSayMsg := .F.
			ElseIf (!Empty(cPermi) .and. (cValFil <> cPermi) ) .and. !lPermi
				lSayMsg := .T.
			EndIf

			If !Empty(cPermi) .and. lPermi
				lSayMsg := .T.
			EndIf

			If lSayMsg
				//Mensagem de restricao de acesso
			    cTextError += " " + CHR(13) + CHR(10)
		    	cTextError += STR0111 + cAlias + " " + CHR(13) + CHR(10)   // "Usurio com restrio de acesso a tabela "
			    cTextError += " " + CHR(13) + CHR(10)
			    lSayMsg := .F.
	    	EndIf
		EndIf
	Next

ElseIf !Empty(cAlias)
    If(AliasInDic(cAlias))
	   	If SELECT(cAlias) == 0
			dbSelectArea(cAlias)
	    EndIf

		lPermi := ChkRH("",cAlias,"1",,,.T.)
		cPrefixTable := ( PrefixoCpo( cAlias ) + "_" )
		cValFil := " ("+cPrefixTable+"FILIAL $'"+fValidFil() +"') "
		cPermi := GetGPEXSpFl(cAlias, cPrefixTable)

	   	If !Empty(cPermi) .or. lPermi
			lSayMsg := .T.
		EndIf

		If cPermi == cValfil
			lSayMsg := .F.
		EndIf

		If lSayMsg
			//Mensagem de restricao de acesso
		    cTextError += " " + CHR(13) + CHR(10)
		    cTextError += STR0111 + cAlias + " " + CHR(13) + CHR(10)   // "Usurio com restrio de acesso a tabela "
	    	cTextError += " " + CHR(13) + CHR(10)
		    lSayMsg := .F.
		EndIf
    EndIf
EndIf

If !Empty(cTextError) .and. lMens

	//Gera tela de log das tabelas que tem restries de uso para o usurio
	If !lProsiga
	    cTextError += " " + CHR(13) + CHR(10)
    	cTextError += STR0112 + CHR(13) + CHR(10)   // "No  possvel executar essa rotina havendo "
	    cTextError += STR0113                       // "restrio de acesso a(s) tabela(s) citada(s)."
    EndIf

	/*
	Ŀ
	 Monta as Dimensoes dos Objetos         					   
	*/
	aAdvSize	 := MsAdvSize(,.T.,370)
	aInfoAdvSize := { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 3 , 3 }
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. , .T. } )
	aObjSize	 := MsObjSize( aInfoAdvSize , aObjCoords )

	DEFINE FONT oFont NAME "Arial" SIZE 0,-11
	DEFINE MSDIALOG oDlg TITLE STR0114 From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] PIXEL // "Log Controle de Acesso"

		@ aObjSize[1,1], aObjSize[1,2] GET oMemo  VAR cTextError MEMO SIZE aObjSize[1,3], aObjSize[1,4] OF oDlg PIXEL
		oMemo:bRClicked := {||AllwaysTrue()}
		oMemo:oFont:=oFont

	    If !lProsiga
			AAdd(aButtons, {"SALVAR",	bGrava , OemToAnsi(STR0152), OemToAnsi(STR0152)})	//"Salvar"
		EndIf

	ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar(oDlg,bOk,bCancel,,aButtons)

EndIf

Return ( Empty(cTextError) )

/*
Ŀ
Funo     SPFilterOff	Autor  Igor Franzoi      Data 07/04/2009
Ĵ
Descrio Muda a tabela para nao filtrada ou para tabela filtrada		
          conforme parametro											
Ĵ
Sintaxe   SPFilterOff( aTables, lType )								
Ĵ
 Uso      Generico													
Ĵ
 Retorno  lRet - Efetuou a operacao 									
Ĵ
Parametros< Vide Parametros Formais >									
*/
Function SPFilTerOff( aTables, lType )

Local lRet	:= .F.

Local nCont := 0

Default lType := .T.	//.T. desativa o SuperFiltro

If cORGSPFL== 'N'
	Return .T.
EndIf

For nCont := 1 To Len(aTables)
   	If AliasInDic( aTables[nCont] )
		If ( lType .and. FWOnSPFilter(aTables[nCont]) )
			FWNoSPFilter(aTables[nCont])
			lRet := .T.
		ElseIf ( !lType .and. !FWOnSPFilter(aTables[nCont]) )
			//FWYesSPFilter(aTables[nCont])
			FWSPFilter(aTables[nCont])
			lRet := .T.
		EndIf
	EndIf
Next

Return (lRet)

/*
Ŀ
Funo     GPELoadExec	Autor  Igor Franzoi      Data 13/04/2009
Ĵ
Descrio Funcao executada a cada rotina chamada pelo GPE				
Ĵ
Sintaxe   GPELoadExec													
Ĵ
 Uso      Generico													
Ĵ
 Retorno  															
Ĵ
Parametros< Vide Parametros Formais >									
*/
Function GPELoadExec()
	Iif( FindFunction("RHLIBEXP"), RhLibExp(), Nil )
If cORGSPFL== 'N'
	Return ""
EndIf

Return (SPFLoadExec())

Function ORGLoadExec()
	Iif( FindFunction("RHLIBEXP"), RhLibExp(), Nil )
Return

Function VDFLoadExec()
	Iif( FindFunction("RHLIBEXP"), RhLibExp(), Nil )
Return

Function GFPLoadExec()
	Iif( FindFunction("RHLIBEXP"), RhLibExp(), Nil )
Return

/*
Ŀ
Funo     SPFLoadExec	Autor  Igor Franzoi      Data 13/04/2009
Ĵ
Descrio Funcao executada a cada rotina chamada por todos os modulos 
Ĵ
Sintaxe   SPFLoadExec													
Ĵ
 Uso      Generico													
Ĵ
 Retorno  															
Ĵ
Parametros< Vide Parametros Formais >									
*/
Function SPFLoadExec()

Local cFunName		:= ""
Local cExpFilter	:= ""
Local cAuxFilter	:= ""
Local cTypeFilter	:= "1"

Local nCont			:= 0

Local lReplace		:= .F.

Local aAuxSPFil		:= {}
Local aOnSPFilter	:= ""

cFunName 	:= FunName()
aOnSPFilter	:= FWGetSPFilter()

Iif( FindFunction("RHLIBEXP"), RhLibExp(), Nil )

//Abre a tabela de restricoes antes de todas outras
ChkFile("SRW")
If SRW->(Eof())
	Return NIL
EndIf

If (SubStr(cFunName,1,3) $ ("APD/CSA/GPE/PON/RSP/TRM/APT"))
	If SubStr(cFunName,3,1) == "R"
		cTypeFilter := "2"
	EndIf
EndIf

If ( Empty(aOnSPFilter) )
	aOnSPFilter := LoadTbSpFil()
	For nCont := 1 To Len(aOnSPFilter)
		aAdd( aAuxSpFil, { aOnSPFilter[nCont], "" } )
	Next
	aOnSPFilter := aClone(aAuxSPFil)
Else
	lReplace	:= .T.
EndIf

For nCont := 1 To Len(aOnSPFilter)
	If ( Select(aOnSPFilter[nCont,1]) == 0 )
		ChkFile(aOnSPFilter[nCont,1])
	EndIf
	cExpFilter := GetGPEXSpFl(aOnSPFilter[nCont,1],PrefixoCpo( aOnSPFilter[nCont,1] ))
	cAuxFilter += ChkRh(cFunName,aOnSPFilter[nCont,1],cTypeFilter)
	If ( !Empty(cAuxFilter), cExpFilter := cExpFilter+" .and. "+cAuxFilter, cExpFilter )
	If !lReplace
		FWSetSPFilter(aOnSPFilter[nCont,1],cExpFilter)
	Else
		If ( aScan( aOnSPFilter, { |x| x[1] == aOnSPFilter[nCont,1] .and. AllTrim(x[2]) != AllTrim(cExpFilter) } ) > 0 )
			FWSetSPFilter(aOnSPFilter[nCont,1],cExpFilter)
		EndIf
	EndIf
	cExpFilter := ""
	cAuxfilter := ""
Next

Return (Nil)

/*


Ŀ
Funo    fGrpVerba  Autor  Marcelo Silveira       Data  01/10/09 
Ĵ
Descrio  Exibir os codigos para criar grupo de verbas               
Ĵ
 Uso       GPEA040 / GPEM400                                          
Ĵ
Parametros cNomeCpo = Nome do campo na tabela SX3. Necessario apenas  
                      quando a funcao eh chamada em alguma enchoice.  
ٱ


*/
Function fGrpVerba(cNomeCpo)
	Local cCampo		:= "M->RV_GRPVERB"
	Local cTitulo  		:= STR0158 //"Grupo de Verbas"
	Local MvPar    		:= ""
	Local MvParDef 		:= ""
	Local MvRet	 		:= Alltrim(ReadVar())
	Local MvStrRet		:= ""
	Local lRet     		:= .T.
	Local l1Elem   		:= .F.
	Local nGrupo		:= 0
	Local cGrpVerba     := GetMvRH( "MV_GRPVERB" , .F., STR0159 ) //"Grupo 1/Grupo 2/Grupo 3/Grupo 4/Grupo 5/Grupo 6/Grupo 7/Grupo 8/Grupo 9/Grupo 0"
	Local i				:= 0
	Local cDesc 		:= ""

	Private aGrpVerba	:= {}
	DEFAULT cNomeCpo	:= "1"

	//MONTA OS GRUPOS DE VERBAS COM BASE NA DESCRIO INDICADA NO PARAMETRO MV_GRPVERB
	For i := 1 to Len(cGrpVerba)
		If (SubStr(cGrpVerba,i,1) == "/") .OR. (i == Len(cGrpVerba))
			If !(SubStr(cGrpVerba,i,1) == "/")
				cDesc += SubStr(cGrpVerba,i,1)
			EndIf
			aadd(aGrpVerba,cDesc)
			cDesc := ""
		Else
			cDesc += SubStr(cGrpVerba,i,1)
		EndIf
	Next

	IF ( MvRet $ cCampo ) .or. ( &MvRet <> NIL )

		cAlias	 := Alias() 				 // Salva Alias Anterior
		MvPar 	 := &(Alltrim(ReadVar()))	 // Carrega Nome da Variavel do Get em Questao

		MvParDef := "1234567890"

		If cNomeCpo # "1" .And. cNomeCpo $ mvRet
			cNomeCpo := "1"
		EndIf

		If !Empty( mvRet ) .And. cNomeCpo == "1"
			If f_Opcoes(@MvPar,cTitulo,aGrpVerba,MvParDef,,,l1Elem)
				For nGrupo := 1 To Len( mvpar )
					If ( SubStr( mvpar, nGrupo, 1 ) # "*" )
						MvStrRet += SubStr( mvpar , nGrupo , 1 )
					Else
						MvStrRet += Space( 1 )
					Endif
				Next nGrupo
				&MvRet := MvStrRet
			EndIf
		EndIf

		If !Empty(cAlias)
			dbSelectArea( cAlias )
		Endif

	Else
		CposInitWhen()
	EndIf
Return( lRet )

/*


ͻ
Funcao    fM350VlPis     Autor  Allyson M 	  Data   12/03/12   
͹
Desc.     Funcao para buscar no acumulado os valores para geracao do  
          registro M350 do SPED Pis/Cofins.       			  		  
͹
Parametros                                                            
                                                                      
͹
Uso        Generico                                                   
ͼ


*/
Function fM350VlPis( cFilIni, cFilFim, dDataIni, dDataFim )

Local aArea		:= GetArea()
Local aAreaSM0	:= SM0->( GetArea() )
Local aCodFol	:= {}
Local aFilProc	:= {}
Local aRegM350	:= {}
Local aTpc		:= { 1, 2 }
Local aStru		:= {}
Local cAliasSRD	:= "SRD"
Local cCCFim	:= ""
Local cCodEmp	:= SM0->M0_CODIGO
Local cDtPesqF	:= ""
Local cDtPesqI	:= ""
Local cFilSRV	:= ""
Local cMesAno	:= ""
Local cPdQry	:= ""
Local cQuery	:= ""
Local cVbTotSa	:= ""
Local cVbExcBa	:= ""
Local cTpContr	:= "12"
Local lSRVComp	:= Empty( xFilial( "SRV" ) )
Local lQuerySRD	:= .F.
Local nCont		:= 0
Local nFilProc	:= 0
Local nPdQry	:= 0
Local nTamCC	:= TamSx3( "RZ_CC" )[1]
Local nVlAliPis	:= 1
Local nVlTotBas	:= 0
Local nVlTotExc	:= 0
Local nVlTotPis	:= 0
Local nVlTotSal	:= 0
Local nX		:= 0

Default cFilIni := FWGETCODFILIAL
Default cFilFim := FWGETCODFILIAL
Default dDataIni:= sToD( cValToChar( Year( dDataBase ) ) + "0101" )
Default dDataFim:= sToD( cValToChar( Year( dDataBase ) ) + "1231" )

cCCFim	 := Replicate( "z", nTamCC )
cDtPesqI := AnoMes( dDataIni )
cDtPesqF := AnoMes( dDataFim )
If Month( dDataFim ) == 12
	cDtPesqF := SubStr(cDtPesqF, 1, 4) + "13"
EndIf

//Monta o array das filiais a processar com o codigo das verbas.
dbSelectArea( "SM0" )
dbSeek( cCodEmp, .T. )
While !EoF() .And. cCodEmp == SM0->M0_CODIGO
	If AllTrim(FWGETCODFILIAL) >= AllTrim(cFilIni) .And. AllTrim(FWGETCODFILIAL) <= AllTrim(cFilFim)
		//Se o SRV for compartilhado, nao executa filtro de filial pois o codigo das verbas e' o mesmo.
		If lSRVComp
			cFilSRV := ""
		//Se o SRV for exclusivo, executa filtro de filial pois cada filial tera' codigo de verba diferente.
		ElseIf FWModeAccess("SRV", 1) == "E" .And. FWModeAccess("SRV", 2) == "E" .And. FWModeAccess("SRV", 3) == "E"
			cFilSRV	:= FWGETCODFILIAL
		ElseIf FWModeAccess("SRV", 1) == "E" .And. FWModeAccess("SRV", 2) == "E"
			cFilSRV	:= FWCompany()+FWUnitBusiness()
		ElseIf FWModeAccess("SRV", 1) == "E"
			cFilSRV	:= FWCompany()
		EndIf
        //Busca os codigos da folha e adiciona a filial caso tenha as verbas de Id's 223 e 229 cadastradas
		If Fp_Codfol( @aCodFol, cFilSRV, .F. )
			If !Empty( aCodFol[223,1] ) .And. !Empty( aCodFol[229,1] )
				cVbTotSa := GetMvRH( "MV_VBTOTSA", .F., "", cFilSRV )
				cVbTotSa += If( !Empty(cVbTotSa), "-" + GetMvRH( "MV_VBTOTS1", .F., "", cFilSRV ), GetMvRH( "MV_VBTOTS1", .F., "", cFilSRV ) )

				cVbExcBa := GetMvRH( "MV_VBEXCBA", .F., "", cFilSRV )
				cVbExcBa += If( !Empty(cVbExcBa), "-" + GetMvRH( "MV_VBEXCB1", .F., "", cFilSRV ), GetMvRH( "MV_VBEXCB1", .F., "", cFilSRV ) )

				aAdd( aFilProc, { FWGETCODFILIAL, cVbTotSa, cVbExcBa, aCodFol[223,1], aCodFol[229,1] } )
			Endif
		Endif
	Endif
	SM0->( dbSkip() )
End While

//Executa query no SRD para cada filial que sera processada, realizando filtro por filial,
//data de pagamento e codigo de verbas para encontrar os valores do PIS.
For nFilProc := 1 To Len( aFilProc )
	dbSelectArea( "SRD" )
	#IFDEF TOP
		cAliasSRD 	:= "SPEDMontSRD"
		lQuerySRD	:= .T.

		If ( Select( cAliasSRD ) > 0 )
			(cAliasSRD)->( dbCloseArea() )
		EndIf

		aStru  	:= SRD->( dbStruct() )
		cQuery 	:= "SELECT * "
		cQuery 	+= " FROM " + RetSqlName("SRD") + " SRD "
		cQuery 	+= " WHERE SRD.RD_FILIAL  = '" + aFilProc[nFilProc, 1] + "'"

		If cDtPesqF != cDtPesqI
			cQuery 	+= " AND SRD.RD_DATARQ BETWEEN '"+ cDtPesqI + "' AND '"+ cDtPesqF +"'"
		Else
			cQuery 	+= " AND SRD.RD_DATARQ = '"+ cDtPesqI + "'"
		EndIf

		cQuery 	+= " AND SRD.RD_EMPRESA = '" + Space( Len( cEmpAnt ) ) + "'"

		//Adiciona as verbas com Id 223 e 229 para query
		cPdQry  := "'" + aFilProc[nFilProc, 4] + "', '" + aFilProc[nFilProc, 5] + "'"

		//Adiciona as verbas para composicao do total de salario para Query (MV_VBTOTSA)
		If !Empty( aFilProc[nFilProc, 2] )
			For nPdQry := 1 To Len( AllTrim( aFilProc[nFilProc, 2] ) ) Step 3
				cPdQry += ", '" + Subs( aFilProc[nFilProc, 2], nPdQry, 3 ) + "'"
				nPdQry++
			Next nPdQry
		EndIf

		//Adiciona as verbas para composicao do total de exclusao para Query (MV_VBEXCBA)
		If !Empty( aFilProc[nFilProc, 3] )
			For nPdQry := 1 To Len( AllTrim( aFilProc[nFilProc, 3] ) ) Step 3
				cPdQry += ", '" + Subs( aFilProc[nFilProc, 3], nPdQry, 3 ) + "'"
				nPdQry++
			Next nPdQry
		EndIf

		cQuery 	+= " AND SRD.RD_PD IN (" + cPdQry + ")"
		cQuery 	+= " AND SRD.D_E_L_E_T_ = ' ' "
		cQuery 	+= " ORDER BY " + SqlOrder( SRD->( IndexKey() ) )

		cQuery := ChangeQuery( cQuery )
		dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasSRD, .T., .T.)

		For nX := 1 To Len( aStru )
			If aStru[nX][2] != "C" .And. FieldPos( aStru[nX][1] ) != 0
				TcSetField( cAliasSRD, aStru[nX][1], aStru[nX][2], aStru[nX][3], aStru[nX][4] )
			EndIf
		Next nX

		dbSelectArea( cAliasSRD )
	#ENDIF


	//While do SRD para alimentar os valores das variaveis de PIS
	While (cAliasSRD)->( !Eof() ) .And. (cAliasSRD)->RD_FILIAL == aFilProc[nFilProc, 1]
		If (cAliasSRD)->RD_EMPRESA == Space( Len( cEmpAnt ) ) .And. (cAliasSRD)->RD_DATARQ  >= cDtPesqI .And. (cAliasSRD)->RD_DATARQ <= cDtPesqF
			//Valor Total da Folha de Salarios (MV_VBTOTSA)
			If (cAliasSRD)->RD_PD $ aFilProc[nFilProc, 2]
				nVlTotSal += (cAliasSRD)->RD_VALOR
			EndIf
			//Valor Total das Exclusoes a Base de Cclculo (MV_VBEXCBA)
			If (cAliasSRD)->RD_PD $ aFilProc[nFilProc, 3]
				nVlTotExc += (cAliasSRD)->RD_VALOR
			EndIf
			//Valor Total da Base de Calculo (Id 223)
			If (cAliasSRD)->RD_PD == aFilProc[nFilProc, 4]
				nVlTotBas += (cAliasSRD)->RD_VALOR
			EndIf
			//Valor Total da Contribuicao Social sobre a Folha de Salarios (Id 229)
			If (cAliasSRD)->RD_PD == aFilProc[nFilProc, 5]
				nVlTotPis += (cAliasSRD)->RD_VALOR
				//Aliquota do PIS/PASEP - Folha de Salarios
				PosSrv( (cAliasSRD)->RD_PD, (cAliasSRD)->RD_FILIAL )
				nVlAliPis  := SRV->RV_PERC
			EndIf
		EndIf
		(cAliasSRD)->( dbSkip() )
	End While
Next nFilProc

#IFDEF TOP
	If lQuerySRD
		(cAliasSRD)->( dbCloseArea() )
	EndIf
#ENDIF

// Gera a base de clculo de acordo com o valor total do PIS, pois o clculo individual feito na folha de pagamento
// gera diferena quando h arredondamento do valor
nVlTotBas := Round(nVlTotPis / (nVlAliPis / 100), 2)
nVlTotSal := If(nVlTotSal > 0, nVlTotBas + nVlTotExc, nVlTotSal)

//Monta o registro M350 para envio ao Sped Pis/Cofins
aAdd( aRegM350, { "M350", nVlTotSal, nVlTotExc, nVlTotBas, nVlAliPis, nVlTotPis } )

RestArea( aArea )
RestArea( aAreaSM0 )

Return( aRegM350 )
