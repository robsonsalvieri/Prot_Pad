#INCLUDE "PONM070.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "PONCALEN.CH"
#INCLUDE "ARFF.CH"
#INCLUDE "FWLIBVERSION.CH"

Static lPonCalmBlock
Static lPonCalrBlock
Static lPonCalaTotBlock
Static lPonCaldBlock
Static lPonCalHeBlock
Static lPnm070CposBlock              
Static lPnmBh01Block   
Static lPnm07001Block
Static lPnmDSR01Block   
Static lPnmDSR02Block   
Static lPonEveContBlock
Static lPort1510 	:= Port1510() 	//  Verifica se Portaria 1510/2009 esta em vigor.   
Static lDSRHorista 	:= SuperGetMv( "MV_DSRHORI", NIL, .F. )
Static lDSRTab 		:= SuperGetMv("MV_DSRTAB",,.F.)
Static lCpoCCT
Static lCpoPer	:= NIL
Static lMesesBH	:= NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ PONM070  ³ Autor ³ Fernando Joly Siquini ³ Data ³ 19/01/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calculo Mensal                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ SIGAPON				             						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Leandro Dr. ³13/04/14³      ³Retirada de ajustes, database e FieldPos  ³±±
±±³            ³        ³      ³que nao serao utilizados na P12.		  ³±±
±±³Luis Artuso ³27/08/14³TQFN58³Ajuste para considerar o conteudo do para-³±±
±±³            ³        ³      ³metro MV_DDSRFER.                         ³±±
±±³Wag Mobile  ³18/12/14³TRHGNE³Retornar alteracoes referentes ao chamado ³±±
±±³            ³        ³      ³TQFN58                                    ³±±
±±³Luis Artuso ³16/07/15³TSWW25³Ajuste em fCalcPer para totalizar correta-³±±
±±³            ³        ³      ³mente os eventos de faltas, quando o perio³±±
±±³            ³        ³      ³do de apuracao for semanal.               ³±±
±±³Renan Borges³18/04/16³TUJU54³Ajuste para não gerar DSR duplicado quando³±±
±±³            ³        ³      ³não houver DSR no primeiro periodo e hou- ³±±
±±³            ³        ³      ³ver mais de 1 DSR no prox periodo.        ³±±
±±³            ³        ³      ³Criação do P.E PN070LOG que será utilizado³±±
±±³            ³        ³      ³para gravar o log na tabela CV8,solicitado³±±
±±³            ³        ³      ³pelo cliente CERTISIGN.		              ³±±
±±³Matheus M.  ³26/07/16³TVLXIR³Ajuste para desconto de DSR em feriado.   ³±±
±±³Renan Borges³29/03/17³MRH-  ³Ajuste para que ao realizar o cálculo men-³±±
±±³            ³        ³8742  ³sal seja respeitado as datas informadas   ³±±
±±³            ³        ³      ³nos parametros corretamente, sendo possí- ³±±
±±³            ³        ³      ³vel gerar os resultados do período selecio³±±
±±³            ³        ³      ³nado.                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function PONM070( lRobo, lTelaBH, lPerApont ) 
Local aArea			:= GetArea()
Local cSvFilAnt		:= cFilAnt
Local cUrl			:= ""
Local lBarG1ShowTm 	:= .F.
Local lBarG2ShowTm 	:= .F.
Local nOp			:= 0
Local lSchedule		:= FWGetRunSchedule()
Local cAliasSRA		:= ""
Local cMarkSRA		:= ""
Local lExib2Plan	:= FwLibVersion() >= "20240520"
Local lExec2Plan	:= FwIsInCallStack("WFLAUNCHER") .or. FwIsInCallStack("FWBOSCHDEXECUTE")

Private cCadastro   := OemToAnsi( STR0006 ) // 'Calculo Mensal'
Private dPerIni		:= Ctod("//")
Private dPerFim		:= Ctod("//")
Private lAbortPrint := .F.

Private aFldRot 	:= {'RA_NOME'}
Private aOfusca	 	:= If(FindFunction('ChkOfusca'), ChkOfusca(), {.T.,.F.}) //[1] Acesso; [2]Ofusca
Private lOfuscaNom	:= .F. //RA_NOME
PRIVATE aFldOfusca	:= {}
Private lSegFaltas	:= SuperGetMv("MV_SEGFALT",NIL,.F.)

Default lTelaBH		:= .F.
Default lRobo		:= .F.
Default lPerApont	:= .F.

If lTelaBH 
	If Type("oArqSRA") == "O" .And. Type("cMark") == "C"
		cAliasSRA := oArqSRA:GetRealName()
		cMarkSRA := cMark
	EndIf
	lTelaBH := If(Empty(cAliasSRA) .Or. Empty(cMarkSRA), .F., lTelaBH)
EndIf

If !lSegFaltas
	If !IsBlind()
		cUrl := "https://tdn.totvs.com/pages/viewpage.action?pageId=847569991"
		nOp := Aviso(STR0068,STR0066 + CRLF + CRLF + CRLF + STR0067 + cUrl,{STR0069,STR0070}) //"A partir de 01/06/2024 o parâmetro MV_SEGFALT obrigatoriamente deverá ser ativado para realizar o calculo mensal." ### "Consulte a documentação em: "
		
		If nOp == 2
			shellExecute("Open",cUrl, "", "", 1)
		EndIf
	Else
		Conout(AnsiToOEM(STR0068 + ": " + STR0066))
	EndIf
	
	Return
EndIf

If aOfusca[2]
	aFldOfusca := FwProtectedDataUtil():UsrNoAccessFieldsInList( aFldRot ) // CAMPOS SEM ACESSO
	IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_NOME" } ) > 0
		lOfuscaNom := FwProtectedDataUtil():IsFieldInList( "RA_NOME" )
	ENDIF
EndIf

DEFAULT lPonCalmBlock		:= ExistBlock( "PONCALM"  	)
DEFAULT lPonCalrBlock		:= ExistBlock( "PONCALR"  	)
DEFAULT lPonCalaTotBlock	:= ExistBlock( "PONCALATOT"	)
DEFAULT lPonCaldBlock		:= ExistBlock( "PONCALD"  	)
DEFAULT lPonCalHeBlock		:= ExistBlock( "PONCALHE" 	)
DEFAULT lPnm070CposBlock	:= ExistBlock( "PNM070CPOS"	)
DEFAULT lPnmBh01Block		:= ExistBlock( "PNM070BH01"	)
DEFAULT lPnm07001Block		:= ExistBlock( "PNM07001"	)   
DEFAULT lPnmDSR01Block		:= ExistBlock( "PNMDDSR01")
DEFAULT lPnmDSR02Block		:= ExistBlock( "PNMDDSR2")
DEFAULT lPonEveContBlock    := ExistBlock( "PNMEVECONT"	)    

If lPort1510
	cCadastro += fPortTit() //Complementa titulo da tela com dizeres referente a portaria.
EndIf

// Só Executa se os Modos de Acesso dos Arquivos Relacionados estiverm OK e se For Encontrado o Periodo de Apontamento.
IF ValidArqPon() 
	// Reinicializa Variaveis Staticas para o Calculo Mensal
	PonDestroyStatic()
	
	// Aviso informando que será sobreposto os eventos do período na SPB
	// "Atenção"
	// "Ao realizar o cálculo mensal os eventos serão sobrepostos, principalmente a data de pagamento. Ela será atualizada para a data base do sistema caso já existam eventos nos resultados dentro do período selecionado."
	If !lRobo .And. !lSchedule .And. !lTelaBH
		MsgInfo(OemToAnsi(STR0063),OemToAnsi(STR0040))
	EndIf

	If !lRobo .And. !lSchedule .And. !lTelaBH
		// Executa o Processo
		TNewProcess():New("PONM070", STR0006 , {|oSelf| PNM070Proc(lRobo, lTelaBH, cAliasSRA, cMarkSRA, lPerApont, oSelf, lExec2Plan)}, STR0003 + STR0004 + STR0005, "PNM070", NIL, NIL, NIL, NIL, .T., .F., lExib2Plan) //"Cálculo Mensal" / "Esta rotina tem  como objetivo apurar o resultado final dos eventos calculados em um Período, possibilitando sua manutençäo antes de realizar o Fechamento Mensal."
	ElseIf (lRobo .Or. lSchedule) .And. !lExec2Plan
		PNM070Proc(lRobo, lTelaBH, cAliasSRA, cMarkSRA, lPerApont)
	ElseIf lExec2Plan
		TNewProcess():New("PONM070", STR0006 , {|oSelf| PNM070Proc(lRobo, lTelaBH, cAliasSRA, cMarkSRA, lPerApont, oSelf, lExec2Plan)}, STR0003 + STR0004 + STR0005, "PNM070", NIL, NIL, NIL, NIL, .T., .F., lExib2Plan) //"Cálculo Mensal" / "Esta rotina tem  como objetivo apurar o resultado final dos eventos calculados em um Período, possibilitando sua manutençäo antes de realizar o Fechamento Mensal."
	ElseIf lTelaBH
		// Verifica se deve Mostrar Calculo de Tempo nas BarGauge
		lBarG1ShowTm := ( SuperGetMv("MV_PNSWTG1",NIL,"N") == "S" )
		lBarG2ShowTm := ( SuperGetMv("MV_PNSWTG2",NIL,"S") == "S" )

		// Executa o Processo
		Proc2BarGauge({|| PNM070Proc(lRobo, lTelaBH, cAliasSRA, cMarkSRA, lPerApont, Nil, .F.)}, STR0001, NIL, NIL, .T., lBarG1ShowTm, lBarG2ShowTm ) // 'Realizando calculo mensal... '
	EndIF	
EndIF

cFilAnt := cSvFilAnt
RestArea( aArea )

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ PONM070Processa ³ Autor ³ Wiliam R.      ³ Data ³ 30/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Processa o fechamento Mensal                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ SIGAPON				             						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function PNM070Proc(lRobo, lTelaBH, cAliasSRA, cMark, lPerApont, oProcess, lExec2Plan)
//-- Variaveis Locais
Local cSvFilAnt		:= cFilAnt
Local cFilExetd		:= ""
Local cLastFil   	:= "__cLastFil__"
Local cLastPrc   	:= "__cLastPrc__"
Local cFilTnoOld	:= "__cFilTnoOld__"
Local cFilTnoAtu	:= "__cFilTnoAtu__"
Local cOldFilTnoSeq	:= "__cOldFilTnoSeq__"
Local cAtuFilTnoSeq	:= "__cAtuFilTnoSeq__"
Local cFilTnoDe		:= ""
Local cFilTnoAte	:= ""
Local cFilialDe  	:= ""
Local cFilialAte 	:= ""
Local cCCDe      	:= ""
Local cCCAte     	:= ""
Local cTurnoDe   	:= ""
Local cTurnoAte  	:= ""
Local cMatDe     	:= ""
Local cMatAte    	:= ""
Local cRegraDe   	:= ""
Local cRegraAte  	:= ""
Local cNomeDe    	:= ""
Local cNomeAte   	:= ""
Local cSituacoes 	:= ""
Local cCategoria 	:= ""
Local cNomeArray 	:= ""
Local cAcessaSRA	:= &("{ || " + ChkRH("PONM070","SRA","2") + "}")
Local cEveMesA		:= ""
Local cFilSPD		:= ""
Local cFilSP6		:= ""
Local cFilSP4		:= ""
Local cFilSP9		:= ""
Local cFilSPC		:= ""
Local cFilSPI		:= ""
Local cFilSPB		:= ""
Local cTimeIni		:= Time()
Local dIniDate		:= Date()
Local cAliasSPB		:= "SPB"
Local cAliasQSPB	:= cAliasSPB
Local cAliasSPC		:= "SPC"
Local cAliasQSPC	:= cAliasSPC
Local cAliasSPI		:= "SPI"
Local cAliasQSPI	:= cAliasSPI
Local cPerAnot 		:= ""
Local cPerAtra		:= ""
Local cPerSaia 		:= ""
Local cPerHext		:= ""
Local cPerHmov		:= ""
Local cPerDdsr		:= ""
Local cDescDSR		:= ""
Local cRefeit		:= ""
Local cRegra		:= ""
Local cEveAbono		:= ""   
Local cEvBhAB		:= ""
Local cEvBhAP		:= ""
Local cMsgBarG1		:= ""
Local cMsgErr		:= ""
Local cVerbaCont	:= ""
Local cVerba		:= ""
Local cMsg			:= ""
Local cBHEveP		:= ""
Local cBHEveD		:= ""
Local cBHEveH		:= ""
Local cTpContr		:= ""
Local cDuracao		:= ""

Local dIniFec		:= CtoD("//")
Local dFimFec		:= CtoD("//")

Local aAreaSRA	 	:= SRA->( GetArea() )
Local aFilFec		:= {}
Local aTabPadrao	:= {}
Local aTotais    	:= {}
Local aRFF			:= {}
Local aBHAcum    	:= {}
Local aCodigos	 	:= {}
Local aResult	 	:= {}
Local aCodRef	 	:= {}
Local aArred_D	 	:= {}
Local aAbonos	 	:= {}
Local aAbonosPer	:= {}
Local aEvesIds		:= {}
Local aRecsSR6		:= {}
Local aSvLogDet		:= {}
Local aLogAboEve	:= {}
Local aRecsBarG		:= {}
Local aSpaFields	:= {}
Local aSpaInfo		:= {}
Local aSp6Fields	:= {}
Local aSp6Info		:= {}
Local aSp9Fields	:= {}
Local aSp9Info		:= {}   
Local aTotAux		:= {}
Local aAuxConv		:= {}
Local aAuxConv2		:= {}
Local aCodFol		:= {}
Local aLogs			:= {}
Local aLogsFunc		:= {}

Local bSraScope

Local lAddEveCont   := .F.
Local lHorasTab	 	:= .F.
Local lDsrProp   	:= .F.
Local lLimDSR	 	:= .F.
Local lDsrPPer		:= .F.
Local lMvAcmHExt 	:= .F.
Local lMvArrInte	:= .F.
Local lMvAbosEve	:= .F.
Local lExistInfo 	:= .F.	
Local lSR6Comp		:= FWModeAccess("SR6", 1) == "C"
Local lIncProcG1	:= .T.
Local lSP9Comp		:= FWModeAccess("SR9", 1) == "C"
Local lMvSubAbAp	:= .F.
Local lMvDedAbBH	:= .T.
Local lMvFolVBh		:= .F.
Local lMvDDSRFer 	:= .T.
Local lPerCompleto  := .F.
Local lMantBH		:= .F.
Local lArredTno 	:= .F.
Local lTemPer		:= .F.
Local lSchedule		:= FWGetRunSchedule()

Local nX         	:= 0
Local nY			:= 0
Local nHrAbon    	:= 0
Local nHoras     	:= 0
Local nW		 	:= 0
Local nLenAbo	 	:= 0
Local nLenSPI		:= 0	
Local nLenSPB		:= 0	
Local nCodAut		:= 0
Local nBHAcum		:= 0
Local nTotais		:= 0
Local nLastRec		:= 0
Local nPosSP4		:= 0
Local nRecsSR6		:= 0
Local nTolNotu		:= 0
Local nTolAtra		:= 0
Local nTolSaia		:= 0	
Local nTolHNR		:= 0
Local nTolHePe		:= 0
Local nNumAtra		:= 0 
Local nHorasAb		:= 0
Local nIncPercG1	:= 0
Local nIncPercG2	:= 0
Local nCount1Time	:= 0
Local nT			:= 0
Local nLenSPIAux	:= 0
Local nConvoc		:= 0
Local nPerAb		:= 0
Local nPosConv		:= 0
Local nI			:= 0
Local nTpContr		:= 0
Local nFuncProc		:= 0

Local cIniData		:= ""
Local cFimData		:= ""

Local uRetBlock
Local lPELog 		:=	ExistBlock("PN070LOG")

Local aStruSRA		:= {}
Local aCposSRA		:= {}
Local aTotBHAux		:= {}
Local aTempSRA		:= SRA->( dbStruct() )
Local aSpbFields	:= SPB->( dbStruct() )
Local aSpcFields	:= SPC->( dbStruct() )
Local aSpiFields	:= SPI->( dbStruct() )
Local cQuery	 	:= ""
Local cWhere		:= ""
Local cSPBQuery		:= ""
Local cSPBSvQuery	:= ""
Local cSPCQuery		:= ""
Local cSPCSvQuery	:= ""
Local cSPIQuery		:= ""
Local cSPISvQuery	:= ""
Local cSvFil	    := ""
Local cSvMat		:= ""
Local cSvIniData	:= ""
Local cSvFimData	:= ""
Local cTpC1			:= ""
Local dDtAuxIni		:= CtoD("")
Local dDtFimProx	:= CtoD("")
Local dDtAuxFim		:= CtoD("")
Local dDtIniUSem	:= CtoD("")
Local lQueryOpened	:= .F.
Local lSraQryOpened	:= .F.
Local lAtuBH		:= .F.
Local lBHProv		:= .F.
Local nSpbFields	:= Len( aSpbFields	)
Local nSpcFields	:= Len( aSpcFields	)
Local nSpiFields	:= Len( aSpiFields	)
Local nContField	:= Len( aTempSRA	)
Local nBHAux		:= 0
Local nBHSem		:= 0
Local lInterm		:= .F.
Local aLogPerg		:= {}

Local aHExtAux		:= {}
Local aHENtAux		:= {}
Local lFiltraCCT	:= .F.
Local cFilCCT		:= ""
Local cCodCCT		:= ""

Local lOnlyBH		:= .F.
Local nMesesBH		:= 0
Local nLoop			:= 0

//-- Variaveis Private
Private cSaiAnte	:= ""
Private cPagaHrs	:= ""
Private cPagaHrsNot := ""
Private cPagaDSR	:= ""
Private cFilSPA		:= ""
Private cArrCalc	:= ""
Private cNormFol    := ""
Private cPerApo		:= ""
Private cHrMovel	:= ""
Private cInMovel	:= ""
Private cPgBHSem	:= "2"
Private lDesDSRAfa	:= .F.

Private dDataIni	:= Ctod("//")
Private dDataFim	:= Ctod("//")

Private aEveCont	:= {}
Private aTabCalend	:= {}
Private aTotAdiN	:= {}
Private aTotAtra	:= {}
Private aTotSAnt	:= {}
Private aTotHNR		:= {}
Private aTotPgHD	:= {}
Private aTotHExt	:= {}
Private aTotHENt	:= {}
Private aCodAut		:= {}
Private aLogDet		:= {}
Private aLogTitle	:= {}
Private aConvoc		:= {}
Private aPerAberto	:= {}

Private lFuncAcBH	:= .T.

Private nBHDe		:= 0
Private nBHAte		:= 0
Private nPercAgBh	:= 0
Private nPercAgFl	:= 0

Private cUsrLog   	:= Alltrim(UsrRetName(__CUSERID))
Private cEveFal		:= ""
Private cEveTotR	:= ""

Private lPgBHSem 	:= SPA->(ColumnPos("PA_PGBHSEM")) > 0
Private lDSRAFAS 	:= SPA->(ColumnPos("PA_DSRAFAS")) > 0
Private lPBConvoc 	:= SPB->(ColumnPos("PB_CONVOC")) > 0
Private lContrInt 	:= SRC->(ColumnPos("RC_CONVOC")) > 0
Private lHEInterm	:= .F.

Private lCheckDSR	:= .F.

Default lRobo		:= .F.
Default lTelaBH		:= .F.
Default cAliasSRA	:= ""
Default cMark		:= ""
Default lPerApont	:= .F.
Default oProcess	:= Nil
Default lExec2Plan	:= .F.

DEFAULT lCpoCCT	   :=  SP4->(ColumnPos("P4_CODCCT") > 0)

lCpoPer := If(lCpoPer != NIL, lCpoPer, SP4->(ColumnPos("P4_PERHEXT") > 0))

lMesesBH := If(lMesesBH == NIL, SPI->(ColumnPos("PI_MESESBH")) > 0, lMesesBH)

SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_SEGFALT")
P_SEGFALT := If( Type("P_SEGFALT") == "U", .F., P_SEGFALT)

// Carregando as Perguntas
If (!lSchedule .And. FindFunction("RetPergLog"))
	Pergunte("PNM070",.F.)
	RetPergLog(aLogPerg, "PNM070")
EndIf

If lSchedule .Or. lExec2Plan
	cFilialDe	:= Padr(AllTrim(mv_par01),GetSx3Cache("RA_FILIAL","X3_TAMANHO"),"")
	cFilialAte	:= Padr(AllTrim(mv_par02),GetSx3Cache("RA_FILIAL","X3_TAMANHO"),"")
	cCCDe		:= Padr(AllTrim(mv_par03),GetSx3Cache("RA_CC","X3_TAMANHO"),"")
	cCCAte		:= Padr(AllTrim(mv_par04),GetSx3Cache("RA_CC","X3_TAMANHO"),"")
	cTurnoDe	:= Padr(AllTrim(mv_par05),GetSx3Cache("RA_TNOTRAB","X3_TAMANHO"),"")
	cTurnoAte	:= Padr(AllTrim(mv_par06),GetSx3Cache("RA_TNOTRAB","X3_TAMANHO"),"")
	cMatDe		:= Padr(AllTrim(mv_par07),GetSx3Cache("RA_MAT","X3_TAMANHO"),"")
	cMatAte		:= Padr(AllTrim(mv_par08),GetSx3Cache("RA_MAT","X3_TAMANHO"),"")
	cRegraDe	:= Padr(AllTrim(mv_par09),GetSx3Cache("RA_REGRA","X3_TAMANHO"),"")
	cRegraAte	:= Padr(AllTrim(mv_par10),GetSx3Cache("RA_REGRA","X3_TAMANHO"),"")
	cNomeDe		:= Padr(AllTrim(mv_par11),GetSx3Cache("RA_NOME","X3_TAMANHO"),"")
	cNomeAte	:= Padr(AllTrim(mv_par12),GetSx3Cache("RA_NOME","X3_TAMANHO"),"")
Else
	cFilialDe  := mv_par01
	cFilialAte := mv_par02
	cCCDe      := mv_par03
	cCCAte     := mv_par04
	cTurnoDe   := mv_par05
	cTurnoAte  := mv_par06
	cMatDe     := mv_par07
	cMatAte    := mv_par08
	cRegraDe   := mv_par09
	cRegraAte  := mv_par10
	cNomeDe    := mv_par11
	cNomeAte   := mv_par12
EndIf

cSituacoes := mv_par13
cCategoria := mv_par14
lHorasTab  := IF( mv_par15 == 1 , .T. , lHorasTab ) //-- 1=Hrs Tabela - 2=Hrs Apont.
dDataIni   := mv_par16
dDataFim   := mv_par17
cTipoRefDe := mv_par18
cTipoRefAte:= mv_par19
nAgrupEvnt := iif(Empty(mv_par20), 1, mv_par20)

If Type("mv_par21") == "C"
	cTpContr := mv_par21
	If cTpContr == "***" .Or. Empty(cTpContr)
		nTpContr := 4
	Else
		cTpC1 := "("
		For nI := 1 To 3
			If cValToChar(nI) $ cTpContr .And. nI == 1
				cTpC1 += "' ','*','1'"
			ElseIf cValToChar(nI) $ cTpContr .And. nI == 2
				If cTpC1 == "("
					cTpC1 += "'2'"
				Else
					cTpC1 += ",'2'"
				EndIf
			ElseIf cValToChar(nI) $ cTpContr .And. nI == 3
				If cTpC1 == "("
					cTpC1 += "'3'"
				Else
					cTpC1 += ",'3'"
				EndIf
			EndIf
		Next
		cTpC1 += ")"
		nTpContr := 1
	EndIf
ElseIf Type("mv_par21") == "N"
	nTpContr    := Iif(Empty(mv_par21), 4, mv_par21)
	If nTpContr == 1
		cTpC1 := "(' ','*','1')"
	ElseIf nTpContr == 2
		cTpC1 := "('2')"
	ElseIf nTpContr == 3
		cTpC1 := "('3')"
	EndIf
EndIf

lOnlyBH := If(!lTelaBH, If(Type("MV_PAR22") == "N", MV_PAR22 == 1, .F.), lTelaBH)

// Inicializa os arquivos a serem utilizados
dbselectArea("RFF")

dbSelectArea("SP5") //-- Refeições
dbSetOrder(1)

dbSelectArea("SP6") //-- Motivos de Abono / Justificativa
dbSetOrder(1)

dbSelectArea("SP9") //-- Eventos
dbSetOrder(1)

dbSelectArea("SPA") //-- Regras de Apontamento
dbSetOrder(1)

dbSelectArea("SPB") //-- Resultados
dbSetOrder(1)

dbSelectArea("SPC") //-- Apontamentos
dbSetOrder(1)

dbSelectArea("SRA") //-- Funcion rios
dbSetOrder(4)

Begin Sequence
	
	// ## O parâmetro Agrupar Eventos está preenchido com a opção 'Sim'. Essa opção faz com o que o cálculo incremente as verbas já presentes nos resultados. Deseja continuar? ##
	If !lRobo .And. !lSchedule .And. !lOnlyBH .And. nAgrupEvnt == 1 .AND. !MsgYesNo(STR0043) 
		Break
	Endif
	
	// Inicializa Filial/Turno De/Ate
	cFilTnoDe	:= ( cFilialDe + cTurnoDe )
	cFilTnoAte	:= ( cFilialAte + cTurnoAte )
	
	// Cria o Bloco dos Funcionarios que atendam ao Scopo
	bSraScope := { || (;
							( RA_TNOTRAB	>= cTurnoDe		.and. RA_TNOTRAB	<= cTurnoAte	) .and. ;
							( RA_FILIAL 	>= cFilialDe	.and. RA_FILIAL 	<= cFilialAte	) .and. ;
							( RA_REGRA 		>= cRegraDe		.and. RA_REGRA 		<= cRegraAte	) .and. ;
							( RA_NOME 		>= cNomeDe		.and. RA_NOME 		<= cNomeAte		) .and. ;
							( RA_MAT 		>= cMatDe		.and. RA_MAT 		<= cMatAte		) .and. ;
							( RA_CC 		>= cCCDe		.and. RA_CC 		<= cCCAte		) .and. ;
							( !lPBConvoc .Or. nTpContr == 4 .Or. RA_TPCONTR $ cTpC1 );
					);
				}
	
	// Seta apenas os Campos do SRA que serao Utilizados
	aAdd( aCposSRA, "RA_FILIAL"		)
	aAdd( aCposSRA, "RA_MAT" 		)	
	aAdd( aCposSRA, "RA_NOME"		)
	aAdd( aCposSRA, "RA_CC"			)
	aAdd( aCposSRA, "RA_TNOTRAB"	)
	aAdd( aCposSRA, "RA_SEQTURN"	)
	aAdd( aCposSRA, "RA_REGRA"  	)
	aAdd( aCposSRA, "RA_ADMISSA"  	)
	aAdd( aCposSRA, "RA_DEMISSA"  	)
	aAdd( aCposSRA, "RA_CATFUNC"  	)
	aAdd( aCposSRA, "RA_SITFOLH"  	)
	aAdd( aCposSRA, "RA_HRSEMAN" 	)
	aAdd( aCposSRA, "RA_HRSMES" 	)
	aAdd( aCposSRA, "RA_ACUMBH" 	)
	aAdd( aCposSRA, "RA_TPCONTR" 	)
	
	// Verifica e Seta os campos a mais incluidos no Mex
	fAdCpoSra(aCposSra)			
	
	// Ponto de Entrada para Campos do Usuario
	IF ( lPnm070CposBlock )
		IF ( ValType( uRetBlock := ExecBlock("PNM070CPOS",.F.,.F.,aCposSRA) ) == "A" )
			IF Len( uRetBlock ) >= Len( aCposSRA )
				aCposSRA	:= aClone( uRetBlock )
				uRetBlock	:= NIL
			EndIF
		EndIF
	EndIF
	
	// Abandona o Processamento
	IF ( lAbortPrint )
		//'O Calculo Mensal Foi Cancelado Pelo Usuario'
		aAdd( aLogDet , STR0010 )
		Break
	EndIF
	
	For nX := 1 To nContField
		// Abandona o Processamento
		IF ( lAbortPrint )
			//'O Calculo Mensal Foi Cancelado Pelo Usuario'
			aAdd( aLogDet , STR0010 )	
			Break
		EndIF
		// Carrega os Campos do SRA para a Montagem da Query
		IF aScan( aCposSRA , { |x| Upper(AllTrim(x)) == Upper( AllTrim( aTempSRA[ nX , 1 ] ) ) } ) > 0
			aAdd( aStruSRA , aClone( aTempSRA[ nX ] ) )
		EndIF
	Next nX
	
	aCposSRA	:= aTempSRA := NIL
	nContField	:= Len( aStruSRA )
	cQuery := "SELECT "
	
	For nX := 1 To nContField
		// Abandona o Processamento
		IF ( lAbortPrint )
			//'O Calculo Mensal Foi Cancelado Pelo Usuario'
			aAdd( aLogDet , STR0010 )	
			Break
		EndIF
		
		// Inclui os Campos na Montagem da Query
		cQuery += "SRA." + aStruSRA[ nX, 1] + ", "
	Next nX
	
	cQuery := SubStr( cQuery, 1, Len(cQuery) - 2)
	cQuery += " FROM " + InitSqlName("SRA") + " SRA "
	
	// Apenas os funcionários selecionados na rotina de Gestão de Banco de Horas
	If lTelaBH
		cQuery += "INNER JOIN " + cAliasSRA + " TMP "
		cQuery += "ON SRA.RA_FILIAL = TMP.RA_FILIAL AND "
		cQuery += "SRA.RA_MAT = TMP.RA_MAT AND "
		cQuery += "TMP.OK = '" + cMark + "' "
	EndIf
	
	cWhere += " WHERE "
	
	If !lTelaBH
		cWhere += "SRA.RA_FILIAL>='" + cFilialDe + "' AND "
		cWhere += "SRA.RA_FILIAL<='" + cFilialAte + "' AND "
		cWhere += "SRA.RA_TNOTRAB>='" + cTurnoDe + "' AND "	
		cWhere += "SRA.RA_TNOTRAB<='" + cTurnoAte + "' AND "
		cWhere += "SRA.RA_MAT>='" + cMatDe + "' AND "	
		cWhere += "SRA.RA_MAT<='" + cMatAte + "' AND "
		cWhere += "SRA.RA_NOME>='" + cNomeDe + "' AND "	
		cWhere += "SRA.RA_NOME<='" + cNomeAte + "' AND "
		cWhere += "SRA.RA_REGRA>='" + cRegraDe + "' AND "	
		cWhere += "SRA.RA_REGRA<='" + cRegraAte + "' AND "
		cWhere += "SRA.RA_CC>='" + cCCDe + "' AND "	
		cWhere += "SRA.RA_CC<='" + cCCAte + "' AND "
		If lPBConvoc .And. nTpContr != 4
			cWhere += "SRA.RA_TPCONTR IN " + cTpC1 + " AND "
		EndIf
	EndIf
	
	cWhere += "SRA.D_E_L_E_T_ = ' ' "
	
	cQuery += cWhere
	cQuery += "ORDER BY " + SqlOrder( SRA->(IndexKey()))
	cQuery := ChangeQuery(cQuery)
	
	// Abandona o Processamento
	IF ( lAbortPrint )
		//'O Calculo Mensal Foi Cancelado Pelo Usuario'
		aAdd( aLogDet , STR0010 )	
		Break
	EndIF
	
	SRA->( dbCloseArea() ) //Fecha o SRA para uso da Query
	If ( lSraQryOpened := MsOpenDbf(.T., "TOPCONN", TcGenQry(,,cQuery), "SRA", .T., .T.))
		For nX := 1 To nContField
			IF ( aStruSRA[nX,2] <> "C" )
				TcSetField("SRA", aStruSRA[nX,1], aStruSRA[nX,2], aStruSRA[nX,3], aStruSRA[nX,4])
			EndIF
		Next nX
		
		// Verifica o Total de Registros a Serem Processados
		cQuery := "SELECT COUNT(*) NLASTREC "
		cQuery += "FROM "+InitSqlName("SRA")+" SRA "
		cQuery += cWhere
		cQuery := ChangeQuery(cQuery)
		IF ( MsOpenDbf(.T., "TOPCONN", TcGenQry(,,cQuery), "__QRYCOUNT", .T., .T.))
			nLastRec := __QRYCOUNT->NLASTREC
			__QRYCOUNT->( dbCloseArea() )
            Else
			MsAguarde( { || SRA->( dbEval( { || ++nLastRec } ) ) } , STR0033 + STR0034 )	//'Aguarde...'###'Selecionaldo Funcionarios'
			SRA->( dbGotop() )
		EndIF
	Else
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Restaura Arquivo Padrao e Ordem                             ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		ChkFile( "SRA" )
		SRA->( dbSetOrder( 04 ) )
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica o Total de Registros a Serem Processados            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aRecsBarG := {}
		CREATE SCOPE aRecsBarG FOR SRA->( Eval( bSraScope ) )
		SRA->( dbSeek( cFilialDe , .T. ) )
		nLastRec := SRA->( ScopeCount( aRecsBarG ) )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Procura primeiro funcion rio.                               ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		SRA->( dbSeek( cFilTnoDe , .T. ) )
	EndIF
	
	If ((!lTelaBH .And. !lRobo .And. !lSchedule) .Or. (oProcess <> Nil .Or. lExec2Plan))
		// Define a quantidade de registros para a regua de processamento
		oProcess:SetRegua1(nLastRec)

		// Inclui a informação no log do tNewProcess
		oProcess:SaveLog(STR0080) // "Início da execução do Cálculo Mensal"
	ElseIf lTelaBH
		// Inicializa Mensagem para a IncProcG2() ( Funcionarios )
		IncProcG2( STR0008  , .F. )	// 'Processando...'
		
		// Atualiza a Mensagem para a IncProcG2() ( Funcionarios )
		BarGauge2Set( nLastRec )
	EndIf

	
	// Carrega os Campos para a PosSpa()
	aAdd( aSpaFields, "PA_PERANOT" )	//01
	aAdd( aSpaFields, "PA_PERATRA" )	//02
	aAdd( aSpaFields, "PA_PERSAIA" )	//03
	aAdd( aSpaFields, "PA_PERHEXT" )	//04
	aAdd( aSpaFields, "PA_PERHMOV" )	//05
	aAdd( aSpaFields, "PA_PERDDSR" )	//06
	aAdd( aSpaFields, "PA_DESCDSR" )	//07
	aAdd( aSpaFields, "PA_REFEIT"  )	//08
	aAdd( aSpaFields, "PA_TOLNOTU" )	//09
	aAdd( aSpaFields, "PA_TOLATRA" )	//10
	aAdd( aSpaFields, "PA_TOLSAIA" )	//11
	aAdd( aSpaFields, "PA_TOLHEPE" )	//12
	aAdd( aSpaFields, "PA_NUMATRA" )	//13
	aAdd( aSpaFields, "PA_HRMOVEL" )	//14
	aAdd( aSpaFields, "PA_INMOVEL" )	//15
	
	If lPort1510
		aAdd( aSpaFields , "PA_NORMFOL" )	//16	
	EndIf
	
	If lPgBHSem
		aAdd( aSpaFields , "PA_PGBHSEM" )	//17
	EndIf
	
	If lDSRAFAS
		aAdd( aSpaFields , "PA_DSRAFAS" )	//18
	EndIf
	
	aAdd( aSpaFields , "PA_TOLHRNR" )	//19
	
	// Carrega os Campos para a PosSp6()
	aAdd( aSp6Fields , "P6_EVENTO"  )	//01
	aAdd( aSp6Fields , "P6_ABHORAS" )	//02
	
	aAdd( aSp9Fields , "P9_BHORAS" )	//01
	aAdd( aSp9Fields , "P9_BHNDE"  )	//02	
	aAdd( aSp9Fields , "P9_BHNATE" )	//03
	aAdd( aSp9Fields , "P9_BHPERC" )	//04
	aAdd( aSp9Fields , "P9_BHAGRU" )	//05
	aAdd( aSp9Fields , "P9_BHVAL"  )	//06
	aAdd( aSp9Fields , "P9_PBH"    )	//07
	aAdd( aSp9Fields , "P9_PFOL"   )	//08
	aAdd( aSp9Fields , "P9_CODFOL" )	//09
	aAdd( aSp9Fields , "P9_TIPOCOD" )	//10
	
	// Processa o Calculo Mensal
	While SRA->( !Eof() .And. ( lTelaBH .Or. ( (cFilTnoAtu := RA_FILIAL + RA_TNOTRAB) >= cFilTnoDe .And. cFilTnoAtu <= cFilTnoAte)))
		
		If(lTelaBH, cFilTnoAtu := SRA->(RA_FILIAL + RA_TNOTRAB), )
		
		If (!lTelaBH .And. !lRobo .And. !lSchedule) .Or. (oProcess <> Nil .Or. lExec2Plan)
			// Obrigatorio chamar o incremento da regua, a quantidade de chamadas do IncRegua1 precisa ser exatamente a mesma da quantidade definida na regua (SetRegua1)
			oProcess:IncRegua1(STR0081 + AllTrim(SRA->RA_FILIAL) + STR0082 + SRA->RA_MAT) // "Processando funcionário... Filial: " " Matrícula: "
		EndIf
		
		// Consiste filtro do intervalo De/Ate
		If !lTelaBH .And. SRA->( !Eval( bSraScope ) )
			SRA->( dbSkip() )
			Loop
		EndIF
		
		If ( aScan(aFilFec, {|x| x == SRA->RA_FILIAL}) ) > 0
			SRA->( dbSkip() )
			Loop
		EndIf
		
		aConvoc		:= {}
		aAuxConv	:= {}
		aAuxConv2	:= {}
		lInterm		:= SRA->RA_TPCONTR == "3"
		lTemPer		:= .F.
		
		// Aborta o processamento
		IF ( lAbortPrint )
			//'O Calculo Mensal Foi Cancelado Pelo Usuario'
			aAdd( aLogDet , STR0010 )	
			Break
		EndIF
		
		// Atualiza a Mensagem para a IncProcG1() ( Turnos )
		cAtuFilTnoSeq := ( cFilTnoAtu + SRA->RA_SEQTURN )
		IF !( cOldFilTnoSeq == cAtuFilTnoSeq )
			// Atualiza o Filial/Turno/Sequencias Anteriores
			cOldFilTnoSeq := cAtuFilTnoSeq
			
			// Atualiza a Mensagem para a BarGauge do Turno
			//"Filial:"###"Turno:"###"Sequencia:"
			cMsgBarG1 := SRA->( STR0026 + " " + RA_FILIAL + " - " + STR0027 + " " + RA_TNOTRAB + " - " + Left(AllTrim( fDesc( "SR6" , RA_TNOTRAB , "R6_DESC" , NIL , RA_TNOTRAB , 01 ) ),50) + " " + STR0028 + " " + RA_SEQTURN )
			
			// Verifica se Houve Troca de Filial para Verificacai dos Turnos
			IF !( cLastFil == SRA->RA_FILIAL ) //A Atribuicao a cLastFil sera feita abaixo
				If (!lTelaBH .And. !lRobo .And. !lSchedule) .And. (oProcess <> Nil .Or. lExec2Plan)
					// Define o Numero de registros da regua de processamento			
					oProcess:SetRegua2(1)
					// Inicializa Mensagem da regua 2
					oProcess:IncRegua2(cMsgBarG1)
				ElseIf lTelaBH
					// Obtem o % de Incremento da 2a. BarGauge
					nIncPercG1 := SuperGetMv( "MV_PONINC1", NIL, 5, SRA->RA_FILIAL )
					
					// Obtem o % de Incremento da 2a. BarGauge
					nIncPercG2 := SuperGetMv( "MV_PONINCP", NIL, 5, SRA->RA_FILIAL )
					
					// Realimenta a Barra de Gauge para os Turnos de Trabalho
					IF ( !lSR6Comp .or. ( nRecsSR6 == 0 ) )
						CREATE SCOPE aRecsSR6 FOR ( R6_FILIAL == cLastFil .or. Len( Alltrim ( R6_FILIAL ) ) > 0 )
						nRecsSR6 := SR6->( ScopeCount( aRecsSR6 ) )
					EndIF
					
					// Define o Contador para o Processo 1
					--nCount1Time
					// Define o Numero de Elementos da BarGauge
					BarGauge1Set( nRecsSR6 )
					
					// Inicializa Mensagem na 1a BarGauge
					IncProcG1( cMsgBarG1 , .F. )
					
					// Reinicializa a Filial/Turno Anterior
					cFilTnoOld := "__cFilTnoOld__"

					If ( lIncProcG1 := !( cFilTnoOld == cFilTnoAtu ) )
						cFilTnoOld := cFilTnoAtu
					EndIF

					IncPrcG1Time( cMsgBarG1, nRecsSR6, cTimeIni, .F., nCount1Time, nIncPercG1, lIncProcG1 )
				EndIf
			EndIF
		EndIF

		If lTelaBH
			// Movimenta a Régua de Processamento do Processamento Principal
			IncPrcG2Time( STR0032, nLastRec, cTimeIni, .T., 2, nIncPercG2 )
		EndIf

		// Consiste a Categoria
		If !lTelaBH .And. !( SRA->RA_SITFOLH $ cSituacoes )
			SRA->( dbSkip() )
			Loop
		EndIf
		
		// Consiste a Categoria
		If !lTelaBH .And. !( SRA->RA_CATFUNC $ cCategoria )
			SRA->( dbSkip() )
			Loop
		EndIf
		
		// Consiste controle de acessos e filiais validas
		If !lTelaBH .And. SRA->( !(RA_FILIAL $ fValidFil()) .or. !Eval(cAcessaSRA) )
			SRA->(dbSkip()) 
			Loop
		EndIf
		
		// Verifica se as H.E. do funcionario vao para Banco de Horas
        lFuncAcBH := !( SRA->RA_ACUMBH == "N" )
		
		If lMesesBH
			nMesesBH := SRA->(GetMesesBH(RA_FILIAL, RA_MAT))
		EndIf
        
		// Cria Array com c¢digos autorizados de Eventos e Horas Extras
		If !( SRA->RA_FILIAL == cLastFil )
			
			fp_CodFol(@aCodFol, xFilial('SRV',SRA->RA_FILIAL), .F., .F.)
			
			If Empty(aCodFol[54,1])
				Help(,,"Help",,STR0064,1,0,,,,,,{STR0065}) //"Não foi encontrada uma verba vinculada com o ID de Cálculo 0054 (Falta)." "Será necessário cadastar uma verba com o ID de Cálculo 0054 e processar novamente o Cálculo Mensal."
				Return
			Else
				cEveFal := aCodFol[54,1]
			EndIf
			
			// Verba para a geração do valor total do vale refeição
			cEveTotR := If(Len(aCodFol) >= 1868 .And. !Empty(aCodFol[1868][1]), aCodFol[1868][1], "" )
			
			// Atualiza a Filial Anterior
			cLastFil	:= SRA->RA_FILIAL	//A atribuicao de cLastFil devera ser feita aqui
            cFilAnt		:= cLastFil
			dPerIni     := CtoD("")
			dPerFim     := CtoD("")
			
			// Carrega as Filiais dos Arquivos
			cFilSP4 := fFilFunc("SP4")
			cFilSP6 := fFilFunc("SP6")
			cFilSP9 := fFilFunc("SP9")
			cFilSPA := fFilFunc("SPA")
			cFilSPB	:= fFilFunc("SPB")
			cFilSPC	:= fFilFunc("SPC")
			cFilSPI	:= fFilFunc("SPI")
			
			// Carregar os Mv's de acordo com a Filial
			lMvAcmHExt	:= ( Upper(AllTrim(SuperGetMv("MV_ACMHEXT",NIL,"N",cLastFil))) == "S" )	//--Verifica se Acumula Hora Extra para o Escalonamento	
			lMvArrInte	:= ( Upper(AllTrim(SuperGetMv("MV_ARRINTE",NIL,"N",cLastFil))) == "S" )	//--Define se ira considerar o Arredondamento Integral das Horas
			lMvAbosEve	:= ( Upper(AllTrim(SuperGetMv("MV_ABOSEVE",NIL,"N",cLastFil))) == "S" )	//--Verifica se Deduz as horas abonadas das horas do evento Sem a necessidade de informa o Codigo do Evento no motivo de abono que abona horas
			lDsrProp   	:= ( Upper(AllTrim(SuperGetMv("MV_DSRPROP",NIL,"N",cLastFil))) == "S" )	//--Desconto de DSR proporcional
			lLimDSR	 	:= ( Upper(AllTrim(SuperGetMv("MV_LIMDSR" ,NIL,"N",cLastFil))) == "S" )	//--Variavel Para Limitar Desconto de DSR ao Periodo de Apuracao do Mesmo
			lDsrPPer	:= ( Upper(AllTrim(SuperGetMv("MV_DSRPPER",NIL,"S",cLastFil))) == "S" )	//--Verifica se gerara evento de desconto de DSR para o proximo periodo
			lMvSubAbAp	:= ( Upper(AllTrim(SuperGetMv("MV_SUBABAP",NIL,"N",cLastFil))) == "S" )	//--Verifica se Quando Abono nao Abonar Horas e Possuir codigo de Evento, se devera Gera-lo em outro evento e abater suas horas das Horas Calculadas
			lMvDedAbBH	:= ( Upper(AllTrim(SuperGetMv("MV_DEDABBH",NIL,"S",cLastFil))) == "S" )	//-- A horas apontadas sofrerao deducao das horas abonadas de um evento que vai para banco de horas e esta relacionado a um motivo de abonos que abona horas.
			lMvFolVBh	:= ( Upper(AllTrim(SuperGetMv("MV_FOLVBH" ,NIL,"N",cLastFil))) == "S" )	//-- A horas apontadas sofrerao deducao das horas abonadas de um evento se o destino das horas apontadas for diferente do destino das horas abonadas.
			cArrCalc	:= Upper(AllTrim(SuperGetMv("MV_ARRCALC",NIL,"B",cLastFil)))			//--Indica se o Arredondamento a maior das horas separadas pelos percentuais dos Eventos serao para o Banco de Horas ou para a Folha de Pagamento
			nBHDe		:= SuperGetMv("MV_BHDE"		,NIL,0,cLastFil)							//--Numero Inicial de Horas que ira compor para acumular no Banco de Horas. Devera estar especificado em Horas. Ex. 0.01 a 999.99
			nBHAte		:= SuperGetMv("MV_BHATE"	,NIL,0,cLastFil)							//--Numero Final de Horas que ira compor para acumular no Banco de Horas. Devera estar especificado em Horas. Ex. 0.01 a 999.99
			nPercAgBh	:= SuperGetMv("MV_PERAGBH"	,NIL,0,cLastFil)							//--Indica o percentual que sera enviado para o Banco de Horas de Eventos com apuracao por Agrupamento. em Horas. Ex. 0 100
			nPercAgFl	:= SuperGetMv("MV_PERAGFL"	,NIL,0,cLastFil)							//--Indica o percentual que sera enviado para a Folha de Pagto de Eventos com apuracao por Agrupamento.de Pagto de Eventos com apuracao por Agrupamento.
			lMvDDSRFer	:= ( (SuperGetMv("MV_DDSRFER"  ,NIL,1,cLastFil)) == 1  )		        //--Verifica se o Desconto do DSR incide sobre o feriado
			lMantBH		:= SuperGetMv("MV_MANTBH",,.F.)
			lArredTno	:= SuperGetMv("MV_ARRETNO",,.F.)										//--Verifica se valida o arredondamento por turno
			lHEInterm	:= SuperGetMv("MV_PONINTE ",NIL,.F.,cLastFil) .And. lPBConvoc .And. (GetApoInfo("GPEM020.PRX")[4] >= sToD("20200903"))//--Apuração de hora extra para contrato intermitente separado por convocação
			
			If lHEInterm
				aPerAberto := {}
				fRetPerComp(StrZero( Month(dDataFim), 2 ), StrZero( Year(dDataFim), 4 ), NIL, SRA->RA_PROCES, fGetCalcRot("1"), @aPerAberto)
			EndIf
			
			If PosSP9( "023A" , cFilSP9 , NIL , 2 , .F. )
				aSp9Info := PosSP9( "023A" , cFilSP9 , aSp9Fields	, 2 , .F. )
				cBHEveP  := aSp9Info[9]
			EndIf
			If PosSP9( "024A" , cFilSP9 , NIL , 2 , .F. )
				aSp9Info := PosSP9( "024A" , cFilSP9 , aSp9Fields	, 2 , .F. )
				cBHEveD  := aSp9Info[9]
			EndIf
			If PosSP9( "042A" , cFilSP9 , NIL , 2 , .F. )
				aSp9Info := PosSP9( "042A" , cFilSP9 , aSp9Fields	, 2 , .F. )
				cBHEveH  := aSp9Info[9]
			EndIf
			
			If lSchedule .Or. lPerApont
				GetPonMesDat(@dDataIni, @dDataFim, cLastFil)
				If dDataBase > dDataFim
					dDataBase := dDataFim
				ElseIf dDataBase < dDataIni
					dDataBase := dDataIni
				EndIf
			EndIf
			
			// Carrega o Periodo de Apontamento de Acordo com a Filial
			IF !CheckPonMes( @dPerIni, @dPerFim, NIL, .T., .T., cLastFil, NIL, @lPerCompleto )
				//'Periodo para o Calculo Invalido.'###'Nao foi possivel Realizar o Calculo Mensal'
				aAdd( aLogDet , STR0009 + " " + STR0002 )
				Break
			ElseIf lPerCompleto
				If ( dPerFim < dDataBase )
					cMsg := STR0037													//'O Periodo de Apontamento: '
					cMsg += Dtoc( dPerIni )
					cMsg += STR0039													//' a '
					cMsg += Dtoc( dPerFim )                                        	
					cMsg += STR0038													//'ainda n„o foi Fechado'
					cMsg += CRLF + STR0022											//"O Calculo Mensal nao sera efetuado."
                    If !lRobo .And. !lSchedule
						MsgAlert( cMsg, STR0040 )									//"Atenção"
					EndIf
                    Break
				EndIf
			EndIF
			
			GetPonMesDat( @dIniFec, @dFimFec, cLastFil ) //Carrega período de apontamento atual
			
			If dPerFim <= dIniFec
				//'Periodo para o Calculo Invalido.'###'Nao foi possivel Realizar o Calculo Mensal'
				aAdd( aLogDet , STR0009 + " " + STR0002 + STR0014 + cLastFil + " - " + STR0059 + DtoC(dPerIni) + " - " + DtoC(dPerFim))
				aAdd( aFilFec, cLastFil)
				SRA->( dbSkip() )
				Loop
			ElseIf dPerIni < dIniFec
				dPerIni := dIniFec //Irá calcular apenas o período que não foi fechado
				aAdd( aLogDet , STR0060 + DtoC(dPerIni) + STR0061 + cFilAnt + " : " + DtoC(dPerIni) + STR0062 + DtoC(dPerFim) ) //"Período de calculo alterado pois os dias anteriores a " ### " já foram fechados. Período utilizado para a filial " ### até
			EndIf
			
			// Reinicializa cIniData e cFimData Quando TOP
			cIniData	:= Dtos( dPerIni )
			cFimData	:= Dtos( dPerFim )
			
			//Consiste Data Inicial e Data Final
			IF !fChkPer(dDataIni, dDataFim, cLastFil)
				//'Periodo para o Calculo Invalido.'###'Nao foi possivel Realizar o Calculo Mensal'
				aAdd( aLogDet , STR0009 + " " + STR0002 )
				Break
			Else
				dPerIni := Max(dPerIni, dDataIni)
				dPerFim := Min(dPerFim, dDataFim)
				
				If nAgrupEvnt == 2 .And. dPerIni == dDataIni .And. dPerFim == dDataFim
					lCheckDSR := .T.
				EndIf
				
			EndIF
            
			// Periodo de Apontamento par registro na tabela RFF
			cPerApo	:= DTOS(dPerIni)+DTOS(dPerFim)
			
			// Reinicializa aCodAut apenas se os arquivos SP9 nao for compartilhada
			IF !( lSP9Comp )
				aCodAut := {}
				aEveCont	:= {} 
				cVerba		:= ""
				cVerbaCont	:= ""
			EndIF
			
			// Carrega Informacoes em aCosAut
			IF Empty( aCodAut )
				
				// Preenche o Array aCodAut com as Horas Extras
				SP4->( dbSeek( cFilSP4 , .T. ) )
				While ( SP4->( !Eof() .and. ( cFilSP4 == P4_FILIAL ) ) )
					
					// Aborta o processamento
					IF ( lAbortPrint )
						//'O Calculo Mensal Foi Cancelado Pelo Usuario'
						aAdd( aLogDet , STR0010 )	
						Break
					EndIF

					For nLoop := 1 To 2
						If (nLoop == 1, cEvento := SP4->P4_CODAUT, cEvento := SP4->P4_CODNAUT)

						IF PosSP9( cEvento , cFilSP9 , NIL , 1 , .F. )
							aSp9Info := PosSP9( cEvento , cFilSP9 , aSp9Fields	, 1 , .F. )
							IF ( (nPosSP4:=aScan( aCodAut, { |x| x[1] == cEvento } )) == 0 )
								aAdd( aCodAut , Array( 14 ) )
								nCodAut := Len( aCodAut )
								aCodAut[ nCodAut , 01 ] := cEvento
								IF !( SP4->P4_TIPO $ "A*B*C*D*E*F*G*H" )
									aCodAut[ nCodAut , 02 ] := If( Val( SP4->P4_TIPO ) >= 5 , "HENA" , "HEDA" )
								Else
									aCodAut[ nCodAut , 02 ] := If( SP4->P4_TIPO$ "B*D*F*H" , "HENA" , "HEDA" )
								EndIF	
								aCodAut[ nCodAut , 03 ] := "N"
								aCodAut[ nCodAut , 04 ] := aSp9Info[1]
								aCodAut[ nCodAut , 05 ] := ""
								aCodAut[ nCodAut , 06 ] := aSp9Info[2]
								aCodAut[ nCodAut , 07 ] := aSp9Info[3]
								aCodAut[ nCodAut , 08 ] := aSp9Info[4]
								aCodAut[ nCodAut , 09 ] := IF( ( nBHDe + nBHAte ) > 0 .and. aSp9Info[5] == "S" , "S" , "N" )
								aCodAut[ nCodAut , 10 ] := aSp9Info[6]
								aCodAut[ nCodAut , 11 ] := aSp9Info[7]
								aCodAut[ nCodAut , 12 ] := aSp9Info[8]
								aCodAut[ nCodAut , 13 ] := aSp9Info[9]
								aCodAut[ nCodAut , 14 ] := {SP4->P4_TIPO}
							Else 
								If ( Ascan(aCodAut[ nPosSP4 , 14 ], SP4->P4_TIPO) == 0 )
									AADD(aCodAut[ nPosSP4 , 14 ],  SP4->P4_TIPO )
								Endif	
							EndIF
						EndIF
					Next
					SP4->(dbSkip())
				EndDo
				
				// Preenche o Array aCodAut com os Eventos (Menos DSR Mes Ant.)
				SP9->( dbSeek( cFilSP9 , .T. ) )
				While ( SP9->( !Eof() .and. ( cFilSP9 == P9_FILIAL ) ) )
					
					// Aborta o processamento
					IF ( lAbortPrint )
						//'O Calculo Mensal Foi Cancelado Pelo Usuario'
						aAdd( aLogDet , STR0010 )	
						Break
					EndIF
					
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Carrega Evento que ainda nao foi carregado se:			       ³
					³Vai para Banco de Horas ou Intregracao com Folha ( com excecao³
					³Saida Antecipada periodo Anterior) ou Evento com Identificador³
					³de Ponto mas sem Integracao com Folha  					   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF	SP9->((( P9_BHORAS == "S" ) .Or. ;
							(!Empty( P9_CODFOL ) .And. ( P9_IDPON # "022A" )) .Or.;
							(Empty( P9_CODFOL ) .And. !Empty( P9_IDPON ))) .And. ;
							( aScan( aCodAut, { |x| x[1] == P9_CODIGO } ) == 0 ))	
						aAdd( aCodAut , Array( 14 ) )
						nCodAut := Len( aCodAut )
						aCodAut[ nCodAut , 01 ] := SP9->P9_CODIGO
						aCodAut[ nCodAut , 02 ] := SP9->P9_IDPON
						aCodAut[ nCodAut , 03 ] := SP9->P9_DESCDSR
						aCodAut[ nCodAut , 04 ] := SP9->P9_BHORAS
						aCodAut[ nCodAut , 05 ] := "D"
						aCodAut[ nCodAut , 06 ] := SP9->P9_BHNDE
						aCodAut[ nCodAut , 07 ] := SP9->P9_BHNATE
						aCodAut[ nCodAut , 08 ] := SP9->P9_BHPERC
						aCodAut[ nCodAut , 09 ] := IF( ( nBHDe + nBHAte ) > 0 .and. SP9->P9_BHAGRU == "S" , "S" , "N" )
						aCodAut[ nCodAut , 10 ] := SP9->P9_BHVAL
						aCodAut[ nCodAut , 11 ] := SP9->P9_PBH
						aCodAut[ nCodAut , 12 ] := SP9->P9_PFOL
						aCodAut[ nCodAut , 13 ] := SP9->P9_CODFOL
						aCodAut[ nCodAut , 14 ] := {SPACE(1)}
					EndIF
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Preenche o Array aCodAut com os Abonos					  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					//--Se existe o campo de Evento Contador
				    //-- Verifica se nao foi carregado o evento do ponto
					If !( ( lAddEveCont:= Empty( aEveCont) ) )
						lAddEveCont:= ( Ascan(aEveCont, {|x| x[1] == SP9->P9_CODIGO } ) == 0 )
					Endif	
					//-- Se o Evento possuir Evento Contador Associado
				   	If lAddEveCont .AND. Len(Alltrim(SP9->P9_EVECONT )) > 0  
				   		AADD(aEveCont, { SP9->P9_CODIGO, SP9->P9_EVECONT } ) 
				   		nRecno:=SP9->(Recno())
				   		cVerbaCont+= If(!Empty( ( cVerba:= PosSP9( SP9->P9_EVECONT , cFilSP9 , "P9_CODFOL" , 1, .F. ) ) ), cVerba, "")
				   		SP9->(DbGoto(nRecno))
				   	Endif	
					SP9->( dbSkip() )
				End While
				
				// Preenche o Array aCodAut com os Abonos
				SP6->( dbSeek( cFilSP6 , .T. ) )
				While ( SP6->( !Eof() .and. ( cFilSP6 == P6_FILIAL ) ) )
					
					// Aborta o processamento
					If ( lAbortPrint )
						//'O Calculo Mensal Foi Cancelado Pelo Usuario'
						aAdd( aLogDet , STR0010 )
						Break
					EndIF
					
					// Carrega o Evento do Motivo de Abono
					cEvento := SP6->P6_EVENTO
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se o Conteudo do parametro MV_ABOSEVE for igual a "N" e o Abo³
					³ no Abonar Horas o Codigo de Evento do Abono devera estar  pre³
					³ enchido													   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If !lMvAbosEve .And. SP6->P6_ABHORAS == "S" .And. Empty( cEvento )
						SP6->( aAdd( aLogAboEve, P6_FILIAL + " - " + P6_CODIGO + " " + P6_DESC ))
						SP6->( dbSkip() )
						Loop
					EndIF
					
					// Se o Evento do Motivo de Abono Nao Estiver Vazio
					If !Empty(cEvento) .And. PosSP9( cEvento, cFilSP9, NIL, 1, .F.)
						aSp9Info := PosSP9( cEvento , cFilSP9 , aSp9Fields	, 1 , .F. )
						aAdd( aCodAut , Array( 14 ) )
						nCodAut := Len( aCodAut )
						aCodAut[ nCodAut , 01 ] := cEvento
						aCodAut[ nCodAut , 02 ] := "ABOA"
						aCodAut[ nCodAut , 03 ] := "N"
						aCodAut[ nCodAut , 04 ] := aSp9Info[1]
						aCodAut[ nCodAut , 05 ] := "D"
						aCodAut[ nCodAut , 06 ] := aSp9Info[2]
						aCodAut[ nCodAut , 07 ] := aSp9Info[3]
						aCodAut[ nCodAut , 08 ] := aSp9Info[4]
						aCodAut[ nCodAut , 09 ] := IF( ( nBHDe + nBHAte ) > 0 .and. aSp9Info[5] == "S" , "S" , "N" )
						aCodAut[ nCodAut , 10 ] := aSp9Info[6]
						aCodAut[ nCodAut , 11 ] := aSp9Info[7]
						aCodAut[ nCodAut , 12 ] := aSp9Info[8]
						aCodAut[ nCodAut , 13 ] := aSp9Info[9]
						aCodAut[ nCodAut , 14 ] := {SPACE(1)}
					EndIF
					SP6->( dbSkip() )
				EndDo
				
				// Carrega no Log de Ocorrencias os Motivos de Abono sem Eventos e Aborta o Processamento
				If ( nW := Len( aLogAboEve ) ) > 0
					For nX := 1 To nW
			    		//'O motivo de Abono: '###' Abona Horas esta sem codigo de Evento devidamente preenchido.'
						aAdd( aLogDet , STR0035 + aLogAboEve[ nX ] + STR0036 )
					Next nX
					Break
				EndIf
			EndIf
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se os Codigos Foram Carregados                      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF Empty( aCodAut )
				//'Nao foi possivel Realizar o Calculo Mensal' ###'Verifique se existem Eventos cadastrados no SP9 (Cadastro de Eventos)'
				aAdd( aLogDet , STR0002  + " " + STR0016 )
				Break
			EndIF
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Nao carregar novamente o cadastro de eventos qdo o mesmo for³
			³ compartilhado												  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF (!Len(AllTrim(cFilSP9)) > 0 .Or. (Len(aCodigos) == 0) .Or. cFilExetd <> SRA->RA_FILIAL)
				aCodigos := {}
				IF !fCargaId(@aCodigos,cLastFil,.F.)
					//'Nao foi possivel Realizar o Calculo Mensal' ###'Verifique se existem Eventos cadastrados no SP9 (Cadastro de Eventos)'
					aAdd( aLogDet , STR0002  + " " + STR0016 )
					Break
				EndIF
				
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carregae alteracao no Log e porque existem Identificadores do³
				³ Ponto nao vinculado a Eventos								   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
            	aSvLogDet	:= aClone( aLogDet )
            	aEvesIds	:= GetEveIdPon( aCodigos , cLastFil , @aLogDet )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Se houve alteracao no Log e porque existem Identificadores do³
				³ Ponto nao vinculado a Eventos								   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
            	IF !fCompArray( aLogDet , aSvLogDet )
            		Break
            	EndIF
            	aSvLogDet := {}
            EndIF

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Inicializa os codigos de Horas Normais e DSR				  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF (;
					Empty( cPagaHrs := aEvesIds[ 001 , 02 ] );
					.or.;
					Empty( cPagaHrsNot := aEvesIds[ 026 , 02 ] );
					.or.;
					Empty( cPagaDSR := aEvesIds[ 002 , 02 ] );
				 )
				//'Nao foi possivel Realizar o Calculo Mensal' ###'Verifique se Existem Eventos para os Identificadores 001A, 002A e 026A'
				aAdd( aLogDet , STR0002  + " " + STR0017 )
				Break
			EndIF
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Evento de Saida Antecipada								  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cSaiAnte := aEvesIds[ 014 , 02 ]
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Reinicializa Array com os Codigos de Refeicao				  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			aCodRef := {}
		ElseIf !( SRA->RA_PROCES == cLastPrc )
			If lHEInterm
				aPerAberto := {}
				fRetPerComp(StrZero( Month(dDataFim), 2 ), StrZero( Year(dDataFim), 4 ), NIL, SRA->RA_PROCES, fGetCalcRot("1"), @aPerAberto)
			EndIf
		EndIF //Final da Verificacao de Troca de Filial/Processo
		
		If lInterm
			aConvoc := BuscaConv(dDataIni, dDataFim, .T. )
		EndIf
		
		If lInterm .And. lHEInterm
			If Empty( aPerAberto )
				//'Nao Foi Possivel Evetuar o Calculo para o Funcionario:"###'da Filial: '###'e Turno: '
				SRA->( aAdd(aLogsFunc, STR0013 + " " + RA_MAT + If(lOfuscaNom,'', '-' + alltrim(RA_NOME)) + " " + STR0014 + " " + RA_FILIAL + " " + STR0015 + " " + RA_TNOTRAB ) ) 
				SRA->( aAdd(aLogsFunc, STR0045 ) )//'Não há período de cálculo de folha aberto no período informado nos parâmetros'   
				SRA->( dbSkip() )
				Loop		
			ElseIf Empty(aConvoc) .Or. Empty(aConvoc[1,1])
				//'Nao Foi Possivel Evetuar o Calculo para o Funcionario:"###'da Filial: '###'e Turno: '
				SRA->( aAdd(aLogsFunc, STR0013 + " " + RA_MAT + If(lOfuscaNom,'', '-' + alltrim(RA_NOME)) + " " + STR0014 + " " + RA_FILIAL + " " + STR0015 + " " + RA_TNOTRAB ) ) 
				SRA->( aAdd(aLogsFunc, STR0044 ) )//'O funcionário não possui convocações nas datas informadas nos parâmetros'
				If !Empty( aPerAberto )
					For nPerAb := 1 To Len(aPerAberto)
						aAuxConv2 := BuscaConv(aPerAberto[nPerAb, 5], aPerAberto[nPerAb, 6], .T. )
						For nConvoc := 1 To Len(aAuxConv2)
							If !Empty(aAuxConv2[1,1]) .And. aScan( aAuxConv, { |x| x[1] == aAuxConv2[nConvoc, 1] } ) == 0
								aAdd( aAuxConv, { aAuxConv2[nConvoc, 1], aAuxConv2[nConvoc, 9], aAuxConv2[nConvoc, 8] } )
							EndIf
						Next nConvoc
					Next nPerAb
					If !Empty(aAuxConv)
						SRA->( aAdd( aLogsFunc, STR0055 ) )//'As convocações cadastradas para o período em aberto da folha são: '
						For nConvoc := 1 To Len(aAuxConv)
							SRA->( aAdd( aLogsFunc, STR0048 + aAuxConv[nConvoc, 1] + " | " + STR0049 + dToC(aAuxConv[nConvoc, 2]) + " | " + STR0050 + dToC(aAuxConv[nConvoc, 3]) ) )//"Código: "##"Data de início: "##"Date de término: "
						Next nConvoc
					Else
						SRA->(aAdd( aLogsFunc, STR0056 ))//'O funcionário não possui convocações no período em aberto da folha.'
					EndIf
				EndIf
				SRA->( dbSkip() )
				Loop
			Else
				For nConvoc := 1 To Len(aConvoc)
					If aScan( aPerAberto, { |x| aConvoc[nConvoc, 2] >= x[5] .And. aConvoc[nConvoc, 3] <= x[6] } ) > 0
						lTemPer := .T.
					Else
						aConvoc[nConvoc, 10] := .F.
						aAdd( aAuxConv, nConvoc )
					EndIf
				Next nConvoc
				If !lTemPer
					//'Nao Foi Possivel Evetuar o Calculo para o Funcionario:"###'da Filial: '###'e Turno: '
					SRA->( aAdd( aLogDet , STR0013 + " " + RA_MAT + If(lOfuscaNom,'', '-' + alltrim(RA_NOME)) + " " + STR0014 + " " + RA_FILIAL + " " + STR0015 + " " + RA_TNOTRAB ) ) 
					SRA->( aAdd( aLogDet , STR0046 ) )//'Não há período de cálculo aberto para as convocações do funcionário. Convocações sem período aberto: '
					For nConvoc := 1 To Len(aConvoc)
						SRA->( aAdd( aLogDet , STR0048 + aConvoc[nConvoc, 1] + " | " + STR0049 + dToC(aConvoc[nConvoc, 9]) + " | " + STR0050 + dToC(aConvoc[nConvoc, 8]) ) )//"Código: "##"Data de início: "##"Date de término: "
					Next nConvoc
					SRA->( dbSkip() )
					Loop	
				ElseIf lTemPer .And. !Empty(aAuxConv)
					//'Para o Funcionario:"###'da Filial: '###'e Turno: '
					SRA->( aAdd( aLogDet , STR0051 + " " + RA_MAT + If(lOfuscaNom,'', '-' + alltrim(RA_NOME)) + " " + STR0014 + " " + RA_FILIAL + " " + STR0015 + " " + RA_TNOTRAB ) ) 
					SRA->( aAdd( aLogDet , STR0047 ) )//'Não há período de cálculo aberto para todas as convocações do funcionário. Convocações sem período aberto: '
					For nConvoc := 1 To Len(aAuxConv)
						SRA->( aAdd( aLogDet , STR0048 + aConvoc[aAuxConv[nConvoc], 1] + " | " + STR0049 + dToC(aConvoc[aAuxConv[nConvoc], 9]) + " | " + STR0050 + dToC(aConvoc[nConvoc, 8]) ) )//"Código: "##"Data de início: "##"Date de término: "
					Next nConvoc
					SRA->( aAdd( aLogDet , STR0054 ) )//'Obs.: os resultados compreendidos nessas datas NÃO serão gravados.'
				EndIf
			EndIf
		EndIf
		
		// Carrega a Regra do Cadastro de Funcionarios
		cRegra := SRA->RA_REGRA
		
		// Verifica se a regra de apontamento do funcionário é válida
		IF !( PosSPA( cRegra , cFilSPA , NIL , 1 , .F. ) )
			//'A Regra: '###'Nao Esta Cadastrada no SPA (Cadastro de Regras)'
			SRA->(aAdd(aLogsFunc, STR0011 + " " + cRegra + " " +  STR0012 ) )	
			//'Nao Foi Possivel Evetuar o Calculo para o Funcionario:"###'da Filial: '###'e Turno: '
			SRA->( aAdd(aLogsFunc, STR0013 + " " + RA_MAT + If(lOfuscaNom,'', '-' + alltrim(RA_NOME)) + " " + STR0014 + " " + RA_FILIAL + " " + STR0015 + " " + RA_TNOTRAB ) ) 
			SRA->( dbSkip() )
			Loop
		EndIF
		
		// Carrega as informacoes do SPA
		aSpaInfo := PosSPA( cRegra, cFilSPA, aSpaFields , 1 , .F. )
		
		// Carrega o conteudo do Campo PA_PERANOT
		cPerAnot := aSpaInfo[1]
		
		// Carrega o conteudo do Campo PA_PERATRA
		cPerAtra := aSpaInfo[2]
		
		// Carrega o conteudo do Campo PA_PERSAIA
		cPerSaia := aSpaInfo[3]
		
		// Carrega o conteudo do Campo PA_PERHEXT
		cPerHext := aSpaInfo[4]
		
		// Carrega o conteudo do Campo PA_PERHMOV
		cPerHmov :=	aSpaInfo[5]
		
		// Carrega o conteudo do Campo PA_PERDDSR
		cPerDdsr := aSpaInfo[6]
		
		// Carrega o conteudo do Campo PA_DESCDSR
		cDescDSR := aSpaInfo[7]
		
		// Carrega o conteudo do Campo PA_REFEIT
		cRefeit	 := aSpaInfo[8]
		
		// Carrega o conteudo do campo PA_TOLNOTU
		nTolNotu := aSpaInfo[9]
		
		// Carrega o conteudo do campo PA_TOLATRA
		nTolAtra := aSpaInfo[10]
		
		// Carrega o conteudo do campo PA_TOLSAIA
		nTolSaia  := aSpaInfo[11]
		
		// Carrega o conteudo do campo PA_TOLHEPE
		nTolHePe  := aSpaInfo[12]
		
		// Carrega o conteudo do campo PA_NUMATRA
		nNumAtra  := Val( aSpaInfo[13] )
		
		// Carrega o conteudo do campo PA_HRMOVEL
		cHrMovel  := aSpaInfo[14]
		
		// Carrega o conteudo do campo PA_INMOVEL
		cInMovel  := aSpaInfo[15]
		
		// Se portaria estiver ativa carrega PA_NORMFOL
		If lPort1510
			cNormFol  := AllTrim(aSpaInfo[aScan(aSpaFields, {|x| x == "PA_NORMFOL"})])
		EndIf
		
		If lPgBHSem
			cPgBHSem := aSpaInfo[aScan(aSpaFields, {|x| x == "PA_PGBHSEM"})]
		EndIf
		
		// Carrega o conteúdo do campo PA_DSRAFAS
		If lDSRAFAS
			lDesDSRAfa := AllTrim(aSpaInfo[aScan(aSpaFields, {|x| x == "PA_DSRAFAS"})]) == "1"
		EndIf
		
		// Carrega o conteudo do campo PA_TOLHRNR
		nTolHNR := aSpaInfo[aScan(aSpaFields, {|x| x == "PA_TOLHRNR"})]
		
		// Definição de Eventos que passem de um mês para outro
		IF ( Empty( cEveMesA := IF( cDescDSR == "S" , aEvesIds[ 022 , 02 ] , aEvesIds[ 021 , 02 ] ) ) )
			//'Nao foi possivel Realizar o Calculo Mensal' ###'Verifique se Existem Eventos para os Identificadores 022A e 021N'
			aAdd( aLogDet , STR0002  + " " + STR0018 )
			Break
		EndIF
		
		// Consiste Admissao e Demissao
		If SRA->(( RA_ADMISSA > dPerFim ) .Or. (!Empty( RA_DEMISSA ) .And. (RA_DEMISSA < dPerIni )))
			SRA->( dbSkip() )
			Loop
		EndIf
		
		// Atualiza os Periodos de Apuracao p/Banco de Horas
		nCodAut := Len(aCodAut)
		For nT := 1 To nCodAut
			IF ( aCodAut[nT,2] == "004A" )			// Periodo Apuracao das Horas Noturnas
				aCodAut[nT,5] := cPerAnot
			ElseIF ( aCodAut[nT,2] == "012A" )		// Periodo Apuracao dos Atrasos
				aCodAut[nT,5] := cPerAtra
			Else
				aCodAut[nT,5] := cPerHext			//Periodo Apuracao das Horas Extras
			EndIF
		Next nT
		
		// Cria a Tabela de Horario Padrao do Funcionario
		aTabCalend := {}
		IF SRA->( !CriaCalend(dPerIni,dPerFim,RA_TNOTRAB,RA_SEQTURN,@aTabPadrao,@aTabCalend,RA_FILIAL,RA_MAT,RA_CC ) )
			//'Nao voi possivel Montar o Calendario para o Funcionario: '###'da Filial: '###'e Turno: '###'O Calculo Mensal nao foi efetuado para este funcionario.'
			SRA->( aAdd( aLogsFunc, STR0019 + " " + RA_MAT + If(lOfuscaNom,'','-' + alltrim(RA_NOME))  + " " + STR0014 + RA_FILIAL + " " + STR0015 + " " + RA_TNOTRAB + ". " + STR0020 ) )
			SRA->( dbSkip() )
			Loop
		EndIF
		
		// Reinicializa os Arrays
		aTotais  := {}
		aRFF	 := {}		
		aTotAdiN := {}
		aTotAtra := {}
		aTotSAnt := {}
		aTotHNR  := {}
		aTotPgHD := {}
		aTotHExt := {}
		aTotHENt := {}
		aResult	 := {}
		
		// Obtem os abonos Para o Periodo
		aAbonosPer := {}
		fAbonosPer( @aAbonosPer , dPerIni , dPerFim , cLastFil , SRA->RA_MAT )
		
		// Se nao for DSR proporcional Carrega as Tabelas de Arredondamento
		IF !( lDsrProp )
			cFilSPD	 := cLastFil
			aArred_D := GetTabArred( @cFilSPD , SRA->RA_TNOTRAB , "D" )
			aArred_D := RetTabArred( aArred_D , cFilSPD , SRA->RA_TNOTRAB , "D" )
		EndIF
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Gerar o Desconto do D.S.R. (017N/018A) baseado no   Arredonda³
		³mento de DSR ou Gerar o Desconto do DSR Limitados ao Total do³
		³DSR (1 Dia)												  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF (( lDsrProp ) .Or. !Empty( aArred_D ))
			
			If lCheckDSR
				//Exclui eventos de atraso período anterior gerados por cálculos parciais
				fDSRAnt(aCodigos, cDescDSR, dPerIni, dPerFim)
			EndIf
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Carrega os Resultados Anteriores para a Apuracao e Geracao  do³
			³desconto do DSR. Quando Tiver codigo/quantidade informada  con³
			³siderar o codigo/quanditade Informada para a apuracao do   Des³
			³conto do DSR. O 5o. Parametro da GetLastApo() eh que ira  efeu³
			³ar o Tratamento (Troca) dos dados referente ao apontado   pelo³
			³informado.													   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			aResult := GetLastApo( dPerIni, dPerFim, NIL, NIL, .T. )
			
			// Efetua o Cálculo e a Geração do Desconto do DSR
			fDescDsr(@aResult,aTabCalend,aCodigos,aArred_D,cPerDdsr,dPerIni,dPerFim,@aTotais,lDsrProp,lLimDSR,lDsrPPer,aAbonosPer,cDescDSR,nNumAtra, lMvDDSRFer, lArredTno)
		EndIF	
		
		// Ponto de Entrada
		IF ( lPoncalmBlock )
			ExecBlock("PONCALM" , .F., .F.)
		EndIF
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se nao for Top Posiciona no Funcionario, Caso contrario monta³
		³ Query														   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Quando a Expressao da Query nao estiver definida monta-a     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF Empty( cSPCQuery )
			cAliasQSPC	:= ( "__Q" + cAliasSPC + "QRY" )
			cSPCQuery	:= "SELECT "
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carregando os Campos do SPC na Query						   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			For nX := 1 To nSpcFields
				cSPCQuery += aSpcFields[ nX , 01 ] + ", "
			Next nX
			cSPCQuery := SubStr( cSPCQuery , 1 , Len( cSPCQuery ) - 2 ) 
			cSPCQuery += ", R_E_C_N_O_ AS RECNO"
			cSPCQuery += " FROM " + InitSqlName( cAliasSPC ) + " " + cAliasSPC + " "
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Montando a Condicao										   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cSPCQuery += "WHERE "
			cSPCQuery += cAliasSPC + "."
			cSPCQuery += "PC_FILIAL='"+cLastFil+"'"
			cSPCQuery += " AND "				
			cSPCQuery += cAliasSPC + "."
			cSPCQuery += "PC_MAT='"+SRA->RA_MAT+"'"
			cSPCQuery += " AND "
			cSPCQuery += " ( "
			cSPCQuery += cAliasSPC + "."
			cSPCQuery += "PC_DATA>='"+cIniData+"'"
			cSPCQuery += " AND "
			cSPCQuery += cAliasSPC + "."
			cSPCQuery += "PC_DATA<='"+cFimData+"'"
			cSPCQuery += " ) AND "
			cSPCQuery += cAliasSPC + ".D_E_L_E_T_=' ' "
			cSPCQuery += "ORDER BY " + SqlOrder( (cAliasSPC)->( IndexKey() ) )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Guarda os Valores Anteriores                                 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cSPCSvQuery	:= cSPCQuery
		Else
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Caso contrario, apenas substitui os valores                  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cSPCQuery	:= StrTran( cSPCSvQuery	, ( "PC_FILIAL='"+cSvFil+"'"	) , ( "PC_FILIAL='"+cLastFil+"'"	) )
			cSPCQuery	:= StrTran( cSPCQuery	, ( "PC_MAT='"+cSvMat+"'"		) , ( "PC_MAT='"+SRA->RA_MAT+"'"	) )
			cSPCQuery	:= StrTran( cSPCQuery	, ( "PC_DATA>='"+cSvIniData+"'" ) , ( "PC_DATA>='"+cIniData+"'"		) )
			cSPCQuery	:= StrTran( cSPCQuery	, ( "PC_DATA<='"+cSvFimData+"'" ) , ( "PC_DATA<='"+cFimData+"'"		) )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Guarda os Valores Anteriores                                 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cSPCSvQuery	:= cSPCQuery
		EndIF
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Utiliza ChangeQuery() para Remontar a Query                  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cSPCQuery := ChangeQuery( cSPCQuery )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se conseguiu Montar a Query Seta os Campos                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cSPCQuery),cAliasQSPC,.T.,.T.) )
			For nX := 1 To nSpcFields
				IF !( aSpcFields[ nX , 02 ] == "C" )
					TcSetField(cAliasQSPC,aSpcFields[nX,01],aSpcFields[nX,02],aSpcFields[nX,03],aSpcFields[nX,04])
				EndIF
			Next nX
		Else
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Caso contrario Utiliza o processo Padrao                     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cAliasQSPC	:= cAliasSPC
			( cAliasQSPC )->( dbSeek( cFilSPC + SRA->RA_MAT  , .F. ) )
		EndIF
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Percorre o SPC Carrega Todos os Eventos do Periodo           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		While ( ( cAliasQSPC )->( !Eof() .and. ( cFilSPC + SRA->RA_MAT ) == ( PC_FILIAL + PC_MAT ) ) )
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Aborta o processamento                                       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( lAbortPrint )
				//'O Calculo Mensal Foi Cancelado Pelo Usuario'
				aAdd( aLogDet , STR0010 )
				Break
			EndIF
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Limita a Leitura somente dos Apontamentos do periodo.		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( cAliasQSPC )->( ( PC_DATA < dPerIni ) .or. ( PC_DATA > dPerFim ) )
				( cAliasQSPC )->( dbSkip() )
				Loop
			EndIF
            
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Existe codigo Informado               		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			lExistInfo	:= !Empty(( cAliasQSPC )->PC_PDI)
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega o Codigo do Evento e a Quantidade de Horas		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cEvento	:= ( cAliasQSPC )->( IF( lExistInfo , PC_PDI		, PC_PD     ) )
			nHoras	:= ( cAliasQSPC )->( IF( lExistInfo , PC_QUANTI    , PC_QUANTC ) )
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se portaria estiver ativa, verifica se deve enviar eventos para a folha ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If lPort1510 .and. cNormFol == '2'
				IF (;					
						( cEvento $ aEvesIds[ 031 , 02 ] ); //Intervalo Normal Noturno
						.or.;
						( cEvento $ aEvesIds[ 030 , 02 ] ); //Horas Trabalhadas Intervalo
						.or.;
						( cEvento $ aEvesIds[ 026 , 02 ] ); //Horas Normais Noturnas
						.or.;
						( ( cEvento $ aEvesIds[ 001 , 02 ] )); //Horas Normais
						.or.;
						( cEvento $ aEvesIds[ 005 , 02 ] ); //Horas Normais Não Realizadas
						.or.;
						( cEvento $ aEvesIds[ 006 , 02 ] ); //Horas Noturnas Não Realizadas
					) 
						
						( cAliasQSPC )->(;
											 fGerRFF(	@aRFF	 		,;	//01 -> Array com os Totais do Ponto
														PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
														cEvento			,;	//03 -> Evento do Ponto para Pesquisa
														cEvento			,;	//04 -> Codigo do Evento de Origem da Informacao
														nHoras			,;	//05 -> Horas Originais    
														0				,;  //06 -> Quantidade horas Abonadas
														/*nBanco*/		,;  //07 -> Quantidade horas Banco de Horas
														PC_CC			,;	//08 -> Centro de Custo para Comparacao
														cPerApo			,;  //09 -> Periodo para Gravacao
														/*cTipoHE	*/	,;  //10 -> Tipo de Hora Extra   
												   		/*nPercent	*/	,; 	//11 -> Percentual de Valorizacao		
														/*lSubstitui*/	;	//12 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
													  );
										)	
														
					( cAliasQSPC )->( dbSkip() )
					Loop
				EndIF
			EndIf
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Quando as Horas Foram Calculadas Pela Tabela so considera  os³
			³ Eventos de Horas Nao Realizadas Quando o Tipo da Verba na  Fo³
			³ lha de Pagamento (GPE) for de Base						   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF (;
					( lHorasTab );
					.and.;
					( cAliasQSPC )->(;
										( PC_PD $ aEvesIds[ 005 , 02 ] );
										.or.;
										( PC_PD $ aEvesIds[ 006 , 02 ] );
									);	
				)	
				IF ( ( cAliasQSPC )->PC_PD  $ aEvesIds[ 005 , 02 ] )
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Posiciona no SP9 para obter o Codigo para a Folha			   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF PosSP9( aEvesIds[ 005 , 02 ] , cLastFil , NIL , 1 , .F. )
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Posiciona no SRV e Verifica se o Evento e de Base			   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						IF !( PosSrv( aEvesIds[ 005 , 02 ] , cLastFil , "RV_TIPOCOD" ) == "3" )
							( cAliasQSPC )->( dbSkip() )
							Loop
						EndIF
					EndIF	
				ElseIF ( ( cAliasQSPC )->PC_PD  $ aEvesIds[ 006 , 02 ] )
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Posiciona no SP9 para obter o Codigo para a Folha			   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF PosSP9( aEvesIds[ 006 , 02 ] , cLastFil , NIL , 1 , .F. )
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Posiciona no SRV e Verifica se o Evento e de Base			   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						IF !( PosSrv( aEvesIds[ 006 , 02 ] , cLastFil , "RV_TIPOCOD" ) == "3" )
							( cAliasQSPC )->( dbSkip() )
							Loop
						EndIF
					EndIF	
				EndIF
			EndIF
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Se Nenhum Codigo foi Informado e Se Existirem Abonos		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF !( lExistInfo )
				aAbonos	:=	{}
				( cAliasQSPC )->( fAbonos( PC_DATA , PC_PD , NIL , @aAbonos , PC_TPMARCA , PC_CC , aAbonosPer ) )
				nLenAbo		:= Len( aAbonos ) 
				nHorasAb	:= 0 
				cEvBhAP		:= ( cAliasQSPC )->( PosSP9( PC_PD , cFilSP9 , "P9_BHORAS" , 1 , .F. ) )
				
				// Percorre todos os Abonos para a Data/Evento
				For nW := 1 To nLenAbo
					
					// Carrega as Informacoes do SP6
					aSp6Info := PosSP6( aAbonos[ nW , AABONOS_CODIGO ] , cFilSP6 , aSp6Fields , 1 , .F. )
					
					// Obtem o Evento Relacionado ao Abono
					cEveAbono	:= aSp6Info[1]
					
					// Obtem a Hora Abonada
					nHrAbon := Min(aAbonos[nW, AABONOS_HORAS_ABO], nHoras)
					
					// Verifica se o Motivo de Abono Abona Horas
					IF ( aSp6Info[2] == "S" )
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Adiciona o Abono no Array									   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						IF !Empty( cEveAbono )
							( cAliasQSPC )->(;
												fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
															PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
															nHrAbon			,;	//03 -> Horas para Soma ou Geracao
															0				,;	//04 -> Valor para Soma ou Geracao
															cEveAbono		,;	//05 -> Evento do Ponto para Pesquisa
															PC_CC			,;	//06 -> Centro de Custo para Comparacao
															cLastFil		,;	//07 -> Filial para Pesquisa no SP9 
															NIL				,;	//08 -> Verba da Folha
															/*lSubstitui*/ 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
															/*cFuncao	*/	,;  //10 -> Funcao  
										  					/*cDepto	*/	,;  //11 -> Depto para gravacao
															/*cPosto	*/	,;  //12 -> Posto para gravacao
															/*cProcesso	*/	,;  //13 -> Periodo para Gravacao
															/*cRoteiro	*/	,;  //14 -> Processo para Gravacao
															/*cPerApo	*/	,;  //15 -> Periodo para Gravacao
															/*cNumPagto	*/ 	,;  //16 -> NumPagto para Gravacao
															/*cTurno 	*/	,;  //17 -> Turno de Trabalho
															/*cSemana	*/	,;  //18 -> Semana/Sequencia do Turno
											   				If( cPaisLoc=="BRA",PC_TIPOHE,Nil),;	  //19 -> Tipo de Hora Extra
															If( cPaisLoc=="BRA",PC_PERCENT,Nil)	; //20 -> Percentual de valorizacao
														 ); 
											)
							
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³          Verifica a existencia de contador de eventos e registra o  numero de ocorrencias.		  ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						    fContaEvento(nHrAbon, @aEveCont, cEveAbono, @aTotais, dPerIni, dPerFim, aTabCalend, cLastFil, cAliasQSPC)

							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Se o parametro MV_DEDABBH existir ou estiver setado p/ "Sim" e|
							³Se o Evento do Abono for para Banco de Horas, deduz as   Horas³
							³de Abono das Horas Apontadas para que soh a diferenca seja  en³
							³viada para apuracao das Horas que irao para a Folha.          ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							aSp9Info:= PosSP9( cEveAbono , cFilSP9 , aSp9Fields , 1 , .F. ) 
							cEvBhAB:= aSp9Info[1]
							If lMvDedAbBH
								/*
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³Se o parametro MV_FolVBh estiver setado p/ "Sim" e se o desti-|
								³no das horas apontadas e o destino das horas abonadas com     ³
								³evento associado são diferentes, deduz-se das horas apontadas ³
								³as horas abonadas. 									       ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
								If lMvFolVBH
									IF cEvBhAP <> cEvBhAB
										nHoras := __TimeSub( nHoras , nHrAbon )
									ElseIf lPort1510
										( cAliasQSPC )->(;
															fGerRFF(	@aRFF	 		,;	//01 -> Array com os Totais do Ponto
																		PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
																		cEveAbono		,;	//03 -> Evento do Ponto para Pesquisa
																		cEvento			,;	//04 -> Codigo do Evento de Origem da Informacao
																		0				,;	//05 -> Horas Originais    
															IF(cEvBhAB=="S",0,nHrAbon) ,;  //06 -> Quantidade horas Abonadas
															IF(cEvBhAB=="S",nHrAbon,0)	,;  //07 -> Quantidade horas Banco de Horas
																		PC_CC			,;	//08 -> Centro de Custo para Comparacao
																		cPerApo			,;  //09 -> Periodo para Gravacao
																		/*cTipoHE	*/	,;  //10 -> Tipo de Hora Extra   
																   		/*nPercent	*/	,; 	//11 -> Percentual de Valorizacao		
																		/*lSubstitui*/	,;	//12 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
																					"2"	;	//13 -> Sinal da quantidade horas
																   );
														)			  							
									EndIF
								Else
									IF ( cEvBhAB == "S" )
										nHoras := __TimeSub( nHoras , nHrAbon )
									Else
										If lPort1510
											( cAliasQSPC )->(;
															fGerRFF(	@aRFF	 		,;	//01 -> Array com os Totais do Ponto
																		PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
																		cEveAbono		,;	//03 -> Evento do Ponto para Pesquisa
																		cEvento			,;	//04 -> Codigo do Evento de Origem da Informacao
																		0				,;	//05 -> Horas Originais    
																		nHrAbon			,;  //06 -> Quantidade horas Abonadas
																		0				,;  //07 -> Quantidade horas Banco de Horas
																		PC_CC			,;	//08 -> Centro de Custo para Comparacao
																		cPerApo			,;  //09 -> Periodo para Gravacao
																		/*cTipoHE	*/	,;  //10 -> Tipo de Hora Extra   
																   		/*nPercent	*/	,; 	//11 -> Percentual de Valorizacao		
																		/*lSubstitui*/	,;	//12 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
																					"2"	;	//13 -> Sinal da quantidade horas
																   );																
																)
										Endif						
									EndIF
								Endif		
							Else
									If lPort1510
										( cAliasQSPC )->(;
														fGerRFF(	@aRFF	 		,;	//01 -> Array com os Totais do Ponto
																	PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
																	cEveAbono		,;	//03 -> Evento do Ponto para Pesquisa
																	cEvento			,;	//04 -> Codigo do Evento de Origem da Informacao
																	0				,;	//05 -> Horas Originais    
														IF(cEvBhAB=="S",0,nHrAbon) ,;  //06 -> Quantidade horas Abonadas
														IF(cEvBhAB=="S",nHrAbon,0)	,;  //07 -> Quantidade horas Banco de Horas
																	PC_CC			,;	//08 -> Centro de Custo para Comparacao
																	cPerApo			,;  //09 -> Periodo para Gravacao
																	/*cTipoHE	*/	,;  //10 -> Tipo de Hora Extra   
																   	/*nPercent	*/	,; 	//11 -> Percentual de Valorizacao		
																	/*lSubstitui*/	,;	//12 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
																				"2"	;	//13 -> Sinal da quantidade horas
																   );																
																)
            						Endif
							Endif	
						Else           
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Se nao Tiver Evento relacionado ao Motivo de Abono acumula  as³
							³Horas Abonadas que serao posteriormente deduzidas das Horas  A³
							³pontadas													   ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							nHorasAb := __TimeSum(nHorasAb, nHrAbon)
						EndIF
					Else
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Se Motivo de Abono Nao Abona Horas e o Codigo do Evento Relaci³
						³onado ao Abono nao Estiver Vazio, Eh como se fosse uma  altera³
						³racao do Codigo de Evento. Ou seja, Vai para os Totais      as³
						³Horas do Abono que serao subtraidas das Horas Calculadas (  Po³
						³deriamos Chamar esta operacao de "Informados via Abono" ).	   ³
						³Para que esse processo seja feito o Parametro MV_SUBABAP  deve³
						³ra ter o Conteudo igual a "S"								   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						IF ( ( lMvSubAbAp ) .and. !Empty( cEveAbono ) )
							( cAliasQSPC )->(;
												fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
															PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
															nHrAbon			,;	//03 -> Horas para Soma ou Geracao
															0				,;	//04 -> Valor para Soma ou Geracao
															cEveAbono		,;	//05 -> Evento do Ponto para Pesquisa
															PC_CC			,;	//06 -> Centro de Custo para Comparacao
															cLastFil		,;	//07 -> Filial para Pesquisa no SP9 
															NIL				,;	//08 -> Verba da Folha
															/*lSubstitui*/ 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
															/*cFuncao	*/	,;  //10 -> Funcao  
										  					/*cDepto	*/	,;  //11 -> Depto para gravacao
															/*cPosto	*/	,;  //12 -> Posto para gravacao
															/*cProcesso	*/	,;  //13 -> Periodo para Gravacao
															/*cRoteiro	*/	,;  //14 -> Processo para Gravacao
															/*cPerApo	*/	,;  //15 -> Periodo para Gravacao
															/*cNumPagto	*/ 	,;  //16 -> NumPagto para Gravacao
															/*cTurno 	*/	,;  //17 -> Turno de Trabalho
															/*cSemana	*/	,;  //18 -> Semana/Sequencia do Turno
															If( cPaisLoc=="BRA",PC_TIPOHE,Nil),;	  //19 -> Tipo de Hora Extra
															If( cPaisLoc=="BRA",PC_PERCENT,Nil)	; //20 -> Percentual de valorizacao
														 ); 
											)
											
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³          Verifica a existencia de contador de eventos e registra o  numero de ocorrencias.		  ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						    fContaEvento(nHrAbon, @aEveCont,cEveAbono, @aTotais, dPerIni, dPerFim, aTabCalend, cLastFil, cAliasQSPC)
																	
							nHoras := __TimeSub( nHoras , nHrAbon )
						EndIF
		 			EndIF
		 		Next nW 
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Deduz Horas de Abono das Horas Apontadas. Somente valido   qdo³
				³solicitado que no Cadastro do Motivo de Abonos  MV_ABOSEVE )  ³
				³aceite abono de horas sem a especificacao do codigo de  evento³
				³associado (para compatibilizar com a v.609, onde podia-se dedu³
				³zir os abonos diretamente da verba). Desse modo, as horas  nao³
				³serao a soma das horas de faltas/atrasos/saidas.			   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		 		IF ( ( lMvAbosEve ) .and. ( nHoras > 0 ) )
			 		nHoras := __TimeSub( nHoras , nHorasAb )
			 	EndIF
		 	EndIF
			
			//-- Define o Nome do Array a ser utilizado
			cNomeArray := ""
			IF ( aScan( aCodAut, {|x| x[1] == cEvento .and.x[2] == "004A" } ) > 0 )
				cNomeArray := "aTotAdiN"
			ElseIF ( aScan( aCodAut, {|x| x[1] == cEvento .and.x[2] == "012A" } ) > 0 )
				cNomeArray := "aTotAtra"
			ElseIF ( aScan( aCodAut, {|x| x[1] == cEvento .and.x[2] == "014A" } ) > 0 )
				cNomeArray := "aTotSAnt"
			ElseIF ( aScan( aCodAut, {|x| x[1] == cEvento .and.x[2] $ "001Aú002A|026A" } ) > 0 )
				cNomeArray := "aTotPgHD"
			ElseIF ( aScan( aCodAut, {|x| x[1] == cEvento .and.x[2] == "HEDA" } ) > 0 )
				cNomeArray := "aTotHExt"
			ElseIF ( aScan( aCodAut, {|x| x[1] == cEvento .and.x[2] == "HENA" } ) > 0 )
				cNomeArray := "aTotHENt"
			ElseIF ( aScan( aCodAut, {|x| x[1] == cEvento } ) > 0 )
				cNomeArray := "aTotais"
			EndIF
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³          Verifica a existencia de contador de eventos e registra o  numero de ocorrencias.		  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			fContaEvento(nHoras, @aEveCont, cEvento, @aTotais, dPerIni, dPerFim, aTabCalend, cLastFil, cAliasQSPC)
			
			//-- Adiciona os Eventos no Array
			IF ( cNomeArray == "aTotais" )
				( cAliasQSPC )->(;
									fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
												PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												nHoras			,;	//03 -> Horas para Soma ou Geracao
												0				,;	//04 -> Valor para Soma ou Geracao
												cEvento			,;	//05 -> Evento do Ponto para Pesquisa
												PC_CC			,;	//06 -> Centro de Custo para Comparacao
												cLastFil		,;	//07 -> Filial para Pesquisa no SP9
												NIL				,;	//08 -> Verba da Folha
												/*lSubstitui*/ 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
												/*cFuncao	*/	,;  //10 -> Funcao  
												/*cDepto	*/	,;  //11 -> Depto para gravacao
												/*cPosto	*/	,;  //12 -> Posto para gravacao
												/*cProcesso	*/	,;  //13 -> Periodo para Gravacao
												/*cRoteiro	*/	,;  //14 -> Processo para Gravacao
												/*cPerApo	*/	,;  //15 -> Periodo para Gravacao
												/*cNumPagto	*/ 	,;  //16 -> NumPagto para Gravacao
												/*cTurno 	*/	,;  //17 -> Turno de Trabalho
												/*cSemana	*/	,;  //18 -> Semana/Sequencia do Turno
												If( cPaisLoc=="BRA",PC_TIPOHE,Nil),;	  //19 -> Tipo de Hora Extra
												If( cPaisLoc=="BRA",PC_PERCENT,Nil)	; //20 -> Percentual de valorizacao
											); 
								) 
				
			ElseIF !Empty(cNomeArray)
				( cAliasQSPC )->(;
									fGeraTot(	&(cNomeArray)	,;	//01 -> Array com os Totais do Ponto
												PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												nHoras			,;	//03 -> Horas para Soma ou Geracao
												0				,;	//04 -> Valor para Soma ou Geracao
												cEvento			,;	//05 -> Evento do Ponto para Pesquisa
												PC_CC			,;	//06 -> Centro de Custo para Comparacao
												cLastFil		,;	//07 -> Filial para Pesquisa no SP9
												NIL				,;	//08 -> Verba da Folha
												/*lSubstitui*/ 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
												/*cFuncao	*/	,;  //10 -> Funcao  
												/*cDepto	*/	,;  //11 -> Depto para gravacao
												/*cPosto	*/	,;  //12 -> Posto para gravacao
												/*cProcesso	*/	,;  //13 -> Periodo para Gravacao
												/*cRoteiro	*/	,;  //14 -> Processo para Gravacao
												/*cPerApo	*/	,;  //15 -> Periodo para Gravacao
												/*cNumPagto	*/ 	,;  //16 -> NumPagto para Gravacao
												/*cTurno 	*/	,;  //17 -> Turno de Trabalho
												/*cSemana	*/	,;  //18 -> Semana/Sequencia do Turno
												If( cPaisLoc=="BRA",PC_TIPOHE,Nil),;		//19 -> Tipo de Hora Extra
												If( cPaisLoc=="BRA",PC_PERCENT,Nil),; 		//20 -> Percentual de valorizacao
												If( lCpoCCT,PC_FILCCT,Nil),;				//21 -> Filial CCT
												If( lCpoCCT,PC_CODCCT,Nil); 				//22 -> Código CCT
											); 
								) 
				
			EndIF
			
			( cAliasQSPC )->( dbSkip() ) //-- Pr¢ximo Evento
			
		EndDo
		
		// Fecha a Query do SPC
		If lQueryOpened
			( cAliasQSPC )->( dbCloseArea() )
			dbSelectArea("SRA")
		EndIF
		
		// Adicional Noturno
		fCalcPer( aTotAdiN,  @aTotais, "AdiN", cPerAnot, nTolNotu )
		
		If cPerAtra == cPerSaia .And. !Empty(nTolHNR)
			aTotHNR := aClone(aTotAtra)
			aEval(aTotSAnt, {|x| Aadd(aTotHNR, x)})
			fCalcPer( aTotHNR, @aTotais, "HRNR", cPerAtra, nTolHNR )
		Else
			// Atrasos
			fCalcPer( aTotAtra, @aTotais, "Atra", cPerAtra, nTolAtra )
			
			// Saída antecipada
			fCalcPer( aTotSAnt, @aTotais, "SANT", cPerSaia, nTolSaia )
		EndIf
		
		// Horas Extras \\
		
		// Convenção Coletiva de trabalho
		aCCTs := GetCCTs(aTotHExt, aTotHENt)
		lFiltraCCT := Len(aCCTs) > 1
		
		// Adiciona o período de apuração e a tolerância cadastrados no tipo de HE
		If lCpoPer
			AadHEPer(@aTotHExt)
			AadHEPer(@aTotHENt)
		EndIf
		
		For nI := 1 To Len(aCCTs)
			// Garante que a tabela de HE seja carregada com base na CCT
			RstGetTabExtra()
			
			cFilCCT := aCCTs[nI, 1]
			cCodCCT := aCCTs[nI, 2]
			
			// Filtra os eventos de HE do período pela CCT
			If lFiltraCCT
				FiltraCCT(aTotHExt, aTotHENt, cFilCCT, cCodCCT, @aHExtAux, @aHENtAux)
			Else
				aHExtAux := aTotHExt
				aHENtAux := aTotHENt
			EndIf
			
			// Agrupa as HE por período de apuração
			If lCpoPer
				aHePorPer := FilHEPer(aHExtAux, aHENtAux)
				
				For nX := 1 To Len(aHePorPer)
					If !fCalcHExt( dPerIni, dPerFim, aHePorPer[nX][3], aHePorPer[nX][4], @aTotais, aTabCalend, aCodAut, lMvAcmHExt, If(Empty(aHePorPer[nX][1]), cPerHext, aHePorPer[nX][1]), If(Empty(aHePorPer[nX][1]), nTolHePe, aHePorPer[nX][2]), @cMsgErr, cFilCCT, cCodCCT)
						//'O Calculo Mensal nao sera efetuado.'###'Nao foi Possivel Carregar os Tipos de Horas Extras.'
						aAdd( aLogDet , STR0022 + " " + STR0021 )
						IF !Empty( cMsgErr )
							aAdd( aLogDet , cMsgErr )
						EndIF
						Break
					EndIf
				Next
				
			Else
				If !fCalcHExt( dPerIni, dPerFim, aHExtAux, aHENtAux, @aTotais, aTabCalend, aCodAut, lMvAcmHExt, cPerHext, nTolHePe, @cMsgErr, cFilCCT, cCodCCT)
					//'O Calculo Mensal nao sera efetuado.'###'Nao foi Possivel Carregar os Tipos de Horas Extras.'
					aAdd( aLogDet , STR0022 + " " + STR0021 )
					IF !Empty( cMsgErr )
						aAdd( aLogDet , cMsgErr )
					EndIF
					Break
				EndIF
			EndIf
		Next nI
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Horas / DSR												  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !fCalcPHD( aTotPgHD,  @aTotais, aTabPadrao , aTabCalend , lHorasTab , lMvAcmHExt , cPerHmov , @cMsgErr )
			//'O Calculo Mensal nao sera efetuado.'###'Nao foi Possivel Carregar os Tipos de Horas Extras.'
			aAdd( aLogDet , STR0022 + " " + STR0021 )
			IF !Empty( cMsgErr )
				aAdd( aLogDet , cMsgErr )
			EndIF
			Break
		EndIF
		
		// Transfere os Eventos para Banco de Horas
		aBHAcum  := {}
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ponto de Entrada para tratamento de eventos antes do BH.     ³
		³ Permite a redefinicao de verbas em funcao de limites persona-³
		³ lizados para cada verba e que difere dos criterios disponi-  ³
		³ lizados no cadastro de eventos para o calculo do BH.		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lPnm07001Block )
			IF ( ValType( aRetBlock := ExecBlock("PNM07001",.F.,.F.,{aClone(aTotais), aClone(aBHAcum)}) ) == "A" )
			   aTotais		:= If( ValType(aRetBlock[1]) == "A", aRetBlock[1] , aTotais	)
			   aBHAcum		:= If( ValType(aRetBlock[2]) == "A", aRetBlock[2] , aBHAcum	)
			EndIF
		EndIF
		
		fCalcBH(@aTotais, @aBHAcum, lInterm)
		
		// Aborta o processamento
		IF ( lAbortPrint )
			//'O Calculo Mensal Foi Cancelado Pelo Usuario'
			aAdd( aLogDet , STR0010 )
			Break
		EndIF
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se nao for Top Posiciona no Funcionario, Caso contrario monta³
		³ Query														   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Quando a Expressao da Query nao estiver definida monta-a     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF Empty( cSPIQuery )
			cAliasQSPI	:= ( "__Q" + cAliasSPI + "QRY" )
			cSPIQuery := "SELECT "
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carregando os Campos do SPC na Query						   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			For nX := 1 To nSpiFields
				cSPIQuery += aSpiFields[ nX , 01 ] + ", "
			Next nX
			cSPIQuery += "R_E_C_N_O_ RECNO "
			cSPIQuery += " FROM " + InitSqlName( cAliasSPI ) + " " + cAliasSPI
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Montando a Condicao										   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cSPIQuery += " WHERE "
			cSPIQuery += cAliasSPI + "."
			cSPIQuery += "PI_FILIAL='"+cLastFil+"'"
			cSPIQuery += " AND "
			cSPIQuery += cAliasSPI + "."
			cSPIQuery += "PI_MAT='"+SRA->RA_MAT+"'"
			cSPIQuery += " AND "
			cSPIQuery += " ( "
			cSPIQuery += 		cAliasSPI + "."
			cSPIQuery += 		"PI_DATA>='"+cIniData+"'"
			cSPIQuery += 		" AND "
			cSPIQuery += 		cAliasSPI + "."
			cSPIQuery += 		"PI_DATA<='"+cFimData+"'"
			cSPIQuery += " )"
			cSPIQuery += " AND "
			cSPIQuery += cAliasSPI + ".D_E_L_E_T_=' ' "
			cSPIQuery += "ORDER BY " + SqlOrder( (cAliasSPI)->( IndexKey() ) )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Guarda os Valores Anteriores                                 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cSPISvQuery	:= cSPIQuery
		Else
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Caso contrario, apenas substitui os valores                  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cSPIQuery	:= StrTran( cSPISvQuery , ( "PI_FILIAL='"+cSvFil+"'"	) , ( "PI_FILIAL='"+cLastFil+"'"	) )
			cSPIQuery	:= StrTran( cSPIQuery   , ( "PI_MAT='"+cSvMat+"'"		) , ( "PI_MAT='"+SRA->RA_MAT+"'"	) )
			cSPIQuery	:= StrTran( cSPIQuery	, ( "PI_DATA>='"+cSvIniData+"'" ) , ( "PI_DATA>='"+cIniData+"'"		) )
			cSPIQuery	:= StrTran( cSPIQuery	, ( "PI_DATA<='"+cSvFimData+"'" ) , ( "PI_DATA<='"+cFimData+"'"		) )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Guarda os Valores Anteriores                                 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cSPISvQuery	:= cSPIQuery
		EndIF
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Utiliza ChangeQuery() para Remontar a Query                  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cSPIQuery := ChangeQuery( cSPIQuery )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se conseguiu Montar a Query Seta os Campos                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cSPIQuery),cAliasQSPI,.T.,.T.) )
			For nX := 1 To nSpiFields
				IF !( aSpiFields[ nX , 02 ] == "C" )
					TcSetField(cAliasQSPI,aSpiFields[nX,01],aSpiFields[nX,02],aSpiFields[nX,03],aSpiFields[nX,04])
				EndIF
			Next nX
		Else
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Caso contrario Utiliza o processo Padrao                     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cAliasQSPI	:= cAliasSPI
			( cAliasQSPI )->( dbSeek( cFilSPI + SRA->RA_MAT  , .F. ) )
		EndIF
		
		// Carrega Informações Anteriores da SPI
		aSPI:={}
		While ( ( cAliasQSPI )->( !Eof() .and.cFilSPI + SRA->RA_MAT == PI_FILIAL + PI_MAT ) )
			IF ( cAliasQSPI )->( ( PI_DATA >= dPerIni ) .and. ( PI_DATA <= dPerFim ) )
				aAdd( aSPI , Array( 07 ) )
				nLenSPI := Len( aSPI )
				aSPI[ nLenSPI , 01 ] := ( cAliasQSPI )->( PI_DATA 	)
				aSPI[ nLenSPI , 02 ] := ( cAliasQSPI )->( PI_PD   	)
				aSPI[ nLenSPI , 03 ] := ( cAliasQSPI )->( PI_QUANT	)
				aSPI[ nLenSPI , 04 ] := ( cAliasQSPI )->( PI_QUANTV )
				IF !( lQueryOpened  )
					aSPI[ nLenSPI , 05 ] := ( cAliasQSPI )->( Recno() )
				Else
					aSPI[ nLenSPI , 05 ] := ( cAliasQSPI )->( RECNO )
				EndIF	
				aSPI[ nLenSPI , 06 ] := ( cAliasQSPI )->( PI_CC		)
				aSPI[ nLenSPI , 07 ] := 0
			EndIF
			( cAliasQSPI )->( dbSkip() )
		EndDo
		
		//Se apura Banco de Horas semanalmente, conforme artigo 58 da reforma trabalhista, busca BH da semana anterior para efetuar as compensações
		If cPgBHSem == "1"
			aSort( aBHAcum ,,, { |x,y| x[1] < y[1] } )
			aTotBHAux 	:= {}
			nBHAux 		:= 0
			nBHSem		:= 0
			DbSelectArea("SPI")
			DbSetOrder(2) //PI_FILIAL+PI_MAT+Dtos(PI_DATA)+PI_PD
			fCarSemAnt(dPerIni,dPerFim,@dDtAuxIni,@dDtAuxFim,@dDtIniUSem)
			If SPI->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + DtoS(dDtAuxIni)))
				While SPI->(!Eof() .and. PI_FILIAL + PI_MAT == SRA->RA_FILIAL + SRA->RA_MAT)
					If SPI->PI_DATA >= StoD(cIniData)
						Exit
					EndIf
					If SPI->PI_STATUS == "B" .and. SPI->PI_TPBAIXA <> "A" //Se esta baixado e não foi pela rotina de cálculo, despreza.
						Loop
					EndIf
					If PosSP9( SPI->PI_PD , SRA->RA_FILIAL, "P9_TIPOCOD") == "2" //Desconto
						nBHSem -= SPI->PI_QUANT
					Else
						nBHSem += SPI->PI_QUANT
					EndIf
					RecLock("SPI", .F.)
					SPI->PI_STATUS := "B" //Altera status para baixado, pois valor será pago ou zerado
					SPI->PI_TPBAIXA := "A" //Indica que foi baixado automaticamente, pela rotina de calculo.
					SPI->PI_DTBAIX := dDataBase
					MsUnLock()
					SPI->(DbSkip())
				EndDo
			EndIf
			
			//Apura o Banco de Horas semana a semana para verificar o saldo
			dDtAuxIni  := dDtAuxFim + 1
			dDtAuxFim  := dDtAuxFim + 7
			dDtFimProx := dDtAuxFim + 7
			nBHAux 	   := 0
			lAtuBH	   := nBHSem <> 0
			
			If lAtuBH
				For nX := 1 to Len(aBHAcum)
					If aBHAcum[nx, 1] >= dDtAuxIni .and. aBHAcum[nx, 1] <= dDtAuxFim
						If PosSP9( aBHAcum[nX, 2] , SRA->RA_FILIAL, "P9_TIPOCOD") == "2" //Desconto
							If nBHSem > 0
								nBHSem -= aBHAcum[nX,3]
								If nBHSem < 0
									nBHAux := nBHSem
									aBHAcum[nX, 3] := nBHAux * (-1)
									nBHSem := 0
									Exit
								Else
									aBHAcum[nX, 3] := 0
								EndIf
							EndIf
						Else
							If nBHSem < 0
								nBHSem += aBHAcum[nX,3]
								If nBHSem > 0
									nBHAux := nBHSem
									aBHAcum[nX, 3] := nBHAux
									nBHSem := 0
									Exit
								Else
									aBHAcum[nX, 3] := 0
								EndIf
							EndIf							
						EndIf					
					EndIf
				Next nX			
			EndIf
			
			If nBHSem <> 0
				fGeraTot(		@aTotBHAux 							,;	//01 -> Array com os Totais do Ponto
								dDtAuxIni-1							,;	//02 -> Data para Pesquisa e Gravacao no aTotais
								If(nBHSem>0,nBHSem,nBHSem*(-1))		,;	//03 -> Horas para Soma ou Geracao
								0									,;	//04 -> Valor para Soma ou Geracao
								If(nBHSem>0,PosSP9("023",SRA->RA_FILIAL,"P9_CODIGO", 2 ),PosSP9("024",SRA->RA_FILIAL,"P9_CODIGO", 2 ))		,;	//05 -> Evento do Ponto para Pesquisa
								SRA->RA_CC							,;	//06 -> Centro de Custo para Comparacao
								SRA->RA_FILIAL						,;	//07 -> Filial para Pesquisa no SP9 
							 )			
			EndIf
			
			nBHSem := 0
				
			For nX := 1 to Len(aBHAcum)
				If aBHAcum[nX, 1] >= dDtAuxIni .and. aBHAcum[nX, 1] <= dDtAuxFim
					If aBHAcum[nX, 1] >= dDtIniUSem //--Na última semana não efetua compensações, deverá ser validado na primeira semana do mês posterior
						Exit
					EndIf
					If aBHAcum[nX,3] > 0
						lBHProv := PosSP9( aBHAcum[nX, 2] , SRA->RA_FILIAL, "P9_TIPOCOD") <> "2"
						
						If lBHProv
							If nBHSem < 0
								nBHSem += aBHAcum[nX,3]
								If nBHSem > 0
									aBHAcum[nX,3] := nBHSem
								Else
								 	aBHAcum[nX,3] := 0
								EndIf
							Else
								nBHSem += aBHAcum[nX,3]
								aBHAcum[nX,3] := 0
							EndIf
						Else
							If nBHSem > 0
								nBHSem -= aBHAcum[nX,3]
								If nBHSem < 0
									aBHAcum[nX,3] := nBHSem * (-1)
								Else
								 	aBHAcum[nX,3] := 0
								EndIf
							Else
								nBHSem -= aBHAcum[nX,3]
								aBHAcum[nX,3] := 0
							EndIf						
						EndIf
					EndIf
				Else
					If nBHSem <> 0
						For nY := nX to Len(aBHAcum)
							If aBHAcum[nY, 1] > dDtAuxFim .and. aBHAcum[nY, 1] <= dDtFimProx
								If aBHAcum[nY,3] > 0
									lBHProv := PosSP9( aBHAcum[nY, 2] , SRA->RA_FILIAL, "P9_TIPOCOD") <> "2"
									If lBHProv
										If nBHSem < 0
											nBHSem += aBHAcum[nY,3]
											If nBHSem > 0
												aBHAcum[nY,3] := nBHSem
												nBHSem := 0
												Exit
											Else
											 	aBHAcum[nY,3] := 0
											EndIf
										EndIf
									Else
										If nBHSem > 0
											nBHSem -= aBHAcum[nY,3]
											If nBHSem < 0
												aBHAcum[nY,3] := nBHSem * (-1)
												nBHSem := 0
												Exit
											Else
											 	aBHAcum[nY,3] := 0
											EndIf
										EndIf
									EndIf
								EndIf
							Else
								Exit
							EndIf
						Next nY
						
						If nBHSem <> 0
							//Gera evento para pagamento/desconto de BH
							fGeraTot(		@aTotBHAux 							,;	//01 -> Array com os Totais do Ponto
											dDtAuxFim-1							,;	//02 -> Data para Pesquisa e Gravacao no aTotais
											If(nBHSem>0,nBHSem,nBHSem*(-1))		,;	//03 -> Horas para Soma ou Geracao
											0									,;	//04 -> Valor para Soma ou Geracao
											If(nBHSem>0,PosSP9("023",SRA->RA_FILIAL,"P9_CODIGO", 2 ),PosSP9("024",SRA->RA_FILIAL,"P9_CODIGO", 2 ))		,;	//05 -> Evento do Ponto para Pesquisa
											SRA->RA_CC							,;	//06 -> Centro de Custo para Comparacao
											SRA->RA_FILIAL						,;	//07 -> Filial para Pesquisa no SP9 
										 ) 					
						EndIf
					EndIf
					
					//--Próxima semana
					dDtAuxIni  := dDtAuxFim + 1
					dDtAuxFim  := dDtAuxFim + 7
					dDtFimProx := dDtAuxFim + 7
					nBHSem     := 0
					nX--									
				EndIf 
			Next nX
			
			If nBHSem <> 0
				//Gera evento para pagamento/desconto de BH
				fGeraTot(		@aTotBHAux 							,;	//01 -> Array com os Totais do Ponto
								dDtAuxFim-1							,;	//02 -> Data para Pesquisa e Gravacao no aTotais
								If(nBHSem>0,nBHSem,nBHSem*(-1))		,;	//03 -> Horas para Soma ou Geracao
								0									,;	//04 -> Valor para Soma ou Geracao
								If(nBHSem>0,PosSP9("023",SRA->RA_FILIAL,"P9_CODIGO", 2 ),PosSP9("024",SRA->RA_FILIAL,"P9_CODIGO", 2 ))		,;	//05 -> Evento do Ponto para Pesquisa
								SRA->RA_CC							,;	//06 -> Centro de Custo para Comparacao
								SRA->RA_FILIAL						,;	//07 -> Filial para Pesquisa no SP9 
							 ) 					
			EndIf			
		EndIf
		
		nLenSPIAux := Len(aSPI)
		
		// Fecha a Query do SPI
		If lQueryOpened
			( cAliasQSPI )->( dbCloseArea() )
			dbSelectArea("SRA")
		EndIf
		
		// Efetua a gravação do Array aBHAcum no arquivo SPI
		IF ( ( nBHAcum := Len(aBHAcum) ) > 0 )
			For nX := 1 To nBHAcum
				IF ( aBHAcum[nX, 3] > 0 )
					IF ( nPos := aScan( aSPI , { |x| x[1] == aBHAcum[ nX,1 ] .and.x[2] == aBHAcum[ nX,2 ] .and.x[6] == aBHAcum[ nX,5 ] } ) ) > 0
						IF aSPI[nPos,3] # aBHAcum[nX,3] .or. aSPI[nPos,4] # aBHAcum[nX,4]
							SPI->(dbGoTo(aSPI[nPos,5]))
							IF !SPI->( RecLock( "SPI", .F. , .T. ) )
								Loop
							EndIF
							nValorV			:= Round(fConvHr(aBHAcum[nX,3], "D", .T., 5)*(aBHAcum[nX,4]/100),2)
							nValorV			:= fConvhr(nValorV,"H")
							SPI->PI_CC		:= IF( Empty(aBHAcum[nX,5]) , SRA->RA_CC , aBHAcum[nX,5] )
							SPI->PI_QUANT	:= aBHAcum[nX,3]
							SPI->PI_QUANTV	:= nValorV
							
							If lMesesBH .And. nMesesBH > 0
								SPI->PI_DTVENC	:= MonthSum(aBHAcum[nX, 1], nMesesBH)
							EndIf
							SPI->( MsUnlock() )
						EndIF
						aDel(aSPI, nPos)
						aSize(aSPI, Len(aSPI)-1)
					Else
						IF !SPI->( RecLock( "SPI" , .T. ) )
							Loop
						EndIF
						nValorV := Round(fConvHr(aBHAcum[nX,3], "D", .T., 5)*(aBHAcum[nX, 4]/100),2)
						nValorV := fConvhr(nValorV,"H")
						SPI->PI_FILIAL	:= cFilSPI
						SPI->PI_MAT		:= SRA->RA_MAT
						SPI->PI_PD		:= aBHAcum[nX, 2]
						SPI->PI_CC		:= IF( Empty(aBHAcum[nX,5]) , SRA->RA_CC , aBHAcum[nX,5] )
						SPI->PI_DATA	:= aBHAcum[nx, 1]
						SPI->PI_QUANT	:= aBHAcum[nX, 3]
						SPI->PI_QUANTV	:= nValorV
						SPI->PI_FLAG	:= "G"
						
						If lMesesBH .And. nMesesBH > 0
							SPI->PI_DTVENC	:= MonthSum(aBHAcum[nx, 1], nMesesBH)
						EndIf
						
						SPI->( MsUnlock() )
					EndIF
				EndIF
			Next nX
		EndIF
		
		// Apaga so SPI as informacoes que nao foram recalculadas
		nLenSPI := Len(aSPI)
		For nX := 1 To nLenSPI
			SPI->( dbGoTo( aSPI[ nX , 5 ] ) )
			// So apaga se for Gerado
			IF SPI->( PI_FLAG == "G" .and.PI_STATUS <> "B" )
				IF SPI->( RecLock( "SPI" , .F. ) )
					IF !SPI->( FkDelete( @cMsgErr ) )
						SPI->( RollBackDelTran( cMsgErr ) )
					EndIF
					SPI->( MsUnLock() )
				EndIF
			EndIF
		Next nX
		
		If !lOnlyBH
			//Quando a Expressao da Query nao estiver definida monta-a
			IF Empty( cSPBQuery )
				cAliasQSPB	:= ( "__Q" + cAliasSPB + "QRY" )
				cSPBQuery := "SELECT "
				
				// Carregando os Campos do SPC na Query
				For nX := 1 To nSpbFields
					cSPBQuery += aSpbFields[ nX , 01 ] + ", "
				Next nX
				cSPBQuery += "R_E_C_N_O_ RECNO "
				cSPBQuery += " FROM " + InitSqlName( cAliasSPB ) + " " + cAliasSPB
				
				//Montando a Condicao										   ³
				cSPBQuery += " WHERE "
				cSPBQuery += cAliasSPB + "."
				cSPBQuery += "PB_FILIAL='"+cLastFil+"'"
				cSPBQuery += " AND "				
				cSPBQuery += cAliasSPB + "."
				cSPBQuery += "PB_MAT='"+SRA->RA_MAT+"'"
				cSPBQuery += " AND "
				cSPBQuery += " ( "
				cSPBQuery += 		cAliasSPB + "."
				cSPBQuery += 		"PB_DATA>='"+cIniData+"'"
				cSPBQuery += 		" AND "
				cSPBQuery += 		cAliasSPB + "."
				cSPBQuery += 		"PB_DATA<='"+cFimData+"'"
				cSPBQuery += " ) "
				cSPBQuery += " AND "
				cSPBQuery += cAliasSPB + ".D_E_L_E_T_=' ' "
				cSPBQuery += "ORDER BY " + SqlOrder( (cAliasSPB)->( IndexKey() ) )
				
				// Guarda os Valores Anteriores
				cSPBSvQuery	:= cSPBQuery
			Else
				// Caso contrario, apenas substitui os valores
				cSPBQuery	:= StrTran( cSPBSvQuery , ( "PB_FILIAL='"+cSvFil+"'"	) , ( "PB_FILIAL='"+cLastFil+"'"	) )
				cSPBQuery	:= StrTran( cSPBQuery   , ( "PB_MAT='"+cSvMat+"'"		) , ( "PB_MAT='"+SRA->RA_MAT+"'"	) )
				cSPBQuery	:= StrTran( cSPBQuery	, ( "PB_DATA>='"+cSvIniData+"'" ) , ( "PB_DATA>='"+cIniData+"'"		) )
				cSPBQuery	:= StrTran( cSPBQuery	, ( "PB_DATA<='"+cSvFimData+"'" ) , ( "PB_DATA<='"+cFimData+"'" 	) )
				
				// Guarda os Valores Anteriores
				cSPBSvQuery	:= cSPBQuery
			EndIF
			
			cSPBQuery := ChangeQuery( cSPBQuery )
			
			// Se conseguiu Montar a Query Seta os Campos
			lQueryOpened := MsOpenDbf(.T., "TOPCONN", TcGenQry(NIL, NIL, cSPBQuery), cAliasQSPB, .T., .T.)
			
			For nX := 1 To nSpbFields
				IF !( aSpbFields[ nX, 02 ] == "C" )
					TcSetField(cAliasQSPB, aSpbFields[nX,01], aSpbFields[nX,02], aSpbFields[nX,03], aSpbFields[nX,04])
				EndIF
			Next nX
			
			// Carrega os Dados Anteriores do SPB
			aSPB:={}
			While ( cAliasQSPB )->( !Eof() )
				If ( cAliasQSPB )->( ( PB_DATA >= dPerIni ) ) .Or. nAgrupEvnt == 1 
					If !lInterm
						aAdd( aSPB , Array( 07 ) )
					Else
						aAdd( aSPB , Array( 08 ) )
					EndIf
					nLenSPB := Len( aSPB )
					aSPB[ nLenSPB , 01 ] := ( cAliasQSPB )->( PB_DATA	)
					aSPB[ nLenSPB , 02 ] := ( cAliasQSPB )->( PB_PD		)
					aSPB[ nLenSPB , 03 ] := ( cAliasQSPB )->( PB_HORAS	)
					aSPB[ nLenSPB , 04 ] := ( cAliasQSPB )->( RECNO	)
					aSPB[ nLenSPB , 05 ] := ( cAliasQSPB )->( PB_CC		)
					aSPB[ nLenSPB , 06 ] := ( cAliasQSPB )->( PB_VALOR	)
					aSPB[ nLenSPB , 07 ] := ( cAliasQSPB )->( PB_TIPO2	)
					If lInterm
						aSPB[ nLenSPB , 08 ] := ( cAliasQSPB )->( PB_CONVOC	)
					EndIf
				EndIf
				( cAliasQSPB )->( dbSkip() )
			EndDo
			
			// Fecha a Query do SPB										  ³
			If ( lQueryOpened )
				( cAliasQSPB )->( dbCloseArea() )
				dbSelectArea("SRA")
			EndIf
			
			// Refeitório
			IF ( cRefeit == "S" )
				// Ponto de Entrada Para Tratamento Especifico para Refeicoes
				IF ( lPoncalrBlock )
					IF ( ValType( uRetBlock := ExecBlock( "PONCALR" , .F. , .F. , { aTotais , aCodRef } ) ) == "A" )
						IF ( Len( uRetBlock ) > 0 )
							IF ( ValType( uRetBlock[1] ) == "A" )
								aTotais	:= aClone( uRetBlock[1] )
							EndIF
							IF ( ( Len( uRetBlock ) > 1 ) .and. ( ValType( uRetBlock[2] ) == "A" ) )
								aCodRef	:= aClone( uRetBlock[2] )
							EndIF
						EndIF
						uRetBlock	:= NIL
					EndIF
				Else
					fCalRefeit( cLastFil, SRA->RA_MAT, @aTotais, @aCodRef, cEveTotR )
				EndIF
			EndIF
			
			// Ponto de Entrada Antes da Totalizacao dos Eventos que irao para a Folha de Pagamento
			IF ( lPonCalaTotBlock )
				uRetBlock := ExecBlock(;
											"PONCALATOT",;
											.F.,;
											.F.,;
											{;
												SRA->RA_FILIAL,;		//ParamIxb[1] <-> Filial do Funcionario
												SRA->RA_MAT,;			//ParamIxb[2] <-> Matricula do Funcionario
												aClone( aTotais ),;		//ParamIxb[3] <-> Array aTotais
												dPerIni,;				//ParamIxb[4] <-> Periodo Incial do Apontamento
												dPerFim,;				//ParamIxb[5] <-> Periodo Final do Apontamento
												aClone( aTabCalend );	//ParamIxb[6] <-> Array com o Calendario de Marcacoes
											},;
											.F.;
									)
				IF ( ValType( uRetBlock ) == "A" )
					aTotais := aClone( uRetBlock )
				EndIF
				uRetBlock := NIL
			EndIF
			
			If lPort1510
				// Elimina todos os Registros do Periodo para o Funcionario
				fDelRFF(SRA->RA_FILIAL, SRA->RA_MAT, cPerApo, cIniData, cFimData, dPerIni, dPerFim)
				
				// Trata Eventos Abonados
				aTotAux	:=aClone(aTotais)
				// Corre todo o aRFF em busca de eventos que abonam as horas
				For nX	:= 1 to Len(aRFF)
					IF ( aRFF[ nX , ARFF_HORAS_ABONADAS	] > 0)
						//-- Procura por Eventos que devem ter as horas de abonos deduzidas
						IF ( (nPos:= Ascan(aTotAux,{|X|  ;
														x[ATOTAIS_DATA			] == aRFF[nX, ARFF_DATA 				] .AND. ;
														x[ATOTAIS_EVENTO_PONTO	] == aRFF[nX, ARFF_EVENTO_ORIGEM 		] .AND. ;
														x[ATOTAIS_CENTO_DE_CUSTO] == aRFF[nX, ARFF_CENTRO_DE_CUSTO 		]  		;
													} ;
											);
							 ) > 0 ;
						   )
						    //-- Se a quantidade abonada for de desconto, subtrai
						    aTotAux[nPos, ATOTAIS_HORAS] := SubHoras( aTotAux[nPos, ATOTAIS_HORAS], aRFF[nX, ARFF_HORAS_ABONADAS] )
						Endif 
						
					ElseIF ( aRFF[ nX , ARFF_HORAS_BANCO	] > 0)
							IF (nPos:= Ascan(aBHAcum,{|X|  ;
														x[01] 		== aRFF[nX, ARFF_DATA 				] .AND. ;
														x[02]		== aRFF[nX, ARFF_EVENTO_ORIGEM 		] .AND. ;
														x[05] 		== aRFF[nX, ARFF_CENTRO_DE_CUSTO 	]  		;
													} ;
											);
							   	) > 0 
						   		
						    	//-- Se a quantidade abonada for de desconto, subtrai
						    	aBHAcum[nPos, 03	] := SubHoras( aBHAcum[nPos, 03	] , aRFF[nX, ARFF_HORAS_BANCO] )
	                        Endif
						   
					Else
				 		//-- Horas Trabalhadas
				 		fGeraTot(	@aTotAux								,;	//01 -> Array com os Totais do Ponto
									aRFF[nX, ARFF_DATA 				]		,;	//02 -> Data para Pesquisa e Gravacao no aTotais
									aRFF[nX, ARFF_HORAS 			] 		,;	//03 -> Horas para Soma ou Geracao
									0										,;	//04 -> Valor para Soma ou Geracao
									aRFF[nX, ARFF_EVENTO_PONTO 		] 		,;	//05 -> Evento do Ponto para Pesquisa
									aRFF[nX, ARFF_CENTRO_DE_CUSTO 	] 		,;	//06 -> Centro de Custo para Comparacao
									cLastFil	  							 ;	//07 -> Filial para Pesquisa no SP9
								)
					Endif
				Next nX
				
				IF ( ( nTotais := Len(aBHAcum) ) > 0 )
					For nX	:= 1 to nTotais
						nHoras:=  aBHAcum[nX, 03	]
						IF (nHoras	> 0 ) 
							
							IF !RFF->( RecLock( "RFF" , .T. ) )
								Loop
							EndIF
							RFF->RFF_FILIAL := SRA->RA_FILIAL
							RFF->RFF_CC     := IF( Empty( aBHAcum[nX, 05	] ) , SRA->RA_CC , aBHAcum[nX, 05	] )
							RFF->RFF_MAT    := SRA->RA_MAT
							RFF->RFF_PD     := aBHAcum[nX, 02	]
							RFF->RFF_TIPO 	:= 2 
							RFF->RFF_QUANTC := aBHAcum[nX, 03	]
							RFF->RFF_DATA   := aBHAcum[nX, 01	]
							RFF->RFF_PAPONT := cPerApo
							RFF->RFF_FLAG	:= "I"  
							RFF->RFF_SINAL	:= "1"  
							RFF->RFF_PERCEN	:=  aBHAcum[nX, 07	]  //Percentual
							RFF->RFF_TIPOHE	:=  aBHAcum[nX, 06	]  //Tipo de HE						
							RFF->( MsUnlock() )
						EndIF
					Next nX
				Endif
				
				// Grava as Informacoes no RFF
				IF ( ( nTotais := Len(aTotAux) ) > 0 )
					For nX := 1 To nTotais
						IF (aTotAux[nX,ATOTAIS_HORAS] > 0 ) 
							IF !RFF->( RecLock( "RFF" , .T. ) )
								Loop
							EndIF
							RFF->RFF_FILIAL := SRA->RA_FILIAL
							RFF->RFF_CC     := IF( Empty( aTotAux[ nX , ATOTAIS_CENTO_DE_CUSTO ] ) , SRA->RA_CC , aTotAux[ nX , ATOTAIS_CENTO_DE_CUSTO ] )
							RFF->RFF_MAT    := SRA->RA_MAT
							RFF->RFF_PD     := aTotAux[ nX , ATOTAIS_EVENTO_PONTO	] 
							RFF->RFF_TIPO 	:= 1 						
							RFF->RFF_QUANTC := aTotAux[ nX , ATOTAIS_HORAS 			]
							RFF->RFF_DATA   := aTotAux[ nX , ATOTAIS_DATA			]
							RFF->RFF_PAPONT := cPerApo
							RFF->RFF_FLAG	:= "I"   
							RFF->RFF_SINAL	:= "1" 
							RFF->RFF_PERCEN	:= aTotAux[ nX , ATOTAIS_PERCENT		]
							RFF->RFF_TIPOHE	:= aTotAux[ nX , ATOTAIS_TIPOHE			] 
							RFF->( MsUnlock() )
						EndIF
					Next nX
				EndIF
				
				// Totaliza os Eventos para calculo da folha de pagamento
				fTotEve( @aTotais ,,.F.,lInterm)
				
			Endif
			
			// Totaliza de Acordo com as Verbas da Folha
			fTotEve( @aTotais , .T. ,,lInterm)
		Else
			aSPB := {}
			aTotais := {}
		EndIf
		
		//Se existir eventos de Banco de Horas que serão pagos/descontados devido a configuração de pagamento semanal, adiciona os itens no array para pagamento
		For nX := 1 to Len(aTotBHAux)
			aAdd(aTotais, aTotBHAux[nX])
		Next nX
		
		// Grava as Informacoes na SPB
		If ( nTotais := Len(aTotais) ) > 0
			For nX := 1 To nTotais
				If (aTotais[nX,ATOTAIS_HORAS] > 0 ) .And. ( aScan(aCodAut, {|x| x[1] == aTotais[nX, ATOTAIS_EVENTO_PONTO] .And. !Empty( x[13])}) > 0 ;
				.Or. (!Empty(cEveTotR) .And. aTotais[nX, ATOTAIS_CODIGO_FOLHA] == cEveTotR))
					If lInterm
						nPosConv := aScan( aConvoc, { |x| aTotais[nX, ATOTAIS_DATA] >= x[2] .And. aTotais[nX, ATOTAIS_DATA] <= x[3]})
						If nPosConv == 0 .And. lHEInterm
							//'Para o Funcionario:"###'da Filial: '###'e Turno: '
							SRA->( aAdd( aLogsFunc, STR0051 + " " + RA_MAT + If(lOfuscaNom,'', '-' + alltrim(RA_NOME)) + " " + STR0014 + " " + RA_FILIAL + " " + STR0015 + " " + RA_TNOTRAB ) ) 
							SRA->( aAdd( aLogsFunc, STR0052 + dToC(aTotais[ nX , ATOTAIS_DATA ]) + STR0053 ) )//'Não foi gerado resultado do dia: '##' devido não ter sido encontrado convocação para esse dia.'
							Loop				
						ElseIf lHEInterm .And. nPosConv > 0 .And. !aConvoc[nPosConv, 10]
							Loop
						EndIf
					EndIf
					
					//Se for um evento de BH e o TIPO2 for diferente de "C", indica que o evento já havia sido gerado por outra rotina, portanto, não sobrepõe
					If (!lInterm .And. (nPos := aScan(aSPB, {|x| x[2] == aTotais[nX,ATOTAIS_CODIGO_FOLHA] .and. x[5] == aTotais[nX,ATOTAIS_CENTO_DE_CUSTO] .and. !( ( x[2] $ cBHEveP + "*" + cBHEveD + "*" + cBHEveH) .and. x[7] <> "C" ) })) > 0 ) .Or.;
						(lInterm .And. nPosConv > 0 .And. ( nPos := aScan(aSPB, {|x| x[2] == aTotais[nX,ATOTAIS_CODIGO_FOLHA] .and.x[5] == aTotais[nX,ATOTAIS_CENTO_DE_CUSTO] .and. !( ( x[2] $ cBHEveP + "*" + cBHEveD + "*" + cBHEveH ) .and. x[7] <> "C" ) .And. x[8] == aConvoc[nPosConv, 1] })) > 0 )
						IF ( aSPB[nPos,7] <> "I") /*( (aSPB[nPos,3] # aTotais[nX,3]) .or. (aSPB[nPos,6] # aTotais[nX,6]) ) .AND. <Termo Atual>*/
							SPB->(dbGoTo(aSPB[nPos,4]))
							IF !SPB->( RecLock( "SPB" , .F. , .T. ) )
								Loop
							EndIF
							If nAgrupEvnt == 2
								SPB->PB_HORAS 	:= fConvHr(aTotais[nX, 3], "D")   
								SPB->PB_VALOR	:= aTotais[ nX , ATOTAIS_VALOR ]
							Else
								SPB->PB_HORAS 	+= fConvHr(aTotais[nX, 3], "D")   
								SPB->PB_VALOR	+= aTotais[ nX , ATOTAIS_VALOR ]
							EndIf
							SPB->PB_DATA    := If((aTotais[nX,ATOTAIS_CODIGO_FOLHA] == cEveFal .and. cPaisLoc == "BRA" .and. lSegFaltas) .Or. ( cPaisLoc == "BRA" .and. lInterm), aTotais[ nX , ATOTAIS_DATA ], dDataBase )
							IF ( aTotais[ nX , ATOTAIS_VALOR ] > 0  )  
									SPB->PB_TIPO1	:=  "V" 
							ElseIF ( aScan( aCodRef , { |x| x == aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] } ) > 0 ) .OR. 	 ;	
						   		    ( aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] $ cVerbaCont	) 		
									SPB->PB_TIPO1	:= 	"D" 
							Else
									SPB->PB_TIPO1	:=  "H" 
							Endif
							If lInterm .And. nPosConv > 0
								SPB->PB_CONVOC	:= aConvoc[nPosConv, 1]
							EndIf
							SPB->( MsUnlock() )
						EndIF
						aDel(aSPB, nPos)
						aSize(aSPB, Len(aSPB)-1)
					ElseIF !Empty( aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] )
						IF !SPB->( RecLock( "SPB" , .T. ) )
							Loop
						EndIF
						SPB->PB_FILIAL := cFilSPB
						SPB->PB_CC     := IF( Empty( aTotais[ nX , ATOTAIS_CENTO_DE_CUSTO ] ) , SRA->RA_CC , aTotais[ nX , ATOTAIS_CENTO_DE_CUSTO ] )
						SPB->PB_MAT    := SRA->RA_MAT
						SPB->PB_PD     := aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] 
						SPB->PB_HORAS  := fConvHr(aTotais[ nX , ATOTAIS_HORAS ], "D")
						SPB->PB_DATA    := If( (aTotais[nX,ATOTAIS_CODIGO_FOLHA] == cEveFal .and. cPaisLoc == "BRA" .and. lSegFaltas ) .Or. ( cPaisLoc == "BRA" .and. lInterm), aTotais[ nX , ATOTAIS_DATA ], dDataBase )
						IF ( aTotais[ nX , ATOTAIS_VALOR ] > 0  )  
								SPB->PB_TIPO1	:=  "V" 
						ElseIF ( aScan( aCodRef , { |x| x == aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] } ) > 0 ) .OR. 	 ;	
					   		    ( aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] $ cVerbaCont	) 		
								SPB->PB_TIPO1	:= 	"D" 
						Else
								SPB->PB_TIPO1	:=  "H" 
						Endif
						SPB->PB_TIPO2  := If(aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] $ cBHEveP + "*" + cBHEveD, "C", "G") //Se for banco de horas, foi gerado pela rotina de calculo e deixa o tipo2 como "C"
						SPB->PB_VALOR  := aTotais[ nX , ATOTAIS_VALOR ]
						If lInterm .And. nPosConv > 0
							SPB->PB_CONVOC	:= aConvoc[nPosConv, 1]
						EndIf
						SPB->( MsUnlock() )
					EndIF
				EndIF
			Next nX
		EndIF
		
		// Apaga so SPB as informacoes que nao foram recalculadas
		nLenSPB := Len( aSPB )
		If !lOnlyBH .And. nAgrupEvnt != 1
			For nX := 1 To nLenSPB
				SPB->( dbGoTo( aSPB[ nX,4 ] ) )
				// So apaga se for Gerado
				IF ( SPB->PB_TIPO2 $ "G*C" ) .AND. ( !(lMantBH .AND. ( SPB->PB_PD == cBHEveP .OR. SPB->PB_PD == cBHEveD .OR. SPB->PB_PD == cBHEveH)) .or. (SPB->PB_TIPO2 == "C"))
					IF SPB->( RecLock( "SPB" , .F. ) )
						IF !SPB->( FkDelete( @cMsgErr ) )
							SPB->( RollBackDelTran( cMsgErr ) )
						EndIF
						SPB->( MsUnlock() )
					EndIF
				EndIF
			Next nX
		EndIf
		
		// Ponto de Entrada de Saida
		IF ( lPoncaldBlock )
 			ExecBlock("PONCALD" , .F. , .F. )
		EndIF
		
		// Salva as Variaveis para a Modificacao das Querys
		cSvFil	    := cLastFil
		cSvMat		:= SRA->RA_MAT
		cSvIniData	:= cIniData
		cSvFimData	:= cFimData
		cFilExetd	:= SRA->RA_FILIAL
		
		// Incrementa a quantidade de funcionários
		nFuncProc++
		
		// Próximo Funcionário
		SRA->( dbSkip() )
		
	EndDo
	
End Sequence

// Fecha a Query do SRA e Restaura o Padrão
If lSraQryOpened
	SRA->( dbCloseArea() )
	ChkFile( "SRA" )
EndIF

cDuracao := RemainingTime( cTimeIni, GetFirstRemaining(), .F. )

aAdd(aLogTitle, STR0071) // "OCORRÊNCIAS DURANTE O CÁLCULO MENSAL"
aAdd(aLogs, {STR0072 + dToC(dIniDate) + ", " + STR0074 + cTimeIni + "."}) // "- Inicio do Cálculo Mensal em " "às"
aAdd(aLogs[1], STR0073 + Dtoc(MsDate()) + ", " + STR0074 + Time() + '.') // "- Final do Cálculo Mensal em " "às"
aAdd(aLogs[1], STR0075 + cDuracao + ".") // "- Decorridos: "
aAdd(aLogs[1], STR0076 + MediumTime( cDuracao, nFuncProc, .T. ) + ".") // "- Tempo médio por funcionário: "
aAdd(aLogs[1], STR0077 + StrZero(nFuncProc, 10) + ".") // "- Número de Funcionários Processados: "

If !Empty(aLogsFunc)
	aAdd(aLogTitle, STR0078) // "Funcionários não processados"
	aAdd(aLogs, aLogsFunc)
EndIf

aAdd(aLogTitle, STR0079) // "Inconsistências nos casdastros do Ponto"
aAdd(aLogs, aClone(aLogDet))

If lPELog
	aEval(aLogsFunc, {|x| aAdd(aLogDet, x)})
	//Utilizado para que na User Function o Log gerado seja imputado na tabela CV8.
	ExecBlock("PN070LOG", .F., .F., {aLogDet, cTimeIni, cUsrLog, dIniDate})
EndIF

// Gera o Log de Inconsistencias
If lTelaBH .Or. (!lRobo .And. !lSchedule) .Or. (oProcess <> Nil .And. !lExec2Plan)
	fMakeLog( aLogs, aLogTitle, "PNM070",,,,,,,,aLogPerg )
EndIF

// Gera o log do tNewProcess
If (!lTelaBH .And. !lRobo .And. !lSchedule) .Or. (oProcess <> Nil)
	oProcess:SaveLog(STR0083) // "Fim da execução do Calculo Mensal"
EndIf

// Gera o log da execução em segundo plano
If lExec2Plan .And. !Empty(aLogs)
	
	// Formata os parâmetros da pergunta
	aLogPerg := fParFrtLog("PNM070")
	
	// Chamada do fMakeLog sem interface para tratamento dos arrays de Log
	fMakeLog(aLogs, aLogTitle, "PNM070", .F.,,,,,,,aLogPerg)

	// Gera o resultado dos array no console.log
	fGrvLog2Pl(aLogs, aLogTitle, aLogPerg, STR0006)
EndIf

// Restaura o Conteudo Original da Filial de Entrada
cFilAnt:= cSvFilAnt

RestArea( aAreaSRA )

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ fCalcPer  ³ Autor ³ Fernando Joly Siquini³ Data ³ 20/01/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula Eventos com Totaliza‡„o por Per¡odo.               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ PONM070							             			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³ Nil                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aTotAdiN = Array multidimencional com os Adicionais Not.   ³±±
±±³          ³ aTotais  = Array multidimencional com os Totais.           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fCalcPer( aTotEve, aTotais, cTipo, cPeriodo, nTolera )

Local dDtIni   		:= Ctod("//")
Local dData    		:= Ctod("//")
Local nX       		:= 0
Local nC       		:= 0
Local nT       		:= 0
Local nTotPer  		:= 0
Local nTotEve		:= 0
Local nPeriodo		:= 0

If ( ( nTotEve := Len(aTotEve) ) > 0 )
	
	If ( ( cPeriodo == "D" ) .Or. ( cPeriodo == "M" ) ) // Tolerancia Diaria ou Mensal
		If ( cPeriodo == "M" )
			aEval(aTotEve, {|x| nTotPer := __TimeSum(x[ATOTAIS_HORAS], nTotPer) })
			If ( nTotPer <= nTolera )
				Return( NIL )
			Endif
		Endif
		For nX := 1 To nTotEve
			fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
						aTotEve[nX, ATOTAIS_DATA]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
						aTotEve[nX, ATOTAIS_HORAS]			,;	//03 -> Horas para Soma ou Geracao
						0									,;	//04 -> Valor para Soma ou Geracao
						aTotEve[nX, ATOTAIS_EVENTO_PONTO]	,;	//05 -> Evento do Ponto para Pesquisa
						aTotEve[nX, ATOTAIS_CENTO_DE_CUSTO]	,;	//06 -> Centro de Custo para Comparacao
						SRA->RA_FILIAL						 ;	//07 -> Filial para Pesquisa no SP9
					) 
			
		Next nX
		
	ElseIF ( cPeriodo == "Q" ) // Tolerancia Quinzenal
		dData := ( dPerIni + 14 )
		For nC := 1 To 2
			nTotPer := 0
			If ( nC == 1 ) // Primeira Quinzena
				aEval(aTotEve, {|x| If( x[ATOTAIS_DATA] >= dPerIni .and.x[ATOTAIS_DATA] <= dData, nTotPer := __TimeSum(x[ATOTAIS_HORAS],nTotPer), Nil) })
			Else			// Segunda Quinzena
				aEval(aTotEve, {|x| If( x[ATOTAIS_DATA] >= (dData+1) .and.x[ATOTAIS_DATA] <= dPerFim, nTotPer := __TimeSum(x[ATOTAIS_HORAS],nTotPer), Nil) })
			Endif
			If ( nTotPer > nTolera )
				nTotEve := Len(aTotEve)
				For nX := 1 To nTotEve
					If (;
							(;
								( nC == 1 );
								.and.;
								( aTotEve[nx,ATOTAIS_DATA] >= dPerIni );
								.and.;
								( aTotEve[nx,ATOTAIS_DATA] <= dData );
							);
							.or.;
							(;
								( nC == 2 );
								.and.;
								( aTotEve[nx,ATOTAIS_DATA] >= ( dData + 1 ) );
								.and.;
								( aTotEve[nx,ATOTAIS_DATA] <= dPerFim );
							);	
						)	
						fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
									aTotEve[nX,ATOTAIS_DATA]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
									aTotEve[nX,ATOTAIS_HORAS]			,;	//03 -> Horas para Soma ou Geracao
									0									,;	//04 -> Valor para Soma ou Geracao
									aTotEve[nX,ATOTAIS_EVENTO_PONTO]	,;	//05 -> Evento do Ponto para Pesquisa
									aTotEve[nX,ATOTAIS_CENTO_DE_CUSTO]	,;	//06 -> Centro de Custo para Comparacao
									SRA->RA_FILIAL						 ;	//07 -> Filial para Pesquisa no SP9
								) 
						
					Endif
				Next nX
			Endif
		Next Nc
		
	ElseIF ( cPeriodo == "S" ) // Tolerancia Semanal
		dDtIni		:= dPerIni
		nPeriodo	:= ( dPerFim - dPerIni )
		For nX := 0 To nPeriodo
			dData    := ( dPerIni + nX )
			aEval(aTotEve, {|x| If( x[ATOTAIS_DATA] == dData , nTotPer := __TimeSum(x[ATOTAIS_HORAS],nTotPer), Nil) })
			If ( ( Dow(dData) == 1 ) .or. ( nX == nPeriodo ) )
				If nTotPer > nTolera
					nTotEve := Len(aTotEve)
					For nT:=1 To nTotEve
						If aTotEve[nT,ATOTAIS_DATA] >= dDtIni .and.aTotEve[nT,ATOTAIS_DATA] <= dData
							fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
										aTotEve[nT,ATOTAIS_DATA]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
										aTotEve[nT,ATOTAIS_HORAS]			,;	//03 -> Horas para Soma ou Geracao
										0									,;	//04 -> Valor para Soma ou Geracao
										aTotEve[nT,ATOTAIS_EVENTO_PONTO]	,;	//05 -> Evento do Ponto para Pesquisa
										aTotEve[nT,ATOTAIS_CENTO_DE_CUSTO]	,;	//06 -> Centro de Custo para Comparacao
										SRA->RA_FILIAL						,;	//07 -> Filial para Pesquisa no SP9
										NIL						 			,;	//08 -> Verba da Folha
										.T.						 			 ;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais
									)
							
						Endif
					Next nT
				EndIf
				dDtIni := dData
				nTotPer  := 0
			EndIf
		Next nX
	EndIf
EndIf

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ fCalcPHD  ³ Autor ³ Fernando Joly Siquini³ Data ³ 26/01/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula o Pagamento de horas e DSR com Tot. por Per¡odo.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ PONM070							   						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³ Nil                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aTotAdiN = Array multidimencional com as Horas e DSR.      ³±±
±±³          ³ aTotais  = Array multidimencional com os Totais.           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fCalcPHD( aTotPgHD, aTotais, aTabPadrao , aTabCalend , lHorasTab , lMvAcmHExt , cPerHmov , cMsgErr )
Local aTotAux		:= {}
Local aTabExtra		:= {}
Local aTabPHD   	:= {}
Local aTurnosPHD	:= {}   
Local aTotDia		:= {}
Local cCusto		:= ""
Local cDataAux		:= ""
Local dData     	:= Ctod("//")
Local dDtAfa		:= Ctod("//")
Local dDtRet		:= Ctod("//")
Local dDt1Aux		:= Ctod("//")
Local lRet			:= .T.
Local lAfasta		:= .F. 
Local nDiasUt     	:= 0
Local nHrsPrev     	:= 0
Local nX        	:= 0
Local nPagaHRS  	:= 0
Local nPagaDSR  	:= 0
Local nQtdDSR   	:= 0
Local nTolHrs   	:= 0
Local nTolInt   	:= 0
Local nTotPer   	:= 0
Local nTotPerNot 	:= 0
Local nTotPerDi  	:= 0
Local nTolera   	:= 0
Local nTotal    	:= 0
Local nTotDi		:= 0
Local nTotNot		:= 0
Local nSaiAnt   	:= 0
Local nHExtras  	:= 0
Local nHExtraPer 	:= 0
Local nOneDSR   	:= 0
Local nPosCalend   	:= 0
Local nTotPgHD		:= 0
Local nTabPHD		:= 0
Local nPeriodo		:= 0
Local nDiasFer		:= 0
Local nHorasAux		:= 0
         
cPeriodoHM := cPerHmov

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Reinicializa as Statics em ToScheduleOverTime()			  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
RstToScheduleOverTime()

IF ( lHorasTab ) //So Monta Calendario Qdo. Horas/DSR for pela Tabela
	//-- Nao foi passado centro de custo como parametro para que CriaCalend()
	//-- nao apure as excecoes.
	IF !CriaCalend(	dDataIni	  								,;
					dDataFim	   								,;
					SRA->RA_TNOTRAB								,;
					fQualSeq(aTabCalend,aTabPadrao,dDataIni)	,;
					aTabPadrao									,;
					@aTabPHD									,;
					SRA->RA_FILIAL								,;
					SRA->RA_MAT									,;
					SRA->RA_CC									,;
					@aTurnosPHD									 ;
				   )
		//'Nao voi possivel Montar o Calendario para o Funcionario: '###'da Filial: '###'e Turno: '###'O Calculo Mensal nao foi efetuado para este funcionario.'
		SRA->( aAdd( aLogDet , STR0019 + " " + RA_MAT + If(lOfuscaNom,'','-' + alltrim(RA_NOME)) + " " + STR0014 + RA_FILIAL + " " + STR0015 + " " + RA_TNOTRAB + ". " + STR0020 ) )
		Return( NIL )
	EndIF
	// Remonta Calendario de Acordo com fQualSeq() Caso Haja Troca de Turno no Periodo
	IF !Empty( aTurnosPHD )
		IF !CriaCalend(	dDataIni	  											,;
						dDataFim	   											,;
						SRA->RA_TNOTRAB											,;
						fQualSeq(@aTabPHD,aTabPadrao,dDataIni,aTurnosPHD[1,1])	,;
						aTabPadrao												,;
						@aTabPHD												,;
						SRA->RA_FILIAL											,;
						SRA->RA_MAT												,;
						SRA->RA_CC												,;
						aTurnosPHD									 			 ;
					   )
			//'Nao voi possivel Montar o Calendario para o Funcionario: '###'da Filial: '###'e Turno: '###'O Calculo Mensal nao foi efetuado para este funcionario.'
			SRA->( aAdd( aLogDet , STR0019 + " " + RA_MAT + If(lOfuscaNom,'','-' + alltrim(RA_NOME)) + " " + STR0014 + RA_FILIAL + " " + STR0015 + " " + RA_TNOTRAB + ". " + STR0020 ) )
			Return( NIL )
		EndIF
	EndIF
EndIF

If ( ( nTotPgHD := Len(aTotPgHD) ) > 0 )

	//-- Calcula Horas Trabalhadas e Pag. DSR de acordo com a Tabela
	nTabPHD := Len(aTabPHD)
	For nX := 1 To nTabPHD
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Soma Horas e DSR de Acordo com a Tabela                     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( aTabPHD[nX, 4] == "1E" )
			dDtAfa := aTabPHD[ nX , CALEND_POS_INI_AFAST ]
			dDtRet := aTabPHD[ nX , CALEND_POS_FIM_AFAST ]
			IF (;
					( lAfasta := aTabPHD[ nX, CALEND_POS_AFAST ] );
					.and.;
					( aTabPHD[ nX , CALEND_POS_DATA ] >= dDtAfa );
					.and.;
					( aTabPHD[nX,CALEND_POS_DATA] <= IF( Empty( dDtRet ) , aTabPHD[nX,CALEND_POS_DATA] , dDtRet ) );
				)	
				Loop
			EndIF
			IF ( aTabPHD[nX,CALEND_POS_DATA] < SRA->RA_ADMISSA )
				Loop
			EndIF	
			IF (;
					(;
						( aTabPHD[nX,CALEND_POS_FERIADO] );
						.and.;
						( aTabPHD[nX,CALEND_POS_TIPO_DIA] != "S" );
					);
					.or.;
					( aTabPHD[nX,CALEND_POS_TIPO_DIA] == "D" );
				)	
				nQtdDSR ++
			EndIF
		EndIF
		IF (;
				( aTabPHD[nX,CALEND_POS_TIPO_DIA] == "S" );
				.and.;
				( aTabPHD[nX,CALEND_POS_DATA] >= SRA->RA_ADMISSA );
				.and.;
				!( lAfasta );
			)	
			IF ( Substr( aTabPHD[nX,CALEND_POS_TIPO_MARC] , -1 ) == "E" )
				nPagaHrs := aTabPHD[nX,CALEND_POS_HRS_TRABA]
				fGeraTot(	@aTotais																		,;	//01 -> Array com os Totais do Ponto
							aTabPHD[nX,CALEND_POS_DATA]														,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							nPagaHrs																		,;	//03 -> Horas para Soma ou Geracao
							0																				,;	//04 -> Valor para Soma ou Geracao
							cPagaHrs																		,;	//05 -> Evento do Ponto para Pesquisa
							IF( !Empty(aTabPHD[nX,CALEND_POS_CC]),aTabPHD[nX,CALEND_POS_CC],SRA->RA_CC )	,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL																	 ;	//07 -> Filial para Pesquisa no SP9
						)
				
			EndIF
		EndIF
	Next nX
	
	If ( lHorasTab )
		If SRA->RA_CATFUNC != "H" .Or. !lDSRHorista
			nOneDSR := Int(SRA->RA_HRSMES/30)
			nOneDSR += ((SRA->RA_HRSMES/30-Int(SRA->RA_HRSMES/30))*60)/100
		Else
			//-- Soma as horas normais previstas 
			aEval( aTabCalend, { |x| If( x[CALEND_POS_TIPO_DIA] == "S" .And. SubStr( x[CALEND_POS_TIPO_MARC], 2, 1 ) == "E", nHrsPrev := __TimeSum(nHrsPrev, x[CALEND_POS_HRS_TRABA]), NIL ) } )	
			//-- Soma os dias uteis (trabalhado e compensado)
			aEval( aTabCalend, { |x| If( x[CALEND_POS_TIPO_MARC] == "1E" .And. x[CALEND_POS_TIPO_DIA] $ "S*C", nDiasUt++, NIL ) } )	
			nOneDSR := Int( nHrsPrev / nDiasUt )
			nOneDSR += ( ( nHrsPrev / nDiasUt - nOneDSR ) * 60 ) / 100
		EndIf
	    	
		For nX := 1 to nQtdDSR
			nPagaDSR := __TimeSum(nPagaDSR, nOneDSR)
		Next nX
        
        nDiasFer:= 0
        cDataAux:= ""
        
        
        If lDSRTab
        	aEval( aTabCalend, { |x| If( x[CALEND_POS_TIPO_MARC] == "1E" .And. x[CALEND_POS_TIPO_ORIG_DIA] == 'S' .And.x[CALEND_POS_FERIADO] == .T., {nDiasFer++,cDataAux += DtOC(x[CALEND_POS_DATA])+ "-"}, NIL ) } )
	        If nDiasFer > 0
            	nA:= 1
                For nx:=1 to nDiasFer
            		dDt1Aux:= SubStr(cDataAux,nA,10)
            		nHorasAux:= 0
            		aEval( aTabCalend, { |x| If( x[CALEND_POS_DATA] == cTod(dDt1Aux), nHorasAux := __TimeSum( nHorasAux, x[CALEND_POS_HRS_TRABA] ), NIL ) } )
                 	nPagaDSR := __TimeSub(nPagaDSR,nOneDSR)
                 	nPagaDSR := __TimeSum(nPagaDSR,nHorasAux)
                 	nA+=11
                 Next
            Endif
        Endif
        
		fGeraTot(	@aTotais		,;	//01 -> Array com os Totais do Ponto
					dDataBase		,;	//02 -> Data para Pesquisa e Gravacao no aTotais
					nPagaDSR		,;	//03 -> Horas para Soma ou Geracao
					0				,;	//04 -> Valor para Soma ou Geracao
					cPagaDSR		,;	//05 -> Evento do Ponto para Pesquisa
					SRA->RA_CC		,;	//06 -> Centro de Custo para Comparacao
					SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
				)
															
	ElseIf ( ( cPeriodoHM == "D" ) .and. !( lHorasTab ) )
		For nX := 1 To nTotPgHD
			If !( lPort1510 .And. cNormFol == '2' .And. (aTotPgHD[nX,ATOTAIS_EVENTO_PONTO]  == cPagaHrs .OR. aTotPgHD[nX,ATOTAIS_EVENTO_PONTO]  == cPagaHrsNot .Or. aTotPgHD[nX,ATOTAIS_EVENTO_PONTO]  == cPagaDSR) )
				fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
							aTotPgHD[nX,ATOTAIS_DATA]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							aTotPgHD[nX,ATOTAIS_HORAS]			,;	//03 -> Horas para Soma ou Geracao
							0									,;	//04 -> Valor para Soma ou Geracao
							aTotPgHD[nX,ATOTAIS_EVENTO_PONTO]	,;	//05 -> Evento do Ponto para Pesquisa
							aTotPgHD[nX,ATOTAIS_CENTO_DE_CUSTO]	,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL						 ;	//07 -> Filial para Pesquisa no SP9
						)
			EndIf				
		Next nX
	Else
		nPeriodo := ( dPerFim - dPerIni )
		For nX := 0 To nPeriodo
			
			dData := ( dPerIni + nX )
			//-- Soma Horas Trabalhadas no Per¡odo
			aEval(aTotPgHD, {|x| If( ( x[ATOTAIS_DATA] == dData ) .and.( x[ATOTAIS_EVENTO_PONTO]  == cPagaHrs .OR.  x[ATOTAIS_EVENTO_PONTO]  == cPagaHrsNot );
									 , ( nTotPer := __TimeSum( x[ATOTAIS_HORAS] , nTotPer ) , If(x[ATOTAIS_EVENTO_PONTO]  == cPagaHrsNot , nTotPerNot := __TimeSum( x[ATOTAIS_HORAS] , nTotPerNot ) , nTotPerDi := __TimeSum( x[ATOTAIS_HORAS] , nTotPerDi )) );
									 , NIL ) } )

			//-- Soma Horas Previstas no Per¡odo
			If ( ( nPosCalend := aScan(aTabCalend, {|x| x[CALEND_POS_DATA] == dData .and.x[CALEND_POS_TIPO_MARC] == "1E" })) > 0 )
				If TipodeDia(aTabCalend[nPosCalend]) == "S" 
					cOrdem := aTabCalend[nPosCalend,CALEND_POS_ORDEM]
					//-- Soma as Horas Previstas Trabalhadas
					aEval(aTabCalend, { |x| If(x[CALEND_POS_ORDEM] == cOrdem .and. SubStr(x[CALEND_POS_TIPO_MARC],2,1) == "E", nTolHrs := __TimeSum(nTolHrs, x[CALEND_POS_HRS_TRABA]),NIL)})
					//-- Verifica todas as saidas e caso seja intervalo soma as horas
					aEval(aTabCalend, { |x| If(x[CALEND_POS_ORDEM] == cOrdem .and. SubStr(x[CALEND_POS_TIPO_MARC],2,1) == "S", nTolInt := __TimeSum(nTolInt, x[CALEND_POS_HRS_INTER]),NIL)})
				Endif
			EndIf
                            
			If (;
					( cHrMovel == "S" .Or. cInMovel == "S" );
					.And.;					
					( ( ( cPeriodoHM == "S" ) .and. ( Dow( dData ) == 1 ) );
					.or.;
					( ( cPeriodoHM == "Q" ) .and. ( nX == 14 ) );
					.or.;
					( ( cPeriodoHM $ "SQM" ) .and. ( nX == nPeriodo ) ) );
				)	

				nTolera := nTolHrs

				If ( nTotPer < nTolera )
					nSaiAnt		:= __TimeSum(nSaiAnt, __TimeSub(nTolera, nTotPer))
					nTotal		:= __TimeSum(nTotal, nTotPer)
					nTotNot		:= __TimeSum(nTotNot, nTotPerNot)
					nTotDi		:= __TimeSum(nTotDi, nTotPerDi)
				ElseIf ( nTotPer > nTolera )
					nHExtraPer  := __TimeSub(nTotPer, nTolera)
					nHExtras	:= __TimeSum(nHExtras, nHExtraPer)
					nTotal		:= __TimeSum(nTotal, nTolera)
					If nTotPerNot > 0 
						If nTotPerNot >= nTotPerDi
							If (nTotPerNot >= nHExtraPer)
								nTotPerNot	:= __TimeSub(nTotPerNot,nHExtraPer)
							Else
								nTotPerDi 	:= __TimeSub(nTotPerDi,__TimeSub(nHExtraPer,nTotPerNot))
								nTotPerNot	:= 0 
							EndIf
							nTotNot	:= __TimeSum(nTotNot, nTotPerNot)
							nTotDi	:= __TimeSum(nTotDi, nTotPerDi)
						Else
							If (nTotPerDi >= nHExtraPer)
								nTotPerDi := __TimeSub(nTotPerDi,nHExtraPer)
							Else
								nTotPerNot	:= __TimeSub(nTotPerNot,__TimeSub(nHExtraPer,nTotPerDi))
								nTotPerDi	:= 0 
							EndIf
							nTotNot	:= __TimeSum(nTotNot, nTotPerNot)
							nTotDi	:= __TimeSum(nTotDi, nTotPerDi)
						EndIf
					EndIf
				Else
					nTotal	:= __TimeSum(nTotal, nTotPer)
					nTotNot	:= __TimeSum(nTotNot, nTotPerNot)
					nTotDi	:= __TimeSum(nTotDi, nTotPerDi)
				EndIf

				nTolHrs  	:= 0
				nTolInt	 	:= 0
				nTolDSR  	:= 0
				nTotPer  	:= 0
				nTotPerNot	:= 0
				nTotPerDi 	:= 0

			EndIf

		Next nX

		//-- Gera Pag. DSR
		For nX := 1 To nTotPgHD
			If aTotPgHD[nX,ATOTAIS_EVENTO_PONTO] == cPagaDSR
				fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
							aTotPgHD[nX,ATOTAIS_DATA]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							aTotPgHD[nX,ATOTAIS_HORAS]			,;	//03 -> Horas para Soma ou Geracao
							0									,;	//04 -> Valor para Soma ou Geracao
							aTotPgHD[nX,ATOTAIS_EVENTO_PONTO]	,;	//05 -> Evento do Ponto para Pesquisa
							aTotPgHD[nX,ATOTAIS_CENTO_DE_CUSTO]	,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL						 ;	//07 -> Filial para Pesquisa no SP9
						)
									
			EndIf
		Next nX

		//-- Procura o Centro de Custo Correspondente na Data
		IF ( ( nPosCalend := aScan( aTabCalend, {|x| x[CALEND_POS_DATA] == dData .and.x[CALEND_POS_TIPO_MARC] == "1E" } ) ) > 0 )
			cCusto := If ( Empty( aTabCalend[nPosCalend,CALEND_POS_CC] ), SRA->RA_CC, aTabCalend[nPosCalend,CALEND_POS_CC] )
		Else
			cCusto := SRA->RA_CC
		EndIF

		If lPort1510 .and. cNormFol <> '2'
			
			If nTotNot > 0
				//-- Gera Horas
				fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
							dData								,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							nTotDi							,;	//03 -> Horas para Soma ou Geracao
							0									,;	//04 -> Valor para Soma ou Geracao
							cPagaHrs							,;	//05 -> Evento do Ponto para Pesquisa
							cCusto								,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL						 ;	//07 -> Filial para Pesquisa no SP9
						) 
						
				fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
							dData								,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							nTotNot								,;	//03 -> Horas para Soma ou Geracao
							0									,;	//04 -> Valor para Soma ou Geracao
							cPagaHrsNot							,;	//05 -> Evento do Ponto para Pesquisa
							cCusto								,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL						 ;	//07 -> Filial para Pesquisa no SP9
						) 
					
			Else
							//-- Gera Horas
				fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
							dData								,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							nTotal								,;	//03 -> Horas para Soma ou Geracao
							0									,;	//04 -> Valor para Soma ou Geracao
							cPagaHrs							,;	//05 -> Evento do Ponto para Pesquisa
							cCusto								,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL						 ;	//07 -> Filial para Pesquisa no SP9
						) 
			EndIf
	   							
		EndIf
		
		//-- Gera Saidas Antecipadas
		If ( nSaiAnt > 0 )
			fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
						dData								,;	//02 -> Data para Pesquisa e Gravacao no aTotais
						nSaiAnt								,;	//03 -> Horas para Soma ou Geracao
						0									,;	//04 -> Valor para Soma ou Geracao
						cSaiAnte							,;	//05 -> Evento do Ponto para Pesquisa
						cCusto								,;	//06 -> Centro de Custo para Comparacao
						SRA->RA_FILIAL						 ;	//07 -> Filial para Pesquisa no SP9
					)
							
		EndIf
		
		//-- Gera Horas Extras
		IF ( nHExtras > 0 )
			IF ( nPosCalend > 0 )
				//-- Carrega tabela de Horas Extras / Horas Extras Noturnas
				IF ( lRet := GetTabExtra( @aTabExtra, SRA->RA_FILIAL, aTabCalend[ nPosCalend, CALEND_POS_TURNO ], .F., .T., NIL, NIL, @cMsgErr ))
					
					aTotAux	:= aClone(aTotais)
					
					fGeraExtra(;
									aTabExtra		,; //01
									"1"				,; //02
									nHExtras		,; //03
									0				,; //04
									{}				,; //05
									@aTotais		,; //06
									dData			,; //07
									"FEC"			,; //08
									NIL				,; //09
									NIL				,; //10
									cCusto			,; //11
									NIL				,; //12
									lMvAcmHExt		,; //13
									NIL				,; //14  
   									/*cFuncao	*/	,; //15 -> Funcao para gravacao
									/*cDepto	*/	,; //16 -> Depto para gravacao
									/*cPosto	*/	,; //17 -> Posto para gravacao  
									/*cProcesso	*/ 	,; //18 -> Processo para Gravacao								
									/*cRoteiro	*/	,; //19 -> Roteiro para Gravacao
									/*cPeriodo	*/	,; //20 -> Periodo para Gravacao								
									/*cNumPagto	*/	,; //21 -> NumPagto para Gravacao	
									/*cTurno	*/ 	,; //19 -> Turno de Trabalho
									/*cSemana	*/	,; //20 -> Semana/Sequencia do Turno
									aTotDia			,; //21 -> Total Eventos  Diarios
									dData		 	;  //22 -> Data do Apontamento							
								)
					
					IF lPort1510
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Agrega horas extras diarias ao aTotais independe do periodo ³
						³ de apuracao.												  ³						
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						aTotais:=aClone(aTotAux)
						Aeval(aTotDia,{|x| aadd(aTotais,x)})
						aTotDia:={}												
					Endif	
				EndIF	
			EndIF
		EndIF
		
	EndIf
EndIf

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fCalcHExt³Autor³Fernando Joly Siquini 1a.Ver³Data³02/02/1998³±±
±±³          ³         ³Autor³Marinaldo de Jesus    2a.Ver³Data³22/07/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Calcula o Pagamento de Horas Extras com Tot. por Per¡odo.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³PONM070							       					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³lRet                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³<Vide Parametros Formais>									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fCalcHExt(	dPerIni 	,;
							dPerFim		,;
							aTotHExt	,;
							aTotHENt	,;
							aTotais		,;
							aTabCalend	,;
							aCodAut		,;
							lMvAcmHExt	,;
							cPerHext	,;
							nTolHePe	,;
							cMsgErr		,;
							cFilCCT		,;
							cCodCCT	;
						   )

Local lRet	:= .T.

Local aTabExtra
Local aExtAllTipos
Local aExtTipo
Local aCodTipos   
Local aTotAux	:= {}
Local aTotDia	:= {}
Local aTiposHE	:= {}

Local bBlkSorTot
Local bBlkAscData
Local bBlkAscCale
Local bBlkAscNData
Local bBlkAscNEven
Local bBlkAscNtData
Local bBlkAscNtEven

Local cTpoExtra
Local cStrTipos
Local cLastTpoExtra
Local cMemVarTpHe

Local dData

Local nLoop
Local nLoopTipo
Local nTipo
Local nCodAut
Local nCodsAut
Local nLenTipo
Local nTipDiurna
Local nTipNoturna
Local nPosTipo
Local nPosCalend
Local nPosData
Local nTolHExt
Local nPeriodo

DEFAULT cFilCCT := ""
DEFAULT cCodCCT := ""

Begin Sequence
	
	bBlkSorTot := { |x,y|	( x[ ATOTAIS_DTOS_DATA ] + x[ ATOTAIS_EVENTO_PONTO ] + x[ ATOTAIS_CENTO_DE_CUSTO ] );
	 						<;
	 						( y[ ATOTAIS_DTOS_DATA ] + y[ ATOTAIS_EVENTO_PONTO ] + Y[ ATOTAIS_CENTO_DE_CUSTO ] );
	 			  }
	
	aSort( aTotHExt , NIL , NIL , bBlkSorTot )
	aSort( aTotHENt , NIL , NIL , bBlkSorTot )
	
	IF ( cPerHext == "D" )
		
		nTipDiurna	:= Len( aTotHExt )
		nTipNoturna := Len( aTotHENt )
		
		For nTipo := 1 To nTipDiurna
			
			fGeraTot(	@aTotais									,;	//01 -> Array com os Totais do Ponto
						aTotHExt[ nTipo , ATOTAIS_DATA ]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
						aTotHExt[ nTipo , ATOTAIS_HORAS ]			,;	//03 -> Horas para Soma ou Geracao
						0											,;	//04 -> Valor para Soma ou Geracao
						aTotHExt[ nTipo , ATOTAIS_EVENTO_PONTO ]	,;	//05 -> Evento do Ponto para Pesquisa
						aTotHExt[ nTipo , ATOTAIS_CENTO_DE_CUSTO ]	,;	//06 -> Centro de Custo para Comparacao
						SRA->RA_FILIAL							 	 ;	//07 -> Filial para Pesquisa no SP9
					) 
					
		
		Next nTipo
		
		For nTipo := 1 To nTipNoturna
			
			fGeraTot(	@aTotais									,;	//01 -> Array com os Totais do Ponto
						aTotHENt[ nTipo , ATOTAIS_DATA ]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
						aTotHENt[ nTipo , ATOTAIS_HORAS ]			,;	//03 -> Horas para Soma ou Geracao
						0											,;	//04 -> Valor para Soma ou Geracao
						aTotHENt[ nTipo , ATOTAIS_EVENTO_PONTO ]	,;	//05 -> Evento do Ponto para Pesquisa
						aTotHENt[ nTipo , ATOTAIS_CENTO_DE_CUSTO ]	,;	//06 -> Centro de Custo para Comparacao
						SRA->RA_FILIAL							 	 ;	//07 -> Filial para Pesquisa no SP9
					)
					
		Next nTipo
		
		Break
		
	EndIF
	
	aCodTipos		:= {}
	aExtAllTipos	:= {}
	
	bBlkAscData		:= { |x| ( x[ ATOTAIS_DATA ] == dData ) }
	bBlkAscCale		:= { |x| ( x[CALEND_POS_DATA] == dData ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) }
	bBlkAscNData	:= { |x| ( ( dData == x[5] ) .and. ( aTotHExt[ nPosData , ATOTAIS_EVENTO_PONTO ] $ x[2] ) ) }
	bBlkAscNEven	:= { |x| ( aTotHExt[ nPosData , ATOTAIS_EVENTO_PONTO ] $ x[2] ) }
	bBlkAscNtData	:= { |x| ( ( dData == x[5] ) .and. ( aTotHENt[ nPosData , ATOTAIS_EVENTO_PONTO ] $ x[2] ) ) }
	bBlkAscNtEven	:= { |x| ( aTotHENt[ nPosData , ATOTAIS_EVENTO_PONTO ] $ x[2] ) }
	
	cTpoExtra		:= "__cTpoExtra__"
	cLastTpoExtra	:= "__cLastTpoExtra__"
	
	nTolHExt		:= nTolHePe
	nCodsAut		:= Len( aCodAut )
	nPeriodo		:= ( dPerFim - dPerIni )
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Reinicializa as Statics em ToScheduleOverTime()			  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	RstToScheduleOverTime()
	
	For nLoop := 0 To nPeriodo
		
		dData := ( dPerIni + nLoop )
		
		//-- Carrega Tabela de Horas Extras para o Turno da Data
		IF ( ( nPosCalend := aScan( aTabCalend, bBlkAscCale ) ) > 0 )
			IF !( lRet := GetTabExtra( @aTabExtra, SRA->RA_FILIAL, aTabCalend[ nPosCalend, CALEND_POS_TURNO ], .F., .T., NIL, NIL, @cMsgErr,,cFilCCT, cCodCCT ) )
				Break
			EndIF
		EndIF
		
		cStrTipos	:= fTpoExtra( dData , aClone( aTabCalend ) )
		If aScan(aTiposHE, {|x| x == cStrTipos}) == 0 // Se não carregou esses tipos de HE ainda
			/*/Acrescenta os tipos de hora extra de intervalo, 
			para serem calculadas as horas extras de intervalo/*/
			cStrTipos += "-"+GetTpExInt( SubStr( cStrTipos,1,1 ) , .F. ) + "-" + GetTpExInt( SubStr( cStrTipos,3,1 ), .T. )
			//Corre Cada um dos Tipos Presentes na string cStrTipos. Ex. '5-1-A-B' 
			For nLoopTipo := 1 To 7 Step 2
				//Obtem o Tipo de Hora Extra. Ex. '5' na primeira vez e '1' no segundo laco.
				cTpoExtra:= Substr(cStrTipos,nLoopTipo,1)
					
					//-- Obtem todas as Faixas de HE do Tipo Lido
					aExtTipo := GetExTipo( aTabExtra , @cTpoExtra )
					aAdd( aExtAllTipos , { cTpoExtra , aClone( aExtTipo ) } )
					nLenTipo := Len( aExtTipo )
					IF !( lRet := ( nLenTipo > 0 ) )
						Break
					EndIF
					
					// Cria a Variavel acumuladora do Tipo de HE
					cMemVarTpHe := ( "nHETp" + cTpoExtra )
					IF !IsMemVar( cMemVarTpHe )
						SetMemVar( cMemVarTpHe , 0 , .T. )
					EndIF
					
					//-- Corre Cada Faixa 
					For nTipo := 1 To nLenTipo
						//-- Gera Informacoes Adicionais para cada faixa 	
						IF ( ( nPosTipo := aScan( aCodTipos , { |x| ( x[1] == aExtTipo[ nTipo , 1 ] ) .and. ( x[5] == dData ) } ) ) == 0 )
							aAdd( aCodTipos , { aExtTipo[ nTipo , 1 ] , "" , {} , aClone( aTabExtra ) , dData } )
							nPosTipo := Len( aCodTipos )
						EndIF
						//-- Obtem todos os codigos de HE para o Tipo Lido
						For nCodAut := 1 To nCodsAut  
							If ( Ascan(aCodAut[ nCodAut , 14 ], aExtTipo[ nTipo , 1 ] ) <> 0 )
								IF !( aCodAut[ nCodAut , 1 ] $ aCodTipos[ nPosTipo , 2 ] )
									aCodTipos[ nPosTipo , 2 ] += ( aCodAut[ nCodAut , 1 ] + "/"  )
								EndIF
							EndIF
						Next nCodAut
					Next nTipo
			Next nLoopTipo
		EndIf
	Next nLoop
	
	If lRet
		For nLoop := 0 To nPeriodo
			
			dData		:= ( dPerIni + nLoop )
			
			//-- Carrega Tabela de Horas Extras para o Turno da Data
			IF ( ( nPosCalend := aScan( aTabCalend, bBlkAscCale ) ) > 0 )
				lRet := GetTabExtra( @aTabExtra, SRA->RA_FILIAL, aTabCalend[ nPosCalend, CALEND_POS_TURNO ], .F., .T., NIL, NIL, @cMsgErr,,cFilCCT, cCodCCT )
			EndIF
			
			nPosData := 0
			While ( ( nPosData := aScan( aTotHExt , bBlkAscData , ++nPosData ) ) > 0 )
				IF ( ( nPosTipo := aScan( aCodTipos , bBlkAscNData ) ) == 0 )
					IF ( ( nPosTipo := aScan( aCodTipos , bBlkAscNEven ) ) == 0 )
						Loop
					EndIF
				EndIF
				cMemVarTpHe := ( "nHETp" + aCodTipos[ nPosTipo , 1 ] )
				SetMemVar( cMemVarTpHe , __TimeSum( GetMemVar( cMemVarTpHe ) , aTotHExt[ nPosData , ATOTAIS_HORAS ] ) )
				aAdd( aCodTipos[ nPosTipo , 3 ] , { aTotHExt[ nPosData , ATOTAIS_HORAS ] , aTotHExt[ nPosData , ATOTAIS_CENTO_DE_CUSTO ], aTotHExt[ nPosData , ATOTAIS_DATA ], aTotHExt[ nPosData , ATOTAIS_EVENTO_PONTO ] } )
			End While
			
			nPosData := 0
			While ( ( nPosData := aScan( aTotHENt , bBlkAscData , ++nPosData ) ) > 0 )
				IF ( ( nPosTipo := aScan( aCodTipos , bBlkAscNtData ) ) == 0 )
					IF ( ( nPosTipo := aScan( aCodTipos , bBlkAscNtEven ) ) == 0 )
						Loop
					EndIF
				EndIF
				cMemVarTpHe := ( "nHETp" + aCodTipos[ nPosTipo , 1 ] )
				SetMemVar( cMemVarTpHe , __TimeSum( GetMemVar( cMemVarTpHe ) , aTotHENt[ nPosData , ATOTAIS_HORAS ] ) )
				aAdd( aCodTipos[ nPosTipo , 3 ] , { aTotHENt[ nPosData , ATOTAIS_HORAS ] , aTotHENt[ nPosData , ATOTAIS_CENTO_DE_CUSTO ], aTotHENt[ nPosData , ATOTAIS_DATA ], aTotHENt[ nPosData , ATOTAIS_EVENTO_PONTO ] } )
			End While
			
			IF ((( cPerHext == "S" ) .and. ( Dow( dData ) == 1 ));
				.or. (( cPerHext == "Q" ) .and. ( nLoop == 14 ));
				.or. (( cPerHext $ "SQM" ) .and. ( nLoop == nPeriodo )))
				
				aTotAux	:= aClone(aTotais)
				IF !( lRet := fGerHExt(;
											dData			,;
											@aTotais		,;
											aExtAllTipos	,;
											aCodTipos		,;
											nTolHExt		,;
											aTabCalend		,;
											lMvAcmHExt		,;
											cPerHext		,;
											aTotDia			;
										);
					)
					Break
				EndIF
				
				IF lPort1510
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Agrega horas extras diarias ao aTotais independe do periodo ³
					³ de apuracao.												  ³						
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					aTotais:=aClone(aTotAux)
					Aeval(aTotDia,{|x| aadd(aTotais,x)})
					aTotDia:={}
				Endif
				
			EndIF
			
		Next nLoop
	EndIf
	
End Sequence

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fGerHExt ³Autor³Marinaldo de Jesus          ³Data³22/07/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Efetua a Geracao de Horas Extras com Tot. por Per¡odo.   	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso  	 ³fCalcHExt() no PONM070			       					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³lRet                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³<Vide Parametros Formais>									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fGerHExt(	dData			,;
							aTotais 		,;
							aExtAllTipos	,;
							aCodTipos		,;
							nTolHExt		,;
							aTabCalend		,;
							lMvAcmHExt		,;
							cPerHext		,;
							aTotDia			;
						)

Local lRet := .T.

Local cCusto
Local cAuxCusto
Local cMemVarTpHe

Local nPosCalend
Local nTipo
Local nTipos
Local nHrCc
Local nHrCcs
Local nHrsAut	:= 0
Local nHrsNAut	:= 0

Local uRetBlock

Begin Sequence

	IF ( ( nPosCalend := aScan( aTabCalend, {|x| ( x[CALEND_POS_DATA] == dData ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } ) ) > 0 )
		cAuxCusto := aTabCalend[ nPosCalend , CALEND_POS_CC ]
		IF Empty( cAuxCusto )
			cAuxCusto := SRA->RA_CC
		EndIF
	EndIF
	
	IF ( lPoncalHeBlock )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³O Ponto de Entrada PONCALHE recebera como parametro o ParamIxb que eh um Ar³
		³ray com tres Elementos,sendo o Primeiro o Clone do Array aCodTipos, o    Se³
		³gundo o Clone do Array aTabCalend o Terceiro o Clone o Array aExtAllTipos. ³
		³Estarao disponiveis tambem as variaveis Privates nHetp? onde ?  corresponde³
		³aos tipos de Horas Extras 1, 2, 3, 4, 5,...A,B....					        ³
		³													  						³
		³Para Visualiza-los no Ponto de Entrada proceder da seguinte forma:			³
		³															  				³
		³User Function PonCalHe()									  				³
		³															  				³
		³Local __aCodTipos		:= aClone( ParamIxb[1] )				  			³
		³Local __aTabCalend 	:= aClone( ParamIxb[2] )				  			³
		³Local __aExtAllTipos	:= aClone( ParamIxb[3] )				  			³
		³Local cMemVarTpHe                             					  			³
		³Local nLoop                                  					  			³
		³Local nLoops                                  					  			³
		³Local nTipo                                  					  			³
		³Local nTipos                                  					  			³
		³...														  				³
		³//Verificando se as Variaveis Privates estao disponiveis					³
		³nTipos := Len( __aExtAllTipos )							  				³
		³For nTipo := 1 To nTipos									  				³
		³   nLoops := Len( __aExtAllTipos )											³
		³   For nLoop := 1 To nLoops								  				³
		³		cMemVarTpHe := ( "nHETp" + __aExtAllTipos[ nTipo , nLoop , 1 ] )	³
		³		SetMemVar( cMemVarTpHe , 0 )										³
		³	Next nLoop												  				³
		³Next nTipo													  				³
		³...															  			³
		³Return( aClone( __aCodTipos ) )				  				  			³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		uRetBlock := ExecBlock(;
									"PONCALHE",;
									.F.,;
									.F.,;
									{;
										aClone( aCodTipos 		),;
										aClone( aTabCalend 		),;
										aClone( aExtAllTipos	);
									},;
									.F.;
				 				)
		IF ( ValType( uRetBlock ) == "A" )
			aCodTipos := aClone( uRetBlock )
		EndIF
	EndIF

	nTipos := Len( aCodTipos )
	For nTipo := 1 To nTipos
		nHrCcs := Len( aCodTipos[ nTipo , 3 ] ) 
		
		For nHrCc := 1 To nHrCcs
			cMemVarTpHe := ( "nHETp" + aCodTipos[ nTipo , 1 ] )
			IF ( GetMemVar( cMemVarTpHe ) > nTolHExt )
				cCusto	:= IF( Empty( aCodTipos[ nTipo , 3 , nHrCc , 2 ] ) , cAuxCusto , aCodTipos[ nTipo , 3 , nHrCc , 2 ] )
				
				If Len(aCodTipos[nTipo, 3, nHrCc]) > 3 .And. !Empty(aCodTipos[nTipo, 3, nHrCc, 4])
					nHrsAut		:= If ((aScan(aCodTipos[nTipo, 4], {|x| x[4] == aCodTipos[nTipo, 3, nHrCc, 4]})) > 0, aCodTipos[nTipo, 3, nHrCc, 1], 0)
					nHrsNAut	:= If ((aScan(aCodTipos[nTipo, 4], {|x| x[5] == aCodTipos[nTipo, 3, nHrCc, 4]})) > 0, aCodTipos[nTipo, 3, nHrCc, 1], 0)
				Else
					nHrsAut		:= aCodTipos[nTipo, 3, nHrCc, 1]
					nHrsNAut	:= 0
				EndIf

				fGeraExtra(;
								aCodTipos[ nTipo , 4 ]				,; //01 -> Array contendo os Tipos de Horas Extras
								aCodTipos[ nTipo , 1 ]				,; //02 -> Tipo de Hora Extra a ser Gerado
								nHrsAut								,; //03 -> Numero de Horas Extras Autorizadas	
								nHrsNAut							,; //04 -> Numero de Horas Extras Nao Autorizadas	
								{}									,; //05 -> Array com os Resultados do Apontamento do Dia
								@aTotais							,; //06 -> Array com os Totais Apontados por Evento do Dia 
								dData								,; //07 -> Data da Gravacao
								"FEC"								,; //08 -> Rotina Chamadora da Funcao
								cPerHext							,; //09 -> Periodo de Apuracao 
								!( lMvAcmHExt )						,; //10 -> Soma ao Valor Existente
								cCusto								,; //11 -> Centro de Custo Para Gravacao
								NIL									,; //12 -> Tipo de Marcacao
								lMvAcmHExt							,; //13 -> Considerar Todas as Horas Extras do Dia Para o Escalonamento
								lMvAcmHExt							,; //14 -> Se Substitui as Horas Existentes
								/*cFuncao			*/				,; //15 -> Funcao para gravacao
								/*cDepto			*/				,; //16 -> Depto para gravacao
								/*cPosto			*/				,; //17 -> Posto para gravacao  
								/*cProcesso			*/ 				,; //18 -> Processo para Gravacao								
								/*cRoteiro			*/				,; //19 -> Roteiro para Gravacao
								/*cPeriodo			*/				,; //20 -> Periodo para Gravacao								
								/*cNumPagto			*/				,; //21 -> NumPagto para Gravacao	
								/*cTurno			*/ 				,; //22 -> Turno de Trabalho
								/*cSemana			*/				,; //23 -> Semana/Sequencia do Turno
								aTotDia								,; //24 -> Total Eventos  Diarios
								aCodTipos[ nTipo , 3, nHrCc, 3 ]   	;  //25 -> Data do Apontamento							
				)
			EndIF
		Next nHrCc
		aCodTipos[ nTipo , 3 ] := {}
	Next nTipo
	
	nTipos := Len( aExtAllTipos )
	For nTipo := 1 To nTipos
		aEval( aExtAllTipos[ nTipo , 2 ] , { |x| SetMemVar( ( "nHETp" + x[ 1 ] ) , 0 ) } )
	Next nTipo
	
End Sequence

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fCalRefeit ³ Autor ³ Equipe Advanced RH   ³ Data ³ 10/02/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula as refei‡”es do Funcion rio.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ PONM070							   						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³ Nil                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cFil     = String com a Filial do Funcion rio.             ³±±
±±³          ³ cMat     = String com a Matricula do Funcion rio.          ³±±
±±³          ³ aTotais  = Array multidimencional com os Totais.           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fCalRefeit( cFil, cMat, aTotais, aCodRef, cEveTotR )

Local nPos	:= 0
Local nHorIni  := 0
Local nHorFim  := 0
Local dDataIni := CtoD("")
Local dDataFim := CtoD("")

DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT aTotais 	:= {}
DEFAULT aCodRef 	:= {}
DEFAULT cEveTotR	:= ""

nHorIni  := aTabCalend[1][CALEND_POS_LIM_MARCACAO][2]
dDataIni := aTabCalend[1][CALEND_POS_LIM_MARCACAO][1]
nHorFim  := aTabCalend[Len(aTabCalend)][CALEND_POS_LIM_MARCACAO][2]
dDataFim := aTabCalend[Len(aTabCalend)][CALEND_POS_LIM_MARCACAO][1]

//-- Posiciona no Inicio das Marcacoes de Refeicao do Funcionario
If SP5->( dbSeek( cFil + cMat, .F.) )
    
	//-- Corre Marcacoes Refeicao para a Matricula Lida
	While ( SP5->( !Eof() .and. ( cFil + cMat ) == ( P5_FILIAL + P5_MAT ) ) )
		
		//-- Verifica se marcacao esta Dentro do periodo 
		IF SP5->( ( fDHtoNS(P5_DATA, P5_HORA) < fDHtoNS(dDataIni, nHorIni) ) .or. ( fDHtoNS(P5_DATA, P5_HORA) > fDHtoNS(dDataFim, nHorFim) ) )
		   SP5->( dbSkip() )
		   Loop
		EndIF
		
   	    //-- Verifica se Tipo de Refeicao esta Dentro do Intervalo de Tipos Escolhido
		IF SP5->(( P5_TIPOREF < cTipoRefDe ) .or. ( P5_TIPOREF > cTipoRefAte ) .or. (( P5_HORA == 0 ) .and. ( P5_VALREF == 0 )))
		   SP5->( dbSkip() )
		   Loop
		EndIF
		
		IF ( SP5->P5_GERAFOL ==	"S" )
		    //Calcula Desc.Refeicao Parte Funcionario 
			nPos := fGeraTot(	@aTotais		,;	//01 -> Array com os Totais do Ponto
								SP5->P5_DATA	,;	//02 -> Data para Pesquisa e Gravacao no aTotais
								1				,;	//03 -> Horas para Soma ou Geracao
								SP5->P5_DESCFUN	,;	//04 -> Valor para Soma ou Geracao
								SP5->P5_PD		,;	//05 -> Evento do Ponto para Pesquisa
								SP5->P5_CC		,;	//06 -> Centro de Custo para Comparacao
								SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
							)
			If ( ( nPos > 0 ) .and.( aScan( aCodRef, { |x| x == aTotais[ nPos, 04 ] } ) == 0 ) )
				aAdd( aCodRef, aTotais[ nPos, 04 ] )
			EndIf
		EndIf
		
		//-- Calcula Desc.Refeicao Parte Empresa
		nPos := fGeraTot(	@aTotais						,;	//01 -> Array com os Totais do Ponto
							SP5->P5_DATA					,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							1								,;	//03 -> Horas para Soma ou Geracao
							SP5->( P5_VALREF - P5_DESCFUN )	,;	//04 -> Valor para Soma ou Geracao
							SP5->P5_PDEMPR					,;	//05 -> Evento do Ponto para Pesquisa
							SP5->P5_CC						,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL	 				 ;	//07 -> Filial para Pesquisa no SP9
						)
		If ( ( nPos > 0 ) .and. aScan( aCodRef, { |x| x == aTotais[ nPos, 04 ] }) == 0 )
			aAdd( aCodRef, aTotais[ nPos, 04 ] )
		EndIf
		
		If !Empty(cEveTotR) .And. SP5->P5_VALREF > 0 // Gera a verba com o valor integral do vale refeição
			fGeraTot(	@aTotais						,;	//01 -> Array com os Totais do Ponto
						SP5->P5_DATA					,;	//02 -> Data para Pesquisa e Gravacao no aTotais
						1								,;	//03 -> Horas para Soma ou Geracao
						SP5->P5_VALREF					,;	//04 -> Valor para Soma ou Geracao
						NIL								,;	//05 -> Evento do Ponto para Pesquisa
						SP5->P5_CC						,;	//06 -> Centro de Custo para Comparacao
						SRA->RA_FILIAL	 				,;	//07 -> Filial para Pesquisa no SP9
						cEveTotR						 ;	//08 -> Verba da Folha
					)
		EndIf
		
		SP5->( dbSkip() )
		
	EndDo
	
EndIf

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fCalcBH    ³ Autor ³ Aldo Marini Junior   ³ Data ³ 20/11/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula os Eventos para Banco de Horas                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ PONM070				             						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³ Nil                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aTotais  = Array multidimencional com os Totais.           ³±±
±±³          ³ aBHAcum  = Array multidimencional com os Totais p/B.Horas  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fCalcBH(aTotais,aBHAcum,lInterm)

Local aRetBlock		:= {}
Local aAux			:= {}

Local cPerApur		:= "D"

Local dDatIni		:= Ctod("//")

Local lAcumBH		:= .F.
Local lAgrup		:= .F.

Local nPosBH		:= 0
Local nT			:= 0
Local nCt			:= 0
Local nPosE			:= 0
Local nValBH		:= 0
Local nValHoras		:= 0
Local nTBHoras		:= 0
Local nPos			:= 0
Local nValCalcB		:= 0
Local nValCalcF		:= 0
Local nT1			:= 0
Local nLenEveBh		:= 0
Local nLenBhAcum	:= 0
Local nTotais		:= 0
Local nAux			:= 0
Local nEveBH		:= 0
Local nPeriodo		:= 0
Local nX			:= 0
DEFAULT lInterm		:= .F.
Private aEveBh	:= {}

// Ordena o array por Evento+Data+Centro de Custo
aSort( aTotais , NIL , NIL , { |x,y| ;
									x[ATOTAIS_EVENTO_PONTO]		+;
									x[ATOTAIS_DTOS_DATA]		+;
									x[ATOTAIS_CENTO_DE_CUSTO] 	 ;
									<							 ;
									y[ATOTAIS_EVENTO_PONTO]		+;
									[ATOTAIS_DTOS_DATA]			+;
									y[ATOTAIS_CENTO_DE_CUSTO];
							};
		)

//-- Se Nao Acumula horas para B.Horas do Funcionario, entao totaliza eventos
IF !( lFuncAcBH )
	fTotEve( @aTotais,,lPort1510 ,lInterm)
	Return( .T. )
EndIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define os codigos do Eventos p/Banco de Horas                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nTotais := Len(aTotais)
For nT := 1 To nTotais
	If (;
			( aScan(aEveBH,  { |X| aTotais[nT,ATOTAIS_EVENTO_PONTO] == X[1] } ) == 0 );
			.and.;
	   		( ( nPosBH := aScan(aCodAut, { |X| x[1]== aTotais[nT,ATOTAIS_EVENTO_PONTO] .and.x[4] == "S" } )) > 0 );
	   	)	
		aAdd( aEveBH , Array( 09 ) )
		nLenEveBh := Len( aEveBH )
		aEveBH[ nLenEveBh , 01 ] := aTotais[nT,ATOTAIS_EVENTO_PONTO]	// 1 - Codigo do Evento
		aEveBH[ nLenEveBh , 02 ] := aCodAut[nPosBH,05]  				// 2 - Periodo de Apuracao
		aEveBH[ nLenEveBh , 03 ] := aCodAut[nPosBH,06]  				// 3 - Numero de Horas De
		aEveBH[ nLenEveBh , 04 ] := aCodAut[nPosBH,07]  				// 4 - Numero de Horas Ate
		aEveBH[ nLenEveBh , 05 ] := aCodAut[nPosBH,08]  				// 5 - Percentual de Valorizacao do Evento
		aEveBH[ nLenEveBh , 06 ] := aCodAut[nPosBH,09]  				// 6 - Agrupa Evento (S/N)
		aEveBH[ nLenEveBh , 07 ] := aCodAut[nPosBH,10]  				// 7 - Valores Totais ou Proporcional a Faixa
		aEveBH[ nLenEveBh , 08 ] := aCodAut[nPosBH,11]  				// 8 - Percentual para Banco de Horas
		aEveBH[ nLenEveBh , 09 ] := aCodAut[nPosBH,12]  				// 9 - Percentual para Folha de Pagto
		If ( aCodAut[nPosBH,9] == "S" )
			lAgrup:= .T.
		Endif
	Endif
Next

// Apuracao p/ BH quando Evento for Apuracao c/Agrupamento
If ( lAgrup )
	aAux:={}
	nTotais := Len(aTotais)
	For nT := 1 To nTotais
		// x[1] - Codigo do Evento
		// x[2] - Acumula Banco de Horas
		// x[3] - Agrupa Lancamentos
		If ( aScan(aCodAut, { |x| x[1] == aTotais[nT,ATOTAIS_EVENTO_PONTO] .and. x[4] == "S" .and. x[9] == "S" }) > 0 )
			aAdd(aAux,{aTotais[nT,ATOTAIS_DATA], aTotais[nT,ATOTAIS_EVENTO_PONTO], aTotais[nT,ATOTAIS_HORAS], nT })
		Endif
	Next nT

	IF ( ( nPercAgBh + nPercAgFl ) > 0 )
		nAux := Len(aAux)
		For nCt := 1 To nAux

			nValCalcB := 0
            nValCalcF := 0
                
			// Percentual para Banco de Horas
			nValCalcB := Round(fConvHr(aTotais[aAux[nCt,4],ATOTAIS_HORAS],"D")*(nPercAgBh/100),2)
			nValCalcB := fConvhr(nValCalcB,"H")
                
			// Percentual para Folha
			nValCalcF := Round(fConvHr(aTotais[aAux[nCt,4],ATOTAIS_HORAS],"D")*(nPercAgFl/100),2)
			nValCalcF := fConvhr(nValCalcF,"H")
                
			If ( ( nPercAgBh + nPercAgFl ) == 100 )
               	If nValCalcB > 0
					If ( cArrCalc == "F" )
						nValCalcF := __TimeSub( aTotais[aAux[nCt,4],ATOTAIS_HORAS],nValCalcB)
					Else
                        nValCalcB := __TimeSub( aTotais[aAux[nCt,4],ATOTAIS_HORAS],nValCalcF)
					Endif
				Endif
			Else
				If ( cArrCalc == "F" )
					If ( ( nValCalcF > 0 ) .and. ( nValCalcB == 0 ) )
						nValCalcF := __TimeSub( aTotais[aAux[nCt,4],ATOTAIS_HORAS],nValCalcF)
					Endif
				Else
					If ( ( nValCalcB > 0 ) .and. ( nValCalcF == 0 ) )
                        nValCalcB := __TimeSub( aTotais[aAux[nCt,4],ATOTAIS_HORAS],nValCalcB)
					Endif
				Endif
			Endif

            If ( nValCalcF > 0 )
   				aTotais[aAux[nCt,4],ATOTAIS_HORAS] := nValCalcF
   			Else
				aTotais[aAux[nCt,4],ATOTAIS_HORAS] := 0
   			Endif
            
			If ( nValCalcB > 0 )
				If ( ( nPos := aScan(aBHAcum, {|x| x[1] == aTotais[aAux[nCt,4],ATOTAIS_DATA] .and.x[2] == aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO] .and.x[5] == aTotais[aAux[nCt,4],ATOTAIS_CENTO_DE_CUSTO] } ) ) > 0 )
					aBHAcum[nPos,3] := __TimeSum(aBHAcum[nPos,3],nValCalcB)
				Else
					aAdd( aBHAcum , Array( 07 ) )
					nLenBhAcum := Len( aBHAcum )
					aBHAcum[ nLenBhAcum , 01 ] := aTotais[aAux[nCt,4],ATOTAIS_DATA]
					aBHAcum[ nLenBhAcum , 02 ] := aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO]
					aBHAcum[ nLenBhAcum , 03 ] := nValCalcB
					IF ( (nPosE:=aScan(aEveBH, { |X| aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO] == X[1] } ) ) > 0 )
						aBHAcum[ nLenBhAcum , 04 ] := aEveBH[nPosE,5]
					Else
						aBHAcum[ nLenBhAcum , 04 ] := 0
					Endif
					aBHAcum[ nLenBhAcum , 05 ] := aTotais[aAux[nCt,4],5]
					aBHAcum[ nLenBhAcum , 06 ] := aTotais[aAux[nCt,4],ATOTAIS_TIPOHE ]					
					aBHAcum[ nLenBhAcum , 07 ] := aTotais[aAux[nCt,4],ATOTAIS_PERCENT]					
					IF ( nValCalcF <= 0 )
						aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO] := Space(3)
					EndIF	
				EndIf
			Endif

		Next nCt

	Else

		// Soma os eventos e verifica se fara parte do Banco de Horas
		// Quando o Tipo For 1 - Provento ou 3 Base sera somado como Provento
		// Quando o Tipo For 2 - Desconto Sera somado como Desconto

		// Horas Normais
		aEval(	aAux, {	|x|	IF(	PosSP9( x[2] , SRA->RA_FILIAL , "P9_TIPOCOD" , 1 , .F. ) $ "1*3",;
							 		nTBHoras :=__TimeSum(nTBHoras,x[3]),;
							 		nTBHoras :=__TimeSub(nTBHoras,x[3]);
							   );
					   };
			  )

		nTBHoras := Abs( nTBHoras )

		nA := 1
		IF ( nTBHoras > 0 )
			//--Procura a faixa de horas
			If ( ( nTBHoras >= nBHDe ) .and. ( nTBHoras <= nBHAte ) )
				nAux := Len(aAux)
				For nCt := 1 To nAux
					If ( nPos := aScan(aBHAcum, {|x| x[1] == aTotais[aAux[nCt,4],ATOTAIS_DATA] .and.x[2] == aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO] .and.x[5] == aTotais[aAux[nCt,4],ATOTAIS_CENTO_DE_CUSTO] } ) ) > 0
						aBHAcum[nPos, 3] := __TimeSum(aBHAcum[nPos,3],aTotais[aAux[nCt,4],ATOTAIS_HORAS])
					Else
						aAdd( aBHAcum , Array( 07 ) )
						nLenBhAcum := Len( aBHAcum )
						aBHAcum[ nLenBhAcum , 01 ] := aTotais[aAux[nCt,4],ATOTAIS_DATA]
						aBHAcum[ nLenBhAcum , 02 ] := aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO]
						aBHAcum[ nLenBhAcum , 03 ] := aTotais[aAux[nCt,4],ATOTAIS_HORAS]
						IF (nPosE:=aScan(aEveBH, { |X| aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO] == X[1] } ) ) > 0
							aBHAcum[ nLenBhAcum , 04 ] := aEveBH[nPosE,5]
						Else
							aBHAcum[ nLenBhAcum , 04 ] := 0
						Endif
						aBHAcum[ nLenBhAcum , 05 ] := aTotais[aAux[nCt,4],ATOTAIS_CENTO_DE_CUSTO]   
						aBHAcum[ nLenBhAcum , 06 ] := aTotais[aAux[nCt,4],ATOTAIS_TIPOHE ]					
						aBHAcum[ nLenBhAcum , 07 ] := aTotais[aAux[nCt,4],ATOTAIS_PERCENT]								
					EndIf
					aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO] := Space(3)
				Next nCt
			Endif
		Endif
	Endif
Endif

// Apuracao p/ BH quando Evento for Apuracao Independente
nEveBH := Len(aEveBH)
For nT:=1 To nEveBH
	
	If ( aEveBH[nT,6] == "S" )
		Loop
	Endif
	
	dDatIni  := dPerIni
	nTBHoras := 0
	cPerApur := aEveBH[nT,2]
	lAcumBH  := .F.

	If ( ( aEveBH[nT,8] + aEveBH[nT,9] ) > 0 )
		nTotais := Len(aTotais)
		For nT1 := 1 To nTotais
			If ( aEveBH[nT,1] == aTotais[nT1,ATOTAIS_EVENTO_PONTO] )

				nValCalcB := 0
                nValCalcF := 0
                
				// Percentual para Banco de Horas
				nValCalcB := Round(fConvHr(aTotais[nT1,ATOTAIS_HORAS],"D")*(aEveBH[nT,8]/100),2)
				nValCalcB := fConvhr(nValCalcB,"H")

				// Percentual para Folha
				nValCalcF := Round(fConvHr(aTotais[nT1,ATOTAIS_HORAS],"D")*(aEveBH[nT,9]/100),2)
				nValCalcF := fConvhr(nValCalcF,"H")

                If ( ( aEveBH[nT,8] + aEveBH[nT,9] ) == 100 )
	               	If ( nValCalcB > 0 )
						If ( cArrCalc == "F" )
							nValCalcF := __TimeSub( aTotais[nT1,ATOTAIS_HORAS],nValCalcB)
						Else
	                        nValCalcB := __TimeSub( aTotais[nT1,ATOTAIS_HORAS],nValCalcF)
						Endif
					Endif
				Else
					If ( cArrCalc == "F" )
						If ( ( nValCalcF > 0 ) .and. ( nValCalcB == 0 ) )
							nValCalcF := __TimeSub( aTotais[nT1,ATOTAIS_HORAS],nValCalcF)
						Endif
					Else
						If ( ( nValCalcB > 0 ) .and. ( nValCalcF == 0 ) )
	                        nValCalcB := __TimeSub( aTotais[nT1,ATOTAIS_HORAS],nValCalcB)
						Endif
					Endif
                Endif
                 
				If ( nValCalcB > 0 )
					If ( nPos := aScan(aBHAcum, {|x| x[1] == aTotais[nT1,ATOTAIS_DATA] .and.x[2] == aTotais[nT1,ATOTAIS_EVENTO_PONTO] .and.x[5] == aTotais[nT1,ATOTAIS_CENTO_DE_CUSTO] } ) ) > 0
						aBHAcum[nPos,3] := __TimeSum(aBHAcum[nPos,3],nValCalcB)
					Else
						aAdd(aBHAcum,{ aTotais[nT1,ATOTAIS_DATA]			,; //01 - Data
									   aTotais[nT1,ATOTAIS_EVENTO_PONTO]	,; //02 - Evento
									   nValCalcB							,; //03 - Horas
									   aEveBH[nT,5]							,; //04 - % Valorizacao
									   aTotais[nT1,ATOTAIS_CENTO_DE_CUSTO]	,; //05 - Centro de Custo
									   aTotais[nT1,ATOTAIS_TIPOHE ]			,; //06 - Tipo de Horas Extras				
									   aTotais[nT1,ATOTAIS_PERCENT]	 		;  //07 - Percentual Pagto									   
									  };
							 )
					EndIf
				Endif

	            If ( nValCalcF > 0 )
	   				aTotais[nT1,ATOTAIS_HORAS] := nValCalcF
	   			Else
					aTotais[nT1,ATOTAIS_HORAS] 			:= 0
					aTotais[nT1,ATOTAIS_EVENTO_PONTO]	:= Space(3)
	   			Endif

			Endif		
		Next
	Else

		nPeriodo := ( dPerFim - dPerIni )
		For nX := 0 To nPeriodo
			dData := dPerIni + nX
			aEval(aTotais, {|x| If(x[ATOTAIS_DATA]==dData .and.x[ATOTAIS_EVENTO_PONTO]==aEveBH[nT,1],;
							   nTBHoras:=__TimeSum(nTBHoras,x[ATOTAIS_HORAS]), Nil)})
			If (;
					( cPerApur ==  "D" );
					.or.;
					( ( cPerApur == "S" ) .and. ( Dow(dData) == 1 ) );
					.or.;
					( ( cPerApur == "Q" ) .and. ( nX == 14 ) );
					.or.;
					( ( cPerApur $ "DSQM" ) .and. ( nX == nPeriodo ) );
				)	
	
				// Calcula Horas para Banco
				If nTBHoras >= aEveBH[nT,3] .and.nTBHoras <= aEveBH[nT,4]
					lAcumBH := .T.
					If aEveBH[nT,7] == "P"
						nTBHoras := If(aEveBH[nT,3] > 0.01,__TimeSub(nTBHoras,aEveBH[nT,3]),nTBHoras)
					Endif
				ElseIf nTBHoras > aEveBH[nT,4] .and.aEVeBH[nT,7] == "P"
					lAcumBH := .T.
					nTBHoras := If(aEveBH[nT,3] == 0.01,aEveBH[nT,4],__TimeSub(aEveBH[nT,4],aEveBH[nT,3]))
				Endif
	            
	           	/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Ponto de Entrada para BH com tratamento Parcial                  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				IF ( lPnmBh01Block )
					IF ( ValType( aRetBlock := ExecBlock("PNM070BH01",.F.,.F.,{dData, cPerApur, aEveBH[nT,1], aClone(aTotais), aClone(aBHAcum), aClone(aEveBH), lAcumBH, nTBHoras}) ) == "A" )
					   aTotais		:= If( ValType(aRetBlock[1]) == "A", aRetBlock[1] , aTotais	)
					   aBHAcum		:= If( ValType(aRetBlock[2]) == "A", aRetBlock[2] , aBHAcum	)
					   lAcumBH		:= If( ValType(aRetBlock[3]) == "L", aRetBlock[3] , lAcumBH	)
					   nTBHoras		:= If( ValType(aRetBlock[4]) == "N", aRetBlock[4] , nTBHoras	)
					EndIF
				EndIF
	
				If ( lAcumBH )
					lAcumBH	:= .F.
					nValBh 	:= 0
					nCt    	:= 1
					nTotais := Len(aTotais)
					While ( ( nValBh <= nTBHoras ) .and. ( nCt <= nTotais ) )
						If (;
								( aTotais[nCt,ATOTAIS_EVENTO_PONTO] == aEveBH[nT,1] );
								.and.;
								( dDatIni <= aTotais[nCt,ATOTAIS_DATA] );
								.and.;
								( dData >= aTotais[nCt,ATOTAIS_DATA] );
							)	
							nValHoras := aTotais[nCt,ATOTAIS_HORAS]
							nValBh    := __TimeSum(nValBh,aTotais[nCt,ATOTAIS_HORAS])
							If ( nValBh > nTBHoras )
								nValHoras := __TimeSub(nValBh,nTBHoras)
								nValHoras := __TimeSub(aTotais[nCt,ATOTAIS_HORAS],nValHoras)
								aTotais[nCt,ATOTAIS_HORAS]	:= __TimeSub( aTotais[nCt,ATOTAIS_HORAS],nValHoras)
							Endif
	
							If ( ( nPos := aScan(aBHAcum, {|x| x[1] == aTotais[nCt,ATOTAIS_DATA] .and.x[2] == aTotais[nCt,ATOTAIS_EVENTO_PONTO] .and.x[5] == aTotais[nCt,ATOTAIS_CENTO_DE_CUSTO] } ) ) > 0 )
								aBHAcum[nPos,3] := __TimeSum(aBHAcum[nPos,3], aTotais[nCt,ATOTAIS_HORAS] )
							Else
								aAdd(aBHAcum,{ 	aTotais[nCt,ATOTAIS_DATA]			,; //01 - Data
												aTotais[nCt,ATOTAIS_EVENTO_PONTO]	,; //02 - Evento
												nValHoras							,; //03 - Horas
												aEveBH[nT,5]						,; //04 - % Valorizacao
												aTotais[nCt,ATOTAIS_CENTO_DE_CUSTO]	,; //05 - Centro de Custo 
											    aTotais[nCt,ATOTAIS_TIPOHE ]		,; //06 - Tipo de Horas Extras				
											    aTotais[nCt,ATOTAIS_PERCENT]		;  //07 - Percentual Pagto									   												
											  };
								    )
							EndIf
	
							If ( nValBh <= nTBHoras )
								aTotais[nCt,ATOTAIS_EVENTO_PONTO] := Space(3)
							Endif
	
						Endif
						nCt++
					End While
				Endif
				nTBHoras	:= 0
				dDatIni		:= dData + 1
			EndIf
		Next nX
	Endif
Next nT

fTotEve( @aTotais,,lPort1510 ,lInterm)

Return( .T. )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fTotEve	  ³ Autor ³ Marinaldo de Jesus    ³ Data ³11/05/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Totalizacao dos Eventos                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aTotais - Array com os Eventos                              ³
³          ³lCodFol - Totalizar pelos Codigos da Folha                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aTotais                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³PONM070                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fTotEve( aTotais , lFolha, lData ,lInterm)

Local aTotAux	:= aClone( aTotais )
Local bBlkTot	:= { || NIL  }
Local bBlkSor	:= { || NIL }
Local nT		:= 0
Local nPos		:= 0
Local nLenTot	:= Len( aTotAux )

DEFAULT	lData	:= .F.
DEFAULT lInterm	:= .F.

aTotais := {}

IF ( lFolha := IF( ( lFolha == NIL ) .or. ( ValType( lFolha ) != "L" ) , .F. , lFolha ) )
	bBlkTot := { |e|	( e[ ATOTAIS_CODIGO_FOLHA ] == aTotAux[ nT , ATOTAIS_CODIGO_FOLHA ] );
					  	.and.;
					  	( e[ ATOTAIS_CENTO_DE_CUSTO ] == aTotAux[ nT , ATOTAIS_CENTO_DE_CUSTO ] );
					  	.and. (;
					  	( e[ ATOTAIS_CODIGO_FOLHA ] <> cEveFal .or. cPaisLoc <> "BRA" .or. !lSegFaltas );
					  	 .or. ;
					  	( e[ ATOTAIS_CODIGO_FOLHA ] == cEveFal .and. cPaisLoc == "BRA" .and. lSegFaltas .and. e[ ATOTAIS_DATA ] == aTotAux[ nT , ATOTAIS_DATA ] );
					  	);
					  	.and. (;
					  	( cPaisLoc <> "BRA" .or. !lInterm );
					  	 .or. ;
					  	( cPaisLoc == "BRA" .and. lInterm .and. e[ ATOTAIS_DATA ] == aTotAux[ nT , ATOTAIS_DATA ] );
					  	);
			   }
	bBlkSor := { |x,y|	( x[ ATOTAIS_CODIGO_FOLHA ] + x[ ATOTAIS_DTOS_DATA ] + x[ ATOTAIS_CENTO_DE_CUSTO ] );
						<;
						( y[ ATOTAIS_CODIGO_FOLHA ] + y[ ATOTAIS_DTOS_DATA ] + Y[ ATOTAIS_CENTO_DE_CUSTO ] );
				}
Else
	bBlkTot := { |e| 	 IF(  ( lData), ;
							   (	e[ ATOTAIS_DATA ] == aTotAux[ nT , ATOTAIS_DATA ]  ),;
								.T.;
						 	 );	
	                     .and.;
						( e[ ATOTAIS_EVENTO_PONTO ] == aTotAux[ nT , ATOTAIS_EVENTO_PONTO ] );
						.and.;
						( e[ ATOTAIS_CENTO_DE_CUSTO ] == aTotAux[ nT , ATOTAIS_CENTO_DE_CUSTO ] );
					  	.and. (;
					  	( e[ ATOTAIS_CODIGO_FOLHA ] <> cEveFal .or. cPaisLoc <> "BRA" .or. !lSegFaltas );
					  	 .or. ;
					  	( e[ ATOTAIS_CODIGO_FOLHA ] == cEveFal .and. cPaisLoc == "BRA" .and. lSegFaltas  .and. e[ ATOTAIS_DATA ] == aTotAux[ nT , ATOTAIS_DATA ] );
					  	);
					  	.and. (;
					  	( cPaisLoc <> "BRA" .or. !lInterm );
					  	 .or. ;
					  	( cPaisLoc == "BRA" .and. lInterm .and. e[ ATOTAIS_DATA ] == aTotAux[ nT , ATOTAIS_DATA ] );
					  	);
				}
	bBlkSor := { |x,y|	( x[ ATOTAIS_EVENTO_PONTO ] + x[ ATOTAIS_DTOS_DATA ] + x[ ATOTAIS_CENTO_DE_CUSTO ] );
	 					<;
	 					( y[ ATOTAIS_EVENTO_PONTO ] + y[ ATOTAIS_DTOS_DATA ] + Y[ ATOTAIS_CENTO_DE_CUSTO ] );
	 			}
EndIF

For nT := 1 To nLenTot
	If !Empty( aTotAux[ nT , ATOTAIS_EVENTO_PONTO ] ) .Or. (!Empty(cEveTotR) .And. aTotAux[ nT, ATOTAIS_CODIGO_FOLHA] == cEveTotR)
		If (( nPos := aScan( aTotais, bBlkTot )) > 0 )
			aTotais[ nPos , ATOTAIS_HORAS	] := __TimeSum( aTotais[ nPos , ATOTAIS_HORAS ] , aTotAux[ nT , ATOTAIS_HORAS ] )
			aTotais[ nPos , ATOTAIS_VALOR	] := ( aTotais[ nPos , ATOTAIS_VALOR ] + aTotAux[ nT , ATOTAIS_VALOR ] )
		Else
			aAdd( aTotais , aClone( aTotAux[ nT ] ) )
		EndIF
	EndIF
Next nT

aSort( aTotais , NIL , NIL , bBlkSor  )

Return( aTotais )

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ fDescDsr  ³ Autor ³Equipe Advanced RH     ³ Data ³20/01/1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcular o Desconto de DSR.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ < Vide Parametros Formais >								   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ < Vide Parametros Formais >								   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Apontamento                                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fDescDsr(	aResult		,; //Array com os resultados do apontamento
							aTabCalend	,; //Array com Calendario do turno
							aCodigos	,; //Array com os C¢digos de Eventos
							aArred_D	,; //Array com os Arredondamentod para DSR
							cPeriodo	,; //Indica o per¡odo para calculo (S, Q ou M)      
							dPerini		,; //Periodo Inicial do Apontamento
							dPerFim		,; //Periodo Final   do Apontamento
							aTotais		,; //Array com os resultados do calculo mensal
							lDsrProp	,; //Verifica se o Desconto Sera Baseado no Arredondamento ou em 1 Dia de Trabalho
							lLimDSR     ,; //Indica se Limita Desc de DSR ao Periodo de Apuracao do Mesmo.
							lDsrPPer	,; //Verifica se sera Gerado Evento para desconto de DSR no Proximo Periodo
							aAbonosPer	,; //Array com Todos os Abonos do Periodo para o Funcionario
							cDescDSR	,; //Conteudo do Campo PA_DESCDSR	
							nNumAtra	,; //Conteudo do Campo PA_NUMATRA	
							lMvDDSRFer	,; //Define se realiza o desconto para dias de Feriado
							lArredTno	;  //Define se o desconto do DSR deve validar arredondamento por turno
						 )

Local cFilSP6    	:= fFilFunc( "SP6" )
Local nDiaDSR	 	:= HrsSem2OneDsr( SRA->RA_HRSEMAN )	//-- Calcula o Dia de DSR que corresponde a um Dia de Trabalho do Funcionario

Local aAbonos  
Local aRetBlock
Local aTabPer   //Contem os dias agrupados pela quantidade de partes definidas pelo periodo de apuracao
Local cTipo
Local cDSR
Local cDSRMS
Local cEveDDSR
Local cAbonaDesc
Local cContDSR	:= ""
Local dData
Local dDataAux	:= CtoD("")
Local dIniSemana:= CtoD("")
Local dFimSemana:= CtoD("")
Local dProxPer
Local lTrabaFer   
Local lExecPad	:= .T.
Local nDesc
Local nHoras
Local nHrsOcorr
Local nHrsOcoBp
Local nNumOcorr
Local nNumOcoBp
Local nGravaDesc
Local nPos
Local nPosDia
Local nAbono
Local nAbonos
Local nHrsEfetAbono
Local nHrsDSRAnt := 0
Local nHrsAbo
Local nResult
Local nResults
Local nPeriodo
Local nPeriodos
Local nNextPer
Local nPerItem
Local nPerItens
Local nArred
Local nArreds   
Local nContDSR 	:= 0       
Local lDescDSR 	:= .F.
Local lTemDsRAnt:= .F.
Local nDSRPri  	:= 0
Local nProxPer 	:= 0
Local nDiasFer	:= 0
Local nHorasAux	:= 0
Local aBkpArred	:= aClone(aArred_D)
Local lCarrega	:= .F.
Local lAbDescDSR:= .F.
Local cFilSPD	:= ""
Local dProxDSR	:= cToD("//")
Local lTemFeria	:= .F.
Local lVerFeria	:= .F.
Local dDtIniPer	:= cToD(" / / ")
Local dDtFeriad	:= cToD(" / / ")
local nLoopDia	:= 0

Begin Sequence
	
	//-- Variaveis ja inicializadas
	cPeriodo := IF( cPeriodo == NIL .or. Empty( cPeriodo ) , "S" , cPeriodo )
	
	DEFAULT lDsrPPer	:= .T.
	
	//-- Verifica se existe o Evento para desconto do D.S.R. no Mes
	IF ( ( nPos := aScan( aCodigos , { |x| x[2] == IF( ( cDescDSR == "S" ) , "018A" , "017N" ) } ) ) == 0 )
		//'O Calculo de Desconto de DSR nao Foi Efetuado'###'Verifique se Existem Eventos para os Identificadores 018A e 017N'
		IF ( aScan( aLogDet , { |x| ( x == ( STR0025 + " " + STR0024 ) ) } ) == 0 )
			aAdd( aLogDet , ( STR0025 + " " + STR0024 ) )
		EndIF
		Break
	EndIF
	//-- Definicao do Evento para desconto do D.S.R. no Mes
	cDSR := aCodigos[nPos,1]
	
	//-- Verifica se existe o Evento para desconto do D.S.R. no Mes Seg
	IF ( ( nPos := aScan( aCodigos , { |x| x[2] == IF( ( cDescDSR == "S" ) , "022A" , "021N" ) } ) ) == 0 )
		//'O Calculo de Desconto de DSR nao Foi Efetuado'###'Verifique se Existem Eventos para os Identificadores 022A e 021N'
		IF ( aScan( aLogDet , { |x| ( x == ( STR0025 + " " +STR0018 ) ) } ) == 0 )
			aAdd( aLogDet , ( STR0025 + " " +STR0018 ) )
		EndIF	
		Break
	EndIF
	//-- Definicao do Evento para desconto do D.S.R. no Mes Seg
	cDSRMS := aCodigos[nPos,1]
	
	//-- Defini‡„o das Verbas que tenham Incidencia para Desconto de D.S.R.
	cEveDDSR := ""
	aEval(aCodigos, { |x| cEveDDSR += IF( ( x[3] == "S" ) , x[1] + "ú" , "" ) } )
	IF ( Len( cEveDDSR ) == 0 )
		//'O Calculo de Desconto de DSR nao Foi Efetuado'###'Nao Existem Eventos com Incidencia para DSR. Acerte as Incidencias no Cadastro de Eventos (SP9)'
		IF ( aScan( aLogDet , { |x| ( x == ( STR0025 + " " + STR0023 ) ) } ) == 0 )
			aAdd( aLogDet , ( STR0025 + " " + STR0023 ) )
		EndIF
		Break
	EndIF
	
	//-- Monta o calendario dividido em per¡odos de APURACAO ( S, Q ou M )
	aTabPer	:= {}
	aAdd( aTabPer , {} )
	nPeriodos	:= ( dPerFim - dPerIni )
	dData		:= ( dPerIni - 1 )
	dProxPer	:= ( dPerFim + 1 )
	nArreds		:= Len( aArred_D )
	dProxDSR	:= If(Dow(dPerIni) == 1, dPerIni, dPerIni + (8 - Dow(dPerini)))
	
	For nPeriodo := 0 To nPeriodos
		
		++dData
		
		cTipo := "N"
		
		//-- Variavel para Abonar Desconto em DSR ocorridos apos a Demmissao ou Durante o periodo de
		//-- Afastamento
		cAbonaDesc	:= ""
		
		//-- Desconsidera Datas Superiores a Demissao
		IF SRA->( !Empty(RA_DEMISSA) .And. (RA_DEMISSA < dData .Or. (cPeriodo == "S" .And. RA_DEMISSA < dProxDSR)))
			cAbonaDesc := "A"
		EndIF
		
		IF ( ( nPos := aScan( aTabCalend , { |x| ( ( x[1] == dData ) .and. ( x[4] == "1E" ) ) } ) ) > 0 )
			
			//-- Verifica se Funcionario Esta afastado na Data
			IF ! lDesDSRAfa .And. ( lAfasta := aTabCalend[ nPos, CALEND_POS_AFAST ] )
				IF (( dData >= aTabCalend[ nPos , CALEND_POS_INI_AFAST ] ) .And. (dData <= IF( Empty( aTabCalend[ nPos , CALEND_POS_FIM_AFAST ] ) , dData , aTabCalend[ nPos , CALEND_POS_FIM_AFAST ] ) ))	
					cAbonaDesc := "A"
				EndIF
			EndIF
			
			//Verifica se funcionario Trabalha em dias feriados
			lTrabaFer := aTabCalend[ nPos , CALEND_POS_TRAB_FERIADO ]
			If ( !( lTrabaFer ) .and. aTabCalend[ nPos , CALEND_POS_FERIADO ] .and. ( aTabCalend[ nPos , CALEND_POS_EXCECAO ] # "E" ))  
				//- Se Desconta DSR para Feriado  
				If lMvDDSRFER
					cTipo := "F"   
				//- Se Nao Desconta DSR para Feriado mas o Feriado e o DSR ocorrem no mesmo dia
				//- Forca desconto somente do DSR
				ElseIF ( aTabCalend[ nPos, CALEND_POS_TIPO_ORIG_DIA ] == "D" ) 
					cTipo:= "D"
				Endif	
			ElseIF ( aTabCalend[ nPos, If( lDesDSRAfa, CALEND_POS_TIPO_ORIG_DIA, CALEND_POS_TIPO_DIA) ] == "D" ) 
				cTipo := "D"
			EndIF
		EndIF
		
		aAdd( aTabPer[Len(aTabPer)], {dData, cTipo, 0, cAbonaDesc, Iif( nPos > 0, aTabCalend[nPos, CALEND_POS_TURNO], "" )})
		
		IF (((( cPeriodo == "S") .And. (Dow(dData) == 1)) .or. ((cPeriodo == "Q") .And. (nPeriodo == 14 ))) .And. (nPeriodo < nPeriodos))	
			aAdd( aTabPer , {} )
			If cPeriodo == "S"
				dProxDSR := dData + 7
			EndIf
		EndIF
		
	Next nPeriodo
	
	//-- Obtem o Numero de Elementos do aResult
	nResults := Len( aResult )

	//-- Verificar se houve desconto de DSR na semana para não lançar o desconto duas vezes. Apenas quando parâmetro MV_DSRPPER estiver com "N"
	If !lDsrPPer .And. Len(aTabPer) > 0
		If (nPosDia := aScan(aTabPer[1],{|x| x[2] == "D"})) > 0
			dIniSemana := dPerIni
			dFimSemana := aTabPer[1,nPosDia,1]
			fCarSemAnt(@dIniSemana,@dFimSemana)
			lTemDsRAnt := fVerDsrSem(SRA->RA_FILIAL,SRA->RA_MAT,dIniSemana,dFimSemana,aCodigos)
		EndIf
	EndIf

	//-- Processa individualmente cada Per¡odo do Calend rio
	nPeriodos := Len( aTabPer )
	For nPeriodo := 1 To nPeriodos
		If !lDsrPPer .And. lTemDsRAnt .And. nPeriodo == 1
			If Len(aTabPer[nPeriodo]) < 7
				lTemDsRAnt := .F.
				Loop
			EndIf
		EndIf
		
		nGravaDesc	:= nDSRPri 
		nDSRPri	:= 0
		nNextPer	:= ( nPeriodo + 1 )
		nHrsDSRAnt  := 0
		
		//-- Soma as ocorrências de Verbas com Desconto para D.S.R. no Período
		nPerItens := Len( aTabPer[ nPeriodo ] )
		For nPerItem := 1 To nPerItens
			dData	:= aTabPer[ nPeriodo , nPerItem , 1 ]
			//Verifica se Tem Evento para o Desconto de DSR
			nPos	:= aScan( aResult , { |x| ( x[1] == dData ) .and. ( x[2] $ cEveDDSR ) } )
			IF ( nPos == 0 )
				// Verifica se existe algum abono que desconta DSR.
				If (nPosAbo := aScan(aAbonosPer, {|x| (x[5] == dData )})) > 0
					If SP6->(MsSeek( cFilSP6 + aAbonosPer[ nPosAbo , AABONOS_CODIGO ])) .And. SP6->P6_EVENTO $ cEveDDSR;
					.And. (nPos := aScan(aResult , {|x| ( x[1] == dData )})) > 0
						lAbDescDSR := .T.
					Else
						lAbDescDSR := .F.
						Loop
					EndIf
				Else
					Loop
				EndIf
			EndIF
			For nResult := nPos To nResults
				IF ( aResult[ nResult , 1 ] <> dData )
					Exit
				EndIF
				IF (aResult[ nResult , 2 ] $ cEveDDSR .Or. lAbDescDSR)
					//-- Total de Faltas/Atrasos, Base para Calculo do Desc DSR
					nHrsaDesc		:= aResult[ nResult , 3 ]
					nHrsEfetAbono	:= 0
					
					//-- Se Existirem Abonos Verifica se os Abonos abonam Faltas que compoem
					//-- a Base para Calculo do Desc de DSR
					IF (;
							( nHrsAbo := fAbonos(;
													dData					,;
													aResult[ nResult , 2 ]	,;
													NIL						,;
													@aAbonos				,;
													aResult[ nResult , 5 ]	,;
													aResult[ nResult , 4 ]	,;
													aAbonosPer			 	 ;
												 );
							) > 0;
						 )
						//-- Corre Todos os Abonos do Evento
						nAbonos := Len( aAbonos )
						For nAbono := 1 To nAbonos
						    //-- Posiciona no Motivo/ Justificativa de cada Abono
						    IF SP6->( MsSeek( cFilSP6 + aAbonos[ nAbono , AABONOS_CODIGO ] ) )
						       //-- Verifica se o Motivo abona Desc.DSR e, entao, nao compoe a
						       //-- base de faltas/atrasos para calculo do Desconto de DSR
						       IF ( SP6->P6_ABDSR $ " S" )
							      nHrsEfetAbono := __TimeSum( nHrsEfetAbono , aAbonos[ nAbono , AABONOS_HORAS_ABO ] )
							   EndIF
	                        EndIF
	                    Next nAbono
					    //-- Do Total de Horas que formam a Base para Desc de DSR
					    //-- Retira-se o total de horas que abonam Desc DSR
						nHrsaDesc := __TimeSub( aResult[ nResult , 3 ] , nHrsEfetAbono )
					EndIF
				    //-- Armazena o Total de Faltas/Atrasos jah deduzidos os Abonos se houverem
					aTabPer[ nPeriodo , nPerItem , 3] := __TimeSum( aTabPer[ nPeriodo , nPerItem , 3 ] , nHrsaDesc )
					//Guarda as horas referentes a DSR do periodo anterior
					If ( cDSRMS $ cEveDDSR )
						nHrsDSRAnt := nHrsaDesc
					EndIf
				EndIF
			Next nResult
		Next nPerItem
		
		//-- Define o no. de horas de ocorrências no Período
		//-- Totaliza o no. de dias com ocorrências no Período
		nHrsOcorr := ( nNumOcorr := 0 )
		
		aEval(aTabPer[nPeriodo], {|x| If( !x[4] == "A" .And. x[3] > 0, (nHrsOcorr := __TimeSum(nHrsOcorr, x[3]), ++nNumOcorr), NIL)})
		
		nHrsOcoBp := nHrsOcorr
		nNumOcoBp := nNumOcorr
		
		//-- Efetua os Descontos para os dias de D.S.R. e Feriados no Per¡odo.
		nDesc := 0     
		
		IF ( lPnmDSR02Block )                             
		 	IF ( ValType( aRetBlock := ExecBlock("PNMDDSR2",.F.,.F.,;
		 																{;
																			aTabCalend	,; //01 - Array com Calendario do turno
																			aResult		,; //02 - Array com os Resultados do apontamento
																			aTotais		,; //03 - Array com os eventos para Valores de Desconto de DSR
																			aArred_D	,; //04 - Array com os Arredondamento para DSR
																			cPeriodo	,; //05 - Indica o per¡odo para calculo (S, Q ou M)      
																			lDsrProp	,; //06 - Verifica se o Desconto Sera Baseado no Arredondamento ou em 1 Dia de Trabalho (parametro "MV_DSRPROP")
																			lLimDSR     ,; //07 - Indica se Limita Desc de DSR ao Periodo de Apuracao do Mesmo (parametro "MV_LIMDSR").
																			lDsrPPer	,; //08 - Verifica se sera Gerado Evento para desconto de DSR no Proximo Periodo (parametro "MV_DSRPPER").
																			lMvDDSRFer	,; //09 - Define se realiza o desconto para dias de Feriado (parametro "MV_DDSRFER").
																			cDSR		,; //10 - Codigo do Evento de Desconto do DSR.	
																			nNumAtra	,; //11 - Contreudo do Campo PA_NUMATRA	
																			aTabPer		,; //12 - Array com as informacoes do Periodo para Calculo do Desc. de DSR
																			nPeriodo	,; //13 - Posicao do array 
																			nHrsOcorr   ,; //14 - Total de Horas de Eventos de Desconto para o Periodo de Apuracao do Desc DSR
																			nNumOcorr   ,; //15 - Qtde de ocorrencias dos Eventos de Desconto para o Periodo de Apuracao do Desc DSR
																			nDiaDSR		 ; //16 - Horas para desconto do DSR
		 																	;
		 																};
		 										) ) == "A" )
			   	lExecPad:= IF( ValType(aRetBlock[1]) == "L", aRetBlock[1], .F. 	 )
			   	nDesc	:= IF( ValType(aRetBlock[2]) == "N", aRetBlock[2], 0 		 )
			   	aTotais := IF( ValType(aRetBlock[3]) == "A", aRetBlock[3], aTotais ) 	
	    	Else
		   	 	lExecPad:= .F.
	    	EndIF
		EndIF    
	    
	    /*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Executa Calculo Padrao do Desconto de DSR					   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

	    If 	lExecPad
		    //-- Se o Parametro de Desconto de DSR for 'Nao', Calcula o Desconto baseado
		    //-- na Tabela de Arredondamento. 
		    IF !( lDsrProp )
	
				For nArred := 1 To nArreds
					
					nDesc		:= 0			
					nHoras		:= aArred_D[ nArred , 3 ]
					lCarrega	:= .T.
					
					//-- Desconto de 1 DSR a cada ocorrˆncia de DSR ou Feriado por Per¡odo
					nPerItens := Len( aTabPer[ nPeriodo ] )
					For nPerItem := 1 To nPerItens
						dData	:= aTabPer[ nPeriodo , nPerItem , 1 ]
						IF ( ( aTabPer[ nPeriodo , nPerItem , 2 ] $ "D/F" ) .and. ( dData >= SRA->RA_ADMISSA ) )
						    //-- Calcula Qtde de Descontos
							If lArredTno .And. lCarrega .And. !Empty( aTabPer[ nPeriodo, nPerItem, 5 ] )
								lCarrega := .F.
								cFilSPD	 := SRA->RA_FILIAL
								aArred_D := GetTabArred( @cFilSPD, aTabPer[ nPeriodo, nPerItem, 5 ], "D" )
								aArred_D := RetTabArred( aArred_D, cFilSPD, aTabPer[ nPeriodo, nPerItem, 5 ], "D" )
								If Empty(aArred_D)
									aArred_D	:= aClone(aBkpArred)
								EndIf
								nHoras	:= aArred_D[ nArred , 3 ]
							EndIf					
							++nDesc
							IF (((nNumOcorr > nNumAtra) .Or. (nNumAtra == 0)) .And. ((nHrsOcorr >= aArred_D[nArred, 1]) .And. (nHrsOcorr <= aArred_D[nArred , 2])) ;
								.And. (aTabPer[nPeriodo, nPerItem, 4] <> "A" ))	
					            //-- Se Limita o Desc de DSR a um Por Periodo e ainda nao o calculou
								//-- ou Se Desconta 1 DSR a cada ocorrˆncia de DSR por Per¡odo
								IF ( ( ( lLimDSR ) .and. Empty( nGravaDesc ) ) .or. !lLimDSR )
									fGeraTot(	@aTotais		,;	//01 -> Array com os Totais do Ponto
												dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												nHoras			,;	//03 -> Horas para Soma ou Geracao
												0				,;	//04 -> Valor para Soma ou Geracao
												cDsr			,;	//05 -> Evento do Ponto para Pesquisa
												SRA->RA_CC		,;	//06 -> Centro de Custo para Comparacao
												SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
											)
									++nGravaDesc	
									If !lMvDDSRFer	
										nNumOcorr--
										nHrsOcorr := 0
									EndIf
								EndIF
							EndIF
						EndIF
	
					Next nPerItem
	
				Next nArred
	
			Else
	
				nDesc  := 0
				
				//-- Desconto de 1 DSR a cada ocorrˆncia de DSR por Per¡odo
				nPerItens := Len( aTabPer[ nPeriodo ] )
				//-- Corre Todos os Dias do Periodo Lido
				For nPerItem := 1 To nPerItens
					dData  := aTabPer[ nPeriodo , nPerItem , 1 ]
					nHoras := 0
					IF (;
							( aTabPer[ nPeriodo , nPerItem , 2 ] $ "D/F" );
							.and.;
							( dData >= SRA->RA_ADMISSA );
						)	
						//-- Calcula Qtde de Descontos
						++nDesc
						//-- Se o Numero de Ocorrencias de Faltas/Atrasos superar o limite Informado
						//-- Gera Desconto
						IF (;
								(;
									( nNumOcorr > nNumAtra );
									.or.;
									( nNumAtra == 0 );
								);
								.and.;
								( aTabPer[ nPeriodo , nPerItem ,4 ] <> "A" );
							)	
							
							
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³ Ponto de Entrada para Desconto de DSR			               ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							IF ( lPnmDSR01Block )                             
								nHoras := nHrsOcorr 
								IF ( ValType( aRetBlock := ExecBlock("PNMDDSR01",.F.,.F.,{dData, nHoras, nNumOcorr, nNumAtra,  1 }) ) == "A" )
								   nHoras		:= If( ValType(aRetBlock[1]) == "N", aRetBlock[1] , nHoras		)
								EndIF 
								fGeraTot(	@aTotais		,;	//01 -> Array com os Totais do Ponto
											dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
											nHoras			,;	//03 -> Horas para Soma ou Geracao
											0				,;	//04 -> Valor para Soma ou Geracao
											cDsr			,;	//05 -> Evento do Ponto para Pesquisa
											SRA->RA_CC		,;	//06 -> Centro de Custo para Comparacao
											SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
										)
								nNumOcorr--
								nHrsOcorr := 0
							Else
							
								//-- Se Limita o Desc de DSR a um Por Periodo e ainda nao o calculou
								//-- ou Se Desconta 1 DSR a cada ocorrˆncia de DSR por Per¡odo
								IF ( ( ( lLimDSR ) .and. Empty( nGravaDesc ) ) .or. !( lLimDSR ))
									
									nDiasFer:=0
									nHorasAux:= 0
																		
									If lDSRTab
							        	aEval( aTabCalend, { |x| If( x[CALEND_POS_TIPO_MARC] == "1E" .And. x[CALEND_POS_TIPO_ORIG_DIA] == 'S' .And. x[CALEND_POS_DATA] == aTabPer[ nPeriodo , nPerItem , 1 ], {nDiasFer++,dDataAux := x[CALEND_POS_DATA]}, NIL ) } )
								        If nDiasFer > 0
							            	aEval( aTabCalend, { |x| If( x[CALEND_POS_DATA] == dDataAux, nHorasAux := __TimeSum( nHorasAux, x[CALEND_POS_HRS_TRABA] ), NIL ) } )
								            nHoras := __TimeSub( nHorasAux , nHrsOcorr )
											//-- Garante que Seja Descontado do DSR ate a sua Totalizacao
											nHoras := IF( nHoras <= 0 , nHorasAux , nHrsOcorr ) 
							            Else
								            nHoras := __TimeSub( nDiaDSR , nHrsOcorr )
											//-- Garante que Seja Descontado do DSR ate a sua Totalizacao
											nHoras := IF( nHoras <= 0 , nDiaDSR , nHrsOcorr ) 
							            Endif
							        Else
							        	nHoras := __TimeSub( nDiaDSR , nHrsOcorr )
										//-- Garante que Seja Descontado do DSR ate a sua Totalizacao
										nHoras := IF( nHoras <= 0 , nDiaDSR , nHrsOcorr ) 
							        Endif						  					
																												
									fGeraTot(	@aTotais		,;	//01 -> Array com os Totais do Ponto
												dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												nHoras			,;	//03 -> Horas para Soma ou Geracao
												0				,;	//04 -> Valor para Soma ou Geracao
												cDsr			,;	//05 -> Evento do Ponto para Pesquisa
												SRA->RA_CC		,;	//06 -> Centro de Custo para Comparacao
												SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
											)
																
									++nGravaDesc
									If !lMvDDSRFer
										nNumOcorr--
										nHrsOcorr := 0
									EndIf									
								EndIF
							EndIF
						Endif	
					EndIF
				Next nPerItem
			EndIF
	    EndIF
	        
		//-- Em per¡odos sem DSR as horas de ocorr. v„o para o pr¢ximo Per¡odo
		IF ( nDesc == 0 )
			IF nPeriodo == 1 .And. Len(aTabPer) > 1//Se nao encontrar dia para DSR no primeiro periodo(semana) , leva para a proxima semana o desconto.
				IF !( lDsrProp )
				  
					For nArred := 1 To nArreds
					
					nDesc	:= 0
					nHoras	:= aArred_D[ nArred , 3 ]
					nProxPer:= nPeriodo + 1
					    	//-- Desconto de 1 DSR a cada ocorrˆncia de DSR ou Feriado por Per¡odo
					nPerItens := Len( aTabPer[ nProxPer ] )
						For nPerItem := 1 To nPerItens
						dData	:= aTabPer[ nProxPer , nPerItem , 1 ]
							IF ( ( aTabPer[ nProxPer , nPerItem , 2 ] $ "D/F" ) .and. ( dData >= SRA->RA_ADMISSA ) )
							    //-- Calcula Qtde de Descontos
							++nDesc
								If !lDescDSR
									If nDesc > 0
										lDescDSR := .T.
									Endif
								Endif
								IF (;
								(;
								( nNumOcorr > nNumAtra );
								.or.;
								( nNumAtra == 0 );
								 );
								.and.;
								   		(;
								   			( nHrsOcorr >= aArred_D[ nArred , 1 ] );
								   			.and.;
								   			( nHrsOcorr <= aArred_D[ nArred , 2 ] );
								   		);
								   		.and.;
								   		( aTabPer[ nProxPer , nPerItem , 4 ] <> "A" );
								   	)	
								            //-- Se Limita o Desc de DSR a um Por Periodo e ainda nao o calculou
								//-- ou Se Desconta 1 DSR a cada ocorrˆncia de DSR por Per¡odo
									IF ( ( ( lLimDSR ) .and. Empty( nGravaDesc ) ) .or. !( lLimDSR ) )
									fGeraTot(	@aTotais		,;	//01 -> Array com os Totais do Ponto
									dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
									nHoras			,;	//03 -> Horas para Soma ou Geracao
									0				,;	//04 -> Valor para Soma ou Geracao
									cDsr			,;	//05 -> Evento do Ponto para Pesquisa
									SRA->RA_CC		,;	//06 -> Centro de Custo para Comparacao
									SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
									)
									++nGravaDesc
									nDSRPri := nGravaDesc
									nNumOcorr--
									nHrsOcorr := 0
									EndIF
								EndIF
							EndIF
						Next nPerItem   
					Next nArred 
				Else
				
					nDesc  := 0
					
					nProxPer:= nPeriodo + 1
					    	//-- Desconto de 1 DSR a cada ocorrˆncia de DSR ou Feriado por Per¡odo
					nPerItens := Len( aTabPer[ nProxPer ] )
					//-- Corre Todos os Dias do Periodo Lido
					For nPerItem := 1 To nPerItens
						dData  := aTabPer[ nProxPer , nPerItem , 1 ]
						nHoras := 0
						IF (;
								( aTabPer[ nProxPer , nPerItem , 2 ] $ "D/F" );
								.and.;
								( dData >= SRA->RA_ADMISSA );
							)	
							//-- Calcula Qtde de Descontos
							++nDesc
							//-- Se o Numero de Ocorrencias de Faltas/Atrasos superar o limite Informado
							//-- Gera Desconto
							IF (;
									(;
										( nNumOcorr > nNumAtra );
										.or.;
										( nNumAtra == 0 );
									);
									.and.;
									( aTabPer[ nProxPer , nPerItem ,4 ] <> "A" );
								)	
								
								
								/*
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³ Ponto de Entrada para Desconto de DSR			               ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
								IF ( lPnmDSR01Block )                             
									nHoras := nHrsOcorr 
									IF ( ValType( aRetBlock := ExecBlock("PNMDDSR01",.F.,.F.,{dData, nHoras, nNumOcorr, nNumAtra,  1 }) ) == "A" )
									   nHoras		:= If( ValType(aRetBlock[1]) == "N", aRetBlock[1] , nHoras		)
									EndIF 
									fGeraTot(	@aTotais		,;	//01 -> Array com os Totais do Ponto
												dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												nHoras			,;	//03 -> Horas para Soma ou Geracao
												0				,;	//04 -> Valor para Soma ou Geracao
												cDsr			,;	//05 -> Evento do Ponto para Pesquisa
												SRA->RA_CC		,;	//06 -> Centro de Custo para Comparacao
												SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
											)
									nNumOcorr--
									nHrsOcorr := 0
								Else
								
									//-- Se Limita o Desc de DSR a um Por Periodo e ainda nao o calculou
									//-- ou Se Desconta 1 DSR a cada ocorrˆncia de DSR por Per¡odo
									IF ( ( ( lLimDSR ) .and. Empty( nGravaDesc ) ) .or. !( lLimDSR ) )
										
									
							
										nHoras := __TimeSub( nDiaDSR , nHrsOcorr )
										//-- Garante que Seja Descontado do DSR ate a sua Totalizacao
										nHoras := IF( nHoras <= 0 , nDiaDSR , nHrsOcorr ) 
									
										
										
										fGeraTot(	@aTotais		,;	//01 -> Array com os Totais do Ponto
													dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
													nHoras			,;	//03 -> Horas para Soma ou Geracao
													0				,;	//04 -> Valor para Soma ou Geracao
													cDsr			,;	//05 -> Evento do Ponto para Pesquisa
													SRA->RA_CC		,;	//06 -> Centro de Custo para Comparacao
													SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
												)
										nNumOcorr--
										nHrsOcorr := 0
										++nGravaDesc
										nDSRPri := nGravaDesc
									EndIF
								EndIF
							Endif	
						EndIF
					Next nPerItem
				EndIF 
			Endif      
  			IF ( nPeriodo < nPeriodos ) .and. !lDescDSR
				//Se havia DSR do periodo anterior para ser descontado e nao encontrou DSR nesta semana
				//elimina as horas de desconto pois j
				If nHrsDSRAnt > 0
					nHrsOcorr := __TimeSub(nHrsOcorr , nHrsDSRAnt)
					nHrsDSRAnt := 0
				EndIf
				aTabPer[ nNextPer , 1 , 3 ] := __TimeSum( aTabPer[ nNextPer , 1 , 3 ] , nHrsOcorr ) 
			ELSEIF ( lDsrPPer ) //Se Gera DSR para o Proximo Periodo
				//-- Gera Pr¢ximo Desconto de D.S.R.
				IF SPC->( MsSeek( SRA->( RA_FILIAL + RA_MAT ) + cDSrMS + Dtos( dProxPer ) ) )
					IF SPC->( RecLock( "SPC" , .F. ) )
						IF ( nHrsOcorr > 0 )
							SPC->PC_FILIAL	:= SRA->RA_FILIAL
							SPC->PC_MAT		:= SRA->RA_MAT
							SPC->PC_PD		:= cDsrMS
							SPC->PC_DATA	:= dProxPer
							SPC->PC_QUANTC	:= nHrsOcorr
							SPC->PC_CC		:= SRA->RA_CC
						Else
							SPC->( dbDelete() )
						EndIF
						SPC->( MsUnLock() )
					EndIF	
				ElseIF ( nHrsOcorr > 0 )
					IF SPC->( RecLock( "SPC" , .T. ) )
						SPC->PC_FILIAL	:= SRA->RA_FILIAL
						SPC->PC_MAT		:= SRA->RA_MAT
						SPC->PC_PD		:= cDsrMS
						SPC->PC_DATA	:= dProxPer
						SPC->PC_QUANTC	:= nHrsOcorr
						SPC->PC_CC		:= SRA->RA_CC
						SPC->( MsUnLock() )
					EndIF
				EndIF
			ElseIF !( lDsrPPer ) //Se Nao Gera DSR para o Proximo Periodo e Forca a Geracao do Desconto do DSR na Ultima Semana
				//Se gerou Dsr para o Proximo Periodo Exclui para gerar o Desconto no Mes
				IF SPC->( MsSeek( SRA->( RA_FILIAL + RA_MAT ) + cDSrMS + Dtos( dProxPer ) ) )
					IF SPC->( RecLock( "SPC" , .F. ) )
						SPC->( dbDelete() )
						SPC->( MsUnLock() )
					EndIF
				EndIF
				dData  := dPerFim
			    //-- Se o Parametro de Desconto de DSR for 'Nao', Calcula o Desconto baseado
			    //-- na Tabela de Arredondamento. 
				IF !( lDsrProp )
					lVerFeria := .F.
					For nArred := 1 To nArreds
						nHoras := aArred_D[nArred, 3]
						IF ( dData >= SRA->RA_ADMISSA )
					    	//-- Calcula Qtde de Descontos
							If (nNumOcorr > nNumAtra .or. nNumAtra == 0) .and. nHrsOcorr >= aArred_D[nArred, 1] .and. nHrsOcorr <= aArred_D[nArred, 2]
					            //-- Se Limita o Desc de DSR a um Por Periodo e ainda não o calculou
								//-- ou Se Desconta 1 DSR a cada ocorrência de DSR por Per¡odo
								IF((( lLimDSR ) .and. (Empty( nGravaDesc ).or. !Empty(nDSRPri) ) ) .or. !( lLimDSR ) )
									fGeraTot(	@aTotais		,;	//01 -> Array com os Totais do Ponto
												dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												nHoras			,;	//03 -> Horas para Soma ou Geracao
												0				,;	//04 -> Valor para Soma ou Geracao
												cDsr			,;	//05 -> Evento do Ponto para Pesquisa
												SRA->RA_CC		,;	//06 -> Centro de Custo para Comparacao
												SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
											)
									nNumOcorr--
									nHrsOcorr := 0
									lVerFeria := .T.
								EndIF
							EndIF
						EndIF
					Next nArred
					
					If lVerFeria .And. nPeriodo == nPeriodos .And. Dow(dPerFim) <> 1 .And. !lLimDSR .And. !lDsrProp .And. !lDsrPPer
						If Len(aTabPer[nPeriodo]) > 0
							dDtIniPer := aTabPer[nPeriodo,1,1]
							
							For nLoopDia := 1 To 7
								lTemFeria := fFeriado(SRA->RA_FILIAL,dDtIniPer + nLoopDia -1)
								
								If lTemFeria
									dDtFeriad := dDtIniPer + nLoopDia -1
									If dDtFeriad == dProxDSR
										lTemFeria := .F.
										LOOP
									EndIf
									Exit
								EndIf
							Next
							
							If lTemFeria
								fGeraTot(;
									@aTotais		,;	//01 -> Array com os Totais do Ponto
									dDtFeriad		,;	//02 -> Data para Pesquisa e Gravacao no aTotais
									nHoras			,;	//03 -> Horas para Soma ou Geracao
									0				,;	//04 -> Valor para Soma ou Geracao
									cDsr			,;	//05 -> Evento do Ponto para Pesquisa
									SRA->RA_CC		,;	//06 -> Centro de Custo para Comparacao
									SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
								)
							EndIf
						EndIf
					EndIf 
				Else
					nHoras := 0
					IF ( dData >= SRA->RA_ADMISSA )
						//-- Se o Numero de Ocorrencias de Faltas/Atrasos superar o limite Informado
						//-- Gera Desconto
						IF ( ( nNumOcorr > nNumAtra ) .or. ( nNumAtra == 0 ) ) 
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³ Ponto de Entrada para Desconto de DSR			               ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							IF ( lPnmDSR01Block ) 
								nHoras := nHrsOcorr 
								IF ( ValType( aRetBlock := ExecBlock("PNMDDSR01",.F.,.F.,{dData, nHoras, nNumOcorr, nNumAtra,  2 }) ) == "A" )
								   nHoras		:= If( ValType(aRetBlock[1]) == "N", aRetBlock[1] , nHoras		)
								EndIF 
								fGeraTot(	@aTotais		,;	//01 -> Array com os Totais do Ponto
											dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
											nHoras			,;	//03 -> Horas para Soma ou Geracao
											0				,;	//04 -> Valor para Soma ou Geracao
											cDsr			,;	//05 -> Evento do Ponto para Pesquisa
											SRA->RA_CC		,;	//06 -> Centro de Custo para Comparacao
											SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
										)
								nNumOcorr--
								nHrsOcorr := 0
							Else
								//-- Se Limita o Desc de DSR a um Por Periodo e ainda nao o calculou
								//-- ou Se Desconta 1 DSR a cada ocorrˆncia de DSR por Per¡odo
								IF ( ( ( lLimDSR ) .and. Empty( nGravaDesc ) ) .or. !( lLimDSR ) )
									nHoras := __TimeSub( nDiaDSR , nHrsOcorr )
									//-- Garante que Seja Descontado do DSR ate a sua Totalizacao
									nHoras := IF( ( nHoras <= 0 ) , nDiaDSR , nHrsOcorr )
									fGeraTot(	@aTotais		,;	//01 -> Array com os Totais do Ponto
												dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												nHoras			,;	//03 -> Horas para Soma ou Geracao
												0				,;	//04 -> Valor para Soma ou Geracao
												cDsr			,;	//05 -> Evento do Ponto para Pesquisa
												SRA->RA_CC		,;	//06 -> Centro de Custo para Comparacao
												SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
											)
									nNumOcorr--
									nHrsOcorr := 0
							    Endif
							EndIF
						EndIF
					EndIF
				EndIF
			EndIF
			
		Else

			/*
			
			-- Define se Gera DSR para o Proximo Periodo --
			
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Se ultima semana do periodo, apresentar desconto de DSR enviando p/ o proximo ³
			³periodo a qtde. de horas de ocorrencias (faltas/atrasos), isto eh, podemos	   ³
			³ter um DSR na ultima semana e uma falta. Sera gerado um desconto de DSR. No   ³
			³entanto, pode ocorrer um DSR/feriado na primeira semana do proximo periodo e  ³
			³as faltas/atrasos do periodo atual deverao ser consideradas p/ descontar esse ³
			³DSR/feriado (proximo periodo), desde que a primeira semana do proximo periodo ³
			³seja a continuacao da ultima semana do periodo atual.						   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			*/
			
			IF ( nPeriodo == nPeriodos ) .And. Dow(dPerFim) <> 1
				//-- Gera Desconto de D.S.R. no proximo periodo
				If lDsrPPer
					IF SPC->( MsSeek( SRA->( RA_FILIAL + RA_MAT ) + cDSrMS + Dtos( dProxPer ) ) )
						IF SPC->( RecLock( "SPC" , .F. ) )
							IF ( nHrsOcorr > 0 )
								SPC->PC_FILIAL	:= SRA->RA_FILIAL
								SPC->PC_MAT		:= SRA->RA_MAT
								SPC->PC_PD		:= cDsrMS
								SPC->PC_DATA	:= dProxPer
								SPC->PC_QUANTC	:= nHrsOcorr
								SPC->PC_CC		:= SRA->RA_CC
							Else
								SPC->( dbDelete() )
							EndIF
							SPC->( MsUnLock() )
						EndIF	
					ElseIF ( nHrsOcorr > 0 )
						IF SPC->( RecLock( "SPC" , .T. ) )
							SPC->PC_FILIAL	:= SRA->RA_FILIAL
							SPC->PC_MAT		:= SRA->RA_MAT
							SPC->PC_PD		:= cDsrMS
							SPC->PC_DATA	:= dProxPer
							SPC->PC_QUANTC	:= nHrsOcorr
							SPC->PC_CC		:= SRA->RA_CC
							SPC->( MsUnLock() )
						EndIF
					EndIF
			    //-- Gera Desconto de D.S.R. no periodo atual e verifica se ha limitacao no desconto do DSR
			    ElseIf (!lDsrPPer .And. nHrsOcorr > 0) .And. (((lLimDSR) .And. Empty(nGravaDesc)) .Or. !(lLimDSR .And. lDsrProp))					
					fGeraTot(	@aTotais		,;	//01 -> Array com os Totais do Ponto
								dPerFim			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
								nHoras			,;	//03 -> Horas para Soma ou Geracao
								0				,;	//04 -> Valor para Soma ou Geracao
								cDsr			,;	//05 -> Evento do Ponto para Pesquisa
								SRA->RA_CC		,;	//06 -> Centro de Custo para Comparacao
								SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
							)			    				    
			    EndIf // lDsrPPer
			EndIf
		EndIF //( nDesc == 0 )
	
	Next nPeriodo

End Sequence
	
//-- Verifica se ha evento contador para desconto de DSR
aEval( aEveCont, { |x| If( x[ 1 ] == cDSR, cContDSR := x[ 2 ], ) } )

If !Empty( cContDSR )
	//-- Qtde de ocorrencias de desconto de DSR
	aEval( aTotais,  { |x| If( x[ 2 ] == cDSR .And. x[ 3 ] > 0, ++nContDSR, ) } )
	
	//-- Gerar o evento com o no. de ocorrencias em aTotais
	fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
				dDataBase		,;	//02 -> Data para Pesquisa e Gravacao no aTotais
				nContDSR		,;	//03 -> Horas para Soma ou Geracao
				0				,;	//04 -> Valor para Soma ou Geracao
				cContDSR		,;	//05 -> Evento do Ponto para Pesquisa
				SRA->RA_CC		,;	//06 -> Centro de Custo para Comparacao
				SRA->RA_FILIAL	 ;	//07 -> Filial para Pesquisa no SP9
			)
EndIf

If lArredTno
	aArred_D	:= aClone(aBkpArred)
EndIf

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³fChkPer   ³ Autor ³Equipe Advanced RH     ³ Data ³05/12/1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida o Periodo de acordo com o MV_PAPONTA				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³fChkPer( dPerDe , dPerAte )								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³PONM010	 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fChkPer( dPerDe , dPerAte , cFil )

Local dPerIni	:= Ctod("//")
Local dPerFim	:= Ctod("//")
Local lRet		:= .T.

DEFAULT dPerDe	:= Ctod("//")
DEFAULT dPerAte	:= Ctod("//")

Begin Sequence
	IF !( lRet := !Empty( dPerDe ) )
		Break
	EndIF
	IF !( lRet := !Empty( dPerAte ) )
		Break
	EndIF
	IF !( lRet := !( dPerDe > dPerAte ) )
		Break
	EndIF
	IF !( lRet := GetPonMesDat( @dPerIni , @dPerFim , cFil ) )
		Break
	EndIF

End Sequence

Return( lRet )
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³fContaEvento     ³ Autor ³Mauricio MR     ³ Data ³25/10/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Conta o numero de ocorrencias de um evento com horas apura- ³±±
±±³          ³das.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³Ver Parametros formais     								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³PONM070	 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fContaEvento(nHoras, aEveCont,cEvento, aTotais, dPerIni, dPerFim, aTabCalend, cLastFil, cAliasQSPC)
Local lContaEvento	:= .F.
Local nPos			:= 0
Local uRetBlock 

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica a existencia de contador de eventos e registra o     ³
³numero de ocorrencias										   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
//--Se existe o campo de Evento Contador
If !Empty(nHoras)
 	//-- Verifica se nao foi carregado o evento do ponto
	If !( Empty( aEveCont) )
		If  !( Empty( nPos:= Ascan( aEveCont, {|x| x[1] == cEvento } ) ) )
			
			lContaEvento	:= .T.
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ponto de Entrada Antes da Totalizacao dos Eventos Contadores ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( lPonEveContBlock )
				dbSelectArea("SPC")
				SPC->(dbGoTo((cAliasQSPC)->RECNO))
				uRetBlock := ExecBlock(;
											"PNMEVECONT",;
											.F.,;
											.F.,;
											{;
												aClone( aTotais ),;			//ParamIxb[1] <-> Array aTotais
												dPerIni,;					//ParamIxb[2] <-> Periodo Inicial do Apontamento
												dPerFim,;					//ParamIxb[3] <-> Periodo Final do Apontamento
												aClone( aTabCalend ),;		//ParamIxb[4] <-> Array com o Calendario de Marcacoes
												aEveCont[nPos,2]	,;		//ParamIxb[5] <-> Evento Contador Ponto para Pesquisa
												nHoras				;		//ParamIxb[6] <-> Horas do Evento do Corrente
											},;
											.F.;
									)
				IF ( ValType( uRetBlock ) == "A" )
					aTotais 		:= aClone( uRetBlock[1] )
                    lContaEvento	:= uRetBlock[2]
				EndIF
				uRetBlock := NIL
			EndIF 
			If lContaEvento 
				( cAliasQSPC )->(;
									fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
												PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												1				,;	//03 -> Horas para Soma ou Geracao
												0				,;	//04 -> Valor para Soma ou Geracao
												aEveCont[nPos,2],;	//05 -> Evento do Ponto para Pesquisa
												PC_CC			,;	//06 -> Centro de Custo para Comparacao
												cLastFil		 ;	//07 -> Filial para Pesquisa no SP9
											);
								)
			Endif					 
		Endif					 
	Endif
Endif 

Return ( NIL )			
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³TipodeDia		   ³ Autor ³Mauricio MR     ³ Data ³02/12/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica o Tipo de Dia 									  ³±±
±±³          ³das.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³Ver Parametros formais     								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³PONM070	 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/

Function TipodeDia( aItemTabCalend )
Local cTipoDia
Local lTrbFeriado

//Verifica Afastamento no Dia
If !Empty( aItemTabCalend[ CALEND_POS_TIP_AFAST] )
   cTipoDia := "!!"
Else 
	//Verifica Feriado, Se trabalha em Feriado e Excecao
   lTrbFeriado	:= aItemTabCalend[ CALEND_POS_TRAB_FERIADO ]
   cTipoDia	:= IF( aItemTabCalend[ CALEND_POS_FERIADO ] , IF(  aItemTabCalend[ CALEND_POS_EXCECAO ]  == "E" , aItemTabCalend[ CALEND_POS_TIPO_DIA ] , IF(!lTrbFeriado,"F",aItemTabCalend[ CALEND_POS_TIPO_DIA ] ) ) , aItemTabCalend[ CALEND_POS_TIPO_DIA ] )                  
Endif
Return( cTipoDia )    
 
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fDelRFF		  ³Autor³Mauricio MR		  ³ Data ³04/12/2009³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Deleta os registros do RFF - Fisicamente se for Top			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   |fDelRFF() 													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponm090                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fDelRFF(cFil,cMat,cPerApo, cIniData, cFimData, dperIni, dperFim)

Local aArea 	  	:= GetArea()     
Local aAreaRFF 	  	:= RFF->(GetArea() )
Local cAlias   	  	:= "RFF"  
Local cMsgErr  	  	:= ""  
Local lQueryOpened	:= .F.
Local lRet 	      	:= .T.

Local cQuery   	  := ""
Local cAliasQry	  := ""
Local cCpoRecno	  := ""
Local cDelet      := ""
Local cFilter	  := ""
Local cQueryDelet := ""
Local cRetSqlName := InitSqlName(cAlias)
Local nMinRec 	  := 0
Local nMaxRec 	  := 0
Local cRecno	  := ""

cDelet    := "% RFF.D_E_L_E_T_ = ' ' %"
cCpoRecno := "R_E_C_N_O_"

cAliasQry := GetNextAlias()

cFilter := "% RFF_FILIAL = '"+cFil+"'"
cFilter += " AND "
cFilter += " RFF_MAT = '"+cMat+"'"
cFilter += " AND "
cFilter += " RFF_PAPONT = '"+cPerApo+"'"	
cFilter += " AND "		
cFilter += " ( "
cFilter += 		"RFF_DATA>='"+cIniData+"'"
cFilter += 		" AND "
cFilter += 		"RFF_DATA<='"+cFimData+"'"  
cFilter += " ) "
cFilter += " %"

BeginSql alias cAliasQry
	column RFF_DATA	as Date
	%NoParser%
	
	SELECT 
		MAX(RFF_DATA) RFF_DATA,
		MIN(RFF.R_E_C_N_O_) MINREC, 
		MAX(RFF.R_E_C_N_O_) MAXREC
	FROM 
		%Table:RFF% RFF
	WHERE 
		%Exp:cFilter% AND
		%Exp:cDelet%
EndSql

nMinRec := (cAliasQry)->(MINREC)
nMaxRec := (cAliasQry)->(MAXREC)
lQueryOpened := .T.

If !Empty(nMinRec)
		
	cQuery := "DELETE FROM " + cRetSqlName
	 
	While ( nMinRec <= nMaxRec )		
        cRecno := " WHERE "
        cRecno += "("
        cRecno +=  cCpoRecno + " >= " + AllTrim( Str( nMinRec , 18 , 0 ) )
        cRecno += " AND "
        cRecno += cCpoRecno + " <= " + AllTrim( Str( ( nMinRec += 1024 ) , 18 , 0 ) )     
        cRecno += ") AND "
        cQueryDelet := ( cQuery + cRecno + SubStr( AllTrim(cFilter), 3,Len(AllTrim(cFilter))-3 ) )

        TcSqlExec( cQueryDelet )
	End While
	
	TcRefresh( cRetSqlName )
	lRet := .T.
EndIf

(cAliasQry)->( DbCloseArea() )

IF !lQueryOpened
	DbSelectArea(cAlias)
	DbsetOrder((cAlias)->(RetOrdem( "RFF" , "RFF_FILIAL+RFF_PAPONT+RFF_MAT+RFF_PD+DTOS(RFF_DATA)+RFF_CC" )))
	IF (cAlias)->( dbSeek( cFil + cPerApo + SRA->RA_MAT , .F. ) )
		While (cAlias)->( !Eof() .and. ( RFF_FILIAL = cFil ) .and. (RFF_PAPONT = cPerApo) .and. ( RFF_MAT = cMat )   )
			IF ( cAlias )->( ( RFF_DATA >= dPerIni ) .and. ( RFF_DATA <= dPerFim ) )
				If (cAlias)->( RecLock( cAlias , .F. ) )			
					If !(cAlias)->( lDeleted := FkDelete( @cMsgErr ) )
						(cAlias)->( RollBackDelTran( cMsgErr ) )
					EndIF
					(cAlias)->(MsUnlock())
				Endif	
			Endif	
			(cAlias)->( dbSkip() )			
		End While
	EndIf
	RestArea(aAreaRFF)
Endif


RestArea(aArea)

Return ( lRet )

/*/{Protheus.doc} fCarSemAnt
@author		Leandro Drumond
@since		06/11/2017
@version	1.0
@return		NIL
@obs		Obtem a data de inicio da semana anterior a semana inicial do período de apontamento 
/*/
Static Function fCarSemAnt(dPerIni,dPerFim,dDtAuxIni,dDtAuxFim,dDtIniUSem)

dDtAuxIni := CtoD("")
dDtAuxFim := CtoD("")
dDtIniUSem:= CtoD("")

While .T.
	If Dow(dPerIni) == 1 //Domingo
		dDtAuxIni := dPerIni - 7
		dDtAuxFim := dPerIni - 1
		Exit
	EndIf
	dPerIni--
EndDo

While .T.
	If Dow(dPerFim) == 1 //Domingo
		dDtIniUSem := dPerFim
		Exit
	EndIf
	dPerFim--
EndDo

Return Nil

/*/{Protheus.doc} fVerDsrSem
@author		Marco Nakazawa
@since		05/11/2021
@version	1.0
@return		lApont = .T. Teve desconto DSR; .F. Não teve desconto DSR
@obs		Verifica se houve o desconto de DSR na ultima semana do período anterior
/*/
Static Function fVerDsrSem(cFilialFun,cMat,dIniSemana,dFimSemana,aCodigos)
	
	Local cAliasSPB		:= GetNextAlias()
	Local cCodDSRDes	:= ""
	Local aIdPonto		:= {"017N","018A"}
	Local nI			:= 0
	Local nPos			:= 0
	Local lApont		:= .F.
	
	Default aCodigos	:= {}
	Default cFilialFun	:= ""
	Default cMat 		:= ""
	Default dIniSemana	:= CtoD("")
	Default dFimSemana	:= CtoD("")
	
	If !Empty(aCodigos)
		For nI := 1 To Len(aIdPonto)
			If (nPos := aScan(aCodigos,{|x| x[2] == aIdPonto[nI] .And. !Empty(x[4])})) > 0
				If Empty(cCodDSRDes)
					cCodDSRDes := "%'" + aCodigos[nPos,4] + "'"
				Else
					cCodDSRDes += ",'" + aCodigos[nPos,4] + "'" 
				EndIf
			EndIf
		Next
		
		cCodDSRDes := If(!Empty(cCodDSRDes), cCodDSRDes + "%", "")
		
	EndIf
	
	If !Empty(cCodDSRDes) .And. !Empty(cMat) .And. !Empty(cFilialFun) .And.!Empty(dIniSemana) .And. !Empty(dFimSemana)
		BeginSql Alias cAliasSPB
			SELECT COUNT(*) AS CONT
			FROM %Table:SPB% SPB
			WHERE SPB.PB_FILIAL = %Exp:cFilialFun%
				AND SPB.PB_MAT = %Exp:cMat%
				AND (SPB.PB_DATA >= %Exp:DtoS(dIniSemana)% AND SPB.PB_DATA <= %Exp:DtoS(dFimSemana)%)
				AND SPB.PB_PD IN (%Exp:cCodDSRDes%)
				AND SPB.%NotDel%
		EndSql
		
		lApont := (cAliasSPB)->CONT > 0
		
		(cAliasSPB)->(DbCloseArea())
	EndIf
Return lApont

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ Scheddef    ³ Autor ³ Marco Nakazawa     ³ Data ³08/03/2021³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Trazer o grupo de perguntas PONM070 quando houver schedule ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function SchedDef()
Local aOrd		:= {}
Local aParam	:= {}

aParam := {	"P"			, ; // Tipo R para relatorio P para processo
			"PNM070"	, ;	// Pergunte do relatorio, caso nao use passar ParamDef
			""			, ; // Alias para o relatório
			aOrd		, ; // Array de ordens para o relatório
			""			}
Return aParam

/*/{Protheus.doc} GetCCTs
Retorna as CCTs presentes nos apontamentos
@type  Static Function
@author Cícero Alves
@since 12/08/2022
@param aTotHExt, array, Eventos de HE autorizados realizados no período
@param aTotHENt, array, Eventos de HE não autorizados realizados no período
@return aCCTs, array, Array bidimesional com as CCT onde aCCTs[n][1] é a Filial e aCCTs[n][2] é o código da CCT 
/*/
Static Function GetCCTs(aTotHExt, aTotHENt)
	
	Local aCCTs := {}
	Local nI	:= 0
	
	DEFAULT aTotHExt := {}
	DEFAULT aTotHENt := {}
	
	For nI := 1 To Len(aTotHExt)
		If aScan(aCCTs, {|x| x[1] == aTotHExt[nI][ATOTAIS_FILCCT] .And. x[2] == aTotHExt[nI][ATOTAIS_CODCCT] }) == 0
			aAdd(aCCTs, {aTotHExt[nI][ATOTAIS_FILCCT], aTotHExt[nI][ATOTAIS_CODCCT]})
		EndIf 
	Next nI
	
	For nI := 1 To Len(aTotHENt)
		If aScan(aCCTs, {|x| x[1] == aTotHENt[nI][ATOTAIS_FILCCT] .And. x[2] == aTotHENt[nI][ATOTAIS_CODCCT] }) == 0
			aAdd(aCCTs, {aTotHENt[nI][ATOTAIS_FILCCT], aTotHENt[nI][ATOTAIS_CODCCT]})
		EndIf 
	Next nI
	
Return aCCTs


/*/{Protheus.doc} FiltraCCT
Carrega apenas os eventos vinculados a CCT informada nos Array passados por parâmetro
@type  Static Function
@author Cícero Alves
@since 12/08/2022
@param aTotHExt, array, Eventos de HE autorizados realizados no período
@param aTotHENt, array, Eventos de HE não autorizados realizados no período
@param cFilCCT, caractere, Filial da CCT 
@param cCodCCT, caractere, Código da CCT 
@param aHExtAux, array, Array onde serão carregados os eventos de HE Autorizados vinculados a CCT - Deve ser passado por referência
@param aHENtAux, array, Array onde serão carregados os eventos de HE Não Autorizados vinculados a CCT - Deve ser passado por referência
/*/
Static Function FiltraCCT(aTotHExt, aTotHENt, cFilCCT, cCodCCT, aHExtAux, aHENtAux)
	
	aHExtAux := {}
	aHENtAux := {}
	
	aEval(aTotHExt, {|x| If( x[ATOTAIS_FILCCT] == cFilCCT .And. x[ATOTAIS_CODCCT] == cCodCCT, aAdd(aHExtAux, x), NIL)})
	aEval(aTotHENt, {|x| If( x[ATOTAIS_FILCCT] == cFilCCT .And. x[ATOTAIS_CODCCT] == cCodCCT, aAdd(aHENtAux, x), NIL)})
	
Return

/*/{Protheus.doc} AadHEPer
Adiciona as informações de período e tolerância no array aTotHExt
@type  Static Function
@author Cícero Alves
@since 15/12/2022
/*/
Static Function AadHEPer(aTotHExt)
	
	Local nI 			:= 1
	Local aTabExtra		:= {}
	Local cMsgErr		:= ""
	Local nPosTab		:= 0
	Local cLastTur		:= "*"
	Local cLastTipo		:= "*"
	Local nPosCalend	:= 0
	Local cTurno		:= ""
	
	DEFAULT aTotHExt := {}
	
	aSort(aTotHExt,,,{|x, y| x[2] < y[2] .And. x[15] < y[15]}) // Ordena as HE por turno e tipo
	
	For nI := 1 To Len(aTotHExt)
		
		If (nPosCalend := aScan( aTabCalend, {|x| (x[CALEND_POS_DATA] == aTotHExt[nI][1] ) .And. ( x[CALEND_POS_TIPO_MARC] == "1E")})) > 0
			cTurno := aTabCalend[nPoscalend][CALEND_POS_TURNO]
		EndIf 
		
		If !(cTurno == cLastTur)
			cLastTur := cTurno
			cLastTipo := aTotHExt[nI][15]
			GetTabExtra( @aTabExtra, SRA->RA_FILIAL, cTurno, .F., .T., NIL, NIL, @cMsgErr,, aTotHExt[nI][17], aTotHExt[nI][18])
			nPosTab := aScan(aTabExtra, {|x| x[1] == aTotHExt[nI][15]})
		ElseIf !(aTotHExt[nI][15] == cLastTipo)
			cLastTipo := aTotHExt[nI][15]
			nPosTab := aScan(aTabExtra, {|x| x[1] == aTotHExt[nI][15]})
		EndIf
		
		If nPosTab > 0
			aAdd(aTotHExt[nI], aTabExtra[nPosTab][7]) 	// Período de apuração
			aAdd(aTotHExt[nI], aTabExtra[nPosTab][8])	// Tolerância por período
		Else
			aAdd(aTotHExt[nI], " ")
			aAdd(aTotHExt[nI], 0)
		EndIf 
	Next
	
	aSort(aTotHExt,,,{|x, y| x[1] < y[1]}) // Ordena as HE por data
	
Return

/*/{Protheus.doc} FilHEPer
Agrupa as HE por período de apuração e tolerância
@type  Static Function
@author Cícero Alves
@since 15/12/2022
/*/
Static Function FilHEPer(aTotHExt, aTotHENt)
	
	Local nI 		:= 0
	Local aHEPer	:= {}
	
	Default aTotHExt := {}
	Default aTotHENt := {}
	
	For nI := 1 To Len(aTotHExt)
		If Empty(aHEPer) .Or. aScan(aHEPer, {|x| aTotHExt[nI][19] == x[1] .And. aTotHExt[nI][20] == x[2]}) == 0
			aAdd(aHEPer, Array(4))
			aHEPer[Len(aHEPer)][1] := aTotHExt[nI][19]
			aHEPer[Len(aHEPer)][2] := aTotHExt[nI][20]
			aHEPer[Len(aHEPer)][3] := {}
			aHEPer[Len(aHEPer)][4] := {}
			aEval(aTotHExt, {|x| If( x[19] == aHEPer[Len(aHEPer)][1] .And. x[20] == aHEPer[Len(aHEPer)][2], aAdd(aHEPer[Len(aHEPer)][3], x), NIL)})
			aEval(aTotHENt, {|x| If( x[19] == aHEPer[Len(aHEPer)][1] .And. x[20] == aHEPer[Len(aHEPer)][2], aAdd(aHEPer[Len(aHEPer)][4], x), NIL)})
		EndIf
	Next
	
	For nI := 1 To Len(aTotHENt)
		If Empty(aHEPer) .Or. aScan(aHEPer, {|x| aTotHENt[nI][19] == x[1] .And. aTotHENt[nI][20] == x[2]}) == 0
			aAdd(aHEPer, Array(4))
			aHEPer[Len(aHEPer)][1] := aTotHENt[nI][19]
			aHEPer[Len(aHEPer)][2] := aTotHENt[nI][20]
			aHEPer[Len(aHEPer)][3] := {}
			aHEPer[Len(aHEPer)][4] := {}
			aEval(aTotHENt, {|x| If( x[19] == aHEPer[Len(aHEPer)][1] .And. x[20] == aHEPer[Len(aHEPer)][2], aAdd(aHEPer[Len(aHEPer)][4], x), NIL)})
		EndIf
	Next
	
Return aHEPer

/*/{Protheus.doc} fDSRAnt
Exclui os eventos de atraso período anterior que podem ter sido gerados ao realizar o cálculo mensal parcial
@type Static Function
@author Cícero Alves
@since 16/02/2023
@param aCodigos, Array, Array com os eventos do ponto
@param cDescDSR, Caractere, Conteudo do Campo PA_DESCDSR; define se gera o evento autorizado ou o não autorizado
@param dPerIni, Data, Data inicial do período
@param dPerFim, Data, Data final do período
/*/
Static Function fDSRAnt(aCodigos, cDescDSR, dPerIni, dPerFim)
	
	Local aArea		:= GetArea()
	Local nPos		:= 0
	Local cDSRMS	:= ""
	
	If ( nPos := aScan( aCodigos, { |x| x[2] == If(( cDescDSR == "S"), "022A", "021N" )})) > 0 .And. !Empty(cDSRMS := aCodigos[nPos, 1])
		
		//Exclui o evento da tabela SPC
		dbSelectArea("SPC")
		dbSetOrder(1)
		
		SPC->(dbSeek(SRA->(RA_FILIAL + RA_MAT) + cDSRMS))
		
		While SPC->(!EoF() .And. PC_FILIAL + PC_MAT + PC_PD == SRA->(RA_FILIAL + RA_MAT) + cDSRMS)
			If SPC->(PC_DATA > dPerIni .And. PC_DATA <= dPerFim)
				RecLock("SPC", .F.)
				SPC->(dbDelete())
				SPC->(MsUnlock())
			EndIf
			SPC->(dbSkip())
		EndDo
	EndIF
	
	RestArea(aArea)
	
Return 
