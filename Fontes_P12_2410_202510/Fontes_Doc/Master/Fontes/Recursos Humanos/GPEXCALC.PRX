#INCLUDE "GPEXCALC.CH"
#Include 'Protheus.ch'

Static lValDissi
Static lValHorAdic   := Type("P_VALHOADIC") != "U" .AND. P_VALHOADIC
Static __lMemCalc

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³          ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador  ³ Data   ³ FNC            ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Leandro Dr. ³10/01/2013³M12RH01         ³Unificacao das Folhas. Projeto Versao 12 ³±±
±±³            ³          ³REQ.: 04_01     ³                                         ³±±
±±³Tiago Malta ³26/11/2013³M12RH01         ³13 SALARIO PRIMEIRA PARCELA Versao 12    ³±±
±±³            ³          ³REQ.: 18_48     ³                                         ³±±
±±³Renata      ³29/04/2014³TPKANK          ³Na funcao Sindical, substituido opcao do ³±±
±±³            ³          ³				  ³calculo para afast. O e P, pelo opcao do  ³±±
±±³            ³          ³				  ³tipo de ausencia.						 ³±±
±±³Flavio C.   ³09/06/2014³TPUOTR     	   ³REPLICA V11 Ajuste p/ tratar nova opcao  ³±±
±±³            ³          ³           	   ³preenchimento do campo X14_RECFAT.		 ³±±
±±³Mauricio T. ³24/07/2014³TQDPY8     	   ³Inclusao do tratamento da variavel aPeri ³±±
±±³            ³          ³           	   ³odo caso a rotina executora nao possir a ³±±
±±³            ³          ³           	   ³variavel declarada. Exclusao do tipo M   ³±±
±±³            ³          ³           	   ³para gravacao na tabela SRC. A partir da ³±±
±±³            ³          ³           	   ³versao 12 o calculo passa a buscar a info³±±
±±³            ³          ³           	   ³rmacao na tabela de Tarefas.             ³±±
±±³Allyson M.  ³30/07/2014³TQ7146    	   ³Ajuste em fCInss() na verificacao de     ³±±
±±³            ³          ³          	   ³alteracao da verba de Id 0168. 			 ³±±
±±³Allyson M.  ³15/08/2014³TQIEK9    	   ³Ajuste em fPerFatEmp() p/ considerar como³±±
±±³            ³          ³          	   ³base de calculo p/ desoneracao a receita ³±±
±±³            ³          ³          	   ³bruta total deduzida das exclusoes. Antes³±±
±±³            ³          ³          	   ³considerava a base liquida, ou seja, a   ³±±
±±³            ³          ³          	   ³receita bruta deduzida das exclusoes e   ³±±
±±³            ³          ³          	   ³exportacoes.  							 ³±±
±±³Everson SP  ³05/12/14³TQPLI03           ³Ajuste na CalDsrHex() para forcar a      ³±±
±±³            ³          ³                ³gravacao de Outros DSR ao calcular       ³±±
±±³            ³          ³                ³o dissidio.                              ³±±
±±³Allyson M.  ³05/01/2015³TQMFVF    	   ³Ajuste p/ calculo de dissidio validar se ³±±
±±³            ³          ³          	   ³houve pagamento de periculosidade, insa- ³±±
±±³            ³          ³          	   ³lubridade e/ou adicional por tempo de    ³±±
±±³            ³          ³          	   ³servico no mes original.				 ³±±
±±³Wag Mobile  ³29/01/2015³TRAYPF    	   ³Incorporação da base de calculo da comis-³±±
±±³            ³          ³          	   ³são para comissionistas 				 ³±±
±±³Allyson M.  ³20/02/2015³TRHKAT    	   ³Ajuste p/ apurar corretamente a diferenca³±±
±±³            ³          ³          	   ³dos valores na rescisao complementar por ³±±
±±³            ³          ³          	   ³dissidio.  				 				 ³±±
±±³Flavio Corr.³04/02/15  ³PCDEF-11847	   ³Ajuste para valorização de adicionais qdo³±±
±±³            ³          ³          	   ³chamado do roteiro INC					 ³±±
±±³Allyson M.  ³04/03/2015³TRIA28    	   ³Ajuste em fSalProf() p/ nao considerar   ³±±
±±³            ³          ³          	   ³tarefas no salario caso seja professor   ³±±
±±³            ³          ³                ³aulista e 13o. p/ somente efetuar  		 ³±±
±±³            ³          ³                ³pagamento de medias.					 ³±±
±±³Christiane V³30/04/2015³TQXON7          ³Alterada a fórmula fliquido() para gravar³±±
±±³            ³          ³                ³a data do pagamento ao gravar o Líquido. ³±±
±±³Raquel Hager³05/10/2015³TTNHL2          ³Alterada fMatriz() para nao incorporar na³±±
±±³            ³          ³                ³Folha verbas já incorporadas nas Ferias  ³±±
±±³Nivia Ferrei³28/10/2015³PCREQ-5350      ³Produtização Gestão publica V12          ³±±
±±³            ³          ³				   ³Ajuste nas categorias		  		     ³±±
±±³Allyson M.  ³29/12/2015³TUALY1    	   ³Ajuste em CalDsrHex() p/ considerar os   ³±±
±±³            ³          ³          	   ³dias nao trabalhados no calculo de DSR de³±±
±±³            ³          ³                ³hora extra quando P_LPROPDSR esta com .T.³±±
±±³Allyson M.  ³05/01/2016³TUCUTQ    	   ³Ajuste em CalDsrHex() p/ considerar as   ³±±
±±³            ³          ³          	   ³horas normais e descanso do cabecalho da ³±±
±±³            ³          ³                ³rescisao (tratamento era efetuado na 11 )³±±
±±³Raquel Hager³10/02/2016³TUJQLJ		   ³Ajuste na funcao fMatriz para passar a   ³±±
±±³            ³          ³                ³gravar a Data de Referência.             ³±±
±±³Raquel Hager³30/03/2016³TUKV34		   ³Ajuste na funcao SalFam para considerar  ³±±
±±³            ³          ³                ³nDiasP no caso de ADMISSAO.              ³±±
±±³Raquel Hager³20/04/2016³TV0922		   ³Ajuste na funcao fVlDiss para nao        ³±±
±±³            ³          ³                ³ valorizar verba informada.			     ³±±
±±³Claudinei S.³04/05/2016³TUCJR5		   ³Incluido controle de calculo do DSR s/ HE³±±
±±³            ³          ³                ³proporcional a afastamentos e ferias.	 ³±±
±±³Claudinei S.³11/05/2016³TUCJR5|TUVQAB   ³Ajustada a variavel que ira considerar ou³±±
±±³            ³          ³                ³nao as ferias para o DSR Prop. de HE.	 ³±±
±±³Raquel Hager³20/05/2016³TV0922		   ³Remocao de ajuste indevido na funcao     ³±±
±±³            ³          ³                ³ fVlDiss.          			             ³±±
±±³Claudinei S.³02/06/2016³TVIAIX		   ³Ajuste na chamada da IncorpSal na fMatriz³±±
±±³            ³          ³                ³p/ considerar o tipo da verba (Prov/Desc)³±±
±±³Gabriel A.  ³06/06/2016³TVGKFO          ³Ajuste para priorizar o valor das verbas ³±±
±±³            ³          ³                ³informadas e no cálculo de líquido para  ³±±
±±³            ³          ³                ³verbas de pagamento obrigatório.         ³±±
±±³Allyson M.  ³13/06/2016³TVHO32          ³Ajuste para não valorizar verbas calcula-³±±
±±³            ³          ³                ³das obtidas pelo fechamento(tipo F)      ³±±
±±³Gabriel A.  ³24/06/2016³TVJSOG          ³Ajuste em fMatriz() p/ nao incorporar o  ³±±
±±³            ³          ³                ³adicional proporcionalizado do calculo de³±±
±±³            ³          ³                ³ferias pois o valor integral ja é somado ³±±
±±³            ³          ³                ³no calculo do adicional                  ³±±
±±³Allyson M.  ³29/07/2016³TVLPAL          ³Ajuste em fMatriz() p/ proporcionalização³±±
±±³            ³          ³                ³considerar os dias de FGTS      		 ³±±
±±³Gabriel A.  ³26/09/2016³TVSEYW          ³Ajuste no cálculo de DRS para            ³±±
±±³            ³          ³                ³comissionado puro.                       ³±±
±±³Claudinei S.³07/10/2016³TWAWG1		   ³Ajuste em SalFam para considerar verbas  ³±±
±±³            ³          ³                ³do grupo 0 para a base de calculo, quando³±±
±±³            ³          ³                ³Horistas com jornada variável.			 ³±±
±±³Allyson M.  ³26/10/2016³TWHDNC          ³Ajuste em fSalario() p/ verificar o MNE  ³±±
±±³            ³          ³                ³P_DIASRES quando for rescisão      		 ³±±
±±ºRaquel Hager³10/10/2016³TWKEU2          ³Realizados ajustes para execução de robô ³±±
±±º            ³          ³                ³de testes para cálculo de rescisão compl.³±±
±±º            ³          ³                ³com período aberto na função CalDsrHex.	 ³±±
±±³Claudinei S.³02/12/2016³TWAWG1/MRH-233  ³Ajuste em SalFam para não buscar mais as ³±±
±±³            ³          ³                ³incidências no array APDV, em algumas    ³±±
±±³            ³          ³                ³situações o APDV estava diferente do APD,³±±
±±³            ³          ³                ³gerando error.log.                       ³±±
±±³Renan Borges³21/12/2016³MRH-2787        ³Ajuste para calcular adiantamento de pro-³±±
±±³            ³          ³                ³fessores corretamente sem gerar a verba  ³±±
±±³            ³          ³                ³de tarefa.                               ³±±
±±³Renan Borges³21/12/2016³MRH-3148        ³Ajuste para calcular folha de professores³±±
±±³            ³          ³                ³proporcional quando houver afastamento.  ³±±
±±³Gabriel A.  ³31/10/2016³TWIONM          ³Ajuste para proporcionalizar o salário   ³±±
±±³            ³          ³                ³família corretamente quando há múltiplos ³±±
±±³            ³          ³                ³vínculos.                                ³±±
±±³Renan Borges³28/12/2016³MRH-3145        ³Ajuste para calcular folha de professores³±±
±±³            ³          ³                ³de acordo os dias de calculo do cadastro ³±±
±±³            ³          ³                ³de períodos.                             ³±±
±±³Raquel Hager³09/01/2017³MRH-3442        ³Ajuste na função SalFam para montar base ³±±
±±³            ³          ³                ³de cálculo corretamente quando Horista   ³±±
±±³            ³          ³                ³com Jornada Variável.                    ³±±
±±³Raquel Hager³09/01/2017³MRH-2970        ³Ajuste no fMatriz para atualização do    ³±±
±±³            ³          ³                ³a SalBase quando este for diferente do   ³±±
±±³            ³          ³                ³gravado pela primeira vez.               ³±±
±±³Raquel Hager³09/01/2017³MRH-3444        ³Ajuste na função CalDSRHex para usar o   ³±±
±±³            ³          ³                ³mnemônico P_DSRCCMAT para controle de    ³±±
±±³            ³          ³                ³padamento do DSR centralizado pelo Centro³±±
±±³            ³          ³                ³de Custo da Matrícula (padrão do sistema)³±±
±±³            ³          ³                ³ou gerar o DSR pelo Centro de Custo da   ³±±
±±³            ³          ³                ³verba de base.                           ³±±
±±³M. Silveira ³26/01/2017³MRH-4657 	   ³Ajuste em CalDsrHex p/considerar as horas³±±
±±³            ³          ³          	   ³conforme a tabela do Ponto: P_LDSRHRSP.  ³±±
±±³Gabriel A.  ³26/01/2017³MRH-4868        ³Ajuste no cálculo de rescisão para       ³±±
±±³            ³          ³                ³horista quando são lançadas horas na RGB.³±±
±±³Renan Borges³31/01/2017³MRH-5615        ³Ajusta para no calculo de professor seja ³±±
±±³            ³          ³                ³calculado os dias trabalhados corretamen-³±±
±±³            ³          ³                ³te, de acordo com o cadastro de periodos,³±±
±±³            ³          ³                ³e quando houver afastamento.             ³±±
±±³Marcos Couts³28/09/2017³DRHESOCP-1362   ³Realizar os ajustes necessários para que ³±±
±±³            ³          ³                ³ao ser gerado a rescisão coletiva, não   ³±±
±±³            ³          ³                ³seja apresentado errorlog no calculo de  ³±±
±±³            ³          ³                ³Calculo de Dsr Sobre Horas Extras        ³±±
±±³Eduardo K.  ³13/10/2017³MPRIMESP-11722  ³Ajuste para proporcionalizar verbas      ³±±
±±³            ³          ³                ³corretamente quando existir prorrogação  ³±±
±±³            ³          ³                ³de licença maternidade.                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CALC_ARRE³ Autor ³ Equipe de RH          ³ Data ³ 01/03/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ calcula Arredondamento                                     ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Calc_Arre(nVal,nArred,nValarr,cSemana)
Local nResto := Mod(nVal,nArred)

If Round(nResto,2) > 0.00
	nValarr := ( nArred - nResto )
	nVal    := ( nVal  +  nValarr )
Else
	nValarr := 0.00
EndIf

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fSalario ³ Autor ³ Mauro                 ³ Data ³ 29.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula Salario Dia Hora e Mes                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ fSalario(Salario,Salhora,Saldia,Salmes,Tipo)               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Codigo = Codigo da Verba que deseja                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fSalario(Salario,SalHora,SalDia,SalMes,cTipo,cAnMes,cNroPagto, cCatMensal)
Local aArea			:= GetArea()
Local cKeySeek		:= ""
Local dData			:= CtoD("//")
Local lMAprendiz  	:= GetMvRH("MV_MAPREND",,.F.)
Local nDiasCalc		:= 0
Local nHrsCalc		:= 0
Local nValor		:= 0
Local cMes			:= ""
Local cAno			:= ""
Local nNumSemana	:= 0
Local nDiasSem		:= 7

DEFAULT cCatMensal    := "M"

If ExistFunc("fUsaGFP") .and. fUsaGFP()	//Se utiliza o modulo de Gestao de Folha Publica - SIGAGFP, acrescenta as novas categorias para mensalistas
	cCatMensal += "*0*1*2*3*4*5*6*7*8*9"
EndIf

If cPaisLoc == "BRA" .And. SRA->RA_CATFUNC == "S"
	If Type("P_NTOTDIAS") == "U"
		SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_NTOTDIAS")
	EndIf
	nDiasSem := P_NTOTDIAS
EndIf

If cPaisLoc == "RUS"
	cCatMensal += "*R"
EndIf

DEFAULT cAnMes      := If(Empty(cAnMes),(If(Type("cAnoMes") # "U", cAnoMes, MesAno(dDataBase))), cAnMes)
DEFAULT cNroPagto	:= If(Empty(cNroPagto),(If(Type("cSemana") # "U", cSemana, "01")), cNroPagto)

	cMes			:= SubStr(cAnMes,5,2)
	cAno			:= SubStr(cAnMes,1,4)
	dData			:= CtoD("01/" + cMes + "/" + cAno)

	dbSelectArea("RCF")
	dbSetOrder(5)  // RCF_FILIAL+RCF_PER+RCF_SEMANA+RCF_ANO+RCF_MES+RCF_PROCES+DTOS(RCF_DTINI)+DTOS(RCF_DTFIM)+RCF_MODULO
	cKeySeek	:= cAnMes + cNroPagto + cAno + cMes + SRA->RA_PROCES
	If RCF->( dbSeek(xFilial("RCF") + cKeySeek) )
		If cPaisLoc == "BRA" .And. Type("cTipoRot") # "U" .And. cTipoRot == "4" .And. (RCF->RCF_DPERIO == 31  .Or. RCF->RCF_MES == "02")
			SetMnemonicos(SRA->RA_FILIAL, NIL, .T., "P_DIASRES", .T.)
			If P_DIASRES = 1
				nDiasCalc	:= RCF->RCF_DPERIO
			Else
				nDiasCalc	:= RCF->RCF_DCALCM
			EndIf
		Else
			nDiasCalc	:= RCF->RCF_DCALCM
		EndIf
	ElseIf ( nModulo == 19 .Or. nModulo == 95 ) .And. AllTrim(GetNewPar('MV_NGINTER','N')) == 'M'
		//quanto integrado MNT X RM, não se utiliza periodos (RCF), portanto o calculo segue a regra antiga da v11
		// para alimentar a tabela de funcionarios da Manutenção (ST1)
		nDiasCalc	:= 30
	EndIf

	If nDiasCalc > 0 .And. SRA->RA_HRSDIA > 0
		nHrsCalc := Round((SRA->RA_HRSDIA * nDiasCalc),2)
	elseIf SRA->RA_HRSMES > 0
		nHrsCalc := SRA->RA_HRSMES
	EndIf

	// Menor Aprendiz
	If SRA->RA_CATEG = '07' .And. lMAprendiz

		If nDiasCalc > 0 .And. SRA->RA_HRSMES > 0
			nHrsCalc := SRA->RA_HRSMES
		EndIf

		 Do Case
			Case F_ULTDIA(dData) == 31
				nNumSemana := 4.428571
			Case F_ULTDIA(dData) == 30
				nNumSemana := 4.285714
			Case F_ULTDIA(dData) == 29
				nNumSemana := 4.142857
			Case F_ULTDIA(dData) == 28
				nNumSemana := 4
		EndCase
		If SRA->RA_CATFUNC = "H"
			nValor :=  nHrsCalc  / 5
			nValor := (nValor * nNumSemana) * SRA->RA_SALARIO
			SalMes := (nValor * 7 ) / 6
		ElseIf SRA->RA_CATFUNC $ cCatMensal
				Salmes := SRA->RA_SALARIO
		EndIf
		RestArea(aArea)
		Salario  := SalMes
		Return
	EndIf

	If ( SRA->RA_CATFUNC $ cCatMensal )
		SalMes := SRA->RA_SALARIO
	EndIf

	If ( SRA->RA_CATFUNC $ "C*P*A*E" )
		If ( SRA->RA_TIPOPGT == "S" )
			SalMes := ( SRA->RA_SALARIO / 7 ) * nDiasCalc
		EndIf
		If ( SRA->RA_TIPOPGT == "M" )
			SalMes :=  SRA->RA_SALARIO
		EndIf
	EndIf

	If ( SRA->RA_CATFUNC $ "H*G*T" )
		SalMes:= SRA->RA_SALARIO * nHrsCalc
	EndIf

	If ( SRA->RA_CATFUNC == "D" )
		SalMes:= SRA->RA_SALARIO * nDiasCalc
	EndIf

	If ( SRA->RA_CATFUNC == "S" )
		SalMes:= ( SRA->RA_SALARIO / nDiasSem  ) * nDiasCalc
	EndIf

	If ( SRA->RA_TIPOPGT == "M" )
		If ( SRA->RA_CATFUNC $ cCatMensal .or. SRA->RA_CATFUNC $ "C*P*A*E" )
			SalDia := SRA->RA_SALARIO / nDiasCalc
			SalHora := SRA->RA_SALARIO /  (nDiasCalc  *    SRA->RA_HRSDIA)
		EndIf
		If ( SRA->RA_CATFUNC $ "H*T*G" )
			SalDia:=  SRA->RA_SALARIO * SRA->RA_HRSDIA
			SalHora:= SRA->RA_SALARIO
		EndIf
		If ( SRA->RA_CATFUNC == "D" )
			SalDia:= SRA->RA_SALARIO
			SalHora:= SRA->RA_SALARIO /  SRA->RA_HRSDIA
		EndIf
	EndIf

	If ( SRA->RA_TIPOPGT == "S" )
		If ( SRA->RA_CATFUNC $ "H*G" )
			SalHora:= SRA->RA_SALARIO
			SalDia:=  (SRA->RA_SALARIO * SRA->RA_HRSDIA)
		EndIf
		If ( SRA->RA_CATFUNC $ "S*T*C*P*A*E" )
			If ( SRA->RA_CATFUNC == "S" )
				SalDia:= ( SRA->RA_SALARIO / nDiasSem )
				SalHora:= (SRA->RA_SALARIO / nDiasSem)  /  SRA->RA_HRSDIA
			Else
				SalDia:= ( SRA->RA_SALARIO / 7 )
				SalHora:= (SRA->RA_SALARIO / 7)  /  SRA->RA_HRSDIA
			EndIf
		EndIf
		If ( SRA->RA_CATFUNC == "D" )
			SalHora:= SRA->RA_SALARIO /  SRA->RA_HRSDIA
			SalDia:= SRA->RA_SALARIO
		EndIf
	EndIf

	Salario  := SalMes

	RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Salfam   ³ Autor ³ Mauro                 ³ Data ³ 23.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo do Salario Familia                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aCodfol   = Matriz Contendo as Ref. das Verbas             ³±±
±±³          ³ Sal_famil = Valor a Ser Calculado Passado como Referencia  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function SalFam(aCodfol,Sal_Famil,cGrava,dDataDem)
Local 	aArea		:= GetArea()
Local   aSRBArea	:= SRB->(GetArea())

Local   nSalAux 	:= Salario
Local   nSalMulV	:= 0
Local	nVb			:= 0
Local   nPosVbApd	:= 0
Local 	cVerbas_Aux	:= ""
Local 	cFil 		:= xFilial("SRV")
Local	llDepSf		:= Iif(SRA->(FieldPos("RA_DEPSF"))>0,.T.,.F.)
Local	nQtdeDepSF	:= 0
Local 	nIdade   	:= 0
Local 	dDaCalc		:= dDataAte //Atualizacao da Variavel ddacalc para não utilizar o DDATABASE
Local	lSaldoSal	:= .T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se for calc.p/funcionario com  multiplos vinculos, tenho q³
//³ utilizar o salario que foi acumulado de todas as matricu- ³
//³ las p/gerar o sal.Familia                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type("lUtiMultiV")<> "U" .and. lUtiMultiV
	nSalAux  := Max(Salario,SRA->RA_SALARIO)
	nSalMulV := fBuscaPd(aCodFol[318,1],"V",cSemana)
	nSalAux  := Max(nSalMulV,nSalAux)
EndIf

If SRA->RA_TPCONTR == "3" .And. !Empty(aConvocacao[1]) .And. !aConvocacao[6]
	Aeval( aPd ,{ |X| SomaInc(X,21,@NSFINTERM, , , , , , ,aCodfol) })
	NSFINTERM += nSalAux
	Return
EndIf
dDatadem := If(dDatadem = Nil,SRA->RA_DEMISSA,dDatadem)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Array que contem as variaveis criadas por fVarRot()       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type("aVarRot") = "U"
	aVarRot := {}
EndIf

If llDepSf
	If Val(SRA->RA_DEPSF) > 0

	    //-- Somente para o BRASIL aplica as regras de validade de idade para considerar os dependentes
	    //-- validos para o beneficio do salario-familia
		If cPaisLoc == "BRA"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Controla idade dos dependentes Salario Familia            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea( "SRB" )
			//-- Se nao existir dependentes de salario familia assume o
			//-- registrado no cadastro de funcionarios (legado)
			If ! dbSeek(SRA->RA_FILIAL + SRA->RA_MAT)
				nQtdeDepSF := VAL(SRA->RA_DEPSF)
			Else
				//Verificar se existem dependentes
				While SRB->(!Eof() .And. SRB->RB_FILIAL + SRB->RB_MAT == SRA->RA_FILIAL + SRA->RA_MAT)

					//-- Somente se o dependente for filho/Outros
					If (Upper(SRB->RB_GRAUPAR) <>"C")

					    //-- *** Somente se não houver limite de idade  ou
						If (SRB->RB_TIPSF == "1")
							nQtdeDepSF += 1
						//-- *** Dependente ate 14 anos
						//-- ****** Nascidos ate a data de calculo
						ElseIF (SRB->RB_TIPSF == "2") .and. ;
						 	   ( AnoMes(ddacalc)>= AnoMes(SRB->RB_DTNASC) )
		 					    //-- Menor de 14 anos ou igual a 14 mas, nesse ultimo caso, completa anos
		 					    //-- ate o mes de referencia inclusive
		 					    //-- Exemplo: Nascto: 01/10/11 ou 31/10/11 e calculo referente a 'Outubro',
		 					    //-- o dependente devera ser considerado.
		 					    //-- No entanto, na folha referente a 'Novembro', o dependente nao devera ser
		 					    //-- considerado no SF pois ja se trata do mes seguinte ao do aniversario de
		 					    //-- 14 anos.
	 							nIdade   	:= CALC_IDADE(ddacalc,SRB->RB_DTNASC)
		 						If ( nIdade < 14 )  .or. ;
		 						   ( 	( nIdade = 14 ) .and. ;
		 						   		( MesAno(ddacalc) <= MesAno(YearSum( SRB->RB_DTNASC , 14 ) ) );
		 						   	)
									nQtdeDepSF += 1
								EndIf

			 			EndIf

					EndIf
					SRB->(dbSkip())
				EndDo
			EndIf
			RestArea(aSRBArea)
		Else
			nQtdeDepSF := VAL(SRA->RA_DEPSF)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Para semanalistas, deve calcular somente na ultima semana ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( SRA->RA_TIPOPGT = "S" .And. ! lUltSemana ) .And. If( SRA->RA_CATFUNC = "S", cTipoRot <> "4", .T. )
			Return
		EndIf

		If SRA->RA_TPCONTR != "3"
			nSalfami_b := 0.00
		Else
			nSalfami_b += NSFINTERM
		EndIf

		If Ascan(aPd, { |X| X[1] = aCodfol[34,1] .And. X[9] # "D"}) = 0

			// As verbas de DSR horista e Hrs. Atividade devem ser buscadas diretamente do aPd,
			// pois nao devem possuir incidencia para salario familia.
			// SOMA INCIDENCIA PARA SALARIO FAMILIA
			Aeval( aPd ,{ |X| SomaInc(X,21,@nSalfami_B, , , , , , ,aCodfol) })

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Proporcionaliza salario conforme as hrs efetivamente      ³
			//³ trabalhadas no mes                                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If  !P_SALFHOR .And. (cTipoRot == "4" .Or. cRot == fGetRotOrdinar( , SRA->RA_FILIAL ) ) .And. SRA->RA_CATFUNC $ "H*T*G*C"
				nSalAux	:= Round( ( SalHor * Round( NHORASTRAB, MsDecimais(1) ) ), MsDecimais(1)) + Round( ( SalHor * Round( DESCANSO, MsDecimais(1) )  ), MsDecimais(1))

				//Recompoe a base do comissionado puro, para ficar compativel ao calculo feito pelo HomologNet no MTE.
				If SRA->RA_CATFUNC == "C" .And. nSalAux == 0
					nSalfami_B := Round( ( (nSalFami_b / DiasTrab) * nDiasC ), MsDecimais(1))
				EndIf
			EndIf

			// SE JORNADA VARIAVEL, BUSCA O VALOR DO SALÁRIO DAS VERBAS DO GRUPO 0
			If SRA->RA_CATFUNC = "H" .And. SRA->(ColumnPos( "RA_HOJORVA")) > 0 .And. SRA->RA_HOJORVA = "1"
				//Busca as verbas que estão no grupo 0, campo RV_GRPVERB = 0
				GP140GrpVerb(cFil,@cVerbas_Aux,"0",.T.)
				For nVb := 1 To Len(cVerbas_Aux) Step 3
					If lSaldoSal .And. aCodFol[0032,1] $ SubStr(cVerbas_Aux,nVb,3)
						lSaldoSal := .F.
						If (nPosVbApd := Ascan(aPd, { |X| X[1] = aCodFol[0048,1] .And. X[9] # "D"})) > 0
							nSalFami_b += aPd[nPosVbApd,5]
						Endif
					Endif
					If (nPosVbApd := Ascan(aPd, { |X| X[1] = SubStr(cVerbas_Aux,nVb,3) .And. X[9] # "D"})) > 0
						//Se a verba já compor a base de salário familia não será considerada.
						If RetValSRV(aPd[nPosVbApd,1],SRA->RA_FILIAL,"RV_SALFAMI") <> "S"
							//Verifica o tipo da verba para saber se ela será somada ou subtraída da base de salário família.
							If RetValSRV(aPd[nPosVbApd,1],SRA->RA_FILIAL,"RV_TIPOCOD") == "2"
								Aeval( aPd ,{ |X|  If( X[1] ==  SubStr(cVerbas_Aux,nVb,3), nSalFami_b -= X[5],Nil) } )
							Else
								Aeval( aPd ,{ |X|  If( X[1] ==  SubStr(cVerbas_Aux,nVb,3), nSalFami_b += X[5],Nil) } )
							Endif
						Endif
					EndIf
				Next nVb
			Else
				// SOMA O SALARIO BASE AUTOMATICAMENTE NA BASE SAL.FAMILIA
				If Len(aTarefas) == 0  .And. !(SRA->RA_SALARIO == 0 .And. SRA->RA_CATFUNC == "I") //Para professores com tarefa não deve somar a base para não duplicar os valores recebidos
					nSalFami_b += If(nDiasMat > 0 .And. RetValSRV(aCodFol[040,1],SRA->RA_FILIAL,"RV_SALFAMI") == "S", nSalAux / nDiasC * DiasTrab, nSalAux )
				EndIf
			EndIf

			// SOMA O VALOR DA MEDIA DE COMISSAO CALCULADA PARA AFASTAMENTO POR AUXILIO MATERNIDADE
			If aCodFol[238,1] # Space(3) .And. RetValSRV(aCodFol[238,1],SRA->RA_FILIAL,"RV_SALFAMI") == "S"
				nSalFami_b += fVarRot("nMedComiss")
			EndIf

			// SOMA O VALOR DA BASE DE INSS DE OUTRAS EMPRESAS NA BASE DE CALCULO DO SALARIO FAMILIA
			// SOMENTE DEVERA CONFIGURAR A VERBA 288 COM "SIM" SE A EMPRESA NAO UTILIZAR MULTIPLOS VINCULOS
			If aCodFol[288,1] # Space(3) .And. RetValSRV(aCodFol[288,1],SRA->RA_FILIAL,"RV_SALFAMI") == "S"
				Aeval( aPd ,{|X| nSalFami_b += If(X[1] == aCodFol[288,1] .And. X[9] <> "D",X[5],0) })
			EndIf

			// CALCULO DO SALARIO FAMILIA PROPORCIONAL
			DiasFamil :=  If(GetMvRH("MV_SALFD")= "S",nDiasC,P_QTDIAMES)
			DiasBase  :=  If(GetMvRH("MV_SALFD")= "S",nDiasC,P_QTDIAMES)


			If GetMvRH("MV_SALFP") = "S"
				If YEAR(SRA->RA_ADMISSA)=YEAR(dDataAte).AND.MONTH(SRA->RA_ADMISSA)=MONTH(dDataAte).AND.DAY(SRA->RA_ADMISSA) # 1
					// Assume Dias de Cálculo para caso de ADMISSAO
					Diasfamil := If(GetMvRH("MV_SALFD")= "S",nDiasP,Diasfamil)
					Diasfamil := DiasFamil - Day(SRA->RA_ADMISSA) + 1
					If !Empty(dDatadem)
						Diasfamil := (Day(dDatadem) - Day(SRA->RA_ADMISSA)+1)
					EndIf
				Elseif  ! Empty(dDataDem)
					DiasFamil := Day(dDataDem)
				EndIf
			EndIf

			//Se foi admitido no mês, inclui verbas de adicionais integrais
			If AnoMes(SRA->RA_ADMISSA) == cPeriodo .and. ( nSalfami_B <= nLIMSF2 .or. nSalfami_B <= nLIMSF1 ) .and. nPeric + nInsalub + nAdtServ > 0
				For nVb := 1 to Len(aPd)
					If aPd[nVb,9] == "D"
						Loop
					EndIf
					If aPd[nVb,1] $ aCodFol[36,1] + "/" + aCodFol[1281,1] .and. nPeric > 0 .and. RetValSRV(aPd[nVb,1], SRA->RA_FILIAL, "RV_SALFAMI") == "S"
						nSalfami_B -= aPd[nVb,5]
						nSalFami_B += nPeric
					EndIf
					If aPd[nVb,1] $ aCodFol[37,1] + "/" + aCodFol[38,1] + "/" + aCodFol[39,1] + "/" + aCodFol[1282,1] .and. nInsalub > 0 .and. RetValSRV(aPd[nVb,1], SRA->RA_FILIAL, "RV_SALFAMI") == "S"
						nSalfami_B -= aPd[nVb,5]
						nSalFami_B += nInsalub
					EndIf
					If aPd[nVb,1] $ aCodFol[1,1] + "/" + aCodFol[2,1] + "/" + aCodFol[3,1] + "/" + aCodFol[4,1] + "/" + aCodFol[5,1] + "/" + aCodFol[1283,1] + "/" + aCodFol[1284,1] + "/" + aCodFol[1285,1] + "/" + aCodFol[1286,1] + "/" + aCodFol[1287,1] .and. nAdtServ > 0 .and. RetValSRV(aPd[nVb,1], SRA->RA_FILIAL, "RV_SALFAMI") == "S"
						nSalfami_B -= aPd[nVb,5]
						nSalFami_B += nAdtServ
					EndIf 
				Next nVb
			EndIf

			If nSalfami_b <= nLIMSF1
				SAL_FAMIL := nQtdeDepSF * nVAL_SF1 / DiasBase * DiasFamil
				SAL_FAMIL := Min( (nQtdeDepSF * nVAL_SF1), SAL_FAMIL)		// Ajuste p/nao extrapolar o limite do beneficio
			Elseif nSalfami_b <= nLIMSF2
				SAL_FAMIL := nQtdeDepSF * nVAL_SF2 / DiasBase * DiasFamil
				SAL_FAMIL := Min( (nQtdeDepSF * nVAL_SF2), SAL_FAMIL)		// Ajuste p/nao extrapolar o limite do beneficio
			EndIf
			If ((SRA->RA_TIPOPGT = "S") .And. (SRA->RA_CATFUNC $ "S*T") .And. ! lUltSemana .And. If( SRA->RA_CATFUNC = "S", cTipoRot <> "4", .T. )) .Or. (SRA->RA_TPCONTR == "3" .And. NSFINTERM == 0 .AND. Empty(aConvocacao[1]))
				SAL_FAMIL := 0
			EndIf

			If cGrava # Nil .And. cGrava = "S" .And. SAL_FAMIL > 0
				If SRA->RA_TPCONTR == "3"
					nOrdGrPd++
					aadd(aSalBase,{aCodfol[34,1],nSalfami_b,nOrdGrPd})
				EndIf
				FMatriz(aCodfol[34,1],SAL_FAMIL,nQtdeDepSF)
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fHECodCorr  ³ Autor ³ Mauricio MR         ³ Data ³26/12/2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica a existencia de Cod HE para comissionista puro     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GPEA090/GPEA100/GPEXCALC                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fHECodCorr(cFilSRA, cCodCorr, cCodSRV)
Local aArea		:= GetArea()
Local aAreaSRV	:= GetArea("SRV")

Local caliasSRV := 'SRV'
Local cFilSRV	:= xFilial("SRV",cFilSRA)

Local lRet		:=.F.

DEFAULT cCodSRV	:= ''

cAliasSRV := GetNextAlias()
BeginSql alias cAliasSRV
	SELECT SRV.RV_COD,SRV.RV_CODCORR, SRV.RV_HE
	FROM %table:SRV% SRV
	WHERE SRV.RV_FILIAL = %exp:cFilSRV%
		  AND SRV.RV_CODCORR =  %exp:cCodCorr%
		  AND SRV.%NotDel%
EndSql

While (cAliasSRV)->( !Eof() )
    //-- Se a Verba de Hora Extra for codigo correspondente de outra, aborta a pesquisa
	If !Empty( (cAliasSRV)->RV_CODCORR ) .and.  ((cAliasSRV)->RV_CODCORR == cCodCorr ) .and.  ( (cAliasSRV)->RV_HE == 'S' )
		lRet		:=.T.
		cCodSRV		:=  (cAliasSRV)->RV_COD
		Exit
	EndIf
	(cAliasSRV)->( DbSkip() )
EndDo

(cAliasSRV)->(DbCloseArea())

RestArea( aAreaSRV )
RestArea( aArea )

Return lRet



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fHrTrabDesc ³ Autor ³ Mauricio MR        ³ Data ³ 26.12.12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo das Horas Trabalhadas							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nHrsEfTrab =  Horas Efetivas Trabalhadas	                  ³±±
±±³          ³ cSemana    =  Semana referenciada		                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fHrTrabDesc(nHrsEfTrab,cSemana)

Local nPosCFol := 0 // Verba de Comissão Folha
Local nPosCRes := 0 // Verba de Comissão Rescisão.
nHrsEfTrab:= 0
nDiasTrab := 0
nDiasDSR  := 0

If !(cTipoRot == "4") // Se não for rescisão, busca pelo ID de comissão da Folha.
	nPosCFol := Ascan(aPd, { |X| X[1] = aCodfol[165,1] .And. X[3] = cSemana .And. X[9] # "D"})
Else
	// Se for rescisão, procura pelo ID de comissão Rescisão
	nPosCRes := Ascan(aPd, { |X| X[1] = aCodfol[121,1] .And. X[3] = cSemana .And. X[9] # "D"})
EndIf

If ( nPosCFol > 0 .Or. nPosCRes > 0 .Or. SRA->RA_CATFUNC == "C" )
    //Horas Efetivamente Trabalhadas
    If ( aCodfol[638,1] # Space(3) )
		If (nPos :=  Ascan(aPd, { |X| X[1] = aCodfol[638,1] .And. X[3] = cSemana .And. X[9] # "D" .And. X[7] # "C"})) > 0
			nHrsEfTrab:= aPd[nPos,4]
		EndIf
	EndIf

	//-- Se nao existir horas efetivamente trabalhadas obtem atraves dos dias trabalhados/contrato
	If Empty(nHrsEfTrab)
		//Horas Efetivamente Trabalhadas a partir dos dias trabalhados
	    If ( aCodfol[989,1] # Space(3) )
			If (nPos :=  Ascan(aPd, { |X| X[1] = aCodfol[989,1] .And. X[3] = cSemana .And. X[9] # "D" .And. X[7] # "C"})) > 0
				nDiasTrab:= aPd[nPos,4]
			EndIf
		EndIf

		If Empty(nDiasTrab) .and. SRA->RA_CATFUNC == "C" .and. cTipoRot == "4" .and. DiasTrab > 0
			nDiasTrab := DiasTrab
		EndIf

		//Se nao existir dias trabalhados, obtem as horas contratuais/Composicao mes/Turno/Periodo
		If Empty(nDiasTrab)
		   	If Normal > 0
		 		nHrsEfTrab := 	Normal
		   	Else
			   	nHrsEfTrab := SRA->RA_HRSMES //Consideramos todas as horas sem a deducao das horas de DSR.
		   	EndIf
		Else
		   	//Compor as horas efetivas a partir dos dias trabalhados no contrato (SRA)
		   	nHrsEfTrab := ( SRA->RA_HRSEMAN / 6 ) * nDiasTrab
		EndIf
	EndIf
EndIf

Return(Nil)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GeraTarefa³ Autor ³ Equipe R.H.           ³ Data ³ 11.12.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo de Tarefeiros                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GeraTarefa(dDataDe,dDataAte,aTarefas,cGrava)
Local aArea			:= GetArea()
Local aFalHE		:= {}
Local bDataDe   	:= &( "{ || " + "MesAno(SRO->RO_DATA) }" )
Local bDataAte  	:= &( "{ || " + "MesAno(SRO->RO_DATAATE) }" )
Local cChaveBus 	:= SRA->RA_FILIAL + SRA->RA_MAT
Local cCCAtual  	:= ""
Local cCodTarefa
Local nValTarefa
Local nCnt
Local cTipVerba
Local nPos
Local cPerAtual 	:= ""
Local cItAtual  	:= ""
Local cClAtual  	:= ""
Local cTarHE		:= ""
Local cTarFal		:= ""
Local cTab			:= "S070"
Local lItemClVl 	:= GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"
Local cItCt 		:= If(lItemClVl,SRA->RA_ITEM,'')
Local cClCt 		:= If(lItemClVl,SRA->RA_CLVL,'')
Local dDtInTar		:= Ctod("//")
Local dDtFiTar		:= Ctod("//")
Local dDtFimTar		:= Ctod("//")
Local lGeraTarefa 	:= .T.
Local nTarTot		:= 0
Local nQtdSem		:= 0
Local nQtdTar		:= 0 // Proporcionalizar qtde. semanas pela qtde. de dias da tarefa
Local nQtDTarM		:= 0
Local nHrsExt		:= 0
Local nHrsFal		:= 0
Local nValHE		:= 0
Local nValFal		:= 0
Local nUltDia		:= 0
Local nDNTrab		:= 0
Local nPosTab		:= 0
Local nTarAux		:= 0

local aPer			:= {}
local lultSem
local nPosSe		:= 0
Local lPropTar   := GetMvRH("MV_PROPTAR",,.F.)

Private aTarAux   	:= {}

if Type("nDiasC") == "U" .AND. Type("aPeriodo") == "U"

	CPERIODO 	:= IF(EMPTY(CPERIODO),GETPERIODCALC(),CPERIODO)
    CROT 		:= IF(EMPTY(CROT),GETROTEXEC(),CROT)
    CROT 		:= IF(CROT=="INC",FGETROTORDINAR(),CROT)

    FCARPERIODO( CPERIODO , CROT , @aPer, @lultSem, @nPosSe)

     IF ( LEN(aPer) > 0 )
     	nDiasC := aPer[nPosSe,20]
     EndIf

EndIf

If CROT == "ADI"
	cGrava := "N"
EndIf

If Type("aPeriodo") <> "U" .AND. Len(aPeriodo) > 0
	cPerAtual := aPeriodo[nPosSem,15] + aPeriodo[nPosSem,16]		 //RCF_ANO + RCF_MES //Periodo de calculo
Else
	cPerAtual := MesAno( dDatade )
EndIf

lNewProf := GetMVRH("MV_NCPROF",,"2") == "1" .and. SRA->( RA_CATFUNC $ "I*J" )

If Type("aOrigTar") == "U" .Or. !Empty(aOrigTar)
	aOrigTar := {}
EndIf

//-- Verificar se estou em rescisao complementar fora do mes para ajustar o mes e ano aberto
If Type("cCompl") <> "U" .And. cCompl == "S" .And. Type("lProxMes") <> "U" .And. lProxMes
	cPerAtual := MesAno(dDatadem)
EndIf

If Type("aErrProc") == "U"
	aErrProc := Array(1,0)
EndIf

If Type("aAfaTar") == "U"
	aAfaTar := {}
EndIf

aTarefas	:= {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Gera Tarefas a partir do array aPd - Movimento Mensal		   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cGrava = "S" .And. !Empty(dDataDe)
	For nCnt := 1 To Len(aPd)
		lGeraTarefa	:= .T.
		cCodTarefa := RetValSrv(aPd[nCnt,1],SRA->RA_FILIAL,"RV_TAREFA")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Este teste verifica se o conteudo do campo RV_TAREFA contem o  |
		//| codigo da tarefa, pois podera conter tambem [S]im ou [N]ao.    |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(AllTrim(cCodTarefa)) == 3 .And. aPd[nCnt,6] $ "H/D" .And. aPd[nCnt,9] # "D"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Caso esteja na incorporacao, a verba tenha menos de 1 parcela e|
			//| a rescisao estiver no mes seguinte, nao criaremos a tarefa pois|
			//| esta tarefa nao faz parte da rescisao no mes seguinte.         |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Type("P_SALINC") <> "U" .And. P_SALINC
				If aPd[nCnt,8] <= 1
					If Type("lRescMSeg") <> "U" .And. lRescMSeg
						lGeraTarefa	:= .F.
					EndIf
				EndIf
			EndIf
			If lGeraTarefa
				If (nPosTab := fPosTab( cTab,cPerAtual,"=",2,cCodTarefa,"=",4)) == 0
					nPosTab := fPosTab( cTab,Space(6),"=",2,cCodTarefa,"=",4)
				EndIf

				If nPosTab > 0
					cTipVerba   := RetValSRV(aPd[nCnt,1],SRA->RA_FILIAL,"RV_TIPOCOD")
					nValTarefa  := fTabela(cTab,nPosTab,6)
					aPd[nCnt,5] := aPd[nCnt,4] * nValTarefa
					Aadd( aTarefas , { aPd[nCnt,1], aPd[nCnt,5], aPd[nCnt,12], aPd[nCnt,4], aPd[nCnt,2], aPd[nCnt,10], cTipVerba, "SRC", "2", aPd[nCnt,13], aPd[nCnt,14], 0, 0, 0, "", "", 0, 0, aPd[nCnt,18] } )
				EndIf
			EndIf
		EndIf
	Next nCnt
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Array que contera as tarefas acumuladas por Verba+C.C.		   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aTarAux := aClone(aTarefas)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Gera Tarefas a partir do arquivo SRO - Lancamentos de Tarefas  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea( "SRO" )
dbSeek( cChaveBus )
While !EOF() .And. ( cChaveBus == SRO->RO_FILIAL + SRO->RO_MAT )
	lCalcTarefa := .F.

	If SRO->RO_TIPO $ "1*3" //1-Tarefa Fixa / 3-Aditamento Fixo
		If Empty(cPerAtual)      .Or. ( Eval(bDataDe)  <= cPerAtual .And.;
		  (Empty(SRO->RO_DATAATE) .Or.   Eval(bDataAte) >= cPerAtual) )
			lCalcTarefa := .T.
        EndIf
	Else //2-Tarefa Variavel / 4-Aditamento Variavel
		If !Empty(dDataDe)
			If (SRO->RO_DATA    <= dDataAte) .And. ( Empty(SRO->RO_DATAATE) .Or.;
			   (SRO->RO_DATAATE >= dDataDe) )
				lCalcTarefa := .T.
			EndIf
		EndIf
	EndIf
	If lCalcTarefa .And. Ascan( aTarefas, { |X| X[1] == SRO->RO_VERBA .And. X[8] == "SRC" }) == 0
		cCCAtual  := If(Empty(SRO->RO_CC), SRA->RA_CC, SRO->RO_CC)
		cItAtual  := If(lItemClVl,If( Empty(SRO->RO_ITEM), cItCt, SRO->RO_ITEM), "" )
		cClAtual  := If(lItemClVl,If( Empty(SRO->RO_CLVL), cClCt, SRO->RO_CLVL), "" )
		cTipVerba := RetValSRV(SRO->RO_VERBA,SRO->RO_FILIAL,"RV_TIPOCOD")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Buscar valores atualizados das tarefas no dissidio retroativo e|
		//| na rescisao complementar.                                      |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( Type("lDissidio") # "U" .And. lDissidio ) .Or. ( Type("cCompl") # "U" .And. cCompl == "S" )
			If (nPosTab := fPosTab( cTab,cPerAtual,"=",2,SRO->RO_CODTAR,"=",4)) == 0
				nPosTab := fPosTab( cTab,Space(6),"=",2,SRO->RO_CODTAR,"=",4)
			EndIf
			If nPosTab > 0
				nTarTot := SRO->RO_VALTOT / SRO->RO_VALOR * fTabela(cTab,nPosTab,6)
			EndIf
		Else
			nTarTot	:= SRO->RO_VALTOT
		EndIf

		nQtdSem := SRO->RO_QTDSEM
		nQtdTar	:= SRO->RO_QUANT

		nHrsExt	:= nHrsFal	:=	nValHE	:=	nValHE	:=	nQtDTarM	:=	nDNTrab	:=	0
		cTarHE	:= cTarFal	:= ""

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Inclui todas as tarefas lancadas com seus valores originais    |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nQtdTar > 0
			Aadd( aOrigTar, { SRO->RO_VERBA, nTarTot, nQtdSem, nQtdTar, cCCAtual, SRO->RO_DATA, cTipVerba, "SRO", SRO->RO_TIPO, cItAtual, cClAtual, nQtDTarM, nHrsExt, nHrsFal, cTarHE, cTarFal, nValHE, nValFal } )
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Novo tratamento para o calculo de professores.                 |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lNewProf

			nUltDia := f_UltDia( Stod( cPerAtual + "01" ) ) // Ultimo dia do mes

			// Ajuste da data de inicio da tarefa no mes
			dDtInTar := If( MesAno(SRO->RO_DATA) == cPerAtual, SRO->RO_DATA, Stod( cPerAtual + "01" ) )

			// Ajuste da data final da tarefa no mes
			dDtFiTar := If( Empty(SRO->RO_DATAATE) .Or. MesAno(SRO->RO_DATAATE) > cPerAtual, Stod( cPerAtual + StrZero( nUltDia, 2 ) ), SRO->RO_DATAATE )

			// Ajusta data final da tarefa de acordo com demissao
			If Type("dDataDem") # "U" .And. !Empty(dDataDem) .And. MesAno(dDataDem) == MesAno(dDtFiTar) .And. dDataDem < dDtFiTar
				dDtFiTar := dDataDem

				If dDtInTar > dDataDem
					dDtInTar := dDataDem + 1 // Adiciona 1 dia na data de inicio para tarefas iniciadas apos demissao para zerar calculo
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Calcula qtde. de dias da tarefa no mes						   |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nQtDTarM := dDtFiTar - dDtInTar + 1

			If nQtDTarM > 0

				nQtDTarM := If( nQtDTarM > nDiasC, nDiasC, nQtDTarM ) // Limitar a geracao das tarefas a 30 dias no mes
				If SRO->RO_TIPO $ "1/3" .or. (lPropTar .And. SRO->RO_TIPO $ "2/4")
					nQtDTarM -= ( Min(nDiasAfas,nDiasC) - nDiasMat )// Abater afastamentos dos dias da tarefa
				EndIf

				If nQtDTarM == nDiasP // RCF_DPERIO
					nQtDTarM := nDiasC
				EndIf
				nQtdSem		:= NoRound( SRO->RO_QTDSEM / nDiasC * nQtDTarM, MsDecimais(1) ) // Proporcionalizar qtde. semanas pela qtde. de dias da tarefa
				nQtdTar		:= NoRound( SRO->RO_QUANT / nDiasC * nQtDTarM, MsDecimais(1) ) // Proporcionalizar qtde. semanas pela qtde. de dias da tarefa
				nTarAux     := nTarTot
				nTarTot		:= nTarTot / nDiasC * nQtDTarM // Proporcionalizar tarefa total pela qtde. de dias da tarefa
				nHrsExt		:= SRO->RO_HRSEXT
				nHrsFal		:= SRO->RO_HRSFAL
			EndIf

			If ( ( nHrsExt + nHrsFal ) > 0 )
				If (nPosTab := fPosTab( cTab,cPerAtual,"=",2,SRO->RO_CODTAR,"=",4)) == 0
					nPosTab := fPosTab( cTab,Space(6),"=",2,SRO->RO_CODTAR,"=",4)
				EndIf
				If nPosTab > 0
					cTarHE	:= fTabela(cTab,nPosTab,9)
					cTarFal	:= fTabela(cTab,nPosTab,10)

					If nHrsExt > 0 .And. fIncide(cTarHE)
						nPos := aScan( aPdv, { |x| x[1] == cTarHE } )
						nValHE	:= nHrsExt * SRO->RO_VALOR * aPdv[ nPos, 2 ] / 100
					EndIf

					If nHrsFal > 0 .And. fIncide(cTarFal)
						nPos := aScan( aPdv, { |x| x[1] == cTarFal } )
						nValFal	:= nHrsFal * SRO->RO_VALOR * aPdv[ nPos, 2 ] / 100
					EndIf
				EndIf
			EndIf
		EndIf

		dbSelectArea( "SRO" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Inclui todas as tarefas lancadas (necessario p/Calculo do DSR) |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nQtdTar > 0 .Or. (nValHE + nValFal) > 0
            If (SRA->RA_CATFUNC $ "I*J")
				Aadd( aTarefas, { SRO->RO_VERBA, nTarTot, nQtdSem, nQtdTar, cCCAtual, SRO->RO_DATA, cTipVerba, "SRO", SRO->RO_TIPO, cItAtual, cClAtual, nQtDTarM, nHrsExt, nHrsFal, cTarHE, cTarFal, nValHE, nValFal } )
			Else
				dDtFimTar := If( !Empty(SRO->RO_DATAATE), SRO->RO_DATAATE, dDataAte )
				dDtFimTar := If( dDtFimTar > dDataAte, dDataAte, dDtFimTar )
				Aadd( aTarefas, { SRO->RO_VERBA, nTarTot, nQtdSem, nQtdTar, cCCAtual, SRO->RO_DATA, cTipVerba, "SRO", SRO->RO_TIPO, cItAtual, cClAtual, nQtDTarM, nHrsExt, nHrsFal, cTarHE, cTarFal, nValHE, nValFal, dDtFimTar } )
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Totaliza tarefas por Verba+Centro de Custo (para Lanc. no SRC) |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPos := Ascan( aTarAux, { |X| X[1] == SRO->RO_VERBA .And. X[5] == cCCAtual .And. X[10] == cItAtual  .And. X[11] == cClAtual} )

			If lNewProf .and. nDiasMat > 0 .and. nTarTot > 0 .and. ( SRO->RO_TIPO $ "1/3" .or. (lPropTar .And. SRO->RO_TIPO $ "2/4") )
				nTarAux     := nTarAux / nDiasC * ( nQtDTarM - nDiasMat )
			Else
				nTarAux := nTarTot
			EndIf

			If nPos > 0
				aTarAux[nPos,02] += nTarAux
				aTarAux[nPos,03] += nQtdSem
				aTarAux[nPos,04] += nQtdTar
				aTarAux[nPos,12] += nQtDTarM
				aTarAux[nPos,13] += nHrsExt
				aTarAux[nPos,14] += nHrsFal
				aTarAux[nPos,17] += nValHE
				aTarAux[nPos,18] += nValFal
			Else
				Aadd( aTarAux, { SRO->RO_VERBA, nTarAux, nQtdSem, nQtdTar, cCCAtual, SRO->RO_DATA, cTipVerba, "SRO", SRO->RO_TIPO, cItAtual, cClAtual, nQtDTarM, nHrsExt, nHrsFal, cTarHE, cTarFal, nValHE, nValFal } )
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Totaliza tarefas por Verba+Centro de Custo (para Lanc. no SRC) |
		//| das horas-extras dos professores.                              |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nHrsExt > 0 .And. !Empty(cTarHE) .And. nValHE > 0
			nPos := Ascan( aFalHE, { |X| X[1] == cTarHE .And. X[5] == cCCAtual .And. X[10] == cItAtual  .And. X[11] == cClAtual} )
			If nPos > 0
				aFalHE[nPos,02] += nValHE
				aFalHE[nPos,03] += nQtdSem
				aFalHE[nPos,04] += nHrsExt
				aFalHE[nPos,12] += nQtDTarM
				aFalHE[nPos,13] += nHrsExt
				aFalHE[nPos,14] += nHrsFal
				aFalHE[nPos,17] += nValHE
				aFalHE[nPos,18] += nValFal
			Else
				Aadd( aFalHE, { cTarHE, nValHE, nQtdSem, nHrsExt, cCCAtual, SRO->RO_DATA, cTipVerba, "SRO", SRO->RO_TIPO, cItAtual, cClAtual, nQtDTarM, nHrsExt, nHrsFal, cTarHE, cTarFal, nValHE, nValFal } )
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Totaliza tarefas por Verba+Centro de Custo (para Lanc. no SRC) |
		//| das faltas dos professores.                                    |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nHrsFal > 0 .And. !Empty(cTarFal) .And. nValFal > 0
			nPos := Ascan( aFalHE, { |X| X[1] == cTarFal .And. X[5] == cCCAtual .And. X[10] == cItAtual  .And. X[11] == cClAtual} )
			If nPos > 0
				aFalHE[nPos,02] += nValFal
				aFalHE[nPos,03] += nQtdSem
				aFalHE[nPos,04] += nHrsFal
				aFalHE[nPos,12] += nQtDTarM
				aFalHE[nPos,13] += nHrsExt
				aFalHE[nPos,14] += nHrsFal
				aFalHE[nPos,17] += nValHE
				aFalHE[nPos,18] += nValFal
			Else
				Aadd( aFalHE, { cTarFal, nValFal, nQtdSem, nHrsFal, cCCAtual, SRO->RO_DATA, cTipVerba, "SRO", SRO->RO_TIPO, cItAtual, cClAtual, nQtDTarM, nHrsExt, nHrsFal, cTarHE, cTarFal, nValHE, nValFal } )
			EndIf
		EndIf
	EndIf

	SRO->( dbSkip() )
EndDo

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Ponto de Entrada para alterar o conteudo do array aTarefas     |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("GPTAREFA")
	EXECBLOCK("GPTAREFA",.F.,.F.)
EndIf

If lNewProf .And. aScan( aTarAux, { |x| x[9] == "1" } ) == 0
	If Empty( aErrProc[1] )
		aAdd( aErrProc[1], PadR( OemtoAnsi(STR0029), 16 ) + PadR( OemtoAnsi(STR0030), 13 ) + OemtoAnsi(STR0031) + CRLF )  //"Filial" ### "Matrícula" ### "Nome"
	EndIf

	aAdd( aErrProc[1], PadR( SRA->RA_FILIAL, 16 ) + PadR( SRA->RA_MAT, 13 ) + SRA->RA_NOME + CRLF )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Grava as Tarefas em aPd ou no Movimento Mensal - SRC		   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type("lUtiMultiV") == "U" .And. cGrava # Nil .And. Len( aTarefas ) > 0
	If cGrava = "S"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| X[6]="SRC" indica que a tarefa ja esta em aPD (nao sera gerada)|
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cTipoRot $ "3*4*5*6*"  // FER / RES / 131 / 132
			AeVal( aTarAux	, { |X| If(!(X[8]$"SRC*RGB") .And. x[9] = "1", IncorpSal(x[02]), (If(cTipoRot $ "3*4" ,FMatriz(X[01],  X[02],X[04],    ,X[5],"V"  ,     ,    ,    ,    ,       ,    ,X[3]   ,X[10],X[11]), ""))) } )
	   		AeVal( aFalHE	, { |X| If(!(X[8]$"SRC*RGB") .And. x[9] = "1", IncorpSal(x[02]), "") } )
		Else
			AeVal( aTarAux	, { |X| If(!(X[8]$"SRC*RGB"), FMatriz(X[01],  X[02],X[04],    ,X[5],"V"  ,     ,    ,    ,    ,       ,    ,X[3]   ,X[10],X[11]), "") } )
	   		AeVal( aFalHE	, { |X| If(!(X[8]$"SRC*RGB"), FMatriz(X[01],  X[02],X[04],    ,X[5],"V"  ,     ,    ,    ,    ,       ,    ,X[3]   ,X[10],X[11]), "") } )
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return( Nil )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fDsrTarefa³ Autor ³ Emerson Rosa de Souza ³ Data ³ 25.07.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo do DSR sobre as tarefas                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fDsrTarefa(aTarefas,aDsrTarefa,cGrava)
Local nValorDsr   := 0
Local nNroTarefa  := 0
Local nDiasTrab	  := 0
Local aDsrAux     := {}
Local cCcGerados  := ""
Local nCnt, nCnt1

aDsrTarefa := {}

If Len(aTarefas) > 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Soma os valores da Tarefa por Data e por Centro de Custo       |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nCnt := 1 To Len(aTarefas)
		//-- O DSR de tarefeiro eh o resultado da soma dos valores das tarefas produzidas na semana dividido pelos
		//-- dias efetivamente trabalhados.
		//-- Ex: No. tarefas executadas na semana: 25
		//-- 	 Dias trabalhados na semana: 6
		//--     Valor da tarefa: R$ 10,00
		//--     Salario: 25 * R$ 10,00 = R$ 250,00
		//--     RSR: R$ 250,00 / 6 = R$ 41,66
		If ( SRA->RA_CATFUNC == "T" )
			nPos := Ascan( aDsrAux , { |X| X[2] == aTarefas[nCnt,5] } )
			If nPos > 0
				aDsrAux[nPos,1] += aTarefas[nCnt,2]
				aDsrAux[nPos,3] := If( aTarefas[nCnt,06] < aDsrAux[nPos,03], aTarefas[nCnt,06], aDsrAux[nPos,03] )
				aDsrAux[nPos,4] := If( aTarefas[nCnt,19] > aDsrAux[nPos,04], aTarefas[nCnt,19], aDsrAux[nPos,04] )
			Else
				Aadd( aDsrAux , { aTarefas[nCnt,2], aTarefas[nCnt,5], aTarefas[nCnt,6], aTarefas[nCnt,19] } )
			EndIf
		Else
			nPos := Ascan( aDsrAux , { |X| X[2] == aTarefas[nCnt,5] .And. X[3] == aTarefas[nCnt,6] } )
			If nPos > 0
				aDsrAux[nPos,1] += aTarefas[nCnt,2]
			Else
				Aadd( aDsrAux , { aTarefas[nCnt,2], aTarefas[nCnt,5], aTarefas[nCnt,6] } )
			EndIf
		EndIf
	Next nCnt
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Calcula o DSR por Centro de Custo 							   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nCnt1 := 1 To Len(aDsrAux)
		If !(aDsrAux[nCnt1,2] $ cCcGerados)
			nValorDsr  := nNroTarefa := 0
			cCcGerados += aDsrAux[nCnt1,2]+"*"
			Aeval( aDsrAux, {|X| If( X[2]==aDsrAux[nCnt1,2], nValorDsr  += X[1], "") } )
			//-- Inicializacao para nao calcular
			nDiasTrab := 0
			nDiasDSR  := 0
			If ( SRA->RA_CATFUNC == "T" )
			    //-- Verifica a existencia dos identificadores de dias Trabalhados e de Descanso
			    //-- Para obter as informacoes
			    If ( aCodfol[989,1] # Space(3) .and. aCodfol[990,1] # Space(3))
					If (nPos :=  Ascan(aPd, { |X| X[1] = aCodfol[989,1] .And. X[3] = cSemana .And. X[9] # "D" .And. X[7] # "C"})) > 0
						nDiasTrab :=  aPd[nPos,4]
					EndIf
					If (nPos :=  Ascan(aPd, { |X| X[1] = aCodfol[990,1] .And. X[3] = cSemana .And. X[9] # "D" .And. X[7] # "C"})) > 0
						nDiasDSR :=  aPd[nPos,4]
					EndIf
				EndIf

				//-- Se nao existir dias trabalhados, considera os dias do periodo como trablahados
				If Empty(nDiasTrab)
					//-- Assume o pagamento de 1 dia de DSR para o periodo
					nDiasDSR	:= 1
					nDiasTrab 	:= ( DateDiffDay( aDsrAux[nCnt1,4], aDsrAux[nCnt1,3] ) + 1 )
					Aadd(  aDsrTarefa , { aCodfol[33,1] , Round( (nValorDsr / nDiasTrab) * nDiasDSR, 2 ) , nDiasDSR, aDsrAux[nCnt1,2] } )
				Else
					Aadd(  aDsrTarefa , { aCodfol[33,1] , Round( (nValorDsr / nDiasTrab) * nDiasDSR, 2 ) , nDiasDSR, aDsrAux[nCnt1,2] } )
				EndIf
			Else
				Aeval( aDsrAux, {|X| If( X[2]==aDsrAux[nCnt1,2], nNroTarefa ++     , "") } )
				Aadd(  aDsrTarefa , { aCodfol[33,1] , Round( nValorDsr / nNroTarefa, 2 ), nNroTarefa, aDsrAux[nCnt1,2] } )
			EndIf
		EndIf
	Next nCnt1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Grava o DSR em aPd ou no Movimento Mensal - SRC				   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cGrava # Nil .And. Len( aDsrTarefa ) > 0
		If cGrava = "S"
			AeVal( aDsrTarefa , { |X| FMatriz(X[1],X[2],X[3], ,X[4],"V",,,,,,,X[3]) } )
		EndIf
	EndIf
EndIf

Return Nil


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FMatriz  ³ Autor ³ Mauro                 ³ Data ³ 23.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao Para Adicionar Verbas na Matriz                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCod       =  Codigo da Verba                              ³±±
±±³          ³ nValor     =  Valor da Verba                               ³±±
±±³          ³ nHoras     =  Horas da Verba  --   Opcional                ³±±
±±³          ³ cSem       =  Semana da Verba --   Opcional                ³±±
±±³          ³ cCct       =  Centro de Custo --   Opcional                ³±±
±±³          ³ cTip1      =  Tipo da Verba   --   Horas Dias Valor        ³±±
±±³          ³ cTip2      =  Origem da Verba --   Opcional                ³±±
±±³          ³ nPar       =  Parcela da Verba--   Opcional                ³±±
±±³          ³ cDel       =  se Deletada "D" --   Opcional                ³±±
±±³          ³ cMes       =  Data de Pagto da Verba                       ³±±
±±³          ³ lAltera    =  Altera os conteudos mesmo que Verba ja exista³±±
±±³          ³               em aPD                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fMatriz(uParam1,uParam2,uParam3,uParam4,uParam5,uParam6,uParam7,uParam8,uParam9,uParam10,uParam11,uParam12,uParam13,uParam14,uParam15,uParam16, uParam17, uParam18, uParam19, uParam20, uParam21, uParam22, uParam23, uParam24, uParam25, uParam26, uParam27, uParam28, uParam29, uParam30)/*
Function fMatriz(cCod, nValor, nHoras, cSem, cCct, cTip1, cTip2, nPar, cDel, dMes, lAltera, cSeq, nQtdSem, cItCt, cClCt, cNumID, lEmpres, cIdCmpl, dDtaRef, lPropDia, nValInteg, lNewValor, cConvoc, lIncorp, cLotPLS, cCodRda, cFilMat, cCodBenOP, cIN2110, cTribuIR)*/

Local lItemClVl := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"
Local cCod		:= uParam1
Local nValor	:= uParam2
Local nHoras 	:= If(uParam3 = Nil , 0.00 , uParam3)
Local cSem   	:= If(uParam4 = Nil , cSemana , uParam4)
Local cCct   	:= If(uParam5 = Nil , If (!lDissidio, Sra->Ra_cc, fDissCC()),uParam5)
Local cTip1  	:= If(uParam6 = Nil , RetValSrv(cCod,SRA->RA_FILIAL,"RV_TIPO ") , uParam6) //Fdesc("SRV",cCod,"RV_TIPO ",,xfilial("SRV",SRA->RA_FILIAL),1), uParam6)
Local cTip2  	:= If(uParam7 = Nil .Or. uParam7 = " ", "C" , uParam7)
Local nPar   	:= If(uParam8 = Nil , 0 , uParam8)
Local cDel   	:= If(uParam9 = Nil , " " , uParam9)
Local lAltera	:= If(uParam11 = Nil, .F. , uParam11)
Local cSeq 	    := If(uParam12 = Nil," ",uParam12)
Local nQtdSem   := If(uParam13 = Nil, 0, uParam13)
Local cIdCmpl	:= If(uParam18 == Nil,"",uParam18)
Local cItCt
Local cClCt
Local dMes
Local dDtaRef
Local lEmpres	:= If(uParam17 == Nil, .F., uParam17)
Local lTemEmpC  := SRK->( FieldPos( "RK_EMPCONS" ) # 0 ) //Campo so existe no Brasil, mantido fieldpos
Local lPropDia	:= .F.
Local nValInteg := 0
Local nPosPdv	:= 0
Local nPosSB	:= 0
Local nBaseAux	:= 0
Local nOrdAux	:= 0
Local cCodCor	:= ""
Local nPosOrig	:= 0
Local cConvoc	:= ""
Local lIncorp
Local lIntSem	:= .F.
Local lLctoDia  := RetValSrv(cCod,SRA->RA_FILIAL,"RV_LCTODIA") == 'S'
Local cLotPLS
Local cCodRda
Local cCodBenOP	:= ""
Local cIN2110	:= ""
Local cTribuIR	:= ""

// Var. Complemento da 2a. parcela em Folha
Local nP132Inf	:= 0
Local lPdCmp132	:= cTipoRot == "6" .and. lCalcFol .and. Type("aPdFol") # "U"

DEFAULT uParam14 := If(lItemClVl,SRA->RA_ITEM,'')
DEFAULT uParam15 := If(lItemClVl,SRA->RA_CLVL,'')
DEFAULT uParam10 := CtoD("//")
DEFAULT uParam16 := ""
DEFAULT uParam19 := CtoD("//")
DEFAULT uParam20 := .F.
DEFAULT uParam21 := 0
DEFAULT uParam22 := .F.
DEFAULT uParam23 := GetConvocCalc()
DEFAULT uParam24 := RetValSRV(cCod, SRA->RA_FILIAL, "RV_INCORP") == "S"
DEFAULT uParam25 := ""
DEFAULT uParam26 := ""
DEFAULT uParam27 := SRA->RA_FILIAL + SRA->RA_MAT
DEFAULT uParam28 := GetBenOP()
DEFAULT uParam29 := ""
DEFAULT uParam30 := ""

cItCt 	  := uParam14
cClCt 	  := uParam15
dMes 	  := uParam10
cNumID	  := uParam16
dDtaRef   := If (!Empty(uParam19), uParam19, If(DDATAATE = Nil , CtoD("//"), DDATAATE))
lPropDia  := uParam20
nValInteg := uParam21
cTip1	  := If(Empty(cTip1),"V",cTip1)
lNewValor := uParam22
cConvoc	  := uParam23
lIncorp   := uParam24
cLotPLS	  := uParam25
cCodRda	  := uParam26
cFilMat   := uParam27
cCodBenOP := uParam28
cIN2110   := uParam29
cTribuIR  := uParam30

If !(cPaisLoc == "BRA") .and. FindFunction("fXMatriz")
	fXMatriz(uParam1,uParam2,uParam3,uParam4,uParam5,uParam6,uParam7,uParam8,uParam9,uParam10,uParam11,uParam12,uParam13,uParam14,uParam15,uParam16)
	Return
EndIf

// Não grava Valor ou Hora negativa e nao grava Valor e hora simultaneamente nulos.
// A gravacao de informacao negativa sera PERMITIDA SE for proveniente de RESCISAO (cTip2 igual a I ou R)
If cCod # Nil .And. cCod # "   " .And. nValor # Nil .And. ;
	( nValor >= 0.00 .or. ( nValor < 0.00 .and. cTip2 $ ("IR") )) .and. ;
	( nHoras >= 0.00 .or. ( nHoras < 0.00 .and. cTip2 $ ("IR") )) .and.;
    ( !(Empty(nValor) .and. Empty(nHoras) ) .or. (cTipoRot == "4" .and. cCompl == "S") )

	//--Verifica se a verba existe no cadastro de verbas e
	//--Carrega na Matriz de Incidencias as Verbas
	If FIncide(cCod)

		nPos 	:= Ascan(aPd, { |X| X[1] == cCod .And. X[3] = cSem .And. X[2] = cCct .And. x[11]= cSeq .and. x[13] = cItCt .and. x[14] = cClCt .and. (x[15] = cNumID .Or. x[7] == "I") .and. ( !(x[7] $ "I*G*E") .or. !lLctoDia .or. x[18] == dDtaRef ) } )
		lIntSem := (cTipoRot == "1" .And. SRA->RA_TPCONTR == "3" .And. SRA->RA_TIPOPGT == "S" .And. cSem < cSemana)

		// Tratamento para recalcular as verbas de 13º na apuração de sua diferença em folha,
		// para os casos em que as verbas de 13o. foram informadas (origem "I") no roteiro '132'
		// e não foram informadas no roteiro 'FOL'
		If lPdCmp132
			nP132Inf := Ascan(aPdFol, { |X| X[1] == cCod .And. X[3] = cSem .And. X[2] = cCct .And. x[11]= cSeq .and. x[13] = cItCt .and. x[14] = cClCt .and. (x[15] = cNumID .Or. x[7] == "I") } )
		EndIf

		If nPos = 0 .Or. lIntSem

			nValInteg 	:= If(nValInteg == 0,nValor,nValInteg)
			nPosPdv 	:=  Ascan(aPdv, { |X| X[1] = cCod } )
			If Len(aPdv) > 0 .And. nPosPdv > 0 .And. aPdv[nPosPdv][18] == "S" .And. !( ( IsInCallStack("GPEM070") .or. IsInCallStack("GPM070GRD") ) .And. cTip2 $ "I/G" .And. ( (aPdv[nPosPdv, 37] $ "0036/1281/" .And. SRA->RA_PERICUL == 0) .Or. (aPdv[nPosPdv, 37] $ "0037/0038/0039/1282/" .And. SRA->RA_INSMAX == 0) ) .And. (aPdv[nPosPdv, 7 ] != "N " .Or. aPdv[nPosPdv, 7 ] != "N ") )//Não efetua incorporação na Provisão caso seja periculosidade/insalubridade, funcionário não tem o adicional configurado no cadastro, a verba foi incluída/gerada manualmente e possui configuração para médias
				// Não incorpora novamente se for uma verba de origem FERIAS
				If !(cTipoRot <> "3" .And. cTip2 $ "K*F") .And. lIncorp .And. !IsInCallStack("S_CMEDFER") .And. !IsInCallStack("fEncarCc") .And. !IsInCallStack("S_GRADIFER") .And. !IsInCallStack("S_GRVADI13");
					.And. !(Len(aCodFol) > 0 .And. aPdv[nPosPdv][1] $ (aCodFol[1296,1]+"/"+aCodFol[1297,1]+"/"+aCodFol[1298,1]+"/"+aCodFol[1299,1]) .And. aPdv[nPosPdv][18] == 'S');// Não incorporar novamente pela rotina de buscar médias, pois o SalHora já está incorporado.
					.And. (SRA->RA_TPCONTR != "3" .Or. cSem == cSemana)//não incorporar verba de semana anterior de intermitente
					//Se tiver dias trabalhados, pula o processamento abaixo nas fórmulas de gravação dos adicionais sobre maternidade porque a geração do adicional sobre o salário já incorpora o valor total
					If !( cTipoRot == "1" .And. DiasTrab > 0 .And. (IsInCallStack("S_GCONFMAT") .Or. IsInCallStack("S_GTRANMAT") .Or. IsInCallStack("S_GPERIMAT") .Or. IsInCallStack("S_GINSMAT")) )
						//Verifica se a verba é de desconto, se for deverá ser abatido o valor e não somado
						If aPdv[nPosPdv][27] == "2"
							IncorpSal(nValor,,.T.)
						Else
							IncorpSal(nValor,Nil,Nil,nPosPdv)
						EndIf
					EndIf
				EndIf
			EndIf

			If lPropDia .And. If(SRA->RA_TIPOPGT == "S" .And. SRA->RA_CATFUNC == "S", DiasTrab + DiasDSR + nDiasPg - nDiasMat <> nDiasC , DiasTrab + nDiasPg - nDiasMat - nDPrgSalMa <> nDiasC )
				fPropor(@nValor,@nHoras,cTip1,nValInteg,nDiasC,cCod)
				//Dias proporcionais Periculosidade
				If SRA->RA_TPCONTR == "3" .And. cTipoRot == "4" .And. aPdv[nPosPdv][1] == aCodFol[36,1] .And. !Empty(aConvocacao[5])
					nHoras := aConvocacao[5]
				EndIf
			EndIf

			nOrdGrPd++ //Mnemonico incrementado a cada novo item incluido no aPd

			If ( nPosSB := aScan(aSalBase, { |X| cCod $ X[1] } ) ) == 0
				If IsInCallStack( "fCarMvto" ) .Or. IsInCallStack( "S_GRVSAL" )
					nBaseAux := Salario
				Else
					nBaseAux := If(Type("SalMes") == "N",SalMes,nValor)
				EndIf
				nOrdAux  := nOrdGrPd
			Else
				nBaseAux := aSalBase[nPosSB,2]
				nOrdAux  := aSalBase[nPosSB,3]
				nOrdGrPd--
			EndIf

			Aadd( aPd, { cCod, cCct, cSem, nHoras, Round(nValor, 2), cTip1, cTip2, nPar, cDel, dMes, cSeq, nQtdSem, cItCt, cClCt, cNumID, lEmpres, cIdCmpl, dDtaRef, nValInteg, nBaseAux, AllTrim(STR(nOrdAux)), cConvoc, cLotPLS, cCodRDA, cFilMat, cCodBenOP, cIN2110, cTribuIR } )

		ElseIf	(nPos # 0 .And. cDel # "D" .And. ( aPd[nPos,9] = "D" .OR. lAltera = .T. ) .And. aPd[nPos,7] # "I") .Or. aPd[nPos,9] == "D" .Or.;
				(lPdCmp132 .And. nP132Inf == 0 .And. cDel # "D")

			nValInteg 	:= If(nValInteg == 0,nValor,nValInteg)
			nPosPdv 	:=  Ascan(aPdv, { |X| X[1] = cCod } )
			If Len(aPdv) > 0 .and. nPosPdv > 0 .and. aPdv[nPosPdv][18] == "S"
				// Não incorpora novamente se for uma verba de origem FERIAS
				If !(cTipoRot <> "3" .And. cTip2 == "K") .And. !( !Empty(aPdv[nPosPdv][37]) .And. cTip2 == "I" ) .And. lIncorp .and. !IsInCallStack("fEncarCc") //Não incorpora se estiver rateando pois a verba já foi incorporada no inicio do processo.
					IncorpSal(aPd[nPos,5],nValor)
				EndIf
			EndIf

			If lPropDia .AND. DiasTrab > 0 .AND. DiasTrab + nDiasPG <> nDiasC
				fPropor(@nValor,@nHoras,cTip1,nValInteg,nDiasC)
			EndIf

			aPd[nPos,5]  := Round(nValor,2)
			aPd[nPos,4]  := nHoras
			aPd[Npos,9]  := cDel
			aPd[Npos,10] := dMes
			aPd[nPos,6]  := cTip1
			aPd[nPos,7]	 := cTip2
			aPd[nPos,12] := nQtdSem
			aPd[nPos,19] := nValInteg
			//-- Tratamento para desconto do emprestimo consignado
			If (lTemEmpC , aPd[nPos,16] := lEmpres , )

			// Atualiza Valor Base
			nPosSB := aScan(aSalBase, { |X| cCod $ X[1] } )
			If nPosSB > 0
				If aPd[nPos,20] <> aSalBase[nPosSB,2]
					aPd[nPos,20] := aSalBase[nPosSB,2]
					aPd[nPos,21] := AllTrim(STR(aSalBase[nPosSB,3]))
				EndIf
			EndIf
			If Len(aPd[nPos]) >= 25
				aPd[nPos,25] := cFilMat
			EndIf
			If Len(aPd[nPos]) >= 28
				aPd[nPos,28] := cTribuIR
			EndIf
		ElseIf lNewValor
			nValor := aPd[nPos,5]
		EndIf
	EndIf

	cCodCor := RetValSrv(cCod,SRA->RA_FILIAL, "RV_CODCORR" )
	If (ISINCALLSTACK("S_CADIFFER") .Or. ISINCALLSTACK("S_INSSFOL") .Or. ISINCALLSTACK("S_CALAFAS") ) .And. !Empty(cCodCor) .And. FIncide(cCodCor) .And. cTipoRot $ "1*4"

		nPos := Ascan(aPd, { |X| X[1] == cCodCor .And. X[3] = cSem .And. X[2] = cCct .And. x[11]= cSeq .and. x[13] = cItCt .and. x[14] = cClCt .and. (x[15] = cNumID .Or. x[7] == "I") } )
		nPosOrig := Ascan(aPd, { |X| X[1] == cCod .And. X[3] = cSem .And. X[2] = cCct .And. x[11]= cSeq .and. x[13] = cItCt .and. x[14] = cClCt .and. (x[15] = cNumID .Or. x[7] == "I") } )

		If nPos = 0
			aAdd( aPd, aClone(aPd[nPosOrig]) )
			aPd[Len(aPd)][1] := cCodCor
		ElseIf (nPos # 0 .And. cDel # "D" .And. ( aPd[nPos,9] = "D" .OR. lAltera = .T. ) .And. aPd[nPos,7] # "I") .Or. aPd[nPos,9] == "D"

			aPd[nPos,5]  := aPd[nPosOrig,5]
			aPd[nPos,4]  := aPd[nPosOrig,4]
			aPd[Npos,9]  := aPd[nPosOrig,9]
			aPd[Npos,10] := aPd[nPosOrig,10]
			aPd[nPos,6]  := aPd[nPosOrig,6]
			aPd[nPos,7]	 := aPd[nPosOrig,7]
			aPd[nPos,12] := aPd[nPosOrig,12]
			aPd[nPos,19] := aPd[nPosOrig,19]
			//-- Tratamento para desconto do emprestimo consignado
			If (lTemEmpC , aPd[nPos,16] := aPd[nPosOrig,16] , )
		ElseIf lNewValor
			nValor := aPd[nPosOrig,5]
		EndIf
	EndIf
EndIf

Return nValor

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FIncide  ³ Autor ³ Mauro                 ³ Data ³ 23.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Inclui a Verba que foi adicionada na matriz de verba na    ³±±
±±³          ³ Matriz de Incidencia                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCod       =  Codigo da Verba                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FIncide(cCod)
Local nPos 		:= 0
Local lRet 		:= .T.
Local cMainTmp	:= "SRV"
Local aArea

Static lCodDsr  := SRV->( ColumnPos("RV_CODDSR") ) > 0
Static lBsCCivi := SRV->( ColumnPos("RV_BSCCIVI") ) > 0
Static lBasCal  := SRV->( ColumnPos("RV_BASCAL") ) > 0
Static lTCMARG  := SRV->( ColumnPos("RV_TCMARG") ) > 0

nPos := ASCAN(aPdv, { |Y| Y[1]=cCod })

If nPos = 0

	aArea		:= GetArea()

	(cMainTmp)->(DbSetOrder(1))

	lTemPd := (cMainTmp)->(MsSeek(xFilial("SRV",SRA->RA_FILIAL) + cCod))//PosSrv(cCod,SRA->RA_FILIAL)

	If lTemPd

		Aadd(aPdv,{cCod,;																//  1-Codigo
		If ((cMainTmp)->RV_PERC > 0,(cMainTmp)->RV_PERC,100),;                          //  2-Percentual da Verba
								         		(cMainTmp)->RV_CODCORR,;				//  3-Codigo Correspondente
		If (Empty((cMainTmp)->RV_INSS)	    ,"N",(cMainTmp)->RV_INSS)   ,;  			//  4-Incidencia Base INSS
		If (Empty((cMainTmp)->RV_IR)  	    ,"N",(cMainTmp)->RV_IR)     ,;  			//  5-Incidencia Base IR
		If (Empty((cMainTmp)->RV_FGTS)	    ,"N",(cMainTmp)->RV_FGTS)   ,;  			//  6-Incidencia Base FGTS
		If (Empty((cMainTmp)->RV_MED13)		,"N",(cMainTmp)->RV_MED13)  ,;  			//  7-Incidencia Media 13o
		If (Empty((cMainTmp)->RV_MEDFER) 	,"N",(cMainTmp)->RV_MEDFER) ,;  			//  8-Incidencia Media Ferias
		If (Empty((cMainTmp)->RV_PERICUL) 	,"N",(cMainTmp)->RV_PERICUL) ,;  			//  9-Incidencia Base Periculosidade
		If (Empty((cMainTmp)->RV_INSALUB) 	,"N",(cMainTmp)->RV_INSALUB) ,;  			// 10-Incidencia Base Insalubridade
		If (Empty((cMainTmp)->RV_REFFER)  	,"N",(cMainTmp)->RV_REFFER)  ,;  			// 11-Se Refere a Ferias
		If (Empty((cMainTmp)->RV_REF13)  	,"N",(cMainTmp)->RV_REF13)  ,;  			// 12-Se Refere a 13o Salario
		If (Empty((cMainTmp)->RV_ADIANTA) 	,"N",(cMainTmp)->RV_ADIANTA) ,;  			// 13-Se Refere a Adiantamento
		If (Empty((cMainTmp)->RV_RAIS)  	,"N",(cMainTmp)->RV_RAIS)   ,;  			// 14-Incidencia para RAIS
		If (Empty((cMainTmp)->RV_DIRF)  	,"N",(cMainTmp)->RV_DIRF) 	 ,;  			// 15-Incidencia para DIRF
		If (Empty((cMainTmp)->RV_DSRHE) 	,"N",(cMainTmp)->RV_DSRHE)  ,;  			// 16-Incidencia para DSR S/ Horas
		If (Empty((cMainTmp)->RV_HE)  	    ,"N",(cMainTmp)->RV_HE)     ,;  			// 17-Se e Verba de Hora Extras
		If (Empty((cMainTmp)->RV_INCORP)  	,"N",(cMainTmp)->RV_INCORP)  ,;  			// 18-Se a Verba Incorpora Salario
		If (Empty((cMainTmp)->RV_ADICTS)  	,"N",(cMainTmp)->RV_ADICTS)  ,;  			// 19-Verba Adic. Tempo Servico
		If (Empty((cMainTmp)->RV_SINDICA) 	,"N",(cMainTmp)->RV_SINDICA) ,;  			// 20-Incidencia Base Contrib. Sindical
		If (Empty((cMainTmp)->RV_SALFAMI) 	,"N",(cMainTmp)->RV_SALFAMI) ,;  			// 21-Incidencia Base Sal. Familia
		If (Empty((cMainTmp)->RV_SEGVIDA) 	,"N",(cMainTmp)->RV_SEGVIDA) ,;  			// 22-Incidencia Base Seguro Vida
		If (Empty((cMainTmp)->RV_MEDAVI)  	,"N",(cMainTmp)->RV_MEDAVI)  ,;  			// 23-Incidencia Media Aviso Previo
		If (Empty((cMainTmp)->RV_CONVCOL) 	,"N",(cMainTmp)->RV_CONVCOL) ,;  			// 24-Incidencia Base Convencao Coletiva
		If (Empty((cMainTmp)->RV_DEDINSS) 	,"N",(cMainTmp)->RV_DEDINSS) ,;  			// 25-Verba Deduz da Guia INSS
		If (Empty((cMainTmp)->RV_MEDREAJ) 	,"N",(cMainTmp)->RV_MEDREAJ) ,;  			// 26-Se e Media Reajustavel
		If (Empty((cMainTmp)->RV_TIPOCOD) 	,"3",(cMainTmp)->RV_TIPOCOD) ,;  			// 27-Tipo do Codigo 1=Prov.,2=Desc.,3=Base
		If (Empty((cMainTmp)->RV_PENSAO)	,"N",(cMainTmp)->RV_PENSAO) ,;  			// 28-Incidencia para Pensao Alimenticia
		If (Empty((cMainTmp)->RV_DSRPROF)	,"N",(cMainTmp)->RV_DSRPROF),; 				// 29-Incidencia para DSR Professores
		If (Empty((cMainTmp)->RV_HRSATIV)	,"N",(cMainTmp)->RV_HRSATIV),; 				// 30-Incidencia para Horas Atividade Professores
		If (Len(AllTrim((cMainTmp)->RV_TAREFA))#3,"   ",(cMainTmp)->RV_TAREFA),;		// 31-Codigo da Tarefa
		If (lCodDsr .and. Len(AllTrim((cMainTmp)->RV_CODDSR)) == 3,(cMainTmp)->RV_CODDSR, "   "),; 			// 32-Codigo DSR
		If (!lBsCCivi .OR. Empty((cMainTmp)->RV_BSCCIVI),"2",(cMainTmp)->RV_BSCCIVI),; 	// 33-Incidencia Base Construção civil
		If (!lBasCal .OR. Empty((cMainTmp)->RV_BASCAL),"1",(cMainTmp)->RV_BASCAL),;   	// 34-Base para calculo (Salario Base ou Salario Incorporado)
		If (Empty((cMainTmp)->RV_INSSFER)	,"2",(cMainTmp)->RV_INSSFER),; 				// 35-Se incide INSS nas ferias
		If (Empty((cMainTmp)->RV_CODMSEG)	,"2","1" ),; 								// 36-Se eh verba de mes seguinte, toda verba de mes seguinte deve ter a sua equivalente definidia no RV_CODMSEG
		If (Empty((cMainTmp)->RV_CODFOL)	,"",(cMainTmp)->RV_CODFOL ),;				// 37-CODFOL
		If (!lTCMARG .OR. Empty((cMainTmp)->RV_TCMARG), "2", (cMainTmp)->RV_TCMARG)}) 	// 38-Se verba será considerada no cálculo da margem consignável do funcionário. Valores: 1=sim, 2=não. Projeto TOTVS Consignado
	Else
		lRet := .F.
	EndIf

	RestArea( aArea )

EndIf

Return(lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ SomaInc  ³ Autor ³ Mauro                 ³ Data ³ 23.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Soma  das Verbas da Matriz com Incidencia para o Codigo    ³±±
±±³          ³ da Matriz de Incidencia                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aPd        =  Codigo da Verba                              ³±±
±±³          ³ nElem      =  Elemento da Matriz de Incidencia a ser Somado³±±
±±³          ³ nBas       =  Variavel a Ser Somado Passar com Ref.        ³±±
±±³          ³ nCond1     =  Condicao 1 para Soma   Opcional        Opc.  ³±±
±±³          ³ nPar1      =  Paramentro de Comparacao da Condicao 1 Opc.  ³±±
±±³          ³ nCond2     =  Condicao 2 para Soma                   Opc.  ³±±
±±³          ³ nPar2      =  Paramentro de Comparacao cond. 2       Opc.  ³±±
±±³          ³ nMes       =  Caso deseje somar det. Mes                   ³±±
±±³          ³ lSemana    =  .T. soma todas as semanas                    ³±±
±±³          ³               .F. soma somente a semana do c lculo         ³±±
±±³          ³ aCodFol    =  Array das Verbas                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function SomaInc(aPd, nElem, nBas, nCond1, cPar1, nCond2, cPar2, nMes, lSemana, aCodFol, SalHora, nHorInc, lChkMes, nPosHora, nPosVal, lCarInc, lPensao)

Local nValor 	:= nValorP := nValorD := nHoras := nValAux := 0.00
Local lTemEmpC  := SRK->( FieldPos( "RK_EMPCONS" ) # 0 )
Local cFaltas	:= aCodfol[54,1]+"/"+aCodfol[242,1]+"/"+aCodfol[244,1]+"/"+aCodfol[55,1]+"/"+aCodfol[243,1]+"/"+aCodfol[245,1]

DEFAULT lChkMes	 := .T.
DEFAULT lCarInc	 := .F.
DEFAULT nPosHora := 4
DEFAULT nPosVal	 := 5
DEFAULT lPensao	 := .F.

DEFAULT __lMemCalc 	:= (cPaisLoc == "BRA" .And. fMemCalc())

If SalHora = Nil
    Salhora := 0
EndIf
If nBas = Nil
   nBas = 0
EndIf
If nHorInc = nil
   nHorInc = 0
EndIf

// Quando verba for Deletada ou quando for emprestimo consignado nao Soma
If ( aPd[9] = "D" .Or. ( lTemEmpC .And. aPd[16] == .T. ) )
	Return
EndIf

lSemana := If( lSemana = Nil,.T.,lSemana )

//--Quando nao for semanalista  nao somar semana diferente da selecionada.
If !lSemana
	If !Empty( aPd[3] ) .And. aPd[3] # cSemana
	  Return
	EndIf
Else  //--Quando for para somar tudo nao somar semana superior ao calculo.
	If aPd[3] > cSemana
	  Return
	EndIf
EndIf

nPos := Ascan(aPdv, { |Y| Y[1] = aPd[1] })

If nPos == 0 .and. lCarInc //Se não encontrou as incidências da verba e é contrato intermitente, busca as incidências.
	fIncide(aPd[1])
	nPos := Ascan(aPdv, { |Y| Y[1] = aPd[1] })
EndIf

If (nPos > 0 .And. nElem > 2 .And. aPdv[nPos,nElem] $ "1S" ) .Or. ;
	(nPos > 0 .And. (nElem = 0 .Or. nElem = 1 .Or. nElem = 2))

	nValAux := aPd[nPosHora]

	If nValAux == 0 .and. nPosHora <> 4 //Tratamento para o caso de existir customizacoes que alimentam o aPD sme informar o novo campo
		nValAux := aPd[4]
	EndIf

    // Somar para  Peric. e Insal. o valor das horas sem acrescimo da verba
    If (nElem = 9 .And. GetMvRH("MV_PERICVH") = 'H' .And. nValAux > 0.00 .And. aPd[6] = 'H' .And. ( aCodFol[35,1] == aPd[1] .or. aPdv[nPos,17] = 'S' .Or. aPd[1] $ cFaltas .Or. aPdv[nPos,9] == 'S')) .Or.;
       (nElem= 10 .And. GetMvRH("MV_INSALVH") = 'H' .And. nValAux > 0.00 .And. aPd[6] = 'H' .And. ( aCodFol[35,1] == aPd[1] .or. aPdv[nPos,17] = 'S' .Or. aPd[1] $ cFaltas .Or. aPdv[nPos,10] == 'S'))
		If lValHorAdic
			nValAux := aPd[4] * If( aPdv[nPos,2] > 0, aPdv[nPos,2] / 100, 1 )
		Else
			nValAux := aPd[4]
		EndIf
       //-- Provento
       If aPdv[nPos,27] == '1'
           nValor := nValAux * Salhora
		//--Desconto
       ElseIf aPdv[nPos,27]=='2'
           nValor := (nValAux * Salhora) * (-1)
       EndIf
       nHoras := If (aPd[6] = 'H',nValAux,0)   // Horas da Verba
    //--Provento
    ElseIf aPdv[nPos,27] == '1' .or. ( (aPd[1] == AcodFol[007,1] ) .and. cTipoRot=="2" .and. (Type("lUtiMultiV")<> "U" .and. lUtiMultiV ) ) .Or. (cTipoRot == "1" .And. nElem == 5 .And. aPd[1] == aCodFol[1660,1])
		nValor  := aPd[nPosVal]
		nValorP := aPd[nPosVal]
        nHoras := If (aPd[6] = 'H',nValAux,0)   // Horas da Verba
    //--Desconto
    ElseIf aPdv[nPos,27] == '2'
		nValor  := aPd[nPosVal] * (-1)
		nValorD := aPd[nPosVal]
        nHoras := If (aPd[6] = 'H',nValAux * (-1),0)   // Horas da Verba
	//--Codigos de Deducao Inss p/Base de Ir
    ElseIf ( aPd[1] = aCodFol[167,1] .Or. aPd[1] = aCodFol[168,1] .Or. aPd[1] = aCodFol[169,1] .Or. aPd[1] = aCodFol[0624,1] ) .And. ( nElem # 0 )
		nValor  := aPd[nPosVal] * (-1)
	//--Codigos de Deducao Inss p/Base de Ir validos somente em 2004
    ElseIf ( aPd[1] = aCodFol[408,1] .Or. aPd[1] = aCodFol[409,1] .Or. aPd[1] = aCodFol[410,1] ) .And. ( nElem # 0 )
		nValor  := aPd[nPosVal] * (-1)
	Else
		nValor := nValorP := nValorD := 0.00
    EndIf

	// Verifica se Mes deve ser Igual ao do Lancamento e sempre considera adiantamento
	If aPd[10] # Nil .And. ! Empty( aPd[10] ) .And. lChkMes
		If nMes # Nil .And. nMes # MONTH(aPd[10]) .And. aPd[1] # AcodFol[007,1]
			nValor := 0.00
		EndIf
	EndIf

	// Soma Todos Elementos da Matriz Ex.:0 = Liquido, 1 - So Provento , 2 - Desconto
	If nElem = 0  .Or. nElem = 1 .Or. nElem = 2
		If nElem = 0
			nBas += Round(nValor,2)
		ElseIf nElem = 1
			nBas += Round(nValorP,2)
		ElseIf nElem = 2
			nBas += Round(nValorD,2)
		EndIf
		Return
	EndIf

    // Verifica se Atende as Condicoes
    If nCond1 == NIl .And. nCond2 == NIl .or. nCond1 == 0 .and. nCond2 == 0
      	nBas     += nValor
       	nHorInc  += nHoras
		If __lMemCalc .And. lPensao .And. !Empty(nValor)
			fAddMemLog("Verba: " + aPd[1] + " - " + AllTrim( RetValSRV(aPd[1], SRA->RA_FILIAL, "RV_DESC")) + " = R$ " + AllTrim(Transform( nValor, "@E 999,999,999,999.99" )), 1, 4)
		EndIf
    ElseIf nCond1 # Nil .And. nCond1 # 0 .And. aPdv[nPos,nCond1] == cPar1 .And. nCond2 == Nil
        nBas     += nValor
        nHorInc  += nHoras
		If __lMemCalc .And. lPensao .And. !Empty(nValor)
			fAddMemLog("Verba: " + aPd[1] + " - " + AllTrim( RetValSRV(aPd[1], SRA->RA_FILIAL, "RV_DESC")) + " = R$ " + AllTrim(Transform( nValor, "@E 999,999,999,999.99" )), 1, 4)
		EndIf
	ElseIf nCond1 # Nil .And. nCond2 # Nil .And. nCond1 # 0 .And. nCond2 # 0
		If aPdv[nPos,nCond1] = cPar1  .And. aPdv[nPos,nCond2] = cPar2
            nBas    += nValor
            nHorInc += nHoras
			If __lMemCalc .And. lPensao .And. !Empty(nValor)
				fAddMemLog("Verba: " + aPd[1] + " - " + AllTrim( RetValSRV(aPd[1], SRA->RA_FILIAL, "RV_DESC" ) ) + " = R$ " + AllTrim(Transform( nValor, "@E 999,999,999,999.99" )), 1, 4)
			EndIf
        EndIf
    EndIf	
EndIf

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CalDsrHex ³ Autor ³ Equipe RH             ³ Data ³28/03/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo de Dsr Sobre Horas Extras                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CalDsrHex (aCodfol,nValDsr,nHorDsr,cFlag)                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aCodfol  =  Matriz com referencias das Verbas.             ³±±
±±³          ³ nValDsr  =  Valor do Calculo Passar Como Referencias.      ³±±
±±³          ³ nHorDsr  =  N§ de Horas Passar Como Referencia             ³±±
±±³          ³ cGrava   =  Ve se Grava na Propria Funcao                  ³±±
±±³          ³ cFlag    =  Controla Flag da Rescisao                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function CalDsrHex(aCodfol,nValDsr,nHorDsr,cGrava,cFlag,nHrsTrab,nHrsDesc,nOpcao)
Local nValDsrn 	:= nValDsrc := nValDsrO := 0
Local nHorDsrn 	:= nHorDsrc := nHorDsrO:= 0
Local Dsrhrex_O	:= 0
Local cCodSep 	:= ""
Local cBkpPer	:= ""
Local cCodDsr	:= ""
Local cSeqAux 	:= " "
Local dBkpDe	:= cToD("//")
Local aBaseDsr	:= {}
Local aAuxDSR 	:= {}
Local lIncODSR	:= GetMvRH( "MV_INCODSR",, .F. )
Local lProAux	:= lPropDia
Local nx		:= 0
Local ny        := 0
Local nPosPd	:= 0
Local cTipv		:= "H"

Local nDSRDTrab := 0
Local nDSRDNTrab:= 0
Local nDSRProp	:= 0
Local nSvHrsDesc:= Descanso
Local nSvHrsTrab:= Normal
Local nBkpHDesc	:= If( nHrsDesc==Nil, If(Descanso=0,1,Descanso), If(nHrsDesc=0,1,nHrsDesc) )
Local nBkpHTrab	:= If( nHrsTrab==Nil, If(Normal=0,1,Normal), If(nHrsTrab=0,1,nHrsTrab) )
Local lPDsrAdm	:= .F.
Local lPDsrDem	:= .F.
Local lPDsrAfa	:= .F.
Local lPDsrFer	:= .F.
Local lDSRCCMat	:= .T. // Valor default do mnemônico P_DSRCCMAT, representa padrão do sistema
Local lGrv		:= Nil
Local dDtIniPer	:= cTod("//")
Local dDtFimPer
Local nz 		:= 0
Local nPosExt 	:= 0
Local lDSRPon   := Type("P_LDSRHRSP") # "U" .AND. P_LDSRHRSP
Local oModel	:= {}
Local nCont		:= 0
Local nHrsDia	:= 0
Local nInfNorm	:= 0
Local nInfDesc	:= 0
Local NormalSV 	:= Normal
Local DescansoSV:= Descanso
Local lRotinc	:= GETROTEXEC() == "INC"
Local lSALHDSR	:= .F.
Local lCalcResc := IsInCallStack("GPEM040")
Local nBaseHor	:= 0

Local aPeriodo2 := {}
Local lUltSem2	:= .F.
Local nPosSem2	:= 0

Default nOpcao := 2

If cTipoRot == "1" .and. !lDissidio .and. cSitFolh == "D" //Se for folha e funcionário estiver demitido, não calcula DSR.
	Return Nil
EndIf

If lRotinc
	nOpcao := 2
EndIf

If Type("P_CPROPDSR") # "U"
	If "1" $ P_CPROPDSR
		lPDsrAdm := .T.
	Endif
	If "2" $ P_CPROPDSR
		lPDsrDem := .T.
	Endif
	If "3" $ P_CPROPDSR
		lPDsrAfa := .T.
	Endif
	If "4" $ P_CPROPDSR
		lPDsrFer := .T.
	Endif
Endif

If Type("P_DSRCCMAT") # "U"
	lDSRCCMat := P_DSRCCMAT  // .T. - Define pagamento do DSR centralizado no Centro de Custo da Matrícula
EndIf						// .F. - Define pagamento do DSR pelo Centro de Busco da verba Base

//Deve considerar o salrio e dsr horista informado na RGB para a base de calculo das demais verbas?
If cPaisLoc == "BRA"
	lSALHDSR := If( Type("P_SALHDSR") == "U", .F., P_SALHDSR)
EndIf

//Altera mnemonico para que nao seja proporcionalizado as verbas
 lPropDia := .F.

If lCalcResc .Or. IsBlind()
	If cCompl == "S"
		// Carrega período do mês da rescisão
		FCarPeriodo( AnoMes(dDataDem), cRot, @aPeriodo2, @lUltSem2, @nPosSem2)
		If Len(aPeriodo2) > 0 .And. nPosSem2 > 0
			Normal := aPeriodo2[nPosSem2, 24] * SRA->RA_HRSDIA
        	Descanso := aPeriodo2[nPosSem2, 07] * SRA->RA_HRSDIA
		EndIf	
	EndIf	
	If cCompl != "S" .Or. nPosSem2 == 0
		Descanso	:= If(M->RG_DESCANS == Nil, Descanso, M->RG_DESCANS)
		Normal		:= If(M->RG_NORMAL == Nil, Normal, M->RG_NORMAL)
	EndIf
EndIf

If nOpcao == 1
	If lDSRPon
		nHrsTrab := nTUteis
		nHrsDesc := nTNUteis
	Else
		nHrsTrab := Normal
		nHrsDesc := Descanso
	EndIf
ElseIf nOpcao == 2
	If lDSRPon
		nHrsTrab := nTUteis
		nHrsDesc := nTNUteis
	EndIf
	If (IsInCallStack("GPEM070") .or. IsInCallStack("GPM070GRD") .Or. IsInCallStack("GPER080")) .And. lRotinc
		Normal := NSVNORMAL
		Descanso := NSVDESCAN
    EndIf
	cFlag	:= If (cFlag == Nil," ",cFlag)
	If SRA->RA_TPCONTR == '3' .and. Normal == 0
		nHrsTrab:= If ( nHrsTrab == Nil , If (Normal=0,aConvocacao[7],Normal) , If (nHrsTrab=0,aConvocacao[7],nHrsTrab))
		nHrsDesc:= If ( nHrsDesc == Nil , If (Descanso=0,1,Descanso) , If (nHrsDesc=0,1,nHrsDesc))
	Else
		nHrsTrab:= If ( nHrsTrab == Nil , If (Normal=0,1,Normal) , If (nHrsTrab=0,1,nHrsTrab))
		nHrsDesc:= Iif( nHrsDesc == Nil, Iif(Descanso == 0 .And. ( !(cTipoRot $ "1/4") .Or. ( nPosSem == 0 .Or. (Len(aPeriodo) > 0 .And. aPeriodo[nPosSem, 7] > 0) ) ), 1, Descanso), Iif(nHrsDesc == 0, 1, nHrsDesc) )
	EndIf
	nHrTDsr := 0

	//--Verifica se existe identificadores de comissao folha e comissao rescisao
	//--se existir ira efetuar o calculo do DSR separado do DSR s/Variaveis
	If aCodFol[166,1] # Space(3)
		cCodSep := aCodFol[165,1]+"/"+aCodFol[347,1]+"/"
	Endif
	If aCodFol[122,1] # Space(3)
		cCodSep += aCodFol[121,1]
	Endif

	//--Calculo do DSR S/Variaveis
	If aCodfol[35,1] # SPACE(3)

		aAuxDSR := {}

		If lDSRCCMat // DSR centralizado pelo Centro de Custo da Matrícula

			Dsrhrex_B := 0.0
			If cFlag = "F"
		      Aeval(aPd,{ |X| If(! X[1] $ cCodSep, SomaInc(X, 16, @Dsrhrex_B, 11, "S", , , , .F., aCodFol,, @nHrTDsr), "")})
			Else
		      Aeval(aPd,{ |X| If(! X[1] $ cCodSep, SomaInc(X, 16, @Dsrhrex_B, 11, "N", , , , .F., aCodFol,, @nHrTDsr), "")})
			EndIf
			aAdd(aAuxDSR, { SRA->RA_CC, Dsrhrex_B, "" }) // Centro de Custo , Valor , Verba Base HE

		Else // DSR de acordo com o Centro de Custo da Verba de Base HE
			For nz := 1 to Len(aPd)
				If ! aPd[nz,1] $ cCodSep .And. RetValSRV(aPd[nz,1], SRA->RA_FILIAL, "RV_DSRHE" ) == "S" .And. ;
					 (RetValSRV(aPd[nz,1], SRA->RA_FILIAL, "RV_REFFER" ) == If(cFlag == "F", "S","N")) .And.;
					 aPd[nz,9] # "D" .And. ( cTipoRot != "N" .Or. aPd[nz, 3] == cSemana )
					nPosExt := aScan(aAuxDSR,{|x| x[1] == aPd[nz,2] .And. x[3] == aPd[nz,1] })
					If nPosExt > 0
						aAuxDSR[nPosExt][2] += aPd[nz][5]
					Else
						aAdd(aAuxDSR,{ aPd[nz,2], aPd[nz,5], aPd[nz,1] }) // Centro de Custo , Valor , Verba Base HE
					EndIf
				EndIf
			Next nz
		EndIf

		//DSR proporcional ao dias trabalhados na Admissao/Rescisao/Afastamento/Ferias

		If !lDSRPon .And. ( lPDsrAdm .OR. lPDsrDem .OR. lPDsrAfa .OR. lPDsrFer )

			nSvHrsDesc := nHrsDesc
			nSvHrsTrab := nHrsTrab

			If lCalcResc .And. cCompl == "S"
				cBkpPer		:= cPeriodo
				dBkpDe		:= dDataDe
				cPeriodo	:= AnoMes(dDataDem)
				dDataDe		:= cToD("01/" + SubStr( cPeriodo, 5, 2 ) + "/" + SubStr( cPeriodo, 1, 4 ))
			EndIf

			dDtIniPer := If( AnoMes(SRA->RA_ADMISSA) == CPERIODO .And. lPDsrAdm, SRA->RA_ADMISSA, DDATADE )
			dDtFimPer := If( !Empty(dDataDem) .And. lPDsrDem, dDataDem, DDATAATE )

		  	FTrabCalen(	 CPERIODO	,;		//01-- Periodo
	                     @nDSRDTrab	,;		//02-- Dias Trabalhados
	                     @nDSRDNTrab,;		//03-- Dias Nao Trabalhados
	                     @nDSRProp 	,;		//04-- Dias de DSR
	                     0		 	,;		//05-- Dias Nao Uteis de Vale Transporte
	                     0		   	,;		//06-- Dias uteis de Vale Transporte
	                     0 		  	,; 		//07-- Dias de Diferenca de Vale Transporte
	                     0		 	,;		//08-- Qtde de Horas de DSR
	                     @nHrsTrab	,;		//09-- Qtde de HoraS Trabalhadas
	                     0			,;		//10-- Dias de Vale Refeicao
	                     0		  	,;		//11-- Dias totais de V.T. Dias Uteis
	                     0		 	,;		//12-- Dias totais de V.T. Dias Nao uteis
	                     cSemana	,;		//13-- Numero de Pagamento
	                     lPDsrAfa	,;		//14-- Proporcional a Afastamento
	                     lPDsrAdm	,;		//15-- Proporcional a Admissao
	                     dDtFimPer	,;		//16-- Data Fim do Periodo
	                     CROT		,;		//17-- Roteiro
	                     dDtIniPer	,;		//18-- Data inicial para pesquisa (opcional)
	                     0			,;		//19-- Verbas de tipos de afastamentos (opcional)
						 0			,;		//20-- Dias de Vale Alimentacao
                     	 0			,;		//21-- Dias uteis
                     	 lPDsrFer	)		//22-- Considera as férias do array aafas


		 	nHrsDesc := ( SRA->RA_HRSDIA * nDSRProp)	//Dias DSR
		 	nHrsTrab := ( SRA->RA_HRSDIA * (nDSRDTrab + nDSRDNTrab))	//Dias Trabalhados+Dias Nao Trabalhados
			If lCalcResc .And. cCompl == "S"
				cPeriodo	:= cBkpPer
				dDataDe		:= dBkpDe
			EndIf

		ElseIf lDSRPon .And. !lPDsrAdm .And. !lPDsrDem .And. !lPDsrAfa .And. !lPDsrFer

			fHTrabCalen( DDATADE, DDATAATE )
			If lCalcResc .Or. IsBlind()
				Descanso := If(M->RG_DESCANS == Nil, Descanso, M->RG_DESCANS)
				Normal	 := If(M->RG_NORMAL == Nil, Normal, M->RG_NORMAL)
			Else
				Descanso := nSvHrsDesc
				Normal	 := nSvHrsTrab
			EndIf
			nHrsTrab := nTUteis
			nHrsDesc := nTNUteis

		 EndIf

		For nx := 1 to Len(aAuxDSR)
			nPosPd := Ascan(aPd,{ |X| X[1] == aCodfol[35,1] .And. x[3] == cSemana .And. X[9] # "D"})
			If aAuxDSR[nx][2] > 0
				If lDissidio
					lGrv := .T.
					nPDis := Ascan(aPdOld,{ |X| X[1] == aCodfol[35,1] .And. X[3] = cSemana})
					nValDsr := ( (aAuxDSR[nx][2] * nHrsDesc ) / nHrsTrab )
					nHorDsr := If( Salhora > 0, nValDsr / Salhora, 0 )
				ElseIf nPosPd > 0 .And. aPd[nPosPd,6] $ "H"
					If aPd[nPosPd,7] $ "I*G"
						nValDsr := ((aAuxDSR[nx][2] * aPd[nPosPd,4] ) / nHrsTrab )
						nHorDsr := aPd[nPosPd,4]
					Else
						nValDsr := ((aAuxDSR[nx][2] * nHrsDesc ) / nHrsTrab )
						nHorDsr := If( Salhora > 0 .And. Salario > 0 , nValDsr / Salhora , 0 )
					EndIf
				Elseif nPosPd  = 0
					nValDsr := ((aAuxDSR[nx][2] * nHrsDesc ) / nHrsTrab )
					nHorDsr := If( Salhora > 0 .And. Salario > 0 , nValDsr / Salhora , 0 )
				EndIf

				nValDsrO := nValDsr
				nHorDsrO := nHorDsr

				If cGrava # Nil .And. cGrava = "S" .And. nValDsr > 0
					// Inclusao do mesmo tratamento para gravacao da verba com ID 035, forcando a gravacao em HORAS
					If lDSRCCMat
						nPosExt	:= 0
						If lCalcResc .And. cCompl == "S"
							nPosExt	:= Ascan(aPd,{ |X| X[1] == aCodfol[35,1] .And. x[2] == aAuxDSR[nx][1] .And. x[3] == cSemana .And. X[9] # "D" .and. x[7] == "C" }) //Se já foi gravada nesse cálculo, regrava
						EndIf
						FMatriz(aCodfol[35,1],nValDsr,nHorDsr,,,"H",,,,,lGrv .Or. nPosExt>0,,,,,,,,,lPropDia)
					Else
						// Se a verba de Horas for Informada, gravar verba de DSR com Centro de Custo/Item Contábil/Classe de Valor
						// da Verba Informada
						nPosExt	:= Ascan(aPd,{ |X| X[1] == aCodfol[35,1] .And. x[2] == aAuxDSR[nx][1] .And. x[3] == cSemana .And. X[9] # "D"})
						If nPosExt > 0
							aPd[nPosExt][4] += nHorDsr
							aPd[nPosExt][5] += nValDsr
						Else
							FMatriz(aCodfol[35,1],nValDsr,nHorDsr,,aAuxDSR[nx][1],"H",,,,,lGrv)
						EndIf
					EndIf
				EndIf
			EndIf
		Next nx
	EndIf

	//--Calculo do Dsr S/Comissao Folha de Pagamento
	If aCodfol[166,1] # SPACE(3)
		Dsrhrex_C := 0.00
		Aeval(aPd,{ |X| If(X[1]$aCodFol[165,1]+'*'+aCodFol[347,1],SomaInc(X,16,@Dsrhrex_C, , , , , ,.F.,aCodFol),"")})
		nPos := Ascan(aPd,{ |X| X[1] = aCodfol[166,1] .And. X[3] = cSemana .And. X[9] # "D"})

		If nPos > 0 .And. aPd[nPos,6] $ "H"
			nValDsr := ((Dsrhrex_C * aPd[nPos,4] ) / nHrsTrab )
			nHorDsr := aPd[nPos,4]
		Elseif nPos  = 0
			nValDsr := ((Dsrhrex_C * nHrsDesc ) / nHrsTrab )
			nHorDsr := nHrsDesc
		EndIf
		nValDsrc := nValDsr
		nHorDsrc := nHorDsr

		// Verifica se grava na Matriz
		If cGrava # Nil .And. cGrava = "S" .And. nValDsr > 0
			If nPos > 0 .And. aPd[nPos, 7] == "I" .And. Ascan(aPd, { |X| X[1] = aCodfol[166,1] .And. X[10] == X[18] .And. X[7] == "I" }) > 0 //Se já existe verba de DSR incluída no aPd
				If ( nPos := Ascan(aPd, { |X| X[1] = aCodfol[166,1] .And. X[3] = cSemana .And. X[9] # "D" .And. X[7] == "C" .And. X[19] == nValDsr}) ) > 0
					cSeqAux := aPd[nPos,11]
				Else
					aEval(aPd, { |X| If( X[1] == aCodFol[166,1] .And. x[1] > cSeqAux, cSeqAux := X[11] , Nil ) })
					cSeqAux := Soma1(cSeqAux)
				EndIf
			EndIf
			FMatriz(aCodfol[166,1],nValDsr,nHorDsr,,,,,,,,,cSeqAux)
		EndIf
	EndIf

	If cGrava = Nil .And. cGrava # "S"
		nValDsr := nValDsrn + nValDsrc
		nHorDsr := nHorDsrn + nHorDsrc
	EndIf

	//--Calculo do DSR S/Comissies Rescisao
	IF aCodfol[122,1] # SPACE(3)
		Dsrhrex_C := 0.00
		Aeval(aPd,{ |X| If(X[1]$ aCodFol[121,1],SomaInc(X,16,@Dsrhrex_C, , , , , ,.F.,aCodFol),"")})

		nPos := Ascan(aPd,{ |X| X[1] = aCodfol[122,1] .And. X[3] = cSemana .And. X[9] # "D"})
		If nPos > 0 .And. aPd[nPos,6] $ "H"
			nValDsr := ((Dsrhrex_C * aPd[nPos,4] ) / nHrsTrab )
			nHorDsr := aPd[nPos,4]
		Elseif nPos  = 0
			nValDsr := ((Dsrhrex_C * nHrsDesc) / nHrsTrab )
			nHorDsr := nHrsDesc
		EndIf
		nValDsrC += nValDsr
		nHorDsrC += nHorDsr

		// Verifica se grava na Matriz
		If cGrava # Nil .And. cGrava = "S" .And. nValDsr > 0
			FMatriz(aCodfol[122,1],nValDsr,nHorDsr)
		EndIf
	Endif
EndIf

If ( ( nOpcao == 1 .And. lIncODSR .And. !lDissidio ) .Or. ( ( nOpcao == 2 .And. !lIncODSR ) .Or. lDissidio ) )
	//--Calculo dos outros DSR
	If !lHoJorVa .And. SRA->RA_CATFUNC == "H" .And. cTipoRot != "1" .And. lSALHDSR
		//Percorre o aPd em busca das verbas de salário horista (Id 0032) e DSR horista (Id 0033)
		For nCont := 1 To Len(aPd)
			If aPd[nCont,1] == aCodFol[032,1] .And. aPd[nCont,9] != "D" .And. AllTrim( aPd[nCont,3] ) == AllTrim( cSemana ) .And. aPd[nCont,7] == "I"
				nInfNorm	+= aPd[nCont,4]
			EndIf
			If aPd[nCont,1] == aCodFol[033,1] .And. aPd[nCont,9] != "D" .And. AllTrim( aPd[nCont,3] ) == AllTrim( cSemana ) .And. aPd[nCont,7] == "I"
				nInfDesc	+= aPd[nCont,4]
			EndIf
		Next nCont

		//Caso tenha informado a verba de salário horista, utiliza as horas informadas
		If nInfNorm > 0
			Normal := nInfNorm
			//Caso possua afastamento, divide as horas pelas dias trabalhados e multiplica pelos dias de cálculo para considerar as horas previstas no mês
			If nDiasAfas > 0
				Normal := (Normal / DiasTrab * nDiasC)
			EndIf

			nHrsDia := (Normal / aPeriodo[nPosSem,24] * aPeriodo[nPosSem,20] / nDiasC)
			//Caso tenha informado a verba de DSR horista, utiliza as horas informadas
			If nInfDesc > 0
				Descanso := nInfDesc
			Else
				Descanso := nHrsDia * aPeriodo[nPosSem,7]
			EndIf

			//Verifica a quantidade de horas trabalhadas por dia, de acordo com as horas informadas
			nHrsDia := (Normal + Descanso) / nDiasC

			//Retira a incorporação das variáveis de salário, pois foram consideradas as horas cadastrais
			Salario -= (SRA->RA_SALARIO * nHrsCal)
			SalMes 	-= (SRA->RA_SALARIO * nHrsCal)
			SalDor 	-= (SRA->RA_SALARIO * SRA->RA_HRSDIA)
			SalDia 	-= (SRA->RA_SALARIO * SRA->RA_HRSDIA)

			//Efetua a incorporação das variáveis de salário, com base nas horas trabalhadas
			nHrsCal := nHrsDia * nDiasC
			Salario	+= (SRA->RA_SALARIO * nHrsCal)
			SalMes 	+= (SRA->RA_SALARIO * nHrsCal)
			SalDor 	+= (SRA->RA_SALARIO * nHrsDia)
			SalDia 	+= (SRA->RA_SALARIO * nHrsDia)

			If Descanso > 0
				lGrv := IIf( lDissidio, .T., Nil ) //Forca a gravacao no calculo do dissidio
				nBaseHor := IIf( lDissidio, SalHor, SRA->RA_SALARIO )
				FMatriz(aCodFol[033,1],(nBaseHor * Descanso ),Descanso,,,"H",,,,,lGrv)
			EndIf
		EndIf
	EndIf

	For nx := 1 to Len(aPdv)

		cCodDsr	:= aPdv[nx,32] //Codigo informado para calculo do DSR (RV_CODDSR)

		If Empty(cCodDsr) .or. ( nInfNorm > 0 .and. cCodDsr == aCodFol[033,1] ) .or. (cFlag <> "F" .and. aPdv[nX,11] == "S") //Se DSR horista e horas foram informadas ou verba referente a férias no cálculo que não é de férias.
			Loop
		Endif

		nPos := Ascan( aBaseDsr, {|x| x[1] == cCodDsr } )
		If nPos = 0
			cTipV := RetValSRV( cCodDsr, SRA->RA_FILIAL, "RV_TIPO" )
			aadd (aBaseDsr, { cCodDsr, aPdv[nx, 1],cTipV } )    //Codigo DSR, Verba
		Else
			aBaseDsr[nPos, 2] += "/" + aPdv[nx, 1]
		EndIf
	Next nx

	For ny:= 1 to Len(aBaseDsr)

		aAuxDSR 	:= {}
		If cTipoRot != "3"
			Dsrhrex_O	:= 0
		EndIf

		If lDSRCCMat // DSR centralizado pelo Centro de Custo da Matrícula
			Aeval ( aPd, {|X| If( x[1] $ aBaseDsr[ ny, 2] .and. x[3] == cSemana .and. x[9] # "D", Dsrhrex_O += x[5], 0 ) } )
			aAdd(aAuxDSR,{ SRA->RA_CC ,Dsrhrex_O, "" }) // Centro de Custo , Valor , Verba Base HE
		Else // DSR de acordo com o Centro de Custo da Verba de Base HE
			For nz := 1 to Len(aPd)
				If aPd[nz,1] $ aBaseDsr[ ny, 2] .and. aPd[nz,3] == cSemana .and. aPd[nz,9] # "D"
					nPosExt := aScan(aAuxDSR,{|x| x[1] == aPd[nz,2] .And. x[3] == aPd[nz,1] })
					If nPosExt > 0
						aAuxDSR[nPosExt][2] += aPd[nz][5]
					Else
						aAdd(aAuxDSR,{ aPd[nz,2],aPd[nz,5], aPd[nz,1] }) // Centro de Custo , Valor , Verba Base
					EndIf
				EndIf
			Next nz
		EndIf

		For nx := 1 to Len(aAuxDSR)
			nPosPd := Ascan(aPd,{ |X| X[1] == aBaseDsr[ ny, 1] .And. x[3] == cSemana .And. X[9] # "D"})
			If aAuxDSR[nx][2] > 0
				If lDissidio
					nPDis := Ascan(aPdOld,{ |X| X[1] == aBaseDsr[ ny, 1] .And. X[3] = cSemana})
					nValDsr := ( (aAuxDSR[nx][2] * nHrsDesc ) / nHrsTrab )
					nHorDsr := If( Salhora > 0, nValDsr / Salhora, 0 )
				ElseIf nPosPd > 0 .And. aPd[nPosPd,6] $ "H"
					If aPd[nPosPd,7] $ "I*G"
						nValDsr := ((aAuxDSR[nx][2] * aPd[nPosPd,4] ) / nHrsTrab )
						nHorDsr := aPd[nPosPd,4]
					Else
						nValDsr := ((aAuxDSR[nx][2] * nHrsDesc ) / nHrsTrab )
						nHorDsr := If( Salhora > 0 .And. Salario > 0 , nValDsr / Salhora , 0 )
					EndIf
				Elseif nPosPd  = 0
					nValDsr := ((aAuxDSR[nx][2] * nHrsDesc ) / nHrsTrab )
					nHorDsr := If( Salhora > 0 .And. Salario > 0 , nValDsr / Salhora , 0 )
			   	EndIf

				nValDsrO := nValDsr
				nHorDsrO := nHorDsr

		 		If cGrava # Nil .And. cGrava = "S" .And. nValDsr > 0
					// Inclusao do mesmo tratamento para gravacao da verba com ID 035, forcando a gravacao em HORAS
					lGrv := If( lDissidio, .T., Nil ) //Forca a gravacao no calculo do dissidio
					If lDSRCCMat // DSR centralizado pelo Centro de Custo da Matrícula
						FMatriz(aBaseDsr[ny, 1],nValDsr,nHorDsr,,,aBaseDsr[ny, 3],,,,,lGrv)
						Dsrhrex_O := 0
					Else
						// Se a verba de Horas for Informada, gravar verba de DSR com Centro de Custo/Item Contábil/Classe de Valor
						// da Verba Informada
						nPosExt	:= Ascan(aPd,{ |X| X[1] == aBaseDsr[ny, 1] .And. x[2] == aAuxDSR[nx][1] .And. x[3] == cSemana .And. X[9] # "D"})
						If nPosExt > 0
							aPd[nPosExt][4] += nHorDsr
							aPd[nPosExt][5] += nValDsr
						Else
							FMatriz(aBaseDsr[ny, 1],nValDsr,nHorDsr,,aAuxDSR[nx][1],aBaseDsr[ny, 3],,,,,lGrv)
						EndIf
					EndIf
				EndIf
			EndIf
		Next nx
	Next ny
EndIf

//Restaura os valores originais de Horas Trabalhadas e DSR
If (lPDsrAdm .OR. lPDsrDem .OR. lPDsrAfa .OR. lPDsrFer) .And. ( nSvHrsDesc > 0 .Or. nSvHrsTrab > 0 )
	nHrsDesc := nSvHrsDesc
	nHrsTrab := nSvHrsTrab
EndIf

If lCalcResc
	If !IsInCallStack("GPEM630") .and. SRA->RA_CATFUNC == "H" .And. Empty( M->RG_DESCANS + M->RG_NORMAL )
		oModel := FWModelActive()
		oModel:GetModel("GPEM040_MSRG"):SetValue("RG_NORMAL" , Normal  )
		oModel:GetModel("GPEM040_MSRG"):SetValue("RG_DESCANS", Descanso)
	EndIf
	Descanso	:= nSvHrsDesc
	Normal		:= nSvHrsTrab
EndIf

If lDSRPon
	nHrsDesc := nBkpHDesc
	nHrsTrab := nBkpHTrab
EndIf

If ( IsInCallStack("GPEM070") .or. IsInCallStack("GPM070GRD") ) .And. lRotinc
	Normal := NormalSV
	Descanso := DescansoSV
EndIf
//-- Somar os Dsr para retorno da nas variaveis enviadas como Parametros
nValDsr 	:= nValDsrN + nValDsrC + nValDsrO
nHorDsr 	:= nHorDsrN + nHorDsrC + nHorDsrO
lPropDia	:= lProAux

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³fChkLicRem³ Autor ³ Emerson Rosa de Souza ³ Data ³26/05/00  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna dias de licenca remunerada (24/12,25/12,31/12,01/01)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCalcFimAq(dDtIni,cTipoRet)                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nDPriMes - Dias do Primeiro Mes ( 24/12,25/12 e 31/12 )    |±±
±±³          ³ nDSegMes - Dias do Segundo  Mes ( 01/01 )			      |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fChkLicRem(dDtIniRef,dDtFimRef,nDMes12,nDMes01,cDia2501)

Local aDLicRem,dDtLicRem,nDl,cAno
Local dDtFimAux := dDtFimRef

DEFAULT cDia2501 := GetMvRH( "MV_DIA2501", .F., "N", SRA->RA_FILIAL )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| O conteudo "S" do parametro foi mantido p/ compatibilizacao|
//| com versoes anteriores. O parametro agora pode conter as   |
//| datas 24/12,25/12,31/12 e 01/01                            |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cDia2501 := If( cDia2501 == "S", "25/12,01/01", cDia2501 )

nDMes12  := nDMes01 := 0
aDLicRem  := { "24/12", "25/12", "31/12", "01/01" }
cAno      := StrZero(Year(dDtIniRef),4)
For nDl := 1 To Len(aDLicRem)
	If aDLicRem[nDl] $ cDia2501
		If nDl # 4
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica os dias de licenca das datas 24/12, 25/12 e 31/12   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dDtLicRem := CTOD(aDLicRem[nDl]+"/"+cAno,"DDMMYY")
			If dDtIniRef <= dDtLicRem .And. dDtFimAux >= dDtLicRem
				If Month(dDtIniRef) == Month(dDtLicRem)
					nDMes12 ++
				Else
					nDMes01 ++
				EndIf
				dDtFimAux ++
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica os dias de licenca da data 01/01    				 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dDtLicRem := CTOD(aDLicRem[nDl]+"/"+StrZero(Val(cAno)+1,4),"DDMMYY")
			If dDtIniRef <= dDtLicRem .And. dDtFimAux >= dDtLicRem
				nDMes01 ++
			Else
				dDtLicRem := CTOD(aDLicRem[nDl]+"/"+StrZero(Val(cAno),4),"DDMMYY")
				If dDtIniRef <= dDtLicRem .And. dDtFimAux >= dDtLicRem
					nDMes12 ++
				EndIf
			EndIf
		EndIf
	EndIf
Next nDl
Return Nil



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fLiquido ³ Autor ³ Mauro                 ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do L¡quido                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fliquido(aCodfol,nArred,lIns,lSfam)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aCodFol   - Matriz Com Codigos da Folha                     ³±±
±±³          ³cCodliq   - Verba de Gravacao do Liquido                    ³±±
±±³          ³nArred    - Valor a Ser Arredondado                         ³±±
±±³          ³cCodArred - Verba de Grav. do Arredondamento                ³±±
±±³          ³lIns      - .F. OU .F. para Gravar Insuficiencia de saldo   ³±±
±±³          ³cCodIns   - Verba de Grav. da Insuficiencia                 ³±±
±±³          ³lObrigat  - .T. Para Obrigatoriedade da Verba no Liquido    ³±±
±±³          ³lGrava    - .T. Para Gravar o Liquido, Arred. e Insuf.      ³±±
±±³          ³lDemiss   - .T. Para Considerar Funcionarios Demitidos na Ge³±±
±±³          ³                racao de Insuficiencia de Saldo			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fLiquido(aCodfol,cCodliq,nArred,cCodArred,lIns,cCodIns,lObrigat,lGrava,lDemiss)

Local nObrigat	:= 0.00
Local nApd		:= 0.00
Local nLenApd	:= If( Type("aPd") == "A" , Len( aPd ) , 0.00 )
Local nValAux   := 0

//--Situacao do Funcionario na data de referencia
cSitFolh	:= If( Type("cSitFolh")=="U",SRA->RA_SITFOLH,cSitFolh)

DEFAULT aCodFol 	:= {}
DEFAULT cCodLiq		:= Space(03)
DEFAULT nArred		:= 0.00
DEFAULT cCodArred	:= Space(03)
DEFAULT lIns		:= .F.
DEFAULT cCodIns		:= Space(03)
DEFAULT lGrava		:= .T.
DEFAULT lObrigat	:= .F.
DEFAULT lDemiss		:= .F.

If cTipoRot == "1" .And. cPaisLoc == "BRA" .And. cSitFolh # "D" .And. !(SRA->RA_CATFUNC $ 'E*G') .and. !lDissidio .And. SRA->RA_TPCONTR != "3"
	fGerArr13()
EndIf

// Liquido/Arredondamento/Insuficiencia
nLiquido := 0.00

// Soma Para compor o Liquido
Aeval( aPd ,{ |x| SomaInc(x,0,@nLiquido,,,,,,.F.,aCodFol ) } )
If SRA->RA_TPCONTR == "3"
	Aeval( aPdConvoc ,{ |x| SomaInc(x,0,@nLiquido,,,,,,.F.,aCodFol ) } )
EndIf

// Verifica o valor dos Proventos Obrigatorios
If lObrigat
	For nApd := 1 To nLenApd
		If aPD[ nApd , 3 ] == cSemana .and. aPd[ nApd , 9 ] # "D" .and. ;
		Upper(RetValSrv(aPD[ nApd , 1 ],SRA->RA_FILIAL,"RV_OBRIGAT") ) == "S"
			nObrigat += aPd[ nApd , 5 ]
		EndIf
	Next nApd
EndIf

If Type("cCalcInf") != "U" .and. cCalcInf == "S" // GetMvRH("MV_CALCINF")
	nObrigat := 0
EndIf

nVAL_ARRE := VLR_INS := 0.00

//Tratamento para provisão do eConsignado quando existir insuficiência de saldo - O desconto deve ser limitado ao saldo do adiantamento
If nLiquido < 0 .and. cTipoRot == "2" 
	nApd := aScan(aPd, {|x| x[1] == aCodFol[1974,1] .and. x[9] <> "D" .and. x[5] > 0})
	If nApd > 0
		nValAux := nLiquido * -1
		nLiquido := Min(nLiquido + aPd[nApd,5],0)
		aPd[nApd,5] -= ( nValAux + nLiquido )
	EndIf
EndIf

If ( nLiquido < 0.00  .or. ( lObrigat .and. nliquido < nObrigat) ) .and. lIns
	// CALCULO DO PROVENTO INSUFICIENCIA DE SALDO
	// QUANDO HA VERBAS OBRIGATORIAS O VALOR DO LIQUIDO DEVE
	// SER IGUAL AO MESMO, E NUNCA ZERO, NESTES CASOS
	nVlr_ins := 0.00
	If !( cSitFolh $ "D*E" ) .or. ( cSitFolh == "D" .and. lDemiss )
		If Round(nLiquido,2) < 0.00 .Or. ( lObrigat .and. Round(nLiquido,2) < nObrigat)
			If Round(nLiquido,2) < 0.00
				nVlr_ins = (nLiquido * -1) + nObrigat
				nLiquido := nObrigat
			ElseIF lObrigat
				nVlr_ins := nObrigat - nLiquido
            	nLiquido := nObrigat
			EndIf
		EndIf
	ElseIF Round( nLiquido , 2 ) < 0.00
		nVlr_ins = ( nLiquido * -1 )
    EndIf
	If nVlr_ins # 0
		If lGrava
			FMatriz( cCodIns , nVlr_ins )
		EndIf
	EndIf
EndIf

//--Calcula Arredondamento
If nArred > 0.00 .and. nLiquido > 0 .and. !(cTipoRot == "5" .and. aPergunte[4,3] == 1) .And. cTipoRot != "N"
	nLiquido := Round( nLiquido , 2 )
	// --- Procura Arredondamento
	If cCodarred # SPACE(3) .and. Ascan(aPd, { |x| x[1] == cCodarred .and. x[3] == cSemana .and. x[9] # "D"} ) == 0
		nSALV_ARR := nArred
		CALC_ARRE(@nLIQUIDO, @nArred, @nVAL_ARRE,cSemana)
		nArred := nSALV_ARR
		If lGrava
			FMatriz(cCodArred,nVal_Arre,,,,,,,,dData_Pgto)
		EndIf
	EndIf
EndIf

//-- Grava‡ao do Liquido
//-- Grava‡ao do Liquido
If Ascan(aPd,{ |x| x[1] == cCodLiq .and. x[3] == cSemana .and. x[9] # "D"}) == 0
	If lGrava
		fMatriz(cCodLiq,nLiquido,,,,,,,,dData_Pgto)
		If cTipoRot == "N"
			fMatriz(aCodFol[1658,1],nLiquido,,,,,,,,dData_Pgto)
		EndIf
	EndIf
EndIf

Return( If( !lGrava , nObrigat , 0 ) )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fHistFer ³ Autor ³ Emerson Rosa de Souza ³ Data ³06/02/99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava o historico caso haja perda de periodo                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fHistFer()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ dIniDtBas  -Inicio do periodo aquisitivo                   |±±
±±³          ³ dFimDtBas  -Fim do periodo aquisitivo                      |±±
±±³          ³ dDiasAf    -Dias de afastamento do periodo                 |±±
±±³          ³ dDescTipAfa-Descricao do afastamento que ocasionou a perda |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fHistFer(dIniDtBas,dFimDtBas,nDiasAf,cDescTipAfa)
Local cAlias := Alias()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Grava no Arquivo de historico o Periodo de Ferias Perdido    |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SRH")
If ! dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+Dtos(dIniDtBas))
	RecLock("SRH",.T.)
Else
	RecLock("SRH",.F.)
EndIf
SRH->RH_FILIAL  := SRA->RA_FILIAL
SRH->RH_MAT     := SRA->RA_MAT
SRH->RH_SALMES  := 0
SRH->RH_SALDIA  := 0
SRH->RH_SALHRS  := 0
SRH->RH_DATABAS := dIniDtBas
SRH->RH_DBASEAT := dFimDtBas
SRH->RH_DFERVEN := 30
SRH->RH_DFERIAS := 0
SRH->RH_DABONPE := 0
SRH->RH_PERC13S := 0
SRH->RH_DATAINI := CTOD("")
SRH->RH_DATAFIM := CTOD("")
SRH->RH_DFALTAS := 0
SRH->RH_DAFASTA := nDiasAf
SRH->RH_DTAVISO := CTOD("")
SRH->RH_DTRECIB := CTOD("")
SRH->RH_SALMIN  := 0
SRH->RH_DIALREM := 0
SRH->RH_DIALRE1 := 0
SRH->RH_TIPCAL  := "N"
SRH->RH_MEDATU  := "N"
SRH->RH_OBSERVA := cDescTipAfa

MsUnlock()
dbSelectArea(cAlias)

Return Nil




/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fSalProf ³ Autor ³ Emerson               ³ Data ³ 06.08.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula Salario Dia Hora e Mes da categoria Professor      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ fSalProf(Salario,Salhora,Saldia,Salmes,Tipo)               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fSalProf(Salario,SalHora,SalDia,SalMes,aTarefas,aSalProf,lDsrHrsAtiv)
Local nCnt1,nCnt2,nCnt3
Local nVlDsrProf := 0
Local nVlHrsAtiv := 0
Local nVlDsrHrs  := 0
Local nPos		 := 0
Local nValor	 := 0
Local aBsDsrProf := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
Local aBsHrsAtiv := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
Local aBsDsrHrs  := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
Local aTotTarefa := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
Local nFixaTotal := 1				//  Sera sempre 1 pois buscara a parte fixa para o SALMES do Professor
Local lDsrBsHAtv := SRV->( RetValSRV(aCodFol[033,1],SRA->RA_FILIAL,"RV_HRSATIV") ) == "S" // Dsr base para Hora atividade
Local lHAtvBsDsr := SRV->( RetValSRV(aCodFol[317,1],SRA->RA_FILIAL,"RV_DSRPROF") ) == "S" // Hora atividade base para Dsr
Local aSvTaref	 := aClone( aTarefas )

DEFAULT lDsrHrsAtiv := GetMvRH("MV_DSRHATV",,.T.)         //  Calcula Primeiro o DSR depois Horas Atividade

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Elementos:   1-Fixa         2-Variavel     3-Total			    ³
//³             N1-Salario     N2-DSR         N3-Horas Atividade	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aSalProf := { { 0,0,0 }, { 0,0,0 }, { 0,0,0 } }
aOSlPrf		:= { { 0,0,0 }, { 0,0,0 }, { 0,0,0 } }

For nCnt3 := 1 To 2

	nVlDsrProf := nVlHrsAtiv := nVlDsrHrs  := 0
	aBsDsrProf := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
	aBsHrsAtiv := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
	aBsDsrHrs  := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
	aTotTarefa := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total

	If nCnt3 == 1
		aTarefas := aClone( aOrigTar )
	Else
		aTarefas := aClone( aSvTaref )
	EndIf

	For nCnt1 := 1 To Len(aTarefas)
		If aTarefas[nCnt1,7] == "1"  // Provento


			If Len(aTarefas[nCnt1]) > 17
				nValor := aTarefas[nCnt1, 2] + aTarefas[nCnt1, 17] - aTarefas[nCnt1, 18]
			Else
				nValor := aTarefas[nCnt1, 2]
			EndIf

			// Posiciona na Verba para calcular salario do professor
			SRV->( PosSrv(aTarefas[nCnt1,1],SRA->RA_FILIAL) )

			// Totaliza proventos para calculo do DSR
			If SRV->RV_DSRPROF == "S"
				If aTarefas[nCnt1,9] $ "1*3"
					aBsDsrProf[1] += nValor
				ElseIf aTarefas[nCnt1,9] $ "2*4"
					aBsDsrProf[2] += nValor
				EndIf
				aBsDsrProf[3] += nValor
			EndIf

			// Totaliza proventos para calculo das Horas Atividade
			If SRV->RV_HRSATIV == "S"
				If aTarefas[nCnt1,9] $ "1*3"
					aBsHrsAtiv[1] += nValor
				ElseIf aTarefas[nCnt1,9] $ "2*4"
					aBsHrsAtiv[2] += nValor
				EndIf
				aBsHrsAtiv[3] += nValor
			EndIf

			// Totaliza proventos que incidam DSR e Hora atividade
			If lRecriaDsr .and. SRV->RV_DSRPROF == "S" .and. SRV->RV_HRSATIV == "S"
				If aTarefas[nCnt1,9] $ "1*3"
					aBsDsrHrs[1] += nValor
				ElseIf aTarefas[nCnt1,9] $ "2*4"
					aBsDsrHrs[2] += nValor
				EndIf
				aBsDsrHrs[3] += nValor
			EndIf

			// Totaliza Tarefas de proventos
			If aTarefas[nCnt1,9] $ "1*3"        // Fixa
				aTotTarefa[1] += nValor
			ElseIf aTarefas[nCnt1,9] $ "2*4"    // Variavel
				aTotTarefa[2] += nValor
			EndIf
			aTotTarefa[3] += nValor // Total
		EndIf
	Next nCnt1

	// Composicao do salario do Professor - Fixas/Variaveis/Total
	For nCnt2 := 1 To 3
		If lDsrHrsAtiv // Calcula DSR e sobre ele a Hora Atividade
			nVlDsrProf := Round( aBsDsrProf[nCnt2] * aParProf[2], 2)
			nVlDsrHrs  := If ( lRecriaDsr , Round( aBsDsrHrs[nCnt2] * aParProf[2], 2), nVlDsrProf) //Somente horas de DSR que incidam horas atividades
			nVlHrsAtiv := Round((aBsHrsAtiv[nCnt2] + If(lDsrBsHAtv,nVlDsrHrs,0) ) * aParProf[3], 2)
		Else           // Calcula Hora Atividade e sobre ela o DSR
			If !lDsrBsHAtv
				nVlHrsAtiv := Round(aBsHrsAtiv[nCnt2]  * aParProf[3], 2)
				nVlDsrProf := Round((aBsDsrProf[nCnt2] + If(lHAtvBsDsr,nVlHrsAtiv,0) ) * aParProf[2], 2)
			Else
				nVlDsrProf := Round( aBsDsrProf[nCnt2] * aParProf[2], 2)
				nVlHrsAtiv := Round((aBsHrsAtiv[nCnt2] + nVlDsrProf ) * aParProf[3], 2)
			EndIf
		EndIf

		If nCnt3 == 1
			aOSlPrf[nCnt2,1] := aTotTarefa[nCnt2]	// Salario
			aOSlPrf[nCnt2,2] := nVlDsrProf			// DSR
			aOSlPrf[nCnt2,3] := nVlHrsAtiv 			// Horas Atividade
		Else
			aSalProf[nCnt2,1] := aTotTarefa[nCnt2] // Salario
			aSalProf[nCnt2,2] := nVlDsrProf			// DSR
			aSalProf[nCnt2,3] := nVlHrsAtiv 		// Horas Atividade
		EndIf
	Next nCnt2
Next nCnt3

aTarefas := aClone( aSvTaref )

//Regrava Horas Atividade somente se mnemonico for true
If lRecriaDsr
	If ( nPos := Ascan(aPd, { |X| X[1] = aCodFol[317,1] .and. X[9] # "D" }) ) > 0 .and. !( aPd[nPos][5] == nVlHrsAtiv )
		aPd[nPos][5] := nVlHrsAtiv
	EndIf
EndIf

If Type("lUtiMultiV") == "U"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se veio de fSalInc() calcula o salario somente sobre as tarefas ³
	//³ fixas, caso contrario calcula sobre as tarefas fixas e variaveis³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lNewProf
		If nDiasAfas > 0 .And. DiasTrab > 0
			SalMes  := Salario := ( (aSalProf[nFixaTotal, 1] + aSalProf[nFixaTotal, 2] + aSalProf[nFixaTotal, 3]) / DiasTrab * nDiasC)
		Else
			SalMes  := Salario := aSalProf[nFixaTotal, 1] + aSalProf[nFixaTotal, 2] + aSalProf[nFixaTotal, 3]
		EndIf
	Else
		SalMes  := Salario := aOSlPrf[nFixaTotal, 1] + aOSlPrf[nFixaTotal, 2] + aOSlPrf[nFixaTotal, 3]
	EndIf

	SalDia  := SalDor  := SalMes / nDiasC
	SalHora := SalHor  := SalMes / nHrsCal
	Salario := SalMes
EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fPSlProf ³ Autor ³ Equipe Rh             ³ Data ³ 14/10/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Proporcionaliza salario do professor                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fPSlProf()									              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fPSlProf(aTarefas,lProp,lDsrHrsAtiv)
Local nCnt
Local lDsrBsHAtv := SRV->( RetValSRV(aCodFol[033,1],SRA->RA_FILIAL,"RV_HRSATIV") ) == "S" // Dsr base para Hora atividade
Local lHAtvBsDsr := SRV->( RetValSRV(aCodFol[317,1],SRA->RA_FILIAL,"RV_DSRPROF") ) == "S" // Hora atividade base para Dsr
Local nVlDsrProf := 0
Local nVlHrsAtiv := 0
Local nVADsrProf := 0	// Valor do DSR de Professores para tarefas variaveis
Local nVAHrsAtiv := 0	// Valor da Hora Atividade de Professores para tarefas variaveis
Local nPos		 := 0
Local nPosTar	 := 0
Local lPropTar   := GetMvRH("MV_PROPTAR",,.F.)   //-- Indica se deve clcular o salario variavel proporcionalmente aos dias trabalhados no mes.
Local aTarAux	 := {}

DEFAULT lDsrHrsAtiv := .T.         //  Calcula Primeiro o DSR depois Horas Atividade
DEFAULT aTarefas := {}
DEFAULT lProp    := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Situacao do Funcionario na data de referencia				 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cSitFolh := If( Type("cSitFolh")=="U",SRA->RA_SITFOLH,cSitFolh )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Admitido no mes de processamento             				 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lAdmissao	:= If( Type("lAdmissao")=="U",MesAno(SRA->RA_ADMISSA) == MesAno(dDataAte),lAdmissao)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Nao proporcionaliza qdo. novo calulo: MV_NCPROF = 1          ³
//³ Proporcionaliza afastados nao demitidos ou conforme parametro³
//³ Proporcionaliza admitidos no mes tambem.                     ³
//³ Proporcionaliza Tarefas nas rescisao considerando MV_PROPTAR ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( ( !Empty(cSitFolh) .And. cSitFolh # "D" ) .Or. lProp .Or. lAdmissao .or. ( !Empty(dDataDem) .and. lPropTar ) ) .And. !lNewProf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Proporcionaliza as tarefas referente ao salario do professor ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nCnt := 1 To Len(aTarefas)
		nVlHrsAtiv := 0
		nVlDsrProf := 0
		nPos := Ascan(aPd, { |X| X[1] + X[2] = aTarefas[nCnt,1] + aTarefas[nCnt,5]  .And. X[9] # 'D'})
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Qdo Tarefa eh variavel e sao pagas numa mesma verba, no aPD   ³
		//³elas ja vem somadas, portanto não posso proporcionalizar-las  ³
		//³tantas vezes qtas forem o numero de lancamentos no aTarefas   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPosTar	:=ascan(aTarAux , {|x| X == aTarefas[nCnt,1] + aTarefas[nCnt,5] }  )

		If nPos > 0 .and. nPosTar <= 0
			If aTarefas[nCnt,9] == "1" .or.  ( lPropTar  .and.  aTarefas[nCnt,9] == "2")
				aPd[nPos,4] := (aPd[nPos,4] / nDiasC ) * Diastrab
				aPd[nPos,5] := Round( aPd[nPos,5] / nDiasC * Diastrab, MsDecimais(1))
				//-- Desconsidera elemento se o valor resultante for nulo
				If aTarefas[nCnt,9] == "1" .and. Empty(aPd[nPos,5])
					aPd[nPos,9] :='D'
				EndIf
				aadd(aTarAux, aTarefas[nCnt,1] + aTarefas[nCnt,5] ) 						//-- Utilizada para nao permitir que uma mesma verba proveniente do aTarefa seja proprorcionalizada novamente
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Guarda o valor de hora atividade e dsr s/tarefas variaveis.  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SRV->( PosSrv(aTarefas[nCnt,1],SRA->RA_FILIAL) )
				If lDsrHrsAtiv // Calcula DSR e sobre ele a Hora Atividade
					If SRV->RV_DSRPROF == "S"
						nVlDsrProf := Round(aPd[nPos,5] * aParProf[2], 2)
					EndIf
					If SRV->RV_HRSATIV == "S"
						nVlHrsAtiv := Round((aPd[nPos,5] + If(lDsrBsHAtv,nVlDsrProf,0) ) * aParProf[3], 2)
					EndIf
				Else           // Calcula Hora Atividade e sobre ela o DSR
					If SRV->RV_HRSATIV == "S"
						nVlHrsAtiv := Round(aPd[nPos,5]  * aParProf[3], 2)
					EndIf
					If SRV->RV_DSRPROF == "S"
						nVlDsrProf := Round((aPd[nPos,5] + If(lHAtvBsDsr,nVlHrsAtiv,0) ) * aParProf[2], 2)
					EndIf
				EndIf
				nVADsrProf += nVlDsrProf
				nVAHrsAtiv += nVlHrsAtiv
			EndIf
		EndIf
	Next nCnt
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Proporcionaliza o DSR                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nPos := Ascan(aPd, { |X| X[1] = aCodFol[033,1] .And. X[9] # 'D'})
	If nPos > 0
		aPd[nPos,5] := aPd[nPos,5] - nVADsrProf
		aPd[nPos,4] := (aPd[nPos,4] / nDiasC ) * Diastrab
		aPd[nPos,5] := Round( aPd[nPos,5] / nDiasC * Diastrab, MsDecimais(1))
		aPd[nPos,5] := aPd[nPos,5] + nVADsrProf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Proporcionaliza as Horas Atividades                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nPos := Ascan(aPd, { |X| X[1] = aCodFol[317,1] .And. X[9] # 'D'})
	If nPos > 0
		aPd[nPos,5] := aPd[nPos,5] - nVAHrsAtiv
		aPd[nPos,4] := (aPd[nPos,4] / nDiasC ) * Diastrab
		aPd[nPos,5] := Round( aPd[nPos,5] / nDIasC * Diastrab, MsDecimais(1))
		aPd[nPos,5] := aPd[nPos,5] + nVAHrsAtiv
	EndIf
EndIf

Return Nil



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fDIndProf ºAutor  ³Emerson             º Data ³  26/05/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Apura os dias indenizados referente a demissao antes do 	  º±±
±±º          ³termino do semestre ou no periodo de recesso.               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fDIndProf(nDiasIndP,dDatSemInf,dDatRecInf,nDIndSem,nDIndRec)
Local aArea     := Getarea()
Local nDiasVenc := nDiasProp := 0
Local dPIDem1Sm := CtoD("")
Local dPIDem2Sm := CtoD("")
Local dFimPer2	:= CtoD("")
Local cMIni1Sm	, cMFim1Sm	, cMIni2Sm	,cMFim2Sm
Local dDtIni1Sm , dDtFim1Sm	, dDtIniPSm
Local dDatCalc 	, dDtIni2Sm	, dDtFim2Sm
Local nAnoIni	, nAnoFim

DEFAULT dDatSemInf := CTOD("")
DEFAULT dDatRecInf := CTOD("")

nA13oIndP := nDiasIndP := nDIndSem := nDIndRec := 0

dbSelectArea( "RCE" )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ MNEMONICOS ESPECIAIS - DE ACORDO COM CADA SINDICATO			 ³
//³ Caso o usuario precise configurar para cada sindicato, devera³
//³ criar os campos no cadastro de sindicato RCE e, atraves das  ³
//³ formulas, igualar os mnemonicos aos campos do RCE.           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//P_PIDEM1SM := "DD/MM"   //"Dia/Mes p/demissao sem pgto indeniz. 1o.Sm"
//P_PIDEM2SM := "DD/MM"   //"Dia/Mes p/demissao sem pgto indeniz. 2o.Sm"
//P_CCAVITRA := "N"		 //"Conta aviso como dias trab. na indenizacao"
//P_PAGRECES := "N"		 //"Pagar indenizacao referente o recesso"
//P_PAGINDFD := "N"       //"Pagar os dias indeniz. sobre ferias e 13o"
//P_NDRECALS := "0"       //"Dias de recesso ate o inicio do Proximo Ano Letivo "

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Data utilizada para o calculo                            	 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dDatCalc := dDataDem + If( P_CCAVITRA == "S", nDiasAv, 0 )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Meses do periodo letivo                                  	 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cMIni1Sm := Substr(RCE->RCE_INI1SM,3,2)  //Mes inicial 1o. semestre
cMFim1Sm := Substr(RCE->RCE_FIM1SM,3,2)  //Mes final   1o. semestre
cMIni2Sm := Substr(RCE->RCE_INI2SM,3,2)  //Mes inicial 2o. semestre
cMFim2Sm := Substr(RCE->RCE_FIM2SM,3,2)  //Mes final   1o. semestre

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta data de inicio e fim do 1o. semestre					 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nAnoFim   	:= Year(dDatCalc)
nAnoIni   	:= If( cMIni1Sm <= cMFim1Sm, nAnoFim, nAnoFim - 1 )
dDtIni1Sm 	:= Ctod( Transform(RCE->RCE_INI1SM, "@R 99/99") + "/" + Strzero( nAnoIni,   4), "DDMMYY")
dDtFim1Sm 	:= Ctod( Transform(RCE->RCE_FIM1SM, "@R 99/99") + "/" + Strzero( nAnoFim,   4), "DDMMYY")
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta data de inicio do proximo semestre 					 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dDtIniPSm := Ctod( Transform(RCE->RCE_INI1SM, "@R 99/99") + "/" + Strzero( nAnoFim+1, 4), "DDMMYY")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta data de inicio e fim do 2o. semestre					 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nAnoFim   := Year(dDatCalc)
nAnoIni   := If( cMIni2Sm <= cMFim2Sm, nAnoFim, nAnoFim - 1 )
dDtIni2Sm := Ctod( Transform(RCE->RCE_INI2SM,"@R 99/99") + "/" + Strzero( nAnoIni, 4), "DDMMYY")
dDtFim2Sm := Ctod( Transform(RCE->RCE_FIM2SM,"@R 99/99") + "/" + Strzero( nAnoFim, 4), "DDMMYY")
dFimPer2  := Ctod( Transform(RCE->RCE_FIM2SM,"@R 99/99") + "/" + Strzero( year(dDataDem),   4), "DDMMYY")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta a data ideal para efetuar a demissao             		 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( P_PIDEM1SM )
	dPIDem1Sm  := Ctod( Transform(P_PIDEM1SM,"@R 99/99") + "/" + Strzero( Year(dDtIni1Sm), 4), "DDMMYY")
EndIf
If !Empty( P_PIDEM2SM )
	dPIDem2Sm  := Ctod( Transform(P_PIDEM2SM,"@R 99/99") + "/" + Strzero( Year(dDtIni2Sm), 4), "DDMMYY")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Utiliza a data de apuracao informada.						 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( dDatSemInf )
	dDatCalc := dDatSemInf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Apura os dias de Semestralidade								 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If dDatCalc > dDtIni1Sm .And. dDatCalc < dDtFim1Sm
	nDIndSem := dDtFim1Sm - dDatCalc
	If !Empty( dPIDem1Sm ) .And. dDatCalc <= dPIDem1Sm
		nDIndSem := 0
	EndIf
ElseIf dDatCalc > dDtIni2Sm .And. dDatCalc < dDtFim2Sm
	nDIndSem := dDtFim2Sm - dDatCalc
	If !Empty( dPIDem2Sm ) .And. dDatCalc <= dPIDem2Sm
		nDIndSem := 0
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Utiliza a data de apuracao informada.						 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( dDatRecInf )
	dDatCalc := dDatRecInf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Apura os dias de Recesso									 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If P_PAGRECES == "S"
	If dDatCalc < dDtIni1Sm
		nDIndRec := dDtIni1Sm - dDatCalc
	ElseIf dDatCalc > dDtFim1Sm .And. dDatCalc < dDtIni2Sm
		nDIndRec := dDtIni2Sm - dDatCalc
	ElseIf dDatCalc > dDtFim2Sm .And. dDatCalc < dDtIniPSm
		nDIndRec := dDtIniPSm - dDatCalc
	ElseIf P_NDRECALS > 0 .and. year(dDatCalc)> year(dDataDem)
		If dDatCalc > dFimPer2 .and. dDatCalc < (dFimPer2+ P_NDRECALS)
			nDIndRec := (dFimPer2+ P_NDRECALS) - dDatCalc
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Totaliza os dias de Semestralidade + Recesso                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nDiasIndP := nDIndSem + nDIndRec

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Apura os avos de ferias e 13o. por conta dos dias Indenizados³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If P_PAGINDFD == "S" .And. nDiasIndP > 0
	nDiasVenc  := 0
	nDiasProp  := 0
	Calc_Fer(dDatCalc,dDatCalc+nDiasIndP,@nDiasVenc,@nDiasProp)
	nDFerIndP   := nDiasVenc + nDiasProp
	fAvos13(@nA13oIndP,dDatCalc+nDiasIndP,0,0,,,dDatCalc)
EndIf

RestArea( aArea )

Return Nil




/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fSalDiss ³ Autor ³ Andreia dos Santos    ³ Data ³ 14.07.03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula Salario Dia Hora e Mes                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ fSalDiss(Salario,Salhora,Saldia,Salmes,Tipo)               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fSalDiss( Salario, SalHora, SalDia, SalMes, cTipo, cTipAum )
Local aArea			:= GetArea()
Local cDatarq		:= StrZero( Year( dDataAte ), 4, 0 ) + StrZero( Month( dDataAte ),2)
Local cPerAux		:= ""
Local cAnoMesPesq	:= cMesAnoCalc//Left( cAnoMes, 4 ) + Right( cAnoMes, 2 )
Local cCatFunc		:= SRA->RA_CATFUNC
Local cTipoPgt		:= SRA->RA_TIPOPGT
Local cAliasDis		:= "RHH"
Local lMAprendiz  	:= GetMvRH("MV_MAPREND",,.F.)
Local lAchou 		:= .F.
Local lDifInc		:= .F.
Local cMes			:= SubStr(cAnoMes,5,2)
Local cAno			:= SubStr(cAnoMes,1,4)
Local cPDs			:= ACODFOL[13,1]+"/"+ACODFOL[14,1]+"/"+ACODFOL[19,1]+"/"+ACODFOL[20,1]+"/"+ACODFOL[64,1]+"/"+ACODFOL[65,1]+"/"+ACODFOL[70,1]
Local dData			:= CtoD("01/" + cMes + "/" + cAno)
Local nNumSemana	:= 0
Local nDiasCalc		:= 0
Local nHrsMes		:= 0
Local nHrsDia		:= 0
Local nValor		:= 0
Local nBaseSal		:= 0
Local nBaseAux		:= 0
Local nPisoSal		:= 0
Local nSalAnt		:= SalMes
Local nCond			:= Nil

If cTipoRot == "3"
	nCond := 11
ElseIf cTipoRot == "4"
	nCond := 12
EndIf

nDisSalInc := 0

Aeval( aPd ,{ |x| If( (!(AllTrim(x[7]) $ "P*S*A*K*C*R*V") .OR. x[1] $ ACODFOL[28,1]+"/"+ACODFOL[348,1]) .AND. !(x[1] $ CPDS), SomaInc(X,18,@nDisSalInc,nCond,"S" , , , , ,aCodfol),) }) //SOMA AS VERBAS QUE INCORPORAM SALÁRIO

//Utiliza os dias de cálculo de aPeriodo pois em fCarPeriodo o array é criado com os dados da época.
nDiasCalc   := IF(APERIODO[NPOSSEM,16] == "02" .and. cPaisLoc == "BRA" .and. !P_PGSALFEV , APERIODO[NPOSSEM,18] , APERIODO[NPOSSEM,20])

If SRA->RA_CATFUNC == "M" .AND. Day(SRA->RA_ADMISSA) > 1 .AND. AnoMes(SRA->RA_ADMISSA) == CPERIODO .AND. APERIODO[NPOSSEM,16] <> "02"
	nDiasCalc := IF( APERIODO[NPOSSEM,18] == 31 .AND. P_DIASADM == 1, APERIODO[NPOSSEM,18], APERIODO[NPOSSEM,20])
EndIf

nHrsDia := SRA->RA_HRSDIA

SR9->(DbSetOrder(1))

If SR9->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + "RA_HRSMES "))
	While SR9->( !Eof() ) .and. SRA->RA_FILIAL + SRA->RA_MAT == SR9->R9_FILIAL+SR9->R9_MAT .AND. ("RA_HRSMES" $ SR9->R9_CAMPO)
		If SR9->R9_DATA <= dDataAte
			nHrsMes := Val( SR9->R9_DESC )
		Else
			Exit
		EndIf

		SR9->( dbSkip() )
	EndDo

	If nHrsMes > 0
		nHrsDia := Round(( nHrsMes / 30 ),4)
		nHrsMes := Round(( nHrsDia * nDiasCalc),2)
		Normal  := aPeriodo[nPosSem,24] * nHrsDia
		Descanso:= aPeriodo[nPosSem,07] * nHrsDia
		NHRSCAL := Round((nHrsDia * NDIASC),2) //Mnemonico
	EndIf
EndIf

If nDiasCalc > 0 .And. nHrsDia > 0 .and. nHrsMes == 0
	If SRA->RA_CATFUNC == 'H' .and. cTipoRot $ "5/6"
		nHrsMes := SRA->RA_HRSMES
	else
		nHrsMes := Round((nHrsDia * nDiasCalc),2)
	EndIf
EndIf

dbSelectArea( 'SR3' )
If !Empty(SR3->(INDEXKEY(2)))
	dbSetorder(2)
EndIf

If dbSeek( SRA->RA_FILIAL + SRA->RA_MAT )
	While SR3->(!EOF()) .AND. SR3->R3_FILIAL + SR3->R3_MAT == SRA->RA_FILIAL + SRA->RA_MAT
		If SR3->R3_PD == '000' .and. mesAno(SR3->R3_DATA) <= cDatarq
	      	cCatFunc := fDesc( "SR7", SR3->R3_MAT+DTOS(SR3->R3_DATA)+SR3->R3_SEQ+SR3->R3_TIPO, "R7_CATFUNC", , SRA->RA_FILIAL, 2 )
	      	cTipoPgt := fDesc( "SR7", SR3->R3_MAT+DTOS(SR3->R3_DATA)+SR3->R3_SEQ+SR3->R3_TIPO, "R7_TIPOPGT", , SRA->RA_FILIAL, 2 )
	 	EndIf
	 	SR3->(DbSkip())
	 EndDo
EndIf

lAchou := (cAliasDis)->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cAnoMesPesq + cDatarq + "000" ) )

If cTipoRot == "3" .and. lCalcFol .and. (!lAchou .OR. ( cPeriodo < cSvSetPer .and. SRA->RA_CATFUNC == cCatFunc ) ) .and. (nDiasFMS + NDIASABMS) > 0//Se for calculo de diferença de férias e existir dias de férias no mês seguinte, procura pelo dissidio no mes seguinte.
	cPerAux		:= StrZero( Year( MonthSum(dDataAte,1) ), 4, 0 ) + StrZero( Month( MonthSum(dDataAte,1) ),2)
	lAchou := (cAliasDis)->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cAnoMesPesq + cPerAux + "000" ) )
	If !lAchou //Se não encontrou no mes atual, retorna para o ms anterior
		lAchou := (cAliasDis)->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cAnoMesPesq + cDatarq + "000" ) )
	EndIf
EndIf

If lAchou
	// Caso tenha varias convocacoes no Periodo, posiciona no registro correto
	If SRA->RA_TPCONTR == "3" .And. SRA->RA_SALARIO == 0 .And. Len(aConvocacao) > 0 .And. !Empty(aConvocacao[1])
		While (cAliasDis)->(!Eof()) .And. (cAliasDis)->RHH_VL <> aConvocacao[4]
			(cAliasDis)->(dbSkip())
		EndDo
	EndIf

	Begin Sequence
		// Menor Aprendiz
		If SRA->RA_CATEG = '07' .And. lMAprendiz
			 Do Case
				Case F_ULTDIA(dData) == 31
					nNumSemana := 4.428571
				Case F_ULTDIA(dData) == 30
					nNumSemana := 4.285714
				Case F_ULTDIA(dData) == 29
					nNumSemana := 4.142857
				Case F_ULTDIA(dData) == 28
					nNumSemana := 4
			EndCase
			If cCatFunc = "H"
				nValor :=  nHrsMes  / 5
				nValor := (nValor * nNumSemana) * (cAliasDis)->&((cAliasDis)+"_CALC")
				SalMes := (nValor * 7 ) / 6
			ElseIf cCatFunc = "M"
			   	Salmes := (cAliasDis)->&((cAliasDis)+"_CALC")
			EndIf
			Salario  := SalMes
			Break
		EndIf

		If Type("P_LDIFINC") <> "U" .And. P_LDIFINC .And. fDifIncorp()
			nBaseSal := SalMes
			lDifInc	 := .T.
		Else
			nBaseSal := (cAliasDis)->&((cAliasDis)+"_CALC")
		EndIf

		If cTipoRot == "3" .And. AnoMes(SRH->RH_DATAINI) < cSvSetPer
			nBaseAux := 0

			If SR3->(dbSeek( SRA->RA_FILIAL + SRA->RA_MAT ) )
				While SR3->(!EOF()) .AND. SR3->R3_FILIAL + SR3->R3_MAT == SRA->RA_FILIAL + SRA->RA_MAT
					If SR3->R3_PD == '000' .and. AnoMes(SR3->R3_DATA) == cSvSetPer .And. SR3->R3_VALOR > nBaseSal .And. cCatFunc == fDesc( "SR7", SR3->R3_MAT+DTOS(SR3->R3_DATA)+SR3->R3_SEQ+SR3->R3_TIPO, "R7_CATFUNC", , SRA->RA_FILIAL, 2 )
						nBaseAux := nBaseSal := SR3->R3_VALOR
				 	EndIf
				 	SR3->(DbSkip())
				 EndDo
				 If nBaseAux > 0
					If cCatFunc $ "M"
						nPisoSal := nPisoMes
					ElseIf cCatFunc $ "C*P*A*E"
						If cTipoPgt = "M"
							nPisoSal  := nPisoMes
						ElseIf cTipoPgt = "S"
							nPisoSal  := nPisoDia * 7
						EndIf
					ElseIf cCatFunc $ "H*T*G*"
						nPisoSal  := nPisoHora
					ElseIf cCatFunc $ "D"
						nPisoSal  := nPisoDia
					ElseIf cCatFunc $ "S"
						nPisoSal  := nPisoDia * 7
					EndIf
				 EndIf
			EndIf

			If nBaseSal == 0 //Se não houve alteração salarial no mês de retorno das férias
				If cCatFunc $ "M"
					nBaseSal := SRH->RH_SALARIO
					nPisoSal := nPisoMes
				ElseIf cCatFunc $ "C*P*A*E"
					If cTipoPgt = "M"
						nBaseSal  := SRH->RH_SALARIO
						nPisoSal  := nPisoMes
			   		ElseIf cTipoPgt = "S"
			   			nBaseSal  := SRH->RH_SALDIA * 7
			   			nPisoSal  := nPisoDia * 7
			   		EndIf
				ElseIf cCatFunc $ "H*T*G*"
					nBaseSal  := SRH->RH_SALHRS
					nPisoSal  := nPisoHora
				ElseIf cCatFunc $ "D"
					nBaseSal  := SRH->RH_SALDIA
					nPisoSal  := nPisoDia
				ElseIf cCatFunc $ "S"
					nBaseSal  := SRH->RH_SALDIA * 7
					nPisoSal  := nPisoDia * 7
				EndIf
			EndIf

			If lDifInc
				nBaseSal := If (!Empty(RHH->RHH_VALOR), nBaseSal + RHH->RHH_VALOR, nBaseSal * (1+ (RHH->RHH_INDICE/100)))
			EndIf
			If nPisoSal > nBaseSal
				nBaseSal := nPisoSal
			EndIf
		EndIf

		If cCatFunc $ "M"
			SalMes    := nBaseSal
			SalHora	  := nBaseSal / nHrsMes
			SalHora30 := nBaseSal / nHrsMes
			SalDia	  := nBaseSal / nDiasCalc
		ElseIf cCatFunc $ "C*P*A*E"
			If cTipoPgt = "M"
				SalMes    := nBaseSal
				SalHora   := nBaseSal / nHrsMes
				SalHora30 := nBaseSal / nHrsMes
				SalDia	  := nBaseSal / nDiasCalc
	   		ElseIf cTipoPgt = "S"
	   			SalMes  := nBaseSal / 7 * nDiasCalc
	   			SalHora := ( nBaseSal / 7 ) / nHrsDia
				SalDia	:= nBaseSal / 7
	   		EndIf
	    ElseIf cCatFunc $ "H*T*G*"
				SalMes  := nBaseSal * nHrsMes
				SalHora := nBaseSal
				SalDia	:= nBaseSal * nHrsDia
		ElseIf cCatFunc $ "D"
				SalMes  := nBaseSal * nDiasCalc
				SalHora := nBaseSal / nHrsMes
				SalDia	:= nBaseSal
		ElseIf cCatFunc $ "S"
	   			SalMes  := nBaseSal / 7 * nDiasCalc
	   			SalHora := ( nBaseSal / 7 ) / nHrsDia
				SalDia	:= nBaseSal / 7
		EndIf

		SALARIO  := SALMES
	    SALHOR   := SALHORA
	    SALDOR   := SALDIA
		SALHOR30 := SalHora30

    End Sequence

    If nSalAnt <> Salmes .and. nDisSalInc > 0 //Soma os valores incorporados na fCarMvto()
    	SalMes += nDisSalInc
    EndIf

EndIf

RestArea(aArea)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncoa    ³fVlDiss   ºAutor  ³Andreia Santos      º Data ³  29/09/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Calcula o reajuste do dissidio para verbas lancadas em valorº±±
±±º          ³Verifica se foi criado o campo RV_VALDISS e se ele esta com º±±
±±º          ³"sim" para calculo da verba lancada em valor.               º±±
±±º          ³Essa funcao devera ser chamada atraves de uma formula, apos º±±
±±º          ³testar se o mnemonico "lDissidio" e verdadeiro.             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVlDiss()

Local cAliasDis 	:= "RHH"
Local cDataArq
Local nPerc			:= 0
Local nX			:= 0

DEFAULT lValDissi	:= SRV->( ColumnPos("RV_VALDISS") ) > 0

If cTipoRot <> "4"
	//-- Nao executa teste do cadastro de formulas pois a funcao nao foi idealizada para tanto
	If lValDissi .And. TYPE("CMESANODISS") <> "U" .And. !lValoDiss
	    cDataArq	:= StrZero( Year( dDataAte ), 4, 0 ) + StrZero( Month( dDataAte ), 2 )
		lValoDiss	:= .T.
		If (cAliasDis)->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cMesAnoDiss + cDataArq + "000" ) )
			nPerc := (cAliasDis)->&((cAliasDis)+"_INDICE")

			If nPerc == 0 .and. nValAum > 0
				//Obtem o percentual de aumento com base no valor fixo do reajuste
				nPerc := Round( ( ( (cAliasDis)->&((cAliasDis)+"_CALC") * 100 ) / (cAliasDis)->&((cAliasDis)+"_VL") ) - 100, 6)
			EndIf

			For nX := 1 to len(aPD)
				If aPd[nX,6] == "V" .and. aPd[nX,7] $ "I*G"
					If RetValSRV(aPd[nX,1], SRA->RA_FILIAL, "RV_VALDISS") == "1" .And. Empty(RetValSRV(aPd[nX,1], SRA->RA_FILIAL, "RV_CODFOL")) .And. (cPaisLoc != "BRA" .Or. aScan( aDissInf, { | X | SRA->RA_FILIAL + SRA->RA_MAT + cRotOrig + cPeriodo + cSemPag + aPd[nX,1] == X[1] + X[2] + X[3] + X[4] + X[5] + X[6] .And. x[7] == aPd[nX,5] } ) == 0)
						aPd[nX,5]	:= aPd[nX,5] * (1+ (nPerc/100))
						If aPd[nX,19] < aPd[nX,5]
							aPd[nX,19]  := aPd[nX,5] //Se foi lançamento fixo proporcional a verba integral foi gravada pela fCalcRG1
						EndIf
					EndIf
				EndIf
			Next
		EndIf
	EndIf
Else
	If lRescDis
		nPerc   := Round(((SRA->RA_SALARIO - SRG->RG_SALMES) * 100) / SRG->RG_SALMES,2)
		For nX := 1 to Len(aPD)
			If aPd[nX,6] == "V" .and. aPd[nX,7] $ "I*G"
		 	   	If RetValSRV(aPd[nX,1],SRA->RA_FILIAL,"RV_VALDISS") == "1" .And. Empty(RetValSRV(aPd[nX,1], SRA->RA_FILIAL, "RV_CODFOL"))
					aPd[nX,5]	:= aPd[nX,5] * (1+ (nPerc/100))
		 	   	EndIf
			EndIf
		Next nX
	EndIf
EndIf

Return( .T. )

/*/{Protheus.doc} fDissCC
Buscar o centro de custo à época do cálculo
@author Henrique Ferreira v.1
		Leandro Drumond   v.2
@since 01/10/2018
@param
@type static function
/*/
Static Function fDissCC()

Local cCusto  := SRA->RA_CC
Local uRet

If HMGet(oPercDif, SRA->RA_FILIAL+SRA->RA_MAT+cPeriodo, uRet)
	cCusto := uRet[4]
EndIf

Return cCusto


/*/{Protheus.doc} function FMARGCS
Funcao que realiza o calculo da margem consignavel para o funcionario.
@author  Hugo de Oliveira
@since   08/12/2020
@version 1.0
/*/
Function FMARGCS()
	Local cConsigPd  := ""
    Local nMargem    := 0
    Local nSoma      := 0
    Local nVlPercent := 0

    cConsigPd := aCodFol[1857,1]

    If !Empty(cConsigPd)
        aEval(aPD, { |X| SomaInc(X, 38, @nSoma, Nil, Nil, Nil, Nil, Nil, Nil, aCodFol)})
    
        nVlPercent := RetValSRV(cConsigPd, cFilAnt, "RV_PERC") / 100
        nMargem    := nSoma * nVlPercent

        // Gera a verba para o calculo da folha
        fMatriz(cConsigPd, nMargem) // Realiza a gravacao de mais uma linha no array de verbas(aPd).
    EndIf
Return

/*/{Protheus.doc} function fLimECons
Limita desconto do e-Consignado
@author  Leandro Drumond
@since   25/03/2025
@version 1.0
/*/
Function fLimECons(cPdLiq)
Local aCodBenef 	:= {}
Local cPdDed		:= ""
Local cPdAdi		:= ""
Local nMargem     	:= 0
Local nSaldo        := 0
Local nEmpTot       := 0
Local nPosLiq       := 0
Local nPosIns       := 0
Local nValProv      := 0
Local nX 		  	:= 0
Local nSaldoAux     := 0
Local nMargemAux    := 0
Local nPosArred     := 0
Local nLiqAux       := 0
Local nValArNew	    := 0
Local nTemEConsig 	:= 0
Local nLiqObrig     := 0
Local nProvAdi      := 0
Local lTemProvF 	:= !Empty(aCodFol[1973,1])
Local lTemProvA     := !Empty(aCodFol[1975,1])
Local lTemDescF     := !Empty(aCodFol[1972,1])
Local lTemArred     := !Empty(aCodFol[43, 1])

DEFAULT __lMemCalc 	:= (cPaisLoc == "BRA" .And. fMemCalc())
DEFAULT cPdLiq      := aCodfol[47,1]

aScan(aPd, {|x| If(RetValSRV(x[1],SRA->RA_FILIAL,"RV_NATUREZ") == "9253" .and. x[9] <> 'D', nTemEConsig++, Nil)})

If nTemEConsig > 0 .and. P_PERECONS > 0

	If nTemEConsig > 1 //Ajustar ordem do aPd para deixar os consignados mais antigos na frente 
		fOrdConsPd(@aPd)		
	EndIf

	cPdDed := aCodFol[64,1] + "/" + aCodFol[66,1] + "/" //INSS e IRRF

	If cTipoRot <> "4"
		aEval(aPd, {|X| SomaInc(X, 4, @nMargem, 11, "N", 12, "N",,, aCodfol)})
	Else
		aEval(aPd, {|X| SomaInc(X, 4, @nMargem,,,,,,, aCodfol)})
		cPdDed += aCodfol[65,1] + "/" + aCodFol[67,1] + "/" + aCodFol[70,1] + "/" + aCodFol[71,1] + "/" //INSS e IR de férias e 13º
	EndIf

	fBusCadBenef(@aCodBenef, If(cRot == fGetCalcRot("4"), fGetCalcRot("1"),cRot),,.T., SRA->RA_FILIAL, SRA->RA_MAT)

	For nX := 1 To Len(aCodBenef)
		cPdDed += aCodBenef[nX,1] + "/" //Verbas de pensão alimentica
	Next nX

	cPdDed += P_DEDCONS
	cPdAdi += P_ADICONS

	//Subtrai as verbas de INSS, IR, Pensão Alimenticia e as definidas no mnemônico P_DEDCONS para calcular o limite do desconto do eConsignado
	//Soma as verbas definidas no mnemônico P_ADICONS
	//Soma a verba de Provisão de empréstimo nas férias e adiantamento, e desconta a provisão mês seguinte para posterior uitlização
	aEval(aPd, {|x|; 
    	If(x[1] $ cPdDed .and. x[9] <> 'D' .and. x[5] > 0,; 
        	nMargem -= x[5],; 
    	If(x[1] $ cPdAdi .And. x[9] <> 'D' .and. x[5] > 0,; 
        	nMargem += x[5],; 
    	If(lTemProvF .and. cTipoRot == "4" .and. x[1] == aCodFol[1973,1] .and. x[9] <> 'D' .and. x[5] > 0,; 
        	nValProv += x[5],; 
		If(lTemProvA .and. cTipoRot == "4" .and. x[1] == aCodFol[1975,1] .and. x[9] <> 'D' .and. x[5] > 0,; 
		 	nProvAdi += x[5],;
    	If(lTemDescF .And. cTipoRot == "4" .and. x[1] == aCodFol[1972,1] .And. x[9] <> 'D',; 
        	nValProv -= x[5], Nil)))));
	})

	//Irá gerar apenas se for rescisão, para folha as verbas serão geradas na fCarmvto()
	//Gera verba 1976 com os valores provisionados nas férias no mês para uso na contabilização
	If !Empty(aCodFol[1976, 1]) .And. nValProv > 0
		fMatriz(aCodFol[1976, 1], nValProv)
	EndIf 

	//Gera verba 1977 com os valores provisionados no adiantamento para uso na contabilização
	If !Empty(aCodFol[1977, 1]) .And. nProvAdi > 0
		fMatriz(aCodFol[1977, 1], nProvAdi)
	EndIf 

	nValProv  += nProvAdi
	nPosLiq   := aScan(aPd, { |X| x[1] == cPdLiq .and. x[9] <> "D"})
	nPosIns   := aScan(aPd, { |X| x[1] == aCodfol[45, 1] .and. x[9] <> "D"})
    nPosArred := aScan(aPd, { |X| x[1] == aCodfol[43, 1] .and. x[9] <> "D"})
	nLiqAux   := If(nPosLiq > 0, aPd[nPosLiq, 5], 0)

	//Se tem insuficiência e líquido indica que tem pagamento obrigatório, logo, os valores de líquido e insuficiência podem ser reajustados 
	If nPosIns > 0 .And. nPosLiq > 0
		nLiqObrig := aPd[nPosLiq, 5]
		aPd[nPosLiq, 5] -= nLiqObrig
	EndIf 

	If __lMemCalc 
		fAddMemLog("Margem Consignável = R$ " + AllTrim(Transform( nMargem, "@E 999,999,999,999.99" )), 1, 4)
		fAddMemLog("Percentual máximo de desconto em relação a margem = " + AllTrim(cValToChar(P_PERECONS)), 1, 4)
		fAddMemLog("Desconto Máximo do eConsignado = R$ " + AllTrim(Transform( nMargem * P_PERECONS / 100, "@E 999,999,999,999.99" )), 1, 4)
	EndIf

	nMargemAux := nMargem := Max(nMargem,0)
	nMargem    := Round(nMargem * P_PERECONS / 100, 2)

	For nX := 1 to Len(aPd)
		If RetValSRV(aPd[nX,1],SRA->RA_FILIAL,"RV_NATUREZ") == "9253" .and. aPd[nX,9] <> 'D' .and. aPd[nX,5] > 0 
			If aPd[nX,5] > nMargem
				nSaldo 	   := aPd[nX,5] - nMargem
				nSaldoAux  += nSaldo
				aPd[nX,5]  := nMargem 
				nMargem    := 0
				aPd[nX,20] := nMargemAux
				If(nPosLiq > 0, aPd[nPosLiq,5] += nSaldo, Nil)
			Else 
				nMargem -= aPd[nX,5]
			EndIf
			nEmpTot += aPd[nX,5]  
			If aPd[nX, 5] <= 0
				aPd[nX, 9] := "D"
			EndIf
		EndIf
	Next nX

	//Caso o empréstimo seja limitado pode ser que volte a ter líquido, nesse caso cria o líquido, o arredondamento e deleta a insuficiência,
	//ou então, mesmo limitado ainda continua com insuficiência, nesse caso atualiza a insuficiência
	If nPosIns > 0 .And. nPosLiq == 0 
		If nSaldoAux - aPd[nPosIns, 5] > 0
			nLiqAux := 0
			If nValArred > 0 .And. lTemArred .And. cTipoRot <> "4"
				nLiqAux := Round(nSaldoAux - aPd[nPosIns, 5], 2 ) 
				CALC_ARRE(@nLiqAux, nValArred, @nValArNew, cSemana)
				fMatriz(aCodfol[43, 1], nValArNew)
			EndIf
			fMatriz(cPdLiq, If(nLiqAux > 0, nLiqAux, nSaldoAux - aPd[nPosIns, 5]))
			aPd[nPosIns, 5] := 0
			aPd[nPosIns, 9] := "D"
		Else 
			aPd[nPosIns, 5] -= nSaldoAux  
			If(aPd[nPosIns, 5] <= 0, aPd[nPosIns, 9] := "D", Nil)
		EndIf	
	EndIf

	If nLiqObrig > 0
		If aPd[nPosIns, 5] > aPd[nPosLiq, 5]
			aPd[nPosIns, 5] -= aPd[nPosLiq, 5]
			If aPd[nPosIns, 5] >= 0
				aPd[nPosLiq, 5] := nLiqObrig
				If(aPd[nPosIns, 5] == 0, aPd[nPosIns, 9] := "D", Nil)
			EndIf 			
		Else 
			aPd[nPosLiq, 5] -= aPd[nPosIns, 5] 
			aPd[nPosLiq, 5] += nLiqObrig 
			aPd[nPosIns, 5] := 0
			aPd[nPosIns, 9] := "D"
		EndIf 
	EndIf 

	//Remonta o arredondamento e o líquido na folha quando o valor do desconto do empréstimo é alterado
	If nPosArred > 0 .And. nPosLiq > 0  .And. aPd[nPosLiq, 5] <> nLiqAux .And. cTipoRot <> "4" 
		nLiqAux := Round(aPd[nPosLiq, 5] - aPd[nPosArred, 5], 2 ) 
		CALC_ARRE(@nLiqAux, nValArred, @nValArNew, cSemana)
		If(nValArNew > 0, aPd[nPosArred, 5] := nValArNew, aPd[nPosArred, 9] := "D") 
		aPd[nPosLiq, 5] := nLiqAux
	EndIf 

	If __lMemCalc 
		fAddMemLog("Total de Descontos eConsignado = R$ " + AllTrim(Transform( nEmpTot, "@E 999,999,999,999.99" )), 1, 4)
	EndIf
EndIf

Return

/*/{Protheus.doc} function fOrdConsPd
Ordena aPd para deixar econsignados antigos na frente
@author  Leandro Drumond
@since   23/06/2025
@version 1.0
/*/
Static Function fOrdConsPd(aPd) 

Local aPdAux  := {}
Local aPosAux := {}
Local dDtAux  := CtoD("")
Local cDocAux := ""
Local cCompAux:= SubStr(cPeriodo,5,2) + SubStr(cPeriodo,1,4)
Local nX      := 0
Local nTamDoc := TamSX3("RK_DOCUMEN")[1]

DbSelectArea("RUO")
DbSetOrder(1) //RUO_FILIAL+RUO_MAT+RUO_NRCONT+RUO_COMPET+RUO_PD+RUO_BCOCON

SRK->(DbSetOrder(2)) //RK_FILIAL, RK_MAT, RK_NUMID, R_E_C_N_O_, D_E_L_E_T_

For nX := 1 to Len(aPd)
	If aPd[nX,9] <> 'D' .and. RetValSRV(aPd[nX,1],SRA->RA_FILIAL,"RV_NATUREZ") == "9253"
		dDtAux := dDataRef 
		cDocAux:= Right(aPd[nX,15],nTamDoc)
		If SRK->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + aPd[nX,15]))
			dDtAux := SRK->RK_DTMOVI 
			cDocAux := SRK->RK_DOCUMEN
			
			If RUO->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + SRK->RK_NRCONTR + cCompAux + aPd[nX,1] + SRK->RK_BCOCONS))
				dDtAux := RUO->RUO_DTINIC
			EndIf
		EndIf
		aAdd(aPosAux,{nX, DtoS(dDtAux), cDocAux})
	Else 
		aAdd(aPdAux, aClone(aPd[nX]))
	EndIf
Next nX

aSort(aPosAux,,,{|x,y| x[2]+x[3]<y[2]+y[3]})

For nX := 1 to Len(aPosAux)
	aAdd(aPdAux, aClone(aPd[aPosAux[nX,1]]))
Next nX

aPd := aClone(aPdAux)

Return Nil
