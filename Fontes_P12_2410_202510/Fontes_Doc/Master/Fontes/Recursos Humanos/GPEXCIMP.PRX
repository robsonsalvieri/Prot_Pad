#INCLUDE "GPEXCALC.CH" 
#INCLUDE "PROTHEUS.CH"

Static aTabS073
Static cFilS073
Static cRotAut
Static cRotFol
Static lTemPdSup
Static lVerMultv
Static lTemRU6
Static __lMemCalc
Static lPAcTrabDif

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³			ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.			  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data	³ FNC			 ³  Motivo da Alteracao 					³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Flavio Corre³25/02/15³PCREQ-2898        ³Inclusao fonte				 			³±±
±±³Allyson M.  ³20/02/2015³TRHKAT    	   ³Ajuste p/ apurar corretamente a diferenca³±±
±±³            ³          ³          	   ³dos valores na rescisao complementar por ³±±
±±³            ³          ³          	   ³dissidio.  				 				 ³±±
±±³Allyson M.  ³04/03/2015³TRHKQ3    	   ³Ajuste na apuracao do Id 0168 - deducao  ³±±
±±³            ³          ³          	   ³da base de IR Ferias em situacao em que  ³±±
±±³            ³          ³          	   ³houve calculo de ferias partidas e no    ³±±
±±³            ³          ³          	   ³segundo mes ha um novo calculo de ferias ³±±
±±³            ³          ³          	   ³partidas. 								 ³±±
±±³Claudinei S.³01/04/15  ³TQXON7    	   ³Criada fInssResEx() parfa verificar os     ³±±
±±³		       ³		  ³          	   ³calculos de Ir, INSS e Deduc Inss IR dos  ³±±  
±±³		       ³		  ³          	   ³Resid.Exterior, Autonomos Cooperados e MEI³±±  
±±³Claudinei S.³01/04/2015³TQXON7          ³Ajustadas as funcoes: fSalc, Calc_IR,    ³±±
±±³            ³          ³          	   ³Calc_IrRRA, fCINSS, fCINSS13, FcIR,      ³±±
±±³            ³          ³          	   ³fCIrFer, fCIR13o, fCSalc, fCalcINSSFun e ³±±
±±³            ³          ³          	   ³fCINSSAut para calcular a base de contri-³±± 
±±³            ³          ³          	   ³buicao independente do conteudo do campo ³±±
±±³            ³          ³          	   ³RA_INSSAUT, incluidas validacoes para    ³±±
±±³            ³          ³          	   ³Residentes no exterior, Autonomos        ³±±
±±³            ³          ³          	   ³Cooperados e MEI. 					      ³±±
±±³Allyson M.  ³04/03/2015³TRHKQ3    	   ³Ajuste na apuracao do Id 0168 - deducao  ³±±
±±³            ³          ³          	   ³da base de IR Ferias em situacao em que  ³±±
±±³            ³          ³          	   ³houve calculo de ferias partidas e no    ³±±
±±³            ³          ³          	   ³segundo mes ha um novo calculo de ferias ³±±
±±³            ³          ³          	   ³partidas. 								 ³±±
±±³Claudinei S.³15/05/2015³TQKKGJ          ³Inclusao do controle de INSS de ferias MS³±±
±±³            ³          ³                ³quando o MV_DINSSFM = "R".               ³±±
±±³            ³          ³				   ³quando o MV_DINSSFM = "R".               ³±±
±±³Claudinei S.³29/06/2015³TRMZGV		   ³Alterada FCalcInssFun() para calcular a  ³±±
±±³            ³          ³				   ³contribuicao adiciona SENAI quando a 	 ³±±
±±³            ³          ³				   ³empresa possuir mais de 500 funcionarios ³±±
±±³Ltrombini   ³16/07/2015³TSSYUM		   ³Alterada FCFGTS() para calcular a base de³±±
±±³            ³          ³				   ³FGTS pra funcionarios admitidos no mes 	 ³±±
±±³            ³          ³				   ³com salario Proporcional				 ³±±
±±³Renan Borges³06/08/2015³TSXNXZ          ³Ajuste para gerar o GPS utilizando o com-³±±
±±³            ³          ³                ³plemento de GPS”, parametro 15, com valor³±±
±±³            ³          ³                ³de compensação de GPS se o centro custo  ³±±
±±³            ³          ³                ³ficar branco e houver filtro de c.custo  ³±±
±±³Flavio Corr ³24/08/2015³TTCGFZ          ³Correção na geração do id 232-INSS Fer.MS³±±
±±³M. Silveira/³05/09/2015³TSGD48          ³Ajuste na fCSalC p/nao calcular a base do³±±
±±³Leandro Dr. ³          ³                ³INSS quando o cpo RA_INSSAUT estiver com ³±±
±±³            ³          ³                ³valor "Nao".                             ³±±
±±³            ³          ³                ³Ajustes na fCIr e fCfgts para correcoes  ³±±
±±³            ³          ³                ³do Piloto TV Tribuna.                    ³±±
±±³Allyson M.  ³10/09/2015³TSZ732    	   ³Ajuste em fCfgts() na proporcionalizacao ³±±
±±³            ³          ³          	   ³da base de FGTS							 ³±±
±±³Allyson M.  ³20/10/2015³TTPYFZ    	   ³Ajuste em fGPSVal() p/ tratar ambos tipos³±±
±±³            ³          ³          	   ³de contrato na SEFIP					 ³±±
±±³            ³          ³        		   ³Ajuste em fCInssAut() p/ verificar corre-³±±
±±³            ³          ³        		   ³tamente o maximo de desconto de INSS     ³±±
±±³            ³          ³          	   ³quando ja houve desconto em outra empresa³±±
±±³Christiane V³29/10/2015³TTPXCT          ³Ajuste em fCSalC() p/ gerar base de cálc.³±±
±±³            ³          ³                ³para autônomo MEI                        ³±±
±±³M. Silveira ³10/12/2015³TTXUZU          ³Ajuste na fCIr13o p/ na resc.complementar³±±
±±³            ³          ³                ³compor o IR considerando as bases e os   ³±±
±±³            ³          ³                ³valores de rescisoes anteriores.         ³±±
±±³Allyson M.  ³14/12/2015³TUAI32    	   ³Ajuste em fCfgts() p/ o cálculo do FGTS  ³±±
±±³            ³          ³          	   ³quando ha afastamento  					 ³±±
±±³Allyson M.  ³29/12/2015³TUCRG2   	   ³Ajuste em fCIr() p/ considerar os Ids    ³±±
±±³            ³          ³          	   ³0106 e 0107 no calculo de rescisao quando³±±
±±³            ³          ³          	   ³nao tem data de referencia (verba oriunda³±±
±±³            ³          ³          	   ³do roteiro ADI)							 ³±±
±±³Raquel Hager³06/01/2016³TUDIMC   	   ³Ajuste para considerar complementar nas  ³±±
±±³            ³          ³          	   ³bases de cálculo de Encargos.			 ³±±
±±³Raquel Hager³14/01/2016³TUDTZD   	   ³Ajuste para não atualizar para DELETADA  ³±±
±±³            ³          ³          	   ³verbas informadas pelo usuario.			 ³±±
±±³Allyson M.  ³22/01/2016³TUDHS0    	   ³Ajuste em fCInss(), fCIr() efCfgts() p/  ³±±
±±³            ³          ³          	   ³situacao no calculo de dissidio que ha 	 ³±±
±±³            ³          ³          	   ³geracao da diferenca de ferias de calculo³±±
±±³            ³          ³          	   ³iniciado no periodo anterior e verbas de ³±±
±±³            ³          ³          	   ³ferias nao estao no acumulados.          ³±±
±±³Allyson M   ³04/02/2016³TUJLEI          ³Ajuste em fcIr13o() p/ somente verificar ³±±
±±³            ³          ³                ³o IR da rescisao anterior quando for o   ³±±
±±³            ³          ³                ³recalculo da rescisao  	 				 ³±±
±±³Allyson M.  ³05/02/2016³TUJCHW    	   ³Retirado o ajuste do dia 29/12    	     ³±±
±±ºRenan Borges³05/04/2016³TUP601          ³Ajuste para abater o valor de % de salá- ³±±
±±º            ³          ³                ³rio educação corretamente do valor de ter³±±
±±º            ³          ³                ³ceiros. Ajuste para validar o cadastro de³±±
±±º            ³          ³                ³tipo de aviso previo corretamente de acor³±±
±±º            ³          ³                ³do com os periodos ativos. Ajuste para   ³±±
±±º            ³          ³                ³utilizar o mnemonico P_CHKDTHOM  ao reali³±±
±±º            ³          ³                ³zar o calculo de rescisão.               ³±±
±±ºRenan Borges³05/05/2016³TVBDCV          ³Ajuste para quando possuir uma verba de  ³±±
±±º            ³          ³                ³PLR na rescisão seja calculada a base de ³±±
±±º            ³          ³                ³IR sem utilizar a data de referencia do  ³±±
±±º            ³          ³                ³sindicato e sim da demissão.             ³±±
±±ºRaquel Hager³24/05/2016³TVBAMG          ³Ajuste para alimentar mnemonico NALQIRADT³±±
±±º            ³          ³                ³- Percentual IR Adiantamento.            ³±±
±±ºRenan Borges³03/06/2016³TVFYT9          ³Ajuste para gerar SEFIP corretamente quan³±±
±±º            ³          ³                ³do tentar gerar para uma filial que não  ³±±
±±º            ³          ³                ³possui registros na tabela S035.         ³±±
±±ºAllyson M   ³30/06/2016³TVFXPQ          ³Ajuste em fCInss() p/ verificar correta- ³±±
±±º            ³          ³                ³mente os dias de ferias no mês  		 ³±±
±±ºClaudinei S.³08/07/2016³TVP136/TUQEKD   ³Ajustada a função fInssResEx para identi-³±±
±±º            ³          ³                ³ficar os funcionários que estão no PPE   ³±±
±±º            ³          ³                ³Programa de Proteção ao Emprego.         ³±±
±±º            ³          ³                ³Merge da 12.1.12.                        ³±±
±±ºMatheus M   ³13/07/2016³TVIJX0          ³Ajuste para gerar os itens 12 e 21 quando³±±
±±º            ³          ³                ³o tipo de contrato for determinado ou    ³±±
±±º            ³          ³                ³indeterminado.						     ³±±
±±ºAllyson M   ³29/07/2016³TVLPAL          ³Ajuste em fCfgts() p/ verificar os valor ³±±
±±º            ³          ³                ³dos adicionais na base quando ha dias de ³±±
±±º            ³          ³                ³FGTS p/ pagamento, caso não incorporem   ³±±
±±ºAllyson M   ³02/08/2016³TVRC14          ³Ajuste em FCalcIRLucro() p/ calculo de IR³±±
±±º            ³          ³                ³correto na rescisão, que já vem  com o   ³±±
±±º            ³          ³                ³valor do IR de folha carregado   		 ³±±
±±ºAllyson M   ³26/08/2016³TVRUMR          ³Ajuste em fInssEmp() p/ validar a falta  ³±±
±±º            ³          ³                ³de preenchimento das tabelas S037 e S038 ³±±
±±³Allyson M.  ³30/08/2016³TVLMEZ          ³Ajuste em fCInss() p/ evitar geracao de  ³±±
±±³            ³          ³        		   ³INSS de folha e, consequentemente, insu- ³±±
±±³            ³          ³        		   ³ficiencia de saldo quando funcionario    ³±±
±±³            ³          ³        		   ³esta os 30 dias do mes de ferias		 ³±±
±±|Claudinei S.|30/11/2016|MRH-1469        |Ajustada fCalcInssFun() para considerar  |±±
±±|            |          |TUQEAR          |as empresas que deixaram a desoneração.  ³±±
±±³Raquel Hager³23/11/2016³TWMEM4          ³Ajuste em fInssEmp() o % SENAI 500 para  ³±±
±±³            ³          ³137831          ³considerar o %SENAI, antes estava fazendo³±±
±±³            ³          ³                ³a divisão sempre por 100.                ³±±
±±ºJônatas A.  ³24/11/2016³172168          ³Ajuste para considerar corretamente os   ³±±
±±º            ³          ³                ³tipos de afastamento que não abatem avos ³±±
±±º            ³          ³                ³da base de FGTS do 130.                  ³±±
±±ºJônatas A.  ³24/11/2016³172168          ³Ajuste p/ gerar FGTS para funcionário    ³±±
±±º            ³          ³                ³afastado durante todo o ano.             ³±±
±±³Renan Borges³14/12/2016³MRH-2445   	   ³Ajuste para que o calculo do dissidio re-³±±
±±³			   ³          ³          	   ³troativo considere a diferença de férias ³±±
±±³			   ³          ³          	   ³já pagas no calculo da folha.            ³±±
±±³Renan Borges³21/12/2016³MRH-2564   	   ³Ajuste para preenche o campo RR_NUMID cor³±±
±±³			   ³          ³          	   ³retamente ao realizar o calculo da resci-³±±
±±³			   ³          ³          	   ³são possuindo um periodo que será pago.  ³±±
±±³Gustavo M.  ³21/12/2016³MRH-438	   	   ³Ajuste na performance ao ter muitos reg. ³±±
±±³			   ³          ³          	   ³na RCC.									 ³±±
±±ºAllyson M   ³27/12/2016³MRH-3264        ³Ajuste em fCalcInssFun() p/ utilizar a   ³±±
±±º            ³          ³                ³data do período de cálculo do dissídio ao³±±
±±º            ³          ³                ³invés da database do sistema.			 ³±±
±±ºGabriel A.  ³27/12/2016³MRH-3015        ³Ajuste para o cálculo do INSS de férias  ³±±
±±º            ³          ³                ³na folha para MULTV.                     ³±±
±±³Allyson M.  ³16/01/2017³MRH-1182        ³Ajuste em fEncarCC() p/ quando for o id  ³±±
±±³            ³		  ³				   ³de líquido da folha não efetuar o rateio ³±±
±±³            ³		  ³				   ³de acordo com o %; será verificado os    ³±±
±±³            ³		  ³				   ³proventos e descontos					 ³±±
±±³Raquel Hager³18/01/2017³MRH-4927        ³Remoção de ajuste indevido na função     ³±±
±±³            ³		  ³				   ³fcInss13.                                ³±±
±±³Raquel Hager³18/01/2017³MRH-4891        ³Ajuste na função fcInss para considerar  ³±±
±±³            ³		  ³				   ³posição 4-RV_INNS na somatoria da base de³±±
±±³            ³		  ³				   ³cálculo de INSS de Férias.               ³±±
±±³Allyson M.  ³19/01/2017³MRH-4377        ³Ajuste em FBaseIni() p/ considerar verbas³±±
±±³            ³		  ³				   ³informadas 								 ³±±
±±³Allyson M   ³20/01/2017³MRH-5109        ³Ajuste em fCalcInssFun() p/ calcular INSS³±±
±±³            ³          ³      		   ³da empresa quando há desoneração e com-  ³±±
±±³            ³          ³      		   ³plementar de dissídio					 ³±±
±±³Renan Borges³23/01/2017³MRH-3753   	   ³Ajuste para calcular diferença de férias ³±±
±±³			   ³          ³          	   ³corretamente quando já houver diferença  ³±±
±±³			   ³          ³          	   ³de férias lançadas da folha do mes ante- ³±±
±±³			   ³          ³          	   ³rior.                                    ³±±
±±³Allyson M   ³24/01/2017³MRH-4639        ³Ajuste em fGpsVal() p/ executar um 'For' ³±±
±±³            ³          ³      		   ³ao invés de fTabela() p/ performance     ³±±
±±³João Balbino³27/01/2017³MPRIMESP-578    ³Ajuste em fCINSS13 p/ não gerar desconto ³±±
±±³            ³          ³      		   ³de INSS para func. Demitido.             ³±±
±±³Allyson M   ³03/02/2017³MRH-5876        ³Ajuste na fCInss para tratar o ID 1412   ³±±
±±³            ³          ³ 		       ³que trata da devolucao do Inss.          ³±±
±±ºGabriel A.  ³03/02/2017³MRH-5965        ³Ajuste para considerar a porcentagem das ³±±
±±º            ³          ³                ³outras entidades quando a de terceiros   ³±±
±±º            ³          ³                ³estiver zerada no cálculo da provisão.   ³±±
±±³Renan Borges³06/02/2017³MRH-1423   	   ³Ajusta para gerar a base de FGTS correta-³±±
±±³			   ³          ³          	   ³mente quando houver afastamento e dias   ³±±
±±³			   ³          ³          	   ³trabalhados no mes.                      ³±±
±±³Allyson M.  ³21/02/2017³MRH-7351        ³Ajuste em FBaseIni() p/ considerar verbas³±±
±±³            ³		  ³				   ³informadas sem ser a de ID 0006			 ³±±
±±³Jônatas A.  ³10/04/2017³DRHPAG-39       ³Ajuste em fGPSVal() p/ incluir código da ³±±
±±³            ³		  ³				   ³verba na chave de busca do array aGPSVal.³±±
±±³Eduardo K.  ³18/04/2017³MPRIMESP-9382   ³Ajuste na proporcionalização de Inss de  ³±±
±±³            ³		  ³				   ³ Ferias e Salario.						 ³±±
±±³Cecilia Car.³24/05/2017³DRHPAG-1474³Ajuste na composicao da base do IR PLR qdo ha ³±±
±±³            ³		  ³				   ³adiantamento calculado no Regime de Caixa³±±
±±³Tiago B.    ³19/07/2017³MPRIMESP-10402  ³ajuste em FCalcIRLucro e Calc_IrPLR para ³±±
±±³            ³		  ³				   ³correto calculo do IRRF no pgto de PLR.  ³±±
±±ºGabriel A.  ³18/08/2017³DRHPAG-4995     ³Ajuste para alimentar a variável         ³±±
±±º            ³          ³                ³lTetoINSS quando o teto do INSS for      ³±±
±±º            ³          ³                ³ultrapassado só com o valor do INSS de   ³±±
±±º            ³          ³                ³férias.                                  ³±±
±±³Eduardo K.  ³17/08/2017³MPRIMESP-11090  ³ajuste em fCIrfer para nao calcular Ir   ³±±
±±³            ³		  ³				   ³ferias para expatriado de acordo c/ hist.³±±
±±³            ³		  ³				   ³de contrato.							 ³±±
±±³Cícero Alves³01/09/2017³DRHPAG-256	   ³Ajustada a fInssResEx() para atribuir ao ³±±
±±³			   ³		  ³				   ³Mnemonico lEncPatro o conteudo do campo  ³±±
±±³			   ³		  ³				   ³RGE_ENCARG(Encargos Sociais Res.Exterior)³±±
±±ºGabriel A.  ³11/09/2017³DRHPAG-5367     ³Implementação de folha complementar para ³±±
±±º            ³          ³                ³múltiplos vínculos.                      ³±±
±±³Eduardo K.  ³18/04/2017³MPRIMESP-9894   ³Ajuste no calculo de INSS Férias quando  ³±±
±±³            ³		  ³				   ³há aumento salarial no período de gozo.  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCalcIrLuc³ Autor ³ Equipe Rh             ³ Data ³10/01/96  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Ir Distr. Lucro                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCalcIrLucro(aCodFol,cSemana,lDep)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FCalcIRLucro(aCodFol,cSem,lDep)

Local aCodBenef := {}
Local aPdAux    := aClone(aPdAcum)
Local cVerbas	:= ""
Local nAliq     := 0
Local nValPePLR := 0
Local nCntP		:= 0
Local nIR_BFol	:= nIR_B
Local nPosP		:= 0
Local nPosRed	:= 0
Local nValDepLr	:= 0.00
Local nValPLRAnt:= 0.00
Local cAnoIR   	:= StrZero(Year(DDATA_PGTO),4)
Local cDtPLR	:= If( (cTipoRot <> "F" .And. !(cTipoRot =='4' .and. ccompl == 'S' .and. Year(ddatadem) <> Year(GetMemVar("RG_DATAHOM"))) ), Alltrim(Str(Ano(dDataDe))) , If(!Empty(aSind) , aSind[1,8] , Substr(CANOMES,1,4) ) ) //Na Rescisão
Local dDtPlr	:= If((cTipoRot <> "F" .And. !(cTipoRot =='4' .and. ccompl == 'S' .and. Year(ddatadem ) <> Year(GetMemVar("RG_DATAHOM"))) ) , DDATAATE , StoD(cDtPLR+"0101") )
Local dDataHom  := cTod("")
Local lIrNeg	:= Len(aCodFol) >= 1726 .And. !Empty(aCodFol[1726,1]) .And. !Empty(aCodFol[1727,1]) 
Local lRvCpoPlr	:= SRV->(Columnpos("RV_REFPLR") > 0)
Local aPensAnt	:= {}
Local nValPenAnt:= 0

DEFAULT lTemRU6 := AliasInDic("RU6")
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

cSem := If (cSem == Nil ,cSemana,cSem)
nIR_B:= 0

If aCodfol[151,1] # Space(3) .And. aCodFol[152,1] # Space(03) .And.;
 	( Ascan(aPd, { |X| X[1] == aCodfol[151,1] .And. X[9] # "D" .And. X[5] > 0}) > 0 ) //Só procura se houver pagamento de PLR no mes.
	If cTipoRot <> "F" //PLR No Roteiro de Rescisão Não utiliza o Sindicato
		If Empty(aTabIrPlr)
			CarIrPlr(@aTabIrPlr,MesAno(dDataDe))
		EndIf
		cVerbas := aCodFol[151,1]+"/"+aCodFol[152,1] + "/" + P_PDBIRPLR
		If Empty(aPdAcum)
			//Busca pela data de pagamento e altera a data do aPdAcum para ficar de acordo com o ano de referencia do PLR
			aPdAcum := fBuscaAcmPer(cVerbas, "", "V", , , cDtPLR+"01", cDtPLR+"12",,,,.T.,.F.,cDtPLR+"0101",cDtPLR+"1231") //Busca pela data de pagamento
			aEval(aPdAcum, {|x| If(cTipoRot == "4" .and. SubStr(x[4],1,4) <> cDtPLR, x[4] := cDtPLR + SubStr(x[4],5,2), Nil)})
		EndIf
		If Empty(aPdAcum)
			aPdAcum := {}
		EndIf		
		fChkPLRAnt(Nil,aPdAcum,Nil,@nValPLRAnt,cDtPLR)
	EndIf
	If !Empty(aTabIrPlr)
		nPos := Ascan(aPd, { |X| X[1] = aCodfol[835,1] .And. X[3] = cSem .And. X[9] # "D"})
		
		If nPos > 0
			nIr_b := aPd[nPos,5]
		Else
			If __lMemCalc			
				fAddMemLog("Verbas com incidência para IR PLR:", 1, 2)					
			EndIf
			Aeval( aPd ,{ |X| If(cTipoRot != "4" .Or. ( (Empty(x[10]) .Or. Year(x[10]) == Year(ddatadem) .Or. (cCompl == "S" .and. Year(ddatadem) <> Year(GetMemVar("RG_DATAHOM")))) .and. (!lRvCpoPlr .or. x[1] == aCodFol[151,1] .or. RetValSRV(x[1], SRA->RA_FILIAL, 'RV_REFPLR') == "S") ), SomaInc(X,5,@nIR_B,11,"N",12,"N",,.F.,aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.), Nil) })
			nIr_b += nValPLRAnt
			If !lRvCpoPlr .or. cTipoRot != "4"
				nIr_b -= nIR_BFol
			EndIf
			If cTipoRot == "4" .and. !lRvCpoPlr .and. RetValSRV(aCodFol[006,1],SRA->RA_FILIAL,"RV_IR") == "S"
				dDataHom := GetMemVar("RG_DATAHOM")
				//-- Procura Base de Ir Adto.
				nPos := Ascan(aPD,{ |X| X[1] == aCodFol[010,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10])})
				If nPos > 0
					Aeval(aPd,{ |X| nIr_b += If ( X[1]==aCodFol[010,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]),X[5],0) })
				Else
					//-- Procura Base de Ir Mes Anterior
					Aeval(aPd,{ |X| nIr_b += If ( X[1]==aCodFol[106,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]),X[5],0) })
					If lIrNeg
						Aeval(aPd,{ |X| nIr_b -= If ( X[1]==aCodFol[1727,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]),X[5],0) })
					EndIf
				EndIf
				//-- Se encontrado o redutor, soma-o novamente na base de IR
				nPos := Ascan(aPD,{ |X| X[1] == aCodFol[408,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10])})
				If nPos > 0
					nIr_b += aPd[nPos,5]
				EndIf
			EndIf			
		EndIf
		
		If nIR_B > 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Busca os codigos de pensao definidos no cadastro beneficiario³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			fBusCadBenef(@aCodBenef)
			
			nValPePLR := 0
			cVerbas := ""
			For nCntP := 1 To Len(aCodBenef)
				nPosP := Ascan(aPD , { |X| X[1] == aCodBenef[nCntP,8] .And. X[9] # "D" })
				
				If nPosP > 0 
					cVerbas += aPd[nPosP,1]+"/"
					If RetValSRV(aPd[nPosP,1], SRA->RA_FILIAL,"RV_IR") == "N"
						nValPePLR += aPd[nPosP,5]
					EndIf
				EndIf
			Next nCntP

			If !Empty(cVerbas)
				aPensAnt := fBuscaAcmPer(cVerbas, "", "V", , , cAnoIR+"01", cAnoIR+"12", ,, , .T. , .F.  )
				aEval(aPensAnt, {|x| nValPenAnt += x[3] } )				
				nIr_b -= nValPenAnt
			EndIf
			
			nIr   := 0.00
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Redutor da base de IR na participacao dos lucros             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPosRed := Ascan(aPd, { |X| X[1] = aCodfol[411,1] .And. X[3] = cSem .And. X[9] # "D"})
			If nPosRed > 0
				nIr_b := Max( nIr_b - aPd[nPosRed,5], 0 )
			EndIf
			
			If cTipoRot == "F" .And. nValPLRAnt == 0
				//Verifica se houve pagamento de PLR no ano atual referente ao ano anterior
				cVerbas := aCodFol[151,1]+"/"+aCodFol[152,1] + "/" + aCodFol[1279,1]+"/" + P_PDBIRPLR
				aPdAcum := {}
				//Busca verbas pelo RD_DATPGT
				aPdAcum  := fBuscaAcmPer(cVerbas, "", "V", , , cAnoIR+"01", cAnoIR+"12",,,,.T.,.F.,cAnoIR+"0101",cAnoIR+"1231")
				aEval(aPdAcum, {|x| x[4] := cAnoIR + SubStr(x[4],5,2)}) //Altera período para ficar igual o ano de pagamento 
				If !Empty(aPdAcum)
					fChkPLRAnt(Nil,aPdAcum,Nil,@nValPLRAnt,cAnoIR)
					nIr_b += nValPLRAnt

					If ( nPosRed := Ascan(aPdAcum, { |X| X[1] = aCodfol[1279,1] }) ) > 0
						nIr_b -= aPdAcum[nPosRed,3] //Subtrai o total da primeira parcela do PLR do ano anterior se este foi pago no ano atual.
						//Isto deve ser feito pois o valor da PLR é a soma das duas parcelas, caso as duas parcelas tenham sido pagas no ano atual, o valor da primeira já estará somada na base.
					EndIf
				EndIf
			Endif
			
			Calc_IrPLR(nIr_B , nValPePLR, @nIr , 0 ,@nValDepLr,, aTabIrPlr,,@nAliq,aCodFol)

			aPdAcum := aClone(aPdAux)
	        //Guarda o valor da base na variavel referente base IR de adiantamento
			BASE_INI := nIr_B
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gerar Ir Dist. Lucro										 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTipoRot == "4" .And. cCompl == "S"
				If (nPos := Ascan(aPd, { |X| X[1] = aCodfol[152,1] .And. X[3] = cSem .And. X[9] # "D" .And. x[5] == 0})) > 0
					aPd[nPos,9] := "D"
				EndIf
			EndIf
			FMatriz(aCodfol[152,1],nIr,nAliq,cSem,,,If(cTipoRot=="F","A",NIL),,,,,,,,,,,,dDtPlr)
			If __lMemCalc			
				fAddMemLog("Valor do desconto do IR: R$ " + AllTrim(Transform( nIr, "@E 999,999,999,999.99" )), 1, 2)					
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gerar Base Ir Dist. Lucro									 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			FMatriz(aCodfol[835,1],nIr_B,,cSem,,,If(cTipoRot=="F","A",NIL),,,,,,,,,,,,dDtPlr)
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gerar Base Ir Primeira Parcela								 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If IRPLRANT > 0
				FMatriz(aCodfol[1328,1],IRPLRANT,,cSem,,,If(cTipoRot=="F","A",NIL),,,,,,,,,,,,dDtPlr)
			EndIf
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gerar Ded.Dep. Distr. Lucro.								 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If aCodFol[300,1] # Space(3)  .and. lDep
				FMatriz(aCodfol[300,1],nValDepLr,Val(SRA->RA_DEPIR),cSem,,,,,,,,,,,,,,,dDtPlr)
				//Zera o valor da variavel de dependente folha pois o valor do dependente
				//sera pago na verba de PLR.
				VAL_DEDDEP := 0
				If lTemRU6 .AND. nValDepLr > 0
					fGrvDepIr(Val(SRA->RA_DEPIR), nValDepLr, "5",, If( cTipoRot == "4", GetMemVar("RG_DATAHOM"), NIL))
				EndIf
			EndIf			
		EndIf
	EndIf
EndIf      

If Empty(aTabIrPlr)
	If aCodfol[151,1] # Space(3) .And. (nPos := Ascan(aPd, { |X| X[1] = aCodfol[151,1] .And. X[3] = cSem .And. X[9] # "D"}) > 0 )
		If GetRemoteType() == -1
			MsgLogGrid( Ap5GetHelp("IRPLR"), .F. ) // Retornar string da funcao Help
		Else
			If IsInCallStack( "EXECROT" ) //Se estiver executando roteiro de calculo
				AddLogExecRot( Ap5GetHelp("IRPLR") )
			Else 
				Help(" ",1,"IRPLR")
			EndIf		
		EndIf     
	EndIf
EndIf     

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FInssEmp ³ Autor ³ Mauro                 ³ Data ³ 06/09/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carregar o Parametro Inss Empresa.                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ FInssEmp(cFilial,aInssEmp,lDeducao,cAnoMes)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fInssEmp(cFil,aInssEmp,lDeducao,cAnoMes,lCodEve,lCarTab,lTabMesOld,aDedTer)

Local aArea			:= GetArea()
Local cTab			:= "S037"
Local nDed			:= 0
Local n     		:= 0
Local nPosTab		:= 0
Local dDataRef		:= CtoD("")
Local lProvisao     := IsInCallStack("GPEM070") .or. IsInCallStack("GPM070GRD")
Local nPerTeProv    := 0
Local nX     		:= 0
Local aTipoContr	:= {}
Local lACodFol		:= Type("aCodFol") == "A"

DEFAULT cAnoMes		:= AnoMes(dDataAte) //Ultimo dia do periodo de calculo
DEFAULT lCodEve		:= .F.
DEFAULT lCarTab		:= .F.
DEFAULT lTabMesOld  := .F.
DEFAULT aDedTer     := {}

dDataRef := Stod(cAnoMes+"01")

lDeducao   := If (lDeducao == Nil , .T. , lDeducao)

//-Array aInssEmp
//-[1] % Empresa    - [2] % Terceiros    - [3] % Acidente    - [4] % Fgts
//-[5] % Prov. 13o. - [6] % Prov. Ferias 
//-[9] % Sal.Educ.  - [10]% Incra        - [11]% Senai       - [12]% Sesi
//-[13]% Senac      - [14]% Sesc         - [15]% Sebrae      - [16]% Dpc
//-[17]% Faer       - [18]% Senar        - [19]% Seconc      - [20]% Prov.Resc
//-[21]% Ac.Trb.Cc  - [22]% Sest         - [23]% Senat       - [24] Cod. Pgto. GPS
//-[25] Cod. Terceiros -[26]% Sescoop    - [27]Rec.Fat.      - [28] Vlr Min. Recol.GPS                     
//-[29]% Rat			- [30]% Adic.SENAI  - [31]Sub Patronal 
                       
aInssEmp := Array( 34, 2 )

For n := 1 To Len(aInssEmp)
	If n==24 .or. n==25 .or. n==27
		aInssEmp[n,1] := ""
		aInssEmp[n,2] := ""	
	Else 
		aInssEmp[n,1] := 0.00000
		aInssEmp[n,2] := 0.00000 
	EndIf 
Next n

//--TABELA S037 - ENCARGOS EMPRESAS
//--PARA GERAR O EVENTO S-1020 DO ESOCIAL, NÃO PRECISA CONSIDERAR OS VALORES DA S037, MAS SOMENTE DA S038.
If !lCodEve
	nPosTab := fPosTab( cTab,cAnoMes,"==",2,"1","==",4,Nil,Nil,Nil,lCarTab,cFil,Nil,Nil,Nil,dDataRef) //Tipo de contrato 1

	If nPosTab == 0
		nPosTab := fPosTab(cTab, Space(6), "==",2,"1","==",4,Nil,Nil,Nil,Nil,cFil,Nil,Nil,Nil,dDataRef)
	EndIf

	If nPosTab > 0 .And. !lTabMesOld
		aInssEmp[01,1] 	:= 	fTabela(cTab,nPosTab,5,dDataRef,cFil)/100    	//Empresa
		aInssEmp[03,1] 	:= 	fTabela(cTab,nPosTab,6,dDataRef,cFil)/100    	//Acidente
		aInssEmp[29,1]	:= 	fTabela(cTab,nPosTab,7,dDataRef,cFil)/100    	//RAT
		aInssEmp[04,1] 	:= 	fTabela(cTab,nPosTab,8,dDataRef,cFil)/100   	//Fgts
		aInssEmp[27,1]	:= 	fTabela(cTab,nPosTab,9,dDataRef,cFil)			//Recolhe s. faturamento
		aInssEmp[24,1]	:=  fTabela(cTab,nPosTab,11,dDataRef,cFil)			//Cod. de Pgto. GPS
		aInssEmp[28,1] 	:=  fTabela(cTab,nPosTab,12,dDataRef,cFil)		    //Vlr. minimo da GPS
		aInssEmp[05,1] 	:=  fTabela(cTab,nPosTab,14,dDataRef,cFil)/100   	//Prov 13
		aInssEmp[06,1] 	:=  fTabela(cTab,nPosTab,15,dDataRef,cFil)/100  	//Prov Ferias 	
		aInssEmp[20,1]	:=  fTabela(cTab,nPosTab,16,dDataRef,cFil)/100   	//Prov Rescisao
		aInssEmp[31,1]	:=  fTabela(cTab,nPosTab,17,dDataRef,cFil)   		//Sub Patronal
		aInssEmp[32,1]	:=  fTabela(cTab,nPosTab,18,dDataRef,cFil)   		//Alíquota sobre folha desonerada
		aInssEmp[33,1]	:=  fTabela(cTab,nPosTab,19,dDataRef,cFil)   		//Alíquota sobre receita
		aInssEmp[34,1]	:=  fTabela(cTab,nPosTab,20,dDataRef,cFil)   		//Cálculo encargo sobre 13º
	ElseIf nPosTab > 0 .And. lTabMesOld
		aInssEmp[03,1] 	:= 	fTabela(cTab,nPosTab,6,dDataRef,cFil)/100    	//Acidente
	Else
		Return( .F. )
	EndIf
EndIf

nPosTab := fPosTab( cTab,cAnoMes,"==",2,"2","==",4,,,,,cFil,Nil,Nil,Nil,dDataRef) //Tipo de contrato 2

If nPosTab == 0
	nPosTab := fPosTab(cTab, Space(6), "==",2,"2","==",4,,,,,cFil,Nil,Nil,Nil,dDataRef)
EndIf

If nPosTab > 0 .And. !lTabMesOld 
	aInssEmp[01,2] 	:= 	fTabela(cTab,nPosTab,5,dDataRef,cFil)/100    	//Empresa
	aInssEmp[03,2] 	:= 	fTabela(cTab,nPosTab,6,dDataRef,cFil)/100    	//Acidente
	aInssEmp[29,2]	:= 	fTabela(cTab,nPosTab,7,dDataRef,cFil)/100    	//RAT
	aInssEmp[04,2] 	:= 	fTabela(cTab,nPosTab,8,dDataRef,cFil)/100   	//Fgts
	aInssEmp[27,2]	:=	fTabela(cTab,nPosTab,9,dDataRef,cFil)			//Recolhe s. faturamento
	aInssEmp[24,2]	:=  fTabela(cTab,nPosTab,11,dDataRef,cFil)			//Cod. de Pgto. GPS
	aInssEmp[28,2] 	:=  fTabela(cTab,nPosTab,12,dDataRef,cFil)		    //Vlr. minimo da GPS
	aInssEmp[05,2] 	:=  fTabela(cTab,nPosTab,14,dDataRef,cFil)/100   	//Prov 13
	aInssEmp[06,2] 	:=  fTabela(cTab,nPosTab,15,dDataRef,cFil)/100  	//Prov Ferias 	
	aInssEmp[20,2]	:=  fTabela(cTab,nPosTab,16,dDataRef,cFil)/100 		//Prov Rescisao
	aInssEmp[31,2]	:=  fTabela(cTab,nPosTab,17,dDataRef,cFil)   		//Sub Patronal
	aInssEmp[32,2]	:=  fTabela(cTab,nPosTab,18,dDataRef,cFil)   		//Alíquota sobre folha desonerada
	aInssEmp[33,2]	:=  fTabela(cTab,nPosTab,19,dDataRef,cFil)   		//Alíquota sobre faturamento
	aInssEmp[34,2]	:=  fTabela(cTab,nPosTab,20,dDataRef,cFil)   		//Cálculo encargo sobre 13º
ElseIf nPosTab > 0 .And. lTabMesOld
	aInssEmp[03,2] 	:= 	fTabela(cTab,nPosTab,6,dDataRef,cFil)/100    	//Acidente
EndIf

If lTabMesOld
	Return( .T. )
EndIf

cTab := "S038"

//--TABELA S038 - OUTRAS ENTIDADES
nPosTab := 0 

If Len(aTipoContr := fRetRCB(cFil,cTab, "18")) == 0 //Verifica se o campo TIPOCONTR  existe
	nPosTab := fPosTab( cTab,cAnoMes,"==",2,,,,,,,,cFil,Nil,Nil,Nil,dDataRef) //Tipo de contrato 1
	If nPosTab == 0
		nPosTab := fPosTab( cTab,Space(6),"==",2,,,,,,,,cFil,Nil,Nil,Nil,dDataRef)
	EndIf
Else
	nPosTab := fPosTab( cTab,cAnoMes,"==",2,"1","==",21,,,,,cFil,Nil,Nil,Nil,dDataRef) 
	If nPosTab == 0
		nPosTab := fPosTab( cTab,cAnoMes,"==",2," ","==",21,,,,,cFil,Nil,Nil,Nil,dDataRef) 
		If nPosTab == 0
			nPosTab := fPosTab(cTab,Space(6),"==",2,"1","==",21,,,,,cFil,Nil,Nil,Nil,dDataRef)
			If nPosTab == 0
				nPosTab := fPosTab(cTab,Space(6),"==",2," ","==",21,,,,,cFil,Nil,Nil,Nil,dDataRef)
			EndIf
		EndIf
	EndIf
EndIf

If nPosTab > 0
	aInssEmp[25,1]	:= 	fTabela(cTab,nPosTab,4,dDataRef,cFil)		//Codigo de Terceiros
	aInssEmp[02,1] 	:=	fTabela(cTab,nPosTab,5,dDataRef,cFil)		//% Terceiros
	aInssEmp[09,1] 	:=	fTabela(cTab,nPosTab,6,dDataRef,cFil)/100	//% Sal. Educacao
	aInssEmp[10,1] 	:=	fTabela(cTab,nPosTab,7,dDataRef,cFil)/100	//% INCRA
	aInssEmp[11,1] 	:=	fTabela(cTab,nPosTab,8,dDataRef,cFil)/100	//% SENAI
	aInssEmp[12,1] 	:=	fTabela(cTab,nPosTab,9,dDataRef,cFil)/100	//% SESI
	aInssEmp[13,1] 	:=	fTabela(cTab,nPosTab,10,dDataRef,cFil)/100	//% SENAC
	aInssEmp[14,1] 	:=	fTabela(cTab,nPosTab,11,dDataRef,cFil)/100	//% SESC
	aInssEmp[15,1] 	:=	fTabela(cTab,nPosTab,12,dDataRef,cFil)/100	//% SEBRAE
	aInssEmp[16,1] 	:=	fTabela(cTab,nPosTab,13,dDataRef,cFil)/100	//% DPC
	aInssEmp[17,1] 	:=	fTabela(cTab,nPosTab,14,dDataRef,cFil)/100	//% F. AER.
	aInssEmp[18,1] 	:=	fTabela(cTab,nPosTab,15,dDataRef,cFil)/100	//% SENAR
	aInssEmp[19,1] 	:=	fTabela(cTab,nPosTab,16,dDataRef,cFil)/100	//% SECONC
	aInssEmp[22,1] 	:=	fTabela(cTab,nPosTab,17,dDataRef,cFil)/100	//% SEST
	aInssEmp[23,1] 	:=	fTabela(cTab,nPosTab,18,dDataRef,cFil)/100	//% SENAT
	aInssEmp[26,1] 	:=	fTabela(cTab,nPosTab,19,dDataRef,cFil)/100	//% SESCOOP
	aInssEmp[30,1] 	:=	fTabela(cTab,nPosTab,20,dDataRef,cFil)/100	//% ADIC.SENAI
Else
	Return( .F. )
EndIf

If Len(aTipoContr) > 0 //Verifica se o campo TIPOCONTR  existe
	nPosTab := fPosTab( cTab,cAnoMes,"==",2,"2","==",21,,,,,cFil,Nil,Nil,Nil,dDataRef) //Tipo de contrato 2	
	If nPosTab == 0
		nPosTab := fPosTab(cTab, Space(6), "==",2,"2","==",21,,,,,cFil,Nil,Nil,Nil,dDataRef)
	EndIf
Else
	nPosTab := 0
EndIf

If nPosTab > 0 
	 	
	aInssEmp[25,2]	:= 	fTabela(cTab,nPosTab,4,dDataRef,cFil)		//Codigo de Terceiros
	aInssEmp[02,2]	:=  fTabela(cTab,nPosTab,5,dDataRef,cFil)		//% Terceiros
	aInssEmp[09,2]	:=  fTabela(cTab,nPosTab,6,dDataRef,cFil)/100	//% Sal. Educacao
	aInssEmp[10,2]	:=  fTabela(cTab,nPosTab,7,dDataRef,cFil)/100	//% INCRA
	aInssEmp[11,2]	:=  fTabela(cTab,nPosTab,8,dDataRef,cFil)/100	//% SENAI
	aInssEmp[12,2]	:=  fTabela(cTab,nPosTab,9,dDataRef,cFil)/100	//% SESI
	aInssEmp[13,2]	:=  fTabela(cTab,nPosTab,10,dDataRef,cFil)/100	//% SENAC
	aInssEmp[14,2]	:=  fTabela(cTab,nPosTab,11,dDataRef,cFil)/100	//% SESC
	aInssEmp[15,2]	:=  fTabela(cTab,nPosTab,12,dDataRef,cFil)/100	//% SEBRAE
	aInssEmp[16,2]	:=  fTabela(cTab,nPosTab,13,dDataRef,cFil)/100	//% DPC
	aInssEmp[17,2]	:=  fTabela(cTab,nPosTab,14,dDataRef,cFil)/100	//% F. AER.
	aInssEmp[18,2]	:=  fTabela(cTab,nPosTab,15,dDataRef,cFil)/100	//% SENAR
	aInssEmp[19,2]	:=  fTabela(cTab,nPosTab,16,dDataRef,cFil)/100	//% SECONC
	aInssEmp[22,2]	:=  fTabela(cTab,nPosTab,17,dDataRef,cFil)/100	//% SEST
	aInssEmp[23,2]	:=  fTabela(cTab,nPosTab,18,dDataRef,cFil)/100	//% SENAT
	aInssEmp[26,2]	:=  fTabela(cTab,nPosTab,19,dDataRef,cFil)/100	//% SESCOOP
	aInssEmp[30,2]	:=  fTabela(cTab,nPosTab,20,dDataRef,cFil)/100	//% ADIC.SENAI

Else

	aInssEmp[25,2]	:= 	aInssEmp[25,1]	//Codigo de Terceiros
	aInssEmp[02,2]	:=  aInssEmp[02,1]  //% Terceiros
	aInssEmp[09,2]	:=  aInssEmp[09,1]  //% Sal. Educacao
	aInssEmp[10,2]	:=  aInssEmp[10,1]  //% INCRA
	aInssEmp[11,2]	:=  aInssEmp[11,1]  //% SENAI
	aInssEmp[12,2]	:=  aInssEmp[12,1]  //% SESI
	aInssEmp[13,2]	:=  aInssEmp[13,1]  //% SENAC
	aInssEmp[14,2]	:=  aInssEmp[14,1]  //% SESC
	aInssEmp[15,2]	:=  aInssEmp[15,1]  //% SEBRAE
	aInssEmp[16,2]	:=  aInssEmp[16,1]  //% DPC
	aInssEmp[17,2]	:=  aInssEmp[17,1]  //% F. AER.
	aInssEmp[18,2]	:=  aInssEmp[18,1]  //% SENAR
	aInssEmp[19,2]	:=  aInssEmp[19,1]  //% SECONC
	aInssEmp[22,2]	:=  aInssEmp[22,1]  //% SEST
	aInssEmp[23,2]	:=  aInssEmp[23,1]  //% SENAT
	aInssEmp[26,2]	:=  aInssEmp[26,1]  //% SESCOOP
	aInssEmp[30,2]	:=  aInssEmp[30,1]  //% ADIC.SENAI

EndIf

For nX := 1 To 2

	nDed := aInssEmp[09,nX] + aInssEmp[10,nX] + aInssEmp[11,nX] + aInssEmp[12,nX] + aInssEmp[13,nX] + aInssEmp[14,nX]
	nDed += aInssEmp[15,nX] + aInssEmp[16,nX] + aInssEmp[17,nX] + aInssEmp[18,nX] + aInssEmp[19,nX]
	nDed += aInssEmp[22,nX] + aInssEmp[23,nX] + aInssEmp[26,nX]

	aAdd(aDedTer, nDed)
	If lDeducao
		aInssEmp[02,nX] -= (nDed*100)
	EndIf
	
	aInssEmp[02,nX] := aInssEmp[02,nX] / 100
	
	If lProvisao .And. aInssEmp[02,nX] == 0 
		nPerTeProv     := aInssEmp[09,nX] + aInssEmp[10,nX] + aInssEmp[11,nX] + aInssEmp[12,nX] + aInssEmp[13,nX] + aInssEmp[14,nX] + aInssEmp[15,nX] +;
		                  aInssEmp[16,nX] + aInssEmp[17,nX] + aInssEmp[18,nX] + aInssEmp[19,nX] + aInssEmp[22,nX] + aInssEmp[23,nX] + aInssEmp[26,nX]
		aInssEmp[02,nX] := nPerTeProv
	EndIf	

	// Se possuir SENAI 500, faz a proporção com o Percentual do SENAI
	// e adiciona o percentual do SENAI 500 ao % Terceiros
	If (Funname() == "GPEA070" .Or. lProvisao) .And. aInssEmp[30,nX] > 0 .And. lACodFol
		
		aInssEmp[2,nX] += (aInssEmp[30,nX] * aInssEmp[11,nX])
		nPerc := RetValSRV(aCodFol[1395, 1],     SRA->RA_FILIAL,"RV_PERC")//SRV->RV_PERC
		
		//Tratamento para retenção do SENAI, quando a empresa contribui com 1% e o SENAI devolve 0,05% para a empresa.
		//Nos terceiros é informado 0,95% para a folha de pagamento, mas o valor do Adicional SENAI é 20%
		//de 1% e não de 0,95%, para estes casos, se o percentual da verba do SENAI for diferente de 100%, 
		//a diferença entre o %SENAI e o Percentual da verba do SENAI será adicionada aos Terceiros.
		If nPerc != 0 .And. nPerc != 100
			aInssEmp[2,nX] += (nPerc / 100) * (aInssEmp[11,nX] / 100) 
		Endif		
	Endif
	
Next nX

RestArea(aArea)          

Return ( .T. )  
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FEncarCc   ³ autor ³ Mauro               ³ Data ³ 19/09/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula encargos por C.Custo                               ´±±
±±³ÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³±±
±±³Parametro ³                                                            ´±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fEncarCc(cVerbas, lRatM013)

Local nQtdDsr   := 0   //-- Quantidade de C.Custo Lancados de DSR s/H.Extra
Local nQtdCom   := 0   //-- Quantidade de C.Custo Lancados de DSR s/Comissoes
Local nQtdPro   := 0   //-- Quantidade de C.Custo Lancados de DSR s/Professor
Local nQtdHE   	:= 0   //-- Quantidade de C.Custo H.E.
Local nQtdHtv   := 0   //-- Quantidade de C.Custo Lancados de DSR s/H.Atividade
Local aCCFgts   := {}  //-- Array contendo os C.Custo com incidência para FGTS
Local aCCInss   := {}  //-- Array contendo os C.Custo com incidência para INSS
Local aEncarDsr := {}  //-- Array com os Valores por c.custo de D.S.R.s/H.Extra
Local aEncarCom := {}  //--Array com os Valores por c.custo de D.S.R. s/Comissoes
Local aEncarPro := {}  //--Array com os Valores por c.custo de D.S.R. de Professor
Local aEncarHe 	:= {}  //--Array com os Valores por c.custo H.E.
Local aEncarHtv := {}  //--Array com os Valores por c.custo de D.S.R. s/Horas Atividade
Local aEncarHrDs:= {}
Local aRatCCInss:= {}  //-- Array contendo os C.Custo com incidência para INSS que não estão na programação de rateio
Local cEncarCC  := ""
Local cTribuIR  := ""
Local nCont	    := 0
Local nBInssAux := 0
Local nBInssBkp := 0
Local nPos	    := 0
Local nQtd     	:= 0   //-- Quantidade de C.Custo Lancados
Local nTInssNRat:= 0
Local aEncar   	:= {}  //-- Array com os Valores por c.custo
Local nValTot  	:= 0   //-- Valor Total das Verbas 100%
Local nVlVerba 	:= 0
Local nHrVerba 	:= 0
Local nHrComp  	:= 0
Local nVlComp  	:= 0
Local nSmComp	:= 0
Local nValDiv  	:= 0
Local nHrsDiv  	:= 0
Local nSemDiv	:= 0
Local nLugar	:= 0
Local nQtdSem	:= 0
Local nFgtsAux  := 0
Local nValAux   := 0
Local cCCRateio

Local nP
Local cTip1		:= ""
Local cTip2		:= ""
Local cVerba	:= ""
Local cSeq		:= " "
Local dDtPgCc	:= Ctod("")
Local nZ		:= 0
Local n			:= 0
Local z			:= 0
Local j			:= 0
Local nV		:= 0
Local nC		:= 0
Local nR		:= 0    
Local nDSRProf  := 0
Local nHrsAtv   := 0
Local nBsDsHt	:= 0
Local nFgts_b	:= 0
Local nInss_b	:= 0
Local nAuxAt	:= 0
Local nAuxAc	:= 0
Local nBaseAc   := 0
Local nBaseAt   := 0
Local nGrvAt	:= 0
Local nGrvAc	:= 0
Local nPercAt	:= 0
Local nPercAc 	:= 0
Local nPosBas	:= 0
Local nPar   	:= 0
Local lCod317   := RetValSrv(aCodFol[317,1],Sra->Ra_Filial,"Rv_EncarCc")
Local lCod033   := RetValSrv(aCodFol[033,1],Sra->Ra_Filial,"Rv_EncarCc")
Local lDesc		:= .F.
Local lEmpCons	:= .F.
Local lRateio	:= .F.
Local lInfVerba := .F.
Local lTemFgts	:= .F.
Local lTemInss	:= .F.
Local cNumId	:= ""
Local lRatInfo  := Type("P_LRATINFO") <> "U" .And. P_LRATINFO
Local dDataRefB := CToD("")

Private lItemClVl := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"  

Default cVerbas     := "" //verbas especificas para realizar rateio
Default lRatM013	:= .F. // Rateio do cálculo da desoneração.
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

// Indica se ira utilizar o novo calculo de rateio de provisao
lProvPMes := cPaisLoc == "BRA" .and. GetMvRH("MV_RATPROV",,"N") == "S"

If lRatM013
	aEncar := aClone( aEncM013 )
Else
	//-- Montar o Array com os centro de custo das verbas de Base p/ Rateio
    For nZ = 1 to Len(aPd)
        If Empty(cVerbas) .OR. (aPd[nZ,1] $ cVerbas)
            If (aPd[nZ,9] # "D" .Or. (cCompl = "S" .And. apd[nZ,1] == acodfol[48,1])) .And. aPd[nZ,3] = cSemana
                cEncarCC  := RetValSrv(aPd[nZ,1],	SRA->RA_FILIAL, "RV_ENCARCC")
                
                If cEncarCC == "B"
                    lDesc	:= RetValSrv(aPd[nZ,1], SRA->RA_FILIAL, "RV_TIPOCOD") $ "2/4"
                    If lItemClVl
                        nP := Ascan( aEncar,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
                    Else
                        nP := Ascan( aEncar,{ |x| aPd[nZ,2] = x[1] })
                    EndIf							
                    If nP == 0                                                
                        If lItemClVl
                            Aadd(aEncar,{ aPd[nZ,2], Iif( !lDesc, aPd[nZ,4], aPd[nZ,4] * (-1)), Iif( !lDesc, aPd[nZ,5], aPd[nZ,5] * (-1)), 0.00, aPd[nZ,13], aPd[nZ,14], aPd[nZ,7] })
                        Else
                            Aadd(aEncar,{ aPd[nZ,2], Iif( !lDesc, aPd[nZ,4], aPd[nZ,4] * (-1)), Iif( !lDesc, aPd[nZ,5], aPd[nZ,5] * (-1)), 0.00, aPd[nZ,7] })
                        EndIf					
                    Else
                        aEncar[nP,2] += Iif( !lDesc, aPd[nZ,4], aPd[nZ,4] * (-1))
                        aEncar[nP,3] += Iif( !lDesc, aPd[nZ,5], aPd[nZ,5] * (-1))
                        If aPd[ nZ , 7 ] == "I" .And. RetValSrv(aPd[nZ,1], SRA->RA_FILIAL, "RV_HE") != "S" ;
							.And. !(lDissidio .And. aPd[nZ,1] $ acodfol[288,1]+"/"+acodfol[289,1]+"/"+acodfol[290,1]+"/"+acodfol[291,1]+"/"+acodfol[992,1])
                            If lItemClVl .And. aEncar[ nP , 7 ] <> "I"
                                aEncar [ nP , 7 ] := "I"
                            ElseIf !lItemClVl .And. aEncar[ nP , 5 ] <> "I"
                                aEncar [ nP , 5 ] := "I"
                            EndIf					
                        EndIf
                    EndIf
                EndIf
                
                //-- Montar o Array com os c.custo das verbas de Base p/ DSR H.Extra
                If 	RetValSrv(aCodFol[035,1],Sra->Ra_Filial,"Rv_EncarCc") == "S" .And. ;
                    RetValSrv(aPd[nZ,1],     Sra->Ra_Filial,"Rv_DsrHe")   == "S" .And. ;
                    RetValSrv(aPd[nZ,1],     Sra->Ra_Filial,"Rv_RefFer")  # "S" .And. ;
                    !(aPd[nZ,1] $ aCodFol[165,1]+","+aCodFol[347,1]+","+aCodFol[317,1]+","+If( SRA->RA_CATFUNC $ "I*J", aCodFol[033,1],"") )
                    If lItemClVl
                        nP := Ascan( aEncarDsr,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
                    Else
                        nP := Ascan( aEncarDsr,{ |x| aPd[nZ,2] = x[1]  })	
                    EndIf	
                    If nP == 0
                        If lItemClVl
                            Aadd(aEncarDsr,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00, aPd[nZ,13], aPd[nZ,14] })
                        Else
                            Aadd(aEncarDsr,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00 })
                        EndIf					
                    Else
                        aEncarDsr[nP,2] += aPd[nZ,4]
                        aEncarDsr[nP,3] += aPd[nZ,5]
                    EndIf
                EndIf
                //-- Montar o Array com os c.custo das verbas de Base p/ DSR s/Comissoes   
                If RetValSrv(aCodFol[166,1],Sra->Ra_Filial,"Rv_EncarCc") == "S" .And. ;
                RetValSrv(aPd[nZ,1],     Sra->Ra_Filial,"Rv_DsrHe")   == "S" .And. ;
                RetValSrv(aPd[nZ,1],     Sra->Ra_Filial,"Rv_RefFer")  <> "S" .And. ;
                aPd[nZ,1] $ aCodFol[165,1]+","+aCodFol[347,1]
                    If lItemClVl
                        nP := Ascan( aEncarCom,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
                    Else
                        nP := Ascan( aEncarCom,{ |x| aPd[nZ,2] = x[1]  })	
                    EndIf	
                    If nP == 0
                        If lItemClVl
                            Aadd(aEncarCom,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00, aPd[nZ,13], aPd[nZ,14] })
                        Else
                            Aadd(aEncarCom,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00 })
                        EndIf					
                    Else
                        aEncarCom[nP,2] += aPd[nZ,4]
                        aEncarCom[nP,3] += aPd[nZ,5]
                    EndIf
                EndIf

                If cEncarCC == "S" .And. ;
                RetValSrv(aPd[nZ,1], SRA->RA_FILIAL, "RV_HE")   == "S"
                    If lItemClVl
                        nP := Ascan( aEncarHE,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
                    Else
                        nP := Ascan( aEncarHE,{ |x| aPd[nZ,2] = x[1]  })	
                    EndIf	
                    If nP == 0
                        If lItemClVl
                            Aadd(aEncarHE,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00, aPd[nZ,13], aPd[nZ,14] })
                        Else
                            Aadd(aEncarHE,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00 })
                        EndIf					
                    Else
                        aEncarHE[nP,2] += aPd[nZ,4]
                        aEncarHE[nP,3] += aPd[nZ,5]
                    EndIf
                EndIf

                //Tratamento efetuado apenas para Professor Mensalista e Aulista.
                If SRA->RA_CATFUNC $ "I*J"   
                    //-- Montar o Array com os c.custo das verbas de Base p/ DSR s/Horas Atividade   
                    If lCod317 == "S" .And.  aPd[nZ,5] > 0 .And.; 
                    RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_HrsAtiv") == "S" .And. ;   
                    RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_RefFer")  # "S" 
                        If !(aPd[nZ,1] $ If( SRA->RA_CATFUNC $ "I*J", aCodFol[033,1],""))
                            If lItemClVl
                                nP := Ascan( aEncarHtv,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
                            Else
                                nP := Ascan( aEncarHtv,{ |x| aPd[nZ,2] = x[1]  })	
                            EndIf	
                            If nP == 0 
                                If lItemClVl
                                    Aadd(aEncarHtv,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00, aPd[nZ,13], aPd[nZ,14] })
                                Else
                                    Aadd(aEncarHtv,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00 })
                                EndIf					
                            Else
                                aEncarHtv[nP,2] += aPd[nZ,4]
                                aEncarHtv[nP,3] += aPd[nZ,5]
                            EndIf
                        Else
                            nDSRProf += aPd[nZ,5]
                        EndIf
                    EndIf
                    
                    //-- Montar o Array com os c.custo das verbas de Base p/ DSR s/Professor   
                    If lCod033 == "S" .And. aPd[nZ,5] > 0 .And.; 
                    RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_DsrProf") == "S" .And. ;
                    RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_RefFer")  # "S" 
                        If !(aPd[nZ,1] $ aCodFol[317,1])
                            If lItemClVl
                                nP := Ascan( aEncarPro,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
                            Else
                                nP := Ascan( aEncarPro,{ |x| aPd[nZ,2] = x[1]  })	
                            EndIf	
                            If nP == 0
                                If lItemClVl
                                    Aadd(aEncarPro,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00, aPd[nZ,13], aPd[nZ,14] })
                                Else
                                    Aadd(aEncarPro,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00 })
                                EndIf					
                            Else
                                aEncarPro[nP,2] += aPd[nZ,4]
                                aEncarPro[nP,3] += aPd[nZ,5]
                            EndIf
                        Else
                            nHrsAtv += aPd[nZ,5]
                        EndIf
                    EndIf
                    
                    
                    //-- Montar o Array com os c.custo das verbas de Base p/ DSR s/Professor e Hora Atividade 
                    If lCod033 == "S" .And. aPd[nZ,5] > 0 .And.; 
                    RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_DsrProf") == "S" .And. ;
                    lCod317 == "S" .And. ;
                    RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_HrsAtiv") == "S" .And. ;   
                    RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_RefFer")  # "S" 
                        If !( aPd[nZ,1] $ aCodFol[317,1] + "*" + If( SRA->RA_CATFUNC $ "I*J", aCodFol[033,1],"") )
                            If lItemClVl
                                nP := Ascan( aEncarHrDs,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
                            Else
                                nP := Ascan( aEncarHrDs,{ |x| aPd[nZ,2] = x[1]  })	
                            EndIf	
                            If nP == 0
                                If lItemClVl
                                    Aadd(aEncarHrDs,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00, aPd[nZ,13], aPd[nZ,14] })
                                Else
                                    Aadd(aEncarHrDs,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00 })
                                EndIf					
                            Else
                                aEncarHrDs[nP,2] += aPd[nZ,4]
                                aEncarHrDs[nP,3] += aPd[nZ,5]
                            EndIf
                            nBsDsHt += aPd[nZ,5]
                        EndIf
                    EndIf
                EndIf

                If aPd[nZ, 7] $ "I/G/E" .And. ( cEncarCC == "N" .Or. cEncarCC == "S" .And. !lRatInfo )
                    If RetValSrv(aPd[nZ,1], SRA->RA_FILIAL, "RV_INSS") == "S"
                        nPos := aScan( aCCInss, { |x| aPd[nZ, 2] == x[1] .And. Iif( lItemClVl, aPd[nZ, 13] == x[5] .And. aPd[nZ, 14] == x[6], .T. ) } )
                        If nPos == 0
                            aAdd( aCCInss, { aPd[nZ, 2], aPd[nZ, 4], aPd[nZ, 5], 0.00, Iif( lItemClVl, aPd[nZ, 13], ""), Iif( lItemClVl, aPd[nZ, 14], "") } )
                        Else
                            aCCInss[nPos,3] += aPd[nZ, 5]
                        EndIf
                    EndIf
                    If RetValSrv(aPd[nZ,1], SRA->RA_FILIAL, "RV_FGTS") == "S"
                        nPos := aScan( aCCFgts, { |x| aPd[nZ, 2] == x[1] .And. Iif( lItemClVl, aPd[nZ, 13] == x[5] .And. aPd[nZ, 14] == x[6], .T. ) } )
                        If nPos == 0
                            aAdd( aCCFgts, { aPd[nZ, 2], aPd[nZ, 4], aPd[nZ, 5], 0.00, Iif( lItemClVl, aPd[nZ, 13], ""), Iif( lItemClVl, aPd[nZ, 14], "") } )
                        Else
                            aCCFgts[nPos,3] += aPd[nZ, 5]
                        EndIf
                    EndIf
                EndIf
            EndIf
        EndIf
    Next
EndIf
nQtd	:= Len(aEncar)
nQtdDsr := Len(aEncarDsr)
nQtdCom := Len(aEncarCom)
nQtdHE  := Len(aEncarHE)
nQtdHtv := Len(aEncarHtv)
nQtdPro := Len(aEncarPro)  

//---------------------------------------------------------------------------------//
// Quando nao houver lancamento de base para rateio, obtem percentuais cadastrados //
// na tabela RHQ - Programacao de Rateio.                                          //
//---------------------------------------------------------------------------------//  
If cPaisLoc == "BRA" .And. lProvPMes // Programacao de Rateio utilizada somente para o Brasil			
	fRateio( {} , 1 ) //Deleta registros de usuarios da tabela RHQ

	If nQtd > 0
	
		//--Verifica se possui alguma verba informada para rateio
		If lItemClVl
			lInfVerba := ( Ascan( aEncar,{ |x| x[7] == "I"  }) > 0 )
		Else
			lInfVerba := ( Ascan( aEncar,{ |x| x[5] == "I"  }) > 0 )
		EndIf					

        If SRA->RA_CATFUNC $ "I*J"
		//---------------------------------------------------------------------------------//                
		// Para funcionários categora I e J, obtem a informação do cadastro de programação //
		// de Rateio                                                                       //
		//---------------------------------------------------------------------------------//        
			fRateio( {} , 2 ) //Carrega a programação de Rateio     
			lRateio := .T.
		ElseIf SRA->RA_CATFUNC $ "C" .And. lInfVerba
		//---------------------------------------------------------------------------------//
		// Para funcionários Comissionistas,caso exista programação de rateio, considera-se//
		// que a verba não foi informada, para que o rateio seja efetuado de acordo com a  //
		// Programação - Tabela RHQ														   //	
		//---------------------------------------------------------------------------------//		
			fRateio( {} , 2 ) //Carrega a programação de Rateio
			lInfVerba := Empty(aRateio)
		EndIf
			
		//---------------------------------------------------------------------------------//
		// Quando nao houver lancamento de base para rateio, obtem percentuais cadastrados //
		// na tabela RHQ - Programacao de Rateio.                                          //
		//---------------------------------------------------------------------------------//			
		If !lInfVerba .and. ( !( SRA->RA_CATFUNC $ "I*J" ) .Or. (SRA->RA_CATFUNC $ "I*J" .And. Len(aRateio) > 0))
			fRateio( {} , 3 ) //Deleta registros de usuarios e busca dados
			If !Empty(aRateio)
				aEncar := {}
				For n := 1 to Len(aRateio)
				//--Desconsidera os registros de programacao de rateio originados dos 
				//--lancamentos do usuario.
					If aRateio[n,5] = "S"
						aAdd(aEncar,{aRateio[n,1],0,0,aRateio[n,4],aRateio[n,2],aRateio[n,3]})
					Else
						aRateio[n,7] := "D"
					EndIf
				Next n 
				nQtd := Len(aEncar)			
				lRateio := .T.
			Else
				//Se não existir percentual de rateio, ignora a programação
				nQtd := 0
				
				For n := 1 to Len(aEncar)
					If aEncar[n,4] > 0
						nQtd := Len(aEncar)
						Exit
					EndIf
				Next n
				If nQtd == 0
					aEncar := {}
				EndIf
			EndIf				
		Else
			//---------------------------------------------------------------//
			// Quando houver lancamento de base para rateio, grava registros //
			// na tabela RHQ - Programacao de Rateio.                        //
			//---------------------------------------------------------------//

			//--Achar o Total da Base de Encargos
			aEval(aEncar,{ |X| nValTot += X[3] })
	
			For n := 1  to nQtd
				aEncar[n,4] := aEncar[n,3] / nValTot				
				//--Quando for o mesmo valor 100 %
				If aEncar[n,4] = 1.00
					aEncar[n,4] := 100.000
				Else  
					fRateio(aEncar[n]) //Grava dados			
				EndIf
			Next n
		EndIf
		
		If nQtd > 0
	  			
			For Nr := 1 to Len(aPd)    
			
				//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
				If aPd[Nr,9]  # "D" .And. aPd[nR,3] == cSemana .And. ( lRatInfo .Or. ! aPd[nR,7] $ "I|G" ) .And. ;
				( RetValSRV(aPd[Nr, 1], SRA->RA_FILIAL, "RV_ENCARCC") == "S" ) .Or.;
				( lRateio .And. RetValSRV(aPd[Nr,1],SRA->RA_FILIAL,"RV_ENCARCC") == "B" )
					
					nVlVerba := nVlComp := nHrVerba := nHrComp := nQtdSem := nSmComp := 0.00
					cVerba   := aPd[Nr,1]
					cTip2	 := aPd[Nr,7]
					nPar	 := aPd[Nr,8]
                    cTribuIR := ""
	
					If cVerba $ aCodFol[13,1] + "/" + aCodFol[14,1] .And. aPd[Nr, 27] != "1"//Sal Contr. Ate Limite Base/Sal Contr. Acima Limite Base
						//INSS será rateado conforme e-Social, somando as verbas de cada Centro de Custos, ao final do rateio
						nBaseAt += If(cVerba == aCodFol[13,1], aPd[Nr,5],0)
						nBaseAc += If(cVerba == aCodFol[14,1], aPd[Nr,5],0)
						lTemInss 	:= .T.
						aPd[Nr,9] 	:= "D"						
						Loop 
					EndIf

					If cVerba == aCodFol[17, 1]//Base FGTS
						lTemFgts 	:= .T.
						aPd[Nr, 9] 	:= "D"						
						Loop 
					EndIf

					//-- Achar o valor total da Verba a ser Calc. por C.Custo
					For nV := 1 To Len(aPd)
						If cVerba == aPd[nV,1] .And. aPd[nV,9] # 'D' .And. aPd[nV,3] == cSemana .And. ( ( lRatInfo .Or. ! aPd[nR,7] $ "I|G" ) .AND. cTip2 == aPd[Nv,7]) .And. aPd[nV, 27] != "1"
							nVlVerba  += aPd[nV,5]
							nHrVerba  += aPd[nV,4]
							nQtdSem	  += aPd[nV,12]
							cTip1		:= aPd[nV,6]		//Tipo da verba( V,H,D )
							cTip2     	:= aPd[nV,7]       	//--> Origem da Verba
							nPar		:= aPd[nV,8]
							dDtPgCc	  	:= aPd[nV,10]		//--> Data Pagto Origem
							cSeq		:= aPd[nV,11]		//--> Sequencia
							cNumID		:= aPd[nV,15]
							lEmpCons	:= aPd[nV,16]		//--> Se é verba de emprestimo consignado
							dDataRefB   := aPd[nV,18]       //--> Data de referência anterior
                            If Len(aPd[nV]) >= 28
                                cTribuIR    := aPd[nV, 28]  //Modelo de tributação do IR
                            EndIf
							aPd[nV,9] 	:= "D"
							//Tratamento para Categorias I,J -> qdo a verba é rateada e a qtde de horas está como o total do mês
							//para todas as verbas. Considerar o total apenas para a primeira verba, ou seja, subtrair o total das demais verbas iguais
							//para que a quantidade de horas seja lançada corretamente.
							If SRA->RA_CATFUNC $ "I*J" .And. nV > 1 .And. (cVerba == aPd[nV -1, 1] .And. aPd[nV, 4] == 30  .And. aPd[nV-1, 4] == 30 )
								nHrVerba  -= aPd[nV,4]
							EndIf
						ElseIf Empty(cSeq) .and. cVerba == aPd[nV,1] .And. aPd[nV,9] # 'D' .And. aPd[nV,3] == cSemana .And. ( ( lRatInfo .Or. ! aPd[nR,7] $ "I|G" ) .AND. cTip2 <> aPd[Nv,7]) .And. aPd[nV, 27] != "1"
							cSeq := "0"
							cSeq := Soma1(aPd[nV,11])
						EndIf
					Next nV

					If cVerba <> aCodfol[47,1]
						//-- Divisao da Verba para cada c.custo
						For Nc := 1 to nQtd
							If Nc # nQtd
								nValDiv := Round(nVlVerba * aEncar[Nc,4],2)
								nHrsDiv := Round(nHrVerba * aEncar[Nc,4],2)
								nSemDiv := Round(nQtdSem  * aEncar[Nc,4],2)
								nVlComp += nValDiv
								nHrComp += nHrsDiv
								nSmComp += nSemDiv
							Else
								nValDiv := nVlVerba - nVlComp
								nHrsDiv := nHrVerba - nHrComp
								nSemDiv	:= nQtdSem  - nSmComp
							EndIf
							nHrsDiv := Iif(nHrsDiv < 0 .And. nValDiv > 0, 0, nHrsDiv)
                            fMatriz(cVerba,nValDiv,nHrsDiv,,aEncar[Nc,1],cTip1,cTip2, Iif(!lItemClVl, nPar, Nil),,dDtPgCc,.T.,cSeq,nSemDiv, Iif(lItemClVl, aEncar[Nc,5], Nil), Iif(lItemClVl, aEncar[Nc,6], Nil),cNumID, lEmpCons,,dDataRefB, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cTribuIR)
						Next Nc
					EndIf
				EndIf
			Next Nr

			For Nr := 1 to Len(aPd)
				//Rateia apenas a verba de liquido, com base em todas as outras verbas que foram rateadas no laço de cima
				If aPd[Nr,1] == aCodfol[47,1]
			
					//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
					If aPd[Nr,9]  # "D" .And. aPd[nR,3] == cSemana .And. ( lRatInfo .Or. ! aPd[nR,7] $ "I|G" ) .And. ;
					( RetValSRV(aPd[Nr, 1], SRA->RA_FILIAL, "RV_ENCARCC") == "S" ) .Or.;
					( lRateio .And. RetValSRV(aPd[Nr,1],SRA->RA_FILIAL,"RV_ENCARCC") == "B" )
						
						nVlVerba := nVlComp := nHrVerba := nHrComp := nQtdSem := nSmComp := 0.00
						cVerba   := aPd[Nr,1]
						cTip2	  := aPd[Nr,7]
						nPar	 := aPd[Nr,8]
						
						nValDiv := 0
						For Nc := 1 to nQtd
							nValDiv := Min(0,nValDiv) //Se negativou o liquido anterior, desconta do atual
							If Nc == 1 //Verifica se existem verbas vindas do fechamento, que não esta em nenhum centro de custos, e soma no nValDiv
								For Nv := 1 to Len(aPd)
									If aPd[Nv,7] == "F"
										If lItemClVl
											If ( aScan(aEncar, {|x| x[1]+x[5]+x[6] == aPd[Nv,2]+aPd[Nv,13]+aPd[Nv,14] }) ) == 0
												SomaInc(aPd[Nv],0,@nValDiv,,,,,,.F.,aCodFol)
											EndIf
										Else
											If ( aScan(aEncar ,{ |x| x[1] == aPd[Nv,2] } ) ) == 0
												SomaInc(aPd[Nv],0,@nValDiv,,,,,,.F.,aCodFol)
											EndIf
										EndIf
									EndIf
								Next Nv							
							EndIf							
							If lItemClVl
								Aeval( aPd ,{ |x| If(x[2]+x[13]+x[14] == aEncar[Nc,1]+aEncar[Nc,5]+aEncar[Nc,6], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
							Else
								Aeval( aPd ,{ |x| If(x[2] == aEncar[Nc,1], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
							EndIf
			
							If lItemClVl
								fMatriz(cVerba,nValDiv,0,,aEncar[Nc,1],cTip1,cTip2,,,dDtPgCc,.T.,cSeq,nSemDiv,aEncar[Nc,5],aEncar[Nc,6],cNumID)  
							Else
								fMatriz(cVerba,nValDiv,0,,aEncar[Nc,1],cTip1,cTip2,nPar,,dDtPgCc,.T.,cSeq,nSemDiv,,,cNumID)    
							EndIf
						Next Nc
					EndIf
				EndIf
			Next Nr	
			
			If lTemInss
                nBInssBkp := ( nBaseAc + nBaseAt )
                For nCont := 1 To Len(aCCInss)
                    If aScan( aEncar, { |x| x[1]+Iif( lItemClVl, x[5]+x[6], "" ) == aCCInss[nCont, 1]+Iif( lItemClVl, aCCInss[nCont, 5]+aCCInss[nCont, 6], "" ) } ) == 0
                        aAdd( aRatCCInss, aClone( aCCInss[nCont] ) )
                    EndIf
                Next nCont
                If !Empty(aRatCCInss)
                    aEval(aRatCCInss, { |x| nTInssNRat += x[3] } )
                    If nBaseAc > 0
                        Calc_Inss(aTInss, ( nBaseAc + nBaseAt - nTInssNRat ), 0, 0, @nBaseAt, @nBaseAc)
                    EndIf
                EndIf
				nPercAt := nBaseAt / ( nBaseAc + nBaseAt ) //Percentual até o limite
				nPercAc := nBaseAc / ( nBaseAc + nBaseAt ) //Percentual acima do limite
				nPosBas := aScan(aPd, {|x| x[1] == aCodFol[13,1]})

				If nPosBas == 0
					nPosBas := aScan(aPd, {|x| x[1] == aCodFol[14,1]})
				EndIf
			
				For Nr := 1 to nQtd
					nInss_b := 0
                    Aeval( aPd ,{ |X| If(x[2]+Iif( lItemClVl, x[13]+x[14], "" ) == aEncar[Nr,1]+Iif( lItemClVl, aEncar[Nr,5]+aEncar[Nr,6], "" ), SomaInc(X, 4, @nInss_b, 12, "N", Nil, Nil, Nil, Nil, aCodfol), Nil) })
                    If nPercAc > 0
                        If Nr < nQtd
                            nAuxAt	:= Round( nInss_b * nPercAt , 2 )
                            nAuxAc 	:= Round( nInss_b * nPercAc , 2 )
                            nGrvAt 	+= nAuxAt
                            nGrvAc 	+= nAuxAc
                        Else
                            nAuxAt	:= nBaseAt - nGrvAt
                            nAuxAc 	:= nBaseAc - nGrvAc
                        EndIf
                        fMatriz(aCodFol[13,1],nAuxAt,aPd[nPosBas,4],,aEncar[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],Iif( !lItemClVl, aPd[nPosBas,8], Nil),,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,Iif( lItemClVl, aEncar[Nr, 5], Nil), Iif( lItemClVl, aEncar[Nr, 6], Nil ),aPd[nPosBas,15], .F.,,aPd[nPosBas,18])  
                        fMatriz(aCodFol[14,1],nAuxAc,aPd[nPosBas,4],,aEncar[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],Iif( !lItemClVl, aPd[nPosBas,8], Nil),,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,Iif( lItemClVl, aEncar[Nr, 5], Nil), Iif( lItemClVl, aEncar[Nr, 6], Nil ),aPd[nPosBas,15], .F.,,aPd[nPosBas,18])  
                    Else
                        fMatriz(aCodFol[13,1],nInss_b,aPd[nPosBas,4],,aEncar[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],Iif( !lItemClVl, aPd[nPosBas,8], Nil),,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,Iif( lItemClVl, aEncar[Nr, 5], Nil), Iif( lItemClVl, aEncar[Nr, 6], Nil ),aPd[nPosBas,15], .F.,,aPd[nPosBas,18])  
                    EndIf
				Next Nr
                If !Empty(aRatCCInss)
                    nAuxAc      := 0
                    nAuxAt      := 0
                    nBInssAux   := nBInssBkp - nTInssNRat
                    For nCont := 1 To Len(aRatCCInss)
                        Calc_Inss( aTInss, (nBInssAux + aRatCCInss[nCont, 3]), 0, 0, @nAuxAt, @nAuxAc, 0, nBInssAux )
                        If nAuxAt > 0
                            fMatriz( aCodFol[13, 1], nAuxAt, aPd[nPosBas,4], Nil, aRatCCInss[nCont, 1], aPd[nPosBas,6], aPd[nPosBas,7], Iif( !lItemClVl, aPd[nPosBas,8], Nil), Nil, aPd[nPosBas,10], .T., aPd[nPosBas,11], Nil, Iif( lItemClVl, aRatCCInss[nCont, 5], Nil), Iif( lItemClVl, aRatCCInss[nCont, 6], Nil ), aPd[nPosBas,15], .F., Nil, aPd[nPosBas,18] )
                        EndIf
                        If nAuxAc > 0
                            fMatriz( aCodFol[14, 1], nAuxAc, aPd[nPosBas,4], Nil, aRatCCInss[nCont, 1], aPd[nPosBas,6], aPd[nPosBas,7], Iif( !lItemClVl, aPd[nPosBas,8], Nil), Nil, aPd[nPosBas,10], .T., aPd[nPosBas,11], Nil, Iif( lItemClVl, aRatCCInss[nCont, 5], Nil), Iif( lItemClVl, aRatCCInss[nCont, 6], Nil ), aPd[nPosBas,15], .F., Nil, aPd[nPosBas,18] )
                        EndIf
                        nBInssAux += aRatCCInss[nCont, 3]
                    Next nCont
                EndIf
			EndIf

			If lTemFgts
				nPosBas := aScan( aPd, { |x| x[1] == aCodFol[17, 1] } )
				//Obtem o valor original da base do FGTS já calculada
				nFgts_b := aPd[nPosBas,5]

                For nCont := 1 To Len(aCCFgts)
                    If aScan( aEncar, { |x| x[1]+Iif( lItemClVl, x[5]+x[6], "" ) == aCCFgts[nCont, 1]+Iif( lItemClVl, aCCFgts[nCont, 5]+aCCFgts[nCont, 6], "" ) } ) == 0
                        fMatriz( aCodFol[17, 1], aCCFgts[nCont, 3], aPd[nPosBas, 4], Nil, aCCFgts[nCont, 1], aPd[nPosBas, 6], aPd[nPosBas, 7], aPd[nPosBas, 8], Nil, aPd[nPosBas, 10], .T., aPd[nPosBas, 11], Nil, Iif( lItemClVl, aCCFgts[nCont, 5], Nil), Iif( lItemClVl, aCCFgts[nCont, 6], Nil ), aPd[nPosBas, 15], .F., Nil, aPd[nPosBas, 18] )
						//Subtrai as verbas geradas a partir do que foi informado da base total
						nFgts_b -= aCCFgts[nCont, 3]
                    EndIf
                Next nCont				

				//Obtem os valores que compõe a base de FGTS cujas verbas não possuem rateio e subtrai da base completa
				nFgtsAux := 0
				cCCRateio := ""
				Aeval( aEncar ,{ |X| cCCRateio += x[1]+Iif( lItemClVl, x[5]+x[6],"") + "#" }) 
				Aeval( aPd ,{ |X| If( ( !(x[7] $ "I/G/E") .or. (x[2]+Iif( lItemClVl, x[13]+x[14],"") $ cCCRateio) ) .and. !(RetValSRV(x[1], SRA->RA_FILIAL, "RV_ENCARCC") $ "S/B") , SomaInc(X, 6, @nFgtsAux, 12, "N", Nil, Nil, Nil, Nil, aCodfol), Nil) })
				nFgts_b -= nFgtsAux

				For Nr := 1 to nQtd
					nFgtsAux := 0
					Aeval( aPd ,{ |X| If(x[2]+Iif( lItemClVl, x[13]+x[14], "" ) == aEncar[Nr,1]+Iif( lItemClVl, aEncar[Nr,5]+aEncar[Nr,6], "" ) .and. !(RetValSRV(X[1], SRA->RA_FILIAL, "RV_ENCARCC") $ "S/B"), SomaInc(X, 6, @nFgtsAux, 12, "N", Nil, Nil, Nil, Nil, aCodfol), Nil) })
                    //Rateia a parte da base referente as verbas que possuem rateio e soma o valor referente as verbas que não possuem rateio e que estavam no mesmo CC
					nValAux := If(nQtd>1, Round(nFgts_b * aEncar[Nr,4],2), nFgts_b) + nFgtsAux
					fMatriz( aCodFol[17, 1], nValAux, aPd[nPosBas, 4], Nil, aEncar[Nr,1], aPd[nPosBas, 6], aPd[nPosBas, 7], aPd[nPosBas, 8], Nil, aPd[nPosBas, 10], .T., aPd[nPosBas, 11], Nil, Iif( lItemClVl, aEncar[Nr, 5], Nil), Iif( lItemClVl, aEncar[Nr, 6], Nil ), aPd[nPosBas, 15], .F., Nil, aPd[nPosBas, 18] )
				Next Nr
			EndIf

			If aScan(aPd, {|x| x[1] == aCodfol[47,1] .And. x[9] == "D" }) > 0
				// Tratar a verba de Liquido
				nValDiv := 0
				For Nc := 1 to nQtd
					nValDiv := Min(0,nValDiv) //Se negativou o liquido anterior, desconta do atual
					If Nc == 1 //Verifica se existem verbas vindas do fechamento, que não esta em nenhum centro de custos, e soma no nValDiv
						For Nr := 1 to Len(aPd)
							If aPd[nR,7] == "F"
								If lItemClVl
									If ( aScan(aEncar, {|x| x[1]+x[5]+x[6] == aPd[Nr,2]+aPd[Nr,13]+aPd[Nr,14] }) ) == 0
										SomaInc(aPd[Nr],0,@nValDiv,,,,,,.F.,aCodFol)
									EndIf
								Else
									If ( aScan(aEncar ,{ |x| x[1] == aPd[Nr,2] } ) ) == 0
										SomaInc(aPd[Nr],0,@nValDiv,,,,,,.F.,aCodFol)
									EndIf
								EndIf
							EndIf
						Next Nr							
					EndIf
					If lItemClVl
						Aeval( aPd ,{ |x| If(x[2]+x[13]+x[14] == aEncar[Nc,1]+aEncar[Nc,5]+aEncar[Nc,6], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
						If SRA->RA_TPCONTR == "3"
							Aeval( aPdConvoc ,{ |x| If(x[2]+x[13]+x[14] == aEncar[Nc,1]+aEncar[Nc,5]+aEncar[Nc,6], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
						EndIf
					Else
						Aeval( aPd ,{ |x| If(x[2] == aEncar[Nc,1], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
						If SRA->RA_TPCONTR == "3"
							Aeval( aPdConvoc ,{ |x| If(x[2] == aEncar[Nc,1], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
						EndIf
					EndIf
	
					If lItemClVl
						fMatriz(aCodfol[0047,1],nValDiv,0,,aEncar[Nc,1],cTip1,cTip2,,,dDtPgCc,.T.,cSeq,nSemDiv,aEncar[Nc,5],aEncar[Nc,6],cNumID)  
					Else
						fMatriz(aCodfol[0047,1],nValDiv,0,,aEncar[Nc,1],cTip1,cTip2,nPar,,dDtPgCc,.T.,cSeq,nSemDiv,,,cNumID)    
					EndIf
				Next Nc
			EndIf
		ElseIf nQtdHE > 0
			If RetValSRV(aCodFol[13,1], SRA->RA_FILIAL, "RV_ENCARCC") == "S"
				Aeval( aPd, { |x| If(x[1] == aCodFol[13,1] .And. x[9] # "D" .And. x[3] == cSemana .And. x[7] # 'F' .And. (lRatInfo .Or. !x[7] $ "I|G"), nBaseAt += x[5], Nil) } )
				Aeval( aPd, { |x| If(x[1] == aCodFol[13,1] .And. x[9] # "D" .And. x[3] == cSemana .And. x[7] # 'F' .And. (lRatInfo .Or. !x[7] $ "I|G"), x[9] := "D", Nil) } )
				Aeval( aPd, { |x| If(x[1] == aCodFol[14,1] .And. x[9] # "D" .And. x[3] == cSemana .And. x[7] # 'F' .And. (lRatInfo .Or. !x[7] $ "I|G"), nBaseAc += x[5], Nil) } )
				Aeval( aPd, { |x| If(x[1] == aCodFol[14,1] .And. x[9] # "D" .And. x[3] == cSemana .And. x[7] # 'F' .And. (lRatInfo .Or. !x[7] $ "I|G"), x[9] := "D", Nil) } )

				nPercAt := nBaseAt / ( nBaseAc + nBaseAt ) //Percentual até o limite
				nPercAc := nBaseAc / ( nBaseAc + nBaseAt ) //Percentual acima do limite
				nPosBas := aScan(aPd, {|x| x[1] == aCodFol[13,1]})			

				If nPosBas > 0
					For Nr := 1 to nQtdHE
						nInss_b := 0						
						Aeval( aPd ,{ |X| If(x[2]+Iif( lItemClVl, x[13]+x[14], "" ) == aEncarHe[Nr,1]+Iif( lItemClVl, aEncarHe[Nr,5]+aEncarHe[Nr,6], "" ), SomaInc(X, 4, @nInss_b, 12, "N", Nil, Nil, Nil, Nil, aCodfol), Nil) })
						If nPercAc > 0
							If Nr < nQtdHE
								nAuxAt	:= Round( nInss_b * nPercAt , 2 )
								nAuxAc 	:= Round( nInss_b * nPercAc , 2 )
								nGrvAt 	+= nAuxAt
								nGrvAc 	+= nAuxAc
							Else
								nAuxAt	:= nBaseAt - nGrvAt
								nAuxAc 	:= nBaseAc - nGrvAc
							EndIf
							fMatriz(aCodFol[13,1],nAuxAt,aPd[nPosBas,4],,aEncarHe[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],Iif( !lItemClVl, aPd[nPosBas,8], Nil),,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,Iif( lItemClVl, aEncarHe[Nr, 5], Nil), Iif( lItemClVl, aEncarHe[Nr, 6], Nil ),aPd[nPosBas,15], .F.,,aPd[nPosBas,18])  
							fMatriz(aCodFol[14,1],nAuxAc,aPd[nPosBas,4],,aEncarHe[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],Iif( !lItemClVl, aPd[nPosBas,8], Nil),,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,Iif( lItemClVl, aEncarHe[Nr, 5], Nil), Iif( lItemClVl, aEncarHe[Nr, 6], Nil ),aPd[nPosBas,15], .F.,,aPd[nPosBas,18])  
						Else
							fMatriz(aCodFol[13,1],nInss_b,aPd[nPosBas,4],,aEncarHe[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],Iif( !lItemClVl, aPd[nPosBas,8], Nil),,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,Iif( lItemClVl, aEncarHe[Nr, 5], Nil), Iif( lItemClVl, aEncarHe[Nr, 6], Nil ),aPd[nPosBas,15], .F.,,aPd[nPosBas,18])  
						EndIf						
					Next Nr
				EndIf

				If aScan(aPd, {|x| x[1] == aCodfol[47,1] .And. x[9] == "D" }) > 0
					// Tratar a verba de Liquido
					nValDiv := 0
					For Nc := 1 to nQtdHE
						nValDiv := Min(0,nValDiv) //Se negativou o liquido anterior, desconta do atual
						If Nc == 1 //Verifica se existem verbas vindas do fechamento, que não esta em nenhum centro de custos, e soma no nValDiv
							For Nr := 1 to Len(aPd)
								If aPd[nR,7] == "F"
									If lItemClVl
										If ( aScan(aEncarHe, {|x| x[1]+x[5]+x[6] == aPd[Nr,2]+aPd[Nr,13]+aPd[Nr,14] }) ) == 0
											SomaInc(aPd[Nr],0,@nValDiv,,,,,,.F.,aCodFol)
										EndIf
									Else
										If ( aScan(aEncarHe ,{ |x| x[1] == aPd[Nr,2] } ) ) == 0
											SomaInc(aPd[Nr],0,@nValDiv,,,,,,.F.,aCodFol)
										EndIf
									EndIf
								EndIf
							Next Nr							
						EndIf
						If lItemClVl
							Aeval( aPd ,{ |x| If(x[2]+x[13]+x[14] == aEncarHe[Nc,1]+aEncarHe[Nc,5]+aEncarHe[Nc,6], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
						Else
							Aeval( aPd ,{ |x| If(x[2] == aEncarHe[Nc,1], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
						EndIf
		
						If lItemClVl
							fMatriz(aCodfol[0047,1],nValDiv,nHrsDiv,,aEncarHe[Nc,1],cTip1,cTip2,,,dDtPgCc,.T.,cSeq,nSemDiv,aEncarHe[Nc,5],aEncarHe[Nc,6],cNumID)  
						Else
							fMatriz(aCodfol[0047,1],nValDiv,nHrsDiv,,aEncarHe[Nc,1],cTip1,cTip2,nPar,,dDtPgCc,.T.,cSeq,nSemDiv,,,cNumID)    
						EndIf
					Next Nc
				EndIf
			EndIf		
		EndIf
	EndIf 
		
	//-------------------------------------------------------------//
	// Apaga da tabela RHQ os registros originados dos lancamentos //
	// do usuario, quando esses lancamentos forem descartados.     //
	//-------------------------------------------------------------//
	For n:=1 to Len(aRateio)
		If aRateio[n,7] = "D"
			RHQ->(DbGoTo(aRateio[n,6]))
			RecLock("RHQ",.F.)
			RHQ->( dbDelete() )
			RHQ->( MsUnlock() )			
		EndIf
	Next n
	
Else

	If nQtd > 0
		//--Achar o Total da Base de Encargos
		aEval(aEncar,{ |X| nValTot += X[3] })
	
		For n := 1  to nQtd
			aEncar[n,4] := aEncar[n,3] / nValTot				
			//--Quando for o mesmo valor 100 %
			If aEncar[n,4] = 1.00
				aEncar[n,4] := 100.000
				nQtd := n 
				aSize(aEncar, n)
				Exit
			EndIf
		Next n
	
		For Nr := 1 to Len(aPd)
				
			//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
			If aPd[Nr,9]  # "D" .And. aPd[nR,3] == cSemana .And. ;
			( !( aPd[Nr,1] $ aCodFol[035,1] + "*" + aCodFol[166,1] + "*" + aCodFol[317,1] + "*" + If( SRA->RA_CATFUNC $ "I*J", aCodFol[033,1],"") ) .And.;
				 RetValSrv(aPd[Nr,1],Sra->Ra_Filial,"Rv_EncarCc") = "S" ) .or. ( lRateio .And. RetValSRV(aPd[Nr,1],Sra->Ra_Filial,"Rv_EncarCc") == "B" )
	
				nVlVerba := nVlComp := nHrVerba := nHrComp := 0.00
				cVerba   := aPd[Nr,1]
				cTip2	 := aPd[Nr,7]
                cTribuIR := ""

				//-- Achar o valor total da Verba a ser Calc. por C.Custo
				For nV := 1 To Len(aPd)
					If cVerba == aPd[nV,1] .And. aPd[nV,9] # 'D' .And. aPd[nV,3] == cSemana .And. (lRatInfo .Or. ! aPd[nV,7] $ "I|G" .and. cTip2 == aPd[nV,7]) .And. aPd[nV, 27] != "1"
						nVlVerba  += aPd[nV,5]
						nHrVerba  += aPd[nV,4]
						cTip1		:= aPd[nV,6]		//Tipo da verba( V,H,D )
						cTip2     	:= aPd[nV,7]		//--> Origem da Verba
						dDtPgCc	  	:= aPd[nV,10]		//--> Data Pagto Origem
						cSeq		:= aPd[nV,11]		//--> Sequencia
						cNumID		:= aPd[nV,15]		//--> Identificador
						lEmpCons	:= aPd[nV,16]		//--> Se é verba de emprestimo consignado
						dDataRefB   := aPd[nV,18]       //--> Data de referência anterior
                        If Len(aPd[nV]) >= 28
                            cTribuIR    := aPd[nV, 28]  //Modelo de tributação do IR
                        EndIf
						aPd[nV,9] 	:= "D"
					EndIf
				Next nV
				
				//-- Divisao da Verba para cada c.custo
				For Nc := 1 to nQtd
					If Nc # nQtd
						nValDiv := Round(nVlVerba * aEncar[Nc,4],2)
						nHrsDiv := Round(nHrVerba * aEncar[Nc,4],2)
						nVlComp += nValDiv
						nHrComp += nHrsDiv
					Else
						nValDiv := nVlVerba - nVlComp
						nHrsDiv := nHrVerba - nHrComp
					EndIf  
					fMatriz(cVerba,nValDiv,nHrsDiv,,aEncar[Nc,1],cTip1,cTip2,,,dDtPgCc,.T.,cSeq,, Iif(lItemClVl, aEncar[Nc,5], Nil), Iif(lItemClVl, aEncar[Nc,6], Nil),cNumID, lEmpCons,,dDataRefB, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cTribuIR)
				Next Nc
			EndIf
		Next Nr
	EndIf
EndIf 

nValTot := 0

If nQtdDsr > 0 .And. !lProvPMes//-- Total de C.Custo de DSR s/ H.Extra
	//--Achar o Total da Base de Encargos
	aEval(aEncarDsr,{ |X| nValTot += X[3] })
	
	//--Gravar o Percentual de cada C.Custo lancado
	For n := 1  to nQtdDsr
		aEncarDsr[n,4] := aEncarDsr[n,3] / nValTot
		//--Quando for o mesmo valor 100 %
		If aEncarDsr[n,4] = 1.00
			aEncarDsr[n,4] := 100.000
		EndIf
	Next n
	
	nLugar := Ascan( aPd,{ |x| aCodFol[035,1] == x[1] })
	If nLugar > 0
		For Nr := nLugar to Len(aPd)
			//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
			If aPd[Nr,9]  # "D" .And. aPd[Nr,1] == aCodFol[035,1] .And. aPd[Nr,3] = cSemana
				nVlVerba := nVlComp := nHrVerba := nHrComp := 0.00
				cVerba   := aPd[Nr,1]
				cTip2	  := aPd[Nr,7]
				
				//-- Achar o valor total da Verba a ser Calc. por C.Custo
				For nV := 1 To Len(aPd)
					If cVerba == aPd[nV,1] .And. aPd[nV,9] # 'D' .And. aPd[nV,3] = cSemana .and. (aPd[nV,7] != "I" .and. cTip2 == aPd[nV,7])
						nVlVerba  	+= aPd[nV,5]
						nHrVerba  	+= aPd[nV,4]
						cTip1     	:= aPd[nV,6]          //--> Tipo da Verba( V,H,D )
						cTip2     	:= aPd[nV,7]          //--> Origem da Verba
						dDtPgCc		:= aPd[nV,10]			//--> Data Pagto de Origem
						aPd[nV,9] 	:= "D"
					EndIf
				Next nV
				
				//-- Divisao da Verba para cada c.custo
				For Nc := 1 to nQtdDsr
					If Nc # nQtdDsr
						nValDiv := Round(nVlVerba * aEncarDsr[Nc,4],2)
						nHrsDiv := Round(nHrVerba * aEncarDsr[Nc,4],2)
						nVlComp += nValDiv
						nHrComp += nHrsDiv
					Else
						nValDiv := nVlVerba - nVlComp
						nHrsDiv := nHrVerba - nHrComp
					EndIf
					If lItemClVl
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarDsr[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.,,,aEncarDsr[Nc,5],aEncarDsr[Nc,6])
					Else
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarDsr[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.)
					EndIf		
				Next Nc
			EndIf
		Next Nr
	EndIf
EndIf
nValTot:= 0 

If nQtdCom > 0 .And. !lProvPMes  //-- Total de C.Custo de DSR s/ Comissao
	//--Achar o Total da Base de Encargos
	aEval(aEncarCom,{ |X| nValTot += X[3] })
	
	//--Gravar o Percentual de cada C.Custo lancado
	For n := 1  to nQtdCom
		aEncarCom[n,4] := aEncarCom[n,3] / nValTot
		//--Quando for o mesmo valor 100 %
		If aEncarCom[n,4] = 1.00
			aEncarCom[n,4] := 100.000
		EndIf
	Next n
	
	nLugar := Ascan( aPd,{ |x| aCodFol[166,1] == x[1] })
	If nLugar > 0
		For Nr := nLugar to Len(aPd)
			//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
			If aPd[Nr,9]  # "D" .And. aPd[Nr,1] == aCodFol[166,1] .And. aPd[Nr,3] = cSemana
				nVlVerba := nVlComp := nHrVerba := nHrComp := 0.00
				cVerba   := aPd[Nr,1]
				cTip2	  := aPd[Nr,7]
				
				//-- Achar o valor total da Verba a ser Calc. por C.Custo
				For nV := 1 To Len(aPd)
					If cVerba == aPd[nV,1] .And. aPd[nV,9] # 'D' .And. aPd[nV,3] = cSemana .AND. (aPd[nV,7] != "I" .and. cTip2 == aPd[nV,7])
						nVlVerba  	+= aPd[nV,5]
						nHrVerba  	+= aPd[nV,4]
						cTip1     	:= aPd[nV,6]          //--> Tipo da Verba( V,H,D )
						cTip2     	:= aPd[nV,7]          //--> Origem da Verba
						dDtPgCc		:= aPd[nV,10]		   //--> Data Pagto de Origem
						aPd[nV,9] 	:= "D"
					EndIf
				Next nV
				
				//-- Divisao da Verba para cada c.custo
				For Nc := 1 to nQtdCom
					If Nc # nQtdCom
						nValDiv := Round(nVlVerba * aEncarCom[Nc,4], MsDecimais(1))
						nHrsDiv := Round(nHrVerba * aEncarCom[Nc,4],2)
						nVlComp += nValDiv
						nHrComp += nHrsDiv
					Else
						nValDiv := nVlVerba - nVlComp
						nHrsDiv := nHrVerba - nHrComp
					EndIf
					If lItemClVl
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarCom[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.,,,aEncarCom[Nc,5],aEncarCom[Nc,6])
					Else
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarCom[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.)
					EndIf		
				Next Nc
			EndIf
		Next Nr
	EndIf
EndIf  

nValTot:= 0 

If nQtdHtv > 0 .And. !lProvPMes //-- Total de C.Custo de DSR s/ Horas Atividade
	
	//--Achar o Total da Base de Encargos
	aEval(aEncarHtv,{ |X| nValTot += X[3] })

	//id.033 com 'S' p/ horas atividade e id.317 com 'N' p/ DSR
	lRecProf := lRecriaDsr .And.	RetValSRV(aCodFol[317,1],Sra->Ra_Filial,"Rv_DsrProf") == "N" .And.;
									RetValSRV(aCodFol[033,1],Sra->Ra_Filial,"Rv_HrsAtiv") == "S"
	If lRecProf
		//--Achar o Total da Base de Encargos
		nBsDProf := 0
		aEval(aEncarPro,{ |X| nBsDProf += X[3] })
		nDSRProf := nBsDsHt / nBsDProf  * nDSRProf
	EndIf
	
	If nDSRProf > 0
		nValTot += nDSRProf
		
		aPerc	:= {}
		nTDsrH	:= 0
		
		If lRecProf // .And. id.033 com 'S' p/ horas atividade e id.317 com 'N' p/ DSR
			aEncarAux := aClone(aEncarHrDs)
		Else
			aEncarAux := aClone(aEncarPro)
		EndIf
		
		//--Filtro dos valores das horas atividade dos c.custo que tem DSR
		For j := 1 To Len(aEncarHtv)
			If ( nPos := aScan( aEncarAux, { |x| x[1] == aEncarHtv[j,1] } ) ) > 0
				aAdd( aPerc, { aEncarAux[nPos,1], aEncarAux[nPos,3] } )
			EndIf
		Next
		
		//--Soma do valor do DSR distribuido por c.custo ao array das Horas Atividade,
		//--de acordo com o percentual de distribuicao do DSR por c.custo
		aEval( aPerc, { |x| nTDsrH += x[2] } )
		
		For z := 1 To Len(aPerc)
			aAdd( aPerc[z], aPerc[z,2] / nTDsrH * nDSRProf )
			If ( nPos := aScan( aEncarHtv, { |x| x[1] == aPerc[z,1] } ) ) > 0
				aEncarHtv[nPos,3] += aPerc[z,3]
			EndIf
		Next
	EndIf
	
	//--Gravar o Percentual de cada C.Custo lancado
	For n := 1  to nQtdHtv
		aEncarHtv[n,4] := aEncarHtv[n,3] / nValTot

		//--Quando for o mesmo valor 100 %
		If aEncarHtv[n,4] = 1.00
			aEncarHtv[n,4] := 100.000
		EndIf
	Next n
	
	nLugar := Ascan( aPd,{ |x| aCodFol[317,1] == x[1] })
	If nLugar > 0
		For Nr := nLugar to Len(aPd)
			//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
			If aPd[Nr,9]  # "D" .And. aPd[Nr,1] == aCodFol[317,1] .And. aPd[Nr,3] = cSemana
				nVlVerba := nVlComp := nHrVerba := nHrComp := 0.00
				cVerba   := aPd[Nr,1]
				cTip2	  := aPd[Nr,7]
				
				//-- Achar o valor total da Verba a ser Calc. por C.Custo
				For nV := 1 To Len(aPd)
					If cVerba == aPd[nV,1] .And. aPd[nV,9] # 'D' .And. aPd[nV,3] = cSemana .and. (aPd[nV,7] != "I" .and. cTip2 == aPd[nV,7])
						nVlVerba  	+= aPd[nV,5]
						nHrVerba  	+= aPd[nV,4]
						cTip1     	:= aPd[nV,6]          //--> Tipo da Verba( V,H,D )
						cTip2     	:= aPd[nV,7]          //--> Origem da Verba
						dDtPgCc		:= aPd[nV,10]		   //--> Data Pagto de Origem
						aPd[nV,9] 	:= "D"
					EndIf
				Next nV
				
				//-- Divisao da Verba para cada c.custo
				For Nc := 1 to nQtdHtv
					If Nc # nQtdHtv
						nValDiv := Round(nVlVerba * aEncarHtv[Nc,4], MsDecimais(1))
						nHrsDiv := Round(nHrVerba * aEncarHtv[Nc,4],2)
						nVlComp += nValDiv
						nHrComp += nHrsDiv
					Else
						nValDiv := nVlVerba - nVlComp
						nHrsDiv := nHrVerba - nHrComp
					EndIf
					If lItemClVl
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarHtv[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.,,,aEncarHtv[Nc,5],aEncarHtv[Nc,6])
					Else
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarHtv[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.)
					EndIf		
				Next Nc
			EndIf
		Next Nr
	EndIf
EndIf 

nValTot:= 0 

If nQtdPro > 0 .And. !lProvPMes //-- Total de C.Custo de DSR s/ Professor
	//--Achar o Total da Base de Encargos
	aEval(aEncarPro,{ |X| nValTot += X[3] })
	
	//id.033 com 'N' p/ horas atividade e id.317 com 'S' p/ DSR
	lRecProf := lRecriaDsr .And.	RetValSRV(aCodFol[317,1],Sra->Ra_Filial,"Rv_DsrProf") == "S" .And.;
									RetValSRV(aCodFol[033,1],Sra->Ra_Filial,"Rv_HrsAtiv") == "N"
									
	If lRecProf // .And. id.033 com 'S' p/ horas atividade e id.317 com 'N' p/ DSR
		//--Achar o Total da Base de Encargos
		nBsDProf := 0
		aEval(aEncarHtv,{ |X| nBsDProf += X[3] })
		nDSRProf := nBsDsHt / nBsDProf  * nHrsAtv
	EndIf
	
	If nHrsAtv > 0
		nValTot += nHrsAtv
		
		aPerc	:= {}
		nTDsrH	:= 0
		
		If lRecProf // .And. id.033 com 'S' p/ horas atividade e id.317 com 'N' p/ DSR
			aEncarAux := aClone(aEncarHrDs)
		Else
			aEncarAux := aClone(aEncarHtv)
		EndIf
		
		//--Filtro dos valores das horas atividade dos c.custo que tem DSR
		For j := 1 To Len(aEncarPro)
			If ( nPos := aScan( aEncarHrDs, { |x| x[1] == aEncarPro[j,1] } ) ) > 0
				aAdd( aPerc, { aEncarHrDs[nPos,1], aEncarHrDs[nPos,3] } )
			EndIf
		Next
		
		//--Soma do valor do DSR distribuido por c.custo ao array das Horas Atividade,
		//--de acordo com o percentual de distribuicao do DSR por c.custo
		aEval( aPerc, { |x| nTDsrH += x[2] } )
		For z := 1 To Len(aPerc)
			aAdd( aPerc[z], aPerc[z,2] / nTDsrH * nHrsAtv )
			If ( nPos := aScan( aEncarPro, { |x| x[1] == aPerc[z,1] } ) ) > 0
				aEncarPro[nPos,3] += aPerc[z,3]
			EndIf
		Next
	EndIf
	
	//--Gravar o Percentual de cada C.Custo lancado
	For n := 1  to nQtdPro
		aEncarPro[n,4] := aEncarPro[n,3] / nValTot
		//--Quando for o mesmo valor 100 %
		If aEncarPro[n,4] = 1.00
			aEncarPro[n,4] := 100.000
		EndIf
	Next n
	
	nLugar := Ascan( aPd,{ |x| aCodFol[033,1] == x[1] })
	If nLugar > 0
		For Nr := nLugar to Len(aPd)
			//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
			If aPd[Nr,9]  # "D" .And. aPd[Nr,1] == aCodFol[033,1] .And. aPd[Nr,3] = cSemana
				nVlVerba := nVlComp := nHrVerba := nHrComp := 0.00
				cVerba   := aPd[Nr,1]
				cTip2	  := aPd[Nr,7]
				
				//-- Achar o valor total da Verba a ser Calc. por C.Custo
				For nV := 1 To Len(aPd)
					If cVerba == aPd[nV,1] .And. aPd[nV,9] # 'D' .And. aPd[nV,3] = cSemana .and. (aPd[nV,7] != "I" .and. cTip2 == aPd[nV,7])
						nVlVerba  	+= aPd[nV,5]
						nHrVerba  	+= aPd[nV,4]
						cTip1     	:= aPd[nV,6]          //--> Tipo da Verba( V,H,D )
						cTip2     	:= aPd[nV,7]          //--> Origem da Verba
						dDtPgCc		:= aPd[nV,10]		   //--> Data Pagto de Origem
						aPd[nV,9] 	:= "D"
					EndIf
				Next nV
				
				//-- Divisao da Verba para cada c.custo
				For Nc := 1 to nQtdPro
					If Nc # nQtdPro
						nValDiv := Round(nVlVerba * aEncarPro[Nc,4], MsDecimais(1))
						nHrsDiv := Round(nHrVerba * aEncarPro[Nc,4],2)
						nVlComp += nValDiv
						nHrComp += nHrsDiv
					Else
						nValDiv := nVlVerba - nVlComp
						nHrsDiv := nHrVerba - nHrComp
					EndIf
					If lItemClVl
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarPro[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.,,,aEncarPro[Nc,5],aEncarPro[Nc,6])
					Else
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarPro[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.)
					EndIf		
				Next Nc
			EndIf
		Next Nr
	EndIf
EndIf  

If __lMemCalc 
	If (nQtd > 1 .Or. lRateio, fAddMemLog("Possui rateio por Centro de Custo? Sim.", 1, 2),fAddMemLog("Possui rateio por Centro de Custo? Não.", 1, 2))
EndIf

Return   

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fGPSVal   ºAutor  ³Andreia dos Santos  º Data ³  05/03/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna os valores cadastrados no parametro 15              º±±
±±º          ³- "Complementacao da GPS"                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cExp1 => Filial                                            º±±
±±º          ³ cExp2 => Ano/Mes a ser pesquisado                          º±±
±±º          ³ aExp3 => array que retornara os valores [1] Centro de Custoº±±
±±º          ³                                         [2] Verba          º±±
±±º          ³                                         [3] Base de Calculoº±±
±±º          ³                                         [4] Percentual     º±±
±±º          ³                                         [5] valor          º±±
±±º          ³                                         [6] Recol./Deducao º±±
±±º          ³                                         [7] Observacao     º±±
±±º          ³                                         [8] per.Inicio Compº±±
±±º          ³                                         [9] Per.Fim Compensº±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fGPSVal(cFil,cAnoMes,aGPSVal,cTpContr)
Local aArea 	:= GetArea()
Local aTabS035	:= {}
Local cTab		:= "S035"
Local nCont  	:= 0
Local nPos		:= 0
Local nTamCC 	:= TamSX3("RA_CC")[1]
Local dDataAux   := StoD(cAnoMes+"01")
Local dDataAnt	:= CtoD("")
Local lDicInter		:= FindFunction("fChkInterm") .And. fChkInterm()	
DEFAULT cTpContr := "1"

cCcInic	:= If ( Type("cCcInic")#"U" , cCcInic, Space(nTamCC))
cCcFina	:= If ( Type("cCcFina")#"U" , cCcFina, Replicate("z",nTamCC))
dDataAnt:= If ( Type("dDataRef")#"U" , dDataRef, CtoD(""))
cTpContr:= If ( cTpContr == " *12" .Or. cTpContr == " *123" .Or. cTpContr == "123", Iif(lDicInter,"4","3"), cTpContr)

//-Array aGPSVal                       
aGPSVal := {}

fCarrTab( @aTabS035, cTab, dDataAux, .T.,,.T. )

If IsIncallStack("GPEM610")
	cTpContr := Alltrim(StrTran(cTpContr, "*", ""))
EndIf
For nCont := 1 To Len(aTabS035)
	If ( cTpContr == Iif(lDicInter,"4","3") .Or. ( cTpContr != Iif(lDicInter,"4","3") .And. aTabS035[nCont, 12] == cTpContr ) ) .And.;
		If( Empty(aTabS035[nCont, 05]) , .T. , ( aTabS035[nCont, 05] >= cCcInic .And. aTabS035[nCont, 05] <= cCcFina ) )

			If aTabS035[nCont, 02] == cFil .Or. aTabS035[nCont, 02] == Space(FwGetTamFilial)
				If (nPos := aScan(aGPSVal,{|x| (x[10] == cFil .Or. Empty(x[10])) .And. x[11] == aTabS035[nCont, 12] .And. x[1] == aTabS035[nCont, 05] .And. x[2] == aTabS035[nCont, 06] })) == 0
					aAdd(aGPSVal,{	aTabS035[nCont, 05],;	// Centro de Custo
						 			aTabS035[nCont, 06],;	// Verba
									aTabS035[nCont, 07],;	// Base de Calculo 
									aTabS035[nCont, 08],;	// Percentual
									aTabS035[nCont, 09],;	// Valor           
									aTabS035[nCont, 10],;	// Recolhimento/Deducao           
									aTabS035[nCont, 11],;	// Observacao       
									aTabS035[nCont, 14]+aTabS035[nCont, 13],; // Ano/mes do periodo inicial de Compensacao
									aTabS035[nCont, 16]+aTabS035[nCont, 15],; // Ano/mes do periodo final de Compensacao
									aTabS035[nCont, 02],;
									aTabS035[nCont, 12]})		
				Else
					aGPSVal[nPos, 05] += aTabS035[nCont, 09]
					aGPSVal[nPos, 03] += aTabS035[nCont, 07]
				EndIf		
			EndIf				
	EndIf		
Next nCont

aSort(aGpsVal,,,{|x,y| x[1]+x[2]<y[1]+y[2]})

dDataRef := dDataAnt

RestArea(aArea)

Return ( .T. )

          

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³FBaseIni  ³ Autor ³ Leandro Drumond       ³ Data ³ 08.01.13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo da Base Inicial de IR.				              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FBaseIni()               						          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 												              ³±±
±±³          ³ 													          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FBaseIni()

Local cMesAnoDtPag 	:= MesAno(dData_Pgto)
Local lIrNeg		:= Len(aCodFol) >= 1726 .And. !Empty(aCodFol[1726,1]) .And. !Empty(aCodFol[1727,1]) 
Local cNoPd			:= aCodFol[6, 1] + "|" + aCodFol[1397, 1]

If RetValSRV(aCodFol[6,1],SRA->RA_FILIAL,"RV_IR") == "S" .And. Calcule == "S"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Soma Base de ir Mes Anterior Quando For Mesmo Mes            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Base_Ini := Val_Adto
	aEval( aPd, { |X| If( !(x[1] $ cNoPd) .and. x[7] $ "I*G", SomaInc( X, 5, @nBIrAdt, 13, "S", , , Month(dData_Pgto), , aCodFol ), Nil ) } )
	aEval( aPd, { |X| nBIrAdt += If( x[1] == aCodFol[10,1] .And. x[3] < cNumPag .And. x[9] # "D", x[5], 0 ) } )
	
	Base_Ini += nBIrAdt
	
	If ( Val_Adto + nBIrAdt ) > 0
		Aeval( aPd, { |X| Base_Ini += Iif( X[1] == aCodFol[106,1] .And. (cMesAnoDtPag == MesAno(X[10]) .Or. Empty(X[10])) .And. X[3] == cNumPag, X[5], 0 ) } )
		If lIrNeg
			Aeval(aPd,{ |X| Base_Ini -= If ( X[1]==aCodFol[1727,1] .And. (cMesAnoDtPag == MesAno(X[10]) .Or. Empty(X[10])),X[5],0) })
		EndIf
	EndIf										

EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³FM010IncIR ³ Autor ³ Leandro Drumond      ³ Data ³ 08.01.13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Soma IR.					     				              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FM010IncIR()              						          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 												              ³±±
±±³          ³ 													          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FM010IncIR()

Local aCodBenef		:= {}
Local cMesAnoDtPag 	:= MesAno(dData_Pgto)
Local cModTribAnt   := ""
Local lAchou        := .F.
Local lCalcPens     := IsInCallStack("fCalcPensao")
Local lMP1171       := ( cPaisLoc == "BRA" .And. Len(aTabIr) >= 7 .And. aTabIr[7, 4] == "S" .And. !lResExt )
Local nAliqComp     := 0
Local nAliqSimp     := 0
Local nDedPerAnt    := 0
Local nIR_BComp     := 0
Local nIR_BSimp     := 0
Local nIRComp       := 0
Local nIRSimp       := 0
Local nDescIr 		:= 0.00
Local nCntP
Local nIr_BasMV		:= 0
Local nIr_MV		:= 0
Local nPosBIrAnt	:= 0
Local nPosIrAnt		:= 0
Local n

Val_Peal := 0
IR_CALC  := 0
cMTribADI:= "1"

DEFAULT lVerMultv   := If ( Type("P_MULTV") == "U",.F.,P_MULTV)
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

If RetValSRV(aCodFol[6,1],SRA->RA_FILIAL,"RV_IR") == "S" .And. Calcule == "S"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Busca os codigos de pensao definidos no cadastro beneficiario³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	fBusCadBenef(@aCodBenef, "ADI", {aCodfol[58,1],aCodfol[174,1]})

	For nCntP := 1 To Len(aCodBenef)
		nPos := Ascan(aPD , { |X| X[1] == aCodBenef[nCntP,1] .And. X[9] # "D" })
		Val_Peal += IF(nPos > 0 , aPd[nPos,5] , 0)
	Next nCntP

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calculo do I.R.                                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If cPaisLoc == "PAR"   
		If !Empty(aTabIr)
    		If Len(aTabIr) > 1 .AND. Len(aTabIr) >= 5 
    			If !Empty(aTabIr[5,1]) .AND. !Empty(aTabIr[1,1]) 
					CALC_IR(@BASE_INI, @VAL_PEAL, @IR_CALC, @BASE_RED, @VAL_DEDDEP, @VAL_DEPEAL, aTabIr )			
				EndIf	
			EndIf	
		EndIf	
	Else
		If lVerMultv
			aEval( aPd, { |X| If ( x[1] $ aCodFol[992,1] .And. x[3] == cSemana .And. X[9] != "D" .and. x[11] == "9", nIr_BasMV += x[5], Nil ) } )
			aEval( aPd, { |X| If ( x[1] $ aCodFol[993,1] .And. x[3] == cSemana .And. X[9] != "D" .and. x[11] == "9", nIr_MV += x[5], Nil ) } )
		EndIf
		BASE_INI += nIr_BasMV
		If lMP1171
            nIR_BComp := BASE_INI
            nIR_BSimp := BASE_INI
            If RetValSRV(aCodFol[6, 1], SRA->RA_FILIAL, "RV_IR") == "S" .And. ( nPosBIrAnt := aScan( aPd, { |x| x[1] == aCodFol[106, 1] .And. x[9] != "D" } ) ) > 0
                If ( nPosIrAnt := aScan( aPd, { |x| x[1] == aCodFol[107, 1] .And. x[9] != "D" } ) ) > 0
                    cModTribAnt := Iif( Empty( aPd[nPosIrAnt, 28] ), "1", aPd[nPosIrAnt, 28] )
                Else
                    cModTribAnt := Iif( cPeriodo == "202305" .And. Empty( aPd[nPosBIrAnt, 28] ), "1", Iif( Empty( aPd[nPosBIrAnt, 28] ), "2", aPd[nPosBIrAnt, 28] ) )
                EndIf
                nDedPerAnt  := fDedPerAnt( cModTribAnt == "2" .And. nPosIrAnt == 0 .And. Empty( aPd[nPosBIrAnt, 28] ), @cModTribAnt, ( nPosIrAnt > 0 .And. Empty( aPd[nPosBIrAnt, 28] ) ) )
                If cModTribAnt == "1"
                    nIR_BSimp += nDedPerAnt
                Else
                    nIR_BComp -= nDedPerAnt
                    BASE_INI  := nIR_BComp
                EndIf
            EndIf
        EndIf
		If __lMemCalc			
			fAddMemLog("Modelo completo:", 1, 2)					
		EndIf
        CALC_IR(@BASE_INI, @VAL_PEAL, @IR_CALC, @BASE_RED, @VAL_DEDDEP, @VAL_DEPEAL, aTabIr,,@NALQIRADT )
        If lMP1171
			If __lMemCalc			
				fAddMemLog("Modelo simplificado:", 1, 2)					
			EndIf
            CALC_IR(nIR_BSimp, 0, @nIrSimp, 0, 0, 0, aTabIr, Nil, @nAliqSimp, lMP1171)
            If nIrSimp < IR_CALC .Or. (nIR_BSimp - aTabIr[7, 1] < BASE_INI - VAL_DEDDEP )
                cMTribADI    := "2"
                nAliqComp   := NALQIRADT
                nIRComp     := IR_CALC
                NALQIRADT   := nAliqSimp
                IR_CALC     := nIrSimp
                BASE_INI    := nIR_BSimp
            EndIf
        EndIf

		BASE_INI -= nIr_BasMV
		IR_CALC  -= nIr_MV
        If lMP1171
            Iif( cMTribADI == "1", nIR_BSimp -= nIr_BasMV, nIR_BComp -= nIr_BasMV )
            Iif( cMTribADI == "1", nIrSimp -= nIr_MV, nIRComp -= nIr_MV )
        EndIf
	EndIf	

	If RetValSRV(aCodFol[6,1],SRA->Ra_filial,"RV_IR") =="S" 
		nDescIr := 0
		Aeval(aPd,{ |X| nDescIr += If ( X[1]==aCodFol[107,1] .And. ;
												(cMesAnoDtPag == MesAno(X[10]) .Or. Empty(X[10])),X[5],0) })

		If cNumPag > "01"
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Verifica se ja Houve Imposto de Renda Descontado             ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            cPdPesq := If(aCodFol[12,1] # Space(3) ,aCodFol[12,1] , aCodFol[9,1] )

            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Somar os Descontos de Imposto de Renda de Adto. Anteriores   ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            For N=1 To Len(aPd)
                If aPd[N,1] == cPdPesq .And. aPd[N,9] # "D" .And. aPd[N,3] < cNumPag
                    lAchou  := .T.
                    nDescIR += aPd[n,5]
                EndIf
            Next

            If !lAchou
                For N := 1 To Len(aPd)
                    If aPd[N,1] == aCodFol[9,1] .And. aPd[N,9] # "D" .And. aPd[N,3] < cNumPag
                        nDescIR += aPd[n,5]
                    EndIf
                Next
            EndIf
        EndIf
		
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Abater do IR Calculado os Impostos de Renda Ja Pagos         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IR_CALC  -= nDescIR
        If lMP1171
            Iif( cMTribADI == "1", nIrSimp -= nDescIR, nIRComp -= nDescIR )
        EndIf
	EndIf
	If Ir_calc < 0  // Residuo do IR
		Vlr_res := Ir_calc * -1
		Ir_calc := 0
		fMatriz(aCodFol[63,1],Vlr_res,0.00, , ,"V","A")
    EndIf
	If __lMemCalc			
		fAddMemLog("Valor do desconto do IR: R$ " + AllTrim(Transform( IR_CALC, "@E 999,999,999,999.99" )), 1, 2)					
	EndIf
    If lMP1171 .And. !lCalcPens
        FMatriz( aCodfol[1919, 1], Iif( cMTribADI == "1", nIR_BSimp, nIR_BComp ), Nil, Nil, Nil, Nil, "A", Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif( cMTribADI == "1", "2", "1" ) )
        FMatriz( aCodfol[1920, 1], Iif( cMTribADI == "1", nIRSimp, nIRComp ), Iif( cMTribADI == "1", nAliqSimp, nAliqComp ), Nil, Nil, Nil, "A", Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif( cMTribADI == "1", "2", "1" ) )
        FMatriz( aCodfol[1924, 1], aTabIr[7, 1], Nil, Nil, Nil, Nil, "A" )
    EndIf
EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³f131CalcFg³ Autor ³ Mauro                 ³ Data ³ 07.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³  Calculo do FGTS 13O. 1o. parc                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ f131CalcFgts()                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/

Function F131CALCFGTS()
Local cTipo2
Local dDataIni
Local dDataFim
Local nBsFgtsAux
Local nAvosFgt
Local nAvosR		:= 0
Local nValAux		:= 0
Local nAvosAci		:= 0
Local nfgts13_Mil	:= 0
Local nPerFgts  	:= 0
Local nVal131Ant    := 0
Local lTCpoFgts 	:= ( Type("SRA->RA_PERFGTS") # "U" )
Local lTemId1848	:= Len(aCodFol) >= 1848 .And. !Empty(aCodFol[1848, 1])
Local lIdFuncPub	:= Len(aCodFol) >= 1956 .And. !Empty(aCodFol[1956, 1])

DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() //Memória de Cálculo

//--Verifica Qual Percentual de FGTS deve Aplicar
If lTCpoFgts .And. SRA->RA_PERFGTS > 0.00
	nPerFgts := SRA->RA_PERFGTS / 100
Else
	nPerFgts := If (SRA->RA_TPCONTR$ " *1",nFgtsCt1,nFgtsCt2)
Endif			

If Ascan(aPd,{ |X| X[1] = aCodfol[108,1] .And. X[9] # "D"}) = 0
	If __lMemCalc			
		fAddMemLog("Verbas com incidência para FGTS 13º:", 1, 2)					
	EndIf
	// PROCURA BASE DO FGTS
	nPos := Ascan(aPd,{ |X| X[1] = aCodfol[108,1] .And. X[9] # "D"} )
	nFgts_b := 0
	If nPos > 0
		nFgts_B := aPd[nPos,5]
	Else
		nFgts_B := 0.00
		// SOMA INCIDENCIA PARA BASE DE FGTS
		Aeval( aPd ,{ |X| SomaInc(X,6,@nFgts_b, , , , , , ,aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.) })

		// CALCULA FGTS COM BASE TOTAL SE AFASTAMENTO POR AUXILIO MATERNIDADE \ ADOCAO \ ACIDENTE 
		nAvosFgt := 0
	    Aeval( aAfast ,{ |X| nAvosFgt += If( Left( X[16], 1 ) $ "O*Q", X[1], 0 ) })
	    Aeval( aAfast ,{ |X| nAvosR += If( Left( X[16], 1 ) $ "R", X[1], 0 ) })
		If nAvosFgt+nAvosR > 0
			//Verifica se houve afastamento por acidente de trabalho para gerar a verba 1730
			Aeval( aAfast ,{ |X| nAvosAci += If( X[16] == "O1", X[1], 0 ) })
			
			If nAvosAci > 0 .and. nFgts_B > 0
				nValAux := nFgts_B - Iif( RetValSRV(cCodIns, SRA->RA_FILIAL, "RV_FGTS") == "S", nInsalub / 12 * nAvos * nPercentua, 0 ) - Iif(RetValSRV(cCodPer, SRA->RA_FILIAL, "RV_FGTS") == "S", nPeric / 12 * nAvos * nPercentua, 0)
				nValAux := Round( ( Iif( nValAux-Int(nValAux) == 0.33 .Or. nValAux-Int(nValAux) == 0.66, fRetDec(nValAux), nValAux ) - nVal_Arre ) / nAvos * (nAvosAci), 2 )
				FMatriz(aCodfol[1730,1],nValAux,0,cSemana,,,"P")
			EndIf
			
			// Quando há afastamento por maternidade, existem verbas de maternidade para 13 salário
			// Portanto, os avos de maternidade devem ser considerados na divisão
			If nAvosMat > 0
				If !lTemId1848
					nFgts_B 	:= Round( fRetDec(@nFgts_B-nVal_Arre) / ( nAvos + nAvosFgt + nAvosR )  * (nAvos + nAvosFgt + nAvosR), 2 )
				Else
					nfgts13_Mil := Round( nFgts_B / nAvos * nAvosR, 2 )
					nFgts_B 	:= Round( @nFgts_B-nVal_Arre / ( nAvos + nAvosFgt )  * (nAvos + nAvosFgt), 2 )
				EndIf
			Else
				If !lTemId1848
					If nAvosAci > 0 .and. nAvosAci == nAvosFgt
						nFgts_B += nValAux
					Else
						nFgts_B 	:= Round( fRetDec(@nFgts_B-nVal_Arre) / nAvos * (nAvos + nAvosFgt + nAvosR), 2 )
					EndIf
				Else
					nfgts13_Mil := Round( Iif( nFgts_B-Int(nFgts_B) == 0.33 .Or. nFgts_B-Int(nFgts_B) == 0.66, fRetDec(nFgts_B), nFgts_B ) / nAvos * nAvosR, 2 )
					If nAvosFgt > 0
						nFgts_B := Round( (nFgts_B-nVal_Arre) / nAvos * (nAvos + nAvosFgt - nAvosAci), 2 )
						nFgts_B += nValAux
					EndIf
				EndIf
			EndIf

				//Calcula FGTS para funcionario afastado durante todo o ano por licença Militar
			If nFgts_B == 0 .And. nAvosR == 12 .And. Left(SRA->RA_AFASFGT,1) == "R" .And. lTemId1848
				dDataIni    := If(cPeriodo == MesAno(SRA->RA_ADMISSA),SRA->RA_ADMISSA,CTOD("01/01/"+Substr(cPeriodo,1,4)))
				dDataFim    := CTOD("31/12/"+Substr(cPeriodo,1,4))
				nBsFgtsAux  := fBuscaAcm(aCodFol[1848,1],,dDataIni,dDataFim,"V")
				nFgts13_Mil	:= (((salmes - nBsFgtsAux) / 12)  * nAvosR) * nPercentua
			EndIf

  			cTipo2  := "P" //Indica tipo "1a. Parcela 13o. para nao ser deletado pela folha
		EndIf
		
		// CALCULA FGTS PARA FUNCIONARIO AFASTADO POR ACIDENTE E ADOCAO ou APOSENTADO COM AVOS DE FGTS PARA RECEBER
		If nFgts_B == 0 .And. nAvosFgt > 0 .And. ( Left(SRA->RA_AFASFGT,1) $ "O*Q*R*X" .or. SRA->RA_AFASFGT $ "U3" )
			//Se houve pagamento de adicionais e a verba não incorporou o salário, soma na base
			If nAdtServ > 0 .and. RetValSRV(aCodFol[1630,1],SRA->RA_FILIAL,"RV_INCORP") == "N"
				nFgts_B += nAdtServ
			EndIf
			If nIntPercul > 0 .And. RetValSRV(aCodFol[1632,1],SRA->RA_FILIAL,"RV_INCORP") == "N" .And. !(SRA->RA_AFASFGT $ "O1*O2")
				nFgts_B += nIntPercul
			EndIf
			If nIntInsal > 0 .And. RetValSRV(aCodFol[1634,1],SRA->RA_FILIAL,"RV_INCORP") == "N" .And. !(SRA->RA_AFASFGT $ "O1*O2")
				nFgts_B += nIntInsal
			EndIf
			If nAdcConf > 0 .and. RetValSRV(aCodFol[1636,1],SRA->RA_FILIAL,"RV_INCORP") == "N"
				nFgts_B += nAdcConf
			EndIf
			If nAdcTrf > 0 .and. RetValSRV(aCodFol[1637,1],SRA->RA_FILIAL,"RV_INCORP") == "N"
				nFgts_B += nAdcTrf
			EndIf
  			nFgts_B += Salmes
  			
			If nAvosAci > 0
				nValAux 	:= nFgts_B
				nValAux 	:= Round( (nValAux-nVal_Arre) / 12 * (nAvosAci), 2 )
				nValAux 	:= nValAux * nPercentual
				nVal131Ant	:= fBuscaAcm(aCodfol[1730,1],,StoD(SubStr(cPeriodo,1,4)+"0101"),StoD(SubStr(cPeriodo,1,4)+"1231"),"V") 
				nValAux 	-= nVal131Ant
				If nValAux > 0
					fMatriz(aCodfol[1730,1],nValAux,0,cSemana,,,"P")
				EndIf
			EndIf 
			
			nFgts_B := Round( nFgts_B / 12 * nAvosFgt, 2 )
  			nFgts_B := nFgts_B * nPercentual
  			
  			// Busca base de FGTS no acumulado para evitar gerar nova base
			If nAvosFgt > 0 .And. nFgts_B > 0 
		   		dDataIni   := If(cPeriodo == MesAno(SRA->RA_ADMISSA),SRA->RA_ADMISSA,CTOD("01/01/"+Substr(cPeriodo,1,4)))
				dDataFim   := CTOD("31/12/"+Substr(cPeriodo,1,4))
				nBsFgtsAux := fBuscaAcm(aCodFol[108,1],,dDataIni,dDataFim,"V")
				nFgts_B    := Max( nFgts_B - nBsFgtsAux, 0 )
			EndIf
		EndIf
	EndIf

	FMatriz(aCodfol[109,1],NoRound((nFgts_B+nFgts13_Mil) * nPerFgts ),0,cSemana,,,cTipo2)
	FMatriz(aCodfol[108,1],nFgts_B,0,cSemana,,,cTipo2)
	If lTemId1848
		FMatriz(aCodfol[1848,1],nFgts13_Mil,0,cSemana,,,cTipo2)
	EndIf

	If __lMemCalc .And. nFgts_B > 0	 
		fAddMemLog("Base FGTS 13º: R$ " + AllTrim(Transform( nFGTS_B, "@E 999,999,999,999.99" )), 1, 2)		
		fAddMemLog("Cálculo do FGTS 13º: R$ " + AllTrim(Transform( nFGTS_B+nFgts13_Mil, "@E 999,999,999,999.99" )) + " * " +cValToChar(nPerFgts), 1, 2)	
		fAddMemLog("FGTS do mês 13º: R$ " + AllTrim(Transform( (nFgts_B+nfgts13_Mil) * nPerFgts, "@E 999,999,999,999.99" )), 1, 2)					
	EndIf
    
	//ID gerado para o eSocial, S-1202 - Remuneração de servidor vinculado a RPPS
	If lIdFuncPub .And. SRA->RA_TPPREVI == "2" .And. !SRA->RA_VIEMRAI $ "30*31*35"
		FMatriz(aCodfol[1956,1],nFgts_B,0,cSemana,,,cTipo2)
	EndIf
EndIf 

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Calc_Ir  ³ Autor ³ Mauro                 ³ Data ³ 03.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao para Calcular Imp. de Renda                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Calc_Ir( nBaseIni, nPenAl, nIrCalc, nBaseRed, nDedDep, nDepeAl, aTabIr, lIrMin, nAliq, lMP1171 )

Local aArea		    := GetArea()

DEFAULT lIrMin	    := If( lIrMin = Nil, .T., lIrMin )
DEFAULT lMP1171     := .F.
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

lResExt		:= If( Type("lResExt")		== "U", .F.		, lResExt)
lAutMEI		:= If( Type("lAutMEI")		== "U", .F.		, lAutMEI)
nPercIRREx	:= If( Type("nPercIRREx")	== "U", 25.00	, nPercIRREx)
lIrResExt	:= If( Type("lIrResExt")	== "U", .T.		, lIrResExt)

//Para MEI nao ira calcular o IR
If lAutMEI
	Return
Endif

If ! lResExt
	nAliq    := 0
	nBaseIni -= nPenAl
	nPenAl   := 0
	nBaseRed := nBaseIni
EndIf

If nBaseIni <= 0
	nDedDep := 0.00
	Return Nil
EndIf

// DEDUCAO POR DEPENDENTES
If nDedDep # Nil .and. !lResExt
	//-- Para o modulo PLS - Plano de Saude a variavel nDedDep sempre tem a quantidade de dependentes informada
	//-- e nem sempre para o GPE envia a quantidade de dependente nesta variavel.
	If cModulo $ ("GPE/GFP")
		nDedDep := aTabIr[5,1] * (If(VAL(SRA->RA_DEPIR) > aTabIr[5,2],aTabIr[5,2],VAL(SRA->RA_DEPIR)))
	Else
		nDedDep := aTabIr[5,1] * If(nDedDep > aTabIr[5,2],aTabIr[5,2],nDedDep)
	EndIf
Else
	nDedDep := 0.00
EndIf
If nBaseIni > 0 .And. __lMemCalc 
	fAddMemLog("Base do cálculo: R$ " + AllTrim(Transform( nBaseIni, "@E 999,999,999,999.99" )),1,3)
EndIf
If !lMP1171
    nBaseRed := nBaseIni - nDedDep
	If nDedDep > 0 .And. __lMemCalc 
		fAddMemLog("Dedução de dependente: R$ " + AllTrim(Transform( nDedDep, "@E 999,999,999,999.99")) ,1,3)
	EndIf
Else
    nBaseRed -= aTabIr[7, 1]//Dedução Simplificada
	If __lMemCalc 
		fAddMemLog("Dedução simplificada: R$ " +  AllTrim(Transform( aTabIr[7, 1], "@E 999,999,999,999.99" )),1,3)
	EndIf
EndIf

If nBaseRed <= aTabIr[1,1] .and. !lResExt
	If __lMemCalc 
		fAddMemLog(IIF(nBaseRed <> nBaseIni,"Base após deduções: R$ " +  AllTrim(Transform( nBaseRed, "@E 999,999,999,999.99" ))+"(Isento de IR)", " (Isento de IR)"),1,3)
	EndIf
	nBaseRed := 0	
	Return Nil
EndIf

// DEDUCAO POR PENSAO ALIMENTICIA
If !lResExt
	If aTabIr[1,1] - (nBaseRed - nPenAl) < 0
		nDepeAl := nPenAl
	Else
		nDepeAl := nBaseRed - aTabIr[1,1]
	EndIf
Else
	nDepeAl := 0
EndIf

nBaseRed -= nDepeAl
If nBaseRed <= aTabIr[1,1] .and. !lResExt
	nBaseRed := 0
	Return Nil
EndIf
If nBaseRed > 0 .And. nBaseRed<> nBaseIni .And. __lMemCalc 
	fAddMemLog("Base após deduções: R$ " +  AllTrim(Transform( nBaseRed, "@E 999,999,999,999.99" )),1,3)
EndIf
If !lResExt
	// CALCULO DO IR SOBRE A TABELA
	If __lMemCalc 
		fAddMemLog("Cálculo do IR sobre a tabela: ",1,3)
	EndIf
	If nBaseRed <= aTabIr[1,1]
		nBaseRed := 0
		Return Nil
	Elseif nBaseRed <= aTabIr[2,1]
		nIrCalc := (nBaseRed * (aTabIr[2,2]/100))-aTabIr[2,3]
		nAliq   := aTabIr[2,2]
		If __lMemCalc 
			fAddMemLog(AllTrim(Transform(nBaseRed, "@E 999,999,999,999.99" ))+" * "+cvaltochar(aTabIr[2,2])+"% - "+AllTrim(Transform(aTabIr[2,3], "@E 999,999,999,999.99" ))+ " (parcela a deduzir do IR) = R$ "+ AllTrim(Transform(INT( nIrCalc * 100 ) / 100, "@E 999,999,999,999.99" )),1,4)
		EndIf
	Elseif nBaseRed <= aTabIr[3,1]
		nIrCalc := (nBaseRed * (aTabIr[3,2]/100))-aTabIr[3,3]
		nAliq   := aTabIr[3,2]
		If __lMemCalc 
			fAddMemLog(AllTrim(Transform(nBaseRed, "@E 999,999,999,999.99" ))+" * "+cvaltochar(aTabIr[3,2])+"% - "+AllTrim(Transform(aTabIr[3,3], "@E 999,999,999,999.99" ))+ " (parcela a deduzir do IR) = R$ "+ AllTrim(Transform(INT( nIrCalc * 100 ) / 100, "@E 999,999,999,999.99" )),1,4)
		EndIf
	Elseif nBaseRed <= aTabIr[4,1]
		nIrCalc := (nBaseRed * (aTabIr[4,2]/100))-aTabIr[4,3]
		nAliq  := aTabIr[4,2]
		If __lMemCalc 
			fAddMemLog(AllTrim(Transform(nBaseRed, "@E 999,999,999,999.99" ))+" * "+cvaltochar(aTabIr[4,2])+"% - "+AllTrim(Transform(aTabIr[4,3], "@E 999,999,999,999.99" ))+ " (parcela a deduzir do IR) = R$ "+ AllTrim(Transform(INT( nIrCalc * 100 ) / 100, "@E 999,999,999,999.99" )),1,4)
		EndIf
	Else
		nIrCalc := (nBaseRed * (aTabIr[6,2]/100))-aTabIr[6,3]
	    nAliq  := aTabIr[6,2]
		If __lMemCalc 
			fAddMemLog(AllTrim(Transform(nBaseRed, "@E 999,999,999,999.99" ))+" * "+cvaltochar(aTabIr[6,2])+"% - "+AllTrim(Transform(aTabIr[6,3], "@E 999,999,999,999.99" ))+ " (parcela a deduzir do IR) = R$ "+ AllTrim(Transform(INT( nIrCalc * 100 ) / 100, "@E 999,999,999,999.99" )),1,4)
		EndIf
	EndIf

ElseIf lIrResExt // Residentes no exterior
	nIrCalc	:= nBaseRed * ( nPercIRREx / 100 )
	nAliq  	:= nPercIRREx
EndIf

nIrCalc = INT( nIrCalc * 100 ) / 100  // DEIXA O VALOR COM 2 CASAS APOS A VIRGULA

// VERIFICA RETENCAO
If nIrCalc < aTabIr[5,3] .And. lIrMin .and. !lResExt
	nIrCalc  := 0
	nBaseRed := 0
EndIf  

RestArea( aArea )

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Calc_IrRRA³ Autor ³ Leandro Drumond       ³ Data ³ 28.06.12³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao para Calcular Imp. de Renda sobre RRA               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Calc_IrRRA(nBaseIni,nPenAl,nIrCalc,nBaseRed,nDedDep,nDepeAl,aTabIr,lIrMin,nAliq,nMesesRRA)

lAutMEI		:= If( Type("lAutMEI")		== "U", .F.,	lAutMEI)
lResExt		:= If( Type("lResExt")		== "U", .F.,	lResExt)
nPercIRREx	:= If( Type("nPercIRREx")	== "U", 25.00,	nPercIRREx)
lIrResExt	:= If( Type("lIrResExt")	== "U", .T.,	lIrResExt)

//Para MEI nao ira calcular o IR
If lAutMEI
	Return
Endif

If !lResExt
	lIrMin   := If (lIrMin = Nil , .T. , lIrMin)
	nAliq    := 0
	nBaseIni -= nPenAl
	nPenAl   := 0
	nBaseRed := nBaseIni
EndIf

If nBaseIni <= 0
	nDedDep := 0.00
	Return Nil
EndIf

// DEDUCAO POR DEPENDENTES
If nDedDep # Nil .and. !lResExt
	nDedDep := aTabIr[20] * (If(VAL(SRA->RA_DEPIR) > aTabIr[21],aTabIr[21],VAL(SRA->RA_DEPIR)))
Else
	nDedDep := 0.00
EndIf

//nBaseRed := nBaseIni - nDedDep -- Nao eh para deduzir dependente no RRA.

If nBaseRed <= ( aTabIr[7] * nMesesRRA ) .and. !lResExt
	Return Nil
EndIf

// DEDUCAO POR PENSAO ALIMENTICIA
If !lResExt
	If ( aTabIr[7] * nMesesRRA )  - (nBaseRed - nPenAl) < 0
		nDepeAl := nPenAl
	Else
		nDepeAl := nBaseRed - ( aTabIr[7] * nMesesRRA )
	EndIf
Else
	nDepeAl := 0
EndIf

nBaseRed -= nDepeAl
If nBaseRed <= ( aTabIr[7] * nMesesRRA ) .and. !lResExt
	nBaseRed := 0
	Return Nil
EndIf

If !lResExt
	// CALCULO DO IR SOBRE A TABELA
	// SE MENOR OU IGUAL AO VALOR DE ISENCAO VEZES A QUANTIDADE DE MESES, NAO CALCULA NADA
	If nBaseRed <= aTabIr[7] * nMesesRRA
		nBaseRed := 0
		Return Nil
	// SE MENOR QUE FAIXA 2, UTILIZA FAIXA 1 PARA O CALCULO
	Elseif nBaseRed <= ( aTabIr[11] * nMesesRRA )
		nIrCalc := (nBaseRed * (aTabIr[9]/100))-( aTabIr[10] * nMesesRRA )
		nAliq   := aTabIr[9]
	// SE MENOR QUE FAIXA 3, UTILIZA FAIXA 2 PARA O CALCULO
	Elseif nBaseRed <= ( aTabIr[14] * nMesesRRA )
		nIrCalc := (nBaseRed * (aTabIr[12]/100))-( aTabIr[13] * nMesesRRA )
		nAliq   := aTabIr[12]
	// SE MENOR QUE FAIXA 4, UTILIZA FAIXA 3 PARA O CALCULO
	Elseif nBaseRed <= ( aTabIr[17] * nMesesRRA )
		nIrCalc := (nBaseRed * (aTabIr[15]/100))-( aTabIr[16] * nMesesRRA )
		nAliq   := aTabIr[15]
	// SE MAIOR OU IGUAL FAIXA 4, UTILIZA FAIXA 4 PARA O CALCULO
	Else
		nIrCalc := (nBaseRed * (aTabIr[18]/100))-( aTabIr[19] * nMesesRRA )
	   nAliq  := aTabIr[18]
	EndIf

ElseIf lIrResExt .And. lIrResExt	//Residentes no exterior
	nIrCalc := (nBaseRed * nPercIrRex) / 100
	nAliq := nPercIrRex
EndIf

nIrCalc = INT( nIrCalc * 100 ) / 100  // DEIXA O VALOR COM 2 CASAS APOS A VIRGULA

// VERIFICA RETENCAO
If nIrCalc < aTabIr[22] .And. lIrMin .and. !lResExt
	nIrCalc  := 0
	nBaseRed := 0
EndIf

Return Nil



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Calc_Inss ³ Autor ³ Mauro                 ³ Data ³ 28.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao para Calcular I.N.S.S.                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Calc_Inss(aInss)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Calc_Inss(aTInss, nBase, nInss, nInss1, nBaseAt, nBaseAc, nAliq, nBaseOut, lTrunca, nBsComp, aInssFx, lEsocial, nAliqEsoc, nBsAutOut, lImpCalc)

Local nBase1	:= nBase
Local nBaseCalc := 0
Local nT 		:= 0
Local nINSSAux	:= 0
Local nBaseAux	:= 0
Local nPerc102  := If(Type("P_INSS102") != "U", P_INSS102, 0)
Local lNovoCalc := aTInss[1,4] == "S"

Default lEsocial  := .F.
Default nBsAutOut := 0
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo
DEFAULT lImpCalc := .T.

lTrunca 	:= If (lTrunca = Nil , .T. , lTrunca)
nBaseAc		:= 0.00
nBaseOut	:= If( nBaseOut == NIL .or. ValType( nBaseOut ) != "N" , 0.00 , nBaseOut )
nBsComp     := If( nBsComp # Nil .And. nBsComp > 0, nBsComp, nBase1 )
lDissidio	:= If( lDissidio == Nil,.F.,lDissidio ) 
nBsOutAux   := nBaseOut

If nBaseOut > 0 .And. nBsAutOut > 0
	If nBsComp > aTinss[Len(aTinss), 1]
		nBaseAux  := nBase1 - nBsAutOut
		nBsComp   := aTinss[Len(aTinss), 1] - nBsAutOut
		nBase1    := aTinss[Len(aTinss), 1] - nBsAutOut
		nBsOutAux -= nBsAutOut
		If nBsComp <= 0 .And. nBaseAux > 0 .And. lNovoCalc 
			nBaseAt := If(aTinss[Len(aTinss), 1] >= nBaseAux, nBaseAux, aTinss[Len(aTinss), 1])
			nBaseac := Max(nBaseAux - nBaseAt, 0)
		EndIf
	Else
		nBsComp   -= nBsAutOut
		nBase1    -= nBsAutOut
		nBsOutAux -= nBsAutOut
	EndIf 
EndIf 

If nBsComp > 0.00
	If __lMemCalc .And. lImpCalc  			
		fAddMemLog("Base do cálculo: R$ " + AllTrim(Transform( nBsComp, "@E 999,999,999,999.99" )), 1, 2)
		If (lNovoCalc,fAddMemLog("Cálculo do INSS por faixa:", 1, 2),fAddMemLog("Cálculo do INSS :", 1, 2) )					
	EndIf
	If SRA->RA_CATEFD == "102" .and. nPerc102 > 0 //Trabalhador rural, INSS fixo em 8% (P_INSS102)
		nBaseCalc := If ( nBase1 < aTinss[Len(aTinss),1] , nBase1 , aTinss[Len(aTinss),1])
        nInss     := If (lTrunca, NoRound(nBaseCalc * nPerc102,2),Round(nBaseCalc * nPerc102,2))
        nInss1    := nInss
        nAliq     := Round(nPerc102 * 100 ,2)
        nBaseAt   := Max(nBaseCalc - nBaseOut , 0 )
        nBaseac   := nBase1 - nBaseOut - nBaseAt	
	ElseIf SRA->RA_CATFUNC $ "P*A"
		nBaseCalc := If ( nBase1 < aTinss[Len(aTinss),1] , nBase1 , aTinss[Len(aTinss),1])
        nInss     := If (lTrunca, NoRound(nBaseCalc * P_PERCAUTO,2),Round(nBaseCalc * P_PERCAUTO,2))
        nInss1    := nInss
        nAliq     := Round(P_PERCAUTO * 100 ,2)
        nBaseAt   := Max(nBaseCalc - nBaseOut , 0 )
        nBaseac   := nBase1 - nBaseOut - nBaseAt
	Else
		If lNovoCalc
			nInss  := 0
			nInss1 := 0
			nBaseAt:= 0
			aInssFx:= Array(4,2)
			For nT := 1 to 4
				aInssFx[nT,1] := 0
				aInssFx[nT,2] := 0
			Next nT
		EndIf		
	    For nT=1 to Len(aTInss)
			If lNovoCalc //Novo formato de cálculo de INSS - Emenda Constitucional 103				
				If nBsComp <= aTInss[nT,1]
					nBaseCalc := If ( nT == 1, nBase1, nBase1 - aTinss[nT-1,1] )
					nInssAux  := If (lTrunca ,NoRound(nBaseCalc * aTInss[nT,2],2),Round(nBaseCalc * aTInss[nT,2],2))
					aInssFx[nT,1] := nInssAux
					aInssFx[nT,2] := Round(aTInss[nT,2] * 100 ,2)
					nInss     += nInssAux
					nInss1    += If (lTrunca ,NoRound(nBaseCalc * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2),Round(nBaseCalc * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2))
					nAliq     := Round(aTInss[nT,2] * 100 ,2)
					nBaseAt   += nBaseCalc
					If __lMemCalc .And. lImpCalc 
						fAddMemLog("Faixa "+cValToChar(nT)+" (até "+AllTrim(Transform(aTinss[nT,1],"@E 999,999,999,999.99"))+")"+If(nT>1,": ("+AllTrim(Transform(nBsComp,"@E 999,999,999,999.99"))+" - "+AllTrim(Transform(aTinss[nT-1,1],"@E 999,999,999,999.99"))+") = ", ": ")+AllTrim(Transform(nBaseCalc,"@E 999,999,999,999.99"))+" * "+cValToChar(nAliq)+"% = " + AllTrim(Transform(aInssFx[nT,1], "@E 999,999,999,999.99" )), 1, 3)
					EndIf					
					Exit
				Else
					nBaseCalc := If ( nT == 1, aTinss[nT,1], aTinss[nT,1] - aTinss[nT-1,1] )
					nInssAux  := If (lTrunca, NoRound(nBaseCalc * aTInss[nT,2],2),Round(nBaseCalc * aTInss[nT,2],2))
					aInssFx[nT,1] := nInssAux
					aInssFx[nT,2] := Round(aTInss[nT,2] * 100 ,2)
					nInss     += nInssAux
					nInss1    += If (lTrunca, NoRound(nBaseCalc * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2),Round(nBaseCalc * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2))
					nAliq     := Round(aTinss[nT,2] * 100 ,2)
					nBaseAt   += nBaseCalc
					If __lMemCalc .And. lImpCalc 
						fAddMemLog("Faixa "+cValToChar(nT)+" (até "+AllTrim(Transform(aTinss[nT,1],"@E 999,999,999,999.99"))+")"+If(nT>1,": ("+AllTrim(Transform(aTinss[nT,1],"@E 999,999,999,999.99"))+" - "+AllTrim(Transform(aTinss[nT-1,1],"@E 999,999,999,999.99"))+") = ", ": ")+AllTrim(Transform(nBaseCalc,"@E 999,999,999,999.99"))+" * "+cValToChar(nAliq)+"% = " + AllTrim(Transform(aInssFx[nT,1], "@E 999,999,999,999.99" )), 1, 3)
					EndIf
				EndIf
			Else //Formato anterior
				If nBsComp <= aTInss[nT,1]
					nInss     := If (lTrunca ,NoRound(nBase1 * aTInss[nT,2],2),Round(nBase1 * aTInss[nT,2],2))
					nInss1    := If (lTrunca ,NoRound(nBase1 * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2),Round(nBase1 * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2))
					nAliq     := Round(aTInss[nT,2] * 100 ,2)
					nBaseAt   := nBase1 - nBsOutAux
					Exit
				ElseIf nT == Len(aTInss)
					nBaseCalc := If ( nBase1 < aTinss[nT,1],nBase1,aTinss[nT,1])
					nInss     := If (lTrunca, NoRound(nBaseCalc * aTInss[nT,2],2),Round(nBaseCalc * aTInss[nT,2],2))
					nInss1    := If (lTrunca, NoRound(nBaseCalc * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2),Round(nBaseCalc * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2))
					nAliq     := Round(aTinss[nT,2] * 100 ,2)
					nBaseAt   := Max(nBaseCalc - nBsOutAux , 0 )
					nBaseac   := nBase1 - nBsOutAux - nBaseAt
				EndIf
			EndIf
	    Next nT
		If nInss > 0 .And. __lMemCalc .And. lImpCalc   
			fAddMemLog("Valor do desconto do INSS: R$ " + AllTrim(Transform(nInss, "@E 999,999,999,999.99" )), 1, 2)
		EndIf
		If lNovoCalc
			If lEsocial
				nAliqEsoc := nAliq
			EndIf			
			nAliq	:= 0 //Zera aliquota
			nBaseAt := Max(nBaseAt - nBsOutAux, 0)
			nBaseac := Max(nBase - nBaseOut - nBaseAt, 0)
		EndIf
	EndIf
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCInss   ³ Autor ³ Equipe RH             ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Inss Funcionario Normal e Ferias                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCInss(aCodfol)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCInss(aCodfol,aTinss,lTrunca)

Local aIN2110   := {}
Local cSeqIN2110:= " "
Local nAteAnt	:= 0.00
Local nAciAnt	:= 0.00
Local nBAt2110  := 0.00
Local nBAc2110  := 0.00
Local nCntIN2110:= 0.00
Local nIN2110   := 0.00 
Local nInssAnt	:= 0.00          
Local nInssAnt1	:= 0.00
Local nInssAnt2	:= 0.00
Local nInssAnt3	:= 0.00
Local nPosIN2110:= 0.00
Local nAliq		:= 0.00
Local nBaseOut	:= 0.00
Local nBaseOutI	:= 0.00
Local nInssOut	:= 0.00
Local nBaseTot	:= 0.00
Local nInss_Ou	:= 0.00
Local nInss_O1	:= 0.00
Local nInssFer	:= 0.00
Local nId0168	:= 0.00
Local nInssFol	:= 0.00
Local nBsMater  := 0.00
Local nNumFer	:= 0.00
Local nInsfeFec	:= 0.00
Local nRegAnt	:= 0.00
Local nRefAut   := 0.00
Local nAuxInssF := 0.00
Local nPosPd
Local nBaseTeto := 0
Local nTetoInss := 0
Local lAumFer	:= .F. //Teve aumento durante as ferias integralmente gozadas
Local lInfTeto	:= .F.
Local lSInssOut := .F.
Local nDiasMs       
Local dDtPgFer  := cToD("")
Local cAlias	:= ""
Local cInssOri 	:= ""
Local nPosFer 	:= 0
Local nFerInc	:= 0
Local nPosInc  	:= 0
Local nX       	:= 0
Local nDedFer	:= 0
Local nBsAutOut := 0
Local cQuery   	:= ""
Local cAliasQry	:= ""
Local lId1449	:= (Len(aCodFol) >= 1449)
Local nInssFOut	:= 0
Local lMultv    := Type("lUtiMultiV") <> "U" .And. lUtiMultiV
Local aPdBkp    := {}
Local aPdFx		:= {aCodFol[1734,1], aCodFol[1735,1], aCodFol[1736,1], aCodFol[1737,1]}
Local aInssFx	:= {}
Local lIntTaf   := ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 2 )
Local nVl0065	:= 0
Local nDedFerMes:= 0

Private lRecInss :=GetNewPar('MV_INSSREC',.F.)  // Recalculo INSS quando rescisao complementar

DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo
If lMultv
	nAliqFMV  := 0
	lTetoINSS := .F.
EndIf

lResExt	    := If( Type("lResExt") 	    == "U"	, .F., lResExt)
lDedInssEx	:= If( Type("lDedInssEx") 	== "U"	, .F., lDedInssEx)
lIrResExt	:= If( Type("lIrResExt") 	== "U"	, .T., lIrResExt)
lInssAut	:= If( Type("lInssAut") 	== "U"	, .T., lInssAut)

// Para os casos em que o funcionário não é autonomo, pode haver acordo
// Entre o Brasil e outros paises, para o não desconto do INSS.
// Para tratar esses acordos o campo RA_INSSAUT é utilizad.
// Se estiver com NÃO, NÃO deverá calcular INSS, independente do RA_CATFUNC.
If cPaisLoc == "BRA" .and. (!lInssAut)
	Return
EndIf

//--Situacao do Funcionario na data de referencia
cSitFolh	:= If( Type("cSitFolh")=="U",SRA->RA_SITFOLH,cSitFolh)
lDissidio	:= If(lDissidio == Nil,.F.,lDissidio) 
lTrunca 	:= If (lTrunca = Nil , .T. , lTrunca)
lRescDis	:= If( type("lRescDis")=="U",.F.,lRescDis)//Rescisao Complementar por Dissidio

If lRescDis .and. !lProxMes
	nRegAnt	:= SRG->(Recno())
	SRG->(DbGoTo(nRegSrg))
	SRR->(DbSetOrder(1)) //RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC
EndIf

//Variável do TETO do INSS.
nBaseTeto := aTinss[Len(aTinss), 1]
nTetoInss := fRetTetIns(aTinss)

aEval( aPd, { |x| nBaseOutI += Iif( x[1] == aCodFol[396, 1] .And. x[9] # "D", x[5], 0) } )
lInfTeto := (nBaseTeto == nBaseOutI)

//INSS para semanalista no caso de dissidio
If lDissidio .And. SRA->RA_TIPOPGT = "S"
	cAlias := GetNextAlias()
	cSql := " SELECT RV_CODFOL,RHH_VB,RHH_CALC,RHH_SEQ FROM "+RetSqlName("RHH")+" RHH"
	cSql += " LEFT JOIN "+RetSqlName("SRV")+" SRV ON RV_COD=RHH_VB AND RV_FILIAL ='"+xFilial("SRV")+"' and SRV.D_E_L_E_T_=''"
	cSql += " WHERE RHH.D_E_L_E_T_= ' '"
	cSql += " AND RHH_MAT='"+SRA->RA_MAT+"'"
	cSql += " AND RHH_DATA='"+cPeriodo+"'"
	cSql += " AND RHH_SEQ < '" + Alltrim(str(Val(cSemana))) + "'"
	cSql += " AND RV_CODFOL IN('0013','0014','0064','0065','0167','0168','0032','0031')"       //
	cSql := changeQuery(csql)
	dbUseArea( .T., "TOPCONN", TcGenQry( ,,cSql ), cAlias )
	While !(cAlias)->(Eof())
		fMatriz((cAlias)->RHH_VB,(cAlias)->RHH_CALC,,Strzero(val((cAlias)->RHH_SEQ),2))
		(cAlias)->(dbskip())
	EndDo                   
	(cAlias)->(dbCloseArea())
EndIf

If !Empty( aCodFol[288,1] ) //Base Inss Outras Empresas
	If Type("aInssOut") == "A" .And. Len(aInssOut) > 0 .And. aScan(aInssOut,{|x| x[5] == SRA->RA_CIC}) > 0
		aEval( aInssOut , { |x| nBaseOut += IF( x[1] == aCodFol[288,1] , x[2] , 0.00 ) } ) 
	Else
		aEval( aPD , { |x| nBaseOut += IF( x[1] == aCodFol[288,1] .and. x[9] # "D" .and. ( x[3] == cSemana .or. lMultv ) , x[5] , 0.00 ) } ) 
	EndIf
	If nBaseOut > 0 .and. !Empty(aCodFol[1847,1])
		aEval( aPd, { |x| If(x[1] == aCodFol[1847,1] .and. x[9] <> 'D', nBsAutOut += x[5], Nil) } )
	EndIf 
EndIf

If !Empty( aCodFol[289,1] ) //Inss Outras Empresas
	If Type("aInssOut") == "A" .And. Len(aInssOut) > 0 .And. aScan(aInssOut,{|x| x[5] == SRA->RA_CIC}) > 0
		aEval( aInssOut , { |x| nInssOut += IF( x[1] == aCodFol[289,1] , x[2] , 0.00 ) } )
	Else
		aEval( aPD , { |x| nInssOut += IF( x[1] == aCodFol[289,1] .and. x[9] # "D" .and. ( x[3] == cSemana .or. lMultv ), x[5] , 0.00 ) } )
		If nBaseOut > 0 .and. nInssAOut + nInssOut == 0 .and. DiasTrab + nDiasPg == 0
			If ( aScan(aPd, {|X| x[1] == aCodFol[0397, 1] .And. X[3] = cSemana .And. x[7] != "K" .And. X[9] # "D"}) ) == 0
				nBaseOut := 0 //Se existe base de inss de outras empresas, não existe recolhimento e funcionário esta afastado o período inteiro, zera inss outras empresas para não calcular INSS indevidamente.
			EndIf
		EndIf
		If nInssAOut == nInssOut .And. cSemana == "01"
			nInssAOut := 0
		Endif
	EndIf
EndIf
  
// Rescisao complementar por dissidio (lRescDis) ou somente complementar (lRecInss, parametro MV_INSSREC), salvar BASE E INSS ja calculados.
If cCompl = "S"  //Rescisao Complementar

	If lRescDis .or. lRecInss .Or. lProxMes // Dissidio ou Parametro MV_INSSREC como T 

		If lRescDis .Or. lRecInss .Or. ( Type("lRescRet") <> "U" .And. lRescRet)
			If lRescDis .Or. ( Type("lRescRet") <> "U" .And. lRescRet)
                Car_inss(@aTInss,MesAno(dDatadem)) // Carrregar tabela inss do mes\ano data rescisao
            EndIf
			aEval( aPdResc , { |x| nBaseOut += If (x[1] $ aCodFol[13,1]+"*"+ aCodFol[14,1]+"*"+ aCodFol[338,1] .and. X[3] == cSemana .And. X[9] # "D", x[5], 0.00) })
			aEval( aPdResc , { |x| nInssOut += If( x[1] $ aCodFol[64,1]+"*"+ aCodFol[65,1]+"*"+ aCodFol[340,1] .and. x[3] == cSemana .and. x[9] # "D", x[5], 0.00) })
		EndIf
		
    	If lProxMes
			aEval( aPdResVals , { |x| nBaseOut += If (x[1] $ aCodFol[13,1]+"*"+ aCodFol[14,1] .And. X[3] = cSemana .And. MesAno(M->RG_DTGERAR) == MesAno(X[Len(X)]) .And. X[9] # "D",x[5],0.00) })
			aEval( aPdResVals , { |x| nInssOut += If( x[1] == aCodFol[64,1] .And. MesAno(M->RG_DTGERAR) == MesAno(X[Len(X)]) .and. x[9] # "D" .and. x[3] == cSemana , x[5] , 0.00 ) } )    			
    	EndIf

	EndIf
	
EndIf

If Ascan(aPd,{ |X| X[1] = aCodfol[64,1] .And. X[3] = cSemana .And. X[9] # "D"}) = 0
	
	//--Verifica se lancou Base de Inss somando as verbas 
	nInss_b := nInssf_b := 0.00
	If !lDissidio
		Aeval( aPd ,{ |X| nInss_B += If (x[1] $ aCodFol[13,1]+"*"+ aCodFol[14,1] .And. X[3] = cSemana .And. X[9] # "D",x[5],0.00) })
	Else                                
		If SRA->RA_TIPOPGT != "S"
			//apagar verbas de base para forçar o carregamento abaixo
			Aeval( aPd ,{ |X| If (x[1] $ (aCodFol[13,1]+"/"+aCodFol[14,1]) .And. X[3] == cSemana .And. X[9] # "D", x[9]:= "D", "") })
		EndIf
	Endif
	
	If nInss_b = 0
		//-- Soma Incidencia para Inss quando base não foi lancada

		If lMultv
			aPdBkp := AClone(aPd)
			For nX := 1 To Len(aPd)
				If aPd[nX,3] <> cSemana
					aPd[nX,3] := cSemana
				EndIf
			Next nX
		EndIf
		If __lMemCalc  
			fAddMemLog("Verbas com incidência para INSS: ", 1, 2)
		EndIf
		Aeval( aPd ,{ |X| SomaInc(X,4,@nInss_b  ,11,"N",12,"N", , ,aCodfol, Nil, Nil, Nil, Nil, Nil, Nil, .T.) })
		If cTipoRot == "1" .And. !lDissidio
            Aeval( aPd, { |X| Iif( x[27] == "1", SomaInc(X, 4, @nIN2110, 11, "N", 12, "N", Nil, Nil, aCodfol), Nil ) } )
        EndIf
		Aeval( aPd ,{ |X| SomaInc(X,4,@nInssF_b ,11,"S", , , , ,aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.) })
		If cTipoRot == "4"
			Aeval( aPdSemAnt ,{ |X| SomaInc(X,4,@nInss_b  ,11,"N",12,"N", , ,aCodfol) })
			Aeval( aPdSemAnt ,{ |X| SomaInc(X,4,@nInssF_b ,11,"S", , , , ,aCodFol) })
		EndIf

		If lMultv
			aPd := AClone(aPdBkp)
		EndIf
		
		If SRA->RA_TPCONTR == "3"
			Aeval( aPdConvoc ,{ |X| SomaInc(X,4,@nInss_b  ,11,"N",12,"N", , ,aCodfol,,,,,, .T.) })
			Aeval( aPdConvoc ,{ |X| SomaInc(X,If(lDissidio, 35,4),@nInssF_b ,11,"S", , , , ,aCodFol,,,,,, .T.) })
		EndIf
		
		//Se for complementar MULTV considera os valores anteriores também
		If lMultv .And. LCALCCOMPL .And. Len(aCPFAll) > 0
			//AEval( aPd ,{ |X| IIf(X[1] == aCodFol[0064,1],X[9] := "D",Nil) })
			
			cAliasQry := GetNextAlias()
			
			cQuery := " SELECT * FROM " + RetSqlName("SRC")
			cQuery += " WHERE "
			cQuery += " ( "
			For nX := 1 To Len(aCPFAll)
				cQuery += " ( RC_FILIAL = '" + aCPFAll[nX,2] + "' AND"
				cQuery += " RC_MAT = '" + aCPFAll[nX,3] + "' )"
				
				If nX <> Len(aCPFAll)
					cQuery += " OR "
				EndIf
			Next nX
			cQuery += " ) AND"
			cQuery += " RC_PROCES = '" + cProcesso + "' AND"
			cQuery += " RC_PERIODO = '" + cPeriodo + "' AND"
			cQuery += " RC_ROTEIR = '" + cRot + "' AND"
			cQuery += " RC_SEMANA < '" + cSemana + "' AND"
			cQuery += " RC_PD IN('" + aCodFol[0013,1] + "','" + aCodFol[0014,1] + "') AND" // Bases de INSS
			cQuery += " D_E_L_E_T_ = ' ' "
			
			cQuery := ChangeQuery(cQuery)
			
			DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)
			
			While (cAliasQry)->( !Eof() )
				nInss_b += (cAliasQry)->RC_VALOR
				(cAliasQry)->( DbSkip() )
			EndDo
			
			(cAliasQry)->( DbCloseArea() )
		EndIf
		//-- Se afastamento Aux. Maternidade, monta base integral p/ encontrar aliquota
		If nDiasSalM > 0 .And. (nInss_b + nInssf_b + nBaseOut) > 0
			nBsMater := (nInss_b + nInssf_b + nBaseOut) + (nDiasSalM*SalDia) + nMedComiss
		EndIf
    EndIf

	If lInfTeto
		FMatriz(aCodfol[14,1], (nInss_b + nInssf_b))
		Return
	EndIf

	If lDissidio .And. cTipoRot == "1"
		aEval( aPd, { |X| If ( x[1] $ aCodFol[72,1] .And. x[3] == cSemana .And. X[9] != "D", nNumFer++, Nil ) } )
		aEval( aPd, { |X| If ( x[1] $ (aCodFol[72,1]+"*"+aCodFol[77,1]+'*'+aCodFol[88,1]+'*'+aCodFol[90,1]+'*'+aCodFol[92,1]+'*'+aCodFol[96,1]+'*'+aCodFol[98,1]+'*'+aCodFol[161,1]+'*'+aCodFol[94,1]+'*'+aCodFol[95,1]) .And. x[3] == cSemana .And. X[9] != "D" .And. x[11] > Str(nNumFer, 1), nInssF_b -= x[19], Nil ) } )			
	EndIf
	
	//-- Funcao para calcular o inss
	nInss := nInssf := nInss1 := nBaseAt := nBaseAc := nInssf1 := nBaseTot := 0.00
	nBaseTot += ( nInss_b + nInssf_b + nBaseOut + nBasAuxD )
	
	//Abate  base de INSS calculada na rescisão complementar.
	If !Empty(SRA->RA_DEMISSA) .and. AnoMes(SRA->RA_DEMISSA) < cPeriodo .and. cTipoRot == "1"
		Aeval( aPd ,{ |X| nBaseTot -= If (x[1] == aCodFol[338,1] .And. X[9] # "D",x[5],0.00) })
	EndIf	

	aEval(aPd, {|X| nInssFOut += If(x[1] $ aCodFol[0397, 1] .And. X[3] = cSemana .And. x[7] != "K" .And. X[9] # "D", x[5], 0.00)})
	aEval(aPd, {|X| nInssFer += If(x[1] $ aCodFol[65, 1] .And. X[3] = cSemana .And. X[9] # "D", x[5], 0.00)})

	 If __lMemCalc 		
		If(nBaseOut > 0, fAddMemLog("Base outros vínculos: R$ " + AllTrim(Transform(nBaseOut, "@E 999,999,999,999.99" )), 1, 2), Nil)
		If(nInssOut > 0 .Or. nInssFOut > 0, fAddMemLog("Valor do desconto outros vínculos: R$ " + AllTrim(Transform(nInssOut + nInssFOut, "@E 999,999,999,999.99" )), 1, 2), Nil)
	EndIf

	nBaseTot -= nIN2110
    Calc_Inss(aTInss,nBaseTot,@nInss,@nInss1,@nBaseAt,@nBaseAc,@nAliq,nBaseOut,lTrunca,nBsMater,@aInssFx,,,nBsAutOut)
	If nBasAuxD > 0
		nBaseTot -= nBasAuxD
		Calc_Inss(aTInss,nBaseTot,0,0,@nBaseAt,@nBaseAc,0,nBaseOut,lTrunca,nBsMater,aClone(aInssFx),,,nBsAutOut)
	EndIf
    If nIN2110 > 0
        nBaseTot += nIN2110
        Calc_Inss(aTInss,nBaseTot,0,0,@nBAt2110,@nBAc2110,0,nBaseOut,lTrunca,nBsMater,aClone(aInssFx),,,nBsAutOut)
        nBAt2110 -= nBaseAt
        nBAc2110 -= nBaseAc
    EndIf

	If lMultv
		dbSelectArea ("SRG")
		dbSetOrder(2)
		If SRG->(DbSeek(xFilial("SRG") + SRA->RA_MAT + "RES" ))
			While SRG->RG_FILIAL == SRA->RA_FILIAL .AND. SRG->RG_MAT == SRA->RA_MAT
				If MesAno(SRG->RG_DATAHOM) == cPeriodo //Caso haja uma rescisao no mesmo mes de calculo da folha deve abater o INSS ja pago
					dbSelectArea("SRR")
					DbSetOrder(1)
					If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[64,1] ))
						nInss -= SRR->RR_VALOR		
					EndIf
					If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[65,1] ))
						nInss -= SRR->RR_VALOR		
					EndIf
				EndIf
			dbSelectArea ("SRG")
			SRG->(DbSkip())
			EndDo
		Endif
	Endif

	//-- Se informou o Inss Outras Empresas Subtrai do Inss Calculado
	If nBaseOut > 0.00 .or. nInssOut > 0.00
	    nAuxInssF := nInss
		If nInssAOut > 0 .or. nBsAutOut == 0
			nInss	:= Max( nInss - ( nInssOut - nInssAOut) , 0 )
		Else
			aEval( aPd, { |x| If(x[1] == aCodFol[1847,1] .and. x[9] <> 'D', nRefAut := x[4], Nil) } )
			nRefAut := If(Empty(nRefAut),11,nRefAut)
			nInss	:= Max( nInss - Max(( nInssOut - (nBsAutOut * (nRefAut/100))),0) , 0 )
		EndIf 

		//-- Se informou o Inss Outras Empresas Subtrai do Inss Calculado
		If nInssOut > 0
			If nInssAOut > 0 .or. nBsAutOut == 0
				nInss1	:= Max( nInss1 - ( nInssOut - nInssAOut) , 0 )
			Else 
				nInss1	:= Max( nInss1 - Max(( nInssOut - (nBsAutOut * (nRefAut/100))),0) , 0 )
			EndIf 
		Else
			//-- Calcular a Deducao de Inss no Ir sobre a Base da outra empresa 
			//-- Para abater da deducao total 
			nDedInss := 0.00                           
			Calc_Inss(aTInss,nBaseOut-nBsAutOut,,@nDedInss,,,,,lTrunca,,@aInssFx)
			nInss1	:= Max( nInss1 - nDedInss , 0 )
		EndIf	

		If nInssFOut > 0 .And. (nInssFer == 0 .Or. (!(cInssFm $ "R*S") .And. nInssOut > 0 .and. nInssFer > 0)) .And. nInss > 0 .And. (nInss1 > 0 .Or. (nInss1 == 0 .And. nInssOut == 0))
			nInss  := Max(nInss - nInssFOut, 0)
			nInss1 := Max(nInss1 - nInssFOut, 0)
		EndIf 
		
		If __lMemCalc .And. (nInssOut > 0 .Or. nInssFOut > 0)  		
			fAddMemLog("Dedução INSS outros vínculos: R$ "+AllTrim(Transform( nAuxInssF, "@E 999,999,999,999.99" )) + " - R$ "+ AllTrim(Transform( nInssOut + nInssFOut , "@E 999,999,999,999.99" )) +" = R$ "+ AllTrim(Transform( nInss1, "@E 999,999,999,999.99" )), 1, 2)
		EndIf

		If nAuxInssF > nInss 
			lSInssOut := .T.
		EndIf
	EndIf

	// Quando funcionario tem ferias no mes e nao possui dias trabalhados ou remuneracao
	// por afastamento, todo o INSS deve ser computado como INSS Ferias pois nao tem
	// rendimentos em folha.
	Aeval( aPd ,{ |X| If (x[1] $ aCodFol[072,1] .And. X[3] = cSemana .And. X[9] # "D", nDiasMes += x[4], NIL) })
    If nDiasMes == 0 .And. cSitFolh == "F" .And. SRA->RA_CATFUNC != "M"
        aEval( aPd, { |x| Iif( x[1] $ (aCodFol[75, 1] + "/" + aCodFol[343, 1] + "/" + aCodFol[345, 1] + "/" + aCodFol[636, 1]) .And. x[3] == cSemana .And. x[9] != "D", nDiasMes += x[4], Nil ) } )
    EndIf
	If ( DiasTrab + nDiasPg + nDiasLRem ) == 0 .and. nDiasMes < 30 .And. cSitFolh $ "A*F" .and. !(SRA->RA_CATFUNC == "M" .and. SRA->RA_SALARIO == 0 .and. nInss > 0 .and. nDiasMes == 0) .And. !(Month(dDataAte) == 2 .And. nDiasMes == Day(dDataAte)) //Se for mensalista sem salário e INSS foi gerado através de lançamento de verbas, não zera inss férias.
		//-- Verifica se teve aumento no mes das ferias integralmente gozadas
		Aeval(aPd, { |X| If (x[1] $ aCodFol[088,1] .And. X[3] == cSemana .And. X[9] # "D" .And. x[5] > 0, lAumFer := .T., NIL) })
		If (Type("lUtiMultiV") == "U" .Or. ( Type("lUtiMultiV") != "U" .And. ! lUtiMultiV )) .And. lAumFer 
			aEval( aPd, { |x| If( x[1] $ aCodFol[65,1] .And. x[3] == cSemana, x[9] := "D", NIL ) } )
		EndIf
	EndIf

    //-- Abater do Inss de Ferias , informado ou gerado pela rotina de Ferias 
   	nNumFer := 0
   	
  	Aeval( aPd ,{ |X| If (x[1] $ aCodFol[164,1]+If(lId1449, "/"+aCodFol[1449,1], "") .And. X[3] = cSemana .And. X[9] # "D",nPosFer++,NIL) })  //nPosFer > 0 significa que eh o segundo mes
  	Aeval( aPd ,{ |X| If (x[1] $ aCodFol[072,1] .And. X[3] = cSemana .And. X[9] # "D",nNumFer++,NIL) })
  		
	//Busca as datas de pagamento geradas das verbas de Férias Pagas mês anterior e abono pago mês anterior, pois essas verbas sempre existem em férias partidas.
	If ( nPos := aScan( aPd, { |x| x[1] $ (aCodFol[164,1]+Iif(lId1449, "/"+aCodFol[1449,1], "")) .And. x[3] == cSemana .And. X[9] # "D" .And. !Empty(x[10]) } ) ) > 0
		dDtPgFer := aPd[nPos, 10]
	EndIf

   	//Se existe inss outras empresas, inss férias e inss na folha, 
	If nInssFOut > 0 .and. nInssFer > 0 
		//verifico se lançou INSS no calculo das ferias
		nInssFer += nInssFOut
	EndIf
   	
   	If  Type("cInssFM") # "U" 
	   	If cInssFm == "R" .and. nInssf_b <> 0 .and. nInssFer == 0 .and.  nPosFer > 0 
			cInssOri := "R"
			cInssFM	 := "N"		
		EndIf
		//Se MV_DINSSFM for R ou S, não existir INSS Férias calculado e existir verba referente a férias
		If cInssFm $ "R*S" .and. nInssf_b > 0 .and. nInssFer == 0
			//Verifica se a verba de férias foi lançada, indicando ser 1/3 pago separado referente a MP e altera cInssFm para "N" para que o INSS sobre férias seja gerado.
			If aScan(aPd, {|x| x[7] == "I" .and. RetValSRV(x[1],SRA->RA_FILIAL,"RV_REFFER") == "S" .and. RetValSRV(x[1],SRA->RA_FILIAL,"RV_INSSFER") == "1"}) > 0
				cInssOri := cInssFm
				cInssFm := "N"
			EndIf
		EndIf
	EndIf
   	
   	//-- Quando Tem Inss de ferias e menor que o Inss do Mes abate o Inss de ferias
	If nInssFer > 0.00 .And. nInss >= nInssFer
   	    //-- Abate os valores de Ded. Inss Ferias, informado ou gerado pela rotina de ferias 
   	    //-- Se o parametro MV_DINSSFM estiver com "S", descontar apenas o inss referente ao mes.
		If Type("cInssFM") # "U" .and. (cInssFM == "S" .OR. cInssFM == "R")
			nInss -= nInssFer			
			nInss1  -= If(nInssf > 0,nInssf, nInssfer)     //Deducao INSS para desconto base IRF Folha, ID 167
			nInssf1	:= If(nInssf > nInssfer, nInssf - nInssfer, nInssfer)   //Deducao INSS para desconto base IRF Ferias, ID 168
			Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })
			//Se a origem da verba é F veio do fechamento, indicando que foi originado da verba de INSS Férias mês seguinte. Como o INSS já foi deduzido integralmente na folha anterior, não efetua nova dedução.
			Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[65,1] .And. X[3] = cSemana .And. X[7] = "F" .And. X[9] # "D",x[5],0.00) })
			lTetoINSS := lMultv .And. Round(nInss,2) == 0.00
		Else
			If nInssf_b > 0.00 
				If  nInss_b > 0.00 .or. nInssFer < nInss //(Se a base for nula e o inss for maior que o inssfer, significa que não houve dias trabalhados porém houve alteração na tabela de inss ou salário )
					//-- Se informou o Inss Outras Empresas Nao Considera a Base de Outras Empresas
					nBaseTot := If( nInssOut > 0 , Max( nBaseTot - nBaseOut , 0 ) , nBaseTot )  
					//-- Proporciona INSS conforme peso das bases de calculos de Folha/Ferias
					If nInss_b <= 0
						nInssf  := nInss
					Else
						If !lMultv .and. LCALCCOMPL //Se for complementar, pega o valor de INSS férias pago na primeira folha
							nInssf  := fGetPdSRC(aCodFol[65,1])
							If nInssf == 0
								NoRound( (nInssf_b / nBaseTot ) * nInss )
							EndIf
						Else
							nInssf  := NoRound( (nInssf_b / nBaseTot ) * nInss )
						EndIf
					EndIf
					nInss   -= nInssf                 
				 	//Marca como deletada verba de INSS Ferias calculada anteriormente
					Aeval( aPd ,{ |X| If (x[1] $ aCodFol[65,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
					//Gera novamente a verba
					fMatriz(aCodFol[65,1],nInssf,nAliq)
					
					If nInssf1 == 0.00     
						nDiasMs	:= 0
					   	//-- Verifica se existe ferias mes seguinte
						If Type("aDiffer") <> "U" 
							Aeval( aDiffer,{|x|nDiasMs+=x[3]} )
						EndIf
						If nDiasMs > 0 
							If Ascan( aPd, { |x| x[1] == aCodFol[88,1] .And. X[3] = cSemana .And. X[5] > 0 .And. X[9] # "D" } ) > 0
								//Deducao INSS para desconto base IRF Folha, ID 167
								Aeval( aPd ,{ |X| nInss1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And.  X[9] # "D" ,x[5],0.00) })
							Else
								nInssf1 := 0
								Aeval( aPd ,{ |X| nInssf1 += If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And.  X[9] # "D" ,x[5],0.00) })
								//-- Proporciona deducao do INSS conforme peso das bases de calculos de Folha/Ferias 
								nInssf1 := Min(nInssf1,NoRound( (nInssf_b / nBaseTot ) * nInss1 ))
								//Deducao INSS para desconto base IRF Folha, ID 167
								nInss1  -= Max(nInssf1,0)
							EndIf
							nInssf1 := 0
						Else  
						  	//Deducao INSS para desconto base IRF Ferias, ID 168
							nInssf1:= ninssf
							Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[9] # "D",x[5],0.00) })
							//Deducao INSS para desconto base IRF Folha, ID 167
							nInss1  -= Max(ninssf,0) 
						EndIf
					EndIf
				Else
				  	//Se a base no calculo da folha for Nula ou Negativa, não ocorreu proventos
				   	//resultando em insuficiente de saldo e portanto vale o inss de férias se houver
				   	//não existira inss de folha
					nInss1 := 0
					nInss  := 0	
				EndIf
			EndIf
		EndIf  
	//--Quando o Inss de Ferias For maior que o Inss do Mes, apagar os Inss de Ferias e 
	//--Gerar um novo com o valor total do Mes	   	
	Elseif nInssFer > 0.00 .And. nInss < nInssfer	   	
		If  (nNumFer > 1)  //Mais de uma ferias no mes
			Aeval( aPd ,{ |X| nInsfeFec+= If (x[1] $ aCodFol[065,1] .And. X[3] = cSemana .And. X[7] == "V" .And. X[9] # "D", x[5],0.00)})
		EndIf   	                           
		
		If nInsfeFec > 0.00 .and. nInss > 0.00 
			//Preservar o valor do INSS das ferias que veio do fechamento.
			//Gravar na verba de inss das ferias do calculo das ferias a diferença entre o teto e o inss ferias do fechamento.        
			//para nao recolher mais o que o teto.
			Aeval( aPd ,{ |X| If (x[1] $ aCodFol[065,1] .And. X[3] = cSemana  .And. X[7] == "K" .And. X[9] # "D",x[9]:= "D","") })
			fMatriz(aCodFol[65,1],nInss-nInsfeFec,nAliq,,,,"C",,,,.T.,"1")	
			If nInssf1 <= 0.00// Deducao INSS para IRF Ferias
				nInssf1 := nInss
				Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })		   	
			EndIf
			nInss := 0.00   
			nInss1:= 0.00     
		ElseIf nInss > 0.00 .Or. (nInss <= 0  .And. nInssFer > 0.00)
			
        	If nInss_b > 0.00 
				//-- Se o INSS Ferias for maior que o da Folha, provavelmente ocorreram ferias e ferias mes seguinte
				//-- e licenca remunerada (Por exemplo, ferias em dezembro e MV_DIA2501 = 'S'. Pagamos 30 de ferias
				//-- e 1 dia de licenca remunerada. Nas ferias, paga-se 30 dias de ferias. Na folha paga-se 29 dias ferias
				//-- e 1 dia de licenca. A base de INSS folha ficara menor que a base de ferias por conta do 1/3 ferias
				//-- das ferias mes seguinte que somente sera tratado no proximo mes).
				If nInss < nInssfer
					//-- Se a verba Id.1412 (Devolucao Inss Ferias) estiver cadastrada mantem o valor do Inss que foi
					//-- calculado nas ferias e gera a diferenca nessa verba que precisa ser cadastrada como provento
					//-- Antes desse ajuste a diferenca do valor calculado a maior era devolvida atraves do liquido
					If cInssFM $ "S/R" .And. Len(aCodfol) >= 1412 .And. !Empty(aCodfol[1412,1])
						fMatriz(aCodfol[1412,1],nInssfer - nInss)
						nInss := 0.00
						nInss1:= 0.00
					Else
						//-- Proporcionaliza dias de ferias/dias de folha, a partir do valor de verbas de FERIAS
						nInssf  := NoRound( (nInssf_b / nBaseTot ) * nInss )
						nInss   -= nInssf
						nInssf1 := NoRound( (nInssf_b / nBaseTot ) * nInss1 )
						nInss1  -= nInssf1         
						Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })		   	
						//-- Substitui o INSS de ferias pelo proporcionalizado, mas mantem o DED IR INSS Ferias
						Aeval( aPd ,{ |X| If (x[1] $ aCodFol[065,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
						fMatriz(aCodFol[65,1],nInssf)
					EndIf
				Else					
					Aeval( aPd ,{ |X| If (x[1] $ aCodFol[065,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
					fMatriz(aCodFol[65,1],nInss)
					If nInssf1 <= 0.00 // Deducao INSS para IRF Ferias
						nInssf1 := nInss
						Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })		   	
					EndIf	
				EndIf
			Else
				If cInssFM $ "S/R" .And. Len(aCodfol) >= 1412 .And. !Empty(aCodfol[1412,1])
					fMatriz(aCodfol[1412,1],nInssfer - nInss - nInssDevFe)

				//Se a base no calculo da folha for Nula ou Negativa, não ocorreu proventos
			   	//resultando em insuficiente de saldo e portanto deve recalcular o inss das ferias
				ElseIf cInssFM == "N" .And. ( !(DiasTrab == 0 .And. nDiasMes >= 30) .OR. nInssOut == 0 )
					//-- Proporcionaliza dias de ferias/dias de folha, a partir do valor de verbas de FERIAS
					nInssf  := Min(NoRound( (nInssf_b / nBaseTot ) * nInss ),nInss)
					nInss   -= nInssf
					nInssf1 := NoRound( (nInssf_b / nBaseTot ) * nInss1 )
					nInss1  -= nInssf1         
					Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })		   	
					//-- Substitui o INSS de ferias pelo proporcionalizado, mas mantem o DED IR INSS Ferias
					Aeval( aPd ,{ |X| If (x[1] $ aCodFol[065,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
					fMatriz(aCodFol[065,1],nInss)
				EndIf
				nInss1 := 0
				nInss  := 0	
			EndIf			
		EndIf

	Else
		//-- Proporcionaliza Inss de Ferias e Salario

		If (nInssf_b > 0.00 .and. nInss_b > 0.00 )
			//-- Se informou o Inss Outras Empresas Nao Considera a Base de Outras Empresas
			nBaseTot := If( nInssOut > 0 , Max( nBaseTot - nBaseOut , 0 ) , nBaseTot )
			 // recalcular somente se for diferente de rateio, ou no IR_MULTV, caso contrario nao gera valor de Inss ferias para ratear
			If !(cInssFM $ "R*S") .Or. (aScan( aPd, {|x| x[1] == aCodFol[164,1]} ) == 0 .And. If(lId1449, aScan( aPd, {|x| x[1] == aCodFol[1449,1]} ) == 0, .T.) .And. IsInCallStack('MULTV'));
			   .Or. SRA->RA_TPCONTR == "3"
				nInssf  := NoRound( (nInssf_b / nBaseTot ) * nInss )
			Else				
				Aeval( aPd ,{ |X| nInssf += If (x[1] $ aCodFol[65,1] .And. X[3] = cSemana, x[5] ,0.00) })
			Endif					
			nInss   -= nInssf
			If !(cInssFM $ "R*S") .Or. SRA->RA_TPCONTR == "3" // recalcular somente se for diferente de rateio
				nInssf1 := NoRound( (nInssf_b / nBaseTot ) * nInss1 )	
			Else
			  Aeval( aPd ,{ |X| nInssf1 += If (x[1] $ aCodFol[65,1] .And. X[3] = cSemana, x[5] ,0.00) })
			Endif	
			nInss1  -= nInssf1         
			Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })

			//Se for férias do próximo período, já deduziu o INSS de férias durante o cálculo das férias.
			//Portanto não gera dedução de INSS Férias novamente 
			If nPosFer > 0 .And. !(cInssFM $ "R*S")
				//Verifica se não teve aumento salarial no próximo período das férias.
				If (nPos:= Ascan( aPd, { |x| x[1] == aCodFol[88,1] .And. X[3] = cSemana .And. X[9] # "D" } )) == 0
					// Em caso afirmativo, zera a variável de dedução INSS para não deduzir novamente, pois já foi feito no cálculo das férias.
					nInssf1 := 0
				Else
				//Caso exista a diferença de férias, verifica se o valor descontado de INSS nas férias foi o teto
					nId0168 := fBusInsFer(dDtPgFer)
					//Se for o teto, zera a dedução, pois já foi deduzido
					If nId0168 == nTetoInss
						nInssf1 := 0
					EndIf
				EndIf
			EndIf

			//-- Teve aumento nas ferias de 30 dias
			//-- Vai existir diferenca para ser apurado INSS da folha e das ferias.
			//-- Na folha devera ser listadas as Deducoes de INSS de Ferias gerada pelas ferias e gerada pela folha (devido ao aumento)
			If lAumFer
				fMatriz(aCodFol[168,1],nInssf1,,,,,"C",,,,.T.,"1")	
			EndIf	
		Elseif nInssf_b > 0 .And. nInss_b <= 0
			//--Quando tem apenas base de Inss sobre ferias  
			//--NAO teve aumento nas ferias de 30 dias
			If !lAumFer
				If ( DiasTrab + nDiasPg + nDiasLRem ) == 0 .And. nDiasMes == 30 .And. cSitFolh $ "A*F" .And. ( nPosInc := aScan( aPd, { |x| x[1] $ aCodFol[65,1] .And. x[3] == cSemana .And. x[7] == "I" } ) ) > 0
					aEval( aPd, { |x| If( x[1] $ aCodFol[65,1] .And. x[3] == cSemana .And. x[7] == "I", nFerInc += x[5], NIL ) } )
					nInss := nFerInc
					nAliq := aPd[nPosInc, 4]
				EndIf
				nInssf := nInss
				nInssf1:= nInss
				nInss1 := 0
				nInss  := 0			
			Else 
				//-- Teve aumento nas ferias de 30 dias
				If nInss > 0.00
				   	Aeval( aPd ,{ |X| If (x[1] $ aCodFol[065,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
			   		FMatriz(aCodfol[65,1],nInss,nAliq)    
		   			If nInssf1 <= 0.00 // Deducao INSS para IRF Ferias
				   		nInssf1 := nInss
							Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })		   	
				  		fMatriz(aCodFol[168,1],nInssf1,,,,,"C",,,,.T.,"1")	
					EndIf
				EndIf		
		   		nInss := 0.00   
		   		nInss1:= 0.00   			
			EndIf	
		//-- Proporcionaliza Inss de Outras Empresas e Salario
		ElseIF nBaseOut > 0.00 .and. nInss_b > 0.00 .and. nInssOut + nInssFOut == 0.00
			nInss_Ou	:= NoRound( ( nBaseOut / nBaseTot ) * nInss )
			nInss		-= nInss_Ou
			nInss_O1	:= NoRound( ( nBaseOut / nBaseTot ) * nInss1 )
			nInss1		-= nInss_O1
		EndIf
	EndIf
	
	//Se existe inss outras empresas, inss férias e não existe inss na folha, subtrai o inss outras empresas do inss férias.
	If nInssOut > 0 .and. nInss == 0 .and. nInssF == 0 .and. nInssFer >= nInssOut  .And. !(cInssFM $ "S/R" .And. Len(aCodfol) >= 1412 .And. !Empty(aCodfol[1412,1]))
		//Excluir verbas de dedução e inss férias
		Aeval( aPd ,{ |X| If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
		Aeval( aPd ,{ |X| If (x[1] $ aCodfol[065,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
		nInssf1 := nInssF := Iif( nBaseTot > nBaseTeto, nTetoInss - nInssOut - nInssFOut, If(lSInssOut, nAuxInssF - nInssOut - nInssFOut, nInssFer - nInssOut - nInssFOut ) )
	EndIf		

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Semanalistas ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SRA->RA_TIPOPGT = "S"
		If Ascan( aPd, { |x| x[1] == aCodFol[065,1] .And. x[3] # cSemana } )  > 0 .And. SRA->RA_TPCONTR <> "3" // Para contrato intermitente, não soma o INSS das Férias com o INSS da Folha.
			nInss  += nInssf
			nInss1 += nInssf1
			nInssf := nInssf1 := 0
		EndIf
	
		If cTipoRot == "4"
			Aeval( aPdSemAnt,{ |X| nAteAnt  += If(X[1] == aCodFol[013,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
			Aeval( aPdSemAnt,{ |X| nAciAnt  += If(X[1] == aCodFol[014,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
			Aeval( aPdSemAnt,{ |X| nInssAnt += If(X[1] $  aCodFol[064,1]+"*"+aCodFol[065,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
			Aeval( aPdSemAnt,{ |X| nInssAnt1+= If(X[1] $  aCodFol[167,1]+"*"+aCodFol[168,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
		Else
			Aeval( aPD,{ |X| nAteAnt  += If(X[1] == aCodFol[013,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
			Aeval( aPD,{ |X| nAciAnt  += If(X[1] == aCodFol[014,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
			If SRA->RA_TPCONTR <> "3" 
				Aeval( aPD,{ |X| nInssAnt += If(X[1] $  aCodFol[064,1]+"*"+aCodFol[065,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
				Aeval( aPD,{ |X| nInssAnt1+= If(X[1] $  aCodFol[167,1]+"*"+aCodFol[168,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
			Else
				aEval( aPD, { |x| nInssAnt += Iif( x[1] == aCodFol[064,1] .And. x[3] < cSemana .And. x[9] != "D", X[5], 0 ) } )
				aEval( aPD, { |x| nInssAnt2 += Iif( x[1] == aCodFol[065,1] .And. x[3] < cSemana .And. x[9] != "D", X[5], 0 ) } )
				aEval( aPD, { |x| nInssAnt1 += Iif( x[1] == aCodFol[167,1] .And. x[3] < cSemana .And. X[9] != "D", X[5], 0 ) } )
				aEval( aPD, { |x| nInssAnt3 += Iif( x[1] == aCodFol[168,1] .And. x[3] < cSemana .And. X[9] != "D", X[5], 0 ) } )
			EndIf
		EndIf

		nBaseAt -= nAteAnt
		nBaseAc -= nAciAnt
		nInss   -= nInssAnt      
		nInss1	-= nInssAnt1
		If SRA->RA_TPCONTR == "3"
			nInssf	-= nInssAnt2      
			nInssf1	-= nInssAnt3
			If nBaseAc > 0 .And. nBaseAt == 0
				nInss := nInss1 := nInssf := nInssf1
			EndIf
		EndIf
    EndIf

	If lRescDis 
		If lProxMes
			FMatriz(aCodfol[ 338,1],nBaseAt+nBaseAc)
		Else
			If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[14,1] ))
				FMatriz(aCodfol[338,1], Max(nBaseAc - SRR->RR_VALOR, 0) , , , , ,"R" )		
				FMatriz(aCodfol[ 14,1], SRR->RR_VALOR)
				FMatriz(aCodfol[ 13,1], nBaseAt)			
			Else
				If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[13,1] ))
 					FMatriz(aCodfol[338,1], Max((nBaseAt + nBaseAc) - SRR->RR_VALOR, 0) , , , , ,"R" )//Base INSS 13 Acima Dissidio
					FMatriz(acodfol[013,1], SRR->RR_VALOR )
				EndIf
			EndIf                    
		EndIf	
	Else
  		FMatriz(aCodfol[ 13,1],nBaseAt)
		FMatriz(aCodfol[ 14,1],nBaseAc)
	EndIf
	
    If cTipoRot == "1" .And. !lDissidio .And. nIN2110 > 0
        nIN2110 := 0
        For nX := 1 To Len(aPd)
            If aPd[nX, 9] != "D" .And. aPd[nX, 27] == "1"
                If ( nPosIN2110 := aScan( aIN2110, { |x| AnoMes(x[1]) == AnoMes(aPd[nX, 18]) } ) ) == 0
                    cSeqIN2110 := Soma1(cSeqIN2110)
                    aAdd( aIN2110, { aPd[nX, 18], aPd[nX, 5], 0, cSeqIN2110 } )
                Else
                    aIN2110[nPosIN2110, 2] += aPd[nX, 5]
                EndIf
            EndIf
        Next nX        
        For nCntIN2110 := 1 To Len(aIN2110)
            Calc_Inss(aTInss, aIN2110[nCntIN2110, 2], @aIN2110[nCntIN2110, 3], Nil, Nil, Nil, Nil, Nil, lTrunca, Nil, Nil) 
            FMatriz( aCodfol[64, 1], aIN2110[nCntIN2110, 3], Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, aIN2110[nCntIN2110, 4], Nil, Nil, Nil, Nil, Nil, Nil, aIN2110[nCntIN2110, 1], Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, "1" )            
            nIN2110 += aIN2110[nCntIN2110, 3]
        Next nCntIN2110
  		FMatriz( aCodfol[13, 1], nBAt2110, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, "1", Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, "1"  )
		FMatriz( aCodfol[14, 1], nBAc2110, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, "1", Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, "1"  )
    EndIf

	If Round(nInss,2) > 0.00
		If lDissidio 
	    	If (nPosPd:= aScan(aPd ,{|X| X[1] = aCodfol[167,1] })) > 0
	    		If aPd[nPosPd][5] > nInss1
	    			nAxINSS := aPd [nPosPd][5] - nInss1
	    			nInss   := aPd [nPosPd][5]
	    			nInss1  := aPd [nPosPd][5]
	    			nInssF  := nInssF - nAxINSS
	    		EndIf
	    	EndIf
	    EndIf	
		If lRescDis 
			If lProxMes
				FMatriz(aCodfol[ 340,1],nInss,nAliq)
			Else
				If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[64,1] ))
					FMatriz(aCodfol[340,1], Max(nInss - SRR->RR_VALOR, 0 ) , , , , ,"R" )		
					FMatriz(aCodfol[ 64,1],SRR->RR_VALOR,nAliq)
				EndIf	
			EndIf	
		Else
			FMatriz(aCodfol[ 64,1],nInss,nAliq)			
		EndIf
	EndIf

	//-- Verifica se existe verba de Dif. INSS Dissidio
	//   a Verba de Ferias Mes Seguinte
	If !(cCompl = "S"  .And. (lRescDis .or. lRecInss .Or. lProxMes))
		If ( nPosPd := Ascan(aPd,{ |X| X[1] == aCodfol[340,1] .And. X[3] = cSemana .And. X[9] # "D"})) > 0
			If	!(RetValSRV(aCodFol[340,1],SRA->RA_FILIAL,"RV_IR") == "S") //SE TIVER INCIDÊNCIA IGNORA, POIS JÁ FOI SOMADO
				nInss1 += aPd[nPosPd,5]
			EndIf
		EndIf	
	EndIf
	
	nDedFer := 0 //Valor da verba de dedução INSS férias
	
	If P_LIMTET .and. nInssFer > 0 //Se deve limitar a dedução ao teto
		Aeval( aPd ,{ |X| nDedFer += If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })
	EndIf
	
    // Deducao INSS IR Folha
	If !lResExt
		If Round(nInss1,2) > 0.00
			FMatriz(aCodfol[167,1],Min(nInss1+nIN2110, nTetoInss - nDedFer)) //Se for para limitar ao teto, subtrai a diferença da dedução de inss férias
		Else
	   		//Busca o valor gravado na verba de INSS Folha
	   		Aeval( aPd ,{ |X| nInssFol += If (x[1] $ aCodFol[64,1] .And. X[3] = cSemana .And. X[9] # "D",x[5],0.00) })
	   		If nInssFol > 0
				FMatriz(aCodfol[167,1],Min(nInssFol, nTetoInss - nDedFer))   		
	   		EndIf
		EndIf
	Else
		If Round(nInss1,2) > 0.00 .and. lDedInssEx .and. lIrResExt
			FMatriz(aCodfol[167,1],Min(nInss1, nTetoInss - nDedFer))
		ElseIf lDedInssEx .and. lIrResExt
			//Busca o valor gravado na verba de INSS Folha
			Aeval( aPd ,{ |X| nInssFol += If (x[1] $ aCodFol[64,1] .And. X[3] = cSemana .And. X[9] # "D",x[5],0.00) })
			If nInssFol > 0
				FMatriz(aCodfol[167,1],Min(nInssFol, nTetoInss - nDedFer))
			EndIf	 
		Endif
	Endif

	// INSS Ferias
	If Round(nInssf,2) > 0
		If SRA->RA_TPCONTR <> "3"
			FMatriz(aCodfol[65,1],nInssf,nAliq)
		Else
			//Se a semana for acima da primeira e já tiver atingido o teto do INSS, zera a variável de INSS para não gerar descontos.
			If cSemana > "01" .And. nInssAnt >= nTetoInss
				nInssf  := 0
				nInssf1 := 0
			Else
				FMatriz(aCodfol[65,1],nInssf,nAliq)
			EndIF
		EndIf
	EndIf

   // Deducao INSS IR Ferias	
	If Round(nInssf1,2)	 > 0
		If !lResExt .Or. (lDedInssEx .And. lIrResExt)
			//Caso haja a verba de Diferenca de Ferias, gera uma nova verba de Deducao INSS Base IR Ferias		
			If (nPos:= Ascan( aPd, { |x| x[1] == aCodFol[88,1] .And. X[3] = cSemana .And. X[5] > 0 .And. X[9] # "D" } ))  > 0
				FMatriz(aCodfol[168,1],nInssf1, Nil, Nil, Nil, Nil, "C", Nil, Nil, Nil, Nil, "1")		
			//Caso o valor de INSS Ferias seja maior do que o apurado anteriormente, gera uma nova verba de Deducao INSS Base IR Ferias com a diferenca dos valores
			ElseIf nInssf1 == nInssf .And. 	nInssf1 > nInssfer .And. nPosInc == 0
				FMatriz(aCodfol[168,1], nInssf1 - nInssfer, Nil, Nil, Nil, Nil, "C", Nil, Nil, Nil, Nil, "1")
			Else
				//Caso haja mais de um calculo de ferias e nao foi carregado o INSS de Ferias devido a outra ferias partidas e haja a verba de Deducao INSS Base IR Ferias
				//gerada pelo calculo de ferias marca a verba com flag de deletada para regravar a verba com o valor atualizado. 
				If nNumFer > 1 .And. ( ( nPos := Ascan( aPd, { |x| x[1] == aCodFol[168,1] .And. X[3] == cSemana .And. X[7] == "K" .And. X[9] # "D" } ) ) > 0 )
					aPd[nPos][9] := "D"
				Endif
				//Verifica se o desconto do INSS das Férias já é o teto do INSS.
				If nInssFer == nTetoInss .And. !lDissidio .And. ( ( nPos := Ascan( aPd, { |x| x[1] == aCodFol[168,1] .And. X[3] == cSemana .And. X[7] == "K" .And. X[9] # "D" } ) ) > 0 )
					aPd[nPos][5] := nInssf1
				Else	
					FMatriz(aCodfol[168,1],nInssf1, Nil, Nil, Nil, Nil, "C", Nil, Nil, Nil, Nil, "1")
				EndIf
			EndIf
		EndIf
	EndIf
	If lIntTaf .And. RetValSrv( aCodfol[65,1], SRA->RA_FILIAL, "RV_INCIRF" ) == "43" .And. Len(aCodFol) >= 1723 .And. !Empty(aCodfol[1723,1])
		nVl0065 := Abs(FBuscaPD( aCodfol[65,1] ))
		If cInssFM == "N"
			//Busca o valor gravado na verba de Ded INSS IR Fer gerado com a diferença quando é recalculo 
			Aeval( aPd ,{ |X| nDedFerMes := If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[9] # "D" .And. X[7] <> "K" ,x[5],0.00) })
			//Abate a diferença de Dedução INSS IR Fer, porque a diferença deve ser somada ao INSS Folha do mes 
			If nDedFerMes > 0
				nVl0065 -= nDedFerMes
			Endif
		Endif	
		If nVl0065 > 0
			FMatriz(aCodfol[1723,1], nVl0065)
		EndIf
	EndIf
EndIf

If Type("cInssFM") # "U" .and. cInssFm == "N" .and. cInssOri $ "R*S"
	cInssFM := 	cInssOri 		
EndIf

If !Empty(nRegAnt)
	SRG->(DbGoTo(nRegAnt))
EndIf

//Gera as verbas de INSS por faixa
If !Empty(aInssFx) .and. !Empty(aPdFx[1])
	fCInssFx(aInssFx,aPdFx)
EndIf

Return


/*/{Protheus.doc} fCInssRtf
Função que apura o INSS da retificação
@author Allyson Mesashi
@since 11/01/2019
@version P12.1.17
/*/
Function fCInssRtf(aCodfol,aTinss,lTrunca)

Local nBaseAt	:= 0.00
Local nBaseAc	:= 0.00
Local nBaseAtAnt:= 0.00
Local nBaseAcAnt:= 0.00
Local nAliq		:= 0.00
Local nBaseOut	:= 0.00
Local nInssOut	:= 0.00
Local nInss		:= 0.00
Local nInssFer	:= 0.00
Local nInssFol	:= 0.00
Local nBaseTot	:= 0.00
Local nTetoInss := 0
Local nCont    	:= 0
Local aInssFx	:= {}
Local aPdFx		:= {aCodFol[1734,1], aCodFol[1735,1], aCodFol[1736,1], aCodFol[1737,1]}

lResExt		:= If( Type("lResExt") 		== "U"	, .F., lResExt)
lDedInssEx	:= If( Type("lDedInssEx") 	== "U"	, .F., lDedInssEx)
lIrResExt	:= If( Type("lIrResExt") 	== "U"	, .T., lIrResExt)
lInssAut	:= If( Type("lInssAut") 	== "U"	, .T., lInssAut)

// Para os casos em que o funcionário não é autonomo, pode haver acordo
// Entre o Brasil e outros paises, para o não desconto do INSS.
// Para tratar esses acordos o campo RA_INSSAUT é utilizad.
// Se estiver com NÃO, NÃO deverá calcular INSS, independente do RA_CATFUNC.
If cPaisLoc == "BRA" .and. (!lInssAut)
	Return
EndIf

//--Situacao do Funcionario na data de referencia
lTrunca 	:= If (lTrunca = Nil , .T. , lTrunca)

//Variável do TETO do INSS.
nTetoInss := fRetTetIns(aTinss)

If Ascan(aPd,{ |X| X[1] == aCodfol[64,1] .And. X[3] == cSemana .And. X[9] # "D"}) = 0
	
	For nCont := 1 To Len(aPd)
		If !Empty( aCodFol[288,1] ) .And. aPd[nCont, 1] == aCodFol[288,1] .and. aPd[nCont, 9] # "D"//Base Inss Outras Empresas
			nBaseOut += aPd[nCont, 5]
		EndIf
		If !Empty( aCodFol[289,1] ) .And. aPd[nCont, 1] == aCodFol[289,1] .and. aPd[nCont, 9] # "D"//Inss Outras Empresas
			nInssOut += aPd[nCont, 5]
		EndIf
		If aPd[nCont, 1] == aCodFol[13,1] .and. aPd[nCont, 9] # "D"//Base Inss Até o Limite
			nBaseAtAnt += aPd[nCont, 5]
		EndIf
		If aPd[nCont, 1] == aCodFol[14,1] .and. aPd[nCont, 9] # "D"//Base Inss Acima do Limite
			nBaseAcAnt += aPd[nCont, 5]
		EndIf
		If aPd[nCont, 1] == aCodFol[64,1] .and. aPd[nCont, 9] # "D"//Inss Fol
			nInssFol += aPd[nCont, 5]
		EndIf
		If aPd[nCont, 1] == aCodFol[65,1] .and. aPd[nCont, 9] # "D"//Inss Ferias
			nInssFer += aPd[nCont, 5]
		EndIf
	Next nCont

	nInss_b := nInssf_b := 0.00
	
	Aeval( aPd ,{ |X| SomaInc(X,4,@nInss_b  ,11,"N",12,"N", , ,aCodfol) })
	Aeval( aPd ,{ |X| SomaInc(X,4,@nInssF_b ,11,"S", , , , ,aCodFol) })
	
	//-- Funcao para calcular o inss
	nInss := nInssf := nInss1 := nBaseAt := nBaseAc := nInssf1 := nBaseTot := 0.00
	nBaseTot += ( nInss_b + nInssf_b + nBaseOut )
	
	Calc_Inss(aTInss,nBaseTot,@nInss,Nil,@nBaseAt,@nBaseAc,@nAliq,nBaseOut,lTrunca,,@aInssFx)                                       

	nBaseAt := Max(nBaseAt - nBaseAtAnt, 0)
	nBaseAc := Max(nBaseAc - nBaseAcAnt, 0)
	
	If nBaseAt > 0
		FMatriz(aCodfol[ 13,1],nBaseAt)
	EndIf
	If nBaseAc > 0
		FMatriz(aCodfol[ 14,1],nBaseAc)
	EndIf

	nInss := Max(nInss - (nInssFol + nInssFer + nInssOut), 0)
	
	If nInss > 0
		FMatriz(aCodfol[64,1],nInss,nAliq)

		//Gera as verbas de INSS por faixa
		If !Empty(aInssFx) .and. !Empty(aPdFx[1])
			fCInssFx(aInssFx,aPdFx)
		EndIf
	EndIf		
EndIf

Return


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCInss13 ³ Autor ³ Equipe RH             ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Inss Funcionario 13o                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCInss13(aCodfol)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³1 - aCodFol  - Array com os Identificadores de Calculo      ³±±
±±³          ³2 - aTabInss - Array com os Valores da Tabela de INSS       ³±±
±±³          ³3 - lCond    - Condicao para SomaInc                        ³±±
±±³          ³4 - nInssAnt   - Valor do Inss ja Descontado                  ³±±
±±³          ³5 - nBAtLimA  - Valor da Base Ate o Limite ja Calculada      ³±±
±±³          ³6 - nBAcLimA  - Valor da Base Acima do Limite ja Calculada   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCInss13(aCodfol,aTinss,lCond,nInssAnt,nBAtLimA,nBAcLimA,lTrunca)

Local nAliq			:= 0.00
Local nBaseOut		:= 0.00
Local nBsAutOut 	:= 0.00
Local nBaseOAt		:= 0.00
Local nBaseOAc		:= 0.00
Local nBaseOIn		:= 0.00
Local nInssOut		:= 0.00
Local nBaseTot		:= 0.00
Local nInss_Ou		:= 0.00 
Local nInss_O1		:= 0.00
Local nDedInss		:= 0.00
Local nPos			:= 0
Local cVerba13		:= ""
Local cTmpAlias		:= ""
Local aPerAberto	:= {}
Local aPerFechado	:= {}
Local aVerbasLanc	:= {}
Local aInssFx		:= {}
Local aPdFx			:= {aCodFol[1742,1], aCodFol[1743,1], aCodFol[1744,1], aCodFol[1745,1]}
Local lTemId1672	:= Len(aCodFol) >= 1672 .And. !Empty(aCodFol[1672, 1])

Private lRecInss := GetNewPar('MV_INSSREC',.F.)  // Recalculo INSS quando rescisao complementar

lResExt	:= If( Type("lResExt") 		== "U"	, .F., lResExt)
lDedInssEx	:= If( Type("lDedInssEx") 	== "U"	, .F., lDedInssEx)
lIrResExt	:= If( Type("lIrResExt") 	== "U"	, .T., lIrResExt)
lInssAut	:= If( Type("lInssAut") 	== "U"	, .T., lInssAut)
lRecRes		:= If( Type("lRecRes") 	== "U"	, .F., lRecRes)
cCompl		:= If( Type("cCompl") 	== "U"	, "N", cCompl)
lDissidio	:= If(lDissidio == Nil,.F.,lDissidio)

// Para os casos em que o funcionário não é autonomo, pode haver acordo
// Entre o Brasil e outros paises, para o não desconto do INSS.
// Para tratar esses acordos o campo RA_INSSAUT é utilizad.
// Se estiver com NÃO, NÃO deverá calcular INSS, independente do RA_CATFUNC.
If cPaisLoc == "BRA" .and. (!lInssAut)
	Return
EndIf

//Caso seja complemento e possua a verba de complemento incluída manualmente, despreza quaisquer diferenças geradas pelo sistema
If cPaisLoc == "BRA" .And. cTipoRot == "6" .And. P_CCOMP13 == 'S' .And. lCalcFol .And. fTem132Per() .And. (aScan(aPd, {|X| X[1] == aCodFol[028,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0) .And. RetValSrv(aCodFol[028,1], SRA->RA_FILIAL, "RV_REF13") == "S"
	fVldCompaPd()
EndIf

lTrunca 	:= If (lTrunca = Nil , .T. , lTrunca)

lRescDis	:= If( type("lRescDis")=="U",.F.,lRescDis)//Rescisao Complementar por Dissidio

If cCompl == "S" 
	nInssP		:= If( nInssAnt	== NIL, 0.00, nInssAnt	)	//Inss ja Pago Para Deduzir do Valor Calculado
	nBAtLim		:= If( nBAtLimA	== NIL, 0.00, nBAtLimA	)	//Base Ate Limite Para Deduzir do Valor Calculado
	nBAcLim		:= If( nBAcLimA	== NIL, 0.00, nBAcLimA	)	//Base Acima Limite Para Deduzir do Valor Calculado
Else
	nInssP		:= If( nInssAnt	== NIL, nInssP, nInssAnt	)	//Inss ja Pago Para Deduzir do Valor Calculado, se não for informado, utiliza o mnemonico
	nBAtLim		:= If( nBAtLimA	== NIL, nBAtLim, nBAtLimA	)	//Base Ate Limite Para Deduzir do Valor Calculado
	nBAcLim		:= If( nBAcLimA	== NIL, nBAcLim, nBAcLimA	)	//Base Acima Limite Para Deduzir do Valor Calculado
EndIf

lCond		:= If( lCond	== NIL, .T. , lCond		)	//Se deseja condicao na Somainc
nInss13_b	:= 0.00

If !Empty( aCodFol[290,1] ) //Base Inss Outras Empresas 13o. Salario
	aEval( aPD , { |x| nBaseOut += If( x[1] == aCodFol[290,1] .and. x[9] # "D", x[5] , 0.00 ) } )
	If nBaseOut == 0 .and. fTem132Per() .and. P_CCOMP13 == 'S' .And. SRA->RA_TPCONTR <> "3"
		fBuscaAcmPer(aCodFol[290,1],"","V",@nBaseOut,,cPeriodo,cPeriodo,,,fGetCalcRot("6"),.T.,.F.)
	EndIf
	If nBaseOut > 0 .and. !Empty(aCodFol[1847,1])
		aEval( aPd, { |x| If(x[1] == aCodFol[1847,1] .and. x[9] <> 'D', nBsAutOut += x[5], Nil) } )
	EndIf 
EndIf

If !Empty( aCodFol[291,1] ) //Inss Outras Empresas 13o. Salario
	aEval( aPD , { |x| nInssOut += If( x[1] == aCodFol[291,1] .and. x[9] # "D", x[5] , 0.00 ) } )
	If nInssOut == 0 .and. fTem132Per() .and. P_CCOMP13 == 'S' .And. SRA->RA_TPCONTR <> "3"
		fBuscaAcmPer(aCodFol[291,1],"","V",@nInssOut,,cPeriodo,cPeriodo,,,fGetCalcRot("6"),.T.,.F.)
	EndIF
EndIf

// Rescisao complementar por dissidio (lRescDis) ou somente complementar (lRecInss, parametro MV_INSSREC), salvar BASE E INSS ja calculados.
If cCompl = "S"  //Rescisao Complementar

	If lRescDis .or. lRecInss .Or. lProxMes .Or. ( Type("lRescRet") <> "U" .And. lRescRet)// Dissidio or Parametro MV_INSSREC como T
		If lRescDis .Or. ( Type("lRescRet") <> "U" .And. lRescRet)
            Car_inss(@aTInss,MesAno(dDatadem)) // Carrregar tabela inss do mes\ano data rescisao
        EndIf

		aEval( aPdResc , { |x| nBaseOut += If (x[1] $ aCodFol[19,1]+"*"+ aCodFol[20,1]+"*"+ aCodFol[399,1] .and. X[3] == cSemana .and. X[9] # "D" .and. AnoMes(M->RG_DTGERAR) <> AnoMes(x[18]), x[5], 0.00)})
		aEval( aPdResc , { |x| nInssOut += If( x[1] $ aCodFol[70,1]+"*"+ aCodFol[401,1] .and. x[3] == cSemana .and. x[9] # "D" .and. AnoMes(M->RG_DTGERAR) <> AnoMes(x[18]), x[5] , 0.00 )})
		
		If lProxMes
			aEval( aPdResVals , { |x| nBaseOut += If (x[1] $ aCodFol[19,1]+"*"+ aCodFol[20,1] .And. X[3] = cSemana .And. MesAno(M->RG_DTGERAR) == MesAno(X[Len(X)]) .And. X[9] # "D",x[5],0.00) })
			aEval( aPdResVals , { |x| nInssOut += If( x[1] == aCodFol[70,1] .And. MesAno(M->RG_DTGERAR) == MesAno(X[Len(X)]) .and. x[9] # "D" .and. x[3] == cSemana , x[5] , 0.00 ) } )    			
		EndIf
	EndIf
    
    // Em casos de demissão no mes 12, onde a segunda parcela do 13 foi paga, as bases de INSS devem ser somadas à base apurada na complementar.
    If Month(dDataDem) == 12 .And. AnoMes(M->RG_DTGERAR) > AnoMes(dDataDem) .And. nInssP > 0 .And. nBAtLim > 0
    	nBaseOut += (nBAtLim + nBAcLim)
    	nBaseOAt := nBAtLim
    	nBaseOAc := nBAcLim
    	nBaseOIn := nInssP
    	nInssOut += nInssP
    EndIf
EndIf

If SRA->RA_TPCONTR == "3" 

	cVerba13 := "% SRD.RD_PD IN('"+ aCodFol[19,1]+"','"+ aCodFol[20,1]+"','"+ aCodFol[70,1]+"')  %"
	cTmpAlias := GetNextAlias()
	BeginSql alias cTmpAlias
		SELECT SRD.RD_PD,SRD.RD_VALOR 
		FROM %table:SRD% SRD 
		WHERE 
		%exp:cVerba13% AND SRD.D_E_L_E_T_= '' 
		AND SRD.RD_FILIAL = %exp:SRA->RA_FILIAL%
		AND SRD.RD_MAT = %exp:SRA->RA_MAT%
		AND SRD.RD_DTREF BETWEEN %exp:substr(cPeriodo,1,4)+"0101"% AND %exp:substr(cPeriodo,1,4)+"1231"%
	EndSql
	
	While !(cTmpAlias)->(Eof())
		If (cTmpAlias)->RD_PD == aCodFol[070,1]
			//nInssP += (cTmpAlias)->RD_VALOR
			nInssOut += (cTmpAlias)->RD_VALOR
		EndIf
		//--Base do Inns Ate Limite ja Descontado na 2a. Parcela
		If (cTmpAlias)->RD_PD == aCodFol[019,1]
			//nBAtLim += (cTmpAlias)->RD_VALOR
			nBaseOut += (cTmpAlias)->RD_VALOR
		EndIf
		//--Base do Inns Acima Limite ja Descontado na 2a. Parcela
		If (cTmpAlias)->RD_PD == aCodFol[020,1]
			//nBAcLim += (cTmpAlias)->RD_VALOR
			nBaseOut += (cTmpAlias)->RD_VALOR
		EndIf
		
		(cTmpAlias)->(dbSkip())
	EndDo
	(cTmpAlias)->(dbCloseArea())
EndIf

If Ascan(aPd,{ |X| X[1] = aCodfol[70,1] .And. X[3] == cSemana .And. X[9] # "D"}) = 0

	//-- Base de Inss 13o
	//--Verifica se lancou Base de Inss somando as verbas 
	nInss13_b := 0.00
	
	If !(P_CCOMP13 = 'S' .And. cRot == fGetCalcRot('6') .And. lCalcFol) .And. SRA->RA_TPCONTR <> "3" //Se estiver calculando complementar desconsidera bases lançadas
		Aeval( aPd ,{ |X| nInss13_B += If (x[1] $ aCodFol[19,1]+"*"+aCodFol[20,1] .And. X[9] # "D" ,x[5],0.00) })
	EndIf

	If nInss13_b == 0.00	
		//-- Soma Incidencia para Inss
		If SRA->RA_TPCONTR <> "3"
			Aeval( aPd ,{ |X| SomaInc(X,4,@nInss13_b,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol,Nil,Nil,Nil,Nil,Nil,Nil,.T.) } )
		Else
			Aeval( aPd ,{ |X| SomaInc(X,4,@nInss13_b,If(lCond,12,Nil),If(lCond,"S",Nil), , , ,.F.,aCodFol) } )
			Aeval( aPdConvoc ,{ |X| SomaInc(X,4,@nInss13_b,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol) } )
		EndIf
	EndIf
	
	//Quando for dissidio, estiver calculando a segunda parcela do 13º e utilizar reajuste de 13º pelas verbas incorporadas na folha, carrega as verbas que incorporaram na folha
	If nInss13_b >0 .and. cTipoRot $ "1*6" .and. lDissidio .and. Type("P_LDIFINC") <> "U" .And. P_LDIFINC
		fRetPerComp(SubStr(cPeriodo,5,2), SubStr(cPeriodo,1,4), Nil, Nil, fGetRotOrdinar(), @aPerAberto, @aPerFechado)
		aVerbasLanc := RetornaVerbasFunc(SRA->RA_FILIAL,SRA->RA_MAT,NIL,fGetRotOrdinar(),,aPerAberto,aPerFechado,,"RV_INCORP=='S'")
		If Len(aVerbasLanc) > 0
			If cTipoRot == "6"
				For nPos := 1 to Len(aVerbasLanc)
					nInss13_b += aVerbasLanc[nPos,7]
				Next nPos
			ElseIf IsInCallStack("GravaDissidio") .and. Len(aPercDif) > 0
				nIndice := aPercDif[Len(aPercDif),2]
				For nPos := 1 to Len(aVerbasLanc)
					nInss13_b -= ( aVerbasLanc[nPos,7] * (nIndice/100))
				Next nPos
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Afastamento por Adocao, considerar base integral              ³
 	//³nAvos = meses para calculo do 13.salario                      ³
 	//³nAvoEnc = meses afastados por adocao                          ³
 	//³nInss13_b = base do inss gerada.                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//nAvoEnc := 0
	//Aeval( aAfast ,{ |X| nAvoEnc += If( X[5] == "B", X[1], 0 ) })
	If nAvoEnc > 0 .and. nAvos > 0 .and. nInss13_b > 0  
		nInss13_b   := NoRound((nInss13_b / nAvos * (nAvos + nAvoEnc) ))
	EndIf

	//-- Funcao para calcular o Inss
	nInss := nInss1 := nBaseAt := nBaseAc := nBaseTot := 0.00
	nBaseTot += ( nInss13_b + nBaseOut + nBasAuxD1 )
	
	//Abate base de INSS calculada na rescisão complementar.
	If !Empty(SRA->RA_DEMISSA) .and. AnoMes(SRA->RA_DEMISSA) < cPeriodo .and. cTipoRot == "1"
		Aeval( aPd ,{ |X| nBaseTot -= If (x[1] == aCodFol[399,1] .And. X[9] # "D",x[5],0.00) })
	EndIf
		
	If nInss13_b > 0.00
		Calc_Inss(aTInss,nBaseTot,@nInss,@nInss1,@nBaseAt,@nBaseAc,@nAliq,nBaseOut,lTrunca,,@aInssFx,,,nBsAutOut)
		If nBasAuxD1 > 0
			nBaseTot -= nBasAuxD1
			Calc_Inss(aTInss,nBaseTot,0,0,@nBaseAt,@nBaseAc,0,nBaseOut,lTrunca,,aClone(aInssFx),,,nBsAutOut)
		EndIf

		//-- Se informou o Inss Outras Empresas Subtrai do Inss Calculado
		If nBaseOut > 0.00 .or. nInssOut > 0.00

			If nInssAOut > 0 .or. nBsAutOut == 0
				nInss	:= Max( nInss - ( nInssOut - nInssAOut) , 0 )
			Else
				aEval( aPd, { |x| If(x[1] == aCodFol[1847,1] .and. x[9] <> 'D', nRefAut := x[4], Nil) } )
				nRefAut := If(Empty(nRefAut),11,nRefAut)
				nInss	:= Max( nInss - Max(( nInssOut - (nBsAutOut * (nRefAut/100))),0) , 0 )
			EndIf 

			//-- Se informou o Inss Outras Empresas Subtrai do Inss Calculado
			If nInssOut > 0
				If nInssAOut > 0 .or. nBsAutOut == 0
					nInss1	:= Max( nInss1 - ( nInssOut - nInssAOut) , 0 )
				Else 
					nInss1	:= Max( nInss1 - Max(( nInssOut - (nBsAutOut * (nRefAut/100))),0) , 0 )
				EndIf 
			Else
				//-- Calcular a Deducao de Inss no Ir sobre a Base da outra empresa 
				//-- Para abater da deducao total 
				nDedInss := 0.00                           
				Calc_Inss(aTInss,nBaseOut-nBsAutOut,,@nDedInss,,,,,lTrunca,,aClone(aInssFx))
				nInss1	:= Max( nInss1 - nDedInss , 0 )
			EndIf	
		EndIf

		//-- Proporcionaliza Inss Salario x Outras Empresas
		If nBaseOut > 0.00 .and. nInss13_b > 0.00 .and. nInssOut == 0.00
			nInss_Ou	:= NoRound( ( nBaseOut / nBaseTot ) * nInss )
			nInss		-= nInss_Ou
			nInss_O1	:= NoRound( ( nBaseOut / nBaseTot ) * nInss1 )
			nInss1		-= nInss_O1
		EndIf
		
		If lRescDis 
			If lProxMes
				If Month(dDataDem) == 12 .And. nInssP > 0 .And. nBAtLim > 0
					FMatriz( acodfol[399,1] ,( Max( ( nBaseAt + nBaseOAt) - nBAtLim , 0 ) + Max( ( nBaseAc + nBaseOAc) - nBAcLim , 0 ) ) )
					FMatriz( aCodfol[401,1] ,( Max( ( nInss + nBaseOIn ) - nInssP  , 0 ) ) , nAliq )
				Else
					FMatriz( acodfol[399,1] ,( Max(nBaseAt - nBAtLim , 0 )+ Max(nBaseAc - nBAcLim , 0 ) ) )
					FMatriz( aCodfol[401,1] ,( Max(nInss   - nInssP  , 0 ) ) , nAliq )
				EndIf
			Else 
				If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[20,1] ))
					FMatriz(aCodfol[399,1], Max((nBaseAc - nBAcLim)-SRR->RR_VALOR, 0) , , , , ,"R" )//Base INSS 13 Acima Dissidio
					FMatriz(acodfol[020,1], SRR->RR_VALOR  )
					FMatriz(aCodfol[019,1],( Max(nBaseAt - nBAtLim, 0 ) ) )
				Else
					If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[19,1] ))
	 					FMatriz(aCodfol[399,1], Max((nBaseAt + nBaseAc)-SRR->RR_VALOR, 0) , , , , ,"R" )//Base INSS 13 Acima Dissidio
						FMatriz(acodfol[019,1], SRR->RR_VALOR )
					EndIf
				EndIf                    

				If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[70,1] ))
					FMatriz(aCodfol[401,1], Max( (nInss-nInssP)- SRR->RR_VALOR, 0 ) , , , , ,"R" )// INSS 13 Dissidio
					FMatriz(aCodfol[070,1], SRR->RR_VALOR  , nAliq ) // INSS 13
				EndIf
			EndIf	
		Else
			If (IsInCallStack("GPEM020") .And. !SRA->RA_SITFOLH == "D") .Or. !IsInCallStack("GPEM020")
				If cCompl == "S" .and. Month(dDataDem) == 12 .And. nInssP > 0 .And. nBAtLim > 0
					FMatriz( acodfol[020,1] ,( Max( ( nBaseAc + nBaseOAc) - nBAcLim , 0 ) ) )
					FMatriz( aCodfol[019,1] ,( Max( ( nBaseAt + nBaseOAt) - nBAtLim , 0 ) ) )
					FMatriz( aCodfol[070,1] ,( Max( ( nInss + nBaseOIn ) - nInssP  , 0 ) ) , nAliq )
				Else
					If cTipoRot == "4" .And. lTemId1672 .And. aScan(aPd, { |x| x[1] == aCodFol[247, 1] .And. x[9] != "D" } ) > 0  .And. nInssP > nInss
						FMatriz( aCodfol[1678,1], nBAcLim - nBaseAc )
						FMatriz( aCodfol[1673,1], nBAtLim - nBaseAt )
						FMatriz( aCodfol[1672,1], nInssP - nInss )
					Else
						FMatriz( acodfol[020,1] ,( Max (nBaseAc - nBAcLim , 0 ) ) )
						FMatriz( aCodfol[019,1] ,( Max( nBaseAt - nBAtLim , 0 ) ) )
						FMatriz( aCodfol[070,1] ,( Max( nInss - nInssP  , 0 ) ) , nAliq )
					EndIf
				EndIf
			Endif
		EndIf	
	EndIf

	//Deducao INSS P/IRF
	If  Round(Max(nInss1   - nInssP  , 0 ),2) > 0.00 
		If !lResExt .Or. (lDedInssEx .And. lIrResExt)
			FMatriz( aCodfol[169,1], Round(Max(nInss1 - nInssP, 0), 2) )
		Endif
	EndIf
EndIf

//Gera as verbas de INSS por faixa
If !Empty(aInssFx) .and. !Empty(aPdFx[1])
	fCInssFx(aInssFx,aPdFx)
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCIr     ³ Autor ³ Equipe RH             ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Ir  Funcionario Normal                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCIr(aCodfol)                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCIr(aCodfol,aTabir,cTipo,dDataHom,cFilialCor,cNumDepIr,cTipoPgto, nBaseTot)

Local aPdAux        := {}
Local aBenOp        := RetBenOp()
Local aCodBenef     := {}
Local aTabIrRRA     := {}
Local nAliqComp     := 0
Local nAliqSimp     := 0
Local nBaseAnt      := 0
Local nContPD       := 0
Local nDedPerAnt    := 0
Local nDedUltSimp   := 0
Local nDeduPrev     := 0
Local nDeduSimp     := 0
Local nIR_BComp     := 0
Local nIR_BSimp     := 0
Local nIrAnt        := 0
Local nIRComp       := 0
Local nIRSimp       := 0
Local nPosBIrAnt	:= 0
Local nPosIrAnt		:= 0
Local nAliq         := 0
Local nMeses        := 0
Local nNumFer       := 0
Local nCntP   
Local cBenOp        := GetBenOP()
Local cIRPlr        := ""
Local cQuery        := ""
Local cAliasQry     := ""
Local cModTribAnt   := ""
Local cTribuIR      := "1"
Local cUltSemSimpl  := ""
Local cVerbDed      := ""
Local nX            := 0
Local nAntBIR 	    := 0
Local nAntDIR 	    := 0
Local nIr_bMUltV    := 0
Local lCalcPensao   := IsInCallStack("fCalcPensao")
Local lMultvCIR	    := IsInCallStack("CalcMVProcessa") .And. !IsInCallStack("S_RECFOL")
Local lMultv        := Type("lUtiMultiV") <> "U" .And. lUtiMultiV
Local lMP1171       := .F.
Local lSemIr_B		:= .F.
Local aPdBkp        := {}
Local nBsTar	    := 0
Local nBsTarIr	    := 0
Local aperA		    := {}
Local aperF		    := {}
Local aperT		    := {}
Local nPos		    := 0
Local nPos1		    := 0
Local nPos2		    := 0
Local nIr_BasMV     := 0
Local nIr_MV	    := 0
Local nDed_MV 		:= 0
Local nDed_Aux      := 0
Local lIrNeg	    := Len(aCodFol) >= 1726 .And. !Empty(aCodFol[1726,1]) .And. !Empty(aCodFol[1727,1])
Local lMVSimpl 		:= .F.
Local nVal			:= 0
Local nIrB_cpy      := 0
Local lAbateu		:= .T.
Local lValidaAdi    := .F.

DEFAULT cFilialCor	:= SRA->RA_FILIAL		// Filial corrente
DEFAULT cNumDepIr	:= SRA->RA_DEPIR		// Numero de dependentes para IR
DEFAULT cTipoPgto	:= SRA->RA_TIPOPGT		// Tipo de pagamento da folha
DEFAULT nBaseTot	:= 0
DEFAULT lVerMultv   := If ( Type("P_MULTV") == "U",.F.,P_MULTV)
DEFAULT lTemRU6 	:= AliasInDic("RU6")
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo


lAutMEI		:= If( Type("lAutMEI") 		== "U"	, .F., lAutMEI)
lResExt		:= If( Type("lResExt") 		== "U"	, .F., lResExt)
lIrResExt	:= If( Type("lIrResExt") 	== "U"	, .T., lIrResExt)

//Para MEI nao ira calcular o IR
If lAutMEI .Or. ( Type("lUtiMultiV")<> "U" .And. lUtiMultiV .And. LCALCCOMPL .And. !lMultvCIR .And. !IsInCallStack("fCalCompl") )
	Return
Endif

//Indica se deve calcular RRA na rescisao
lRescRRA := If(Type("lRescRRA") == "U",.F.,lRescRRA)
cTipoRot := If(Type("cTipoRot") == "U" .or. cTipoRot == Nil, "",cTipoRot)
lMP1171  := ( cPaisLoc == "BRA" .And. Len(aTabIr) >= 7 .And. aTabIr[7, 4] == "S" .And. !lResExt )

cTipo    := If(cTipo=Nil,"",cTipo)

dDataHom := If(dDataHom=Nil,dDataAte,dDataHom)

If Type("lRescMSeg") == "U"
	lRescMSeg:= .F.
EndIf

If Type("aPdResVals") == "U"
	aPdResVals := {}
EndIf

nVal_Peal := nBasered := 0.00

//-- CALCULO DO I.R. NORMAL
If Ascan(aPd,{ |X| X[1] = aCodfol[66,1] .And. X[3] = cSemana .And. X[9] # "D"}) = 0
	nIR_B := nVal_Peal := 0.00
	If nBaseTot == 0
		//-- Procura Base de IR. na Data de pagamento, quandop vem da rescisão vem com 
		//-- a data da rescisao e não pode ser recalculada na folha
		aEval( aPD , { |x| nIr_b += If( X[1] = aCodfol[15,1] .And. X[3] = cSemana .And. X[9] # "D" .And. ( X[10] == NIL .Or. Empty(X[10]) .Or. MesAno(dDataHom) = MesAno(X[10]) ), x[5] , 0.00 ) } )
		
		If lIrNeg
			aEval( aPD , { |x| nIr_b -= If( X[1] = aCodfol[1726,1] .And. X[3] = cSemana .And. X[9] # "D" .And. ( X[10] == NIL .Or. Empty(X[10]) .Or. MesAno(dDataHom) = MesAno(X[10]) ), x[5] , 0.00 ) } )		
		EndIf
	Else
		nIR_B := nBaseTot
	EndIf

	If nIR_B = 0.00
	
		cIRPlr:= fPdIrPLR()
		dbSelectArea('SRQ')
		If SRQ->(dbSeek(SRA->RA_FILIAL + SRA->RA_MAT))
			While SRA->RA_FILIAL + SRA->RA_MAT == SRQ->RQ_FILIAL + SRQ->RQ_MAT .And. !EOF()
		   		cIRPlr+= RQ_VERBPLR +"/"
		   		SRQ->(dbSkip())
		   	EndDo	
		EndIf

		//--Soma Incidencia para Base de I.R. (Alterado para Somar so quando a Semana Informada For Menor ou Igual a cSemana)
		//-- Nao Somar a verba de Distribuicao de Lucro porque o Ir e separado
		If __lMemCalc  
			fAddMemLog("Verbas com incidência para IR: ", 1, 2)
		EndIf
		If SRA->RA_TIPOPGT == "M"
			Aeval( aPd ,{ |X| IF(X[3] <= cSemana .And. !(X[1] $ cIRPlr),SomaInc(X,5,@nIR_B,11,"N",12,"N",Month(dDataHom),,aCodFol,,,If(lMultV, .T. ,.F.), NIL, NIL, NIL, .T.),NIL) } )

			If cPaisLoc == "BRA" .And. cInssFM == "N"
				nIrB_cpy := nIr_B
				nPos1 := aScan(aPd, { |x| x[1] == aCodfol[72, 1] .And. x[9] # "D" .And. x[7] == "K" })
				nPos2 := aScan(aPd, { |x| x[1] == aCodfol[168, 1] .And. x[9] # "D" .And. x[7] == "C" })
				If nPos1 > 0 .And. nPos2 > 0 .And. AnoMes( aPd[nPos1, 18] ) <= AnoMes( aPd[nPos2, 18] )
					AEval( aPd, { |X| IiF( X[3] <= cSemana .And. X[1] == aCodfol[168, 1] .And. x[7] == "C", SomaInc(X, 5, @nIR_B, Nil, Nil, Nil, Nil, Month(dDataHom), Nil, aCodFol, Nil, Nil, Iif(lMultV, .T. ,.F.), Nil, Nil, .T. ), Nil ) } )
					If nIrB_cpy == nIr_B
						lAbateu := .F.
					EndIf
				EndIf
			EndIf

			If nIR_B > 0 .And. cTipo == "R" .And. cCompl == "S" .and. lProxMes //Se complementar é no mês seguinte, verifica se pagamento da primeira rescisão ocorreu no mesmo Ano/Mes da complementar atual
				AEval( aPdResc, { |X| Iif( X[3] <= cSemana .And. !(X[1] $ cIRPlr) .And. AnoMes(x[18]) == AnoMes(dDataDem) .And. AnoMes(x[10]) == AnoMes(dDataHom), SomaInc(X, 5, @nIR_B, 11, "N", 12, "N", Month(dDataHom), Nil, aCodFol, Nil, Nil, Iif(lMultV, .T. ,.F.), Nil, Nil, .T. ), Nil ) } )
				fSomaIrMesAnt(cIRPlr, dDataHom, lMultV, dDataDem)
			EndIf
		Else
			If lMultv
				aPdBkp := AClone(aPd)
				For nX := 1 To Len(aPd)
					If aPd[nX,3] <> cSemana
						aPd[nX,3] := cSemana
					EndIf
				Next nX
			EndIf

			Aeval( aPd, { |X| IF(X[3] == cSemana .And. !(X[1] $ cIRPlr), SomaInc(X,5,@nIR_B,11,"N",12,"N",Month(dDataHom),,aCodFol,,,.T., NIL, NIL, NIL, .T.), NIL) } )
			If nIR_B > 0 .And. cSemana > "01"
				Aeval( aPd, { |X| IF(X[3] < cSemana .And. !(X[1] $ cIRPlr), SomaInc(X,5,@nIR_B,11,"N",12,"N",Month(dDataHom),,aCodFol,,,.T., NIL, NIL, NIL, .T.), NIL) } )
			EndIf
			
			If cSemana > "01" .and. SRA->RA_CATEG <> "15" //Verifica se a base de IR mês anterior esta na mesma competência do cálculo atual e soma na base de IR
				Aeval(aPd,{ |X| nIr_b += If ( X[1]==aCodFol[106,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. x[3] == "01" ,X[5],0) })
				If lIrNeg
					Aeval(aPd,{ |X| nIr_b -= If ( X[1]==aCodFol[1727,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. x[3] == "01" ,X[5],0) })
				EndIf
			EndIf

			If lMultv
				aPd := AClone(aPdBkp)
			EndIf
		EndIF
		If SRA->RA_TPCONTR == "3"
			Aeval( aPdConvoc ,{ |X| IF(X[3] <= cSemana .And. !(X[1] $ cIRPlr),SomaInc(X,5,@nIR_B,11,"N",12,"N",Month(dDataHom),,aCodFol,,,.F.),NIL) } )
		EndIf
		
		If cTipoRot == "O" .And. !aBenOp[4]
			Aeval( aPdBenOp ,{ |X| Iif(X[26] < cBenOp .And. !(X[1] $ cIRPlr), SomaInc(X, 5, @nIR_B, 11, "N", 12, "N", Month(dDataHom), Nil, aCodFol, Nil, Nil, .F.), Nil) } )
		EndIf
		
		//Se for complementar MULTV considera os valores anteriores também
		If IsInCallStack("fCalCompl") .And. Len(aCPFAll) > 0
			//AEval( aPd ,{ |X| IIf(X[1] == aCodFol[0064,1],X[9] := "D",Nil) })
			
			cAliasQry := GetNextAlias()
			
			cQuery := " SELECT * FROM " + RetSqlName("SRC")
			cQuery += " WHERE "
			cQuery += " ( "
			For nX := 1 To Len(aCPFAll)
				cQuery += " ( RC_FILIAL = '" + aCPFAll[nX,2] + "' AND"
				cQuery += " RC_MAT = '" + aCPFAll[nX,3] + "' )"
				
				If nX <> Len(aCPFAll)
					cQuery += " OR "
				EndIf
			Next nX
			cQuery += " ) AND"
			cQuery += " RC_PROCES = '" + cProcesso + "' AND"
			cQuery += " RC_PERIODO = '" + cPeriodo + "' AND"
			cQuery += " RC_ROTEIR = '" + cRot + "' AND"
			cQuery += " RC_SEMANA < '" + cSemana + "' AND"
			cQuery += " RC_PD IN('" + aCodFol[0010,1] + "','" + aCodFol[0015,1] + "','" + aCodFol[0016,1] + "') AND" //Bases de IR
			cQuery += " D_E_L_E_T_ = ' ' "
			
			cQuery := ChangeQuery(cQuery)
			
			DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)
			
			While (cAliasQry)->( !Eof() )
				nIR_B += (cAliasQry)->RC_VALOR
				(cAliasQry)->( DbSkip() )
			EndDo
			
			(cAliasQry)->( DbCloseArea() )
		ElseIf Type("lUtiMultiV")<> "U" .And. lUtiMultiV .And. lMultvCIR .And. LCALCCOMPL
			cAliasQry := GetNextAlias()
			
			cQuery := " SELECT * FROM " + RetSqlName("SRC")
			cQuery += " WHERE"
			cQuery += " RC_FILIAL = '" + SRA->RA_FILIAL + "' AND"
			cQuery += " RC_MAT = '" + SRA->RA_MAT + "' AND"
			cQuery += " RC_PROCES = '" + cProcesso + "' AND"
			cQuery += " RC_PERIODO = '" + cPeriodo + "' AND"
			cQuery += " RC_ROTEIR = '" + cRot + "' AND"
			cQuery += " RC_SEMANA < '" + cSemana + "' AND"
			cQuery += " RC_PD IN('" + aCodFol[0010,1] + "','" + aCodFol[0015,1] + "','" + aCodFol[0016,1] + "','" + aCodFol[0066,1] + "') AND" //Bases de IR e IR
			cQuery += " D_E_L_E_T_ = ' ' "
			
			cQuery := ChangeQuery(cQuery)
			
			DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)
			
			While (cAliasQry)->( !Eof() )
                If (cAliasQry)->RC_PD $ aCodFol[0010,1] + "/" + aCodFol[0015,1] + "/" + aCodFol[0016,1]
					nAntBIR += (cAliasQry)->RC_VALOR
					nIR_B 	+= (cAliasQry)->RC_VALOR
				ElseIf (cAliasQry)->RC_PD == aCodFol[0066,1]
					nAntDIR += (cAliasQry)->RC_VALOR
				EndIf				
				(cAliasQry)->( DbSkip() )
			EndDo
		EndIf
        
		If lResExt
			//-- Busca os codigos de pensao definidos no cadastro de beneficiarios
			fBusCadBenef(@aCodBenef, "FOL")
			For nCntP := 1 To Len(aCodBenef)
				aEval( aPD , { |x| nIR_B += If( x[1] == aCodBenef[nCntP,1] .And. x[9] # "D", x[5] , 0.00 ) } )
			Next nCntP
		EndIf

		//-- Soma o Valor de Base da Pensao Alimenticia
		If aCodfol[57,1] # "   "
			aEval( aPD , { |x| nVal_Peal += If( x[1] == aCodFol[57,1] .And. x[9] # "D", x[5] , 0.00 ) } )
		EndIf

		//-- Busca os codigos de pensao definidos no cadastro de beneficiarios
		fBusCadBenef(@aCodBenef, "ADI", {aCodfol[58,1]})
		For nCntP := 1 To Len(aCodBenef)
			aEval( aPD , { |x| nVal_Peal -= If( x[1] == aCodBenef[nCntP,1] .And. x[9] # "D", x[5] , 0.00 ) } )
		Next nCntP

		//--Abate da Base de Ir o Valor da Pensao
		nIr_b 	 -= If( lResExt,0,Max(nVal_Peal, 0))
		nVal_Peal := 0

		//-- Procura Cod. Base Deducao Previdencia Privada (exceto para residentes no Exterior)
		If aCodfol[215,1] # "   " .And.  RetValSrv(aCodFol[215,1],cFilialCor,"RV_IR") == "S" .And. !lResExt
			aEval( aPD , { |x| nDeduPrev += If( x[1] == aCodFol[215,1] .And. X[9] # "D", x[5] , 0.00 ) } )		
            nIr_b -= nDeduPrev
		EndIf

		//-- Procura Base de Ir Mes Anterior
		If cTipo # "R" .And. ( cSemana == "01" .or. lMultV )
			Aeval(aPd,{ |X| nIr_b += If ( X[1]==aCodFol[106,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. ( (!lMultV .and. cSemana == "01" ) .or. ( X[7] <> 'F' )) ,X[5],0) })
			If lIrNeg
				Aeval(aPd,{ |X| nIr_b -= If ( X[1]==aCodFol[1727,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. ( (!lMultV .and. cSemana == "01" ) .or. ( X[7] <> 'F' )) ,X[5],0) })
			Endif
			If lMultV
				Aeval(aPd,{ |X| nIr_bMUltV += If ( X[1] == aCodFol[106,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. X[7] == 'G'  ,X[5],0) })
				If lIrNeg
					Aeval(aPd,{ |X| nIr_bMUltV -= If ( X[1] == aCodFol[1727,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. X[7] == 'G'  ,X[5],0) })
				Endif
			EndIf
		EndIf
	EndIf

	If cTipo # "R" .And. SRA->RA_TIPOPGT == "S" .And. (SRA->RA_CATEG == "15" .OR. SRA->RA_CATEFD $ "711|712")
		fRetPerComp(str(month(DDATA_PGTO)),str(year(DDATA_PGTO)),,,,@aPerA,@aPerF,@apert,.T.,firstday(DDATA_PGTO),DDATA_PGTO)
		aSort( aPerF ,,, { |x,y| x[7] < y[7] } )
		nPos := aScan(aPerF, { |x| x[7] == cProcesso .and. x[1] <> cPeriodo})
		If nPos > 0
			cAliasQry := GetNextAlias()
				
			cQuery := " SELECT * FROM " + RetSqlName("SRD")
			cQuery += " WHERE"
			cQuery += " RD_FILIAL = '" + SRA->RA_FILIAL + "' AND"
			cQuery += " RD_MAT = '" + SRA->RA_MAT + "' AND"
			cQuery += " RD_PROCES = '" + cProcesso + "' AND"
			cQuery += " RD_PERIODO = '" + aPerF[nPos][1] + "' AND"
			cQuery += " RD_ROTEIR = '" + cRot + "' AND"
			cQuery += " RD_PD IN('" + aCodFol[0015,1] + "','" + aCodFol[0066,1] + "') AND" //Bases de IR e IR
			cQuery += " RD_DATPGT between '"+dtos(firstday(DDATA_PGTO))+"' AND '"+dtos(DDATA_PGTO)+"' AND 
			cQuery += " D_E_L_E_T_ = ' ' "
			
			cQuery := ChangeQuery(cQuery)
			
			DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)
			
			While (cAliasQry)->( !Eof() )
	            If (cAliasQry)->RD_PD == aCodFol[0015,1]
					nBsTar  += (cAliasQry)->RD_VALOR
					nIR_B 	+= (cAliasQry)->RD_VALOR
				ElseIf (cAliasQry)->RD_PD == aCodFol[0066,1]
					nBsTarIr += (cAliasQry)->RD_VALOR
				EndIf				
				(cAliasQry)->( DbSkip() )
			EndDo	 
			(cAliasQry)->( dbCloseArea() )
		EndIf
	EndIf

	//-- Variavel Usada na Rescisao (cTipo)
	//-- Busca Base I.R. Adiantamento se Rescisao for no mesmo Mes
	If cTipo = "R"
		lValidaAdi := If(aScan(aPd, {|x| x[1] == aCodFol[6, 1] .And. x[9] != "D" .And. AnoMes(dDataHom) == AnoMes(x[10])}) > 0, RetValSRV(aCodFol[6, 1], SRA->RA_FILIAL, "RV_IR") == "S", .T.)//Se tem ADI, valida se a verba está Sim para IR
		//-- Verifica se Identificador do Adiant. de Salario esta com "S" p/ IR
		If lValidaAdi .Or. ((RetValSRV(aCodFol[006,1],cFilialCor,"RV_IR") == "N") .And. (RetValSRV(aCodFol[007,1],cFilialCor,"RV_IR") == "N")) //* Ajustado condiç?o pois n?o estava somando a base de IR corretamente devido a configuraç?o da verba de adiantamento
			//-- Procura Base de Ir Adto.
			
			nPos := Ascan(aPD,{ |X| X[1] == aCodFol[010,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10])})
			If nPos > 0
				Aeval(aPd,{ |X| nIr_b += If ( X[1]==aCodFol[010,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]),X[5],0) })
			Else
				//-- Procura Base de Ir Mes Anterior
				Aeval(aPd,{ |X| nIr_b += If ( X[1]==aCodFol[106,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]),X[5],0) })
				If lIrNeg
					Aeval(aPd,{ |X| nIr_b -= If ( X[1]==aCodFol[1727,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]),X[5],0) })
				EndIf
			EndIf
			//-- Se encontrado o redutor, soma-o novamente na base de IR
			nPos := Ascan(aPD,{ |X| X[1] == aCodFol[408,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10])})
			If nPos > 0
				nIr_b += aPd[nPos,5]
			EndIf
		EndIf

         //-- Soma IR na base - Rescisao complementar
		If !Empty( aPdResVals )
			Aeval( aPdResVals , { |X| nIr_b += If ( X[1]==aCodFol[015,1] .And. MesAno(dDataHom) = MesAno(x[10]), X[5], 0) })
		EndIf
					
	EndIf
	
	If lIrNeg .And. nIr_b < 0
		FMatriz(aCodfol[1726,1],nIr_B * -1)
	EndIf
	
    If !lRescRRA .And. lMP1171
        fBusCadBenef(@aCodBenef, "FOL")
        fVerPDDed( @cVerbDed, "FOL", aCodBenef, lResExt )            

        If SRA->RA_TIPOPGT == "M"
            Aeval( aPd ,{ |X| IF(X[3] <= cSemana .And. X[1] $ cVerbDed,SomaInc(X,5,@nDeduSimp,11,"N",12,"N",Month(dDataHom),,aCodFol,,,If(lMultV, .T. ,.F.)),NIL) } )
        ElseIf nIR_B > 0 
            Aeval( aPd ,{ |X| IF(X[3] <= cSemana .And. X[1] $ cVerbDed,SomaInc(X,5,@nDeduSimp,11,"N",12,"N",Month(dDataHom),,aCodFol,,,.T.),NIL) } )
        EndIf
        If SRA->RA_TPCONTR == "3"
            Aeval( aPdConvoc ,{ |X| IF(X[3] <= cSemana .And. X[1] $ cVerbDed,SomaInc(X,5,@nDeduSimp,11,"N",12,"N",Month(dDataHom),,aCodFol,,,.F.),NIL) } )
        EndIf
        If cTipoRot == "O" .And. !aBenOp[4]
            Aeval( aPdBenOp ,{ |X| Iif(X[26] < cBenOp .And. X[1] $ cVerbDed, SomaInc(X, 5, @nDeduSimp, 11, "N", 12, "N", Month(dDataHom), Nil, aCodFol, Nil, Nil, .F.), Nil) } )
        EndIf

		If nIR_B > 0 .And. cTipo == "R" .And. cCompl == "S" .and. lProxMes //Se complementar é no mês seguinte, verifica se pagamento da primeira rescisão ocorreu no mesmo Ano/Mes da complementar atual
			Aeval( aPdResc ,{ |X| If(X[3] <= cSemana .And. X[1] $ cVerbDed .and. MesAno(x[18]) == MesAno(dDataDem) .and. MesAno(x[10]) == MesAno(dDataHom),SomaInc(X,5,@nDeduSimp,11,"N",12,"N",Month(dDataHom),,aCodFol,,,If(lMultV, .T. ,.F.)),NIL) } )
        EndIf

		If cTipoRot == "1" .and. SRA->RA_TIPOPGT == "M" .and. cInssFM == "N" .and. lAbateu
			//Se houve recalculo do INSS, a diferença foi abatida da verba original de Base do IR, 
			//soma essa diferença para que gere a base de IR outros modelos corretamente
			nPos1 := aScan(aPd, { |x| x[1] == aCodfol[72, 1] .And. x[9] # "D" .And. x[7] == "K" })
			nPos2 := aScan(aPd, { |x| x[1] == aCodfol[168, 1] .And. x[9] # "D" .And. x[7] == "C" })
			If nPos1 > 0 .And. nPos2 > 0 .And. AnoMes( aPd[nPos1, 18] ) <= AnoMes( aPd[nPos2, 18] )
				nDeduSimp -= aPd[nPos2, 5]
			EndIf
		EndIf

        nDeduSimp *= (-1)
    EndIf

	nIr_b := If(nIr_b<0,0,nIr_b)
	
	//-- FUNCAO PARA CALCULAR I.R.
	nIr := nBaseRed := 0.00
	nVal_DedDep := val(cNumDepIr)

	If lVerMultv
		aEval( aPd, { |X| If ( x[1] $ aCodFol[992,1] .And. x[3] == cSemana .And. X[9] != "D" .And. (x[11] == "9" .Or. x[7] == "I"), nIr_BasMV += x[5], Nil ) } )
		aEval( aPd, { |X| If ( x[1] $ aCodFol[993,1] .And. x[3] == cSemana .And. X[9] != "D" .And. (x[11] == "9" .Or. x[7] == "I"), nIr_MV += x[5], Nil ) } )
		If lMP1171
			aEval( aPd, { |X| If ( x[1] $ aCodFol[1951,1] .And. x[3] == cSemana .And. X[9] != "D" .And. (x[11] == "9" .Or. x[7] == "I"), nDed_MV += x[5], Nil ) } )	
		EndIf
		If nIr_B == 0 .AND. nIr_BasMV > 0  .OR. (nIr_BasMV > 0 .AND. nDed_MV == 0 .AND. nDeduSimp == 0 .AND. !lInssAut) //Vinculo sem base de IR e com base MV ou Sem dedução MV, sem deduções legais e INSS no vinculo atual
			lSemIr_B := .T. 
		EndIf
		If nIr_BasMV > 0 .And. __lMemCalc			
			fAddMemLog("Base IR outros vínculos: R$ " + AllTrim(Transform( nIr_BasMV, "@E 999,999,999,999.99" )), 1, 2)					
			fAddMemLog("Valor do desconto do IR outros vínculos: R$ " + AllTrim(Transform( nIr_MV, "@E 999,999,999,999.99" )), 1, 2)					
			fAddMemLog("Dedução outros vínculos: R$ " + AllTrim(Transform( nDed_MV, "@E 999,999,999,999.99" )), 1, 2)				
		EndIf
	EndIf

	nIr_B += ( nIr_BasMV - nDed_MV )
		
	If lDissidio .And. cTipoRot == "1"
		aEval( aPd, { |X| If ( x[1] $ aCodFol[72,1] .And. x[3] == cSemana .And. X[9] != "D", nNumFer++, Nil ) } )
		aEval( aPd, { |X| If ( x[1] $ (aCodFol[72,1]+"*"+aCodFol[77,1]+'*'+aCodFol[88,1]+'*'+aCodFol[90,1]+'*'+aCodFol[92,1]+'*'+aCodFol[96,1]+'*'+aCodFol[98,1]+'*'+aCodFol[161,1]+'*'+aCodFol[94,1]+'*'+aCodFol[95,1]) .And. x[3] == cSemana .And. X[9] != "D" .And. x[11] > Str(nNumFer, 1), nFgts_b -= x[19], Nil ) } )			
	EndIf

	If !lRescRRA
		If lMP1171
            nIR_BComp := nIr_B
            nIR_BSimp := nIr_B
            If cTipoRot == "4" .And. lValidaAdi .And. ( nPosBIrAnt := aScan( aPd, { |x| x[1] == aCodFol[106, 1] .And. x[9] != "D" .And. AnoMes(dDataHom) == AnoMes(x[10]) } ) ) > 0
			    If ( nPosIrAnt := aScan( aPd, { |x| x[1] == aCodFol[107, 1] .And. x[9] != "D" } ) ) > 0
                    cModTribAnt := Iif( Empty( aPd[nPosIrAnt, 28] ), "1", aPd[nPosIrAnt, 28] )
                Else
                    cModTribAnt := Iif( cPeriodo == "202305" .And. Empty( aPd[nPosBIrAnt, 28] ), "1", Iif( Empty( aPd[nPosBIrAnt, 28] ), "2", aPd[nPosBIrAnt, 28] ) )
                EndIf
                nDedPerAnt  := fDedPerAnt( cModTribAnt == "2" .And. nPosIrAnt == 0 .And. Empty( aPd[nPosBIrAnt, 28] ), @cModTribAnt, ( nPosIrAnt > 0 .And. Empty( aPd[nPosBIrAnt, 28] ) ) )
                If cModTribAnt == "1"
                    nIR_BSimp += nDedPerAnt
                Else
                    nIR_BComp -= nDedPerAnt
                    nIr_B     := nIR_BComp
                EndIf
            EndIf
        EndIf
		If __lMemCalc			
			fAddMemLog("Modelo completo:", 1, 2)					
		EndIf
		CALC_IR(nIr_B,nVal_Peal,@nIr,@nBaseRed,@nVal_DedDep,,aTabIr,,@nAliq)
		If lMP1171
            If aCodFol[215, 1] $ cVerbDed
                nIR_BSimp += nDeduPrev
            EndIf

			nIR_BSimp += ( nDeduSimp + nDed_MV )

			If nIr_BasMV > 0 .and. ( nDed_MV == 0 .or. SRA->RA_CATEFD $ "711|712|734" )//Se MULTV com tributação completa, soma INSS para calcular a verba 1914 corretamente
				nDed_Aux := 0 
				aEval( aPD , { |x| nDed_Aux += IF( x[1] == aCodFol[289,1] .and. x[9] # "D" .and. x[7] # 'I', x[5] , 0.00 ) } )
				If SRA->RA_CATEFD $ "711|712|734"
					nDed_Aux -= nDed_MV
				EndIf
				nIR_BSimp += nDed_Aux
				lMVSimpl  := nDed_Aux == 0 //Se nDed_MV for zero e não existir dedução de INSS da outra empresa, indica que não houve lançamento de verba de INSS e dedução foi simplificada
			EndIf
			If __lMemCalc			
				fAddMemLog("Modelo simplificado:", 1, 2)					
			EndIf
			CALC_IR(nIR_BSimp, 0, @nIrSimp, 0, 0, Nil, aTabIr, Nil, @nAliqSimp, lMP1171)

			If nDed_Aux > 0
				nIR_BSimp -= nDed_Aux
			EndIf 
			
			//Se já existir cálculo de MULTV e Base não for alterada, significa que já foi usada aliquota completa no primeiro vínculo
			If nIr_BasMV == 0 .or. Empty(aCodFol[1951,1]) .or. ( nDed_MV > 0 .and. nDed_Aux == 0) .or. lMVSimpl .or. lSemIr_B 
				If (nIrSimp < nIr .Or. (nIR_BSimp - aTabIr[7, 1] < nIr_B - nVal_DedDep )) .And. nIr_B > 0 .and. (nIr_BasMV == 0 .or. nIr_B <> ( nIr_BasMV - nDed_MV ) .or. ( nIrSimp < nIr .and. lMVSimpl ) .or. ( cSemana <> "01" .and. nIR_B == ( nIr_BasMV - nDed_MV ) ))
					cTribuIR    := "2"
					nAliqComp   := nAliq
					nIRComp     := nIr
					nAliq       := nAliqSimp
					nIR         := nIrSimp
					nIr_B       := nIR_BSimp
				EndIf
			EndIf
        EndIf
	Else
		If !Gpm40LoadRRA(@nIr_B,@nVal_Peal,@aTabIrRRA,@nMeses,dDataHom,aCodFol[974,1],aCodFol[975,1])
			Return
		EndIf
		CALC_IRRRA(nIr_B,nVal_Peal,@nIr,@nBaseRed,@nVal_DedDep,,aTabIrRRA,.F.,@nAliq,nMeses+1)
		nPos := Ascan(aPD,{ |X| X[1] == aCodFol[977,1] .And. X[9] # "D" })
		If nPos > 0
			aPd[nPos,5] := nBaseRed
		EndIf
	EndIf

	If nIr_BasMV > 0
		nIr_B := nIr_B - ( nIr_BasMV - If((SRA->RA_CATEG == "15" .OR. SRA->RA_CATEFD $ "711|712") .and. cSemana == "01" .and. cTribuIR == "1", nDed_MV, 0) )
	EndIf
	nIr   -= nIr_MV
	
    If lMP1171
        Iif( cTribuIR == "1", nIR_BSimp -= nIr_BasMV, nIR_BComp -= nIr_BasMV )
        Iif( cTribuIR == "1", nIrSimp -= nIr_MV, nIRComp -= nIr_MV )
    EndIf

	If cTipo # "R" .And. SRA->RA_TIPOPGT == "S" .And. (SRA->RA_CATEG == "15" .OR. SRA->RA_CATEFD $ "711|712")
		 nIr_b -= nBsTar
		 nIr -= nBsTarIr
        If lMP1171
            Iif( cTribuIR == "1", nIR_BSimp -= nBsTar, nIR_BComp -= nBsTar )
            Iif( cTribuIR == "1", nIrSimp -= nBsTarIr, nIRComp -= nBsTarIr )
        EndIf
	EndIf

	If Type("lUtiMultiV")<> "U" .And. lUtiMultiV .And. lMultvCIR .And. LCALCCOMPL
		nIr_B	-= nAntBIR
		nIr		-= nAntDIR
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Semanalistas ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cTipoPgto == "S" 
		aPdAux := aClone( Iif( cTipoRot == "4", aPdSemAnt, aPd ) )

        AEval( aPdAux, { |X| nBaseAnt += Iif( X[1] == aCodFol[15, 1] .And. X[3] < cSemana .And. AnoMes(dDataHom) == AnoMes(X[10]) .And. X[9] # "D", X[5], 0 ) } )
        AEval( aPdAux, { |X| nIrAnt   += Iif( X[1] == aCodFol[66, 1] .And. X[3] < cSemana .And. AnoMes(dDataHom) == AnoMes(X[10]) .And. X[9] # "D", X[5], 0 ) } )
        
        Iif( lIrNeg, AEval( aPdAux, { |X| nBaseAnt -= Iif( X[1] == aCodFol[1726, 1] .And. X[3] < cSemana .And. AnoMes(dDataHom) == AnoMes(X[10]) .And. X[9] # "D", X[5], 0 ) } ), Nil )
		
		If nBaseAnt > 0 .And. __lMemCalc			
			fAddMemLog("Base IR anterior: R$ " + AllTrim(Transform( nBaseAnt, "@E 999,999,999,999.99" )), 1, 2)					
			fAddMemLog("Valor do desconto do IR anterior: R$ " + AllTrim(Transform( nIrAnt, "@E 999,999,999,999.99" )), 1, 2)					
		EndIf

        If cSemana > "01"
            If aScan( aPdAux, { |x| x[1] == aCodFol[15, 1] .And. X[3] < cSemana .And. AnoMes(dDataHom) == AnoMes(X[10]) .And. X[9] # "D" .And. !Empty(x[28]) } )
                For nContPd := 1 To Len(aPdAux)
                    If aPdAux[nContPd, 1] == aCodFol[15, 1] .And. aPdAux[nContPd, 3] < cSemana .And. aPdAux[nContPd, 28] == "2" .And. aPdAux[nContPd, 3] > cUltSemSimpl
                        cUltSemSimpl := aPdAux[nContPd, 3]
                    EndIf
                Next nContPd
            EndIf
            If !Empty(cUltSemSimpl)
                AEval( aPdAux, { |X| Iif( X[3] <= cUltSemSimpl .And. X[1] $ cVerbDed, SomaInc(X, 5, @nDedUltSimp, 11, "N", 12, "N", Month(dDataHom), Nil, aCodFol, Nil, Nil, .T. ), Nil ) } )
                nDedUltSimp *= (-1)
            EndIf
            If lMP1171 .And. cTribuIR == "1"
                nIr_B       += nDed_MV
                nIR_BComp   += nDed_MV
            EndIf
        EndIf

		If !(SRA->RA_CATFUNC $ "A*P") .or. SRA->RA_CATEG == "15" //Nos demais casos mantém a base de IR cheia
			nIr_B -= (nBaseAnt - Iif( lMP1171 .And. cTribuIR == "1", nDedUltSimp, 0 ) )
            If lMP1171
                Iif( cTribuIR == "1", nIR_BSimp -= nBaseAnt, nIR_BComp -= (nBaseAnt - nDedUltSimp) )
            EndIf
		EndIf
		nIr   -= nIrAnt
        If lMP1171
            Iif( cTribuIR == "1", nIrSimp -= nIrAnt, nIRComp -= nIrAnt )
        EndIf
	EndIf

	If cTipoRot == "O" .And. !aBenOp[4]
		aEval( aPdBenOp, { |x| nIrAnt += Iif(x[1] == aCodFol[66,1] .And. x[26] < cBenOp .And. (Empty(X[10]) .Or. MesAno(dDataHom) == MesAno(X[10])) .And. x[9] # "D", x[5], 0) } )
		nIr -= nIrAnt
        If lMP1171
            Iif( cTribuIR == "1", nIrSimp -= nIrAnt, nIRComp -= nIrAnt )
        EndIf
	EndIf

	//--Abater Ir Mes Anterior so quando for Mesmo Mes
	If cTipo # "R" .And. ( cSemana == "01" .or. lMultV ) .and. !( SRA->RA_TIPOPGT == "S" .And. (SRA->RA_CATEG == "15" .OR. SRA->RA_CATEFD $ "711|712") ) 
		Aeval(aPd,{ |X| nIr -= If ( X[1]==aCodFol[107,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. ((!lMultv .and. cSemana == "01") .or. x[7] == "G") ,X[5],0) })
		If lMP1171
            Aeval(aPd,{ |X| nIRComp -= If ( X[1]==aCodFol[107,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. ((!lMultv .and. cSemana == "01") .or. x[7] == "G") ,X[5],0) })
		    Aeval(aPd,{ |X| nIrSimp -= If ( X[1]==aCodFol[107,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. ((!lMultv .and. cSemana == "01") .or. x[7] == "G") ,X[5],0) })
        EndIf
	ElseIf cSemana > "01" .and. SRA->RA_CATFUNC $ "A*P*H" .and. SRA->RA_CATEG <> "15" //Subtrai IR pago no período anterior com a mesma data de competencia do pagamento atual
		Aeval(aPd,{ |X| nIr -= If ( X[1]==aCodFol[107,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. x[3] == "01" ,X[5],0) })
		If lMP1171
            Aeval(aPd,{ |X| nIRComp -= If ( X[1]==aCodFol[107,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. x[3] == "01" ,X[5],0) })
		    Aeval(aPd,{ |X| nIrSimp -= If ( X[1]==aCodFol[107,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. x[3] == "01" ,X[5],0) })
        EndIf
	EndIf
	
	//-- Variavel usada na Rescisao (cTipo)
	//-- Abate I.R. Mes Anterior
	If cTipo == "R" .And. ( lValidaAdi .Or. ((RetValSRV(aCodFol[006,1],cFilialCor,"RV_IR") == "N") .And. (RetValSRV(aCodFol[007,1],cFilialCor,"RV_IR") == "N")) ) //Ajusta o abatimento do IR no mês anterior em regime competência
		Aeval(aPd,{ |X| nIr -= If ( X[1]==aCodFol[107,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]),X[5],0) })
		If lMP1171
            Aeval(aPd,{ |X| nIRComp -= If ( X[1]==aCodFol[107,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]),X[5],0) })
		    Aeval(aPd,{ |X| nIrSimp -= If ( X[1]==aCodFol[107,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]),X[5],0) })
        EndIf
		//-- Abate I.R. do Adiantamento
		Aeval(aPd,{ |X| nIr -= If ( X[1]==aCodFol[012,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]) ,X[5] ,0)})
		If lMP1171
            Aeval(aPd,{ |X| nIRComp -= If ( X[1]==aCodFol[012,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]) ,X[5] ,0)})
		    Aeval(aPd,{ |X| nIrSimp -= If ( X[1]==aCodFol[012,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]) ,X[5] ,0)})
        EndIf
	EndIf
	
	//-- Abate I.R. na Rescisao complementar
	If cTipo == "R" .And. !Empty( aPdResVals )
		Aeval( aPdResVals, { |X| nIr -=   If ( X[1]==aCodFol[066,1] .And. MesAno(dDataHom) = MesAno(x[10]) ,X[5] ,0)})
		If lMP1171
            Aeval( aPdResVals, { |X| nIRComp -=   If ( X[1]==aCodFol[066,1] .And. MesAno(dDataHom) = MesAno(x[10]) ,X[5] ,0)})
		    Aeval( aPdResVals, { |X| nIrSimp -=   If ( X[1]==aCodFol[066,1] .And. MesAno(dDataHom) = MesAno(x[10]) ,X[5] ,0)})
        EndIf
		Aeval( aPdResVals, { |X| nIr_b -= If ( X[1]==aCodFol[015,1] .And. MesAno(dDataHom) = MesAno(x[10]), X[5], 0)})
		If lMP1171
            Aeval( aPdResVals, { |X| nIR_BComp -= If ( X[1]==aCodFol[015,1] .And. MesAno(dDataHom) = MesAno(x[10]), X[5], 0)})
		    Aeval( aPdResVals, { |X| nIR_BSimp -= If ( X[1]==aCodFol[015,1] .And. MesAno(dDataHom) = MesAno(x[10]), X[5], 0)})
        EndIf
	EndIf

	If nIr > 0 .And. cTipo == "R" .and. cCompl == "S" .and. lProxMes
		//Subtrai o valor de IR descontado na rescisão original se esta teve o pagamento no mesmo Ano/Mes da complementar atual
		Aeval(aPdResc,{ |X| nIr -= If ( X[1]==aCodFol[066,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(x[10]) .And. MesAno(x[18]) == MesAno(dDataDem) ,X[5] ,0)})
		If lMP1171
            Aeval(aPdResc,{ |X| nIRComp -= If ( X[1]==aCodFol[066,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(x[10]) .And. MesAno(x[18]) == MesAno(dDataDem) ,X[5] ,0)})
		    Aeval(aPdResc,{ |X| nIrSimp -= If ( X[1]==aCodFol[066,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(x[10]) .And. MesAno(x[18]) == MesAno(dDataDem) ,X[5] ,0)})
        EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Zera o Valor da Aliquota se Ir <= 0 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nIr <= 0
		nAliq := 0
	EndIf
	
	//Subtrai a base de ir mês anterior de outros vínculos quando utiliza MULTV
	nIr_B -= nIr_bMUltV 
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ A Bs.IR Autonomo Carret. ja foi gerada, porem o vlr devera ser somente o da   ³
	//³ semana calculada sem os vlrs das semanas  anteriores                          ³	
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SRA->RA_CATFUNC == "A" .And. AnoMes(dDataHom) >= "200304" .And. (SRA->RA_CATEG $ '15|16|18' .Or. SRA->RA_CATEFD $ "711|712|734") .And. cTipoPgto == "S"
		If nIr_B > 0
			FMatriz( aCodfol[15,1], nIr_B, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, .T., Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cTribuIR )
		Else 	
			Aeval( aPD,{ |X| If(X[1] == aCodFol[15,1] .And. X[3] == cSemana .And. ( MesAno(dDataHom) == MesAno(X[10]) .Or. Empty(X[10])) .And. X[9] # "D",X[9]:="D","")} )
		EndIf
	Else 	
		If nIr_B > 0
			//Se for fretista altera a base de IR gravada anteriormente
			If SRA->RA_CATFUNC == "A" .And. AnoMes(dDataHom) >= "200304" .And. (SRA->RA_CATEG $ '15|16|18' .Or. SRA->RA_CATEFD $ "711|712|734")  .and. ( nPos := Ascan(aPd,{ |X| X[1] = aCodfol[15,1] .And. X[3] = cSemana .And. X[9] # "D"}) ) > 0
				aPd[nPos,5] := nIr_B
				If Len(aPd[nPos]) >= 28
					aPd[nPos,28] := cTribuIR
				EndIf
			Else
				FMatriz(aCodfol[15,1], nIr_B, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cTribuIR)
			EndIf
		Else
			If lIrNeg
				FMatriz(aCodfol[1726,1],nIr_B * -1)
			EndiF
		EndIf
	EndIf

	//Tratamento para autonomo carreteiro
	If SRA->RA_CATFUNC == "A" .And. MesAno(dDataHom) >= '200304' .And. (SRA->RA_CATEG $ '15|16' .Or. SRA->RA_CATEFD $ "711|712|734" ) .And. Len(aCodFol) >= 1563 .And. !Empty(aCodFol[1563,1])
		fGerAutCar()
	EndIf

	If (!lResExt) .Or. (lResExt .And. lIrResExt)
		If !( SRA->RA_CATFUNC == "A" .And. !Empty(SRA->RA_SINDICA) .And. SubStr( fCodCBO( SRA->RA_FILIAL, SRA->RA_CODFUNC ), 1, 4 ) == "3422" )
		    FMatriz( aCodfol[66,1], nIr, nAliq, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cTribuIR )
			If __lMemCalc			
				fAddMemLog("Valor do desconto do IR: R$ " + AllTrim(Transform( nIr, "@E 999,999,999,999.99" )), 1, 2)					
			EndIf
		EndIf
        If lMP1171 .And. !lCalcPensao
            FMatriz( aCodfol[1913, 1], Iif( cTribuIR == "1", nIR_BSimp, nIR_BComp ), Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif( cTribuIR == "1", "2", "1" ) )
            FMatriz( aCodfol[1914, 1], Iif( cTribuIR == "1" .and. nIR_BSimp > 0, nIRSimp, nIRComp ), Iif( cTribuIR == "1", nAliqSimp, nAliqComp ), Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif( cTribuIR == "1", "2", "1" ) )
			
			// Gerar verba de dedução IR apenas se gerou valor em alguma modalidade de calculo
			nVal := 0
			Aeval( aPD, { |X| nVal += If( (X[1]==aCodFol[15,1] .Or. X[1]==aCodfol[1913,1]) .And. Iif(cTipoPgto == "S", X[3] == cSemana, .T.) .And. X[9] # "D", X[5], 0)})
			If nVal > 0 
				FMatriz( aCodfol[1921, 1], aTabIr[7, 1] )
			EndIf
        EndIf
	Endif
	//-- TIRA SEMPRE O FLAG DO CODIGO DE DEDUCAO DE DEPENDENTES
	//-- PARA MUDA-LO PARA "D" DELETADO
	nPos := Ascan ( aPD , { |X| X[1] == aCodFol[59,1] } )
	If nPos > 0 .And. nVal_DedDep > 0
		aPD[nPos,9] := "D"
	EndIf
	nPos := Ascan(aPd, {|X| X[1]==aCodFol[106,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10])})
	//-- Nao gera a deducao de dependentes se for rescisao no mes seguinte e tiver utilizado a verba de base
	//-- de ir do mes anterior para compor a base de calculo de ir de rescisao.
	//-- Neste caso, devera utilizar o dependente para o abatimento porem nao deve gravar a verba para nao causar
	//-- duplicidade de deducao de dependentes na DIRF
	If !(cTipo = "R" .And. lRescMSeg .And. nPos > 0) .And. (nIr_B > 0)
		FMatriz(aCodfol[59,1],nVal_DedDep,val(cNumDepIr))
		If lTemRU6 .AND. cTipoRot $ "1/9/4" .AND. nVal_DedDep > 0 .AND. !lDissidio
			fGrvDepIr(val(cNumDepIr), nVal_DedDep, If(cTipoRot $ "1/9", "1", "4"), cTribuIR, If( cTipoRot == "4", GetMemVar("RG_DATAHOM"), NIL))
		Endif	
	EndIf
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCIrFer  ³ Autor ³ Equipe RH             ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Ir  Funcionario Ferias                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCIrFer(aCodfol)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aCodFol    = Array com Identificadores de Calculo Folha    ´±±
±±³          ³ aTabIr     = Array com a Tabela de IR                      ´±±
±±³          ³ lCond      = .T.ou.f.Verificar ou Nao Incidencia das Verbas´±±
±±³          ³ dDataPg    = Data Para verificar mes/ano de calculo        ´±±
±±³          ³ lRecalculo = .T.ou.F. Se recalcula ou nao o IR Ferias      ´±±
±±³          ³ cTipo      = "F"=Ferias                                    ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCIrfer(aCodfol, aTabir, lCond, Ddatapg, lRecalculo, cTipo, lCalcUmT)

Local aAreaSRH	 := SRH->( GetArea() )
Local aCodBenef  := {}
Local cTribuIR   := "1"
Local cVerbDed   := ""
Local cMdTribAnt := ""
Local cSeq		 := ""
Local dBkpPgto	 := cToD("//")
Local nAliq 	 := 0
Local nAliqComp  := 0
Local nAliqSimp  := 0
Local nBOut		 := 0
Local nDeduPrev  := 0
Local nDeduSimp  := 0
Local nInssOut   := 0
Local nIR_BComp  := 0
Local nIR_BSimp  := 0
Local nIrf_Ant	 := 0.00	
Local nIRComp    := 0
Local nIRSimp    := 0
Local nPos3		 := 0      
Local nPosAux	 := 0     
Local NVL0079	 := 0 //Uso GFP
Local lCalcPensao:= IsInCallStack("fCalcPensao")
Local lId1449	 := (Len(aCodFol) >= 1449)
Local lMP1171    := .F.
Local lMp927     := .T.
Local lTribComp  := .F.
Local nDed_MV    := 0
Local nPosIrAnt  := 0
Local nPosBIrAnt := 0
Local nPosIrO    := 0
Local nVlIrO     := 0
Local cTipoIr    := ""
Local nPosIrF    := 0

lAutMEI		:= If( Type("lAutMEI") 	 == "U"	, .F., lAutMEI)
lIrResExt	:= If( Type("lIrResExt") == "U"	, .T., lIrResExt)

DEFAULT lVerMultv   := If ( Type("P_MULTV") == "U",.F.,P_MULTV)
DEFAULT lCalcUmT	:= .F.
DEFAULT lTemRU6 	:= AliasInDic("RU6")
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

//Para MEI ou res. exterior com RGE_DESCIR=="2" nao ira calcular o IR
If lAutMEI .or. !lIrResExt
	Return
Endif

nPosIrF := Ascan(Apd, {|x| x[1]==aCodFol[67,1]})

If nPosIrF > 0
	cTipoIr := Apd[nPosIrf,28]
Endif

lMP1171   := ( cPaisLoc == "BRA" .And. Len(aTabIr) >= 7 .And. aTabIr[7, 4] == "S" .And. !lResExt )

//Indica se deve calcular RRA na rescisao
lRescRRA := If(Type("lRescRRA") == "U",.F.,lRescRRA)

lRecalculo 	:= If(lRecalculo= Nil,.F.,lRecalculo)
dDatapg 	:= If (dDatapg  = Nil, dDataAte , dDatapg) //dDataAte = Ultimo dia do periodo
cTipo       := If (cTipo    = Nil," ", cTipo)
nVal_Peal 	:= 0.00
nBaseRed 	:= 0.00
nIrBant 	:= 0.00
nIRf_B 		:= 0.00
nIrF_Out	:= 0.00
nBiF_Out    := 0.00

If !lCalcUmT
	If lRescRRA
		//Calcula apenas se nao tiver calculado IR normal, pois IR de ferias eh calculado junto quando existe RRA
		If ( nPos := aScan(aPD,{ |X| X[1] == aCodFol[015,1] .And. X[9] # "D" }) ) > 0
			Return Nil
		EndIf
	EndIf

	//Verifico se n?o houve cálculo de férias por motivo da MP927, nestes casos a base e o IR já foram calculados e pagos no mes de inicio das ferias
	If lCalcFol .or. cTipoRot == "1"
		dbSelectArea ("SRH")
		dbSetOrder(1)
		dbSeek(SRA->RA_FILIAL+SRA->RA_MAT)
		While !Eof() .And. SRH->RH_FILIAL+SRH->RH_MAT == SRA->RA_FILIAL+SRA->RA_MAT
			If SRH->(RH_DTRECIB > RH_DATAINI) .And. (AnoMes(SRH->RH_DTRECIB) == cPeriodo)
				lMp927 := .F.
			Endif
			dbSkip()
		EndDo
	EndIf
EndIf

If lMp927
	If __lMemCalc 
		fAddMemLog("Verbas com incidência para IR: ",1,2)
	EndIf
    // Soma Incidencia para Base de Ir Ferias
    If lCond # Nil .And. lCond 
        Aeval( aPd ,{ |X| SomaInc(X,5,@nIRf_B,11,"S",12,"N",Month(dDataPg), ,aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.) })
    Else
        Aeval( aPd ,{ |X| SomaInc(X,5,@nIRf_B, , , , , , ,aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.)})
    EndIf
	If SRA->RA_TPCONTR == "3" .and. cTipoRot == "1" //Se contrato intermitente, busca verbas das outras convocações
		Aeval( aPdConvoc ,{ |X| SomaInc(X,5,@nIRf_B,11,"S",12,"N",Month(dDataPg), ,aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.) })
	EndIf
Endif
//GFP - cálculo de férias de estatutário , quando parâmetro S_SUMFERAB == "S", deve descontar o valor do 1/3 de abono somado ao 1/3 de férias.
If CTIPOROT == "L" .AND. SRA->RA_REGIME == "2" .AND. P_SUMFERAB == "S" .AND. !(RetValSRV(ACODFOL[0079,1], SRA->RA_FILIAL, "RV_INSSFER") == '1')
	//DESCONTA VALOR DO 1/3 DE ABONO QUE FOI SOMADO À VERBA DE 1/3 DE FERIAS.
	AEVAL(APD, { | X | IIF( X[1] == ACODFOL[0079,1] .AND. X[3] == CNUMPAG .AND. X[9] == "D" .AND. !(X[7] == "S"), NVL0079 += X[5], )} )
	nIRf_B -= NVL0079
EndIf

//--Soma Base de Ir das Ferias no movimento
If SRA->RA_TPCONTR <> "3"
	Aeval(aPd,{ |X| nIrBAnt += If ( X[1]==aCodFol[16,1] .And. X[9] # "D" .and.  Month(X[10]) = Month(dDatapg) ,X[5] ,0)})
Else
	If cSemana > "01"
		Aeval(aPd,{ |X| nIrBAnt += If ( X[1]==aCodFol[16,1] .And. X[3] < cSemana .And. X[9] # "D" .and. Month(X[10]) = Month(dDatapg) ,X[5] ,0)})
	Else
		Aeval(aPd,{ |X| nIrBAnt += If ( X[1]==aCodFol[16,1] .And. X[9] # "D" .and. Month(X[10]) = Month(dDatapg) ,X[5] ,0)})
	EndIf
	Aeval(aPdConvoc,{ |X| nIrBAnt += If ( X[1]==aCodFol[16,1] .And. X[9] # "D" .and.  Month(X[10]) = Month(dDatapg) ,X[5] ,0)})
EndIf

//-- Evita a soma de base de IRRF Ferias
If cTipoRot == "1" .And. RetValSrv(aCodFol[168,1], SRA->RA_FILIAL,"RV_IR") == "S" .and. ( aScan(aPd, {|x| x[1] == aCodFol[16,1] .and. Month(X[10]) = Month(dDatapg) .and. x[28] == "2"}) ) > 0
	Aeval(aPd,{ |X| nIrBAnt -= If ( X[1]==aCodFol[397,1] .And. X[9] # "D" .And. Month(X[10]) = Month(dDatapg) ,X[5] ,0)})
EndIf

If cTipo = "F" .or. (cTipoRot == "4" .and. lVerMultv)//Quando for calculo de Ferias ou rescisão de múltiplos vinculos
	// Busca Base Ir Ferias Outros Periodos
	nBOut := 0.00
	If ( nPos := aScan(aPd,{ |X| X[1] == aCodFol[236,1] .And. X[9] # "D" }) ) > 0
        nBOut += aPd[nPos,5]
		lTribComp := If(Len(aPd[nPos]) >= 28, aPd[nPos,28] == "1", .T.)
	EndIf
	If nBOut > 0.00
		If __lMemCalc 
			fAddMemLog("Base do IR outros períodos: R$ " + AllTrim(Transform( nBOut, "@E 999,999,999,999.99" )),1,2)		
		EndIf
		If lMP1171 .And. !lTribComp
			aEval( aPd, { |X| If ( x[1] $ aCodFol[1951,1] .And. x[3] == cSemana .And. X[9] != "D" .And. (x[11] == "9" .Or. x[7] == "I"), nDed_MV += x[5], Nil ) } )
            aEval( aPd, { |x| nInssOut += Iif( x[1] == aCodFol[397, 1] .And. x[9] != "D", x[5], 0 ) } ) 
            If nDed_MV == 0
                nBOut -= nInssOut
            EndIf
		EndIf
		If __lMemCalc 
			fAddMemLog("Desconto INSS IR outros períodos: R$ " + AllTrim(Transform( nInssOut, "@E 999,999,999,999.99" )),1,2)
		EndIf
		nBiF_Out := nBOut
		nIrf_b   += ( nBOut - nDed_MV )
	EndIf
EndIf

// Soma Ir Ferias Outros Periodos
Aeval(aPd,{ |X| nIrF_Out += If ( X[1]==aCodFol[237,1] .And. X[9] # "D" ,X[5] ,0)})
If nIrF_Out > 0 .And. __lMemCalc 
	fAddMemLog("Valor do desconto de IR outros períodos: R$ " + AllTrim(Transform( nIrF_Out, "@E 999,999,999,999.99" )),1,2)
EndIf

// Soma o Valor de Base da Pensao, informado pelo usu rio
If aCodfol[171,1] # "   "
	Aeval(aPd,{ |X| nVAL_PEAL += If ( X[1]==aCodFol[171,1] .And. X[9] # "D" ,X[5] ,0)})
EndIf

//-- Procura Cod. Base Deducao Previdencia Privada Ferias
If aCodfol[216,1] # "   " .And. RetValSrv(aCodFol[216,1],SRA->RA_FILIAL,"RV_IR") == "S"
	Aeval(aPd,{ |X| nDeduPrev += If ( X[1]==aCodFol[216,1] .And. X[9] # "D" ,X[5] ,0)})
    nIrf_b -= nDeduPrev
EndIf

If lMP1171
    fBusCadBenef( @aCodBenef, "FER" )
    fVerPDDed( @cVerbDed, "FER", aCodBenef )

    // Soma Incidencia para Base de Ir Ferias
    If lCond # Nil .And. lCond 
        Aeval( aPd ,{ |X| Iif( x[1] $ cVerbDed, SomaInc(X,5,@nDeduSimp,11,"S",12,"N",Month(dDataPg), ,aCodFol), Nil ) })
    Else
        Aeval( aPd ,{ |x| Iif( x[1] $ cVerbDed, SomaInc(X,5,@nDeduSimp, , , , , , ,aCodFol), Nil ) } )
    EndIf
	If SRA->RA_TPCONTR == "3" .and. cTipoRot == "1" //Se contrato intermitente, busca verbas das outras convocações
        Aeval( aPdConvoc ,{ |X| Iif( x[1] $ cVerbDed, SomaInc(X,5,@nDeduSimp,11,"S",12,"N",Month(dDataPg), ,aCodFol), Nil ) })
	EndIf

	If nDed_MV == 0
	    nDeduSimp -= nInssOut
    EndIf
	nDeduSimp *= (-1)
EndIf

//-- Funcao p/ Calcular I.R Ferias
nIrf 		:= 0.00
nIrf_Ant	:= 0.00

nVal_DedDep := Val(SRA->RA_DEPIR)
If (Ascan(aPd,{ |X| X[1] == aCodfol[67,1] .And. X[3] == cSemana .And. X[9] # "D"}) == 0 .Or. cTipoRot == "1" .Or. (cTipoRot == "4" .And. !IsInCallStack("fCalcPensao")) .Or. lCalcUmT) .And. nIrf_b > 0.00
	If __lMemCalc			
		fAddMemLog("Modelo completo:", 1, 2)					
	EndIf
	CALC_IR(nIrf_B,nVal_Peal,@nIrf,@nBaseRed,@nVAL_DEDDEP,,aTabIr,,@nAliq)
    If lMP1171
        nIR_BComp := nIrf_B
        nIR_BSimp := nIrf_B
        If aCodFol[216, 1] $ cVerbDed
            nIR_BSimp += nDeduPrev
        EndIf
        nIR_BSimp += nDeduSimp + nDed_MV

		//Se existe pagamento em outro período
		If nBiF_Out > 0
			If ( nPosIrAnt := aScan( aPd, { |x| x[1] == aCodFol[237, 1] .And. x[9] != "D" } ) ) > 0
				cMdTribAnt := Iif( Empty( aPd[nPosIrAnt, 28] ), "1", aPd[nPosIrAnt, 28] )
			ElseIf ( nPosBIrAnt := aScan( aPd, { |x| x[1] == aCodFol[236, 1] .And. x[9] != "D" } ) ) > 0
				cMdTribAnt := Iif( cPeriodo == "202305" .And. Empty( aPd[nPosBIrAnt, 28] ), "1", Iif( Empty( aPd[nPosBIrAnt, 28] ), "2", aPd[nPosBIrAnt, 28] ) )
			EndIf
		EndIf

		//Se já houve tributação completa no mês, não precisa recalcular simplificado
		If nBiF_Out == 0 .or. cMdTribAnt <> "1"
			If __lMemCalc			
				fAddMemLog("Modelo simplificado:", 1, 2)					
			EndIf
			CALC_IR(nIR_BSimp, 0, @nIrSimp, 0, 0, Nil, aTabIr, Nil, @nAliqSimp, lMP1171)
			If nIrSimp < nIrf .Or. (nIR_BSimp - aTabIr[7, 1] < nIrf_B - nVal_DedDep )
				cTribuIR    := "2"
				nAliqComp   := nAliq
				nIRComp     := nIrf
				nAliq       := nAliqSimp
				nIrf        := nIrSimp
				nIrf_B      := nIR_BSimp
			EndIf
		EndIf
    EndIf

	If cTipo = "F"  .or. (cTipoRot == "4" .and. lVerMultv)// Quando For Ferias ou rescisão de múltiplo vínculo
		//Abater Base e Ir Outros Periodos apos Calculo
	    nIrf_B -= nBiF_Out
	    nIrf   -= nIrF_Out
        If lMP1171
            If nDed_MV == 0 .And. cTribuIR == "1"
                nBiF_Out += nInssOut
            EndIf
            Iif( cTribuIR == "1", nIR_BSimp -= nBiF_Out, nIR_BComp -= nBiF_Out )
            Iif( cTribuIR == "1", nIrSimp -= nIrF_Out, nIRComp -= nIrF_Out )
        EndIf
    EndIf

	nPos  := Ascan(aPd,{ |X| X[1] = aCodfol[67,1] .And. X[9] # "D"})
	nPos1 := Ascan(aPd,{ |X| X[1] = aCodfol[16,1] .And. X[9] # "D"})
	nPos2 := Ascan(aPd,{ |X| X[1] = aCodfol[164,1] .And. X[9] # "D"})//Ferias pagas mes anterior 
	If lId1449
		nPos3 := Ascan(aPd,{ |X| X[1] = aCodfol[1449,1] .And. X[9] # "D"})//Abonos pagos mes anterior 
	EndIf
	
	If (nPos == 0 .and. nPos1 == 0 .and. nPos2 == 0 .and. nPos3 == 0) .OR. lRecalculo .Or. ( SRA->RA_TPCONTR == "3" .And. cSemana > "01") 
		If SRA->RA_TPCONTR == "3" .And. cSemana > "01"
			Aeval(aPd,{ |X| nIrf_Ant += If ( X[1]==aCodFol[67,1] .And. X[9] # "D" .And. X[3] < cSemana .and.  Month(X[10]) = Month(dDatapg) ,X[5] ,0)})	
			nIrf_B -= nIrBAnt
			nIrf -= nIrf_Ant
            If lMP1171
                Iif( cTribuIR == "1", nIR_BSimp -= nIrBAnt, nIR_BComp -= nIrBAnt )
                Iif( cTribuIR == "1", nIrSimp -= nIrf_Ant, nIRComp -= nIrf_Ant )
            EndIf
		EndIf
		FMatriz(Acodfol[67,1], nIrf, nAliq, Nil, Nil, Nil, Nil, Nil, Nil, Iif(lCalcUmT, dDatapg, Nil), lRecalculo, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cTribuIR )
		If __lMemCalc 
			fAddMemLog("Valor do desconto do IR: R$ " + AllTrim(Transform( nIrf, "@E 999,999,999,999.99" )),1,2)
		EndIf
		If lMP1171 .And. !lCalcPensao
            FMatriz( aCodfol[1915, 1], Iif( cTribuIR == "1", nIR_BSimp, nIR_BComp ), Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif( cTribuIR == "1", "2", "1" ) )
            FMatriz( aCodfol[1916, 1], Iif( cTribuIR == "1", nIRSimp, nIRComp ), Iif( cTribuIR == "1", nAliqSimp, nAliqComp ), Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif( cTribuIR == "1", "2", "1" ) )
            FMatriz( aCodfol[1922, 1], aTabIr[7, 1] )
        EndIf
		FMatriz(Acodfol[16,1], nIrf_B, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif(lCalcUmT, dDatapg, Nil), lRecalculo, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cTribuIR )
		FMatriz(aCodfol[60,1], nVal_DedDep, Val(SRA->RA_DEPIR), Nil, Nil, Nil, Nil, Nil, Nil, Iif(lCalcUmT, dDatapg, Nil), lRecalculo)
		If lTemRU6 .AND. cTipoRot $ "3/4" .AND. nVal_DedDep > 0 .AND. !lDissidio
			fGrvDepIr(Val(SRA->RA_DEPIR), nVal_DedDep, "3", cTribuIR, If( cTipoRot == "3", M->RH_DTRECIB, GetMemVar("RG_DATAHOM")))
		EndIf
	Else
		
		Aeval(aPd,{ |X| nIrf_Ant += If ( X[1]==aCodFol[67,1] .And. X[9] # "D" .And.  Month(X[10]) = Month(dDatapg) ,X[5] ,0)})	
		If __lMemCalc 
			fAddMemLog("Valor do desconto do IR: R$ " + AllTrim(Transform( nIrf, "@E 999,999,999,999.99" )),1,2)
		EndIf
		//-- Quando houver Diferenca e for no mesmo mes das Ferias
		If ( nPos  > 0 .and. aPd[nPos,10]  # Nil  ) .Or. ;
		   ( nPos1 > 0 .and. aPd[nPos1,10] # Nil  )

		   	nPosIrO := Ascan(Apd,{|x| x[1]==aCodFol[1916,1]})

			If nPosIrO > 0
				Aeval(aPd,{ |X| nVlIrO += If ( X[1]==aCodFol[1916,1] .And. X[9] # "D" .and.  X[7] == "K" ,X[5] ,0)})	
			Endif

			If nPos > 0
				nIrf   -= nIrf_Ant
                If lMP1171
                    Iif( cTribuIR == "1", nIrSimp -=  Iif(cTipoIr == "1" .And. nVlIrO > 0 , nVlIrO ,nIrf_Ant), nIRComp -= nIrf_Ant )
                EndIf
		    EndIf
			nIrf_b -= nIrBant
            If lMP1171 .and. nIrf_b > 0
                Iif( cTribuIR == "1", nIR_BSimp -= Iif(cTipoIr == "1", nIrBant + nDeduSimp ,nIrBant), nIR_BComp -= nIrBant )
                cSeq := "0"
				aEval(aPd, {|x| If(x[1] == aCodFol[1915,1] .and. x[9] <> "D", cSeq := Soma1(cSeq), Nil)})
				cSeq := If(cSeq == "0", " ", cSeq)
                FMatriz( aCodfol[1915, 1], Iif( cTribuIR == "1", nIR_BSimp, nIR_BComp ), Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cSeq, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif( cTribuIR == "1", "2", "1" ) )
                FMatriz( aCodfol[1916, 1], Iif( cTribuIR == "1", nIRSimp, nIRComp ), Iif( cTribuIR == "1", nAliqSimp, nAliqComp ), Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cSeq, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif( cTribuIR == "1", "2", "1" ) )
				If Ascan(aPd,{ |X| X[1] == aCodFol[1922,1] .And. X[9] # "D" .And. X[7] == "K"}) == 0 // Validação para evitar duplicidade da verba 1922
                	FMatriz( aCodfol[1922, 1], aTabIr[7, 1] )
				Endif
            EndIf
		EndIf
		If nIrf >= 0
			FMatriz(Acodfol[101,1], nIrf, nAliq, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cTribuIR)//-- Cod Dif. I.Renda  Ferias
			nPos  := Ascan(aPd,{|X| X[1] = aCodfol[67,1] .And. X[9] # "D"})
			If nPos > 0 .And. aPd[nPos,7] <> "K" .and. nIrf_Ant == 0 .And. nIrBant == 0// se tem IR de Férias e IR anterior então não houve IR nas férias e não deve gerar novamente
				aPd[nPos, 9] := "D"
			Endif
		Else
			FMatriz(Acodfol[659,1],nIrf*(-1),nAliq)			//-- Cod Compensacao de IR
		EndIf
		If cInssFM == "N" .And. nPos1 > 0 .And. nIrf_B < 0
			aPd[nPos1, 9] := "D"
			FMatriz(Acodfol[16,1], nIrf_b + nIrBant)
		EndIf
		FMatriz(Acodfol[100,1],nIrf_B, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cTribuIR )//-- Cod Dif. Base I.R Ferias 
		If nIrf > 0.00
			FMatriz(aCodfol[61,1],nVal_DedDep)
		EndIf
	EndIf
EndIf

If cPaisLoc == "BRA" .And. SRA->RA_TPCONTR != "3" .And. cTipoRot == "1" .And. SubStr(cPeriodo, 5, 2) == "12" .And. SubStr(cPeriodo, 1, 4) $ "2020/2021" .And. AnoMes(dDatapg) > cPeriodo .And. (!Empty(P_ADIPINI) .Or. !Empty(P_DINIADI))
	If ( nPosAux := Ascan(aPd, { |X| AnoMes(x[10]) == "202012" .And. RetValSRV(x[1], SRA->RA_FILIAL, "RV_IR") == "S" .And. X[9] # "D"}) ) > 0
		dBkpPgto := aPd[nPosAux, 10]
		If Ascan(aPd,{ |X| X[1] == aCodfol[67,1] .And. X[3] == cSemana .And. X[9] # "D"}) == 0 .And. ( nPosAux := Ascan(aPd, { |X| x[1] == aCodFol[168, 1] .And. X[7] == "C" .And. X[9] # "D"}) ) > 0
			aPd[nPosAux, 10] := dBkpPgto
		EndIf
		fCIrfer(aCodFol, aTabIr, .T., dBkpPgto, Nil, Nil, .T.)
	EndIf
EndIf

RestArea( aAreaSRH )

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCIr13o  ³ Autor ³ Equipe RH             ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Ir  Funcionario 13o.                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCIr13o(aCodfol)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³1 aCodFol    - Array com os Id. de Calculo                  ³±±
±±³          ³2 aTabIR     - Array com os Valores da Tabela de IRRF       ³±±
±±³          ³3 lRecalculo - Logico para Regravacao do Valor em aPD       ³±±
±±³          ³4 lCond      - Logico para SomaInc                          ³±±
±±³          ³5 nIr13P     - Valor do Ir ja Descontado para Abatimento    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCIr13o(aCodfol, aTabir, lRecalculo, lCond, nIr13P, lSimp, nBaseTot)

Local aCodBenef := {}
Local aTabIrRRA	:= {}
Local cMTribAnt := ""
Local cMTribBIR := ""
Local cMTribDIR := ""
Local cTribuIR  := "1"
Local cVerbDed  := ""
Local dDtResAux := CtoD("")
Local lCalcPens := IsInCallStack("fCalcPensao")
Local lComp13   := IsInCallStack("FCOMPL13")
Local lMP1171   := .F.
Local lRescComp := cTipoRot == "4" .And. cCompl == "S" .And. Len(aPdResc) > 0
Local lDedSimp  := .F.
Local lTribComp := .F.
Local nX		:= 0
Local nAliq		:= 0
Local nAliqComp := 0
Local nAliqSimp := 0
Local nDedPerAnt:= 0
Local nDeduPrev := 0
Local nDeduSimp := 0
Local nIR_BComp := 0
Local nIR_BSimp := 0
Local nIRComp   := 0 
Local nIRSimp   := 0
Local nMeses   	:= 0
Local nBsIR13Res:= 0
Local nIR13Res	:= 0
Local nBs13Ant  := 0
Local nIr13Ant  := 0
Local nBaseOut  := 0
Local nIrOut	:= 0
Local nPos 		:= 0
Local nDed_MV   := 0

DEFAULT lSimp   	:= .F.
DEFAULT lTemRU6 	:= AliasInDic("RU6")
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo
DEFAULT nBaseTot    := 0

lCond		:= If( lCond		= NIL, .T.  , lCond      ) // Se deseja Condicao na Somainc
lRecalculo	:= If( lRecalculo	= NIL, .F.  , lRecalculo ) // Se deseja Regravar a Verba em aPD
nIr13P		:= If( nIr13P		= NIL, 0.00 , nIr13P	 ) // Para deduzir do IR calculado

lAutMEI	    := If( Type("lAutMEI") 		== "U"	, .F., lAutMEI)

lMP1171     := ( cPaisLoc == "BRA" .And. Len(aTabIr) >= 7 .And. aTabIr[7, 4] == "S" .And. !lResExt )

//Se cálculo da 2º parcela e funcionário foi reintegrado no ano, deve subtrair o IR 13º pago na rescisão do total apurado
If cTipoRot == "6" .and. !Empty(SRA->RA_FECREI) .and. nIr13Reint > 0
	nIr13P += nIr13Reint
EndIf

//Para MEI nao ira calcular o IR
If lAutMEI
	Return
Endif

//Indica se deve calcular RRA na rescisao
lRescRRA := If(Type("lRescRRA") == "U",.F.,lRescRRA)

nIR13_B 	:= 0.00
nVal_Peal	:= 0.00
nbaseRed 	:= 0.00

If lMP1171
    fBusCadBenef( @aCodBenef, "132" )
    fVerPDDed( @cVerbDed, "132", aCodBenef )
EndIf

//Tratamento para obter o valor de rescisoes anteriores que devem ser 
//consideradas para o calculo do IR do 13o. independente da database
If lRescComp
	For nX := 1 To Len(aPdResc)
		//--Somente considera as verbas que nao estao excluidas
		//--Se for RRA deverá somar apenas as verbas pagas no ano
		If aPdResc[nX,9] <> "D" .and. (!lRescRRA .or. (Year(aPdResc[nX,18]) == Year(M->RG_DTGERAR)))
			//--Obtem o valor e a base do IR 13o. da última rescisão antes do mês atual
			If aPdResc[nX,1] == Acodfol[027,1] .and. AnoMes(aPdResc[nX,18]) <> AnoMes(M->RG_DTGERAR) .and. aPdResc[nX,18] > dDtResAux
				dDtResAux  := aPdResc[nX,18]
				nBsIR13Res := aPdResc[nX,5]
                cMTribBIR  := aPdResc[nX, 28]
			EndIf
			If aPdResc[nX,1] == Acodfol[071,1] .and. AnoMes(aPdResc[nX,18]) <> AnoMes(M->RG_DTGERAR)
				nIR13Res   += aPdResc[nX,5]
                cMTribDIR  := aPdResc[nX, 28]
			EndIf
            If lMP1171 .And. aPdResc[nX,1] $ cVerbDed .And. AnoMes( aPdResc[nX, 18] ) != AnoMes( M->RG_DTGERAR )
                nDedPerAnt += aPdResc[nX, 5]
            EndIf
		EndIf
	Next nX
    If lMP1171
        cMTribAnt := Iif( !Empty(cMTribDIR), cMTribDIR, Iif( !Empty(cMTribBIR), cMTribBIR, "1" ) )
    EndIf
Endif

If Ascan(aPd,{ |X| X[1] = aCodfol[71,1] .And. X[9] # "D"})  = 0  .OR. lRecalculo
	
	//-- Soma Base de Ir 13o. 
	Aeval(aPd,{ |X| nIr13_B += If ( X[1]==aCodFol[027,1] .And. X[3] == cSemana .And. X[9] # "D" ,X[5] ,0)})
	
	lDedSimp := nIr13_B == 0 //Se a base já estava informada, não deve somar INSS para base simplificada
	
	If nIr13_B = 0.00 .OR. lRecalculo
		If __lMemCalc 
			fAddMemLog("Verbas com incidência para IR: ",1,2)
		EndIf

		If nBaseTot == 0
			//-- Soma Incidencia para Base de Ir 13o.
			Aeval( aPd ,{ |X| SomaInc(X,5,@nIR13_B,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T. ) })
			If SRA->RA_TPCONTR == "3"
				If cSemana > "01"
					Aeval( aPd ,{ |X| nBs13Ant += If(X[1] == aCodFol[27,1] .And. X[3] < cSemana .And. X[9] # "D" .And. Month(X[10]) = Month(dData_Pgto), X[5], 0) } )
					Aeval( aPd ,{ |X| nIr13Ant += If(X[1] == aCodFol[71,1] .And. X[3] < cSemana .And. X[9] # "D" .And. Month(X[10]) = Month(dData_Pgto), X[5], 0) } )
				EndIf
				Aeval( aPdConvoc ,{ |X| SomaInc(X,5,@nIR13_B,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol) })
			EndIf
		Else 
			nIR13_B := nBaseTot
		EndIf
	EndIf

	nIr13 := 0.00
	nVal_DedDep := VAL(SRA->RA_DEPIR)
	// Buscar os codigos de Pensao Alimenticia
	If aCodfol[173,1] # "   " // Base Pensao Alimentica 13§ 1¦ Parcela Ded IR
		Aeval(aPd,{ |X| nVAL_PEAL += If ( X[1]==aCodFol[173,1] .And. X[9] # "D" ,X[5] ,0)})
	EndIf
	If aCodfol[129,1] # "   " // Base Pensao Alimenticia 13§ 2¦ Parcela
		Aeval(aPd,{ |X| nVAL_PEAL += If ( X[1]==aCodFol[129,1] .And. X[9] # "D" ,X[5] ,0)})
	EndIf

	//-- Procura Cod. Base Deducao Previdencia Privada
	If aCodfol[302,1] # "   " .And.  RetValSRV(aCodFol[302,1],SRA->RA_FILIAL,"RV_IR") == "S"
		Aeval(aPd,{ |X| nDeduPrev += If ( X[1]==aCodFol[302,1] .And. X[9] # "D" ,X[5] ,0)})
        nIr13_B -= nDeduPrev
	EndIf

	//Deduz INSS descontado na 2a. Parcela
	If !(cTipoRot == "4" .And. cCompl == "S" .And. lProxMes)
		nIr13_B -= nInssP
	EndIf

	//Soma na base do IR o valor de rescisoes anteriores
	If nIr13_B <= 0
		nBsIR13Res	:= 0
		nIR13Res	:= 0
	ElseIf nBsIR13Res > 0
		nIr13_B += nBsIR13Res
	EndIf
	
	If nIr13_b > 0.00

        If lMP1171 .and. lDedSimp
            Aeval( aPd ,{ |X| Iif( x[1] $ cVerbDed, SomaInc(X,5,@nDeduSimp,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol), Nil ) })
            If SRA->RA_TPCONTR == "3"
                Aeval( aPdConvoc ,{ |X| Iif( x[1] $ cVerbDed, SomaInc(X,5,@nDeduSimp,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol), Nil ) })
            EndIf

            nDeduSimp *= (-1)
        EndIf

		If !Empty(aCodfol[994,1]) // Base IR 13º outras empresas
			If ( nPos := aScan(aPd,{ |X| X[1] == aCodFol[994,1] .And. X[9] # "D" .and. x[11] == "9"}) ) > 0
				nBaseOut += aPd[nPos,5]
				lTribComp := If(Len(aPd[nPos]) >= 28, aPd[nPos,28] == "1", .T.)
			EndIf
			If nBaseOut > 0 .and. !lTribComp
				aEval( aPd, { |X| If ( x[1] $ aCodFol[1951,1] .And. x[3] == cSemana .And. X[9] != "D" .And. (x[11] == "9" .Or. x[7] == "I"), nDed_MV += x[5], Nil ) } )
			EndIf
		EndIf
		If !Empty(aCodfol[995,1]) // IR 13º outras empresas
			Aeval(aPd,{ |X| nIrOut += If ( X[1] == aCodFol[995,1] .And. X[9] # "D" .and. x[11] == "9",X[5] ,0)})
		EndIf

		nIr13_b += ( nBaseOut - nDed_MV )

		If !lRescRRA
            If lMP1171
                nIR_BComp := nIr13_B
                nIR_BSimp := nIr13_B
                If lRescComp
                    If cMTribAnt == "1"
                        nIR_BSimp += nDedPerAnt
                    Else
                        nIR_BComp -= nDedPerAnt
                        nIr13_B   := nIR_BComp
                    EndIf
                EndIf
            EndIf
			If __lMemCalc			
				fAddMemLog("Modelo completo:", 1, 2)					
			EndIf
			CALC_IR(nIr13_B,nVal_Peal,@nIr13,@nBaseRed,@nVAL_DEDDEP,,aTabIr,.F.,@nAliq)
            
			If lMP1171
				If !(cTipoRot == "4" .And. cCompl == "S" .And. lProxMes)
                	nIR_BSimp += nInssP
				EndIf
                If aCodFol[302, 1] $ cVerbDed
                    nIR_BSimp += nDeduPrev
                EndIf
                nIR_BSimp += ( nDeduSimp + nDed_MV )
				If __lMemCalc			
					fAddMemLog("Modelo simplificado:", 1, 2)					
				EndIf
                CALC_IR(nIR_BSimp, 0, @nIrSimp, 0, 0, Nil, aTabIr, .F., @nAliqSimp, lMP1171)

                If ( nIrSimp < nIr13 .Or. (nIR_BSimp - aTabIr[7, 1] < nIr13_B - nVal_DedDep ) ) .and. ( nBaseOut == 0 .or. !lTribComp ) //Se houve tributação completa no vínculo anterior, não deve mais usar tributação simplificada
                    cTribuIR    := "2"
                    nAliqComp   := nAliq
                    nIRComp     := nIr13
                    nAliq       := nAliqSimp
                    nIr13       := nIrSimp
                    nIr13_B     := nIR_BSimp
                EndIf
            EndIf
		Else
			If !Gpm40LoadRRA(@nIr13_B,@nVal_Peal,@aTabIrRRA,@nMeses,If(cTipoRot == "4", M->RG_DATAHOM, dDataAte),aCodFol[979,1],aCodFol[980,1])
				Return
			EndIf
			CALC_IRRRA(nIr13_B,nVal_Peal,@nIr13,@nBaseRed,@nVal_DedDep,,aTabIrRRA,.F.,@nAliq,1)
			nPos := Ascan(aPD,{ |X| X[1] == aCodFol[982,1] .And. X[9] # "D" })
			If nPos > 0
				aPd[nPos,5] := nBaseRed
			EndIf
		EndIf

		nIr13_b -= nBaseOut
		nIr13   -= nIrOut
        If lMP1171
            Iif( cTribuIR == "1", nIR_BSimp -= nBaseOut, nIR_BComp -= nBaseOut )
            Iif( cTribuIR == "1", nIrOut -= nIrOut, nIRComp -= nIrOut )
        EndIf

		If SRA->RA_TPCONTR == "3" .And. cSemana > "01"
			nIr13_B -= nBs13Ant
			nIr13_B -= nIr13Ant 
            If lMP1171
                Iif( cTribuIR == "1", nIR_BSimp -= nBs13Ant, nIR_BComp -= nBs13Ant )
                Iif( cTribuIR == "1", nIrOut -= nIr13Ant, nIRComp -= nIr13Ant )
            EndIf
		EndIf

		FMatriz( Acodfol[071,1] , NoRound( Max( nIr13 - nIr13P - nIR13Res , 0 ) , 2 ),nAliq, , , , , , , ,lRecalculo, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cTribuIR )
		If __lMemCalc			
			fAddMemLog("Valor do desconto do IR: R$ " + AllTrim(Transform( NoRound( Max( nIr13 - nIr13P - nIR13Res , 0 ) , 2 ), "@E 999,999,999,999.99" )), 1, 2)					
		EndIf
		If lMP1171 .And. (!lCalcPens .Or. lSimp) .And. ( lDedSimp .Or. Ascan(aPD,{ |X| X[1] == aCodFol[1917,1] .And. X[9] # "D" }) == 0)
            FMatriz( aCodfol[1917, 1], Iif( cTribuIR == "1", nIR_BSimp, nIR_BComp ), Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif( cTribuIR == "1", "2", "1" ) )
            FMatriz( aCodfol[1918, 1], Iif( cTribuIR == "1", nIRSimp -  nIr13P - nIR13Res , nIRComp - nIr13P - nIR13Res ), Iif( cTribuIR == "1", nAliqSimp, nAliqComp ), Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif( cTribuIR == "1", "2", "1" ) )
            FMatriz( aCodfol[1923, 1], aTabIr[7, 1] )
        EndIf
		FMatriz( Acodfol[027,1], nIr13_B, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, lRecalculo, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cTribuIR )

		FMatriz( aCodfol[062,1] , nVal_DedDep, If(VAL(SRA->RA_DEPIR) > aTabIr[5,2],aTabIr[5,2],VAL(SRA->RA_DEPIR)), , , , , , , ,lRecalculo)
		
		//Se for rescisão verifica se já ocorreu lançamento na RU6 de 13º, para não duplicar no eSocial na folha anual do 13º
		If lTemRU6 .AND. nVal_DedDep > 0 .AND. !lDissidio .AND. !lComp13 .AND. If( cTipoRot == "4" .AND. !lRecRes .AND. cCompl == "N", !f132RU6(), .T.) 
			fGrvDepIr(Val(SRA->RA_DEPIR), nVal_DedDep, "2", cTribuIR, If( cTipoRot == "4", GetMemVar("RG_DATAHOM"), NIL))		
		EndIf
	EndIf
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCFgts   ³ Autor ³ Mauro                 ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do FGTS  Funcionario                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCFgts(aCodfol)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCfgts(aCodfol,nFgts_b,cGrava,nAfasFgts,cTipo,lTrunca)

Local aAreaRCM      := {}
Local aAreaSR8      := {}
Local aAdicFGTS  	:= {}

Local lSemana	 	:= If( cSemana # Space( 2 ), .T., .F.)
Local lIdFuncPub	:= Len(aCodFol) >= 1955 .And. !Empty(aCodFol[1955, 1])
Local lIncoNFGTS 	:= .T.
Local lTemVbFGTS	:= .F.
Local cCodVerba  	:= ""
Local cPDAciTrab  	:= ""
Local cPdSup        := ""
Local cSeq			:= ""
Local cCodAdinInc	:= ""
Local nDiasAcTrab 	:= 0 
Local nX         	:= 0
Local nPos			:= 0
Local nBaseTot 	 	:= 0
Local nCont  	    := 0
Local nDAdm			:= 0
Local nDiasAux		:= 0
Local nFgtsTot 	 	:= 0
Local nPerFgts	 	:= 0
Local nNumFer		:= 0
Local nSalAux		:= 0
Local nPos1432		:= 0
Local nPosAdic		:= 0
Local nPosPeri		:= 0
Local nPosInsal		:= 0
Local nValAux       := 0
Local nPericAux		:= 0
Local nInsalubAux	:= 0
Local nHrsAfas		:= 0
Local nHrsAux 		:= 0
Local nVAuxFGTSDia  := 0
Local nVFGTSAnt     := 0
Local nAtuFgsAdic	:= 0

Private lZerBase	:= GetMvRH("MV_ZERBASE",,.F.)                         

Static lTCpoFgts

DEFAULT cTipo 		:= " "
DEFAULT lTrunca 	:= .T. 
DEFAULT lTCpoFgts  	:= ( Type("SRA->RA_PERFGTS") # "U" )
DEFAULT lTemPdSup	:= RCM->( ColumnPos("RCM_PDSUP") ) > 0
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() //Memória de Cálculo

//--Situacao do Funcionario na data de referencia
cSitFolh			:= If( Type("cSitFolh")   == "U",SRA->RA_SITFOLH,cSitFolh)
cTipoRot			:= If( Type("cTipoRot")   == "U","",cTipoRot)
lResExt				:= If( Type("lResExt") 	  == "U", .F., lResExt)
cEncResExt			:= If( Type("cEncResExt") == "U" .Or. Empty(cEncResExt), "1234", cEncResExt)

If nAfasFgts = Nil
	nAfasFgts := 0
EndIf

If cSitFolh == "D"  .And. cTipo # 'R'
	Return
EndIf

If SRA->RA_CATFUNC = "P" .And. (!lTCpoFgts .Or. SRA->RA_PERFGTS == 0.00)
	Return
EndIf

//--Somar Fgts Semanas Anteriores
If cSemana # Space( 2 )
	Aeval( aPd,{ |X| nBaseTot += If( X[1]=aCodFol[17,1] .And. x[3] < cSemana,x[5],0 ) } )
	Aeval( aPd,{ |X| nFgtsTot += If( X[1]=aCodFol[18,1] .And. x[3] < cSemana,x[5],0 ) } )
EndIf


//--Verifica Qual Percentual de FGTS deve Aplicar 
If lTCpoFgts .And. SRA->RA_PERFGTS > 0.00
	nPerFgts := SRA->RA_PERFGTS / 100
Else
	nPerFgts := If (SRA->RA_TPCONTR$ " *1*3",nFgtsCt1,nFgtsCt2)
EndIf

If lResExt .And. ! ("3" $ cEncResExt)
	nPerFgts := 0
EndIf

//Verifica se insalubridade e periculosidade devem ser somados no FGTS integralmente ou apenas o que foi pago
If P_ADCFGTS > 0
	nPericAux	:= nPeric
	nInsalubAux	:= nInsalub
	If P_ADCFGTS == 1 .or. P_ADCFGTS == 3 //Proporcionaliza periculosidade ou ambos
		nPosPeri		:= Ascan(aPd,{ |X| X[1] == cCodPer .And. X[9] # "D" .And. X[3] = cSemana })
		If nPosPeri > 0
			nPeric := aPd[nPosPeri,5]
		EndIf
	EndIf
	If P_ADCFGTS == 2 .or. P_ADCFGTS == 3 //Proporcionaliza insalubridade ou ambos
		nPosInsal		:= Ascan(aPd,{ |X| X[1] == cCodIns .And. X[9] # "D" .And. X[3] = cSemana })
		If nPosInsal > 0
			nInsalub := aPd[nPosInsal,5]
		EndIf
	EndIf
EndIf

nFgts_b := 0
nFgts_bAV	:= 0
If lDissidio
	aEval( aPd, { |x| If( ( ( x[1] == aCodFol[17,1] .and. x[7] <> "I" ) .or. x[1] == aCodfol[18,1] ), x[9] := "D", Nil ) }  )	
EndIf
If Ascan(aPd,{ |X| X[1] = aCodfol[18,1] .And. X[9] # "D" .And. X[3] = cSemana }) = 0
	// Soma Base do fgts                                                           
	Aeval(aPd,{ |X| nFgts_B += If ( X[1]==aCodFol[017,1] .And. X[9] # "D" .And. X[3]=cSemana,X[5] ,0)})
	
	If nFgts_B = 0.00 
		If __lMemCalc			
			fAddMemLog("Verbas com incidência para FGTS:", 1, 2)					
		EndIf
		// Soma Incidencia para Base de Fgts
		cPdSup := fVldPdSup(nDiasFgts,lTemPdSup,aDetAfas) 
		Aeval( aPd ,{ |X| If( X[1] <> aCodFol[042,1] .And. !(X[1] $ cPdSup), SomaInc(X,6,@nFgts_b,12,"N", , , ,lSemana,aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.),) })
		If SRA->RA_TPCONTR == "3"
			Aeval( aPdConvoc ,{ |X| If( X[1] <> aCodFol[042,1],SomaInc(X,6,@nFgts_b,12,"N", , , ,lSemana,aCodFol),) })
		EndIf
		If lDissidio .And. cTipoRot == "1"
			aEval( aPd, { |X| If ( x[1] $ aCodFol[72,1] .And. x[3] == cSemana .And. X[9] != "D", nNumFer++, Nil ) } )
			aEval( aPd, { |X| If ( x[1] $ (aCodFol[72,1]+"*"+aCodFol[77,1]+'*'+aCodFol[88,1]+'*'+aCodFol[90,1]+'*'+aCodFol[92,1]+'*'+aCodFol[96,1]+'*'+aCodFol[98,1]+'*'+aCodFol[161,1]+'*'+aCodFol[94,1]+'*'+aCodFol[95,1]) .And. x[3] == cSemana .And. X[9] != "D" .And. x[11] > Str(nNumFer, 1), nFgts_b -= x[19], Nil ) } )			
		EndIf
		
		lTemVbFGTS := ( nFgts_B > 0 )

		If nDiasFgts > 0
			nValAux 	:= nFgts_B
			cCodAdinInc := ""
			cPDAciTrab  := "" //Lista das verbas de acidente de trabalho sem incidência
			nDiasAcTrab := 0  //Dias de acidente de trabalho pagos na verba sem incidência
			nAtuFgsAdic := 0
			//Se existir a verba de acidente de trabalho sem incidências, e a verba de adicionais sem incidência estiver com RV_FGTS == "S"
			//Subtrai os valores da base pois já serão calculados integralmente a partir deste ponto
			If Ascan(aPd,{ |x| x[1] $ aCodfol[1873,1] + "/" + aCodFol[1874,1] + "/" + aCodFol[1875,1] + "/" + aCodFol[1876,1] + "/" + aCodFol[1877,1] .And. X[9] # "D" .And. X[3] == cSemana .And. RetValSRV( x[1], SRA->RA_FILIAL, "RV_FGTS" ) == "S"}) > 0
				aEval(aDetAfas, {|x| If(x[7] == "O1" .and. x[12] == x[1], cPDAciTrab += x[1] + "/", Nil)})
				If !Empty(cPDAciTrab)
					aEval(aPd, {|x| If( x[1] $ cPDAciTrab .And. X[9] # "D" .And. X[3] == cSemana, nDiasAcTrab += x[4], Nil )})
				EndIf
			EndIf

			If nDiasAcTrab > 0
				If P_ADCFGTS == 1 .or. P_ADCFGTS == 3 //Proporciona periculosidade
					If RetValSRV(aCodFol[1873,1],SRA->RA_FILIAL,"RV_FGTS") == "S" //Se é para proporcionaizar a periculosidade e a verba de periculosidade sem incidências já possui incidencia para FGTS, não precisa recacular periculosidade
						nAtuFgsAdic := 1
					EndIf
				EndIf
				If P_ADCFGTS == 2 .or. P_ADCFGTS == 3 //Proporciona insalubridade
					If RetValSRV(aCodFol[1874,1],SRA->RA_FILIAL,"RV_FGTS") == "S" //Se é para proporcionaizar a periculosidade e a verba de periculosidade sem incidências já possui incidencia para FGTS, não precisa recacular periculosidade
						nAtuFgsAdic += 2
					EndIf
				EndIf
				cCodAdinInc := If(nAtuFgsAdic <> 1 .and. nAtuFgsAdic <> 3, aCodfol[1873,1],"") + "/" + If(nAtuFgsAdic <= 1, aCodfol[1874,1],"") + "/" + aCodFol[1875,1] + "/" + aCodFol[1876,1] + "/" + aCodFol[1877,1]
				aEval(aPd, {|x| If( x[1] $ cCodAdinInc .And. x[9] # "D" .And. x[3] == cSemana .And. RetValSRV( x[1], SRA->RA_FILIAL, "RV_FGTS" ) == "S", nFgts_B -= Round(((x[5] / x[4]) * nDiasAcTrab),2),Nil)})
			EndIf
			
			If nDiasFgts + DiasTrab > nDiasC
				nDiasFgts += 30 - (nDiasFgts + DiasTrab)
			Else
				nDiasFgts	:= Min(nDiasC, nDiasFgts)
			EndIf

			If DiasTrab <> 0
				If SRA->RA_CATFUNC == "C" //Se for comissionado e não possui salário, soma a verba de auxilio doença que foi ignorada no somainc anterior
					Aeval( aPd ,{ |X| If( X[1] == aCodFol[042,1] .And. X[9] != "D" ,nFGTS_B += x[5],) })
					If SRA->RA_TPCONTR == "3"
						Aeval( aPdConvoc ,{ |X| If( X[1] == aCodFol[042,1] .And. X[9] != "D" ,nFGTS_B += x[5],) })
					EndIf
				EndIf
			EndIf
			lIncoNFGTS := .T.

			nFGTS_B += fBsFgtsAdic(@aAdicFGTS,@lIncoNFGTS,,nAtuFgsAdic)

			If aScan( aAdicFGTS, { |x| x[2] > 0 } ) == 0
				nSalAux := Salario
				For nX := 1 to Len(aPd)
					If aPd[nx][7] == "I" .And. aPd[nx][5] > 0 // Verba Informada e com Valor
						cCodVerba	:= aPd[nX][1]
						If RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_INCORP" ) == "S" .And. RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_FGTS" ) == "N" 
							nSalAux += aPd[nx][5]
						EndIf
					EndIf
				Next nX
	
				If cPaisLoc ==  "BRA" .and. SRA->RA_CATFUNC == "H" .and. P_HRSPONFO
					nHrsAfas:= 0
					nHrsAux := 0
					
					For nCont := 1 to Len(aDetAfas)
						If aDetAfas[nCont,7] == "O1"
							fHrsPon(aDetAfas[nCont,7],@nHrsAfas, ,aDetAfas[nCont,8],aDetAfas[nCont,10],aDetAfas[nCont,2] )
						EndIf
					Next nCont

					nHrsAux:= fConvHr(nHrsAfas,"D")

					nFGTS_B += If(!Empty(nHrsAux), Round(nHrsAux * SRA->RA_SALARIO,2), (nSalAux / nDiasC) * nDiasFgts)
				Else 
					nFGTS_B += (nSalAux / nDiasC) * nDiasFgts
				EndIf
				
			Else
				If lIncoNFGTS
					nFGTS_B += SalDor * nDiasFgts 
				Else
					nFGTS_B += SalDia * nDiasFgts
					If P_ADCFGTS > 0
						If !(cBCalPer $ "2*6*7*8") .And. nPericAux <> nPeric
							nFGTS_B -= ( nPericAux - nPeric )
						EndIf
						If !(cBCalIns $ "3*4*7*8") .And. nInsalubAux <> nInsalub
							nFGTS_B -= ( nInsalubAux - nInsalub )
						EndIf
					EndIf
				EndIf
			EndIf
			If nFGTS_B > nValAux //Guarda o valor diário do FGTS sobre acidente de trabalho para usar na geração da verba de acidente de trabalho meses anteriores, quando necessário
				nVAuxFGTSDia := ( nFGTS_B - nValAux ) / nDiasFgts
			EndIf
			If __lMemCalc .And. nFGTS_B > nValAux
        		fAddMemLog("Valor referente a afastamento: " +AllTrim(Transform( nFGTS_B - nValAux, "@E 999,999,999,999.99" )), 1, 2)
			EndIf
		EndIf

		// Soma na base de FGTS o valor da media de comissao
		If fVarRot("nMedComiss") > 0 //SRA->RA_CATFUNC == "C" 
			nFgts_b += fVarRot("nMedComiss")
		EndIf
		If nMed407 > 0 .And. RetValSRV( aCodFol[407, 1], SRA->RA_FILIAL, "RV_FGTS" ) == "S" .And. aScan( aPd, { |x| x[1] == aCodFol[238, 1] .And. x[9] != "D" .And. x[7] != "I" } ) > 0
			nFgts_b += nMed407
			nFGTS_B := Round(nFGTS_B,2)
		Endif
		// Zera a base negativa sem abater as faltas no aviso prévio 
		If lZerBase .and. cTipo == "R"
			Aeval( aPd ,{ |X| SomaInc(X,6,@nFgts_bAV,12,"N", 1,aCodFol[111,1], ,lSemana,aCodFol) }) 

			If nfgts_b - nfgts_bAV < 0 
				nfgts_b := nfgts_bAV
			EndIf
		EndIf			

		If nfgts_b == 0.00 .And. cSemana # Space(2)
			//--Soma Base fgts Semanas Anteriores
			nFgts_b += nBaseTot
		EndIf	
		
		If __lMemCalc .And. nFGTS_B > 0 .And. cTipoRot <> "4"
			fAddMemLog("Base FGTS: R$ " + AllTrim(Transform( nFgts_b, "@E 999,999,999,999.99" )), 1, 2)					
		EndIf

	EndIf
	
    If lAdmissao
       nDAdm := nDiasP - Day( Iif(Empty(SRA->RA_FECREI), SRA->RA_ADMISSA, SRA->RA_FECREI) ) + 1
    EndIf

	//Se houve mudança de afastamento d edoença para acidente de trabalho no mês, gera base referente aos meses anteriores
	If Len(aAfaAcid) > 0
		nVAuxFGTSDia := If(nVAuxFGTSDia > 0, nVAuxFGTSDia, nFGTS_B / nDiasC)
		cSeq         := "1"
		For nX := 1 to Len(aAfaAcid)
			fMatriz(aCodfol[1966,1],Round(aAfaAcid[nX,2] * nVAuxFGTSDia, 2),aAfaAcid[nX,2], , , , , , , , ,cSeq , , , , , , , aAfaAcid[nX,1])
			cSeq := Soma1(cSeq)
		Next nX 
	EndIf

	If cGrava # Nil .And. cGrava == "S"
		If !Empty(aCodFol[1966,1])
			aEval(aPd, {|x| If(x[1] == aCodFol[1966,1] .and. x[9] <> "D", nVFGTSAnt += x[5], Nil)})
		EndIf
		
		nFGTS_B := (nFgts_B/If(SRA->RA_TIPOPGT=="S" .and. !(cTipoRot $ "3*4"),P_NTOTDIAS,If(lAdmissao,ndadm,nDiasC))) * If(SRA->RA_TIPOPGT=="S" .and. !(cTipoRot $ "3*4"),P_NTOTDIAS,If(lAdmissao,ndadm,nDiasC))
 		If Round(nFGTS_B,1) > nFGTS_B .And. Round(nFGTS_B,1) - nFGTS_B < 0.01
		 	nFGTS_B := Round(nFGTS_B,1)
		EndIf
		 
		nVfgts := If(lTrunca, NoRound( ( nFGTS_B + nVFGTSAnt ) * nPerFgts ,2), Round( ( nFGTS_B + nVFGTSAnt )  * nPerFgts,2) )

		If nVfgts > 0 .And. __lMemCalc .And. cTipoRot <> "4"
			fAddMemLog("Cálculo do FGTS: R$ " + AllTrim(Transform( nFGTS_B, "@E 999,999,999,999.99" )) + " * " +cValToChar(nPerFgts), 1, 2)
			fAddMemLog("FGTS do mês: R$ " + AllTrim(Transform( nVfgts, "@E 999,999,999,999.99" )), 1, 2)						
		EndIf

		FMatriz(aCodfol[18,1],nVfgts-nFgtsTot)
		FMatriz(aCodfol[17,1],nFGTS_B-nBaseTot)

		//ID gerado para o eSocial, S-1202 - Remuneração de servidor vinculado a RPPS
		If lIdFuncPub .And. SRA->RA_TPPREVI == "2" .And. !SRA->RA_VIEMRAI $ "30*31*35"
			FMatriz(aCodfol[1955,1],nFGTS_B-nBaseTot)
		EndIf
	EndIf
EndIf    


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Quando for calculo de dissidio, e no movimento do mes nao existir ³
//³a verba de fgts do mes (id 018), porem existir a verba de base (id³
//³017, fazer o calculo do fgts baseado na verba de base e grava-la  ³
//³no ApdOld (array salvo com vlrs antes do reajuste)  	             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If lDissidio .and. Ascan(aPdOld, { |X| X[1] == aCodfol[18,1] .And. X[3] == cSemana } ) == 0 .and. !Empty(SRA->RA_DEMISSA)

	nPos := Ascan(aPdOld, { |X| X[1] == aCodfol[17,1] .And. X[3] == cSemana } )

	If nPos > 0

		Aadd(aPdOld,{aCodfol[18,1],;
				  aPdOld[nPos,2],;
				  aPdOld[nPos,3],;
				  aPdOld[nPos,4],;
				  Round((aPdOld[nPos,5])*nPerFgts,2),;
				  aPdOld[nPos,6],;
				  aPdOld[nPos,7],;
				  aPdOld[nPos,8],;
				  aPdOld[nPos,9],;
				  aPdOld[nPos,10],;
				  aPdOld[nPos,11],;
				  aPdOld[nPos,12],;
				  aPdOld[nPos,13],;
				  aPdOld[nPos,14]})          
				  
	EndIf
EndIf

If P_ADCFGTS > 0
	nPeric 	 := nPericAux
	nInsalub := nInsalubAux
EndIf

If nDiasFGTS > 0 .And. DiasTrab < nDiasC
    If lTemPdSup .And. !Empty( aDetAfas )
        aAreaRCM := RCM->( GetArea() )
        aAreaSR8 := SR8->( GetArea() )
        RCM->( dbSetOrder( RetOrder( "RCM", "RCM_FILIAL+RCM_TIPO" ) ) )
        SR8->( dbSetOrder( RetOrder( "SR8", "R8_FILIAL+R8_NUMID" ) ) )

        For nCont := 1 To Len(aDetAfas)
            If RetValSrv(aDetAfas[nCont, 1], SRA->RA_FILIAL,"RV_INSS") != "S" .And. RCM->( DbSeek(xFilial("RCM",SRA->RA_FILIAL) + aDetAfas[nCont,18] ) .And. RCM->RCM_PDSUP == aDetAfas[nCont,1]) .And. SR8->( DbSeek(SRA->RA_FILIAL + aDetAfas[nCont,3]) ) .And. SR8->R8_PROADIC != '1'
                nDiasAux += aDetAfas[nCont, 2]
            EndIf
        Next nCont

        RestArea(aAreaRCM)
        RestArea(aAreaSR8)
    EndIf  
    
    For nCont := 1 To Len(aAdicFGTS)
        If aAdicFGTS[nCont, 2] > 0 .And. RetValSRV( aAdicFGTS[nCont, 1], SRA->RA_FILIAL, "RV_INCORP" ) == "S" .And. RetValSRV( aAdicFGTS[nCont, 1], SRA->RA_FILIAL, "RV_FGTS" ) == "S"
            If ( nPosAdic := aScan( aPd, { |x| x[1] == aAdicFGTS[nCont, 1] .And. x[9] != "D" .And. X[3] == cSemana } ) ) > 0 .And. Round( aPd[nPosAdic, 19], 2 ) - aPd[nPosAdic, 5] > 0
                IncorpSal( ( Round( aPd[nPosAdic, 19], 2 ) / nDiasC * ( nDiasC - (nDiasAux + DiasTrab) ) ), 0, .T.)
            EndIf
        EndIf
    Next nCont

    If aScan( aAdicFGTS, { |x| x[2] > 0 } ) > 0 .And. ( nPos1432 := aScan( aPd, { |x| x[1] == aCodfol[1432, 1] .And. x[9] != "D" } ) ) > 0 .And. aPd[nPos1432, 4] == nDiasFgts .And. nDiasFgts == nDiasC .And. !lTemVbFGTS
        aPd[nPos1432, 5] := (nFGTS_B - nBaseTot)
    EndIf
EndIf

Return

/*/{Protheus.doc} fCfgtsRtf
Função que apura o FGTS da retificação
@author Allyson Mesashi
@since 08/04/2021
@version P12.1.27
/*/
Function fCfgtsRtf(aCodfol, nFgts_b, cGrava, nAfasFgts, cTipo, lTrunca)

Local cPdAvi        := ""
Local nBaseAnt		:= 0
Local nCont			:= 0
Local nFgtsAnt		:= 0
Local nPerFgts	 	:= 0
Local lSemana	 	:= If( cSemana # Space( 2 ), .T., .F.)
Local lIdFuncPub	:= Len(aCodFol) >= 1955 .And. !Empty(aCodFol[1955, 1])
 
DEFAULT cTipo 		:= " "
DEFAULT lTrunca 	:= .T. 
DEFAULT lTCpoFgts  	:= ( Type("SRA->RA_PERFGTS") # "U" )
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() //Memória de Cálculo

//--Situacao do Funcionario na data de referencia
cSitFolh			:= If( Type("cSitFolh") == "U", SRA->RA_SITFOLH, cSitFolh)
cTipoRot			:= If( Type("cTipoRot") == "U", "", cTipoRot)
lResExt				:= If( Type("lResExt") == "U", .F., lResExt)
cEncResExt			:= If( Type("cEncResExt") == "U" .Or. Empty(cEncResExt), "1234", cEncResExt)

If nAfasFgts == Nil
	nAfasFgts := 0
EndIf

If SRA->RA_CATFUNC == "P" .And. (!lTCpoFgts .Or. SRA->RA_PERFGTS == 0.00)
	Return
EndIf

//--Verifica Qual Percentual de FGTS deve Aplicar 
If lTCpoFgts .And. SRA->RA_PERFGTS > 0.00
	nPerFgts := SRA->RA_PERFGTS / 100
Else
	nPerFgts := If(SRA->RA_TPCONTR $ " *1*3", nFgtsCt1, nFgtsCt2)
EndIf

If lResExt .And. !("3" $ cEncResExt)
	nPerFgts := 0
EndIf

nFgts_b := 0

If Ascan(aPd,{ |X| X[1] == aCodfol[18,1] .And. X[9] # "D" .And. X[3] == cSemana }) == 0
	If aScan(aPd, {|Z| Z[1]==aCodFol[1887,1]}) > 0 //Obtem a base de FGTS sobre aviso prévio se existir o id 1887 no APD
		cPdAvi 	:= "/"+aCodFol[0111,1]+"/"+aCodFol[0250,1]+"/"+aCodFol[1683,1]+"/"+aCodFol[1689,1]+"/"+aCodFol[1695,1]+"/"+aCodFol[1701,1]+"/"+aCodFol[1707,1]+"/"+aCodFol[1713,1]+"/"+aCodFol[1719,1]
	EndIf
	For nCont := 1 To Len(aPd)
		If aPd[nCont, 1] $ (aCodFol[17,1]+"/"+aCodFol[293,1]+cPdAvi) .and. aPd[nCont, 9] # "D"//Base FGTS
			nBaseAnt += aPd[nCont, 5]
		EndIf
		If aPd[nCont, 1] $ (aCodFol[18,1]+"/"+aCodFol[119,1]) .and. aPd[nCont, 9] # "D"//Codigo FGTS Deposito
			nFgtsAnt += aPd[nCont, 5]
		EndIf
	Next nCont	

	If __lMemCalc			
		fAddMemLog("Verbas com incidência para FGTS:", 1, 2)					
	EndIf
	// Soma Base do fgts                                                           
	Aeval(aPd,{ |X| nFgts_B += If( X[1] == aCodFol[017,1] .And. X[9] # "D" .And. X[3] == cSemana, X[5], 0)})
	
	If nFgts_B = 0.00 
		// Soma Incidencia para Base de Fgts
		Aeval( aPd, { |X| If( X[1] <> aCodFol[042,1], SomaInc(X, 6, @nFgts_b, 12, "N", , , , lSemana, aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.),) } )
	EndIf

	If __lMemCalc .And. nFgts_B > 0
		fAddMemLog("Base FGTS: R$ " + AllTrim(Transform( nFgts_b, "@E 999,999,999,999.99" )), 1, 2)	
	EndIf

	If cGrava # Nil .And. cGrava == "S"	 
		If lTrunca
			nVfgts := NoRound( nFGTS_B * nPerFgts ,2)
		Else
			nVfgts := Round( nFGTS_B * nPerFgts,2)
		EndIf

		nFGTS_B := Max(nFGTS_B - nBaseAnt, 0)
		nVfgts 	:= Max(nVfgts - nFGTSAnt, 0)
		
		If __lMemCalc .And. nFgts_B > 0	 
			fAddMemLog("Base FGTS menos a base anterior: R$ " + AllTrim(Transform( nFGTS_B, "@E 999,999,999,999.99" )), 1, 2)		
			fAddMemLog("Cálculo do FGTS: R$ " + AllTrim(Transform( nFGTS_B, "@E 999,999,999,999.99" )) + " * " +cValToChar(nPerFgts), 1, 2)
			fAddMemLog("FGTS do mês: R$ " + AllTrim(Transform( nVfgts, "@E 999,999,999,999.99" )), 1, 2)						
		EndIf

		FMatriz(aCodfol[18,1], nVfgts)
		FMatriz(aCodfol[17,1], nFGTS_B)

		//ID gerado para o eSocial, S-1202 - Remuneração de servidor vinculado a RPPS
		If lIdFuncPub .And. SRA->RA_TPPREVI == "2" .And. !SRA->RA_VIEMRAI $ "30*31*35"
			FMatriz(aCodfol[1955,1],nFGTS_B)
		EndIf
	EndIf
EndIf    

Return

/*/{Protheus.doc} fBsFgtsAdic
	Adicionais na base fgts
	@since 26/03/2020
/*/
Function fBsFgtsAdic(aAdic, lInco, nDiasInss, nAtuFgsAdic)
Local lBaseINSS 	:= .F.
Local lIncoNFGTS 	:= .T.
Local aAdicFGTS  	:= {}
Local cCodVerba  	:= ""
Local nValVerba  	:= 0
Local nX         	:= 0
Local nPosPd		:= 0
Local cTipoPd 	 	:= ""
Local nDiasAdc	 	:= 0
Local nHrsTot		:= 0
Local nBsAdic		:= 0
Local nTemInc       := 0

DEFAULT aAdic		:= {}
DEFAULT lInco		:= .T. 
DEFAULT nDiasInss	:= 0
DEFAULT nAtuFgsAdic := 0

cTipoRot 	:= If( Type("cTipoRot")   == "U","",cTipoRot)
lBaseINSS 	:= (nDiasInss > 0)

aAdicFGTS  	:= { {cCodConf,nAdcConf,aCodFol[1877,1]} , {cCodTrf,nAdcTrf,,aCodFol[1876,1]} }

If nAtuFgsAdic == 0 .or. nAtuFgsAdic == 2
	aAdd(aAdicFGTS, {cCodPer,Iif(nPeric > 0, nPeric, nIntPercul),aCodFol[1873,1]})
EndIf 
If nAtuFgsAdic <= 1
 	aAdd(aAdicFGTS, {cCodIns,nInsalub,aCodFol[1874,1]}) 
EndIf

If !Empty(cTipoRot) .And. Len( aAdtServ ) > 0
	 For nx := 1 to Len(aAdtServ)
	 	aAdd(aAdicFGTS, { aAdtServ[nX][1], aAdtServ[nX][3], aCodFol[1875,1]})
	 Next nX 
EndIf

aAdic := aClone(aAdicFGTS)

If aScan( aAdicFGTS, { |x| x[2] > 0 } ) > 0 .And. (DiasTrab+nDaPaPg == nDiasC .Or. cTipoRot="4") .And. RetValSRV(aCodFol[42,1], SRA->RA_FILIAL, "RV_BASCAL") != "2"
	nValAux := 0
	For nX := 1 to Len(aAdicFGTS)
		If aAdicFGTS[nX,2] > 0 .and. aScan(aPd, {|x| x[1] == aAdicFGTS[nX,3]}) > 0 .and. RetValSRV(aAdicFGTS[nX,3], SRA->RA_FILIAL, "RV_FGTS") == "S"
			nValAux += aAdicFGTS[nX,2]	
		EndIf
	Next nX
	//Se não houver verbas de adicionais sem incidências no aPd, sai da função
	If nValAux == 0
		Return 0
	EndIf
EndIf

For nX := 1 To Len(aAdicFGTS)
	cCodVerba := aAdicFGTS[nX,1]
	nValVerba := aAdicFGTS[nX,2]
	If !Empty(cCodVerba)
		cTipoPd := RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_TIPO" )
	EndIf

	If nValVerba > 0
		lIncoNFGTS := lIncoNFGTS .And.;
		( ( RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_INCORP" ) == "S" .And. RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_FGTS" ) == "N" ) .Or.;
		( RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_INCORP" ) == "S" .And. RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_FGTS" ) == "S" .And. DiasTrab > 0 ) )
		If lBaseINSS .And. RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_INCORP" ) == "S"
			Loop
		EndIf
		If !lBaseINSS .and. lIncoNFGTS
			nTemInc++
		EndIf
		If ( RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_FGTS" ) == "S" )
			nPosPd := Ascan(aPd,{ |X| X[1] == cCodVerba .And. X[9] # "D"})
			//Se a verba tem incidência de FGTS, e esta no aPd, subtrai da base o que já foi somado.
			If nPosPd > 0 .and. RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_FGTS" ) == "S" .and. RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_REF13" ) <> "S"
				If lBaseINSS .or. aScan(aPd, {|x| x[1] == aAdicFGTS[nX,3]}) == 0 .or. !(RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_INCORP" ) <> "S")
					nBsAdic -= aPd[nPosPd,5]
				Else
					nBsAdic -= Round(( nValVerba / nDiasC ) * DiasTrab, 2)
				EndIf
			EndIf
			If RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_INCORP" ) <> "S" 
				If !lIncoNFGTS
					nBsAdic += NoRound((nValVerba / nDiasC) * ( nDiasFgts + DiasTrab ))
				Else	
					nBsAdic += (nValVerba / nDiasC) * ( nDiasFgts )								
				EndIf
			Else
				If !lIncoNFGTS .And. nPosPd > 0 .And. DiasTrab > 0
					nBsAdic += aPd[nPosPd,5]
				Elseif DiasTrab > 0	
					nBsAdic += (nValVerba / nDiasC) * ( nDiasFgts + DiasTrab )
				EndIf							
			EndIf						
		EndIf
		If DiasTrab > 0 .and. nDiasPG < nDiasFgts .and. ( RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_FGTS" ) == "S" )
			If ( nPosPd := Ascan(aPd,{ |X| X[1] == cCodVerba .And. X[9] # "D"}) ) > 0
				//Se os dias de adicionais forem superiores aos dias trabalhados, proporcionaliza o pagamento de acordo com os dias trabalhados.
				If cTipoPd == "D"
					If aPd[nPosPd,4] > DiasTrab
						nBsAdic -= aPd[nPosPd,5]
						nBsAdic += ( aPd[nPosPd,5] / (nDiasPg + DiasTrab) ) * DiasTrab
					EndIf
				Else
					nDiasAdc := Int( aPd[nPosPd,4] / SRA->RA_HRSDIA )
					If nDiasAdc > DiasTrab
						nHrsTot := (nDiasPg + DiasTrab) * SRA->RA_HRSDIA
						nBsAdic -= aPd[nPosPd,5]
						nBsAdic += ( aPd[nPosPd,5] / nHrsTot ) * aPd[nPosPd,4]
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
Next nX

lInco := If(nTemInc > 0, .T., lIncoNFGTS) //Se pelo menos um adicional incorporou irá considerar o salário normal para base do FGTS

Return nBsAdic


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCFgts13 ³ Autor ³ Mauro                 ³ Data ³25/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do FGTS  Funcionario 13o.                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCFgts13(aCodfol)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCfgts13(aCodfol, nfgts13_b, cGrava, lCond, cTipo, lTrunca, nFgts13_Mil, nFgts13_Aci)

Local dDataIni,dDataFim,nPosCod1,nPosCod2,nAvos_OQ,nAvos_R,n13AvInd,lSomouPri
Local nBs13Srd		:= 0
Local nArred13		:= 0
Local nPerFgts  	:= 0
Local nAvosAci		:= 0
Local nValAux		:= 0
Local lTCpoFgts 	:= ( Type("SRA->RA_PERFGTS") # "U" )
Local cTipAfa   	:= If( Type("cAbatAfas") == "U", GetMvRH("MV_ABATAFA"), cAbatAfas)
Local cCodigos		:= ""
Local cMedDire		:= P_MEDDIREN
Local nValMedDir	:= 0
Local aVerbasLanc	:= {}
Local aPerAberto	:= {}
Local aPerFechado	:= {}
Local nPos			:= 0
Local nbasetot      := 0
Local nfgtstot      := 0
Local nVal1730		:= 0
Local nAvAux		:= 0
Local nBs13Mil		:= 0
Local nFgtsLiq      := 0
Local lDevFGTS	    := .F.
Local lTemId1848	:= Len(aCodFol) >= 1848 .And. !Empty(aCodFol[1848, 1])
Local lTemId1849	:= Len(aCodFol) >= 1848 .And. !Empty(aCodFol[1849, 1])
Local lTemId1883    := Len(aCodFol) >= 1883 .And. !Empty(aCodFol[1883, 1])
Local lIdFuncPub	:= Len(aCodFol) >= 1956 .And. !Empty(aCodFol[1956, 1])
Local lTemId1962	:= Len(aCodFol) >= 1963 .And. !Empty(aCodFol[1962, 1]) .And. !Empty(aCodFol[1963, 1])
Local lSALMGRP		:= GetMvRH("MV_SALMGRP",,"N") == "S"

DEFAULT nFgts13_Mil	:= 0
DEFAULT nFgts13_Aci := 0
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() //Memória de Cálculo

//Tratamento para P_MEDDIREN = "M" - Misto. Calcula como se fosse "S" para funcionário com menos de um ano de contrato por tempo determinado.
If cMedDire == "M"
	cMedDire := If(SRA->RA_TPCONTR == "2" .and. DateDiffYear( SRA->RA_DTFIMCT , SRA->RA_ADMISSA ) < 1, "S", "N")
EndIf

//--Situacao do Funcionario na data de referencia
cSitFolh	:= If( type("cSitFolh")=="U",SRA->RA_SITFOLH,cSitFolh)

lCond 		:= If (lCond = Nil , .T. , lCond)   // Condicao para Somainc
cTipo 		:= If (cTipo = Nil , " " , cTipo)
lTrunca 	:= If (lTrunca = Nil , .T. , lTrunca)
lResExt		:= If( Type("lResExt") 	== "U"	, .F., lResExt)
cEncResExt	:= If( Type("cEncResExt") == "U" .Or. Empty(cEncResExt), "1234", cEncResExt)

If cSitFolh = "D"  .And. cTipo # 'R'
	Return
EndIf

If SRA->RA_CATFUNC = "P" .And. (!lTCpoFgts .Or. SRA->RA_PERFGTS == 0.00)
	Return
EndIf

//Inicializa caso nao tenham sido criadas
aAfast  := If(Type("aAfast") == "U", {}, aAfast)
nAvos   := If(Type("nAvos")  == "U",  0, nAvos)

//--Verifica Qual Percentual de FGTS deve Aplicar 
If lTCpoFgts .And. SRA->RA_PERFGTS > 0.00
	nPerFgts := SRA->RA_PERFGTS / 100
Else
	nPerFgts := If (SRA->RA_TPCONTR$ " *1*3",nFgtsCt1,nFgtsCt2)
EndIf

If lResExt .And. !("3" $ cEncResExt)
	nPerFgts := 0
EndIf

nFgts13_b := 0
If Ascan(aPd,{ |X| X[1] = aCodfol[109,1] .And. X[3] == cSemana .And. X[9] # "D"}) = 0
	If __lMemCalc			
		fAddMemLog("Verbas com incidência para FGTS 13º:", 1, 2)
	EndIf
	// Soma Base do fgts 13o
	If SRA->RA_TPCONTR == "3" .And. SRA->RA_TIPOPGT == "S"
		Aeval(aPd,{ |X| nFgts13_B += If ( X[1]==aCodFol[108,1] .And. X[3] == cSemana .And. X[9] # "D" ,X[5] ,0)})
		//--Somar Fgts Semanas Anteriores
		If cSemana # Space( 2 ) .And. cSemana > "01"
			Aeval( aPd,{ |X| nbasetot += If( X[1]=aCodFol[108,1] .And. x[3] < cSemana,x[5],0 ) } )
			Aeval( aPd,{ |X| nfgtstot += If( X[1]=aCodFol[109,1] .And. x[3] < cSemana,x[5],0 ) } )	
		EndIf
	Else
		Aeval(aPd,{ |X| nFgts13_B += If ( X[1]==aCodFol[108,1] .And. X[9] # "D" ,X[5] ,0)})
	EndIf
	If nFgts13_b = 0
		nFgts13_B	:= 0.00
		nArred13	:= 0.00
		//-- Soma Incidencia para Base de Fgts
        Aeval( aPd ,{ |X| SomaInc(X,6,@nFgts13_b,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.) })
	    If SRA->RA_TPCONTR == "3"
			Aeval( aPdConvoc ,{ |X| SomaInc(X,6,@nFgts13_b,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol) })
		EndIf

		//-- Data inicial e final para calculo do 13o. salario
   		dDataIni := If(MesAno(dDataAte) == MesAno(SRA->RA_ADMISSA),SRA->RA_ADMISSA,CTOD("01/01/"+StrZero(Year(dDataAte),4)))
		dDataFim := CTOD("31/12/"+StrZero(Year(dDataAte),4))

		// Se houve pagamento de arredondamento na primeira parcela, ela não possui incidência para FGTS e não foi gerada a verba de contrapartida, soma na base pois ela foi descontada indevidamente na verba 0183
		If cTipoRot $ "6*4" .and. RetValSRV(aCodFol[26,1], SRA->RA_FILIAL, "RV_FGTS") != "S" .and. ( aScan(aPd, {|x| x[1] == aCodFol[29,1] .and. x[9] <> "D" }) == 0 )
			fBuscaAcmPer(aCodFol[26,1], "", "V", @nArred13, , AnoMes(dDataIni), AnoMes(dDataFim), ,, fGetCalcRot("1")+fGetCalcRot("5"), .T. , .F.  )
			nFgts13_b += nArred13
		EndIf

		//-- Se folha de pagamento e houver base, buscar afastamento para recalcular base integral
		//-- Se a verba de 13o tiver sido paga em ferias ("K"), nao buscar afastamentos
	    If cTipoRot == "1" .And. (Ascan( aPd, { |X| X[1] == aCodFol[22,1] .And. X[7] == "K" }) == 0)
		    nAvosAf := 0
	    	If nFgts13_B > 0
		    	fAvos13(@nAvos,dDataAte,0,0,"1")
		    	fRetAfas(dDataIni,dDataFim,If(cTipAfa=="S","O*P*Q*X*B",cTipAfa),@nAvosAf,,,@aAfast)
				nAvos := Max(0, nAvos - nAvosAf)
		    EndIf
	    EndIf

	    //Quando for dissidio, estiver calculando a segunda parcela do 13º e utilizar reajuste de 13º pelas verbas incorporadas na folha, carrega as verbas que incorporaram na folha
		If nFgts13_b > 0 .and. cTipoRot $ "1*6" .and. lDissidio .and. Type("P_LDIFINC") <> "U" .And. P_LDIFINC
			fRetPerComp(SubStr(cPeriodo,5,2), SubStr(cPeriodo,1,4), Nil, Nil, fGetRotOrdinar(), @aPerAberto, @aPerFechado)
			aVerbasLanc := RetornaVerbasFunc(SRA->RA_FILIAL,SRA->RA_MAT,NIL,fGetRotOrdinar(),,aPerAberto,aPerFechado,,"RV_INCORP=='S'")
			If Len(aVerbasLanc) > 0
				If cTipoRot == "6"
					For nPos := 1 to Len(aVerbasLanc)
						nFgts13_b += aVerbasLanc[nPos,7]
					Next nPos
				ElseIf IsInCallStack("GravaDissidio") .and. Len(aPercDif) > 0
					nIndice := aPercDif[Len(aPercDif),2]
					For nPos := 1 to Len(aVerbasLanc)
						nFgts13_b -= ( aVerbasLanc[nPos,7] * (nIndice/100))
					Next nPos
				EndIf
			EndIf
		EndIf	    

		// Calcula FGTS com base total se afastamento acidente de trabalho ou militar
		nAvos_OQ := 0
		nAvos_R := 0
	    Aeval( aAfast ,{ |X| nAvos_OQ += If( ( Left( X[16], 1 ) == "O" .or. X[16] $ "Q4*Q5*Q6" .Or. (X[16] == "Q1" .And. Empty(X[20])) ), X[1], 0 ) }) //--Acidente de trabalho o adoção
	    Aeval( aAfast ,{ |X| nAvos_r += If( Left( X[16], 1 ) $ "R", X[1], 0 ) })
		If (nAvos_OQ > 0 .Or. nAvos_R > 0) .And. nAvos > 0 .And. nFgts13_B > 0

			// Busca valor do desconto da 1a parcela e devolve para achar total do 13o.
			lSomouPri := .F.
			nPosCod1   := Ascan(aPd,{ |X| X[1] == aCodfol[183,1] .And. X[9] # "D"} )
			nPosCod2   := 0
			If nPosCod1 == 0
				nPosCod2 := Ascan(aPd,{ |X| X[1] == aCodfol[116,1] .And. X[9] # "D"} )
         	EndIf
			If (nPosCod1 > 0 .And.  RetValSRV(aCodFol[183,1],SRA->RA_FILIAL,"RV_FGTS") == "S") .Or. ;
			   (nPosCod2 > 0 .And.  RetValSRV(aCodFol[116,1],SRA->RA_FILIAL,"RV_FGTS") == "S")
				fBuscaAcmPer(aCodFol[108,1], "", "V", @nBs13Srd, , AnoMes(dDataIni), AnoMes(dDataFim), ,, fGetCalcRot("1")+fGetCalcRot("5"), .T. , .F.  )
				//-- Soma o valor da 1a parcela somente se a 1a parcela estiver acumulada no SRD
				//-- caso contrario nao soma pois a rescisao esta ocorrendo no mesmo mes do pagamento
				//-- da 1a parcela do 13o salario.
				If nBs13Srd > 0
		  			nFgts13_B  += aPd[If(nPosCod1 > 0, nPosCod1, nPosCod2),5]
					lSomouPri  := .T.
		  		EndIf
			EndIf

			fBuscaAcmPer(aCodFol[1730,1], "", "V", @nVal1730, , AnoMes(dDataIni), AnoMes(dDataFim), ,, fGetCalcRot("1")+fGetCalcRot("5"), .T. , .F.  )
			// Salva o valor das medias ocorridas no movimento e desconta da base de calculo
			// quando o parametro MV_MEDDIRE estiver com "S" Meses de Direito.
			If cMedDire == "S"
				cCodigos	+= If(!empty(aCodFol[123,1]) .And. RetValSRV(aCodFol[123,1],SRA->RA_FILIAL,"RV_FGTS") == "S",aCodFol[123,1]+",","")
				cCodigos	+= If(!empty(aCodFol[124,1]) .And. RetValSRV(aCodFol[124,1],SRA->RA_FILIAL,"RV_FGTS") == "S",aCodFol[124,1]+",","")
				cCodigos	+= If(!empty(aCodFol[251,1]) .And. RetValSRV(aCodFol[251,1],SRA->RA_FILIAL,"RV_FGTS") == "S",aCodFol[251,1]+",","")
				cCodigos	+= If(!empty(aCodFol[253,1]) .And. RetValSRV(aCodFol[253,1],SRA->RA_FILIAL,"RV_FGTS") == "S",aCodFol[253,1],"")
				nValMedDir	:= fBuscaPd(cCodigos,"V")
			EndIf

			// Abate o valor encontrado de medias quando o parametro MV_MEDDIRE estiver com "S"
			nFgts13_B	-= nValMedDir
			
			// Se roteiro de rescisao, abater avo indenizado para depois calcular
			If cTipoRot == "4"
				n13AvInd := 0
				Aeval(aPd,{ |X| n13AvInd += If ( X[1]==aCodFol[115,1] .And. X[9] # "D" ,X[5] ,0)})
				
				If n13AvInd > 0 .And. RetValSRV(aCodFol[115,1],SRA->RA_FILIAL,"RV_FGTS") == "S"
		  			nFgts13_B -= n13AvInd
		  		Else
		  			n13AvInd := 0.00	
				EndIf
				
				If lSALMGRP .or. Left(aAfast[1,16], 1) == "O"
					nAvAux 		:= nAvos + If( !lTemId1849, nAvos_R, 0) + nAvos_OQ + nAvosMat				
					nFgts13_B 	:= Round( @nFgts13_B / ( nAvos + nAvosMat ) * nAvAux, 2 )
				EndIf 

				If lTemId1849
  					nFgts13_Mil := Round( nFgts13_B / ( nAvos + nAvos_OQ + nAvosMat ) * nAvos_R, 2 )
				EndIf

				If lTemId1883 .and. nAvos_OQ > 0
					nFgts13_Aci := Round( nFgts13_B / ( nAvos + nAvos_OQ + nAvosMat ) * nAvos_OQ, 2 )
				EndIf

				nFgts13_B += n13AvInd
	  		Else
	  			nValAux	  := nFgts13_B
	  			If !lTemId1848
					nFgts13_B 	:= Round( fRetDec(@nFgts13_B) / nAvos * (nAvos + nAvos_OQ + nAvos_R), 2 )
				Else
					nFgts13_Mil := Round( (nFgts13_B-nBs13Srd) / nAvos * nAvos_R, 2 )
					If nAvos_OQ > 0
						nFgts13_B 	:= Round( (nFgts13_B / nAvos) * (nAvos + nAvos_OQ), 2 )
					EndIf
				EndIf
			EndIf
			// Soma o valor encontrado de medias quando o parametro MV_MEDDIRE estiver com "S"
			nFgts13_B	+= nValMedDir
			// Subtrai base da 1a parcela para achar base da 2a.
			If lSomouPri
  				nFgts13_B -= nBs13Srd
  			EndIf
  			
  			If cTipoRot == "6" .and. nValAux > 0
	  			//Verifica se houve afastamento por acidente de trabalho para gerar a verba 1730
				Aeval( aAfast ,{ |X| nAvosAci += If( X[16] == "O1", X[1], 0 ) })
				
				If nAvosAci > 0
					nValAux := Round( (nValAux / nAvos) * (nAvosAci), 2 )
					FMatriz(aCodfol[1730,1],Max(nValAux-nVal1730, 0),0,cSemana)
				EndIf
			EndIf
		EndIf
		// Calcula FGTS para funcionario afastado durante todo o ano por Acidente ou Militar
	    If cTipoRot == "4"
	    	If nFgts13_B == 0 .And. nAvos == 0 .And. (nAvos_OQ > 0 .Or. nAvos_R > 0)
				nAvAux := If( !lTemId1849, nAvos_R, 0) + nAvos_OQ
				
				nFgts13_B := (((SalMes + nAdtServ + nPeric + nInsalub ) / 12) * nAvAux ) + nMed13o
				
				If lTemId1849 .and. nAvos_R > 0
					nFgts13_Mil	:= (((SalMes + nAdtServ + nPeric + nInsalub ) / 12) * nAvos_R )
				EndIf
				If lTemId1883 .and. nAvos_OQ > 0
					nFgts13_Aci	:= (((SalMes + nAdtServ + nPeric + nInsalub ) / 12) * nAvos_OQ )
				EndIf
			EndIf
	    ElseIf cTipoRot == "6"
			If nFgts13_B == 0
				nBs13Srd := 0
				If nAvos_OQ+nAvos_R == 12 .And. Left(SRA->RA_AFASFGT,1) $ "O*B*R"
					nBs13Srd  := fBuscaAcm(aCodFol[108,1],,dDataIni,If(lDissidio .and. AnoMes(dDataFim) == cPeriodo, MonthSub(dDataFim,1) ,dDataFim),"V")
					nBs13Mil  := fBuscaAcm(aCodFol[1848,1],,dDataIni,If(lDissidio .and. AnoMes(dDataFim) == cPeriodo, MonthSub(dDataFim,1) ,dDataFim),"V")
					If !lTemId1848 .Or. nAvos_R == 0
						nFgts13_B 	:= salmes - nBs13Srd
					Else
						nFgts13_Mil	:= salmes - nBs13Mil
					Endif
				//Funcionario afastado durante todo o ano, mas somente parte foi por Acidente ou Adocao
				ElseIf nAvos == 0 .And. nAvos_OQ+nAvos_R > 0					
					If !lTemId1848
						nFgts13_B 	:= ( (SalMes / 12) * (nAvos_OQ+nAvos_R) )
					Else
						nFgts13_B 	:= ( (SalMes / 12) * nAvos_OQ )
						nFgts13_Mil := ( (SalMes / 12) * nAvos_R )
					EndIf
				EndIf			
			   	If nAvos_OQ > 0
			   		nAvosAci := 0
		  			//Verifica se houve afastamento por acidente de trabalho para gerar a verba 1730
					Aeval( aAfast ,{ |X| nAvosAci += If( X[16] == "O1", X[1], 0 ) })
					
					If nAvosAci > 0
						nValAux := SalMes - nBs13Srd
						nValAux := Round( fRetDec(@nValAux) / 12 * (nAvosAci), 2 )
						FMatriz(aCodfol[1730,1],nValAux,0,cSemana)
					EndIf
				EndIf				
			EndIf
		EndIf
	EndIf

	If cGrava # Nil .And. cGrava = "S"

		If lTrunca
			nVfgts13 := NoRound( (nFgts13_B+nFgts13_Mil) * nPerFgts,2)
		Else
			nVfgts13 := Round( (nFgts13_B+nFgts13_Mil) * nPerFgts,2)
		EndIf

        nVlrBFgts   := nFgts13_B - nbasetot
        nVlrFgts    := nVfgts13 - nfgtstot

        If nVlrBFgts < 0
            nVlrBFgts   *= (-1)
            nVlrFgts    *= (-1)
            lDevFGTS    := .T.
        EndIf

		FMatriz( Iif( !lDevFGTS, aCodfol[109,1], aCodfol[1676,1] ), nVlrFgts )
		FMatriz( Iif( !lDevFGTS, aCodfol[108,1], aCodfol[1677,1] ), nVlrBFgts )

		If lTemId1848 .and. nFgts13_Mil > 0
			FMatriz(aCodfol[1848,1],nFgts13_Mil)
		EndIf
		If lTemId1883 .and. nFgts13_Aci > 0
			FMatriz(aCodfol[1883,1],nFgts13_Aci)
		EndIf

		If __lMemCalc .And. nVlrBFgts > 0 .And. cTipoRot <> "4"
			fAddMemLog("Base FGTS 13º: R$ " + AllTrim(Transform( nVlrBFgts, "@E 999,999,999,999.99" )), 1, 2)		
			fAddMemLog("Cálculo do FGTS 13º: R$ " + AllTrim(Transform( nVlrBFgts, "@E 999,999,999,999.99" )) + " * " +cValToChar(nPerFgts), 1, 2)
			fAddMemLog("FGTS do mês 13º: R$ " + AllTrim(Transform( nVfgts13, "@E 999,999,999,999.99" )), 1, 2)						
		EndIf

		//ID gerado para o eSocial, S-1202 - Remuneração de servidor vinculado a RPPS
		If lIdFuncPub .And. SRA->RA_TPPREVI == "2" .And. !SRA->RA_VIEMRAI $ "30*31*35"
			FMatriz(aCodfol[1956,1],nFgts13_B - nbasetot)
		EndIf
		If cTipoRot == "6" .And. lTemId1962 .And. AnoMes(dDataAte) < AnoMes(dDataFim) //Se o cálculo do 132 estiver sendo efetuado antes do mes 12, grava liquido
			nFgtsLiq    := (nVlrBFgts - nVlrFgts) * nPerFgts
			FMatriz(aCodfol[1962,1],nFgtsLiq)
			FMatriz(aCodfol[1963,1],nFgtsLiq)
		EndIf
	EndIf
EndIf

Return
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCSalC   ³ Autor ³ Equipe RH             ³ Data ³06/02/99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Inss Pro-Labore Autonomo                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCSalC(aCodfol,aTSalC)                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCSalC(aCodfol,aTSalC)

Local aInfoAux  := {}
Local aPdBkp    := {}
Local lMultv    := Type("lUtiMultiV") <> "U" .And. lUtiMultiV
Local nX        := 0

nSalc_b := 0.00
nSalC_c := 0.00
nInssSc := 0.00

If lMultv
	aPdBkp := AClone(aPd)
	For nX := 1 To Len(aPd)
		If aPd[nX,3] <> cSemana
			aPd[nX,3] := cSemana
		EndIf
	Next nX
EndIf

If ( lInssAut .Or. (SRA->RA_CATEFD $ "711|712|734" .And. fInfo(@aInfoAux, SRA->RA_FILIAL) .And. aInfoAux[12] == "1") ) .Or. lAutMei//Campo RA_INSSAUT igual a Sim ou vazio ou autônomo fretereiro e produtor rural PF OU autônomo MEI
	If Ascan(aPd,{ |X| X[1] = aCodfol[222,1] .And. X[3] = cSemana .And. X[9] # "D"}) = 0
		If SRA->RA_CATEG $ "17|18"	
			//--Soma Base Pro-Labore lancada
			Aeval(aPd,{ |X| nSalC_c += If ( X[1]$ aCodfol[1384,1] .And. X[3] = cSemana .And. X[9] # "D" ,X[5] ,0)})
			If nSalc_c = 0.00
				//-- Soma Incidencia para Inss
				Aeval( aPd ,{ |X| If (x[3] == cSemana,SomaInc(X,4,@nSalC_c  ,11,"N",12,"N", , ,aCodfol),"")})
		   EndIf
		Else
			//--Soma Base Pro-Labore lancada
			Aeval(aPd,{ |X| nSalC_b += If ( X[1]$ aCodfol[221,1] .And. X[3] = cSemana .And. X[9] # "D" ,X[5] ,0)})
			If nSalc_B = 0.00
				//-- Soma Incidencia para Inss
				Aeval( aPd ,{ |X| If (x[3] == cSemana,SomaInc(X,4,@nSalC_b ,11,"N",12,"N", , ,aCodfol),"")})
			EndIf
		EndIf
	EndIf
EndIf

If lMultv
	aPd := AClone(aPdBkp)
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fCContrib ºAutor  ³Microsiga           º Data ³  09/24/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Calculo da Contribuicao sobre base Fgts                     º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP6                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCContrib()

Local lTCpoFgts := ( Type("SRA->RA_PERFGTS") # "U" )

Static cFilCtr
Static nPCtr
Static nPcTrR
Static cFilCtr13
Static nPCtr13
Static nPCtrR13

If SRA->RA_CATFUNC = "P" .And. (!lTCpoFgts .Or. SRA->RA_PERFGTS == 0.00)
	Return
EndIf

//--Carregar o % da contribuicao sobre Fgts
If cFilCtr = Nil .Or. cFilCtr # SRA->RA_FILIAL
	cFilCtr := SRA->RA_FILIAL
	nPCtr	:= RetValSRV(aCodFol[298,1],SRA->RA_FILIAL,"RV_PERC") /100
	nPCtrR	:= RetValSRV(aCodFol[295,1],SRA->RA_FILIAL,"RV_PERC") /100
EndIf	

//--Carregar o % da contribuicao sobre Fgts
If cFilCtr13 = Nil .Or. cFilCtr13 # SRA->RA_FILIAL
	cFilCtr13 := SRA->RA_FILIAL
	nPCtr13	  := RetValSRV(aCodFol[299,1],SRA->RA_FILIAL,"RV_PERC") / 100
	nPCtrR13  := RetValSRV(aCodFol[296,1],SRA->RA_FILIAL,"RV_PERC") / 100
EndIf	

//--Calculo da Contribuicao Sobre Base Fgts
If nPCtr > 0.00
	//-- Soma Base Fgts Folha
	nBaseMes := FBuscaPd(aCodFol[17,1],,cSemana)
	If nBaseMes > 0
		FMatriz(aCodfol[298,1],NoRound(nBaseMes * nPCtr,2) , nPCtr * 100)
	EndIf		
EndIf

If nPCtrR > 0
	//--Soma Base Resc. por Dispensa	
	nBaseRes := fBuscaPd(aCodFol[293,1],,cSemana)
    If nBaseRes > 0 
		FMatriz(aCodfol[295,1],NoRound(nBaseRes * nPCtrR,2) , nPCtrR * 100)
	EndIf	
EndIf	

//--Calculo da Contribuicao Sobre Base Fgts 13o.
If nPCtr13 > 0.00     
  
	//-- Soma Base Fgts 13o
	nBase13 := FBuscaPd(aCodFol[108,1],,cSemana)
	If nBase13 > 0
		FMatriz(aCodfol[299,1],NoRound(nBase13 * nPCtr13,2) , nPCtr13 * 100)
	EndIf	 
EndIf	
	 
If nPCtrR13 > 0	
    //-- Soma Base 13o. resc. por Dispensa
	nBRes13 := fBuscaPd(aCodFol[294,1],,cSemana)
	If nBres13 > 0
		FMatriz(aCodfol[296,1],NoRound(nBRes13 * nPCtrR13,2) , nPCtrR13 * 100)
	EndIf	
EndIf	

Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FCalcInssFun ³ Fatima    	            ³ Data ³ 06/11/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calculo Encargos Empresa por Funcionario                   ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCalcInssFun()

Local cRecFatEmp  := ""
Local cTpc        := ""
Local cAux		  := ""
Local cVerba	  := ""
Local cTpRotAnt	  := ""
Local nValBasInss := 0.00
Local nPercAcTrab := 0.00
Local nPercTer    := 0.00
Local nPercPro    := 0.00
Local nPercAut    := 0.00
Local nPercEmp    := 0.00
Local nPerFatEmp  := 0
Local nPercFPAS   := 0.00
Local nPercCC     := 0.00
Local nDed        := 0.00
Local nBasePis    := 0.00
Local nBseProAut  := 0.00
Local nTotBseAut  := 0.00
Local nRet        := 0.00
Local nX		  := 0
Local nRetFDes	  := 0.00
Local nComplEmp13 := 0.00
Local nComplEmpFol:= 0.00
Local nComplB13	  := 0.00
Local nComplBFol  := 0.00
Local lRotDiss	  := IsInCallStack( "GPEM690" )
Local lPercCC	  := .F.
Local lPercSRA    := .F.
Local lSumAnt     := .F.
Local lPerIgual   := .F.
Local lResComDis  := cTipoRot == "4" .And. cCompl == "S" .And. lRescDis
Local lOnera	  := ( cTipoRot == "4" .Or. cTipoRot == "6" )
Local lComplDis	  := IsInCallStack("GravaDissidio") //complemento 13 no dissidio
Local nPerc		  := 0
Local nValcus	  := 0.00
Local nIdDiss	  := 0
Local nIdTerc	  := 0
Local nIdSalEdu	  := 0
Local nIdIncra	  := 0
Local nIdSenai	  := 0
Local nIdSesi	  := 0
Local nIdSenac	  := 0
Local nIdSesc	  := 0
Local nIdSebrae	  := 0
Local nIdDpc	  := 0
Local nIdFaer	  := 0
Local nIdSenar	  := 0
Local nIdSeconc	  := 0
Local nIdSest	  := 0
Local nIdSenat	  := 0
Local nIdSescoop  := 0
Local nIdAdSenai  := 0
Local nValSENAI	  := 0
Local nBaseMes	  := 0 //Base INSS em casos de de rescisão complementar por dissidio dentro do mesmo mês.
Local nValAux 	  := 0
Local nBasEncarg  := 0
Local nValAuxAf	  := 0
Local nBasInssOld := 0
Local nPAcTrabOld := 0
Local nPAcTrabAux := 0

Local cMesAberto  := cAnoMes //Mnemonico carregado na formula CARGARCH()
Local cMesCalcDis := IIF(lRotDiss, cMesAnoCalc, "") // Se for GPEM690 usa o período do cálculo do dissídio
Local cOneFol	  := P_FDESFOL

Local aArea		  := GetArea()
Local aPdAfa 	  := {}
Local aPdMat 	  := {}
Local aInfoAux	  := {}
Local aInssEmpAnt := {}
Local lComplFol	  := P_CCOMP13 == 'S' .And. lCalcFol .And. fTem132Per()
Local lTabS033	  := .F.
Local lProLab	  := (Len(aCodFol) >= 1430)
Local lAutCoo	  := (Len(aCodFol) >= 1448)
Local lVbInSMat	  := (Len(aCodFol) >= 1905) .And. !Empty(aCodFol[1905,1])
Local lGestPubl	  := IIF(ExistFunc("fUsaGFP"), fUsaGFP(), .F.)
Local cBkpRot	  := ""
Local nPosOnera	  := 0
Local lFpas582	  := .F.
Local lContrVA	  := SRA->RA_CATEFD $ '107/108'
Local lRot131	  := If( cTipoRot == "5"	, .T., .F.)
Local nLimiteVA	  := VAL_SALMIN * 1.5
Local lIntermit	  := SRA->RA_TPCONTR == "3"
Local cPdsCP15	  := ""
Local nValTer     := 0
Local aPosTerc	  := {}
Local aBkpEmpSt   := {}
Local nValAuxOld  := 0
Local nValAfOld	  := 0

Private aInssEmp   
Private aGPSPer 

Static cFilInss 
Static aInssEmpSt
Static aGPSPerSt
Static aInssEmpOld
Static aDedTer 

DEFAULT lPAcTrabDif := .F.

lRescDis	:= If( Type("lRescDis")=="U",.F.,lRescDis)//Rescisao Complementar por Dissidio
lProxMes    := If( Type("lProxMes") == "U", .F., lProxMes) // Rescisão complementar no próximo mês da original.
lDissidio	:= If(lDissidio == Nil,.F.,lDissidio) 
lResExt		:= If( Type("lResExt") 	== "U"	, .F., lResExt)
lInssAut	:= If( Type("lInssAut")	== "U"	, .T., lInssAut)
lEncPatro	:= If( Type("lEncPatro") == "U", .T., lEncPatro)
cEncResExt	:= If( Type("cEncResExt") == "U" .Or. Empty(cEncResExt), "123", cEncResExt)
lTabS033	:= Type( "aTabS033" ) == "U"
P_ENCEMP	:= If(Type("P_ENCEMP")=="U","", P_ENCEMP) //Define quais encargos terão as verbas de maternidade deduzidas. 1 = Todos
P_DEDMAT	:= If(!Empty(P_ENCEMP) .and. Type("P_DEDMAT")<>"U",P_DEDMAT,"") //Define quais verbas de maternidade serão deduzidas. 1 = Todos
P_ENCEMPAF	:= Iif(cPaisLoc == "BRA" .And. Type("P_ENCEMPAF")=="U", "", P_ENCEMPAF) //Define quais encargos terão as verbas de incidência CP 15 deduzidas. 1 = Todos

If !Empty(P_ENCEMP) .and. !(P_ENCEMP == '1') .and. !("*" $ P_ENCEMP)
	cAux := ""
	For nX := 1 to Len(P_ENCEMP) step 3
		cAux += SubStr(P_ENCEMP,nX,3) + "*"
	Next nX
	P_ENCEMP := cAux	
EndIf

If !Empty(P_DEDMAT)
	cAux := ""
	If !(P_DEDMAT == '1') .and. !("*" $ P_DEDMAT)
		For nX := 1 to Len(P_DEDMAT) step 3
			cVerba := SubStr(P_DEDMAT,nX,3)
			If RetValSrv( cVerba, SRA->RA_FILIAL, "RV_INSS" ) == "S"
				cAux += cVerba + "*"
			EndIf
		Next nX
		P_DEDMAT := cAux
	ElseIf P_DEDMAT == "1"
		aPdMat := fCarPdMat( cTipoRot == "4" .And. aScan(aPd, { |x| x[1] == aCodFol[247, 1] .And. x[9] != "D" } ) > 0 )
		For nX := 1 to Len(aPdMat)
			cAux += aPdMat[nX] + "*"
		Next nX
		P_DEDMAT := cAux
	EndIf 
EndIf

If !Empty(P_ENCEMPAF)	
	If !(P_ENCEMPAF == '1') .and. !("*" $ P_ENCEMPAF)
		cAux := ""
		For nX := 1 to Len(P_ENCEMPAF) step 3
			cAux += SubStr(P_ENCEMPAF,nX,3) + "*"
		Next nX
		P_ENCEMPAF := cAux	
	EndIf
	cAux := ""
	aPdAfa := fCarPdAfa()
	For nX := 1 to Len(aPdAfa)
		cAux += aPdAfa[nX] + "*"
	Next nX
	cPdsCP15 := cAux
EndIf

// Verifica tipo de contrato
If SRA->RA_TPCONTR$ " *1"
	cTpC  := "1"
Else	
	cTpC  := "2"
EndIf

// Carrega Array de Encargos da Empressa    
If aInssEmpSt == nil .or. Len(aInssEmpSt) == 0 .Or. cFilInss # SRA->RA_FILIAL
	RstGpexIni()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Resgata os percentuais de terceiros armazenados na tabela S035			³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	fGPSVal(SRA->RA_FILIAL,cMesAberto,@aGPSPerSt,cTpC)

	aInssEmpSt := Array(23,2)
	cFilInss := SRA->RA_FILIAL
	aDedTer  := {}
	If !fInssEmp(SRA->RA_FILIAL,@aInssEmpSt,,IIf(lRotDiss, cMesCalcDis, cMesAberto),,,,@aDedTer)
		Return                            
	EndIf 

	aInssEmpOld := {}		
	If lRotDiss .And. SubStr(cMesCalcDis, 1, 4) > SubStr(cMesAberto, 1, 4) .And. !fInssEmp(SRA->RA_FILIAL, @aInssEmpOld,, cMesAberto,,, lRotDiss) //Busca apenas o percentual de acidente da S037 do período da época
		Return
	EndIf	

EndIf

aInssEmp    := aInssEmpSt
aGPSPer     := aGPSPerSt
aInssEmpAnt := aInssEmpOld

If lRotDiss .And. Len(aInssEmpAnt) > 0
	nPAcTrabOld := If (SRA->RA_TPCONTR $ " *1", aInssEmpAnt[3, 1], aInssEmpAnt[3, 2])
EndIf

aAdd(aEncDCTF, {"RAT", If(SRA->RA_TPCONTR $ "1*3",aInssEmp[29,1],aInssEmp[29,2])})
aAdd(aEncDCTF, {"TER", If(SRA->RA_TPCONTR $ "1*3",aInssEmp[25,1],aInssEmp[25,2])})

If !lRot131
	// Soma a Base de Inss
	If lRescDis .or. lDissidio
		If lRescDis 
			aEval(aPd,{ |x| nValBasInss += If ( X[1] $ aCodFol[338,1] + "/" + aCodFol[399,1] .And. x[9] != "D" .And. Empty(x[15]), x[5], 0) })
			//Se a rescisão por dissidio for dentro do mesmo mês.
			If !lProxMes
				aEval(aPd,{ |x| nBaseMes += If ( X[1]$ AcodFol[13,1]+"/"+aCodFol[14,1]+"/"+aCodFol[19,1]+"/"+aCodFol[20,1] .And. x[9] # "D",x[5],0.00) })
			EndIf
		Else
			aEval(aPd,{ |x| nValBasInss += If ( X[1]$ AcodFol[13,1]+"/"+aCodFol[14,1]+"/"+aCodFol[19,1]+"/"+aCodFol[20,1] .And. x[9] # "D",x[5],0.00) })
			If nPAcTrabOld > 0
				aEval(aPdOld,{ |x| nBasInssOld += If ( X[1] $ AcodFol[13,1]+"/"+aCodFol[14,1]+"/"+aCodFol[19,1]+"/"+aCodFol[20,1] .And. x[9] # "D", x[5], 0.00) })
			EndIf
			If Len(aDedTer) > 0 .And. aInssEmp[2][Val(cTpc)] == 0//Valida se a verba % terceiros foi desmembrada
				aEval(aPdOld,{ |x| nValTer += If ( X[1] $ AcodFol[149,1] .And. x[9] # "D", x[5], 0.00) })
				If nValTer > 0
					aPosTerc   := {9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 22, 23, 26}//posicoes do aInssEmp referente a terceiros
					aBkpEmpSt  := aClone(aInssEmp)
					For nX := 1 to Len(aPosTerc)
						aInssEmp[aPosTerc[nX]][Val(cTpc)] := 0
					Next nX
					aInssEmp[2][Val(cTpc)] := aDedTer[Val(cTpc)]
				EndIf
			EndIf	
		EndIf
		
	Else
		aEval(aPd,{ |x| nValBasInss += If ( X[1]$ AcodFol[13,1]+"/"+aCodFol[14,1]+"/"+aCodFol[19,1]+"/"+aCodFol[20,1] .And. x[9] # "D" .And. If( cTipoRot == "N" .Or. lIntermit, x[3] == cSemana, .T. ),x[5],0.00) })
	EndIf

	If SRA->RA_TIPOPGT == "S" .And. !lUltSemana .And. !lIntermit
		nValBasInss := 0
	EndIf   

	cRecFatEmp 	:= aInssEmp[27, Val(cTpc)]//X14_RECFAT

	If nValBasInss > 0 .and. !SRA->RA_CATFUNC $ "AP"

		If !Empty(P_ENCEMP) .and. !Empty(P_DEDMAT)
			nValAux := 0
			aEval(aPd, {|x| If(x[1] $ P_DEDMAT .and. x[9] <> 'D', nValAux += x[5], Nil)})
			nValAuxOld := 0
			aEval(aPdOld, {|x| If(x[1] $ P_DEDMAT .and. x[9] <> 'D', nValAuxOld += x[5], Nil)})
		EndIf 
		If !Empty(P_ENCEMPAF) .and. !Empty(cPdsCP15)
			nValAuxAf := 0
			aEval(aPd, {|x| If(x[1] $ cPdsCP15 .and. x[9] <> 'D', nValAuxAf += x[5], Nil)})
			nValAfOld := 0
			aEval(aPdOld, {|x| If(x[1] $ cPdsCP15 .and. x[9] <> 'D', nValAfOld += x[5], Nil)})
		EndIf 

		If P_ENCEMP == "1" .and. (nValAux > 0 .Or. nValAuxOld > 0)
			nValBasInss := Max(0,nValBasInss-nValAux)
			nBasInssOld := Max(0,nBasInssOld-nValAuxOld)
			If nValBasInss > 0  .And. lVbInSMat
				FGeraVerba(aCodFol[1905,1], nValBasInss)
            EndIF
		EndIf 
		If P_ENCEMPAF == "1" .and. (nValAuxAf > 0 .Or. nValAfOld > 0)
			nValBasInss := Max(0,nValBasInss-nValAuxAf)
			nBasInssOld := Max(0,nBasInssOld-nValAfOld)
		EndIf

		//-- Calculo % Acid. Trab. por Funcionario
		If lRescDis 
			nIdDiss:= 945 // Percentual Acidente Trabalho Dissidio
		Else 
			nIdDiss:= 150 // Percentual Acidente Trabalho
		EndIf

		If ( !lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "2" $ cEncResExt )
			nRet := (aScan( aPd, {|X| x[1] == aCodFol[nIdDiss, 1] .And. If( cTipoRot == "N" .Or. lIntermit, x[3] == cSemana, .T. )} ))	// Testa se já existe
			nBasEncarg := nValBasInss
			If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMP
				nBasEncarg -= nValAux
			EndIf
			If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMPAF
				nBasEncarg -= nValAuxAf
			EndIf
			If nRet == 0  .or. lRescDis 
				nPAcTrabAux := If (SRA->RA_TPCONTR$ " *1", aInssEmp[3,1] , aInssEmp[3,2])
				fBuscaAci(@nPercAcTrab, @nPercTer, @lPercSRA, @lPercCC, @lPerIgual)
				If !lPercSRA .and. lRotDiss .and. !lPerIgual .and. Type("SRA->RA_PERCSAT") # "U" .And. SRA->RA_PERCSAT > 0 .And. SRA->RA_PERCSAT <> nPercAcTrab
					lPercSRA    := .T. 
					lSumAnt     := .T.
					nPAcTrabAux := SRA->RA_PERCSAT / 100 //Se for dissídio e existir percentual cadastrado na SRA diferente da tabela de encargos, deve usar o percentual para cálculo da diferença de bases
				EndIf
				If lRotDiss .And. lPercSRA .And. !lPerIgual .And. nPAcTrabAux <> nPercAcTrab
					nBasInssOld := 0
					aEval(aPdOld,{ |x| nBasInssOld += If ( X[1] $ AcodFol[13,1]+"/"+aCodFol[14,1]+"/"+aCodFol[19,1]+"/"+aCodFol[20,1] .And. x[9] # "D", x[5], 0.00) })
					nPAcTrabOld := nPercAcTrab
					nPercAcTrab := nPAcTrabAux
				EndIf
				fMatriz(aCodfol[nIdDiss, 1], IIf(lRotDiss .And. nBasInssOld > 0 .And. nPAcTrabOld <> nPercAcTrab .And. !lPercCC, Round(((nBasEncarg - nBasInssOld) * nPercAcTrab ) + If(lSumAnt, nBasInssOld * nPAcTrabOld, 0), 2), Round(nBasEncarg * nPercAcTrab, 2))) // Acidente Trabalho
				aAdd(aEncDCTF, {aCodfol[nIdDiss, 1], nPercAcTrab})
				//Se a rescisão por dissidio for dentro do mesmo mês da original.
				If !lProxMes .And. nBaseMes > 0
					fMatriz(aCodfol[150, 1], Round(nBaseMes * nPercAcTrab, 2))	// Acidente Trabalho
					aAdd(aEncDCTF, {aCodfol[150, 1], nPercAcTrab})
				EndIf
			ElseIf aPd[nRet,9] == "D"
				fBuscaAci(@nPercAcTrab, @nPercTer)
				fMatriz(aCodfol[nIdDiss, 1], Round(nBasEncarg * nPercAcTrab, 2))	// Acidente Trabalho
				aAdd(aEncDCTF, {aCodfol[nIdDiss, 1], nPercAcTrab})
			ElseIf lComplFol .or. ( P_CCOMP13 == 'S' .And. lCalcFol .And. cTipoRot == "6" .and.  AnoMes(SRA->RA_ADMISSA) == cPeriodo ) //Se funcionário foi admitido após o pagamento do 132, lCalcFol estará .F., porém, deve ser tratado da mesma forma quando é complementar.
				fBuscaAci(@nPercAcTrab, @nPercTer)
				fMatriz(aCodfol[nIdDiss, 1], Round(nValBasInss * nPercAcTrab,2),,,,,,,,,.T.)	// Acidente Trabalho
				aAdd(aEncDCTF, {aCodfol[nIdDiss, 1], nPercAcTrab})
			EndIf
		EndIf

		If lRotDiss .And. nPAcTrabOld > 0 .And. nPAcTrabOld <> nPercAcTrab .and. !lSumAnt
			lPAcTrabDif := .T.
		EndIf

		If !lContrVA .Or. (lContrVA .And. P_ENCARGVA)
			If lContrVA 
				If nValBasInss > nLimiteVA
					nValBasInss := nValBasInss - nLimiteVA
				Else
					nValBasInss := 0
				EndIf
			EndIf

			dbSelectArea("CTT")

			nPercFPAS := 0
			nPercEmp  := 0
			lFpas582  := .F.
			lPercCC   := .F.
			If CTT->(dbSeek( cFilial + SRA->RA_CC ))
				nPercFPAS   := CTT->CTT_PERFPA / 100
				nPercCC   	:= nPercFPAS
				lFpas582	:= Alltrim(CTT->CTT_FPAS) == '582'
				If Type("CTT_PEREMP") # "U"		
					nPercEmp    := CTT->CTT_PEREMP / 100
				EndIf
			EndIf
			
			If nPercFPAS > 0
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Deducao do percentual pago por convenios                    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nDed := 0
				For nPerc = 9 TO 19
					nDed += aInssEmp[nPerc,Val(cTpc)]
				Next
				
				nDed += aInssEmp[22,Val(cTpc)]
				nDed += aInssEmp[23,Val(cTpc)]
				nDed += fP15Terc(SRA->RA_CC,aGPSPer,"*") //Deduzir o % de terceiros do parametro 15
			
				nPercFPAS -= nDed
				If nPercFPAS < 0
					nPercFPAS 	:= nPercCC
					lPercCC		:= .T.
				EndIf
			ElseIf !lFpas582
				nPercFPAS := aInssemp[2, Val(cTpc)]
			EndIf
			
			//-- Calcular Inss Empresa
			If !SRA->RA_CATFUNC $ "AP" 
			
				If lRescDis 
					nIdDiss		:= 943 // INSS Empresa Dissidio
					nIdTerc		:= 944
					nIdSalEdu	:= 959
					nIdIncra	:= 946
					nIdSenai	:= 947
					nIdSesi		:= 948
					nIdSenac	:= 949
					nIdSesc		:= 950
					nIdSebrae	:= 951
					nIdDpc		:= 952
					nIdFaer		:= 953
					nIdSenar	:= 954
					nIdSeconc	:= 955
					nIdSest		:= 956
					nIdSenat	:= 957
					nIdSescoop	:= 958
					nIdAdSenai 	:= 1396
				Else 
					nIdDiss		:= 148 // INSS EMPRESA
					nIdTerc		:= 149
					nIdSalEdu	:= 204
					nIdIncra	:= 184
					nIdSenai	:= 185
					nIdSesi		:= 186
					nIdSenac	:= 187
					nIdSesc		:= 188
					nIdSebrae	:= 189
					nIdDpc		:= 190
					nIdFaer		:= 191
					nIdSenar	:= 192
					nIdSeconc	:= 193
					nIdSest		:= 200
					nIdSenat	:= 201
					nIdSescoop	:= 782
					nIdAdSenai	:= 1395
				EndIf

				//Se recolhe INSS s/ faturamento, chama fPerFatEmp p/ verificar os faturamentos na competencia
				//e, se for o caso, alterar a aliquota de calculo da contribuicao previdenciaria, ou,
				//nao gera a verba de INSS Empresa
				nRetFDes := (aScan( aPd,{|X| x[1] == aCodFol[1385,1]} ))
				If (cRecFatEmp $ "S*M*C" .And. ( Empty(cOneFol) .Or. cPeriodo <= cOneFol ) ) .Or. ( !Empty(cOneFol) .And. cPeriodo > cOneFol .And. SubStr(cOneFol,1,4) == SubStr(cPeriodo,1,4) .And. (nRetFdes > 0 .Or. lOnera ) )
					
					If lComplDis //complemento de 13 no dissidio
						//calcula %empresa 13
						cTpRotAnt := cTipoRot
						cTipoRot := "6" //altera temporariamente o tipo do roteiro de calculo para correta carga da tabela S033
						aTabS033 := {}
						fCarrTab( @aTabS033, "S033", If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]), .T. )
						aEval(aPd,{ |x| nComplB13 += If ( X[1]$ AcodFol[19,1]+"/"+aCodFol[20,1] .And. x[9] # "D",x[5],0.00) }) //base para complemento 13
						nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]),.T. )[5]
						nComplEmp13 := Round(nComplB13 * nPerFatEmp, 2)

						//calcula %empresa Fol
						cTipoRot = "1"
						aTabS033 := {}
						fCarrTab( @aTabS033, "S033", If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]), .T. )
						aEval(aPd,{ |x| nComplBFol += If ( X[1]$ aCodFol[13,1]+"/"+aCodFol[14,1] .And. x[9] # "D",x[5],0.00) }) //base para complemento fol
						nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]) )[1]
						nComplEmpFol := Round(nComplBFol * nPerFatEmp, 2)
						
						fMatriz(aCodfol[nIdDiss,1], nComplEmp13 + nComplEmpFol)   // Empresa
						aAdd(aEncDCTF, {aCodfol[nIdDiss, 1], nPerFatEmp})
						nPerFatEmp := 0

						cTipoRot := cTpRotAnt
					Else
						If lTabS033 .And. (lRotDiss .Or. lResComDis)
							//Chama fCarrTab para recarregar tabela auxiliar S033
							aTabS033 := {}
							fCarrTab( @aTabS033, "S033", If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]), .T. )
						EndIf
						//Para a rescisao, folha e 13 salario, deve-se fazer o processo separadamente, pois o imposto da contribuicao
						//patronal da parte empresa sera calculada na rotina GPEM013
						If (lRotDiss .Or. lResComDis) .And. lInssAut .And. (( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "1" $ cEncResExt ))
							If cTipoRot == "6" //SE 132
								nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]),.T. )[5]
							Else
								nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]) )[1]
							EndIf
							If nPerFatEmp > 0
								nBasEncarg := nValBasInss
								If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMP
									nBasEncarg -= nValAux
								EndIf
								If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMPAF
									nBasEncarg -= nValAuxAf
								EndIf
								fMatriz(aCodfol[nIdDiss,1], Round(nBasEncarg * nPerFatEmp, 2))   // Empresa
								aAdd(aEncDCTF, {aCodfol[nIdDiss, 1], nPerFatEmp})
								//Se não for rescisão do próximo mês.
								If lRescDis .And. !lProxMes
									fMatriz(aCodfol[148,1], Round(nBaseMes * nPerFatEmp, 2))   // Empresa
									aAdd(aEncDCTF, {aCodfol[148, 1], nPerFatEmp})
								EndIf
							EndIf
						ElseIf nRetFDes > 0 .And. (cTipoRot $ "4/6")
							aEval(aPd,{ |x| nComplB13 += If ( X[1]$ AcodFol[1385,1] .And. x[9] # "D",x[5],0.00) }) //base para complemento 13
							
							aTabS033 := {}
							cBkpRot := cTipoRot 
							cTipoRot := "6" 
							fCarrTab( @aTabS033, "S033", If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]), .T. )
							
							nPosOnera := Ascan(aTabS033, { |X| X[6] == "2" })
							If nPosOnera > 0
								cRecFatEmp := "oM"
							Else
								cRecFatEmp := "oS"
							Endif			
							
							nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]),.T. )[5]
							cTipoRot := cBkpRot 
							
							If cRecFatEmp == "oM"
								nComplEmp13 := Round(nComplB13 * nPerFatEmp, 2)
							EndIf
							nComplEmpFol := Round((nValBasInss - nComplB13 ) * aInssEmp[1, Val(cTpc)], 2)
							nBasEncarg := nComplEmpFol + nComplEmp13
							If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMP
								nBasEncarg -= nValAux
							EndIf
							If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMPAF
								nBasEncarg -= nValAuxAf
							EndIf
							fMatriz(aCodfol[nIdDiss,1], Round(nBasEncarg,2),,,,,,,,,lComplFol)		// Empresa
							aAdd(aEncDCTF, {aCodfol[nIdDiss, 1], nPerFatEmp})
						EndIf
					EndIf
				Else
					// Calculo de Complemento de 13 na Folha
					If lInssAut .And. (( !lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "1" $ cEncResExt ))
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodfol[nIdDiss,1], Round(nBasEncarg * If (nPercEmp > 0, nPercEmp, aInssEmp[1, Val(cTpc)]), 2),,,,,,,,,lComplFol)		// Empresa
						aAdd(aEncDCTF, {aCodfol[nIdDiss, 1], If (nPercEmp > 0, nPercEmp, aInssEmp[1, Val(cTpc)])})
						If lRescDis .And. !lProxMes
							fMatriz(aCodfol[148,1], Round(nBaseMes * If (nPercEmp > 0, nPercEmp, aInssEmp[1, Val(cTpc)]), 2),,,,,,,,,lComplFol)		// Empresa
							aAdd(aEncDCTF, {aCodfol[148, 1], If (nPercEmp > 0, nPercEmp, aInssEmp[1, Val(cTpc)])})
						EndIf
					EndIf
				EndIf

				If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "4" $ cEncResExt )
					nBasEncarg := nValBasInss
					If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdTerc, 1] $ P_ENCEMP
						nBasEncarg -= nValAux
					EndIf
					If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdTerc, 1] $ P_ENCEMPAF
						nBasEncarg -= nValAuxAf
					EndIf
					fMatriz(aCodFol[nIdTerc, 1], Round(nBasEncarg * nPercFPAS , 2))									// Terceiros
					aAdd(aEncDCTF, {aCodfol[nIdTerc, 1], nPercFPAS})
					//Verifica se não rescisão do próximo mês.
					If lRescDis .And. !lProxMes
						fMatriz(aCodFol[149, 1], Round(nBaseMes * nPercFPAS, 2))									// Terceiros
						aAdd(aEncDCTF, {aCodfol[149, 1], nPercFPAS})
					EndIf
				Endif
				If !lPercCC
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "5" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSalEdu, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSalEdu, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSalEdu, 1], Round(nBasEncarg * (aInssemp[09, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSalEdu, 1])), 2))	// Sal.Educ.
						aAdd(aEncDCTF, {aCodfol[nIdSalEdu, 1], (aInssemp[09, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSalEdu, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[204, 1], Round(nBaseMes * (aInssemp[09, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSalEdu, 1])), 2))	// Sal.Educ.
							aAdd(aEncDCTF, {aCodfol[204, 1], (aInssemp[09, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSalEdu, 1]))})
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "6" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdIncra, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdIncra, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdIncra, 1], Round(nBasEncarg * (aInssemp[10, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdIncra, 1])), 2))		// Incra
						aAdd(aEncDCTF, {aCodfol[nIdIncra, 1], (aInssemp[10, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdIncra, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[184, 1], Round(nBaseMes * (aInssemp[10, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdIncra, 1])), 2))		// Incra
							aAdd(aEncDCTF, {aCodfol[184, 1], (aInssemp[10, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdIncra, 1]))})
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "7" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSenai, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSenai, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSenai, 1], Round(nBasEncarg * (aInssemp[11, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenai, 1])), 2))		// Senai
						aAdd(aEncDCTF, {aCodfol[nIdSenai, 1], (aInssemp[11, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenai, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[185, 1], Round(nBaseMes * (aInssemp[11, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenai, 1])), 2))		// Senai
							aAdd(aEncDCTF, {aCodfol[185, 1], (aInssemp[11, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenai, 1]))})
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "8" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSesi, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSesi, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSesi, 1], Round(nBasEncarg * (aInssemp[12, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSesi, 1])), 2))		// Sesi
						aAdd(aEncDCTF, {aCodfol[nIdSesi, 1], (aInssemp[12, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSesi, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[186, 1], Round(nBaseMes * (aInssemp[12, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSesi, 1])), 2))		// Sesi
							aAdd(aEncDCTF, {aCodfol[186, 1], (aInssemp[12, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSesi, 1]))})
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "9" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSenac, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSenac, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSenac, 1], Round(nBasEncarg * (aInssemp[13, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenac, 1])), 2))		// Senac
						aAdd(aEncDCTF, {aCodfol[nIdSenac, 1], (aInssemp[13, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenac, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[187, 1], Round(nBaseMes * (aInssemp[13, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenac, 1])), 2))		// Senac
							aAdd(aEncDCTF, {aCodfol[187, 1], (aInssemp[13, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenac, 1]))})
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "A" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSesc, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSesc, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSesc, 1], Round(nBasEncarg * (aInssemp[14, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSesc, 1])), 2))		// Sesc
						aAdd(aEncDCTF, {aCodfol[nIdSesc, 1], (aInssemp[14, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSesc, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[188, 1], Round(nBaseMes * (aInssemp[14, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSesc, 1])), 2))		// Sesc
							aAdd(aEncDCTF, {aCodfol[188, 1], (aInssemp[14, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSesc, 1]))})
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "B" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSebrae, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSebrae, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSebrae, 1], Round(nBasEncarg * (aInssemp[15, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSebrae, 1])), 2))	// Sebrae
						aAdd(aEncDCTF, {aCodfol[nIdSebrae, 1], (aInssemp[15, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSebrae, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[189, 1], Round(nBaseMes * (aInssemp[15, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSebrae, 1])), 2))	// Sebrae
							aAdd(aEncDCTF, {aCodfol[189, 1], (aInssemp[15, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSebrae, 1]))})
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "C" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdDpc, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdDpc, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdDpc, 1], Round(nBasEncarg * (aInssemp[16, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdDpc, 1])), 2))			// Dpc
						aAdd(aEncDCTF, {aCodfol[nIdDpc, 1], (aInssemp[16, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdDpc, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[190, 1], Round(nBaseMes * (aInssemp[16, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdDpc, 1])), 2))			// Dpc
							aAdd(aEncDCTF, {aCodfol[190, 1], (aInssemp[16, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdDpc, 1]))})
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "D" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdFaer, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdFaer, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdFaer, 1], Round(nBasEncarg * (aInssemp[17, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdFaer, 1])), 2))		// Faer
						aAdd(aEncDCTF, {aCodfol[nIdFaer, 1], (aInssemp[17, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdFaer, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[191, 1], Round(nBaseMes * (aInssemp[17, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdFaer, 1])), 2))		// Faer
							aAdd(aEncDCTF, {aCodfol[191, 1], (aInssemp[17, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdFaer, 1]))})
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "E" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSenar, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSenar, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSenar, 1], Round(nBasEncarg * (aInssemp[18, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenar, 1])), 2))		// Senab
						aAdd(aEncDCTF, {aCodfol[nIdSenar, 1], (aInssemp[18, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenar, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[192, 1], Round(nBaseMes * (aInssemp[18, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenar, 1])), 2))		// Senab
							aAdd(aEncDCTF, {aCodfol[192, 1], (aInssemp[18, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenar, 1]))})
						EndIf 
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "F" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSeconc, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSeconc, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSeconc, 1], Round(nBasEncarg * (aInssemp[19, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSeconc, 1])), 2))	// Seconc
						aAdd(aEncDCTF, {aCodfol[nIdSeconc, 1], (aInssemp[19, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSeconc, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[193, 1], Round(nBaseMes * (aInssemp[19, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSeconc, 1])), 2))	// Seconc
							aAdd(aEncDCTF, {aCodfol[193, 1], (aInssemp[19, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSeconc, 1]))})
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "G" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSest, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSest, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSest, 1], Round(nBasEncarg * (aInssemp[22, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSest, 1])), 2))		// Sest
						aAdd(aEncDCTF, {aCodfol[nIdSest, 1], (aInssemp[22, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSest, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[200, 1], Round(nBaseMes * (aInssemp[22, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSest, 1])), 2))		// Sest
							aAdd(aEncDCTF, {aCodfol[200, 1], (aInssemp[22, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSest, 1]))})
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "H" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSenat, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSenat, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSenat, 1], Round(nBasEncarg * (aInssemp[23, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenat, 1])), 2))		// Senat
						aAdd(aEncDCTF, {aCodfol[nIdSenat, 1], (aInssemp[23, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenat, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[201, 1], Round(nBaseMes * (aInssemp[23, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenat, 1])), 2))		// Senat
							aAdd(aEncDCTF, {aCodfol[201, 1], (aInssemp[23, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenat, 1]))})
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "I" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSescoop, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAf) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSescoop, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSescoop, 1], Round(nBasEncarg * (aInssemp[26, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSescoop, 1])), 2))	// Sescoop
						aAdd(aEncDCTF, {aCodfol[nIdSescoop, 1], (aInssemp[26, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSescoop, 1]))})
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[782, 1], Round(nBaseMes * (aInssemp[26, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSescoop, 1])), 2))	// Sescoop
							aAdd(aEncDCTF, {aCodfol[782, 1], (aInssemp[26, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSescoop, 1]))})
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "J" $ cEncResExt )
						If Len(aCodFol) >= 1395 .And. Len(aInssemp) >= 30 .And. !Empty( aCodFol[nIdAdSenai,1] )
							nValSENAI := Round(nValBasInss * (aInssemp[11, Val(cTpc)]), 2)
							nValSENAI := Round(nValSENAI * (aInssemp[30, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdAdSenai, 1])), 2)
							nPerc := RetValSrv(aCodFol[nIdAdSenai, 1], SRA->RA_FILIAL,"RV_PERC")
							If nPerc != 0
								nValSENAI := nValSENAI * ( nPerc / 100 )
							EndIf
							nBasEncarg := nValSENAI
							If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdAdSenai, 1] $ P_ENCEMP
								nBasEncarg -= nValAux
							EndIf
							If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdAdSenai, 1] $ P_ENCEMPAF
								nBasEncarg -= nValAuxAf
							EndIf
							fMatriz(aCodFol[nIdAdSenai, 1], nBasEncarg,,,,,,,,,lComplFol)	// Senai 500 funcionarios
							aAdd(aEncDCTF, {aCodfol[nIdAdSenai, 1], nPerc})
							If lRescDis .And. !lProxMes
								nValSENAI := Round(nBaseMes * (aInssemp[11, Val(cTpc)]), 2)
								nValSENAI := Round(nValSENAI * (aInssemp[30, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[1395, 1])), 2)
								nPerc := RetValSrv(aCodFol[1395, 1], SRA->RA_FILIAL,"RV_PERC")
								If nPerc != 0
									nValSENAI := nValSENAI * ( nPerc / 100 )
								EndIf
								fMatriz(aCodFol[1395, 1], nValSENAI,,,,,,,,,lComplFol)	// Senai 500 funcionarios
								aAdd(aEncDCTF, {aCodfol[1395, 1], nPerc})
							EndIf
						EndIf
					Endif
				Endif
				If nValTer > 0 .And. Len(aBkpEmpSt) > 0
					aInssEmp  := aClone(aBkpEmpSt)
					aBkpEmpSt := {}
				EndIf
			EndIf
		EndIf
	Else
		//--Inss s/Prolabore e Autonomo

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calcula valor do Acidente de Trabalho (Aposent. Especial)   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If aScan( aPd,{|X| x[1] == aCodFol[150,1]} ) == 0 // Testa se ja existe
			fBuscaAci(@nPercAcTrab,,@lPercSRA)
			If nPercAcTrab > 0 .And. lPercSRA
				//--Monta Base de Inss
				aEval(aPd,{ |x| nBseProAut += If ( X[1]$ (aCodFol[217,1]+"x"+aCodFol[218,1] + If(lProLab, "x"+aCodFol[1430,1]+'x'+aCodFol[1431,1],"") + If(lAutCoo, "x"+aCodFol[1448,1],"")) .And. x[3] == cSemana .And. x[9] # "D",x[5],0.00) })
				If Len(aCodFol) > 1412
					aEval(aPd,{ |x| nBseProAut += If ( X[1]$ (aCodFol[1413,1]) .And. x[3] == cSemana .And. x[9] # "D",x[5],0.00) })
				Endif
				If nBseProAut > 0 .And. lEncPatro
					fMatriz(aCodfol[150,1],Round(nBseProAut * nPercAcTrab,2)) // Acidente Trabalho
					aAdd(aEncDCTF, {aCodfol[150, 1], nPercAcTrab})
				EndIf
			EndIf
		EndIf

		If !lContrVA .Or. (lContrVA .And. P_ENCARGVA)	
			If aCodFol[221,1] # Space(3) .Or. aCodFol[1384,1] # Space(3)	
				nValBasInss := 0
				If SRA->RA_CATEG $ "17|18"
					aEval(aPd,{ |x| nValBasInss += If ( X[1]$ AcodFol[1384,1] .And. x[3] == cSemana .And. x[9] # "D",x[5],0.00) })
				Else
					aEval(aPd,{ |x| nValBasInss += If ( X[1]$ AcodFol[221,1] .And. x[3] == cSemana .And. x[9] # "D",x[5],0.00) })
				Endif

				//Se for autonomo e empregador for pessoa física produtor rural, deve recolher INSS emrpesa mesmo que RA_INSSAUT esteja com "Não"
				If !lInssAut .And. nValBasInss == 0 .And. SubStr(SRA->RA_CATEFD, 1, 1) == "7" .And. SRA->RA_AUTMEI == "2"
					aInfoAux := {}
					If fInfo(@aInfoAux,SRA->RA_FILIAL)
						If aInfoAux[12] == "1" //M0_PRODRUR
							Aeval( aPd ,{ |X| SomaInc(X,4,@nValBasInss,,,,,,,aCodfol) })
						EndIf
					EndIf
				EndIf

				If lContrVA
					If nValBasInss > nLimiteVA
						nValBasInss := nValBasInss - nLimiteVA
					Else
						nValBasInss := 0
					EndIf
				EndIf
				//Se recolhe INSS s/ faturamento, chama fPerFatEmp p/ verificar os faturamentos na competencia
				//e, se for o caso, alterar a aliquota de calculo da contribuicao previdenciaria, ou,
				//nao gera a verba de INSS Empresa
				If (cRecFatEmp $ "S*M*C" .And. (cPeriodo <= cOneFol .Or. Empty(cOneFol) ))
					//Para a rescisao e folha, deve-se fazer o processo separadamente, pois o imposto da contribuicao
					//patronal da parte empresa sera calculada na rotina GPEM013   		
					If lTabS033 .And. lRotDiss
						//Chama fCarrTab para recarregar tabela auxiliar S033
						aTabS033 := {}
						fCarrTab( @aTabS033, "S033", dDatabase, .T. )
					EndIf
					//Para a rescisao, folha e 13 salario, deve-se fazer o processo separadamente, pois o imposto da contribuicao
					//patronal da parte empresa sera calculada na rotina GPEM013
					If lRotDiss .And. lEncPatro
						nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, dDatabase )[1]
						If nPerFatEmp > 0
							fMatriz(aCodfol[148,1], Round(nValBasInss * nPerFatEmp, 2))   // Empresa
							aAdd(aEncDCTF, {aCodfol[148, 1], nPerFatEmp})
						EndIf
					EndIf
				Else
					If SRA->RA_CATEG $ "17|18" .and. lEncPatro
						nPercPro := RetValSRV( aCodFol[1384,1],SRA->RA_FILIAL,"RV_PERC") / 100
						If nPercPro = 1.00 .Or. (nPercPro = 0.00 .And. aInssemp[1,Val(cTpc)] # 0.00)
							nPercPro := 0.15
						Endif
						fMatriz(aCodfol[148,1],Round(nValBasInss * nPercPro,2))   // Empresa
						aAdd(aEncDCTF, {aCodfol[148, 1], nPercPro})
					ElseIf lEncPatro
						nPercPro := RetValSRV( aCodFol[221,1],SRA->RA_FILIAL,"RV_PERC") / 100
						If nPercPro = 1.00 .Or. (nPercPro = 0.00 .And. aInssemp[1,Val(cTpc)] # 0.00)
							nPercPro := 0.20
						Endif
						fMatriz(aCodfol[148,1],Round(nValBasInss * nPercPro,2))   // Empresa
						aAdd(aEncDCTF, {aCodfol[148, 1], nPercPro})
					Endif
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Base INSS Ref. Servicos Prestados Pessoa Fisica e Juridica  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If aCodFol[350,1] # Space(3) .And. aCodFol[353,1] # Space(3)
				nValBasInss := nTotBseAut := 0
				aEval(aPd,{ |x| nValBasInss += If ( X[1]$ AcodFol[350,1] .And. x[9] # "D",x[5],0.00) })
				//Se recolhe INSS s/ faturamento, chama fPerFatEmp p/ verificar os faturamentos na competencia
				//e, se for o caso, alterar a aliquota de calculo da contribuicao previdenciaria, ou,
				//nao gera a verba de INSS Empresa
				
				If lContrVA
					If nValBasInss > nLimiteVA
						nValBasInss := nValBasInss - nLimiteVA
					Else
						nValBasInss := 0
					EndIf
				EndIf
				
				If cRecFatEmp $ "S*M*C"
					//Para a rescisao e folha, deve-se fazer o processo separadamente, pois o imposto da contribuicao
					//patronal da parte empresa sera calculada na rotina GPEM013     		
					If lTabS033 .And. lRotDiss
						//Chama fCarrTab para recarregar tabela auxiliar S033
						aTabS033 := {}
						fCarrTab( @aTabS033, "S033", dDatabase, .T. )
					EndIf
					//Para a rescisao, folha e 13 salario, deve-se fazer o processo separadamente, pois o imposto da contribuicao
					//patronal da parte empresa sera calculada na rotina GPEM013
					If lRotDiss
						nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, dDatabase )[1]
						If nPerFatEmp > 0
							nTotBseAut  := Round(nValBasInss * nPerFatEmp,2)
						EndIf
					EndIf
				Else
					nPercAut	 := RetValSRV( aCodFol[350,1],SRA->RA_FILIAL,"RV_PERC") / 100
					If nPercAut = 1.00 .Or. (nPercAut = 0.00  .And. aInssemp[1,Val(cTpc)] # 0.00)
						nPercAut := 0.20
					EndIf
					nTotBseAut  := Round(nValBasInss * nPercAut,2)
				EndIf

				nValBasInss := 0

				aEval(aPd,{ |x| nValBasInss += If ( X[1]$ AcodFol[353,1] .And. x[9] # "D",x[5],0.00) })
				If lContrVA
					If nValBasInss > nLimiteVA
						nValBasInss := nValBasInss - nLimiteVA
					Else
						nValBasInss := 0
					EndIf
				EndIf
				//Se recolhe INSS s/ faturamento, chama fPerFatEmp p/ verificar os faturamentos na competencia
				//e, se for o caso, alterar a aliquota de calculo da contribuicao previdenciaria, ou,
				//nao gera a verba de INSS Empresa
				If cRecFatEmp $ "S*M*C"
					//Para a rescisao e folha, deve-se fazer o processo separadamente, pois o imposto da contribuicao
					//patronal da parte empresa sera calculada na rotina GPEM013 
					If lTabS033 .And. lRotDiss
						//Chama fCarrTab para recarregar tabela auxiliar S033
						aTabS033 := {}
						fCarrTab( @aTabS033, "S033", cRecFatEmp, .T. )
					EndIf
					//Para a rescisao, folha e 13 salario, deve-se fazer o processo separadamente, pois o imposto da contribuicao
					//patronal da parte empresa sera calculada na rotina GPEM013
					If lRotDiss
						nPerFatEmp := fPerFatEmp( SRA->RA_FILIAL, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, dDatabase )[1]
						If nPerFatEmp > 0
							nTotBseAut  := Round(nValBasInss * nPerFatEmp,2)
						EndIf
					EndIf
				Else
					nPercAut	 := RetValSRV( aCodFol[353,1],SRA->RA_FILIAL,"RV_PERC") / 100
					If nPercAut = 1.00 .Or. (nPercAut = 0.00  .And. aInssemp[1,Val(cTpc)] # 0.00)
						nPercAut := 0.20
					EndIf
					nTotBseAut  += Round(nValBasInss * nPercAut,2)
				EndIf
				If lEncPatro
					fMatriz(aCodfol[148,1],nTotBseAut)		// Empresa
					aAdd(aEncDCTF, {aCodfol[148, 1], If(cRecFatEmp $ "S*M*C",nPerFatEmp,nPercPro)})
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

//-- Calculo do Pis Empresa
If aCodFol[229,1] # Space(3) .And. !lContrVA
	aEval(aPd,{ |x| nBasePis += If ( RetValSrv(X[1],SRA->RA_FILIAL,"RV_PIS")=="S" .and. RetValSrv(X[1],SRA->RA_FILIAL,"RV_TIPOCOD")$"1*3" .and. x[3] == cSemana .And. x[9] # "D" ,x[5],0.00) })
	aEval(aPd,{ |x| nBasePis -= If ( RetValSrv(X[1],SRA->RA_FILIAL,"RV_PIS")=="S" .and. RetValSrv(X[1],SRA->RA_FILIAL,"RV_TIPOCOD")$"2"  .and. x[3] == cSemana .And. x[9] # "D" ,x[5],0.00) })
	If nBasePis > 0
		If Type("nBasPIS13") <> "U"
			// Verifica se existe a verba de base de PIS na SRD do roteiro 131, se for o calculo do roteiro 132
			If cTipoRot == "6" .And. cRot != fGetRotOrdinar()
				fBuscaAcmPer(aCodFol[223,1],,"V",@nBasPIS13,,AnoMes(sToD(StrZero(Year(dDataRef), 4)+"0101")),AnoMes(sToD(StrZero(Year(dDataRef), 4)+"1231")),,,"131")
				If nBasPIS13 == 0 .And. aScan( aPd, { |x| x[1] == aCodFol[183, 1] .And. x[9] != "D" } ) > 0 .And. RetValSrv(aCodFol[22, 1] ,SRA->RA_FILIAL, "RV_PIS") == "S"
					fBuscaAcmPer(aCodFol[22,1],,"V",@nBasPIS13,,AnoMes(sToD(StrZero(Year(dDataRef), 4)+"0101")),AnoMes(sToD(StrZero(Year(dDataRef), 4)+"1231")),,,"FOL")
				EndIf
				If nBasPIS13 > 0
					nBasePis -= nBasPIS13
				EndIf
			EndIf
		EndIf
 		
		nPercPis  := RetValSrv( aCodFol[229,1],SRA->RA_FILIAL,"RV_PERC") / 100
    	fMatriz(aCodfol[229,1],Round(nBasePis * nPercPis,2))   // PIS
		aAdd(aEncDCTF, {aCodfol[229, 1], nPercPis})
    	if aCodFol[223,1] # Space(3)
	    	fMatriz(aCodfol[223,1],nBasePis)   // BASE PIS
	    EndIf
	EndIf
EndIf

If !(lGestPubl .AND. SRA->RA_REGIME == '2') .And. !lContrVA .And. !lRot131 //Folha Privada
	// Montar Base Para Provisao Simplificada Ferias /  13o / Rescisao
	If aCodFol[194,1] # Space(3) .Or. aCodFol[195,1] # Space(3) .Or. aCodFol[196,1] # Space(3)
		aEval(aPd,{ |x| nValCus += If ( RetValSrv(X[1],SRA->RA_FILIAL,"RV_CUSTO")=="S" .and. RetValSrv(X[1],SRA->RA_FILIAL,"RV_TIPOCOD")$"1*3" .and. x[3] == cSemana .And. x[9] # "D" ,x[5],0.00) })
		aEval(aPd,{ |x| nValCus -= If ( RetValSrv(X[1],SRA->RA_FILIAL,"RV_CUSTO")=="S" .and. RetValSrv(X[1],SRA->RA_FILIAL,"RV_TIPOCOD")$"2"  .and. x[3] == cSemana .And. x[9] # "D" ,x[5],0.00) })

		// Calcular Provisao Simplificada
		If nValCus > 0.00
			fMatriz(aCodFol[194,1],Round(nValCus * aInssemp[6,Val(cTpc)],2))  // Prov. Ferias
			aAdd(aEncDCTF, {aCodfol[194, 1], aInssemp[6,Val(cTpc)]})
			fMatriz(aCodFol[195,1],Round(nValCus * aInssemp[5,Val(cTpc)],2))  // Prov. 13o.
			aAdd(aEncDCTF, {aCodfol[195, 1], aInssemp[5,Val(cTpc)]})
			fMatriz(aCodFol[196,1],Round(nValCus * aInssemp[20,Val(cTpc)],2))  // Prov. Rescisao
			aAdd(aEncDCTF, {aCodfol[196, 1], aInssemp[20,Val(cTpc)]})
		EndIf
	EndIf
EndIf

// Se foi Dissidio e cFolMes continha o Mes/Ano do Calculo de Dissidio, deve ZERAR tabelas Encargos (Param 14), pois 
// as vars foram utilizadas de acordo com o Mes/Ano do Calculo do Dissidio. Esta acao eh p/ nao correr risco de ficar
// com tabela com os percentuais de meses divergentes do necessario para o proximo calculo.
If lDissidio
	aInssEmpSt	:= Nil
	aInssEmp	:= Nil
	aInssEmpOld := Nil
EndIf

RestArea( aArea )
Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCInssAut ³ Autor ³ Renata                ³ Data ³ 01.09.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao para Calcular I.N.S.S. Autonomo                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Calc_Inss(aInss)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCInssAut(aCodfol,aTinss,lTrunca)

Local nBaseCalc 	:= 0
Local nTetoIns		:= 0
Local nBaseAux		:= 0
Local nBsSemAnt		:= 0
Local nDescAnt		:= 0
Local nDescOut      := 0
Local nPos          := 0

nSalC_c		:= If( Type("nSalC_c") 		== "U"	, 0.00, nSalC_c)
lInssAut	:= If( Type("lInssAut") 	== "U"	, .T., lInssAut)

DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

// Para os casos em que o funcionário não é autonomo, pode haver acordo
// Entre o Brasil e outros paises, para o não desconto do INSS.
// Para tratar esses acordos o campo RA_INSSAUT é utilizad.
// Se estiver com NÃO, NÃO deverá calcular INSS, independente do RA_CATFUNC.
If cPaisLoc == "BRA" .and. (!lInssAut)
	Return
EndIf

lTrunca 	:= If (lTrunca = Nil , .T. , lTrunca)
	
nTetoIns := aTinss[Len(aTinss),1]

IF SRA->RA_TIPOPGT == "S" .and. cSemana > '01'
	AEval( aPd, { |X| nBsSemAnt += Iif( X[1] == aCodFol[221, 1] .And. X[3] < cSemana .And. X[9] <> "D", X[5], 0 ) } )
    AEval( aPd, { |X| nDescAnt += Iif( X[1] == aCodFol[064, 1] .And. X[3] < cSemana .And. X[9] <> "D", X[5], 0 ) } )
EndIf

If nVlBsOut > 0
	If SRA->RA_CATEG $ "17|18"
		nBaseCalc := nSalC_c + nBsSemAnt
	Else
		nBaseCalc := nSalC_b + nBsSemAnt
	EndIf

	If (nVlBsOut + nBaseCalc) > nTetoIns
		nBaseAux  := nTetoIns - nVlBsOut
		nVInssAut := If( lTrunca, NoRound(nBaseAux * P_PERCAUTO, 2), Round(nBaseAux * P_PERCAUTO, 2) )
	Else
		nVInssAut	:= If( lTrunca, NoRound(nBaseCalc * P_PERCAUTO, 2), Round(nBaseCalc * P_PERCAUTO, 2) )
	EndIf
	If __lMemCalc
		fAddMemLog("Base do cálculo outros vínculos: R$ " + AllTrim(Transform(nVlBsOut, "@E 999,999,999,999.99" )), 1, 2)
		nPos     := aScan(aPd,{|x| x[1] == aCodFol[0289, 1]})	
		nDescOut := aPd[nPos, 5] 	
		fAddMemLog("Valor do desconto outros vínculos: R$ " + AllTrim(Transform(nDescOut, "@E 999,999,999,999.99" )), 1, 2)
	EndIf
Else
	If SRA->RA_CATEG $ "17|18"
		nBaseCalc := Min(nSalC_c, aTinss[Len(aTinss),1])
	Else
		nBaseCalc := Min(nSalC_b, aTinss[Len(aTinss),1])
	EndIf

    nBaseCalc += nBsSemAnt	
	nVInssAut := Iif( lTrunca, NoRound(nBaseCalc * P_PERCAUTO, 2), Round(nBaseCalc * P_PERCAUTO, 2) ) - nDescAnt
	
EndIf
If __lMemCalc		
	fAddMemLog("Base do cálculo: R$ " + AllTrim(Transform( If( nBaseAux > 0, nBaseAux, nBaseCalc), "@E 999,999,999,999.99" )), 1, 2)
	fAddMemLog("P_PERCAUTO: " + cvaltochar(P_PERCAUTO) + " ("+ retRcaDes("P_PERCAUTO")+")" , 1, 2)
	fAddMemLog("Cálculo do INSS: R$ "+ AllTrim(Transform( If( nBaseAux > 0, nBaseAux, nBaseCalc), "@E 999,999,999,999.99" )) + " * "+cvaltochar(P_PERCAUTO), 1, 2) 
	fAddMemLog("Valor do desconto do INSS: R$ "+AllTrim(Transform(nVInssAut, "@E 999,999,999,999.99" )), 1, 2) 								
EndIf
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPEXFUN1  ºAutor  ³Microsiga           º Data ³  07/25/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna o indicador de Base de Calculo para a previdencia   º±±
±±º          ³social, utilizado no MANAD.                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GPEVerTpBase(cCampo,lTabSrv)
Local aAreaSRD:= {}
Local cTpBase := "9" //outras bases de calculo
Local cAlias  := "SRV"
Local lCodFol := .T.
Local lResDisINSS	:= .F.
Local lRsCplDis		:= .T.
Local cQueryAlias	:= ""

DEFAULT lTabSrv := .F.

#IFDEF TOP
	If !lTabSrv
		cAlias := "SRD"
	Else
		cAlias := "SRV"
	EndIf
#ENDIF

lCodFol := IIF(len((cAlias)->RV_CODFOL) == 4,.T.,.F.)

If lTabSrv
	//PosSrv(SRD->RD_PD,SRA->RA_FILIAL)
	SRV->(MsSeek (xFilial("SRV",SRA->RA_FILIAL)+SRD->RD_PD ))
EndIf

If cCampo == "BIRRF"
    If (cAlias)->RV_CODFOL $ Iif(lCodFol, "0073/0076/0078/0083/0344/0346/0637", "073/076/078/083/344/346/637")	//Refere-se a ferias, 1/3 ferias mes seguinte e medias mes seguinte
	    cTpBase := "1"
	ElseIf (cAlias)->RV_CODFOL == Iif( lCodFol, "0007", "007" ) 	//Refere-se a adiantamento
	    cTpBase := "3"	
	ElseIf SRD->RD_IR == "S" .AND. !(SRD->RD_ROTEIR $ "131*132") .And. (cAlias)->RV_TIPOCOD != "3" //Base de calculo salario mensal
		cTpBase := "1"
	ElseIf SRD->RD_IR == "S" .AND. SRD->RD_ROTEIR == "132" .And. (cAlias)->RV_TIPOCOD != "3"// Base de calculo 130 salario
		cTpBase := "2"
	ElseIf SRD->RD_IR # "S" .Or. SRD->RD_ROTEIR $ "131"//Nao e base de calculo
		cTpBase := "3"
	EndIf
	
	//Se a verba for de PLR, trata como outro tipo de base de calculo
	If (cAlias)->RV_CODFOL = Iif(lCodFol,'0151','151') .and. SRD->RD_DATARQ >= "201301" 	//Verba de PLR
		cTpBase := "9"
	Endif
	//Se a verba incidir para IRRF e nao tiver Id de Calculo, verificar se trata-se de pensao
	If SRD->RD_IR == "S" .And. Empty( (cAlias)->RV_CODFOL )
		//Procura a existencia da verba como pensao nos beneficiarios
		cTpBase := fBusPensao( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, SRD->RD_PD, cTpBase )
	Endif
	//Se a verba for de deducao de pensao, altera o flag para incidir para IRRF pois verba sempre deduz da base de IR
	If (cAlias)->RV_CODFOL == Iif(lCodFol, '0057', '057')//Base Pensao Alimentica Folha Ded I.R.
		cTpBase := "1"
	EndIf
	//Se a verba incidir para IRRF ou for parte da base de cálculo, verifica se ha insuficiencia de saldo
    If SRD->RD_IR == "S" .Or. cTpBase $ "1*2"
		aAreaSRD := SRD->( GetArea() )
		//Procura a existencia da verba de Id 045 - Insuficiencia de saldo e 015 - Base IR
		if fBusIns(SRD->RD_FILIAL,SRD->RD_MAT,SRD->RD_DATARQ,_aTotal[013, 045, 1]) .And. !fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 015, 1] )
			cTpBase := "3"
		Endif
		RestArea( aAreaSRD )
	EndIf
	//Se a verba incidir para IRRF, for parte da base de cálculo e nao for da 2a. parcela do 13o., verifica se ha Base de IRRF ou se o pagamento da verba ocorreu na mesma competencia da rescisao
    If SRD->RD_IR == "S" .And. cTpBase == "1" .And. !(fTipo2RD( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, SRD->RD_PD ) $ "S*K")
		aAreaSRD := SRD->( GetArea() )
		//Se nao existir a verba de Id 0015 - Base IRRF ou
		//se o flag nao for de Ferias, houver pagamento de Rescisao e a competencia de pagamento for difente do pagamento da Rescisao
		If !fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 015, 1] ) .Or. ( fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 126, 1] ) .And. AnoMes( fDatPgt( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, SRD->RD_PD ) ) != AnoMes( fDatPgt( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 126, 1] ) ) )
			cTpBase := "3"
		EndIf
		RestArea( aAreaSRD )
	EndIf
	//Se for a verba de Base IR Mes Anterior e for regime caixa, verifica se a verba entrou na base de IRRF da Folha
	If (cAlias)->RV_CODFOL = Iif(lCodFol, '0106', '106') .And. RetValSRV(_aTotal[013, 006, 1], SRD->RD_FILIAL, "RV_IR") == "S"//Base IR Mes Anterior##Adiantamento
		aAreaSRD := SRD->( GetArea() )
		//Procura a existencia da verba de Id 0126 - Liquido pago na Rescisao, de Id 0015 - Base IRRF Folha, de Id 0010 - Base IR Adiantamento e de Id 0340 - Valor INSS Diferenca Dissidio. Rescisao tem que ser paga na mesma competencia da verba de Id 0106
		If fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 126, 1] ) .And. ( AnoMes( fDatPgt( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 126, 1] ) ) == SRD->RD_DATARQ ).And. fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 015, 1] ) .And. !fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 010, 1] ) .And. !fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 340, 1] )
			cTpBase := "1"//Base de calculo salario mensal
		Else
			cTpBase := "3"//Nao e base de calculo
		Endif
		RestArea( aAreaSRD )	
	EndIf 
	//Se a verba incidir para IRRF e for as verbas de Comissao, verifica se ha base de IR
    If SRD->RD_IR == "S" .And. (cAlias)->RV_CODFOL $ Iif(lCodFol, "0165/0166", "165/166")//Comissao##DSR Comissao
		aAreaSRD := SRD->( GetArea() )
		//Procura a existencia das verbas dos Ids 015/027 - Base Imposto de Renda/Base Imposto de Renda 13o.
		if !fBusIns(SRD->RD_FILIAL,SRD->RD_MAT,SRD->RD_DATARQ,_aTotal[013, 015, 1]) .And. !fBusIns(SRD->RD_FILIAL,SRD->RD_MAT,SRD->RD_DATARQ,_aTotal[013, 027, 1])
			cTpBase := "3"
		Endif
		RestArea( aAreaSRD )
	EndIf
	//Se a verba de INSS incidir para IRRF nao e base de calculo
    If SRD->RD_IR == "S" .And. (cAlias)->RV_CODFOL $ Iif(lCodFol, "0064/0065/0070", "064/065/070")//INSS Folha, Ferias e 13o
		If (cAlias)->RV_CODFOL != Iif(lCodFol, "0065", "065")//INSS Ferias
			cTpBase := "3"
		Else
			//Procura a existencia da verba de Id 0100 - Cod Dif. Base I.R Ferias 
			If !fBusIns(SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 100, 1])
				cTpBase := "3"
			Endif 
		EndIf
	EndIf

ElseIf cCampo == "BINSS"
	If SRD->RD_INSS == "S" .And. !(SRD->RD_ROTEIR $ "131*132") .AND. (cAlias)->RV_TIPOCOD#"2"//Base de calculo de contribuicao mensal
		cTpBase := "1"
	ElseIf SRD->RD_INSS == "S" .And. SRD->RD_ROTEIR == "132" .AND. (cAlias)->RV_TIPOCOD#"2"//Base de calculo do 13 salario
		cTpBase := "2"
	EndIf

	If SRD->RD_INSS # "S" .AND. (cAlias)->RV_FGTS == "S" // base de calculo exclusiva do FGTS
		cTpBase := "6"
	ElseIf (cAlias)->RV_TIPOCOD =="2" .AND. SRD->RD_INSS == "S" .And. !(SRD->RD_ROTEIR $ "131") //Deducoes da base de calculo
		cTpBase := "7"
	ElseIf SRD->RD_INSS # "S" .Or. SRD->RD_ROTEIR $ "131"			// Nao e base de calculo
		cTpBase := "8"
	EndIf

	If (cAlias)->RV_CODFOL $ Iif(lCodFol,"0064/0065/0070","064/065/070") 	//Refere-se a vl descontado do segurado
		cTpBase := "3"
	ElseIf (cAlias)->RV_CODFOL $ Iif(lCodFol,"0034","034") 		//Refere-se a vl. pago de salario familia
		cTpBase := "4"
	ElseIf (cAlias)->RV_CODFOL == Iif(lCodFol,"0040","040")		//Base de calculo do salario maternidade
		cTpBase := "5"
	ElseIf (cAlias)->RV_CODFOL $ Iif(lCodFol,"0238/0247","238/247")		//Nao e base de calculo
		cTpBase := "8"
    EndIf
	
	//Se a verba incidir para INSS ou for parte da base de cálculo, verifica se há verba:
	// ID 0013 S.CONT LIMITE FOLHA - No caso de funcionário ativo e Folha de Pagamento
	// ID 0019 - S.CONT ATE LIM 13?  - No caso de 13º Salário
	// ID 0338 - BS INSS DIF. DISS  - No caso de funcionário demitido com Rescisão Complementar por Dissídio
	// ID 0399 - BS INSS DIF. DISS 13 - No caso de funcionário demitido com Rescisão Complementar por Dissídio
    If SRD->RD_INSS == "S" .Or. cTpBase = "1"
		aAreaSRD := SRD->( GetArea() )	
		If !Empty(SRA->RA_DEMISSA)
			cQueryAlias 	:= GetNextAlias()
			BeginSql alias cQueryAlias
				Select RG_FILIAL, RG_MAT, RG_PERIODO, RG_RESCDIS
				From %Table:SRG% SRG
				Where SRG.RG_FILIAL = %Exp: SRA->RA_FILIAL%  AND
					SRG.RG_MAT = %Exp: SRA->RA_MAT% AND
					SRG.RG_PERIODO = %Exp: SRD->RD_DATARQ% AND
					SRG.%NotDel% 			
			EndSql
			// Identifica se ocorreu Rescisão Complementar por Dissídio no Período
			If (cQueryAlias)->(!Eof())
				While  lRsCplDis .And. (cQueryAlias)->(!Eof()) .And. (cQueryAlias)->(RG_FILIAL+RG_MAT) == SRA->(RA_FILIAL+RA_MAT) .And. (cQueryAlias)->RG_PERIODO == SRD->RD_DATARQ
					If (cQueryAlias)->RG_RESCDIS == "2"
						lRsCplDis	:= .F.
						lResDisINSS := .T.						
					EndIf
					(cQueryAlias)->( dbSkip() )
				EndDo
			EndIf
			(cQueryAlias)->(DbCloseArea())	
		EndIf
		// Procura a existencia da verba de Id 013 - Base INSS ou Id 019 - Base INSS 13  ou Id 009 - Base INSS DISS ou
		// Id 0338 - Base INSS ou Id 0399 - Base INSS DISS 13 para Resc. Complementar por Dissídio
		if !fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, iif((cAlias)->RV_REF13=="S",If(lResDisINSS,399,019),If(lResDisINSS,338,013)), 1] )
			cTpBase := "8"
		Endif
		RestArea( aAreaSRD )
	EndIf

	//Estagiario nao tem desconto de INSS
	If SRA->RA_CATFUNC $ "E*G"
		cTpBase := "8"
	Endif

EndIf
Return( cTpBase )



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fInssResEx³ Autor ³ Claudinei Soares      ³ Data ³23/10/2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carregar variaveis para os calculos de IR e INSS  dos      ³±±
±±³          ³ funcionarios residentes no exterior.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fInssResEx()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fInssResEx()

Local aArea		:= GetArea()
Local nOrdRGE 	:= 0
Local cChRGE	:= ""

Local lRGEPpe	:= .F.
Local lRGEStat 	:= .F.
Local lRGECod  	:= .F.
Local lRGEEnc  	:= .F.
Local lRGECale 	:= .F.
Local lRGEDtAlt	:= .F.
Local lRGEPdSal	:= .F.
Local lRGETpRem	:= .F.

If cPaisLoc == "BRA"
	lRGEPpe		:= RGE->(ColumnPos( "RGE_PPE" )) > 0
	lRGEStat	:= RGE->(ColumnPos( "RGE_STATUS" )) > 0
	lRGECod 	:= RGE->(ColumnPos( "RGE_COD" )) > 0
	lRGEEnc 	:= RGE->(ColumnPos( "RGE_ENCARG" )) > 0
	lRGECale	:= RGE->(ColumnPos( "RGE_CALENC" )) > 0
	lRGEDtAlt	:= RGE->(ColumnPos( "RGE_DTALT" )) > 0
	lRGEPdSal	:= RGE->(ColumnPos( "RGE_PDSAL" )) > 0
	lRGETpRem	:= RGE->(ColumnPos( "RGE_TPREM" )) > 0
EndIf 

lInssAut 	:= If(SRA->RA_INSSAUT=="N",.F.,.T.)	
lResExt 	:= If(SRA->RA_RESEXT=="1",.T.,.F.)	
lAutMei 	:= If(SRA->RA_AUTMEI=="1" .and. SRA->RA_CATFUNC == "A",.T.,.F.)
P_lPPEAtiv	:= If( Type("P_lPPEAtiv")== "U", .F.	, P_lPPEAtiv)
lPPEFunc	:= If( Type("lPPEFunc")	== "U", .F.	, lPPEFunc)
dIniRGE		:= If( Type("dIniRGE") 	== "U", CtoD("//"), dIniRGE)
dFimRGE		:= If( Type("dFimRGE")	== "U", CtoD("//"), dFimRGE)

If lResExt .Or. P_lPPEAtiv
	aPPE := {}
	// Define ordem da tab. RGE (Hist. contrato) 
	nOrdRGE	:= RetOrdem( "RGE", "RGE_FILIAL+RGE_MAT+DTOS(RGE_DATAIN)+RGE_TIPOCO" )
	DbSelectArea( "RGE" )
	RGE->( DbSetOrder( nOrdRGE ) )						// RGE_FILIAL+RGE_MAT+DTOS(RGE_DATAIN)+RGE_TIPOCO
	RGE->( DbSeek( xFilial( "RGE" ) + SRA->RA_MAT ) )	// Verifica se ha algum contrato para o funcionario
	If Empty(RGE->RGE_DATAFI) .or. RGE->RGE_DATAFI >= dDataAte
		lIrResExt := RGE->RGE_DESCIR != "2"
		lDedInssEx := RGE->RGE_DEDINS == "1"
	EndIf
	// Utiliza o Percentual se o Contrato estiver dentro do MesAno de Calculo
	If ( MesAno( RGE->RGE_DATAIN ) <= MesAno( dDataBase ) ) .and. ;
		( Empty( RGE->RGE_DATAFI ) .or. MesAno( RGE->RGE_DATAFI ) >= MesAno( dDataBase ) )
		cPdSalExt  := Iif( lRGETpRem .And. lRGEPdSal .And. RGE->RGE_TPREM == "1", RGE->RGE_PDSAL, "")
		nPercIrRex := If(RGE->RGE_PERCIR == 0, 25, RGE->RGE_PERCIR)
	Endif
	If lRGEPpe
		While !Eof() .And. RGE->RGE_FILIAL+RGE->RGE_MAT == SRA->RA_FILIAL + SRA->RA_MAT
			aAdd(aPPE, { RGE->RGE_PPE, RGE->RGE_DATAIN, RGE->RGE_DATAFI, Iif( lRGECod, RGE->RGE_COD, "" ), Iif( lRGEStat, RGE->RGE_STATUS, "0" ), Iif( lRGEDtAlt, RGE->RGE_DTALT, cToD("//") ) })
			cChRGE:= RGE->RGE_FILIAL+RGE->RGE_MAT+DTOS(RGE_DATAIN)
			dbSkip()
		EndDo
		If LEN(aPPE)>0
			nPPE := LEN(aPPE)
			IF RGE->( DbSeek( cChRGE ) )	
				lPPEFunc  := If(aPPE[nPPE,1]=="1",.T.,.F.)
				If lPPEFUNC .And. lRGEStat
					lPPEFUNC :=  RGE->RGE_STATUS <> '1' //  0 ou Branco - Ativo ; 1 - Inativo
				EndIf
				dIniRGE  := RGE->RGE_DATAIN
				dFimRGE  := RGE->RGE_DATAFI
				If lRGECod
					cPPECOD	:= RGE->RGE_COD
				Else
					cPPECOD	:= ''
				EndIf
			Endif
		Endif
	Endif
		If lResExt .And. lRGEEnc
			lEncPatro := If(RGE->RGE_ENCARG == "2", .F., .T.)
			If lEncPatro .And. RGE->RGE_RESEXT == "1" .And. lRGECale
				cEncResExt := AllTrim(RGE->RGE_CALENC)
			Endif
		EndIf
	
	RestArea( aArea )
Endif

Return

/*/{Protheus.doc} RestXCIMP
Funcao que reinicializa variaveis estaticas
@author Allyson Mesashi
@since 08/06/2016
@version P12 R7
/*/
Function RestXCIMP()
	cFilInss   	:= ""
	aInssEmpSt 	:= {}
Return

/*/{Protheus.doc} fGerAutCar
Função que gera as verbas desmembradas do autônomo carreteiro
@author Allyson Mesashi
@since 13/09/2018
@version P12.1.17
/*/
Static Function fGerAutCar()

Local aRateio	:= {}
Local cTipo2	:= ""
Local cVerba	:= ""
Local nCont 	:= 0
Local nOption	:= 1
Local nPos 		:= 0
Local nVl1563	:= 0
Local nVl1564	:= 0
Local nVl1565	:= 0
Local nVlTotal	:= 0
Local nVlVerba	:= 0

//Guarda os valores das verbas de IDs 1563, 1564 e 1565
nVl1563 := fBuscaPd( aCodFol[1563, 1] )
nVl1564 := fBuscaPd( aCodFol[1564, 1] )
nVl1565 := fBuscaPd( aCodFol[1565, 1] )

//Monta matriz com CC, Item, CLVL e valor para rateio
For nCont := 1 To Len(aPd)
	If !(aPd[nCont, 1] $ aCodFol[1563, 1]+"/"+aCodFol[1564, 1]+"/"+aCodFol[1565, 1]) .And. RetValSrv( aPd[nCont, 1], SRA->RA_FILIAL, "RV_INSS" ) == "S" .And. RetValSrv( aPd[nCont, 1], SRA->RA_FILIAL, "RV_REFFER" ) == "N" .And. RetValSrv( aPd[nCont, 1], SRA->RA_FILIAL, "RV_REF13" ) == "N" .And. aPd[ncont, 3] == csemana
		If ( nPos := aScan( aRateio, { |x| x[1]+x[2]+x[3] == aPd[nCont, 2]+aPd[nCont, 13]+aPd[nCont, 14] } ) ) == 0
			aAdd( aRateio, { aPd[nCont, 2], aPd[nCont, 13], aPd[nCont, 14], aPd[nCont, 5] } )
			cTipo2 := aPd[nCont, 7]
		Else
			aRateio[nPos, 4] += aPd[nCont, 5]
		EndIf
	ElseIf aPd[nCont, 1] $ aCodFol[1563, 1]+"/"+aCodFol[1564, 1]+"/"+aCodFol[1565, 1]
		aPd[nCont, 9] := "D"
	EndIf
Next nCont

aEval( aRateio, { |x| nVlTotal += x[4] } )

//Faz a geração dos valores rateados
While nOption < 4
	If nOption == 1
		cVerba 	 := aCodFol[1563, 1]
		nVlVerba := nVl1563
	ElseIf nOption == 2
		cVerba 	 := aCodFol[1564, 1]
		nVlVerba := nVl1564
	Else
		cVerba	 := aCodFol[1565, 1]
		nVlVerba := nVl1565
	EndIf

	For nCont := 1 To Len(aRateio)
		FGeraVerba(cVerba, (aRateio[nCont, 4]/nVlTotal) * nVlVerba, Nil, Nil, aRateio[nCont, 1], Nil, cTipo2, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, aRateio[nCont, 2], aRateio[nCont, 3])
	Next nCont

	nOption++
EndDo

//Exclui verbas com incidência de INSS/IRRF
For nCont := 1 To Len(aPd)
	If !(aPd[nCont, 1] $ aCodFol[1563,1]+"|"+aCodFol[1564,1]) .And. RetValSrv( aPd[nCont, 1], SRA->RA_FILIAL, "RV_INSS" ) == "S" .And. RetValSrv( aPd[nCont, 1], SRA->RA_FILIAL, "RV_REFFER" ) == "N" .And. RetValSrv( aPd[nCont, 1], SRA->RA_FILIAL, "RV_REF13" ) == "N"
		aPd[nCont, 9] := "D"
	EndIf
Next nCont

Return


/*/{Protheus.doc} fBusInsFer
Função para buscar o INSS das férias descontado no cálculo das férias.
@author Henrique Ferreira
@since 29/03/2019
@version P12.1.17
/*/
Static Function fBusInsFer(dDtPg)

Local aAreaSRR := SRR->( GetArea() )
Local nValInss := 0

DbSelectArea("SRR")
DbSetOrder(5)

If SRR->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + dToS(dDtPg) + aCodFol[168,1]))
	nValInss := SRR->RR_VALOR
EndIf

RestArea(aAreaSRR)

Return nValInss

/*/{Protheus.doc} fGetPdSRC
Função para buscar o INSS das férias descontado no cálculo da folha.
@author Leandro Drumond
@since 14/08/2019
@version P12.1.17
/*/
Static Function fGetPdSRC(cPd)

Local cAliasQry := GetNextAlias()
Local cQuery	:= ""
Local nRet		:= 0	

cQuery := " SELECT RC_VALOR FROM " + RetSqlName("SRC")
cQuery += " WHERE "
cQuery += " RC_FILIAL = '" + SRA->RA_FILIAL + "' AND"
cQuery += " RC_MAT = '" + SRA->RA_MAT + "' AND"
cQuery += " RC_PROCES = '" + cProcesso + "' AND"
cQuery += " RC_PERIODO = '" + cPeriodo + "' AND"
cQuery += " RC_ROTEIR = '" + cRot + "' AND"
cQuery += " RC_SEMANA < '" + cSemana + "' AND"
cQuery += " RC_PD IN('" + cPd + "') AND" 
cQuery += " D_E_L_E_T_ = ' ' "

cQuery := ChangeQuery(cQuery)

DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)

While (cAliasQry)->( !Eof() )
	nRet += (cAliasQry)->RC_VALOR
	(cAliasQry)->( DbSkip() )
EndDo

(cAliasQry)->( DbCloseArea() )

Return nRet

/*/{Protheus.doc} fCInssFx
Gera as verbas de INSS por faixa
@author Leandro Drumond
@since 27/01/2020
@version P12.1.23
/*/
Function fCInssFx(aInssFx,aPdFx, cSeq)
Local nX 		:= 0
Local cNumSeq 	:= ""

DEFAULT cSeq := " "

For nX := 1 to Len(aInssFx)
	If !Empty(aPdFx[nX]) .and. aInssFx[nX,1] > 0
		If !Empty(cSeq)
			cNumSeq := RetValSRV(aPdFx[nX],SRA->RA_FILIAL,"RV_QTDLANC")
		EndIf
		If Empty(cSeq) .or. Val(cSeq) < Val(cNumSeq)
			fMatriz(aPdFx[nX], aInssFx[nX,1], aInssFx[nX,2],,,,,,,,,cSeq)
		EndIf		
	EndIf
Next nX

Return Nil

/*/{Protheus.doc} fRetTetIns
Retorna o teto do INSS de acordo com a tabela recebida
@author Julio Silva
@since 26/03/2020
@version P12.1.25
/*/
Function fRetTetIns(aTinss)

Local nX 		:= 0
Local nTetoInss := 0

If Len(aTInss) > 0
	If aTInss[1,4] == "S"
		For nX := 1 To Len(aTinss)
			nTetoInss += NoRound(If ( nX == 1, aTinss[nX,1] * aTinss[nX,2], (aTinss[nX,1] - aTinss[nX-1,1]) * aTinss[nX,2]), 2)
		Next nX
	else
		nTetoInss := NoRound(aTinss[Len(aTinss),1] * aTinss[Len(aTinss),2] , 2)
	EndIf
EndIf

Return nTetoInss

/*/{Protheus.doc} fCarPdMat
Carrega as verbas de maternidade
@author Leandro Drumond
@since 07/12/2020
@version P12.1.27
/*/
Function fCarPdMat( lSefip )

Local aRet		:= {}
Local cTmpAlias := GetNextAlias()
Local cFilSRV   := xFilial("SRV")
Local cVerbaMat := "% SRV.RV_INCCP IN('21','22')  %"
Local cExp		:= "%%"

Default lSefip	:= .F.

If lSefip
	cExp := "% AND SRV.RV_CODFOL NOT IN  ('1446','1447') %"
EndIf

BeginSql alias cTmpAlias
	SELECT SRV.RV_COD
	FROM %table:SRV% SRV 
	WHERE 
	%exp:cVerbaMat% AND SRV.D_E_L_E_T_= '' 
	AND SRV.RV_FILIAL = %exp:cFilSRV%
	AND SRV.RV_NATUREZ <> ' '
	AND SRV.RV_INSS = 'S'
	%exp:cExp%
EndSql

While !(cTmpAlias)->(Eof())
	aAdd(aRet,(cTmpAlias)->RV_COD)	
	(cTmpAlias)->(dbSkip())
EndDo

If !Empty(aRet)
	aAdd(aRet, fGetCodFol("0238"))
eNDiF

(cTmpAlias)->(dbCloseArea())

Return aRet

/*/{Protheus.doc} fCarPdAfa
Carrega as verbas de afastamento com incidência 15
@author Allyson Mesashi
@since 15/01/2021
@version P12.1.27
/*/
Function fCarPdAfa( cConfig )

Local aRet		:= {}
Local cTmpAlias := GetNextAlias()
Local cFilSRV   := xFilial("SRV")
Local cVerbaMat := "% SRV.RV_INCCP IN ('15')  %"

BeginSql alias cTmpAlias
	SELECT SRV.RV_COD
	FROM %table:SRV% SRV 
	WHERE 
	%exp:cVerbaMat% AND SRV.D_E_L_E_T_= '' 
	AND SRV.RV_FILIAL = %exp:cFilSRV%
	AND SRV.RV_NATUREZ <> ' '
	AND SRV.RV_INSS = 'S'
EndSql

While !(cTmpAlias)->(Eof())
	aAdd(aRet,(cTmpAlias)->RV_COD)	
	(cTmpAlias)->(dbSkip())
EndDo

(cTmpAlias)->(dbCloseArea())

Return aRet

/*/{Protheus.doc} fSomaIrMesAnt
Carrega as verbas do Ir de complementar no mesmo mês
@author Fernando Luis Guilherme
@since 17/12/2020
@version P12.1.27
/*/
Static Function fSomaIrMesAnt(cIRPlr, dDataHom, lMultV, dDataDem )
Local aAreaSRG := SRG -> (GetArea())
Local dDataH := Ctod("")

DEFAULT cIRPlr := ""

DbSelectArea ("SRG")
DbSetOrder(1)

If SRG->(dbSeek(xFilial("SRG",SRA->RA_FILIAL)+SRA->RA_MAT))
	while SRG->RG_FILIAL = SRA->RA_FILIAL .And. SRG->RG_MAT == SRA->RA_MAT  
		If SRG->RG_RESCDIS == "1" .And. MesAno(SRG->RG_DATAHOM) == MesAno(M->RG_DATAHOM) .And. AnoMes(dDataDem) != AnoMes(SRG->RG_DTGERAR)
			dDataH := SRG->RG_DTGERAR
		EndIf
		SRG->(DBSKIP())
	EndDo
Endif

If !Empty(dDataH) .And. MesAno(dDataH) < MesAno(M->RG_DATAHOM)
	Aeval( aPdResc ,{ |X| If(X[3] <= cSemana .And. !(X[1] $ cIRPlr) .and. (RetValSRV(X[1],SRA->RA_FILIAL,"RV_REFFER") == "N" .or. RetValSRV(X[1],SRA->RA_FILIAL,"RV_REFFER") == "") .and. MesAno(x[18]) == MesAno(dDataH) .and. MesAno(x[10]) == MesAno(dDataHom),SomaInc(X,5,@nIR_B,5,"S",12,"N",Month(dDataHom),,aCodFol,,,If(lMultV, .T. ,.F.)),NIL) } )
Endif

RestArea(aAreaSRG) //Restaurar SQG aqui porque faz uso do registro abaixo

// Verifica se teve adiantamento para abater da base do IR
If RetValSRV(aCodFol[007, 1], SRA->RA_FILIAL, "RV_IR" ) == "S"
    Aeval(aPdResc,{ |X| nIR_B -= If ( x[1] == aCodFol[007,1] .And. x[3] <= cSemana .and. AnoMes(x[18]) == AnoMes(dDataDem) .and. AnoMes(dDataHom) <> AnoMes(dDataDem) .And. AnoMes(x[10]) <> AnoMes(SRG->RG_DATAHOM) .And. SRG->RG_RESCDIS == "0" ,X[5] ,0)})
EndIf

Return

/*/{Protheus.doc} fVldCompaPd
Retira o valor das verbas com incidência para INSS, IR ou FGTS caso tenha complemento de 13º incluído manualmente
@author Allyson Mesashi
@since 29/01/2021
@version P12.1.27
/*/
Static Function fVldCompaPd()

Local nCont := 0

For nCont := 1 To Len(aPd)
	If !(aPd[nCont, 1] $ aCodFol[183, 1]+"/"+aCodFol[024, 1]+"/"+aCodFol[1435, 1]) .And. aPd[nCont, 7] != "I" .And. (RetValSrv(aPd[nCont, 1], SRA->RA_FILIAL, "RV_INSS") == "S" .Or. RetValSrv(aPd[nCont, 1], SRA->RA_FILIAL, "RV_IR") == "S" .Or. RetValSrv(aPd[nCont, 1], SRA->RA_FILIAL, "RV_FGTS") == "S")
		aPd[nCont, 5] := 0
	EndIf
Next nCont

Return

/*/{Protheus.doc} fVerPDDed
Verifica código de verbas referente a deduções no modelo completo do IR
@author Allyson Mesashi
@since 02/05/2023
/*/
Function fVerPDDed( cVerbDed, cRotCalc, aBenefs, lResExt )

Local aVerbas   := StrTokArr( P_DEDIRSIM, "/" )
Local aPdnDed   := StrTokArr( P_NDEDIRSI, "/" )
Local cRefFer 	:= ""
Local cRef13 	:= ""
Local nCont     := 0

If cRotCalc == "FOL"
    cVerbDed += Iif( RetValSRV( aCodFol[64, 1], SRA->RA_FILIAL, "RV_IR" ) == "S", aCodFol[64, 1], aCodFol[167, 1] ) + "/"//INSS
    If !Empty(aCodfol[215, 1]) .And. RetValSrv(aCodFol[215, 1], SRA->RA_FILIAL, "RV_IR") == "S" .And. !lResExt
        cVerbDed += aCodFol[215, 1] + "/"
    EndIf
    cVerbDed += Iif( RetValSRV( aCodFol[340, 1], SRA->RA_FILIAL, "RV_IR" ) == "S", aCodFol[340, 1], Space(3) ) + "/"//Valor INSS Diferenca Dissidio
ElseIf cRotCalc == "FER"
    cVerbDed += Iif( RetValSRV( aCodFol[65, 1], SRA->RA_FILIAL, "RV_IR" ) == "S", aCodFol[65, 1], aCodFol[168, 1] ) + "/" + Iif( RetValSRV( aCodFol[232, 1], SRA->RA_FILIAL, "RV_IR" ) == "S", aCodFol[232, 1], "" ) + "/"//INSS Ferias
    If !Empty(aCodfol[216, 1]) .And. RetValSrv(aCodFol[216, 1], SRA->RA_FILIAL, "RV_IR") == "S" .And. !lResExt
        cVerbDed += aCodFol[216, 1] + "/"
    EndIf
ElseIf cRotCalc == "132"
    cVerbDed += Iif( RetValSRV( aCodFol[70, 1], SRA->RA_FILIAL, "RV_IR" ) == "S", aCodFol[70, 1], aCodFol[169, 1] ) + "/"//INSS 13º
    If !Empty(aCodfol[302, 1]) .And. RetValSrv(aCodFol[302, 1], SRA->RA_FILIAL, "RV_IR") == "S" .And. !lResExt
        cVerbDed += aCodFol[302, 1] + "/"
    EndIf
    cVerbDed += Iif( RetValSRV( aCodFol[401, 1], SRA->RA_FILIAL, "RV_IR" ) == "S", aCodFol[401, 1], Space(3) ) + "/"//Valor INSS Diferenca Dissidio 13o
EndIf

For nCont := 1 To Len(aBenefs)
    cVerbDed += aBenefs[nCont, 1] + "/"//RQ_VERBADT|RQ_VERBFOL|RQ_VERBFER|RQ_VERB132
    cVerbDed += aBenefs[nCont, 8] + "/"//RQ_VERBPLR
Next nCont

If cRotCalc $ "FOL/132/FER"
    fVerS073( cRotCalc, @cVerbDed )
EndIf

//Verbas sem identificador de cálculo que não devem compor a base de IR simplificada
For nCont := 1 to Len(aPdnDed)
	If Empty(RetValSRV(aPdnDed[nCont], SRA->RA_FILIAL, "RV_CODFOL")) .and. RetValSRV( aPdnDed[nCont], SRA->RA_FILIAL, "RV_IR" ) == "S"
		cRefFer := RetValSRV(aPdnDed[nCont], SRA->RA_FILIAL, "RV_REFFER") 
		cRef13  := RetValSRV(aPdnDed[nCont], SRA->RA_FILIAL, "RV_REF13") 
		If ( ( cRotCalc == "FOL" .and. cRefFer <> "S" .and. cRef13 <> "S" ) .or. ;
			 ( cRotCalc == "FER" .and. cRefFer == "S" ) .or. ;
			 ( cRotCalc == "132" .and. cRef13 == "S" ) )
			cVerbDed += aPdnDed[nCont] + "/"
		EndIf
	EndIf
Next nCont

For nCont := 1 To Len(aVerbas)
    If RetValSRV( aVerbas[nCont], SRA->RA_FILIAL, "RV_IR" ) == "S" .And. RetValSRV( aVerbas[nCont], SRA->RA_FILIAL, "RV_TIPOCOD" ) $ "2/3/4" .And. aVerbas[nCont] $ cVerbDed 
        cVerbDed := StrTran( cVerbDed, aVerbas[nCont], Space(3) )
    EndIf
Next nCont

Return

/*/{Protheus.doc} fVerS073
Verifica configuração de previdência privade de verba sem ID vinculada nas tabelas SMU e S073
@author Allyson Mesashi
@since 24/05/2023
/*/
Static Function fVerS073( cRotCalc, cVerbDed )

Local aAreaSMU      := SMU->( GetArea() )
Local nPosS073      := 0

DEFAULT aTabS073    := {}
DEFAULT cFilS073    := ""

If SRA->RA_FILIAL != cFilS073
    aTabS073 := {}
    cFilS073 := SRA->RA_FILIAL
    fRetTab( @aTabS073, "S073", Nil, Nil, Nil, Nil, .T., Nil, .T. )
EndIf

SMU->( dbSetOrder(1) )//MU_FILIAL+MU_MAT+MU_CODFOR+MU_PERINI
If SMU->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT ) )
	While SMU->( !EoF() ) .And. SMU->MU_FILIAL+SMU->MU_MAT == SRA->RA_FILIAL+SRA->RA_MAT
		If cPeriodo >= SubStr( SMU->MU_PERINI, 3, 4)+SubStr( SMU->MU_PERINI, 1, 2) .And. If(!Empty(SMU->MU_PERFIM), cPeriodo <= SubStr( SMU->MU_PERFIM, 3, 4 )+SubStr( SMU->MU_PERFIM, 1, 2 ), .T.)
            If ( nPosS073 := aScan( aTabS073, { |x| x[5] == SMU->MU_CODFOR } ) ) > 0
				If RetValSRV( Iif( cRotCalc $ "FOL/FER", aTabS073[nPoss073, 10], aTabS073[nPoss073, 11] ), SRA->RA_FILIAL, "RV_IR" ) == "S"
                	cVerbDed += Iif( cRotCalc $ "FOL/FER", aTabS073[nPoss073, 10], aTabS073[nPoss073, 11] ) + "/"
				EndIf
            EndIf
		EndIf
		SMU->( dbSkip() )
	End
EndIf

RestArea( aAreaSMU )

Return

/*/{Protheus.doc} fDedPerAnt
Verifica o valor das deduções legais realizadas na folha no período anterior 
@author Allyson Mesashi
@since 22/05/2023
/*/
Static Function fDedPerAnt( lVerTribAnt, cModTribAnt, lValTribAnt )

Local aBenefs       := {}
Local aVerbasAnt    := {}
Local aPerAtual		:= {}
Local cPerAnt       := SubMesAno( cPeriodo )
Local cVerbDed      := ""
Local cSRCSeek 		:= ""
Local cVerbDep      := aCodFol[59, 1]
Local cPerFol 		:= ""
Local nCont         := 0
Local nValor        := 0
Local nValorDep     := 0
Local nValIrAnt		:= 0
Local nValIrOAnt	:= 0

DEFAULT cRotAut     := fGetCalcRot("9")
DEFAULT cRotFol     := fGetCalcRot("1")

fBusCadBenef( @aBenefs, "FOL", Nil, Nil, Nil, Nil, MonthSub(dDataAte, 1) )
fVerPDDed( @cVerbDed, "FOL", aBenefs, lResExt )

If lVerTribAnt
    cVerbDed += cVerbDep
EndIf

If lValTribAnt
    cVerbDed += aCodFol[15, 1] + "/" + aCodFol[1913, 1]
EndIf

If cTipoRot == "4"
	fGetPerAtual( @aPerAtual, xFilial("RCH", SRA->RA_FILIAL), SRA->RA_PROCES, Iif(SRA->RA_CATFUNC $ "A*P", cRotAut, cRotFol) )
	If !Empty(aPerAtual)
		cPerFol := aPerAtual[1, 1]
	EndIf
EndIf

If Empty(cPerFol) .or. cPerFol > cPerAnt
	aVerbasAnt := fBuscaAcmPer( cVerbDed, Nil, "V", 0, Nil, cPerAnt, cPerAnt, Nil, Nil, cRotFol+"/"+cRotAut, .T. )

	For nCont := 1 To Len(aVerbasAnt)
		If aVerbasAnt[nCont, 1] == aCodFol[15,1]
			nValIrAnt += aVerbasAnt[nCont,3]
		ElseIf aVerbasAnt[nCont, 1] == aCodFol[1913,1]
			nValIrOAnt += aVerbasAnt[nCont,3]
		Else
			If aVerbasAnt[nCont, 1] != cVerbDep
				nValor += aVerbasAnt[nCont, 3]
			Else
				nValorDep += aVerbasAnt[nCont, 3]
			EndIf
		EndIf
	Next nCont
Else
	
	DbSelectArea("SRC")
	DbSetOrder(RetOrder("SRC","RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA"))

	cSRCSeek := SRA->RA_FILIAL + SRA->RA_MAT + SRA->RA_PROCES + Iif(SRA->RA_CATFUNC $ "A*P", cRotAut, cRotFol) + cPerAnt

	If DbSeek( cSRCSeek )	
		While SRC->(!Eof() .and. RC_FILIAL + RC_MAT + RC_PROCES + RC_ROTEIR + RC_PERIODO == cSRCSeek )
			If SRC->RC_PD $ cVerbDed
				If SRC->RC_PD == aCodFol[15,1]
					nValIrAnt += SRC->RC_VALOR
				ElseIf SRC->RC_PD == aCodFol[1913,1]
					nValIrOAnt += SRC->RC_VALOR
				Else
					If SRC->RC_PD != cVerbDep
						nValor += SRC->RC_VALOR
					Else
						nValorDep += SRC->RC_VALOR
					EndIf
				EndIf
			EndIf
					
			SRC->(DbSkip())
		EndDo
	EndIf
EndIf

If lVerTribAnt .And. nValor + nValorDep > aTabIr[7, 1]
    cModTribAnt := "1"
EndIf

If lValTribAnt .And. cModTribAnt == "1" .And. nValIrAnt > 0 .And. nValIrOAnt > 0
	cModTribAnt := Iif( nValIrAnt > nValIrOAnt, "2", "1" )
EndIf

If !Empty( aCodFol[1950, 1] )
	If nValor > 0
    	FMatriz( aCodFol[1950, 1], nValor )
	Else 	
	 	Aeval( aPd, { |x| If(x[1] == aCodFol[1950,1] .And. x[3] == cSemana .And. x[7] == "I" .And. x[9] != "D" , nValor += x[5], Nil) } )
	EndIf	
EndIf

Return nValor

/*/{Protheus.doc} fPdIrPLR
Obtém todas as verbas de base de IR para PLR
@author Leandro Drumond
@since 31/05/2023
/*/
Static Function fPdIrPLR()
Local aArea
Local cFilSRV 	 := xFilial("SRV")
Local cTmpAlias	 := ""

Static cFilIRPLR := ""
Static cPdIRPLR	 := ""

If cFilSRV <> cFilIRPLR
	aArea := GetArea()

	cFilIRPLR := cFilSRV 
	
	cTmpAlias := GetNextAlias()
	
	BeginSql alias cTmpAlias
		SELECT SRV.RV_COD
		FROM %table:SRV% SRV 
		WHERE SRV.RV_FILIAL = %exp:cFilSRV%
		AND SRV.RV_IR = 'S'
		AND SRV.RV_REFPLR = 'S'
		AND SRV.RV_CODFOL <> '0151'
		AND SRV.D_E_L_E_T_= '' 
	EndSql

	cPdIRPLR := aCodFol[151,1] + "/"
	
	While !(cTmpAlias)->(Eof())
		cPdIRPLR += (cTmpAlias)->RV_COD + "/" 
		(cTmpAlias)->(dbSkip())
	EndDo

	(cTmpAlias)->(dbCloseArea())

	RestArea(aArea)

EndIf

Return cPdIRPLR

/*/{Protheus.doc} fVldPdSup
Obtém as verbas de pagamento quando o afastamento for superior a 15 dias referente aos dias pagos pela empresa, 
que não devem incorporar a base do fgts 
@author Maria Luísa de S. Arcanjo Bastos
@since 22/08/2023
/*/
Static Function fVldPdSup(nDiasFgts, lTemPdSup, aDetAfas)
Local nCont    := 0
Local cPdSup   := ""

If lTemPdSup .And. nDiasFGTS > 0 .And. !Empty(aDetAfas)
	For nCont := 1 To Len(aDetAfas)
		If !Empty(aDetAfas[nCont][13]) .And. aDetAfas[nCont][7] <> "P1" .and. !Empty(aDetAfas[nCont][12])
			cPdSup += aDetAfas[nCont][1] + "*"
		EndIf
	Next nCont
EndIf

Return cPdSup

/*/{Protheus.doc} fGrvDepIr
Função para gravar os movimentos de IRRF dos dependentes na RU6
@author Bruno Costa
@since 12/09/2023
@params nQtdDep - Quantidade de dependentes de IR
@params nValDep - Valor total da dedução dos depentendes
@params cTpRend - Tipo de rendimento 1=Folha;2=13º;3=Férias;4=Rescisão;5=PLR 
@params cTribuIR - Tipo de tributação 1=Completa;2=Simplificada	
@params dDtPgto - Data de pagamento 
/*/
Static Function fGrvDepIr(nQtdDep, nValDep, cTpRend, cTribuIR, dDtPgto)

Local aAreaSRB	:= GetArea()
Local aDepIr    := {}
Local cTipodep	:= ""
Local cDia 		:= ""
Local cMesNasc  := ""
Local cTpMov 	:= "2" //Cálculo da Dedução para B.C. IRRF
Local cSeqMov 	:= "01" //Sequencia do movimento
Local cMesCalc  := Substr(cAnoMes,5,4)
Local cAnoCalc  := Substr(cAnoMes,1,4)
Local dDtNasc   := cTod("")
Local nIdade	:= 0
Local nX		:= 0
Local nValUni   := nValDep/nQtdDep
Local lNovo		:= .T.

DEFAULT cTribuIR := "1"
DEFAULT dDtPgto  := DDATA_PGTO

DBSelectArea("SRB")
SRB->(DBSetOrder(1)) //RB_FILIAL+RB_MAT+RB_COD

If SRB->(DBSeek(SRA->RA_FILIAL+SRA->RA_MAT))
	While SRB->(!Eof()) .And. SRA->RA_FILIAL+SRA->RA_MAT == SRB->(RB_FILIAL+RB_MAT)
		cTipodep  := SRB->RB_TIPIR
		dDtNasc   := SRB->RB_DTNASC
		cMesNasc  := StrZero( Month(dDtNasc), 2)
		cDia      := IIf(cMesCalc == "02", "28", "30")
		nIdade    := Calc_Idade( CtoD(cDia+"/" + cMesCalc + "/" + cAnoCalc , "DDMMYY" ), dDtNasc)
		If cTipodep == "1" .OR. ( cTipodep == "2" .AND. ( nIdade <= 21 .or. (nIdade == 22 .and. cMesNasc == cMesCalc) ) ) .OR. (cTipodep == "3" .AND. ( nIdade <= 24 .or. (nIdade == 25 .and. cMesNasc == cMesCalc) ))
			aAdd(aDepIr, {SRB->RB_COD})
		EndIf
		SRB->(DBSkip())
	EndDo
EndIf

dbSelectArea("RU6")
RU6->( dbSetOrder(2) ) //RU6_FILIAL+RU6_MAT+RU6_DTPGTO+RU6_TPREND+RU6_CODSRB+RU6_COMPET+RU6_SEMANA                                                                                       

For nX := 1 To Len(aDepIr)
	lNovo := RU6->( !dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + DTOS(dDtPgto) + cTpRend + aDepIr[nX, 1] ))
		
	If RU6->( RecLock("RU6", lNovo) )
		RU6_FILIAL := SRA->RA_FILIAL
		RU6_MAT    := SRA->RA_MAT
		RU6_CODSRB := aDepIr[nX,1]
		RU6_DTMOV  := dDataBase
		RU6_SEQMOV := cSeqMov
		RU6_TPMOV  := cTpMov	
		RU6_COMPET := cAnoMes
		RU6_SEMANA := cSemana
		RU6_DTPGTO := dDtPgto
		RU6_TPREND := cTpRend
		RU6_VLRDED := nValUni
		RU6_TPCAL  := cTribuIR			
		RU6->( MsUnlock() )
	EndIf 		
Next nX	

RestArea(aAreaSRB)

Return

/*/{Protheus.doc} f132RU6
Função para verificar se já existe dedução de 13º na RU6 para não gerar novamente no cálculo da rescisão,
pois o 13º é tributação exclusiva e o evento de 13º no eSocial é único. 
@author Bruno Costa
@since 28/09/2023
/*/
Static Function f132RU6()
Local lRet 		:= .F.
Local aArea     := GetArea()
Local cAliasRU6 := GetNextAlias()
Local aTransf   := {}
Local aFilMat	:= {}
Local nX 		:= 0
Local cWhere 	:= ""

If fTransfFil( @aTransf) 
	aAdd(aFilMat, { SRA->RA_FILIAL , SRA->RA_MAT })
	For nX := 1 To Len(aTransf)
		If AnoMes(aTransf[nX,7]) <= cPeriodo .and. aTransf[nX,2] <> aTransf[nX,5] 
			aAdd(aFilMat, {aTransf[nX,8], aTransf[nX,9]})
		EndIf
	Next nX
Else
	aAdd(aFilMat, { SRA->RA_FILIAL , SRA->RA_MAT} )
EndIf

cWhere := "%" 
If Len(aFilmat) == 1
	cWhere += " RU6.RU6_FILIAL = '" + SRA->RA_FILIAL + "' AND "
	cWhere += "RU6.RU6_MAT = '" + SRA->RA_MAT + "' AND "
Else
	cWhere += "("
	For nX := 1 to Len(aFilMat)
		cWhere += If(nX == 1, " (", " OR (")
		cWhere += " RU6.RU6_FILIAL = '" + aFilMat[nX,1] + "' AND "
		cWhere += "RU6.RU6_MAT = '" + aFilMat[nX,2] + "' )"
	Next nX
	cWhere += " ) AND "
EndIf
cWhere += "RU6.RU6_COMPET BETWEEN '" + substr(cAnoMes,1,4)+"01" + "' AND '" + substr(cAnoMes,1,4)+"12" 
cWhere += "' AND RU6.RU6_TPREND = '2' "
cWhere += "%"

BeginSql alias cAliasRU6
	SELECT COUNT(*) AS CONTADOR 
	FROM %table:RU6% RU6 
	WHERE %exp:cWhere%
    AND RU6.%NotDel% 
EndSql

If ( cAliasRU6 )->( !Eof() )
	If ( cAliasRU6 )->CONTADOR > 0
		lRet := .T.
	EndIf
EndIf

(cAliasRU6)->( DbCloseArea() ) 

RestArea(aArea)

Return lRet

/*/{Protheus.doc} fVerPercAci
Função para verificar se foi trocado o percentual do acidente de trabalho no dissídio
@author Bruno Costa
@since 27/06/2024
/*/
Function fVerPercAci()

Local lRet := lPAcTrabDif

lPAcTrabDif := .F.

Return lRet
