#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEXPER.CH"

Static _aPerAtu		:= {}
Static _aPesqPer	:= {}
Static _aPesqTno	:= {}
Static _aCarFec		:= {}
Static _aCarPer		:= {}

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL. 		   	            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ FNC 			 ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Leandro Dr. ³19/03/13³M12RH01         ³Unificao da Folha.                        ³±±
±±³Alberto M   ³10/09/14³TPXWQ2          ³Correção para geracao de titulos para     ³±±
±±             ³        ³                ³geracao de titulos para periodos abertos  ³±±
±±             ³        ³                ³e periodos fechados.                      ³±±
±±³Alberto M   ³09/10/14³TPXWQ2          ³Ajustes na funcao fRetPerComp, otimizando ³±±
±±             ³        ³                ³a query do RCH.                           ³±± 
±±³Alberto M   ³21/08/15³TSZ123          ³Ajuste em FTrabCalen() p/ nao gerar error ³±±
±±             ³        ³                ³log na geracao do xml do homolognet       ³±±
±±³Flavio Corr ³24/08/15³TTDZBA	         ³Receber a filial na funçaõ  fcarrperiodo  ³±±
±±³Marcos Perei³03/09/15³PCREQ-5342      ³Ajuste na FTrabCalen para GSP             ³±±
±±             ³        ³                ³                                          ³±± 
±±³Allyson M   ³08/12/15³TTYNZS          ³Ajuste na carga dos dados do periodo 		³±±
±±³Raquel Hager³11/02/16³TULLDU          ³Ajuste na carga dos dados do periodo. 	³±±
±±³Flavio COrre³24/02/16³TUNFQL          ³Melhoria no log                       	³±±
±±³Renan Borges³06/04/16³TUT503          ³Ajuste para gerar log com a filial do fun-³±±
±±³			   ³		³		   		 ³cionário correta.                         ³±±
±±³Claudinei S.³04/05/16³TUCJR5          ³Ajuste na FTrabCalen para considerar ou   ³±±
±±             ³        ³                ³não as férias, conforme o novo mnemonico  ³±±
±±             ³        ³                ³P_CPROPDSR.                               ³±±
±³Claudinei S. ³11/05/16³TUCJR5|TUVQAB   ³Ajustada na FTrabCalen a apuração dos dias³±±
±±³            ³        ³                ³de ferias para o DSR de Horas Extras.	    ³±±
±±³Gabriel A.  ³16/06/16³TVKVVH          ³Ajuste para buscar os períodos na RCF de  ³±±
±±             ³        ³                ³acordo com a semana.                      ³±±
±±³Claudinei S.³20/06/16³TVKTW6          ³Ajuste na FTrabCalen p/ considerar os dias³±±
±±             ³        ³                ³trabalhados dos Horistas pelo periodo do  ³±±
±±             ³        ³                ³PON/GPE, conforme o Mnemonico P_nDSRHori. ³±±
±±³Claudinei S.³27/06/16³TVKTW6          ³Ajuste na FTrabCalen p/ considerar os dias³±±
±±             ³        ³                ³trabalhados dos Horistas pelo periodo do  ³±±
±±             ³        ³                ³PONTO corretamete.                        ³±±
±±³Gabriel A.  ³29/06/16³TVIBY6          ³Criação de função para retornar o último  ³±±
±±             ³        ³                ³período fechado.                          ³±±
±±³Gabriel A.  ³21/07/16³TVPLEY          ³Ajuste no nome da variável roteiro para   ³±±
±±             ³        ³                ³Argentina.                                ³±±
±±³M. Silveira ³26/01/17³MRH-4657        ³Incluida a funcao fHTrabCalen p/ permitir ³±±
±±³            ³        ³                ³calcular Salario e DSR de horista conforme³±±
±±³            ³        ³                ³a tabela de horario do Ponto, com uso do  ³±±
±±³            ³        ³                ³Mnemonico P_LDSRHRSP.                     ³±±
±±³M. Camargo  ³20/12/18³DMINA-5150      ³Modificación a función fgetPerAtual para  ³±±
±±³            ³        ³                ³recibir parámetro que permita identificar ³±±
±±³            ³        ³                ³si está siendo detonada por rutina automá-³±±
±±³            ³        ³                ³tica . Enviía mensaje al usuario cuando no³±±
±±³            ³        ³                ³encuentra periodo abierto para el procedi-³±±
±±³            ³        ³                ³miento, proceso y sucursal indicadas.     ³±±
±±³            ³        ³                ³Aplica países diferentes a Brasil.        ³±±
±±³M. Camargo  ³01/10/19³DMINA-7357      ³Modificación a función fcarperiodo  para  ³±±
±±³            ³        ³                ³cuando MV_PERMOD2=TRUE                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fTrabCalenºAutor  ³Microsiga           º Data ³  05/12/03   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Calculo dos totais do Calendario de acordo com  Cmpetencia  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GENERICO                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FTrabCalen(cPeriodo	,;		//01-- Periodo
                     nDTrab  	,;		//02-- Dias Trabalhados
                     nDNTrab 	,;		//03-- Dias Nao Trabalhados
                     nDDsr   	,;		//04-- Dias de DSR
                     nDNUtil 	,;		//05-- Dias Nao Uteis de Vale Transporte 
                     nDUte   	,;		//06-- Dias uteis de Vale Transporte 
                     nDifVT  	,; 		//07-- Dias de Diferenca de Vale Transporte
                     nHrsDSR 	,;		//08-- Qtde de Horas de DSR
                     nHrsTrab	,;		//09-- Qtde de HoraS Trabalhadas 
                     nVlRefei	,;		//10-- Dias de Vale Refeicao 
                     nTotVT  	,;		//11-- Dias totais de V.T. Dias Uteis 
                     nTotNVT 	,;		//12-- Dias totais de V.T. Dias Nao uteis 
                     cSem		,;		//13-- Numero de Pagamento
                     lPerAfas	,;		//14-- Proporcional a Afastamento
                     lAdmissao	,;		//15-- Proporcional a Admissao
                     dDataFim	,;		//16-- Data Fim do Periodo
                     cRoteiro	,;		//17-- Roteiro
                     dDataIni	,;		//18-- Data inicial para pesquisa (opcional)
                     cVbAfast	,;		//19-- Verbas de tipos de afastamentos (opcional)
                     nVlAlim	,;		//20-- Dias de Vale Alimentacao
                     nDUteis	,;		//21-- Dias uteis
                     lConsFer	,;		//22-- Considera Afastamento referente a ferias
                     aTabCalend	,;		//23-- Calendario do Ponto 
                     lDSRHorist )		//24-- Originou do cálculo do DSR Horista

Local aArea			:= GetArea()
Local aRCHArea		:= RCH->( GetArea() )
Local aTabCAux 		:= {}
Local aTabPadrao 	:= {}
Local aTurnos 		:= {}
Local nDSRDom 		:= 0
Local lUltSemana
Local nPos			:= 0
Local nPos1			:= 0 
Local nPosFer		:= 0
Local nAfasPer		:= 0
Local nInicio 
Local nCount		:= 0 
Local nTotDias 
Local nDAuxMat		:= 0
Local cOldSem 		:= Space(2) 
Local aAfast		:= {}
Local aPerAux 		:= {}

Private aDados		:= {}

If Type("nPosSem") == "U"
	Private nPosSem := 0
EndIf
If Type("nDiasMat")== "U" 
	Private nDiasMat := 0
EndIf   

Static cPer
Static cTurno
Static lGestPubl

DEFAULT lGestPubl 	:= If(ExistFunc("fUsaGFP"),fUsaGFP(),.f.)	//Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
DEFAULT cTurno 		:= "!!!"
DEFAULT cVbAfast	:= ""
DEFAULT nDTrab 		:= 0
DEFAULT nDNTrab		:= 0
DEFAULT nDDsr  		:= 0
DEFAULT nDNUtil		:= 0
DEFAULT nDUte		:= 0
DEFAULT nDifVT		:= 0
DEFAULT nHrsDSR		:= 0
DEFAULT nHrsTrab	:= 0
DEFAULT nVlRefei	:= 0
DEFAULT nTotVT		:= 0
DEFAULT nTotNVT		:= 0
DEFAULT nVlAlim		:= 0
DEFAULT lPerAfas	:= .F.
DEFAULT lAdmissao	:= .T.
DEFAULT lConsFer	:= .T.
DEFAULT aTabCalend  := {}
DEFAULT lDSRHorist	:= .F.
DEFAULT cSem 		:= Space( GetSx3Cache("RCH_NUMPAG", "X3_TAMANHO") )

If Type( "cSemana" ) != "U"
	cOldSem		:= cSemana
Else
	cOldSem		:= Space( GetSx3Cache("RCH_NUMPAG", "X3_TAMANHO") )
EndIf

//Se for Horista e deseja calcular o DSR pelo calendário do ponto, faz a carga do calendário do ponto.
If cPaisLoc == "BRA" .and. If( Type("P_NDSRHORI") == "U", .F., (P_NDSRHORI == 2 .Or. (P_NDSRHORI == 3 .And. SRA->RA_TPCONTR == "3")) ) .And. SRA->RA_CATFUNC == "H" .And. lDSRHorist
	nHrsDSR := HrsSem2OneDsr( SRA->RA_HRSEMAN )
	
	If CriaCalend(dDataIni 			,;	//01 -> Data Inicial do Periodo
					dDataFim		,;	//02 -> Data Final do Periodo
					SRA->RA_TNOTRAB	,;	//03 -> Turno Para a Montagem do Calendario
					SRA->RA_SEQTURN	,;	//04 -> Sequencia Inicial para a Montagem Calendario
					@aTabPadrao		,;	//05 -> Array Tabela de Horario Padrao
					@aTabCalend		,;	//06 -> Array com o Calendario de Marcacoes
					SRA->RA_FILIAL  ,;	//07 -> Filial para a Montagem da Tabela de Horario
					SRA->RA_MAT   	,;	//08 -> Matricula para a Montagem da Tabela de Horario
					SRA->RA_CC   	,;	//09 -> Centro de Custo para a Montagem da Tabela
					@aTurnos		,;	//10 -> Array com as Trocas de Turno
					NIL				,;	//11 -> Array com Todas as Excecoes do Periodo
					NIL				,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
					.T.				,;	//13 -> Se executa a funcao se sincronismo do calendario (Default .T.)
					NIL			 	,;	//14 -> Se Forca a Criacao de Novo Calendario
					NIL  			,; 	//15 -> Array com marcacoes para tratamento de Turnos Opcionais
					NIL 			,; 	//16 -> Se considera as exceções cadastradas
					.T. 	 		; 	//17 -> Chamada do GPEXPER
					)

		//Adiciona a primeira entrada dos dias no array auxiliar aTabCAux
		aEval( aTabCalend, { |x| If( x[4] == "1E", aAdd( aTabCAux, aClone(x) ), Nil)  } )		

		Normal 	:= 0
		Descanso 	:= 0
		nTUteis 	:= 0
		nTNUteis 	:= 0
		
		//Se o dia for do tipo Trabalhado*Compensado*Nao trabalhado, conta como dia util
		aEval( aTabCAux, { |x| If( x[36] $ "S*C*N" 	.And. 	x[19] == .F. .And. x[24] == .F. , nTUteis++, Nil ) } )
		//Se o dia for do tipo  DSR*Feriado e nao estiver afastado, conta como dia nao util
		aEval( aTabCAux, { |x| If( ( x[36] $ "D*F"	.Or. x[19] ) .And. x[24] == .F. , nTNUteis++, Nil ) } )
		//Se o dia for do tipo  DSR e nao estiver afastado, conta como dia nao util
		aEval( aTabCAux, { |x| If( (x[36] == "D" .Or. x[19] == .T.) .And. x[24] == .F. , nDSRDom++, Nil ) } )
		//Apura as horas de trabalho previstas dos dias de tipo Trabalhado*Compensado
		aEval( aTabCalend, { |x| If( x[36] $ "S*C*N" 	.And. x[24] == .F. , Normal 	:= __TimeSum( Normal, x[7] )	, Nil ) } )		

		//Calcula DSR com base nas horas trabalhadas e dias uteis
		nHrsDSR := Int( Normal / nTUteis )
		nHrsDSR += ( ( Normal / nTUteis - nHrsDSR ) * 60 ) / 100

		//Transforma hora sexagesimal em centesimal, igual ao conceito do SIGAPON
		Normal		:= 	fConvHr(Normal, "D")  
		//Alimenta o retorno da função com os dias vindos do SIGAPON
		nDDsr 		:= nDSRDom
		nDTrab 	:= nTUteis - nTNUteis
		nDNtrab	:= nTNUteis
	EndIf

//Se usar o calendario do periodo
Else 
	//--Atribui a Semana Solicitada ou 00 para mensalista
	cSemana		:= cSem 
	
	//--Carrega a Semana Somente se Mudar a data de Referencia 
	If Type( "aPeriodo" ) = "U"
		aPeriodo := {}
	EndIf
	
	If Empty(aPeriodo) .or. ( aPeriodo[nPosSem,15] + aPeriodo[nPosSem,16] <> cPeriodo ) 
		If cPaisLoc == "ARG" .And. (cRoteiro == fGetCalcRot("3") .Or. cRoteiro == fGetCalcRot("4"))
			aPeriodo := {}
		EndIf
		//--Funcao para carregar Periodo 
		If !fCarPeriodo( cPeriodo, cRoteiro , @aPeriodo , lUltSemana , @nPosSem )
			Return .F.
		EndIf
		cTurno		:= SRA->RA_TNOTRAB  
	EndIf

	If SRA->RA_TPCONTR == "3" .and. cTipoRot == "4" .and. cCompl == "S" .and. cPeriodo <> SRG->RG_PERIODO
		aPerAux := aClone(aPeriodo)

		aPeriodo := {}
		fCarPeriodo( SRG->RG_PERIODO, cRoteiro , @aPeriodo , lUltSemana , @nPosSem )
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Para semanalistas, calcula o n£mero de dias trabalhados      ³
	//³ conforme Calendario                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If(nPos 	:= Ascan( aPeriodo, { |X| X[1]+ X[2] == SRA->RA_TNOTRAB +  cSemana } ) )== 0
		If( nPos := Ascan( aPeriodo, { |X| X[1]+ X[2] == "@@@" +  cSemana } ) ) == 0
			If( nPos := Ascan( aPeriodo, { |X| X[1]+ X[2] == SRA->RA_TNOTRAB +  "  "} ) ) == 0
				nPos:= Ascan( aPeriodo, { |X| x[1]+ x[2] == "@@@" + "  " } )
			EndIf
		EndIf	
	EndIf 
	
	If nPos > 0 
		aDados	 := aClone(aPeriodo[nPos,5])	//-- Dias do Periodo 
	
		//-- Data Final do Periodo
		If Empty(dDataFim) .Or. dDataFim > aPeriodo[nPos,4]
			If Len(aPeriodo[nPos,5]) > 0
				dDataFim := Iif( !Empty(aPeriodo[nPos,4]), aPeriodo[nPos,4], aPeriodo[nPos,5,Len(aPeriodo[nPos,5]),1])
			Else
				dDataFim := aPeriodo[nPos,4]
			EndIf
		EndIf
		                                        
		If !Empty(dDataIni)                
			nTotDias:= Ascan( aDados, { |x| x[1]== dDataFim } )
		Else 
			//-- Total de Dias da Semana 
			nTotDias := Len(aDados)
			If nTotDias == 0
				nTotDias := dDataFim - aPeriodo[nPos,3] + 1
			EndIf
		EndIf
			                         
		nInicio  := 1               
		//-- Verifica Admissao no periodo e diminui o numero de dias a ser pesquisado 
		If !Empty(dDataIni)   
			nInicio:= Ascan( aDados, { |x| x[1]== dDataIni } )
			If lAdmissao .And. SRA->RA_ADMISSA >= dDataIni .And. SRA->RA_ADMISSA <= dDataFim
				nInicio:= Ascan( aDados, { |x| x[1]== SRA->RA_ADMISSA } )
			EndIf
		Else	
			If lAdmissao .and. SRA->RA_ADMISSA >= aPeriodo[nPos,3] .And. SRA->RA_ADMISSA <= dDataFim
				nInicio := nTotDias - ( dDataFim - SRA->RA_ADMISSA )
			EndIf
		EndIf
	
		//-- Monta a Data de Inicio da Pesquisa 
		If cPaisLoc $ "BOL" .And. MesAno(SRA->RA_ADMISSA) <> cPeriodo
			nInicio := 1
		EndIf                    
		If cPaisLoc $ "ARG"
			nInicio := 1
		EndIf                    
		If !Empty(dDataIni)
			dDataDia:= dDataIni
		Else
			If Len(aPeriodo[nPos,5]) > 0
				dDataDia := Iif(!Empty(aPeriodo[nPos,3]), aPeriodo[nPos,3], aPeriodo[nPos,5,1,1]) + nInicio - 1
			Else
				dDataDia := aPeriodo[nPos,3] + nInicio - 1
			EndIf
		EndIf
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica dias de Afastamentos/Ferias                                     ³
		//³ aAfast{nAvosAP,nDiasAP,SR8->R8_DATAINI,SR8->R8_DATAFIM,SR8->R8_TIPO})    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		
		nDAuxMat := nDiasMat
		
		fRetAfas(dDataDia, dDataFim , , , , , @aAfast, cVbAfast,,,,,,,,.F.)
		
		nDiasMat := nDAuxMat

		If !lConsFer
			If ( nPosFer := aScan(aAfast, { |X| X[5] == "F" })) > 0
				aDel(aAfast, nPosFer)
				aSize(aAfast,Len(aAfast)-1)
			EndIf
		EndIf
		
		nDUteis		:= aPeriodo[nPos,24]
		
		If Len(aDados) == 0
	
			nDDsr  		:= ceiling( aPeriodo[nPos,7] - ( ( nDiasAfas * aPeriodo[nPos,7] ) / nDiasc ) )
	   	  	nDNTrab		:= ceiling( aPeriodo[nPos,8] - ( ( nDiasAfas * aPeriodo[nPos,8] ) / nDiasc ) )
	   	  	nDTrab 		:= nDiasC - nDiasAfas - nDDsr - nDNTrab
	   		nDNUtil		:= aPeriodo[nPos,9]
			nTotNVT		:= aPeriodo[nPos,9]
			nDUte  		:= aPeriodo[nPos,10]
			nTotVT		:= aPeriodo[nPos,10]
			nDifVT		:= aPeriodo[nPos,11]
			nVlRefei	:= aPeriodo[nPos,12]
			nHrsDSR		:= aPeriodo[nPos,13]
			nHrsTrab	:= aPeriodo[nPos,14]
		Else	
			For nCount := nInicio to nTotDias 
			                                               
				nPos1 := aScan(aAfast,{|x| dDataDia >= x[3] .and. (dDataDia <= x[4] .or. Empty(x[4])  ) } )
				
				If !Empty(cVbAfast) .And. nPos1 > 0
					nAfasPer := If( nPos > 0, ascan(aAfast, {|x| x[12] $ cVbAfast } ), 0 )
				ElseIf nPos1 > 0 .And. ( (lPerAfas .And. aAfast[nPos1,5] <> "F" ) .Or. (lConsFer .And. aAfast[nPos1,5] == "F"  ) )
					nAfasPer := 1
				Else
					nAfasPer := 0
				EndIf
				
				If  nAfasPer == 0 .And. ( (lPerAfas .And. nPos1 <= 0) .Or. (!lPerAfas .And. dDataDia <= dDataFim) .Or. (lGestPubl .AND. SRA->RA_REGIME == '2') )
		
					nDTrab += If( aDados[nCount,2] == "1", 1, 0 ) 
				    nDDsr  += If( aDados[nCount,2] $ "3/4", 1, 0 )
			    	nDNTrab+= If( !(aDados[nCount,2] $ "1/3/4" ), 1, 0 )
			    	nDNUtil+= If( (Alltrim( Upper(  Cdow( aDados[nCount,1] ))) == "SATURDAY" .OR. ; 
								  Alltrim( Upper(  Cdow( aDados[nCount,1] ))) == "SUNDAY"   ) .AND. ; 
								   aDados[nCount,3] == "1"      ,1,0 )
					nDUte  += If( ( Alltrim( Upper( Cdow( aDados[nCount,1] ))) != "SATURDAY" .and. ;
								     Alltrim( Upper( Cdow( aDados[nCount,1] ))) != "SUNDAY" ) .AND. ;
								  aDados[nCount,3] == "1"    ,1 ,0 ) 
					nDifVT	+= If( aDados[nCount,4] == "1"  ,1 ,0 )
					nVlRefei+= If( aDados[nCount,5] == "1"  ,1 ,0 )
					nHrsDSR	+= aDados[nCount,6] 
					nHrsTrab+= aDados[nCount,7]
					nVlAlim += If( aDados[nCount,8] == "1"  ,1 ,0 )
					
				EndIf 
				
				dDataDia := dDataDia + 1
			Next nCount
			//# Abate os dias de afastamento dos dias trabalhados
			If cPaisLoc == "ARG" .And. IsInCallStack("S_PROMEDIO") .And. ;
				(cRoteiro == FGETCALCROT("3") .Or. cRoteiro == FGETCALCROT("4"))
				
				nAux := 0
				aEval(aAfast,{ |X| nAux += X[11] })
				nDTrab -= nAux
			EndIf
		EndIf
	EndIf  
	
	If Len(aDados) > 0
		//-- Dias totais de V.T. Dias Uteis 
		aEval(aDados,{ |X| nTotVT	+= If(  X[3] == "1" .and. ; 
											( Alltrim( Upper( Cdow( X[1] ))) != "SATURDAY" ) .and.  ;
											( Alltrim( Upper( Cdow( X[1] ))) != "SUNDAY"	) ;
										 ,1,0 );
					  }) 
		//-- Dias totais de V.T. Dias Nao uteis 
		aEval(aDados,{ |X| nTotNVT	+= If(  X[3] == "1" .and. ; 
											(( Alltrim( Upper( Cdow( X[1] ))) == "SATURDAY" ).or.  ;
											 ( Alltrim( Upper( Cdow( X[1] ))) == "SUNDAY"   );
											)   ;
										 ,1,0 ) ;
					})
	EndIf
	
	//--Retorna a Semana Original do Calculo
	cSemana := cOldSem
EndIf 

If !Empty(aPerAux)
	aPeriodo := aClone(aPerAux)
EndIf

RestArea( aArea )
RestArea( aRCHArea )

Return(.T.)

/* 
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fCarPeriodo ºAutor  ³Microsiga- Natie    º Data ³  01/12/03   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Carrega o Array aPeriodo com as semanas do mes de Calculo     º±±
±±º          ³atraves da Filial e do Turno do funcionario posicionado       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±³Parametros³dDataRef  = Data para Mes Ano de referencia                   ³±±
±±³          ³aPeriodo  = Array parta carregar as semanas da data de ref.   ³±±
±±³          ³nPosSem   = Posicao da Semana atual no array aPeriodo		    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±ºUso       ³ Sigagpe                                                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/ 
Function fCarPeriodo( cPeriodo, cRoteiro, aPeriodo, lUltSemana, nPosSem, lShowHelp, cFilTab, lGraMed, lRestRCH)

Local cFilRCF	:= ""
Local cKeyTurno := ""
Local cKeySemana:= ""
Local cRotBlank := Space( GetSx3Cache( "RCH_ROTEIR", "X3_TAMANHO" ) )
Local cTurno	:= SRA->RA_TNOTRAB
Local cSvTurno	:= cTurno
Local cProcesso	:= SRA->RA_PROCES
Local cMsgHelp	:= ""
Local cCompl	:= ""
Local dDtDePer	:= CtoD("")
Local dDtAtePer	:= CtoD("")
Local dDtPago   := CtoD("")
Local dDataAux	:= CtoD("")
Local nPosAux	:= 0
Local nPosAux2	:= 0
Local nRecRCH	:= 0
Local lComplFol	:= Type("P_CCOMP13") != "U" .And. P_CCOMP13 == 'S' .And. lCalcFol .And. fTem132Per() .And. cRoteiro != fGetCalcRot('3')
Local aAltSPF	:= {}
Local lPerMod2	:= (GetMvRH("MV_MODFOL", NIL, "1") == "2") .And. GetMvRH( "MV_PERMOD2" , .F., .F. ) // Mod 2 y mv_permod2=t
Local aDados	:= {}
Local dDataSR9	:= CtoD("")

DEFAULT lShowHelp 	:= If( FindFunction( "AddLogExecRot" ) , .F. , .T. )
DEFAULT cFilTab		:= xFilial("RCH",SRA->RA_FILIAL)
DEFAULT lGraMed		:= .F.
DEFAULT lRestRCH	:= .T.

cSemana := If(Type( "cSemana" ) = "U" , "01", (If(Empty(cSemana),"01",cSemana)) )

// Validação da variável lDissidio para evitar erros em rotinas que não carregam os mnemônicos.
If Type( "lDissidio" ) == "U"
	lDissidio := .F.
EndIf

//Se for dissidio verifica se houve troca de turno na tabela SR9.
If lDissidio
	cTurno		:= ALLTRIM(gpRetSR9("SR9",stod (cPeriodo + cValToChar (f_UltDia (stod (cPeriodo + "01")))), "RA_TNOTRAB",@dDataSR9))
	cSvTurno	:= cTurno

	aAltSPF		:= HistSPF(stod(cPeriodo + "01"),dDataBase)
	If !Empty(dDataSR9) 
		aadd(aAltSPF,{dDataSR9,cTurno,cTurno})
		aAltSPF := aSort(aAltSPF,,,{|x,y| x[1]< y[1]})
	EndIf
	If Len(aAltSPF) > 0
		aEval(aAltSPF,{|x| cTurno := If(ANOMES(x[1]) > cPeriodo, x[2], x[3])} )
		cSvTurno	:= cTurno 
	Else
		cTurno 		:= SRA->RA_TNOTRAB
		cSvTurno	:= cTurno
	EndIf
EndIf


If (nPosAux := aScan( _aCarPer, { |x| x[1] == cFilTab+cProcesso+cPeriodo+cRoteiro+cTurno+cSemana } )) == 0 .And. ( aScan( _aPesqTno, { |x| x[1] == cFilTab+cProcesso+cPeriodo+cRotBlank+cTurno+cSemana } ) == 0 .Or. (nPosAux := aScan( _aCarPer, { |x| x[1] == cFilTab+cProcesso+cPeriodo+cRoteiro+"@@@"+cSemana } )) == 0 )
	dbSelectArea("RCH")
	dbSetOrder(1)

	If aScan( _aPesqPer, { |x| x[1] == cFilTab+cProcesso+cPeriodo+cSemana+cRoteiro } ) == 0 
		aAdd( _aPesqPer, { cFilTab+cProcesso+cPeriodo+cSemana+cRoteiro } )
		If !dbSeek(cFilTab + cProcesso + cPeriodo + cSemana + cRoteiro , .T. )
			If ( lShowHelp )
				HELP( " ",1,"GPCALEND",  )						//--Nao existe periodo cadastrado 
			ElseIf FindFunction( "AddLogExecRot" )
				cMsgHelp := "Function(RCH): "
				cMsgHelp += ProcName()
				cMsgHelp += "/Line: "
				cMsgHelp += AllTrim( Str( ProcLine() ) )
				cMsgHelp += " - "
				cMsgHelp += "Help:GPCALEND"
				cMsgHelp += " -> "
				cMsgHelp += STR0014		//"Nao existe roteiro cadastrado"
				cMsgHelp += " -> " + CRLF
				cMsgHelp += STR0012 + cFilTab + CRLF
				cMsgHelp += STR0003 + cProcesso + CRLF
				cMsgHelp += STR0011 + cPeriodo + CRLF
				cMsgHelp += STR0002 + cSemana + CRLF
				cMsgHelp += STR0004 + cRoteiro + CRLF
				If IsInCallStack("fCompl13")
					cMsgHelp += + CRLF + STR0013
				EndIf
				AddLogExecRot( cMsgHelp )
			EndIf
			aPeriodo := {}
			Return(.F.)
		EndIf
	EndIf
	If !lPerMod2
		dbSelectArea( "RCF")                                                     
		dbSetOrder(2)

		aAdd( _aPesqTno, { cFilTab+cProcesso+cPeriodo+cRotBlank+cTurno+cSemana } )
		If !dbSeek(cFilTab + cProcesso + cPeriodo + cRotBlank + cTurno + cSemana , .T. )
			cTurno	:= "@@@"
			If !dbSeek(cFilTab + cProcesso + cPeriodo + cRotBlank + cTurno + cSemana , .T. )
				If ( lShowHelp )
					HELP( " ",1,"GPCALEND",  )						//--Nao existe periodo cadastrado 
				ElseIf FindFunction( "AddLogExecRot" )
					cMsgHelp := "Function: "
					cMsgHelp += ProcName()
					cMsgHelp += "/Line: "
					cMsgHelp += AllTrim( Str( ProcLine() ) )
					cMsgHelp += " - "
					cMsgHelp += "Help:GPCALEND"
					cMsgHelp += " -> "
					cMsgHelp += STR0008		//"Nao existe periodo cadastrado"
					cMsgHelp += " -> "
					cMsgHelp += cFilTab + "/" + cProcesso  + "/" +  cPeriodo  + "/" +  cRotBlank + "/" +  cTurno + "/" + cSemana
					AddLogExecRot( cMsgHelp )
				EndIf
				aPeriodo := {}
				Return(.F.) 
			EndIf
		EndIf

		aDados 		:= {}
		
		While !RCF->( Eof() ) .and. cFilTab + cProcesso + cPeriodo + cRotBlank + cTurno + cSemana == RCF->(RCF_FILIAL + RCF_PROCES + RCF_PER + RCF_ROTEIR + RCF_TNOTRA + RCF_SEMANA ) 
			cFilRCF		:= RCF->RCF_FILIAL 
			cKeyTurno	:= RCF->RCF_TNOTRA 
			cKeySemana	:= RCF->RCF_SEMANA
			
			If RCH->( dbSeek(cFilTab + cProcesso + cPeriodo + cKeySemana + If(!lComplFol, cRoteiro, fGetCalcRot("1")) ) ) 
				dDtDePer	:= RCH->RCH_DTINI 
				dDtAtePer	:= RCH->RCH_DTFIM
				dDtPago		:= RCH->RCH_DTPAGO
				cCompl		:= RCH->RCH_COMPL
				
				If Empty(dDataAux)
					dDataAux := dDtDePer
				EndIf 
			EndIf
		
			aDados		:= {}
			If cKeySemana == cSemana
				aPeriodo	:= {}
			EndIf
		
			//### Nao carregar dias/horas trabalhados dia a dia
			If cPaisLoc # "ARG" .Or. (cPaisLoc == "ARG" .And. !(cRoteiro $ "LIQ"))
				
				RCG->(DbSetOrder(RetOrder("RCG","RCG_FILIAL+RCG_PROCES+RCG_PER+RCG_SEMANA+RCG_ROTEIR+RCG_TNOTRA+DTOS(RCG_DIAMES)")))
				If RCG->( dbSeek(cFilTab + cProcesso + cPeriodo + cKeySemana + cRotBlank + cKeyTurno  ) ) 
					
					While !RCG->( Eof() )  .and. cFilRCF + cProcesso + cPeriodo + cKeySemana + cRotBlank + cKeyTurno  = RCG->(RCG_FILIAL + RCG_PROCES + RCG_PER + RCG_SEMANA + RCG_ROTEIR + RCG_TNOTRA ) 
						aAdd(aDados,{RCG->RCG_DIAMES, RCG->RCG_TIPDIA, RCG->RCG_VTRANS, RCG->RCG_DIFTRA,  RCG->RCG_VREFEI, RCG->RCG_HRSDSR, RCG->RCG_HRSTRA, RCG->RCG_VALIM } ) 
						RCG->( DbSkip() ) 
					Enddo               
				EndIf
			EndIf
			nPosSem	   := aScan(aPeriodo,{|X| x[1]+x[2]+DtoS(x[3])+x[27] == cKeyTurno+cKeySemana+DtoS(dDtDePer)+cFilTab})
			If nPosSem == 0 .And. cKeySemana == cSemana
				aAdd(aPeriodo, {cKeyTurno, cKeySemana, dDtDePer, dDtAtePer, aDados, ;
								RCF->RCF_DIATRA, RCF->RCF_DIADSR, RCF->RCF_DNTRAB, RCF->RCF_DNUTIL, RCF->RCF_DUTILT, ;
								RCF->RCF_DDIFVT, RCF->RCF_DREFEI, RCF->RCF_HRSDSR, RCF->RCF_HRSTRA, RCF->RCF_ANO, ;
								RCF->RCF_MES, dDtPago, RCF->RCF_DPERIO, RCH->RCH_DTCORT, RCF->RCF_DCALCM, ;
								RCF->RCF_DALIM, If(cPaisLoc=="BRA",RCH->RCH_TARINI,""), If(cPaisLoc=="BRA",RCH->RCH_TARFIM,""), RCF->RCF_DUTEIS, cCompl, ;
								RCH->RCH_PERSEL, RCF->RCF_FILIAL }  )
				nPosSem	   := aScan(aPeriodo,{|X| x[1]+x[2]+DtoS(x[3])+x[27] == cKeyTurno+cKeySemana+DtoS(dDtDePer)+cFilTab})
			EndIf
			RCF->(DbSkip())
		EndDo
		aAdd( _aCarPer, { cFilTab+cProcesso+cPeriodo+cRoteiro+cTurno+cSemana, aClone(aPeriodo), nPosSem, .F., 0 } )
		nPosAux2 := Len(_aCarPer)
	Else
		dbSelectArea("RCH")	
		RCH->(dbSetOrder(1)) // RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR          
		RCH->(DBGOTOP())
		If RCH->( dbSeek(cFilTab + cProcesso + cPeriodo + cSemana + If(!lComplFol, cRoteiro, fGetCalcRot("1")) ) )
			dDtDePer	:= RCH->RCH_DTINI 
			dDtAtePer	:= RCH->RCH_DTFIM
			dDtPago		:= RCH->RCH_DTPAGO
			cCompl		:= RCH->RCH_COMPL
			cKeySemana	:= RCH->RCH_NUMPAG
			If Empty(dDataAux)
				dDataAux := dDtDePer
			EndIf 
			aAdd(aPeriodo, {cTurno, cKeySemana, dDtDePer, dDtAtePer, aDados, ;
						0,  0, 0, If(cPaisLoc <> "BRA", RCH->RCH_DIAPER-RCH->RCH_DIAUTI, RCH_DIAUTI), RCH->RCH_DIAUTI, ;
						0,  0, 0, 0, RCH->RCH_ANO, ;
						RCH->RCH_MES, dDtPago, RCF->RCF_DPERIO, RCH->RCH_DTCORT, RCF->RCF_DCALCM, ;
						0, If(cPaisLoc=="BRA",RCH->RCH_TARINI,""), If(cPaisLoc=="BRA",RCH->RCH_TARFIM,""), RCH->RCH_DIAUTI, cCompl, ;
						RCH->RCH_PERSEL, RCH->RCH_FILIAL }  )
			nPosSem	   := aScan(aPeriodo,{|X| x[1]+x[2]+DtoS(x[3])+x[27] == cTurno+cKeySemana+DtoS(dDtDePer)+cFilTab})		
		EndIf
	EndIf

	aSort( aPeriodo ,,, { |X,Y| X[1]+ x[2] < Y[1]+ y[2] } )		//-- Turno + Semana

	nRecRCH := RCH->(Recno())
	//Se não existir semana posterior ou se a semana posterior for folha complementar, define a variável como .T.
	lUltSemana := If ( !(RCH->( dbSeek(cFilTab + cProcesso + cPeriodo + Soma1(cSemana) + cRoteiro))) .or. RCH->RCH_COMPL == "1", .T., .F. )
	nPosSem	   := aScan(aPeriodo,{|X| x[1]+x[2]+DtoS(x[3])+x[27] == cTurno+cSemana+DtoS(dDataAux)+cFilTab})

	RCH->(DbGoTo(nRecRCH)) 
	If nPosAux2 > 0
		_aCarPer[nPosAux2, 3] := nPosSem
		_aCarPer[nPosAux2, 4] := lUltSemana
		_aCarPer[nPosAux2, 5] := nRecRCH
	EndIf
Else
	aPeriodo 	:= aClone( _aCarPer[nPosAux, 2] ) 
	nPosSem 	:= _aCarPer[nPosAux, 3]
	lUltSemana 	:= _aCarPer[nPosAux, 4]
	If !lGraMed
		RCH->(DbGoTo(_aCarPer[nPosAux, 5]))
	Else
		lRestRCH := .F.
	EndIf
EndIf

Return(.T.)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGetLastPer  ³Autor³Mauricio T. Takakura    ³Data³23/08/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retornar por Referencia o ultimo Periodo segundo Roteiro e	³
³          ³Processo.                                                 	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetLastPer( cLastPer		,;	// Por referencia, retorna o ultimo periodo em aberto
					  cLastNroPagto	,;	// Por referencia, retorna o Nro. de Pagamento do Ultimo Periodo em aberto
					  cProcesso		,;	// Processo a ser pesquisado - Obrigatorio
					  cRoteiro		,;	// Roteiro a ser pesquisado - Obrigatorio
					  lVldLstPer	,;	// Se deve validar se o proximo periodo apos o encontrado em aberto esta fechado.
					  lMsg			,;	// Se deve mostrar a mensagem com o erro encontrado 
  					  cLastAnoMes	,;	// Retorna a competencia a que se refere o ultimo periodo aberto
  					  cFilRCH		;	// Filial posicionado no RCH
					)

Local aArea 		:= GetArea()
Local aRCHArea 		:= RCH->( GetArea() )

Local cHelp

Local lRet

Local nPosReg

Local xRCHFil

DEFAULT cProcesso 	:= ""
DEFAULT cRoteiro	:= ""
DEFAULT cFilRCH		:= xFilial("RCH")
DEFAULT lMsg		:= .F.
DEFAULT lVldLstPer	:= .T.

xRCHFil := cFilRCH

Begin Sequence 

	If Empty( cProcesso ) .Or. Empty( cRoteiro )
		lRet := .F.
		Break
	EndIf

	DbSelectArea( "RCH" )
	DbSetOrder( 5 )			// RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+DTOS(RCH_DTFECH)+RCH_PER+RCH_NUMPAG
	DbSeek( xRCHFil + cProcesso + cRoteiro + Dtos(Ctod("//")), .F. )

	If !Eof() .and. RCH->( RCH_PROCES + RCH_ROTEIR + DTOS(RCH_DTFECH) ) == cProcesso + cRoteiro + Dtos(Ctod("//"))
		cLastPer		:= RCH->RCH_PER
		cLastNroPagto	:= RCH->RCH_NUMPAG
		cLastAnoMes	    := RCH->RCH_ANO + RCH->RCH_MES

		/*/		
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verificar se o proximo periodo esta fechado, pois no calculo nao eh permi³
		³ tido calcular com periodos futuros ja fechados.                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
		If lVldLstPer
			nPosReg := RCH->( Recno() )
			DbSetOrder( 4 )			// RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG
			RCH->( DbGoTo( nPosReg ) )

			RCH->( DbSkip() )
			If RCH->( RCH_FILIAL + RCH_PROCES + RCH_ROTEIR ) == ( xRCHFil + cProcesso + cRoteiro ) .and. !Empty( RCH->RCH_DTFECH )
				If lMsg
					cHelp := STR0001 + cLastPer + ", "					// "O Periodo: "
					cHelp += STR0002 + cLastNroPagto + ", "				// "Nro Pagamento: "
					cHelp += STR0003 + cProcesso + ", "					// "Processo: "
					cHelp += STR0004 + cRoteiro + " " + CRLF			// "Roteiro: "
					cHelp += STR0005 + " " + CRLF 						// "foi encontrado como sendo o proximo Periodo a ser processado, "
					cHelp += STR0006 									// "mas o Periodo subsequente ja foi Fechado!"
					MsgInfo( OemToAnsi( cHelp ), OemToAnsi( STR0007 ) )
					lRet := .F.
					Break
				EndIf
			EndIf
		EndIf
		lRet := .T.
	Else
		lRet := .F.
	EndIf

End Sequence

RestArea( aArea )
RestArea( aRCHArea )

Return( lRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fSetVarPer		³Autor³Mauricio Takakura  ³ Data ³27/09/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Atualiza o Valor das variaveis de Periodos com seus valores ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³cHtml  														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³GPER030       										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fSetVarPer( cVarProc, cValProc, cVarPer, cValPer, cVarNPago, cValNPago, cVarRot, cValRot )

If !Empty( cVarProc )
	&cVarProc := cValProc
EndIf
If !Empty( cVarPer )
	&cVarPer := cValPer
EndIf
If !Empty( cVarNPago )
    &cVarNPago := cValNPago
EndIf
If !Empty( cVarRot )
	&cVarRot := cValRot
EndIf
    
Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fPosPeriodo  ³Autor³Mauricio T. Takakura    ³Data³23/08/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Posiciona no Periodo de acordo com os parametros          	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fPosPeriodo( cFilRCH       ,;	// Filial 
					  cProcesso		,;	// Codigo do Processo a Pesquisar                    
					  cPeriodo     	,;	// Codigo do Periodo a Pesquisar 
					  cNroPago  	,;	// Nro de Pagamento
					  cRoteiro		,;	// Roteiro de Pagamento
					  cDataFech 	,;	// Data de Fechamento 
					  lRotBlank		,;	// @.t. - Retorna se o roteiro eh em branco ou nao
					  nOrdem		,;	// Ordem do Indice
					  cAnoMes		 ;	// Ano/Mes do periodo
					)

Local cChave		:= ""
Local cChaveBlank	:= ""
Local cRotBlank		:= Space( GetSx3Cache( "RCH_ROTEIR", "X3_TAMANHO" ) )

Local lRet

DEFAULT cFilRCH		:= xFilial( "RCH" )
DEFAULT cProcesso 	:= Space( GetSx3Cache( "RCH_PROCES", "X3_TAMANHO" ) )
DEFAULT cPeriodo	:= Space( GetSx3Cache( "RCH_PER", "X3_TAMANHO" ) )
DEFAULT cNroPago	:= Space( GetSx3Cache( "RCH_NUMPAG", "X3_TAMANHO" ) )
DEFAULT cRoteiro	:= Space( GetSx3Cache( "RCH_ROTEIR", "X3_TAMANHO" ) )
DEFAULT cDataFech 	:= DTOS( CTOD("//") )
DEFAULT nOrdem		:= 1
DEFAULT cAnoMes		:= ""

Begin Sequence 
	
	If Valtype( cDataFech ) == "D"
		cDataFech := DTOS( cDataFech )
	EndIf

	DbSelectArea( "RCH" )
	DbSetOrder( nOrdem )
	If nOrdem == 1	// RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR
	    cChave 		:= cFilRCH + cProcesso + cPeriodo + cNroPago + cRoteiro
	    cChaveBlank := cFilRCH + cProcesso + cPeriodo + cNroPago + cRotBlank
	ElseIf nOrdem == 2	// RCH_FILIAL+RCH_PROCES+RCH_PER+DTOS(RCH_DTFECH)+RCH_ROTEIR
		cChave 		:= cFilRCH + cProcesso + cPeriodo + cDataFech + cRoteiro
		cChaveBlank	:= cFilRCH + cProcesso + cPeriodo + cDataFech + cRotBlank
	ElseIf nOrdem == 3 	// RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+DTOS(RCH_DTFECH)+RCH_ROTEIR
		cChave 		:= cFilRCH + cProcesso + cPeriodo + cNroPago + cDataFech + cRoteiro
		cChaveBlank	:= cFilRCH + cProcesso + cPeriodo + cNroPago + cDataFech + cRotBlank
	ElseIf nOrdem == 4	// RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG
		cChave 		:= cFilRCH + cProcesso + cRoteiro  + cPeriodo + cNroPago
		cChaveBlank	:= cFilRCH + cProcesso + cRotBlank + cPeriodo + cNroPago
	ElseIf nOrdem == 5 	// RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+DTOS(RCH_DTFECH)+RCH_PER+RCH_NUMPAG
		cChave 		:= cFilRCH + cProcesso + cRoteiro  + cDataFech + cPeriodo + cNroPago
		cChaveBlank	:= cFilRCH + cProcesso + cRotBlank  + cDataFech + cPeriodo + cNroPago
	ElseIf nOrdem == 6 	// RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_ANO+RCH_MES+RCH_NUMPAG
		cChave 		:= cFilRCH + cProcesso + cRoteiro  + cAnoMes + cNroPago
		cChaveBlank	:= cFilRCH + cProcesso + cRotBlank  + cAnoMes + cNroPago
	EndIf		

	DbSeek( RTrim(cChave), .F.)
	If RCH->( Eof() )
		DbSeek( cChaveBlank, .F.)
		lRotBlank := .T.
	EndIf
	
	If !Eof()
		lRet := .T.
	Else
		lRet := .F.
	EndIf

End Sequence

Return( lRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetPerAtual	³Autor³Mauricio Takakura  ³ Data ³02/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna em um array o periodo atual de determinado roteiro	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fGetPerAtual( aPerAtual, cFilRCH, cProcesso, cRoteiro, lAllRot , lAuto, cPer, cSem )

Local aArea     := {}
Local lRet      := .T.
Local cRotTipo2 := ""
Local aRotTipo2 := {}
Local cRotMisto	:= ""
Local nCnt		:= 0
Local lPerSem   := .F.
Local nPosAux	:= 0

DEFAULT aPerAtual := {}
DEFAULT cFilRCH   := xFilial( "RCH" )
DEFAULT cProcesso := ""
DEFAULT cRoteiro  := ""
DEFAULT lAuto     := .F.

//Variavel sera utilizada para considerar todos os tipos do Roteiro
DEFAULT lAllRot   := .F.

DEFAULT cPer      := ""
DEFAULT cSem      := ""

If (nPosAux := aScan( _aPerAtu, { |x| x[1] == cFilRCH+cProcesso+cRoteiro } )) == 0
	aArea     	:= GetArea()
	cRotTipo2 	:= fGetTipoRot(cRoteiro)
	lPerSem 	:= !Empty( cPer + cSem )

	aRotTipo2 := fGetRotTipo(cRotTipo2)

	Begin Sequence

		DbSelectArea( "RCH")
		
		If !lPerSem
			DbSetOrder( RetOrder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PERSEL" ) )
		Else
			DbSetOrder( RetOrder( "RCH", "RCH_FILIAL+RCH_PER+RCH_NUMPAG+RCH_PROCES+RCH_ROTEIR+RCH_PERSEL" ) )
		EndIf

		If !lAllRot
			If !lPerSem
				DbSeek( cFilRCH + cProcesso + cRoteiro + "1", .F. )
			Else
				DbSeek( cFilRCH + cPer + cSem + cProcesso + cRoteiro + "1", .F. )
			EndIf

			If RCH->( Eof() )
				lRet := .F.
			EndIf
		Else
			If Len(aRotTipo2) > 1
				For nCnt := 1 to Len(aRotTipo2)
					cRotMisto := aRotTipo2[nCnt]
					
					If !lPerSem
						DbSeek( cFilRCH + cProcesso + cRoteiro + "1", .F. )
					Else
						DbSeek( cFilRCH + cPer + cSem + cProcesso + cRoteiro + "1", .F. )
					EndIf
		
					If RCH->( Eof() )
						lRet := .F.
						Exit
					EndIf
				Next nCnt
			Endif	
		Endif

		If lRet
			RCH->( aAdd( aPerAtual, { RCH_PER, RCH_NUMPAG, RCH_ROTEIR, RCH_MES, RCH_ANO, RCH_DTINI, RCH_DTFIM, RCH_PROCES, RCH_DTCORT, RCH_DTINTE, RCH_DTPAGO } ) )
			aAdd( _aPerAtu, { cFilRCH+cProcesso+cRoteiro, aClone(aPerAtual) } )
		ElseIf cPaisLoc <> "BRA" .AND. Funname() == "GPEA010"  .and. !lAuto
			MsgAlert(STR0015	+ CHR(10) + CHR(13) +					; // "No existe periodo de nómina seleccionado para "
					STR0016 	+ cFilRCH 	 	+ CHR(10) + CHR(13) + 	; // "Sucursal: "
					STR0017 	+ cProcesso	+ CHR(10) + CHR(13) + 		; // "Proceso: "
					STR0018 	+ cRoteiro)		// "Procedimiento: "
		EndIf

	End Sequence

	RestArea( aArea )
Else
	aAdd( aPerAtual, aClone( _aPerAtu[nPosAux, 2, 1] ) )
EndIf

Return( lRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fRetPerComp		³Autor³Mauricio Takakura  ³ Data ³04/04/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna array periodos abertos e fechados de uma competencia³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fRetPerComp(cMes		,;		//Obrigatorio - Mes para localizar as informacoes
						cAno		,;		//Obrigatorio - Ano para localizar as informacoes
						cRCHFil	,;		//Opcional - Filial a Pesquisar
						cProcesso	,;		//Obrigatorio - Filtro por Processo
						cRoteiro	,;		//Opcional - Filtro por Roteiro
						aPerAberto	,;		//Por Referencia - Array com os periodos Abertos
						aPerFechado,;		//Por Referencia - Array com os periodos Fechados
						aPerTodos  ,;		//Por Referencia - Array com os periodos Abertos e Fechados em Ordem Crescente
						lVerific   ,;    //Opcional - Verifica se a chamada da função veio do GPER050.
						dDataDe    ,;    //Opcional - Caso a chamada da função vier do GPER050 verifica a data incial de pagamento.
						dDataAte   ,;    //Opcional - Caso a chamada da função vier do GPER050 verifica a data final de pagamento.
						lTodosPer   ;    //Se .T. não filtra pela filial
						 )

Local aArea			:= GetArea()
Local cAliasRCH 	:= ""
Local cWhereRCH   	:= ""
Local cCamposRCH  	:= "" 
Local nCnt

DEFAULT cRCHFil		:= xFilial("RCH")
DEFAULT cProcesso 	:= ""
DEFAULT cRoteiro	:= ""
DEFAULT lVerific    := .F.
DEFAULT dDataDe     := cToD("//")
DEFAULT dDataAte    := cToD("//")
DEFAULT lTodosPer   := .F.

If Empty(cMes) .Or. Empty(cAno)
	Return(NIL)
EndIf

aPerAberto 	:= {}
aPerFechado	:= {}

If !lVerific //Chamada da função não veio do GPER050
	If !lTodosPer 
		cAliasRCH := "RCH"
		dbSelectArea(cAliasRCH)
		DbSetOrder(RetOrder("RCH", "RCH_FILIAL+RCH_ANO+RCH_MES"))	// Ordem 4
		DbSeek( cRCHFil+cAno+cMes, .F. )
		While RCH->( !Eof() ) .and. RCH->( RCH_FILIAL + RCH_ANO + RCH_MES ) == cRCHFil + cAno + cMes

			If 	(!Empty(cProcesso) .And. RCH->RCH_PROCES <> cProcesso) .Or.;
				(!Empty(cRoteiro) .and. RCH->RCH_ROTEIR <> cRoteiro)
				RCH->( DbSkip() )
				Loop
			EndIf
		
			If Empty( RCH->RCH_DTFECH )
				aAdd(aPerAberto	, RCH->({RCH_PER, RCH_NUMPAG, RCH_MES, RCH_ANO, RCH_DTINI, RCH_DTFIM, RCH_PROCES, RCH_ROTEIR, RCH_DTPAGO, RCH_DTCORT, RCH_DTINTE, RCH_COMPL, RCH_PERSEL }))
			Else
				aAdd(aPerFechado, RCH->({RCH_PER, RCH_NUMPAG, RCH_MES, RCH_ANO, RCH_DTINI, RCH_DTFIM, RCH_PROCES, RCH_ROTEIR, RCH_DTPAGO, RCH_DTCORT, RCH_DTINTE, RCH_COMPL, RCH_PERSEL }))
			EndIf

			RCH->( DbSkip() )
		EndDo
	Else
		cAliasRCH  := GetNextAlias()
		
		cCamposRCH := "%RCH_DTPAGO, RCH_PER, RCH_NUMPAG, RCH_MES, RCH_ANO, "
		cCamposRCH += "RCH_DTINI, RCH_DTFIM, RCH_DTFECH, RCH_PROCES, RCH_ROTEIR, "
		cCamposRCH += "RCH_DTPAGO, RCH_DTCORT, RCH_DTINTE, RCH_COMPL, RCH_PERSEL%"
		
		cWhereRCH := " RCH.RCH_ANO = '" + cAno + "' "
		cWhereRCH += " AND RCH.RCH_MES = '" + cMes + "' "
		
		If !Empty(cProcesso)
			cWhereRCH += " AND RCH.RCH_PROCES = '" + cProcesso + "' "
		EndIf

		If !Empty(cRoteiro)
			cWhereRCH += " AND RCH.RCH_ROTEIR = '" + cRoteiro + "' "
		EndIf

		cWhereRCH := "%" + cWhereRCH + "%"		
		
		BeginSql alias cAliasRCH
			SELECT DISTINCT %Exp:cCamposRCH% 
			FROM  %Table:RCH% RCH
			WHERE %Exp:cWhereRCH% AND RCH.%NotDel%
			ORDER BY 6,5 //Ordenação por ano e mês
		EndSql

		If ((cAliasRCH)->( !EOF() ))
			While (cAliasRCH)->( !EOF() )
				If Empty( (cAliasRCH)->RCH_DTFECH )
					aAdd(aPerAberto, (cAliasRCH)->({RCH_PER, RCH_NUMPAG, RCH_MES, RCH_ANO, RCH_DTINI, RCH_DTFIM, RCH_PROCES, RCH_ROTEIR, RCH_DTPAGO, RCH_DTCORT, RCH_DTINTE, RCH_COMPL, RCH_PERSEL}))
				Else
					aAdd(aPerFechado, (cAliasRCH)->({RCH_PER, RCH_NUMPAG, RCH_MES, RCH_ANO, RCH_DTINI, RCH_DTFIM, RCH_PROCES, RCH_ROTEIR, RCH_DTPAGO, RCH_DTCORT, RCH_DTINTE,RCH_COMPL, RCH_PERSEL}))
				EndIf
				(cAliasRCH)->( DbSkip() )
			EndDo

			(cAliasRCH)->(DbCloseArea())
		EndIf
	EndIf
Else //Chamada da função veio do GPER050.
	//Montando a Query
	
	cAliasRCH  := GetNextAlias()
	
	cCamposRCH := "%RCH_FILIAL, RCH_DTPAGO, RCH_PER, RCH_NUMPAG, RCH_MES, RCH_ANO, "
	cCamposRCH += "RCH_DTINI, RCH_DTFIM, RCH_DTFECH, RCH_PROCES, RCH_ROTEIR, "
	cCamposRCH += "RCH_DTPAGO, RCH_DTCORT, RCH_DTINTE, RCH_COMPL%"
	
	cWhereRCH := "%RCH.RCH_FILIAL ='" + cRCHFil + "' AND "
	cWhereRCH += "RCH.RCH_DTPAGO >= '"     + dToS(dDataDe) + "' AND "
	cWhereRCH += "RCH.RCH_DTPAGO <= '"  + dToS(dDataAte) + "'%"
	
	
	BeginSql alias cAliasRCH
		SELECT %exp:cCamposRCH% 
		FROM  %table:RCH% RCH
		WHERE %exp:cWhereRCH% AND RCH.%notDel%
	EndSql

	if((cAliasRCH)->( !Eof() ))
		While (cAliasRCH)->( !Eof() )
			If Empty( (cAliasRCH)->RCH_DTFECH )
				aAdd(aPerAberto, (cAliasRCH)->({RCH_PER, RCH_NUMPAG, RCH_MES, RCH_ANO, RCH_DTINI, RCH_DTFIM, RCH_PROCES, RCH_ROTEIR, RCH_DTPAGO, RCH_DTCORT, RCH_DTINTE, RCH_COMPL}))
			Else
				aAdd(aPerFechado, (cAliasRCH)->({RCH_PER, RCH_NUMPAG, RCH_MES, RCH_ANO, RCH_DTINI, RCH_DTFIM, RCH_PROCES, RCH_ROTEIR, RCH_DTPAGO, RCH_DTCORT, RCH_DTINTE,RCH_COMPL}))
			EndIf
			(cAliasRCH)->( DbSkip() )
		EndDo
		(cAliasRCH)->(DbCloseArea())
	EndIf
EndIf

If aPerTodos # Nil
	aPerTodos := {}
	If Len(aPerAberto) > 0 .And. Len(aPerFechado) > 0
		aPerTodos := aClone(aPerAberto)
		For nCnt := 1 To Len( aPerFechado )
			If aScan( aPerTodos, { |x| x[1]+x[8] == aPerFechado[nCnt,1]+aPerFechado[nCnt,8] } ) == 0
				aAdd( aPerTodos, ACLONE(aPerFechado[nCnt]) )
			EndIf
		Next nCnt
	ElseIf Len(aPerAberto) > 0
		aPerTodos := aClone( aPerAberto )
	ElseIf Len(aPerFechado) > 0
		aPerTodos := aClone( aPerFechado )
	EndIf
	aSort( aPerTodos,,, { |x,y| x[1] < y[1] } )
EndIf

RestArea( aArea )

Return ( NIL )


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fRetroPer ºAutor  ³Tiago Malta         º Data ³  29/12/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                   	  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function fRetroPer( dData , nQretro , cTipopag ,cProcess )

Local dDataper 	:= Substr(dtos(dData),1,6)
Local uValid    := { || ( RCH->RCH_DTINI <= dData .and. RCH->RCH_DTFIM >= dData .and. RCH->RCH_PROCES == cProcess ) } 
Local aPeriod   := {}
Local lAchou 	:= .T.

	If cTipopag == NIL
		cTipopag := SRA->RA_TIPOPGT
	EndIf             
	
	If cProcess == NIL
		cProcess := SRA->RA_PROCES
	EndIf

	RCH->(DbSetOrder(7))
	RCH->(DbSeek(xfilial("RCH")+dDataper)) 
  
	If 	!Eval(uValid)
		While RCH->( !EOF() )			
			If Eval(uValid)
				lAchou := .T.
				Exit
			EndIf
			RCH->( DbSkip() )
		EndDo   
	Else  
		lAchou := .T.
	EndIf
         
	If lAchou		
		RCH->(DbSkip(-1))
		
		While !RCH->(bof()) .and. Len(aPeriod) <= (nQretro - 1)
        	aAdd(aPeriod , { RCH->RCH_PER , RCH->RCH_NUMPAG , RCH->RCH_PROCES , RCH->RCH_ROTEIR , RCH->RCH_MES , RCH->RCH_ANO , RCH->RCH_DTINI , RCH->RCH_DTFIM , RCH->RCH_DTPAGO } )
		  	RCH->(DbSkip(-1))		
		Enddo
	EndIf
	
Return( aPeriod )

/*/{Protheus.doc}fPerFech
Retorna o último período fechado de determinado processo e roteiro
@author Gabriel de Souza Almeida
@since 02/06/2016
@version P12
/*/
Function fPerFech( cProcess, cRot, cFil, aPerAtual )

	Local aArea := GetArea()
	Local cRet  := ""
	Local nPos	:= 0
	
	Default cProcess := ""
	Default cRot     := ""
	Default cFil     := xFilial("RCH")
	Default aPerAtual	:= {}
	
	If (nPos := aScan( _aCarFec, { |x| x[1] == xFilial("RCH", cFil)+cProcess+cRot } ) ) == 0
		DbSelectArea("RCH")
		RCH->(DbSetOrder(4)) //RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG
		If RCH->(DbSeek(xFilial("RCH", cFil) + cProcess + cRot))
			While !(RCH->( EOF() )) .And. !(Empty(RCH_DTFECH))
				RCH->(DbSkip())
			EndDo
		EndIf
		
		RCH->(DbSkip(-1))
		cRet := RCH->RCH_PER
		
		RCH->( aAdd( aPerAtual, { RCH_PER, RCH_NUMPAG, RCH_ROTEIR, RCH_MES, RCH_ANO, RCH_DTINI, RCH_DTFIM, RCH_PROCES, RCH_DTCORT, RCH_DTINTE, RCH_DTPAGO } ) )
		RCH->(DbCloseArea())

		aAdd( _aCarFec, { xFilial("RCH", cFil)+cProcess+cRot, aClone(aPerAtual) } )

		RestArea(aArea)
	Else
		aAdd( aPerAtual, aClone( _aCarFec[nPos, 2, 1] ) )
		cRet := _aCarFec[nPos, 2, 1, 1]
	EndIf
	
Return( cRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fHTrabCalen    ºAutor  ³M. Silveira      º Data ³  26/01/2017 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Carrega horas normais e descanso do Horista conforme a tabela º±±
±±º        ³de horario do Ponto                                           º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiro de Calculo                                            º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fHTrabCalen( dIni, dFim, lAltera, lProp )

Local nConDSR		:= 0
Local nDSRDom		:= 0
Local nLenTab		:= 0
Local nTUteis2	    := 0
Local nTNUteis2	    := 0
Local nDSRDom2	    := 0
Local Normal2		:= 0
Local Desc2		    := 0
Local aTabPadrao	:= {}
Local aTabCAux 	    := {}
Local aAux	   		:= {}
Local aArea 		:= GetArea() 
Local lDSRTab		:= GetMvRH("MV_DSRTAB",, .F.)
Local lDSRHorista	:= GetMvRH("MV_DSRHORI",,.F.)
Local lDSRHE		:= IsInCallStack("CalDsrHex")		//DSR de Hora Extra
Local lCargaIni     := IsInCallStack("S_CARGARCH")
Local nHrsDSR 	    := HrsSem2OneDsr( SRA->RA_HRSEMAN )
Local nBkpNormal    := 0 // Backup Variavel Normal
Local nBkpDesc      := 0 // Backup Variavel Descanso
Local nBkpDUt	    := 0 // Backup Variavel Dias Uteis
Local nBkpDNUt		:= 0 // Backup Variavel Dias Não uteis
Local nHTbPon       := 0
Local nHDsPon       := 0
Local nHrsDSR2		:= 0 //Horas de DSR conforme Horario do Ponto
Local lDSRTbPd		:= If( Type("P_NDSRHORI") == "U", .F., P_NDSRHORI == 3 ) //Obtem as horas de DSR da tabela de horario padrao

DEFAULT lAltera := .F. // Variavel que controlará se a chamada da função veio da formula SALDOSAL.
DEFAULT lProp   := .F. // Variavel que controlará se o retorno das horas trabalhadas e de DSR será proporcional, desconsiderando qualquer afastamento.


If CriaCalend(	dIni 			,;	//01 -> Data Inicial do Periodo
				dFim			,;	//02 -> Data Final do Periodo
				SRA->RA_TNOTRAB	,;	//03 -> Turno Para a Montagem do Calendario
				SRA->RA_SEQTURN	,;	//04 -> Sequencia Inicial para a Montagem Calendario
				@aTabPadrao		,;	//05 -> Array Tabela de Horario Padrao
				@aAux			,;	//06 -> Array com o Calendario de Marcacoes
				SRA->RA_FILIAL  ,;	//07 -> Filial para a Montagem da Tabela de Horario
				SRA->RA_MAT   	,;	//08 -> Matricula para a Montagem da Tabela de Horario
				SRA->RA_CC   	,;	//09 -> Centro de Custo para a Montagem da Tabela
				NIL				,;	//10 -> Array com as Trocas de Turno
				NIL				,;	//11 -> Array com Todas as Excecoes do Periodo
				NIL				,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
				.T.				,;	//13 -> Se executa a funcao se sincronismo do calendario (Default .T.)
				.F.			 	;	//14 -> Se Forca a Criacao de Novo Calendario
				)
				
		//Adiciona a primeira entrada dos dias no array auxiliar aTabCAux
	aEval( aAux, { |x| If( x[4] == "1E", aAdd( aTabCAux, aClone(x) ), Nil)  } )		

	If lAltera
		nBkpNormal := Normal
		nBkpDesc   := Descanso
		nBkpDUt    := nTUteis
		nBkpDNUt   := nTNUteis
		Normal 	    := 0
		Descanso 	:= 0
		nTUteis 	:= 0
		nTNUteis 	:= 0
		nHrsDSR2	:= 0
	Else
		Normal 	    := 0
		Descanso 	:= 0
		nTUteis 	:= 0
		nTNUteis 	:= 0
		nHrsDSR2	:= 0
	EndIf

	If !lDSRHE
		If !lAltera
			//Se o dia for do tipo Trabalhado*Compensado*Nao trabalhado, conta como dia util
			aEval( aTabCAux, 	{ |x| If( x[6] $ "S*C*N" .And. x[24] == .F., nTUteis++, Nil ) } )
			//Se o dia for do tipo  DSR*Feriado e nao estiver afastado, conta como dia nao util
			aEval( aTabCAux, 	{ |x| If( x[6] $ "D*F" .And. x[24] == .F., nTNUteis++, Nil ) } )
			//Se o dia for do tipo  DSR e nao estiver afastado, conta como dia nao util
			aEval( aTabCAux, 	{ |x| If( x[6] == "D" .And. x[24] == .F., nDSRDom++, Nil ) } )
			//Apura as horas de trabalho previstas dos dias de tipo Trabalhado*Compensado
			aEval( aAux, 		{ |x| If( x[6] == "S", Normal := __TimeSum( Normal, x[7] ), Nil ) } )
			//Se o dia for do tipo Trabalhado*Compensado*Nao trabalhado, conta como dia util
			aEval( aTabCAux, 	{ |x| If( x[36] $ "S*C*N" .And. x[19] == .F., nTUteis2++, Nil ) } )
			//Se o dia for do tipo  DSR*Feriado e nao estiver afastado, conta como dia nao util
			aEval( aTabCAux, 	{ |x| If( x[36] $ "D*F" .Or. x[19] == .T., nTNUteis2++, Nil ) } )
			//Se o dia for do tipo  DSR e nao estiver afastado, conta como dia nao util
			aEval( aTabCAux, 	{ |x| If( x[36] == "D" .Or. x[19] == .T., nDSRDom2++, Nil ) } )
			//Apura as horas de trabalho previstas dos dias de tipo Trabalhado*Compensado
			aEval( aAux, 		{ |x| If( x[36] == "S" .And. x[6] <> "F", Normal2 := __TimeSum( Normal2, x[7] ), Nil ) } )
			//Se o dia for do tipo  DSR*Feriado apura as horas de DSR
			If lDSRTbPd
				aEval( aAux, 	{ |x| If( x[36] $ "D", nHrsDSR2 := __TimeSum( nHrsDSR2, x[7] ), Nil ) } )
			EndIf
		Else
			//Se o dia for do tipo Trabalhado*Compensado*Nao trabalhado, conta como dia util
			aEval( aTabCAux, 	{ |x| If( x[6] $ "S*C*N" .And. x[24] == .F., nTUteis++, Nil ) } )
			//Se o dia for do tipo  DSR*Feriado e nao estiver afastado, conta como dia nao util
			aEval( aTabCAux, 	{ |x| If( x[6] $ "D*F" .And. x[24] == .F., nTNUteis++, Nil ) } )
			//Se o dia for do tipo  DSR e nao estiver afastado, conta como dia nao util
			aEval( aTabCAux, 	{ |x| If( x[6] == "D" .And. x[24] == .F., nDSRDom++, Nil ) } )
			//Apura as horas de trabalho previstas dos dias de tipo Trabalhado*Compensado
			aEval( aAux, 		{ |x| If( x[6] == "S", nHTbPon := __TimeSum( nHTbPon, x[7] ), Nil ) } )
			//Se o dia for do tipo Trabalhado*Compensado*Nao trabalhado, conta como dia util
			aEval( aTabCAux, 	{ |x| If( x[36] $ "S*C*N" .And. x[19] == .F., nTUteis2++, Nil ) } )
			//Se o dia for do tipo  DSR*Feriado e nao estiver afastado, conta como dia nao util
			aEval( aTabCAux, 	{ |x| If( x[36] $ "D*F" .Or. x[19] == .T., nTNUteis2++, Nil ) } )
			//Se o dia for do tipo  DSR e nao estiver afastado, conta como dia nao util
			aEval( aTabCAux, 	{ |x| If( x[36] == "D" .Or. x[19] == .T., nDSRDom2++, Nil ) } )
			//Apura as horas de trabalho previstas dos dias de tipo Trabalhado*Compensado
			aEval( aAux, 		{ |x| If( x[36] == "S" .And. x[6] <> "F", Normal2 := __TimeSum( Normal2, x[7] ), Nil ) } )
			//Se o dia for do tipo  DSR*Feriado apura as horas de DSR
			If lDSRTbPd
				aEval( aAux,	{ |x| If( x[36] $ "D", nHrsDSR2 := __TimeSum( nHrsDSR2, x[7] ), Nil ) } )
			EndIf
		EndIf
	Else
		//Se o dia for do tipo Trabalhado*Compensado*Nao trabalhado, conta como dia util
		aEval( aTabCAux, 	{ |x| If( x[36] $ "S*C*N" .And. x[19] == .F., nTUteis++, Nil ) } )
		//Se o dia for do tipo  DSR*Feriado e nao estiver afastado, conta como dia nao util
		aEval( aTabCAux, 	{ |x| If( x[36] $ "D*F" .Or. x[19] == .T., nTNUteis++, Nil ) } )
		//Se o dia for do tipo  DSR e nao estiver afastado, conta como dia nao util
		aEval( aTabCAux, 	{ |x| If( x[36] == "D" .Or. x[19] == .T., nDSRDom++, Nil ) } )
		//Apura as horas de trabalho previstas dos dias de tipo Trabalhado*Compensado
		aEval( aAux, 		{ |x| If( x[36] == "S", Normal2 := __TimeSum( Normal2, x[7] ), Nil ) } )			
		//Se o dia for do tipo DSR apura as horas de DSR
		If lDSRTbPd
			aEval( aAux,	{ |x| If( x[36] $ "D", nHrsDSR2 := __TimeSum( nHrsDSR2, x[7] ), Nil ) } )
		EndIf
	EndIf

	//DSR total apurado conforme as horas da tabela de horario padrao
	If nHrsDSR2 > 0
		nHrsDSR := nHrsDSR2
		If !lAltera .and. Normal > 0
			Descanso := nHrsDSR
		Else
			nHDsPon := nHrsDSR
		EndIf
	EndIf

	//Apura o DSR multiplicando o valor de um DSR pela qtde de DSR
	//Se houver um feriado, paga o DSR de acordo com a qtde de horas que estava prevista
	If lDSRTab
		
		//Apura o total de DSR, de acordo com a quantidade de DSR X horas de um DSR (quando nao traz o DSR da tabela)
		If !lDSRTbPd
			For nConDSR := 1 To nDSRDom
				If !lAltera
					Descanso := __TimeSum( Descanso, nHrsDSR )
				Else
					nHDsPon := __TimeSum( nHDsPon, nHrsDSR )
				EndIf
			Next nConDSR
		EndIf
		
		//Apura o total de DSR, de acordo com a quantidade de DSR X horas de um DSR
		For nLenTab := 1 To Len(aTabCAux)
			//Se for feriado, verifica se ha horas previstas de trabalho,
			//caso contrario, considera as horas padrao de um DSR
			If ( !lDSRHE .And. aTabCAux[nLenTab, 6] == "F" .And. aTabCAux[nLenTab, 24] == .F. ) .Or. ( lDSRHE .And. ( aTabCAux[nLenTab, 36] == "F" .Or. aTabCAux[nLenTab, 19] == .T. ) )
				nHorasFer := 0
				aEval( aAux, { |x| If( x[1] == aTabCAux[nLenTab, 1], nHorasFer := __TimeSum( nHorasFer, x[7] ), Nil ) } )
				If nHorasFer > 0
					If !lAltera
						Descanso := __TimeSum( Descanso, nHorasFer )
					Else
						nHDsPon := __TimeSum( nHDsPon, nHorasFer )
					EndIf
				Else
					If !lAltera
						Descanso := __TimeSum( Descanso, nHrsDSR )						
					Else
						nHDsPon := __TimeSum( nHDsPon, nHrsDSR )						
					EndIf
				EndIf
			EndIf
		Next nConDSR
	//Apura o DSR multiplicando o valor de um DSR pela qtde de dias nao uteis
	Else
		//Apura o total de DSR, de acordo com a quantidade de dias nao uteis X horas de um DSR
		If !lDSRTbPd
			For nConDSR := 1 To nTNUteis
				If !lAltera
					Descanso := __TimeSum( Descanso, nHrsDSR )
				Else
					nHDsPon := __TimeSum( nHDsPon, nHrsDSR )
				EndIf
			Next nConDSR
		EndIf
	EndIf

	If !lDSRHE
		//Calcula DSR com base nas horas trabalhadas e dias uteis
		If !lDSRTbPd
			If lDSRHorista
				nHrsDSR := Int( Normal2 / nTUteis2 )
				nHrsDSR += ( ( Normal2 / nTUteis2 - nHrsDSR ) * 60 ) / 100
			EndIf
		EndIf
		
		//Apura o DSR multiplicando o valor de um DSR pela qtde de DSR
		//Se houver um feriado, paga o DSR de acordo com a qtde de horas que estava prevista
		If lDSRTab
			//Apura o total de DSR, de acordo com a quantidade de DSR X horas de um DSR
			If !lDSRTbPd
				For nConDSR := 1 To nDSRDom2
					Desc2 := __TimeSum( Desc2, nHrsDSR )
				Next nConDSR
			Else
				Desc2 := __TimeSum( Desc2, nHrsDSR )
			EndIf
			
			//Apura o total de DSR, de acordo com a quantidade de DSR X horas de um DSR
			For nLenTab := 1 To Len(aTabCAux)
				//Se for feriado, verifica se ha horas previstas de trabalho,
				//caso contrario, considera as horas padrao de um DSR
				If aTabCAux[nLenTab, 6] == "F" .And. aTabCAux[nLenTab, 24] == .F.
					nHorasFer := 0
					aEval( aAux, { |x| If( x[1] == aTabCAux[nLenTab, 1], nHorasFer := __TimeSum( nHorasFer, x[7] ), Nil ) } )
					If nHorasFer > 0
						Desc2 := __TimeSum( Desc2, nHorasFer )
					Else
						Desc2 := __TimeSum( Desc2, nHrsDSR )						
					EndIf
				EndIf
			Next nConDSR
		//Apura o DSR multiplicando o valor de um DSR pela qtde de dias nao uteis
		ElseIf !lProp .And. !lDSRTbPd
			//Apura o total de DSR, de acordo com a quantidade de dias nao uteis X horas de um DSR
			If !lDSRTbPd
				For nConDSR := 1 To nTNUteis2
					Desc2 := __TimeSum( Desc2, nHrsDSR )
				Next nConDSR
			EndIf
		ElseIf lProp .And. !lDSRTbPd
			//Apura o total de DSR, de acordo com a quantidade de dias nao uteis X horas de um DSR enquanto o funcionário está ativo.
			For nConDSR := 1 To nTNUteis
				Desc2 := __TimeSum( Desc2, nHrsDSR )
			Next nConDSR
		ElseIf lDSRTbPd
			Desc2 := nHrsDSR
		EndIf
	EndIf

	//Transforma hora sexagesimal em centesimal, igual ao conceito do SIGAPON
	nPonTrab := Normal   := fConvHr(Normal, "D")  
	nPonDesc := Descanso := fConvHr(Descanso, "D")  		

	// Quando o lAltera for .F., os valores da Normal e Descanso serão 0. logo, será utilizada a Normal2 e a Desc2 para o cálculo.
	If !lDSRHE .And. ( ( Normal + Descanso ) == 0 .or. lCargaIni ) .and. !lProp
		nPonTrab := fConvHr(Normal2, "D")
		nPonDesc := fConvHr(Desc2, "D")
	ElseIf !lDSRHE .And. ( Normal + Descanso ) == 0 .and. lProp
		nPonTrab := fConvHr(nHTbPon, "D")
		nPonDesc := fConvHr(Desc2, "D")
	EndIf
	
	If lAltera
		Normal   := nBkpNormal
		Descanso := nBkpDesc
		nTUteis  := nBkpDUt
		nTNUteis := nBkpDNUt
	EndIf

EndIf

RestArea( aArea )

Return()

/*/{Protheus.doc} function_method_class_name
Calcula as horas normais e de descanço para funcionários com contrato intermitente.
@author cicero.pereira
@since 27/12/2017
@version 12.1.17
@param Normal, numérico, Horas normais da convocação, deve ser passada por referência
@param Descanso, numérico, Horas de DSR da convocação, deve ser passada por referência
/*/
Function DiaDSRInte(Normal, Descanso)
	
	Local dInicio	:= ACONVOCACAO[2]
	Local dFim		:= ACONVOCACAO[3]
	Local nDiasDSR	:= 0
	Local aDados	:= aClone(aPeriodo[1,5])
	Local nX		:= 0
	
	Normal := 0
	Descanso := 0
	
	For nX := 1 to Len(aDados)
		If aDados[nX,1] >= dInicio .and. aDados[nX,1] <= dFim .and. aDados[nX,2] $ "3*4"
			nDiasDSR++
		EndIf
	Next nX
	
	Normal := (ACONVOCACAO[5] - nDiasDSR) * ACONVOCACAO[7]
	Descanso := nDiasDSR * ACONVOCACAO[7]
	
Return

/*/{Protheus.doc} fNextPer
//Proximo periodo
@author flavio.scorrea
@since 12/02/2019
/*/
Function fNextPer(cProc,cMes,cRotRch)
Local aArea		:= GetArea()
Local cAliasTMp	:= GetNextAlias()
Local nRecno	:= 0

BeginSql alias cAliasTMp
	SELECT R_E_C_N_O_ AS RECNO
	FROM  %table:RCH% RCH
	WHERE RCH.%notDel%
		AND RCH.RCH_FILIAL = %exp:xFilial("RCH")%
		AND RCH.RCH_ROTEIR = %exp:cRotRch%
		AND RCH.RCH_PER > %exp:cMes%
		AND RCH.RCH_PROCES = %exp:cProc%
	ORDER BY RCH_PER,RCH_NUMPAG
EndSql

If !(cAliasTMp)->(eof())
	nRecno := (cAliasTMp)->RECNO
EndIf

(cAliasTMp)->(dbCloseArea())
RestArea(aArea)
Return nRecno

/*/{Protheus.doc} RstaPerAtu
Reiniciar a variável _aPerAtu
@author Allyson Luiz Mesashi
@since 05/01/2023
/*/
Function RstaPerAtu()

_aPerAtu 	:= {}

Return( Nil )
