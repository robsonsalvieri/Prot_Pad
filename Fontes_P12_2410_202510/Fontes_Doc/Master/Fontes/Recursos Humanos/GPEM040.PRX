#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "GPEM040A.CH"
#INCLUDE "vkey.ch"

Static aFerPag		:= {}
Static _aCodFol		:= {}
Static aPd_SRK		:= {}
Static aStructSRG
Static aSPBRec
Static aPdRAW
Static cRfyTpAv
Static cTpAvBkp
Static cOpcCompl	:= "1"
Static cIdHistMed 	:= ""
Static _BkpFilial	:= ""
Static lTemRFY
Static lDtDemRFY
Static lAvMsg
Static lGestPubl
Static lIntTaf
Static lMiddleware
Static __lMemCalc
Static lCancelCalc	:= .T.
Static lAtuBrowse	:= .F.
Static lVlEsocDif	:= .F.
Static lCtrlTit
Static lConsig
Static lCpoFlagIC
Static lVerMultv
Static lTemPostUmT
Static lTemSeqMV
Static lTemTpRem
Static lTribIR
Static lMvRHNG
Static lVNaoApl
Static lRDisOrig
Static nVal1904		:= 0
Static lTemRU6
Static lTemFerDesc
Static lCpoReint

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ GPEM040  ³ Autor ³ Leandro Drumond                ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Calculo de Rescisao                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GPEM040()                                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Esecifico                                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³            ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data     ³ FNC         ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Raquel Hager³17/07/2014³TPZUCK       ³Inclusao de replicas versao 11  com itens ³±±
±±³            ³          ³             ³do eSocial.					           ³±±
±±³Christiane V³24/07/2014³TQCNUA       ³Correção de erros no cálculo da rescisão. ³±±
±±³Emerson Camp³19/08/2014³TQGBQ6       ³Inclusao da funcao fVldAccess na funcao   ³±±
±±³            ³          ³             ³CalResc para validar de per. bloqueado.   ³±±
±±³Gustavo M.  ³24/09/2014³TQQNS7       ³Ajuste na verificacao do tipo de aviso.   ³±±
±±³Allyson M.  ³27/01/2015³TRGSDH       ³Ajuste p/ calculo quando ha rateio p/     ³±±
±±³            ³          ³             ³respeitar o item/classe cadastrado.   	   ³±±
±±³Flavio Corr ³19/03/15  ³PCREQ-4163   ³Integração Mensagem Unica                 ³±±
±±³Renan Borges³22/06/2015³TSQYRQ       ³Ajuste p/ não gerar error.log ao preencher³±±
±±³            ³          ³             ³o tipo de rescisão.                 	   ³±±
±±³L.Ttrombini ³16/07/2015³TSSFG7       ³Ajuste p/ Não calcular os dias de Aviso   ³±±
±±³            ³          ³             ³Previo quando tipo de Rescisão estiver com³±±
±±³            ³          ³             ³Aviso Previo = "N" 					   ³±±
±±³Christiane V³29/07/2015³PCDEF-52364  ³Inclusão de validações para o eSocial     ³±±
±±³Mariana M.  ³08/09/2015³TSYCQ6       ³Ajuste na função GP40DiasAv (calculo de   ³±±
±±³            ³          ³             ³data e Aviso Previo)p/ quando não utilizar³±±
±±³            ³          ³             ³o cadastro de aviso prévio, o sistema cal-³±±
±±³            ³          ³             ³cule a data de aviso prévio corretamente  ³±±
±±³            ³          ³             ³(30 dias antes da demissao)			   ³±±
±±³Flavio Corr.³22/09/2015³TTKNAO       ³Integração com ponto                      ³±±
±±³            ³          ³	            ³				                           ³±±
±±³Matheus M.  ³23/09/2015³TTJLK4       ³Ajuste para trazer o tipo de rescisão     ³±±
±±³            ³          ³	            ³quando a solicitacao é efetuada pelo	   ³±±
±±³            ³          ³	            ³portal.		                           ³±±
±±³Renan Borges³19/10/2015³TTOW08       ³Ajuste para que ao preencher a data de de-³±±
±±³            ³          ³             ³missão de um autonomo, quando seu processo³±±
±±³            ³          ³             ³ não possui periodo de rescisão, não seja ³±±
±±³            ³          ³             ³gerado error.log.                         ³±±
±±³Mariana M.  ³05/11/2015³TTRRQX       ³Ajuste na função GP40VldTpRes e fSRGWhen  ³±±
±±³            ³          ³             ³para que o sistema possa deixar o campo de³±±
±±³            ³          ³             ³Data de Aviso Previo habilitado e carregar³±±
±±³            ³          ³             ³data quando o aviso for Indenizado	       ³±±
±±³Cecilia Carv³02/12/2015³PCDEF-86584  ³Ajuste para nao deixar gravar a rescisao  ³±±
±±³            ³          ³             ³sem ter efetuado o calculo antes.         ³±±
±±³Cecilia Carv³03/12/2015³PCDEF-86584  ³Inclusao de linhas que foram retiradas in-³±±
±±³            ³          ³             ³devidamente.                              ³±±
±±³M. Silveira ³10/12/2015³TTXUZU       ³Ajuste na mensagem de exibida ao calcular ³±±
±±³            ³          ³             ³estagiario sem recesso cadastrado.        ³±±
±±³Cícero Alves³28/12/2015³TUBXVA       ³Correção nas chamadas da função fGetCodFol³±±
±±³            ³          ³             ³      									   ³±±
±±³Cícero Alves³28/12/2015³TUBURI       ³Ajuste p/ deducao das faltas lancadas na  ³±±
±±³            ³          ³             ³tabela RGB		                           ³±±
±±³Cícero Alves³06/01/2016³PCREQ-9091  	³Ajuste para criar opcao de bloqueio para  ³±±
±±³            ³          ³             ³readmissão.                               ³±±
±±³Raquel Hager³07/01/2016³TTTON9    	³Valida bloqueio de periodos para exclusao.³±±
±±³Raquel Hager³08/01/2016³TTTON9    	³Inclusao da validao no if de EXCLUSAO.	   ³±±
±±³Allyson M.  ³12/01/2015³TUEKJH       ³Ajuste p/ desabilitar a edicao dos campos ³±±
±±³            ³          ³             ³de salario do cabecalho da rescisao       ³±±
±±³            ³          ³             ³Ajuste p/ validar preenchimento da data de³±±
±±³            ³          ³             ³homologacao antes do calculo              ³±±
±±³Raquel Hager³12/01/2016³TTTON9    	³Inclusao var. aPerAtual na func.FTUDOOKM40³±±
±±³Renan Borges³13/01/2016³TUAGO9       ³Ajuste para utilizar a rotina GPEM040 como³±±
±±³            ³          ³             ³adapter do tipo MVC pelo Mile corretamente³±±
±±³Allyson M.  ³19/01/2016³TUGCTV       ³Ajuste p/ deducao das faltas lancadas na  ³±±
±±³            ³          ³             ³tabela RGB	quando possui data preenchida  ³±±
±±³Allyson M.  ³26/01/2016³TUEQZ2    	³Ajuste para guardar o valor do salario    ³±±
±±³			   ³          ³          	³incorporado para o relatorio de medias    ³±±
±±³Allyson M.  ³04/02/2016³TUJCCK    	³Ajuste p/ sempre desfazer a delecao das   ³±±
±±³			   ³          ³          	³linhas do calculo antes de atualizar a    ³±±
±±³			   ³          ³          	³grid com o novo calculo p/ evitar situacao³±±
±±³			   ³          ³          	³em que verba que deveria ser gravada era  ³±±
±±³			   ³          ³          	³exibida como deletada.					   ³±±
±±³Allyson M.  ³05/02/2016³TUBP63    	³Ajuste p/ nao carregar o campo RG_SABDOM  ³±±
±±³			   ³          ³          	³desabilitado quando tem cadastro do aviso ³±±
±±³			   ³          ³          	³previo									   ³±±
±±³Allyson M.  ³05/02/2016³TUJENA    	³Ajuste p/ validar o cadastro do periodo   ³±±
±±³			   ³          ³          	³corretamente antes de iniciar o calculo   ³±±
±±³Claudinei S.³18/02/2016³TUCD45       ³Incluido novo controle para o Aviso Previo³±±
±±³            ³          ³             ³Trabalhado e Indenizado.                  ³±±
±±ºRenan Borges³26/02/2016³TUNQG2       ³Ajuste para no calculo da rescisão comple-º±±
±±º            ³          ³             ³mentar seja possível informar o código de º±±
±±º            ³          ³             ³RRA e para não gerar os valores de RRA ca-º±±
±±º            ³          ³             ³so não seja informado o código.           º±±
±±ºRenan Borges³26/02/2016³TUOPJD       ³Ajuste para no calculo da rescisão comple-º±±
±±º            ³          ³             ³mentar seja possível informar o código de º±±
±±º            ³          ³             ³RRA e para não gerar os valores de RRA ca-º±±
±±º            ³          ³             ³so não seja informado o código.           º±±
±±³Claudinei S.³29/02/2016³TUCD45       ³Incluido tratamento para gravacao do novo ³±±
±±³            ³          ³             ³campo RG_DTPROAV.                         ³±±
±±³Claudinei S.³03/03/2016³TUCD45       ³Incluido tratamento para gravacao do tipo ³±±
±±³            ³          ³             ³de rescisao quando possui cad.aviso previo³±±
±±³Claudinei S.³07/03/2016³TUCD45       ³Ajuste para nao projetar a data quando o  ³±±
±±³            ³          ³             ³tipo do aviso for N ou D, e para que ao   ³±±
±±³            ³          ³             ³excluir o aviso do Cad.Aviso Prévio,o tipo³±±
±±³            ³          ³             ³do aviso nao apareca na rescisao          ³±±
±±³Claudinei S.³16/03/2016³TURBCB       ³Ajuste considerar o campo do sindicato    ³±±
±±³            ³          ³             ³RCE_PRJAVT somente se aviso for trabalhado³±±
±±ºClaudinei S.³18/03/2016³TUSEC0       ³Ajustada a rotina para não permitir o     ³±±
±±º            ³          ³             ³cálculo da rescisão sem o preenchimento da³±±
±±º            ³          ³             ³data do aviso prévio.                     ³±±
±±ºClaudinei S.³21/03/2016³TUUEUC       ³fInitModel,carregar a descricao correta do³±±
±±º            ³          ³             ³tipo do aviso em rescisões já calculadas  ³±±
±±º            ³          ³             ³após ter sido incluída uma nova rescisão. ³±±
±±ºGustavo M.  ³04/04/2016³TUSJMS       ³Ajuste para validar se o periodo está ati ³±±
±±º            ³          ³             ³vo.									   ³±±
±±ºRenan Borges³05/04/2016³TUP601       ³Ajuste para abater o valor de % de salário³±±
±±º            ³          ³             ³educação corretamente do valor de tercei- ³±±
±±º            ³          ³             ³ros. Ajuste para validar o cadastro de ti-³±±
±±º            ³          ³             ³po de aviso previo corretamente de acordo ³±±
±±º            ³          ³             ³com os periodos ativos. Ajuste para utili-³±±
±±º            ³          ³             ³zar o mnemonico P_CHKDTHOM  ao realizar o ³±±
±±º            ³          ³             ³calculo de rescisão.                      ³±±
±±ºRaquel Hager³06/04/2016³TUUOE5       ³Ajuste para permissao de edicao do campo  ³±±
±±º            ³          ³             ³de Data de Aviso quando Complementar.     ³±±
±±³Renan Borges³12/04/2016³TURTIA       ³Ajuste para mostrar codigo de classe valor³±±
±±³            ³          ³             ³corretamente quando MV_ITMCLVL igual a 3 e³±±
±±³            ³          ³             ³não possuir o Item no registro de "Progra-³±±
±±³            ³          ³             ³mação de Rateio".                         ³±±
±±³Eduardo F.  ³09/05/2016³TUXUTK       ³Validação da quantidade maxima de lançamen³±±
±±³            ³          ³             ³tos por verbas, onde no final do procedi- ³±±
±±³            ³          ³             ³mento caso alguma verba esteja incorreta  ³±±
±±³            ³          ³             ³com o a listagem do calculo o usuário é   ³±±
±±³            ³          ³             ³informado de quais verbas estão incorretas³±±
±±ºRaquel Hager³30/05/2016³TVFXON       ³Ajuste para usar LoadValue quando comple- ³±±
±±º            ³          ³             ³mentar pois o campo já estará gravado na  ³±±
±±º            ³          ³             ³tabela./Ajuste para carregar variavel     ³±±
±±º            ³          ³             ³nDferave quando complementar para geração ³±±
±±º            ³          ³             ³da ref de Médias de Férias Proporcionais./³±±
±±º            ³          ³             ³Ajuste para não recalcular Dias de Férias ³±±
±±º            ³          ³             ³Proporcionais/Aviso/Vencidas quando comple³±±
±±º            ³          ³             ³mentar.							       ³±±
±±ºAllyson M.  ³13/06/2016³TVBL05       ³Ajuste na verificacao das ferias sobre    ³±±
±±º            ³          ³             ³aviso quando possuir aviso misto.		   ³±±
±±º            ³          ³TVJSRJ       ³Ajuste quando carregar os lançamentos das ³±±
±±º            ³          ³             ³rescisoes anteriores p/ nao verificar data³±±
±±º            ³          ³TVH709       ³Ajuste para gravar na SRR o mesmo período ³±±
±±³            ³          ³             ³da SRG, ou seja, o período que está sendo ³±±
±±³            ³          ³             ³calculada a rescisão complementar.        ³±±
±±³Gabriel A.  ³14/06/2016³TVFIKA       ³Ajuste para não exibir a mensagem de      ³±±
±±³            ³          ³             ³salário mínimo indevidamente.             ³±±
±±ºAllyson M.  ³14/06/2016³TVJDFD       ³Ajuste na importação dos resultados do    ³±±
±±º            ³          ³             ³ponto p/ não validar a data informada com ³±±
±±º            ³          ³             ³o período do ponto pois os dados da SPB só³±±
±±º            ³          ³             ³irão conter os dados do período em aberto ³±±
±±º            ³          ³             ³e troca do help() por msgalert() pois não ³±±
±±º            ³          ³             ³exibia a mensagem corretamente			   ³±±
±±³Gabriel A.  ³23/06/2016³TUXPCK       ³Ajuste na validação do campo RA_DEMISSA   ³±±
±±³            ³          ³             ³quando for importação via MILE.           ³±±
±±³Gabriel A.  ³24/06/2016³TVJSOG       ³Ajuste para guardar o valor do salario    ³±±
±±³            ³          ³             ³incorporado para o relatorio de medias    ³±±
±±ºAllyson M.  ³18/07/2016³TVNTNE       ³Ajuste p/ efetuar validação do campo de   ³±±
±±º            ³          ³             ³data de demissão somente quando alterar o ³±±
±±º            ³          ³             ³campo de data de demissão (antes validava ³±±
±±º            ³          ³             ³quando alterava a data de aviso) e quando ³±±
±±º            ³          ³             ³executar o cálculo de rescisão. 		   ³±±
±±ºAllyson M.  ³27/07/2016³TVKWJ7       ³Ajuste p/ carregar os campos de usuario   ³±±
±±º            ³          ³             ³de forma editável no fSRGWhen() 		   ³±±
±±ºVictor A.   ³28/07/2016³TVKHL4       ³Ajuste p/ nao consultar roteiro rescisão  ³±±
±±º            ³          ³             ³caso o funcionário não possua vinculos    ³±±
±±º            ³          ³             ³empregatícios em fChkDtDem().             ³±±
±±ºAllyson M.  ³04/08/2016³TVGXM3       ³Ajuste p/ validar tipo de roteiro somente ³±±
±±º            ³          ³             ³após a validação das datas 		   	   ³±±
±±ºCícero Alves³14/09/2016³TVQMN6       ³Ajuste na função fChkDtDem para verificar ³±±
±±º            ³          ³             ³se o GPE está sendo utilizado			   ³±±
±±ºAllyson M.  ³19/09/2016³TVVTPR       ³Ajuste p/ garantir a reinicialização das  ³±±
±±º            ³          ³             ³variáveis de aviso prévio 		   	   	   ³±±
±±ºAllyson M.  ³22/09/2016³TVY808       ³Ajuste na verificação do controle de dias ³±±
±±º            ³          ³             ³de direito		   	   	   				   ³±±
±±ºAllyson M.  ³18/10/2016³TVUZFF       ³Ajuste p/ não considerar o salário família³±±
±±º            ³          ³             ³p/ o desconto do empréstimo consignado.   ³±±
±±ºMatheus M.  ³18/10/2016³TWAAH8       ³Ajuste na carga do código da rescisão     ³±±
±±º            ³          ³             ³quando vier do Portal GCH.				   ³±±
±±ºAllyson M.  ³26/10/2016³TWHDNC       ³-Ajuste p/ reinicializar variáveis static ³±±
±±º            ³          ³             ³do GPEXCIMP/GPEXCINI ao iniciar o calculo ³±±
±±º            ³          ³             ³-Ajuste p/ permitir excluir rescisão simu-³±±
±±º            ³          ³             ³lada de períodos anteriores			   ³±±
±±º            ³          ³             ³-Ajuste p/ preparar rotina p/ teste auto- ³±±
±±º            ³          ³             ³matizado do robô de complementar 		   ³±±
±±ºRaquel Hager³10/10/2016³TWKEU2       ³Realizados ajustes para execução de robô  ³±±
±±º            ³          ³             ³de testes para cálculo de rescisão compl. ³±±
±±º            ³          ³             ³com período aberto.					   ³±±
±±³M.Camargo   ³25/10/2016³MRH-1134     ³ Se modifica fVAC_RESM2 por loc Chile     ³±±
±±ºCícero Alves³11/11/2016³TWEP47       ³Ajuste na validação dos campos para buscar³±±
±±º            ³          ³             ³a informação do modelo criado na rotina   ³±±
±±º            ³          ³             ³gpem042								   ³±±
±±ºRaquel Hager³29/12/2016³MRH-3935     ³Ajuste em fChkDtDem para buscar Afastamen-³±±
±±º            ³          ³             ³to em períodos futuros(1 ano para frente) ³±±
±±³Gabriel A.  ³10/01/2017³MRH-4551     ³Ajuste no cálculo de férias proporcionais ³±±
±±³            ³          ³             ³quando a data do aviso é trocada.         ³±±
±±ºAllyson M.  ³06/02/2017³MRH-5565     ³Ajuste no cálculo de complementar p/ não  ³±±
±±º            ³          ³             ³permitir o cálculo de complementar por    ³±±
±±º            ³          ³             ³dissídio se selecionado o 'Recálculo'	   ³±±
±±³Oswaldo L.  ³01/02/17  ³MRH-5770     ³Tratativa para que o sistema apenas utilize ³±±
±±³            ³          ³             ³os campos de acordo com o pais conectado  ³±±
±±³Gabriel A.  ³07/03/2017³MRH-7844     ³Ajuste no cálculo de rescisão quando há   ³±±
±±³            ³          ³             ³empréstimo consignado.                    ³±±
±±³Gabriel A.  ³05/04/2017³DRHPAG-42    ³Ajuste para zerar o mnemônico nFalAtuD em ³±±
±±³            ³          ³             ³todos os cálculos.                        ³±±
±±³Eduardo K.  ³20/04/2017³MPRIMESP-9798³Ajuste p/ não carregar verba de PLR no    ³±±
±±³            ³          ³             ³calculo da rescisão.                      ³±±
±±³Claudinei S.|09/05/2017|MRH-1646     |Implementado o cálculo para funcionários  ³±±
±±³            |          |             |com regime parcial.                       ³±±
±±³Marcos Cout.|26/05/2017|DRHESOCP-282 |Realizar a geração do evento S-2299       ³±±
±±³            |          |             |Desligamento. Foi realizado o merge 12.16 ³±±
±±³Marcos Cout.|01/06/2017|DRHESOCP-320 |Realizar a geração do evento S-2299       ³±±
±±³            |          |             |Desligamento Coletivo. Realizar ajustes   ³±±
±±³            |          |             |necessários para melhor funcionamento.    ³±±
±±³Marcos Cout.³02/06/2017³DRHESOCP-331 ³Ajustes para geração de LOG. Evento       ³±±
±±³            ³          ³             ³S-2299 - Desligamento Coletivo            ³±±
±±³Cecilia Car.|24/05/2017|DRHPAG-1474  |Ajuste para permitir lançar verba de PLR  ³±±
±±³            |          |             |no cálculo da rescisão.                   ³±±
±±³Cícero Alves|02/06/2017|DRHPAG-2125  |Inclusão do PE VLDTPRESP				   ³±±
±±³Marcos Cout.³14/06/2017³DRHESOCP-419 ³Ajustes para exibição de alerta (help) e  ³±±
±±³            ³          ³             ³chamada da função persistência do STATUS  ³±±
±±³Marcos Cout.³16/06/2017³DRHESOCP-437 ³Adicionada variavel aErros responsavel por³±±
±±³            ³          ³             ³armazenar o erros do XML na funcao. S2299 ³±±
±±³Marcos Cout.³24/08/2017³DRHESOCP-868 ³Ponteirando o registro para a sua filial  ³±±
±±³            ³          ³             ³correta. O registro não estava sendo encon³±±
±±³            ³          ³             ³_trado na base do TAF                     ³±±
±±³Cecília C.  ³21/08/2017³DRHESOCP-736 ³Implementação do campo RG_INDAV e geração ³±±
±±³            ³          ³             ³no XML S-2299.                            ³±±
±±³L. Samaniego|04/09/2017|DMICNS-163   |Se realiza declaracion de Variables para  ³±±
±±³            |          |             |el pais Argentina cuando ejecuta GPEM042  ³±±
±±Flavio C.    |12/09/2017|DRHPAG-4711  |Compatibilizado fonte com versoes .14 .16 ³±±
±±³            |          |             | e .17 								   ³±±
±±³Isabel N.   |15/09/2017|DRHPAG-4561  |Inicializa variáveis p/ ModFol modelo 2.  ³±±
±±ºRenan Borges³19/09/2017³DRHESOCP-1045³Ajuste para ao tentar fazer um desligamen-³±±
±±º            ³          ³             ³to S-2299 o sistema não retornar o erro de³±±
±±º            ³          ³             ³ Help FWMODELPOS.                         ³±±
±±ºCecília C.  ³05/10/2017³DRHESOCP-1324³Ajuste na geração dos valores do plano de ³±±
±±º            ³          ³             ³saúde do dependente para o evento S-2299. ³±±
±±ºEduardo K.  ³16/10/2017³MPRIMESP11285³Ajuste para ordenar verbas no grid pelo   ³±±
±±º            ³          ³             ³código das mesmas.						   ³±±
±±ºJoão Balbino³17/10/2017³MPRIMESP11750³Ajuste para posicionar corretamente a SRF ³±±
±±º            ³          ³             ³caso haja mais de um periodo aberto.      ³±±
±±ºJaqueline L.³22/12/2017³DRHPAG-10265 ³Declarando o Array aLogErros na função    ³±±
±±º            ³          ³             ³FCHKINTEG para evitar erroLog.            ³±±
±±ºCecília Carv³08/01/2018³DRHESOCP-2682³Ajuste para geração de contrato intermiten³±±
±±º            ³          ³             ³te - evento S-2200.                       ³±±
±±ºJaqueline L.³13/03/2018³DRHGCH-62    ³Retirado a chamada da tela de Filial      ³±±
±±³Marcos Cout.³15/03/2018³DRHESOCP-3473³Realizar criação do botão de "Integração  ³±±
±±³            ³          ³             ³com o TAF".                               ³±±
±±³Eduardo Vic.³22/03/2018³DRHESOCP-3704³Tratamento quando rescisão complementar   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GPEM040(nOpcAuto,lRotAuto)

Local aArea         := GetArea()
Local aCoors  		:= FWGetDialogSize( oMainWnd )
Local cIdBrowse
Local cIdGrid
Local oPanelUp
Local oTela
Local oPanelDown
Local oRelacSRG
Local cFiltraRH		:= ""
Local cVerEnv		:= ""
Local cVerGPE		:= ""

Private oDlgPrinc

Private oBrowseUp
Private oBrowseDwn
Private cResComp
Private aLogErros	:= {}				// Array com os logs de erros de processamento
Private lRescRRA	:= .F.
Private lAtuSimul	:= .F.
Private lSabDom		:= GetMvRH("MV_SABDOM") == "S" //Se pagara o sab e domingo qdo demissao na sexta
Private lModDataDem := GetMvRH("MV_MDDTDEM",NIL,"N") == "S"
Private lProjav		:= .F. //Projeção do aviso prévio por tipo de rescisão
Private lProj		:= .T. //Projeção do aviso prévio por sindicato
Private lColetiva	:= .F.
Private lTCFA040	:= IsInCallStack("TCFA040")
Private aSrgRecnos	:= {}
Private nRegSrg		:= 0
Private cAtualSit   := GetMvRH( "MV_SITRES", .F., "2" )
Private cModFol 	:= GetMvRH( "MV_MODFOL", .F., "1" )
Private cFilOld		:= ""
Private dDataAvi	:= CtoD ("//")
Private nSalaMed	:= 0
Private nSMesMed	:= 0
Private nSDiaMed	:= 0
Private nSHorMed	:= 0
Private lIndAv		:= Iif(cPaisLoc == 'BRA' .And. SRG->(ColumnPos( "RG_INDAV")) > 0, .T., .F.)
Private lContrInt	:= If(SRC->(ColumnPos( 'RC_CONVOC' )) > 0,.T.,.F.)

Private aPublicacao := Array(5) // [1]-Data da Rescisão / [2]-Nr.Documento / [3]-Data Publicacao / [4]-Chave RI6 / [5]-Índice da RI6

DEFAULT __lMemCalc  := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc() //Memória de Cálculo
DEFAULT lRotAuto    := .F.
DEFAULT lIntTaf 	:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 )
DEFAULT lMiddleware	:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )
DEFAULT lVNaoApl  	:= cPaisLoc == "BOL" .And. SRR->( ColumnPos("RR_VNAOAPL") ) > 0
DEFAULT lCpoReint	:= SRG->(ColumnPos( 'RG_REINTEG' )) > 0 

lAvMsg				:= .F.
lAtuBrowse			:= .T. //Se for robo não passara por aqui

If lMiddleware .And. !ChkFile("RJE")
	Help( " ", 1, OemToAnsi(STR0020),, OemToAnsi(STR0248), 1, 0 )//"Tabela RJE não encontrada. Execute o UPDDISTR - atualizador de dicionário e base de dados."
	Return
EndIf

//Verifica se os leiaute do eSocial GPE vs TAF estão divergentes.
If lIntTaf .And. FindFunction("fVersEsoc") .And. FindFunction("ESocMsgVer")
	fVersEsoc( "S2299", .F.,,, @cVerEnv, @cVerGPE)
	If !lMiddleware .And. cVerGPE <> cVerEnv .And. (cVerGPE >= "9.0" .Or. cVerEnv >= "9.0")
		//"Atenção! A versão do leiaute GPE é xxx e a do TAF é xxx, sendo assim, estão divergentes. O Evento xxx não será integrado com o TAF, e consequentemente, não será enviado ao RET.
		//Caso prossiga a informação será atualizada somente na base do GPE. Deseja continuar?"
		If ESocMsgVer(.F.,/*cEvento*/, cVerGPE, cVerEnv)
			lVlEsocDif  := .T.
			lIntTAF		:= .F.
		Else
			Return
		EndIf
	EndIf
EndIf

If cPaisLoc == "BOL" .And. !lVNaoApl
	Help( " ", 1, OemToAnsi(STR0020),, OemToAnsi(STR0317), 1, 0 )//"Atenção"##"Campo RR_VNAOAPL não encontrado. Solicite ao administrador do sistema consultar a documentação https://tdn.totvs.com/x/pMzAKQ."
	Return
EndIf

//Inicializa variaveis que no modelo 1 sao mnemonicos
If cModFol == "2"
	aIncRes				:= {}
	lUltSemana 			:= .F.
	lRescDis			:= .F.
	lRescPLR			:= .F.
	lRecRes				:= .F.
	nPosSem				:= 0
	Salario				:= 0
	SalHora				:= 0
	SalDia				:= 0
	SalMes				:= 0
	NORMAL				:= 0
	DESCANSO			:= 0
	nDferven 			:= 0
	nFaltasv			:= 0
	nDferave			:= 0
	nFaltasp			:= 0
	nDferInd			:= 0
	cProcesso			:= ""
	cPeriodo			:= ""
	cNumPag				:= ""
	cRot				:= ""
	cCompl				:= ""
	dDataDem			:= CtoD("")
	dDataAvis			:= CtoD("")
	dDtEst936			:= CtoD("")
	nPerEst936			:= 0
EndIf

If lRotAuto

	lAtuBrowse	:= .F.

	FWExecView(If(nOpcAuto == MODEL_OPERATION_INSERT,STR0037,If(nOpcAuto == MODEL_OPERATION_VIEW,STR0005,STR0007)), "GPEM040", nOpcAuto ,,{||.T.})

Else

	Define MsDialog oDlgPrinc Title OemToAnsi(STR0001) From aCoors[1], aCoors[2] To aCoors[3], aCoors[4] OF oMainWnd Pixel  //"Calculo de Rescisao"

	// Cria o conteiner onde serão colocados os paineis
	oTela     := FWFormContainer():New( oDlgPrinc )
	cIdBrowse := oTela:CreateHorizontalBox( 60 )
	cIdGrid   := oTela:CreateHorizontalBox( 35 )

	oTela:Activate( oDlgPrinc, .F. )

	//Cria os paineis onde serao colocados os browses
	oPanelUp  	:= oTela:GeTPanel( cIdBrowse )
	oPanelDown  := oTela:GeTPanel( cIdGrid )

	// FWmBrowse Superior: Funcionarios
	oBrowseUp:= FWmBrowse():New()
	oBrowseUp:SetOwner( oPanelUp )                  // Aqui se associa o browse ao componente de tela
	oBrowseUp:SetDescription( OemToAnsi(STR0002) )	//"Funcionarios"
	oBrowseUp:SetAlias( 'SRA' )
	oBrowseUp:SetMenuDef( 'GPEM630' )              // Define de onde virao os botoes deste browse
	oBrowseUp:DisableDetails()
	oBrowseUp:SetProfileID( '1' )
	oBrowseUp:SetCacheView (.F.)
	oBrowseUp:ExecuteFilter(.T.)

	GpLegMVC(@oBrowseUp)

	cFiltraRh := ChkRh("GPEM040","SRA","1")
	// Aplicar filtro quando chamado pelo TCFA040 (Aprovacao workflow portal)
	If lTCFA040
		cFiltraRh += IF(!Empty(cFiltraRh),'.and. RA_FILIAL == "' + RTrim(cFilFun) + '"','RA_MAT == "' + RTrim(cMatFun) + '"')
	EndIf

	oBrowseUp:SetFilterDefault(cFiltraRh)
	oBrowseUp:SetMainProc("GPEM630")
	oBrowseUp:Activate()

	// FWmBrowse Inferior: Cabecalhos de rescisao
	oBrowseDwn:= FWMBrowse():New()
	oBrowseDwn:SetOwner( oPanelDown )
	oBrowseDwn:SetDescription( OemToAnsi(STR0003) )	//"Cabeçalho de rescisão"
	oBrowseDwn:SetMenuDef( 'GPEM040' )
	oBrowseDwn:DisableDetails()
	oBrowseDwn:SetAlias( 'SRG' )
	oBrowseDwn:SetProfileID( '2' )
	oBrowseDwn:ForceQuitButton()					//sempre que existem dois menudefs na tela, deve-se indicar em qual browse vai ficar o botao 'Sair'
	oBrowseDwn:SetCacheView (.F.)
	oBrowseDwn:ExecuteFilter(.T.)

	If cModFol == "2"
		oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='1'"		, 'YELLOW'	, OemToAnsi(STR0030) ) //Nao Calculado
		oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='2'"		, 'GREEN'	, OemToAnsi(STR0031) ) //Calculado
		oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='3'"		, 'RED'		, OemToAnsi(STR0032) ) //Fechado
		oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='4'"		, 'PINK'	, OemToAnsi(STR0033) ) //Impresso
		oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='5'"		, 'BLUE'	, OemToAnsi(STR0034) ) //Pago
	Else
		IF lCpoReint
			oBrowseDwn:AddLegend( "SRG->RG_EFETIVA== 'N' .And. SRG->RG_REINTEG != '1' "		, 'BLUE'	, OemToAnsi(STR0036) ) //Simulação
			oBrowseDwn:AddLegend( "SRG->RG_EFETIVA== 'N' .And. SRG->RG_REINTEG == '1' "		, 'BLACK'	, OemToAnsi(STR0326) ) //"Reintegrada"
		Else
			oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='N'"		, 'BLUE'	, OemToAnsi(STR0036) ) //Simulação
		EndIf
		oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='S'"		, 'RED'		, OemToAnsi(STR0035) ) //Efetivada
	EndIf

	// Relacionamento entre os Paineis
	oRelacSRG:= FWBrwRelation():New()
	oRelacSRG:AddRelation( oBrowseUp  , oBrowseDwn , { { 'RG_FILIAL', 'RA_FILIAL' }, { 'RG_MAT' , 'RA_MAT'  } } )
	oRelacSRG:Activate()

	oBrowseDwn:SetMainProc("GPEM040")
	oBrowseDwn:Activate()

	oBrowseUp:Refresh()
	oBrowseDwn:Refresh()

	Activate MsDialog oDlgPrinc Center

EndIf

RestArea(aArea)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MenuDef     ³ Autor ³ Leandro Drumond       ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Menu Funcional                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MenuDef()                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function MenuDef()

	Local aRotina := {}

	DEFAULT lGestPubl 	:= IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
	DEFAULT lIntTaf 	:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 )
	DEFAULT lMiddleware	:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )

	ADD OPTION aRotina Title OemToAnsi(STR0004)	Action 'PesqBrw'         OPERATION 1  ACCESS 0 DISABLE MENU //"Pesquisar"
	ADD OPTION aRotina Title OemToAnsi(STR0005)	Action 'VIEWDEF.GPEM040' OPERATION 2  ACCESS 0 DISABLE MENU //"Visualizar"
	ADD OPTION aRotina Title OemToAnsi(STR0037) Action 'VIEWDEF.GPEM040' OPERATION 3  ACCESS 0 DISABLE MENU //"Incluir"

	If SuperGetMv( "MV_MODFOL", .F., "1" ) == "2"
		ADD OPTION aRotina Title OemToAnsi(STR0006) Action 'VIEWDEF.GPEM040' OPERATION 4  ACCESS 0 DISABLE MENU //"Manutenção"
	EndIf

	ADD OPTION aRotina Title OemToAnsi(STR0007) Action 'VIEWDEF.GPEM040' OPERATION 5  ACCESS 0 DISABLE MENU	//"Excluir"

	If cPaisLoc == "BRA"
		ADD OPTION aRotina Title OemToAnsi(STR0103) Action 'GPEA925(Nil,Nil,4)' OPERATION 3  ACCESS 0 DISABLE MENU	//"Cadastro de Aviso Prévio"
	EndIf

	If lGestPubl .AND. cModulo $ 'GFP*VDF'
		ADD OPTION aRotina Title OemToAnsi(STR0226) Action 'Gp40GItePu()' OPERATION 3  ACCESS 0 DISABLE MENU //"Gerar Item Publicação"
	EndIf

	If cPaisLoc == "BRA" .And. (lIntTaf .Or. lMiddleware) .And. FindFunction("fIntResLot") .And. !lVlEsocDif
		ADD OPTION aRotina Title OemToAnsi(STR0283) Action 'fIntResLot()' OPERATION 3  ACCESS 0 DISABLE MENU//"Integ. eSocial em lote"
		ADD OPTION aRotina Title OemToAnsi(STR0316) Action 'fIntResLot(.T.)' OPERATION 3  ACCESS 0 DISABLE MENU//"Relatório Excel S-2299 em lote
	EndIf

Return aRotina

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ModelDef    ³ Autor ³ Leandro Drumond       ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Modelo de Dados da Rotina                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ModelDef()                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function ModelDef()
Local oModel
Local oStruSRG
Local oStruGET
Local cWhenSRG		:= ""
Local nX			:= 0
Local oEvent  		:= GPM040VLD():New()
Local bCommiM040	:= { | oModel | fCommit040(oModel) }
Local lBloqAdm		:= SRA->(ColumnPos("RA_BLOQADM")) > 0

DEFAULT lVNaoApl  	:= cPaisLoc == "BOL" .And. SRR->( ColumnPos("RR_VNAOAPL") ) > 0

cModFol		:=  If( Type("CMODFOL")== "U", SuperGetMv( "MV_MODFOL", .F., "1" ), cModFol)

oModel := MPFormModel():New( 'GPEM040', /*bPreValid*/, /*Utilizar FWModelEvent*/, bCommiM040, /*Utilizar FWModelEvent*/ )

oStruSRG := FWFormStruct(1,"SRG")
oStruSRG:AddField ( PosAlias( "SX3" , "RA_ADMISSA"  , "" , "X3Titulo()" , 2 , .F. ) 	,; //Titulo
					""																	,; //Descricao
					"RG_ADMISSA"														,; //Campo
					"D"																	,; //Tipo
					8																	,; //Tamanho
					0																	,; //Decimal
					Nil																	,; //Valid
					Nil																	,; //When
					Nil																	,; //Combo
					Nil																	,; //Obrigatorio
					FwBuildFeature( STRUCT_FEATURE_INIPAD, "SRA->RA_ADMISSA" )			,; //Inicializador padrao
					Nil																	,; //Campo chave
					Nil																	,; //Alteravel
					.T.																	)  //Virtual
if cPaisLoc == "BRA"
	oStruSRG:AddField ( OemToAnsi(STR0261)												 	,; //Titulo
					""																	,; //Descricao
					"RG_DSCRESC"														,; //Campo
					"C"																	,; //Tipo
					25																	,; //Tamanho
					0																	,; //Decimal
					Nil																	,; //Valid
					Nil																	,; //When
					Nil																	,; //Combo
					Nil																	,; //Obrigatorio
					FwBuildFeature(STRUCT_FEATURE_INIPAD, "fSRetDes()")					,; //Inicializador padrao
					Nil																	,; //Campo chave
					.F.																	,; //Alteravel
					.T.																	)  //Virtual
EndIf
//		 		   cTitulo, cTooltip, cIdField	 , cTipo	, nTamanho, nDecimal, bValid, bWhen, aValues, lObrigat, bInit									      												 					 , lKey, lNoUpd, lVirtual, cValid)
If lBloqAdm
	oStruSRG:AddField( OemToAnsi(STR0150), ""	    , "RA_BLOQADM", "L"		, 1	  	  ,	0		, Nil	, Nil  , Nil	,	   Nil,	FwBuildFeature( STRUCT_FEATURE_INIPAD, "If(SRA->RA_BLOQADM == '1', .T., .F.)" ), Nil , .F.   , .T.     , ""    )
ElseIf cPaisLoc $ "BRA|DOM|MEX"
	oStruSRG:AddField( OemToAnsi(STR0150), ""	    , "RA_FECREI", "L"		, 1	  	  ,	0		, Nil	, Nil  , Nil	,	   Nil,	FwBuildFeature( STRUCT_FEATURE_INIPAD, "If(SRA->RA_FECREI != cTOd('') .AND. SRA-> RA_SITFOLH == 'D', .T., .F.)" ), Nil , .F.   , .T.     , ""    )
EndIf

oModel:AddFields("GPEM040_MSRG", /*cOwner*/, oStruSRG , /*Pre-Validacao*/,/*Pos-Validacao*/,/*Carga*/)

If aStructSRG == Nil .Or. Empty(aStructSRG)
	aStructSRG := oStruSRG:GetFields()
EndIf

For nX := 1 to Len(aStructSRG)
	cWhenSRG := "{ || fSRGWhen( '" + aStructSRG[nX,3] + "' ) } "
	oStruSRG:SetProperty( aStructSRG[nX,3], MODEL_FIELD_WHEN, &(cWhenSRG) )
    If cPaisLoc == "BOL" .and. aStructSRG[nX,3] == "RG_DATAHOM"
		oStruSRG:SetProperty( aStructSRG[nX,3], MODEL_FIELD_VALID, {|a,b,c,d| FWInitCpo(a,b,c),lRet:=((fChkDtHom(M->RG_DATADEM, M->RG_DATAHOM))),FWCloseCpo(a,b,c,lRet),lRet} )
	EndIf
Next nX

If cPaisLoc == "BRA"
    oStruSRG:SetProperty( "RG_SABDOM", MODEL_FIELD_VALID, {|| fVldSabDom() } )
    If ( fDesc("SR6", SRA->RA_TNOTRAB, "R6_TPJOR1", NIL, SRA->RA_FILIAL, 1) == "2" )
        oStruSRG:SetProperty( "RG_DESCANS", MODEL_FIELD_VALID, { || Positivo() } )
        oStruSRG:SetProperty( "RG_DESCANS", MODEL_FIELD_OBRIGAT, .F. )
    EndIf
    oStruSRG:SetProperty( "RG_MEDATU", MODEL_FIELD_VALID, FwBuildFeature( STRUCT_FEATURE_VALID, 'Pertence("SN") .And. fAtAvProj()' ) )
EndIf

If cModFol == "2"
	oStruGET := FWFormStruct( 1, 'SRC', /*bAvalCampo*/, /*lViewUsado*/ )
	//seta inicializador padrao para o campo de descricao do SRC
	oStruGET:SetProperty( 'RC_DESCPD' , MODEL_FIELD_INIT, FWBuildFeature( /*STRUCT_FEATURE_INIPAD*/ 3 , "FillDescPd()" ))
Else
	oStruGET := FWFormStruct(1, "SRR")

	oStruGET:SetProperty( 'RR_DESCPD' , MODEL_FIELD_INIT,{|oGrid|FDESC("SRV",If(oGrid:Length()>0,oGrid:GetValue("RR_PD"),SRR->RR_PD),"RV_DESC")})
EndIf

IncidCpos(oStruGET,IIF(cModFol == "2","SRC","SRR"))

If cPaisLoc == "BOL" .And. lVNaoApl
	oStruGET:SetProperty( "RR_VALOR", MODEL_FIELD_OBRIGAT, .F. )
EndIf

oModel:AddGrid("GPEM040_MGET", "GPEM040_MSRG", oStruGET,/*bLinePre*/, /* bLinePost*/, /*bPre*/,  /*bPost*/,/*{|oGrid| CargaSRR(oGrid) }*//*bLoad*/)

//Regras do Model GPEM040_MGET
oModel:GetModel( "GPEM040_MGET" ):SetNoInsertLine(.T.)
oModel:GetModel( "GPEM040_MGET" ):SetNoDeleteLine(.T.)
oModel:GetModel( "GPEM040_MGET" ):SetOptional(.T.)

//Definindo relacionamento entre SRG e SRC
If cModFol == "2"
	If cPaisLoc $ "ARG*CHI*COL*COS*DOM*MEX"
	   oModel:SetRelation( 'GPEM040_MGET', { { 'RC_FILIAL', 'xFilial( "SRC" )' } , { 'RC_MAT', 'RG_MAT' },  {'RC_DTREF', 'RG_DTPAGO'}	} , SRC->(IndexKey(1)) )
	Else
	    oModel:SetRelation( 'GPEM040_MGET', { { 'RC_FILIAL', 'xFilial( "SRC" )' } , { 'RC_MAT', 'RG_MAT' }	} , SRC->(IndexKey(1)) )
	EndIf
Else
	SRR->(DbSetOrder( RetOrdem( "SRR", "RR_FILIAL+RR_PD" ) ))
	oModel:SetRelation( 'GPEM040_MGET', { { 'RR_FILIAL', 'xFilial( "SRG" )' }, { 'RR_MAT', 'RG_MAT' }, { 'RR_DATA', 'RG_DTGERAR' }}, SRR->( IndexKey( 5 ) ) )
EndIf


oModel:SetPrimaryKey( {"RG_FILIAL", "RG_MAT", "RG_PERIODO", "RG_ROTEIR", "RG_SEMANA", "RG_DTGERAR", "R_E_C_D_E_L_"} )

//--Valida se o model deve ser ativado
oModel:SetVldActivate( { |oModel| fVldModel(oModel,oModel:GetOperation()) } )

//--Apos a ativacao, faz a carga inicial da enchoice
oModel:SetActivate( { |oModel| fInitModel(oModel,oModel:GetOperation()) } )

oModel:InstallEvent("GPM040VLD", /*cOwner*/, oEvent)

Return oModel

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ViewDef     ³ Autor ³ Leandro Drumond       ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³View                                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ViewDef()                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function ViewDef()

Local lResComp	:= .F.
Local lRetif	:= .F.
Local lConfCompl:= SRR->(ColumnPos("RR_VALORI")) > 0
Local oStruSRG 	:= FWFormStruct( 2, 'SRG' )
Local oStruGET 	:= If( cModFol == "2" , FWFormStruct( 2, 'SRC' ) , FWFormStruct( 2, 'SRR' ) ) //Modelo 1 utiliza SRR, modelo 2 utilizada SRC
Local oModel   	:= FWLoadModel( 'GPEM040' )
Local oView
Local bAplicacao:= {|| fAplicaRes(1) }
Local bUndoAplic:= {|| fAplicaRes(2) }
Local bCalcM42	:= {|| MsAguarde( { || Iif( lTCFA040, If(VldTpRes(), CalResc(), Help( , , OemToAnsi(STR0020), , OemToAnsi(STR0188), 1, 0 )), CalResc() )} , STR0101 )}
Local bCalcAnt	:= {|| RescAntView() }
Local bLancFixos:= {|| AbreCadastro(1)}
Local bIncidenci:= {|| AbreCadastro(2) }
Local bAusencias:= {|| AbreCadastro(3) }
Local bValFuturo:= {|| AbreCadastro(4) }
Local bTmpExtra	:= {|| AbreCadastro(5) }
Local bIntegra	:= {|| AbreCadastro(6) }
Local bMedias	:= {|| AbreCadastro(7) }
Local bFerias	:= {|| AbreCadastro(8) }
Local bPonto	:= {|| AbreCadastro(9) }
Local bAviso	:= {|| AbreCadastro(10) }
Local bIntTAF
Local lBloqAdm	:= SRA->(ColumnPos("RA_BLOQADM")) > 0
Local lHistMed	:= AliasInDic("RJK") .And. AliasInDic("SRP")
Local cTrabSVinc:= fCatTrabEFD("TSV")

DEFAULT lIntTaf 	:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 )
DEFAULT lMiddleware	:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )

bIntTAF	:= {|| iif ((lIntTaf .Or. lMiddleware) .And. fResCompl(Nil ,.T., Nil, @lResComp, @lRetif),fIntegraTAF( (lIntTaf .Or. lMiddleware), oModel:GetModel('GPEM040_MSRG'), oModel:GetModel('GPEM040_MGET'), oModel, lResComp, lRetif, aPd_SRK ),.T.) }
bRelTAF	:= {|| iif ((lIntTaf .Or. lMiddleware) .And. fResCompl(Nil ,.T., Nil, @lResComp, @lRetif),fIntegraTAF( (lIntTaf .Or. lMiddleware), oModel:GetModel('GPEM040_MSRG'), oModel:GetModel('GPEM040_MGET'), oModel, lResComp, lRetif, aPd_SRK, .T. ),.T.) }

oView := FWFormView():New()
oView:SetModel( oModel )

oStruSRG:RemoveField( 'RG_PROCES' )
oStruSRG:RemoveField( 'RG_ROTEIR' )
oStruSRG:RemoveField( 'RG_RRA' )

oStruSRG:AddField ( "RG_ADMISSA"														,; //Campo
					"04"																,; //Ordem
					PosAlias( "SX3" , "RA_ADMISSA"  , "" , "X3Titulo()" , 2 , .F. )		,; //Titulo
					""																	,; //Descricao
					{""}																,; //Help
					"D"																	,; //Tipo
					""																	,; //Picture
					Nil																	,; //Bloco picture var
					''																	,; //F3
					.F.																	,; //Alteravel?
					"1"																	,; //Pasta
					Nil																	,; //Agrupamento
					Nil																	,; //Combo
					Nil																	,; //Tamanho maximo combo
					Nil																	,; //Inicializador de browse
					.T.																	)  //Virtual
If cPaisLoc=='BRA'
	oStruSRG:AddField ( "RG_DSCRESC"														,; //[01] - Campo
					"30"																,; //[02] - Ordem
					OemToAnsi(STR0261)													,; //[03] - Titulo
					""																	,; //[04] - Descricao
					{""}																,; //[05] - Help
					"C"																	,; //[06] - Tipo
					""																	,; //[07] - Picture
					Nil																	,; //[08] - Bloco picture var
					''																	,; //[09] - F3
					.F.																	,; //[10] - Alteravel?
					"1"																	,; //[11] - Pasta
					Nil																	,; //[12] - Agrupamento
					Nil																	,; //[13] - Combo
					25																	,; //[14] - Tamanho maximo combo
					Nil																	,; //[15] - Inicializador de browse
					.T.																	)  //[16] - Virtual
EndIf
//		 AddField( cIdField   , cOrdem, cTitulo, cDescric, aHelp, cType, cPicture, bPictVar, cLookUp, lCanChange, cFolder, cGroup, aComboValues, nMaxLenCombo, cIniBrow, lVirtual, cPictVar, lInsertLine )
If lBloqAdm
	oStruSRG:AddField( "RA_BLOQADM", "26"  , OemToAnsi(STR0150), ""		 , {""} , "L"  , ""	     , Nil	   , ''	    , .T.	    , "1"	 , Nil	 , Nil		   , Nil  		 , ".T."   , .F.	 , ""	   , .F. 		 )
ElseIf cPaisLoc $ "BRA|DOM|MEX"
	oStruSRG:AddField( "RA_FECREI", "26"  , OemToAnsi(STR0150), ""		 , {""} , "L"  , ""	     , Nil	   , ''	    , .T.	    , "1"	 , Nil	 , Nil		   , Nil  		 , ".T."   , .F.	 , ""	   , .F. 		 )
EndIf

If cPaisLoc $ "BRA|EQU"
	oStruSRG:SetProperty( 'RG_SABDOM' , MVC_VIEW_CANCHANGE, .T. )
EndIf

//Altera as propriedades dos campos abaixo, para permitir edição.
If cPaisLoc == "BRA"
	oStruSRG:SetProperty( 'RG_DAVISO' , MVC_VIEW_CANCHANGE, .T. )
	oStruSRG:SetProperty( 'RG_DAVCUM' , MVC_VIEW_CANCHANGE, .T. )
	oStruSRG:SetProperty( 'RG_DAVIND' , MVC_VIEW_CANCHANGE, .T. )
EndIf

If cPaisLoc <> "BRA
	oStruSRG:SetNoFolder() //Se nao for Brasil, nao divide em pasta, pois nao possui referencia ao EFD Social
EndIf

If SRG->(ColumnPos("RG_PDRESC")) > 0
	oStruSRG:SetProperty( 'RG_PDRESC' , MVC_VIEW_FOLDER_NUMBER, "1")
EndIf

If SRG->(ColumnPos("RG_NPROCS")) > 0 .And. cPaisLoc == "BRA
    oStruSRG:SetProperty( 'RG_NPROCS' , MVC_VIEW_FOLDER_NUMBER, "2")
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Nao apresenta os seguintes campos no Grid                  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If cModFol == "2"
	oStruGET:RemoveField( 'RC_FILIAL' )
	oStruGET:RemoveField( 'RC_MAT' )
	oStruGET:RemoveField( 'RC_NOME' )
	oStruGET:RemoveField( 'RC_QTDSEM' )
	oStruGET:RemoveField( 'RC_HORINFO' )
	oStruGET:RemoveField( 'RC_VALINFO' )
	oStruGET:RemoveField( 'RC_VALORBA' )
	oStruGET:RemoveField( 'RC_PROCES' )
	oStruGET:RemoveField( 'RC_PERIODO' )
	oStruGET:RemoveField( 'RC_ROTEIR' )
	oStruGET:RemoveField( 'RC_SEMANA' )
Else
	oStruGET:RemoveField( 'RR_FILIAL' )
	oStruGET:RemoveField( 'RR_MAT' )
	oStruGET:RemoveField( 'RR_AUXIL' )
	oStruGET:RemoveField( 'RR_TIPO3' )
	If lConfCompl
		If Empty(SRA->RA_DEMISSA)
			oStruGET:RemoveField( 'RR_VALORI' ) //Não exibe o campo na primeira rescisão ou na complementar no mesmo mês
		Else
			oStruGET:SetProperty( 'RR_VALORI' , MVC_VIEW_ORDEM, "08" )
		EndIf
	EndIf
EndIf

IncidCpos(oStruGET,IIF(cModFol == "2",'SRC','SRR'),.T.)

oView:AddField( 'VIEW_SRG', oStruSRG, 'GPEM040_MSRG' )
oView:AddGrid(  'VIEW_GET', oStruGET, 'GPEM040_MGET' )

oView:CreateHorizontalBox( 'SUPERIOR', 50 )
oView:CreateHorizontalBox( 'INFERIOR', 50 )

oView:SetOnlyView('VIEW_GET') //nao permite alteracoes no Grid

oView:SetOwnerView( 'VIEW_SRG', 'SUPERIOR' )
oView:SetOwnerView( 'VIEW_GET', 'INFERIOR' )

oView:addUserButton(OemToAnsi(STR0011) + " (F6)","MAGIC_BMP", bCalcM42,   OemToAnsi(STR0011),VK_F6, {MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE} ) //"Calcular Rescisão"

If cPaisLoc == "BRA" .And. !Empty(SRA->RA_DEMISSA)
	//Se for complementar, inclui botão para visualizar rescisões anteriores
	oView:addUserButton("Rescisões Anteriores" ,"MAGIC_BMP", bCalcAnt,   OemToAnsi(STR0253),, {MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE} ) //"Rescisões Anteriores"
EndIf

If cModFol == "2"
	oView:addUserButton(OemToAnsi(STR0013),"MAGIC_BMP", bAplicacao, OemToAnsi(STR0013),, {MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE} )	 //"Aplicar rescisão"
	oView:addUserButton(OemToAnsi(STR0014),"MAGIC_BMP", bUndoAplic, OemToAnsi(STR0014),, {MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE} )	 //"Desfazer aplicação de rescisão"
EndIf

oView:addUserButton(OemToAnsi(STR0015),"MAGIC_BMP", bLancFixos, OemToAnsi(STR0015),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Lançamentos Fixos"
oView:addUserButton(OemToAnsi(STR0016) + " (F7)","MAGIC_BMP", bIncidenci, OemToAnsi(STR0016),VK_F7,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Lançamentos por funcionário"
oView:addUserButton(OemToAnsi(STR0017),"MAGIC_BMP", bAusencias, OemToAnsi(STR0017),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Afastamentos"
oView:addUserButton(OemToAnsi(STR0018),"MAGIC_BMP", bValFuturo, OemToAnsi(STR0018),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Valores Futuros"
oView:addUserButton(OemToAnsi(STR0038) + " (F8)","MAGIC_BMP", bIntegra, 	 OemToAnsi(STR0038),VK_F8,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Integrações"
oView:addUserButton(OemToAnsi(STR0120),"MAGIC_BMP", bMedias, 	 OemToAnsi(STR0120),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE,iif(lHistMed,MODEL_OPERATION_VIEW,) } )						//"Visualizar Medias"
oView:addUserButton(OemToAnsi(STR0121),"MAGIC_BMP", bFerias, 	 OemToAnsi(STR0121),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Contr. Dias de Direito"
oView:addUserButton(OemToAnsi(STR0075),"CLOCK01",bPonto , 	 OemToAnsi(STR0075),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Contr. Dias de Direito"
oView:addUserButton(OemToAnsi(STR0166),"MAGIC_BMP", bAviso, 	 "Aviso Prévio"/*OemToAnsi(STR0121)*/,,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Aviso Prévio"

If cModFol == "2"
	oView:addUserButton(OemToAnsi(STR0019),"MAGIC_BMP", bTmpExtra , OemToAnsi(STR0019),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE,MODEL_OPERATION_VIEW } )	//"Tempo Extra"
EndIf

//Botão auxiliar para integração no TAF
If cPaisLoc == "BRA" .And. FunName() == "GPEM040" .And. SRG->RG_EFETIVA == "S" .And. !lVlEsocDif
	oView:addUserButton( OemToAnsi(STR0211), "MAGIC_BMP", bIntTAF, OemToAnsi(STR0211), , {MODEL_OPERATION_VIEW} )	//"Integração com o TAF"
	If !(SRA->RA_CATEFD $ cTrabSVinc)
		oView:addUserButton( OemToAnsi(STR0315), "MAGIC_BMP", bRelTAF, OemToAnsi(STR0211), , {MODEL_OPERATION_VIEW} )	//"Relatório Excel S-2299"
	EndIf
EndIf

oView:SetCloseOnOk({ || If(SRG->RG_EFETIVA == "S", fCtrTitLg(), .T. )}) //Fecha tela apos commit

oView:SetViewCanActivate({ |oView| Gp40VldView(oView)})

oView:SetAfterViewActivate({ |oView| Gp40VldView(oView)})

oView:SetViewAction( 'BUTTONCANCEL', { |oView| fDelHist( .F.,oView ), fDelRU6( .F., oView ) } )

Return oView

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gp40VldView ºAutor  ³Leandro Drumond   º Data ³  20/08/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida view			                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Gp40VldView(oView)
dbSelectArea("SRG")
Return lCancelCalc //Se cancelou a seleção de complementar/recalculo..retorna sem exibir erro.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fVldModel    ³ Autor ³ Leandro Drumond       ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida model e inicializa cabecalho SRG.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fVldModel(oModel,nOperation)                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fVldModel(oModel,nOperation)
Local aPerAtual		:= {}
Local aRetAuto		:= {}
Local cMesAnoRef	:= ""
Local cMesAnoDem	:= ""
Local cCodFer		:= ""
Local lRet			:= .T.
Local lRetPer		:= .T.
Local lEstag		:= .F.
Local nMaxCompl		:= 0
Local lRobo			:= IsBlind()
Local aInfoTpRes	:= {}
Local lTemRes		:= .F.

DEFAULT lGestPubl   := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
DEFAULT lCtrlTit	:= ChkFile("RJ1") .And. !Empty(GetNewPar("MV_BTITRES", "" )) .And. RJ1->(ColumnPos( "RJ1_ROTEIR")) > 0 .And. RJ1->(ColumnPos( "RJ1_PROCES")) > 0 .And. RJ1->(ColumnPos( "RJ1_TIPO")) > 0
DEFAULT lCpoReint	:= SRG->(ColumnPos( 'RG_REINTEG' )) > 0 

lModDataDem := GetMvRH("MV_MDDTDEM",NIL,"N") == "S"

RstlDefaut()
SetMnemonicos(NIL,NIL,.T.,,,"GPEM040")

Begin Sequence

	If IsInCallStack("FwAlertExitPage")
		lCancelCalc := .F.
		Break
	EndIf
	//Zera aSPBRec
	aPd			:= {}
	aSrgRecnos  := {}
	aSPBRec 	:= {}
	aPerFerias	:= {}
	aPeriodo	:= {}
	aCodFol		:= {}
	aFerPag		:= {}
	dDataDem	:= dDataDem1 := dDtEst936 := CtoD("")
	dDataAvis	:= CtoD("")
	lColetiva	:= .F.
	lProxMes	:= .F.
	nRegSrg 	:= 0
	nDFerVen 	:= 0
	nDFerAux 	:= 0
	nDFerAve 	:= 0
	nDFerInd	:= 0
	nDFerAnt	:= 0
	nDiasAv		:= 0
	nDiascum	:= 0
	nDiaInde	:= 0
	cTipoRot	:= "4"
	cRfyTpAv	:= ""
	lTemRFY		:= .F.
	lRecRes		:= .F.
	lDtDemRFY	:= .F.
	cFilOld		:= cFilAnt
	cFilAnt		:= SRA->RA_FILIAL
	nPerEst936	:= 0
	nVal1904	:= 0

	lAtuSimul 	:= .F. //Indica se trata-se de efetivacao de uma simulacao
	cCompl	  	:= "N"
	lRescDis  	:= .F.
	lDissidio 	:= .F.
	lCancelCalc	:= .T.
	lIntTaf		:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .And. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 ) .And. !(SRA->RA_CATEFD $ SuperGetMv( "MV_NTSV", .F., "701|711|712|741|" )) .And. !lVlEsocDif
	lMiddleware	:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )
	cOpcCompl 	:= "1"

	If _BkpFilial <> SRA->RA_FILIAL .or. Empty(_aCodFol)
		If !FP_CODFOL(@aCodFol,SRA->RA_FILIAL)
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0100), 1, 0 ) //"Atenção" ## "Falha na carga de verbas"
			Return( .F. )
		EndIf
		_aCodFol:= aClone(aCodFol)
		_BkpFilial:= SRA->RA_FILIAL
	Endif

	aCodFol:= aClone(_aCodFol)
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria Arquivo Temporario para Calculo de Medias               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	Cria_Trp()

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Nao deixa incluir rescisao se houver outra em aberto. 	          ³
	³ Se jah houver rescisao fechada, lanca como rescisao complementar.   ³
	³ (Se for complemetar fora do mes, sera modificada no TudoOK)  	      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If nOperation == MODEL_OPERATION_INSERT

		If (TamSX3("RR_HORAS")[1] > TamSX3("RC_HORAS")[1]) .Or. (TamSX3("RR_HORAS")[1] > TamSX3("RD_HORAS")[1]) .Or. (TamSX3("RR_HORAS")[1] > TamSX3("RGB_HORAS")[1])
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0189 + CRLF + STR0190 ), 1, 0)  // "Atenção"##"O tamanho dos campos RR_HORAS, RC_HORAS, RD_HORAS e RGB_HORAS está divergente e deveriam estar iguais."##"Solicite a correção ao administrador do sistema."
			lRet := .F.
			Break
		EndIf

		If cPaisLoc == "BRA" .and. !Empty(SRA->RA_DEMISSA) .and. SRA->RA_SITFOLH == "D" .and. SRA->RA_RESCRAI == '31'
			lRet := .F.
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0229) , 1, 0 ) //"Atenção" ## Funcionário foi transferido e não encontra-se ativo nesta empresa/filial."
			Break
		EndIf
		If ! SRA->RA_CATFUNC $ "A*P" // Se não for autônomo ou pró-labore verifica o controle de dias de direito
			If SRA->RA_CATFUNC $ "E*G"   // Estagiario Mensalista/Horista
				cCodFer	:= FGETCODFOL( "0891" )
				lEstag	:= .T.
			Else
				cCodFer	:= FGETCODFOL( "0072" )
			EndIf
			SRF->(DbSetOrder(2))
			lRet := SRF->( dbSeek( SRA->( RA_FILIAL + RA_MAT + cCodFer  ) ) )

			SRF->(DbSetOrder(1))

			If !lRet .AND. lGestPubl .AND. SRA->RA_CATFUNC $ '4*7*8*9' //GFP nao exige SRF das categorias Adido/Aponsentados/Pensionista
				lRet := .T.
			EndIf

			If !lRet .and. Empty(SRA->RA_DEMISSA)
				Iif(!lEstag, Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0039) , 1, 0 ), Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0148) , 1, 0 ) ) //"Atenção" ## Funcionário não tem registro cadastrado para o ID 0072/0891 no cadastro de Controle de Dias de Direito.
			Break
			EndIf
		EndIf

		lRet := .T.

		If fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetCalcRot('4') )
			cMesAnoRef  := aPerAtual[1,5] + aPerAtual[1,4]
			dDataDe  := aPerAtual[1,6]
			dDataAte := aPerAtual[1,7]
			cPeriodo := aPerAtual[1,1]
			cRot	 := aPerAtual[1,3]
			cNumPag	 := aPerAtual[1,2]
			cSemana	 := aPerAtual[1,2]
			cProcesso:= aPerAtual[1,8]

			lRetPer := fCarPeriodo( cPeriodo , cRot , @aPeriodo , @lUltSemana , @nPosSem)

			If !lRetPer
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0153), 1, 0)  // "Atenção"###"A configuração dos períodos está incorreta ou não existe período válido para o roteiro de rescisão. Verifique o cadastro de períodos."
				lRet := .F.
				Break
			EndIf

			NORMAL := aPeriodo[nPosSem,24] * SRA->RA_HRSDIA
			DESCANSO := aPeriodo[nPosSem,07] * SRA->RA_HRSDIA
		Else
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0021) + SRA->RA_PROCES + OemToAnsi(STR0022) + fGetCalcRot('4'), 1, 0)  // "Atenção"###"Não existe periodo aberto para o processo: ### roteiro:###"
			lRet := .F.
			Break
		EndIf

		dbSelectArea("SRG")

		If cModFol == "2"
			cResComp := "1"
			SRG->(DbSetOrder( RetOrdem( "SRG", "RG_FILIAL+RG_MAT+DTOS(RG_DTPAGO)" ) ))
			If SRG->(dbSeek(xFilial("SRG",SRA->RA_FILIAL)+SRA->RA_MAT))
				While SRG->(!Eof() .and. RG_FILIAL + RG_MAT == xFilial("SRG",SRA->RA_FILIAL) + SRA->RA_MAT )
					If SRG->RG_EFETIVA $ "1*2"
						Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0040), 1, 0 ) //"Nao é possivel incluir nova rescisao" ## "pois existe rescisao em aberto para este funcionario"
						lRet:= .F.
						Break
					EndIf
					SRG->(DbSkip())
				EndDo
				cResComp := "2"
			EndIf
		Else
			If lCpoReint
				SRG->(DbSetOrder( RetOrdem( "SRG", "RG_FILIAL+RG_MAT+RG_REINTEG" ) ))

				If SRG->(dbSeek(xFilial("SRG",SRA->RA_FILIAL)+SRA->RA_MAT+Space(FwTamSX3("RG_REINTEG")[1])))
					lTemRes := .T.
				Else
					SRG->(DbGoTop())
					If SRG->(dbSeek(xFilial("SRG",SRA->RA_FILIAL)+SRA->RA_MAT+"2"))
						lTemRes := .T.
					EndIf
				EndIf
			Else 
				SRG->(DbSetOrder( RetOrdem( "SRG", "RG_FILIAL+RG_MAT+DTOS(RG_DTGERAR)" ) ))
				If SRG->(dbSeek(xFilial("SRG",SRA->RA_FILIAL)+SRA->RA_MAT))
					lTemRes := .T.
				EndIf
			EndIf

			If lTemRes
				While SRG->(!Eof() .and. RG_FILIAL + RG_MAT == xFilial("SRG",SRA->RA_FILIAL) + SRA->RA_MAT )
					nRegSrg := SRG->( Recno() )
					If MesAno( SRG->RG_DTGERAR ) == cMesAnoRef
						nMaxCompl++
					EndIf
					nPos	:= aScan( aSrgRecnos , { |x| MesAno( x[2] ) == MesAno( SRG->RG_DTGERAR ) } )
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Se Teve Rescisao Complementar no Mesmo Mes da Demissao consi³
					³sidera apenas a Ultima										 ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If MesAno( SRG->RG_DTGERAR ) == MesAno( SRG->RG_DATADEM ) .And. nPos > 0.00 .And. !fCompPLR()
						aSrgRecnos[ nPos , 01 ] := nRegSrg
						aSrgRecnos[ nPos , 02 ] := SRG->RG_DTGERAR
						aSrgRecnos[ nPos , 03 ] := SRG->RG_DATADEM
					Else
						SRG->( aAdd( aSrgRecnos , { nRegSrg , RG_DTGERAR , RG_DATADEM } ) )
					EndIf

					SRG->(DbSkip())
				EndDo
				SRG->(DbGoTo(nRegSrg))

				cMesAnoDem	:= AnoMes(SRG->RG_DATADEM)
				lProxMes	:= !(cMesAnoRef == cMesAnoDem)

				If SRG->RG_EFETIVA == "N"
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0023),1,0 )//"Existe rescisão simulada gravada. Será aberta para efetivação."
					oModel:SetOperation(MODEL_OPERATION_UPDATE)
					lAtuSimul := .T.
					Break
				Else

					//Se ano da rescisao complementar (MV_FOLMES) for maior que ano da demissao, deve calcular RRA
					lRescRRA := If(SubStr(cMesAnoRef,1,4) > SubStr(cMesAnoDem,1,4),.T.,.F.)

					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Calculo de Rescisoes Complementares no Mesmo Mes/Ano e Limi³
					³ tado a 9 em funcao do campo RC_SEQ ser de Tamanho 1        ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If lProxMes
						If ( nMaxCompl < 9 )
							cCompl	:= "S"
							If !IsBlind()
								If cPaisLoc != "BRA" .Or. (!lIntTaf .And. !lMiddleware)
									lRescDis  := MsgYesNo( OemToAnsi( STR0124 ) , OemToAnsi( STR0123) ) //Rescisão Complementar. Deseja calcular a complementar por dissídio?
									cOpcCompl := If( lRescDis, "2", "1" )
								Else
									fAlertJob()
									If (cOpcCompl := OpcRecCom()) == "0"
										lCancelCalc := .F.
										lRet := .T.
										Break
									EndIf
									lRescDis  := (cOpcCompl == "2")
								EndIf
							Else
								If GetGlbVars("aRetAuto", @aRetAuto)
									lRescDis := aRetAuto[2]
									If Len(aRetAuto) < 3
										cOpcCompl := If( lRescDis, "2", "1" )
									Else
										cOpcCompl := aRetAuto[3]
									EndIf
								Else
									lRescDis := .F.
									cOpcCompl := If( lRescDis, "2", "1" )
								EndIf
							EndIf
							aPdResc		:= {}
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³ Matriz Verbas da Rescisao ja Paga para Calculo de Compl.   ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							fCarCompl( SRA->( RA_FILIAL + RA_MAT ) , @aPdResc, aSrgRecnos )
						Else
							Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0024),1,0 ) //"Excedeu o Número Máximo de Rescisões Complementares para Cálculo na Data Base"
							lRet := .F.
							Break
						EndIf
					Else
						fTemIdResc( SRA->( RA_FILIAL + RA_MAT ), aSrgRecnos )
						DbSelectArea("RCH")
						DbSetOrder(1)
						If DbSeek(xFilial("RCH",SRA->RA_FILIAL)+SRG->RG_PROCES+SRG->RG_PERIODO+SRG->RG_SEMANA+SRG->RG_ROTEIR)
							If !Empty(RCH->RCH_DTINTE)
								Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0122), 1, 0 ) //"Periodo referente a data de demissão já foi integrado."
								lRet := .F.
								Break
							EndIf
						EndIf

						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Apresenta Tela para Escolha da Opcoes de Recalculo ou   com³
						³ plementar quando Calculo no Mesmo Mes/Ano da Demissa		 ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						If IsBlind() .And. GetGlbVars("aRetAuto", @aRetAuto)
							nRecRes	:= aRetAuto[1]
							If nRecRes == 2
								lRescDis := aRetAuto[2]
							EndIf
						Else
							nRecRes 	:= OpcRecRes()
						EndIf

						If ( lRecRes := (  nRecRes == 1 ) )			//Recalculo de Rescisao
							cCompl := "N"
						ElseIf ( lRecRes := (  nRecRes == 2 ) )						//Rescisao Complementar
							cCompl := "S"
						ElseIf ( nRecRes == 3 )											//Rescisao com Reingresso - MEX
							If cPaisLoc $ "BRA|DOM|MEX" .And. Empty(SRA->RA_FECREI)
								Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0025),1,0 )//"Não há data de reingresso informada."
								lRet := .F.
								Break
							Else
								cCompl  := "N"
								lReingr := .T.
								/*
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³ Se for uma nova rescisão, e tem a data de reingresso		 ³
								³ retorna processo que o funcionário está no SRA, atual		 ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
								cProcesso := SRA->RA_PROCES
								cPeriodo  := ""
								cNumPag	  := ""
							EndIf
						Else
							lCancelCalc := .F.
							lRet := .T.
							Break
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		If (lIntTaf .Or. lMiddleware) .And. cPaisLoc == "BRA" .And. cCompl == 'S' .And. !lRobo
			fIncRes(SRA->RA_FILIAL, SRG->RG_TIPORES, @aInfoTpRes)
			If Len(aInfoTpRes) > 0 .And. Empty(aInfoTpRes[22])
				Help(,, OemToAnsi(STR0020),, + CRLF + OemToAnsi(STR0143) + " " + SRA->RA_CATEFD + ", " + OemToAnsi(STR0294), 1, 0,,,,,, { + CRLF + OemToAnsi(STR0295)})//"Atencao" ## "Para func. Cat.eSocial contido em:" ### " a coluna Mot. eSocial. (tabela S043) deverá estar preenchida." ### "Altere a tabela S043 e preencha o campo Mot. eSocial para o tipo de rescisão."
				lRet := .F.
			EndIf
		EndIf

		If lRecRes
			If cPaisLoc $ "BRA*EQU"
				If  SRG->RG_SABDOM == "1"
					lSabDom := .T.
				Else
					lSabDom := .F.
				EndIf
			EndIf
		Else
			lSabDom := SuperGetMv("MV_SABDOM",NIl,"N")=="S"
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Avisa ao usuario, porem permite continuar no calculo         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !IsBlind() .And. lRescDis .And. !fBuscaRHH(SRA->RA_FILIAL, SRA->RA_MAT,  cMesAnoRef)
			If !GetNewPar("MV_RHTAF")
				If !fBusSRKDis()
					MsgInfo(+ CRLF + OemToAnsi(STR0262) + CRLF + CRLF + OemToAnsi(STR0302)) // "Foi selecionada Rescisão Complementar por Dissídio, mas não foi encontrado cálculo de dissídio, caso seja realizada a geração do evento S-1200 posteriormente, esta rescisão não será considerada." ### "Caso já tenha efetuado calculo do Dissidio, verifique o compartilhamento de Empresa / Filial da tabela RHH através do Configurador."
				EndIf
			EndIf

			If lRet .And. GetNewPar("MV_RHTAF") .And. GetNewPar("MV_FASESOC") == '2'
				If MsgYesNo("Não foi encontrado cálculo de dissídio no período aberto! Deseja verificar se há valores de dissídio não quitados (SRK) em períodos anteriores?", "Rescisão Complementar por Dissídio.")
					If !fBusSRKDis()
						Help( ,, OemToAnsi(STR0020),, + CRLF + OemToAnsi(STR0263) + CRLF + CRLF + OemToAnsi(STR0302), 1, 0) // "Atenção" ## "Foi selecionada Rescisão Complementar por Dissídio, mas não foi encontrado cálculo de dissídio, a rescisão não será gerada." ### "Caso já tenha efetuado calculo do Dissidio, verifique o compartilhamento de Empresa / Filial da tabela RHH através do Configurador."
						lRet := .F.
					EndIf
				Else
					Help( ,, OemToAnsi(STR0020),, + CRLF + OemToAnsi(STR0263) + CRLF + CRLF + OemToAnsi(STR0302), 1, 0) // "Atenção" ## "Foi selecionada Rescisão Complementar por Dissídio, mas não foi encontrado cálculo de dissídio, a rescisão não será gerada." ### "Caso já tenha efetuado calculo do Dissidio, verifique o compartilhamento de Empresa / Filial da tabela RHH através do Configurador."
					lRet := .F.
				EndIf
			EndIf
		Endif

		If SRA->RA_SITFOLH == "A"
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0028),1,0 ) //Funcionário está com situação de afastado no cadastro.
		EndIf

		If SRA->RA_SITFOLH == "F"
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0029),1,0 )  //Funcionário está com situação de férias no cadastro.
		EndIf

		If lRecRes .AND. nRecRes == 1 .AND. SRG->RG_EFETIVA == "S" .And. fExisTitRe()
			If !lCtrlTit
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0218), 1, 0 ) //"Atençãoo, Cáculo de Rescisão cancelado pelo usuário."
			ElseIf lCtrlTit .And. Len( aLogErros ) > 0
					// "Atenção"###"Ação cancelada - título(s) encontrado(s) sobre essa rescisão."###"Consulte os títulos listados no log."
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0286), 1, 0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0288)})
					// Imprime Log
					fCtrTitLg()
			EndIf
			lRet := .F.
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega informacoes do salario do funcionario              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		fSalario(@Salario,@SalHora,@SalDia,@SalMes,"A",AnoMes(dDataDe),cNumPag)

		If lRet .And. !IsBlind() .And. dDatabase >= Stod("20230501") .And. (lIntTaf .Or. lMiddleware) .And. FindFunction("fChkNatSRV")
			fChkNatSRV(cFilAnt)
		EndIf

	ElseIf nOperation == MODEL_OPERATION_DELETE
		If Empty(cPeriodo)
			If fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetCalcRot('4') )
				cMesAnoRef  := aPerAtual[1,5] + aPerAtual[1,4]
				dDataDe  := aPerAtual[1,6]
				dDataAte := aPerAtual[1,7]
				cPeriodo := aPerAtual[1,1]
				cRot	 := aPerAtual[1,3]
				cNumPag	 := aPerAtual[1,2]
				cSemana	 := aPerAtual[1,2]
				cProcesso:= aPerAtual[1,8]

				lRetPer := fCarPeriodo( cPeriodo , cRot , @aPeriodo , @lUltSemana , @nPosSem)

				If !lRetPer
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0153), 1, 0)  // "Atenção"###"A configuração dos períodos está incorreta ou não existe período válido para o roteiro de rescisão. Verifique o cadastro de períodos."
					lRet := .F.
					Break
				EndIf

				NORMAL := aPeriodo[nPosSem,24] * SRA->RA_HRSDIA
				DESCANSO := aPeriodo[nPosSem,07] * SRA->RA_HRSDIA
			Else
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0021) + SRA->RA_PROCES + OemToAnsi(STR0022) + fGetCalcRot('4'), 1, 0)  // "Atenção"###"Não existe periodo aberto para o processo: ### roteiro:###"
				lRet := .F.
				Break
			EndIf
		EndIf
		//Verifica se rescisão foi calculada em período anterior
		If SRA->RA_SITFOLH == "D" .And. AnoMes(SRG->RG_DTGERAR) < cPeriodo .And. AnoMes(SRG->RG_DATADEM) < cPeriodo .AND. SRG->RG_EFETIVA <> 'N'
			Help(" ",1,"GPM040MANT")
			lRet := .F.
			Break
		EndIf

		nRegSrg := SRG->( Recno() )
		While SRG->(!Eof() .and. RG_FILIAL + RG_MAT == xFilial("SRG",SRA->RA_FILIAL) + SRA->RA_MAT )

			If MesAno( SRG->RG_DTGERAR ) == cMesAnoRef
				nMaxCompl++
			EndIf
			nPos	:= aScan( aSrgRecnos , { |x| MesAno( x[2] ) == MesAno( SRG->RG_DTGERAR ) } )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Se Teve Rescisao Complementar no Mesmo Mes da Demissao consi³
			³sidera apenas a Ultima										 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If MesAno( SRG->RG_DTGERAR ) == MesAno( SRG->RG_DATADEM ) .and. nPos > 0.00
				aSrgRecnos[ nPos , 01 ] := nRegSrg
				aSrgRecnos[ nPos , 02 ] := SRG->RG_DTGERAR
				aSrgRecnos[ nPos , 03 ] := SRG->RG_DATADEM
			Else
				SRG->( aAdd( aSrgRecnos , { nRegSrg , RG_DTGERAR , RG_DATADEM } ) )
			EndIf

			SRG->(DbSkip())
		EndDo
		SRG->(DbGoTo(nRegSrg))

		//Verifica se rescisão é a última calculada
		If aScan( aSrgRecnos, { |x| x[2] > SRG->RG_DTGERAR } ) > 0
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0209), 1, 0 ) //"A exclusão de Rescisões deverá ser feita do fim (última calculada) para o início (primeira calculada)"
			lRet := .F.
		EndIf

		If lRet .AND. SRG->RG_EFETIVA == "S" .And. fExisTitRe()
			If !lCtrlTit
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0218), 1, 0 ) //"Atençãoo, Cáculo de Rescisão cancelado pelo usuário."
			ElseIf lCtrlTit .And. Len( aLogErros ) > 0
					// "Atenção"###"Ação cancelada - título(s) encontrado(s) sobre essa rescisão."###"Consulte os títulos listados no log."
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0286), 1, 0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0288)})
					// Imprime Log
					fCtrTitLg()
			EndIf
			lRet := .F.
		EndIf

	EndIf

End Sequence

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fInitModel   ³ Autor ³ Leandro Drumond       ³ Data ³ 13/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Carrega enchoice apos ativacao do modelo.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fInitModel(oModel,nOperation)                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fInitModel(oModel,nOperation)
Local cTipoSind	:= ""
Local lConfCompl:= SRR->(ColumnPos("RR_VALORI")) > 0
Local oViewAux
Local oViewStruct
Local oViewSRG
Local oStruSRG

DEFAULT lGestPubl := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
DEFAULT lTemTpRem := SRG->( ColumnPos( "RG_TPREMAD" ) ) > 0

cIdHistMed := ""

If lAtuBrowse .And. nOperation <> MODEL_OPERATION_VIEW
	oViewSRG := FWViewActive()
	oStruSRG := oViewSRG:GetViewStruct("GPEM040_MSRG")
	If cPaisLoc == "BRA"
		oStruSRG:RemoveField('RG_RESCDIS')
		oStruSRG:RemoveField('RG_DSCRESC')
	EndIf
EndIf

If lAtuBrowse .and. lConfCompl .and. !Empty(SRA->RA_DEMISSA)
	If ( nOperation <> MODEL_OPERATION_INSERT .and. ( iif(cPaisloc=="BRA" .And. SRG->RG_RESCDIS == "0",.T.,.F.)  .or. AnoMes(SRG->RG_DATADEM) == AnoMes(SRG->RG_DTGERAR) ) ) .or. ( nOperation == MODEL_OPERATION_INSERT .and. (cCompl <> "S" .or. !lProxMes) )
		oViewAux := FWViewActive()
		oViewStruct := oViewAux:GetViewStruct("GPEM040_MGET")
		oViewStruct:RemoveField("RR_VALORI")
	EndIf
EndIf

If nOperation == MODEL_OPERATION_INSERT

	oModel:LoadValue("GPEM040_MSRG","RG_SALMES",SalMes)
	oModel:LoadValue("GPEM040_MSRG","RG_SALDIA",SalDia)
	oModel:LoadValue("GPEM040_MSRG","RG_SALHORA",SalHora)
	If lTCFA040
		oModel:LoadValue("GPEM040_MSRG","RG_TIPORES",cTipResPortal)
		GP40VldTpRes("S043",cTipResPortal)
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega informacoes do periodo				             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	oModel:LoadValue("GPEM040_MSRG","RG_PROCES",cProcesso)
	oModel:LoadValue("GPEM040_MSRG","RG_PERIODO",cPeriodo)
	oModel:LoadValue("GPEM040_MSRG","RG_SEMANA",cNumPag)
	oModel:LoadValue("GPEM040_MSRG","RG_ROTEIR",cRot)
	oModel:LoadValue("GPEM040_MSRG","RG_NORMAL",NORMAL)
	oModel:LoadValue("GPEM040_MSRG","RG_DESCANS",DESCANSO)
	If cPaisLoc == "BRA"
		oModel:LoadValue("GPEM040_MSRG","RG_JTCUMPR","1")
		oModel:LoadValue("GPEM040_MSRG","RG_RESCDIS", If( cCompl != "S", "0", cOpcCompl) )
	EndIf

	If cPaisLoc $ "BRA*EQU"
		oModel:LoadValue("GPEM040_MSRG","RG_SABDOM",If(lSabDom,"1","2"))
	EndIf

	If cModFol == "2"
		If(cPaisLoc $ "ARG*CHI*COL*COS*DOM*MEX")
			oModel:LoadValue("GPEM040_MSRG","RG_RESCOMP",cResComp)
		EndIf
	EndIf

	If SRG->( ColumnPos( "RG_PDRESC")) > 0 .And. RCE->(ColumnPos( "RCE_PDRESC")) > 0
		If lRescDis
			cTipoSind := Posicione("RCE",1,xFilial("RCE",SRA->RA_FILIAL)+SRA->RA_SINDICA,"RCE_PDRESC")
		EndIf
		oModel:LoadValue("GPEM040_MSRG","RG_PDRESC",IIf(Empty(cTipoSind),"1",cTipoSind))
	EndIf

	If cCompl == "S" .or. lRecRes
		SRG->(DbGoTo(nRegSrg))

		If cPaisLoc $ "BRA*EQU"
			oModel:LoadValue("GPEM040_MSRG","RG_SABDOM",SRG->RG_SABDOM)
		EndIf

		oModel:LoadValue("GPEM040_MSRG","RG_TIPORES",SRG->RG_TIPORES)
		oModel:LoadValue("GPEM040_MSRG","RG_MEDATU",SRG->RG_MEDATU)
		oModel:LoadValue("GPEM040_MSRG","RG_DATADEM",SRG->RG_DATADEM)
		If cCompl == "S"
			dDataDem1 := SRG->RG_DATADEM
			dDtProje  := SRG->RG_DTPROAV
			nDiasAV	  := SRG->RG_DAVISO
			nDiasCum  := SRG->RG_DAVCUM
			nDiaInde  := SRG->RG_DAVIND
		EndIf

		GP40VldTpRes('S043',SRG->RG_TIPORES)

		If cCompl == "S"
			oModel:LoadValue("GPEM040_MSRG","RG_DTAVISO",SRG->RG_DTAVISO)
		Else
			oModel:SetValue("GPEM040_MSRG","RG_DTAVISO",SRG->RG_DTAVISO)
		EndIf

		oModel:LoadValue("GPEM040_MSRG","RG_PERIODO",SRG->RG_PERIODO)
		oModel:LoadValue("GPEM040_MSRG","RG_SEMANA",SRG->RG_SEMANA)
		oModel:LoadValue("GPEM040_MSRG","RG_NORMAL",SRG->RG_NORMAL)
		oModel:LoadValue("GPEM040_MSRG","RG_DESCANS",SRG->RG_DESCANS)
		If cCompl == "S"
			oModel:LoadValue("GPEM040_MSRG","RG_SALMES",SRG->RG_SALMES)
			oModel:LoadValue("GPEM040_MSRG","RG_SALDIA",SRG->RG_SALDIA)
			oModel:LoadValue("GPEM040_MSRG","RG_SALHORA",SRG->RG_SALHORA)
			oModel:LoadValue("GPEM040_MSRG","RG_DFERVEN",SRG->RG_DFERVEN)
			oModel:LoadValue("GPEM040_MSRG","RG_DFERPRO",SRG->RG_DFERPRO)
			If(cPaisLoc == 'BRA')
				oModel:LoadValue("GPEM040_MSRG","RG_DFERAVI",SRG->RG_DFERAVI)
				oModel:LoadValue("GPEM040_MSRG","RG_OBITO",SRG->RG_OBITO)
			EndIf
		EndIf
		nDiasAv	:= SRG->RG_DAVISO
		If cCompl == "S"
			oModel:LoadValue("GPEM040_MSRG","RG_DAVISO",nDiasAv)
		Else 
			oModel:SetValue("GPEM040_MSRG","RG_DAVISO",nDiasAv)
		EndIf

		If ( cPaisLoc == 'BRA' )
			If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .And. SRG->(ColumnPos( "RG_DAVIND")) > 0
				nDiasCum	:= SRG->RG_DAVCUM
				nDiaInde 	:= SRG->RG_DAVIND
				oModel:LoadValue("GPEM040_MSRG","RG_DAVCUM",SRG->RG_DAVCUM)
				oModel:LoadValue("GPEM040_MSRG","RG_DAVIND",SRG->RG_DAVIND)
			Endif
		EndIf

		If lIndAv
		  oModel:LoadValue("GPEM040_MSRG","RG_INDAV",SRG->RG_INDAV)
		EndIf
		If lTemTpRem
            oModel:LoadValue("GPEM040_MSRG", "RG_TPREMAD", SRG->RG_TPREMAD)
            oModel:LoadValue("GPEM040_MSRG", "RG_DTQUAR", SRG->RG_DTQUAR)
        EndIf
	ElseIf cPaisLoc == "BRA"
		dbSelectArea("RFY")
		RFY->( dbSetOrder(1) )
		If RFY->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT ) )
			While RFY->( !EOF() ) .and. SRA->RA_FILIAL+SRA->RA_MAT == RFY->RFY_FILIAL+RFY->RFY_MAT
				If Empty(RFY->RFY_DTCAP) .and. Empty(RFY->RFY_TPCAP)
			    	cRfyTpAv	:= RFY->RFY_TPAVIS
			    	oModel:SetValue("GPEM040_MSRG","RG_DATADEM",RFY->RFY_DTPJAV)
			    	If !Empty(RFY->RFY_DTASVP)
				   		If !Empty(RFY->RFY_TPRESC)
				   			fIncRes(SRA->RA_FILIAL,RFY->RFY_TPRESC,@aIncRes,@nPercFgts,@cRescrais,@cAfasfgts,@Cod_Am)
				   			If RFY->(ColumnPos( "RFY_DAVCUM")) > 0
				   				nDiasCum 	:= RFY->RFY_DAVCUM
								nDiaInde 	:= (RFY->RFY_DIASAV-RFY->RFY_DAVCUM)
							Endif
							nDiasAv 	:= RFY->RFY_DIASAV
				   			lTemRFY := .T.
				   			GP40VldTpRes('S043',RFY->RFY_TPRESC)

					   		If !Empty(aIncRes) .And. !(aIncRes[2] $ "I/A")
					   			If ( cPaisLoc == 'BRA' )
						   			If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .And. SRG->(ColumnPos( "RG_DAVIND")) > 0
						   				oModel:LoadValue("GPEM040_MSRG","RG_DAVIND",RFY->RFY_DTASVP-RFY->RFY_DAVCUM)
						   				oModel:LoadValue("GPEM040_MSRG","RG_DAVCUM",RFY->RFY_DAVCUM)
						   			Endif
					   			EndIf
					   			oModel:LoadValue("GPEM040_MSRG","RG_DTAVISO",RFY->RFY_DTASVP)
					   		EndIf
					   	EndIf
				   		lTemRFY := .T.
			   		EndIf
			    	If !Empty(RFY->RFY_TPRESC)
			    		oModel:SetValue("GPEM040_MSRG","RG_TIPORES",RFY->RFY_TPRESC)
			    	Else
			    		oModel:LoadValue("GPEM040_MSRG","RG_DESCTPR","")
			    	EndIf
		    		oModel:LoadValue("GPEM040_MSRG","RG_DAVISO"	,RFY->RFY_DIASAV)

		    		If ( cPaisLoc == 'BRA' )
			    		If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .ANd. SRG->(ColumnPos( "RG_DAVIND")) > 0
			    			oModel:LoadValue("GPEM040_MSRG","RG_DAVCUM"	,RFY->RFY_DAVCUM)
							oModel:LoadValue("GPEM040_MSRG","RG_DAVIND"	,RFY->RFY_DIASAV-RFY->RFY_DAVCUM)
						Endif
					EndIf

					oModel:LoadValue("GPEM040_MSRG","RG_DTAVISO"	,RFY->RFY_DTASVP)
					oModel:LoadValue("GPEM040_MSRG","RG_DATADEM"	,RFY->RFY_DTPJAV)
		    		nDiasAv 	:= RFY->RFY_DIASAV
					If RFY->(ColumnPos( "RFY_DAVCUM")) > 0
						//Atribui às variáveis Private os valores digitados no cadastro do Aviso Prévio.
						nDiasCum 	:= RFY->RFY_DAVCUM
						nDiaInde 	:= (RFY->RFY_DIASAV-RFY->RFY_DAVCUM)
						dDataDem1	:= RFY->RFY_DTPJAV
						dDtProje	:= CtoD("")
						If !Empty(RFY->RFY_DTASVP)
							dDtProje    := RFY->RFY_DTASVP + nDiasAv
						EndIf
					Endif

					//Chama novamente o cálculo das férias.
					//Nesse ponto, o cadastro de Aviso Prévio existe, portanto, recalcula as férias, de acordo com os valores digitados pelo usuário.
					If !Empty(dDataDem1)
						//Calcula dias de ferias
						If lGestPubl .AND. cPaisLoc == "BRA" .AND. SRA->RA_REGIME == "2" .AND. FindFunction("fdFerResFP")
							fdFerResFP(.T.,dDataDem1)
						Else
							aPerFerias := {}
							fdFerRes(.T.,dDataDem1)
						EndIf

						oModel:LoadValue("GPEM040_MSRG","RG_DFERVEN", If(!lMetFalv, If(!lTempoParc, nDferven - nFaltasv, 0), nDferven / 2))
						oModel:LoadValue("GPEM040_MSRG","RG_DFERPRO", If(!lMetFalp, If(!lTempoPArc, nDferave - nFaltasp, 0), nDferave / 2))
						If (SRA->RA_TPCONTR == "3" .Or. SRA->RA_CATEFD $ '107/108') .and. nDferInd > 0
							nDferInd := 2.5	// Intermitente sempre será 1 avo
						EndIf
						oModel:LoadValue("GPEM040_MSRG","RG_DFERAVI",nDferInd)
					EndIf

					oModel:LoadValue("GPEM040_MSRG","RG_DTPROAV" , dDtProje)
		    		lTemRFY := .T.
			    	Exit
				EndIf
				RFY->( dbSkip() )
			EndDo
		ElseIf Empty(M->RG_TIPORES)
			If lTCFA040
				oModel:LoadValue("GPEM040_MSRG","RG_DESCTPR",fDescRCC("S043",cTipResPortal,1,2,3,30))
			Else
				oModel:LoadValue("GPEM040_MSRG","RG_DESCTPR","")
		EndIf
	EndIf
	EndIf
ElseIf nOperation <> MODEL_OPERATION_DELETE
	cDesc:= fDescRCC("S043",SRG->RG_TIPORES,1,2,3,30)
	oModel:LoadValue("GPEM040_MSRG","RG_DESCTPR",cDesc)
EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fChkDtDem    ³ Autor ³ Leandro Drumond       ³ Data ³ 13/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Checar a Data de Demissao do Funcionario.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³Logico   -> .T. para Data Valida e .F. para Data Nao Valida    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fChkDtDem( dDtDemAux 	,;	// Data de Demissao
					lMsg 		,;	// Se mostra mensagem de erro ou nao
					dRch_DtIni	,;	// Data de Inicio do Periodo
					dRch_DtFim	,;	// Data Final do Periodo
					lModDataDem ,;	// Nao Usado
					aLogErros	,;	// Array com o Log de Erros
					lResPos		;	// Nao Usado
				  )

Local aBuscaAf	:= {}
Local aTransf	:= {}
Local aPerAberto:= {}
Local aPerAtual	:= {}

Local cMsgData	:= ""
Local cMotEsoc  := ""

Local dDtPesq1	:= CtoD("//")
Local dDtPesq2	:= CtoD("//")
Local dDtInteg	:= CtoD("//")

Local lRet		:= .T.
Local lOrigem	:= .T.
Local lRetPer	:= .T.
Local lMotEsoc  := .T.
Local lRobo		:= IsBlind()

Local nX		:= 0
Local IsMILEFunc := .F.

Local lUsaGpe 	:= .T.

If FunName() == "GPEA010"
	IsMILEFunc := IsInCallStack("FWMILEIMPORT")
EndIf

If Type("lUltSemana") == "U"
	Private lUltSemana := .F.
EndIf

If Type("nPosSem") == "U"
	Private nPosSem := 0
EndIf

If Type("Salario") == "U"
	Private Salario := 0
EndIf

If Type("SalHora") == "U"
	Private SalHora := 0
EndIf

If Type("SalDia") == "U"
	Private SalDia := 0
EndIf

If Type("SalMes") == "U"
	Private SalMes := 0
EndIf

DEFAULT dDtDemAux 	:= &(ReadVar())
DEFAULT aLogErros	:= {}
DEFAULT lTemFerDesc := SRV->( ColumnPos( "RV_FERDESC")) > 0

/*Quando essa função for chamada a partir da Importação Logix
deve sempre retornar verdadeiro(.T.)*/
If (IsInCallStack("RHIMP01") .Or. IsInCallStack("GPEA265") .Or. IsInCallStack("RHIMPGEN") .Or. IsInCallStack("U_RHIMP08JOB") .Or. IsMILEFunc .Or. (FunName() == "GPEM040" .And. ProcName(3) == "SETRULES") )
	Return(.T.)
EndIf

dDataDem := dDataDem1 := dDtDemAux

lColetiva	:= If ( Type("LCOLETIVA")== "U" ,.F., lColetiva)
cCompl		:= If ( Type("CCOMPL")= "U" .Or. cCompl = Nil, "N", cCompl)
lMsg		:= If( lMsg == NIL .or. ValType( lMsg ) != "L"  , .T. , lMsg )

If !lColetiva .and. cPaisLoc $ "BRA*EQU"
	If FunName() $ "GPEA010|GPEA011"
		lSabDom := SuperGetMv("MV_SABDOM",NIl,"N")=="S"
	Else
		lSabDom := M->RG_SABDOM == "1"
	EndIf
EndIf

Begin Sequence


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Data de demissao nao foi preenchida ou invalida³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Empty( dDtDemAux )
		lRet := .F.
		If lMsg
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0043), 1, 0 ) //"Data em branco ou Invalida"
		Else
		  	aAdd( aLogErros, STR0043 )
		EndIf
		Break
	EndIf

/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Demissao nao Pode ser Inferior a Admissao                  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If dDtDemAux < SRA->RA_ADMISSA
		lRet := .F.
		If lMsg
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0044), 1, 0 ) //Data de Demissao nao Pode Ser Inferior a Admissao
		Else
		  	aAdd( aLogErros, STR0044 )
		EndIf
		Break
	EndIf

	//-- Quando o cadastro de funcionário for alterado por outro módulo verificar se o GPE está sendo utilizado
	If (FunName() $ "GPEA010/TRMA100"  .AND. cModulo != "GPE") .Or. (nModulo == 7 .and. IsincallStack("GPEI010"))
		dbSelectArea("SRD")
		If(! dbSeek(xFilial("SRD"))) .AND. EOF()
			dbSelectArea("SRC")
			If( ! dbSeek(xFilial("SRC"))) .AND. EOF()
				lUsaGpe := .F.
			EndIf
		EndIf
	EndIf

	If lUsaGpe
		If fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetCalcRot('4') )
			dRch_DtIni 	:= dDataDe  := aPerAtual[1,6]
			dRch_DtFim 	:= dDataAte := aPerAtual[1,7]
			cPeriodo 	:= aPerAtual[1,1]
			cRot	 	:= aPerAtual[1,3]
			cNumPag	 	:= aPerAtual[1,2]
			cProcesso	:= aPerAtual[1,8]
			dDtInteg	:= aPerAtual[1,10]
		ElseIf !(SRA->RA_CATFUNC $ "A|E|P") // Funcionários sem vínculo empregatício não necessita verificar o roteiro de rescisão.
			lRet := .F.

			If lMsg
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0046), 1, 0 )
			EndIf

			If !lRet
				Break
			EndIf
		EndIf
	EndIf

    //Nao permite rescisao com data anterior ao periodo atual
    If lUsaGpe .AND. !Empty(dRch_DtIni) .And. !Empty(dRch_DtFim)  .and. cCompl <> "S"
		If ( dDtDemAux < dRch_DtIni )
			cMsgData := STR0045 // "Data de Demissao menor que a Data Inicial do Periodo Atual"
			lRet := .F.
		ElseIf ( dDtDemAux > dRch_DtFim )
			fRetPerComp(SubStr(Dtos(dDataDem),5,2), SubStr(Dtos(dDataDem),1,4),, SRA->RA_PROCES,fGetCalcRot("4"),@aPerAberto )

			If Empty(aPerAberto)
				cMsgData := STR0046 //"Não existe período de cálculo aberto para a competência"
				lRet := .F.
			Else
				dDataDe 	:= aPerAberto[1,5]
				dDataAte 	:= aPerAberto[1,6]
				cPeriodo	:= aPerAberto[1,1]
				cNumPag		:= aPerAberto[1,2]
				dDtInteg	:= aPerAberto[1,11]
			EndIf
		EndIf

		If !(FunName() $ "GPEA010|GPEA011")
			aPeriodo 	:= {}

			If !(lRetPer := fCarPeriodo( cPeriodo , cRot , @aPeriodo , @lUltSemana , @nPosSem))
				If cSemana <> "01"
					cSemana := "01"
					lRetPer := fCarPeriodo( cPeriodo , cRot , @aPeriodo , @lUltSemana , @nPosSem)
				EndIf
			EndIf

			If !lRetPer
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0153), 1, 0)  // "Atenção"###"A configuração dos períodos está incorreta ou não existe período válido para o roteiro de rescisão. Verifique o cadastro de períodos."
				lRet := .F.
				Break
			EndIf

			//Altera periodo e semana na tela
			M->RG_PERIODO := cPeriodo
			M->RG_SEMANA  := cNumPag
			M->RG_NORMAL  := NORMAL := aPeriodo[nPosSem,24] * SRA->RA_HRSDIA
			M->RG_DESCANS := DESCANSO := aPeriodo[nPosSem,07] * SRA->RA_HRSDIA

			fSalario(@Salario,@SalHora,@SalDia,@SalMes,"A",AnoMes(dDataDe),cNumPag)

			M->RG_SALMES  := SalMes
			M->RG_SALDIA  := SalDia
			M->RG_SALHORA := SalHora

			//Ponto de Entrada para alteração do cabeçalho da rescisão - Tv Tribuna
			If ExistBlock( "GPESALAR" )
				ExecBlock("GPESALAR",.F.,.F.)
		EndIf

		EndIf

		If lMsg .and. !Empty( cMsgData )
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(cMsgData), 1, 0 )
		EndIf

		If !lRet
			Break
		EndIf
	EndIf

	If !Empty(dDtInteg)
		lRet := .F.
		If lMsg
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0122), 1, 0 ) //"Periodo referente a data de demissão já foi integrado."
		Else
		  	aAdd( aLogErros, STR0122 )
		EndIf
		Break
	EndIf

	If lUsaGpe .And. !( SRA->RA_CATFUNC $ "A|E|P" ) .And. IsInCallStack("CALRESC") .And. !fChkInteg( lMsg )
		lRet := .F.
		Break
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se o Funcionario esta Afastado                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	dDtPesq1	:= SRA->RA_ADMISSA
	dDtPesq2	:= dDtDemAux
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega os Afastamentos do Funcionario                     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cCompl <> "S" .and. fChkAfas(SRA->RA_FILIAL,SRA->RA_MAT, dDtPesq2, @dDtPesq2,,,dDtPesq2,YearSum(dDtPesq2, 1))
		fRetAfas(dDtPesq1, YearSum(dDtPesq2, 1),,,,, @aBuscaAf)
	EndIf

	If !Empty( aBuscaAf )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ordena o Array pelo Inicio do Afastamento                  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aSort( aBuscaAf,,,{ |x,y| x[3] < y[3] } )
		If cPaisLoc == "BRA" 
			cMotEsoc  := fGP40TPRES(M->RG_TIPORES,,, dDtDemAux)
			//Conforme MOS, permitir incluir rescisão quando funcionário possuir afastamento cadastrado para os seguintes motivos 
			If !Empty(cMotEsoc)
				lMotEsoc := !(cMotEsoc $ "07|09|10|11|12|13|14|16|21|22|23|24|25|26|29|30|32|34|36|37|38|39|40|43|44|47|48|49")
			EndIf
		EndIf
		For nX := 1 To Len( aBuscaAf )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Data de Demissao nao Pode ser Inferior ao Inicio do Afast. ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If dDtDemAux <= aBuscaAf[ nx , 3 ] 
				If lMotEsoc
					lRet := .F.
					If lMsg
						Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0047), 1, 0 ) //"Existe Afastamento Posterior à Data Informada"
					Else
						aAdd( aLogErros, STR0047 )
					EndIf
					Break
				Else 
					If lMsg .And. !lRobo
						lRet := MsgYesNo( OemToAnsi( STR0047) + ". " + OemTOAnsi(STR0042), OemTOAnsi(STR0020) )//"Atencao"###"Existe Afastamento Posterior à Data Informada"###"Continua?"
						If !lRet
							Break
						EndIf
					Else
						aAdd( aLogErros, STR0047 )
					EndIf
				EndIf
			EndIf

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Demissao nao pode ser Calculada com Funcionario Afastado   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If (cPaisLoc != "BRA" .Or. lMotEsoc) .And. (Empty( aBuscaAf[ nX , 4 ] ) .Or. aBuscaAf[ nX , 4 ] >= iif( cPaisLoc != "BOL" ,dDtDemAux,dDtDemAux+1))
				If aBuscaAf[nX,5] <> "F" .OR. !lTemFerDesc .OR. (!IsBlind() .And. IsInCallStack("CALRESC") .And. !MsgYesNo( OemToAnsi( STR0322 ) , OemToAnsi( STR0020) )) //"Existem férias calculadas com retorno posterior a data de demissão. Converter verbas de férias em dias de férias indenizadas?" ### Atenção
					lRet := .F.
					If lMsg
						Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0048), 1, 0 )	//"Demissao nao Pode ser Calculada com Funcionario Afastado"
					Else
						aAdd( aLogErros, STR0048 )
					EndIf
					Break
				EndIf
			EndIf
		Next nX
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se o Funcionario tem Transferencia                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cCompl <> "S" .and. fTransf(@aTransf,,,,,,,lOrigem)
		For nX := 1 To Len( aTransf )
			If dDtDemAux < aTransf[ nX , 7 ]
				lRet := .F.
				If lMsg
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0049), 1, 0 )	//"Existe Transferência Posterior à Data Informada"
				Else
					aAdd( aLogErros, STR0049 )
				EndIf
				Break
			EndIf
		Next nX
	EndIf

	dDataDem := dDataDem1 := dDtDemAux

	fDtSabDom()

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Tempo de Casa do Funcionario                               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nAnosCasa := fAnosCasa( dDataDem , SRA->RA_ADMISSA )

	If !(cCompl == "S")
		M->RG_DTGERAR := dDtDemAux
	EndIf

End Sequence

Return( lRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fdFerRes  ³ Autor ³ Equipe RH             ³ Data ³25/07/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Busca Dias de Ferias Vencidas e Proporcionais               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fdFerRes()                                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fdFerRes( lGpexmed, dtAviso, cMedAtu )

Local aAreaSRH		:= {}
Local aFer			:= {}
Local aFer14457	    := {}
Local aPerAux		:= {}
Local aPerAtual		:= {}
Local aPerFerAux	:= {}
Local cPd
Local dDtBaseFer
Local dDtIniPen
Local dDataDAux		:= CtoD("")
Local dDtSRFAux		:= CtoD("")
Local dDtIniPre		:= CtoD("")
Local dDtFimPre		:= CtoD("")
Local cMesAnoRef	:= ""
Local cSeekSRF		:= ""
Local lNoRescMes	:= .F.
Local lConvFProp	:= .F.
Local lDVenPen		:= .F.
Local lLei14457     := .F.
Local lMP1046       := .F.
Local lRescInFer	:= .F.
Local nDFerPag		:= 0.00
Local nDFerGoz 		:= 0
Local nVal_SalMin 	:= 0
Local nFaltasPer	:= 0
Local nTipFal		:= 0
Local nTotDDobra	:= 0
Local nFerA			:= 0
Local nFerAAux		:= 0
Local nFerV			:= 0
Local nFerVAux		:= 0
Local nRecAux		:= 0
Local nQtdAtiv		:= 0
Local nDFerVPgAnt	:= 0 //Dias de férias vencidos pagos no mes anterior
Local nDFerAPgAnt	:= 0 //Dias de férias antecipadas pagas no mes anterior
Local nx,nPos
Local nPosTbFer		:= 0
Local nTempoParc	:= 0
Local nDFerTot      := 0
Local nVencAux		:= 0
Local nPosFal		:= 0
Local aBkpFer		:= {}
Local cCodFer		:= ""

P_REGPARCI			:= If( Type("P_REGPARCI") == "U", .F. , P_REGPARCI)
P_PRJESTAB			:= If( Type("P_PRJESTAB") == "U", .F. , P_PRJESTAB)
P_LDOBAVI			:= If( Type("P_LDOBAVI") == "U", .T. , P_LDOBAVI)
dDtEst936			:= If( Type("dDtEst936") == "U", cToD("") , dDtEst936)

DEFAULT lGpexmed	:= .T.
DEFAULT cMedAtu     := "S"
DEFAULT dDataDem	:= M->RG_DATADEM
DEFAULT lGestPubl   := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
DEFAULT lTemPostUmT := SRH->( ColumnPos( "RH_POSTUMT" ) ) > 0

If cPaisLoc == "BRA" .AND. lGestPubl .AND. SRA->RA_REGIME == "2" .AND. FindFunction("fdFerResFP")
	fdFerResFP( lGpexmed, dtAviso )
	Return
EndIf

If cPaisLoc == "BRA" .And. !( Empty(dtAviso) )
	dDataDem := dtAviso
Endif

If IsInCallStack("GPEA011") .And. cCompl == "S" .And. lProxMes .And. cPeriodo > AnoMes( dDataDem )
	RstaPerAtu() //Reinicia o array _aPerAtu para pegar o período certo da folha
EndIf

//Busca periodo atual da folha
fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetRotOrdinar() ) // Busca o periodo aberto da folha

If !Empty(aPerAtual)
	cMesAnoRef := aPerAtual[1,5] + aPerAtual[1,4]
Else
	cMesAnoRef := AnoMes(dDataBase)
EndIf

Sal_Min(@nVal_SalMin, IIf(!Empty(dDataDem),AnoMes( dDataDem ),cMesAnoRef))

lNoRescMes			:= !( cMesAnoRef  == AnoMes( dDataDem ) )

If SRA->RA_CATFUNC $ "E*G"   // Estagiario Mensalista/Horista
	cCodFer	:= FGETCODFOL( "0891" )
Else
	cCodFer	:= FGETCODFOL( "0072" )
EndIf

Begin Sequence

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Funcao Para Calcular Dias Ferias Vencidas e Proporcionais  ³
	³ Achar os dias de Ferias sem a parte indenizada de Aviso 	 ³
	³ Previo													 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nDFerV 	 := 0
	nDFerA 	 := 0
	nDFerInd := 0
	nDFerAnt := 0

	If !(cPaisLoc $ "MEX|BOL|HAI")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Verifica a existecia do array aTabFer p/ o calculo de ferias |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Type("aTabFer") # "A" .Or. Len(aTabFer) == 0
			aTabFer	:= {}
			aTabFer2:= {}
			If cPaisLoc == "PER"
				fRetTab(@aTabFer,"S017",,,fCalcFimAq(Iif(dDataRef==Nil,dDataBase,dDataRef)),)
			Else
				If !(cPaisLoc $ 'ANG')
					fTab_Fer(@aTabFer,,@aTabFer2)
				EndIf
			EndIf
		EndIf

		//Se as horas semanais forem inferiores a 26, e o Mnemonico P_REGPARCI estiver ativo,
		//utiliza os dias de férias da tabela S065 - Tabela de férias tempo parcial (Artigo 130A da CLT)
		If cPaisLoc == "BRA"
			aAreaSRH   := SRH->( GetArea() )
			aPerDesc   := {}
			aPerDesc2  := {}
			nTempoParc := SRA->RA_HRSEMAN
			If ( SRA->RA_HOPARC == "1" .And. nTempoParc <= 25 .And. nTempoParc  > 0 .And. Len(aTabFer2) > 0	.And. P_REGPARCI )
				nPosTbFer := Ascan(aTabFer2, { |X|  nTempoParc <= X[6] .And. nTempoParc > X[5] })
				If nPosTbFer > 0
					aTabFer := aClone(aTabFer2[nPosTbFer])
				Endif
			Endif
		EndIf

		If cPaisLoc == "PER"
			If SRA->RA_MEIOPER == "1" //# Part Time
				nDiasFer := aTabFer[6]
			Else
				nDiasFer := aTabFer[5]
			EndIf
			nDiasAux := nDiasFer
		ElseIf cPaisLoc <> "ANG"
			nDiasFer := aTabFer[4]
			nDiasAux := aTabFer[3]
		EndIf

		DbSelectArea("SRF")
		DbSetOrder(2)

		cSeekSRF := SRA->RA_FILIAL + SRA->RA_MAT + cCodFer
		dDtSRFAux := CtoD("")

		If DbSeek(cSeekSRF)
			If SRF->RF_STATUS $ " 1"
				RecAux := SRF->(Recno()) //Grava o primeiro registro aberto da SRF
			EndIf
			While SRF->(!Eof() .and. RF_FILIAL + RF_MAT + RF_PD == cSeekSRF )
				aFer        := {}
				aFer14457   := {}
				If (SRF->RF_STATUS $ " 1" .and. ( SRF->RF_DFERVAT > 0 .or. SRF->RF_DFERAAT > 0  .or. SRF->RF_DVENPEN > 0 ) ) .or.; //Carrega o primeiro periodo aquisitivo com dias vencidos ou a vencer
				 	( cCompl == "S" .And. lProxMes .and. Ascan(aFerPag,{ |X| X[1] == SRF->RF_DATABAS .and. X[2] == SRF->RF_DATAFIM }) > 0 )  //Se for complementar, carrega a SRF dos períodos de férias pagos na rescisão.
					aAdd(aPerFerAux,{	SRF->RF_DATABAS	,;										  		 			// 01 - Inicio Database de Ferias
										If(Empty(SRF->RF_DATAFIM),fCalcFimAq(SRF->RF_DATABAS),SRF->RF_DATAFIM),;    // 02 - Final Database de Ferias
										SRF->RF_DFERVAT	,;															// 03 - Dias de ferias vencidas
										SRF->RF_DFERAAT	,;															// 04 - Dias de ferias a vencer
										0.00			,;															// 05 - Dias totais de afastamento por periodo
										SRF->RF_OBSERVA	,;															// 06 - Descricao do tipo de afastamento do periodo
										CtoD("")		,;															// 07 - Data de original de termino do p.aquisitivo quando houver prorrogacao do mesmo RWX
										If(Empty(SRF->RF_STATUS),"1",SRF->RF_STATUS),;								// 08 - Status do periodo de ferias:  1-Ativo (Vencidos/A vencer)/2-Prescrito (Perdido)/3-Pago
										CtoD("")		,;															// 09 - Data de Inicio do Proximo periodo caso seja um periodo perdido.
										0				,;															// 10 - Quantidade dias de deducao para o direito apurado no periodo
										SRF->RF_DVENPEN ,;     														// 11 - Dias Vencidos Pendentes
										SRF->RF_IVENPEN ,;     														// 12 - Data Inicia Vencido Pendente
										SRF->RF_FVENPEN ,;															// 13 - Data Inicia Vencido Pendente
										SRF->RF_DFERANT ,;     														// 14 - Dias de Ferias Antecipadas
										SRF->RF_DFALVAT ,;     														// 15 - Dias de Faltas Vencidas
										SRF->RF_DFALAAT ,; 				    										// 16 - Dias de Faltas a Vencer
										If(cPaisLoc$"VEN|EQU",SRF->RF_DBONVAT,NIL),;				 				// 17 - Dias de bono vencido
										If(cPaisLoc$"VEN|EQU",SRF->RF_DBONAAT,NIL),; 								// 18 - Dias de bono a Vencer
										0				,;															// 19 - Total de dias de ferias
										0				,;															// 20 - Total de dias de bonificacao
										0				,;															// 21 - Dias de Faltas vencidas bonificacao
										0				,;															// 22 - Dias de ¦Faltas a Vencer bonificacao
										0				,;															// 23 - Dias de ausencia convertidos em ferias
										0				,;      													// 24 - Total de Dias de Ferias do Periodo
										SRF->RF_DIASANT ,;					      									// 25 - Dias Gozados Vencidos
										SRF->RF_DIASANT	,;	    													// 26 - Dias Gozados a Vencer
										0               ,;      													// 27 - Dias Subsid. Vencidos
										0               ,;   														// 28 - Dias Subsid. a Vencer
										0				,; 															// 29 - Dias de Pagto. Minimo na Adm/Dem (cpo. RF_PAGOFER desabilitado 08/2012)
										SRF->( RECNO() ),;															// 30 - Recno do aquivo
										Iif(Type("SRF->RF_FERPAGA")<>"U",  SRF->RF_FERPAGA, 0) ,;					// 31 - Dias pagos em R$ na folha
										SRF->RF_DATAATU	,;															// 32 - Data de atualizacao
										0                ;                                                          // 33 - Dias de suspensão do período
										})
										If Empty(nRecAux)
											nRecAux := SRF->(Recno()) //Grava o primeiro registro aberto da SRF
										EndIf
				ElseIf SRF->RF_STATUS == "2" //Prescrito
					dDtIniPre := SRF->RF_DATABAS
					dDtFimPre := SRF->RF_DATAFIM
				EndIf
				If cCompl == "S" .And. lProxMes //Rescisao complementar
					dDtSRFAux := SRF->RF_DATAFIM + 1
				EndIf
				If cPaisLoc == "BRA" .And. cAfasfgts == "J " .And. (!Empty(aCodFol[1858, 1]) .Or. !Empty(aCodFol[1859, 1])) .And. (SRF->RF_DFERVAT == 0 .And. (SRF->RF_STATUS == "3" .Or. SRF->RF_DFERANT > SRF->RF_DFERAAT))
					SRH->( dbSetOrder(1) )//RH_FILIAL+RH_MAT+DTOS(RH_DATABAS)+DTOS(RH_DATAINI)
					If SRH->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+dToS(SRF->RF_DATABAS) ) )
						While SRH->( !EoF() ) .And. SRH->RH_FILIAL+SRH->RH_MAT+dToS(SRH->RH_DATABAS) == SRA->RA_FILIAL+SRA->RA_MAT+dToS(SRF->RF_DATABAS)
							lLei14457   := ( lTemPostUmT .And. SRH->RH_DATAINI >= cToD("21/09/2022") .And. ( ( SRH->RH_DFERIAS+SRH->RH_DABONPE > SRH->RH_DFERVEN ) .Or. ( SRH->RH_DATAINI < SRH->RH_DATABAS ) ) )
                            lMP1046     := ( SRH->RH_DATAINI >= cToD("28/04/2021") .And. SRH->RH_DATAINI <= cToD("25/08/2021") )
                            If lMP1046 .Or. lLei14457
                                aAdd( Iif( lMP1046, aFer, aFer14457), SRH->RH_DATAINI )
							EndIf
							SRH->( dbSkip() )
						EndDo
					EndIf
					If !Empty(aFer) .Or. !Empty(aFer14457)
						aPerAux		:= {}
						nFerAAux	:= 0
						nFerVAux	:= 0
						aAdd(aPerAux,	{	SRF->RF_DATABAS	,;										  		 			// 01 - Inicio Database de Ferias
											If(Empty(SRF->RF_DATAFIM),fCalcFimAq(SRF->RF_DATABAS),SRF->RF_DATAFIM),;    // 02 - Final Database de Ferias
											SRF->RF_DFERVAT	,;															// 03 - Dias de ferias vencidas
											SRF->RF_DFERAAT	,;															// 04 - Dias de ferias a vencer
											0.00			,;															// 05 - Dias totais de afastamento por periodo
											SRF->RF_OBSERVA	,;															// 06 - Descricao do tipo de afastamento do periodo
											CtoD("")		,;															// 07 - Data de original de termino do p.aquisitivo quando houver prorrogacao do mesmo RWX
											"1",;																		// 08 - Status do periodo de ferias:  1-Ativo (Vencidos/A vencer)/2-Prescrito (Perdido)/3-Pago
											CtoD("")		,;															// 09 - Data de Inicio do Proximo periodo caso seja um periodo perdido.
											0				,;															// 10 - Quantidade dias de deducao para o direito apurado no periodo
											SRF->RF_DVENPEN ,;     														// 11 - Dias Vencidos Pendentes
											SRF->RF_IVENPEN ,;     														// 12 - Data Inicia Vencido Pendente
											SRF->RF_FVENPEN ,;															// 13 - Data Inicia Vencido Pendente
											SRF->RF_DFERANT ,;     														// 14 - Dias de Ferias Antecipadas
											SRF->RF_DFALVAT ,;     														// 15 - Dias de Faltas Vencidas
											SRF->RF_DFALAAT ,; 				    										// 16 - Dias de Faltas a Vencer
											NIL,;				 														// 17 - Dias de bono vencido
											NIL,; 																		// 18 - Dias de bono a Vencer
											0				,;															// 19 - Total de dias de ferias
											0				,;															// 20 - Total de dias de bonificacao
											0				,;															// 21 - Dias de Faltas vencidas bonificacao
											0				,;															// 22 - Dias de ¦Faltas a Vencer bonificacao
											0				,;															// 23 - Dias de ausencia convertidos em ferias
											0				,;      													// 24 - Total de Dias de Ferias do Periodo
											SRF->RF_DIASANT ,;					      									// 25 - Dias Gozados Vencidos
											SRF->RF_DIASANT	,;	    													// 26 - Dias Gozados a Vencer
											0               ,;      													// 27 - Dias Subsid. Vencidos
											0               ,;   														// 28 - Dias Subsid. a Vencer
											0				,; 															// 29 - Dias de Pagto. Minimo na Adm/Dem (cpo. RF_PAGOFER desabilitado 08/2012)
											SRF->( RECNO() ),;															// 30 - Recno do aquivo
											Iif(Type("SRF->RF_FERPAGA")<>"U",  SRF->RF_FERPAGA, 0) ,;					// 31 - Dias pagos em R$ na folha
											SRF->RF_DATAATU	,;															// 32 - Data de atualizacao
											0                ;                                                          // 33 - Dias de suspensão do período
											})
						Calc_Fer(@aPerAux, dDataDem, @nFerVAux, @nFerAAux,,,,.F.,aPerAux[1])
						If nFerVAux == 0 .And. SRF->RF_DFERANT > nFerAAux
							aAdd( Iif( !Empty(aFer), aPerDesc, aPerDesc2 ), { SRF->RF_DATABAS, SRF->RF_DATAFIM, nFerAAux, SRF->RF_DFERANT, Iif( !Empty(aFer), aFer, aFer14457 ) } )
						EndIf
					EndIf
				EndIf
				SRF->(DbSkip())
			EndDo
			If nRecAux > 0
				SRF->(DbGoTo(nRecAux))
			ElseIf !(SRF->RF_FILIAL + SRF->RF_MAT + SRF->RF_PD == cSeekSRF) //Posiciona no último registro da SRF
				SRF->(DbSkip(-1))
				If (SRF->RF_FILIAL + SRF->RF_MAT + SRF->RF_PD == cSeekSRF) .And. SRF->RF_STATUS == "3"
					aAdd(aPerFerAux,{	SRF->RF_DATABAS	,;										  		 			// 01 - Inicio Database de Ferias
										If(Empty(SRF->RF_DATAFIM),fCalcFimAq(SRF->RF_DATABAS),SRF->RF_DATAFIM),;  // 02 - Final Database de Ferias
										SRF->RF_DFERVAT	,;															// 03 - Dias de ferias vencidas
										SRF->RF_DFERAAT	,;															// 04 - Dias de ferias a vencer
										0.00			,;															// 05 - Dias totais de afastamento por periodo
										SRF->RF_OBSERVA	,;															// 06 - Descricao do tipo de afastamento do periodo
										CtoD("")		,;															// 07 - Data de original de termino do p.aquisitivo quando houver prorrogacao do mesmo RWX
										If(Empty(SRF->RF_STATUS),"1",SRF->RF_STATUS),;								// 08 - Status do periodo de ferias:  1-Ativo (Vencidos/A vencer)/2-Prescrito (Perdido)/3-Pago
										CtoD("")		,;															// 09 - Data de Inicio do Proximo periodo caso seja um periodo perdido.
										0				,;															// 10 - Quantidade dias de deducao para o direito apurado no periodo
										SRF->RF_DVENPEN ,;     														// 11 - Dias Vencidos Pendentes
										SRF->RF_IVENPEN ,;     														// 12 - Data Inicia Vencido Pendente
										SRF->RF_FVENPEN ,;															// 13 - Data Inicia Vencido Pendente
										SRF->RF_DFERANT ,;     														// 14 - Dias de Ferias Antecipadas
										SRF->RF_DFALVAT ,;     														// 15 - Dias de Faltas Vencidas
										SRF->RF_DFALAAT ,; 				    										// 16 - Dias de Faltas a Vencer
										If(cPaisLoc$"VEN|EQU",SRF->RF_DBONVAT,NIL),;				 				// 17 - Dias de bono vencido
										If(cPaisLoc$"VEN|EQU",SRF->RF_DBONAAT,NIL),; 								// 18 - Dias de bono a Vencer
										0				,;															// 19 - Total de dias de ferias
										0				,;															// 20 - Total de dias de bonificacao
										0				,;															// 21 - Dias de Faltas vencidas bonificacao
										0				,;															// 22 - Dias de ¦Faltas a Vencer bonificacao
										0				,;															// 23 - Dias de ausencia convertidos em ferias
										0				,;      													// 24 - Total de Dias de Ferias do Periodo
										SRF->RF_DIASANT ,;					      									// 25 - Dias Gozados Vencidos
										SRF->RF_DIASANT	,;	    													// 26 - Dias Gozados a Vencer
										0               ,;      													// 27 - Dias Subsid. Vencidos
										0               ,;   														// 28 - Dias Subsid. a Vencer
										0				,; 															// 29 - Dias de Pagto. Minimo na Adm/Dem (cpo. RF_PAGOFER desabilitado 08/2012)
										SRF->( RECNO() ),;															// 30 - Recno do aquivo
										Iif(Type("SRF->RF_FERPAGA")<>"U",  SRF->RF_FERPAGA, 0) ,;					// 31 - Dias pagos em R$ na folha
										SRF->RF_DATAATU ,;                                                          // 32 - Data de atualizacao
										0                ;                                                          // 33 - Dias de suspensão do período
										})
				EndIf
			EndIf
		EndIf

		If cPaisLoc == "BRA"
			RestArea( aAreaSRH )
		EndIf

		//	aPerFerias - Mnemonico tipo Publico com os Periodos de Ferias
		If !(cCompl == "S" .And. lProxMes) //Apenas executa se não for complementar
			If !Empty(nRecAux) //Tratamento para quando ocorrer rescisão durante período de férias partidas. Transformar férias pagas em férias indenizadas na rescisão
				SRF->(DbGoTo(nRecAux))
				SRF->(DbSkip(-1)) //Volta para o último período fechado
					
				If SRA->RA_FILIAL+SRA->RA_MAT != SRF->RF_FILIAL+SRF->RF_MAT //Verifica se o registro posicionado na SRF esta correto devido ao DbSkip, caso não esteja posiciona no recno ativo e zera o array para os casos de férias partidas com dias de férias inferior aos dias vencidos
					SRF->(DbGoTo(nRecAux))
				EndIf	

				dbSelectArea("SRH")
				DbSetOrder(1)
				
				If SRH->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + DtoS(SRF->RF_DATABAS)))
					While SRH->(!Eof() .and. RH_FILIAL + RH_MAT + DtoS(RH_DATABAS) == SRA->RA_FILIAL + SRA->RA_MAT + DtoS(SRF->RF_DATABAS))
						If SRH->RH_PERIODO < M->RG_PERIODO .and. SRH->RH_DATAFIM > dDataDem
							aPerFerAux := {}
							aAdd(aPerFerAux,{	SRF->RF_DATABAS				,;
												fCalcFimAq(SRF->RF_DATABAS)	,;
												SRF->RF_DFERVAT	,;															// 03 - Dias de ferias vencidas
												SRF->RF_DFERAAT	,;															// 04 - Dias de ferias a vencer
												0.00			,;															// 05 - Dias totais de afastamento por periodo
												SRF->RF_OBSERVA	,;															// 06 - Descricao do tipo de afastamento do periodo
												CtoD("")		,;															// 07 - Data de original de termino do p.aquisitivo quando houver prorrogacao do mesmo RWX
												"1"				,;															// 08 - Status do periodo de ferias:  1-Ativo (Vencidos/A vencer)/2-Prescrito (Perdido)/3-Pago
												CtoD("")		,;															// 09 - Data de Inicio do Proximo periodo caso seja um periodo perdido.
												0				,;															// 10 - Quantidade dias de deducao para o direito apurado no periodo
												SRF->RF_DVENPEN ,;     														// 11 - Dias Vencidos Pendentes
												SRF->RF_IVENPEN ,;     														// 12 - Data Inicia Vencido Pendente
												SRF->RF_FVENPEN ,;															// 13 - Data Inicia Vencido Pendente
												SRF->RF_DFERANT - SRH->RH_DFERIAS - SRH->RH_DABONPE ,;     					// 14 - Dias de Ferias Antecipadas
												SRF->RF_DFALVAT ,;     														// 15 - Dias de Faltas Vencidas
												SRF->RF_DFALAAT ,; 				    										// 16 - Dias de Faltas a Vencer
												If(cPaisLoc$"VEN|EQU",SRF->RF_DBONVAT,NIL),;				 				// 17 - Dias de bono vencido
												If(cPaisLoc$"VEN|EQU",SRF->RF_DBONAAT,NIL),; 								// 18 - Dias de bono a Vencer
												0				,;															// 19 - Total de dias de ferias
												0				,;															// 20 - Total de dias de bonificacao
												0				,;															// 21 - Dias de Faltas vencidas bonificacao
												0				,;															// 22 - Dias de ¦Faltas a Vencer bonificacao
												0				,;															// 23 - Dias de ausencia convertidos em ferias
												0				,;      													// 24 - Total de Dias de Ferias do Periodo
												SRF->RF_DIASANT ,;					      									// 25 - Dias Gozados Vencidos
												SRF->RF_DIASANT	,;	    													// 26 - Dias Gozados a Vencer
												0               ,;      													// 27 - Dias Subsid. Vencidos
												0               ,;   														// 28 - Dias Subsid. a Vencer
												0				,; 															// 29 - Dias de Pagto. Minimo na Adm/Dem (cpo. RF_PAGOFER desabilitado 08/2012)
												SRF->( RECNO() ),;															// 30 - Recno do aquivo
												Iif(Type("SRF->RF_FERPAGA")<>"U",  SRF->RF_FERPAGA, 0) ,;					// 31 - Dias pagos em R$ na folha
												SRF->RF_DATAATU ,;                                                          // 32 - Data de atualizacao
												0                ;                                                          // 33 - Dias de suspensão do período
												})
							nRecAux := SRF->(Recno())
							lRescInFer := .T.
							aSort( @aPerFerAux, , , { | x, y | x[ 1 ] < y[ 1 ] } )
							Exit
						EndIf
						SRH->(DbSkip())
					EndDo 
				EndIf
				SRF->(DbGoTo(nRecAux))
			EndIf
			If Len(aPerFerAux) > 0
				If !Empty(dDtIniPre) .and. Empty(aPerFerAux[Len(aPerFerAux),3]) .And. Day(dDtIniPre) == Day(aPerFerAux[Len(aPerFerAux),1]) .And. Month(dDtIniPre) == Month(aPerFerAux[Len(aPerFerAux),1])
					nQtdAtiv := 0
					Aeval(aPerFerAux, { |X| nQtdAtiv += If ( X[8] == "1" .And. X[1] > dDtIniPre ,1,0) } )
					If nQtdAtiv < 2 .and. dDtFimPre + 1 >= aPerFerAux[Len(aPerFerAux),1]//Se o período anterior ao ultimo estava prescrito, efetua calc_fer considerando o período anterior para avaliação correta dos afastamentos sequenciais
						If ( ( Len(aPerFerAux) == 1 .and. Empty(aPerFerAux[Len(aPerFerAux),4]) ) .or. ( Len(aPerFerAux) > 1 .and. aPerFerAux[Len(aPerFerAux),1] - 1 > aPerFerAux[Len(aPerFerAux)-1,2] ) )
							aPerFerAux[Len(aPerFerAux),1] := dDtIniPre
						EndIf
					ElseIf nQtdAtiv == 0 //Ainda não existe período ativo gravado na SRF após o último preescrito. Cria período com inicio no último período preescrito e fim do período que seria o atual
						aAdd(aPerFerAux,{	dDtIniPre					,;
											fCalcFimAq(dDtFimPre + 1)	,;
											0.00			,;
											0.00			,;
											0.00			,;
											""				,;
											CtoD("")		,;
											"1"				,;
											CtoD("")		,;
											0.00			,;
											0.00			,;
											CtoD("")		,;
											CtoD("")		,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00		    ,;
											0.00			,;
											0.00		    ,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											CtoD("")		,;
											0.00             ;
											})
					EndIf
				EndIf

				For nPos := 1 to Len(aPerFerAux) - 1
					nFerV += aPerFerAux[nPos,3]
					nFerA += aPerFerAux[nPos,4]
				Next nPos

				aAdd(aPerFerias,aPerFerAux[Len(aPerFerAux)])
			EndIf

			dDataDAux := dDataDem

			fDtSabDom() //Verifica se deve pagar o sabado e domingo para utilizar na apuração dos avos.

			Calc_Fer(@aPerFerias,dDataDem, @nDferv, @nDfera,,,,.F.,If(Len(aPerFerias)>0,aPerFerias[Len(aPerFerias),1],dDtSRFAux))

			dDataDem := dDataDAux //Retorna datadem original

			If Len(aPerFerAux) > 0
				For nPos := 1 to Len(aPerFerias)
					If nPos == 1
						aPerFerAux[Len(aPerFerAux)] := aClone(aPerFerias[nPos])
					Else
						aAdd(aPerFerAux, aPerFerias[nPos])
					EndIf
				Next nPos
				aPerFerias := aPerFerAux
			EndIf
		Else
			aPerFerias := aClone(aPerFerAux)
			nDFerV := SRG->RG_DFERVEN
			nDFerA := SRG->RG_DFERPRO
		EndIf

		nDFerV += nFerV
		nDFerA += nFerA

		// Verifica e Aplica a Tabela de Faltas
		If !(cPaisLoc $ "ANG/ARG/EQU")
			aFaltasPer := {}
			nFalAtuD   := 0
			Calmed( @nfaltasv, @nFaltasp, lGpexmed, dDtBaseFer, nVal_SalMin, @aFaltasPer, cMedAtu )
		EndIf

		nPos		:= Ascan(aPerFerias,{ |X| X[8] == "1" })
		nPos		:= If(nPos == 0,Len(aPerFerias),nPos)
		If nPos > 0
			dDtBaseFer	:= aPerFerias[nPos,1]
			dDtIniPen	:= aPerFerias[nPos,12]
			lDVenPen	:= (aPerFerias[nPos,11] > 0 .and. !Empty(aPerFerias[nPos,12]))
		    dDT1        := dDtBaseFer // dDt1 - Mnemonico Tipo Publico utilizado no GPEXMED
			Aeval(aPerFerias, { |X| nDFerAnt += If ( X[8] = "1" .OR. ( cCompl == "S" .and. x[3] > 0 ),X[14],0) } ) // Apura dias de Ferias Antecipadas
			If cCompl == "S" .And. Len(aFerPag) > 0 .And. aPerFerias[nPos,8] <> "1" //Quando complementar, subtrai os dias pagos na rescisão
				nVencAux := nDFerV
				For nX := Len(aFerPag) to 1 step -1 //Trata do mais recente para o mais antigo
					If aFerPag[nX,3] - Int(aFerPag[nX,3]) == 0.12
						//Pode ocorrer casos em que o valor gerado na SRR não condiz com a referência dos avos.
						// Por isso, busca a quantidade de dias vencidos e subtrai a referência da SRR.
						If Int(aFerPag[nX,3]) < 12
							nDFerTot := nVencAux - Int(aFerPag[nX,3]) * nDiasFer
						Else
							nDFerTot := 0
							nVencAux -= ( Int(aFerPag[nX,3]) * nDiasFer )
						EndIf
						//Caso o valor seja < 0, quer dizer que tem menos dias vencidos do que referência.
						//Exemplo: 24 Dias Vencidos e 12/12 gerados na SRR.
						// 24 - (12 * 2,5) = -6
						If nDFerTot < 0
							nDFerTot := nDFerTot * (- 1)
						EndIf
						nDFerAnt -= (Int(aFerPag[nX,3]) * nDiasFer) + nDFerTot
						If !lRescDis
							nDFerAnt := Max(nDFerAnt, 0)
						EndIf
					Else
						nDFerAnt -=  aFerPag[nX,3]
					EndIf
				Next nX

				//Subtrai os dias de faltas que foram descontados
				If (nPosFal := aScan(aFaltasPer, {|X| X[1] = CVALTOCHAR(nPos + If(nPos > 1, 3, 0))})) > 0
					nDFerAnt -= aFaltasPer[nPosFal, 2]
				EndIf

			EndIf
		EndIf

		If !(cCompl == "S" .and. Len(aFerPag) > 0)
			dbSelectArea("SRH")
			DbSetOrder(1)
			
			For nx := 1 to Len(aPerFerias)
				SRH->( MsSeek( SRA->RA_FILIAL + SRA->RA_MAT + Dtos(aPerFerias[nx,1]) ) )
				While !Eof() .And. SRH->RH_FILIAL + SRH->RH_MAT + Dtoc(SRH->RH_DATABAS) == SRA->RA_FILIAL + SRA->RA_MAT + Dtoc(aPerFerias[nx,1])
					If cPaisLoc == "EQU"
						If SRH->RH_PERIODO == cPeriodo .And. SRH->RH_NPAGTO == cNumPag
							nDFerGoz+= SRH->RH_DFERIAS  //ferias gozadas
							nDFerGoz+= SRH->RH_DBONIFI  //ferias vendidas (Abono pec)
						EndIf
					Else
						If MesAno(SRH->RH_DATAINI) == MesAno(dDataDem) .Or. ( lNoRescMes .And. MesAno(SRH->RH_DATAFIM) == MesAno(dDataDem) ) .or. ( lRescInFer .and. SRH->RH_DATAFIM > dDataDem )
							If SRH->RH_DFERIAS + SRH->RH_DABONPE + SRH->RH_DFALTAS + nDFerAnt >= nDiasAux  .and. !(MesAno(SRH->RH_DATAINI) == MesAno(dDataDem)) .and. !lRescInFer
								dDtBaseFer 	:= SRH->RH_DBASEAT + 1
								If cCompl <> "S" .and. lNoRescMes .and. MesAno(SRH->RH_DATAINI) == cMesAnoRef
									If aPerFerias[nX,3] > 0
										nDFerVPgAnt += SRH->RH_DFERIAS + SRH->RH_DABONPE
									Else
										nDFerAPgAnt += SRH->RH_DFERIAS + SRH->RH_DABONPE
									EndIf
								EndIf
							Else
								If cPaisloc <> "VEN"
									If SRH->RH_DATAFIM <= dDatadem
										nDFerAnt  += SRH->RH_DABONPE + SRH->RH_DFERIAS
									ElseIf dDataDem >= SRH->RH_DATAINI
										nDFerAnt += dDataDem - SRH->RH_DATAINI
									EndIf
								EndIf
							EndIf
						//Se férias foi paga durante o período aberto da folha e rescisão esta sendo calculada para o futuro, subtrai os dias de férias pagos no mês anterior da rescisão
						ElseIf cCompl <> "S" .and. lNoRescMes .and. MesAno(SRH->RH_DATAINI) == cMesAnoRef
							If aPerFerias[nX,3] > 0
								nDFerVPgAnt += SRH->RH_DFERIAS + SRH->RH_DABONPE
								If nDFerVPgAnt + SRF->RF_DFERANT >= aTabFer[3] //Se o período foi quitado (30 dias pago), altera o registro na SRF
									SRF->(DbSkip())
									If !(SRF->RF_FILIAL + SRF->RF_MAT == SRA->RA_FILIAL + SRA->RA_MAT ) .and. nRecAux > 0
										SRF->(DbGoTo(nRecAux))
									Else
										nRecAux := SRF->(Recno())
									EndIf
								EndIf
							Else
								nDFerAPgAnt += SRH->RH_DFERIAS + SRH->RH_DABONPE
							EndIf
						EndIf
					EndIf
					dbSkip()
				Enddo
			Next nx
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Calcular Dias de Ferias						 			 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nDFerVen := 0
		nDFerAve := 0
		If cCompl <> "S"
			dDataDAux := dDataDem

			fDtSabDom() //Verifica se deve pagar o sabado e domingo para utilizar na apuração dos avos.

			aBkpFer := aClone(aPerFerias)
			If cPaisLoc $ "PTG|ARG|VEN|COL|ANG|PER|EQU"
				Calc_Fer(@aPerFerias , dDataDem , @nDferven, @nDferave,,,,.f.)
			ElseIf !Empty(aIncRes) .And. aIncRes[2] $ "T*B" .And. cPaisLoc == "BRA"
				Calc_Fer(@aPerFerias, Iif( P_PRJESTAB .And. dDtEst936 > dDataDem, (dDtEst936+nDiaInde), (dDataDem+nDiaInde) ),@nDferven,@nDferave,,,,.F.,dDtSRFAux)
			Else
				Calc_Fer(@aPerFerias, Iif( cPaisLoc == "BRA" .And. P_PRJESTAB .And. dDtEst936 > dDataDem, dDtEst936 + If(!Empty(aIncRes) .And. aIncRes[2]$ "S*I*A", nDiasAv, 0), dDataDem + If( !Empty(aIncRes) .And. aIncRes[2]$ "S*I*A".And. !(cPaisLoc $"ARG|CHI"), nDiasAv, 0)), @nDferven, @nDferave,,,,.F.,dDtSRFAux)
			EndIf
			aPerFerias := aBkpFer

			//Subtrai os dias de férias pagos no mês da folha que ainda esta aberto
			If nDFerVPgAnt > 0 .and. nDFerV > 0
				nDFerV -= nDFerVPgAnt
				nDferven -= nDFerVPgAnt
				If nDFerV == 0 //Se período foi quitado, altera aPerFerias para calcular médias corretamente
					If ( nPos := aScan(aPerFerias, {|x| x[8] == "1" .and. x[3] > 0}) ) > 0
						aPerFerias[nPos,8] := "3"
					EndIf
				EndIf
			ElseIf nDFerAPgAnt > 0 .and. nDFerA > 0
				nDFerA := Max(0,nDFerA - nDFerAPgAnt)
				nDferave := Max(0, nDFerAve - nDFerAPgAnt)
			EndIf

			//Calcular dias ferias sobre aviso, vencido e proporcionais
			nDferInd := ( (nDferven +  nDferave) - ( nDferv + nDfera ) )     // Dias Ferias sobre aviso previo
			nDferven := nDferv               								 // Dias Ferias Indenizados sem aviso
			nDferave := nDfera		         								 // Dias Ferias Proporcionais sem aviso

			dDataDem := dDataDAux //Retorna datadem original
		Else
			If(cPaisLoc == 'BRA')
				nDferInd := SRG->RG_DFERAVI
			EndIf
			nDferave := SRG->RG_DFERPRO
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		|Se apurada ferias vencidas em consequencia do aviso,subtrair|
		|da vencidas, a ferias a vencer calculada sem o aviso.       |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If ( nDferInd == nDiasAux )
			nDferInd -= nDfera   // 1/12 avos de ferias sobre aviso indenizado
		EndIf

		// Verifica e Aplica a Tabela de Faltas
		If !(cPaisLoc $ "ANG/ARG/EQU")
			aFaltasPer := {}
			nFalAtuD   := 0
			Calmed( @nfaltasv, @nFaltasp, lGpexmed, dDtBaseFer, nVal_SalMin, @aFaltasPer, cMedAtu )
		EndIf

		If(cPaisLoc == 'BRA')
			lDFerAvi := !(SRG->RG_DFERAVI == 0 .and. nDiasAv > 0 .and. cCompl == "S")
		Else
			lDFerAvi := !(nDiasAv > 0 .and. cCompl == "S")
		EndIf
		//FALTAS
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ A rotina de media gera as faltas por periodos com a data demissao sem    ³
		//³ o aviso previo. As faltas ficam gravadas no periodo correspondente,      ³
		//³ podendo ser, proporcional ou vencidas. 									 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se for complementar antes da separacao dos dias ferias sobre aviso, pode  ³
		//³ocorrer com o aviso previo indenizado ou quando completa os 12 meses com a³
		//³data da demissao, as ferias proporcionais podem passar a ser vencidas, e  ³
		//³as faltas ficarem gravadas no periodo proporcional. Nessas situacoes      ³
		//³utilizar faltas do periodo proporcional par abater das ferias vencidas.   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If (nDFerA > 0 .And. nDFerVen >= nDFerV) .or. (nDFerA == 0 .And. nDFerVen > 29 )
			nfaltasv := nFaltasp := 0
			nFaltasPer	:= aScan(aFaltasPer, { |x| x[ 1 ] == "2" } )

		  	If ( nFaltasPer > 0 )  .and. !lDFerAvi // 	//-- Se encontrou algum periodo com faltas proporcionais e calculo sem a separacao das ferias sobre aviso.
				//-- Na existencia de periodos de ferias, as ferias proporcionais somente serão convertidas em vencidas
				//-- caso o periodo das mesmas compreenda a da data de demissao
				lConvFProp:= ( 	;
								( Type("aPerFerias") != "U" .and. ;
								  Dtos( aPerFerias[ Len( aPerFerias ) ,2 ] )  >= Dtos(dDataDem) .and. ;
								  aPerFerias[ Len(aPerFerias),3 ] > 0;
								) .or.;
							 	Type("aPerFerias") == "U" ;
							 )
		        If  lConvFProp
					If( ( nTipFal := Val( aFaltasPer[ Len( aFaltasPer ), 1 ] ) ) >= 5, nTipFal := nTipFal + 1, If( aFaltasPer[ 1, 1 ] == "1", nTipFal := 5, nTipFal := 1 ) )
					aFaltasPer[ nFaltasPer, 1 ] := Alltrim( Str( nTipFal ) )
					aSort( @aFaltasPer, , , { | x, y | x[ 1 ] < y[ 1 ] } )
				EndIf
			EndIf
		EndIf

		//Calculo das faltas vencidas proporcionais aos dias de ferias vencidas por periodo
		If Len( aFaltasPer ) > 0

			nFaltasv := 0
			aEval( aFaltasPer, {|x| nFaltasv +=If( x[ 1 ] <> "2" , x[2],0) })

			nFaltasp:=0
			aEval( aFaltasPer, {|x| nFaltasp +=If( x[ 1 ] == "2" , x[2],0) })

		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ A rotina de media gera as faltas por periodos com a data demissao sem     ³
		³ o aviso previo e o periodo para faltas pode ser proporcional e com o aviso³
		³ as ferias mudou de proporcional para vencidas e as faltas ficaram gravada ³
		³ no periodo proporcional, nessa situacao utilizar faltas do periodo        ³
		³ proporcional par abater das ferias vencidas.                              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If nDFerV == 0 .And. nDFerA > 0 .And. nFaltasv = 0 .And. nDFerVen > 0
			nfaltasv := nFaltasp
			nFaltasp  := 0
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		| Calcula as Faltas Proporcionais							 |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !P_REGPARCI .And. !lTempoParc
			nFaltasp := ((nFaltasp / 30) * nDferAve)
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		| Calculo de Ferias Dobrada									 |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !SRA->RA_CATFUNC $ "E*G" .and. SRA->RA_TPCONTR <> "3"//Se for estagiario ou intermitente não calcula férias em dobro
			If cPaisLoc == "BRA"
				fDiasDobra( ndDobro, 0, .F., Iif(cCompl <> "S", nDferven, nDFerV), If( lDVenPen, dDtIniPen, dDtBaseFer ), Iif( P_LDOBAVI .And. !Empty(dDtProje), dDtProje, dDataDem ), Iif( P_LDOBAVI .And. !Empty(dDtProje), dDtProje, dDataDem ), @nTotDDobra, aFaltasPer, nDFerAnt + nDFerVPgAnt + nDFerAPgAnt, dDataDem, nDiaInde)
				ndDobro	:= nTotDDobra
			Else
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				| Calculo de Ferias Dobrada									 |
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If (nDFerVen / nDiasAux) > 1
					ndDobro := ( (Int(nDFerVen / nDiasAux)-1 ) * nDiasAux )
					ndDobro -= nDFerAnt
				EndIf
			EndIf
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Deducao de dias de ferias antecipadas                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !(cCompl == "S" .and. Len(aFerPag) > 0) .And. nDFerAnt > 0 .AND. cPaisLoc <> "ANG"
			If nDferave > 0 .And. nDferven = 0
				nDferave -= nDFerAnt
			ElseIf nDferven > 0
				nDferven -= nDFerAnt
			EndIf
			If nDFerInd > 0 .and. ( nDferave < 0 .or. nDferven < 0 )
				nDFerInd += If(nDferave < 0, nDferave, nDferven)
				nDFerInd := Max(nDFerInd, 0)
			EndIf
			nDferave := If(nDferave < 0, 0, nDferave)
			nDferven := If(nDferven < 0, 0, nDferven)
		EndIf

		If nDFerVPgAnt > 0 .and. nDFerV > 0
			nDFerAnt += nDFerVPgAnt
		EndIf
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Zera dias de Ferias para Funcionarios com Menos de um ano de³
		³Casa e quando o Tipo de Rescisao estiver com "N" para o  Cal³
		³culo de Ferias Prop. Enunc. 261 do TST e art. 147 da CLT.   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !(cPaisLoc$"PTG|ARG|VEN|COL|ANG|PER|EQU") .And. !Empty(aIncRes) .And. aIncRes[4] = "N" .And. nAnosCasa < 1
			nDferave := 0 ; nDferven := 0
		EndIf

		//Desconta dias de ferias ja pagos ou gozados no periodo da rescisao
		If cPaisLoc == "EQU" .And. nDFerGoz > 0
			If nDferven > nDFerGoz
				nDFerVen-= nDFerGoz
			Else
				nDFerGoz-= nDFerVen
				nDFerVen:= 0
				nDFerAVe:= Max(	nDFerAVe - nDFerGoz, 0 )
			EndIf
		EndIf

	Else

		If cPaisLoc == "BOL"
			aTabFer := {}
			aTabFer2 := {}
			fTab_Fer(@aTabFer, , @aTabFer2)
		EndIf

		nDferven := 0
		nDferave := 0
		nDFerPag := 0

		DbSelectArea( "SRF" )
		DbSetOrder( RetOrdem( "SRF", "RF_FILIAL+RF_MAT+RF_PD+DTOS(RF_DATABAS)" ))
		cPd := fGetCodFol("0072")	// ID de Vacaciones
		Dbseek( SRA->RA_FILIAL + SRA->RA_MAT + cPd, .F. )
		While !Eof() .and. SRF->(RF_FILIAL+RF_MAT+RF_PD) == (SRA->RA_FILIAL + SRA->RA_MAT + cPd)
			If cPaisLoc != "BOL" .Or. SRF->RF_STATUS $ " 1"
				nDferven += SRF->RF_DFERVAT
				nDferave += SRF->RF_DFERAAT
				nDFerPag += SRF->RF_DFERANT
			EndIf
			DbSkip()
		EndDo
		If cPaisLoc == "BOL" .And. nDferave > 0
			SRF->( DbSetOrder(1) )
			SRF->( Dbseek( SRA->RA_FILIAL + SRA->RA_MAT, .F. ) )
			While SRF->( !Eof() ) .And. SRF->RF_FILIAL+SRF->RF_MAT == SRA->RA_FILIAL+SRA->RA_MAT
				If SRF->RF_PD == cPd .AND. SRF->RF_STATUS $ " 1"
					dDataDe :=CtoD( StrZero(Day(SRA->RA_ADMISSA),2)+ "/"+RCH->RCH_MES+"/"+RCH->RCH_ANO) //DIA ADM + MES/ANO PERIODO.
					dDataIniP :=CtoD( StrZero( DAY( SRA->RA_ADMISSA ), 2 ) + "/" + StrZero( Month( SRA->RA_ADMISSA ),2 ) + "/" + StrZero(YEAR(dDataDe),4 ) )  //DIA/MES ADM + ANO PERIODO
					If dDataIniP <= dDataDe
						dDtFimP := CtoD( StrZero( DAY( SRA->RA_ADMISSA ),2 ) + "/" + StrZero( Month( SRA->RA_ADMISSA ) ,2 ) + "/" + StrZero( YEAR(dDataDe) + 1, 4) ) -1
					Else
						dDataIniP:= CtoD( StrZero( DAY( SRA->RA_ADMISSA) , 2 )  + "/" + StrZero( Month( SRA->RA_ADMISSA ) ,  2 ) + "/" + StrZero( YEAR(DDATADE ) - 1,  4 ) )
						dDtFimP := CtoD( StrZero( DAY( SRA->RA_ADMISSA ), 2 ) + "/" + StrZero( Month( SRA->RA_ADMISSA ),2  ) + "/" + StrZero(YEAR(DDATADE) , 4) ) -1
					EndIf

					If SRA->RA_ADMISSA < dtAviso
						DDATAF := dtAviso
						NANOSTRAB := (( DDATAF - SRA->RA_ADMISSA) + 1) / 365
						NX := FPOSTAB("S010", SRA->RA_PROCES, "=", 4 , NANOSTRAB , "<=" , 6 )
						NDIASVAC := If(NX > 0,  FTABELA("S010" , NX , 7 ) ,  0 )
						If NDIASVAC > 0
							nDferven := 0
							nDferave := (NANOSTRAB - Int(NANOSTRAB)) * NDIASVAC

							If SRF->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT ) )
								While SRF->( !EoF() ) .And. SRF->RF_FILIAL + SRF->RF_MAT == SRA->RA_FILIAL + SRA->RA_MAT
									If SRF->RF_DFERVAT > 0 .And. SRF->RF_STATUS == "1"
										nDferven += SRF->RF_DFERVAT
									ElseIf SRF->RF_DFERVAT == 0
										nDferave -= SRF->RF_DFERANT
									EndIf
									SRF->( dbSkip() )
								End
							EndIf
						EndIf
					EndIf
					Exit
				EndIf
				SRF->( DbSkip())
			EndDo
		EndIf

		SR8->( dbSetOrder(1) )
		If SR8->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+cPeriodo ) )
			While SR8->( !EoF() ) .And. SR8->R8_FILIAL+SR8->R8_MAT+SubStr( DToS(SR8->R8_DATAINI), 1, 6 ) == SRA->RA_FILIAL+SRA->RA_MAT+cPeriodo
				If SR8->R8_TIPOAFA == "VAC"
					nDFerAux += SR8->R8_DURACAO
					nDFerPag += SR8->R8_DURACAO
				EndIf
				SR8->( dbSkip() )
			EndDo
		EndIf

		If nDFerPag > 0
		   If nDferven >= nDFerPag
		   		nDferven := nDferven - nDFerPag
		   Else
		   		If nDferave >= (nDFerPag - nDferven)
		   			nDferave := nDferave - (nDFerPag - nDferven)
		   		Else
		   			nDferave := 0
		   		EndIf
		   		nDferven := 0
		   EndIf
		EndIf
	EndIf

End Sequence

Return( Nil )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CalMed       ³ Autor ³ Leandro Drumond       ³ Data ³ 08/01/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo das Medias do Funcionario							     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso	     ³GPEM040													     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function CalMed( nFaltasv, nFaltasp, lGpexmed, dDtBaseFer, nVal_SalMin, aFaltasPer, cMedAtu )

Local aPerAtual		:= {}
Local APdAux		:= aPd
Local cTipMed		:= ""
Local cMesAnoRef	:= ""

Local nX			:= 0.00
Local nFalAtu		:= 0.00
Local nLenaPd		:= 0.00
Local nQtdPer		:= 0.00
Local lResMSeg		:= .F.
Local nNroFaltas	:= 0.00
Local nFaltasU		:= 0
Local nTotFal		:= 0       //Total faltas sem o desconto
Local nAux			:= 0

lMetadeFal			:= If( Type("lMetadeFal") == "U", .F. , lMetadeFal)
lMetFalP			:= If( Type("lMetFalP") == "U", .F. , lMetFalP)
lMetFalV			:= If( Type("lMetFalV") == "U", .F. , lMetFalV)

DEFAULT lGpexmed	:= .T.
DEFAULT dDtBaseFer	:= SRF->RF_DATABAS
DEFAULT cMedAtu	    := "S"

fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetCalcRot('4')  ) // Busca o periodo aberto da rescisao

If !Empty(aPerAtual)
	cMesAnoRef := aPerAtual[1,5] + aPerAtual[1,4]
Else
	cMesAnoRef := AnoMes(dDataBase)
EndIf

lResMSeg := ( MesAno( dDataDem ) > cMesAnoRef )

aPd := {}

fCarRGB()

nLenaPd := Len(aPd)

Begin Sequence

	DbSelectArea( cTBLXMED )

	nFaltasv := nFaltasp := 0

	If lGpexmed

		If (cTBLXMED)->( RECCOUNT() ) > 0
			zap
		EndIf

		If cCompl == "S"
			M->RG_DFERVEN := SRG->RG_DFERVEN
			M->RG_DFERPRO := SRG->RG_DFERPRO
		EndIf

		GPEXMED(dDtBaseFer, ,dDataDem,dDataDem,dDataDem,SalHora,nVal_SalMin,aCodfol,,If( lResMSeg, .T., .F. ),.T.)
		For nX := 1 To 6
			cTipMed	   := Str( IF(nX ==1, 1,nX+3),1 )
			nNroFaltas := 0
			IF dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cTipMed + "998" + "9698" )
				nNroFaltas := (cTBLXMED)->RP_HORAS
				nTotFal	   := nNroFaltas
				TabFaltas(@nNroFaltas)
				aAdd( aFaltasPer, { cTipMed, nNroFaltas, nTotFal })
			EndIF
			lMetFalV := lMetadeFal
			nFaltasv += nNroFaltas
		Next nX
		If !Empty(aFaltasPer)
			nFaltasU := aFaltasPer[Len(aFaltasPer),2]
		EndIf
	EndIf

	nNroFaltas := 0

    If cPaisLoc != "BRA" .Or. cMedAtu == "S"
        For nX := 1 To nLenaPd
            If aPd[nX,9] <> "D"
                //--Verifica se ‚ falta/Atraso para descontar Ferias e 13o.
                If aPd[nX,1] $ ( aCodFol[054,1]+'*'+aCodFol[203,1]+'*'+aCodFol[055,1]+'*'+aCodFol[242,1]+'*'+ aCodFol[243,1]+'*'+aCodFol[244,1]+'*'+aCodFol[245,1] )
                    nFalAtu := 0
                    If aPd[nX,6] = "D"
                        nFalAtu := aPd[nX,4]
                    ElseIf aPd[nX,6] == "H"
                        nFalAtu := aPd[nX,4]/Round(SRA->RA_HRSMES/30,2)
                    EndIf
                    If Upper(AllTrim(PosSrv(aPd[nX,1],SRA->RA_FILIAL,"RV_MEDFER"))) $ "S *SP"
                        If !( aPd[nX,1]  $ aCodFol[244,1] + '_' + aCodFol[245,1] )
                            If ( Empty(aPd[nX,10]) .Or. nDferv == 0 .Or. (nDferv > 0 .And. aPd[nX,10] >= aPerFerias[Len(aPerFerias),1]) )
                                nFaltasP += nFalAtu
                            Else
                                nNroFaltas += nFalAtu
                            EndIf
                        Else
                            If ( Empty(aPd[nX,10]) .Or. nDferv == 0 .Or. (nDferv > 0 .And. aPd[nX,10] >= aPerFerias[Len(aPerFerias),1]) )
                                nFaltasP -= nFalAtu
                            Else
                                nNroFaltas -= nFalAtu
                            EndIf
                        EndIf
                    EndIf
                    If Upper(AllTrim(PosSrv(aPd[nX,1],SRA->RA_FILIAL,"RV_MED13"))) == "S"
                        If !( aPd[nX,1]  $ aCodFol[244,1] + '_' + aCodFol[245,1] )
                            nFalAtuD += nFalAtu
                        Else
                            nFalAtuD -= nFalAtu
                        EndIf
                    EndIf
                EndIf
            EndIf
        Next nX
    EndIf

	If nNroFaltas > 0
		If Len(aFaltasPer) > 0
			nNroFaltas += aFaltasPer[Len(aFaltasPer),3]
			nAux := nNroFaltas
			TabFaltas(@nNroFaltas)
			aFaltasPer[Len(aFaltasPer),2] := nNroFaltas
			aFaltasPer[Len(aFaltasPer),3] := nAux
			lMetFalV := lMetadeFal
			nFaltasv += (nNroFaltas - nFaltasU)
		Else
			nAux := nNroFaltas
			TabFaltas(@nNroFaltas)
			aAdd( aFaltasPer, { "1", nNroFaltas, nAux })
			nFaltasv += (nNroFaltas - nFaltasU)
		EndIf
	EndIf

	//-- Busca as faltas lancadas na rescisao original para o calculo do 13o salario
	If cCompl == "S" .And. lProxMes
		For nX := 1 To Len(aPdResc)
			//--Somente considera as verbas que nao estao excluidas
			If aPdResc[nX,9] <> "D"
				//--Verifica se ‚ falta/Atraso para descontar Ferias e 13o.
				If aPdResc[nX,1] $ ( aCodFol[054,1]+'*'+aCodFol[203,1]+'*'+aCodFol[055,1]+'*'+aCodFol[242,1]+'*'+ ;
						aCodFol[243,1]+'*'+aCodFol[244,1]+'*'+aCodFol[245,1] )
					nFalAtu := 0
					If aPdResc[nX,6] = "D"
						nFalAtu := aPdResc[nX,4]
					ElseIf aPdResc[nX,6] == "H"
						nFalAtu :=  Int(aPdResc[nX,4]/Round(SRA->RA_HRSMES/30,2))
					EndIf
					If Upper(AllTrim(PosSrv(aPdResc[nX,1],Sra->Ra_Filial,"RV_MED13"))) == "S"
						If !( aPdResc[nX,1]  $ aCodFol[244,1] + '_' + aCodFol[245,1] )
							nFalAtuD += nFalAtu
						Else
							nFalAtuD -= nFalAtu
						EndIf
					EndIf
				EndIf
			EndIf
		Next nX
	EndIf

	dbSelectArea(cTBLXMED)
	IF dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + "2" + "998" + "9698" )
		nFaltasP += (cTBLXMED)->RP_HORAS
	EndIF

	If nFaltasP > 0
		If nDferave > 0 .or. ( cCompl == "S" .And. lProxMes .and. SRG->RG_DFERPRO > 0 )
			TabFaltas(@nFaltasp, nDferave)
			aAdd( aFaltasPer, { "2", nFaltasp })
			lMetFalP := lMetadeFal
		ElseIf Len(aPerFerias) <= 1 .or. !( Empty(aPerFerias[Len(aPerFerias)][3]) .and. aPerFerias[Len(aPerFerias)-1][8] == "2") //Se o último período não tem dias e o anterior estiver prescrito, ignora as faltas

			nQtdPer 	:= Len(aFaltasPer) //Qtd de periodos de faltas
			nFaltasV	:= If(nQtdPer>0,aFaltasPer[nQtdPer,3],0) + nFaltasP
			nFaltasP	:= 0

			TabFaltas(@nFaltasV)
			lMetFalV := lMetadeFal

			If nQtdPer > 0
				aSort( @aFaltasPer, , , { |x,y| X[1] < y[1] } )
				aFaltasPer[nQtdPer,2] := nFaltasV
			Else
				aAdd( aFaltasPer, { "1", nFaltasV })
			EndIf
		EndIf
	EndIf

End Sequence

If( Len( aFaltasPer ) > 0, aSort( @aFaltasPer, , , { | x, y | x[ 1 ] < y[ 1 ] } ), )

aPd := APdAux

Return( Nil )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCarCompl    ³ Autor ³ Leandro Drumond       ³ Data ³ 08/01/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Carregar os Valores Pagos Anteriormente que serao utilizados	 ³±±
±±³          ³para o Calculo da Rescisao complementar Feita Fora da   Data	 ³±±
±±³          ³de Demissao													 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso	     ³GPEM040													     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fCarCompl( cFilMat , aPdResc , aSrgRecnos )

Local aArea		:= GetArea()
Local cSeq		:= " "
Local dDataGer	:= Ctod("//")
Local dDataPag	:= Ctod("//")
Local nPerc		:= 0.00
Local nPosPd	:= 0.00
Local nV		:= 0.00
Local nX		:= 0.00
Local nPos		:= 0.00
Local nPosIns	:= 0.00
Local nVezes	:= Len( aSrgRecnos )
Local nValTerP	:= 0
Local nValTerV	:= 0
Local nCount	:= 0
Local lRatProv	:= GetMvRH("MV_RATPROV", Nil, "N") == "S"
//Novos adicionais rescisão.
Local cIdsADI   := aCodFol[1680,1] + "/" + aCodFol[1681,1] + "/" + aCodFol[1682,1] + "/" + aCodFol[1683,1] + "/" + aCodFol[1684,1] + "/" +;
					   aCodFol[1685,1] + "/" + aCodFol[1686,1] + "/" + aCodFol[1687,1] + "/" + aCodFol[1688,1] + "/" + aCodFol[1689,1] + "/" +;
					   aCodFol[1690,1] + "/" + aCodFol[1691,1] + "/" + aCodFol[1692,1] + "/" + aCodFol[1693,1] + "/" + aCodFol[1694,1] + "/" +;
					   aCodFol[1695,1] + "/" + aCodFol[1696,1] + "/" + aCodFol[1697,1] + "/" + aCodFol[1698,1] + "/" + aCodFol[1699,1] + "/" +;
					   aCodFol[1700,1] + "/" + aCodFol[1701,1] + "/" + aCodFol[1702,1] + "/" + aCodFol[1703,1] + "/" + aCodFol[1704,1] + "/" +;
					   aCodFol[1705,1] + "/" + aCodFol[1706,1] + "/" + aCodFol[1707,1] + "/" + aCodFol[1708,1] + "/" + aCodFol[1709,1] + "/" +;
					   aCodFol[1710,1] + "/" + aCodFol[1711,1] + "/" + aCodFol[1712,1] + "/" + aCodFol[1713,1] + "/" + aCodFol[1714,1] + "/" +;
					   aCodFol[1715,1] + "/" + aCodFol[1716,1] + "/" + aCodFol[1717,1] + "/" + aCodFol[1718,1] + "/" + aCodFol[1719,1] + "/" +;
					   aCodFol[1720,1] + "/" + aCodFol[1721,1]

DEFAULT lTribIR := SRR->( ColumnPos( 'RR_TRIBIR' ) ) > 0

aPdResc	    := {}
aPd			:= {}
aFerPag		:= {}
aPerDobra   := {}
LTEMIDRESC 	:= .F.

SRR->(DbSetOrder(3))

For nV := 1 To nVezes
	dDataGer	:= aSrgRecnos[ nV , 02 ]
	lMesDem     := ( MesAno( aSrgRecnos[ nV , 02 ] ) == MesAno( aSrgRecnos[ nV , 03 ] ) )
	If SRR->( dbSeek( cFilMat + "R" + Dtos( dDataGer ) ) )
		While SRR->( !Eof() .and. RR_FILIAL + RR_MAT + RR_TIPO3 + Dtos( RR_DATA ) == cFilMat + "R" + Dtos( dDataGer ) )
			dDataPag := SRR->( If( Empty( RR_DATAPAG ) , RR_DATA , RR_DATAPAG ) )

			If SRR->RR_PD $ cIdsADI
				LTEMIDRESC := .T.
			EndIf

			If SRR->RR_PD == aCodFol[86,1] //Se for verba referente a férias indenizadas, grava período para posterior carga no aPerFerias
				If ( nPos := aScan( aFerPag, { |x| dToS(x[1])+dToS(x[2]) == SubStr(SRR->RR_NUMID,1,8)+SubStr(SRR->RR_NUMID,12,8) } ) ) == 0
					aAdd(aFerPag, { StoD(SubStr(SRR->RR_NUMID,1,8)), StoD(SubStr(SRR->RR_NUMID,12,8)), SRR->RR_HORAS, SRR->RR_DATA, SRR->RR_CC + SRR->RR_ITEM + SRR->RR_CLVL})
				ElseIf aFerPag[nPos, 5] <> SRR->RR_CC + SRR->RR_ITEM + SRR->RR_CLVL
					aFerPag[nPos, 3] += SRR->RR_HORAS
				EndIf
			ElseIf SRR->RR_PD $ aCodFol[224,1] + "/" + aCodFol[925,1]//Férias em Dobro
			 	aAdd(aPerDobra, {StoD(SubStr(SRR->RR_NUMID,1,8)),StoD(SubStr(SRR->RR_NUMID,12,8)), SRR->RR_HORAS, 0, 0})
			 	ndDobro += SRR->RR_HORAS
			EndIf

			cSeq := SRR->RR_SEQ

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se nao Existir a Verba em aPd acrescenta					 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If lRatProv
				If (AnoMes(SRR->RR_DATA) == cPeriodo .And. SRR->RR_TIPO2 $ "I/E") .Or. ;
				   ( ;
				   		nPosPd := aScan( aPD , { |x|  x[1] == SRR->RR_PD .And. x[11] == SRR->RR_SEQ .And. x[2] == SRR->RR_CC  .And. AnoMes(x[18]) == AnoMes(dDataGer) .Or. ;
													( x[1] == SRR->RR_PD .And. x[11] == SRR->RR_SEQ .And. x[2] == SRR->RR_CC .And. AnoMes(x[18]) <> AnoMes(dDataGer) .And. ;
														( ( SRR->RR_TIPO2 $ "I/E" .And. x[7] $ "I/E" ) .Or. ( SRR->RR_TIPO2 == "G" .And. x[7] == "G" .And. SRR->RR_TIPO1 == "H" .And. x[6] == "H"  ) ) ;
													) ;
												};
										 ;
										)  ) == 0.00
					aScan(aPd, {|X| If( x[1] == SRR->RR_PD .And. x[11] >= SRR->RR_SEQ .And. x[2] == SRR->RR_CC, cSeq := Soma1(cSeq), cSeq := cSeq) })
					SRR->( fMatriz(RR_PD, RR_VALOR, SRR->RR_HORAS, RR_SEMANA, RR_CC, RR_TIPO1, RR_TIPO2, 0, "", dDataPag, Nil, cSeq, Nil, Nil, Nil, Iif(RR_TIPO2 <> "G", RR_NUMID ,Nil), Nil, Nil, dDataGer, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, IIf( lTribIR, RR_TRIBIR, Nil ) ) )
				Else
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ A Quantidade Devera ser Sempre a Ultima 					 ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If !((SRR->RR_TIPO2 == "I" .And. SRR->RR_VALORI > 0 .And. SRR->RR_VALOR == 0) .Or. ; //Complementar da Complementar
					     (SRR->RR_TIPO2 == "G" .And. SRR->RR_TIPO1 == "H" .And. aPd[ nPosPd, 04] == SRR->RR_HORAS .And. SRR->RR_VALORI > 0 .And. SRR->RR_VALOR > 0 ))
						aPd[ nPosPd, 04 ] := Iif(SRR->RR_TIPO1 == "H", SRR->RR_HORAS + Iif(lRescDis .And. !lMesDem, aPd[ nPosPd, 04 ], 0), SRR->RR_HORAS)
					EndIf

					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Ja os Valores, quando o Mes/Ano da Data de Geracao for igual³
					³ao Mes/Ano da Data de Demissao considera sempre o ultimo  va³
					³lor, C/C o Valores deverao sem Somados pois referem-se a Com³
					³pelentar de Complementar									 ³
					³Obs.: Base IR 13o. sempre deve considerar o valor da ultima ³
					³rescisao porque ela sempre sera composta pelas anteriores.  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF lMesDem .Or. SRR->RR_PD == aCodFol[27,1]
						aPd[ nPosPd , 05 ] := SRR->RR_VALOR
					Else
						aPd[ nPosPd , 05 ] += SRR->RR_VALOR
					EndIf
				EndIf
			Else
				If (AnoMes(SRR->RR_DATA) == cPeriodo .And. SRR->RR_TIPO2 $ "I/E") .Or. ;
				   ( ;
				   		nPosPd := aScan( aPD , { |x|  x[1] == SRR->RR_PD .And. x[11] == SRR->RR_SEQ .And. AnoMes(x[18]) == AnoMes(dDataGer) .Or. ;
													( x[1] == SRR->RR_PD .And. x[11] == SRR->RR_SEQ .And. AnoMes(x[18]) <> AnoMes(dDataGer) .And. ;
														( ( SRR->RR_TIPO2 $ "I/E" .And. x[7] $ "I/E" ) .Or. ( SRR->RR_TIPO2 == "G" .And. x[7] == "G" .And. SRR->RR_TIPO1 == "H" .And. x[6] == "H"  ) ) ;
													) ;
												};
										 ;
										)  ) == 0.00
					For nCount := (Val(cSeq) + 1) to 9
						If aScan(aPd, {|X| x[1] == SRR->RR_PD .And. x[11] == cSeq  }) > 0
							cSeq := Soma1(cSeq)
						Else
							Exit
						EndIf
					Next nCount

					SRR->( fMatriz(RR_PD, RR_VALOR, SRR->RR_HORAS, RR_SEMANA, RR_CC, RR_TIPO1, RR_TIPO2, 0, "", dDataPag, Nil, cSeq, Nil, Nil, Nil, Iif(RR_TIPO2 <> "G",RR_NUMID,Nil), Nil, Nil, dDataGer, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, IIf( lTribIR, RR_TRIBIR, Nil ) ) )
				Else
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ A Quantidade Devera ser Sempre a Ultima 					 ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If !((SRR->RR_TIPO2 == "I" .And. SRR->RR_VALORI > 0 .And. SRR->RR_VALOR == 0) .Or. ; //Complementar da Complementar
					     (SRR->RR_TIPO2 == "G" .And. SRR->RR_TIPO1 == "H" .And. aPd[ nPosPd, 04] == SRR->RR_HORAS .And. SRR->RR_VALORI > 0 .And. SRR->RR_VALOR > 0 ))
						aPd[ nPosPd, 04 ] := Iif(SRR->RR_TIPO1 == "H",SRR->RR_HORAS + Iif(lRescDis .And. !lMesDem, aPd[ nPosPd, 04 ], 0), SRR->RR_HORAS)
					EndIf

					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Ja os Valores, quando o Mes/Ano da Data de Geracao for igual³
					³ao Mes/Ano da Data de Demissao considera sempre o ultimo  va³
					³lor, C/C o Valores deverao sem Somados pois referem-se a Com³
					³pelentar de Complementar									 ³
					³Obs.: Base IR 13o. sempre deve considerar o valor da ultima ³
					³rescisao porque ela sempre sera composta pelas anteriores.  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF lMesDem .Or. SRR->RR_PD == aCodFol[27,1]
						aPd[ nPosPd , 05 ] := SRR->RR_VALOR
					Else
						aPd[ nPosPd , 05 ] += SRR->RR_VALOR
					EndIf
				EndIf
			EndIf


			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Obtem os valores de INSS e IR de rescisoes complementares   ³
			³calculadas em meses diferentes da demissao para tratamento  ³
			³especifico quando houver diversas Rescisoes Complementares. ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If !lMesDem	.And. ( nPosPd := aScan( aPD , { |x| x[1] == SRR->RR_PD } ) ) > 0
				If ( aPd[nPosPd,1] $ aCodFol[64,1]+"*"+aCodFol[13,1]+"*"+aCodFol[14,1]+"*"+aCodFol[15,1]+"*"+aCodFol[66,1])
					aAdd( aPdResVals, aClone(aPd[nPosPd]) )
					nPosIns := Len( aPdResVals )
					aPdResVals[nPosIns][05] := SRR->RR_VALOR
					aPdResVals[nPosIns][10] := dDataPag
					aAdd( aPdResVals[nPosIns], SRR->RR_DATA )
				EndIf
			EndIf

			SRR->( dbSkip() )
		EndDo
	EndIf
Next nV

//Caso a verba do ID 0625 esteja cadastrada e não exista no calculo original
//refaz o calculo do 1/3 de ferias vencidas e 1/3 de ferias proporcionais
If !Empty(aCodFol[625,1]) .And. aScan( aPd, { |x| x[1] == aCodFol[625,1] } ) == 0 .And. aScan( aPd, { |x| x[1] == aCodFol[87,1] } ) > 0
	dDataPag := CtoD("")
	lZeraApd := .T.
	For nX := 1 to Len(aPd)
		If !Empty(dDataPag) .and. AnoMes(dDataPag) <> AnoMes(aPd[nX,18])
			aEval( aPd, { |x| If(x[1] == aCodFol[125,1] , x[9] := "D", Nil) } )
			lZeraApd := .F.
			nPerc := fDesc("SRV", aCodFol[125,1], "RV_PERC", Nil, SRA->RA_FILIAL)
			fGeraVerba(aCodfol[125,1], Round( nValTerV * If( nPerc == 0 .Or. nPerc == 100, 1/3, nPerc/100 ), 2 ), 0, Nil, Nil, "V", "R",,,,,,,,,,,,dDataPag)
			nPerc := fDesc("SRV", aCodFol[625,1], "RV_PERC", Nil, SRA->RA_FILIAL)
			fGeraVerba(aCodfol[625,1], Round( nValTerP * If( nPerc == 0 .Or. nPerc == 100, 1/3, nPerc/100 ), 2 ), 0, Nil, Nil, "V", "R",,,,,,,,,,,,dDataPag)
			nValTerV := 0
			nValTerP := 0
			dDataPag  := CtoD("")
		EndIf
		If aPd[nX, 1] $ aCodFol[86,1]+"/"+aCodFol[248,1]
			nValTerV += aPd[nX, 5]
			dDataPag := aPd[nX,18]
		ElseIf aPd[nX, 1] $ aCodFol[87,1]+"/"+aCodFol[249,1]
			nValTerP += aPd[nX, 5]
			dDataPag := aPd[nX,18]
		EndIf
	Next nX
	If lZeraApd
		aEval( aPd, { |x| If(x[1] == aCodFol[125,1] , x[9] := "D", Nil) } )
	EndIf
	nPerc := fDesc("SRV", aCodFol[125,1], "RV_PERC", Nil, SRA->RA_FILIAL)
	fGeraVerba(aCodfol[125,1], Round( nValTerV * If( nPerc == 0 .Or. nPerc == 100, 1/3, nPerc/100 ), 2 ), 0, Nil, Nil, "V", "R",,,,,,,,,,,,dDataPag)
	nPerc := fDesc("SRV", aCodFol[625,1], "RV_PERC", Nil, SRA->RA_FILIAL)
	fGeraVerba(aCodfol[625,1], Round( nValTerP * If( nPerc == 0 .Or. nPerc == 100, 1/3, nPerc/100 ), 2 ), 0, Nil, Nil, "V", "R",,,,,,,,,,,,dDataPag)
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega aPdResc com os Valores Correspondentes			 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nX := 1 to Len(aPd)
	aAdd(aPdResc, aPd[nX])
Next nX

aPd		:= {}

RestArea(aArea)

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fChkDtHom    ³ Autor ³ Luciana Silveira      ³ Data ³ 12/01/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Checar a Data de Homologacao do Funcionario 				     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso	     ³GPEM040													     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fChkDtHom( dDataDem , dDataHom  )
Local lRet		:= .T.

lChkDtHom := If( Type("P_CHKDTHOM")=="U",.T.,P_CHKDTHOM)

If lChkDtHom
	If dDataHom < dDataDem
		lRet := .F.
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0106), 1, 0 ) //"Data de Homologação não pode ser inferior a Demissão"
	EndIf
EndIf

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RrFuncInitºAutor  ³Silvia Taguti       º Data ³  07/19/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inicializador Padrao para o campo RR_CODFUNC                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RRFuncInit()

Return( SRA->RA_CODFUNC )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gpm040Fin ºAutor  ³Mauricio Takakura   º Data ³  28/03/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Aplicacao do Finiquitos para um calculo - Somente Mexico    º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Gpm040Fin( nTipo, cRoteir, cPer, cNPgto, cProc, aParam )	// 1-Aplicacao Rescisao; 2-Reversao Rescisao

Local aPerAtual	:= {}
Local aSRGHeader:= {}
Local aSRGCols	:= {}
Local aSRRHeader:= {}
Local aSRRCols	:= {}

Local bSet15	  := { || lRet := .T., oDlg:End() }
Local bSet24	  := { || lRet := .F., oDlg:End() }
Local bDialogInit := {}

Local cTitle
Local cTipoRot 	:= fGetTipoRot( cRoteir )
Local cRotDesc
Local cSvRoteir := cRoteir
Local cSvPer	:= cPer
Local cSvNPgto	:= cNPgto

Local cFil		:= ""
Local cMat		:= ""

Local lRet 		:= .t.

Local nNextRecno 	:= 0
Local nRecno 		:= 0
Local nOrder 		:= 0

Local oDlg

Local lGpm040ReApl
Local lGpm040AplRes
Local lRetGpm040Apl := .F.
Local oGetRef		:= Nil
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

Local aAdv1Size		:= {}
Local aInfo1AdvSize	:= {}
Local aObj1Size		:= {}
Local aObj1Coords 	:= {}

Local aAdv2Size		:= {}
Local aInfo2AdvSize	:= {}
Local aObj2Size		:= {}
Local aObj2Coords 	:= {}

DEFAULT nTipo 	  := 0
DEFAULT cProcesso := ""
DEFAULT cProc	  := ""
DEFAULT cRoteir	  := ""
DEFAULT cPer 	  := ""
DEFAULT cNPgto	  := ""

lGpm040ReApl := ExistBlock( "GPM040RA" )
lGpm040AplRes:= ExistBlock( "GPM040AR" )

If ( nTipo == 2 )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Ponto de Entrada para nao verificacao da Situacao da Folha   ³
	³ em caso de Reversao da Aplicacao de Rescisao				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If ( lGpm040ReApl )
		oGetRef := oGet
		lRetGpm040Apl := ExecBlock("GPM040RA")
		If !( ValType(lRetGpm040Apl) == "L" )
			lRetGpm040Apl := .F.
		EndIf
		oGet := oGetRef
	EndIf

EndIf

If ( MV_MODFOL == "2" )

	If (nTipo == 1 .and. cTipoRot <> "4") .Or. (nTipo == 2 .and. cTipoRot <> "A")
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0107),1,0 ) //"Tipo de Roteiro Diferente do Solicitado!"###"Atencao"
		Return( .F. )
	Else

		If nTipo == 1
			cRoteir := fGetCalcRot('A')	// Aplicacao de Finiquito
		ElseIf nTipo == 2
			If (AllTrim(SRA->RA_SITFOLH) == "D") .or. lRetGpm040Apl
				cRoteir := fGetCalcRot('4')	// Reversao de Aplicacao de Rescisao
			Else
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0108),1,0 ) //"A reversao só pode ser feita para funcionários demitidos"
				Return( .F. )
			EndIf
		EndIf

		lRet := fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, cRoteir ) // Busca o periodo aberto para trabalho
		If lRet
			cPer		:= aPerAtual[1,1]
			cNPgto 		:= aPerAtual[1,2]
		Else
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0082),1,0 ) //"Periodo nao cadastrado para o Roteiro selecionado!"###"Atencai"
			Return( lRet )
		EndIf
		If nTipo == 1 .and. cTipoRot == "4"
			cTitle := OemToAnsi(STR0110) // "Aplicacao de Rescisao"
		Else
			cTitle := OemToAnsi(STR0111) // "Reversao da Aplicacao de Rescisao"
		EndIf
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para a Inicializacao do Dialog            	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bDialogInit		:= { ||;
								CursorWait()													,;
								EnchoiceBar( oDlg , bSet15 , bSet24, NIL  )						,;
								CursorArrow()												 	 ;
					   }

	aAdvSize        := MsAdvSize( ,.T.,370)

	aInfoAdvSize    := { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 040 , 000 , .T. , .T. } )
	aAdd( aObjCoords , { 060 , 000 , .T. , .T. } )
	aObjSize    := MsObjSize( aInfoAdvSize , aObjCoords, .T., .T. )

	aAdv1Size    := aClone(aObjSize[1])

	aInfo1AdvSize    := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 5 , 5 }
	aAdd( aObj1Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj1Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
	aObj1Size := MsObjSize( aInfo1AdvSize , aObj1Coords )

	aAdv2Size    := aClone(aObjSize[2])

	aInfo2AdvSize    := { aAdv2Size[2] , aAdv2Size[1] , aAdv2Size[4] , aAdv2Size[3] , 5 , 5 }
	aAdd( aObj2Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj2Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
	aObj2Size := MsObjSize( aInfo2AdvSize , aObj2Coords )

	DEFINE MSDIALOG oDlg TITLE cTitle FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME PIXEL
		oDlg:lEscClose := .F. // Nao permite sair ao se pressionar a tecla ESC.

		If ExistCpo("SRY", cRoteir)
			cRotDesc := Posicione("SRY",1,xFilial("SRY")+cRoteir, "RY_DESC")
		EndIf


		@ aObj1Size[1,1]	, aObj1Size[1,2] 		SAY   OemToAnsi(STR0085) SIZE 033,007 OF oDlg PIXEL	//"Periodo: "
		@ aObj1Size[1,1]	, aObj1Size[1,2]+55 	MSGET cPer SIZE 040,007	OF oDlg PIXEL WHEN .F.

		@ aObj1Size[2,1]	, aObj1Size[2,2] 		SAY   OemToAnsi(STR0086) SIZE 038,007 OF oDlg PIXEL	//"Nro Pagto: "
		@ aObj1Size[2,1]	, aObj1Size[2,2]+55 	MSGET cNPgto SIZE 040,007	OF oDlg PIXEL WHEN .F.

		@ aObj1Size[3,1]	, aObj1Size[3,2] 		SAY OemToAnsi(STR0112) SIZE 033,007 OF oDlg PIXEL	//"Tipo Folha: "
		@ aObj2Size[3,1]	, aObj2Size[3,2] 		SAY OemToAnsi(STR0088) SIZE 033,007 OF oDlg PIXEL	//"Descricao: "
		@ aObj1Size[3,1]	, aObj1Size[3,2]+55 	MSGET cRoteir  SIZE 040,007	OF oDlg PIXEL WHEN .F. PICTURE PesqPict("SRY","RY_CALCULO")
		@ aObj2Size[3,1]	, aObj2Size[3,2]+55 	MSGET cRotDesc SIZE 110,007	OF oDlg PIXEL WHEN .F.

	ACTIVATE DIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED

	If !lRet
		cRoteir := cSvRoteir
		cPer 	:= cSvPer
		cNPgto 	:= cSvNPgto
	Else
		// Alterar o periodo do Calculo de Finiquitos para Aplicacao de Finiquitos
	    DbSelectArea( "SRC" )
	    nOrder := RetOrdem("SRC","RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA")
	    DbSetOrder( nOrder )
	    DbSeek(SRA->(RA_FILIAL+RA_MAT+RA_PROCES)+cSvRoteir+cSvPer+cSvNPgto, .F.)

		Begin Transaction
		    While SRC->( !Eof() ) .and. SRC->( RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA) == SRA->(RA_FILIAL+RA_MAT+RA_PROCES)+cSvRoteir+cSvPer+cSvNPgto

		   		/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Obtem o Proximo Registro                    				   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If !GetNextRecno( "SRC", @nNextRecno , @nRecno , nOrder )
					Exit
				EndIf

				RecLock( "SRC", .F.)
				SRC->RC_PERIODO := cPer
				SRC->RC_ROTEIR	:= cRoteir
				SRC->RC_SEMANA 	:= cNPgto
				MsUnlock()

				If !GotoNextRecno( "SRC" , nNextRecno , nOrder )
					Exit
				EndIf

		    EndDo
		End Transaction

		If lRet
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0089),1,0 ) //"Processo Concluido com Sucesso!"###"Atencao"
			oGet:Refresh()

			If ( lGpm040AplRes )
				oGetRef := oGet
				ExecBlock( "GPM040AR",.F.,.F.,{cRoteir, cPer, cNPgto, cProcesso, SRA->RA_MAT})
				oGet := oGetRef
			EndIf

		EndIf
	EndIf

ElseIf ( MV_MODFOL == "1" )

	cFil		:= aParam[01]
	cMat		:= aParam[02]
	aSRGHeader	:= aParam[03]
	aSRGCols	:= aParam[04]
	aSRRHeader	:= aParam[05]
	aSRRCols	:= aParam[06]

	bSet15		:= { || lRet := .T.,;
					aParam := { cProc, cPer, cRoteir, cNPgto },;
					If ( lRet := fPerClose( cProc, cPer, cNPgto, cRoteir, 2 ),;
					fRecAplFin( cFilial, cMat, SRG->RG_DTGERAR, {}, aParam, aSRGHeader, aSRGCols, aSRRHeader, aSRRCols, .T. ),;
					.F. ) ,;
					If ( lRet, oDlg:End(), Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0109),,1,0 ) ); //"Periodo nao Cadastrado!" - "Atenção"
				}
	bSet24		:= { || lRet := .F., oDlg:End() }
	bDialogInit := {}

	lRet 		:= .T.

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para a Inicializacao do Dialog            	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bDialogInit		:= { ||;
								CursorWait()													,;
								EnchoiceBar( oDlg , bSet15 , bSet24, NIL  )						,;
								CursorArrow()												 	 ;
					   }

	aAdvSize        := MsAdvSize( ,.T.,370)

	aInfoAdvSize    := { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 040 , 000 , .T. , .T. } )
	aAdd( aObjCoords , { 060 , 000 , .T. , .T. } )
	aObjSize    := MsObjSize( aInfoAdvSize , aObjCoords, .T., .T. )

	aAdv1Size    := aClone(aObjSize[1])

	aInfo1AdvSize    := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 5 , 5 }
	aAdd( aObj1Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj1Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
	aObj1Size := MsObjSize( aInfo1AdvSize , aObj1Coords )

	aAdv2Size    := aClone(aObjSize[2])

	aInfo2AdvSize    := { aAdv2Size[2] , aAdv2Size[1] , aAdv2Size[4] , aAdv2Size[3] , 5 , 5 }
	aAdd( aObj2Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj2Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
	aObj2Size := MsObjSize( aInfo2AdvSize , aObj2Coords )

	DEFINE MSDIALOG oDlg TITLE cTitle FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME PIXEL
		oDlg:lEscClose := .F. // Nao permite sair ao se pressionar a tecla ESC.

		If ExistCpo("SRY", cRoteir)
			cRotDesc := Posicione("SRY",1,xFilial("SRY")+cRot, "RY_DESC")
		EndIf

		@ aObj1Size[1,1]	,aObj1Size[1,2] SAY OemToAnsi(STR0087) SIZE 033,007 OF oDlg PIXEL	//"Roteiro: "
		@ aObj2Size[1,1]	,aObj2Size[1,2] SAY OemToAnsi(STR0088) SIZE 033,007 OF oDlg PIXEL	//"Descricao: "

		@ aObj1Size[1,1]	,aObj1Size[1,2]+55 MSGET oRoteiro VAR cRoteir  SIZE 040,007	OF oDlg PIXEL PICTURE "@!" F3 'SRYRES' VALID NaoVazio() .And. ExistCpo("SRY")
		oRoteiro:bValid		:= { || cRot := cRoteir,;
									cRotDesc := Posicione("SRY",1,xFilial("SRY")+cRoteir, "RY_DESC") }
		@ aObj2Size[1,1]	, aObj2Size[1,2]+55 MSGET oRotDescr VAR cRotDesc SIZE 110,007	OF oDlg PIXEL WHEN .F.

		@ aObj1Size[2,1]	, aObj1Size[2,2] SAY   OemToAnsi(STR0085) SIZE 033,007 OF oDlg PIXEL	//"Periodo: "
		@ aObj1Size[2,1]	, aObj1Size[2,2]+55 MSGET oPeriodo VAR cPer SIZE 040,007	OF oDlg PIXEL F3 'RCH' VALID NaoVazio()
		oPeriodo:bValid		:= { || cPeriodo := cPer }

		@ aObj1Size[3,1]	, aObj1Size[3,2] SAY   OemToAnsi(STR0086) SIZE 038,007 OF oDlg PIXEL	//"Nro Pagto: "
		@ aObj1Size[3,1]	, aObj1Size[3,2]+55 MSGET oNumPag VAR cNPgto SIZE 040,007	OF oDlg PIXEL WHEN ( .F. ) F3 'RCH01'
		oNumPag:bValid := { || cNumPag := cNPgto }

		@ aObj2Size[3,1]    , aObj2Size[3,2] SAY   OemToAnsi(STR0090) SIZE 033,007 OF oDlg PIXEL	//"Processo: "
		@ aObj2Size[3,1]    , aObj2Size[3,2]+55 MSGET oProcesso VAR cProc SIZE 040,007	OF oDlg PIXEL WHEN .F.
		oProcesso:bValid := { || cProcesso := cProc }

	ACTIVATE DIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED

EndIf

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fPerClose ºAutor  ³Igor Franzoi        º Data ³  01/12/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se o periodo esta fechado						  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fPerClose( cProcesso, cPeriodo, cNumPag, cRoteiro, nOption )

Local aArea		:= GetArea()

Local cFilRCH	:= ""

Local lRet 		:= .F.

Local bCondRCH	:= {}
DEFAULT nOption := 1
If ( Type("cProcesso") == "U" .or. Empty(cProcesso) )
	cProcesso := Space( GetSx3Cache("RCH_PROCES", "X3_TAMANHO") )
EndIf
If ( Type("cPeriodo") == "U" .or. Empty(cPeriodo) )
	cPeriodo := Space( GetSx3Cache("RCH_PER", "X3_TAMANHO") )
EndIf
If ( Type("cNumPag") == "U" .or. Empty(cNumPag) )
	cNumPag := Space( GetSx3Cache("RCH_PER", "X3_TAMANHO") )
EndIf
If ( Type("cRoteiro") == "U" .or. Empty(cRoteiro) )
	cRoteiro := Space( GetSx3Cache("RCH_ROTEIR", "X3_TAMANHO") )
EndIf

Begin Sequence

 	If Empty( cProcesso )
 		lRet := .F.
		Break
	EndIf

	cFilRCH	:= xFilial("RCH",SRA->RA_FILIAL)
	DbSelectArea("RCH")
	If ( nOption == 1 .or. nOption == 2 )
		RCH->( dbsetOrder( Retorder( "RCH" , "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR" ) ) )
		RCH->( dbSeek( cFilRCH + cProcesso + cPeriodo + cNumPag + cRoteiro, .F. ) )
		bCondRCH := { || (RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR) == (cFilRCH + cProcesso + cPeriodo + cNumPag + cRoteiro ) }
	ElseIf ( nOption == 3 )
		RCH->( dbsetOrder( Retorder( "RCH" , "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG" ) ) )
		RCH->( dbSeek( cFilRCH + cProcesso + cRoteiro, .F. ) )
		bCondRCH := { || (RCH_FILIAL+RCH_PROCES+RCH_ROTEIR) == (cFilRCH + cProcesso + cRoteiro ) }
	Else
		RCH->( dbsetOrder( Retorder( "RCH" , "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR" ) ) )
		RCH->( dbSeek( cFilRCH + cProcesso + cPeriodo + cNumPag + cRoteiro, .F. ) )
		bCondRCH := { || (RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR) == (cFilRCH + cProcesso + cPeriodo + cNumPag + cRoteiro ) }
	EndIf
	While RCH->( !Eof() .and. Eval(bCondRCH) )
		//Verifica se o período esta fechado - Padrao
		If ( nOption == 1 )
			If !Empty( RCH_DTFECH )
				lRet := .T.
				Exit
			EndIf
		//Localiza o período, se não existe retorna .F.
		ElseIf ( nOption == 2 )
			lRet := .T.
		//Retorna no conteúdo das variaveis, o último período de rescisão em aberto
		ElseIf ( nOption == 3 )

			//Se o roteiro for igual ao de rescisao e periodo aberto
			If ( fGetTipoRot( RCH->RCH_ROTEIR ) == '4' .and. Empty(RCH->RCH_DTFECH) )

				cNumPag		:= RCH->RCH_NUMPAG
				cRoteiro	:= RCH->RCH_ROTEIR
				cPeriodo	:= RCH->RCH_PER
				cProcesso	:= RCH->RCH_PROCES

				lRet := .T.

			EndIf

		EndIf
		RCH->( dbSkip() )
	EndDo

End Sequence

RestArea( aArea )

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fRecAplFinºAutor  ³Igor Franzoi        º Data ³  02/12/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Grava a aplicação na tabela SRC     						  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fRecAplFin( cFil, cMat, dDataGer, aDataFrom, aDataTo, aHeaderSRG, aColsSRG, aHeaderSRR, aColsSRR, lWindow, lMsg )

Local lRet		:= .F.
Local lDupl		:= .F.

Local cAliasSRC	:= "SRC"

//Periodo PARA
Local cRot		:= Space( GetSx3Cache("RCH_ROTEIR", "X3_TAMANHO") )
Local cNumPag	:= Space( GetSx3Cache("RCH_NUMPAG", "X3_TAMANHO") )
Local cPeriodo	:= Space( GetSx3Cache("RCH_PER"	  , "X3_TAMANHO") )
Local cProcesso	:= Space( GetSx3Cache("RCH_PROCES", "X3_TAMANHO") )

//Periodo DE
Local cRotFrom	  := Space( GetSx3Cache("RCH_ROTEIR", "X3_TAMANHO") )
Local cNumPagFrom := Space( GetSx3Cache("RCH_NUMPAG", "X3_TAMANHO") )
Local cPeriodFrom := Space( GetSx3Cache("RCH_PER"	  , "X3_TAMANHO") )
Local cProcesFrom := Space( GetSx3Cache("RCH_PROCES", "X3_TAMANHO") )

Local cJoin		:= ""
Local cWhere	:= ""
Local cQuery	:= ""
Local cKeySRC	:= ""
Local cMsgAlert := ""

Local nRecnoSRG := ""
Local nOrderSRC := RetOrdem("SRC","RC_FILIAL+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+Dtos(RC_DTREF)")

Local nPosPD	:= ""
Local nPosTipo1	:= ""
Local nPosHorInf:= ""
Local nPosHoras	:= ""
Local nPosValInf:= ""
Local nPosValor	:= ""
Local nPosTipo2	:= ""
Local nPosData	:= ""
Local nPosDataPg:= ""
Local nPosSeq	:= ""
Local nPosCC	:= ""
Local nPosNumID	:= ""

Local nContCols	  := 0

DEFAULT lMsg	:= .T.
DEFAULT lWindow := .F.

cRot		:= aDataTo[03]
cNumPag		:= aDataTo[04]
cPeriodo	:= aDataTo[02]
cProcesso	:= aDataTo[01]

dbSelectArea("SRG")
dbSetOrder(RetOrder("SRG","RG_FILIAL+RG_MAT+DTOS(RG_DTGERAR)"))
SRG->(dbSeek(cFil+cMat+Dtos(dDataGer)))
nRecnoSRG := SRG->(Recno())

//Efetua gravação conforme os parametros utilizados na aplicação através da tela
If lWindow

	nPosPD		:= GdFieldPos( "RR_PD", aHeaderSRR )
	nPosTipo1	:= GdFieldPos( "RR_TIPO1", aHeaderSRR )
	nPosHorInf	:= GdFieldPos( "RR_HORINFO", aHeaderSRR )
	nPosHoras	:= GdFieldPos( "RR_HORAS", aHeaderSRR )
	nPosValInf	:= GdFieldPos( "RR_VALINFO", aHeaderSRR )
	nPosValor	:= GdFieldPos( "RR_VALOR", aHeaderSRR )
	nPosTipo2	:= GdFieldPos( "RR_TIPO2", aHeaderSRR )
	nPosData	:= GdFieldPos( "RR_DATA", aHeaderSRR )
	nPosDataPg	:= GdFieldPos( "RR_DATAPAG", aHeaderSRR )
	nPosSeq		:= GdFieldPos( "RR_SEQ", aHeaderSRR )
	nPosCC		:= GdFieldPos( "RR_CC", aHeaderSRR )
	nPosNumID	:= GdFieldPos( "RR_NUMID", aHeaderSRR )

    Begin Transaction

	    DbSelectArea( cAliasSRC )
	    (cAliasSRC)->(DbSetOrder( nOrderSRC ))

		For nContCols := 1	To Len(aColsSRR)

			cKeySRC := cFil+cMat+cPeriodo+cNumPag+cRot+aColsSRR[ nContCols, nPosPD ]+aColsSRR[ nContCols, nPosCC ]+aColsSRR[ nContCols, nPosSeq ]+Dtos(aColsSRR[ nContCols, nPosData ])

			If !(cAliasSRC)->(DbSeek(cKeySRC))
				RecLock(cAliasSRC,.T.)

					(cAliasSRC)->RC_FILIAL	:= cFil
					(cAliasSRC)->RC_MAT		:= cMat
					(cAliasSRC)->RC_PD		:= aColsSRR[ nContCols, nPosPD ]
					(cAliasSRC)->RC_TIPO1	:= aColsSRR[ nContCols, nPosTipo1 ]
					(cAliasSRC)->RC_HORINFO	:= aColsSRR[ nContCols, nPosHorInf ]
					(cAliasSRC)->RC_HORAS	:= aColsSRR[ nContCols, nPosHoras ]
					(cAliasSRC)->RC_VALINFO	:= aColsSRR[ nContCols, nPosValInf ]
					(cAliasSRC)->RC_VALOR	:= aColsSRR[ nContCols, nPosValor ]
					(cAliasSRC)->RC_DATA	:= aColsSRR[ nContCols, nPosDataPg ]
					(cAliasSRC)->RC_DTREF	:= aColsSRR[ nContCols, nPosData ]
					(cAliasSRC)->RC_SEMANA	:= cNumPag
					(cAliasSRC)->RC_CC		:= aColsSRR[ nContCols, nPosCC ]
					(cAliasSRC)->RC_TIPO2	:= aColsSRR[ nContCols, nPosTipo2 ]
					(cAliasSRC)->RC_SEQ		:= aColsSRR[ nContCols, nPosSeq ]
					(cAliasSRC)->RC_PROCES	:= cProcesso
					(cAliasSRC)->RC_PERIODO	:= cPeriodo
					(cAliasSRC)->RC_POSTO	:= SRA->RA_POSTO
					(cAliasSRC)->RC_NUMID	:= aColsSRR[ nContCols, nPosNumID ]
					(cAliasSRC)->RC_ROTEIR	:= cRot
					(cAliasSRC)->RC_CODFUNC	:= SRA->RA_CODFUNC

				(cAliasSRC)->(MsUnlock())
				lRet := .T.
			Else
				lDupl := .T.
			EndIf
		Next

	End Transaction

Else

	cRotFrom	:= aDataFrom[03]
	cNumPagFrom	:= aDataFrom[04]
	cPeriodFrom := aDataFrom[02]
	cProcesFrom := aDataFrom[01]

	#IFDEF TOP

		cJoin := "%"
		cJoin += " SRR.RR_FILIAL  = SRG.RG_FILIAL  AND "
		cJoin += " SRR.RR_MAT 	  = SRG.RG_MAT 	   AND "
		cJoin += " SRR.RR_PROCES  = SRG.RG_PROCES  AND "
		cJoin += " SRR.RR_PERIODO = SRG.RG_PERIODO AND "
		cJoin += " SRR.RR_SEMANA  = SRG.RG_SEMANA  AND "
		cJoin += " SRR.RR_ROTEIR = SRG.RG_ROTEIR	   "
		cJoin += "%"

		cWhere := "%"
		cWhere += " SRG.RG_FILIAL 	= '" + cFil + "' AND "
		cWhere += " SRG.RG_MAT 		= '" + cMat + "' AND "
		cWhere += " SRG.RG_PROCES 	= '" + cProcesFrom + "' AND "
		cWhere += " SRG.RG_PERIODO 	= '" + cPeriodFrom + "' AND "
		cWhere += " SRG.RG_SEMANA 	= '" + cNumPagFrom + "' AND "
		cWhere += " SRG.RG_ROTEIR 	= '" + cRotFrom	+ "' "
		cWhere += "%"

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Seleciona os dados na tabela SRR - aDataFrom				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cQuery := GetNextAlias()
		BeginSql alias cQuery
			column RR_DATA AS Date, RR_DATAPAG AS Date
			SELECT
				SRR.RR_PD, SRR.RR_TIPO1, SRR.RR_HORINFO, SRR.RR_HORAS, SRR.RR_VALINFO, SRR.RR_VALOR,
				SRR.RR_TIPO2, SRR.RR_DATA, SRR.RR_DATAPAG, SRR.RR_SEQ, SRR.RR_CC, SRR.RR_NUMID
			FROM 		%table:SRG% SRG
			INNER JOIN  %table:SRR% SRR
			ON 			%exp:cJoin%
			WHERE
						%exp:cWhere% AND
						SRG.%NotDel% AND
						SRR.%NotDel%
		EndSql

	    DbSelectArea( cAliasSRC )
	    (cAliasSRC)->(DbSetOrder( nOrderSRC ))

		While (cQuery)->( !Eof() )

			cKeySRC := cFil+cMat+cPeriodo+cNumPag+cRot+(cQuery)->RR_PD+(cQuery)->RR_CC+(cQuery)->RR_SEQ+Dtos((cQuery)->RR_DATA)

			If !(cAliasSRC)->(DbSeek(cKeySRC))
				RecLock(cAliasSRC,.T.)

					(cAliasSRC)->RC_FILIAL	:= cFil
					(cAliasSRC)->RC_MAT		:= cMat
					(cAliasSRC)->RC_PD		:= (cQuery)->RR_PD
					(cAliasSRC)->RC_TIPO1	:= (cQuery)->RR_TIPO1
					(cAliasSRC)->RC_HORINFO	:= (cQuery)->RR_HORINFO
					(cAliasSRC)->RC_HORAS	:= (cQuery)->RR_HORAS
					(cAliasSRC)->RC_VALINFO	:= (cQuery)->RR_VALINFO
					(cAliasSRC)->RC_VALOR	:= (cQuery)->RR_VALOR
					(cAliasSRC)->RC_DATA	:= (cQuery)->RR_DATAPAG
					(cAliasSRC)->RC_DTREF	:= (cQuery)->RR_DATA
					(cAliasSRC)->RC_SEMANA	:= cNumPag
					(cAliasSRC)->RC_CC		:= (cQuery)->RR_CC
					(cAliasSRC)->RC_TIPO2	:= (cQuery)->RR_TIPO2
					(cAliasSRC)->RC_SEQ		:= (cQuery)->RR_SEQ
					(cAliasSRC)->RC_PROCES	:= cProcesso
					(cAliasSRC)->RC_PERIODO	:= cPeriodo
					(cAliasSRC)->RC_POSTO	:= SRA->RA_POSTO
					(cAliasSRC)->RC_NUMID	:= (cQuery)->RR_NUMID
					(cAliasSRC)->RC_ROTEIR	:= cRot
					(cAliasSRC)->RC_CODFUNC	:= SRA->RA_CODFUNC

				(cAliasSRC)->(MsUnlock())
				lRet := .T.
			Else
				lDupl := .T.
			EndIf

			(cQuery)->(dbSkip())

		EndDo

	#Else

		cJoin	:= ""
		cWhere	:= ""
		dbSelectArea("SRR")
		dbSetOrder(RetOrder("SRR","RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR+RR_SEMANA+RR_PD+RR_CC+RR_SEQ+Dtos(RR_DATA)"))

	    DbSelectArea( cAliasSRC )
	    (cAliasSRC)->(DbSetOrder( nOrderSRC ))

		While( !Eof() .and. RR_FILIAL + RR_MAT + RR_PERIODO == cFil + cMat + cPeriodFrom + cRotFrom + cNumPagFrom .and. SRG->RG_DTGERAR == RR_DATA )

			cKeySRC := cFil+cMat+cPeriodo+cNumPag+cRot+RR_PD+RR_CC+RR_SEQ+Dtos(RR_DATA)

			If !(cAliasSRC)->(DbSeek(cKeySRC))
				RecLock(cAliasSRC,.T.)

					(cAliasSRC)->RC_FILIAL	:= cFil
					(cAliasSRC)->RC_MAT		:= cMat
					(cAliasSRC)->RC_PD		:= (cQuery)->RR_PD
					(cAliasSRC)->RC_TIPO1	:= (cQuery)->RR_TIPO1
					(cAliasSRC)->RC_HORINFO	:= (cQuery)->RR_HORINFO
					(cAliasSRC)->RC_HORAS	:= (cQuery)->RR_HORAS
					(cAliasSRC)->RC_VALINFO	:= (cQuery)->RR_VALINFO
					(cAliasSRC)->RC_VALOR	:= (cQuery)->RR_VALOR
					(cAliasSRC)->RC_DATA	:= (cQuery)->RR_DATAPAG
					(cAliasSRC)->RC_DTREF	:= (cQuery)->RR_DATA
					(cAliasSRC)->RC_SEMANA	:= cNumPag
					(cAliasSRC)->RC_CC		:= (cQuery)->RR_CC
					(cAliasSRC)->RC_TIPO2	:= (cQuery)->RR_TIPO2
					(cAliasSRC)->RC_SEQ		:= (cQuery)->RR_SEQ
					(cAliasSRC)->RC_PROCES	:= cProcesso
					(cAliasSRC)->RC_PERIODO	:= cPeriodo
					(cAliasSRC)->RC_POSTO	:= SRA->RA_POSTO
					(cAliasSRC)->RC_NUMID	:= (cQuery)->RR_NUMID
					(cAliasSRC)->RC_ROTEIR	:= cRot
					(cAliasSRC)->RC_CODFUNC	:= SRA->RA_CODFUNC

				(cAliasSRC)->(MsUnlock())
				lRet := .T.
			Else
				lDupl := .T.
			EndIf

			SRR->(dbSkip())

		EndDo

	#EndIf

EndIf

If lDupl
	If lMsg
		cMsgAlert := OemToAnsi(STR0098) + CRLF			//"Registros duplicado!"
		cMsgAlert += OemToAnsi(STR0099) + "SRC" + CRLF  //"Tabela: "
		Help( ,, OemToAnsi(STR0020),, cMsgAlert,,1,0 ) //"Atenção"
EndIf
EndIf

//Grava flag de Aplicação de rescisão
If lRet
	If(cPaisLoc == 'MEX')
		dbSelectArea("SRG")
		SRG->(dbGoTo(nRecnoSRG))
		If ( SRG->RG_STSAPL != "1" )
			RecLock("SRG",.F.)
				SRG->RG_STSAPL := "1"
			SRG->(MsUnlock())
		EndIf
	EndIf
EndIf

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RRProces  ºAutor  ³Igor Franzoi        º Data ³  03/12/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inicializador padrao do campo processo					  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RRProces()

Local cProc	:= Space( GetSx3Cache("RCH_PROCES", "X3_TAMANHO") )

If ( ValType("cProcesso") != "U" )
	cProc := cProcesso
Else
	cProc := SRA->RA_PROCES
EndIf

Return (cProc)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fImpPonto  ºAutor  ³RH                  º Data ³  02/07/07     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Importa resultado do Ponto Eletronico para a rescisao(utili-  º±±
±±º          ³ zado para importacao de resultados do periodo de apontamento  º±±
±±º          ³ do mes da rescisao, em rescisao calculada para o mes seguinte º±±
±±º          ³ ao mes em aberto na folha).                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ dDataDe    = Data inicial do periodo p/ importar os resultadosº±±
±±º          ³ dDataAte   = Data final do periodo p/ importar os resultados  º±±
±±º          ³ nSubsLct   = Opcao para lctos. ja existentes na rescisao      º±±
±±º          ³ lIsGPEM040 = .T.-Calculo GPEM040; .F.-Calculo GPEM630         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fImpPonto( dDataDe, dDataAte, nSubsLct, lIsGPEM040, aLogFile, lIsGPEM630 )

Local aDetSPB 			:= {}
Local aDetSPBAux		:= {}
Local aCabSPB			:= {}
Local aCabSPBAux		:= {}
Local aSpbRecnos		:= {}
Local aSpbRecAux		:= {}
Local aPerAtual			:= {}
Local aNotFields		:= {"PB_FILIAL", "PB_MAT"}
Local aRetSRV
Local aSvKeys			:= GetKeys()
Local cFil				:= SRA->RA_FILIAL
Local cMat				:= SRA->RA_MAT
Local cKey				:= ( ( cFil + cMat ) )
Local cPonMes			:= GetPonMes()
Local cProcFol			:= 	""
Local cRotFol			:=	""
Local cPerFol			:=	""
Local cNPagFol			:= 	""
Local cRotAux 			:= fGetCalcRot('1')
Local bKey 				:= { || SPB->(PB_FILIAL + PB_MAT) }
Local bSkip				:= { || (SPB->PB_DATA > dDataAte .Or. SPB->PB_DATA < dDataDe) }
Local bSkip1			:= { || .T. }
Local lComisPuro		:= .F.
Local nPosPBPd			:= 0
Local nPosPBVlr			:= 0
Local nPosPBHrs 		:= 0
Local nPosPBTp1			:= 0
Local nPosPBTp2			:= 0
Local nPosPBSem			:= 0
Local nPosPBDtPg		:= 0
Local nPosPBCc			:= 0
Local nPosPBDel			:= 0
Local nPosPBAWT			:= 0
Local nPosPBRWT			:= 0
Local nPosPBRot			:= 0
Local nx				:= 0
Local ny				:= 0
Local nPos				:= 0.00
Local nOpcA 			:= 0.00
Local oFont
Local oRadio
Local oGroup
Local dPerIni			:= CtoD("")
Local dPerFim			:= CtoD("")
Local dPonMes			:= CtoD( Substr(cPonMes, 7, 2) + "/" + Substr(cPonMes, 5, 2) + "/" + Substr(cPonMes, 1, 4) )
Local lItemClVl   		:= SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "1*3"
Local lContinua			:= .T.
Local lInclui 			:= .T.
Local aAdvSize			:= {}
Local aInfoAdvSize		:= {}
Local aObjCoords   		:= {}
Local aObjSize			:= {}
Local dBkpAvis 			:= CtoD("")

DEFAULT	aLogFile		:= {}
DEFAULT nSubsLct		:= 2 //Opcao para lancamentos ja existentes: 1-Substitui;2-Despreza;3-Soma
DEFAULT dDataDe			:= CtoD("") //Data inicial do periodo para importacao do Ponto
DEFAULT dDataAte		:= CtoD("") //Data final do periodo para importacao do Ponto
DEFAULT lIsGPEM040		:= .T. //Calculo de rescisao via GPEM040
DEFAULT lIsGPEM630		:= .F. //Rescisão coletiva

If cPaisLoc == "BRA"
	dBkpAvis 	:= dDataAvis
EndIf

aAdvSize		:= MsAdvSize()
aAdvSize[5]		:=	500 //horizontal
aAdvSize[3]		:=	252 // LARGURA
aAdvSize[4]		:=	87  // ALTURA
aAdvSize[6]		:=  200 //Vertical
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 2 , 2 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize			:= MsObjSize( aInfoAdvSize , aObjCoords )

If lIsGPEM040
	If Empty(dPonMes)
		MsgAlert(STR0064)   //Parametro MV_PONMES deve estar preenchido para que a importação seja executada
		Return NIl
	EndIf

	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg1 FROM  aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi( STR0065 ) OF oMainWnd PIXEL //Integração de dados do Ponto Eletronico

		@ aObjSize[1][1]-30,aObjSize[1][2]	GROUP oGroup TO aObjSize[1][3]-10,aObjSize[1][4] LABEL OemToAnsi(STR0066) OF oDlg1 PIXEL	//"Informações para busca dos resultados:"
		oGroup:oFont:=oFont

		@ aObjSize[1][1]-10,aObjSize[1][2]+10 SAY OemToAnsi(STR0067) SIZE 146,10 OF oDlg1 PIXEL FONT oFont //"Data inicial:"
		@ aObjSize[1][1]-10,aObjSize[1][2]+50 MSGET odDataDe VAR dDataDe 	  				    	SIZE 050,10 OF oDlg1 PIXEL PICTURE "@D"
		@ aObjSize[1][1]-10,aObjSize[1][2]+140 SAY OemToAnsi(STR0068)			 					SIZE 146,10 OF oDlg1 PIXEL FONT oFont //"Data final:"
		@ aObjSize[1][1]-10,aObjSize[1][2]+180 MSGET odDataAte VAR dDataAte		   		   		SIZE 050,10 OF oDlg1 PIXEL PICTURE "@D"

		@ aObjSize[1][1]+10,aObjSize[1][2]+10 SAY OemToAnsi(STR0069)								SIZE 146,15 OF oDlg1 PIXEL FONT oFont //"Lançamentos ja existentes:"
		@ aObjSize[1][1]+10,aObjSize[1][2]+100 RADIO oRadio VAR nSubsLct ITEMS	OemToAnsi(STR0070)	,;			//"Substituir"
													OemToAnsi(STR0071)	,;			//"Desprezar"
													OemToAnsi(STR0072)	 ;			//"Somar"
					SIZE 050,010 OF oDlg1 PIXEL

		lContinua := PerAponta( @dPerIni , @dPerFim , dPonMes , NIL , cFil )

		DEFINE SBUTTON oSButton1 FROM 80, 80 TYPE 01 OF oDlg1 ENABLE ACTION { || If( !lContinua .Or. Empty( dDataDe ) .Or. Empty( dDataAte ) .Or. ( dDataAte < dDataDe ),;
		 				MsgAlert(STR0073,"") , If( MsgYesNo( OemToAnsi( STR0074 ) , OemToAnsi( STR0075 ) ), ( nOpcA := 1 , oDlg1:End() ),))}

		DEFINE SBUTTON oSButton2 FROM 80, 120 TYPE 02 OF oDlg1 ENABLE ACTION {|| nOpcA := 2,oDlg1:End() }

	ACTIVATE MSDIALOG oDlg1 CENTERED
	RestKeys( aSvKeys , .T. )
EndIf

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³Identifica comissionista puro			 ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lComisPuro :=  ( cPaisLoc == "BRA" )  .and.  (SRA->RA_CATFUNC == "C" ) .and.  Empty(SRA->RA_SALARIO )

If ( nOpcA == 1 ) .Or. ( !lIsGPEM040 ) //Calculo de Rescisao

	//Utiliza o processo da rescisão
	cProcFol 	:= cProcesso
	cRotFOL		:= cRot
	cPerFOL		:= cPeriodo
	cNPagFOL	:= cSemana

	If Empty(cPerFol)

		fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetRotOrdinar() ) // Busca o periodo aberto da folha

		If !Empty(aPerAtual)
			cProcFOL	:= 	aPerAtual[1,8]
			cRotFOL		:=	aPerAtual[1,3]
			cPerFOL		:=	aPerAtual[1,1]
			cNPagFOL	:= 	aPerAtual[1,2]
		Else
			If lIsGPEM040
				MsgAlert(STR0076)   //"Não existe periodo da folha ativo."
			Else
				SRA->(;
							aAdd( aLogFile ,	STR0077 + 		RA_NOME 	+  " "	+;		//"Funcionario: "
												STR0078 + 		RA_FILIAL 	+ "   " +	;	//"Filial: "
												STR0079 + 		RA_MAT 		+ ".  "	+	;	//"Matricula: "
												STR0076;									//"Nao existe período da folha ativo."
								);
						 )
			EndIf
			Return(Nil)
		EndIf
	EndIf

	aDetSPBAux		:= GdMontaCols(@aCabSPBAux,,,,"SPB",aNotFields,@aSpbRecAux,"SRG",cKey,bKey,bSkip) //aDetSPBAux contem lctos. do SPB, filtrando apenas a filial+matricula dentro do periodo selecionado
	aDetSPB			:= GdMontaCols(@aCabSPB,,,,"SPB",aNotFields,@aSpbRecnos,"SRG",cKey,bKey,bSkip1) //criacao de aDetSPB vazio com mesma estrutura de aDetSPBAux
	nPosPBPd		:= GdFieldPos("PB_PD",aCabSPBAux)
	nPosPBVlr		:= GdFieldPos("PB_VALOR",aCabSPBAux)
	nPosPBHrs	 	:= GdFieldPos("PB_HORAS",aCabSPBAux)
	nPosPBTp1		:= GdFieldPos("PB_TIPO1",aCabSPBAux)
	nPosPBTp2		:= GdFieldPos("PB_TIPO2",aCabSPBAux)
	nPosPBSem		:= GdFieldPos("PB_SEMANA",aCabSPBAux)
	nPosPBDtPg		:= GdFieldPos("PB_DATA",aCabSPBAux)
	nPosPBCc		:= GdFieldPos("PB_CC",aCabSPBAux)
	nPosPBDel		:= GdFieldPos("GDDELETED",aCabSPBAux)
	nPosPBAWT		:= GdFieldPos("PB_ALI_WT",aCabSPBAux)
	nPosPBRWT		:= GdFieldPos("PB_REC_WT",aCabSPBAux)
	nPosPBRot		:= GdFieldPos("PB_ROTEIR",aCabSPBAux)

	If ( Len( aSpbRecAux ) > 0.00 )
		For ny := 1 to Len(aDetSPBAux) //For para alimentar aDetSPB com os totais de aDetSPBAux


			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³*** Tratamento para comissionista puro (BRA)							³
			³    Converte a verba de hora extra para verba de hora extra s/comissoes³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If lComisPuro
				aRetSRV:= PosSrv(aDetSPBAux[ ny, nPosPBPd ],cFil,{"RV_CODCORR","RV_HE"})
				//-- Se a verba for de hora extra
				If aRetSRV[2] == "S"
					//-- Substitui o codigo da verba pelo correspondente
					If !Empty(aRetSRV[1])
						aDetSPBAux[ ny, nPosPBPd ]:= aRetSRV[1]
					EndIf
				EndIf
			EndIf

			If ( aScan(aDetSPB,{ |x| ( x[nPosPBPd] + x[nPosPBCc] + x[nPosPBSem] == aDetSPBAux[ny,nPosPBPd] + aDetSPBAux[ny,nPosPBCc] + aDetSPBAux[ny,nPosPBSem] ) } )  == 0)
				nPos := Len(aDetSPB)

				If( !Empty( aDetSPB[nPos,nPosPBPd] ), aAdd( aDetSPB , Array( Len(aDetSPB[1]) ) ), )

				nPos							:= Len(aDetSPB)
				aDetSPB[nPos,nPosPBPd]			:= aDetSPBAux[ny,nPosPBPd]
				aDetSPB[nPos,nPosPBVlr]			:= aDetSPBAux[ny,nPosPBVlr]
				aDetSPB[nPos,nPosPBHrs]			:= aDetSPBAux[ny,nPosPBHrs]
				aDetSPB[nPos,nPosPBTp1]			:= aDetSPBAux[ny,nPosPBTp1]
				aDetSPB[nPos,nPosPBSem]			:= aDetSPBAux[ny,nPosPBSem]
				aDetSPB[nPos,nPosPBCc]			:= aDetSPBAux[ny,nPosPBCc]
				aDetSPB[nPos,nPosPBDel]			:= .F.
				aDetSPB[nPos,nPosPBAWT]			:= aDetSPBAux[ny,nPosPBAWT]
				aDetSPB[nPos,nPosPBRWT]			:= aDetSPBAux[ny,nPosPBRWT]
		    Else
		    	nLin := aScan(aDetSPB,{ |x| ( x[nPosPBPd] + x[nPosPBCc] + x[nPosPBSem] == aDetSPBAux[ny,nPosPBPd] + aDetSPBAux[ny,nPosPBCc] + aDetSPBAux[ny,nPosPBSem] ) } )

		       	aDetSPB[nLin,nPosPBHrs]			+= aDetSPBAux[ny,nPosPBHrs]
		    	aDetSPB[nLin,nPosPBVlr]			+= aDetSPBAux[ny,nPosPBVlr]
				aDetSPB[nLin,nPosPBAWT]			:= NIL
				aDetSPB[nLin,nPosPBRWT]			:= NIL
			EndIf
		Next ny

		DbSelectArea("RGB")
		DbSetOrder(RetOrder("RGB","RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_PD+RGB_CC+RGB_SEQ+DTOS(RGB_DTREF)"))

		For nx := 1 to Len(aDetSPB)
			If lIsGPEM040 .or. lIsGPEM630
				//Alimentar aColsAnt com registros de aDetSPB checando duplicidade (caso haja, serao somados os lctos.)
				If cRotFol <> cRotAux //Se roteiro para integração for diferente de FOL, verifica se já existe o registro no roteiro FOL 
					lInclui := !RGB->(DbSeek(SRA->RA_FILIAL+cProcFOL+SRA->RA_MAT+cPerFOL+cNPagFOL+cRotAux+aDetSPB[nx,nPosPBPd]+aDetSPB[nx,nPosPBCc]))
				Endif
				If lInclui .and. !RGB->(DbSeek(SRA->RA_FILIAL+cProcFOL+SRA->RA_MAT+cPerFOL+cNPagFOL+cRotFOL+aDetSPB[nx,nPosPBPd]+aDetSPB[nx,nPosPBCc]))
					RecLock("RGB",.T.)

					RGB->RGB_FILIAL	:= SRA->RA_FILIAL
					RGB->RGB_MAT	:= SRA->RA_MAT
					RGB->RGB_CC		:= aDetSPB[nx,nPosPBCc]
					RGB->RGB_PD		:= aDetSPB[nx,nPosPBPd]
					RGB->RGB_HORAS	:= aDetSPB[nx,nPosPBHrs]
					RGB->RGB_DTREF	:= Ctod("//")
					RGB->RGB_TIPO1	:= aDetSPB[nx,nPosPBTp1]
					RGB->RGB_TIPO2	:= "E"
					RGB->RGB_VALOR	:= aDetSPB[nx,nPosPBVlr]
					RGB->RGB_PARCEL	:= 0
					RGB->RGB_SEQ	:= SRR->RR_SEQ
					RGB->RGB_PROCES	:= cProcFOL
			      	RGB->RGB_PERIOD	:= cPerFOL
					RGB->RGB_ROTEIR	:= cRotFOL
					RGB->RGB_SEMANA	:= cNPagFOL
			      	RGB->RGB_ROTORI	:= "PON"

					If lItemClVl
						RGB->RGB_ITEM 	:= SRR->RR_ITEM
						RGB->RGB_CLVL 	:= SRR->RR_CLVL
					EndIf
					RGB->(msUnlock())
				ElseIf nSubsLct == 1 //Lcto. ja existente, substitui
					RecLock("RGB",.F.)

					If RGB->RGB_TIPO1 <> aDetSPB[nx,nPosPBTp1]
						If RGB->RGB_TIPO1 == "H" .And. aDetSPB[nx,nPosPBTp1] == "D"
							RGB->RGB_HORAS	:= NoRound( ( ( SRA->RA_HRSMES / 30 ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
		     			ElseIf RGB->RGB_TIPO1 == "D" .And. aDetSPB[nx,nPosPBTp1] == "H"
		      				RGB->RGB_HORAS	:= NoRound( ( ( 30 / SRA->RA_HRSMES ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
		      			Else
		      				RGB->RGB_HORAS	:= aDetSPB[nx,nPosPBHrs]
						EndIf
					Else
						RGB->RGB_HORAS	:= aDetSPB[nx,nPosPBHrs]
					EndIf

					RGB->RGB_TIPO2 	:= "E" //Utilizando o mesmo tratamento da rescisao, atribui a origem do ultimo lcto.
					RGB->RGB_VALOR	:= aDetSPB[nx,nPosPBVlr]
					RGB->(msUnlock())
				ElseIf nSubsLct == 3//Lcto. ja existente, soma
					RecLock("RGB",.F.)

					If RGB->RGB_TIPO1 <> aDetSPB[nx,nPosPBTp1]
						If RGB->RGB_TIPO1 == "H" .And. aDetSPB[nx,nPosPBTp1] == "D"
							RGB->RGB_HORAS	+= NoRound( ( ( SRA->RA_HRSMES / 30 ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				ElseIf RGB->RGB_TIPO1 == "D" .And. aDetSPB[nx,nPosPBTp1] == "H"
	      					RGB->RGB_HORAS	+= NoRound( ( ( 30 / SRA->RA_HRSMES ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				Else
							RGB->RGB_HORAS	+= aDetSPB[nx,nPosPBHrs]
						EndIf
					Else
						RGB->RGB_HORAS += aDetSPB[nx,nPosPBHrs]
					EndIf

					RGB->RGB_TIPO2 	:= "E" //Utilizando o mesmo tratamento da rescisao, atribui a origem do ultimo lcto.
					RGB->RGB_VALOR	+= aDetSPB[nx,nPosPBVlr]
					RGB->(msUnlock())
				EndIf
			Else //Importacao no calculo de Rescisao Coletiva

				//Verifica se existe a chave VERBA + C.CUSTO + SEMANA para incluir ou somar no aPd
				nPos := ( aScan( aPd,{ |x| ( x[1] + x[2] + x[3] == aDetSPB[nx,nPosPBPd] + aDetSPB[nx,nPosPBCc] + aDetSPB[nx,nPosPBSem] ) .And. ( x[9] <> "D" ) } ) )

				If nPos == 0
					fMatriz( aDetSPB[ nx,nPosPBPd ]		,;	//Verba
						aDetSPB[nx,nPosPBVlr]			,;	//Valor
						aDetSPB[nx,nPosPBHrs]			,;	//Horas
						aDetSPB[nx,nPosPBSem]			,;	//Semana
						aDetSPB[nx,nPosPBCC]			,;	//Centro de Custo
						aDetSPB[nx,nPosPBTp1]			,;	//Tipo 1 "V"alor,"H"oras,"D"ias
						"E"								,;	//Tipo 2 "G"erado,"I"nformado,"E"letronico,etc.
						0								,;	//Parcela
						" "								,;	//Deletada
						CTOD("//")						 ;	//Data de Pagamento
					)

				ElseIf nSubsLct == 1 //Lcto. ja existente, substitui

					If aPd[nPos,06] <> aDetSPB[nx,nPosPBTp1]
						If aPd[nPos,06] == "H" .And. aDetSPB[nx,nPosPBTp1] == "D"
							aPd[nPos,04]	:= NoRound( ( ( SRA->RA_HRSMES / 30 ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				ElseIf aPd[nPos,06] == "D" .And. aDetSPB[nx,nPosPBTp1] == "H"
	      					aPd[nPos,04]	:= NoRound( ( ( 30 / SRA->RA_HRSMES ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				Else
							aPd[nPos,04]	:= aDetSPB[nx,nPosPBHrs]
						EndIf
					Else

						aPd[nPos,04]	:= aDetSPB[nx,nPosPBHrs]
					EndIf

					aPd[nPos,05] := aDetSPB[nx,nPosPBVlr]	//Valor
					aPd[nPos,07] := "E"						//Origem do Calculo

				ElseIf nSubsLct == 3//Lcto. ja existente, soma

					If aPd[nPos,06] <> aDetSPB[nx,nPosPBTp1]
						If aPd[nPos,06] == "H" .And. aDetSPB[nx,nPosPBTp1] == "D"
							aPd[nPos,04]	+= NoRound( ( ( SRA->RA_HRSMES / 30 ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				ElseIf aPd[nPos,06] == "D" .And. aDetSPB[nx,nPosPBTp1] == "H"
	      					aPd[nPos,04]	+= NoRound( ( ( 30 / SRA->RA_HRSMES ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				Else
							aPd[nPos,04]	+= aDetSPB[nx,nPosPBHrs]
						EndIf
					Else

						aPd[nPos,04]	+= aDetSPB[nx,nPosPBHrs]
					EndIf

					aPd[nPos,05] += aDetSPB[nx,nPosPBVlr]	//Valor
					aPd[nPos,07] := "E"						//Origem do Calculo
				EndIf
			EndIf
		Next nx

		If !Empty(aSpbRecAux)
			aSPBRec := aClone(aSpbRecAux)
		EndIf
		If lIsGPEM040
			If cPaisLoc == "BRA"
				dDataAvis := M->RG_DTAVISO
				fAtAvProj(.T.,.F.)
				dDataAvis := dBkpAvis
			EndIf
			MsgAlert(STR0089)   //"Processo Concluido com Sucesso!"
		EndIf

	Else

		If lIsGPEM040

			MsgAlert(STR0080)   //"Nao ha lancamentos nos resultados do Ponto Eletronico para importacao."
		Else

			SRA->(;
						aAdd( aLogFile ,	STR0077 + 		RA_NOME 	+  " "	+;		//"Funcionario:"
											STR0078 + 	    RA_FILIAL 	+ "   " +	;	//"Filial:"
											STR0079 + 		RA_MAT 		+ ".  "	+	;	//"Matricula:"
											STR0080 + STR0318 + DtoC(dDataDe) + " - " + DtoC(dDataAte);									//"Nao ha lancamentos nos resultados do Ponto Eletronico para importacao." ### " Período de apontamento: "
							);
					 )
		EndIf
	EndIf
	SPB->( dbCloseArea() )
EndIf

Return( Nil )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGetPeriodoºAutor  ³Leandro Drumond    º Data ³  14/09/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Obtem o periodo de apontamento							  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fGetPeriodo( oPeriodo )

Local aArea 		:= GetArea()
Local lRet 			:= .T.

oPeriodo:PerSel()

    /*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Mostra Advertencia para Periodo Nao Encontrado				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
lRet := oPeriodo:lFound

RestArea( aArea )

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GrvIntSPB  ºAutor  ³Leandro Drumond    º Data ³  19/09/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Grava conteudo no campo PB_INTEGRAm para que, ao efetuar 	  º±±
±±º          ³fechamento do periodo, campo PL_INTEGRA fique com conteudo  º±±
±±º          ³igual a um e valores nao sejam transferidos na integracao.  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GrvIntSPB(aSPBRec)
Local aArea := GetArea()
Local nX	:= 0

For nX := 1 to Len(aSPBRec)
	SPB->(dbGoTo(aSPBRec[nX]))
	RecLock("SPB",.F.)

		SPB->PB_INTEGRA := "1"

	SPB->(MsUnlock())
Next nX

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ExcIntSPB  ºAutor  ³Leandro Drumond    º Data ³  19/09/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Exclui conteudo do campo PB_INTEGRA						  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ExcIntSPB(cKeySPB)
Local aArea 	:= GetArea()
Local cKeyRG8 	:= ''

Private oPeriodo	:= RHPERIODO():New()

cKeyRG8 := "GPE" + cPeriodo + cNumPag + cProcesso + fGetRotOrdinar()

RG8->( dbSetOrder( Retorder( "RG8" , "RG8_FILIAL+RG8_MODCOR+RG8_PERCOR+RG8_NPGCOR+RG8_PROCOR+RG8_ROTCOR" ) ) )

//PROCURA CHAVE CORRESPONDENTE DA FOLHA
If RG8->( dbSeek( xFilial("RCH",SRA->RA_FILIAL) + cKeyRG8 ) )
	oPeriodo:cProcesso	:= 	RG8->RG8_PRCORI
	oPeriodo:cRoteiro	:=	RG8->RG8_ROTORI
	oPeriodo:cPeriodo	:=	RG8->RG8_PERORI
	oPeriodo:cNumPagto	:= 	RG8->RG8_NPGORI

	If !(fGetPeriodo( oPeriodo ))
		Return Nil
	EndIf
EndIf

If MsFile("SPB")
	SPB->(DbSetOrder(1))

	If SPB->(dbSeek(cKeySPB))
		While SPB->(!Eof() .and. PB_FILIAL + PB_MAT + PB_PROCES + PB_PERIODO + PB_ROTEIR + PB_SEMANA == cKeySPB + oPeriodo:cProcesso + oPeriodo:cPeriodo + oPeriodo:cRoteiro + oPeriodo:cNumPagto )
			If SPB->PB_INTEGRA == "1"
				RecLock("SPB",.F.)
				SPB->PB_INTEGRA := " "
				SPB->(MsUnlock())
			EndIf
			SPB->(dbSkip())
		EndDo
	EndIf
Endif

RestArea(aArea)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCommit040  ³ Autor ³ Leandro Drumond       ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao que comita as informacoes, SEM abrir outra inclusao au-³±±
±±³          ³tomaticamente.                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fCommit040(oModel)                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fCommit040(oModel)
Local aArea      	:= GetArea()
Local aAreaSRD     	:= GetArea()
Local nOperacao  	:= oModel:GetOperation()
Local lRet			:= .T.
Local oGrid 		:= oModel:GetModel('GPEM040_MGET')
Local aSolucao		:= {}
Local nI
Local aPerAtuADI	:= {}
Local lBloqAdm		:= SRA->(ColumnPos("RA_BLOQADM")) > 0
Local lAhgora		:= SuperGetMv("MV_RHAHGOR",, .F. )
Local cQuery		:= ""

DEFAULT lGestPubl   := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
DEFAULT lConsig		:= GetMvRH("MV_CONSIG",, .F.)
DEFAULT lCpoFlagIC	:= ChkFile("SRG") .And. SRG->(ColumnPos("RG_CONFIC")) > 0
DEFAULT lMvRHNG		:= SuperGetMv('MV_RHNG', .F., .F.)
DEFAULT __lMemCalc  := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc() // Memória de Cálculo

Begin Transaction

	If nOperacao == MODEL_OPERATION_DELETE

		//Informa ao usuario sobre os lancamentos importados do Ponto Eletronico
		If !lColetiva
			cMsgAlert := OemToAnsi(STR0194) //"Se houve importação de dados do Ponto Eletrônico eles não serão excluídos ao executar o cancelamento da rescisão."
			aAdd( aSolucao, { OemToAnsi(STR0195) } ) //"Os dados importados do Ponto Eletrônico deverão ser cancelados por meio da rotina Cancelamento de Cálculo (GPEM160), selecionando o roteiro 'PON'."
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(cMsgAlert) , 1,,,,,,, aSolucao )
		EndIf

		FWFormCommit( oModel ) 						//--Grava model
		ExcIntSPB(SRA->RA_FILIAL+SRA->RA_MAT) 		//--Retorna o campo PB_INTEGRA para Nil, de forma que este possa ser integrado com a folha apos o fechamento
		fRetSitRes()  								//--Retorna a situacao do funcionario

		fDelHist(.T.) //deleta historico de medias
		fDelRU6(.T.) //Deleta deduções dos dependentes

		If lAhgora .And. SRG->RG_EFETIVA == "S" .And. SRG->RG_RESCDIS == "0"
			fResAhgora(.T.) //Deleta/Altera registro de integração com Ahgora
		EndIf 

		If __lMemCalc //Exclui informações da memória de cálculo, quando existir
			fDelMemCalc(SRG->RG_FILIAL, SRG->RG_MAT, SRG->RG_PROCES, SRG->RG_PERIODO, SRG->RG_ROTEIR, SRG->RG_SEMANA)
		EndIf

		If lGestPubl .AND. cModulo $ 'GFP*VDF'
			fIncRes(SRA->RA_FILIAL, oModel:GetValue("GPEM040_MSRG","RG_TIPORES"), @aIncRes, @nPercFgts, @cRescrais, @cAfasfgts, @Cod_Am)
			fRetSitGFP(cAfasfgts)//--Retorna a situacao do funcionario aposentado
		EndIf

		If cPaisLoc== "BRA" .And. SRG->RG_EFETIVA == "S" .And. SRG->RG_RESCDIS == '0' .AND. FindFunction("OrgXDelRescisao") //Só retorna status do posto se for a rescisão principal, na exclusão de complementares nada é alterado.
			OrgXDelRescisao(SRA->RA_FILIAL, SRA->RA_MAT)
		EndIf
		PcoDetLan("000090","01","GPEM040", .T.)

		If lBloqAdm
			If oModel:GetValue("GPEM040_MSRG","RA_BLOQADM")
				RecLock("SRA", .F.)
				SRA->RA_BLOQADM :=  "2"
				MsUnLock()
			EndIf
		ElseIf cPaisLoc $ "BRA|DOM|MEX" .And. oModel:GetValue("GPEM040_MSRG","RA_FECREI")
			RecLock("SRA", .F.)
			SRA->RA_FECREI :=  CtoD("")
			MsUnLock()
		EndIf

		// Gravar as verbas com origem A que estão no grid na RGB caso o roteiro de adiantamento esteja fechado.
		If ! cCompl == "S" .And. fGetPerAtual( @aPerAtuADI, xFilial("RCH", SRA->RA_FILIAL), SRA->RA_PROCES, fGetCalcRot('2'))
			If aPerAtuADI[1][1] > cPeriodo // Período de ADI já foi fechado
				For nI := 1 To oGrid:Length()
					oGrid:GoLine(nI)
					If oGrid:GetValue("RR_TIPO2") == "A" .And. (oGrid:GetValue("RR_PD") != aCodFol[010,1])
						GravaRGB(oGrid, oGrid:nLine)
					EndIf
				Next
			EndIf
		EndIf

		If SRA->RA_SITFOLH == "D" //Se a rescisão excluída era complementar, funcionário continua demitido.
			DbSelectArea("SRC")
			DbSetOrder(RetOrder("SRC","RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA"))
			If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + SRA->RA_PROCES + fGetCalcRot('1'))
				MsgAlert(STR0228) //"A rescisão foi integrada e calculada na folha. Os registros gravados no roteiro da folha não serão excluídos. Para exclui-los utilize a rotina de 'Cancelamento de Cálculo'."
			EndIf
		EndIf

		If cPaisLoc == "BRA" .And. !Empty(P_ADIPGFE)
			For nI := 1 To oGrid:Length()
				oGrid:GoLine(nI)
				If oGrid:GetValue("RR_PD") $ P_ADIPGFE+"/"+P_ADIPGAB .And. oGrid:GetValue("RR_TIPO2") == "F"
					//--Exclui registros existentes na SRC
					cQuery := "UPDATE " + RetSqlName("SRD") + " "
					cQuery += "SET RD_NUMID='' "
					cQuery += "WHERE RD_FILIAL='" + SRA->RA_FILIAL + "' AND "
					cQuery += "RD_MAT='" + SRA->RA_MAT + "' AND "
					cQuery += "RD_NUMID='" + oModel:GetValue("GPEM040_MSRG", "RG_PERIODO") + oModel:GetValue("GPEM040_MSRG", "RG_SEMANA") + oModel:GetValue("GPEM040_MSRG", "RG_ROTEIR") + oGrid:GetValue("RR_PD") + "'"

					TcSqlExec( cQuery )

					TcRefresh( InitSqlName("SRD") )
				EndIf
			Next
		EndIf

		//Registra na RJP a exclusão do cálculo da rescisão
		If lMvRHNG .And. SRG->RG_EFETIVA == "S" .And. cCompl <> "S"
			fRescToRJP("E")
		EndIf

	Else

		//Apaga rescisao anterior
		If lRecRes .and. !(cCompl == "S") .and. lRet
		    If SRG->RG_DATAHOM <> M->RG_DATAHOM
				fDelRU6(.T.,, lRecRes)
			EndIf
			Gpem040Exc( nRegSrg )
		EndIf

		If cPaisLoc == "BRA" .And. oModel:GetValue("GPEM040_MSRG", "RG_EFETIVA") == "S" .And. lConsig .And. lCpoFlagIC
			If IsBlind() .Or. MsgYesNo( OemToAnsi( STR0296 ), OemToAnsi( STR0020 ) )//"Deseja enviar a rescisão para a instituição de crédito?"##"Atenção"
				oModel:GetModel('GPEM040_MSRG'):LoadValue('RG_CONFIC', "1")
			EndIf
		EndIf

		FWFormCommit( oModel ) //Grava model

		If SRG->RG_EFETIVA $ "S*2"

			If cPaisLoc != "MEX"

				RetSituacao()

				If  lGestPubl .AND. cModulo $ 'GFP*VDF'
					If cAfasfgts $ 'U1*U3'//Aposentadoria
						RegToMemory("SRA")
						fGravaSr3(dDataDem,"APO", SRG->RG_NOVSUBS,, 4) //Grava SR3/SR7

						RecLock("SRA",.F.,.T.)
						SRA->RA_SITFOLH	:= ""
						SRA->RA_DEMISSA	:= Ctod("  /  /  ")
						SRA->RA_APOSENT	:= dDataDem
						If SRA->RA_CATFUNC == "2" //Servidor Efetivo
							SRA->RA_CATFUNC	:= "8"
						ELseIf	SRA->RA_CATFUNC == "0" //Membro Efetivo.
							SRA->RA_CATFUNC	:= "7"
						EndIf
						SRA->RA_TABELA	:= ""
						SRA->RA_TABNIVE	:= ""
						SRA->RA_TABFAIX	:= ""
						SRA->RA_SALARIO	:= SRG->RG_NOVSUBS
						SRA->RA_MSBLQL	:= '2'
						SRA->( MsUnLock() )


					EndIf

					If SRA->RA_CATFUNC $ '4,5'//4Servidor Adido/Cedido
						If 	RID->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT))
							While RID->(!eof()) .and. RID->(RID_FILIAL+RID_MAT) == SRA->(RA_FILIAL+RA_MAT)
								If empty(RID->RID_DATFIM)
									RecLock("RID",.F.,.T.)
									RID->RID_DATFIM	:= 	dDataDem
									RID->( MsUnLock() )
								Endif
								RID->(dbskip())
							EndDo
						EndIF
					EndIf
				EndIf
			EndIf

			If FindFunction("OrgXRescisao")
				OrgXRescisao(SRA->RA_FILIAL, SRA->RA_MAT, dDataDem)
			EndIf

			fMontaMail("017")

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Integracao Protheus X RM Classis Net (RM Sistemas)³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If GetNewPar("MV_CLASSIS", .F.)
				//Efetua atualizacao de registros na tabela INT_FUNC (Tabela de integracao de professores)
				//referente a Integracao do Protheus x RM Classis Net (RM Sistemas)
				ClsIncPrf("U", "GPEM040")
			Endif

			GrvIntSPB(aSPBRec)

			If cPaisLoc == "BRA" .And. !Empty( aRecResUt )
				aAreaSRD := SRD->( GetArea() )
				For nI := 1 To Len(aRecResUt)
					SRD->( dbGoTo( aRecResUt[nI, 1] ) )
					If RecLock("SRD", .F.)
						SRD->RD_NUMID := aRecResUt[nI, 2]
						SRD->(MsUnlock())
					EndIf
				Next nI
				RestArea( aAreaSRD )
			EndIf

			PcoDetLan("000090","01","GPEM040")
		EndIf

		If lBloqAdm
			If oModel:GetValue("GPEM040_MSRG","RA_BLOQADM")
				RecLock("SRA", .F.)
				SRA->RA_BLOQADM :=  "1"
				MsUnLock()
			EndIf
		ElseIf cPaisLoc $ "BRA|DOM|MEX" .And. oModel:GetValue("GPEM040_MSRG","RA_FECREI")
			RecLock("SRA", .F.)
			SRA->RA_FECREI :=  oModel:GetValue("GPEM040_MSRG","RG_DATADEM")
			MsUnLock()
		EndIf

		//Grava na tabela RJP - NG Quirons
		If lMvRHNG .And. SRG->RG_EFETIVA == "S" .And. cCompl <> "S"
			fRescToRJP("D")
		EndIf

	EndIf

End Transaction

If CCOMPL <> "S"
	//Desvincula ou vincula o funcionário ao currículo de acordo com a operação realizada
	fVincSQG(nOperacao,SRA->RA_FILIAL,SRA->RA_MAT)
EndIf


/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Atualiza Publicação RI6 - SIGAGFP								³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If lGestPubl .And. cModulo $ 'GFP*VDF' .And. cCompl <> "S" .And. !Empty(aPublicacao[4]) .And. nOperacao == MODEL_OPERATION_INSERT
	DbSelectArea("RI6")
	DbSetOrder(aPublicacao[5])
	RI6->(DbSeek(aPublicacao[4]))
	Reclock("RI6",.F.)
	RI6->RI6_TABORI	:= "SRG"
	RI6->RI6_DTEFEI	:= SRG->RG_DATADEM
	MsUnlock()
	DbSelectArea("SRG")
EndIf


cFilAnt := cFilOld

RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fRetSitResºAutor  ³Microsiga           º Data ³  01/30/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna a Situacao do funcionario                          º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function fRetSitRes(cFil,cMat)
Local aArea		:= SRG->(GetArea())
Local aSituacao := {}

DEFAULT cFil 	:= SRA->RA_FILIAL
DEFAULT cMat 	:= SRA->RA_MAT

aSituacao := RetSituacao( cFil , cMat , .F. , NIL , .T. )

If !( aSituacao[1] == "D" )
		SRA->( RecLock( "SRA" , .F. , .T. ) )
		SRA->RA_DEMISSA  := Ctod("//")
		SRA->RA_RESCRAI  := "  "
		SRA->( MsUnLock() )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Retorna a Atual Situacao do Funcionario                       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		RetSituacao(cFil , cMat , .T. , NIL , .T. )
EndIf

RestArea(aArea)

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fTudoOKM40  ³ Autor ³ Leandro Drumond       ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Validacoes acionadas ao clicar no botao confirma.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fTudoOKM40()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fTudoOKM40(oModel)
Local aArea			:= GetArea()
Local lRet			:= .T.
Local lContinua		:= .T.
Local nAux2			:= 0
Local nX			:= 0
Local nOperation	:= oModel:GetOperation()
Local oModelSRG		:= oModel:GetModel('GPEM040_MSRG')
Local oGrid 		:= oModel:GetModel('GPEM040_MGET')
Local aPerAtual		:= {}
Local cProcesso		:= ""
Local cRoteiro		:= ""
Local cPeriodo		:= ""
Local cNumPago		:= ""
Local cMesAnt		:= ""
Local cMesAtu		:= ""
Local cAnoAnt		:= ""
Local cAnoAtu		:= ""
Local cSem			:= ""
Local dDtPerAt		:= CtoD("//")
Local lAlteracao	:= .F.
Local lBloqAb		:= .F.
Local lBloqDtDem	:= .F.
//Controle de registros duplicados comparando com a quantidade de lançamentos permitidos
Local nCVerba		:= 1 //Inicializado com 1 devido a valor que obrigatoriamente deve conter de verba, caso haja diferença deve checar qtde de lanc limite
Local cVerbaAnt		:= "" //Controle de Verba Anterior
Local cVerbaAtu		:= "" //Controle de Verbas Atual
Local cMsgLog		:= ""
Local lItemClVl   	:= SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "1*3" // Define se trabalha com item e classe contabil
Local aErros		:= {}
Local lGera			:= .T.
Local cMsgAlert 	:= ""
Local cMsg			:= ""
Local lTpSuces		:= SRG->(ColumnPos("RG_TPSU")) > 0
Local cTpSuc		:= "3"
Local lResComp		:= .F.
Local lRetif		:= .F.
Local lAhgora		:= SuperGetMv("MV_RHAHGOR",, .F. ) .And. ChkFile("RUM")

Private aPd_Aux		:= aPd_SRK
Private oExcel		:= Nil

DEFAULT lVerMultv	:= If ( Type("P_MULTV") == "U",.F.,P_MULTV)
DEFAULT lTemSeqMV	:= If(SRC->(ColumnPos( 'RC_SEQMV' )) > 0,.T.,.F.)
DEFAULT lIntTaf 	:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 )
DEFAULT lMiddleware	:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )
DEFAULT lTemTpRem   := SRG->( ColumnPos( "RG_TPREMAD" ) ) > 0

FWModelActive( oModel )

 /*	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Nao deixa alterar informacoes caso a rescisao esteja aplicada. 					  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 	*/
If cModFol == "2" .and. (nOperation == MODEL_OPERATION_UPDATE .Or. nOperation == MODEL_OPERATION_DELETE) .And. !(RG_EFETIVA $ "1*2")
	Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0092), 1, 0 ) //"Esta rescisao ja foi aplicada. Portanto, não pode ser modificada."
	lRet:= .F.
EndIf

DbSelectArea("RCH")
DbSetOrder(1)
If DbSeek(xFilial("RCH",SRA->RA_FILIAL)+M->RG_PROCES+M->RG_PERIODO+M->RG_SEMANA+M->RG_ROTEIR)
	If M->RG_EFETIVA == 'S' .And. RCH->RCH_PERSEL <> "1"
		cMsgAlert := OemToAnsi(STR0219)
		Help(, , OemToAnsi(STR0020), , OemToAnsi(cMsgAlert), 1, 0, , , , , , { OemToAnsi(STR0220) })
		lRet := .F.
	EndIf
EndIf

/*	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Reclassifica o tipo de rescisao (caso for rescisao complementar ou complementar fora do mes). ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 	*/
If lRet .And. (nOperation == MODEL_OPERATION_UPDATE .Or. nOperation == MODEL_OPERATION_INSERT)
	If cModFol == "2"
		//Necessario igualar os campos de roteiro, pois o setRelation e feito atraves
		//de RG_APLROT em virtude do processo de aplicacao e reversao de aplicacao
		oModelSRG:LoadValue('RG_APLROT', oModelSRG:GetValue('RG_ROTEIR'))

		dbSelectArea("SRG")
		SRG->(DbSetOrder( RetOrdem( "SRG", "RG_FILIAL+RG_MAT+DTOS(RG_DTPAGO)" ) ))

		If SRG->(dbSeek(xFilial("SRG",SRA->RA_FILIAL)+SRA->RA_MAT)) .And. SRG->RG_DTPAGO <> M->RG_DTPAGO


		    If cPaisLoc $ "ARG*CHI*COL*COS*DOM*MEX"

				While SRG->(RG_FILIAL+RG_MAT) == xFilial("SRG",SRA->RA_FILIAL) + SRA->RA_MAT .And. lContinua
					If SRG->RG_RESCOMP == "1"
						cProcesso	:= SRG->RG_PROCES
						cRoteiro	:= SRG->RG_ROTEIR
						cPeriodo	:= SRG->RG_PERIODO
						cNumPago	:= SRG->RG_SEMANA
						lContinua:= .F.
					EndIf
					SRG->(dbSkip())
				End

			EndIf

			//procura o mes do periodo da rescisao
			cAnoAnt:= Posicione("RCH", 4, xFilial("RCH",SRA->RA_FILIAL)+cProcesso+cRoteiro+cPeriodo+cNumPago, "RCH_ANO")
			cMesAnt:= Posicione("RCH", 4, xFilial("RCH",SRA->RA_FILIAL)+cProcesso+cRoteiro+cPeriodo+cNumPago, "RCH_MES")
			cAnoAnt+= cMesAnt
			//procura o mes do periodo da nova rescisao. Se for no mesmo mes, mantem status 'rescisao complementar', caso contrario muda para 'rescisao compl. fora do mes'
			cAnoAtu:= Posicione("RCH", 4, xFilial("RCH",SRA->RA_FILIAL)+M->RG_PROCES+M->RG_ROTEIR+M->RG_PERIODO+M->RG_SEMANA, "RCH_ANO")
			cMesAtu:= Posicione("RCH", 4, xFilial("RCH",SRA->RA_FILIAL)+M->RG_PROCES+M->RG_ROTEIR+M->RG_PERIODO+M->RG_SEMANA, "RCH_MES")
			cAnoAtu+= cMesAtu

			If cAnoAnt < cAnoAtu
				If cPaisLoc $ "ARG*CHI*COL*COS*DOM*MEX"
					M->RG_RESCOMP:= "3"
				EndIf
			ElseIf cAnoAnt > cAnoAtu
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0093), 1, 0 ) //"O periodo selecionado eh anterior ao periodo em que foi calculada a rescisao"
				lRet:= .F.
			EndIf

		EndIf
	EndIf
EndIf

If lRet
/*	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se eh inclusao, soh permite a confirmacao se a rescisao foi calculada.              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 	*/
	If nOperation == MODEL_OPERATION_INSERT
		If oGrid:Length() == 1 .And. (cPaisLoc != "BRA" .Or. (cPaisLoc == "BRA" .And. SRA->RA_CATEFD <> '111'))
			If Empty(oGrid:GetValue("RR_PD"))
				Help( ,, 'HELP',, OemToAnsi(STR0094), 1, 0 ) //"Para incluir uma rescisao ela deve ser calculada."##"Calcule a rescisao."
				lRet:= .F.
			Else
				If !IsBlind() .and. !( MsgNoYes(	OemToAnsi( STR0197 + CRLF + CRLF + STR0097),;//"Só houve a geração de uma verba no cálculo da rescisão."##"Deseja gravar mesmo assim?"
					OemToAnsi(STR0020) )) // "Atencao"
					cMsgLog := STR0198//"Rescisão não foi gravada."
					lRet	:= .F.
				EndIf
			EndIf
		Else
			cTpSuc := If(lTpSuces, oModelSRG:GetValue('RG_TPSU'), "3")
			If lTCFA040
				If VldTpRes() .And. fValEfdM040(M->RG_OBS, oModelSRG:GetValue('RG_OBITO'), oModelSRG:GetValue('RG_TIPORES'), oModelSRG:GetValue('RG_NPROC'), oModelSRG:GetValue('RG_SUCES'),cTpSuc)
					lRet := .T.
				Else
					Help( ,, OemToAnsi('Atenção'),, OemToAnsi('Utilize o Tipo de Rescisão informado na solicitação vinda do Portal.'), 1, 0 )
					lRet := .F.
				EndIf
			Else
				lRet := cPaisLoc != "BRA" .Or. fValEfdM040(M->RG_OBS, oModelSRG:GetValue('RG_OBITO'), oModelSRG:GetValue('RG_TIPORES'), oModelSRG:GetValue('RG_NPROC'), oModelSRG:GetValue('RG_SUCES'), cTpSuc, @cMsg)
				If Empty(cMsgLog)
					cMsgLog :=  cMsg
				Else
					cMsgLog += CRLF + cMsg
				Endif
			EndIf
		EndIf
	ElseIf nOperation == MODEL_OPERATION_UPDATE
	/*	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se eh alteracao, verifica se os dados foram alterados e se houve recalculo da rescisao ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 	*/
		If Len(oModelSRG:aDataModel) > 0
			For nAux2 := 1 To Len(oModelSRG:aDataModel[1])
				If oModel:IsFieldUpdated('GPEM040_MSRG', oModelSRG:aDataModel[1][nAux2][1])
					lAlteracao:= .T.
					Exit
				EndIf
			Next
		EndIf

		If lAlteracao
			If!( MsgNoYes(	OemToAnsi( STR0096 + CRLF + CRLF + STR0097),;//"Houve alteracao de campos no formulario e nao houve recalculo da rescisao."##"Deseja gravar mesmo assim?"
				 OemToAnsi(STR0020) )) // "Atencao"
				lRet:= .F.
			EndIf
		EndIf
	EndIf
EndIf

If lRet .and. nOperation == MODEL_OPERATION_DELETE
	DbSelectArea("RCH")
	DbSetOrder(1)
	If DbSeek(xFilial("RCH",SRA->RA_FILIAL)+M->RG_PROCES+M->RG_PERIODO+M->RG_SEMANA+M->RG_ROTEIR)
		If SRG->RG_EFETIVA == 'S' .And. !Empty(RCH->RCH_DTINTE)
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0102), 1, 0 ) //"Periodo já foi integrado com a folha de pagamento. Rescisão não poderá ser excluída."
			lRet := .F.
		EndIf
	EndIf

	// Valida bloqueio na exclusao
	If lRet
		If fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetCalcRot('4') )
			dDtPerAt	:= aPerAtual[1,7]
			cSem		:= aPerAtual[1,2]
			lBloqAb 	:= !fVldAccess( cFilAnt, dDtPerAt, cSem, .F., fGetCalcRot("4") )
		EndIf
		lBloqDtDem	:= !fVldAccess( cFilAnt, M->RG_DATADEM, M->RG_SEMANA, .F., fGetCalcRot("4") )
		If lBloqAb .Or. lBloqDtDem // Periodo aberto esta bloqueado ou o periodo em que a rescisao foi calculada
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0149), 1, 0 ) //"Exclusão bloqueada para o período. Contate o Administrador."
			lRet := .F.
		EndIf
	EndIf
EndIf

If lRet .and. nOperation == MODEL_OPERATION_INSERT
	For nX := 1 to oGrid:Length()
		oGrid:GoLine(nX)
		If (cModFol == "1" .And. oGrid:GetValue("RR_VALOR") < 0) .Or. (cModFol == "2" .And. oGrid:GetValue("RC_VALOR") < 0)
			If MsgYesNo( OemToAnsi( STR0104 ) , OemToAnsi( STR0020) ) //Atenção. Existem valores negativos na rescisão. Continua?
				lRet := .T.
			Else
				lRet := .F.
			EndIf
			Exit
		EndIf
		If lItemClVl
			cVerbaAtu	:=  oGrid:GetValue("RR_PD")+oGrid:GetValue("RR_CC")+oGrid:GetValue("RR_ITEM")+oGrid:GetValue("RR_CLVL")
		Else
			cVerbaAtu	:=  oGrid:GetValue("RR_PD")+oGrid:GetValue("RR_CC")
		EndIf
		if  cVerbaAnt == cVerbaAtu
			nCVerba	+= 1
		EndIf
		If cVerbaAnt <> cVerbaAtu .Or. (cVerbaAnt == cVerbaAtu .And. nX == oGrid:Length())
			if (nCVerba > 1 .And. nCVerba > Val(Posicione("SRV",1,xFilial("SRV")+cVerbaAnt ,"RV_QTDLANC")) .And. SRV->RV_LCTODIA <> "S")
				if Empty(cMsgLog)
					cMsgLog += STR0169 + CRLF
				EndIf
				cMsgLog += cVerbaAnt +' - ' + Posicione("SRV",1,xFilial("SRV")+cVerbaAnt ,"RV_DESC") + CRLF
			EndIf
			cVerbaAnt := cVerbaAtu
			nCVerba	:= 1
		EndIf
	Next nX
EndIf

if !Empty(cMsgLog)
	Help( ,, STR0170 , ,OemToAnsi( cMsgLog) , 1 , 0 )
	lRet := .F.
EndIf

If lTemTpRem .And. lRet .And. (nOperation == MODEL_OPERATION_INSERT .Or. nOperation == MODEL_OPERATION_UPDATE) .And. !Empty(oModelSRG:GetValue("RG_TPREMAD")) .And. Empty(oModelSRG:GetValue("RG_DTQUAR"))
    Help( Nil, Nil, OemToAnsi(STR0020), Nil, OemToAnsi(STR0319), 1, 0 )//"Atenção"##'É obrigatório efetuar o preenchimento do campo "Dt.Fim.Quar." (RG_DTQUAR) quando o campo "Tp.Rem.Desl." (RG_TPREMAD) está preenchido.'
    lRet := .F.
EndIf

If lRet .And. cPaisLoc == "BRA"
	If lVerMultv .and. lTemSeqMV
		If nOperation <> MODEL_OPERATION_DELETE
			cSeqMV := "9" //Força a gravação da RAZ/RAW
			aPd := aClone(aPdRAW)
			fGrvRAZRAW(.T.)
			aPd := {}
		Else
			fDelRAZRAW()
		EndIf
	EndIf

	// Valida se o conteúdo do parâmetro MV_FASESOC é válido
	If SuperGetMv("MV_RHTAF",, .F.) .And. !Empty(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) .And. !SuperGetMv("MV_FASESOC",/*lHelp*/,' ') $ "1|2"
		// "Conteúdo do parâmetro MV_FASESOC inválido." # "Verifique o conteúdo do parâmetro MV_FASESOC." # "Os valores permitidos são: " # " (Vazio) - Primeira fase" # "1 - Primeira e segunda fase" # "2 - Primeira, segunda e treiceira fase"
		Help(NIL, NIL, "MV_FASESOC", NIL, STR0230, 1, 0, NIL, NIL, NIL, NIL, NIL, { STR0231 + CRLF + STR0232 + CRLF + STR0233 + CRLF + STR0234 + CRLF + STR0235 })
		lRet := .F.
	EndIf
	//Integracao com o TAF
	If (lIntTaf .Or. lMiddleware) .And. fResCompl(@lGera, Nil, nOperation, @lResComp, @lRetif, Nil, cOpcCompl) .And. M->RG_EFETIVA == 'S' .And. lRet
		lRet := fGeraIntegracao( oModelSRG, oGrid, lRet, @aErros, oModel, lResComp, lRetif)
	EndIf
EndIf
//Retornado pela função fResCompl, se rescisão complementar com pagto de PLR e outras verbas, perguntar se quer
//enviar ao TAF ou cancelar o cálculo e fazer os pagamentos em 2 complementares, uma com o PLR e a outras com os outros pagamentos.
If !lGera .And. lRet
	lRet := lGera
	Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0218), 1, 0 ) //"Atenção, Cálculo de Rescisão cancelado pelo usuário."
Endif

If lRet
	fDelTMPMED()
EndIf

If lRet .And. cPaisLoc == "BRA" .And. M->RG_EFETIVA == "S"
	If (nOperation == MODEL_OPERATION_INSERT .Or. nOperation == MODEL_OPERATION_UPDATE) .And. nVal1904 > 0 .And. (IsBlind() .Or. MsgNoYes(STR0311 + CRLF + STR0312, STR0020) )//"A base de INSS de 13º apurada na Rescisão é menor do que a base apurada no roteiro 132."##'Clique em "Sim" para que o sistema efetue a geração da diferença da base de INSS de 13º na verba de ID 1904 no roteiro 132 em período da semana 02 para posterior retificação ao eSocial.'##"Atençäo"
		fGrv1904( nVal1904 )
	ElseIf nOperation == MODEL_OPERATION_DELETE .And. oGrid:SeekLine( { { "RR_PD", aCodFol[247, 1]} } )
		fExc1904()
	EndIf
EndIf

If lRet .And. FindFunction( 'ngIntegra' ) .And. M->RG_EFETIVA == "S" // Finaliza o programa e a tarefa do funcionário
	ngIntegra( { SRA->RA_MAT, M->RG_DATADEM } )
EndIf

If lRet .And. !IsBlind() .And. cPaisLoc == "BRA" .And. nOperation == MODEL_OPERATION_INSERT .And. cCompl == "S" .And. !lProxMes
    MsgAlert(STR0321, STR0020)//"A rescisão anterior será desprezada pois foi efetuado cálculo de rescisão complementar no mesmo mês da original. Todas as conferências devem ser realizadas neste cálculo."##"Atenção"
EndIf

If lRet .And. lAhgora .And. !cCompl == "S" .And. !nOperation == MODEL_OPERATION_DELETE
	fResAhgora()
EndIf

RestArea(aArea)
Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GP40VldTpResºAutor  ³Leandro Drumond   º Data ³  12/12/2013 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica o tipo de rescisao para o funcionario             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³GPEM040													  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GP40VldTpRes(cTab,cTpRes)
Local cTpRsDir	:= ""
Local cDesc		:= ""
Local cTpAviso  := ""
Local cCodAfa	:= ""
Local cDesTpRes	:= ""
Local cDesAvPre	:= ""
Local cCateg	:= "721,722"
Local cTabFil	:= ""
Local cVersEnvio:= ""
Local cVersGPE  := ""
Local cMotEsoc	:=  ""
Local cTrabVinc := fCatTrabEFD("TCV") //Retorna todos os Trab. Com Vínculo
Local cTrabSVinc:= fCatTrabEFD("TSV") //Retorna todos os Trab. Sem Vínculo
Local dDataAv	:= CtoD("")
Local oModel	:= FWModelActive()
Local lExbAlert := .T.
Local lRet 	    := .F.
Local lTrabVinc := .F.
Local lTrabSVinc:= .F.
Local lTabS043	:= .F.
Local lRobo		:= IsBlind()
Local aRet      := array(2)

If cPaisLoc == "BRA"
	lTrabVinc := SRA->RA_CATEFD $ cTrabVinc
	lTrabSVinc:= SRA->RA_CATEFD $ cTrabSVinc
	If lTrabSVinc
	    lRet := fVersEsoc( 'S2399', lExbAlert, , @aRet, @cVersEnvio,@cVersGPE )
	Else
	    lRet := fVersEsoc( 'S2299', lExbAlert, , @aRet, @cVersEnvio,@cVersGPE )
	EndIf

	DEFAULT nDferven  := 0
	DEFAULT nDferave  := 0
	DEFAULT nFaltasv  := 0
	DEFAULT nFaltasp  := 0
EndIf

DEFAULT cTpRes 		:= &(ReadVar())
DEFAULT lIntTaf 	:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 )
DEFAULT lMiddleware	:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )

Private lMetFalV	:= If( Type("lMetFalV") == "U", .F., lMetFalV)
Private LTEMPOPARC	:= If( Type("LTEMPOPARC") == "U", .F., LTEMPOPARC)
Private LMETFALP	:= If( Type("LMETFALP") == "U", .F., LMETFALP)

Private lTpRes    := .T.
Private nDFerPag  := 0.00

If cTab <> Nil
	dbSelectArea( "RCC" )
	dbSetOrder(1)
	cTabFil := Iif(dbSeek(xFilial("RCC",SRA->RA_FILIAL) + cTab + xFilial("SRA")), "E", Iif(dbSeek(xFilial("RCC",SRA->RA_FILIAL) + cTab  ), "C", ""))
	If !Empty(cTabFil)
		While !Eof() .And. Iif(cTabFil == "C", RCC->RCC_FILIAL+RCC_CODIGO == xFilial("RCC",SRA->RA_FILIAL)+cTab, RCC->RCC_FILIAL+RCC_CODIGO+RCC_FIL == xFilial("RCC",SRA->RA_FILIAL)+cTab+xFilial("SRA"))  
			If RCC->RCC_FILIAL+RCC_CODIGO == xFilial("RCC",SRA->RA_FILIAL)+cTab .and. Alltrim(Substr(RCC->RCC_CONTEU,1,2)) == AllTrim(cTpRes)
				cDesc := Alltrim(Substr(RCC->RCC_CONTEU,3,30))
				cTpAviso := Alltrim(Substr(RCC->RCC_CONTEU,34,1))
				cTpRsDir := Alltrim(Substr(RCC->RCC_CONTEU,64,2))
				cCodAfa  := Alltrim(Substr(RCC->RCC_CONTEU,50,1))
				cMotEsoc := Alltrim(Substr(RCC->RCC_CONTEU,73,2))
				lRet := .T.
				lTabS043 = .T.
				Exit
			EndIf
			dBSkip()
		EndDo
	EndIf
	
	If !lTabS043
		Help(" ",1, "NOTAB")
	Else
	    If cPaisLoc == "MEX"
	    	oModel:LoadValue("GPEM040_MSRG","RG_DESCTPR",cDesc)
		EndIf
	EndIf
EndIf

If (lIntTaf .Or. lMiddleware) .And. cPaisLoc == "BRA" .And. lTrabVinc .And. lTabS043 .And. Empty(cMotEsoc)
	Help(,, OemToAnsi(STR0020),, + CRLF + OemToAnsi(STR0143) + " " + SRA->RA_CATEFD + ", " + OemToAnsi(STR0294), 1, 0,,,,,, { + CRLF + OemToAnsi(STR0295)})//"Atencao" ## "Para func. Cat.eSocial contido em:" ### " a coluna Mot. eSocial. (tabela S043) deverá estar preenchida." ### "Altere a tabela S043 e preencha o campo Mot. eSocial para o tipo de rescisão."
	lRet := Iif(lRobo, .T., .F.)
EndIf

If cPaisLoc <> "MEX"
	If lRet .And. cPaisLoc == "BRA" .and. !Empty(cRfyTpAv)
		If cTpAviso $ "I*T*N*D*B"
			If ((cRfyTpAv $ "1*2*5" .Or. ( cRfyTpAv == "6" .And. cVersEnvio >= "2.4.02") ) .AND. cTpAviso $ "T*B")
				If cCodAfa == "I"
					lRet := .T.
				Else
					Help( ,, OemToAnsi(STR0020),, STR0208  , 1, 0 ) //STR0208 # "Código de Afastamento de FGTS informado no Tipo de Recisão é incompativél com o tipo de Aviso Prévio."
					lRet := .F.
				Endif
			Elseif (cRfyTpAv $ "4" .AND. cTpAviso $ "T")
				If cCodAfa == "J"
					lRet := .T.
				Else
					Help( ,, OemToAnsi(STR0020),, STR0208  , 1, 0 ) //STR0208 # "Código de Afastamento de FGTS informado no Tipo de Recisão é incompativél com o tipo de Aviso Prévio."
					lRet := .F.
				Endif
			Elseif (cRfyTpAv $ "3" .AND. cTpAviso $ "N" )
				lRet := .T.
			Else

				/*Montagem da descricao do tipo da rescisao para exibicao na mensagem
				 STR0154 - "está como T - Trabalhado " 154
				 STR0155 - "está como  I - Indenizado " 155
				 STR0156 - "esta como N - Não Previsto" 156
				 STR0157 - "está como D - Descontado " 157 */
				cDesTpRes := Iif(cTpAviso $ "T*B", STR0154, Iif(cTpAviso == "I", STR0155, Iif(cTpAviso == "N", STR0156, STR0157)))

				/*Montagem da descricao do tipo do aviso para exibicao na mensagem
				 STR0158 - 1- Aviso Previo Trabalhado dado pelo empregador ao empregado" 158
				 STR0159 - 2- Aviso Previo Trabalhado dado pelo empregador ao empregado" 159
				 STR0160 - 3– Aviso Previo por Pedido de Demissão, Dispensado do seu cumprimento" 160
				 STR0215 - 6- Aviso prévio trabalhado decorrente de acordo entre empregado e empregador (art. 484-A, 'caput', da CLT).
		         STR0161 - 4- Aviso Previo Trabalhado dado pelo empregado ao empregador (pedido de demissão)." 161 */
				cDesAvPre := Iif(cRfyTpAv == "1", STR0158, Iif(cRfyTpAv == "2", STR0159, Iif(cRfyTpAv == "3", STR0160, Iif(cRfyTpAv == "6" .And. cVersEnvio >= "2.4.02", STR0215, STR0161))))			

				//"Atencao" ## STR0020 "
				//Aviso Previo informado no Tipo de Rescisao (<Cod.TpRes> - <Desc.Aviso>) esta divergente com o tipo de aviso cadastrado para esse funcionario
				//(<Cod.TpAvPrv> - <Desc.TpAvPrv>). Ajuste o tipo de rescisao ou o cadastro do aviso previo.
				//Lembrando que o cadastro do aviso previo nao deve ser realizado quando este for indenizado/descontado(pedido demissao).

				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0162) + ":  "+ cTpRes + " - " + cDesc + " "+cDesTpRes+" , " + OemToAnsi(STR0163) + ": " +  cDesAvPre +". " + chr(13)+ chr(13)+ OemToAnsi(STR0164)  , 1, 0 )

				lRet:= .F.
			Endif
		Endif
	Endif

	If lRet .And. cPaisLoc == "BRA"
		If SRA->RA_CATEFD $ "721|722"
			If Empty(cTpRsDir)
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0143) + " " + cCateg +"." + OemToAnsi(STR0144), 1, 0 ) //"Atencao" ## "Para func. Cat.eSocial contido em:"###" a coluna Tp.Res.Dir. (tabela S043) devera estar preenchida."
				lRet := .F.
			Else
				oModel:LoadValue("GPEM040_MSRG","RG_TPDIR",cTpRsDir)
			EndIf
		EndIf
	EndIf

	If lRet

		If cPaisLoc == "BRA"

			fIncRes(SRA->RA_FILIAL,cTpRes,@aIncRes,@nPercFgts,@cRescrais,@cAfasfgts,@Cod_Am)
			If !Empty(aIncRes) .And. Len(aIncRes)>=17
				lProJav	  := aIncRes[17] == "S"
			Else
				Help( ,, OemToAnsi(STR0020),, OemToAnsi("Tipo de Rescisão não encontrado."), 1, 0 )//Tipo de Rescisão não encontrado.
				lRet:= .F.
			EndIf
			If RCE->(ColumnPos( "RCE_PRJAVT")) > 0
				If (fDesc( "RCE", SRA->RA_SINDICA, "RCE_PRJAVT" )) == "2"
					lProj := .F.
				Endif
			Else
				lProj := .T.
			Endif

			If !lTemRFY
				If !cCompl == "S"
					nDiasAv := GP40DiasAv(@dDataAv,,cTpAviso,@nDiasCum, @nDiaInde)
				EndIf
				If (!Empty(aIncRes) .And.  !(aIncRes[2] $ "I/A")) .Or. cPaisLoc == "BRA"
					oModel:LoadValue("GPEM040_MSRG","RG_DTAVISO",dDataAv)
				EndIf

				If ( cPaisLoc == 'BRA' )
					If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .And. SRG->(ColumnPos( "RG_DAVIND")) > 0
						oModel:LoadValue("GPEM040_MSRG","RG_DAVCUM",nDiasCum)
						oModel:LoadValue("GPEM040_MSRG","RG_DTPROAV",dDtProje)
						oModel:LoadValue("GPEM040_MSRG","RG_DAVIND",nDiaInde)
					Endif
				ENdIf

				oModel:LoadValue("GPEM040_MSRG","RG_DAVISO",nDiasAV)
				oModel:LoadValue("GPEM040_MSRG","RG_DATADEM",dDataDem1)
			Else
				If !Empty(M->RG_DTAVISO)
					nDiasAv := ( dDataDem - M->RG_DTAVISO ) + 1
				EndIf
				If !Empty(aIncRes) .And. aIncRes[2] $ "N|D"
					dDtProje := CTOD("//")
				ElseIf !Empty(dDataAv)
					dDtProje := dDataAv + nDiasAv
				Endif
				oModel:LoadValue("GPEM040_MSRG","RG_DAVISO",nDiasAV)
				If ( cPaisLoc == 'BRA' )
					If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .and. SRG->(ColumnPos( "RG_DAVIND")) > 0
						oModel:LoadValue("GPEM040_MSRG","RG_DTPROAV",dDtProje)
					Endif
				EndIf
				lDtDemRFY := .T.
			EndIf

		ElseIf cPaisLoc == "BOL"
			fIncRes(SRA->RA_FILIAL, cTpRes, @aIncRes, @nPercFgts, @cRescrais, @cAfasfgts, @Cod_Am)
		EndIf

		oModel:LoadValue("GPEM040_MSRG","RG_DESCTPR",cDesc)
		If cPaisLoc == "BRA"
			oModel:LoadValue("GPEM040_MSRG","RG_TPAVISO",cTpAviso)
			If SRA->RA_CATEFD == "721"
				oModel:LoadValue("GPEM040_MSRG","RG_TPDIR",aIncRes[18])
			EndIf
		EndIf
		nFalAtuD := 0


		If cPaisLoc <> "BRA" .OR. !Empty(dDataDem1)
			//Calcula dias de ferias
			aPerFerias := {}
			fdFerRes(.T.,dDataDem1)

			oModel:LoadValue("GPEM040_MSRG","RG_DFERVEN", If(!lMetFalv, If(!lTempoParc, nDferven - nFaltasv, 0), nDferven / 2))
			oModel:LoadValue("GPEM040_MSRG","RG_DFERPRO", If(!lMetFalp, If(!lTempoPArc, nDferave - nFaltasp, 0), nDferave / 2))

			If(cPaisLoc == 'BRA')
				If (SRA->RA_TPCONTR == "3" .Or. SRA->RA_CATEFD $ '107/108') .and. nDferInd > 0
					nDferInd := 2.5	// Intermitente sempre será 1 avo
				EndIf
				oModel:LoadValue("GPEM040_MSRG","RG_DFERAVI",nDferInd)
			EndIf
		Endif
	EndIf
EndIf

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gp40VldAvP  ºAutor  ³Leandro Drumond   º Data ³  14/12/2013 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Atualiza a data de aviso de acordo com os dias de aviso    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³GPEM040													  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Gp40VldAvP()

Local oModel
Local dDataAv 	 := CtoD("")
Local nDAvInf    := 0 // Variável para buscar os dias digitados no campo RG_DAVISO
Local nDAvIndInf := 0 // Variável para buscar os dias digitados no campo RG_DAVIND
Local nDAvCumInf := 0 // Variável para buscar os dias digitados no campo RG_DAVCUM

DEFAULT lGestPubl := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

oModel := FWModelActive()
lTemRFY := If(ValType(lTemRFY) == "L", lTemRFY, .F.)

aIncRes  := If(Type("aIncRes") == "U", {}, aIncRes)
dDatadem := If(Type("dDatadem") == "U", CtoD(""), dDatadem)
lProjav  := If(Type("lProjav") == "U", .F., lProjav)
lProj    := If(Type("lProj") == "U", .F. , lProj)

If !lTemRFY
	nDiasAv := &(ReadVar())

	If cPaisLoc <> "ARG" .AND. !(nDiasAv == 0 .And. !Empty(aIncRes) .And. aIncRes[02] == "T") .And. !Empty(dDatadem)
		dDataAv := M->RG_DTAVISO
	EndIf

	If cPaisLoc <> "ARG" .AND. !Empty(aIncRes) .And. !(aIncRes[02] $ "I/A")
		If cPaisLoc == "BRA" .and. (lProjav .or. lProj)
			If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .and.  SRG->(ColumnPos( "RG_DAVIND")) > 0

				//Tratativa para o caso do usuário digitar os dias de aviso previo manualmente na rescisão, para casos em que o trabalhador comprovou ter outro emprego.
				nDAvInf    := oModel:GetValue("GPEM040_MSRG","RG_DAVISO") // Carrega os valores digitados pelo usuário
				nDAvIndInf := oModel:GetValue("GPEM040_MSRG","RG_DAVIND") // Carrega os valores digitados pelo usuário
				nDAvCumInf := oModel:GetValue("GPEM040_MSRG","RG_DAVCUM") // Carrega os valores digitados pelo usuário
				//Fim

				nDiascum := If (nDiasAv < 30, nDiasAv, nDiascum)
				nDiaInde := nDiasAv - nDiascum
				nDiasCum := nDiasAv - nDiaInde

				//Tratativa para o caso do usuário digitar os dias de aviso previo manualmente na rescisão, para casos em que o trabalhador comprovou ter outro emprego.
				nDiasAv  := nDAvInf
				nDiascum := If(nDAvCumInf > nDAvInf, nDAvInf, nDAvCumInf)
				nDiaInde := nDAvInf - nDiascum


				M->RG_DAVIND := nDiaInde
				M->RG_DAVCUM := nDiasCum

				If !Empty(dDataAvis)
					dDatadem1:= dDataAvis + nDiasCum + nDiaInde
				EndIf

				//Calcula dias de ferias
				//Nesse caso, não existe a RFY, portanto, caso o usuário troque os dias de aviso prévio, será necessário recalcular as férias de acordo os os valores digitados pelo usuário.
				If lGestPubl .AND. cPaisLoc == "BRA" .AND. SRA->RA_REGIME == "2" .AND. FindFunction("fdFerResFP")
					fdFerResFP(.T.,dDataDem1)
				Else
					aPerFerias := {}
					fdFerRes(.T.,dDataDem1)
				EndIf
				oModel:LoadValue("GPEM040_MSRG","RG_DFERVEN", If(!lMetFalv, If(!lTempoParc, nDferven - nFaltasv, 0), nDferven / 2))
				oModel:LoadValue("GPEM040_MSRG","RG_DFERPRO", If(!lMetFalp, If(!lTempoParc, nDferave - nFaltasp, 0), nDferave / 2))
				If (SRA->RA_TPCONTR == "3" .Or. SRA->RA_CATEFD $ '107/108') .and. nDferInd > 0
					nDferInd := 2.5	// Intermitente sempre será 1 avo
				EndIf
				oModel:LoadValue("GPEM040_MSRG","RG_DFERAVI",nDferInd)
				//Fim Tratativa

			ElseIf !Empty(dDataAvis)
				dDatadem1:= dDataAvis + nDiasAv
			EndIf

			M->RG_DATADEM := dDataDem1
			oModel:LoadValue("GPEM040_MSRG","RG_DAVISO",nDiasAV)
			If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .and.  SRG->(ColumnPos( "RG_DAVIND")) > 0
				oModel:LoadValue("GPEM040_MSRG","RG_DAVCUM",nDiasCum)
				oModel:LoadValue("GPEM040_MSRG","RG_DAVIND",nDiaInde)
			Endif
			oModel:LoadValue("GPEM040_MSRG","RG_DATADEM",dDataDem1)
			oModel:LoadValue("GPEM040_MSRG","RG_DTGERAR",dDataDem1)
			oModel:LoadValue("GPEM040_MSRG","RG_DTPROAV",dDatadem1) // Atualiza a data projetada.
		Endif
	Else
		If !Empty(aIncRes) .And. aIncRes[02] == "A"
			nDiaInde := nDiasAv / 2
		Else
			nDiaInde := nDiasAv
		EndIf
		If ( cPaisLoc == 'BRA' )
			If SRG->(ColumnPos( "RG_DAVIND")) > 0
				M->RG_DAVIND := nDiaInde
			Endif
		ENdIf
	EndIf
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fValDtResc   ³ Autor ³ EquipeRH		       ³ Data ³ 07/02/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se data está correta, ou seja tem que ser maior que a ³±±
±±³          ³data de admissão. E nao pode haver qualquer tipo de transfe-   ³±±
±±³          ³cia apos a data de demissão.									 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fValDtResc()                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fValDtResc(dData)
Local lRet		:= .T.
Local nX		:=0
Local aTransf	:={}

DEFAULT dData:= M->RG_DATADEM

If !Empty(dData)

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se o Funcionario tem Transferencia                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If fTransf(@aTransf,,,,,,,.T.)
		For nX := 1 To Len( aTransf )
			If dData < aTransf[ nX , 7 ]
				lRet:= .F.
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0049), 1, 0 )	//"Existe Transferência Posterior à Data Informada"
				Return lRet
			EndIf
		Next nX
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Demissao nao Pode ser Inferior a Admissao                  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If lRet .And. dData < SRA->RA_ADMISSA
		lRet:= .F.
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0044), 1, 0 )	//"Data de Demissao nao Pode Ser Inferior a Admissao"
		Return lRet
	EndIf
EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCargaDFerias³ Autor ³ Erika Kanamori        ³ Data ³ 11/08/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Carrega dias vencidos e proporcionais de ferias do cabecalho da³±±
±±³          ³rescisao                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fCargaDFerias()                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fCargaDFerias()

fVAC_RESM2()

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fVAC_RESM2   ³ Autor ³ EquipeRH		       ³ Data ³ 11/08/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina copia funão fCargaDFerias 30/11/11 (ver historico TFS)  ³±±
±±³          ³Realiza carga dias vencidos e proporcionais de ferias no       ³±±
±±³          ³cabecalho rescisao, para paises Modelo 2 e diferente Argentina.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fCargaDFerias()                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fVAC_RESM2(nDiasVacV, nOpc)
Local oModel	:= FWModelActive()
Local oModelSRG	:= Nil
Local nOperation:= oModel:GetOperation()
Local oViewSRG	:= FWViewActive()
Local aPerFerias:= {}
Local nDFerVen	:= 0
Local nDFerAVe	:= 0
Local nDFerPag	:= 0
Local nDFerDir	:= 0
Local nDFerPagV	:= 0
Local x			:= 0
Local nAno		:= 0
Local nDiasFer	:= 0
Local nDiasProp	:= 0
Local lRet		:= 	.T.

Default nDiasVacV 	:= 0
Default nOpc		:= 0

If Type("cModel") == "C" .AND. ! Empty(cModel)
	oModelSRG	:= oModel:GetModel(cModel)
Else
	oModelSRG	:= oModel:GetModel('GPEM040_MSRG')
EndIf


If (nOperation == MODEL_OPERATION_INSERT .Or. (nOperation == MODEL_OPERATION_UPDATE) )

	If lRet
		If cPaisLoc =='CHI' // carga Vacaciones progresivas
			nVacProgre:= Gp042VacProg()
			If nVacProgre > 0
				oModelSRG:LoadValue('RG_DFERPRG', nVacProgre )
			Else
				oModelSRG:LoadValue('RG_DFERPRG', 0 )
			EndIf
		Endif
		CargaFerias(@aPerFerias, Iif(nOpc==1,SRA->RA_DEMISSA,M->RG_DATADEM))

		If Len(aPerFerias)> 0

			If cPaisLoc # 'ARG'
		        //A seguir trecho recuperado da data 30/11/11, para tratamento de modelo 2
		        //Tomar cuidado neste chamado, pois a mesma só está preparada para os paises COS|DOM
		        //Na rotina CargaFerias esta detalhado o que é avaliado para cada pais
				Aeval(aPerFerias,{|x| (nDFerVen += x[5], nDFerAVe += x[4], nDFerPag += x[7])})

					//desconta dias pagos
				If cPaisLoc <> "CHI"
					If nDFerVen > nDFerPag
						nDFerVen:= nDFerVen - nDFerPag
					Else
						nDFerVen:= 0
						nDFerPag:= nDFerPag - nDFerVen
						nDFerAVe:= Max(nDFerAVe - nDFerPag, 0)
					Endif
				Else
					nDFerVen := Gp042VacProg(.T.)
				EndIF

				If cPaisLoc =='CHI'
					// carga Vacaciones Proporcionales CHILE
					oModelSRG:LoadValue('RG_DFERVEN', nDFerVen )
					nVacProp:= Gp042VaPc()
					oModelSRG:LoadValue('RG_DFERPRO', nVacProp )
				Else
					oModelSRG:LoadValue('RG_DFERVEN', nDFerVen )
					If  nOpc != 1
						oModelSRG:LoadValue('RG_DFERPRO', nDFerAVe )
					Endif
				EndIf
			Else
				//Tratamento especifico para Argentina

				nAno := year(M->RG_DATADEM)
				//Aqui preninimos qdo ano de admissao e demissao iguais, e admissao maior que 01/01/ANO
				dDataIni:= Iif(nAno == year(SRA->RA_ADMISSA),SRA->RA_ADMISSA,CTOD("01/01/"+STR(nAno)))
				fDiasFerArg(.T.,dDataIni,M->RG_DATADEM,@nDiasFer,@nDiasProp, .T.)

				For x:=1 To Len(aPerferias)
					//Tratamento para anoCivil colocar o If do parame
					If nAno == Year(aPerFerias[x,1]) .And. nAno == Year(aPerFerias[x,2])
						//Ferias proporcionais
						//com o mesmo periodo de RG_PERIODO - periodo SRF_VIGENTE
						nDFerPagV	+= aPerferias[x,7]	//RF_DFERANT = Ferias Pagas
					ElseIf (Year(aPerFerias[x,1]) < nAno  .And. Year(aPerFerias[x,2]) < nAno)
						nDFerDir	+= aPerferias[x,3]	//RF_DIASDIR = Dias de Direito
						nDFerPag	+= aPerferias[x,7]	//RF_DFERANT = Ferias Pagas
					EndIf
				Next x

				//Ferias Proporcionais do periodo vigente
				nDFerAve	:= nDiasProp - nDFerPagV

				//Ferias Nao gozadas
				//Se nDFerAve for negativo, entrará na conta a seguir, caso contrario não
				nDFerVen    := ((Iif (nDFerAve>0, 0, nDFerAve) )  + nDFerDir ) - nDFerPag

				oModelSRG:LoadValue('RG_DFERVEN', Iif (nDFerVen > 0 ,nDFerVen, 0) )
				oModelSRG:LoadValue('RG_DFERPRO', Iif (nDFerAVe > 0, nDFerAVe, 0) )
			EndIf
		Else
			oModelSRG:LoadValue('RG_DFERVEN', 0)
			If  nOpc != 1
				oModelSRG:LoadValue('RG_DFERPRO', 0)
			Endif
		EndIf

		//Roteiro e Periodo irei limpar, para que os mesmos sejam preenchidos adequadamente
		If cPaisLoc == "BRA"
			oModelSRG:LoadValue('RG_ROTEIR', '')
			oModelSRG:LoadValue('RG_PERIODO', '')
		EndIf

		If oViewSRG != Nil .And. oViewSRG:lActivate .And. cPaisLoc !='CHI'
			oViewSRG:Refresh()
	EndIf
EndIf
EndIf

If  nOpc == 1
	nDiasVacV := nDFerVen
Endif

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fSRGWhen     ³ Autor ³ Leandro Drumond       ³ Data ³ 12/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³When dos campos da SRG										 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fSRGWhen()                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fSRGWhen(cCampo)
Local lRet := .F.

DEFAULT lGestPubl := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

If cCampo == "RG_EFETIVA"
	lRet := .T.
ElseIf lAtuSimul //Se for efetivacao da simulacao, nao permite o preechimento de nenhum outro campo
	lRet := .F.
ElseIf cCampo $ "RG_DATAHOM*RG_MEDATU*RA_FECREI*RA_BLOQADM"
	lRet := .T.
ElseIf cCampo == "RG_SABDOM" .And. !Empty(dDataDem) .And. !lTemRFY
	lRet := .F.
ElseIf lGestPubl .AND. cModulo $ 'GFP*VDF' .AND. cCampo == "RG_NOVSUBS"
	lRet := .T.
ElseIf cCompl == "S"
	If lRescRRA .and. cCampo == "RG_IDCMPL"
		lRet := .T.
	ElseIf cCampo == "RG_DTGERAR" .or. ( cCampo == "RG_DATADEM" .and. lModDataDem ) .or. ( cCampo == "RG_DATADEM" .and. Empty(SRG->RG_DATADEM) )
		lRet := .T.
	ElseIf lIndAv .And. cCampo $ "RG_INDAV"
        lRet := .T.
	EndIf
ElseIf cCampo == "RG_DTGERAR" .And. cCompl <> "S" .And. !lRecRes //se não for complementar e nem recálculo
    lRet := .T.
Elseif cCampo == "RG_OBITO"
	lRet := fObitoWhen()
Elseif cCampo == "RG_CONFIC"
	lRet := .F.
ElseIf cCampo $ "RG_TPREMAD*RG_DTQUAR"
	lRet := .T.
Else

	If lRescRRA .and. cCampo == "RG_IDCMPL"
		lRet := .T.
	ElseIf 	(  (( cPaisLoc != 'BRA' ) .And. cCampo $ "RG_TIPORES*RG_DATADEM*RG_DTAVISO*RG_DAVISO*RG_SABDOM*RG_JTCUMPR*RG_COMPRAV*RG_DESCTPR*RG_NPROC*RG_OBITO*RG_SUCES*RG_OBS*RG_TPSU")     ;
	           .or. ;
	           (( cPaisLoc == 'BRA' ) .And. cCampo $ "RG_TIPORES*RG_DATADEM*RG_DTAVISO*RG_DAVISO*RG_SABDOM*RG_JTCUMPR*RG_COMPRAV*RG_DESCTPR*RG_NPROC*RG_OBITO*RG_SUCES*RG_OBS*RG_DAVCUM*RG_DAVIND*RG_NPROCS*RG_TPSU")  ;
	        )


		If lTemRFY .and. cCampo $ "RG_DTAVISO*RG_DAVISO"
			If lDtDemRFY
				lRet := .T.
				If cCampo == "RG_DTAVISO"
					lDtDemRFY := .T.
				EndIf
			Else
				lRet := .F.
			EndIf
		ElseIf cCampo $ "RG_DAVCUM*RG_DAVIND" .and. Empty(dDataDem)
			lRet := .F.
		Else
			lRet := .T.
		EndIf
	ElseIf cCampo $ "RG_NORMAL*RG_DESCANS"
		lRet := .T.
	ElseIf lIndAv .And. cCampo $ "RG_INDAV"
    	lRet := .T.
	ElseIf cCampo == "RG_PDV"
		lRet := fHabPDV(M->RG_TIPORES, .T.)
	EndIf
EndIf

If GetSx3Cache(cCampo, "X3_PROPRI") == "U"
	lRet := .T.
EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AbreCadastro³ Autor ³Erika Kanamori		  ³ Data ³ 14/09/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Faz chamada de telas de cadastro e tratamento para calculo    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³nOpcaoTela: opcao a ser chamada                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function AbreCadastro(nOpcaoTela)
Local aArea			:= GetArea()
Local oModel      	:= FWModelActive()
Local oGrid			:= oModel:GetModel("GPEM040_MGET")

Private lResM2	:= .T. 	//flag que indica se deve ou nao mostrar o browse inicial
Private lM2Modif:= .F. //variavel para saber se houve alteracoes no cadastro
Private lAvPrevRfy	:= .F.

DEFAULT lGestPubl := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

lTempoParc	:= If( Type("LTEMPOPARC") == "U", .F., lTempoParc)
lMetFalp	:= If( Type("LMETFALP") == "U", .F., lMetFalp)
lMetFalv	:= If( Type("LMETFALV") == "U", .F., lMetFalv)

Do Case
	Case nOpcaoTela== 1 //"Lançamentos Fixos"
		GpeA550()
	Case nOpcaoTela== 2 //"Incidências por funcionário"
		 GPEA580()
	Case nOpcaoTela== 3 //"Ausências"
		GpeA240()
	Case nOpcaoTela== 4 //"Valores Futuros"
		GPEA110()
	Case nOpcaoTela== 5 //"Tempo Extra"
		Gpea640()
	Case nOpcaoTela== 6 //"Integrações"
		Gpem019()
	Case nOpcaoTela== 7 //Medias
		fVerMedia("R")
	Case nOpcaoTela== 8 //Controle dias de direito
		Gpea050(1)
	Case nOpcaoTela == 9
		fImpPonto()
	Case nOpcaoTela== 10 //Cadastro de aviso previo
		Gpea925(,,4)
EndCase

If lAvPrevRfy
	fInitModel(oModel,oModel:GetOperation())
Endif


If lM2Modif .and. !Empty(dDataDem) .And. cCompl <> "S"
	//Calcula dias de ferias
	If lGestPubl .AND. cPaisLoc == "BRA" .AND. SRA->RA_REGIME == "2" .AND. FindFunction("fdFerResFP")
		fdFerResFP(.T.)
	Else
		aPerFerias := {}
		fdFerRes(.T.)
	EndIf

	oModel:LoadValue("GPEM040_MSRG","RG_DFERVEN", If(!lMetFalv, If(!lTempoParc, nDferven - nFaltasv, 0), nDferven / 2))
	oModel:LoadValue("GPEM040_MSRG","RG_DFERPRO", If(!lMetFalp, If(!lTempoParc, nDferave - nFaltasp, 0), nDferave / 2))

	If(cPaisLoc == 'BRA')
		If (SRA->RA_TPCONTR == "3" .Or. SRA->RA_CATEFD $ '107/108') .and. nDferInd > 0
			nDferInd := 2.5	// Intermitente sempre será 1 avo
		EndIf
		oModel:LoadValue("GPEM040_MSRG","RG_DFERAVI",nDferInd)
	EndIf

	//ATUALIZA VARIAVEIS DA TELA
	M->RG_DFERVEN := If(!lMetFalv, If(!lTempoParc, nDferven - nFaltasv, 0), nDferven / 2)
	M->RG_DFERPRO := If(!lMetFalp, If(!lTempoParc, nDferave - nFaltasp, 0), nDferave / 2)

	If(cPaisLoc == 'BRA')
		M->RG_DFERAVI := nDferInd
	EndIf

	If oGrid:Length() > 1
		If( MsgNoYes(	OemToAnsi( STR0051 + CRLF + CRLF + STR0052),;//"Estas modificações só terão efeito se a rescisão for recalculada."##"Deseja recalcular agora?"
			OemToAnsi(STR0020) )) // "Atencao"
			CalResc() //Nao eh necessario validar, pois a funcao de calculo realiza a validacao do model (se houver alteracoes)
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CalResc     ³ Autor ³ Leandro Drumond       ³ Data ³ 07/01/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava as informacoes do model (para que seja possivel acessa- ³±±
±±³          ³las nas formulas), e executa o calculo de rescisao de acordo  ³±±
±±³          ³com os campos de roteiro, processo, periodo e data de pagto.  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CalResc()                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function CalResc()

Local aArea         := GetArea()
Local aPerAux		:= {}
Local aTitleLog		:= {}
Local aLog			:= {}
Local aVarAux		:= {}
Local aCposSRV		:= {'RV_INSS','RV_FGTS','RV_IR','RV_INCORP','RV_REF13','RV_REFFER'}
Local lItemClVl   	:= SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "1*3" // Define se trabalha com item e classe contabil
Local lAtuGrid		:= .F.
Local nPosLog		:= 0
Local nPos			:= 0
Local nX			:= 0
Local nElem			:= 0
Local nElem1		:= 0
Local nCount		:= 0
Local nRet			:= 0
Local nPosaPd 		:= 0
Local nPosaPdV 		:= 0
Local nValAux		:= 0
Local nHorAux		:= 0
Local nAnoCasaAux	:= 0
Local oModel      	:= FWModelActive()
Local oGrid			:= oModel:GetModel("GPEM040_MGET")
Local lBaseRRA      := .F.
Local lLocked		:= .T.
Local lConfCompl	:= SRR->(ColumnPos("RR_VALORI")) > 0
Local lSeqMv        := SRR->(ColumnPos("RR_SEQMV")) > 0
Local dBkp			:= M->RG_DATADEM
Local lLancFut 		:= .F.
Local lRet          := .T.
Local lLogProc 		:= !IsBlind() .and. SuperGetMV("MV_LOGPROC",,.F.)
Local cTipoAux		:= ""

Private lRescRet	:=  (cOpcCompl == "3")

Static lPergBenef

P_lPPEAtiv			:= If( Type("P_lPPEAtiv") == "U", .F. , P_lPPEAtiv)
dDtEst936			:= If( Type("dDtEst936") == "U", cToD("") , dDtEst936)
lPergBenef			:= .T.

DEFAULT lGestPubl   := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
DEFAULT lVNaoApl    := cPaisLoc == "BOL" .And. SRR->( ColumnPos("RR_VNAOAPL") ) > 0
DEFAULT lTribIR     := SRR->( ColumnPos( 'RR_TRIBIR' ) ) > 0
DEFAULT lConsig		:= GetMvRH("MV_CONSIG",, .F.)

SRV->(DbSetOrder(1))

//?- Verifica se o calculo esta Liberado
If !fVldAccess( cFilAnt, M->RG_DATADEM, M->RG_SEMANA, .T., fGetCalcRot("4") )
   Return( .F. )
EndIf

If lAtuSimul //Se for efetivacao da simulacao, nao permite recalculo
	Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0126), 1, 0 ) //"Atenção"##"Rescisão simulada não pode ser recalculada. Exclua e efetue um novo cálculo."
	Return(.F.)
EndIf

If Len(aSpbRec) > 0 .and. !( lLocked := ChkFile( "SPB",.F.))
	Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0172), 1, 0 ) //O Fechamento do SIGAPON está sendo executado. Tente mais tarde.
	Return( .F. )
EndIf

/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Funcao verifica se existe alguma restrição de acesso para o³
//³usuário que impeça a execução da rotina.                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If !(fValidFun({"SQB","SRJ","RCO",;
				"CTT","RGC","RCE","SR6","SR3",;
				"SR7","SRC","RGB","SRV","SRK",;
				"RCP","RG7"}))
	RestArea(aArea)
	Return(.F.)
EndIf

If lRescRRA
	If Empty(oModel:GetModel('GPEM040_MSRG'):GetValue("RG_IDCMPL"))
		If Isblind() .Or. MsgYesNo( OemToAnsi( STR0113 ) , OemToAnsi( STR0020) ) //Atenção. Identificador de complemento do RRA não foi preenchido. Não será calculado RRA. Continua?
			lRescRRA := .F.
		Else
			Return(.F.)
		EndIf
	Else
		DbSelectArea('RF1')
		If !(DbSeek(xFilial('RF1')+oModel:GetModel('GPEM040_MSRG'):GetValue("RG_IDCMPL")))
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0165), 1, 0 ) //"Atencao"##'Complemento Trabalhista informado não encontrado'  {OK}
			Return(.F.)
		EndIf
	EndIf
EndIf

If !IsBlind() .and. cCompl <> "S" .and. SRA->RA_CATFUNC $ "A*P" .and. !Empty(SRA->RA_CIC) .and. fVerMultV()
	lRet := MsgYesNo( OemToAnsi(STR0327) + OemToAnsi(STR0328), OemToAnsi(STR0020) )//"Atencao"###"Funcionário possui vínculo celetista que ainda não foi calculado, o que poderá acarretar divergências com a apuração do INSS no eSocial."###"Prosseguir com Cálculo?"
	If !lRet
		Return(.F.)
	EndIf
EndIf

If lGestPubl .AND. cModulo $ 'GFP*VDF' .AND. oModel:GetOperation() == MODEL_OPERATION_INSERT
	dDataDem1 		:= fDtRescAnt(SRA->RA_FILIAL,SRA->RA_MAT)

	If Empty(dDataDem1)
		lRet := MsgNoYes( OemToAnsi(STR0227), OemToAnsi(STR0020) ) //Não existe publicação para esta Rescisão. Deseja continuar?
		If !(cCompl == "S")
			dDataDem1	:= Iif(lRet, dDataBase, dDataDem1)
		Else
			dDataDem1	:= Iif(lRet, dDataDem, dDataDem1)
		EndIf
		If !lRet
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0218), 1, 0 ) //"Atenção, Cálculo de Rescisão cancelado pelo usuário."
		EndIf
	ElseIf Empty(aPublicacao[2])
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0223), 1, 0 ) //	"Existe Item com pendência de Publicação. Não será possível prosseguir."  ###	Atenção
		lRet		:= .F.
	ElseIf Empty(aPublicacal[3])
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0224), 1, 0 )//	"Existe Documento gerado sem data de publicação. Não será possível prosseguir." ###	Atenção
		lRet		:= .F.
	EndIf

	If lRet .AND. cAfasfgts $ 'U1*U3' .AND. Empty(oModelSRG:GetValue('RG_NOVSUBS'))
		lRet := .F.
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0225), 1, 0 )//Para Aposentadoria o Valor do Novo Subsidio deve ser Informado.
	EndIf

	If !lRet
		Return .F.
	EndIf
EndIf

Begin Sequence

    aPD  := {}
    aPDV := {}
    aPd_SRK := {}

	If !fChkDtDem(oModel:GetValue("GPEM040_MSRG","RG_DATADEM"), .T., dDataDe, dDataAte, lModDataDem, @aLogErros)
		Break
	EndIf

	cRot			:= M->RG_ROTEIR
	cPeriodo		:= M->RG_PERIODO
	cNumPag			:= M->RG_SEMANA
	lMesAtu			:= ( M->RG_MEDATU == "S" )
	cTipoRot		:= fGetTipoRot(cRot)
	oModel:LoadValue("GPEM040_MSRG","RG_PERIODO",cPeriodo)
    M->RG_DFERPRO   := oModel:GetValue("GPEM040_MSRG","RG_DFERPRO")

		/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Aviso de Demissao durante a Estabilidade do Funcionario    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !(cPaisLoc $ "DOM*EQU")
		If (! Empty(SRA->RA_DTVTEST)) .And. SRA->RA_DTVTEST >= dDataDem1
			If !IsBlind() .And. !( MsgYesNo( OemToAnsi( STR0041 ) + Dtoc(SRA->RA_DTVTEST) + ". " + OemTOAnsi(STR0042), OemToAnsi( STR0020 ) ) ) //"Atencao"###"Funcionario esta com data de Estabilidade ate: "###"Continua?"
				Break
			EndIf
		EndIf
		If !IsBlind() .And. cPaisLoc == "BRA" .And. P_lPPEAtiv .And. Date() >= cToD("09/10/2020") .And. !Empty(dDtEst936) .And. dDtEst936 >= dDataDem1
			If !( MsgYesNo( OemToAnsi( STR0290 ) + dToC(dDtEst936) + ". " + OemTOAnsi(STR0042), OemToAnsi( STR0020 ) ) ) //"Atencao"###"Funcionário está com data de estabilidade da MP 936/2020 até: "###"Continua?"
				Break
			Else
				If SRG->(ColumnPos( "RG_DTESTAB")) == 0 .Or. Len(aCodFol) < 1853 .Or. Empty(aCodFol[1853,1])
					fAlert936(1)
					Break
				Else
					fAlert936(2)
				EndIf
			EndIf
		EndIf
	EndIf

	//Integração com o GS
	If FindFunction("TecConfAlo") .AND. SuperGetMV("MV_TECXRH", NIL, .F. ) .AND. !IsBlind()
		TecConfAlo( /*oModel*/, dDataDem1 )
	EndIf

	If Empty(M->RG_DATAHOM)
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0151), 1, 0 ) //"Atenção"##"Data de Homologação não foi preenchida"
		Break
	EndIf

	If Empty(M->RG_DTAVISO)
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0167), 1, 0 ) //"Atenção"##"Data do Aviso não foi preenchida"
		Break
	EndIf

	If Empty(M->RG_TIPORES)
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0152), 1, 0 ) //"Atenção"##"Tipo de Rescisão não foi preenchido"
		Break
	EndIf

	If Empty(M->RG_DTGERAR)
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0171), 1, 0 ) //"Atenção"##"Data de Geração não foi preenchida"
		Break
	EndIf

	If cTipoRot <> "4"
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0053), 1, 0 ) //"Atenção"##"Roteiro de Cálculo diferente de Rescisão!"
		Break
	EndIf

	DbSelectArea(cTBLXMED)
	Zap

	cSvSetRot 		:= SetRotExec( cRot )
	cSvSetPer 		:= SetPeriodCalc( cPeriodo )
	cSvSetNumPago 	:= SetNumPgCalc( cNumPag )

	If cModFol == "1" .and. !(cPaisLoc $ "BRA*CHI*PAR") .and. oSrr == Nil
		oSrr := Nil
		GetSRR( @oSrr, "1 = 0" )	// Expressao de filtro para criar um objeto em branco
	EndIf

	aPerAux	:= aClone(aPerFerias)

	nAnoCasaAux := nAnosCasa
	NINCSEMID := 0
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Executa as formulas roteiro                                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

	//Memória de Cálculo
	If __lMemCalc
		fSetMemCalc()
	EndIf

	nRet := ExecRot( SRA->RA_FILIAL , cRot )

	//Memória de Cálculo
	If __lMemCalc
		fAddMemLog("",2) //grava parametros na memoria de calculo
		fGrvLogFun(cRot, cPeriodo, cNumPag,"GPEM040", aMenLog)
		aMenLog := {}
	EndIf

	nAnosCasa := nAnoCasaAux //Restaura valor do mnemonico

	aPerFerias	:= aClone(aPerAux)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Fecha o Repositorio Auxiliar                                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	RpoFormInit( NIL , .T. )

	If nRet < 0 .or. nRet == 2 //Retorna 2 quando calculo eh abortado
		cFilCalc 	:= ""
		lErrExecRot	:= .T.
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Carregando Informacoes para o Log                                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aLogInit := LogExecRot()
		For nX := 1 To Len( aLogInit )
			If !Empty(aLogInit[ nX, 2 ])
				If nX == 1
					aAdd( aTitleLog, STR0054 ) //"Erro de Carga de Mnemonicos"
				ElseIf nX == 2
					aAdd( aTitleLog, STR0055 ) //"Erro de Carga de Formulas"
				ElseIf nX == 3
				aAdd( aTitleLog, STR0056 ) //"Ocorreu erro na compilacao ou Execucao do Roteiro"
				ElseIf nX == 4
					aAdd( aTitleLog, STR0057 ) //"Erros ocasionados durante o Calculo da Rescisao"
				EndIf
				aAdd( aLog, aLogInit[nX, 2] )
			EndIf
		Next nX

		If Len( aLogErros ) > 0
			If Empty( aLog )
				aAdd( aTitleLog, STR0058 )	//"Log de Ocorrencias do Calculo de Rescisao"
				aAdd( aLog, {} )
			EndIf

			nPosLog := Len( aLog )
			For nX := 1 To Len( aLogErros )
				aAdd( aLog[ nPosLog ], aLogErros[ nX ] )
			Next nX
		EndIf

		If !Empty( aLog )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Mostrar o Log                                                          ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			MsAguarde( { || fMakeLog( aLog , aTitleLog , "GPEM040" , NIL , FunName() , STR0058 ) } ,  STR0058 ) //"Log de Ocorrencias do Calculo de Rescisao"
		EndIf
		RstExecCalc()
		Return( .F. )
	EndIf

	SetRotExec( cSvSetRot )
	SetPeriodCalc( cSvSetPer )
	SetNumPgCalc( cSvSetNumPago )

	aEval( aPd, { |x, y| If( x[16] == .T. , aAdd( aPd_SRK, {aPd[y,1], APD[y,7]} ), Nil )  }  )

	//--Transfere verbas para identificador de RRA no caso de rescisão complementar ser feita em ano diferente da rescisão original
	If lRescRRA

		//Verifica se as verbas geradas pelo roteiro existe incidência de RRA
		//para realizar a transferência de base do IR
		For nX := 1 To Len(aPd)
			If AllTrim(PosSrv(aPd[nX,1],SRA->RA_FILIAL,"RV_RRA")) == "1"
				lBaseRRA := .T.
				Exit
			EndIf
		Next nX

		If lBaseRRA

			//Trasnfere Base de IR para Base IR RRA
			If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[974,1] .and. x[9] # "D" }) ) > 0
				If (nP := aScan(aPd,{ |x| x[1] == aCodFol[015,1] .and. x[9] # "D" }) ) > 0
					aPd[nPos,5] := aPd[nP,05]
					aPd[nP,9] := "D"
					//Transfere IR para codigo de IR RRA
					If (nP := aScan(aPd,{ |x| x[1] == aCodFol[066,1] .and. x[9] # "D" }) ) > 0
						If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[978,1] .and. x[9] # "D" }) ) > 0
							aPd[nPos,5] := aPd[nP,5]
							aPd[nP,9] := "D"
						Else
							aPd[nP,1] := aCodFol[978,1]
						EndIf
					EndIf
					//Apaga base IRRF de Ferias, pois valor foi incorporado a Base IR RRA
					If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[016,1] .and. x[9] # "D" }) ) > 0
						aPd[nPos,9] := "D"
					EndIf
					//Apaga IRRF de Ferias, pois valor foi incorporado ao IR RRA
					If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[067,1] .and. x[9] # "D" }) ) > 0
						aPd[nPos,9] := "D"
				EndIf
				EndIf
			ElseIf ( nPos := aScan(aPd,{ |x| ( x[1] == aCodFol[015,1] .or. x[1] == aCodFol[016,1] ) .and. x[9] # "D" }) ) > 0
				aPd[nPos,1] := aCodFol[974,1]
				If ( nPos := aScan(aPd,{ |x| ( x[1] == aCodFol[066,1] .or. x[1] == aCodFol[067,1] ) .and. x[9] # "D" }) ) > 0
					aPd[nPos,1] := aCodFol[978,1]
				EndIf
			EndIf
			//Trasnfere base de IR 13o para Base IR 13o RRA
			If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[979,1] .and. x[9] # "D" }) ) > 0
				If (nP := aScan(aPd,{ |x| x[1] == aCodFol[027,1] .and. x[9] # "D" }) ) > 0
					aPd[nPos,5] := aPd[nP,05]
					aPd[nP,9] := "D"
					//Transfere IR 13o para codigo de IR 13o RRA
					If (nP := aScan(aPd,{ |x| x[1] == aCodFol[071,1] .and. x[9] # "D" }) ) > 0
						If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[983,1] .and. x[9] # "D" }) ) > 0
							aPd[nPos,5] := aPd[nP,5]
							aPd[nP,9] := "D"
						Else
							aPd[nP,1] := aCodFol[983,1]
						EndIf
				EndIf
				EndIf
			ElseIf ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[027,1] .and. x[9] # "D" }) ) > 0
				aPd[nPos,1] := aCodFol[979,1]
				If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[071,1] .and. x[9] # "D" }) ) > 0
					aPd[nPos,1] := aCodFol[983,1]
				EndIf
			EndIf
		EndIf
	EndIf

	If cPaisLoc == "BRA" .And. !Empty(aCodFol[1904, 1]) .And. aScan(aPd, { |x| x[1] == aCodFol[247, 1] .And. x[9] != "D" } ) > 0 .And. (nBaseAt + nBaseAc) < (nBAtLim + nBAcLim)
		nVal1904 := ( (nBAtLim + nBAcLim) - (nBaseAt + nBaseAc) )
	EndIf

	If cModFol == "1"
		If cPaisLoc $ "BRA*CHI*PAR"
				
			If fResValidApd(@aPd) > 0	
			
				nElem  := Len(aPd)
				aPdRAW := aClone(aPd) //Copia valores gerados na rescisão

				For nCount = 1 To nElem

					lLancFut := aPd[nCount,7] == "G" .And. "SRK" $ aPd[nCount,15]

					If ( Round(aPd[nCount,5],2) = 0.00 .And. ( !(aPd[nCount,7] $ "I*E*G") .or. lRescPLR)) .Or. aPd[nCount,9] == "D"
						Loop
					EndIf

					If !(cPaisLoc == "BRA") .And. ( nPos := aScan( aVarAux, {|x| x[1] == aPd[nCount,1] .And. x[2] == aPd[nCount,2] .And. x[3] == aPd[nCount,3] .And. x[4] == aPd[nCount,11] .and. aPd[nCount,7] == "I"} )) > 0
						nElem1	:= nPos
						lAtuGrid:= .T.
					ElseIf cPaisLoc == "BRA" .And. ( nPos := aScan( aVarAux, {|x| x[1] == aPd[nCount,1] .And. x[2] == aPd[nCount,2] .And. x[3] == aPd[nCount,3]  .And. x[5] == aPd[nCount,7] .And. x[6] == aPd[nCount,13] .And. x[7] == aPd[nCount,14]  .And. (aPd[nCount,7] $ "I*E*G") } )) > 0
						nElem1	:= nPos
						lAtuGrid:= .T.
					Else
						nElem1++
						aAdd(aVarAux,{aPd[nCount,1],aPd[nCount,2],aPd[nCount,3],aPd[nCount,11],aPd[nCount,7],aPd[nCount,13], aPd[nCount,14]})
						lAtuGrid:= .F.
					Endif

					If nElem1 > oGrid:Length()
						oGrid:AddLine(.T.)
					EndIf

					oGrid:GoLine(nElem1)

					If lAtuGrid
						nValAux := oGrid:GetValue("RR_VALOR") + aPd[nCount,05]
						nHorAux := oGrid:GetValue("RR_HORAS") + aPd[nCount,04]
					Else
						nValAux := aPd[nCount,05]
						nHorAux := aPd[nCount,04]
					EndIf

					oGrid:LoadValue("RR_FILIAL"	,SRA->RA_FILIAL)
					oGrid:LoadValue("RR_MAT"	,SRA->RA_MAT)
					oGrid:LoadValue("RR_PD"		,aPd[nCount,01])
					oGrid:LoadValue("RR_DESCPD"	,DescPd( aPd[nCount,01] ))
					oGrid:LoadValue("RR_VALOR"	,Round(nValAux,2))
					oGrid:LoadValue("RR_HORAS"	,nHorAux)
					oGrid:LoadValue("RR_TIPO1"	,aPd[nCount,06])
					oGrid:LoadValue("RR_TIPO2"	,If(aPd[nCount,07]=="C","R",aPd[nCount,07]))
					oGrid:LoadValue("RR_DATA"	,oModel:GetModel('GPEM040_MSRG'):GetValue("RG_DTGERAR"))
					oGrid:LoadValue("RR_DATAPAG",Iif(Empty(aPd[nCount,10]) .Or. aPd[nCount,07] $ "C/E/G/I" .Or. aCodFol[007, 01] == aPd[nCount, 1] .Or. ( ( nPosaPdV := aScan( aPdv, { |x| x[3] == aPd[nCount, 1] } ) ) > 0 .And. ( nPosaPd := aScan( aPd, { |x| x[1] == aPdv[nPosaPdv, 1] .And. x[9] != "D" } ) ) > 0 .And. aPd[nPosaPd, 7] $ "C/E/G/I" ), oModel:GetModel('GPEM040_MSRG'):GetValue("RG_DATAHOM"), aPd[nCount,10]))
					oGrid:LoadValue("RR_CC"		,aPD[nCount,02])
					oGrid:LoadValue("RR_PROCES"	,SRA->RA_PROCES)
					oGrid:LoadValue("RR_PERIODO",oModel:GetModel('GPEM040_MSRG'):GetValue("RG_PERIODO"))
					oGrid:LoadValue("RR_ROTEIR"	,cRot)
					oGrid:LoadValue("RR_SEMANA"	,cNumPag)
					oGrid:LoadValue("RR_TIPO3"	,"R")
					oGrid:LoadValue("RR_SEQ"	,aPd[nCount,11])
					oGrid:LoadValue("RR_VALORBA",aPd[nCount,20])
					oGrid:LoadValue("RR_CODB1T"	,aPd[nCount,21])
					If !lLancFut
						oGrid:LoadValue("RR_NUMID"	,aPd[nCount,15])
					EndIf
					If(SRV->(DbSeek(xFilial('SRV') + oGrid:GetValue('RR_PD'))))
						aEval(aCposSRV,{|x|oGrid:LoadValue("RR" + SubStr( x, At('_',x)),SRV->(&(x)))})
					EndIf
					If lItemClVl
						oGrid:LoadValue("RR_ITEM"	,If(!Empty(aPd[nCount,13]), aPd[nCount,13], SRA->RA_ITEM))
						oGrid:LoadValue("RR_CLVL"	,If(!Empty(aPd[nCount,14]), aPd[nCount,14], SRA->RA_CLVL))
					EndIf
					If cPaisLoc == "BRA"
						oGrid:LoadValue("RR_IDCMPL", aPd[nCount,17])
					EndIf	
					oGrid:LoadValue("RR_DTREF",If( aPd[nCount,07] $ "I*E*G", CtoD("//"), aPd[nCount,18])) //Se for a verba de base salarial, não grava a soma das anteriores
					If cCompl == "S" .and. lConfCompl .and. lProxMes .and. aPd[nCount,1] <> aCodFol[318,1] //Não grava quando a complementar é no mesmo mês
						nValAux := 0
						cTipoAux := If(aPd[nCount,07]=="C","R",aPd[nCount,07])
						aEval(aPdResc,{ |X| nValAux += If( x[1]+x[2] == aPd[nCount,1] + aPd[nCount,2] .and. x[9]<>'D' .and. AllTrim(x[15]) == AllTrim(aPd[nCount,15]) .and. cTipoAux == x[7] ,x[5] ,0) })
						If nValAux > 0
							oGrid:LoadValue("RR_VALORI"	,Round(nValAux,2))
						EndIf
					EndIf
					If lSeqMv
						oGrid:LoadValue("RR_SEQMV"	,cSeqMV)
					EndIf
                    If lTribIR
                        oGrid:LoadValue("RR_TRIBIR"	, aPd[nCount, 28])
                    EndIf
				Next
			EndIf
		Else
			fo_GoTop( @oSrr )

			nElem1 := 0

			For nX := 1 To Len( oSrr:aCols )
				If !fo_Deleted( @oSrr, nX )

					nElem1++

					If nElem1 > oGrid:Length()
						oGrid:AddLine(.T.)
					EndIf

					oGrid:GoLine(nElem1)

					oGrid:LoadValue("RR_FILIAL"	,SRA->RA_FILIAL)
					oGrid:LoadValue("RR_MAT"	,SRA->RA_MAT)
					oGrid:LoadValue("RR_PD"		,fo_GetVal( @oSrr, "RR_PD", nX ))
					oGrid:LoadValue("RR_DESCPD"	,DescPd( fo_GetVal( @oSrr, "RR_PD", nX ) ))
					oGrid:LoadValue("RR_VALOR"	,fo_GetVal( @oSrr, "RR_VALOR", nX ))
					If lVNaoApl
						oGrid:LoadValue("RR_VNAOAPL"	,fo_GetVal( @oSrr, "RR_VNAOAPL", nX ))
					EndIf
					oGrid:LoadValue("RR_HORAS"	,If( fo_GetVal( @oSrr, "RR_TIPO1", nX )=="H", fConvHoras( fo_GetVal( @oSrr, "RR_HORAS", nX ),"1"), fo_GetVal( @oSrr, "RR_HORAS", nX )))
					oGrid:LoadValue("RR_TIPO1"	,fo_GetVal( @oSrr, "RR_TIPO1", nX ))
					oGrid:LoadValue("RR_TIPO2"	,fo_GetVal( @oSrr, "RR_TIPO2", nX ))
					oGrid:LoadValue("RR_DATA"	,oModel:GetModel('GPEM040_MSRG'):GetValue("RG_DTGERAR"))
					oGrid:LoadValue("RR_DATAPAG",oModel:GetModel('GPEM040_MSRG'):GetValue("RG_DATAHOM"))
					oGrid:LoadValue("RR_CC"		,fo_GetVal( @oSrr, "RR_CC", nX ))
					oGrid:LoadValue("RR_PROCES"	,SRA->RA_PROCES)
					oGrid:LoadValue("RR_PERIODO",oModel:GetModel('GPEM040_MSRG'):GetValue("RG_PERIODO"))
					oGrid:LoadValue("RR_ROTEIR"	,cRot)
					oGrid:LoadValue("RR_SEMANA"	,cNumPag)
					oGrid:LoadValue("RR_TIPO3"	,"R")
					oGrid:LoadValue("RR_SEQ"	,fo_GetVal( @oSrr, "RR_SEQ", nX ))
					oGrid:LoadValue("RR_VALORBA",fo_GetVal( @oSrr, "RR_VALORBA", nX ))
					oGrid:LoadValue("RR_CODB1T"	,fo_GetVal( @oSrr, "RR_CODB1T", nX ))
					oGrid:LoadValue("RR_NUMID"	,fo_GetVal( @oSrr, "RR_NUMID", nX ))
					If(SRV->(DbSeek(xFilial('SRV') + oGrid:GetValue('RR_PD'))))
						aEval(aCposSRV,{|x|oGrid:LoadValue("RR" + SubStr( x, At('_',x)),SRV->(&(x)))})
					EndIf
					If lItemClVl
						oGrid:LoadValue("RR_ITEM"	,SRA->RA_ITEM)
						oGrid:LoadValue("RR_CLVL"	,SRA->RA_CLVL)
					EndIf
				EndIf
			Next nX
		EndIf
	Else
		nElem := Len(aPd)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ CONTA OS ELEMENTOS VALIDOS PARA MONTAR O NOVO aCols        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nElem1 := 0
		aEval(aPd,{ |X| nElem1 += If( Round(x[5],2) = 0.00 .Or. X[9]=="D" ,0 ,1) })

		If nElem1 > 0

			aSort( aPD ,,, { |x,y| x[1] + x[11] < y[1] + y[11] } )

			nElem1 := 0

			For nCount = 1 To nElem
				If Round(aPd[nCount,5],2) = 0.00 .Or. aPd[nCount,9] == "D"
					Loop
				EndIf

				nElem1++

				If nElem1 > oGrid:Length()
					oGrid:AddLine(.T.)
				EndIf

				oGrid:GoLine(nElem1)

				oGrid:LoadValue("RC_FILIAL"	,SRA->RA_FILIAL)
				oGrid:LoadValue("RC_MAT"	,SRA->RA_MAT)
				oGrid:LoadValue("RC_PD"		,aPd[nCount,01])
				oGrid:LoadValue("RC_DESCPD"	,DescPd( aPd[nCount,01] ))
				oGrid:LoadValue("RC_VALOR"	,Round(aPd[nCount,05],2))
				oGrid:LoadValue("RC_HORAS"	,aPd[nCount,04])
				oGrid:LoadValue("RC_TIPO1"	,aPd[nCount,06])
				oGrid:LoadValue("RC_TIPO2"	,If(aPd[nCount,07]=="C","R",aPd[nCount,07]))

				If (cPaisLoc $ "ARG*CHI*COL*COS*DOM*MEX")
					oGrid:LoadValue("RC_DATA"	,oModel:GetModel('GPEM040_MSRG'):GetValue("RG_DTPAGO"))
					oGrid:LoadValue("RC_DTREF"  ,oModel:GetModel('GPEM040_MSRG'):GetValue("RG_DTPAGO"))
				EndIf

				oGrid:LoadValue("RC_CC"		,aPd[nCount,02])
				oGrid:LoadValue("RC_PROCES"	,SRA->RA_PROCES)
				oGrid:LoadValue("RC_PERIODO",oModel:GetModel('GPEM040_MSRG'):GetValue("RG_PERIODO"))
				oGrid:LoadValue("RC_ROTEIR"	,cRot)
				oGrid:LoadValue("RC_SEMANA"	,cNumPag)
				oGrid:LoadValue("RC_SEQ"	,aPd[nCount,11])
				oGrid:LoadValue("RC_VALORBA",aPd[nCount,20])
				oGrid:LoadValue("RC_CODB1T"	,aPd[nCount,21])
				oGrid:LoadValue("RC_NUMID"	,aPd[nCount,15])
				If(SRV->(DbSeek(xFilial('SRV') + oGrid:GetValue('RR_PD'))))
					aEval(aCposSRV,{|x|oGrid:LoadValue("RR" + SubStr( x, At('_',x)),SRV->(&(x)))})
				EndIf
				If lItemClVl
					oGrid:LoadValue("RC_ITEM"	,If(!Empty(aPd[nCount,13]), aPd[nCount,13], SRA->RA_ITEM))
					oGrid:LoadValue("RC_CLVL"	,If(!Empty(aPd[nCount,14]), aPd[nCount,14], SRA->RA_CLVL))
				EndIf
			Next nCount
		EndIf
	EndIf

	//Zera grid
	If nElem1 > 1 .and. oGrid:Length() > nElem1
		oModel:GetModel( "GPEM040_MGET" ):SetNoDeleteLine(.F.) //--Altera model para permitir excluir as linhas do calculo anterior
		For nX := nElem1+1 to oGrid:Length()
			oGrid:GoLine(nX)
			oGrid:DeleteLine()
		Next nX
		oModel:GetModel( "GPEM040_MGET" ):SetNoDeleteLine(.T.) //--Retorna bloqueio de exclusão de linha
	ElseIf nElem1 > 1
		For nX := 1 to nElem1
			oGrid:GoLine(nX)
			oGrid:UnDeleteLine()
		Next nX
	EndIf

	oGrid:GoLine(1) //Posiciona na primeira linha

	//grava historico de médias
	cIdHistMed := fHistMed(oModel:GetModel('GPEM040_MSRG'):GetValue("RG_DTGERAR"))

End Sequence

If lLogProc .and. MsgYesNo(OemToAnsi(STR0313), OemToAnsi(STR0020))//"O parâmetro MV_LOGPROC esta ativo. Deseja consultar os parâmetros utilizados no cálculo? "### Atenção.
	aAdd( aTitleLog, OemToAnsi(STR0314) )	// "Log de Execução do Cálculo de Rescisão"
	aAdd(aLog, {""})
	MsAguarde( { || fMakeLog( aLog , aTitleLog , "" , NIL , FunName() , OemToAnsi(STR0314) ) } ,  OemToAnsi(STR0314) ) //"Log de Execução do Cálculo de Rescisão"
EndIf

RestArea(aArea)

nSalaMed	:= Salario
nSMesMed	:= SalMes
nSDiaMed	:= SalDia
nSHorMed	:= SalHora
dDataDem	:= dBkp

RstExecCalc() //Restaurar as Static apos o calculo
RstGpexIni()
RestXCIMP()

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fAplicaRes  ³ Autor ³ Erika Kanamori        ³ Data ³ 18/08/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao de validacao de aplicacao e reversao de aplicacao de   ³±±
±±³          ³rescisao.                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³nTipoApl: 1 para aplicacao; 2 para reversao de aplicacao.     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fAplicaRes(nTipoApl)
Local oModel        := FWModelActive()
Local oModelSRG    	:= oModel:GetModel("GPEM040_MSRG")
Local nOperation	:= oModel:GetOperation()
Local cRoteiro		:= ""
Local cPeriodo		:= ""
Local cNumPago		:= ""
Local lRet			:= .T.
Local nAux2			:= 0
Local dDtFech  		:= CTOD("//")

/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Soh faz aplicacao se tiver rescisao calculada e sem        ³
//³alteracoes a confirmar 								      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If nOperation == MODEL_OPERATION_INSERT
	lRet:= .F.
Else
   	If nOperation != MODEL_OPERATION_VIEW
		If Len(oModelSRG:aDataModel) > 0
			For nAux2 := 1 To Len(oModelSRG:aDataModel[1])
				If oModel:IsFieldUpdated("GPEM040_MSRG", oModelSRG:aDataModel[1][nAux2][1])
					lRet:= .F.
					Exit
				EndIf
			Next
		EndIf
	Else
		lRet:= .F.
	EndIf
EndIf

If lRet
	If nTipoApl == 1
		cRoteiro:= M->RG_ROTEIR
		cPeriodo:= M->RG_PERIODO
		cNumPago:= M->RG_SEMANA
	Else
		cRoteiro:= M->RG_APLROT
		cPeriodo:= M->RG_APLPER
		cNumPago:= M->RG_APLNPG
		If Empty(cRoteiro) .Or. Empty(cPeriodo)
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0059) , 1, 0 )//"Atenção"##"Nao é possivel reverter a aplicaçao de rescisao pois a aplicação ainda não foi executada."
			Return(.F.)
		EndIf

		//Verifica se o periodo do roteiro de aplicacao esta fechado
		dDtFech := Posicione("RCH", 4, xFilial("RCH",SRA->RA_FILIAL)+SRA->RA_PROCES+cRoteiro+cPeriodo+cNumPago, "RCH_DTFECH")
		If !Empty(dDtFech)
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0060) , 1, 0 )//"Atenção"##"Nao é possivel reverter a aplicaçao de rescisao pois o periodo ja esta fechado."
			Return(.F.)
		EndIf
	EndIf

	If !Gpm042Apl( nTipoApl, cRoteiro, cPeriodo , cNumPago )
		lRet:= .F.
	EndIf
Else
	If nOperation == MODEL_OPERATION_VIEW
   		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0061) , 1, 0 )//"Atenção"##"Execute esse processo em modo de alteracao."
	Else
		If nTipoApl == 1
	   		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0062) , 1, 0 )//"Atenção"##"É necessario confirmar as informacoes do formulario antes de realizar a operação de aplicação de rescisão."
	   	Else
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0063) , 1, 0 )//"Atenção"##"É necessario confirmar as informacoes do formulario antes de realizar a operação de reversão de aplicação de rescisão."
EndIf
	EndIf
EndIf

Return(lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpm042Apl   ³ Autor ³ Erika Kanamori        ³ Data ³ 19/08/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao de aplicacao e reversao de aplicacao de rescisao.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³nTipo		: 1- Aplicacao, 2- Reversao de aplicacao            ³±±
±±³          ³cRoteir	: Roteiro de calculo                                ³±±
±±³          ³cPer 		: Periodo de calculo                                ³±±
±±³          ³cNPgto	: Numero de pagamento                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function Gpm042Apl( nTipo, cRoteir, cPer, cNPgto)

Local aPerAtual	  := {}

Local bSet15	  := { || lRet := .T., oDlg:End() }
Local bSet24	  := { || lRet := .F., oDlg:End() }
Local bDialogInit := {}

Local cTitle
Local cTipoRot 	  := fGetTipoRot( cRoteir )
Local cRotDesc
Local cSvRoteir   := cRoteir
Local cSvPer	  := cPer
Local cSvNPgto	  := cNPgto

Local lRet 		  := .t.

Local nNextRecno  := 0
Local nRecno 	  := 0
Local nOrder 	  := 0

Local oDlg

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

Local aAdv1Size		:= {}
Local aInfo1AdvSize	:= {}
Local aObj1Size		:= {}
Local aObj1Coords 	:= {}

Local aAdv2Size		:= {}
Local aInfo2AdvSize	:= {}
Local aObj2Size		:= {}
Local aObj2Coords 	:= {}

Local oModel      	:= FWModelActive()
Local oModelSRG		:= oModel:GetModel('GPEM040_MSRG')

Local cFil			:= SRA->RA_FILIAL
Local cMat			:= SRA->RA_MAT

DEFAULT nTipo 	  := 0
DEFAULT cRoteir	  := ""
DEFAULT cPer 	  := ""
DEFAULT cNPgto	  := ""

If (nTipo == 1 .and. cTipoRot <> "4") .Or. (nTipo == 2 .and. cTipoRot <> "A")
	Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0081) , 1, 0 )//"Atenção"##Tipo de Roteiro Diferente do Solicitado!
	Return( .F. )
Else

	If nTipo == 1
		cRoteir := fGetCalcRot('A')	// Aplicacao de Finiquito
	ElseIf nTipo == 2
		cRoteir := fGetCalcRot('4')	// Reversao de Aplicacao de Rescisao
	EndIf

	lRet := fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, cRoteir ) // Busca o periodo aberto para trabalho
	If lRet
		cPer		:= aPerAtual[1,1]
		cNPgto 		:= aPerAtual[1,2]
	Else
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0082) , 1, 0 )//"Atenção"##"Periodo nao cadastrado para o Roteiro selecionado!"
		Return( lRet )
	EndIf
	If nTipo == 1 .and. cTipoRot == "4"
		cTitle := OemToAnsi(STR0083) // "Aplicacao de Rescisao"
	Else
		cTitle := OemToAnsi(STR0084) // "Reversao da Aplicacao de Rescisao"
	EndIf
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Define o Bloco para a Inicializacao do Dialog            	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
bDialogInit		:= { ||;
							CursorWait()													,;
							EnchoiceBar( oDlg , bSet15 , bSet24, NIL  )						,;
							CursorArrow()												 	 ;
				   }

aAdvSize        := MsAdvSize( ,.T.,370)

aInfoAdvSize    := { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 040 , 000 , .T. , .T. } )
aAdd( aObjCoords , { 060 , 000 , .T. , .T. } )
aObjSize    := MsObjSize( aInfoAdvSize , aObjCoords, .T., .T. )

aAdv1Size    := aClone(aObjSize[1])

aInfo1AdvSize    := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 5 , 5 }
aAdd( aObj1Coords , { 000 , 020 , .T. , .F. } )
aAdd( aObj1Coords , { 000 , 020 , .T. , .F. } )
aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
aObj1Size := MsObjSize( aInfo1AdvSize , aObj1Coords )

aAdv2Size    := aClone(aObjSize[2])

aInfo2AdvSize    := { aAdv2Size[2] , aAdv2Size[1] , aAdv2Size[4] , aAdv2Size[3] , 5 , 5 }
aAdd( aObj2Coords , { 000 , 020 , .T. , .F. } )
aAdd( aObj2Coords , { 000 , 020 , .T. , .F. } )
aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
aObj2Size := MsObjSize( aInfo2AdvSize , aObj2Coords )

DEFINE MSDIALOG oDlg TITLE cTitle FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME PIXEL
	oDlg:lEscClose := .F. // Nao permite sair ao se pressionar a tecla ESC.

	If ExistCpo("SRY", cRoteir)
		cRotDesc := Posicione("SRY",1,xFilial("SRY")+cRoteir, "RY_DESC")
	EndIf


	@ aObj1Size[1,1]	, aObj1Size[1,2] 		SAY   OemToAnsi(STR0085) SIZE 033,007 OF oDlg PIXEL	//"Periodo: "
	@ aObj1Size[1,1]	, aObj1Size[1,2]+55 	MSGET cPer SIZE 040,007	OF oDlg PIXEL WHEN .F.

	@ aObj1Size[2,1]	, aObj1Size[2,2] 		SAY   OemToAnsi(STR0086) SIZE 038,007 OF oDlg PIXEL	//"Nro Pagto: "
	@ aObj1Size[2,1]	, aObj1Size[2,2]+55 	MSGET cNPgto SIZE 040,007	OF oDlg PIXEL WHEN .F.

	@ aObj1Size[3,1]	, aObj1Size[3,2] 		SAY OemToAnsi(STR0087) SIZE 033,007 OF oDlg PIXEL	//"Roteiro: "
	@ aObj2Size[3,1]	, aObj2Size[3,2] 		SAY OemToAnsi(STR0088) SIZE 033,007 OF oDlg PIXEL	//"Descricao: "
	@ aObj1Size[3,1]	, aObj1Size[3,2]+55 	MSGET cRoteir  SIZE 040,007	OF oDlg PIXEL WHEN .F. PICTURE PesqPict("SRY","RY_CALCULO")
	@ aObj2Size[3,1]	, aObj2Size[3,2]+55 	MSGET cRotDesc SIZE 110,007	OF oDlg PIXEL WHEN .F.

ACTIVATE DIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED

If lRet
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Alterando o periodo do Calculo de Finiquitos para Aplicacao de Finiquitos ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

	DbSelectArea( "SRC" )
    nOrder := RetOrdem("SRC","RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA")
    DbSetOrder( nOrder )
    DbSeek(SRA->(RA_FILIAL+RA_MAT+RA_PROCES)+cSvRoteir+cSvPer+cSvNPgto, .F.)

	Begin Transaction

	    /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Altera informacoes no formulario             				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
   		If nTipo == 1
			oModelSRG:LoadValue('RG_APLROT' , cRoteir 	)
			oModelSRG:LoadValue('RG_APLPER' , cPer    	)
			oModelSRG:LoadValue('RG_APLNPG' , cNPgto  	)
			oModelSRG:LoadValue('RG_EFETIVA', "3"		)
		Else
			oModelSRG:LoadValue('RG_ROTEIR' , cRoteir 	)
			oModelSRG:LoadValue('RG_PERIODO', cPer    	)
			oModelSRG:LoadValue('RG_SEMANA' , cNPgto  	)
			oModelSRG:LoadValue('RG_EFETIVA', "2"		)
			oModelSRG:ClearField('RG_APLPER')
			oModelSRG:ClearField('RG_APLNPG')
			oModelSRG:ClearField('RG_APLROT' )
		EndIf

		If cAtualSit == "1"
			If nTipo == 1
				RetSituacao(cFil ,cMat , .T.,M->RG_DATADEM)
	        Else
		        fRetSitRes(cFil,cMat)
    		EndIf
		EndIf

		FwFormCommit(oModel) //nao precisa fazer validacoes novamente pois o formulario jah foi validado antes da aplicacao de rescisao

		DbSelectArea("SRG") //voltar para a tabela SRG
	End Transaction

	While SRC->( !Eof() ) .and. SRC->( RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA) == SRA->(RA_FILIAL+RA_MAT+RA_PROCES)+cSvRoteir+cSvPer+cSvNPgto

   		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Obtem o Proximo Registro                    				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !GetNextRecno( "SRC", @nNextRecno , @nRecno , nOrder )
			Exit
		EndIf

		RecLock( "SRC", .F.)
		SRC->RC_PERIODO := cPer
		SRC->RC_ROTEIR	:= cRoteir
		SRC->RC_SEMANA 	:= cNPgto
		MsUnlock()

		If !GotoNextRecno( "SRC" , nNextRecno , nOrder )
			Exit
		EndIf
    EndDo

	If lRet
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0089) , 1, 0 )//"Atenção"##"Processo Concluido com Sucesso!"
	EndIf
EndIf

Return(lRet)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³OpcRecRes ³ Autor ³ Marinaldo de Jesus 	  ³ Data ³04/03/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Dialogo com as Opcoes para Recalculo da Resciasao			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³OpcRecRes( nOpc )											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Numero da Opcao de Recalculo da Rescisao: 0 -> Sair			³
³          ³                                          1 -> Recalculo	³
³          ³                                          2 -> Complementar ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³GPEM040   												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function OpcRecRes()

Local aSvKeys	:= GetKeys()

Local bSet15	:= { || lOpcOk := .T.	, RestKeys( aSvKeys , .T. ) , oDlg:End() }
Local bSet24	:= { || nOpcRec := 0	, RestKeys( aSvKeys , .T. ) , oDlg:End() }

Local lOpcOk	:= .F.

Local nOpcRec	:= 1.00

Local oRadio
Local oDlg
Local oGroup
Local oFont
Local oCheckRes
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

aAdvSize	:= MsAdvSize( ,.T.,370)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 15 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM  aAdvSize[7],0 TO aAdvSize[6]*0.60,aAdvSize[5] TITLE OemToAnsi( STR0001 ) PIXEL

	@ aObjSize[1,1],aObjSize[1,2]	GROUP oGroup TO aObjSize[1,1] + 45,aObjSize[1,4] LABEL OemToAnsi(STR0114) OF oDlg PIXEL	//"Rescis„o ja foi Calculada. Escolha a Op‡„o:"
	oGroup:oFont:=oFont

	If ( cPaisLoc == "MEX" ) .AND. ( TYPE("SRG->RG_FECREI") <> "U" )
		@ aObjSize[1,1]+10,aObjSize[1,2]+10	RADIO oRadio VAR nOpcRec ITEMS 	OemToAnsi(STR0115)	,;			//"Recalcular"
																				OemToAnsi(STR0116)	,;	   		//"Complementar"
																				OemToAnsi(STR0117)	 ;			//"Nova"
					SIZE 115,010 OF oDlg PIXEL

		@ aObjSize[1][1]+40,aObjSize[1][2]+10 CHECKBOX oCheckRes VAR lRescDis PROMPT OemToAnsi( STR0118 ) SIZE 95,10 OF oDlg PIXEL FONT oFont  	//"Complementar por Dissidio"
	Else
		@ aObjSize[1,1]+10,aObjSize[1,2]+10	RADIO oRadio VAR nOpcRec ITEMS 	OemToAnsi(STR0115)	,;			//"Recalcular"
																				OemToAnsi(STR0116)	 ;	   		//"Complementar"
					SIZE 115,010 OF oDlg PIXEL
		oRadio:bChange := { || fRadioChange(nOpcRec, oCheckRes) }

		@ aObjSize[1][1]+30,aObjSize[1][2]+10 CHECKBOX oCheckRes VAR lRescDis PROMPT OemToAnsi( STR0118 ) SIZE 95,10 OF oDlg PIXEL //"Complementar por Dissidio"
		oCheckRes:lVisible := .F.
	EndIf

	oDlg:bSet24 := { || nOpcRec := 0 , oDlg:End() }
	bSvSet24 := SetKey( 24 , oDlg:bSet24 )

	oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.

ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 )
RestKeys( aSvKeys , .T. )

If !( lOpcOk )
	nOpcRec := 0
EndIf

Return( nOpcRec )

/*/{Protheus.doc} OpcRecCom
Dialogo com as Opcoes para Complementar
@author Allyson
@since 26/12/2018
@version 1.0
@return cOpcRec  -  1 -> Complementar
					2 -> Complementar por Dissídio
					3 -> Retificação
/*/
Static Function OpcRecCom()

Local aSvKeys	:= GetKeys()

Local bSet15	:= { || lOpcOk := .T.	, RestKeys( aSvKeys , .T. ) , oDlg:End() }
Local bSet24	:= { || nOpcRec := 0	, RestKeys( aSvKeys , .T. ) , oDlg:End() }

Local lOpcOk	:= .F.

Local cOpcRec	:= "0"
Local nOpcRec	:= 1.00

Local oRadio
Local oDlg
Local oGroup
Local oFont
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

aAdvSize	:= MsAdvSize( ,.T.,370)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 15 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM  aAdvSize[7],0 TO aAdvSize[6]*0.60,aAdvSize[5] TITLE OemToAnsi( STR0001 ) PIXEL

	@ aObjSize[1,1],aObjSize[1,2]	GROUP oGroup TO aObjSize[1,1] + 45,aObjSize[1,4] LABEL OemToAnsi(STR0114) OF oDlg PIXEL	//"Rescis„o ja foi Calculada. Escolha a Op‡„o:"
	oGroup:oFont:=oFont

	@ aObjSize[1,1]+10,aObjSize[1,2]+10	RADIO oRadio VAR nOpcRec ITEMS 	OemToAnsi(STR0116)	,;			//"Complementar"
																		OemToAnsi(STR0118)	,;	   		//"Complementar por Dissidio"
																		OemToAnsi(STR0240)	 ;	   		//"Retificação"
				SIZE 115,010 OF oDlg PIXEL

	oDlg:bSet24 := { || nOpcRec := 0 , oDlg:End() }
	bSvSet24 := SetKey( 24 , oDlg:bSet24 )

	oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.

ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 )
RestKeys( aSvKeys , .T. )

If !lOpcOk
	nOpcRec := 0
EndIf

cOpcRec := Str(nOpcRec, 1)

Return( cOpcRec )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Gpem040Exc 	³ Autor ³Marinaldo de Jesus   ³ Data ³16/05/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Excluir os Itens de Rescisoes Calculados					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpem040Exc( nRegSrg , aSrgRecnos , aSrgExclui )				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL 														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³GPEM040   												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function Gpem040Exc( nRegSrg , aSrgRecnos , aSrgExclui, lResPosFol,cAfasfgts)

Local aSituacao		:= {}

Local cFil			:= SRA->RA_FILIAL
Local cMat			:= SRA->RA_MAT
Local cKey			:= ( ( cFil + cMat ) + "R" )
Local cKeySPB		:= cFil + cMat

Local lExcluiu		:= .F.

Local nRecno		:= 0.00
Local nRecnos		:= 0.00
Local nIndSRR		:= RetOrder( "SRR", "RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC" )
Local cMyChave		:= ""

DEFAULT aSrgRecnos	:= { { nRegSrg, ,  } }
DEFAULT aSrgExclui  := { { .T. } }
DEFAULT lResPosFol  := .F.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Controle nOpcEx para exclusão.       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nOpcEx := 9
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa a gravacao dos lancamentos do SIGAPCO        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PcoIniLan("000090")

Begin Transaction

	nRecnos := Len( aSrgRecnos )
	For nRecno := 1 To nRecnos
		If ( aSrgExclui[ nRecno , 01 ] )
			lExcluiu := .T.
			SRG->( dbGoto( aSrgRecnos[ nRecno, 1 ] ) )
			SRR->( dbSetOrder(nIndSRR) )
			If SRR->( dbSeek( cKey ) )
				While SRR->( !Eof() .and. cKey == RR_FILIAL+RR_MAT+RR_TIPO3 )
					If ( SRG->RG_DTGERAR == SRR->RR_DATA )
						SRR->( RecLock("SRR",.F.,.T.) )
						SRR->( dbDelete() )
						SRR->( MsUnLock() )
						//integracao com modulo SIGAPCO
						PcoDetLan("000090","01","GPEM040", .T.)
					EndIf
					SRR->( dbSkip() )
				EndDo
			EndIf
			//# Salva chave pra pesquisa futura
			cMyChave := SRG->(RG_MAT+RG_PROCES+RG_ROTEIR+RG_PERIODO+RG_SEMANA)

			SRG->( RecLock( "SRG" , .F. , .T. ) )
			SRG->( dbDelete() )
			SRG->( MsUnLock() )
		EndIf
	Next nRecno

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se ocorreu exclusao                                           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If ( lExcluiu )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica a Situacao do Funcionario                            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If cPaisLoc <> "MEX"	// Para o México nao devera alterar os campos de demissao na exclusao, pois
								// o status e os demais campos sao informados no cadastro de funcionario
			aSituacao := RetSituacao( cFil , cMat , .F. , NIL , .T. )
			If !( aSituacao[1] == "D" )
				SRA->( RecLock( "SRA" , .F. , .T. ) )
				SRA->RA_DEMISSA  := Ctod("//")
				SRA->RA_RESCRAI  := "  "
				If ( ( cPaisLoc == "DOM" ) .and. !Empty(SRA->RA_DTENTRA) )
					SRA->RA_DTENTRA := Max(SRA->RA_ADMISSA,(SRA->RA_DTENTRA - 365))
				EndIf
				SRA->( MsUnLock() )

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Atualiza Bloqueio do SRA e Apaga SRC com dados da Rescisao ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If lResPosFol .And. cPaisLoc == "ARG"

					ResBloqSRA("E")	//# Excluir
					ResExclSRC( cMyChave )	//# SRG->(RG_MAT+RG_PROCES+RG_ROTEIR+RG_PERIODO+RG_SEMANA)

					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0119), 1, 0 )//#"Rescisão depois da folha excluida com sucesso !!!"###"Atencao"

				EndIf

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Retorna a Atual Situacao do Funcionario                       ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				RetSituacao(cFil , cMat , .T. , NIL , .T. )
			EndIf

		EndIf

		If FindFunction("OrgXDelRescisao")
			OrgXDelRescisao(SRA->RA_FILIAL, SRA->RA_MAT)
		EndIf

		//--Retorna o campo PB_INTEGRA para Nil, de forma que este possa ser integrado com a folha apos o fechamento
		ExcIntSPB(cKeySPB)

	EndIf

End Transaction

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Finaliza a gravacao dos lancamentos do SIGAPCO          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PcoFinLan("000090")

Return( Nil )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GP40DiasAv  ³ Autor ³ Leandro Drumond       ³ Data ³ 14/01/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula dias e data de aviso previo.                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³GP40DiasAv(@dDataAv,nDiasAv)									³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function GP40DiasAv(dDataAv,nDiasAv,cTpAviso,nDiasCum,nDiaInde)

	DEFAULT nDiasAv		:= 0
	DEFAULT nDiasCum	:= 0
	DEFAULT nDiaInde	:= 0

	If cPaisLoc == "BRA"
		nDiasAv:= (fDesc( "RCE", SRA->RA_SINDICA, "RCE_DIASAV" ))
	EndIf

	lProJav := If(Type("lProJav") <> "L", .F., lProJav)

	If cPaisLoc == "BRA" .And. RCE->(ColumnPos( "RCE_PRJAVT")) > 0
		If (fDesc( "RCE", SRA->RA_SINDICA, "RCE_PRJAVT" )) == "2"
			lProj := .F.
		Endif
	Else
		lProj := .T.
	Endif

	If nDiasAv == 0 .And. lProjav .And. ( (lProj .And. cTpAviso $ "T*B") .Or. ! cTpAviso $ "T*B")
		nDiasAv := fComplAvP(dDatadem1,nAnosCasa,cTpAviso)
	EndIf
	If cPaisLoc == "BRA"
		If	nDiasAv == 0 .And. lProjav .And. ( (lProj .And. cTpAviso $ "T*B") .Or. ! cTpAviso $ "T*B")
			nDiasAv := fAvProj(dDatadem1,nAnosCasa,,cTpAviso,,@nDiasCum,nDiaInde)
		EndIf
	Else
		If	nDiasAv == 0 .And. lProjav
			nDiasAv := fAvProj(dDatadem1,nAnosCasa,,cTpAviso)
		EndIf
	Endif

	If nDiasAv == 0 .and. !lProjav
		nDiasAv:= 30
	EndIf

	If cPaisLoc <> "BRA"
		If nDiasAv > 0 .and. lProJav
			dDataAv := If( ! Empty(aIncRes) .And. ! aIncRes[02] $ "T*B", If(lSabDom .and. dDatadem <> dDatadem1, dDatadem1, dDatadem), dDatadem - nDiasAv + 1)
		EndIf
	Endif
	if nDiasAv > 0 .and. !Empty(aIncRes) .And. aIncRes[02] == "N"
		nDiasAv := 0
	Endif

Return nDiasAv

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fChkDtGer   ³ Autor ³ Leandro Drumond       ³ Data ³ 23/01/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valid do campo RG_DTGERAR.			                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fChkDtGer()													³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fChkDtGer()
Local aArea			:= GetArea()
Local lRet 			:= .T.
Local aPerAberto	:= {}
Local dDataGer  	:= &(ReadVar())
Local oModel		:= FWModelActive()
Local cFil			:= ""
Local cMat			:= ""
Local nRecAux		:= SRG->(Recno())
Local nX			:= 0
Local lUsaDiss		:= lRescDis
If cModFol == "2"
	If Type("cCompl") == "U" .Or. cCompl == Nil
		Private cCompl := "N"
	EndIf
	If Type("dDataDem1") == "U" .Or. dDataDem1 == Nil
		Private dDataDem1 := ddatabase
	EndIf
	If Type("dDataDem") == "U" .Or. dDataDem == Nil
		Private dDataDem := fDtSabDom()
	EndIf
	If Type("nSabDom") == "U" .Or. nSabDom == Nil
		Private nSabDom := 0
	EndIf
EndIf

If Type("cModel") == "C" .AND. ! Empty(cModel)
	cFil := oModel:GetModel(cModel):GetValue("RG_FILIAL")
	cMat := oModel:GetModel(cModel):GetValue("RG_MAT")
Else
	cFil := oModel:GetModel('GPEM040_MSRG'):GetValue("RG_FILIAL")
	cMat := oModel:GetModel('GPEM040_MSRG'):GetValue("RG_MAT")
EndIf

Begin Sequence
	If cCompl == "S"
		SRG->(DbSetOrder(1))
		If SRG->(DbSeek(cFil+cMat+DtoS(dDataGer)))
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0134), 1, 0 ) //"Atenção"###"A data de geração da complementar deve ser diferente das demais rescisões"
			lRet := .F.
			SRG->(DbGoTo(nRecAux))
			Break
		Else
			SRG->(DbGoTo(nRecAux))
		EndIf

		If cPaisLoc == "BRA"
			For nX := 1 To Len(aSrgRecnos)
				SRG->( dbGoTo( aSrgRecnos[nX, 1] ) )
				//Se existiu uma complementar por dissídio no mês atual, força a nova rescisão como dissídio para que calcule a anterior corretamente (apenas a última será integrada)
				If AnoMes( SRG->RG_DTGERAR ) == AnoMes(dDataGer) .and. SRG->RG_RESCDIS == "2"
					lUsaDiss := .T.
				EndIf
			Next nX
		EndIf
		SRG->(DbGoTo(nRecAux))

		If !(AnoMes(dDataGer) == AnoMes(dDataDem)) .or. lRescDis
			fRetPerComp(SubStr(Dtos(dDataGer),5,2), SubStr(Dtos(dDataGer),1,4),, SRA->RA_PROCES,fGetCalcRot("4"),@aPerAberto )

			If Empty(aPerAberto)
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0135), 1, 0 ) //"Data de Geração Inválida. A Data de geração deve pertencer ao periodo em aberto"
				lRet := .F.
			Else
				dDataDe 	:= aPerAberto[1,5]
				dDataAte 	:= aPerAberto[1,6]
				cPeriodo	:= aPerAberto[1,1]
				cNumPag		:= aPerAberto[1,2]

				aPeriodo 	:= {}

				fCarPeriodo( cPeriodo , cRot , @aPeriodo , @lUltSemana , @nPosSem)

				//Altera periodo e semana na tela
				M->RG_PERIODO := cPeriodo
				M->RG_SEMANA  := cNumPag

				fSalario(@Salario,@SalHora,@SalDia,@SalMes,"A",AnoMes(dDataDe),cNumPag)

				M->RG_SALMES  := SalMes
				M->RG_SALDIA  := SalDia
				M->RG_SALHORA := SalHora

				If IsBlind()
					oModel:LoadValue("GPEM040_MSRG","RG_PERIODO",cPeriodo)
					oModel:LoadValue("GPEM040_MSRG","RG_SEMANA",cNumPag)
					oModel:LoadValue("GPEM040_MSRG","RG_SALMES",SalMes)
					oModel:LoadValue("GPEM040_MSRG","RG_SALDIA",SalDia)
					oModel:LoadValue("GPEM040_MSRG","RG_SALHORA",SalHora)
				EndIf

				//Ponto de Entrada para alteração do cabeçalho da rescisão - Tv Tribuna
				If ExistBlock( "GPESALAR" )
					ExecBlock("GPESALAR",.F.,.F.)
				EndIf

			EndIf
		EndIf

	Else
	    If Empty(dDataGer)
			 Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0171), 1, 0 ) //"Data de Geração não foi preenchida"
			 lRet := .F.
	    Else
			If !(AnoMes(dDataGer) == AnoMes(dDataDem))
				fRetPerComp(SubStr(Dtos(dDataGer),5,2), SubStr(Dtos(dDataGer),1,4),, SRA->RA_PROCES,fGetCalcRot("4"),@aPerAberto )
				If Empty(aPerAberto)
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0135), 1, 0 ) //"Data de Geração Inválida. A Data de geração deve pertencer ao periodo em aberto"
					lRet := .F.
		       EndIf
		   Else
				SRG->(DbSetOrder(1))
				If SRG->(DbSeek(cFil+cMat+DtoS(dDataGer)))
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0193), 1, 0 ) //"Atenção"###"Data de Geração Inválida. Já existe Rescisão calculada para esta data."
					lRet := .F.
					SRG->(DbGoTo(nRecAux))
					Break
				Else
					SRG->(DbGoTo(nRecAux))
				EndIf
			EndIf
       EndIf

	EndIf
End Sequence

RestArea(aArea)

If lRet
	lRDisOrig := lRescDis //Guarda valor original selecionado pelo usuário na inclusão da complementar
	lRescDis  := lUsaDiss
EndIf
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCarRGB     ³ Autor ³ Leandro Drumond       ³ Data ³ 17/01/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Carrega lançamentos da RGB para analise na calmed             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fCarRGB()														³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fCarRGB(cProcAux,cPerAux,cSemAux)
Local aArea		 := GetArea()
Local cQuery	 := GetNextAlias()
Local cWhere	 := ""
Local cRotRGB	 := fGetRotOrdinar() + "*" + fGetCalcRot("4") //FOL*RES
Local cSeq := ""

DEFAULT cProcAux := M->RG_PROCES
DEFAULT cPerAux	 := M->RG_PERIODO
DEFAULT cSemAux	 := M->RG_SEMANA

cWhere := "%"
cWhere += " RGB_FILIAL 	= '" + SRA->RA_FILIAL + "' AND "
cWhere += " RGB_MAT 	= '" + SRA->RA_MAT + "' AND "
cWhere += " RGB_PROCES 	= '" + cProcAux + "' AND "
cWhere += " RGB_PERIOD  = '" + cPerAux + "' AND "
cWhere += " RGB_SEMANA 	= '" + cSemAux + "' "
cWhere += "%"

BeginSql alias cQuery
	SELECT
		column RGB_DTREF AS Date
		RGB_PD, RGB_VALOR, RGB_CC, RGB_CC, RGB_TIPO1, RGB_TIPO2, RGB_HORAS, RGB_DTREF, RGB_ROTEIR
	FROM 		%table:RGB% RGB
	WHERE
				%exp:cWhere% AND
				RGB.%NotDel%
EndSql

While (cQuery)->( !Eof() )
	If (cQuery)->RGB_ROTEIR $ cRotRGB
		If (cQuery)->( nPos := Ascan(aPd, { |X| X[1] == RGB_PD .And. X[3] = cSemana .And. X[2] = RGB_CC .AND. X[10] == RGB_DTREF } ) ) == 0
			If (cQuery)->( nPos := Ascan(aPd, { |X| X[1] == RGB_PD .And. X[3] = cSemana .And. X[2] = RGB_CC  } ) ) > 0
				If Empty(cSeq)
					cSeq := "0"
				EndIf
				cSeq := Soma1(cSeq)
			Else
				cSeq := ""
			EndIf
			(cQuery)->( FMatriz(RGB_PD,RGB_VALOR,RGB_HORAS,,RGB_CC,RGB_TIPO1,RGB_TIPO2,,,RGB_DTREF,,cSeq ) )
		Else
			aPd[nPos,4] += (cQuery)->RGB_HORAS
			aPd[nPos,5] := Round((cQuery)->RGB_VALOR + aPd[nPos,5],2)
		EndIf
	EndIf
	(cQuery)->(dbSkip())
EndDo

dbSelectArea(cQuery)
dbCloseArea()

RestArea(aArea)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Gpm40LoadRRA  ³ Autor ³ Leandro Drumond   ³ Data ³ 03.08.12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega valores de RRA                                	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM040                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Function Gpm40LoadRRA(nIr_B,nVal_Peal,aTabIr,nMeses,dDataHom,cPdIr,cPdInss)
Local aArea		:= GetArea()
Local cChave	:= ""
Local nBaseAux 	:= 0
Local nPosTab	:= 0
Local nX		:= 0

//Carrega tabela de IR para RRA somente se o periodo nao tiver sido carregado
nPosTab := fPosTab( "S034",AnoMes(dDataHom),">=",4,AnoMes(dDataHom),"<=",5 )

If nPosTab > 0
	aAdd(aTabIr,"S034")
	For nX := 1 to 21
		aAdd(aTabIr,fTabela("S034",nPosTab,nX))
	Next nX
Else
	If IsInCallStack( "EXECROT" ) //Se estiver executando roteiro de calculo
		AddLogExecRot( STR0125 )	// "Tabela de IR RRA (Tabela S034) não cadastrada."
		FinalCalc()
	Else
		Help( , , OemToAnsi(STR0020), , OemToAnsi( STR0125 ), 1, 0 )// "Tabela de IR RRA (Tabela S034) não cadastrada."
	EndIf
    SET DECIMALS TO 2
    Return ( .F. )
EndIf

//Se for verba de RRA, soma verbas de RRA Ferias
If cPdIR == aCodFol[974,1]
	Aeval( aPd ,{ |X| SomaInc(X,5,@nBaseAux,11,"S",12,"N",Month(dDataBase), ,aCodFol) })
EndIf

//Se nao existe base de IR, nao precisa somar IR RRA
If nIr_B <= 0 .and. nBaseAux <= 0
	Return Nil
EndIf

aEval( aPD , { |x| nBaseAux += IF( X[1] = cPdIr .And. X[3] = cSemana .And. X[9] # "D" .And. ( X[10] == NIL .Or. Empty(X[10]) .Or. MesAno(dDataHom) = MesAno(X[10]) ), x[5] , 0.00 ) } )

If nBaseAux > 0
	If ( nPos := Ascan(aPD,{ |X| !Empty(X[17]) }) ) > 0

		cChave := xFilial("RFC")+SRA->RA_MAT+aPd[nPos,17]+cPdIr

		DbSelectArea("RFC")
		DbSetOrder(RetOrder("RFC","RFC_FILIAL+RFC_MAT+RFC_IDCMPL+RFC_PD+RFC_CC+RFC_DATARQ+RFC_SEQ"))

		If(DbSeek(cChave))
			While(RFC->(!Eof() .and. RFC_FILIAL + RFC_MAT + RFC_IDCMPL + RFC_PD == cChave))
				nMeses += RFC->RFC_MESES
				RFC->(DbSkip())
			EndDo

			nIr_B += nBaseAux

			//Soma deducoes de INSS RRA
			aEval( aPD , { |x| nVal_Peal += IF( X[1] = cPdInss .And. X[3] = cSemana .And. X[9] # "D" .And. ( X[10] == NIL .Or. Empty(X[10]) .Or. MesAno(dDataHom) = MesAno(X[10]) ), x[5] , 0.00 ) } )

		EndIf
		EndIf
EndIf

//Zera IR RRA e IR RRA 13o para nao duplicar calculo do liquido
If ( nPos := Ascan(aPD,{ |X| X[1] == aCodFol[978,1] } ) ) > 0
	aPd[nPos,5] := 0
EndIf
If ( nPos := Ascan(aPD,{ |X| X[1] == aCodFol[983,1] } ) ) > 0
	aPd[nPos,5] := 0
EndIf

RestArea(aArea)
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³fTpRescDir³ Autor ³ Alessandro Santos	    ³ Data ³ 29/03/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Selecionar tipo de rescisao de diretor                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fTpRescDir()											 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Cadastro tabela SRG - Campo RG_TPDIR  					  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fTpRescDir()
Local cTitulo 	:= OemtoAnsi(STR0127) //##"Informacoes de Diretor"
Local MvPar   	:= ""
Local MvParDef	:= ""
Local MvStrRet := ""
Local nGrupo  	:= 0
Local lRet    	:= .T.
Local l1Elem  	:= .T.
Local aArea   	:= GetArea()
Local aTipo := { "01-" + OemtoAnsi(STR0128),; //##"Exoneracao do Diretor Nao Empregado sem justa causa, por deliberacao da assembleia, dos socios cotistas ou da autoridade competente"
				  "02-" + OemtoAnsi(STR0129),; //##"Termino de Mandato do Diretor Nao Empregado que nao tenha sido reconduzido ao cargo"
				  "03-" + OemtoAnsi(STR0130),; //##"Exoneracao a pedido de Diretor Nao Empregado"
				  "04-" + OemtoAnsi(STR0131),; //##"Exoneracao do Diretor Não Empregado por culpa receproca ou forca maior"
				  "05-" + OemtoAnsi(STR0132),;	//##"Morte do Diretor Nao Empregado"
				  "06-" + OemtoAnsi(STR0133),;  //##"Exoneracao do Diretor Nao Empregado por falencia, encerramento ou supressao de parte da empresa"
				  "99-" + OemtoAnsi(STR0260)}  //##"Outros"

cAlias 	:= Alias() 					// Salva Alias Anterior
MvPar	:= &(Alltrim(ReadVar()))	// Carrega Nome da Variavel do Get em Questao
MvRet	:= Alltrim(ReadVar())		// Iguala Nome da Variavel ao Nome variavel de Retorno
VAR_IXB := MvPar



MvParDef := "01020304050699"

If f_Opcoes(@MvPar, cTitulo, aTipo, MvParDef,,, l1Elem, 2)
	For nGrupo := 1 To Len(MvPar)
 		MvStrRet += Iif(SubStr(MvPar, nGrupo, 2) # "*", SubStr(mvpar, nGrupo, 1), Space(1))
	Next nGrupo

	&(MvRet) := AllTrim(MvStrRet)
EndIf

lRet := Iif(MvStrRet $ MvParDef, .T., .F. )

RestArea(aArea)

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³ fValEfd 	ºAutor  ³ Emerson Campos     º Data ³  20/09/2013 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao para validar todos os campos do eSocial			  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cObs Campo observação da aba eSocial			  			  º±±
±±º          ³ cAtOb Campo Atestado de obito da aba eSocial			      º±±
±±º          ³ cTpRes Campo Tipo de rescisao da aba eSocial			      º±±
±±º          ³ cNrProc Campo nro do processo trabalhista da aba eSocial	  º±±
±±º          ³ cCnpj Campo CNPJ da sucessora da aba eSocial			  	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM040 			                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fValEfd(cObs, cAtOb, cTpRes, cNrProc, cNroCnpj, cTpSuc, cMsg)
Return fValEfdM040(cObs, cAtOb, cTpRes, cNrProc, cNroCnpj, cTpSuc, cMsg)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fObitoVld	ºAutor  ³ Emerson Campos     º Data ³  20/09/2013 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao para validar o ca				  					  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM040 			                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fObitoVld(cAtObito, cTipR)
Return fObtVldM040(cAtObito, cTipR)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³ fValCNPJ  ºAutor  ³ Emerson Campos    º Data ³  26/09/2013 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao para limitar em 255 caractreres no campo memo		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM040 			                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fValCNPJ(cCnpj, cTipR, cTpSuc, cMsg)
Return fVldInsM040(cCnpj, cTipR, cTpSuc, cMsg)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³INTEGDEF  ºAutor  ³                     º Data ³ 06/01/2015 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função para a interação com EAI                             º±±
±±º          ³envio e recebimento                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function IntegDef( cXml, nType, cTypeMsg, cVersaoMsg )

Local aRet  := {}

aRet:= GPEI041( cXml, nType, cTypeMsg, cVersaoMsg )

Return aRet

/*/{Protheus.doc} VldTpRes
Valida o Tipo de rescisão vindo do portal.
@author cicero.pereira
@since 23/09/2015
@version 2.0
@see http://tdn.totvs.com/x/PrthE
/*/
Static Function VldTpRes()

	Local aAreaSRG	:= SRG->( GetArea() )
	Local lRet		:= .F.

	If M->RG_TIPORES == cTipResPortal
		lRet := .T.
	EndIF

	//Ponto de entrada para definir se o tipo de rescisão pode ser alterado quando a solicitação vier do portal
	If ExistBlock( "VLDTPRESP" )
		lRet := ExecBlock("VLDTPRESP",.F.,.F.)
	EndIf

	RestArea(aAreaSRG)

Return ( lRet )

/*/{Protheus.doc} fRadioChange
@author Allyson Mesashi
@Since 06/02/2017
@version 1.0
@param nOpcao Opção selecionada (1-Recálculo, 2-Complementar)
@param oCheck Objeto oCheckRes da opção "Complementar por dissídio"
/*/
Static Function fRadioChange(nOpcao, oCheck)

If nOpcao == 1
	lRescDis		:= .F.
	oCheck:lVisible := .F.
Else
	oCheck:lVisible := .T.
EndIf

oCheck:Refresh()

Return .T.

Static Function IncidCpos(oStruct,cTabela,lIsView)
	Local aArea	:= SX3->(GetArea())
	Local aCampos := {'RV_INSS','RV_FGTS','RV_IR','RV_INCORP','RV_REF13','RV_REFFER'}
	Local nI := 0
	Local cCpNome := ''
	Local cPrefixo := ''
	Local cOrdem := ''
	Local cCpoPD := ''
	Local bIniPad := {||}
	Local cIniPad := ''
	Default lIsView := .F.

	cPrefixo := PrefixoCpo(cTabela)
	cCpoPD := cPrefixo + '_PD'

	SX3->(dbSetOrder(2))
	dbSelectArea('SX3')
	for nI:= 1 to Len(aCampos)
		cCpNome := cPrefixo + SubStr( aCampos[nI], At('_',aCampos[nI]))
		if(dbSeek(aCampos[nI]))
			if(lIsView)
				cOrdem := aTail(oStruct:aFields)[2]
				cOrdem := Val(cOrdem) + 1
				cOrdem := StrZero(cOrdem,2)

				oStruct:AddField(	cCpNome, cOrdem, AllTrim(X3_TITULO), AllTrim(X3_TITULO), {}, X3_TIPO, AllTrim(X3_PICTURE),;
				/*bPictVar*/, /*cLookUp*/, /*lCanChange*/, /*cFolder*/, /*cGroup*/, /*aComboValues*/,;
				/*nMaxLenCombo*/, /*cIniBrow*/, .T.)
			else
				cIniPad := 'POSICIONE( "SRV", 1, xFilial("SRV")+'+ cTabela + '->'+ cCpoPD + ',"'+ aCampos[nI] +'")'
				bIniPad := FwBuildFeature( STRUCT_FEATURE_INIPAD, cIniPad )
				oStruct:AddField(AllTrim(X3_TITULO), AllTrim(X3_TITULO), cCpNome, X3_TIPO, X3_TAMANHO, X3_DECIMAL,;
			  	/*bValid*/, /*bWhen*/, /*aValues*/, /*lObrigat*/, bIniPad, /*lKey*/, /*lNoUpd*/,.T.)

		endIf
		endIf
	next nI

	RestArea(aArea)

Return nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGP40TPRES  ºAutor  ³Rh Manutenção      º Data ³  31/05/17  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Baseado no tipo de rescisao informado, realiza um de/para naº±±
±±º          ³ tabela do eSocial e retorna a opcao selecionada            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Rescisao Simples e Rescisao Coletiva                       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGP40TPRES( cCodTpRes, cTpAvs, laIncRes, dDataPesq )
Return fM40TPRES( cCodTpRes, cTpAvs, laIncRes, dDataPesq )

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGP40VLRES  ºAutor  ³Rh Manutenção      º Data ³  31/05/17  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Realiza a validacoes dos dados enviados para rescisao do    º±±
±±º          ³ funcionario corrente                                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Realiza a validacao dos registros setados em memoria       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParam     ³ cTpAviso   : Tipo de Aviso do funcionário                  º±±
±±º          ³ cCdEFD     : Tipo Rescisao do eSocial                      º±±
±±º          ³ dDtDemissa : Data de demissao do desligamento              º±±
±±º          ³ cCodObito  : Numero de certidao de obito do funcionario    º±±
±±º          ³ cTpRes     : 1 = Rescisao Simples / 2 = Rescisao Coletiva  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGP40VLRES( cTpAviso, cCdEFD, dDtDemissa, cCodObito, cTpRes, cIndAv, aErroRes, lAviso, cVersEnvio, nOper, lNT15)
Return fM40VLRES( cTpAviso, cCdEFD, dDtDemissa, cCodObito, cTpRes, cIndAv, aErroRes, lAviso, cVersEnvio, nOper, lNT15)

/*/{Protheus.doc} fVincSQG
Disponibiliza o currículo do funcionário ou troca o status para FUN
@author Gabriel A.
@Since 21/09/2017
@version 1.0
@param nOperacao Operação da rescisão - Inclusão ou Exclusão
@param cFil Filial do funcionário
@param cMat Matrícula do funcionário
/*/
Static Function fVincSQG(nOperacao,cFil,cMat)
	Local cCurriculo := ""
	Local aArea      := GetArea()
	Local cAliasQry  := GetNextAlias()
	Local cFilSQG    := xFilial("SQG",cFil)

	BeginSql Alias cAliasQry
		SELECT QG_FILIAL,QG_CURRIC
		FROM %Table:SQG% SQG
		WHERE
			QG_FILMAT = %Exp:cFil% AND
			QG_MAT = %Exp:cMat% AND
			SQG.%NotDel%
	EndSql

	If !( (cAliasQry)->(EOF()) )
		cCurriculo := (cAliasQry)->QG_CURRIC

		DbSelectArea("SQG")
		SQG->( DbSetOrder(1) )

		If SQG->( DbSeek(cFilSQG + cCurriculo) )
			RecLock("SQG",.F.)
			If nOperacao == MODEL_OPERATION_DELETE
				SQG->QG_SITUAC := Iif( SRA->RA_ADMISSA <= SQG->QG_DTCAD, "FUN", "002")
			Else
				SQG->QG_SITUAC := "001"
			EndIf
			SQG->( MsUnlock() )
		EndIf

		SQG->( DbCloseArea() )
	EndIf

	RestArea(aArea)
Return

/*/{Protheus.doc}fChkInteg()
- Verifica se existem dados que nao foram integrados.
@Type Static Function
@author:	Jônatas Alves
@since:		26/09/2017
@param:	lMsg - Indica se deve exibir mensagem ao usuario.
@version 1.0
@return lRet - Retorno lógico, indica se prossegue com a rescisão.
/*/
Static Function fChkInteg( lMsg )

Local aArea		:= GetArea()
Local aRCH		:= RCH->(GetArea())
Local aLogAux	:= {}
Local cQuery	:= ""
Local cAliasQRY	:= GetNextAlias()
Local cKeyRCH	:= xFilial("RCH") + cProcesso + GetRotExec() + cPeriodo
Local cUltSemana:= cNumPag
Local lRet 		:= .T.
Local lFirst	:= .T.

Private aLogErros	:= {}				// Array com os logs de erros de processamento


DbSelectArea("RCH")
DbSetOrder(4) //RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG
DbSeek( cKeyRCH  + cNumPag )

While !Eof() .and. RCH_FILIAL + RCH_PROCES + RCH_ROTEIR + RCH_PER == cKeyRCH
	If RCH_NUMPAG <>  cNumPag
		cUltSemana  := RCH_NUMPAG
	EndIf
	RCH->(DbSkip())
EndDo

cQuery := "SELECT RY_CALCULO, RY_DESC FROM " + RetSqlName("RCH") + " RCH "
cQuery += "INNER JOIN " + RetSqlName("SRY") + " SRY "
cQuery += "ON RCH.RCH_ROTEIR = SRY.RY_CALCULO AND "
cQuery += FWJoinFilial( "RCH", "SRY" )
cQuery += " INNER JOIN " + RetSqlName("RCJ") + " RCJ "
cQuery += "ON RCH.RCH_PROCES = RCJ.RCJ_CODIGO AND "
cQuery += FWJoinFilial( "RCH", "RCJ" )
cQuery += " INNER JOIN " + RetSqlName("SRA") + " SRA "
cQuery += "ON " + FWJoinFilial( "RCH", "SRA" )
cQuery += " WHERE RCH_PROCES = '" + cProcesso + "' AND RCH_PER = '" + cPeriodo + "' AND RCH_DTINTE = ''"
cQuery += " AND RY_INTEGRA = '1'" //Nao valida folha, adiantamento, 13o., Autonomo e PLR pois nao sao integraveis
cQuery += " AND RY_TIPO <> '4'" //Nao valida o proprio roteiro de rescisao
cQuery += " AND RA_FILIAL = '" + SRA->RA_FILIAL + "'"
cQuery += " AND RA_MAT = '" + SRA->RA_MAT + "'"

If cUltSemana <> cNumPag //Se for a ultima semana, todos as demais semanas devem estar fechadas
	cQuery += " AND RCH_NUMPAG = '" + cNumPag + "'"
EndIf

cQuery += "  AND RCJ.D_E_L_E_T_ = ' ' AND RCH.D_E_L_E_T_ = ' ' AND SRY.D_E_L_E_T_ = ' ' AND SRA.D_E_L_E_T_ = ' '"
cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQRY)

dbSelectArea(cAliasQRY)

cMsgLog := ""

While !((cAliasQRY)->(EOF()))
	If lFirst
		cMsgLog += STR0199 + CRLF // "Os seguintes roteiros de cálculo ainda não foram integrados:"
		aAdd(aLogErros, { OemToAnsi( STR0199 ) }) // "Os seguintes roteiros de cálculo ainda não foram integrados:"
		lFirst := .F.
	EndIf
	If (aScan(aLogAux, {|x| x[01]+x[02] == (cAliasQRY)->RY_CALCULO + (cAliasQRY)->RY_DESC })) == 0
		aAdd(aLogAux, {(cAliasQRY)->RY_CALCULO , (cAliasQRY)->RY_DESC})
		cMsgLog += (cAliasQRY)->RY_CALCULO + " - " + (cAliasQRY)->RY_DESC + CRLF
		aAdd(aLogErros, {(cAliasQRY)->RY_CALCULO , (cAliasQRY)->RY_DESC})
	EndIf
	(cAliasQRY)->(DbSkip())
EndDo

(cAliasQRY)->(dbCloseArea())

If !Empty( cMsgLog )
	cMsgLog += STR0200 + CRLF // "Antes de prosseguir, é recomendada a verificação dos cálculos e"
	cMsgLog += STR0201 + CRLF // "solicitações dos benefícios já realizados para a competência de"
	cMsgLog += STR0202 + CRLF // "cálculo da rescisão."
	cMsgLog += STR0203 + CRLF // "Se necessário, efetue a manutenção dessas informações para não"
	cMsgLog += STR0204 + CRLF // "ocasionar pedidos de benefícios indevidos para este funcionário."
	cMsgLog += STR0205 // "Deseja continuar ?"
	aAdd(aLogErros, { OemToAnsi( STR0206 ) }) // "É recomendada a verificação dos cálculos e solicitações dos benefícios já realizados para a competência de cálculo da rescisão."
	aAdd(aLogErros, { OemToAnsi( STR0207 ) }) // "Se necessário, efetue a manutenção dessas informações para não ocasionar pedidos de benefícios indevidos para este funcionário."
EndIf

If lMsg .And. !Empty( cMsgLog ) .And. !IsBlind()
	lRet := MsgNoYes( OemToAnsi( cMsgLog ) , OemToAnsi( STR0020 ) ) // Atenção
EndIf

RestArea(aRCH)
RestArea(aArea)

Return lRet

/*/{Protheus.doc} GravaRGB
Grava verba na RGB de acordo com as informações da SRR
@author cicero.pereira
@since 09/04/2018
@param oGrid, object, Grid com as verbas da SRR
@param nLine, numeric, Número da linha no grid
/*/
Static Function GravaRGB(oGrid, nLine)

	Local cChave := ""

	oGrid:GoLine(nLine)

	// RGB_FILIAL + RGB_PROCES + RGB_MAT + RGB_PERIOD + RGB_SEMANA + RGB_PD + RGB_SEQ

	cChave := SRA->(RA_FILIAL + RA_PROCES + RA_MAT) + cPeriodo + oGrid:GetValue("RR_SEMANA") + oGrid:GetValue("RR_PD")
	DbSelectArea("RGB")
	DbSetOrder(3)

	// Só grava se não encontrar a verba na RGB
	If ! DbSeek(cChave)
		RecLock("RGB", .T.)
			RGB -> RGB_FILIAL := SRA->RA_FILIAL
			RGB -> RGB_MAT 	  := SRA->RA_MAT
			RGB -> RGB_PD 	  := oGrid:GetValue("RR_PD")
			RGB -> RGB_TIPO1  := oGrid:GetValue("RR_TIPO1")
			RGB -> RGB_HORAS  := oGrid:GetValue("RR_HORAS")
			RGB -> RGB_VALOR  := oGrid:GetValue("RR_VALOR")
			RGB -> RGB_TIPO2  := oGrid:GetValue("RR_TIPO2")
			RGB -> RGB_DTREF  := oGrid:GetValue("RR_DATAPAG")
			RGB -> RGB_PROCES := SRA->RA_PROCES
			RGB -> RGB_PERIOD := cPeriodo
			RGB -> RGB_ROTEIR := "FOL" // lançamento sempre na folha
			RGB -> RGB_SEMANA := oGrid:GetValue("RR_SEMANA")
			RGB -> RGB_CC  	  := SRA->RA_CC
			RGB -> RGB_ITEM   := oGrid:GetValue("RR_ITEM")
			RGB -> RGB_CLVL   := oGrid:GetValue("RR_CLVL")
		MsUnlock()
	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fObitoWhen
Função usada no X3_WHEN do campo RG_OBITO para que fique abilitado
apenas quando motivo de desligamento for igual a 10 - RESCISÃO POR
FALECIMENTO DO EMPREGADO
@author  Rafael Reis
@since   26/09/18
@version 1
/*/
//-------------------------------------------------------------------
Function fObitoWhen()
Local lRet	:= .F.
Local nPos	:= 0
Local cTipo	:= ""

If !Empty(M->RG_TIPORES)
	If ( nPos := fPosTab("S043", M->RG_TIPORES , "=", 4 )) > 0
		cTipo := fTabela("S043", nPos, 33)
		If ValType(cTipo) == "C"
			lRet := Alltrim(cTipo) $ 'A'
		EndIf
	EndIf
Endif
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fObtVld
Função responsável por validar preenchimento do campo RG_OBITO de acordo
com padrão de certidões estabelecido para Registro Civil das Pessoas
Naturais
@author  Rafael Reis
@since   26/09/18
@version 1
/*/
//-------------------------------------------------------------------
Function fObtVld()
Local lRet := .T.
If !Empty(M->RG_OBITO)
	If !Len(M->RG_OBITO) == 32 .OR. !SubStr( M->RG_OBITO ,15, 1) $ '4/7'
		lRet := .F.
		Help(NIL, NIL, OemToAnsi(STR0020) , NIL, "Formato de Certidão de Óbito inválido.", 1, 0, NIL, NIL, NIL, NIL, NIL, {"Informe a Certidão de acordo com o Padrão estabelecido para Registro Civil das Pessoas Naturais."})
	Endif
Endif
Return lRet
/*/{Protheus.doc} fPVarSuces
Função responsável por alterar a picture do campo RG_SUCES
Este campo pode ser preenchido com um CNPJ ou um CPF.
@author  Claudinei Soares
@since   10/12/2018
@version 1
/*/

Function fPVarSuces()

Local cPict := "@R NN.NNN.NNN/NNNN-NN"

If SRG->(ColumnPos( 'RG_TPSU' ) ) > 0
	If M->RG_TPSU == "2"
		cPict := "@R 999.999.999-99"
	Else
		cPict := "@R NN.NNN.NNN/NNNN-NN"
	Endif
Endif

cPict := cPict + "%C"

Return cPict

//-------------------------------------------------------------------
/*/{Protheus.doc} fAlertJob
Função para exibição de alerta e link para o TDN com orientação sobre
envio de afastamentos
@author  Rafael Reis
@since   26/10/2018
@version 1
/*/
//-------------------------------------------------------------------
Static Function fAlertJob()
Local oButton1
Local oButton2
Local oCheckBo1
Local lCheckBo1 := .F.
Local oGroup1
Local oPanel1
Local oSay1
Local cSession	:= "AlertaComplementar"
Local lChkMsg := fwGetProfString(cSession,"MSG_JOBCOMPL_" + cUserName,'',.T.) == ""
Static oDlg

If lChkMsg

	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0241) FROM 000, 000  TO 200, 500 COLORS 0, 16777215 PIXEL //#STR0241 = "Rescisão Complementar"

		@ 000, 000 MSPANEL oPanel1 SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
		@ 005, 012 GROUP oGroup1 TO 055, 237 PROMPT OemToAnsi(STR0020) OF oPanel1 COLOR 0, 16777215 PIXEL //#STR0020 = "Atenção"
		@ 022, 017 SAY oSay1 PROMPT OemToAnsi(STR0242) SIZE 215, 025 OF oPanel1 COLORS 0, 16777215 PIXEL //#STR0242 = 'Foi criada a opção Retificação, que irá retificar os eventos S-2299/S-2399 do eSocial. Clique em "Abrir Link" para consultar a documentação no TDN'
		@ 080, 012 CHECKBOX oCheckBo1 VAR lCheckBo1 PROMPT OEMToAnsi(STR0243) SIZE 067, 008 OF oPanel1 COLORS 0, 16777215 PIXEL //#STR0243 = "Não exibir novamente"
		@ 070, 160 BUTTON oButton1 PROMPT "Abrir Link" SIZE 037, 012 OF oPanel1 PIXEL
		@ 070, 200 BUTTON oButton2 PROMPT "OK" SIZE 037, 012 OF oPanel1 PIXEL

		oButton1:bLClicked := {|| ShellExecute("open","http://tdn.totvs.com/x/ewCmGg","","",1) }
		oButton2:bLClicked := {|| oDlg:End() }

	ACTIVATE MSDIALOG oDlg CENTERED

	If lCheckBo1
		fwWriteProfString(cSession,"MSG_JOBCOMPL_" + cUserName, 'CHECKED', .T.)
	Endif

Endif

Return

/*/{Protheus.doc} fExisTitRe
//Verifica se existe titulo para a rescisão
@author paulo.inzonha
@since 22/01/2019
@version 1.0
@return Logico, Retorna .T. se encontrou o titulo e .F. se não encontrou
@type function
/*/
Function fExisTitRe()
Local lRet 		 := .F.
Local cCtrlTit	 := ""
Local nIndex	 := 0

DEFAULT lCtrlTit := ChkFile("RJ1") .And. !Empty(GetNewPar("MV_BTITRES", "" )) .And. RJ1->(ColumnPos( "RJ1_ROTEIR")) > 0 .And. RJ1->(ColumnPos( "RJ1_PROCES")) > 0 .And. RJ1->(ColumnPos( "RJ1_TIPO")) > 0

// Possui dados atualizados para Integ. Títulos por Roteiros de Cálculo completo (RES/FER/ADI/FOL)
If lCtrlTit
	// Utiliza conteúdo do parâmetro MV_BTITRES (variavel cCtrlTit)
	// 0 - Não realiza tratamento
	// 1 - Exibe mensagem para o usuário mas não bloqueia, usuário escolhe prosseguir ou não - gera log com Títulos
	// 2 - Exibe mensagem para o usuário e bloqueia - gera log com Títulos
	cCtrlTit := SuperGetMv("MV_BTITRES",,"0")
	If cCtrlTit == "0"
		lRet := .F.
	ElseIf cCtrlTit $ "1*2"
		If TCCanOpen(RetSqlname("RJ1")) .And. !Empty(RJ1->(INDEXKEY(3)))

			nIndex := Retorder("RJ1","RJ1_FILIAL+RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT")

			dbSelectArea("RJ1")
			RJ1->(dbSetOrder(nIndex)) // RJ1_FILIAL+ RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT
			If RJ1->(dbSeek(SRG->RG_FILIAL+SRG->RG_PROCES+SRG->RG_ROTEIR+SRG->RG_PERIODO+SRG->RG_SEMANA+DTOS(SRG->RG_DTGERAR)+SRG->RG_FILIAL+SRG->RG_MAT))
				aAdd( aLogErros, OemToAnsi(STR0289) + OemToAnsi(STR0285) ) // "Existe Título(s) gerado(s) sobre essa rescisão"###"Consulte o(s) Título(s) abaixo em Manutenção de Títulos:"
				While RJ1->(!Eof()) .And. (	RJ1->RJ1_FILIAL+RJ1->RJ1_PROCES+RJ1->RJ1_ROTEIR+RJ1->RJ1_PERIOD+RJ1->RJ1_SEMANA+DTOS(RJ1->RJ1_DTGERA)+RJ1->RJ1_FILFUN+RJ1->RJ1_MAT == SRG->RG_FILIAL+SRG->RG_PROCES+SRG->RG_ROTEIR+SRG->RG_PERIODO+SRG->RG_SEMANA+DTOS(SRG->RG_DTGERAR)+SRG->RG_FILIAL+SRG->RG_MAT )
					aAdd( aLogErros, OemToAnsi(STR0078) + RJ1->RJ1_FILIAL + " " + OemToAnsi(STR0287) + RJ1->RJ1_NUMTIT ) // Filial:###Número do Título:
					("RJ1")->(DbSkip())
				EndDo

				lRet := Iif(cCtrlTit == "1", !MsgNoYes(OemToAnsi(STR0289) + OemToAnsi(STR0245),OemToAnsi(STR0020)), .T.) //"Existe Título(s) gerado(s) sobre essa rescisão. A Exclusão ou Recálculo da Rescisão sem a exclusão do título anterior pode gerar duplicidade de titulos. Deseja Continuar?"                                                                                                                                                                                                                                                                                                                                                                                      "

			EndIf
			RJ1->(dbCloseArea())
		EndIf
	EndIf
EndIf

Return lRet

/*/{Protheus.doc} GPM040VLD
Classe de evento do MVC - Validação do Cálculo de Rescisão.

@author  Leandro Drumond
@since   05/04/2019
@type    Class
@version 12.1.17
/*/
//-------------------------------------------------------------------------------------------------------------
Class GPM040VLD FROM FWModelEvent

	Data lRet
	Method new()
	Method ModelPosVld()
	Method DeActivate()

End Class

Method new() Class GPM040VLD

Return

Method DeActivate() Class GPM040VLD
	If Type("cFilOld") != "U" //qdo vem da carga inicial do eai
		cFilAnt := cFilOld

		If !lTCFA040 .and. lAtuBrowse
			oBrowseUp:Refresh()
			oBrowseDwn:Refresh()
		EndIf
	EndIf
	fDelTMPMED()
Return

Method ModelPosVld(oModel, cModelId) Class GPM040VLD
	lRet:= fTudoOKM40(oModel)
Return lRet


/*/{Protheus.doc} fBuscaRHH()
Função responsável por verificar se o funcionário possui dissídio retroativo calculado
@type function
@author Claudinei Soares
@since 06/05/2019
@version 1.0
@param cFilRHH 		= Filial a ser pesquisada na tabela RHH
@param cMatRHH 		= Matrícula a ser pesquisada na tabela RHH
@param cPerRHH 		= Período do cálculo da rescisão
@return lRet, Lógico, Retorno da função, se verdadeiro o funcionário possui dissídio calulado
/*/

Function fBuscaRHH(cFilRHH, cMatRHH, cPerRHH)

Local lRet	:= .F.
Local aArea	:= GetArea()

dbSelectArea("RHH")
RHH->( dbSetOrder(1) )

If RHH->( dbSeek( xFilial("RHH", cFilRHH) + cMatRHH + cPerRHH ) )
	lRet := .T.
Endif

RestArea(aArea)

Return lRet

/*/{Protheus.doc} RescAntView
Monta browse para visualização das rescisões complementares anteriores

@author  Leandro Drumond
@since   09/09/2019
@type    function
@version 1.0
/*/
Function RescAntView()

Local aRescAnt := {}
Local aArea	   := GetArea()
Local aAreaSRG := SRG->(GetArea())
Local aAreaSRR := SRR->(GetArea())
Local aAreaSRA := SRA->(GetArea())
Local cTpResc  := ""
Local dDataGer := CtoD("")

DbSelectArea("SRR")
DbSetOrder(1) //RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC

dbSelectArea( "SRG" )
DbSetOrder(1) //RG_FILIAL+RG_MAT+DTOS(RG_DTGERAR)

dbSeek(SRA->RA_FILIAL+SRA->RA_MAT)
While SRG->( !Eof() .And. RG_FILIAL+RG_MAT == SRA->RA_FILIAL+SRA->RA_MAT )
	cTpResc := STR0254 //"Normal"
	If SRG->RG_RESCDIS == "3"
		cTpResc := STR0255 //"Retificadora"
	ElseIf SRG->RG_RESCDIS == "2"
		cTpResc := STR0256 //"Dissídio"
	ElseIf SRG->RG_RESCDIS == "1"
		If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[151,1])) //Verifica se foi pago PLR
			cTpResc := STR0257 //"PLR"
		Else
			cTpResc := STR0116 //"Complementar"
		EndIf
	EndIf
	aAdd(aRescAnt, { SRG->RG_DATADEM, SRG->RG_DTGERAR, SRG->RG_DATAHOM, cTpResc })
	SRG->(dbSkip())
EndDo

Begin Sequence

	If Len(aRescAnt) > 1
		If !fSeleResc(aRescAnt,@dDataGer)
			Break
		EndIf
	ElseIf Len(aRescAnt) == 1
		dDataGer := aRescAnt[1,2]
	EndIf

	If !Empty(dDataGer)
		SRG->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+DTOS(dDataGer)))
		FWExecView("", "GPEM040", MODEL_OPERATION_VIEW,,{||.T.},,50)
	EndIf

End Sequence

RestArea(aAreaSRG)
RestArea(aAreaSRR)
RestArea(aAreaSRA)
RestArea(aArea)

Return Nil

/*/{Protheus.doc} fSeleResc
Monta browse para seleção das rescisões complementares anteriores

@author  Leandro Drumond
@since   09/09/2019
@type    function
@version 1.0
/*/
Static Function fSeleResc(aLbxF,dDataGera)
Local aObjCoords	:= {}
Local aAdvSize		:= {}
Local aObjSize		:= {}
Local aInfoAdvSize	:= {}
Local lOK      		:= .F.
Local nPosLbxF		:= 0
Local oDlg
Local oLbxF

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta as Dimensoes dos Objetos         					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdvSize	:= MsAdvSize(,.T.,180)
aInfoAdvSize:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. , .T. } )
aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

oDlg := MSDialog():New(aAdvSize[7],0,aAdvSize[6]*0.9,aAdvSize[5],STR0258,,,,,,,,,.T.) //"Selecione a Rescisão"

	@ aObjSize[1,1]-20 , aObjSize[1,2] LISTBOX oLbxF FIELDS HEADER 	OemToAnsi(GetSx3Cache("RG_DATADEM","X3_TITULO")),; 	//"Data de Demissão"
																	OemToAnsi(GetSx3Cache("RG_DTGERAR","X3_TITULO")),;  //"Data de Geração"
																	OemToAnsi(GetSx3Cache("RG_DATAHOM","X3_TITULO")),;  //"Data de Homologação"
																	OemToAnsi(GetSx3Cache("RG_RESCDIS","X3_TITULO"));   //"Tipo de Rescisão"
													 FIELDSIZES 45,45,45,45;
													 SIZE aObjSize[1,3] , aObjSize[1,4]*0.7;
										OF oDlg PIXEL ON DBLCLICK ( lOk := .T., nPosLbxF:=oLbxF:nAt,oDlg:End() )

	oLbxF:SetArray(aLbxF)
	oLbxF:bLine := { || {aLbxF[oLbxF:nAt,1],aLbxF[oLbxF:nAt,2],aLbxF[oLbxF:nAt,3],aLbxF[oLbxF:nAt,4]}}

	TButton():New( aObjSize[1,4]*0.9, aObjSize[1,3]*0.87, STR0259, oDlg, {|| lOk := .T.,nPosLbxF:=oLbxF:nAt, oDlg:End()},aObjSize[1,3] - (aObjSize[1,3]*0.87),20,,,,.T.) //"Abrir"

oDlg:Activate()

If lOk
	dDataGera := aLbxF[nPosLbxF,2]
EndIf

Return( lOk )

/*/{Protheus.doc} fDelHist
/Delete historico de medias
@author flavio.scorrea
@since 23/10/2019
/*/
Static Function fDelHist(lDel, oView)
Local lHistMed		:= AliasInDic("RJK") .And. AliasInDic("SRP")

DEFAULT __lMemCalc  := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc() // Memória de Cálculo

If (lDel .Or. (oView:GetModel():nOperation != 1 .And. oView:GetModel():nOperation != 5) )
	If lHistMed .And. Empty(cIdHistMed)
		If fTemHMed(M->RG_DTGERAR,,M->RG_PERIODO,M->RG_SEMANA,M->RG_ROTEIR)
			cIdHistMed := RJK->RJK_ID
		Endif
	EndIf
	If lHistMed .And. !Empty(cIdHistMed)
		fDelHMedId(cIdHistMed)
	EndIf
	If !lDel .and. __lMemCalc //Exclui informações da memória de cálculo, quando existir
		fDelMemCalc(M->RG_FILIAL, M->RG_MAT, M->RG_PROCES, M->RG_PERIODO, M->RG_ROTEIR, M->RG_SEMANA)
	EndIf
EndIf

Return

/*/{Protheus.doc} fVldSabDom
/Atualiza variável lSabDom
@author Leandro Drumond
@since 12/11/2019
/*/
Function fVldSabDom()

Local oModel := FWModelActive()
Local cVar 	 := oModel:GetValue("GPEM040_MSRG","RG_SABDOM")

lSabDom := cVar == "1"

Return .T.

/*/
 {Protheus.doc} fSRetDes
Função responsavel por retornar a descrição do tipo de rescisão.

@type		Function
@author		Silvio César Stecca
@since		19/02/2020
@version	12
@param
@return 	cDescResc, Caracter, Retorno da função, retorna a descrição do tipo de rescisão.
/*/
Function fSRetDes()

	Local cDescResc := ""
	Local oModel	:= FWModelActive()
	Local cTpResc	:= Iif(Empty(oModel:GetValue("GPEM040_MSRG", "RG_RESCDIS")), "0", oModel:GetValue("GPEM040_MSRG", "RG_RESCDIS"))

	Do Case
		Case cTpResc == '0'
			cDescResc := OemToAnsi(STR0254) // "Normal"

		Case cTpResc == '1'
			cDescResc := OemToAnsi(STR0116) // "Complementar"

		Case cTpResc == '2'
			cDescResc := OemToAnsi(STR0118) // "Complementar por Dissidio"

		OtherWise
			cDescResc := OemToAnsi(STR0240) // "Retificação"
	EndCase

Return cDescResc

/*/{Protheus.doc} fTemIdResc
Verifica se na rescisao original tem novos id's de adicionais
@since 09/04/2020
/*/
Function fTemIdResc( cFilMat  , aSrgRecnos )

Local aArea		:= GetArea()
Local dDataGer	:= Ctod("//")
Local nVezes	:= Len( aSrgRecnos )
Local nV		:= 1
Local aCampos 	:= {"RA_PERICUL","RA_INSMAX","RA_ADCCONF", "RA_ADCTRF","RA_ADTPOSE"}
Local aAdics    := {SRA->RA_PERICUL > 0, SRA->RA_INSMAX > 0,  SRA->RA_ADCCONF > 0 , SRA->RA_ADCTRF > 0, !("N" $ SRA->RA_ADTPOSE) }
Local nX        := 0
//Novos adicionais rescisão.
Local cIdsADI   := aCodFol[1680,1] + "/" + aCodFol[1681,1] + "/" + aCodFol[1682,1] + "/" + aCodFol[1683,1] + "/" + aCodFol[1684,1] + "/" +;
					   aCodFol[1685,1] + "/" + aCodFol[1686,1] + "/" + aCodFol[1687,1] + "/" + aCodFol[1688,1] + "/" + aCodFol[1689,1] + "/" +;
					   aCodFol[1690,1] + "/" + aCodFol[1691,1] + "/" + aCodFol[1692,1] + "/" + aCodFol[1693,1] + "/" + aCodFol[1694,1] + "/" +;
					   aCodFol[1695,1] + "/" + aCodFol[1696,1] + "/" + aCodFol[1697,1] + "/" + aCodFol[1698,1] + "/" + aCodFol[1699,1] + "/" +;
					   aCodFol[1700,1] + "/" + aCodFol[1701,1] + "/" + aCodFol[1702,1] + "/" + aCodFol[1703,1] + "/" + aCodFol[1704,1] + "/" +;
					   aCodFol[1705,1] + "/" + aCodFol[1706,1] + "/" + aCodFol[1707,1] + "/" + aCodFol[1708,1] + "/" + aCodFol[1709,1] + "/" +;
					   aCodFol[1710,1] + "/" + aCodFol[1711,1] + "/" + aCodFol[1712,1] + "/" + aCodFol[1713,1] + "/" + aCodFol[1714,1] + "/" +;
					   aCodFol[1715,1] + "/" + aCodFol[1716,1] + "/" + aCodFol[1717,1] + "/" + aCodFol[1718,1] + "/" + aCodFol[1719,1] + "/" +;
					   aCodFol[1720,1] + "/" + aCodFol[1721,1]

LTEMIDRESC 	:= .F.

SRR->(DbSetOrder(3))

For nV := 1 To nVezes
	dDataGer	:= aSrgRecnos[ nV , 02 ]
	If SRR->( dbSeek( cFilMat + "R" + Dtos( dDataGer ) ) )
		While SRR->( !Eof() .and. RR_FILIAL + RR_MAT + RR_TIPO3 + Dtos( RR_DATA ) == cFilMat + "R" + Dtos( dDataGer ) )
			If SRR->RR_PD $ cIdsADI
				LTEMIDRESC := .T.
				exit
			EndIf
			SRR->( dbSkip() )
		EndDo
	EndIf

	For nX := 1 To Len(aCampos)
		If aAdics[nX] .And. !LTEMIDRESC 
			If SR9->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + aCampos[nX]))
				While SR9->(!Eof()) .And. SRA->RA_FILIAL + SRA->RA_MAT  == SR9->R9_FILIAL + SR9->R9_MAT .And. aCampos[nX] $ SR9->R9_CAMPO
					If AnoMes(dDataGer) >= AnoMes(SR9->R9_DATA) .And. (Val(StrTran(SR9->R9_DESC,",",".")) > 0 .Or. (aAdics[5] .And. !("N" $ SR9->R9_DESC)))
						LTEMIDRESC := .T.	
						Exit
					EndIf
					SR9->(DbSkip())		
				EndDo				 		
			EndIf
		EndIf
	Next nX
Next nV

RestaRea(aArea)
Return

/*/{Protheus.doc} fUpdAtBrw
Atualiza o conteúdo da variável static lAtuBrowse
@since 14/05/2020
/*/
Function fUpdAtBrw( lCont )

lAtuBrowse := lCont

Return

/*/{Protheus.doc} fCtrTitLg
Imprime log com títulos existentes do funcionário (quando existe controle de títulos na base MV_BTITRES igual a 1 ou 2)
@author		raquel.anrade
@since		04/08/2020
@version 1.0
/*/
Static Function fCtrTitLg()
Local aLog			:= {}
Local aTitleLog		:= {}
Local nX			:= 0
Local nPosLog		:= 0
Local lRet			:= .T.

lCtrlTit		:= ChkFile("RJ1") .And. !Empty(GetNewPar("MV_BTITRES", "" )) .And. RJ1->(ColumnPos( "RJ1_ROTEIR")) > 0 .And. RJ1->(ColumnPos( "RJ1_PROCES")) > 0 .And. RJ1->(ColumnPos( "RJ1_TIPO")) > 0

If lCtrlTit .And. Len( aLogErros ) > 0
	If Empty( aLog )
		aAdd( aTitleLog, STR0058 )	//"Log de Ocorrencias do Calculo de Rescisao"
		aAdd( aLog, {} )
	EndIf

	nPosLog := Len( aLog )
	For nX := 1 To Len( aLogErros )
		aAdd( aLog[ nPosLog ], aLogErros[ nX ] )
	Next nX

	If !IsBlind()
		MsAguarde( { || fMakeLog( aLog , aTitleLog , "GPEM040" , NIL , FunName() , STR0058 ) } ,  STR0058 ) //"Log de Ocorrencias do Cálculo de Rescisao"
		aLog		:= {}
		aLogErros	:= {}
	EndIf
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fAlert936
Função para exibição de alerta e link para o TDN com orientação sobre multa da MP 936/2020
@author  allyson.mesashi
@since   24/09/2020
@version 1
/*/
//-------------------------------------------------------------------
Static Function fAlert936( nOpc )
Local oButton1
Local oButton2
Local oCheckBo1
Local lCheckBo1 := .F.
Local oGroup1
Local oPanel1
Local oSay1
Local cSession	:= "Alerta936"
Local cVar		:= ""
Local lChkMsg 	:= fwGetProfString(cSession, "MSG_MULT936_" + cUserName,'',.T.) == ""
Local oDlg

Default nOpc	:= 2

If nOpc == 1
	cVar := "MSG_MULT936A_"
Else
	cVar := "MSG_MULT936B_"
EndIf
lChkMsg 	:= fwGetProfString(cSession, cVar + cUserName,'',.T.) == ""

If lChkMsg

	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0291) FROM 000, 000  TO 200, 500 COLORS 0, 16777215 PIXEL //#STR0291 = "Rescisão com estabilidade da MP 936/2020"

		@ 000, 000 MSPANEL oPanel1 SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
		@ 005, 012 GROUP oGroup1 TO 055, 237 PROMPT OemToAnsi(STR0020) OF oPanel1 COLOR 0, 16777215 PIXEL //#STR0020 = "Atenção"
		If nOpc == 1
			@ 022, 017 SAY oSay1 PROMPT OemToAnsi(STR0292) SIZE 215, 025 OF oPanel1 COLORS 0, 16777215 PIXEL //#STR0292 = 'É necessário possuir o campo RG_DTESTAB no dicionário de dados e cadastro de verba para o Id de cálculo 1853. Clique em "Abrir Link" para consultar a documentação no TDN'
		Else
			@ 022, 017 SAY oSay1 PROMPT OemToAnsi(STR0293) SIZE 215, 025 OF oPanel1 COLORS 0, 16777215 PIXEL //#STR0293 = 'Clique em "Abrir Link" para consultar a documentação no TDN com a explicação dos cálculos realizados pelo sistema'
		EndIf
		@ 080, 012 CHECKBOX oCheckBo1 VAR lCheckBo1 PROMPT OEMToAnsi(STR0243) SIZE 067, 008 OF oPanel1 COLORS 0, 16777215 PIXEL //#STR0243 = "Não exibir novamente"
		@ 070, 160 BUTTON oButton1 PROMPT "Abrir Link" SIZE 037, 012 OF oPanel1 PIXEL
		@ 070, 200 BUTTON oButton2 PROMPT "OK" SIZE 037, 012 OF oPanel1 PIXEL

		oButton1:bLClicked := {|| ShellExecute("open","https://tdn.totvs.com/x/uVmVIQ","","",1) }
		oButton2:bLClicked := {|| oDlg:End() }

	ACTIVATE MSDIALOG oDlg CENTERED

	If lCheckBo1
		fwWriteProfString(cSession, cVar + cUserName, 'CHECKED', .T.)
	Endif

Endif

Return

/*/{Protheus.doc} fDelRAZRAW
Função para excluir os registros gerados na RAZ/RAW quando funcionário possui multiplos vínculos
@author  Leandro Drumond
@since   21/09/2021
@version 1
/*/
Static Function fDelRAZRAW()

dbSelectArea("RAW")
RAW->(dbSetOrder(1))//RAW_FILIAL, RAW_MAT, RAW_FOLMES, RAW_TPFOL, RAW_PROCES, RAW_ROTEIR, RAW_SEMANA

If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + "1" + SRA->RA_PROCES + fGetCalcRot("4"))
	RecLock("RAW",.F.)
	DbDelete()
	MsUnLock()

	dbSelectArea("RAZ")
	RAZ->(DbSetOrder(1))//RAZ_FILIAL+RAZ_MAT+RAZ_FOLMES+RAZ_TPFOL+RAZ_INSCR

	If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + "1")
		RecLock("RAZ",.F.)
		DbDelete()
		MsUnLock()
	EndIf
EndIf

Return Nil

/*/{Protheus.doc} fBusSRKDis
Função para verificar se o funcionário possui lançamentos não quitados de dissídio retroativo calculado em período anterior
@author  Julio Silva
@since   04/11/2021
@version 1
/*/

Function fBusSRKDis()

	Local aArea := getArea()
	Local lRet := .F.

	DbSelectArea("SRK")
	SRK->( dbSetOrder(1) )
	If SRK->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT ) )
		While SRK->( !EoF() .And. SRK->RK_FILIAL+SRK->RK_MAT == SRA->RA_FILIAL+SRA->RA_MAT  )
			If !Empty(SRK->RK_NUMID) .And. !Empty(SRK->RK_MESDISS) .And. SRK->RK_STATUS == "2"
				If fBuscaRHH(SRA->RA_FILIAL, SRA->RA_MAT,  SRK->RK_PERINI+SubStr(SRK->RK_MESDISS,3)+SubStr(SRK->RK_MESDISS,1,2))
					lRet := .T.
					Exit
				EndIf
			EndIf
			SRK->( dbSkip() )
		EndDo
	EndIf

	RestaRea(aArea)

Return lRet

/*/{Protheus.doc} fRescToRJP
Processo para enviar os dados para integração (NG - Quirons) Tabela RJP.
@since	02/12/2021
@autor	martins.marcio
@version 1.0
/*/
Function fRescToRJP(cOperacao)

	Local aArea		:= GetArea()
	Local dDtBase   := dDataBase
	Local cHoraAt   := Time()
	Local cTmpEmp   := cEmpAnt
	Local cProces   := "SRA"
	Local cUserId   := SubStr(cUsuario,7,15)
	Local cTmpMat   := SRA->RA_MAT
	Local cTmpFil   := xFilial ("SRA")
	Local cChave    := cTmpEmp + "|" + cTmpFil + "|" + cTmpMat
	Local lApagou	:= .F.

	DEFAULT cOperacao	:= "D"
	
	If cOperacao == "D" 
		fSetInforRJP(cTmpFil, cTmpMat, cProces, cChave, cOperacao, dDtBase, cHoraAt, cUserId )
	ElseIf cOperacao == "E" //Exclusão do Cálculo de Rescisão
		DBSelectArea("RJP")
		RJP->(DBSetOrder(7))
		If (RJP->(DBSeek(xFilial("RJP")+cProces+cChave)))
			While RJP->RJP_FILIAL== xFilial("RJP") .AND. RJP->RJP_TAB == cProces .AND. RJP->RJP_FIL == cTmpFil ;
				.AND. ( RJP->RJP_OPER == "D" ) .AND. AllTrim(RJP->RJP_KEY) == AllTrim(cChave)

				// Apaga a informação da rescisão na tabala RJP caso esteja pendente de integração
				If Empty(RJP->RJP_DTIN)	
					If RecLock("RJP",.F.)
						RJP->(DbDelete())
						RJP->(MsUnlock())
						lApagou := .T.
					EndIf
				EndIf
				RJP->(DBSkip())
			EndDo
			// Caso a Rescisão já tenha sido integrada com o Quirons, registra a volta do funcionário para ativo na tabela RJP 
			If !lApagou
				fSetInforRJP(cTmpFil, cTmpMat, cProces, cChave, "A", dDtBase, cHoraAt, cUserId )
			EndIf
		Endif
	EndIf

	RestArea(aArea)

Return (.T.)

/*/{Protheus.doc} fGetPergunte
Preenche o mnemonico aPergunte com os dados da consulta de beneficios
@since	22/08/2022
@autor	Leandro Drumond
@version 1.0
/*/
Function fGetPergunte(aPergunte,cPerg)

Local oSX1  := FWSX1Util():New()

If lPergBenef
	MsgInfo(STR0308) //"Serão recalculados os beneficios para desconto conforme parametrização do tipo de rescisão e do mnemônico P_DESCBEN."
	lPergBenef := .F.
EndIf

Pergunte(cPerg, .T.)

oSX1:AddGroup(cPerg)
oSX1:SearchGroup()

aEval(oSX1:aGrupo[1,2],{|x| aAdd(aPergunte, {x:cX1_VAR01, AllTrim(x:cX1_PERGUNT), &(x:cX1_VAR01), x:cX1_TIPO, 10})})

FreeObj(oSX1)

Return Nil

/*/{Protheus.doc} fLogBenef
Log de erro no cálculo de beneficios
@since	22/08/2022
@autor	Leandro Drumond
@version 1.0
/*/
Function fLogBenef()
Local aLogInit 		:= {}
Local aTitleLog		:= {}
Local aLog			:= {}
Local nX 			:= 0

cFilCalc 	:= ""
lErrExecRot	:= .T.

//Carregando Informacoes para o Log
aLogInit := LogExecRot()
For nX := 1 To Len( aLogInit )
	If !Empty(aLogInit[ nX, 2 ])
		If nX == 1
			aAdd( aTitleLog, STR0054 ) //"Erro de Carga de Mnemonicos"
		ElseIf nX == 2
			aAdd( aTitleLog, STR0055 ) //"Erro de Carga de Formulas"
		ElseIf nX == 3
		aAdd( aTitleLog, STR0056 ) //"Ocorreu erro na compilacao ou Execucao do Roteiro"
		ElseIf nX == 4
			aAdd( aTitleLog, STR0306 ) //"Erros ocasionados durante o Calculo dos Benefícios"
		EndIf
		aAdd( aLog, aLogInit[nX, 2] )
	EndIf
Next nX

If !Empty( aLog )
	//Mostrar o Log
	MsAguarde( { || fMakeLog( aLog , aTitleLog , "GPEM040" , NIL , FunName() , STR0307 ) } ,  STR0307 ) //"Log de Ocorrencias do Calculo de Benefícios"
EndIf

RstExecCalc()

Return Nil

/*/{Protheus.doc} fCompPLR
Log de erro no cálculo de beneficios
@since	29/08/2022
@autor	Leandro Drumond
/*/
Static Function fCompPLR()

Local aAreaSRR	:= SRR->( GetArea() )
Local lCompPLR	:= .F.

SRR->( dbSetOrder(1) )//RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC
If SRR->( dbSeek( SRG->RG_FILIAL + SRG->RG_MAT + "R" + dToS(SRG->RG_DTGERAR) + aCodFol[151, 1] ) ) //Verifica se foi pago PLR
	lCompPLR := .T.
EndIf

RestArea( aAreaSRR )

Return lCompPLR


/*/{Protheus.doc} fObtDVacV()
Obtener vacaciones vencidas cuando el empleado está inactivo
@since	26/09/2022
@autor	Laura Medina
@param
@return nDiasVacV, Numerico, Retorna los días de vacaciones vencidas
/*/
Function fObtDVacV()
Local nDiasVacV := 0

//Empleado inactivo (opción INCLUIR)
If  !Empty(SRA->RA_DEMISSA) .And. SRA->RA_SITFOLH == 'D'
	fVAC_RESM2(@nDiasVacV,1)
ENDIF

Return nDiasVacV

/*/{Protheus.doc} fGrv1904
Efetua gravação da verba de ID 1904 no roteiro 132 de semana 02
@autor Allyson Luiz Mesashi
@since 07/12/2022
/*/
Static Function fGrv1904( nVal1904 )

Local aArea		:= ( GetArea() )
Local aAreaRCF	:= RCF->( GetArea() )
Local aAreaRCG	:= RCG->( GetArea() )
Local aAreaRCH	:= RCH->( GetArea() )
Local aAreaRFQ	:= RFQ->( GetArea() )
Local aAreaSRC	:= SRC->( GetArea() )
Local cRot132	:= fGetCalcRot('6')
Local dDataFim 	:= LastDate( sToD( cPeriodo+"01" ) )
Local dDataIni 	:= sToD( cPeriodo+"01" )
Local dDtPag	:= cToD("//")

RCF->( dbSetOrder(4) )//RCF_FILIAL+RCF_PER+RCF_SEMANA+RCF_ANO+RCF_MES+RCF_PROCES+RCF_ROTEIR+RCF_TNOTRA+DTOS(RCF_DTINI)+DTOS(RCF_DTFIM)+RCF_MODULO
RCG->( dbSetOrder(2) )//RCG_FILIAL+RCG_PROCES+RCG_PER+RCG_SEMANA+RCG_ROTEIR+RCG_TNOTRA+DTOS(RCG_DIAMES)
RCH->( dbSetOrder(4) )//RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG
RFQ->( dbSetOrder(1) )//RFQ_FILIAL+RFQ_PROCES+RFQ_PERIOD+RFQ_NUMPAG+DTOS(RFQ_DTINI)+DTOS(RFQ_DTFIM)+RFQ_MODULO
SRC->( dbSetOrder(4) )//RC_FILIAL+RC_MAT+RC_PERIODO+RC_ROTEIR+RC_SEMANA+RC_PD

fGrvRFQ( dDataIni, dDataFim )
fGrvRCH( cRot132, dDataIni, dDataFim, @dDtPag )
fGrvRCF( dDataIni, dDataFim )
fGrvRCG( dDataIni, dDataFim )
fGrvSRC( cRot132, dDataFim, dDtPag, nVal1904 )

RestArea( aAreaRCF )
RestArea( aAreaRCG )
RestArea( aAreaRCH )
RestArea( aAreaRFQ )
RestArea( aAreaSRC )
RestArea( aArea )

Return

/*/{Protheus.doc} fGrvRFQ
Função que copia os dados da tabela RFQ
@autor Allyson Luiz Mesashi
@since 07/12/2022
/*/
Static Function fGrvRFQ( dDataIni, dDataFim )

Local cAno		:= SubStr(cPeriodo, 1, 4)
Local cChavePes	:= xFilial("RFQ", SRA->RA_FILIAL) + SRA->RA_PROCES + cPeriodo + "02"
Local cMes		:= SubStr(cPeriodo, 5, 2)

If !RFQ->( dbSeek( cChavePes ) ) .And. RFQ->( Reclock("RFQ", .T.) )
	RFQ->RFQ_FILIAL	:= xFilial("RFQ", SRA->RA_FILIAL)
	RFQ->RFQ_PROCES	:= SRA->RA_PROCES
	RFQ->RFQ_MES   	:= cMes
	RFQ->RFQ_ANO   	:= cAno
	RFQ->RFQ_PERIOD	:= cPeriodo
	RFQ->RFQ_NUMPAG	:= "02"
	RFQ->RFQ_DTINI 	:= dDataIni
	RFQ->RFQ_DTFIM 	:= dDataFim
	RFQ->RFQ_MODULO	:= "GPE"
	RFQ->RFQ_STATUS := "1"
	RFQ->( MsUnlock() )
EndIf

Return

/*/{Protheus.doc} fGrvRCH
Função que grava novo período (tabela RCH)
@autor Allyson Luiz Mesashi
@since 07/12/2022
/*/
Static Function fGrvRCH( cRot132, dDataIni, dDataFim, dDtPag )

Local cAno		:= SubStr(cPeriodo, 1, 4)
Local cChavePes	:= xFilial("RCH", SRA->RA_FILIAL) + SRA->RA_PROCES + cRot132 + cPeriodo
Local cMes		:= SubStr(cPeriodo, 5, 2)

If RCH->( DbSeek( cChavePes ) )
	While RCH->( !EoF() ) .And. RCH->RCH_FILIAL+RCH->RCH_PROCES+RCH->RCH_ROTEIR+RCH->RCH_PER == cChavePes
		dDtPag := RCH->RCH_DTPAGO
		RCH->( dbSkip() )
	EndDo
EndIf

cChavePes	:= xFilial("RCH", SRA->RA_FILIAL) + SRA->RA_PROCES + cRot132 + cPeriodo + "02"
If !RCH->( dbSeek( cChavePes ) ) .And. RCH->( Reclock("RCH", .T.) )
	RCH->RCH_FILIAL	:= xFilial("RCH", SRA->RA_FILIAL)
	RCH->RCH_PER	:= cPeriodo
	RCH->RCH_NUMPAG	:= "02"
	RCH->RCH_PROCES	:= SRA->RA_PROCES
	RCH->RCH_ROTEIR	:= cRot132
	RCH->RCH_MES   	:= cMes
	RCH->RCH_ANO   	:= cAno
	RCH->RCH_DTINI 	:= dDataIni
	RCH->RCH_DTFIM 	:= dDataFim
	RCH->RCH_DTPAGO	:= dDtPag
	RCH->RCH_PERSEL	:= "2"
	RCH->RCH_STATUS	:= "0"
	RCH->RCH_MODULO	:= "GPE"
	RCH->RCH_COMPL	:= "2"
	RCH->( MsUnlock() )
EndIf

Return

/*/{Protheus.doc} fGrvRCF
Função que copia os dados da tabela RCF
@autor Allyson Luiz Mesashi
@since 07/12/2022
/*/
Static Function fGrvRCF( dDataIni, dDataFim )

Local cAno		:= SubStr(cPeriodo, 1, 4)
Local cMes		:= SubStr(cPeriodo, 5, 2)
Local cChavePes	:= xFilial("RCF", SRA->RA_FILIAL) + cPeriodo + "02" + cAno + cMes + SRA->RA_PROCES + Space(3) + "@@@" + dToS(dDataIni) + dToS(dDataFim) + "GPE"
Local nUltDia   := f_UltDia(dDataIni)
Local nDiasCal  := IIf(GetMvRH("MV_DIASPER",,"1") == "1", nUltDia, 30)
Local nDiaTrab  := DateWorkDay(dDataIni, dDataFim)
Local nDiaNoTr  := ( dDataFim - dDataIni + 1 ) - nDiaTrab

If !RCF->( dbSeek( cChavePes ) ) .And. RCF->( Reclock("RCF", .T.) )
	RCF->RCF_FILIAL	:= xFilial("RCF", SRA->RA_FILIAL)
	RCF->RCF_MES   	:= cMes
	RCF->RCF_ANO   	:= cAno
	RCF->RCF_PER	:= cPeriodo
	RCF->RCF_PROCES	:= SRA->RA_PROCES
	RCF->RCF_TNOTRA	:= "@@@"
	RCF->RCF_SEMANA	:= "02"
	RCF->RCF_DTINI 	:= dDataIni
	RCF->RCF_DTFIM 	:= dDataFim
	RCF->RCF_DCALCM	:= nDiasCal
	RCF->RCF_DPERIO	:= Iif(dDataFim - dDataIni + 1 == f_UltDia(dDataIni), nDiasCal, dDataFim - dDataIni + 1)
	RCF->RCF_HRSDIA	:= 8
	RCF->RCF_DIADSR	:= nDiaNoTr / 2
	RCF->RCF_DUTEIS	:= RCF->RCF_DPERIO - RCF->RCF_DIADSR
	RCF->RCF_HRSDSR	:= ( nDiaNoTr / 2 ) * 8
	RCF->RCF_DIATRA	:= nDiaTrab
	RCF->RCF_HRSTRA	:= nDiaTrab * 8
	RCF->RCF_DNTRAB	:= nDiaNoTr / 2
	RCF->RCF_DUTILT	:= nDiaTrab
	RCF->RCF_DREFEI	:= nDiaTrab
	RCF->RCF_DALIM	:= nDiaTrab
	RCF->RCF_MODULO	:= "GPE"
	RCF->( MsUnlock() )
EndIf

Return

/*/{Protheus.doc} fGrvRCH
Função que copia os dados da tabela RCG
@autor Allyson Luiz Mesashi
@since 07/12/2022
/*/
Static Function fGrvRCG( dDataIni, dDataFim )

Local aColsRCG	:= fMontaRCG( dDataIni, dDataFim )
Local cAno		:= SubStr(cPeriodo, 1, 4)
Local cMes		:= SubStr(cPeriodo, 5, 2)
Local cChavePes	:= ""
Local nCont		:= 0

For nCont := 1 To Len(aColsRCG)
	cChavePes	:= xFilial("RCG", SRA->RA_FILIAL) + SRA->RA_PROCES + cPeriodo + "02" + Space(3) + "@@@" + dToS(aColsRCG[nCont, 1])
	If !RCG->( dbSeek( cChavePes ) ) .And. RCG->( Reclock("RCG", .T.) )
		RCG->RCG_FILIAL	:= xFilial("RCG", SRA->RA_FILIAL)
		RCG->RCG_MES	:= cMes
		RCG->RCG_ANO	:= cAno
		RCG->RCG_PER	:= cPeriodo
		RCG->RCG_PROCES	:= SRA->RA_PROCES
		RCG->RCG_TNOTRA := "@@@"
		RCG->RCG_SEMANA := "02"
		RCG->RCG_DIAMES := aColsRCG[nCont, 1]
		RCG->RCG_TIPDIA := aColsRCG[nCont, 2]
		RCG->RCG_VTRANS := aColsRCG[nCont, 3]
		RCG->RCG_DIFTRA := aColsRCG[nCont, 4]
		RCG->RCG_VREFEI := aColsRCG[nCont, 5]
		RCG->RCG_VALIM  := aColsRCG[nCont, 6]
		RCG->RCG_HRSTRA := aColsRCG[nCont, 7]
		RCG->RCG_HRSDSR := aColsRCG[nCont, 8]
		RCG->RCG_DTINI	:= dDataIni
		RCG->RCG_DTFIM	:= dDataFim
		RCG->RCG_MODULO	:= "GPE"
		RCG->( MsUnlock() )
	EndIf
Next nCont

Return

/*/{Protheus.doc} fMontaRCG
Função que monta os registros da tabela RCG (adaptação fNewAcols())
@autor Allyson Luiz Mesashi
@since 07/12/2022
/*/
Static Function fMontaRCG( dDataIni, dDataFim )

Local aColsRCG	:= {}
Local dData		:= cToD("//")
Local nCnt		:= 0
Local nDias		:= Max( (dDataFim  - dDataIni ) + 1, 0 )

aColsRCG 	:= Array(nDias, 8)

For nCnt := 1 To nDias
	dData		:= Iif( nCnt == 1, dDataIni, dData + 1 )
	aColsRCG[nCnt, 1] := dData
	aColsRCG[nCnt, 2] := RetTipoDia(dData)
	aColsRCG[nCnt, 3] := Iif( Alltrim(Upper(Cdow(dData))) == "SATURDAY" .Or. Alltrim(Upper(Cdow(dData))) == "SUNDAY" .Or. RetTipoDia(dData) == "4", "2", "1"  )
	aColsRCG[nCnt, 4] := "2"
	aColsRCG[nCnt, 5] := aColsRCG[nCnt, 4]
	aColsRCG[nCnt, 6] := aColsRCG[nCnt, 4]
	aColsRCG[nCnt, 7] := Iif( aColsRCG[nCnt, 2] == "4", 0, Iif( Alltrim(Upper(Cdow(dData))) == "SATURDAY" .Or. Alltrim(Upper(Cdow(dData))) == "SUNDAY", 0, 8 ) )
	aColsRCG[nCnt, 8] := Iif( aColsRCG[nCnt, 2] == "4", 8, Iif( Alltrim(Upper(Cdow(dData))) == "SUNDAY", 8, 0 ) )
Next nCnt

Return aColsRCG

/*/{Protheus.doc} fGrvSRC
Função que grava a verba de ID 1904 na tabela SRC
@autor Allyson Luiz Mesashi
@since 07/12/2022
/*/
Static Function fGrvSRC( cRot132, dDataFim, dDtPag, nVal1904 )

Local cChavePes	:= SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + cRot132 + "02" + aCodFol[1904, 1]
Local lItemClVl := SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "1*3" // Define se trabalha com item e classe contabil

If !SRC->( dbSeek( cChavePes ) ) .And. SRC->( Reclock("SRC", .T.) )
	SRC->RC_FILIAL	 	:= SRA->RA_FILIAL
	SRC->RC_MAT		 	:= SRA->RA_MAT
	SRC->RC_PD		 	:= aCodFol[1904, 1]
	SRC->RC_TIPO1	 	:= "V"
	SRC->RC_VALOR	 	:= nVal1904
	SRC->RC_DATA	 	:= dDtPag
	SRC->RC_DTREF    	:= dDataFim
	SRC->RC_SEMANA   	:= "02"
	SRC->RC_TIPO2 	 	:= "C"
	SRC->RC_PROCES 	 	:= SRA->RA_PROCES
	SRC->RC_PERIODO	 	:= cPeriodo
	SRC->RC_ROTEIR	 	:= cRot132
	SRC->RC_CC		 	:= SRA->RA_CC
	If lItemClVl
		SRC->RC_ITEM	:= SRA->RA_ITEM
		SRC->RC_CLVL	:= SRA->RA_CLVL
	EndIf
	SRC->( MsUnlock() )
EndIf

Return

/*/{Protheus.doc} fExc1904
Efetua exclusão da verba de ID 1904 no roteiro 132 de semana 02
@autor Allyson Luiz Mesashi
@since 07/12/2022
/*/
Static Function fExc1904()

Local aArea		:= ( GetArea() )
Local aAreaSRC	:= SRC->( GetArea() )
Local cChavePes	:= SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + fGetCalcRot('6') + "02" + aCodFol[1904, 1]

SRC->( dbSetOrder(4) )//RC_FILIAL+RC_MAT+RC_PERIODO+RC_ROTEIR+RC_SEMANA+RC_PD

If SRC->( dbSeek( cChavePes ) ) .And. SRC->( Reclock("SRC", .F.) )
	SRC->( dbDelete() )
	SRC->( MsUnlock() )
EndIf

RestArea( aAreaSRC )
RestArea( aArea )

Return

/*/{Protheus.doc} fRescDiss
Retorna o valor original de lRescDis definido pelo usuário no momento da inclusão da complementar
@autor Leandro Drumond
@since 26/05/2023
/*/
Function fRescDiss()

DEFAULT lRDisOrig := lRescDis

Return lRDisOrig

/*/{Protheus.doc} fVerConsig
Verifica se funcionário possui empréstimo consignado
@autor Leandro Drumond
@since 22/06/2023
/*/
Static Function fVerConsig(cPdConsig, nTotConsig, aConsig)
Local aArea 	:= GetArea()
Local aTabS137	:= {}
Local cCodePart := aConsig[1]
Local nPos 		:= 0
Local lRet 		:= .F.
Local lErro     := .T.

fCarrTab( @aTabS137, "S137", Nil, .T. )

If !Empty(aTabS137)
	cCodePart := aConsig[1]
	nPos := aScan( aTabS137, { |x| x[2] == SRA->RA_FILIAL .and. AllTrim(SubStr(x[7],1,4)) == cCodePart } )
	If nPos == 0
		nPos := aScan( aTabS137, { |x| x[2] == Space(FwGetTamFilial) .and. AllTrim(SubStr(x[7],1,4)) == cCodePart } )
	EndIf
	If nPos > 0 .and. !Empty(aTabS137[nPos, 06])
		cPdConsig  := aTabS137[nPos, 06]
		nTotConsig := aConsig[2]
		lErro      := .F.
	EndIf 
EndIf

If lErro 
	If !lColetiva .and. !IsBlind()
		//"Código do parceiro " ### " não foi encontrado na tabela S137 ou não existe verba cadastrada para rescisão. Verifique!" ### "Inconsistência na integração com TOTVS Consignado."
		MsgInfo(STR0323 + cCodePart + STR0324, STR0325)
	Else
		SRA->(	aAdd( aLogFile,	OemToAnsi(STR0077) + " " + If(lOfusca, Replicate('*',30), RA_NOME ) + " " +;	// "Funcionario:"
								OemToAnsi(STR0078) + " " + RA_FILIAL	+ " "	+							;	// "da Filial:"
								OemToAnsi(STR0079) + " " + RA_MAT		+ ", "	+							;	// "Matricula:"
								OemToAnsi(STR0323) + cCodePart + OemToAnsi(STR0324)))		
	EndIf
EndIf

RestArea(aArea)

Return lRet

/*/{Protheus.doc} fHabPDV
	Verifica se habilita indicativo de adesão PDV (When RG_PDV)
	@type  Function
	@author isabel.noguti
	@since 09/08/2023
	@version 1.0
	/*/
Function fHabPDV(cTipoRes, lWhen040)
Local lRet			:= .F.
Local cMotEsoc		:= ""
Local oModel

Default cTipoRes	:= ""
Default lWhen040	:= .F.

	If !Empty(cTipoRes)
		cMotEsoc := fGP40TPRES(cTipoRes,,, dDatabase)
		If !Empty(cMotEsoc)
			lRet := !(cMotEsoc $ "10|11|12|13|28|29|30|34|36|37|40|43|44")
		EndIf
	EndIf

	If !lRet
		If lWhen040
			oModel := FWModelActive()
			If( oModel:GetValue("GPEM040_MSRG","RG_PDV"), oModel:LoadValue("GPEM040_MSRG","RG_PDV",lRet), )
		Else
			cIndPDV := "Não"
		EndIf
	EndIf

Return lRet

/*/{Protheus.doc} fDelRU6
Delete dependente da RU6
@author Bruno Costa
@since 25/09/2023
/*/
Static Function fDelRU6(lDel, oView, lRec)
DEFAULT lTemRU6 := AliasInDic("RU6") 
DEFAULT lRec	:= .F.

If ( lTemRU6 .AND. lDel .AND. VAL(SRA->RA_DEPIR) >= 1 .Or. (lTemRU6 .AND. VAL(SRA->RA_DEPIR) >= 1 .AND. oView:GetModel():nOperation != 1 .And. oView:GetModel():nOperation != 5) )
	
	TcSqlExec("DELETE FROM " + RetSqlName("RU6") + " WHERE RU6_FILIAL = '" + SRA->RA_FILIAL + "' AND RU6_MAT = '" + SRA->RA_MAT + "' AND RU6_DTPGTO = '" + If(lRec, DTOS(SRG->RG_DATAHOM), DTOS(M->RG_DATAHOM) ) + "' AND ( RU6_TPREND IN ( '2', '3', '4')) ")

EndIf	

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fTpRemBox
Retorna as opções de combobox do campo RG_TPREMAD
@author Allyson Luiz Mesashi
@since 06/12/2023
/*/
//-------------------------------------------------------------------
Function fTpRemBox()

Local cOpcBox := STR0320//"1=Quarentena;2=Desligamento reconhecido judicialmente com data anterior a competências com remunerações já informadas no eSocial;3=Aposentadoria de servidor com data anterior a competências com remunerações já informadas no eSocial"

Return cOpcBox

/*/{Protheus.doc} fResEmpVld
Valida desconto de empréstimos
@author Leandro Drumond
@since 12/12/2023
/*/
Function fResEmpVld()
Local nElem2 		:= 0
Local nP3			:= 0
Local nSdoEmp		:= 0
Local nTotEmp 		:= 0
Local nTotLiq 		:= 0
Local nTetoDesc		:= 0
Local nDescAux 		:= 0
Local nPosLiq		:= 0
Local nPosInsuf		:= 0
Local nPosLiqAnt	:= 0
Local nPosEmp		:= 0
Local nLiqAux 		:= 0
Local nX  			:= 0
Local nTotConsig	:= 0
Local nValAux		:= 0
Local nValAux2		:= 0
Local nQtd			:= 1
Local nVlComp		:= 0
Local nPLiqRat		:= 0
Local cPdConsig 	:= ""
Local aEncar 		:= {}
Local aConsig       := {}
Local lRatInfo  	:= Type("P_LRATINFO") <> "U" .And. P_LRATINFO
Local lLiqRat		:= .F.

DEFAULT lConsig		:= GetMvRH("MV_CONSIG",, .F.)

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Tratamento de Emprestimos                     	         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If (cCompl != "S" .Or. !lProxMes) .And. ( nPosLiq := aScan( aPD,{|x| x[1] == aCodfol[126,1] .And. x[9] != "D" } ) ) > 0//Saldo liquido
	nTotEmp := 0

	If Len(aRateio) > 0 .And. RetValSRV(aPd[nPosLiq, 1], SRA->RA_FILIAL, "RV_ENCARCC") $ "S*B" 
		aEval(aPd, { |x| If(x[1] == aCodfol[126, 1] .And. x[9] != "D", nTotLiq += x[5], Nil) } )
		lLiqRat := .T.
	Else
		nTotLiq := aPd[nPosLiq,05]
	EndIf

	//Retira o valor do salário familia pois o pagamento dessa verba é obrigatória
	aEval( aPd ,{ |X| If(x[1] == aCodFol[034,1] .And. x[9] != "D", nTotLiq -= x[5], Nil) } )
	aEval( aPd ,{ |X| If(X[16] == .T. .And. x[9] != "D" .and. RetValSRV(x[1], SRA->RA_FILIAL,"RV_NATUREZ") != "9253",nTotEmp+=x[5],Nil) } )
	
	//Retira o valor da PLR conforme legislação
	aEval(aPd, {|X| If(x[1] == aCodFol[151, 1] .And. x[9] != "D", nTotLiq -= x[5], Nil)})

	nPosLiqAnt := If(cCompl == "S", aScan( aPD, { |x| x[1] == aCodfol[303,1] .And. x[9] != "D" } ) , 0 )
	nTotLiq    += If(cCompl == "S" .and. nPosLiqAnt > 0, aPd[nPosLiqAnt, 05], 0 )
	
	nTetoDesc 	:= Round(P_PERCONS/100 * nTotLiq,2)
	nSdoEmp 	:= Round(P_PERCONS/100 * nTotLiq,2)

	If lConsig
		aConsig := fDebitBalanceEmployee() //EndPoint que obtém o saldo devedor do funcionário no TOTVS CONSIGNADO
		For nX := 1 to Len(aConsig)
			If !Empty(aConsig[nX,1]) .and. aConsig[nX,2] > 0
				cPdConsig := ""
				nTotConsig:= 0
				fVerConsig(@cPdConsig, @nTotConsig, aConsig[nX])
				
				If nTotConsig > 0
					fMatriz(cPdConsig,nTotConsig,,,,,"R",,,,,,,,,,.T.)
					nTotEmp += nTotConsig
				EndIf
			EndIf
		Next nX
	EndIf

	If nTotEmp > 0 .and. nTotEmp > nTetoDesc // o Total de Emprestimo é maior que 30% do liquido
		//"Atenção o funcionario possui emprestimo(s) que serao liquidados parcialmente ou NÃO serão liquidados
		// pois o saldo devedor dos mesmos ultrapassa o valor do teto estabelecido pelo mnemônico P_PERCONS
		//(XX% sobre o liquido da Rescisão). Verifique os Lancamentos Futuros"
		If !lColetiva
			MsgInfo(STR0221 + "(" + cValToChar(P_PERCONS) + STR0222)
		Else
			SRA->( aAdd( aLogConsig, STR0077 + If(lOfusca, Replicate('*', 30), Alltrim(RA_NOME)) + " " +; // "Funcionário:"
							         STR0078 + RA_FILIAL + " " +;	 								      // "Filial:"
							         STR0079 + RA_MAT ))							                   	  // "Matrícula:"										
		EndIf
	EndIf

	If nTotEmp > 0 // Calcula emprestimos
		nElem2 := Len(aPd)

		If Len(aRateio) > 0 	
			For nX := 1 to Len(aRateio)
				If aRateio[nX,5] = "S"
					aAdd(aEncar, {aRateio[nX, 1], 0, 0, aRateio[nX, 4], aRateio[nX, 2], aRateio[nX, 3]})
				EndIf
			Next nX	
		EndIf

		For nP3 := 1 To nElem2
			If (nPosEmp := aScan( aPD, {|x| x[16] == .T. .And. x[9] != "D" .and. RetValSRV(x[1], SRA->RA_FILIAL,"RV_NATUREZ") != "9253"}, nP3 )) > 0
				If Len(aEncar) > 0 .And. ( lRatInfo .Or. !aPd[nPosEmp, 7] $ "I|G" ) .And. ( RetValSRV(aPd[nPosEmp, 1], SRA->RA_FILIAL, "RV_ENCARCC") $ "S*B" ) //Calcula o saldo rateado
					If nSdoEmp > 0 .And. nQtd != Len(aEncar)
						aPd[nPosEmp,05] := Round(nSdoEmp * aEncar[nQtd, 4], 2)
						nVlComp += aPd[nPosEmp, 05]
						If lLiqRat .And. (nPLiqRat := aScan(aPD, {|x| x[1] == aCodfol[126,1] .And. x[2] == aEncar[nQtd, 1] .And. x[9] != "D" .And. If(!Empty(x[13]), x[13] == aEncar[nQtd, 5], .T.) .And. If(!Empty(x[14]), x[14] == aEncar[nQtd, 6], .T.)})) > 0
							nPosLiq := nPLiqRat
						EndIf	
						nQtd++					
					ElseIf nSdoEmp > 0
						aPd[nPosEmp, 05] := nSdoEmp - nVlComp
						nSdoEmp := nSdoEmp - aPd[nPosEmp, 05] - nVlComp
						If lLiqRat .And. (nPLiqRat := aScan(aPD, {|x| x[1] == aCodfol[126,1] .And. x[2] == aEncar[nQtd, 1] .And. x[9] != "D" .And. If(!Empty(x[13]), x[13] == aEncar[nQtd, 5], .T.) .And. If(!Empty(x[14]), x[14] == aEncar[nQtd, 6], .T.)})) > 0
							nPosLiq := nPLiqRat
						EndIf	
					Else 
						aPd[nPosEmp, 05] := 0
						aPd[nPosEmp, 09] := "D"
					EndIf
				ElseIf nSdoEmp > 0 //Tem saldo a descontar
					If  aPd[nPosEmp,05] >=  nSdoEmp // valor do emprestimo maior ou igual ao saldo
						aPd[nPosEmp,05]:= nSdoEmp
						nSdoEmp := 0
					Else      //Valdor menor
						nSdoEmp -= aPd[nPosEmp,05]
					EndIf
				Else // verba nao pode ser processada
					aPd[nPosEmp,05] := 0
					aPd[nPosEmp,09] := "D"
				EndIf
				
				aPd[nPosLiq,05] -= aPd[nPosEmp,05]//Subtrai o valor do emprestimo no liquido
				aPd[nPosEmp,16] := .F.
			EndIf
		Next nP3
	EndIf
ElseIf aScan( aPD,{|x| x[1] == aCodfol[0048,1] } ) > 0
	nElem2 := Len(aPd)
	aEval( aPd ,{ |X| If(X[16] == .T.,nTotEmp+=x[5],Nil) } )
	If nTotEmp > 0
		//"Atenção o funcionario possui emprestimo(s) que serao liquidados parcialmente ou NÃO serão liquidados
		// pois o saldo devedor dos mesmos ultrapassa o valor de 30% sobre o liquido da Rescisão"
		// Verifique os Lancamentos Futuros
		MsgInfo(OemToAnsi(STR0105))
		aEval( aPd ,{ |x| If( x[16] == .T. .and. RetValSRV(x[1], SRA->RA_FILIAL,"RV_NATUREZ") != "9253", ( x[5] := 0, X[9] := "D"),Nil) } )
	EndIf
EndIf

If cPaisLoc == "BRA" .and. !Empty(aCodFol[1899, 1]) .and. !Empty(P_LIMRESPD) .and. P_LIMRESPD <> "N"

	nDescAux := 0

	If P_LIMRESPD == "S"
		aEval(aPd, {|x| If(x[1] <> aCodFol[126,1] .and. x[9] <> "D" .and. RetValSRV(x[1], SRA->RA_FILIAL, 'RV_TIPOCOD') == "2", nDescAux += x[5], Nil )} )
	Else
		aEval(aPd, {|x| If(x[1] $ P_LIMRESPD .and. x[9] <> "D", nDescAux += x[5], Nil )} )
	EndIf

	If nDescAux > SALMES
		nValAux := nDescAux - SALMES

		fMatriz(aCodFol[1899,1], nValAux ) //Gera valor não descontado devido ultrapassar o teto

		//"O funcionário possui descontos que não serão efetuados integralmente, de acordo com a definição do mnemônico P_LIMRESPD."
		//"O teto para desconto do funcionário é de R$"
		MsgInfo(STR0309 + CRLF + STR0310 + cValToChar(SALMES))

		aSort( aPD ,,, { |x,y| Val(x[21]) > Val(y[21]) } ) //Coloca na ordem de cálculo inversa

		nPosLiq 	:= aScan( aPD,{|x| x[1] == aCodfol[126,1] .And. x[9] != "D" } )
		nPosInsuf	:= aScan( aPD,{|x| x[1] == aCodfol[45,1] .And. x[9] != "D" } )

		For nX := 1 to Len(aPd)
			If aPd[nX,1] <> aCodFol[126,1] .and. aPd[nX,9] <> "D" .and. !aPd[nX,16] .and. ( RetValSRV(aPd[nX,1], SRA->RA_FILIAL, 'RV_TIPOCOD') == "2" )  .and.( P_LIMRESPD == "S" .or. aPd[nX,1] $ P_LIMRESPD )
				
				If nPosLiq + nPosInsuf > 0
					nLiqAux := If(nPosLiq > 0, aPd[nPosLiq,5] + If(aPd[nX,5] <= nValAux, aPd[nX,5], nValAux), aPd[nPosInsuf,5] - If(aPd[nX,5] <= nValAux, aPd[nX,5], nValAux))
					If(nPosLiq > 0, aPd[nPosLiq,5] := nLiqAux, aPd[nPosInsuf,5] := Max(nLiqAux,0)) //Soma o valor abatido do desconto no liquido
					If(nLiqAux < 0 .and. nPosLiq == 0, fMatriz(aCodFol[126,1], ( nLiqAux * (-1) ) ), Nil) //Gera liquido
					If(nLiqAux < 0 .and. nPosLiq == 0, nPosLiq 	:= aScan( aPD,{|x| x[1] == aCodfol[126,1] .And. x[9] != "D" } ), Nil )
				EndIf 

				nValAux2  := If(aPd[nX,5] <= nValAux, nValAux - aPd[nX,5], 0)
				aPd[nX,5] := If(aPd[nX,5] <= nValAux, 0, aPd[nX,5] - nValAux)
				nVAlAux   := nVAlAux2
				
				If nValAux == 0
					Exit
				EndIf
			EndIf
		Next nX
	EndIf
EndIf

If cPaisLoc == "BRA" .and. cCompl != "S"//Trata eConsignado individualmente
	fLimECons(aCodfol[126,1])
EndIf

Return Nil

/*/{Protheus.doc} fResAhgora
Processo para gerar alteração referente a demissão na tabela de integração com Ahgora
@since 10/09/2024
@autor	Bruno Costa
@version 1.0
/*/
Function fResAhgora(lDel)
Local aArea       := GetArea()
Local cChave      := cEmpAnt + "|" + SRA->RA_FILIAL + "|" + SRA->RA_MAT + If(!lDel, "|" + If(IsInCallStack("GPEM630"), dToS(SRA->RA_DEMISSA), dToS(M->RG_DATADEM)), "")
Local cVldPonto   := SuperGetMv("MV_INTEGPW",, "1")
Local aCodInterno := {}

DEFAULT lDel := .F.

If cVldPonto <> "1" 
	If !GPEAhGora():fAhgoraPW(cVldPonto)
		Return
	EndIf
EndIf

aAdd(aCodInterno, {SRA->RA_FILIAL, SRA->RA_MAT, cEmpAnt+SRA->RA_FILIAL+SRA->RA_MAT, Nil, Nil, If(lDel, "E", "A")})

GPEAhGora():gravaRUM("I", "SRA", cChave, aCodInterno, "1",,,,,, lDel)

RestArea(aArea)

Return Nil

/*/{Protheus.doc} fResValidApd
Valida apd da rescisão antes de gravar
@since 25/07/2025
@autor	Bruno Costa
@version 1.0
/*/
Function fResValidApd(aPd)
Local nElem      := 0
Local nCount     := 0
Local cVerbasPLR := ""
Local lRvCpoPlr	 := SRV->(Columnpos("RV_REFPLR")) > 0

aEval(aPd, {|X| nElem += If(Round(x[5], 2) == 0.00 .Or. X[9] == "D", 0 , 1)})

If nElem > 0

	aSort(aPd,,, {|x,y| x[1] + x[11] < y[1] + y[11]})

	If lRescPLR
		cVerbasPLR := aCodFol[151,1]+'*'+aCodFol[152,1]+'*'+aCodFol[300,1]+'*'+aCodFol[835,1]+'*'+aCodFol[836,1]
		For nCount := 1 To Len(aPd)
			If !(aPd[nCount,1] $ cVerbasPLR) .And. (!lRvCpoPlr .Or. (lRvCpoPlr .And. !(RetValSRV(aPd[nCount,1], SRA->RA_FILIAL, 'RV_REFPLR') == "S")))
				aDel(aPd,nCount)
				aSize(aPd,Len(aPd)-1)
				nCount--
			EndIf
			If nCount == Len(aPd)
				Exit
			EndIf
		Next nCount
		fLiquido(aCodFol,aCodFol[126,1],0,"",.T.,aCodFol[45,1],.T.,.T.,.T.)
	EndIf
EndIf 

Return nElem

/*/{Protheus.doc} fVerMultV
Verifica se funcionário autonomo possui vinculo celetista sem folha calculada no período
@since 21/08/2025
@autor	Leandro Drumond
@version 1.0
/*/
Static Function fVerMultV() 
Local aArea     := GetArea() 
Local aAreaSRA  := SRA->(GetArea())
Local cFilMat   := SRA->RA_FILIAL + SRA->RA_MAT
Local cCpf 		:= SRA->RA_CIC
Local lRet 		:= .F. 

DbSelectArea("SRA")
DbSetOrder(RetOrder("SRA","RA_CIC+RA_FILIAL+RA_MAT"))

SRA->(DbSeek(SRA->RA_CIC))

While SRA->(!Eof() .and. SRA->RA_CIC == cCpf)
	If SRA->RA_FILIAL + SRA->RA_MAT <> cFilMat .and. !(SRA->RA_CATFUNC $ "P*A") .And. !(SRA->RA_RESCRAI $ "30/31") .And. AnoMes(SRA->RA_ADMISSA) <= M->RG_PERIODO .And. Empty(SRA->RA_DEMISSA)
		If !SRC->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT))
			lRet := .T.
			Exit
		EndIf 
	EndIf
	SRA->(DbSkip())
EndDo

RestArea(aAreaSRA)
RestArea(aArea)

Return lRet 
