#INCLUDE "GPEXCALC.CH" 
#INCLUDE "PROTHEUS.CH"

Static lRGECod   	:= RGE->(ColumnPos( "RGE_COD" )) > 0
Static lTemRefQua
Static __lMemCalc

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³			ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.			  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data	³ FNC			 ³  Motivo da Alteracao 					³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Flavio Corre³25/02/15³PCREQ-2898      ³Inclusao fonte							³±±
±±³EstherViveiro³08/06/15³TSNTY3         ³Modificada funcao fGerValFut() para		³±±
±±³             ³        ³               ³considerar apenas status ativo do lcto 	³±±
±±³             ³        ³               ³futuro no momento de adicionar verba na	³±±
±±³             ³        ³               ³folha.								  	³±±
±±³Christiane V.³25/11/15³TTSH96         ³Ajuste na FCalcPensao para considerar os  ³±±
±±³             ³        ³               ³dias de ferias quando nao houver verba de ³±±
±±³             ³		 ³				 ³ferias no cadastro do beneficiario.       ³±±
±±³Allyson M    ³08/12/15³TTZLBR         ³Ajuste em fGerValFut() na montagem da data³±±
±±³             ³        ³               ³quando lancamento e' de dissidio      	³±±
±±³Cícero Alves ³28/12/15³TUBQGB         ³Ajuste p/ zerar o valor da pensao s/ a 1o.³±±
±±³             ³        ³               ³parcela so quando a 2o. estiver calculada.³±±
±±³Joao Balbino³20/01/16³TUAGXR          ³Corrigido o calclo de multiplas pensôes   ³±±  
±±³Allyson M    ³04/02/16³TUJLEI         ³Ajuste na chamada de fcIr13o() quando for ³±±
±±³             ³        ³               ³rescisao p/ verificar corretamente quando	³±±
±±³             ³        ³               ³recalculo e quando for complementar   	³±±
±±³Raquel Hager ³10/02/16³TUJQLJ         ³Ajuste nas funcoes fCMenSind/fCConfed/    ³±±
±±³             ³        ³               ³fCAssist para considerar valores Min/Maz	³±±
±±³             ³        ³               ³para desconto.							³±±
±±³Raquel Hager ³07/07/16³TVHTUE         ³Ajuste para não calcular Cont.Assistencial³±±
±±³             ³        ³               ³se não possuir dias trabalhados.        	³±±
±±ºClaudinei S. ³08/07/16³TVP136/TUQEKD  ³Criada a função fSalRed para calcular o   ³±±
±±º             ³        ³               ³valor do desconto do PPE - Programa de    ³±±
±±º             ³        ³               ³Proteção ao Emprego. Merge 12.1.12        ³±±
±±ºClaudinei S. ³02/08/16³TUVZAE         ³Ajustada a FCalcPensao() para calcular a  ³±±
±±º             ³        ³               ³proporção da pensão sobre 13º conforme    ³±±
±±º             ³        ³               ³os avos, MV_PROPENS.                      ³±±
±±ºRaquel Hager ³11/18/16³TVHQCW         ³Remoção de ajuste anterior e ajuste na    ³±±
±±º             ³        ³               ³função FCalcPensao para ao considerar o   ³±±
±±º             ³        ³               ³roteiro Folha, considerar Autonomo na     ³±±
±±º             ³        ³               ³composição da base de cálculo de Pensão.  ³±±
±±ºClaudinei S. ³18/08/16³TUVZAE         ³Ajustada a FCalcPensao() para calcular a  ³±±
±±º             ³        ³               ³proporção das pensões sobre 13º, folha e  ³±±
±±º             ³        ³               ³férias, conforme os avos, MV_PROPENS.     ³±±
±±ºCícero Alves ³28/09/16³TWD740         ³Criada a função RestXCDES para reiniciali-³±±
±±º             ³        ³               ³zar as variáveis Static do fonte, usada   ³±±
±±º             ³        ³               ³nos testes automatizados					³±±
±±ºLeandro Dr.  ³30/09/16³TVPWWQ         ³Tratamento para não calcular mensalidade  ³±±
±±º             ³        ³               ³sindical de funcionários afastados se o   ³±±
±±º             ³        ³               ³campo RCE_DESAFA estiver com "Não"		³±±
±±ºCícero Alves ³04/10/16³TWBGM2         ³Ajuste na função fCAssist para considerar ³±±
±±º             ³        ³               ³o mnemônico P_PROPCONT no calculo da con- ³±±
±±º             ³        ³               ³tribuição assistencial					³±±
±±³Allyson M.   ³26/10/16³TVMSTU         ³Ajuste em Sindical() p/ calculo quando for³±±
±±³             ³        ³        		 ³rescisao complementar     				³±±
±±³Renan	    ³26/10/16³TVMSTU         ³Ajuste em Sindical() p/ nao gerar a verba ³±±
±±³             ³        ³        		 ³em rescisão do mês seguinte se já houver	³±±
±±³             ³        ³        		 ³sido calculada na folha em aberto			³±±
±±³Allyson M.   ³11/11/16³TWEMN2         ³Ajuste em fGerValFut() p/ verificar a data³±±
±±³             ³        ³        		 ³de pagamento da folha quando for cálculo 	³±±
±±³             ³        ³        		 ³de férias e p/ não considerar o registro	³±±
±±³             ³        ³        		 ³na folha quando a regra de desconto for de³±±
±±³             ³        ³        		 ³férias e for no mês de início das férias  ³±±
±±ºClaudinei S. ³02/12/16³TWHG1/MRH-855 ³Ajuste em fCAssit, fCConfed, fCMenSind e  ³±±
±±º             ³        ³               ³em Sindical, para que em caso de Horista  ³±±
±±º             ³        ³               ³com jornada variável sejam consideradas as³±±
±±º             ³        ³               ³verbas do grupo 0 para compor o salário.  ³±±
±±³Allyson M.   ³19/12/16³MRH-3481       ³Ajuste em FCalcPensao() p/ executar função³±±
±±³             ³        ³        		 ³de cálculo de IR de 13º quando executar o	³±±
±±³             ³        ³        		 ³roteiro 132 pois não estava calculando e	³±±
±±³             ³        ³        		 ³considerando o IR na pensão				³±±
±±³Allyson M.   ³16/01/17³MRH-4067       ³Ajuste na FCalcPensao p/ somente conside- ³±±
±±³             ³        ³               ³rar os dias de férias na regra com valor  ³±±
±±³             ³		 ³				 ³fixo       								³±±
±±³Renan Borges ³18/01/17³MRH-1195       ³Ajuste para que na rescisão o desconto da ³±±
±±³             ³        ³        		 ³contribuição sindical considere o dsr pro-³±±
±±³             ³        ³        		 ³fessor e as horas ativdades também.	    ³±±
±±³M. Silveira  ³03/02/17³MRH-6040       ³Ajuste em fCAssist e fCConfed p/ permitir ³±±
±±³             ³        ³        		 ³calcular ou nao p/ funcionarios afastados.³±±
±±³             ³        ³        		 ³Validacao do Mne P_NDAFAACS para definir a³±±
±±³             ³        ³        		 ³quantidade minima de dias afastado.       ³±±
±±³Renan Borges ³03/02/17³MRH-5909       ³Ajusta para proporcionalizar a pensão ali-³±±
±±³             ³        ³        		 ³mentícia corretamente com o parâmetro MV_-³±±
±±³             ³        ³        		 ³PROPENS igual a N, e na referencia da insa³±±
±±³             ³        ³        		 ³lubridade de auxilio maternidade.	        ³±±
±±³M. Silveira  ³07/02/17³MRH-2712       ³Ajuste em fCAssist para permitir o calculo³±±
±±³             ³        ³        		 ³nos roteiros PLR e 132.                   ³±±
±±³Eduardo K.   ³31/03/17³MPRIMESP-9469  ³Ajuste para desconto de contribuição sind.³±±
±±³             ³        ³        		 ³na licença maternidade.                   ³±±
±±ºClaudinei S. ³18/05/17³DRHPAG-1817/   ³Criada a fPensaoAPD() para buscar a verba ³±±
±±º             ³        ³DRHPAG-2001    ³de pensão nas férias e somar seus valores ³±±
±±º             ³        ³               ³de acordo com o array APD.                ³±±
±±ºSilvia T.    ³29/06/18³DRHGFP-491     ³Ajuste no calculo da Pensao para Gestão   ³±±
±±º             ³        ³               ³Publica - Troca de variaveis fixas por    ³±±
±±º             ³        ³               ³Roteiro                                   ³±±
±±ºSilvia T.    ³04/10/18³DRHGFP-1781    ³Tratamento para considerar tipos L e M    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FCalcPensao³ autor ³ Jose Ricardo        ³ Data ³ 11/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula a Pensao Alimenticia (Cad. Func./Cad. Beneficiarios³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FCalcPensao(cInss,cIR,cPensao,nPercPensao,dDataPgto,cTipo,lCarrBenef,cFilialCor,cNumDepIr,cTipoPgto,cSitFolha,aPensao,lDifFerMP)

Local nBase131   := 0
Local nValBase   := nLiqTemp   := 0
Local nValIR     := 0
Local nNrSlMin   := nValFixo   := 0
Local nValPensao := nVlPens131 := 0
Local nValIRAdi	 := 0
Local cIRAdi 	 := aCodFol[12,1]//I.R. DO ADIANTAMENTO Cod. Base Demo Folha
Local cPd0183 	 := aCodFol[183, 1]//Desc. Ant. 13o. na 2o. Parcela
Local lUsarIRAdi := .F.
Local nPosRot	 := 0
Local nAvos13Av	 := 0
Local nAvosFerAv := 0
Local nPos13Av	 := 0
Local cMVProPens := GetMvRH("MV_PROPENS",,"S")
Local cRotVerba  := ""
Local cVbBaseP   := ""
Local cVb131     := ""
Local cVbPLR     := ""
Local cVbAdt     := ""
Local cVbFer     := ""
Local cSeqAux	 := " "
Local lCalSlLiq  := .T.
Local lCadPensao := .T.
Local lCalSlBru  := .F.
Local lDesc131   := .F.
Local lFirst     := .T.
Local lUsarIR    := .T.
Local lTem1961	 := Len(aCodFol) >= 1961 .And. !Empty(aCodFol[1961, 1])
Local lPgtP132	 := .F.
Local aCodBenef  := {}
Local aOldBenef	 := {}
Local aBenefAux	 := {}
Local nIndProp   := 1
Local cSemAtual  := If(Type("cSemana") == Nil, "  ", cSemana)
Local nPos,nPos2,nPos3,nCnt1,cTipoPens
Local aPdIR		 := {}		// array que guardar o ultimo IR gerado
Local nPosIR	 := 0		// variavel para posicionamento das verbas que serao geradas
Local nx		 := 0		// variavel para looping e atualizacao dos valores de IR.
Local nIndPropAnt:= 1
Local cMVPENSOUT := GetMvRH("MV_PENSOUT",,"S")	// Parametro que indica se deve abater as pensoes de todos os
													// beneficiarios calculados ate o momento para apurar o IR do
													// beneficiario corrente.
Local nPosP132	 	:= 0
Local lRatIR	   	:= If( Type("P_RATIRMV") == "U", .T., P_RATIRMV)
Local cPropPens  	:= If(Type("P_PENSPROP") == "U", "1", P_PENSPROP)
Local lProp			:= (cMVPENSOUT == "N" .And. cPropPens == "4")
Local lSairPens		:= .F.
Local cTpPiso	 	:= ""
Local nContVez		:= 0
Local nVlBase	 	:= 0
Local nVlPiso	 	:= 0
Local nVlDed131		:= 0

//-- Variaveis utilizadas na integracao com o PLS
Local c_Pensao		:= ""
Local n_PercPensao	:= 0
Local n_ValFixo		:= 0
Local n_NrSlMin		:= 0
Local c_VbBaseP		:= ""
Local l_CalSlLiq	:= .T.

Local nTamVF		:= 0
Local nTamSM		:= 0
Local nTamPC		:= 0
Local cTipoFol      := "FOL"
Local cTipoFer 		:= "FER"
Local cTipo131 		:= "131"
Local cTipo132	    := "132"    
Local cTipo13O		:= "13O"
Local nPosBen		:= 0
Local lMVPENSIR		:= GetMvRH("MV_PENSIR",,.F.)
Local nValPenInc	:= 0
Local nValPenNIr    := 0
Local lIRPens	   	:= If( Type("P_LIRPENS") == "U", .F., P_LIRPENS)

Private lGestPubl 	:= IIF(ExistFunc("fUsaGFP"),fUsaGFP(),.F.)	//Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

//-- Variaveis utilizadas na integracao com o PLS
DEFAULT cSitFolha	:= SRA->RA_SITFOLH
DEFAULT lCarrBenef	:= .T.
DEFAULT aPensao		:= {}
DEFAULT lDifFerMP   := .F.

DEFAULT __lMemCalc 	:= (cPaisLoc == "BRA" .And. fMemCalc())

If lGestPubl .AND. SRA->RA_REGIME == '2'
	cTipoFol := fGetRotOrdinar()
	cTipoFer := If(SRA->RA_CATFUNC $ "0*1","170","060")
	cTipo131 := fGetCalcRot("5")
	cTipo132 := fGetCalcRot("6")
	cTipo13O := fGetCalcRot("6")
Endif	

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Indica o tipo de calculo na rescisao                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cTipo     := If(cTipo == Nil, Space(3), UPPER(cTipo))
cTipoPens := Space(3)

If cTipoRot == "4" .Or. SRA->RA_TPCONTR == "3"
	cTipoPens := If( Empty(cTipo), cTipoFol, If(UPPER(cTipo) == cTipo13O, cTipo132, cTipo) )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica roteiro p/ prop. pensao sobre Sal.Minimo e Val.Fixo ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cTipoRot $ "1/4"
	nIndProp := ( Min( (DiasTrab+If(SRA->RA_TIPOPGT=="S",DiasDsr,0)+nDiasPg), 30 ) / Min(nDiasC,P_QTDIAMES) )
ElseIf cTipoRot $ "3/L/M"
	nIndProp := ( Min( M->RH_DFERIAS, 30 ) / P_QTDIAMES )
ElseIf cTipoRot == "2"
	nIndProp := ( Min( DiasTb, nDiasC) / nDiasC )
ElseIf cTipoRot $ "5/6"
	nIndProp := ( Min( nAvos, 12 ) / 12 )
EndIf

nIndPropAnt	:= nIndProp

If lCarrBenef
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Busca informacoes no cadastro de beneficiarios				 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	fBusCadBenef( @aCodBenef, cTipoPens )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se nao houver dados calcula a partir do % do cadastro de func³
//³ ou trata a informacao enviada no array aPensao.              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aCodBenef) == 0
	If Len(aPensao) > 0
		For nx := 1 to Len(aPensao)
			If Len(aPensao[nx]) == 6
				c_Pensao	:= If(ValType(aPensao[nx,1]) == ValType(cPensao),aPensao[nx,1],cPensao)
				n_PercPensao:= If(ValType(aPensao[nx,2]) == ValType(nPercPensao),aPensao[nx,2],nPercPensao)
				n_ValFixo	:= If(ValType(aPensao[nx,3]) == ValType(nValFixo),aPensao[nx,3],nValFixo)
				n_NrSlMin	:= If(ValType(aPensao[nx,4]) == ValType(nNrSlMin),aPensao[nx,4],nNrSlMin)
				c_VbBaseP	:= If(ValType(aPensao[nx,5]) == ValType(cVbBaseP),aPensao[nx,5],cVbBaseP)
				l_CalSlLiq	:= If(ValType(aPensao[nx,6]) == ValType(lCalSlLiq),aPensao[nx,6],lCalSlLiq)
				Aadd(aCodBenef, { c_Pensao, n_PercPensao, n_ValFixo, n_NrSlMin, c_VbBaseP, l_CalSlLiq, aCodFol[172,1], cVbPLR, "", "", "", "", "", "", "", "" })
			EndIf
		Next nx
	else
		Aadd(aCodBenef, { cPensao, nPercPensao, nValFixo, nNrSlMin, cVbBaseP, lCalSlLiq, aCodFol[172,1], cVbPLR, "", "", "", "", "", "", "", "", "", 0 })
	EndIf
	lCadPensao := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ordena o array de beneficiarios iniciando pelas pensoes fixas³
//³ salario minimo, utilizacao do IR e depois percentuais.		 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nTamVF := TamSX3("RQ_VALFIXO")[1]
nTamSM := TamSX3("RQ_NRSLMIN")[1]
nTamPC := TamSX3("RQ_PERCENT")[1]

nPos  := Ascan(aCodBenef, { |X| X[3] <>0 } )
nPos1 := Ascan(aCodBenef, { |X| X[4] <>0 } )
nPos2 := Ascan(aCodBenef, { |X| X[5] $ cIR } ) 

aOldBenef := aClone( aCodBenef ) // Armazena copia do aCodBenef original
aEval( aCodBenef, { |W| aAdd( W, If( Empty(W[5]) .Or. cIR $ W[5], "0", "1" ) ) } ) // Adiciona um elemento para identificar se usa(0) ou nao(1) o IR na base de calculo

If npos+npos1+npos2 > 0
	aSort( aCodBenef ,,, {|X,Y| StrZero(X[3],nTamVF)+StrZero(X[4],nTamSM)+X[Len(X)]+StrZero(X[2],nTamPC) > StrZero(Y[3],nTamVF)+StrZero(Y[4],nTamSM)+Y[Len(Y)]+StrZero(Y[2],nTamPC) })
EndIf

If (cMVPENSOUT == "S" .And. cPropPens $ "1*3") .Or. lProp
	If Len(aCodBenef) > 1
		aBenefAux := {}
		For nCnt1 := 1 to Len(aCodBenef)
			If ( nPos := Ascan(aBenefAux, { |X| X[1] == aCodBenef[nCnt1,5] .And. (cPropPens == "1" .Or. X[6][1][2] == aCodBenef[nCnt1,2] )} ) ) > 0
				aBenefAux[nPos,3] += 1
				aBenefAux[nPos,4] += aCodBenef[nCnt1,2]
				aBenefAux[nPos,5] += "*" + If( cTipo == "DFE", aCodBenef[nCnt1,13], Iif( cTipoRot == "F", aCodBenef[nCnt1,8], aCodBenef[nCnt1,1]) )
				aBenefAux[nPos,7] += "*" + alltrim(str(aCodBenef[nCnt1,19])) 
				aAdd(aBenefAux[nPos,6],{If( cTipo == "DFE", aCodBenef[nCnt1,13], Iif( cTipoRot == "F", aCodBenef[nCnt1,8], aCodBenef[nCnt1,1])) ,aCodBenef[nCnt1,2], aCodBenef[nCnt1,9] } )
			ElseIf aCodBenef[nCnt1,6] .and. aCodBenef[nCnt1,2] > 0
				aAdd(aBenefAux, { aCodBenef[nCnt1,5] , Iif( cTipoRot == "F", aCodBenef[nCnt1,8], aCodBenef[nCnt1,1]) , 1 , aCodBenef[nCnt1,2], If( cTipo == "DFE", aCodBenef[nCnt1,13], Iif( cTipoRot == "F", aCodBenef[nCnt1,8], aCodBenef[nCnt1,1])), {} ,alltrim(str(aCodBenef[nCnt1,19]))})
				aAdd(aBenefAux[Len(aBenefAux),6],{If( cTipo == "DFE", aCodBenef[nCnt1,13], Iif( cTipoRot == "F", aCodBenef[nCnt1,8], aCodBenef[nCnt1,1])) ,aCodBenef[nCnt1,2], aCodBenef[nCnt1,9] } )
			EndIf
		Next nCnt1
	EndIf
EndIf

For nCnt1 := 1 To Len(aCodBenef)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega array com dados do cad. de pens. ou % do cad. de Func³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nIndProp	:= nIndPropAnt
	cPensao     := If( cTipo == "DFE", aCodBenef[nCnt1,13], aCodBenef[nCnt1,1] )
	nPosBen := 0
	If lProp .And. (nPosBen := ascan(aBenefAux,{|x| alltrim(str(aCodBenef[nCnt1,19])) $ x[7]})) > 0
		nPercPensao := aBenefAux[nPosBen,4]
	Else
		nPercPensao := aCodBenef[nCnt1,2]
	EndIf
	nValFixo    := aCodBenef[nCnt1,3]
	nNrSlMin    := aCodBenef[nCnt1,4]
	cVbBaseP    := aCodBenef[nCnt1,5]
	lCalSlLiq   := aCodBenef[nCnt1,6]
	cVb131      := aCodBenef[nCnt1,7]
	cVbPLR      := aCodBenef[nCnt1,8]
	cVbAdt      := aCodBenef[nCnt1,14]
	cRotVerba   := aCodBenef[nCnt1,16]
	If Len(aCodBenef[nCnt1]) >= 25
		cTpPiso	 := aCodBenef[nCnt1,25]
		nVlPiso	 := aCodBenef[nCnt1,26]
	EndIf
	cVbFer		:= Substr( cRotVerba, AT( cTipoFer, cRotVerba )+ 3,3 ) // CODIGO PENSAO DE FERIAS INFORMADO NO CADASTRO DE BENEFICIARIOS.
	cSeqAux	 	:= " "
	lDesc131	:= .F.

	If lDifFerMP
		cPensao := cVbFer
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Considera os dias de ferias se nao tiver a verba informada.  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	If cTipoRot $ "1/4" .And. cSitFolha == "F" .And. Empty(cVbFer) .And. (nValFixo > 0 .Or. nNrSlMin > 0)
		nIndProp := ( Min( (DiasTrab+If(SRA->RA_TIPOPGT=="S",DiasDsr,0)+nDiasAd+P_QTDIAMES), 30 ) / 30 )
	Endif
	
	If nNrSlMin > 0 .And. cTipo == "DFE"
		nIndProp := fDifPensaoSM( nNrSlMin, .F. )	
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pensao sobre salario minimo e valor fixo.					 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cMVProPens == "N"
		If nValFixo > 0 .Or. nNrSlMin > 0
			If nIndProp > 0
				nIndProp	:= 1
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Quando for calculo de folha, o funcionario estiver em ferias ³
			//³ e nao tiver codigo de pensao de ferias e tiver codigo de pen-³
			//³ sao de folha nao proporcionalizamos a pensao alimenticia.    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTipoRot == "1"
				If cSitFolha == "F" 
					If ( nPosRot := AT( cTipoFer, cRotVerba ) ) > 0
						If	!Empty( Substr( cRotVerba, nPosRot + 3, 3 ) ) .and. fLocaliaPd(Substr( cRotVerba, nPosRot + 3, 3 )) > 0
							nIndProp := 0
						EndIf
					EndIf
				Else
					If lDissidio
						If Ascan(aPd, { |X| X[1] = cVbFer .And. X[9] # "D" } ) > 0  // SER FOR DISSIDIO, VERIFICAR SE TEM CODIGO PENSAO FERIAS 
							nIndProp := 0                                       // NO CADASTRO DE BENEFICIARIOS E NOS ACUMULADOS (APD)
						EndIf
					EndIf
				EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Quando for calculo de ferias e o funcionario nao tiver codigo³
			//³ de pensao de folha e tiver codigo de pensao de ferias nao    ³
			//³ proporcionalizamos a pensao alimenticia.                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ajusta o indice de proporcionalizacao para Pensao 1a.parcela ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cTipoRot == "5" .And. ( nValFixo > 0 .Or. nNrSlMin > 0 )
		 //-- a variavel cVb131 contem o codigo da pensao de 2a parcela 
		 //-- quando for o calculo da 1a parcela do 13o salario
		If !Empty(cPensao) .And. !Empty(cVb131)
			nIndProp	:= nIndProp * nPercentual
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula a pensao sobre Participacao nos Lucros e Resultados  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cTipoRot == "F"
		If cMVPENSOUT == "N" .And. !lProp
			fVerVbBenef(aCodBenef,1,nCnt1)
		EndIf
		fPensPLR(cVbPLR, nPercPensao, nValFixo, nNrSlMin, lCalSlLiq, dDataPgto, cVbBaseP, cTpPiso, nVlPiso)
		If cMVPENSOUT == "N"
			fVerVbBenef(aCodBenef,2,nCnt1)
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se nao existir codigo de pensao ou percentual, le proximo    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Empty(cPensao) .Or. (nPercPensao == 0 .And. nValFixo == 0 .And. nNrSlMin == 0) .Or.;
	   ( ( nValFixo > 0 .Or. nNrSlMin > 0 ) .And. nIndProp == 0 )
		Loop
	EndIf

    If __lMemCalc
        If lFirst
            fAddMemLog("Parametrização: ", 1, 1)
            fAddMemLog("MV_PENSIR: " + cValToChar(lMVPENSIR) + " ("+retX6Desc("MV_PENSIR")+")", 1, 2)
            fAddMemLog("MV_PENSOUT: " + cMVPENSOUT + " ("+retX6Desc("MV_PENSOUT")+")", 1, 2)
            fAddMemLog("MV_PROPENS: " + cMVProPens+ " ("+retX6Desc("MV_PROPENS")+")", 1, 2)
            fAddMemLog("P_PENSPROP: " + cPropPens + " ("+ retRcaDes("P_PENSPROP")+")", 1, 2)
            fAddMemLog("P_RATIRMV: " + cValToChar(lRatIR) + " ("+ retRcaDes("P_RATIRMV")+")", 1, 2)
			fAddMemLog("P_LIRPENS: " + cValToChar(lIRPens) + " ("+ retRcaDes("P_LIRPENS")+")", 1, 2)
        	fAddMemLog("Índice de proporcionalização baseado nos dias/avos trabalhados ou calculados: " + cValToChar(nIndProp*100) + "%", 1, 2)
        EndIf
		fAddMemLog("Cálculo do beneficiário: " + aCodBenef[nCnt1, 9], 1, 1)
    EndIf


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se ja foi lancado um codigo de pensao, le proximo elemento   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Ascan(aPd, { |X| X[1] = cPensao .And. X[3] = cSemAtual .And. X[9] # "D" .and. (cTipoRot <> '4' .or. X[7] <> "K" )} ) > 0
		If __lMemCalc
			fAddMemLog("Obs.: cálculo abortado devido verba " + cPensao + " já existir no cálculo.", 1, 2)
		EndIf
		Loop
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se Semanalistas nao tiverem proventos calculados ou se eles  ³	
	//³ nao tiverem incidencia de Pensao Alim. cancela o calculo     ³	
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	If SRA->RA_TIPOPGT = "S"          
		If Ascan(aPd, { |X| X[3] == cSemAtual .And. X[9] # "D" } ) > 0             
			If Ascan(aPd, { |X| X[3]==cSemAtual .And. RetValSRV( X[1],SRA->RA_FILIAL,"RV_PENSAO")=="S" .And. X[9] # "D" } ) <= 0
				Return
			EndIf
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o IR esta contido nos codigos de base da pensao  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lUsarIR := ( Empty(cVbBaseP) .Or. cIR $ cVbBaseP )
	lUsarIRAdi 	:= ( Empty(cVbBaseP) .Or. cIRAdi $ cVbBaseP ) .And. Empty(cVbAdt)
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pegar o Valor do Imposto de Renda Calculado					 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nValIR := 0.00
	nValIRAdi := 0.00
	
	If lIRPens .And. cTipoRot $ "1,3,4,6"// Calcula o IR antes da pensão
		If __lMemCalc     
			fAddMemLog("1º cálculo do IR (antes do 1º cálculo da pensão): ", 1, 2)
		EndIf
		If cTipoRot = "3" .Or. (cTipoRot =="4" .And. cTipo = cTipoFER)
			fcIrFer(aCodfol, aTabIr, If ( cTipo = cTipoFER, .T.,.F.), If(cTipoRot =="4" .And. cTipo == cTipoFER, M->RG_DATAHOM, M->RH_DTRECIB), .T., If(cTipoRot = "3", "F", nil))
		ElseIf cTipoRot $ "6" .Or. (cTipoRot =="4" .And. cTipo = cTipo13O )
			fcIr13o(aCodfol,If ( cTipo == cTipo13O, aTabIr,aTabIr13),.T.,If (cTipo = cTipo13O ,.T.,.F.),If(cTipoRot =="4",nIr13P,nil))
		Else
			fCIr(aCodfol,If(cTipoRot = "6",aTabIR13,aTabIr),if(cTipoRot == "4","R",nil),dDataPgto,cFilialCor,cNumDepIr,cTipoPgto)	      
		EndIf
	EndIf

	If lUsarIR
		If __lMemCalc
			fAddMemLog("Obs.: IR será considerado na base de cálculo.", 1, 2)
		EndIf		
		nPos := Ascan(aPd, { |X| X[1] = cIR .And. X[3] = cSemAtual .And. X[9] # "D" } )
		If nPos > 0
			nValIR := aPd[nPos,5]	
		EndIf				
	EndIf
	
	If lUsarIRAdi
		If __lMemCalc
			fAddMemLog("Obs.: IR de adiantamento será considerado na base de cálculo.", 1, 2)
		EndIf
		nPos := Ascan(aPd, { |X| X[1] = cIRAdi .And. X[3] = cSemAtual .And. X[9] # "D" } )
		If nPos > 0
			nValIRAdi := aPd[nPos,5]
		EndIf
	EndIf	
	
	If ( cTipoRot == "6" .And. lProp .And. !Empty( cVb131 ) .And. Empty(cVbBaseP) )
		lDesc131 := .T.
		If ( nPos := aScan(aPd, { |x| x[1] == cPd0183 .And. X[9] != "D" } ) ) > 0
			nBase131 := aPd[nPos, 5]
		EndIf
		If __lMemCalc
			fAddMemLog("Obs.: Base de pensão da 1ª parcela será deduzida.", 1, 2)
			fAddMemLog("Base da pensão da 1ª parcela: R$ " + AllTrim(Transform( nBase131, "@E 999,999,999,999.99" )), 1, 3)
		EndIf
		If ( nPos := aScan(aPd, { |x| x[1] == cVb131 .And. X[9] != "D" } ) ) > 0 .And. nNrSlMin == 0
			aPd[nPos, 9] := "D"
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta base da pensao ou utiliza val. fixo do cad. benef.	 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nValBase   := 0.00
	nValPensao := 0.00
	nLiqTemp   := 0.00
	If nValFixo > 0

		If cTipoRot = "4" .AND. cMVProPens <> "N"
			nPos13Av := Ascan(aPd, { |X| X[1] = aCodFol[115,1] .And. X[9] # "D" } )
			Do Case
				Case cTipoPens == cTipoFol 
					nIndProp := ( Min( (DiasTrab+If(SRA->RA_TIPOPGT=="S",DiasDsr,0)+nDiasPg), 30 ) / Min(nDiasC,P_QTDIAMES) )
				Case cTipoPens == cTipoFer 
					//Deve considerar todos os avos pagos de férias, não apenas 12, poi pode ter sido pago mais que um período na rescisão
					nAvosFerAv := 0
					aEval(aPd, {|x| If(x[1] $ aCodFol[086,1] + "/" + aCodFol[087,1] + "/" + aCodFol[230,1] .and. x[9] <> "D", nAvosFerAv += Val(Substr(Alltrim(Str(x[4])),1,2)), Nil)})
					nIndProp := ( nAvosFerAv / 12 )
				Case cTipoPens == cTipo131 
					If nPos13Av > 0
						nAvos13Av := Val(Substr(Alltrim(Str(aPd[nPos13Av,4])),1,2))
					Endif
					nIndProp := ( Min( nAvos + nAvos13Av, 12 ) / 12 )
				Case cTipoPens == cTipo132 
					If nPos13Av > 0
						nAvos13Av := Val(Substr(Alltrim(Str(aPd[nPos13Av,4])),1,2))
					Endif
					nIndProp := ( Min( nAvos + nAvos13Av, 12 ) / 12 )	
			EndCase
		Endif	

		nValPensao := nValFixo * nIndProp //Proporcionaliza valor fixo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Nao efetuar o calculo p/ Valor Fixo na Rescisao Complementar ³
		//³ Ou na Diferenca de Ferias                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cCompl == "S" .Or. cTipo == "DFE"
			Loop
		EndIf		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calcular pensao sobre 1a parcela em separado no calc. ferias ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cTipoRot = "3" .and. !Empty(cVb131)  .and. RetValSRV(cVb131,SRA->RA_FILIAL,"RV_PENSAO") = "S"
			nVlPens131 := NoRound( (nValFixo * M->RH_PERC13S)/100 ,MsDecimais(1))
			FGeraVerba(cVb131,nVlPens131,nPercPensao,cSemAtual,,"V",,,,dDataPgto)
			If __lMemCalc
				fAddMemLog("Pensão de 13º salário sobre valor fixo. Valor da pensão: R$ " + AllTrim(Transform( nVlPens131, "@E 999,999,999,999.99" )), 1, 2)
			EndIf
		EndIf
		If __lMemCalc
			fAddMemLog("Pensão sobre valor fixo. Valor da pensão: R$ " + AllTrim(Transform( nValPensao, "@E 999,999,999,999.99" )), 1, 2)
		EndIf
	ElseIf nNrSlMin > 0
	
		If cTipoRot = "4" .and. cCompl == "S" .And. lProxMes //Não realizar calculo por salário minimo na rescisão complementar pois já foi calculado na principal
			Loop
		EndIf
	
		If cTipoRot = "4" .AND. cMVProPens <> "N"
			nPos13Av := Ascan(aPd, { |X| X[1] = aCodFol[115,1] .And. X[9] # "D" } )
			Do Case
				Case cTipoPens == cTipoFOL 
					nIndProp := ( Min( (DiasTrab+If(SRA->RA_TIPOPGT=="S",DiasDsr,0)+nDiasPg), 30 ) / Min(nDiasC,P_QTDIAMES) )
				Case cTipoPens == cTipoFER
					//Deve considerar todos os avos pagos de férias, não apenas 12, poi pode ter sido pago mais que um período na rescisão
					nAvosFerAv := 0
					aEval(aPd, {|x| If(x[1] $ aCodFol[086,1] + "/" + aCodFol[087,1] + "/" + aCodFol[230,1] .and. x[9] <> "D", nAvosFerAv += Val(Substr(Alltrim(Str(x[4])),1,2)), Nil)})
					nIndProp := ( nAvosFerAv / 12 )
				Case cTipoPens == cTipo131 
					If nPos13Av > 0
						nAvos13Av := Val(Substr(Alltrim(Str(aPd[nPos13Av,4])),1,2))
					Endif
					nIndProp := ( Min( nAvos + nAvos13Av, 12 ) / 12 )
				Case cTipoPens == cTipo132 
					If nPos13Av > 0
						nAvos13Av := Val(Substr(Alltrim(Str(aPd[nPos13Av,4])),1,2))
					Endif
					nIndProp := ( Min( nAvos + nAvos13Av, 12 ) / 12 )	
			EndCase
		Endif	
	
		nValPensao	:= NoRound(Val_SalMin * nNrSlMin, MsDecimais(1)) * nIndProp //Proporcionaliza salario minimo

		If __lMemCalc
			fAddMemLog("Pensão sobre salário mínimo: ", 1, 2)
			fAddMemLog("Salário mínimo: R$ " + AllTrim(Transform( Val_SalMin, "@E 999,999,999,999.99" )), 1, 3)
			fAddMemLog("Qtde. salário(s) mínimo(s): " + cValToChar(nNrSlMin), 1, 3)
			fAddMemLog("Índice de proporcionalização: " + cValToChar(nIndProp*100) + "%", 1, 3)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calcular pensao sobre 1a parcela em separado no calc. ferias ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		
		If cTipoRot = "3" .And. !Empty(cVb131)
			nPos := Ascan(aPd, { |X| X[1] = aCodFol[22,1] .And. X[3] = cSemAtual .And. X[9] # "D"})
		    If  nPos > 0 .And. RetValSRV(aPd[nPos,1],SRA->RA_FILIAL,"RV_PENSAO") = "S" 
				nVlPens131 	:= NoRound( ((Val_SalMin * nNrSlMin) * M->RH_PERC13S)/100 ,MsDecimais(1))
				nVlPens131 	:= NoRound( (nVlPens131 * nPercPensao / 100),MsDecimais(1))

				If cPaisLoc == "BRA" .And. cTpPiso $ "2/3"
					If cTpPiso == "2"
						nVlBase	:= nVlPiso * nIndProp
					ElseIf cTpPiso == "3"
						nVlBase	:= NoRound( (nVlPiso/100) * Val_SalMin, MsDecimais(1) ) * nIndProp
					EndIf
					nVlPens131 := fPisoPens( cTpPiso, nVlPens131, nVlBase )
				EndIf

				FGeraVerba(cVb131,nVlPens131,nPercPensao,cSemAtual,,"V",,,,dDataPgto)		
			Endif	
		EndIf	
	
	Else
		If cMVPENSOUT == "N" .And. lProp
			fVerVbBenef(aCodBenef,1,nCnt1)
		EndIf
		
		If __lMemCalc
			fAddMemLog("Pensão sobre base de cálculo:", 1, 2)
			fAddMemLog("Verbas consideradas: ", 1, 3)
		EndIf

		If cTipoRot = "2"
			fBsPensAdt(aPd,@nValBase)
		ElseIf cTipoRot = "5"
			If lCadPensao
				Aeval( aPd ,{ |X|  If(X[1] $ cVbBaseP .Or. Empty(cVbBaseP), SomaInc(X, 28, @nValBase, Nil, Nil, Nil, Nil, Nil, .F., aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.),"") })
			Else
				nPos := Ascan(aPd, { |X| X[1] = aCodFol[22,1] .And. X[3] = cSemAtual .And. X[9] # "D" } )
				If nPos > 0
					nValBase := aPd[nPos,5]
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Somas as verbas com "S" para Pensao Alimenticia  		     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ElseIf cTipoRot $ "1*9*O" .And. SRA->RA_TPCONTR != "3"
			If cTipo == "DFE" //Monta base para pensao da Diferenca de Ferias
				If lDifFerMP
					cPdBasDFE := cVbBaseP
				Else
					cPdBasDFE := fGetDifFer(cVbBaseP)
				EndIf
				Aeval( aPd ,{ |X| If(X[1] $ cPdBasDFE .and. (!lDifFerMP .or. RetValSRV(x[1], SRA->RA_FILIAL, "RV_REFFER") == "S"), SomaInc(X, 28, @nValBase, Nil, Nil, Nil, Nil, Nil, .F., aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.),"") })
			Else
				If !(cPaisLoc $ "CHI")
					Aeval( aPd ,{ |X| If(X[1] $ cVbBaseP .Or. Empty(cVbBaseP), SomaInc(X, 28, @nValBase, 11, 'N', 12, 'N', Nil, .F., aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.),"") })
				Else
					Aeval( aPd ,{ |X| If(X[1] $ cVbBaseP .Or. Empty(cVbBaseP), SomaInc(X,28,@nValBase,11,'N',,, , .F.,aCodFol),"") })
				EndIf	
			EndIf
		ElseIf cTipoRot == "4" .Or. SRA->RA_TPCONTR == "3"
			If cTipo == cTipoFER
				Aeval( aPd ,{ |X|  If(X[1] $ cVbBaseP .Or. Empty(cVbBaseP), SomaInc(X, 28, @nValBase, 11, 'S', 12, 'N', Nil, .F., aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.),"") })
			ElseIf cTipo == "13O"
				Aeval( aPd ,{ |X|  If(X[1] $ cVbBaseP .Or. Empty(cVbBaseP), SomaInc(X, 28, @nValBase, 11, 'N', 12, 'S', Nil, .F., aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.),"") })
			Else
				Aeval( aPd ,{ |X|  If(X[1] $ cVbBaseP .Or. Empty(cVbBaseP), SomaInc(X, 28, @nValBase, 11, 'N', 12, 'N', Nil, .F., aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.),"") })
			EndIf
		Else
			Aeval( aPd ,{ |X|  If(X[1] $ cVbBaseP .Or. Empty(cVbBaseP), SomaInc(X, 28, @nValBase, Nil, Nil, Nil, Nil, Nil, .F., aCodFol, Nil, Nil, Nil, Nil, Nil, Nil, .T.),"") })
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calcular pensao sobre 1a parcela em separado no calc. ferias ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTipoRot = "3"
				nPos    := Ascan(aPd, { |X| X[1] = aCodFol[22,1] .And. X[3] = cSemAtual .And. X[9] # "D"})
				If Ascan(aPd , { |X|  X[1] = aCodFol[22,1] .and. X[1]$cVbBaseP}) > 0				
					If !Empty(cVb131) .and. RetValSRV(aPd[nPos,1],SRA->RA_FILIAL,"RV_PENSAO") = "S"			
						nValBase   -= aPd[nPos,5]
						nVlPens131 := NoRound(((aPd[nPos,5] * nPercPensao)/100),MsDecimais(1))
						FGeraVerba(cVb131,nVlPens131,nPercPensao,cSemAtual,,"V",,,,dDataPgto)
					else
						If RetValSRV(aPd[nPos,1],SRA->RA_FILIAL,"RV_PENSAO") = "S"			
							nValBase   -= aPd[nPos,5]
							nVlPens131 := NoRound(((aPd[nPos,5] * nPercPensao)/100),MsDecimais(1))
							FGeraVerba(cVb131,nVlPens131,nPercPensao,cSemAtual,,"V",,,,dDataPgto)
						EndIf 
					EndIf
				else	
					If Empty(cVbBaseP) .and. nPos > 0 .And. RetValSRV(aPd[nPos,1],SRA->RA_FILIAL,"RV_PENSAO") = "S" 
						nValBase   -= aPd[nPos,5]
						nVlPens131 := NoRound(((aPd[nPos,5] * nPercPensao)/100),MsDecimais(1))
						FGeraVerba(cVb131,nVlPens131,nPercPensao,cSemAtual,,"V",,,,dDataPgto)
					EndIf
				EndIf
				If __lMemCalc .And. nPos > 0 .And. aScan(aPd, { |x| x[1] == cVb131 .And. x[9] != "D"}) > 0	
					fAddMemLog("Pensão de 13º sobre base de cálculo: ", 1, 2)
					fAddMemLog("Base de cálculo da pensão: R$ " + AllTrim(Transform( aPd[nPos,5], "@E 999,999,999,999.99" )), 1, 3)
					fAddMemLog("% da pensão: " + cValToChar(nPercPensao), 1, 3)
					fAddMemLog("Valor da pensão: R$ " + AllTrim(Transform( nVlPens131, "@E 999,999,999,999.99" )), 1, 3)
				EndIf
			EndIf
		EndIf
		If lDesc131
			nValBase -= nBase131
		EndIf		
		If lIRPens .and. nValIR > 0 .And. cTipoRot $ "1,3,4,6"

			nValBase += nValIR //devolve o IR para a base poise sera descontado novamente
			//-- Deletar IR para recalculo			
			If (nPos := Ascan(aPd, { |X| X[1] = cIR .And. X[3] = cSemAtual .And. X[9] # "D" .And. X[7] # 'I'} )) > 0
				aPd[nPos,9] := "D"
			EndIf
			//Deletar base do I.R. p/ recalculo
			If cTipoRot = "3" .Or. (cTipoRot =="4" .And. cTipo = cTipoFER)
				nPos := Ascan(aPd, { |X| X[1] = aCodFol[16,1] .And. X[3] = cSemAtual .And. X[9] # "D" .And. X[7] # 'I' })
			ElseIf cTipoRot $ "6" .Or. (cTipoRot =="4" .And. cTipo = cTipo13O )
				nPos := Ascan(aPd, { |X| X[1] = aCodFol[27,1] .And. X[3] = cSemAtual .And. X[9] # "D" .And. X[7] # 'I' })
			Else
				nPos := Ascan(aPd, { |X| X[1] = aCodFol[15,1] .And. X[3] = cSemAtual .And. X[9] # "D" .And. X[7] # 'I' })
			EndIf
			If nPos > 0
				aPd[nPos,9] := 'D'
			EndIf		
		EndIf
		nValBase	:= If(nValBase < 0 ,0, nValBase )
		nLiqTemp 	:= NoRound(nValBase,2)

		If lMVPENSIR 	
			Aeval( aPd ,{ |X| If(!X[1] == aCodFol[64,1] .And.;
				( cTipoRot == "6" .Or. RetValSRV(X[1], SRA->RA_FILIAL, "RV_REF13") <> "S" ) .And.;
				( cTipoRot == "3" .Or. RetValSRV(X[1], SRA->RA_FILIAL, "RV_REFFER") <> "S" ),; 
				SomaInc(X,28, @nValPenNIr, 28, "S", 5, "N", Nil, Nil, aCodfol, Nil, Nil, Nil, Nil, Nil, Nil, .T.), Nil) })
		ENDIF
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcular pensao se nao for informado valor fixo 			 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nValFixo == 0 .And. nNrSlMin == 0
		nValPensao := NoRound((((nLiqTemp-nValIR-nValIRAdi) * nPercPensao)/100),2)
		If __lMemCalc
			fAddMemLog("Base de cálculo da pensão: R$ " + AllTrim(Transform( If (lIRPens .and. nValIR > 0, nLiqTemp - nValIR, nLiqTemp), "@E 999,999,999,999.99" )), 1, 2)
			fAddMemLog("1º cálculo da pensão:" , 1, 2)
			fAddMemLog("IR: R$ " + AllTrim(Transform( nValIR, "@E 999,999,999,999.99" )), 1, 3)
			If cTipoRot != "2"
				fAddMemLog("IR do adiantamento: R$ " + AllTrim(Transform( nValIRAdi, "@E 999,999,999,999.99" )), 1, 3)
			EndIf
			fAddMemLog("% da pensão: " + cValToChar(nPercPensao), 1, 3)
			fAddMemLog("Valor da pensão: R$ " + AllTrim(Transform( nValPensao, "@E 999,999,999,999.99" )), 1, 3)
		EndIf
	ElseIf nNrSlMin > 0
		If nNrSlMin > 0 .And. cTipo == "DFE"
			nValPensao := fDifPensaoSM( nNrSlMin, .T. )
		EndIf	
		nValPensao := NoRound((nValPensao * nPercPensao / 100),MsDecimais(1))
		If __lMemCalc
			fAddMemLog("% da pensão: " + cValToChar(nPercPensao), 1, 3)
			fAddMemLog("Valor da pensão: R$ " + AllTrim(Transform( nValPensao, "@E 999,999,999,999.99" )), 1, 3)	
			If cTipoRot == "3" .And. M->RH_PERC13S > 0
				fAddMemLog("Pensão de 13º sobre salário mínimo: ", 1, 2)
				fAddMemLog("Salário mínimo: R$ " + AllTrim(Transform( Val_SalMin, "@E 999,999,999,999.99" )), 1, 3)
				fAddMemLog("Qtde. salário(s) mínimo(s): " + cValToChar(nNrSlMin), 1, 3)
				fAddMemLog("% 13º salário: " + cValToChar(M->RH_PERC13S), 1, 3)
				fAddMemLog("% da pensão: " + cValToChar(nPercPensao), 1, 3)
				fAddMemLog("Valor da pensão: R$ " + AllTrim(Transform( nVlPens131, "@E 999,999,999,999.99" )), 1, 3)
			EndIf
		EndIf
	EndIf
	If cPaisLoc == "CHI" .And. (cTipoRot == "5" .or. nValFixo > 0)
		nValPensao := Round(nValPensao,MsDecimais(1))   
	EndIf
	
	If cTipoRot == "4" .and. cTipo == cTipoFER .and. ( nPos := Ascan(aPd, { |X| X[1] == cPensao .And. X[3] == cSemAtual .And. X[9] # "D" .and. X[7] == "K" } ) ) > 0
		cSeqAux := "1"
		nValPensao := nValPensao - aPd[nPos,5] //Subtrai a pensão que já foi descontada nas férias
	EndIf
	
    If (nValFixo > 0 .Or. nNrSlMin > 0) .And. cTipoRot == '5' .And. aPergunte[5,3] == 2
        nValPensao += fBuscaAcm( cPensao, Nil, sToD( StrZero(Year(dDataPgto), 4)+"0101" ), sToD( StrZero(Year(dDataPgto), 4)+"1231" ), "V")
    EndIf		
	
	If cPaisLoc == "BRA" .And. cTpPiso $ "2/3/4"
		If cTpPiso == "2"
			nVlBase	:= nVlPiso * nIndProp
		ElseIf cTpPiso == "3"
			nVlBase	:= NoRound( (nVlPiso/100) * Val_SalMin, MsDecimais(1) ) * nIndProp
		ElseIf cTpPiso == "4"
			nVlBase	:= NoRound( (nVlPiso/100) * (nLiqTemp-nValIR-nValIRAdi), 2 )
		EndIf
		nValPensao := fPisoPens( cTpPiso, nValPensao, nVlBase )
		If __lMemCalc
			fAddMemLog("Obs.: há configuração de piso para pensão:", 1, 3)
			fAddMemLog("Tipo do piso: " + cTpPiso, 1, 4)
			fAddMemLog("Valor do piso: R$ " + AllTrim(Transform( nVlBase, "@E 999,999,999,999.99" )), 1, 4)
			fAddMemLog("Valor da pensão após validação do piso: R$ " + AllTrim(Transform( nValPensao, "@E 999,999,999,999.99" )), 1, 4)
		EndIf
	EndIf
	
	FGeraVerba(cPensao,nValPensao,nPercPensao,cSemAtual,,"V",,,,dDataPgto,,,,cSeqAux)

	If nValFixo == 0 .and. nNrSlMin == 0 .and. nValPensao > 0 //Grava a base utilizada no cálculo
		aPd[Len(aPd),20] := (nLiqTemp-nValIR-nValIRAdi)
	EndIf
	
	If cTipoRot == "5" .And. lProp
		fVerVbBenef(aCodBenef, 2, nCnt1)
	EndIf

	If cTipoRot == "5" .Or. (cTipoRot == "2" .And. !lCadPensao) .Or. nValFixo > 0 .Or. nNrSlMin > 0
		Loop
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se nao utilizar IR, sair depois de calcular a pensao		 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lUsarIR .Or. !lRatIR
		If cMVPENSOUT == "N" // Ativar os codigos anteriormente deletados para calculo
			fVerVbBenef(aCodBenef,2,nCnt1)
		EndIf
		Loop
	EndIf
	
	nContVez   := 0
	nValPensao := 0
	lCalSlBru  := .F.
	lSairPens  := .F.
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se houver mais de uma pensao, marcar codigos anteriores como ³
	//³ deletados para nao serem utilizados como deducao na base I.R.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cMVPENSOUT == "N" .And. !lProp
		fVerVbBenef(aCodBenef,1,nCnt1)
	EndIf
	
	While Max((((nLiqTemp-nValIR-nValIRAdi) * nPercPensao)/100),nValPensao) - Min((((nLiqTemp-nValIR-nValIRAdi) * nPercPensao)/100),nValPensao) > 0.01 .And. ((lIRPens .And. lCalSlLiq) .OR. !lIRPens)
		nValPensao := NoRound((((nLiqTemp-nValIR-nValIRAdi) * nPercPensao)/100),2)
		nContVez++

		If __lMemCalc .And. nContVez > 1
			fAddMemLog(cValToChar(nContVez) + "º cálculo da pensão:", 1, 2)
			fAddMemLog("Base de cálculo da pensão: "+cvaltochar(nLiqTemp)+" - "+cvaltochar(nValIR)+" - "+cvaltochar(nValIRAdi)+" = R$ " + AllTrim(Transform((nLiqTemp-nValIR-nValIRAdi), "@E 999,999,999,999.99" )), 1, 3)
			fAddMemLog("IR: R$ " + AllTrim(Transform( nValIR, "@E 999,999,999,999.99" )), 1, 3)
			If cTipoRot != "2"
				fAddMemLog("IR do adiantamento: R$ " + AllTrim(Transform( nValIRAdi, "@E 999,999,999,999.99" )), 1, 3)
			EndIf
			fAddMemLog("% da pensão: " + cValToChar(nPercPensao), 1, 3)
			fAddMemLog("Valor da pensão: R$ " + AllTrim(Transform( nValPensao, "@E 999,999,999,999.99" )), 1, 3)
		EndIf

		If cPaisLoc == "BRA" .And. cTpPiso $ "2/3/4"
			If cTpPiso == "2"
				nVlBase	:= nVlPiso * nIndProp
			ElseIf cTpPiso == "3"
				nVlBase	:= NoRound( (nVlPiso/100) * Val_SalMin, MsDecimais(1) ) * nIndProp
			ElseIf cTpPiso == "4"
				nVlBase	:= NoRound( (nVlPiso/100) * (nLiqTemp-nValIR-nValIRAdi), 2 )
			EndIf
			nValPensao 	:= fPisoPens( cTpPiso, nValPensao, nVlBase )
			If __lMemCalc .And. nContVez > 1
				fAddMemLog("Obs.: há configuração de piso para pensão:", 1, 3)
				fAddMemLog("Tipo do piso: " + cTpPiso, 1, 4)
				fAddMemLog("Valor do piso: R$ " + AllTrim(Transform( nVlBase, "@E 999,999,999,999.99" )), 1, 4)
				fAddMemLog("Valor da pensão após validação do piso: R$ " + AllTrim(Transform( nValPensao, "@E 999,999,999,999.99" )), 1, 4)
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Procura codigo de Pensao em aPd								 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPos := Ascan(aPd, { |X| X[1] = cPensao .And. X[3] = cSemAtual .And. X[9] # "D" .and. (Empty(cSeqAux) .or. x[11] == cSeqAux )} )
		
		If nPos > 0
			If cPaisLoc == "BRA" .And. cTpPiso $ "2/3/4" .And. nContVez > 1 .And. !(Abs(nValPensao - aPd[nPos, 5]) > 0.01)
				lSairPens	:= .T.
			EndIf
			aPd[nPos,5]  := nValPensao
			aPd[nPos,20] := (nLiqTemp-nValIR-nValIRAdi)
			If nValPensao < 0
				aPd[nPos,9] := "D" 
			EndIf
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se for calculo pelo bruto, cancela apos o primeiro calculo   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lCalSlBru .Or. lSairPens .Or. nValPensao < 0
			Exit
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calculo valor do I.R. para deducao na pensao				 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc == "BRA"
			If cTipoRot = "3" .Or. (cTipoRot =="4" .And. cTipo = cTipoFER) .Or. ( cTipoRot = "1" .And. cTipo == "DFE" )
				If __lMemCalc       
					fAddMemLog(If(lIRPens, cValToChar(nContVez+1), cValToChar(nContVez)) + "º cálculo do IR na pensão: ", 1, 2)
				EndIf
				If cTipoRot = "1" .And. cTipo == "DFE"
					fcIrFer(aCodfol, aTabIr, .T., dDataPgto)
				Else 
					fcIrFer(aCodfol, aTabIr, If ( cTipo = cTipoFER, .T.,.F.), If(cTipoRot =="4" .And. cTipo == cTipoFER, M->RG_DATAHOM, M->RH_DTRECIB), .T., If(cTipoRot = "3", "F", nil))
				EndIf
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Deletar base do I.R. p/ recalculo (utilizar pensao p/deducao)³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nPos := Ascan(aPd, { |X| X[1] = aCodFol[16, 1] .And. X[3] = cSemAtual .And. X[9] # "D" .And. X[7] # 'I' })
				If nPos > 0
					aPd[nPos, 9] = 'D'
				EndIf
				
			ElseIf cTipoRot $ "5*6" .Or. (cTipoRot =="4" .And. cTipo = cTipo13O )
				nValPenInc := 0
				
				If lMVPENSIR
					Aeval( aPd ,{ |X| SomaInc(X, 5, @nValPenInc, 28, "N", 5, "S", Nil, Nil, aCodfol, Nil, Nil, Nil, Nil, Nil, Nil, .T.) })
				EndIf 
				If __lMemCalc       
					fAddMemLog(If(lIRPens, cValToChar(nContVez+1), cValToChar(nContVez)) + "º cálculo do IR na pensão: ", 1, 2)
				EndIf
				If nValPenInc > 0
					fcIr13o(aCodfol,If ( cTipo == cTipo13O, aTabIr,aTabIr13),.T.,If (cTipo = cTipo13O ,.T.,.F.),If(cTipoRot =="4",nIr13P,nil),,nLiqTemp-nValPensao-nValPenNIr)
				Else
					fcIr13o(aCodfol,If ( cTipo == cTipo13O, aTabIr,aTabIr13),.T.,If (cTipo = cTipo13O ,.T.,.F.),If(cTipoRot =="4",nIr13P,nil))
				EndIf
				
				nPos := Ascan(aPd, { |X| X[1] = aCodFol[27,1] .And. X[3] = cSemAtual .And. X[9] # "D" .And. X[7] # 'I' })
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Salva a ultima base do IR para finalizacao do calculo de Pensao ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !lProp
					If (nPosIR	:= Ascan(aPdIR, { |X| X[1] == aCodFol[27,1] .And. X[3] = cSemAtual .And. X[9] # "D" .And. X[7] # 'I' }) ) > 0
						If nPos > 0
							aPdIR[nPosIR,4]		:= aPd[nPos,4]
							aPdIR[nPosIR,5]		:= aPd[nPos,5]
							aPdIR[nPosIR,9]		:= " "
						Else
							aPdIR[nPosIR,9]		:= "D"
						EndIf
					Else
						If nPos > 0
							aAdd(aPdIR , aClone( aPd[nPos] ) )
						EndIf
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Deletar base do I.R. p/ recalculo (utilizar pensao p/deducao)³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nPos > 0
					aPd[nPos,9] = 'D'
				EndIf
			ElseIf cTipoRot = "2"
				nBaseIrAdi := Base_Ini    // Preserva base (sera alterada durante o calculo)
				FM010IncIR()		       // Calcula o I.R.
				Base_Ini   := nBaseIrAdi   // Retorna a base original
				nValIR     := IR_CALC      // Preserva o valor do I.R.
				IR_CALC    := 0.00         // Zera o I.R. para um novo calculo
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Calculo do IR para deducao na PENSAO                         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If __lMemCalc       
					fAddMemLog(If(lIRPens, cValToChar(nContVez+1), cValToChar(nContVez)) + "º cálculo do IR na pensão: ", 1, 2)
				EndIf
				IF lMVPENSIR
					Aeval( aPd ,{ |X| SomaInc(X, 5, @nValPenInc, 28, "N", 5, "S", Nil, Nil, aCodfol, Nil, Nil, Nil, Nil, Nil, Nil, .T.) })
					If nValPenInc > 0
						fCIr(aCodfol,If(cTipoRot = "6",aTabIR13,aTabIr),if(cTipoRot == "4","R",nil),dDataPgto,cFilialCor,cNumDepIr,cTipoPgto,nLiqTemp-nValPensao-Iif(nValPenNIr<0 .and. !Empty(cVbBaseP), nValPenNIr * -1, nValPenNIr))
					Else
						fCIr(aCodfol,If(cTipoRot = "6",aTabIR13,aTabIr),if(cTipoRot == "4","R",nil),dDataPgto,cFilialCor,cNumDepIr,cTipoPgto)
					EndIf
				Else
					fCIr(aCodfol,If(cTipoRot = "6",aTabIR13,aTabIr),if(cTipoRot == "4","R",nil),dDataPgto,cFilialCor,cNumDepIr,cTipoPgto)
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Deletar base do I.R. p/ recalculo (utilizar pensao p/deducao)³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nPos := Ascan(aPd, { |X| X[1] = aCodFol[15,1] .And. X[3] = cSemAtual .And. X[9] # "D" .And. X[7] # 'I' })
				If nPos > 0
					aPd[nPos,9] := 'D'
				EndIf
			EndIf
		Else
		   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calculo do IR para deducao na PENSAO                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cPaisLoc <> "CHI" .Or. cTipoRot $ "1|2"
				LocGananc()
			EndIf	
		   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Deletar base do I.R. p/ recalculo (utilizar pensao p/deducao)³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTipoRot == "1"
				nPos := Ascan(aPd, { |X| X[1] = aCodFol[15,1] .And. X[3] = cSemAtual .And. X[9] # "D" .And. X[7] # 'I' })
			ElseIf cTipoRot = "3" .Or. (cTipoRot =="4" .And. cTipo = cTipoFER)
				nPos := Ascan(aPd, { |X| X[1] = aCodFol[16,1] .And. X[3] = cSemAtual .And. X[9] # "D" .And. X[7] # 'I' })
			ElseIf cTipoRot $ "5|6" .Or. (cTipoRot =="4" .And. cTipo = cTipo13O )
				nPos := Ascan(aPd, { |X| X[1] = aCodFol[27,1] .And. X[3] = cSemAtual .And. X[9] # "D" .And. X[7] # 'I' })
			Else
				nPos := Ascan(aPd, { |X| X[1] = aCodFol[15,1] .And. X[3] = cSemAtual .And. X[9] # "D" .And. X[7] # 'I' })
    		EndIf
			If nPos > 0
				aPd[nPos,9] := 'D'
			EndIf				
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Recuperar o valor do I.R.                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPos := Ascan(aPd, { |X| X[1] = cIR .And. X[3] = cSemAtual .And. X[9] # "D" } )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Salva o ultimo valor de IR para finalizacao do calculo de Pensao da 2a parc. 13o. salario ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cTipoRot = "6" .Or. (cTipoRot =="4" .And. cTipo = cTipo13O )
			If !lProp
				If (nPosIR	:= Ascan(aPdIR, { |X| X[1] == cIR .And. X[3] = cSemAtual .And. X[9] # "D" .And. X[7] # 'I' }) ) > 0
					If nPos > 0
						aPdIR[nPosIR,4]		:= aPd[nPos,4]
						aPdIR[nPosIR,5]		:= aPd[nPos,5]
						aPdIR[nPosIR,9]		:= " "
					else
						aPdIR[nPosIR,9]		:= "D"
					EndIf
				else
					If nPos > 0
						aAdd(aPdIR , aClone( aPd[nPos] ) )
					EndIf
				EndIf
			EndIf
		EndIf

		If nPos > 0
			nValIR := NoRound(aPd[nPos,5],2)
			//-- Deleta para ser calculado novamente
			If cTipoRot $  "1*4*6*3*9*O" .And. aPd[nPos,7] # "I"
				aPd[nPos,9] := "D"
			EndIf
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se nao for calculo pelo liquido, indica que e pelo bruto	 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lCalSlLiq
			lCalSlBru := .T.
		EndIf

		If !lCalSlBru .And. !( Max((((nLiqTemp-nValIR-nValIRAdi) * nPercPensao)/100),nValPensao) - Min((((nLiqTemp-nValIR-nValIRAdi) * nPercPensao)/100),nValPensao) > 0.01 )
			If __lMemCalc
				fAddMemLog("Valor de desconto da pensão em folha : R$ " + AllTrim( Transform(nValPensao, "@E 999,999,999.99") ), 1, 2)
			EndIf
		EndIf
	Enddo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ativar os codigos anteriormente deletados para calculo		 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cMVPENSOUT == "N"
		fVerVbBenef(aCodBenef,2,nCnt1)
	EndIf
	If cPaisLoc == "CHI"
		nPos := Ascan(aPd, { |X| X[1] = cPensao .And. X[3] = cSemAtual .And. X[9] # "D" } )
		If nPos > 0
			aPd[nPos,5] := Round(aPd[nPos,5],MsDecimais(1))
		EndIf
	EndIf
Next nCnt1

aCodBenef := aClone( aOldBenef ) // Restaura aCodBenf original

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento especial quando for roteiro da 2¦ parcela do 13§	 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (cTipoRot == "6") .or. ( cTipoRot == "4" .and. cTipo == cTipo13O )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Preservando o ultimo ir calculado de 13o salario pois se o funcionario tem pensao na ³
	//³ primeira parcela do 13o salario abateremos a pensao completa da base de calculo do IR³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Len(aPdIR) == 0 	.Or. cMVPENSOUT == "N" .or. cPaisLoc == "BRA"
		If cPaisLoc == "BRA"
			If (cTipoRot = "6" .and. !lProp)				
				If __lMemCalc       
					fAddMemLog("Último cálculo do IR na pensão: ", 1, 2)
				EndIf
                fcIr13o( aCodfol, If(cTipoRot = "6",aTabIR13,aTabIr), .T., If (cTipo = cTipo13O,.T.,.F.), If(cTipoRot =="4",nIr13P,Nil), .T.)
            EndIf
		Else
			If cPaisLoc <> "CHI"
				LocGananc()
			EndIf	
		EndIf			
	Else
		For nx := 1 to len(aPdIR)
			If aPdIR[nx,9] <> "D"
				if ( nPosIR := Ascan(aPd, { |X| X[1] == aPdIR[nx,1] .And. X[3] == aPdIR[nx,3] .And. X[7] == aPdIR[nx,7] }) ) > 0
					aPd[nPosIR,4]	:= aPdIR[nx,4]
					aPd[nPosIR,5]	:= aPdIR[nx,5]
					aPd[nPosIR,9]	:= aPdIR[nx,9]
				else
					aAdd( aPd , aClone( aPdIR[nx] ) )
				EndIf
			EndIf
		next nx
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ajuste da pensao alimenticia quando existir pensao na 1a.parc³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nCnt1   := 1 To Len(aCodBenef)
		cVb131  := aCodBenef[nCnt1,7]
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Pesquisa Codigo de Pensao Descontado na 1o. Parcela			 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPos2 := Ascan(aPd, { |X| X[1] = cVb131 .And. X[3] = cSemAtual .AND. X[9] # "D" } )
		If !(aCodFol[183,1] $ aCodBenef[nCnt1,5])//Desc. Ant. 13o. na 2o. Parcela
			cPensao := aCodBenef[nCnt1,1]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Procura codigo de Pensao em aPd							     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPos3 := Ascan(aPd, { |X| X[1] = cPensao .And. X[3] = cSemAtual .AND. X[9] # "D" } )
			If nPos3 > 0
				If nPos2 > 0
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Abate da Pensao da 2¦ Parc. a Pensao Descontada na 1¦ Parcela³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aPd[nPos3,5] := NoRound(aPd[nPos3,5] - aPd[nPos2,5],MsDecimais(1))
				EndIf
				aPd[nPos3,5] := If(aPd[nPos3,5] < 0, 0, aPd[nPos3,5])
			EndIf
			
			If nPos3 > 0 .And. ( Ascan(aPd, { |x| x[1] = aCodFol[247,1] .And. x[3] = cSemAtual .And. x[9] # "D" } ) > 0 ) .And.;
			  Type("aValP132") == "A" .And. ( ( nPosP132 := Ascan( aValP132, { |x| x[1] = cPensao } ) ) > 0 )
			  	aPd[nPos3,5] := Max(NoRound(aPd[nPos3,5] - aValP132[nPosP132,2],MsDecimais(1)), 0)
				If aPd[nPos3,5] == 0 
					lPgtP132 := .T.
				EndIf	
			EndIf
		EndIf 
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Zera o Valor da Primeira para nao descontar novamente na 2¦. ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nPos2 > 0 .And. aPd[nPos2,5] > 0
			nVlDed131 += aPd[nPos2, 5]
			aPd[nPos2,5] := 0.00
			aPd[nPos2,9] := "D"
		EndIf 
	Next nCnt1	

	//Gera ID 1961 com o valor da pensão do 131 no 132 ou na rescisão, para demonstração da dedução da base do IRRF no evento S-5002 do eSocial 
	If lTem1961 .And. nVlDed131 > 0 .And. !lPgtP132
		FMatriz(aCodfol[1961, 1], nVlDed131, 0, cSemana)
	EndIf

EndIf

If Len(aBenefAux) > 0
	If __lMemCalc
		fAddMemLog("Proporcionalização da(s) pensão(ões):", 1, 1)
	EndIf
	For nCnt1 := 1 to Len(aBenefAux)
		If aBenefAux[nCnt1,3] > 1
			If cMVPENSOUT == "S" 
				nPercTot := aBenefAux[nCnt1,4]
				cPdAux   := aBenefAux[nCnt1,5]
				nPensTot := 0
				aPdAux   := {}
				aEval( aPd, { |X| If( X[1] $ cPdAux, nPensTot += X[5] , 0 ) } )
				If nPensTot > 0
					For nX := 1 to Len(aBenefAux[nCnt1,6])
						If __lMemCalc
							fAddMemLog("Proporcionalização do beneficiário: " + aBenefAux[nCnt1,6,nX,3] + ":", 1, 2)
						EndIf
						cPdAux := aBenefAux[nCnt1,6,nX,1]
						nPerc  := aBenefAux[nCnt1,6,nX,2]
						If ( nPos := Ascan( aPd, {|x| x[1] == cPdAux .And. x[9] <> "D"} ) )  > 0
							If __lMemCalc
								fAddMemLog("Valor anterior da pensão: R$ " + AllTrim(Transform( aPd[nPos,5], "@E 999,999,999,999.99" )), 1, 3)
								fAddMemLog("Valor total da(s) pensão(ões): R$ " + AllTrim(Transform( nPensTot, "@E 999,999,999,999.99" )), 1, 3)
								fAddMemLog("% total da pensão: " + cValToChar(nPercTot), 1, 3)
								fAddMemLog("% da pensão: " + cValToChar(nPerc), 1, 3)
								fAddMemLog("Índice de proporcionalização: " + cValToChar((nPerc / nPercTot)*100) + "%", 1, 3)
							EndIf
							aPd[nPos,5] := Round( (nPensTot * nPerc) / nPercTot ,2 ) 
							If __lMemCalc
								fAddMemLog("Valor da pensão após proporcionalização: R$ " + AllTrim(Transform( aPd[nPos,5], "@E 999,999,999,999.99" )), 1, 3)
							EndIf
						EndIf
					Next nX
				EndIf
			ElseIf cMVPENSOUT == "N"
				nPercTot := aBenefAux[nCnt1,4]
				cPdAux   := aBenefAux[nCnt1,5]
				For nX := 1 to Len(aBenefAux[nCnt1,6])
					If __lMemCalc
						fAddMemLog("Proporcionalização do beneficiário: " + aBenefAux[nCnt1,6,nX,3] + ":", 1, 2)
					EndIf
					cPdAux := aBenefAux[nCnt1,6,nX,1]
					nPerc  := aBenefAux[nCnt1,6,nX,2]
					If ( nPos := Ascan( aPd, {|x| x[1] == cPdAux .And. x[9] <> "D"} ) )  > 0
						If __lMemCalc
							fAddMemLog("Valor total da pensão: R$ " + AllTrim(Transform( aPd[nPos,5], "@E 999,999,999,999.99" )), 1, 3)
							fAddMemLog("Quantidade de pensão(ões) para divisão: " + cValToChar(aBenefAux[nCnt1,3]), 1, 3)
						EndIf
						aPd[nPos,5] := Round( aPd[nPos,5] / aBenefAux[nCnt1,3] ,2 ) 
						aPd[nPos,4] := nPerc
						If __lMemCalc
							fAddMemLog("Valor da pensão após proporcionalização: R$ " + AllTrim(Transform( aPd[nPos,5], "@E 999,999,999,999.99" )), 1, 3)
						EndIf
					EndIf
				Next nX
			EndIf
		EndIf
	Next nCnt1
EndIf

//Se foi lançada 1/3 de férias na folha referente a MP, refaz o cálculo como diferença de férias
If cPaisLoc == "BRA" .and. !lDifFerMP .and. cTipoRot == "1" .and. ( aScan(aPd, {|x| x[1] $ P_ADIPGFE + "/" + P_ADIPGAB }) ) > 0
	FCalcPensao(aCodFol[65, 1], aCodFol[67, 1],,,dData_Pgto,"DFE",,,,,,,.T.)
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³fBsPensAdt()³ autor ³ Emerson Rosa        ³ Data ³ 18/03/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Monta Base de Pensao para o Adiantamento                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fBsPensAdt(aPd, nValBase)
Local nAdt			:= 0
Local cAlias 		:= ALIAS()

DEFAULT __lMemCalc 	:= (cPaisLoc == "BRA" .And. fMemCalc())

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Utiliza valor do adiantamento como base p/ calculo da pensao ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If RetValSRV(aCodFol[6,1],xFilial("SRV"),"RV_PENSAO") == "S" .And. Type("Val_Adto") # "U"
	nValBase := Val_Adto
	If __lMemCalc
		fAddMemLog("Verba : " + aCodFol[6,1] + " - " + AllTrim( RetValSRV(aCodFol[6,1], SRA->RA_FILIAL, "RV_DESC")) + "(Id 0006) ", 1, 4)
		fAddMemLog("Valor : R$ " + AllTrim(Transform( Val_Adto, "@E 999,999,999,999.99" )), 1, 4)
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega valor da base com demais verbas que incidem pensao   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nAdt := 1 To Len(aPd)
	If aPd[nAdt,1] # aCodfol[6,1] .And. aPd[nAdt,3] == cSemana
		
		If RetValSRV( aPd[nAdt,1], SRA->RA_FILIAL,"RV_PENSAO") == "S" .And. RetValSRV( aPd[nAdt,1], SRA->RA_FILIAL,"RV_ADIANTA") == "S"
			If RetValSRV( aPd[nAdt,1], SRA->RA_FILIAL,"RV_TIPOCOD") $ "1*3"    // Provento/Base
				nValBase += aPd[nAdt,5]
			ElseIf RetValSRV( aPd[nAdt,1], SRA->RA_FILIAL,"RV_TIPOCOD") == "2" // Desconto
				nValBase -= aPd[nAdt,5]
			EndIf
			If __lMemCalc
				fAddMemLog("Verba : " + aPd[nAdt,1] + " - " + AllTrim( RetValSRV( aPd[nAdt,1], SRA->RA_FILIAL, "RV_DESC")) + If (!Empty(RetValSRV(aPd[nAdt,1], SRA->RA_FILIAL, "RV_CODFOL")), " -  (Id " + AllTrim( RetValSRV(aPd[nAdt,1], SRA->RA_FILIAL, "RV_CODFOL")) + ") ", ""), 1, 4)
				fAddMemLog("Valor : R$ " + AllTrim(Transform( aPd[nAdt,5], "@E 999,999,999,999.99" )), 1, 4)
			EndIf
		EndIf
	EndIf
Next nAdt
dbSelectArea( cAlias )

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FGerValFut ³ autor ³ Mauro               ³ Data ³ 27/06/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gerar Descconto de Valores Futuros                         ´±±
±±³ÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³±±
±±³Parametro ³ cTipo =  "N" ou "R" (Quando for "R" desconta Integral)     ´±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGerValFut(cTipo)

Local aAreaSRR  := {}
Local aArray   	:= {}
Local aValFut  	:= {}
Local bQuebra
Local cCC      	:= ""
Local cClVl
Local cCodigo  	:= ""
Local cCodJur	:= ""
Local cCodAux	:= ""
Local cEmpCons
Local cItem
Local cNumId	:= ""
Local cIdCmpl	:= ""
Local cTipoV	:= ""
Local cChaveSRR := ""
Local cCompet	:= ""
Local dDtAux
Local dDtValFut := dData_Pgto
Local dDtaRef	:= CtoD("")
Local lLctoDia	:= .F.
Local lEmprest 	:= .F.
Local lImpPonto	:= .F.
Local lProcessa
Local lResMSeg 	:= .F.
Local n		   	:= 0
Local nCnt	   	:= 0
Local nHoras   	:= 0 
Local nQtdeLc  	:= 0
Local nPosPd	:= 0
Local nPosRK	:= 0
Local nRecSRC  	:= 0
Local nSomaMeses:= 0
Local nTotSem  	:= 0
Local nValor   	:= 0 
Local nJuros    := 0
Local nValJur	:= 0
Local nValSRC  	:= 0.00

Local aPerFol		:= {}
Local aConvocacao   := {}
Local lChkRUO		:= .T.
Local lUltSemFol	:= .F.
Local nPosSemFol	:= 0

Local lItemClVl		:= SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "1*3"
Local lRegraDS 		:= SRK->( FieldPos( "RK_REGRADS" ) # 0 )	   // Testa se a base foi atualizada  
Local lTemEmpC 		:= SRK->( FieldPos( "RK_EMPCONS" ) # 0 )
Local nOrdBkp		:= SRC->(IndexOrd())
Local cMesFol		:= ""
Local cTipoFol      := fGetRotOrdinar() 

Static lChkEConsig

DEFAULT lTemRefQua  := SRV->( ColumnPos( "RV_REFQUAR" ) ) > 0
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() //Memória de Cálculo
DEFAULT lChkEConsig := cPaisLoc == "BRA" .and. cTipoRot = "4" .and. cCompl <> "S" .and. ChkFile("RUO")

If lRegraDS .And. cTipoRot == "3"
	fCarPeriodo( cPeriodo, cTipoFOL, @aPerFol, @lUltSemFol, @nPosSemFol)		
	If Len(aPerFol) > 0
		dDtValFut := aPerFol[nPosSemFol,17]
	Else
		dDtValFut 	:= M->RH_DATAINI
	EndIf
EndIf

If cTipoRot == "4"
	cMesFol	:= MesAno(dDataDe)
	fGetPerAtual( @aPerFol, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES,fGetRotOrdinar() )
	If Len(aPerFol) > 0 
		cMesFol := aPerFol[1][1]
	EndIf
EndIf

cTipo := If(cTipo =Nil,'N',cTipo)

aSentenca	:= {}
dbSelectArea("REP")
If !EMPTY(REP->(INDEXKEY(3)))
	REP->( DbSetOrder(3))
EndIf	

dbSelectArea("SRK")
If SRK->(Ordkey(2)) ==  "RK_FILIAL+RK_MAT+RK_PD+RK_CC+RK_ITEM+RK_CLVL"
	DbSetOrder(2) // RK_FILIAL+RK_MAT+RK_PD+RK_CC+RK_ITEM+RK_CLVL
Else
	DbSetOrder(1) // RK_FILIAL+RK_MAT+RK_PD+RK_DOCUMENT
EndIf
dbSeek( SRA->RA_FILIAL + SRA->RA_MAT )
If __lMemCalc
	fAddMemLog("Verbas FGTS valores futuros:", 1, 2)
EndIf
While ! Eof() .And. SRK->RK_FILIAL + SRK->RK_MAT == SRA->RA_FILIAL + SRA->RA_MAT
	cCC     	:= SRK->RK_CC
	cItem    	:= If(lItemClVl, SRK->RK_ITEM,"")
	cClVl    	:= If(lItemClVl, SRK->RK_CLVL,"")
	cEmpCons   	:= If(lTemEmpC,SRK->RK_EMPCONS,"N") //Campo emprestimo consignado so existe no Brasil
	cIdCmpl		:= SRK->RK_IDCMPL
	//Monta a data inicio e fim do mes do dissidio, caso o lancamento seja referente a um dissidio
	If !Empty( SRK->RK_MESDISS ) .And. Empty(SRK->RK_NUMID)
		dDtAux 	:= sTod( SubStr( SRK->RK_MESDISS, 3, 4) + SubStr( SRK->RK_MESDISS, 1, 2) + "01")
		If Empty(dDtAux)
			dDtAux 	:= sTod( SRK->RK_MESDISS + "01")
			If !Empty(dDtAux)
				cNumId  := dToS( dDtAux ) + " - " + SRK->RK_MESDISS + StrZero( f_UltDia( dDtAux ), 2 )
			EndIf
		Else
			cNumId 	:= dToS( dDtAux ) + " - " + SubStr( SRK->RK_MESDISS, 3, 4) + SubStr( SRK->RK_MESDISS, 1, 2) + StrZero( f_UltDia( dDtAux ), 2 )
		EndIf 
	Else
		cNumId	:= SRK->RK_NUMID
	EndIf
	cCodigo 	:= SRK->RK_PD
	cTipoV		:= ""
	cCodJur		:= SRK->RK_PDJUROS
	lImpPonto	:= .F.
	nHoras  	:= 0
	nJuros		:= SRK->RK_JUROMES
	nValor  	:= 0
	nTotSem 	:= 0	
	nQtdeLc 	:= 0
	nX			:= 0
	
	If cTipoRot == "4" .And. cCompl == "S" .And. lProxMes .And. RetValSRV(cCodigo,SRA->RA_FILIAL,"RV_EMPCONS") == "1"
		SRK->( dbSkip() )
		Loop
	EndIf
	
	If cCodigo <> cCodAux
		lLctoDia := RetValSRV(cCodigo,SRA->RA_FILIAL,"RV_LCTODIA") == "S" //Indica que possui lançamento diário
		dDtaRef	 := dDataDe //Primeiro dia do período (mnemonico)
		cCodAux  := cCodigo
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Para semanalistas, Deve Verificar as Parcelas             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SRA->RA_TIPOPGT = "S"
		For  n=1 to Len(aPd)
			If aPd[n,1] == cCodigo .and. aPd[n,9] # 'D'
				Aadd(aValFut,{aPd[n,1],aPd[n,5],aPd[n,10],aPd[n,02],aPd[n,03]})
			EndIf
		Next N
	EndIf
	
	// Soma os valores por verba, Centro de Custo, Item e Classe de valor
	bQuebra := { || SRK->RK_CC == cCC .And. If(lItemClVl, SRK->RK_ITEM == cItem,.T.) .And. If(lItemClVl, SRK->RK_CLVL == cClVl,.T.) .And. If(!Empty(SRK->RK_NUMID),SRK->RK_NUMID == cNumId, .T.) }
	
	While SRK->(!Eof()) .And. cCodigo == SRK->RK_PD .And. SRK->RK_FILIAL + SRK->RK_MAT == SRA->RA_FILIAL + SRA->RA_MAT 	.And.;
			Eval(bQuebra)  
			
		cEmpCons   	:= If(lTemEmpC, SRK->RK_EMPCONS,"N")
			
		//- Somente gera parcelas para item nao quitado em banco (instituicao financeira ou por outro meio que
		//--nao folha de pagamento).
		lProcessa := .F.
		
		If cTipo == "R"
			//Se já houve complementar anterior, e as verbas estão no aPd, significa que essas verbas já foram pagas.
			If !( cTipoRot == "4" .and. cCompl == "S" .And. lProxMes .and.;
				 aScan( aSrgRecnos , { |x| MesAno( x[2] ) == MesAno( M->RG_DTGERAR ) } ) > 0 .and.;
				 ( nPosRK := aScan( aPd, {|x| x[1] == SRK->RK_PD .And. x[9] <> "D" .And. x[7] == "G"} ) )  > 0 )
				lProcessa := .T.
			EndIf
		Else
			If lRegraDS .And. SRK->RK_REGRADS == "2" 	// Desconto em Ferias Quando Houver      
				//Se no calculo da folha existir a verba de lançamento futuro e tiver sido gerada nas férias (x[7] == "K"), esta sera desconsiderada
				If cTipoRot == "1" .And. Ascan( aPd, {|x| x[1] == SRK->RK_PD .And. x[9] <> "D" .And. x[7] == "K"} )  > 0
					lProcessa := .F.
				Else
					lProcessa := .T.
				EndIf	
			Else		// Desconto em Folha
				If cTipoRot <> "3"
					lProcessa := .T.
				EndIf
			EndIf
		EndIf	
		
		If !lProcessa
			dbSkip()
			Loop
		EndIf
		
		aArray := {}
		//--Montagem do periodo de abrangencia da verba de lancto. futuro
		If lDissidio .And. ( nPosRK := Ascan( aPd, {|x| x[1] == SRK->RK_PD .And. x[2] == SRK->RK_CC .And. x[9] == "D" } ) ) > 0
			nForSRK := If( MesAno( aPd[nPosRK,10] ) <> MesAno( dDataAte ), 1, 0 ) + SRK->RK_PARCELA // Periodo para regime caixa ou competencia

			For nCnt := nForSRK To 1 Step -1
				aAdd( aArray, MesAno( MonthSub( SRK->RK_DTVENC, nCnt ) ) )
			Next nCnt
		EndIf

		//--Se nao for quitado pelo banco ou se for Dissidio e o periodo do calculo estiver no periodo de abrangencia da verba de lancto. futuro
		If !lDissidio .And. SRK->RK_QUITAR <> '3'
			If ( ( ( cTipo == "R" ) .Or. ( SRK->RK_DTVENC <= dDtValFut ) ) .AND. ;
			     ( SRK->RK_STATUS == "2" ) .AND. ;
			     ( SRK->RK_PARCPAG < SRK->RK_PARCELA ) ) .Or.;
				 ( cPaisLoc == 'BRA' .And. SRK->RK_DTVENC <= dDtValFut .And. SRK->RK_TIPO == "P" .And. SRK->RK_STATUS == "2" )	
				
				If cPaisLoc == 'BRA' .And. SRK->RK_TIPO == "P"
					cTipoV		:= PosSrv( SRK->RK_PD, SRK->RK_FILIAL, "RV_TIPO" )
					lImpPonto 	:= .T.
					nHoras		+= SRK->RK_HORAS
				EndIf

				If cTipo == 'R' .Or. (cPaisLoc =='ARG' .And. SRK->RK_PD==aCodFol[327,1].And. Month(dDtValFut)==12)  .or. ;
				( cPaisLoc <> 'COL' .AND. !Empty(SRK->RK_QUITAR) .And. !(SRK->RK_QUITAR $ "2*3") )
					
					If cTipo == "R"
						//Se rescisão e verba de empréstimo consignaoo do Programa de Credito ao trabalhador, desconta apenas o valor da parcela
						If cPaisLoc == "BRA" .AND. RetValSRV(SRK->RK_PD, SRA->RA_FILIAL, "RV_NATUREZ") == "9253"
							lChkRUO  := .F.
							If  cCompl <> "S"
								nValor   += SRK->RK_VALORPA
							Else 
								nValor += fGetConsOri(SRK->RK_PD, SRK->RK_NUMID) //Quando for complementar no mesmo mês, inclui a verba apenas se ela já foi calculada na primeira rescisão
							EndIf
							lEmprest := .F.		
						ElseIf !lTemRefQua .Or. RetValSRV(SRK->RK_PD, SRA->RA_FILIAL, "RV_REFQUAR") != "1"
                            lResMSeg := ( MesAno( dDataDem1 ) > cMesFol )
                            nRecSRC := SRC->(Recno())
                            SRC->(dbSetOrder(1))
                            If lResMSeg
								If !( SRC->( dbSeek( SRK->RK_FILIAL + SRK->RK_MAT + SRK->RK_PD + SRK->RK_CC + cSemana ) ) .And.;
                                (( SRK->RK_PARCELA - SRK->RK_PARCPAG == 1 ) .And. (MesAno(SRC->RC_DTREF) == MesAno(SRK->RK_DTREF) .Or.  (cPaisLoc <> 'COL' .And. SRK->RK_QUITAR == "1" ))))
                                
                                    If SRC->(!Eof() .and. RC_FILIAL + RC_MAT + RC_PD + RC_SEMANA == SRK->(RK_FILIAL + RK_MAT + RK_PD + cSemana)) .And. !(SRK->RK_PARCELA == 1 .And. SRK->RK_PARCPAG == 0) 
										While SRC->(!Eof() .and. RC_FILIAL + RC_MAT + RC_PD + RC_SEMANA == SRK->(RK_FILIAL + RK_MAT + RK_PD + cSemana))
                                            If AllTrim(SRK->RK_NUMID) == AllTrim(SRC->RC_NUMID)
                                                nValSRC := SRC->RC_VALOR
                                                nValor  += ( ( ( SRK->RK_VALORPA * SRK->RK_PARCELA ) - SRK->RK_VLRPAGO ) + SRK->RK_VALORAR )
                                                
                                                If SRC->RC_TIPO2 == "G"
                                                    nValor  -= nValSRC
                                                EndIf
                                                lEmprest:= If( cEmpCons == "1", .T., .F. )
                                            EndIf
                                            SRC->(DbSkip())
                                        EndDo
                                    Else
                                        nValor  += ( ( ( SRK->RK_VALORPA * SRK->RK_PARCELA ) - SRK->RK_VLRPAGO ) + SRK->RK_VALORAR )
                                        lEmprest:= If( cEmpCons == "1", .T., .F. )
                                    EndIf								
                                EndIf
                            Else
                                nValor  += ( ( ( SRK->RK_VALORPA * SRK->RK_PARCELA ) - SRK->RK_VLRPAGO ) + SRK->RK_VALORAR )
								If __lMemCalc
									If nValor > 0 .And. SRK->RK_PD == aCodfol[337,1]
										fAddMemLog("Verba: "  + aCodfol[337,1] + " - " + AllTrim( RetValSRV(aCodfol[337,1], SRA->RA_FILIAL, "RV_DESC")) + " = R$ " + AllTrim(Transform(nValor, "@E 999,999,999,999.99" )), 1, 3)
										fAddMemLog("Base FGTS: R$ " + AllTrim(Transform( nValor, "@E 999,999,999,999.99" )), 1, 2)
									ElseIf  nValor > 0 .And. SRK->RK_PD == aCodfol[339,1]
										fAddMemLog("FGTS do mês: R$ " + AllTrim(Transform( nValor, "@E 999,999,999,999.99" )), 1, 2)
									EndIf
								EndIf
                                lEmprest:= If( cEmpCons == "1", .T., .F. )
                            EndIf
                            
                            SRC->( dbGoTo( nRecSRC ) )
                            SRC->(dbSetOrder(nOrdBkp))
                        Else
                            nValor  += (SRK->RK_VALORPA + SRK->RK_VALORAR) + Iif( Empty(cCodJur), SRK->RK_PCJUROS, 0 )
                            nValJur += Iif( !Empty(cCodJur), SRK->RK_PCJUROS, 0 )
                        EndIf
					Else
						nValor  += ( ( ( SRK->RK_VALORPA * SRK->RK_PARCELA ) - SRK->RK_VLRPAGO ) + SRK->RK_VALORAR  )
					EndIf
				Else
					If SRA->RA_TIPOPGT == "S"
						If Ascan(aValFut,{|X| X[1] = SRK->RK_PD .and. x[4] == SRK->RK_CC .and. X[3] >= SRK->RK_DTVENC .And. X[5] >= SRK->RK_NUMPAGO }) = 0
							nValor += If( ( SRK->RK_PARCELA=1                                                   ) .OR. ; 
							              ( SRK->RK_PARCELA >1 .and. ( SRK->RK_PARCPAG + 1 = SRK->RK_PARCELA ) )     ,;  //-- Se for a ultima parcela,  deve-se somar o valor do residuo 
											(SRK->RK_VALORPA + SRK->RK_VALORAR),;
											 SRK->RK_VALORPA )
						
						EndIf
					Else
						If cTipoRot == "3"
							//Verifica se tem Folha aberta e se já houve lançamento da verba na FOL.
							SRC->(dbSetOrder(1))
							If SRC->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cCodigo + cCC + cSemana ) )
								nSomaMeses := 0
								While ( SRC->(!Eof() .and. RC_FILIAL + RC_MAT + RC_PD + RC_CC + RC_SEMANA) == SRA->(RA_FILIAL + RA_MAT + cCodigo + cCC + cSemana) )
									If AllTrim(cNumId) == AllTrim(SRC->RC_NUMID)
										nSomaMeses++
									EndIf
									SRC->(DbSkip())
								EndDo
							EndIf
							If SRK->RK_PARCPAG + nSomaMeses + 1 <= SRK->RK_PARCELA
								If ( nSomaMeses == 0 .And. SRK->RK_PARCELA=1 ) .Or. ( SRK->RK_PARCELA >1 .and. ( SRK->RK_PARCPAG + 1 + nSomaMeses = SRK->RK_PARCELA ) )
									If !Empty(cCodJur)
										nValor  += (SRK->RK_VALORPA + SRK->RK_VALORAR)
										nValJur += SRK->RK_PCJUROS
									Else
										nValor += SRK->RK_VALORPA + SRK->RK_VALORAR + SRK->RK_PCJUROS
									EndIf
								Else
									If !Empty(cCodJur)
										nValor  += SRK->RK_VALORPA
										nValJur += SRK->RK_PCJUROS
									Else
										nValor += SRK->RK_VALORPA + SRK->RK_PCJUROS
									EndIf
								EndIf
							EndIf
						Else
							If SRK->RK_PARCELA == 1 .Or. ( SRK->RK_PARCELA > 1 .and. ( SRK->RK_PARCPAG + 1 = SRK->RK_PARCELA ) )
								aAreaSRR	:= SRR->( GetArea() )
								SRR->( DbSetOrder(RetOrder("SRR","RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR+RR_SEMANA+RR_PD+RR_CC+RR_SEQ+DTOS(RR_DATA)")) ) 

								cChaveSRR := SRA->RA_FILIAL+SRA->RA_MAT+SomaMesAno( cPeriodo )+fGetCalcRot('3')+cSemana+SRK->RK_PD
								
								If !Empty(cCodJur)
									nValor  += (SRK->RK_VALORPA + SRK->RK_VALORAR)
									nValJur += SRK->RK_PCJUROS
								Else
									nValor += (SRK->RK_VALORPA + SRK->RK_VALORAR + SRK->RK_PCJUROS)
								EndIf
								
								//Verifica se existe férias pagas no período posterior
								If SRR->( dbSeek( cChaveSRR ) )								
									While SRR->(!Eof() .and. RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR+RR_SEMANA+RR_PD == cChaveSRR )
										//Se já foi pago nas férias posterior, subtrai o valor pois não deve gerar novamente.
										If SRR->RR_NUMID == SRK->RK_NUMID
											If !Empty(cCodJur)
												nValor  -= (SRK->RK_VALORPA + SRK->RK_VALORAR)
												nValJur -= SRK->RK_PCJUROS
											Else
												nValor -= (SRK->RK_VALORPA + SRK->RK_VALORAR + SRK->RK_PCJUROS)
											EndIf
											Exit
										EndIf
										SRR->(DbSkip())
									EndDo
								EndIf

								RestArea( aAreaSRR )
								DbSelectArea("SRK")
							Else
								If !Empty(cCodJur)
									nValor  += SRK->RK_VALORPA
									nValJur += SRK->RK_PCJUROS
								Else
									nValor +=  SRK->RK_VALORPA + SRK->RK_PCJUROS
								EndIf
							EndIf							
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		cDtMov 	:= MESANO(SRK->RK_DTMOVI)
		cDtMov	:=	Substr(cDtMov,5,2)+Substr(cDtMov,1,4)
		
		If REP->( dbSeek(SRK->RK_FILIAL+SRK->RK_MAT+cDtMov))
			aadd( aSentenca,{SRK->RK_PD})
		EndIf

		dbSkip()
	Enddo
	
	//Se for contrato intermitente descontar só na última convocação                                                                                                          
	If 	SRA->RA_TPCONTR == '3' .And. cTipoRot <> '3' 
		aConvocacao := RetConvoc()
		If !(aConvocacao[6])
			nValor := 0
		EndIf
	EndIf

	// Se funcionário reintegrado no mês, desconsidera lançamentos que foram pagos na rescisão
	If nValor > 0
		If cTipoRot == "1" .And. !Empty(SRA->RA_FECREI) .and. MesAno(SRA->RA_FECREI) == MesAno(dDataRef)
			If Ascan( aPd, {|x| x[1] == cCodigo .And. x[5] == nValor .And. x[9] <> "D" .And. x[7] == "G" .And. x[10] < SRA->RA_FECREI} )  > 0
				nValor := 0
			EndIf
		EndIf
	EndIf	

	If nValor > 0 .Or. ( lDissidio .And. !Empty( aArray ) .And. aScan( aArray, { |x| x == MesAno( dDataAte ) } ) > 0 ) .Or. lImpPonto
		If cTipo == "R" .And. lProxMes .And. lTemRefQua .And. RetValSRV(cCodigo, SRA->RA_FILIAL, "RV_REFQUAR") == "1" .And. ( nPosPd := aScan( aPd, { |x| x[1]+x[2]+x[13]+x[14] == cCodigo+cCC+cItem+cClVl .And. x[9] != "D" } ) ) > 0
            aPd[nPosPd, 5] += nValor
        Else
            aAux	:= {}
            fNotLancPD( cCodigo , , .F. , @nQtdeLc )		//-- QTDE LCTO  PERMITIDO SRV 
            // VERIFICAR SE A QTD DE LACTOS PERMITIDOS 
            For nCnt := 1 to nQtdeLc
                aAdd(aAux,nCnt)
            next nCnt
            
            // VERIFICAR AS SEQUENCIAS NAO UTILIZAS
            For nCnt := 1 To Len( aPd )
                nPos	:= 0
                If aPd[nCnt,1] = cCodigo .And. aPd[nCnt,3] = cSemana .And. aPd[nCnt,2] == cCC .And. ;
                    (Len(aPd[nCnt]) < 13 .Or. aPd[nCnt,13] == cItem) .And.;
                    (Len(aPd[nCnt]) < 14 .Or. aPd[nCnt,14] == cClVl) .and. (!lLctoDia .or. aPd[nCnt,18] == dDtaRef)
                    If Empty(aPd[nCnt,09])    //SE LANCAMENTO NAO FOR DELETADO
                        nPos	:= Ascan(aAux,{|X| X == val(aPd[nCnt,11])})   //PEGAR A PROPRIA SEQUENCIA
                        nx++
                    EndIf
                    If nPos > 0
                        aDel(aAux,nPos)
                        aSize(aAux,len(aAux)-1)
                    EndIf
                EndIf                                   
            Next nCnt      

            // VERIFICAR SE A SEQUENCIA ESTA EM BRANCO
            For nCnt := 1 To Len( aPd )
                If aPd[nCnt,1] = cCodigo .And. aPd[nCnt,3] = cSemana .And. aPd[nCnt,2] == cCC .And. ;
                    (Len(aPd[nCnt]) < 13 .Or. aPd[nCnt,13] == cItem) .And.;
                    (Len(aPd[nCnt]) < 14 .Or. aPd[nCnt,14] == cClVl) .and. (!lLctoDia .or. aPd[nCnt,18] == dDtaRef)
                    If Empty(aPd[nCnt,11]) .and. Empty(aPd[nCnt,9]) .and. nQtdeLc > 1    //SE SEQUENCIA FOR EM BRANCO
                        aAdd(aPd,aClone(aPd[nCnt]))
                        aPd[nCnt,9]			:= "D"
                        aPd[len(aPd),11]	:= strzero(aAux[1],1)
                        aDel(aAux,1)
                        aSize(aAux,len(aAux)-1)
                    EndIf
                EndIf                                   
            Next nCnt
            
            If Empty(aAux) //Se todas as sequencias foram utilizadas e utliza lançamento diário, aumenta um dia na data de referência
                dDtaRef++
                nX := 0
                For nCnt := 1 to nQtdeLc
                    aAdd(aAux,nCnt)
                Next nCnt
            EndIf
            
            // QTD DE LANC. PERMITIDA
            If nX < nQtdeLc
                If lDissidio
                    FMatriz(aPd[nPosRK,1],aPd[nPosRK,5],aPd[nPosRK,4],aPd[nPosRK,3],aPd[nPosRK,2],"V","G",,,,.T.,If(nQtdeLc = 1,Space(1),Strzero(aAux[1],1)),,cItem,cClVl,aPd[nPosRK,15],,cIdCmpl,If(lLctoDia,dDtaRef,)) // QTD DE LANC.PERMITIDOS = 1, ENTAO SEQUENCIA EM BRANCO
                ElseIf lImpPonto
                    FMatriz(cCodigo,0,nHoras,cSemana,cCC,cTipoV,"E",,,,.T.,If(nQtdeLc = 1,Space(1),Strzero(aAux[1],1)),,cItem,cClVl, cNumId, lEmprest,cIdCmpl,If(lLctoDia,dDtaRef,)) // QTD DE LANC.PERMITIDOS = 1, ENTAO SEQUENCIA EM BRANCO
                Else	
                    FMatriz(cCodigo,nValor,0,cSemana,cCC,"V","G",,,,.T.,If(nQtdeLc = 1,Space(1),Strzero(aAux[1],1)),,cItem,cClVl, cNumId, lEmprest,cIdCmpl,If(lLctoDia,dDtaRef,)) // QTD DE LANC.PERMITIDOS = 1, ENTAO SEQUENCIA EM BRANCO
                    If !Empty(cCodJur) .and. !Empty(nValJur)
                        fMatriz(cCodJur,nValJur,nJuros,cSemana,cCC,"V","G",,,,.T.,If(nQtdeLc = 1,Space(1),Strzero(aAux[1],1)),,cItem,cClVl, cNumId, lEmprest,cIdCmpl,If(lLctoDia,dDtaRef,)) // QTD DE LANC.PERMITIDOS = 1, ENTAO SEQUENCIA EM BRANCO					
                    EndIf
                EndIf
                
                aDel(aAux,1)
                aSize(aAux,len(aAux)-1)
            EndIf	               	                                                            
        EndIf
	EndIf
Enddo

If lChkEConsig .and. lChkRUO //Busca consignado no histórico RUO
	cCompet := SubStr(cPeriodo,5,2)+SubStr(cPeriodo,1,4)
	RUO->(DbSetOrder(3))
	cItem := If(lItemClVl, SRA->RA_ITEM, "")
	cClVl := If(lItemClVl, SRA->RA_CLVL, "")
	If RUO->(DbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cCompet))
		While RUO->(!Eof() .and. RUO_FILIAL + RUO_MAT + RUO_COMPET == SRA->RA_FILIAL + SRA->RA_MAT + cCompet)
			fMatriz(RUO->RUO_PD,RUO->RUO_VLPARC,,cSemana,SRA->RA_CC,"V","G",,,,.T.,,,cItem,cClVl, RUO->RUO_NUMID, .F.)
			RUO->(dbSkip())
		EndDo
	EndIf
EndIf

SRK->(DbSetOrder(1))
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fVerVbBene³ Autor ³ Emerson Rosa de Souza ³ Data ³ 07.03.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Deletar ou limpar delecao para calculo do I.R. 			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aCodBenef - Array contendo os codigos de benef calculados  ³±±
±±³          ³ nProceder - Indica se devera deletar ou limpar delecao	  ³±±
±±³          ³ nNroCod   - Numero de codigos de benef ja calculados	      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fVerVbBenef(aCodBenef,nProceder,nNroCod)
Local nCnt4,nPosCod

If nNroCod > 1
	For nCnt4 := 1 To nNroCod-1
		If nProceder == 1 // Deletar verba para nao entrar no calculo do I.R.
			nPosCod := Ascan(aPd, { |X| X[1] $ aCodBenef[nCnt4,1]+"/"+aCodBenef[nCnt4,8] .AND. X[9] # "D" } )
			If nPosCod > 0
				aPd[nPosCod,9] := "D"
			EndIf
		Else 		      // Limpar delecao
			nPosCod := Ascan(aPd, { |X| X[1] $ aCodBenef[nCnt4,1]+"/"+aCodBenef[nCnt4,8] .AND. X[9] = "D" } )
			If nPosCod > 0
				aPd[nPosCod,9] := ""
			EndIf
		EndIf
	Next nCnt4
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ fCAssist ºAutor  ³ Adilson Silva      º Data ³ 24/05/2007  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Calculo da Contribuicao Assistencial.                      º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MP8                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fCAssist(aCodfol,cVerba)

Local cVerbas_Aux	:= ""
Local cCodVbs		:= ""
Local cFil			:= xFilial("SRV")
Local cRotCalc		:= GetRotExec()
Local aMeses 		:= { "JAN","FEV","MAR","ABR","MAI","JUN","JUL","AGO","SET","OUT","NOV","DEZ" }
Local aCodVbs		:= {}
Local nRef   		:= 0
Local nValor 		:= 0
Local nVb			:= 0
Local nX			:= 0
Local nPosVbApd		:= 0
Local nDAfast		:= If( Type("NDIASAFAS") # "U", NDIASAFAS, 0 ) 	//"Dias afastados"
Local nDAfaACS 		:= If( Type("P_NDAFAACS") # "U", P_NDAFAACS, 0 ) 	//"Dias afastado p/ Mensal.Sindical e Contr. Assist. e Confed."
Local nMes, cMes, cCampo
Local nMinimo, nMaximo
Local nBasCalc
Local lSaldoSal		:= .T.
Local lCompl13      := .F.
Local cRotRes		:= fGetCalcRot('4')
Local cRot132		:= fGetCalcRot('6')
Local cRotPlr		:= fGetCalcRot('F')
Local cRotFol      	:= fGetCalcRot('1')

P_PROPCONT := If( Type("P_PROPCONT") # "U", P_PROPCONT, .F. )

If cTipoRot == "4" .And. P_PROPCONT
	nDiasMat := 0
EndIf
// Efetua o cálculo se a quantidade de dias trabalhados for maior que 0 Ou P_PROPCONT = .F.
If !P_PROPCONT .Or. (cTipoRot == "6") .Or. (P_PROPCONT .And. DiasTrab > 0 )

	If cVerba # Space( 03 ) 
		If ( Ascan(aPd,{|X| X[1] == cVerba .And. X[9] <> "D" .And. X[7] $ "I*G"}) ) == 0
			If fPosReg("RCE",1,xFilial("RCE")+SRA->RA_SINDICA)

				If P_PROPCONT .And. RCE->(ColumnPos("RCE_DESAFA")) > 0 .And. !AllTrim(RCE->RCE_DESAFA) $ "1/2"
					If !"A" $ AllTrim(RCE->RCE_DESAFA) .And. ( Upper(SRA->RA_SITFOLH) == "A" .And. nDAfast >= nDAfaACS )
						Return()
					EndIf
				EndIf

				nMes   := If(cTipoRot == "4" .and. cCompl == "S", Month(dDataDem), Val(Right( cAnoMes,2 )))
				cMes   := aMeses[ nMes ]
				cCampo := "RCE->RCE_ASS" + cMes
			
				If ( nRef := &cCampo ) > 0
					nMinimo  := RCE->RCE_ASSMIN
					nMaximo  := If( RCE->RCE_ASSMAX == 0,9999999.99,RCE->RCE_ASSMAX )
					nBasCalc := 0
		
					If RCE->RCE_ASSSAL == "1"	  		// Salario Base
						// SE JORNADA VARIAVEL, BUSCA O VALOR DO SALÁRIO DAS VERBAS DO GRUPO 0
						If SRA->RA_CATFUNC = "H" .And. SRA->(ColumnPos( "RA_HOJORVA")) > 0 .And. SRA->RA_HOJORVA = "1"
							//Busca as verbas que estão no grupo 0, campo RV_GRPVERB = 0
							GP140GrpVerb(cFil,@cVerbas_Aux,"0",.T.)
							For nVb := 1 To Len(cVerbas_Aux) Step 3
								If lSaldoSal .And. aCodFol[0032,1] $ SubStr(cVerbas_Aux,nVb,3)
									lSaldoSal := .F.
									If (nPosVbApd := Ascan(aPd, { |X| X[1] = aCodFol[0048,1] .And. X[9] # "D"})) > 0
										nBasCalc += aPd[nPosVbApd,5]
									Endif
								Endif
								If (nPosVbApd := Ascan(aPd, { |X| X[1] = SubStr(cVerbas_Aux,nVb,3) .And. X[9] # "D"})) > 0
									//Verifica o tipo da verba para saber se ela será somada ou subtraída da base de cálculo.
									If RetValSRV(aPd[nPosVbApd,1],SRA->RA_FILIAL,"RV_TIPOCOD") == "2"
										nBasCalc -= aPd[nPosVbApd,5]
									Else
										nBasCalc += aPd[nPosVbApd,5]
									Endif
								EndIf
							Next nVb
						Else
							nBasCalc := SALARIO
						EndIf
					ElseIf RCE->RCE_ASSSAL == "2"		// Salario Composto
						nBasCalc := SALMES
					ElseIf RCE->RCE_ASSSAL == "3"		// Piso da Categoria
						nBasCalc := RCE->RCE_PISO
					ElseIf RCE->RCE_ASSSAL == "4"		// Salario Minimo
						nBasCalc := Val_SalMin
					EndIf

					//Quando executadas pelos roteiros PLR/132
					lCompl13 := If(cRotCalc == cRotFol .And. cTipoRot == "6", .T., .F.)
					If cRotCalc $ cRotRes + "/" + cRot132 + "/" + cRotPlr .Or. lCompl13
						If cRotCalc == cRot132 .Or. lCompl13
							cCodVbs := If( Type("P_VCASS132") # "U", Alltrim(P_VCASS132), "" ) //Verbas para o calculo do 132
						ElseIf cRotCalc $ cRotPlr + "/" + cRotRes
							cCodVbs := If( Type("P_VCASSPLR") # "U", Alltrim(P_VCASSPLR), "" ) //Verbas para o calculo da PLR
						EndIf					
						If !Empty( cCodVbs )
							If !lCompl13
								nBasCalc := 0  
							EndIf
							aCodVbs := StrTokArr( cCodVbs, "," )
							For nX := 1 To Len(aCodVbs)
								If( ValType(aCodVbs[nX]) == "C" )
									aEval( aPd, { |X| If( X[1] == aCodVbs[nX], nBasCalc += X[5], 0 ) } )
								EndIf
							Next nX
						EndIf
					EndIf
		
					// Calcula a Contribuicao Assistencial
					If nBasCalc > 0
						If RCE->RCE_ASSREF == "1"			// Valor Fixo
							// Valor da Contribuicao
							If nRef > nMaximo .Or. nRef < nMinimo
								nValor := 0
							Else						
								nValor := nRef
							EndIf
							nRef   := 0
						ElseIf RCE->RCE_ASSREF == "2"		// Percentual
							// Calcula Valor da Contribuicao
							nValor := Round( nBasCalc * (nRef / 100),2 )
							// Verifica Desconto Minimo
							nValor := Max(nValor,nMinimo)
							// Verifica Desconto Maximo
							nValor := Min(nValor,nMaximo)
						EndIf
		
						// Geracao do Valor na Folha
						If nValor > 0
							If cPaisLoc == "BRA" 								
								fGeraVerba( cVerba, nValor, nRef, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif( cTipoRot != "6", P_PROPCONT, Nil) )
							Else
								fGeraVerba(cVerba,nValor,nRef,,,,,,,,.T.,,,,,P_PROPCONT)
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	Else
		CMSGLOG := FMSGFORM({19}) + " -> 0069 - " + aCodFol[69,2] //"Nao existe verba cadastrada para identificador de calculo "
		S_MSGLOG()
		FINALCALC()
		Return()
	EndIf

EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ fCConfed ºAutor  ³ Adilson Silva      º Data ³ 24/05/2007  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Calculo da Contribuicao Confederativa.                     º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MP8                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fCConfed(aCodfol,cVerba)

Local cVerbas_Aux	:= ""
Local cFil			:= xFilial("SRV")
Local aMeses 		:= { "JAN","FEV","MAR","ABR","MAI","JUN","JUL","AGO","SET","OUT","NOV","DEZ" }
Local nPos166		:= 0
Local nRef   		:= 0
Local nValor 		:= 0
Local nVb			:= 0
Local nPosVbApd		:= 0
Local nDAfast		:= If( Type("NDIASAFAS") # "U", NDIASAFAS, 0 ) 	//"Dias afastados"
Local nDAfaACS 		:= P_NDAFAACS								 	//"Dias afastado p/ Mensal.Sindical e Contr. Assist. e Confed."
Local nMes, cMes, cCampo
Local nMinimo, nMaximo
Local nBasCalc
Local lSaldoSal		:= .T.

Static lDesAfa
Static lHorJova

DEFAULT lDesAfa  := RCE->(ColumnPos("RCE_DESAFA")) > 0
DEFAULT lHorJova := SRA->(ColumnPos( "RA_HOJORVA")) > 0

// Efetua o cálculo se a quantidade de dias trabalhados for maior que 0 Ou P_PROPCONT = .F.
If !P_PROPCONT .Or. (P_PROPCONT .And. DiasTrab > 0 )

	If cVerba # Space( 03 )
		If fPosReg("RCE",1,xFilial("RCE")+SRA->RA_SINDICA)
	
			If P_PROPCONT .And. lDesAfa .And. !AllTrim(RCE->RCE_DESAFA) $ "1/2" 
				If !"C" $ AllTrim(RCE->RCE_DESAFA) .And. ( Upper(SRA->RA_SITFOLH) == "A" .And. nDAfast >= nDAfaACS )
					Return (Nil)
				EndIf
			EndIf
	
			nMes   := If(cTipoRot == "4" .and. cCompl == "S", Month(dDataDem), Val(Right( cAnoMes,2 )))
			cMes   := aMeses[ nMes ]
			cCampo := "RCE->RCE_CON" + cMes
	      
			If ( nRef := &cCampo ) > 0
				nMinimo  := RCE->RCE_CONMIN
				nMaximo  := If( RCE->RCE_CONMAX == 0,9999999.99,RCE->RCE_CONMAX )
				nBasCalc := 0
	
				If RCE->RCE_CONSAL == "1"	  		// Salario Base
					// SE JORNADA VARIAVEL, BUSCA O VALOR DO SALÁRIO DAS VERBAS DO GRUPO 0
					If SRA->RA_CATFUNC = "H" .And. lHorJova .And. SRA->RA_HOJORVA = "1"
						//Busca as verbas que estão no grupo 0, campo RV_GRPVERB = 0
						GP140GrpVerb(cFil,@cVerbas_Aux,"0",.T.)
						For nVb := 1 To Len(cVerbas_Aux) Step 3
							If lSaldoSal .And. aCodFol[0032,1] $ SubStr(cVerbas_Aux,nVb,3)
								lSaldoSal := .F.
								If (nPosVbApd := Ascan(aPd, { |X| X[1] = aCodFol[0048,1] .And. X[9] # "D"})) > 0
									nBasCalc += aPd[nPosVbApd,5]
								Endif
							Endif						
							If (nPosVbApd := Ascan(aPd, { |X| X[1] = SubStr(cVerbas_Aux,nVb,3) .And. X[9] # "D"})) > 0
								//Verifica o tipo da verba para saber se ela será somada ou subtraída da base de cálculo.
								If RetValSRV(aPd[nPosVbApd,1],SRA->RA_FILIAL,"RV_TIPOCOD") == "2"
									nBasCalc -= aPd[nPosVbApd,5]
								Else
									nBasCalc += aPd[nPosVbApd,5]
								EndIf
							EndIf
						Next nVb
					Else
						nBasCalc := SALARIO
					EndIf
				ElseIf RCE->RCE_CONSAL == "2"		// Salario Composto
					nBasCalc := SALMES
					If ( nPos166 := aScan( aPd, { |x| x[1] = aCodfol[166,1] .And. AllTrim( x[3] ) == AllTrim( cSemana ) .And. X[9] != "D"} ) ) > 0 .And. RetValSRV( aPd[nPos166, 1], SRA->RA_FILIAL,"RV_INCORP") == "S"
						nBasCalc += aPd[nPos166, 5]  
					EndIf
				ElseIf RCE->RCE_CONSAL == "3"		// Piso da Categoria
					nBasCalc := RCE->RCE_PISO
				ElseIf RCE->RCE_CONSAL == "4"		// Salario Minimo
					nBasCalc := Val_SalMin
				EndIf
	
				// Calcula a Contribuicao Confederativa
				If nBasCalc > 0
					If RCE->RCE_CONREF == "1"			// Valor Fixo
						// Valor da Contribuicao
						If nRef > nMaximo .Or. nRef < nMinimo
							nValor := 0
						Else						
							nValor := nRef
						EndIf
						nRef   := 0
					ElseIf RCE->RCE_CONREF == "2"		// Percentual
						// Calcula Valor da Contribuicao
						nValor := Round( nBasCalc * (nRef / 100),2 )
						// Verifica Desconto Minimo
						nValor := Max(nValor,nMinimo)
						// Verifica Desconto Maximo
						nValor := Min(nValor,nMaximo)
					EndIf
	
					// Geracao do Valor na Folha
					If nValor > 0 
						If cPaisLoc == "BRA" 
							If ! (( Ascan(aPd,{|X| X[1] == cVerba .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
								fGeraVerba(cVerba,nValor,nRef,,,,,,,,,,,,,P_PROPCONT)
							EndIf	
						Else
							fGeraVerba(cVerba,nValor,nRef,,,,,,,,.T.,,,,,P_PROPCONT)
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	Else
		CMSGLOG := FMSGFORM({19}) + " -> 0175 - " + aCodFol[175,2] //"Nao existe verba cadastrada para identificador de calculo "
		S_MSGLOG()
		FINALCALC()
		Return()
	EndIf
	
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fCMenSind ºAutor  ³ Adilson Silva      º Data ³ 01/11/2009  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Calculo da Contribuicao Confederativa.                     º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MP8                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fCMenSind(aCodfol,cVerba)

Local cVerbas_Aux	:= ""
Local cFil			:= xFilial("SRV")
Local nRef   		:= 0
Local nValor 		:= 0
Local nVb			:= 0
Local nPosVbApd		:= 0
Local nDAfast		:= If( Type("NDIASAFAS") # "U", NDIASAFAS, 0 ) 	//"Dias afastados"
Local nDAfaACS 		:= If( Type("P_NDAFAACS") # "U", P_NDAFAACS, 0 ) 	//"Dias afastado p/ Mensal.Sindical e Contr. Assist. e Confed."
Local nMinimo, nMaximo
Local nBasCalc
Local lSaldoSal		:= .T.

//Não calcula para demitidos pois já foi calculado na rescisão.
If cTipoRot == "1" .and. !Empty(SRA->RA_DEMISSA)
	Return Nil
EndIf

//Não calcula para demitidospois já foi calculado na rescisão.
If cTipoRot == "1" .and. !Empty(SRA->RA_DEMISSA)
	Return Nil
EndIf

P_PROPCONT := If( Type("P_PROPCONT") # "U", P_PROPCONT, .F. )

// Efetua o cálculo se a quantidade de dias trabalhados for maior que 0 Ou P_PROPCONT = .F.
If !P_PROPCONT .Or. (P_PROPCONT .And. DiasTrab > 0 )

	If cVerba # Space( 03 )
		If fPosReg("RCE",1,xFilial("RCE",SRA->RA_FILIAL)+SRA->RA_SINDICA)
			
			//Retirar FIELDPOS após a liberação do release 12.1.14
			If P_PROPCONT .And. RCE->(ColumnPos("RCE_DESAFA")) > 0 .And. AllTrim(RCE->RCE_DESAFA) # "1"
				If !"S" $ AllTrim(RCE->RCE_DESAFA) .And. ( Upper(SRA->RA_SITFOLH) == "A" .And. nDAfast >= nDAfaACS )
					Return (Nil)
				EndIf
			EndIf
			
			If ( nRef := RCE->RCE_MENSIN ) > 0
				nMinimo  := RCE->RCE_MENMIN
				nMaximo  := If( RCE->RCE_MENMAX == 0,9999999.99,RCE->RCE_MENMAX )
				nBasCalc := 0
	
				If RCE->RCE_MENSAL == "1"	  		// Salario Base
					// SE JORNADA VARIAVEL, BUSCA O VALOR DO SALÁRIO DAS VERBAS DO GRUPO 0
					If SRA->RA_CATFUNC = "H" .And. SRA->(ColumnPos( "RA_HOJORVA")) > 0 .And. SRA->RA_HOJORVA = "1"
						//Busca as verbas que estão no grupo 0, campo RV_GRPVERB = 0
						GP140GrpVerb(cFil,@cVerbas_Aux,"0",.T.)
						For nVb := 1 To Len(cVerbas_Aux) Step 3
							If lSaldoSal .And. aCodFol[0032,1] $ SubStr(cVerbas_Aux,nVb,3)
								lSaldoSal := .F.
								If (nPosVbApd := Ascan(aPd, { |X| X[1] = aCodFol[0048,1] .And. X[9] # "D"})) > 0
									nBasCalc += aPd[nPosVbApd,5]
								Endif
							Endif
							If (nPosVbApd := Ascan(aPd, { |X| X[1] = SubStr(cVerbas_Aux,nVb,3) .And. X[9] # "D"})) > 0
								//Verifica o tipo da verba para saber se ela será somada ou subtraída da base de cálculo.
								If RetValSRV(aPd[nPosVbApd,1],SRA->RA_FILIAL,"RV_TIPOCOD") == "2"
									nBasCalc -= aPd[nPosVbApd,5]
								Else
									nBasCalc += aPd[nPosVbApd,5]
								Endif
							EndIf
						Next nVb
					Else
						nBasCalc := SALARIO
					EndIf
				ElseIf RCE->RCE_MENSAL == "2"		// Salario Composto
					nBasCalc := SALMES
				ElseIf RCE->RCE_MENSAL == "3"		// Piso da Categoria
					nBasCalc := RCE->RCE_PISO
				ElseIf RCE->RCE_MENSAL == "4"		// Salario Minimo
					nBasCalc := Val_SalMin
				EndIf
	
				// Calcula a Contribuicao Confederativa
				If nBasCalc > 0
					If RCE->RCE_MENREF == "1"			// Valor Fixo
						// Valor da Contribuicao
						If nRef > nMaximo .Or. nRef < nMinimo
							nValor := 0
						Else
							nValor := nRef
						EndIf
						nRef   := 0
					ElseIf RCE->RCE_MENREF == "2"		// Percentual
						// Calcula Valor da Contribuicao
						nValor := Round( nBasCalc * (nRef / 100),2 )
						// Verifica Desconto Minimo
						nValor := Max(nValor,nMinimo)
						// Verifica Desconto Maximo
						nValor := Min(nValor,nMaximo)
					EndIf
	
					// Geracao do Valor na Folha
					If nValor > 0 
						If cPaisLoc == "BRA" 
							If ! (( Ascan(aPd,{|X| X[1] == cVerba .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
								fGeraVerba(cVerba,nValor,nRef,,,,,,,,,,,,,P_PROPCONT)
							EndIf	
						Else
							fGeraVerba(cVerba,nValor,nRef,,,,,,,,.T.,,,,,P_PROPCONT)
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	Else
		CMSGLOG := FMSGFORM({19}) + " -> 0720 - " + aCodFol[720,2] //"Nao existe verba cadastrada para identificador de calculo "
		S_MSGLOG()
		FINALCALC()
		Return()
	EndIf

EndIf

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Sindical ³ Autor ³ Mauro                 ³ Data ³ 23.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo da Contribuicao Sindical                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aCodfol    =  Matriz de Ref. da  Verba                     ³±±
±±³          ³ nContri    =  Valor da Contribuicao Passar como Ref.       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Sindical(aCodfol,nContri,cGrava,lSalBase,nBaseSind,cCodPd)

Local Contri_b		:= 0.00
Local cVerbas_Aux	:= ""
Local cFil 			:= xFilial("SRV")
Local cAnoContr		:= Left( cPeriodo, 4 )
Local cSind			:= SRA->RA_SINDICA
Local cCcFun		:= SRA->RA_CC
Local nVb			:= 0
Local nPosVbApd		:= 0
Local dDtIniA
Local dDtFimA
Local cTipAfA
Local lDescSin
Local lRescCS
Local lDCSAfa		// Desconta contribuicao afastado.
Local lHoJorV		:= .F. //Se funcionário é horista com jornada variável
Local lFuncRur		:= Left( SRA->RA_TIPOADM, 1 ) == "2" // Funcionário produtor rural
Local nPosFRur		:= 0
Local cSrcAlias		:= "SRC"
Local aArea			:= GetArea()
Local aPerAtu		:= {}
Local cRotFun		:= If(SRA->RA_CATFUNC $ 'A|P',fGetCalcRot('9'),fGetCalcRot('1'))
Local lSaldoSal		:= .T.

Static cFilSind
Static nDTrSind
Static aTabS127

//--Situacao do Funcionario na data de referencia
cSitFolh	:= If( type("cSitFolh")=="U",SRA->RA_SITFOLH,cSitFolh)

//-- Verifica se trata de dissidio
lDissidio  := If(lDissidio == Nil,.F.,lDissidio)
 
If cFilSind == Nil .Or. SRA->RA_FILIAL # cFilSind
	cFilSind  := SRA->RA_FILIAL
	nDTrSind  := GetNewPar("MV_DTRSIND",2)
	
	If lFuncRur
		aTabS127 := {}
		fRetTab( @aTabS127, "S127", , , , , .T., , .T. )
	EndIf
EndIf

lSalBase := RetValSRV(cCodPd,SRA->RA_FILIAL,"RV_BASCAL ") == "1" //Salario Base ou Proporcional

If Type( "lRescMSeg" ) # "U" 
     lRescCS  :=  lRescMSeg 
Else
     lRescCS := .F.
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Para semanalistas, deve calcular somente na ultima semana ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (SRA->RA_TIPOPGT = "S" .And. ! lUltSemana) .OR. Empty(aCodfol[68,1])
	Return
EndIf

// Busca informações para calculo da contribuicao na tabela S127
If lFuncRur
	
	nBaseSind := 0
	
	If !(;	
			( nPosFRur := aScan( aTabS127, { |x| x[5] == cAnoContr .And. x[2] == cFilSind .And. x[8] == cSind .And. AllTrim( x[9] ) == AllTrim( cCcFun ) } ) ) > 0;
			.Or.;
			( nPosFRur := aScan( aTabS127, { |x| x[5] == cAnoContr .And. Empty( x[2] ) .And. x[8] == cSind .And. AllTrim( x[9] ) == AllTrim( cCcFun ) } ) ) > 0;
			.Or.;
			( nPosFRur := aScan( aTabS127, { |x| x[5] == cAnoContr .And. Empty( x[2] ) .And. Empty( x[8] ) .And. AllTrim( x[9] ) == AllTrim( cCcFun ) } ) ) > 0;
			.Or.;
			( nPosFRur := aScan( aTabS127, { |x| x[5] == cAnoContr .And. Empty( x[2] ) .And. x[8] == cSind .And. Empty( x[9] ) } ) ) > 0;
			.Or.;
			( nPosFRur := aScan( aTabS127, { |x| x[5] == cAnoContr .And. x[2] == cFilSind .And. Empty( x[8] ) .And. AllTrim( x[9] ) == AllTrim( cCcFun ) } ) ) > 0;
			.Or.;
			( nPosFRur := aScan( aTabS127, { |x| x[5] == cAnoContr .And. x[2] == cFilSind .And. x[8] == cSind .And. Empty( x[9] ) } ) ) > 0;
			.Or.;
			( nPosFRur := aScan( aTabS127, { |x| x[5] == cAnoContr .And. x[2] == cFilSind .And. Empty( x[8] ) .And. Empty( x[9] ) } ) ) > 0;
			.Or.;
			( nPosFRur := aScan( aTabS127, { |x| x[5] == cAnoContr .And. Empty( x[2] ) .And. Empty( x[8] ) .And. Empty( x[9] ) } ) ) > 0;
		)
		
		Return
	EndIf
EndIf

If ( cTipoRot == "4" )
	If fGetPerAtual( @aPerAtu, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, cRotFun )
		If Mesano(dDataAte) > aPerAtu[1][1]
			DbSelectArea(cSrcAlias)
			DbsetOrder(1)
			If ( cSrcAlias )->(dbSeek(SRA->RA_FILIAL + SRA->RA_MAT + aCodfol[68,1] ))
				RestArea(aArea)
				Return
			EndIf
			RestArea(aArea)
		EndIf
	EndIf 
EndIf


If ( cTipoRot <> "1") .OR. lDissidio .OR. ( cTipoRot == "1" .AND. EMPTY(SRA->RA_DEMISSA) )  .OR. ;
	( ( cTipoRot == "1" )  .AND.  !lDissidio .AND. !EMPTY(SRA->RA_DEMISSA) .AND. ANOMES(SRA->RA_DEMISSA) >=ANOMES(dDataAte) ) 
  	If  (MONTH(dDataAte) >= 3 .And. SRA->RA_PGCTSIN <> "N") .Or. SRA->RA_PGCTSIN $ "D*T"
  		If (If( lDissidio .Or. (cTipoRot == "4" .And. cCompl == "S"), If( lDissidio,.T., aScan( aPdResc, { |x| x[1] == aCodfol[68,1] } ) > 0), SRA->RA_PGCTSIN == "S") .And. (Mesano(SRA->RA_ADMISSA)=Mesano(dDataAte) .Or. Month(dDataAte) >= 3) .And. !lRescCS);
			.Or. ( SRA->RA_PGCTSIN $ "D*T" .And. ( ( MesAno(dDataAte) > MesAno(SRA->RA_ADMISSA) .And. !lRescCS ) .Or. ( lRescCS .And. DateDiffMonth( dDataDem1, SRA->RA_ADMISSA ) == 1 ) ) )

			// SE JORNADA VARIAVEL, BUSCA O VALOR DO SALÁRIO DAS VERBAS DO GRUPO 0
			If SRA->RA_CATFUNC = "H" .And. SRA->(ColumnPos( "RA_HOJORVA")) > 0 .And. SRA->RA_HOJORVA = "1"
				//Busca as verbas que estão no grupo 0, campo RV_GRPVERB = 0
				GP140GrpVerb(cFil,@cVerbas_Aux,"0",.T.)
				For nVb := 1 To Len(cVerbas_Aux) Step 3
					If lSaldoSal .And. aCodFol[0032,1] $ SubStr(cVerbas_Aux,nVb,3)
						lSaldoSal := .F.
						If (nPosVbApd := Ascan(aPd, { |X| X[1] = aCodFol[0048,1] .And. X[9] # "D"})) > 0
							Contri_b += aPd[nPosVbApd,5]
						Endif
					Endif
					If (nPosVbApd := Ascan(aPd, { |X| X[1] = SubStr(cVerbas_Aux,nVb,3) .And. X[9] # "D"})) > 0
						//Se a verba já compor a base de cálculo não será considerada.
						If RetValSRV(aPd[nPosVbApd,1],SRA->RA_FILIAL,"RV_SINDICA") <> "S"
							//Verifica o tipo da verba para saber se ela será somada ou subtraída da base de cálculo.
							If RetValSRV(aPd[nPosVbApd,1],SRA->RA_FILIAL,"RV_TIPOCOD") == "2"
								Contri_b -= aPd[nPosVbApd,5]
							Else
								Contri_b += aPd[nPosVbApd,5]
							Endif
						Endif
					EndIf
				Next nVb
				nValHorj := Contri_b
				lHoJorV := .T.
			EndIf

			If nBaseSind = Nil .Or. nBaseSind <= 0
				
				If lFuncRur
					Contri_b := VAL_SALMIN * aTabS127[ nPosFRur, 6 ] / aTabS127[ nPosFRur, 7 ]
				Else	
					Aeval( aPd ,{ |X|  SomaInc(X,20,@Contri_b, , , ,,,,aCodFol) })
				
					If SRA->RA_CATFUNC $ "I*J"
						If cTipoRot <> "4"
							Aeval( aPd , { |X|  If( X[1] == aCodFol[033,1], SomaInc( X, 1,	@Contri_b, , , , , , , aCodFol ), ) } )
							Aeval( aPd , { |X|  If( X[1] == aCodFol[317,1], SomaInc( X, 1,@Contri_b, , , , , , , aCodFol ), ) } )
						Else
							Contri_b += aOSlPrf[1,2] + aOSlPrf[1,3]
						EndIf
						Contri_b += aOSlPrf[1,1]
					ElseIf !lHoJorV
						Contri_b += If (lSalBase,  Salario, SalMes)
					EndIf
				EndIf
			ElseIf !lHojorV
				Contri_b := nBaseSind + Salario
			Else
				Contri_b := nBaseSind + nValHorj
			EndIf
			
			//-- Calculo da Contribuicao Sindical			
			If Contri_B > 0
				If Ascan(aPd, { |X| X[1]= aCodfol[68,1] .And. X[9] # "D"}) = 0
					If lFuncRur
						nContri := CONTRI_B / 30
					ElseIf SRA->RA_CATFUNC == "H"
						nContri := CONTRI_B / nDiasC
					Else
						nContri := CONTRI_B / P_QTDIAMES
					EndIf
					
					//Verifica se Deve descontar Sindical para afastado no mes de acordo com Art. 602 da CLT
					lDescSin := .T.
					If cSitFolh $ "A*F"
						fChkAfas(SRA->RA_FILIAL,SRA->RA_MAT,dDataAte,@dDtIniA,@dDtFimA,@cTipAfa,,,,@lDCSAfa)      
						If MesAno(dDtIniA) == MesAno(dDataAte) .And. DiasTrab < nDTrSind
							lDescSin := .F.
						//Nao deve descontar contribuicao se o funcionario trabalhou menos dias do que configurado
						//no parametro MV_DTRSIND no mes de retorno do afastamento. A contribuicao sera descontada
						//no mes seguinte
						ElseIf !Empty(dDtFimA) .And. MesAno(dDtFimA) == MesAno(dDataAte) .And. DiasTrab < nDTrSind
							lDescSin := .F.						
						Elseif MesAno(dDtIniA) # MesAno(dDataAte) .And.;
								(Empty(dDtFimA) .Or. MesAno(dDtFimA) >= MesAno(dDataAte)) .And.;
								(Substr(MesAno(dDtFimA),5,2) != "03" .Or. !lDCSAfa) .And.;
								If( cSitFolh $ "F|A" , DiasTrab < nDTrSind, .T. )
									lDescSin := .F.
						EndIf
						//se for afastamento por licença maternidade
						// e desconta contribuição p/ afastado
						If cSitFolh == "A" .And. RCM->RCM_TIPO == "006" .And. lDCSAfa 	
							lDescSin := .T.
						EndIf	
					EndIf
							
					//-- Nao gera para afastado conforme os dias Trabalhados
					If lDescSin 
						If cGrava # Nil .And. cGrava = "S"
							FMatriz(cCodPd,nContri,0)
						EndIf
    				EndIf
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CalSeguro ³ Autor ³ Equipe RH             ³ Data ³28/03/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo de Seguro de Vida Funcionario / Empresa             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CalSeguro(aCodfol,nSeguro,nSegEmp,Seguro_B,aSeguro)        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function CalSeguro(aCodFol,nSeguro,nSegEmp,Seguro_B,aSeguro)
Local nPos := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Array que contem as variaveis criadas por fVarRot()       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type("aVarRot") = "U"
	aVarRot := {}
EndIf

If Empty(aCodFol[153,1]) .or. Empty(aCodFol[154,1]) .or. Empty(aCodFol[155,1])
	If Empty(aCodFol[153,1])
		CMSGLOG := FMSGFORM({19}) + " -> 0153 - " + aCodFol[153,2] //"Nao existe verba cadastrada para identificador de calculo "
		S_MSGLOG()
	EndIf
	If Empty(aCodFol[154,1])
		CMSGLOG := FMSGFORM({19}) + " -> 0154 - " + aCodFol[154,2] //"Nao existe verba cadastrada para identificador de calculo "
		S_MSGLOG()
	EndIf
	If Empty(aCodFol[155,1])
		CMSGLOG := FMSGFORM({19}) + " -> 0155 - " + aCodFol[155,2] //"Nao existe verba cadastrada para identificador de calculo "
		S_MSGLOG()
	EndIf
	FINALCALC()
	Return()
EndIf

If Ascan(aPd, { |X| X[1] = aCodFol[153,1] .And. X[9] # "D"}) = 0
	nSeguro := nSegEmp := Seguro_B := 0.00
	// Soma Incidencia para Seguro
	Aeval( aPd ,{ |X|  SomaInc(X,22,@Seguro_B, , , , , , ,aCodFol) })

	If Seguro_B = 0.00
		If RetValSRV(aCodFol[153,1],SRA->RA_FILIAL,"RV_BASCAL") == "2"
			Seguro_B := Salmes
		Else
			Seguro_B := Salario
		EndIf			
	EndIf

	// SOMA O VALOR DA MEDIA DE COMISSAO CALCULADA PARA AFASTAMENTO POR AUXILIO MATERNIDADE
	If aCodFol[238,1] # Space(3) .And. RetValSRV(aCodFol[238,1],SRA->RA_FILIAL,"RV_SEGVIDA") == "S"
		Seguro_B += fVarRot("nMedComiss")
	EndIf

	nPos := Ascan(aSeguro , {|x| x[1] = SRA->RA_SEGUROV })
	
	If nPos > 0
		If Len(aSeguro[nPos]) >= 3 .and. Seguro_B <= aSeguro[nPos,3]
			nSeguro := (Iif(aSeguro[nPos,6] = 0, Seguro_B, aSeguro[nPos,6]) * aSeguro[nPos,4]) / 100
			nSeguro := Iif(nSeguro < aSeguro[nPos,7], aSeguro[nPos,7], nSeguro)
			nSeguro := Iif(nSeguro > aSeguro[nPos,8] .And. aSeguro[nPos,8] > 0 , aSeguro[nPos,8] , nSeguro)
			nSegEmp := (Iif(aSeguro[nPos,6] = 0, Seguro_B, aSeguro[nPos,6]) * aSeguro[nPos,5]) / 100
		Elseif Len(aSeguro[nPos]) >= 10 .and. Seguro_B <= aSeguro[nPos,10]
			nSeguro := (Iif(aSeguro[nPos,13] = 0, Seguro_B, aSeguro[nPos,13]) * aSeguro[nPos,11]) / 100
			nSeguro := Iif(nSeguro < aSeguro[nPos,14], aSeguro[nPos,14], nSeguro)
			nSeguro := Iif(nSeguro > aSeguro[nPos,15] .And. aSeguro[nPos,15] > 0, aSeguro[nPos,15], nSeguro)
			nSegEmp := (Iif(aSeguro[nPos,13] = 0, Seguro_B, aSeguro[nPos,13]) * aSeguro[nPos,12]) / 100
		Elseif Len(aSeguro[nPos]) >= 17 .and. Seguro_B <= aSeguro[nPos,17]
			nSeguro := (Iif(aSeguro[nPos,20] = 0, Seguro_B, aSeguro[nPos,20]) * aSeguro[nPos,18]) / 100
			nSeguro := Iif(nSeguro < aSeguro[nPos,21], aSeguro[nPos,21], nSeguro)
			nSeguro := Iif(nSeguro > aSeguro[nPos,22] .And. aSeguro[nPos,22] > 0, aSeguro[nPos,22], nSeguro)
			nSegEmp := (Iif(aSeguro[nPos,20] = 0, Seguro_B, aSeguro[nPos,20]) * aSeguro[nPos,19]) / 100
		Elseif Len(aSeguro[nPos]) >= 24 .and. Seguro_B <= aSeguro[nPos,24]
			nSeguro := (Iif(aSeguro[nPos,27] = 0, Seguro_B, aSeguro[nPos,27]) * aSeguro[nPos,25]) / 100
			nSeguro := Iif(nSeguro < aSeguro[nPos,28], aSeguro[nPos,28], nSeguro)
			nSeguro := Iif(nSeguro > aSeguro[nPos,29] .And. aSeguro[nPos,29] > 0, aSeguro[nPos,29], nSeguro)
			nSegEmp := (Iif(aSeguro[nPos,27] = 0, Seguro_B, aSeguro[nPos,27]) * aSeguro[nPos,26]) / 100
		ElseIf Len(aSeguro[nPos]) >= 31
			nSeguro := (Iif(aSeguro[nPos,34] = 0, Seguro_B, aSeguro[nPos,34]) * aSeguro[nPos,32]) / 100
			nSeguro := Iif(nSeguro < aSeguro[nPos,35], aSeguro[nPos,35], nSeguro)
			nSeguro := Iif(nSeguro > aSeguro[nPos,36] .And. aSeguro[nPos,36] > 0, aSeguro[nPos,36], nSeguro)
			nSegEmp := (Iif(aSeguro[nPos,34] = 0, Seguro_B, aSeguro[nPos,34]) * aSeguro[nPos,33]) / 100
		EndIf
		FMatriz(aCodFol[153,1],nSeguro)
		FMatriz(aCodFol[154,1],nSegEmp)
		FMatriz(aCodFol[155,1],Seguro_B)
	Else
		CMSGLOG := STR0039 + SRA->RA_SEGUROV + STR0040 //Tabela de Seguro de Vida ### não cadastrada
		S_MSGLOG()      
		FINALCALC()
		Return()
	EndIf
EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fSalRed  ³ Autor ³ Renata                ³ Data ³ 10.08.15 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula Salario Dia, Hora e Mes Reduzido                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ fSalRedo(Salario,Salhora,Saldia,Salmes,Tipo)               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fSalRed(nValRed, nSalRed, nHrsRed, nSalBen)
	
	Local cCod		:= Space(3)
	Local cSeq		:= " "
	Local nHNorRed	:= 0
	Local nHDesRed	:= 0
	Local nPosTab	:= 0
	Local aTmpAfas	:= {}
	Local aValAdic	:= {}
	Local nTmpTrab	:= 0
	Local nTmpAfas	:= 0
	Local nDiasAux	:= 0
	Local nCont		:= 0
	Local nContAux	:= 0
	Local nTamSeq 	:= TamSX3("RC_SEQ")[1]
	Local nI 		:= 0
	Local nSalBkp	:= SalMes
	Local nValAdi	:= 0
	Local cPdAdicio	:= ""
	Local cPdAdtS	:= ""
	Local cPdInsal	:= ""
	Local aBkpAfas	:= AClone( aDetAfas )
	Local aBkpAfasEs:= AClone( aDiaAfaEs )
	Local nBkpDFgt	:= nDiasFgts
	Local nBkpDMat	:= nDiasMat
	Local nTamSind  := TamSX3("RA_SINDICA")[1]
	Local lCalcBen	:= .F.
	Local cStatRGE	:= ""
	Local lAdtServ	:= .F.
	Local lInsalub	:= .F.
	Local nAdcAux	:= 0
	Local nPosAdt	:= 0
	Local nIndic	:= 1
	Local lAposent	:= SRA->RA_AFASFGT $ "U1*U3" .Or. SRA->RA_EAPOSEN == "1"
	
	Default nHrsRed := SRA->RA_HRSMES
	Default nSalBen := 0
	
	dIniPPE		:= If( Type("dIniPPE" ) == "U", CtoD("//")		, dIniPPE )
	dFimPPE		:= If( Type("dFimPPE" )	== "U", CtoD("//")		, dFimPPE )
	lPPEFunc	:= If( Type("lPPEFunc")	== "U", .F.				, lPPEFunc)
	dIniRGE		:= If( Type("dIniRGE" ) == "U", CtoD("//")		, dIniRGE )
	dFimRGE		:= If( Type("dFimRGE" )	== "U", CtoD("//")		, dFimRGE )
	nSalRed		:= If( Type("nSalREd" )	== "U", SRA->RA_SALARIO	, nSalRed )
	nHrsRed		:= If( Type("nHrsRed" )	== "U", SRA->RA_HRSMES	, nSalRed )
	nTetoPPE	:= If( Type("nTetoPPE")	== "U", 0				, nTetoPPE)
	nPerRed		:= If( Type("nPerRed" )	== "U", 0				, nPerRed )
	lCalcBen	:= (nSalBen > 0)
	
	If Empty(aCodFol)
		If !Fp_CodFol(@ACODFOL,SRA->RA_FILIAL)
			FinalCalc()
			Return .F.
		EndIf
	EndIf
	
	// Não calcula a redução para aposentados no adiantamento
	If cTipoRot == "2" .And. lAposent
		Return .F.
	EndIf
	
	cPdAdicio	:= aCodFol[1,1] + "|" + aCodFol[2,1] + "|" + aCodFol[3,1] + "|" + aCodFol[4,1] + "|" + aCodFol[5,1] + "|" + ;
					aCodFol[36,1] + "|" + aCodFol[37,1] + "|" + aCodFol[38,1] + "|" + aCodFol[39,1] + "|" + aCodFol[984,1] + "|" + aCodFol[988,1]
	cPdAdtS		:= aCodFol[1,1] + "|" + aCodFol[2,1] + "|" + aCodFol[3,1] + "|" + aCodFol[4,1] + "|" + aCodFol[5,1] + "|"		   
	cPdInsal	:= aCodFol[37,1] + "|" + aCodFol[38,1] + "|" + aCodFol[39,1] + "|"
	If Len (aCodFol) > 1396
		cCod:= aCodfol[1397,1]
	EndIf
	
	If !Empty(cCod)
		If SRA->RA_CATFUNC == "C" .And. SRA->RA_SALARIO == 0 .And. fPosReg("RCE", 1, xFilial("RCE")+SRA->RA_SINDICA) .And. RCE->RCE_GCOMIS > 0
			SalMes := RCE->RCE_GCOMIS
		EndIf
		If lCalcBen
			SalMes := nSalBen
		EndIf
		For nPosAdt := 1 To Len(aAdtServ)
			If cBCalATS $ "3/4" .And. RetValSrv(aAdtServ[nPosAdt, 1], SRA->RA_FILIAL, "RV_INCORP") == "S" .And.;//Piso sindicato/salário mínimo
				(cTipoRot != "2" .Or. RetValSrv(aCodFol[6,1], SRA->RA_FILIAL, "RV_BASCAL") == "2")//Adiantamento
				If cTipoRot == "2"
					nIndic := ( SRA->RA_PERCADT / 100 )
				EndIf
				nAdcAux += (aAdtServ[nPosAdt, 3] * nIndic)
			EndIf
		Next nPosAdt
		If nInsalub > 0 .And. cBCalIns $ "1/4/5/6/7/8" .And. RetValSrv(cCodIns, SRA->RA_FILIAL, "RV_INCORP") == "S" .And.;//Piso sindicato/salário mínimo
			(cTipoRot != "2" .Or. RetValSrv(aCodFol[6,1], SRA->RA_FILIAL, "RV_BASCAL") == "2")//Adiantamento
			If cTipoRot == "2"
				nIndic := ( SRA->RA_PERCADT / 100 )
			EndIf
			nAdcAux += (nInsalub * nIndic)
		EndIf
		For nCont := 1 To Len(aPPE)
			If aPPE[nCont, 1] == "1" .And. !(aPPE[nCont, 5] $ "1/2")//RGE_PPE|RGE_STATUS
				cPPECOD := aPPE[nCont, 4]
				dIniRGE := aPPE[nCont, 2]
				dFimRGE := aPPE[nCont, 3]
				cStatRGE:= aPPE[nCont, 5]
				
				If cStatRGE $ "3/4"//Prorrogação | Antecipação
					dFimRGE := aPPE[nCont, 6]
				EndIf
				
				If lRGECod .And. !Empty(cPPECOD)
					nPosTab := fPosTab("S061", cPPECOD, "==", 4)
				Else
					nPosTab := fPosTab("S061", SRA->RA_SINDICA, "==", 5)
					
					//Se não encontrou o sindicato, verifica se o sindicato está vazio na tabela
					If nPosTab == 0
						nPosTab := fPosTab("S061", Space(nTamSind), "==",5)
					EndIf
				EndIf
				
				If nPosTab > 0
					dIniPPE		:=  fTabela("S061", nPosTab, 6)		//Inicio da Vigencia
					dFimPPE		:=  fTabela("S061", nPosTab, 7)		//Fim da Vigência
					nPerRed		:=  fTabela("S061", nPosTab, 8)		//Percentual de reducao
					nTetoPPE	:=  fTabela("S061", nPosTab, 9)		//Teto do abono 
					
					If cStatRGE == "3"//Prorrogação
						dFimPPE += fTabela("S061", nPosTab, 12)		//Dias de prorrogação
					ElseIf cStatRGE == "4" .And. !Empty(fTabela("S061", nPosTab, 11))//Antecipação
						dFimPPE := fTabela("S061", nPosTab, 11)		//Data de antecipação
					EndIf
					
					//So calcula o PPE se os contratos do Historico de Contratos(RGE) e da tabela do PPE (S061) estiverem vigentes
					If (AnoMes(dIniRGE) <= cPeriodo .And. cPeriodo <= AnoMes(dFimRGE)) .And. (AnoMes(dIniPPE) <= cPeriodo .And. cPeriodo <= AnoMes(dFimPPE))
						If Salmes > 0
							nDiasPPE := Min((Min(dFimRGE,DDATAATE) - Max(dIniRGE,DDATADE)) +1 ,nDiasC)
							
							// Tratamento para meses com 31 dias
							If nDiasPPE < nDiasC .And. Day(Min(dFimRGE, DDATAATE)) > nDiasC
								nDiasPPE--
							ElseIf (nDiasAux+nDiasPPE) > nDiasC
								nDiasPPE -= (nDiasAux+nDiasPPE) - nDiasc
							ElseIf Month(dDataAte) == 2 .And. (nDiasPPE == 28 .Or. nDiasPPE == 29)
								nDiasPPE := nDiasC
							EndIf
							
							//nDiasPPE := Min((Min(dFimRGE,if(f_ultdia(ddataate) > nDiasC,if(month(ddataate)<>2,ddataate-1,ddataate),DDATAATE)) - Max(dIniRGE,DDATADE)) +1 ,nDiasC)
							FDIASAFAST(@nTmpAfas , @nTmpTrab ,,,,,@aTmpAfas,,,iif( anomes(dIniRGE) == anoMes(DDATADE),dIniRGE,DDATADE),Min(dFimRGE,DDATAATE))
							aDetAfas 	:= aClone(aBkpAfas)
							aDiaAfaEs 	:= aClone(aBkpAfasEs)
							nDiasFgts	:= nBkpDFgt
							nDiasMat	:= nBkpDMat
							nDiasPPe 	-= nTmpAfas
							
							nDiasAux += nDiasPPE
							
							If nDiasPPe > 0
								
								// No Adiantamento calcula a redução sobre o valor total do adiantamento e não gera a verba de redução
								If !lCalcBen .And. cTipoRot == "2"
									If DiasTrab == nDiasPPE .and. nTmpAfas == 0
										nValAdi += (Val_Adto-nAdcAux) * nPerRed / 100
									Else
										nValAdi += (Val_Adto-nAdcAux) * nPerRed / 100 / nDiasC * nDiasPPE
									EndIf
								Else
									If SRA->RA_CATFUNC == "H" .And. cDiasMes == "S"
										nHNorRed 	:= ( (Normal / nDiasC * nDiasPPE) * nPerRed) / 100
										nHDesRed	:= ( (Descanso / nDiasC * nDiasPPE) * nPerRed) / 100
										nHrsRed 	:= (nHNorRed + nHDesRed)
										nValRed 	:= (SRA->RA_SALARIO * (nHNorRed + nHDesRed))
										nValRed 	:= (nValRed / nDiasC) * nDiasPPE //proporcionalização
									ElseIf SRA->RA_CATFUNC $ "H*M*C" 
										nHrsRed 	:= (( (SRA->RA_HRSMES / nDiasC * nDiasPPE) * nPerRed) / 100)
										nValRed 	:= (( (SalMes-nAdcAux) * nPerRed ) / 100)
										nValRed 	:= (nValRed / nDiasC) * nDiasPPE //proporcionalização
									EndIf
									If !lCalcBen
										If nContAux > 0
											cSeq := StrZero( Val(cSeq)+1, nTamSeq )
										EndIf
										
										fGeraVerba(cCod, nValRed, nHrsRed, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cSeq)									
										nContAux++
										
										// Calcula o benefício BEm e a ajuda compensatória para funcionários aposentados
										If lAposent
											BEmAposent(nPosTab, nPerRed, nValRed, (SalMes-nAdcAux), , nDiasPPE, cSeq)
										EndIf
										
										// Aplicar a redução nas verbas dos adicionais que não incorporam o salário
										For nI := 1 To Len(aPd)
											If aPd[nI][1] $ cPdAdicio .And. RetValSrv(aPd[nI][1], SRA->RA_FILIAL, "RV_INCORP") != "S"
												lAdtServ	:= aPd[nI][1] $ cPdAdtS
												lInsalub	:= aPd[nI][1] $ cPdInsal
												If (lAdtServ .And. cBCalATS $ "3/4") .Or.;//ATS e base de cálculo piso/salário mínimo
													(lInsalub .And. cBCalIns $ "1/4/5/6/7/8")//Insaluburidade e base de cálculo sobre piso/salário mínimo
													Loop
												EndIf
												aAdd(aValAdic, { nI, (aPd[nI][5] * nPerRed / 100 / nDiasC * nDiasPPE), (aPd[nI][4] * nPerRed / 100 / nDiasC * nDiasPPE) })
											EndIf
										Next
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		Next nCont
		
		aEval(aValAdic, { |x| aPd[x[1], 4] -= x[3] })
		aEval(aValAdic, { |x| aPd[x[1], 5] -= x[2], nValRed += x[2] })
		
		If !lCalcBen .And. cTipoRot == "2" .And. nValAdi > 0
			Val_Adto -= nValAdi
		EndIf
		
		nDiasPPE := nDiasAux
		If SRA->RA_CATFUNC == "C" .And. SRA->RA_SALARIO == 0
			SalMes := nSalBkp
		EndIf		
	EndIf
	
Return .T.

/*/{Protheus.doc} BEmAposent
Calcula o benefício BEm e a ajuda compensatória para funcionários aposentados
@type  Function
@author Cícero Alves
@since 27/08/2020
@param nPosTabela, Numérico, Posição na tabela S061
@param nPerRedu, Numérico, Percentual de Redução aplicado
@param nValRedu, Numérico, Valor da redução calculada
@param nSalfunc, Numérico, Salário do funcionário
@param nValAfast, Numérico, valor do afastamento quando há suspensão do contrato
@param nDias, Numérico, Dias de redução para proporcionalização
@param cSequen, Caracter, Sequência da verba, mesma sequência da verba de redução
@example
	BEmAposent(1, 25, 500.00, 2000.00, , 30, "") -> Para redução do salário
	BEmAposent(,,,, 1400.00,,) -> Para suspensão do contrato
@see https://tdn.totvs.com/x/BfR5IQ
/*/
Function BEmAposent(nPosTabela, nPerRedu, nValRedu, nSalfunc, nValAfast, nDias, cSequen)
	
	/*Até R$ 1.599,61: multiplica-se o salário médio por 0,8 (80%) 
	De R$ 1.599,62 a R$ 2.666,29: o que exceder R$ 1.599,61 será multiplicado por 0,5 (50%) e somado a R$ 1.279,69 
	Acima de R$ 2.666,29: a parcela será de R$ 1.813,03*/
	
	Local nSegDesmpr 	:= 0
	Local nValBEm		:= 0
	Local nValAjuda		:= 0
	Local cCodBEm		:= ""
	Local cCodAjd		:= ""
	Local nSEGFAIXA1	:= 0
	Local nSEGPER1		:= 0
	Local nSEGFAIXA2	:= 0
	Local nSEGPER2 		:= 0
	Local nTETOSEG		:= 0
	
	Default nPosTabela	:= 0
	Default nValAfast 	:= 0
	Default nDias		:= nDiasC
	Default cSequen		:= " "
	
	If Len (aCodFol) > 1851
		cCodBEm := aCodfol[1851, 1]
		cCodAjd := aCodfol[1852, 1]
	EndIf
	
	If nValAfast > 0
		nValAjuda := nValAfast
	ElseIf nPosTabela > 0		
		nSEGFAIXA1 := fTabela("S061", nPosTabela, 13)	// 1ª Faixa para cálculo do seguro desemprego
		nSEGPER1   := fTabela("S061", nPosTabela, 14)	// % Aplicada na primeira faixa
		nSEGFAIXA2 := fTabela("S061", nPosTabela, 15)	// 2ª Faixa para cálculo do seguro desemprego
		nSEGPER2   := fTabela("S061", nPosTabela, 16)	// % Aplicada na segunda faixa
		nTETOSEG   := fTabela("S061", nPosTabela, 9)	// Teto do seguro desemprego
		
		If !Empty(cCodBEm) .And. nSEGFAIXA1 > 0 .And. nSEGFAIXA2 > 0 .And. nSEGPER1 > 0 .And. nSEGPER2 > 0 .And. nTETOSEG > 0
			
			Do Case 
				Case SalMes <= nSEGFAIXA1
					nSegDesmpr := SalMes * nSEGPER1 / 100 
				Case SalMes <= nSEGFAIXA2
					nSegDesmpr := (nSEGFAIXA1 * nSEGPER1 / 100) + ((SalMes - nSEGFAIXA1) * nSEGPER2 / 100)
				Otherwise 
					nSegDesmpr := nTETOSEG
			EndCase
			
			nValBEm := nSegDesmpr * nPerRedu / 100
			nValBEm := nValBEm / nDiasC * nDias
			
			nValAjuda := (nSalfunc / nDiasC * nDias) - nValBEm - ((nSalfunc / nDiasC * nDias) - nValRedu)
			
			fGeraVerba(cCodBEm, nValBEm, , Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cSequen)
					
		Endif
	EndIf	
	
	If !Empty(cCodAjd) .And. nValAjuda > 0 
		nPos := aScan(aPd, {|x| x[1] == cCodAjd .and. x[9] <> 'D' } )
		If nPos > 0 .and. aPd[nPos,7] == 'C' //--Cria sequencia pois pode possuir suspensão e redução no mesmo mês
			aEval( aPd, { |x|  If(x[1] == cCodAjd .and. x[9] <> 'D', cSequen := Soma1(cSequen), Nil)} )
			nPos := 0
		EndIf
		If nPos == 0
			fGeraVerba(cCodAjd, nValAjuda, , Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, cSequen)
		EndIf
	EndIf
	
Return 

/*/{Protheus.doc} RestXCDES
Renicializa o conteúdo das variáveis Static
@author cicero.pereira
@since 27/09/2016
@version 1.0
/*/
Function RestXCDES()
	
	cFilSind := ""
	nDTrSind := ""
	
Return

/*/{Protheus.doc} fPensaoAPD
Busca o valor de pensão alimentícia nas férias que estiver no APD
@author claudinei.soares
@since 16/05/2017
@version 1.0
/*/
Function fPensaoAPD()

	Local cVerba 		:= ''
	Local cPdFer 		:= ''
	Local nBnf			:= 0
	Local nPensApd	:= 0
	Local nPosPens	:= 0
	Local aCdBenef 	:= {}

	fBusCadBenef( @aCdBenef )

	For nBnf := 1 To Len(aCdBenef)
		cVerba		:= aCdBenef[nBnf,16]
    	cPdFer 	:= Substr( cVerba, AT( "FER", cVerba )+ 3,3 )
		nPosPens 	:= fLocaliApd( cPdFer )
		If Ascan(aPd, { |X| X[1] = cPdFer .And. X[9] # "D" } ) > 0  
			nPensApd	+= aPd[nPosPens,5]
		EndIf
	Next nBnf
	
Return nPensApd

/*/{Protheus.doc} fHisContAs
Busca o a configuração da contribuição sindical na SR9 para o dissídio
@author gabriel.almeida
@since 01/06/2018
@version 1.0
/*/
Function fHisContAs()
	Local lContAss := .F.

	If SR9->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + "RA_ASSIST") )
		While SR9->( !Eof() ) .And. SRA->RA_FILIAL + SRA->RA_MAT == SR9->R9_FILIAL + SR9->R9_MAT .And. ( "RA_ASSIST" $ SR9->R9_CAMPO )
			If SR9->R9_DATA <= dDataAte
				lContAss := AllTrim( SR9->R9_DESC ) == "1"
			Else
				Exit
			EndIf

			SR9->( DbSkip() )
		EndDo
	Else
		lContAss := SRA->RA_ASSIST == "1"
	EndIf

Return lContAss


/*/{Protheus.doc} fHisContCf
Busca o a configuração da contribuição confederativa na SR9 para o dissídio
@author henrique.ferreira
@since 13/07/2018
@version 1.0
/*/
Function fHisContCf()
	Local lContCf := .F.

	If SR9->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + "RA_CONFED") )
		While SR9->( !Eof() ) .And. SRA->RA_FILIAL + SRA->RA_MAT == SR9->R9_FILIAL + SR9->R9_MAT .And. ( "RA_CONFED" $ SR9->R9_CAMPO )
			If SR9->R9_DATA <= dDataAte
				lContCf := AllTrim( SR9->R9_DESC ) == "1"
			Else
				Exit
			EndIf

			SR9->( DbSkip() )
		EndDo
	Else
		lContCf := SRA->RA_CONFED == "1"
	EndIf

Return lContCf

/*/{Protheus.doc} fHisMSind
Busca o a configuração da mensalidade sindical na SR9 para o dissídio
@author henrique.ferreira
@since 13/07/2018
@version 1.0
/*/
Function fHisMSind()
	Local lMenSind := .F.

	If SR9->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + "RA_MENSIND") )
		While SR9->( !Eof() ) .And. SRA->RA_FILIAL + SRA->RA_MAT == SR9->R9_FILIAL + SR9->R9_MAT .And. ( "RA_MENSIND" $ SR9->R9_CAMPO )
			If SR9->R9_DATA <= dDataAte
				lMenSind := AllTrim( SR9->R9_DESC ) == "1"
			Else
				Exit
			EndIf

			SR9->( DbSkip() )
		EndDo
	Else
		lMenSind := SRA->RA_MENSIND == "1"
	EndIf

Return lMenSind

/*/{Protheus.doc} fGetDifFer
Retorna as verbas de diferença de férias existentes na SRV
@author Leandro.Drumond
@since 16/08/2018
@version 1.0
/*/
Static Function fGetDifFer(cVbBaseP)
Local cRet		:= ""
Local cAliasSRV := GetNextAlias()
Local cFilSRV	:= xFilial("SRV")

DEFAULT cVbBaseP := ""

BeginSql alias cAliasSRV
	SELECT DISTINCT SRV.RV_FERSEG
	FROM %table:SRV% SRV
	WHERE SRV.RV_FILIAL = %exp:cFilSRV%
		  AND SRV.RV_REFFER = 'S'
		  AND SRV.RV_FERSEG <> ''
		  AND SRV.%NotDel%
EndSql

While (cAliasSRV)->( !Eof() )
    //-- Se a Verba de Hora Extra for codigo correspondente de outra, aborta a pesquisa 
	If Empty(cVbBaseP) .OR. (cAliasSRV)->RV_FERSEG $ cVbBaseP
		cRet += (cAliasSRV)->RV_FERSEG + ","  
	EndIf
	(cAliasSRV)->( DbSkip() )
EndDo

(cAliasSRV)->(DbCloseArea())

Return cRet

/*/{Protheus.doc} fPisoPens
Função para verificar se a pensão é maior que o piso definido no cadastro do beneficiário
@author Allyson Mesashi
@since 30/08/2021
@param cTpPiso, Caracter, Tipo do piso da pensão
@param nValPensao, Numérico, Valor da pensão atual
@param nVlPiso, Numérico, Valor do piso da pensão (conforme tipo)
@return nValPensao, Numérico, Valor da pensão ajustada
@version P12.1.27
/*/
Function fPisoPens( cTpPiso, nValPensao, nVlPiso )

Default cTpPiso 	:= "1"
Default nValPensao 	:= 0
Default nVlPiso 	:= 0

If cTpPiso $ "2/3/4" .And. nValPensao < nVlPiso
	nValPensao := nVlPiso
EndIf

Return nValPensao


/*/{Protheus.doc} retX6Desc
Função que retorna a descrição do parâmetro
@author Maria Luisa de Souza Arcanjo Bastos
@since 18/10/2023
@param cParam, Caracter, Código
@return cRet, Caracter, Descrição do parâmetro
@version P12.1.2310
/*/
Function retX6Desc(cParam)

	Local cRet := ""

	Default cParam 	:= ""

	If !Empty(cParam) .And. FWSX6Util():ExistsParam(cParam)
		cRet := AllTrim( X6Descric() ) +" "+ AllTrim( X6Desc1() ) +" "+ AllTrim( X6Desc2() )
	EndIf

Return( cRet )

/*/{Protheus.doc} retRcaDes
Função que retorna a descrição do mnemônico
@author Maria Luisa de Souza Arcanjo Bastos
@since 18/10/2023
@param cMne, Caracter, Mnemônico
@return cRet, Caracter, Descrição 
@version P12.1.2310
/*/
Function retRcaDes(cMne)

	Local cRet   := ""

	DEFAULT cMne := ""

	dbSelectArea('RCA')
	RCA->(dbSetOrder(1))
	If !Empty(cMne) .And. RCA->(dbSeek( xFilial("RCA")+ cMne))
		cRet := AllTrim(RCA->RCA_DESC)
	EndIf

Return(cRet)

/*/{Protheus.doc} fGetConsOri
Retorna valor original do eConsignado descontado na rescisão anterior
@author Leandro Drumond
@since 30/06/2025
@version P12.1.2310
/*/
Static Function fGetConsOri(cVerba, cNumID)
Local nValor 	:= 0

SRR->(DbSetOrder(4)) //RR_FILIAL, RR_MAT, RR_PERIODO, RR_ROTEIR, RR_SEMANA, RR_PD, RR_CC, RR_SEQ, RR_DATA

nValor := If(SRR->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + cRoteiro + cSemana + cVerba )), SRR->RR_VALOR, 0)

Return nValor
