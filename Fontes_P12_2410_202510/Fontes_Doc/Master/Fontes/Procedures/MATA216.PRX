#INCLUDE "MATA216.CH" 
#INCLUDE "PROTHEUS.CH"
#INCLUDE "fwlibversion.ch"
#INCLUDE "TBICONN.CH"
#INCLUDE "FILEIO.CH"
#INCLUDE "FWEVENTVIEWCONSTS.CH"

#DEFINE MAXPASSO 7
Static lTPBD

Static __lPrc2Pla 

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Mata216   ³ Rev   ³ Eduardo Riera         ³ Data ³12.03.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao dos acumulados do Poder de/em Terceiros³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpL1: Indica se o processo sera Batch                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo atualizar os dados do poder de ³±±
±±³          ³terceiros, das seguintes tabelas                             ³±±
±±³          ³A) SB6 -> Saldo do Poder de Terceiro                         ³±±
±±³          ³B) SB2 -> Saldos fisico e financeiro - Dados do MRP          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MATA216(lBat)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define Variaveis                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local nOpcA      := 0
Local aSays      := {}
Local aButtons   := {}
Local lExec      := .F.
Local lRet       := .T.
Local lProcessa  := .T.
Local bBlNewProc := {|oCenterPanel| ProcLogIni({},"MATA216"),lExec:=a216Proced(lBat,oCenterPanel),If(!lExec,a216Exec(lBat,oCenterPanel),)}
Local lUsaNewPrc := Iif(__lPrc2Pla, .T., UsaNewPrc())
Local cSPMAT041  := GetSPName("MAT041","15")
Local cSubRoutine:= ""
Local aInfoCustom	:= {}

Private aResult   := {}
Private aFilsCalc := {}
Private lSchedule := FWGetRunSchedule()
Private cCadastro  := OemtoAnsi(STR0001) //"Refaz Poder de/em terceiros"

If __lPrc2Pla == Nil
	__lPrc2Pla := GetRPORelease() >= "12.1.2410" //Controle criado para sempre utilizar a tNewProcess a partir da Release 12.1.2410
EndIf 
lUsaNewPrc := Iif(__lPrc2Pla, .T., UsaNewPrc())
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada MT216PRO                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock( 'MT216PRO')
	lRet:= ExecBlock('MT216PRO',.F.,.F.)
	If Valtype(lRet) <> 'L'
		lRet := .T. 
	EndIf
EndIf

If lRet 
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega as perguntas selecionadas                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ mv_par01 - Do Produto ?                                  ³
	//³ mv_par02 - Ate o Produto ?                               ³
	//³ mv_par03 - Seleciona Filiais ?                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Pergunte("MTA216",.F.)
	
	lBat := If(lBat == NIL, .F., lBat)
	
	TCInternal(5,"*OFF")   // Desliga Refresh no Lock do Top
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nova forma de criar dialogos para processos Batch            ³
	//³ COMPATIVEL COM PROTHEUS (BOF)                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lBat .And. !lSchedule
		If lUsaNewPrc
			//Função que apresenta log de execução(CV8) na tNewProcess
			If FindFunction('CV8LogView')
				Aadd(aInfoCustom,{OemToAnsi(STR0024),{|oCenterPanel| CV8LogView("MATA216", oCenterPanel)},"VERNOTA"}) //"Log de Execução"
			EndIf

			tNewProcess():New("MATA216",cCadastro,bBlNewProc,OemtoAnsi(STR0002)+OemtoAnsi(STR0003)+OemtoAnsi(STR0004),"MTA216",aInfoCustom,Nil,Nil,Nil,Nil,Nil,.T.)
		Else
			AADD(aSays,OemToAnsi(STR0002)) //"   Este programa tem como objetivo refazer o poder de/em "
			AADD(aSays,OemToAnsi(STR0003)) //"terceiros, conforme os movimentos dos documentos de "
			AADD(aSays,OemToAnsi(STR0004)) //"entrada/saida e os itens de pedido de venda liberados."
	
			AADD(aButtons, { 5,.T.,{|o| nOpcA:= 0 ,Pergunte("MTA216",.T.)} } )
			AADD(aButtons, { 1,.T.,{|o| nOpcA:= 1,If(MsgYesNo(OemToAnsi(STR0005),OemToAnsi(STR0006)),o:oWnd:End(),nOpcA:=0) } } ) //"Confirma Refaz Poder de/em terceiro ?"###"Aten‡„o"
			AADD(aButtons, { 2,.T.,{|o| o:oWnd:End() }} )
				
			ProcLogIni(aButtons)
		
			FormBatch( cCadastro, aSays, aButtons,,200,405 )
		EndIf
	Else
		ProcLogIni({})
		nOpcA := 1	
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	// Telemetria - Uso da classe FwCustomMetrics                   //
	// Metrica - setAverageMetric                                   //
	// Grava se utiliza ou nao utilizam procedure Refaz poder de    //
	// terceiros (MATA216)											//
	//?ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	If FWLibVersion() >= "20210628"
		If ExistProc( cSPMAT041, VerIDProc() )
			cSubRoutine := "PROCEDURE"
		else
			cSubRoutine := "ADVPL"
		Endif

		FWCustomMetrics():setAverageMetric(	cSubRoutine/*cSubRoutine*/,;
											"estoque/custos-protheus_refaz-poder-de-terceiros-stored-procedures_count" /*cIdMetric*/,;
											1 /*nValue*/,;
											/*dDateSend*/,;
											/*nLapTime*/,;
											"MATA216"/*cRotina*/)
	EndIf

	If (nOpcA == 1 .And. (!lUsaNewPrc .Or. lSchedule .Or. lBat))
		If ExistProc( cSPMAT041, VerIDProc() )	
			If IsBlind()
				BatchProcess(,,,{ || Processa({|lEnd| a216Proced(lBat)},,,.F.) } )
			Else
				Processa({|lEnd| a216Proced(lBat)},,,.F.)
			EndIf	
			lProcessa := .F.
		EndIf
		If lProcessa		
			a216Exec(lBat)
		EndIf	
	EndIf   
EndIf

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Ma216Proc ³ Rev   ³ Eduardo Riera         ³ Data ³12.03.2001 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de Processamento do MATA216                           ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo processar o poder de terceiro  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Ma216Proc(oObj,lBat)
Local aStruSD1  := {}
Local aStruSD2  := {}
Local cAliasSB2 := "SB2"
Local cAliasSB6 := "SB6"
Local cQuery    := ""
Local cChave    := ""
Local nMin      := 0
Local nMax      := 0
Local nX        := 0
Local nTamRegua := 7
Local cAliasSD1 := "SD1"
Local cAliasSD2 := "SD2"
Local cAliasSC9 := "SC9"
Local lQuery    := .F.
Local lContinua := .T.
Local lProcExcl := GetMv("MV_CUSTEXC") == "S"
Local lDelFisico:= GetMv("MV_DL216B6",,1)==1
Local lMT216Fil := ExistBlock("MT216FIL")
Local aTabs		:= {"SB2","SB6","SD1","SD2","SC9"}
Local aFiltro   := {}
Local cMensagem := ""
Local cFilSB2   := ""
Local cFilSB6   := ""
Local cFilSD1   := ""
Local cFilSD2   := ""
Local cFilSC6   := ""
Local cFilName	:= AllTrim(FWEmpName(cEmpAnt))+"/"+AllTrim(FWFilialName())

Local lM216VLib := FWLibVersion() >= "20211116"
Local oQry

DEFAULT lBat    := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ProcLogAtu("MENSAGEM",STR0022+cFilAnt,STR0012+cFilAnt) // "Inicio Filial: "

If !lBat .And. !IsBlind()
	oObj:SetRegua2(MAXPASSO)
	If !lProcExcl
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Avisa o usuario sobre o risco de processar compartilhado     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cMensagem := OemToAnsi(STR0011)+chr(13)		//"Esta rotina ser  executada em modo"
		cMensagem += OemToAnsi(STR0012)+chr(13)		//"compartilhado , conforme indicado"
		cMensagem += OemToAnsi(STR0013)+chr(13)		//"pelo parƒmetro MV_CUSTEXC."
		cMensagem += OemToAnsi(STR0014)+chr(13)		//"As movimenta‡”es que ocorrerem durante"
		cMensagem += OemToAnsi(STR0015)+chr(13)		//"o processo podem influir no c lculo."
		IF !MsgYesNo(cMensagem,OemToAnsi(STR0006))	
			Return
		Endif
	Endif
EndIf
If lProcExcl
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Abre todos os arquivos de forma exclusiva                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !(	MA280FLock("SB2",,!IsBlind()) .And.	MA280FLock("SB6",,!IsBlind()) .And.	MA280FLock("SD1",,!IsBlind()) .And.	MA280FLock("SD2",,!IsBlind()) .And.	MA280FLock("SC9",,!IsBlind()) )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Fecha todos os arquivos e reabre-os de forma compartilhada   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nX := 1 To Len(aTabs)
			dbSelectArea(aTabs[nX])
			dbCloseArea()
		Next nX
		OpenFile(SubStr(cNumEmp,1,2))
		Return
	Else
		OpenIndx("SB2")
		OpenIndx("SB6")
		OpenIndx("SD1")
		OpenIndx("SD2")
		OpenIndx("SC9")
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ MT216FIL - Ponto de Entrada para Filtrar processamento.      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lMT216FIL
	aFiltro := ExecBlock("MT216FIL",.F.,.F.)
	If ValType(aFiltro) == "A" .And. Len(aFiltro) == 5
		cFilSB2 := aFiltro[1]
		cFilSB6 := aFiltro[2]
		cFilSD1 := aFiltro[3]
		cFilSD2 := aFiltro[4]
		cFilSC6 := aFiltro[5]
	EndIf
EndIf

If lSchedule
	ProcRegua(nTamRegua)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza os acumulados do poder de/em teceiro                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SX2")
dbSetOrder(1)
MsSeek("SB2")
cMensagem := AllTrim(X2Nome())
cMensagem := Lower(cMensagem)
cMensagem := Upper(SubStr(cMensagem,1,1))+SubStr(cMensagem,2)
cAliasSB2 := "MA215PROC"
cQuery := "SELECT MIN(R_E_C_N_O_) MINRECNO,"
cQuery += "MAX(R_E_C_N_O_) MAXRECNO "
cQuery += "FROM "+RetSqlName("SB2")+" "
cQuery += "WHERE B2_FILIAL='"+xFilial("SB2")+"' AND "
cQuery += "B2_COD >= '"+mv_par01+"' AND B2_COD <= '"+mv_par02+"' "
cQuery += IIf(Empty(cFilSB2),"","AND " + cFilSB2 + " ")
cQuery += "AND D_E_L_E_T_=' '"
cQuery := ChangeQuery(cQuery)
	
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB2)
nMax := (cAliasSB2)->MAXRECNO
nMin := (cAliasSB2)->MINRECNO
dbCloseArea()
dbSelectArea("SB2")
cQuery := "UPDATE "
cQuery += RetSqlName("SB2")+" "
cQuery += "SET B2_QTNP = 0,"
cQuery += "B2_QNPT = 0,"
cQuery += "B2_QTER = 0 "
cQuery += "WHERE B2_FILIAL='"+xFilial("SB2")+"' AND "
cQuery += "B2_COD >= '"+mv_par01+"' AND B2_COD <= '"+mv_par02+"' "
cQuery += IIf(Empty(cFilSB2),"","AND " + cFilSB2 + " ")
cQuery += "AND D_E_L_E_T_=' ' AND "

If !lBat .And. !IsBlind()
	oObj:SetRegua1(Int(nMax/1024)+1)
EndIf	
For nX := nMin To nMax STEP 1024
	cChave := "R_E_C_N_O_>="+Str(nX,10,0)+" AND R_E_C_N_O_<="+Str(nX+1023,10,0)+""
	TcSqlExec(cQuery+cChave)
	If !lBat .And. !IsBlind()
		oObj:IncRegua1(cMensagem)
	Endif	
Next nX

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³A tabela eh fechada para restaurar o buffer da aplicacao³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SB2")
dbCloseArea()
ChkFile("SB2",.F.)
	
If !lBat .And. !IsBlind()
	oObj:IncRegua2(STR0007) //"Atualizando poder de/em terceiro"
ElseIf lSchedule
	IncProc(STR0021+cFilName) //"Processando: "
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Elimina os registros do saldo de poder de terceiro           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SX2")
dbSetOrder(1)
MsSeek("SB6")
cMensagem := AllTrim(X2Nome())
cMensagem := Lower(cMensagem)
cMensagem := Upper(SubStr(cMensagem,1,1))+SubStr(cMensagem,2)

If lDelFisico
	cAliasSB6 := "MA216PROC"
		
	cQuery := "SELECT MIN(R_E_C_N_O_) MINRECNO,"
	cQuery += "MAX(R_E_C_N_O_) MAXRECNO "
	cQuery += "FROM "+RetSqlName("SB6")+" "
	cQuery += "WHERE B6_FILIAL='"+xFilial("SB6")+"' AND "
	cQuery += "B6_PRODUTO >= '"+mv_par01+"' AND B6_PRODUTO <= '"+mv_par02+"' "
	cQuery += IIf(Empty(cFilSB6),"","AND " + cFilSB6 + " ")
	cQuery += "AND D_E_L_E_T_=' '"
	cQuery := ChangeQuery(cQuery)
	
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6)
	nMax := (cAliasSB6)->MAXRECNO
	nMin := (cAliasSB6)->MINRECNO
	dbCloseArea()
	dbSelectArea("SB6")
	cQuery := "DELETE FROM "
	cQuery += RetSqlName("SB6")+" "	
	cQuery += "WHERE B6_FILIAL='"+xFilial("SB6")+"' AND "
	cQuery += "B6_PRODUTO >= '"+mv_par01+"' AND B6_PRODUTO <= '"+mv_par02+"' "
	cQuery += IIf(Empty(cFilSB6),"","AND " + cFilSB6 + " ")
	If !lBat .And. !IsBlind()
		oObj:SetRegua1(Int(nMax/1024)+1)
	EndIf
	For nX := nMin To nMax STEP 1024
		cChave := "AND R_E_C_N_O_>="+Str(nX,10,0)+" AND R_E_C_N_O_<="+Str(nX+1023,10,0)+""
		TcSqlExec(cQuery+cChave)
		If !lBat .And. !IsBlind()
			oObj:IncRegua1(cMensagem)
		EndIf
	Next nX
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³A tabela eh fechada para restaurar o buffer da aplicacao³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB6")
	dbCloseArea()
	ChkFile("SB6",.F.)
Else
	If !lBat .And. !IsBlind()
		oObj:SetRegua1(SB6->(LastRec()))	
	EndIf
	dbSelectArea("SB6")
	dbSetOrder(1)
	MsSeek(xFilial("SB6"))
	While !Eof() .And. SB6->B6_FILIAL == xFIlial("SB6")
		If SB6->B6_PRODUTO < mv_par01 .Or. SB6->B6_PRODUTO > mv_par02 .Or.;
		   (!Empty(cFilSB6) .And. !(&cFilSB6))
			dbSkip()
			Loop			
		EndIf

		RecLock("SB6",.F.)
		dbDelete()
		MsUnlock()
		dbSelectArea("SB6")
		dbSkip()                     
		If !lBat  .And. !IsBlind()
			oObj:IncRegua1(cMensagem)
		EndIf
	EndDo
EndIf        
If !lBat .And. !IsBlind()
	oObj:IncRegua2(STR0007) //"Atualizando poder de/em terceiro"
Elseif lSchedule
	IncProc(STR0021+cFilName) //"Processando: "
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica as remessas do Poder em terceiro                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SX2")
dbSetOrder(1)
MsSeek("SD2")
cMensagem := AllTrim(X2Nome())
cMensagem := Lower(cMensagem)
cMensagem := Upper(SubStr(cMensagem,1,1))+SubStr(cMensagem,2)

If !lBat .And. !IsBlind()
	oObj:SetRegua1(SD2->(LastRec()))	
EndIf
cAliasSD2 := "MA216PROC"
aStruSD2  := SD2->(dbStruct())
lQuery := .T.

cQuery := "SELECT SD2.*,SF4.F4_PODER3 "
cQuery += "FROM "+RetSqlName("SD2")+" SD2,"
cQuery += RetSqlName("SF4")+" SF4 "
cQuery += "WHERE "
cQuery += "SD2.D2_FILIAL= ? AND "
cQuery += "SD2.D2_COD >= ? AND SD2.D2_COD <= ? "
cQuery += "AND SD2.D2_ORIGLAN <> ? "
cQuery += IIf(Empty(cFilSD2),""," AND " + cFilSD2 + " ")
cQuery += "AND SD2.D_E_L_E_T_= ? AND "
If cPaisLoc = 'MEX'
   cQuery += "SD2.D2_SERIE <> 'R' AND " // remito
EndIf
cQuery += "SF4.F4_FILIAL= ? AND "
cQuery += "SF4.F4_CODIGO=SD2.D2_TES AND "
cQuery += "SF4.F4_PODER3= ? AND "
cQuery += "SF4.D_E_L_E_T_= ? "
cQuery += "ORDER BY D2_FILIAL,D2_COD,D2_LOCAL "

cQuery := ChangeQuery(cQuery)

If lM216VLib
	oQry := FwExecStatement():New(cQuery)
Else
	oQry := FWPreparedStatement():New(cQuery)
EndIf 

oQry:SetString(1,xFilial('SD2'))
oQry:SetString(2,mv_par01)
oQry:SetString(3,mv_par02)
oQry:SetString(4,'LF')
oQry:SetString(5,' ')
oQry:SetString(6,xFilial('SF4'))
oQry:SetString(7,'R')
oQry:SetString(8,' ')

If lM216VLib
	 oQry:OpenAlias(cAliasSD2)	
Else
	cAliasSD2 := MPSYSOpenQuery(oQry:GetFixQuery())
EndIf


For nX := 1 To Len(aStruSD2)
	If aStruSD2[nX][2]<>"C"
		TcSetField(cAliasSD2,aStruSD2[nX][1],aStruSD2[nX][2],aStruSD2[nX][3],aStruSD2[nX][4])
	EndIf
Next nX

While !Eof() .And. (cAliasSD2)->D2_FILIAL == xFilial("SD2")	
	If lContinua
		Begin Transaction
			MaAtuSB6(cAliasSD2,3,.T.)
		End Transaction
	EndIf
	
	dbSelectArea(cAliasSD2)
	dbSkip()
	If !lBat .And. !IsBlind()	
		oObj:IncRegua1(cMensagem)
	EndIf
EndDo

If lQuery
	dbSelectArea(cAliasSD2)
	dbCloseArea()
	dbSelectArea("SD2")
EndIf
    
If !lBat .And. !IsBlind()
	oObj:IncRegua2(STR0007) //"Atualizando poder de/em terceiro"
Elseif lSchedule
	IncProc(STR0021+cFilName) //"Processando: "
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica as remessas do Poder de terceiro                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SX2")
dbSetOrder(1)
MsSeek("SD1")
cMensagem := AllTrim(X2Nome())
cMensagem := Lower(cMensagem)
cMensagem := Upper(SubStr(cMensagem,1,1))+SubStr(cMensagem,2)
If !lBat .And. !IsBlind()
	oObj:SetRegua1(SD1->(LastRec()))	
EndIf
cAliasSD1 := "MA216PROC"
aStruSD1  := SD1->(dbStruct())
lQuery := .T.

cQuery := "SELECT SD1.*,SF4.F4_PODER3 "
cQuery += "FROM "+RetSqlName("SD1")+" SD1,"
cQuery += RetSqlName("SF4")+" SF4 "
cQuery += "WHERE "
cQuery += "SD1.D1_FILIAL= ? AND "
cQuery += "SD1.D1_COD >= ? AND SD1.D1_COD <= ? "
cQuery += IIf(Empty(cFilSD1),""," AND " + cFilSD1 + " ")
cQuery += "AND SD1.D1_ORIGLAN <> ? "
cQuery += "AND SD1.D_E_L_E_T_= ? AND "
cQuery += "SF4.F4_FILIAL= ? AND "
cQuery += "SF4.F4_CODIGO=SD1.D1_TES AND "
cQuery += "SF4.F4_PODER3= ? AND "
cQuery += "SF4.D_E_L_E_T_= ? "
cQuery += "ORDER BY D1_FILIAL,D1_COD,D1_LOCAL "

cQuery := ChangeQuery(cQuery)

If lM216VLib
	oQry := FwExecStatement():New(cQuery)
Else
	oQry := FWPreparedStatement():New(cQuery)
EndIf 

oQry:SetString(1,xFilial('SD1'))
oQry:SetString(2,mv_par01)
oQry:SetString(3,mv_par02)
oQry:SetString(4,'LF')
oQry:SetString(5,' ')
oQry:SetString(6,xFilial('SF4'))
oQry:SetString(7,'R')
oQry:SetString(8,' ')

If lM216VLib
	 oQry:OpenAlias(cAliasSD1)	
Else
	cAliasSD1 := MPSYSOpenQuery(oQry:GetFixQuery())
EndIf 

For nX := 1 To Len(aStruSD1)
	If aStruSD1[nX][2]<>"C"
		TcSetField(cAliasSD1,aStruSD1[nX][1],aStruSD1[nX][2],aStruSD1[nX][3],aStruSD1[nX][4])
	EndIf
Next nX
While !Eof() .And. (cAliasSD1)->D1_FILIAL == xFilial("SD1")
	If lContinua
		dbSelectArea('SF1')
		dbsetorder(1)		//Posiciona SF1 para uso no F1_CLIPROP
		DbSeek(xFilial('SF1')+(cAliasSD1)->D1_DOC+(cAliasSD1)->D1_SERIE+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA)
		Begin Transaction
			MaAtuSB6(cAliasSD1,1,.T.)
		End Transaction
	EndIf
	dbSelectArea(cAliasSD1)
	dbSkip()
	If !lBat .And. !IsBlind()	
		oObj:IncRegua1(cMensagem)
	EndIf
EndDo
If lQuery
	dbSelectArea(cAliasSD1)
	dbCloseArea()
	dbSelectArea("SD1")
EndIf
    
If !lBat .And. !IsBlind()
	oObj:IncRegua2(STR0007) //"Atualizando poder de/em terceiro"
ElseIf lSchedule
	IncProc(STR0021+cFilName) //"Processando: "
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica os retornos do Poder de terceiro                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SX2")
dbSetOrder(1)
MsSeek("SD2")
cMensagem := AllTrim(X2Nome())
cMensagem := Lower(cMensagem)
cMensagem := Upper(SubStr(cMensagem,1,1))+SubStr(cMensagem,2)
If !lBat .And. !IsBlind()
	oObj:SetRegua1(SD2->(LastRec()))	
EndIf
cAliasSD2 := "MA216PROC"
aStruSD2  := SD2->(dbStruct())
lQuery := .T.

cQuery := "SELECT SD2.*,SF4.F4_PODER3 "
cQuery += "FROM "+RetSqlName("SD2")+" SD2,"
cQuery += RetSqlName("SF4")+" SF4 "
cQuery += "WHERE "
cQuery += "SD2.D2_FILIAL='"+xFilial("SD2")+"' AND "
cQuery += "SD2.D2_COD >= '"+mv_par01+"' AND SD2.D2_COD <= '"+mv_par02+"' "
cQuery += IIf(Empty(cFilSD2),""," AND " + cFilSD2 + " ")
cQuery += "AND SD2.D_E_L_E_T_=' ' AND "
If cPaisloc = 'MEX'
	cQuery += "SD2.D2_SERIE <> 'R' AND "    //remito
EndIf
cQuery += "SF4.F4_FILIAL='"+xFilial("SF4")+"' AND "
cQuery += "SF4.F4_CODIGO=SD2.D2_TES AND "
cQuery += "SF4.F4_PODER3='D' AND "
cQuery += "SF4.D_E_L_E_T_=' ' "
cQuery += "ORDER BY D2_FILIAL,D2_COD,D2_LOCAL "

cQuery := ChangeQuery(cQuery)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD2,.T.,.T.)

For nX := 1 To Len(aStruSD2)
	If aStruSD2[nX][2]<>"C"
		TcSetField(cAliasSD2,aStruSD2[nX][1],aStruSD2[nX][2],aStruSD2[nX][3],aStruSD2[nX][4])
	EndIf
Next nX
While !Eof() .And. (cAliasSD2)->D2_FILIAL == xFilial("SD2")
	If lContinua
		Begin Transaction
			MaAtuSB6(cAliasSD2,3,.T.)
		End Transaction
	EndIf
	
	dbSelectArea(cAliasSD2)
	dbSkip()
	If !lBat .And. !IsBlind()	
		oObj:IncRegua1(cMensagem)	
	EndIf
EndDo
If lQuery
	dbSelectArea(cAliasSD2)
	dbCloseArea()
	dbSelectArea("SD2")
EndIf    
If !lBat .And. !IsBlind()
	oObj:IncRegua2(STR0007) //"Atualizando poder de/em terceiro"
ElseIf lSchedule
	IncProc(STR0021+cFilName) //"Processando: "
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica os retornos do Poder em terceiro                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SX2")
dbSetOrder(1)
MsSeek("SD1")
cMensagem := AllTrim(X2Nome())
cMensagem := Lower(cMensagem)
cMensagem := Upper(SubStr(cMensagem,1,1))+SubStr(cMensagem,2)
If !lBat .And. !IsBlind()
	oObj:SetRegua1(SD1->(LastRec()))
EndIf
cAliasSD1 := "MA216PROC"
aStruSD1  := SD1->(dbStruct())
lQuery := .T.

cQuery := "SELECT SD1.*,SF4.F4_PODER3 "
cQuery += "FROM "+RetSqlName("SD1")+" SD1,"
cQuery += RetSqlName("SF4")+" SF4 "
cQuery += "WHERE "
cQuery += "SD1.D1_FILIAL='"+xFilial("SD1")+"' AND "
cQuery += "SD1.D1_COD >= '"+mv_par01+"' AND SD1.D1_COD <= '"+mv_par02+"' "
cQuery += IIf(Empty(cFilSD1),""," AND " + cFilSD1 + " ")
cQuery += "AND SD1.D_E_L_E_T_=' ' AND "
cQuery += "SF4.F4_FILIAL='"+xFilial("SF4")+"' AND "
cQuery += "SF4.F4_CODIGO=SD1.D1_TES AND "
cQuery += "SF4.F4_PODER3='D' AND "
cQuery += "SF4.D_E_L_E_T_=' ' "
cQuery += "ORDER BY D1_FILIAL,D1_COD,D1_LOCAL "

cQuery := ChangeQuery(cQuery)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD1,.T.,.T.)

For nX := 1 To Len(aStruSD1)
	If aStruSD1[nX][2]<>"C"
		TcSetField(cAliasSD1,aStruSD1[nX][1],aStruSD1[nX][2],aStruSD1[nX][3],aStruSD1[nX][4])
	EndIf
Next nX
While !Eof() .And. (cAliasSD1)->D1_FILIAL == xFilial("SD1")
	If lContinua
		Begin Transaction
			MaAtuSB6(cAliasSD1,1,.T.)
		End Transaction
	EndIf
	dbSelectArea(cAliasSD1)
	dbSkip()
	If !lBat .And. !IsBlind()	
		oObj:IncRegua1(cMensagem)	
	EndIf
EndDo
If lQuery
	dbSelectArea(cAliasSD1)
	dbCloseArea()
	dbSelectArea("SD1")
EndIf    
If !lBat .And. !IsBlind()
	oObj:IncRegua2(STR0007) //"Atualizando poder de/em terceiro"
ElseIf lSchedule
	IncProc(STR0021+cFilName) //"Processando: "
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica os retornos do Poder em terceiro                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SX2")
dbSetOrder(1)
MsSeek("SC9")
cMensagem := AllTrim(X2Nome())
cMensagem := Lower(cMensagem)
cMensagem := Upper(SubStr(cMensagem,1,1))+SubStr(cMensagem,2)
cAliasSB6 := "MA215PROC"
cQuery := "SELECT MIN(R_E_C_N_O_) MINRECNO,"
cQuery += "MAX(R_E_C_N_O_) MAXRECNO "
cQuery += "FROM "+RetSqlName("SB6")+" "
cQuery += "WHERE B6_FILIAL='"+xFilial("SB6")+"' AND "
cQuery += "B6_PRODUTO >= '"+mv_par01+"' AND B6_PRODUTO <= '"+mv_par02+"' "
cQuery += IIf(Empty(cFilSB6),""," AND " + cFilSB6 + " ")
cQuery += "AND B6_PODER3 = 'R' "
cQuery += "AND D_E_L_E_T_=' '"
cQuery := ChangeQuery(cQuery)
	
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6)
nMax := (cAliasSB6)->MAXRECNO
nMin := (cAliasSB6)->MINRECNO
dbCloseArea()
dbSelectArea("SB6")
If lTPBD == Nil
	lTPBD := If(Upper(TcGetDb()) $ "ORACLE*DB2*POSTGRES", .T.,.F.) // Verifica se o banco e oracle 
endIf
cQuery := "UPDATE "
cQuery += RetSqlName("SB6")+" "
cQuery += "SET B6_QULIB = "
cQuery += "(SELECT " + IIf(lTPBD,"COALESCE( ","ISNULL (")
cQuery += "SUM(C9_QTDLIB),0) "
cQuery += "FROM "
cQuery += RetSqlName("SC9")+" SC9,"
cQuery += RetSqlName("SC6")+" SC6,"
cQuery += RetSqlName("SF4")+" SF4 "
cQuery += "WHERE "
    	cQuery += "SC9.C9_FILIAL='"+xFilial("SC9")+"' AND "
cQuery += "SC9.C9_BLCRED <> '10' AND "
cQuery += "SC9.C9_BLEST <> '10' AND "
cQuery += "SC9.C9_PRODUTO=B6_PRODUTO AND "
cQuery += "SC9.C9_IDENTB6=B6_IDENT AND "
cQuery += "SC9.D_E_L_E_T_=' ' AND "
cQuery += "SC6.C6_FILIAL='"+xFilial("SC6")+"' AND "
cQuery += "SC6.C6_NUM=SC9.C9_PEDIDO AND "
cQuery += "SC6.C6_ITEM=SC9.C9_ITEM AND "
cQuery += "SC6.C6_PRODUTO=SC9.C9_PRODUTO AND "
cQuery += "SC6.C6_PRODUTO >= '"+mv_par01+"' AND SC6.C6_PRODUTO <= '"+mv_par02+"' "
cQuery += IIf(Empty(cFilSC6),""," AND " + cFilSC6 + " ")
cQuery += "AND SC6.D_E_L_E_T_=' ' AND "
cQuery += "SF4.F4_FILIAL='"+xFilial("SF4")+"' AND "
cQuery += "SF4.F4_CODIGO=SC6.C6_TES AND "
cQuery += "SF4.F4_PODER3='D' AND "
cQuery += "SF4.D_E_L_E_T_=' ' ) "
cQuery += "WHERE B6_FILIAL='"+xFilial("SB6")+"' AND "
cQuery += "B6_PRODUTO >= '"+mv_par01+"' AND B6_PRODUTO <= '"+mv_par02+"' "
cQuery += "AND B6_PODER3 = 'R' "
cQuery += IIf(Empty(cFilSB6),""," AND " + cFilSB6 + " ")
If !lBat .And. !IsBlind()		
	oObj:SetRegua1(Int(nMax/1024)+1)
EndIf
For nX := nMin To nMax STEP 1024
	cChave := "AND R_E_C_N_O_>="+Str(nX,10,0)+" AND R_E_C_N_O_<="+Str(nX+1023,10,0)+""
	TcSqlExec(cQuery+cChave)
	If !lBat .And. !IsBlind()			
		oObj:IncRegua1(cMensagem)
	EndIf	
Next nX
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Refresh executado no TopConnect             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SX2")
Set Filter to
DbSetOrder(1)
DbSeek("SB6")
TcRefresh(RetSqlName("SB6"))
dbSelectArea("SB6")
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³A tabela eh fechada para restaurar o buffer da aplicacao³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SB6")
dbCloseArea()
ChkFile("SB6",.F.)                  
If !lBat .And. !IsBlind()
	oObj:IncRegua2(STR0007) //"Atualizando poder de/em terceiro"
ElseIf lSchedule
	IncProc(STR0021+cFilName) //"Processando: "
Endif	
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Fecha todos os arquivos e reabre-os de forma compartilhada   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lBat .And. !IsBlind()
	If lProcExcl
		dbCloseAll()
		OpenFile(SubStr(cNumEmp,1,2))
	EndIf
EndIf	
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Executa o acerto do Custo em Partes                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
A216CstPartes(lBat,oObj)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ProcLogAtu("MENSAGEM",STR0023+cFilAnt,STR0013+cFilAnt) //"Final Filial: "

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A216CstPartes ³ Rev   ³ Microsiga S/A     ³ Data ³27/05/2008 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Funcao utilizada para reprocessar o custo em partes          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA216                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function A216CstPartes(lBat,oObj)
Local lCstPart  := .F.
Local lContinua := .F.
Local aRegraCP  := {}
Local aLogsPart := {}
Local aRetPartes:= {}
Local cQuery    := ''
Local cSeek     := ''
Local _cCampo   := ''
Local _nLoop0   := 0
Local _nLoop1   := 0
Local nCustoAtu := 0
Local cAliasSB6 := GetNextAlias()
Local cMoeda330C:= SuperGetMv('MV_MOEDACM',.F.,"2345") // Moedas para calculo do custo medio - Sempre processa moeda 1

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Preenche array com as regras do custo em partes.             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("MA330CP")
	aRegraCP:=ExecBlock("MA330CP",.F.,.F.)
	If ValType(aRegraCP) # "A"
		aRegraCP:={}
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se os campos do custo em partes estao Ok            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Len(aRegraCP) > 0
		lCstPart:=MA330AvlCp(aRegraCP,aLogsPart)
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processamento do Custo Em Partes                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCstPart
	cQuery := "SELECT R_E_C_N_O_ SB6RECNO "
	cQuery += "FROM "+RetSqlName("SB6")+" "
	cQuery += "WHERE B6_FILIAL='"+xFilial("SB6")+"' AND "
	cQuery += "B6_PRODUTO >= '"+mv_par01+"' AND B6_PRODUTO <= '"+mv_par02+"' "
	cQuery += "AND D_E_L_E_T_=' '"
	cQuery := ChangeQuery(cQuery)
		
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6)
    
	dbSelectArea(cAliasSB6)
	If !lBat .And. !IsBlind() .And. oObj <> Nil
		oObj:SetRegua2(SB6->(LastRec()))
	EndIf	
	Do While !Eof()

		If !lBat .And. !IsBlind() .And. oObj <> Nil
			oObj:IncRegua2(STR0020) //"Atualizando o Custo em Partes"
		EndIf

		dbSelectArea("SB6")
		dbSetOrder(1)
		dbGoto((cAliasSB6)->SB6RECNO)
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Localiza o documento de Origem para Gravar o Custo em partes³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lContinua := .F.
		If SB6->B6_TES <= '500'
			_cCampo   := "D1_CP"
			dbSelectArea("SD1")
			dbSetOrder(1)
			dbSeek(cSeek:=xFilial("SD1")+SB6->B6_DOC+SB6->B6_SERIE+SB6->B6_CLIFOR+SB6->B6_LOJA+SB6->B6_PRODUTO)
			Do While !Eof() .And. cSeek == SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD	
				If SD1->D1_TES     == SB6->B6_TES     .And.;
				   SD1->D1_LOCAL   == SB6->B6_LOCAL   .And.;
				   IIF(SD1->D1_NFORI<>' ',SD1->D1_IDENTB6,SD1->D1_NUMSEQ) == SB6->B6_IDENT   .And.;
				   SD1->D1_EMISSAO == SB6->B6_EMISSAO .And.;	
				   QtdComp(SD1->D1_QUANT)==QtdComp(SB6->B6_QUANT) .And.;
				   QtdComp(SD1->D1_VUNIT)==QtdComp(SB6->B6_PRUNIT)
				   lContinua := .T.	
				   Exit				   
				EndIf   
				dbSkip()
			EndDo
		Else 
			_cCampo   := "D2_CP"
			dbSelectArea("SD2")
			dbSetOrder(3)
			dbSeek(cSeek:=xFilial("SD2")+SB6->B6_DOC+SB6->B6_SERIE+SB6->B6_CLIFOR+SB6->B6_LOJA+SB6->B6_PRODUTO)
			Do While !Eof() .And. cSeek == SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD	
				If SD2->D2_TES     == SB6->B6_TES     .And.;
				   SD2->D2_LOCAL   == SB6->B6_LOCAL   .And.;
				   IIF(SD2->D2_NFORI<>' ',SD2->D2_IDENTB6,SD2->D2_NUMSEQ) == SB6->B6_IDENT  .And.;
				   SD2->D2_EMISSAO == SB6->B6_EMISSAO .And.;	
				   QtdComp(SD2->D2_QUANT )==QtdComp(SB6->B6_QUANT) .And.;
				   QtdComp(SD2->D2_PRCVEN)==QtdComp(SB6->B6_PRUNIT)
				   lContinua := .T.					   
				   Exit
				EndIf   
				dbSkip()
			EndDo
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o Custo em Partes na tabela SB6             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lContinua
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Inicializa o array aRetPartes com valor zerado       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRetPartes:=ARRAY((Len(aRegraCP)+1)*5)
			AFILL(aRetPartes,0)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega aRetPartes com os custos ja informados nos campos ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For _nLoop0:=1 to Len(aRegraCP)+1
				For _nLoop1:=1 to 5
					// Verifica se moeda devera ser considerada 	
					If _nLoop1 # 1 .And. !(Str(_nLoop1,1,0) $ cMoeda330C)
						aRetPartes[_nLoop1+((_nLoop0-1)*5)]:=0
	                	Loop
					EndIf
					_cCampo1  :=_cCampo+Strzero(_nLoop0,2,0)+Strzero(_nLoop1,2,0)
					nCustoAtu := FIELDGET(FieldPos(_cCampo1))
					aRetPartes[_nLoop1+((_nLoop0-1)*5)]:=nCustoAtu
				Next _nLoop1
			Next _nLoop0

			//-- Array com o custos nas 5 moedas (Conferencia realizada na funcao GravaCusCP)
			aCusto := {	SB6->B6_CUSTO1,;
						SB6->B6_CUSTO2,;
						SB6->B6_CUSTO3,;
						SB6->B6_CUSTO4,;
						SB6->B6_CUSTO5,;
					   }

			//-- Realiza a Gravacao do custo em partes na tabela SB6	
			GravaCusCP(lCstPart,aRegraCP,aCusto,"SB6",SB6->B6_PRODUTO,aClone(aRetPartes),NIL,NIL,aClone(aCusto),.F.)
		EndIf
		dbSelectArea(cAliasSB6)
		dbSkip()
	EndDo

EndIf
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³VerIDProc ³ Autor ³ Marcelo Pimentel      ³ Data ³24.07.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Identifica a sequencia de controle do fonte ADVPL com a     ³±±
±±³          ³stored procedure, qualquer alteracao que envolva diretamente³±±
±±³          ³a stored procedure a variavel sera incrementada.            ³±±
±±³          ³Procedure MAT041                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/         
Static Function VerIDProc()
Return '002'

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    	³a216Proced³ Autor ³ Andre Anjos           ³ Data ³15.12.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o 	³Funcao para chamada de procedure caso exista                |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/         
Function a216Proced(lBat,oCenterPanel)
Local aAreaAnt   := GetArea()
Local aAreaSM0   := SM0->(GetArea())
Local aFils		 := {}
Local nForFilial := 0
Local cFilBack   := cFilAnt
Local lProcessou := .F.
Local cSPMAT041  := GetSPName("MAT041","15")
Local aProcess   := {}
Local lExistPer4 := .F. //--Verifica a existencia da pergunta 04 que foi implementada na versão 12.1.14
Local cQry		 := ""
Local oQry 		 := Nil
Local cAliasAux  := ""
Local nY		 := 0
Local aTmpBulk	 := {}
Local oBulk		 := Nil
Local aFieldsSB6 := {}
Local cNomSB6	 := ""
Local n216THR	 := SuperGetMV("MV_A216THR",.F.,1)
Local nQtTHR	 := 0
Local cProdde	 := ''
Local cProdate   := ''
Local nCount2    := 0
Local nThrCTR	 := 0
Local aAreatrb	 
Local cFilProc 	 := cFilant
Local oFwSX1Util := Nil
Local cSSKey     := ""
Local aUsers	 := {}
Local nFil       := 0
Local nTries     := 1
Local nQtTotal   := 0
Local nThr       := 0
Local nCnt 		 := 0

oFwSX1Util := FwSX1Util():New()
oFwSX1Util:AddGroup("MTA216")
oFwSX1Util:SearchGroup()
lExistPer4 := LEN(oFwSX1Util:GetGroup("MTA216")[2]) > 3

If ExistProc( cSPMAT041, VerIDProc() )  
//Incluido tratamento para execucao por filiais.
	If !lBat .And. !IsBlind()
		aFilsCalc := MatFilCalc(mv_par03 == 1)
	Else
		aFils := MatFilCalc(.F.) // Processa somente a filial corrente
	EndIf	

	If !Empty(aFils)
		nForFilial := aScan(aFils,{|x| x[1] == .T.})
		aAdd(aFilsCalc, aFils[nForFilial])
	EndIf

	If !lBat
		ProcRegua(len(aFilsCalc),16,4)
	EndIf
		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿	
	//³ Inicializa o log de processamento   ³s
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcLogAtu("INICIO")
	If oCenterPanel <> NIL
		oCenterPanel:SaveLog(OemToAnsi(STR0016))
	EndIf

	If n216THR <= 0
		n216THR := 1
	ElseIf n216THR > 30
		n216THR := 30 
	EndIf

	If n216THR > 1
		cNomSB6:=CriaTrab(NIL,.F.)
		aFieldsSB6 := {}
		AADD(aFieldsSB6,{"B6_FILPROC"   ,"C",TamSX3("B6_FILIAL")[1] ,0})
		AADD(aFieldsSB6,{"B6_FILIAL"	,"C",TamSX3("B6_FILIAL")[1] ,0})
		AADD(aFieldsSB6,{"B6_PRODUTO"	,"C",TamSX3("B6_PRODUTO")[1],0})
		AADD(aFieldsSB6,{"B6_COUNT"		,"N",10,0})
		AADD(aFieldsSB6,{"THREAD"       ,"N",3,0}) 
		oTmpTable := FWTemporaryTable():New(cNomSB6)
		oTmpTable:SetFields( aFieldsSB6 )
		oTmpTable:AddIndex("indice1", {"B6_FILPROC","B6_FILIAL","B6_PRODUTO"})
		oTmpTable:AddIndex("indice2", {"B6_FILPROC","B6_FILIAL","THREAD","B6_PRODUTO"})
		oTmpTable:Create()

		For nForFilial := 1 to Len(aFilsCalc)
			cAliasAux := GetNextAlias()
			If aFilsCalc[nForFilial,1]
				cFilAnt:=aFilsCalc[nForFilial,2]
				nY := 1
				If oQry == Nil
					cQry :=	"SELECT FILIAL, PRODUTO, SUM(QTD) QTD FROM (
					cQry += "SELECT D2_FILIAL FILIAL, D2_COD PRODUTO , COUNT(SD2.R_E_C_N_O_) QTD "
					cQry += " FROM "+RetSqlName('SD2')+" SD2,"+RetSqlName('SF4')+" SF4 "
					cQry += " WHERE D2_FILIAL  = ?  AND D2_COD  BETWEEN ?  and ? "	// 1 , 2 , 3
					cQry += " AND D2_ORIGLAN  <> ? AND F4_FILIAL  = ? " 			// 4 , 5
					cQry += " AND F4_PODER3  = ?  AND F4_CODIGO  = D2_TES  AND "	// 6 
					cQry += " SD2.D_E_L_E_T_  = ? AND SF4.D_E_L_E_T_  = ? "			// 7 , 8
					cQry += " GROUP BY D2_FILIAL,D2_COD "
					cQry += " UNION " 
					cQry += " SELECT D2_FILIAL FILIAL , D2_COD PRODUTO , COUNT(SD2.R_E_C_N_O_) QTD "
					cQry += " FROM "+RetSqlName('SD2')+" SD2,"+RetSqlName('SF4')+" SF4 "
					cQry += " WHERE D2_FILIAL  = ?  AND D2_COD  BETWEEN ? AND ? "	// 9 , 10 , 11
					cQry += " AND F4_FILIAL  = ? AND F4_PODER3  = ? "				// 12 , 13
					cQry += " AND F4_CODIGO  = D2_TES  AND SD2.D_E_L_E_T_  = ? "	// 14, 
					cQry += " AND SF4.D_E_L_E_T_  = ? "								// 15
					cQry += " GROUP BY D2_FILIAL,D2_COD "
					cQry += " UNION "
					cQry += " SELECT D1_FILIAL FILIAL, D1_COD PRODUTO , COUNT(SD1.R_E_C_N_O_) QTD "
					cQry += " FROM "+RetSqlName('SD1')+" SD1, "+RetSqlName('SF4')+" SF4 "
					cQry += " WHERE D1_FILIAL  = ? AND D1_COD  BETWEEN ? AND ? "	// 16 , 17 , 18
					cQry += " AND D1_ORIGLAN  <> ? AND F4_FILIAL  = ? "				// 19 , 20
					cQry += " AND F4_CODIGO  = D1_TES  AND F4_PODER3  = ? "			// 21
					cQry += " AND SD1.D_E_L_E_T_  = ? AND SF4.D_E_L_E_T_  = ? "		// 22 , 23
					cQry += " GROUP BY D1_FILIAL,D1_COD "
					cQry += " UNION "
					cQry += " SELECT D1_FILIAL FILIAL, D1_COD PRODUTO , COUNT(SD1.R_E_C_N_O_) QTD "
					cQry += " FROM "+RetSqlName('SD1')+" SD1, "+RetSqlName('SF4')+" SF4 "
					cQry += " WHERE D1_FILIAL  = ? AND D1_COD BETWEEN ? AND ? "		// 24 , 25 , 26
					cQry += " AND F4_FILIAL  = ? AND F4_CODIGO  = D1_TES "			// 27
					cQry += " AND F4_PODER3  = ? AND SD1.D_E_L_E_T_  = ? "			// 28 , 29
					cQry += " AND SF4.D_E_L_E_T_  = ? "								// 30
					cQry += " GROUP BY D1_FILIAL,D1_COD ) T " 
					cQry += " GROUP BY FILIAL, PRODUTO "
					cQry += " ORDER BY 3 DESC "
					cQry := ChangeQuery(cQry)
					oQry:= FWPreparedStatement():New(cQry)
				EndIf 
				oQry:SetString(nY++, FWxFilial('SD2'))  // 1
				oQry:SetString(nY++, mv_par01)			// 2	
				oQry:SetString(nY++, mv_par02)			// 3
				oQry:SetString(nY++, 'LF')				// 4
				oQry:SetString(nY++, FWxFilial('SF4'))	// 5
				oQry:SetString(nY++, 'R')				// 6
				oQry:SetString(nY++, Space(1))			// 7
				oQry:SetString(nY++, Space(1))			// 8

				oQry:SetString(nY++, FWxFilial('SD2'))  // 9
				oQry:SetString(nY++, mv_par01)			// 10	
				oQry:SetString(nY++, mv_par02)			// 11
				oQry:SetString(nY++, FWxFilial('SF4'))	// 12
				oQry:SetString(nY++, 'D')				// 13
				oQry:SetString(nY++, Space(1))			// 14
				oQry:SetString(nY++, Space(1))			// 15

				oQry:SetString(nY++, FWxFilial('SD1'))  // 16
				oQry:SetString(nY++, mv_par01)			// 17	
				oQry:SetString(nY++, mv_par02)			// 18
				oQry:SetString(nY++, 'LF')				// 19
				oQry:SetString(nY++, FWxFilial('SF4'))	// 20
				oQry:SetString(nY++, 'R')				// 21
				oQry:SetString(nY++, Space(1))			// 22
				oQry:SetString(nY++, Space(1))			// 23

				oQry:SetString(nY++, FWxFilial('SD1'))  // 24
				oQry:SetString(nY++, mv_par01)			// 25	
				oQry:SetString(nY++, mv_par02)			// 26
				oQry:SetString(nY++, FWxFilial('SF4'))	// 27
				oQry:SetString(nY++, 'D')				// 28
				oQry:SetString(nY++, Space(1))			// 29
				oQry:SetString(nY++, Space(1))			// 30

				cAliasAux := MPSYSOpenQuery(oQry:GetFixQuery(), cAliasAux)		

				oBulk := FwBulk():New(oTmpTable:GetTableNameForTCFunctions(),500)
				oBulk:SetFields(aFieldsSB6)
				lCanUseBlk := oBulk:CanBulk()
				If lCanUseBlk
					While !(cAliasAux)->(Eof())
						lNoReg := .F.
						aTmpBulk := {}
						aadd(aTmpBulk,cFilProc)
						aadd(aTmpBulk,(cAliasAux)->FILIAL)
						aadd(aTmpBulk,(cAliasAux)->PRODUTO)
						aadd(aTmpBulk,(cAliasAux)->QTD)
						aadd(aTmpBulk,0)
						If !oBulk:AddData(aTmpBulk) 
							UserException(OemToAnsi(STR0025) +oBulk:GetError()) // "Erro no inclusão de campos no arquivo temporario"
						EndIf 
						(cAliasAux)->( dbSkip() )
					EndDo
				EndIf
				If !(oBulk:Close()) 
					ConOut(OemToAnsi(STR0026) + oBulk:GetError()) // "Erro ao inserir registros da SB6 no arquivo temp. Detalhes: "
				Endif
				oBulk:Destroy()
				oBulk := nil
				ASize(aTmpBulk,0) 

				dbSelectArea(cNomSB6)
				(cNomSB6)->(dbsetorder(1))
				(cNomSB6)->(dbgotop())
				(cNomSB6)->(dbseek(cFilProc+cFilAnt))
				while !Eof() .and. (cNomSB6)->(B6_FILPROC+B6_FILIAL) == cFilProc+cFilAnt
					nQtTotal += (cNomSB6)->B6_COUNT
					DbSkip()
				EndDo
				nRegTHR := round(nQtTotal / n216THR,0)

				(cNomSB6)->(dbgotop())
				(cNomSB6)->(dbseek(cFilProc+cFilAnt))
				nThr := 1
				while !Eof() .and. (cNomSB6)->(B6_FILPROC+B6_FILIAL) = cFilProc+cFilAnt
					RecLock(cNomSB6,.f.)
					THREAD := nThr
					nCnt += B6_COUNT
					MsUnlock()
					If nCnt >= nRegTHR
						nThr += 1
						nCnt := 0
					EndIf  
					DbSkip()
				EndDo
			EndIf
		Next nForFilial
	EndIf

	//Restaura a Filial Original
	cFilAnt := cFilBack
	nCount2 := nQtTHR
	cSSKey	:= cEmpAnt+CHR(255)+cFilAnt+CHR(255)+cAliasAux

	//Preparação para manualjob
	ClearGlbValue(cEmpAnt+cFilAnt+"ERROSB6GLOBAL")	
	cIDThread := cValToChar(ThreadID())
	cSemaforo := "M216JPRC_"+cIDThread+"_"+CEMPANT
	A216JobManual("1", cSemaforo, "M216JPRCCONNECT",nQtTHR,cSSKey)

	For nForFilial := 1 to Len(aFilsCalc)
		If aFilsCalc[nForFilial,1]
			// Altera filial corrente
			cFilAnt:=aFilsCalc[nForFilial,2]
			cProdde  := ''
			cProdate := ''	
			If n216THR > 1
				nThrCTR:= 0
				dbSelectArea(cNomSB6)
				(cNomSB6)->(dbsetorder(2))
				(cNomSB6)->(dbgotop())
				(cNomSB6)->(dbseek(cFilProc+cFilAnt))
				while !Eof() .and. (cNomSB6)->(B6_FILPROC+B6_FILIAL) == cFilProc+cFilAnt//.And. (cNomSB6)->B6_FILPROC = cFilProc .and. (cNomSB6)->B6_FILIAL = cFilAnt 
					If nThrCTR == 0
						nThrCTR:=(cNomSB6)->THREAD
					EndIf
					If cProdde = ''
						cProdde  := (cNomSB6)->B6_PRODUTO
					EndIf
					If (cNomSB6)->THREAD == nThrCTR
						cProdate := (cNomSB6)->B6_PRODUTO
					ElseIf (cNomSB6)->THREAD > nThrCTR
							aAreatrb := (cNomSB6)->(GetArea())
							M216StThr (cSemaforo,cEmpAnt,cFilAnt,cProdde,cProdate,nThrCTR,cIDThread)
							RestArea(aAreatrb)
							nThrCTR++
							cProdde := (cNomSB6)->B6_PRODUTO
					EndIf
					DbSkip()
				Enddo
				If !Empty(cProdde) .and. !Empty(cProdate)
					aAreatrb := (cNomSB6)->(GetArea())
					M216StThr (cSemaforo,cEmpAnt,cFilAnt,cProdde,cProdate,nThrCTR,cIDThread)
					RestArea(aAreatrb)
				EndIf
			Else
				M216StThr (cSemaforo,cEmpAnt,cFilAnt,mv_par01,mv_par02,nThrCTR,cIDThread)
			EndIf
			If lExistPer4 .And. MV_PAR04 == 1
				//ApMsgInfo(cFilAnt + STR0009)  //'Processamento OK'
			Else
				Aadd(aProcess, {.T.,cFilAnt, STR0009})
			EndIf 
		EndIf
	Next nForFilial

	lLoop      := .T.
	nCntThread := 0

	While lLoop 
		aUsers := GetUserInfoArray()
		For nY := 1 to len(aUsers)
			If aUsers[nY][1] == cSemaforo // semaforo
				cIDSubThr := cValToChar(aUsers[nY][3])  // ID da working thread
				cGlbName := "cThrWrk"+cIDSubThr // define o nome da variavel global
				cGlbValue := GetGlbValue(cGlbName) // Verifica valor da variável

				If cGlbValue == "1"
					nCntThread++ // conta qtas working threads abertas e executando
				EndIf
					
				If cGlbValue == "3" //Erro nas threads
					nCntThread := 0
					Exit
				EndIf
			EndIf
		Next nY

		If nCntThread == 0
			lLoop := .F. //Todas processadas, encerra o loop
		EndIf
		nCntThread := 0
		sleep(2000)

		//Limpa array
		For nY := 1 To Len(aUsers)
			aSize(aUsers[nY], 0)
		Next nY
		aUsers := aSize(aUsers,0)
	EndDo

	//Volta ao começo
	nFil := 1
	Sleep(1000)
	nTries++
	//Trata erros
	cErroGlob := GetGlbValue(cEmpAnt+cFilAnt+"ERROSB6GLOBAL")
	CONOUT (cErroGlob)
	If !Empty(cErroGlob)
		ProcLogAtu("MENSAGEM",cErroGlob,'MATA216')
		UserException(cErroGlob)
	EndIf

	A216JobManual("2", cSemaforo, "M216JPRCCONNECT")

	cFilAnt := cFilBack

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcLogAtu("MENSAGEM",STR0023+cFilAnt,STR0023+cFilAnt,'MATA216') //"Final Filial: "
	ProcLogAtu("FIM")
	If oCenterPanel <> NIL
		oCenterPanel:SaveLog(OemToAnsi(STR0017))
	EndIf
	If !lBat .And. !IsBlind()
		If lExistPer4 .And. MV_PAR04 = 2
			MostraLog(aProcess)
		EndIf
	EndIf

	A216CstPartes(lBat) //'Processa acerto do custo em partes'
	lProcessou := .T.

	//Restaura a Filial Original
	cFilAnt := cFilBack
EndIf

RestArea(aAreaSM0)
RestArea(aAreaAnt) 
Return lProcessou
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    	³a216Exec  ³ Autor ³ Andre Anjos           ³ Data ³15.12.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o 	³Funcao para chamada da MA216Proc para as filiais marcadas   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/         
Function a216Exec(lBat,oCenterPanel)
Local nForFilial := 0
Local cFilBack   := cFilAnt
Local oProcess

ProcLogAtu("INICIO")

Do Case
	Case !lBat .And. !IsBlind()
		aFilsCalc := MatFilCalc(mv_par03 == 1)
		For nForFilial := 1 to Len(aFilsCalc)
			
			If aFilsCalc[nForFilial,1]
				// Altera filial corrente
				cFilAnt:=aFilsCalc[nForFilial,2]
				If oCenterPanel <> NIL
					oCenterPanel:SaveLog(OemToAnsi(STR0016))
					Ma216Proc(oCenterPanel,lBat)	
					oCenterPanel:SaveLog(OemToAnsi(STR0017))
				Else
					oProcess := MsNewProcess():New({|lEnd| Ma216Proc(oProcess,lBat)},"","",.F.)
					oProcess:Activate()
				EndIf
			EndIf
			
		Next nForFilial
	Case lBat
		Ma216Proc(Nil,lBat)
	Case lSchedule
		BatchProcess(,,,{ || Processa({|lEnd| Ma216Proc(Nil,lBat)},,,.F.) } )
EndCase

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ProcLogAtu("FIM")

cFilAnt := cFilBack

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³MostraLog ³ Autor ³ Talita Teixeira       ³ Data ³26.10.2016 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA216                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/


Static Function MostraLog(aProcess)

Local oOK := LoadBitmap(GetResources(),'br_verde')
Local oNO := LoadBitmap(GetResources(),'br_vermelho')  

DEFINE DIALOG oDlg TITLE "Log de Processamento" FROM 180,180 TO 500,700 PIXEL	    

oBrowse := TCBrowse():New( 01 , 01, 260,140,,{'','Filial','Log'},{20,30,30},oDlg,,,,,{||},,,,,,,.F.,,.T.,,.F.,,, )    
oBrowse:SetArray(aProcess)    
oBrowse:bLine := {||{If(aProcess[oBrowse:nAt,01],oOK,oNO),aProcess[oBrowse:nAt,02],;                      
aProcess[oBrowse:nAt,03] } }    

DEFINE SBUTTON FROM 145,230 TYPE 1  ENABLE OF oDlg Action(oDlg:End()) 

ACTIVATE DIALOG oDlg CENTERED

Return

/*/{Protheus.doc} EngSPS15Signature
Funcao executada durante a exibicao de informacoes detalhadas do processo na
interface de gestao de procedures.
Faz a execucao da funcao static VerIdProc
@type function
@version 1.0
@author Squad Entradas
@since 13/12/2021
@param cProcesso, character, Codigo do processo
@return character, Retorna a assinatura do processo
/*/
Function EngSPS15Signature(cProcesso as character)

	Local cAssinatura as character

	cAssinatura := VerIDProc()

Return cAssinatura

//-------------------------------------------------------------------
/*/{Protheus.doc} SchedDef
Retorna as perguntas definidas no schedule.
@return aReturn - Array com os parametros
@author  Squad Entradas
@since 	 19/03/2024
/*/
//-------------------------------------------------------------------

Static Function Scheddef()
Local aParam  := {}

	aParam := { "P",;           //Tipo R para relatorio P para processo
				"MTA216",;      //Pergunte do relatorio, caso nao use passar ParamDef
				,;              //Alias
				,;              //Array de ordens
				}               //Titulo

Return aParam

/*/{Protheus.doc} M216JOBSTART - Função para iniciar o ambiente
pela empresas/filial informada na chamada da MANUALJOB
@author Totvs
@since 16/04/2025
@version 1.0
/*/
FUNCTION M216JOBSTART(cParam)
LOCAL aParam := {}
LOCAL aTabelas   := {"SB2","SF4","SD1","SD2","SD3","SF2","SF1","SB6","SD7"}
LOCAL cLFil
LOCAL cLEmp
LOCAL cGlbName
Local cParam3  := '' As Character

   cGlbName  := "cThrWrk"+cValToChar(ThreadId())
	A216LckGlb(cGlbName)
	PutGlbValue(cGlbName,"1")
	A216ULckGlb(cGlbName)
	aParam := STRTOKARR( cParam, chr(255) )

	cLEmp := aParam[1]
	cLFil := aParam[2]
	If Len(aParam) > 2 .And. !Empty(aParam[3])
		cParam3 := aParam[3]
	EndIf

	RpcSetType(3)
	RpcSetEnv( cLEmp,cLFil,,,'EST',,aTabelas)
	A216LckGlb(cGlbName)
    PutGlbValue(cGlbName,"0")
	A216ULckGlb(cGlbName)

RETURN .T.

/*/{Protheus.doc} M216JOBEXIT - Função ao encerrar a thread da chamada da MANUALJOB
@author Totvs
@since 06/04/2020
@version 1.0
@return logico - sempre verdadeiro
/*/
FUNCTION M216JOBEXIT()
RETURN .T.

/*/{Protheus.doc} M216StThr - Dispara a execução da procedure 
@author Totvs
@since 06/04/2020
@version 1.0
@return nulo
/*/
Function M216StThr (cSemaforo,cEmp,cFil,cProdde,cProdate,nThread,cIDThread)
Local cFilBack   := cFilAnt
Local cSPMAT041  := GetSPName("MAT041","15")
Local Ni

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

cFilAnt:=cFil
dbSelectArea("SM0")
dbSetOrder(1)
MsSeek(cEmp+cFilAnt)

IncProc(STR0021+AllTrim(SM0->M0_NOME)+"/"+AllTrim(SM0->M0_FILIAL)) //"Processando: "

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Dispara thread para Stored Procedure        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
while ! IPCGO(cSemaforo,cEmpAnt,cFilAnt,cSPMAT041,cProdde,cProdate,cFilBack,nThread)
	for nI := 1 to 2
		sleep(1000)
	Next nI
End

Return 

/*/{Protheus.doc} A216JobManual
Abertura de threads filhas para processamento
@author Totvs
@since 16/04/2025
@version 1.0
/*/
Static Function A216JobManual(cStatus, cIdentificador, cJobConnect, nTotThread, cSessionKey )
LOCAL nMinThread
LOCAL nMaxThread
LOCAL nFreeThread
LOCAL nIncThread

Default nTotThread  := SuperGetMV("MV_A216THR",.F.,1)
Default cSessionKey := cEmpAnt+CHR(255)+cFilAnt+CHR(255)

	// inicia o manualJob
	If cStatus == "1"
		If nTotThread > 10
			nTotThread := 10
		ElseIf nTotThread == 9
			nTotThread := 10
		Else
			nTotThread := nTotThread+2
		EndIf
		
		nMinThread := Val(GetSrvProfString( "ThreadMinOrdem", cValToChar(nTotThread) ))
		nMaxThread := Val(GetSrvProfString( "ThreadMaxOrdem", "30" ))
		nFreeThread := 2
		nIncThread := 2
	EndIf

	// encerra o manualJob
	If cStatus == "2"
		nMinThread := 0
		nMaxThread := 0
		nFreeThread := 0
		nIncThread := 0
	EndIf

   ManualJob(	cIdentificador/*Nome do indentificador do job*/,;
				GetEnvServer()/*Ambiente que vc vai abrir este cara*/,;
				"IPC"/*Tipo do job. Mantenha como Ipc*/,;
				"M216JOBSTART"/*Função que será chamada quando uma nova thread subir*/,;
				cJobConnect/*Função que será chamada toda vez que vc mandar um ipcgo para ela*/,;
				"M216JOBEXIT"/*Função que será invocada quando a thread cair pelo timeout dela*/,;
				cSessionKey/*Não alterar. É o SessionKey*/,;
				300 /*Tempo em segundos que a thread será reavaliada e irá cair. Vamos manter 5 minutos. Se não receber nada ela morre*/,;
				nMinThread /*Minimo de threads inicias. Vamos deixar 0 para que quando cair por timeout ele acabe*/,;
				nMaxThread /*máximo de threads que ele vai subir*/,;
				nFreeThread /*mínimo de threads livres*/,;
				nIncThread /*incremento de threads livres*/,;
      		)

	If cStatus == "2"
		DownThread(cIdentificador)
	EndIf

Return .T.

/*/{Protheus.doc} A216LckGlb
Função responsável por garantir o uso da varável global em atualização
@author Totvs
@since 16/04/2025
@version 1.0
@return nulo
/*/
Function A216LckGlb(cNameGlobal)
	//- Garante que apenas um pegue o ID
	While !KillApp()
		//- Valida se peguei a chave
		If GlbNmLock(cNameGlobal)
			Exit
		EndIf
		Sleep(175)
	EndDo
Return

/*/{Protheus.doc} A216ULckGlb
Função responsável por liberar o uso da varável global em atualização
@author Totvs
@since 16/04/2025
@version 1.0
@return nulo
/*/
Function A216ULckGlb(cNameGlobal)
GlbNmUnlock(cNameGlobal)
Return

/*/{Protheus.doc} M216JPRCCONNECT - Executa a funcao M216JPRC para executar a procedure MAT041 por filial
@author Totvs
@since 16/04/2025
@version 1.0
@return nulo
/*/
Function M216JPRCCONNECT(cEmp,cFil,cProcNam,cprodde,cprodate,cFilBack,nThread)
LOCAL cGlbName
LOCAL cThisThread

	If cEmp=="##QUIT##"
		cThisThread := cValToChar(ThreadId())
		cGlbName := "cThrWrk"+cThisThread // define o nome da variavel global
		ClearGlbValue(cGlbName)
		killapp(.T.)
	ELSE
		cGlbName  := "cThrWrk"+cValToChar(ThreadId())
		A216LckGlb(cGlbName)
		PutGlbValue(cGlbName,"1")
		A216ULckGlb(cGlbName)
		M216JPRC(cEmp,cFil,cProcNam,cprodde,cprodate,cFilBack,nThread)
	Endif
	A216LckGlb(cGlbName)
	PutGlbValue(cGlbName,"0")
	A216ULckGlb(cGlbName)

RETURN

/*/{Protheus.doc} M216JPRC - Executa a Procedure 
@author Totvs
@since 16/04/2025
@version 1.0
@return nulo
/*/
Function M216JPRC(cEmp,cFil,cProcNam,cprodde,cprodate,cFilBack,nThread)
Local aResult     := {}
Local cFilMSG	  := cFil
Local nTRY 		  := 0
Local cGlbName    := ""
Local cInTransact := ""

cGlbName  := "cThrWrk"+cValToChar(ThreadId())

// STATUS 1 - Iniciando execucao do Job
A216LckGlb(cGlbName)

// Seta job para empresa filial desejada
cFilant := cFil

// STATUS 2 - Conexao efetuada com sucesso
PutGlbValue(cGlbName, "2" )
A216ULckGlb(cGlbName)

ProcLogAtu("MENSAGEM",STR0022+" Proc:"+cFilMSG+" Fil :"+cFil+" Thr:"+cValToChar(nThread),cFil+" Thr:"+cValToChar(nThread)+" Prd: "+cProdde+" a "+cProdate,'MATA216') // "Inicio Filial: "

cInTransact :='0'
if InTransact()
	cInTransact := '1'
EndIf

aResult:=TCSpExec(	xProcedures( cProcNam),cFil,cprodde,cprodate,cInTransact)

while .t.
	If Empty(aResult)
		nTRY++
		If nTRY > 5
			A216LckGlb(cGlbName)
			PutGlbValue(cGlbName, "3") //Status de Erro
			A216ULckGlb(cGlbName)

			A216LckGlb(cEmp+cFil+"ERROSB6GLOBAL")
			PutGlbValue(cEmp+cFil+"ERROSB6GLOBAL", TCSQLError())
			A216ULckGlb(cEmp+cFil+"ERROSB6GLOBAL")
			ProcLogAtu("MENSAGEM","Erro "+" Proc:"+cFilMSG+" Fil :"+cFil+" Thr:"+cValToChar(nThread)+" excedeu limite de Tentativas",cFil+" Thr:"+cValToChar(nThread)+" Prd: "+cProdde+" a "+cProdate,'MATA216') // "Inicio Filial: "
			ProcLogAtu("MENSAGEM","Erro Proc: "+cFilMSG+" Fil :"+cFil+" Thr:"+cValToChar(nThread)+" "+TCSQLError(),TCSQLError())
			EXIT
		else
			ProcLogAtu("MENSAGEM","Erro "+" Proc:"+cFilMSG+" Fil :"+cFil+" Thr:"+cValToChar(nThread)+" Try "+cvaltochar(nTRY),cFil+" Thr:"+cValToChar(nThread)+" Prd: "+cProdde+" a "+cProdate,'MATA216')
			ProcLogAtu("MENSAGEM","Erro Proc: "+cFilMSG+" Fil :"+cFil+" Thr:"+cValToChar(nThread)+" "+TCSQLError(),TCSQLError())
			aResult:=TCSpExec(	xProcedures( cProcNam),cFil,cprodde,cprodate,cInTransact)
		EndIf
	ElseIf aResult[1] == "0"
		A216LckGlb(cGlbName)
		PutGlbValue(cGlbName, "3" ) //Status de Erro
		A216ULckGlb(cGlbName)

		A216LckGlb(cEmp+cFil+"ERROSB6GLOBAL")
		PutGlbValue(cEmp+cFil+"ERROSB6GLOBAL", "Erro "+" Proc:"+cFilMSG+" Fil :"+cFil+" Thr:"+cValToChar(nThread)+" Retorno zero")
		A216ULckGlb(cEmp+cFil+"ERROSB6GLOBAL")
		ProcLogAtu("MENSAGEM","Erro "+" Proc:"+cFilMSG+" Fil :"+cFil+" Thr:"+cValToChar(nThread)+" Retorno zero",cFil+" Thr:"+cValToChar(nThread)+" Prd: "+cProdde+" a "+cProdate,'MATA216') // "Inicio Filial: "
        ProcLogAtu("MENSAGEM","Erro Proc: "+cFilMSG+" Fil :"+cFil+" Thr:"+cValToChar(nThread)+" "+TCSQLError(),TCSQLError())
		EXIT
	ElseIf aResult[1] == "1"
		ProcLogAtu("MENSAGEM",STR0023+" Proc:"+cFilMSG+" Fil :"+cFil+" Thr:"+cValToChar(nThread),cFil+" Thr:"+cValToChar(nThread)+" Prd: "+cProdde+" a "+cProdate,'MATA216') // "Final Filial: "
		Exit
	EndIf
EndDo

RETURN


/*/{Protheus.doc} DownThread
Baixa das working thread abertas, onde o controle é feito através de variaveis globais
@author Totvs
@since 16/04/2025
@version 1.0
@return nulo
/*/
Static Function DownThread(cIdentificador)
LOCAL lLoop
LOCAL nI
LOCAL nCntThread
LOCAL aUsers
LOCAL cGlbName
LOCAL cGlbValue
LOCAL cIDThread

	lLoop := .T.
	nI := 0
	aUsers := {}

	While lLoop // loop de controle para encerramento de todas as working threads
		aUsers := GetUserInfoArray()
		For nI := 1 to len(aUsers)
			If aUsers[nI][1] == cIdentificador // semaforo

				nCntThread++ // conta qtas working threads abertas

				cIDThread := cValToChar(aUsers[nI][3])  // ID da working thread

				cGlbName := "cThrWrk"+cIDThread // define o nome da variavel global

				cGlbValue := GetGlbValue(cGlbName) // Verifica valor da variável

				If cGlbValue == "0"
					IPCGO( cIdentificador,"##QUIT##")
				EndIf
			EndIf
		Next nI
		aUsers := aSize(aUsers,0)
		If nCntThread ==0
			lLoop := .F.
		EndIf
		nCntThread := 0
		sleep(1000)
	EndDo

RETURN NIL

