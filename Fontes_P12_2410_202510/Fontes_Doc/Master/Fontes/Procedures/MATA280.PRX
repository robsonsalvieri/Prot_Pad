#INCLUDE "MATA280.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FILEIO.CH"
#INCLUDE "FWLIBVERSION.CH"
#INCLUDE "FWEVENTVIEWCONSTS.CH"

#DEFINE _NEWLINE chr(13)+chr(13);

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MATA280  ³ Autor ³ Eveli Morasco         ³ Data ³ 17/02/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fechamento mensal                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Marcelo Pim.³15/01/98³xxxxxx³Controle de Saldos em unidade de medida.  ³±±
±±³Rodrigo Sart³15/07/98³16978A³Acerto nos locks qdo roda compartilhado.  ³±±
±±³Rodrigo Sart³27/07/98³XXXXXX³Incluida pergunta se gera copia dos dados ³±±
±±³            ³        ³      ³ou nao.                                   ³±±
±±³Rodrigo Sart³21/05/99³XXXXXX³Transfere os saldos dos Lotes FIFO        ³±±
±±³Rodrigo Sart³20/07/99³22963a³ Acerto na gravacao ref 2a Unidade Medida ³±±
±±³Marcelo Pim.³09/11/01³PYME  ³ Adequacao do fonte para utilizacao do    ³±±
±±³            ³        ³PYME  ³ Siga PyMe.                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Descri‡…o ³ PLANO DE MELHORIA CONTINUA                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ITEM PMC  ³ Responsavel              ³ Data         |BOPS:             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³      01  ³                          ³              |                  ³±±
±±³      02  ³Erike Yuri da Silva       ³13/01/2006    |00000091471       ³±±
±±³      03  ³                          ³              |                  ³±±
±±³      04  ³Flavio Luiz Vicco         ³08/09/2006    |00000106852       ³±±
±±³      05  ³Erike Yuri da Silva       ³25/01/2006    |00000092023       ³±±
±±³      06  ³                          ³              |                  ³±±
±±³      07  ³                          ³              |                  ³±±
±±³      08  ³Flavio Luiz Vicco         ³08/09/2006    |00000106852       ³±±
±±³      09  ³Erike Yuri da Silva       ³13/01/2006    |00000091471       ³±±
±±³      10  ³Erike Yuri da Silva       ³25/01/2006    |00000092023       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MATA280(lBat,ddataFec,cArq1,cArq2,cArq3,cArq4,cArq5,cArq6,cArq7, aListaFil, aParAuto, oJourney, lOnbord, cUserNamej)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define variaveis locais                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aTreeProc  := {}
Local aProcsOk   := {}
Local lOpc		 := .F.
Local bBlNewProc := {|oCenterPanel|aFilsCalc := MatFilCalc(mv_par03==1),IIF(ma280OK(dDataFec,cArq1,cArq2,cArq3,cArq4,cArq5,cArq6,cArq7,!lBat), a280Run(@aProcsOk,lBat,dDataFec,cArq1,cArq2,cArq3,cArq4,cArq5,cArq6,cArq7,oCenterPanel), .F.)}
Local lNewRelease:= UsaNewPrc()
Local oDlgOcorr
Local oOcorr
Local oDlg
Local oProcess
Local nCont
Local cBackFil
LOCAL lEnviron:= FindFunction("ACVERVLD")
Local lCstOnLine  := AllTrim(SuperGetMv("MV_CUSMED",.F.,"M")) == "O"
Local cRelease := ""
Local lMsgBlock

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Nomes dos arquivos para copia dos registros deletados        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private lEnd	:= .F.
Private nOpca	:= 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas para custo em partes                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private lMA330CP  := ExistBlock("MA330CP")
Private lCstPart  := .F.
Private aRegraCP  := {}

Private aFilsCalc := {}
Private alogsGR   := {}
Private lChkLog   := .F.
Private cFilStart := cFilAnt

Default lBat	  := .F.
Default aListaFil := {}
Default aParAuto  := {}

PRIVATE lJourney
Private OJOURNEYLOG
PRIVATE aAuto280	:= aClone(aParAuto)
PRIVATE lExistD3Y	:= AliasInDic("D3Y")

//Variavel de controle se esta processando pelo onboard de jornada de fechamento 
Default  lOnbord  := .F.
Default	 cUserNameJ := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Variavel utilizada para gravar o grupo de perguntas - MTA280  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE a280ParamZX:=Array(4)
lJourney := lOnbord	
if lEnviron
	If !lJourney
		OJOURNEYLOG	:= acJourneyLog():New()	
	Else
		OJOURNEYLOG	:= oJourney
		iIf (Empty(cUserName), cUserName:= cUserNameJ, cUserName)
	EndIf
	OJOURNEYLOG:envValid(lJourney)
else
	Help(" ",1,"NOTATU",,STR0147,02,01)
	Return Nil
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa o log de processamento   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
oJourneyLog:logIni(.T.)
If oJourneyLog:nCondition == 1
	oJourneyLog:idMovD3X()
	oJourneyLog:setThreadId( Strzero(ThreadID(),15))
elseIF oJourneyLog:nCondition == 4 .or. oJourneyLog:nCondition == 2 
	oJourneyLog:idMovCV8()
EndIf

TCInternal(5,"*OFF")   // Desliga Refresh no Lock do Top

aRegraCP := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica o direito de acesso por parte do usuario                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Substr(cAcesso,18,1) # "S"
	Help ( " ", 1, "SEMPERM" )
	Return
EndIf

If !IsBlind()
	If FindFunction("MsgExpRot")
		cRelease := GetRPORelease()

		If cRelease >= "12.1.2210"
			lMsgBlock := .T.
		Else
			lMsgBlock := .F.
		EndIf

		MsgExpRot("MATA280",;
					OemToAnsi(STR0152),;
					"https://tdn.totvs.com/x/Nm7pJw",;
					"20221231",; //Data de expiração
					7,; //Pausa do aviso em dias
					"20230101",; //Data de bloqueio
					Nil,; //Informacao de TReport (nao utilizado nesta rotina)
					lMsgBlock) //Exibe ou nao texto informando que a rotina sera/foi bloqueada a partir da data de bloqueio

		If cRelease >= "12.1.2210" .And. DToS(Date()) >= "20230101"
			Return
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Preenche array com as regras do custo em partes.             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lMA330CP
	aRegraCP:=ExecBlock("MA330CP",.F.,.F.)
	If ValType(aRegraCP) # "A"
		aRegraCP:={}
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se os campos do custo em partes estao Ok            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aRegraCP) > 0
	lCstPart:=MA330AvlCp(aRegracp,{})
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Pega a data do Recalculo do custo medio, vinda do SX1 ou SX6 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SuperGetMv("MV_CMDBLQV",.F.,.F.) .and. !lCstOnLine
	If !Empty(aListaFil)
		dDataFec := SuperGetMV("MV_DBLQMOV",.F.,SToD(""),aListaFil[1][2])
	Else
		dDataFec := SuperGetMV("MV_DBLQMOV",.F.,SToD(""))
	EndIf
Else
	If ! lBat .OR. (lBat .AND. dDataFec == NIL)
		Pergunte("MTA330",.F.)
		dDataFec := mv_par01
	Endif	
	MTA280Perg(.F.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se foram passados dados como parametro para execucao³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ValType(cArq1) # "C"
	cArq1:=Space(5)
EndIf
If ValType(cArq2) # "C"
	cArq2:=Space(5)
EndIf
If ValType(cArq3) # "C"
	cArq3:=Space(5)
EndIf
If ValType(cArq4) # "C"
	cArq4:=Space(5)
EndIf
If ValType(cArq5) # "C"
	cArq5:=Space(5)
EndIf
If ValType(cArq6) # "C"
	cArq6:=Space(5)
EndIf
If ValType(cArq7) # "C"
	cArq7:=Space(5)
EndIf

If !lBat
	If Getmv("MV_CUSTEXC") == "N"
		cMens := OemToAnsi(STR0001)+chr(13) //"Esta rotina ser  executada em modo"
		cMens += OemToAnsi(STR0002)+chr(13) //"compartilhado , conforme indicado"
		cMens += OemToAnsi(STR0003)+chr(13) //"pelo parƒmetro MV_CUSTEXC."
		cMens += OemToAnsi(STR0004)+chr(13) //"As movimenta‡”es que ocorrerem durante"
		cMens += OemToAnsi(STR0005)+chr(13) //"o processo podem influir no c lculo."
		If !MsgYesNo(cMens,OemToAnsi(STR0006)) //"ATEN€O"
			Return
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica as perguntas selecionadas                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas para parametros                         ³
//³ mv_par01     // Gera copia dos dados                         ³
//³ mv_par02     // Gera Sld Inicial para MOD                    ³
//³ mv_par03     // Seleciona Filial                             ³
//³ mv_par04     // Atualiza saldo atual da MOD                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MTA280Perg(.F.)

If lBat 
	If lJourney
		aFilsCalc := aListaFil
	Else 
		aFilsCalc := MatFilCalc(mv_par03==1)
	Endif
EndIf
If !lBat
	If !lNewRelease
		If MTA280Perg(.T.)
			aFilsCalc := MatFilCalc(mv_par03==1)

			If !Empty(aFilsCalc)
				DEFINE MSDIALOG oDlg FROM  100,4 TO 430,630 TITLE OemToAnsi(STR0007) PIXEL    //"Fechamento do Per¡odo no Estoque"

				a280MontPanel(oDlg,"OLD",@dDataFec,@cArq1,@cArq2,@cArq3,@cArq4,@cArq5,@cArq6,@cArq7)

				DEFINE SBUTTON FROM 145, 240 TYPE 1 ACTION (nOpca := 1,IF(ma280OK(dDataFec,cArq1,cArq2,cArq3,cArq4,cArq5,cArq6,cArq7,!lBat),oDlg:End(),nOpca:=0)) ENABLE OF oDlg
				DEFINE SBUTTON FROM 145, 267 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg
				ACTIVATE MSDIALOG oDlg Center
			EndIf
		EndIf
	Else
		aAdd(aTreeProc,{OemToAnsi(STR0068),;
						{|oCenterPanel|a280MontPanel(oCenterPanel,"DATA",@dDataFec,@cArq1,@cArq2,@cArq3,@cArq4,@cArq5,@cArq6,@cArq7)},;
						"btcalend_ocean"})
		aAdd(aTreeProc,{OemToAnsi(STR0069),;
						{|oCenterPanel|a280MontPanel(oCenterPanel,"ARQS",@dDataFec,@cArq1,@cArq2,@cArq3,@cArq4,@cArq5,@cArq6,@cArq7)},;
						"papel_escrito"})

		oProcess := tNewProcess():New("MATA280",OemToAnsi(STR0070),bBlNewProc,OemToAnsi(STR0066)+_NEWLINE+OemToAnsi(STR0067),"MTA280",aTreeProc)
		lOpc := oProcess:LEND
		If lOpc
			nOpca := 1
		Else
			nOpca := 0
		EndIf
	EndIf
ElseIf MA280Ok(dDataFec,cArq1,cArq2,cArq3,cArq4,cArq5,cArq6,cArq7,!lBat)
	nOpca     := 1
	If lJourney
		aFilsCalc := aListaFil
	Else 
		aFilsCalc := MatFilCalc(.F., aListaFil,,,,,,lJourney)
	Endif
EndIf

If nOpca == 1 .AND. (!lNewRelease .OR. lBat)
	a280Run(@aProcsOk,lBat,dDataFec,cArq1,cArq2,cArq3,cArq4,cArq5,cArq6,cArq7)
EndIf

If len(aLogsGR) > 0
	cBackFil:=cFilant
	For nCont := 1 to len(aLogsGR)
		cFilAnt:=aLogsGR[nCont][1]

		A280Log(aLogsGR[nCont][2],aLogsGR[nCont][3],aLogsGR[nCont][4],,lBat)
	Next nCont
	cFilAnt:=cBackFil
EndIf

// Apresenta mensagens relacionadas
If Len(aProcsOk) > 0
	DEFINE MSDIALOG oDlgOcorr TITLE OemToAnsi(STR0062) From 8,05 To 20,65 OF oMainWnd	//"Log de processamento das STORED PROCEDURES"
	@ 1,001 LISTBOX oOcorr Fields HEADER Space(63) SIZE 190,70
	oOcorr:SetArray(aProcsOk)
	oOcorr:bLine := { || {aProcsOk[oOcorr:nAT]} }
	DEFINE SBUTTON FROM 18,202 TYPE 1 ACTION oDlgOcorr:End() ENABLE OF oDlgOcorr
	ACTIVATE MSDIALOG oDlgOcorr
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MA280Arq ³ Autor ³ Eveli Morasco         ³ Data ³ 05/03/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consiste o nome do arquivo informado                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MA280Arq(ExpC1)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo principal para formar o nome do   ³±±
±±³          ³         arquivo morto                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA280                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MA280Arq(cArq,cAlias)
Local lRetorna := .T.
cArq := cArq+cAlias+".AMT"
If mv_par01 == 1
	If " "$cArq
		Help(" ",1,"MA280ESP")
		lRetorna := .F.
	ElseIf File(cArq)
		Help(" ",1,"MA280ARQ")
		lRetorna := .F.
	ElseIf !(IsAlpha(cArq))
		Help(" ",1,"MA280PNU")
		lRetorna := .F.
	EndIf
EndIf
Return lRetorna

/*/{Protheus.doc} A280Data
	Valida se data informada é maior que MV_ULMES nas filiais
	@type  Function
	@author TOTVS
	@since 15/10/2020
	@version 1.0
	@param dDataFec, date, Data informada para fechamento
	@param lMostraHelp, logic, Indica se deve exibir help em tela.
/*/
Static Function A280Data(dDataFec,lMostraHelp)
Local lRet		:= .T.
Local nForFil	:= 0
Local cFilBack	:= cFilAnt

For nForFil := 1 To Len(aFilsCalc)
	If aFilsCalc[nForFil,1]
		cFilAnt:=aFilsCalc[nForFil,2]

		If dDataFec <= GetMv("MV_ULMES")
			If lMostraHelp
				Help(" ",1,"MA280DATA")
			EndIf
			M280PrcLog("MENSAGEM", STR0158, STR0159, "ER")
			lRet := .F.
			Exit
		EndIf
	EndIf
Next nForFil

cFilAnt := cFilBack

Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MATA280     ³ Autor ³Rogerio F. Guimaraes³ Data ³ 09.09.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ A Rotina padrao foi renomeada para xMA280Process p/ os ca- ³±±
±±³          ³ sos que utilizam banco de dados disparem uma Stored Proce- ³±±
±±³          ³ dure. Se a procedure nao existir a rotina padrao           ³±±
±±³          ³ xMA280Process sera executada.                              ³±±
±±³          ³ Motivo basico da alteracao e a Otimizacao e Performance    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Processa o Fechamento                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA280                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MA280Process(aProcsOk,lBat,dDataFec,cFilLogin,aArquivos,lEnd,oCenterPanel,lMultFil)

Local cMes
Local lArqExcl    := IIf(GetMV("MV_CUSTEXC")!="N",.T.,.F.) // Abertura de arq. exclusivos/compartilhados
Local lFatConv    := .F.
Local lBackConv   := .F.
Local lContinua   := .T.
Local lExistBlock := ExistBlock("MA280CON")
Local aRetPartes  := {}
Local _aSaldoUni  := {}
Local aLogs       :={{}}
Local nQuantIni   := 0
Local nQuantIni2  := 0
Local _nLoop1     := 0
Local _nLoop2     := 0
Local aValIni     :={0, 0, 0, 0, 0}
Local aResult     := {}
Local dDataMes    := GetMv("MV_ULMES") //Data do Ultimo Fechamento
Local lPIMSINT    := SuperGetMV("MV_PIMSINT",.F.,.F.) // Indica se Existe Integração Protheus x PIMS Graos
Local l300SalNeg  := GetMV("MV_MT300NG",.F.,.T.) // Indica se permite saldo negativo
Local lA280SB9    := ExistBlock("A280SB9")
Local cQuery      := ""
Local cIndice     := ""
Local cFilSCC     := ""
Local cFilSBD     := ""
Local cKey        := ""
Local cSeek       := ""
Local _cCampo     := ""
Local lCusFIFO    := SuperGetMv("MV_CUSFIFO",.F.,.F.)
Local lCusLIFO    := SuperGetMv( 'MV_CUSLIFO' ,.F.,.F.)
Local lCstOnLine  := AllTrim(SuperGetMv("MV_CUSMED",.F.,"M")) == "O"
Local lCusFil     := AllTrim(SuperGetMV( 'MV_CUSFIL' ,.F.,"A")) == "F"
Local lCusEmp     := AllTrim(SuperGetMv( 'MV_CUSFIL' ,.F.,"A")) == "E"
Local cNomeTab    := "0_SP"
Local cArqProd    := SuperGetMv("MV_ARQPROD",.F.,.F.)
Local aDataProc
Local cMoeda330C := SuperGetMv( 'MV_MOEDACM' ,.F.,"2345")
Local cSubRotina := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³MV_CUSREP - Parametro utilizado para habilitar o calculo do   ³
//³            Custo de Reposicao.                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lCusRep    := SuperGetMv("MV_CUSREP",.F.,.F.) .And. MA330AvRep()

//------------------
// Saldo inicial WMS
//------------------
Local lWmsNew    := SuperGetMv("MV_WMSNEW",.F.,.F.)
Local oMovEstEnd := Nil
Local lExecProc  := .F.

Private cSPMAT038  := GetSPName("MAT038","17")
Private cSPMAT038A := GetSPName("MAT038A","17")
Private cSPMAT038B := GetSPName("MAT038B","17")
Private cSPMAT039  := GetSPName("MAT039","17")

DEFAULT lMultFil := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If oCenterPanel <> NIL .And. !lBat
	oCenterPanel:SaveLog(STR0118) // "Inicio do processamento."
EndIf

If !lBat
	If oCenterPanel <> NIL
		oCenterPanel:SetRegua2(If(mv_par01==1,5,4))
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atraves do parametro MV_CUSTEXC, verifica se a abertura de   ³
//³ arquivos e' exclusiva ou compartilhada.                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lArqExcl
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Abre todos os arquivos de forma exclusiva                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ! (	MA280FLock("SB2") .And. MA280FLock("SB3") .And. MA280FLock("SC2") .And. ;
			MA280FLock("SF1") .And. MA280FLock("SD1") .And. MA280FLock("SF2") .And. ;
			MA280FLock("SD2") .And. MA280FLock("SD3") .And. MA280FLock("SB9") .And. ;
			MA280FLock("SBD") )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Fecha todos os arquivos e reabre-os de forma compartilhada   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbCloseAll()
		OpenFile(SubStr(cNumEmp,1,2))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If oCenterPanel <> NIL .And. !lBat
			oCenterPanel:SaveLog(STR0078) //"Erro na abertura exclusiva das tabelas."
		EndIf
		Return .T.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Abre indices dos arquivos que foram abertos de forma exclusivo ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	OpenIndx("SB2")
	OpenIndx("SB3")
	OpenIndx("SBD")
	OpenIndx("SC2")
	OpenIndx("SF1")
	OpenIndx("SD1")
	OpenIndx("SF2")
	OpenIndx("SD2")
	OpenIndx("SD3")
	OpenIndx("SB9")
EndIf

If lJourney .And. oJourneyLog:processHasStarted(oJourneyLog:cIdParent, oJourneyLog:cIdChild, 'MATA280', cFilStart)
	oJourneyLog:attStatus('PROCESSING', .T.)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
M280PrcLog("INICIO")
M280PrcLog("AMBIENTE")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica atraves do parametro se zera demandas.              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If GetMV("MV_ZERADEM") == "S"
	cMes:=StrZero(Month(dDataFec)+1,2)
	cMes:=IIF(cMes>"12","01",cMes)

	//inserir codigo especifico
	If ExistProc( cSPMAT039, VerIDProc() )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento			    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		M280PrcLog("MENSAGEM",STR0087+" - "+STR0063+" "+cFilAnt,STR0087+" - "+STR0063+" "+cFilAnt, '2') //"Stored Procedures: Iniciando processo para zerar demandas"

	   FWMsgRun(, {|| MA280SP2(cFilAnt, cMes, @aResult ) }, OemToAnsi(STR0119+" "+ STR0063+": "+cFilAnt) , OemToAnsi(STR0063)) // "Processando"

		If !lBat
			If Empty(aResult)
				AADD(aProcsOk,STR0042+" - "+STR0063+" "+cFilAnt) //'Erro na chamada do processo para zerar as demandas'
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If oCenterPanel <> NIL .And. !lBat
					oCenterPanel:SaveLog("STORED PROCEDURE MESSAGE: "+STR0042+" - "+STR0063+" "+cFilAnt)
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				M280PrcLog("ERRO",STR0042+" - "+STR0063+" "+cFilAnt,STR0042+" - "+STR0063+" "+cFilAnt,'ER') //"Erro na chamada do processo para zerar as demandas"

				lContinua := .F.
			ElseIf aResult[1] == "01" .or. aResult[1] == "1"
				AADD(aProcsOk,STR0043+" - "+STR0063+" "+cFilAnt) //'Zerar as demandas OK'
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If oCenterPanel <> NIL .And. !lBat
					oCenterPanel:SaveLog("STORED PROCEDURE MESSAGE: "+STR0043+" - "+STR0063+" "+cFilAnt)
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				M280PrcLog("MENSAGEM",STR0043+" - "+STR0063+" "+cFilAnt,STR0043+" - "+STR0063+" "+cFilAnt, '3') //"Zerar as demandas OK"
			Else
				AADD(aProcsOk,STR0044+" - "+STR0063+" "+cFilAnt) //'Zerar as demandas com Erro'
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If oCenterPanel <> NIL .And. !lBat
					oCenterPanel:SaveLog("STORED PROCEDURE MESSAGE: "+STR0044+" - "+STR0063+" "+cFilAnt)
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				M280PrcLog("ERRO",STR0044+" - "+STR0063+" "+cFilAnt,STR0044+" - "+STR0063+" "+cFilAnt,'ER') //"Zerar as demandas com Erro"
				lContinua := .F.
			EndIf
		Else 
			If Empty(aResult)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				M280PrcLog("ERRO",STR0042+" - "+STR0063+" "+cFilAnt,STR0042+" - "+STR0063+" "+cFilAnt,'ER') //"Erro na chamada do processo para zerar as demandas"

				lContinua := .F.
			ElseIf aResult[1] == "01" .or. aResult[1] == "1"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				M280PrcLog("MENSAGEM",STR0043+" - "+STR0063+" "+cFilAnt,STR0043+" - "+STR0063+" "+cFilAnt, '3') //"Zerar as demandas OK"
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				M280PrcLog("ERRO",STR0044+" - "+STR0063+" "+cFilAnt,STR0044+" - "+STR0063+" "+cFilAnt,'ER') //"Zerar as demandas com Erro"
				lContinua := .F.
			EndIf
		EndIf
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento			    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		M280PrcLog("MENSAGEM",STR0088,STR0088, '2') //"Iniciando processo para zerar demandas"
		cMes:="B3_Q"+cMes
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Zera o arquivo de consumos antes de recalcular               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SB3")
		dbSeek( xFilial("SB3") )
		If oCenterPanel <> NIL .And. !lBat
			oCenterPanel:SetRegua1(SB3->(LastRec()))
		EndIf
		While !EOF() .And. B3_FILIAL == xFilial("SB3")
			RecLock("SB3",.F.) // Tentar Ver Replace All para TOPCONN
			Replace &(cMes) With 0
			MsUnlock()
			dbSkip()
			If oCenterPanel <> NIL .And. !lBat
				oCenterPanel:IncRegua1(OemToAnsi(STR0071))
			EndIf
		EndDo
		If oCenterPanel <> NIL .And. !lBat
			oCenterPanel:IncRegua2()
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento			    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		M280PrcLog("MENSAGEM",STR0043+" - "+STR0063+" "+cFilAnt,STR0043+" - "+STR0063+" "+cFilAnt, '3') //"Zerar as demandas OK"
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tabela TRC - Utilizada para armazenar as divergencias encontradas³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistProc(cSPMAT038, VerIDProc()) .And. TCCanOpen( "TRC"+SM0->M0_CODIGO+cNomeTab )
	lExecProc := .T.
	cSubRotina := "PROCEDURE"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento			    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	M280PrcLog("MENSAGEM",STR0089+" - "+STR0063+" "+cFilAnt,STR0089+" - "+STR0063+" "+cFilAnt, '4A') //"Stored Procedures: Iniciando Virada de Saldos"

	//-- Executar Procedure
   FWMsgRun(, {|| A280InsTRB(cFilLogin,cFilAnt,dDataMes,dDataFec) }, OemToAnsi(STR0119+" "+ STR0063+": "+cFilAnt), OemToAnsi(STR0120) ) //"Processando" ## "Selecionando os produtos..."

	//-- Limpar arquivo de Logs
	TcSqlExec( "DELETE FROM "+"TRC"+SM0->M0_CODIGO+cNomeTab+" WHERE TRC_FILIAL = '"+cFilAnt + "' and D_E_L_E_T_  = ' '")

	cMoeda330C := SuperGetMv('MV_MOEDACM',.F.,"2345")

	aDataProc := Array(3)
	aDataProc[1] := {	cFilLogin,;													// 01. Codigo da Filial Logada
							cFilAnt,;													// 02. Codigo da Filial a ser processada
							DTOS(dDataFec),;											// 03. Data de Fechamento
							GetMV("MV_RASTRO"),;										// 04. Rastreabilidade Ativada
							Dtos(dDataMes),;											// 05. Data do ultimo fechamento
							mv_par02,;													// 06. Gera Sld Inicial para MOD
							GetMV("MV_CUSZERO"),;									// 07. Zerar Custo
							If( l300SalNeg, '1', '0' ),;							// 08. Permite saldo negativo
							cMoeda330C,;												// 09. Moedas a serem processadas
							If( lCstOnLine, '1', '0' ),;							// 10. Verifica se devera utilizar o custo ON-LINE.
							If( lCusFil   , '1', '0' ),;							// 11. Verifica se o sistema utiliza o custo unificado por Filial
							If( lCusEmp   , '1', '0' ),;							// 12. Verifica se o sistema utiliza o custo unificado por Empresa
						   mv_par04,;													// 13. Atualiza saldo atual da MOD
							A330FilNum(cFilAnt),;									// 14. FILSEQ - A330FilNum()
							IIF(lWmsNew,'1','0'),;									// 15. Utiliza ou não WMS
							IIF(SuperGetMV("MV_PRODMOD",.F.,.T.),'1','0'),;	// 16. Utiliza o campo B1_CCCUSTO
							cArqProd;													// 17. Verifica se o sistema utiliza controle por SB1 ou SBZ
						}

	aDataProc[2] := {	cFilAnt,;													// 01. Codigo da Filial a ser processada
							DTOS(dDataFec),;											// 02. Data de Fechamento
							If(lCusFIFO .Or. lCusLIFO,'1','0'),;				// 03. Utiliza custo Fifo/Lifo
							cMoeda330C,;												// 04. Moedas a serem processadas
							'1';														// 05. Fechamento FIFO
					}

	aDataProc[3] := {	cFilAnt,;													// 01. Codigo da Filial a ser processada
							Dtos(dDataMes);											// 02. Data do ultimo fechamento
					}

	//-- Executar Procedure
   FWMsgRun(, {|oMsgRunSay| MA280SP1( oMsgRunSay, aDataProc, @aResult ) }, OemToAnsi(STR0119+" "+ STR0063+": "+cFilAnt) , OemToAnsi(STR0090) ) // "Processando" ## "Iniciando Virada de Saldos"

	If !lBat
		If Empty(aResult)
			AADD(aProcsOk,STR0045+" - "+STR0063+" "+cFilAnt) //'Erro na virada de saldos'
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento			    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If oCenterPanel <> NIL
				oCenterPanel:SaveLog("STORED PROCEDURE MESSAGE: "+STR0045+" - "+STR0063+" "+cFilAnt)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento			    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			M280PrcLog("ERRO",STR0045+" - "+STR0063+" "+cFilAnt,STR0045+" - "+STR0063+" "+cFilAnt, 'ER') //'Erro na virada de saldos'
			lContinua := .F.
		ElseIf aResult[1] == "01" .or. aResult[1] == "1"
			//Seleciona SB9 com saldo zerado para criar SCC
			If lCusFIFO .Or. lCusLIFO
				SldZeroSB9(dDataFec)
			EndIf

			AADD(aProcsOk,STR0046+" - "+STR0063+" "+cFilAnt) //'Virada de saldos OK'
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento			    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If oCenterPanel <> NIL
				oCenterPanel:SaveLog("STORED PROCEDURE MESSAGE: "+STR0046+" - "+STR0063+" "+cFilAnt)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento			    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			M280PrcLog("MENSAGEM",STR0046+" - "+STR0063+" "+cFilAnt,STR0046+" - "+STR0063+" "+cFilAnt, '4G') //'Virada de saldos OK'
			DbSelectArea("SX2")
			Set Filter to
			DbSetOrder(1)
			DbSeek("SB9")
			TcRefresh(RetSqlName("SB9"))
			dbSelectArea("SB9")
		Else
			AADD(aProcsOk,STR0047+" - "+STR0063+" "+cFilAnt) //'Virada de saldos com Erro'
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento			    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If oCenterPanel <> NIL
				oCenterPanel:SaveLog("STORED PROCEDURE MESSAGE: "+STR0047+" - "+STR0063+" "+cFilAnt)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento			    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			M280PrcLog("ERRO",STR0047+" - "+STR0063+" "+cFilAnt,STR0047+" - "+STR0063+" "+cFilAnt, 'ER') //'Virada de saldos com Erro'
			lContinua := .F.
		EndIf
	EndIf

	M280PrcLog("MENSAGEM",OemToAnsi(I18N("Stored Procedures: " +STR0110 ,{cFilAnt})),OemToAnsi(I18N("Stored Procedures: " +STR0110 ,{cFilAnt})), '5') //"Termino da Virada de Saldos na Filial #1[D MG 01]#" ## "Termino da Virada de Saldos na Filial #1[D MG 01]#"
	M280PrcLog("MENSAGEM",OemToAnsi(I18N(STR0111,{cFilAnt})),OemToAnsi(I18N(STR0111,{cFilAnt}))) //"Processando as divergencias encontradas na tabela TRC na Filial #1[D MG 01]#" ## "Processando as divergencias encontradas na tabela TRC na Filial #1[D MG 01]#"

	//Arquivo de trabalho com divergencias encontradas na TABELA TRC
	cQuery := "SELECT TRC_COD, TRC_LOCAL, TRC_ALIAS, TRC_QFIM, TRC_DIVERG from "+"TRC"+SM0->M0_CODIGO+cNomeTab+" WHERE TRC_FILIAL = '"+cFilAnt + "' and D_E_L_E_T_  = ' '"
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRCSP", .F., .T.)

	aTam:= TamSX3("B2_QFIM")
	TcSetField( "TRCSP", "TRC_QFIM"	,"N", aTam[1],aTam[2] )
	TcSetField( "TRCSP", "TRC_DIVERG"	,"N", aTam[1],aTam[2] )
	TRCSP->(dbGoTop())
	Do While !TRCSP->( Eof() )
		If !(QtdComp(TRCSP->TRC_QFIM)==QtdComp(TRCSP->TRC_DIVERG))
			If Len(aLogs[Len(aLogs)]) > 4095
				aAdd(aLogs, {})
			EndIf
			aAdd(aLogs[Len(aLogs)], { TRCSP->TRC_ALIAS	,;
										TRCSP->TRC_COD	,;
										TRCSP->TRC_LOCAL	,;
										TRCSP->TRC_QFIM	,;
										TRCSP->TRC_DIVERG})
		EndIf
		TRCSP->( dbSkip() )
	EndDo
	TRCSP->( dbCloseArea() )
	M280PrcLog("MENSAGEM",OemToAnsi(I18N(STR0112,{cFilAnt})),OemToAnsi(I18N(STR0112,{cFilAnt}))) //"Finalizado processo das divergencias encontradas na tabela TRC na Filial #1[D MG 01]#" ## "Finalizado processo das divergencias encontradas na tabela TRC na Filial #1[D MG 01]#"

Else
	cSubRotina := "ADVPL"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento			    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	M280PrcLog("MENSAGEM",STR0090+" - "+STR0063+" "+cFilAnt,STR0090+" - "+STR0063+" "+cFilAnt, '4A') //"Iniciando Virada de Saldos"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza Saldos                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSeek( xFilial("SB2") )
	If oCenterPanel <> NIL .And. !lBat
		oCenterPanel:SetRegua1(SB2->(LastRec()))
	EndIf

	While !EOF() .And. B2_FILIAL == xFilial("SB2")
		If IsProdMod(B2_COD) .And. mv_par04 == 1
			RecLock("SB2",.F.)
			Replace B2_QATU  With B2_QATU  - B2_QFIM
			Replace B2_QFIM  With 0
			Replace B2_VATU1 With Abs(B2_QATU*B2_CM1)
			Replace B2_VFIM1 With 0
			Replace B2_VATU2 With If("2" $ cMoeda330C,Abs(B2_QATU*B2_CM2),0)
			Replace B2_VFIM2 With 0
			Replace B2_VATU3 With If("3" $ cMoeda330C,Abs(B2_QATU*B2_CM3),0)
			Replace B2_VFIM3 With 0
			Replace B2_VATU4 With If("4" $ cMoeda330C,Abs(B2_QATU*B2_CM4),0)
			Replace B2_VFIM4 With 0
			Replace B2_VATU5 With If("5" $ cMoeda330C,Abs(B2_QATU*B2_CM5),0)
			Replace B2_VFIM5 With 0
			MsUnlock()
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza o custo unificado ON-LINE                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			B2AtuUnif(SB2->B2_COD)
		EndIf
		If !IsProdMod(B2_COD) .Or. mv_par02 == 1
			dbSelectArea("SB1")
			dbSeek(xFilial("SB1")+SB2->B2_COD+SB2->B2_LOCAL)
			dbSelectArea("SB9")
			dbSeek( xFilial("SB9")+SB2->B2_COD+SB2->B2_LOCAL+DTOS(dDataFec) )
			If !Found()
				RecLock("SB9",.T.)
				Replace B9_FILIAL With xFilial("SB9")
				Replace B9_COD With SB2->B2_COD
				Replace B9_LOCAL With SB2->B2_LOCAL
				Replace B9_DATA With dDataFec
				Replace B9_CUSTD With RetFldProd(SB1->B1_COD,"B1_CUSTD")
				Replace B9_MCUSTD With RetFldProd(SB1->B1_COD,"B1_MCUSTD")
			Else
				RecLock("SB9",.F.)
			EndIf
			lFatConv :=SB1->(dbSeek(xFilial("SB1")+SB2->B2_COD)) .And. !Empty(SB1->B1_SEGUM)
			lBackConv:=lFatConv
			//	Executa P.E. para verificar se deve usar fator de conversao ou nao
			If lExistBlock
				lFatConv:=ExecBlock("MA280CON",.F.,.F.,{SB1->B1_COD,lFatConv})
				If Valtype(lFatConv) != "L"
					lFatConv:=lBackConv
				EndIf
			EndIf
			// Protecao para evitar divergencia entre saldo por lote/endereco e saldo em estoque
			If (Rastro(SB2->B2_COD) .Or. Localiza(SB2->B2_COD)) .And. QtdComp(SB2->B2_QFIM) < QtdComp(0) .And. !l300SalNeg
				nQuantIni :=0
				nQuantIni2:=0
				aValIni   :={0,0,0,0,0}
			Else
				nQuantIni :=SB2->B2_QFIM
				nQuantIni2:= iif(nQuantIni > 0, SB2->B2_QFIM2, 0)
				aValIni   :={SB2->B2_VFIM1,SB2->B2_VFIM2,SB2->B2_VFIM3,SB2->B2_VFIM4,SB2->B2_VFIM5}
			EndIf
			Replace	B9_QINI    With nQuantIni
			Replace B9_QISEGUM With If(lFatConv,ConvUm(SB1->B1_COD,nQuantIni,nQuantIni2,2),nQuantIni2)
			Replace	B9_VINI1   With aValIni[1]
			Replace B9_VINI2   With If("2" $ cMoeda330C,aValIni[2],0)
			Replace B9_VINI3   With If("3" $ cMoeda330C,aValIni[3],0)
			Replace B9_VINI4   With If("4" $ cMoeda330C,aValIni[4],0)
			Replace B9_VINI5   With If("5" $ cMoeda330C,aValIni[5],0)
			Replace B9_DATA    With dDataFec
			Replace B9_VINIFF1 With SB2->B2_VFIMFF1
			Replace B9_VINIFF2 With If("2" $ cMoeda330C,SB2->B2_VFIMFF2,0)
			Replace B9_VINIFF3 With If("3" $ cMoeda330C,SB2->B2_VFIMFF3,0)
			Replace B9_VINIFF4 With If("4" $ cMoeda330C,SB2->B2_VFIMFF4,0)
			Replace B9_VINIFF5 With If("5" $ cMoeda330C,SB2->B2_VFIMFF5,0)
			Replace B9_CUSTD   With RetFldProd(SB1->B1_COD,"B1_CUSTD")
			Replace B9_MCUSTD  With RetFldProd(SB1->B1_COD,"B1_MCUSTD")
			Replace B9_CM1 With SB2->B2_CMFIM1
			Replace B9_CM2 With SB2->B2_CMFIM2
			Replace B9_CM3 With SB2->B2_CMFIM3
			Replace B9_CM4 With SB2->B2_CMFIM4
			Replace B9_CM5 With SB2->B2_CMFIM5
			If lCusRep
				Replace B9_CMRP1 With SB2->B2_CMRP1
				Replace B9_CMRP2 With If("2" $ cMoeda330C,SB2->B2_CMRP2,0)
				Replace B9_CMRP3 With If("3" $ cMoeda330C,SB2->B2_CMRP3,0)
				Replace B9_CMRP4 With If("4" $ cMoeda330C,SB2->B2_CMRP4,0)
				Replace B9_CMRP5 With If("5" $ cMoeda330C,SB2->B2_CMRP5,0)
				Replace B9_VINIRP1 With SB2->B2_VFRP1
				Replace B9_VINIRP2 With If("2" $ cMoeda330C,SB2->B2_VFRP2,0)
				Replace B9_VINIRP3 With If("3" $ cMoeda330C,SB2->B2_VFRP3,0)
				Replace B9_VINIRP4 With If("4" $ cMoeda330C,SB2->B2_VFRP4,0)
				Replace B9_VINIRP5 With If("5" $ cMoeda330C,SB2->B2_VFRP5,0)
			EndIf
			MsUnlock()

			If lCstPart
				dbSelectArea("SB2")
				aRetPartes:=PegaCMPFim("B2_CPF",lCstPart,Len(aRegraCP)+1,SB9->B9_QINI,NIL,aRegraCP)
				dbSelectArea("SB9")
				GravaCusCP(lCstPart,NIL,NIL,"SB9",SB2->B2_COD,aRetPartes,SB9->B9_QINI,"B9_CP",{B9_VINI1,B9_VINI2,B9_VINI3,B9_VINI4,B9_VINI5})
				_aSaldoUni:={}
				dbSelectArea("SB2")
				_cCampo:="B2_CP"
				// Calculo do custo medio historico em partes
				For _nLoop1:=1 to Len(aRegraCP)+1
					AADD(_aSaldoUni,ARRAY(5))
					For _nLoop2:=1 to 5
						// Verifica se moeda devera ser considerada
						If _nLoop2 # 1 .And. !(Str(_nLoop2,1,0) $ cMoeda330C)
							Loop
						EndIf
						_cCampo1:=_cCampo+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
						_aSaldoUni[_nLoop1,_nLoop2]:=FIELDGET(FieldPos(_cCampo1))
					Next _nLoop2
				Next _nLoop1
				// Gravacao do custo medio historio em partes
				dbSelectArea("SB9")
				Reclock("SB9",.F.)
				_cCampo:="B9_CPM"
				For _nLoop1:=1 to Len(aRegraCP)+1
					For _nLoop2:=1 to 5
						// Verifica se moeda devera ser considerada
						If _nLoop2 # 1 .And. !(Str(_nLoop2,1,0) $ cMoeda330C)
							Loop
						EndIf
						dbSelectArea("SB9")
						_cCampo:="B9_CPM"+Strzero(_nLoop1,2,0)+Strzero(_nLoop2,2,0)
						FIELDPUT(FieldPos(_cCampo),_aSaldoUni[_nLoop1,_nLoop2])
					Next _nLoop2
				Next _nLoop1
				MsUnlock()
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de Entrada para atualizacao do SB9.                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lA280SB9
				ExecBlock("A280SB9",.F.,.F.)
			EndIf

			BJAtuComB2(dDataFec, lFatConv,aLogs)
			BKAtuComB2(dDataFec, lFatConv,aLogs)
		EndIf

		dbSelectArea("SB2")
		dbSkip()
		If !lBat
			If oCenterPanel <> NIL
				oCenterPanel:IncRegua1(OemToAnsi(STR0072))
			Else
				IncProc()
			EndIf
		EndIf
	End
	If oCenterPanel <> NIL .And. !lBat
		oCenterPanel:IncRegua2()
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Processa Saldo Inicial para Lotes do custo FIFO/LIFO         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lCusFIFO .Or. lCusLIFO

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza Saldos Iniciais Fifo / Lifo                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SCC")
			cIndice := CriaTrab("",.F.)
			dbSelectArea("SCC")
			cFilSCC := 'CC_FILIAL == "'+xFilial("SCC")+'" .And. CC_STATUS == "A"'
			cKey    := 'CC_FILIAL+Dtos(CC_DATA)'
			IndRegua("SCC",cIndice,cKey,,cFilSCC,STR0050)
			nIndex := RetIndex("SCC")

			dbSetOrder(nIndex+1)
			dbGotop()
			While !Eof()
				RecLock("SCC",.F.)
				Replace CC_STATUS With "E"
				MsUnlock()
				dbSkip()
			End

			RetIndex("SCC")
			dbClearFilter()
			Ferase(cIndice+OrdBagExt())

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gera Saldos Iniciais Fifo/Lifo Baseado nos Lotes em aberto.  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SBD")
			cIndice := CriaTrab("",.F.)
			dbSelectArea("SBD")
			cFilSBD := 'BD_FILIAL == "'+xFilial("SBD")+'" .And. BD_STATUS <> "Z"'
			cKey    := 'BD_FILIAL+BD_STATUS'
			IndRegua("SBD",cIndice,cKey,,cFilSBD,STR0050)
			nIndex := RetIndex("SBD")
			dbSetOrder(nIndex+1)
			dbGoTop()
			While !Eof()
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//| Ajusta a quantidade do campo D8_QFIMDEV                       |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea("SD8")
				dbSetOrder(1) //D8_FILIAL+D8_PRODUTO+D8_LOCAL+D8_SEQ
				dbSeek(cSeek := xFilial("SD8")+SBD->(BD_PRODUTO+BD_LOCAL+BD_SEQ))
				Do While !Eof() .And. cSeek == xFilial("SD8")+D8_PRODUTO+D8_LOCAL+D8_SEQ
					If QtdComp(D8_QFIMDEV) > QtdComp(0) .And. D8_TM > "500" .And. !Empty(D8_ITEM)
						RecLock("SD8",.F.)
						Replace D8_QFIMDEV With 0
					EndIf
					dbSkip()
				EndDo

				RecLock("SCC",.T.)
				Replace CC_FILIAL  With xFilial("SCC")
				Replace CC_PRODUTO With SBD->BD_PRODUTO
				Replace CC_LOCAL   With SBD->BD_LOCAL
				Replace CC_DATA    With dDataFec
				Replace CC_QINI    With SBD->BD_QINI
				Replace CC_QINI2UM With SBD->BD_QINI2UM
				Replace CC_VINIFF1 With SBD->BD_CUSINI1
				Replace CC_VINIFF2 With If("2" $ cMoeda330C,SBD->BD_CUSINI2,0)
				Replace CC_VINIFF3 With If("3" $ cMoeda330C,SBD->BD_CUSINI3,0)
				Replace CC_VINIFF4 With If("4" $ cMoeda330C,SBD->BD_CUSINI4,0)
				Replace CC_VINIFF5 With If("5" $ cMoeda330C,SBD->BD_CUSINI5,0)
				Replace CC_QFIM    With SBD->BD_QFIM
				Replace CC_QFIM2UM With SBD->BD_QFIM2UM
				Replace CC_VFIMFF1 With SBD->BD_CUSFIM1
				Replace CC_VFIMFF2 With If("2" $ cMoeda330C,SBD->BD_CUSFIM2,0)
				Replace CC_VFIMFF3 With If("3" $ cMoeda330C,SBD->BD_CUSFIM3,0)
				Replace CC_VFIMFF4 With If("4" $ cMoeda330C,SBD->BD_CUSFIM4,0)
				Replace CC_VFIMFF5 With If("5" $ cMoeda330C,SBD->BD_CUSFIM5,0)
				Replace CC_DTORIG  With SBD->BD_DATA
				Replace CC_OP      With SBD->BD_OP
				Replace CC_SEQ     With SBD->BD_SEQ
				Replace CC_STATUS  With "A"
				MsUnlock()

				dbSelectArea("SBD")

				dbSkip()
			End

			//Seleciona SB9 com saldo zerado para gerar registros SCC 
			SldZeroSB9(dDataFec)

	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Transfere os saldos das OP's                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SC2")
	dbSeek(xFilial("SC2"))
	If oCenterPanel <> NIL .And. !lBat
		oCenterPanel:SetRegua1(SC2->(LastRec()))
	EndIF
	While !EOF() .And. C2_FILIAL == xFilial("SC2")
		RecLock("SC2",.F.)
		Replace C2_VINI1 With C2_VFIM1
		Replace C2_VINI2   With If("2" $ cMoeda330C,C2_VFIM2,0)
		Replace C2_VINI3   With If("3" $ cMoeda330C,C2_VFIM3,0)
		Replace C2_VINI4   With If("4" $ cMoeda330C,C2_VFIM4,0)
		Replace C2_VINI5   With If("5" $ cMoeda330C,C2_VFIM5,0)
		Replace C2_APRINI1 With C2_APRFIM1
		Replace C2_APRINI2 With If("2" $ cMoeda330C,C2_APRFIM2,0)
		Replace C2_APRINI3 With If("3" $ cMoeda330C,C2_APRFIM3,0)
		Replace C2_APRINI4 With If("4" $ cMoeda330C,C2_APRFIM4,0)
		Replace C2_APRINI5 With If("5" $ cMoeda330C,C2_APRFIM5,0)
		If (lCusFIFO .Or. lCusLIFO)
			Replace C2_VINIFF1 With C2_VFIMFF1
			Replace C2_VINIFF2 With If("2" $ cMoeda330C,C2_VFIMFF2,0)
			Replace C2_VINIFF3 With If("3" $ cMoeda330C,C2_VFIMFF3,0)
			Replace C2_VINIFF4 With If("4" $ cMoeda330C,C2_VFIMFF4,0)
			Replace C2_VINIFF5 With If("5" $ cMoeda330C,C2_VFIMFF5,0)
		EndIf		
		If lCusRep
			Replace C2_VINIRP1 With C2_VFIMRP1
			Replace C2_VINIRP2 With If("2" $ cMoeda330C,C2_VFIMRP2,0)
			Replace C2_VINIRP3 With If("3" $ cMoeda330C,C2_VFIMRP3,0)
			Replace C2_VINIRP4 With If("4" $ cMoeda330C,C2_VFIMRP4,0)
			Replace C2_VINIRP5 With If("5" $ cMoeda330C,C2_VFIMRP5,0)
			Replace C2_APRIRP1 With C2_APRFRP1
			Replace C2_APRIRP2 With If("2" $ cMoeda330C,C2_APRFRP2,0)
			Replace C2_APRIRP3 With If("2" $ cMoeda330C,C2_APRFRP3,0)
			Replace C2_APRIRP4 With If("2" $ cMoeda330C,C2_APRFRP4,0)
			Replace C2_APRIRP5 With If("2" $ cMoeda330C,C2_APRFRP5,0)
		EndIf
		MsUnlock()
		If lCstPart
			aRetPartes:=PegaCMPFim("C2_CPF",lCstPart,Len(aRegraCP)+1,1)
			GravaCusCP(lCstPart,NIL,NIL,"SC2",SC2->C2_PRODUTO,aRetPartes,1,"C2_CPI",{C2_VINI1,C2_VINI2,C2_VINI3,C2_VINI4,C2_VINI5})
			aRetPartes:=PegaCMPFim("C2_APF",lCstPart,Len(aRegraCP)+1,1)
			GravaCusCP(lCstPart,NIL,NIL,"SC2",SC2->C2_PRODUTO,aRetPartes,1,"C2_API",{C2_APRINI1,C2_APRINI2,C2_APRINI3,C2_APRINI4,C2_APRINI5})
		EndIf
		dbSkip()
		If !lBat
			If oCenterPanel <> NIL
				oCenterPanel:IncRegua1(OemToAnsi(STR0073))
			Else
				IncProc()
			EndIf
		EndIf
	EndDo
	If oCenterPanel <> NIL .And. !lBat
		oCenterPanel:IncRegua2()
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Transfere os saldos das Tarefas - SIGAPMS                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ! __lPyme
		dbSelectArea("AF9")
		dbSeek(xFilial("AF9"))
		If oCenterPanel <> NIL .And. !lBat
			oCenterPanel:SetRegua1(AF9->(LastRec()))
		EndIf
		While !EOF() .And. AF9_FILIAL == xFilial("AF9")
			RecLock("AF9",.F.)
			Replace AF9_VINI1   With AF9_VFIM1
			Replace AF9_VINI2   With If("2" $ cMoeda330C,AF9_VFIM2,0)
			Replace AF9_VINI3   With If("3" $ cMoeda330C,AF9_VFIM3,0)
			Replace AF9_VINI4   With If("4" $ cMoeda330C,AF9_VFIM4,0)
			Replace AF9_VINI5   With If("5" $ cMoeda330C,AF9_VFIM5,0)
			MsUnlock()
			dbSkip()
			If !lBat
				If oCenterPanel <> NIL
					oCenterPanel:IncRegua1(OemToAnsi(STR0074))
				Else
					IncProc()
				EndIf
			EndIf
		EndDo
		If oCenterPanel <> NIL .And. !lBat
			oCenterPanel:IncRegua2()
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento			    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	M280PrcLog("MENSAGEM",STR0091+" - "+STR0063+" "+cFilAnt,STR0091+" - "+STR0063+" "+cFilAnt, '5') //"Termino do processo de Virada de Saldos"
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
// Telemetria - Uso da classe FwCustomMetrics                   //
// Metrica - setAverageMetric                                   //
// Grava se utiliza ou nao stored procedure para o processamento//
// da virada dos saldos.                                        //
//?ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
If FWLibVersion() >= "20210628"
	FWCustomMetrics():setAverageMetric(	cSubRotina/*cSubRoutine*/,;
										"estoque/custos-protheus_fechamento-de-estoque-stored-procedures_count" /*cIdMetric*/,;
										1 /*nValue*/,;
										/*dDateSend*/,;
										/*nLapTime*/,;
										"MATA280"/*cRotina*/)
EndIf

If lContinua .And. !lExecProc
	//-------------------------------------------------------------------
	// Realisa a atualização na tabela D15 (Saldos Iniciais Endereço WMS)
	// A operação é realizada fora do Loop de Produtos da SB2, pois quando
	// o produto possui estrutura, é preciso considerar o filho e não o pai.
	// Portanto, WmsFechto realiza a leitura de todos os produtos de uma vez.
	//-------------------------------------------------------------------
	If IntDL() .And. lWmsNew
		oMovEstEnd := WMSDTCMovimentosEstoqueEndereco():New()
		oMovEstEnd:SetUlMes(dDataMes)
		oMovEstEnd:SetDatFech(dDataFec)
		oMovEstEnd:WmsFechto()
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gera Copia dos Dados                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lContinua
	M280Copia(aArquivos,lArqExcl,lEnd,dDataFec,aLogs,oCenterPanel,lBat,lMultFil)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If oCenterPanel <> NIL .And. !lBat
	oCenterPanel:SaveLog(STR0077) // "Fim Processamento"
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Integracao PIMS GRAOS    									    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lPIMSINT
	M280PrcLog("MENSAGEM",OemToAnsi(I18N(STR0113,{cFilAnt})),OemToAnsi(I18N(STR0113,{cFilAnt})), '7A') //"Iniciando a integração com PIMS GRAOS na Filial #1[D MG 01]#" ## "Iniciando a integração com PIMS GRAOS na Filial #1[D MG 01]#"
	PIMSItCost(dDataFec,dDataMes)
	M280PrcLog("MENSAGEM",OemToAnsi(I18N(STR0114,{cFilAnt})),OemToAnsi(I18N(STR0114,{cFilAnt})), '7B') //"Termino da integração com PIMS GRAOS na Filial #1[D MG 01]#" ## "Termino da integração com PIMS GRAOS na Filial #1[D MG 01]#"
EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	// Telemetria - Uso da classe FwCustomMetrics                     //
	// Metrica - setAverageMetric                                     //
	// Grava se utiliza ou nao Controle de Custos: On-line ou Off-Line//
	//?ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	If FWLibVersion() >= "20210628"
		If lCstOnLine
			cSubRotina := "On-line"	
		Else
			cSubRotina := "Off-line"
		EndIf
		FWCustomMetrics():setAverageMetric(	cSubRotina/*cSubRoutine*/,;
											"estoque/custos-protheus_controle-de-custos-_info" /*cIdMetric*/,;
											1 /*nValue*/,;
											/*dDateSend*/,;
											/*nLapTime*/,;
											"MATA280"/*cRotina*/)
	EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o log de processamento   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
M280PrcLog("FIM")

Return Nil

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³M280Copia    ³ Autor ³Rogerio F. Guimaraes³ Data ³ 09.09.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera Copia dos Dados                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA280                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function M280Copia(aArquivos,lArqExcl,lEnd,dDataFec,aLogs,oCenterPanel,lBat,lMultFil)

Local dData		:= GetMV("MV_ULMES")
Local nStatus	:= 0
Local	cArq1
Local	cArq2
Local	cArq3
Local	cArq4
Local	cArq5
Local	cArq6
Local	cArq7

Default lBat := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica parametro se gera copia dos dados               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If mv_par01 == 1

	M280PrcLog("MENSAGEM",OemToAnsi(I18N(STR0115,{cFilAnt})) ,OemToAnsi(I18N(STR0115,{cFilAnt})) ) // "Iniciando copia de dados da Filial #1[D MG 01]#" ## "Iniciando copia de dados da Filial #1[D MG 01]#"

	cArq1 := aArquivos[1]
	cArq2 := aArquivos[2]
	cArq3 := aArquivos[3]
	cArq4 := aArquivos[4]
	cArq5 := aArquivos[5]
	cArq6 := aArquivos[6]
	cArq7 := aArquivos[7]

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Processa depuracao dos arquivos                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If oCenterPanel <> NIL .And. !lBat
		oCenterPanel:SetRegua1(7)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Copia registros do SC2 para arquivo morto                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	dbSelectArea("SC2")
	dbSeek(xFilial("SC2"))
	cArq6 += "SC2AMT"
	If lMultFil
		nStatus := TCSqlExec("insert into "+cArq6+" SELECT * FROM "+RetSqlName("SC2")+" WHERE C2_FILIAL = '"+xFilial("SC2")+"' AND C2_EMISSAO <= '"+DTOS(dDataFec)+"' ")
	Else
		Copy To &(cArq6) While C2_FILIAL == xFilial("SC2") For C2_EMISSAO <= dDataFec VIA "TOPCONN"
	Endif
	If oCenterPanel <> NIL .And. !lBat
		oCenterPanel:IncRegua1(OemToAnsi(STR0075))
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Copia registros do AF9 para arquivo morto                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ! __lPyme
		dbSelectArea("AF9")
		dbSeek(xFilial("AF9"))
		cArq7 += "AF9AMT"
		If lMultFil
			nStatus := TCSqlExec("insert into "+cArq7+" SELECT * FROM "+RetSqlName("AF9")+" WHERE AF9_FILIAL = '"+xFilial("AF9")+"' AND AF9_START <= '"+DTOS(dDataFec)+"' ")
		Else
			Copy To &(cArq7) While AF9_FILIAL == xFilial("AF9") For AF9_START <= dDataFec VIA "TOPCONN"
		Endif
	EndIf
	If oCenterPanel <> NIL .And. !lBat
		oCenterPanel:IncRegua1(OemToAnsi(STR0075))
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Copia registros do SF1 para arquivo morto                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SF1")
	dbSeek(xFilial("SF1"))
	cArq1 += "SF1AMT"
	If lMultFil
		nStatus := TCSqlExec("insert into "+cArq1+" SELECT * FROM "+RetSqlName("SF1")+" WHERE F1_FILIAL = '"+xFilial("SF1")+"' AND F1_DTDIGIT <= '"+DTOS(dDataFec)+"' ")
	Else
		Copy To &(cArq1) While F1_FILIAL == xFilial("SF1") For F1_DTDIGIT <= dDataFec VIA "TOPCONN"
	Endif
	If oCenterPanel <> NIL .And. !lBat
		oCenterPanel:IncRegua1(OemToAnsi(STR0075))
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Copia registros do SD1 para arquivo morto                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SD1")
	dbSeek(xFilial("SD1"))
	cArq2 += "SD1AMT"
	If lMultFil
		nStatus := TCSqlExec("insert into "+cArq2+" SELECT * FROM "+RetSqlName("SD1")+" WHERE D1_FILIAL = '"+xFilial("SF1")+"' AND D1_DTDIGIT <= '"+DTOS(dDataFec)+"' ")
	Else
		Copy To &(cArq2) While D1_FILIAL == xFilial("SD1") For D1_DTDIGIT <= dDataFec VIA "TOPCONN"
	Endif
	If oCenterPanel <> NIL .And. !lBat
		oCenterPanel:IncRegua1(OemToAnsi(STR0075))
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Copia registros do SF2 para arquivo morto                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SF2")
	dbSeek(xFilial("SF2"))
	cArq3 += "SF2AMT"
	If lMultFil
		nStatus := TCSqlExec("insert into "+cArq3+" SELECT * FROM "+RetSqlName("SF2")+" WHERE F2_FILIAL = '"+xFilial("SF2")+"' AND F2_EMISSAO <= '"+DTOS(dDataFec)+"' ")
	Else
		Copy To &(cArq3) While F2_FILIAL == xFilial("SF2") For F2_EMISSAO <= dDataFec VIA "TOPCONN"
	Endif
	If oCenterPanel <> NIL .And. !lBat
		oCenterPanel:IncRegua1(OemToAnsi(STR0075))
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Copia registros do SD2 para arquivo morto                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SD2")
	dbSeek(xFilial("SD2"))
	cArq4 += "SD2AMT"
	If lMultFil
		nStatus := TCSqlExec("insert into "+cArq4+" SELECT * FROM "+RetSqlName("SD2")+" WHERE D2_FILIAL = '"+xFilial("SD2")+"' AND D2_EMISSAO <= '"+DTOS(dDataFec)+"' ")
	Else
		Copy To &(cArq4) While D2_FILIAL == xFilial("SD2") For D2_EMISSAO <= dDataFec VIA "TOPCONN"
	Endif
	If oCenterPanel <> NIL .And. !lBat
		oCenterPanel:IncRegua1(OemToAnsi(STR0075))
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Copia registros do SD3 para arquivo morto                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SD3")
	dbSeek(xFilial("SD3"))
	cArq5 += "SD3AMT"
	If lMultFil
		nStatus := TCSqlExec("insert into "+cArq5+" SELECT * FROM "+RetSqlName("SD3")+" WHERE D3_FILIAL = '"+xFilial("SD3")+"' AND D3_EMISSAO <= '"+DTOS(dDataFec)+"' ")
	Else
		Copy To &(cArq5) While D3_FILIAL == xFilial("SD3") For D3_EMISSAO <= dDataFec VIA "TOPCONN"
	Endif
	If oCenterPanel <> NIL .And. !lBat
		oCenterPanel:IncRegua1(OemToAnsi(STR0075))
	EndIf

	M280PrcLog("MENSAGEM",OemToAnsi(I18N(STR0116,{cFilAnt})) ,OemToAnsi(I18N(STR0116,{cFilAnt}))) // "Termino da copia de dados da Filial #1[D MG 01]#" ## "Termino da copia de dados da Filial #1[D MG 01]#"
Else
	M280PrcLog("MENSAGEM",OemToAnsi(I18N(STR0117,{cFilAnt})) ,OemToAnsi(I18N(STR0117,{cFilAnt}))) // "Processo de copia de dados da Filial #1[D MG 01]# não foi solicitada" ## "Processo de copia de dados da Filial #1[D MG 01]# não foi solicitada"
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Fecha todos os arquivos e reabre-os de forma compartilhada,  ³
//³ se o parametro MV_CUSTEXC estiver p/ abertura exclusiva.     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lArqExcl
	dbCloseAll()
	OpenFile(SubStr(cNumEmp,1,2))
Endif

// Ponto de entrada para tratamento de informacoes
If ExistBlock("MA280FIM")
	Execblock("MA280FIM",.F.,.F.,dData)
EndIf

// Ponto de entrada para tratamento de informacoes 2
If ExistBlock("MA2802FI")
	Execblock("MA2802FI",.F.,.F.,{dData,dDataFec})
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gravar a Data do Fechamento no SX6.                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If GetMV("MV_ULMES") != NIL
	PutMV("MV_ULMES",dDataFec)
EndIf

If oCenterPanel <> NIL .And. !lBat
	oCenterPanel:IncRegua2()
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Imprime os logs de divergencia                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aLogs[1]) > 0
			
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  
	//³ Atualiza o log de processamento   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If oCenterPanel <> NIL .And. !lBat
		oCenterPanel:SaveLog(STR0079) //"Foram encontradas quantidades conflitantes apos o fechamento."
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento			    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	M280PrcLog("MENSAGEM",STR0079+" "+STR0063+" "+cFilAnt,STR0079+" "+STR0063+" "+cFilAnt, '6') //"Foram encontradas quantidades conflitantes apos o fechamento."

	If ExistBlock("MA280BAT")
		Execblock("MA280BAT",.F.,.F.,{aLogs, dData, dDataFec})
	Else
		If lChkLog
			aadd(aLogsGR,{cFilAnt,aLogs,Iif(empty(dData),'',dData),dDataFec})
		Else
			If !lBat
				Aviso(STR0006, STR0051+CHR(13)+CHR(10)+STR0052, {'Ok'}) //"ATENÇÄO"###'O fechamento foi finalizado com sucesso!'###'Obs.: Durante o fechamento o sistema encontrou quantidades conflitantes. O relatorio a seguir, que lista estas quantidades, deve ser analisado posteriormente.'
			EndIf
			If !lJourney
				A280Log(aLogs,dData,dDataFec,,lBat)
			Endif
		EndIf
	EndIf

	If lJourney
		ExportDivergenceRecords(aLogs)
	EndIf	
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MA280Ok  ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 22/11/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se digitacao esta OK                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MA280OK()                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA280                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MA280Ok(dDataFec,cArq1,cArq2,cArq3,cArq4,cArq5,cArq6,cArq7,lMostraHelp)
Local cFilFech := ""
Local lRetorna := .T.
Local dDtFech  := ""

DEFAULT lMostraHelp := .T. //O valor de lMostraHelp é a negação do valor de lBat

cArq1 += "SF1AMT"
cArq2 += "SD1AMT"
cArq3 += "SF2AMT"
cArq4 += "SD2AMT"
cArq5 += "SD3AMT"
cArq6 += "SC2AMT"
cArq7 += "AF9AMT"

If mv_par01 == 1
	If (" "$cArq1 .Or. Empty(cArq1))
		If lMostraHelp
			Help(" ",1,"MA280ESP")
		EndIf
		lRetorna := .F.
	ElseIf MsFile(cArq1)
		If lMostraHelp
			Help(" ",1,"MA280ARQ")
		EndIf
		lRetorna := .F.
	ElseIf (" "$cArq2 .Or. Empty(cArq2))
		If lMostraHelp
			Help(" ",1,"MA280ESP")
		EndIf
		lRetorna := .F.
	ElseIf MsFile(cArq2)
		If lMostraHelp
			Help(" ",1,"MA280ARQ")
		EndIf
		lRetorna := .F.
	ElseIf (" "$cArq3 .Or. Empty(cArq3))
		If lMostraHelp
			Help(" ",1,"MA280ESP")
		EndIf
		lRetorna := .F.
	ElseIf MsFile(cArq3)
		If lMostraHelp
			Help(" ",1,"MA280ARQ")
		EndIf
		lRetorna := .F.
	ElseIf (" "$cArq4 .Or. Empty(cArq4))
		If lMostraHelp
			Help(" ",1,"MA280ESP")
		EndIf
		lRetorna := .F.
	ElseIf MsFile(cArq4)
		If lMostraHelp
			Help(" ",1,"MA280ARQ")
		EndIf
		lRetorna := .F.
	ElseIf (" "$cArq5 .Or. Empty(cArq5))
		If lMostraHelp
			Help(" ",1,"MA280ESP")
		EndIf
		lRetorna := .F.
	ElseIf MsFile(cArq5)
		If lMostraHelp
			Help(" ",1,"MA280ARQ")
		EndIf
		lRetorna := .F.
	ElseIf (" "$cArq6 .Or. Empty(cArq6))
		If lMostraHelp
			Help(" ",1,"MA280ESP")
		EndIf
		lRetorna := .F.
	ElseIf MsFile(cArq6)
		If lMostraHelp
			Help(" ",1,"MA280ARQ")
		EndIf
		lRetorna := .F.
	ElseIf (" "$cArq7 .Or. Empty(cArq7)) .And. !__lPyme
		If lMostraHelp
			Help(" ",1,"MA280ESP")
		EndIf
		lRetorna := .F.
	ElseIf MsFile(cArq7) .And. !__lPyme
		If lMostraHelp
			Help(" ",1,"MA280ARQ")
		EndIf
		lRetorna := .F.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Valida data de fechamento informada		 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorna
	lRetorna := A280Data(dDataFec,lMostraHelp)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validacao somente para ambiente LOCALIZADO ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorna .And. cPaisLoc <> "BRA" .And. lMostraHelp
	// Verifica a existencia de "remitos" sem "facturas" no periodo.
	lRetorna := A280SemFac(dDataFec)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se existe saldo a enderecar (SDA) ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorna .And. A280TemSDA(dDataFec,lMostraHelp)
	lRetorna := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se jah foi feita virada de saldos ³
//³na data informada (procura regs. na SB9)   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorna .And. !A280ValFch(dDataFec, @cFilFech,@dDtFech)
	M280PrcLog("MENSAGEM", 'MA280DTFEC - ' + STR0160 + STR0063 + ': ' + cFilFech + '. ' + STR0156 + dtoc(stod(dDtFech)) + '. ' + STR0157 + DtoC(dDataFec) + '.', STR0161, "ER")
	Help( ' ', 1, 'MA280DTFEC',, STR0063 + ': ' + cFilFech + ' ' + STR0156 + dtoc(stod(dDtFech)) + ' ' + STR0157 + DtoC(dDataFec) , 5, 11 )
	lRetorna := .F.
EndIf

If lRetorna .And. mv_par01 == 1 .And. lMostraHelp
	lRetorna := (MsgYesNo(OemToAnsi(STR0019),OemToAnsi(STR0006))) //"Confirma configura‡„o dos parƒmetros?"###"ATEN€O"
EndIf
Return lRetorna

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³BJAtuComB2³ Autor ³ Fernando Joly Siquini ³ Data ³ 09/11/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Efetua a grava‡Æo no arquivo SBJ - Saldos Iniciais por Lote³±±
±±³          ³ Obs.: Todas as atualiza‡äes sÆo feitas com base nos dados  ³±±
±±³          ³       do registro do SB2, que j  deve estar posicionado.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ BJAtuComB2()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Numerico - Soma das Quantidades do SB8                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Gen‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function BJAtuComB2(dDataFec, lFatConv, aLogs, lConsulta, aConsulta)
Static lAtuSBJ   := NIL
Local nRet       := 0
Local aAreaAnt   := GetArea()
Local aAreaSB1   := SB1->(GetArea())
Local aAreaSB8   := SB8->(GetArea())
Local aAreaSBJ   := SBJ->(GetArea())
Local cSeekSB8   := ''
Local aSaldo     := {}
Local l300SalNeg := GetMv("MV_MT300NG",.F.,.T.) // Indica se permite saldo negativo

Default aLogs     := {}
Default aConsulta := {}
Default lConsulta := .F.

If Rastro(SB2->B2_COD)
	If lAtuSBJ == NIL .And. !lConsulta
		lAtuSBJ:=ExistBlock("A280SBJ")
	EndIf
	dDataFec := If(dDataFec==Nil.Or.Empty(dDataFec),dDataBase,dDataFec)
	lFatConv := If(lFatConv==Nil.Or.ValType(lFatConv)#'L',.F.,lFatConv)
	dbSelectArea('SB1')
	If dbSeek(xFilial('SB1')+SB2->B2_COD+SB2->B2_LOCAL, .F.)
		//-- Alimenta SBJ com base no SB8 para Rastreabilidade
		dbSelectArea('SB8')
		dbSetOrder(1) //B8_FILIAL+B8_PRODUTO+B8_LOCAL+DTOS(B8_DTVALID)+B8_LOTECTL+B8_NUMLOTE
		If dbSeek(cSeekSB8 := xFilial('SB8')+SB1->B1_COD+SB2->B2_LOCAL, .F.)
			Do While !SB8->(Eof()) .And. ;
					cSeekSB8 == SB8->B8_FILIAL + SB8->B8_PRODUTO + SB8->B8_LOCAL
				aSaldo:=CalcEstL(SB8->B8_PRODUTO,SB8->B8_LOCAL,(dDataFec+1),SB8->B8_LOTECTL,SB8->B8_NUMLOTE,"","",.T.)
				// Filtra data no SB8
				If SB8->B8_DATA > dDataFec
					// Caso nao tenha tido movimento ignora registro
					If QtdComp(aSaldo[1]) == QtdComp(0)
						SB8->(dbSkip())
						Loop
						// Caso tenha tido movimento que deixou saldo negativo zera saldo
					ElseIf QtdComp(aSaldo[1]) < QtdComp(0) .And. !l300SalNeg
						aSaldo[1]:=0
						aSaldo[7]:=0
					EndIf
				EndIf
				dbSelectArea('SBJ')
				dbSetOrder(1) //BJ_FILIAL+BJ_COD+BJ_LOCAL+BJ_LOTECTL+BJ_NUMLOTE+DTOS(BJ_DATA)
				If !dbSeek(xFilial('SBJ')+SB8->B8_PRODUTO+SB8->B8_LOCAL+SB8->B8_LOTECTL+SB8->B8_NUMLOTE+DtoS(dDataFec), .F.)
					If lConsulta
						aAdd(aConsulta,{xFilial('SBJ'),SB8->B8_PRODUTO,SB8->B8_LOCAL,SB8->B8_LOTECTL,SB8->B8_NUMLOTE,dDataFec,aSaldo[1]})
					Else
						RecLock('SBJ', .T.)
						Replace BJ_FILIAL  With xFilial('SBJ')
						Replace BJ_COD     With SB8->B8_PRODUTO
						Replace BJ_LOCAL   With SB8->B8_LOCAL
						Replace BJ_LOTECTL With SB8->B8_LOTECTL
						Replace BJ_NUMLOTE With SB8->B8_NUMLOTE
						Replace BJ_DATA    With dDataFec
					EndIf
				Else
					If lConsulta
						nAchou:=ASCAN(aConsulta,{|x| x[1] == BJ_FILIAL .And. x[2] == BJ_COD .And. x[3] == BJ_LOCAL .And. x[4] == BJ_LOTECTL .And. x[5] == BJ_NUMLOTE .And. x[6] == DTOS(BJ_DATA)})
						If nAchou > 0
							aConsulta[nAchou,9] := aSaldo[1]
						EndIf
					Else
						RecLock('SBJ', .F.)
					EndIf
				EndIf
				If !lConsulta
					If !Empty(SB8->B8_DTVALID)
						Replace BJ_DTVALID With SB8->B8_DTVALID
					EndIf
					Replace BJ_QINI    With aSaldo[1]
					Replace BJ_QISEGUM With If(lFatConv,ConvUm(SBJ->BJ_COD,aSaldo[1],aSaldo[7],2),aSaldo[7])
					MsUnlock()
					If lAtuSBJ
						ExecBlock("A280SBJ",.F.,.F.)
					EndIf
				EndIf
				nRet        += BJ_QINI
				aAreaSBJ[3] := Recno()
				SB8->(dbSkip())
			EndDo
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Avisa sobre Diferencas entre SB2 e SB8.         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lConsulta .And. !(QtdComp(nRet)==QtdComp(SB2->B2_QFIM))
			If Len(aLogs[Len(aLogs)]) > 4095
				aAdd(aLogs, {})
			EndIf
			aAdd(aLogs[Len(aLogs)], {	'SB8'			,;
										SB2->B2_COD		,;
										SB2->B2_LOCAL	,;
										SB2->B2_QFIM	,;
										nRet})
		EndIf
	EndIf
	RestArea(aAreaSBJ)
	RestArea(aAreaSB8)
	RestArea(aAreaSB1)
	RestArea(aAreaAnt)
EndIf
Return nRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³BKAtuComB2³ Autor ³ Fernando Joly Siquini ³ Data ³ 08/11/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Efetua a grava‡ao no arquivo SBK - Saldos Iniciais por     ³±±
±±³          ³ Localiza‡„o.                                               ³±±
±±³          ³ Obs.: Todas as atualiza‡oes sao feitas com base nos dados  ³±±
±±³          ³       do registro do SB2, que j  deve estar posicionado.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ BKAtuComB2()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Numerico - Soma das Quantidades do SBF                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Gen‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function BKAtuComB2(dDataFec, lFatConv, aLogs, lConsulta, aConsulta)
Static lAtuSBK   := Nil

Local aAreaAnt   := GetArea()
Local aAreaSB1   := SB1->(GetArea())
Local aAreaSBF   := SBF->(GetArea())
Local aAreaSBK   := SBK->(GetArea())
Local cSeekSBF   := ''
Local nAchou     := 0
Local nRet       := 0
Local aLocaliz   :={{}}
Local aSaldo     := {}
Local dDataMes   := GetMv("MV_ULMES")
Local l300SalNeg := GetMv("MV_MT300NG",.F.,.T.) // Indica se permite saldo negativo
Local lUsaRastro := .F.
Local i,z

Default aLogs     := {}
Default aConsulta := {}
Default lConsulta := .F.

If Localiza(SB2->B2_COD)
	If lAtuSBK == NIL .And. !lConsulta
		lAtuSBK:=ExistBlock("A280SBK")
	EndIf
	dDataFec := If(dDataFec==Nil.Or.Empty(dDataFec),dDataBase,dDataFec)
	lFatConv := If(lFatConv==Nil.Or.ValType(lFatConv)#'L',.F.,lFatConv)
	dbSelectArea('SB1')
	If dbSeek(xFilial('SB1')+SB2->B2_COD,.F.)
		//-- Alimenta SBK com base no SBF para Localiza‡ao
		dbSelectArea('SBF')
		dbSetOrder(2) //BF_FILIAL+BF_PRODUTO+BF_LOCAL+BF_LOTECTL+BF_NUMLOTE+BF_PRIOR+BF_LOCALIZ+BF_NUMSERI
		If dbSeek(cSeekSBF := xFilial('SBF') + SB2->B2_COD + SB2->B2_LOCAL, .F.)
			Do While !SBF->(Eof()) .And. cSeekSBF == SBF->BF_FILIAL + SBF->BF_PRODUTO + SBF->BF_LOCAL
				// Filtra qtd igual a zero
				If QtdComp(SBF->BF_QUANT) == QtdComp(0)
					SBF->(dbSkip())
					Loop
				EndIf
				If QtdComp(SBF->BF_QUANT) < QtdComp(0) .And. !l300SalNeg
					SBF->(dbSkip())
					Loop
				EndIf
				For i:=1 to Len(aLocaliz)
					nAchou:=ASCAN(aLocaliz[i],{|x| x[1] == BF_LOCALIZ .And. x[2] == BF_NUMSERI .And. x[3] == BF_LOTECTL .And. x[4] == BF_NUMLOTE})
					If nAchou > 0
						Exit
					EndIf
				Next i
				If nAchou == 0
					If Len(aLocaliz[Len(aLocaliz)]) > 4095
						AADD(aLocaliz,{})
					EndIf
					AADD(aLocaliz[Len(aLocaliz)],{BF_LOCALIZ,BF_NUMSERI,BF_LOTECTL,BF_NUMLOTE})
				EndIf
				SBF->(dbSkip())
			EndDo
		EndIf
		// Varre saldos iniciais
		lUsaRastro := Rastro(SB2->B2_COD)
		dbSelectArea("SBK")
		dbSetOrder(3) //BK_FILIAL+BK_COD+BK_LOCAL+DTOS(BK_DATA)
		dbSeek(xFilial("SBK")+SB2->B2_COD+SB2->B2_LOCAL+DTOS(dDataMes),.T.) //Procura o último saldo inicial lançado
		While !Eof() .And. BK_FILIAL+BK_COD+BK_LOCAL == xFilial("SBK")+SB2->B2_COD+SB2->B2_LOCAL .And. DTOS(BK_DATA) < DTOS(dDataFec)
			For i:=1 to Len(aLocaliz)
				cLoteCTL := If (lUsaRastro,BK_LOTECTL,Space(Len(BK_LOTECTL)))
				nAchou:=ASCAN(aLocaliz[i],{|x| x[1] == BK_LOCALIZ .And. x[2] == BK_NUMSERI .And. x[3] == cLoteCTL .And. x[4] == BK_NUMLOTE})
				If nAchou > 0
					Exit
				EndIf
			Next i
			If nAchou == 0
				//-- Se o produto trabalha com controle de numero de serie e
				//-- a quantidade do registro SBK e igual a Zero, nao gravar
				//-- novo registro na tabela SBK para o fechamento atual
				If !Empty(BK_NUMSERI) .And. QtdComp(BK_QINI) == QtdComp(0)
					dbSkip()
					Loop
				Else
					If Len(aLocaliz[Len(aLocaliz)]) > 4095
						AADD(aLocaliz,{})
					EndIf
					AADD(aLocaliz[Len(aLocaliz)],{BK_LOCALIZ,BK_NUMSERI,cLoteCTL,BK_NUMLOTE})
				EndIf
			EndIf
			dbSkip()
		End
		// Varre movimentacao interna
		dbSelectArea("SDB")
		dbSetOrder(10) //DB_FILIAL+DB_PRODUTO+DB_LOCAL+DTOS(DB_DATA)
		dbSeek(xFilial("SDB")+SB2->B2_COD+SB2->B2_LOCAL+DTOS(dDataMes+1))
		While !Eof() .And. DB_FILIAL+DB_PRODUTO+DB_LOCAL == xFilial("SDB")+SB2->B2_COD+SB2->B2_LOCAL .And. DTOS(DB_DATA) <= DTOS(dDataFec)
			For i:=1 to Len(aLocaliz)
				cLoteCTL := If (lUsaRastro,DB_LOTECTL,Space(Len(DB_LOTECTL)))
				nAchou:=ASCAN(aLocaliz[i],{|x| x[1] == DB_LOCALIZ .And. x[2] == DB_NUMSERI .And. x[3] == cLoteCTL .And. x[4] == DB_NUMLOTE})
				If nAchou > 0
					Exit
				EndIf
			Next i
			If nAchou == 0
				If Len(aLocaliz[Len(aLocaliz)]) > 4095
					AADD(aLocaliz,{})
				EndIf
				AADD(aLocaliz[Len(aLocaliz)],{DB_LOCALIZ,DB_NUMSERI,cLoteCTL,DB_NUMLOTE})
			EndIf
			dbSkip()
		End
		//Grava SBK
		If Len(aLocaliz[1]) > 0
			For i:=1 to Len(aLocaliz)
				For z:=1 to Len(aLocaliz[i])
					aSaldo		:=CalcEstL(SB2->B2_COD,SB2->B2_LOCAL,(dDataFec+1),aLocaliz[i,z,3],aLocaliz[i,z,4],aLocaliz[i,z,1],aLocaliz[i,z,2])
					// Caso tenha tido movimento que deixou saldo negativo zera saldo
					If QtdComp(aSaldo[1]) < QtdComp(0) .And. !l300SalNeg
						aSaldo[1]	:= 0
						aSaldo[7]	:= 0
					EndIf
					dbSelectArea('SBK')
					dbSetOrder(1) //BK_FILIAL+BK_COD+BK_LOCAL+BK_LOTECTL+BK_NUMLOTE+BK_LOCALIZ+BK_NUMSERI+DTOS(BK_DATA)
					If !dbSeek(xFilial('SBK') + SB2->B2_COD + SB2->B2_LOCAL + aLocaliz[i,z,3] + aLocaliz[i,z,4] + aLocaliz[i,z,1] + aLocaliz[i,z,2] + DtoS(dDataFec), .F.)
						If lConsulta
							aAdd(aConsulta,{xFilial('SBK'),SB2->B2_COD,SB2->B2_LOCAL,aLocaliz[i,z,3],aLocaliz[i,z,4],aLocaliz[i,z,1],aLocaliz[i,z,2],dDataFec,aSaldo[1]})
						Else
							RecLock('SBK', .T.)
							Replace BK_FILIAL  With xFilial('SBK')
							Replace BK_COD     With SB2->B2_COD
							Replace BK_LOCAL   With SB2->B2_LOCAL
							Replace BK_LOTECTL With aLocaliz[i,z,3]
							Replace BK_NUMLOTE With aLocaliz[i,z,4]
							Replace BK_LOCALIZ With aLocaliz[i,z,1]
							Replace BK_NUMSERI With aLocaliz[i,z,2]
							Replace BK_DATA    With dDataFec
						EndIf
					Else
						If !lConsulta
							RecLock('SBK', .F.)
						Else
							nAchou:=ASCAN(aConsulta,{|x| x[1] == BK_FILIAL .And. x[2] == BK_COD .And. x[3] == BK_LOCAL .And. x[4] == BK_LOTECTL .And. x[5] == BK_NUMLOTE .And. x[6] == BK_LOCALIZ .And. x[7] == BK_NUMSERI .And. x[8] == DTOS(BK_DATA)})
							If nAchou > 0
								aConsulta[nAchou,9] := aSaldo[1]
							EndIf
						EndIf
					EndIf
					If !lConsulta
						Replace BK_QINI    With aSaldo[1]
						Replace BK_QISEGUM With If(lFatConv,ConvUm(SBK->BK_COD,aSaldo[1],aSaldo[7],2),aSaldo[7])
						MsUnlock()
						If lAtuSBK
							ExecBlock("A280SBK",.F.,.F.)
						EndIf
					EndIf
					nRet += aSaldo[1]
				Next z
			Next i
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Avisa sobre Diferencas entre SB2 e SBF.         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lConsulta
			dbSelectArea("SDB")
			dbSetOrder(10) //DB_FILIAL+DB_PRODUTO+DB_LOCAL+DTOS(DB_DATA)
			dbSeek(xFilial("SDB")+SB2->B2_COD+SB2->B2_LOCAL+DTOS(dDataFec+1))
			//-- Caso possua movimentos apos a data de fechamento emitir log de divergencia
			If SDB->(EOF())
				If !( QtdComp(nRet)==QtdComp(SB2->B2_QFIM-SB2->B2_QACLASS) )
					If Len(aLogs[Len(aLogs)]) > 4095
						aAdd(aLogs, {})
					EndIf
					aAdd(aLogs[Len(aLogs)], {	'SBF'			,;
												SB2->B2_COD		,;
												SB2->B2_LOCAL	,;
												SB2->B2_QFIM-(SB2->B2_QACLASS),;
												nRet})
				EndIf
			EndIf
		EndIf
	EndIf
	RestArea(aAreaSBK)
	RestArea(aAreaSBF)
	RestArea(aAreaSB1)
	RestArea(aAreaAnt)
EndIf

FWFreeArray(aLocaliz)
Return nRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A280LOG   ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 23/07/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Relatorio de Produtos que ficaram com divergencia no fecha ³±±
±±³          ³ mento.                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAEST                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function A280Log(aLogs, dDataUlMes, dDataFec, nTipoLog, lBat)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis obrigatorias dos programas de relatorio            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local titulo   := ""
Local cDesc1   := ""
Local cDesc2   := ""
Local cDesc3   := ""
Local cString  := "SB2"
Local wnrel    := "MATA280"
Local cPerg    := "      "
Local lComp	   := .F.	// Ativado habilita escolher modo RETRATO / PAISAGEM

Default nTipoLog := 1

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis tipo Private padrao de todos os relatorios         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE aReturn := {STR0038,1,STR0039, 2, 2, 1, "", 1 } //"Zebrado"###"Administracao"
PRIVATE nLastKey:= 0
PRIVATE Tamanho		:= "G"

If nTipoLog == 1
	titulo   := 'Filial: '+cFilAnt+' - '+STR0053 //"Itens com problemas "
	cDesc1   := STR0054 //"O relatorio lista os produtos que apresentaram problemas durante "
	cDesc2   := STR0036 //"o processo de fechamento de estoque. Devem ser tomadas as "
	cDesc3   := STR0037 //"acoes corretivas necessarias."
ElseIf nTipoLog == 2
	titulo   := 'Filial: '+cFilAnt+' - '+STR0092 //"Saldo a Distribuir "
	cDesc1   := STR0093 //"O relatorio ira listar os produtos que apresentaram saldo "
	cDesc2   := STR0094//"a enderecar pendente de distribuição."
	cDesc3   := ""
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Envia controle para a funcao SETPRINT                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//Força a impressão em disco quando for lBat
If lBat
	aReturn[5] := 1
	__AIMPRESS[1] := 1
EndIf

wnrel := SetPrint(cString,wnrel,cPerg,@titulo,cDesc1,cDesc2,cDesc3,.F.,/*aOrd*/,lComp,Tamanho,/*aFilter*/,.F.)

If nLastKey = 27
	Set Filter to
	Return
Endif

SetDefault(aReturn,cString)

If nLastKey = 27
	Set Filter to
	Return
Endif

RptStatus({|lEnd| C280Imp(@lEnd,wnRel,titulo,aLogs,dDataUlMes,dDataFec,nTipoLog)},titulo)

Return NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ C280IMP  ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 23/07/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Chamada do Relatorio                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA280  			                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function C280Imp(lEnd,WnRel,titulo,aLogs,dDataUlMes,dDataFec,nTipoLog)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis locais exclusivas deste programa                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local Tamanho  := "G"
Local nTipo    := 0
Local nCntImpr := 0
Local cRodaTxt := STR0040   //"REGISTRO(S)"
Local aLog     := {}
Local cQuebra  := ""
Local cPictSDA := PesqPict("SDA","DA_SALDO")
Local i,z, nPos
Local nSizCli  := Tamsx3('A1_COD')[1] - 6    // ajuste dinamico layout por tamanho do codigo cliente / fornecedor

Default nTipoLog := 1
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa variaveis para controlar cursor de progressao     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !IsBlind()
	SetRegua(Len(aLogs))
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa os codigos de caracter Comprimido/Normal da impressora ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nTipo := IIF(aReturn[4]==1,15,18)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Contadores de linha e pagina                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE li    := 80
PRIVATE m_pag := 01

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria o cabecalho.                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nTipoLog == 1
	cabec1 := STR0055//'Produto           Local  Sld.Fisico e Financeiro                  Movimento'
	cabec2 := ''
ElseIf nTipoLog == 2
	//          1         2         3         4         5         6         7         8         9         10
	// 12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
	If FWSIZEFILIAL() > 2
		cabec1 := STR0105 //" FILIAL       PRODUTO                         AMZ             SALDO   DATA       DOCUMENTO      SERIE CLI/FOR    LOJA NUMSEQ ORIGEM"
		//          1         2         3         4         5         6         7         8         9         10
		// 12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
		cabec2 := STR0106 //"                                                           PENDENTE"
	Else
		cabec1 := STR0107
		cabec2 := STR0108
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Impressao do relatorio de divergencia de saldos          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nTipoLog == 1
	For i:=1 to Len(aLogs)
		If !IsBlind()
			IncRegua()
		EndIf
		aLog := aClone(aLogs[i])
		//-- aLog[n, 1] = ALIAS
		//-- aLog[n, 2] = Produto
		//-- aLog[n, 3] = Local
		//-- aLog[n, 4] = Quantidade final no SB2
		//-- aLog[n, 5] = Quantidade da composicao do movimento do ALIAS ate a data final
		aSort(aLog,,, {|x, y| x[1]+x[2]+x[3] > y[1]+y[2]+y[3]})
		For z:=1 to Len(aLog)
			If lEnd
				@ Prow()+1,001 PSAY STR0049 //"CANCELADO PELO OPERADOR"
				Exit
			EndIf
			If li > 58
				cabec(titulo,cabec1,cabec2,wnrel,Tamanho,nTipo)
			EndIf
			If !(cQuebra==aLog[z, 1])
				If !Empty(cQuebra)
					Li++
				EndIf
				cQuebra := aLog[z, 1]
				If cQuebra == 'SB8'
					@ Li, 00 PSay STR0056+STR0057+DtoC(dDataUlMes)+STR0058+DtoC(dDataFec) //'* Saldo Fisico e Financeiro final VERSUS Saldo da movimentacao por '###'Lote de '###' ate '
					Li ++
					If TAMSX3("B1_COD")[1] < 16
						@ Li, 01 PSay STR0060 //'Produto           Local  Sld.Fisico e Financeiro         Movimento por Lote'
					Else
						@ Li, 01 PSay substr(STR0060,1,15)+SPACE(Tamsx3("B1_COD")[1] - 15)+Substr(STR0060,16,len(STR0060)) //'Produto           Local  Sld.Fisico e Financeiro         Movimento por Lote'
					EndIF
					//--           Produto           Local  Sld.Fisico e Financeiro         Movimento por Lote
					//--           XXXXXXXXXXXXXXX      XX          [999,999,999.99]-----------[999,999,999.99]
					//--           12345678901234567890123456789012345678901234567890123456789012345678901234567890
					//--           00000000011111111112222222222333333333344444444445555555555666666666677777777778
				ElseIf cQuebra == 'SBF'
					@ Li, 00 PSay STR0056+STR0059+DtoC(dDataUlMes)+STR0058+DtoC(dDataFec) //'* Saldo Fisico e Financeiro final VERSUS Saldo da movimentacao por '###'Endereco de '###' ate '
					Li ++
					If TAMSX3("B1_COD")[1] < 16
						@ Li, 01 PSay STR0061 //'Produto           Local  Sld.Fisico e Financeiro     Movimento por Endereco'
					Else
						@ Li, 01 PSay substr(STR0061,1,15)+SPACE(Tamsx3("B1_COD")[1] - 15)+Substr(STR0061,16,len(STR0061))//'Produto           Local  Sld.Fisico e Financeiro     Movimento por Endereco'
					EndIf
					//--           Produto           Local  Sld.Fisico e Financeiro     Movimento por Endereco
					//--           XXXXXXXXXXXXXXX      XX          [999,999,999.99]-----------[999,999,999.99]
					//--           12345678901234567890123456789012345678901234567890123456789012345678901234567890
					//--           00000000011111111112222222222333333333344444444445555555555666666666677777777778
				EndIf
				Li ++
			EndIf
			//-- aLog[n, 1] = ALIAS
			//-- aLog[n, 2] = Produto
			//-- aLog[n, 3] = Local
			//-- aLog[n, 4] = Quantidade final no SB2
			//-- aLog[n, 5] = Quantidade da composicao do movimento do ALIAS ate a data final
			nPos:= 22
			@ Li, 01 PSay aLog[z, 2]
			if Tamsx3("B1_COD")[1] < 16
				@ Li, 22 PSay aLog[z, 3]
			Else
				nPos:= Tamsx3("B1_COD")[1] + 6
				@ Li, nPos PSay aLog[z, 3]
			EndIf
			@ Li, nPos + 10 PSay '['+Transform(aLog[z, 4], PesqPict("SB2","B2_QATU"))+']-----------['+Transform(aLog[z, 5], PesqPict("SB2","B2_QATU"))+']'
			//--           Produto           Local  Sld.Fisico e Financeiro                  Movimento
			//--           XXXXXXXXXXXXXXX      XX          [999,999,999.99]-----------[999,999,999.99]
			//--           12345678901234567890123456789012345678901234567890123456789012345678901234567890
			//--           00000000011111111112222222222333333333344444444445555555555666666666677777777778
			Li++
		Next z
	Next i
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Impressao do relatorio de saldo a distribuir             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf nTipoLog == 2

	For i:=1 to Len(aLogs)
		If !IsBlind()
			IncRegua()
		EndIf
		aLog := aClone(aLogs[i])
		If lEnd
			@ Prow()+1,001 PSAY STR0049 //"CANCELADO PELO OPERADOR"
			Exit
		EndIf
		If li > 58
			cabec(titulo,cabec1,cabec2,wnrel,Tamanho,nTipo)
		EndIf
		If FWSIZEFILIAL() > 2
			@ Li, 001 PSay aLog[01]                         // Filial
			@ Li, 014 PSay aLog[02]                         // Produto
			@ Li, 059 PSay aLog[03]                         // Armazem
			@ Li, 063 PSay Transform(aLog[04], cPictSDA)    // Saldo
			@ Li, 086 PSay aLog[05]                         // Data
			@ Li, 109 PSay aLog[06]                         // Documento
			@ Li, 128 PSay aLog[07]                         // Serie
			@ Li, 142 PSay aLog[08]                         // Cliente/Fornecedor
			@ Li, 173 PSay aLog[09]                         // Loja
			@ Li, 184 PSay aLog[10]                         // NumSeq
			@ Li, 204 PSay aLog[11]                         // Origem
		Else
			@ Li, 001 PSay aLog[01]                         // Filial
			@ Li, 010 PSay aLog[02]                         // Produto
			@ Li, 058 PSay aLog[03]                         // Armazem
			@ Li, 066 PSay Transform(aLog[04], cPictSDA)    // Saldo
			@ Li, 088 PSay aLog[05]                         // Data
			@ Li, 108 PSay aLog[06]                         // Documento
			@ Li, 134 PSay aLog[07]                         // Serie
			@ Li, 149 PSay aLog[08]                         // Cliente/Fornecedor
			@ Li, 180+nSizCli PSay aLog[09]                         // Loja
			@ Li, 189+nSizCli PSay aLog[10]                         // NumSeq
			@ Li, 209+nSizCli PSay aLog[11]                         // Origem
		EndIf
		Li++
	Next i
	Li++
	Li++
	@ Li,005 Psay STR0097 //"*** IMPORTANTE *** "
	Li++
	@ Li,005 Psay STR0098 //"A rotina VIRADA DE SALDOS somente sera executada quando todo saldo pendente"
	Li++
	@ Li,005 Psay STR0099 //"de distribuição listado no relatorio for endereçado.  O  relatorio  somente"
	Li++
	@ Li,005 Psay STR0100 //"ira considerar o saldo pendente dentro do periodo de fechamento de estoque"
	Li++
	@ Li,005 Psay STR0101 + SPACE(1) + DTOC(dDataUlMes+1) + SPACE(1) + STR0102 + SPACE(1) + DTOC(dDataFec) // "de DD/MM/AAAA ate DD/MM/AAAA"
	Li++
EndIf

If li != 80
	Roda(nCntImpr,cRodaTxt,Tamanho)
EndIf

Set Device to Screen

If aReturn[5] = 1
	Set Printer To
	dbCommitAll()
	OurSpool(wnrel)
EndIf

MS_FLUSH()

Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MA280SP1    ³ Autor ³ Marcelo Pimentel      ³ Data ³23/04/03³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Processa o Fechamento mensal utilizando a Stored Procedure ³±±
±±³          ³ MAT038                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA280                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MA280SP1( oMsgRunSay, aData, aResult)

	aResult := NIL

	If oMsgRunSay <> NIL
		oMsgRunSay:cCaption := OemToAnsi(STR0072+" "+ STR0063+":"+cFilAnt) // "Transferindo saldos de produtos..."
		ProcessMessages()
		Sleep(2000)
	EndIf
	// Executa a procedure MAT038A
	// para transferir os saldos dos produtos
	aResult := M280SP038(cSPMAT038,aData[1])
	If aResult[1] == "1"
		If oMsgRunSay <> NIL
			oMsgRunSay:cCaption := OemToAnsi(STR0132+" "+ STR0063+": "+cFilAnt) // "Transferindo saldos de produtos em FIFO/LIFO"
			ProcessMessages()
			Sleep(2000)
		EndIf
		// Executa a procedure MAT038A
		// para transferir os saldos FIFO,LIFO
		aResult := M280SP038A(cSPMAT038A,aData[2])
	EndIf

	If aResult[1] == "1"
		If oMsgRunSay <> NIL
			oMsgRunSay:cCaption := OemToAnsi(STR0073+" "+ STR0063+": "+cFilAnt) // "Transferindo saldos de OP's..."
			ProcessMessages()
			Sleep(2000)
		EndIf
		// Executa a procedure MAT038A
		// para transferir os saldos Ordens de Produção
		aResult := M280SP038B(cSPMAT038B,aData[3])
	EndIf

Return

/*/{Protheus.doc} M280SP038
	Controle das threads filhas das execuções da procedure MAT038 em Multi-Thread
	@type  Function
	@author reynaldo
	@since 14/09/2020
	@version 1.0
	@param cSPMAT038, caracter, Nome da procedure a ser chamada
	@param aData, array, Data de inicio e fim do periodo a ser considerado na virada
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function M280SP038( cSPMAT038, aData)
Local nX
Local lControl
Local cJobAux  //controle da fase do processamento da procedure
Local cJobID
Local cJobFile
Local cJobError
Local nRetry_0
Local nRetry_1
Local cInfThread
Local aResult
Local cMsgError
Local cMsgLog

	// Prepara os valores dos parametros da procedure para cada thread
	aThreads := ma280SPPREP(aData)

	//
	// inicia os startjobs
	//
	For nX :=1 to Len(aThreads)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento			    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		M280PrcLog("MENSAGEM",I18N(STR0121 +" "+ STR0063+": "+cFilAnt,{StrZero(nX,2)}) ,I18N(STR0121 +" "+ STR0063+": "+cFilAnt,{StrZero(nX,2)})) // "Iniciando a thread #1[01]#"

		// Inicializa variavel global de controle de thread
		cJobAux:="MATA280"+cEmpAnt+cFilAnt+StrZero(nX,2)
		PutGlbValue(cJobAux,"0")
		GlbUnLock()
		aThreads[nX,'NomeGlobal'] := cJobAux

		// Inicializa variavel global para ID da thread
		cJobID:="MATA280"+cEmpAnt+cFilAnt+StrZero(nX,2)+"ID"
		PutGlbValue(cJobID," ")
		GlbUnLock()
		aThreads[nX,'ID'] := cJobID

		aThreads[nX,'NomeArquivo'] := cJobAux+".job"

		// Inicializa variavel global de Mm
		cJobError :="MATA280"+cEmpAnt+cFilAnt+StrZero(nX,2)+"ERROR"
		PutGlbValue(cJobError,"")
		GlbUnLock()
		aThreads[nX,'MsgError'] := cJobError

		cInfThread := aThreads[nX]:toJson()

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Dispara thread para processamento           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   StartJob( "M280JSP038", GetEnvServer(), .F., cEmpAnt, cFilAnt, cSPMAT038, cInfThread )
		Sleep(1000)
	Next nX

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Controle de Seguranca para MULTI-THREAD                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lControl := .T.
	While lControl

		For nX :=1 to Len(aThreads)

			// Inicializa variavel global de controle de thread
			cJobAux := aThreads[nX,'NomeGlobal']
			cJobID := aThreads[nX,'ID']
			cJobFile := aThreads[nX,'NomeArquivo']
			cJobError := aThreads[nX,'MsgError']

			If aThreads[nX,'Status'] == 1
				// Inicializa variaveis de tentativas
				nRetry_0 := aThreads[nX,'nRetry_0']
				nRetry_1 := aThreads[nX,'nRetry_1']

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Analise das Threads em Execucao                              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Do Case
					// TRATAMENTO PARA ERRO DE SUBIDA DE THREAD
					Case GetGlbValue(cJobAux) == '0'
						If nRetry_0 > 50
							cMsgLog := I18N(STR0133,{StrZero(nX,3),GetGlbValue(cJobID)}) // "Não foi possivel realizar a subida da thread #1[001]# ID #2[15201]#. "
							a280ConOut(Replicate("-",80))				//"-------------------------------------------------------------"
							a280ConOut("MATA280: " + cMsgLog)

							a280ConOut(Replicate("-",80))  			//"-------------------------------------------------------------"
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Atualiza o log de processamento			    ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							M280PrcLog("MENSAGEM", cMsgLog, cMsgLog, 'ER')
							Final( cMsgLog)
						Else
							nRetry_0 ++
						EndIf
					// TRATAMENTO PARA ERRO DE CONEXAO
					Case GetGlbValue(cJobAux) == '1'
						If FCreate(cJobFile) # -1
							If nRetry_1 > 5
								cMsgLog := I18N(STR0134,{StrZero(nX,3),GetGlbValue(cJobID)}) // "Erro de conexao na thread #1[001]# ID #2[15201]#. "
								a280ConOut(Replicate("-",80))  //"----------------------------------------------------"
								a280ConOut("MATA280: "+ cMsgLog)
								a280ConOut("Thread controle numero : " + cJobAux )	//
								a280ConOut("Numero de tentativas excedidas")				//
								a280ConOut(Replicate("-",80))  //"----------------------------------------------------"
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Atualiza o log de processamento			    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								M280PrcLog("MENSAGEM", cMsgLog, cMsgLog, 'ER')
								Final("MATA280: "+ cMsgLog)
							Else
								// Inicializa variavel global de controle de Job
								PutGlbValue(cJobAux, "0" )
								GlbUnLock()
								// Reiniciar thread
								a280ConOut(Replicate("-",65))
								a280ConOut("MATA280: Erro de conexao na thread de procedures")
								a280ConOut("Numero de tentativas: "+StrZero(nRetry_1,2))
								a280ConOut("Reiniciando a thread controle numero : " + cJobAux )			//
								a280ConOut(Replicate("-",65))
							EndIf
							nRetry_1 ++
						EndIf
					// TRATAMENTO PARA ERRO DE APLICACAO
					Case GetGlbValue(cJobAux) == '2'
						If FCreate(cJobFile) # -1
							cInfThread := aThreads[nX]:toJson()
							cMsgLog := I18N(STR0135,{StrZero(nX,3),GetGlbValue(cJobID)}) // "Erro de aplicacao na thread #1[001]# ID #2[15201]#. "
							a280ConOut(Replicate("-",80))	//"-----------------------------------------------------"
							a280ConOut("MATA280:  " + cMsgLog)
							a280ConOut("Thread controle numero : " + cJobAux )	//
							a280ConOut(Replicate("-",80))  //"------------------------------------------------------"
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Atualiza o log de processamento			    ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							M280PrcLog("ERRO", cMsgLog, cMsgLog +char(10)+cInfThread, 'ER')

							Final("MATA280 - "+ cMsgLog)
						EndIF

					// THREAD PROCESSADA CORRETAMENTE
					Case GetGlbValue(cJobAux) == '3'
						If File(cJobFile)
							nHdl := FOpen( cJobFile, FO_READ+FO_EXCLUSIVE )
							If nHdl > -1
								FClose(nHdl)
								If File(cJobFile )
									fErase(cJobFile )
								ENDIF
							EndIf
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Atualiza o log de processamento			    ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							cMsgLog := i18N(STR0139,{StrZero(nX,3),GetGlbValue(cJobID),cFilAnt}) //"Termino da virada da thread #1[001]# ID #2[15201]# da filial #3[D MG 01]. "
							M280PrcLog("MENSAGEM", cMsgLog, cMsgLog)

						EndIf

						// Limpa variavel global de controle de thread
						ClearGlbValue(cJobAux)
						ClearGlbValue(cJobID)
						aThreads[nX,'Status'] := 0 // execucao da thread finalizada

					// THREAD FALHA NA CHAMADA DA PROCEDURE
					Case GetGlbValue(cJobAux) == '4'
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza o log de processamento			    ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						cMsgLog := I18N(STR0137,{"MAT038","17"})  // "Procedure #1[MAT038B]# Processo #2[17]#"
						cMsgError := GetGlbValue(cJobError)
						cInfThread := aThreads[nX]:toJson()
						M280PrcLog("ERRO";
									,I18N(STR0138,{"MAT038",GetGlbValue(cJobID)}); // "Erro de chamada da procedure #1[MAT038]# na thread ID #2[15201]#. "
									,STR0136 + chr(10)+; // "Falha na virada de saldos dos produtos"
									cMsgLog +chr(10)+;
									cInfThread +chr(10)+;
									STR0145 +chr(10)+; // "Ocorrência detectada de erro de execução da procedure"
									cMsgError, 'ER' )
						A280Alert(STR0136, cMsgLog, cMsgError) // "Falha na virada de saldos dos produtos" // "Procedure #1[MAT038B]# Processo #2[17]#" //"Falha na virada de saldos de Ordens de Produção"
				EndCase

				aThreads[nX,'nRetry_0'] := nRetry_0
				aThreads[nX,'nRetry_1'] := nRetry_1

				sleep(1000)

			EndIf
		Next nX

		// verifica se existe alguma thread ativa,
		//caso positivo continua no while
		lControl := .F.
		aResult := {"1"}
		For nX :=1 to Len(aThreads)
			If aThreads[nX,'Status'] == 1
				aResult := NIL
				lControl := .T.
				Exit
			EndIf
		Next nX

	End

Return aResult


 /*/{Protheus.doc} ma280SPPREP
	Preparacao da execução da procedure MAT038 em Multi-Thread
	@type  Function
	@author reynaldo
	@since 14/09/2020
	@version 1.0
	@param aDataProc, array, Contem os dados para execucao da procedure
	@param aThreads, array, Tem os vetores para cada thread com os parametros e
									controles de execução
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function ma280SPPREP(aDataProc)
Local nCount
Local nPos
Local aThreads
Local aSPParam
Local aFaixaProd

	aSPParam := {}

	aAdd( aSPParam, aDataProc[01] )		// 01. Codigo da Filial Logada
	aAdd( aSPParam, aDataProc[02] )		// 02. Codigo da Filial a ser processada
	aAdd( aSPParam, ""            )		// 03. Numero da Thread
	aAdd( aSPParam, aDataProc[03] )		// 04. Data de Fechamento
	aAdd( aSPParam, aDataProc[04] )		// 05. Rastreabilidade Ativada
	aAdd( aSPParam, aDataProc[05] )		// 06. Data do ultimo fechamento
	aAdd( aSPParam, aDataProc[06] )		// 07. Gera Sld Inicial para MOD
	aAdd( aSPParam, aDataProc[07] )		// 08. Zerar Custo
	aAdd( aSPParam, aDataProc[08] )		// 09. Permite saldo negativo
	aAdd( aSPParam, aDataProc[09] )		// 10. Moedas a serem processadas
	aAdd( aSPParam, aDataProc[10] )		// 11. Verifica se devera utilizar o custo ON-LINE.
	aAdd( aSPParam, aDataProc[11] )		// 12. Verifica se o sistema utiliza o custo unificado por Filial
	aAdd( aSPParam, aDataProc[12] )		// 13. Verifica se o sistema utiliza o custo unificado por Empresa
	aAdd( aSPParam, aDataProc[13] )		// 14. Atualiza saldo atual da MOD
	aAdd( aSPParam, aDataProc[14] )		// 15. FILSEQ - A330FilNum()
	aAdd( aSPParam, aDataProc[15] )		// 16. Utiliza ou não WMS
	aAdd( aSPParam, aDataProc[16] )		// 17. Utiliza o campo B1_CCCUSTO
	aAdd( aSPParam, aDataProc[17] )		// 18. Verifica se o sistema utiliza controle por SB1 ou SBZ
	aThreads := {}

	// Calcula as faixas de produto+local de armazem por thread
	aFaixaProd := M280QtdThr(aDataProc[01],aDataProc[02])

	For nCount := 1 To len(aFaixaProd)

		aSPParam[03] := strzero(nCount,2) // atualiza com o numero da thread

		Aadd(aThreads,JsonObject():new())
		nPos := Len(aThreads)
		aThreads[nPos][ 'NomeGlobal' ]   := ""
		aThreads[nPos][ 'ID' ]           := ""
		aThreads[nPos][ 'NomeArquivo' ]  := ""
		aThreads[nPos][ 'Status' ]       := 1 // 1- Ativo / 0 - desativado
		aThreads[nPos][ 'nRetry_0' ]     := 0
		aThreads[nPos][ 'nRetry_1' ]     := 0
		aThreads[nPos][ 'SPParametros' ] := aClone(aSPParam)
		aThreads[nPos][ 'MsgError' ] := ""

	Next nCount

	aSPParam := aSize(aSPParam,0)
	aFaixaProd := aSize(aFaixaProd,0)

Return aThreads

 /*/{Protheus.doc} M280JSP038
	Chamada da procedure MAT038
	@type  Function
	@author reynaldo
	@since 14/09/2020
	@version 1.0
	@param cLEmp, caracter, Código da empresa corrente
	@param cLFil, caracter, Código da filial corrente
	@param aThread, array, Contem as informações da working thread e os dados
	 								para execucao da procedure
	@param aDataProc, array, Parametros da procedure MAT038
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Function M280JSP038( cLEmp, cLFil, cSPMAT038, cInfThread )

Local nHd1
Local aResult
Local cJobAux
Local cJobID
Local cJobFile
Local oJThread
Local aDataProc
Local cMsgError
Local cJobError
Local cInTransact as character

oJThread := JsonObject():new()
oJThread:fromJson(cInfThread)

cJobAux   := oJThread[ 'NomeGlobal' ]
cJobID    := oJThread[ 'ID' ]
cJobFile  := oJThread[ 'NomeArquivo' ]
aDataProc := oJThread[ 'SPParametros' ]
cJobError := oJThread[ 'MsgError' ]

// Apaga arquivo ja existente
If File(cJobFile)
	fErase(cJobFile)
EndIf

// Criacao do arquivo de controle de jobs
nHd1 := MSFCreate(cJobFile)

// Identificação da Thread
PutGlbValue(cJobID, cValToChar(ThreadID()) )
GlbUnLock()

// STATUS 1 - Iniciando execucao do Job
PutGlbValue(cJobAux, "1" )
GlbUnLock()

// Seta job para empresa filial desejada
RpcSetType(3)
RpcSetEnv( cLEmp,cLFil,,,'EST',,{"SB1","SB2"})

// STATUS 2 - Conexao efetuada com sucesso
PutGlbValue(cJobAux, "2" )
GlbUnLock()

a280ConOut("[MATA280] "+dtoc(Date())+" "+Time()+" "+i18N(STR0122+" "+ STR0063+": "+cFilAnt, {cValToChar(ThreadID())})) //"Inicio do job de virada de saldos - Thread: #1[62]#"

cInTransact :='0'
if InTransact()
	cInTransact := '1'
EndIf

aResult := TCSPEXEC( xProcedures( cSPMAT038 ), ;
								aDataProc[01] ,;	// 01. IN_FILIALLOGIN
								aDataProc[02] ,;	// 02. IN_FILIALCOR
								aDataProc[03] ,;	// 03. IN_THREAD
								aDataProc[04] ,;	// 04. IN_DATA
								aDataProc[05] ,;	// 05. IN_MV_RASTRO
								aDataProc[06] ,;	// 06. IN_MV_ULMES
								aDataProc[07] ,;	// 07. IN_MV_PAR02
								aDataProc[08] ,;	// 08. IN_MV_CUSZERO
								aDataProc[09] ,;	// 09. IN_300SALNEG
								aDataProc[10] ,;	// 10. IN_MV_MOEDACM
								aDataProc[11] ,;	// 11. IN_MV_CUSMED
								aDataProc[12] ,;	// 12. IN_MV_CUSFIL
								aDataProc[13] ,;	// 13. IN_MV_CUSEMP
								aDataProc[14] ,;	// 14. IN_MV_PAR04
								aDataProc[15] ,;	// 15. IN_FILSEQ
								aDataProc[16] ,;	// 16. IN_MV_WMSNEW
								aDataProc[17] ,;	// 17. IN_MV_PRODMOD
								aDataProc[18] ,;	// 18. IN_MV_ARQPROD
								cInTransact;	    // 19. IN_TRANSACTION
						)

// limpa array
aDataProc := aSize(aDataProc,0)

If Empty(aResult)

	cMsgError := TCSqlError()
	PutGlbValue(cJobError, cMsgError )

	// STATUS 4 - 'Erro na chamada do processo'
	PutGlbValue(cJobAux,"4")
	GlbUnLock()
	a280ConOut(Replicate("-",80))	//"-----------------------------------------------------"
	a280ConOut("MATA280: " + I18N(STR0144,{cSPMAT038})) //"Erro de chamada da procedure #1[MAT038A]# "
	a280ConOut("Thread ID " + GetGlbValue(cJobID))
	a280ConOut("Thread controle numero : " + cJobAux )	//
	a280ConOut(Replicate("-",80))  //"------------------------------------------------------"

	GlbUnLock()

ElseIf aResult[1] == "0"
	// STATUS 5 - 'Reprocessamento com Erro'
	PutGlbValue(cJobAux,"5")
	GlbUnLock()

ElseIf aResult[1] == "1"
	// STATUS 1 - 'processamento finalizado'
	PutGlbValue(cJobAux,"3")
	GlbUnLock()

EndIf

//
a280ConOut("[MATA280] "+dtoc(Date())+" "+Time()+" "+i18N(STR0123+" "+ STR0063+": "+cFilAnt, {cValToChar(ThreadID())})) //"Fim do job de virada de saldos - Thread: #1[62]#"

Return .T.

/*/{Protheus.doc} M280SP038A
	Chamada da procedure MAT038A
	@type  Function
	@author reynaldo
	@since 14/09/2020
	@version 1.0
	@param cLEmp, caracter, Código da empresa corrente
	@param cLFil, caracter, Código da filial corrente
	@param aThread, array, Contem as informações da working thread e os dados
	 								para execucao da procedure
	@param aDataProc, array, Parametros da procedure MAT038
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function M280SP038A(cSPMAT038A,aDataProc)
Local aResult
Local cMensagem
Local cMsgError
Local cInTransact as character

cInTransact :='0'
if InTransact()
	cInTransact := '1'
EndIf

cMensagem := STR0124+" "+ STR0063+": "+cFilAnt // "Inicio da virada de saldos FIFO/LIFO "
a280ConOut("[MATA280] "+dtoc(Date())+" "+Time()+" "+cMensagem )
If aDataProc[03]== "1"

	M280PrcLog("MENSAGEM", "Procedure: "+cMensagem, cMensagem, '4B')

	aResult := TCSPEXEC( xProcedures( cSPMAT038A ), ;
									aDataProc[01] ,;	// 01. IN_FILIALCOR
									aDataProc[02] ,;	// 02. IN_DATA
									aDataProc[03] ,;	// 03. IN_MV_CUSFIFO
									aDataProc[04] ,;	// 04. IN_MV_MOEDACM
									aDataProc[05] ,;	// 05. IN_CFECHFIFO
									cInTransact;		//Flag que Indica execução em transação
							)

	// limpa array
	aDataProc := aSize(aDataProc,0)

	If Empty(aResult)
		cMensagem := I18N(STR0137,{"MAT038A","17"}) // "Procedure #1[MAT038B]# Processo #2[17]#"
		cMsgError := TCSqlError()
		// STATUS 4 - 'Erro na chamada do processo'
		M280PrcLog("ERRO";
					,I18N(STR0144,{cSPMAT038A}); //"Erro de chamada da procedure #1[MAT038A]# "
					,STR0140 + chr(10)+; // "Falha na virada de saldos FIFO/LIFO"
					cMensagem + chr(10)+; // "Procedure #1[MAT038B]# Processo #2[17]#"
					STR0145 +chr(10)+; // "Ocorrência detectada de erro de execução da procedure"
					cMsgError, 'ER')
		A280Alert(STR0140, cMensagem, cMsgError) //"Falha na virada de saldos FIFO/LIFO"

	ElseIf aResult[1] == "0"
		cMensagem := I18N(STR0146,{"MAT038A"}) //"Houve erro no processamento da procedure armazenada #1[MAT038B]#"
		// STATUS 5 - 'Reprocessamento com Erro'
		M280PrcLog("ERRO",cMensagem,TcSqlError(),'ER')
		Final(cMensagem)

	ElseIf aResult[1] == "1"

		cMensagem := STR0125+" "+ STR0063+": "+cFilAnt // "Fim da virada de saldos FIFO/LIFO "
		// STATUS 1 - 'processamento finalizado'
		M280PrcLog("MENSAGEM",cMensagem ,cMensagem, '4C')

	EndIf
Else
	M280PrcLog("MENSAGEM", STR0126+" "+ STR0063+": "+cFilAnt, STR0127+" "+ STR0063+": "+cFilAnt, '4D') // "Saldo dos produtos em FIFO/LIFO não foram processados"  ## "Não foram processados os saldos de FIFO/LIFO" )
	aResult := {"1"}
EndIf

cMensagem := STR0125+" "+ STR0063+": "+cFilAnt // "Fim da virada de saldos FIFO/LIFO "
a280ConOut("[MATA280] "+dtoc(Date())+" "+Time()+" "+cMensagem )

Return aResult

/*/{Protheus.doc} M280SP038B
	Chamada da procedure MAT038B
	@type  Function
	@author reynaldo
	@since 04/11/2020
	@version 1.0
	@param cSPMAT038B, caracter, Código da empresa corrente
	@param aDataProc, array, Parametros da procedure MAT038B
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function M280SP038B(cSPMAT038B,aDataProc)
Local aResult
Local cMensagem
Local cMsgError
Local cInTransact as character

cInTransact :='0'
if InTransact()
	cInTransact := '1'
EndIf

cMensagem := STR0128+" "+ STR0063+": "+cFilAnt // "Inicio da virada de saldos de Ordens de Produção "

M280PrcLog("MENSAGEM", "Procedure: "+cMensagem, cMensagem, '4E' )
a280ConOut("[MATA280] "+dtoc(Date())+" "+Time()+" "+cMensagem )

aResult := TCSPEXEC( xProcedures( cSPMAT038B ), ;
								aDataProc[01] ,;	// 01. IN_FILIALCOR
								aDataProc[02] ,;	// 02. IN_MV_ULMES
								cInTransact;    	// 03. flag indica execução em transação
						)

// limpa array
aDataProc := aSize(aDataProc,0)

If Empty(aResult)
	cMensagem := I18N(STR0137,{"MAT038B","17"}) // "Procedure #1[MAT038B]# Processo #2[17]#"
	cMsgError := TCSqlError()
	// STATUS 4 - 'Erro na chamada do processo'
	M280PrcLog("ERRO" ;
				,I18N(STR0144,{cSPMAT038B}); //"Erro de chamada da procedure #1[MAT038A]# "
				,STR0141 + chr(10)+; //"Falha na virada de saldos de Ordens de Produção"
				cMensagem + chr(10)+;
				STR0145 +chr(10)+; // "Ocorrência detectada de erro de execução da procedure"
				cMsgError, 'ER' )
	A280Alert(STR0141, cMensagem, cMsgError) // "Falha na virada de saldos de Ordens de Produção"

ElseIf aResult[1] == "0"
	cMensagem := I18N(STR0146,{"MAT038B"}) //"Houve erro no processamento da procedure armazenada #1[MAT038B]#"
	// STATUS 5 - 'Reprocessamento com Erro'
	M280PrcLog("ERRO",cMensagem,TcSqlError(),'ER')
	Final(cMensagem)

ElseIf aResult[1] == "1"

	cMensagem := STR0129+" "+ STR0063+": "+cFilAnt// "Fim da virada de saldos das Ordens de Produção "
	// STATUS 1 - 'processamento finalizado'
	M280PrcLog("MENSAGEM",cMensagem ,cMensagem, '4F')

EndIf

//
cMensagem := STR0129+" "+ STR0063+": "+cFilAnt// "Fim da virada de saldos das Ordens de Produção "
a280ConOut("[MATA280] "+dtoc(Date())+" "+Time()+" "+cMensagem )

Return aResult

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MA280SP2    ³ Autor ³ Marcelo Pimentel      ³ Data ³23/04/03³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Processo para zerar demandas utilizando a Stored Procedure ³±±
±±³          ³ MAT039                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA280                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MA280SP2(cCodFil,cMes,aResult)
Local cInTransact as character

cInTransact :='0'
if InTransact()
	cInTransact := '1'
EndIf
aResult:= TCSPEXEC( xProcedures( cSPMAT039 ),cCodFil,cMes,cInTransact)
Return aResult


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³VerIDProc ³ Autor ³ Marcelo Pimentel      ³ Data ³24.07.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Identifica a sequencia de controle do fonte ADVPL com a     ³±±
±±³          ³stored procedure, qualquer alteracao que envolva diretamente³±±
±±³          ³a stored procedure a variavel sera incrementada.            ³±±
±±³          ³Procedure MAT038                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function VerIDProc() //se alterar a assinatura alterar no sigacusb
Return '004'

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³a280MontPa³ Autor ³ Andre Anjos           ³ Data ³16.12.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta tela usada apos perguntas ou painel                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function a280MontPanel(oCenterPanel,cOrigem,dDataFec,cArq1,cArq2,cArq3,cArq4,cArq5,cArq6,cArq7)
local lNewRelease := UsaNewPrc()
local lEditaData := !SuperGetMV("MV_CMDBLQV",.F.,.F.)
local oCheck1

If cOrigem == "DATA" .Or. !lNewRelease
	@ 05,04 TO 050,310 LABEL "" OF oCenterPanel PIXEL
EndIf
If !lNewRelease
	@  52,04 TO 161,310 LABEL "" OF oCenterPanel PIXEL
ElseIf cOrigem == "ARQS"
	@  05,04 TO 125,310 LABEL "" OF oCenterPanel PIXEL
EndIf
If cOrigem == "DATA" .Or. !lNewRelease
	@  36,111 MSGET dDataFec SIZE 43,09 Valid !Empty(dDataFec) When lEditaData OF oCenterPanel PIXEL HASBUTTON
	@  36,180 CHECKBOX oCheck1 VAR lChklog PROMPT "Logs apos ultima filial"   SIZE 070, 008 OF oCenterPanel
EndIf
If !lNewRelease
	@ 083,139 MSGET cArq1 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq1) .And. MA280Arq(cArq1,"SF1") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	@ 083,219 MSGET cArq2 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq2) .And. MA280Arq(cArq2,"SD1") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	@ 099,139 MSGET cArq3 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq3) .And. MA280Arq(cArq3,"SF2") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	@ 099,219 MSGET cArq4 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq4) .And. MA280Arq(cArq4,"SD2") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	@ 115,139 MSGET cArq5 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq5) .And. MA280Arq(cArq5,"SD3") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	@ 131,139 MSGET cArq6 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq6) .And. MA280Arq(cArq6,"SC2") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	If !__lPyMe
		@ 145,139 MSGET cArq7 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq7) .And. MA280Arq(cArq7,"AF9") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	EndIf
ElseIf cOrigem == "ARQS"
	@ 46,139 MSGET cArq1 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq1) .And. MA280Arq(cArq1,"SF1") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	@ 46,219 MSGET cArq2 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq2) .And. MA280Arq(cArq2,"SD1") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	@ 62,139 MSGET cArq3 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq3) .And. MA280Arq(cArq3,"SF2") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	@ 62,219 MSGET cArq4 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq4) .And. MA280Arq(cArq4,"SD2") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	@ 78,139 MSGET cArq5 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq5) .And. MA280Arq(cArq5,"SD3") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	@ 94,139 MSGET cArq6 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq6) .And. MA280Arq(cArq6,"SC2") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	If !__lPyMe
		@ 108,139 MSGET cArq7 Picture "@!" SIZE 23,10 Valid NaoVazio(cArq7) .And. MA280Arq(cArq7,"AF9") OF oCenterPanel PIXEL WHEN mv_par01 == 1
	EndIf
EndIf

If cOrigem == "DATA" .OR. !lNewRelease
	@  09,10 SAY OemToAnsi(STR0008+STR0064)	SIZE 300, 24 OF oCenterPanel PIXEL			//"O programa fará a transferência dos saldos finais, calculados na rotina de Recálculo do Custo Médio, para os saldos iniciais do próximo período."##" Ele trará a data do último recálculo como sugestão, esta data deverá ser usada na rotina Limpeza Mensal que poderá ser executada posteriormente. Confirme a data da virada de saldos."
	@  37,10 SAY OemToAnsi(STR0009)   		SIZE  97,  8 OF oCenterPanel PIXEL    		//"Data Base para executar o fechamento:"
EndIf
If !lNewRelease
	@ 056,007 SAY OemToAnsi(STR0010+STR0065) SIZE 301,023 OF oCenterPanel PIXEL		//"Para efetuar a transferência dos saldos, será necessário informar os nomes dos arquivos onde serão copiados os movimentos anteriores à data do fechamento."##" Estes nomes deverão conter no máximo 5 caracteres cada um, o sistema se encarregará de complementá-los com o padrão utilizado na rotina de Depuração de Arquivos."
	@ 083,036 SAY OemToAnsi(STR0011)   SIZE 101,11 OF oCenterPanel PIXEL    		//"Notas Fiscais de Compra ---> Cabe‡alho"
	@ 099,036 SAY OemToAnsi(STR0012)   SIZE 100,11 OF oCenterPanel PIXEL    		//"Notas Fiscais de Venda  ---> Cabe‡alho"
	@ 083,175 SAY OemToAnsi(STR0013)   SIZE 046,10 OF oCenterPanel PIXEL    		//"SF1.AMT       Itens"
	@ 099,175 SAY OemToAnsi(STR0014)   SIZE 046,10 OF oCenterPanel PIXEL    		//"SF2.AMT       Itens"
	@ 083,254 SAY OemToAnsi("SD1AMT") SIZE 048,10 OF oCenterPanel PIXEL
	@ 115,036 SAY OemToAnsi(STR0015)   SIZE 100,10 OF oCenterPanel PIXEL    		//"Movimenta‡”es Internas --------------------->"
	@ 099,254 SAY OemToAnsi("SD2AMT") SIZE 049,10 OF oCenterPanel PIXEL
	@ 115,175 SAY OemToAnsi("SD3AMT") SIZE 049,11 OF oCenterPanel PIXEL
	@ 131,036 SAY OemToAnsi(STR0016)   SIZE 100,10 OF oCenterPanel PIXEL    		//"Ordem de Produ‡„o        --------------------->"
	@ 131,175 SAY OemToAnsi("SC2AMT") SIZE 049,11 OF oCenterPanel PIXEL
	If ! __lPyme
		@ 147,036 SAY STR0028 SIZE 100,010 OF oCenterPanel PIXEL 					//"Tarefas de Projetos      --------------------->"
		@ 147,175 SAY OemToAnsi("AF9AMT") SIZE 49,11 OF oCenterPanel PIXEL
	EndIf
ElseIf cOrigem == "ARQS"
	@  13, 10 SAY OemToAnsi(STR0010+STR0065)   SIZE 301, 23 OF oCenterPanel PIXEL	//"Para efetuar a transferência dos saldos, será necessário informar os nomes dos arquivos onde serão copiados os movimentos anteriores à data do fechamento."##" Estes nomes deverão conter no máximo 5 caracteres cada um, o sistema se encarregará de complementá-los com o padrão utilizado na rotina de Depuração de Arquivos."
	@  48, 36 SAY OemToAnsi(STR0011)   SIZE 101, 11 OF oCenterPanel PIXEL    		//"Notas Fiscais de Compra ---> Cabe‡alho"
	@  64, 36 SAY OemToAnsi(STR0012)   SIZE 100, 11 OF oCenterPanel PIXEL    		//"Notas Fiscais de Venda  ---> Cabe‡alho"
	@  48,175 SAY OemToAnsi(STR0013)   SIZE  46, 10 OF oCenterPanel PIXEL    		//"SF1.AMT       Itens"
	@  64,175 SAY OemToAnsi(STR0014)   SIZE  46, 10 OF oCenterPanel PIXEL    		//"SF2.AMT       Itens"
	@  48,254 SAY OemToAnsi("SD1AMT") SIZE  48, 10 OF oCenterPanel PIXEL
	@  80, 36 SAY OemToAnsi(STR0015)   SIZE 100, 10 OF oCenterPanel PIXEL    		//"Movimenta‡”es Internas --------------------->"
	@  64,254 SAY OemToAnsi("SD2AMT") SIZE  49, 10 OF oCenterPanel PIXEL
	@  80,175 SAY OemToAnsi("SD3AMT") SIZE  49, 11 OF oCenterPanel PIXEL
	@  96, 36 SAY OemToAnsi(STR0016)   SIZE 100, 10 OF oCenterPanel PIXEL    		//"Ordem de Produ‡„o        --------------------->"
	@  96,175 SAY OemToAnsi("SC2AMT") SIZE  49, 11 OF oCenterPanel PIXEL
	If ! __lPyme
		@ 112, 36 SAY STR0028 SIZE 100, 10 OF oCenterPanel PIXEL 					//"Tarefas de Projetos      --------------------->"
		@ 112, 175 SAY OemToAnsi("AF9AMT") SIZE 49,11 OF oCenterPanel PIXEL
	EndIf
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    |a280Run   ³ Autor ³ Andre Anjos		    ³ Data ³16.12.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Faz processamento com varias filiais                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function a280Run(aProcsOk,lBat,dDataFec,cArq1,cArq2,cArq3,cArq4,cArq5,cArq6,cArq7,oCenterPanel)
Local cFilBack   := cFilAnt
Local nForFilial := 0
Local nProcFil   := 0
Local lRet       := .T.
Local lEnviou	 := .T.
Local cIDEvent	 := ""
LOCAL cTempo	 := "",nTempoFim:=0,nTempo := 0,nTempoIni:=Seconds()

Local aFilsValid := {}

private cTableTRB
private cAliasTRB
private cFilLogin

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para validar a execucao da rotina  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lRet :=  M280PE280OK(dDataFec)

If lRet

	cFilLogin := cFilAnt
	cTableTRB := "TRB"+cEmpAnt+"0_SPMATA280"
	cAliasTRB := GetNextAlias()
	If Select(cAliasTRB) > 0
		(cAliasTRB)->(dbCloseArea())
	EndIf
	If !EqualsTrb(cAliasTRB, cTableTRB) // se a tabela e indice estiver correta
		A280CreTRB(cTableTRB) // cria da tabela de processamento
	EndIf

	// Exclui todos os registros referentes ao ultimo processamento pela filial logada
	TcSqlExec("DELETE FROM "+cTableTRB+" WHERE FILLOG = '"+cFilLogin+"' ")
	dbUseArea(.T.,"TOPCONN",cTableTRB,cAliasTRB,.T.,.F.)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Faz Processamento                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nForFilial := 1 to Len(aFilsCalc)
		If aFilsCalc[nForFilial,1]
			If nForFilial == 1 
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Tratamento de inicio de EventViewer ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cIDEvent:= "077"
				cTitle	:= 	STR0148 // Inicio processamento virada dos saldos
				cMessage:=  STR0149+cUserName +CRLF // Usuário 
				A280Event(cIDEvent, cTitle, cMessage)
				lEnviou:= .T.
			EndIf
			nProcFil++ // controla a qtde de filial processada
			// Altera filial corrente
			cFilAnt:=aFilsCalc[nForFilial,2]
			If lBat
				MA280Process(aProcsOk,lBat,dDataFec,cFilLogin,{cArq1,cArq2,cArq3,cArq4,cArq5,cArq6,cArq7},,,nProcFil>1)
			Else
				If oCenterPanel == NIL
				   FWMsgRun(, {|| MA280Process(aProcsOk,lBat,dDataFec,cFilLogin,{cArq1,cArq2,cArq3,cArq4,cArq5,cArq6,cArq7},@lEnd,,nProcFil>1) }, OemToAnsi(STR0017),OemToAnsi(STR0018)) // "Fechamento Mensal" ## "Efetuando Fechamento Mensal..."
				Else
					MA280Process(aProcsOk,lBat,dDataFec,cFilLogin,{cArq1,cArq2,cArq3,cArq4,cArq5,cArq6,cArq7},@lEnd,oCenterPanel,nProcFil>1)
				EndIf
			EndIf
			aadd(aFilsValid, aFilsCalc[nForFilial])
		EndIf
	Next
EndIf

If lEnviou
	nTempoFim:=Seconds()
	If nTempoFim < nTempoIni
		nTempo := (nTempoFim+86399) - nTempoIni
	Else
		nTempo := nTempoFim - nTempoIni
	EndIf
	cTempo:=StrZero((nTempo)/60,5,0)

	cIDEvent:= "079"
	cTitle	:= STR0150// Termino de processamento da virada dos saldo "
	cMessage:= STR0151+cTempo+ " Min" + CRLF // "Tempo de Execução: "
	cMessage+= STR0149+cUserName +CRLF // Usuário // Min
	A280Event(cIDEvent, cTitle, cMessage )
EndIf 
//Recupera a filial corrente
cFilAnt:=cFilBack

If lRet 

	If lExistD3Y
		GravaD3Y(aFilsValid,dDataFec)
	Endif 

	if lJourney
		oJourneyLog:attStatus('FINISHED', .F.)
	endIf

Endif 

If Select(cAliasTRB) > 0
	(cAliasTRB)->(dbCloseArea())
EndIf

oJourneyLog:Destroy()
FreeObj(oJourneyLog)

Return

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A280SemFac³ Autor ³ Emerson Rony Oliveira ³ Data ³20/03/2009      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Verifica a existência de REMITOS sem FACTURA no periodo.         ³±±
±±³          ³                                                                  ³±±
±±³          ³ Ao realizar a virada de saldos em ambiente localizado sera       ³±±
±±³          ³ necessario verificar se existe algum "remito" sem "factura"      ³±±
±±³          ³ associada dentro do periodo de fechamento.                       ³±±
±±³          ³                                                                  ³±±
±±³          ³ Havendo ao menos um remito nesta situacao dentro do periodo      ³±±
±±³          ³ deve ser emitido um aviso ao usuario sobre o fato e solicitar    ³±±
±±³          ³ que ele decida se a rotina deve ou nao continuar.                ³±±
±±³          ³                                                                  ³±±
±±³          ³ E necessário mencionar que se ele decidir prosseguir, o custo dos³±±
±±³          ³ remitos que nao possuirem factura nao serao reajustados caso seja³±±
±±³          ³ associada uma factura no periodo seguinte.                       ³±±
±±³          ³                                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void A280SemFac(ExpD1)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpD1 = Data de fechamento                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Logico - Prossegue(.T.) ou nao (.F.) com a rotina de encerramento³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA280()                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function A280SemFac(dDataFec)
Local aRemitos   := {}
Local aFacturas  := {}
Local lRet       := .T. // caso nao encontre nenhuma inconsistencia, a rotina devera continuar
Local aArea      := GetArea()
Local aAreaSD1	 := SD1->(GetArea())
Local nX         := 0
Local cFilBack   := cFilAnt
Local nForFilial := 0
Local cFiliais   := ""
Local dDataIni	 := dDataBase

dbSelectArea("SD1")
dbSetOrder(6) //D1_FILIAL+DTOS(D1_DTDIGIT)+D1_NUMSEQ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Faz Processamento                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nForFilial := 1 to Len(aFilsCalc)
	If aFilsCalc[nForFilial,1]
		aRemitos  := {}
		aFacturas := {}
		// Altera filial corrente
		cFilAnt:=aFilsCalc[nForFilial,2]
		dDataIni:=GetMv("MV_ULMES")

		dbSeek(xFilial("SD1")+Dtos(dDataIni),.T.)
		// Obter todos os remitos e facturas do periodo
		While !Eof() .And. SD1->D1_FILIAL == xFilial("SD1") .And. SD1->D1_DTDIGIT >= dDataIni .And. D1_DTDIGIT <= dDataFec
			If IsRemito(1,"D1_TIPODOC")
				// Obtem todos os remitos do periodo
				aAdd(aRemitos,  {SD1->D1_FILIAL+SD1->D1_DOC   +SD1->D1_SERIE  +SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEM})
			Else // Qualquer outro documento dentro do periodo que nao seja remito
				aAdd(aFacturas, {SD1->D1_FILIAL+SD1->D1_REMITO+SD1->D1_SERIREM+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMREM})
			EndIf
			dbSkip()
		EndDo

		// Localizar os "remitos" nos demais documentos do periodo
		If Len(aRemitos) > 0
			For nX := 1 to Len(aRemitos)
				If aScan( aFacturas, { |x| x[1] == aRemitos[nX][1]} ) == 0
					// Nao encontrou nenhuma factura vinculada ao remito para a filial atual
					cFiliais += IIF(Empty(cFiliais), cFilAnt, ', ' + cFilAnt)
					Exit
				EndIf
			Next nX
		EndIf
	EndIf
Next nForFilial

If !Empty(cFiliais)
	lRet := (Aviso(STR0017,STR0080+CHR(13)+STR0081+cFiliais+CHR(13)+STR0082+CHR(13)+STR0083+CHR(13)+STR0084,{STR0085, STR0086}) == 1)
EndIf

RestArea(aAreaSD1)
RestArea(aArea)

//Recupera a filial corrente
cFilAnt:=cFilBack

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A280TemSDA    ³ Autor ³ Microsiga S/A         ³ Data ³27/07/2009  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Verifica a existencia de saldos a distribuir pendentes dentro    ³±±
±±³          ³ do periodo de fechamento de estoque.                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void A280TemSDA(dDataMes,dDataFec,lMostraHelp)                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Logico - Existe (.T.) ou Nao Existe (.F.)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA280()                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function A280TemSDA(dDataFec,lMostraHelp)
Local aAreaAnt := GetArea()
Local aAreaSB1 := SB1->(GetArea())
Local aAreaSDA := SDA->(GetArea())
Local nForFil  := 0
Local aLogSDA  := {}
Local cAliasTop:= ''
Local cQuery   := ''
Local cFilBack := cFilAnt // Salva a filial corrente
Local lTemSDA  := .F.
Local lBat 	   := If(lMostraHelp,.F.,.T.)
Local dDataMes := dDataBase

For nForFil := 1 To Len(aFilsCalc)
	If aFilsCalc[nForFil,1]
		// Altera filial corrente
		cFilAnt:=aFilsCalc[nForFil,2]
		
		If SuperGetMv("MV_A280SDA",.F.,.T.)
			dDataMes:=GetMv("MV_ULMES")
			cAliasTop := GetNextAlias()
			cQuery    := " SELECT DA_FILIAL,DA_PRODUTO,DA_LOCAL,DA_SALDO,DA_DATA,DA_DOC,DA_SERIE,DA_CLIFOR,DA_LOJA,DA_NUMSEQ,DA_ORIGEM "
			cQuery    += " FROM "+RetSqlName("SB1")+" SB1 , " + RetSqlName("SDA")+" SDA "
			cQuery    += " WHERE  SB1.B1_FILIAL = '"+xFilial("SB1")+"' "
			cQuery    +=         " AND SDA.DA_FILIAL = '"+xFilial("SDA")+"' "
			cQuery    +=         " AND SB1.B1_COD = SDA.DA_PRODUTO "
			cQuery    +=         " AND ( SB1.B1_LOCALIZ = 'S' "
			cQuery    +=         " OR EXISTS(SELECT 1 From " + RetSqlName("SBZ") + " WHERE  BZ_FILIAL = '" + xFilial("SBZ") + "' AND BZ_COD = SB1.B1_COD AND BZ_LOCALIZ = 'S')) "
			cQuery    +=         " AND SDA.DA_SALDO > 0 "
			cQuery    +=         " AND SDA.DA_DATA >= '" + DTOS(dDataMes+1)+ "' "
			cQuery    +=         " AND SDA.DA_DATA <= '" + DTOS(dDataFec)+ "' "
			cQuery    +=         " AND SB1.D_E_L_E_T_ = ' ' "
			cQuery    +=         " AND SDA.D_E_L_E_T_ = ' ' "
			cQuery    += " ORDER BY "+SqlOrder(SB1->(IndexKey()))
			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTop,.T.,.T.)
			aEval(SDA->(dbStruct()), {|x| If(x[2] <> "C" .And. (cAliasTop)->(FieldPos(x[1]))>0, TcSetField(cAliasTop,x[1],x[2],x[3],x[4]),Nil)})
			dbSelectArea(cAliasTop)
			Do While !Eof()
				aAdd(aLogSDA,{DA_FILIAL,DA_PRODUTO,DA_LOCAL,DA_SALDO,DA_DATA,DA_DOC,DA_SERIE,DA_CLIFOR,DA_LOJA,DA_NUMSEQ,DA_ORIGEM})
				dbSkip()
			EndDo
			dbSelectArea(cAliasTop)
			dbCloseArea()
			dbSelectArea("SB1")
			// Imprime relatorio de saldo a enderecar pendente
			If Len(aLogSDA) > 0
				lTemSDA := .T.
				A280Log(aLogSDA,dDataMes,dDataFec,2,lBat)
			EndIf
		EndIf
	EndIf
Next nForFil

cFilAnt := cFilBack

RestArea(aAreaSDA)
RestArea(aAreaSB1)
RestArea(aAreaAnt)
Return lTemSDA

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A280ValFch³ Autor ³ Emerson Rony Oliveira ³ Data ³08/02/2010      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Verifica a existência de registros na tabela SB9 com data a      ³±±
±±³          ³ partir da data informada nos parâmetros da rotina.               ³±±
±±³          ³                                                                  ³±±
±±³          ³ Se existir ao menos um registro na tabela SB9 com data igual ou  ³±±
±±³          ³ superior a informada, o usuário receberá um aviso informando-o   ³±±
±±³          ³ sobre o fato e a rotina não prosseguirá.                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void A280ValFch(ExpD1)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpD1 = Data de fechamento                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Logico - Prossegue(.T.) ou nao (.F.) com a rotina de encerramento³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA280()                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function A280ValFch(dDataFec, cFilFech, dDtFech)
Local aArea      := GetArea()
Local cAliasTmp  := ''
Local cQuery     := ''
Local cFilBack   := cFilAnt // Salva a filial corrente
Local nForFilial := 0
Local lRet       := .T.

Default cFilFech := ""

For nForFilial := 1 to Len(aFilsCalc)
	If aFilsCalc[nForFilial,1]
		// Altera filial corrente
		cFilAnt:=aFilsCalc[nForFilial,2]
		cQuery := "SELECT B9_DATA "
		cQuery += "  FROM "+RetSqlName("SB9")+" SB9 "
		cQuery += " WHERE B9_FILIAL = '"+xFilial("SB9")+"' "
		cQuery += "   AND B9_DATA >= '"+DTOS(dDataFec)+"' "
		cQuery += "   AND D_E_L_E_T_ = ' ' "

		cAliasTmp := GetNextAlias()
		cQuery    := ChangeQuery(cQuery)
		dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasTmp, .T., .F. )

		If !(cAliasTmp)->(Eof())
			lRet     := .F.
			cFilFech := cFilAnt
			dDtFech  := (cAliasTmp)->B9_DATA
			Exit
		EndIf
		(cAliasTmp)->( DbCloseArea() )
	EndIf
Next nForFilial

cFilAnt := cFilBack
RestArea(aArea)

Return lRet

/*/{Protheus.doc} M280QtdThr
	Define a quantidade de threads e a faixa de registros da tabela TRBA280
	@type  Function
	@author reynaldo
	@since 14/09/2020
	@version 1.0
	@param nenhum
	@return aThreads, vetor, A faixa de codigo de produto e local de estoque que vai ser utilizado
									por cada thread
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function M280QtdThr(cFilLog, cFilProc)
Local aAreaAnt  := GetArea()
Local aProdutos := {}
Local aThreads  := {}
Local cQuery    := ''
Local nX        := 0
Local nInicio   := 0
Local nRegProc  := 0
Local cAliasSB2
Local oPrepStat
Local cMessage


	//-- Define a string da query a ser processada
	cQuery := ""
	cQuery += "select count(*) TOTAL "
	cQuery += " from " +cTableTRB+ " TRB "
	cQuery += " where TRB.FILLOG = '"+cFilLog+"' "
	cQuery += " and TRB.FILIAL = '"+cFilProc+"' "
	cQuery := ChangeQuery(cQuery)
	nTotalReg := MpSysExecScalar(cQuery,"TOTAL")

	nThreads := 5 // Qtde de Threads que serao abertas

	//-- Analisa a quantidade de Threads X nRegistros
	If nTotalReg == 0
		aThreads := {}
	ElseIf nTotalReg < 20000
		aThreads := ARRAY(1)			// Processa somente em uma thread
	Else
		aThreads := ARRAY(nThreads)		// Processa com o numero de threads informada
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula o registro original de cada thread e     ³
	//³ aciona thread gerando arquivo de fila.           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX:=1 to Len(aThreads)

		aThreads[nX]:={0,1}

		// Registro inicial para processamento
		nInicio := IIf( nX == 1 , 1 , aThreads[nX-1,2]+1 )

		// Quantidade de registros a processar
		If nX == Len(aThreads)
			nRegProc += nTotalReg - nRegProc
		Else
			nRegProc += Int(nTotalReg/Len(aThreads))
		EndIf

		If oPrepStat == NIL
			cQuery := "update " +cTableTRB "
			cQuery += " set THREAD = ? "
			cQuery += " where FILLOG = ? "
			cQuery += " and FILIAL = ? "
			cQuery += " and ORDEM >= ? "
			cQuery += " and ORDEM <= ? "

			oPrepStat := FWPreparedStatement():New()
			oPrepStat:SetQuery( cQuery )

		EndIf

		oPrepStat:SetString(  1 ,Strzero(nX,2))
		oPrepStat:SetString(  2 ,cFilLog)
		oPrepStat:SetString(  3 ,cFilProc)
		oPrepStat:SetNumeric( 4 ,nInicio)
		oPrepStat:SetNumeric( 5 ,nRegProc)

		//Recupera a consulta já com os parâmetros injetados
		cQuery := oPrepStat:GetFixQuery()

		Begin Transaction

			// insere os registros na tabela de processamento
			If TcSqlExec(cQuery ) < 0
				cMessage := STR0142 + TCSQLError() // "Erro na listagem dos produtos para virada de saldo: "
				Final(cMessage)
			EndIf

		End Transaction

		aThreads[nX,1] := nInicio
		aThreads[nX,2] := nRegProc

	Next nX

	If oPrepStat <> NIL
		oPrepStat:Destroy()
	EndIf
	
	aProdutos := aSize(aProdutos,0)

	//-- Encerra cAliasSB2
	dbSelectArea(cAliasSB2)
	dbCloseArea()

RestArea(aAreaAnt)
Return aThreads

/*/{Protheus.doc} A280CreTRB
	Cria/Recria e abre a tabela TRBA280
	@type  Function
	@author reynaldo
	@since 15/10/2020
	@version 1.0
	@return lRet, Logico, Se verdadeiro se conseguiu fazer a abertura das tabelas
	@example
	(examples)
	@see (links_or_references)
	/*/
Function A280CreTRB(cTable,cAliasTRB)
	Local aStruct

	If TCCanOpen(cTable)
		//	A280DelIdx() // exclui a tabela e seus indices da tabela
		TCDelFile( cTable )
	EndIf
	aStruct := GetTRBStr()
	FWDBCreate(cTable,aStruct,"TOPCONN",.T.)

Return NIL


/*/{Protheus.doc} A280InsTRB
	Atualiza a tabela TRBA280 com os produtos para o fechamento de estoque
	@type  Function
	@author reynaldo
	@since 15/10/2020
	@version 1.0
	@return lRet, Logico, Se verdadeiro se conseguiu fazer a abertura das tabelas
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function A280InsTRB(cFilLogin,cFilAnt,dInicio,dFim)
	Local oPrepStat
	Local cQuery
	Local cMessage

	M280PrcLog("MENSAGEM","Stored Procedures: "+i18n(STR0130, {cFilAnt}),"Stored Procedures: "+i18n(STR0130, {cFilAnt})) //"Iniciando seleção dos produtos da filial #1[D MG 01]#" "+ cFilAnt)

	dInicio += 1

	oPrepStat := MATA280InsertStatement():New(cFilLogin,cFilAnt)
	oPrepStat:SetString( 1 ,xFilial("SB2"))
	oPrepStat:SetString( 2 ,xFilial("SB1"))
	oPrepStat:SetString( 3 ,xFilial("SD1"))
	oPrepStat:SetDate(   4 ,dInicio)
	oPrepStat:SetDate(   5 ,dFim)
	oPrepStat:SetString( 6 ,xFilial("SD2"))
	oPrepStat:SetDate(   7 ,dInicio)
	oPrepStat:SetDate(   8 ,dFim)
	oPrepStat:SetString( 9 ,xFilial("SD3"))
	oPrepStat:SetDate(  10 ,dInicio)
	oPrepStat:SetDate(  11 ,dFim)

	//Recupera a consulta já com os parâmetros injetados
	cQuery := oPrepStat:GetFixQuery()

	// insere os registros na tabela de processamento
	If TcSqlExec(cQuery ) < 0
		cMessage := STR0142 + TCSQLError() // "Erro na listagem dos produtos para virada de saldo: "
		Final(cMessage)
	EndIf

	A280UpdTrb(cFilLogin,cFilAnt)

	M280PrcLog("MENSAGEM","Stored Procedures: "+i18n(STR0131, {cFilAnt}),"Stored Procedures: "+i18n(STR0131, {cFilAnt}))	//"Finalizando seleção dos produtos da filial #1[D MG 01]#"

Return

Static Function A280UpdTrb(cFilLog,cFilProc)
Local lMV_RASTRO
Local lMV_LOCALIZ
Local cCodAnt
Local cRastro
Local cLocaliz
Local aQuerys
Local cQuery
Local cAliTRBP

	// processa a TRB, caso MV_LOTE e/ou Localiza esta ativo
	lMV_RASTRO := SuperGetMV("MV_RASTRO",.F.,"N") == "S"
	lMV_LOCALIZ := SuperGetMV("MV_LOCALIZ",.F.,"N") == "S"

	cQuery := ""
	cQuery += "select B2_COD, R_E_C_N_O_  "
	cQuery += " from " +cTableTRB+ " TRB "
	cQuery += " where TRB.FILLOG = '"+cFilLog+"' "
	cQuery += " and TRB.FILIAL = '"+cFilProc+"' "
	cQuery := ChangeQuery(cQuery)
	cAliTRBP := MPSysOpenQuery(cQuery,,)

	aQuerys := {}
	cCodAnt := ""
	While ! (cAliTRBP)->(Eof())
		If cCodAnt == (cAliTRBP)->B2_COD
		Else
			cCodAnt := (cAliTRBP)->B2_COD
			cRastro := iIf(lMV_RASTRO .AND. Rastro(cCodAnt),"1","0")
			cLocaliz := iIf(lMV_LOCALIZ .AND. Localiza(cCodAnt,.T.),"1","0")
		EndIf

		cQuery := "update "+cTableTRB+" "
		cQuery += " set B1_RASTRO = '" +cRastro+ "' "
		cQuery += ", B1_LOCALIZ = '" +cLocaliz+ "' "
		cQuery += " where R_E_C_N_O_ = " + cValtoChar((cAliTRBP)->R_E_C_N_O_)
		aAdd(aQuerys,cQuery)

		If Len(aQuerys) >2043
			a280ApplyQry(aQuerys)
			aQuerys := {}
		EndIf
		(cAliTRBP)->(dbSkip())
	EndDo
	(cAliTRBP)->(dbCloseArea())

	If Len(aQuerys) >0
		a280ApplyQry(aQuerys)
		aQuerys := {}
	EndIf

	aQuerys := aSize(aQuerys,0)

Return

Static Function a280ApplyQry(aQuerys)
Local nCnt
Local cQuery
Local cMessage

	Begin Transaction

		For nCnt := 1 To len(aQuerys)
			cQuery := aQuerys[nCnt]
			If TcSqlExec(cQuery) < 0
				cMessage := STR0143  +TCSQLError() // "Erro na identificacao de rastro e/ou localização: "
				Final(cMessage)
			EndIf
		Next nCnt
	End Transaction
Return

/*/{Protheus.doc} GetSB2Def
	Retorna um array com os campos a serem apresentados no SELECT a se feito na tabela SB1 e SB2
	@type  Function
	@author reynaldo
	@since 15/10/2020
	@version 1.0
	@return aFieds, array, array com alias, campo e nome virtual
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function GetSB2Def()
	Local aFields

	aFields := {}
	aadd(aFields, {"SB2", "B2_COD"    , NIL})
	aadd(aFields, {"SB2", "B2_LOCAL"  , NIL})
	aadd(aFields, {"SB2", "R_E_C_N_O_", "B2_SB2RECN","N",18,0})
	aadd(aFields, {"SB2", "B2_QFIM"   , NIL})
	aadd(aFields, {"SB2", "B2_VFIM1"  , NIL})
	aadd(aFields, {"SB2", "B2_VFIM2"  , NIL})
	aadd(aFields, {"SB2", "B2_VFIM3"  , NIL})
	aadd(aFields, {"SB2", "B2_VFIM4"  , NIL})
	aadd(aFields, {"SB2", "B2_VFIM5"  , NIL})
	aadd(aFields, {"SB2", "B2_VFIMFF1", NIL})
	aadd(aFields, {"SB2", "B2_VFIMFF2", NIL})
	aadd(aFields, {"SB2", "B2_VFIMFF3", NIL})
	aadd(aFields, {"SB2", "B2_VFIMFF4", NIL})
	aadd(aFields, {"SB2", "B2_VFIMFF5", NIL})
	aadd(aFields, {"SB2", "B2_QFIM2"  , NIL})
	aadd(aFields, {"SB2", "B2_QACLASS", NIL})
	aadd(aFields, {"SB2", "B2_CMFIM1" , NIL})
	aadd(aFields, {"SB2", "B2_CMFIM2" , NIL})
	aadd(aFields, {"SB2", "B2_CMFIM3" , NIL})
	aadd(aFields, {"SB2", "B2_CMFIM4" , NIL})
	aadd(aFields, {"SB2", "B2_CMFIM5" , NIL})
	aadd(aFields, {"SB2", "B2_CMRP1"  , NIL})
	aadd(aFields, {"SB2", "B2_CMRP2"  , NIL})
	aadd(aFields, {"SB2", "B2_CMRP3"  , NIL})
	aadd(aFields, {"SB2", "B2_CMRP4"  , NIL})
	aadd(aFields, {"SB2", "B2_CMRP5"  , NIL})
	aadd(aFields, {"SB2", "B2_VFRP1"  , NIL})
	aadd(aFields, {"SB2", "B2_VFRP2"  , NIL})
	aadd(aFields, {"SB2", "B2_VFRP3"  , NIL})
	aadd(aFields, {"SB2", "B2_VFRP4"  , NIL})
	aadd(aFields, {"SB2", "B2_VFRP5"  , NIL})

	aadd(aFields, {"SB1", "B1_SEGUM"  , NIL})
	aadd(aFields, {"SB1", "B1_CONV"   , NIL})
	aadd(aFields, {"SB1", "B1_CUSTD"  , NIL})
	aadd(aFields, {"SB1", "B1_MCUSTD" , NIL})
	aadd(aFields, {"SB1", "B1_CCCUSTO", NIL})
	aadd(aFields, {"SB1", "B1_LOCALIZ", NIL})
	aadd(aFields, {"SB1", "B1_RASTRO" , NIL})

Return aFields

/*/{Protheus.doc} GetTRBStr
	Retorna um array com a estrutura da tabela de processamento TRBA280
	@type  Function
	@author reynaldo
	@since 15/10/2020
	@version 1.0
	@return aFieds, array, array com nomes dos campos, tipo tamanho e decimais
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function GetTRBStr()
	Local aTamanho
	Local aCampos
	Local nLoop
	Local aStruct
	Local cNomeCampo
	Local cTypeField
	Local aFieldFilial

	// carrega os campos a serem consultados
	aCampos := GetSB2Def()

	// campo padrao de filial
	aTamanho := TamSX3("B2_FILIAL")
	cTypeField := FWSX3Util():GetFieldType( "B2_FILIAL" )
	aFieldFilial := {"C",aTamanho[1],aTamanho[2]}

	aStruct :={}
	// campo que armazena a filial logada
	aAdd(aStruct,{"FILLOG",aFieldFilial[1],aFieldFilial[2],aFieldFilial[3]})

	// campo que armazena em qual thread será processado
	aAdd(aStruct,{"THREAD","C",	2,0})

	// ordem dos registros para calculo da distribuição das thread
	aAdd(aStruct,{"ORDEM","N",18,0})

	// campo que armazena a filial selecionada para ser processado
	aAdd(aStruct,{"FILIAL",aFieldFilial[1],aFieldFilial[2],aFieldFilial[3]})

	For nLoop := 1 to len(aCampos)

		cNomeCampo := iIf(aCampos[nLoop,3] == NIL, aCampos[nLoop,2], aCampos[nLoop,3])

		cTypeField := FWSX3Util():GetFieldType( aCampos[nLoop,2] )

		If Empty(cTypeField) .AND. aCampos[nLoop,4] != NIL
			cTypeField := aCampos[nLoop,4]
			aTamanho := {aCampos[nLoop,5],aCampos[nLoop,6]}
		Else
			aTamanho := TamSX3(aCampos[nLoop,2])
		EndIf

		aAdd(aStruct,{cNomeCampo, cTypeField,aTamanho[1],aTamanho[2]})

	Next nLoop

	aCampos := aSize(aCampos,0)

Return aStruct

/*/{Protheus.doc} GetFldQry
	Formata os campos do array para que sejam utilizados em uma query SELECT
	@type  Function
	@author reynaldo
	@since 15/10/2020
	@version 1.0
	@return cQryFields, caracteres, campos que serão apresentadas no SELECT
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function GetFldQry()
	Local aCampos
	Local cQryFields
	Local nCount

	aCampos := GetSB2Def()

	cQryFields := ""
	For nCount := 1 to len(aCampos)

		cQryFields += aCampos[nCount,1]+"."+aCampos[nCount,2]
		If aCampos[nCount,3] <> NIL
			cQryFields += " "+aCampos[nCount,3]
		EndIf

		cQryFields += ", "

	Next nCount

	cQryFields := Left(cQryFields, Len(cQryFields)-2)

	aCampos := aSize(aCampos,0)

Return cQryFields

/*/{Protheus.doc} EqualsTrb
	Compara as estruturas da tabela TRBA280 gravada no banco com a sua definicao (GetTRBStr) estao iguais
	@type  Function
	@author reynaldo
	@since 15/10/2020
	@version 1.0
	@return lReCriar, Logico, Se verdadeiro existe diferenas na estrutura fisica com a definição
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function EqualsTrb(cAliasTRB, cTableTRB)
	Local aPadrao
	Local aAtual
	Local nCnt
	Local lEquals

	If Select(cAliasTRB)<=0
		dbUseArea(.T.,"TOPCONN",cTableTRB,cAliasTRB,.T.,.F.)
	EndIf

	If Select(cAliasTRB)<=0
		lEquals := .F.
	Else
		aAtual := (cAliasTRB)->(dbStruct())
		aPadrao := GetTRBStr()

		lEquals := len(aAtual) == len(aPadrao)

		If lEquals
			aSort(aAtual,,,{|x,y| x[1] < y[1]})
			aSort(aPadrao,,,{|x,y| x[1] < y[1]})
			For nCnt := 1 To Len(aAtual)
				If ! (aAtual[nCnt,2] == aPadrao[nCnt,2] ;
						.AND. aAtual[nCnt,3] == aPadrao[nCnt,3] ;
						.AND. aAtual[nCnt,4] == aPadrao[nCnt,4])

					lEquals := .F.
					Exit

				EndIf
			Next nCnt
		EndIf

		If Select(cAliasTRB)>0
			(cAliasTRB)->(dbCloseArea())
		EndIf
	EndIf

Return lEquals

/*/{Protheus.doc} MATA280InsertStatement
	Classe que monta a query de insert para a tabela TRBA280
	@type  Function
	@author reynaldo
	@since 15/10/2020
	@version 1.0
	@return lRet, Logico, Se verdadeiro se conseguiu fazer a abertura das tabelas
	@example
	(examples)
	@see (links_or_references)
	/*/
CLASS MATA280InsertStatement

	// Declaracao das propriedades da Classe
	DATA oStatment
	DATA cQryInsertFields
	DATA aParameters
	DATA MV_A280GRV
	DATA cFilialLogin
	DATA cFilialProcessada

	// Declaração dos Métodos da Classe
	METHOD New(cFilLogin,cFilAnt) CONSTRUCTOR
	METHOD SetQuerySelect()
	METHOD GetFixQuery()
	METHOD SetString(nPosicao, cValor)
	METHOD SetDate(nPosicao, dValor)

ENDCLASS

// Criação do construtor, onde atribuimos os valores default
// para as propriedades e retornamos Self
METHOD New(cFilLogin,cFilAnt) Class MATA280InsertStatement
	::oStatment := FWPreparedStatement():New()

	::MV_A280GRV := SuperGetMV('MV_A280GRV',.F.,.T.)

	::cFilialLogin := cFilLogin
	::cFilialProcessada := cFilAnt

	::SetQuerySelect()

Return Self

METHOD SetQuerySelect() Class MATA280InsertStatement
Local cQryFields
Local cQuery
Local cQrySelect
Local cQryInsertFields

	cQryFields := GetFldQry()

	cQuery := ""
	cQuery += "select '"+::cFilialLogin+"', '', ROW_NUMBER() OVER (ORDER BY B2_FILIAL, B2_COD, B2_LOCAL ), '"+::cFilialProcessada+"' ,"
	cQuery += cQryFields
	cQuery += " from "+RetSQLName("SB2")+" SB2 , "+RetSQLName("SB1")+" SB1 "
	cQuery += " where B2_FILIAL    = ? "
	cQuery += " and B1_FILIAL      = ? "
	cQuery += " and B1_COD         = B2_COD "
	cQuery += " and SB2.D_E_L_E_T_ = ' ' "
	cQuery += " and SB1.D_E_L_E_T_ = ' ' "
	If !::MV_A280GRV
		cQuery += "and ( B2_QFIM  <> 0 "
		cQuery += " or B2_VFIM1 <> 0 "
		cQuery += " or B2_VFIM2 <> 0 "
		cQuery += " or B2_VFIM3 <> 0 "
		cQuery += " or B2_VFIM4 <> 0 "
		cQuery += " or B2_VFIM5 <> 0 "

		cQuery += " or exists (select 1 "
		cQuery += " from "+RetSQLName("SD1")+" "
		cQuery += " where D1_FILIAL = ? "
		cQuery += " and D1_COD    = B2_COD "
		cQuery += " and D1_LOCAL  = B2_LOCAL "
		cQuery += " and D1_DTDIGIT between ? and ? "
		cQuery += " and D_E_L_E_T_ = ' ' ) "

		cQuery += " or exists (select 1 "
		cQuery += " from "+RetSQLName("SD2")+" "
		cQuery += " where D2_FILIAL = ? "
		cQuery += " and D2_COD   = B2_COD "
		cQuery += " and D2_LOCAL = B2_LOCAL "
		cQuery += " and D2_EMISSAO between ? and ? "
		cQuery += " and D_E_L_E_T_ = ' ' ) "

		cQuery += " or exists (select 1 "
		cQuery += " from "+RetSQLName("SD3")+" "
		cQuery += " where D3_FILIAL = ? "
		cQuery += " and D3_COD   = B2_COD "
		cQuery += " and D3_LOCAL = B2_LOCAL "
		cQuery += " and D3_EMISSAO between ? and ? "
		cQuery += " and D3_ESTORNO = ' ' "
		cQuery += " and D_E_L_E_T_ = ' ' ) "
		cQuery += " ) "
	EndIf

	cQrySelect := ChangeQuery(cQuery)

	cQryInsertFields := GetInsFld(GetTRBStr())
	cQuery := "INSERT INTO "+cTableTRB+" ( "+cQryInsertFields+" ) "
	cQuery += cQrySelect

	::oStatment:SetQuery(cQuery)

Return Self

METHOD GetFixQuery() Class MATA280InsertStatement
Local cQuery

	cQuery := ::oStatment:GetFixQuery()

Return cQuery


METHOD SetString(nPosicao, cValor) Class MATA280InsertStatement

	If !::MV_A280GRV .OR. (::MV_A280GRV .AND. nPosicao <3)
		::oStatment:SetString( nPosicao ,cValor)
	EndIf

Return Self

METHOD SetDate(nPosicao, dValor) Class MATA280InsertStatement

	If !::MV_A280GRV .OR. (::MV_A280GRV .AND. nPosicao <3)
		::oStatment:SetDate( nPosicao ,dValor)
	EndIf
Return Self


Static Function GetInsFld(aCampos)
	Local cQryFields
	Local nCount

	cQryFields := ""
	For nCount := 1 to len(aCampos)

		cQryFields += +aCampos[nCount,1]
		cQryFields += ", "

	Next nCount

	cQryFields := Left(cQryFields, Len(cQryFields)-2)

	aCampos := aSize(aCampos,0)

Return cQryFields

/*/{Protheus.doc} M280PrcLog
	Encapsula chamada da M280PrcLog para garantir gravação da filial da CV8 com a filial
	que está executando o processo.
	@type  Function
	@author reynaldo
	@since 04/11/2020
	@version 1.0
	@param cTipo, caracter, tipo do log a ser gerado
	@param cTexto, caracter, mensagem a ser gravada no log gerado
	@param cDetalhe, caracter, detalhe a ser gravado para o log gerado
/*/
Static Function M280PrcLog(cTipo,cTexto,cDetalhe, cStatus)
Default cStatus := " " 
oJourneyLog:LogProAtu(cTipo,cTexto,cDetalhe,cFilStart, cStatus,dDataBase,cFilAnt, lJourney)

Return

/*/{Protheus.doc} a280ConOut
	Imprime no console a mensagem
	@type  Function
	@author reynaldo
	@since 10/12/2020
	@version 1.0
	@param cMensagem, caracter, mensagem a ser impressa
	@return return_var, return_type, return_description
	/*/
Static Function a280ConOut(cMensagem)
	conout(cMensagem)
return NIL

/*/{Protheus.doc} A280Alert
	Abre uma janela com a mensagem de erro
	@type  Function
	@author reynaldo
	@since 10/12/2020
	@version 1.0
	@param cMsg1, caracter, primeira mensagem
	@param cMsg2, caracter, segunda mensagem
	@param cError, caracter, mensagem de erro vindo do dbaccess
	/*/
Function A280Alert(cMsg1, cMsg2, cError)
Local cTexto
Local cTitulo
Local oDlg
Local oFont
Local oMemo
Local lFinish

default cMsg1 := ""
default cMsg2 := ""

If !IsBlind()

	cTitulo := "Erro na chamada de procedimento armazenado do banco de dados"

	cTexto := cError

	lFinish := .F.

	__cFileLog := MemoWrite(Criatrab(, .F.) + ".log", cTexto)

	DEFINE FONT oFont NAME "Courier New" SIZE 8, 15
	DEFINE MSDIALOG oDlg TITLE cTitulo  From 3,0 to 340,427 PIXEL
	@ 05,05 SAY OemToAnsi(cMsg1) SIZE 150, 10 OF oDlg PIXEL // "Falha na geração de arquivo de trabalho."
	@ 15,05 SAY OemToAnsi(cMsg2) SIZE 150, 10 OF oDlg PIXEL // "Execução da procedure 004 do processo 19"
	@ 25,05 SAY OemToAnsi("Retorno de falha do banco de dados:") SIZE 150, 10 OF oDlg PIXEL
	@ 35,05 GET oMemo  VAR cTexto MEMO SIZE 200,110 OF oDlg PIXEL READONLY
	oMemo:bRClicked := {||AllwaysTrue()}
	oMemo:oFont:=oFont

	TButton():New( 153,150 , "Finalizar", oDlg,{||(oDlg:end(),lFinish:= .T.)} ,40,010,,,.F.,.T.,.F.,,.F.,,,.F. )

	ACTIVATE MSDIALOG oDlg CENTER

	If lFinish
		Quit
	EndIf
Else
	Quit
EndIf

Return

/*/{Protheus.doc} SldZeroSB9
	Recuperar dados SB9 com saldo zero na data de fechamento.
	@type  Function
	@author Henry
	@since 19/11/2021
	@version 1.0
	@param dDataFec, Date, Data fechamento
/*/
Static Function SldZeroSB9(dDataFec)

Local aAreaAtu	:= GetArea()
Local cAliasQry	:= GetNextAlias()

//--- Query para trazer saldo SB9 Zerados ---//
BeginSql Alias cAliasQry

SELECT 	
		B9_FILIAL,
		B9_COD,
		B9_LOCAL,
		B9_QINI, 
		B9_VINI1,
		B9_DATA 
  FROM %Table:SB9% SB9
 WHERE SB9.%notDel%
   AND 	B9_DATA = %exp:dDataFec%   
   AND  B9_QINI = 0
ORDER BY  
	B9_FILIAL	
    ,B9_COD

EndSQL

DbselectArea(cAliasQry)
DbGoTop()
While (cAliasQry)->( !Eof() )

	SldZero((cAliasQry)->B9_FILIAL, (cAliasQry)->B9_COD, (cAliasQry)->B9_LOCAL, dDataFec, (cAliasQry)->B9_VINI1)

	(cAliasQry)->( DbSkip() )
EndDo
(cAliasQry)->( DbCloseArea() )

RestArea(aAreaAtu)

Return

/*/{Protheus.doc} SldZero
	Quando saldo for alimentado na SB9 com valor igual a ZERO, também alimenta a SCC
	@type  Function
	@author Henry
	@since 10/11/2021
	@version 1.0
	@param _cFilial, caracter, Filial
	@param _cProd, caracter, Código do produto
	@param _cLocal, caracter, Local armazem do produto
	@param dDataFec, Date, Data fechamento
	@param nValIni, Numeric, Valor inicial
/*/
Static Function SldZero(_cFilial, _cProd, _cLocal, dDataFec, nValIni)
	Local aArea := GetArea()

	DbSelectArea("SCC")
	RecLock("SCC", .T.)
		Replace CC_FILIAL	With _cFilial
		Replace CC_PRODUTO 	With _cProd
		Replace CC_QINI 	With 0
		Replace CC_VFIMFF1	With nValIni
		Replace CC_LOCAL 	With _cLocal
		Replace CC_DATA   	With dDataFec
	MsUnlock()

	A228Atu(1)

	RestArea(aArea)
	
Return

/*/{Protheus.doc} EngPre17Compile
Funcao executada antes da compilacao das procedures (Pre-Compile)
Cria as tabelas temporárias dos processos
IMPORTANTE:
- Essa função não podem ter interface alguma, nem interação com usuário.
- Todo e qualquer erro retornado deverá ser armazenado na variável "cError" que
  é enviada por referência.
Neste caso se trata do pacote 17 - MATA280 Virada de Saldos()
@type function
@version 1.0
@author reynaldo
@since 21/12/2021
@param cProcesso, character, Codigo do processo
@param cEmpresa, character, Codigo da empresa
@param cError, character, Passada por referencia, deve conter a mensagem de erro caso ocorra
@return logical, .T. caso tudo ok
/*/
Function EngPre17Compile(cProcesso as character, cEmpresa as character, cError as character)
	Local cNomeTab := "0_SP"

	A280CreTRB("TRB"+cEmpresa+cNomeTab+"MATA280") // cria da tabela de processamento

	If TcCanOpen("TRC"+cEmpresa+cNomeTab)
		If TCCanOpen("TRC"+cEmpresa+cNomeTab, "TRC"+cEmpresa+cNomeTab+"01")
			TcDelIndex("TRC"+cEmpresa+cNomeTab,"TRC"+cEmpresa+cNomeTab+"01")
		EndIf
		TcDelFile("TRC"+cEmpresa+cNomeTab)
	EndIf

	aCampos:= GetTRCStru() // Esta FunÃ§Ã£o esta codificada no arquivo MATXFUNA.PRX
	EngSPSWorkTable("","TRC"+cEmpresa+cNomeTab,aCampos,.T.)
	TcSqlExec("Create index TRC"+cEmpresa+cNomeTab+"01 on " + "TRC"+cEmpresa+cNomeTab+"( TRC_COD )")

	If FindFunction('GetTRJStru')
		If TcCanOpen("TRJ"+cEmpresa+cNomeTab)
			If TCCanOpen("TRJ"+cEmpresa+cNomeTab, "TRJ"+cEmpresa+cNomeTab+"01")
				TcDelIndex("TRJ"+cEmpresa+cNomeTab,"TRJ"+cEmpresa+cNomeTab+"01 ")
			EndIf
			TcDelFile("TRJ"+cEmpresa+cNomeTab)
		EndIf
		aCampos:= GetTRJStru() // Esta FunÃ§Ã£o esta codificada no arquivo MATXFUNA.PRX
		EngSPSWorkTable("","TRJ"+cEmpresa+cNomeTab,aCampos,.T.)
		TcSqlExec("Create index TRJ"+cEmpresa+cNomeTab+"01 on " + "TRJ"+cEmpresa+cNomeTab+"( BJ_FILIAL, BJ_COD, BJ_LOCAL, BJ_LOTECTL, BJ_NUMLOTE, BJ_DATA, D_E_L_E_T_ )")
	EndIf

	If FindFunction('GetTRKStru')
		If TcCanOpen("TRK"+cEmpresa+cNomeTab)
			If TCCanOpen("TRK"+cEmpresa+cNomeTab, "TRK"+cEmpresa+cNomeTab+"01")
				TcDelIndex("TRK"+cEmpresa+cNomeTab,"TRK"+cEmpresa+cNomeTab+"01 ")
			EndIf
			TcDelFile("TRK"+cEmpresa+cNomeTab)
		EndIf
		aCampos:= GetTRKStru() // Esta FunÃ§Ã£o esta codificada no arquivo MATXFUNA.PRX
		EngSPSWorkTable("","TRK"+cEmpresa+cNomeTab,aCampos,.T.)
		TcSqlExec("Create index TRK"+cEmpresa+cNomeTab+"01 on " + "TRK"+cEmpresa+cNomeTab+"( BK_FILIAL, BK_COD, BK_LOCAL, BK_LOTECTL, BK_NUMLOTE, BK_LOCALIZ, BK_NUMSERI, BK_DATA, D_E_L_E_T_ )")
	EndIf

Return .T.

/*/{Protheus.doc} EngOn17Compile
Funções executadas durante a compilação da procedure.('On Compile')
Faz a adaptação do código original da procedure, substituindo as tags '###' pela
sequência específica de acordo com a regra de negócio da área responsável pelo
processo.
IMPORTANTE:
- Essa função não podem ter interface alguma, nem interação com usuário.
- Todo e qualquer erro retornado deverá ser armazenado na variável "cError" que
  é enviada por referência.
Neste caso se trata do pacote 17 - MATA280 Virada de Saldos()
@type function
@version 1.0
@author reynaldo
@since 21/12/2021
@param cProcesso, character, Codigo do processo
@param cEmpresa, character, Codigo da empresa
@param cProcName, character, Nome da stored procedure
@param cBuffer, character, Codigo original da procedure (corpo da procedure)
@param cError, character, Passada por referencia, deve conter a mensagem de erro caso ocorra
@return logical, .T. caso tudo ok
/*/
Function EngOn17Compile(cProcesso as character, cEmpresa as character, cProcName as character, cBuffer as character, cError as character)
	Local cNomeTab := "0_SP"

	// Faz a troca das tags "###" nos nomes de tabelas especÃ­ficas do processo
	cBuffer := StrTran( cBuffer, "TRB###", "TRB"+cEmpresa+cNomeTab )
	cBuffer := StrTran( cBuffer, "TRC###", "TRC"+cEmpresa+cNomeTab )
	cBuffer := StrTran( cBuffer, "TRJ###", "TRJ"+cEmpresa+cNomeTab )
	cBuffer := StrTran( cBuffer, "TRK###", "TRK"+cEmpresa+cNomeTab )

Return .T.

/*/{Protheus.doc} EngSPS17Delete
 Funções executadas durante a desinstalação dos processos ('On Uninstall')
 Faz a exclusão das tabelas da classe "TR". Essas tabelas recebem nomes distintos
 e são usadas apenas por alguns processos.
 Neste caso se trata do pacote 17 - MATA280 Virada de Saldos()
IMPORTANTE:
- Esse tipo de função deverá ser desenvolvida pelas áreas donas dos processos.
- Essas funções não podem ter interface alguma, nem interação com usuário.
- Todo e qualquer erro retornado deverá ser armazenado na variável "cError" que
  é enviada por referência.
@type function
@version 1.0
@author reynaldo
@since 21/12/2021
@param cProcesso, character, Codigo do processo
@param cEmpresa, character, Codigo da empresa
@param cError, character, Passada por referencia, deve conter a mensagem de erro caso ocorra
@return logical, .T. caso tudo ok
/*/
Function EngSPS17Delete(cProcesso as character, cEmpresa as character, cError as character)
	Local cIndexName as character
	Local cNomeTab   as character
	Local cTableName as character

	cIndexName := ""
	cNomeTab   := "0_SP"

	cTableName := "TRC"+cEmpresa+cNomeTab
	If TcCanOpen(cTableName)
		cIndexName := cTableName+"01"
		If TCCanOpen(cTableName, cIndexName )
			TcDelIndex(cTableName,cIndexName)
		EndIf
		TcDelFile(cTableName)
	EndIf

	cTableName := "TRJ"+cEmpresa+cNomeTab
	If TcCanOpen(cTableName)
		cIndexName := cTableName+"01"
		If TCCanOpen(cTableName, cIndexName )
			TcDelIndex(cTableName,cIndexName)
		EndIf
		TcDelFile(cTableName)
	EndIf

	cTableName := "TRK"+cEmpresa+cNomeTab
	If TcCanOpen(cTableName)
		cIndexName := cTableName+"01"
		If TCCanOpen(cTableName, cIndexName )
			TcDelIndex(cTableName,cIndexName)
		EndIf
		TcDelFile(cTableName)
	EndIf

	cTableName := "TRB"+cEmpresa+cNomeTab+"MATA280"
	If TcCanOpen(cTableName)
		TcDelFile(cTableName)
	EndIf

Return .T.

/*/{Protheus.doc} EngSPS17Signature
 Retornar a assinatura da rotina MATA280.PRX responsável pelo processo 17 - MATA280 Virada de Saldos.
 Neste caso se trata do pacote 17 - MATA280 Virada de Saldos()
IMPORTANTE:
- Essa função não podem ter interface alguma, nem interação com usuário.
@type function
@version 1.0
@author reynaldo
@since 21/12/2021
@param cProcesso, character, Codigo do processo
@return logical, .T. caso tudo ok
/*/
Function EngSPS17Signature(cProcesso as character)
	Local cAssinatura as character

	cAssinatura := VERIDPROC()

Return cAssinatura


/*/{Protheus.doc} ExportDivergenceRecords
    (long_description)
    @type  Function
    @author user
    @since date
    @version version
    @param param, param_type, param_descr
    @return return, return_type, return_description
    @example
    (examples)
    @see (links_or_references)
/*/
Function ExportDivergenceRecords(aLogs)

Local oDivergenceService  := EstAcMiddle('ac.acDivergence.service', 'acDivergenceService():New()')

If Valtype(oDivergenceService) == 'O'
	oDivergenceService:dataDivergence(OJOURNEYLOG:cIdParent, aLogs, cFilAnt)
Endif

Return

/*/{Protheus.doc} MTA280Perg
    (long_description)
    @type  Function
    @author user
    @since date
    @version version
    @param param
    @return
    @example
    (examples)
    @see (links_or_references)
/*/
Function MTA280Perg(lTela)
Local ni
Default lTela := .T.

If lTela
	pergunte("MTA280",.T.)
Else
	If Type("aAuto280")=="A" .And. Len(aAuto280) == 4
		a280ParamZX := aClone(aAuto280)
		For ni := 1 to 4
			&("mv_par"+StrZero(ni,2)) := a280ParamZX[ni]
		Next ni
	Else	
		Pergunte("MTA280",.F.)
	EndIf
EndIf

Return .T.

/*/{Protheus.doc} ExportDivergenceRecords
    (long_description)
    @type  Function
    @author user
    @since date
    @version version
    @param param, param_type, param_descr
    @return return, return_type, return_description
    @example
    (examples)
    @see (links_or_references)
/*/
Static Function GravaD3Y(aFils, dDataFec)

Local cType 	:= 'SB9'
Local cStruct   := '{"closing":{"mta280":[]},"contabilization":{"mta331":[]},"recalculation":{"mta330":[]}}'
Local cParams 	:= '{"params": [], "branches": []}'
Local lMiddle 	:= FindFunction('EstAcMiddle')
Local oBranchs 	:= Nil
Local oFilsProc := JsonObject():new()

If lMiddle
	oBranchs := EstAcMiddle('ac.branchesList.Serv', 'acBranchesListServ():New()')
Endif

If lMiddle .and. Valtype(oBranchs) == 'O'

	If oJourneyLog:nCondition == 1
		oJourneyLog:updateD3YPositi('MATA280')
	ElseIf oJourneyLog:nCondition == 2
		oFilsProc["branches"]:=   oBranchs:listBranchesinformated(aFils)
		oJourneyLog:InsertD3y(oJourneyLog:cIdParent, 'T', 'FN', '', cStruct, cType, cParams,;
		oJourneyLog:cIdChild, oFilsProc:GetJsonText("branches"),dtoc(dDataFec), .T., .T.)
	Endif
Endif

Return	

/*/{Protheus.doc} nomeFunction
	(long_description)
	@type  Function
	@author user
	@since 27/09/2021
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Function A280Event(cIDEvent,cTitle,cMessage)
    EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cIDEvent, FW_EV_LEVEL_INFO, "",cTitle, cMessage, .T. ) 
Return 

/*/{Protheus.doc} nomeFunction
	(long_description)
	@type  Function
	@author user
	@since 27/09/2021
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
/*/

Function A280Legacy() 

Return getLegacy()

/*/{Protheus.doc} a280PE280OK
	Funcao que executa o Ponto de Entrada A280OK
	@type  Function
	@author pedro.missaglia
	@since 03/08/2022
	@version 1.0
	@param dDataFec
	@return lRet
/*/

Static Function M280PE280OK(dDataFec) 

Local lRet 		:= .T.
Local xRet 		:= .T.
Local cMessage 	:= ""

If ExistBlock("A280OK")
	xRet :=	ExecBlock("A280OK",.F.,.F.,{dDataFec})
	If ValType(xRet) # "L" .AND. ValType(xRet) # "A"
		lRet := .T.
		xRet := lRet
	Else 
		If ValType(xRet) == "L"
			lRet := xRet
			cMessage := ""
		Else 
			If Len(xRet) > 0
				If ValType(xRet[1]) == "L"
					lRet := xRet[1]
				Else 
					lRet := .T.
					xRet[1] := .T.
				Endif

				If Len(xRet) > 1
					If ValType(xRet[2]) == "C"
						cMessage 	:= xRet[2]
					Else 
						cMessage := ""
						xRet[2] := ""
					Endif
				Else
					cMessage := ""
				Endif
			Else
				lRet := .T.
				xRet := lRet
				cMessage := ""
			Endif 
		Endif
	EndIf
Endif

If !lRet
	M280PrcLog("ERRO",STR0154 + " - A280OK ", STR0155 + Chr(13)+Chr(10) + cMessage ,"ER") 
Endif

return lRet 
