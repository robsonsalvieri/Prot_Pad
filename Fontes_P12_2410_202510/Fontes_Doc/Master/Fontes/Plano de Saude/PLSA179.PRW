
#include "PLSMGER.CH"
/*/


Ŀ
Programa   PLSA179  Autor  Paulo Carnelossi      Data    13.06.03 
Ĵ
Descrio  Cadastro de Formas de Bloqueio do Sub-Contrato             
Ĵ
Uso        Advanced Protheus 7.10                                     
Ĵ
Parametros Nenhum                                                     
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Alterao                     
Ĵ
ٱ


/*/
Function PLSA179

//Ŀ
// Define variaveis...                                                 
//
LOCAL   aRotAux   := {}
LOCAL   nNr
PRIVATE aRotina   := MenuDef()
PRIVATE cCadastro := fundesc()
PRIVATE cAlias    := "BQU"
//Ŀ
// Chama funcao de Browse...                                           
//
BQU->(dbGoTop())
 
   If ExistBlock("PL179MEN")
      aRotAux := ExecBlock("PL179MEN",.F.,.F.,{})

      If ValType(aRotAux) == "A"
         for nNr := 1 to Len(aRotAux)
            AAdd(aRotina, aRotAux[nNr])
         Next
      EndIf	
   EndIf

BQU->(mBrowse(06,01,22,75,"BQU"))
//Ŀ
// Fim da Rotina...                                                    
//

Return
/*/


Ŀ
Programa   PLSA179MOV Autor  Paulo Carnelossi    Data    13.06.03 
Ĵ
Descrio  Monto uma enchoice especifica para a exclusao              
Ĵ
Parametros Nenhum                                                     
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Alterao                     
Ĵ
ٱ


/*/                     
Function PLSA179MOV(cAlias,nReg,nOpc)
Local I__f := 0
Local nRetorno	:= 0

//Ŀ
// Define variaveis da EnchoiceBar...                                  
//
LOCAL bOK     := {|| nOpca := 1,If( PLSA179OK(M->BQU_CODBLO), ;
                      oDlg:End(),nOpca:=2),If(nOpca==1,oDlg:End(),.F.) }
LOCAL bCancel := {||oDlg:End()}
//Ŀ
// Define variaveis genericas...                                       
//
PRIVATE nOpcx        := nOpc
PRIVATE nOpca        := 0
//Ŀ
// Define variaveis da enchoice...                                     
//
PRIVATE aTELA[0][0]
PRIVATE aGETS[0]   
//Ŀ
// Define variaveis para controle de forma de pagamento...             
//
PRIVATE aSTela  := {}
//Ŀ
// Define Dialogo...                                                   
//
PRIVATE oDlg

If nOpc == K_Incluir
	
	nRetorno := AxInclui(cAlias,nReg,K_Incluir)

ElseIf nOpc == K_Alterar
	
	nRetorno := AxAltera(cAlias,nReg,K_Alterar)

ElseIf nOpc == K_Excluir
   //Ŀ
   // Monta ,M->??? para enchoice...                                       
   //
   Copy cAlias TO MEMORY
   //Ŀ
   // Define dialogo...                                                   
   //
   SetEnch("") 
   DEFINE MSDIALOG oDlg TITLE cCadastro FROM ndLinIni,ndColIni TO ndLinFin,ndColFin OF GetWndDefault()
   //Ŀ
   // Monta Enchoice dos Dados Gerais ...                                 
   //
   Zero();MsMGet():New(cAlias,nReg,nOpc,,,,,{012,001,195,356},,,,,,oDlg,,,.F.)
   //Ŀ
   // Ativa o dialogo...                                                  
   //
   ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,bOK,bCancel,.F.,{})
   //Ŀ
   // Trata atualizacao dos dados...  
   //
   If nOpca == K_OK
      //Ŀ
      // Inicio da Transacao...                                              
      // 
      Begin Transaction
      PLUPTENC("BQU",nOpc)
      End Transaction
   Endif
EndIf

If nRetorno == 1 .And. nOpc <> K_Excluir .And. ExistBlock("PL179GRV")
	   
	ExecBlock("PL179GRV",.F.,.F.,{nOpc})

EndIf
      
Return

/*/


Ŀ
Programa   PLS179New  Autor  Paulo Carnelossi    Data  13.06.03   
Ĵ
Descrio  Busca novo codigo para bloqueio de Sub-contrato            
Ĵ
Parametros Nenhum                                                     
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Alterao                     
Ĵ
ٱ


/*/                     
Function PLS179New(cPropri)
//Ŀ
// Busca o proximo codigo...                                                
//
LOCAL cNew

BQU->(DbSetOrder(1))
                                                                         
If cPropri == "9"
   BQU->(DbSeek(xFilial("BQU")+cPropri+"99"))
Else
   If cPropri == "1"
      BQU->(DbSeek(xFilial("BQU")+"9"))
   Endif
Endif
BQU->(DbSkip(-1))

If BQU->BQU_PROPRI == cPropri
   cNew := cPropri+StrZero(Val(Subs(BQU->BQU_CODBLO,2,2))+1,2)
Else
   cNew := cPropri+"01"
Endif

Return(cNew)

/*/


Ŀ
Programa   PLS179VLD  Autor  Paulo Carnelossi    Data  13.06.03   
Ĵ
Descrio  Verifica se o campo rdmake foi utilizado                   
Ĵ
Parametros Nenhum                                                     
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Alterao                     
Ĵ
ٱ


/*/                     
Function PLS179VLD()
Return(M->BQU_PERBLO == "0" .And. M->BQU_PROPRI <> "1")

/*/


Ŀ
Programa   PLSA179OK  Autor  Paulo Carnelossi    Data  13.06.03   
Ĵ
Descrio  Verifica se existe algum sub-contrato com esse codigo de   
           bloqueio                                                   
Ĵ
Parametros Nenhum                                                     
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Alterao                     
Ĵ
ٱ


/*/                     
Function PLSA179OK(cCodBlo)
                     
LOCAL nRecBQC := BQC->(Recno())
LOCAL nOrdBQC := BQC->(IndexOrd())
LOCAL cInd    := CriaTrab(Nil,.F.)
LOCAL cFor    := ""
LOCAL lRet    := .T.
//Ŀ
// Monta Expressao de filtro...                                             
//
cFor := "BQC_FILIAL = '"+xFilial("BQC")+"' .And. "
cFor += "BQC_CODBLO == '"+cCodBlo+"'"
//Ŀ
// Monta filtro de acordo com os grupos informados no parametro...          
//
BQC->(IndRegua("BQC",cInd,"BQC_CODBLO",nil,cFor,nil,.T.))
//Ŀ
// Posicione no primeiro registro no arquivo de usuarios...                 
//
If !BQC->(EOF())
   Alert("Existe algum contrato bloqueado com esse motivo !")
   lRet := .F.
Endif
   
//Ŀ
// Restaura dados salvados...                                          
//
BQC->(DbSetOrder(nOrdBQC))
BQC->(DbGoTo(nRecBQC))   
      
Return(lRet)

/*/


Ŀ
Programa  MenuDef    Autor  Darcio R. Sporl        Data 05/01/2007
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          		1 - Pesquisa e Posiciona em um Banco de Dados           
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/
Static Function MenuDef()
Private aRotina := {    { STRPL01    , 'AxPesqui'   	   , 0 , K_Pesquisar  , 0, .F.},; 
							 	{ STRPL02	, 'AxVisual' 		   , 0 , K_Visualizar  , 0, Nil},;
         				     	{ STRPL03  	, 'PLSA179MOV' 		       , 0 , K_Incluir        , 0, Nil},;
      						  	{ STRPL04	, 'PLSA179MOV' 		   , 0 , K_Alterar       , 0, Nil},;
      						  	{ STRPL05	, 'PLSA179MOV'   , 0 , K_Excluir      , 0, Nil}}
Return(aRotina)
