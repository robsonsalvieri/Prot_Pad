
#include "PLSMGER.CH"
#include "PROTHEUS.CH"

/*/


Ŀ
Programa   PLSA766  Autor  Antonio / Tulio Byte  Data  13.12.2002 
Ĵ
Descrio  Cria as vidas                                              
ٱ

            	
/*/
Function PLSA766
LOCAL nQtd   := 0
LOCAL nTotal := 0
	//Ŀ
// Define ordem padrao pelo CPF...                                          
//
BA1->(DbSetOrder(4))
BA1->(MsSeek(xFilial("BA1")))
//Ŀ
// Navega por todos os usuarios da base de dados...                         
//
While ! BA1->(Eof())
      //Ŀ
      // Acumula qtd...                                                           
      //
      nQtd   ++    
      nTotal ++
      
      If nQtd == 100
         nQtd := 0
      Endif                                            
      
     PLSA766ANV()

//Ŀ
// Grava a vida nova ou posicionada...                                      
//
BA1->(RecLock("BA1",.F.))                         
BA1->BA1_MATVID := BTS->BTS_MATVID
BA1->(MsUnlock())
//Ŀ
// Navega para outro usuario...                                             
//
BA1->(DbSkip())
Enddo
//Ŀ
// Fim da Rotina...                                                         
//
Return
/*/


Ŀ
Programa  PLSA766Vid Autor  Antonio / Tulio Byte  Data  13.12.2002 
Ĵ
Descrio  Cria as vidas                                              
ٱ


/*/                                                                                                  
Function PLSA766Vid(cAlias)
LOCAL cCodVid := ''
DEFAULT cAlias := 'BA1'
//Ŀ
// Busca o novo codigo de vida...                                           
//
cCodVid := BTS->(GetSx8Num("BTS","BTS_MATVID"))
//Ŀ
// grava a vida fisicamente...                                              
//
BTS->(RecLock("BTS",.T.)) 
BTS->BTS_FILIAL := xFilial("BTS")
BTS->BTS_MATVID := cCodVid
BTS->BTS_NOMUSR := &(cAlias+"->BA1_NOMUSR")
BTS->BTS_NOMCAR := &(cAlias+"->BA1_NOMUSR")
BTS->BTS_SEXO   := &(cAlias+"->BA1_SEXO")
BTS->BTS_ESTCIV := &(cAlias+"->BA1_ESTCIV")
BTS->BTS_CPFUSR := &(cAlias+"->BA1_CPFUSR")
BTS->BTS_DRGUSR := &(cAlias+"->BA1_DRGUSR")
BTS->BTS_ORGEM  := &(cAlias+"->BA1_ORGEM" )
BTS->BTS_CEPUSR := &(cAlias+"->BA1_CEPUSR")
BTS->BTS_ENDERE := &(cAlias+"->BA1_ENDERE")
BTS->BTS_NR_END := &(cAlias+"->BA1_NR_END")
BTS->BTS_COMEND := &(cAlias+"->BA1_COMEND")
BTS->BTS_BAIRRO := &(cAlias+"->BA1_BAIRRO")
BTS->BTS_MUNICI := &(cAlias+"->BA1_MUNICI")                                                        
BTS->BTS_ESTADO := &(cAlias+"->BA1_ESTADO")
BTS->BTS_TELEFO := &(cAlias+"->BA1_TELEFO")
BTS->BTS_DATNAS := &(cAlias+"->BA1_DATNAS")
BTS->BTS_UNIVER := &(cAlias+"->BA1_UNIVER")
BTS->BTS_MAE    := &(cAlias+"->BA1_MAE")
BTS->BTS_PAI    := &(cAlias+"->BA1_PAI")
BTS->BTS_INTERD := "0"
BTS->BTS_CORNAT := "6"
BTS->BTS_SANGUE := &(cAlias+"->BA1_SANGUE")
BTS->BTS_CODMUN := &(cAlias+"->BA1_CODMUN")

If BTS->(FieldPos("BTS_TIPDOC")) > 0 .And. BA1->(FieldPos("BA1_TIPDOC")) > 0
   BTS->BTS_TIPDOC := &(cAlias+"->BA1_TIPDOC")
Endif

If BTS->(FieldPos("BTS_DRGUSR")) > 0 .And. BA1->(FieldPos("BA1_TIPDOC")) > 0
   BTS->BTS_DRGUSR := &(cAlias+"->BA1_DRGUSR")
Endif

If BA1->(FieldPos("BA1_NRCRNA")) > 0 
   BTS->BTS_NRCRNA := &(cAlias+"->BA1_NRCRNA")
Endif 

BTS->(MsUnlock())
ConfirmSX8()       

//Ŀ
// Ponto de entrada para gravar novos dados na tabela BTS                   
//
If ExistBlock("PLS766GRV") 
    ExecBlock("PLS766GRV",.F.,.F.)    
EndIf    
//Ŀ
// Fim da Rotina...                                                         
//
Return
/*/


Ŀ
Programa  PLSA766ANV Autor  Antonio / Tulio Byte Data  13.12.2002 
Ĵ
Descrio  Cria as vidas                                              
ٱ


/*/
Function PLSA766ANV(lDireto,lPergVid)
LOCAL cNomUsr 	:= ''
LOCAL cDatNas 	:= cTod('')
LOCAL nRegBTS	:= 0
LOCAL aVidas	:= {}

DEFAULT lDireto := .F.     
DEFAULT lPergVid := .T.

//Ŀ
// << CPF >> Procura pelo CPF...                                            
//
BTS->(DBSetOrder(3))
If BTS->(MsSeek(xFilial("BTS")+BA1->BA1_CPFUSR)) .And. ! Empty(BA1->BA1_CPFUSR) .And. Subs(BA1->BA1_CPFUSR,1,11) <> "00000000000" .And. dtos(BA1->BA1_DATNAS) == dtos(BTS->BTS_DATNAS)
	
Else
	If !lDireto
		//Ŀ
		// << NOME + DATA DE NASCIMENTO >>                                          
		//
		BTS->(DbSetOrder(5))
		If BTS->(MsSeek(xFilial("BTS")+BA1->BA1_NOMUSR+dTos(BA1->BA1_DATNAS)))
			cNomUsr := BTS->BTS_NOMUSR
			cDatNas := BTS->BTS_DATNAS
			nRegBTS := BTS->( Recno() )
			
			While !BTS->( Eof() ) .and. BTS->BTS_NOMUSR == cNomUsr .and.;
				dTos(BTS->BTS_DATNAS) == dTos(cDatNas)
				
				Aadd(aVidas, {BTS->BTS_MATVID, BTS->BTS_NOMUSR,;
				BTS->BTS_DATNAS, BTS->BTS_MAE, BTS->(Recno())} )
				
				BTS->( dbSkip() )
			Enddo
			
			If lPergVid .And. PLS766BRW(aVidas)
			Else
				//Ŀ
				// Caso nao seja selecionada nenhuma vida pelo browse...                    
				//
				PLSA766VID()
			Endif
		Else
			//Ŀ
			// Nao existe na vida agora vou incluir pela primeira vez na vida...        
			//
			PLSA766VID()
		EndIf
	Else
		PLSA766VID()
	Endif
Endif

Return


/*


ͻ
Programa  PLS766BRW Autor  Geraldo Felix Junior Data   14/04/05   
͹
Desc.      Mostra browse com as vidas de mesmo nome e mesma data de   
           nascimento para relecao de uma delas.                      
͹
Uso        AP                                                        
ͼ


*/
Static Function PLS766BRW(aVidas)
LOCAL oDlgUsu
LOCAL oListaUsr                      
LOCAL lRet := .F.
LOCAL bOk 		:= {|| lRet := .T., BTS->( dbGoto(aVidas[oListaUsr:nAt][5]) ), oDlgUsu:End() }
LOCAL bCancel   := {|| Iif(MsgYesNo("Cancelando a selecao, sera criada uma nova vida!"),;
						(lRet := .F., oDlgUsu:End()), .T.) }

// variaveis lgpd 
local objCENFUNLGP  := CENFUNLGP():New()
local aCamposCen  	:= {}
local aBls  		:= {}

DEFINE MSDIALOG oDlgUsu TITLE "Vidas" FROM 012,005 TO 28, 100 

oListaUsr := TcBrowse():New( 013, 002, 372, 062,,,, oDlgUsu,,,,,,,,,,,, .F.,, .T.,, .F., )
oListaUsr:SetArray(aVidas)

oListaUsr:AddColumn(TcColumn():New("Matricula ",nil,;
nil,nil,nil,nil,050,.F.,.F.,nil,nil,nil,.F.,nil))
oListaUsr:ACOLUMNS[1]:BDATA     := { || aVidas[oListaUsr:nAt,1] }

oListaUsr:AddColumn(TcColumn():New("Nome",nil,;
nil,nil,nil,nil,125,.F.,.F.,nil,nil,nil,.F.,nil))
oListaUsr:ACOLUMNS[2]:BDATA     := { || aVidas[oListaUsr:nAt,2] }

oListaUsr:AddColumn(TcColumn():New("Data de nasc",nil,;
nil,nil,nil,nil,050,.F.,.F.,nil,nil,nil,.F.,nil))
oListaUsr:ACOLUMNS[3]:BDATA     := { || aVidas[oListaUsr:nAt,3] }

oListaUsr:AddColumn(TcColumn():New("Nome da mae",nil,;
nil,nil,nil,nil,100,.F.,.F.,nil,nil,nil,.F.,nil))
oListaUsr:ACOLUMNS[4]:BDATA     := { || aVidas[oListaUsr:nAt,4] }

if objCENFUNLGP:isLGPDAt()
	aCamposCen := {"BTS_MATVID", "BTS_NOMUSR", "BTS_DATNAS", "BTS_MAE"}
	aBls := objCENFUNLGP:getTcBrw(aCamposCen)

	oListaUsr:aObfuscatedCols := aBls
endif

oListaUsr:BLDBLCLICK := bOk

TButton():New(090,105,"Confirmar",,bOK    ,030,010,,,,.T.) //Boto Confirmar
TButton():New(090,150,"Cancelar" ,,bCancel,030,010,,,,.T.) //Boto Cancelar

ACTIVATE MSDIALOG oDlgUsu /*ON INIT Eval({||EnChoiceBar(oDlgUsu,{||Eval(bOk)},{||Eval(bCancel)},.F.)} )*/

Return(lRet)


/*/


Ŀ
Programa  PL766VALD	 Autor  Daher				   Data  23.02.2005 
Ĵ
Descrio  Verifica duplicidade no cadst de vidas                     
ٱ


/*/
Function PL766VALD
//Ŀ
// Declaracao de variaveis...                                          
//
LOCAL aSays     := {}
LOCAL aButtons  := {}
LOCAL cPerg     := "PLS766"
LOCAL cCadastro := "Verificao de duplicidade no cadastro de vidas"

//Ŀ
// Monta texto para janela de processamento                                 
//
AADD(aSays,"Programa que lista as duplicidades encontradas no cadastro de vidas (BTS).")
//Ŀ
// Monta botoes para janela de processamento                                
//
AADD(aButtons, { 5,.T.,{|| Pergunte(cPerg,.T. ) } } )
AADD(aButtons, { 1,.T.,{|| MsAguarde({|| PL766VALPro(cPerg)}, "", "Processando...", .T.),FechaBatch() }} )
AADD(aButtons, { 2,.T.,{|| FechaBatch() }} )
//Ŀ
// Exibe janela de processamento                                            
//
FormBatch( cCadastro, aSays, aButtons,, 160 )
//Ŀ
// Fim da Rotina Principal...                                               
//
Return     

/*/


Ŀ
Programa  PL766VALPro| Autor  Daher				   Data  23.02.2005 
Ĵ
Descrio  Processa duplicidade no cadst de vidas                     
ٱ


/*/                              
Function PL766VALPro(cPerg)
//Ŀ
// Busca dados dos parametros...                                       
//
  
LOCAL aDados  := {}
LOCAL aCabec  := { {"Matric. Vida","@!",30},{"Nome Vida","@!",100},{"Data Nasc.","@D",030},{"CPF","@C",050},{"Qtd de Duplicidades","@C",050}}
LOCAL cTitulo := "Duplicidades Encontradas"      
LOCAL nOrdBTS := BTS->(IndexOrd())
LOCAL nRecBTS := BTS->(Recno())        
LOCAL i		  := 1                  
PRIVATE cNomeUs
PRIVATE cMatric
PRIVATE dDatNas
PRIVATE cCPFusu                  
PRIVATE nRecAux      
PRIVATE nNome   
PRIVATE nDatN 
PRIVATE nCPF       
PRIVATE lWhile := .F.

Pergunte(cPerg,.F.) 
nNome := 1
nDatN := mv_par01
nCPF  := mv_par02
//Ŀ
// Sempre ordeno por NOME												
//
BTS->(DbSetOrder(2))
BTS->(DbGoTop())   
                   

while !BTS->(EOF()) 
	cNomeUs := BTS->BTS_NOMUSR
	cMatric := BTS->BTS_MATVID
	dDatNas := BTS->BTS_DATNAS
	cCPFusu := BTS->BTS_CPFUSR 
	i 		:= 0
	BTS->(DbSkip())
	MontaWhile()	
	while !BTS->(EOF()) .AND. lWhile 
		i++
		BTS->(DbSkip())
		MontaWhile()
	enddo       
	
	if i > 0
	      aadd(aDados,{cMatric,cNomeUs,dDatNas,cCPFusu,i})
	endif      
	lWhile  := .F.	       
enddo                          

PLSCRIGEN(aDados,aCabec,cTitulo)

BTS->(DbSetOrder(nOrdBTS))
BTS->(DbGoTo(nRecBTS))

return                      

static Function MontaWhile()
	//Ŀ
	// Considera nome ?                                                    |
	//| se eh pra considerar o nome e o nome jah eh diferente entao retorno |
	//| direto, e por ai vai ...											
	//
	if nNome == 1
	     if BTS->BTS_NOMUSR == cNomeUs
	     	lWhile := .T.
	     else
	     	lWhile := .F. 
	     	return
	     endif
	endif     
	//Ŀ
	// Considera dt nasc ?													
	//
	if nDatN == 1  
	     if BTS->BTS_DATNAS == dDatNas
	     	lWhile := .T.
	     else
	     	lWhile := .F.
	     	return
	     endif
	endif       
	//Ŀ
	// Considera cpf	 ?													
	//
	if nCPF == 1 
		if BTS->BTS_CPFUSR == cCPFusu
		    lWhile := .T.
		else
			lWhile := .F.
			return
		endif
	endif                 
	
return 