#include "msobject.ch"
#include "protheus.ch"
#include "tlpp-core.th"
#include "totvs.framework.treports.integratedprovider.th"

namespace totvs.protheus.health.smartview.plan.incomeexpense

using namespace totvs.protheus.health.smartview.plan.utils

/*/{Protheus.doc} IncomeExpensesBusinessObject
Objeto de negócio para o Smart View - Receita x Despesas

@type class
@version 12.1.2310
@author vinicius.queiros
@since 27/08/2023
/*/
@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAPLS", tables="BM1,SE1,BD6", name="Receita x Despesas", country="ALL", initialRelease="12.1.2210")
class IncomeExpensesBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	private data jFilterParams as json 
	private data lExistPergunte as logical 

	public method new() as object
	public method getData(nPage as numeric, oFilter as object) as object
	public method getSchema() as object

	private method setFilterParams(oFilter as object) as logical
	private method getQueryIncomeExpenses() as object
	private method validParameters() as logical

endclass

/*/{Protheus.doc} new
Contrutor da classe

@type method
@version 12.1.2310  
@author vinicius.queiros
@since 27/08/2023
@return object, objeto da classe IncomeExpensesBusinessObject
/*/   
method new() class IncomeExpensesBusinessObject

	_Super:new()

	self:jFilterParams := JsonObject():new()

	self:appendArea(UtilsBusinessObject():getAreaName())
	self:setDisplayName("Receitas x Despesas")
	self:setDescription("Diferença entre as receitas e despesas dos contratos ou beneficiários.")

	self:lExistPergunte := self:setPergunte("PLR734")
	if !self:lExistPergunte
		self:setErrorStatus(400, "Pergunte não encontrado", "Verifique o grupo de perguntas PLR734 na base de dados.")
	endif

return self

/*/{Protheus.doc} getData
Retorna o objeto de dados

@type method
@version 12.1.2310  
@author vinicius.queiros
@since 29/04/2023
@param nPage, numérico, indica a página atual do relatório
@param oFilter, objeto, contém o filtro do Smart View
@return object, objeto oData da classe IntegratedProvider 
/*/ 
method getData(nPage as numeric, oFilter as object) as object class IncomeExpensesBusinessObject

	local cAliasTemp as character
	local nSkip := 0 as numeric
	local nCount := 0 as numeric
	local jItems as json
	local aFieldsLGPD := {"BQC_DESCRI", "BA1_NOMUSR"} as array
	local aPDFields := {} as array
	local lObfuscated := .f. as logical
	local cContractDesc as character
	local cNameBenef as character
	Local oStatement as object

	if self:lExistPergunte
		self:setFilterParams(oFilter)
		if self:validParameters()
			oStatement := self:getQueryIncomeExpenses()
			cAliasTemp := oStatement:openAlias()

			if nPage == 1
				(cAliasTemp)->(dbGoTop())
			else
				nSkip := ((nPage - 1) * self:getPageSize())

				(cAliasTemp)->(dbSkip(nSkip))
			endif

			if !(cAliasTemp)->(eof())
				aPDFields := FwProtectedDataUtil():usrAccessPDField(__cUserID, aFieldsLGPD)
				lObfuscated := len(aPDFields) <> len(aFieldsLGPD)

				while !(cAliasTemp)->(eof())
					jItems := JsonObject():new()

					if self:jFilterParams["type"] == 1 // Sintetico
						jItems["CHAVE"] := transform((cAliasTemp)->CHAVE, "@R ####.####.############-###.#########-###")

						cContractDesc := posicione("BQC", 1, xFilial("BQC")+(cAliasTemp)->CHAVE, "BQC_DESCRI")
						jItems["DESC"] := iif(lObfuscated .and. aScan(aPDFields, "BQC_DESCRI") == 0,;
											FwProtectedDataUtil():valueAsteriskToAnonymize(cContractDesc),;
											cContractDesc)
					else
						jItems["CHAVE"] := transform((cAliasTemp)->CHAVE, "@R ####.####.######-##")

						cNameBenef := posicione("BA1", 2, xFilial("BA1")+(cAliasTemp)->CHAVE, "BA1_NOMUSR")
						jItems["DESC"] := iif(lObfuscated .and. aScan(aPDFields, "BA1_NOMUSR") == 0,;
											FwProtectedDataUtil():valueAsteriskToAnonymize(cNameBenef),;
											cNameBenef)
					endif
					jItems["INCOME"] := (cAliasTemp)->INCOME
					jItems["EXPENSE"] := (cAliasTemp)->EXPENSE
					jItems["PERCEN"] := ((cAliasTemp)->EXPENSE / (cAliasTemp)->INCOME) * 100
					jItems["BALANCE"] := (cAliasTemp)->INCOME - (cAliasTemp)->EXPENSE
					
					self:oData:appendData(jItems)
			
					(cAliasTemp)->(dbSkip())
					nCount++

					if nCount == self:getPageSize()
						exit
					endif
				enddo
			endif

			self:setHasNext(!(cAliasTemp)->(eof()))

			(cAliasTemp)->(dbCloseArea())
		endif
	endif

return self:oData

/*/{Protheus.doc} getSchema
Retorna a Estrutura de dados

@type method
@version Protheus 12.1.2310  
@author vinicius.queiros
@since 09/09/2023
@return object, objeto oData da classe IntegratedProvider 
/*/ 
method getSchema() as object class IncomeExpensesBusinessObject

    self:addProperty("CHAVE", "Codigo", "string", "Codigo", "CHAVE")
	self:addProperty("DESC", "Nome", "string", "Nome", "DESC")
    self:addProperty("INCOME", "Receita", "number", "Receita", "INCOME")
	self:addProperty("EXPENSE", "Despesa", "number", "Despesa", "EXPENSE")
	self:addProperty("PERCEN", "Percentual", "number", "Percentual", "PERCEN")
	self:addProperty("BALANCE", "Saldo", "number", "Saldo", "BALANCE")

return self:oSchema

/*/{Protheus.doc} setFilterParams
Defini os parâmetros do pergunte recebido pelo smart view para ser usado
na montagem da query 

@type method
@version 12.1.2310  
@author vinicius.queiros
@since 27/08/2023
@param oFilter, object, Objeto de filtro do Smart View
@return logical, se os parâmetros foram definidos com sucesso
/*/
method setFilterParams(oFilter as object) as logical class IncomeExpensesBusinessObject

	local jParams := oFilter:getParameters() as json
	local lOk := .t. as logical

	self:jFilterParams["healthInsurerCode"] := jParams["MV_PAR01"][1] // Operadora ?
	self:jFilterParams["companyCodeFrom"] := jParams["MV_PAR02"][1] // Grupo/Empresa De ?
	self:jFilterParams["companyCodeTo"] := jParams["MV_PAR03"][1] // Grupo/Empresa Ate ?
	self:jFilterParams["contractCodeFrom"] := jParams["MV_PAR04"][1] // Contrato De ?
	self:jFilterParams["contractCodeTo"] := jParams["MV_PAR05"][1] // Contrato Ate ?
	self:jFilterParams["subcontractCodeFrom"] := jParams["MV_PAR06"][1] // Subcontrato De ?
	self:jFilterParams["subcontractCodeTo"] := jParams["MV_PAR07"][1] // Subcontrato Ate ?
	self:jFilterParams["familyCodeFrom"] := jParams["MV_PAR08"][1] // Familia De ?
	self:jFilterParams["familyCodeTo"] := jParams["MV_PAR09"][1] // Familia Ate ?
	self:jFilterParams["monthYearFrom"] := jParams["MV_PAR10"][1] // Mes Ano De ?
	self:jFilterParams["monthYearTo"] := jParams["MV_PAR11"][1] // Mes Ano Ate ?
	self:jFilterParams["type"] := iif(valType(jParams["MV_PAR12"][1]) == "C", val(jParams["MV_PAR12"][1]), jParams["MV_PAR12"][1]) // Tipo do Relatorio ? Sintetico e Analitico
	self:jFilterParams["incomeStatus"] := cValToChar(jParams["MV_PAR13"][1]) // Considerar Receitas ? Baixadas, Em Aberto ou Ambas

return lOk

/*/{Protheus.doc} getQueryIncomeExpenses
Retorna a query para buscar as receitas x despesas dos parâmetros informados
para o objeto de negocio

@type method
@version 12.1.2310  
@author vinicius.queiros
@since 27/08/2023
@param oFilter, object, Objeto de filtro do Smart View
@return character, query completa para buscar as receitas x despesas
/*/
method getQueryIncomeExpenses() as object class IncomeExpensesBusinessObject

	local cQuery as character
	local cExpenseKey as character
	local cExpenseValue as character
	local cIncomeKey as character
	local dDateProFrom as date
	local dDateProTo as date
	local nOrder := 1 as numeric
    Local oStatement as object

	cQuery += " SELECT ? TOTAL"
	cQuery += " FROM "
	cQuery += " ( "
	// Query de Receitas
	if self:jFilterParams["type"] == 1 // Sintetico
		cExpenseKey := "CONCAT(CONCAT(CONCAT(BM1_CODINT, BM1_CODEMP), CONCAT(BM1_CONEMP, BM1_VERCON)), CONCAT(BM1_SUBCON, BM1_VERSUB))"		
	else
		cExpenseKey := "CONCAT(CONCAT(BM1_CODINT, BM1_CODEMP), CONCAT(BM1_MATRIC, BM1_TIPREG))"
	endif
	cExpenseValue := "BM1_VALOR"

	cQuery += "SELECT ? CHAVE, 
	cQuery += " SUM(CASE WHEN BM1_TIPO = ?  THEN ? ELSE 0 END) AS INCOME,
	cQuery += " SUM(CASE WHEN BM1_TIPO = ?  THEN ? ELSE 0 END) AS EXPENSE"
	cQuery += " FROM ? BM1 "

	cQuery += " INNER JOIN ? SE1 ON "
	cQuery += "		SE1.E1_FILIAL = ? AND "
	cQuery += "		BM1.BM1_PREFIX = SE1.E1_PREFIXO AND "
	cQuery += "		BM1.BM1_NUMTIT = SE1.E1_NUM AND "
	cQuery += "		BM1.BM1_TIPTIT = SE1.E1_TIPO AND "
	cQuery += "		BM1.BM1_PARCEL = SE1.E1_PARCELA AND "
	cQuery += "		SE1.D_E_L_E_T_ = ? "

	cQuery += " WHERE "
	cQuery += " 	BM1.BM1_FILIAL = ? AND "
	cQuery += " 	BM1.BM1_CODINT = ? AND "
	cQuery += " 	BM1.BM1_CODEMP >= ? AND "
	cQuery += "  	BM1.BM1_CODEMP <= ? AND "
	cQuery += "  	BM1.BM1_CONEMP >= ? AND "
	cQuery += "  	BM1.BM1_CONEMP <= ? AND "
	cQuery += "  	BM1.BM1_SUBCON >= ? AND "
	cQuery += "  	BM1.BM1_SUBCON <= ? AND "
	cQuery += "  	BM1.BM1_MATRIC >= ? AND "
	cQuery += "  	BM1.BM1_MATRIC <= ? AND "
	cQuery += "  	CONCAT(BM1.BM1_ANO, BM1.BM1_MES) >= ? AND "
	cQuery += "  	CONCAT(BM1.BM1_ANO, BM1.BM1_MES) <= ? AND  "
		
	do case
		case self:jFilterParams["incomeStatus"] == "1" // Baixadas
			cQuery += " SE1.E1_SALDO = ? AND "
		case self:jFilterParams["incomeStatus"] == "2" // Em Aberto
			cQuery += " SE1.E1_SALDO > ? AND "
	endcase

	cQuery += " BM1.D_E_L_E_T_ = ? "
	cQuery += " GROUP BY ?"

	cQuery += " UNION ALL "

	// Query de Despesas
	if self:jFilterParams["type"] == 1 // Sintetico
		cIncomeKey := "CONCAT(CONCAT(CONCAT(BD6_CODOPE, BD6_CODEMP),CONCAT(BD6_CONEMP, BD6_VERCON)), CONCAT(BD6_SUBCON, BD6_VERSUB))"                      
	else
		cIncomeKey := "CONCAT(CONCAT(BD6_CODOPE, BD6_CODEMP), CONCAT(BD6_MATRIC, BD6_TIPREG))"
	endif

	dDateProFrom := ctod("01/"+substr(self:jFilterParams["monthYearFrom"],1,2)+"/"+substr(self:jFilterParams["monthYearFrom"],3,4))
	dDateProTo	:= lastDate(ctod("01/"+substr(self:jFilterParams["monthYearTo"],1,2)+"/"+substr(self:jFilterParams["monthYearTo"],3,4)))

	cQuery += "SELECT ? CHAVE, 0 INCOME, SUM(?) EXPENSE "
	cQuery += " FROM ? BD6 "

	cQuery += " WHERE "
	cQuery += " 	BD6.BD6_FILIAL = ? AND "
	cQuery += " 	BD6.BD6_OPEUSR = ? AND "
	cQuery += " 	BD6.BD6_CODEMP >= ? AND "
	cQuery += "  	BD6.BD6_CODEMP <= ? AND "
	cQuery += "  	BD6.BD6_CONEMP >= ? AND "
	cQuery += "  	BD6.BD6_CONEMP <= ? AND "
	cQuery += "  	BD6.BD6_SUBCON >= ? AND "
	cQuery += "  	BD6.BD6_SUBCON <= ? AND "
	cQuery += "  	BD6.BD6_MATRIC >= ? AND "
	cQuery += "  	BD6.BD6_MATRIC <= ? AND "
	cQuery += "  	BD6.BD6_DATPRO >= ? AND "
	cQuery += "  	BD6.BD6_DATPRO <= ? AND "
	cQuery += " 	BD6.BD6_FASE = ? AND " // Faturada
	cQuery += " 	BD6.BD6_SITUAC = ? AND " // Ativo
	cQuery += " 	BD6.D_E_L_E_T_ = ? "

	cQuery += " GROUP BY ?"

	cQuery += " ) TABLE_TEMP "
	cQuery += " GROUP BY ? "
	cQuery += " ORDER BY ? DESC "

	cQuery := ChangeQuery(cQuery)

	oStatement := FWExecStatement():new(cQuery)

	oStatement:setUnsafe(nOrder++,"TABLE_TEMP.CHAVE, SUM(TABLE_TEMP.INCOME) INCOME, SUM(TABLE_TEMP.EXPENSE) EXPENSE, SUM(TABLE_TEMP.INCOME) - SUM(TABLE_TEMP.EXPENSE)")
	
	oStatement:setUnsafe(nOrder++,cExpenseKey)
	oStatement:setString(nOrder++,'1')
	oStatement:setUnsafe(nOrder++,cExpenseValue)
	oStatement:setString(nOrder++,'2')
	oStatement:setUnsafe(nOrder++,cExpenseValue)
	oStatement:setUnsafe(nOrder++,retSqlName("BM1"))

	oStatement:setUnsafe(nOrder++,retSqlName("SE1"))
	oStatement:setString(nOrder++,xFilial("SE1"))
	oStatement:setString(nOrder++,"")

	oStatement:setString(nOrder++,xFilial("BM1"))
	oStatement:setString(nOrder++,self:jFilterParams["healthInsurerCode"])
	oStatement:setString(nOrder++,self:jFilterParams["companyCodeFrom"])
	oStatement:setString(nOrder++,self:jFilterParams["companyCodeTo"])
	oStatement:setString(nOrder++,self:jFilterParams["contractCodeFrom"])
	oStatement:setString(nOrder++,self:jFilterParams["contractCodeTo"])
	oStatement:setString(nOrder++,self:jFilterParams["subcontractCodeFrom"])
	oStatement:setString(nOrder++,self:jFilterParams["subcontractCodeTo"])
	oStatement:setString(nOrder++,self:jFilterParams["familyCodeFrom"])
	oStatement:setString(nOrder++,self:jFilterParams["familyCodeTo"])
	oStatement:setString(nOrder++,substr(self:jFilterParams["monthYearFrom"],3,4)+substr(self:jFilterParams["monthYearFrom"],1,2))
	oStatement:setString(nOrder++,substr(self:jFilterParams["monthYearTo"],3,4)+substr(self:jFilterParams["monthYearTo"],1,2))
	
	do case
		case self:jFilterParams["incomeStatus"] == "1" // Baixadas
			oStatement:setUnsafe(nOrder++,"0")
		case self:jFilterParams["incomeStatus"] == "2" // Em Aberto
			oStatement:setUnsafe(nOrder++,"0")
	endcase

	oStatement:setString(nOrder++,"")

	if self:jFilterParams["type"] == 1 // Sintetico
		oStatement:setUnsafe(nOrder++,"CONCAT(CONCAT(CONCAT(BM1_CODINT, BM1_CODEMP), CONCAT(BM1_CONEMP, BM1_VERCON)), CONCAT(BM1_SUBCON, BM1_VERSUB)), BM1_TIPO")
	else
		oStatement:setUnsafe(nOrder++,"CONCAT(CONCAT(BM1_CODINT, BM1_CODEMP), CONCAT(BM1_MATRIC, BM1_TIPREG)), BM1_TIPO")
	endif

	oStatement:setUnsafe(nOrder++, cIncomeKey)
	oStatement:setUnsafe(nOrder++, "BD6_VLRPAG")
	oStatement:setUnsafe(nOrder++, retSqlName("BD6"))

	oStatement:setString(nOrder++, xFilial("BD6"))
	oStatement:setString(nOrder++, self:jFilterParams["healthInsurerCode"])
	oStatement:setString(nOrder++, self:jFilterParams["companyCodeFrom"])
	oStatement:setString(nOrder++, self:jFilterParams["companyCodeTo"])
	oStatement:setString(nOrder++, self:jFilterParams["contractCodeFrom"])
	oStatement:setString(nOrder++, self:jFilterParams["contractCodeTo"])
	oStatement:setString(nOrder++, self:jFilterParams["subcontractCodeFrom"])
	oStatement:setString(nOrder++, self:jFilterParams["subcontractCodeTo"])
	oStatement:setString(nOrder++, self:jFilterParams["familyCodeFrom"])
	oStatement:setString(nOrder++, self:jFilterParams["familyCodeTo"])
	oStatement:setString(nOrder++, dtos(dDateProFrom))
	oStatement:setString(nOrder++, dtos(dDateProTo))
	oStatement:setString(nOrder++, '4')
	oStatement:setString(nOrder++, '1')
	oStatement:setString(nOrder++, '')

	if self:jFilterParams["type"] == 1 // Sintetico
		oStatement:setUnsafe(nOrder++, 'CONCAT(CONCAT(CONCAT(BD6_CODOPE, BD6_CODEMP), CONCAT(BD6_CONEMP, BD6_VERCON)), CONCAT(BD6_SUBCON, BD6_VERSUB))')
	else
		oStatement:setUnsafe(nOrder++, 'CONCAT(CONCAT(BD6_CODOPE, BD6_CODEMP), CONCAT(BD6_MATRIC, BD6_TIPREG))')
	endif

	oStatement:setUnsafe(nOrder++, 'CHAVE')
	oStatement:setUnsafe(nOrder++, 'TOTAL')

return oStatement

/*/{Protheus.doc} validParameters
Realizar a validação dos parametros recebidos pelo smart view

@type method
@version 12.1.2310  
@author vinicius.queiros
@since 10/09/2023
@return logical, se os parametros informados pelo Smart View estõa validos
/*/
method validParameters() as logical class IncomeExpensesBusinessObject

	local aParams := {} as array
	local lSucess := .f. as logical
	local jResponse as json
	local aTypeOptions := {{"value": 1, "description": "Sintetico"}, {"value": 2, "description": "Analitico"}} as array
	local aIncomeStatusOptions := {{"value": "1", "description": "Baixadas"}, {"value": "2", "description": "Em Aberto"}, {"value": "3", "description": "Ambas"}} as array

	aAdd(aParams, {"question": "healthInsurerCode", "description": "Operadora", "required": .t., "size": 4, "findReg": {"table": "BA0", "order": 1}})
	aAdd(aParams, {"question": "companyCodeTo", "description": "Grupo/Empresa Até", "required": .t.})
	aAdd(aParams, {"question": "familyCodeTo", "description": "Familia Até", "required": .t.})
	aAdd(aParams, {"question": "monthYearFrom", "description": "Mes e Ano De", "required": .t., "size": 6, "format": "MMYYYY"})
	aAdd(aParams, {"question": "monthYearTo", "description": "Mes e Ano Até", "required": .t., "size": 6, "format": "MMYYYY"})
	aAdd(aParams, {"question": "type", "description": "Tipo do Relatório", "required": .t., "size": 1, "options": aTypeOptions})
	aAdd(aParams, {"question": "incomeStatus", "description": "Considerar Receitas", "required": .t., "size": 1, "options": aIncomeStatusOptions})

	jResponse := UtilsBusinessObject():validQuestParams(aParams, self:jFilterParams)
	lSucess := jResponse["sucess"]
	if !lSucess
		self:setErrorStatus(jResponse["codError"], jResponse["message"], jResponse["detailedMsg"])
	endif

return lSucess
