#include "PLSMGER.CH"
#include "PLSMLIB.CH"

#IFDEF TOP
       #include "TOPCONN.CH"
#ENDIF       

#include "PROTHEUS.CH"
#include "COLORS.CH"
/*/


Ŀ
Programa   PLVLDCOLS  Autor  Tulio Cesar           Data 29.02.2000
Ĵ
Descri??o  Valida mesma chave em um aCols.                            
Ĵ
Uso        GetDados.                                                  
Ĵ
Parametros cDado   - Novo dado a ser inserido.                        
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRU?AO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Altera??o                     
Ĵ
                                                                    
ٱ


/*/
Function PLVLDCOLS(cDado,aDados,aCabec,nLin)
LOCAL nInd
LOCAL lFlag   := .T.
LOCAL nColuna

DEFAULT aCabec := aHeader                  
DEFAULT aDados := aCols  
DEFAULT nLin   := n

nColuna := Ascan(aCabec,{|a| a[2] $ AllTrim(SX3->X3_CAMPO)})

For nInd := 1 To Len(aDados)
    If aDados[nInd,nColuna] == cDado .And. nLin <> nInd
       lFlag := .F.
    Endif
Next                

If ! lFlag
   Help(" ",1,"PLVLDCOLS")
Endif

Return(lFlag)
/*/


Ŀ
Funcao     PLINITCols  Autor  Tulio Cesar          Data  15.02.00 
Ĵ
Descricao  Trata inicializadores padroes de campos no aCols           
Ĵ
Sintaxe    PLInitCols()                                               
Ĵ
Parametros Nenhum                                                     
Ĵ
 Uso       Cadastrado no Alias BF5.                                   
ٱ

/*/
Function PLInitCols(aCls,aHdr,oBrowse,nOpc)
LOCAL cBlock     
LOCAL nHeader
LOCAL cCampo,n

PRIVATE aHeader := aHdr
PRIVATE aCols   := aCls            

DEFAULT nOpc := nOpcx

If Select("BF5") > 0

   If nOpc <> K_Incluir

      For n := 1 To Len(aCols)
         For nHeader := 1 To Len(aHeader)
             BF5->(DbSetOrder(1))
             If BF5->(MsSeek(AllTrim(aHeader[nHeader,2])))
                cBlock   := AllTrim(BF5->BF5_BLOCK1)+AllTrim(BF5->BF5_BLOCK2)+AllTrim(BF5->BF5_BLOCK3)+AllTrim(BF5->BF5_BLOCK4)+AllTrim(BF5->BF5_BLOCK5)
                aCols[n,nHeader] := &cBlock
              Endif                    
         Next              
      Next
   
      If ValType(oBrowse) <> "U" 
         oBrowse:Atualiza()
      Endif   
      n := 1
 
   Endif
Endif

Return

/*/


Ŀ
Funcao     HGetDados     Autor  Tulio Cesar        Data  27.03.00 
Ĵ
Descricao                                                             
ٱ


/*/
Function HGetDados(oGet)
oGet:Hide()
oGet:oBrowse:Hide()
oGet:oBrowse:lDisablePaint:=.T.
Return(.T.)
/*/


Ŀ
Funcao     SGetDados     Autor  Tulio Cesar        Data  27.03.00 
Ĵ
Descricao                                                             
ٱ


/*/
Function SGetDados(oGet)
oGet:Show()
oGet:oBrowse:Show()
oGet:oBrowse:lDisablePaint:=.F.   
oGet:oBrowse:SetFocus()
Return(.T.)
/*/


Ŀ
Funcao     PLDesItem     Autor  Tulio Cesar        Data  26.04.00 
Ĵ
Descricao  Retorna a descricao de um item AMB ou ESP                  
ٱ


/*/
Function PLDesItem(cCodProc)
LOCAL nOrdem  
LOCAL cDesc   := ""

nOrdem := BA8->(IndexOrd())
BA8->(DbSetOrder(1))
If BA8->(MsSeek(xFilial("BA8")+AllTrim(cCodProc)))
   cDesc := BA8->BA8_DESCRI
Endif                        
BA8->(DbSetOrder(nOrdem))
  
Return(cDesc)   
   
/*/


Ŀ
Funcao     PLDesCod      Autor  Tulio Cesar        Data  26.04.00 
Ĵ
Descricao  Retorna o codigo do procedimento com mascara...            
ٱ


/*/
Function PLDesCod(cCodProc)
Return(TransForm(cCodProc,"@R !!.!!.!!!-!!!"))
/*/


Ŀ
Funcao     PLAcerFil     Autor  Tulio Cesar        Data  26.04.00 
Ĵ
Descricao  Acerta filtro montado pelo SetPrint...                     
ٱ


/*/                                                  
Function PLAcerFil(cExp)

cExp := StrTran(Upper(cExp),"DTOS","")

Return(cExp)
/*/


Ŀ
Funcao     PLRetTAB      Autor  Tulio Cesar        Data  26.04.00 
Ĵ
Descricao  Retorna a tabela de precos de um cred. em uma localidade   
ٱ


/*/                                                  
Function PLRetTAB(cCodCre,cCodLoc,cOrdem)
LOCAL nOrdBB8  := BB8->(IndexOrd())
LOCAL cRetorno := "" 

BB8->(DbSetOrder(1))
If BB8->(MsSeek(xFilial("BB8")+cCodCre+cCodLoc+cOrdem)) 
   cRetorno := BB8->BB8_CODTAB
Endif

BB8->(DbSetOrder(nOrdBB8))

Return(cRetorno)
/*/


Ŀ
Funcao     PLRetORI      Autor  Tulio Cesar        Data  26.04.00 
Ĵ
Descricao  Retorna a origem de atendimento de uma localidade          
ٱ


/*/                                                  
Function PLRetORI(cCodLoc)
LOCAL nOrdBD1  := BD1->(IndexOrd())
LOCAL cRetorno := "" 

BD1->(DbSetOrder(1))
If BD1->(MsSeek(xFilial("BD1")+cCodLoc)) 
   cRetorno := BD1->BD1_CODORI
Endif

BD1->(DbSetOrder(nOrdBD1))

Return(cRetorno)
/*/


Ŀ
Funcao     PLRetFil      Autor  Tulio Cesar        Data  26.04.00 
Ĵ
Descricao  Retorna a quantidade de filme...                           
ٱ


/*/                                                  
Function PLRetFIL(cCodProc)
LOCAL nRet := 0

BD4->(DbSetOrder(1))
If BD4->(MsSeek(xFilial("BD4")+cCodProc))
   While ! BD4->(Eof()) .And. AllTrim(BD4->BD4_CODAMB) == AllTrim(cCodProc)
         If Subs(BD4->BD4_CODIGO,1,3) == "FIL"
            nRet := BD4->BD4_VALREF
            Exit
         Endif   
   BD4->(DbSkip())
   Enddo
Endif   

Return(nRet)



Function PLRETTIT(cMatric)       
LOCAL cNomeTit
LOCAL nOrdBA1 := BA1->(IndexOrd())
LOCAL nRecBA1 := BA1->(Recno())

BA1->(DbSetOrder(2))

If BA1->(MsSeek(xFilial("BA1")+cMatric))
   cNomeTit := BA1->BA1_NOMUSR
Else
   cNomeTit := Space(Len(BA1->BA1_NOMUSR))
Endif   

BA1->(DbGoTo(nRecBA1))
BA1->(DbSetOrder(nOrdBA1))

Return(cNomeTit)


/*


Ŀ
Funcao     PLNOVIMP  Autor  Tulio Cesar            Data  23.05.00 
Ĵ
Descricao  Mensagem de nova implementacao do produto plano de saude   
ٱ


*/
Function PLNOVIMP()

MsgStop("Disponivel em futuras atualizacoes")

Return
/*


Ŀ
Funcao     PLNUMAUT  Autor  Tulio Cesar            Data  29.05.00 
Ĵ
Descricao  Retorna o numero da proxima autorizacao.                   
ٱ


*/
Function PLNUMAUT(cOpeMov,cAno,cMes,cFiltro)
LOCAL nH			:= 0
LOCAL cNum		:= ""
LOCAL lFiltrar	:= .f.
LOCAL cNumBEA 	:= StrZero(1,Len(BEA->BEA_NUMAUT))
LOCAL cNumB44 	:= StrZero(1,Len(BEA->BEA_NUMAUT))
LOCAL cNumBOW 	:= StrZero(1,Len(BEA->BEA_NUMAUT))
LOCAL cNumBE4 	:= StrZero(1,Len(BEA->BEA_NUMAUT))
LOCAL cNumBD5 	:= StrZero(1,Len(BEA->BEA_NUMAUT))
LOCAL cNumB4Q 	:= StrZero(1,Len(BEA->BEA_NUMAUT))
LOCAL cNumB4A	:= StrZero(1,Len(BEA->BEA_NUMAUT))  
LOCAL nOrdBEA 	:= BEA->(IndexOrd())
LOCAL nRecBEA 	:= BEA->(Recno())
LOCAL nOrdB44 	:= 0
LOCAL nRecB44 	:= 0
LOCAL nOrdBOW 	:= 0
LOCAL nRecBOW 	:= 0
LOCAL nOrdBE4 	:= 0
LOCAL nRecBE4 	:= 0
Local nrecBD5		:= 0
Local nOrdBD5		:= 0
LOCAL cFilBEA 	:= xFilial("BEA")
LOCAL nLenNum 	:= Len(BEA->BEA_NUMAUT)
LOCAL cAreaSlv 	:= Alias()
Local cSql			:= ""
     
DEFAULT cFiltro := ""

nH := PLSAbreSem("PLNUMAUT.SMF")

lFiltrar := !Empty(cFiltro)

DbSelectArea("BEA")

if lFiltrar
   SET FILTER TO
endIf
//                                     
// Busco o maior numero do BEA												 
//
BEA->(DbSetOrder(1))
BEA->(MsSeek(cFilBEA+cOpeMov+cAno+cMes+Replicate("9",nLenNum),.T.))
BEA->(DbSkip(-1))                                                      
If BEA->(BEA_FILIAL+BEA_OPEMOV+BEA_ANOAUT+BEA_MESAUT) <> cFilBEA+cOpeMov+cAno+cMes
   cNumBEA := StrZero(1,nLenNum)
Else
   cNumBEA := StrZero(Val(BEA->BEA_NUMAUT)+1,nLenNum)
Endif
BEA->(DbSetOrder(nOrdBEA))
BEA->(DbGoTo(nRecBEA))                         
                                    
// Agora vou buscar o maior do B44										     
If PLSALIASEXI("B44")
	nOrdB44 := B44->(IndexOrd())         
	nRecB44 := B44->(Recno())         
	B44->(DbSetOrder(1))
	B44->(MsSeek(xFilial("B44")+cOpeMov+cAno+cMes+Replicate("9",nLenNum),.T.))
	B44->(DbSkip(-1))                                                      
	If B44->(B44_FILIAL+B44_OPEMOV+B44_ANOAUT+B44_MESAUT) <> xFilial("B44")+cOpeMov+cAno+cMes
	   cNumB44 := StrZero(1,nLenNum)
	Else
	   cNumB44 := StrZero(Val(B44->B44_NUMAUT)+1,nLenNum)
	Endif
	B44->(DbSetOrder(nOrdB44))
	B44->(DbGoTo(nRecB44))                         
EndIf
//Ŀ                                     
// Agora vou comparar os dois e pegar o maior							     
//
If cNumB44 > cNumBEA 
	cNum := cNumB44
Else
	cNum := cNumBEA
EndIf         
                                    
// Agora vou buscar o maior da BOW ** Gera Guia mesmo no Protocolo
SIX->(DbSetOrder(1))
If PLSALIASEXI("BOW") .and. SIX->(msSeek("BOW6"))

	nOrdBOW := BOW->(IndexOrd())         
	nRecBOW := BOW->(Recno())         

	BOW->(DbSetOrder(6))
	BOW->(MsSeek(xFilial("BOW")+cOpeMov+cAno+cMes+Replicate("9",nLenNum),.T.))
	BOW->(DbSkip(-1))
	                                                      
	If BOW->(BOW_FILIAL+BOW_OPEMOV+BOW_ANOAUT+BOW_MESAUT) <> xFilial("BOW")+cOpeMov+cAno+cMes
	   cNumBOW := StrZero(1,nLenNum)
	Else
	   cNumBOW := StrZero(Val(BOW->BOW_NUMAUT)+1,nLenNum)
	Endif
	
	BOW->(DbSetOrder(nOrdBOW))
	BOW->(DbGoTo(nRecBOW))                         
EndIf
//Ŀ                                     
// Agora vou comparar os dois e pegar o maior							     
//
If cNumBOW > cNum 
	cNum := cNumBOW
EndIf   

//Ŀ                                     
// Se  For Chamado pelo Reembolso Retorno o Ultimo numero Autorizao 	     
// de Reembolso 															 
//

If (FunName() == "PLSA001" .or.  Type("cTlmkReem") # "U")  /// variavel Chamada do Fonte plsa001 correcao Numerao autorizacao para reembolso
	PLSFechaSem(nH,"PLNUMAUT.SMF")
	Return(cNum)
Endif
                                   
// Agora vou buscar o maior do BE4										    
If PLSALIASEXI("BE4")
	nOrdBE4 := BE4->(IndexOrd())         
	nRecBE4 := BE4->(Recno())         
	BE4->(DbSetOrder(2))
	BE4->(MsSeek(xFilial("BE4")+cOpeMov+cAno+cMes+Replicate("9",nLenNum),.T.))
	BE4->(DbSkip(-1))                                                      
	If BE4->(BE4_FILIAL+BE4_CODOPE+BE4_ANOINT+BE4_MESINT) <> xFilial("BE4")+cOpeMov+cAno+cMes
	   cNumBE4 := StrZero(1,nLenNum)
	Else
	   cNumBE4 := StrZero(Val(BE4->BE4_NUMINT)+1,nLenNum)
	Endif
	BE4->(DbSetOrder(nOrdBE4))
	BE4->(DbGoTo(nRecBE4))                         
EndIf                  
//Ŀ                                     
// Agora vou comparar os dois e pegar o maior							     
//
If cNumBE4 > cNum
	cNum := cNumBE4
EndIf
                                                                                                          
// Agora vou buscar o maior do B4A
nOrdB4A := B4A->(IndexOrd())         
nRecB4A := B4A->(Recno())         
B4A->(DbSetOrder(1))
B4A->(MsSeek(xFilial("B4A")+cOpeMov+cAno+cMes+Replicate("9",nLenNum),.T.))
B4A->(DbSkip(-1))                                                      
If B4A->(B4A_FILIAL+B4A_OPEMOV+B4A_ANOAUT+B4A_MESAUT) <> xFilial("B4A")+cOpeMov+cAno+cMes
   cNumB4A := StrZero(1,nLenNum)
Else
   cNumB4A := StrZero(Val(B4A->B4A_NUMAUT)+1,nLenNum)
Endif
B4A->(DbSetOrder(nOrdB4A))
B4A->(DbGoTo(nRecB4A))

If cNumB4A > cNum
	cNum := cNumB4A
EndIf
                                   
// Agora vou buscar o maior do BD5
cSql += " Select MAX(BD5_NUMAUT) BD5_NUMAUT FROM " + RetsqlName("BD5")
cSql += " WHERE BD5_FILIAL = '" + xFilial('BD5') + "' "
cSql += " AND BD5_CODOPE = '" + cOpeMov + "' "
cSql += " AND BD5_ANOAUT = '" + cAno + "' "
cSql += " AND BD5_MESAUT = '" + cMes + "' "
cSql += " AND D_E_L_E_T_ = ' ' "
cSql := ChangeQuery(cSql)
dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSql),"MAXBD5",.F.,.T.)

If EmpTy(MAXBD5->BD5_NUMAUT)
      cNumBD5 := StrZero(1,nLenNum)
else
	cNumBD5 := StrZero(Val(MAXBD5->BD5_NUMAUT)+1,nLenNum)
EndIF
	                         
MAXBD5->(dbCloseArea())

If cNumBD5 > cNum
      cNum := cNumBD5
EndIf
                                   
// Agora vou buscar o maior do B4Q										     
If PLSALIASEXI("B4Q") 
	nOrdB4Q := B4Q->(IndexOrd())         
	nRecB4Q := B4Q->(Recno())         
	B4Q->(DbSetOrder(1))
	B4Q->(MsSeek(xFilial("B4Q")+cOpeMov+cAno+cMes+Replicate("9",nLenNum),.T.))
	B4Q->(DbSkip(-1))                                                      
	If B4Q->(B4Q_FILIAL+B4Q_OPEMOV+B4Q_ANOAUT+B4Q_MESAUT) <> xFilial("B4Q")+cOpeMov+cAno+cMes
	   cNumB4Q := StrZero(1,nLenNum)
	Else
	   cNumB4Q := StrZero(Val(B4Q->B4Q_NUMAUT)+1,nLenNum)
	Endif
	B4Q->(DbSetOrder(nOrdB4Q))
	B4Q->(DbGoTo(nRecB4Q))                         
EndIf

If cNumB4Q > cNum
	cNum := cNumB4Q
EndIf

DbSelectArea("BEA")
if lFiltrar   	
   SET FILTER TO &cFiltro   	   
endIf	

if ! Empty(cAreaSlv)
	DbSelectArea(cAreaSlv)
endIf

PLSFechaSem(nH,"PLNUMAUT.SMF")
//Ŀ                                     
// Fim da Rotina															 
//
Return(cNum)
/*


Ŀ
Funcao     PLNUMEST  Autor  Tulio Cesar            Data  12.01.03 
Ĵ
Descricao  Retorna o numero da proxima Liberacao Especial             
ٱ


*/
Function PLNUMLES(cOpeMov,cAno,cMes)
LOCAL nNum    := 0
LOCAL nOrdBEI := BEI->(IndexOrd())
LOCAL nRecBEI := BEI->(Recno())
       
BEI->(DbSetOrder(1))
BEI->(MsSeek(xFilial("BEI")+cOpeMov+cAno+cMes+"999999",.T.))
       
BEI->(DbSkip(-1))
        
If BEI->(BEI_FILIAL+BEI_OPEMOV+BEI_ANOLES+BEI_MESLES) == xFilial("BEI")+cOpeMov+cAno+cMes
   nNum := Val(BEI->BEI_NUMLES)+1
Else
   nNum := 1
Endif                      
       
BEI->(DbGoTo(nRecBEI))
BEI->(DbSetOrder(nOrdBEI))

Return(StrZero(nNum,Len(BEI->BEI_NUMLES)))

/*


Ŀ
Funcao     PLRETMES  Autor  Tulio Cesar            Data  29.05.00 
Ĵ
Descricao  Retorna o nome de um determinado mes...                    
ٱ


*/
Function PLRETMES(nMes,cTipo)
LOCAL aMes
LOCAL cRet                   
DEFAULT cTipo := "1"

If cTipo == "1"
   aMes := {"JANEIRO","FEVEREIRO","MARCO","ABRIL","MAIO","JUNHO","JULHO","AGOSTO","SETEMBRO","OUTUBRO","NOVEMBRO","DEZEMBRO"}
Else
   aMes := {"Janeiro","Fevereiro","Marco","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"}
Endif

If nMes >= 1 .And. nMes <= 12
   cRet :=aMes[nMes]
Else
   cRet := "MES INVALIDO!!!"
Endif      

Return(cRet)
/*


Ŀ
Funcao     PLSELLOC  Autor  Tulio Cesar            Data  31.05.00 
Ĵ
Descricao  Monta tela padrao para selecionar localidade de um credenc 
ٱ


*/
Function PLSELLOC(cCodCre)
LOCAL aDados := {}
LOCAL aCabec := {}
LOCAL oDlg
LOCAL cRet
LOCAL oBrwLoc
LOCAL bOK    := {|| cRet := oBrwLoc:aCols[oBrwLoc:Linha(),oBrwLoc:RetCol("BB8_CODLOC")]+"-"+;
                              oBrwLoc:aCols[oBrwLoc:Linha(),oBrwLoc:RetCol("BB8_DESLOC")]+"-"+;
                              oBrwLoc:aCols[oBrwLoc:Linha(),oBrwLoc:RetCol("BB8_END")],;
                              oDlg:End() }
LOCAL nNome

Store Header "BB8" TO aCabec For SX3->X3_ORDEM >= "03"

SA2->(DbSetOrder(1))

SA2->(MsSeek(xFilial("SA2")+cCodCre))

cNome := cCodCre+" - "+AllTrim(SA2->A2_NOME)

BB8->(DbSetOrder(1))
If BB8->(MsSeek(xFilial("BB8")+cCodCre))

   aTrb := {}

   Store COLS "BB8" TO aDados FROM aCabec VETTRAB aTrb While xFilial("BB8")+cCodCre == BB8->(BB8_FILIAL+BB8_CODCRE)
   
   DEFINE MSDIALOG oDlg TITLE "Locais de Atendimento" FROM 008.2,010.3 TO 020,100.3 OF GetWndDefault()
   
   oBrwLoc := TPLSBrw():New(022,005,345,073,nil  ,oDlg,nil    , bOK ,nil    ,nil   ,nil, .T.   ,nil  ,.T.   ,nil   ,aCabec,aDados,.F.,"BB8",K_Visualizar,"Localidades do Credenciado",nil)

   @ 005,005 MSGET cNome SIZE 205,010 OF oDlg PIXEL COLOR CLR_HBLUE
   
   ACTIVATE DIALOG oDlg ON INIT PLInitCols(aDados,aCabec,oBrwLoc)
   
Else
   Help("",1,"PLSELLOC")
   cRet := "LOCALIDADE PARA O CREDENCIADO NAO EXISTE"
Endif   

Return(cRet)

/*


Ŀ
Funcao     PLRETCRI  Autor  Tulio Cesar            Data  31.05.00 
Ĵ
Descricao  Retorna a descricao da critica da autorizacao...           
ٱ


*/
Function PLRETCRI(cCritica)

SX5->(DbSetOrder(1))
SX5->(MsSeek(xFilial("SX5")+"B3"+cCritica))

aSX5    := FWGetSX5("B3",cCritica)

RETURN(IF(Len(aSX5) == 0," ",aSX5[1][4]))

/*


Ŀ
Funcao     PLVALSQL  Autor  Tulio Cesar            Data  ??.??.?? 
Ĵ
Descricao  Converte expressoes do tipo Caracter, Data e Numerico para 
           um formato valido para Script em ambiente TopConnect.      
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRU?AO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Altera??o                     
Ĵ
ٱ


*/
//Ŀ
// Caracter TULIO CESAR DE MELO BATISTA -> 'TULIO CESAR DE MELO BATISTA' 
// Data     10/10/200                   -> '20001010'                    
// Numerico 100.95                      -> 100.95                        
//
Function PLValSQL(xFieldGet)
LOCAL cField
LOCAL cValor

DO CASE
	CASE ValType(xFieldGet) == "C"
 		  cField := Trim(xFieldGet)
		  If ("'"$cField)
		  	  cField := StrTran(cField,"'",'"')
		  EndIf
		  cValor := "'" + cField + "'"
	CASE VALTYPE(xFieldGet) == "D"
		  cValor := "'" + DTOS( xFieldGet ) + "'"
   CASE VALTYPE(xFieldGet) == "L"
	     If xFieldGet
			  cValor := "T"
		  Else
			  cValor := "F"
		  EndIf
	CASE ValType(xFieldGet) == "N"
		  cValor := AllTrim( Str( xFieldGet ) )
ENDCASE

Return cValor

/*


Ŀ
Funcao     PLDESGRU  Autor  Tulio Cesar            Data  13.06.00 
Ĵ
Descricao  Retorna a descricao de um grupo de credenciados            
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRU?AO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Altera??o                     
Ĵ
ٱ


*/
Function PLDESGRU(cCodGrupo)

BAG->(DbSetOrder(1))
BAG->(MsSeek(xFilial("BAG")+cCodGrupo))

Return(If(BAG->(Found()),BAG->BAG_DESCRI,""))
/*


Ŀ
Funcao     PLRETESP  Autor  Tulio Cesar            Data  14.06.00 
Ĵ
Descricao  Retorna as especialidades de um determinado credenciado    
ٱ


*/
Function PLRETESP(cCodCre)
LOCAL cEspec  := ""

BB9->(DbSetOrder(1))

If BB9->(MsSeek(xFilial("BB9")+cCodCre))
   While ! BB9->(Eof()) .And. BB9->(BB9_FILIAL+BB9_CODCRE) == xFilial("BB9")+cCodCre
         BA8->(DbSetOrder(1))
         
         If BA8->(MsSeek(xFilial("BA8")+BB9->BB9_CODOPC))
            cEspec := cEspec + "   "+AllTrim(BA8->BA8_DESCRI)
         Endif
   BB9->(DbSkip())
   Enddo
Endif         
          
Return(cEspec)
/*


Ŀ
Funcao     PLDESPRO  Autor  Tulio Cesar            Data  14.06.00 
Ĵ
Descricao  Retorna a descricao de um procedimento.                    
ٱ


*/
Function PLDESPRO(cCodPad,cCodPro)
LOCAL nOrdBR8 := BR8->(IndexOrd())

BR8->(DbSetOrder(1))
If BR8->(MsSeek(xFilial("BR8")+cCodPad+cCodPro))
   cRet := BR8->BR8_DESCRI
Else  
   cRet := "PROCEDIMENTO NAO ENCONTRADO"
   cRet := cRet + Space(Len(BR8->BR8_DESCRI)-Len(cRet))
Endif      

BR8->(DbSetOrder(nOrdBR8))

Return(cRet)
/*


Ŀ
Funcao     PLRETTPU  Autor  Tulio Cesar            Data  15.06.00 
Ĵ
Descricao  Retorno se usuario e Titular, Depedente ou Agregado        
ٱ


*/
Function PLRETTPU(cTipoUsr)
LOCAL cRet

If     cTipoUsr == "D"
       cRet := STR0063//"Depedente"
ElseIf cTipoUsr == "A"
       cRet := STR0064//"Agregado"
ElseIf cTipoUsr == "T"
       cRet := STR0065//"Titular"
Else
       cRet := ""
Endif

Return(cRet)


/*


Ŀ
Funcao     PLVLDUSU  Autor  Tulio Cesar            Data  17.06.00 
Ĵ
Descricao  Retorna se o usuario e valido.                             
ٱ


*/
Function PLVLDUSU(cMatric)
//Ŀ
// Salva ordens antigas...                                             
//
LOCAL nOrdBA1 := BA1->(IndexOrd())
LOCAL nOrdBA3 := BA3->(IndexOrd())
LOCAL nOrdSA1 := SA1->(IndexOrd())
//Ŀ
// Verifica arquivo de usuarios...                                     
//    
BA1->(DbSetOrder(2))
If ! BA1->(MsSeek(xFilial("BA1")+cMatric))
   BA1->(DbSetOrder(5))                   
   If ! BA1->(MsSeek(xFilial("BA1")+cMatric))
      BA1->(DbSetOrder(nOrdBA1))
      Help(" ",1,"PLCONTBA1")
      Return(.F.)
   Endif   
Endif   
//Ŀ
// Verifica se o contrato existe...                                    
//
BA3->(DbSetOrder(1))
If ! BA3->(MsSeek(xFilial("BA3")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC)))
   BA1->(DbSetOrder(nOrdBA1))   
   BA3->(DbSetOrder(nOrdBA3))
   Help(" ",1,"PLCONTBA3")
   Return(.F.)
Endif
//Ŀ
// Verifica se o cliente existe...                                     
//
If BA3->BA3_COBNIV == "1"
   SA1->(DbSetOrder(1))
   If ! SA1->(MsSeek(xFilial("SA1")+BA3->BA3_CODCLI+BA3->BA3_LOJA))
      BA1->(DbSetOrder(nOrdBA1))   
      BA3->(DbSetOrder(nOrdBA3))
      SA1->(DbSetOrder(nOrdSA1))
      Help(" ",1,"PLCONTSA1")
      Return(.F.)
   Endif   
Endif   
//Ŀ
// Usuario OK...                                                       
//
Return(.T.)
/*


Ŀ
Funcao     PLVERTOP  Autor  Tulio Cesar            Data  17.06.00 
Ĵ
Descricao  Exibe mensagem dizendo que a rotina so funciona TopConn    
ٱ


*/
Function PLVERTOP()

Return


/*


Ŀ
Funcao     PLRETGLO  Autor  Tulio Cesar            Data  31.05.00 
Ĵ
Descricao  Retorna a descricao da glosa de um movimento...            
ٱ


*/
Function PLRETGLO(cCritica)

SX5->(DbSetOrder(1))
SX5->(MsSeek(xFilial("SX5")+"B2"+cCritica))

aSX5    := FWGetSX5("B2",cCritica)

RETURN(IF(Len(aSX5) == 0,Space(55),aSX5[1][4]))
/*/


Ŀ
Funcao     PLProxMAT     Autor  Tulio Cesar        Data  20.06.00 
Ĵ
Descricao  Retorna a proxima matricula para um contrato.              
ٱ


/*/

Function PLProxMAT(cCodInt,cCodEmp, cFilBA1)

//Ŀ
// Inicializa variaveis                                                
//
LOCAL cRetorno
LOCAL nH
LOCAL lRepete
LOCAL aOldArea := GetArea()

DEFAULT cFilBA1 := ''

//Ŀ
// Aloca semaforo                                                      
//
nH := PLSAbreSem("PLPROXMAT.SMF")
//Ŀ
// Salva posicao das tabelas                                           
//
nOrdBA3 := BA3->(IndexOrd())
nRecBA3 := BA3->(Recno())
nOrdBA1 := BA1->(IndexOrd())
nRecBA1 := BA1->(Recno())

//Ŀ
// Limpa o filtro do BA1( Usuarios )                                   
//
BA1->( dbClearFilter() )

//Ŀ
// Calcula proxima matricula, verificando se existe execblock          
// onde o cliente pode configurar sua regra para determinar o          
// numero da proxima matricula                                         
//
If  ExistBlock("PLPROXMT")
    cRetorno := ExecBlock("PLPROXMT",.F.,.F.,{cCodInt,cCodEmp})
Else    
    //Ŀ
    // Verifica a proxima matricula disponivel com base no BA3             
    //
    BA3->(DbSetOrder(1)) 
    BA3->(MsSeek(xFilial("BA3")+cCodInt+cCodEmp+"999999",.T.))
    BA3->(DbSkip(-1))
    If  BA3->(BA3_FILIAL+BA3_CODINT+BA3_CODEMP) == xFilial("BA3")+cCodInt+cCodEmp
        cRetorno := StrZero(Val(BA3->BA3_MATRIC)+1,6)
    Else
        cRetorno := StrZero(1,6)
    Endif                      
    //Ŀ
    // Verifica se a matricula ja nao foi utilizada anteriormente          
    //
    While .T.
       //Ŀ
       // Inicializa variavel para indicar se deve repetir a verificacao      
       //
       lRepete := .F.
       //Ŀ
       // Verifica se existe matricula anterior com o mesmo numero            
       //
       BA1->(dbsetOrder(5))  // BA1_MATANT
       While .T.
          If  BA1->(MsSeek(xFilial("BA1")+cCodInt+cCodEmp+cRetorno))
              cRetorno := StrZero(Val(cRetorno)+1,6)
              lRepete  := .T.
              Loop
          Endif
          Exit
       Enddo   
       //Ŀ
       // Verifica se existe matricula anterior/anterior com o mesmo numero   
       //
       BA1->(dbsetOrder(10))  // BA1_MATUSB
       While .T.
          If  BA1->(MsSeek(xFilial("BA1")+cCodInt+cCodEmp+cRetorno))
              cRetorno := StrZero(Val(cRetorno)+1,6)
              lRepete  := .T.
              Loop
          Endif
          Exit
       Enddo   
       //Ŀ
       // Verifica se pode encerrar a verificacao                             
       //
       If  ! lRepete
           Exit
       Endif
    Enddo
Endif
//Ŀ
// Restaura posicao das tabelas                                        
//
BA3->(DbSetOrder(nOrdBA3))
BA3->(DbGoTo(nRecBA3))    
BA1->(DbSetOrder(nOrdBA1))
BA1->(DbGoTo(nRecBA1))                                                  

//Ŀ
// Restaura o filtro do BA1...                                         
//
If !Empty(cFilBA1)
	dbSelectArea("BA1")
	SET FILTER TO &cFilBA1
Endif
                 
//Ŀ
// Restaura a area de trabalho...                                      
//
RestArea(aOldArea)

//Ŀ
// Libera semaforo                                                     
//
PLSFechaSem(nH,"PLPROXMAT.SMF")
//Ŀ
// Fim da funcao                                                       
//
Return(cRetorno)

/*/


Ŀ
Funcao     PLEXCCRE   Autor  Tulio Cesar        Data  27.06.00 
Ĵ
Descricao  Valida se pode excluir um credenciado.                  
ٱ


/*/
Function PLEXCCRE(cCodCre,lHelp)
//Ŀ
// Parametros                                                          
// cCodCre - Codigo do Credenciado (6 Digitos)                         
// lHelp   - Exibir help caso haja movimentacao                        
//

//Ŀ
// Retorno:                                                            
// Logico   : .T. caso exista movimentacao                             
//            .F. caso nao exista movimentacao                         
//

//Ŀ
// Define variaveis...                                                 
//
LOCAL lMov    := .F.              
//Ŀ
// Verifica se existe no arquivo de movimentacao...                    
//
BD6->(DbSetOrder(4))

If BD6->(MsSeek(xFilial("BD6")+cCodCre))
   lMov := .T.
Endif
//Ŀ
// Verifica se existe no arquivo de contas a pagar...                  
//
If ! lMov
   SE2->(DbSetOrder(nPlOrdSE2))

   If SE2->(MsSeek(xFilial("SE2")+cCodCre))
      lMov := .T.
   Endif
Endif      
//Ŀ
// Verifica se existe no arquivo de autorizacoes...                    
//
If ! lMov
   BE2->(DbSetOrder(2))

   If BE2->(MsSeek(xFilial("BE2")+cCodCre))
      lMov := .T.
   Endif
Endif      
//Ŀ
// Exibe help...                                                       
//
If lHelp
   If lMov
      Help("",1,"PLMOVCRE")
   Endif
Endif
//Ŀ
// Retorno da funcao...                                                
//
Return(lMov)      


Function PLRETLib(cCodLib)

cRet := ""

BA7->(DbSetOrder(1))

If BA7->(MsSeek(xFilial("BA7")+cCodLib))
   cRet := BA7->BA7_DESCRI
Endif

Return(cRet)   


/*


Ŀ
Funcao     PLVALSTR  Autor  Tulio Cesar            Data  30.06.00 
Ĵ
Descricao  Converte expressoes para tipo caracter.                    
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRU?AO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Altera??o                     
Ĵ
ٱ


*/
Function PLValSTR(xValue)

LOCAL cRet := ""
 
If     ValType(xValue) == "D"
       cRet := dtoc(xValue)
ElseIf ValType(xValue) == "L"
       cRet := IF(xValue,"T","F")
ElseIf ValType(xValue) == "N"
       cRet := Str(xValue)
ElseIf ValType(xValue) == "C"
       cRet := xValue
Endif                      

Return(cRet)


Function PLRETUSR(cCodUsr)

cRet := ""

If     cCodUsr == "T"
       cRet := "TITULAR"
ElseIf cCodUsr == "D"
       cRet := "DEPEDENTE"
ElseIf cCodUsr == "A"
       cRet := "AGREGADO"       
Endif

Return(cRet)       

/*


Ŀ
Funcao     PLOPCUSR  Autor  Tulio Cesar            Data  01.07.00 
Ĵ
Descricao  Retorna em uma array os opcionais de um usuario...         
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRU?AO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Altera??o                     
Ĵ
ٱ


*/
Function PLOPCUSR(cMatric)
//Ŀ
// Define variaveis...                                                 
//
LOCAL aRetorno := {}
//Ŀ
// Define ordem default no arquivo de produtos...                      
//
BA2->(DbSetOrder(1))    
//Ŀ
// Navega pelos produtos...                                            
//
BE7->(DbSetOrder(1))
//Ŀ
// Busca os produtos vinculados a este usuario...                      
//
If BE7->(MsSeek(xFilial("BE7")+cMatric))
   While ! BE7->(Eof()) .And. BE7->(BE7_FILIAL+BE7_CODINT+BE7_CODEMP+BE7_MATRIC+BE7_TIPREG) == xFilial("BE7")+cMatric
         //Ŀ
         // Caso esteja em desbloqueado OK...                                   
         //
         If Empty(BE7->BE7_MOTBLO)
            //Ŀ
            // Posiciono no produto...                                             
            //
            If BA2->(MsSeek(xFilial("BA2")+BE7->BE7_CODPRO))
               aadd(aRetorno,{BE7->BE7_CODPRO,BA2->BA2_DESPLA,BE7->BE7_DATA})
            Endif   
         Endif   
   //Ŀ
   // Acesso proximo opcional para este usuario...                        
   //
   BE7->(DbSkip())
   Enddo
Endif      
//Ŀ
// Retorno da funcao...                                                
//
Return(aRetorno)
/*


Ŀ
Funcao     PLRETOPE  Autor  Tulio Cesar            Data  04.07.00 
Ĵ
Descricao  Retorno o operador do Advanced Protheus (cUserName)        
ٱ


*/
Function PLRETOPE()
Return(cUserName)
/*


Ŀ
Funcao     PLSLDEMP  Autor  Tulio Cesar            Data  11.07.00 
Ĵ
Descricao  Retorna o saldo de uma empresa.                            
ٱ


*/
Function PLSLDEMP(cCodInt,cCodEmp,cAno,cMes)
//Ŀ
// Parametros                                                          
// cCodEmp - Codigo da Empresa/Grupo (4 Digitos)                       
// cCodInt - Codigo da Instituicao (3 Digitos)                         
// cAno    - Ano Base do Saldo (2 Digitos)                             
// cMes    - Mes Base do Saldo (2 Digitos)                             
//

//Ŀ
// Retorno:                                                            
// Numerico : [1] - Valor da despesa da empresa                        
//
LOCAL nSaldo  := 0
LOCAL cSQL

cSQL := " SELECT SUM(ROUND(BD6_VLRPAG,2)) AS VALOR FROM "+RetSQLName("BD6")+" WHERE "
cSQL += " BD6_CODEMP = '"+cCodEmp+"' AND "
cSQL += " BD6_CODINT = '"+cCodInt+"' AND "
cSQL += " BD6_ANO    = '"+cAno+"' AND "
cSQL += " BD6_MES    = '"+cMes+"' AND "
cSQL += " BD6_FILIAL = '"+xFilial("BD6")+"' AND "
cSQL += " D_E_L_E_T_ = '' "

cSQL := ChangeQuery(cSQL)
DbUseArea(.T.,'TOPCONN',TCGENQRY(,,cSQL),"TrbEmp",.T.,.T.)

TCSETFIELD("TrbEmp","VALOR","N",nVlPrec,nVlDec)

nSaldo := TrbEmp->VALOR

TrbEmp->(DbCloseArea())
//Ŀ
// Retorno da funcao em formato numerico...                            
//
Return(nSaldo)
/*


Ŀ
Funcao     PLVALCONT Autor  Tulio Cesar            Data  11.07.00 
Ĵ
Descricao  Retorna o valor de um contrato.                            
ٱ


*/
Function PLVALCONT(cMatric,cAno,cMes,lDetalhado)

//Ŀ
// Salva dados...                                                      
//

LOCAL nOrdBA3 := BA3->(IndexOrd())
LOCAL nRecBA3 := BA3->(Recno())
LOCAL nOrdBA1 := BA1->(IndexOrd())
LOCAL nRecBA1 := BA1->(Recno())
LOCAL nOrdBA2 := BA2->(IndexOrd())
LOCAL nRecBA2 := BA2->(Recno())
//Ŀ
// Defino variavies de retorno...                                      
//
LOCAL nRet   := 0
LOCAL aRet   := {}
//Ŀ
// Caso nao seja especificado obtem o valor na DataBase...             
//
PUBLIC nIdade := 0
DEFAULT cAno   := PLSSTRANO(dDataBase,.T.)
DEFAULT cMes   := PLSSTRMES(dDataBase)
DEFAULT lDetalhado := .F.
//Ŀ
// Posiciona no arquivo de contratos...                                
//
BA3->(DbSetOrder(1))

If ! BA3->(MsSeek(xFilial("BA3")+cMatric))
   BA3->(DbSetOrder(nOrdBA3))
   BA3->(DbGoTo(nRecBA3))
   Help("",1,"PLVALCONTBA3")
   Return(nRet)
Endif
//Ŀ
// Verifica se esta pedindo um valor de cobranca apos a inclusao contr.
//
If cAno+cMes < Subs(dtos(BA3->BA3_DATBAS),1,6)
   BA3->(DbSetOrder(nOrdBA3))
   BA3->(DbGoTo(nRecBA3))
   MsgStop("O Mes/Ano Informado a inferior ao mes do contrato.")
   Return(nRet)
Endif
//Ŀ
// Posiciona no arquivo de planos...                                   
//
BA2->(DbSetOrder(1))

If ! BA2->(MsSeek(xFilial("BA2")+BA3->(BA3_CODINT+BA3_CODPLA)))
   BA3->(DbSetOrder(nOrdBA3))
   BA3->(DbGoTo(nRecBA3))
   BA2->(DbSetOrder(nOrdBA2))
   BA2->(DbGoTo(nRecBA2))
   Help("",1,"PLVALCONTBA2")
   Return(nRet)
Endif
//Ŀ
// Busca o valor do Plano do Contrato...                               
//
nRet := PLVALPRO(cMatric,BA3->(BA3_CODINT+BA3_CODPLA),cAno,cMes,.F.,"",0,.T.,If(lDetalhado,aRet,nil))
//Ŀ
// Busca o valor dos produtos ligados a cada usuario...                
//
BE7->(DbSetOrder(1))

If BE7->(MsSeek(xFilial("BE7")+cMatric))
   While ! BE7->(Eof()) .And. BE7->(BE7_FILIAL+BE7_CODINT+BE7_CODEMP+BE7_MATRIC) == xFilial("BE7")+cMatric
         //Ŀ
         // Verifico se o produto esta bloqueado...                             
         //
         //If ! Empty(BE7->BE7_MOTBLO)
         If ! (( Empty(BE7->BE7_MOTBLO) .Or. cAno+cMes < Subs(dtos(BE7->BE7_DATBLO),1,6) ))
            BE7->(DbSkip())
            Loop
         Endif   
         //Ŀ
         // Verifico se no anomes atual o usuario ja tinha o produto...         
         //
         If ! (cAno+cMes >= Subs(dtos(BE7->BE7_DATA),1,6) )
            BE7->(DbSkip())
            Loop
         Endif   
         //Ŀ
         // Posiciona no produto...                                             
         //
         BA2->(DbSetOrder(1))
         
         BA2->(MsSeek(xFilial("BA2")+BE7->BE7_CODPRO))
         //Ŀ
         // Para cada produto verifico se o usuario esta ativo...               
         //
         BA1->(DbSetOrder(2))
         
         If BA1->(MsSeek(xFilial("BA1")+BE7->(BE7_CODINT+BE7_CODEMP+BE7_MATRIC+BE7_TIPREG)))
            //If Empty(BA1->BA1_MOTBLO)
            If ( Empty(BA1->BA1_MOTBLO) .Or. cAno+cMes < Subs(dtos(BA1->BA1_DATBLO),1,6) )
               nVlrProd := PLVALPRO(cMatric,BE7->BE7_CODPRO,cAno,cMes,.T.,BE7->BE7_TIPREG,BE7->BE7_COEFIC,.F.)
               nRet     += nVlrProd
               
               If lDetalhado
                  aadd(aRet,{BA1->(BA1_CODINT+"."+BA1_CODEMP+"."+BA1_MATRIC+"-"+BA1_TIPREG),BA1->BA1_NOMUSR,BA1->BA1_COEFIC,nIdade,"BE7",BE7->BE7_CODPRO+" - "+BA2->BA2_DESPLA,nVlrProd,nRet})
               Endif   
            Endif
         Endif   
   BE7->(DbSkip())
   Enddo           
Endif   
//Ŀ
// Verifico se existe taxa de adesao para o produto...                 
//
If BA2->BA2_TXADES > 0
   //Ŀ
   // Somente cobrar taxa se nao existe titulo no SE1...                  
   //
   SE1->(DbSetOrder(nPlOrdSE1))
         
   lCalc := SE1->(MsSeek(xFilial("SE1")+cMatric))

   If ! lCalc
      nQtdUsr := PLSQTDUSR(cMatric,.T.)
      nTaxa   := BA2->BA2_TXADES*nQtdUsr
      nRet    += nTaxa
         
      If lDetalhado
         aadd(aRet,{"","FAMILIA",1,0,"TAX","TAXA DE IMPLANTACAO",nTaxa,nRet})
      Endif
   Endif   
Endif   
//Ŀ
// Calcula aumento agencia nacional de saude...                        
//
nRet := PLREAJUS(BA3->BA3_CODEMP,BA3->BA3_DATBAS,nRet,cAno,cMes,aRet)
//Ŀ
// Calcula desconto ou acrescimo em relacao ao contrato todo...        
//
nRet := PLADCON(cMatric,nRet,cAno,cMes,lDetalhado,aRet)
//Ŀ
// Restaura dados salvados...                                          
//
BA1->(DbSetOrder(nOrdBA1))
BA1->(DbGoTo(nRecBA1))
BA3->(DbSetOrder(nOrdBA3))
BA3->(DbGoTo(nRecBA3))
BA2->(DbSetOrder(nOrdBA2))
BA2->(DbGoTo(nRecBA2))
//Ŀ
// Fim da Rotina...                                                    
//
Return(IF(lDetalhado,aRet,nRet))
/*


Ŀ
Funcao     PLVALPRO  Autor  Tulio Cesar            Data  08.08.00 
Ĵ
Descricao  Retorna o valor de um produto para um contrato.            
ٱ


*/
Function PLVALPRO(cMatric,cCodPro,cAno,cMes,lInd,cIdent,nCoefic,lBA2,aRet)
//Ŀ
// Salva dados...                                                      
//
LOCAL nOrdBA1 := BA1->(IndexOrd())
LOCAL nRecBA1 := BA1->(Recno())
//Ŀ
// Define variaveis...                                                 
//
LOCAL lDetalhado := (ValType(aRet)=="A")
LOCAL nRet       := 0
LOCAL nQtdAux    := 0
LOCAL nQtdDep    := 0
LOCAL nQtdMinDep
LOCAL nQtdMaxDep
//Ŀ
// Caso nao seja especificado obtem o valor na DataBase...             
//
DEFAULT cAno    := PLSSTRANO(dDataBase,.T.)
DEFAULT cMes    := PLSSTRMES(dDataBase)             
DEFAULT lInd    := .F.
DEFAULT cMatric := ""                                              
DEFAULT nCoefic := 1
DEFAULT lBA2    := .F.
//Ŀ
// Define ordens default...                                            
//
BA2->(DbSetOrder(1))
BA1->(DbSetOrder(2))
//Ŀ
// Posiciona no Produto...                                             
//
If ! BA2->(MsSeek(xFilial("BA2")+cCodPro))
   Return(nRet)
Endif   
//Ŀ
// Posiciona na familia...                                             
//
BA3->(DbSetOrder(1))

If ! BA3->(MsSeek(xFilial("BA3")+cMatric))
   Return(nRet)
Endif   
//Ŀ
// Testa valor fixo...                                                 
//
If     BA2->BA2_FIXO == "S"
       If lInd
          nRet += BA2->BA2_VALFIX*nCoefic              
       Else
          If ! lBA2
             BE7->(DbSetOrder(1))
             
             If BE7->(MsSeek(xFilial("BE7")+cMatric))
                While ! BE7->(Eof()) .And. BE7->(BE7_FILIAL+BE7_CODINT+BE7_CODEMP+BE7_MATRIC) == xFilial("BE7")+cMatric
                      BA1->(DbSetOrder(2))
                      If BA1->(MsSeek(xFilial("BA1")+BE7->(BE7_CODINT+BE7_CODEMP+BE7_MATRIC+BE7_TIPREG)))
                         //If Empty(BE7->BE7_MOTBLO)
                         
                         If cAno+cMes <= Subs(dtos(BE7->BE7_DATA),1,6)
                            BE7->(DbSkip())
                            Loop
                         Endif   
                         
                         If ( Empty(BE7->BE7_MOTBLO) .Or. cAno+cMes < Subs(dtos(BE7->BE7_DATBLO),1,6) )
                            nVal := BA2->BA2_VALFIX*BE7->BE7_COEFIC
                            nRet += nVal
                            If lDetalhado
                               aadd(aRet,{BA1->(BA1_CODINT+"."+BA1_CODEMP+"."+BA1_MATRIC+"-"+BA1_TIPREG),BA1->BA1_NOMUSR,BE7->BE7_COEFIC,nIdade,"BE7",BE7->BE7_CODPRO+" - "+BA2->BA2_DESPLA,nVal,nRet})
                            Endif   
                         Endif   
                      Endif   
                BE7->(DbSkip())
                Enddo      
             Endif      
          Else
             BA1->(DbSetOrder(2))
             
             If BA1->(MsSeek(xFilial("BA1")+cMatric))
                While ! BA1->(Eof()) .And. BA1->(BA1_FILIAL+BA1_CODINT+BA1_CODEMP+BA1_MATRIC) == xFilial("BA1")+cMatric
                      //If Empty(BA1->BA1_MOTBLO)
                      If ( Empty(BA1->BA1_MOTBLO) .Or. cAno+cMes < Subs(dtos(BA1->BA1_DATBLO),1,6) )
                         nVal := BA2->BA2_VALFIX*BA1->BA1_COEFIC
                         nRet += nVal
                         If lDetalhado
                            aadd(aRet,{BA1->(BA1_CODINT+"."+BA1_CODEMP+"."+BA1_MATRIC+"-"+BA1_TIPREG),BA1->BA1_NOMUSR,BA1->BA1_COEFIC,nIdade,"BA2",BA2->BA2_CODPLA+" - "+BA2->BA2_DESPLA,nVal,nRet})
                         Endif
                      Endif   
                BA1->(DbSkip())
                Enddo      
             Endif      
          Endif  
       Endif   
ElseIf BA2->BA2_FAMILI <> "S"
       If ! lInd
          If BA1->(MsSeek(xFilial("BA1")+cMatric))
             While ! BA1->(Eof()) .And. BA1->(BA1_FILIAL+BA1_CODINT+BA1_CODEMP+BA1_MATRIC) == xFilial("BA1")+cMatric
                   //If Empty(BA1->BA1_MOTBLO)
                   If ( Empty(BA1->BA1_MOTBLO) .Or. cAno+cMes < Subs(dtos(BA1->BA1_DATBLO),1,6) )
                      nVal := PLVLRFAI(BA1->BA1_DATNAS,BA1->BA1_TIPUSU,cCodPro,cAno,cMes,BA1->BA1_DATINC,BA1->BA1_COEFIC)
                      nRet += nVal
                      If lDetalhado
                         aadd(aRet,{BA1->(BA1_CODINT+"."+BA1_CODEMP+"."+BA1_MATRIC+"-"+BA1_TIPREG),BA1->BA1_NOMUSR,BA1->BA1_COEFIC,nIdade,"BA2",BA2->BA2_CODPLA+" - "+BA2->BA2_DESPLA,nVal,nRet})
                      Endif   
                   Endif   
             BA1->(DbSkip())
             Enddo
          Endif
       Else           
           BA1->(DbSetOrder(2))
           If BA1->(MsSeek(xFilial("BA1")+cMatric+cIdent))
              //If Empty(BA1->BA1_MOTBLO)
              If ( Empty(BA1->BA1_MOTBLO) .Or. cAno+cMes < Subs(dtos(BA1->BA1_DATBLO),1,6) )
                 nVal := PLVLRFAI(BA1->BA1_DATNAS,BA1->BA1_TIPUSU,cCodPro,cAno,cMes,BA1->BA1_DATINC,nCoefic)
                 nRet += nVal
                 
                 If lDetalhado
                    aadd(aRet,{BA1->(BA1_CODINT+"."+BA1_CODEMP+"."+BA1_MATRIC+"-"+BA1_TIPREG),BA1->BA1_NOMUSR,BA1->BA1_COEFIC,nIdade,"BA2",BA2->BA2_CODPLA+" - "+BA2->BA2_DESPLA,nVal,nRet})
                 Endif   
              Endif   
           Endif
       Endif   
ElseIf BA2->BA2_FAMILI == "S" 
       //Ŀ
       // Plano Familiar...                                                   
       //
       nQtdMinDep := BA2->BA2_NMINDE
       nQtdMaxDep := BA2->BA2_NMAXDE

       nQtdDep    := PLSQTDUSR(cMatric,.F.)-1
       //Ŀ
       // Menor que a quantidade minima. Pega o da faixa...                   
       //
       If     nQtdDep < nQtdMinDep
              BA1->(MsSeek(xFilial("BA1")+cMatric))
              nVal := PLVLRFAI(BA1->BA1_DATNAS,BA1->BA1_TIPUSU,cCodPro,cAno,cMes,BA1->BA1_DATINC,BA1->BA1_COEFIC)
              nRet += nVal
              
              If lDetalhado
                 aadd(aRet,{"","FAMILIA",1,0,"BA2","PLANO FAMILIAR "+BA2->BA2_CODPLA+" - "+BA2->BA2_DESPLA,nVal,nRet})
              Endif
       ElseIf nQtdDep > nQtdMaxDep   
              nVal := BA2->BA2_VLFAMI
              nRet += nVal

              If lDetalhado
                 aadd(aRet,{"","FAMILIA",1,0,"BA2","PLANO FAMILIAR "+BA2->BA2_CODPLA+" - "+BA2->BA2_DESPLA,nVal,nRet})
              Endif

              If BA1->(MsSeek(xFilial("BA1")+cMatric))
                 BA1->(DbSkip()) // Pula o titular...
                 While ! BA1->(Eof()) .And. BA1->(BA1_FILIAL+BA1_CODINT+BA1_CODEMP+BA1_MATRIC) == xFilial("BA1")+cMatric
                       //If Empty(BA1->BA1_MOTBLO)
                       If ( Empty(BA1->BA1_MOTBLO) .Or. cAno+cMes < Subs(dtos(BA1->BA1_DATBLO),1,6) )
                          nQtdAux ++
                       Else
                          BA1->(DbSkip())
                          Loop
                       Endif   
                       If nQtdAux > nQtdMaxDep
                          nVal := PLVLRFAI(BA1->BA1_DATNAS,BA1->BA1_TIPUSU,cCodPro,cAno,cMes,BA1->BA1_DATINC,BA1->BA1_COEFIC)         
                          nRet += nVal
                          
                          If lDetalhado
                             aadd(aRet,{"","FAMILIA",1,0,"BA2","PLANO FAMILIAR "+BA2->BA2_CODPLA+" - "+BA2->BA2_DESPLA,nVal,nRet})
                          Endif
                       Endif
                 BA1->(DbSkip())
                 Enddo
              Endif
       Else
              nVal    :=BA2->BA2_VLFAMI
              nRet    += nVal
              nQtdAgr := PLSQTDUSR(cMatric,.T.)-1

              If lDetalhado
                 aadd(aRet,{"","FAMILIA",1,0,"BA2","PLANO FAMILIAR "+BA2->BA2_CODPLA+" - "+BA2->BA2_DESPLA,nVal,nRet})
              Endif                              
              
              //Ŀ
              // Existe agregados que devem ser somados a parte do plano familiar... 
              //
              If nQtdAgr > nQtdDep 
                 If BA1->(MsSeek(xFilial("BA1")+cMatric))
                    BA1->(DbSkip()) // Pula o titular...
                    While ! BA1->(Eof()) .And. BA1->(BA1_FILIAL+BA1_CODINT+BA1_CODEMP+BA1_MATRIC) == xFilial("BA1")+cMatric
                          //If BA1->BA1_TIPUSU <> "A" .Or. ! Empty(BA1->BA1_MOTBLO)
                          If BA1->BA1_TIPUSU <> "A" .Or. ! ( Empty(BA1->BA1_MOTBLO) .Or. cAno+cMes < Subs(dtos(BA1->BA1_DATBLO),1,6) )
                             BA1->(DbSkip())
                             Loop
                          Endif   
                          nVal := PLVLRFAI(BA1->BA1_DATNAS,BA1->BA1_TIPUSU,cCodPro,cAno,cMes,BA1->BA1_DATINC,BA1->BA1_COEFIC)         
                          nRet += nVal
                          
                          If lDetalhado
                              aadd(aRet,{BA1->(BA1_CODINT+"."+BA1_CODEMP+"."+BA1_MATRIC+"-"+BA1_TIPREG),BA1->BA1_NOMUSR,BA1->BA1_COEFIC,nIdade,"BA2","USUARIO AGREGADO "+BA2->BA2_CODPLA+" - "+BA2->BA2_DESPLA,nVal,nRet})
                          Endif
                    BA1->(DbSkip())
                    Enddo
                 Endif
              Endif
       Endif
Endif   
//Ŀ
// Restaura area do BA1...                                             
//
BA1->(DbSetOrder(nOrdBA1))
BA1->(DbGoTo(nRecBA1))
//Ŀ
// Retorna o valor de cobranca para este produto...                    
//
Return(nRet)
/*


Ŀ
Funcao     PLX7DAT   Autor  Tulio Cesar            Data  24.07.00 
Ĵ
Descricao  Funcao utilizada no X7_REGRA do campo BA1_DATNAS           
ٱ


*/
Function PLX7Dat(dDatNasc,cTipUsu,cCodPla,dDatInc,nCoefic)

nVlr := PLVLRFAI(dDatNasc,cTipUsu,cCodPla,PLSSTRANO(dDatInc),PLSSTRMES(dDatInc),dDatInc,nCoefic)

Return(nVlr)
/*


Ŀ
Funcao     PLALTCLI  Autor  Tulio Cesar            Data  03.08.00 
Ĵ
Descricao  Altera dados de um cliente para a matricula informada.     
ٱ


*/
Function PLAltCli(cMatric, lVisCli)

DEFAULT lVisCli := .F.

BA1->(DbSetOrder(2))
IF BA1->(MsSeek(xFilial("BA1")+cMatric))
   BA3->(DbSetOrder(1))
   IF BA3->(MsSeek(xFilial("BA3")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC))) .And. BA3->BA3_COBNIV == "1"
      SA1->(DbSetOrder(1))
      IF SA1->(MsSeek(xFilial("SA1")+BA3->BA3_CODCLI+BA3->BA3_LOJA))
         cOld := cCadastro
         If lVisCli
         	cCadastro := "Visualizacao de Dados do Cliente - Usuario Selecionado "+AllTrim(BA1->BA1_NOMUSR)
         	SA1->(AxVisual("SA1",SA1->(Recno()),K_Alterar))
         Else
	        cCadastro := "Alteracao de Dados do Cliente - Usuario Selecionado "+AllTrim(BA1->BA1_NOMUSR)
         	SA1->(AxAltera("SA1",SA1->(Recno()),K_Alterar))
         EndIf
         cCadastro := cOld
      Endif
   Else
      Help("",1,"PLSALTCLI")      
   Endif
Else
   Help("",1,"PLSA090USR")
Endif               

Return   
/*


Ŀ
Funcao     PLDATESTR  Autor  Tulio Cesar            Data  03.08.00 
Ĵ
Descricao  Converte uma data para formato com 4 digitos no ano.        
ٱ


*/
Function PLDateSTR(dData)
cData := dtos(dData)
cDia  := Subs(cData,7,2)
cMes  := Subs(cData,5,2)
cAno  := Subs(cData,1,4)
cRet  := cDia+"/"+cMes+"/"+cAno
Return(cRet)
/*


Ŀ
Funcao     PLVLRFAI  Autor  Tulio Cesar            Data  03.08.00 
Ĵ
Descricao  Retorna um valor para uma determinada faixa...             
ٱ


*/
Function PLVLRFAI(dNascto,cTipo,cPlano,cAno,cMes,dDataInc,nCoefic)
//Ŀ
// Define variaveis...                                                 
//
LOCAL dData
LOCAL nRet    := 0
//Ŀ
// Ponto de entrada para tratar valor da faixa etaria...               
//
If ExistBlock("PLVLRFAI")
   nRet := ExecBlock("PLVLRFAI",.F.,.F.)
   
   If nRet > 0
      Return(nRet)
   Endif   
Endif   
//Ŀ
// Posiciona no produto...                                             
//
BA2->(DbSetOrder(1))
BA2->(MsSeek(xFilial("BA2")+cPlano))
//Ŀ
// Usuarios com mais de dez anos de plano permanecem na faixa quando   
// isto acontece.                                                      
//
nAnosPlano := PLSDIFANOS(PLSSTRANO(dDataInc,.T.),PLSSTRMES(dDataInc),cAno,cMes,"M")

//Ŀ
// Tratamentos para mudanca de faixa...                                
//
cAnoAux := "1998"
cMesAux := "06"
dData   := ctod("01/"+cMesAux+"/"+Subs(cAnoAux,3,2))

nIdade := DateDiffYear(dData,dNascto)       

If     BA1->BA1_10ANOS == "N" .Or. nIdade < 60
       nIdade := 0
       If     BA2->BA2_MUDFAI == "N"
              If ! Empty(BA2->BA2_ANOMES)
                 cAnoNas := subs(dtos(dNascto),1,4)
                 cMesNas := subs(dtos(dNascto),5,2)
      
                 If cAnoNas+cMesNas <= BA2->BA2_ANOMES
                    dData   := ctod("01/"+Subs(BA2->BA2_ANOMES,5,2)+"/"+Subs(BA2->BA2_ANOMES,3,2))
                    nIdade  := DateDiffYear(dData,dNascto)    
                 Endif
              Else
                 nIdade  := DateDiffYear(dDataInc,dNascto)       
              Endif
       ElseIf nAnosPlano > (10*12) .And. BA2->BA2_MUDFAI ==  "S"
              cAnoAux := StrZero(val(subs(dtos(dDataInc),1,4))+10,4)
              cMesAux := PLSSTRMES(dDataInc)
   
              dData   := ctod("01/"+cMesAux+"/"+Subs(cAnoAux,3,2))
              nIdade  := DateDiffYear(dData,dNascto)
       ElseIf BA2->BA2_MUDFAI == "S" .And. BA1->BA1_10ANOS == "N"
              dData   := ctod("01/"+cMes+"/"+Subs(cAno,3,2))
              nIdade  := DateDiffYear(dData,dNascto)
       Else
              nIdade  := DateDiffYear(dDataInc,dNascto)
       Endif   
ElseIf BA1->BA1_10ANOS == "S"
       cAnoAux := StrZero(val(subs(dtos(dDataInc),1,4)),4)
       cMesAux := PLSSTRMES(dDataInc)
   
       dData   := ctod("01/"+cMesAux+"/"+Subs(cAnoAux,3,2))
       nIdade  := DateDiffYear(dData,dNascto)
Endif   
//Ŀ
// Busca a faixa etaria para este usuario...                           
//
If     cTipo == "T"
       cCodAux := "1"
ElseIf cTipo == "D"  
       cCodAux := "2"
ElseIf cTipo == "A"         
       cCodAux := "3"
Endif       
       
BB3->(DbSetOrder(1))
If BB3->(MsSeek(xFilial("BB3")+cPlano+cCodAux))
   While ! BB3->(Eof()) .And. BB3->(BB3_FILIAL+BB3_CODPLA+BB3_TIPUSR) == xFilial("BB3")+cPlano+cCodAux
         If nIdade >= BB3->BB3_IDAINI .And. nIdade <= BB3->BB3_IDAFIN
             nRet := BB3->BB3_VALFAI*nCoefic
         Endif   
   BB3->(DbSkip())
   Enddo
Endif
//Ŀ
// Retorno da funcao...                                                
//
Return(nRet)




Function PLRETMATR(lDigito)
DEFAULT lDigito := .T.
Return(BA1->(BA1_CODINT+"."+BA1_CODEMP+"."+BA1_MATRIC+"-"+BA1_TIPREG+If(lDigito,"-"+BA1_DIGITO,"")))



Function PLCData(cData)
Return(Subs(cData,7,2)+"/"+Subs(cData,5,2)+"/"+Subs(cData,3,2))

Function GeraSQL()
LOCAL nIndice := 0
LOCAL cExpSQL := Space(00)

For nIndice := 1 To FCount()
    cExpSQL := cExpSQL + FieldName(nIndice)+", "
Next

cExpSQL := Subs(cExpSQL,1,Len(cExpSQL)-2)

Return(cExpSQL)


Function PLInitPad(cA,aH,aC)
LOCAL n, SX3Order := SX3->(IndexOrd()), cArea := Alias(), cCampo

SX3->(DbSetOrder(1))

For n := 1 To Len(aH)
    cCampo := AllTrim(aH[n,2])
    If ExistIni(cCampo)
       If SX3->(MsSeek(cA))
          While SX3->X3_ARQUIVO == cA
                If AllTrim(SX3->X3_CAMPO) == cCampo
                   aC[1,n] := InitPad(SX3->X3_RELACAO)
                Endif
          SX3->(DbSkip())
          Enddo
       Endif
    Endif

Next

SX3->(DbSetOrder(SX3Order))

DbSelectArea(cArea)

Return

Function PLRETGET(cCampo,aHdr,aCls,oBrowse)
DEFAULT aHdr := aHeader            
DEFAULT aCls := aCols                     

Return(aCls[n,Ascan(aHdr,{|a| AllTrim(a[2]) = AllTrim(cCampo)})])




Function PLRETFAM()
Return(BA3->(BA3_CODINT+"."+BA3_CODEMP+"-"+BA3_MATRIC))





Function PLGERCOB()

If ! Pergunte("PLA700",.T.)
   Return
Endif
   
cAno    := mv_par01
cMes    := mv_par02
cMatric := BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC)

PLSA760(cMatric,cAno,cMes)

Return




Function PLCONVMAT(cMatric)
Return(Subs(cMatric,1,3)+"."+Subs(cMatric,4,4)+"-"+Subs(cMatric,8,6))



Function PLREAJUS(cCodEmp,dDataInc,nRet,cAno,cMes,aRet)

BH9->(DbSetOrder(1))

If BH9->(MsSeek(xFilial("BH9")+cCodEmp))
   While ! BH9->(Eof()) .And. BH9->(BH9_FILIAL+BH9_CODEMP) == xFilial("BH9")+cCodEmp
         
         //Primeiro tratamento...         
         cAnoFim := Subs(BH9->BH9_DATFIN,1,4)
         cMesFim := Subs(BH9->BH9_DATFIN,5,2)
         
         cAnoIni := Subs(dtos(dDataInc),1,4)
         cMesIni := Subs(dtos(dDataInc),5,2)
         
         nRes    := PLSDIFANOS(cAnoIni,cMesIni,cAnoFim,cMesFim,"M")
         
         If nRes < 12
            BH9->(DbSkip())
            Loop
         Endif   

         //Segundo tratamento...
         cAnoFim := cAno
         cMesFim := cMes
         
         cAnoIni := Subs(dtos(dDataInc),1,4)
         cMesIni := Subs(dtos(dDataInc),5,2)
         
         nRes    := PLSDIFANOS(cAnoIni,cMesIni,cAnoFim,cMesFim,"M")
         
         If nRes >= 12
            lReaj := .F.
            nRea  := 0 
          If     cAno+cMes >= BH9->BH9_DATINI .And. BH9->BH9_DATINI >= subs(dtos(BA3->BA3_DATBAS),1,6)
                   If     cAno == Subs(BH9->BH9_DATINI,1,4)                         
                          If subs(dtos(dDataInc),5,2) >= Subs(BH9->BH9_DATINI,5,2) .And. cMes >= subs(dtos(dDataInc),5,2)
                             nRea :=((nRet*BH9->BH9_PERPAD)/100)               
                             nRet := nRet + nRea
                             lReaj:= .T.
                          Endif
                   ElseIf cAno >  Subs(BH9->BH9_DATINI,1,4)
                          nAnos := Val(cAno)-Val(Subs(BH9->BH9_DATINI,1,4))
                          If     nAnos > 1
                                 nRea := ((nRet*BH9->BH9_PERPAD)/100)                                         
                                 nRet := nRet + nRea
                                 lReaj:= .T.
                          ElseIf nAnos == 0
                                 If cMes >= subs(dtos(dDataInc),5,2)
                                    nRea := ((nRet*BH9->BH9_PERPAD)/100)               
                                    nRet := nRet + nRea
                                    lReaj:= .T.
                                 Endif   
                          ElseIf nAnos == 1
                                 If (cMes >= subs(dtos(dDataInc),5,2) .Or. subs(dtos(dDataInc),5,2) > Subs(BH9->BH9_DATINI,5,2) )
                                    nRea := ((nRet*BH9->BH9_PERPAD)/100)               
                                    nRet := nRet + nRea
                                    lReaj:= .T.
                                 Endif   
                          Endif   
                   Endif
            Endif
            If lReaj .And. ValType(aRet) == "A" .And. nRea > 0
               aadd(aRet,{"","FAMILIA",1,0,"ANS","REAJUSTE ANS REF "+BH9->BH9_DATINI,nRea,nRet})
            Endif   
        Endif             
               
   BH9->(DbSkip())
   Enddo   
Endif      

Return(nRet)

/*


Ŀ
Funcao     PLNOMUSR  Autor  Tulio Cesar            Data  15.09.00 
Ĵ
Descricao  Retorna o nome de um usuario de acordo com a matricula.    
ٱ


*/
Function PLNOMUSR(cMatric)

BA1->(DbSetOrder(2))

BA1->(MsSeek(xFilial("BA1")+cMatric))

Return(IF(BA1->(Found()),BA1->BA1_NOMUSR,"USUARIO NAO ENCONTRADO: MATRICULA "+cMatric))

/*


Ŀ
Funcao     PLADCON   Autor  Tulio Cesar            Data  15.09.00 
Ĵ
Descricao  Aplica um aumento ou desconto a um usuario...              
ٱ


*/
Function PLADCON(cMatric,nRet,cAno,cMes,lDetalhado,aRet)
//Ŀ
// Tratamento para buscar descontos para os usuarios desta familia...  
//
BI2->(DbSetOrder(1))

nRetAnt := nRet
nFator  := 0
cTipo   := ""
cDif    := 0

If BI2->(MsSeek(xFilial("BI2")+cMatric))
   While ! BI2->(Eof()) .And. BI2->(BI2_FILIAL+BI2_CODINT+BI2_CODEMP+BI2_MATRIC) == xFilial("BI2")+cMatric
   
         If cAno+cMes >= BI2->(BI2_ANOINI+BI2_MESINI) .And. cAno+cMes <= BI2->(BI2_ANOFIN+BI2_MESFIN)
            // Dentro dos parametros
         Else 
            BI2->(DbSkip())
            Loop
         Endif   
         
         nPerc  := 0
         cTipo  := BI2->BI2_TIPO
         cDif   := IF(BI2->BI2_PERC>0,"P","V")
         nFator := IF(BI2->BI2_PERC>0,BI2->BI2_PERC,BI2->BI2_VALOR)
         If     BI2->BI2_PERC > 0
                nPerc := (nRet*BI2->BI2_PERC)/100
                   
                If BI2->BI2_TIPO == "D"
                   nRet  := nRet - nPerc
                Else           
                   nRet  := nRet + nPerc
                Endif   
         ElseIf BI2->BI2_VALOR > 0
                nPerc := BI2->BI2_VALOR
                If BI2->BI2_TIPO == "D"
                   nRet  := nRet - BI2->BI2_VALOR
                Else
                   nRet  := nRet + BI2->BI2_VALOR
                Endif   
         Endif       
         
         If lDetalhado
            aadd(aRet,{"","FAMILIA",nFator,0,"BI2",If(cTipo=="D","DESCONTO ","ACRESCIMO ")+IF(cDif=="P"," EM %"," EM R$"),nPerc,nRet})
         Endif   

   BI2->(DbSkip())
   Enddo
Endif   

Return(nRet)


/*


Ŀ
Funcao     PLRETPOS  Autor  Tulio Cesar            Data  16.05.00 
Ĵ
Descricao  Retorno posicao em um aHeader                              
ٱ


*/
Function PLRETPOS(cCampo,aHdr,lHelp)
LOCAL nCol
DEFAULT aHdr := aHeader
DEFAULT lHelp := .F.

nCol := Ascan(aHdr,{|a| AllTrim(a[2]) == AllTrim(cCampo)})

Return(nCol)


Function PLMontVen(nDia,cMes,cAno)

LOCAL dVencto  := ctod("")

While Empty(dVencto)
      dVencto  := ctod(StrZero(nDia,2)+"/"+cMes+"/"+Subs(cAno,3,2))
      If Empty(dVencto)
         nDia     := nDia - 1
      Endif   
Enddo    

Return(dVencto)



Function PLSRETInt(cCodTip,cCodInt)
LOCAL nOrdOld := BA0->(IndexOrd())
LOCAL nRegOld := BA0->(Recno())
LOCAL cRet    := ""

BA0->(DbSetOrder(1))
If BA0->(MsSeek(xFilial("BA0")+cCodTip+cCodInt))
   cRet := BA0->BA0_NOMINT
Else  
   cRet := Space(Len(BA0->BA0_NOMINT))
Endif      

BA0->(DbGoTo(nRegOld))
BA0->(DbSetOrder(nOrdOld))

Return(cRet)

/*/


Ŀ
Funcao    PLSQTDUSR  Autor  Tulio Cesar        Data  08.08.00 
Ĵ
Descricao  Retorno a quantidade de usuarios de um contrato...     
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRU?AO INICIAL          
Ĵ
Programador  Data    BOPS   Motivo da Altera??o                 
Ĵ
Padua       01/08/02      Novo para contar por tipo de usuario  
ٱ


nTipo : Define se o Tipo do Usuario ou usado como grau de Parentesco:
0 - Todos Usuarios
1 - Titular , Dependente, Agregado .. etc
2 - Filho, Filha, Esposa.. etc          
/*/
Function PLSQTDUSR(cMatric,nTipo,cTipUsr)
LOCAL nQtdUsr    := 0         
LOCAL aQtdUsr    := {}
LOCAL cSQL       := "" 
Default cTipUsr  := "" 
Default nTipo    := 0  
                      
   cSQL := " SELECT BA1_TIPUSU,BA1_GRAUPA,BA1_MOTBLO FROM "+RetSQLName("BA1")+" WHERE "
   cSQL += " BA1_FILIAL = '"+xFilial("BA1")+"' AND "
   cSQL += " BA1_CODINT = '"+Substr(cMatric,1,4)+"' AND "
   cSQL += " BA1_CODEMP = '"+Substr(cMatric,5,4)+"' AND "                                       
   cSQL += " BA1_MATRIC = '"+Substr(cMatric,9,6)+"' AND "
   cSQL += " D_E_L_E_T_= '' "
   
   cSQL := ChangeQuery(cSQL)
   DbUseArea(.T.,'TOPCONN',TCGENQRY(,,cSQL),"TrbBA1",.T.,.T.)

   While !TrbBA1->(Eof()) 
         If Empty(TrbBA1->BA1_MOTBLO)
            if nTipo <> 0
              if Upper(cTipUsr) == "VET"
                 nTemp := aScan(aQtdUsr,{|x|x[1]==if(nTipo==1,TrbBA1->BA1_TIPUSU,TrbBA1->BA1_GRAUPA)})
                 if nTemp > 0  
                     aQtdUsr[nTemp,2] := aQtdUsr[nTemp,2] + 1
                 Else
                     aadd(aQtdUsr,{if(nTipo==1,TrbBA1->BA1_TIPUSU,TrbBA1->BA1_GRAUPA),1})
                 Endif    
              Elseif if(nTipo==1,TrbBA1->BA1_TIPUSU,TrbBA1->BA1_GRAUPA) == cTipUsr
                 nQtdUsr ++
              Endif
            Else     
               nQtdUsr ++
            Endif   
         Endif   
   TrbBA1->(DbSkip())
   Enddo
   TrbBA1->(DbCloseArea())
//Ŀ
// Se foi pedido um vetor, retorno o mesmo..                           
//
if Upper(cTipUsr) == "VET"
   Return(aQtdUsr)
Endif
Return(nQtdUsr)

/*/


Ŀ
Funcao    PLQTUSEMP  Autor  Antonio de Padua   Data  11.09.02 
Ĵ
Descricao  Retorno a quantidade de usuarios de um sub-contrato... 
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRU?AO INICIAL          
Ĵ
Programador  Data    BOPS   Motivo da Altera??o                 
Ĵ
ٱ


/*/
Function PLQTUSEMP(	cCodInt,cCodEmp,cNumCon,cVerCon,;
					cSubCon,cVerSub,cForPag,cCpoForPag,;
					cMes,cAno)
					
LOCAL aQtdUsr   := {}
LOCAL cSQL      := ""
Local lPorFor 	:= cForPag <> Nil

DEFAULT cCpoForPag := "BA3_FORPAG"
DEFAULT cMes := ''
DEFAULT cAno := ''

cSQL :=	" SELECT BA1_CODINT, BA1_CODEMP, BA1_CONEMP, BA1_VERCON, BA1_SUBCON, " 
cSql += " BA1_VERSUB, BA1_TIPUSU, BA1_MATRIC, BA1_TIPREG,BA1_DIGITO, BA1_SEXO, BA3_FORPAG, BA1.R_E_C_N_O_ REG "
cSql += " FROM "+RetSqlName("BA1")+" BA1, "+RetSqlName("BA3")+" BA3 "
cSql += " WHERE BA1_FILIAL = '" + xFilial("BA1") + "' "
cSql += " AND BA1_CODINT = '" +cCodInt+"' "
cSql += " AND BA1_CODEMP = '" +cCodEmp+"' "

If ! Empty(cNumCon)
	cSQL +=	" AND BA1_CONEMP = '" + cNumCon + "' "
	cSql += " AND BA1_VERCON = '" + cVerCon + "' "
Endif
If ! Empty(cSubCon)
	cSQL += " AND BA1_SUBCON = '" + cSubCon + "' " 
	cSql += " AND BA1_VERSUB = '" + cVerSub + "' "
Endif

cSQL +=	" AND BA1.D_E_L_E_T_ = ' ' "
cSQL += " AND BA3.D_E_L_E_T_ = ' ' " 
cSQL += " AND BA3.BA3_FILIAL = BA1.BA1_FILIAL " 
cSQL +=	" AND BA3.BA3_CODINT = BA1.BA1_CODINT " 
cSQL += " AND BA3.BA3_CODEMP = BA1.BA1_CODEMP " 
cSQL += " AND BA3.BA3_MATRIC = BA1.BA1_MATRIC " 
cSQL += " AND BA3.BA3_CONEMP = BA1.BA1_CONEMP " 
cSQL += " AND BA3.BA3_VERCON = BA1.BA1_VERCON " 
cSQL += " AND BA3.BA3_SUBCON = BA1.BA1_SUBCON " 
cSQL += " AND BA3.BA3_VERSUB = BA1.BA1_VERSUB "

If lPorFor
	cSQL += " AND BA3." + cCpoForPag + " = '" + cForPag + "' "
Endif

cSQL := ChangeQuery(cSQL)
DbUseArea(.T.,'TOPCONN',TCGENQRY(,,cSQL),"TrbBA1",.T.,.T.)

While !TrbBA1->(Eof())
	// Posiciona o cadastro de usuarios...
	//BA1->( dbGoto(TrbBA1->REG) )
	
	// Analisa se usuario esta ativo na competencia informada...
	If 	AnalisaUsr(cAno,cMes,nil, nil,nil) [1]
		aadd( aQtdUsr,{TrbBA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO),;
			TrbBA1->REG,;
			TrbBA1->BA1_SEXO,;
			TrbBA1->BA1_TIPUSU} )
	Endif
	
	TrbBA1->(DbSkip())
Enddo
TrbBA1->(DbCloseArea())

Return(aQtdUsr)

/*/


Ŀ
Funcao    PlsVldGd   Autor  Eduardo Motta          Data  13.09.01 
Ĵ
Descricao  Controla a mudanca de linha da getdados                    
Ĵ
Sintaxe   PlsVldGd(oBrw,aCampo)                                       
ٱ
|          |oBrw = Browse onde sera feita a pesquisa                    |
|||
|          |uCampo=Vetor com os campos a validar.                       |
ٱ


/*/
Function PlsVldGd(uCampos,lHelp,xaCols,lInsert,bCond,cAliVig,xaHeader)
Local aCamp 	:= {}
Local nI 		:= 0
Local nJ 		:= 0
LOCAL nPosCOL   := 0
Local aValores 	:= {}
Local lRet 		:= .T.
Local lAchou 	:= .F.
Local nStart    := 0
LOCAL nLiOld    := 0
DEFAULT lInsert := .F.
DEFAULT lHelp 	:= .T.
DEFAULT uCampos := SubStr(ReadVar(),4)
DEFAULT xaCols 	:= aCols
DEFAULT bCond	:= {||.T.}
DEFAULT cAliVig := ''
DEFAULT xaHeader := aHeader

If ValType(uCampos) == "C"
   aadd(aCamp,GdFieldPos(AllTrim(uCampos),xaHeader))
ElseIf ValType(uCampos) == "A"
   aCamp := {}
   For nI := 1 to Len(uCampos)
      aadd(aCamp,GdFieldPos(AllTrim(uCampos[nI]),xaHeader))
   Next
Else  // nao foi passado o parametro uCampos (ERRO)
   Return NIL      
EndIf
For nI := 1 to Len(aCamp)
   aadd(aValores,&("M->"+AllTrim(xaHeader[aCamp[nI],2])))
Next       
        
nLiOld := N
If lInsert .And. N <> Len(xaCols)
   N := Len(xaCols)
EndIf

nStart := 1
While .T.
   nPosCOL := 0
   nPosCOL := AScan(xaCols,{|x|CompCols(x,aCamp,aValores)},nStart)
   If nPosCOL # N
      Exit
   EndIf
   nStart := nPosCOL+1
EndDo 
If nPosCOL # 0 .And. Eval(bCond)
   lRet := .F.
EndIf

If lHelp .and. !lRet
   Help(" ",1,"JAGRAVADO")
EndIf
N := nLiOld

Return lRet
/*/


Ŀ
Funcao    CompCols   Autor  Eduardo Motta          Data  25.09.01 
Ĵ
Descricao  Funcao auxiliar para a PlsVldGD                            
Ĵ
Sintaxe   CompCols(aLinha,aCampos,aValores)                           
ٱ


/*/
Function CompCols(aLinha,aCamp,aValores)
Local lRet := .T.
Local nJ   := 0
If aLinha[Len(aLinha)]  // se a linha estiver DELETADA
   Return .F.
EndIf
For nJ := 1 to Len(aCamp)
   If aLinha[aCamp[nJ]] # aValores[nJ]
      lRet := .F.
      Exit
   EndIf
Next
Return lRet


/*


ͻ
Programa  PLSMLIB   Autor  Microsiga            Data   12/22/03   
͹
Desc.                                                                 
                                                                      
͹
Uso        AP                                                        
ͼ


*/

Function PLSRelTop()
LOCAL lRet := .T.
#IFNDEF TOP
         MsgInfo("Este relatorio somente esta disponivel para ambiente TopConnect")
         lRet := .F.
#ENDIF         
Return(lRet)



/*


ͻ
Programa  PLSParSQL Autor  Tulio Cesar          Data   12/22/03   
͹
Desc.      Parce entre SQL/ORACLE usada no PLSQUERY!                  
                                                                      
͹
Uso        AP                                                         
ͼ


*/
Function PLSParSQL(cFilADV)

cFilADV := StrTran(Upper(cFilADV),".AND."," AND ")
cFilADV := StrTran(cFilADV,".OR."," OR ")
cFilADV := StrTran(cFilADV,"=="," = ")
cFilADV := StrTran(cFilADV,'"',"'")
cFilADV := StrTran(cFilADV,'$'," IN ")
cFilADV := StrTran(cFilADV,'ALLTRIM(',"LTRIM(")
cFilADV := StrTran(cFilADV,'DTOS(',"(")

Return(cFilADV)

Function PLSAvaSQL(cSQL)
cSql := PLSConSQL(cSQL)
Return(cSQL)

/*/{Protheus.doc} PLSCPOSSE1
@author  PLS TEAM
@version P12
@since   25/05/04
/*/
function PLSCPOSSE1(cTipo, lLegenda)

local aCabFin  := {}
local cCposE1  := allTrim(getNewPar("MV_PLCPSE1",'E1_VENCREA,E1_SALDO,E1_PREFIXO,E1_NUM,E1_PARCELA,E1_TIPO,E1_BAIXA,E1_PLNUCOB')) + ",E1_VENCREA,E1_SALDO,E1_PREFIXO,E1_NUM,E1_PARCELA,E1_BAIXA,E1_PLNUCOB" 
local aTrb     := StrTokArr(cCposE1, "," )
local nCont    := 0
local nPosBaixa:=0

Default lLegenda := .F.

if select("BKP") != 0
    
    SX3->(DbSetOrder(2))
    BKP->(DbSetOrder(1))
    BKP->(DbGoTop())
   
    while ! BKP->(Eof())         

         if SX3->(MsSeek(BKP->BKP_CAMPO))
            
            if cTipo == "C" .And. BKP->BKP_CONTRA == "S"

                  aadd(aCabFin,{trim(X3TITULO()),SX3->X3_CAMPO,;
                                SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,;
                                SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT,SX3->X3_ORDEM})
            
            elseIf cTipo == "A" .And. BKP->BKP_ATEND == "S"                

                  aadd(aCabFin,{trim(X3TITULO()),SX3->X3_CAMPO,;
                                SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,;
                                SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT,SX3->X3_ORDEM})

            endIf        

         endIf   

    BKP->(DbSkip())
    endDo

endIf    

SX3->(DbSetOrder(2))

//Verifica se existem campos que sao obrigatorios no browse...        
for nCont := 1 to Len(aTrb)

    if PLRETPOS(aTrb[nCont], aCabFin, .f.) == 0

       if SX3->( msSeek(aTrb[nCont]))
      
          aadd(aCabFin,{trim(X3TITULO()),SX3->X3_CAMPO,;
                         SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,;
                         SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT,SX3->X3_ORDEM})

        endIf

    endIf

next

//Incluso dos dias de atraso para atender a nonos clientes
If cTipo == "A" 
   nPosBaixa:= Ascan(aCabFin,{|x| AllTrim(x[2]) == "E1_BAIXA"})
   If nPosBaixa > 0
      nOrdBaixa := StrZero(Val((aCabFin[nPosBaixa,11]))+1,2)
      aadd(aCabFin,{'Dias atraso','E1_ATRPLS','@!',5,0,'','','','','',nOrdBaixa})
   Endif
Endif

// Legenda dos Ttulos
If lLegenda
   aadd(aCabFin, {"Status", "STATUS", '@BMP', 6, 0, "", "", "", "", "", "00"})
EndIf

aSort(aCabFin,,, { | x,y | x[11] < y[11] })

return(aCabFin)

Function PLSGetVer()
Return(strTran(cVer,".",""))

Function PlsSQLOrd(cOrdem)

cOrdem := STRTran(cOrdem,"+",",")
cOrdem := StrTran(cOrdem,"DTOS(","")
cOrdem := StrTran(cOrdem,")","")

Return(cOrdem)
/*/


Ŀ
Funcao    PLSVERBLO  Autor  Michele Tatagiba       Data  29.01.02 
Ĵ
Descricao  Verifica se o usuario esta bloqueado e se pode fazer       
|          |algum procedimento                                          |
ٱ

/*/
Function PLSVERBLO(cCodInt,cCodEmp,cMatric,cTipReg)

LOCAL lRet    := .T.

//Ŀ
// Testa se o usuario/contrato esta bloqueado...                            
//                    
BA3->(DBSetOrder(1))
If BA3->(MsSeek(xFilial("BA3")+cCodInt+cCodEmp+cMatric))
   If Empty(BA3->BA3_MOTBLO)
      BA1->(DBSetOrder(2))
      If BA1->(MsSeek(xFilial("BA1")+cCodInt+cCodEmp+cMatric+cTipReg))
         If !Empty(BA1->BA1_MOTBLO)
            //Ŀ
            // Se o usaurio  estiver bloqueado, vou verificar se o codigo do bloqueio   
            // permite que o usuario utilize o plano                                          
            //                    
            BG3->(DBSetOrder(1))
            If BG3->(MsSeek(xFilial("BG3")+BA1->BA1_MOTBLO))
               If BG3->BG3_PERPLA == "0" //0==Nao;1==Sim
                  lRet := .F.
                  MsgStop(AllTrim(BA1->BA1_NOMUSR)+Chr(13)+Chr(13)+"USUARIO(A) BLOQUEADO(A) EM "+dtoc(BA1->BA1_DATBLO)+Chr(13)+Chr(13)+"MOTIVO : "+Posicione("BG3",1,xFilial("BG3")+BA1->BA1_MOTBLO,"BG3_DESBLO"))
               Endif
            Else
               Help("",1,"PLSVERBLO")
               lRet := .F.
            Endif             
                        
         Endif
      Endif
   Else      
      //Ŀ
      // Se o contrato estiver bloqueado, vou verificar se o codigo do bloqueio   
      // permite que o usuario utilize o plano                                          
      //                    
      BG1->(DBSetOrder(1))
      If BG1->(MsSeek(xFilial("BG1")+BA3->BA3_MOTBLO))
         If BG1->BG1_PERPLA == "0" //0==Nao;1==Sim
            lRet := .F.
            MsgStop(" CONTRATO BLOQUEADO EM "+dtoc(BA3->BA3_DATBLO)+Chr(13)+Chr(13)+"MOTIVO : "+Posicione("BG1",1,xFilial("BG1")+BA3->BA3_MOTBLO,"BG1_DESBLO"))
         Endif
      Else
         Help("",1,"PLSVERBLO")
         lRet := .F.
      Endif
   Endif
Endif

Return(lRet)

/*/


Ŀ
Funcao    PLSBLOAUT  Autor  Michele Tatagiba       Data  29.01.02 
Ĵ
Descricao  Verifica se o motivo de bloqueio do contrato e automatico  
ٱ

/*/
Function PLSBLOAUT(cCodBlo,nTipo)

//Ŀ
// nTipo = 1  -> Bloqueio de usuario  (BG3)                        
// nTipo = 2  -> Bloqueio de contrato (BG1)                              
// nTipo = 3  -> Bloqueio de Rede Referenciada (BAP)                     
// nTipo = 4  -> Bloqueio de Opcional					                     
//                    
LOCAL lRet    := .F.
LOCAL cTipBlo := "1"	//	Ativo
LOCAL cMotBlo := ""
DEFAULT nTipo := 1

If nTipo == 1
	BG3->(DBSetOrder(1))
	IF BG3->(MsSeek(xFilial("BG3") + BA1->BA1_MOTBLO))
		cTipBlo := BG3->BG3_TIPBLO	//	Status Atual do Usurio
	ENDIF
	
	If readvar() == "M->BF4_MOTBLO"
		cMotBlo := oBrwOUsu:aCols[oBrwOUsu:Linha()][PLRETPOS("BF4_MOTBLO",oBrwOUsu:aHeader)]		
		If BG3->(MsSeek(xFilial("BG3") + cMotBlo)) .And. !Empty(cMotBlo)
			cTipBlo := BG3->BG3_TIPBLO	//	Status Atual do Opcional
		Endif
	EndIf
		
	If BG3->(MsSeek(xFilial("BG3") + cCodBlo))	//	Formas de (Des)Bloqueio de Usurio
		If BG3->BG3_PERBLO == "1"
			IF cTipBlo <> BG3->BG3_TIPBLO
				lRet := .T.
			ENDIF
		Endif
	Endif
ElseIf nTipo == 2
		BG1->(DBSetOrder(1))
		If BG1->(MsSeek(xFilial("BG1") + cCodBlo))	//	Formas de (Des)Bloqueio de Famlia
			If BG1->BG1_PERBLO == "1"
				lRet := .T.
			Endif
		Endif
ElseIf nTipo == 3
	BAP->(DBSetOrder(1))
	If BAP->(MsSeek(xFilial("BAP") + cCodBlo))	//	Formas de (Des)Bloqueio de RDA
		If BAP->BAP_PERBLO == "1"
			lRet := .T.
		Endif
	Endif
ElseIf nTipo == 4
	BG3->(DBSetOrder(1))
	cMotCols := oBrwOUsu:aCols[oBrwOUsu:Linha(),oBrwOUsu:PlRetPos("BF4_MOTBLO")]
	IF !Empty(Alltrim(cMotCols)) .And. BG3->(MsSeek(xFilial("BG3") + cMotCols))
		cTipBlo := BG3->BG3_TIPBLO	//	Status Atual do Opcional
	Else
		cTipBlo := "-1" //No encontrou
	ENDIF
	If BG3->(MsSeek(xFilial("BG3") + cCodBlo))	//	Formas de (Des)Bloqueio de Usurio
		If BG3->BG3_PERBLO == "1"
			IF cTipBlo <> BG3->BG3_TIPBLO .OR. Empty(M->BF4_TIPBLO)
				M->BF4_TIPBLO := BG3->BG3_TIPBLO
				lRet := .T.
			Endif
		Endif
	Endif

Endif
If !lRet
	IF nTipo == 1
		MSGINFO("O Usurio j est " + IIF(cTipBlo == '1', "des", "") + "bloqueado", "Cdigo Invlido!")
	ELSEIF nTipo == 4
		MSGINFO("O Opcional j est " + IIF(cTipBlo == '1', "des", "") + "bloqueado", "Cdigo Invlido!")
	ELSE
		Help("",1,"PLSBLOAUT")
	ENDIF
Endif

Return(lRet)

/*


ͻ
Programa  PLSESPVid Autor  Geraldo Felix Junior Data   09/11/06   
͹
Desc.     Atualiza endereco do usuario de acordo com as opcoes do     
          campo BA1_ORIEND( Origem do endereco )                      
͹
Uso        AP                                                        
ͼ


*/

Function PLSESPVid(nRegBA1,nRegBTS, lLog)
LOCAL cCpo01                                         
LOCAL cCpo02          
LOCAL cCampo
LOCAL cCpo  
LOCAL aStruBTS := BTS->(DbStruct())
LOCAL lFldOri  := BA1->( FieldPos("BA1_ORIEND") ) > 0
                    
DEFAULT lLog := .F.

BA1->(DbGoTo(nRegBA1))
BTS->(DbGoTo(nRegBTS))
     
If !lLog
	BA1->(RecLock("BA1",.F.))
Else
	RegToMemory("BA1", .F., .F. )
Endif

SX3->(DbSetOrder(1))
If SX3->(MsSeek("BA1"))
	While ! SX3->(Eof()) .And. SX3->X3_ARQUIVO == "BA1"
		cCpo := AllTrim(SX3->X3_CAMPO)

		If cCpo $ "BA1_FILIAL,BA1_ORIEND" .Or. BA1->(FieldPos(cCpo)) == 0
			SX3->(DbSkip())
			Loop
		Else
			// Trata o endereco... so leva o endereco quando o campo BA1_ORIEND existir e a origem do
			// endereco for a VIDA.
			If cCpo $ "BA1_CEPUSR, BA1_ENDERE, BA1_NR_END, BA1_COMEND, BA1_BAIRRO, BA1_MUNICI, BA1_ESTADO"
				If lFldOri
					If BA1->BA1_ORIEND <> '4'
						SX3->(DbSkip())
						Loop
					Endif
				Else
					SX3->(DbSkip())
					Loop
				Endif
			Endif

			If !lLog
				cCpo01	:= "BA1->"+cCpo
			Else
				cCpo01	:= "M->"+cCpo
			Endif
			
			cCpo02 		:= "BTS->BTS_"+Subs(cCpo,5,10)			
			cCampo 		:= "BTS_"+Subs(cCpo,5,10)

		      //Ŀ
	    	  // Criada a trava de alteracoes para conteudo vazio, pois ao replicar o BTS 
		      // para o BA1 ele estava zerando os campos nao preenchidos. Chamado TEJERW.       
		      //                    
			
			If Ascan(aStruBTS,{|x| cCampo == x[1] }) > 0 .And. IIf(! ValType(cCpo02) $ "L|N", !Empty(&cCpo02), .T.)
				&cCpo01 := &cCpo02
			Endif
		Endif
		
		SX3->(DbSkip())
	Enddo
	
	If lLog 

		PLUPTENC("BA1",4,.T.,.T.)		
	Endif
Endif    

If !lLog
	BA1->(MsUnLock())
Endif

Return

/*/


Ŀ
Funcao     PLSVLDCOL   Autor  Michele Tatagiba     Data  22.03.02 
Ĵ
Descricao  Verifica se o conteudo do campo que esta sendo digitado    
           ja existe no acols.                                        
Ĵ
Parametros aCampos => Todos os campos que precisam ser verificados    
           no acols. Ex: {"XXX","YYY","RRR"}                          
ٱ


/*/
Function PLSVLDCOL(aCampos,lHelp)
           
LOCAL lRet    := .T.
LOCAL nInd    := 1
LOCAL nQtd    := 0,nI

DEFAULT lHelp := .T.

For nInd := 1 To Len(aCols)
    nQtd := 0
    //Ŀ
    // Analiso campos a campo do vetor para verificar a igualdade                            
    //
    For nI := 1 To Len(aCampos)
        If &("M->"+aCampos[nI]) == aCols[nInd,PlRetPos(aCampos[nI])] .And. !Empty(&("M->"+aCampos[nI])) .And.;
           !aCols[nInd,Len(aHeader)+1] .And. nInd <> n
           nQtd ++
        Endif
    Next
    //Ŀ
    // Indico se os campos sao iguais                    
    //
    If nQtd == Len(aCampos)
       lRet := .F.
       Exit
    Endif
Next

If !lRet .And. lHelp
   Help("",1,"PLSVLDCOL")
Endif

Return(lRet)



/*/


Ŀ
Programa   PLSSERVER   Autor  Tulio Cesar           Data  28.08.2001 
Ĵ
Descri??o  Verifica se o sistema esta rodando no remote ou no server.    
ٱ


/*/
Function PLSSERVER()
Return(.F.)



Function PLSENCBAR(oDlg,bOk,bCancel,lMessageDel,aMoreFunc)
Local oBar
Local bSet15
Local bSet24
Local lOk
Local oBtOk
Local oBtCan
Local lVolta  := .F.                   
Local nInd
Local lConLog          
DEFAULT aMoreFunc := {}

DEFINE BUTTONBAR oBar SIZE 25,25 3D TOP OF oDlg

For nInd := 1 To Len(aMoreFunc)
         If     nInd == 1
                DEFINE BUTTON RESOURCE aMoreFunc[1,1] OF oBar GROUP ACTION Eval(aMoreFunc[1,2])  TOOLTIP OemToAnsi(aMoreFunc[1,3])
         ElseIf nInd == 2
                DEFINE BUTTON RESOURCE aMoreFunc[2,1] OF oBar GROUP ACTION Eval(aMoreFunc[2,2])  TOOLTIP OemToAnsi(aMoreFunc[2,3])            
         ElseIf nInd == 3
                DEFINE BUTTON RESOURCE aMoreFunc[3,1] OF oBar GROUP ACTION Eval(aMoreFunc[3,2])  TOOLTIP OemToAnsi(aMoreFunc[3,3])            
         ElseIf nInd == 4
                DEFINE BUTTON RESOURCE aMoreFunc[4,1] OF oBar GROUP ACTION Eval(aMoreFunc[4,2])  TOOLTIP OemToAnsi(aMoreFunc[4,3])            
         ElseIf nInd == 5
                DEFINE BUTTON RESOURCE aMoreFunc[5,1] OF oBar GROUP ACTION Eval(aMoreFunc[5,2])  TOOLTIP OemToAnsi(aMoreFunc[5,3])            
         ElseIf nInd == 6
                DEFINE BUTTON RESOURCE aMoreFunc[6,1] OF oBar GROUP ACTION Eval(aMoreFunc[6,2])  TOOLTIP OemToAnsi(aMoreFunc[6,3])            
         ElseIf nInd == 7
                DEFINE BUTTON RESOURCE aMoreFunc[7,1] OF oBar GROUP ACTION Eval(aMoreFunc[7,2])  TOOLTIP OemToAnsi(aMoreFunc[7,3])            
         ElseIf nInd == 8
                DEFINE BUTTON RESOURCE aMoreFunc[8,1] OF oBar GROUP ACTION Eval(aMoreFunc[8,2])  TOOLTIP OemToAnsi(aMoreFunc[8,3])            
         ElseIf nInd == 9
                DEFINE BUTTON RESOURCE aMoreFunc[9,1] OF oBar GROUP ACTION Eval(aMoreFunc[9,2])  TOOLTIP OemToAnsi(aMoreFunc[9,3])            
         ElseIf nInd == 10
                DEFINE BUTTON RESOURCE aMoreFunc[10,1] OF oBar GROUP ACTION Eval(aMoreFunc[10,2])  TOOLTIP OemToAnsi(aMoreFunc[10,3])            
         ElseIf nInd == 11
                DEFINE BUTTON RESOURCE aMoreFunc[11,1] OF oBar GROUP ACTION Eval(aMoreFunc[11,2])  TOOLTIP OemToAnsi(aMoreFunc[11,3])            
         ElseIf nInd == 12
                DEFINE BUTTON RESOURCE aMoreFunc[12,1] OF oBar GROUP ACTION Eval(aMoreFunc[12,2])  TOOLTIP OemToAnsi(aMoreFunc[12,3])            
         Endif
Next              

oBar:nGroups += 6
DEFINE BUTTON oBtOk RESOURCE "Ok" OF oBar GROUP ACTION ( If(type("cTudoOk") == "U","AllwaysTrue()",cTudoOk), lLoop:=lVolta,lOk:=Eval(bOk)) TOOLTIP "Ok - <Ctrl-O>"  //"OK"###"Ok - <Ctrl-O>"
SetKEY(15,oBtOk:bAction)
oDlg:bSet15 := oBtOk:bAction
     
DEFINE BUTTON oBtCan RESOURCE "Cancel" OF oBar ACTION ( lLoop:=.f.,Eval(bCancel),ButtOff(bSet15,bSet24,.T.)) TOOLTIP "Cancelar - <Ctrl-X>"  //"CANCEL"###"Cancelar - <Ctrl-X>"
SetKEY(24,oBtCan:bAction)
oDlg:bSet24 := oBtCan:bAction

oBar:bRClicked := {|| AllwaysTrue()}

Return nil


Static Function ButtOff(bSet15,bSet24,lOk)

DEFAULT lOk := .t.

if lOk
    SetKey(15,bSet15)
    SetKey(24,bSet24)
Endif

Return .t.


/*/


Ŀ
Funcao     PLSFUNCEP   Autor  Michele Tatagiba     Data  14.05.02 
Ĵ
Descricao  Verifica se o campo endereco do CEP esta preenchido        
Ĵ
Parametros cEnd = Campo que se deseja comparar com o do Arquivo BC9,  
                  e campo do endereco.                                
           cBC9 = Campo respectivo do BC9 respectivo ao cEnd.         
ٱ


/*/
Function PLSFUNCEP(cEnd,cBC9,lPergunt)
                   
LOCAL lPreenche := .F.
LOCAL cExpre1   := ""
LOCAL cExpre2   := ""           
LOCAL cExpre3   := ReadVar()      
LOCAL cExpre4   := "BC9->BC9_END" 
LOCAL cExpre5
LOCAL cAlias    := Subs(cExpre3,4,3)
LOCAL cAux      := ""
LOCAL nInd      := 1

//Ŀ
// Se o CEP estiver em branco, nao preciso verificar nada.             
//
If !Empty(&(cExpre3))
   //Ŀ
   // Analiso o conteudo do campo cEnd separando o que e tem que ser comparado e o que e endereco 
   //
   For nInd := 1 To Len(cEnd)
       If Subs(cEnd,nInd,1) == ","
          cExpre1 := "M->"+cAlias+"_"+cAux
          cAux    := ""
       Else
          cAux += Subs(cEnd,nInd,1) 
       Endif
   Next
                             
   cExpre2 := "M->"+cAlias+"_"+cAux
   //Ŀ
   // Se e a primeira vez que se digita algum CEP, nao preciso verificar nada  
   //
   If Empty(&(cExpre2))
      Return(.T.)
   Endif

   If BC9->(MsSeek(xFilial("BC9")+&cExpre3))
      cExpre5 := "BC9->BC9_"+cBC9
      //Ŀ
      // Verifico se o campo endereco do Alias e igual ao do BC9 pelo CEP que foi digitado.          
      //   
      If AllTrim(&cExpre2) == AllTrim(&cExpre4)
         If AllTrim(&cExpre1) <> AllTrim(&cExpre5)
            lPreenche := .T.
         Endif
      Endif
      
      If lPergunt
         lPreenche := MsgYesNo("Confirma a alteracao dos dados referentes a Endereco?")
      EndIf
   EndIf
EndIf

Return(lPreenche)
/*


Ŀ
Funcao     PLNUMINT  Autor  Tulio Cesar            Data  29.05.00 
Ĵ
Descricao  Retorna o numero da proxima internacao...                  
ٱ


*/
Function PLNUMINT(cOpeMov,cAno,cMes)
Return(PlNewNAut("BE4",cOpeMov,cAno,cMes,K_Incluir,""))
/*/


Ŀ
 Objeto      PLSRETACOM  Autor  Michele Tatagiba      Data  11.09.2002 
Ĵ
 Descri??o   Verifica qual a acomodacao permitida para o usuario           
Ĵ
 Uso         Advanced Protheus 7.10                                        
Ĵ
             ATUALIZACOES SOFRIDAS DESDE A CONSTRU?AO INICIAL               
Ĵ
 Programador  Data    BOPS   Motivo da Altera??o                         
Ĵ
ٱ


/*/
Function PLSRETACOM(cCodInt,cCodPla,cVerPla)

LOCAL cAcomod := ""

BI3->(DBSetOrder(1))
If BI3->(MsSeek(xFilial("BI3")+cCodInt+cCodPla+cVerPla))
   cAcomod := BI3->BI3_CODACO
Endif

Return(cAcomod)


/*/


Ŀ
Funcao     PLSVIGPAD   Autor  Michele Tatagiba     Data  05.11.02 
Ĵ
Descricao  Mensagem para quando a data vigencia padrao for maios que  
           a data de vigencia que se quer colocar.                    
Ĵ
Sintaxe    PLSVIGPAD                                                  
Ĵ
Parametros cExpre = Expressao que vai ser comparada                   ٱ
           cCadas = Nome do cadastro para a mensagem                  ٱ
ٱ


/*/
Function PLSVIGPAD(cExpre,cCadas)

LOCAL lRet := .T.

If !&(cExpre)
   MsgInfo("A data de vigencia padrao de "+cCadas+" e maior que a data de vigencia que esta sendo informada.")
   lRet := .F.
Endif

Return(lRet)


Function PLDIFANOS(cAnoIni,cMesini,cAnoFim,cMesFim,cModelo)

nAnos   := Val(cAnoFim)-Val(cAnoIni)
nMeses  := Val(cMesFim)-Val(cMesIni)
         
If     nMeses > 0
       nRes    := (nAnos*12)+nMeses
ElseIf nMeses < 0
       nRes    := (nAnos*12)-ABS(nMeses)
ElseIf nMeses == 0
       nRes    := nAnos*12     
Endif
Return(IF(cModelo=="M",nRes,nRes/12))


Function PLSTRMES(dData)
Return(subs(dtos(dData),5,2))

Function PLSTRANO(dData,lAno2000)
Default lAno2000 := .F.

If ! lAno2000
   cRet := subs(dtos(dData),3,2)
Else   
   cRet := subs(dtos(dData),1,4)
Endif
   
Return(cRet)

Function PLFilSRA(cCodEmp)

BG9->(DbSetOrder(1))

If ! BG9->(DbSeek(xFilial("BG9")+cCodEmp))
   Return("XX")
Endif

If BG9->BG9_FILESP == "1"
   Return(BG9->BG9_FILSRA)
Else
   Return(xFilial("SRA"))
Endif   


Return


/*/


Ŀ
Funcao     PLSMUDCOD   Autor  Daher			     Data  25.05.06 
Ĵ
Descricao  Dado um procedimento ele faz um de/para na tabela de precos
Ĵ
Sintaxe    PLSMUDCOD                                                  
Ĵ
Parametros cExpre = Expressao que vai ser comparada                   ٱ
           cCadas = Nome do cadastro para a mensagem                  ٱ
ٱ


/*/
Function PLSMUDCOD(cAlias)

LOCAL cCodPro := &("M->"+cAlias+"_CODPRO")
LOCAL cCodInt := PlsIntPad()
LOCAL aDadRDA := PlsGetRda()
LOCAL cCodRDA := ""                    
LOCAL cCodLoc := ""
LOCAL cCodTab := ""
    

If Len(aDadRda) >= 12
	cCodRDA := aDadRda[2]         
	cCodLoc := aDadRda[12]         
Else
	return (.T.)   
Endif
	
If SeekBB8Esp(cCodRDA,cCodInt,cCodLoc) .And. ! Empty(BB8->BB8_TABPRE)
		cCodTab := BB8->BB8_TABPRE
Endif               

BC6->(DbSetOrder(2))	
If BC6->(MsSeek(xFilial("BC6")+cCodInt+cCodRDA+cCodTab+cCodPro))
	cCodPro :=	BC6->BC6_CODPRO
Endif                    

&("M->"+cAlias+"_CODPRO") := cCodPro

return (.T.)   


Static Function SeekBB8Esp(cCodRDA,cCodInt,cCodLoc)
LOCAL lRet := .F.

lRet := BB8->(MsSeek(xFilial("BB8")+cCodRDA+cCodInt+Subs(cCodLoc,1,3)))

If ExistBlock("PLSBB8SK")
   lRet := ExecBlock("PLSBB8SK",.F.,.F.,{lRet,cCodRda,cCodInt,Subs(cCodLoc,1,3)})
Endif


Return(lRet)

/*/


Ŀ
Funcao     PLSBIGVLD   Autor  Totvs		     		    Data  25.05.06 
Ĵ
Descricao  Funo Generica para validacoes de campo que nao cabem no X3_VALID
Ĵ
Sintaxe    PLSBIGVLD()                                                 		 
Ĵ
Parametros 																	 
ٱ


/*/
Function PLSBIGVLD()

LOCAL lRet := .T.

DO CASE

	CASE ReadVar() == "M->BB2_CODPSA"
		lRet := (ExistCpo("BR8",M->BB2_CODPAD+M->BB2_CODPSA,1) .And. PLSVLDGD({"BB2_CODPSA","BB2_CODPAD"},,,) .And. PLSGATNIV(M->BB2_CODPAD,M->BB2_CODPSA,"BB2"))

	CASE ReadVar() == "M->BBI_CODPRO"
		lRet := (PlsSeek("BI3",1,M->BBI_CODINT+M->BBI_CODPRO+M->BBI_VERSAO,"BBI_DESPRO","BI3_DESCRI") .and. PlsVldGd({"BBI_CODINT","BBI_CODPRO","BBI_VERSAO"}))

ENDCASE

Return (lRet)

/*/


Ŀ
Funcao     PLSAValDat  Autor  Victor Ferreira   		    Data  09.08.12 
Ĵ
Descricao  Funcao generica utilizada para validacao de campos de data        
           inicial e final. E feita uma validacao para que o sistema possa   
           impedir que o usuario cadastre datas finais menores que iniciais. 
           O retorno e uma variavel de tipo logico com o valor .F.   		 
Ĵ
Sintaxe    PLSAValDat(dDatIn,dDatFin,lFunObr)                          		 
Ĵ
Parametros VARIAVEL		TIPO	CONTEUDO A SER INFORMADO   					 
          																	 
           dDatIn		D		Memoria do campo de Data Inicial			 
           dDatFin		D		Memoria do campo de Data Final				 
           cMsg			C		Mensagem a ser apresentada no MsgInfo		 
ٱ


/*/
Function PLSAValDat(dDatIn,dDatFin,cMsg)

Local lRet := .T.
Local cDarFin

cDarFin := ALLTRIM(DTOS(dDatFin))

If !Empty(cDarFin) .And. dDatFin < dDatIn
	lRet := .F.
	MsgInfo(cMsg, "Ateno")
Endif
 
Return (lRet)

/*/


Ŀ
Programa   CheckArray  Autor  Totvs			      Data  21.03.2013 
Ĵ
Descri??o  Compara dois arrays											 
ٱ


/*/
Static Function CheckArray(a1, a2)

Local lRet	:= .T.
Local nX	:= 0

If Len(a1) <> Len(a2)
	Return .F.
EndIf

For nX := 1 To Len(a1)
	If a1[nX] <> a2[nX]
		lRet := .F.
		Exit
	EndIf
Next

Return lRet

/*/


Ŀ
Programa   AAddCriPLS  Autor  Totvs			      Data  21.03.2013 
Ĵ
Descri??o  Add item em um array APENAS se ele no j no existir.		 
ٱ


/*/
Function AAddCriPLS(aDdArray, xItem)

Local lRet := .F.

If 0 == AScan(aDdArray,{|x| IIf(ValType(xItem)=="A" .And. ValType(x)=="A",CheckArray(x,xItem),x == xItem)})
	lRet := AAdd(aDdArray,xItem) 
EndIf	

Return lRet
