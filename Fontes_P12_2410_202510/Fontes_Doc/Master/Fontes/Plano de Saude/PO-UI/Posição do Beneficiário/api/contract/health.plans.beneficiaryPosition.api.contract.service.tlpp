#Include "tlpp-core.th"

Namespace totvs.protheus.health.plans.beneficiaryPosition.api.contract

Using Namespace totvs.protheus.health.plans.beneficiaryPosition.api.util

/*/{Protheus.doc} ContractBeneficiaryService
Classe responsavel por processar os dados de contrato dos beneficiários

@type class
@author Vinicius Queiros Teixeira
@since 03/10/2022
@version Protheus 12
/*/
Class ContractBeneficiaryService From BaseService

  	Public Method new() Constructor
    Public Method contractBeneficiary(cSubscriberId As Character) As Logical
    Public Method familyBeneficiaries(cSubscriberId As Character) As Logical

    Private Method getFieldsContract(cAlias As Character) As Character
    Private Method returnSituationStatus(cOperator As character, cCompanyCode As character, cRegistration As character, cRecordType As character, dBlockDate As date, dAdditionDate As Date) As Character
 
EndClass

/*/{Protheus.doc} new
Método construtor da classe

@type method
@author Vinicius Queiros Teixeira
@since 03/10/2022
@version Protheus 12
/*/
Method new() Class ContractBeneficiaryService
    _Super:new()
Return Self

/*/{Protheus.doc} contractBeneficiary
Método responsavel por retornar os dados de contrato do beneficiário

@type method
@author Vinicius Queiros Teixeira
@since 03/10/2022
@version Protheus 12
/*/
Method contractBeneficiary(cSubscriberId As Character) As Logical Class ContractBeneficiaryService

    Local aAreaBA1 := BA1->(FWGetArea()) As Array
    Local lSucess As Logical
    Local aVirtual := {} As Array
    Local cCodInt := '' as Character
    Local cCodPla := '' as Character
    Local cVersao := '' as Character

    BA1->(DbSetOrder(2))
    If BA1->(MsSeek(xFilial("BA1")+Padr(cSubscriberId, TamSX3("BA1_CODINT")[1]+TamSX3("BA1_CODEMP")[1]+TamSX3("BA1_MATRIC")[1]+TamSX3("BA1_TIPREG")[1]+TamSX3("BA1_DIGITO")[1])))     
        aAdd(aVirtual, {"field": "BA1_ESTCIV" , "expression" : {|| Posicione("SX5", 1, xFilial("SX5")+"33"+BA1->BA1_ESTCIV, "X5_DESCRI")}})

        Self:setFormStruct("BA1", Self:getFieldsContract(), aVirtual)

        BA3->(DbSetOrder(1))
        If BA3->(MsSeek(xFilial("BA3")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC))) // Pessoa juridica retorna os dados do subcontrato
            if BA3->BA3_TIPOUS == "2"
                aVirtual := {}
                aAdd(aVirtual, {"field": "BA3_DESEMP" , "expression" : {|| Posicione("BG9", 1, xFilial("BG9")+BA1->(BA1_CODINT+BA1_CODEMP), "BG9_DESCRI")}})
                aAdd(aVirtual, {"field": "BA3_DESSUB" , "expression" : {|| Posicione("BQC", 1, xFilial("BQC")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_CONEMP+BA1_VERCON+BA1_SUBCON+BA1_VERSUB), "BQC_DESCRI")}})
                
                Self:setFormStruct("BA3", Self:getFieldsContract("BA3"), aVirtual, .F., .F.)
            elseif Empty(BA1->BA1_CODPLA)
                Self:setFormStruct("BA3", "BA3_CODPLA", {}, .F., .F.)
            endif
            if !Empty(BA1->BA1_CODPLA) 
                cCodInt := BA1->BA1_CODINT
                cCodPla := BA1->BA1_CODPLA
                cVersao := BA1->BA1_VERSAO
            else
                cCodInt := BA3->BA3_CODINT
                cCodPla := BA3->BA3_CODPLA
                cVersao := BA3->BA3_VERSAO
            endif

            BI3->(DbSetOrder(1))
            if BI3->(MsSeek(xFilial("BI3")+cCodInt+cCodPla+cVersao))
                aVirtual := {}                                                
                aAdd(aVirtual, {"field": "BI3_DESACO" , "expression" : {|| Posicione("BI4",1,xFilial("BI4")+BI3->BI3_CODACO,"BI4_DESCRI")}})
                Self:setFormStruct("BI3",  Self:getFieldsContract("BI3"), aVirtual, .F., .F.) 
            EndIf
        EndIf
        // Atributos não-dicionário para auxiliar o front e o consumo das outras apis
        Self:setAttribute("fields", "situation", self:returnSituationStatus(BA1->BA1_CODINT, BA1->BA1_CODEMP, BA1->BA1_MATRIC, BA1->BA1_TIPREG, BA1->BA1_DATBLO, BA1->BA1_DATINC), "C")
        Self:setAttribute("fields", "card", {|| BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)}, "C")
        lSucess := .T.
        Self:nCodeStatus := 200 // Ok

    Else
        lSucess := .F.
        Self:SetError("E001", "Beneficiário não encontrado.",;
                              "Não foi encontrado nenhum beneficiário com a matricula "+cSubscriberId,;
                              404) // Not Found
    EndIf

    FWRestArea(aAreaBA1)

Return lSucess

/*/{Protheus.doc} familyBeneficiaries
Método responsavel por retornar os beneficiários da familia

@type method
@author Vinicius Queiros Teixeira
@since 10/10/2022
@version Protheus 12
/*/
Method familyBeneficiaries(cSubscriberId As Character) As Logical Class ContractBeneficiaryService

    Local aAreaBA1 := BA1->(FWGetArea()) As Array
    Local lSucess As Logical
    Local cIdFamilia As Character
    Local nPosBeneficiario := 0 As Numeric

    BA1->(DbSetOrder(2))
    If BA1->(MsSeek(FWXFilial("BA1")+Padr(cSubscriberId, TamSX3("BA1_CODINT")[1]+TamSX3("BA1_CODEMP")[1]+TamSX3("BA1_MATRIC")[1]+TamSX3("BA1_TIPREG")[1]+TamSX3("BA1_DIGITO")[1])))
        cIdFamilia := BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC)

        Self:setAttribute("", "beneficiaries", {|| {}}, "A")

        If Self:jResult:hasProperty("beneficiaries")
            If BA1->(MsSeek(FWXFilial("BA1")+cIdFamilia))
                While !BA1->(EOf()) .And. BA1->(BA1_FILIAL+BA1_CODINT+BA1_CODEMP+BA1_MATRIC) == FWXFilial("BA1")+cIdFamilia

                    aAdd(Self:jResult["beneficiaries"], JsonObject():new())
                    nPosBeneficiario := Len(Self:jResult["beneficiaries"])

                    Self:jResult["beneficiaries"][nPosBeneficiario]["card"] := BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)
                    Self:jResult["beneficiaries"][nPosBeneficiario]["name"] := Alltrim(BA1->BA1_NOMUSR)
                    Self:jResult["beneficiaries"][nPosBeneficiario]["socialName"] := Alltrim(BA1->BA1_NOMSOC)
                    Self:jResult["beneficiaries"][nPosBeneficiario]["kinship"] := Alltrim(Posicione("BRP", 1, xFilial("BRP")+BA1->BA1_GRAUPA, "BRP_DESCRI"))    
                    Self:jResult["beneficiaries"][nPosBeneficiario]["situation"] := IIf(Empty(BA1->BA1_DATBLO), "Ativo", IIf(BA1->BA1_DATBLO > dDataBase, "Bloqueio Futuro", "Bloqueado"))
                                     
                    BA1->(DbSkip())
                EndDo
            EndIf
        EndIf
        lSucess := .T.
        Self:nCodeStatus := 200
    Else
        lSucess := .F.
        Self:SetError("E001", "Beneficiário não encontrado.",;
                              "Não foi encontrado nenhum beneficiário com a matricula "+cSubscriberId,;
                              404) // Not Found
    EndIf

    FWRestArea(aAreaBA1)

Return lSucess

/*/{Protheus.doc} getFieldsContract
Método responsavel por retornar os campos de contrato (BA1) que será 
apresentados na api.

@type method
@author Vinicius Queiros Teixeira
@since 23/11/2022
@version Protheus 12
/*/
Method getFieldsContract(cAlias As Character) As Character Class ContractBeneficiaryService

    Local cFields As Character

    Default cAlias := "BA1"

    Do Case
        Case cAlias == "BA1"
            cFields := "BA1_NOMUSR,BA1_CPFUSR,BA1_MAE,BA1_DATNAS,BA1_SEXO,BA1_DRGUSR,BA1_PAI,BA1_ESTCIV,BA1_ENDERE,BA1_COMEND,BA1_BAIRRO,"+;
                       "BA1_MUNICI,BA1_ESTADO,BA1_DATBLO,BA1_MOTBLO,BA1_NOMSOC,BA1_EMAIL,BA1_DATINC,BA1_DDD,BA1_TELEFO"

            if !Empty(BA1->BA1_CODPLA)
                cFields += ",BA1_CODPLA"
            endif
        Case cAlias == "BA3"
            cFields := "BA3_CODEMP,BA3_DESEMP,BA3_CONEMP,BA3_VERCON,BA3_SUBCON,BA3_VERSUB,BA3_DESSUB"
            if Empty(BA1->BA1_CODPLA)
                cFields += ",BA3_CODPLA"
            endif
        Case cAlias == "BI3"
             cFields += "BI3_DESCRI,BI3_CODACO,BI3_DESACO"
    EndCase

Return cFields

/*/{Protheus.doc} returnSituationStatus
Método responsavel por retornar o status do beneficiário estando ativo, bloqueado ou com bloqueio futuro

@type method
@author Gabriel Lakatos
@return character, retorna o status do beneficiário
@since 30/05/2025
@version 12.1.2410
/*/
Method returnSituationStatus(cOperator As character, cCompanyCode As character, cRegistration As character, cRecordType As character, dBlockDate As date, dAdditionDate As Date) As Character Class ContractBeneficiaryService

    Local aAreaBA1 := {} As Array
    Local aVgDatBlo := {} As Array
    Local lIsBloc := .F. As Logical
    Local lWillBloc := .F. As Logical
    Local cStatus As Character

    aAreaBA1 := BA1->(GetArea())

	lIsBloc := PlChHiBlo('BCA',dDatabase,cOperator+cCompanyCode+cRegistration,cRecordType,nil,nil,nil,nil,@aVgDatBlo,.F.)

    //verifica se tem bloqueio futuro
	if !lIsBloc
		if len(aVgDatBlo) > 0
			if valType(aVgDatBlo[1][1]) == "C"
				lWillBloc := aScan(aVgDatBlo,{|x| alltrim(x[1]) > dtos(dDatabase)}) > 0
			else
				lWillBloc := aScan(aVgDatBlo,{|x| x[1] > dDatabase }) > 0
			endif
		endif
	endIf

    if lIsBloc .or. (!lWillBloc .and. !empty(dBlockDate))
		cStatus := "Bloqueado"
	elseif lWillBloc .and. !empty(dBlockDate)
		cStatus := "Bloqueio Futuro"
	elseif dAdditionDate <= dDataBase
		cStatus := "Ativo"
	endIf

	restArea(aAreaBA1)

Return cStatus
