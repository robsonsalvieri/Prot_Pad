#Include "tlpp-core.th"

Namespace totvs.protheus.health.plans.api.invoicing.title

Using Namespace totvs.protheus.health.plans.api.util

/*/{Protheus.doc} TitleAdapter
Classe adaptadora de collenction de Títulos - Base de dados

@type class
@author Vinicius Queiros Teixeira
@since 14/02/2023
@version Protheus 12
/*/
Class TitleAdapter From BaseAdapter

	Public Method new() Constructor
	Public Method getPageTitles() As Logical
	public method getTotalTitles() as json

	Private Method mapFieldsTitles() As Logical
	Private Method getQueryTitles() As Character
	Private Method getWhereTitles() As Character
	Private Method getOrderTitles() As Character

EndClass

/*/{Protheus.doc} new
Método construtor da classe

@type method
@author Vinicius Queiros Teixeira
@since 14/02/2023
@version Protheus 12
/*/
Method new() class TitleAdapter

	_Super:new()

Return Self

/*/{Protheus.doc} getPageTitles
Método responsavel por retornar a pagina de Títulos

@type method
@author Vinicius Queiros Teixeira
@since 14/02/2023
@version Protheus 12
/*/
Method getPageTitles() As Logical Class TitleAdapter

	Local lSucess := .F. As Logical
    Local cQuery := Self:getQueryTitles() As Character
    Local cWhere := Self:getWhereTitles() As Character
    Local cOrder := Self:getOrderTitles() As Character
	
	Self:mapFieldsTitles()

	If Self:executeQueryAdapter(cQuery, cWhere, cOrder)
		lSucess := .T.
	EndIf

Return lSucess

/*/{Protheus.doc} getTotalTitles
Adapta e retorna os totalizadores dos títulos financeiros no formato JSON
@type method
@version 12.1.2510
@author vinicius.queiros
@since 22/06/2025
@return json, totalizadores dos títulos incluindo quantidade e valor por status (Vencido, Aberto e Pago)
/*/
method getTotalTitles() as json class TitleAdapter

	local cQuery := self:getQueryTitles() as character
	local cWhere := self:getWhereTitles() as character
	local cFields as character
	local oExecStmt as object
	local cAlias as character
	local jResponse := JsonObject():new() as json

	jResponse["open"] := {"total": 0, "value": 0}
	jResponse["paid"] := {"total": 0, "value": 0}
	jResponse["overdue"] := {"total": 0, "value": 0}
	jResponse["titles"] := {"total": 0, "value": 0}
	
	// Faturas em aberto
	cFields += "SUM(CASE WHEN E1_SALDO > 0 THEN 1 ELSE 0 END) TOTAL_OPEN,"
	cFields += "SUM(CASE WHEN E1_SALDO > 0 THEN E1_SALDO ELSE 0 END) VALUE_OPEN,"
	// Faturas pagas
	cFields += "SUM(CASE WHEN E1_SALDO = 0 THEN 1 ELSE 0 END) TOTAL_PAID,"
	cFields += "SUM(CASE WHEN E1_SALDO = 0 THEN E1_VALOR ELSE 0 END) VALUE_PAID,"
	// Faturas vencidas
	cFields += "SUM(CASE WHEN E1_SALDO > 0 AND E1_VENCREA < " + dtos(dDataBase) + " THEN 1 ELSE 0 END) TOTAL_OVERDUE,"
	cFields += "SUM(CASE WHEN E1_SALDO > 0 AND E1_VENCREA < " + dtos(dDataBase) + " THEN E1_SALDO ELSE 0 END) VALUE_OVERDUE,"
	// Total de faturas
	cFields += "COUNT(E1_NUM) TOTAL_TITLES,"
	cFields += "SUM(E1_VALOR) VALUE_TITLES"

	cQuery := strTran(cQuery, "#QueryWhere#", cWhere)
	cQuery := strTran(cQuery, "#QueryFields#", cFields)

	oExecStmt := FwExecStatement():new(cQuery)

	cAlias := oExecStmt:openAlias()

	if !(cAlias)->(eof())
		jResponse["open"] := {"total": (cAlias)->TOTAL_OPEN, "value": (cAlias)->VALUE_OPEN}
		jResponse["paid"] := {"total": (cAlias)->TOTAL_PAID, "value": (cAlias)->VALUE_PAID}
		jResponse["overdue"] := {"total": (cAlias)->TOTAL_OVERDUE, "value": (cAlias)->VALUE_OVERDUE}
		jResponse["titles"] := {"total": (cAlias)->TOTAL_TITLES, "value": (cAlias)->VALUE_TITLES}
	endif

	(cAlias)->(dbCloseArea())

	oExecStmt:destroy()
	freeObj(oExecStmt)

return jResponse

/*/{Protheus.doc} mapFieldsTitles
Método responsavel por mapear os atributos do json com os campos da tabela de títulos

@type method
@author Vinicius Queiros Teixeira
@since 14/02/2023
@version Protheus 12
/*/
Method mapFieldsTitles() As Logical Class TitleAdapter

	self:oAdapterBase:addMapFields("customer_id", "E1_CLIENTE", .T., .F., {"E1_CLIENTE", "C", TamSX3("E1_CLIENTE")[1], 0})
	self:oAdapterBase:addMapFields("customer_store", "E1_LOJA", .T., .F., {"E1_LOJA", "C", TamSX3("E1_LOJA")[1], 0})
	self:oAdapterBase:addMapFields("customer_name", "E1_NOMCLI", .T., .F., {"E1_NOMCLI", "C", TamSX3("E1_NOMCLI")[1], 0})
	self:oAdapterBase:addMapFields("issue_date", "E1_EMISSAO", .T., .F., {"E1_EMISSAO", "C", TamSX3("E1_EMISSAO")[1], 0}, self:getFormatDate("E1_EMISSAO"))
	self:oAdapterBase:addMapFields("prefix", "E1_PREFIXO", .T., .F., {"E1_PREFIXO", "C", TamSX3("E1_PREFIXO")[1], 0})
	self:oAdapterBase:addMapFields("number", "E1_NUM", .T., .F., {"E1_NUM", "C", TamSX3("E1_NUM")[1], 0})
	self:oAdapterBase:addMapFields("parcel", "E1_PARCELA", .T., .F., {"E1_PARCELA", "C", TamSX3("E1_PARCELA")[1], 0})
	self:oAdapterBase:addMapFields("type", "E1_TIPO", .T., .F., {"E1_TIPO", "C", TamSX3("E1_TIPO")[1], 0})
	self:oAdapterBase:addMapFields("base_month", "E1_MESBASE", .T., .F., {"E1_MESBASE", "C", TamSX3("E1_MESBASE")[1], 0})
	self:oAdapterBase:addMapFields("base_year", "E1_ANOBASE", .T., .F., {"E1_ANOBASE", "C", TamSX3("E1_ANOBASE")[1], 0})
	self:oAdapterBase:addMapFields("real_due_date", "E1_VENCREA", .T., .F., {"E1_VENCREA", "C", TamSX3("E1_VENCREA")[1], 0}, self:getFormatDate("E1_VENCREA"))
	self:oAdapterBase:addMapFields("amount", "E1_VALOR", .T., .F., {"E1_VALOR", "N", TamSX3("E1_VALOR")[1], 0})
	self:oAdapterBase:addMapFields("balance", "E1_SALDO", .T., .F., {"E1_SALDO", "N", TamSX3("E1_SALDO")[1], 0})
	self:oAdapterBase:addMapFields("net_value", "E1_VALLIQ", .T., .F., {"E1_VALLIQ", "N", TamSX3("E1_VALLIQ")[1], 0})
	self:oAdapterBase:addMapFields("low_date", "E1_BAIXA", .T., .F., {"E1_BAIXA", "C", TamSX3("E1_BAIXA")[1], 0}, self:getFormatDate("E1_BAIXA"))
	self:oAdapterBase:AddMapFields("status", "STATUS", .T., .F., {"STATUS", "C", TamSX3("E1_STATUS")[1], 0},;
					  			   "CASE WHEN E1_SALDO = E1_VALOR THEN 'A' WHEN E1_SALDO > 0 AND E1_SALDO < E1_VALOR THEN 'P' WHEN E1_SALDO = 0 THEN 'B' ELSE '' END")
	self:oAdapterBase:AddMapFields("title_id", "SE1KEY", .T., .F., {"SE1KEY", "C", TamSX3("E1_PREFIXO")[1]+TamSX3("E1_NUM")[1]+TamSX3("E1_PARCELA")[1]+TamSX3("E1_TIPO")[1], 0},;
								   "CASE WHEN E1_PARCELA = ' ' THEN E1_PREFIXO"+self:concatOperator()+"E1_NUM"+self:concatOperator()+"'"+replicate("+", tamSX3("E1_PARCELA")[1])+"'"+self:concatOperator()+"E1_TIPO "+;
								   " ELSE E1_PREFIXO"+self:concatOperator()+"E1_NUM"+self:concatOperator()+"E1_PARCELA"+self:concatOperator()+"E1_TIPO END")
	self:oAdapterBase:addMapFields("situation", "E1_SITUACA", .T., .F., {"E1_SITUACA", "C", TamSX3("E1_SITUACA")[1], 0})
	self:oAdapterBase:addMapFields("company_code", "E1_CODEMP", .T., .F., {"E1_CODEMP", "C", TamSX3("E1_CODEMP")[1], 0})
	self:oAdapterBase:addMapFields("contract_code", "E1_CONEMP", .T., .F., {"E1_CONEMP", "C", TamSX3("E1_CONEMP")[1], 0})
	self:oAdapterBase:addMapFields("subcontract_code", "E1_SUBCON", .T., .F., {"E1_SUBCON", "C", TamSX3("E1_SUBCON")[1], 0})
	self:oAdapterBase:addMapFields("subcontract_description", "BQC_DESCRI", .T., .F., {"BQC_DESCRI", "C", tamSX3("BQC_DESCRI")[1], 0})

Return .T.

/*/{Protheus.doc} getQueryTitles
Método responsavel por retornar o corpo da query que busca os títulos

@type Method
@author Vinicius Queiros Teixeira
@since 14/02/2023
@version Protheus 12
/*/
method getQueryTitles() as Character class TitleAdapter

	local cQuery as character
	local cLoginUserCode as character

	cQuery := "SELECT #QueryFields# FROM "+RetSqlName("SE1")+" SE1 "

	if self:hasValidParam("loginUser")
		cLoginUserCode := posicione("BSW", 1, xFilial("BSW") + upper(self:jParams["loginUser"]), "BSW_CODUSR")

		cQuery += " INNER JOIN " + retSqlName("B40") + " B40 ON "
		cQuery += "		B40.B40_FILIAL = '" + xFilial("B40") + "' AND "
		cQuery += " 	B40.B40_CODUSR = '" + cLoginUserCode + "' AND "
		cQuery += " 	B40.B40_CODINT = SE1.E1_CODINT AND "
		cQuery += " 	B40.B40_CODEMP = SE1.E1_CODEMP AND "
		cQuery += " 	B40.B40_NUMCON = SE1.E1_CONEMP AND "
		cQuery += " 	B40.B40_VERCON = SE1.E1_VERCON AND "
		cQuery += " 	B40.B40_SUBCON = SE1.E1_SUBCON AND "
		cQuery += " 	B40.B40_VERSUB = SE1.E1_VERSUB AND "
		cQuery += " 	B40.D_E_L_E_T_ = ' ' "
	endif	

	cQuery += " LEFT JOIN " + retSqlName("BQC") + " BQC ON"
	cQuery += "	    BQC.BQC_FILIAL = '" + xFilial("BQC") + "' AND "
	cQuery += "		BQC.BQC_CODIGO = SE1.E1_CODINT " + self:concatOperator() + " SE1.E1_CODEMP AND "
	cQuery += "		BQC.BQC_NUMCON = SE1.E1_CONEMP AND "
	cQuery += "		BQC.BQC_VERCON = SE1.E1_VERCON AND "
	cQuery += "		BQC.BQC_SUBCON = SE1.E1_SUBCON AND "
	cQuery += "		BQC.BQC_VERSUB = SE1.E1_VERSUB AND "
	cQuery += "		BQC.D_E_L_E_T_ = ' ' "

  	cQuery += " WHERE #QueryWhere#"

return cQuery

/*/{Protheus.doc} getWhereTitles
Método responsavel por retornar o WHERE da query que busca os títulos

@type Method
@author Vinicius Queiros Teixeira
@since 14/02/2023
@version Protheus 12
/*/
Method getWhereTitles() As Character Class TitleAdapter

	local cQuery as character
	local aTitleStatus := {"A", "P", "B"} as array
	local nX := 0 as numeric
	local lAddStatus := .f. as logical
	local cType as character

	if self:jParams:hasProperty("status")
		aTitleStatus := strToKarr(upper(self:jParams["status"]), ",")
	endif

	cQuery := " SE1.E1_FILIAL = '"+FWxFilial("SE1")+"' AND "

	If Self:jParams:hasProperty("healthInsurerCode")
    	cQuery += " SE1.E1_CODINT = '"+Self:jParams["healthInsurerCode"]+"' AND "
	endif

	If Self:jParams:hasProperty("companyCode")
		cQuery += " SE1.E1_CODEMP = '"+Self:jParams["companyCode"]+"' AND "
	endif

	If Self:jParams:hasProperty("familyCode")
		cQuery += " SE1.E1_MATRIC = '"+Self:jParams["familyCode"]+"' AND "
	Else
		If Self:jParams:hasProperty("contractCode")
			cQuery += " SE1.E1_CONEMP = '"+Self:jParams["contractCode"]+"' AND "		
		EndIf

		If Self:jParams:hasProperty("contractVersionCode")
			cQuery += " SE1.E1_VERCON = '"+Self:jParams["contractVersionCode"]+"' AND "
		EndIf

		If Self:jParams:hasProperty("subcontractCode")
			cQuery += " SE1.E1_SUBCON = '"+Self:jParams["subcontractCode"]+"' AND "		
		EndIf

		If Self:jParams:hasProperty("subcontractVersionCode")
			cQuery += " SE1.E1_VERSUB = '"+Self:jParams["subcontractVersionCode"]+"' AND "
		EndIf
	EndIf

	if Self:jParams:hasProperty("type")
		cQuery += " SE1.E1_TIPO IN ("+Self:breakValueQuery(Self:jParams["type"])+") AND "
	else
		cType := strTran(getNewPar("MV_PLSTIT", "DP"), "'", "")
		cQuery += " SE1.E1_TIPO IN (" + self:breakValueQuery(cType) + ") AND "
	endif

	if self:jParams:hasProperty("status")
		cQuery += " ( "
		for nX := 1 to len(aTitleStatus)
			do case
				case aTitleStatus[nX] == "A" // Em aberto
					cQuery += "( E1_SALDO = E1_VALOR )"
					lAddStatus := .t.

				case aTitleStatus[nX] == "P" // Baixado Parcialmente
					cQuery += "( E1_SALDO > 0 AND E1_SALDO < E1_VALOR ) "
					lAddStatus := .t.

				case aTitleStatus[nX] == "B" // Baixado Totalmente
					cQuery += "( E1_SALDO = 0 ) "
					lAddStatus := .t.
				
				case aTitleStatus[nX] == "V" // Vencidas
					cQuery += "( E1_VENCREA < " + dtos(dDataBase) + " AND E1_SALDO > 0 ) "
					lAddStatus := .t.
			endcase

			if nX < len(aTitleStatus)
				if aTitleStatus[nX+1] $ "A/P/B/V" .And. lAddStatus
					cQuery += " OR "
					lAddStatus := .f.
				endif 		
			endif
		next nX
		cQuery += ") AND "
	endif

	if self:jParams:hasProperty("situation")
		cQuery += " SE1.E1_SITUACA IN ("+Self:breakValueQuery(Self:jParams["situation"])+") AND "
	endif

	cQuery += " SE1.D_E_L_E_T_ = ' ' "

Return cQuery

/*/{Protheus.doc} getOrderTitles
Método responsavel por retornar a ORDEM da query que busca os títulos

@type Method
@author Vinicius Queiros Teixeira
@since 14/02/2023
@version Protheus 12
/*/
Method getOrderTitles() As Character Class TitleAdapter

	Local cOrdemQuery As Character
	
	cOrdemQuery := "SE1.E1_PREFIXO, SE1.E1_NUM, SE1.E1_PARCELA, SE1.E1_TIPO"

Return cOrdemQuery
