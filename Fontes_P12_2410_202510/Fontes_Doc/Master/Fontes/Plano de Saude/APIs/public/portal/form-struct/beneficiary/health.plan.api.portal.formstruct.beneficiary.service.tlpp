#include "tlpp-core.th"
#include "health.plan.api.portal.formstruct.beneficiary.service.ch"

#define STATUS_CODE_OK 200
#define STATUS_CODE_NOT_FOUND 404

namespace totvs.protheus.health.plan.api.portal.formstruct

using namespace totvs.protheus.health.plans.api.util

/*/{Protheus.doc} BeneficiaryService
Classe responsável por gerenciar as operações de beneficiários, incluindo consultas e processamento de dados relacionados aos formulários.
@type class
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
*/
class BeneficiaryService from BaseService

	protected data jProduct as json
	protected data jFields as json
	protected data lFieldDataExecBlock as logical

	public method new() constructor
	public method destroy()

	public method getBeneficiaries() as logical
	public method setFormFields(cType as character) as logical
	public method getFieldsBase(cAlias as character) as array
	
	protected method getFormStruct() as logical
	protected method getValues(cAlias as character) as array
	protected method getOptionsType(cAlias as character) as array

	protected method setInclusionFields() as logical
	protected method setUpdateFields() as logical

	protected method getFieldOptions(cField as character, aCbox as array) as array
	protected method getFieldData(jField as json) as json
	protected method hasValidProperty(cField as character, cProperty as character) as logical
	protected method addField(aFields as array) as logical
	protected method hasValidContractParams() as logical

endclass

/*/{Protheus.doc} new
Construtor da classe BeneficiaryService, inicializa os objetos e variáveis necessárias.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@return object, instância da classe BeneficiaryService
*/
method new() class BeneficiaryService

	_Super:new()

	self:jProduct := JsonObject():new()
	self:jFields := JsonObject():new()
	self:lFieldDataExecBlock := existBlock("PTBENFORM")
	
return self

/*/{Protheus.doc} destroy
Libera os recursos utilizados pela instância da classe BeneficiaryService.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
*/
method destroy() class BeneficiaryService

	_Super:destroy()

	freeObj(self:jProduct)
	freeObj(self:jFields)

return

/*/{Protheus.doc} getBeneficiaries
Realiza a consulta dos beneficiários, retornando sucesso caso a estrutura do formulário seja obtida com êxito.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@return logical, retorna .T. se a operação for bem-sucedida, .F. caso contrário
*/
method getBeneficiaries() as logical class BeneficiaryService

	local lSuccess := .F. as logical

	lSuccess := self:getFormStruct()
	
	if lSuccess
		self:nCodeStatus := STATUS_CODE_OK
	endif

return lSuccess

/*/{Protheus.doc} setFormFields
Define os campos do formulário com base no tipo informado, para inclusão ou atualização de dados.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param cType, character, tipo da operação: "1" para inclusão e "2" para atualização
@return logical, retorna .T. se os campos forem definidos com sucesso, .F. caso contrário
*/
method setFormFields(cType as character) as logical class BeneficiaryService

	local lSuccess := .F. as logical

	do case
		case cType == "1"
			self:setInclusionFields()
			lSuccess := .T.

		case cType == "2"
			self:setUpdateFields()
			lSuccess := .T.
	endcase

return lSuccess

/*/{Protheus.doc} getFieldsBase
Obtém os campos base para um alias específico, configurando as propriedades dos campos conforme a estrutura do formulário.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param cAlias, character, alias do formulário para obter os campos
@return array, retorna um array de objetos contendo as propriedades dos campos
*/
method getFieldsBase(cAlias as character) as array class BeneficiaryService

	local aFields := {} as array
	local oStruct as object
	local nX as numeric
	local nSizeArray as numeric
	local jField as json
	local aOptions as array
	local cContainer as character
	local aFieldData as array
	local jFields as json

	jFields := self:jFields

	oStruct := FWFormStruct(2, cAlias, {|cField| jFields:hasProperty(upper(alltrim(cField)))}, .F.)
	nSizeArray := len(oStruct["aFields"])

	for nX := 1 to nSizeArray
		jField := {"property" : oStruct["aFields"][nX][1], "label" : oStruct["aFields"][nX][3]} // X3_CAMPO - X3_TITULO

		aFieldData := tamSX3(oStruct["aFields"][nX][1]) // X3_CAMPO - return: [1] Tamanho ; [2] Decimal ; [3] Tipo

		do case
			case aFieldData[3] == "D" // Date
				jField["type"] := "date"
				jField["format"] := "dd/mm/yyyy"
				
			case aFieldData[3] == "C" // Caracter
				jField["maxLength"] := aFieldData[1]
		endcase

		if !empty(cContainer := getFieldContainer(jField["property"]))
			jField["container"] := cContainer
		endif

		if self:hasValidProperty(jField["property"], "order")
			jField["order"] := self:jFields[jField["property"]]["order"]
		endif

		if self:hasValidProperty(jField["property"], "required")
			jField["required"] := self:jFields[jField["property"]]["required"]
			jField["showRequired"] := .T.
		endif

		if self:hasValidProperty(jField["property"], "label")
			jField["label"] := self:jFields[jField["property"]]["label"]
		endif

		if len(aOptions := self:getFieldOptions(jField["property"], oStruct["aFields"][nX][13])) > 0
			jField["options"] := aClone(aOptions)
		endif

		jField := self:getFieldData(jField)

		aAdd(aFields, jField)
	next nCount

	freeObj(jField)
	freeObj(oStruct)
	freeObj(jFields)

	fwFreeArray(aOptions)
	fwFreeArray(aFieldData)

return aFields

/*/{Protheus.doc} getFormStruct
Obtém a estrutura do formulário para um beneficiário, incluindo os campos de inclusão e atualização, caso aplicável.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@return logical, retorna .T. se a estrutura do formulário for obtida com sucesso, .F. caso contrário
*/
method getFormStruct() as logical class BeneficiaryService

	local lSuccess := .F. as logical
	local aExpandables := {} as array
	local lError := .F. as logical
	local nSubscriberIdSize as numeric
	local lBeneficiaryFound := .F. as logical
	local lHasSubscriberId := self:jParams:hasProperty("subscriberId") as logical
	local lHasContract := .F. as logical

	if lHasSubscriberId
		nSubscriberIdSize := tamSX3("BA1_CODINT")[1] + tamSX3("BA1_CODEMP")[1] + tamSX3("BA1_MATRIC")[1] + tamSX3("BA1_TIPREG")[1] + tamSX3("BA1_DIGITO")[1]

		BA1->(dbSetOrder(2))
		if BA1->(msSeek(xFilial("BA1") + padr(self:jParams["subscriberId"], nSubscriberIdSize)))
			lBeneficiaryFound := .T.
			self:jProduct := getProductData({"healthInsurerCode": BA1->BA1_CODINT,;
										     "companyCode": BA1->BA1_CODEMP,;
										     "familyCode": BA1->BA1_MATRIC,;
										     "contractCode": BA1->BA1_CONEMP,;
										     "contractVersion": BA1->BA1_VERCON,;
										     "subcontractCode": BA1->BA1_SUBCON,;
										     "subcontractVersion": BA1->BA1_VERSUB})
		else
			lError := .T.
			self:setError("E001",;
						  STR0001,; // "Não foi possível localizar o beneficiário informado no sistema. Por favor, verifique os dados fornecidos e tente novamente."
						  STR0002,; // "O parâmetro informado (subscriberId) não foi encontrado na tabela de beneficiários (BA1). A consulta considerou os seguintes campos: BA1_CODINT, BA1_CODEMP, BA1_MATRIC, BA1_TIPREG e BA1_DIGITO. Verifique os dados enviados e tente novamente."
						  STATUS_CODE_NOT_FOUND)
		endif
	else
		if self:hasValidContractParams()
			lHasContract := .T.
			self:jProduct := getProductData({"healthInsurerCode": self:jParams["healthInsurerCode"],;
										     "companyCode": self:jParams["companyCode"],;
										     "familyCode": "",;
										     "contractCode": self:jParams["contractCode"],;
										     "contractVersion": self:jParams["contractVersion"],;
										     "subcontractCode": self:jParams["subcontractCode"],;
										     "subcontractVersion": self:jParams["subcontractVersion"]},;
											 lHasContract)			
		endif
	endif

	if !lError
		if self:jParams:hasProperty("expand") .and. "inclusion" $ self:jParams["expand"]
			self:setInclusionFields()
			
			self:jResult["inclusion"] := JsonObject():new()

			self:jResult["inclusion"]["fields"] := self:getFieldsBase("B2N")
			self:jResult["inclusion"]["optionsType"] := self:getOptionsType("B2N")
			self:jResult["inclusion"]["attachment"] := {"enabled": .T., "required": .T., "informationMessage": STR0003} // "Documentos obrigatórios: CPF, RG (frente e verso), Certidão de Nascimento ou Casamento e Comprovante de Residência."

			if existBlock("PTBENANX")
				self:jResult["inclusion"]["attachment"] := execBlock("PTBENANX", .F., .F., {})
			endif
			
			if lHasSubscriberId .and. lBeneficiaryFound
				self:jResult["inclusion"]["values"] := self:getValues("B2N")

			elseif lHasContract
				self:jResult["inclusion"]["values"] := self:getValues("")
			endif

			self:jResult["inclusion"]["adhesionTerms"] := iif(existBlock("PTBENTAD"), execBlock("PTBENTAD", .F., .F., {}), STR0040) // "Declaro minha adesão ao plano, ciente das condições, direitos e obrigações estabelecidos. Autorizo o uso dos meus dados conforme a legislação vigente."
		else
			aAdd(aExpandables, "inclusion")
		endif

		if self:jParams:hasProperty("expand") .and. "update" $ self:jParams["expand"]
			self:setUpdateFields()

			self:jResult["update"] := JsonObject():new()

			self:jResult["update"]["fields"] := self:getFieldsBase("BA1")
			self:jResult["update"]["optionsType"] := self:getOptionsType("BA1")

			if lHasSubscriberId .and. lBeneficiaryFound
				self:jResult["update"]["values"] := self:getValues("BA1")
			endif
		else
			aAdd(aExpandables, "update")
		endif

		if len(aExpandables) > 0
			self:jResult["_expandables"] := aClone(aExpandables)
		endif

		self:jResult["additionalInfo"] := JsonObject():new()
		self:jResult["additionalInfo"]["kinshipCodeHolder"] := superGetMV("MV_PLCDTGP", .F., "01")

		lSuccess := .T.
	endif

	fwFreeArray(aExpandables)

return lSuccess

/*/{Protheus.doc} getValues
Obtém os valores dos campos baseados no alias fornecido, retornando os valores associados a cada campo.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param cAlias, character, alias do formulário para obter os valores
@return array, retorna um array de objetos contendo as propriedades e valores dos campos
*/
method getValues(cAlias as character) as array class BeneficiaryService

	local aValues := {} as array
	local nCount as numeric
	local aFields as array
	local nSizeFields as numeric
	local xValue as variant

	default cAlias := ""

	do case
		case cAlias == "B2N"
			aAdd(aValues, {"property": "B2N_CODEMP", "value": alltrim(BA1->BA1_CODEMP)})
			aAdd(aValues, {"property": "B2N_CONEMP", "value": alltrim(BA1->BA1_CONEMP)})
			aAdd(aValues, {"property": "B2N_SUBCON", "value": alltrim(BA1->BA1_SUBCON)})
		
		case cAlias == "BA1"
			aFields := self:jFields:getNames()
			nSizeFields := len(aFields)

			for nCount := 1 to nSizeFields
				xValue := &("BA1->" + aFields[nCount])

				do case
					case valType(xValue) == "D"
						xValue := transform(dtos(xValue), "@R 9999-99-99")

					case valType(xValue) == "C"
						xValue := alltrim(xValue)
				endcase

				aAdd(aValues, {"property": aFields[nCount], "value": xValue})
			next nCount

		case empty(cAlias)
			aAdd(aValues, {"property": "B2N_CODEMP", "value": self:jParams["companyCode"]})
			aAdd(aValues, {"property": "B2N_CONEMP", "value": self:jParams["contractCode"]})
			aAdd(aValues, {"property": "B2N_SUBCON", "value": self:jParams["subcontractCode"]})
	endcase

	fwFreeArray(aFields)

return aValues

/*/{Protheus.doc} getOptionsType
Obtém as opções de tipo de campo baseadas no alias fornecido, retornando os tipos de campo configurados.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param cAlias, character, alias do formulário para obter as opções de tipo de campo
@return array, retorna um array de objetos contendo as propriedades e tipos de campos
*/
method getOptionsType(cAlias as character) as array class BeneficiaryService

	local aTypes := {} as array

	do case
		case cAlias == "B2N"
			aAdd(aTypes, {"property": "B2N_CODPRO", "type": "select"})
			aAdd(aTypes, {"property": "B2N_COMUNI", "type": "select"})
			aAdd(aTypes, {"property": "B2N_GRAUPA", "type": "select"})
		
		case cAlias == "BA1"
			aAdd(aTypes, {"property": "BA1_CODPRF", "type": "select"})	
			aAdd(aTypes, {"property": "BA1_GRAUPA", "type": "select"})		
	endcase

return aTypes

/*/{Protheus.doc} setInclusionFields
Define os campos que serão utilizados para inclusão de um beneficiário, incluindo dados pessoais, de endereço, contato e plano.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@return, logical, Retorna .T. se os campos forem definidos corretamente.
*/
method setInclusionFields() as logical class BeneficiaryService

	local aPersonalData := {} as array
	local aAddressData := {} as array
	local aContactData := {} as array
	local aPlanData := {} as array

	self:jFields := JsonObject():new()

	// Informações Pessoais
	aAdd(aPersonalData, {"field": "B2N_CPFUSR", "label": STR0004, "required": .T.}) // "CPF"
	aAdd(aPersonalData, {"field": "B2N_NOMUSR", "label": STR0005, "required": .T.}) // "Nome"
	aAdd(aPersonalData, {"field": "B2N_DATNAS", "label": STR0006, "required": .T.}) // "Data de Nascimento"
	aAdd(aPersonalData, {"field": "B2N_DRGUSR", "label": STR0007, "required": .F.}) // "RG"
	aAdd(aPersonalData, {"field": "B2N_ORGEM", "label": STR0008, "required": .F.}) // "Órgão Emissor"
	aAdd(aPersonalData, {"field": "B2N_RGEST", "label": STR0009, "required": .F.}) // "Estado Emissor"
	aAdd(aPersonalData, {"field": "B2N_SEXO", "label": STR0010, "required": .T.}) // "Sexo"
	aAdd(aPersonalData, {"field": "B2N_MAE", "label": STR0011, "required": .T.}) // "Nome da Mãe"
	aAdd(aPersonalData, {"field": "B2N_PAI", "label": STR0012, "required": .F.}) // "Nome do Pai" 
	aAdd(aPersonalData, {"field": "B2N_ESTCIV", "label": STR0013, "required": .T.}) // "Estado Civil"
	aAdd(aPersonalData, {"field": "B2N_GRAUPA", "label": STR0014, "required": .T.}) // "Grau de Parentesco"
	aAdd(aPersonalData, {"field": "B2N_NRCRNA", "label": STR0015, "required": .F.}) // "Cartão Nacional de Saúde"
	aAdd(aPersonalData, {"field": "B2N_UNIVER", "label": STR0016, "required": .F.}) // "Universitário" 
	aAdd(aPersonalData, {"field": "B2N_DATADT", "label": STR0017, "required": .F.}) // "Data de Adoção" 
	aAdd(aPersonalData, {"field": "B2N_INVALI", "label": STR0018, "required": .F.}) // "Invalidez"

	// Endereço
	aAdd(aAddressData, {"field": "B2N_CEPUSR", "label": STR0019, "required": .T.}) // "CEP"
	aAdd(aAddressData, {"field": "B2N_ENDERE", "label": STR0020, "required": .F.}) // "Endereço"
	aAdd(aAddressData, {"field": "B2N_NR_END", "label": STR0021, "required": .F.}) // "Número"
	aAdd(aAddressData, {"field": "B2N_COMEND", "label": STR0022, "required": .F.}) // "Complemento"
	aAdd(aAddressData, {"field": "B2N_BAIRRO", "label": STR0023, "required": .F.}) // "Bairro"
	aAdd(aAddressData, {"field": "B2N_ESTADO", "label": STR0024, "required": .F.}) // "Estado"
	aAdd(aAddressData, {"field": "B2N_CODMUN", "label": STR0025, "required": .F.}) // "Cidade"
	aAdd(aAddressData, {"field": "B2N_MUNICI", "label": STR0025, "required": .F.}) // "Cidade"

	// Informações para contato
	aAdd(aContactData, {"field": "B2N_DDD", "label": STR0026, "required": .F.}) // "DDD"
	aAdd(aContactData, {"field": "B2N_TELEFO", "label": STR0027, "required": .F.}) // "Telefone"
	aAdd(aContactData, {"field": "B2N_EMAIL", "label": STR0028, "required": .F.}) // "E-mail"
	aAdd(aContactData, {"field": "B2N_COMUNI", "label": STR0029, "required": .F.}) // "Canais"

	// Dados do plano
	aAdd(aPlanData, {"field": "B2N_CODPRO", "label": STR0033, "required": .T.}) // "Plano"

	self:addField(aPersonalData)
	self:addField(aAddressData)
	self:addField(aContactData)
	self:addField(aPlanData)

	if existBlock("PTBENFLD")
		self:jFields := execBlock("PTBENFLD", .F., .F., {self:jFields, .T.})
	endif

	fwFreeArray(aPersonalData)
	fwFreeArray(aAddressData)
	fwFreeArray(aContactData)
	fwFreeArray(aPlanData)

return .T.

/*/{Protheus.doc} setUpdateFields
Define os campos que serão utilizados para atualização das informações de um beneficiário, incluindo dados pessoais, de endereço e de contato.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@return, logical, Retorna .T. se os campos forem definidos corretamente.
*/
method setUpdateFields() class BeneficiaryService

	local aPersonalData := {} as array
	local aAddressData := {} as array
	local aContactData := {} as array

	self:jFields := JsonObject():new()

	// Informações Pessoais
	aAdd(aPersonalData, {"field": "BA1_CPFUSR", "label": STR0004, "required": .T.}) // "CPF"
	aAdd(aPersonalData, {"field": "BA1_NOMUSR", "label": STR0005, "required": .T.}) // "Nome"
	aAdd(aPersonalData, {"field": "BA1_DATNAS", "label": STR0006, "required": .T.}) // "Data de Nascimento"
	aAdd(aPersonalData, {"field": "BA1_DRGUSR", "label": STR0007, "required": .F.}) // "RG"
	aAdd(aPersonalData, {"field": "BA1_ORGEM", "label": STR0008, "required": .F.}) // "Órgão Emissor"
	aAdd(aPersonalData, {"field": "BA1_SEXO", "label": STR0010, "required": .T.}) // "Sexo"
	aAdd(aPersonalData, {"field": "BA1_MAE", "label": STR0011, "required": .T.}) // "Nome da Mãe"
	aAdd(aPersonalData, {"field": "BA1_PAI", "label": STR0012, "required": .F.}) // "Nome do Pai" 
	aAdd(aPersonalData, {"field": "BA1_ESTCIV", "label": STR0013, "required": .T.}) // "Estado Civil"
	aAdd(aPersonalData, {"field": "BA1_GRAUPA", "label": STR0014, "required": .T.}) // "Grau de Parentesco"
	aAdd(aPersonalData, {"field": "BA1_CODPRF", "label": STR0034, "required": .F.}) // "Profissão"
	aAdd(aPersonalData, {"field": "BA1_ESCOLA", "label": STR0035, "required": .F.}) // "Escolaridade"

	// Endereço
	aAdd(aAddressData, {"field": "BA1_CEPUSR", "label": STR0019, "required": .T.}) // "CEP"
	aAdd(aAddressData, {"field": "BA1_ENDERE", "label": STR0020, "required": .F.}) // "Endereço"
	aAdd(aAddressData, {"field": "BA1_NR_END", "label": STR0021, "required": .F.}) // "Número"
	aAdd(aAddressData, {"field": "BA1_COMEND", "label": STR0022, "required": .F.}) // "Complemento"
	aAdd(aAddressData, {"field": "BA1_BAIRRO", "label": STR0023, "required": .F.}) // "Bairro"
	aAdd(aAddressData, {"field": "BA1_ESTADO", "label": STR0024, "required": .F.}) // "Estado"
	aAdd(aAddressData, {"field": "BA1_CODMUN", "label": STR0025, "required": .F.}) // "Cidade"
	aAdd(aAddressData, {"field": "BA1_MUNICI", "label": STR0025, "required": .F.}) // "Cidade"

	// Informações para contato
	aAdd(aContactData, {"field": "BA1_DDD", "label": STR0026, "required": .F.}) // "DDD"
	aAdd(aContactData, {"field": "BA1_TELEFO", "label": STR0027, "required": .F.}) // "Telefone"
	aAdd(aContactData, {"field": "BA1_EMAIL", "label": STR0028, "required": .F.}) // "E-mail"

	self:addField(aPersonalData)
	self:addField(aAddressData)
	self:addField(aContactData)

	if existBlock("PTBENFLD")
		self:jFields := execBlock("PTBENFLD", .F., .F., {self:jFields, .F.})
	endif

	fwFreeArray(aPersonalData)
	fwFreeArray(aAddressData)
	fwFreeArray(aContactData)

return

/*/{Protheus.doc} getFieldOptions
Obtém as opções para um campo específico, considerando o tipo de campo e parâmetros fornecidos.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param cField, character, nome do campo para obter as opções
@param aCbox, array, opções de filtro e configuração adicionais
@return array, retorna um array de objetos contendo as opções de valor e rótulo
*/
method getFieldOptions(cField as character, aCbox as array) as array class BeneficiaryService

	local aOptions := {} as array
	local aItens := {} as array
	local nSizeArray := 0 as numeric
	local nX := 0 as numeric
	local aFilter := {} as array

	do case
		case cField == "BA1_CODMUN"
			if self:jParams:hasProperty("subscriberId")
				aAdd(aOptions, {"value": BA1->BA1_CODMUN, "label": upper(alltrim(BA1->BA1_MUNICI))})
			endif

		case cField == "BA1_ESCOLA"
			aOptions := getSX5Options("26")

		case cField $ "B2N_ESTCIV-BA1_ESTCIV"
			aOptions := getSX5Options("33")

		case cField $ "B2N_ESTADO-B2N_RGEST-BA1_ESTADO"
			aOptions := getSX5Options("12", .T., .T.)

		case cField == "B2N_COMUNI"
			aAdd(aOptions, {"value" : "0", "label" : STR0028}) // "E-mail"
			aAdd(aOptions, {"value" : "1", "label" : STR0036}) // "SMS"
			aAdd(aOptions, {"value" : "2", "label" : STR0037}) // "Ambos"

		case cField == "B2N_CODPRO"
			if self:jProduct:hasProperty("products")
				aOptions := self:jProduct["products"]
			endif

		case cField $ "B2N_GRAUPA-BA1_GRAUPA"
			aAdd(aFilter, {"field": "BRP_FILIAL", "operator": "=", "value": xFilial("BRP")})
			aOptions := getQueryOptions({"table": "BRP", "valueColumn": "BRP_CODIGO", "labelColumn": "BRP_DESCRI", "filter": aFilter})

		case cField == "BA1_CODPRF"
			aOptions := getProfessions()

		otherwise
			nSizeArray := len(aCbox)

			if nSizeArray > 0
				for nX := 1 to nSizeArray
					aItens := strTokArr(aCbox[nX], "=")

					if len(aItens) >= 2
						if upper(alltrim(aItens[1])) <> "X"
							aAdd(aOptions, {"value" : alltrim(aItens[1]), "label" : capital(alltrim(aItens[2]))})
						endif
					endif
				next
			endif
	endcase

	fwFreeArray(aItens)
	fwFreeArray(aFilter)

return aOptions

/*/{Protheus.doc} getFieldData
Processa dados de um campo específico, aplicando máscaras, limites e outras configurações conforme o tipo de campo.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param jField, json, objeto JSON contendo o campo a ser processado
@return json, retorna o objeto JSON com as configurações atualizadas para o campo
*/
method getFieldData(jField as json) as json class BeneficiaryService

	do case
		case jField["property"] == "B2N_CPFUSR" .or. jField["property"] == "BA1_CPFUSR"
			jField["mask"] := "999.999.999-99"
			jField["maxLength"] := 14

		case jField["property"] == "B2N_CEPUSR" .or. jField["property"] == "BA1_CEPUSR"
			jField["mask"] := "99999-999"
			jField["icon"] := "an an-map-pin"
			jField["maxLength"] := jField["maxLength"] + 1

		case jField["property"] == "B2N_EMAIL" .or. jField["property"] == "BA1_EMAIL"
			jField["icon"] := "an an-envelope"
			jField["pattern"] := "\S+@\S+\.\S+"
			jField["errorMessage"] := "E-mail inválido"

		case jField["property"] == "B2N_DATNAS" .or. jField["property"] == "BA1_DATNAS"
			jField["maxValue"] := transform(dtos(dDataBase), "@R 9999-99-99")

		case jField["property"] == "BA1_DDD" .or. jField["property"] == "B2N_DDD"
			jField["mask"] := "999"

		case jField["property"] $ "BA1_CODMUN-B2N_CODMUN"
			jField["disabled"] := .T.
			jField["visible"] := .F.

		case jField["property"] $ "BA1_ESTADO-BA1_MUNICI-B2N_ESTADO-B2N_MUNICI"
			jField["disabled"] := .T.			
	endcase

	if self:lFieldDataExecBlock
		jField := execBlock("PTBENFORM", .F., .F., {jField})
	endif

return jField

/*/{Protheus.doc} hasValidProperty
Verifica se um campo e uma propriedade estão presentes no objeto `jFields`.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param cField, character, nome do campo a ser verificado
@param cProperty, character, nome da propriedade a ser verificada
@return logical, retorna .T. se o campo e a propriedade existem, .F. caso contrário
*/
method hasValidProperty(cField as character, cProperty as character) as logical class BeneficiaryService
	
return self:jFields:hasProperty(cField) .and. self:jFields[cField]:hasProperty(cProperty)

/*/{Protheus.doc} addField
Adiciona novos campos ao conjunto de campos da classe BeneficiaryService.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param aFields, array, Array contendo os campos a serem adicionados, onde cada item deve possuir "field", "label" e "required".
@return logical, Retorna .T. se os campos forem adicionados com sucesso.
*/
method addField(aFields as array) as logical class BeneficiaryService

	local nX as numeric
	local nSizeArray as numeric
	local nOrder := len(self:jFields:getNames()) + 1

	nSizeArray := len(aFields)

	for nX := 1 to nSizeArray
		self:jFields[aFields[nX]["field"]] := {"label": aFields[nX]["label"],;
											   "order": nOrder++,;
											   "required": aFields[nX]["required"]}
	next nX

return .T.

/*/{Protheus.doc} hasValidContractParams
Verifica se os parâmetros do contrato/subcontrato são válidos.
@type method
@version 12.1.2510
@author vinicius.queiros
@since 18/03/2025
@return logical, indica se os parâmetros do contrato/subcontrato são válidos.
*/
method hasValidContractParams() as logical class BeneficiaryService

	local lHasValid := .T. as logical
	local aRequiredFields := {"healthInsurerCode", "companyCode", "contractCode", "contractVersion", "subcontractCode", "subcontractVersion"} as array
	local nCount as numeric
	local nSizeArray as numeric

	nSizeArray := len(aRequiredFields)

	for nCount := 1 to nSizeArray
		if !self:jParams:hasProperty(aRequiredFields[nCount])
			lHasValid := .F.
			exit
		endif
	next nCount

return lHasValid

/*/{Protheus.doc} getSX5Options
Obtém as opções de uma tabela SX5, com base nos parâmetros de configuração para rótulo e transformação.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param cTable, character, nome da tabela SX5
@param lNoLabel, logical, se .T., o rótulo será o valor sem alteração. O padrão é .F.
@param lUpperLabel, logical, se .T., o rótulo será transformado para maiúsculas. O padrão é .F.
@return array, retorna um array com os valores e rótulos da tabela SX5
*/
static function getSX5Options(cTable as character, lNoLabel as logical, lUpperLabel as logical) as array

	local aOptions := {} as array
	local aSX5Data as array
	local nX as numeric
	local nSizeArray as numeric
	local cLabel as character
	local cValue as character

	default lNoLabel := .F.
	default lUpperLabel := .F.

	aSX5Data := FWGetSX5(cTable)
	nSizeArray := len(aSX5Data)

	for nX := 1 to nSizeArray
		cValue := alltrim(aSX5Data[nX][3])
		cLabel := iif(lNoLabel, cValue, aSX5Data[nX][4])
		cLabel := iif(lUpperLabel, upper(cLabel), capital(cLabel))

		aAdd(aOptions, {"value": cValue, "label": cLabel})
	Next nX

	fwFreeArray(aSX5Data)

return aOptions

/*/{Protheus.doc} getFieldContainer
Retorna a descrição do container de agrupamento de um campo específico.
@type function
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param cField, character, Nome do campo a ser verificado.
@return character, Retorna a descrição do container correspondente ao campo informado.
*/
static function getFieldContainer(cField as character) as character

	local cDescription as character

	do case
		case cField == "B2N_CPFUSR" .or. cField == "BA1_CPFUSR"
			cDescription := STR0038 // "Informações Pessoais"

		case cField == "B2N_CEPUSR" .or. cField == "BA1_CEPUSR"
			cDescription := STR0020 // "Endereço"

		case cField == "B2N_DDD" .or. cField == "BA1_DDD"
			cDescription := STR0039 // "Informações para Contato"

		case cField == "B2N_CODPRO"
			cDescription := STR0041 // "Dados do Plano"
	endcase

return cDescription

/*/{Protheus.doc} getQueryOptions
Executa uma consulta SQL dinâmica baseada nos parâmetros informados e retorna uma lista de opções formatadas.
@type function
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param jQueryData, json, Estrutura contendo os parâmetros da consulta, incluindo tabela, colunas e filtros.
@return array, Retorna uma matriz contendo as opções resultantes da consulta, no formato [{"value": valor, "label": descrição}].
*/
static function getQueryOptions(jQueryData as json) as array

	local aOptions := {} as array
	local oExecStmt as object
	local nOrder := 1 as numeric
	local cQuery as character
	local nX as numeric
	local nSizeArray as numeric
	local cAlias as character

	cQuery := " SELECT ? "
	cQuery += " FROM ? "
	cQuery += " WHERE "

	nSizeArray := len(jQueryData["filter"])

	for nX := 1 to nSizeArray
		cQuery += jQueryData["filter"][nX]["field"] + " " +  jQueryData["filter"][nX]["operator"] + " ? AND "
	next nX

	cQuery += "D_E_L_E_T_ = ? "

	oExecStmt := FwExecStatement():new(cQuery)

	oExecStmt:setUnsafe(nOrder++, jQueryData["valueColumn"] + " VALUE," + jQueryData["labelColumn"] + " LABEL")
	oExecStmt:setUnsafe(nOrder++, retSqlName(jQueryData["table"]))

	for nX := 1 to nSizeArray
		oExecStmt:setString(nOrder++, jQueryData["filter"][nX]["value"])
	next nX

	oExecStmt:setString(nOrder++, " ")

	cAlias := oExecStmt:openAlias()

	if !(cAlias)->(eof())
		while !(cAlias)->(eof())
			aAdd(aOptions, {"value" : alltrim((cAlias)->VALUE), "label" : capital(alltrim((cAlias)->LABEL))})

			(cAlias)->(dbSkip())
		enddo
	endif

	(cAlias)->(dbCloseArea())

	freeObj(oExecStmt)

return aOptions

/*/{Protheus.doc} getProductData
Obtém os dados dos produtos associados ao beneficiários e empresa com base nos parâmetros informados.
@type function
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param jData, json, Estrutura contendo os parâmetros necessários para consulta dos produtos, incluindo operadora, empresa e contrato.
@return json, Retorna um objeto JSON contendo uma lista de produtos no formato [{"value": código, "label": descrição}].
*/
static function getProductData(jData as json, lHasContract as logical) as json

	local jProductData := JsonObject():new() as json
	local oExecStmt as object
	local nOrder := 1 as numeric
	local cQuery as character
	local cAlias as character
	local cCode as character

	default lHasContract := .F.

	BG9->(dbSetOrder(1))
	if BG9->(msSeek(xFilial("BG9") + jData["healthInsurerCode"] + jData["companyCode"]))
		if BG9->BG9_TIPO == "2" // 2 = Pessoa Juridica
			cQuery := "SELECT ? "
			cQuery += " FROM ? BT6 "

			cQuery += " INNER JOIN ? BI3 ON "
			cQuery += "	    BI3.BI3_FILIAL = ? AND "
			cQuery += "	    BI3.BI3_CODIGO = BT6.BT6_CODPRO AND "
			cQuery += "	    BI3.BI3_VERSAO = BT6.BT6_VERSAO AND "
			cQuery += "	    BI3.D_E_L_E_T_ = ? "

			cQuery += " INNER JOIN ? BE5 ON "
			cQuery += "		BE5.BE5_FILIAL = ? AND "
			cQuery += "     BE5.BE5_CODGRU = BI3.BI3_GRUPO AND "
			cQuery += "		BE5.BE5_TIPO = ? AND "
			cQuery += "		BE5.D_E_L_E_T_ = ? "

			cQuery += " WHERE BT6.BT6_FILIAL = ? AND "
			cQuery += " 	  BT6.BT6_CODINT = ? AND "
			cQuery += " 	  BT6.BT6_CODIGO = ? AND "
			cQuery += " 	  BT6.BT6_NUMCON = ? AND "
			cQuery += " 	  BT6.BT6_VERCON = ? AND "
			cQuery += " 	  BT6.BT6_SUBCON = ? AND "
			cQuery += " 	  BT6.BT6_VERSUB = ? AND "
			cQuery += " 	  BT6.D_E_L_E_T_ = ? "

			oExecStmt := FWExecStatement():new(cQuery)

			oExecStmt:setUnsafe(nOrder++, "BI3.BI3_CODIGO VALUE, BI3.BI3_DESCRI LABEL, BI3.BI3_VERSAO VERSION")
			oExecStmt:setUnsafe(nOrder++, retSqlName("BT6"))
			oExecStmt:setUnsafe(nOrder++, retSqlName("BI3"))
			oExecStmt:setString(nOrder++, xFilial("BI3"))
			oExecStmt:setString(nOrder++, " ")
			oExecStmt:setUnsafe(nOrder++, retSqlName("BE5"))
			oExecStmt:setString(nOrder++, xFilial("BI3"))
			oExecStmt:setString(nOrder++, "1") // Planos
			oExecStmt:setString(nOrder++, " ")
			oExecStmt:setString(nOrder++, xFilial("BT6"))
			oExecStmt:setString(nOrder++, jData["healthInsurerCode"])
			oExecStmt:setString(nOrder++, jData["companyCode"])
			oExecStmt:setString(nOrder++, jData["contractCode"])
			oExecStmt:setString(nOrder++, jData["contractVersion"])
			oExecStmt:setString(nOrder++, jData["subcontractCode"])
			oExecStmt:setString(nOrder++, jData["subcontractVersion"])
			oExecStmt:setString(nOrder++, " ")
		else // Pessoa fisica
			cQuery := "SELECT ? "
			cQuery += " FROM ? BA3 "

			cQuery += " INNER JOIN ? BI3 ON "
			cQuery += "	    BI3.BI3_FILIAL = ? AND "
			cQuery += "	    BI3.BI3_CODIGO = BA3.BA3_CODPLA AND "
			cQuery += "	    BI3.BI3_VERSAO = BA3.BA3_VERSAO AND "
			cQuery += "	    BI3.D_E_L_E_T_ = ? "

			cQuery += " WHERE BA3.BA3_FILIAL = ? AND "
			cQuery += " 	  BA3.BA3_CODINT = ? AND "
			cQuery += " 	  BA3.BA3_CODEMP = ? AND "
			cQuery += " 	  BA3.BA3_MATRIC = ? AND "
			cQuery += " 	  BA3.D_E_L_E_T_ = ? "

			oExecStmt := FWExecStatement():new(cQuery)

			oExecStmt:setUnsafe(nOrder++, "BI3.BI3_CODIGO VALUE, BI3.BI3_DESCRI LABEL")
			oExecStmt:setUnsafe(nOrder++, retSqlName("BA3"))
			oExecStmt:setUnsafe(nOrder++, retSqlName("BI3"))
			oExecStmt:setString(nOrder++, xFilial("BI3"))
			oExecStmt:setString(nOrder++, " ")
			oExecStmt:setString(nOrder++, xFilial("BA3"))
			oExecStmt:setString(nOrder++, jData["healthInsurerCode"])
			oExecStmt:setString(nOrder++, jData["companyCode"])
			oExecStmt:setString(nOrder++, jData["familyCode"])
			oExecStmt:setString(nOrder++, " ")
		endif

		cAlias := oExecStmt:openAlias()

		if !(cAlias)->(eof())
			jProductData["products"] := {}

			while !(cAlias)->(eof())
				cCode := iif(lHasContract .and. BG9->BG9_TIPO == "2", (cAlias)->VALUE + "-" +  (cAlias)->VERSION, alltrim((cAlias)->VALUE))
				aAdd(jProductData["products"], {"value" : cCode, "label" : capital(alltrim((cAlias)->LABEL))})

				(cAlias)->(dbSkip())
			enddo
		endif

		(cAlias)->(dbCloseArea())
	endif

	freeObj(oExecStmt)

return jProductData

/*/{Protheus.doc} getProfessions
Obtém a lista de profissões cadastradas no sistema.
@type function
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@return array, Retorna um array contendo a lista de profissões no formato [{"value": código, "label": descrição}].
*/
static function getProfessions() as array

	local cQuery as character
	local aProfessions := {} as array
	local oExecStmt as object
	local nOrder := 1 as numeric
	local cAlias as character

	cQuery := "SELECT ? "
	cQuery += " FROM ? BCX "
	cQuery += " WHERE BCX.BCX_FILIAL = ? AND "
	cQuery += " 	  BCX.D_E_L_E_T_ = ? "

	oExecStmt := FWExecStatement():new(cQuery)

	oExecStmt:setUnsafe(nOrder++, "BCX.BCX_CODIGO, BCX.BCX_DESCRI")
	oExecStmt:setUnsafe(nOrder++, retSqlName("BCX"))
	oExecStmt:setString(nOrder++, xFilial("BCX"))
	oExecStmt:setString(nOrder++, " ")
		
	cAlias := oExecStmt:openAlias()

	if !(cAlias)->(eof())
		while !(cAlias)->(eof())
			aAdd(aProfessions, {"value" : alltrim((cAlias)->BCX_CODIGO), "label" : capital(alltrim((cAlias)->BCX_DESCRI))})

			(cAlias)->(dbSkip())
		enddo
	endif

	(cAlias)->(dbCloseArea())

	freeObj(oExecStmt)

return aProfessions
