#include "tlpp-core.th"

namespace totvs.protheus.health.plans.api.attendance.refund

using namespace totvs.protheus.health.plans.api.util

/*/{Protheus.doc} RefundService
Classe de serviço de Protocolo de Reembolso - Regra de Negócio

@type class
@author vinicius.queiros
@since 11/04/2023
@version Protheus 12
/*/
class RefundService
    
    protected data oAdapter as Object
    protected data aRefundReceipts as array
    protected data aAttachments as array
    protected data jBankData as json
    protected data jContact as json
    protected data cProtocolNumber as character
    protected data cSubscriberId as character
    protected data oBaseService as object

    public method new() constructor
    public method postRefunds() as logical
    public method getRefunds() as logical
    public method deleteRefunds() as logical
    public method postSendProtocol() as logical
    public method getProtocolBase64() as logical
    public method getRefundId() as logical

    public method getStatusCode() as numeric
    public method getJsonResult() as json
    public method setBodyString(cBody as character, cErro as character) as logical
    public method setQueryParams(jQueryParams as json) as logical
    public method setPathParams(jPathParams as json) as logical

    protected method setRefundStruct() as logical
    protected method validRefund(cErro as character, aDetailsErro as array) as logical
    protected method validReceipts(cErro as character, aDetailsErro as array, jBodyChecking as json) as logical
    protected method validExpenses(cErro as character, aDetailsErro as array, oStructRefund as Object, aRefundReceipt as array) as logical
    protected method existsExpensePrescription(oStructRefund as Object) as logical
    protected method existsExpenseCode(oStructRefund as Object) as logical
    protected method addRefund() as logical
    protected method confirmRefund(cRecnos as character) as logical
    protected method setProtocolJsonResponse() as logical
    protected method getToleranceDate() as date
    protected method getRefundExpenses(cProtocol as character, cNoSeqExpense as character) as array
    protected method setProtocolStruct() as logical
    protected method getStatusApi(cStatus as character) as character

endclass

/*/{Protheus.doc} new
Método construtor da classe

@type method
@author vinicius.queiros
@since 11/04/2023
@version Protheus 12
/*/
method new() class RefundService

    self:aRefundReceipts := {}
    self:aAttachments := {}
    self:jBankData := nil
    self:jContact := nil
    self:cProtocolNumber := ""
    self:cSubscriberId := ""
    self:oBaseService := BaseService():new()

return self

/*/{Protheus.doc} postRefunds
Método responsavel por cadastrar os Protocolos de Reembolso

@type method
@author vinicius.queiros
@since 11/04/2023
@version Protheus 12
/*/
method postRefunds() as logical class RefundService

    local lSucess := .f. as logical
    local aFields := {} as array

    // Verifica se os campos do body estão validos
    aAdd(aFields, {"field" : "status", "required" : .f., "type" : "C", "options" : {"0", "1"}, "size" : tamSX3("BOW_STATUS")[1], "default" : "1"}) // 1 = Protocolado ; 2 = Solicitação não concluida
    aAdd(aFields, {"field" : "healthInsurerCode", "required" : .t., "type" : "C", "size" : tamSX3("BA0_CODIDE")[1]+tamSX3("BA0_CODINT")[1]})
    aAdd(aFields, {"field" : "subscriberId", "required" : .t., "type" : "C", "size" : tamSX3("BA1_CODINT")[1]+tamSX3("BA1_CODEMP")[1]+tamSX3("BA1_MATRIC")[1]+tamSX3("BA1_TIPREG")[1]+tamSX3("BA1_DIGITO")[1]})
    aAdd(aFields, {"field" : "refundReceipts", "required" : .t., "type" : "A"})
    aAdd(aFields, {"field" : "bankData", "required" : .f., "type" : "J"})
    aAdd(aFields, {"field" : "contact", "required" : .f., "type" : "J"})
    
    if self:oBaseService:checkBodyFields(aFields, "E002")
        if self:setRefundStruct()
            if self:addRefund()
                lSucess := .t.
                self:oBaseService:nCodeStatus := 201 // Create 
            endif
        endif
    endif      

return lSucess

/*/{Protheus.doc} getRefunds
Valida os dados recebidos pela api e processa a classe adapter para retornar
os protocolos de reembolso do beneficiário

@type method
@version Protheus 12.1.2310  
@author vinicius.queiros
@since 26/04/2023
@return logical, se houve sucesso ao retornar os protocolos de reembolso
/*/
method getRefunds() as logical class RefundService

    local lSucess := .f. as logical
    local aFields := {} as array
    local lRequiredRequestDate := .t. as logical
    local lSeekPreviousMonths := .f. as logical

    if self:oBaseService:jParams:hasProperty("protocol")
        lRequiredRequestDate := .f.
    endif

    if self:oBaseService:jParams:hasProperty("previousMonths")
        lSeekPreviousMonths := .t.
    endif

    aAdd(aFields, {"field" : "requestDateInitial", "required" : lRequiredRequestDate .and. !lSeekPreviousMonths, "type" : "D"})
    aAdd(aFields, {"field" : "requestDateFinal", "required" : lRequiredRequestDate .and. !lSeekPreviousMonths, "type" : "D"})
    aAdd(aFields, {"field" : "protocol", "required" : .f., "type" : "C", "size" : tamSX3("BOW_PROTOC")[1]})
    aAdd(aFields, {"field" : "subscriberId", "required" : .t., "type" : "C", "size" : tamSX3("BA1_CODINT")[1]+tamSX3("BA1_CODEMP")[1]+tamSX3("BA1_MATRIC")[1]+tamSX3("BA1_TIPREG")[1]+tamSX3("BA1_DIGITO")[1]})

    if self:oBaseService:checkBodyFields(aFields, "E001", self:oBaseService:jParams, nil, nil, "as chaves do query param estão inválidos")
        if lSeekPreviousMonths
            self:oBaseService:setAttributeJson({"attribute" : "requestDateInitial", "value" : monthSub(dDatabase, val(self:oBaseService:jParams["previousMonths"])), "type" : "D", "setResponse" : .t.}, self:oBaseService:jParams)
            self:oBaseService:setAttributeJson({"attribute" : "requestDateFinal", "value" : dDataBase, "type" : "D", "setResponse" : .t.}, self:oBaseService:jParams)
        endif

        BA1->(DBSetOrder(2)) // BA1_FILIAL + BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO
        if BA1->(MsSeek(xFilial("BA1")+self:oBaseService:jParams["subscriberId"]))
        
            self:oAdapter := RefundAdapter():New()
            self:oAdapter:setQueryParams(self:oBaseService:jParams)
            self:oAdapter:setLinks({"rel" : "expenses",;
                                    "url" : "/totvsHealthPlans/attendance/v1/refunds",;
                                    "paths" : {{"path" : {"protocol"}, "resource" : "expenses"}};
                                    }) // hiperlink para a api de despesas do protocolo de reembolso
            self:oAdapter:setLinks({"rel" : "attachments",;
                                    "url" : "/totvsHealthPlans/attendance/v1/refunds",;
                                    "paths" : {{"path" : {"protocol"}, "resource" : "attachments"}};
                                    }) // hiperlink para a api de anexos do protocolo de reembolso  

            if self:oAdapter:getPageRefunds()
                lSucess := .t.
                self:oBaseService:nCodeStatus := 200 // Ok
                self:oBaseService:jResult := self:oAdapter:getJsonResult()
            endif
        else
            self:oBaseService:setError("E002", "Beneficiário não encontrado",;
                                       "Não foi encontrado nenhum beneficiário com a matricula "+self:oBaseService:jParams["subscriberId"]+" no cadastro (BA1)",;
                                       404) // Not found
        endif
    endif
   
return lSucess

/*/{Protheus.doc} deleteRefunds
Deleta o protocolo de reembolso enviado pelo path param da requisição

@type method
@version Protheus 12.1.2310  
@author vinicius.queiros
@since 28/04/2023
@return logical, se houve sucesso ao deletar o protocolo
/*/
method deleteRefunds() as logical class RefundService

    local lSucess := .f. as logical
    local aFields := {} as array
    
    aAdd(aFields, {"field" : "protocol", "required" : .t., "type" : "C", "size" : tamSX3("BOW_PROTOC")[1]})

    if self:oBaseService:checkBodyFields(aFields, "E001", self:oBaseService:jPath, nil, nil, "A chave do path param esta inválida")
        BOW->(DBSetOrder(1)) // BOW_FILIAL + BOW_PROTOC
        if BOW->(MsSeek(xFilial("BOW")+self:oBaseService:jPath["protocol"]))
            if BOW->BOW_STATUS == "A" // Solicitação não concluida
                begin transaction
					P001AEXCG(BOW->BOW_PROTOC)
				end transaction

                lSucess := .t.
                self:oBaseService:nCodeStatus := 204 // No content
            else
                self:oBaseService:setError("E003", "Não foi possível excluir esta solicitação pois já esta protocolada, entre em contato com a operadora",;
                                           "Permitido somente excluir protocolos com o status (BOW_STATUS) igual a A (Solicitação não concluida)",;
                                           400) // Bad Request
            endif
        else
            self:oBaseService:setError("E002", "Protocolo de reembolso não encontrado",;
                                       "Não foi encontrado o protocolo de reembolso "+self:oBaseService:jPath["protocol"]+" na base de dados (BOW)",;
                                       404) // Not found
        endif
    endif
   
return lSucess

/*/{Protheus.doc} postSendProtocol
Método responsavel finalizar o protocolo de reembolso com o status 
em aberto (Solicitação não concluida) 

@type method
@version Protheus 12.1.2310
@author vinicius.queiros
@since 02/06/2023
@return logical, se houve sucesso ao processar a api
/*/
method postSendProtocol() as logical class RefundService

    local lSucess := .f. as logical
    local aFields := {} as array

    // Verifica se os campos do body estão validos
    aAdd(aFields, {"field" : "protocol", "required" : .t., "type" : "C", "size" : tamSX3("BOW_PROTOC")[1]}) 

    if self:oBaseService:checkBodyFields(aFields, "E002")
        BOW->(dBSetOrder(1)) // BOW_FILIAL + BOW_PROTOC
        if BOW->(MsSeek(xFilial("BOW")+self:oBaseService:jBody["protocol"]))
            if BOW->BOW_STATUS == "A" // Solicitação não concluida
                self:cSubscriberId := alltrim(BOW->BOW_USUARI)
                self:cProtocolNumber := alltrim(BOW->BOW_PROTOC)
                self:oBaseService:jBody["healthInsurerCode"] := alltrim(BOW->BOW_OPEMOV)

                if self:setProtocolStruct()        
                    if self:confirmRefund("0", .t.)
                        if self:setProtocolJsonResponse()
                            lSucess := .t.
                            self:oBaseService:nCodeStatus := 201 // Create 
                        endif
                    endif              
                endif
            else
                self:oBaseService:setError("E004", "Permite finalizar protocolo de reembolso somente com o status de solicitação não concluida",;
                                           "Permitido somente finalizar protocolos com o status (BOW_STATUS) igual a 0 (Solicitação não concluida)",;
                                           400) // Bad Request
            endif
        else
            self:oBaseService:setError("E003", "Protocolo de reembolso não encontrado",;
                                       "Não foi encontrado o protocolo de reembolso "+self:oBaseService:jBody["protocol"]+" na base de dados (BOW)",;
                                       404) // Not found
        endif
    endif      

return lSucess

/*/{Protheus.doc} getProtocolBase64
Retorna o protocolo de reembolso em arquivo base 64

@type method
@version Protheus 12.1.2310
@author vinicius.queiros
@since 07/06/2023
@return logical, se houve sucesso ao gerar o pdf do protocolo
/*/
method getProtocolBase64() as logical class RefundService

    local lSucess := .f. as Logical
    local aKeys := {} as Array
    local cFileName as Character
    local cDiretory := getNewPar("MV_RELT")

    if existDir(cDiretory)
        // Chaves do query param obrigatórios na api
        aAdd(aKeys, {"type" : "pathParams", "key" : "protocol"})

        if self:oBaseService:checkRequiredKeys(aKeys, "E001")
            BOW->(dbSetOrder(1))
            if BOW->(msSeek(xFilial("BOW")+self:oBaseService:jPath["protocol"]))
                cFileName := PLSRPROT(BOW->BOW_PROTOC, cDiretory, .t.)[1]

                if !empty(cFileName) .and. file(cDiretory+cFileName)
                    self:oBaseService:setAttributeJson({"attribute" : "fileName", "value" : lower(cFileName), "type" : "C"})
                    self:oBaseService:setAttributeJson({"attribute" : "file", "value" : self:oBaseService:convertFileToBase64(cDiretory+cFileName), "type" : "C"})                  
                    
                    lSucess := .t.
                    self:oBaseService:nCodeStatus := 200 // Ok
                endif
            else
                self:oBaseService:setError("E002", "Protocolo não encontrado",;
                                                "Não foi encontrada na tabela BOW o protocol "+self:oBaseService:jPath["protocol"]+" (BOW_PROTOC).",;
                                                404) // Not found
            endif     
        endif
    else
        self:oBaseService:setError("E003", "Diretório para impressão do relatório não encontrado.",;
                                           "Verifique se existe o diretório informado no parâmetro MV_RELT no servidor.",;
                                           400) // Bad Request
    endif

return lSucess

/*/{Protheus.doc} setRefundStruct
Método responsavel por definir/validar a estrutura do reembolso para gravação

@type method
@author vinicius.queiros
@since 11/04/2023
@version Protheus 12
/*/
method setRefundStruct() as logical class RefundService

    local lOk := .f. as logical
    local nX := 0 as numeric
    local nY := 0 as numeric
    local aFieldsExpenses := {} as array
    local aFieldsReceipts := {} as array
    local aFieldsAttachments := {} as array
    local aFieldsBankData := {} as array
    local aFieldsContact := {} as array
    local oStructRefund as object
    local aDetailsErro := {} as array
    local jAttachment as Json
    local lIsHref as logical
    
    // Validações do reembolso
    if self:validRefund("E004", @aDetailsErro)
        // Campos do recibo de reembolso
        aAdd(aFieldsReceipts, {"field" : "unreferencedNetworkIdentifier", "required" : .t., "type" : "C"})
        aAdd(aFieldsReceipts, {"field" : "unreferencedNetworkName", "required" : .t., "type" : "C"})
        aAdd(aFieldsReceipts, {"field" : "stateAbbreviation", "required" : .t., "type" : "C", "size" : tamSX3("BID_EST")[1]})
        aAdd(aFieldsReceipts, {"field" : "cityCode", "required" : .t., "type" : "C", "size" : tamSX3("BID_CODMUN")[1]})
        aAdd(aFieldsReceipts, {"field" : "documentCode", "required" : .t., "type" : "C", "size" : tamSX3("BBS_COD")[1]})
        aAdd(aFieldsReceipts, {"field" : "documentNumber", "required" : .f., "type" : "C"})
        aAdd(aFieldsReceipts, {"field" : "documentDate", "required" : .t., "type" : "D"})
        aAdd(aFieldsReceipts, {"field" : "expenses", "required" : .t., "type" : "A"})
        // Campos das despesas do recebido de reembolso
        aAdd(aFieldsExpenses, {"field" : "subscriberId", "required" : .t., "type" : "C", "size" : tamSX3("BA1_CODINT")[1]+tamSX3("BA1_CODEMP")[1]+tamSX3("BA1_MATRIC")[1]+tamSX3("BA1_TIPREG")[1]+tamSX3("BA1_DIGITO")[1]})
        aAdd(aFieldsExpenses, {"field" : "procedureClass", "required" : .t., "type" : "C"})
        aAdd(aFieldsExpenses, {"field" : "tableCode", "required" : .t., "type" : "C"})
        aAdd(aFieldsExpenses, {"field" : "procedureCode", "required" : .t., "type" : "C"})
        aAdd(aFieldsExpenses, {"field" : "continuousUse", "required" : .t., "type" : "C", "options" : {"0", "1"}}) // 0 = Não ; 1 = Sim
        aAdd(aFieldsExpenses, {"field" : "expenseAmount", "required" : .t., "type" : "N"})
        aAdd(aFieldsExpenses, {"field" : "quantity", "required" : .t., "type" : "N"})
        aAdd(aFieldsExpenses, {"field" : "executionDate", "required" : .t., "type" : "D"})

        self:aRefundReceipts := array(Len(self:oBaseService:jBody["refundReceipts"]))

        for nY := 1 to Len(self:oBaseService:jBody["refundReceipts"])
            self:aRefundReceipts[nY] := {}

            if self:oBaseService:checkBodyFields(aFieldsReceipts, "E005", self:oBaseService:jBody["refundReceipts"][nY], @aDetailsErro, .f.)
                if self:validReceipts("E006", @aDetailsErro, self:oBaseService:jBody["refundReceipts"][nY])

                    for nX := 1 to Len(self:oBaseService:jBody["refundReceipts"][nY]["expenses"])
                        // Verifica se os campos do expenses do json estão validos 
                        if self:oBaseService:checkBodyFields(aFieldsExpenses, "E007", self:oBaseService:jBody["refundReceipts"][nY]["expenses"][nX], @aDetailsErro, .f.)

                            oStructRefund := RefundStruct():new()

                            // Informações do comprovante
                            oStructRefund:TipDoc := self:oBaseService:jBody["refundReceipts"][nY]["documentType"]
                            oStructRefund:CPFCNPJ := self:oBaseService:jBody["refundReceipts"][nY]["unreferencedNetworkIdentifier"]
                            oStructRefund:NomRDA := self:oBaseService:jBody["refundReceipts"][nY]["unreferencedNetworkName"]
                            oStructRefund:UF := self:oBaseService:jBody["refundReceipts"][nY]["stateAbbreviation"]
                            oStructRefund:Cidade := self:oBaseService:jBody["refundReceipts"][nY]["cityCode"]
                            oStructRefund:NroDoc := self:oBaseService:jBody["refundReceipts"][nY]["documentNumber"]
                            oStructRefund:DatDoc := self:oBaseService:convertDateFormat(self:oBaseService:jBody["refundReceipts"][nY]["documentDate"])
                
                            // Dados da despesa
                            oStructRefund:Matric := self:oBaseService:jBody["refundReceipts"][nY]["expenses"][nX]["subscriberId"]
                            oStructRefund:CodPad := self:oBaseService:jBody["refundReceipts"][nY]["expenses"][nX]["tableCode"]
                            oStructRefund:CodPro := self:oBaseService:jBody["refundReceipts"][nY]["expenses"][nX]["procedureCode"]
                            oStructRefund:TipSer := self:oBaseService:jBody["refundReceipts"][nY]["expenses"][nX]["procedureClass"]

                            oStructRefund:UsoC := self:oBaseService:jBody["refundReceipts"][nY]["expenses"][nX]["continuousUse"]
                            if oStructRefund:UsoC == "1" // Medicamento de uso continuo
                                if self:oBaseService:checkBodyFields({{"field" : "prescriptionCode", "required" : .t., "type" : "C"}}, "E008", self:oBaseService:jBody["refundReceipts"][nY]["expenses"][nX], @aDetailsErro, .f.)
                                    oStructRefund:CodRec := self:oBaseService:jBody["refundReceipts"][nY]["expenses"][nX]["prescriptionCode"]
                                    oStructRefund:CodMed := self:oBaseService:jBody["refundReceipts"][nY]["expenses"][nX]["procedureCode"]
                                endif
                            endif

                            oStructRefund:VlrPro := cValToChar(self:oBaseService:jBody["refundReceipts"][nY]["expenses"][nX]["expenseAmount"] * 100) // Converte em caracter sem casas decimais - Função PLSREEMBIT espera dessa forma
                            oStructRefund:QtdPro := cValToChar(self:oBaseService:jBody["refundReceipts"][nY]["expenses"][nX]["quantity"]) // Converte em caracter - Função PLSREEMBIT espera dessa forma
                            oStructRefund:DatComprov := self:oBaseService:convertDateFormat(self:oBaseService:jBody["refundReceipts"][nY]["expenses"][nX]["executionDate"])
                            oStructRefund:cDocObr := self:oBaseService:jBody["refundReceipts"][nY]["requiredDocument"]

                            // Validações da despesa
                            if self:validExpenses("E009", @aDetailsErro, oStructRefund, self:aRefundReceipts[nY]) .And. Len(aDetailsErro) == 0
                                aAdd(self:aRefundReceipts[nY], oStructRefund)
                            endif
                        endif
                    next nX

                    if Len(aDetailsErro) == 0
                        aFieldsAttachments := {}
                        aAdd(aFieldsAttachments, {"field" : "attachments", "required" : self:oBaseService:jBody["status"] == "1", "type" : "A"}) // Anexo obrigatório para o status protocolado

                        if self:oBaseService:checkBodyFields(aFieldsAttachments, "E010", self:oBaseService:jBody["refundReceipts"][nY], @aDetailsErro, .f.)
                            if self:oBaseService:jBody["refundReceipts"][nY]:hasProperty("attachments")
                                for nX := 1 to Len(self:oBaseService:jBody["refundReceipts"][nY]["attachments"])
                                    aFieldsAttachments := {}

                                    lIsHref := self:oBaseService:jBody["refundReceipts"][nY]["attachments"][nX]:hasProperty("href")
                                    aAdd(aFieldsAttachments, {"field" : "href", "required" : lIsHref, "type" : "C"})
                                    aAdd(aFieldsAttachments, {"field" : "fileName", "required" : !lIsHref, "type" : "C"})
                                    aAdd(aFieldsAttachments, {"field" : "base64", "required" : !lIsHref, "type" : "C"})

                                    if self:oBaseService:checkBodyFields(aFieldsAttachments, "E011", self:oBaseService:jBody["refundReceipts"][nY]["attachments"][nX], @aDetailsErro, .f.)

                                        if lIsHref
                                            jAttachment := self:oBaseService:fileDownload(self:oBaseService:jBody["refundReceipts"][nY]["attachments"][nX]["href"])
                                        else
                                            jAttachment := self:oBaseService:base64ToFile(self:oBaseService:jBody["refundReceipts"][nY]["attachments"][nX])
                                        endif

                                        if jAttachment["sucess"]
                                            aAdd(self:aAttachments, {"fileDirectory" : jAttachment["fileDirectory"]})
                                        else
                                            aAdd(aDetailsErro, {"code" : "E012-400",; // Bad Request
                                                                "message" : jAttachment["message"],;
                                                                "detailedMessage" : jAttachment["detailedMessage"]})
                                        endif
                                    endif
                                next nX
                            endif
                        endif
                    endif

                endif
            endif
        next nY

        if self:oBaseService:jBody:hasProperty("bankData")
            aAdd(aFieldsBankData, {"field" : "bankCode", "required" : .t., "type" : "C", "maxSize": tamSx3("BOW_NROBCO")[1]})
            aAdd(aFieldsBankData, {"field" : "branch", "required" : .t., "type" : "C", "maxSize": tamSx3("BOW_NROAGE")[1]})
            aAdd(aFieldsBankData, {"field" : "branchVD", "required" : .t., "type" : "C", "maxSize": tamSx3("BOW_NRODAG")[1]})
            aAdd(aFieldsBankData, {"field" : "account", "required" : .t., "type" : "C", "maxSize": tamSx3("BOW_NROCTA")[1]})
            aAdd(aFieldsBankData, {"field" : "accountVD", "required" : .t., "type" : "C", "maxSize": tamSx3("BOW_NRODTO")[1]})

            if self:oBaseService:checkBodyFields(aFieldsBankData, "E014", self:oBaseService:jBody["bankData"], @aDetailsErro, .f.)
                SA6->(dbSetOrder(1))    
                if SA6->(msSeek(xFilial("SA6")+self:oBaseService:jBody["bankData"]["bankCode"]))
                    self:jBankData := { "bankCode" : self:oBaseService:jBody["bankData"]["bankCode"],;
                                        "branch" : self:oBaseService:jBody["bankData"]["branch"],;
                                        "branchVD" : self:oBaseService:jBody["bankData"]["branchVD"],;
                                        "account" : self:oBaseService:jBody["bankData"]["account"],;
                                        "accountVD" : self:oBaseService:jBody["bankData"]["accountVD"]}
                else
                    aAdd(aDetailsErro, {"code" : "E015-404",; // Not found
                                        "message" : "Banco não encontrado",;
                                        "detailedMessage" : "Não foi encontrado nenhum banco na tabela SA6 com o código "+self:oBaseService:jBody["bankData"]["bankCode"]})
                endif
            endif
        endif

        if self:oBaseService:jBody:hasProperty("contact")
            aAdd(aFieldsContact, {"field" : "telephone", "required" : .t., "type" : "C", "maxSize": tamSx3("BOW_TELCON")[1]})
            aAdd(aFieldsContact, {"field" : "email", "required" : .t., "type" : "C", "maxSize": tamSx3("BA1_EMAIL")[1]})

            if self:oBaseService:checkBodyFields(aFieldsContact, "E016", self:oBaseService:jBody["contact"], @aDetailsErro, .f.)
                self:jContact := {"telephone" : self:oBaseService:jBody["contact"]["telephone"], "email" : self:oBaseService:jBody["contact"]["email"]}
            endif
        endif

    endif

    if Len(aDetailsErro) == 0
        lOk := .t.
    else
        self:oBaseService:setError("E003", "Dados inválidos para realizar a solicitação de reembolso",;
                                   "Verifique os detalhes dos erros no campo details",;
                                    400,; // Bad Request
                                    aDetailsErro)
    endif

return lOk

/*/{Protheus.doc} validRefund
Método responsavel por validar os dados do reembolso

@type method
@author vinicius.queiros
@since 13/04/2023
@version Protheus 12
/*/
method validRefund(cErro as character, aDetailsErro as array) as logical class RefundService

    local lCheck := .t. as logical
    local cHolderType := GetNewPar("MV_PLCDTIT", .t.) as character
    local aPEValid as array

    BA0->(DbSetOrder(1)) // BA0_FILIAL + BA0_CODIDE + BA0_CODINT 
    if !BA0->(MsSeek(xFilial("BA0")+self:oBaseService:jBody["healthInsurerCode"]))
        lCheck := .f.
        aAdd(aDetailsErro, {"code" : cErro+"A-404",; // Not Found
                            "message" : "Operadora de saúde não encontrada",;
                            "detailedMessage" : "Não foi encontrada nenhuma operadora de saúde com o código "+self:oBaseService:jBody["healthInsurerCode"]+" no cadastro (BA0)"})
    endif

    BA1->(DBSetOrder(2)) // BA1_FILIAL + BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO
    if !BA1->(MsSeek(xFilial("BA1")+self:oBaseService:jBody["subscriberId"]))
        lCheck := .f.
        aAdd(aDetailsErro, {"code" : cErro+"B-404",; // Not Found
                            "message" : "Beneficiário solicitante não encontrado",;
                            "detailedMessage" : "Não foi encontrado nenhum beneficiário com a matricula "+self:oBaseService:jBody["subscriberId"]+" no cadastro (BA1)"})
    else
        do case
            case BA1->BA1_REEWEB <> "1"
                lCheck := .f.
                aAdd(aDetailsErro, {"code" : cErro+"D-400",; // Bad Request
                                    "message" : "Beneficiário sem permissão para solicitar reembolso, para maiores informações, consulte a Operadora",;
                                    "detailedMessage" : "Somente beneficiário com o campo BA1_REEWEB igual a 1 pode solicitar reembolso"})
            otherwise   
                self:oBaseService:jBody["toleranceDate"] := self:getToleranceDate(subStr(self:oBaseService:jBody["subscriberId"], 1, 14))
                self:oBaseService:jBody["isHolder"] := BA1->BA1_TIPUSU == cHolderType .Or. BA1->BA1_RESFAM == "1"
        endcase
    endif

    if existBlock("PTVLDRMB")
		aPEValid := execBlock("PTVLDRMB", .F., .F., {self:oBaseService:jBody})

        if valType(aPEValid) == "A" .and. len(aPEValid) >= 2 .and. !aPEValid[1]
            lCheck := .F.

            aAdd(aDetailsErro, {"code" : cErro+"K-400",; // Bad Request
                                "message": aPEValid[2],;
                                "detailedMessage": "Validação do reembolso via ponto de entrada PTVLDRMB: " + aPEValid[2]})
        endif    
	endif
    
    fwFreeArray(aPEValid)
    
return lCheck

/*/{Protheus.doc} validReceipts
Método responsavel por validar os dados de cada recibo de reembolso

@type method
@author vinicius.queiros
@since 13/04/2023
@version Protheus 12
/*/
method validReceipts(cErro as character, aDetailsErro as array, jBodyChecking as json) as logical class RefundService

    local lCheck := .t. as logical
    local cToleranceDate as character

    if self:oBaseService:convertDateFormat(jBodyChecking["documentDate"]) < self:oBaseService:jBody["toleranceDate"] 
        cToleranceDate := self:oBaseService:setAttributeJson({"attribute" : "toleranceDate", "value" : self:oBaseService:jBody["toleranceDate"], "type" : "D", "addJsonResult" : .f., "setResponse" : .t.})
        lCheck := .f.
        aAdd(aDetailsErro, {"code" : cErro+"A-400",; // Bad Request
                            "message" : "O documento "+jBodyChecking["documentNumber"]+" já atingiu a data limite para solicitação do reembolso",;
                            "detailedMessage" : "Foi informado no campo documentDate do json uma data inferior a data limite ("+cToleranceDate+")"})
    endif

    if self:oBaseService:convertDateFormat(jBodyChecking["documentDate"]) > dDataBase
        lCheck := .f.
        aAdd(aDetailsErro, {"code" : cErro+"B-400",; // Bad Request
                            "message" : "A data de emissão do comprovante "+jBodyChecking["documentNumber"]+" não pode ser maior que a data atual.",;
                            "detailedMessage" : "Foi informado no campo documentDate do json uma data maior que a data atual."})
    endif

    BBS->(DbSetOrder(1))
	if BBS->(MsSeek(xFilial("BBS")+jBodyChecking["documentCode"]))
        jBodyChecking["requiredDocument"] := IIf(BBS->BBS_OBRIGA == "1", "true", "false")
        jBodyChecking["documentType"] := Alltrim(BBS->BBS_DESCRI)
	else
        lCheck := .f.
        aAdd(aDetailsErro, {"code" : cErro+"C-404",; // Not Found
                            "message" : "Código do documento não encontrado",;
                            "detailedMessage" : "Não foi encontrado nenhum documento com o código "+jBodyChecking["documentCode"]+" no cadastro (BBS)"})
    endif

    BID->(DbSetOrder(4)) // BID_FILIAL + BID_EST + BID_CODMUN
	if !BID->(MsSeek(xFilial("BID")+jBodyChecking["stateAbbreviation"]+jBodyChecking["cityCode"]))
        lCheck := .f.
        aAdd(aDetailsErro, {"code" : cErro+"D-404",; // Not Found
                            "message" : "Estado e Cidade não encontrado",;
                            "detailedMessage" : "Não foi encontrado nenhum estado "+jBodyChecking["stateAbbreviation"]+" e cidade "+jBodyChecking["cityCode"]+" no cadastro (BID)"})
    endif

    if !CGC(jBodyChecking["unreferencedNetworkIdentifier"])
        lCheck := .f.
        aAdd(aDetailsErro, {"code" : cErro+"E-400",; // Bad Request
                            "message" : "CPF/CNPJ da rede não referenciada Inválido",;
                            "detailedMessage" : "O CPF/CNPJ informado no campo unreferencedNetworkIdentifier está invalido."})
    endif

return lCheck

/*/{Protheus.doc} validExpenses
Método responsavel por validar os dados da despesa

@type method
@author vinicius.queiros
@since 13/04/2023
@version Protheus 12
/*/
method validExpenses(cErro as character, aDetailsErro as array, oStructRefund as Object, aRefundReceipt as array) as logical class RefundService

    local aCheck := {} as array
    local lValid := .t. as logical
    local lPLVLDITREE := Existblock("PLVLDITREE") as logical
    local cDocumentDate as character
    local cToleranceDate as character

    Default aRefundReceipt := {}

    BA1->(DBSetOrder(2)) // BA1_FILIAL + BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO
    if !BA1->(MsSeek(xFilial("BA1")+oStructRefund:Matric))
        lValid := .f.
        aAdd(aDetailsErro, {"code" : cErro+"A-404",; // Not Found
                                    "message" : "Beneficiário "+oStructRefund:Matric+" do documento "+oStructRefund:NroDoc+" não encontrado",;
                                    "detailedMessage" : "Não foi encontrado nenhum beneficiário com a matricula "+oStructRefund:Matric+" no cadastro (BA1)"})
    endif
    
    if Substr(oStructRefund:Matric, 1, 14) <> Substr(self:oBaseService:jBody["subscriberId"], 1, 14)
        lValid := .f.
        aAdd(aDetailsErro, {"code" : cErro+"B-400",; // Bad Request
                            "message" : "Beneficiário "+oStructRefund:Matric+" do documento "+oStructRefund:NroDoc+" não pertence a familia do solicitante",;
                            "detailedMessage" : "A matricula "+oStructRefund:Matric+" informada no subscriberId não pertence a familia do solicitante"})
    endif

    if !self:oBaseService:jBody["isHolder"]
        if oStructRefund:Matric <> self:oBaseService:jBody["subscriberId"]
            lValid := .f.
            aAdd(aDetailsErro, {"code" : cErro+"L-400",; // Bad Request
                                "message" : "Beneficiário dependente não pode solicitar reembolso para outros beneficiários",;
                                "detailedMessage" : "A matricula "+oStructRefund:Matric+" informada no subscriberId está diferente a matricula do solicitante"})
        endif
    endif
 
    aCheck := PLCHKDUPRE(oStructRefund, oStructRefund:cDocObr)
    if !aCheck[1]
        lValid := .f.
        aAdd(aDetailsErro, {"code" : cErro+"C-409",; // Conflict
                            "message" : "A despesa "+oStructRefund:CodPro+" ("+Alltrim(aCheck[3])+") do documento "+oStructRefund:NroDoc+" já foi solicitada no protocolo "+Alltrim(aCheck[2]),;
                            "detailedMessage" : "Na tabela B1N já consta o protocolo "+Alltrim(aCheck[2])+" com os mesmo dados da despesa informada"})
    endif

    if !PLBLOQREEM(oStructRefund:Matric, oStructRefund:DatDoc)
        lValid := .f.
        cDocumentDate := self:oBaseService:setAttributeJson({"attribute" : "documentDate", "value" : oStructRefund:DatDoc, "type" : "D", "addJsonResult" : .f., "setResponse" : .t.})
        aAdd(aDetailsErro, {"code" : cErro+"D-400",; // Bad Request
                            "message" : "Beneficiário "+oStructRefund:Matric+" do documento "+oStructRefund:NroDoc+" está bloqueado",;
                            "detailedMessage" : "Beneficiário com a matricula "+oStructRefund:Matric+" informado no subscriberId está bloqueado na data "+cDocumentDate})
    endif
    
    if oStructRefund:UsoC == "1" // Medicamento de uso continuo
        if !self:existsExpensePrescription(oStructRefund)
            lValid := .f.
            aAdd(aDetailsErro, {"code" : cErro+"E-400",; // Bad Request
                                "message" : " O Medicamento "+oStructRefund:CodPro+" de uso continuo da receita "+oStructRefund:CodRec+" não foi autorizado ou não encontrado",;
                                "detailedMessage" : "Não foi encontrado para a receita "+oStructRefund:CodRec+" (B4F), nenhum saldo para autorização do medicamento "+oStructRefund:CodPro+" (B7D)"})
        endif
    else
        if !self:existsExpenseCode(oStructRefund)
            lValid := .f.
            aAdd(aDetailsErro, {"code" : cErro+"F-404",; // Not Found
                                "message" : "Código da despesa "+oStructRefund:CodPro+" informado no documento "+oStructRefund:NroDoc+" não encontrado",;
                                "detailedMessage" : "Não foi encontrado nenhum despesa com o código = "+oStructRefund:CodPro+", com a tabela = "+oStructRefund:CodPad+" e a classe = "+oStructRefund:TipSer+" no cadastro (BR8)"})
        endif
    endif

    if oStructRefund:DatComprov < self:oBaseService:jBody["toleranceDate"] 
        lValid := .f.
        cToleranceDate := self:oBaseService:setAttributeJson({"attribute" : "toleranceDate", "value" : self:oBaseService:jBody["toleranceDate"], "type" : "D", "addJsonResult" : .f., "setResponse" : .t.})
        aAdd(aDetailsErro, {"code" : cErro+"G-400",; // Bad Request
                            "message" : "O data de execução da despesa "+oStructRefund:CodPro+" do documento "+oStructRefund:NroDoc+" já atingiu a data limite para solicitação do reembolso",;
                            "detailedMessage" : "Foi informado no campo executionDate da despesa "+oStructRefund:CodPro+" uma data inferior a data limite ("+cToleranceDate+")"})
    endif

    if oStructRefund:DatComprov > oStructRefund:DatDoc
        lValid := .f.
        aAdd(aDetailsErro, {"code" : cErro+"H-400",; // Bad Request
                            "message" : "A data de execução da despesa "+oStructRefund:CodPro+" não pode ser maior que a data do documento "+oStructRefund:NroDoc,;
                            "detailedMessage" : "Foi informado no campo executionDate da despesa "+oStructRefund:CodPro+" uma data maior que a data do documentDate "+oStructRefund:NroDoc})
    endif

    // Verifica duplicidade de despesa no mesmo comprovante
    if Len(aRefundReceipt) > 0 .And. Ascan(aRefundReceipt, { |x| x:Matric == oStructRefund:Matric .And.;
                                                                 x:NroDoc == oStructRefund:NroDoc .And.;
                                                                 x:CodPad == oStructRefund:CodPad .And.;
                                                                 x:CodPro == oStructRefund:CodPro .And.;
                                                                 x:DatComprov == oStructRefund:DatComprov}) > 0
        lValid := .f.
        aAdd(aDetailsErro, {"code" : cErro+"J-400",; // Bad Request
                            "message" : "A despesa "+oStructRefund:CodPro+" foi adicionada mais de uma vez no documento "+oStructRefund:NroDoc,;
                            "detailedMessage" : "Foi informado no json a mesma despesa "+oStructRefund:CodPro+" (procedureCode) para o documento "+oStructRefund:NroDoc+" (documentNumber)"})  
    endif
    
    if lPLVLDITREE
        aCheck := ExecBlock("PLVLDITREE", .f., .f., {oStructRefund})

        if !aCheck[1]
            lValid := .f.
            aAdd(aDetailsErro, {"code" : cErro+"I-400",; // Bad Request
                                "message" : aCheck[2],;
                                "detailedMessage" : aCheck[2]})
        endif
    endif

return lValid

/*/{Protheus.doc} existsExpenseCode
Método responsavel por validar se despesa existe na base de dados

@type method
@author vinicius.queiros
@since 14/04/2023
@version Protheus 12
/*/
method existsExpenseCode(oStructRefund as Object) as logical class RefundService

    local lExists := .f. as logical
    local cAliasTemp as character
    local cTableCode := oStructRefund:CodPad
    local cProcedureCode := oStructRefund:CodPro
    local cClassCode := oStructRefund:TipSer

    cAliasTemp := getNextAlias()
    BeginSql Alias cAliasTemp	
        SELECT BR8.BR8_CODPSA FROM %table:BR8% BR8 
         WHERE BR8.BR8_FILIAL = %xFilial:BR8% 
           AND BR8.BR8_CODPAD = %Exp:cTableCode%
           AND BR8.BR8_CODPSA = %Exp:cProcedureCode%
           AND BR8.BR8_CLASSE = %Exp:cClassCode%
           AND BR8.%NotDel% 
    EndSql
    
    if !(cAliasTemp)->(Eof())
        lExists := .t.
    endif

    (cAliasTemp)->(DbCloseArea())

return lExists

/*/{Protheus.doc} existsExpensePrescription
Método responsavel por validar se existe receita para o medicamento de uso continuo

@type method
@author vinicius.queiros
@since 14/04/2023
@version Protheus 12
/*/
method existsExpensePrescription(oStructRefund as Object) as logical class RefundService

    local lExists := .f. as logical
    local cAliasTemp as character
    local cSubscriberId := oStructRefund:Matric as character
    local cPrescription := oStructRefund:CodRec as character
    local cMedicationCode := oStructRefund:CodMed as character
    local cMedicationTable := oStructRefund:codPad as character
    local cExpirationDate := GetNewPar("MV_PLVALRE", "0") as character // Valida o medicamento pela data da receita (0) ou pela data do medicamento (1) 
    local cFieldDateInitil := IIf(cExpirationDate == "0", "B4F_DATINI", "B7D_DTVINI")
    local cFieldDateFinal := IIf(cExpirationDate == "0", "B4F_DATFIN", "B7D_DTFVAL")

    cAliasTemp := getNextAlias()
    BeginSql Alias cAliasTemp	
        SELECT B7D.B7D_SEQUEN, B7D.B7D_DTVINI, B7D.B7D_DTFVAL, B4F.B4F_DATINI, B4F.B4F_DATFIN FROM %table:B7D% B7D 
        INNER JOIN %table:B4F% B4F
            ON B4F.B4F_FILIAL = %xFilial:B4F% 
           AND B4F.B4F_CODREC = B7D.B7D_CODREC
           AND B4F.B4F_MATRIC = %Exp:cSubscriberId%
           AND B4F.B4F_STATUS IN ('3', '5') // 3= Deferido ; 5=Deferido parcialmente
           AND B4F.%NotDel%
        
        INNER JOIN %table:BR8% BR8
            ON BR8.BR8_FILIAL = %xFilial:BR8% 
           AND BR8.BR8_CODPAD = B7D.B7D_CODPAD
           AND BR8.BR8_CODPSA = B7D.B7D_CODMED
           AND BR8.%NotDel%

         WHERE B7D.B7D_FILIAL = %xFilial:B7D% 
           AND B7D.B7D_CODREC = %Exp:cPrescription%
           AND B7D.B7D_CODMED = %Exp:cMedicationCode%
           AND B7D.B7D_CODPAD = %Exp:cMedicationTable%
           AND B7D.B7D_OK = 'T'
           AND B7D.B7D_QTDAUT >= B7D.B7D_QTDEXE
           AND B7D.%NotDel% 
    EndSql

    TCSetField(cAliasTemp, "B7D_DTVINI", "D")
    TCSetField(cAliasTemp, "B7D_DTFVAL", "D")
    TCSetField(cAliasTemp, "B4F_DATINI", "D")
    TCSetField(cAliasTemp, "B4F_DATFIN", "D")

    While !(cAliasTemp)->(Eof())
        if PLSINTVAL(cAliasTemp, cFieldDateInitil, cFieldDateFinal, oStructRefund:DatDoc)
            oStructRefund:SeqMed := (cAliasTemp)->B7D_SEQUEN
            lExists := .t.
            Exit
        endif

        (cAliasTemp)->(DbSkip())
    EndDo

    (cAliasTemp)->(DbCloseArea())

return lExists

/*/{Protheus.doc} addRefund
Método responsavel por adicionar os protocolos de reembolso

@type method
@author vinicius.queiros
@since 11/04/2023
@version Protheus 12
/*/
method addRefund() as logical class RefundService

    local lAdd := .f. as logical
    local nX := 0 as Numeric
    local nY := 0 as Numeric
    local aResult := {} as array
    local cRecnos := "" as character
    local lInsertBOW := .f. as logical
    local lInsertB1N := .f. as logical
    local lUpdateBOW := .f. as logical

    for nY := 1 to Len(self:aRefundReceipts)
        cRecnos := ""
        for nX := 1 to Len(self:aRefundReceipts[nY])
            lInsertBOW := nY == 1 .And. nX == 1 // Inclui BOW somente na primeira despesa de todos os comprovantes
            lInsertB1N := .t. // Sempre inclui a despesa
            lUpdateBOW := nX == 1 // Atualiza BOW na primeira despesa de cada comprovante

            aResult := PLSREEMBIT(lInsertBOW, lInsertB1N, IIf(Empty(self:cProtocolNumber), "0", self:cProtocolNumber), self:aRefundReceipts[nY][nX], "0",;
                                  self:oBaseService:jBody["subscriberId"], lUpdateBOW, IIf(Empty(cRecnos), "0", cRecnos), "01", self:oBaseService:jBody["healthInsurerCode"],;
                                  self:jBankData, self:jContact)

            if ValType(aResult) == "A" .And. Len(aResult) > 0
                cRecnos += IIf(Empty(cRecnos), "", ",")+StrToKarr(aResult[1], "|")[2]

                if Empty(self:cProtocolNumber)
                    self:cProtocolNumber := StrToKarr(aResult[1], "|")[1]
                    lAdd := .t.
                endif
            endif
        next nX
    next nY

    // Anexa no banco de conhecimento os arquivos recebidos
    if lAdd .And. Len(self:aAttachments) > 0
        self:oBaseService:addknowledgeBank(self:aAttachments, "BOW", xFilial("BOW")+self:oBaseService:jBody["healthInsurerCode"]+self:cProtocolNumber)
    endif

    if lAdd .And. self:oBaseService:jBody["status"] == "1" // Protocolado
        lAdd := self:confirmRefund(cRecnos)
    endif 

    if lAdd
        lAdd := self:setProtocolJsonResponse()
    endif
	 
return lAdd

/*/{Protheus.doc} confirmRefund
Método responsavel por finalizar a solicitação do protocolo de reembolso
(status igual a 1 = Protocolado)

@type method
@author vinicius.queiros
@since 14/04/2023
@version Protheus 12
/*/
method confirmRefund(cRecnos as character, lUpdate as logical) as logical class RefundService

    local lConfirm := .f. as logical
    local aBeneficiaryData := {} as array
    local aRefundData := {} as array
    local aChecksDeleted := {} as array
    local nLastReceipts := Len(self:oBaseService:jBody["refundReceipts"]) as Numeric
    local aUnreferencedNetworks := {} as array
    local aConfirm := {} as array

    default lUpdate := .f.

    aBeneficiaryData := PLSDADUSR(self:oBaseService:jBody["subscriberId"], "1", .f.,dDatabase, nil, nil, "NAO_VALIDAR_CARTAO")

    aAdd(aRefundData, self:oBaseService:jBody["subscriberId"])
	aAdd(aRefundData, self:oBaseService:jBody["refundReceipts"][nLastReceipts]["unreferencedNetworkIdentifier"])
	aAdd(aRefundData, "") // Login do portal
	aAdd(aRefundData, xFilial("BOW"))
	aAdd(aRefundData, self:oBaseService:jBody["refundReceipts"][nLastReceipts]["unreferencedNetworkName"])
	aAdd(aRefundData, self:oBaseService:jBody["refundReceipts"][nLastReceipts]["documentNumber"])
	aAdd(aRefundData, DToC(self:oBaseService:convertDateFormat(self:oBaseService:jBody["refundReceipts"][nLastReceipts]["documentDate"])))
	aAdd(aRefundData, self:oBaseService:jBody["refundReceipts"][nLastReceipts]["documentType"])
	aAdd(aRefundData, "")
	aAdd(aRefundData, "")

    // Tratamento para multi-comprovantes
    if !GetNewPar("MV_VRDANRF", .f.)
		aUnreferencedNetworks := PLSRCRNRF(self:cProtocolNumber)
        // Atualiza CNPJ/CPF da Rede não referenciada - Cabeçaho do protocolo (BOW)
		if (Empty(aRefundData[2]) .Or. aRefundData[2] <> aUnreferencedNetworks[2][1]) .And. (Len(aUnreferencedNetworks[1]) > 0)
			aRefundData[2] := IIf(!Empty(aUnreferencedNetworks[2][1]), aUnreferencedNetworks[2][1], aUnreferencedNetworks[1][2][2])
		endif
        // Atualiza Nome da Rede não referenciada - Cabeçaho do protocolo (BOW)
		if (Empty(aRefundData[5]) .Or. aRefundData[5] <> aUnreferencedNetworks[2][2]) .And. (Len(aUnreferencedNetworks[1]) > 0)
			aRefundData[5] := IIf(!Empty(aUnreferencedNetworks[2][2]), aUnreferencedNetworks[2][2], aUnreferencedNetworks[1][2][1])
		endif
        // Atualiza Estado e Cidade da Rede não referenciada - Cabeçaho do protocolo (BOW)
		if !Empty(aUnreferencedNetworks[2][3]) .And. Len(aUnreferencedNetworks[1]) >= 1
			aRefundData[9] := IIf(!Empty(aUnreferencedNetworks[2][3]), aUnreferencedNetworks[2][3], aUnreferencedNetworks[1][2][3])
			aRefundData[10] := IIf(!Empty(aUnreferencedNetworks[2][4]), aUnreferencedNetworks[2][4], aUnreferencedNetworks[1][2][4])
		endif
    endif

    // Verifica se existem itens negados e deleta do banco de dados
	aChecksDeleted := PLDELITEM(self:cProtocolNumber)

    if aChecksDeleted[1]
        aConfirm := StrToKarr(PLSCMPBOW(self:cProtocolNumber, aRefundData, iif(lUpdate, "true", "false"), self:oBaseService:jBody["refundReceipts"][nLastReceipts]["requiredDocument"], .f., cRecnos, "S", nil, self:oBaseService:jBody["healthInsurerCode"]), "|")

        if aConfirm[1] == "true"
            lConfirm := .t.
        else
            self:oBaseService:setError("E013", "Solicitação de reembolso não concluída",;
                                       aConfirm[2],;
                                       400) // Bad Request
        endif  
    endif

return lConfirm

/*/{Protheus.doc} setProtocolJsonResponse
Método responsavel por setar o json de resposta do protocolo de reembolso

@type method
@author vinicius.queiros
@since 14/04/2023
@version Protheus 12
/*/
method setProtocolJsonResponse() as logical class RefundService

    local lOk := .f. as logical
    local cAliasTemp as character
    local cProtocolNumber := self:cProtocolNumber as character
    local cStatus as character

    cAliasTemp := getNextAlias()
    beginSql alias cAliasTemp	
        SELECT BOW.BOW_PROTOC, BOW.BOW_STATUS, BOW.BOW_DTDIGI, BOW.BOW_VLRAPR, BOW.BOW_VLRREE, BOW.BOW_PGMTO, BOW.BOW_NOMUSR FROM %table:BOW% BOW
           WHERE BOW.BOW_FILIAL = %xFilial:BOW% 
           AND BOW.BOW_PROTOC = %exp:cProtocolNumber%
           AND BOW.%notDel% 
    endSql
    
    if !(cAliasTemp)->(eof())
        if (cAliasTemp)->BOW_STATUS == "A"
            cStatus := "0" // Solicitação não concluida (status na api)
        else
            cStatus := (cAliasTemp)->BOW_STATUS
        endif

        self:oBaseService:setAttributeJson({"attribute" : "protocol", "value" : cProtocolNumber, "type" : "C", "setResponse" : .t.})
        self:oBaseService:setAttributeJson({"attribute" : "status", "value" : cStatus, "type" : "C", "setResponse" : .t.})
        self:oBaseService:setAttributeJson({"attribute" : "requestDate", "value" : SToD((cAliasTemp)->BOW_DTDIGI), "type" : "D", "setResponse" : .t.})
        self:oBaseService:setAttributeJson({"attribute" : "presentedAmount", "value" : (cAliasTemp)->BOW_VLRAPR, "type" : "N", "setResponse" : .t.})
        self:oBaseService:setAttributeJson({"attribute" : "refundedAmount", "value" : (cAliasTemp)->BOW_VLRREE, "type" : "N", "setResponse" : .t.})
        self:oBaseService:setAttributeJson({"attribute" : "paymentDate", "value" : SToD((cAliasTemp)->BOW_PGMTO), "type" : "D", "setResponse" : .t.})
        self:oBaseService:setAttributeJson({"attribute" : "beneficiaryName", "value" : (cAliasTemp)->BOW_NOMUSR, "type" : "C", "setResponse" : .t.})

        self:oBaseService:addLinkJson({"rel" : "expenses", "href" : "/totvsHealthPlans/attendance/v1/refunds/"+cProtocolNumber+"/expenses"})
        self:oBaseService:addLinkJson({"rel" : "attachments", "href" : "/totvsHealthPlans/attendance/v1/refunds/"+cProtocolNumber+"/attachments"})

        lOk := .t.
    endif

    (cAliasTemp)->(dbCloseArea())

return lOk

/*/{Protheus.doc} getStatusCode
Retornar o status code de retorno da API

@type method
@version Protheus 12.1.2310
@author vinicius.queiros
@since 30/05/2023
@return numeric, status code da api
/*/
method getStatusCode() as numeric class RefundService
return self:oBaseService:getStatusCode()

/*/{Protheus.doc} getJsonResult
Retornar o json da api

@type method
@version Protheus 12.1.2310
@author vinicius.queiros
@since 30/05/2023
@return json, Json final da api 
/*/
method getJsonResult() as json class RefundService
return self:oBaseService:getJsonResult()

/*/{Protheus.doc} setBodyString
Método responsavel por definir os dados do body recebidos pela requisição

@type method
@author vinicius.queiros
@since 30/05/2023
@version Protheus 12.1.2310
@param, cBody, character, body recebido pela api
@param, cErro, Código do erro quando encontrado
@param logical, Se o body está valido 
/*/
method setBodyString(cBody as character, cErro as character) as logical class RefundService

    local lOk := .f. as logical

    lOk := self:oBaseService:setBodyString(cBody, cErro)

return lOk

/*/{Protheus.doc} setQueryParams
Define os dados do Query Param recebidos pela requisição

@type method
@version Protheus 12.1.2310
@author vinicius.queiros
@since 30/05/2023
@param jQueryParams, json, Dados do query param recebidos pela requisição
@return logical
/*/
method setQueryParams(jQueryParams as json) as logical class RefundService

    self:oBaseService:setQueryParams(jQueryParams)

return .t.

/*/{Protheus.doc} setPathParams
Define os dados do path Param recebidos pela requisição

@type method
@version Protheus 12.1.2310
@author vinicius.queiros
@since 30/05/2023
@param jPathParams, json, Dados do path param recebidos pela requisição
@return logical
/*/
method setPathParams(jPathParams as json) as logical class RefundService

    self:oBaseService:setPathParams(jPathParams)

return .t.

/*/{Protheus.doc} getToleranceDate
Retorna data de tolerancia da familia para solicitação de reembolso

@type method
@version Protheus 12.1.2310
@author vinicius.queiros
@since 30/05/2023
@param cFamilyCode, character, Código da família, sendo BA3_CODINT+BA3_CODEMP+BA3_MATRIC
@return character, data de tolerância no formato: AAAA-MM-DD
/*/
method getToleranceDate(cFamilyCode as character) as date class RefundService

    local dToleranceDate := ctod(" / / ") as date

    BA3->(dbSetOrder(1)) // BA3_FILIAL + BA3_CODINT + BA3_CODEMP + BA3_MATRIC
    if BA3->(msSeek(xFilial("BA3")+cFamilyCode))

        BI3->(dbSetOrder(1)) // BI3_FILIAL + BI3_CODINT + BI3_CODIGO + BI3_VERSAO
        if BI3->(MsSeek(xFilial("BI3")+BA3->(BA3_CODINT+BA3_CODPLA+BA3_VERSAO))) .and. BI3->BI3_MXDRMB > 0       
            dToleranceDate := dDataBase - BI3->BI3_MXDRMB              
        endif
    endIf
    
return dToleranceDate

/*/{Protheus.doc} getRefundExpenses
Retorna as despesas do protocolo de reembolso

@type method
@version Protheus 12.1.2310
@author vinicius.queiros
@since 30/05/2023
@param cProtocol, character, numero do protocolo de reembolso
@return array, Despesas com o objeto RefundStruct 
/*/
method getRefundExpenses(cProtocol as character, cNoSeqExpense as character) as array class RefundService

    local aExpenses := {} as array
    local cAliasTemp as character
    local oStructRefund as object

    default cNoSeqExpense := ""

    cAliasTemp := getNextAlias()
    
    beginSql alias cAliasTemp	
        SELECT B1N.B1N_MATRIC, B1N.B1N_NUMDOC, B1N.B1N_CODPAD, B1N.B1N_CODPRO, B1N.B1N_DATPRO, B1N.B1N_TIPDOC,
               B1N.B1N_PRCNPJ, B1N.B1N_PRNOME, B1N.B1N_EST, B1N.B1N_CODMUN, B1N.B1N_DATDOC, B1N.B1N_TIPSER,  
               B1N.B1N_USOCON, B1N.B1N_CODREC, B1N.B1N_CODMED, B1N.B1N_VLRTOT, B1N.B1N_QTDPRO 
           FROM %table:B1N% B1N
           WHERE B1N.B1N_FILIAL = %xFilial:B1N% 
             AND B1N.B1N_PROTOC = %exp:cProtocol%
             AND B1N.B1N_SEQUEN <> %exp:cNoSeqExpense%
             AND B1N.%notDel% 
    endSql

    while !(cAliasTemp)->(eof())
        
        oStructRefund := RefundStruct():new()

        oStructRefund:Matric := alltrim((cAliasTemp)->B1N_MATRIC)
        oStructRefund:NroDoc := alltrim((cAliasTemp)->B1N_NUMDOC)
        oStructRefund:CodPad := alltrim((cAliasTemp)->B1N_CODPAD)
        oStructRefund:CodPro := alltrim((cAliasTemp)->B1N_CODPRO)
        oStructRefund:DatComprov := stod((cAliasTemp)->B1N_DATPRO)
        oStructRefund:TipDoc := alltrim((cAliasTemp)->B1N_TIPDOC)
        oStructRefund:CPFCNPJ := alltrim((cAliasTemp)->B1N_PRCNPJ)
        oStructRefund:NomRDA := alltrim((cAliasTemp)->B1N_PRNOME)
        oStructRefund:UF := alltrim((cAliasTemp)->B1N_EST)
        oStructRefund:Cidade := alltrim((cAliasTemp)->B1N_CODMUN)
        oStructRefund:DatDoc := stod((cAliasTemp)->B1N_DATDOC)
        oStructRefund:TipSer := alltrim((cAliasTemp)->B1N_TIPSER)
        oStructRefund:UsoC := alltrim((cAliasTemp)->B1N_USOCON)
        oStructRefund:CodRec := alltrim((cAliasTemp)->B1N_CODREC)
        oStructRefund:CodMed := alltrim((cAliasTemp)->B1N_CODMED)
        oStructRefund:VlrPro := cValToChar((cAliasTemp)->B1N_VLRTOT * 100) // Converte em caracter sem casas decimais - Função PLSREEMBIT espera dessa forma
        oStructRefund:QtdPro := cValToChar((cAliasTemp)->B1N_QTDPRO) // Converte em caracter - Função PLSREEMBIT espera dessa forma
    
        aAdd(aExpenses, oStructRefund)
        (cAliasTemp)->(dbSkip())
    enddo

    (cAliasTemp)->(dbCloseArea())

return aExpenses

/*/{Protheus.doc} setProtocolStruct
Define/valida a estrutura do protocolo de reembolso para protocolar (status = 1)

@type method
@version Protheus 12.1.2310  
@author vinicius.queiros
@since 02/06/2023
@return logical, se os dados do reembolso estão prontos para protocolar
/*/
method setProtocolStruct() as logical class RefundService

    local aDetailsErro := {} as array
    local aRefundExpenses as array
    local lOk := .f. as logical
    local nX := 0 as numeric
    local jBodyChecking as json
    local aAttachments as array

    self:oBaseService:jBody["toleranceDate"] := self:getToleranceDate(substr(self:cSubscriberId, 1, 14))
    self:oBaseService:jBody["subscriberId"] := self:cSubscriberId
    self:oBaseService:jBody["refundReceipts"] := {}

    aRefundExpenses := self:getRefundExpenses(self:cProtocolNumber) // Despesas do protocolo já incluidas para validação

    aAttachments := self:oBaseService:getKnowledgeBank("BOW", xFilial("BOW")+self:oBaseService:jBody["healthInsurerCode"]+self:cProtocolNumber)["items"]

    if len(aAttachments) == 0
        aAdd(aDetailsErro, {"code" : "E008-404",; // Not Found
                            "message" : "Não foram enviados anexos para esta solicitação, anexe e tente concluir a solicitação novamente",;
                            "detailedMessage" : "Não foi encontrado no banco de conhecimento (AC9) nenhum anexo para o protocolo "+self:cProtocolNumber})
    endif

    for nX := 1 to len(aRefundExpenses)

        jBodyChecking := JsonObject():new()        
        jBodyChecking["unreferencedNetworkIdentifier"] := aRefundExpenses[nX]:CPFCNPJ
        jBodyChecking["unreferencedNetworkName"] := aRefundExpenses[nX]:NomRDA
        jBodyChecking["stateAbbreviation"] := aRefundExpenses[nX]:UF
        jBodyChecking["cityCode"] := aRefundExpenses[nX]:Cidade
        jBodyChecking["documentCode"] := posicione("BBS", 2, xFilial("BBS")+aRefundExpenses[nX]:TipDoc, "BBS_COD")
        jBodyChecking["documentNumber"] := aRefundExpenses[nX]:NroDoc
        jBodyChecking["documentDate"] := self:oBaseService:setAttributeJson({"attribute" : "toleranceDate", "value" : aRefundExpenses[nX]:DatDoc, "type" : "D", "addJsonResult" : .f., "setResponse" : .t.})

        // Valida os dados do comprovante
        if self:validReceipts("E005", @aDetailsErro, @jBodyChecking)  
            aRefundExpenses[nX]:cDocObr := jBodyChecking["requiredDocument"]  

            self:validExpenses("E006", @aDetailsErro, aRefundExpenses[nX]) // Valida os dados despesa
        endif

        aAdd(self:oBaseService:jBody["refundReceipts"], jBodyChecking)
    next nX

    if len(aDetailsErro) > 0
        self:oBaseService:setError("E007", "Dados inválidos para confirmar o protocolo de reembolso",;
                                   "Verifique os detalhes dos erros no campo details",;
                                    400,; // Bad Request
                                    aDetailsErro)
    else
        lOk := .t.
    endif  

return lOk

/*/{Protheus.doc} getRefundId
Método responsavel por retornar os dados do protocolo de reembolso

@type method
@author vinicius.queiros
@since 12/12/2023
@version 12.1.2410
@return logical, se houve sucesso ao retornar os dados do protocolo de reembolso
/*/
method getRefundId() as Logical class RefundService

    local lSucess := .f. as logical
    local aKeys := {} as array
    local cProtocol as character

    aAdd(aKeys, {"type" : "pathParams", "key" : "protocol"})

    if self:oBaseService:checkRequiredKeys(aKeys, "E001") // Not Acceptable
        cProtocol := padr(self:oBaseService:jPath["protocol"], tamSX3("BOW_PROTOC")[1])

        BOW->(dbSetOrder(1))
        if BOW->(msSeek(xFilial("BOW")+cProtocol))
            self:oBaseService:setAttributeJson({"attribute" : "status", "value" : self:getStatusApi(BOW->BOW_STATUS), "type" : "C"})
            self:oBaseService:setAttributeJson({"attribute" : "protocol", "value" : BOW->BOW_PROTOC, "type" : "C"})
            self:oBaseService:setAttributeJson({"attribute" : "request_date", "value" : BOW->BOW_DTDIGI, "type" : "D"})
            self:oBaseService:setAttributeJson({"attribute" : "presented_amount", "value" : BOW->BOW_VLRAPR, "type" : "N"})
            self:oBaseService:setAttributeJson({"attribute" : "refunded_amount", "value" : BOW->BOW_VLRREE, "type" : "N"})
            self:oBaseService:setAttributeJson({"attribute" : "payment_date", "value" : BOW->BOW_PGMTO, "type" : "C"})
            self:oBaseService:setAttributeJson({"attribute" : "beneficiary_name", "value" : BOW->BOW_NOMUSR, "type" : "C"})
            self:oBaseService:setAttributeJson({"attribute" : "observation", "value" : BOW->BOW_OBS, "type" : "C"})
            self:oBaseService:setAttributeJson({"attribute" : "bank_code", "value" : BOW->BOW_NROBCO, "type" : "C"})
            self:oBaseService:setAttributeJson({"attribute" : "bank_name", "value" : posicione("SA6", 1, xFilial("SA6")+BOW->BOW_NROBCO, "A6_NOME"), "type" : "C"})
            self:oBaseService:setAttributeJson({"attribute" : "branch", "value" : BOW->BOW_NROAGE, "type" : "C"})
            self:oBaseService:setAttributeJson({"attribute" : "branch_vd", "value" : BOW->BOW_NRODAG, "type" : "C"})
            self:oBaseService:setAttributeJson({"attribute" : "account", "value" : BOW->BOW_NROCTA, "type" : "C"})
            self:oBaseService:setAttributeJson({"attribute" : "account_vd", "value" : BOW->BOW_NRODTO, "type" : "C"})
            self:oBaseService:setAttributeJson({"attribute" : "telephone", "value" : BOW->BOW_TELCON, "type" : "C"})
            If BOW->(FieldPos('BOW_EMAIL')) > 0 .and. !empty(BOW->BOW_EMAIL)
                self:oBaseService:setAttributeJson({"attribute" : "email", "value" : BOW->BOW_EMAIL, "type" : "C"})
            else
                BA1->(dbSetOrder(2))
                if BA1->(msSeek(xFilial("BOW")+BOW->BOW_USUARI))
                    self:oBaseService:setAttributeJson({"attribute" : "email", "value" : BA1->BA1_EMAIL, "type" : "C"})
                EndIf
            EndIf

            lSucess := .t.
            self:oBaseService:nCodeStatus := 200 // Ok
        else
            self:oBaseService:setError("E002", "Nenhuma protocolo foi encontrada",;
                                               "Não foi encontrada nenhum protocolo com o ID "+cProtocol+" na tabela BOW (BOW_PROTOC).",;
                                               404) // Not found
        endif
    endif

return lSucess

/*/{Protheus.doc} getStatusApi
Retorna os status da api x protheus do protocolo de reembolso

@type method
@version 12.1.2410
@author vinicius.queiros
@since 12/12/2023
@return character, Campo status da api com o de/para
/*/
method getStatusApi(cStatus as character) as character class RefundService

    local cStatusApi := "" as character

    do case
        case cStatus == "A" // Solicitação não concluida
            cStatusApi := "0"
             
        case cStatus == "0" .or. cStatus == "1" // Protocolado
            cStatusApi := "1"

        case cStatus == "2" .or. cStatus == "3" .or. cStatus == "5" .or. cStatus == "9" // Em analise
            cStatusApi := "2"

        case cStatus == "6" // Reembolso aprovado
            cStatusApi := "3"

        case cStatus == "4" .or. cStatus == "7" .or. cStatus == "8" // Reembolso rejeitado
            cStatusApi := "4"

        case cStatus == "B" // Aguardando informação do Beneficiário
            cStatusApi := "5"

        case cStatus == "C" // Aprovado Parcialmente
            cStatusApi := "6"

        case cStatus == "D" // Cancelado
            cStatusApi := "7"
        
        case cStatus == "E" // Reembolso revertido
            cStatusApi := "8"
    endcase

return cStatusApi
