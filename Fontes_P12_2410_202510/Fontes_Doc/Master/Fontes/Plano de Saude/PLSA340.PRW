#INCLUDE "plsa340.ch"

#include "PLSMGER.CH"
/*/


Ŀ
Programa   PLSA340  Autor  Michele Tatagiba      Data  29.01.2002 
Ĵ
Descrio  Cadastro de Formas de Bloqueio do Contrato                 
Ĵ
Uso        Advanced Protheus 7.10                                     
Ĵ
Parametros Nenhum                                                     
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Alterao                     
Ĵ
ٱ


/*/
Function PLSA340

//Ŀ
// Define variaveis...                                                 
//
LOCAL aRotAux     := {}
LOCAL nNr         
PRIVATE aRotina   := MenuDef()
PRIVATE cCadastro := fundesc()  //"Formas de Bloqueio do Familia"
PRIVATE cAlias    := "BG1"
//Ŀ
// Chama funcao de Browse...                                           
//
BG1->(dbGoTop())
   
   If ExistBlock("PL340MEN")
      aRotAux := ExecBlock("PL340MEN",.F.,.F.,{})

      If ValType(aRotAux) == "A"
         for nNr := 1 to Len(aRotAux)
            AAdd(aRotina, aRotAux[nNr])
         Next
      EndIf	
   EndIf

BG1->(mBrowse(06,01,22,75,"BG1"))
//Ŀ
// Fim da Rotina...                                                    
//

Return
/*/


Ŀ
Programa   PLSA340MOV Autor  Michele Tatagiba    Data  29.01.2002 
Ĵ
Descrio  Monto uma enchoice especifica para a exclusao              
Ĵ
Parametros Nenhum                                                     
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Alterao                     
Ĵ
ٱ


/*/                     
Function PLSA340MOV(cAlias,nReg,nOpc)
Local I__f := 0
Local nRetorno	:= 0

//Ŀ
// Define variaveis da EnchoiceBar...                                  
//
LOCAL bOK     := {|| nOpca := 1,If( PLSA340OK(M->BG1_CODBLO), ;
                      oDlg:End(),nOpca:=2),If(nOpca==1,oDlg:End(),.F.) }
LOCAL bCancel := {||oDlg:End()}
//Ŀ
// Define variaveis genericas...                                       
//
PRIVATE nOpcx        := nOpc
PRIVATE nOpca        := 0
//Ŀ
// Define variaveis da enchoice...                                     
//
PRIVATE aTELA[0][0]
PRIVATE aGETS[0]   
//Ŀ
// Define variaveis para controle de forma de pagamento...             
//
PRIVATE aSTela  := {}
//Ŀ
// Define Dialogo...                                                   
//
PRIVATE oDlg

If nOpc == K_Incluir
	
	nRetorno := AxInclui(cAlias,nReg,K_Incluir)

ElseIf nOpc == K_Alterar
	
	nRetorno := AxAltera(cAlias,nReg,K_Alterar)

ElseIf nOpc == K_Excluir

   //Ŀ
   // Monta ,M->??? para enchoice...                                       
   //
   Copy cAlias TO MEMORY
   //Ŀ
   // Define dialogo...                                                   
   //
   SetEnch("") 
   DEFINE MSDIALOG oDlg TITLE cCadastro FROM ndLinIni,ndColIni TO ndLinFin,ndColFin OF GetWndDefault()
   //Ŀ
   // Monta Enchoice dos Dados Gerais ...                                 
   //
   Zero();MsMGet():New(cAlias,nReg,nOpc,,,,,{012,001,195,356},,,,,,oDlg,,,.F.)
   //Ŀ
   // Ativa o dialogo...                                                  
   //
   ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,bOK,bCancel,.F.,{})
   //Ŀ
   // Trata atualizacao dos dados...  
   //
   If nOpca == K_OK
      //Ŀ
      // Inicio da Transacao...                                              
      // 
      Begin Transaction
      PLUPTENC("BG1",nOpc)
      End Transaction
   Endif
EndIf 

If nRetorno == 1 .And. nOpc <> K_Excluir .And. ExistBlock("PL340GRV")
	   
	ExecBlock("PL340GRV",.F.,.F.,{nOpc})

EndIf
Return

/*/


Ŀ
Programa   PLS340New  Autor  Michele Tatagiba    Data  29.01.2002 
Ĵ
Descrio  Busca novo codigo para bloqueio de contrato                
Ĵ
Parametros Nenhum                                                     
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Alterao                     
Ĵ
ٱ


/*/                     
Function PLS340New(cPropri)
//Ŀ
// Busca o proximo codigo...                                                
//
LOCAL cNew

BG1->(DbSetOrder(1))
                                                                         
If cPropri == "9"
   BG1->(DbSeek(xFilial("BG1")+cPropri+"99"))
Else
   If cPropri == "1"
      BG1->(DbSeek(xFilial("BG1")+"9"))
   Endif
Endif
BG1->(DbSkip(-1))

If BG1->BG1_PROPRI == cPropri
   cNew := cPropri+StrZero(Val(Subs(BG1->BG1_CODBLO,2,2))+1,2)
Else
   cNew := cPropri+"01"
Endif

Return(cNew)

/*/


Ŀ
Programa   PLS340VLD  Autor  Michele Tatagiba    Data  29.01.2002 
Ĵ
Descrio  Verifica se o campo rdmake foi utilizado                   
Ĵ
Parametros Nenhum                                                     
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Alterao                     
Ĵ
ٱ


/*/                     
Function PLS340VLD()
Return(M->BG1_PERBLO == "0" .And. M->BG1_PROPRI <> "1")

/*/


Ŀ
Programa   PLSA340OK  Autor  Michele Tatagiba    Data  29.01.2002 
Ĵ
Descrio  Verifica se existe algum contratocom esse codigo de bloquei
Ĵ
Parametros Nenhum                                                     
Ĵ
            ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL           
Ĵ
Programador  Data    BOPS   Motivo da Alterao                     
Ĵ
ٱ


/*/                     
Function PLSA340OK(cCodBlo)
                     
LOCAL nRecBA3 := BA3->(Recno())
LOCAL nOrdBA3 := BA3->(IndexOrd())
LOCAL cInd    := CriaTrab(Nil,.F.)
LOCAL cFor    := ""
LOCAL lRet    := .T.
//Ŀ
// Monta Expressao de filtro...                                             
//
cFor := "BA3_FILIAL = '"+xFilial("BA3")+"' .And. "
cFor += "BA3_MOTBLO == '"+cCodBlo+"'"
//Ŀ
// Monta filtro de acordo com os grupos informados no parametro...          
//
BA3->(IndRegua("BA3",cInd,"BA3_MOTBLO",nil,cFor,nil,.T.))
//Ŀ
// Posicione no primeiro registro no arquivo de usuarios...                 
//
If !BA3->(EOF())
   Alert(STR0007) //"Existe algum contrato bloqueado com esse motivo !"
   lRet := .F.
Endif
   
//Ŀ
// Restaura dados salvados...                                          
//
BA3->(DbSetOrder(nOrdBA3))
BA3->(DbGoTo(nRecBA3))   
      
Return(lRet)

/*/


Ŀ
Programa  MenuDef    Autor  Darcio R. Sporl        Data 04/01/2007
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          		1 - Pesquisa e Posiciona em um Banco de Dados           
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/
Static Function MenuDef()
Private aRotina := {	{ STR0001	, 'AxPesqui'	, 0 , K_Pesquisar  , 0, .F.},; //"Pesquisar"
						{ STR0002	, 'AxVisual'	, 0 , K_Visualizar , 0, Nil},; //"Visualizar"
						{ STR0003	, 'PLSA340MOV'	, 0 , K_Incluir    , 0, Nil},; //"Incluir"
						{ STR0004	, 'PLSA340MOV'	, 0 , K_Alterar    , 0, Nil},; //"Alterar"
						{ STR0005	, 'PLSA340MOV'	, 0 , K_Excluir    , 0, Nil} } //"Excluir"
Return(aRotina)