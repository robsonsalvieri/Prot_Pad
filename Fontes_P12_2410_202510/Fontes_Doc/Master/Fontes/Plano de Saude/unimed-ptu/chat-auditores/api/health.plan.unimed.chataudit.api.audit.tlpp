#include "tlpp-core.th"
#include "tlpp-rest.th"

#define INCLUSION_TYPE "1" // Inclusão
#define CRLF chr(13) + chr(10)
#define REQUIRED .T.
#define OPTIONAL .F.

namespace totvs.protheus.health.plan.unimed

using namespace totvs.protheus.health.plan.api.util


class ChatAuditApiAudit from RestClient

	protected data jBody as json
	protected data aParams as array
	protected data jResponse as json
	protected data cMessage as character
	protected data lIsError as logical
	protected data oToken as object
	protected data cUnimedOrigin as character
	protected data cOperation as character
	protected data jStatusCodeMessage as json

	public method new(cHealthInsurerCode) constructor
	public method addChatAudit(cUnimedOrigin as character, cOperation as character, cTransactionCode as character) as logical
	public method send() as logical
	public method getRequest() as json
	public method getResponse() as json
	public method getMessage() as character
	public method destroy()

	protected method loadHeader()
	protected method loadBillingGuideUsageData()
	protected method loadDataOriginMessage()
	protected method loadDataDestinationMessage()
	protected method loadDataMessage()	

	protected method loadApiConfig(cHealthInsurerCode as character) as logical
	protected method setResponse() as logical
	protected method setError(cCode as character, cMessage as character, cDetailedMessage as character, aDetails as array) as json
	protected method setParams(jData as json)
	protected method setAttribute(jData as json)
	protected method getStatusCodeMessage(cStatusCode as character, cOperation as character) as character
	protected METHOD setFormData(aKeys as array) as logical
endclass

/*/{Protheus.doc} new
Método construtor da classe
@type method
@version 12.1.2410
@author jose.paulo
@since 04/04/2025
@param cHealthInsurerCode, character, código da operadora para autenticação
@return object, objeto da instância da classe
/*/
method new(cHealthInsurerCode) class ChatAuditApiAudit

	_Super:new()

	self:oToken := TokenOAuth():new(PLSINTPAD())
	self:jBody := JsonObject():new()
	self:aParams := {}
	self:jResponse := JsonObject():new()
	self:lIsError := .F.

return self


method addChatAudit(cUnimedOrigin as character, cOperation as character, cTransactionCode as character) as logical class ChatAuditApiAudit

	local lAdd := .F. as logical

	self:jBody := JsonObject():new()

	if !Empty(cUnimedOrigin)
		self:cUnimedOrigin := cUnimedOrigin
		self:cOperation    := cOperation

		self:loadHeader(cTransactionCode)
		self:loadBillingGuideUsageData()
		self:loadDataOriginMessage()
		self:loadDataDestinationMessage()
		self:loadDataMessage()

		if !self:lIsError
			lAdd := .T.
		endif
	else
		self:setError("502.021",;
					  "Unimed origem não encontrada no CADU",; 
					  "Operadora origem não encontrada.") 
		lAdd := .F.
	endif

return lAdd

method send() as logical class ChatAuditApiAudit

	local lSuccess       := .F. as logical
	local aHeaders       := {}  as array
	local aFormData      := {}  as array
	local cFileName             as Character
	local cFileExt              as Character
	local aArquiv        := {}  as array
	local lAnexo         := .F. as logical
	local nI             := 0 as numeric
	
	aArquiv:=PlsAneBC(BIU->BIU_FILIAL+BIU->BIU_IDSALA+BIU->BIU_IDCHAT)

	If Len(aArquiv) == 1
		If Len(aArquiv[1]) > 2 .And. !Empty(aArquiv[1,1]) .And. !Empty(aArquiv[1,2]) .And. !Empty(aArquiv[1,3])
			lAnexo := .T.
		Endif
	EndIf 

	if self:oToken:getToken()
		if self:loadApiConfig(PLSINTPAD())
			aAdd(aHeaders, {"key": "Authorization", "value": "Bearer " + self:oToken:getBearer()})	
			aAdd(aHeaders, {"key": "Content-Type", "value": "multipart/form-data"})

			If lAnexo
				aAdd(aHeaders, {"key": "Content-Disposition", "value": "inline; filename="+Alltrim(aArquiv[1,2])+Alltrim(aArquiv[1,3])})
				aAdd(aHeaders, {"key": "Accept-Charset", "value": "/"})
				aAdd(aHeaders, {"key": "Connection", "value": "keep-alive"})
			EndIf

			self:setHeaderParams(aHeaders)

			aAdd(aFormData, {"key": "body", "value": self:jBody:toJson(),"contentType": "application/json"})

			iF lAnexo
				SplitPath(Alltrim(aArquiv[1,2])+Alltrim(aArquiv[1,3]),,,@cFileName,@cFileExt)
				aAdd(aFormData, {"key": "anexo", "value": aArquiv[1,1], "contentType": "application/zip", "fileName": aArquiv[1,2] + cFileName + cFileExt})
			Endif

			self:setFormData(aFormData)

			lSuccess := self:post()

			if lSuccess
				lSuccess := self:setResponse()
			else
				self:jResponse:fromJson(self:getBody())
			endif

			self:cMessage := self:getStatusCodeMessage(cValToChar(self:getStatusCode()), self:cOperation)

			if (self:jResponse:hasProperty("status") .and. len(self:jResponse["status"])>0 .And. self:jResponse["status"][1]:hasProperty("statusProcessamento") .And. self:jResponse["status"][1]["statusProcessamento"]=="E")

				For nI:=1 to len(self:jResponse["status"])
					If nI == 1 
						self:cMessage := self:jResponse["status"][nI]["descricaoMensagem"]
					Else 
						self:cMessage += CRLF + self:jResponse["status"][nI]["descricaoMensagem"] 
					EndIf
				Next nI
			elseif empty(self:cMessage)
				self:cMessage := iif(self:jResponse:hasProperty("message"),;
									self:jResponse["message"],;
									"Falha na transmissão. Verifique as configurações no cadastro da Operadora.")
				lSuccess := .F.
			endif
		else
			lSuccess := .F.
		endif
	else
		lSuccess := .F.
		self:cMessage := self:oToken:getMessage()
		self:jResponse := self:oToken:getBody()
	endif

	fwFreeArray(aHeaders)

return lSuccess

/*/{Protheus.doc} getRequest
obter json de envio do CHAT
@type method
@version 12.1.2410
@author jose.paulo
@since 04/04/2025
@return json, objeto json com os dados da solicitação
/*/
method getRequest() as json class ChatAuditApiAudit

return self:jBody

/*/{Protheus.doc} getResponse
Obter json de resposta do envio do CHAT
@type method
@version 12.1.2410 
@author jose.paulo
@since 04/04/2025
@return json, objeto json com os dados da resposta
/*/
method getResponse() as json class ChatAuditApiAudit

return self:jResponse

/*/{Protheus.doc} getMessage
Obter mensagem de resposta do processamento
@type method
@version 12.1.2410
@author jose.paulo
@since 04/04/2025
@return character, mensagem de erro ou sucesso
/*/
method getMessage() as character class ChatAuditApiAudit

return self:cMessage

/*/{Protheus.doc} destroy
Limpa da memória as variáveis (objeto, array e json) da clase
@type method
@version 12.1.2410
@author jose.paulo
@since 04/04/2025
/*/
method destroy() class ChatAuditApiAudit

	freeObj(self:jBody)
	freeObj(self:jResponse)
	freeObj(self:oToken)
	freeObj(self:jStatusCodeMessage)
	fwFreeArray(self:aParams)

return

/*/{Protheus.doc} loadHeader
Carrega os dados do cabeçalho na requisição (body) a ser enviado para o chataudit.
@type method
@version 12.1.2410
@author jose.paulo
@since 04/04/2025
@param cTransactionCode, character, código da transação gerado
/*/
method loadHeader(cTransactionCode as character) class ChatAuditApiAudit

	local cOrigin := "cabecalho" as character

	self:jBody["cabecalho"] := JsonObject():new()
	self:setAttribute({"body": self:jBody["cabecalho"], "attribute": "codigoControleTransacao", "value": val(cTransactionCode), "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "Transação gerada automaticamente pelo sistema."}) 

	self:setAttribute({"body": self:jBody["cabecalho"], "attribute": "numeroVersaoPTU", "value": "01", "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "Fixo 010"}) 

	self:setAttribute({"body": self:jBody["cabecalho"], "attribute": "dataGeracao", "value": Alltrim(BIU->BIU_DATGER), "type": "chracter", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "Data Geração"})

return

/*/{Protheus.doc} loadBillingGuideUsageData
Carrega os dados do CHAT na requisição (body) a ser enviado para o chataudit.
@type method
@version 12.1.2410  
@author jose.paulo
@since 04/04/2025 
/*/
method loadBillingGuideUsageData() class ChatAuditApiAudit

	local cOrigin := "dadosGuiaCobrancaUtilizacao" as character

	self:jBody["dadosGuiaCobrancaUtilizacao"] := JsonObject():new()

	self:setAttribute({"body": self:jBody["dadosGuiaCobrancaUtilizacao"], "attribute": "unimedOrigemCobranca",;
					   "value": SubStr(BIV->BIV_ORGMCB,2,3), "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0026"})	   

	self:setAttribute({"body": self:jBody["dadosGuiaCobrancaUtilizacao"], "attribute": "unimedDestinoCobranca",;
					   "value": SubStr(BIV->BIV_DESTCB,2,3), "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0027"}) 

	self:setAttribute({"body": self:jBody["dadosGuiaCobrancaUtilizacao"], "attribute": "numeroDoc1",;
					   "value": PADL(BIV->BIV_NRDOC1,20), "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0028"}) 			   
					   
	self:setAttribute({"body": self:jBody["dadosGuiaCobrancaUtilizacao"], "attribute": "numeroDoc2",;
		   			   "value": PADL(BIV->BIV_NRDOC2,20), "type": "character", "required": OPTIONAL, "origin": cOrigin,;
		   			   "errorDetailedMessage": "STR0029"}) 

	self:setAttribute({"body": self:jBody["dadosGuiaCobrancaUtilizacao"], "attribute": "numeroLotePrestador",;
					   "value": BIV->BIV_LOTPRT, "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0030"}) 

	self:setAttribute({"body": self:jBody["dadosGuiaCobrancaUtilizacao"], "attribute": "numeroGuiaTissPrestador",;
					   "value": BIV->BIV_GUIPRT, "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0031"}) 

	self:setAttribute({"body": self:jBody["dadosGuiaCobrancaUtilizacao"], "attribute": "numeroGuiaTissOperadora",;
					   "value": BIV->BIV_GUIOPE, "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0032"}) 
					   
return

/*/{Protheus.doc} loadDataOriginMessage
Carrega os dados do cooperado na requisição (body) a ser enviado para o chataudit.
@type method
@version 12.1.2410 
@author jose.paulo
@since 04/04/2025
/*/
method loadDataOriginMessage() class ChatAuditApiAudit
	local cOrigin := "dadosUnimedOrigemMensagem" as character

	self:jBody["dadosUnimedOrigemMensagem"]:= JsonObject():new()

	self:setAttribute({"body": self:jBody["dadosUnimedOrigemMensagem"], "attribute": "unimedOrigem",;
					   "value": SubStr(BIU->BIU_ORGMSG,2,3), "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0044"})

	self:setAttribute({"body": self:jBody["dadosUnimedOrigemMensagem"], "attribute": "tipoAuditor",;
					   "value": val(BIU->BIU_TADTOR), "type": "number", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0045"})

	self:setAttribute({"body": self:jBody["dadosUnimedOrigemMensagem"], "attribute": "nomeAuditorOrigem",;
					   "value": BIU->BIU_NOMEOR, "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0045"})

	self:setAttribute({"body": self:jBody["dadosUnimedOrigemMensagem"], "attribute": "numeroConselhoProfissional",;
					   "value": BIU->BIU_CONPOR, "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0045"})

	self:setAttribute({"body": self:jBody["dadosUnimedOrigemMensagem"], "attribute": "ufConselhoProfissional",;
					   "value": BIU->BIU_UFCPOR, "type": "uf", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0045"})

return

/*/{Protheus.doc} loadDataDestinationMessage
Carrega os dados do produto do agregado na requisição (body) a ser enviado para o chataudit.
@type method
@version 12.1.2410 
@author jose.paulo
@since 04/04/2025
/*/
method loadDataDestinationMessage() class ChatAuditApiAudit
	local cOrigin := "dadosUnimedDestinoMensagem" as character

	self:jBody["dadosUnimedDestinoMensagem"]:= JsonObject():new()

	self:setAttribute({"body": self:jBody["dadosUnimedDestinoMensagem"], "attribute": "unimedDestino",;
					   "value": SubStr(BIU->BIU_DESMSG,2,3), "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0044"})

	self:setAttribute({"body": self:jBody["dadosUnimedDestinoMensagem"], "attribute": "tipoAuditor",;
					   "value": val(BIU->BIU_TADTDS), "type": "number", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0045"})

	self:setAttribute({"body": self:jBody["dadosUnimedDestinoMensagem"], "attribute": "nomeAuditorDestino",;
					   "value": BIU->BIU_NOMEDS, "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0045"})

	self:setAttribute({"body": self:jBody["dadosUnimedDestinoMensagem"], "attribute": "numeroConselhoProfissional",;
					   "value": BIU->BIU_CONPDS, "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0045"})

	self:setAttribute({"body": self:jBody["dadosUnimedDestinoMensagem"], "attribute": "ufConselhoProfissional",;
					   "value": BIU->BIU_UFCPDS, "type": "uf", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0045"})

return

/*/{Protheus.doc} loadDataMessage
Carrega os dados de preexistencia na requisição (body) a ser enviado para o chataudit.
@type method
@version 12.1.2410 
@author jose.paulo
@since 04/04/2025
/*/
method loadDataMessage() class ChatAuditApiAudit
	local cOrigin := "dadosMensagem" as character

	self:jBody["dadosMensagem"]:= JsonObject():new()

	self:setAttribute({"body": self:jBody["dadosMensagem"], "attribute": "tipoTransacao",;
					   "value": val(BIU->BIU_TPTRAN), "type": "number", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0044"})

	self:setAttribute({"body": self:jBody["dadosMensagem"], "attribute": "descricaoMensagem",;
					   "value": Alltrim(SubStr(BIU->BIU_MSGENV,1,2000)), "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": "STR0045"})

return


/*/{Protheus.doc} loadApiConfig
Carrega as configurações necessárias para comunicar com o chataudit
@type method
@version 12.1.2410
@author jose.paulo
@since 04/04/2025
@param cHealthInsurerCode, character, código da operadora para buscar as configurações
@return logical, se as configurações foram carregadas com sucesso
/*/
method loadApiConfig(cHealthInsurerCode as character) as logical class ChatAuditApiAudit

	local lOk := .T. as logical
	local cPFXFile as character
	local cCertificate as character
	local cPrivKey as character
	local cPassword as character
	local cError as character
	local cFileNamePFX as character
	local cCertificateDirectory := superGetMV("MV_PLCBCER", .F., "\cadbenef\certificados\") as character

	BA0->(dbSetOrder(1))
	if BA0->(dbSeek(xFilial("BA0") + PLSINTPAD()))
		self:setEndpoint(alltrim(BA0->BA0_URLCHA))
		cFileNamePFX := alltrim(BA0->BA0_CDBPFX)
		cPassword := alltrim(BA0->BA0_CDBPAS)

		if !empty(cFileNamePFX)
			cPFXFile := PLSMudSis(cCertificateDirectory + cFileNamePFX)
			cCertificate := PLSMudSis(cCertificateDirectory + "certificate.pem")
			cPrivKey := PLSMudSis(cCertificateDirectory + "privKey.pem")

			if file(cPFXFile)
				do case
					case !file(cCertificate) .and. !PFXCert2PEM(cPFXFile, cCertificate, @cError, cPassword)
						lOk := .F.
						self:setError("401",;
									  "Falha ao extrair o certificado de cliente para geração do arquivo no formato .PEM (Privacy Enhanced Mail).",; // "Falha ao extrair o certificado de cliente para geração do arquivo no formato .PEM (Privacy Enhanced Mail)."
									  cError)

					case !file(cPrivKey) .and. !PFXKey2PEM(cPFXFile, cPrivKey, @cError, cPassword)
						lOk := .F.
						self:setError("401",;
									   "Falha ao extrair a chave privada para geração do arquivo no formato .PEM (Privacy Enhanced Mail).",; // "Falha ao extrair a chave privada para geração do arquivo no formato .PEM (Privacy Enhanced Mail)."
									  cError)
					otherwise
						lOk := .T.
						self:setDigitalCertificate(cCertificate, cPrivKey, cPassword)
				endcase
			else
				lOk := .F.
				self:setError("401",;
							   "Certificado digital (PFX) não encontrado no diretório (RootPath) do servidor.",; // "Certificado digital (PFX) não encontrado no diretório (RootPath) do servidor."
							  cError)
			endif
		endif
	endif

return lOk

/*/{Protheus.doc} setResponse
Defini os dados de resposta da comunicação com o chataudit.
@type method
@version 12.1.2410
@author jose.paulo
@since 04/04/2025
@return logical, se a resposta foi processada com sucesso
/*/
method setResponse() as logical class ChatAuditApiAudit
	local xRet as variant
	local lSuccess := .F. as logical

	xRet := self:jResponse:fromJson(self:getBody())

	if xRet == nil
		if self:jResponse:hasProperty("status") .and. len(self:jResponse["status"])>0 .And. self:jResponse["status"][1]:hasProperty("statusProcessamento") .And. self:jResponse["status"][1]["statusProcessamento"]=="E"
			lSuccess := .F. 
		else
			lSuccess := .T.
		endif
	endif

return lSuccess

/*/{Protheus.doc} setError
Defini os dados de erro no json de resposta
@type method
@version 12.1.2410
@author jose.paulo
@since 04/04/2025
@param cCode, character, código do erro (status code)
@param cMessage, character, mensagem do erro
@param cDetailedMessage, character, detalhes do erro
@param aDetails, character, lista de objetos de erro com mais detalhes sobre o erro principal
@return json, objeto json de resposta
/*/
method setError(cCode as character, cMessage as character, cDetailedMessage as character, aDetails as array) as json class ChatAuditApiAudit

	local nCount as numeric

	default aDetails := {}

	self:jResponse["code"] := cCode
	self:jResponse["message"] := cMessage
	self:jResponse["detailedMessage"] := cDetailedMessage

	if len(aDetails) > 0
		if self:jResponse:hasProperty("details")
			for nCount := 1 to len(aDetails)
				aAdd(self:jResponse["details"], aDetails[nCount])
			next nCount
		else
			self:jResponse["details"] = aClone(aDetails)
		endif
	endif

	self:lIsError := .T.
	self:cMessage := cMessage

return self:jResponse

/*/{Protheus.doc} setParams
Defini os parâmetros (query param) para ser utilizado na comunicação com o chataudit
@type method
@version 12.1.2410 
@author jose.paulo
@since 04/04/2025
@param jData, json, dados do parâmetro a ser adicionado na lista do query param
/*/
/*method setParams(jData as json) class ChatAuditApiAudit

	local aDetails := {} as array

	if !empty(jData["value"])
	
			if jData["type"] == "character"
				if valType(jData["value"]) == "C"
					jData["value"] := alltrim(jData["value"])
				endif
			endif
		
		aAdd(self:aParams, {"key": jData["key"], "value": jData["value"]})
	else
		if jData["required"]
			aAdd(aDetails, {"code": "400.001", "message": "O campo " + jData["key"] + " é obrigatório.", "detailedMessage": iif(jData:hasProperty("errorDetailedMessage"), jData["errorDetailedMessage"], "")}) // "O campo ";" é obrigatório."
			self:setError("400.001","Existem campos obrigatórios que não foram preenchidos.","Verifique a lista de erros para mais detalhes.",aDetails)
		endif
	endif

return*/

/*/{Protheus.doc} setAttribute
Defini os campos a ser adicionado no body para comunicar com o chataudit.
@type method
@version 12.1.2410
@author jose.paulo
@since 04/04/2025
@param jData, json, dados do campo a ser adicionado body da requisição
/*/
method setAttribute(jData as json) class ChatAuditApiAudit

	local lEmpty as logical
	local aDetails := {} as array

	lEmpty := ((valtype(jData["value"]) <> "L" .and. empty(jData["value"])) .or. (jData["type"] == "logical" .and. valtype(jData["value"]) <> "L" ))

	if !empty(jData["value"])

		/*if jData:hasProperty("specialChar") .and. jData["specialChar"]
			if valType(jData["value"]) == "C"
				jData["value"] := self:removeSpecialChar(jData["value"])
			endif
		endif*/

		do case
			/*case jData["type"] == "numeric"
				if valType(jData["value"]) == "C"
					jData["value"] := val(jData["value"])
				endif*/

			case jData["type"] == "character"
				if valType(jData["value"]) == "C"
					/*if jData:hasProperty("size")
						jData["value"] := padr(jData["value"], jData["size"])
					endif*/

					jData["value"] := alltrim(jData["value"])
				endif

			case jData["type"] == "uf" // Unidade Federativa - Formato XX, onde XX pertence ao domínio {RS,SC,PR,SP,MG,RJ,ES,MS,MT,GO,TO,PA,AM,RO,RR,AC,DF,BA,SE,CE,PI,PB,RN,AL,MA,PE,AP}
				jData["value"] := getCodeUF(jData["value"])
		endcase
	endif

	// Mandatório (Obrigatório envio da informação)
	if jData["required"] .and. lEmpty
		aAdd(aDetails, {"code": "400.001", "message": "O campo " + jData["attribute"] + " é obrigatório.", "detailedMessage": iif(jData:hasProperty("errorDetailedMessage"), jData["errorDetailedMessage"], "")}) // "O campo ";" é obrigatório." 
		self:setError("400.001","Existem campos obrigatórios que não foram preenchidos.","Verifique a lista de erros para mais detalhes.",aDetails)
	else
		if !lEmpty
			jData["body"][jData["attribute"]] := jData["value"]
		else
			if !jData["required"]
				jData["body"][jData["attribute"]] := nil
			endif
		endif
	endif

	fwFreeArray(aDetails)

return

/*/{Protheus.doc} getStatusCodeMessage
Obter a mensagem de acordo com o status code
@type method
@version 12.1.2410
@author jose.paulo
@since 04/04/2025
@return character, mensagem do status code
/*/
method getStatusCodeMessage(cStatusCode as character, cOperation as character) as character class ChatAuditApiAudit

	local cMessage := "" as character
	local jStatusCodeMessage := JsonObject():new() as json

	jStatusCodeMessage["200"] := "Chat atualizado com sucesso."
	jStatusCodeMessage["201"] := "Mensagem enviada com sucesso."
	jStatusCodeMessage["400"] := "A requisição foi malformada, omitindo atributos necessários, seja no payload ou através de atributos no header, ou na URL."
	jStatusCodeMessage["401"] := "Cabeçalho de autenticação ausente/inválido ou token inválido."
	jStatusCodeMessage["403"] := "Acesso negado para este ambiente."
	jStatusCodeMessage["405"] := "O consumidor tentou acessar o recurso com um método que não existe."
	jStatusCodeMessage["422"] := "Erro de negócio."
	jStatusCodeMessage["429"] := "A operação foi recusada, por exceder o limite de chamadas feitas dentro de um determinado período ou o limite de requisições concorrentes foi atingido."
	jStatusCodeMessage["500"] := "Erro do servidor, ocorreu um erro no gateway da API ou no microsserviço."
	jStatusCodeMessage["504"] := "A requisição não foi atendida dentro do tempo limite estabelecido, gateway time out."

	if jStatusCodeMessage:hasProperty(cStatusCode)
		cMessage := jStatusCodeMessage[cStatusCode]
	endif

return cMessage

/*/{Protheus.doc} getCodeUF
Obter o código do estado de acordo com o UF
@type function
@version 12.1.2410  
@author jose.paulo
@since 04/04/2025
@param cUF, character, sigla do estado (UF)
@return character, código do estado
/*/
static function getCodeUF(cUF as character) as character

	local jCodes := JsonObject():new() as json
	local cCodeUF := "" as character

	jCodes["RO"] := "11"
	jCodes["AC"] := "12"
	jCodes["AM"] := "13"
	jCodes["RR"] := "14"
	jCodes["PA"] := "15"
	jCodes["AP"] := "16"
	jCodes["TO"] := "17"
	jCodes["MA"] := "21"
	jCodes["PI"] := "22"
	jCodes["CE"] := "23"
	jCodes["RN"] := "24"
	jCodes["PB"] := "25"
	jCodes["PE"] := "26"
	jCodes["AL"] := "27"
	jCodes["SE"] := "28"
	jCodes["BA"] := "29"
	jCodes["MG"] := "31"
	jCodes["ES"] := "32"
	jCodes["RJ"] := "33"
	jCodes["SP"] := "35"
	jCodes["PR"] := "41"
	jCodes["SC"] := "42"
	jCodes["RS"] := "43"
	jCodes["MS"] := "50"
	jCodes["MT"] := "51"
	jCodes["GO"] := "52"
	jCodes["DF"] := "53"
	jCodes["EX"] := "98"

	if jCodes:hasProperty(cUF)
		cCodeUF := jCodes[cUF]
	endif

return Val(cCodeUF)

method setFormData(aKeys as array) as logical class ChatAuditApiAudit

    local nCount as numeric
    local nSizeArray as numeric

    nSizeArray := len(aKeys)

    self:cBody := ""
    

    for nCount := 1 to nSizeArray

        self:cBody += 'Content-Disposition: form-data; name="' + aKeys[nCount]["key"] + '"'
        

        if aKeys[nCount]:hasProperty("fileName")
            self:cBody += '; filename="' +  aKeys[nCount]["fileName"] + '"'
        endif

        if aKeys[nCount]:hasProperty("contentType")
            self:cBody += CRLF + 'Content-Type: ' + aKeys[nCount]["contentType"]
        endif

        self:cBody += CRLF + CRLF + aKeys[nCount]["value"]

        self:cBody += CRLF

        if nCount == nSizeArray
            self:cBody += CRLF
        endif
    next nCount

return .T.

Function PlsAneBC(cIdHistory) 
	Local cQuery      := "" As Character
	Local cAliasQuery := "" As Character
	Local oFile       := NIL As Object
	Local cDirDocs    := lower(Alltrim(MsDocPath())) + "\" As Character	
	Local cFile       := "" As Character
	Local aArquiv     := {} As Array

	cQuery := "SELECT ACB.ACB_OBJETO ANEXO "
	cQuery += "FROM " + RetSqlName("AC9") + " AC9 "
	cQuery += "INNER JOIN " + RetSqlName("ACB") + " ACB ON ACB.ACB_FILIAL = AC9.AC9_FILIAL "
	cQuery += "AND ACB.ACB_CODOBJ = AC9.AC9_CODOBJ "
	cQuery += "AND ACB.D_E_L_E_T_ = '' "
	cQuery += "WHERE AC9.AC9_FILIAL = '" + xFilial("AC9") + "' "
	cQuery += 	"AND AC9.AC9_ENTIDA = 'BIU' "
	cQuery += 	"AND AC9.AC9_CODENT = '" + cIdHistory + "' "
	cQuery += 	"AND AC9.D_E_L_E_T_ = '' "

	cAliasQuery := MpSysOpenQuery(changeQuery(cQuery))

	While (cAliasQuery)->(!Eof())

		oFile := FwFileReader():New(cDirDocs + (cAliasQuery)->ANEXO)

		If (oFile:Open())
			cFile := oFile:FullRead()
			aadd(aArquiv,{cFile,cDirDocs,(cAliasQuery)->ANEXO} )
		Endif

		oFile:Close()
		(cAliasQuery)->(DbSkip())
	End Do

	(cAliasQuery)->(DbCloseArea())

Return aArquiv
