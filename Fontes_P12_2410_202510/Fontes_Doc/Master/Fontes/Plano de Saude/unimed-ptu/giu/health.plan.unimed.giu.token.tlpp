#include "tlpp-core.th"

namespace totvs.protheus.health.plan.unimed

using namespace totvs.protheus.health.plan.api.util

/*/{Protheus.doc} TokenGIU
Autenticação – Obter token a partir de login e senha

@type method
@version 12.1.2410
@author vinicius.queiros
@since 09/01/2024
/*/
class TokenGIU

    private data cBearer as character
    private data cCookie as character
    private data cResponseBody as character
    private data cResponseCookie as character
    private data cErrorMessage as character
    private data lCache as logical
    private data lRobotTest as logical
    private data cHealthInsurerCode as character

    public method new(cHealthInsurerCode) constructor
    public method setRobotTest(cResponseBody as character, cResponseCookie as character) as logical
    public method getToken() as logical
    public method disableCache() as logical

    public method getCookie() as character
    public method getBearer() as character
    public method getErrorMessage() as character

    private method setResponse(cBody as character, cCookie as character) as logical
    private method formatCookie(cCookie as character) as character

endclass

/*/{Protheus.doc} new
Método construtor da classe

@type method
@version 12.1.2410
@author vinicius.queiros
@since 09/01/2024
@param cHealthInsurerCode, character, codigo da operadora que contém as configurações (BA0)
@return object, classe TokenGIU
/*/
method new(cHealthInsurerCode as character) class TokenGIU

    default cHealthInsurerCode := plsIntPad()

    self:cHealthInsurerCode := cHealthInsurerCode

    self:lCache := .t.

return self

/*/{Protheus.doc} setRobotTest
Defini que o retorno da comunicação é pelo robô de testes

@type method
@version 12.1.2410  
@author vinicius.queiros
@return logical, sucesso ao definir os dados
@since 15/01/2024
/*/
method setRobotTest(cResponseBody as character, cResponseCookie as character) as logical class TokenGIU

    self:cResponseBody := cResponseBody
    self:cResponseCookie := cResponseCookie

    self:lRobotTest := .t.

return self:lRobotTest

/*/{Protheus.doc} getToken
Fornecer token de autenticação a partir de usuário e senha. Este serviço poderá ser 
utilizado para realizar a autenticação de usuário ou a autenticação de Conta 
de Serviço/ Aplicação.

@type method
@version 12.1.2410  
@author vinicius.queiros
@since 09/01/2024
@return logical, se houve sucesso ao obter o token 
/*/
method getToken() as logical class TokenGIU

    local lNewToken := .t. as logical
    local dTokenDate as date
    local nTokenSeconds as numeric
    local aExpiresIn as array
    local jBody as json
    local lSuccess := .f. as logical
    local oRestClient as object
    local aHeaderParams := {} as array
    
    if !empty(self:cHealthInsurerCode)
        BA0->(dbSetOrder(1))
        if BA0->(msSeek(xFilial("BA0")+self:cHealthInsurerCode))
            aExpiresIn := strTokArr(alltrim(BA0->BA0_TMPGIU), "|")

            if len(aExpiresIn) >= 2
                dTokenDate := stod(aExpiresIn[1])
                nTokenSeconds := val(aExpiresIn[2])

                if dTokenDate == dDataBase .And. seconds() < nTokenSeconds
                    lNewToken := .f.
                EndIf
            endif

            if lNewToken .or. !self:lCache
                oRestClient := RestClient():new()
                jBody := {"grant_type": "password",;
                          "username": alltrim(BA0->BA0_USRGIU),;
                          "password": alltrim(BA0->BA0_PASGIU)}
                
                aAdd(aHeaderParams, {"key": "Content-Type", "value": "application/json"})

                oRestClient:setBody(jBody:toJson())
                oRestClient:setHeaderParams(aHeaderParams)
                oRestClient:setEndpoint(alltrim(BA0->BA0_ENDGIU))

                if self:lRobotTest
                    oRestClient:setRobotTest(self:cResponseBody, self:cResponseCookie)
                endif

                if oRestClient:post()
                    lSuccess := self:setResponse(oRestClient:getBody(), oRestClient:getCookie())
                else
                    lSuccess := .f.
                    self:cErrorMessage := oRestClient:getErrorMessage()
                endif

                oRestClient:destroy()
            else
                self:cCookie := alltrim(BA0->BA0_COOGIU)
                self:cBearer := alltrim(BA0->BA0_BEAGIU)
                lSuccess := .t.
            endif
        else
            lSuccess := .f.
            self:cErrorMessage := "Operadora de saúde não encontrada no cadastro." 
        endif
    else
        lSuccess := .f.
        self:cErrorMessage := "Código da operadora de saúde não informado"     
    endif

    freeObj(jBody)
    freeObj(oRestClient)

    fwFreeArray(aExpiresIn)
    fwFreeArray(aHeaderParams)

return lSuccess

/*/{Protheus.doc} getCookie
Obter cookie: X-CSRF-TOKEN gerado no GIU ao autenticar a Conta de Serviço

@type method
@version 12.1.2410  
@author vinicius.queiros
@since 09/01/2024
@return character, cookie gerado
/*/
method getCookie() as character class TokenGIU

return self:cCookie

/*/{Protheus.doc} getBearer
Obter authorization: token do tipo bearer gerado no GIU ao autenticar a Conta de Serviço

@type method
@version 12.1.2410  
@author vinicius.queiros
@since 09/01/2024
@return character, bearer gerado
/*/
method getBearer() as character class TokenGIU

return self:cBearer

/*/{Protheus.doc} disableCache
Desabilita cache para a busca do token, ao desabilitar sempre será feita uma requisição
na api da unimed.

@type method
@version 12.1.2410  
@author vinicius.queiros
@since 10/01/2024
/*/
method disableCache() as logical class TokenGIU

    self:lCache := .f.

return .t.

/*/{Protheus.doc} getErrorMessage
Obter messagem de error 

@type method
@version 12.1.2410  
@author vinicius.queiros
@since 10/01/2024
@return character, messagem de erro
/*/
method getErrorMessage() as character class TokenGIU

return self:cErrorMessage

/*/{Protheus.doc} getToken
Defini a resposta do token para obter o bearer e o cookie

@type method
@version 12.1.2410  
@author vinicius.queiros
@since 09/01/2024
@param cBody, character, Body (json) da resposta da api
@param cCookie, character, Cookie da resposta da api
@return logical, se houve sucesso ao obter o token 
/*/
method setResponse(cBody as character, cCookie as character) as logical class TokenGIU

    local jResponse := JsonObject():new() as json
    local lSuccess := .f. as logical
    local nExpireTime as numeric
    local cExpireDate as character

    jResponse:fromJson(cBody)

    if jResponse:hasProperty("access_token")
        self:cBearer := alltrim(jResponse["access_token"])
        self:cCookie := alltrim(self:formatCookie(cCookie))

        if !empty(self:cBearer) .and. !empty(self:cCookie)
            nExpireTime := noRound(seconds(), 0) + (jResponse["expires_in"] - 100)
            cExpireDate := dtos(dDataBase)

            BA0->(recLock("BA0", .f.))
                BA0->BA0_BEAGIU := self:cBearer
                BA0->BA0_COOGIU := self:cCookie
                BA0->BA0_TMPGIU := cExpireDate+"|"+cValtoChar(nExpireTime)
            BA0->(msUnLock())

            lSuccess := .t.
        endif
    endif

    freeObj(jResponse)

Return lSuccess

/*/{Protheus.doc} formatCookie
obtem o formato correto do cookie para ser utilizado na autenticação

@type method
@version 12.1.2410  
@author vinicius.queiros
@since 09/01/2024
@param cCookie, character, cookie a ser formatado
@return character, cookie no formato correto 
/*/
method formatCookie(cCookie as character) as character class TokenGIU

    local cCookieFormat := "" as character
    local aCookie as array

    if !empty(cCookie)
        aCookie := strTokArr(cCookie, ";")

        if len(aCookie) >= 4
            cCookieFormat := aCookie[1]+";"+;
                             " Path=/api"+";"+;
                             aCookie[2]+";"+;
                             aCookie[3]+";"+;
                             aCookie[4]+";"
        endif 
    endif

    fwFreeArray(aCookie)

return cCookieFormat
