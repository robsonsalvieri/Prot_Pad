
#include "tlpp-core.th"
#include "fwmvcdef.ch"
#include "health.plan.unimed.cadbenef.create.ch"

#define ACTIVE_REGISTRATION "1" // Cadastro ativo 
#define FULL_REGISTRATION "2" // Cadastro completo
#define PERIODIC_MOTION "3" // Mov. Periódica
#define DELETION_ONLY "4" // Somente exclusão

#define PENDING_SEND "1" // Pendente de envio
#define SEND_COMPLETED "2" // Envio finalizado
#define SEND_ERROR "3" // Erro de envio

#define INCLUSION_TYPE "1" // Inclusão
#define UPDATE_TYPE "2" // Atualização
#define EXCLUSION_TYPE "3" // Exclusão

namespace totvs.protheus.health.plan.unimed

/*/{Protheus.doc} cadBenefBatchAddBeneficiaries
Adiciona os beneficiários no lote de acordo com os campos informados na criação do lote
@type function
@version 12.1.2410
@author vinicius.queiros
@since 5/21/2024
@param jParameters, json, parâmetros com os campos da criação do lote para filtro
@return numeric, quantidade de beneficiários incluido no lote
/*/
function cadBenefBatchAddBeneficiaries(jParameters as json) as numeric

    local oExecStmt as object
    local cAlias as character
    local aAreaBPW := BPW->(getArea()) as array
    local cFilialBPY := xFilial("BPY") as character
    local oModel as object
    local nQtdAddTotal := 0 as numeric
    
    oExecStmt := getQueryBeneficiaries(jParameters, .F.)

    cAlias := oExecStmt:openAlias()

    BPY->(dbSetOrder(1))
    if !(cAlias)->(eof())
        BA1->(dbSetOrder(2))

        while !(cAlias)->(eof())
            if !BPY->(msSeek(cFilialBPY + jParameters["batchCode"] + (cAlias)->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)))  
                if BA1->(msSeek(xFilial("BA1") + (cAlias)->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)))
                    oModel := fwLoadModel("PLPTU002")

                    oModel:setOperation(MODEL_OPERATION_INSERT)
                    oModel:activate()
                    oModel:setValue("BPYMASTER", "BPY_CODLOT", jParameters["batchCode"])
                    oModel:setValue("BPYMASTER", "BPY_CODINT", BA1->BA1_CODINT)
                    oModel:setValue("BPYMASTER", "BPY_CODEMP", BA1->BA1_CODEMP)
                    oModel:setValue("BPYMASTER", "BPY_MATRIC", BA1->BA1_MATRIC)
                    oModel:setValue("BPYMASTER", "BPY_TIPREG", BA1->BA1_TIPREG)
                    oModel:setValue("BPYMASTER", "BPY_DIGITO", BA1->BA1_DIGITO)
                    oModel:setValue("BPYMASTER", "BPY_STATUS", PENDING_SEND)
                    oModel:setValue("BPYMASTER", "BPY_TIPMOV", getMovementType())

                    if oModel:vldData()
                        oModel:commitData()
                        nQtdAddTotal++
                    endif

                    oModel:deActivate()
                    oModel:destroy()
                    freeObj(oModel)
                endif
            endif
            
            (cAlias)->(dbskip())
        enddo    
    endif

    (cAlias)->(dbCloseArea())

    restArea(aAreaBPW)

	freeObj(oExecStmt)
    fwFreeArray(aAreaBPW)

return nQtdAddTotal

/*/{Protheus.doc} cadBenefBatchHasBeneficiaries
Antes de criar o lote, verifica se possui algum beneficiário para os campos informados na criação.
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 5/21/2024
@param jParameters, json, parâmetros com os campos da criação do lote para filtro
@return logical, se possui algum beneficiário a ser incluido de acordo com o filtro
/*/
function cadBenefBatchHasBeneficiaries(jParameters as json)

    local oExecStmt as object
    local lHasBeneficiaries := .F. as logical
    
    oExecStmt := getQueryBeneficiaries(jParameters, .T.)

    if oExecStmt:execScalar("TOTAL") > 0
        lHasBeneficiaries := .T.
    endif

    freeObj(oExecStmt)

return lHasBeneficiaries

/*/{Protheus.doc} cadBenefBatchDeleteBeneficiaries
Realiza a exclusão dos beneficiários do lote
@type function
@version 12.1.2410  
@author vinicius.queiros
@since 21/05/2024
@param jParameters, json, parâmetro com os dados do lote
/*/
function cadBenefBatchDeleteBeneficiaries(jParameters as json)

    local aAreaBPW := BPW->(getArea()) as array
    local cFilialBPY := xFilial("BPY") as character
    local oModel as object

    BPY->(dbSetOrder(1))
    if BPY->(msSeek(cFilialBPY + jParameters["batchCode"]))  
        while !BPY->(eof()) .and. cFilialBPY + jParameters["batchCode"] == BPY->(BPY_FILIAL + BPY_CODLOT)   
            oModel := fwLoadModel("PLPTU002")

            oModel:setOperation(MODEL_OPERATION_DELETE)
            oModel:activate()

            if oModel:vldData()
                oModel:commitData()
            endif

            oModel:deActivate()
            oModel:destroy()
            freeObj(oModel)
              
            BPY->(dbskip())
        enddo
    endif

    restArea(aAreaBPW)

    fwFreeArray(aAreaBPW)

return

/*/{Protheus.doc} getQueryBeneficiaries
Obter a query com os beneficiários a serem incluidos no lote do CadBenef
@type function
@version 12.1.2410  
@author vinicius.queiros
@since 21/05/2024
@param jParameters, json, parâmetro com os campos do lote
@param lCount, logical, se o processo é somente para contar a quantidade de beneficiários (COUNT)
@return object, objeto da instância da classe FwExecStatement
/*/
static function getQueryBeneficiaries(jParameters as json, lCount as logical) as object

    local oExecStmt as object
    local cQuery as character
    local nOrder := 1 as numeric
	local lIsPeriodicMotion := jParameters["movementType"] == PERIODIC_MOTION as logical
	local cChangeFields := superGetMV("MV_PTC1300", .F., "BA1_DATNAS;BA1_SEXO;BA1_CPFUSR;BA1_NOMUSR;BA1_MAE;BA1_TIPUSU;BA1_ENDERE;BA1_CEPUSR;BA1_MUNICI;BA1_ESTADO") as character
	
	if !lIsPeriodicMotion
		cQuery := " SELECT ? "
		cQuery += " FROM ? BA1 "
		cQuery += " WHERE "
		cQuery += getWhereFilterBeneficiaries(jParameters)

		do case
			case jParameters["movementType"] == ACTIVE_REGISTRATION // Cadastro de ativos
				cQuery += " BA1.BA1_DATINC >= ? AND "
				cQuery += " BA1.BA1_DATINC <= ? AND "
				cQuery += " BA1.BA1_MOTBLO = ? AND "

			case jParameters["movementType"] == FULL_REGISTRATION // Cadastro completo
				cQuery += " BA1.BA1_DATINC >= ? AND "
				cQuery += " BA1.BA1_DATINC <= ? AND "
				
			case jParameters["movementType"] == DELETION_ONLY // Somente exclusão
				cQuery += " BA1.BA1_DATBLO >= ? AND "
				cQuery += " BA1.BA1_DATBLO <= ? AND "
				cQuery += " BA1.BA1_MOTBLO <> ? AND "
				cQuery += " BA1.BA1_CODUBR <> ? AND "
		endcase

		cQuery += " BA1.D_E_L_E_T_ = ? "
	else
		// Movimentação periodica
		cQuery := " SELECT ? "
		cQuery += " FROM ( "
		// Movimentação de inclusão do plano
		cQuery += " 	SELECT ? "
		cQuery += " 	FROM ? BA1 "
		cQuery += " 	WHERE " + getWhereFilterBeneficiaries(jParameters)
		cQuery += " 		BA1.BA1_DATINC >= ? AND BA1.BA1_DATINC <= ? AND "
		cQuery += " 		NOT EXISTS (" + getQueryNotExists("BPY.BPY_DATENV > BA1.BA1_DATINC") + ") AND "
		cQuery += " 		BA1.D_E_L_E_T_ = ? "

		cQuery += "		UNION "

		// Movimentação de repasse 
		cQuery += " 	SELECT ? "
		cQuery += " 	FROM ? BA1 "
		cQuery += " 	WHERE " + getWhereFilterBeneficiaries(jParameters)
		cQuery += " 		BA1.BA1_DATREP >= ? AND BA1.BA1_DATREP <= ? AND BA1.BA1_DATREP <> ? AND "
		cQuery += " 		NOT EXISTS (" + getQueryNotExists("BPY.BPY_DATENV > BA1.BA1_DATREP") + ") AND "
		cQuery += " 		BA1.D_E_L_E_T_ = ? "

		cQuery += "		UNION "

		// Movimentação de bloqueio
		cQuery += " 	SELECT ? "
		cQuery += " 	FROM ? BA1 "
		cQuery += " 	WHERE " + getWhereFilterBeneficiaries(jParameters)
		cQuery += " 		BA1.BA1_DATBLO >= ? AND BA1.BA1_DATBLO <= ? AND BA1.BA1_DATBLO <> ? AND BA1.BA1_CODUBR <> ? AND "
		cQuery += " 		NOT EXISTS (" + getQueryNotExists("BPY.BPY_DATENV > BA1.BA1_DATBLO") + ") AND "
		cQuery += " 		BA1.D_E_L_E_T_ = ? "

		cQuery += "		UNION "

		// Movimentação de alteração do cadastro
		cQuery += " 	SELECT ? "
		cQuery += " 	FROM ? BA1 "
		cQuery += " 	INNER JOIN ? BX1 ON "
		cQuery += " 		BX1.BX1_FILIAL = ? AND "
		cQuery += " 		BX1.BX1_ALIAS = ? AND "
		cQuery += " 		CAST(BX1.BX1_RECNO AS INT) = BA1.R_E_C_N_O_ AND "
		cQuery += "     	BX1.BX1_TIPO = ? AND "
		cQuery += "     	BX1.BX1_DATA >= ? AND "
		cQuery += "     	BX1.BX1_DATA <= ? AND "
		cQuery += " 		NOT EXISTS (" + getQueryNotExists("(BPY.BPY_DATENV > BX1.BX1_DATA OR (BPY.BPY_DATENV = BX1.BX1_DATA AND BPY.BPY_HORENV > BX1.BX1_HORA))") + ") AND "
		cQuery += "			BX1.D_E_L_E_T_ = ? "
		cQuery += " 	INNER JOIN ? BX2 ON "
		cQuery += " 		BX2.BX2_FILIAL = ? AND "
		cQuery += " 		BX2.BX2_SEQUEN = BX1.BX1_SEQUEN AND "
		cQuery += " 		BX2.BX2_CAMPO IN (?) AND "
		cQuery += "			BX2.D_E_L_E_T_ = ? "
		cQuery += "		WHERE " + getWhereFilterBeneficiaries(jParameters)
		cQuery += " 		BA1.BA1_CODUBR <> ? AND "
		cQuery += " 		(BA1.BA1_DATBLO = ? OR BA1.BA1_DATBLO > ?) AND "
		cQuery += "			BA1.D_E_L_E_T_ = ? "

		cQuery += "		UNION "

		// Movimentação de inclusão retroativa do cadastro
		cQuery += " 	SELECT ? "
		cQuery += " 	FROM ? BA1 "
		cQuery += " 	INNER JOIN ? BX1 ON "
		cQuery += " 		BX1.BX1_FILIAL = ? AND "
		cQuery += " 		BX1.BX1_ALIAS = ? AND "
		cQuery += " 		CAST(BX1.BX1_RECNO AS INT) = BA1.R_E_C_N_O_ AND "
		cQuery += "     	BX1.BX1_TIPO = ? AND "
		cQuery += "     	BX1.BX1_DATA >= ? AND "
		cQuery += "     	BX1.BX1_DATA <= ? AND "
		cQuery += " 		NOT EXISTS (" + getQueryNotExists("(BPY.BPY_DATENV > BX1.BX1_DATA OR (BPY.BPY_DATENV = BX1.BX1_DATA AND BPY.BPY_HORENV > BX1.BX1_HORA))") + ") AND "
		cQuery += "			BX1.D_E_L_E_T_ = ? "
		cQuery += "		WHERE " + getWhereFilterBeneficiaries(jParameters)
		cQuery += " 		BA1.BA1_CODUBR = ? AND "
		cQuery += "			BA1.D_E_L_E_T_ = ? "
		
		cQuery += "		UNION "

		// Movimentação de via da carteirinha
		cQuery += " 	SELECT ? "
		cQuery += " 	FROM ? BA1 "
		cQuery += " 	INNER JOIN ? BED ON "
		cQuery += " 		BED.BED_FILIAL = ? AND "
		cQuery += "     	BED.BED_CODINT = BA1.BA1_CODINT AND "
		cQuery += "     	BED.BED_CODEMP = BA1.BA1_CODEMP AND "
		cQuery += "     	BED.BED_MATRIC = BA1.BA1_MATRIC AND "
		cQuery += "     	BED.BED_TIPREG = BA1.BA1_TIPREG AND "
		cQuery += "     	BED.BED_DIGITO = BA1.BA1_DIGITO AND "
		cQuery += "     	BED.BED_DTSOLI >= ? AND "
		cQuery += "     	BED.BED_DTSOLI <= ? AND "
		cQuery += " 		NOT EXISTS (" + getQueryNotExists("BPY.BPY_DATENV > BED.BED_DTSOLI") + ") AND "
		cQuery += "			BED.D_E_L_E_T_ = ? "
		cQuery += "		WHERE " + getWhereFilterBeneficiaries(jParameters)
		cQuery += "			BA1.D_E_L_E_T_ = ? "

		cQuery += "	UNION "

		// Movimentações de desbloqueios
		cQuery += " 	SELECT ? "
		cQuery += " 	FROM ? BA1 "
		cQuery += " 	INNER JOIN ? BCA ON "
		cQuery += " 		BCA.BCA_FILIAL = ? AND "
		cQuery += "     	BCA.BCA_MATRIC = BA1.BA1_CODINT || BA1.BA1_CODEMP || BA1.BA1_MATRIC AND "
		cQuery += "         BCA.BCA_TIPREG = BA1.BA1_TIPREG AND "
		cQuery += "        	BCA.BCA_TIPO = ? AND "
		cQuery += "         BCA.BCA_DATLAN >= ? AND "
		cQuery += "         BCA.BCA_DATLAN <= ? AND "
		cQuery += " 		NOT EXISTS (" + getQueryNotExists("(BPY.BPY_DATENV > BCA.BCA_DATLAN OR (BPY.BPY_DATENV = BCA.BCA_DATLAN AND BPY.BPY_HORENV > BCA.BCA_HORLAN ))") + ") AND "
		cQuery += "			BCA.D_E_L_E_T_ = ? "
		cQuery += "		WHERE " + getWhereFilterBeneficiaries(jParameters)
		cQuery += "			BA1.D_E_L_E_T_ = ? "
		cQuery += " ) TAB "
	endif

    if !lCount
        cQuery += " ORDER BY ? "
    endif

    cQuery := changeQuery(cQuery)
    oExecStmt := FwExecStatement():new(cQuery)

	if !lIsPeriodicMotion
		if lCount
        	oExecStmt:setUnsafe(nOrder++, "COUNT(BA1.BA1_MATRIC) TOTAL ")
		else
			oExecStmt:setUnsafe(nOrder++, "BA1.BA1_CODINT, BA1.BA1_CODEMP, BA1.BA1_MATRIC, BA1.BA1_TIPREG, BA1.BA1_DIGITO")
		endif

		oExecStmt:setUnsafe(nOrder++, retSqlName("BA1"))
		oExecStmt := setWhereFilterBeneficiaries(oExecStmt, @nOrder, jParameters)

		do case
			case jParameters["movementType"] == ACTIVE_REGISTRATION // Cadastro de ativos
				oExecStmt:setDate(nOrder++, jParameters["dateFrom"])
				oExecStmt:setDate(nOrder++, jParameters["dateTo"])
				oExecStmt:setString(nOrder++, " ")

			case jParameters["movementType"] == FULL_REGISTRATION // Cadastro completo
				oExecStmt:setDate(nOrder++, jParameters["dateFrom"])
				oExecStmt:setDate(nOrder++, jParameters["dateTo"])
		
			case jParameters["movementType"] == DELETION_ONLY // Somente exclusão
				oExecStmt:setDate(nOrder++, jParameters["dateFrom"])
				oExecStmt:setDate(nOrder++, jParameters["dateTo"])
				oExecStmt:setString(nOrder++, " ")
				oExecStmt:setString(nOrder++, " ")
		endcase

		oExecStmt:setString(nOrder++, " ")
	else
		if lCount
        	oExecStmt:setUnsafe(nOrder++, "COUNT(TAB.BA1_MATRIC) TOTAL ")
		else
			oExecStmt:setUnsafe(nOrder++, "TAB.BA1_CODINT, TAB.BA1_CODEMP, TAB.BA1_MATRIC, TAB.BA1_TIPREG, TAB.BA1_DIGITO")
		endif

		// Movimentação de inclusão do plano
		oExecStmt:setUnsafe(nOrder++, "BA1.BA1_CODINT, BA1.BA1_CODEMP, BA1.BA1_MATRIC, BA1.BA1_TIPREG, BA1.BA1_DIGITO")
		oExecStmt:setUnsafe(nOrder++, retSqlName("BA1"))
		oExecStmt := setWhereFilterBeneficiaries(oExecStmt, @nOrder, jParameters)
		oExecStmt:setDate(nOrder++, jParameters["dateFrom"])
        oExecStmt:setDate(nOrder++, jParameters["dateTo"])
		oExecStmt := setQueryNotExists(oExecStmt, @nOrder)
		oExecStmt:setString(nOrder++, " ")

		// Movimentação de repasse 
		oExecStmt:setUnsafe(nOrder++, "BA1.BA1_CODINT, BA1.BA1_CODEMP, BA1.BA1_MATRIC, BA1.BA1_TIPREG, BA1.BA1_DIGITO")
		oExecStmt:setUnsafe(nOrder++, retSqlName("BA1"))
		oExecStmt := setWhereFilterBeneficiaries(oExecStmt, @nOrder, jParameters)
		oExecStmt:setDate(nOrder++, jParameters["dateFrom"])
        oExecStmt:setDate(nOrder++, jParameters["dateTo"])
		oExecStmt:setString(nOrder++, " ")
		oExecStmt := setQueryNotExists(oExecStmt, @nOrder)
		oExecStmt:setString(nOrder++, " ")

		// Movimentação de bloqueio
		oExecStmt:setUnsafe(nOrder++, "BA1.BA1_CODINT, BA1.BA1_CODEMP, BA1.BA1_MATRIC, BA1.BA1_TIPREG, BA1.BA1_DIGITO")
		oExecStmt:setUnsafe(nOrder++, retSqlName("BA1"))
		oExecStmt := setWhereFilterBeneficiaries(oExecStmt, @nOrder, jParameters)
		oExecStmt:setDate(nOrder++, jParameters["dateFrom"])
        oExecStmt:setDate(nOrder++, jParameters["dateTo"])
		oExecStmt:setString(nOrder++, " ")
		oExecStmt:setString(nOrder++, " ")
		oExecStmt := setQueryNotExists(oExecStmt, @nOrder)
		oExecStmt:setString(nOrder++, " ")

		// Movimentação de alteração do cadastro
		oExecStmt:setUnsafe(nOrder++, "BA1.BA1_CODINT, BA1.BA1_CODEMP, BA1.BA1_MATRIC, BA1.BA1_TIPREG, BA1.BA1_DIGITO")
		oExecStmt:setUnsafe(nOrder++, retSqlName("BA1"))
		oExecStmt:setUnsafe(nOrder++, retSqlName("BX1"))
		oExecStmt:setString(nOrder++, xFilial("BX1"))
		oExecStmt:setString(nOrder++, "BA1")
		oExecStmt:setString(nOrder++, "A") // Alteração
		oExecStmt:setDate(nOrder++, jParameters["dateFrom"])
		oExecStmt:setDate(nOrder++, jParameters["dateTo"])
		oExecStmt := setQueryNotExists(oExecStmt, @nOrder)
		oExecStmt:setString(nOrder++, " ")
		oExecStmt:setUnsafe(nOrder++, retSqlName("BX2"))
		oExecStmt:setString(nOrder++, xFilial("BX2"))
		oExecStmt:setUnsafe(nOrder++, breakSqlFields(cChangeFields, ";"))
		oExecStmt:setString(nOrder++, " ")
		oExecStmt := setWhereFilterBeneficiaries(oExecStmt, @nOrder, jParameters)
		oExecStmt:setString(nOrder++, " ")
		oExecStmt:setString(nOrder++, " ")
		oExecStmt:setDate(nOrder++, dDataBase)
		oExecStmt:setString(nOrder++, " ")

		// Movimentação de inclusão retroativa do cadastro
		oExecStmt:setUnsafe(nOrder++, "BA1.BA1_CODINT, BA1.BA1_CODEMP, BA1.BA1_MATRIC, BA1.BA1_TIPREG, BA1.BA1_DIGITO")
		oExecStmt:setUnsafe(nOrder++, retSqlName("BA1"))
		oExecStmt:setUnsafe(nOrder++, retSqlName("BX1"))
		oExecStmt:setString(nOrder++, xFilial("BX1"))
		oExecStmt:setString(nOrder++, "BA1")
		oExecStmt:setString(nOrder++, "I") // Inclusão
		oExecStmt:setDate(nOrder++, jParameters["dateFrom"])
		oExecStmt:setDate(nOrder++, jParameters["dateTo"])
		oExecStmt := setQueryNotExists(oExecStmt, @nOrder)
		oExecStmt:setString(nOrder++, " ")
		oExecStmt := setWhereFilterBeneficiaries(oExecStmt, @nOrder, jParameters)
		oExecStmt:setString(nOrder++, " ")
		oExecStmt:setString(nOrder++, " ")

		// Movimentação de via da carteirinha
		oExecStmt:setUnsafe(nOrder++, "BA1.BA1_CODINT, BA1.BA1_CODEMP, BA1.BA1_MATRIC, BA1.BA1_TIPREG, BA1.BA1_DIGITO")
		oExecStmt:setUnsafe(nOrder++, retSqlName("BA1"))
		oExecStmt:setUnsafe(nOrder++, retSqlName("BED"))
		oExecStmt:setString(nOrder++, xFilial("BED"))
		oExecStmt:setDate(nOrder++, jParameters["dateFrom"])
        oExecStmt:setDate(nOrder++, jParameters["dateTo"])
		oExecStmt := setQueryNotExists(oExecStmt, @nOrder)
		oExecStmt:setString(nOrder++, " ")
		oExecStmt := setWhereFilterBeneficiaries(oExecStmt, @nOrder, jParameters)
		oExecStmt:setString(nOrder++, " ")

		// Movimentações de desbloqueios
		oExecStmt:setUnsafe(nOrder++, "BA1.BA1_CODINT, BA1.BA1_CODEMP, BA1.BA1_MATRIC, BA1.BA1_TIPREG, BA1.BA1_DIGITO")
		oExecStmt:setUnsafe(nOrder++, retSqlName("BA1"))
		oExecStmt:setUnsafe(nOrder++, retSqlName("BCA"))
		oExecStmt:setString(nOrder++, xFilial("BCA"))
		oExecStmt:setString(nOrder++, "1") // Desbloqueio
		oExecStmt:setDate(nOrder++, jParameters["dateFrom"])
        oExecStmt:setDate(nOrder++, jParameters["dateTo"])
		oExecStmt := setQueryNotExists(oExecStmt, @nOrder)
		oExecStmt:setString(nOrder++, " ")
		oExecStmt := setWhereFilterBeneficiaries(oExecStmt, @nOrder, jParameters)
		oExecStmt:setString(nOrder++, " ")
	endif

    if !lCount
        oExecStmt:setUnsafe(nOrder++, "BA1_CODINT, BA1_CODEMP, BA1_MATRIC, BA1_TIPREG")
    endif

    if existBlock("PTU001QRY")
        oExecStmt := execBlock("PTU001QRY", .F., .F., {oExecStmt, jParameters, lCount})
    endif

return oExecStmt

/*/{Protheus.doc} getMovementType
Obter o tipo de movimentação a ser enviado para o CadBenef, sendo: Inclusão, atualização e exclusão.
@type function
@version 12.1.2410  
@author vinicius.queiros
@since 21/05/2024
@return character, tipo da movimentação
/*/
static function getMovementType() as character

    local cType as character

    cType := INCLUSION_TYPE

    do case
        case !empty(BA1->BA1_MOTBLO) .And. !empty(BA1->BA1_CODUBR)
            cType := EXCLUSION_TYPE
        
        case !empty(BA1->BA1_CODUBR)
            cType := UPDATE_TYPE
    endcase

return cType

/*/{Protheus.doc} cadBenefDeleteBatch
Realiza a chamada da tela para realizar a exclusão do lote
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@param cBatchCode, character, código do lote a ser excluido
/*/
function cadBenefDeleteBatch(cBatchCode as character)

    if getTotalBeneficiariesByStatusCadBenef(cBatchCode, SEND_COMPLETED) > 0
        fwAlertError(STR0001, "") // "Não é permitido excluir lote depois que realizado o envio dos beneficiários."        
    else
        fwExecView(STR0002, "PLPTU001", MODEL_OPERATION_DELETE, nil, {|| .T.}) // "Excluir Lote"
    endif

return

/*/{Protheus.doc} cadBenefDeleteItem
Realiza a chamada da tela para realizar a exclusão do beneficiário do lote
@type function
@version 12.1.2510 
@author giovanna.charlo
@since 15/07/2025
/*/
function cadBenefDeleteItem()

    if BPY->BPY_STATUS == SEND_COMPLETED
        fwAlertError(STR0003, "") // "Não é permitido excluir este beneficiário depois que foi realizado o seu envio."  
    else
        fwExecView(STR0004, "PLPTU002", MODEL_OPERATION_DELETE, nil, {|| .T.}) // "Excluir Beneficiário do Lote"
    endif

return

/*/{Protheus.doc} cadBenefGetBenefNameBrowser
Incializador do browser (X3_INIBRW) do nome do beneficiário
@type function
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@return character, nome do beneficiário
/*/
function cadBenefGetBenefNameBrowser() as character

    local cBeneficiaryName as character

    cBeneficiaryName := posicione("BA1", 2, xFilial("BA1") + BPY->(BPY_CODINT + BPY_CODEMP + BPY_MATRIC + BPY_TIPREG + BPY_DIGITO), "BA1_NOMUSR") 

return cBeneficiaryName

/*/{Protheus.doc} getQueryNotExists
Retorna o trecho da query de NOT EXISTS para beneficiários com lote pendente de envio
@type function
@version 12.1.2510
@author vinicius.queiros
@since 31/10/2024
@param cDateCondition, character, condição da data de envio do beneficiário (BPY_DATENV)
@return character, query dos beneficiários do lote
/*/
static function getQueryNotExists(cDateCondition as character) as character

	local cQuery as character

	cQuery := " SELECT ? "
	cQuery += " FROM ? BPY "
	cQuery += " WHERE BPY.BPY_FILIAL = ? "
	cQuery += "   AND BPY.BPY_CODINT = BA1.BA1_CODINT "
	cQuery += "   AND BPY.BPY_CODEMP = BA1.BA1_CODEMP "
	cQuery += "   AND BPY.BPY_MATRIC = BA1.BA1_MATRIC "
	cQuery += "   AND BPY.BPY_TIPREG = BA1.BA1_TIPREG "
	cQuery += "   AND BPY.BPY_DIGITO = BA1.BA1_DIGITO "
	cQuery += "   AND BPY.D_E_L_E_T_ = ? "
	cQuery += "   AND (BPY.BPY_STATUS IN (?, ?) "
	cQuery += "        OR (BPY.BPY_STATUS = ? AND " + cDateCondition + " ))"
	
return cQuery

/*/{Protheus.doc} getWhereFilterBeneficiaries
Retorna o trecho do where para os beneficiários de acordo com os parametros do lote
@type function
@version 12.1.2510
@author vinicius.queiros
@since 31/10/2024
@param jParameters, json, parâmetro com os campos do lote
@return character, where com as condições de filtro do beneficiário
/*/
static function getWhereFilterBeneficiaries(jParameters as json) as character

	local cWhere as character

	cWhere := " BA1.BA1_FILIAL = ? AND "
	cWhere += " BA1.BA1_CODINT = ? AND "

	if !empty(jParameters["companyCodeFrom"])
		cWhere += " BA1.BA1_CODEMP >= ? AND "
	endif

	if !empty(jParameters["companyCodeTo"])
		cWhere += " BA1.BA1_CODEMP <= ? AND "
	endif

	if !empty(jParameters["contractCodeFrom"])
		cWhere += " BA1.BA1_CONEMP >= ? AND "
	endif

	if !empty(jParameters["contractCodeTo"])
		cWhere += " BA1.BA1_CONEMP <= ? AND "
	endif

	if !empty(jParameters["subcontractCodeFrom"])
		cWhere += " BA1.BA1_SUBCON >= ? AND "
	endif

	if !empty(jParameters["subcontractCodeTo"])
		cWhere += " BA1.BA1_SUBCON <= ? AND "
	endif

	if !empty(jParameters["familyCodeFrom"])
		cWhere += " BA1.BA1_MATRIC >= ? AND "
	endif

	if !empty(jParameters["familyCodeTo"])
		cWhere += " BA1.BA1_MATRIC <= ? AND "
	endif

	cWhere += " BA1.BA1_CODEMP <> ? AND "

	if !empty(jParameters["considerANS"])
		cWhere += " BA1.BA1_INFANS = ? AND "
	endif

	if !empty(jParameters["considerSIB"])
		cWhere += " BA1.BA1_INFSIB = ? AND "
	endif

return cWhere

/*/{Protheus.doc} setWhereFilterBeneficiaries
Define os valores do where para os beneficiários de acordo com os parametros do lote
@type function
@version 12.1.2510
@author vinicius.queiros
@since 31/10/2024
@param oExecStmt, object, FwExecStatement com a query
@param nOrder, numeric, ordem de atributação dos valores (passado por referencia @)
@param jParameters, json, parâmetro com os campos do lote
@return object, FwExecStatement com os valores
/*/
static function setWhereFilterBeneficiaries(oExecStmt as object, nOrder as numeric, jParameters as json) as object

	local cExchangeCompany := superGetMV("MV_PLSGEIN", .F., "") as character

	oExecStmt:setString(nOrder++, xFilial("BA1"))
    oExecStmt:setString(nOrder++, jParameters["unimedOrigin"])

    if !empty(jParameters["companyCodeFrom"])
        oExecStmt:setString(nOrder++, jParameters["companyCodeFrom"])
    endif

    if !empty(jParameters["companyCodeTo"])
        oExecStmt:setString(nOrder++, jParameters["companyCodeTo"])
    endif

    if !empty(jParameters["contractCodeFrom"])
        oExecStmt:setString(nOrder++, jParameters["contractCodeFrom"])
    endif

    if !empty(jParameters["contractCodeTo"])
        oExecStmt:setString(nOrder++, jParameters["contractCodeTo"])
    endif

    if !empty(jParameters["subcontractCodeFrom"])
        oExecStmt:setString(nOrder++, jParameters["subcontractCodeFrom"])
    endif

    if !empty(jParameters["subcontractCodeTo"])
        oExecStmt:setString(nOrder++, jParameters["subcontractCodeTo"])
    endif

    if !empty(jParameters["familyCodeFrom"])
        oExecStmt:setString(nOrder++, jParameters["familyCodeFrom"])
    endif

    if !empty(jParameters["familyCodeTo"])
        oExecStmt:setString(nOrder++, jParameters["familyCodeTo"])
    endif

    oExecStmt:setString(nOrder++, cExchangeCompany)  

    if !empty(jParameters["considerANS"])
        oExecStmt:setString(nOrder++, jParameters["considerANS"])
    endif

    if !empty(jParameters["considerSIB"])
        oExecStmt:setString(nOrder++, jParameters["considerSIB"])
    endif

return oExecStmt

/*/{Protheus.doc} setQueryNotExists
Define os valores da query de NOT EXISTS para beneficiários com lote pendente de envio
@type function
@version 12.1.2510
@author vinicius.queiros
@since 31/10/2024
@param oExecStmt, object, FwExecStatement com a query
@param nOrder, numeric, ordem de atributação dos valores (passado por referencia @)
@return object, FwExecStatement com os valores
/*/
static function setQueryNotExists(oExecStmt as object, nOrder as numeric) as object

	oExecStmt:setUnsafe(nOrder++, "BPY.BPY_CODINT, BPY.BPY_CODEMP, BPY.BPY_MATRIC, BPY.BPY_TIPREG, BPY.BPY_DIGITO")
    oExecStmt:setUnsafe(nOrder++, retSqlName("BPY"))
    oExecStmt:setString(nOrder++, xFilial("BPY"))
	oExecStmt:setString(nOrder++, " ")
    oExecStmt:setString(nOrder++, PENDING_SEND)
    oExecStmt:setString(nOrder++, SEND_ERROR)
    oExecStmt:setString(nOrder++, SEND_COMPLETED)
    
return oExecStmt

/*/{Protheus.doc} breakSqlFields
Quebra os campos no formato de query para ser utilizado com o IN do SQL
@type function
@version 12.1.2510
@author vinicius.queiros
@since 08/11/2024
@param cFields, character, lista de campos a ser formatado
@param cSeparator, character, separador dos campos
@return cSqlFields, lista de campos no formato sql
/*/
static function breakSqlFields(cFields as character, cSeparator as character) as character

	local cSqlFields as character
	local nCount := 0 as numeric
	local aFields := {} as array

	aFields := StrToKarr(cFields, cSeparator)

	for nCount := 1 to Len(aFields)
		cSqlFields += "'" + aFields[nCount] + "'"

		cSqlFields += iif(nCount < len(aFields), ",", "")
	next nCount

	fwFreeArray(aFields)

return cSqlFields
