#INCLUDE "totvs.ch"
#INCLUDE "health.plan.delinquency.monitor.service.ch"
#INCLUDE "tlpp-core.th"

namespace totvs.protheus.health.delinquency.monitor

/*a variavel cRealTbInvoice recebe o nome real da tabela temporaria de titulos pois ela
podera ser utilizada no metodo estatico realNameInvoices que por sua vez podera ser
utilizado na funcao de retorno dos dados na rotina do gerenciador de e-mails
no momento do envio do e-mail*/
static cRealTbInvoice 	    as character

/*a variavel cRealTbBeneficiaries recebe o nome real da tabela temporaria de beneficiarios pois ela
podera ser utilizada no metodo estatico realNameBeneficiaries que por sua vez podera ser
utilizado na funcao de retorno dos dados na rotina do gerenciador de e-mails
no momento do envio do e-mail*/
static cRealTbBeneficiaries as character

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} DelinquencyInterface
Monitor de inadimplência
@version P12
/*/
Class DelinquencyService

	protected data cDataTableTemp  as character
	protected data cTmpInvoices    as character

	private data oBulkContact      as object
	private data lDebugOracle      as logical
	private data lOracleDb	       as logical

	public Method new()  
	public Method createBulkContact()   
	public Method insertDataBulkContact(cBenefRegister as character, cTypeContact as character, cDescriptionContact as character) as logical  
	public Method flushBulkContact()   
	public Method goToBeneficiarie(cPosRecno as character)   
	public Method getAliasDataBenef()             as character
	public method dropTables() 

	protected Method createTableBeneficiaries()   as character
	Protected Method createTableInvoices()        as character
	protected Method getAliasInvoices() 		  as character
	protected Method populateTableBeneficiaries() as json
	protected Method loadDataTables() 			  as json
	protected Method logService(cError) 
	protected Method manipulationTablesDebug() 
	
	static Method realNameBeneficiaries() 
	static Method realNameInvoices() 

EndClass

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} New
Construtor
@version P12
/*/
Method new() Class DelinquencyService
	
	self:lOracleDb    := (TCGetDB() == "ORACLE")
	self:lDebugOracle := IIf(self:lOracleDb, (AllTrim(GetNewPar("MV_DEBMONT", ".F.")) == ".T."), .F.)
	
Return self

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} createTableInvoices
Cria a tabela temporaria dos titulos
@version P12
/*/
Method createTableInvoices() as character Class DelinquencyService

	Local aSctFilds  := {} as array
	Local oTmpData	 as object

	oTmpData := FWTemporaryTable():New("BENEFINA")
	
	//Monta os campos da tabela correspondente aos titulos
	AADD(aSctFilds, {"E1_VENCTO" , "D", 8 ,0})
	AADD(aSctFilds, {"E1_EMISSAO", "D", 8 ,0})
	AADD(aSctFilds, {"E1_VENCREA", "D", 8 ,0})
	AADD(aSctFilds, {"E1_PREFIXO", "C", 3 ,0})
	AADD(aSctFilds, {"E1_NUM"    , "C", 18,0})
	AADD(aSctFilds, {"E1_PARCELA", "C", 3 ,0})
	AADD(aSctFilds, {"E1_TIPO"   , "C", 3 ,0})
	AADD(aSctFilds, {"E1_VALOR"  , "N", 16,2})
	AADD(aSctFilds, {"E1_MESBASE", "C", 2 ,0})
	AADD(aSctFilds, {"E1_ANOBASE", "C", 4 ,0})
	AADD(aSctFilds, {"E1_PLNUCOB", "C", 12,0})
	AADD(aSctFilds, {"E1_CONEMP" , "C", 12,0})
	AADD(aSctFilds, {"E1_VERCON" , "C", 3 ,0})
	AADD(aSctFilds, {"E1_SUBCON" , "C", 9 ,0})
	AADD(aSctFilds, {"E1_VERSUB" , "C", 3 ,0})
	AADD(aSctFilds, {"E1_CLIENTE", "C", 6 ,0})
	AADD(aSctFilds, {"E1_LOJA"   , "C", 2 ,0})
	AADD(aSctFilds, {"BM1_CODINT", "C", 4 ,0})
	AADD(aSctFilds, {"BM1_CODEMP", "C", 4 ,0})
	AADD(aSctFilds, {"BM1_MATRIC", "C", 6 ,0})
	AADD(aSctFilds, {"BM1_TIPREG", "C", 2 ,0})
	AADD(aSctFilds, {"BM1_DIGITO", "C", 1 ,0})
	AADD(aSctFilds, {"BM1_MATUSU", "C", 17,0})
	
	//Monta os campos da tabela correspondente aos beneficiarios
	AADD(aSctFilds, {"BA1_NOMUSR", "C", 99,0})
	AADD(aSctFilds, {"BA1_NOMSOC", "C", 99,0})
	AADD(aSctFilds, {"BA1_CODINT", "C", 4 ,0})
	AADD(aSctFilds, {"BA1_CODEMP", "C", 4 ,0})
	AADD(aSctFilds, {"BA1_MATRIC", "C", 6 ,0})
	AADD(aSctFilds, {"BA1_TIPREG", "C", 2 ,0})
	AADD(aSctFilds, {"BA1_DIGITO", "C", 1 ,0})
	AADD(aSctFilds, {"BA1_CONEMP", "C", 12,0})
	AADD(aSctFilds, {"BA1_VERCON", "C", 3 ,0})
	AADD(aSctFilds, {"BA1_SUBCON", "C", 9 ,0})
	AADD(aSctFilds, {"BA1_VERSUB", "C", 3 ,0})
	AADD(aSctFilds, {"BA1_MATANT", "C", 20,0})
	AADD(aSctFilds, {"BA1_EMAIL" , "C", 90,0})
	AADD(aSctFilds, {"BA3_CODCLI", "C", 6 ,0})
	AADD(aSctFilds, {"BA3_LOJA"  , "C", 2 ,0})
	AADD(aSctFilds, {"BA3_DATBAS", "D", 8 ,0})
	AADD(aSctFilds, {"BA3_COBNIV", "C", 1 ,0})
	AADD(aSctFilds, {"E1_NOMCLI" , "C", 99,0})

	//Estes dois campos sao importantes pois serao utilizados nos filtros
	//da RN 593 na interface, eles fazem parte da regra da RN
	AADD(aSctFilds, {"DAT_LIMITE", "D", 8 ,0})
	AADD(aSctFilds, {"QTD_REGTRO", "N", 9 ,0})

	//insere os campos que seram criados na temporaria
	oTmpData:SetFields(aSctFilds)

	//indices
	oTmpData:AddIndex("1", {"E1_VENCTO" })
	oTmpData:AddIndex("2", {"E1_NUM"    })
	oTmpData:AddIndex("3", {"BM1_MATUSU"})

	If Select("BENEFINA") > 0
		BENEFINA->(DbCloseArea()) 
	EndIf

	//cria a tabela
	oTmpData:Create()
	
	//variavel utilizada no metodo getAliasInvoices
	self:cTmpInvoices      := oTmpData:GetAlias()
	
Return oTmpData:GetRealName() //retorna o nome real da tabela temporaria

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} loadDataTables
Carrega os dados na tabela temporaria BENEFINA que vai servir para
e partir dela iremos popular a tabela BENEINAD
@version P12
/*/
Method loadDataTables(dDateSearch     as date     , cHealtOperCode as character, cCompany as character,;
					  cContract       as character, cSubcontract   as character) as json Class DelinquencyService
	
	Local aParams      := {} 	 as array
	Local cDataQuery           	 as character
	Local cRealTableNameInvoices as character
	Local cPrefix				 as character
	Local cErrorIv				 as character
	Local nLenTipo			 	 as integer
	Local oJRetLoad			 	 := JsonObject():New() 
	Local oStatement             := FWExecStatement():New()
	Local lGenNFBRA				 := GetNewPar("MV_PLSNFBR","0") == "1"

	Default dDateSearch     := STOD("")
	Default cHealtOperCode  := ""
	Default cCompany 		:= ""
	Default cContract       := ""
	Default cSubcontract    := ""

	//dropa as tabelas temporarias anteriores criadas
	self:dropTables()

	//campos utilizados na tabela temporaria de beneficiarios BENEINAD	
	cFieldBenef := " BA1_NOMUSR, BA1_NOMSOC, BA1_CODINT, BA1_CODEMP, BA1_MATRIC, BA1_TIPREG, BA1_DIGITO, "
	cFieldBenef += " BA1_CONEMP, BA1_VERCON, BA1_SUBCON, BA1_VERSUB, BA1_MATANT, BA1_EMAIL , 			 "
    cFieldBenef += " BA3_CODCLI, BA3_LOJA  , BA3_DATBAS, BA3_COBNIV, E1_NOMCLI              			 "

	// campos exclusivos para a tabela temporaria de titulos BENEFINA.
	/*a tabela BENEFINA possui os campos da tabela BENEINAD pois sera a partir dos dados gravados
	na tabela BENEFINA que iremos popular a tabela BENEINAD, por isso foi criado na tabela temporaria
	dos titulos os campos da tabela de beneficiarios, isso faz com que haja melhora na performance
	de inserção dos dados nas tabelas*/
	cFieldInvoices := " E1_EMISSAO, "
	cFieldInvoices += " E1_VENCREA, "
	cFieldInvoices += " E1_PREFIXO, "
	cFieldInvoices += " E1_NUM, 	"
	cFieldInvoices += " E1_PARCELA, "
	cFieldInvoices += " E1_TIPO, 	"
	cFieldInvoices += " E1_VALOR, 	"
	cFieldInvoices += " E1_MESBASE, "
	cFieldInvoices += " E1_ANOBASE, "
	cFieldInvoices += " E1_PLNUCOB, "
	cFieldInvoices += " E1_CONEMP, 	"
	cFieldInvoices += " E1_VERCON, 	"
	cFieldInvoices += " E1_SUBCON, 	"
	cFieldInvoices += " E1_VERSUB, 	"
	cFieldInvoices += " E1_CLIENTE, "
	cFieldInvoices += " E1_LOJA, 	"
	cFieldInvoices += " BM1_CODINT, "
	cFieldInvoices += " BM1_CODEMP, "
	cFieldInvoices += " BM1_MATRIC, "
	cFieldInvoices += " BM1_TIPREG, "
	cFieldInvoices += " BM1_DIGITO, "
	cFieldInvoices += " BM1_MATUSU 	"

	cRealTableNameInvoices := self:createTableInvoices()

	cRealTbInvoice := cRealTableNameInvoices
	
	/*devido a grande quantidade de dados que a rotina tera que manipular, nao foi utilizado
	o reclock, o bulk nao funcionou corretamente na tabela temporaria, a insercao de dados direto
	torna a rotina muito mais performatica e por se tratar de manipulação de um tabela temporaria,
	o risco de gerar inconsistencia nao é um problema ja que ela sempre sera dropada e criada
	a cada novo filtro*/
	
	If self:lOracleDb
		cDataQuery += "	INSERT INTO " + cRealTableNameInvoices
		cDataQuery += "(E1_VENCTO," + cFieldBenef + "," + cFieldInvoices + ", DAT_LIMITE,  QTD_REGTRO) "
	EndIf

	cDataQuery += " WITH BASEDATA AS ("
    cDataQuery += " 	SELECT E1_VENCTO," + cFieldBenef + "," + cFieldInvoices
    cDataQuery += " 	   ,FIRST_VALUE(E1_VENCTO) OVER (PARTITION BY "
    cDataQuery += " 	        BM1_CODINT, "
    cDataQuery += " 	        BM1_CODEMP, "
    cDataQuery += " 	        BM1_MATRIC, "
    cDataQuery += " 	        BM1_TIPREG, "
    cDataQuery += " 	        BM1_DIGITO  "
    cDataQuery += " 	        ORDER BY E1_VENCTO ASC) DAT_LIMITE, "
    cDataQuery += " 	    COUNT(BM1_MATRIC) OVER (PARTITION BY "
    cDataQuery += " 	        BM1_CODINT, "
    cDataQuery += " 	        BM1_CODEMP, "
    cDataQuery += " 	        BM1_MATRIC, "
    cDataQuery += " 	        BM1_TIPREG, "
    cDataQuery += " 	        BM1_DIGITO, "
    cDataQuery += " 	        BM1_MATUSU) QTD_REGTRO"

    cDataQuery += " 	FROM " + RetSQLName("BA1") + " BA1 "
    
	cDataQuery += " 	    INNER JOIN  " + RetSQLName("BA3") + " BA3 " 
	cDataQuery += "			 ON "
	cDataQuery += "             BA3.BA3_FILIAL = '" + xFilial("BA3") + "' AND "
    cDataQuery += " 	        BA3.BA3_CODINT = BA1.BA1_CODINT 		  AND "
    cDataQuery += " 	        BA3.BA3_CODEMP = BA1.BA1_CODEMP 		  AND "
    cDataQuery += " 	        BA3.BA3_MATRIC = BA1.BA1_MATRIC 		  AND "
    cDataQuery += " 	        BA3.BA3_CONEMP = BA1.BA1_CONEMP 		  AND "
    cDataQuery += " 	        BA3.BA3_VERCON = BA1.BA1_VERCON 		  AND "
    cDataQuery += " 	        BA3.BA3_SUBCON = BA1.BA1_SUBCON 		  AND "
    cDataQuery += " 	        BA3.BA3_VERSUB = BA1.BA1_VERSUB 		      "
    
	cDataQuery += " 	    INNER JOIN " + RetSQLName("BM1") + " BM1  "
	cDataQuery += "			 ON "
    cDataQuery += "             BM1.BM1_FILIAL = '" + xFilial("BM1") + "' AND "
	cDataQuery += " 	        BM1.BM1_CODINT = BA1.BA1_CODINT           AND "
    cDataQuery += " 	        BM1.BM1_CODEMP = BA1.BA1_CODEMP           AND "
    cDataQuery += " 	        BM1.BM1_MATRIC = BA1.BA1_MATRIC           AND "
    cDataQuery += " 	        BM1.BM1_TIPREG = BA1.BA1_TIPREG           AND "
    cDataQuery += " 	        BM1.BM1_DIGITO = BA1.BA1_DIGITO"
    
	cDataQuery += " 	    INNER JOIN " + RetSQLName("SE1") + " SE1 "
	cDataQuery += "			 ON "
	cDataQuery += "             SE1.E1_FILIAL  = '" + xFilial("SE1") + "' AND "
    cDataQuery += " 	        SE1.E1_NUM     = BM1.BM1_NUMTIT           AND "
    cDataQuery += " 	        SE1.E1_TIPO    = BM1.BM1_TIPTIT           AND "
    cDataQuery += " 	        SE1.E1_PREFIXO = BM1.BM1_PREFIX"
	
	cDataQuery += " 	    INNER JOIN " + RetSQLName("BI3") + " BI3 "
	cDataQuery += "			 ON "
	cDataQuery += "             BI3.BI3_FILIAL = '" + xFilial("BI3") + "' AND "
	cDataQuery += " 	        BI3.BI3_CODINT = BA3.BA3_CODINT           AND "
	cDataQuery += " 	        BI3.BI3_CODIGO = BA3.BA3_CODPLA           AND "
	cDataQuery += " 	        BI3.BI3_VERSAO = BA3.BA3_VERSAO               "

    cDataQuery += " 	WHERE "
	cDataQuery += " 	  BM1.BM1_CODTIP = '101'                          AND "
	cDataQuery += " 	  BM1.BM1_TIPO   = '1'                            AND "
	
	cPrefix := SUPERGETMV("MV_PLPFE11", .F., "'PLS'")
	cPrefix := Eval({|| &cPrefix })

	If lGenNFBRA .And. Empty(A460Especie(cPrefix))
		cPrefix := "UNI"
	EndIf
	
	cDataQuery += " 	E1_PREFIXO = '" + cPrefix + "' 			AND "
	
	aStrTokArr := StrTokArr(SUPERGETMV("MV_PLSTIT", .F., "'DP'"), ",")
	cStrIn := ""

	nLenArr := Len(aStrTokArr)
	For nLenTipo := 1 To Len(aStrTokArr)
		cStrIn += "'" + aStrTokArr[nLenTipo] + "' "

		If nLenTipo < nLenArr
			cStrIn += ","
		EndIf
	Next

	cDataQuery += " 	E1_TIPO IN (" + cStrIn + ")             AND "
	
	cDataQuery += "     E1_STATUS = 'A' 					    AND "
	cDataQuery += "     E1_BAIXA  = ' ' 					    AND "

	cDataQuery += "     E1_VENCTO BETWEEN ? AND ?               AND "
	AADD(aParams, dDateSearch)
	AADD(aParams, dDataBase - 1)

	If !Empty(cHealtOperCode)
		cDataQuery += "     BA3_CODINT = ? 	  					AND "
		AADD(aParams, cHealtOperCode)
	EndIf

	If !Empty(cCompany)
		cDataQuery += "     BA3_CODEMP = ? 	  					AND " 
		AADD(aParams, cCompany)
	EndIf

	If !Empty(cContract)
		cDataQuery += "     BA3_CONEMP = ? 	  					AND "
		AADD(aParams, cContract)
	EndIf

	If !Empty(cSubcontract)
		cDataQuery += "     BA3_SUBCON = ? 	  					AND "
		AADD(aParams, cSubcontract)
	EndIf

	cDataQuery += " 	(BA1_TIPUSU = 'T' OR BA1_RESFAM = '1')  AND "
	cDataQuery += "       BA3.BA3_DATBLO = ' '   			    AND "

    cDataQuery += "     BA1.D_E_L_E_T_ = ' ' 					AND "
    cDataQuery += "     BA3.D_E_L_E_T_ = ' ' 					AND "
    cDataQuery += "     BM1.D_E_L_E_T_ = ' ' 					AND "
    cDataQuery += "     SE1.D_E_L_E_T_ = ' '     				AND	"
    cDataQuery += "     BI3.D_E_L_E_T_ = ' '     					"
	cDataQuery += " )"

	If !self:lOracleDb
			
		cDataQuery += "	INSERT INTO " + cRealTableNameInvoices
		cDataQuery += "(E1_VENCTO," + cFieldBenef + "," + cFieldInvoices + ", DAT_LIMITE,  QTD_REGTRO) "
	EndIf
	
	cDataQuery += " SELECT E1_VENCTO," + cFieldBenef + "," + cFieldInvoices + ", DAT_LIMITE,  QTD_REGTRO "
	cDataQuery += " FROM BASEDATA "
	cDataQuery += " ORDER BY E1_VENCTO"
	
	oStatement:SetQuery(cDataQuery)
	oStatement:setParams(aParams)

	If TCSqlExec(oStatement:getFixQuery()) < 0

		self:logService(TCSqlError())
		
		oJRetLoad["dataExists"] := .F.
		oJRetLoad["message"]   := STR0001 + AllTrim(TCSqlError()) //"Não foi possível concluir o processo de pesquisa dos dados, entre em contato com o administrador do sistema e informe o seguinte erro: "
	Else
	
		BENEFINA->(DbGoTop())

		If !BENEFINA->(EOF())
			oJRetLoad := self:populateTableBeneficiaries(cRealTableNameInvoices, cFieldBenef)
		Else
			oJRetLoad["dataExists"] := .F.
			oJRetLoad["message"]    := STR0002 //"Não encontramos nenhum resultado para o filtro aplicado. Ajuste os critérios de busca e tente novamente."
		EndIf

		If self:lOracleDb
			
			//o oracle nao permite acessar os dados da sessao de uma tabela temporaria em outra sessao,como no SQL server
			//ou postgre, dessa forma, se faz necessario criar uma tabela fisica para poder persisitir os dados da tabela
			//temporaria para ter acesso em outras sessoes do banco de dados, e a tabela fisica deve ser excluida ao fechar a rotina
			If self:lDebugOracle
				self:manipulationTablesDebug("BENEFINA_COPY", cRealTableNameInvoices)
			EndIf
		EndIf
	EndIf

Return oJRetLoad

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} createTableBeneficiaries
Cria a tabela temporaria de beneficiario
@version P12
/*/
Method createTableBeneficiaries() as character Class DelinquencyService

	Local aStructFilds := {}
	
	AADD(aStructFilds, {"MARK"      , "C", 1 ,0})
	AADD(aStructFilds, {"BA1_NOMUSR", "C", 99,0})
	AADD(aStructFilds, {"BA1_NOMSOC", "C", 99,0})
	AADD(aStructFilds, {"BA1_CODINT", "C", 4 ,0})
	AADD(aStructFilds, {"BA1_CODEMP", "C", 4 ,0})
	AADD(aStructFilds, {"BA1_MATRIC", "C", 6 ,0})
	AADD(aStructFilds, {"BA1_TIPREG", "C", 2 ,0})
	AADD(aStructFilds, {"BA1_DIGITO", "C", 1 ,0})
	AADD(aStructFilds, {"BA1_CONEMP", "C", 12,0})
	AADD(aStructFilds, {"BA1_VERCON", "C", 3 ,0})
	AADD(aStructFilds, {"BA1_SUBCON", "C", 9 ,0})
	AADD(aStructFilds, {"BA1_VERSUB", "C", 3 ,0})
	AADD(aStructFilds, {"BA1_MATANT", "C", 20,0})
	AADD(aStructFilds, {"BA1_EMAIL" , "C", 90,0})
	AADD(aStructFilds, {"BA3_CODCLI", "C", 6 ,0})
	AADD(aStructFilds, {"BA3_LOJA"  , "C", 2 ,0})
	AADD(aStructFilds, {"BA3_DATBAS", "D", 8 ,0})
	AADD(aStructFilds, {"BA3_COBNIV", "C", 1 ,0})
	AADD(aStructFilds, {"E1_NOMCLI" , "C", 99,0})
	AADD(aStructFilds, {"E1_VENCTO" , "D", 8 ,0})
	AADD(aStructFilds, {"BE4_CODRDA", "C", 6 ,0})
	AADD(aStructFilds, {"BE4_DTDIGI", "D", 8 ,0})
	AADD(aStructFilds, {"BRZ_DATCON", "D", 8 ,0})
	AADD(aStructFilds, {"DAT_LIMITE", "D", 8 ,0})
	AADD(aStructFilds, {"QTD_REGTRO", "N", 9 ,0})

	oTempData := FWTemporaryTable():New("BENEINAD")
	
	oTempData:SetFields(aStructFilds)

	oTempData:AddIndex("1", {"E1_VENCTO"} )
	oTempData:AddIndex("2", {"BA1_CODINT", "BA1_CODEMP", "BA1_MATRIC", "BA1_TIPREG", "BA1_DIGITO"} )
	oTempData:AddIndex("3", {"BA1_NOMUSR"} )
	
	If Select("BENEINAD") > 0
		BENEINAD->(DbCloseArea()) 
	EndIf

	oTempData:Create()
	
	self:cDataTableTemp := oTempData:GetAlias()
	
Return oTempData:GetRealName()

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} populateTableBeneficiaries
Carrega os dados na tabela temporaria BENEINAD a partir da tabela 
temporaria BENEFINA
@version P12
/*/
Method populateTableBeneficiaries(cTableInvoices as character, cFieldsBen as character) as json Class DelinquencyService

	Local cRealTableNameBeneficiaries := self:CreateTableBeneficiaries()
	Local oJRetPopBeneficiarie := JsonObject():New()
	Local cQueryBen	   as character	

	Default cTableInvoices := ""
	Default cFieldsBen     := ""

	cRealTbBeneficiaries := cRealTableNameBeneficiaries

	/*a tabela de titulos pode ter varias linhas de acordo com a quantidade de titulos em atraso,
	a query foi desenvolvida para gravar na tabela temporaria apenas uma vez os dados de cada beneficiario, e gravar os dados
	ordenando do beneficiario que possui o titulo com vencimento mais antigo ao que possui o vencimento mais proximo da data atual*/
	
	If self:lOracleDb
		cQueryBen += " INSERT INTO " + cRealTableNameBeneficiaries
		cQueryBen += " (" + cFieldsBen + " , E1_VENCTO, BE4_CODRDA, BE4_DTDIGI, BRZ_DATCON, DAT_LIMITE, QTD_REGTRO )"
	EndIf
	
	cQueryBen += "  WITH RankedData AS ( "
	cQueryBen += " 		SELECT " 
	cQueryBen += " 			INV.BA1_NOMUSR, INV.BA1_NOMSOC, INV.BA1_CODINT, INV.BA1_CODEMP, INV.BA1_MATRIC, INV.BA1_TIPREG, INV.BA1_DIGITO, "
	cQueryBen += " 			INV.BA1_CONEMP, INV.BA1_VERCON, INV.BA1_SUBCON, INV.BA1_VERSUB, INV.BA1_MATANT, INV.BA1_EMAIL , INV.BA3_CODCLI, " 
	cQueryBen += " 			INV.BA3_LOJA  , INV.BA3_DATBAS, INV.BA3_COBNIV, INV.E1_NOMCLI , INV.E1_VENCTO , 				"
	cQueryBen += "			COALESCE(BRZ.BRZ_DATCON, NULL) AS BRZ_DATCON  , COALESCE(BE4.BE4_CODRDA, '') AS BE4_CODRDA    , BE4_DTDIGI    , "
	cQueryBen += "			DAT_LIMITE, QTD_REGTRO, 																						"                      															
	
	cQueryBen += " 			ROW_NUMBER() OVER ( "
	cQueryBen += " 				PARTITION BY "
	cQueryBen += " 					BA1_CODINT, BA1_CODEMP, BA1_MATRIC, BA1_TIPREG, BA1_DIGITO " 
	cQueryBen += " 				ORDER BY E1_VENCTO ASC " 
	cQueryBen += " 			) AS rn "
	
	cQueryBen += "		FROM " + cTableInvoices +" INV  "
	
	cQueryBen += "		LEFT JOIN (  "
	cQueryBen += "					SELECT BRZ_MATRIC, MAX(BRZ_DATCON) AS BRZ_DATCON  "
	cQueryBen += "					FROM " + RetSQLName("BRZ") + " BRZ " 
	cQueryBen += "					WHERE BRZ_FILIAL = '" + xFilial("BRZ") + "' " 
	cQueryBen += "					AND D_E_L_E_T_ = ' '  "
	cQueryBen += "					GROUP BY BRZ_MATRIC  "
	cQueryBen += "				) BRZ  "
	cQueryBen += "				ON BRZ.BRZ_MATRIC = INV.BM1_MATUSU  "
	
	cQueryBen += "		LEFT JOIN " + RetSQLName("BE4") + " BE4  "
	cQueryBen += "			ON  BE4.BE4_CODOPE = INV.BA1_CODINT  "
	cQueryBen += "			AND BE4.BE4_CODEMP = INV.BA1_CODEMP  "
	cQueryBen += "			AND BE4.BE4_MATRIC = INV.BA1_MATRIC  "
	cQueryBen += "			AND BE4.BE4_DTDIGI <= '" + DTOS(dDataBase) + "' "
	cQueryBen += "			AND BE4.BE4_DTDIGI <> ' '  "
	cQueryBen += "			AND (BE4.BE4_DTALTA = ' ' OR BE4.BE4_DTALTA >= '" + DTOS(dDataBase) + "' ) "  
	cQueryBen += "	)  "

	/*devido a grande quantidade de dados que a rotina tera que manipular, nao foi utilizado
	o reclock, o bulk nao funcionou corretamente na tabela temporaria, a insercao de dados direto
	torna a rotina muito mais performatica e por se tratar de manipulação de um tabela temporaria,
	o risco de gerar inconsistencia nao é um problema ja que ela sempre sera dropada e criada
	a cada novo filtro*/
	If !self:lOracleDb
		cQueryBen += " INSERT INTO " + cRealTableNameBeneficiaries
		cQueryBen += " (" + cFieldsBen + " , E1_VENCTO, BE4_CODRDA, BE4_DTDIGI, BRZ_DATCON, DAT_LIMITE, QTD_REGTRO )"
	EndIf

	cQueryBen += "	SELECT  "
	cQueryBen += "	    BA1_NOMUSR, BA1_NOMSOC, BA1_CODINT, BA1_CODEMP, BA1_MATRIC, BA1_TIPREG, BA1_DIGITO, "
	cQueryBen += "	    BA1_CONEMP, BA1_VERCON, BA1_SUBCON, BA1_VERSUB, BA1_MATANT, BA1_EMAIL , BA3_CODCLI, "
	cQueryBen += "	    BA3_LOJA  , BA3_DATBAS, BA3_COBNIV, E1_NOMCLI , E1_VENCTO , BE4_CODRDA,  			"
	cQueryBen += "	    BE4_DTDIGI, BRZ_DATCON, DAT_LIMITE, QTD_REGTRO  								    "
	
	cQueryBen += "	FROM RankedData  "
	cQueryBen += "	WHERE rn = 1     "
	cQueryBen += "	ORDER BY E1_VENCTO"

	If TCSqlExec(cQueryBen) < 0
		self:logService(TCSqlError())
		
		oJRetPopBeneficiarie["dataExists"] := .F.
		oJRetPopBeneficiarie["message"]   := STR0001 + AllTrim(TCSqlError()) //"Não foi possível concluir o processo de pesquisa dos dados, entre em contato com o administrador do sistema e informe o seguinte erro: "
	Else
		
		BENEINAD->(DbGoTop())

		oJRetPopBeneficiarie["dataExists"] := .T.
		oJRetPopBeneficiarie["message"]   := ""

		If self:lOracleDb
			
			//o oracle nao permite acessar os dados da sessao de uma tabela temporaria em outra sessao,como no SQL server
			//ou postgre, dessa forma, se faz necessario criar uma tabela fisica para poder persisitir os dados da tabela
			//temporaria para ter acesso em outras sessoes do banco de dados, e a tabela fisica deve ser excluida ao fechar a rotina
			If self:lDebugOracle
				self:manipulationTablesDebug("BENEINAD_COPY", cRealTableNameBeneficiaries)
			EndIf
		EndIf
	EndIf

Return oJRetPopBeneficiarie

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} getAliasDataBenef

@version P12
/*/
Method getAliasDataBenef() as character Class DelinquencyService
Return self:cDataTableTemp

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} getAliasDataBenef
Retorna no nome do arquivo da tabela temporaria BENEFINA
@version P12
/*/
Method getAliasInvoices() as character Class DelinquencyService
Return self:cTmpInvoices


//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} createBulkContact
Cria o objeto da classe FWBulk para inserção dos dados na tabela de contato
@version P12
/*/
Method createBulkContact() Class DelinquencyService
	
	self:oBulkContact := FWBulk():new(RetSQLName("BRZ"), 1000)

	If FwBulk():CanBulk() 
		self:oBulkContact:SetFields(BRZ->(DbStruct()))
	EndIf
Return 

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} insertDataBulkContact
Insere os dados no buffer do objeto FWBulk
@version P12
/*/
Method insertDataBulkContact(cBenefRegister as character, cTypeContact as character, cDescriptionContact as character) as logical Class DelinquencyService

	Local   lRetAdd             := .T.

	Default cBenefRegister      := ""
	Default cTypeContact        := "01"
	Default cDescriptionContact := STR0003 //"Registro gerado através do envio de e-mail"       

	lRetAdd := self:oBulkContact:addData( {xFilial("BRZ")        ,;
											dDataBase	         ,;
											SubStr(Time(), 1, 5) ,;
											cTypeContact         ,;
											cBenefRegister       ,;
											cDescriptionContact  ,;
											dDataBase            ,;
											Time()               ,;
											"0"                   ;
										  };
										)
	
	If !lRetAdd
		self:logService(self:oBulkContact:GetError())
	EndIf

Return lRetAdd

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} flushBulkContact
Realiza o commit dos dados inseridos no buffer do objeto FWBulk
@version P12
/*/
Method flushBulkContact() Class DelinquencyService
	
	Local lRetFlush := .T.

	lRetFlush := self:oBulkContact:Flush()
	self:oBulkContact:close()
	self:oBulkContact:destroy()
	
	If !lRetFlush
		self:logService(self:oBulkContact:GetError())
	EndIf
Return lRetFlush

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} realNameInvoices
O nome real da tabela de titulos no banco de dados
@version P12
/*/
Method realNameInvoices()  Class DelinquencyService
Return cRealTbInvoice

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} realNameBeneficiaries
O nome real da tabela de beneficiarios no banco de dados
@version P12
/*/
Method realNameBeneficiaries()  Class DelinquencyService
Return cRealTbBeneficiaries

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} goToBeneficiarie
posiciona o ponteiro na tabela temporaria de beneficiarios
@version P12
/*/
Method goToBeneficiarie(cPosRecno as character) Class DelinquencyService
Return BENEINAD->(DbGoTo(Val(cPosRecno)))

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} dropTables
Dropa as tabelas temporárias e a tabela de debug
@version P12
/*/
Method dropTables() Class DelinquencyService
	
	Local cSqlDrop as character
	Local cErrorDp as character

	If !EMPTY(cRealTbBeneficiaries)
		
		cSqlDrop := " DROP TABLE " + cRealTbBeneficiaries + "; "
		cSqlDrop += " DROP TABLE " + cRealTbInvoice  + "; "

		If self:lDebugOracle 

			cSqlDrop := " BEGIN"
			cSqlDrop += "	EXECUTE IMMEDIATE 'DROP TABLE BENEFINA_COPY';"
			cSqlDrop += " EXCEPTION"
			cSqlDrop += "	WHEN OTHERS THEN"
			cSqlDrop += "		IF SQLCODE != -942 THEN "
			cSqlDrop += "			RAISE;"
			cSqlDrop += "		END IF;"
			cSqlDrop += " END;"
			
			If TCSqlExec(cSqlDrop) < 0
				cErrorDp := TCSqlError()
			EndIf

			cSqlDrop := " BEGIN"
			cSqlDrop += "	EXECUTE IMMEDIATE 'DROP TABLE BENEINAD_COPY';"
			cSqlDrop += " EXCEPTION"
			cSqlDrop += "	WHEN OTHERS THEN"
			cSqlDrop += "		IF SQLCODE != -942 THEN "
			cSqlDrop += "			RAISE;"
			cSqlDrop += "		END IF;"
			cSqlDrop += " END;"
				
			If TCSqlExec(cSqlDrop) < 0
				cErrorDp := TCSqlError()
			EndIf
		EndIf
	EndIf
Return

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} manipulationTablesDebug
Manipulação das tabelas de debug apenas para banco oracle e com o atributo
lDebugOracle como true
@version P12
/*/
Method manipulationTablesDebug(cNameCopyTable as character, cRealTbName as character) Class DelinquencyService
	
	Local cSqlDegub  as character
	Local cErrorDrop as character
	
	cSqlDegub := " BEGIN"
	cSqlDegub += "	EXECUTE IMMEDIATE 'DROP TABLE " + cNameCopyTable + "';"
	cSqlDegub += " EXCEPTION"
	cSqlDegub += "	WHEN OTHERS THEN"
	cSqlDegub += "		IF SQLCODE != -942 THEN "
	cSqlDegub += "			RAISE;"
	cSqlDegub += "		END IF;"
	cSqlDegub += " END;"

	If TCSqlExec(cSqlDegub) < 0
		cErrorDrop := TCSqlError()
	EndIf

	cSqlDegub := "CREATE TABLE  " + cNameCopyTable + " AS   "
	cSqlDegub += "SELECT * FROM " + cRealTbName
	
	If TCSqlExec(cSqlDegub) < 0
		cErrorDrop := TCSqlError()
	EndIf
Return

//////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------
/*/{Protheus.doc} logService
Gera o log de erro
@version P12
/*/
Method logService(cError) Class DelinquencyService
	
	Local cLogName := "monitorInadimplencia.log"
	plsLogFil("////////////////////////////////////////////////////////////////////// INICIO //////////////////////////////////////////////////////////////////////////", cLogName)
	plsLogFil("DATA...........: " + DTOS(dDataBase), cLogName)
	plsLogFil("HORA...........: " + TIME()         , cLogName)
	plsLogFil("FUNÇÃO/METODO..: " + ProcName(1)    , cLogName)
	plsLogFil(" "                                  , cLogName)
	plsLogFil("ERRO...........: " + cError         , cLogName)
	plsLogFil("////////////////////////////////////////////////////////////////////// FIM  //////////////////////////////////////////////////////////////////////////", cLogName)
Return

