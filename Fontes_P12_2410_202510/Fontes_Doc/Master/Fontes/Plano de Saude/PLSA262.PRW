#INCLUDE "plsa262.ch"
#include "PROTHEUS.CH"

#include "PLSMGER.CH"
#define  K_DefExc  4
/*


Ŀ
Programa   PLSA262  Autor  Tulio Cesar           Data  24.06.2002 
Ĵ
Descrio  Exportacao ou impressao de identificacao de usuarios       
Ĵ
Uso        Advanced Protheus                                          
Ĵ
Parametros Nenhum                                                     
ٱ


*/
Function PLSA262
	
	local lUsBlV := GetNewPar("MV_PLBLQVE",.F.)

	private aRotina := MenuDef()
	private cDesCar := Posicione("BA0",1,xFilial("BA0")+PLSINTPAD(),"AllTrim(If(Empty(BA0_NOMCAR), 'Carto de Identificao', BA0_NOMCAR))") //'Carteira'
	private cCadastro := STR0010 + AllTrim(cDesCar) //"Exportacao/Emissao de "

	private	aCores := {{"BDE->BDE_STACAR == '1'", 'BR_VERDE'},;
					   {"BDE->BDE_STACAR == '2'", 'BR_VERMELHO'}}

	private aCdCores := {{"BR_VERDE", STR0011},; //'Em aberto'
						 {"BR_VERMELHO", STR0012}} //'Encerrado

	If lUsBlV
		AADD(aCores,   { "BDE->BDE_STACAR='3'", 'BR_AZUL'     })
		AADD(aCores,   { "BDE->BDE_STACAR='4'", 'BR_AMARELO'  })
		AADD(aCdCores, { 'BR_AZUL'            ,STR0041        })
		AADD(aCdCores, { 'BR_AMARELO'         ,STR0040        })
	EndIf

	aAdd(aCores, {"BDE->BDE_STACAR == '5'", "BR_LARANJA"})
	aAdd(aCores, {"BDE->BDE_STACAR == '6'", "BR_PRETO"})

	aAdd(aCdCores, {"BR_LARANJA", STR0046})
	aAdd(aCdCores, {"BR_PRETO", STR0047})

	If ExistBlock("PLBDEBTADD")
		aBtAdd := ExecBlock("PLBDEBTADD",.F.,.F.,{aRotina})
		If ValType(aBtAdd) == "A"
			AEval(aBtAdd,{|x| AAdd(aRotina,x)})
		EndIf
	EndIf

	BDE->(DBSetOrder(1))
	BDE->(mBrowse(06,01,22,75,'BDE',,,,,,aCores,,,,, .T. ))

Return

/*


Ŀ
Programa   PLSA262EXP  Autor  Tulio Cesar        Data  25.06.2002 
Ĵ
Descrio  Exportacao/Impressao de identificacao de usuario           
ٱ


*/
Function PLSA262EXP(cAlias,nReg,nOpc)
	Local I__f := 0

	Local oDlg
	Local oEnc
	Local aRet
	Local nOpca
	Local bOK
	Local bCancel
	Local _nH
	Local aPosObj   := {}
	Local aObjects  := {}
	Local aSize     := {}
	Local aInfo     := {}

	TCREFRESH(RetSqlName("BDE"))

	BEGIN TRANSACTION

		bOK     := {|| nOpca := 1, aRet := PLSA262Ext(oEnc:aGets,oEnc:aTela,M->BDE_CODINT,M->BDE_CODIGO,oDlg),If(aRet[1].and.aRet[2,1]>0,oDlg:End(),.f.) }
		bCancel := {|| nOpca := 0, oDlg:End() }

		//Ŀ
		// Define dialogo...                                                   
		//
		aSize := MsAdvSize()
		aObjects := {}
		AAdd( aObjects, { 1, 1, .T., .T., .F. } )

		aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 }
		aPosObj := MsObjSize( aInfo, aObjects )

		DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 To aSize[6],aSize[5] OF GetWndDefault() Pixel

		//Ŀ
		// Enchoice...                                                         
		//
		Copy cAlias To Memory Blank

		//se a validacao realizada na funcao PLSA262NUM indentificar que o codigo sequencial gerado esta duplicado, o codigo nao sera gerado
		//nao permitindo a abertura da rotina
		If !EMPTY(M->BDE_CODIGO)

			oEnc := BDE->(MsMGet():New(cAlias,nReg,nOpc,,,,,aPosObj[1],,,,,,oDlg,,,.F.))

			//Ŀ
			// Ativa o dialogo...                                                  
			//
			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,bOK,bCancel,.F.,{}) Center
		EndIf

		//Ŀ
		// Inclui movimento...                                                 
		//
		If nOpca = K_OK .and. aRet[1]
			M->BDE_QTD    := aRet[2,1]
			M->BDE_STACAR := "1"

			if M->BDE_TIPGER <> '2'
				BDE->(PLUPTENC("BDE",K_Incluir))
			endIf
		Endif

		If nOpca == 0
			RollBackSX8()
		Else 
			ConfirmSX8()
		EndIf

	END TRANSACTION

	TCREFRESH(RetSqlName("BDE"))

	If ExistBlock("PLS262GR") .And. nOpca == K_OK .And. aRet[1]
		ExecBlock("PLS262GR",.F.,.F.)
	Endif

	//Ŀ
	// Fim da Rotina...                                                    
	//
Return

/*


Ŀ
Programa   PLSA262EXT  Autor  Tulio Cesar        Data  25.06.2002 
Ĵ
Descrio  Trata rotina externa                                       
ٱ


*/
Static Function PLSA262Ext(aGets,aTela,cCodInt,cCodigo,oDlg)

	Local cExpRdm
	Local aRet := {.T.,{}}

	//Ŀ
	// Testa campos obrigatorios...                                        
	//
	If ! Obrigatorio(aGets,aTela)
		aRet := {.F.,{}}
		Return(aRet)
	Endif
	//Ŀ
	// Solicita confirmacao                                                
	//

	cMsg := chr(13) + STR0015 //"Voce deseja confirmar o processamento para os parametros informados ?"

	If  M->BDE_MUDVAL == "1"
		cMsg += chr(13)
		cMsg += chr(13)
		cMsg += STR0016 + chr(13)  //"obs: a data de validade dos usuarios selecionados sera alterada"
		If !Empty(M->BDE_DATVAL)
			cMsg += STR0017 + dtoc(M->BDE_DATVAL) //"          para "
		EndIf
	Endif

	If  Aviso(STR0018,cMsg, { STR0019,STR0020 },2) <> 1 //"Confirmacao"###"&Sim"###"&Nao"
		aRet := {.F.,{}}
		Return(aRet)
	Endif
	//Ŀ
	// Posiciona na Operadora...                                           
	//
	BA0->(DbSetOrder(1))
	If BA0->(MsSeek(xFilial("BA0")+cCodInt))
		If Empty(BA0->BA0_EXPIDE)
			cExpRdm := AllTrim(GetMV("MV_PLSEXPI"))
		Else
			cExpRdm := AllTrim(BA0->BA0_EXPIDE)
		Endif
		If ExistBlock(cExpRdm)
			aRet := ExecBlock(cExpRdm,.F.,.F.,{cCodigo,M->BDE_MOTIVO,cCodInt,oDlg})
		Else
			aRet := Plsa264({cCodigo,M->BDE_MOTIVO,cCodInt,oDlg,NIL,NIL,NIL,NIL,NIL,NIL,.T.,(M->BDE_TIPGER=='2')})
		EndIf

		If ValType(aRet) <> "A"
			aRet := {.T.,{0},{},{}}
		Endif

	Else
		aRet := {.F.,{},{},{}}
	Endif

	If  aRet[2,1] == 0
		aRet := {.F., {}}
		msgStop(STR0021) //"Nenhum usuario encontrado para os parametros informados"
	Endif

	//Ŀ
	// Fim da Rotina...                                                    
	//
Return(aRet)

/*


Ŀ
Programa   PLSA262VIS  Autor  Eduardo Motta      Data  15.04.2004 
Ĵ
Descrio  Visualizacao                                               
ٱ


*/
Function PLSA262VIS(cAlias,nReg,nOpc)
	Local I__f := 0

	Local aRet
	Local oDlg
	Local oEnc
	Local oGetBED
	Local nOpca    	:= 0
	Local aHeader  	:= {}
	Local aCols    	:= {}
	Local aVetTrab 	:= {}
	Local aPosObj   := {}
	Local aObjects  := {}
	Local aSize     := {}
	Local aInfo     := {}

	Private n 		:= 1


	If Len( aHeader ) == 0
		Store HEADER "BED" TO aHeader For .T.
	Endif


	If nOpc == K_Incluir
		Store COLS Blank "BED" TO aCols FROM aHeader
	Else
		aCols:= MntAcols(cAlias,nOpc,aHeader,aCols,aVetTrab)
	EndIf

	Copy cAlias To Memory Blank
	/*
Store Header "BED" to aHeader For .T.

DbSelectArea("BED")
DbSetOrder(4)

If MsSeek(xFilial("BED")+BDE->BDE_CODIGO)
	Store COLS "BED" TO aCols FROM aHeader VETTRAB aVetTrab While xFilial("BED") == BED->BED_FILIAL .and. BDE->BDE_CODIGO == BED->BED_CDIDEN
Else
	Store COLS Blank "BED" TO aCols FROM aHeader
EndIf
	*/
	aSize := MsAdvSize()
	aObjects := {}
	AAdd( aObjects, { 1,  1, .T., .T., .F. } )
	AAdd( aObjects, { 1, 70, .T., .F., .F. } )

	aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 }
	aPosObj := MsObjSize( aInfo, aObjects )

	DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 To aSize[6],aSize[5] OF GetWndDefault() Pixel

	oEnc := BDE->(MsMGet():New(cAlias,nReg,nOpc,,,,,aPosObj[1],,,,,,oDlg,,,.F.))
	oGetBED := TPLSBrw():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,4],aPosObj[2,3],nil  ,oDlg,nil    ,  ,nil    ,nil   ,nil, .T.   ,nil  ,.T.   ,nil   ,aHeader,aCols,.F.,"BED",nOpc,STR0022,nil,nil,nil,aVetTrab,,,) //"Lotes"

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||oDlg:End()},{||oDlg:End()},.F.,{}) Center

Return

/*


Ŀ
Programa   PLSA262ENC  Autor  Eduardo Motta      Data  15.04.2004 
Ĵ
Descrio  Encerramento do lote                                       
ٱ


*/
Function PLSA262ENC(cAlias,nReg,nOpc)
	Local I__f := 0

	Local oDlg
	Local oEnc
	Local aRet
	Local oGetBED
	Local nOpca    	:= 0
	Local aHeader  	:= {}
	Local aCols    	:= {}
	Local aVetTrab 	:= {}
	Local aPosObj   := {}
	Local aObjects  := {}
	Local aSize     := {}
	Local aInfo     := {}
	Local lBlqVEnc   := GetNewPar("MV_PLBLQVE",.F.)
	Local lContCp    := BED->( FieldPos("BED_CTRBLO") ) > 0 .And. BED->( FieldPos("BED_STAANB") ) > 0
	Local cSQLBED	 := ""
	Local aInfBl     := {}
	Local dBlqDat    := dDataBase
	Local cBloMot    := GetNewPar("MV_PLMOTBA","51")
	Local cBlqObs    := GetNewPar("MV_PLOBSBQ","")
	Local cTipoB     := "1"
	Local nI          := 0
	Local cBDELot    := ""
	Local aLotBlq    := {}
	Local aLotBDE    := {}
	Local cBDECdI    := ""
	Local lRet       := .F.
	Local aAreaBde 	 := BDE->(GetArea())
	Local lPosBed    := .T.
	Local cQuery     := ""
	Local nRecno     := 0

	Private n 		:= 1

	If lBlqVEnc .And. !lContCp
		MsgStop(STR0042) //"Parmetro MV_PLBLQVE Ativo, porm o Dicionrio de dados est desatualizado.!!!"
		Return
	EndIf

	SX5->(DbSetOrder(1))

	If lBlqVEnc

		If cBloMot >= "50"

			lRet := SX5->(DbSeek(xFilial("SX5")+"BG"+cBloMot))

			If !lRet
				msginfo(STR0043)  //"Cdigo de Bloqueio no existe na Tabela BG."
				Return
			EndIf
		Else
			msginfo(STR0044)  //"Escolha um codigo referente a bloqueio."
			Return
		EndIf
	EndIf

	aCols:= MntAcols(cAlias,nOpc,aHeader,aCols,aVetTrab)

	Copy cAlias To Memory Blank

	aSize := MsAdvSize()
	aObjects := {}
	AAdd( aObjects, { 1,  1, .T., .T., .F. } )
	AAdd( aObjects, { 1, 70, .T., .F., .F. } )

	aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 }
	aPosObj := MsObjSize( aInfo, aObjects )

	DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 To aSize[6],aSize[5] OF GetWndDefault() Pixel

	oEnc := BDE->(MsMGet():New(cAlias,nReg,nOpc,,,,,aPosObj[1],,,,,,oDlg,,,.F.))
	oGetBED := TPLSBrw():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,4],aPosObj[2,3],nil  ,oDlg,nil    ,  ,nil    ,nil   ,nil, .T.   ,nil  ,.T.   ,nil   ,aHeader,aCols,.F.,"BED",nOpc,STR0022,nil,nil,nil,aVetTrab,,,) //"Lotes"

	M->BDE_CODIGO := BDE->BDE_CODIGO
	M->BDE_MOTIVO := BDE->BDE_MOTIVO
	M->BDE_TIPGRU := BDE->BDE_TIPGRU
	M->BDE_UNILOC := BDE->BDE_UNILOC
	M->BDE_EMPDE  := BDE->BDE_EMPDE
	M->BDE_EMPATE := BDE->BDE_EMPATE
	M->BDE_CONDE  := BDE->BDE_CONDE
	M->BDE_CONATE := BDE->BDE_CONATE
	M->BDE_SUBDE  := BDE->BDE_SUBDE
	M->BDE_SUBATE := BDE->BDE_SUBATE
	M->BDE_MATDE  := BDE->BDE_MATDE
	M->BDE_MATATE := BDE->BDE_MATATE
	M->BDE_TIPGER := BDE->BDE_TIPGER
	M->BDE_DATA1  := BDE->BDE_DATA1
	M->BDE_DATA2  := BDE->BDE_DATA2
	M->BDE_DIRGRV := BDE->BDE_DIRGRV
	M->BDE_MUDVAL := BDE->BDE_MUDVAL
	M->BDE_DATVAL := BDE->BDE_DATVAL
	M->BDE_QTD    := BDE->BDE_QTD
	M->BDE_STACAR := BDE->BDE_STACAR
	M->BDE_EMPRES := BDE->BDE_EMPRES
	M->BDE_DATENT := BDE->BDE_DATENT
	If BED->( FieldPos("BED_GRPDE") ) > 0 .AND. BED->( FieldPos("BED_GRPATE") ) > 0
		M->BDE_GRPDE  := BDE->BDE_GRPDE
		M->BDE_GRPATE := BDE->BDE_GRPATE
	EndIf

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca := 1,oDlg:End()},{||nOpca := 0,oDlg:End()},.F.,{}) Center

	If nOpca == 1

		If !(BDE->BDE_STACAR $ "1/4")
			MsgStop(STR0023) //"Somente lotes em aberto podem ser encerrados."
			Return
		EndIf

		// Query para verificar se tem algum lote aguardando pagamento do titulo
		cQuery := "SELECT BED_FATUR FROM "+RetSqlName("BED")+ " BED "
		cQuery += "WHERE BED_FILIAL = '"+xFilial("BED")+"' AND "
		cQuery += "BED_CDIDEN = '"+BDE->BDE_CODIGO+"' AND "
		cQuery += "BED_FATUR = '2' AND " // Aguardando Pagamento
		cQuery += "BED.D_E_L_E_T_ = ' ' "

		dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TrbBED",.F.,.T.)

		If !TrbBED->(Eof())
			MsgStop(STR0045) //"No  possivel encerrar o lote enquanto tiver titulos aguardando o pagamento"
			TrbBED->(DbCloseArea())
			Return
		Endif

		TrbBED->(DbCloseArea())

		BEGIN TRANSACTION

			BDE->(RecLock("BDE",.F.))
			BDE->BDE_STACAR := "2"
			BDE->BDE_EMPRES := M->BDE_EMPRES
			BDE->BDE_DATENT := M->BDE_DATENT
			cBDELot := BDE->BDE_CODIGO
			cBDECdI := BDE->BDE_CODINT

			BDE->(MsUnlock())

			BA1->(dbsetOrder(2))
			BED->(DbSetOrder(4))
			BED->(MsSeek(xFilial("BED")+BDE->BDE_CODIGO))

			While xFilial("BED") == BED->BED_FILIAL .and. BDE->BDE_CODIGO == BED->BED_CDIDEN
				//Ŀ
				// Atualiza status de cada cartao do lote                              
				//
				BED->(RecLock("BED",.F.))
				BED->BED_STACAR := "2"
				BED->(MsUnlock())
				If lBlqVEnc .And. lContCp
					AADD(aLotBlq,{BED->BED_CODINT+BED->BED_CODEMP+BED->BED_MATRIC+BED->BED_TIPREG+BED->BED_DIGITO,BED->BED_CDIDEN,BED->BED_CTRBLO})
				EndIf
				//Ŀ
				// Atualiza status de emissao de cartao no usuario                     
				//
				If BA1->(msSeek(xFilial("BA1")+BED->(BED_CODINT+BED_CODEMP+BED_MATRIC+BED_TIPREG+BED_DIGITO))) .and. ;
						BA1->BA1_EMICAR == "2"
					If BA1->(RecLock("BA1",.F.))
						BA1->BA1_EMICAR := "3" // gerado
						BA1->(msUnLock())
					Endif
				Endif
				//Ŀ
				// Atualiza status de cada cartao do lote                              
				//
				//Ŀ
				// Acessa proximo cartao do lote                                       
				//
				BED->(DbSkip())
			EndDo

			If !Empty(cBloMot) .And. !Empty(cTipoB) .And. Len(aLotBlq) >= 1

				B1D->(DbSetOrder(1))

				For nI:=1   To Len(aLotBlq)

					cSql := " SELECT R_E_C_N_O_ RECNO FROM "+ RetSqlName("BED") + " "
					cSql += " WHERE "
					cSql += "  BED_FILIAL='" + xFilial("BED") + "' "
					cSql += "  AND BED_CODINT = '" + SubStr(aLotBlq[nI,1],1,4) + "' "
					cSql += "  AND BED_CODEMP = '" + SubStr(aLotBlq[nI,1],5,4) + "' "
					cSql += "  AND BED_MATRIC = '" + SubStr(aLotBlq[nI,1],9,6) + "' "
					cSql += "  AND BED_FATUR  <> '' "
					cSql += "  AND BED_CDIDEN < '" + cBDELot + "' "
					cSql += "  AND BED_TIPREG = '" + SubStr(aLotBlq[nI,1],15,2) + "' "
					cSql += "  AND BED_DIGITO = '" + SubStr(aLotBlq[nI,1],17,1) + "' "
					cSql += "  AND BED_BLOIDE <> '1' "
					cSql += "  AND BED_STACAR = '1' "
					cSql += "  AND D_E_L_E_T_ = '' "

					cSql:= ChangeQuery(cSql)

					dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSql),"TrbBED",.F.,.T.)

					While !TrbBED->(Eof())

						nRecno:= TrbBED->RECNO

						If nRecno > 0

							BED->(DBGOTO(nRecno))
							RecLock("BED", .F.)

							BED->(RecLock("BED",.F.))
							BED->BED_STACAR := "3"		// Via Bloqueada
							BED->BED_CTRBLO := cBDELot
							BED->(MsUnlock())

							If lPosBed

								AADD(aLotBDE,{BED->BED_FILIAL, BED->BED_CODINT,BED->BED_CDIDEN,BED->BED_CTRBLO})

							Else
								If(Ascan(aLotBDE,{|x| x[1]+ x[2]+ x[3] == BED->BED_FILIAL+BED->BED_CODINT+BED->BED_CDIDEN}))=0
									AADD(aLotBDE,{BED->BED_FILIAL, BED->BED_CODINT,BED->BED_CDIDEN,BED->BED_CTRBLO})

								EndIf
							EndIf
							lPosBed := .F.
							//Ŀ
							// Crio historico do (des)bloqueio das Vias                            
							//

							BlqIdent("1",dDataBase,cBloMot,cBlqObs)

						Endif
						TrbBED->(dbSkip())
					EndDo
					IIF(SELECT('TrbBED')>0,TrbBED->(DbCloseArea()),"")

				Next nI

				If Len(aLotBDE)>=1

					PLAJCABDE(aLotBDE,"1") //atualizo cabecalho dos lotes bloqueados

				EndIf

			EndIf

		END TRANSACTION

	EndIf

	Restarea(aAreaBDE)

Return

/*


Ŀ
Programa   PLSA262NUM  Autor  Tulio Cesar        Data  25.06.2002 
Ĵ
Descrio  Retorna proximo numero                                     
ٱ


*/
Function PLSA262NUM(cOperadora, lChmWeb, lAutmacao)

	Local nOpc := 0
	Local cNum := GetSxeNum("BDE","BDE_CODIGO",xFilial("BDE") + cOperadora)

	Default cOperadora := "0000"
	Default lAutmacao  := .F.
	Default lChmWeb	:= iif(funName() == "RPC", .T., .F.)

	BDE->(DbSetOrder(1))

	If BDE->(MsSeek(xFilial("BDE") + cOperadora + cNum))
		
		If !lAutmacao .AND. !lChmWeb

			nOpc := Aviso( 'Entre em Contato Com o Suporte',;
				'O cdigo gerado para o lote, corresponde a um cdigo de outro lote j gerado, ser necessrio ajustar atravs do configurador o controle de numerao (alias BDE) '+;
				'com a chave "' + xFilial("BDE") + cOperadora + '" para um cdigo inexistente.' + CHR(13)+CHR(10)+CHR(13)+CHR(10) +;
				'Clique no boto de documentao, copie o link que ser exibido no navegador e envie para o suporte.',;
				{"OK", "Documentao"},;
				3,;
				)

			If nOpc == 2 //Exibe documentacao

				ShellExecute("Open", "https://tdn.totvs.com/pages/releaseview.action?pageId=309411140", "", "", 1)
			EndIf
		Endif
		cNum := ""	
	EndIf

Return cNum

/*


Ŀ
Programa   PLSA262EXC  Autor  Tulio Cesar        Data  25.06.2002 
Ĵ
Descrio  Exclui identificacao de usuario                            
ٱ


*/
Function PLSA262EXC(cAlias,nReg,nOpc)
	Local I__f 		:= 0

	Local oDlg
	Local oEnc
	Local cSQL		:= ""
	Local cCodInt	:= ""
	Local cCodEmp	:= ""
	Local cMatric	:= ""
	Local cTipReg	:= ""
	Local cDigito	:= ""
	Local nRegBED   := 0
	Local nOrdBED   := 0
	Local nOrdBBT   := 0
	Local nOrdSE1   := 0
	Local nOpca     := 0
	Local nUltVia   := 0
	Local lDeleta   := .T.
	Local aVetor    := {}
	Local cArea     := Alias()
	Local cQuebra   := Chr(13)
	Local cOperad   := BDE->BDE_CODINT
	Local cCodigo   := BDE->BDE_CODIGO
	Local bOK       := { || (Iif(ExistBlock("PLSA262EXC"),If(ExecBlock("PLSA262EXC",.F.,.F.,{cOperad,cCodigo}),(nOpca := 1, oDlg:End()),.F.),(nOpca := 1, oDlg:End())))}
	Local bCancel   := { || oDlg:End() }
	Local aPosObj   := {}
	Local aObjects  := {}
	Local aSize     := {}
	Local aInfo     := {}
	Local aRetBED   := {}
	LOCAL aCriticas := {}
	Local lCriticas := .F.
	

	SE1->(DbSetOrder(1))

	If BDE->BDE_STACAR == "2"
		MsgStop(STR0024) //"Lote j encerrado e no poder ser excludo!"
		Return
	EndIf
	If BDE->BDE_STACAR $ "3,4"
		MsgStop(STR0039) //"Lote com Bloqueio Total ou Parcial, no poder ser excludo!"
		Return
	EndIf

	//Ŀ
	// Define dialogo...                                                   
	//
	aSize := MsAdvSize()
	aObjects := {}
	AAdd( aObjects, { 1, 1, .T., .T., .F. } )

	aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 }
	aPosObj := MsObjSize( aInfo, aObjects )

	DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 To aSize[6],aSize[5] OF GetWndDefault() Pixel

	//Ŀ
	// Enchoice...                                                         
	//
	Copy cAlias To Memory

	oEnc := BDE->(MsMGet():New(cAlias,nReg,K_Visualizar,,,,,aPosObj[1],,,,,,oDlg,,,.F.))

	//Ŀ
	// Ativa o dialogo...                                                  
	//
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,bOK,bCancel,.F.,{}) Center

	//Ŀ
	// Define tratamento de acordo com a opcao...                          
	//
	If nOpca == K_OK

		cSQL := " SELECT R_E_C_N_O_ REG FROM " + RetSQLName("BED")
		cSQL += " WHERE BED_FILIAL = '" + xFilial("BED") + "' AND "
		cSQL += "       BED_CODINT = '" + cOperad + "' AND "
		cSQL += "       BED_CDIDEN = '" + cCodigo + "' AND "
		cSQL += "       D_E_L_E_T_ <> '*' "

		PLSQuery(cSQL,"TrbA262")

		While ! TrbA262->(Eof())

			//Ŀ
			// Posiciona BED...   							                        
			//
			BED->(DbGoTo(TrbA262->(REG)))

			//Ŀ
			// Verifica se foi faturada...                                         
			//
			If SE1->(MsSeek(xFilial("SE1")+BED->(BED_PREFIX + BED_NUMTIT + BED_PARCEL + BED_TIPTIT)))

				If BED->BED_FATUR == "1"
					Aadd(aCriticas, {BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG),STR0025})//"No  possvel excluir este lanamento pois ele j foi faturado!"###"Usurio: "
					lDeleta := .F.
				Else
					If SE1->E1_SALDO = 0
						Aadd(aCriticas, {BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG),STR0027})//"No  possvel excluir este lanamento pois ele j foi pago!"###"Usurio: "
						lDeleta := .F.
					Endif
				Endif

			EndIf

			//Ŀ
			// Verifica se eh o ultimo lote emitido para este usuario...           
			//
			cCodInt := BED->BED_CODINT
			cCodEmp := BED->BED_CODEMP
			cMatric := BED->BED_MATRIC
			cTipReg := BED->BED_TIPREG
			cDigito := BED->BED_DIGITO

			aRetBED := PL261UVC(cCodInt, cCodEmp, cMatric, cTipReg, , )
			nUltVia := aRetBED[1]

			If nUltVia >= 0
				If nUltVia <> BED->BED_VIACAR
					Aadd(aCriticas, {BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG),STR0028})//"Somente a ltima via do carto do usurio pode ser excluda!"###"Usurio: "
					lDeleta := .F.
				Endif
			Else
				Aadd(aCriticas, {BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG),STR0029})//"ltima via do carto do usurio no encontrada. Verifique!"
				lDeleta := .F.
			Endif

			//Ŀ
			// Verifica se a via do cartao esta bloqueada...           			
			//
			If BED->( FieldPos("BED_CODBLO") ) = 0 .AND. BED->( FieldPos("BED_BLOIDE") ) = 0
				Aadd(aCriticas, {BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG),STR0030})//"Dicionario de dados desatualizado!!!"
				lDeleta := .F.
			Else
				IF BED->BED_BLOIDE == "1"
					Aadd(aCriticas, {BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG),STR0031})//"Via do Carto no pode ser excluida pois est bloqueada!"
					lDeleta := .F.
				Endif
			Endif

			If BED->BED_ORIGEM != 'REEMITE' .and. BED->BED_ORIGEM != 'PLSA262' .and. BED->BED_ORIGEM != 'RPC'
				Aadd(aCriticas, {BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG),STR0038})//"Via de carto do usurio emitida pela rotina de Lanamentos Avulsos, o registro no ser excludo."
				lDeleta := .F.
			Endif

			TrbA262->(DbSkip())
		EndDo

		TrbA262->(DbGoTop())

		If lDeleta

			BEGIN TRANSACTION

				While ! TrbA262->(Eof())

					//Ŀ
					// Posiciona BED...   							                        
					//
					BED->(DbGoTo(TrbA262->(REG)))

					//Ŀ
					// Alimenta variaveis...                                        		
					//
					cCodInt := BED->BED_CODINT
					cCodEmp := BED->BED_CODEMP
					cMatric := BED->BED_MATRIC
					cTipReg := BED->BED_TIPREG
					cDigito := BED->BED_DIGITO

					//Ŀ
					// Atualiza dados no usuario...                                        
					//
					If BED->BED_FATUR <> "2"
						BA1->(DbSetOrder(2))
						If BA1->(MsSeek(xFilial("BA1")+cCodInt+cCodEmp+cMatric+cTipReg))

							BA1->(RecLock("BA1",.F.))

							If BA1->BA1_VIACAR > 1 
								If aRetBED[1] >= 0
									if alltrim(upper(BED->BED_ORIGEM)) == "REEMITE"
										BA1->BA1_VIACAR := aRetBED[1]
										BA1->BA1_CDIDEN := "AVULSA"
									else
										BA1->BA1_VIACAR := aRetBED[1] - 1
										BA1->BA1_CDIDEN := aRetBED[4]
										BA1->BA1_DTVLCR := aRetBED[3]
									endif
				
									GrvVldCarUsr(BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC),aRetBED[3])
								Else
									Aadd(aCriticas, {BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG),STR0032})//"No foi encontrada a Via anterior do Carto. Verifique!"###"Usurio: "
								Endif
							Else
								if alltrim(upper(BED->BED_ORIGEM)) == "REEMITE"
									BA1->BA1_VIACAR := 1
									BA1->BA1_CDIDEN := "AVULSA"
								else
									BA1->BA1_VIACAR := 0
									BA1->BA1_CDIDEN := ""
									BA1->BA1_DTVLCR := Stod("")
								endif

								GrvVldCarUsr(BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC),BA1->BA1_DTVLCR)			
							Endif

							BA1->(MsUnLock())

						Endif
					EndIf

					//Ŀ
					// Atualiza Financeiro... 		                                        
					//
					nOrdBBT := BBT->(IndexOrd())
					BBT->(DbSetOrder(7))

					If BBT->(MsSeek(xFilial("BBT")+BED->(BED_PREFIX + BED_NUMTIT + BED_PARCEL + BED_TIPTIT)))

						BBT->(RecLock("BBT",.F.))
						BBT->(DbDelete())
						BBT->(MsUnLock())

					Endif

					BBT->(DbSetOrder(nOrdBBT))

					nOrdSE1 := SE1->(IndexOrd())
					SE1->(DbSetOrder(1))

					If SE1->(MsSeek(xFilial("SE1")+BED->(BED_PREFIX + BED_NUMTIT + BED_PARCEL + BED_TIPTIT)))

						nOldMod := nModulo
						nModulo := 6

						aVetor  := {	{"E1_PREFIXO" ,SE1->E1_PREFIXO ,Nil},;
							{"E1_NUM"	  ,SE1->E1_NUM     ,Nil},;
							{"E1_PARCELA" ,SE1->E1_PARCELA ,Nil},;
							{"E1_TIPO"	  ,SE1->E1_TIPO    ,Nil},;
							{"E1_NATUREZ" ,SE1->E1_NATUREZ ,Nil} }

						//Ŀ
						// Exclui registro em SE1...	                                        
						//
						MSExecAuto({|x,y| Fina040(x,y)},aVetor,5)

						nModulo := nOldMod

					Endif

					SE1->(DbSetOrder(nOrdSE1))

					//Ŀ
					// Atualiza BED...														
					//

					If AllTrim(FunName()) == AllTrim(BED->BED_ORIGEM) .or. upper(alltrim(BED->BED_ORIGEM)) == "RPC"
						BED->(RecLock("BED",.F.))
						BED->(DbDelete())
						BED->(MsUnLock())
					EndIf
					
					If BED->BED_CDIDEN <> "AVULSA"
						BDE->(RecLock("BDE",.F.))
						If BDE->BDE_QTD == 1
							BDE->(DbDelete())
						Else
							BDE->BDE_QTD := BDE->BDE_QTD -1
						Endif
						BDE->(MsUnLock())
					Endif

					//Ŀ
					// Exclui BDE... 						                        		
					//
					BED->(RecLock("BED",.F.))
					BED->BED_ORIGEM := 'PLSA261'
					BED->BED_CDIDEN := 'AVULSA'
					BED->(MsUnLock())
					
					BDE->(PLUPTENC("BDE",K_Excluir))

					TrbA262->(DbSkip())
				EndDo

			END TRANSACTION

		Endif

		//Ŀ
		// Fecha Temporario... 						                        
		//
		TrbA262->(DbCloseArea())

	Endif

	If ! Empty(cArea)
		DbSelectArea(cArea)
	Endif

	//Ŀ
	// Apresenta as critinas no final...                                   
	//
	If Len(aCriticas) > 0
		Aviso("Crticas","Houveram crticas no processamento!",{"Visualizar"})

		PLSCRIGEN(aCriticas,{ 	{"Matricula","@!", 70},; //"Matrcula"
			{"Critica","@!", 170 }},"Criticas")
	Endif

	//Ŀ
	// Fim da Rotina...                                                    
	//
Return


/*


Ŀ
Programa   PLSA262Prn  Autor Wagner Mobile Costa Data  28.08.2003 
Ĵ
Descrio  Emite as carteiras do lote selecionado                     
ٱ


*/
Function PLSA262PT()
Return Plsa262Prn()

Function PLSA262Prn(cCodLote)
	Local aRet	  	:= {}
	Local cExpRdm 	:= ""
	Local cCodInt 	:= ""
	Local cCodEmp 	:= ""
	Local cMatric 	:= ""
	Local cTipReg 	:= ""
	Local nI      	:= 0
	Local aRecno  	:= {}
	Local lNew 	  	:= .F.
	local lImpressao:= .f.
	Local cOperad 	:= PlsIntPad()
	Local nUltVia 	:= 0
	Local lImprim 	:= .T.
	Local lAgrupa 	:= .T.
	Local cQuebra 	:= Chr(13)
	Local nTipPes 	:= 1   // 1=todas   2=fisica   3=juridica
	Local lErro   	:= .F.
	Local lReturn   := .F.
	Local lReemissao:= .F.

	If cCodLote == Nil
		If !Pergunte("PLS263")
			Return
		EndIf

		cCodLote 	:= RTrim(MV_PAR01)
		lImpressao 	:= Str(MV_PAR02,1) == "2"
		lImprim  	:= If(MV_PAR03==1,.T.,.F.)
		nTipPes  	:= MV_PAR05   // 1=todas   2=fisica   3=juridica
	EndIf

	If IsIncallStack("PLSA262PT")
		lReemissao := .T.
	EndIf

	BEGIN TRANSACTION

		If cCodLote <> "AVULSA"

			BDE->(DbSetOrder(1))
			If !BDE->(MsSeek(xFilial("BDE")+cOperad+cCodLote))
				MsgStop(STR0033) //"Lote no encontrado!"
				lReturn := .T.
			EndIf

		Else

			lNew := .T.

			BED->(DbSetOrder(4))
			BED->(MsSeek(xFilial("BED")+PadR(cCodLote,12)))

			While !BED->(Eof()) .and. PadR(cCodLote,12) == BED->BED_CDIDEN
				BA3->(DbSetOrder(1))
				BA3->(msSeek(xFilial("BA3")+BED->BED_CODINT+BED->BED_CODEMP+BED->BED_MATRIC))
				lErro := .F.
				If nTipPes > 1
					If nTipPes == 2 // somente pessoa fisica
						If BA3->BA3_TIPOUS == "2"  // SE CONTRATO FOR DE PESSOA JURIDICA PULA
							lErro := .T.
						EndIf
					ElseIf nTipPes == 3  // somente pessoa juridica
						If BA3->BA3_TIPOUS == "1"  // SE CONTRATO FOR DE PESSOA FISICA PULA
							lErro := .T.
						EndIf
					EndIf
				EndIf
				If !lErro
					aadd(aRecno,BED->(Recno()))
				EndIf
				BED->(DbSkip())
			EndDo

			if len(aRecno) == 0
				MsgInfo("No foram encontrados lanamentos avulsos pendentes para realizar o processamento.")
				lReturn := .T.
			else
				//Ŀ
				// Grava lote													
				//
				cCodLote := PLSA262NUM(cOperad)

				If !EMPTY(cCodLote)

					BDE->(DbSetOrder(1))

					BDE->(RecLock("BDE",.T.))
					BDE->BDE_FILIAL := xFilial("BDE")
					BDE->BDE_CODINT := cOperad
					BDE->BDE_CODIGO := cCodLote
					BDE->BDE_UNILOC := "1"
					BDE->BDE_TIPGRU := "3"
					BDE->BDE_STACAR := "1"
					BDE->BDE_TIPGER := Str(MV_PAR02,1)
					BDE->(MsUnlock())

					For nI := 1 to Len(aRecno)
						//Ŀ
						// Posiciona BED...											
						//
						BED->(DbGoto(aRecno[nI]))
						//Ŀ
						// Alimenta variaveis...										
						//
						cCodInt := BED->BED_CODINT
						cCodEmp := BED->BED_CODEMP
						cMatric := BED->BED_MATRIC
						cTipReg := BED->BED_TIPREG
						//Ŀ
						// Compoe o Lote somente se for a Ultima Via do Usuario...		
						//
						nUltVia := PL261UVC(cCodInt, cCodEmp, cMatric, cTipReg, 1)[1]
						//Ŀ
						// Validacao													
						//
						If BED->BED_VIACAR = nUltVia
							lAgrupa := .T.
						Else
							lAgrupa := .F.
						Endif
						//Ŀ
						// Verifica se a Via esta bloqueada...                                 
						//
						If BED->( FieldPos("BED_CODBLO") ) = 0 .AND. BED->( FieldPos("BED_BLOIDE") ) = 0
							MsgStop(STR0030) //"Dicionario de dados desatualizado!!!"
							lAgrupa := .F.
						Else
							If BED->BED_BLOIDE == "1"
								MsgStop(STR0034 + cQuebra + STR0026 + BED->(BED_CODINT+BED_CODEMP+BED_MATRIC+BED_TIPREG)) //"Via do carto no ser emitida pois se encontra bloqueada!"###"Usurio: "
								lAgrupa := .F.
							Endif
						Endif
						//Ŀ
						// Checa e cria o registro									    
						//
						If lAgrupa
							BED->(RecLock("BED",.F.))
							BED->BED_CDIDEN := cCodLote
							BED->(MsUnlock())
						Endif

						If lReemissao
							BED->(RecLock("BED",.F.))
							BED->BED_ORIGEM := "REEMITE"
							BED->(MsUnLock())
						EndIf
					Next
				Else
					lReturn := .T.
					aRet := {.F.,{0}}
				EndIf
			EndIf
		EndIf

		If !lReturn
			//Ŀ
			// Posiciona na Operadora...                                           
			//
			aRet := {.F.,{0}}

			BA0->(DbSetOrder(1))

			If BA0->(MsSeek(xFilial("BA0")+BDE->BDE_CODINT))

				If Empty(BA0->BA0_EXPIDE)
					cExpRdm := AllTrim(GetMV("MV_PLSEXPI"))
				Else
					cExpRdm := AllTrim(BA0->BA0_EXPIDE)
				Endif

				If ExistBlock(cExpRdm)
					aRet := ExecBlock(cExpRdm,.F.,.F.,{BDE->BDE_CODIGO,BDE->BDE_MOTIVO,BDE->BDE_CODINT,NIL,5,.t.,lImprim,NIL,lNew,NIL,.T.,lImpressao})
				Else
					aRet := Plsa264({BDE->BDE_CODIGO,BDE->BDE_MOTIVO,BDE->BDE_CODINT,NIL,5,.t.,lImprim,NIL,lNew,NIL,.T.,lImpressao})
				EndIf

				If ValType(aRet) <> "A" .or. Len(aRet) == 0
					aRet := {.T.,{0},{},{}}
				Endif

			Endif

			If aRet[1]
				If lNew
					BDE->(RecLock("BDE",.F.))
					BDE->BDE_QTD := aRet[2,1]
					BDE->(MsUnlock())
					MsgStop(STR0035 + cCodLote) //"Gerado lote "
				Endif
			Elseif !lReemissao
				BDE->(RecLock("BDE",.F.))
				BDE->(DbDelete())
				BDE->(MsUnlock())
			EndIf

			Iif(aRet[1], ConfirmSX8(), RollBackSX8())
		Else
			aRet := {.F.,{0}}
		EndIf

	END TRANSACTION

Return(aRet)

/*/
	
	
	Ŀ
	Funcao     PLSA262LEG  Autor  Wagner Mobile Costa  Data  28.08.03 
	Ĵ
	Descricao  Exibe a legenda...                                         
	ٱ
	
	
/*/
Function PLSA262Leg()

	Local aLegenda := aClone(aCdCores)

	BrwLegenda(cCadastro,STR0036 ,aLegenda) //"Status"

	fwFreeArray(aLegenda)

Return

/*


ͻ
Programa  RetDtVld  Autor  Thiago Machado Correa Data   17/11/05   
͹
Desc.     Retorna data de validade                                     
͹
Uso        AP                                                          
ͼ


*/
Static Function RetDtVld(dDatBas)

	LOCAL cAno 	  := ""
	LOCAL cDia 	  := ""
	LOCAL cMes 	  := ""
	LOCAL nCnt    := 0
	LOCAL nMeses  := 0
	LOCAL dRet    := StoD("")

	cAno := Substr(dtoS(dDatBas),1,4)
	cMes := Substr(dtoS(dDatBas),5,2)
	cDia := Substr(dtoS(dDatBas),7,2)

	//Posiciona BA3 e BQC
	BA3->(DbSetOrder(1))
	BQC->(DbSetOrder(1))

	BA3->(DbSeek(xFilial("BA3")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC)))
	BQC->(DbSeek(xFilial("BQC")+BA3->(BA3_CODINT+BA3_CODEMP+BA3_CONEMP+BA3_VERCON+BA3_SUBCON+BA3_VERSUB)))

	//Alimenta Periodo de Renovacao
	If BA3->BA3_TIPOUS == "2"
		nMeses := BQC->BQC_NPERRN
	Else
		nMeses := GetMV("MV_PLSPRPF")
	Endif

	//Calcula data de validade
	cMes := Val(cMes)
	For nCnt := 1 To nMeses
		cMes += 1
		If cMes > 12
			cMes := 1
			cAno := StrZero((Year(dDataBase)+1),4)
		Endif
	Next
	cMes := StrZero(cMes,2)

	//Alimenta campo
	dRet := cTod(cDia+"/"+cMes+"/"+cAno)

	If ExistBlock("PLS262DT")
		dRet := ExecBlock("PLS262DT",.F.,.F.,{dRet})
	Endif

Return dRet


/*


ͻ
Programa  PLSA262RPTAutor  Geraldo Felix Junior Data   16/05/06   
͹
Desc.      Imprime relatorio de conferencia...                        
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function PLSA262RPT()
	// Chama relatorio com parametros ja estabelecidos...
	PLSR038(	BDE->BDE_CODINT,;
		BDE->BDE_DATA1,;
		BDE->BDE_DATA2,;
		BDE->BDE_EMPDE,;
		BDE->BDE_EMPATE,;
		BDE->BDE_CONDE,;
		BDE->BDE_CONATE,;
		BDE->BDE_SUBDE,;
		BDE->BDE_SUBATE,;
		BDE->BDE_MATDE,;
		BDE->BDE_MATATE,;
		BDE->BDE_CODIGO,;
		1,;
		1)

Return()

/*


ͻ
Programa  MntAcols  Autor  Otacilio A. Junior   Data  28/03/2007  
͹
Desc.      Monta aCols para ser utilizado na Getdados                 
                                                                      
͹
Uso        AP                                                         
ͼ


*/
Function MntAcols(cAlias,nOpc,aHeader,aCols,aVetTrab)

	Local nCntFor,nX
	Local aStruBED := BED->(DbStruct())


	If Len( aHeader ) == 0
		Store HEADER "BED" TO aHeader For .T.
	Endif

	If nOpc == K_Incluir
		Store COLS Blank "BED" TO aCols FROM aHeader
	Else

		cQuery := ""

		lQuery := .T.

		cAliasBED := "QRYBED"

		cQuery := "SELECT BED.* "
		cQuery += " FROM "
		cQuery += RetSqlName("BED")+ " BED "
		cQuery += " WHERE "
		cQuery += "BED_FILIAL = '"+xFilial("BED")+"' AND "
		cQuery += "BED_CDIDEN = '"+BDE->BDE_CODIGO+"' AND "
		cQuery += "BED.D_E_L_E_T_ = ' ' "

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasBED,.F.,.T.)

		For nCntFor := 1 To Len(aStruBED)
			If ( aStruBED[nCntFor,2]<>"C" )
				TcSetField(cAliasBED,aStruBED[nCntFor,1],aStruBED[nCntFor,2],aStruBED[nCntFor,3],aStruBED[nCntFor,4])
			EndIf
		Next nCntFor

		While !Eof()

			Aadd(aCols,Array(Len(aHeader)+1))

			BED->(MsGoto((cAliasBED)->R_E_C_N_O_))

			For nX := 1 To Len(aHeader)
				If ( aHeader[nX,10] !=  "V" )
					aCols[Len(aCols)][nX] := (cAliasBED)->(FieldGet(FieldPos(aHeader[nX,2])))
				Else
					aCols[Len(aCols)][nX] := CriaVar(aHeader[nX,2],.T.)
				EndIf
			Next nX
			aCols[Len(aCols)][Len(aHeader)+1] := .F.

			Aadd(aVetTrab, (cAliasBED)->R_E_C_N_O_ )

			dbSelectArea(cAliasBED)
			dbSkip()
		EndDo

		If Empty(aCols)
			BED->(MsGoto(0))
			Store COLS Blank "BED" TO aCols FROM aHeader
		EndIf

		(cAliasBED)->(dbCloseArea())
		dbSelectArea("BED")
	EndIf
Return(aCols)

/*/
	
	
	Ŀ
	Programa  MenuDef    Autor  Darcio R. Sporl        Data 02/01/2007
	Ĵ
	Descrio  Utilizacao de menu Funcional                               
	                                                                      
	                                                                      
	Ĵ
	Retorno   Array com opcoes da rotina.                                 
	Ĵ
	ParametrosParametros do array a Rotina:                               
	          1. Nome a aparecer no cabecalho                             
	          2. Nome da Rotina associada                                 
	          3. Reservado                                                
	          4. Tipo de Transao a ser efetuada:                        
	          		1 - Pesquisa e Posiciona em um Banco de Dados           
	              2 - Simplesmente Mostra os Campos                       
	              3 - Inclui registros no Bancos de Dados                 
	              4 - Altera o registro corrente                          
	              5 - Remove o registro corrente do Banco de Dados        
	          5. Nivel de acesso                                          
	          6. Habilita Menu Funcional                                  
	Ĵ
	   DATA    Programador   Manutencao efetuada                         
	Ĵ
	                                                                     
	ٱ
	
	
/*/
Static Function MenuDef()
	Private aRotina := {	{ STR0001	,'AxPesqui'  , 0 , K_Pesquisar  , 0, .F.},; //"Pesquisar"
	{ STR0002	,'PLSA262VIS', 0 , K_Visualizar , 0, Nil},; //"Visualizar"
	{ STR0003	,'PLSA262EXP', 0 , K_Incluir    , 0, Nil},; //"E&xportar"
	{ STR0004	,'PLSA262EXC', 0 , K_DefExc     , 0, Nil},; //"&Excluir"
	{ STR0005	,'PLSA262ENC', 0 , K_Visualizar , 0, Nil},; //"E&ncerrar Lote"
	{ STR0006	,'PLSA262PT' , 0 , K_Incluir    , 0, Nil},; //"Reemitir"
	{ STR0007	,'PLSA262RPT', 0 , K_Incluir    , 0, Nil},; //"Rel.Con&f."
	{ STR0008	,"PLSA262LEG", 0 , K_Incluir    , 0, .F.} } //"Legenda"
Return(aRotina)


/*


Ŀ
Programa  MenuDef    Autor  TOTVS                  Data 07/02/2017
Ĵ
Descrio  Ajusta Status das vias Bloqueadas em Lotes anteriores      


*/

Function PLAJCABDE(aLoBDE,cTpBlo)

	LOCAL    nJ        := 0
	Local    lRet      := .F.
	Default aLoBDE     := {}
	Default cTpBlo     := "1"

	For nj:= 1  to Len(aLoBDE)

		If BDE->(MsSeek(xFilial("BDE")+aLoBDE[nJ,2]+aLoBDE[nJ,3]))

			lRet:= PLBLOPA(aLoBDE[nJ,2], aLoBDE[nJ,3],cTpBlo)

			BDE->(RecLock("BDE",.F.))
			If cTpBlo == "1" .And. !lRet
				BDE->BDE_STAANB := BDE->BDE_STACAR
				BDE->BDE_STACAR := "3"
			ElseIf cTpBlo == "1" .And. lRet
				BDE->BDE_STAANB := BDE->BDE_STACAR
				BDE->BDE_STACAR := "4"
			ElseIf cTpBlo == "0" .And. lRet
				If !Empty(BDE->BDE_STAANB)
					BDE->BDE_STAANB := BDE->BDE_STACAR
					BDE->BDE_STACAR := "4"
				Else
					BDE->BDE_STACAR := "4"
					BDE->BDE_STAANB := ""
				EndIf
			ElseIf cTpBlo == "0" .And. !lRet
				If !Empty(BDE->BDE_STAANB)
					BDE->BDE_STACAR := BDE->BDE_STAANB
					BDE->BDE_STAANB := "3"
				Else
					BDE->BDE_STAANB := "3"
					BDE->BDE_STACAR := "2"
				EndIf
			EndIf
			BDE->(MsUnlock())
		EndIf
	Next nJ


Return()

/*


Ŀ
Programa  MenuDef    Autor  TOTVS                  Data 07/02/2017
Ĵ
Descrio  Ajusta Status do Cabecalho do lote quando necessario       


*/

Function PLBLOPA(cChkCIt,cChkCBl,cTipBlo)

	Local cSQLBLO     := ""
	Local lRet        := .F.
	Default cChkCIt   := ""
	Default cChkCBl   := ""
	Default cTipBlo   := ""

	cSQLBLO := "SELECT COUNT(*) AS QTDEBLO"
	cSQLBLO += " FROM " + RetSqlName("BED")
	cSQLBLO += " WHERE BED_FILIAL = '" + xFilial("BED")  + "' "
	cSQLBLO += "   AND BED_CODINT = '" +    cChkCIt      + "' "

	If cTipBlo == "1"                             //Caso seja um bloqueio, verifico se ha vias desbloqueadas para marcar o lote como bloqueado ou parcialmente bloq.
		cSQLBLO += "   AND BED_BLOIDE = '0' AND BED_CDIDEN = '" +    cChkCBl      + "' "
	Else
		If AllTrim(FunName()) == "PLSA261"
			cSQLBLO += "   AND BED_BLOIDE = '1' AND BED_CDIDEN = '" +    cChkCBl      + "' "
		Else
			cSQLBLO += "   AND BED_BLOIDE = '1' AND BED_CTRBLO = '" +    cChkCBl      + "' "
		EndIf
	EndIf

	cSQLBLO += " AND D_E_L_E_T_ = ' '"

	cSQLBLO := ChangeQuery(cSQLBLO)
	dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSQLBLO),"BEDVBLO",.F.,.T.)

	BEDVBLO->(DbGoTop())

	If !BEDVBLO->( Eof() )

		If BEDVBLO->QTDEBLO >= 1
			lRet:= .T.
		EndIf

	EndIf

	BEDVBLO->(DbCloseArea())


Return (lRet)

Function Pl262DtBlo()
Return (Empty(BA1->BA1_DATBLO).OR.BA1->BA1_DATBLO>dDataBase)

/*/{Protheus.doc} RetBA3Val
Retorna BA3_VALID
@author Roberto Barbosa
@since 06/2019
/*/
Function RetBA3Val()
	Local aAreaBA3	:= GetArea()

	BA3->(DbSetOrder(1))
	BA3->(msSeek(xFilial("BA3")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_CONEMP+BA1_VERCON+BA1_SUBCON+BA1_VERSUB)))

	RestArea(aAreaBA3)

Return BA3->BA3_VALID
