#INCLUDE "MATXFIS.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "MATXDEF.CH"
#INCLUDE 'FWLIBVERSION.CH'

// SEMPRE QUE REALIZAR M_ANUTENCAO NAS REFERENCIAS DE IMPOSTOS DA MATXFIS ATUALIZAR A FUNCAO MATXFIS_V COM A DATA ATUAL
/*
MATXFIS - Edson Maricate/Eduardo - 08/12/99
Programa de Calculo de Impostos Fiscais e Financeiros
*/
STATIC jPE        := JsonObject():New()
STATIC jParametro := JsonObject():New()
STATIC jAlias     := JsonObject():New()
STATIC jCampos    := JsonObject():New()
STATIC jFunctions := JsonObject():New()
STATIC jTamSX3    := JsonObject():New()
STATIC oJCFOP     := JsonObject():New()
STATIC jCache     := JsonObject():New()
Static lAllCfops  := .F.

STATIC aMaster
STATIC aNFCab
STATIC aNFItem
STATIC aItemDec
STATIC aBrwLF
STATIC aStack
STATIC aRefSX3
STATIC oRefSX3
STATIC aSaveDec
STATIC aAuxOri
STATIC cAliasPROD  := "SB1"
STATIC aInfNat 	   := Array(27)
STATIC aTES[MAX_TS]
STATIC aItemRef
STATIC aCabRef
STATIC aResRef
STATIC aTGITRef
STATIC aTGNFRef
STATIC aTGLFRef	:= {}
STATIC aLFIS
STATIC aPE
STATIC aSX6
STATIC aDic
STATIC aPos
STATIC aFunc
STATIC aUltPesq   	//ALEMES - FUNCAO DE IR
STATIC aUltPesqF2D  := {}
STATIC bFisRefresh
STATIC bLivroRefresh
STATIC cCpoSBZ     := CpyFieldSB(,.T.)  //ALEMES - So utilizada na MaSBCampo
STATIC lLimInss    := .F. //ALEMES - BASICAMENTE PRA SER USADA MAFISDEL
STATIC lNotRemito  := .T. //ALEMES - Localizado por enquanto nao
STATIC cSX6FilAnt  := cFilAnt  //Inicia variavel com filial corrente
STATIC cSX6EmpAnt  := cEmpAnt  //Inicia variavel com filial corrente
Static cRpoRelease := GetRPORelease()
STATIC cFornCE1    := Space(FisTamSX3('CE1', 'CE1_FORISS')[1])
STATIC cDescCE1	   := Space(FisTamSX3('CE1', 'CE1_MUNISS')[1])
STATIC cLojaCE1    := Space(FisTamSX3('CE1', 'CE1_LOJISS')[1])
STATIC lLoadCache  := Iif((aSX6==NIL).Or.(aPos==NIL),MaLoadCache(),.F.)
STATIC lRastItem   := .T.
STATIC lHistorico  := .F.
STATIC cAlsCab     := ""
STATIC cAlsItem    := ""
STATIC cMunForISS  := ""
STATIC dVencCE1    := CTod("")
STATIC cRecIssCE1  := "1"
STATIC lCalculPCC  := .F. //Indica se Calcula (PIS,COFINS,CSLL), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
STATIC lINSSSemDu  := .F. //Indica se Calcula (INSS), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
STATIC lIRRFSemDu  := .F. //Indica se Calcula (IRRF), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
STATIC aAliqSN     := {}
STATIC aRefAlt
STATIC aHmFor	   := {}
STATIC aDepTrib	   := {}
STATIC aDepVlOrig  := {}
STATIC lReproc     := .F.
STATIC lTelemetria := .F.
STATIC lCFGTelemet := .F.
STATIC lVldCalImp := cPaisLoc == "ARG" .And. fisFindFunc('fVldCalImp')
STATIC lTeleCfg		:= FWLibVersion() >= "20200727"
Static lMetrica    :=  fisFindFunc('TMSMETRICA') .and. fisFindFunc('FWLSPUTASYNCINFO') .and. FwLibVersion() >= "20200727" 
Static cITCODMUN := Space(FisTamSX3( 'SF3','F3_CODMUN')[1]) //309-IT_CODMUN
Static cITTPACTIV := Space(FisTamSX3( 'SF3','F3_TPACTIV')[1]) //310-IT_TPACTIV
STATIC lSimuRepro := .F. // identifica se a matxfis foi acionada pelo reprocessamento através do simulador

Static lCJ2 := fisExtTab('12.1.2310', .T., 'CJ2')
Static lCpoUsrAFRMM := fisExtCmp('12.1.2410',.F.,'SD1','D1_AFRMIMP') .And. fisExtCmp('12.1.2410',.F.,'SFT','FT_AFRMIMP')
/*
MATXFIS_V - Rodrigo Aguilar - 21/11/11
Funcao que retorna a data da ultima manutencao nas referencias de imposto do MATXFIS
O retorno desta funcao eh utilizado na execucao do UPDFIS SEMPRE atualizar com a data de inclusao da referencia
*/
Function MATXFIS_V()
Return CtoD("13/04/16")

/*
MaLoadCache - Alemes/Demetrio Rios  Data 20/09/2012
 Alimenta as variaveis STATIC para cachear as chamadas de
 funcoes de uso generico para evitar processamento recursivo
 aSX6  - Todos os parametros Utilizados na MATXFIS
 aPE - Todos os Pontos de Entradas Utilizados n MATXFIS
 aPos- Todos os FiledPos a serem executados na MATXFIS
 aDic- Todos os AliasinDic executados na MATXFIS
*/
Static Function MaLoadCache()
//aPE	:= GPEMxFis()  // Pontos de entrada
//aFunc	:= GFFMxFis()	 // FindFunction
//aSX6 	:= GParMxFis(@cSX6FilAnt,@cSX6EmpAnt) // Parametros
//aDic 	:= GAiMxFis()  // AliasIndic
//aPos 	:= GFPMxFis(aSX6)  // FieldPos
//aTamSX3 := STamMxFis( aPos ) // TamSX3

/*
If aSX6 == Nil
	GParMxFis(@cSX6FilAnt,@cSX6EmpAnt)
Endif

If aPos == Nil
	GFPMxFis(aSX6)
Endif
*/

//força a carga do cache dos parâmetros
FREEOBJ( jParametro )
jParametro    := JsonObject():New()

Return Nil

/*

/*AS PROXIMAS 26 FUNCOES ABAIXO SAO FUNCOES DE CONTROLE QUE INTERAGEM COM TODOS OS MODULOS DO PROTHEUS OU QUALQUER PROGRAMA COM MATXFIS IMPLEMENTADA*/
/*MaFisFound - Edson Maricate - 08.12.1999
Verifica se o item ja existe na relacao de itens incluidos.
*/
Function MaFisFound(cCampo,nItem)
Local lRetorno  := .T.

If aNfItem <> Nil
	If cCampo == "IT"
		If nItem > Len(aNfItem)
			lRetorno := .F.
		EndIf
	Else
		If Empty(aNfCab)
			lRetorno := .F.
		EndIf
	EndIf
Else
	lRetorno := .F.
EndIf

// Ao utilizar o Protheus com varias Filiais e possivel que em alguns processos como o de inclusao de Notas Fiscais o usuario altere
// a filial atraves da Dialog de seleçao de filiais, com isso se faz necessario que os parametros SX6 sejam novamente carregados para
// a filial corrente refazendo o cache realizado na variavel aSX6, esta nova carga e controlada pela variavel cSX6FilAnt
// Tratativa da empresa (cempant) logada para tratar clientes que não tem cadastrada a Gestão de empresas.
//If cSX6FilAnt <> cFilAnt .Or. cSX6EmpAnt <> cEmpAnt
//	aSX6 := GParMxFis(@cSX6FilAnt,@cSX6EmpAnt)
//EndIf

Return lRetorno
/*
MaFisSave - Edson Maricate - 10.12.99
Salva a NF atual em uma area temporaria
*/
Function MaFisSave()

If aMaster == Nil
	aMaster := {}
EndIf

aadd(aMaster,{aClone(aNfCab),;
	aClone(aSaveDec),;
	aClone(aNfItem),;
	aClone(aItemDec),;
	bFisRefresh,;
	bLivroRefresh,;
	aClone(aBrwLF),;
	aClone(aStack),;
	aClone(aAuxOri),;
	cAliasProd,;
	aClone(aRefAlt)})

Return len(aMaster)

/*MaFisRestore - Edson Maricate - 10.12.99
Carrega a NF salva em uma area temporaia*/
Function MaFisRestore(nPosMaster)
Local lRet := .F.
Local nUltimo := 0

default nPosMaster := 0

if aMaster <> Nil

	If nPosMaster == 0
		nUltimo := Len(aMaster)
	Else
		nUltimo := nPosMaster
	EndIf
	
	aNfCab        := aClone(aMaster[nUltimo][01])
	aSaveDec      := aClone(aMaster[nUltimo][02])
	aNfItem       := aClone(aMaster[nUltimo][03])
	aItemDec      := aClone(aMaster[nUltimo][04])
	bFisRefresh   := aMaster[nUltimo][05]
	bLivroRefresh := aMaster[nUltimo][06]
	aBrwLF        := aClone(aMaster[nUltimo][07])
	aStack        := aClone(aMaster[nUltimo][08])
	aAuxOri       := aClone(aMaster[nUltimo][09])
	cAliasProd    := aMaster[nUltimo][10]
	aRefAlt       := aClone(aMaster[nUltimo][11])

	if nPosMaster == 0
		aMaster       := aSize(aMaster,nUltimo-1)
	endif
	lRet := .T.
endif

If nUltimo == 1 .and. nPosMaster == 0
   aMaster := Nil
EndIf

Return lRet

/*MaFisClear - Edson Maricate -09.12.1999
Limpa os itens da NF e zera as variaveis do cabecalho.*/
Function MaFisClear()

If MaFisFound('NF')
	aNfItem := {}
	aRefAlt := {}
	aItemDec:= {}
	If aSaveDec<>Nil
		aFill(aSaveDec,0)
	EndIf
	aAuxOri	:= {}
	MaIt2Cab()
EndIf

Return .T.

/*/MaFisEnd- Edson Maricate -10.01.1999
Finaliza o uso das funcoes Fiscais.
Parametros ExpL1: Indica se deve reinicializar o codeblock da funcao
MaFisRodape ( bFisRefresh ) */
Function MaFisEnd(lRodape)

DEFAULT lRodape := .T.

// Telemetria de tributos utilizados pelo configurador 
If !lReproc .And. lTeleCfg .And. Valtype(aNFItem) == 'A' 
	VerifItens()
EndIf

aNfCab	:= Nil
aNfItem	:= Nil
aRefAlt := NIL
aItemDec:= Nil
aSaveDec:= Nil
aAuxOri	:= Nil
aTes	:= Array(MAX_TS)
bLivroRefresh := Nil
If lRodape
	bFisRefresh := Nil
EndIf
lNotRemito :=.T.
cFornCE1    := Space(FisTamSX3('CE1', 'CE1_FORISS')[1])
cDescCE1	:= Space(FisTamSX3('CE1', 'CE1_MUNISS')[1])
cLojaCE1    := Space(FisTamSX3('CE1', 'CE1_LOJISS')[1])
dVencCE1    := Ctod("")
cRecIssCE1  := "1"
aHmFor		:= nil
aDepTrib	:= nil
aDepVlOrig	:= nil
aUltPesqF2D	:= nil
lTelemetria := .F.
lCFGTelemet := .F.

/* Não limpa objetos e arrays que são de reuso no MATXFIS
Permitindo ue sejam utlizados diversas vezes.
if fisFindFunc('XFISEND')
	XFisEnd()
endif
*/
Return .T.

/*/MaFisNfCab - Alexandre Lemes - 01/10/2012
Torna disponivel o array static aNfCab as rotinas externas/*/
Function MaFisNFCab()
Return aClone(aNFCab[NF_IMPOSTOS])

/*/MaFisIni -Eduardo/Edson - 08.12.1999
Inicializa o Calculo das operacoes Fiscais/*/
Function MaFisIni(cCodCliFor,;	// 1-Cod. Cli/For
cLoja,;		  // 02-Lj do Cli/For
cCliFor,;	  // 03-C:Cliente , F:Fornecedor
cTipoNF,;	  // 04-Tp NF( "N","D","B","C","P","I" )
cTpCliFor,;	  // 05-Tp do Cli/For
aRelImp,;	  // 06-Relacao de Impostos que suportados no arquivo
cTpComp,;	  // 07-Tipo de complemento
lInsere,;	  // 08-Permite Incluir Impostos no Rodape .T./.F.
cAliasP,;	  // 09-Alias do Cadastro de Produtos - ("SBI" P/ Front Loja)
cRotina,;	  // 10-Nome da rotina que esta utilizando a funcao
cTipoDoc,;	  // 11-Tipo de documento
cEspecie,;	  // 12-Especie do documento
cCodProsp,;	  // 13-Codigo e Loja do Prospect
cGrpCliFor,;  // 14-Grupo Cliente
cRecolheISS,; // 15-Recolhe ISS
cCliEnt,;	  // 16-Codigo do cliente de entrega na nota fiscal de saida
cLojEnt,;	  // 17-Loja do cliente de entrega na nota fiscal de saida
aTransp,;	  // 18-Informacoes do transportador [01]-UF,[02]-TPTRANS
lEmiteNF,;	  // 19-Se esta emitindo nota fiscal ou cupom fiscal (Sigaloja)
lCalcIPI,;    // 20-Define se calcula IPI (SIGALOJA)
cPedido,;     // 21-Pedido de Venda
cCliFat,;	  // 22-Cliente do faturamento ( cCodCliFor é passado como o cliente de entrega, pois é o considerado na maioria das funções fiscais, exceto ao gravar o clinte nas tabelas do livro)
cLojCFat,;    // 23-Loja do cliente do faturamento
nTotPed,;	  // 24-Total do Pedido
dDtEmiss,;	  // 25-Data de emissão do documento inicialmente só é diferente de dDataBase nas notas de entrada (MATA103 e MATA910)
cTpFrete,;    // 26-Tipo de Frete informado no pedido
lCalcPCC,;    // 27-Indica se Calcula (PIS,COFINS,CSLL), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
lCalcINSS,;   // 28-Indica se Calcula (INSS), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
lCalcIRRF,;   // 29-Indica se Calcula (IRRF), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
cTpCompl,;    // 30-Tipo de Complemento
cCltdest,;	  // 31-Cliente de destino de transporte (Notas de entrada de transporte )
cLjtdest,;    // 32-Loja de destino de transporte (Notas de entrada de transporte )
lCalcTG,;     // 33-Flag para indicar se os tributos genéricos devem ou não ser calculados - deve ser passado como .T. somente após a preparação da rotina para gravação, visualização e exclusão dos tributos genéricos.
nQtdItens,;   // 34-Quantidade de itens no documento.
lPlanilha,;   // 35-Indica se a chamada é realizada pela planilha financeira
cNumNota,;    // 36-Numero da nota
lF2BTeste)    // 37-Considera regras com status "Teste" no Configurador de tributos 

Local aArea    	:= GetArea()
Local aAreaSA1 	:= SA1->(GetArea())
Local aAreaSA2 	:= SA2->(GetArea())
Local cOperNf  	:= ""
Local cUfDest  	:= ""
Local cUfOrig  	:= ""
Local cNatureza	:= ""
Local cCodMuni  := ""
Local cAtividad	:= ""
Local cRecPIS  	:= "N"
Local cRecIRRF  := "2"
Local cRecCOFI 	:= "N"
Local cRecCSLL 	:= "N"
Local cRecISS  	:= "2"
Local cRecINSS 	:= "N"
Local cCalcINP	:= "N"
Local cRecSEST 	:= "2"
Local cCNPJ    	:= ""
Local lInclui 	:= .T.
Local lInscrito	:= .F.
Local lSuframa 	:= .F.
Local cCalcSuf 	:= " "
Local nAliqIRF 	:= 0
Local cSerie   	:= ''
Local nMoeda   	:= 1
Local nTxMoeda 	:= 0
Local cModIRF  	:= ""
Local cOPIrrf  	:= ""
Local cRecFet  	:= "2"
Local cRecFab  	:= "2"
Local cRecFac  	:= "2"
Local cRecFMD	:= "2"
Local cSimpNac 	:= ""
Local nNumDep	:= 0
Local cProvEnt	:= "  "   // Provincia de entrega
Local cIRFProg  := 0
Local cMvEstado	:= ""
Local cMvDupNat	:= ""
Local cIRMP232  := "2"
Local lA1Contrib:= .F.
Local lA2Contrib:= .F.
Local lA1CalcIRF:= .F.
Local lA2IRPROG := .F.
Local cFRetIss	:=	""
Local cSerSat	:= ""
Local cRegeSim	:= ""   // A1_REGESIM / A2_REGESIM - Regime simplificado MT
Local nPercAtm	:= 0	// A1_PERCATM - Pecentual de Carga Media
Local cPessoa	:= "" 	// A1_PESSOA - Pessoa - Fisica / Juridica
Local cNReduz	:= ""   // A1_NREDUZ / A2_NREDUZ - Nome Fantasia
Local cCRDMA	:= ""	// Credito Estimulo de Manaus
Local cSimpSC	:= "" 	// A1_SIMPLES - Clie. optante SIMPLES/SC
Local cCDRDes	:= ""   // A1_CDRDES - Regiao do Cliente
Local cNatCliFa := ""
Local cTipoFat	:= ""
Local cGrpCliFat := CriaVar("A1_GRPTRIB",.F.)
Local aAreaSA1F	:= {}
Local cIDSA1    := ""
Local cIDSA2    := ""
Local lHist := .F.
Local cHistSA1  := ""
Local cHistSA2  := ""
Local lPOS		:= fisFindFunc("STFIsPOS") .AND. STFIsPOS()
Local nRecCide	:= ""
Local cUfPreISS := ""
Local cHstA1Dest:=""
Local lHistDest	:=.F.
Local linscDest	:=.F.
Local lA1Cntdest:=.F.
Local cUfCliDest:=""
Local cRecIMAMT	:= "2"
Local cRecFASEMT:= "2"
Local nIndice := 0
Local nIndUpf   := 0
Local cDedBsPC := " "
Local cM0CodMun := IIf(cPaisLoc == "BRA", Iif(Len(Alltrim(SM0->M0_CODMUN))<=5,xFisCodIBGE(SM0->M0_ESTENT),"")+SM0->M0_CODMUN, "")
Local cTipoRur := ""
Local nPerFECP := 0
Local cMesEmi  := ""
Local cAnoEmi  := ""
Local cPerIniSN := ""
Local cPerFimSN := ""
Local cPerEmpty := ""
Local cMesSN  := ""
Local cAnoSN  := ""
Local nPosAlqSN := 0
Local lUsaAlqSN := .F.
Local cGrossIR	:= ""
Local cTPJFor	:= ""
Local lTemF2B   := .F.
Local lPerfPart	:= .F.

DEFAULT aRelImp := {}
DEFAULT cTpComp := ""
DEFAULT lInsere := .F.
DEFAULT cAliasP := "SB1"
DEFAULT cTipoDoc:= ""
DEFAULT cEspecie:= ""
DEFAULT	cCodProsp:= ""	//Codigo e Loja do Prospect
DEFAULT cGrpCliFor:= CriaVar("A1_GRPTRIB",.F.)
DEFAULT cRecolheISS	:=	""
DEFAULT cCliEnt  := Space(FisTamSX3('SF3','F3_CLIEFOR' )[1])
DEFAULT cLojEnt  := Space(FisTamSX3('SF3','F3_LOJA' )[1])
DEFAULT aTransp  := {"",""}
DEFAULT lEmiteNF:= .T.
DEFAULT cRotina := ""
DEFAULT lCalcIPI:= .T.
DEFAULT cPedido	:= ""
DEFAULT cCliFat		:= ""
DEFAULT cLojCFat	:= ""
DEFAULT nTotPed		:= 0
DEFAULT dDtEmiss	:= dDataBase
DEFAULT cTpFrete	:= ""
DEFAULT lCalcPCC 	:= .F.
DEFAULT lCalcINSS	:= .F.
DEFAULT lCalcIRRF	:= .F.
DEFAULT cTpCompl := ''
DEFAULT cCltdest := ''
DEFAULT cLjtdest := ''
DEFAULT lCalcTG := .F.
DEFAULT nQtdItens := 0
DEFAULT lPlanilha := .F.
DEFAULT cNumNota := ''
DEFAULT lF2BTeste := .F.


If cRotina $ "LOJA701|FATA701" .AND. !lPOS
	If fisGetParam('MV_LJINTUF',0) > 0 .OR. cRotina == "FATA701"
		lEmiteNF :=  LjNFFimVd()// Verifica se emite NF aplica-se apenas quando tipo do cliente for diferente de Consumidor Final e se o mesmo não pertencer a estado configurado no parametro MV_LJDIFAL
	Else
		lEmiteNF :=  IIf(!Empty(cTpCliFor), cTpCliFor, SA1->A1_TIPO) != "F" .And. LjNFFimVd()  // Verifica se emite NF //aplica-se apenas quando tipo do cliente for diferente de Consumidor Final e se o mesmo não pertencer a estado configurado no parametro MV_LJDIFAL
	EndIf
EndIf

cTpCliFor	:= IIf(cTpCliFor==Nil," ",cTpCliFor)
aUltPesq	:= {ctod(""),"","",0,0,0,0,0}
lNotRemito	:= .T.
lCalculPCC	:= lCalcPCC
lINSSSemDu	:= lCalcINSS
lIRRFSemDu	:= lCalcIRRF
cMesEmi     := Month2Str(dDtEmiss)
cAnoEmi     := Year2Str(dDtEmiss)

aDepTrib	:= {}
aDepVlOrig  := {}
aUltPesqF2D	:= {}

If MaFisFound("NF")
	lInclui		:= .F.
	cCodCliFor	:= aNfCab[NF_CODCLIFOR]
	cLoja		:= aNfCab[NF_LOJA]
	cCliFor		:= aNfCab[NF_CLIFOR]
	cTipoNF		:= aNfCab[NF_TIPONF]
	cTpCliFor	:= aNfCab[NF_TPCLIFOR]
	aRelImp		:= aNfCab[NF_RELIMP]
	cNatureza	:= aNfCab[NF_NATUREZA]
	cTpComp		:= aNfCab[NF_TPCOMP]
	lInsere		:= aNfCab[NF_INSIMP]
	cRotina		:= aNfCab[NF_ROTINA]
	nAliqIRF	:= aNfCab[NF_ALIQIR]
	cSerie		:= aNfCab[NF_SERIENF]
	cTipoDoc	:= aNfCab[NF_TIPODOC]
	nMoeda		:= aNfCab[NF_MOEDA]
	nTxMoeda	:= aNfCab[NF_TXMOEDA]
	cEspecie	:= aNfCab[NF_ESPECIE]
	cCNPJ		:= aNfCab[NF_CNPJ]
	cCliEnt		:= aNfCab[NF_CLIENT]
	cLojEnt		:= aNfCab[NF_LOJENT]
	cCodMuni	:= aNfCab[NF_CODMUN]
	cAtividad   := aNfCab[NF_TPACTIV]
	cRegeSim	:= aNfCab[NF_REGESIM]
	nPercAtm	:= aNfCab[NF_PERCATM]
	cPessoa		:= aNfCab[NF_PESSOA]
	cNReduz		:= aNfCab[NF_NREDUZ]
	cCRDMA 		:= aNfCab[NF_A1CRDMA]
	cSimpSC		:= aNfCab[NF_SIMPSC]
	cCDRDes		:= aNfCab[NF_CDRDES]
	cCliFat		:= aNfCab[NF_CLIEFAT]
	cLojCFat	:= aNfCab[NF_LOJCFAT]
	dDtEmiss	:= aNfCab[NF_DTEMISS]
	cTpFrete	:= aNfCab[NF_TPFRETE]
	cSerSat		:= aNfCab[NF_SERSAT]
	cTpCompl	:= aNfCab[NF_TPCOMPL]
	cCltdest	:= aNfCab[NF_CLIDEST]
	cLjtdest	:= aNfCab[NF_LOJDEST]
	cUfCliDest  := aNfCab[NF_UFCDEST]
	cUFPREISS	:= aNFCab[NF_UFPREISS]
	If cPaisLoc<> "BRA"
		lNotRemito	:=  !(IsRemito(1,"'"+aNFCab[NF_TIPODOC]+"'") .AND. cPaisLoc <> "RUS")
	EndIf
	If cPaisLoc $ "ARG|EUA"
		cProvEnt  := aNfCab[NF_PROVENT]
	EndIf
	lCalcTG     := aNfCab[NF_CALCTG]
	nQtdItens   := aNfCab[NF_QTDITENS]
Else
	If cPaisLoc<> "BRA"
		lNotRemito	:=  !(IsRemito(1,"'"+cTipoDoc+"'") .AND. cPaisLoc <> "RUS")
	EndIf
EndIf

cMvEstado	:= fisGetParam('MV_ESTADO','')
cMvDupNat	:= fisGetParam('MV_1DUPNAT','')
cIRMP232	:= fisGetParam('MV_IRMP232','2')

lA1Contrib	:= fisExtCmp('12.1.2310', .T.,'SA1','A1_CONTRIB')
lA1CalcIRF	:= fisExtCmp('12.1.2310', .T.,'SA1','A1_CALCIRF')
lA2IRPROG	:= fisExtCmp('12.1.2310', .T.,'SA2','A2_IRPROG')
lA2Contrib	:= fisExtCmp('12.1.2310', .T.,'SA2','A2_CONTRIB')

If lInclui
	aNFCab	:= {}
	aNFItem	:= {}
	aRefAlt := {}
	aItemDec:= {}
	cAliasPROD := cAliasP
EndIf

//Faz verificação da existência dos fontes dependentes
//Se a função não estiver disponível no RPO, a rotina será aobrtada!
MaVldFuncD()

// Verifica se existe ao menos uma regra na F2B.
If cPaisLoc == "BRA" .And. fisExtTab('12.1.2310', .T., 'F2B')
	dbSelectArea("F2B")
	If F2B->(dbSeek(xFilial("F2B")))
		lTemF2B	:= .T.
	EndIF

	//Verifica se o participante está em algum perfil de participante
	dbSelectArea("F22")
	dbSetOrder(2)
	If F22->(dbSeek(xFilial("F22") + Iif(cCliFor == "C", "2", "1") + cCodCliFor + cLoja)) .Or.  F22->(dbSeek(xFilial("F22") + Iif(cCliFor == "C", "2", "1") + PADR("TODOS",FisTamSX3( 'F22', 'F22_CLIFOR' )[1]) + Replicate("Z",FisTamSX3('F22','F22_LOJA' )[1])))
		lPerfPart	:= .T.
	EndIF
	
	aHmFor	   := {}
	
EndIf

// Posiciona os registros necessarios
If ( cCliFor == "C" )
	If Empty(cCodProsp)
		dbSelectArea("SA1")
		dbSetOrder(1)
		MsSeek(xFilial("SA1")+cCodCliFor+cLoja)
		If lHistorico
			//Se for reprocessamento,  e tiver habilitado para buscar os Historico Fiscais,
			//verifico se o ID do historico do Cliente e igual ao que foi gravado na Nota. Se for
			//igual é porque nao teve alterações no cliente após a emissão. Se for diferente,
			//é porque teve alterações no cadastro, e entao os dados são carregados da tabela de
			//Historico(SS2).
			cHistSA1 := IIF(cTipoNF=="D", (cAlsCab)->F1_IDSA1, (cAlsCab)->F2_IDSA1)
			If cPaisLoc == "BRA" .And. Alltrim(SA1->A1_IDHIST)<>Alltrim(cHistSA1)
				dbSelectArea("SS2")
				dbSetOrder(1)
				MsSeek(xFilial("SS2")+cHistSA1+cCodCliFor+cLoja)
				lHist := .T.
			EndIf
		EndIf

		cOperNf   := IIf(cTipoNf$"DB","E","S")
		lInscrito := IIf(lHist, IIf(Empty(SS2->S2_INSCR).Or."ISENT"$SS2->S2_INSCR.Or."RG"$SS2->S2_INSCR.Or.( lA1Contrib .And. SS2->S2_CONTRIB == "2"),.T.,.F.), IIf(Empty(SA1->A1_INSCR).Or."ISENT" $ SA1->A1_INSCR .Or. "RG" $ SA1->A1_INSCR .Or.( lA1Contrib .And. SA1->A1_CONTRIB == "2"),.T.,.F.))

		If SA1->A1_CONTRIB == "1" .and. (SA1->A1_TPJ == "3" .or. SA1->A1_TPJ == "1") .and. ( Empty( SA1->A1_INSCR ) .or. "ISENT" $ SA1->A1_INSCR )
			lInscrito := .F.
		EndIf

		//Tratamento para considerar como contribuinte do ICMS Produtor Rural com inscrição Rural
		If IIf(lHist, !Empty(SS2->S2_INSCRUR) .And. "L" $ SS2->S2_TIPO .And. ( lA1Contrib .And. SS2->S2_CONTRIB <> "2"), !Empty(SA1->A1_INSCRUR) .And. "L" $ SA1->A1_TIPO .And. ( lA1Contrib .And. SA1->A1_CONTRIB <> "2"))
			lInscrito := .F.
		EndIf

		cCodMuni  := IIf(lHist, SS2->S2_COD_MUN, SA1->A1_COD_MUN)
		lSuframa  := IIf(lHist, !Empty(SS2->S2_SUFRAMA) .And. SS2->S2_CALCSUF<>'N',  !Empty(SA1->A1_SUFRAMA) .And. SA1->A1_CALCSUF<>'N')
		cCalcSuf  := IIf(lHist, SS2->S2_CALCSUF, SA1->A1_CALCSUF)

		If Empty(cGrpCliFor)
			cGrpCliFor := IIf(lHist, SS2->S2_GRPTRIB, SA1->A1_GRPTRIB)
		EndIf

		If lEmiteNF
			cUfDest   := IIf(lHist, IIf(cTipoNf$"DB",cMvEstado,SS2->S2_EST), IIf(cTipoNf$"DB",cMvEstado,SA1->A1_EST))
			cUfOrig   := IIf(lHist, IIf(cTipoNf$"DB",SS2->S2_EST,cMvEstado), IIf(cTipoNf$"DB",SA1->A1_EST,cMvEstado))
		Else
			cUfDest   := cMvEstado
			cUfOrig   := cMvEstado
			If cPaisLoc == "ARG" // SigaLoja - para argentina inicializa a provincia do cliente
				cProvEnt  := IIf(lHist, SS2->S2_EST, SA1->A1_EST)
			EndIf
		EndIf

		cCNPJ     := IIf(lHist, SS2->S2_CGC, SA1->A1_CGC)

		If lInclui
			
			cNatureza := iIf( cRotina == 'MATA461'.and. lPlanilha .and. !Empty(cMvDupNat) .and. Substr(cMvDupNat,1,3) == "SC5",&("M->"+Substr(cMvDupNat,At('>',cMvDupNat)+1,LEN(cMvDupNat))),iIf(!Empty(cMvDupNat),&(cMvDupNat),""))	

			If Substr(cMvDupNat,1,3) == "SC5" .and. IsInCallStack("TECA400")
				cNatureza := ""
			EndIF
			
			cTpCliFor := IIf(lHist, IIf(Empty(cTpCliFor),SS2->S2_TIPO,cTpCliFor), IIf(Empty(cTpCliFor),SA1->A1_TIPO,cTpCliFor))
		Else
			cTpCliFor := IIf(lHist, SS2->S2_TIPO, SA1->A1_TIPO)
		EndIf

		nAliqIRF  := IIf(lHist, SS2->S2_ALIQIR, SA1->A1_ALIQIR)
		cRecPIS   := IIf(lHist, SS2->S2_RECPIS, SA1->A1_RECPIS)
		cRecCOFI  := IIf(lHist, SS2->S2_RECCOFI, SA1->A1_RECCOFI)
		cRecCSLL  := IIf(lHist, SS2->S2_RECCSLL, SA1->A1_RECCSLL)
		cRecISS   := IIf(lHist, IIf(SS2->S2_RECISS$"N|2| ","2","1"), IIf(SA1->A1_RECISS$"N|2| ","2","1"))

		If !Empty(cRecolheISS)
			cRecISS  := cRecolheISS
		Endif

		cRecINSS := IIf(lHist, SS2->S2_RECINSS, SA1->A1_RECINSS)

		If cPaisLoc == "BRA"
			If fisExtCmp('12.1.2310', .T.,'SB1', 'B1_AFETHAB')  .And. fisExtCmp('12.1.2310', .T.,'SA2', 'A2_RECFET')  .And. fisExtCmp('12.1.2310', .T.,'SA1', 'A1_RECFET') .And. fisExtCmp('12.1.2310', .T.,'SF4', 'F4_CALCFET')
				cRecFet  := IIf(lHist, IIf(Empty(SS2->S2_RECFET),"2",SS2->S2_RECFET), IIf(Empty(SA1->A1_RECFET),"2",SA1->A1_RECFET))
			EndIf

			If fisExtCmp('12.1.2310', .T.,'SB1', 'B1_AFABOV') .And. fisExtCmp('12.1.2310', .T.,'SA2', 'A2_RFABOV') .And. fisExtCmp('12.1.2310', .T.,'SA1', 'A1_RFABOV') .And. fisExtCmp('12.1.2310', .T.,'SF4', 'F4_CFABOV')
				cRecFab  := IIf(lHist, IIf(Empty(SS2->S2_RFABOV),"2",SS2->S2_RFABOV), IIf(Empty(SA1->A1_RFABOV),"2",SA1->A1_RFABOV))
			EndIf

			If fisExtCmp('12.1.2310', .T.,'SB1', 'B1_AFACS') .And. fisExtCmp('12.1.2310', .T.,'SA2', 'A2_RFACS') .And. fisExtCmp('12.1.2310', .T.,'SA1', 'A1_RFACS')  .And. fisExtCmp('12.1.2310', .T.,'SF4', 'F4_CFACS')
				cRecFac  := IIf(lHist, IIf(Empty(SS2->S2_RFACS),"2",SS2->S2_RFACS), IIf(Empty(SA1->A1_RFACS),"2",SA1->A1_RFACS))
			EndIf

			If fisExtCmp('12.1.2310', .T.,'SB1','B1_AFACS') .And. fisExtCmp('12.1.2310', .T.,'SA2','A2_RFACS') .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RFACS')  .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CFACS')
				cRecFMD  := IIf(lHist, IIf(Empty(SS2->S2_RECFMD),"2",SS2->S2_RECFMD), IIf(Empty(SA1->A1_RECFMD),"2",SA1->A1_RECFMD))
			EndIf

			If fisExtCmp('12.1.2310', .T.,'SB1', 'B1_AIMAMT') .And. fisExtCmp('12.1.2310', .T.,'SA2', 'A2_RIMAMT') .And. fisExtCmp('12.1.2310', .T.,'SA1', 'A1_RIMAMT') .And. fisExtCmp('12.1.2310', .T.,'SF4', 'F4_CIMAMT')
				cRecIMAMT  := IIf(lHist, IIf(Empty(SS2->S2_RIMAMT),"2",SS2->S2_RIMAMT), IIf(Empty(SA1->A1_RIMAMT),"2",SA1->A1_RIMAMT))
			EndIf

			If fisExtCmp('12.1.2310', .T.,'SB1', 'B1_AFASEMT') .And. fisExtCmp('12.1.2310', .T.,'SA2', 'A2_RFASEMT') .And. fisExtCmp('12.1.2310', .T.,'SA1', 'A1_RFASEMT') .And. fisExtCmp('12.1.2310', .T.,'SF4', 'F4_CFASE')
				cRecFASEMT  := IIf(lHist, IIf(Empty(SS2->S2_RFASEMT),"2",SS2->S2_RFASEMT), IIf(Empty(SA1->A1_RFASEMT),"2",SA1->A1_RFASEMT))
			EndIf

			cFRetIss := Iif(lHist, SS2->S2_FRETISS, SA1->A1_FRETISS)

			If fisExtCmp('12.1.2310', .T.,'SA1', 'A1_RECIRRF')
				cRecIRRF := IIf(lHist, SS2->S2_RECIRRF, SA1->A1_RECIRRF)
			EndIf
		EndIf

		cModIRF  := IIf(lHist, IIf( lA1CalcIRF ,SS2->S2_CALCIRF,IIf(cIRMP232=="2","1","2")), IIf( lA1CalcIRF ,SA1->A1_CALCIRF,IIf(cIRMP232=="2","1","2")))
		cOPIrrf  := IIf(lHist, IIf( fisExtCmp('12.1.2310', .T.,'SA1','A1_TPESSOA'), SS2->S2_TPESSOA,""), IIf( fisExtCmp('12.1.2310', .T.,'SA1','A1_TPESSOA') , SA1->A1_TPESSOA,""))
		nNumDep  := 0	// so verifico os dependentes para os fornecedores
		cIRFProg := IIf(lHist, IIf( lA2IRPROG , SS2->S2_IRPROG , "2" ) , "" )
		cRegeSim := IIf(lHist, IIf(fisExtCmp('12.1.2310', .T.,'SA1','A1_REGESIM'), SS2->S2_REGESIM , "" ), IIf(fisExtCmp('12.1.2310', .T.,'SA1','A1_REGESIM'), SA1->A1_REGESIM , "" ))
		nPercAtm := IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SA1','A1_PERCATM'), SS2->S2_PERCATM , 0   ), Iif(fisExtCmp('12.1.2310', .T.,'SA1','A1_PERCATM'), SA1->A1_PERCATM , 0))
		cPessoa  := IIf(lHist, SS2->S2_PESSOA, SA1->A1_PESSOA )
		cNReduz  := IIf(lHist, SS2->S2_NREDUZ, SA1->A1_NREDUZ)
		cCRDMA   := IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SA1','A1_CRDMA'), SS2->S2_CRDMA , "" ), Iif(fisExtCmp('12.1.2310', .T.,'SA1','A1_CRDMA')	 , SA1->A1_CRDMA , "" ))
		cSimpSC  := IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SA1','A1_SIMPLES'), SS2->S2_SIMPLES , ""), Iif(fisExtCmp('12.1.2310', .T.,'SA1','A1_SIMPLES'), SA1->A1_SIMPLES , ""))
		cCDRDes  := IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SA1','A1_CDRDES'), SS2->S2_CDRDES , ""), Iif(fisExtCmp('12.1.2310', .T.,'SA1','A1_CDRDES'), SA1->A1_CDRDES , ""))
		cSimpNac := IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SA1','A1_SIMPNAC'),SS2->S2_SIMPNAC,""), Iif(fisExtCmp('12.1.2310', .T.,'SA1','A1_SIMPNAC'),SA1->A1_SIMPNAC,""))
		nPerFECP := IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SA1','A1_PERFECP'),SS2->S2_PERFECP,""), Iif(fisExtCmp('12.1.2310', .T.,'SA1','A1_PERFECP'),SA1->A1_PERFECP,""))

		cIdSA1 := IIf(lHist, IIf(fisExtCmp('12.1.2310', .T.,'SA1','A1_IDHIST'), SS2->S2_IDHIST, ""), IIf(fisExtCmp('12.1.2310', .T.,'SA1','A1_IDHIST'), SA1->A1_IDHIST, ""))

		//Os tratamentos para PIS e COFINS irão utilizar como base o cliente de faturamento e
		//não mais o cliente entrega passado pelo parâmetro cCodCliFor na função MaFisIni e
		//gravado no array aNfCab e utilizado para as regras dos outros tributos.
		If fisGetParam('MV_PCFATPC',.F.) .And. cOperNf == "S"  .And. !Empty(cCliFat)
			aAreaSA1F	:=	SA1->(GetArea())
			If MsSeek(xFilial("SA1")+cCliFat+cLojCFat)
				If lInclui
					cNatCliFa := &(cMvDupNat)
					cTipoFat  := IIf(Empty(cTipoFat),SA1->A1_TIPO,cTipoFat)
				Else
					cTipoFat := SA1->A1_TIPO
				EndIf
				cGrpCliFat:= SA1->A1_GRPTRIB
				cRecPIS  := SA1->A1_RECPIS
				cRecCOFI := SA1->A1_RECCOFI

				If cPaisLoc == "BRA" .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RECIRRF')
					cRecIRRF := SA1->A1_RECIRRF
				EndIf
			EndIf
			RestArea(aAreaSA1F)  // Posicionando novamente no cliente principal utilizado na MATXFIS (Parâmetro cCodCliFor do MaFisIni() )
		EndIf

		// Carga das alíquotas da apuração do simples nacional
		If cPaisLoc == "BRA" .And. fisExtTab('12.1.2310', .T., 'F13') .And. fisGetParam('MV_CODREG','') == "1" .And. cOperNf == "S" .And. !cTipoNf $ "DB"

			// Só faço a carga se o array estiver vazio - evitar queries.
			If Empty(aAliqSN)

				#IFDEF TOP

					cPerIniSN := dToS(FirstDay(MonthSub(dDtEmiss, 1)))
					cPerFimSN := dToS(LastDay(MonthSub(dDtEmiss, 1)))
					cMesSN    := Month2Str(MonthSub(dDtEmiss, 1))
					cAnoSN    := Year2Str(MonthSub(dDtEmiss, 1))
					cPerEmpty := Space(FisTamSX3( 'F13', 'F13_FIMVIG' )[1])

					BeginSql Alias "MaAliqSN"
						SELECT F12.F12_TPATIV, F13.F13_FATORR, F13.F13_CFOP, F13.F13_CODISS, F13.F13_GRUPO,F16.F16_ICMS, F16.F16_ISS, F16B.F16_ISS AS ALIQFATORR, F16C.F16_ICMS AS ICMSTRCOM, F18.F18_FATORR
						FROM %Table:F13% F13
						INNER JOIN %Table:F12% F12 ON F12.F12_FILIAL = %xFilial:F12% AND F12.F12_CODATV = F13.F13_CODATV AND F12.%NotDel%
						LEFT JOIN %Table:F18% F18 ON F18.F18_FILIAL = %xFilial:F18% AND F18.F18_PER = %Exp:cPerIniSN% AND F18.%NotDel%
						LEFT JOIN %Table:F16% F16 ON F16.F16_FILIAL = %xFilial:F16% AND F16.F16_ANEXO = F13.F13_ANEXO AND F16.F16_MES = %Exp:cMesSN% AND F16.F16_ANO = %Exp:cAnoSN% AND F16.F16_APROV = '1' AND F16.%NotDel%
						LEFT JOIN %Table:F16% F16B ON F16B.F16_FILIAL = %xFilial:F16% AND F16B.F16_ANEXO = F13.F13_ASUB AND F16B.F16_MES = %Exp:cMesSN% AND F16B.F16_ANO = %Exp:cAnoSN% AND F16B.F16_APROV = '1' AND F16B.%NotDel%
						LEFT JOIN %Table:F16% F16C ON F16C.F16_FILIAL = %xFilial:F16% AND F16C.F16_ANEXO = '01' AND F16C.F16_MES = %Exp:cMesSN% AND F16C.F16_ANO = %Exp:cAnoSN% AND F16C.F16_APROV = '1' AND F16C.%NotDel%
						WHERE
						F13.F13_FILIAL = %xFilial:F13% AND
						F13.F13_INIVIG <= %Exp:cPerIniSN% AND (F13.F13_FIMVIG >= %Exp:cPerFimSN% OR F13.F13_FIMVIG = %Exp:cPerEmpty%) AND
						F13.%NotDel%
					EndSql

					dbSelectArea("MaAliqSN")
					MaAliqSN->(dbGoTop())

					While !MaAliqSN->(Eof())

						aAdd(aAliqSN, {})
						nPosAlqSN := Len(aAliqSN)

						If !Empty(MaAliqSN->F13_CFOP)

							aAdd(aAliqSN[nPosAlqSN], MaAliqSN->F13_CFOP) // CFOP
							aAdd(aAliqSN[nPosAlqSN], "") // COD ISS
							aAdd(aAliqSN[nPosAlqSN], "") // Grupo

							// Se a atividade for de transporte ou comunicação ela será tributada no anexo III
							// mas a alíquota do ICMS será do anexo I. Por isso fiz um JOIN na F16 passando direto
							// o anexo I.
							If MaAliqSN->F12_TPATIV == "1" .And. !Empty(MaAliqSN->ICMSTRCOM)
								aAdd(aAliqSN[nPosAlqSN], MaAliqSN->ICMSTRCOM) // ALIQUOTA
							Else
								aAdd(aAliqSN[nPosAlqSN], MaAliqSN->F16_ICMS) // ALIQUOTA
							EndIf

						ElseIf !Empty(MaAliqSN->F13_CODISS)

							aAdd(aAliqSN[nPosAlqSN],"") // CFOP
							aAdd(aAliqSN[nPosAlqSN], MaAliqSN->F13_CODISS) // COD ISS
							aAdd(aAliqSN[nPosAlqSN], "") // Grupo

							// Se o fator "r" for inferior a 28% a alíquota deve ser a do anexo
							// substituto.
							If MaAliqSN->F13_FATORR == "1" .And. MaAliqSN->F18_FATORR < 0.28
								aAdd(aAliqSN[nPosAlqSN], MaAliqSN->ALIQFATORR) // ALIQUOTA
							Else
								aAdd(aAliqSN[nPosAlqSN], MaAliqSN->F16_ISS) // ALIQUOTA
							EndIf

						ElseIf !Empty(MaAliqSN->F13_GRUPO)

							aAdd(aAliqSN[nPosAlqSN], "") // CFOP
							aAdd(aAliqSN[nPosAlqSN], "") //CODISS
							aAdd(aAliqSN[nPosAlqSN],MaAliqSN->F13_GRUPO) // GRUPO

							// Se o fator "r" for inferior a 28% a alíquota deve ser a do anexo
							// substituto.
							If MaAliqSN->F13_FATORR == "1" .And. MaAliqSN->F18_FATORR < 0.28
								aAdd(aAliqSN[nPosAlqSN], MaAliqSN->ALIQFATORR) // ALIQUOTA
							Else
								aAdd(aAliqSN[nPosAlqSN], MaAliqSN->F16_ISS) // ALIQUOTA
							EndIf

						EndIf

						MaAliqSN->(dbSkip())

					EndDo

					MaAliqSN->(dbCloseArea())

				#ENDIF

			EndIf

			lUsaAlqSN := !Empty(aAliqSN)

		EndIf

	Else
		//Inicializa as variaveis para a entidade prospect
		DbSelectArea("SUS")
		DbSetOrder(1)
		MsSeek(xFilial("SUS")+cCodProsp)
		cOperNf   := IIf(cTipoNf$"DB","E","S")

		If fisExtCmp('12.1.2310', .T.,'SUS','US_INSCR')
			lInscrito := IIf(Empty(SUS->US_INSCR) .Or. "ISENT" $ SUS->US_INSCR .Or. "RG" $ SUS->US_INSCR .Or. ( fisExtCmp('12.1.2310', .T.,'SUS','US_CONTRIB') .And. SUS->US_CONTRIB == "2"),.T.,.F.)
		Endif

		If fisExtCmp('12.1.2310', .T.,'SUS','US_SUFRAMA')  .And. fisExtCmp('12.1.2310', .T.,'SUS','US_CALCSUF')
			lSuframa  := !Empty(SUS->US_SUFRAMA) .And. SUS->US_CALCSUF<>'N'
			cCalcSuf  := SUS->US_CALCSUF
		Endif

		If fisExtCmp('12.1.2310', .T.,'SUS','US_GRPTRIB')  .And. Empty(cGrpCliFor)
			cGrpCliFor:= SUS->US_GRPTRIB
		Endif

		cUfDest   := IIf(cTipoNf$"DB",cMvEstado,SUS->US_EST)
		cUfOrig   := IIf(cTipoNf$"DB",SUS->US_EST,cMvEstado)
		cCNPJ     := SUS->US_CGC

		If lInclui
			If fisExtCmp('12.1.2310', .T.,'SUS','US_NATUREZ')
				cNatureza := SUS->US_NATUREZ
			Endif
			cTpCliFor := IIf(Empty(cTpCliFor),SUS->US_TIPO,cTpCliFor)
		Else
			cTpCliFor := SUS->US_TIPO
		EndIf

		nAliqIRF := IIf(fisExtCmp('12.1.2310', .T.,'SUS','US_ALIQIR'),SUS->US_ALIQIR	,0)
		cRecPIS  := IIf(fisExtCmp('12.1.2310', .T.,'SUS','US_RECPIS'),SUS->US_RECPIS	,"N")
		cRecCOFI := IIf(fisExtCmp('12.1.2310', .T.,'SUS','US_RECCOFI'),SUS->US_RECCOFI	,"N")
		cRecCSLL := IIf(fisExtCmp('12.1.2310', .T.,'SUS','US_RECCSLL'),SUS->US_RECCSLL	,"N")
		cRecISS  := IIf(fisExtCmp('12.1.2310', .T.,'SUS','US_RECISS'),SUS->US_RECISS	,"2")
		cRecINSS := IIf(fisExtCmp('12.1.2310', .T.,'SUS','US_RECINSS'),SUS->US_RECINSS	,"N")
		cModIRF  := IIf( lA1CalcIRF ,SA1->A1_CALCIRF,IIf(cIRMP232=="2","1","2"))
		cOPIrrf  := IIf(fisExtCmp('12.1.2310', .T.,'SUS','US_TPESSOA'),SUS->US_TPESSOA	,"")
		nNumDep	 := 0	// so verifico os dependentes para os fornecedores
		cIRFProg := IIf(lA2IRPROG,SA2->A2_IRPROG,"2")
	EndIf
Else
	lHist := .F.
	dbSelectArea("SA2")
	dbSetOrder(1)
	MsSeek(xFilial("SA2")+cCodCliFor+cLoja)
	If lHistorico
		//Se for reprocessamento,  e tiver habilitado para buscar os Historico Fiscais,
		//verifico se o ID do historico do Fornecedor e igual ao que foi gravado na Nota.
		//Se for igual é porque nao teve alterações no cliente após a emissão. Se for diferen
		//te e porque teve alterações no cadastro, e entao os dados são carregados da tabela
		//de Historico(SS3).
		cHistSA2 := IIF(!cTipoNF$"B|D", (cAlsCab)->F1_IDSA2, (cAlsCab)->F2_IDSA2)
		If cPaisLoc == "BRA" .And. Alltrim(SA2->A2_IDHIST)<>Alltrim(cHistSA2)
			dbSelectArea("SS3")
			dbSetOrder(1)
			MsSeek(xFilial("SS3")+cHistSA2+cCodCliFor+cLoja)
			cAls2 := "SS3"
			lHist := .T.
		EndIf
	EndIf

	cOperNf   := IIf(cTipoNf$"DB","S","E")

	If Empty(cGrpCliFor)
		cGrpCliFor:= IIf(lHist, SS3->S3_GRPTRIB, SA2->A2_GRPTRIB)
	EndIf

	lInscrito := IIf(cOperNf == "S" .And. cTipoNf$"B",IIf(Empty(SA2->A2_INSCR) .Or. "ISENT" $ SA2->A2_INSCR .Or. "RG" $ SA2->A2_INSCR .Or. (lA2Contrib .And. SA2->A2_CONTRIB == "2"),.T.,.F.),IIf(Empty(SM0->M0_INSC).Or."ISENT"$SM0->M0_INSC .Or. fisGetParam('MV_SM0CONT','1')=="2",.T.,.F.))
	If Empty(cCodMuni)
		cCodMuni  := IIf(lHist, SS3->S3_COD_MUN, SA2->A2_COD_MUN)
	EndIf
	cUfDest   := IIf(lHist, IIf(cTipoNf$"DB",SS3->S3_EST,cMvEstado), IIf(cTipoNf$"DB",SA2->A2_EST,cMvEstado))
	cUfOrig   := IIf(lHist, IIf(cTipoNf$"DB",cMvEstado,SS3->S3_EST), IIf(cTipoNf$"DB",cMvEstado,SA2->A2_EST))
	cCNPJ     := IIf(lHist, SS3->S3_CGC, SA2->A2_CGC)

	If cTpComp == "F" .And. cOperNf == "E" .And. (Alltrim(cEspecie)$"CTR/CTE/CTA/CA/CTF/CTEOS" .Or. "NFST"$cEspecie ) //cliente irá alterar o NFOrig pelo MATA116 e manteremos a UF original para gravação no Livro
		cUfCliDest := cUfOrig
	EndIf

	If cPaisLoc == "ARG" //Argentina inicializa a provincia do Fornecedor
		cProvEnt  := IIf(lHist, SS3->S3_EST, SA2->A2_EST)
	EndIf

	If lInclui
		cNatureza := IIf(!Empty(fisGetParam('MV_2DUPNAT','')), &(fisGetParam('MV_2DUPNAT','')),"")
		If Empty( cTpCliFor )
			// Converte os tipos do fornecedor para os tipos validos
			cTpCliFor := IIf(lHist, IIf( SS3->S3_TIPO == "J" .Or. SS3->S3_TIPO == " " , "R" , SS3->S3_TIPO ), IIf( SA2->A2_TIPO == "J" .Or. SA2->A2_TIPO == " " , "R" , SA2->A2_TIPO ))
		EndIf
	Else
		cTpCliFor := IIf(lHist, IIf( SS3->S3_TIPO == "J" .Or. SS3->S3_TIPO == " " , "R" , SS3->S33_TIPO ), IIf( SA2->A2_TIPO == "J" .Or. SA2->A2_TIPO == " " , Iif(Empty(cTpCliFor),"R",cTpCliFor) , SA2->A2_TIPO ))
	EndIf

	If cPaisLoc == "BRA"

		cRecISS  := IIf(lHist, IIf(SS3->S3_RECISS<>"S","2","1"), IIf(SA2->A2_RECISS<>"S","2","1"))
		cRecINSS := IIf(lHist, SS3->S3_RECINSS, SA2->A2_RECINSS)
		cCalcINP := IIf(lHist, IIf(fisExtCmp('12.1.2310', .T.,'SA2','A2_CALCINP'),SS3->S3_CALCINP,"2"), IIf(fisExtCmp('12.1.2310', .T.,'SA2','A2_CALCINP'),SA2->A2_CALCINP,"2"))
		cRecSEST := IIf(lHist, IIf(fisExtCmp('12.1.2310', .T.,'SA2','A2_RECSEST'),SS3->S3_RECSEST,"2"), IIf(fisExtCmp('12.1.2310', .T.,'SA2','A2_RECSEST'),SA2->A2_RECSEST,"2"))
		cRecPIS  := IIf(lHist, IIf(SS3->S3_RECPIS<>"2","N","S"), IIf(SA2->A2_RECPIS<>"2","N","S"))
		cRecCOFI := IIf(lHist, IIf(SS3->S3_RECCOFI<>"2","N","S"), IIf(SA2->A2_RECCOFI<>"2","N","S"))
		cRecCSLL := IIf(lHist, IIf(SS3->S3_RECCSLL<>"2","N","S"), IIf(SA2->A2_RECCSLL<>"2","N","S"))

		If !Empty(cRecolheISS)
			cRecISS  := cRecolheISS
		Endif

		If fisExtCmp('12.1.2310', .T.,'SB1','B1_AFETHAB')  .And. fisExtCmp('12.1.2310', .T.,'SA2','A2_RECFET')  .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RECFET') .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CALCFET')
			cRecFet  := IIf(lHist, IIf(Empty(SS3->S3_RECFET),"2",SS3->S3_RECFET), IIf(Empty(SA2->A2_RECFET),"2",SA2->A2_RECFET))
		Endif

		If fisExtCmp('12.1.2310', .T.,'SB1','B1_AFABOV') .And. fisExtCmp('12.1.2310', .T.,'SA2','A2_RFABOV') .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RFABOV') .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CFABOV')
			cRecFab  := IIf(lHist, IIf(Empty(SS3->S3_RFABOV),"2",SS3->S3_RFABOV), IIf(Empty(SA2->A2_RFABOV),"2",SA2->A2_RFABOV))
		Endif

		If fisExtCmp('12.1.2310', .T.,'SB1','B1_AFACS') .And. fisExtCmp('12.1.2310', .T.,'SA2','A2_RFACS') .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RFACS')  .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CFACS')
			cRecFac  := IIf(lHist, IIf(Empty(SS3->S3_RFACS),"2",SS3->S3_RFACS), IIf(Empty(SA2->A2_RFACS),"2",SA2->A2_RFACS))
		Endif

		If fisExtCmp('12.1.2310', .T.,'SB1','B1_AFAMAD') .And. fisExtCmp('12.1.2310', .T.,'SA2','A2_RECFMD') .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RECFMD')  .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CFAMAD')
			cRecFMD  := IIf(lHist, IIf(Empty(SS3->S3_RECFMD),"2",SS3->S3_RECFMD), IIf(Empty(SA2->A2_RECFMD),"2",SA2->A2_RECFMD))
		Endif

		If fisExtCmp('12.1.2310', .T.,'SB1','B1_AIMAMT') .And. fisExtCmp('12.1.2310', .T.,'SA2','A2_RIMAMT') .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RIMAMT') .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CIMAMT')
			cRecIMAMT  := IIf(lHist, IIf(Empty(SS3->S3_RIMAMT),"2",SS3->S3_RIMAMT), IIf(Empty(SA2->A2_RIMAMT),"2",SA2->A2_RIMAMT))
		Endif

		If fisExtCmp('12.1.2310', .T.,'SB1','B1_AFASEMT') .And. fisExtCmp('12.1.2310', .T.,'SA2','A2_RFASEMT') .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RFASEMT') .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CFASE')
			cRecFASEMT  := IIf(lHist, IIf(Empty(SS3->S3_RFASEMT),"2",SS3->S3_RFASEMT), IIf(Empty(SA2->A2_RFASEMT),"2",SA2->A2_RFASEMT))
		Endif

		cModIRF  := IIf(lHist, IIf(fisExtCmp('12.1.2310', .T.,'SA2','A2_CALCIRF'),SS3->S3_CALCIRF,"1"), IIf(fisExtCmp('12.1.2310', .T.,'SA2','A2_CALCIRF'),SA2->A2_CALCIRF,"1"))
		cOPIrrf  := IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SA2','A2_TPESSOA'),SS3->S3_TPESSOA,""), Iif(fisExtCmp('12.1.2310', .T.,'SA2','A2_TPESSOA'),SA2->A2_TPESSOA,""))
		cSimpNac := IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SA2','A2_SIMPNAC'),SS3->S3_SIMPNAC,""), Iif(fisExtCmp('12.1.2310', .T.,'SA2','A2_SIMPNAC'),SA2->A2_SIMPNAC,""))
		nNumDep  := IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SA2','A2_NUMDEP'),SS3->S3_NUMDEP,0), Iif(fisExtCmp('12.1.2310', .T.,'SA2','A2_NUMDEP'),SA2->A2_NUMDEP,0))  	//so verifico os dependentes para os fornecedores
		cIRFProg := IIf(lHist, IIf(lA2IRPROG,SS3->S3_IRPROG,"2"), IIf(lA2IRPROG,SA2->A2_IRPROG,"2"))
		cRegeSim := IIf(lHist, IIf(fisExtCmp('12.1.2310', .T.,'SA2','A2_REGESIM'), SS3->S3_REGESIM , "" ), IIf(fisExtCmp('12.1.2310', .T.,'SA2','A2_REGESIM'), SA2->A2_REGESIM , "" ))
		cNReduz  := IIf(lHist, SS3->S3_NREDUZ, SA2->A2_NREDUZ)
		cIdSA2   := IIf(lHist, If(fisExtCmp('12.1.2310', .T.,'SA2','A2_IDHIST'), SS3->S3_IDHIST, ""), If(fisExtCmp('12.1.2310', .T.,'SA2','A2_IDHIST'), SA2->A2_IDHIST, ""))
		nRecCide := IIf(lHist, If(fisExtCmp('12.1.2310', .T.,'SA2','A2_RECCIDE'), SS3->S3_RECCIDE, ""), If(fisExtCmp('12.1.2310', .T.,'SA2','A2_RECCIDE'), SA2->A2_RECCIDE, ""))
		cGrossIR := IIf(lHist, If(fisExtCmp('12.1.2310', .T.,'SA2','A2_GROSSIR'), SS3->S3_GROSSIR, ""), If(fisExtCmp('12.1.2310', .T.,'SA2','A2_GROSSIR'), SA2->A2_GROSSIR, ""))

		If cOperNf == "E" .And. !Empty(cCltdest) .And. !Empty(cLjtdest) .And. (AllTrim(cEspecie) $ "CTR/CTE/CTA/CA/CTF" .Or. "NFST"$AllTrim(cEspecie))
			lA1Cntdest	:= fisExtCmp('12.1.2310', .T.,'SA1','A1_CONTRIB')
			dbSelectArea("SA1")
			dbSetOrder(1)
			If SA1->(MsSeek(xFilial("SA1")+cCltdest+cLjtdest))
				If lHistorico
					cHstA1Dest := (cAlsCab)->F1_IDSA1
					If cPaisLoc == "BRA" .And.  Alltrim(SA1->A1_IDHIST)<>Alltrim(cHstA1Dest)
						dbSelectArea("SS2")
						dbSetOrder(1)
						MsSeek(xFilial("SS2")+cHstA1Dest+cCltdest+cLjtdest)
						lHistDest := .T.
					EndIf
				EndIf

				linscDest := IIf(lHistDest, IIf(Empty(SS2->S2_INSCR).Or."ISENT"$SS2->S2_INSCR.Or."RG"$SS2->S2_INSCR.Or.( lA1Cntdest .And. SS2->S2_CONTRIB == "2"),.T.,.F.), IIf(Empty(SA1->A1_INSCR).Or."ISENT" $ SA1->A1_INSCR .Or. "RG" $ SA1->A1_INSCR .Or.( lA1Cntdest .And. SA1->A1_CONTRIB == "2"),.T.,.F.))
				If SA1->A1_CONTRIB == "1" .And. (SA1->A1_TPJ == "3" .or. SA1->A1_TPJ == "1") .And. Empty(SA1->A1_INSCR)
					linscDest := .F.
				Endif
				If IIf(lHistDest, !Empty(SS2->S2_INSCRUR) .And. "L" $ SS2->S2_TIPO .And. ( lA1Cntdest .And. SS2->S2_CONTRIB <> "2"), !Empty(SA1->A1_INSCRUR) .And. "L" $ SA1->A1_TIPO .And. ( lA1Cntdest .And. SA1->A1_CONTRIB <> "2"))
					linscDest := .F.
				EndIf
				cUfCliDest := IIf(lHistDest,SS2->S2_EST,SA1->A1_EST)
				cUfDest := cUfCliDest
			Endif
		Endif

		cDedBsPC := IIf(lHist, If(fisExtCmp('12.1.2310', .T.,'SA2','A2_DEDBSPC'), SS3->S3_DEDBSPC, " "), If(fisExtCmp('12.1.2310', .T.,'SA2','A2_DEDBSPC'), SA2->A2_DEDBSPC, " "))
		cTipoRur := IIf(lHist, If(fisExtCmp('12.1.2310', .T.,'SA2','A2_TIPORUR'), SS3->S3_TIPORUR, ""),  If(fisExtCmp('12.1.2310', .T.,'SA2','A2_TIPORUR'), SA2->A2_TIPORUR, ""))
		cTPJFor	 := IIf(lHist, SS3->S3_TPJ, SA2->A2_TPJ)

		nPerFECP := fisGetParam('MV_PERFECP',0)
	EndIf
EndIf

If Empty(cUfPreISS)
	IF cOperNF == "E"
		cUfPreISS := cUfOrig
	Else
		cUfPreISS := cUfDest
	EndIf
EndIf

cMunForISS := cCodMuni

IF fisExtTab('12.1.2310', .T., 'F0R') .And. fisExtCmp('12.1.2310', .T.,'F0R','F0R_INDICE')
	If F0R->(MsSeek(xFilial("F0R")+cUfDest+AnoMes(dDtEmiss)))
		nIndice:= F0R->F0R_INDICE
	EndIf
EndIf


//Parametro "MV_INDUPF", utilizado para informar o campo da tabela SM2 (Moedas) que sera utilizado para informar o indexador UPF/MT, com a finalidade de calcular as contribuições FETHAB, FACS, FABOV, FAMAD
IF cPaisLoc == 'BRA'
	If fisExtCmp('12.1.2310', .T.,'SM2',fisGetParam('MV_INDUPF',''))
	    SM2->(dbSetOrder(1))
	    If SM2->(MsSeek(dDataBase))
	        nIndUpf := SM2->&(Alltrim(fisGetParam('MV_INDUPF','')))
	    Endif
	Endif
EndIf

dbSelectArea("SED")
SED->(dbSetOrder(1))

If SED->(MsSeek(xFilial("SED")+cNatureza))
	If lHistorico
		If ( cCliFor == "C" .And. !cTipoNf$"D|B") .Or. (cCliFor == "F" .And. cTipoNf$"D|B")
			cHistSED :=	(cAlsCab)->F2_IDSED
		Else
			cHistSED :=	(cAlsCab)->F1_IDSED
		EndIf
		lHistrt := .F.
		If cPaisLoc == "BRA" .And. Alltrim(SED->ED_IDHIST)<>Alltrim(cHistSED)
			dbSelectArea("SS7")
			dbSetOrder(1)
			MsSeek(xFilial("SS7")+cHistSED)
			lHist := .T.
		EndIf
	EndIf

	aInfNat := {IIf(lHist, SS7->S7_CODIGO,  SED->ED_CODIGO),;  //aInfNat->01
				IIf(lHist, SS7->S7_CALCIRF, SED->ED_CALCIRF),; //aInfNat->02
				IIf(lHist, SS7->S7_PERCIRF, SED->ED_PERCIRF),; //aInfNat->03
				IIf(lHist, SS7->S7_BASEIRF, SED->ED_BASEIRF),; //aInfNat->04
				IIf(lHist, SS7->S7_PERCINS, SED->ED_PERCINS),; //aInfNat->05
				IIf(lHist, SS7->S7_BASEINS, SED->ED_BASEINS),; //aInfNat->06
				IIf(lHist, SS7->S7_CALCINS, SED->ED_CALCINS),; //aInfNat->07
				IIf(lHist, SS7->S7_CALCISS, SED->ED_CALCISS),; //aInfNat->08
				IIf(lHist, SS7->S7_CALCPIS, SED->ED_CALCPIS),; //aInfNat->09
				IIf(lHist, SS7->S7_PERCPIS, SED->ED_PERCPIS),; //aInfNat->10
				IIf(lHist, SS7->S7_CALCCOF, SED->ED_CALCCOF),; //aInfNat->11
				IIf(lHist, SS7->S7_PERCCOF, SED->ED_PERCCOF),; //aInfNat->12
				IIf(lHist, SS7->S7_CALCCSL, SED->ED_CALCCSL),; //aInfNat->13
				IIf(lHist, SS7->S7_PERCCSL, SED->ED_PERCCSL),; //aInfNat->14
				IIf(lHist, SS7->S7_BASESES, SED->ED_BASESES),; //aInfNat->15
				IIf(lHist, SS7->S7_PERCSES, SED->ED_PERCSES),; //aInfNat->16
				IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_IDHIST'), SS7->S7_IDHIST,""), Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_IDHIST'), SED->ED_IDHIST,"")),; // aInfNat -> 17
				IIf(lHist, SS7->S7_DEDINSS, SED->ED_DEDINSS),; // aInfNat -> 18
				IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_CALCCID'), SS7->S7_CALCCID,""), Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_CALCCID'), SED->ED_CALCCID,"")),; // aInfNat -> 19
				IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_PERCCID'), SS7->S7_PERCCID,0), Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_PERCCID'), SED->ED_PERCCID,0)),; // aInfNat -> 20
				IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_BASECID'), SS7->S7_BASECID,0), Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_BASECID'), SED->ED_BASECID,0)),; // aInfNat -> 21
				IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_IRRFCAR'), SS7->S7_IRRFCAR,""), Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_IRRFCAR'), SED->ED_IRRFCAR,"")),; // aInfNat -> 22
				IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_BASEIRC'), SS7->S7_BASEIRC,0), Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_BASEIRC'), SED->ED_BASEIRC,0)),; // aInfNat -> 23
				IIf(lHist, "", Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_CALCFMP'), SED->ED_CALCFMP,"2")),; // aInfNat -> 24
				IIf(lHist, 0, Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_PERQFMP'), SED->ED_PERQFMP,0)),; // aInfNat -> 25
				IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_CALCINP'), SS7->S7_CALCINP,"2"), Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_CALCINP'), SED->ED_CALCINP,"2")),; // aInfNat -> 26
				IIf(lHist, Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_PERCINP'), SS7->S7_PERCINP,0), Iif(fisExtCmp('12.1.2310', .T.,'SED','ED_PERCINP'), SED->ED_PERCINP,0))} // aInfNat -> 27
Else
	aInfNat := {"",;	// aInfNat -> 01 - ED_CODIGO
				"",;	// aInfNat -> 02 - ED_CALCIRF
				0 ,;	// aInfNat -> 03 - ED_PERCIRF
				0 ,;	// aInfNat -> 04 - ED_BASEIRF
				0 ,;	// aInfNat -> 05 - ED_PERCINS
				0 ,;	// aInfNat -> 06 - ED_BASEINS
				"",;	// aInfNat -> 07 - ED_CALCINS
				"",;	// aInfNat -> 08 - ED_CALCISS
				"",;	// aInfNat -> 09 - ED_CALCPIS
				0 ,;	// aInfNat -> 10 - ED_PERCPIS
				"",;	// aInfNat -> 11 - ED_CALCCOF
				0 ,;	// aInfNat -> 12 - ED_PERCCOF
				"",;	// aInfNat -> 13 - ED_CALCCSL
				0 ,;	// aInfNat -> 14 - ED_PERCCSL
				0 ,;	// aInfNat -> 15 - ED_BASESES
				0 ,;	// aInfNat -> 16 - ED_PERCSES
				"",;	// aInfNat -> 17 - ED_IDHIST
				"",;	// aInfNat -> 18 - ED_DEDINSS
				"N",;	// aInfNat -> 19 - ED_CALCCID
				0,;		// aInfNat -> 20 - ED_PERCCID
				0,;     // aInfNat -> 21 - ED_BASECID
				"",;	// aInfNat -> 22 - ED_IRRFCAR
				0,;     // aInfNat -> 23 - ED_BASEIRC
				"2",;	// aInfNat -> 24 - ED_CALCFMP
				0,;		// aInfNat -> 25 - ED_PERQFMP
				"2",;	// aInfNat -> 26 - ED_CALCINP
				0}		// aInfNat -> 27 - ED_PERCINP
EndIf

aNfCab := {cTipoNF,;//1
cOperNF,;//2
cCliFor,;//3
cTpCliFor,;//4
lInscrito,;//5
cGrpCliFor,;//6
cUFdest,;//7
cUfOrig,;//8
0,;//9
0,;//10
0,;//11
0,;//12
0,;//13
0,;//14
{0,0,0,0,0,0,0,0,"1"},;//15
{0,0,0},;//16
0,;//17
0,;//18
0,;//19
cCodCliFor,;//20
cLoja,;//21
{},;//22
{0,0,0},;//23
{0,0,0,.F.,0,.F.},;//24
{0,0},;//25
cNatureza,;//26
0,;//27
{},;//28
{},;//29
IIf(lInclui .And. !lPlanilha,{{'...','',0,0,0,'NEW'}},{{"","",0,0,0,""}}),;//30
0,;//31
aRelImp,;//32
IIf(lInclui .And. !lPlanilha,{{'...','',0,0,'NEW'}},{{"","",0,0,""}}),;//33
0,;//34
lSuframa,;//35
Array(NMAXIV),;//36
Array(NMAXIV),;//37
cTpComp,;//38
lInsere,;//39
0,;//40
0,;//41
0,;//42
0,;//43
0,;//44
0,;//45
0,;//46
0,;//47
0,;//48
cRotina,;//49
0,;//50
nAliqIRF,;//51
0,;//52
cRecPIS,;//53
cRecCOFI,;//54
cRecCSLL,;//55
cRecISS,;//56
cRecINSS,;//57
nMoeda,;//58
nTxMoeda,;//59
cSerie,;//60
cTipoDoc,;//61
Array(NMAXIV),;//62
0,;//63
0,;//64
cEspecie,;//65
cCNPJ,;//66
0,;//67
0,;//68
0,;//69
cModIRF,;//70
{"","","",""},;//71
cCalcSuf,;//72
0,;//73 - Base de Calculo do AFRMM - NF
0,;//74 - Valor do AFRMM - NF
0,;//75
0,;//76
cOPIrrf,;//77
{0,0},;//78 - Array dos valores do SEST
cRecSEST,;//79 - Recolhe SEST
0,;//80 - Base de calculo do PIS Subst. Tributaria
0,;//81 - Valor do PIS Subst. Tributaria
0,;//82 - Base de calculo da COFINS Subst. Tributaria
0,;//83 - Valor da COFINS Subst. Tributaria
0,;//84 - Valor Total do Frete de Pauta
0,;//85 - Valor FETHAB
cRecFet,;//86 - Recolhe FETHAB
cCliEnt,;//87 - Codigo do cliente de entrega
cLojEnt,;//88 - Loja do cliente de entrega
0,;//89 - Valor do Fundersul - Mato Grosso do Sul
0,;//90 - Valor do Estorno de Credito
cSimpNac,;//91 - Enquadra no Simples Nacional
aTransp,;//92 - Dados do transportador para o calculo do ICMS do frete autonomo embarcador
0,;//93 - Base do ICMS de transporte Substituicao Tributaria
0,;//94 - Base do ICMS de transporte Substituicao Tributaria
0,;//95 - Credito Presumido Simples Nacional - SC
0,;//96 - Valor Antecipacao ICMS
0,;//97 - Despesas nao tributadas - Portugal
0,;//98 - Tara - Portugal
nNumDep,;//99 - Numero de dependentes - cálculo base IRRF pessoa fisica
cProvEnt,;//100 - Provincia de entrega
0,;//101 - Valor do FECP
0,;//102 - Valor do FECP ST
0,;//103 - Valor Crédito Presumido - SC
cIRFProg,;//104 - Calcula IR pela Tabela Progressiva mesmo sendo Pessoa Juridica
0,;//105 - Valor do imposto de Importacao
.T.,;//106 - Flag para recalculo de impostos variaveis
0,;//107 - Valor do credito presumido PE
Array(NMAXIV),;//108 - Valor do ORIGINAL DO iMPOSTO
0,;//109 - Valor FABOV - Mato Grosso
cRecFab,;//110 - Reponsabilidade de recolhimento FABOV - Mato Grosso
0,;//111 - Valor FACS - Mato Grosso
cRecFac,;//112 - Reponsabilidade de recolhimento FACS - Mato Grosso
lCalcIPI,;//113 - Calcula IPI (SIGALOJA)
0,;//114 - Valor do FUMACOP
0,;//115 - Valor do Senar
0,;//116 - Credito Outorgado SP
0,;//117 - Base do ICMS sem desconto - Decreto 43.080/02-MG
0,;//118 - Valor do ICMS sem desconto - Decreto 43.080/02-MG
0,;//119 - Valor do Desconto - Decreto 43.080/02-MG
0,;//120 - Valor do ICMS sem debito de imposto - Decreto 43.080/02-MG
0,;//121 - Base do FUNRURAL
cPedido,;//122 - Pedido de Venda
cCodMuni,;//123 - Codigo do Municipio utilizado na operacao
{0,0},;//124 - Valor TPDP - PB
0,;//125 - Valor incentivo prod.leite RICMS/MG
0,;//126 - Base de calculo do INSS Condições Especiais
0,;//127 - Valor do INSS Condições Especiais
0,;//128 - Valor do FECOP-RN
0,;//129 - Valor do FECOP ST-RN
0,;//130 - Credito Presumido
0,;//131 - Valor do FECP-MG
0,;//132 - Valor do FECP ST-MG
0,;//133 - Valor do Reintegra
0,;//134 - Base de Calculo do Reintegra
0,;//135 - Valor do FECP-MT
0,;//136 - Valor do FECP ST-MT
cRegeSim,;//137 - Regime Simp. MT
nPercAtm,;//138 - Perc. Carga media
cPessoa,;//139 - Pessoa - Fisica/Juridica
cNReduz,;//140 - Nome Fantasia
cCRDMA,;//141 - Credito Estimulo de Manaus
cSimpSC,;//142 - Clie. optante SIMPLES/SC
cCDRDes,;//143 - Regiao do Cliente
{cCliFat,cLojCFat,cTipoFat,cGrpCliFat,cNatCliFa},;//144 - Cliente, Loja, Tipo, Grupo e Natureza do cliente do Faturamento (utilizado para PIS e COFINS)
0,;//145 - Abatimentos de Materiais do ISS
0,;//146 - Abatimentos de Servicos do ISS
0,;//147 - Abatimentos de Materiais do INSS
0,;//148 - Abatimentos de Servicos do INSS
0,;//149 - Adiantamento
nTotPed,;//150 - Total do Pedido
dDtEmiss,;//151 - Emissao do documento
cIDSA1,;//152 - ID Historico Cliente
cIDSA2,;//153 - ID Historico Fornecedor
aInfNat[18],;//154 - ID Historico Natureza
0 ,;//155 - Total do Desconto do Item - USO DO NOVO PDV - LOJA
0 ,;//156 - Total do Acrescimos do Item - USO DO NOVO PDV - LOJA
cTpFrete ,;//157 - Tipo de Frete definido no pedido de Venda
cFRetIss ,;//158 - Forma de Retencao do ISS. 1 - Considera Valor Minimo; 2 - Sempre Retem
cUfPreISS,;//159 - UF da prestacao do servico do ISS onde o servico foi prestado
Array(NMAXUF),;//160 -Array com conteúdo da tabela CFC
0,;//161 - Valor Cide
nRecCide,;//162 - Rec Cide
0,;//163 - Valor do FETAHB retido pelo cliente/fornecedor
" ",;//164 - Modalidade CTE / SF1
0,;//165 - NF_BASNDE
0,;//166 -NF_ICMNDES
0,;//167 - Total de adiantamento
0,;//168-Base de Calculo CIDE
0,;//169-Base do ISS CEPOM
0,;//170-Valor do ISS CEPOM
0,;//171-Valor IPI a ser inserido na base do ICM, venda futura CF
0,;//172- Base Fumipeq
0,;//173- Valor Fumipeq
0,;//174-Valor Famad
cRecFMD,;//175-Responsabilidade de recolhimento FAMAD - Mato Grosso
cSerSat,;//176- Série do CF-e SAT
0,;//177- Base ICMS ST Recolh. Ant.
0,;//178- Valor ICMS ST Recolhido Anteriormente.
cTpCompl,;//179- Tipo de Complemento
0,;//180- Difal
.F.,;//181- Regra para calculo de Difal para consumidor final
0,;//182 - FECP DIFAL
0,;//183 - Base Destino DIFAL
cCltdest,;//184 - Cliente de destino da mercadoria
cLjtdest,;//185 - Loja de destino da mercadoria
cUfCliDest,;//186- UF de destino da mercadoria
linscDest,;//187 - verifica se cliente de destino da mercadoria é contribuinte
0,;//188 - Valor FUNDESA
0,;//189 - Valor IMA-MT
0,;//190 - Valor FASE-MT
0,;//191 - Valor do IMA-MT retido pelo cliente/fornecedor
0,;//192 - Valor do FASE-MT retido pelo cliente/fornecedor
cRecIMAMT,;//193 - Reponsabilidade de recolhimento IMA-MT
cRecFASEMT,;//194 - Reponsabilidade de recolhimento FASE-MT
0,;//195 - Preço Médio Ponderado, para ser utilizado como base de ICMS ST
nIndice,;//196 - Indice tabela F0R
0,;//197 - Valor do Pedágio
cAtividad,;//198 - Actividad economica
cCalcINP,;//199 - Calcula INSS Patronal
0,;//200 - Valor do INSS Patronal
0,;//201 - Valor do AFRMM na Importação
0,;//202 - Valor PROTEGE-GO
nIndUpf,;//203 - Indice Mato Grosso
0,;//204 - Valor FEEF-GO
cDedBsPC,;//205 - Impostos que serão deduzidos da base de PIS/COFINS.
cM0CodMun,;// 206 - Codigo do municipio do SIGAMAT.
cTipoRur,;// 207 - Tipo do Fornecedor para efeito da contribuicao seguridade social.
cRecIRRF,;// 208 - Recolhe IRRF sim ou não.
0,;//209 - Base do FCP recolhido anteriormente.
0,;//210 - Valor do FCP recolhido anteriormente.
nPerFECP,;//211 - Percentual do FECP-ST "por CNAE": Campo A1_PERFECP ou parametro MV_PERFECP.
0,;//212 - Base do FECP - Proprio.
0,;//213 - Base do FECP - ST.
0,;//214 - Base do FECP - Complementar.
lEmiteNF,;//215 - Se esta emitindo nota fiscal ou cupom fiscal (Sigaloja)
aAliqSN,; //216 - Alíquotas de ICMS/ISS calculadas pela apuração do SN
lUsaAlqSN,; // 217 - Define se devem ou não ser utilizadas as alíquotas calculadas pela apuração do SIMPLES NACIONAL.
cGrossIR,;//218 - Opção da base de cálculo do IR, se deverá ou não fazer o Gross Up
cTPJFor,;//219 - Tipo de pessoa jurídica do fornecedor
"",;//220 - calcular valor Declaratorio
lTemF2B,;   //221 Flag para indicar se existe, ao menos, uma regra na tabela F2B
{},;//222 Totalizador dos tributos genéricos.
lCalcTG,; //223-Flag para indicar se os tributos genéricos devem ou não ser calculados - deve ser passado como .T. somente após a preparação da rotina para gravação, visualização e exclusão dos tributos genéricos.
lPerfPart,; //224 - Indica se o participante está contido em ao menos 1 perfil de participante dos tributos genéricos
nQtdItens,;//225 - Quantidade de itens do documento.
tcgetdb(),;//226 - Tipo de Banco de dados
0,;//227 - Valor do ICMS a ser deduzido
{},;//228 - Controle do SavaDec dos tributos genéricos
fisFindFunc("ChkTribLeg"),;//229 - Flag indicando se deve chamar função ChkTribLeg de verificação de tributo genérico com ID de tributo legado.
0,;		//230 - Grand Total in main currency
Array(NMAXIV),;//231 - Tax calculation base in main currency
Array(NMAXIV),;//232 - Value of Tax in main currency
0,; //233 - Goods Value in main currency
0,; //234 - Campo de Libro Fiscal para IPM
0,; //235 - Alicuota para el IPM
cNumNota,;	//236 - número da nota
lF2BTeste} //237 - Considera regras do configurador com status = 1- Teste s

//	Carga das referencias vinculadas a tabela UF x UF
//  Foi necessario criar as referencias da tabela CFC no cabecalho e fazer o seek desta tabela na MaFisIni() para que nao
// seja preciso colocar o seek de UF x UF na funcao MaFisIniCpo(), evitando que sejam feitas duas consultas por item. Com
// esta mecanica, sera feito 1 seek no cabecalho com a chave UF x UF e 1 seek por item com a chave UF x UF x Produto.
//  Utilizo o PadR[TamSx3] na posicao 3 do indice (codigo do produto) para garantir que nao seja cacheado no cabecalho o
// conteudo de um registro de item, onde o produto esteja preenchido.

// Carga da tabela CFC.
MaSeekCFC(1)

// Inicializa arrays de impostos variaveis
aNfCab[NF_BASEIMP]:=Afill(aNfCab[NF_BASEIMP],0)
aNfCab[NF_VALIMP]:=Afill(aNfCab[NF_VALIMP],0)
aNfCab[NF_MINIMP]:=Afill(aNfCab[NF_MINIMP],0)
aNfCab[NF_VLRORIG]:=Afill(aNfCab[NF_VLRORIG],0)
If cPaisLoc == "RUS"
	aNfCab[NF_BASEIMP_C1]	:=	Afill(aNfCab[NF_BASEIMP_C1],0)
	aNfCab[NF_VALIMP_C1]	:=	Afill(aNfCab[NF_VALIMP_C1],0)
EndIf
// Cria o array de Referencias
If aItemRef == Nil
	MaIniRef()
EndIf

// Cria o array de arredondamentos do item
If aSaveDec == Nil
	aSaveDec := Array(Len(aItemRef))
	aFill(aSaveDec,0)
EndIf

If aAuxOri == Nil
	aAuxOri := {}
EndIf

If aNFCab[NF_SAVEDEC_TG] == Nil
	aNFCab[NF_SAVEDEC_TG]	:= {}
EndIF

RestArea(aAreaSA1)
RestArea(aAreaSA2)
RestArea(aArea)

//Adiciona Telemetria quando inicializado MATXFIS
FisXTelem("MATXFIS")
Return(.T.)
/*MaFisIniLo Edson Maricate 09.12.99
Esta rotina tem como objetivo inicializar a variavel aNFItem
Rotina inicializacao do item da funcao Fiscal
Parametros
ExpN1: Item do Array ANFItem que deve ser inicializado
ExpA2: Array de otimizacao de Inicializacao(OPC)
ExpL3: Indica se o item deve ser estornado caso exista
*/
Function MaFisIniLoad(nItem,aLoad,lEstorno,cIdTribGen)

DEFAULT lEstorno := .F.
Default cIdTribGen	:= ""//Id dos tributos genéricos para visualização/exclusão

If !MaFisFound("IT",nItem)

	If aLoad == Nil
		aLoad := Array(14)
		aLoad[01] := IIf( aNfCab[NF_OPERNF] == "S" , Space(Len(SD2->D2_COD)) , Space(Len(SD1->D1_COD)))
		aLoad[02] := "   "
		aLoad[03] :=  If(cPaisLoc == "BRA" ,Space(Len(SD1->D1_CODISS)) , Space(9) )
		aLoad[04] := 0
		aLoad[05] := Space(Len(SD1->D1_NFORI))
		aLoad[06] := Space(Len(SD1->D1_SERIORI))
		aLoad[07] := 0
		aLoad[08] := 0
		aLoad[09] := Nil
		aLoad[10] := ""
		aLoad[11] := ""
		aLoad[12] := Space(Len(aLoad[1])) 	// Codigo do Produto Fiscal
		aLoad[13] := 0 						// Recno do Produto Fiscal
		aLoad[14] := Space(FisTamSX3( 'SD1','D1_OPER' )[1]) // Tipo de Operação
	EndIf

	aadd(aNfItem,{"",;//1-Grupo de Tributacao
	{},;//2-Array contendo as excessoes Fiscais
	0,;//3-Aliquota de ICMS
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},;//4-Valores de ICMS
	0,;//5-Aliquota de IPI
	{0,0,0,0,0},;//6-Valores de IPI
	aLoad[5],;//7-Numero da NF Original
	aLoad[6],;//8-Serie da NF Original
	aLoad[9],;//9-RecNo da NF original
	0,;//10-Valor do desconto do item
	0,;//11-Valor do Frete
	0,;//12-Valor da despesa
	0,;//13-Valor do seguro
	0,;//14-Valor do frete autonomo
	0,;//15-Valor da Mercadoria
	aLoad[1],;//16-Codigo do produto
	aLoad[2],;//17-Codigo da TES
	0,;//18-Valor Total do item
	"",;//19-Codigo FIscal de Operacao
	0,;//20-Valor do Funrural
	0,;//21-Aliquota para calculo do FunRural
	.F.,;//22-Flag de controle para itens deletados
	MaFisRetLF() ,;//23-Array Contendo o demonstrativo fiscal
	{0,0,0,aLoad[3],"","","",0,0,0,.F.},;//24-Array contendo os valores de ISS
	{0,0,0,0,.F.,0,0},;//25-Array contendo os valores de IR
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},;//26-Array contendo os valores de INSS
	0 ,;//27-Valor da Embalagem
	Array(NMAXIV),;//28
	Array(NMAXIV),;//29
	Array(NMAXIV),;//30
	0,;//31
	0,;//32
	Array(NMAXIV),;//33
	aLoad[4],;//34
	0,;//35
	0,;//36
	0,;//37
	0,;//38
	0,;//39
	0,;//40
	0,;//41
	0,;//42
	0,;//43
	0,;//44
	0,;//45
	0,;//46
	0,;//47
	0,;//48
	aLoad[7],;//49
	aLoad[8],;//50
	0,;//51
	aNFCAB[NF_TIPONF],;//52
	"",;//53
	0,;//54
	0,;//55
	0,;//56
	0,;//57
	0,;//58
	0,;//59
	0,;//60
	0,;//61
	0,;//62
	0,;//63
	0,;//64
	0,;//65
	0,;//66-AFRMM
	0,;//67
	0,;//68
	0,;//69
	0,;//70
	0,;//71
	"",;//72
	Iif(aNfCab[NF_OPERNF]=="S", StrZero(1,FisTamSX3('SD2','D2_ITEM')[1],0), StrZero(1,FisTamSX3('SD1','D1_ITEM')[1],0)),;//73
	{0,0,0},;//74-Array contendo os valores do SEST
	0,;//75-Base de calculo do PIS Subst. Tributaria
	0,;//76-Aliquota do PIS Subst. Tributaria
	0,;//77-Valor do PIS Subst. Tributaria
	0,;//78-Bae da COFINS Subst. Tributaria
	0,;//79-Aliquota da COFINS Subst. Tributaria
	0,;//80-Valor da COFINS Subst. Tributaria
	0,;//81-Valor do Frete de Pauta
	0,;//82-Base FETHAB
	0,;//83-Aliquota FETHAB
	0,;//84-Valor FETHAB
	0,;//85-Abatimento do Valor do INSS em Valor-Subcontratada
	{"","","","","","",0,0,0,0,0,0,0,"",0},;//86-SPED
	0,;//87-Abatimento da base de calculo do ISS referente ao material utilizado
	"",;//88-Indica se a operacao, mesmo sem calculo de ICMS ST, faz parte do Regime Especial de Substituicao Tributaria
	0,;//89-Percentual de UFERMS para o calculo do Fundersul-Mato Grosso do Sul
	0,;//90-Valor da UFERMS para o calculo do Fundersul-Mato Grosso do Sul
	0,;//91-Valor do Fundersul-Mato Grosso do Sul
	0,;//92-Valor do Estorno de Credito
	"",;//93-Codigo Autorizacao CODIF-Combustiveis
	0,;//94-Base do ICMS de transporte Substituicao Tributaria
	0,;//95-Aliquota do ICMS de transporte Substituicao Tributaria
	0,;//96-Valor do ICMS de transporte Substituicao Tributaria
	0,;//97-Valor do credito presumido simples nacional-SC
	0,;//98-Valor Antecipacao ICMS
	0,;//99-Valor das despesas nao tributadas-Portugal
	0,;//100-Valor da Tara-Portugal
	Iif(cPaisLoc == "ARG" .and. Type("lLocxAuto")<>"U" .And. lLocxAuto,"  " ,aNFCab[NF_PROVENT]),;//101-Provincia de entrega
	0,;//102-Valor do FECP
	0,;//103-Valor do FECP ST
	0,;//104-Aliquota FECP
	0,;//105-Valor Credito Presumido-SC
	0,;//106-Valor do desconto total proporcionalizado
	{{"",0,0,0}},;//107-Array para o calculo do IVA Ajustado
	{0,0},;//108-Array com os valores do Imposto de Importação
	0,;//109-Valor da Pauta do PIS
	0,;//110-Valor da Pauta do Cofins
	0,;//111-Aliquota de Diferencial Simples
	" ",;//112-Classificacao fiscal
	0,;//113-Valor do imposto ISC (Localizado Peru) por unidade"PER"
	0,;//114-Valor do credito presumido PE
	0,;//115-Valor Credito Presumido-MG
	0,;//116-Valor Dependente
	0,;//117-Credito Presumido CE
	0,;//118-Base FABOV-Mato Grosso
	0,;//119-Aliquota FABOV-Mato Grosso
	0,;//120-Valor FABOV-Mato Grosso
	0,;//121-Base FACS-Mato Grosso
	0,;//122-Aliquota FACS-Mato Grosso
	0,;//123-Valor FACS-Mato Grosso
	0,;//124-Valor do FUMACOP
	0,;//125-Aliquota FUMACOP
	Space(5),;//126-Concepto de Retencao(Equador)
	"",;//127-moticms
	0,;//128-Aliquota do Senar
	0,;//129-Valor do Senar
	0,;//130-Base do Senar
	0,;//131-Valor do Credito Outorgado SP
	0,;//132-Abatimento do valor do INSS Subcontratada
	0,;//133-Base de calculo ICMS sem reducao-Decreto 43.080/02-MG
	0,;//134-Valor ICMS sem reducao-Decreto 43.080/02-MG
	0,;//135-Percentual de reducao-Decreto 43.080/02-MG
	0,;//136-Base do FUNRURAL
	0,;//137-Base Veiculo
	{0,0,0},;//138-Valor da Base(01)/Valor(02)/Aliquota(03) do Regime de Operacoes Simplificadas-MT
	0 ,;//139-Valor da Base do FUMACOP
	0, ;//140-Crédito Presumido PR
	{"","","",CToD("")},;//141-Array contendo as informacoes da Natureza da receita.
	{0,0,0},;//142-Array contendo as informacoes da TPDP.
	0,;//143-Valor incentivo prod.leite RICMS/MG
	0,;//144-Percentual incentivo prod.leite RICMS/MG
	{0,0,0},;//145-Array com valores do INSS Condições Especiais
	0,;//146-Valor do FECOP-RN
	0,;//147-Valor do FECOP ST-RN
	0,;//148-Aliquota FECOP-RN
	0,;//149-Valor do FUE-localização Austrália
	"",;//150-Método utilizado cálculo FUE-localização Austrália
	"2",;//151-NF Emitida sob norma específica
	0,;//152-Coeficiente de PIS por Substituição Tributária para fabricantes de cigarros
	0,;//153-Coeficiente de COFINS por Substituição Tributária para fabricantes de cigarros
	0,;//154-Credito Presumido.
	0,;//155-Preco Unitario utilizado para calculo da Substituição tributária para fabrixante de Cigarros
	"2",;//156-Recolhimento Antecipado-Para atender necessidades do SPEDFISCAL de MG
	0,;//157-Valor do FECP-MG
	0,;//158-Valor do FECP ST-MG
	0,;//159-Aliquota FECP-MG
	0,;//160-Valor de Reintegra
	0,;//161-Base de Calculo do Reintegra
	0,;//162-Valor da COFINS de Importacao Majorada
	0,;//163-Aliquota da COFINS de Importacao Majorada
	0,;//164-Valor do FECP-MT
	0,;//165-Valor do FECP ST-MT
	0,;//166-Aliquota FECP-MT
	Iif(Len(aLoad)>=10,{aLoad[10],aLoad[11]},{"",""}),;//167-1- Lote Produto / 2- Sub-Lote Produto
	"2",;//168-DIAT-SC
	"2",;//169-Campo de diferimento na tabela SB1-Conteudo do parametro MV_ALQDFB1
	0,;//170-Indica o % calculo do ICMS-ST, se utiliza pauta ou margem.
	"",;//171-MaSBCampo("RSATIVO")
	"",;//172-MaSBCampo("POSIPI")
	"",;//173-MaSBCampo("UM")
	"",;//174-MaSBCampo("SEGUM")
	0,;//175-MaSBCampo("AFABOV")
	0,;//176-MaSBCampo("AFACS")
	0,;//177-MaSBCampo("AFETHAB")
	"",;//178-MaSBCampo("TFETHAB")
	{},;//179-Array com a exceção fiscal do cliente do faturamento
	0,;//180-Adiantamento
	"",;//181-Codigo da Natureza da Operacao
	Array(NMAXSB) ,;//182-Dados do cadastro de produtos SB1 ou SBi ou SBZ
	{"","",aNfCab[NF_IDSA1],aNfCab[NF_IDSA2],"","","",aNfCab[NF_IDSED],"","",""},;//183-Array ID's Historico
	0,;//184-DescTot-Desconto dado no Total, reteado por item-Uso do novo PDV-LOJA
	0,;//185-AcresciTot-Acrescimo dado no Total, reteado por item-Uso do novo PDV-LOJA
	0,;//186-Valor da PIS de Importacao Majorada
	0,;//187-Aliquota da PIS de Importacao Majorada
	Iif( Len(aLoad)>11 , aLoad[12] , "" ),;//188-Identificação do produto Fiscal- Demetrio
	Iif( Len(aLoad)>12 , aLoad[13] , 0 ),;//189-Recno do Produto Fiscal-Demetrio
	"" ,;//190-NCM Fiscal
	Array(NMAXUFP),;//191-Array com conteudo da tabela CFC
	0,;//192-Valor Cide
	"",;//193-Convênio 139/06
	0,;//194-VAlor do FETHAB retido pelo cliente
	0,;//195-Aliquota do FECP ST
	0,;//196-Aliquota do FECP Outros (Antecipacao/Diferencial de aliquotas)
	0,;//197-NF_BASNDE
	0,;//198 -NF_ICMNDES
	0,;//199-Adiantamento (PERU)
	0,;//200
	0,;//201-Identifica o preço para Consumidor Final
	0,;//202-Base de cálculo cide
	0,;//203-Aliquota Cide
	0,;//204-Base do ISS CEPOM
	0,;//205-Valor do ISS CEPOM
	0,;//206-Aliquota do ISS CEPOM
	0,;//207-Valor IPI a ser inserido na base do ICM, venda futura CF
	0,;//208-Base Fumipeq
	0,;//209-Valor Fumipeq
	0,;//210-Aliquota Fumipeq
	0,;//211-Base FAMAD
	0,;//212-Valor FAMAD
	0,;//213-Alíquota FAMAD
	Array(MAX_TS),;//214-Array com os dados da TES.
	.F.,;//215-Flag p/ indicar calculo de pauta de PIS
	.F.,;//216-Flag p/ indicar calculo de pauta de COFINS
	"",;//217-Enquadramento IPI
	"",;//218-CEST
	0,;//219-Base do CPRB
	0,;//220-Valor do CPRB
	0,;//221-Aliquota do CPRB
	0,;//222-Código atividade CPRB
	0,;//223-Difal
	0,;//224-Perc Difal destino
	0,;//225-Perc Difal origem
	0,;//226-Valor FECP Difal
	0,;//227-Fator de Redução Desc.ICMS
	0,;//228-Valor de Redução Desc.ICMS
	0,;//229-Base FUNDESA
	0,;//230-Aliquota FUNDESA
	0,;//231-Valor FUNDESA
	0,;//232-Base IMA-MT
	0,;//233-Aliquota IMA-MT
	0,;//234-Valor IMA-MT
	0,;//235-Aliquota IMA-MT (SB1)
	0,;//236-Valor IMA-MT retido clie/for
	0,;//237-Base FASE-MT
	0,;//238-Aliquota FASE-MT
	0,;//239-Valor FASE-MT
	0,;//240-Aliquota FASE-MT (SB1)
	0,;//241-Valor FASE-MT retido clie/for
	0,;//242-Preço Médio Ponderado, para ser utilizado como base de ICMS ST
	aNfCab[NF_INDICE],;//243-Indice tabela F0R
	0,;//244-Valor do Pedágio
	0,;//245-Valor Solidario XML
	0,;//246-Pauta CIDE
	" ",;//247-CSOSN
	0,;//248-Base do INSS Patronal
	0,;//249-Percentual do INSS Patronal
	0,;//250-Valor do INSS Patronal
	IIf(fisExtCmp('12.1.2310', .T.,'SB1','B1_TRIBMUN'), Space(FisTamSX3( 'SB1','B1_TRIBMUN' )[1]), ""),;//251-Código de Trib. Municipal
	0,;//252-Valor do AFRMM na Importação
	0,;//253-Valor do Credito Presumido Paraná
	0,;//254 Valor do desconto-Decreto 43.080/2002 RICMS-MG
	0,;//255-Valor do ICMS da Operação-Sem diferimento (Valor como se não tivesse o diferimento)
	0,;//256-Base PROTEGE-GO
	0,;//257-Aliquota PROTEGE-GO
	0,;//258-Valor PROTEGE-GO
	0,;//259-Base FEEF-RJ
	0,;//260-Aliquota FEEF-RJ
	0,;//261-Valor FEEF-RJ
	"",;//262-Código de Atividade
	"",;//263-Coluna onde será escriturada a parcela diferida, na coluna Outros ou Isentod
	0,;//264-Base do FCP recolhido anteriormente.
	0,;//265-Aliquota do FCP recolhido anteriormente.
	0,;//266-Valor do FCP recolhido anteriormente.
	0,;//267-Aliquota ICMS ST Recolh. Ant.
	0,;//268-Base do FECP-Proprio.
	0,;//269-Base do FECP-ST.
	0,;//270-Base do FECP-Complementar.
	0,;//271-Indice auxiliar do FCP.
	0,;//272-Crédito do Prodepe PE
	"",;//273-Conta Contábil de Receita
	0,;//274-Valor do ICMS antes de ser submetido ao arredondamento
	{},;//275-Código declaratorio
	{},;//276-Tributos Genéricos
	FWUUIDV4(.T.),;//277-Id do tributo genérico, gerado automaticamente pela MATXFIS nas inclusões de notas
	cIdTribGen,; //278-Id do tributo genérico para visualização e exclusão
	IIf(Len(aLoad) >= 14, aLoad[14], Space(FisTamSX3( 'SD1','D1_OPER')[1])),;//279 - Tipo de operação.
	0,; // 280 - Valor IPI Origem para Orgãos Publicos
	0,; // 281 - Valor Base ICMS Efetivo
	0,; // 282 - ALQ ICMS Efetivo
	0,; // 283 - Valor ICMS Efetivo
	0,; // 284 - Percentual da Redução do ICMS Efetivo
	0,; // 285 - Valor Base ICMS Retido Anteriormente na saída
	0,; // 286 - Valor Base ICMS Retido Anteriormente na saída
	0,; // 287 - Valor do ICMS Retido Anteriormente na saída
	0,; // 288 - Valor do ICMS Próprio do Substituto
	Array(NMAXRC),;// 289 - Referências de Ressarciento
	0,; //290 Base de cálculo do FECP ST recolhido anteriormente através da média ponderada das últimas aquicoes
	0,; //291 Percentual do FECP ST recolhido anteriormente através da média ponderada das últimas aquicoes
	0,; //292 Valor FECP ST recolhido anteriormente através da média ponderada das últimas aquicoes
	0,; //293 Valor do ICMS Desonerado Próprio
	0,; //294 Valor do ICMS Desonerado ST
	0,; //295 Valor Total considerado para calcular ICMS Efetivo
	0,;//296 Quantidade de Itens Devolvidos
	0,; //297 Desconto Fiscal de impostos
	0,;//298 Aliquota da antecipacao de ICMS - Proprio
	Array(NMAXCDDECL),;// 299 - Referências das informações de para enquadramento codigo valor declaratorio e codigo de ajuste
	0,;// 300 - Cálcula o percentual do valor da operação com relação ao valor de pauta do produto, cadastrado no campo B1_VLR_ICM
	0,;	//301 - Goods Value in main currency
	Array(NMAXIV),;//302 - Tax calculation base in main currency
	Array(NMAXIV),;//303 - Value of Tax in main currency
	0,;//304 - Grand Total in main currency
	STOD(""),; //305 - Data de Emissão da NF Origem
	0,; //306 - //Arred CRD PRESUMIDO ICM
	"",; // 307 - ITEM DO XML
	0,;  //308 - Arred Cred Presumido Transporte
	cITCODMUN,; //309-IT_CODMUN
	cITTPACTIV,; //310-IT_TPACTIV
	""}) //311-IT_NORECAL (para evitar que o item seja recalculado configurador, mas que o CFGTRIB apenas absorva os valores)


	If Len(aNfitem) > 1
		aNfitem[Len(aNfitem)][IT_ITEM] := Soma1(aNfitem[Len(aNfitem)-1][IT_ITEM])
	EndIf

	If !Empty( aNfItem[nItem][IT_PRODUTO] ) .And. (!( aNfItem[nItem][IT_PRODUTO] == aNfItem[nItem][IT_PRD][SB_COD] ))
		MaFisIniCpo(nItem)
	ElseIf Empty( aNfItem[nItem][IT_PRODUTO] )
		MaFisIniCpo(nItem,.F.)
	EndIf

	If !Empty( aNfItem[nItem][IT_TES] ) .And. ( aNfItem[nItem][IT_TES] <> aNfItem[nItem][IT_TS][TS_CODIGO] )
		MaNewFisTES(aNfItem[nItem][IT_TES],,nItem)
	ElseIf Empty( aNfItem[nItem][IT_TES] )
		MaNewFisTES(,,nItem,.F.)
	EndIf

	// Inicializa arrays de impostos variaveis
	aNfItem[nItem][IT_BASEIMP]:=Afill(aNfItem[nItem][IT_BASEIMP],0)
	aNfItem[nItem][IT_ALIQIMP]:=Afill(aNfItem[nItem][IT_ALIQIMP],0)
	aNfItem[nItem][IT_VALIMP] :=Afill(aNfItem[nItem][IT_VALIMP],0)
	aNfItem[nItem][IT_DESCIV] :=Afill(aNfItem[nItem][IT_DESCIV],{"","",""})
	If cPaisLoc == "RUS"
		aNfItem[nItem][IT_BASEIMP_C1]	:= Afill(aNfItem[nItem][IT_BASEIMP_C1],0)
		aNfItem[nItem][IT_VALIMP_C1] := Afill(aNfItem[nItem][IT_VALIMP_C1],0)
	EndIf
	aadd(aItemDec,{Nil,Nil})
	aItemDec[Len(aItemDec)][1] := Array(Len(aItemRef))
	aItemDec[Len(aItemDec)][2] := Array(Len(aItemRef))
	aFill(aItemDec[Len(aItemDec)][1],0)
	aFill(aItemDec[Len(aItemDec)][2],0)

	// Carga do array aRefAlt - utilizado p/ controle das referências
	// alteradas por MaFisAlt e MaFisLoad para que as alterações não
	// sejam desfeitas pelos recálculos.
	loadRefAlt(nItem)

	//----------------------------------------------------------------------------
	//Faz carga dos tributos genéricos se o ID do tributo genérico for preenchido.
	//----------------------------------------------------------------------------
	If !Empty(aNfItem[nItem][IT_ID_LOAD_TRBGEN]) .AND. fisExtTab('12.1.2310', .T., 'F2D')
		xFisLoadTG(@aNfItem, nItem,, Len(aTGITRef) ,aNFCab, aPos, aDic,aHmFor, lReproc)
		//Telemetrica Confxfis
		FisXTelem("CONFXFIS", nItem)
	EndIF
Else
	If lEstorno
		MaFisSomaIt(nItem,.F.)
	Endif
EndIf

Return .T.

/*
MaFisAdd Edson Maricate 09.12.99
Inicializa o Calculo das operacoes Fiscais por item
*/
Function MaFisAdd(cProduto,;   	// 1-Codigo do Produto ( Obrigatorio )
cTes,;	   	// 2-Codigo do TES ( Opcional )
nQtd,;	   	// 3-Quantidade ( Obrigatorio )
nPrcUnit,;  // 4 -Preco Unitario ( Obrigatorio )
nDesconto,; // 5 -Valor do Desconto ( Opcional )
cNFOri,;	// 6 -Numero da NF Original ( Devolucao/Benef )
cSEROri,;	// 7 -Serie da NF Original ( Devolucao/Benef )
nRecOri,;	// 8 -RecNo da NF Original no arq SD1/SD2
nFrete,;	// 9 -Valor do Frete do Item ( Opcional )
nDespesa,;	// 10-Valor da Despesa do item ( Opcional )
nSeguro,;	// 11-Valor do Seguro do item ( Opcional )
nFretAut,;	// 12-Valor do Frete Autonomo ( Opcional )
nValMerc,;	// 13-Valor da Mercadoria ( Obrigatorio )
nValEmb,;	// 14-Valor da Embalagem ( Opiconal )
nRecSB1,;	// 15-RecNo do SB1
nRecSF4,;	// 16-RecNo do SF4
cNItem,;    // 17-Item
nDesNTrb,;  // 18-Despesas nao tributadas - Portugal
nTara,;		// 19-Tara - Portugal
cCfo,; 		// 20-CFO
aNfOri,;    // 21-Array para o calculo do IVA Ajustado (opcional)
cConcept,;	// 22-Concepto
nBaseVeic,;	// 23-Base Veiculo
nPLote,; 	// 24-Lote Produto
nPSubLot,;	// 25-Sub-Lote Produto
nAbatIss,;	// 26-Valor do Abatimento ISS
cCodISS,; 	// 27-Codigo ISS
cClasFis,;	// 28-Classificação Fiscal
cProdFis,;	// 29-Cod. do Produto Fiscal
nRecPrdF,;	// 30-Recno do Produto Fiscal
cNcmFiscal,;// 31-NCM do produto Fiscal
cIdTribGen,;// 32-Id dos tributos genéricos para visualização/exclusão
cTpOper)    // 33-Tipo de Operação (opcional)

Local aArea	:= GetArea()
Local nItem := 0
DEFAULT nRecSB1  := 0
DEFAULT nRecSF4  := 0
DEFAULT cNItem	 := ""
DEFAULT cCfo	 := ""
DEFAULT nDesNTrb := 0
DEFAULT nTara	 := 0
DEFAULT aNfOri	 := {}
DEFAULT cConcept := Space(5)
DEFAULT nBaseVeic:= 0
DEFAULT nAbatIss := 0
DEFAULT cCodISS	 := ""
DEFAULT cClasFis := ""
DEFAULT cProdFis := Space(Len(cProduto))
DEFAULT nRecPrdF := 0
DEFAULT cNcmFiscal := ""
Default cIdTribGen	:= ""
DEFAULT cTpOper  := IIf(fisExtCmp('12.1.2310', .T.,'SD1','D1_OPER'), Space(FisTamSX3( 'SD1','D1_OPER')[1]), "  ")

If cPaisLoc == "BRA"
	MaFisTes(@cTes,nRecSF4)
Endif

aadd(aNfItem,{"",; //1 - Grupo de Tributacao
{},;//2 - Array contendo as excessoes Fiscais
0,;//3 - Aliquota de ICMS
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},;//4-Valores de ICMS
0,;//5 - Aliquota de IPI
{0,0,0,0,0},;//6 - Valores de IPI
cNFOri,;//7 - Numero da NF Original
cSEROri,;//8 - Serie da NF Original
nRecOri,;//9 - RecNo da NF original
nDesconto,;//10 - Valor do desconto do item
nFrete,;//11 - Valor do Frete
nDespesa,;//12 - Valor da despesa
nSeguro,;//13 - Valor do seguro
nFretAut,;//14 - Valor do frete autonomo
nValMerc,;//15 - Valor da Mercadoria
cProduto,;//16 - Codigo do produto
cTes,;//17 - Codigo da TES
0,;//18 - Valor Total do item
cCfo,;//19 - Codigo FIscal de Operacao
0,;//20 - Valor do Funrural
0,;//21 - Aliquota para calculo do FunRural
.F.,;//22 - Flag de controle para itens deletados
MaFisRetLF(),;//23 - Array Contendo o demonstrativo fiscal
{0,0,0,cCodISS,"","","",0,0,0,.F.},; //24 - Array contendo os valores de ISS
{0,0,0,0,.F.,0,0},;//25 - Array contendo os valores de IR
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},;//26 - Array contendo os valores de INSS
0,;//27 - Valor da Embalagem
Array(NMAXIV),;//28
Array(NMAXIV),;//29
Array(NMAXIV),;//30
0,;//31
0,;//32
Array(NMAXIV),;//33
nQtd,;//34
nPrcUnit,;//35
0,;//36
0,;//37
0,;//38
0,;//39
0,;//40
0,;//41
0,;//42
0,;//43
0,;//44
0,;//45
0,;//46
0,;//47
0,;//48
nRecSB1,;//49
nRecSF4,;//50
0,;//51
aNfCab[NF_TIPONF],;//52
"",;//53
0,;//54
0,;//55
0,;//56
0,;//57
0,;//58
0,;//59
0,;//60
nAbatIss,;//61
0,;//62
0,;//63
0,;//64
0,;//65
0,;//66 - Base AFRMM - Item
0,;//67 - Aliquota AFRMM - Item
0,;//68 - Valor AFRMM - Item
0,;//69
0,;//70
0,;//71
"",;//72
Iif(aNfCab[NF_OPERNF]=="S", StrZero(1,FisTamSX3('SD2','D2_ITEM')[1]), StrZero(1,FisTamSX3('SD1','D1_ITEM')[1])),;//73
{0,0,0},;//74 - Array dos valores do SEST
0,;//75 - Base de calculo do PIS Subst. Tributaria
0,;//76 - Aliquota do PIS Subst. Tributaria
0,;//77 - Valor do PIS Subst. Tributaria
0,;//78 - Bae da COFINS Subst. Tributaria
0,;//79 - Aliquota da COFINS Subst. Tributaria
0,;//80 - Valor da COFINS Subst. Tributaria
0,;//81 - Valor do Frete de Pauta
0,;//82 - Base FETHAB
0,;//83 - Aliquota FETHAB
0,;//84 - Valor FETHAB
0,;//85 - Abatimento do Valor do INSS em Valor - Subcontratada
{"","","","","","",0,0,0,0,0,0,0,"",0},;
0,;//87 - Abatimento do Valor do ISS referente ao material utilizado})
"",;//88 - Indica se a operacao, mesmo sem calculo de ICMS ST, faz parte do Regime Especial de Substituicao Tributaria
0,;//89 - Percentual de UFERMS para o calculo do Fundersul - Mato Grosso do Sul
0,;//90 - Valor da UFERMS para o calculo do Fundersul - Mato Grosso do Sul
0,;//91 - Valor do Fundersul - Mato Grosso do Sul
0,;//92 - Valor do Estorno de Credito
"",;//93 - Codigo Autorizacao CODIF - Combustiveis
0,;//94 - Base do ICMS de transporte Substituicao Tributaria
0,;//95 - Aliquota do ICMS de transporte Substituicao Tributaria
0,;//96 - Valor do ICMS de transporte Substituicao Tributaria
0,;//97 - Valor do credito presumido simples nacional - SC
0,;//98 - Valor Antecipacao ICMS
nDesNTrb,;//99 - Valor das despesas nao tributadas - Portugal
nTara,;//100 - Valor da Tara - Portugal
aNFCab[NF_PROVENT],;//101 - Provincia de entrega
0,;//102 - Valor do FECP
0,;//103 - Valor do FECP ST
0,;//104 - Aliquota FECP
0,;//105 - Valor Crédito Presumido SC
0,;//106 - Valor do desconto total proporcionalizado
{{"",0,0,0}},;//107 - Array para o calculo do IVA Ajustado
{0,0},;//108 - Array com os valores do Imposto de Importação
0,;//109 - Valor da Pauta do PIS
0,;//110 - Valor da Pauta do Cofins
0,;//111 -  Valor da Aliquota Dif para simples
cClasFis,;//112 - IT_CLASFIS
0,;//113 - Valor do imposto ISC (Localizado Peru) por unidade "PER"
0,;//114 - IT_CRPREPE Credito Presumido - Art. 6 Decreto  n28.247
0,;//115 - Valor Crédito Presumido MG
0,;//116 - Valor de desconto de dependente do fornecedor
0,;//117 - Credito Presumido Ceara
0,;//118 - Base FABOV - Mato Grosso
0,;//119 - Aliq FABOV - Mato Grosso
0,;//120 - Valor FABOV - Mato Grosso
0,;//121 - Base FACS - Mato Grosso
0,;//122 - Aliq FACS - Mato Grosso
0,;//123 - Valor FACS - Mato Grosso
0,;//124 - Valor FUMACOP
0,;//125 - Aliq FUMACOP
cConcept,;//126 - Concepto Retencao(Equador)
"",;//127 moticms
0,;//128 - Aliquota Senar
0,;//129 - Valor Senar
0,;//130 - Base Senar
0,;//131 - Credito Outorgado SP
0,;//132- Abatimento do valor do INSS Subcontratada
0,;//133- Base de calculo ICMS sem reducao - Decreto 43.080/02-MG
0,;//134- Valor do ICMS sem reducao - Decreto 43.080/02-MG
0,;//135- Percentual de Reducao Decreto 43.080/02-MG
0,;//136 - Base do FUNRURAL
nBaseVeic,;//137 - Base Veiculo
{0,0,0},;//138 - Valor da Base(01)/Valor(02)/Aliquota(03) do Regime de Operacoes Simplificadas - MT
0,;//139 - Valor da Base do FUMACOP
0,;//140 - Valor do Créd Presumido do Paraná
{"","","",CToD("")},;//141 - Array Dados Natureza da opercao
{0,0,0},;//142 - Array da TPDP.
0,;//143 - Valor incentivo prod.leite RICMS/MG
0,;//144 - Percentual incentivo prod.leite RICMS/MG
{0,0,0},;//145 - Array com valores do INSS Condições Especiais
0,;//146 - Valor do FECOP-RN
0,;//147 - Valor do FECOP ST-RN
0,;//148 - Aliquota FECOP-RN
0,;//149 - Valor do FUE - localização Austrália
"",;//150 - Método utilizado cálculo FUE - localização Austrália
"2",;//151 - NF Emitida sob norma específica
0,;//152 - Coeficiente de PIS por Substituição Tributária para fabricantes de cigarros
0,;//153 - Coeficiente de COFINS por Substituição Tributária para fabricantes de cigarros
0,;//154 - Credito Presumido
0,;//155 - Preco Unitario utilizado para calculo da Substituição tributária para fabrixante de Cigarros
"2",;//156 - Recolhimento Antecipado - Para atender necessidades do SPEDFISCAL de MG
0,;//157 - Valor do FECP-MG
0,;//158 - Valor do FECP ST-MG
0,;//159 - Aliquota FECP-MG
0,;//160 - Valor do Reintegra
0,;//161 - Base de Calculo do Reintegra
0,;//162 - Valor da COFINS de Importacao Majorada
0,;//163 - Aliquota da COFINS de Importacao Majorada
0,;//164 - Valor do FECP-MT
0,;//165 - Valor do FECP ST-MT
0,;//166 - Aliquota FECP-MT
{nPLote,nPSubLot},;//167 - 1- Lote Produto / 2- SubLoteProduto
"2",;//168 - DIAT - SC
"2",;//169 - Campo de diferimento na tabela SB1 - Conteudo do parametro MV_ALQDFB1
0,;//170 - Indica o % calculo do ICMS-ST, se utiliza pauta ou margem.
"",;//171 - MaSBCampo("RSATIVO")
"",;//172 - MaSBCampo("POSIPI")
"",;//173 - MaSBCampo("UM")
"",;//174 - MaSBCampo("SEGUM")
0,;//175 - MaSBCampo("AFABOV")
0,;//176 - MaSBCampo("AFACS")
0,;//177 - MaSBCampo("AFETHAB")
"",;//178 - MaSBCampo("TFETHAB")
{},;//179 - Array com a exceção fiscal do cliente do faturamento
0,;//180 - Adiantamento
"",;//181 - Codigo da Natureza da Operacao
Array(NMAXSB) ,;//182 - Dados do cadastro de produtos SB1 ou SBi ou SBZ
{"","",aNfCab[NF_IDSA1],aNfCab[NF_IDSA2],"","","",aNfCab[NF_IDSED],"","",""},; // 183 - Array ID's Historicos
0,;//184 - DescTot - Desconto dado no Total, reteado por item - Uso do novo PDV - LOJA
0,;//185 - AcresciTot - Acrescimo dado no Total, reteado por item - Uso do novo PDV - LOJA
0,;//186 - Valor da PIS de Importacao Majorada
0,;//187 - Aliquota da PIS de Importacao Majorada
cProdFis,;//188 - Identificação do produto Fiscal  - Demetrio
nRecPrdF,;//189 - Recno do Produto Fiscal - Demetrio
cNcmFiscal,;//190 - NCM Fiscal
Array(NMAXUFP),;// 191 - Array com conteudo da tabela CFC
0,;//192 - Valor Cide
"",;//193 - Convênio 139/06
0,;//194 - VAlor do FETHAB retido pelo cliente
0,;//195 - Aliquota do FECP ST
0,;//196 - Aliquota do FECP Outros (Antecipacao/Diferencial de aliquotas)
0,;//197 - NF_BASNDE
0,;//198 - NF_ICMNDES
0,;//199 - Adiantamento
0,;//200
0,;//201 - Identifica o preço para Consumidor Final
0,;//202 - Base de cálculo cide
0,;//203 - Aliquota Cide
0,;//204 - Base do ISS CEPOM
0,;//205 - Valor do ISS CEPOM
0,;//206 - Aliquota do ISS CEPOM
0,;//207 - Valor IPI a ser inserido na base do ICM, venda futura CF
0,;//208 - Base Fumipeq
0,;//209 - Valor Fumipeq
0,;//210 - Valor Fumipeq
0,;//211 - Base FAMAD
0,;//212 - Valor FAMAD
0,;//213 - Alíquota FAMAD
Array(MAX_TS),;//214 - Array com os dados da TES.
.F.,;//215 - Flag p/ Indicar calculo com pauta de PIS
.F.,;//216 - Flag p/ indicar calculo com pauta de COFINS
"",;//217 - Enquadramento IPI
"",;//218 - CEST
0,;//219 - Base do CPRB
0,;//220 - Valor do CPRB
0,;//221 - Aliquota do CPRB
0,;//222 - Código atividade CPRB
0,;//223 - Difal
0,;//224 - Perc Difal destino
0,;//225 - Perc Difal origem
0,;//226 - Valor FECP Difal
0,;//227 - Fator de Redução Desc.ICMS
0,;//228 - Valor de Redução Desc.ICMS
0,;//229 - Base FUNDESA
0,;//230 - Aliquota FUNDESA
0,;//231 - Valor FUNDESA
0,;//232 - Base IMA-MT
0,;//233 - Aliquota IMA-MT
0,;//234 - Valor IMA-MT
0,;//235 - Aliquota IMA-MT (SB1)
0,;//236 - Valor IMA-MT retido clie/for
0,;//237 - Base FASE-MT
0,;//238 - Aliquota FASE-MT
0,;//239 - Valor FASE-MT
0,;//240 - Aliquota FASE-MT (SB1)
0,;//241 - Valor FASE-MT retido clie/for
0,;	//242 - Preço Médio Ponderado, para ser utilizado como base de ICMS ST
aNfCab[NF_INDICE],; // 243 - Indice tabela F0R
0,;//244 - Valor do Pedágio
0,;//245 - Valor Solidario XML
0,;//246 - Pauta CIDE
"   ",;//247 - CSOSN
0,;//248 - Base do INSS Patronal
0,;//249 - Percentual do INSS Patronal
0,;//250 - Valor do INSS Patronal
IIf(fisExtCmp('12.1.2310', .T.,'SB1','B1_TRIBMUN'), Space(FisTamSX3( 'SB1','B1_TRIBMUN')[1]), ""),; //251 - Código de Trib. Municipal
0,;//252 - Valor do AFRMM na Importação
0,;//253 - Valor do Credito Presumido Paraná
0,;//254 - Valor do desconto - Decreto 43.080/2002 RICMS-MG
0,;//255 - Valor do ICMS da Operação - Sem diferimento (Valor como se não tivesse o diferimento)
0,;//256 - Base PROTEGE-GO
0,;//257 - Aliquota PROTEGE-GO
0,;//258 - Valor PROTEGE-GO
0,;//259 - Base FEEF-RJ
0,;//260 - Aliquota FEEF-RJ
0,;//261 - Valor FEEF-RJ
"",;//262 - Código de Atividade
"",;//263 - Coluna onde será escriturada a parcela diferida, na coluna Outros ou Isentod
0,;//264 - Base do FCP recolhido anteriormente.
0,;//265 - Aliquota do FCP recolhido anteriormente.
0,;//266 - Valor do FCP recolhido anteriormente.
0,;//267 - Aliquota ICMS ST Recolh. Ant.
0,;//268 - Base do FCP - Proprio.
0,;//269 - Base do FCP - ST.
0,;//270 - Base do FCP - Complementar.
0,;//271 - Indice auxiliar do FCP.
0,;//272 - Crédito Prodepe
"",;//273- Conta Contábil de Receita
0,;//274-Valor do ICMS antes de ser submetido ao arredondamento
{},;//275-Código declaratorio
{},; //276-Tributos Genéricos
FWUUIDV4(.T.),;//277-Id do tributo genérico, gerado automaticamente pela MATXFIS nas inclusões de notas
cIdTribGen,; //278-Id do tributo genérico para visualização e exclusão
cTpOper,; //279 - Tipo de operação
0,; // 280 - Valor IPI Origem para Orgãos Publicos
0,; // 281 - Valor Base ICMS Efetivo
0,; // 282 - ALQ ICMS Efetivo
0,; // 283 - Valor ICMS Efetivo
0,; // 284 - Percentual da Redução do ICMS Efetivo
0,; // 285 - Valor Base ICMS Retido Anteriormente na saída
0,; // 286 - Valor Base ICMS Retido Anteriormente na saída
0,; // 287 - Valor do ICMS Retido Anteriormente na saída
0,; // 288 - Valor do ICMS Próprio do Substituto
Array(NMAXRC),;// 289 - Referências de Ressarciento
0,; //290 Base de cálculo do FECP ST recolhido anteriormente através da média ponderada das últimas aquicoes
0,; //291 Percentual do FECP ST recolhido anteriormente através da média ponderada das últimas aquicoes
0,; //292 Valor FECP ST recolhido anteriormente através da média ponderada das últimas aquicoes
0,; //293 Valor do ICMS Desonerado Próprio
0,; //294 Valor do ICMS Desonerado ST
0,; //295 Valor Total considerado para calcular ICMS Efetivo
0,; //296 Quantidade de Itens Devolvidos
0,;  //297 Dseconto Fiscal de impostos
0,;//298 Aliquota da antecipacao de ICMS - Proprio
Array(NMAXCDDECL),;// 299 - Referências das informações de para enquadramento codigo valor declaratorio e codigo de ajuste
0,; // 300 - Cálcula o percentual do valor da operação com relação ao valor de pauta do produto, cadastrado no campo B1_VLR_ICM
0,;	//301 - Goods Value in main currency
Array(NMAXIV),;//302 - Tax calculation base in main currency
Array(NMAXIV),;//303 - Value of Tax in main currency
0,;//304 - Grand Total in main currency
STOD(""),; //305 - Data de Emissão da NF Origem
0,;//306 - ARRED CRD PRESUMIDO ICM
"",; // 307 - ITEM DO XML
0,;  //308 - Arred Cred Presumido Transporte
cITCODMUN,; //309-IT_CODMUN
cITTPACTIV,; //310-IT_TPACTIV
""}) //311-IT_NORECAL (para evitar que o item seja recalculado configurador, mas que o CFGTRIB apenas absorva os valores) 

If Empty(cNItem)
	If Len(aNfitem) > 1
		aNfitem[Len(aNfitem)][IT_ITEM] := Soma1(aNfitem[Len(aNfitem)-1][IT_ITEM])
	EndIf
Else
	aNfitem[Len(aNfitem)][IT_ITEM] := cNItem
EndIf

aadd(aItemDec,{Nil,Nil})
aItemDec[Len(aItemDec)][1] := Array(Len(aItemRef))
aItemDec[Len(aItemDec)][2] := Array(Len(aItemRef))
aFill(aItemDec[Len(aItemDec)][1],0)
aFill(aItemDec[Len(aItemDec)][2],0)

nItem := Len(aNfItem)

If !Empty( aNfItem[nItem][IT_PRODUTO] ) .And. (!( aNfItem[nItem][IT_PRODUTO] == aNfItem[nItem][IT_PRD][SB_COD] ))
	MaFisIniCpo(nItem)
ElseIf Empty( aNfItem[nItem][IT_PRODUTO] )
	MaFisIniCpo( nItem , .F. )
EndIf

If !Empty( aNfItem[nItem][IT_TES] ) .And.  (aNfItem[nItem][IT_TES] <> aNfItem[nItem][IT_TS][TS_CODIGO])
	MaNewFisTES(@cTes, nRecSF4, nItem)
ElseIf Empty( aNfItem[nItem][IT_TES] )
	MaNewFisTES(@cTes, nRecSF4, nItem, .F.)
EndIf

// Inicializa arrays de impostos variaveis
aNfItem[nItem][IT_BASEIMP]:=Afill(aNfItem[nItem][IT_BASEIMP],0)
aNfItem[nItem][IT_ALIQIMP]:=Afill(aNfItem[nItem][IT_ALIQIMP],0)
aNfItem[nItem][IT_VALIMP] :=Afill(aNfItem[nItem][IT_VALIMP],0)
aNfItem[nItem][IT_DESCIV] :=Afill(aNfItem[nItem][IT_DESCIV],{"","",""})
If cPaisLoc == "RUS"
	aNfItem[nItem][IT_BASEIMP_C1]	:=	Afill(aNfItem[nItem][IT_BASEIMP_C1],0)
	aNfItem[nItem][IT_VALIMP_C1]	:=	Afill(aNfItem[nItem][IT_VALIMP_C1],0)
EndIf
// Carga do array aRefAlt - utilizado p/ controle das referências
// alteradas por MaFisAlt e MaFisLoad para que as alterações não
// sejam desfeitas pelos recálculos.
loadRefAlt(nItem)

MaFisRecal("",nItem)
//----------------------------------------------------------------------------
//Faz carga dos tributos genéricos se o ID do tributo genérico for preenchido.
//----------------------------------------------------------------------------
If !Empty(aNfItem[nItem][IT_ID_LOAD_TRBGEN]) .AND. fisExtTab('12.1.2310', .T., 'F2D')
	xFisLoadTG(@aNfItem, nItem,, Len(aTGITRef) ,aNFCab, aPos, aDic,aHmFor, lReproc)
EndIF
MaIt2Cab()

RestArea(aArea)

Return(nItem)

/*MaFisLoad Edson Maricate 09.12.99
Carrega os valores de impostos de bases e item.
*/
Function MaFisLoad(cCampo,nValor,nItem,aTrbGen)

Local cPosCpo  := MaFisScan(cCampo)
Local nPosGen  := 0
Local aTribLegA	:= {}
Local aTribLegD	:= {}
DEFAULT aTrbGen := {"",""}

If nValor <> Nil
	// Altera o valor do campo no Array aNfCab ou aNfItem
	If Substr(cCampo,1,2) == "IT"

		//Configurador com Legado 
		//Converte Referencia alterada legado em Configurador 
		If len(aNFItem[nItem][IT_TRIBGEN]) > 0  .and. (Len(aTrbGen) >= 2 .And. (Empty(aTrbGen[TG_SIGLA]) .Or. Empty(aTrbGen[TG_REFERENCIA])))
			aTribLegA	:= Iif(aNfCab[NF_CHKTRIBLEG] , ListTLegTG(aNFItem, nItem),{})
			If Len(aTribLegA) > 0
				ccampo := AltTribLeg(aNfItem,nItem,ccampo,aTrbGen)
			Endif
		Endif

		//Tratamento para o tributo genérico
		If AllTrim(cCampo) == "IT_TRIBGEN" .And. Len(aTrbGen) >= 2 .And. !Empty(aTrbGen[TG_SIGLA]) .And. !Empty(aTrbGen[TG_REFERENCIA])
			cPosCpo := MaFisScan(aTrbGen[TG_REFERENCIA])
			If (nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| Alltrim(x[TG_IT_SIGLA]) == Alltrim(aTrbGen[TG_SIGLA])})) > 0
				//Se o tributo genérico existir e for referência válida,  então atribuimos o valor a ele.
				aNfItem[nItem][IT_TRIBGEN][nPosGen][cPosCpo] := nValor
				
				//Atualiza Referencia Legado
				IF Len(aTribLegA) > 0
					//Obtem a lista dos tributos genéricos com ID de tributo legado após de refazer os cálculos
					aTribLegD	:= Iif(aNfCab[NF_CHKTRIBLEG] , ListTLegTG(aNFItem, nItem),{})

					//Obtem a lista de tributos legados que precisam ser atualizados após o cálculo dos tributos genéricos
					aTrbLegCalc	:= Iif(aNfCab[NF_CHKTRIBLEG] , ChkCalcTLeg(aTribLegA, aTribLegD),{})

					//Refaz aqui o cálculo dos tributos legados se necessário
					If Len(aTrbLegCalc) > 0
						AtuTrbLeg(aTrbLegCalc, nItem, .T.)
					EndIf
				Endif
			EndIf
		// Tratamento para os itens.
		ElseIf ValType(cPosCpo) == "A"
			aNfItem[nItem][cPosCpo[1]][cPosCpo[2]] := nValor
			aRefAlt[nItem][cPosCpo[1]][cPosCpo[2]] := .T.
		Else
			aNfItem[nItem][Val(cPosCpo)] := nValor
			aRefAlt[nItem][Val(cPosCpo)] := .T.
		EndIf
		If AllTrim(cCampo) == "IT_PRODUTO" .And. !Empty( aNfItem[nItem][IT_PRODUTO] ) .And. (!( aNfItem[nItem][IT_PRODUTO] == aNfItem[nItem][IT_PRD][SB_COD] ))
			MaFisIniCpo(nItem)
		EndIf
		If AllTrim(cCampo) == "IT_TES" .And. !Empty( aNfItem[nItem][IT_TES] ) .And. ( aNfItem[nItem][IT_TES] <> aNfItem[nItem][IT_TS][TS_CODIGO] )
			MaNewFisTES(aNfItem[nItem][IT_TES],,nItem)
		EndIf
	ElseIf Substr(cCampo,1,2) == "LF"
		// Tratamento para os itens do livro.
		If ValType(cPosCpo) == "A"
			aNfItem[nItem][IT_LIVRO][cPosCpo[1]][cPosCpo[2]] := nValor
		ElseIf ValType(cPosCpo) == "C"
			aNfItem[nItem][IT_LIVRO][Val(cPosCpo)] := nValor
		ElseIf ValType(cPosCpo) == "N"
			aNfItem[nItem][IT_LIVRO][cPosCpo] := nValor
		EndIf
	Else
		// Tratamento para o cabecalho.
		If AllTrim(cCampo) == "NF_TRIBGEN" .And. Len(aTrbGen) >= 2  .And. !Empty(aTrbGen[TG_SIGLA]) .And. !Empty(aTrbGen[TG_REFERENCIA])
			cPosCpo := MaFisScan(aTrbGen[TG_REFERENCIA])
			If (nPosGen := aScan(aNFCab[NF_TRIBGEN], {|x| AllTrim(x[TG_NF_SIGLA]) == AllTrim(aTrbGen[TG_SIGLA])})) > 0
				aNfcab[NF_TRIBGEN][nPosGen][cPosCpo] := nValor
			EndIf
		ElseIf ValType(cPosCpo) == "A"
			aNfCab[cPosCpo[1]][cPosCpo[2]] := nValor
		Else
			aNfCab[Val(cPosCpo)] := nValor
		EndIf
	EndIf
EndIf


Return .T.

/*MaFisEndLoad Edson Maricate 09.12.99
Finaliza a carga dos itens Fiscais
Parametros
ExpN1 : Item
ExpN2 : Tipo de atualizacao do Item :
1-(default) Executa o recalculo de todos os itens para efetuar a atualizacao do cabecalho
2-Executa a soma do item para atualizacao do cabecalho
3-Nao executa a atualizacao do cabecalho.
*/
Function MaFisEndLoad(nItem,nTipo,lExec)

Local aArea   := GetArea()
Local nPosTESM := 0
DEFAULT nTipo := 1
DEFAULT lExec := .T.

If (cPaisLoc $ "ARG")
	If Type("aTesMXF") <> "U"
		nPosTESM := Ascan(aTesMXF,{|X| AllTrim(x[2][1]) == aNfItem[nItem][IT_TES]})
	EndIf
	If nPosTESM > 0
		aTes := aClone(aTesMXF[nPosTESM][2])
	Else
		MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
		If Type("aTesMXF") <> "U" .and. nPosTESM == 0
			AADD(aTesMXF,{nItem,aClone(aTes)})
		EndIf
	EndIf
Else
	MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
EndIf
MaFisNameIV(,nItem)
MaRecM120(nItem)
MaFisVTot(nItem)
If lExec
	MaItArred(nItem)
EndIf
MaFisLF(nItem)

Do Case
	Case nTipo == 1
		If lExec
			MaIt2cab()
		EndIf
	Case nTipo == 2
		MaFisSomaIt(nItem)
EndCase

If bFisRefresh <> Nil
	Eval(bFisRefresh)
EndIf

If bLivroRefresh <> Nil
	Eval(bLivroRefresh)
EndIf

RestArea(aArea)

Return .T.

/*/{Protheus.doc} MaRecM120
Tratamento para vizualição ou alteração no MATA120 quando há tratamento de desconto utilizando o campo F4_AGREGA=D
@author Gabriel Venditti Barreira
@since 15/10/2020
/*/
Static Function MaRecM120(nItem)

DEFAULT nItem = 1

If aNFItem[nItem][IT_TS][TS_AGREG]$"DR" .And. (aNFItem[nItem][IT_TS][TS_AGRDRED]=="2" .Or. Empty(aNFItem[nItem][IT_TS][TS_AGRDRED])) .And. FunName() $ "MATA120|MATA121"
   MaFisRecal("IT_BASEICM",nItem)
EndIF

Return 

/*MaFisRet Edson Maricate 08.12.99
Retorna os impostos calculados pela MATXFIS.
Retorno   ExpN1: Valor do imposto.
*/
Function MaFisRet(nItem,cCampo,aTrbGen)

Local nRetorno
Local cPosCpo := MaFisScan(cCampo)
Local cSigTrGen := ""
Local cPosRefTG := ""
Local cRefTrGen := ""
Local nPosGen := ""

DEFAULT aTrbGen := {"",""}

Do Case
Case Substr(cCampo,1,2) == "IT"

	If cCampo == "IT_TRIBGEN"

		cSigTrGen := IIf(Len(aTrbGen) >= 1, aTrbGen[TG_SIGLA], "")
		cRefTrGen := IIf(Len(aTrbGen) >= 2, aTrbGen[TG_REFERENCIA], "")

		If !Empty(cRefTrGen)
			cPosRefTG := MaFisScan(cRefTrGen)
		EndIf

		// Se não passou o tributo e a ref. específica retorno a lista completa de tributos
		If Empty(cSigTrGen) .And. Empty(cRefTrGen)
			If nItem == Nil
				nRetorno := aClone(aNfItem[1][Val(cPosCpo)])
			Else
				nRetorno := aClone(aNfItem[nItem][Val(cPosCpo)])
			EndIf
		// Se passou somente a sigla do tributo retorno todas as informações daquele tributo
		ElseIf !Empty(cSigTrGen) .And. Empty(cRefTrGen)
			If (nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_SIGLA]) == AllTrim(cSigTrGen)})) > 0
				nRetorno := aClone(aNFItem[nItem][IT_TRIBGEN][nPosGen])
			Else
				nRetorno := {}
			EndIf
		// Se passou a sigla e a referência desejada retorno somente a referencia		
		ElseIf !Empty(cSigTrGen) .And. !Empty(cRefTrGen)
			
			If (nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_SIGLA]) == AllTrim(cSigTrGen)})) > 0								
			
				IF Substring(cRefTrGen,1,5) == "TG_LF"
					nRetorno := aNFItem[nItem][IT_TRIBGEN][nPosGen][TG_IT_LF][cPosRefTG]
				Else
					nRetorno := aNFItem[nItem][IT_TRIBGEN][nPosGen][cPosRefTG]
				EndIf
								
			Else
				nRetorno := 0
			EndIf
		EndIf

	Else
		If ValType(cPosCpo) == "A"
			nRetorno := aNfItem[nItem][cPosCpo[1]][cPosCpo[2]]
		Else
			If nItem == Nil
				nRetorno := aNfItem[1][Val(cPosCpo)]
			Else
				nRetorno := aNfItem[nItem][Val(cPosCpo)]
			EndIf
		EndIf
	EndIf
Case Substr(cCampo,1,2) == "LF"
	If nItem == Nil
		nRetorno := aNfItem[nItem][NF_LIVRO][cPosCpo]
	Else
		nRetorno := aNfItem[nItem][IT_LIVRO][cPosCpo]
	EndIf
OtherWise

	If cCampo == "NF_TRIBGEN"

		cSigTrGen := IIf(Len(aTrbGen) >= 1, aTrbGen[TG_SIGLA], "")
		cRefTrGen := IIf(Len(aTrbGen) >= 2, aTrbGen[TG_REFERENCIA], "")

		If !Empty(cRefTrGen)
			cPosRefTG := MaFisScan(cRefTrGen)
		EndIf

		// Se não passou o tributo e a ref. específica retorno a lista completa de tributos
		If Empty(cSigTrGen) .And. Empty(cRefTrGen)
			nRetorno := aClone(aNfCab[Val(cPosCpo)])
		// Se passou somente a sigla do tributo retorno todas as informações daquele tributo
		ElseIf !Empty(cSigTrGen) .And. Empty(cRefTrGen)
			If (nPosGen := aScan(aNFCab[NF_TRIBGEN], {|x| AllTrim(x[TG_NF_SIGLA]) == AllTrim(cSigTrGen)})) > 0
				nRetorno := aClone(aNFCab[NF_TRIBGEN][nPosGen])
			Else
				nRetorno := {}
			EndIf
		// Se passou a sigla e a referência desejada retorno somente a referencia
		ElseIf !Empty(cSigTrGen) .And. !Empty(cRefTrGen)
			If (nPosGen := aScan(aNFCab[NF_TRIBGEN], {|x| AllTrim(x[TG_NF_SIGLA]) == AllTrim(cSigTrGen)})) > 0
				nRetorno := aNFCab[NF_TRIBGEN][nPosGen][cPosRefTG]
			Else
				nRetorno := 0
			EndIf
		EndIf

	Else
		If ValType(cPosCpo) == "A"
			nRetorno := aNfCab[cPosCpo[1]][cPosCpo[2]]
		Else
			nRetorno := IIF(ValType(aNfCab)=="A",aNfCab[Val(cPosCpo)],0)
		EndIf
	EndIf

EndCase

Return nRetorno

/* MaColsToFi -Edson Maricate  -01.02.1999
Rotina carregamento da funcao fiscal com base no acols e aheader
ParametrosExpA1: Variavel com a estrutura do aHeader
          ExpA2: Variavel com a estrutura do aCols
          ExpN3: Item a ser carregado (OPC)
          ExpC4: Nome do (OPC)
          ExpL5: Indica se o recalculo dos impostos deve ser feito(OPC)
          ExpL6: Indica se o recalculo dos impostos deve ser feito(OPC)
          ExpL7: Indica se o recalculo vai considerar as linhs apagadas
		  ExpL9: Indica se a function MaFisEndLoad deve ser feita.
Descrio Esta rotina tem como objetivo inicializar a variavel aNFItem
          com base no aCols
*/
Function MaColsToFis(aHeader,aCols,nItem,cProg,lRecalc,lVisual,lDel,lSoItem,lEndLoad)

Local nItemIni := IIf( nItem == Nil, 1 , nItem )
Local nItemAte := IIf( nItem == Nil, Len(aCols) , nItem )
Local nX       := 0
Local nY       := 0
Local cValid   := ""
Local nTpCalc   := 0

DEFAULT lRecalc := .F.
DEFAULT lVisual	:= .F.
DEFAULT lDel    := .F.	//Indica que a linha deletada do acols nao sera considerada
DEFAULT lSoItem	:= .F.
DEFAULT lEndLoad:= .T.

If cPaisLoc == "ARG"
	nItemIni := IIf( nItemIni == 0 , 1 , nItemIni )
	nItemAte := IIf( nItemAte == 0 , Len(aCols), nItemAte )
EndIf

If nItemIni == nItemAte //Caso seja passado somente um item, o reprocessamento na MaFisLoad será feito somente no item passado.
	lSoItem := .T.
EndIf

If nItem == Nil
	MaFisClear()
EndIf

For nY := nItemIni To nItemAte
	MaFisIniLoad(nY,,.T.)
	For nX	:= 1 To Len(aHeader)
		cValid	 := AllTrim(UPPER(aHeader[nX][6]))
		cRefCols := MaFisGetRf(cValid)[1]
		If !Empty(cRefCols) .And. MaFisFound("IT",nY)
			MaFisLoad(cRefCols,aCols[nY][nX],nY)
		EndIf
	Next nX
	If lRecalc //  .and. Iif(cPaisLoc == "ARG", Type("lLocxAuto") <> "U" .and. lLocxAuto,.T.)
		MaFisRecal("IT_",nY)
		For nX	:= 1 To Len(aHeader)
			cValid	 := AllTrim(UPPER(aHeader[nX][6]))
			cRefCols := MaFisGetRf(cValid)[1]
			If !Empty(cRefCols) .And. MaFisFound("IT",nY)
				aCols[nY][nX]:= MaFisRet(nY,cRefCols)
			EndIf
		Next nX
	EndIf

	If lVisual
		nTpCalc := 3 //Nao executa recálculo ou atualizacao do cabecalho.
	Else
		If lSoItem
			nTpCalc := 2 //Executa apenas a soma do item para atualizacao do cabecalho
		Else
			nTpCalc := 1 //Executa o recalculo de todos os itens para efetuar a atualizacao do cabecalho
		EndIf
	EndIf

	If lEndLoad
		MaFisEndLoad(nY,nTpCalc)
	EndIf

	//Se a execucao da rotina considerar os itens deletados, executa a MAFISDEL
	If lDel .And. aCols[nY][Len(aHeader)+1]
		MaFisDel(nY,.T.)
	Endif
Next nY

Return .T.

/*MaFisToCols - Edson Maricate- 01.02.99
Atualiza os valores do aCols com os valores da Funcao Fiscal
*/
Function MaFisToCols(aHeader,aCols,nItem,cProg)

Local nItemIni := IIf( nItem == Nil , 1 , nItem )		
Local nItemAte := IIf( nItem == Nil, Len(aCols) ,nItem )
Local nX       := 0
Local nY       := 0
Local nPosTES  := GetPosTes(aHeader)

For nY := nItemIni to nItemAte
	For nX := 1 to Len(aHeader)
		cValid	:= AllTrim(UPPER(aHeader[nX][6]))
		cRefCols:= MaFisGetRF(cValid)[1]
		If !Empty(cRefCols) .And. MaFisFound("IT",nY)
			//Se a referencia for da Classificação fiscal, e a TES, a Classificação fiscal não será
			//Atribuida ao aCols da Nota
			If cRefCols == "IT_CF" .AND. nPosTES > 0 .AND. Empty(aCols[nY][nPosTES])
				If cPaisLoc <> "RUS" 
					aCols[nY][nX] := ""
				Else	
					//phantom error in criavar as a result TES Length is 0 which user can input in aCols. 
					//TES size is the same for all tables, so we use SD1 as reference
					aCols[nY][nX] := Space(FisTamSX3( 'SD1','D1_TES')[1])
				EndIf
			ElseIf cRefCols == "IT_VLSLXML"
				aCols[nY][nX]:= MaFisRet(nY,"IT_VALSOL")
			Else
				//Chama novamente o preenchimento do Valid e do cRefCols se o cRefCols estiver vazio
				If Empty(cRefCols)
					cValid	:= AllTrim(UPPER(aHeader[nX][6]))
					cRefCols:= MaFisGetRF(cValid)[1]
				EndIf
				aCols[nY][nX]:= MaFisRet(nY,cRefCols)
			Endif	
		EndIf
	Next nX
Next nY

Return .T.

/*MaFisSXRef - Eduardo Riera  -08.08.2001
Rotina de avalicao das referencias existentes para um determinada tabela no dicionario de dados
Esta rotina tem como objetivo verificar e retornar as referencias da funcao fiscal com base no dicionario de dados, para recuperar os valores da funcao fiscal
ParametrosExpC1: Tabela do Dicionario de dados
Retorno   ExpA1: Array com as referencias da funcao fiscal
*/
Function MaFisSXRef(cAlias)

Local aArea    := GetArea()
Local aRefer   := {}
Local nX       := 0
DEFAULT aRefSX3 := {}

If aScan(aRefSx3,{|x| x[1] == cAlias}) == 0 // Verifica se o alias solicitado esta no cache de memoria e adiciona as referencia ao cache de memoria
	MaFisRelImp("",{cAlias})
EndIf

For nX := 1 To Len(aRefSX3) // Obtem os dados do cache
	If aRefSX3[nX][1] == cAlias
		aadd(aRefer,{aRefSX3[nX][2],aRefSX3[nX][3]})
	EndIf
Next nX

RestArea(aArea)

Return(aRefer)

/*/
MaFisDel - Edson Maricate -21.12.1999
Marca/Desmarca o item especificado como deletado.
Parametros
ExpN1	: Numero do Item.
ExpL2 : .T. - Deleta o item , .F. - Ativa o item
/*/
Function MaFisDel(nItem,lDelete)

Local nI := 0
Local lCDAIndic	  := fisExtTab('12.1.2310', .T., 'CDA')

Local cPessoa	:= Iif(Len(Alltrim(aNfCab[NF_CNPJ]))< 14,"F","J")
Local lUsaTbPrg := (aNfItem[nItem][IT_BASEIRR] > 0  .or. fisGetParam('MV_FMP1171',.F.)) .And.; 
				   ((cPessoa == "F" .And. aNfCab[NF_IRPROG] <> "2") .Or. aNfCab[NF_IRPROG] == "1") .And.;
				   (aNfCab[NF_CLIFOR] == "F" .Or. (aNfCab[NF_CLIFOR] == "C" .And. aNfCab[NF_ALIQIR] == 0) .Or. aNfCab[NF_IRPROG] == "1")

If MaFisFound("IT",nItem)
	If lDelete
		If !aNfItem[nItem][IT_DELETED]
			aNfItem[nItem][IT_DELETED]	:= .T.
			// recalculo o IR quando o mesmo é proveniente da tabela progressiva
			If lUsaTbPrg
				// rodo o item deletado para tratar o mesmo antes
				MafisIr(nItem)
				MaFisLF(nItem)
				// se for dedução simplificada, preciso recalcular todos os itens da NF
				if fisFindFunc('RECALIR') .and. (aNFCab[NF_INIDEDS] .or. aNFCab[NF_ITDEDDIF] > 0)
					RecalIR(aNFCab, aNfItem, nItem)// substituo a chamada direta da MaFisIr
				endif
			endif
			If cPaisLoc <> "BRA"
				MaFisRecal(,nItem)
			EndIf
		Endif
	Else
		If aNfItem[nItem][IT_DELETED]
			aNfItem[nItem][IT_DELETED]	:= .F.
			// recalculo o IR quando o mesmo é proveniente da tabela progressiva
			If lUsaTbPrg
				setIRStatic("nItRetDel", nItem)
				MafisIr(nItem)
				MaFisLF(nItem)
			endif
			If cPaisLoc <> "BRA"
				MaFisRecal("IT_VALMERC",nItem)
			Endif
		EndIf
	EndIf

	If cPaisLoc == "BRA" .And. ( lLimInss .Or. fisGetParam('MV_ISSPRG','N') == "S" )
		For nI := 1 to Len(aNfItem)
			If lLimInss
				MaFisINSS(nI,"VLR")
			Endif
			If fisGetParam('MV_ISSPRG','N') == "S"
				MaFisISS(nI)
				MaFisLF(nI)
			EndIf
		Next nI
	EndIf	

	MaIt2Cab()

	If cPaisLoc == "BRA" .And. lCDAIndic .And. Type("oLancApICMS") == "O"
		a103AjuICM(nItem)
	EndIf
EndIf

Return

/*/MaFisRef- Edson Maricate - 10.12.99
Executa o calculo dos valores do item da NF.
Parametros
ExpC1 = Referencia
ExpC2 = Identificador do arquivo
ExpC1 = Valor da Referencia
/*/
Function MaFisRef(cReferencia,cProg,xValor)

Local aArea	   := GetArea()
Local lRet 	   := .T.
Local nX       := 0
Local nY       := 0
Local cValid   := ""
Local cRefCols := ""
local dTmp     := Ctod("")
Local nPosTES  := IIF(Type("aHeader")=="U",0,GetPosTes(aHeader))
Local nPosTESM  := 0
Local lActItems := Iif(cPaisLoc $ "ARG|COL" .And. Funname() $ "MATA101N|MATA465N|MATA466N|MATA467N", .T., .F.)

If MaFisFound("NF")
	If cPaisLoc	==	"RUS" .And. aNFCab[NF_OPERNF] == "S" .And. !Empty(aNFCab[NF_ESPECIE])
		dTmp	:= dDataBase
		dDataBase	:=	M->F2_DTSAIDA
	EndIf

	If SubStr(cReferencia,1,2) == "NF"
		If lRet := MaFisVldAlt(cReferencia)
			MaFisAlt(cReferencia,xValor)
			For nY := 1 to Len(aCols)
				If MaFisFound("IT",nY)
					For nX	:= 1 to Len(aHeader)
						cValid	:= AllTrim(UPPER(aHeader[nX][6]))
						If "MAFISREF"$cValid
							nPosRef := AT('MAFISREF("',cValid) + 10
							cRefCols:=Substr(cValid,nPosRef,AT('","'+cProg+'",',cValid)-nPosRef )
							aCols[nY][nX]:= MaFisRet(nY,cRefCols)
						EndIf
					Next nX
				EndIf
			Next nY
		EndIf
	Else
		If MaFisFound("IT",N)
			If aNfItem[N][IT_DELETED] .And. IIf(Len(aCols[1])==Len(aHeader)+1,!aCols[N][Len(aHeader)+1],.F.)
				MaFisDel(N,.F.)
			EndIf
			If GdFieldPos("D1_ITEM")>0
				aNfItem[N][IT_ITEM] := aCols[N][GdFieldPos("D1_ITEM")]
			EndIf
		EndIf
		MaFisIniLoad(n)
		If lRet := MaFisVldAlt(cReferencia,n)
			MaFisAlt(cReferencia,xValor,n)
			For nX	:= 1 to Len(aHeader)
				cValid	:= AllTrim(UPPER(aHeader[nX][6]))
				If "MAFISREF"$cValid
					nPosRef := AT('MAFISREF("',cValid) + 10
					cRefCols:=Substr(cValid,nPosRef,AT('","'+cProg+'",',cValid)-nPosRef )
					//Se a referencia for da Classificação fiscal e a TES estiver em branco, a Classificação fiscal nã será
					//Atribuida ao aCols da Nota
					If cRefCols == "IT_CF" .AND. nPosTES > 0 .AND. Empty(aCols[n][nPosTES])
						If cPaisLoc <> "RUS"
							aCols[n][nX] := ""
						Else
							//phantom error in criavar as a result TES Length is 0 which user can input in aCols   
							//TES size is the same for all tables, so we use SD1 as reference
							aCols[n][nX] := Space(FisTamSX3( 'SD1','D1_TES')[1])
						EndIf
					Else
						aCols[n][nX]:= MaFisRet(n,cRefCols)
					Endif
				EndIf
			Next nX
		EndIf
	EndIf
	If lActItems .And. (cReferencia $ "IT_QUANT|IT_PRCUNI|IT_VALMERC|IT_TES|IT_DESCONTO|IT_CF|IT_PROVENT|IT_CODMUN|IT_TPACTIV")
		If aNfItem[n][IT_PRCUNI] > 0 .And. aNfItem[n][IT_VALMERC] > 0 .And. !Empty(aNfItem[n][IT_TES])
			If aNfItem[n][IT_TES] <> aTes[TS_CODIGO]
				If Type("aTesMXF") <> "U"
					nPosTESM := Ascan(aTesMXF,{|X| X[1] == n})
				EndIf
				If nPosTESM > 0
					aTes := aClone(aTesMXF[nPosTESM][2])
				Else
					MaFisTes(aNfItem[n][IT_TES],aNfItem[n][IT_RECNOSF4],n)
				EndIf
			EndIf
			If aScan(aTes[TS_SFC], { |x| Alltrim(x[SFC_CALCULO]) == "T" }) > 0
				MaFisToCols(aHeader,aCols,,"MT100")
			EndIf
		EndIf
	EndIf
	If cPaisLoc == "RUS" .AND. Type('bRefresh') == 'B' .OR. cPaisLoc <> "RUS"
		Eval(bRefresh)
	EndIf
	If cPaisLoc	==	"RUS" .And. aNFCab[NF_OPERNF] == "S" .And. !Empty(aNFCab[NF_ESPECIE])
		If cReferencia == "IT_VALMERC" .or. cReferencia =="IT_CF" //case when we change D2_TOTAL or D2_CF
			lRet := lRet .AND. ExcRt467N(Nil, N) //recalculate values in local currency for line N
		EndIf
		dDataBase:=dTmp
	Endif
EndIf

RestArea(aArea)

Return lRet

/*MaFisAlt - Edson Maricate -09.12.1999
Altera os valores de impostos e bases do item
*/
Function MaFisAlt(cCampo,nValor,nItem,lNoCabec,nItemNao,lDupl,cRotina,lRecal,dVencReal,aTrbGen)

Local aArea       := GetArea()
Local aRef        := {}
Local cPosCpo     := ""
Local nPos        := 0
Local nValAnt     := 0
Local nPosItDec   := 0
Local cCpoTxMoeda := IIf( cPaisLoc $ "PER" , "/NF_TXMOEDA" , "" )
Local lCDAIndic	  := fisExtTab('12.1.2310', .T., 'CDA')
Local nPosGen     := 0
Local cRefTrbGen  := ""
Local nTrbGen	:= 0
Local nY		:= 0
Local cCpoD1Altr  := ""

DEFAULT lNoCabec := .F.
DEFAULT nItemNao := 0
DEFAULT lDupl    := .F.
DEFAULT cRotina  := ""
DEFAULT lRecal   := .T.
DEFAULT dVencReal := dDataBase
DEFAULT aTrbGen  := {"",""}

If fisGetParam('MV_RSATIVO',.F.)
	lRastItem := .T.
EndIf

// Para alterar _TRIBGEN é OBRIGATÓRIO passar o aTrbGen completo (sigla + referencia).
If ((cCampo == "IT_TRIBGEN" .Or. cCampo == "NF_TRIBGEN") .And. (Len(aTrbGen) < 2 .Or. (Len(aTrbGen) >= 2 .And. (Empty(aTrbGen[TG_SIGLA]) .Or. Empty(aTrbGen[TG_REFERENCIA])))))
	nValor := Nil
Endif

IF cCampo == "NF_TPCLIFOR"
	nValor := TpCliFor(nValor) // Função para converter o tipo do Cliente/Fornecedor para um típo válido. DSERFISE-8201
EndIF

If nValor <> Nil
	Do Case
		Case Substr(cCampo,1,2) == "IT"
			If MaFisFound("IT",nItem)
				If MaFisRet(nItem,cCampo,aTrbGen) <> nValor
					If !lNocabec
						MaFisSomaIt(nItem,.F.,cCampo)
					EndIf					
					 
					//Configurador com Legado 
					//Converte Referencia alterada legado em Configurador 
					If len(aNFItem[nItem][IT_TRIBGEN]) > 0  .and. (Len(aTrbGen) >= 2 .And. (Empty(aTrbGen[TG_SIGLA]) .Or. Empty(aTrbGen[TG_REFERENCIA])))
						cCpoD1Altr := cCampo
						ccampo     := AltTribLeg(aNfItem,nItem,ccampo,aTrbGen)
					Endif					

					If cCampo == "IT_TRIBGEN"
						cPosCpo	:= MaFisScan(aTrbGen[TG_REFERENCIA])
						If (nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_SIGLA]) == AllTrim(aTrbGen[TG_SIGLA])})) > 0
							aNfItem[nItem][IT_TRIBGEN][nPosGen][cPosCpo] := nValor
						EndIf
					Else
						cPosCpo	:= MaFisScan(cCampo)

						// Tratamento para os itens.
						If ValType(cPosCpo) == "A"
							aNfItem[nItem][cPosCpo[1]][cPosCpo[2]] := nValor
							If (cPaisLoc=="RUS") .AND. (cCampo == "IT_BASEIV1_C1" .OR. cCampo == "IT_VALIV1_C1")
								Do Case
									Case (aTes[TS_SFC][Len(aTes[TS_SFC])][SFC_INCNOTA] == "1") .And. (aTes[TS_SFC][Len(aTes[TS_SFC])][SFC_CREDITA] $ "1|3")
										aNfItem[nItem][IT_VALMERC_C1] := aNfItem[nItem][IT_BASEIMP_C1][cPosCpo[2]]
										aRefAlt[nItem][IT_VALMERC_C1] := .T.
									Case (aTes[TS_SFC][Len(aTes[TS_SFC])][SFC_INCNOTA] == "3") .And. (aTes[TS_SFC][Len(aTes[TS_SFC])][SFC_CREDITA] $ "2|3")
										aNfItem[nItem][IT_VALMERC_C1] := aNfItem[nItem][IT_BASEIMP_C1][cPosCpo[2]]+aNfItem[nItem][IT_VALIMP_C1][cPosCpo[2]]
										aRefAlt[nItem][IT_VALMERC_C1] := .T.
								EndCase
							EndIf
							aRefAlt[nItem][cPosCpo[1]][cPosCpo[2]] := .T.
						Else
							aNfItem[nItem][Val(cPosCpo)] := nValor
							If (cPaisLoc=="RUS") .AND. (cCampo == "IT_VALMERC")
								aNfItem[nItem][IT_VALMERC_C1] := xMoeda(nValor,aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
								aRefAlt[nItem][IT_VALMERC_C1] := .T.
							EndIf
							aRefAlt[nItem][Val(cPosCpo)] := .T.
						EndIf
					EndIf

					If AllTrim(cCampo) == "IT_PRODUTO" .And. !Empty( aNfItem[nItem][IT_PRODUTO] ) .And. (!( aNfItem[nItem][IT_PRODUTO] == aNfItem[nItem][IT_PRD][SB_COD] ))
						MaFisIniCpo(nItem)
					EndIf

					If AllTrim(cCampo) == "IT_TES" .And. !Empty( aNfItem[nItem][IT_TES] ) .And. ( aNfItem[nItem][IT_TES] <> aNfItem[nItem][IT_TS][TS_CODIGO] )
						MaNewFisTES(aNfItem[nItem][IT_TES],,nItem)
					EndIf

					If cPaisLoc=="BOL"  .AND. fisFindFunc( "MAFISICEBO" ) .AND. (AllTrim(cCampo) $ "IT_QUANT|IT_PRCUNI|IT_VALMERC")
						nValor:= MAFISICEBO(cCampo,nValor,funname())
						aNfItem[nItem][Val(cPosCpo)] := nValor
					EndIf
					// Tratamento especifico e diferenciado para cada campo.
					If lRecal .and. IIF(cPaisLoc == "ARG" .and. Type("lLocxAuto") <> "U" .and. lLocxAuto, !cCampo $ "IT_" .and. Iif(Type("cUltCpo") <> "U", cCampo == cUltCpo .or. cCampo == "IT_VALMERC" .or. cCampo == "IT_DESCONTO" ,.T.) , .T.)
						MaFisRecal(cCampo,nItem,dVencReal,aTrbGen,cCpoD1Altr)
						If (cPaisLoc=="RUS") .AND. (Alltrim(cCampo)	==	"IT_VALMERC")
							MaFisRecal("IT_VALMERC_C1",nItem,dVencReal)
						EndIf
					EndIf

					If !lNoCabec
						MaFisSomaIt(nItem)
						If bFisRefresh <> Nil
							Eval(bFisRefresh)
						EndIf
						If bLivroRefresh <> Nil
							Eval(bLivroRefresh)
						EndIf
					EndIf

					If cPaisLoc == "BRA" .And. lCDAIndic .And. Type("oLancApICMS") == "O"
						a103AjuICM(nItem)
					EndIf
				EndIf
			EndIf
		Case Substr(cCampo,1,2) == "NF"
			If MaFisFound("NF")
				If MaFisRet(,cCampo,aTrbGen) <> nValor .Or. lDupl

					If cCampo == "NF_TRIBGEN"
						cPosCpo	:= MaFisScan(aTrbGen[TG_REFERENCIA])
						If (nPosGen := aScan(aNFCab[NF_TRIBGEN], {|x| AllTrim(x[TG_NF_SIGLA]) == AllTrim(aTrbGen[TG_SIGLA])})) > 0
							nValAnt := aNFCab[NF_TRIBGEN][nPosGen][cPosCpo]
							aNFCab[NF_TRIBGEN][nPosGen][cPosCpo] := nValor
						EndIf
					Else
						cPosCpo	:= MaFisScan(cCampo)
						// Tratamento para o cabecalho.
						If ValType(cPosCpo) == "A"
							nValAnt	:= aNfCab[cPosCpo[1]][cPosCpo[2]]
							aNfCab[cPosCpo[1]][cPosCpo[2]] := nValor
						Else
							nValAnt	:= aNfCab[Val(cPosCpo)]
							aNfCab[Val(cPosCpo)] := nValor
						EndIf
					EndIf

					// Tratamento especifico e diferenciado para cada campo.
					Do Case
						Case AllTrim(cCampo)$"NF_CODCLIFOR/NF_LOJA/NF_TIPONF/NF_OPERNF/NF_CLIFOR/NF_NATUREZA/NF_CLIDEST/NF_LOJDEST/NF_TPFRETE"+cCpoTxMoeda
							// Reinicia os valores de arredondamento dos impostos contidos no aSaveDec.
							If AllTrim(cCampo)$"NF_NATUREZA"
								aRef := {"IT_VALISS","IT_VALIRR","IT_VALINS","IT_VALCOF","IT_VALCSL","IT_VALPIS","IT_VALPS2","IT_VALCF2","IT_VALPS3","IT_VALCF3"}
								For nPos := 1 to Len(aItemRef)
									If !Empty(aScan(aRef,aItemRef[nPos,1]))
										aSaveDec[nPos] := 0
									EndIF
								Next nPos
								//Aqui não preciso zerar o SaveDec dos tributos genéricos, pois acima só são zerados os tributos legados, logo os genéricos não será necessário zerar.
							Else
								aSaveDec := Nil

								//Limpo aqui os valores do SaVeDec dos tributos genéricos.
								aNFCab[NF_SAVEDEC_TG]	:= {}
							EndIf

							MaFisIni( NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, cRotina, NIL, NIL, NIL, NIL, aNfCab[NF_RECISS],,,,,,,,,,,,,,,,aNfCab[NF_CLIDEST],aNfCab[NF_LOJDEST] )

							For nItem := 1 To Len(aNfItem)
								If AllTrim(cCampo)$"NF_CODCLIFOR/NF_LOJA"
									aNfItem[nItem, IT_EXCECAO]	:=	{}
									// Quando estiver alterando o cliente/fornecedor, necessito a chamada da MaFisIniCpo para recarregar as referencias
									// da amarracao UF x UF x Produto (tabela CFC).
									MaFisIniCpo( nItem )
									//Como zero o array aSaveDec acima, preciso zerar o aItemDec tambem, para nao dar diferenca na funcao MaItArred
								ElseIf AllTrim(cCampo)$"NF_NATUREZA"
									For nPos := 1 to Len(aRef)
										nPosItDec	:=	aScan(aItemRef,{|aX| aX[1]==aRef[nPos]})
										If !Empty(nPosItDec)
											If Len(aItemDec[nItem][1])>=nPosItDec
												aItemDec[nItem][1][nPosItDec]	:=	0
											EndIf
											If Len(aItemDec[nItem][2])>=nPosItDec
												aItemDec[nItem][2][nPosItDec]	:=	0
											EndIf
										EndIf
									Next nPos
									//Aqui não preciso zerar o SaveDec dos tributos genéricos, pois acima só são zerados os tributos legados contidos no aRef, logo os genéricos não será necessário zerar.
								EndIf

								MaFisRecal(cCampo,nItem,dVencReal)

								If cPaisLoc == "BRA" .And. lCDAIndic .And. Type("oLancApICMS") == "O"
									a103AjuICM(nItem)
								EndIf
							Next nItem

							If !lNoCabec
								MaIt2Cab()
							EndIf

						Case AllTrim(cCampo)$"NF_UFDEST/NF_UFORIGEM/NF_SUFRAMA/NF_AUXACUM/NF_RECISS"+Iif(cPaisLoc <> "BRA","/NF_SERIENF/NF_PROVENT","")+Iif(cPaisLoc $ "COL|BRA|EUA","/NF_CODMUN/NF_TPACTIV","")+"/NF_PNF_COD/NF_PNF_LOJ/NF_PNF_UF/NF_PNF_TPCLIFOR/NF_DTEMISS/NF_MODAL"
							// Refaz cabeçalho da CFC
							MaSeekCFC(1)

							For nItem := 1 To Len(aNfItem)
								If AllTrim(cCampo)$"NF_UFDEST"
									aNfItem[nItem, IT_EXCECAO]	:=	{}
									// Carga da Tabela CFC.
									MaSeekCFC(2, nItem)
									
									If cPaisLoc == "ARG"
										aNFItem[nItem][IT_TS][TS_CODIGO] := "   "
									Endif
								EndIf

								MaFisRecal(cCampo,nItem,dVencReal)

								If !lNoCabec .And. cPaisLoc <> "BRA"
									MaFisSomaIt(nItem)
									If bFisRefresh <> Nil
										Eval(bFisRefresh)
									EndIf
									If bLivroRefresh <> Nil
										Eval(bLivroRefresh)
									EndIf
								EndIf
							Next nItem

							If !lNoCabec
								MaIt2Cab()
							EndIf
							// Atualizacao/recalculo dos valores na alteracao da moeda e taxa
						Case cPaisLoc == "ARG" .And. ((nValAnt <> nValor .Or. lDupl) .And. ValType(nValor) == "N" ) .And. (AllTrim(cCampo)$"NF_MOEDA/NF_TXMOEDA/")
							For nItem := 1 To Len(aNfItem)
								MaFisRecal(Alltrim(cCampo),nItem)
							Next
							If !lNoCabec
								MaIt2Cab()
							Endif
							//	Atualizacao/recalculo dos valores na alteracao dos valores na aba de impostos
						Case cPaisLoc == "ARG" .And. 'NF_VALIV'$AllTrim(cCampo)
							MaFisRatRes("IT"+Substr(cCampo,3,Len(cCampo)-2),nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],'IT_ALIQ'+aNfCab[NF_IMPOSTOS][nItem][IMP_NOME],'IT_BASE'+aNfCab[NF_IMPOSTOS][nItem][IMP_NOME],nItemNao)
							For nItem := 1 to Len(aNfItem)
								MaFisRecal("IT"+Substr(cCampo,3,Len(cCampo)-2),nItem)
							Next nItem
							If !lNoCabec
								MaIt2Cab(nItemNao)
							EndIf
						Case cPaisLoc == "COL" .And. 'NF_VALIV'$AllTrim(cCampo) .And. FindFunction("LxImpLibC") .And. LxImpLibC()
							MaFisRatRes("IT"+Substr(cCampo,3,Len(cCampo)-2),nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],'IT_ALIQ'+aNfCab[NF_IMPOSTOS][nItem][IMP_NOME],'IT_BASE'+aNfCab[NF_IMPOSTOS][nItem][IMP_NOME],nItemNao)
							For nItem := 1 to Len(aNfItem)
								MaFisRecal("IT"+Substr(cCampo,3,Len(cCampo)-2),nItem)
							Next nItem
							If !lNoCabec
								MaIt2Cab(nItemNao)
							EndIf							
						OtherWise
							If ((nValAnt <> nValor .Or. lDupl) .And. ValType(nValor) == "N" ) .And. !(AllTrim(cCampo)$"NF_MOEDA/NF_TXMOEDA/") .And. !'NF_MINIV'$AllTrim(cCampo) .And.!'NF_MINIMP'$AllTrim(cCampo)
								If AllTrim(cCampo)$"NF_FRETE/NF_SEGURO/NF_DESPESA/NF_DESCONTO/NF_DESCTOT/NF_ACRESCI/NF_VLR_FRT/NF_DESNTRB/NF_TARA/NF_ADIANTTOT/NF_AFRMIMP/NF_VALPEDG"

									For nItem := 1 To Len(aNfItem)
										aFill(aItemDec[nItem][1],0)
										aFill(aItemDec[nItem][2],0)
                                        If cPaisLoc $ "COL|PER|MEX" .and. fisGetParam('MV_DESCSAI','') == "2"
											MaFisSomaIt(nItem)
											If MaFisFound("IT",nItem)
												If MaFisRet(nItem,"IT_DESCONTO",aTrbGen) <> nValor
													If !lNoCabec
														MaFisSomaIt(nItem,.F.,"IT_DESCONTO")
													EndIf
												EndIf
											EndIf
										EndIf

										//Zero abaixo os valores de ItemDec dos tributos genéricos
										//Percorre lista dos tributos enquadrados e calculados
										For nTrbGen:= 1 to Len(aNfItem[nItem][IT_TRIBGEN])

											//Neste laço percorro os campos do tributo genérico(Base, Alíquota, Valor) que estão com flag para tratar arredondamento e sobra
											For nY:= 1 to Len(aTGITRef)
												aNfItem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_ITEMDEC][1][nY]	:= 0
												aNfItem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_ITEMDEC][2][nY]	:= 0
											Next nY

										Next nTrbGen

									Next nItem

									aFill(aSaveDec,0)
									//Zero o SaveDec dos tributos genéricos aqui
									aNFCab[NF_SAVEDEC_TG]	:= {}

								EndIf
								If cCampo == "NF_TRIBGEN"
									// Necessário fazer este "de-para" entre as referências pois como o MaFisAlt que chamou a
									// MaRateio foi de NF_TRIBGEN a referência em aTrbGen é "TG_NF_" e no trecho abaixo preciso
									// da referência correspondente em "TG_IT_" para efetuar o rateio entre os itens.
									Do Case
										Case aTrbGen[TG_REFERENCIA] == "TG_NF_BASE"
											cRefTrbGen := "TG_IT_BASE"
										Case aTrbGen[TG_REFERENCIA] == "TG_NF_VALOR"
											cRefTrbGen := "TG_IT_VALOR"
									EndCase
									MaRateio("IT_TRIBGEN",nValAnt,nValor,lDupl,{aTrbGen[1], cRefTrbGen})
									For nItem := 1 To Len(aNfItem)
										MaFisRecal("IT_TRIBGEN",nItem,dVencReal,{aTrbGen[1], cRefTrbGen})
										If cPaisLoc=="BRA" .And. lCDAIndic .And. Type("oLancApICMS")=="O"
											a103AjuICM(nItem)
										EndIf
									Next nItem
									If !lNoCabec
										MaIt2Cab()
									EndIf
								Else
									MaRateio("IT"+Substr(cCampo,3,Len(cCampo)-2),nValAnt,nValor,lDupl)
									For nItem := 1 To Len(aNfItem)
										MaFisRecal("IT"+Substr(cCampo,3,Len(cCampo)-2),nItem,dVencReal)
										If cPaisLoc=="BRA" .And. lCDAIndic .And. Type("oLancApICMS")=="O"
											a103AjuICM(nItem)
										EndIf
									Next nItem
									If !lNoCabec
										MaIt2Cab()
									EndIf
								EndIf
							EndIf
					EndCase
				EndIf
			EndIf
		Case Substr(cCampo,1,3) == "IMP"
			If cCampo == "IMP_TRIBGEN"
				MaFisRatRes("IT_TRIBGEN",nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],"TG_IT_ALIQUOTA","TG_IT_BASE",nItemNao,aTrbGen)
				For nItem := 1 to Len(aNfItem)
					If nItem <> nItemNao
						MaFisRecal("IT_TRIBGEN",nItem,dVencReal,aTrbGen)
						If cPaisLoc=="BRA" .And. lCDAIndic .And. Type("oLancApICMS")=="O"
							a103AjuICM(nItem)
						EndIf
					Endif
				Next nItem
				If !lNoCabec
					MaIt2Cab(nItemNao)
				EndIf
			Else
				If cCampo == "IMP_VALRUR"
					cCampo := "IMP_FUNRURAL"
					MaFisRatRes("IT_FUNRURAL",nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],"IT_PERFUN","IT_BASEFUN",nItemNao)
				ElseIf cCampo == "IMP_VALSENAR"
                    cCampo := "IMP_FUNRURAL"
                    MaFisRatRes("IT_VLSENAR",nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],"IT_ALSENAR","IT_BSSENAR",nItemNao)
				ElseIF cCampo $ "IMP_BASEINP/IMP_VALINP"
					MaFisRatRes("IT"+Substr(cCampo,4,Len(cCampo)-3),nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],"IT_PERCINP","IT_BASEINP",nItemNao)
				ElseIf Alltrim(cCampo) $ "IMP_VALCMP"
					MaFisRatRes("IT"+Substr(cCampo,4,Len(cCampo)-3),nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],'IT_ALIQ'+aNfCab[NF_IMPOSTOS][nItem][IMP_NOME],'IT_BASEICM',nItemNao)
				Else
					If Alltrim(cCampo) $ "IMP_BASECID | IMP_VALCIDE"
						MaFisRatRes("IT"+Substr(cCampo,4,Len(cCampo)-3),nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],'IT_ALQ'+aNfCab[NF_IMPOSTOS][nItem][IMP_DESC],'IT_BASE'+aNfCab[NF_IMPOSTOS][nItem][IMP_NOME],nItemNao)
					Else		
						MaFisRatRes("IT"+Substr(cCampo,4,Len(cCampo)-3),nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],'IT_ALIQ'+aNfCab[NF_IMPOSTOS][nItem][IMP_NOME],'IT_BASE'+aNfCab[NF_IMPOSTOS][nItem][IMP_NOME],nItemNao)
					EndIF
				EndIf
				For nItem := 1 to Len(aNfItem)
					If nItem <> nItemNao
						MaFisRecal("IT"+Substr(cCampo,4,Len(cCampo)-3),nItem,dVencReal)
						If cPaisLoc=="BRA" .And. lCDAIndic .And. Type("oLancApICMS")=="O"
							a103AjuICM(nItem)
						EndIf
					Endif
				Next nItem
				If !lNoCabec
					MaIt2Cab(nItemNao)
				EndIf
			EndIf
	EndCase
EndIF

RestArea(aArea)

Return .T.

/*/
MaFisRecal -  Edson Maricate-20.12.1999
Recalcula os valores de impostos do item.
Parametros
ExpC1: Campo que sofreu alteracao.
ExpN2: Item.
/*/
Function MaFisRecal(cCampo,nItem,dVencReal,aTrbGen,cCpoD1Altr)

Local nPosTESM		:= 0
Local nPosAux		:= 0
Local lSort			:= .F.
Local lMVRPCBIZF	:= fisGetParam('MV_RPCBIZF',.F.) .And. aNfCab[NF_UFDEST] $ fisGetParam('MV_RPCBIUF','')
Local aTribLegA		:= {}
Local aTribLegD		:= {}
Local aTrbLegCalc	:= {}
Local nTot 			:= aNfItem[nItem][IT_TOTAL]
Local lProtege		:= ((aNFItem[nItem][IT_TS][TS_ALIQPRO] > 0) .AND. ((aNFCab[NF_UFORIGEM]=="GO") .OR. (aNFCab[NF_UFDEST]=="GO")))
Local lFeef			:= (aNfItem[nItem][IT_UFXPROD][UFP_ALFEEF] > 0 .and. aNFItem[nItem][IT_TS][TS_FEEF]== '1' .OR. (aNFItem[nItem][IT_TS][TS_ALQFEEF] > 0 .and. ( empty(aNFItem[nItem][IT_TS][TS_FEEF]) .or. aNFItem[nItem][IT_TS][TS_FEEF]== '1')))

DEFAULT cCampo	:=	""
DEFAULT dVencReal := dDataBase
DEFAULT aTrbGen := {"",""}
DEFAULT cCpoD1Altr := ""

//==============================================
//RETIRADA DE ESPAÇOS E TRATAR PARA CAIXA ALTA
//==============================================
cCampo:= AllTrim(UPPER(cCampo))

CargOper(aNfCab,cCampo,aNfItem,nItem, .T.)

If cCampo == "IT_PRODUTO" .And. !Empty( aNfItem[nItem][IT_PRODUTO] ) .And. (!( aNfItem[nItem][IT_PRODUTO] == aNfItem[nItem][IT_PRD][SB_COD] ))
	MaFisIniCpo(nItem)
EndIf

If cCampo == "IT_TES" .And. cPaisLoc == "BRA"   .And. !Empty( aNfItem[nItem][IT_TES] ) .And. ( aNfItem[nItem][IT_TES] <> aNfItem[nItem][IT_TS][TS_CODIGO] )
	MaNewFisTES(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
EndIf

If aNfItem[nItem][IT_TES] <> aTes[TS_CODIGO]
	If cPaisLoc == "ARG"
		If Type("aTesMXF") <> "U"
			nPosTESM := Ascan(aTesMXF,{|X| X[1] == nItem})

			If nPosTESM > 0 .and. aTesMXF[nPosTESM][2][1] == aNfItem[nItem][IT_TES]
				aTes := AClone(aTesMXF[nPosTESM][2])
			Else
				nPosAux := ascan(aTesMXF,{|x| AllTrim(x[2][1]) == AllTrim(aNfItem[nItem][IT_TES])})
				lSort 	:= !(Type("l120Auto") <> "U" .and. l120Auto)
				If nPosAux > 0 .and. Type("aTesMXF") <> "U" .and. AllTrim(aNfItem[nItem][IT_TES]) <> "" .and. !lSort
					If Type("aTesMXF") <> "U" .and. nPosTESM == 0
						AADD(aTesMXF,{nItem,AClone(aTesMXF[nPosAux][2])})
						aTes := AClone(aTesMXF[Len(aTesMXF)][2])
					ElseIf nPosTESM > 0
						aTesMXF[nPosTESM][2] := AClone(aTesMXF[nPosAux][2])
						aTes := AClone(aTesMXF[nPosTESM][2])
					EndIf
				Else
					MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
					If Type("aTesMXF") <> "U" .and. nPosTESM == 0 .and. !Empty(aTes[TS_CODIGO])
						AADD(aTesMXF,{nItem,AClone(aTes)})
					ElseIf nPosTESM > 0 .and. !Empty(aTes[TS_CODIGO])
						aTesMXF[nPosTESM][2] := AClone(aTes)
					EndIf
				EndIf
			EndIf
		Else
			MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
		EndIf
	Else
		MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
	EndIf
EndIf

Do Case
	Case Empty(cCampo) 
		//encapsulamento deste trecho que era executado no trecho OtherWise
		//para replicar e melhorar a performance quando cCampo estiver vazio
		fMatOwise(cCampo,nItem,dVencReal,lMVRPCBIZF,aTrbLegCalc) 
	Case cCampo == "IT_NORECAL" .AND. cPaisLoc == "BRA"
		// Case para chamar o CFGTRIB que está no final da pilha, porém não deve recalcular os impostos do legado.
		aNfItem[nItem][IT_NORECAL] := "S"
	Case cCampo == "IT_CF"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				// Proteção para não recalcular a alíquota de ICMS caso ela tenha sido intencionalmente
				// alterada por MaFisAlt ou MaFisLoad.
				If aNfCab[NF_USAALIQSN] .And. !aRefAlt[nItem][IT_ALIQICM]
					// Recalculo a alíquota de ICMS.
					MaAliqIcms(nItem)
					// Chamo recursivamente a função MaFisRecal com a referência "IT_ALIQICM" para
					// efetuar todos os recálculos que devem ser feitos na alteração da alíquota.
					MaFisRecal("IT_ALIQICM",nItem,dVencReal)
				EndIf
				MaFisII(nItem)
				MaFisVTot(nItem)
			EndIf
			MaCodDecl(nItem)
		EndIf
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisTPDP(nItem)
		If cPaisLoc $ "ARG|COL|RUS"
			MaFisImpIV(nItem,cCampo)
			MaFisNameIV(,nItem)
			MaFisVTot(nItem)
		Endif
	Case cCampo == "IT_VALMERC"
		aNfItem[nItem][IT_DESCZF] := 0
		If cPaisLoc == "BRA"
			MaAliqSoli(nItem)
			MaExcecao(nItem)
			MaMargem(nItem)
		Endif
		MaFisPreCalc(nItem,cCampo)
		If cPaisLoc == "BRA"
			MaFisIPI(nItem,"BSE|VLR")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0 //Caso haja PIS/COFINS desonerado para ZFM, chamo a MaFisVDescZF para evitar o cálculo incorreto da base de ICMS
				MaFisVDescZF(nItem)
			EndIf
			MaFisBSICM(nItem)
			MaALIQCMP(nItem)
			MaFisVICMS(nItem)
			MaFisISS(nItem)
			If !( aNFItem[nItem][IT_TS][TS_TPIPI]=="B" .Or. (fisGetParam('MV_IPIBRUT','')=="S" .And. aNFItem[nItem][IT_TS][TS_TPIPI] ==" ") ) .And. ( aNFItem[nItem][IT_TS][TS_AGREG]=="D" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="R" )
				MaFisIPI(nItem,"BSE|VLR")
			EndIf
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
			MaFisVTot(nItem)
			MaFisVComp(nItem)
			MaFisVDescZF(nItem)
			MaFisBSSol(nItem)	
			MaFisVSol(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						If aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2" .And. ChkProdNac(nItem)
							ZfCalcCofPis(nItem)
						EndIf
						If ChkDescCF( lMVRPCBIZF, nItem )
							MaFisBSICM(nItem,,.T.)
							MaFisVICMS(nItem)
						EndIf
						If aNfItem[nItem][IT_DESCZF] == 0 .Or. !(!ChkProdNac(nItem) .And. aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2")
							ZfDedBCofPis(nItem)
						EndIf
						MaFisVTot(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
					IF lMVRPCBIZF .And. !ChkProdNac(nItem)
				  		MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
				EndIf
			EndIf
			MaFisRURAL(nItem)
			MaFisVSul(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			If aNFItem[nItem][IT_TS][TS_BCPCST] == "1" //Campo que indica se os valores de PIS/COFINS ST entram na base de ICMS-ST
				MaFisBSSOL(nItem)
				MaFisVSol(nItem)
			EndIf
			MaFisVTot(nItem)
			MaFisSENAR(nItem)
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
			MaFisTPDP(nItem)
			MaFisLF(nItem)
			MaFisPROT(nItem)
			MaFisLF(nItem)
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		MaFisNameIV(,nItem)
		If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			If aNfItem[nItem][IT_DESCZF] == 0 .Or. !(!ChkProdNac(nItem) .And. aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2")
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
			EndIf	
			If !(fisGetParam('MV_DESCZF',.T.) .and. fisGetParam('MV_CPRBNF',.F.) .AND. fisGetParam('MV_DEDBPIS','') == "D" .AND. fisGetParam('MV_DEDBCPR','N') == "D")
				MaFisCPRB(nItem)
			EndIf
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					If ChkDescCF( lMVRPCBIZF, nItem )
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
					EndIf
					If aNfItem[nItem][IT_DESCZF] == 0 .Or. !(!ChkProdNac(nItem) .And. aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2")
						ZfDedBCofPis(nItem)
					EndIf
					If aNFItem[nItem][IT_TS][TS_DESCOND] == "1" .Or. !ChkProdNac(nItem)
						ZfCalcCofPis(nItem)
					EndIf
					MaFisVTot(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
				If lMVRPCBIZF .And. !ChkProdNac(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
			EndIf
			MaFisLF(nItem)
			MaFisPROT(nItem)
			MaFisLF(nItem)
		EndIf
		If aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1"
			MaFisBsIcm(nItem)
			MaFisVICMS(nItem)
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		Endif
		MaFisVTot(nItem,Iif(cPaisLoc == "RUS",cCampo,Nil))
		If cPaisLoc == "BRA"
			MaFisINSS(nItem,"BSE|VLR")
			// se for dedução simplificada, preciso recalcular todos os itens da NF
			if fisFindFunc('RECALIR') .and. (aNFCab[NF_INIDEDS] .or. aNFCab[NF_ITDEDDIF] > 0)
				RecalIR(aNFCab, aNfItem, nItem)// substituo a chamada direta da MaFisIr
			else
				MaFisIR(nItem,,dVencReal)
			endif
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIF
			MaFisCSLL(nItem)
			MaFisSEST(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisISSBi(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			MaFisCide(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
			If aNFItem[nItem][IT_TS][TS_BCPCST] == "1" //Campo que indica se os valores de PIS/COFINS ST entram na base de ICMS-ST
				MaFisBSSOL(nItem)
				MaFisVSol(nItem)
			EndIf
			MaFisINSP(nItem)
			// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
			If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
				// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
				// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
				// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
				If aNFItem[nItem][IT_VALICM] == 0
					MaFisBSICM(nItem,,,,,.F.)
					MaFisVICMS(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)
					MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
					MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
				EndIf
			EndIf
			MaFisVTot(nItem)
		Endif
		MaFisLF(nItem) //Tratamento realizado para que não seja chamado dentro das funções MaFisPROT e MaFisFEEF e não comprometa a performance
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			//Recalcula o PIS/COFINS e o CPRB para somar o valor do crédito presumido, caso o sistema esteja parametrizado para isso
			CrdPresAdd( nItem,  aNfItem[nItem][IT_LIVRO][LF_CRDPRES] > 0, fisGetParam('MV_CPRBNF',.F.) .And. fisGetParam('MV_CRDPRCP',.F.), fisGetParam('MV_CRDPRPC',.F.),;
								aNfItem[nItem][IT_VALPIS], aNfItem[nItem][IT_VALPS2], aNfItem[nItem][IT_VALPS3],;
								aNfItem[nItem][IT_VALCOF], aNfItem[nItem][IT_VALCF2], aNfItem[nItem][IT_VALCF3] )
			MaFisLF(nItem)
			MaFisAFRMM(nItem)
			MaFisFFF(nItem)
		EndIf

	Case cPaisLoc == "RUS" .And. cCampo == "IT_VALMERC_C1"
		aNfItem[nItem][IT_DESCZF] := 0
		MaFisPreCalc(nItem,cCampo)
		MaFisImpIV(nItem,cCampo)
		MaFisNameIV(,nItem)
		If aNFItem[nItem][IT_TS][TS_OPERSUC] == "1"
			MaFisBsIcm(nItem)
			MaFisVICMS(nItem)
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		Endif
		MaFisVTot(nItem,Iif(cPaisLoc == "RUS",cCampo,Nil))
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
	Case cCampo == "IT_BASEICM"
		MaAliqSoli(nItem)
		MaExcecao(nItem)
		MaMargem(nItem)
		MaFisVICMS(nItem)
		MaFisTPDP(nItem)
		If !( aNFItem[nItem][IT_TS][TS_TPIPI]=="B" .Or. (fisGetParam('MV_IPIBRUT','')=="S" .And. aNFItem[nItem][IT_TS][TS_TPIPI] ==" ") )	.And. ( aNFItem[nItem][IT_TS][TS_AGREG]=="D" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="R" )
			MaFisIPI(nItem,"BSE|VLR")
		EndIf
		MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		MaFisVTot(nItem)
		MaFisVComp(nItem)
		MaFisBSSol(nItem)
		MaFisVSol(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			// Quando necessário ajuste de centavos na base de calculo do ICMS, o sistema não pode mudar os valores da base de calculo do PIS e COFINS importação.
			If !(aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3" .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"123")
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
			Endif

			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					ZfDedBCofPis(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem) //Tratamento realizado para que não seja chamado dentro das funções MaFisPROT e MaFisFEEF e não comprometa a performance
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_ALIQICM"
		If aNFItem[nItem][IT_TS][TS_AGREG] $ "I,A,D,R,E"
			MaFisBsICM( nItem , , , , cCampo )
		Endif
		MaAliqSoli(nItem)
		If !(IsInCallStack("GFEA065") .Or. IsInCallStack("GFEA065IPG")) // VALIDAÇÃO CRIADA PARA VERIFICAR INTEGRAÇÃO COM O SIGAGFE
			MaFisVICMS(nItem)
		EndIf
		MaFisTPDP(nItem)
		If !( aNFItem[nItem][IT_TS][TS_TPIPI]=="B" .Or. (fisGetParam('MV_IPIBRUT','')=="S" .And. aNFItem[nItem][IT_TS][TS_TPIPI] ==" ") )	.And. ( aNFItem[nItem][IT_TS][TS_AGREG]=="D" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="R" )
			MaFisIPI(nItem,"BSE|VLR")
		EndIf
		MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		MaFisVTot(nItem)
		MaFisVComp(nItem,,cCampo)
		If fisGetParam('MV_FISXMVA',.F.) .And. aNfItem[nItem][IT_TS][TS_LFICM] == "I" .And. aNfItem[nItem][IT_PRD][SB_IVAAJU] == "1" .And. aNFitem[nItem][IT_MARGEM] > 0 .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM]
			MaMargem(nItem)
			MaFisBSSol(nItem)
		Endif
		MaFisVSol(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.,,cCampo)
					MaFisVICMS(nItem)
					ZfDedBCofPis(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem,,cCampo)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem, cCampo)
			EndIf
		EndIf
		// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
		If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
			// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
			// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
			// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
			If aNFItem[nItem][IT_VALICM] == 0
				MaFisBSICM(nItem,,,,,.F.)
				MaFisVICMS(nItem)
				MaFisVTot(nItem)
				MaFisVComp(nItem,,cCampo)
				MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
				MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem)//Tratamento realizado para que não seja chamado dentro das funções MaFisPROT e MaFisFEEF e não comprometa a performance
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_ALIQIPI"
		MaAliqSoli(nItem)
		MaExcecao(nItem)
		MaMargem(nItem)
		MaFisTPDP(nItem)
		If aNFItem[nItem,IT_BASEIPI] == 0
			MaFisIPI(nItem,"BSE")
		Endif
		MaFisIPI(nItem,"VLR")
		If (aNFItem[nItem][IT_TS][TS_INCIDE]	== "S"  .Or. (aNFItem[nItem][IT_TS][TS_INCIDE] == "F" .And. aNFCab[NF_TPCLIFOR] =="F" .And. aNFCab[NF_CLIFOR] =="C")) .And.;
			aNFItem[nItem][IT_TS][TS_IPI] <> "R"
			MaFisBsICM(nItem)
			MaFisVICMS(nItem)
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		EndIf
		MaFisVTot(nItem)
		MaFisVComp(nItem)
		MaFisBSSol(nItem)
		MaFisVSol(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					ZfDedBCofPis(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem) //Tratamento realizado para que não seja chamado dentro das funções MaFisPROT e MaFisFEEF e não comprometa a performance
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		//Recalcula o PIS/COFINS e o CPRB para somar o valor do crédito presumido, caso o sistema esteja parametrizado para isso
		CrdPresAdd( nItem,  aNfItem[nItem][IT_LIVRO][LF_CRDPRES] > 0, fisGetParam('MV_CPRBNF',.F.) .And. fisGetParam('MV_CRDPRCP',.F.), fisGetParam('MV_CRDPRPC',.F.),;
							aNfItem[nItem][IT_VALPIS], aNfItem[nItem][IT_VALPS2], aNfItem[nItem][IT_VALPS3],;
							aNfItem[nItem][IT_VALCOF], aNfItem[nItem][IT_VALCF2], aNfItem[nItem][IT_VALCF3] )
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_BASEIPI"
		MaAliqSoli(nItem)
		MaExcecao(nItem)
		MaMargem(nItem)
		MaFisIPI(nItem,"VLR")
		MaFisTPDP(nItem)
		If (aNFItem[nItem][IT_TS][TS_INCIDE]	== "S" .Or. (aNFItem[nItem][IT_TS][TS_INCIDE] == "F" .And. aNFCab[NF_TPCLIFOR] =="F" .And. aNFCab[NF_CLIFOR] =="C")) .And.;
			aNFItem[nItem][IT_TS][TS_IPI] <> "R"
			MaFisBsIcm(nItem)
			MaFisVICMS(nItem)
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
			MaFisVTot(nItem)
			MaFisVComp(nItem)
			MaFisBSSol(nItem)
			MaFisVSol(nitem)
		EndIf
		IF aNFItem[nItem][IT_TS][TS_SOMAIPI] == "1"
			MaFisBSSol(nItem)
			MaFisVSol(nitem)
		EndIf
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					ZfDedBCofPis(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem) //Tratamento realizado para que não seja chamado dentro das funções MaFisPROT e MaFisFEEF e não comprometa a performance
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		//Recalcula o PIS/COFINS e o CPRB para somar o valor do crédito presumido, caso o sistema esteja parametrizado para isso
		CrdPresAdd( nItem,  aNfItem[nItem][IT_LIVRO][LF_CRDPRES] > 0, fisGetParam('MV_CPRBNF',.F.) .And. fisGetParam('MV_CRDPRCP',.F.), fisGetParam('MV_CRDPRPC',.F.),;
							aNfItem[nItem][IT_VALPIS], aNfItem[nItem][IT_VALPS2], aNfItem[nItem][IT_VALPS3],;
							aNfItem[nItem][IT_VALCOF], aNfItem[nItem][IT_VALCF2], aNfItem[nItem][IT_VALCF3] )
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_VALIPI"
		MaAliqSoli(nItem)
		MaExcecao(nItem)
		MaMargem(nItem)
		MaFisTPDP(nItem)
		If (aNFItem[nItem][IT_TS][TS_INCIDE]	== "S"  .Or. (aNFItem[nItem][IT_TS][TS_INCIDE] == "F" .And. aNFCab[NF_TPCLIFOR] =="F" .And. aNFCab[NF_CLIFOR] =="C")) .And.;
			aNFItem[nItem][IT_TS][TS_IPI] <> "R"
			MaFisBsIcm(nItem)
			MaFisVICMS(nItem)
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		EndIf
		MaFisVTot(nItem)
		MaFisVComp(nItem)
		MaFisBSSol(nItem)
		MaFisVSol(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					ZfDedBCofPis(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem) //Tratamento realizado para que não seja chamado dentro das funções MaFisPROT e MaFisFEEF e não comprometa a performance
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		//Recalcula o PIS/COFINS e o CPRB para somar o valor do crédito presumido, caso o sistema esteja parametrizado para isso
		CrdPresAdd( nItem,  aNfItem[nItem][IT_LIVRO][LF_CRDPRES] > 0, fisGetParam('MV_CPRBNF',.F.) .And. fisGetParam('MV_CRDPRCP',.F.), fisGetParam('MV_CRDPRPC',.F.),;
							aNfItem[nItem][IT_VALPIS], aNfItem[nItem][IT_VALPS2], aNfItem[nItem][IT_VALPS3],;
							aNfItem[nItem][IT_VALCOF], aNfItem[nItem][IT_VALCF2], aNfItem[nItem][IT_VALCF3] )
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_BASESOL"
		MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		MaFisVSol(nItem,cCampo)
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
		EndIf
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_ALIQSOL"
		MaFisVSol(nItem)
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_VALSOL"
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
		EndIf
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisTPDP(nItem)
	Case cCampo == "IT_MARGEM"
		MaFisBsSol(nItem)
		MaFisVSol(nItem)
		MaFisVTot(nItem)
		MaFisCOFINS(nItem,"CF2")
		MaFisPIS(nItem,"PS2")
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_ICMFRETE"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisBSICM(nItem)
				MaFisBSSOL(nItem)
				MaFisVSOL(nItem)
				MaFisLF(nItem)
				MaFisPROT(nItem)
				MaFisFEEF(nItem)
				MaFisLF(nItem)
			Endif
		Endif
	Case cCampo == "IT_ALIQCMP"
		MaFisVTot(nItem)
		MaFisVComp(nItem)
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_VALCMP"
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_VALICM"
		MaFisVTot(nItem)
		MaFisVComp(nItem)
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
			MaFisCOFINS(nItem,"CF2")
		    MaFisPIS(nItem,"PS2")
			MaFisVICMS(nItem, .T.)
			If cPaisLoc == "BRA"
				MaFisII(nItem, cCampo)
			EndIf
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_PERFUN"
		MaFisRURAL(nItem)
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_FUNRURAL"
		MaFisRURAL(nItem,"BSE|ALQ")
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_VALFDS"
		MaFisVSul(nItem)
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_BSSENAR"
		MaFisVSul(nItem)
		MaFisSENAR(nItem)
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_VLSENAR"
		MaFisVSul(nItem)
		MaFisSENAR(nItem)
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case cCampo == "IT_ESTCRED"
		MaFisLF(nItem)
	Case cCampo == "IT_FRETE" .Or. cCampo == "IT_VLR_FRT"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaAliqSoli(nItem)
			Endif
			MaExcecao(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaMargem(nItem)
				MaFisIPI(nItem,"BSE|VLR")
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
				MaFisVDescZF(nItem)
				MaFisVTot(nItem)
				MaFisVComp(nItem)
				MaFisBSSOL(nItem)
				MaFisVSOL(nItem)
				If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
					MaFisCOFINS(nItem,"CF2")
					MaFisPIS(nItem,"PS2")
					If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
						MaFisIPI(nItem,"BSE|VLR")
						If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
							If aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2" .And. ChkProdNac(nItem)
								ZfCalcCofPis(nItem)
							EndIf
							MaFisBSICM(nItem,,.T.)
							MaFisVICMS(nItem)
							MaFisCPRB(nItem)
							If aNfItem[nItem][IT_DESCZF] == 0 .Or. !(!ChkProdNac(nItem) .And. aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2")
								ZfDedBCofPis(nItem)
							EndIf
							MaFisVTot(nItem)
							MaFisVComp(nItem)
						ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
							MaFisBSICM(nItem,,.T.)
							MaFisVICMS(nItem)
							MaFisVDescZF(nItem)
							MaFisPIS(nItem,"PS2")
							MaFisCOFINS(nItem,"CF2")
						EndIf
						MaFisBSSol(nItem)
						MaFisVSol(nItem)
						IF lMVRPCBIZF .And. !ChkProdNac(nItem)
				  			MaFisPIS(nItem,"PS2")
							MaFisCOFINS(nItem,"CF2")
						EndIf
					EndIf
				EndIf
			EndIf
			If !(fisGetParam('MV_DESCZF',.T.) .and. fisGetParam('MV_CPRBNF',.F.) .AND. fisGetParam('MV_DEDBPIS',"") == "D" .AND. fisGetParam('MV_DEDBCPR',"") == "D")
				MaFisCPRB(nItem)
			EndIf
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
			MaFisRURAL(nItem)
			MaFisTPDP(nItem)
			MaFisLF(nItem)
			MaFisPROT(nItem)
			MaFisFEEF(nItem)
			MaFisLF(nItem)
			MaFisFECP(nItem)
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			If aNFItem[nItem][IT_TS][TS_DESCOND] == "1" .And. aNfItem[nItem][IT_DESCZF] == (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF])
				MaFisVDescZF(nItem)
			EndIf
			If aNfItem[nItem][IT_DESCZF] == 0 .Or. !(!ChkProdNac(nItem) .And. aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2")
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
			EndIf
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					If aNfItem[nItem][IT_DESCZF] == 0 .Or. !(!ChkProdNac(nItem) .And. aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2")
						ZfDedBCofPis(nItem)
					EndIf
					If aNFItem[nItem][IT_TS][TS_DESCOND] == "1" .Or. !ChkProdNac(nItem)
						ZfCalcCofPis(nItem)
					EndIf
					MaFisVTot(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
				IF lMVRPCBIZF .And. !ChkProdNac(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				If lProtege	.Or. lFeef
					MaFisLF(nItem)
					If lProtege
						MaFisPROT(nItem)
					EndIf
					If lFeef
						MaFisFEEF(nItem)
					EndIf
				EndIf
				MaFisLF(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		If cPaisLoc == "BRA"
			MaFisINSS(nItem,"BSE|VLR")
			MaFisSENAR(nItem)
			MaFisIR(nItem,"BSE|VLR",dVencReal)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIf
			MaFisCSLL(nItem)
			MaFisSEST(nItem)
			MaFisINSP(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisISSBi(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
			// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
			If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
				// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
				// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
				// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
				If aNFItem[nItem][IT_VALICM] == 0
					MaFisBSICM(nItem,,,,,.F.)
					MaFisVICMS(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)
					MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
					MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
				EndIf
			EndIf
			MaFisVTot(nItem)
		Endif

		If lProtege	.Or. lFeef
			MaFisLF(nItem)
			If lProtege
				MaFisPROT(nItem)
			EndIf
			If lFeef
				MaFisFEEF(nItem)
			EndIf
		EndIf
		
		MaItArred(nItem)
		//Recalcula o PIS/COFINS e o CPRB para somar o valor do crédito presumido, caso o sistema esteja parametrizado para isso
		CrdPresAdd( nItem,  aNfItem[nItem][IT_LIVRO][LF_CRDPRES] > 0, fisGetParam('MV_CPRBNF',.F.) .And. fisGetParam('MV_CRDPRCP',.F.), fisGetParam('MV_CRDPRPC',.F.),;
							aNfItem[nItem][IT_VALPIS], aNfItem[nItem][IT_VALPS2], aNfItem[nItem][IT_VALPS3],;
							aNfItem[nItem][IT_VALCOF], aNfItem[nItem][IT_VALCF2], aNfItem[nItem][IT_VALCF3] ) 
		MaFisLF(nItem)
	Case cCampo == "IT_DESPESA" .Or. cCampo == "IT_AFRMIMP"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaAliqSoli(nItem)
			Endif
			MaExcecao(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaMargem(nItem)
				If aNFItem[nItem][IT_TS][TS_DESPIPI] <> "N"
					MaFisIPI(nItem,"BSE|VLR")
				EndIf
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
				MaFisVDescZF(nItem)
				MaFisVTot(nItem)
				MaFisVComp(nItem)
				MaFisBSSOL(nItem)
				MaFisVSOL(nItem)
				If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
					MaFisCOFINS(nItem,"CF2")
					MaFisPIS(nItem,"PS2")
					If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
						MaFisIPI(nItem,"BSE|VLR")
						If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
							If aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2" .And. ChkProdNac(nItem)
								ZfCalcCofPis(nItem)
							EndIf
							MaFisBSICM(nItem,,.T.)
							MaFisVICMS(nItem)
							MaFisCPRB(nItem)
							If aNfItem[nItem][IT_DESCZF] == 0 .Or. !(!ChkProdNac(nItem) .And. aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2")
								ZfDedBCofPis(nItem)
							EndIf
							MaFisVTot(nItem)
							MaFisVComp(nItem)
						ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
							MaFisBSICM(nItem,,.T.)
							MaFisVICMS(nItem)
							MaFisVDescZF(nItem)
							MaFisPIS(nItem,"PS2")
							MaFisCOFINS(nItem,"CF2")
						EndIf
						MaFisBSSol(nItem)
						MaFisVSol(nItem)
						If lMVRPCBIZF .And. !ChkProdNac(nItem)
							MaFisPIS(nItem,"PS2")
							MaFisCOFINS(nItem,"CF2")
						EndIf						
					EndIf
				EndIf
			EndIf
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				If aNFItem[nItem][IT_TS][TS_DESCOND] == "1" .And. aNfItem[nItem][IT_DESCZF] == (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF])
					MaFisVDescZF(nItem)
				EndIf
				If aNfItem[nItem][IT_DESCZF] == 0 .Or. !(!ChkProdNac(nItem) .And. aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2")
					MaFisCOFINS(nItem,"CF2")
					MaFisPIS(nItem,"PS2")
				EndIf
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						If aNfItem[nItem][IT_DESCZF] == 0 .Or. !(!ChkProdNac(nItem) .And. aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2")
							ZfDedBCofPis(nItem)
						EndIf
						If aNFItem[nItem][IT_TS][TS_DESCOND] == "1" .Or. !ChkProdNac(nItem)
							ZfCalcCofPis(nItem)
						EndIf
						MaFisVTot(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
					If lMVRPCBIZF .And. !ChkProdNac(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf					
				EndIf
			EndIf
			If !(fisGetParam('MV_DESCZF',.T.) .and. fisGetParam('MV_CPRBNF',.F.) .AND. fisGetParam('MV_DEDBPIS',"") == "D" .AND. fisGetParam('MV_DEDBCPR',) == "D")
				MaFisCPRB(nItem)
			EndIf
			MaFisLF(nItem)
			MaFisPROT(nItem)
			MaFisFEEF(nItem)
			MaFisLF(nItem)
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		MaFisVTot(nItem)
		If cPaisLoc == "BRA"
			MaFisINSS(nItem,"BSE|VLR")
			MaFisSENAR(nItem)
			MaFisIR(nItem,"BSE|VLR",dVencReal)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIf
			MaFisCSLL(nItem)
			MaFisSEST(nItem)
			MaFisINSP(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
			// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
			If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
				// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
				// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
				// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
				If aNFItem[nItem][IT_VALICM] == 0
					MaFisBSICM(nItem,,,,,.F.)
					MaFisVICMS(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)
					MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
					MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
				EndIf
			EndIf
			MaFisVTot(nItem)
			MaFisRURAL(nItem)
		Endif
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaFisLF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			//Recalcula o PIS/COFINS e o CPRB para somar o valor do crédito presumido, caso o sistema esteja parametrizado para isso
			CrdPresAdd( nItem,  aNfItem[nItem][IT_LIVRO][LF_CRDPRES] > 0, fisGetParam('MV_CPRBNF',.F.) .And. fisGetParam('MV_CRDPRCP',.F.), fisGetParam('MV_CRDPRPC',.F.),;
								aNfItem[nItem][IT_VALPIS], aNfItem[nItem][IT_VALPS2], aNfItem[nItem][IT_VALPS3],;
								aNfItem[nItem][IT_VALCOF], aNfItem[nItem][IT_VALCF2], aNfItem[nItem][IT_VALCF3] )
			MaFisLF(nItem)
		EndIf
	Case cCampo == "IT_SEGURO"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaAliqSoli(nItem)
			Endif
			MaExcecao(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaMargem(nItem)
				MaFisIPI(nItem,"BSE|VLR")
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
				MaFisVDescZF(nItem)
				MaFisVTot(nItem)
				MaFisVComp(nItem)
				MaFisBSSOL(nItem)
				MaFisVSOL(nItem)
				If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
					MaFisCOFINS(nItem,"CF2")
					MaFisPIS(nItem,"PS2")
					If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
						MaFisIPI(nItem,"BSE|VLR")
						If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
							If aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2" .And. ChkProdNac(nItem)
								ZfCalcCofPis(nItem)
							EndIf
							MaFisBSICM(nItem,,.T.)
							MaFisVICMS(nItem)
							MaFisCPRB(nItem)
							If aNfItem[nItem][IT_DESCZF] == 0 .Or. !(!ChkProdNac(nItem) .And. aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2")
								ZfDedBCofPis(nItem)
							EndIf
							MaFisVTot(nItem)
							MaFisVComp(nItem)
						ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
							MaFisBSICM(nItem,,.T.)
							MaFisVICMS(nItem)
							MaFisVDescZF(nItem)
							MaFisPIS(nItem,"PS2")
							MaFisCOFINS(nItem,"CF2")
						EndIf
						MaFisBSSol(nItem)
						MaFisVSol(nItem)
						If lMVRPCBIZF .And. !ChkProdNac(nItem)
							MaFisPIS(nItem,"PS2")
							MaFisCOFINS(nItem,"CF2")
						EndIf						
					EndIf
				EndIf
			Endif
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				If aNFItem[nItem][IT_TS][TS_DESCOND] == "1" .And. aNfItem[nItem][IT_DESCZF] == (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF])
					MaFisVDescZF(nItem)
				EndIf
				If aNfItem[nItem][IT_DESCZF] == 0 .Or. !(!ChkProdNac(nItem) .And. aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2")
					MaFisCOFINS(nItem,"CF2")
					MaFisPIS(nItem,"PS2")
				EndIf
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)					
						If aNfItem[nItem][IT_DESCZF] == 0 .Or. !(!ChkProdNac(nItem) .And. aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2")
							ZfDedBCofPis(nItem)
						EndIf
						If aNFItem[nItem][IT_TS][TS_DESCOND] == "1" .Or. !ChkProdNac(nItem)
							ZfCalcCofPis(nItem)
						EndIf
						MaFisVTot(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
					If lMVRPCBIZF .And. !ChkProdNac(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf					
				EndIf
			EndIf
			If !(fisGetParam('MV_DESCZF',.T.) .and. fisGetParam('MV_CPRBNF',.F.) .AND. fisGetParam('MV_DEDBPIS',"") == "D" .AND. fisGetParam('MV_DEDBCPR',"") == "D")
				MaFisCPRB(nItem)
			EndIf
			MaFisLF(nItem)
			MaFisPROT(nItem)
			MaFisFEEF(nItem)
			MaFisLF(nItem)
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		MaFisVTot(nItem)
		If cPaisLoc == "BRA"
			MaFisINSS(nItem,"BSE|VLR")
			MaFisSENAR(nItem)
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
			MaFisIR(nItem,"BSE|VLR",dVencReal)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIf
			MaFisCSLL(nItem)
			MaFisSEST(nItem)
			MaFisINSP(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
			// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
			If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
				// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
				// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
				// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
				If aNFItem[nItem][IT_VALICM] == 0
					MaFisBSICM(nItem,,,,,.F.)
					MaFisVICMS(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)
					MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
					MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
				EndIf
			EndIf
			MaFisVTot(nItem)
			MaFisRURAL(nItem)
		Endif
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaFisLF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			//Recalcula o PIS/COFINS e o CPRB para somar o valor do crédito presumido, caso o sistema esteja parametrizado para isso
			CrdPresAdd( nItem,  aNfItem[nItem][IT_LIVRO][LF_CRDPRES] > 0, fisGetParam('MV_CPRBNF',.F.) .And. fisGetParam('MV_CRDPRCP',.F.), fisGetParam('MV_CRDPRPC',.F.),;
								aNfItem[nItem][IT_VALPIS], aNfItem[nItem][IT_VALPS2], aNfItem[nItem][IT_VALPS3],;
								aNfItem[nItem][IT_VALCOF], aNfItem[nItem][IT_VALCF2], aNfItem[nItem][IT_VALCF3] )
			MaFisLF(nItem)
		EndIf
	Case cCampo == "IT_REDIR"
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_BASEIRR"
		MaFisIR(nItem,"ALQ|VLR",dVencReal)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_VALIRR"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_ALIQIRR"
		MaFisIR(nItem,"VLR",dVencReal)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_BASESES"
		MaFisSEST(nItem, "VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_VALSES"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_ALIQSES"
		MaFisSEST(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_REDINSS"
		MaFisINSS(nItem,"BSE|VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_BASEINS"
		MaFisINSS(nItem,"VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_ABVLINSS"
		MaFisINSS(nItem,"BSE|VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_ABSCINS"
		MaFisINSS(nItem,"BSE|VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)

	Case cPaisLoc == "BRA" .And. ( cCampo == "IT_BSCP15" .Or. cCampo == "IT_BSCP20" .Or. cCampo == "IT_BSCP25" ) //Valor Base INSS Servico 15, 20 e 25 anos.
		MaFisINSS(nItem,"VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cPaisLoc == "BRA" .And. ( cCampo == "IT_SECP15" .Or. cCampo == "IT_SECP20" .Or. cCampo == "IT_SECP25" ) //Valor do serviço (usado como base) para contribuição previdenciária (INSS) especial em 15, 20 e 25 anos.
		MaFisINSS(nItem)
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cPaisLoc == "BRA" .And. ( cCampo == "IT_ALCP15" .Or. cCampo == "IT_ALCP20" .Or. cCampo == "IT_ALCP25" ) //Alíquota para contribuição previdenciária (INSS) especial em 15, 20 e 25 anos.
		MaFisINSS(nItem,"VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)

	Case cPaisLoc == "BRA" .And. ( cCampo == "IT_VLCP15" .Or. cCampo == "IT_VLCP20" .Or. cCampo == "IT_VLCP25" ) //Valor da contribuição previdenciária (INSS) especial em 15, 20 e 25 anos.
		MaFisLF(nItem)

	Case cCampo == "IT_ABVLISS"
		MaFisISS(nItem)
		MaFisISSBi(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_ABMATISS"
		MaFisISS(nItem)
		MaFisISSBi(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_VALINS"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_ALIQINS"
		MaFisINSS(nItem,"VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_VALISS"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_REDISS"
		MaFisISS(nItem)
		MaFisISSBi(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_BASEISS"
		MaFisISS(nItem,"VLR")
		MaFisISSBi(nItem,"VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_ALIQISS"
		MaFisISS(nItem,"VLR")
		MaFisPIS(nItem,"PS2")
		MaFisCOFINS(nItem,"CF2")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_BASECPM"
		MaFisISSBi(nItem,"VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_ALQCPM"
		MaFisISSBi(nItem,"VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_CODISS"
		MaFisISS(nItem,"COD")
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisIR(nItem,,dVencReal)
		// Se utilizar CE1 (MV_ISSXMUN) ou tiver apuração do simples nacional
		// recalcular aliq. e valor pois um cod. diferente pode resultar em uma
		// aliquota diferente conforme a regra enquadrada.
		If fisGetParam('MV_ISSXMUN',.F.) .Or. aNfCab[NF_USAALIQSN]
			MaFisISS(nItem,"ALQ|VLR")
		EndIf
		MaFisISSBi(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_BASECID" .Or. cCampo == "IT_ALQCIDE" 
		MafisCide(nItem,"BSE|ALQ")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_VALCIDE"
		MafisCide(nItem,"VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_CFPS"
		MaFisLF(nItem)
	Case cCampo == "IT_RGESPST"
		MaFisLF(nItem)
	Case cCampo == "IT_BASECOF"
		MaFisCOFINS(nItem,"COF|CF2","ALQ|VLR")
		MaItArred(nItem)
	Case cCampo == "IT_ALIQCOF"
		MaFisCOFINS(nItem,"COF|CF2","VLR")
		MaItArred(nItem)
	Case cCampo == "IT_BASEPIS"
		MaFisPIS(nItem,"PIS|PS2","ALQ|VLR")
		MaItArred(nItem)
	Case cCampo == "IT_ALIQPIS"
		MaFisPIS(nItem,"PIS|PS2","VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_AVLINSS"
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_BASEPS2"
		MaFisPIS(nItem,"PIS|PS2","ALQ|VLR")
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisCPRB(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_BASECF2"
		MaFisCOFINS(nItem,"COF|CF2","ALQ|VLR")
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_ALIQPS2"
		MaFisPIS(nItem,"PIS|PS2","VLR")
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_ALIQCF2"
		MaFisCOFINS(nItem,"COF|CF2","VLR")
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_VALPS2"
		MaItArred(nItem)
		MaFisVTot(nItem)
	   	MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		If cPaisLoc == "BRA"
			If aNFItem[nItem][IT_TS][TS_AGRPIS] == 'P' .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"13" .And.;
			 aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3"//Se agregar PIS importação na Base de ICMS, refaz a Base e valor de ICMS com valor de PIS atualizado
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MafisII(nItem, cCampo)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_VALCF2"
		MaItArred(nItem)
		MaFisVTot(nItem)
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		If cPaisLoc == "BRA"
			If aNFItem[nItem][IT_TS][TS_AGRCOF] == 'C' .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"23" .And. ;
			aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3" //Se agregar COFINS importação na Base de ICMS, refaz a Base e valor de ICMS com valor de COFINS atualizado
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MafisII(nItem, cCampo)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_BASECSL"
		MaFisCSLL(nItem,"ALQ|VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_ALIQCSL"
		MaFisCSLL(nItem,"VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_VALCSL"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_VALCOF"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_VALPIS"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_DESCONTO" .Or. cCampo == "IT_DESCTOT"
		If cPaisLoc == "BRA"
			MaAliqSoli(nItem)
			MaExcecao(nItem)
			MaMargem(nItem)
			MaFisIPI(nItem,"BSE|VLR")
			MaFisBSICM(nItem,,aNFItem[nItem][IT_TS][TS_COFDSZF] == "1" .AND. aNFItem[nItem][IT_TS][TS_PISDSZF] == "1" .And. lMVRPCBIZF)
			MaFisVICMS(nItem)
			MaFisRURAL(nItem)			
			MaFisTPDP(nItem)
			If !( aNFItem[nItem][IT_TS][TS_TPIPI]=="B" .Or. (fisGetParam('MV_IPIBRUT','')=="S" .And. aNFItem[nItem][IT_TS][TS_TPIPI] ==" ") ) .And. ( aNFItem[nItem][IT_TS][TS_AGREG]=="D" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="R" )
				MaFisIPI(nItem,"BSE|VLR")
			EndIf
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
			MaFisVTot(nItem)
			MaFisSENAR(nItem)
			MaFisVTot(nItem)
			MaFisVComp(nItem)
			MaFisBSSOL(nItem)
			MaFisVSOL(nItem)
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
		Else
			// Indica se o preco unitario sera arredondado em 0 casas decimais ou nao. Se .T. respeita MV_CENT (Apenas Chile).
			If (aNfCab[NF_OPERNF] =='S' .Or. (aNFitem[nItem][IT_TIPONF ]$"DB" .And. Alltrim(cFunName) $ "MATA465N|MATA462DN|" .And. cPaisLoc $ "MEX|PAR|PER|VEN|COL|EQU" .And. cCampo<>"IT_TES")) .And. fisGetParam('MV_DESCSAI',) == "1"
				If cPaisLoc == "CHI" .And. fisGetParam('MV_PRCDEC',.F.)
					aNFitem[nItem][IT_VALMERC] := Round(aNFitem[nItem][IT_VALMERC] - (aNFitem[nItem][IT_DESCONTO]+aNFitem[nItem][IT_DESCTOT]),MsDecimais(aNFCab[NF_MOEDA]))
				Else
					aNFitem[nItem][IT_VALMERC] -= (aNFitem[nItem][IT_DESCONTO]+aNFitem[nItem][IT_DESCTOT])
					If cPaisLoc == "RUS"
						aNFitem[nItem][IT_VALMERC_C1] -= xMoeda((aNFitem[nItem][IT_DESCONTO]+aNFitem[nItem][IT_DESCTOT]),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
					EndIf
				Endif
				aNFitem[nItem][IT_PRCUNI] := aNFitem[nItem][IT_VALMERC] / Max( aNFitem[nItem][IT_QUANT] , 1 )
			Endif
			MaFisImpIV(nItem,cCampo)
		Endif
		MaFisNameIV(,nItem)

		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				//Caso haja PIS/COFINS desonerado para ZFM, chamo a MaFisVDescZF para evitar o cálculo incorreto das bases de ICMS, PIS e COFINS.
				//Isso é necessário pois na pilha de chamada da Planilha Financeira o NF_DESCONTO é o último a ser informado, portanto o valor de PIS e COFINS desonerado já terá sido calculado e isso refletirá no cálcuçlo dos demais impostos.
				If aNfItem[nItem][IT_DESCZF] <> 0 .And. !(aNFItem[nItem][IT_TS][TS_COFDSZF] == "1" .AND. aNFItem[nItem][IT_TS][TS_PISDSZF] == "1" .And. lMVRPCBIZF)
					MaFisVDescZF(nItem)
				EndIf
				MaFisPIS(nItem,"PS2")
				MaFisCOFINS(nItem,"CF2")
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						If aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2" .And. ChkProdNac(nItem)
							ZfCalcCofPis(nItem)
						EndIf
						MaFisBSICM(nItem,,.T. )
						MaFisVICMS(nItem)
						MaFisCPRB(nItem)
						If aNfItem[nItem][IT_DESCZF] == 0 .Or. !(!ChkProdNac(nItem) .And. aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2")
							ZfDedBCofPis(nItem)
						EndIf
						If aNFItem[nItem][IT_TS][TS_DESCOND] == "1" .Or. !ChkProdNac(nItem)
							ZfCalcCofPis(nItem)
						EndIf
						MaFisVTot(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
					If lMVRPCBIZF .And. !ChkProdNac(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf					
				EndIf
			EndIf
			If !(fisGetParam('MV_DESCZF',.T.) .and. fisGetParam('MV_CPRBNF',.F.) .AND. fisGetParam('MV_DEDBPIS',"") == "D" .AND. fisGetParam('MV_DEDBCPR',"") == "D")
				MaFisCPRB(nItem)
			EndIf
		Endif
		MaFisVTot(nItem)
		If cPaisLoc == "BRA"
			MaFisINSS(nItem,"BSE|VLR|RED")
			MaFisIR(nItem,,dVencReal)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisPIS(nItem,"PIS")
				MaFisCOFINS(nItem,"COF")
			EndIf
			MaFisCSLL(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisISSBi(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
			// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
			If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
				// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
				// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
				// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
				If aNFItem[nItem][IT_VALICM] == 0
					MaFisBSICM(nItem,,,,,.F.)
					MaFisVICMS(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)
					MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
					MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
				EndIf
			EndIf
			MaFisVTot(nItem)
			MaFisINSP(nItem)
		Endif
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaFisLF(nItem)
		MaItArred(nItem)
		MaFisSENAR(nItem) //bruce
		If cPaisLoc == "BRA"
			//Recalcula o PIS/COFINS e o CPRB para somar o valor do crédito presumido, caso o sistema esteja parametrizado para isso
			CrdPresAdd( nItem,  aNfItem[nItem][IT_LIVRO][LF_CRDPRES] > 0, fisGetParam('MV_CPRBNF',.F.) .And. fisGetParam('MV_CRDPRCP',.F.), fisGetParam('MV_CRDPRPC',.F.),;
								aNfItem[nItem][IT_VALPIS], aNfItem[nItem][IT_VALPS2], aNfItem[nItem][IT_VALPS3],;
								aNfItem[nItem][IT_VALCOF], aNfItem[nItem][IT_VALCF2], aNfItem[nItem][IT_VALCF3] )
			MaFisLF(nItem)
		EndIf
	Case  cPaisLoc == "PER" .and. fisExtCmp('12.1.2310', .T.,'SF1','F1_ADIANT') .and. cCampo == "IT_ADIANTTOT"
		MaFisImpIV(nItem,cCampo)
		MaFisNameIV(,nItem)
		MaFisVTot(nItem)
		MaItArred(nItem)
	Case Substr(cCampo,1,9) == "IT_BASEIV" .AND. IIf( cPaisLoc == "RUS",!("_C1" $ cCampo), .T.)
		MaFisVLIV(Ascan(aNFItem[nItem][IT_TS][TS_SFC],{|x| Substr(x[10],10,1) == Substr(cCampo,10,1)}),nItem)
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Substr(cCampo,1,8) == "IT_VALIV" .AND. IIf( cPaisLoc == "RUS", !("_C1" $ cCampo), .T.)
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_AUTONOMO"
		If Empty( aNFItem[nItem,IT_ALIQICM] )
			MaAliqIcms(nItem)
		EndIf
		MaMargem(nItem)
		MaFisBSSOL(nItem)
		MaFisVSol(nItem)
		MaFisICA(nItem)
		MaFisTST(nItem)
		MaFisVTot(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_BASEICA"
		MaFisICA(nItem)
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_VALICA"
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_BASETST"
		MaFisTST(nItem,"ALQ|VLR")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_VALTST"
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_ALIQTST"
		MaFisTST(nItem,"BSE|VLR")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_FUNRURAL"
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "NF_NATUREZA"
		If cPaisLoc == "BRA"
			MaFisISS(nItem,"ALQ")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisPIS(nItem,"PS2")
				MaFisCOFINS(nItem,"CF2")
				MaFisSEST(nItem)
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						ZfDedBCofPis(nItem)
						MaFisVTot(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
				EndIf
			EndIf
			MaFisVTot(nItem)
			MaFisINSS(nItem)
			MaFisIR(nItem,,dVencReal)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIf
			MaFisCSLL(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisISSBi(nItem)
			MaFisVTot(nItem)
			MaFisINSP(nItem)
			MaFisPIS(nItem,"PS3")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				//Caso classificação a posteriore de nota fiscal de importação, neste ponto o MafisII necessita que a referencia NF_BICMORI esteja valorada
				// por isso se faz necessária a chamada das rotinas MaFisBSICM e MaFisVICMS
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				If	aNfCab[NF_SUFRAMA]
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisII(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisVComp(nItem)
		EndIf
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaFisLF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			//Recalcula o PIS/COFINS e o CPRB para somar o valor do crédito presumido, caso o sistema esteja parametrizado para isso
			CrdPresAdd( nItem,  aNfItem[nItem][IT_LIVRO][LF_CRDPRES] > 0, fisGetParam('MV_CPRBNF',.F.) .And. fisGetParam('MV_CRDPRCP',.F.), fisGetParam('MV_CRDPRPC',.F.),;
								aNfItem[nItem][IT_VALPIS], aNfItem[nItem][IT_VALPS2], aNfItem[nItem][IT_VALPS3],;
								aNfItem[nItem][IT_VALCOF], aNfItem[nItem][IT_VALCF2], aNfItem[nItem][IT_VALCF3] )
			MaFisLF(nItem)
		Endif
		MaFisCIDE(nItem)
		MaFisFMPEQ(nItem)
	Case cCampo == "IT_TES"

		// P/ Brasil a MaFisCFO eh chamada antes da MaExcecao
		// pois pode acontecer das UF's de origem/destino serem
		// alteradas (venda presencial). Entao soh posso enquadrar
		// a excecao depois desta funcao.
		If cPaisLoc == "BRA"
			MaFisCFO(nItem)
			MaExcecao( nItem , cCampo )
			MaFisPreCalc(nItem,cCampo)
		Else
			MaFisPreCalc(nItem,cCampo)
			If cPaisLoc == "RUS"
				MaFisCFO(nItem, MaFisRet(nItem,"IT_CF"))
			Else
				MaFisCFO(nItem)
			EndIf
		EndIf

		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
				MaFisBSSOL(nItem)
				MaFisFECP( nItem , "IT_TES" )
			EndIf
			MaFisTPDP(nItem)
			If (aNFItem[nItem][IT_TS][TS_AGREG]$"B") .And. fisGetParam('MV_ESTADO','') $ fisGetParam('MV_TIPOB',"RS/SP/") // FNC 000000193742010 SIGAEIC Protocolo ICMS 99, DE 14 DE DEZEMBRO DE 2007, para que as movimentações geradas pelo EIC, ao utilizar no TES o campo Agrega valor como B que calcule.o ICMS ST.
				MaMargem(nItem)
				MaFisBSSol(nItem)
				MaAliqSoli(nItem)
				MaFisVSol(nItem)
			EndIf
			If ( ( Empty(aNFItem[nItem,IT_ALIQICM] ) .Or. aNFItem[nItem][IT_TS][TS_ICM]=="N" .Or. (aNFCab[NF_SIMPNAC] == "1" .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F")) .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" ) )
				MaAliqIcms(nItem)
			EndIf
			If (Empty( aNFItem[nItem,IT_ALIQIPI] ) .Or. aNFItem[nItem][IT_TS][TS_IPI]=="N") .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
				MaFisIPI(nItem,"ALQ")
			EndIf
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" ) .Or. ((!Empty(aNFItem[nItem][IT_TS][TS_ISEFECP]) .And. !Empty(aNFItem[nItem][IT_TS][TS_FECPANT]) .And. aNFItem[nItem][IT_TS][TS_ISEFECP]<>aNFItem[nItem][IT_TS][TS_FECPANT]))
				MaALIQCMP(nItem)
				MaAliqSoli(nItem)
			Endif
			MaFisISS(nItem,"ALQ")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaMargem(nItem)
				MaFisIPI(nItem,"BSE|VLR")
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
				MaFisVTot(nItem)
				MaFisVComp(nItem)
				if fisGetParam('MV_SOMAICM',.F.)
					MaFisBSICM(nItem)
					MaFisVICMS(nItem)
					MaFisIPI(nItem,"BSE|VLR")
				endif
			Else
				MaFisIPI(nItem,"")
			Endif
			MaFisVDescZF(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
				MaFisBSSOL(nItem)
				MaALIQCMP(nItem)
				MaFisVSOL(nItem)
				MaFisICA(nItem)
				MaFisTST(nItem)
			EndIf
			If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"CF2","ALQ")
				MaFisPIS(nItem,"PS2")
				MaFisCOFINS(nItem,"CF2")
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						ZfDedBCofPis(nItem)
						MaFisVTot(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
				Else
					If (aNFItem[nItem][IT_TS][TS_AGRPIS]=="P" .Or. aNFItem[nItem][IT_TS][TS_AGRCOF]=="C") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"
						MaFisBSICM(nItem)
						MaFisVICMS(nItem)
						MaFisBSSOL(nItem)
						MaFisVSOL(nItem)
					EndIf
				EndIf
			EndIf
			MaFisRURAL(nItem)
			MaFisVSul(nItem)
			MaFisSENAR(nItem)
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
			MaFisFFF(nItem)
			MaCodDecl(nItem)
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		MaFisNameIV(,nItem)
		If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisISS(nItem)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					ZfDedBCofPis(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)

				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		If cPaisLoc == "BRA"
			MaFisINSS(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
				MaFisIR(nItem,,dVencReal)
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIf
			MaFisCSLL(nItem)
			MaFisSEST(nItem)
			MaFisINSP(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisISSBi(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
			If aNFItem[nItem][IT_TS][TS_BCPCST] == "1" //Campo que indica se os valores de PIS/COFINS ST entram na base de ICMS-ST
				MaFisBSSOL(nItem)
				MaFisVSol(nItem)
			EndIf
			MaFisVTot(nItem)
			If aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1"
				MaFisCOFINS(nItem,"COF|CF2")
				MaFisPIS(nItem,"PIS|PS2")
				MaFisBsIcm(nItem)
				MaFisVICMS(nItem)
				MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
			Endif
			MaFisCPRB(nItem)
			// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
			If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
				// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
				// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
				// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
				If aNFItem[nItem][IT_VALICM] == 0
					MaFisBSICM(nItem,,,,,.F.)
					MaFisVICMS(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)
					MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
					MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
					MaFisVTot(nItem)
				EndIf
			EndIf
		Endif
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaFisLF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			MaFisAFRMM(nItem)
			//Recalcula o PIS/COFINS e o CPRB para somar o valor do crédito presumido, caso o sistema esteja parametrizado para isso
			CrdPresAdd( nItem,  aNfItem[nItem][IT_LIVRO][LF_CRDPRES] > 0, fisGetParam('MV_CPRBNF',.F.) .And. fisGetParam('MV_CRDPRCP',.F.), fisGetParam('MV_CRDPRPC',.F.),;
								aNfItem[nItem][IT_VALPIS], aNfItem[nItem][IT_VALPS2], aNfItem[nItem][IT_VALPS3],;
								aNfItem[nItem][IT_VALCOF], aNfItem[nItem][IT_VALCF2], aNfItem[nItem][IT_VALCF3] )
			MaFisLF(nItem)
		EndIf
		MafisCide(nItem)
		MaFisFMPEQ(nItem)
	Case cCampo == "IT_VALEMB"

		// P/ Brasil a MaFisCFO eh chamada antes da MaExcecao
		// pois pode acontecer das UF's de origem/destino serem
		// alteradas (venda presencial). Entao soh posso enquadrar
		// a excecao depois desta funcao.
		If cPaisLoc == "BRA"
			MaFisCFO(nItem)
			MaExcecao(nItem)
			MaFisPreCalc(nItem)
		Else
			MaFisPreCalc(nItem)
			MaFisCFO(nItem)
		Endif

		If cPaisLoc == "BRA"
			If Empty( aNFItem[nItem,IT_ALIQICM] ) .Or. aNFItem[nItem][IT_TS][TS_ICM]=="N"
				MaAliqIcms(nItem)
			EndIf
			If Empty( aNFItem[nItem,IT_ALIQIPI] ) .Or. aNFItem[nItem][IT_TS][TS_IPI]=="N"
				MaFisIPI(nItem,"ALQ")
			EndIf
			MaALIQCMP(nItem)
			MaAliqSoli(nItem)
			MaMargem(nItem)
			MaFisIPI(nItem,"BSE|VLR")
			MaFisBSICM(nItem)
			MaFisVICMS(nItem)
			MaFisTPDP(nItem)
			If !( aNFItem[nItem][IT_TS][TS_TPIPI]=="B" .Or. (fisGetParam('MV_IPIBRUT','')=="S" .And. aNFItem[nItem][IT_TS][TS_TPIPI] ==" ") ) .And. ( aNFItem[nItem][IT_TS][TS_AGREG]=="D" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="R" )
				MaFisIPI(nItem,"BSE|VLR")
			EndIf
		Endif
		MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		If cPaisLoc == "BRA"
			MaFisVTot(nItem)
			MaFisVComp(nItem)
			MaFisVDescZF(nItem)
			MaFisBSSOL(nItem)
			MaFisVSOL(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						ZfDedBCofPis(nItem)
						MaFisVTot(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
				EndIf
			EndIf
			MaFisICA(nItem)
			MaFisTST(nItem)
			MaFisRURAL(nItem)
			MaFisVSul(nItem)
			MaFisSENAR(nItem)
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		MaFisNameIV(,nItem)
		If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					ZfDedBCofPis(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		If cPaisLoc == "BRA"
			MaFisINSS(nItem)
			MaFisIR(nItem,,dVencReal)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIf
			MaFisCSLL(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			MaFisVTot(nItem)
			MaFisINSP(nItem)
		Endif
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaFisLF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			MaFisLF(nItem)
		Endif
	Case cCampo == "IT_DESCZF"
		MaFisBSSOL(nItem)
		MaFisVSOL(nItem)
		MaFisICA(nItem)
		MaFisTST(nItem)
		MaFisRURAL(nItem)
		MaFisVSul(nItem)
		MaFisSENAR(nItem)
		If cPaisLoc=="BRA"
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		MaFisNameIV(,nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisPIS(nItem,"PS2")
			MaFisCOFINS(nItem,"CF2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					ZfDedBCofPis(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR|RED")
		MaFisIR(nItem,,dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C")
			MaFisPIS(nItem,"PIS")
			MaFisCOFINS(nItem,"COF")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisISS(nItem)
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisINSP(nItem)
		MaFisVTot(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_BASEDUP"
		MaItArred(nItem)
	Case cCampo == "IT_VALII"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisIPI(nItem,"BSE|VLR")//alterada posição. Estava entre MaFisII e MaFIsVTot
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MaFisII(nItem)
				MaFisVTot(nItem)
				MaFisLF(nItem)
				MaFisPROT(nItem)
				MaFisFEEF(nItem)
				MaItArred(nItem)
				MaFisLF(nItem)
			EndIf
		EndIf
	Case cCampo == "IT_ALIQII"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MaFisII(nItem)
				MaFisIPI(nItem,"BSE|VLR")
				MaFisVTot(nItem)
				MaFisLF(nItem)
				MaFisPROT(nItem)
				MaFisFEEF(nItem)
				MaItArred(nItem)
				MaFisLF(nItem)
			EndIf
		EndIf
	Case cCampo == "IT_CONCEPT"
		If cPaisLoc=="EQU" .or. cPaisLoc=="VEN"
			MaFisPreCalc(nItem)
			MaFisCFO(nItem)
			MaFisImpIV(nItem,cCampo)
			MaFisNameIV(,nItem)
			MaFisVTot(nItem)
			MaItArred(nItem)
		Endif
	Case cCampo == "IT_BASEPS3".Or. cCampo =="IT_VALPS3" .Or. cCampo == "IT_BASECF3" .Or. cCampo =="IT_VALCF3"
		If cPaisLoc=="BRA"
			MaFisVTot(nItem)
			MaItArred(nItem)
			MaFisLF(nItem)
		Endif
	Case cCampo == "IT_VALCMAJ"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem, "IT_VALCMAJ")
				MaFisVTot(nItem)
				MaItArred(nItem)
				MaFisLF(nItem)
			EndIf
		EndIf
	Case cCampo == "IT_TRIBMU"
		MaFisLF(nItem)
	Case cCampo == "IT_PRCMEDP"
		If	cPaisLoc == "BRA"
			MaFisBSSol(nItem)
			MaFisVSol(nItem)
			MaFisVTot(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
			EndIf
			MaFisINSS(nItem,"BSE|VLR")
			MaFisIR(nItem,"BSE|VLR",dVencReal)
			MaFisINSP(nItem)
			MaFisLF(nItem)
			MaFisPROT(nItem)
			MaFisFEEF(nItem)
			MaFisLF(nItem)
			MaItArred(nItem)
			MaFisLF(nItem)
			MaFisSEST(nItem)
		EndIf
	Case (cCampo == "IT_VALPEDG")
		MaFisBSICM(nItem,,.T.)
		MaFisVICMS(nItem)
		MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		MaFisVTot(nItem)
		MaFisVComp(nItem)
		MaFisBSSol(nItem)
		MaFisVSol(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
		EndIf
		// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
		If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
			// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
			// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
			// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
			If aNFItem[nItem][IT_VALICM] == 0
				MaFisBSICM(nItem,,,,,.F.)
				MaFisVICMS(nItem)
				MaFisVTot(nItem)
				MaFisVComp(nItem)
				MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
				MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case (cCampo == "IT_GRPCST")
		MaFisIPI(nItem,"CST")
	Case cCampo == "IT_BASECID"
		MafisCide(nItem,"BSE")
	Case cCampo == "IT_VALCIDE"
		MafisCide(nItem,"VLR")
	Case (cCampo == "IT_ALFCCMP"  .Or.;
		 cCampo == "IT_VFCPDIF"  .Or.;
		 cCampo =="IT_ALIQFECP" .Or.;
		 cCampo =="IT_VALFECP"  .Or.;
		 cCampo =="IT_BASEDES"  .Or.;
		 cCampo =="IT_VFECPST"  .Or.;
		 cCampo =="IT_DIFAL")
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
		EndIf
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_VALINP"
		MaFisINSP(nItem, "BSE|ALQ")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_BASEINP"
		MaFisINSP(nItem, "VLR|ALQ")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_TRIBGEN"
		//Obrigatoriamente precisa especificar o tributo e a referência
		IF Len(aTrbGen) >= 2 .AND. !Empty(aTrbGen[TG_SIGLA]) .And. !Empty(aTrbGen[TG_REFERENCIA])

			//Obtem a lista dos tributos genéricos com ID de tributo legado após de refazer os cálculos
			aTribLegA	:= Iif(aNfCab[NF_CHKTRIBLEG] , ListTLegTG(aNFItem, nItem),{})

			If aTrbGen[TG_REFERENCIA] $ "TG_IT_BASE/TG_IT_ALIQUOTA" //Se alterou a base ou alíquota recalculará o valor
				xFisTrbGen(@aNfCab, @aNfItem, nItem, "IT_TRIBGEN", "VLR", aTrbGen[TG_SIGLA], aPos, aDic, Len(aTGITRef),aHmFor,aDepTrib, aDepVlOrig,aFunc, aUltPesqF2D)
				MaItArred(nItem, { "TG_IT_VALOR" } )
			
				IF fisExtTab('12.1.2310', .T., 'CJ2')
					//Função que verifica se foi alterado o total ou a base da duplicata para refazer os tributos dependentes das referências
					xRefTotLf(aNfCab, aNfItem, nItem, aPos, aDic, aTGITRef, aHmFor, aDepTrib, aDepVlOrig, aFunc, aUltPesqF2D, dVencReal)
				Endif

			EndIF		

			//Tratamento somente para situações com fórmulas
			If Len(aHmFor) > 0
				//Aqui chamarei a função para recalcular os tributos depentendes
				xFisTrbGen(@aNfCab, @aNfItem, nItem, "DEP", aTrbGen[TG_REFERENCIA], aTrbGen[TG_SIGLA], aPos, aDic, Len(aTGITRef),aHmFor,aDepTrib, aDepVlOrig,aFunc, aUltPesqF2D, cCpoD1Altr)

				IF fisExtTab('12.1.2310', .T., 'CJ2')
					//Função que verifica se foi alterado o total ou a base da duplicata para refazer os tributos dependentes das referências
					xRefTotLf(aNfCab, aNfItem, nItem, aPos, aDic, aTGITRef, aHmFor, aDepTrib, aDepVlOrig, aFunc, aUltPesqF2D, dVencReal)
				Endif

			EndIF

			//Obtem a lista dos tributos genéricos com ID de tributo legado após de refazer os cálculos
			aTribLegD	:= Iif(aNfCab[NF_CHKTRIBLEG] , ListTLegTG(aNFItem, nItem),{})

			//Obtem a lista de tributos legados que precisam ser atualizados após o cálculo dos tributos genéricos
			aTrbLegCalc	:= Iif(aNfCab[NF_CHKTRIBLEG] , ChkCalcTLeg(aTribLegA, aTribLegD),{})

			//Refaz aqui o cálculo dos tributos legados se necessário
			If Len(aTrbLegCalc) > 0
				AtuTrbLeg(aTrbLegCalc, nItem)
			EndIf

		EndIF
	Case cCampo == "IT_TPOPER"
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_QTDORI"
		MaFisLF(nItem)
	Case cCampo == "IT_BSFCPST"
		MaFisFECP(nItem,,,"VLR")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case (cPaisLoc == "RUS") .And. (AllTrim(cCampo) == "IT_VALMERC_C1")
		aNfItem[nItem][IT_DESCZF] := 0
		MaFisPreCalc(nItem,cCampo)
		MaFisImpIV(nItem,cCampo)
		MaFisNameIV(,nItem)
		If aNFItem[nItem][IT_TS][TS_OPERSUC] == "1"
			MaFisBsIcm(nItem)
			MaFisVICMS(nItem)
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		Endif
		MaFisVTot(nItem,Iif(cPaisLoc == "RUS",cCampo,Nil))
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
	Case cCampo == "IT_PR43080"
		MaFisBSICM(nItem,.T.)
		MaFisVICMS(nItem,.T.)
		MaFisVTot(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_DEDICM"
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cCampo == "IT_PESO"
		MaFisVTot(nItem)
		MaItArred(nItem)
	OtherWise
		//encapsulamento deste trecho para replicar e melhorar a performance quando cCampo estiver vazio
		fMatOwise(cCampo,nItem,dVencReal,lMVRPCBIZF,aTrbLegCalc) 
EndCase

//Aqui verifica se existe ao menos uma regra cadastrada na tabela F2B, para chamar função de cálculo dos tributos genéricos.
//Se o ID de carga dos tributos genéricos estiver preenchido, a função não será chamada.
//Se o usuário fez alguma alteração via tela, os valores deos tributos genéricos serão recalculados.
If aNfCab[NF_TEMF2B] .And. cCampo <> "IT_TRIBGEN" .AND. (Empty(aNfItem[nItem][IT_ID_LOAD_TRBGEN]) .Or. (!Empty(aNfItem[nItem][IT_ID_LOAD_TRBGEN]) .AND. IsInCallStack("VALIDGET")) .OR. lSimuRepro)

	//Obtem a lista dos tributos genéricos com ID de tributo legado antes de refazer os cálculos
	aTribLegA	:= Iif(aNfCab[NF_CHKTRIBLEG] , ListTLegTG(aNFItem, nItem),{})
	// ajusto o arredondamento do que já foi calculado para não termos problemas
	// com novos calculos
	TGAjuArred(@aNFCab, @aNfItem, aTGITRef, nItem,'')
	//Chama função para enquadrar e calcular tributos genéricos	
	xFisTrbGen(aNfCab, @aNfItem, nItem, cCampo,,, aPos, aDic, Len(aTGITRef), aHmFor, aDepTrib, aDepVlOrig,aFunc, aUltPesqF2D)
	
	If cCampo == "IT_VALMERC"
		xFisTrbGen(aNfCab, @aNfItem, nItem, "IT_TOTAL",,, aPos, aDic, Len(aTGITRef), aHmFor, aDepTrib, aDepVlOrig,aFunc, aUltPesqF2D)
		xFisTrbGen(aNfCab, @aNfItem, nItem, "IT_BASEDUP",,, aPos, aDic, Len(aTGITRef), aHmFor, aDepTrib, aDepVlOrig,aFunc, aUltPesqF2D)
		xFisTrbGen(aNfCab, @aNfItem, nItem, "LF_VALCONT",,, aPos, aDic, Len(aTGITRef), aHmFor, aDepTrib, aDepVlOrig,aFunc, aUltPesqF2D)
		xFisTrbGen(aNfCab, @aNfItem, nItem, "IT_BICMORI",,, aPos, aDic, Len(aTGITRef), aHmFor, aDepTrib, aDepVlOrig,aFunc, aUltPesqF2D)
	EndIf
	
	//Faz arredondamento do valor e da base de cálculo dos tributos genéricos
	MaItArred(nItem, { "TG_IT_BASE","TG_IT_VALOR" } )

	IF fisExtTab('12.1.2310', .T., 'CJ2')
		//Função que verifica se foi alterado o total ou a base da duplicata para refazer os tributos dependentes das referências
		xRefTotLf(aNfCab, aNfItem, nItem, aPos, aDic, aTGITRef, aHmFor, aDepTrib, aDepVlOrig, aFunc, aUltPesqF2D, dVencReal, nTot)
	Endif

	//Obtem a lista dos tributos genéricos com ID de tributo legado após de refazer os cálculos
	aTribLegD	:= Iif(aNfCab[NF_CHKTRIBLEG] , ListTLegTG(aNFItem, nItem),{})

	//Obtem a lista de tributos legados que precisam ser atualizados após o cálculo dos tributos genéricos
	aTrbLegCalc	:= Iif(aNfCab[NF_CHKTRIBLEG] , ChkCalcTLeg(aTribLegA, aTribLegD),{})

	//Refaz aqui o cálculo dos tributos legados se necessário
	If Len(aTrbLegCalc) > 0
		AtuTrbLeg(aTrbLegCalc, nItem)
	EndIf

	//Recalculo dos tributos do CBS e do IBS (Reforma) para garantir que todas dependencia ja estejam atualizadas
	xRecReforma(aNfCab, @aNfItem, nItem, aPos, aDic, Len(aTGITRef), aHmFor, aDepTrib, aDepVlOrig, aFunc, aUltPesqF2D)

	FisXTelem("CONFXFIS", nItem) //Telemetria quando calculado tributos pelo configurador
EndIF

//Faz chamada para processar os valores das últimas aquisições para compor valores de ressarcimento de ICMS
If fisGetParam('MV_ULTAQUI','') $ "1/2/3" .AND. Mafiscache('Mafisrecal_valid_MV_ULTAQUI',,{|| fisExtCmp('12.1.2310', .T., 'SFT' , 'FT_BSTANT' ) .AND. fisExtCmp('12.1.2310', .T., 'SFT' , 'FT_PSTANT' ) .AND. fisExtCmp('12.1.2310', .T., 'SFT' , 'FT_VSTANT' ) .AND. fisExtCmp('12.1.2310', .T., 'SFT' , 'FT_VICPRST' ) .AND. ;
  fisExtCmp('12.1.2310', .T., 'SFT' , 'FT_BFCANTS' ) .AND. fisExtCmp('12.1.2310', .T., 'SFT' , 'FT_PFCANTS' ) .AND. fisExtCmp('12.1.2310', .T., 'SFT' , 'FT_VFCANTS' ) .AND. fisExtCmp('12.1.2310', .T., 'SD1' , 'D1_VFECPST' ) .AND. fisExtCmp('12.1.2310', .T., 'SD1' , 'D1_BSFCPST' ) .AND. ;
	fisExtCmp('12.1.2310', .T., 'SD1' , 'D1_FCPAUX' ) .AND. fisExtCmp('12.1.2310', .T., 'SD1' , 'D1_ALFCPST' ) .AND. fisExtCmp('12.1.2310', .T., 'SD1' , 'D1_AFCPANT' ) .AND. fisExtCmp('12.1.2310', .T., 'SD1' , 'D1_BFCPANT' ) .AND. fisExtCmp('12.1.2310', .T., 'SD1' , 'D1_VFCPANT' ) .AND. ;
	fisExtCmp('12.1.2310', .T., 'SD1' , 'D1_ALQNDES' ) .AND. fisExtCmp('12.1.2310', .T., 'SFT' , 'FT_VFCANTS' )},.T.) .AND. ;
	( (aNfCab[NF_OPERNF]=="S" .AND. aNFCab[NF_CLIFOR]=="C") .OR. (aNFCab[NF_TIPONF] $ "DB" ))

	FISXULTENT(nItem, aNfItem, aNfCab, aSX6, cCampo,.F.)

EndIF

Return
/*/
fMatOwise -  Eduardo Ferreira-27.08.2020
Encapsulamento do trecho do OTHERWISE da função MaFisRecal
/*/
Static Function fMatOwise(cCampo,nItem,dVencReal,lMVRPCBIZF,aTrbLegCalc)
Local lRet	   := .T.

    If cPaisLoc == "BRA"
		MaFisCFO(nItem)
		MaSeekCFC(3,nItem)
		MaExcecao( nItem , cCampo )
		MaFisPreCalc(nItem,cCampo)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
		
			If (Empty( aNFItem[nItem,IT_ALIQICM] ) .Or. aNfCab[NF_TIPONF] $ "DBC" .Or. ;
				"NF_" $ cCampo .Or. "IT_RECORI" == cCampo .Or.;
				"IT_PRODUTO" == cCampo .Or. "IT_GRPTRIB" == cCampo .Or. ;
				"IT_CLASFIS" == cCampo)
				MaAliqIcms(nItem)
			Endif
			If (Empty( aNFItem[nItem,IT_ALIQIPI] ) .Or. aNfCab[NF_TIPONF] $ "DB" .Or. ;
				"NF_" $ cCampo .Or. "IT_RECORI" == cCampo .Or. ;
				"IT_PRODUTO" == cCampo .Or. "IT_GRPTRIB" == cCampo)
				MaFisIPI(nItem,"ALQ")
			Endif

			MaALIQCMP(nItem)
			MaAliqSoli(nItem)
		EndIf

		MaFisISS(nItem,"ALQ")
		MaFisTPDP(nItem)
		MaMargem(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisIPI(nItem,"BSE|VLR")
			MaFisBSICM(nItem)
			MaFisVICMS(nItem)
		Else
			MaFisIPI(nItem,"")
		Endif
		If !( aNFItem[nItem][IT_TS][TS_TPIPI]=="B" .Or. (fisGetParam('MV_IPIBRUT','')=="S" .And. aNFItem[nItem][IT_TS][TS_TPIPI] ==" ") ) .And. ( aNFItem[nItem][IT_TS][TS_AGREG]=="D" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="R")
			MaFisIPI(nItem,"BSE|VLR")
		EndIf
		MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		MaFisISS(nItem)
		MaFisVTot(nItem)
		MaFisVComp(nItem)
		MaFisVDescZF(nItem)
		MaFisBSSOL(nItem)
		If aNFItem[nItem][IT_TS][TS_ISEFEMG] == "2" .And. aNfItem[nItem][IT_ALFECMG] > 0
			MaFisVICMS(nItem)
		EndIf

		If cCampo <> "IT_VLSLXML"
			MaFisVSOL(nItem)
		EndIf

		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
			If !(aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1" .And. cCampo#"IT_RECORI")
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
			EndIf
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					//Para cliente consudmidor final, o ICMS não deve ser recalculado quando houver desconto, a menos que o parâmetro MV_RPCBICF esteja ativo em conjunto com o MV_RPCBIZF e trate-se de um produto de origem nacional.
					If ChkDescCF( lMVRPCBIZF, nItem )
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
					Endif
					If fisGetParam('MV_DESCZF',.T.) .and. fisGetParam('MV_CPRBNF',.F.) .AND. fisGetParam('MV_DEDBPIS','') == "D" .AND. fisGetParam('MV_DEDBCPR','N') == "D"
						MaFisCPRB(nItem)
					EndIf
					ZfDedBCofPis(nItem)
					MaFisVTot(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				If aNFItem[nItem][IT_TS][TS_ISEFEMG] == "2" .And. aNfItem[nItem][IT_ALFECMG] > 0
					MaFisVICMS(nItem)
				EndIf
				MaFisVSol(nItem)
			ElseIf aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1"
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
			EndIf
		EndIf
		MaFisICA(nItem)
		MaFisTST(nItem)
		MaFisRURAL(nItem)
		MaFisVSul(nItem)
		MaFisFFF(nItem)
		MaFisAliqIV(,nItem)
		MaFisBSIV(,nItem)
		MaFisVLIV(,nItem)
		MaFisNameIV(,nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
			If !(aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1")
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
			EndIf
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					If aNFItem[nItem][IT_TS][TS_DESCOND] $ " |2" .And. ChkProdNac(nItem)
						ZfCalcCofPis(nItem)
					EndIf
					//Para cliente consudmidor final, o ICMS não deve ser recalculado quando houver desconto, a menos que o parâmetro MV_RPCBICF esteja ativo em conjunto com o MV_RPCBIZF e trate-se de um produto de origem nacional.
					If ChkDescCF( lMVRPCBIZF, nItem )
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
					Endif
					If aNFItem[nItem][IT_TS][TS_DESCOND] == "1" .Or. !ChkProdNac(nItem)
						ZfCalcCofPis(nItem)
					EndIf
					MaFisVTot(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				If aNFItem[nItem][IT_TS][TS_ISEFEMG] == "2" .And. aNfItem[nItem][IT_ALFECMG] > 0
					MaFisVICMS(nItem)
				EndIf
				MaFisVSol(nItem)
				If lMVRPCBIZF .And. !ChkProdNac(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
			Else
				If (aNFItem[nItem][IT_TS][TS_AGRPIS]=="P" .Or. aNFItem[nItem][IT_TS][TS_AGRCOF]=="C") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"
					MaFisBSICM(nItem)
					MaFisVICMS(nItem)
				EndIf
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisSENAR(nItem)
		MaFisINSS(nItem)
		MaFisIR(nItem,,dVencReal)
		If !(aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" ) .And. !(aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1")
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisSEST(nItem)
		MaFisINSP(nItem)
		MaFisBSSOL(nItem)
		If aNFItem[nItem][IT_TS][TS_ISEFEMG] == "2" .And. aNfItem[nItem][IT_ALFECMG] > 0
			MaFisVICMS(nItem)
		EndIf
		If cCampo <> "IT_VLSLXML"
			MaFisVSol(nItem)
		EndIf
		MaFisVTot(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisISS(nItem)
		MaFisISSBi(nItem)
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		If aNFItem[nItem][IT_TS][TS_BCPCST] == "1" //Campo que indica se os valores de PIS/COFINS ST entram na base de ICMS-ST
			MaFisBSSOL(nItem)
			If aNFItem[nItem][IT_TS][TS_ISEFEMG] == "2" .And. aNfItem[nItem][IT_ALFECMG] > 0
				MaFisVICMS(nItem)
			EndIf
			MaFisVSol(nItem)
		EndIf
		If !(fisGetParam('MV_DESCZF',.T.) .and. fisGetParam('MV_CPRBNF',.F.) .AND. fisGetParam('MV_DEDBPIS','') == "D" .AND. fisGetParam('MV_DEDBCPR','N') == "D")
			MaFisCPRB(nItem)
		EndIf
		MaCodDecl(nItem)
		// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
		If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
			// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
			// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
			// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
			If aNFItem[nItem][IT_VALICM] == 0
				MaFisBSICM(nItem,,,,,.F.)
				MaFisVICMS(nItem)
				MaFisVTot(nItem)
				MaFisVComp(nItem)
				MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
				MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisLF(nItem,,.F.)
		If !(fisGetParam('MV_DESCZF',.T.) .and. fisGetParam('MV_CPRBNF',.F.) .AND. fisGetParam('MV_DEDBPIS','') == "D" .AND. fisGetParam('MV_DEDBCPR','N') == "D") .And. aNFItem[nItem][IT_TS][TS_DESCOND] == "2" .And.;
			IIF(!Empty(fisGetParam('MV_IMPZFRC','')),  !(SubStr( aNfItem[nItem][IT_CLASFIS],1,1 ) $ fisGetParam('MV_IMPZFRC','')) ,aNfItem[nItem][IT_PRD][SB_IMPZFRC] $ " N") // Checa se o produto possui origem nacional, através dos parâmetros MV_IMPZFRC e, caso o parâmetro esteja em branco, através do campo B1_IMPZFRC
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
				If !(aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1")
					MaFisCOFINS(nItem,"CF2")
					MaFisPIS(nItem,"PS2")
				EndIf
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					If	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
				EndIf
			EndIf
		EndIf

		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		If cCampo == "IT_PRODUTO"
			MaFisCide(nItem)
		EndIf
		MaItArred(nItem)
		MaFisAFRMM(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisII(nItem)
			MaFisVTot(nItem)
		EndIf
		//Recalcula o PIS/COFINS e o CPRB para somar o valor do crédito presumido, caso o sistema esteja parametrizado para isso
		CrdPresAdd( nItem,  aNfItem[nItem][IT_LIVRO][LF_CRDPRES] > 0, fisGetParam('MV_CPRBNF',.F.) .And. fisGetParam('MV_CRDPRCP',.F.), fisGetParam('MV_CRDPRPC',.F.),;
							aNfItem[nItem][IT_VALPIS], aNfItem[nItem][IT_VALPS2], aNfItem[nItem][IT_VALPS3],;
							aNfItem[nItem][IT_VALCOF], aNfItem[nItem][IT_VALCF2], aNfItem[nItem][IT_VALCF3] )
		MaFisLF(nItem)
		MaFisFMPEQ(nItem)
	Else
		MaFisPreCalc(nItem)
		If !(cPaisLoc $ "ARG|COL|RUS")
			MaFisCFO(nItem)
		ElseIf cPaisLoc $ "RUS|COL"
			MaFisCFO(nItem, MaFisRet(nItem,"IT_CF"))
		Endif
		MaFisImpIV(nItem,cCampo)
		MaFisNameIV(,nItem)
		MaFisVTot(nItem, Iif(cPaisLoc == "RUS",cCampo,Nil))
		MaItArred(nItem)
	EndIf
Return lRet		   
/*MaFisTes-Alexandre Lemes -03/01/2013´
Inicializa o codigo da TES utilizada no item
*/
Function MaFisTes(cTes,nRecnoSF4,nItemTes)

	xFisTes(@cTes,@nRecnoSF4,@nItemTes,@aTes,@lNotRemito,@lHistorico,@cAlsItem,@aNfCab,@aNfItem,@aSX6,@aPos,@aDic)

Return

/*/
MaFisWrite - Edson Maricate -10.01.1999
Verifica arredondamentos para iniciar a gravacao
*/
Function MaFisWrite(nOpc,cArea,nItem,lImpostos,lRemito)

Local aAcDif 	:= Array(Len(aItemRef))
Local aNotasOri := {}
Local nX       	:= 0
Local nY       	:= 0
Local lGravaCpo := .T.
Local nPosCmp	:= 0
DEFAULT lImpostos:= .F.
DEFAULT lRemito  := .F. //Variavel criada para indicar que impostos nao devem ser gravados (somente despesas)

aFill(aAcDif,0)
Do Case
Case nOpc == 2 // Efetua a gravacao dos campos de impostos.
	dbSelectArea(cArea)
	For nX := 1 to Len(aNfCab[NF_RELIMP])
		If aNfCab[NF_RELIMP][nX][1] == cArea
			If  cPaisLoc <> "RUS"
				Do Case
				Case lImpostos .And. !(Substr(aNfCab[NF_RELIMP][nX][1],4,6) $ "BASIMP*ALQIMP*VALIMP")
					lGravaCpo := .F.
				Case lRemito .And. Substr(aNfCab[NF_RELIMP][nX][1],4,6) $ "BASIMP*ALQIMP*VALIMP"
					lGravaCpo := .F.
				Otherwise
					lGravaCpo := .T.
				EndCase
			Else	//(30/07/18): aNfCab[NF_RELIMP][nX] = {Table_name, Field_name, Valid_name}
				Do Case
				Case lImpostos .And. !(Substr(aNfCab[NF_RELIMP][nX][1],4,6) $ "BASIMP*ALQIMP*VALIMP")
					lGravaCpo := .F.
				Case lRemito .And. Substr(aNfCab[NF_RELIMP][nX][2],4,6) $ "BASIMP*ALQIMP*VALIMP*BSIMP1*VLIMP1*VLMERC*VLBRUT"
					lGravaCpo := .F.
				Otherwise
					lGravaCpo := .T.
				EndCase
			EndIf
			If lGravaCpo .And. (nPosCmp := FieldPos(aNfCab[NF_RELIMP][nX][2])) > 0
				FieldPut(nPosCmp,MaFisRet(nItem,aNfCab[NF_RELIMP][nX][3]))
			Endif
		EndIf
	Next nX
OtherWise //Inicia a gravacao e fetua a correcao dos arredondamentos.
	aNfCab[NF_LIVRO] := {}
	For nX := 1 to Len(aNfItem)
		If !aNfItem[nX][IT_DELETED]
			If cPaisLoc=="BRA"
				For nY := 1 to Len(aItemRef)
					If aItemRef[nY][4]
						If ValType(aItemRef[nY][2]) == "A"
							nAcDif := aAcDif[nY]
							nValor := aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]]
							If nValor > 0
								aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] := NoRound(nValor,2,@nAcDif,10)
								aAcDif[nY] := nAcDif
								If NoRound(aAcDif[nY],2) >= 0.01
									aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += 0.01
									aAcDif[nY] -= 0.01
								EndIf
							EndIf
						Else
							nAcDif := aAcDif[nY]
							nValor := aNfItem[nX][Val(aItemRef[nY][2])]
							If nValor > 0
								aNfItem[nX][Val(aItemRef[nY][2])] := NoRound(nValor,2,@nAcDif,10)
								aAcDif[nY] := nAcDif
								If NoRound(aAcDif[nY],2) >= 0.01
									aNfItem[nX][Val(aItemRef[nY][2])] += 0.01
									aAcDif[nY] -= 0.01
								EndIf
							EndIf
						EndIf
					EndIf
				Next nY
			EndIf
			If cPaisLoc == "BRA" .Or. lNotRemito
				MaFisLFToLivro(nX,@aNotasOri)
			EndIf
		EndIf
	Next nX
	If cPaisLoc == "BRA"
		For nX := 1 To Len(aCabRef)
			If ValType(aCabRef[nX,2]) <> "A"
				nY := Val(aCabRef[nX,2])
				If ValType(aNfCab[nY]) == "N" .And. aCabRef[nX][3]
					aNfCab[nY] := NoRound(aNfCab[nY]+0.00000001,2,,10)
				EndIf
			EndIf
		Next nX
	Endif
EndCase

Return .T.

/*/
MaFisIniNF Rev.   Eduardo Riera  -08.08.2001
Rotina de Inicializacao da funcao fiscal com base nas Notas Fiscais
Esta rotina tem como objetivo atualizar a funcao fiscal com
base em uma nota fiscal de entrada ou saida. A Funcao Fiscal
eh atualizada com base nas referencias do dicionario de dados
Parametros
ExpN1: Tipo de Nota Fiscal
[1] Nota Fiscal de Entrada
[2] Nota Fiscal de Saida
ExpX2: Numero do Registro do Cabecalho da Nota Fiscal, ou o Alias da Tabela a ser considerada
ExpA3: Array para Otimizacao ( Uso Interno deve-se apenas assegurar que seu valor foi amazenado externamente a esta rotina)
ExpC4: Alias da tabela de notas fiscais de entrada (OPC)
ExpL5: Indica se deve ser recalculada a base dos impostos Fiscais (OPC)
/*/
Function MaFisIniNF(nTipoNF,nRecSF,aOtimizacao,cAlias,lReprocess,cFunOrig, lHistFis, cAlsItem2, lCalcTG, lF2BTeste)

Local aArea	   := GetArea()
Local aAreaSD1 := SD1->(GetArea())
Local aAreaSF1 := SF1->(GetArea())
Local aAreaSD2 := SD2->(GetArea())
Local aAreaSF2 := SF2->(GetArea())
Local cAlias2  := ""
Local cCliEnt  := Space(FisTamSX3( 'SF3','F3_CLIEFOR' )[1])
Local cLojEnt  := Space(FisTamSX3( 'SF3','F3_LOJA' )[1])
Local nX	   := 0
Local nY	   := 0
Local nValor   := 0
Local nDesc	   := 0
Local lQuery   := .F.
Local lISS	   := .F.
Local lSoICMS  := .T.
Local lCmpsSN1 := fisExtCmp('12.1.2310', .T.,'SN1','N1_CSTPIS') .And. fisExtCmp('12.1.2310', .T.,'SN1','N1_CSTCOFI') .And. fisExtCmp('12.1.2310', .T.,'SN1','N1_ALIQPIS') .And. fisExtCmp('12.1.2310', .T.,'SN1','N1_ALIQCOF') .And. fisExtCmp('12.1.2310', .T.,'SN1','N1_CODBCC')
Local cUfOrig	:= ''
Local cUfDest	:= ''
Local lCtaRec   := fisExtCmp('12.1.2310', .T.,'SD2','D2_CTAREC') 
Local lCtaEntRe := fisExtCmp('12.1.2310', .T.,'SD1','D1_CTAREC')
Local nPos:=0
Local oMontQry:=nil
Local lIsSimul := lCalcTG <> Nil .and. lF2BTeste <> Nil // define se a chamada da função veio do simulador

#IFDEF TOP
	Local aStru := {}
	Local cQuery:= ""
#ENDIF
DEFAULT cFunOrig   := ""
DEFAULT lHistFis   := .F.
DEFAULT lReprocess := .F.
DEFAULT cAlsItem2  := ""
DEFAULT lCalcTG	   := .F.
DEFAULT lF2BTeste  := .F.

If cFunOrig == "MATA930"
	lHistorico := lHistFis
EndIf

//Aqui indico na variável static que se trata de reprocessamento do livro
lReproc	:= lReprocess

Do Case
	Case nTipoNF == 1
		If Empty(aOtimizacao)
			aOtimizacao := {MaFisSXRef("SF1"),MaFisSxRef("SD1")}
		EndIf

		cAlias2 := "SD1"

		If Empty(cAlias)
			cAlias := "SF1"
			dbSelectArea(cAlias)
			MsGoto(nRecSF)
		EndIf

		If lHistorico
			cAlsCab := cAlias
		EndIf
		MaFisEnd()
		MaFisIni((cAlias)->F1_FORNECE,(cAlias)->F1_LOJA,IIF((cAlias)->F1_TIPO$'DB',"C","F"),(cAlias)->F1_TIPO,,,If((cAlias)->F1_TIPO=="C",AllTrim((cAlias)->F1_ORIGLAN),Nil),,,,,,,,Iif(lReprocess,(cAlias)->F1_RECISS,Nil),,,,,,,,,,,,,,,,,,lCalcTG,,,,lF2BTeste)

		If (cAlias)->F1_TIPO$"DB" .And. !lReprocess .And. cFunOrig <> "FISR001"
			MaFisAlt("NF_UFDEST",(cAlias)->F1_EST)
		Else
			MaFisAlt("NF_UFORIGEM",(cAlias)->F1_EST)
		EndIf

		MaFisAlt("NF_ESPECIE",(cAlias)->F1_ESPECIE)

		If lReprocess .And. aNFCab[NF_OPERNF] == "E" .AND. ( AllTrim( aNFCab[NF_ESPECIE] ) $ "CTR/CTE/CTA/CA/CTF/CTEOS" .Or. "NFST" $ AllTrim( aNFCab[NF_ESPECIE] ) )
			//Tratamento do F1_ESTDES
			If (cAlias)->( FieldPos( "F1_ESTDES" ) ) > 0 .And. !Empty( (cAlias)->F1_ESTDES )
				MaFisAlt("NF_UFCDEST",(cAlias)->F1_ESTDES)
			Endif

			//Tratamento dos campos F1_UFORITR e F1_UFDESTR
			//Se F1_UFORITR e/ou F1_UFDESTR estiverem preenchidos terão prioridade, se não então considerarei os NF_UFORIGEM e NF_UFDEST já carregados
			cUFOrig	:= Alltrim( Iif( (cAlias)->(FieldPos("F1_UFORITR") ) > 0 .And. !Empty( (cAlias)->F1_UFORITR ) , (cAlias)->F1_UFORITR , aNFCab[NF_UFORIGEM] ) )
			cUfDest	:= Alltrim( Iif( (cAlias)->(FieldPos("F1_UFDESTR") ) > 0 .And. !Empty( (cAlias)->F1_UFDESTR ) , (cAlias)->F1_UFDESTR , aNFCab[NF_UFDEST]   ) )

			If !Empty( cUFOrig ) .AND. !Empty( cUfDest ) .AND. fisGetParam('MV_ESTADO','') == cUFOrig .AND.  cUFOrig <> cUfDest

				If cUFOrig <> Alltrim( aNFCab[NF_UFORIGEM]  )
					MaFisAlt("NF_UFORIGEM"	, cUFOrig	)
				EndIF

				If cUfDest <> Alltrim( aNFCab[NF_UFDEST] )
					MaFisAlt("NF_UFDEST"	, cUfDest  )
				EndIF

			EndIF

		EndIf

		dbSelectArea(cAlias2)
		dbSetOrder(1)
		#IFDEF TOP
		If TcSrvType()<>"AS/400" .and. !lReprocess .Or. lIsSimul //Melhoria de performance para reprocessamento
			aStru   := SD1->(dbStruct())
			lQuery  := .T.
			cAlias2 := "MaFisIniNF"
			cQuery  := "SELECT SD1.*,SD1.R_E_C_N_O_ SD1RECNO FROM "+RetSqlName("SD1")+" SD1 "
			cQuery  += "WHERE "
			cQuery  += "SD1.D1_FILIAL = ? AND "
			cQuery  += "SD1.D1_DOC = ? AND "
			cQuery  += "SD1.D1_SERIE = ? AND "
			cQuery  += "SD1.D1_FORNECE = ? AND "
			cQuery  += "SD1.D1_LOJA = ? AND "
			cQuery  += "SD1.D1_TIPO= ? AND "
			cQuery  += "SD1.D_E_L_E_T_= ? "
			cQuery  += "ORDER BY SD1.D1_FILIAL,SD1.D1_NUMSEQ "
			
			oMontQry := FwExecStatement():New(ChangeQuery(cQuery))

			oMontQry:SetString(nPos += 1, xFilial("SD1"))
			oMontQry:SetString(nPos += 1, (cAlias)->F1_DOC)
			oMontQry:SetString(nPos += 1, (cAlias)->F1_SERIE)
			oMontQry:SetString(nPos += 1, (cAlias)->F1_FORNECE)
			oMontQry:SetString(nPos += 1, (cAlias)->F1_LOJA)
			oMontQry:SetString(nPos += 1, (cAlias)->F1_TIPO)
			oMontQry:SetString(nPos += 1, ' ')

			cAlias2 := oMontQry:OpenAlias()  

			For nX := 1 To Len(aStru)
				If aStru[nX][2] <> "C"
					TcSetField(cAlias2,aStru[nX][1],aStru[nX][2],aStru[nX][3],aStru[nX][4])
				EndIf
			Next nX
		Else
		#ENDIF
			MsSeek(xFilial("SD1")+(cAlias)->F1_DOC+(cAlias)->F1_SERIE+(cAlias)->F1_FORNECE+(cAlias)->F1_LOJA)
		#IFDEF TOP
		EndIf
		#ENDIF

		dbSelectArea(cAlias2)
		While ( !Eof() .And. (cAlias2)->D1_FILIAL == xFilial("SD1") .And.;
			(cAlias2)->D1_DOC == (cAlias)->F1_DOC .And.;
			(cAlias2)->D1_SERIE == (cAlias)->F1_SERIE .And.;
			(cAlias2)->D1_FORNECE == (cAlias)->F1_FORNECE .And.;
			(cAlias2)->D1_LOJA == (cAlias)->F1_LOJA )

			If (cAlias2)->D1_TIPO == (cAlias)->F1_TIPO
				nY++
				If lHistorico
					cAlsItem  := cAlias2
					cAlsItem2 := cAlias2
				EndIf

				If lReprocess
					MaFisIniLoad(nY)
				Else
					MaFisIniLoad(nY,,,Iif(fisExtCmp('12.1.2310', .T.,'SD1','D1_IDTRIB'),(cAlias2)->D1_IDTRIB,""))
				EndIf

				If lReprocess
					MaFisAlt ("IT_ITEM", (cAlias2)->D1_ITEM, nY)
					If lCtaEntRe
						Mafisload("IT_CTAREC",(cAlias2)->D1_CTAREC,nY) // Ajuste para igualar D2_CTAREC 
					EndIF	
				EndIf

				(cAliasProd)->(dbSetOrder(1))
				If (cAliasProd)->(MsSeek(xFilial(cAliasProd)+(cAlias2)->D1_COD))
					aNFitem[nY][IT_CODISS]	:=	aNfItem[nY][IT_PRD][SB_CODISS]
				Endif

				For nX := 1 To Len(aOtimizacao[2])
					nValor := (cAlias2)->(FieldGet(FieldPos(aOtimizacao[2][nX][1])))
					IF !Empty(nValor)
						MaFisLoad(aOtimizacao[2][nX][2],nValor,nY)
					Endif
				Next nX

				// Rotina usada apanas para retornar o valor do ICMS ISENTO no Relatorio DUB-ICMS
				If cFunOrig == "FISR001"  .And. (cAlias2)->D1_CLASFIS $(" 40/ 41/ 50/ 90/040/041/050/090/140/141/150/190")
					MaFisTes(aNfItem[nY][IT_TES],aNfItem[nY][IT_RECNOSF4],nY)

					aNFItem[nY][IT_TS][TS_ICM] := "S"
					MaAliqIcms(nY)
					MaFisBSICM(nY)
					MaFisVICMS(nY)
					MaItArred(nY,{"IT_VALICM"})
				EndIf

				MaFisEndLoad(nY,2)

				If lReprocess
					If cPaisLoc == "BRA"
						
						//Para o reprocessamento não posso passar o D1_IDTRIB no MaFisIniLoad 
						//Porque ele carrega os tributos genéricos antes de preencher as referências dos tributos legados
						aNfItem[nY][IT_ID_LOAD_TRBGEN]:= Iif(fisExtCmp('12.1.2310', .T.,'SD1','D1_IDTRIB'),(cAlias2)->D1_IDTRIB,"")

						if lCalcTG // para que ocorra o cálculo dos tributos genéricos
							lSimuRepro := .T.
							MafisLoad("IT_TES", "", nY)
							MaFisAlt("IT_TES", (cAlias2)->D1_TES, ny)
						endif

						MaFisIPI(nY,"BSE|VLR",.T.) // Calcula a Base de IPI Original
						MaExcecao(nY)
						MaFisPreCalc(nY)
						MaFisBSICM(nY,.T.)	// Calcula a Base de ICMS Original
						MaFisVICMS(nY,.T.) 	// Calcula o Valor do ICMS / Diferido
						MaFisPis(nY,"PS2","BSE|VLR",.T.)
						MaFisCofins(nY,"CF2","BSE|VLR",.T.)
						MaFisCPRB(nY)
						MaFisISS(nY)
						// Não chamar as funcoes do ICMS complementar nas entradas pois
						// os valores ja foram carregados de SD1 e nao precisam ser recalculados.
						/*If (cAlias2)->D1_TIPO $ "NDC"
							MaALIQCMP(nY)
							MaMargem(nY)
							MaFisVComp(nY,.T.)
						EndIf*/

						If aNFItem[nY][IT_TS][TS_ATUATF] == "S" .And. lCmpsSN1//Atualiza Ativo Fixo
							DbSelectArea("SN1")
							DbSetOrder(1)
							If SN1->(MsSeek(xFilial("SN1")+Substr((cAlias2)->D1_CBASEAF,1,10)+Substr((cAlias2)->D1_CBASEAF,11,4)))
								RecLock("SN1",.F.)
								SN1->N1_CSTPIS	:=	aNfItem[nY][IT_LIVRO][LF_CSTPIS]
								SN1->N1_CSTCOFI	:=	aNfItem[nY][IT_LIVRO][LF_CSTCOF]
								SN1->N1_ALIQPIS	:=	aNfItem[nY][IT_ALIQPS2]
								SN1->N1_ALIQCOF	:=	aNfItem[nY][IT_ALIQCF2]
								SN1->N1_CODBCC	:=	aNFItem[nY][IT_TS][TS_CODBCC]
								SN1->(FkCommit())
								MsUnLock()
							Endif
						Endif

						//Grava valor Credito Presumido Substituicao Tributaria retido pelo contratante do servico de transporte - Decreto 44.147/2005 (MG)
						If aNFItem[nY][IT_TS][TS_CRPRST]<>0
							MaAliqSoli(nY)
							MaMargem(nY)
							MaFisVSol(nY)
							MaFisVTot(nY)
						EndIf

						//----------------------------------------------------------------------------
						//Faz carga dos tributos genéricos se o ID do tributo genérico for preenchido.
						//----------------------------------------------------------------------------
						CargaTribGen(aNFCab, aNfItem, nY, aTGITRef, aPos, aDic, aHmFor, lReprocess)						
					EndIf

					MaItArred(nY,{"IT_VALCMP"})

					If lReprocess .And. fisExtTab('12.1.2310', .T., 'CJ2')
						//Aqui chama função para refazer o livro dos tributos genéricos no reprocessamento
						ReprocTribgen(aNFItem, nY, aNFCab, aHmFor)
					EndIf
					
					MaFisLF(nY)
					MaFisLoad("LF_ITEMORI",(cAlias2)->D1_ITEMORI,nY) //Refaz o Item Original
				EndIf
			EndIf

			If (cAlias2)->D1_ORIGLAN<>(cAlias)->F1_ORIGLAN
				If lQuery
					SD1->(MsGoto((cAlias2)->SD1RECNO))
				EndIf
				RecLock("SD1",.F.)
				SD1->D1_ORIGLAN := (cAlias)->F1_ORIGLAN
				MsUnlock()
			EndIf

			dbSelectArea(cAlias2)
			dbSkip()

		EndDo

		If lQuery .and.(!lReprocess .Or. !lHistorico)
			dbSelectArea(cAlias2)
			dbCloseArea()
			dbSelectArea("SD1")
		EndIf

		If (cAlias)->F1_IMPORT <> "S"
			MaFisAlt("NF_FRETE"  ,(cAlias)->F1_FRETE)
			MaFisAlt("NF_SEGURO" ,(cAlias)->F1_SEGURO)
			MaFisAlt("NF_DESPESA",(cAlias)->F1_DESPESA)
			If fisExtCmp('12.1.2310', .T.,'SF1','F1_DESNTRB')
				MaFisAlt("NF_DESNTRB",(cAlias)->F1_DESNTRB)
			Endif
			If fisExtCmp('12.1.2310', .T.,'SF1','F1_TARA')
				MaFisAlt("NF_TARA"   ,(cAlias)->F1_TARA)
			Endif
		EndIf

		// Fundo Social - Sera recalculado para apresentar nas observacoes do documento
		MaFisAlt("NF_FUNRURAL" ,(cAlias)->F1_CONTSOC,)

	Case nTipoNF == 2 // Processa NF de saida
		If Empty(aOtimizacao) //Verifica se o Array de otimizacao esta disponivel
			aOtimizacao := {MaFisSXRef("SF2"),MaFisSxRef("SD2")}
		EndIf
		cAlias2 := "SD2"
		If Empty(cAlias)
			cAlias := "SF2"
			dbSelectArea(cAlias)
			MsGoto(nRecSF)
		EndIf
		If lHistorico
			cAlsCab := cAlias
		EndIf
		MaFisEnd()
		MaFisIni((cAlias)->F2_CLIENTE,(cAlias)->F2_LOJA,IIF((cAlias)->F2_TIPO$'DB',"F","C"),(cAlias)->F2_TIPO,(cAlias)->F2_TIPOCLI,{},,,,,,,,,Iif( fisExtCmp('12.1.2310', .T.,'SF2','F2_RECISS') ,(cAlias)->F2_RECISS,""),(cAlias)->F2_CLIENT, (cAlias)->F2_LOJENT,,,,,,,,,IIF(cPaisLoc=="BRA",(cAlias)->F2_TPFRETE,NIL),,,,,,,lCalcTG,,,,lF2BTeste)

		If (cAlias)->F2_TIPO$"DB" .And. !lReprocess .And. cFunOrig <> "FISR001"
			MaFisAlt("NF_UFORIGEM",(cAlias)->F2_EST)
		Else
			MaFisAlt("NF_UFDEST",(cAlias)->F2_EST)
		EndIf
		MaFisAlt("NF_ESPECIE",(cAlias)->F2_ESPECIE)

		//-- Tratamento para o ambiente Gestao de Transporte (SIGATMS)
		If (AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE" .Or. "NFST" $ AllTrim((cAlias)->F2_ESPECIE))
			MaFisAlt("NF_PNF_COD" ,(cAlias)->F2_CLIENTE,)
			MaFisAlt("NF_PNF_LOJ" ,(cAlias)->F2_LOJA,)
			MaFisAlt("NF_PNF_UF"  ,(cAlias)->F2_EST,)
			If IntTms()
				MaFisAlt("NF_UFORIGEM",(cAlias)->F2_UFORIG) 
			Endif
			// Quando existe um valor de ICMS Retido o Tipo do Cliente deve ser o do Cliente Devedor do Frete
			If (cAlias)->F2_ICMSRET > 0
				MaFisAlt("NF_PNF_TPCLIFOR",Posicione("SA1",1,xFilial("SA1")+(cAlias)->F2_CLIENTE+(cAlias)->F2_LOJA,"A1_TIPO"))
			Else
				MaFisAlt("NF_PNF_TPCLIFOR",(cAlias)->F2_TIPOCLI,)
			EndIf
			If IntTms() .And. lReprocess
				DT6->(dbSetOrder(1))
				If DT6->(MsSeek(IIf(FWModeAccess("DT6",3) == "E" , (cAlias)->F2_FILIAL,xFilial("DT6"))+(cAlias)->F2_FILIAL+(cAlias)->F2_DOC+(cAlias)->F2_SERIE))
					MaFisAlt("NF_UFORIGEM",Posicione("DUY",1,xFilial("DUY")+DT6->DT6_CDRORI,"DUY_EST"))
					MaFisAlt("NF_UFDEST"  ,Posicione("DUY",1,xFilial("DUY")+DT6->DT6_CDRCAL,"DUY_EST"))
					If fisGetParam('MV_TMSUFPG',.F.) //--Com o MV_TMSUFPG True, gravar o Estado do Pagador do Frete
						MaFisAlt("NF_PNF_UF",Posicione("SA1",1,xFilial("SA1")+DT6->DT6_CLIDEV+DT6->DT6_LOJDEV,"A1_EST"),)
					EndIf
				EndIf
			EndIf
		EndIf

		cCliEnt	:=	aNFCab[NF_CLIENT]
		cLojEnt	:=	aNFCab[NF_LOJENT]

		dbSelectArea("SD2")
		dbSetOrder(3)

		#IFDEF TOP
		If TcSrvType()<>"AS/400" .and. !lReprocess .or. lIsSimul //Melhoria de performance para reprocessamento
			aStru   := SD2->(dbStruct())
			lQuery  := .T.
			cAlias2 := "MaFisIniNF"
			cQuery  := "SELECT SD2.*,SD2.R_E_C_N_O_ SD2RECNO FROM "+RetSqlName("SD2")+" SD2 "
			cQuery  += "WHERE "
			cQuery  += "SD2.D2_FILIAL = ? AND "
			cQuery  += "SD2.D2_DOC = ? AND "
			cQuery  += "SD2.D2_SERIE = ? AND "
			cQuery  += "SD2.D2_CLIENTE = ? AND "
			cQuery  += "SD2.D2_LOJA = ? AND "
			cQuery  += "SD2.D_E_L_E_T_= ? "
			cQuery  += "ORDER BY SD2.D2_FILIAL,SD2.D2_NUMSEQ "
			
			oMontQry := FwExecStatement():New(ChangeQuery(cQuery))

			oMontQry:SetString(nPos += 1, xFilial("SD2"))
			oMontQry:SetString(nPos += 1, (cAlias)->F2_DOC)
			oMontQry:SetString(nPos += 1, (cAlias)->F2_SERIE)
			oMontQry:SetString(nPos += 1, (cAlias)->F2_CLIENTE)
			oMontQry:SetString(nPos += 1, (cAlias)->F2_LOJA)
			oMontQry:SetString(nPos += 1, ' ')

			cAlias2 := oMontQry:OpenAlias()  

			For nX := 1 To Len(aStru)
				If aStru[nX][2]<>"C"
					TcSetField(cAlias2,aStru[nX][1],aStru[nX][2],aStru[nX][3],aStru[nX][4])
				EndIf
			Next nX
		Else
		#ENDIF
			MsSeek(xFilial("SD2")+(cAlias)->F2_DOC+(cAlias)->F2_SERIE+(cAlias)->F2_CLIENTE+(cAlias)->F2_LOJA)
		#IFDEF TOP
		EndIf
		#ENDIF
		dbSelectArea(cAlias)
		While !Eof().And. (cAlias2)->D2_FILIAL == xFilial("SD2") .And.;
			(cAlias2)->D2_DOC == (cAlias)->F2_DOC .And.;
			(cAlias2)->D2_SERIE == (cAlias)->F2_SERIE .And.;
			(cAlias2)->D2_CLIENTE == (cAlias)->F2_CLIENTE .And.;
			(cAlias2)->D2_LOJA == (cAlias)->F2_LOJA
			lISS := .F.
			If Empty(cCliEnt) .And. Empty(cLojEnt)
				SC5->(dbSetOrder(1))
				If SC5->(MsSeek(xFilial("SC5")+(cAlias2)->D2_PEDIDO))

					cCliEnt	:=	SC5->C5_CLIENT
					cLojEnt	:=	SC5->C5_LOJAENT

					MaFisAlt("NF_CLIENT", SC5->C5_CLIENT)
					MaFisAlt("NF_LOJENT", SC5->C5_LOJAENT)

					DbSelectArea("SF2")
					SF2->(DbSetOrder(1))

					If cAlias <> "SF2"
						SF2->(dbSetOrder(1))
						If SF2->(MsSeek(xFilial("SF2")+(cAlias)->F2_DOC+(cAlias)->F2_SERIE+(cAlias)->F2_CLIENTE+(cAlias)->F2_LOJA))
							RecLock("SF2",.F.)
							SF2->F2_CLIENT	:=	aNFCab[NF_CLIENT]
							SF2->F2_LOJENT	:=	aNFCab[NF_LOJENT]
							MsUnLock()
						EndIf
					Else
						SF2->(dbSetOrder(1))
						If SF2->(MsSeek(xFilial("SF2")+(cAlias)->F2_DOC+(cAlias)->F2_SERIE+(cAlias)->F2_CLIENTE+(cAlias)->F2_LOJA))
							RecLock(cAlias,.F.)
							(cAlias)->F2_CLIENT	:=	aNFCab[NF_CLIENT]
							(cAlias)->F2_LOJENT	:=	aNFCab[NF_LOJENT]
							MsUnLock()
						EndIf
					EndIf
				EndIf
			EndIf


			nY++

			If lHistorico
				cAlsItem  := cAlias2
				cAlsItem2 := cAlias2
			EndIf

			If lReprocess
				MaFisIniLoad(nY)
			Else
				MaFisIniLoad(nY,,,Iif(fisExtCmp('12.1.2310', .T.,'SD2','D2_IDTRIB'),(cAlias2)->D2_IDTRIB,""))
			EndIf

			If lReprocess
				MaFisAlt ("IT_ITEM", (cAlias2)->D2_ITEM, nY)
				If lCtaRec
					Mafisload("IT_CTAREC",(cAlias2)->D2_CTAREC,nY)
				EndIF	
			EndIf

			If !Empty((cAlias2)->D2_CODISS) .Or. (cAlias2)->D2_VALISS > 0
				lISS 	:= 	.T.
				lSoICMS	:=	.F.
				If !Empty((cAlias2)->D2_CODISS)
					aNFItem[nY][IT_RATEIOISS] := "S"
				EndIf
			EndIf

			If lReprocess .Or. (cAlias2)->D2_ORIGLAN $ "LO/VD" //Origem da venda feita no módulo do LOJA
				nDesc := LjxPesqDesc(cAlias2)
				If nDesc > 0
					If lReprocess
						MaFisAlt("IT_DESCPRO",nDesc,nY)
					EndIf
					If aNFItem[nY][IT_TS][TS_DESCOND] == "2"
						aNfItem[nY][IT_BICMORI] += aNfItem[nY][IT_DESCPRO]
						aNfItem[nY][IT_DESCPRO] := 0
					EndIf
				EndIf
			Else
				nDesc := 0
			EndIf

			For nX := 1 To Len(aOtimizacao[2])
				Do Case
					Case aOtimizacao[2][nX][2] == "IT_VALMERC"
						If cPaisLoc <> "BRA" .And. fisGetParam('MV_DESCSAI','') == "1"
							nValor := (cAlias2)->D2_TOTAL
						Else
							nValor := (cAlias2)->D2_TOTAL + (cAlias2)->D2_DESCON + nDesc
						Endif
					Case aOtimizacao[2][nX][2] == "IT_VALISS"
						nValor := IIF(lISS .And. Empty((cAlias2)->D2_VALISS) ,(cAlias2)->D2_VALICM,(cAlias2)->D2_VALISS)
					Case aOtimizacao[2][nX][2] == "IT_BASEISS"
						nValor := IIF(lISS .And. Empty((cAlias2)->D2_BASEISS),(cAlias2)->D2_BASEICM,(cAlias2)->D2_BASEISS)
					Case aOtimizacao[2][nX][2] == "IT_ALIQISS"
						nValor := IIF(lISS .And. Empty((cAlias2)->D2_ALIQISS),(cAlias2)->D2_PICM,(cAlias2)->D2_ALIQISS)
					OtherWise
						nValor := (cAlias2)->(FieldGet(FieldPos(aOtimizacao[2][nX][1])))
				EndCase
				IF !Empty(nValor)
					MaFisLoad(aOtimizacao[2][nX][2],nValor,nY)
				Endif
			Next nX

			MaFisTes(aNfItem[nY][IT_TES],aNfItem[nY][IT_RECNOSF4],nY)

			If aNFItem[nY][IT_TS][TS_AGREG] == "R"
				MaFisLoad("IT_VALMERC",(cAlias2)->D2_TOTAL + (cAlias2)->D2_DESCICM , nY)
				MaFisLoad("IT_PRCUNI", aNFitem[nY][IT_VALMERC] / aNFitem[nY][IT_QUANT] , nY)
				If cPaisLoc == "RUS"
					MaFisLoad("IT_VALMERC_C1",(cAlias2)->D2_TOTALM + xMoeda((cAlias2)->D2_DESCICM,aNfCab[NF_MOEDA,1,dDataBase,,aNfCab[NF_TXMOEDA]]) , nY)
				EndIf
			EndIf

			MaFisLoad("IT_DESCZF",(cAlias2)->D2_DESCZFR,nY)

			If nDesc > 0
				If lReprocess
					MaFisAlt("IT_DESCPRO",nDesc,nY)
					// Reprocessamento da venda.
					//    No loja nao é gravado o desconto total no d2_descon, por isso busca o nDesc(L2_DESCPRO)
					//    No D2_DESCON é gravado o desconto no item do orçamento e qdo há desconto no total e no item,
					//    tem que somar o dois valores no IT_DESCONTO
					If cFunOrig == "MATA930" .And. ((cAlias2)->D2_DESCON > 0 .Or. nDesc>0)
						MaFisAlt("IT_DESCONTO",nDesc + (cAlias2)->D2_DESCON,nY)
						MaFisAlt("IT_DESCPRO",0,nY)
					EndIf
				Else
				MaFisLoad("IT_DESCONTO", aNfItem[nY][IT_DESCONTO] + nDesc , nY)
				EndIf
			EndIf

			// Rotina usada apenas para retornar o valor do ICMS ISENTO no Relatorio DUB-ICMS
			If cFunOrig == "FISR001" .And. (cAlias2)->D2_CLASFIS $(" 40/ 41/ 50/ 90/040/041/050/090/140/141/150/190")
				aNFItem[nY][IT_TS][TS_ICM] := "S"
				MaAliqIcms(nY)
				MaFisBSICM(nY)
				MaFisVICMS(nY)
				MaItArred(nY,{"IT_VALICM"})
			EndIf

			MaFisEndLoad(nY,2)

			If lReprocess
				If cPaisLoc=="BRA"

					//Para o reprocessamento não posso passar o D2_IDTRIB no MaFisIniLoad 
					//Porque ele carrega os tributos genéricos antes de preencher as referências dos tributos legados
					aNfItem[nY][IT_ID_LOAD_TRBGEN]:= Iif(fisExtCmp('12.1.2310', .T.,'SD2','D2_IDTRIB'),(cAlias2)->D2_IDTRIB,"")

					if lCalcTG // para que ocorra o cálculo dos tributos genéricos
						lSimuRepro := .T.
						MafisLoad("IT_TES", "", nY)
						MaFisAlt("IT_TES", (cAlias2)->D2_TES, ny)
					endif

					MaFisIPI(nY,"BSE|VLR",.T.) // Calcula a Base de IPI Original
					MaExcecao(nY)
					MaFisPreCalc(nY)
					MaFisBSICM(nY,.T.)	// Calcula a Base de ICMS Original
					MaFisVICMS(nY,.T.) 	// Calcula o Valor do ICMS / Diferido

					// Não chamar as funcoes do ICMS complementar nas saidas pois
					// os valores ja foram carregados de SD2 e nao precisam ser recalculados.


					MaFisCSLL(nY)
					MaFisCofins(nY,"CF2","BSE|VLR",.T.)
					MaFisPis(nY,"PS2","BSE|VLR",.T.)
					MaFisCPRB(nY)
					MaFisISS(nY)
					//Grava valor Credito Presumido Substituicao Tributaria retido pelo contratante do servico de transporte - Decreto 44.147/2005 (MG)
					If aNFItem[nY][IT_TS][TS_CRPRST]<>0
						MaAliqSoli(nY)
						MaMargem(nY)
						MaFisVSol(nY)
						MaFisVTot(nY)
					EndIf

					//----------------------------------------------------------------------------
					//Faz carga dos tributos genéricos se o ID do tributo genérico for preenchido.
					//----------------------------------------------------------------------------
					CargaTribGen(aNFCab, aNfItem, nY, aTGITRef, aPos, aDic, aHmFor, lReprocess)
				EndIf
				MaItArred(nY,{"IT_VALCMP"})
 				MaItArred(nY,{"IT_VFECPST"})
 				MaItArred(nY,{"IT_VALFECP"})
				
				If lReprocess .And. fisExtTab('12.1.2310', .T., 'F2D')
					//Aqui chama função para refazer o livro dos tributos genéricos no reprocessamento
					ReprocTribgen(aNFItem, nY, aNFCab, aHmFor)
				EndIf

				MaFisLF(nY)
				MaFisLoad("LF_ITEMORI",(cAlias2)->D2_ITEMORI,nY) //Refaz o Item Original
			EndIf
			dbSelectArea(cAlias2)
			dbSkip()
		EndDo

		If lQuery .and.(!lReprocess .Or. !lHistorico)
			dbSelectArea(cAlias2)
			dbCloseArea()
			dbSelectArea("SD2")
		EndIf

		MaFisAlt("NF_FRETE",(cAlias)->F2_FRETE)

		If fisExtCmp('12.1.2310', .T.,'SF2','F2_VLR_FRT')
			MaFisAlt("NF_VLR_FRT",(cAlias)->F2_VLR_FRT)
		EndIf

		MaFisAlt("NF_SEGURO" ,(cAlias)->F2_SEGURO)
		MaFisAlt("NF_DESPESA",(cAlias)->F2_DESPESA)

		If fisExtCmp('12.1.2310', .T.,'SF2','F2_DESNTRB')
			MaFisAlt("NF_DESNTRB",(cAlias)->F2_DESNTRB)
		Endif

		If fisExtCmp('12.1.2310', .T.,'SF2','F2_TARA')
			MaFisAlt("NF_TARA",(cAlias)->F2_TARA)
		Endif

		MaFisLoad("NF_AUTONOMO",(cAlias)->F2_FRETAUT)

		If lSoICMS .And. cFunOrig <> "FISR001"	//Nao retirar - So devo processar este bloco se o documento fiscal conter SOMENTE ICMS.
			MaFisAlt("NF_BASEICM",(cAlias)->F2_BASEICM,)
			MaFisAlt("NF_VALICM" ,(cAlias)->F2_VALICM,)
			MaFisAlt("NF_BASEIPI",(cAlias)->F2_BASEIPI,)
			MaFisAlt("NF_VALIPI" ,(cAlias)->F2_VALIPI,)
		EndIf

		MaFisAlt("NF_VALICA"  ,(cAlias)->F2_ICMAUTO,)
		MaFisAlt("NF_FUNRURAL",(cAlias)->F2_CONTSOC,)

		If !lReprocess  .And. cFunOrig <> "FISR001"
			For nX := 1 To Len(aOtimizacao[1])
				If Empty(MaFisRet(,aOtimizacao[1][nX][2]))
					nValor := (cAlias)->(FieldGet(FieldPos(aOtimizacao[1][nX][1])))
					MaFisAlt(aOtimizacao[1][nX][2],nValor)
				ElseIf !lReprocess
					nValor := (cAlias)->(FieldGet(FieldPos(aOtimizacao[1][nX][1])))
					MaFisLoad(aOtimizacao[1][nX][2],nValor)
				EndIf
			Next nX
		EndIf
EndCase

RestArea(aAreaSD2)
RestArea(aAreaSF2)
RestArea(aAreaSD1)
RestArea(aAreaSF1)
RestArea(aArea)
lSimuRepro := .F.
Return .T.

/*FUNCOES DE CONTROLE DOS FOLDERS - LIVRO FISCAL E IMPOSTOS*/

/*
MaFisBrwLF -Edson Maricate  -13.12.1999
Objeto Browse demonstrativo dos livros fiscais
Parametros
ExpO1: Objeto ListBox a ser montado
ExpA2: Array com as coordenadas do Objeto
ExpL3: Flag de edicao livro .F. - Editavel .T. - Nao Editavel
ExpA4: Array contendo os registros do Livro Fiscal
/*/
Function MaFisBrwLivro(oWnd,aPosWnd,lVisual,aRecSF3,lOpcVisual)

Local aFixos	:= xFisAFixos()
Local aArea		:= GetArea()
Local aAreaSX3	:= SX3->(GetArea())
Local aItensLF	:= {}
Local aHeadLF	:= {}
Local aTamHead	:= {}
Local nX        := 0
Local nY        := 0
Local oLivro

DEFAULT lOpcVisual := .F.

// Inicializa os campos fixos do Livro Fiscal
If aBrwLF == Nil
	aBrwLF := {}
	SX3->(DbSetOrder(2))
	For nX := 1 To Len(aFixos)
		If SX3->(MsSeek(aFixos[nX][1]))
			aadd( aBrwLF ,{ aFixos[nX][1] , CriaVar(aFixos[nX][1],.F.) , PesqPict("SF3",aFixos[nX][1]) , X3Titulo() , TamSX3(aFixos[nX][1])[1] } )
		EndIf
	Next nX
EndIf
// Monta o cabecalho com os titulos do SF3.
For nX	:= 1 To Len(aBrwLF)
	aadd(aHeadLF,aBrwLF[nX][4])
	If aBrwLF[nX][5] > Len(aBrwLF[nX][4])
		aadd(aTamHead,aBrwLF[nX][5]*3)
	Else
		aadd(aTamHead,Len(aBrwLF[nX][4])*3)
	EndIf
Next nX
// Monta os itens de visualizacao da ListBox.
Do Case
	Case !Empty(aRecSF3)
		For nX	:= 1 To Len(aRecSF3)
			dbSelectArea("SF3")
			MsGoto(aRecSF3[nX])
			aadd(aItensLF,Array(Len(aBrwLF)))
			For nY := 1 to Len(aBrwLF)
				aItensLF[nX][nY] := &(aBrwLF[nY][1])
			Next nY
		Next nX
	Case !Empty(aNFCab)
		aItensLF := aClone(aNFCab[NF_LIVRO])
		If cPaisLoc<>"BRA"
			If !Empty(aItensLF)
				aItensLF:=Adel(aItensLF,1)
				aItensLF:=aSize(aItensLF,Len(aItensLF)-1)
			Endif
		EndIf
EndCase
If Empty(aItensLF)
	aadd(aItensLF,Array(Len(aBrwLF)))
	For nX	:= 1 To Len(aBrwLF)
		aItensLF[1][nX] := aBrwLF[nX][2]
	Next nX
EndIf

bLivroRefresh   := {|| MaFisLFNew(oLivro)}
oLivro:= TWBrowse():New( aPosWnd[1],aPosWnd[2],aPosWnd[3],aPosWnd[4],,aHeadLF,aTamHead,oWnd,,,,,,,,,,,,.F.,,.T.,,.F.,,,)
oLivro:SetArray(aItensLF)
If Len(aItensLF) > 0
	oLivro:bLine := {||MaFisLFLine(oLivro,aItensLF)}
EndIf
oLivro:lAutoEdit := !lVisual
// O aHeader contido no aHeadLF e montado apartir do aBrwLF criado pela xFisAFixos e diverge do conteudo do aNFCab[NF_LIVRO]
// O Refresh a seguir alinha o aHeadLF com o aItensLF
If bLivroRefresh <> Nil .And. Empty(aRecSF3) .And. !lOpcVisual
	Eval(bLivroRefresh)
EndIf

RestArea(aAreaSX3)
RestArea(aArea)

Return ( oLivro )

/*/
MaFisLFNew -Edson Maricate  -13.12.1999
Esta rotina tem como objetivo atualizar o array com o demonstrativo fiscal.
Browse demonstrativo dos livros fiscais
ParametrosExpO1: Objeto ListBox dos livros fiscais
/*/
Static Function MaFisLFNew(oLivro)

Local aTemp   := {}
Local aFixos  := xFisAFixos()
Local aLinha  := {}
Local nMaxBrw := Len(aBrwLF)
Local nX      := 0
Local nY      := 0
Local nZ      := 0
Local nPosCon := 0
Local nPosTES := 0
Local nMax1   := 0
Local nMax2   := 0
Local laNFCab := !(Empty(aNFCab))

If !laNFCab
	aadd(aLinha,Array(nMaxBrw))
	For nX := 1 To nMaxBrw
		aLinha[1][nX] := aBrwLF[nX][2]
	Next nX
Else
	If Len(aNFCab[NF_LIVRO])>0
		If cPaisLoc == "ARG" .and. fisFindFunc('XACTLIVFIS') .and. fisGetParam('MV_ACTLIVF',.F.)
			xActLivFis(@aAuxOri,@aNfItem,@aNfCab[NF_LIVRO],@aTes,IT_DELETED,,.T.)
			xActLivFis( ,,@aNfCab[NF_LIVRO],,,aNfCab[NF_OPERNF],.F.)
		EndIf	
		aTemp :=  aClone(aNFCab[NF_LIVRO])
	ELse
		aAdd(aTemp,MaFisRetLF())
	Endif
	If cPaisLoc<>"BRA"
		If !Empty(aTemp)
			aTemp:=Adel(aTemp,1)
			aTemp:=aSize(aTemp,Len(aTemp)-1)
		Endif
	Endif
	nMax1 := Len(aTemp)
	For nX := 1 To nMax1
		nMax2 := Min(Len(aTemp[nX]),Len(aFixos))
		aadd(aLinha,Array(nMaxBrw))
		For nY := 1 To nMax2
			nZ := aScan(aBrwLF,{|x| x[1]==aFixos[nY][1]})
			nPosCon := aScan(aBrwLF,{|x| x[1] == "F3_CONCEPT"})
			nPosTES := aScan(aBrwLF,{|x| x[1] == "F3_TES"})
			If nZ <> 0
				aLinha[nX][nZ]:= aTemp[nX][nY]
			EndIf

			If nPosCon <> 0 .And. cPaisLoc == "EQU" .AND. ALLTRIM( aBrwLF[nZ][1]) == "F3_CONCEPT" .and. ((FunName() == "MATA101N") .Or. (fisFindFunc("ChkLxProp") .and. ChkLxProp("ConceptoIRLibro")))
				If aTemp[nX][nPosTES] == MaFisRet(nX,"IT_TES")
					aLinha[nX][nPosCon]:= MaFisRet(nX,"IT_CONCEPT")
				Else
					If aLinha[nX][nPosTES] == MaFisRet(N,"IT_TES")
						aLinha[nX][nPosCon]:= MaFisRet(Nx,"IT_CONCEPT")
					Else
						aLinha[nX][nPosCon]:= MaFisRet(N,"IT_CONCEPT")
					EndIf
				endIf
			EndIf
		Next nY
	Next nX
EndIf

If ValType(oLivro)<>"U"
		oLivro:SetArray(aLinha)
		oLivro:bLine := {|| MaFisLFLine(oLivro,aLinha) }
		oLivro:Refresh()
EndIf

Return(.T.)

/*/
MaFisLFLin - Edson Maricate  -13.12.1999
Esta rotina tem como objetivo preparar a montagem da linha a ser exibida no browse do demonstrativo fiscal
Parametros
ExpO1: Objeto ListBox do Livro Fiscal
ExpA2: Array com os itens do listbox
Retorno
ExpA1: Array com a linha do demonstrativo fiscal
/*/
Static Function MaFisLFLine(oLivro,aItensLF)

Local aLinha := aItensLF[oLivro:nAt]
Local aFixos := xFisAFixos()
Local nX     := 0
Local nY     := 0
Local nMax   := Len(aFixos)

For nX := 1 To nMax
	nY := aScan(aBrwLF,{|x| x[1]==aFixos[nX][1]})
	If nY <> 0 .And. ValType(aLinha[nY]) == "N"
		If cPaisLoc == "BRA"
			If SUBS(aBrwLF[nY][1],1,10) $ "F3_VALANTI"
				aLinha[nY] := Round(aLinha[nY],MsDecimais(1))
			Else
				aLinha[nY]:= TransForm(aLinha[nY],aBrwLF[nY][3])
			EndIf
		Else
			If SUBS(aBrwLF[nY][1],1,6) $ "F3_VAL|F3_BAS|F3_RET|F3_DES"
				aLinha[nY] := Round(aLinha[nY],MsDecimais(1))
			EndIf
			aLinha[nY]:= TransForm(aLinha[nY],aBrwLF[nY][3])
		EndIf
	EndIf
Next nX

Return( aLinha )

/*/
MaFisRodape - Edson Maricate-13.12.1999
Atualiza o Array de Resumos da NF.
/*/
Function MaFisRodape(nTipo,;		// Quebra : 1 Imposto+Aliquota,  2-Imposto
	oJanela,;		// Janela onde sera montado
	aImpostos,;	// Relacao de Impostos que deverao aparecer ( Codigo )
	aPosicao,;			// Array contendo Posicao e Tamanho
	bValidPrg,;	// Validacao executada na Edicao dop Campo
	lVisual,; // So para visualizacao
	cFornIss,; //Fornecedor do ISS
	cLojaIss,; //Loja do Fornecedor do ISS
	aRecSE2,;
	cDirf,;
	cCodRet,;
	oCodRet,;
	nCombo,;
	oCombo,;
	dVencIss,; 	//Vencimento ISS
	aCodR,;
	cRecIss,;	//Informa se recolhe o ISS ou nao
	oRecIss,;
	lEditImp,;	//Edicao de impostos dos Docs.Fiscais operacao de Inclusao, MV_EDITIMP ativado, Form.Proprio N e Especie NF/NCP/NDP/NDE/NCE (LOCALIZADO)
	cDescri,;
	lAPI)		//Indica se a chamada é realizada por API e portanto não pode exibir tela.

Local oList
Local aTemp
Local aOpcoes := {"Sim","Nao"}
Local oFornIss
Local oLojaIss
Local oVencIss
Local oDescri
Local oBtn081 := Nil
Local oBtn084 := Nil
Local aAreaSE2 := {}
Local aAreaSA2 := {}
Local lFornIss := .F.
Local lVisuimp := .F.
Local nPosDum  := 0
Local aAUTOISS := {}
Local aMaPCCI  := {}
Local nI       := 0
Local nPosCodR := 0
Local aOpcIss  := {"1="+STR0024,"2="+STR0025}
Local nPosImp  := 0
Local nTamForn := (FisTamSX3( 'SE2','E2_FORNISS' )[1]*4)
Local nTamLoja := (FisTamSX3( 'SE2','E2_LOJAISS' )[1]*4)
Local lTamForn :=  FisTamSX3( 'SE2','E2_FORNISS' )[1]>6
Local lTamLoja :=  FisTamSX3( 'SE2','E2_LOJAISS' )[1]>2
Local lRotina  := IsInCallStack("MATA103") .Or. FunName()$"MATA119/PMSA300/MATA116/MATA140" .Or. IsInCallStack("A120TRACK")
Local cVersao := GetVersao(.F.)
Local lMata101n := .F.
Local nCount := 0

DEFAULT oCodRet := Nil
DEFAULT oCombo  := Nil
DEFAULT nCombo  := 2
DEFAULT dVencIss:= CtoD("")
DEFAULT aCodR	:= {}
DEFAULT oRecIss := Nil
DEFAULT cRecIss := "1"
Default lEditImp := .F.
Default lAPI     := .F.

// Ao utilizar o Protheus com varias Filiais e possivel que em alguns processos como o de inclusao de Notas Fiscais o usuario altere
// a filial atraves da Dialog de seleçao de filiais, com isso se faz necessario que os parametros SX6 sejam novamente carregados para
// a filial corrente refazendo o cache realizado na variavel aSX6, esta nova carga e controlada pela variavel cSX6FilAnt
// Tratativa da empresa (cempant) logada para tratar clientes que não tem cadastrada a Gestão de empresas.
//If cSX6FilAnt <> cFilAnt .Or. cSX6EmpAnt <> cEmpAnt
//	aSX6 := GParMxFis(@cSX6FilAnt,@cSX6EmpAnt)
//EndIf

aAUTOISS := &(fisGetParam('MV_AUTOISS','{"","","",""}'))

If nTipo == 1
	If Empty(aNfCab) .Or. Empty(aNfCab[NF_IMPOSTOS])
		aTemp	:= {{"","",0,0,0,""}}
	Else
	    If lVisual
	        For nPosImp := 1 to Len(aNFCab[NF_IMPOSTOS])
                If Alltrim(aNFCab[NF_IMPOSTOS][nPosImp][1]) == "IRR" .And. aNFCab[NF_IMPOSTOS][nPosImp][4] == 0
                    MaFisIR(1,"ALQ",,lVisual)
                    aNFCab[NF_IMPOSTOS][nPosImp][4] := aNfItem[1][IT_ALIQIRR]
                EndIf
	        Next nPosImp
	    EndIf
		aTemp	:= aNFCab[NF_IMPOSTOS]
	EndIf
Else
	If Empty(aNfCab) .Or. Empty(aNfCab[NF_IMPOSTOS2])
		aTemp	:= {{"","",0,0,""}}
	Else
		aTemp	:= aNFCab[NF_IMPOSTOS2]
	EndIf
EndIf

If !lAPI

	bFisRefresh	:= {|| MaFisRRefresh(oList,nTipo,oFornISS,@cFornISS,oLojaISS,@cLojaISS,oRecISS,@cRecISS,oVencISS,@dVencISS,@cDescri,oDescri)}

	If fisExtCmp('12.1.2310', .T.,'SE2','E2_FORNISS') .And. fisExtCmp('12.1.2310', .T.,'SE2','E2_LOJAISS')
		If cFornIss <> NIL .And. cLojaIss <> NIL
			lFornIss := .T.
			aPosicao[2] := 85
			aPosicao[3] -= 80
			@ 03,02 TO 58, (Iif (lTamForn, nTamForn+52,84 )+ Iif (lTamLoja,9,0)) LABEL '' OF oJanela PIXEL
			@ 06,10 SAY STR0023 Of oJanela PIXEL SIZE 80,09 //"Dados de Cobrança do ISS"
			@ 19,04 SAY RetTitle("E2_FORNISS") Of oJanela PIXEL SIZE 30,09

			If fisExtCmp('12.1.2310', .T.,'SE2','E2_VENCISS')
				@ 46,04 SAY RetTitle("E2_VENCISS")Of oJanela PIXEL SIZE 30,09
			EndIf

			If lVisual
				If Len(aRecSE2) > 0
					aAreaSE2 := SE2->(GetArea())
					aAreaSA2 := SA2->(GetArea())

					for nCount := 1 to len(aRecSE2)
						SE2->(dbGoTo(aRecSE2[nCount]))
						if !Empty(SE2->E2_FORNISS) .and. !Empty(SE2->E2_LOJAISS)
							cFornIss := SE2->E2_FORNISS
							cLojaIss := SE2->E2_LOJAISS
							SE2->(dbGoTo(aRecSE2[1]))
							exit // sai do laço
						endif
					Next nCount

					If SA2->(MsSeek(xFilial("SA2")+cFornIss+cLojaIss))
						cDescri := SA2->A2_NREDUZ
					Endif
					If fisExtCmp('12.1.2310', .T.,'SE2','E2_VENCISS')
						dVencIss := SE2->E2_VENCISS
					EndIf

					If cPaisLoc=="BRA"
						If !Empty( SE2->E2_CODRPIS )
							aAdd( aMaPCCI , {"PIS",SE2->E2_CODRPIS} )
						EndIf
						If !Empty( SE2->E2_CODRCOF )
							aAdd( aMaPCCI , {"COF",SE2->E2_CODRCOF} )
						EndIf
						If !Empty( SE2->E2_CODRCSL )
							aAdd( aMaPCCI , {"CSL",SE2->E2_CODRCSL} )
						EndIf
						If !Empty( SE2->E2_CODRET )
							aAdd( aMaPCCI , {"IRR",SE2->E2_CODRET} )
						EndIf
					Endif

					For nI := 1 To Len( aTemp )
						If (nTipo==1)
							If (nPosCodR := aScan(aMaPCCI, {|aX|aX[1]==aTemp[nI][6]}))>0
								aAdd( aCodR, {nI, aMaPCCI[nPosCodR][2], 1, aTemp[nI][6]} )
							EndIf
						Else
							If (nPosCodR := aScan(aMaPCCI, {|aX|aX[1]==aTemp[nI][5]}))>0
								aAdd( aCodR, {nI, aMaPCCI[nPosCodR][2], 1, aTemp[nI][5]} )
							EndIf
						EndIf
					Next
					RestArea(aAreaSE2)
					RestArea(aAreaSA2)
				Endif

				@ 18,31 MSGET oFornIss VAR cFornIss PICTURE PesqPict('SE2','E2_FORNISS') OF oJanela PIXEL SIZE IIf(lTamForn, nTamForn,35),09 READONLY
				@ 18,Iif(lTamForn, nTamForn+35,67) MSGET oLojaIss VAR cLojaIss PICTURE PesqPict('SE2','E2_LOJAISS') OF oJanela PIXEL SIZE IIf(lTamLoja, nTamLoja,15),09 READONLY

				If fisExtCmp('12.1.2310', .T.,'SE2','E2_VENCISS')
					@ 44,38 MSGET oVencIss VAR dVencIss OF oJanela PIXEL READONLY
				EndIf
			Else
				If !Empty(cFornISS) .And. !Empty(cLojaISS)
					aAreaSA2 := SA2->(GetArea())
					If SA2->(MsSeek(xFilial("SA2")+cFornIss+cLojaIss))
						cDescri := SA2->A2_NREDUZ
					Endif
					RestArea(aAreaSA2)
				Endif
				@ 18,31 MSGET oFornIss VAR cFornIss PICTURE PesqPict('SE2','E2_FORNISS') OF oJanela PIXEL SIZE IIf(lTamForn, nTamForn,35),09 F3 CpoRetF3('E2_FORNISS') ;
				VALID MaVldForn(@cFornIss,@cLojaIss,@oDescri,@cDescri,@oLojaISS,@oFornIss,1)
				@ 18,IIf(lTamForn, nTamForn+35,67) MSGET oLojaIss VAR cLojaIss PICTURE PesqPict('SE2','E2_LOJAISS') OF oJanela PIXEL SIZE Iif(lTamLoja, nTamLoja,15),09 F3 CpoRetF3('E2_LOJAISS') ;
				VALID MaVldForn(@cFornIss,@cLojaIss,@oDescri,@cDescri,@oLojaISS,@oFornIss,2)
				If fisExtCmp('12.1.2310', .T.,'SE2','E2_VENCISS')
					@ 44,31 MSGET oVencIss VAR dVencIss OF oJanela PIXEL
				EndIf
			EndIf
			@ 31,04 MSGET oDescri VAR cDescri OF oJanela PIXEL SIZE 78,09 WHEN .F.
		Endif
	Endif

	If fisGetParam('MV_VISDIRF','1') == "1"
		If cDirf <> NIL .And. cCodRet <> NIL

		If lVisual
			cCodRet 	:= Space(FisTamSX3( 'SE2','E2_CODRET')[1])
			cDirf   	:= "2"
		Else
				cDirf 	:= CriaVar("E2_DIRF",.T.)
				cCodRet := CriaVar("E2_CODRET")
				If aAutoISS<>Nil .And. Len(aAutoISS)==4 .And. !Empty(aAutoISS[03])
					cDirf 	:= aAutoISS[03]
					cCodRet	:= aAutoISS[04]
				EndIf
			Endif

			nCombo	:= aOpcoes[VAL(Iif((cDirf$"1|2"),cDirf,"2"))]
			nTamForn := IIf(lTamForn, nTamForn,0)

		If lFornIss

				aPosicao[2] := 170
				aPosicao[3] -= 74
				//Configuração do quando Dirf
				If cVersao <> "12"
					@ 03,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0)) TO 42,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0))  LABEL '' OF oJanela PIXEL
					@ 06,(Iif (lTamForn, nTamForn+90,120)+Iif (lTamLoja,10,0)) SAY "DIRF" Of oJanela PIXEL SIZE 80,Iif (lTamForn, nTamForn+09,09) //"Dados de Cobrança do ISS"
					@ 16,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0)) SAY RetTitle("E2_DIRF") Of oJanela PIXEL SIZE 30,Iif (lTamForn, nTamForn+09,09)
					@ 16,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSCOMBOBOX oCombo VAR nCombo ITEMS aOpcoes ON CHANGE (cDirf := StrZero(oCombo:nAt,1)) VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.F.) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
					@ 27,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0)) SAY RetTitle("E2_CODRET") Of oJanela PIXEL SIZE 50,Iif (lTamForn, nTamForn+09,09)
					@ 27,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSGET oCodRet VAR cCodRet F3 "37" VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.T.) WHEN !lVisual OF oJanela PIXEL SIZE 40,09
					@ 42,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0)) TO 58,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0))  LABEL '' OF oJanela PIXEL
					@ 47,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))  SAY RetTitle("A2_RECISS") Of oJanela PIXEL SIZE 50,Iif (lTamForn, nTamForn+09,09)
					@ 46,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSCOMBOBOX oRecIss VAR cRecIss ITEMS aOpcIss VALID MaFisAlt( "NF_RECISS", cRecIss) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
				Else
				@ 03,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0)) TO 48,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0))  LABEL '' OF oJanela PIXEL
					@ 06,(Iif (lTamForn, nTamForn+90,120)+Iif (lTamLoja,10,0)) SAY "DIRF" Of oJanela PIXEL SIZE 80,09 //"Dados de Cobrança do ISS"
					@ 16,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0)) SAY RetTitle("E2_DIRF") Of oJanela PIXEL SIZE 30,09
					@ 16,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSCOMBOBOX oCombo VAR nCombo ITEMS aOpcoes ON CHANGE (cDirf := StrZero(oCombo:nAt,1)) VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.F.) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
					@ 35,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0)) SAY RetTitle("E2_CODRET") Of oJanela PIXEL SIZE 50,09
					@ 34,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSGET oCodRet VAR cCodRet F3 "37" VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.T.) WHEN !lVisual OF oJanela PIXEL SIZE 40,09
					@ 49,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0)) TO 70,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0))  LABEL '' OF oJanela PIXEL
					@ 55,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0)) SAY RetTitle("A2_RECISS") Of oJanela PIXEL SIZE 50,09
					@ 52,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSCOMBOBOX oRecIss VAR cRecIss ITEMS aOpcIss VALID MaFisAlt( "NF_RECISS", cRecIss) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
				EndIf

				aPosicao[2] -= 41

			Else

				aPosicao[2] := 129
				aPosicao[3] -= 74
				//Configuração do quando Dirf
				If cVersao <> "12"
					@ 03,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0))TO 42,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0)) LABEL '' OF oJanela PIXEL
					@ 06,(Iif (lTamForn, nTamForn+90,120)+Iif (lTamLoja,10,0)) SAY "DIRF" Of oJanela PIXEL SIZE 80,Iif (lTamForn, nTamForn+09,09) //"Dados de Cobrança do ISS"
					@ 16,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))SAY RetTitle("E2_DIRF") Of oJanela PIXEL SIZE 30,Iif (lTamForn, nTamForn+09,09)
					@ 16,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSCOMBOBOX oCombo VAR nCombo ITEMS aOpcoes ON CHANGE (cDirf := StrZero(oCombo:nAt,1)) VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.F.) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
					@ 27,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))SAY RetTitle("E2_CODRET") Of oJanela PIXEL SIZE 50,Iif (lTamForn, nTamForn+09,09)
					@ 27,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0))MSGET oCodRet VAR cCodRet F3 "37" VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.T.) WHEN !lVisual OF oJanela PIXEL SIZE 40,09
					@ 42,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0))TO 58,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0))  LABEL '' OF oJanela PIXEL
					@ 47,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))SAY RetTitle("A2_RECISS") Of oJanela PIXEL SIZE 50,Iif (lTamForn, nTamForn+09,09)
					@ 46,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0))MSCOMBOBOX oRecIss VAR cRecIss ITEMS aOpcIss VALID MaFisAlt( "NF_RECISS", cRecIss) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
				Else
					@ 03,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0))TO 48,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0)) LABEL '' OF oJanela PIXEL
					@ 06,(Iif (lTamForn, nTamForn+90,120)+Iif (lTamLoja,10,0)) SAY "DIRF" Of oJanela PIXEL SIZE 80,09 //"Dados de Cobrança do ISS"
					@ 16,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))SAY RetTitle("E2_DIRF") Of oJanela PIXEL SIZE 30,09
					@ 16,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSCOMBOBOX oCombo VAR nCombo ITEMS aOpcoes ON CHANGE (cDirf := StrZero(oCombo:nAt,1)) VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.F.) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
					@ 35,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))SAY RetTitle("E2_CODRET") Of oJanela PIXEL SIZE 50,09
					@ 34,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0))MSGET oCodRet VAR cCodRet F3 "37" VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.T.) WHEN !lVisual OF oJanela PIXEL SIZE 40,09
					@ 49,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0))TO 70,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0))  LABEL '' OF oJanela PIXEL
					@ 55,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))SAY RetTitle("A2_RECISS") Of oJanela PIXEL SIZE 50,09
					@ 52,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0))MSCOMBOBOX oRecIss VAR cRecIss ITEMS aOpcIss VALID MaFisAlt( "NF_RECISS", cRecIss) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
				EndIf

			Endif
		Endif
	Endif

	If cPaisLoc <> "BRA" .and. lEditImp .and. fisFindFunc( "FISA081" ) .and. fisFindFunc( "FISA084" )
		aPosicao[2] := 85
		aPosicao[3] -= 80
		@ 03,02 To 58,( Iif( lTamForn, nTamForn + 52, 84 ) + Iif( lTamLoja, 9, 0 ) ) LABEL STR0042 Of oJanela Pixel //"Editarimposto"
		@ 13,12 Button oBtn081 Prompt STR0043 Action FISA081( oList ) Size 60,10 Of oJanela Pixel //"PorItem"
		@ 38,12 Button oBtn084 Prompt STR0044 Action FISA084( oList ) Size 60,10 Of oJanela Pixel //"PorImposto"
	EndIf

	IF IsInCallStack( "MATA920" ) .or. IsInCallStack( "MATA910" )
		If nTipo == 1
			oList := TWBrowse():New( aPosicao[1]-2,Iif(lTamForn .And. lRotina, aPosicao[2]+(nTamForn+nTamLoja),Iif(fisGetParam('MV_VISDIRF','1') == "1" .And. lRotina,Iif(lTamLoja,aPosicao[2]+51,aPosicao[2]+41),aPosicao[2])),Iif(lTamForn .And. lRotina, aPosicao[3]+32-(nTamForn+nTamLoja),Iif(fisGetParam('MV_VISDIRF','1') == "1" .And. lRotina,aPosicao[3]-10,Iif(!Empty(aNfCab).and.aNfCab[NF_OPERNF]=="S",aPosicao[3],aPosicao[3]+41))),aPosicao[4]+2,,{STR0003,STR0004,STR0005,STR0006,STR0007},{30,90,50,30,50},oJanela,,,,,,,,,,,,.F.,,.T.,,.F.,,, ) //"Cod."###"Descricao"###"Base Imposto"###"Aliquota"###"Vlr. Imposto"
		Else
			oList := TWBrowse():New( aPosicao[1]-2,Iif(lTamForn .And. lRotina, aPosicao[2]+(nTamForn+nTamLoja),Iif(fisGetParam('MV_VISDIRF','1') == "1" .And. lRotina,Iif(lTamLoja,aPosicao[2]+51,aPosicao[2]+41),aPosicao[2])),Iif(lTamForn .And. lRotina, aPosicao[3]+32-(nTamForn+nTamLoja),Iif(fisGetParam('MV_VISDIRF','1') == "1" .And. lRotina,aPosicao[3]-10,Iif(!Empty(aNfCab).and.aNfCab[NF_OPERNF]=="S",aPosicao[3],aPosicao[3]+41))),aPosicao[4]+2,,{STR0003,STR0004,STR0005,STR0007},{30,90,50,50},oJanela,,,,,,,,,,,,.F.,,.T.,,.F.,,, ) //"Cod."###"Descricao"###"Base Imposto"###"Vlr. Imposto"
		EndIf
	Else
		If nTipo == 1
			oList := TWBrowse():New( aPosicao[1]-2,Iif(lTamForn .And. lRotina, aPosicao[2]+(nTamForn+nTamLoja),Iif(fisGetParam('MV_VISDIRF','1') == "1" .And. lRotina,Iif(lTamLoja,aPosicao[2]+51,aPosicao[2]+41),Iif(fisGetParam('MV_VISDIRF','1') == "2"  .OR. Empty(fisGetParam('MV_VISDIRF','1')),aPosicao[2],iif(!Empty(aNfCab).and.aNfCab[NF_OPERNF]=="S",aPosicao[2],aPosicao[2]+41)))),Iif(lTamForn .And. lRotina, aPosicao[3]+32-(nTamForn+nTamLoja),Iif(fisGetParam('MV_VISDIRF','1') == "1" .And. lRotina,aPosicao[3]-10,Iif(fisGetParam('MV_VISDIRF','1') == "2",aPosicao[3],iif(!Empty(aNfCab).and.aNfCab[NF_OPERNF]=="S",aPosicao[3],aPosicao[3]-10)))),aPosicao[4]+2,,{STR0003,STR0004,STR0005,STR0006,STR0007},{30,90,50,30,50},oJanela,,,,,,,,,,,,.F.,,.T.,,.F.,,, ) //"Cod."###"Descricao"###"Base Imposto"###"Aliquota"###"Vlr. Imposto"
		Else
			lmata101n := IsInCallStack("MATA101N")
			oList := TWBrowse():New( aPosicao[1]-2,Iif(lTamForn .And. lRotina, aPosicao[2]+(nTamForn+nTamLoja),Iif(fisGetParam('MV_VISDIRF','1') == "1" .And. lRotina,Iif(lTamLoja,aPosicao[2]+51,aPosicao[2]+41),Iif(fisGetParam('MV_VISDIRF','1') == "2" .OR.  lMata101n .OR. Empty(fisGetParam('MV_VISDIRF','1')),aPosicao[2],iif(!Empty(aNfCab).and.aNfCab[NF_OPERNF]=="S",aPosicao[2],aPosicao[2]+41)))),Iif(lTamForn .And. lRotina, aPosicao[3]+32-(nTamForn+nTamLoja),Iif(fisGetParam('MV_VISDIRF','1') == "1" .And. lRotina,aPosicao[3]-10,Iif(fisGetParam('MV_VISDIRF','1') == "2",aPosicao[3],iif(!Empty(aNfCab).and.aNfCab[NF_OPERNF]=="S",aPosicao[3],aPosicao[3]-10)))),aPosicao[4]+2,,{STR0003,STR0004,STR0005,STR0007},{30,90,50,50},oJanela,,,,,,,,,,,,.F.,,.T.,,.F.,,, ) //"Cod."###"Descricao"###"Base Imposto"###"Vlr. Imposto"
		EndIf
	EndIf

	If cPaisLoc == "ARG"
		nPosDum	:=	Ascan(aTemp,{|x| x[1] == "DUM"})
		If nPosDum > 0
			aDel(aTemp,nPosDum)
			aSize(aTemp,Len(aTemp)-1)
		Endif
	Endif

	oList:SetArray(aTemp)

	If fisExtPE('VISUIMP')
		lVisuimp := ExecBlock("VISUIMP",.F.,.F.,{lVisuimp})
	Endif

	If !lVisual .And. !lVisuimp
		oList:bLDblClick 	:= {|| MaFisVRodape(oList,bValidPrg,nTipo,oList:nColPos) .And. MaFisInsereImp(oList,bValidPrg,nTipo)}
	EndIf

	oList:bChange 		:= {|| MaAtuCdR(@cCodRet,aCodR,oList,oCodRet,oCombo,@nCombo,aOpcoes)}
	oList:bLine 		:= {|| MaFisLine(oList,aTemp,nTipo) }
	oList:lAutoEdit	:= !lVisual .And. !lVisuimp
EndIf

If lAPI
	Return aClone(aTemp)
Else
	Return oList
EndIf

/*/
MaFisVRoda - Edson Maricate -13.12.1999
Atualiza o Array de Resumos da NF.
/*/
Function MaFisVRodape(oList,bValidPrg,nTipo,nCol)

Local cIniCpo   := ""
Local nPos      := oList:nAT
Local nBaseAnt  := 0
Local nBase     := 0
Local nVal      := 0
Local nLiv	    := 0
Local lEditaVal := .F.
Local lEditaBas	:= .F.
Local nDec		:= IIf( MaFisFound("NF") , MsDecimais(Max(aNFCab[NF_MOEDA],1)) , 2 )
Local cPictGet	:= '@E 999,999,999' + IIf( nDec > 0 , "." + Replicate("9",nDec) , "" )
Local lZerouCMP := .F.
Local cImpuesto := ""
Local lTribGen  := cPaisLoc == "BRA" .And. MaFisFound("NF") .And. IIf(nTipo==1,AllTrim(MaFisRet(,'NF_IMPOSTOS')[nPos][6])=="TG", AllTrim(MaFisRet(,'NF_IMPOSTOS2')[nPos][5])=="TG")
Local cNamImp	:=  MaFisRet(,'NF_IMPOSTOS')[nPos][1] 

Private nValBck	:= 0
Private nValAnt := 0
Private cImposto:= ""
DEFAULT nCol := 0

If MaFisFound("NF") .And. Len( aNFCab[NF_IMPOSTOS] ) > 0 .And. IIf(nTipo==1,MaFisVldAlt(MaFisRet(,'NF_IMPOSTOS')[nPos][6]),MaFisVldAlt(MaFisRet(,'NF_IMPOSTOS')[nPos][5]))

	nBaseAnt := IIf(nTipo==1,aNFCab[NF_IMPOSTOS][nPos][3],aNFCab[NF_IMPOSTOS2][nPos][3])
	nBase    := nBaseAnt

	lEditaVal:= IIf(aScan(aNfCab[NF_RELIMP],{|x|x[3]==AllTrim('IT_VAL'+IIf(nTipo==1,IIf('IT_VAL'+MaFisRet(,'NF_IMPOSTOS')[nPos][6] == "IT_VALCID",MaFisRet(,'NF_IMPOSTOS')[nPos][2],MaFisRet(,'NF_IMPOSTOS')[nPos][6]),MaFisRet(,'NF_IMPOSTOS2')[nPos][5]))})>0 ;
	.Or.  aScan(aNfCab[NF_RELIMP],{|x|x[3]==AllTrim('NF_VAL'+IIf(nTipo==1,MaFisRet(,'NF_IMPOSTOS')[nPos][6],MaFisRet(,'NF_IMPOSTOS2')[nPos][5]))})>0 ,.T.,.F.) ;
	.Or. MaFisRet(,'NF_IMPOSTOS')[nPos][6]=="RUR";
	.Or. MaFisRet(,'NF_IMPOSTOS')[nPos][6]=="SENAR";
	.Or. lTribGen

	If cPaisLoc <> "BRA"
		lEditaBas := .F.
	Else
		lEditaBas:= IIf(aScan(aNfCab[NF_RELIMP],{|x|x[3]==AllTrim('IT_BASE'+IIf(nTipo=1,MaFisRet(,'NF_IMPOSTOS')[nPos][6],MaFisRet(,'NF_IMPOSTOS2')[nPos][5]))})>0 ;
		.Or.  aScan(aNfCab[NF_RELIMP],{|x|x[3]==AllTrim('NF_BASE'+IIf(nTipo=1,MaFisRet(,'NF_IMPOSTOS')[nPos][6],MaFisRet(,'NF_IMPOSTOS2')[nPos][5]))})>0 ;
		.Or. lTribGen ,.T.,.F.)
	Endif

	// Monta a Edicao da Base do imposto
	If lEditaBas .And. ( nCol == 0 .Or. nCol == 3)
		MaFisEditCell(@nBase,oList,cPictGet,3,'Positivo()')
		If nBaseAnt <> nBase
			If nTipo == 1
				If lTribGen
					MaFisAlt("IMP_TRIBGEN",nBase,nPos,,,,,,,{MaFisRet(,'NF_IMPOSTOS')[nPos][1],"TG_IT_BASE"})
					lEditaVal := Len(aNFCab[NF_IMPOSTOS]) >= nPos
				Else
					cIniCpo	:= 'IMP_BASE'
					MaFisAlt('IMP_BASE'+MaFisRet(,'NF_IMPOSTOS')[nPos][6],nBase,nPos)
					If Len(aNFCab[NF_IMPOSTOS]) >= nPos
						If nBase > 0
							aNFCab[NF_IMPOSTOS][nPos][3] := nBase
						EndIf
					Else
						lEditaVal := .F.
					EndIf
				EndIf
			Else
				If lTribGen
					MaFisAlt("NF_TRIBGEN",nBase,nPos,,,,,,,{MaFisRet(,'NF_IMPOSTOS2')[nPos][1],"TG_NF_BASE"})
					lEditaVal := Len(aNFCab[NF_IMPOSTOS2]) >= nPos
				Else
					cIniCpo	:= 'NF_BASE'
					MaFisAlt('NF_BASE'+MaFisRet(,'NF_IMPOSTOS2')[nPos][5],nBase,nPos)
					If Len(aNFCab[NF_IMPOSTOS2]) >= nPos
						aNFCab[NF_IMPOSTOS2][nPos][3] := nBase
					Else
						lEditaVal := .F.
					EndIf
				EndIf
			EndIf
			Eval(bValidPrg)
			MaFisRRefresh(oList,nTipo)
		EndIf
	EndIf

	If lEditaVal
		nLiv:=NumCpoImpVar(Subs(IIf(nTipo==1,aNFCab[NF_IMPOSTOS][nPos][6],aNFCab[NF_IMPOSTOS2][nPos][5]),3,1))
		If nLiv > 0
			nValBck := aNFCab[NF_VLRORIG][nLiv]
		EndIf
		nValAnt	:= IIf(nTipo==1,aNFCab[NF_IMPOSTOS][nPos][5],aNFCab[NF_IMPOSTOS2][nPos][4])
		nVal	:= nValAnt
		If cPaisLoc=="BRA"
			MaFisEditCell(@nVal,oList,cPictGet,IIf(nTipo==1,5,4),'Positivo()')
		Else
			cImposto:= IIf(nTipo==1,aNFCab[NF_IMPOSTOS][nPos][1],aNFCab[NF_IMPOSTOS2][nPos][1])
			MaFisEditCell(@nVal,oList,cPictGet,IIf(nTipo==1,5,4),'LocxValImp(ReadVar(),nValBck,cImposto)')
		Endif
		If nValAnt<>nVal
			If nTipo == 1
				If lTribGen
					MaFisAlt("IMP_TRIBGEN",nVal,nPos,,,,,,,{MaFisRet(,'NF_IMPOSTOS')[nPos][1],"TG_IT_VALOR"})
				Else
					// Verifico se zerou o valor de ICMS Complementar, pois como o mesmo nao tem
					// base de calculo se o valor for zerado o tributo eh eliminado da listagem.
					// Se for o caso nao posso utilizar o "nPos" p/ indexar o NF_IMPOSTOS pois o
					// nro de elementos nao eh mais o mesmo, visto que foi removida uma linha.
					If MaFisRet(,'NF_IMPOSTOS')[nPos][6] == "CMP" .And. nVal == 0
						lZerouCMP := .T.
					EndIf
					MaFisAlt('IMP_VAL'+IIf('IMP_VAL'+MaFisRet(,'NF_IMPOSTOS')[nPos][6] == "IMP_VALCID",MaFisRet(,'NF_IMPOSTOS')[nPos][2],MaFisRet(,'NF_IMPOSTOS')[nPos][6]),nVal,nPos)
					If !lZerouCMP
						If Len(aNFCab[NF_IMPOSTOS]) >= nPos .and. MaFisRet(,'NF_IMPOSTOS')[nPos][1] == cNamImp
							aNFCab[NF_IMPOSTOS][nPos][5] := nVal
						Endif
					EndIf
				EndIf
			Else
				If lTribGen
					MaFisAlt("NF_TRIBGEN",nVal,nPos,,,,,,,{MaFisRet(,'NF_IMPOSTOS2')[nPos][1],"TG_NF_VALOR"})
				Else
					If MaFisRet(,'NF_IMPOSTOS2')[nPos][5] == "CMP" .And. nVal == 0
						lZerouCMP := .T.
					EndIf
					cImpuesto := MaFisRet(,'NF_IMPOSTOS2')[nPos][1]
					MaFisAlt('NF_VAL'+MaFisRet(,'NF_IMPOSTOS2')[nPos][5],nVal,nPos)
					If !lZerouCMP
						If cPaisLoc == "ARG"
							nPos := ASCAN(MaFisRet(,'NF_IMPOSTOS2'),{|X| X[1] == cImpuesto})
						EndIf
						If Len(aNFCab[NF_IMPOSTOS2]) >= nPos
							aNFCab[NF_IMPOSTOS2][nPos][4] := nVal
						Endif
					EndIf
				EndIf
			EndIf
			Eval(bValidPrg)
			MaFisRRefresh(oList,nTipo)
			If nLiv > 0
				aNFCab[NF_VLRORIG][nLiv]:=nValBck
			EndIf
		EndIf
	EndIf
EndIf

Return .T.

/*
MaVldForn      Nereu H. Jr. Microsiga  Data   12/09/03
Desc.      Valida fornecedor no momento da transferencia de fornecedor
           na implantacao do titulo de ISS
*/
Static Function MaVldForn(cFornIss,cLojaIss,oDescri,cDescri,oLojaISS,oFornIss,nTipo)
Local lRet := .F.
Local aAreaSA2 := SA2->(GetArea())

If Empty(cFornIss)
	cLojaISS:= Space(Len(cLojaIss))
	lRet    := .T.
	cDescri := ""
	oDescri:Refresh()
Else
	dbSelectArea("SA2")
	dbSetOrder(1)
	If MsSeek(xFilial("SA2")+cFornIss+cLojaIss)
		cDescri:= SA2->A2_NREDUZ
		lRet   := .T.
		oDescri:Refresh()
	Else
		If nTipo == 1
			lRet := .T.
		Else
			lRet := .F.
		Endif
		cDescri := ""
	Endif
EndIf

If nTipo == 2 .And. Empty(cLojaIss) .And. !Empty(cFornIss)
	cFornISS := Space(Len(cFornIss))
	lRet     := .T.
	cDescri  := ""
	oDescri:Refresh()
	oFornIss:Refresh()
Endif

IF lRet .And. !Empty(cFornISS) .And. !RegistroOk("SA2")
	lRet     := .F.
EndIf

RestArea(aAreaSA2)
Return(lRet)

/*/
MaFisVldAlt - Edson Maricate-02.02.2000
Verifica a referencia e se a mesma pode ser alterada.
/*/
Function MaFisVldAlt(cReferencia,nItem)
Local lRet := .T.

If cPaisLoc == "BRA"
	Do Case
		Case aNfCab[NF_TIPONF] == "I" .And. Alltrim(cReferencia)$"IT_QUANT#IT_VALICM#NF_VALICM"
		
			Help("   ",1,"COMPICM")
			lRet := .F.
		Case aNfCab[NF_TIPONF] == "P" .And. AllTrim(cReferencia)$"IT_BASEIPI#NF_BASEIPI#IT_VALIPI#NF_VALIPI#IT_QUANT"
			Help("   ",1,"COMPIPI")
			lRet := .F.
		 //Alteração feita em conjunto com materiais e faturamento, para que no complemento de preço
		//	seja possível informar a quantidade.
		Case aNfCab[NF_TIPONF] == "C" .And. AllTrim(cReferencia)$"IT_QUANT"
			If aNfCab[NF_TPCOMPL] == '1' .OR. EmpTy(aNfCab[NF_TPCOMPL])
				Help("   ",1,"COMPPRC")
				lRet := .F.
			ElseIF aNfCab[NF_TPCOMPL] == '3'
				Help("   ",1,"COMPFRT")
				lRet := .F.
			EndIF
		// Campos soh podem ser alterados em NF's de complemento de ICMS/DIFAL
		Case (aNfCab[NF_TIPONF] <> "I" .And. (AllTrim(cReferencia) == "IT_ALFCCMP" .Or.;
											  AllTrim(cReferencia) == "IT_VFCPDIF" .Or.;
											  AllTrim(cReferencia) == "IT_ALIQFECP" .Or.;
											  AllTrim(cReferencia) == "IT_VALFECP" .Or.;
											  AllTrim(cReferencia) == "IT_BASEDES" .Or.;
											  AllTrim(cReferencia) == "IT_DIFAL"))
			MsgInfo(STR0048 + STR0049)
			lRet := .F.
	EndCase
Else
	If nItem <> NIL .And. !Empty(aNfItem[nItem][IT_REMITO]) .And. Alltrim(cReferencia)$"IT_PRODUTO"
		Help("   ",1,"LOCXNF0003")
		lRet := .F.
	Endif
Endif

Return lRet

/*/
MaFisLine - Edson Maricate  -13.12.1999
Retorna a linha de exibicao do ListBox atualizado.
*/
Function MaFisLine(oList,aTemp,nTipo)
Local aRet,nDec
Local cPictAliq	:= IIf(cPaisLoc="BRA", "@E 999.99", PesqPict("SFB","FB_ALIQ"))
Local cPictVal	:= ""
Local nVlrPis	:= IIf(cPaisLoc="BRA" .AND. fisExtCmp('12.1.2310', .T.,'SB1','B1_VLR_PIS'), TamSX3("B1_VLR_PIS")[02], 0)
Local nPPis		:= TamSX3("B1_PPIS")[02]
Local cPictAlDef:=cPictAliq
Local nDecAliq
Local cVlrAliq
Local nPosVg
Local naTemp

If fisGetParam('MV_DECALIQ',.F.)
	cPictAliq	:= IIf(cPaisLoc="BRA",IIF(nVlrPis > nPPis, PesqPict("SB1","B1_VLR_PIS"),PesqPict("SB1","B1_PPIS")),PesqPict("SFB","FB_ALIQ"))
EndIf

If cPaisLoc="BRA" .And. cPictAliq==cPictAlDef
	nPosVg  :=RAt(".",cPictAliq)
	nDecAliq:=Len(Right(cPictAliq,Len(cPictAliq)-nPosVg))
	For naTemp:=1 To Len(aTemp)
		If ValType(aTemp[naTemp][4])=="N"
			cVlrAliq:=Str(aTemp[naTemp][4])
			nPosVg  :=RAt(".",cVlrAliq)
			If nPosVg>0 .And. Len(Right(cVlrAliq,Len(cVlrAliq)-nPosVg))>nDecAliq
				nDecAliq:=Len(Right(cVlrAliq,Len(cVlrAliq)-nPosVg))
			Endif
		EndIf
	Next naTemp
	If nDecAliq=3
		cPictAliq:="@E 999.999"
	ElseIf nDecAliq=4
		cPictAliq:="@E 999.9999"
	ElseIf nDecAliq=5
		cPictAliq:="@E 999.99999"
	ElseIf nDecAliq=6
		cPictAliq:="@E 999.999999"
	EndIf
EndIf

If cPaisLoc<>"BRA"
	If (FunName()=="MATA120" .Or. (cPaisLoc == "RUS" .And. FunName()== "MATA121")) .And. Type("nMoedaPed")=="N"
		nDec:=MsDecimais(nMoedaPed)
	ELSEIf FunName()=="MATA123" .And. Type("nMoedaPed")=="N"
		nDec:=MsDecimais(nMoedaPed)
	ElseIf FunName()=="MATA150" .And. Type("nMoedaCot")=="N"
		nDec:=MsDecimais(nMoedaCot)
	ElseIf FunName() $ "MATA410|OFIXA018|OFIXA011|OFIXA100"
		nDec:=MsDecimais(M->C5_MOEDA)
	Else
		nDec:=MsDecimais(IIf(Type("nMoedaNF")=="N",nMoedaNF,IIf(Type("nMoedaCor")=="N",nMoedaCor,1)))
	Endif
Else
	nDec:=2
Endif
cPictVal := "@E 999,999,999,999"+IIf(nDec>0,"."+Replicate("9",nDec),"")
If Len(aTemp)>0
	If nTipo == 1
		aRet:= {aTemp[oList:nAt][1],;
		aTemp[oList:nAt][2],;
		IIf(ValType(aTemp[oList:nAt][3])=="N",TransForm(aTemp[oList:nAt][3],cPictVal),aTemp[oList:nAt][3]),;
		TransForm(aTemp[oList:nAt][4],cPictAliq),;
		IIf(valType(aTemp[oList:nAt][5])=="N",TransForm(aTemp[oList:nAt][5],cPictVal),aTemp[oList:nAt][5]) }
	Else
		aRet:= {aTemp[oList:nAt][1],;
		aTemp[oList:nAt][2],;
		IIf(ValType(aTemp[oList:nAt][3])=="N",TransForm(aTemp[oList:nAt][3],cPictVal),aTemp[oList:nAt][3]),;
		IIf(ValType(aTemp[oList:nAt][4])=="N",TransForm(aTemp[oList:nAt][4],cPictVal),aTemp[oList:nAt][4]) }
	EndIf
Else
	aRet:={}
Endif

Return aRet

/*/
MaFisInser - Edson Maricate -13.12.1999
Insere um novo Imposto na NF.
*/
Function MaFisInsereImp(oList,bValidPrg,nTipo)
Local oDlg
Local oCombo
Local lOk		:= .F.
Local nPos		:= oList:nAT
Local lInsere	:= .F.
Local aImpostos	:= {'IRRF Imposto de Renda','ISS Imp. Serviço','I.C.M.S','IPI','ICMS Retido','INSS','PIS - Via Apuração','COFINS - Via Apuração','PIS - Via Retençao','COFINS - Via Retençao','CSLL - Via Retençao','ICMS Complementar','PIS - Subst. Tributaria','COFINS - Subst. Tributaria','SEST/SENAT','FETHAB','FABOV','FACS','CPRB','FUNDESA','IMA-MT','FASE-MT','INSS - Patronal','CIDE','SENAR'}
Local aImpCod	:= {'IRR','ISS','ICM','IPI','SOL','INS','PS2','CF2','PIS','COF','CSL','CMP','PS3','CF3','SES','FET','FAB','FAC','CPB','FUN','IMA','FAS','INP','CID','SENAR'}
Local nBase		:= 0
Local nValor	:= 0
Local cImposto	:= aImpostos[1]
Local cVersao	:= GetVersao(.F.)
Local cCodImp	:= ""
Local cCodVal	:= ""
Local lAtuImpMan	:= .T.

lInsere := If( MaFisFound("NF"), AllTrim(IIf(nTipo==1,Len(MaFisRet(,'NF_IMPOSTOS'))>0 .And. MaFisRet(,'NF_IMPOSTOS')[nPos][6],Len(MaFisRet(,'NF_IMPOSTOS2'))>0 .And. MaFisRet(,'NF_IMPOSTOS2')[nPos][5]))=="NEW", .F. )

If lInsere .And. cPaisLoc=="BRA"

	If cVersao <> "12"
		DEFINE MSDIALOG oDlg FROM 119,147 TO 320,580 TITLE "Impostos" Of oMainWnd PIXEL
		@ 22 ,09  SAY "Imposto" Of oDlg PIXEL SIZE 41,09
		@ 21 ,34  MSCOMBOBOX oCombo VAR cImposto ITEMS aImpostos SIZE 106,50 OF oDlg PIXEL
		@ 43 ,09  SAY "Base" Of oDlg PIXEL SIZE 28 ,9
		@ 59 ,09  SAY "Valor" Of oDlg PIXEL SIZE 42 ,9
		@ 42 ,34  MSGET nBase  Picture "@E 999,999,999,999.99" Valid Positivo(nBase)  OF oDlg PIXEL SIZE 75,09
		@ 60 ,34  MSGET nValor Picture "@E 999,999,999,999.99" Valid Positivo(nValor) OF oDlg PIXEL SIZE 75,09
	Else
		DEFINE MSDIALOG oDlg FROM 119,147 TO 320,850 TITLE "Impostos" Of oMainWnd PIXEL
		@ 42 ,09  SAY "Imposto" Of oDlg PIXEL SIZE 41,09
		@ 41 ,34  MSCOMBOBOX oCombo VAR cImposto ITEMS aImpostos SIZE 106,50 OF oDlg PIXEL
		@ 63 ,09  SAY "Base" Of oDlg PIXEL SIZE 28 ,9
		@ 79 ,09  SAY "Valor" Of oDlg PIXEL SIZE 42 ,9
		@ 62 ,34  MSGET nBase  Picture "@E 999,999,999,999.99" Valid Positivo(nBase)  OF oDlg PIXEL SIZE 75,09
		@ 80 ,34  MSGET nValor Picture "@E 999,999,999,999.99" Valid Positivo(nValor) OF oDlg PIXEL SIZE 75,09
	EndIf

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||lOk:=.T.,oDlg:End()},{||oDlg:End()}) CENTERED

EndIf

If lOk
	If fisExtPE('MFISIMP')
		lAtuImpMan := Execblock("MFISIMP",.F.,.F.,{nValor,aImpCod,cImposto,nBase})
		If Valtype(lAtuImpMan) <> 'L'
			lAtuImpMan := .T.
		EndIF
	Endif
	cCodImp := aImpCod[aScan(aImpostos,cImposto)]
	cCodVal := cCodImp
	If cCodImp == "CID"
		cCodVal := "CIDE"
	EndIf
	If lAtuImpMan .And. !Empty(MaFisScan("NF_BASE"+cCodImp,.F.)) .And. (nBase > 0 .Or. cCodImp $ "PIS,COF,CSL,IRR")
		MaFisAlt("NF_BASE"+cCodImp,nBase,)
	EndIf
	If lAtuImpMan .And. !Empty(MaFisScan("NF_VAL"+cCodVal,.F.)) .And. (nValor > 0 .Or. cCodVal $ "PIS,COF,CSL,IRR")
		MaFisAlt("NF_VAL"+cCodVal,nValor,)
	EndIf
	If lAtuImpMan .And. nBase + nValor > 0
		MaFisRRefresh(oList,nTipo)
		Eval(bValidPrg)
	EndIf
EndIf

Return .T.

/*/
MaFisEditCellLine - Edson Maricate  Data 13.12.1999
Cria um Get para edicao do Imposta no ListBox.
/*/
Function MaFisEditCell(nValor,oBrowse,cPict,nCol,cValidCpo)
Local oDlg
Local oRect
Local oGet1
Local oBtn
Local cMacro   := ''
Local nRow     := oBrowse:nAt
Local oOwner   := oBrowse:oWnd
Local lMaVldImp:= fisExtPE('MAVLDIMP')
Local cValid   := IIf( cValidCpo == Nil , '.T.' , cValidCpo ) + ' .And. Eval(bChange)'
Local cCelula  := Iif( nCol == 3 , "BASE" , "VALOR" )

bChange:= { || nValor := &cMacro,oBrowse:aArray[nRow,nCol] := &cMacro }
oRect  := tRect():New(0,0,0,0)    // obtem as coordenadas da celula (lugar onde
oBrowse:GetCellRect(nCol,nRow,oRect)  // a janela de edicao deve ficar)
aDim   := {oRect:nTop,oRect:nLeft,oRect:nBottom,oRect:nRight}

DEFINE MSDIALOG oDlg OF oOwner FROM 0,0 TO 0,0 STYLE nOR( WS_VISIBLE, WS_POPUP ) PIXEL

cMacro := "M->CELL"
&cMacro:= nValor
cPict  := cPict

@ 0,0 MSGET oGet1 VAR &(cMacro) SIZE 0,0 OF oDlg FONT oOwner:oFont PICTURE cPict PIXEL HASBUTTON ;
VALID IIf( lMaVldImp , ExecBlock("MAVLDIMP", .F., .F. , { oBrowse:aArray[nRow,1] , oBrowse:aArray[nRow,3] , oBrowse:aArray[nRow,5] , cCelula , &(cMacro) } ) , .T. ) .And. &cValid

oGet1:Move(-2,-2, (aDim[ 4 ] - aDim[ 2 ]) + 4, aDim[ 3 ] - aDim[ 1 ] + 4 )

@ 0,0 BUTTON oBtn PROMPT "ze" SIZE 0,0 OF oDlg
oBtn:bGotFocus := {|| oDlg:nLastKey := VK_RETURN, oDlg:End(0)}

oGet1:cReadVar  := cMacro

ACTIVATE MSDIALOG oDlg ON INIT oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])

oBrowse:nAt := nRow
SetFocus(oBrowse:hWnd)
oBrowse:Refresh()

Return Nil

/*/
MaFisRRefresh - Edson Maricate - 13.12.1999
Executa o Refresh no ListBox.
/*/
Function MaFisRRefresh(oList,nTipo,oFornISS,cFornISS,oLojaISS,cLojaISS,oRecISS,cRecISS,oVencISS,dVencISS,cDescri,oDescri)
Local aTemp
Local nPosDum := 0

If nTipo == 1
	aTemp := IIf(!Empty(aNfCab),aNfCab[NF_IMPOSTOS],{{"","",0,0,0}})
Else
	aTemp := IIf(!Empty(aNfCab),aNfCab[NF_IMPOSTOS2],{{"","",0,0}})
EndIf

If cPaisLoc == "ARG"
	nPosDum	:= Ascan(aTemp,{|x| x[1] == "DUM"})
	If nPosDum > 0
		aDel(aTemp,nPosDum)
		aSize(aTemp,Len(aTemp)-1)
	Endif
Endif

If fisGetParam('MV_ISSXMUN',.F.)
	If ValType(oFornISS)<>"U" .And. Empty(cFornISS)
		cFornISS := cFornCE1
		oFornISS:Refresh()
	EndIf

	If ValType(oLojaISS)<>"U" .And. Empty(cLojaISS)
		cLojaISS := cLojaCE1
		oLojaISS:Refresh()
	EndIf

	If ValType(oDescri)<>"U" .And. Empty(cDescri)
		cDescri  := cDescCE1
		oDescri:Refresh()
	EndIf

	If ValType(oVencISS)<>"U" .And. Empty(dVencISS)
		dVencISS := dVencCE1
		oVencISS:Refresh()
	EndIf

	If ValType(oRecISS)<>"U" .And. Empty(cRecISS)
		cRecISS := cRecISSCE1
		oRecISS:Refresh()
	EndIf
EndIf
If ValType(oList)<>"U"
	oList:SetArray(aTemp)
	If Len(aTemp) > 0 .And. oList:nAt > Len(aTemp)
		oList:nAt := Len(aTemp)
	EndIF
	oList:bLine := {|| MaFisLine(oList,aTemp,nTipo) }
	oList:Refresh()
EndIf

Return .T.

/*
	Funo    MaGrvCdR -Gustavo G. Rueda  Data 15.12.2006
	Descrio Funcao de amarracao do Codigo de receita a devida retencao
	da aba impostos. Somente para PIS/COF/CSL/IRR.
	ParametrosExpC1: Variavel cCodRet que recebe o codigo atualizado.
	ExpO2: Objeto oCombo para refresh.
	ExpO3: Objeto oList para refresh.
	ExpA4: Variavel aCodR que contem todos os codigos d retencoes
	relacionados na nota
	ExpO5: Objeto oCodRet para refresh
	ExpL6: Flag para identificar se a chamada estah sendo d valid
	do campo E2_CODRET
	lRet -> Flag de retorno para o VALID
*/
Static Function MaGrvCdR(cCodRet,oCombo,oList,aCodR,oCodRet,lCodRet)
Local lRet    := .T.
Local nPosCodR:= aScan(aCodR, {|x|x[4]==oList:AARRAY[oList:nAt][1]})
Local lVPos := ValType(oList)=='O' .and. (ValType(oList:AARRAY)=='A' .and. len(oList:AARRAY) > 0 )
Local lIRRProg := (Funname() == "MATA103" .and. (SA2->A2_TIPO == 'F' .or. (SA2->A2_TIPO == 'J' .and. anfCab[NF_IRPROG] == "1")))

DEFAULT lCodRet := .F.
//Quando o combo for 2(Nao) nao deve ter o codigo de receita, por isso atribuo 2 e branco.
If oCombo:nAt==2
	
	cCodRet := Iif(cPaisLoc=="BRA", Space(FisTamSX3( 'SE2','E2_CODRET')[1]), Space(4))
	oCodRet:Refresh()
			
	If nPosCodR!=0
		aCodR[nPosCodR][2]:= cCodRet
		aCodR[nPosCodR][3]:= oCombo:nAt
	Else
		If lVpos
			aAdd( aCodR, {oList:nAt, cCodRet, oCombo:nAt, oList:AARRAY[oList:nAt][1]} )
		Endif
	EndIf
	if lIRRProg .and. !Empty(aCodR)
		IRRProg(aCodR,nPosCodR)
	endif
Else
	oCodRet:Refresh()
	If lCodRet .And. !CheckSx3("E2_CODRET", cCodRet)
		lRet := .F.
	Else
		If lCodRet .And. fisExtPE('VLCODRET')
			lRet := ExecBlock( "VLCODRET",.F.,.F.,{ oList:AARRAY[oList:nAt][1] , cCodRet })
			If ValType(lRet) <> "L"
				lRet :=  .T.
			EndIf
		EndIf

		If lRet
			If nPosCodR!=0
				aCodR[nPosCodR][2]:= cCodRet
				aCodR[nPosCodR][3]:= oCombo:nAt
			Else
				If lVPos
					aAdd( aCodR, {oList:nAt, cCodRet, oCombo:nAt, oList:AARRAY[oList:nAt][1]} )
				EndIf
			EndIf
			if lIRRProg .and. !Empty(aCodR)
				IRRProg(aCodR,nPosCodR)
			endif
		EndIf
	EndIf
EndIf

Return lRet

/*/
MaAtuCdR -Gustavo G. Rueda-15.12.2006
Rotina de atualizacao do codigo de receita exibido na aba impostos a medida que seleciono a retencao no browse ao lado
Parametros
ExpC1: Variavel cCodRet que recebe o codigo atualizado.
ExpA2: Variavel aCodR que contem todos   codigos de retencoes relacionados na nota.
ExpO3: Objeto oList para refresh.
ExpO4: Objeto oCodRet para refresh.
ExpO5: Objeto oCombo para refresh.
ExpO6: Variavel nCombo que recebe a opcao selecionada.
ExpO7: Variavel aOpcoes que contem as opcoes para selecao.
/*/
Function MaAtuCdR(cCodRet,aCodR,oList,oCodRet,oCombo,nCombo,aOpcoes)
Local nPosCodR := 0
Local nX       := 0

If oList <> Nil
	//Este tratamento se deve para o codigo de receita do IR caso venha preenchido atraves do MV_AUTOISS ou do PE MT103DRF.
	If Len(aCodR) == 1 .And. aCodR[1][1] == 99
		For nX := 1 To Len(oList:aArray)
			If oList:aArray[nX][1]=="IRR"
				aCodR[1][1]	:= nX
			EndIf
		Next nX
	EndIf

	If (nPosCodR:= aScan(aCodR, {|x|x[4] == oList:aArray[oList:nAt][1]})) > 0
		cCodRet	:= aCodR[nPosCodR,2]
		nCombo	:= aOpcoes[aCodR[nPosCodR,3]]
	Else
		cCodRet	:= Iif(cPaisLoc=="BRA", Space(FisTamSX3( 'SE2','E2_CODRET' )[1]), Space(4))
		nCombo	:= aOpcoes[2]
	EndIf
EndIf
If oCodRet <> Nil
	oCodRet:Refresh()
EndIf
If oCombo <> Nil
	oCombo:Refresh()
EndIf


Return .T.

/* FUNCOES SECUNDARIAS AS FUNCOES PRINCIPAIS - FUNCOES DE APOIO */

/*/
MaFisIniCpo -Alexandre Lemes -08/12/2012
/*/
Static Function MaFisIniCpo(nItem,lSeek)
	xFisIniCpo(nItem,@lSeek,@aSX6,@aNfItem,@lHistorico,@aNfCab,@aPos,@aDic,@cCpoSBZ,@cAlsItem,@cAliasPROD)
Return
/*/
MaFisRetLF - Edson Maricate -03.01.2000
Retorna um array com a estrutura inicial do aLivro
/*/
Function MaFisRetLF()
       //1  2  3  4  5   6  7  8  9  10 11 12 13 14  15  16  17 18  19  20  21 22  23  24  25 26 27 28 29 30  31  32  33  34          35  36 37 38 39 40 41  42 43  44  45  46  47  48  49 50  51  52  53 54  55 56 57 58 59 60 61 62  63 64 65 66 67 68 69  70  71 72 73 74  75 76 77 78 79 80  81 82  83 84 85 86 87  88 89 90 91 92   93   94  95 96  97 98 99    100  101 102 103 104 105 106 107 108 109  110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164
Return {"",0, 0, 0, 0, 0, 0,  0, 0, 0,  0,"", 0, 0, "", "",  0, "", 0, "", 0, 0,  "", "",  0, 0, 0, 0, 0, 0, "", "", "", 0, {0,0,0,0,0}, "", 0, 0, 0, 0, 0, "","", "", "", "", "", "",  0, 0, "", "", 0,  0,  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, "",  0, 0, 0, 0 ,"","", 0, 0, 0, 0 ,"", 0,  0, 0, 0, 0, 0, "", 0, 0, 0, 0 ,  0 , "", "","", "","","",CtoD(""), 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  "", 0 , 0, "", "", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0}

/*/
MaFisScan-Eduardo/Edson   -02.04.2002
Func de procura da posicao da referencia nos arrays internos
/*/
Function MaFisScan(cCampo,lErro)

	If aItemRef == Nil
		MaIniRef()
	EndIf
	Return xFisScan(cCampo,lErro,aItemRef,aCabRef,aLFis,aResRef,aTGITRef,aTGNFRef,aTGLFRef)

Return

/*/
MaItArred - Edson Maricate  -12.04.2001
 Executa a correcao dos arredondamentos do item
           Utiliza o Array aSaveDec para armazenar os centesimos
           que foram truncados. ( aSaveDec deve estar inicializado
           obrigatoriamente pela MaFisIni() )
/*/
Function MaItArred(nX,aRefs,lIBGE,lValidArrd)
Local nY        := 0
Local nZ        := 0
Local nDifItDel := 0
Local nAbatISS	:= 0
Local nDif      := 0
Local nValor 	:= 0
Local nDifItem	:= 0
Local nDec      := 2
Local nPrecissao := fisGetParam('MV_RNDPREC',10)
Local nRndPrec  := IIf( nPrecissao < 3 , 10 , nPrecissao ) // Precisao para o arredondamento
Local lSobra    := fisGetParam('MV_RNDSOBR',.T.) // Parametro para considerar, ou nao, as sobras quando o parametro de arredondamento estiver como .F., ou seja, para truncar.
Local lRndrne   := fisGetParam('MV_RNDRNE',.T.)
Local lIBGE886  := fisGetParam('MV_IBGE886',.F.)
Local nValISS := 0
Local nBasIss   := 0
Local nDifISS := 0
Local nISSABNT  := 0
Local lArdISS   := .F.

Local laRefsNil  := aRefs == Nil
Local nTamaRefs  := IIF(laRefsNil, 0, Len(aRefs))
Local nPosRefs   := 1
Local nTamItRf   := Len(aItemRef)
Local lProcessa	 := .T.

DEFAULT lIBGE := .F.

//Se o valor do Pis Apuracao for Zero e houver sobra deverá entrar para arrendondar
//Exemplo: PIS = 0,53 x 1,65% = 0,008745
//Arrendondando seguindo os parametros padroes ficará PIS = 0,00
//Deixando uma sobra de 0,008, a qual deverá arredondar para 0,01 o valor do PIS.
//Mediante essa situação acima o lValidArrd voltará como .T.
DEFAULT lValidArrd:= .F.

If aItemRef == Nil
	MaIniRef()
EndIf

IF lIBGE .OR. aNFCab[NF_OPERNF] == "E" //Não considera Arredondamento do IBGE para notas de entrada
	lIBGE886  := .F. //Quando alterado valor de ISS não aplica arredondamento do IBGE
Endif

		If cPaisLoc<>"BRA"
			If FunName()=="LOJA701" //OPTIMIZA
		     	nDec:=MsDecimais(nMoedaCor)
			ElseIf FunName() $ "MATA120|MATA121|CNTA121|CNTA260" .And. Type("nMoedaPed")=="N"
				nDec:=MsDecimais(nMoedaPed)
			ElseIf FunName()=="MATA123" .And. Type("nMoedaPed")=="N"
				nDec:=MsDecimais(nMoedaPed)
			ElseIf FunName()=="MATA150" .And. Type("nMoedaCot")=="N"
				nDec:=MsDecimais(nMoedaCot)
			ElseIf FunName()=="MATA160" .And. Type("nMoedaAval")=="N"
				nDec:=MsDecimais(nMoedaAval)
			ElseIf Type("nMoedaNF")=="N"
				nDec:=MsDecimais(nMoedaNF)
			ElseIf Type("nMoedaCor")=="N"
				nDec:=MsDecimais(nMoedaCor)
			ElseIf Type("M->F1_MOEDA")=="N"
				nDec:=MsDecimais(M->F1_MOEDA)
			ElseIf Type("M->F2_MOEDA")=="N"
				nDec:=MsDecimais(M->F2_MOEDA)
			ElseIf Type("M->C5_MOEDA")=="N"
				nDec:=MsDecimais(M->C5_MOEDA)
			ElseIf FunName()=="MATA143" .And. Type("nMoedaDes")=="N"
				nDec:=MsDecimais(nMoedaDes)
			Else
				nDec:=MsDecimais(1)
			Endif
			If cPaisLoc=="BOL"  .AND. fisFindFunc( "MaFisRoubo" )
				nDec:=MaFisRoubo(FunName(),nDec)
			EndIf
			nDif:=10**(-nDec)
		Endif

// Executa a correcao nos arredondamentos.
While lProcessa

	If !laRefsNil //Performo melhor procurando onumero de referencias ao inves do aItemRef inteiro - Conto apenas quantidade de aRefs que possuo para arredondar
		nY := Ascan(aItemRef, { |X| (X[1]) == aRefs[nPosRefs] } )
		nPosRefs ++
		lProcessa := nPosRefs <= nTamaRefs
	Else //Caso nao haja diferença percorro todo o aItemRef
		nY ++
		lProcessa := nY < nTamItRf
	EndIf

	If nY > 0 .And. aItemRef[nY][4]
		nDifItem	:= 0
		nDifItDel   := 0

		For nZ := 1 To Len(aNfItem) // For para desconsiderar os itens deletados nos arrays de acumulos da sobras qdo o parametro MV_RNDSOBR = .T.
			If aNfItem[nZ][IT_DELETED] .And. lSobra
				If aItemDec[nZ][1][nY] > 0
					nDifItDel += aItemDec[nZ][1][nY]
					nDifItDel -= (1/10**nDec)
				Else
					nDifItDel += aItemDec[nZ][2][nY]
				EndIf
			EndIf
		Next nZ

		If ValType(aItemRef[nY][2]) == "A"
			nValor := aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]]
			If nValor <> 0
				While Int(nValor) <> Int(NoRound(NoRound(nValor,nRndPrec),nDec,nDifItem,10)) .And. nRndPrec > 2
					nRndPrec -= 1
				Enddo
				aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] := NoRound(NoRound(nValor,nRndPrec),nDec,@nDifItem,10)
				If nDifItem <> 0
					aSaveDec[nY] += aItemDec[nX][1][nY]
					aItemDec[nX][1][nY] := 0
					If !aItemRef[nY][5]
						aSaveDec[nY] -= aItemDec[nX][2][nY]
						aItemDec[nX][2][nY]	:= nDifItem
						aSaveDec[nY] += nDifItem
						If lSobra
							//TRATAMENTO SAO PAULO COM ITENS QUE TENHAM ABATIMENTO.
							If lRndrne .And. aItemRef[nY][1] == "IT_VALISS" .And. aNfItem[nX,IT_ABVLISS] > 0
								If ( (NoRound(aSaveDec[nY],nDec) - nDifItDel ) >= 1/10**nDec)
									aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
									aItemDec[nX][2][nY]	:= 0
									aSaveDec[nY] -= (1/10**nDec)
									aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += (1/10**nDec)
									nAbatISS += aNfItem[nX,IT_ABVLISS]
								EndIf
								//TRATAMENTO SAO PAULO COM ITENS QUE NAO TENHAM ABATIMENTO ANTERIORES.
							ElseIf lRndrne .And. aItemRef[nY][1] == "IT_VALISS" .And. nAbatISS == 0
								If ( (NoRound(aSaveDec[nY],nDec) - nDifItDel ) >= 1/10**nDec)
									aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
									aItemDec[nX][2][nY]	:= 0
									aSaveDec[nY] -= (1/10**nDec)
									aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += (1/10**nDec)
								EndIf
							Else
								If ( aSaveDec[nY] - nDifItDel )  >= (50/(10**(nDec + 2)))
									aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
									aItemDec[nX][2][nY]	:= 0
									aSaveDec[nY] -= (1/10**nDec)
									aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += (1/10**nDec)
								EndIf
							EndIf
						EndIf
					ElseIf nDifItem > 0 .And. (aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] > 0 .Or. lValidArrd)
						aSaveDec[nY] -= aItemDec[nX][2][nY]
						aItemDec[nX][2][nY]	:= nDifItem
						aSaveDec[nY] += nDifItem
						If ( aSaveDec[nY] - nDifItDel ) >= (50/(10**(nDec + 2)))
							If lSobra
								aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
								aItemDec[nX][2][nY]	:= 0
								aSaveDec[nY] -= (1/10**nDec)
							EndIf
							aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += (1/10**nDec)
						EndIf
					EndIf
					If !lSobra
						aItemDec[nX][1][nY]	:= 0
						aItemDec[nX][2][nY]	:= 0
						aSaveDec[nY] := 0
					Endif
				EndIf

				// Tratamento p/ arredondamento ABNT/IBGE - ISS - MV_IBGE886
				// Não executa quando MAFISININF estiver na pilha pois esta função é p/ visualização e reprocessamento
				// do documento, então não posso alterar nenhum valor.
				If cPaisLoc == "BRA" .And. lIBGE886 .And. aItemRef[nY][1] == "IT_VALISS" .And. aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] > 0 .And. !IsInCallStack("MAFISININF")//!lVisReproc

					// Se o documento tem mais de um item só vou fazer o tratamento no último item p/ acertar o valor total, que é
					// o que é validado na transmissão da NFS.
					// Atenção: Este tratamento p/ o último item só funciona para o faturamento (Planilha / MATA461) pois para as demais
					// interfaces de digitação não é possível saber a quantidade de itens que o documento terá. Assim, para estas demais rotinas,
					// o tratamento continuará sendo feito item a item assim como era feito anteriormente.
					If aNFCab[NF_QTDITENS] > 0
						If nX == aNFCab[NF_QTDITENS]
							lArdISS := .T.
							aEval(aNFItem,{|x| nBasIss += x[IT_BASEISS]})
							aEval(aNFItem,{|x| nValISS += x[IT_VALISS]})
						EndIf
					Else
						lArdISS := .T.
						nBasIss := aNfItem[nX][IT_BASEISS]
						nValISS := aNfItem[nX][IT_VALISS]
					EndIf

					If lArdISS
						// Calculo o valor total de ISS da forma mais "pura" possível, ou seja,
						// sem nenhum tratamento de arredondamento.
						nISSABNT := (nBasIss * (aNfItem[nX][IT_ALIQISS] / 100))

						// Arredondo o valor para 2 casas e guardo a sobra, ou seja, o valor da 3 casa em diante na variavel nDifISS.
						nISSABNT := NoRound(NoRound(nISSABNT, 10), 2, @nDifISS, 10)

						// Caso 1: Terceiro dígito é 5 seguido de zeros, então igualo exatamente a 0.005 pois 0.005 = 0.005000...
						If nDifISS == 0.005
								// Verifico se o segundo algarismo após a vírgula é ímpar.
								// Se for, somo 0.01 p/ arredondar. Caso contrário não faço
								// nada pois o número deve ser truncado.
							If Mod(Val(Right(cValToChar(nISSABNT * 100), 1)), 2) <> 0
								nISSABNT += 0.01
							EndIf
						// Caso 2: Terceiro digito maior do que 5, ou 5 seguido de qualquer número diferente de zero, ou seja, qlqr valor acima de 0.005...
						ElseIf nDifISS > 0.005
							nISSABNT += 0.01
						EndIf

						// Por fim, verifico se o valor total dos itens já corresponde ao valor que seria esperado
						// no padrão ABNT. Se não corresponder, faço o ajuste no último item para que os valores batam.
						If nValISS <> nISSABNT
							aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += (nISSABNT - nValISS)
						EndIf

						// Se o controle de sobras estiver ativo limpo os arrays.
						If lSobra
							aItemDec[nX][1][nY]	:= 0
							aItemDec[nX][2][nY]	:= 0
							aSaveDec[nY] := 0
						EndIf
					EndIf

				EndIf

			EndIf
		Else
			nValor := aNfItem[nX][Val(aItemRef[nY][2])]
			If nValor <> 0
				While Int(nValor) <> Int(NoRound(NoRound(nValor,nRndPrec),nDec,nDifItem,10)) .And. nRndPrec > 2
					nRndPrec -= 1
				Enddo
				aNfItem[nX][Val(aItemRef[nY][2])] := NoRound(NoRound(nValor,nRndPrec),nDec,@nDifItem,10)
				If nDifItem <> 0
					aSaveDec[nY] += aItemDec[nX][1][nY]
					aItemDec[nX][1][nY] := 0
					If !aItemRef[nY][5]
						aSaveDec[nY] -= aItemDec[nX][2][nY]
						aItemDec[nX][2][nY]	:= nDifItem
						aSaveDec[nY] += nDifItem

						//TRATAMENTO SAO PAULO COM ITENS QUE TENHAM ABATIMENTO.
						If  lRndRne .And. aItemRef[nY][1] == "IT_VALISS" .And. aNfItem[nX,IT_ABVLISS] > 0
							If ( NoRound(aSaveDec[nY],nDec) - nDifItDel ) >= 1/10**nDec
								aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
								aItemDec[nX][2][nY]	:= 0
								aSaveDec[nY] -= (1/10**nDec)
								aNfItem[nX][Val(aItemRef[nY][2])] += (1/10**nDec)
								nAbatISS += aNfItem[nX,IT_ABVLISS]
							EndIf
							//TRATAMENTO SAO PAULO COM ITENS QUE NAO TENHAM ABATIMENTO ANTERIORES.
						ElseIf lRndRne .And. aItemRef[nY][1] == "IT_VALISS" .And. nAbatISS == 0
							If ( NoRound(aSaveDec[nY],nDec) - nDifItDel ) >= 1/10**nDec
								aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
								aItemDec[nX][2][nY]	:= 0
								aSaveDec[nY] -= (1/10**nDec)
								aNfItem[nX][Val(aItemRef[nY][2])] += (1/10**nDec)
							EndIf
						Else
							If lSobra .And. ( aSaveDec[nY] - nDifItDel ) >= (50/(10**(nDec + 2)))
								aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
								aItemDec[nX][2][nY]	:= 0
								aSaveDec[nY] -= (1/10**nDec)
								aNfItem[nX][Val(aItemRef[nY][2])] += (1/10**nDec)
							EndIf
						EndIf

					ElseIf nDifItem > 0 .And. (aNfItem[nX][Val(aItemRef[nY][2])] > 0 .Or. lValidArrd)
						aSaveDec[nY] -= aItemDec[nX][2][nY]
						aItemDec[nX][2][nY] := nDifItem
						aSaveDec[nY] += nDifItem
						If ( aSaveDec[nY] - nDifItDel ) >= (50/(10**(nDec + 2)))
							aItemDec[nX][1][nY] := (1/10**nDec) - nDifItem
							aItemDec[nX][2][nY] := 0
							aSaveDec[nY] -= (1/10**nDec)
							aNfItem[nX][Val(aItemRef[nY][2])] += (1/10**nDec)
						EndIf
					EndIf
					If !lSobra
						aItemDec[nX][1][nY]	:= 0
						aItemDec[nX][2][nY]	:= 0
						aSaveDec[nY] 		:= 0
					Endif
				EndIf
			EndIf
		EndIf
	EndIf
EndDo

//------------------------------------------------------
//Processamento do arredondamento dos tributos genéricos
//Percorre a lista dos tributos genéricos enquadrados
//Somente fará para o Brasil
//------------------------------------------------------
If cPaisLoc  == "BRA" .AND. aNfCab[NF_CHKTRIBLEG]
	FisTgArred(@aNFCab, @aNfItem, aSX6, aTGITRef, aRefs, nDec, nx, lSobra)
EndIF

Return

/*/
 MaIt2Cab- Edson Maricate -13.12.1999
 Atualiza os valores totais do cabecalho da NF
/*/
Function MaIt2Cab(nItemNao)
Local nX := 0
Local nY := 0
Local aSFB := {}		//OPTIMIZA...
Local aSFC := {}
Local aSF4 := {}		//...OPTIMIZA
DEFAULT nItemNao := 0

aAuxOri := {}
aNfCab[NF_DESCONTO]	:= 0
aNfCab[NF_DESCTOT]	:= 0
aNfCab[NF_DEDICM]	:= 0
aNfCab[NF_ACRESCI]	:= 0
aNfCab[NF_FRETE]	:= 0
aNfCab[NF_DESPESA]	:= 0
aNfCab[NF_SEGURO]	:= 0
aNfCab[NF_VALEMB]	:= 0
aNfCab[NF_AUTONOMO]	:= 0
aNfCab[NF_ICMS]		:= {0,0,0,0,0,0,0,0,"1"}
aNfCab[NF_IPI]		:= {0,0,0}
aNfCab[NF_TOTAL]	:= 0
aNfCab[NF_VALMERC]	:= 0
aNfCab[NF_VNAGREG]  := 0
aNfCab[NF_FUNRURAL]	:= 0
aNfCab[NF_LIVRO]	:= {}
aNfCab[NF_BASEIRR]	:= 0
aNfCab[NF_VALIRR]	:= 0
aNfCab[NF_BASEINS]  := 0
aNfCab[NF_VALINS]	:= 0
aNfCab[NF_BASEISS] 	:= 0
aNfCab[NF_VALISS]	:= 0
aNfCab[NF_DESCISS]  := 0
aNfCab[NF_IMPOSTOS]	:= {}
aNfCab[NF_IMPOSTOS2]:= {}
aNfCab[NF_BASEDUP]	:= 0
aNfCab[NF_DESCZF]	:= 0
aNfCab[NF_BASEIMP]	:= Array(NMAXIV)
aNfCab[NF_BASEIMP]	:= Afill(aNfCab[NF_BASEIMP],0)
aNfCab[NF_VALIMP]	:= Array(NMAXIV)
aNfCab[NF_VALIMP]	:= Afill(aNfCab[NF_VALIMP],0)
If cPaisLoc == "RUS"
	aNfCab[NF_TOTAL_C1]	:= 0
	aNfCab[NF_VALMERC_C1]	:= 0
	aNfCab[NF_BASEIMP_C1]	:= Array(NMAXIV)
	aNfCab[NF_BASEIMP_C1]	:= Afill(aNfCab[NF_BASEIMP_C1],0)
	aNfCab[NF_VALIMP_C1]	:= Array(NMAXIV)
	aNfCab[NF_VALIMP_C1]	:= Afill(aNfCab[NF_VALIMP_C1],0)
EndIf
aNfCab[NF_PESO]		:= 0
aNfCab[NF_ICMFRETE]	:= 0
aNfCab[NF_BSFRETE]	:= 0
aNfCab[NF_BASEICA]	:= 0
aNfCab[NF_VALICA]	:= 0
aNfCab[NF_BASECOF]	:= 0
aNfCab[NF_VALCOF]	:= 0
aNfCab[NF_BASECSL]	:= 0
aNfCab[NF_VALCSL]	:= 0
aNfCab[NF_BASEPIS]	:= 0
aNfCab[NF_VALPIS]	:= 0
aNfCab[NF_BASEPS2]	:= 0
aNfCab[NF_VALPS2]	:= 0
aNfCab[NF_BASECF2]	:= 0
aNfCab[NF_VALCF2]	:= 0
aNfCab[NF_MINIMP]	:=Array(NMAXIV)
aNfCab[NF_MINIMP]	:=Afill(aNfCab[NF_MINIMP],0)
aNfCab[NF_BASEAFRMM]:= 0
aNfCab[NF_PIS252]   := 0
aNfCab[NF_COF252]   := 0
aNfCab[NF_BASESES]  := 0
aNfCab[NF_VALSES]	:= 0
aNfCab[NF_BASEPS3]  := 0
aNfCab[NF_VALPS3]   := 0
aNfCab[NF_BASECF3]  := 0
aNfCab[NF_VALCF3]   := 0
aNfCab[NF_VLR_FRT]  := 0
aNfCab[NF_VALFET]   := 0
aNfCab[NF_VALFETR]  := 0
aNfCab[NF_VALFDS]   := 0
aNfCab[NF_VLSENAR]  := 0
aNfCab[NF_ESTCRED]  := 0
aNfCab[NF_BASETST]  := 0
aNfCab[NF_VALTST]   := 0
aNfCab[NF_CRPRSIM]  := 0
aNfCab[NF_VALANTI]  := 0
aNfCab[NF_DESNTRB]  := 0
aNfCab[NF_TARA]   	:= 0
aNfCab[NF_CRDPRES]	:= 0
aNfCab[NF_CRPREPE]	:= 0
aNfCab[NF_VALFAC]	:= 0
aNfCab[NF_VALFET]	:= 0
aNfCab[NF_VALFETR]	:= 0
aNfCab[NF_VALFAB]	:= 0
aNfCab[NF_CROUTSP]  := 0
aNfCab[NF_BSSEMDS]  := 0
aNfCab[NF_ICSEMDS]  := 0
aNfCab[NF_DS43080]  := 0
aNfCab[NF_VL43080]  := 0
aNfCab[NF_VLRORIG]	:= Array(NMAXIV)
aNfCab[NF_VLRORIG]	:= Afill(aNfCab[NF_VLRORIG],0)
aNfCab[NF_ICMSDIF]  := 0
aNfCab[NF_BASEFUN]  := 0
aNfCab[NF_VALII]    := 0
aNfCab[NF_VLINCMG]  := 0
aNfCab[NF_BASEINA]	:= 0
aNFCab[NF_VALINA]	:= 0
aNfCab[NF_VFECPRN]  := 0
aNfCab[NF_VFESTRN]  := 0
aNfCab[NF_CREDPRE]	:= 0
aNfCab[NF_VFECPMG]  := 0
aNfCab[NF_VFESTMG]  := 0
aNfCab[NF_VREINT]   := 0
aNfCab[NF_BSREIN]   := 0
aNfCab[NF_VFECPMT]  := 0
aNfCab[NF_VFESTMT]  := 0
aNfCab[NF_ISSABMT]  := 0
aNfCab[NF_ISSABSR]  := 0
aNfCab[NF_INSABMT]  := 0
aNfCab[NF_INSABSR]  := 0
aNfCab[NF_ADIANT]   := 0
aNfCab[NF_VALTPDP]  := 0
aNfCab[NF_BASTPDP]  := 0
aNfCab[NF_VALAFRMM] := 0
aNfCab[NF_VALFECP]  := 0
aNfCab[NF_VFECPST]  := 0
aNfCab[NF_VALFUM]   := 0
aNfCab[NF_VALCIDE]  := 0
aNfCab[NF_AFRMIMP]	:= 0
aNfCab[NF_VALINP]  := 0
aNfCab[NF_VALPRO]  := 0
aNfCab[NF_VALCPM]  := 0
aNfCab[NF_TRIBGEN] := {}
aNfCab[NF_VALIMA] := 0

IF cPaisLoc == "PER" .and. fisExtCmp('12.1.2310', .T.,'SF1','F1_ADIANT')
	aNfCab[NF_ADIANTTOT] := 0
EndIf
//OPTIMIZA...
aSF4 := SF4->(GetArea())
aSFB := SFB->(GetArea())
aSFC := SFC->(GetArea())
If aSF4[2] <> 1
	SF4->(DbSetOrder(1))
EndIf
If aSFB[2] <> 1
	SFB->(DbSetOrder(1))
EndIf
If aSFC[2] <> 2
	SFC->(DbSetOrder(2))
EndIf
//...OPTIMIZA
For nX := 1 to Len(aNfItem)
	If nItemNao <> nX
		MaFisSomaIt(nX)
	Endif
Next nX

If cPaisLoc == "BRA" // Executa a correcao nos arredondamentos no Cabecalho e Livros Fiscais
	For nX := 1 To Len(aCabRef)
		If ValType(aCabRef[nX,2]) <> "A"
			nY := Val(aCabRef[nX,2])
			If ValType(aNfCab[nY]) == "N" .And. aCabRef[nX][3]
				aNfCab[nY] := NoRound(aNfCab[nY],2,,10)
			EndIf
		EndIf
	Next nX
Endif
//OPTIMIZA...
RestArea(aSF4)
RestArea(aSFB)
RestArea(aSFC)
//...OPTIMIZA
If bFisRefresh <> Nil
	Eval(bFisRefresh)
EndIf

If bLivroRefresh <> Nil
	Eval(bLivroRefresh)
EndIf

Return .T.

/*
MaFisSomaIt -Edson Maricate -13.12.1999
Esta rotina tem como objetivo atualizar a variavel aNfCab com base nos itens da funcao fiscal
Rotina atualizacao dos dados do Cabecalho da funcao fiscal
aNfCab com base em um item da funcao fiscal aNfItem
Parametros
ExpN1: Item do Array ANFItem que deve ser inicializado
ExpL2: Indica se eh inclusao (.T.)ou estorno(.F.) (OPC)
ExpC3: Campo a ser atualizado (OPC)
*/
Function MaFisSomaIt(nX,lSoma,cCampo)
Local nY := 0
Local nG := 0
Local cUFFCP := ""
Local nTrbGen		:= 0
Local cSiglaGen		:= ""
Local cDescriGen    := ""
Local nBaseGen	    := 0
Local nAlqGen		:= 0
Local nValGen		:= 0
Local lZero			:= .F.

DEFAULT lSoma := .T.

If !aNfItem[nX][IT_DELETED]

	xFisSomaIt(@aNfItem,@aNfCab,@nX,@lSoma,@aPos,@lNotRemito,Iif(Type("cFunName")=="U",Upper(AllTrim(FunName())),cFunName),@cCampo,@aSX6,aDic)

	//Inclui a linha para inclusao de Impostos.
	If aNfCab[NF_INSIMP]
		If aScan(aNfCab[NF_IMPOSTOS],{|x| x[6] == "NEW"  }) == 0
			aadd(aNfCab[NF_IMPOSTOS],{'...','  ',0,0,0,'NEW'})
		EndIf
		If aScan(aNfCab[NF_IMPOSTOS2],{|x| x[5] == "NEW"  }) == 0
			aadd(aNfCab[NF_IMPOSTOS2],{'...','  ',0,0,'NEW'})
		EndIf
	EndIf

	// Montagem do array NF_IMPOSTOS contando o rodape e todos os impostos calculados
	// ICMS,IPI,INSS,ICMS RETIDO,ICMS COMP,ISS,IR    Impostos Argentina,Chile,Etc
	If cPaisLoc == "BRA"

		MaFisTes(aNfItem[nX][IT_TES],aNfItem[nX][IT_RECNOSF4],nX)

		If (aNfItem[nX][IT_BASEICM]<>0 .Or. aNfItem[nX][IT_VALICM]<>0) .And. aNfItem[nX][IT_VALISS] == 0;
			.And. !((aNFCab[NF_SIMPNAC] =="1" .And. aNFItem[nX][IT_TS][TS_COMPL] == "S" .And. aNFItem[nX][IT_TS][TS_CIAP] == "S")) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_ICMS))
			If aNfItem[nX][IT_UFXPROD][UFP_BASRDZ] == '2'
				MaFisResumo(aNfItem[nX][IT_BASEICM],aNfItem[nX][IT_ALIQICM],aNfItem[nX][IT_VALICM],'ICM','ICMS Base Red. + FECP Base Total','ICM',,,lSoma)
			Else
				MaFisResumo(aNfItem[nX][IT_BASEICM],aNfItem[nX][IT_ALIQICM],aNfItem[nX][IT_VALICM],'ICM','ICMS','ICM',,,lSoma)
			EndIf
		EndIf
		IF aNfItem[nX][IT_VALCIDE] > 0 .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_CIDE))
			MaFisResumo(aNfItem[nX][IT_BASECID],aNfItem[nX][IT_ALQCIDE],aNfItem[nX][IT_VALCIDE],'CID','CIDE','CID',,,lSoma)
		EndIf
		//ISSCPM
		IF aNfItem[nX][IT_VALCPM] > 0 .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_ISSBI))
			MaFisResumo(aNfItem[nX][IT_BASECPM],aNfItem[nX][IT_ALQCPM],aNfItem[nX][IT_VALCPM],'CPM','ISS BiTributado','CPM',,,lSoma)
		EndIf
		//FUMIPEQ
		IF aNfItem[nX][IT_VALFMP] > 0 .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_FUMIPQ))
			MaFisResumo(aNfItem[nX][IT_BASEFMP],aNfItem[nX][IT_ALQFMP],aNfItem[nX][IT_VALFMP],'FMP','FUMIPEQ','FMP',,,lSoma)
		EndIf
		If (aNfItem[nX][IT_BASEIPI]<>0 .Or. aNfItem[nX][IT_VALIPI]<>0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_IPI))
			MaFisResumo(aNfItem[nX][IT_BASEIPI],aNfItem[nX][IT_ALIQIPI],aNfItem[nX][IT_VALIPI],'IPI','IPI ','IPI',,,lSoma)
		EndIf
		If (aNfItem[nX][IT_BASEICA]<>0 .Or. aNfItem[nX][IT_VALICA]<>0) .AND. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_FRTAUT))
			MaFisResumo(aNfItem[nX][IT_BASEICA],aNfItem[nX][IT_ALIQICM],aNfItem[nX][IT_VALICA],'ICA','ICMS ref. Frete Autonomo','ICA',,,lSoma)
		EndIf
		If (aNfItem[nX][IT_BASETST]<>0 .Or. aNfItem[nX][IT_VALTST]<>0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_FRTEMB))
			MaFisResumo(aNfItem[nX][IT_BASETST],aNfItem[nX][IT_ALIQTST],aNfItem[nX][IT_VALTST],'TST','ICMS ref. Frete Autonomo - ST','TST',,,lSoma)
		EndIf
		If (aNfItem[nX][IT_BASESOL]<>0 .Or. aNfItem[nX][IT_VALSOL]<>0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_ICMSST))
			MaFisResumo(aNfItem[nX][IT_BASESOL],aNfItem[nX][IT_ALIQSOL],aNfItem[nX][IT_VALSOL],'ICR','ICMS Retido ','SOL',,,lSoma)
		EndIf
		If (aNfItem[nX][IT_VALCMP]<>0 .And. aNfItem[nX][IT_DIFAL]==0 .And. aNfItem[nX][IT_PDDES] == 0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_CMP))
			MaFisResumo(0,aNfItem[nX][IT_ALIQCMP],aNfItem[nX][IT_VALCMP],'ICC','ICMS Complementar ','CMP',,,lSoma)
		EndIf
		If ((aNfItem[nX][IT_BASEDES]<>0 .Or. aNfItem[nX][IT_DIFAL]<>0) .And. aNfItem[nX][IT_PDDES] > 0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_DIFAL))
			If (aNfItem[nX][IT_DIFAL]==0 .And. aNfItem[nX][IT_VFCPDIF]>0 ) .And.  !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_FCPCMP))
				MaFisResumo(aNfItem[nX][IT_BASEDES],aNfItem[nX][IT_ALIQCMP],Iif(aNfCab[NF_TIPONF]=="D",aNfItem[nX][IT_DIFAL],aNfItem[nX][IT_VALCMP]),'ICC','ICMS Complementar ','CMP',.T.,.T.,lSoma)
				MaFisResumo(aNfItem[nX][IT_BASEDES],aNfItem[nX][IT_ALFCCMP],aNfItem[nX][IT_VFCPDIF],'DIF','FECP','CMP',.T.,.T.,lSoma)
			Else
				If aNfCab[NF_OPERNF]=="S"
					MaFisResumo(aNfItem[nX][IT_BASEDES],aNfItem[nX][IT_ALIQCMP],Iif(aNfCab[NF_TIPONF]=="D",aNfItem[nX][IT_DIFAL],aNfItem[nX][IT_VALCMP]),'ICC','ICMS Complementar ','CMP',.T.,.T.,lSoma)
					MaFisResumo(aNfItem[nX][IT_BASEDES],aNfItem[nX][IT_ALIQCMP]+(Iif(aNfItem[nX][IT_VFCPDIF]>0,aNfItem[nX][IT_ALFCCMP],0)),Iif(aNfCab[NF_TIPONF]=="D",aNfItem[nX][IT_VALCMP],aNfItem[nX][IT_DIFAL])+aNfItem[nX][IT_VFCPDIF],'DIF','ICMS Complementar Dest.'+(Iif(aNfItem[nX][IT_VFCPDIF]>0,' + ' + xFisNameFCP(aNFCab[NF_UFDEST], .F., .F.),'')),'CMP',.T.,.T.,lSoma)
				Else
					MaFisResumo(aNfItem[nX][IT_BASEDES],aNfItem[nX][IT_ALIQCMP],Iif(aNfCab[NF_TIPONF]=="D" .Or. (aNfCab[NF_TIPONF]=="B" .And. Iif(Type("cFormul")=="C",cFormul == "S", .F.)),aNfItem[nX][IT_VALCMP],aNfItem[nX][IT_DIFAL]),'ICC','ICMS Complementar ','CMP',.T.,.T.,lSoma)
					MaFisResumo(aNfItem[nX][IT_BASEDES],aNfItem[nX][IT_ALIQCMP]+(Iif(aNfItem[nX][IT_VFCPDIF]>0,aNfItem[nX][IT_ALFCCMP],0)),Iif(aNfCab[NF_TIPONF]=="D" .Or. (aNfCab[NF_TIPONF]=="B" .And. Iif(Type("cFormul")=="C",cFormul == "S", .F.)),aNfItem[nX][IT_DIFAL],aNfItem[nX][IT_VALCMP])+aNfItem[nX][IT_VFCPDIF],'DIF','ICMS Complementar Dest.'+(Iif(aNfItem[nX][IT_VFCPDIF]>0,' + ' + xFisNameFCP(aNFCab[NF_UFDEST], .F., .F.),'')),'CMP',.T.,.T.,lSoma)
				Endif
			EndIf
		EndIf
		If (aNfItem[nX][IT_BASEISS]<>0 .Or. aNfItem[nX][IT_VALISS]<>0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_ISS))
			MaFisResumo(aNfItem[nX][IT_BASEISS],aNfItem[nX][IT_ALIQISS],aNfItem[nX][IT_VALISS],'ISS','ISS Imposto sobre servico ','ISS',,,lSoma)
		EndIf
		If (aNfItem[nX][IT_BASEIRR]<>0 .Or. aNfItem[nX][IT_VALIRR]<>0) .and. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_IR))
			MaFisResumo(aNfItem[nX][IT_BASEIRR],aNfItem[nX][IT_ALIQIRR],aNfItem[nX][IT_VALIRR],'IRR','IRRF Imposto de renda ','IRR',,,lSoma)
		EndIf

		If (aNfItem[nX][IT_BASEINS]<>0 .Or. aNfItem[nX][IT_VALINS]<>0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_INSS))
			MaFisResumo(aNfItem[nX][IT_BASEINS],aNfItem[nX][IT_ALIQINS],aNfItem[nX][IT_VALINS],'INS','INSS ','INS',,,lSoma)
		EndIf

		If (aNfItem[nX][IT_BASEPIS]<>0 .Or. aNfItem[nX][IT_VALPIS]<>0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX,TRIB_ID_PISRET))
			MaFisResumo(aNfItem[nX][IT_BASEPIS],aNfItem[nX][IT_ALIQPIS],aNfItem[nX][IT_VALPIS],'PIS','PIS - Via Retençao','PIS',.T.,.T.,lSoma)
		EndIf
		If (aNfItem[nX][IT_BASECOF]<>0 .Or. aNfItem[nX][IT_VALCOF]<>0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX,TRIB_ID_COFRET))
			MaFisResumo(aNfItem[nX][IT_BASECOF],aNfItem[nX][IT_ALIQCOF],aNfItem[nX][IT_VALCOF],'COF','COFINS - Via Retenção','COF',.T.,.T.,lSoma)
		EndIf
		If (aNfItem[nX][IT_BASECSL]<>0 .Or. aNfItem[nX][IT_VALCSL]<>0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_CSLL))
			MaFisResumo(aNfItem[nX][IT_BASECSL],aNfItem[nX][IT_ALIQCSL],aNfItem[nX][IT_VALCSL],'CSL','CSLL - Via Retenção','CSL',.T.,.T.,lSoma)
		EndIf
		If (aNfItem[nX][IT_BASEFUN]<>0 .Or. aNfItem[nX][IT_FUNRURAL]<>0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_FUNRUR))
			MaFisResumo(aNfItem[nX][IT_BASEFUN],aNfItem[nX][IT_PERFUN],aNfItem[nX][IT_FUNRURAL],'FRU','GILRAT ','RUR',.T.,.T.,lSoma)
		EndIf
		
		IF !(aNfCab[NF_CHKTRIBLEG] .AND. (ChkTribLeg(aNFItem, nX, TRIB_ID_PIS) .OR. ChkTribLeg(aNFItem, nX, TRIB_ID_DZFPIS))) 
			If ((aNfItem[nX,IT_BASEPS2]<>0 .Or. aNfItem[nX,IT_VALPS2]<>0) .And. (aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nX,IT_CF],1,1)=="3" .And. aNFItem[nX][IT_TS][TS_INTBSIC]$"123"))
				MaFisResumo(aNfItem[nX,IT_BASEPS2],aNfItem[nX,IT_ALIQPS2],aNfItem[nX,IT_VALPS2],'PS2',Iif(aNFItem[nX][IT_TS][TS_ALQPMAJ]>0,'PIS - Importacao + Majorada','PIS - Importacao'),'PS2',,,lSoma)
			ElseIf (aNfItem[nX,IT_BASEPS2]<>0 .Or. aNfItem[nX,IT_VALPS2]<>0) .And.;
				((aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nX,IT_CF],1,1)=="3" .And. aNFItem[nX][IT_TS][TS_INTBSIC]$"123") .Or.;
				(aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nX,IT_CF],1,1)=="7" .And. aNFItem[nX][IT_TS][TS_INTBSIC]$"123"))
				MaFisResumo(aNfItem[nX,IT_BASEPS2],aNfItem[nX,IT_ALIQPS2],aNfItem[nX,IT_VALPS2],'PS2','PIS/Pasep - Importacao','PS2',,,lSoma)
			ElseIf aNfItem[nX,IT_BASEPS2]<>0 .Or. aNfItem[nX,IT_VALPS2]<>0
				MaFisResumo(aNfItem[nX,IT_BASEPS2],aNfItem[nX,IT_ALIQPS2],aNfItem[nX,IT_VALPS2],'PS2','PIS/Pasep - Via apuracao','PS2',,,lSoma)
			EndIf
		Endif
		IF !(aNfCab[NF_CHKTRIBLEG] .AND. (ChkTribLeg(aNFItem, nX, TRIB_ID_COF) .OR. ChkTribLeg(aNFItem, nX, TRIB_ID_DZFCOF)))
			If (aNfItem[nX,IT_BASECF2]<>0 .Or. aNfItem[nX,IT_VALCF2]<>0) .And. (aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nX,IT_CF],1,1)=="3" .And. aNFItem[nX][IT_TS][TS_INTBSIC]$"123")
				MaFisResumo(aNfItem[nX,IT_BASECF2],aNfItem[nX,IT_ALIQCF2],aNfItem[nX,IT_VALCF2],'CF2',Iif(aNFItem[nX][IT_TS][TS_ALQCMAJ]>0,'COFINS - Importacao + Majorada','COFINS - Importacao'),'CF2',,,lSoma)
			ElseIf (aNfItem[nX,IT_BASECF2]<>0 .Or. aNfItem[nX,IT_VALCF2]<>0) .And.;
				((aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nX,IT_CF],1,1)=="3" .And. aNFItem[nX][IT_TS][TS_INTBSIC]$"123") .Or.;
				(aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nX,IT_CF],1,1)=="7" .And. aNFItem[nX][IT_TS][TS_INTBSIC]$"123"))
				MaFisResumo(aNfItem[nX,IT_BASECF2],aNfItem[nX,IT_ALIQCF2],aNfItem[nX,IT_VALCF2],'CF2','COFINS - Importacao','CF2',,,lSoma)
			ElseIf aNfItem[nX,IT_BASECF2]<>0 .Or. aNfItem[nX,IT_VALCF2]<>0
				MaFisResumo(aNfItem[nX,IT_BASECF2],aNfItem[nX,IT_ALIQCF2],aNfItem[nX,IT_VALCF2],'CF2','COFINS - Via apuracao','CF2',,,lSoma)
			EndIf
		Endif
		If aNfItem[nx][IT_BASEAFRMM]<>0 .Or. aNfItem[nx][IT_VALAFRMM]<>0
			MaFisResumo(aNfItem[nx][IT_BASEAFRMM],aNfItem[nx][IT_ALIQAFRMM],aNfItem[nx][IT_VALAFRMM],'AFRMM','AFRMM','AFRMM',,,lSoma)
		EndIf
		If aNfItem[nX][IT_BASESES]<>0 .Or. aNfItem[nX][IT_VALSES]<>0
			MaFisResumo(aNfItem[nX][IT_BASESES],aNfItem[nX][IT_ALIQSES],aNfItem[nX][IT_VALSES],'SES','SEST/SENAT','SES',,,lSoma)
		EndIf
		If ((aNfItem[nx][IT_BASEPS3]<>0 .Or. aNfItem[nx][IT_VALPS3]<>0) .Or. (aNFItem[nX][IT_TS][TS_PSCFST] == "4" .And. aNfItem[nx][IT_ALIQPS3] != 0)) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_PISST))
			MaFisResumo(aNfItem[nx][IT_BASEPS3],aNfItem[nx][IT_ALIQPS3],aNfItem[nx][IT_VALPS3],'PS3','PIS/Pasep - Subst. Tributaria','PS3',,,lSoma)
		EndIf
		If ((aNfItem[nx][IT_BASECF3]<>0 .Or. aNfItem[nx][IT_VALCF3]<>0) .Or. (aNFItem[nX][IT_TS][TS_PSCFST] == "4" .And. aNfItem[nx][IT_ALIQCF3] != 0)) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_COFST))
			MaFisResumo(aNfItem[nx][IT_BASECF3],aNfItem[nx][IT_ALIQCF3],aNfItem[nx][IT_VALCF3],'CF3','COFINS - Subst. Tributaria','CF3',,,lSoma)
		EndIf
		If Mafiscache('MaFisSomaIt_Valid_B1_AFETHAB',,{|| fisExtCmp('12.1.2310', .T.,'SB1','B1_AFETHAB') .And. fisExtCmp('12.1.2310', .T.,'SA2','A2_RECFET') .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RECFET') .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CALCFET')})
			If aNfItem[nx][IT_BASEFET]<>0 .Or. aNfItem[nx][IT_VALFET]<>0
				MaFisResumo(aNfItem[nx][IT_BASEFET],aNfItem[nx][IT_ALIQFET],aNfItem[nx][IT_VALFET],'FET','FETHAB','FET',.T.,.T.,lSoma)
			Endif
		EndIf
		If Mafiscache('MaFisSomaIt_Valid_B1_AFABOV',,{|| fisExtCmp('12.1.2310', .T.,'SB1','B1_AFABOV') .And. fisExtCmp('12.1.2310', .T.,'SA2','A2_RFABOV') .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RFABOV') .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CFABOV')})
			If aNfItem[nx][IT_BASEFAB]<>0 .Or. aNfItem[nx][IT_VALFAB]<>0
				MaFisResumo(aNfItem[nx][IT_BASEFAB],aNfItem[nx][IT_ALIQFAB],aNfItem[nx][IT_VALFAB],'FAB','FABOV','FAB',.T.,.T.,lSoma)
			Endif
		EndIf
		If fisExtCmp('12.1.2310', .T.,'SB1','B1_ALFUMAC')
			If aNfItem[nx][IT_BASEFUM]<>0 .And. aNfItem[nx][IT_VALFUM]<>0
				MaFisResumo(aNfItem[nx][IT_BASEFUM],aNfItem[nx][IT_ALIQFUM],aNfItem[nx][IT_VALFUM],'FUM','FUMACOP','FUM',.T.,.T.,lSoma)
			Endif
		EndIf
		If Mafiscache('MaFisSomaIt_Valid_B1_AFACS',,{||fisExtCmp('12.1.2310', .T.,'SB1','B1_AFACS') .And. fisExtCmp('12.1.2310', .T.,'SA2','A2_RFACS') .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RFACS') .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CFACS')})
			If aNfItem[nx][IT_BASEFAC]<>0 .Or. aNfItem[nx][IT_VALFAC]<>0
				MaFisResumo(aNfItem[nx][IT_BASEFAC],aNfItem[nx][IT_ALIQFAC],aNfItem[nx][IT_VALFAC],'FAC','FACS','FAC',.T.,.T.,lSoma)
			Endif
		EndIf
		IF aNfItem[nX][IT_VALFMD] > 0
			MaFisResumo(aNfItem[nX][IT_BASEFMD],aNfItem[nX][IT_ALQFMD],aNfItem[nX][IT_VALFMD],'FMD','FAMAD','FMD',,,lSoma)
		EndIf
		If aNfItem[nX][IT_VALFDS] > 0
			MaFisResumo(0,0,aNfItem[nX][IT_VALFDS],'FDS','FUNDERSUL','FDS',.T.,.T.,lSoma)
		EndIf
		If (aNfItem[nX][IT_BSSENAR]<>0 .Or. aNfItem[nX][IT_VLSENAR]<>0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_SENAR))
			MaFisResumo(aNfItem[nX][IT_BSSENAR],aNfItem[nX][IT_ALSENAR],aNfItem[nX][IT_VLSENAR],'SENAR','SENAR','SENAR',.T.,.T.,lSoma)
		Endif
		If fisGetParam('MV_ALITPDP',0) > 0 .And. aNfCab[NF_BASTPDP] >= 100
			If aNfItem[nX][IT_BASTPDP] <> 0 .And. aNfItem[nX][IT_VALTPDP] <> 0 .And. nX == Len(aNfItem)
				MaFisResumo(aNfCab[NF_BASTPDP],aNfItem[nX][IT_ALITPDP],aNfCab[NF_VALTPDP],'TPD','TPDP-PB','TPDP',.T.,.T.,lSoma)
			Endif
		EndIf
		IF aNfItem[nX][IT_VALCPB] > 0 .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_CPRB))
			MaFisResumo(aNfItem[nX][IT_BASECPB],aNfItem[nX][IT_ALIQCPB],aNfItem[nX][IT_VALCPB],'CPB','CPRB','CPB',.T.,.T.,lSoma)
		EndIf
		If Mafiscache('MaFisSomaIt_Valid_B1_AFUNDES',,{||fisExtCmp('12.1.2310', .T.,'SB1','B1_AFUNDES') .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CFUNDES')})
			If aNfItem[nx][IT_BASFUND]<>0 .Or. aNfItem[nx][IT_VALFUND]<>0
				MaFisResumo(aNfItem[nx][IT_BASFUND],aNfItem[nx][IT_ALIFUND],aNfItem[nx][IT_VALFUND],'FUN','FUNDESA','FUN',.T.,.T.,lSoma)
			Endif
		EndIf
		If Mafiscache('MaFisSomaIt_Valid_B1_AIMAMT',,{|| fisExtCmp('12.1.2310', .T.,'SB1','B1_AIMAMT') .And. fisExtCmp('12.1.2310', .T.,'SA2','A2_RIMAMT') .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RIMAMT') .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CIMAMT')})
			If aNfItem[nx][IT_BASIMA]<>0 .Or. aNfItem[nx][IT_VALIMA]<>0
				MaFisResumo(aNfItem[nx][IT_BASIMA],aNfItem[nx][IT_ALIIMA],aNfItem[nx][IT_VALIMA],'IMA','IMA-MT','IMA',.T.,.T.,lSoma)
			Endif
		EndIf
		If Mafiscache('MaFisSomaIt_Valid_B1_AFASEMT',,{||fisExtCmp('12.1.2310', .T.,'SB1','B1_AFASEMT') .And. fisExtCmp('12.1.2310', .T.,'SA2','A2_RFASEMT') .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RFASEMT') .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CFASE')})
			If aNfItem[nx][IT_BASFASE]<>0 .Or. aNfItem[nx][IT_VALFASE]<>0
				MaFisResumo(aNfItem[nx][IT_BASFASE],aNfItem[nx][IT_ALIFASE],aNfItem[nx][IT_VALFASE],'FAS','FASE-MT','FAS',.T.,.T.,lSoma)
			Endif
		EndIf
		IF aNfItem[nX][IT_VALINP] > 0 .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_INSSPT))
			MaFisResumo(aNfItem[nX][IT_BASEINP],aNfItem[nX][IT_PERCINP],aNfItem[nX][IT_VALINP],'INP','INSS-Patronal','INP',.T.,.T.,lSoma)
		EndIf
		IF aNfItem[nX][IT_VALPRO] > 0 .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_PROTEG))
			MaFisResumo(aNfItem[nX][IT_BASEPRO],aNfItem[nX][IT_ALIQPRO],aNfItem[nX][IT_VALPRO],'PTG','PROTEGE-GO','PTG',.T.,.T.,lSoma)
		EndIf
		// Exibe os valores de ICMS,PIS e COFINS descontados do documento nas operacoes com ZFM/ALC.
		// Atencao: NUNCA habilitar estes campos p/ edicao no folder "Impostos".
		If (aNfCab[NF_SUFRAMA] .And. fisGetParam('MV_DESCZF',.T.) ) 
			If ((aNfItem[nX][IT_DESCZF] - (aNfItem[nX][IT_DESCZFPIS] + aNfItem[nX][IT_DESCZFCOF])) > 0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. PosICDesZF(aNfItem, nX, IT_TRIBGEN, TRIB_ID_ICMDES) > 0)
				MaFisResumo(0,0,aNfItem[nX][IT_DESCZF] - (aNfItem[nX][IT_DESCZFPIS] + aNfItem[nX][IT_DESCZFCOF]),'ZFI','ICMS Desonerado - ZFM','ZFI',.T.,.T.,lSoma)
			EndIf
			If aNfItem[nX][IT_DESCZFPIS] > 0 .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_DZFPIS))
				MaFisResumo(0,0,aNfItem[nX][IT_DESCZFPIS],'ZFP','PIS Desonerado - ZFM','ZFP',.T.,.T.,lSoma)
			EndIf
			If aNfItem[nX][IT_DESCZFCOF] > 0 .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_DZFCOF))
				MaFisResumo(0,0,aNfItem[nX][IT_DESCZFCOF],'ZFC','COFINS Desonerado - ZFM','ZFC',.T.,.T.,lSoma)
			EndIf
		EndIf
		//Valido a existencia dos novos campos de base de calculo para que nao sejam exibidos
		//os valores 'segregados' de FCP de NF's emitidas anteriormente à criacao destes campos. A ideia
		//eh manter o sistema exatamente como ele trabalhava antes da NF-e 4.0 e soh demonstrar os valores
		//separadamente em NF's emitidas apos a implementacao da NF-e / atualizacao do dicionario.

		If Mafiscache('MaFisSomaIt_Valid_FT_BASFECP',,{||fisExtCmp('12.1.2310', .T.,'SFT','FT_BASFECP') .And. fisExtCmp('12.1.2310', .T.,'SFT','FT_BSFCPST') .And. fisExtCmp('12.1.2310', .T.,'SFT','FT_BSFCCMP')})

			// Nas devoluções considerar o FCP da UF de origem do documento.
			cUFFCP := IIf(aNFCab[NF_TIPONF] $ "DB", aNfCab[NF_UFORIGEM], aNFCab[NF_UFDEST])

			// FCP Proprio.
			If (aNfItem[nX][IT_BASFECP] > 0 .And. (aNfItem[nX][IT_ALIQFECP] > 0 .Or. aNfItem[nX][IT_FCPAUX] > 0)) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_FECPIC))
				MaFisResumo(aNfItem[nX][IT_BASFECP],IIf(aNfItem[nX][IT_FCPAUX] > 0, aNfItem[nX][IT_FCPAUX], aNfItem[nX][IT_ALIQFECP]),aNfItem[nX][IT_VALFECP],'FCP',xFisNameFCP(cUFFCP, .F., .F.),'FCP',.T.,.T.,lSoma)
			EndIf

			// FCP Complementar (Diferencial de Aliquotas - Entrada)
			If (aNfItem[nX][IT_BSFCCMP] > 0 .And. (aNfItem[nX][IT_ALFCCMP] > 0 .Or. aNfItem[nX][IT_FCPAUX] > 0) .And. aNfItem[nX][IT_VALFECP] > 0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_FCPCMP))
				MaFisResumo(aNfItem[nX][IT_BSFCCMP],IIf(aNfItem[nX][IT_FCPAUX] > 0, aNfItem[nX][IT_FCPAUX], aNfItem[nX][IT_ALFCCMP]),aNfItem[nX][IT_VALFECP],'FCM',xFisNameFCP(cUFFCP, .F., .T.),'FCM',.T.,.T.,lSoma)
			EndIf

			// FCP ST
			If (aNfItem[nX][IT_BSFCPST] > 0 .And. (aNfItem[nX][IT_ALFCST] > 0 .Or. aNfItem[nX][IT_FCPAUX] > 0) .And. aNfItem[nX][IT_VFECPST] > 0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_FCPST))
				MaFisResumo(aNfItem[nX][IT_BSFCPST],IIf(aNfItem[nX][IT_FCPAUX] > 0, aNfItem[nX][IT_FCPAUX], aNfItem[nX][IT_ALFCST]),aNfItem[nX][IT_VFECPST],'FST',xFisNameFCP(cUFFCP, .T., .F.),'FST',.T.,.T.,lSoma)
			EndIf

			// FCP Complementar (Diferencial de Aliquotas - Saida)
			If (aNfItem[nX][IT_BSFCCMP] > 0 .And. (aNfItem[nX][IT_ALFCCMP] > 0 .Or. aNfItem[nX][IT_FCPAUX] > 0) .And. aNfItem[nX][IT_VFCPDIF] > 0) .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_FCPCMP))
				MaFisResumo(aNfItem[nX][IT_BSFCCMP],IIf(aNfItem[nX][IT_FCPAUX] > 0, aNfItem[nX][IT_FCPAUX], aNfItem[nX][IT_ALFCCMP]),aNfItem[nX][IT_VFCPDIF],'FCM',xFisNameFCP(cUFFCP, .F., .T.),'FCM',.T.,.T.,lSoma)
			EndIf

		EndIf
		//FEEF -RJ
		If aNfItem[nX][IT_BASFEEF] > 0 .and. aNfItem[nX][IT_VALFEEF] > 0 .And. !(aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nX, TRIB_ID_FEEF))
			MaFisResumo(aNfItem[nX][IT_BASFEEF],aNfItem[nX][IT_ALQFEEF],aNfItem[nX][IT_VALFEEF],'FEEF','FEEF - Fundo Est. Equilíbrio Fiscal','FEEF',.T.,.T.,lSoma)
		Endif
		//Aqui faço laço nos tributos genéricos, para chamar a MaFisResumo
		If cPaisLoc == "BRA"
			For nTrbGen:= 1 to Len(aNfItem[nx][IT_TRIBGEN])

				if aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_BASE] == 0 .AND. aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_ALIQUOTA] == 0
					aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_VL_ZERO] := .T.
				EndIf

				cSiglaGen	:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_SIGLA]
				cDescriGen  := aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_DESCRICAO]
				nBaseGen	:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_BASE]
				nAlqGen		:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_ALIQUOTA]
				nValGen		:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_VALOR]
				lZero 		:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_VL_ZERO]
				
				//Se o tributo genérico possuir base ou valor chamarei a Resumo
				If (nBaseGen > 0 .Or. nValGen > 0) .OR. aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_DED_DEP] > 0 .Or. lZero
					MaFisResumo(nBaseGen,nAlqGen,nValGen,cSiglaGen,cDescriGen,'TG',.T.,.T.,lSoma)
				EndIF

			Next nTrbGen
		EndIf
	Endif

	If cPaisLoc == "BRA" .Or. lNotRemito
		For nG := 1 To NMAXIV
			If aNfItem[nX][IT_BASEIMP][nG]<>0 .Or. aNfItem[nX][IT_VALIMP][nG]<>0
				MaFisResumo(aNfItem[nX][IT_BASEIMP][nG],aNfItem[nX][IT_ALIQIMP][nG],aNfItem[nX][IT_VALIMP][nG],aNfItem[nX][IT_DESCIV][nG][1],aNfItem[nX][IT_DESCIV][nG][2],"IV"+NumCpoImpVar(nG),,,lSoma)
			EndIf
		Next nG

		MaFisLFToLivro(nX,@aAuxOri,lSoma)

	EndIf

	If !lSoma // Executa a correcao nos arredondamentos.
		For nY := 1 to Len(aItemRef)
			If aItemRef[nY][4]
				If !aItemRef[nY][5]
					If ValType(aItemRef[nY][2]) == "A"
						aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += aItemDec[nX][2][nY]
						aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] -= aItemDec[nX][1][nY]
					Else
						aNfItem[nX][Val(aItemRef[nY][2])] += aItemDec[nX][2][nY]
						aNfItem[nX][Val(aItemRef[nY][2])] -= aItemDec[nX][1][nY]
					EndIf
					aSaveDec[nY] += aItemDec[nX][1][nY]
					aSaveDec[nY] -= aItemDec[nX][2][nY]
				Else
					If ValType(aItemRef[nY][2]) == "A"
						aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += aItemDec[nX][2][nY]
						aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] -= aItemDec[nX][1][nY]
					Else
						aNfItem[nX][Val(aItemRef[nY][2])] += aItemDec[nX][2][nY]
						aNfItem[nX][Val(aItemRef[nY][2])] -= aItemDec[nX][1][nY]
					EndIf
					If !(!Empty(cCampo) .And. cCampo == aItemRef[nY][1])
						aSaveDec[nY] += aItemDec[nX][1][nY]
						aSaveDec[nY] -= aItemDec[nX][2][nY]
					EndIf
				EndIf
				aItemDec[nX][1][nY]:= 0
				aItemDec[nX][2][nY]:= 0
			EndIf
		Next nY
	EndIf

	If !lSoma .AND. cPaisLoc == "BRA" .AND. aNfCab[NF_CHKTRIBLEG]
		//Realiza ajuste de arredondamento nos tributos genéricos.
		TGAjuArred(@aNFCab, @aNfItem, aTGITRef, nx, cCampo)
	EndIF

	If fisExtPE('MXTOTIT')
		// PE para manipulação dos valores das referencias (em uso na importação TSF)
		// nesse ponto passa 0 para aplicar regra somente para o cabecalho
		ExecBlock("MXTOTIT",.F.,.F.,{0})
	EndIf

EndIf

Return

/*/
MaFisResum - Edson Maricate -13.12.1999
Atualiza o Array de Resumos da NF.
/*/
Function MaFisResumo(nValBase,nAliquota,nValor,cCodImp,cDescImp,cNomeRef,lForceVlr,lForceBs,lSoma)
Local nRS  := 0
Local nRS2 := 0

DEFAULT lForceVlr := .F.
DEFAULT lForceBs  := .F.
DEFAULT lSoma	  := .T.

If Empty(cCodImp)
	Return	.F.
Endif

If !Empty(aNfCab[NF_IMPOSTOS]) .And. aNfCab[NF_IMPOSTOS][1][1] == ""
	aNfCab[NF_IMPOSTOS] := {}
	aNfCab[NF_IMPOSTOS2]:= {}
Else
	nRS	:= aScan(aNfCab[NF_IMPOSTOS] ,{|x| x[IMP_COD] == cCodImp .And. x[IMP_ALIQ] == nAliquota })
	nRS2:= aScan(aNfCab[NF_IMPOSTOS2],{|x| x[IMP_COD] == cCodImp })
EndIf

If aNfCab[NF_RELIMP] <> Nil .And. !Empty(aNfCab[NF_RELIMP])
	nValBase := IIf( aScan(aNfCab[NF_RELIMP] , {|x|"BASE" + cNomeRef $ x[3] } ) > 0 .Or. lForceBs  , nValBase , 0 )
	nValor	 := IIf( aScan(aNfCab[NF_RELIMP] , {|x|"VAL"  + cNomeRef $ x[3] } ) > 0 .Or. lForceVlr , nValor   , 0 )
EndIf

If cPaisLoc == "CHI" .And. fisGetParam('MV_PRCDEC',.F.)
	aNfCab[NF_TOTAL]   := Round(aNfCab[NF_TOTAL]   , MsDecimais(aNFCab[NF_MOEDA]))
	aNfCab[NF_VALMERC] := Round(aNfCab[NF_VALMERC] , MsDecimais(aNFCab[NF_MOEDA]))
	aNfCab[NF_BASEDUP] := Round(aNfCab[NF_BASEDUP] , MsDecimais(aNFCab[NF_MOEDA]))
	nValor   		   := Round(nValor             , MsDecimais(aNFCab[NF_MOEDA]))
ElseIf cPaisLoc == "ANG" .And. fisGetParam('MV_RNDANG',.F.) //Arredondamento do valor total da nota de acordo com MV_RNDANG para localizado Angola
	aNfCab[NF_TOTAL]   := int(aNfCab[NF_TOTAL]  ) + IIf( aNfCab[NF_TOTAL]   - int(aNfCab[NF_TOTAL]  )  >= 0.01 , 1.0 , 0.0 )
	aNfCab[NF_BASEDUP] := int(aNfCab[NF_BASEDUP]) + IIf( aNfCab[NF_BASEDUP] - int(aNfCab[NF_BASEDUP])  >= 0.01 , 1.0 , 0.0 )
EndIf

If lSoma

	If nRS > 0
		aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] 	+= nValBase
		aNfCab[NF_IMPOSTOS][nRS][IMP_VAL]  	+= nValor
	Else
		aadd(aNfCab[NF_IMPOSTOS],{cCodImp,cDescImp,nValBase,nAliquota,nValor,cNomeRef})
	EndIf

	If nRS2 > 0
		If cPaisLoc $ "CHI" .And. fisGetParam('MV_PRCDEC',.F.)
			aNfCab[NF_IMPOSTOS2][nRS2][3] 	+= Round(nValBase,MsDecimais(aNFCab[NF_MOEDA]))
			aNfCab[NF_IMPOSTOS2][nRS2][4] 	+= Round(nValor,MsDecimais(aNFCab[NF_MOEDA]))
		Else
			aNfCab[NF_IMPOSTOS2][nRS2][3] 	+= nValBase
			aNfCab[NF_IMPOSTOS2][nRS2][4] 	+= nValor
		EndIf
	Else
		If cPaisLoc == "CHI" .And. fisGetParam('MV_PRCDEC',.F.)
			aadd(aNfCab[NF_IMPOSTOS2],{cCodImp,cDescImp,Round(nValBase,MsDecimais(aNFCab[NF_MOEDA])),Round(nValor,MsDecimais(aNFCab[NF_MOEDA])),cNomeRef})
		Else
			aadd(aNfCab[NF_IMPOSTOS2],{cCodImp,cDescImp,nValBase,nValor,cNomeRef})
		EndIf
	EndIf

Else

	If nRS > 0
		aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] 	-= nValBase
		aNfCab[NF_IMPOSTOS][nRS][IMP_VAL]  	-= nValor
		If  aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] <= 0 .And. aNfCab[NF_IMPOSTOS][nRS][IMP_VAL] <= 0
			aDel(aNfCab[NF_IMPOSTOS],nRS)
			aSize(aNfCab[NF_IMPOSTOS],Len(aNfCab[NF_IMPOSTOS])-1)
		EndIf
	EndIf

	If nRS2 > 0
		aNfCab[NF_IMPOSTOS2][nRS2][3] 	-= nValBase
		aNfCab[NF_IMPOSTOS2][nRS2][4] 	-= nValor
		If  aNfCab[NF_IMPOSTOS2][nRS2][3] <= 0 .And. aNfCab[NF_IMPOSTOS2][nRS2][4] <= 0
			aDel(aNfCab[NF_IMPOSTOS2],nRS2)
			aSize(aNfCab[NF_IMPOSTOS2],Len(aNfCab[NF_IMPOSTOS2])-1)
		EndIf
	EndIf

EndIf

Return .T.

/*
MaFisLFToLivro - Edson Maricate - 07.03.2000
Adiciona o item nos livros fiscais
*/
Function MaFisLFToLivro(nItem,aNotasOri,lSoma)

	xLFToLivro(nItem,aNotasOri,lSoma,aPos,@aNfItem,@aTes,@aNfCab,aPE,aSX6)

Return .T.

/*/
MaFisLF -  Edson Maricate - 20.12.1999
Atualiza os livros fiscais para o item.
/*/
Function MaFisLF(nItem,lRecPreSt,lProcExcecao)

	xFisLF(nItem, lRecPreSt, @aNFItem, @aNfCab, aSX6, aPos, aPE, cAliasPROD, aFunc,aInfNat, aDic,lProcExcecao)

Return

/*/
MaRateio -Edson Maricate  -20.12.2000
Esta rotina tem como objetivo efetuar o rateio das despesas
acessorias sobre todos os itens da nota fiscal, exceto os
que possuirem a referencia ISS.
Parametros
ExpC1: Nome da Referencia da despesas acessoria
ExpN2: Valor atual da despesa acessoria
ExpN3: Novo valor da despesa acessoria
/*/
Static Function MaRateio(cReferencia,nAnterior,nAtual,lDupl,aTrbGen)

Local aRateio    := {}
Local nX		 := 0
Local nDiferenca := 0
Local nY		 := 0
Local nSoma 	 := 0
Local nValMISS   := 0
Local nValDISS   := 0
Local nPesoMISS  := 0
Local nDec       := 2
Local nItValMerc := 0
Local nBseRateio := 0
Local aPosCpo	 := MaFisScan(cReferencia)
Local cMvRatDesp := fisGetParam('MV_RATDESP','')
Local cTpRatDesp := Substr(cMvRatDesp,AT("DESP=",cMvRatDesp)+5,1)
Local cTpRatFrete:= Substr(cMvRatDesp,AT("FR=",cMvRatDesp)+3,1)
Local cTpRatSeg	 := Substr(cMvRatDesp,AT("SEG=",cMvRatDesp)+4,1)
Local cTpRatNTr	 := Substr(cMvRatDesp,AT("NTRB=",cMvRatDesp)+5,1)
Local cTpRatTara := Substr(cMvRatDesp,AT("TARA=",cMvRatDesp)+5,1)
Local lRatDesc	 :=	( (cReferencia == "IT_DESCONTO" .OR. cReferencia == "IT_DESCTOT" ) .And. cPaisLoc <> "BRA" .And. (aNfCab[NF_OPERNF] == "S" .Or. (cPaisLoc=="COL" .And. aNfCab[NF_OPERNF] == "E" .And. FunName()=="MATA465N")) .And. fisGetParam('MV_DESCSAI','') == "1" )
Local lRateiaIt  := .T.
Local lRatECF    := aNfCab[NF_ROTINA] == 'LOJA701' .AND. (cReferencia $ "IT_DESCTOT|IT_ACRESCI") .AND. fisFindFunc("STFIsPOS") .AND. STFIsPOS() .AND. fisFindFunc("STBTaxGrupTrib") .AND. fisFindFunc("STBTaxRateio")
Local lTribGen   := cPaisLoc == "BRA" .And. AllTrim(cReferencia) == "IT_TRIBGEN"
Local nPosRefGen := 0
Local nPosGen    := 0

DEFAULT lDupl := .F.
DEFAULT aTrbGen := {"",""}

If cPaisLoc<>"BRA"
	If FunName() $ "MATA120|MATA121" .And. Type("nMoedaPed")=="N"
		nDec:=MsDecimais(nMoedaPed)
	ElseIf FunName()=="MATA123" .And. Type("nMoedaPed")=="N"
		nDec:=MsDecimais(nMoedaPed)
	ElseIf FunName()=="MATA150" .And. Type("nMoedaCot")=="N"
		nDec:=MsDecimais(nMoedaCot)
	ElseIf FunName()=="MATA160" .And. Type("nMoedaAval")=="N"
		nDec:=MsDecimais(nMoedaAval)
	ElseIf Type("nMoedaNF")=="N"
		nDec:=MsDecimais(nMoedaNF)
	ElseIf Type("nMoedaCor")=="N"
		nDec:=MsDecimais(nMoedaCor)
	ElseIf Type("M->F1_MOEDA")=="N"
		nDec:=MsDecimais(M->F1_MOEDA)
	ElseIf Type("M->F2_MOEDA")=="N"
		nDec:=MsDecimais(M->F2_MOEDA)
	ElseIf FunName()=="MATA143" .And. Type("nMoedaDes")=="N"
		nDec:=MsDecimais(nMoedaDes)
	Else
		nDec:=MsDecimais(1)
	Endif
Endif

If fisExtPE('MARATEIO')
	aRateio := ExecBlock("MARATEIO",.F.,.F.,{cTpRatDesp,cTpRatFrete,cTpRatSeg,cTpRatNTr,cTpRatTara})
	cTpRatDesp  := aRateio[1]
	cTpRatFrete := aRateio[2]
	cTpRatSeg   := aRateio[3]
	cTpRatNTr	:= Iif(Len(aRateio) > 3 , aRateio[4] , "" )
	cTpRatTara	:= Iif(Len(aRateio) > 4 , aRateio[5] , "" )
EndIf

If ( "FRETE"$cReferencia .Or. "SEGURO"$cReferencia .Or. "DESPESA"$cReferencia .Or. "VLR_FRT"$cReferencia .Or. "DESNTRB"$cReferencia .Or."TARA"$cReferencia)
	If aNfCab[NF_PESO] <> 0 .And. ((cReferencia == "IT_FRETE" .And. cTpRatFrete == "2" ) .Or. ;
			(cReferencia == "IT_DESPESA" .And. cTpRatDesp == "2" ).Or.;
			(cReferencia == "IT_SEGURO"  .And. cTpRatSeg  == "2" ).Or.;
			(cReferencia == "IT_VLR_FRT" .And. cTpRatFrete== "2" ).Or.;
			(cReferencia == "IT_DESNTRB" .And. cTpRatNTr  == "2" ).Or.;
			(cReferencia == "IT_TARA"    .And. cTpRatTara == "2" ))
		aEval(aNfItem,{|x| nPesoMISS+= If(!x[IT_DELETED] .And. x[IT_RATEIOISS]=="S" .And. (!lDupl .Or. x[IT_BASEDUP]>0),x[IT_PESO],0)})
	Else
		aEval(aNfItem,{|x| nValMISS += If(!x[IT_DELETED] .And. x[IT_RATEIOISS]=="S" .And. (!lDupl .Or. x[IT_BASEDUP]>0),(x[IT_VALMERC]+x[IT_VNAGREG]),0)})
		aEval(aNfItem,{|x| nValDISS += If(!x[IT_DELETED] .And. x[IT_RATEIOISS]=="S" .And. (!lDupl .Or. x[IT_BASEDUP]>0),((x[IT_VALMERC]-(x[IT_DESCONTO]+x[IT_DESCTOT]))+x[IT_VNAGREG]),0)})
	EndIf
EndIf

// O MV_VALDESP = T impede que as despesas sejam rateadas no item com F4_ICMS = N para que o valor total das despesas sejam rateadas entre os itens F4_ICMS=S para que o frete integral faca parte da base do ICMS
// O MV_RATAGRE = T impede que as despesas sejam rateadas no item com F4_AGREG = N para que o valor total das despesas sejam rateadas entre os itens F4_AGREG=S.
// OBSERVACAO - INFORMACOES DA TES PODERIA ESTAR NO ITEM
If ((fisGetParam('MV_VALDESP',.F.) .Or. fisGetParam('MV_RATAGRE',.F.)) .And. !lTribGen)
	For nX	:= 1 to Len(aNfItem)
		SF4->(dbSetOrder(1))
		SF4->(MsSeek(xFilial("SF4")+aNfItem[nX][IT_TES] ))
		If fisGetParam('MV_VALDESP',.F.) .And. SF4->F4_ICM == "N" .And. !aNfItem[nX][IT_DELETED]
			nItValMerc += aNfItem[nX][IT_VALMERC]
		ElseIf fisGetParam('MV_RATAGRE',.F.) .And. SF4->F4_AGREG == "N" .And. !aNfItem[nX][IT_DELETED]
			nItValMerc += aNfItem[nX][IT_VALMERC]
		EndIf
	Next nX
EndIf

If nAnterior > 0

	nDiferenca := (nAtual-nAnterior) / nAnterior

	If AllTrim(cReferencia) == "IT_TRIBGEN"

		nPosRefGen := MaFisScan(aTrbGen[TG_REFERENCIA])

		For nX := 1 to Len(aNfItem)

			// Verifica se o item não está deletado e se o tributo em questão foi calculado
			lRateiaIt := !aNfItem[nX][IT_DELETED] .And. ((nPosGen := aScan(aNFItem[nX][IT_TRIBGEN], {|x| Alltrim(x[TG_IT_SIGLA]) == Alltrim(aTrbGen[TG_SIGLA])})) > 0)

			If lRateiaIt
				aNfItem[nX][IT_TRIBGEN][nPosGen][nPosRefGen] := NoRound((1+nDiferenca)*aNfItem[nX][IT_TRIBGEN][nPosGen][nPosRefGen],nDec)
				nSoma += aNfItem[nX][IT_TRIBGEN][nPosGen][nPosRefGen]
				nY := nX
			EndIf

		Next nX

		// Efetua a correcao da dizima no ultimo item.
		If nY <> 0 .And. nPosGen > 0
			aNfItem[nY][IT_TRIBGEN][nPosGen][nPosRefGen] += nAtual - nSoma
		EndIf

	Else

		For nX	:= 1 to Len(aNfItem)

			lRateiaIt := .T.
			SF4->(dbSetOrder(1))
			SF4->(MsSeek(xFilial("SF4")+aNfItem[nX][IT_TES] ))
			If fisGetParam('MV_VALDESP',.F.) .And. SF4->F4_ICM == "N"
				If ValType(aPosCpo) == "A"
					aNfItem[nX][aPosCpo[1]][aPosCpo[2]] := 0
				Else
					aNfItem[nX][Val(aPosCpo)] := 0
				EndIf
				lRateiaIt := .F. //Impede que o item participe do rateio das depesas
			EndIf
			If fisGetParam('MV_RATAGRE',.F.) .And. SF4->F4_AGREG == "N"
				If ValType(aPosCpo) == "A"
					aNfItem[nX][aPosCpo[1]][aPosCpo[2]] := 0
				Else
					aNfItem[nX][Val(aPosCpo)] := 0
				EndIf
				lRateiaIt := .F. //Impede que o item participe do rateio do desconto
			EndIf
			If lRateiaIt .And. !aNfItem[nX][IT_DELETED] .And.;
				!( aNfItem[nX][IT_RATEIOISS]=="S" .And. ("FRETE"$cReferencia .Or. "SEGURO"$cReferencia .Or. "DESPESA"$cReferencia .Or. "VLR_FRT"$cReferencia .Or. "DESNTRB"$cReferencia .Or."TARA"$cReferencia) ) .And.;
				(!lDupl .Or. aNfItem[nX][IT_BASEDUP]>0)

				If ValType(aPosCpo) == "A"
					If cPaisLoc == "RUS" .and. "_C1" $ cReferencia
						aNfItem[nX][aPosCpo[1]][aPosCpo[2]] := Round((1+nDiferenca)*aNfItem[nX][aPosCpo[1]][aPosCpo[2]],nDec)
					Else
						aNfItem[nX][aPosCpo[1]][aPosCpo[2]] := NoRound((1+nDiferenca)*aNfItem[nX][aPosCpo[1]][aPosCpo[2]],nDec)
					EndIf
					IF cPaisLoc=="COL" .And. (NoRound((1+nDiferenca)*aNfItem[nX][aPosCpo[1]][aPosCpo[2]],nDec) == 0) .and. (nAnterior==0)
						Loop
					Else
						nY := nX
					EndIf
					nSoma += aNfItem[nX][aPosCpo[1]][aPosCpo[2]]
				Else
				IF cPaisLoc=="COL" .And. (NoRound((1+nDiferenca)*aNfItem[nX][Val(aPosCpo)],nDec) == 0) .and. (nAnterior==0)
						Loop
					Else
						nY := nX
					EndIf
					If lRatDesc
						aNFitem[nX][IT_VALMERC]   += aNfItem[nX][Val(aPosCpo)]
						aNfItem[nX][Val(aPosCpo)] := NoRound((1+nDiferenca)*aNfItem[nX][Val(aPosCpo)],nDec)
						nSoma += aNfItem[nX][Val(aPosCpo)]
						If cPaisLoc == "RUS"
							aNFitem[nX][IT_VALMERC_C1]   += xMoeda(aNfItem[nX][Val(aPosCpo)],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
						EndIf
					Else
						If (cPaisLoc=="RUS") .and. ("_C1" $ cReferencia)
							aNfItem[nX][Val(aPosCpo)] := Round((1+nDiferenca)*aNfItem[nX][Val(aPosCpo)],nDec)
						Else
							aNfItem[nX][Val(aPosCpo)] := NoRound((1+nDiferenca)*aNfItem[nX][Val(aPosCpo)],nDec)
						EndIf
						nSoma += aNfItem[nX][Val(aPosCpo)]
					Endif
				EndIf
			EndIf

		Next nX

		// Efetua a correcao da dizima no primeiro item.
		If nY <> 0
			If ValType(aPosCpo) == "A"
				aNfItem[nY][aPosCpo[1]][aPosCpo[2]] += nAtual - nSoma
			Else
				aNfItem[nY][Val(aPosCpo)] += nAtual - nSoma
			EndIf
		EndIf

	EndIf

Else
	For nX	:= 1 to Len(aNfItem)

        lRateiaIt := .T.
		SF4->(dbSetOrder(1))
		SF4->(MsSeek(xFilial("SF4") + aNfItem[nX][IT_TES] ))
		If fisGetParam('MV_VALDESP',.F.) .And. SF4->F4_ICM == "N"
			If ValType(aPosCpo) == "A"
				aNfItem[nX][aPosCpo[1]][aPosCpo[2]] := 0
            Else
				aNfItem[nX][Val(aPosCpo)] := 0
            EndIf
           lRateiaIt := .F. //Impede que o item participe do rateio das depesas
        EndIf
		If fisGetParam('MV_RATAGRE',.F.) .And. SF4->F4_AGREG == "N"
			If ValType(aPosCpo) == "A"
				aNfItem[nX][aPosCpo[1]][aPosCpo[2]] := 0
            Else
				aNfItem[nX][Val(aPosCpo)] := 0
            EndIf
           lRateiaIt := .F. //Impede que o item participe do rateio do desconto
        EndIf
		If lRateiaIt .And. !aNfItem[nX][IT_DELETED] .And.;
			!( aNfItem[nX][IT_RATEIOISS]=="S" .And. ("FRETE"$cReferencia .Or. "SEGURO"$cReferencia .Or. "DESPESA"$cReferencia .Or. "VLR_FRT"$cReferencia .Or. "DESNTRB"$cReferencia .Or."TARA"$cReferencia) ).And.;
			(!lDupl .Or. aNfItem[nX][IT_BASEDUP]>0)
			nY := nX
			// Efetua o rateio do valor informado nos itens da NF
			// O rateio das despesas ( frete/seguro/despesas ) podera
			// ser efetuado por valor ou peso, de acordo com a config.
			// do parametro MV_RATDESP.
			If aNfCab[NF_PESO] <> 0 .And. (( cReferencia == "IT_FRETE" .And. cTpRatFrete == "2" ) .Or. ;
					(cReferencia=="IT_DESPESA" .And. cTpRatDesp == "2") .Or. ;
					(cReferencia=="IT_SEGURO"  .And. cTpRatSeg  == "2") .Or. ;
					(cReferencia=="IT_VLR_FRT" .And. cTpRatFrete== "2") .Or. ;
					(cReferencia=="IT_DESNTRB" .And. cTpRatNTr  == "2") .Or. ;
					(cReferencia=="IT_TARA"    .And. cTpRatTara == "2"))
				// Rateio por Peso.
				If ValType(aPosCpo) == "A"
					aNfItem[nX][aPosCpo[1]][aPosCpo[2]] += NoRound((nAtual-nAnterior)*(aNfItem[nX][IT_PESO]/(aNfCab[NF_PESO]-nPesoMISS)),nDec)
					nSoma += aNfItem[nX][aPosCpo[1]][aPosCpo[2]]
				Else
					aNfItem[nX][Val(aPosCpo)] += NoRound((nAtual-nAnterior)*(aNfItem[nX][IT_PESO]/(aNfCab[NF_PESO]-nPesoMISS)),nDec)
					nSoma += aNfItem[nX][Val(aPosCpo)]
				EndIf
			Else
				// Rateio por Valor.
				If ValType(aPosCpo) == "A"
					aNfItem[nX][aPosCpo[1]][aPosCpo[2]] += NoRound((nAtual-nAnterior)*(aNfItem[nX][IT_VALMERC]/((aNfCab[NF_VALMERC]+aNfCab[NF_VNAGREG] - nItValMerc )-nValMISS)),nDec)
					nSoma += aNfItem[nX][aPosCpo[1]][aPosCpo[2]]
				Else
					If lRatDesc
						aNFitem[nX][IT_VALMERC]  += NoRound(aNfItem[nX][Val(aPosCpo)],nDec)
						aNfItem[nX][Val(aPosCpo)]+= NoRound((nAtual-nAnterior)*(aNfItem[nX][IT_VALMERC]/((aNfCab[NF_VALMERC]+aNfCab[NF_VNAGREG]- nItValMerc )-nValMISS)),nDec)
						nSoma += aNfItem[nX][Val(aPosCpo)]
						If cPaisLoc == "RUS"
							aNFitem[nX][IT_VALMERC_C1]  += NoRound(xMoeda(aNfItem[nX][Val(aPosCpo)],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA]),nDec)
						EndIf
					Else
						If aNfCab[NF_ROTINA] == "MATA461"
							nBseRateio := Iif(("FRETE"$cReferencia .Or. "SEGURO"$cReferencia .Or. "DESPESA"$cReferencia) .And. (aNfCab[NF_DESCONTO] + aNfCab[NF_DESCTOT]) > 0 , aNfCab[NF_VALMERC] - (aNfCab[NF_DESCONTO]+ aNfCab[NF_DESCTOT]), aNfCab[NF_VALMERC] )

							//Realizada correcao para que o rateio por valor seja realizado corretamente quando existir abatimento C5_DESCONT no pedido de venda.
							aNfItem[nX][Val(aPosCpo)]+= Round((nAtual-nAnterior)*((aNfItem[nX][IT_VALMERC] - (aNfItem[nX][IT_DESCONTO] + aNfItem[nX][IT_DESCTOT]))/((( nBseRateio - nItValMerc)+aNfCab[NF_VNAGREG])-nValDISS)),MsDecimais(aNfCab[NF_MOEDA]))
						ElseIf lRatECF
							STBTaxGrupTrib(aNfCab,aNfItem,nX,cReferencia)
						Else
							aNfItem[nX][Val(aPosCpo)]+= Round((nAtual-nAnterior)*(aNfItem[nX][IT_VALMERC]/((aNfCab[NF_VALMERC] - nItValMerc +aNfCab[NF_VNAGREG])-nValMISS)),MsDecimais(aNfCab[NF_MOEDA]))
						EndIf
						nSoma += aNfItem[nX][Val(aPosCpo)]
					Endif
				EndIf
			EndIf
		EndIf
	Next nX

	If lRatECF
		STBTaxRateio(aNfCab,@aNfItem,aPosCpo,cReferencia,nDec)
    Else
		//Efetua a correcao da dizima no primeiro item
		If nY <> 0
			If ValType(aPosCpo) == "A"
				If aNfItem[nY][aPosCpo[1]][aPosCpo[2]] + ( nAtual-nSoma ) >= 0
					aNfItem[nY][aPosCpo[1]][aPosCpo[2]] += nAtual-nSoma
	            Else
	                For nY :=1 to Len(aNfItem)
						If aNfItem[nY][aPosCpo[1]][aPosCpo[2]] + ( nAtual-nSoma ) >= 0
	 						aNfItem[nY][aPosCpo[1]][aPosCpo[2]] += nAtual-nSoma
	                        Exit
	                    EndIf
	                Next nY
	            EndIf
			Else
	            If aNfItem[nY][Val(aPosCpo)] + ( nAtual-nSoma ) >= 0
					aNfItem[nY][Val(aPosCpo)] += nAtual-nSoma

	            Else
	                For nY :=1 to Len(aNfItem)
	                	If aNfItem[nY][Val(aPosCpo)] + ( nAtual-nSoma ) >= 0
							aNfItem[nY][Val(aPosCpo)] += nAtual-nSoma
	                        Exit
	                    EndIf
	                Next nY
	            EndIf
			EndIf
		EndIf
	EndIf
EndIf

Return

/*/
MaFisRatRe -Edson Maricate  -20.12.1999
Esta rotina tem como objetivo distribuir o valor da referencia alterada, entre os itens de mesma referencia.
Rateio do resumo de impostos
Parametros
ExpC1: Nome da Referencia do imposto
ExpN2: Valor atual da referencia
ExpN3: Aliquota da referencia alterada
ExpN4: Nome da Referencia Aliquota para este imposto
/*/
Function MaFisRatRes(cReferencia,nAtual,nAliquota,cCpoAliq,cCpoBase,nItemNao,aTrbGen)

Local aPosCpo 	:= MaFisScan(cReferencia)
Local nCpoAliq	:= MaFisScan(cCpoAliq)
Local nCpoBase	:= MaFisScan(cCpoBase,.F.)
Local nX        := 0
Local nTotAcum	:= 0
Local nAuxItem	:= 0
Local nAliqItem	:= 0
Local nBaseTot	:= 0
Local nVlrTot   := 0
Local nFator    := 0
Local nPosItRef := 0
Local nDecimais	:= 0
Local lAuxItem	:= .T.
Local lsomadif	:=	.F.
Local nPosGen   := 0
Local nPosRefGen := 0
Local nOldTotAcum := 0
Local nMaFisRet		:= 0

DEFAULT aTrbGen := {"",""}

nAtual := Round(nAtual,MsDecimais( aNFCab[NF_MOEDA] ))

DEFAULT nItemNao	:=	0

If cReferencia=="IT_VALSOL"
	nCpoBase := 0
EndIf

If cReferencia == "IT_TRIBGEN"

	nPosRefGen := MaFisScan(aTrbGen[TG_REFERENCIA])

	For nX := 1 To Len(aNFItem)
		//Soh somar as bases da mesma aliquota, porque o rateio eh soh para os itens da mesma aliquota
		If (MaFisRet(nX,cReferencia,{aTrbGen[TG_SIGLA],cCpoAliq}) == nAliquota)
			nBaseTot += IIf(!aNfItem[nX][IT_DELETED],MaFisRet(nX,cReferencia,{aTrbGen[TG_SIGLA],cCpoBase}),0)
		EndIf
	Next nX

	For nX := 1 to Len(aNfItem)
		If !aNfItem[nX][IT_DELETED]

			If nAtual <> 0 .And. nAtual == nTotAcum .And. cPaisLoc == "BRA"
				Exit
			Endif

			nFator := MaFisRet(nX,cReferencia,{aTrbGen[TG_SIGLA],cCpoBase}) / nBaseTot
			nAliqItem := MaFisRet(nX,cReferencia,{aTrbGen[TG_SIGLA],cCpoAliq})

			If nAliqItem == nAliquota

				If nX <> nItemNao
					MaFisSomaIt(nX,.F.)
				Endif

				If lAuxItem
					nAuxItem := nX
					lAuxItem := .F.
				EndIf

				If (nPosGen := aScan(aNFItem[nX][IT_TRIBGEN], {|x| Alltrim(x[TG_IT_SIGLA]) == Alltrim(aTrbGen[TG_SIGLA])})) > 0

					nPosItRef := Ascan(aTGITRef,{|x| x[1] == aTrbGen[TG_REFERENCIA]})

					If aTGITRef[nPosItRef][4] .And. aTGITRef[nPosItRef][5]
						nTotAcum += aNfItem[nX][IT_TRIBGEN][nPosGen][nPosRefGen] := NoRound(nFator * nAtual, 2)
					Else
						nTotAcum += aNfItem[nX][IT_TRIBGEN][nPosGen][nPosRefGen] := nFator * nAtual
					EndIf

				EndIf

			EndIf
		EndIf
	Next nX

	If !lAuxItem .And. nAtual <> nTotAcum
		If (nPosGen := aScan(aNFItem[nAuxItem][IT_TRIBGEN], {|x| Alltrim(x[TG_IT_SIGLA]) == Alltrim(aTrbGen[TG_SIGLA])})) > 0
			aNfItem[nAuxItem][IT_TRIBGEN][nPosGen][nPosRefGen] += (nAtual-nTotAcum)
		EndIf
	EndIf

Else

	For nX := 1 To Len(aNFItem)
		If !Empty(nCpoBase) .AND. MaFisRet(nX,CCPOBASE) > 0 // so se existir a base, no caso de Dif. de Aliquota nao existe
			//Soh somar as bases da mesma aliquota, porque o rateio eh soh para os itens da mesma aliquota
			If (MaFisRet(nX,cCpoAliq)==nAliquota )
				nBaseTot+=IIf(!aNfItem[nX][IT_DELETED],MaFisRet(nX,'IT_VALMERC'),0)
			EndIf
		Else
			If nBaseTot <= 0
				nVlrTot+=IIf(!aNfItem[nX][IT_DELETED],MaFisRet(nX,cReferencia),0)
			EndIf
		EndIf
	Next nX

	If cPaisLoc $"ARG/PER"
		nDecimais := MsDecimais( aNFCab[NF_MOEDA] )
	Endif

	For nX := 1 to Len(aNfItem)
		If !aNfItem[nX][IT_DELETED]
			If nAtual <> 0 .And. nAtual == nTotAcum .And. cPaisLoc == "BRA"
				Exit
			Endif
			If !Empty(nCpoBase) .AND. MaFisRet(nX,CCPOBASE) > 0 // so se existir a base, no caso de Dif. de Aliquota nao existe
				//O rateio de impostos eh feito com base na base calculada para cada item
				nFator := MaFisRet(nX,'IT_VALMERC')/nBaseTot
			Else
				If nBaseTot <= 0
					nFator := MaFisRet(nX,cReferencia)/nVlrTot
				EndIf
			EndIf
			If ValType(nCpoAliq) == "A"
				nAliqItem := aNfItem[nX][nCpoAliq[1]][nCpoAliq[2]]
			Else
				nAliqItem := aNfItem[nX][Val(nCpoAliq)]
			EndIf

			If nAliqItem == nAliquota

				If nX <> nItemNao
					MaFisSomaIt(nX,.F.)
				Endif

				nPosItRef := Ascan(aItemRef,{|x| x[1] == cReferencia})
				nOldTotAcum := nTotAcum		//Armazena o valor acumulado antes de adicionar novos valores de impostos a itens que não deveriam tê-los.
				nMaFisRet		:= MaFisRet(nX,CCPOBASE)	//Antes de atualizar o aNfItem, verifica-se se o item possui base de cálculo para o respectivo imposto.

				If lAuxItem .AND. nMaFisRet > 0
					nAuxItem := nX
					lAuxItem := .F.
				EndIf

				If nPosItRef > 0
					If aItemRef[nPosItRef][4] .And. aItemRef[nPosItRef][5]
						If ValType(aPosCpo) == "A"
							nTotAcum += aNfItem[nX][aPosCpo[1]][aPosCpo[2]]:= NoRound(nFator*nAtual,2)
						Else
							nTotAcum += aNfItem[nX][Val(aPosCpo)]:= iif(MaFisRet(nX,CCPOBASE) > 0, NoRound(nFator*nAtual,2),0)
						EndIf
					Else
						If ValType(aPosCpo) == "A"
							nTotAcum += aNfItem[nX][aPosCpo[1]][aPosCpo[2]]:= IIf(cPaisLoc$"PAR/PER" , NoRound(nFator*nAtual,nDecimais) , nFator*nAtual )
						Else
							nTotAcum += aNfItem[nX][Val(aPosCpo)] := IIf(cPaisLoc$"PAR/PER" , NoRound(nFator*nAtual,nDecimais) , iif(MaFisRet(nX,CCPOBASE) > 0, nFator*nAtual,0) )
						EndIf
					EndIf
				Else
					If ValType(aPosCpo) == "A"
						nTotAcum += aNfItem[nX][aPosCpo[1]][aPosCpo[2]]:= IIf(cPaisLoc$"PAR/PER" , NoRound(nFator*nAtual,nDecimais) , nFator*nAtual )
					Else
						nTotAcum += aNfItem[nX][Val(aPosCpo)] := IIf(cPaisLoc$"PAR/PER" , NoRound(nFator*nAtual,nDecimais) ,  iif(MaFisRet(nX,CCPOBASE) > 0, nFator*nAtual,0) )
					EndIf
				Endif
				nTotAcum := VoltaItemAcum(nX,aPosCpo,nMaFisRet,nTotAcum,nOldTotAcum)
			EndIf
		EndIf
	Next nX

	If !lAuxItem .And. nAtual <> nTotAcum
		If CReferencia == 'IT_BASEICM'
			For NX := 1 To Len(aNfItem)
				lSomadif :=(aNfItem[nx][aPosCpo[1]][aPosCpo[2]]	+ (nAtual-nTotAcum)) <= MaFisRet(nX,"IT_VALMERC")
				IF lSomadif
					If ValType(aPosCpo) == "A"
						aNfItem[nx][aPosCpo[1]][aPosCpo[2]] += (nAtual-nTotAcum)
					Else
						aNfItem[nx][Val(aPosCpo)] += (nAtual-nTotAcum)
					EndIf
					EXIT
				endif
			next nx
		ELSE
			If ValType(aPosCpo) == "A"
				aNfItem[nAuxItem][aPosCpo[1]][aPosCpo[2]] += (nAtual-nTotAcum)
			Else
				aNfItem[nAuxItem][Val(aPosCpo)] += (nAtual-nTotAcum)
			EndIf
		ENDIF
	EndIf
EndIf

Return

/*/
VoltaItemAcum - Rafael P. Gonçalves - 28/11/2024
Implementada uma tratativa para verificar SE o item não possui base de cálculo para o imposto.
Isso evita que o valor do imposto seja distribuído entre itens que não estão sujeitos àquele imposto específico.
Criada a partir da issue: https://jiraproducao.totvs.com.br/browse/DSERFISE-9946
/*/
Static Function VoltaItemAcum(nX,aPosCpo,nMaFisRet,nTotAcum,nOldTotAcum)
	
	If (nMaFisRet <= 0)
		If ValType(aPosCpo) == "A"
			aNfItem[nX][aPosCpo[1]][aPosCpo[2]] := 0
		Else
			aNfItem[nX][Val(aPosCpo)] := 0
		EndIf
		If (nTotAcum > nOldTotAcum)
			nTotAcum -= (nTotAcum - nOldTotAcum)
		Endif
	EndIf

Return (nTotAcum)
/*/
MaFisPreCalc - Alexandre Lemes - 28/12/2012
Utilizar esta funcao para alimentar todos dados necessarios
no array aNFItem ANTES do calculo dos impostos pelas funcoes
de impostos, esta e uma funcao PRE-CALCULO, esta funcao deve
ser utilizada para alimentar qualquer posicao do aNFItem com
essa caracteristica
/*/
Function MaFisPreCalc(nItem,cCampo)
Local cOrigem := ""
Static aDesExiARG	:={}

DEFAULT cCampo	:= ""

If cPaisLoc == "BRA"
	//Grava o conteudo do campo Codigo de Autorização - CODIF - DIAT-SC
	aNfItem[nItem][IT_CODIF] := aNfItem[nItem][IT_PRD][SB_CODIF]
	aNFitem[nItem][IT_B1DIAT]:= aNfItem[nItem][IT_PRD][SB_PRDDIAT]

	//Atualiza a classificacao fiscal de ICMS
	If !isInCallStack("TSFGRVNF")
		If  cCampo$"IT_PRODUTO/IT_TES"  .Or. Len(Alltrim(aNfitem[nItem][IT_CLASFIS]))<3 .Or. ;
		(aNfitem[nItem][IT_TIPONF] == "D" .And. !Empty(aNFItem[nItem][IT_RECORI]) .And.  aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] == "C" )

			If fisGetParam('MV_STFRETE',.F.) .And. (AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE/CTA/CTF" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE]))
				aNfitem[nItem][IT_CLASFIS] := "0" + aNFItem[nItem][IT_TS][TS_SITTRIB] // Conforme parecer da Consultoria Tributaria emitido no chamado SCSFW2
			Else
				If aNfitem[nItem][IT_TIPONF] == "D" .And. !Empty(aNFItem[nItem][IT_RECORI]) .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] == "C" .And. fisGetParam('MV_CSTORI',.T.)
					dbSelectArea("SD2")
					MsGoto( aNFItem[nItem][IT_RECORI] )
					aNfitem[nItem][IT_CLASFIS] := SD2->D2_CLASFIS
				Else
					//Se possui origem na nota respeita o dado da nota
					cOrigem := SubStr(aNfItem[nItem][IT_CLASFIS], 1, 1)
					//Caso esteja alterando produto obtem o dado do produto
					If Empty(cOrigem) .Or. cCampo$"IT_PRODUTO"
						cOrigem := aNfItem[nItem][IT_PRD][SB_ORIGEM]
					EndIf
					//Se o preco de venda for menor que o preço de pauta não aplica a redução
					//Atende ao Decreto N 51703 DE 31/07/2014 PARA RS
					If ((fisExtCmp('12.1.2310', .T.,'SF4','F4_RDBSICM') .And. aNFItem[nItem][IT_TS][TS_RDBSICM] == "2") .And. ((aNfItem[nItem][IT_VALMERC] / aNfItem[nItem][IT_QUANT]) < aNfItem[nItem][IT_PAUTIC]))
						aNfItem[nItem][IT_CLASFIS] := cOrigem + "00"
					Else
						aNfitem[nItem][IT_CLASFIS] := cOrigem + aNFItem[nItem][IT_TS][TS_SITTRIB]
					EndIf
				EndIf
			EndIf
		ElseIf (aNfitem[nItem][IT_TIPONF] $ "CIP" .And. !Empty(aNFItem[nItem][IT_RECORI]) .And.  aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_CLIFOR] == "C" )
			dbSelectArea("SD2")
			MsGoto( aNFItem[nItem][IT_RECORI] )
			aNfitem[nItem][IT_CLASFIS] := SubStr(SD2->D2_CLASFIS, 1, 1)
		Endif
		aNfItem[nItem][IT_LIVRO][LF_CLASFIS] := aNfItem[nItem][IT_CLASFIS]
	EndIF

	//Atualiza Natureza da Operacao/Prestacao.
	aNfItem[nItem][IT_NATOPER] := IIf( fisExtCmp('12.1.2310', .T.,'SF4','F4_NATOPER') , aNFItem[nItem][IT_TS][TS_NATOPER] , "" )

	//Atualiza Natureza da Receita
	//Por se tratar de Natureza da RECEITA, faco as validacoes apenas para notas fiscais de saida

	If ( aNFCab[NF_TIPONF] $ "DB" .Or. aNFItem[nItem][IT_TS][TS_PODER3] =="D" ) .And. !Empty(aNFItem[nItem][IT_RECORI])
		If aNFCab[NF_TIPONF] $ "DB"
			If ( aNFCab[NF_CLIFOR] == "C")
				dbSelectArea("SD2")
				MsGoto(aNFItem[nItem][IT_RECORI])
				aNfItem[nItem][IT_TABNTRE] := SD2->D2_TNATREC
				aNfItem[nItem][IT_CODNTRE] := SD2->D2_CNATREC
				aNfItem[nItem][IT_GRPNTRE] := SD2->D2_GRUPONC
				aNfItem[nItem][IT_DATNTRE] := SD2->D2_DTFIMNT
			Else
				dbSelectArea("SD1")
				MsGoto(aNFItem[nItem][IT_RECORI])
				aNfItem[nItem][IT_TABNTRE] := SD1->D1_TNATREC
				aNfItem[nItem][IT_CODNTRE] := SD1->D1_CNATREC
				aNfItem[nItem][IT_GRPNTRE] := SD1->D1_GRUPONC
				aNfItem[nItem][IT_DATNTRE] := SD1->D1_DTFIMNT
			EndIf
		EndIf
	Else
		If aNfCab[NF_ROTINA] == "MATA461"  .AND. ((fisExtCmp('12.1.2310', .T.,'SC6','C6_TNATREC')).And.(fisExtCmp('12.1.2310', .T.,'SC6','C6_CNATREC')).And.;
				(fisExtCmp('12.1.2310', .T.,'SC6','C6_GRPNATR')).And. (fisExtCmp('12.1.2310', .T.,'SC6','C6_DTFIMNT'))) .And. !Empty(SC6->C6_TNATREC)
			// Se nao pegou da excecao busca SC6
			aNfItem[nItem][IT_TABNTRE] := SC6->C6_TNATREC
			aNfItem[nItem][IT_CODNTRE] := SC6->C6_CNATREC
			aNfItem[nItem][IT_GRPNTRE] := SC6->C6_GRPNATR
			aNfItem[nItem][IT_DATNTRE] := SC6->C6_DTFIMNT
			// Se nao pegou da SC6 busca SF4
		Elseif ((fisExtCmp('12.1.2310', .T.,'SF4','F4_TNATREC')).And.(fisExtCmp('12.1.2310', .T.,'SF4','F4_CNATREC')).And.(fisExtCmp('12.1.2310', .T.,'SF4','F4_GRPNATR')).And.(fisExtCmp('12.1.2310', .T.,'SF4','F4_DTFIMNT'))) .And. !Empty(SF4->F4_TNATREC)
			aNfItem[nItem][IT_TABNTRE] := SF4->F4_TNATREC
			aNfItem[nItem][IT_CODNTRE] := SF4->F4_CNATREC
			aNfItem[nItem][IT_GRPNTRE] := SF4->F4_GRPNATR
			aNfItem[nItem][IT_DATNTRE] := SF4->F4_DTFIMNT
			// Se nao pegou SF4 busca do SB1
		Elseif ((fisExtCmp('12.1.2310', .T.,'SB1','B1_TNATREC')).And.(fisExtCmp('12.1.2310', .T.,'SB1','B1_CNATREC')).And.(fisExtCmp('12.1.2310', .T.,'SB1','B1_GRPNATR')).And.(fisExtCmp('12.1.2310', .T.,'SB1','B1_DTFIMNT')))
			aNfItem[nItem][IT_TABNTRE] := aNfItem[nItem][IT_PRD][SB_TNATREC]
			aNfItem[nItem][IT_CODNTRE] := aNfItem[nItem][IT_PRD][SB_CNATREC]
			aNfItem[nItem][IT_GRPNTRE] := aNfItem[nItem][IT_PRD][SB_GRPNATR]
			aNfItem[nItem][IT_DATNTRE] := aNfItem[nItem][IT_PRD][SB_DTFIMNT]
		EndIf

		//Prioridade absoluta de preenchimento (SF7)
		If !Empty(aNFitem[nItem][IT_EXCECAO]) .And. !Empty(aNfItem[nItem][IT_EXCECAO][21]) .And. !Empty(aNfItem[nItem][IT_EXCECAO][22])//Busca pela Excecao
			aNfItem[nItem][IT_TABNTRE] := aNfItem[nItem][IT_EXCECAO][21]
			aNfItem[nItem][IT_CODNTRE] := aNfItem[nItem][IT_EXCECAO][22]
			aNfItem[nItem][IT_GRPNTRE] := aNfItem[nItem][IT_EXCECAO][23]
			aNfItem[nItem][IT_DATNTRE] := aNfItem[nItem][IT_EXCECAO][24]
		EndIf
	EndIF

EndIf

//Atualiza o preco unitario do item.
//Alteração feita em conjunto com Materiais e Faturamento, para que seja possível informar quantidade no complemento de preço
If (aNFitem[nItem][IT_TIPONF ]$"PI" .OR. (aNFitem[nItem][IT_TIPONF ]=="C" .AND. aNfCab[NF_TPCOMPL] <> '2' )  ).And. (cPaisLoc == "BRA" .Or. aTes[TS_QTDZERO] == "1")
	If !(cPaisLoc == "RUS") .Or. (cPaisLoc == "RUS" .And. aNFitem[nItem][IT_QUANT] == 0)
		aNfItem[nItem][IT_PRCUNI]  := aNfItem[nItem][IT_VALMERC]
	EndIf
Elseif aNFitem[nItem][IT_TIPONF ]$"DB" .And. cPaisLoc == "PAR" .And. fisGetParam('MV_DESCSAI','')=='1' .And. Alltrim(cFunName) == "MATA465N" .And. ( aNFitem[nItem][IT_DESCONTO] > 0 .OR.  aNFitem[nItem][IT_DESCTOT] > 0 ) .And. cCampo <> "IT_TES"
	aNFitem[nItem][IT_VALMERC] -= (aNFitem[nItem][IT_DESCONTO]+aNFitem[nItem][IT_DESCTOT])
	aNFitem[nItem][IT_PRCUNI]  := aNFitem[nItem][IT_VALMERC]/Max(aNFitem[nItem][IT_QUANT],1)
EndIf

If cPaisLoc == "URU"
   aNfItem[nItem][IT_TOTAL]  := aNfItem[nItem][IT_VALMERC]
EndIf

If cPaisLoc == "ARG" .And. (cCampo == "IT_VALMERC") .And. aNfCab[NF_OPERNF] =='E' .And. Alltrim(FunName()) $ "MATA465N"
	If aNfCab[NF_OPERNF] =='S'
		nPosDes := aScan(aHeader, {|x| Alltrim(x[2]) == "D2_DESC"})
	Else
		nPosDes := aScan(aHeader, {|x| Alltrim(x[2]) == "D1_DESC"})
	EndIf
	If aCols[nItem][nPosDes] > 0
		aNFitem[nItem][IT_DESCONTO] := aNFitem[nItem][IT_VALMERC] * (aCols[nItem][nPosDes]/100)
		IF FindFunction("xDesConARG") 
			aNFitem[nItem][IT_DESCONTO]:=xDesConARG(aHeader,aCols,@aDesExiARG,aNFitem[nItem][IT_VALMERC],nPosDes,nItem,cEspecie,aNFitem[nItem][IT_DESCONTO] )
		endIf
	EndIf
EndIf

Return Nil

/*/
MaFisVDescZF - Edson Maricate - 08.12.1999
Executa o calculo do Valor do Desconto da ZF.
Retorno
ExpN1: Item.
/*/
Function MaFisVDescZF(nItem)
FISXDESCZF(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)
Return

/*/
 MaFisVTot - Edson Maricate -13.12.1999
 Atualiza os valores totais do item
/*/
Function MaFisVTot(nItem,cCampo)

Local alAreaX   := {}
Local alAreaY   := {}
Local nImp      := 0
Local nValImp   := 0
Local nImposto  := 0
Local lDescInc  := (cPaisLoc <> "BRA" .And. aNfCab[NF_OPERNF]=="S" .And. fisGetParam('MV_DESCSAI','')=='1')
Local nAgrPisPas:= IIf( aTes[TS_AGRPIS] == "1" .And. aTes[TS_PSCFST]  <> "1" , aNfItem[nItem,IT_VALPS2] , 0 ) + IIf( aTes[TS_AGRCOF] == "1" .And. aTes[TS_PSCFST] <> "1" , aNfItem[nItem,IT_VALCF2] , 0 )
Local nPisCofST := IIf( aTes[TS_PSCFST] == "1" .And. aTes[TS_APSCFST] == "1" , aNfItem[nItem,IT_VALPS3] + aNfItem[nItem,IT_VALCF3] , 0 ) // Pis/Cofins ST - sera somado ao total do documento
Local nFretAut  := IIf( !fisGetParam('MV_FRETAUT',.T.) , 0 , aNfItem[nItem][IT_VALICA] )
Local lIsInclui	 := .F.
Local lImpSolGen := ChkTribLeg(aNfItem, nItem, TRIB_ID_ICMSST) //Verifica se está configurado pelo configurador de tributos
Local lIPITribGen := aNfCab[NF_CHKTRIBLEG] .AND. ChkTribLeg(aNFItem, nItem, TRIB_ID_IPI)
Local lSomaIPILeg := aTes[TS_IPI] <> 'R' .And. !lIPITribGen

DEFAULT cCampo	:= ""

If cPaisLoc $ "ARG|MEX|PER|COL|VEN|EQU" .And. isMemVar("Inclui")
	If Inclui
		lIsInclui := .T.
	EndIf
EndIf

If cPaisLoc $ "MEX|ARG|PER|COL|VEN|CHI|EQU"
	cFunName := funname() //OPTIMIZA
	If (cPaisLoc == "MEX" .and. Alltrim(cFunName) == "MATA465N" .And. fisGetParam('MV_DESCDVI',.T.) == .F. .And. fisGetParam('MV_DESCSAI','') == "1") .or. ;
	   (cPaisLoc $ "ARG|MEX|PER|COL|VEN|CHI|EQU" .and. Alltrim(cFunName) $ "MATA465N|MATA462DN" .And. fisGetParam('MV_DESCSAI','') == "1")
		lDescInc := .T.
	EndIf
EndIf

Do Case
Case aNFitem[nItem][IT_TIPONF ] == "P"
	aNfItem[nItem][IT_TOTAL]	:= aNfItem[nItem][IT_FRETE] + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_DESPESA]) + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_SEGURO])+;
		aNfItem[nItem][IT_VALIPI]+IIf(aTes[TS_INCSOL]$"A,N,D" .Or. lImpSolGen, 0,aNfItem[nItem][IT_VALSOL])+;
		aNfItem[nItem][IT_VALEMB]+nFretAut+nAgrPisPas+nPisCofST+;
		aNfItem[nItem][IT_DESNTRB]+aNfItem[nItem][IT_TARA]+;
		aNfItem[nItem][IT_ACRESCI]
	If cPaisLoc == "RUS"
		aNfItem[nItem][IT_TOTAL_C1]	:= xMoeda((aNfItem[nItem][IT_FRETE] + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_DESPESA]) + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_SEGURO])+;
			aNfItem[nItem][IT_VALIPI]+IIf(aTes[TS_INCSOL]$"A,N,D",0,aNfItem[nItem][IT_VALSOL])+;
			aNfItem[nItem][IT_VALEMB]+nFretAut+nAgrPisPas+nPisCofST+;
			aNfItem[nItem][IT_DESNTRB]+aNfItem[nItem][IT_TARA]+;
			aNfItem[nItem][IT_ACRESCI]),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
	EndIf
OtherWise
	Do Case
	Case aTes[TS_AGREG] == "N"
		aNfItem[nItem][IT_TOTAL]	:= aNfItem[nItem][IT_FRETE] + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_DESPESA]) + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_SEGURO])+;
			IIf(lSomaIPILeg,aNfItem[nItem][IT_VALIPI],0) + IIf(aTes[TS_INCSOL]$"A,N,D" .Or. lImpSolGen, 0,aNfItem[nItem][IT_VALSOL])+;
			aNfItem[nItem][IT_VALEMB]+nAgrPisPas+nPisCofST+;
			aNfItem[nItem][IT_DESNTRB]+aNfItem[nItem][IT_TARA]+;
			aNfItem[nItem][IT_ACRESCI]
		If cPaisLoc == "RUS"
			aNfItem[nItem][IT_TOTAL_C1]	:= xMoeda((aNfItem[nItem][IT_FRETE] + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_DESPESA]) + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_SEGURO])+;
				IIf(aTes[TS_IPI] == 'R',0,aNfItem[nItem][IT_VALIPI]) + IIf(aTes[TS_INCSOL]$"A,N,D",0,aNfItem[nItem][IT_VALSOL])+;
				aNfItem[nItem][IT_VALEMB]+nAgrPisPas+nPisCofST+;
				aNfItem[nItem][IT_DESNTRB]+aNfItem[nItem][IT_TARA]+;
				aNfItem[nItem][IT_ACRESCI]),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
		EndIf
		aNfItem[nItem][IT_VNAGREG] := aNfItem[nItem][IT_VALMERC]-(aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])
	Case aTes[TS_AGREG] == "I" .Or. aTes[TS_AGREG] == "B"
		aNfItem[nItem][IT_TOTAL]	:= aNfItem[nItem][IT_VALMERC] + aNfItem[nItem][IT_FRETE] + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_DESPESA]) + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_SEGURO])+;
			IIf(lSomaIPILeg,aNfItem[nItem][IT_VALIPI],0)+ IIf((aTes[TS_INCSOL]$"A,N,D".Or. lImpSolGen).And.aTes[TS_ICM]<>"N",0,aNfItem[nItem][IT_VALSOL]) - IIf(lDescInc,0,(aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]))+;
			If(aNFitem[nItem][IT_TIPONF ]<>"I",aNfItem[nItem][IT_VALICM]+(Iif(aNfCab[NF_PPDIFAL],aNfItem[nItem][IT_DIFAL]+aNfItem[nItem][IT_VALCMP]+aNfItem[nItem][IT_VFCPDIF],0)),0) + aNfItem[nItem][IT_VALEMB]+nFretAut+nAgrPisPas+nPisCofST+;
			aNfItem[nItem][IT_DESNTRB]+aNfItem[nItem][IT_TARA] + aNfItem[nItem][IT_AFRMIMP]+;
			aNfItem[nItem][IT_ACRESCI]
		If cPaisLoc == "RUS"
			aNfItem[nItem][IT_TOTAL_C1]	:= xMoeda((aNfItem[nItem][IT_VALMERC] + aNfItem[nItem][IT_FRETE] + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_DESPESA]) + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_SEGURO])+;
				IIf(aTes[TS_IPI] == 'R',0,aNfItem[nItem][IT_VALIPI])+ IIf(aTes[TS_INCSOL]$"A,N,D".And.aTes[TS_ICM]<>"N",0,aNfItem[nItem][IT_VALSOL]) - IIf(lDescInc,0,(aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]))+;
				If(aNFitem[nItem][IT_TIPONF ]<>"I",aNfItem[nItem][IT_VALICM]+(Iif(aNfCab[NF_PPDIFAL],aNfItem[nItem][IT_DIFAL]+aNfItem[nItem][IT_VALCMP]+aNfItem[nItem][IT_VFCPDIF],0)),0) + aNfItem[nItem][IT_VALEMB]+nFretAut+nAgrPisPas+nPisCofST+;
				aNfItem[nItem][IT_DESNTRB]+aNfItem[nItem][IT_TARA] + aNfItem[nItem][IT_AFRMIMP]+;
				aNfItem[nItem][IT_ACRESCI]),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
		EndIf
			aNfItem[nItem][IT_VNAGREG] := 0
			If	(AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE]))
				If aTes[TS_CRPRST] <> 0  .And. !((aTes[TS_INCSOL] $ "A,N,D" .Or. lImpSolGen) .And. aTes[TS_ICM] <> "N")
					aNfItem[nItem][IT_TOTAL] += 	(aNfItem[nItem][IT_VLCSOL] - aNfItem[nItem][IT_VALSOL])
					If cPaisLoc == "RUS"
						aNfItem[nItem][IT_TOTAL_C1] += 	xMoeda((aNfItem[nItem][IT_VLCSOL] - aNfItem[nItem][IT_VALSOL]),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
					EndIf
				EndIf
			EndIf
			// Se o parâmetro está habilitado significa que não foi informado o II com o Valor Aduaneitro, então devo somar para que fique no total da NF.
            IF fisGetParam('MV_EIC0064',.F.)
                 aNfItem[nItem][IT_TOTAL] += aNfItem[nItem][IT_VALII]
				If cPaisLoc == "RUS"
					aNfItem[nItem][IT_TOTAL_C1] += xMoeda(aNfItem[nItem][IT_VALII],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
				EndIf
			EndIf
	OtherWise
			aNfItem[nItem][IT_TOTAL]	:= aNfItem[nItem][IT_VALMERC] + aNfItem[nItem][IT_FRETE] + ;
			IIf(aTes[TS_DESPICM] == "3" .Or. aTes[TS_DESPICM] == "4" , 0 , aNfItem[nItem][IT_DESPESA] ) + ;
			IIf(aTes[TS_DESPICM] == "3", 0 , aNfItem[nItem][IT_SEGURO] ) +;
			IIf(lSomaIPILeg,aNfItem[nItem][IT_VALIPI],0) + ;
			IIf(aTes[TS_INCSOL]$"A,N,D" .Or. lImpSolGen, 0 ,IIf( (aNfItem[nItem][IT_VFECPST]>aNfItem[nItem][IT_VALSOL]),  aNfItem[nItem][IT_VFECPST], aNfItem[nItem][IT_VALSOL] ) )+ ;
			IIf((aNFitem[nItem][IT_TIPONF ]$"DB" .And. cPaisLoc =="PAR" .And. fisGetParam('MV_DESCSAI','') == "1" ), (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) , 0 ) - ;
			IIf(lDescInc, 0, IIf(cPaisLoc $ "PER|MEX|VEN" .And. !lIsInclui  .And. AllTrim(FunName()) $ "MATA467N|MATA462N|MATA465N|MATA102DN", 0,(aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])))+;
			aNfItem[nItem][IT_VALEMB]+nFretAut + nAgrPisPas + nPisCofST +;
			aNfItem[nItem][IT_DESNTRB]+aNfItem[nItem][IT_TARA]+;
			aNfItem[nItem][IT_ACRESCI]
			aNfItem[nItem][IT_TOTAL] := aNfItem[nItem][IT_TOTAL] + IIF (cPaisLoc == "MEX" .and. AllTrim(FunName()) $ "MATA466N" .And. !lIsInclui .And. fisGetParam('MV_DESCSAI','')=='2' .And. aNfCab[NF_TIPODOC] $ "07|06",(aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]),0)
			If (cPaisLoc == "RUS")
				aNfItem[nItem][IT_TOTAL_C1]	:= MaFisRet(nItem,"IT_BASEIV1_C1")
			EndIf

			IF cPaisLoc == "ARG" .And. lDescInc .And. Alltrim(cFunName) == "MATA465N" .And. Alltrim(cEspecie) == "NCC" .And. fisGetParam('MV_DESCSAI','') == "1" .And. Empty(aNfItem[nItem][IT_NFORI])
				aNfItem[nItem][IT_TOTAL]	-= aNfItem[nItem][IT_DESCONTO]
			EndIf
			// Se o parâmetro está habilitado significa que não foi informado o II com o Valor Aduaneitro, então devo somar para que fique no total da NF.
			//Alterado para que o Valor do II seja considerado apenas no Total da NF e não no Total do Item.
			If aTes[TS_AGREG] == "C" .And. fisGetParam('MV_EIC0064',.F.)
                aNfItem[nItem][IT_TOTAL] += aNfItem[nItem][IT_VALII]
				If cPaisLoc == "RUS"
					aNfItem[nItem][IT_TOTAL_C1] += xMoeda(aNfItem[nItem][IT_VALII],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
				EndIf
			EndIf


			//Indica se o valor da deducao sera agregado ao Total da NF ou nao, em conj TS_AGREG = D ou R
			//Conforme Anexo IV, item 8 letra B e item B5 do RICMS MG
			//TS_AGRDRED = "1" - Agrega o valor da deducao
			//TS_AGRDRED = "2" - Abate o valor da deducao, como ja era feito antes da implementacao
			If aTes[TS_AGREG]$"DR" .And. aTes[TS_AGRDRED]=="1"
				aNfItem[nItem][IT_TOTAL]	+= IIf(Empty(aNfItem[nItem][IT_RECORI]) .Or. aTes[TS_AGREG]$"DR" , aNfItem[nItem][IT_DEDICM] , 0 )
				If cPaisLoc == "RUS"
					aNfItem[nItem][IT_TOTAL_C1]	+= IIf(Empty(aNfItem[nItem][IT_RECORI]) .Or. aTes[TS_AGREG]$"DR" , xMoeda(aNfItem[nItem][IT_DEDICM],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA]), 0 )
				EndIf
			ElseIf aTes[TS_AGREG]$"DR" .And. (aTes[TS_AGRDRED]=="2" .Or. Empty(aTes[TS_AGRDRED]))
				aNfItem[nItem][IT_TOTAL]	-= IIf(Empty(aNfItem[nItem][IT_RECORI]) .Or. aTes[TS_AGREG]$"DR" , aNfItem[nItem][IT_DEDICM] , 0 )
				If cPaisLoc == "RUS"
					aNfItem[nItem][IT_TOTAL_C1] -= IIf(Empty(aNfItem[nItem][IT_RECORI]) .Or. aTes[TS_AGREG]$"DR" , xMoeda(aNfItem[nItem][IT_DEDICM],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA]) , 0 )
				EndIf
			EndIf

			aNfItem[nItem][IT_VNAGREG] := 0
	EndCase
EndCase

//Adiantamento - Mexico
If cPaisLoc == "MEX" .And. fisExtCmp('12.1.2310', .T.,'SD2','D2_VALADI') .Or. (cPaisLoc=="PER" .And. Alltrim(cFunName) $ "MATA101N|MATA467N" )
	aNfItem[nItem][IT_TOTAL] -= aNfItem[nItem][IT_ADIANT]
EndIf

//Adiantamento - Peru
If cPaisLoc == "PER" .and. fisExtCmp('12.1.2310', .T.,'SD2','F1_ADIANT')
	aNfItem[nItem][IT_TOTAL] -= aNfItem[nItem][IT_ADIANTTOT]
EndIf

aNfItem[nItem][IT_TOTAL] += Iif(aTes[TS_AGRPIS] == "P" , aNFitem[nItem][IT_VALPS2] , 0 ) + Iif(aTes[TS_AGRCOF]=="C",aNFitem[nItem][IT_VALCF2],0)
aNfItem[nItem][IT_TOTAL] -= Iif(aTes[TS_AGRPIS] == "D" , aNFitem[nItem][IT_VALPS2] , 0 ) + Iif(aTes[TS_AGRCOF]=="D",aNFitem[nItem][IT_VALCF2],0)
aNfItem[nItem][IT_TOTAL] += Iif(aTes[TS_AGRISS] == "1", aNFitem[nItem][IT_VALISS], 0)
If cPaisLoc == "RUS"
	aNfItem[nItem][IT_TOTAL_C1] += xMoeda( Iif(aTes[TS_AGRPIS] == "P" , aNFitem[nItem][IT_VALPS2] , 0 ) + Iif(aTes[TS_AGRCOF]=="C",aNFitem[nItem][IT_VALCF2],0),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
	aNfItem[nItem][IT_TOTAL_C1] -= xMoeda( Iif(aTes[TS_AGRPIS] == "D" , aNFitem[nItem][IT_VALPS2] , 0 ) + Iif(aTes[TS_AGRCOF]=="D",aNFitem[nItem][IT_VALCF2],0),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
	aNfItem[nItem][IT_TOTAL_C1] += xMoeda( Iif(aTes[TS_AGRISS] == "1", aNFitem[nItem][IT_VALISS], 0),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
EndIf
//Se o módulo de origem for o TMS, será tratado conforme abaixo
If (aTes[TS_AGRPIS]=="P" .And. aTes[TS_AGRCOF]=="C" .And. (aTes[TS_AGREG]=="I" .Or. aTes[TS_AGREG]=="A") .And. !aTes[TS_INTBSIC]$"123") .and. nModulo == 43 //TMS
	If Abs( MAFISRET(nItem,"IT_BASEICM") - MAFISRET(nItem,"IT_TOTAL") ) == 0.01
		If (MAFISRET(nItem,"IT_BASEICM") < MAFISRET(nItem,"IT_TOTAL") )
			aNfItem[nItem][IT_BASEICM] := aNfItem[nItem][IT_TOTAL]
		Else
			aNfItem[nItem][IT_TOTAL] := aNfItem[nItem][IT_BASEICM]
		Endif
		If cPaisLoc == "RUS"
			aNfItem[nItem][IT_TOTAL_C1] := xMoeda(aNfItem[nItem][IT_BASEICM],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
		EndIf
	EndIf
//Senão, se mantém o legado
ELSE
	If aTes[TS_AGRPIS]=="P" .And. aTes[TS_AGRCOF]=="C" .And. (aTes[TS_AGREG]=="I" .Or. aTes[TS_AGREG]=="A") .And. !aTes[TS_INTBSIC]$"123"
		If Abs( MAFISRET(nItem,"IT_BASEICM") - MAFISRET(nItem,"IT_TOTAL") ) == 0.01
				aNfItem[nItem][IT_TOTAL] := aNfItem[nItem][IT_BASEICM]
			If cPaisLoc == "RUS"
				aNfItem[nItem][IT_TOTAL_C1] := xMoeda(aNfItem[nItem][IT_BASEICM],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
			EndIf
		EndIf
	EndIf
ENDIF
//ICMS Diferido Incentivo abate de gado - o valor diferido sera somado ao total da NF e a duplicata
If aTes[TS_PICMDIF]<>0 .And. aTes[TS_ICMSDIF]=="4"
	aNfItem[nItem][IT_TOTAL] += aNfItem[nItem][IT_ICMSDIF]
	If cPaisLoc == "RUS"
		aNfItem[nItem][IT_TOTAL_C1] += xMoeda(aNfItem[nItem][IT_ICMSDIF],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
	EndIf
EndIf

//Decreto nro 43.080/02
If aNfItem[nItem][IT_BSSEMDS] > 0
	aNfItem[nItem][IT_TOTAL] -= ( aNfItem[nItem][IT_ICSEMDS] - aNfItem[nItem][IT_VALICM] )
	If cPaisLoc == "RUS"
		aNfItem[nItem][IT_TOTAL_C1] -= xMoeda((aNfItem[nItem][IT_ICSEMDS] - aNfItem[nItem][IT_VALICM] ),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
	EndIf
EndIf

If	aNFItem[nItem][IT_TS][TS_AGRPEDG] <> "3" .And. aNfItem[nItem][IT_VALPEDG] > 0
	aNfItem[nItem][IT_TOTAL] += aNfItem[nItem][IT_VALPEDG]
	If cPaisLoc == "RUS"
		aNfItem[nItem][IT_TOTAL_C1] += xMoeda(aNfItem[nItem][IT_VALPEDG],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
	EndIf
EndIf

// Calcula ICMS Diferido e Desconta na NF e Fatura
If aNFItem[nItem][IT_TS][TS_ICMSDIF] == "6"
	aNfItem[nItem][IT_TOTAL] 	-= aNfItem[nItem][IT_ICMSDIF]
EndIf //issue DSERFIS1-8601

aNfItem[nItem][IT_BASEDUP] := 0

If aTes[TS_DUPLIC] <>"N" .Or. lCalculPCC
	aNfItem[nItem][IT_BASEDUP] := aNfItem[nItem][IT_TOTAL]
	If fisGetParam('MV_DPAGREG',.F.) .And. aTes[TS_AGREG] == "N"
		aNfItem[nItem][IT_BASEDUP] += aNfItem[nItem][IT_VALMERC]
	EndIf
	If aTes[TS_AGREG]=="G"
		aNfItem[nItem][IT_BASEDUP] += aNfItem[nItem][IT_VALICM] - aNfItem[nItem][IT_BASEDUP]
		If aTes[TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1" .And. nAgrPisPas > 0
			aNfItem[nItem][IT_BASEDUP] -= ((nAgrPisPas * aNfItem[nItem][IT_ALIQICM]) /100)
			aNfItem[nItem][IT_BASEDUP] += nAgrPisPas
		Endif
	EndIf
	If aTes[TS_AGREG]=="H"
		aNfItem[nItem][IT_BASEDUP] += (aNfItem[nItem][IT_VALSOL]+aNfItem[nItem][IT_VALIPI]) - aNfItem[nItem][IT_BASEDUP]
	EndIf
	If aTes[TS_AGREG]=="F"
		aNfItem[nItem][IT_BASEDUP] -= aNfItem[nItem][IT_VALMERC]
	EndIf
	If aNFitem[nItem][IT_TIPONF ]=='I'
		aNfItem[nItem][IT_BASEDUP]	-= aNfItem[nItem][IT_VALICM]
	EndIf
	If aTes[TS_PICMDIF]<>0 .And. aTes[TS_ICMSDIF]=="1" .And. aTes[TS_ICM] == "S"
		MaItArred(nItem, { "IT_ICMSDIF" } )
		aNfItem[nItem][IT_BASEDUP]	-= aNfItem[nItem][IT_ICMSDIF]
	EndIf
	If (aNfCab[NF_RECISS]=="1".And. fisGetParam('MV_DESCISS',.F.) .And. aNfCab[NF_OPERNF]=="S".And. fisGetParam('MV_TPABISS','1')=="1")
		If (aNfItem[nItem][IT_VALISS] > fisGetParam('MV_VRETISS',0)) .OR.;
			aTes[TS_FRETISS] == "2" .And. IIF(fisExtCmp('12.1.2310', .T.,'SA1','A1_FRETISS'),IIF(aNfCab[NF_FRETISS] == "2",.T.,.F.),.F.)
			aNfItem[nItem][IT_BASEDUP]	-= aNfItem[nItem][IT_VALISS]
		EndIf
	EndIf
	If aTes[TS_INCSOL]=="D" .And. !lImpSolGen 
		aNfItem[nItem][IT_BASEDUP]	-= aNfItem[nItem][IT_VALSOL]
	EndIf
	If aTes[TS_AGREG]=="E"
		aNfItem[nItem][IT_BASEDUP]	-= aNfItem[nItem][IT_DEDICM]
	EndIf


	//Fundersul - sera reduzido do total da duplicata
	If cPaisLoc =="BRA" .And.  aTes[TS_CLFDSUL] == "1"
		aNfItem[nItem][IT_BASEDUP]	-= aNfItem[nItem][IT_VALFDS]
	Endif

	//Funrural - Abate valor da Duplicata quando é devolução de compra
	If aNfCab[NF_TIPONF] == "D" .AND. aNfItem[nItem][IT_BASEFUN] > 0 .And. aNfCab[NF_OPERNF] == "S"
		aNfItem[nItem][IT_BASEDUP] -= aNfItem[nItem][IT_FUNRURAL]
	EndIf

	// se for necessário será deduzido da duplicata o SENAR.
	dedSenarDup(aNfCab, aTes, aNfItem, nItem)

	If cPaisLoc =="BRA" .And.  aNfItem[nItem][IT_VLINCMG] > 0
		aNfItem[nItem][IT_BASEDUP]	+= aNfItem[nItem][IT_VLINCMG]
	Endif

Else
	//O F4_DUPLIST e utilizado para gerar um titulo somente com o valor
	//do ICMS-ST e foi implementado no MATA461 para NF de Remessa na
	//saida, aqui foi implemntado para notas fiscais de entrada respeitan
	//do o mesmo conceito utilizado na saida de gerar o titulo somente se
	//Gera Duplicatas F4_DUPLIC estiver = NAO
	If aNfCab[NF_OPERNF] == "E" .And. aTes[TS_DUPLIST] == "1"
		aNfItem[nItem][IT_BASEDUP] += aNfItem[nItem][IT_VALSOL]
	EndIf
	//O F4_DUPLIPI tem o mesmo efeito do F4_DUPLIST, porém para o IPI
	If aNfCab[NF_OPERNF] == "E" .And. aTes[TS_DUPLIPI] == "1"
		aNfItem[nItem][IT_BASEDUP] += aNfItem[nItem][IT_VALIPI]
	EndIf
EndIf
// Verifica se a TES possui tratamento para Impostos Variaveis
If !Empty(aTes[TS_SFC])
	For nImposto := 1 to Len(aTes[TS_SFC])
		nImp := NumCpoImpVar(RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1))
		If  aTes[TS_DUPLIC] <> "N" .And. aNFitem[nItem][IT_TIPONF ]<>'B'
			Do Case
				Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
					nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
				Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
					nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
				Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
					nValImp:=0
			EndCase
			aNfItem[nItem][IT_BASEDUP] += nValImp
		Endif

		Do Case
			Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
				nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
			Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
				nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
			Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
				nValImp:=0
		EndCase
		aNfItem[nItem][IT_TOTAL] += nValImp
		If cPaisLoc == "RUS"
			aNfItem[nItem][IT_TOTAL_C1] += If(cPaisLoc <> "RUS",xMoeda(nValImp,aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA]),MaFisRet(nItem,"IT_VALIV1_C1"))
		EndIf
	Next nImposto
EndIf

IF xFisGrossIR(nItem, aNFItem, aNfCab, "DUP") //Verifica se deverá considerar GrossUp do IRRF na BaseDup
	aNfItem[nItem][IT_BASEDUP] 	:= aNfItem[nItem][IT_BASEDUP] / ( 1 - ( aNfItem[nItem][IT_ALIQIRR] / 100 ) )	
EndIF
//          TRATAMENTO EXPECIFICO PARA LOCALIZADO PERU
// Quando o cálculo do ISC for por unidade, ou seja, se houver
// alguma exceção fiscal,  o valor do campo especifico FF_VLRISC > 0
// é gravado no campo customizado D1_VLRISC ou D2_VLRISC.
// Se não houver nenhuma exceção fiscal, mas no produto o valor do
// campo especíco B1_VLRISC  > 0 então no campo especifico D1_VLRISC
// ou D2_VLRISC é gravado o seu valor.
// Caso não seja nenhuma das opções anteriores o valor do campo é ze-
// rado.

If cPaisLoc $ "PER"
	alAreaX := SFC->(GetArea())
	alAreaY := SFF->(GetArea())
	aNfItem[nItem][IT_VLRISC] := 0
	SFC->(DbSetOrder(2))
	If SFC->(MsSeek(xFilial("SFC")+aNfItem[nItem][IT_TES]+"ISC"))
		SFF->(DbSetOrder(3))
		If SFF->(MsSeek(xFilial("SFF")+SFC->FC_IMPOSTO)) .And. SFF->FF_VLRISC > 0
			aNfItem[nItem][IT_VLRISC] := SFF->FF_VLRISC
		EndIf
		If aNfItem[nItem][IT_VLRISC] = 0 .And. aNfItem[nItem][IT_PRD][SB_VLRISC] > 0
			aNfItem[nItem][IT_VLRISC] := aNfItem[nItem][IT_PRD][SB_VLRISC]
		EndIf
	EndIf
	RestArea(alAreaX)
	RestArea(alAreaY)
EndIf

If !lImpSolGen .AND. aNfItem[nItem][IT_TS][TS_INCSOL] $ "E" .And. fisExtCmp('12.1.2310', .T.,'SFT','FT_DESCFIS')

	aNfItem[nItem][IT_TOTAL] -= aNfItem[nItem][IT_VALSOL]
	If cPaisLoc == "RUS"
		aNfItem[nItem][IT_TOTAL_C1] -= xMoeda(aNfItem[nItem][IT_VALSOL],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
	EndIf
	aNfItem[nItem][IT_DESCFIS] := aNfItem[nItem][IT_VALSOL]

EndIf

If  lCJ2 .and. cPaisLoc == "BRA"
	//Tributo genérico tratamento de escrituração do valor total da nota
	//Tratamento também valor total da base da duplicata
	FisSumTG(aNfItem, nItem)
EndIf

Return

/*/
MaFisCFO- Edson Maricate -13.12.1999
Processa o Codigo Fiscal do item especificado
Sintaxe   ExpC1 := MaFisCFO(ExpN1,ExpC2,[ExpA1])
Parametros
ExpN1: Item
ExpC2: Codigo Fiscal Original ( Opcional )
ExpA1: Array de parametros opcional a ser enviado quando a funcao e chamada de fora da matxfis. Estrutura:
1 - Identificador do parametro ( mnemonico )
2 - Conteudo
Retorno ExpC1: Codigo Fiscal de Operacao
/*/
Function MaFisCFO(nItem,cAuxCF,aDados)

Local cCfo	    := IIf( cAuxCF == Nil , aTes[TS_CF] , cAuxCF )
Local cRetCF    := ""
Local cOperNf   := ""
Local cTpCliFor := ""
Local cMVEstado	:= ""
Local cUfOrigem := ""
Local cUfDest   := ""
Local cTpComp   := ""
Local cInscri   := ""
Local cRestoCfo := ""
Local cContr	:= ""
Local cConvCfo	:= ""
Local lInscrito := .T.
Local lUsaCfps	:= .F.
Local nX        := 0
Local cUfCliDest:= ""
Local cCltdest  := ""
Local cEspecie  := ""
Local cCfoTES	:= ""

// Ao utilizar o Protheus com varias Filiais e possivel que em alguns processos como o de inclusao de Notas Fiscais o usuario altere
// a filial atraves da Dialog de seleçao de filiais, com isso se faz necessario que os parametros SX6 sejam novamente carregados para
// a filial corrente refazendo o cache realizado na variavel aSX6, esta nova carga e controlada pela variavel cSX6FilAnt
// Tratativa da empresa (cempant) logada para tratar clientes que não tem cadastrada a Gestão de empresas.
//If cSX6FilAnt <> cFilAnt .Or. cSX6EmpAnt <> cEmpAnt
//	aSX6 := GParMxFis(@cSX6FilAnt,@cSX6EmpAnt)
//EndIf

cMVEstado := fisGetParam('MV_ESTADO','')
cUfOrigem := cMVEstado
lUsaCfps  := fisGetParam('MV_USACFPS',.F.)
cConvCfo  := fisGetParam('MV_CONVCFO','1')
cCfoTES   := fisGetParam('MV_CFOTES','') //Define CFOPs que não sofrerão alteração, sera o cadastrado da SF4

If cCfo == "99943" .AND. nModulo == 43 //-- CFOP TMS
	cCodCli := aNfCab[NF_CODCLIFOR]
	cLojCli := aNfCab[NF_LOJA]
	cSegCli := Posicione("SA1",1,xFilial("SA1")+cCodCli+cLojCli,"A1_SATIV1")
	If !Empty(cSegCli)
		cCfo := Posicione("DY5",2,xFilial("DY5")+cSegCli,"DY5_CF")
	EndIf
EndIf

If ValType( aDados ) == "A"

	cUfOrigem := cMVEstado
	cUfDest   := cMVEstado

	For nX := 1 To Len(aDados)
		Do Case
			Case aDados[nX, 1] == "OPERNF"
				cOperNF   := aDados[nX, 2]
			Case aDados[nX, 1] == "TPCLIFOR"
				cTpCliFor := aDados[nX, 2]
			Case aDados[nX, 1] == "UFORIGEM"
				cUfOrigem := aDados[nX, 2]
			Case aDados[nX, 1] == "UFDEST"
				cUfDest   := aDados[nX, 2]
			Case aDados[nX, 1] == "TPCOMP"
				cTpComp   := aDados[nX, 2]
			Case aDados[nX, 1] == "INSCR"
				cInscri   := aDados[nX, 2]
				lInscrito := !(Empty(cInscri).Or."ISENT" $ cInscri)
			Case aDados[nX, 1] == "CONTR"
				cContr    := aDados[nX, 2]
		EndCase
	Next nX

	If Len(aDados)> 5
		If fisExtCmp('12.1.2310', .T.,'SF4','F4_VENPRES')
			If SF4->F4_VENPRES == "1" .And. aDados[2][2] == "F" .And. aDados[1][2] == "S" .And. aDados[6][2]$ "S|F|D|T"
				cUfDest := cUfOrigem
			EndIf
		EndIf
	EndIf

	//Verifica a indicacao de contribuinte ou nao do ICMS pelo cadastro do Cliente
	If !Empty(cContr)
		// Contribuinte
		If cContr == "1"
			lInscrito := .T.
			// Nao Contribuinte
		ElseIf cContr == "2"
			lInscrito := .F.
		Endif
	Endif

Else

	If aNFCab[NF_TIPONF] <> "B"
		cUfOrigem := aNfCab[NF_UFORIGEM]
	Else
		If (aTes[TS_PODER3] == "D" .Or. aTes[TS_PODER3] == "R" .Or. aTes[TS_PODER3] == "N") .And. aNfCab[NF_OPERNF] == "E"
			cUfOrigem := aNfCab[NF_UFORIGEM]
		EndiF
	EndIf

	cOperNf  := aNfCab[NF_OPERNF]
	cTpCliFor:= aNfCab[NF_TPCLIFOR]
	cUfDest  := aNfCab[NF_UFDEST]
	cTpComp  := aNfCab[NF_TPCOMP]
	lInscrito:= !aNfCab[NF_LINSCR]
	cCltdest  := aNfCab[NF_CLIDEST]
	cUfCliDest := aNfCab[NF_UFCDEST]
	cEspecie := aNfCab[NF_ESPECIE]

EndIf
If cPaisLoc <> "RUS"
	cRestoCfo := SubStr(cCfo,2,Len(cCfo)-1)
EndIf

IF aTes[TS_VENPRES] == "1" .And. aNfCab[NF_TPCLIFOR] == "F" .And. aNfCab[NF_OPERNF] == "S" .And. aNfCab[NF_TPFRETE] $ "S|F|D|T"
	aNfCab[NF_UFDEST] := aNfCab[NF_UFORIGEM]
	cUfDest := cUfOrigem
	// Se houver alteração do estado de destino reposiciono a tabela CFC UF x UF.
	MaSeekCFC(2,nItem)
EndIf

If cPaisLoc == "BRA"
	If SubStr(cCfo,1,3) == "999" .Or. SubStr(cCfo,1,3) == "000" .Or. SubStr(cCfo,1,4) $ "1601#1602#5601#5602#1664#2664#5664#5665#5666#6664#6665#6666"+cCfoTES
		cRetCF := cCfo
	Else
		If cOperNf == "E"
			If (cUfOrigem == "EX" .Or. cUfDest == "EX") .And. !(SubStr(cCfo,1,4) $ "1663#2663") 
				cRetCF := "3"
			Else
				/*==========================================================|
				|CA  |	CONHECIMENTO AEREO                                  |
				|CTA |	CONHECIMENTO DE TRANSPORTE AQUAVIARIO               |
				|CTE |	CONHECIMENTO DE TRANSPORTE ELETRONICO               |
				|CTF |	CONHECIMENTO DE TRANSPORTE FERROVIARIO              |
				|CTM |	CONHECIMENTO DE TRANSPORTE MULTIMODAL DE CARGAS     |
				|CTR |	CONHECIMENTO DE TRANSPORTE RODOVIARIO               |
				|NFST|	NOTA FISCAL DE SERVICO DE TRANSPORTE                |
				|==========================================================*/

				If (AllTrim(cEspecie) $ "CTR/CTE/CTA/CA/CTF") .Or. ("NFST" $ AllTrim(cEspecie))
					If (Empty(cCltdest) .And. (cUfOrigem <> fisGetParam('MV_ESTADO','') .Or. ( !Empty(cUfDest) .And. cUfDest <> fisGetParam('MV_ESTADO','')))) .Or. (!Empty(cCltdest) .And. cUfOrigem <> cUfCliDest)
						cRetCF := '2'
					Else
						cRetCF := '1'
					EndIf
				ElseIf (!Empty(cCltdest) .And. cUfOrigem == cUfCliDest) .Or. (Empty(cCltdest) .And. cUfOrigem == cUfDest)
					cRetCF := '1'
				ElseIf !cUfOrigem == "EX" .And. !cUfDest == "EX"
					cRetCF := "2"
				Else
					cRetCF := SubStr(cCfo,1,1)
				EndIf
			EndIf
		Else
			//Caso o parâmetro MV_TMSUFPG seja falso e o documento seja geraddo à partir do TMS, o sistema deverá considerar a operação como dentro de estado.
			If Iif(nModulo <> 43, cUfDest == cUfOrigem .And. cTpCliFor <> "X", cUfDest == cUfOrigem) 
				cRetCF := "5"
				If cConvCfo == "1"
					// Caso seja operacao com consumidor final troca a terminacao
					// do CFOP
					If (cTpCliFor == "F" .Or. !lInscrito) .And. AllTrim( cRestoCfo ) == "655"
						cRestoCfo := "656" + Space( Len( cRestoCfo ) - 3 )
					EndIf
					If (cTpCliFor == "F" .Or. !lInscrito) .And. AllTrim( cRestoCfo ) == "107"
						cRestoCfo := "101" + Space( Len( cRestoCfo ) - 3 )
					EndIf
					If (cTpCliFor == "F" .Or. !lInscrito) .And. AllTrim( cRestoCfo ) == "108"
						cRestoCfo := "102" + Space( Len( cRestoCfo ) - 3 )
					EndIf
				EndIf
			ElseIf Iif(nModulo <> 43,(cUfDest <> "EX" .And. cTpCliFor == "X") .Or. ( cTpCliFor <> "X"  .And. cUfOrigem <> "EX" ),;
						( cUfOrigem <> cUfDest  .And. cUfDest <> "EX" ))
				// Conversao do CFO interestadual
				cRetCF := "6"

				If cConvCfo == "1"
					If !lInscrito
						If AllTrim( cRestoCfo ) == "102"
							// Caso seja operacao interestadual para nao inscritos
							// altera o final do CFO de 102 para 108
							cRestoCfo := "108" + Space( Len( cRestoCfo ) - 3 )
						ElseIf AllTrim( cRestoCfo ) == "101"
							// Caso seja operacao interestadual para nao inscritos
							// altera o final do CFO de 101 para 107
							cRestoCfo := "107" + Space( Len( cRestoCfo ) - 3 )
						ElseIf AllTrim( cRestoCfo ) == "106"
							// Caso seja operacao interestadual para nao inscritos
							// altera o final do CFO de 106 para 108
							cRestoCfo := "108" + Space( Len( cRestoCfo ) - 3 )
						ElseIf AllTrim( cRestoCfo ) == "105" .And. cUfOrigem =='SP'
							// Caso seja operacao interestadual, emitida de São Paulo para nao não contribuintes e final do CFOP 107, altera este para final 107
							cRestoCfo := "107" + Space( Len( cRestoCfo ) - 3 )
						EndIf
					EndIf
					// Caso seja operacao com consumidor final troca a terminacao
					// do CFOP
					If (cTpCliFor == "F" .Or. !lInscrito) .And. AllTrim( cRestoCfo ) == "655"
						cRestoCfo := "656" + Space( Len( cRestoCfo ) - 3 )
					EndIf
				EndIf
			Else
				Iif (SubStr(cCfo,1,4) $ "5663#6663",cRetCF := SubStr(cCfo,1,1),cRetCF := "7")
			EndIf
		EndIf

		//Em caso de devolução de venda presencial para consumidor final, fundamentação Legal: Art. 136 e 138 do RICMS/SP"
		If aTes[TS_VENPRES] == "1" .And. aNfCab[NF_TPCLIFOR] == "F" .And. aNfCab[NF_OPERNF] == "E" .And. aNfitem[nItem][IT_TIPONF] == "D"
			cRetCF := "1"
		EndIf

		//Venda de combustível ou lubrificante adquirido ou recebido de
		//terceiros destinado a consumidor ou usuário final. Alterar o
		//final do CFO de 656 para 667.
		If cOperNF == "S" .And. cTpCliFor == "X" .And. SubStr(cCfo,2,3) == "656" .And. ( cUfOrigem <> cUfDest )
			If cConvCfo == "1"
				cRestoCfo := "667" + Space( Len( cRestoCfo ) - 3 )
			EndIf
		EndIf

		//Devolução de venda de combustível ou lubrificante destinado
		//a consumidor ou usuário final. Alterar o final do CFO de
		//662 para 202.
		If cOperNF == "E" .And. cTpCliFor == "X" .And. SubStr(cCfo,2,3) == "662" .And. ( cUfOrigem <> cUfDest )
			If cConvCfo == "1"
				cRestoCfo := "202" + Space( Len( cRestoCfo ) - 3 )
			EndIf
		EndIf

		//Venda de Combistiveis a Consumidor Final em operacao interestadual
		//mantem o CFOP 5667 ao inves de 6667 conforme Ajuste Sinief 05/2009.
		//http://www1.fazenda.gov.br/confaz/confaz/ajustes/2009/aj_005_09.htm
		If cOperNF == "S" .And. cTpCliFor <> "R" .And. AllTrim(cCfo) == "5667" .And. ( cUfOrigem <> cUfDest )
			If cConvCfo == "1" .And. fisGetParam('MV_SNEFCFO',.F.)
				cRetCF := "5"
			EndIf
		EndIf

		// Tratamento para Complemento de Frete
		If cTpComp == "F" .And. cConvCfo=="1"
			cRetCF += IIf(SubStr(cCfo,2,3)$"931/932/933/949/351/352/353/354/355/356/360",SubStr(cCfo,2,3),"352")
		Else
			cRetCF += cRestoCfo
		EndIf
	EndIf

	// Ajuste do CFO para fora do estado quando for 4 digitos
	If Left(cRetCf,4) == "6405" .And. cConvCfo == "1"
		cRetCf := "6404"+SubStr(cRetCf,5)
	EndIf

	If lUsaCfps .And. Left(LTrim(cCfo),1)=="9"
		cRetCf := "9"+cRestoCfo
	EndIf

	// Verifica os CFOPS de Importacao e Exportacao.
	If SubStr(cRetCF,1,2) == "79"
		If !fisExtCFOP(cRetCf)
			cRetCf := "7949"
		EndIf
	EndIf

Else
	cRetCF:=Alltrim(cCfo)
EndIf

If cPaisLoc <> "RUS"
	If !fisExtCFOP(cRetCf)
		cRetCF := "     "
	EndIf
EndIf

If ValType( aDados ) <> "A"
	aNfItem[nItem][IT_CF] := PadR(cRetCF,Len(SF4->F4_CF))
Endif

Return ( cRetCF )

/*/
MaExcecao-Eduardo/Edson   -09.12.1999
Calculo das Excecoes fiscais
/*/
Function MaExcecao(nItem,cCampo)

Local aParExce := {}
Local nPosExce := 0
Local aExcecao := {}

nPosExce := xFsVerExce(nItem, cCampo)

aAdd(aParExce, aNFCab[NF_ESPECIE])
aAdd(aParExce, aNFCab[NF_OPERNF])
aAdd(aParExce, aNFCab[NF_GRPCLI])
aAdd(aParExce, aNfCab[NF_CLIFOR])
aAdd(aParExce, aNfCab[NF_TIPONF])
aAdd(aParExce, aNFCab[NF_UFDEST])
aAdd(aParExce, aNFCab[NF_UFORIGEM])
aAdd(aParExce, aNfCab[NF_TPCLIFOR])
aAdd(aParExce, aNFCab[NF_CLIEFAT])
aAdd(aParExce, aNFCab[NF_GRPFAT])
aAdd(aParExce, aNfCab[NF_TIPOFAT])
aAdd(aParExce, aNfItem[nItem][IT_CLASFIS])
aAdd(aParExce, aNFItem[nItem,IT_GRPTRIB])
aAdd(aParExce, aNfItem[nItem][IT_PRD][SB_GRTRIB])
aAdd(aParExce, aNFItem[nItem][IT_TS][TS_SITTRIB])
aAdd(aParExce, aNfitem[nItem][IT_TIPONF])
aAdd(aParExce, aNFItem[nItem][IT_RECORI])
aAdd(aParExce, aNfItem[nItem][IT_PRD][SB_ORIGEM])
If nPosExce > 0
	aAdd(aParExce, aNfItem[nPosExce][IT_EXCECAO])
Else
	aAdd(aParExce, aNfItem[nItem][IT_EXCECAO])
EndIf
aAdd(aParExce, aNfItem[nItem][IT_EXCEFAT])
aAdd(aParExce, aNfItem[nItem][IT_IDSF7])
aAdd(aParExce, " ") // Campo com contéudo do IDHist quando houver

If cPaisLoc <> 'RUS'
	aExcecao := xFsExcecao(@nItem,@cCampo,@aNfItem,@aPos,@aSX6,@aNFCab,@aPE,@lHistorico, cAlsItem, @aParExce, nPosExce)
Endif 

aNfItem[nItem][IT_CLASFIS] := aParExce[EF_IT_CLASFIS]
aNfItem[nItem][IT_EXCECAO] := aParExce[EF_IT_EXCECAO]
aNfItem[nItem][IT_EXCEFAT] := aParExce[EF_IT_EXCEFAT]
aNfItem[nItem][IT_IDSF7]   := aParExce[EF_IT_IDSF7]

aSize(aParExce,0)

Return aExcecao

/*/
MaFisAjIt - Gustavo Rueda  -13/12/2007
Funcao de consistencias dos ajustes dos documentos fiscais.
Parametros
nXX -> Numero do item.
nTipo -> Tipo de processamento. 1=Item a item, 2=Todos Items
/*/
Function MaFisAjIt(nXX,nTipo)
Local aGrava	:= {}

	aGrava := xMaFisAjIt(@nXX, @nTipo, @aNfCab, @aNfItem, @aPos, @aSX6, @aDic, aPE, aInfNat)


Return aGrava

//-------------------------------------------------------------------
/*/{Protheus.doc} MafisAgrIt

Função que fará o agrupamento de tributos por item do xml

@author Adilson Roberto
@since 15/07/2022
@version 12.1.33
/*/
//-------------------------------------------------------------------
Function MafisAgrIt()

Local oItemAgr	:= Nil

	AgrupItem(aNfItem,aNfCab,aPos,aSX6,@oItemAgr,cPaisLoc)

Return oItemAgr
//-------------------------------------------------------------------
//-------------------------------------------------------------------
/* FUNCOES PARA CALCULO DE IMPOSTOS - LOCALIZADOS E IMPOSTOS VARIAVEIS (BRASIL) */

/*/
MaFisBSIV - Edson Maricate  -02.02.2000
Executa o calculo da Base dos Impostos Variaveis
Parametros
ExpN1: Numero do Imposto ( 1 a X )
ExpN2: Item a ser calculado
/*/
Static Function MaFisBSIV(nImposto,nItem)

Local nBaseRet
Local nImp     := Len(aTes[TS_SFC])
Local nImpde   := IIF(nImposto==Nil,1,nImposto)
Local nImpAte  := IIF(nImposto==Nil,nImp,nImposto)

Private aInfo   //Definida como private pois é usada numa macro    := {}
// Verifica se a TES possui tratamento para Impostos Variaveis
If !Empty(aTes[TS_SFC])
	If nImpde>0 .And. nImpAte>0
		For nImposto := nImpDe to nImpAte
			// Executa o calculo atraves da Funcao cadastrada no SFB
			aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
			nImp:=NumCpoImpVar(aInfo[2])
			If aNfCab[NF_OPERNF] == "E"
				If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
					If cPaisLoc <> "BRA"
						nBaseRet := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo)')
						If ValType(nBaseRet) == "N"
							aNfItem[nItem][IT_BASEIMP][nImp]:= nBaseRet
							If cPaisLoc == "RUS"
								aNfItem[nItem][IT_BASEIMP_C1][nImp]:= xMoeda(nBaseRet,aNFCab[NF_MOEDA],1,dDataBase,,aNFCab[NF_TXMOEDA])
							EndIf
						EndIf
					Else
						aNfItem[nItem][IT_BASEIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"B",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
					EndIf
					aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
				EndIf
			Else
				If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
					If cPaisLoc <> "BRA"
						nBaseRet :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo)')
						If ValType(nBaseRet) == "N"
							aNfItem[nItem][IT_BASEIMP][nImp]:= nBaseRet
							If cPaisLoc == "RUS"
								aNfItem[nItem][IT_BASEIMP_C1][nImp]:= xMoeda(nBaseRet,aNFCab[NF_MOEDA],1,dDataBase,,aNFCab[NF_TXMOEDA])
							EndIf
						EndIf
					Else
						aNfItem[nItem][IT_BASEIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"B",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
					EndIf
					aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
				EndIf
			EndIf
		Next nImposto
	Endif
Else
	// Zera todas as aliquotas.
	For nImposto := 1 to NMAXIV
		aNFItem[nItem][IT_BASEIMP][nImposto]:= 0
		aNfItem[nItem][IT_DESCIV][nImposto] := {"","",""}
		If cPaisLoc == "RUS"
			aNFItem[nItem][IT_BASEIMP_C1][nImposto]:= 0
		EndIf
	Next nImposto
EndIf

Return Nil

/*/
MaFisAliqIV - Edson Maricate-02.02.2000
Executa o calculo da Aliquota dos Impostos Variaveis
Parametros
ExpN1: Numero do Imposto ( 1 a 6 )
ExpN2: Item a ser calculado
/*/
Static Function MaFisAliqIV(nImposto,nItem)

Local nAliqImp
Local nImp	  :=Len(aTes[TS_SFC])
Local nImpde  :=IIF(nImposto==Nil,1,nImposto)
Local nImpAte :=IIF(nImposto==Nil,nImp,nImposto)
Local nMv_ALQIPM	:= fisGetParam('MV_ALQIPM',0)
Local cMV_AGENTE    := fisGetParam('MV_AGENTE',"   ")
Local alAreaX
Local alAreaY
Local alAreaZ
Local nlTotal := 0
Local nlMinDIG := fisGetParam('MV_MINDETR',0)
Local nCpoIPM  := 3
Local lFnTpDig:= (cPaisLoc == "PER" .AND. ((((funname() == "MATA101N") .Or. (fisFindFunc("ChkLxProp") .and. ChkLxProp("xFisValidaDetraccion"))) .AND. aNfCab[NF_TIPODOC] == "10") .OR. funname() == "MATA121") .AND. FindFunction("LxPerTpDIG")) 
Local lTpDig := .F.
Local aTaxKey := IIf(lVldCalImp, fGetTaxKey(nItem), Array(2))

Private aInfo 									  //Definida como private pois é usada numa macro
// Verifica se a TES possui tratamento para Impostos Variaveis
If cPaisLoc=="PER"  .And. fisExtCmp('12.1.2310', .T.,'SB1','B1_VMINDET')
	nlMinDIG := Iif( aNfItem[nItem][IT_PRD][SB_VMINDET] > 0 , aNfItem[nItem][IT_PRD][SB_VMINDET] , nlMinDIG )
EndIf

If !Empty(aTes[TS_SFC])
	If nImpde>0 .And. nImpAte>0
		For nImposto := nImpDe to nImpAte
			//       Tratamento especifico para localizado PERU
			// Abaixo estão as aliquotas dos impostos variáveis de acordo
			// com as regras de ISC, IGV, PIV e DIG. Caso não seja nenhum
			// desses executa normalmente como se fosse não localizado

			//Caso nao seja localizado Peru, executa o padrão
			If cPaisLoc $ "PER"
				alAreaX := SFC->(GetArea())
				alAreaY := SF4->(GetArea())
				alAreaZ := GetArea()
				lTpDig  := .F. 
				If lFnTpDig 
					lTpDig := LxPerTpDIG(aTes[TS_SFC][nImposto][SFC_IMPOSTO])
				EndIF

				If aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "IGV"
					DbSelectArea("SF4")
					DbSetOrder(1)
					If MsSeek(xFilial("SF4")+aTes[TS_CODIGO])
						If (SF4->F4_CALCIGV <> "2" .And. SF4->F4_CALCIGV <> "3" .And. SF4->F4_CALCIGV <> "4")

							// Executa o calculo atraves da Funcao cadastrada no SFB
							aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
							nImp:=NumCpoImpVar(aInfo[2])
							If aNfCab[NF_OPERNF] == "E"
								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
									If cPaisLoc <> "BRA"
										nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')
										If ValType(nAliqImp) == "N"
											aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
											If aNfCab[NF_CPOIPM] <> 0
												nCpoIPM := aNfCab[NF_CPOIPM]
											EndIf
											If aNfCab[NF_ALQIPM] <> 0
												nMv_ALQIPM := aNfCab[NF_ALQIPM]
											EndIf
											//          TRATAMENTO EXPECIFICO PARA LOCALIZADO PERU
											// Quando o TES for referente ao imposto do IGV, o valor do IPM, o
											// qual é uma porcentagem do IGV,o valor da base, aliquota e valor do
											// imposto é gravado nos campos _BASIMP3, _ALQIMP3 e VALIMP3.
											// O valor da base é a mesma utilizada para o cálculo do IGV.
											// O valor da alíqutoa é proveniente de um paramêtro chamado
											// MV_ALQIPM.
											// O valor do imposto é a multiplicação da base pelo valor da aliquota
											// NO CASO ABAIXO APENAS A ALIQUOTA DO IMPOSTO é PREENCHIDA PARA ENTRA-
											// DA.
											If nMv_ALQIPM > 0 
												aNfItem[nItem][IT_ALIQIMP][nCpoIPM] += nMv_ALQIPM
											EndIf
										EndIf
									Else
										aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							Else
								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
									If cPaisLoc <>"BRA"

										nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')

										If ValType(nAliqImp) == "N"
											aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
											If aNfCab[NF_CPOIPM] <> 0
												nCpoIPM := aNfCab[NF_CPOIPM]
											EndIf
											If aNfCab[NF_ALQIPM] <> 0
												nMv_ALQIPM := aNfCab[NF_ALQIPM]
											EndIf
											//          TRATAMENTO EXPECIFICO PARA LOCALIZADO PERU
											// NO CASO ABAIXO APENAS A ALIQUOTA DO IMPOSTO é PREENCHIDA PARA SAIDA.
											If nMv_ALQIPM > 0
												aNfItem[nItem][IT_ALIQIMP][nCpoIPM] += nMv_ALQIPM
											EndIf

										EndIf
									Else
										aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
				ElseIf aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "PIV"

					// Executa o calculo atraves da Funcao cadastrada no SFB
					aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
					nImp:=NumCpoImpVar(aInfo[2])
					If aNfCab[NF_OPERNF] == "E"

						If aNfCab[NF_CLIFOR] $ "F"

							If SubStr(cMV_AGENTE,2,1) == "S" .And.  SA2->A2_AGENRET <> "1"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
									If cPaisLoc <> "BRA"

										nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')

										If ValType(nAliqImp) == "N"
											aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
										EndIf
									Else
										aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf

							EndIf

						ElseIf aNfCab[NF_CLIFOR] $ "C"

							If SA1->A1_AGENTE == "2"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
									If cPaisLoc <> "BRA"

										nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')

										If ValType(nAliqImp) == "N"
											aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
										EndIf
									Else
										aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf
						EndIf
					Else
						If aNfCab[NF_CLIFOR] $ "C"

							If SA1->A1_AGENTE == "2"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
									If cPaisLoc <>"BRA"

										nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')

										If ValType(nAliqImp) == "N"
											aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp

										EndIf
									Else
										aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf

							EndIf

						ElseIf aNfCab[NF_CLIFOR] $ "F"

							If SubStr(cMV_AGENTE,2,1) == "S" .And.  SA2->A2_AGENRET <> "1"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
									If cPaisLoc <>"BRA"

										nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')

										If ValType(nAliqImp) == "N"
											aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp

										EndIf
									Else
										aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf

							EndIf

						EndIf

					EndIf

				ElseIf aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "DIG"  .OR. lTpDig

					nlTotal := MaRetBasT(,,,.T.)

					nlTOtal += aNfCab[NF_FRETE] + aNfCab[NF_DESPESA] + aNfCab[NF_SEGURO] - (aNfCab[NF_DESCONTO]+aNfCab[NF_DESCTOT]) + aNfCab[NF_ACRESCI]

					If ((AllTrim(Upper(FunName())) $ "MATA465N/MATA466N/MATA467N/MATA101N/MATA121") .Or. (fisFindFunc("ChkLxProp") .and. ChkLxProp("xFisAplicaTasaPER"))) .And. aNFCab[NF_TXMOEDA] <> 0

						nlTotal := nlTotal * aNFCab[NF_TXMOEDA]

					ElseIf AllTrim(Upper(FunName())) $ "MATA410/OFIXA018/OFIXA011/OFIXA100"

						nlTotal := xMoeda(nlTotal,M->C5_MOEDA,1,dDataBase)

					EndIf
					If nlTotal > nlMinDIG

						// Executa o calculo atraves da Funcao cadastrada no SFB

						MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)

						aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
						nImp:=NumCpoImpVar(aInfo[2])
						If aNfCab[NF_OPERNF] == "E"

							If aNfCab[NF_CLIFOR] $ "F"

								If SubStr(cMV_AGENTE,3,1) == "S"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
										If cPaisLoc <> "BRA"

											nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')

											If ValType(nAliqImp) == "N"
												aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
											EndIf
										Else
											aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf
									EndIf

								EndIf

							ElseIf aNfCab[NF_CLIFOR] $ "C"

								If SubStr(cMV_AGENTE,1,1) == "N" .And.  SA1->A1_AGENTE == "3"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
										If cPaisLoc <> "BRA"

											nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')

											If ValType(nAliqImp) == "N"
												aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
											EndIf
										Else
											aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf
									EndIf
								EndIf
							EndIf
						Else

							If aNfCab[NF_CLIFOR] $ "C"

								If SubStr(cMV_AGENTE,1,1) == "N" .And.  SA1->A1_AGENTE == "3"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If cPaisLoc <>"BRA"

											nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')

											If ValType(nAliqImp) == "N"
												aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp

											EndIf
										Else
											aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf
									EndIf

								EndIf

							ElseIf aNfCab[NF_CLIFOR] $ "F"

								If SubStr(cMV_AGENTE,3,1) == "S" .And.  SA2->A2_AGENRET <> "1"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If cPaisLoc <>"BRA"

											nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')

											If ValType(nAliqImp) == "N"
												aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp

											EndIf
										Else
											aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf
									EndIf

								EndIf

							EndIf

						EndIf
					EndIf
				Else
					// Executa o calculo atraves da Funcao cadastrada no SFB
					aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
					nImp:=NumCpoImpVar(aInfo[2])
					If aNfCab[NF_OPERNF] == "E"
						If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
							If cPaisLoc <> "BRA"

								nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')
								If ValType(nAliqImp) == "N"
									aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
								EndIf
							Else
								aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
							EndIf
						EndIf
					Else
						If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
							If cPaisLoc <>"BRA"
								nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')
								If ValType(nAliqImp) == "N"
									aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
								EndIf
							Else
								aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
							EndIf
						EndIf
					EndIf
				EndIf
				RestArea(alAreaX)
				RestArea(alAreaY)
				RestArea(alAreaZ)
			Else
				// Executa o calculo atraves da Funcao cadastrada no SFB
				aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
				nImp:=NumCpoImpVar(aInfo[2])
				If aNfCab[NF_OPERNF] == "E"
					If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
						If cPaisLoc <> "BRA"
							If lVldCalImp
								If fVldCalImp(aTes[TS_SFC][nImposto][SFB_FORMENT], aTaxKey, aInfo, aNfCab[NF_OPERNF])
									nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')
								EndIf
							Else
								nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')
							EndIf
							If ValType(nAliqImp) == "N"
								aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
							EndIf
						Else
							aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
						EndIf
					EndIf
				Else
					If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
						If cPaisLoc <>"BRA"
							If lVldCalImp
								If fVldCalImp(aTes[TS_SFC][nImposto][SFB_FORMSAI], aTaxKey, aInfo, aNfCab[NF_OPERNF])
									nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')
								EndIf
							Else
								nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')
							EndIf
							If ValType(nAliqImp) == "N"
								aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp

							EndIf
						Else
							aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
						EndIf
					EndIf
				EndIf
			EndIf
		Next nImposto
	Endif
Else
	// Zera todas as aliquotas.
	For nImposto := 1 to NMAXIV
		aNFItem[nItem][IT_ALIQIMP][nImposto]:= 0
	Next nImposto
EndIf
Return Nil

/*/
MaFisVLIV - Edson Maricate  -02.02.2000
Executa o calculo do Valor dos Impostos Variaveis
Parametros
ExpN1: Numero do Imposto ( 1 a X )
ExpN2: Item a ser calculado
/*/
Static Function MaFisVLIV(nImposto,nItem,cCampo)

Local nValImp  := 0
Local nImp		:=Len(aTes[TS_SFC])
Local nImpde 	:=IIF(nImposto==Nil,1,nImposto)
Local nImpAte	:=IIF(nImposto==Nil,nImp,nImposto)
Local cMV_AGENTE  	:= fisGetParam('MV_AGENTE',"   ")
Local nMv_ALQIPM	:= fisGetParam('MV_ALQIPM',0)
Local alAreaX
Local alAreaY
Local alAreaZ
Local nlTotal := 0
Local nlMinDIG 		:= fisGetParam('MV_MINDETR',0)
Local nCpoIPM := 3
Local lFnTpDig:= cPaisLoc == "PER" .AND. ((((funname() == "MATA101N") .Or. (fisFindFunc("ChkLxProp") .and. ChkLxProp("xFisValidaDetraccion"))) .AND. aNfCab[NF_TIPODOC] == "10") .OR. funname() == "MATA121") .AND. FindFunction("LxPerTpDIG") 
Local lTpDig := .F.
Local aTaxKey := IIf(lVldCalImp, fGetTaxKey(nItem), Array(2))

Default cCampo := ""
Private aInfo //Definida como private pois é usada numa macro
// Verifica se a TES possui tratamento para Impostos Variaveis
If cPaisLoc=="PER"  .And. fisExtCmp('12.1.2310', .T.,'SB1','B1_VMINDET')
	nlMinDIG := Iif(aNfItem[nItem][IT_PRD][SB_VMINDET] > 0 , aNfItem[nItem][IT_PRD][SB_VMINDET] , nlMinDIG)
EndIf

If aNfCab[NF_ALQIPM] <> 0
	nMv_ALQIPM := aNfCab[NF_ALQIPM]
EndIf

If !Empty(aTes[TS_SFC])
	If nImpde>0 .And. nImpAte>0
		For nImposto := nImpDe to nImpAte
			//       Tratamento especifico para localizado PERU
			// Abaixo estão os cálculos dos impostos variáveis de acordo
			// com as regras de ISC,IGV, PIV e DIG. Caso não seja nenhum
			// desses executa normalmente como se fosse não localizado

			//Caso seja não seja localizado Peru, executa padrão
			If cPaisLoc $ "PER"
				alAreaX := SFC->(GetArea())
				alAreaY := SF4->(GetArea())
				alAreaZ := GetArea()
				lTpDig  := .F. 
				If lFnTpDig 
					lTpDig := LxPerTpDIG(aTes[TS_SFC][nImposto][SFC_IMPOSTO])
				EndIF
				If aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "IGV"
					DbSelectArea("SF4")
					DbSetOrder(1)
					If MsSeek(xFilial("SF4")+aTes[TS_CODIGO])
						If (SF4->F4_CALCIGV <> "2" .And. SF4->F4_CALCIGV <> "3" .And. SF4->F4_CALCIGV <> "4")

							// Executa o calculo atraves da Funcao cadastrada no SFB
							aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
							nImp:=NumCpoImpVar(aInfo[2])
							If aNfCab[NF_OPERNF] == "E"
								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
									If cPaisLoc <> "BRA"
										nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')
										If ValType(nValImp) == "N"
											aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
											If aNfCab[NF_CPOIPM] <> 0
												nCpoIPM := aNfCab[NF_CPOIPM]
											EndIf
											//          TRATAMENTO EXPECIFICO PARA LOCALIZADO PERU
											// Quando o TES for referente ao imposto do IGV, o valor do IPM, o
											// qual é uma porcentagem do IGV,o valor da base, aliquota e valor do
											// imposto é gravado nos campos _BASIMP3, _ALQIMP3 e VALIMP3.
											// O valor da base é a mesma utilizada para o cálculo do IGV.
											// O valor da alíqutoa é proveniente de um paramêtro chamado
											// MV_ALQIPM.
											// O valor do imposto é a multiplicação da base pelo valor da aliquota
											// NO CASO ABAIXO APENAS O VALOR DO IMPOSTO é PREENCHIDO PARA ENTRADA,
											// SENDO QUE OS VALORRES DA BASE E DA ALIQUOTA Já FORAM PREENCHIDOS AN-
											// TERIORMENTE.
											If nMv_ALQIPM > 0 .And. aNfItem[nItem][IT_VALIMP][nCpoIPM] == 0
												aNfItem[nItem][IT_VALIMP][nCpoIPM] += aNfItem[nItem][IT_BASEIMP][nCpoIPM] * (nMv_ALQIPM/100)
											EndIf
										EndIf
									Else
										aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							Else
								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
									If cPaisLoc <>"BRA"
										nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')
										If ValType(nValImp) == "N"
											aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
											If aNfCab[NF_CPOIPM] <> 0
												nCpoIPM := aNfCab[NF_CPOIPM]
											EndIf
											//          TRATAMENTO EXPECIFICO PARA LOCALIZADO PERU
											// NO CASO ABAIXO APENAS O VALOR DO IMPOSTO é PREENCHIDO PARA SáIDA,
											// SENDO QUE OS VALORRES DA BASE E DA ALIQUOTA Já FORAM PREENCHIDOS AN-
											// TERIORMENTE.
											If nMv_ALQIPM > 0 .And. aNfItem[nItem][IT_VALIMP][nCpoIPM] == 0
												aNfItem[nItem][IT_VALIMP][nCpoIPM]:= aNfItem[nItem][IT_BASEIMP][nCpoIPM] * (nMv_ALQIPM/100)
											EndIf
										EndIf
									Else
										aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf
							// Verifica as Propriedades do Imposto
							Do Case
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
									nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
									nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
									nValImp:=0
							EndCase
							aNfItem[nItem][IT_BASEDUP] += nValImp
							Do Case
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
									nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
									nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
									nValImp:=0
							EndCase
							aNfItem[nItem][IT_TOTAL] += nValImp
						EndIf
					EndIf

				ElseIf aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "PIV"

					// Executa o calculo atraves da Funcao cadastrada no SFB
					aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
					nImp:=NumCpoImpVar(aInfo[2])
					If aNfCab[NF_OPERNF] == "E"

						If aNfCab[NF_CLIFOR] $ "F"

							If SubStr(cMV_AGENTE,2,1) == "S" .And.  SA2->A2_AGENRET <> "1"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
									If cPaisLoc <> "BRA"

										nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')

										If ValType(nValImp) == "N"
											aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
										EndIf
									Else
										aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf

						ElseIf aNfCab[NF_CLIFOR] $ "C"

							If SA1->A1_AGENTE == "2"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
									If cPaisLoc <> "BRA"

										nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')

										If ValType(nValImp) == "N"
											aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
										EndIf
									Else
										aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf
						EndIf
					Else
						If aNfCab[NF_CLIFOR] $ "C"
							If SA1->A1_AGENTE == "2"
								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
									If cPaisLoc <>"BRA"

										nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')

										If ValType(nValImp) == "N"
											aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
										EndIf
									Else
										aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf
						ElseIf aNfCab[NF_CLIFOR] $ "F"

							If SubStr(cMV_AGENTE,2,1) == "S" .And.  SA2->A2_AGENRET <> "1"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
									If cPaisLoc <>"BRA"

										nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')

										If ValType(nValImp) == "N"
											aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
										EndIf
									Else
										aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
					// Verifica as Propriedades do Imposto
					Do Case
						Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
							nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
							nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
							nValImp:=0
					EndCase
					aNfItem[nItem][IT_BASEDUP] += nValImp
					Do Case
						Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
							nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
							nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
							nValImp:=0
					EndCase
					aNfItem[nItem][IT_TOTAL] += nValImp

				ElseIf aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "DIG" .OR. lTpDig

					nlTotal := MaRetBasT(,,,.T.)

					nlTOtal += aNfCab[NF_FRETE] + aNfCab[NF_DESPESA] + aNfCab[NF_SEGURO] - (aNfCab[NF_DESCONTO]+aNfCab[NF_DESCTOT]) + aNfCab[NF_ACRESCI]

					If ((AllTrim(Upper(FunName())) $ "MATA465N/MATA466N/MATA467N/MATA101N/MATA121") .Or. (fisFindFunc("ChkLxProp") .and. ChkLxProp("xFisAplicaTasaPER"))) .And. aNFCab[NF_TXMOEDA] <> 0

						nlTotal := nlTotal * aNFCab[NF_TXMOEDA]

					ElseIf AllTrim(Upper(FunName())) $ "MATA410/OFIXA018/OFIXA011/OFIXA100"

						nlTotal := xMoeda(nlTotal,M->C5_MOEDA,1,dDataBase)

					EndIf
					If nlTotal > nlMinDIG
						// Executa o calculo atraves da Funcao cadastrada no SFB

						MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)

						aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
						nImp:=NumCpoImpVar(aInfo[2])
						If aNfCab[NF_OPERNF] == "E"

							If aNfCab[NF_CLIFOR] $ "F"

								If SubStr(cMV_AGENTE,3,1) == "S"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])

										If cPaisLoc <> "BRA"

											nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')

											If ValType(nValImp) == "N"
												aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
											EndIf
										Else
											aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf

									EndIf

								EndIf

							ElseIf aNfCab[NF_CLIFOR] $ "C"

								If SubStr(cMV_AGENTE,1,1) == "N" .And.  SA1->A1_AGENTE == "3"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])

										If cPaisLoc <> "BRA"

											nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')

											If ValType(nValImp) == "N"
												aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
											EndIf
										Else
											aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf

									EndIf

								EndIf

							EndIf

						Else

							If aNfCab[NF_CLIFOR] $ "C"

								If SubStr(cMV_AGENTE,1,1) == "N" .And.  SA1->A1_AGENTE == "3"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If cPaisLoc <>"BRA"

											nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')

											If ValType(nValImp) == "N"
												aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
											EndIf
										Else
											aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf
									EndIf

								EndIf

							ElseIf aNfCab[NF_CLIFOR] $ "F"

								If SubStr(cMV_AGENTE,3,1) == "S" .And.  SA2->A2_AGENRET <> "1"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If cPaisLoc <>"BRA"

											nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')

											If ValType(nValImp) == "N"
												aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
											EndIf
										Else
											aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf
									EndIf

								EndIf

							EndIf


						EndIf
						// Verifica as Propriedades do Imposto
						Do Case
							Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
								nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
								nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
								nValImp:=0
						EndCase
						aNfItem[nItem][IT_BASEDUP] += nValImp
						Do Case
							Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
								nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
								nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
								nValImp:=0
						EndCase
						aNfItem[nItem][IT_TOTAL] += nValImp
					EndIf
				Else

					// Executa o calculo atraves da Funcao cadastrada no SFB
					aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
					nImp:=NumCpoImpVar(aInfo[2])
					If aNfCab[NF_OPERNF] == "E"
						If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
							If cPaisLoc <> "BRA"

								nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')

								If ValType(nValImp) == "N"
									aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
								EndIf
							Else
								aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
							EndIf
						EndIf
					Else
						If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
							If cPaisLoc <>"BRA"

								nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')

								If ValType(nValImp) == "N"
									aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
								EndIf
							Else
								aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
							EndIf
						EndIf
					EndIf
					// Verifica as Propriedades do Imposto
					Do Case
						Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
							nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
							nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
							nValImp:=0
					EndCase
					aNfItem[nItem][IT_BASEDUP] += nValImp
					Do Case
						Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
							nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
							nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
							nValImp:=0
					EndCase
					aNfItem[nItem][IT_TOTAL] += nValImp

				EndIf

				RestArea(alAreaX)
				RestArea(alAreaY)
				RestArea(alAreaZ)
			Else

				// Executa o calculo atraves da Funcao cadastrada no SFB
				aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
				nImp:=NumCpoImpVar(aInfo[2])
				If aNfCab[NF_OPERNF] == "E"
					If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
						If cPaisLoc <> "BRA"
							If lVldCalImp
								If fVldCalImp(aTes[TS_SFC][nImposto][SFB_FORMENT], aTaxKey, aInfo, aNfCab[NF_OPERNF])
									nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')
								EndIf
							Else
								nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')
							EndIf
							If ValType(nValImp) == "N"
								aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
								If cPaisLoc == "RUS"
									aNfItem[nItem][IT_VALIMP_C1][nImp]:= Iif( !("_C1" $ cCampo) .AND. !IsInCallStack("__MODXOK"),Round(xMoeda(nValImp,aNfCab[NF_MOEDA],1,dDataBase,10,aNfCab[NF_TXMOEDA]),2),MaFisRet(nItem, "IT_VALIV1_C1"))
								EndIf
							EndIf
						Else
							aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
						EndIf
					EndIf
				Else
					If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
						If cPaisLoc <>"BRA"
							If lVldCalImp
								If fVldCalImp(aTes[TS_SFC][nImposto][SFB_FORMSAI], aTaxKey, aInfo, aNfCab[NF_OPERNF])
									nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')
								EndIf
							Else
								nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')
							EndIf
							If ValType(nValImp) == "N"
								aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
								If cPaisLoc == "RUS"
									aNfItem[nItem][IT_VALIMP_C1][nImp]:= Iif(!("_C1" $ cCampo) .AND. !IsInCallStack("__MODXOK"),Round(xMoeda(nValImp,aNfCab[NF_MOEDA],1,dDataBase,10,aNfCab[NF_TXMOEDA]),2),MaFisRet(nItem, "IT_VALIV1_C1"))
								EndIf
							EndIf
						Else
							aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
						EndIf
					EndIf
				EndIf
				// Verifica as Propriedades do Imposto
				Do Case
					Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
						nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
					Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
						nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
					Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
						nValImp:=0
				EndCase
				aNfItem[nItem][IT_BASEDUP] += nValImp
				Do Case
					Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
						nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
					Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
						nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
					Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
						nValImp:=0
				EndCase
				aNfItem[nItem][IT_TOTAL] += nValImp
				If cPaisLoc == "RUS"
					aNfItem[nItem][IT_TOTAL_C1] += Iif(!("_C1" $ cCampo),xMoeda(nValImp,aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA]),MaFisRet(nItem,"IT_VALIV1_C1"))
				EndIf
			EndIf
		Next nImposto
	Endif
Else
	// Zera todas as aliquotas.
	For nImposto := 1 to NMAXIV
		aNFItem[nItem][IT_VALIMP][nImposto]:= 0
		aNFItem[nItem][IT_VALIMP_C1][nImposto]:= 0
	Next nImposto
EndIf

Return Nil

/*/
MaFisNameIV - Edson Maricate-02.02.2000
Preeche o nome dos impostos Variaveis
Parametros
ExpN1: Numero do Imposto ( 1 a 6 )
ExpN2: Item a ser calculado
/*/
Static Function MaFisNameIV(nImposto,nItem)

Local nImpde  := IIf(nImposto==Nil,1,nImposto)
Local nImpAte := IIF(nImposto==Nil,Len(aTes[TS_SFC]),nImposto)

// Verifica se a TES possui tratamento para Impostos Variaveis
If !Empty(aTes[TS_SFC])
	If nImpde>0 .And. nImpAte>0
		For nImposto := nImpDe to nImpAte
			// Executa o calculo atraves da Funcao cadastrada no SFB
			If	aNfCab[NF_OPERNF] == "E"
				If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
					nImp:=NumCpoImpVar(RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1))
					aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
				EndIf
			Else
				If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
					nImp:=NumCpoImpVar(RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVRSI]),1))
					aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
				EndIf
			EndIf
		Next nImposto
	Endif
Else
	For nImposto := 1 to NMAXIV
		aNfItem[nItem][IT_DESCIV][nImposto] := {"","",""}
	Next nImposto
EndIf

Return Nil

/*/
MaFisImpIV - Alexandre Lemes -27/11/2013
Funcao que dispara o calculo dos impostos localizados.
A Funcao sofreu um refactory em 27/11/2013 em razao da baixa performance ao calcular os impostos por Total do pais
Argentina. O projeto de melhoria de performance do calculo dos impostos localizados foi dividido por fases sendo
que o refacture desta funcao foi a FASE I.
Parametros
ExpN1: Item
ExpC2: Referencia Fiscal vinda da MaFisRecal()
ExpL3: Flag ao editar os campos de despesas acessorias do
do documento fiscal serve para evitar o recalculo
desnecessario dos imposto por total
ExpL4: Indica se a chamada da funcao vem da edicao de um
campo de cabecalho do documento fiscal (Despesas acessorias)
/*/
Static Function MaFisImpIV(nItem,cCampo,lExecuta,lDespesas)

Local aCposArred  := {"IT_DESCONTO","IT_FRETE","IT_DESPESA","IT_SEGURO","IT_VALEMB","IT_TOTAL","IT_VALMERC","IT_VNAGREG","IT_BASEDUP","IT_ADIANT","IT_DESCTOT","IT_ACRESCI","IT_VLR_FRT","IT_DESNTRB"}
Local aCalcular   := aClone( aTes[TS_SFC] )
Local aAreaSFB	:= SFB->(GetArea())
Local cNumCpo     := ""
Local nX		  := 0
Local nY 		  := 0
Local nG          := 0
Local nZ          := 0
Local nIV         := 0
Local nBaseIV     := 0
Local nAliquota   := 0
Local nValorIV    := 0
Local nImpAnt     := 0
Local nVlrRateado := 0
Local nBseRateado := 0
Local nBseRateio  := 0
Local nFator      := 0
Local nPosItRef   := 0
Local nDecimais	  := IIf( cPaisLoc $ "ARG/PER/EQU/COL" , MsDecimais(aNFCab[NF_MOEDA]) , 0 )
Local lRefazNFCab := .T.
Local lPasaIB	  := .F.
Local aAreaSFC	  := SFC->(GetArea())
Local nOrdSFC	  := SFC->(IndexOrd())
Local lLojaIb 	  := .T.
Local nCountIT	  := 0
Local nUltItem	  := 0
Local nPosTESM	:= 0
Local lArgSal 	  := IIf( cPaisLoc == "ARG", ((Upper(Funname()) $ "MATA410") .Or. (fisFindFunc("ChkLxProp") .and. ChkLxProp("xFisCalcFinal"))),.F.)
Local lFlagCalc  := .T.	//OPTIMIZA
Local lCalcTot   := .T.
Local lLivFisARG := Iif(cPaisLoc == "ARG" .And. ((Funname() $ "MATA101N|MATA465N|MATA466N|MATA467N") .Or. (fisFindFunc("ChkLxProp") .and. ChkLxProp("xFisLivFisArg"))), .T., .F.)
Local lTESxTotal  := .F. //.T. cuando existe impuesto configurado por total en la TES
Local lfNReFaz   := (cPaisLoc == "ARG" .And. Funname() $ "MATA101N|MATA465N")
Local lSFC := .T.
Local lTesMXF	:= Type("aTesMXF") <> "U"
Local oCposArred := JsonObject():New()
Local lTESMIZero:=  IIF(cPaisLoc == "ARG",len(aTes[TS_SFC])>0 ,.T.)
Local lRatImpIt := cPaisLoc <> "BRA" .And. fisFindFunc("RatImpItem")

DEFAULT cCampo	 := ""
DEFAULT lExecuta := .T.
DEFAULT lDespesas:= .F.

If cPaisLoc == "PER" .and. fisExtCmp('12.1.2310', .T.,'SF1','F1_ADIANT')
	AADD(aCposArred,"IT_ADIANTTOT")
EndIf

//OPTIMIZA
If cPaisLoc $ "ARG|RUS"
	lFlagCalc := IIF(Type("lLocxAuto") <> "U" .and. lLocxAuto, Iif(cPaisLoc <> "RUS" .And. Type("cUltCpo") <> "U", cCampo == cUltCpo,.T.),MaFisRet(nItem,"IT_VALMERC")>0 .and. !Empty(MaFisRet(nItem,"IT_TES")))
	If lfNReFaz .And. (IsIncallStack("LxA103ForF4") .or. IsIncallStack("LxA103ItemPC") .or. IsIncallStack("LxA103Cond")) 
		If IsIncallStack("MaFisReprocess")
			lFlagCalc := .T.
			If Type("aTESPedC") <> "U"
				If Len(aTESPedC) == 1
					lRefazNFCab := IIf(nItem == Len(aNfItem), .T., .F.)
					lCalcTot    := IIf(nItem == Len(aNfItem), .T., .F.)
				EndIf
			EndIf
		EndIf
	EndIf

	If lfNReFaz .And. IsIncallStack("LxDocOri") .And. IsIncallStack("MaFisReprocess") .And. Type("aTESDcOri") <> "U" .And. Len(aTESDcOri) == 1
		lRefazNFCab := IIf(nItem == Len(aNfItem), .T., .F.)
		lCalcTot    := IIf(nItem == Len(aNfItem), .T., .F.)
	EndIf
EndIf

If lNotRemito .and. lFlagCalc	//OPTIMIZA
	//Tratamento para calculo do impostos variaveis localizados especifico para o SIGAEIC.
	If (Type("lFacImport")=="L" .And. lFacImport)
		PRIVATE aImposEIC := {}
		SD1->(MsSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aNfItem[nItem][IT_PRODUTO]+StrZero(nItem,FisTamSX3( 'SD1','D1_ITEM')[1])))
		A100IniImp(SD1->D1_SERIE,SD1->D1_DOC,SD1->D1_TEC,,,,,,,nItem)
		If Len(aImposEic) > 0
			For nX := 1 To Len(aImposEIC)
				nIV := NumCpoImpVar(Right(aImposEIC[nX,6],1))
				If nIV > 0
					SFB->(MsSeek(xFilial("SFB")+aImposEIC[nX,4]))
					aNFItem[nItem][IT_BASEIMP][nIV]	:=	aImposEIC[nX,7]
					aNfItem[nItem][IT_DESCIV][nIV]	:=	{aImposEIC[nX,4],SFB->FB_DESCR,Posicione("SFC",1,xFilial("SFC")+aImposEIC[nX][2]+aImposEIC[nX][3]+aImposEIC[nX][4],"FC_CALCULO")}
					aNFItem[nItem][IT_VALIMP][nIV]	:=	aImposEIC[nX,9]
					aNFItem[nItem][IT_ALIQIMP][nIV]	:=	aImposEIC[nX,5]
					If cPaisLoc == "RUS"
						aNFItem[nItem][IT_BASEIMP_C1][nIV]	:=	xMoeda(aImposEIC[nX,7],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
						aNFItem[nItem][IT_VALIMP_C1][nIV]	:=	xMoeda(aImposEIC[nX,9],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
					EndIf
				Endif
			Next nX
		Endif
	Else
		If (cPaisLoc $ "ARG|RUS")
			If lTesMXF
				nPosTESM := Ascan(aTesMXF,{|X| X[1] == nItem})
				If nPosTESM > 0
					aTesMXF[nPosTESM][2] := aClone(aTes)
				Else
					AADD(aTesMXF,{nItem,aClone(aTes)})
				EndIf
			EndIf
		EndIf
		//Rotina que LIMPA os impostos calculados no Item,a TES pode ter sido alterada por outra.
		
			For nIV := 1 to NMAXIV
				If aNfItem[nItem][IT_DESCIV][nIV][3] == "T" .And. Ascan( aCalcular ,{ |x| Right(Alltrim(x[9]),1) == NumCpoImpVar( nIV ) } ) == 0 .And. !(cPaisLoc == "ARG" .And. aNfItem[nItem][IT_DESCIV][nIV][2] == "Dummy")
					Aadd(aCalcular,{"",aNfItem[nItem][IT_DESCIV][nIV][1],"","","","",0,aNfItem[nItem][IT_DESCIV][nIV][2],"D1_VALIMP"+NumCpoImpVar(nIV),"","","","","","","","","",aNfItem[nItem][IT_DESCIV][nIV][3],Nil,0,aNFItem[nItem][IT_ALIQIMP][nIV]} )
				Endif
				aNfItem[nItem][IT_DESCIV][nIV]	:=	{"","",""}
				aNFItem[nItem][IT_BASEIMP][nIV]	:=	0
				aNFItem[nItem][IT_VALIMP][nIV]	:=	0
				aNFItem[nItem][IT_ALIQIMP][nIV]	:=	0

				Aadd( aCposArred , "IT_BASEIV"+NumCpoImpVar(nIV) )
				Aadd( aCposArred , "IT_VALIV"+NumCpoImpVar(nIV)  )
				If 	cPaisLoc == "RUS" .AND. !("_C1" $ cCampo) .AND. !IsInCallStack("__MODXOK")
					aNFItem[nItem][IT_BASEIMP_C1][nIV]	:=	0
					aNFItem[nItem][IT_VALIMP_C1][nIV]	:=	0
				ElseIf cPaisLoc == "RUS"
					Aadd( aCposArred , "IT_BASEIV"+NumCpoImpVar(nIV)+"_C1")
					Aadd( aCposArred , "IT_VALIV"+NumCpoImpVar(nIV)+"_C1" )
				EndIF
			Next nIV
		
		If cPaisLoc == "ARG" .and. aNfItem[nItem][IT_DELETED] .and. ((CCO->(FieldPos("CCO_IMMINR")) > 0 .and. ALLTRIM(aNfItem[nItem][IT_TES]) $ SuperGetMV("MV_IBIMPOR",.T.,"")) .or. ASCAN(aCalcular,{|X|SUBSTR(X[2],1,2) $ "IB"}) > 0)
			SFC->(DbSetOrder(2))
			SFB->(DbSetOrder(1))
			SFC->(dbSeek(XFILIAL("SFC")+aNfItem[nItem][IT_TES]))
			Do While !SFC->(eof()) .and. aNfItem[nItem][IT_TES]==SFC->FC_TES
				If SFB->(dbSeek(XFILIAL("SFB")+SFC->FC_IMPOSTO))
					If sfb->fb_classif=='1'
						lPasaIB := .T.
						Exit
					EndIf
				EndIf
				SFC->(DBSKIP())
			EndDo
			SFC->(DbSetOrder(nOrdSFC))
			RestArea(aAreaSFC)
			RestArea(aAreaSFB)
		Endif
		//Rotina principal que dispara o calculo de TODOS o impostos variaveis localizados.
		If Len(aCalcular) > 0 .And. (!aNfItem[nItem][IT_DELETED] .or. lPasaIB == .T.) .AND. lTESMIZero

			If AllTrim(Upper(FunName())) == "LOJA701" //SIGALOJA
				//Verifica qual eh o ultimo item valido que nao esta deletado
				nCountIT := Len(aNfItem)
				While nCountIT >= 1
					If !aNfItem[nCountIT][IT_DELETED]
						nUltItem := nCountIT
						Exit
					EndIf
					nCountIT--
				End
			EndIf

			For nIV := 1 To Len(aCalcular)
				If aCalcular[nIV][SFC_CALCULO] <> "T"
					MaFisCalcIV(nIV,nItem, .F., Iif(cPaisLoc == "RUS",cCampo,Nil))
					MaFisAliqIV(nIV,nItem)
					MaFisVLIV(nIV,nItem, Iif(cPaisLoc == "RUS",cCampo,Nil))
				Else
					If Len(aCalcular[nIV]) < 22
						MaFisCalcIV(nIV,nItem, .T., Iif(cPaisLoc == "RUS",cCampo,Nil))
						MaFisAliqIV(nIV,nItem)
					EndIf
					cNumCpo := Right(Alltrim(aCalcular[nIV][SFB_CPOVREI]),1)
					nNumCpo := NumCpoImpVar( cNumCpo )
					If Len(aCalcular[nIV]) < 22
						nImpAnt  := MaFisRet(nItem,"IT_VALIV" + cNumCpo)
						MaFisVLIV(nIV,nItem, Iif(cPaisLoc == "RUS",cCampo,Nil))
						nValorIV := MaFisRet(nItem,"IT_VALIV" + cNumCpo)
						nAliquota:= MaFisRet(nItem,"IT_ALIQIV"+ cNumCpo)
					Else
						If MaFisRet(,"NF_BASEIV"+cNumCpo) < MaFisRet(,"NF_MINIV"+cNumCpo)
							nBaseIV	 := 0
							nValorIV := 0
						Else
							nBaseIV  := MaFisRet(,"NF_BASEIV"+cNumCpo)
							nValorIV :=	MaFisRet(,"NF_VALIV"+cNumCpo)
						Endif
						nAliquota := aCalcular[nIV][22]
					EndIf

					If Left(aCalcular[nIV][2],2) == "IB" .And. aNFCab[NF_TPCLIFOR] != "F" .And. ( Isincallstack('Lj7DescPro') .Or. Isincallstack("Lj7ZeraDesc") .Or. Isincallstack("Lj7LimpDes") ) //.Or. Isincallstack("LjTelaCard")
						If nItem == nUltItem
							lLojaIb:= .T.
						Else
							lLojaIb:= .F.
						EndIf
					Else
						lLojaIb:= .T.
					EndIf

					If lLojaIb .And. lExecuta .And. !( Alltrim(cCampo) $  "PRODUTO|QUANT|PRCUNI" ) .And. aNfItem[nItem][IT_VALMERC] > 0 .And. ;
						( ( Len(aCalcular[nIV])  < 22 .And. ( Round(nValorIV,3) > 0 .Or. ;
						( IF(Left(aCalcular[nIV][2],2) == "IB" .And. aNFCab[NF_TPCLIFOR] != "F",.T.,nImpAnt > 0) .And. Round(nValorIV,3) == 0) ) ) .Or. ;
						( Len(aCalcular[nIV]) == 22 .And. nBaseIV > 0 ) ) .and. lCalcTot
						
						nBseRateio  := 0
						nBseRateado := 0
						nVlrRateado := 0
						aEval(aNfItem,{|x| nBseRateio += IIf( !x[IT_DELETED] .And. x[IT_ALIQIMP][nNumCpo] == nAliquota  , x[IT_BASEIMP][nNumCpo] , 0 ) } )

						For nX := 1 to Len(aNfItem)
							If !aNfItem[nX][IT_DELETED]
								If aNfItem[nX][IT_TES] <> aTes[TS_CODIGO]
									If (cPaisLoc $ "ARG|RUS") .and. lTesMXF
										nPosTESM := Ascan(aTesMXF,{|X| X[1] == nX})
										If nPosTESM > 0
											aTes := aClone(aTesMXF[nPosTESM][2])
										Else
											MaFisTes(aNfItem[nX][IT_TES],aNfItem[nX][IT_RECNOSF4],nX)
											AADD(aTesMXF,{nX,aClone(aTes)})
										EndIf
									Else
										MaFisTes(aNfItem[nX][IT_TES],aNfItem[nX][IT_RECNOSF4],nX)
									EndIf
								EndIf

								nFator := aNFItem[nX][IT_BASEIMP][nNumCpo] / nBseRateio

								If aNFItem[nX][IT_ALIQIMP][nNumCpo] == nAliquota
									If nX <> nItem .or. (nModulo == 12 .and. Left(aCalcular[nIV][2],2) =="IB" .and.!Isincallstack('mata465n'))
										If !lArgSal
											aNfCab[NF_DESCONTO]	-= aNfItem[nX][IT_DESCONTO]
											aNfCab[NF_FRETE]	-= aNfItem[nX][IT_FRETE]
											aNfCab[NF_DESPESA]	-= aNfItem[nX][IT_DESPESA]
											aNfCab[NF_SEGURO]	-= aNfItem[nX][IT_SEGURO]
											aNfCab[NF_VALEMB]	-= aNfItem[nX][IT_VALEMB]
											aNfCab[NF_TOTAL]	-= aNfItem[nX][IT_TOTAL]
											aNfCab[NF_VALMERC]	-= aNfItem[nX][IT_VALMERC]-aNfItem[nX][IT_VNAGREG]
											If cPaisLoc == "RUS"
												aNfCab[NF_TOTAL_C1]	-= aNfItem[nX][IT_TOTAL_C1]
												aNfCab[NF_VALMERC_C1]	-= aNfItem[nX][IT_VALMERC_C1] - xMoeda(aNfItem[nX][IT_VNAGREG],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
											EndIf
											aNfCab[NF_VNAGREG] 	-= aNfItem[nX][IT_VNAGREG]
											aNfCab[NF_BASEDUP]	-= aNfItem[nX][IT_BASEDUP]
											aNfCab[NF_PESO]		-= aNfItem[nX][IT_PESO]
											aNFCab[NF_ADIANT]	-= aNfItem[nX][IT_ADIANT]
											aNfCab[NF_DESCTOT]  -= aNfItem[nX][IT_DESCTOT]
											aNfCab[NF_ACRESCI]	-= aNfItem[nX][IT_ACRESCI]
											aNfCab[NF_VLR_FRT]	-= aNfItem[nX][IT_VLR_FRT]
											aNfCab[NF_DESNTRB]	-= aNfItem[nX][IT_DESNTRB]
											aNfCab[NF_TARA]		-= aNfItem[nX][IT_TARA]
											If cPaisLoc == "PER" .and. fisExtCmp('12.1.2310', .T.,'SF1','F1_ADIANT')
												aNfCab[NF_ADIANTTOT]	-= aNfItem[nX][IT_ADIANTTOT]
											EndIf
											For nG := 1 To NMAXIV
												aNfCab[NF_BASEIMP][nG] -= aNfItem[nX][IT_BASEIMP][nG]
												aNfCab[NF_VALIMP][nG]  -= aNfItem[nX][IT_VALIMP][nG]
												aNfCab[NF_VLRORIG][nG] -= aNfItem[nX][IT_VALIMP][nG]
												If cPaisLoc == "RUS"
													aNfCab[NF_BASEIMP_C1][nG] -= aNfItem[nX][IT_BASEIMP_C1][nG]
													aNfCab[NF_VALIMP_C1][nG]  -= aNfItem[nX][IT_VALIMP_C1][nG]
												EndIf
												If aNfItem[nX][IT_BASEIMP][nG]<>0 .Or. aNfItem[nX][IT_VALIMP][nG] <> 0
													MaFisResumo(aNfItem[nX][IT_BASEIMP][nG],aNfItem[nX][IT_ALIQIMP][nG],aNfItem[nX][IT_VALIMP][nG],aNfItem[nX][IT_DESCIV][nG][1],aNfItem[nX][IT_DESCIV][nG][2],"IV"+NumCpoImpVar(nG),,,.F.)
												EndIf
											Next nG
										EndIf
										If nIV == Len(aCalcular)
											If !(cPaisLoc == "ARG" .and. (lArgSal .Or. lLivFisARG))
												MaFisLFToLivro(nX,@aAuxOri,.F.)
											Endif
											For nZ := 1 to Len(aCposArred)  // Executa a correcao nos arredondamentos.
												If oCposArred:HasProperty(aCposArred[nZ])
													nY := oCposArred[aCposArred[nZ]]
												Else
													nY := aScan( aItemRef , {|x| x[1] == aCposArred[nZ]} )
													oCposArred[aCposArred[nZ]] := nY
												EndIf
												If aItemRef[nY][4]
													If !aItemRef[nY][5]
														If ValType(aItemRef[nY][2]) == "A"
															aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += aItemDec[nX][2][nY]
															aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] -= aItemDec[nX][1][nY]
														Else
															aNfItem[nX][Val(aItemRef[nY][2])] += aItemDec[nX][2][nY]
															aNfItem[nX][Val(aItemRef[nY][2])] -= aItemDec[nX][1][nY]
														EndIf
														aSaveDec[nY] += aItemDec[nX][1][nY]
														aSaveDec[nY] -= aItemDec[nX][2][nY]
													Else
														If ValType(aItemRef[nY][2]) == "A"
															aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] -= aItemDec[nX][2][nY]
															aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += aItemDec[nX][1][nY]
														Else
															aNfItem[nX][Val(aItemRef[nY][2])] -= aItemDec[nX][2][nY]
															aNfItem[nX][Val(aItemRef[nY][2])] += aItemDec[nX][1][nY]
														EndIf
													EndIf
													aItemDec[nX][1][nY]:= 0
													aItemDec[nX][2][nY]:= 0
												EndIf
											Next nZ
										EndIf
									Endif

									If nBaseIV > 0
										nPosItRef   := Ascan(aItemRef,{|x| x[1] == "IT_BASEIV"+cNumCpo })
										nBseRateado += aNFItem[nX][IT_BASEIMP][nNumCpo] := IIf( aItemRef[nPosItRef][4] .And. aItemRef[nPosItRef][5] , NoRound( nFator * nBaseIV , 2 ) , IIf(cPaisLoc$"PAR/PER",NoRound(nFator*nBaseIV,nDecimais) , nFator * nBaseIV )  )
									EndIf
									nPosItRef   := Ascan(aItemRef,{|x| x[1] == "IT_VALIV"+cNumCpo })
									If (cPaisLoc $ "ARG|RUS")
										aNFItem[nX][IT_TOTAL] -= aNFItem[nX][IT_VALIMP][nNumCpo]
										If cPaisLoc == "ARG" .and. aTes[TS_DUPLIC] <> "N"
											aNFItem[nX][IT_BASEDUP] -= aNFItem[nX][IT_VALIMP][nNumCpo]
										EndIf
									EndIf
									nVlrRateado += aNFItem[nX][IT_VALIMP][nNumCpo] := IIf( aItemRef[nPosItRef][4] .And. aItemRef[nPosItRef][5] , NoRound( nFator * nValorIV , 2 ) , IIf(cPaisLoc$"PAR/PER",NoRound(nFator*nValorIV,nDecimais) , IIf(cPaisLoc$"ARG|EQU|COL",Round(nFator*nValorIV,nDecimais),nFator * nValorIV))  )
									If (cPaisLoc == "RUS") .Or. (cPaisLoc == "ARG" .And. nBaseIV == 0)
										aNFItem[nX][IT_TOTAL] += aNFItem[nX][IT_VALIMP][nNumCpo]
										If cPaisLoc == "ARG" .and. aTes[TS_DUPLIC] <> "N"
											aNFItem[nX][IT_BASEDUP] += aNFItem[nX][IT_VALIMP][nNumCpo]
										EndIf
									EndIf
								EndIf
								If Len(aNfItem) == nX
									If cPaisLoc $ "COL"
										lSFC := Len(aTes[TS_SFC]) > 0
									EndIf
									If nBaseIV > 0 .And. nBaseIV <> nBseRateado .And. lSFC
										aNfItem[Len(aNfItem)][IT_BASEIMP][nNumCpo]+= (nBaseIV-nBseRateado)
									EndIf
									If nValorIV <> nVlrRateado .And. lSFC .And. !cPaisLoc $  "EQU|COL"
										aNfItem[Len(aNfItem)][IT_VALIMP][nNumCpo] += (nValorIV-nVlrRateado)
										If cpaisLoc == "RUS"
											aNfItem[Len(aNfItem)][IT_VALIMP_C1][nNumCpo] += xMoeda((nValorIV-nVlrRateado),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
										EndIf
									EndIf
									If lRatImpIt .And. nValorIV <> nVlrRateado .And. lSFC
										RatImpItem(@aNfItem, nValorIV, nVlrRateado, nDecimais, nAliquota, nNumCpo)
									EndIf
								EndIf
								If nX <> nItem // nItemNao
									If nBaseIV > 0
										MaFisVLIV(Ascan(aTes[TS_SFC],{|x| Substr(x[10],10,1) ==  cNumCpo }) , nX )
										If (nfator<>0) .AND. ((cPaisLoc $ "ARG|RUS"))
											IF cPaisLoc == "ARG"
												aNFItem[nX][IT_BASEDUP] -= aNFItem[nX][IT_VALIMP][nNumCpo]
												aNFItem[nX][IT_TOTAL] -= aNFItem[nX][IT_VALIMP][nNumCpo]
											EndIf 
											aNfItem[nX][IT_VALIMP][nNumCpo] := aNfItem[nX][IT_VALIMP][nNumCpo] * nFator
											IF cPaisLoc == "ARG"
												aNFItem[nX][IT_BASEDUP] += aNFItem[nX][IT_VALIMP][nNumCpo]
												aNFItem[nX][IT_TOTAL] += aNFItem[nX][IT_VALIMP][nNumCpo]
											EndIf 
										EndIf
									EndIf
									If cPaisLoc<> "ARG" .And. nIV == Len(aCalcular)
										MaFisVTot(nX)     // tem o len do aTES
										MaItArred(nX,aCposArred)
									EndIf

								EndIf
								If cPaisLoc == "COL" .Or. (cPaisLoc=="ARG" .and. nIV == Len(aCalcular) .and. IIF(lArgSal, nX == Len(aNfItem),.T.))
									MaFisVTot(nX)     // tem o len do aTES
									MaItArred(nX,aCposArred)
								EndIf
							EndIf

						Next nX

						If lRefazNFCab .and. IIF(lArgSal, nIV == Len(aCalcular),.T.)
							aAuxOri := {}
							aNfCab[NF_LIVRO]	:= {}
							aNfCab[NF_IMPOSTOS]	:= {}
							aNfCab[NF_IMPOSTOS2]:= {}
							aNfCab[NF_DESCONTO]	:= 0
							aNfCab[NF_DESCTOT]	:= 0
							aNfCab[NF_ACRESCI]	:= 0
							aNfCab[NF_FRETE]	:= 0
							aNfCab[NF_DESPESA]	:= 0
							aNfCab[NF_SEGURO]	:= 0
							aNfCab[NF_VALEMB]	:= 0
							aNfCab[NF_TOTAL]	:= 0
							aNfCab[NF_VALMERC]	:= 0
							aNfCab[NF_VNAGREG]  := 0
							aNfCab[NF_BASEDUP]	:= 0
							aNfCab[NF_PESO]		:= 0
							aNfCab[NF_VLR_FRT]  := 0
							aNfCab[NF_DESNTRB]  := 0
							aNfCab[NF_ADIANT]   := 0
							aNfCab[NF_BASEIMP]	:= Array(NMAXIV)
							aNfCab[NF_BASEIMP]	:= Afill(aNfCab[NF_BASEIMP],0)
							aNfCab[NF_VALIMP]	:= Array(NMAXIV)
							aNfCab[NF_VALIMP]	:= Afill(aNfCab[NF_VALIMP],0)
							If cPaisLoc == "RUS"
								aNfCab[NF_TOTAL_C1]	:= 0
								aNfCab[NF_VALMERC_C1]	:= 0
								aNfCab[NF_BASEIMP_C1]	:= Array(NMAXIV)
								aNfCab[NF_BASEIMP_C1]	:= Afill(aNfCab[NF_BASEIMP_C1],0)
								aNfCab[NF_VALIMP_C1]	:= Array(NMAXIV)
								aNfCab[NF_VALIMP_C1]	:= Afill(aNfCab[NF_VALIMP_C1],0)
							EndIf
							aNfCab[NF_MINIMP]	:= Array(NMAXIV)
							aNfCab[NF_MINIMP]	:= Afill(aNfCab[NF_MINIMP],0)
							aNfCab[NF_VLRORIG]	:= Array(NMAXIV)
							aNfCab[NF_VLRORIG]	:= Afill(aNfCab[NF_VLRORIG],0)
							If cPaisLoc == "PER" .and. fisExtCmp('12.1.2310', .T.,'SF1','F1_ADIANT')
								aNfCab[NF_ADIANTTOT]   := 0
							EndIf
							For nX := 1 to Len(aNfItem)
								If nItem <> nX  .Or. lDespesas .or. (nModulo == 12 .and. Left(aCalcular[nIV][2],2) =="IB" .and. !Isincallstack('mata465n'))
									If !aNfItem[nX][IT_DELETED]
										aNfCab[NF_DESCONTO]+= aNfItem[nX][IT_DESCONTO]
										aNfCab[NF_FRETE]   += aNfItem[nX][IT_FRETE]
										aNfCab[NF_DESPESA] += aNfItem[nX][IT_DESPESA]
										aNfCab[NF_SEGURO]  += aNfItem[nX][IT_SEGURO]
										aNfCab[NF_VALEMB]  += aNfItem[nX][IT_VALEMB]
										aNfCab[NF_TOTAL]   += aNfItem[nX][IT_TOTAL]
										aNfCab[NF_VALMERC] += aNfItem[nX][IT_VALMERC]-aNfItem[nX][IT_VNAGREG]
										If cPaisLoc == "RUS"
											aNfCab[NF_TOTAL_C1]   += aNfItem[nX][IT_TOTAL_C1]
											aNfCab[NF_VALMERC_C1] += aNfItem[nX][IT_VALMERC_C1]-xMoeda(aNfItem[nX][IT_VNAGREG],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
										EndIf
										aNfCab[NF_VNAGREG] += aNfItem[nX][IT_VNAGREG]
										aNfCab[NF_BASEDUP] += aNfItem[nX][IT_BASEDUP]
										aNfCab[NF_PESO]	   += aNfItem[nX][IT_PESO]
										aNfCab[NF_ADIANT]  += aNfItem[nX][IT_ADIANT]
										aNfCab[NF_DESCTOT] += aNfItem[nX][IT_DESCTOT]
										aNfCab[NF_ACRESCI] += aNfItem[nX][IT_ACRESCI]
										aNfCab[NF_VLR_FRT] += aNfItem[nX][IT_VLR_FRT]
										aNfCab[NF_DESNTRB] += aNfItem[nX][IT_DESNTRB]
										aNfCab[NF_TARA]	   += aNfItem[nX][IT_TARA]

										If cPaisLoc == "PER" .and. fisExtCmp('12.1.2310', .T.,'SF1','F1_ADIANT')
											aNfCab[NF_ADIANTTOT]  += aNfItem[nX][IT_ADIANTTOT]
										EndIF
										For nG := 1 To NMAXIV
											aNfCab[NF_BASEIMP][nG]+= aNfItem[nX][IT_BASEIMP][nG]
											aNfCab[NF_VALIMP][nG] += aNfItem[nX][IT_VALIMP][nG]
											aNfCab[NF_VLRORIG][nG]+= aNfItem[nX][IT_VALIMP][nG]
											If cPaisLoc == "RUS"
												aNfCab[NF_BASEIMP_C1][nG]+= aNfItem[nX][IT_BASEIMP_C1][nG]
												aNfCab[NF_VALIMP_C1][nG] += aNfItem[nX][IT_VALIMP_C1][nG]
											EndIf
											If aNfItem[nX][IT_BASEIMP][nG]<>0 .Or. aNfItem[nX][IT_VALIMP][nG] <> 0
												MaFisResumo(aNfItem[nX][IT_BASEIMP][nG],aNfItem[nX][IT_ALIQIMP][nG],aNfItem[nX][IT_VALIMP][nG],aNfItem[nX][IT_DESCIV][nG][1],aNfItem[nX][IT_DESCIV][nG][2],"IV"+NumCpoImpVar(nG),,,.T.)
											EndIf
										Next nG
										If nIV == Len(aCalcular) .And. !lLivFisARG
											MaFisLFToLivro(nX,@aAuxOri,.T.)
										EndIf
									EndIf
								Endif
							Next nX

						EndIf

						If aNfItem[nItem][IT_TES] <> aTes[TS_CODIGO]
							If (cPaisLoc $ "ARG|RUS")
								If lTesMXF
									nPosTESM := Ascan(aTesMXF,{|X| X[1] == nItem})
								EndIf
								If nPosTESM > 0
									aTes := aClone(aTesMXF[nPosTESM][2])
								Else
									MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
									If Type("aTesMXF") <> "U" .and. nPosTESM == 0
										AADD(aTesMXF,{nItem,aClone(aTes)})
									EndIf
								EndIf
							Else
								MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
							EndIf
						EndIf
					Endif
					lTESxTotal := .T.
				EndIf
			Next nIV
			/*Genera libro fiscal Argentina*/
			If lLivFisARG .And. lTESxTotal .and. IIF(lArgSal, nX == Len(aNfItem),.T.)
				aNfCab[NF_LIVRO]	:= {}
				For nX := 1 To Len(aNfItem)
					If !aNfItem[nX][IT_DELETED] .And. nItem <> nX
						MaFisLFToLivro(nX,@aAuxOri,.T.)
					EndIf
				Next nX
				If aNfItem[nItem][IT_TES] <> aTes[TS_CODIGO]
					If lTesMXF
						nPosTESM := Ascan(aTesMXF,{|X| X[1] == nItem})
					EndIf
					If nPosTESM > 0
						aTes := aClone(aTesMXF[nPosTESM][2])
					Else
						MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
Return
/*
MaRetIncIV - Leandro C.G. - Data   14/01/02
Retorna valores de impostos referentes a um item de NF que incidem no custo, Duplicata, ou Nota
Parametros:
nItem	- Numero do item da Nota Fiscal
cOpc	- 1- Custo 2- Nota 3- Duplicata
Obs.: Considera que o arquivo de itens da Nota Fiscal ja esta posicionado no registro correto e que
as variaveis de calculo de impostos do programa MatxFis ja estao inicializadas
*/
Function MaRetIncIV(nItem,cOpc)

Local aDescImp 	:=	{}	//Descricao/Codigo de todos os impostos que incidem no item
Local aValImp	:=	{}	//Array com os valores de todos os impostos que incidem no item
Local nImposVar	:=	0	//Valor dos impostos variaveis que incidem no custo
Local aSFC		:=	{} //Array com as propriedades dos impostos do item
Local aRet 		:= {} //Array com os impostos e valores que sao somados ou subtraidos no custo
/*						[1] - Codigo do imposto
[2] - Valor positivio (quando imposto e creditado) e negativo (+/-)
*/
Local nI		:=	0	//controle de loop
//Consistindo parametros
If Empty(nItem)
	Return( 0 )
EndIf

If aNfItem[nItem][IT_TES] <> aTes[TS_CODIGO]
	MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
EndIf

aSFC	 :=	aClone(aTes[TS_SFC])

aDescImp :=	aNFItem[nItem,IT_DESCIV]		//Descricao/Codigo dos impostos
aValImp  :=	aNFItem[nItem,IT_VALIMP]		//Valor dos Impostos

//Buscando valores referentes aos impostos
For nI := 1 to Len(aSFC)
	nPosImp	:=	Ascan(aDescImp,{|x| x[1] == aSFC[nI][SFC_IMPOSTO]})
	If nPosImp > 0
		Do Case
			Case cOpc == '1'
				If aSFC[nI][SFC_CREDITA] <> '3'
					nImposVar	:=	aValImp[nPosImp] * If(aSFC[nI][SFC_CREDITA] == '1', 1 , -1)
					Aadd(aRet, {aSFC[nI][SFC_IMPOSTO], nImposVar})
				Endif
			Case cOpc == '2'
				If aSFC[nI][SFC_INCNOTA] <> '3'
					nImposVar	+=	aValImp[nPosImp] * If(aSFC[nI][SFC_INCNOTA] == '1', 1 , -1)
				Endif
			Case cOpc == '3'
				If aSFC[nI][SFC_INCDUPL] <> '3'
					nImposVar	+=	aValImp[nPosImp] * If(aSFC[nI][SFC_INCDUPL] == '1', 1 , -1)
				Endif
		EndCase
	Endif
Next nI

Return(IIf(cOpc=="1",aRet,nImposVar))

/*
MaFisCalcIV - 03.04.2009
Executa o calculo do Valor dos Impostos Variaveis
Parametros
ExpN1: Numero do Imposto ( 1 a X )
ExpN2: Item a ser calculado
/*/
Static Function MaFisCalcIV(nImposto,nItem,lImpTot,cCampo)
Local lRet		:= .T.
Local nValImp	:= 0
Local nImp		:=Len(aTes[TS_SFC])
Local nImpde	:=IIF(nImposto==Nil,1,nImposto)
Local nImpAte	:=IIF(nImposto==Nil,nImp,nImposto)
Local xImposto
Local nMv_ALQIPM	:= fisGetParam('MV_ALQIPM',0)
Local cMV_AGENTE  	:= fisGetParam('MV_AGENTE',"   ")
Local alAreaX
Local alAreaY
Local alAreaZ
Local nlTotal    := 0
Local nlMinDIG   	:= fisGetParam('MV_MINDETR',0)
Local nCpoIPM    := 3
Local lFnTpDig:= cPaisLoc == "PER" .AND. ((((funname() == "MATA101N") .Or. (fisFindFunc("ChkLxProp") .and. ChkLxProp("xFisValidaDetraccion"))) .AND. aNfCab[NF_TIPODOC] == "10") .OR. funname() == "MATA121") .AND. FindFunction("LxPerTpDIG") 
Local lTpDig := .F.
Local aTaxKey := IIf(lVldCalImp, fGetTaxKey(nItem), Array(2))

Default cCampo	:= ""
Private aInfo  //Definida como private pois é usada numa macro
// Verifica se a TES possui tratamento para Impostos Variaveis
If cPaisLoc=="PER"  .And. fisExtCmp('12.1.2310', .T.,'SB1','B1_VMINDET')
	nlMinDIG := Iif( aNfItem[nItem][IT_PRD][SB_VMINDET] > 0 , aNfItem[nItem][IT_PRD][SB_VMINDET] , nlMinDIG )
EndIf

If cPaisLoc == "BRA" .Or. lNotRemito
	If !Empty(aTes[TS_SFC])
		If nImpde>0 .And. nImpAte>0
			nImposto := nImpDe
			While (nImposto <= nImpAte) .And. lRet

				If cPaisLoc $ "PER"
					alAreaX := SFC->(GetArea())
					alAreaY := SF4->(GetArea())
					alAreaZ := GetArea()
					lTpDig := .F.
					If lFnTpDig 
						lTpDig := LxPerTpDIG(aTes[TS_SFC][nImposto][SFC_IMPOSTO])
					EndIF

					If aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "IGV"
						DbSelectArea("SF4")
						DbSetOrder(1)
						// VERIFICAR A NECESSIDADE DESTE SEEK -> POIS AQUI UTILIZA A REFERENCIA aTes[TS_CODIGO] para posicionar na SF4
						If MsSeek(xFilial("SF4")+aTes[TS_CODIGO])
							If (SF4->F4_CALCIGV <> "2" .And. SF4->F4_CALCIGV <> "3" .And. SF4->F4_CALCIGV <> "4")
								aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
								nImp:=NumCpoImpVar(aInfo[2])
								If aNfCab[NF_CPOIPM] <> 0
									nCpoIPM := aNfCab[NF_CPOIPM]
								EndIf
								If aNfCab[NF_ALQIPM] <> 0
									nMv_ALQIPM := aNfCab[NF_ALQIPM]
								EndIf
								If aNfCab[NF_OPERNF] == "E"
									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
										If lImpTot
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
										Else
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
										Endif
										If ValType(xImposto) == "A"
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
											aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]

											aNfItem[nItem][IT_BASEIMP][nCpoIPM] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nCpoIPM] := nMv_ALQIPM
											aNfItem[nItem][IT_VALIMP][nCpoIPM]  := xImposto[1]*(nMv_ALQIPM/100)
										Else
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto
											lRet := .F.
											If nMv_ALQIPM > 0 .And. aNfItem[nItem][IT_BASEIMP][nCpoIPM] == 0
												aNfItem[nItem][IT_BASEIMP][nCpoIPM] := xImposto
											EndIf
										EndIf
										aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
									EndIf
								Else
									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If lImpTot
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
										Else
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
										Endif
										If ValType(xImposto) == "A"
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
											aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]

											aNfItem[nItem][IT_BASEIMP][nCpoIPM] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nCpoIPM] := nMv_ALQIPM
											aNfItem[nItem][IT_VALIMP][nCpoIPM]  := xImposto[1]*(nMv_ALQIPM/100)
										Else
											aNfItem[nItem][IT_BASEIMP][nImp]:= xImposto
											lRet := .F.
											If nMv_ALQIPM > 0 .And. aNfItem[nItem][IT_BASEIMP][nCpoIPM] == 0
												aNfItem[nItem][IT_BASEIMP][nCpoIPM] := xImposto
											EndIf
										EndIf
										aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
									EndIf
								EndIf
								If lRet
									Do Case
										Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
											nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
										Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
											nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
										Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
											nValImp:=0
									EndCase
									aNfItem[nItem][IT_BASEDUP] += nValImp
									Do Case
										Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
											nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
										Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
											nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
										Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
											nValImp:=0
									EndCase
									aNfItem[nItem][IT_TOTAL] += nValImp
								Endif
							EndIf
						EndIf

					ElseIf aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "PIV"
						aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
						nImp:=NumCpoImpVar(aInfo[2])
						If aNfCab[NF_OPERNF] == "E"
							If aNfCab[NF_CLIFOR] $ "F"
								If SubStr(cMV_AGENTE,2,1) == "S" .And.  SA2->A2_AGENRET <> "1"
									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
										If lImpTot
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
										Else
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
										Endif
										If ValType(xImposto) == "A"
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
											aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
										Else
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto
											lRet := .F.
										EndIf
										aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
									EndIf
								EndIf
							ElseIf aNfCab[NF_CLIFOR] $ "C"

								If  SA1->A1_AGENTE == "2"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
										If lImpTot
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
										Else
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
										Endif
										If ValType(xImposto) == "A"
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
											aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
										Else
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto
											lRet := .F.
										EndIf
										aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
									EndIf
								EndIf
							EndIf

						Else
							If aNfCab[NF_CLIFOR] $ "C"
								If SA1->A1_AGENTE == "2"
									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If lImpTot
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
										Else
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
										Endif
										If ValType(xImposto) == "A"
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
											aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
										Else
											aNfItem[nItem][IT_BASEIMP][nImp]:= xImposto
											lRet := .F.
										EndIf
										aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
									EndIf

								EndIf
							ElseIf aNfCab[NF_CLIFOR] $ "F"
								If SubStr(cMV_AGENTE,2,1) == "S" .And.  SA2->A2_AGENRET <> "1"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If lImpTot
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
										Else
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
										Endif
										If ValType(xImposto) == "A"
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
											aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
										Else
											aNfItem[nItem][IT_BASEIMP][nImp]:= xImposto
											lRet := .F.
										EndIf
										aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
									EndIf
								EndIf
							EndIf
						EndIf
						If lRet
							Do Case
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
									nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
									nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
									nValImp:=0
							EndCase
							aNfItem[nItem][IT_BASEDUP] += nValImp
							Do Case
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
									nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
									nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
									nValImp:=0
							EndCase
							aNfItem[nItem][IT_TOTAL] += nValImp
						Endif

					ElseIf aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "DIG" .OR. lTpDig

						nlTotal := MaRetBasT(,,,.T.)

						nlTOtal += aNfCab[NF_FRETE] + aNfCab[NF_DESPESA] + aNfCab[NF_SEGURO] - (aNfCab[NF_DESCONTO]+aNfCab[NF_DESCTOT]) + aNfCab[NF_ACRESCI]

						If ((AllTrim(Upper(FunName())) $ "MATA465N/MATA466N/MATA467N/MATA101N/MATA121") .Or. (fisFindFunc("ChkLxProp") .and. ChkLxProp("xFisAplicaTasaPER"))) .And. aNFCab[NF_TXMOEDA] <> 0

							nlTotal := nlTotal * aNFCab[NF_TXMOEDA]

						ElseIf AllTrim(Upper(FunName())) $ "MATA410/OFIXA018/OFIXA011/OFIXA100"

							nlTotal := xMoeda(nlTotal,M->C5_MOEDA,1,dDataBase)

						EndIf
						If nlTotal > nlMinDIG

							If aNfCab[NF_RECIV]
								aNfCab[NF_RECIV] := .F.
								MaRecurDIG(.T., nItem)
							EndIf

							MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
							aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
							nImp:=NumCpoImpVar(aInfo[2])
							If aNfCab[NF_OPERNF] == "E"

								If aNfCab[NF_CLIFOR] $ "F"

									If SubStr(cMV_AGENTE,3,1) == "S"

										If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
											If lImpTot
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
											Else
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
											Endif
											If ValType(xImposto) == "A"
												aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
												aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
												aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
											Else
												aNfItem[nItem][IT_BASEIMP][nImp] := xImposto
												lRet := .F.
											EndIf
											aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
										EndIf

									EndIf

								ElseIf aNfCab[NF_CLIFOR] $ "C"

									If SubStr(cMV_AGENTE,1,1) == "N" .And.  SA1->A1_AGENTE == "3"

										If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
											If lImpTot
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
											Else
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
											Endif
											If ValType(xImposto) == "A"
												aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
												aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
												aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
											Else
												aNfItem[nItem][IT_BASEIMP][nImp] := xImposto
												lRet := .F.
											EndIf
											aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
										EndIf
									EndIf

								EndIf
							Else
								If aNfCab[NF_CLIFOR] $ "C"

									If SubStr(cMV_AGENTE,1,1) == "N" .And.  SA1->A1_AGENTE == "3"

										If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
											If lImpTot
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
											Else
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
											Endif
											If ValType(xImposto) == "A"
												aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
												aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
												aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
											Else
												aNfItem[nItem][IT_BASEIMP][nImp]:= xImposto
												lRet := .F.
											EndIf
											aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
										EndIf
									EndIf

								ElseIf aNfCab[NF_CLIFOR] $ "F"
									If SubStr(cMV_AGENTE,3,1) == "S" .And.  SA2->A2_AGENRET <> "1"
										If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
											If lImpTot
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
											Else
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
											Endif
											If ValType(xImposto) == "A"
												aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
												aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
												aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
											Else
												aNfItem[nItem][IT_BASEIMP][nImp]:= xImposto
												lRet := .F.
											EndIf
											aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
										EndIf
									EndIf
								EndIf
							EndIf
							If lRet
								Do Case
									Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
										nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
									Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
										nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
									Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
										nValImp:=0
								EndCase
								aNfItem[nItem][IT_BASEDUP] += nValImp
								Do Case
									Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
										nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
									Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
										nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
									Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
										nValImp:=0
								EndCase
								aNfItem[nItem][IT_TOTAL] += nValImp
							Endif
						Else
							aNfCab[NF_RECIV] := .T.
							MaRecurDIG(.F., nItem)
						EndIf
					Else
						aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
						nImp:=NumCpoImpVar(aInfo[2])
						If aNfCab[NF_OPERNF] == "E"
							If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
								If lImpTot
									xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
								Else
									xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
								Endif
								If ValType(xImposto) == "A"
									aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
									aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
									aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
								Else
									aNfItem[nItem][IT_BASEIMP][nImp] := xImposto
									lRet := .F.
								EndIf
								aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
							EndIf
						Else
							If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
								If lImpTot
									xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
								Else
									xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
								Endif
								If ValType(xImposto) == "A"
									aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
									aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
									aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
								Else
									aNfItem[nItem][IT_BASEIMP][nImp]:= xImposto
									lRet := .F.
								EndIf
								aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
							EndIf
						EndIf
						If lRet
							Do Case
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
									nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
									nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
									nValImp:=0
							EndCase
							aNfItem[nItem][IT_BASEDUP] += nValImp
							Do Case
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
									nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
									nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
									nValImp:=0
							EndCase
							aNfItem[nItem][IT_TOTAL] += nValImp
						Endif

					EndIf
					RestArea(alAreaX)
					RestArea(alAreaY)
					RestArea(alAreaZ)
				Else
					aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
					nImp:=NumCpoImpVar(aInfo[2])
					If aNfCab[NF_OPERNF] == "E"
						If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
							If lVldCalImp
								If fVldCalImp(aTes[TS_SFC][nImposto][SFB_FORMENT], aTaxKey, aInfo, aNfCab[NF_OPERNF])
									If lImpTot
										xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
									Else
										xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
									Endif
								EndIf
							Else
								If lImpTot
									xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
								Else
									xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
								Endif
							EndIf

							IF aNFitem[nItem][IT_TIPONF]$"DB" .AND. cPaisLoc == "PAR" .AND. fisGetParam('MV_DESCSAI',"")=='1' .AND. Alltrim(cFunName) == "MATA465N" .AND. ( aNFitem[nItem][IT_DESCONTO]>0  .OR.  aNFitem[nItem][IT_DESCTOT]>0 )
								xImposto += (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])
							EndIf

							If ValType(xImposto) == "A"
								aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
								aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
								aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
								If cPaisLoc == "RUS"
									aNfItem[nItem][IT_BASEIMP_C1][nImp] := Iif(!("_C1" $ cCampo) .AND. !IsInCallStack("__MODXOK"), xMoeda(xImposto[1],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA]),MaFisRet(nItem,"IT_BASEIV1_C1"))
									aNfItem[nItem][IT_VALIMP_C1][nImp] := Iif(!("_C1" $ cCampo) .AND. !IsInCallStack("__MODXOK"), xMoeda(xImposto[3],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA]),MaFisRet(nItem,"IT_VALIV1_C1"))
								EndIf
							Else
								aNfItem[nItem][IT_BASEIMP][nImp] := IIF(ValType(xImposto) == "U",0,xImposto)
								If cPaisLoc == "RUS"
									aNfItem[nItem][IT_BASEIMP_C1][nImp] := Iif(!("_C1" $ cCampo) .AND. !IsInCallStack("__MODXOK"), IIF(ValType(xImposto) == "U",0,xMoeda(xImposto,aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])),MaFisRet(nItem,"IT_BASEIV1_C1"))
								EndIf
								lRet := .F.
							EndIf
							aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
						EndIf
					Else
						If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
							If lVldCalImp
								If fVldCalImp(aTes[TS_SFC][nImposto][SFB_FORMSAI], aTaxKey, aInfo, aNfCab[NF_OPERNF])
									If lImpTot
										xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
									Else
										xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
									Endif
								EndIf							
							Else
								If lImpTot
									xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
								Else
									xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
								Endif
							EndIf
							If ValType(xImposto) == "A"
								aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
								aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
								aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
								//(08/05/18): if change coins manually get value in grid (only for Russian fields)
								If cPaisLoc == "RUS"
									aNfItem[nItem][IT_BASEIMP_C1][nImp] :=  Iif(!("_C1" $ cCampo) .AND. !IsInCallStack("__MODXOK"), xMoeda(xImposto[1],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA]),MaFisRet(nItem,"IT_BASEIV1_C1"))
									aNfItem[nItem][IT_VALIMP_C1][nImp] :=	Iif(!("_C1" $ cCampo) .AND. !IsInCallStack("__MODXOK"), xMoeda(xImposto[3],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA]),MaFisRet(nItem,"IT_VALIV1_C1"))
								EndIf
							Else
								aNfItem[nItem][IT_BASEIMP][nImp]:= IIF(ValType(xImposto) == "U",0,xImposto)
								//(08/05/18): if change coins manually get value in grid (only for Russian fields)
								If cPaisLoc == "RUS"
									aNfItem[nItem][IT_BASEIMP_C1][nImp] := Iif(!("_C1" $ cCampo) .AND. !IsInCallStack("__MODXOK"), IIF(ValType(xImposto) == "U",0,xMoeda(xImposto,aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])),MaFisRet(nItem,"IT_BASEIV1_C1"))
								EndIf
								lRet := .F.
							EndIf
							aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
						EndIf
					EndIf
					If lRet
						Do Case
							Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
								nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
								nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
								nValImp:=0
						EndCase
						aNfItem[nItem][IT_BASEDUP] += nValImp
						Do Case
							Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
								nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
								nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
								nValImp:=0
						EndCase
						aNfItem[nItem][IT_TOTAL] += nValImp
						//(08/05/18): if change coins manually get value in grid (only for Russian fields)
						If cPaisLoc == "RUS"
							aNfItem[nItem][IT_TOTAL_C1] += Iif(!("_C1" $ cCampo),xMoeda(nValImp,aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA]),MaFisRet(nItem,"IT_VALIV1_C1"))
						EndIf
					Endif
				EndIf
				nImposto++
			Enddo
		Endif
	Else
		For nImposto := 1 to NMAXIV
			aNFItem[nItem][IT_BASEIMP][nImposto] := 0
			aNfItem[nItem][IT_DESCIV][nImposto]	 := {"","",""}
			aNFItem[nItem][IT_VALIMP][nImposto]	 := 0
			aNFItem[nItem][IT_ALIQIMP][nImposto] := 0
			If cPaisLoc == "RUS"
				aNFItem[nItem][IT_BASEIMP_C1][nImposto] := 0
				aNFItem[nItem][IT_VALIMP_C1][nImposto]	 := 0
			EndIf
		Next nImposto
	EndIf
EndIf
Return(lRet)

/*
MaRetIncIV - Leandro C.G. - 14/01/02
Retorna valores de impostos referentes a um item de NF que incidem no custo, Duplicata, ou Nota
*/
Function NumCpoImpVar(xCpoLiv)
Local cCpo,xRet
cCpo:="123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
xRet:=0
If !Empty(xCpoLiv)
	If ValType(xCpoLiv)=="C"
		xRet:=At(xCpoLiv,cCpo)
	ElseIf ValType(xCpoLiv)=="N"
		If xCpoLiv>0
			xRet:=Substr(cCpo,xCpoLiv,1)
		Endif
	Endif
Endif
Return(xRet)

/*/
MaFisCalAl- Bruno Sobieski - 29.08.2003
Executa o calculo da Aliquota dos Impostos Variaveis
Esta funcao foi criada para nao tirar a propriedade de STATIC da funcao MAFISAliqIV
Parametros
ExpN1: Numero do Imposto ( 1 a 6 )
ExpN2: Item a ser calculado
*/
Function MaFisCalAl(nImposto,nItem)

MaFisAliqIV(nImposto,nItem)

Return

Function MAFisZero()
Return 0.0001

/*/
MaRetBasT - Bruno Sobieski -21.10.2004
Retorna a base total de um imposto, dependendo da aliquota
/*/
Function MaRetBasT(cNumImp,nItem,nAliq,llTot)
Local nBase	  :=	0
Local nX	  :=	0	//controle de loop
Local nY	  :=  0
Local lFnTpDig:= (cPaisLoc == "PER" .AND. ((((funname() == "MATA101N") .Or. (fisFindFunc("ChkLxProp") .and. ChkLxProp("xFisValidaDetraccion"))) .AND. aNfCab[NF_TIPODOC] == "10") .OR. funname() == "MATA121") .AND. FindFunction("LxPerTpDIG"))
Default llTot := .F.
//Local nPosImp	:=	aScan(aNfCab[NF_IMPOSTOS],{|x| x[IMP_COD] ==aDesc[1] .And.	x[IMP_ALIQ]==nAliq })

//nBase		:=	MaFisRet(nlcont,'IT_BASEIV'	+cNumImp)
If cPaisLoc == "BRA" .Or. lNotRemito
	For nX := 1 To Len(aNFItem)
		If !aNfItem[nX][IT_DELETED]
			/*Calcula o valor total da nota fiscal com os impostos de todos itens "PER"*/
			If llTot
				nBase += aNFItem[nX,IT_VALMERC]

				If aNfItem[nX][IT_TES] <> aNFItem[nX][IT_TS][TS_CODIGO]
					MaFisTes(aNfItem[nX][IT_TES],aNfItem[nX][IT_RECNOSF4],nX)
				EndIf

				For nY := 1 to Len(aNFItem[nX][IT_TS][TS_SFC])
					If aNFItem[nX][IT_TS][TS_SFC][nY][SFC_IMPOSTO] <> "DIG" .And. !IIF( lFnTpDig, LxPerTpDIG(aNFItem[nX][IT_TS][TS_SFC][nY][SFC_IMPOSTO]), .F.)
						nBase += MaFisRet(nX,'IT_VALIV'+ RIGHT(Alltrim(aNFItem[nX][IT_TS][TS_SFC][nY][SFB_CPOVREI]),1))
					EndIf
				Next nY
			Else
				If MaFisRet(nX,'IT_ALIQIV'+cNumImp) == nAliq
					nBase += MaFisRet(nX,'IT_BASEIV'+cNumImp)
				Endif
			EndIf

		Endif
	Next nX
EndIf
Return nBase

/*
MaRecurDIG - FELIPE V. NAMBARA      Data 25/11/2009
Calcula os valores dos impostos variaveis dos itens anteriores no caso da DETRAÇÃO DIG no localizado PERU
Parametros llFlag - Identifica se haverá ou não a recursão. nItem - Número de ítem
*/
Function MaRecurDIG(llFlag, nItem)
Local nlCont    := 1
Local nlCont2   := 1
Local nlCont3	:= 1
Local nlCont4   := 1
Local nG        := 0
Local nRs		:= 0
Local nRs2		:= 0
Local _IdxF3a   := 0
Local _IdxF3b   := 0
Local _IdxF3c   := 0
Local _IdxF3d   := 0
Local _IdxF3e   := 0
Local _IdxF3f   := 0
Local nlItens   := 0
Local nContador := 0
Local lFnTpDig	:= (cPaisLoc == "PER" .AND. ((((funname() == "MATA101N") .Or. (fisFindFunc("ChkLxProp") .and. ChkLxProp("xFisValidaDetraccion"))) .AND. aNfCab[NF_TIPODOC] == "10") .OR. funname() == "MATA121") .AND. FindFunction("LxPerTpDIG") )
Local nImp		:= 0
Local lRestado	:= .F.

Default nItem	:= 1

For nlCont4 := 1 To Len(aNfItem)
	If !aNfItem[nlCont4][IT_DELETED]
		nlItens++
	EndIf
Next nlCont4

If llFlag

	For nlCont := 1 To Len(aNfItem)
		If !aNfItem[nlCont][IT_DELETED] .And. nItem <> nlCont

			MaFisTes(aNfItem[nlCont][IT_TES],aNfItem[nlCont][IT_RECNOSF4],nlCont)

			If Len(aNFItem[nlCont][IT_TS][TS_SFC]) > 0
				lRestado := .F.

				For nlCont2 := 1 To Len(aNFItem[nlCont][IT_TS][TS_SFC])
					If (aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_IMPOSTO] $ "DIG" .Or. IIf(lFnTpDig, LxPerTpDIG(aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_IMPOSTO]), .F.)) .And. cPaisLoc <> "PER"
						nG := 0
						nImp:=NumCpoImpVar(RIGHT(Alltrim(aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFB_CPOVREI]) ,1))

						aNfCab[NF_BASEIMP][nImp] -= aNfItem[nlCont][IT_BASEIMP][nImp]
						aNfCab[NF_VALIMP][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]
						aNfCab[NF_VLRORIG][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]
						If cPaisLoc == "RUS"
							aNfCab[NF_BASEIMP_C1][nImp] -= aNfItem[nlCont][IT_BASEIMP_C1][nImp]
							aNfCab[NF_VALIMP_C1][nImp]  -= aNfItem[nlCont][IT_VALIMP_C1][nImp]
						EndIf
						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "1"
							aNfCab[NF_TOTAL]      -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							If cPaisLoc == "RUS"
								aNfCab[NF_TOTAL_C1]      -= xMoeda(aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
							EndIf
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "2"
							aNfCab[NF_TOTAL]      += aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							If cPaisLoc == "RUS"
								aNfCab[NF_TOTAL_C1]      += xMoeda(aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
							EndIf
						EndIf

						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "1"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][1]/100)
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "2"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][1]/100)
						EndIf

						aNfCab[NF_VALMERC]    -= aNfItem[nlCont][IT_VALMERC]
						If cPaisLoc == "RUS"
							aNfCab[NF_VALMERC_C1]    -= aNfItem[nlCont][IT_VALMERC_C1]
						EndIf
						nRS	 := aScan(aNfCab[NF_IMPOSTOS],{|x| (x[IMP_COD] == "DIG" .Or. IIf(lFnTpDig, LxPerTpDIG(x[IMP_COD]), .F.)) .AND. x[IMP_ALIQ] == aNfItem[nlCont][IT_ALIQIMP][nImp] })
						nRS2 := aScan(aNfCab[NF_IMPOSTOS2],{|x| x[IMP_COD] == "DIG"  .Or. IIf(lFnTpDig, LxPerTpDIG(x[IMP_COD]), .F.)})

						If nRs > 0
							aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS][nRS][IMP_VAL]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						If nRs2 > 0
							aNfCab[NF_IMPOSTOS2][nRS2][3] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS2][nRS2][4]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						_IdxF3a := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALCONT" } )
						_IdxF3b := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_BASIMP"+Alltrim(Str(nImp)) } )
						_IdxF3c := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALIMP"+Alltrim(Str(nImp)) } )
						_IdxF3f := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_TES" } )

						nContador:=nlCont3
						For nContador := 2 To Len(aNFCab[NF_LIVRO])
							nlCont3:=nContador
							If aNfCab[NF_LIVRO][nlCont3][_IdxF3f] $ aNfItem[nlCont][IT_TES]
								Exit
							EndIf
						Next

						If ValType(aNfItem[nlCont][IT_BASEIMP][nImp]) == "N" .And. ValType(aNfItem[nlCont][IT_ALIQIMP][nImp]) == "N"

							aNfCab[NF_LIVRO][nlCont3][_IdxF3a] -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							aNfCab[NF_LIVRO][nlCont3][_IdxF3b] -= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_LIVRO][nlCont3][_IdxF3c] -= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf
						//Recalcula o imposto DIG para todos os itens anteriores
						If !MaFisCalcIV(nlCont2,nlCont,(nG>0))

							MaFisAliqIV(nlCont2,nlCont)

							If nG == 0
								MaFisVLIV(nlCont2,nlCont)
							Endif
						Endif
					ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_IMPOSTO] $ "ISC" .And. cPaisLoc <> "PER"

						nImp:=NumCpoImpVar(RIGHT(Alltrim(aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFB_CPOVREI]),1 ))

						aNfCab[NF_BASEIMP][nImp] -= aNfItem[nlCont][IT_BASEIMP][nImp]
						aNfCab[NF_VALIMP][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]
						aNfCab[NF_VLRORIG][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]
						If cPaisLoc == "RUS"
							aNfCab[NF_BASEIMP_C1][nImp] -= aNfItem[nlCont][IT_BASEIMP_C1][nImp]
							aNfCab[NF_VALIMP_C1][nImp]  -= aNfItem[nlCont][IT_VALIMP_C1][nImp]
						EndIf
						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "1"
							aNfCab[NF_TOTAL]      -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							If cPaisLoc == "RUS"
								aNfCab[NF_TOTAL_C1]      -= xMoeda(aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
							EndIf
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "2"
							aNfCab[NF_TOTAL]      += aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							If cPaisLoc == "RUS"
								aNfCab[NF_TOTAL_C1]      += xMoeda(aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
							EndIf
						EndIf

						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "1"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "2"
							aNfCab[NF_BASEDUP]    += aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						EndIf

						aNfCab[NF_VALMERC]    -= aNfItem[nlCont][IT_VALMERC]
						If cPaisLoc == "RUS"
							aNfCab[NF_VALMERC_C1]    -= aNfItem[nlCont][IT_VALMERC_C1]
						EndIf
						nRS	 := aScan(aNfCab[NF_IMPOSTOS],{|x| x[IMP_COD] == "ISC" .And. x[IMP_ALIQ] == aNfItem[nlCont][IT_ALIQIMP][nImp] })
						nRS2 := aScan(aNfCab[NF_IMPOSTOS2],{|x| x[IMP_COD] == "ISC" })

						If nRs > 0
							aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS][nRS][IMP_VAL]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						If nRs2 > 0
							aNfCab[NF_IMPOSTOS2][nRS2][3] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS2][nRS2][4]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						_IdxF3a := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALCONT" } )
						_IdxF3b := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_BASIMP"+Alltrim(Str(nImp)) } )
						_IdxF3c := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALIMP"+Alltrim(Str(nImp)) } )
						_IdxF3f := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_TES" } )

						nContador:=nlCont3
						For nContador := 2 To Len(aNFCab[NF_LIVRO])
							nlCont3:=nContador
							If aNfCab[NF_LIVRO][nlCont3][_IdxF3f] $ aNfItem[nlCont][IT_TES]
								Exit
							EndIf
						Next

						If ValType(aNfItem[nlCont][IT_BASEIMP][nImp]) == "N" .And. ValType(aNfItem[nlCont][IT_ALIQIMP][nImp]) == "N"

							aNfCab[NF_LIVRO][nlCont3][_IdxF3a] -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							aNfCab[NF_LIVRO][nlCont3][_IdxF3b] -= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_LIVRO][nlCont3][_IdxF3c] -= aNfItem[nlCont][IT_VALIMP][nImp]

						EndIf

					ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_IMPOSTO] $ "IGV" .And. cPaisLoc <> "PER"

						nImp:=NumCpoImpVar( RIGHT ( Alltrim(aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFB_CPOVREI] ),1 ))

						aNfCab[NF_BASEIMP][nImp] -= aNfItem[nlCont][IT_BASEIMP][nImp]
						aNfCab[NF_VALIMP][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]
						aNfCab[NF_VLRORIG][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]

						aNfCab[NF_BASEIMP][3] -= aNfItem[nlCont][IT_BASEIMP][3]
						aNfCab[NF_VALIMP][3]  -= aNfItem[nlCont][IT_VALIMP][3]
						aNfCab[NF_VLRORIG][3]  -= aNfItem[nlCont][IT_VALIMP][3]
						If cPaisLoc == "RUS"
							aNfCab[NF_BASEIMP_C1][nImp] -= aNfItem[nlCont][IT_BASEIMP_C1][nImp]
							aNfCab[NF_VALIMP_C1][nImp]  -= aNfItem[nlCont][IT_VALIMP_C1][nImp]
							aNfCab[NF_BASEIMP_C1][3] -= aNfItem[nlCont][IT_BASEIMP_C1][3]
							aNfCab[NF_VALIMP_C1][3]  -= aNfItem[nlCont][IT_VALIMP_C1][3]
						EndIf
						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "1"
							aNfCab[NF_TOTAL]      -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							If cPaisLoc == "RUS"
								aNfCab[NF_TOTAL_C1]      -= xMoeda(aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
							EndIf
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "2"
							aNfCab[NF_TOTAL]      += aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							If cPaisLoc == "RUS"
								aNfCab[NF_TOTAL_C1]      += xMoeda(aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
							EndIf
						EndIf

						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "1"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][1]/100)
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "2"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][1]/100)
						EndIf

						aNfCab[NF_VALMERC]    -= aNfItem[nlCont][IT_VALMERC]
						If cPaisLoc == "RUS"
							aNfCab[NF_VALMERC_C1]    -= aNfItem[nlCont][IT_VALMERC_C1]
						EndIf
						nRS	 := aScan(aNfCab[NF_IMPOSTOS],{|x| x[IMP_COD] == "IGV" .And. x[IMP_ALIQ] == aNfItem[nlCont][IT_ALIQIMP][nImp] })
						nRS2 := aScan(aNfCab[NF_IMPOSTOS2],{|x| x[IMP_COD] == "IGV" })

						If nRs > 0
							aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS][nRS][IMP_VAL]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						If nRs2 > 0
							aNfCab[NF_IMPOSTOS2][nRS2][3] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS2][nRS2][4]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						_IdxF3a := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALCONT" } )
						_IdxF3b := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_BASIMP"+Alltrim(Str(nImp)) } )
						_IdxF3c := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALIMP"+Alltrim(Str(nImp)) } )
						_IdxF3d := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_BASIMP3" } )
						_IdxF3e := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALIMP3" } )
						_IdxF3f := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_TES" } )

						nContador:=nlCont3
						For nContador := 2 To Len(aNFCab[NF_LIVRO])
							nlCont3:=nContador
							If aNfCab[NF_LIVRO][nlCont3][_IdxF3f] $ aNfItem[nlCont][IT_TES]
								Exit
							EndIf
						Next

						If ValType(aNfItem[nlCont][IT_BASEIMP][nImp]) == "N" .And. ValType(aNfItem[nlCont][IT_ALIQIMP][nImp]) == "N"

							aNfCab[NF_LIVRO][nlCont3][_IdxF3a] -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							aNfCab[NF_LIVRO][nlCont3][_IdxF3b] -= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_LIVRO][nlCont3][_IdxF3c] -= aNfItem[nlCont][IT_VALIMP][nImp]
							aNfCab[NF_LIVRO][nlCont3][_IdxF3d] -= aNfItem[nlCont][IT_BASEIMP][3]
							aNfCab[NF_LIVRO][nlCont3][_IdxF3e] -= aNfItem[nlCont][IT_VALIMP][3]
						EndIf

					ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_IMPOSTO] $ "PIV" .And. cPaisLoc <> "PER"

						nImp:=NumCpoImpVar(RIGHT(Alltrim(aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFB_CPOVREI]) ,1))

						aNfCab[NF_BASEIMP][nImp] -= aNfItem[nlCont][IT_BASEIMP][nImp]
						aNfCab[NF_VALIMP][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]
						aNfCab[NF_VLRORIG][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]
						If cPaisLoc == "RUS"
							aNfCab[NF_BASEIMP_C1][nImp] -= aNfItem[nlCont][IT_BASEIMP_C1][nImp]
							aNfCab[NF_VALIMP_C1][nImp]  -= aNfItem[nlCont][IT_VALIMP_C1][nImp]
						EndIf
						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "1"
							aNfCab[NF_TOTAL]      -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							If cPaisLoc == "RUS"
								aNfCab[NF_TOTAL_C1]   -= xMoeda(aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
							EndIf
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "2"
							aNfCab[NF_TOTAL]      += aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							If cPaisLoc == "RUS"
								aNfCab[NF_TOTAL_C1]   += xMoeda(aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100),aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
							EndIf
						EndIf

						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "1"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "2"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						EndIf

						aNfCab[NF_VALMERC]    -= aNfItem[nlCont][IT_VALMERC]
						If cPaisLoc == "RUS"
							aNfCab[NF_VALMERC_C1]    -= aNfItem[nlCont][IT_VALMERC_C1]
						EndIf
						nRS	 := aScan(aNfCab[NF_IMPOSTOS],{|x| x[IMP_COD] == "PIV" .And. x[IMP_ALIQ] == aNfItem[nlCont][IT_ALIQIMP][nImp] })
						nRS2 := aScan(aNfCab[NF_IMPOSTOS2],{|x| x[IMP_COD] == "PIV" })

						If nRs > 0
							aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS][nRS][IMP_VAL]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						If nRs2 > 0
							aNfCab[NF_IMPOSTOS2][nRS2][3] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS2][nRS2][4]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						_IdxF3a := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALCONT" } )
						_IdxF3b := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_BASIMP"+Alltrim(Str(nImp)) } )
						_IdxF3c := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALIMP"+Alltrim(Str(nImp)) } )
						_IdxF3f := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_TES" } )

						nContador:=nlCont3
						For nContador := 2 To Len(aNFCab[NF_LIVRO])
							nlCont3:=nContador
							If aNfCab[NF_LIVRO][nlCont3][_IdxF3f] $ aNfItem[nlCont][IT_TES]
								Exit
							EndIf
						Next

						If ValType(aNfItem[nlCont][IT_BASEIMP][nImp]) == "N" .And. ValType(aNfItem[nlCont][IT_ALIQIMP][nImp]) == "N"

							aNfCab[NF_LIVRO][nlCont3][_IdxF3a] -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							aNfCab[NF_LIVRO][nlCont3][_IdxF3b] -= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_LIVRO][nlCont3][_IdxF3c] -= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf
						
					ElseIf (aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_IMPOSTO] $ "DIG" .Or. IIf(lFnTpDig, LxPerTpDIG(aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_IMPOSTO]), .F.)) .And. cPaisLoc == "PER"
						nG := 0
						nImp:=NumCpoImpVar(RIGHT(Alltrim(aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFB_CPOVREI]) ,1))
						If !lRestado
							MaFisSomaIt(nlCont,.F.)
							lRestado := .T.
						EndIf
						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] == "1"
							aNfItem[nlCont][IT_BASEDUP] -= aNfItem[nlCont][IT_VALIMP][nImp]
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] == "2"
							aNfItem[nlCont][IT_BASEDUP] += aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf
						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] == "1"
							aNfItem[nlCont][IT_TOTAL] -= aNfItem[nlCont][IT_VALIMP][nImp]
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] == "2"
							aNfItem[nlCont][IT_TOTAL] += aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf
						//Recalcula o imposto DIG para todos os itens anteriores
						If !MaFisCalcIV(nlCont2,nlCont,(nG>0))
							MaFisAliqIV(nlCont2,nlCont)
							If nG == 0
								MaFisVLIV(nlCont2,nlCont)
							Endif
						Endif

					EndIf
				Next nlCont2

				aNfCab[NF_RECIV] := .F.
			EndIf

			If cPaisLoc <> "PER"			
				MaFisSomaIt(nlCont,.T.)
			ElseIf lRestado
				MaFisVTot(nlCont)
				MaFisSomaIt(nlCont,.T.)
				MaFisToCols(aHeader,aCols,nlCont)
			EndIf
		EndIf
	Next nlCont

Else
	If cPaisLoc <> "PER"
		For nlCont := 1 To Len(aNfItem)

			If !aNfItem[nlCont][IT_DELETED] .And. aNfCab[NF_VALIMP][5] > 0

				nRS	 := aScan(aNfCab[NF_IMPOSTOS],{|x| (x[IMP_COD] == "DIG" .Or. IIf(lFnTpDig, LxPerTpDIG(x[IMP_COD]), .F.)) .And. x[IMP_ALIQ] == aNfItem[nlCont][IT_ALIQIMP][5] })
				nRS2 := aScan(aNfCab[NF_IMPOSTOS2],{|x| x[IMP_COD] == "DIG" .Or. IIf(lFnTpDig, LxPerTpDIG(x[IMP_COD]), .F.)})

				If nRs > 0
					aDel(aNfCab[NF_IMPOSTOS],nRS)
					aSize(aNfCab[NF_IMPOSTOS],Len(aNfCab[NF_IMPOSTOS]) -1)
				EndIf

				If nRs2 > 0
					aDel(aNfCab[NF_IMPOSTOS2],nRS2)
					aSize(aNfCab[NF_IMPOSTOS2],Len(aNfCab[NF_IMPOSTOS2]) -1)
				EndIf

				_IdxF3a := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALCONT" } )
				_IdxF3b := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_BASIMP5" } )
				_IdxF3c := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALIMP5" } )
				_IdxF3f := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_TES" } )

				nContador:=nlCont3
				For nContador := 2 To Len(aNFCab[NF_LIVRO])
					nlCont3:=nContador
					If aNfCab[NF_LIVRO][nlCont3][_IdxF3f] $ aNfItem[nlCont][IT_TES]
						Exit
					EndIf
				Next

				aNfCab[NF_LIVRO][nlCont3][_IdxF3b] -= aNfItem[nlCont][IT_BASEIMP][5]
				aNfCab[NF_LIVRO][nlCont3][_IdxF3c] -= aNfItem[nlCont][IT_VALIMP][5]

				aNfItem[nlCont][IT_BASEIMP][5] := 0
				aNfItem[nlCont][IT_VALIMP][5]  := 0
				aNfItem[nlCont][IT_ALIQIMP][5] := 0
				If cPaisLoc == "RUS"
					aNfItem[nlCont][IT_BASEIMP_C1][5] := 0
					aNfItem[nlCont][IT_VALIMP_C1][5]  := 0
				EndIf
			EndIf
		Next nlCont

	aNfCab[NF_BASEIMP][5] := 0
	aNfCab[NF_VALIMP][5]  := 0
	aNfCab[NF_VLRORIG][5]  := 0
	If cPaisLoc == "RUS"
		aNfCab[NF_BASEIMP_C1][5] := 0
		aNfCab[NF_VALIMP_C1][5]  := 0
	EndIf

	Else
		For nlCont := 1 To Len(aNfItem)
			If !aNfItem[nlCont][IT_DELETED]
				lRestado := .F.

				For nlCont2 := 1 To Len(aNFItem[nlCont][IT_TS][TS_SFC])
					If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_IMPOSTO] $ "DIG" .Or. IIf(lFnTpDig, LxPerTpDIG(aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_IMPOSTO]), .F.)
						nImp := NumCpoImpVar(RIGHT(Alltrim(aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFB_CPOVREI]) ,1))
						If (aNfItem[nlCont][IT_BASEIMP][nImp] + aNfItem[nlCont][IT_VALIMP][nImp]) <> 0
							If !lRestado .And. nlCont <> nItem
								MaFisSomaIt(nlCont,.F.)
								lRestado := .T.
							EndIf
							If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] == "1"
								aNfItem[nlCont][IT_BASEDUP] -= aNfItem[nlCont][IT_VALIMP][nImp]
							ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] == "2"
								aNfItem[nlCont][IT_BASEDUP] += aNfItem[nlCont][IT_VALIMP][nImp]
							EndIf
							If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] == "1"
								aNfItem[nlCont][IT_TOTAL] -= aNfItem[nlCont][IT_VALIMP][nImp]
							ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] == "2"
								aNfItem[nlCont][IT_TOTAL] += aNfItem[nlCont][IT_VALIMP][nImp]
							EndIf
							aNfItem[nlCont][IT_BASEIMP][nImp] := 0
							aNfItem[nlCont][IT_VALIMP][nImp]  := 0
							aNfItem[nlCont][IT_ALIQIMP][nImp] := 0
						EndIf
					EndIf
				Next nlCont2

				If lRestado
					MaFisVTot(nlCont)
					MaFisSomaIt(nlCont,.T.)
					MaFisToCols(aHeader,aCols,nlCont)
				EndIf
			EndIf
		Next nlCont

	EndIf
EndIf

Return()

/*/
MaFisBSICM - Edson Maricate -08.12.1999
Executa o calculo da Base do ICMS do Item.
/*/
Function MaFisBSICM( nItem , lReproc , lZF , lICDif , cCampo, lAgreg )
FISXBICMS(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, lReproc , lZF , lICDif , cCampo, lAgreg, cAliasPROD, aTes)
Return
/*
MaAliqICM-Eduardo/Edson   -08.12.1999
Calculo da Aliquota para operacoes de ICMS
*/
Function MaAliqIcms(nItem,lSolidario,lICDif)
Return FISXAICMS(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, lSolidario,lICDif)
Return(0)

/*MaFisVICMS - Edson Maricate -08.12.1999
Executa o calculo do Valor do ICMS  do Item.
*/
Function MaFisVICMS(nItem,lReproc,lDif)
FISXVICMS(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, lReproc, lDif)
Return

/*
MaMargem- Edson Maricate -08.12.1999
Calculo da Margem de lucro para calculo do ICMS Solidario.
*/
Function MaMargem(nItem)
Return FISXMARGEM(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)

/*
MaFisBSSol -Edson Maricate  -08.12.1999
Esta rotina tem como objetivo calcular a base do retido/Solid conforme definido no regulamento de ICMS.
*/
Function MaFisBSSOL(nItem, cCampo)
FisBasSol(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cCampo)
Return

/*/
MaAliqSol- Edson Maricate -08.12.1999
Calculo da Aliquota para operacoes de ICMS Solidario.
/*/
Function MaAliqSoli(nItem)
Return FisAlqSol(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)

/*/
MaFisVSol-Edson Maricate  -08.12.1999
Esta rotina tem como objetivo calcular o valor do ICMS retido/solidario conforme definido do regulamento de ICMS.
/*/
Function MaFisVSOL(nItem,cCampo)
FisValSol(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cCampo )
Return

/*/
MaALIQCMP- Edson Maricate -08.12.1999
Executa o calculo da aliquota do ICMS complementar.
/*/
Function MaALIQCMP(nItem)
FisAlqDifal(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)
Return

/*/
MaFisVComp - Edson Maricate -08.12.1999
Executa o calculo do ICMS Complementar / Antecipacao ICMS
/*/
Function MaFisVComp(nItem,lReproc,cCampo)
FisValDifal(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, lReproc, cCampo)
Return(.T.)

/*/
MaFisIPI -Alexandre Lemes -21/11/2012
Calculo do imposto sobre produtos industrializacos ( IPI ).
*/
Function MaFisIPI(nItem,cExecuta,lNoProces,cRefSDesc)
FISXIPI(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cExecuta, lNoProces, cRefSDesc)
Return

/*/
MaFisISS -Alexandre Lemes -05/11/2012
Calculo do ISS
/*/
Function MaFisISS(nItem,cExecuta)
FISXISS(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cExecuta, cMunForISS, cFornCE1, cDescCE1, cLojaCE1, dVencCE1, cRecIssCE1)
Return

/*/
MaAliqISS- Alexandre Lemes-05/11/2012
A funcao MaAliqISS foi mantida apenas por motivo de compati
bilidade, pois devido a mesma nao ser STATIC ela foi utiliza
da em varios programas do PROTHEUS para obter a aliquota ISS*/

Function MaAliqISS(nItem)
MaExcecao(nItem)
MaFisISS(nItem,"ALQ")
Return(aNfItem[nItem][IT_ALIQISS])

/*/
MaFisINSS - Alexandre Lemes - 29/10/2012
Calcula o INSS.
/*/
Function MaFisINSS(nItem,cExecuta )
FISXINSS(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cExecuta, lINSSSemDu, lLimInss,cAliasPROD)
Return

/*/
MaFisIR -Alexandre Lemes -06/11/2012
Calculo do IR pessoa Fisica e Juridica
*/
Function MaFisIR(nItem,cExecuta,dVencReal,lVisual)
FISXIR(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cExecuta, lIRRFSemDu, dVencReal, lVisual, aUltPesq,lReproc)
Return

/*/
MaTbIrfPF-Eduardo/Edson   -31.01.2004
Inicializa o Calculo das operacoes Fiscais
Retorno   ExpA: [1] Valor do IRPF
[2] Aliquota do IRPF
[3] Dedução  do IRPF
Parametros ExpN1 : Valor do IRPF
ExpN2 : Valor acumulado do IRPF
*/
Function MaTbIrfPF(nBaseIRF,nTotIrf,lSE2,cFornece,cLoja,dVencReal,cPessoa)
If aUltPesq == Nil
	STATIC aUltPesq := {ctod(""),"","",0,0,0,0,0}
EndIf
Return xFisIRFPF(aNfCab, aNFItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, nBaseIRF, nTotIrf, lSE2, cFornece, cLoja, dVencReal, cPessoa, aUltPesq)

/*MaRecIR - Cleber Stenio   -07.01.2009
  DescrioRecalcula o Valor do IR qdo alterado a condicao de Pagamento
   do Titulo no MATA103X.*/
Function MaRecIR(dVencReal,aCodR,nPosCodR)
FISRECIR(aNfCab, aNFItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, dVencReal,aUltPesq,lIRRFSemDu,aCodR,nPosCodR)
Return

/*/
MaFisPIS - Alexandre Lemes - 28/09/2012
Calculo do PIS - Apuracao / Retencao e ST
*/
Function MaFisPIS(nItem,cTipo,cExecuta,lReproc,lAgregICM)
FisxPis(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cTipo, cExecuta, lReproc, lAgregICM)
Return

/*/
MaFisCOFINS -Alexandre Lemes -28/09/2012
Calculo do COFINS - Apuracao / Retencao e ST
*/
Function MaFisCOFINS(nItem,cTipo,cExecuta,lReproc,lAgregICM)
FISXCOFINS(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cTipo, cExecuta, lReproc, lAgregICM)
Return

/*MaFisCSLL-Alexandre Lemes -01/10/2012
Calculo do CSLL
*/
Function MaFisCSLL(nItem,cExecuta)
FISXCSLL(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cExecuta)
Return

/*
MaFisII  - Cleber Stenio Santos - 23.03.2009
Calcula PIS/COFINS Importação conforme fórmula IN SRF 572/05
*/
Function MaFisII(nItem,cCampo)
FISXII(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cCampo)
Return

/*
MaFisRURAL -Alexandre Lemes -04/10/2012
Executa o calculo do FUNRURAL.
*/
Function MaFisRURAL(nItem,cExecuta)
FISXFUNRUR(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cExecuta)
Return

/*
MaFisFFF- Alexandre Lemes-28/09/2012
Efetua calculo FETHAB, FACS, FABOV para o estado do Mato Grosso.
*/
Function MaFisFFF(nItem)

Local cPrUm     := ""
Local cSgUm     := ""
Local nIndUpf	:= aNfCab[NF_INDUFP]

If nIndUpf > 0 .And. cPaisLoc == "BRA"

	cPrUm     := If(!Empty(aNfItem[nItem][IT_B1UM]),aNfItem[nItem][IT_B1UM],"")
	cSgUm     := If(!Empty(aNfItem[nItem][IT_B1SEGUM]),aNfItem[nItem][IT_B1SEGUM],"")

	//FABOV
	FISXFABOV(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cPrUm, cSgUm)

	//FACS
	FISXFACS(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cPrUm, cSgUm)

	//FETHAB
	FISXFETHAB(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cPrUm, cSgUm)

	//FAMAD
	FISXFAMAD(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cPrUm, cSgUm)

	//IMA-MT
	FISXIMA(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cPrUm, cSgUm)

	//FASE-MT
	FISXFASE(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cPrUm, cSgUm)

	//FUNDESA-RS
	FISXFUNDESA(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)

Endif

Return

/*
MaFisSEST - Alexandre Lemes - 01/10/2012
Calculo do SEST
*/
Function MaFisSEST(nItem, cExecuta)
FISxSest(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cExecuta)
Return

/*MaFisSENAR - Alexandre Lemes - 28/09/2012
Descricao  Calculo do SENAR Lei 8.205, de 22 de dezembro de 2004
*/
Function MaFisSENAR(nItem)
FISxSenar(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)
Return

/*MaFisAFRMM - Alexandre Lemes - 01/10/2012
Calculo do AFRMM
*/
Function MaFisAFRMM(nItem)
FISXAFRMM(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)
Return

/*
MaFisVsul - Alexandre Lemes - 28/09/2012
Calcula o valor do Fundersul do item - Mato Grosso do Sul
Este valor sera calculado apenas nas entradas do estado,
sendo que o resultado sera deduzido da duplicata a pagar.
*/
Function MaFisVSul(nItem)
FISxFndSul(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)
Return

/*/
MaFisBSICA - Alexandre Lemes - 24/09/2012
Executa o calculo da Base do ICMS do frete Autonomo
*/
Function MaFisICA(nItem)
FISXICA(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)
Return

/*/
MaFisTST - Alexandre Lemes - 24/09/2012
Verifica a base para calculo do ICMS sobre o frete quando o calculo e feito a parte do calculo do ICMS
*/
Function MaFisTST(nItem,cExecuta)
FISXTST(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cExecuta)
Return

/*
MaFisCIDE - Graziele Paro - 20/12/2013
Efetua o cálculo do CIDE, para que seja definido no titulo campo E2_CIDE
*/
Function MaFisCIDE(nItem,cExecuta)
FISXCide(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cExecuta)
Return

/*
MaFisFMPEQ - Graziele Paro - 01/12/2014
Efetua o cálculo do FUMIPEQ
*/
Function MaFisFMPEQ(nItem)
FISXFUMIPQ(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)
Return

/* MaFisTPDP - Alexandre Lemes - 22/11/2012
Executa calculo do TPDP - Paraiba Taxa de Processamento de Despesas Publicas.
*/
Function MaFisTPDP(nItem)
FISXTPDP(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)
Return

/*
MaFisFECP - ALexandre Lemes - 19/10/2012
Calcula  FECP de Todos os Estados e grava a aliquota a ser
Majorada na aliquota do ICMS na referencia de Aliquota do
FECP de cada estado no array aNFItem
*/
Function MaFisFECP( nItem , cCampo, lReproc, cExecuta)
FisFECP( aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cCampo, lReproc, cExecuta, aRefAlt)
Return
/* FUNCOES PARA FINS ESPECIFICOS E OU QUE PODEM SER MOVIDAS DA MATXFIS */

/*CpyFieldSB   -            -
   Copia estrutura de campo do SB1 para criar no SBZ          */
Function CpyFieldSB(aSx3,lRetCp)

Local aAreaSX3	:= {}
Local aHelp		:= {}
Local nX		:= 0
Local nY		:= 0
Local cOrdem	:= ""
Local cMensagem	:= ""
Local cRet		:= ""
//Os campos agregados neste array serao considerados na execução do UPDFIS para replicar os campos     |
// do SB1 para o SBZ. E na leitura na funcao MaSBCampo, na MATXFIS, que direciona a leitura de
// informacoes fiscais do produto para o SB1 ou SBZ dependendo da configuracao do parametro MV_ARQPROD
Local aCpoSBZ	:= {"B1_PICM"	,;
"B1_VLR_ICM",;
"B1_INT_ICM",;
"B1_PICMRET",;
"B1_PICMENT",;
"B1_IPI"	,;
"B1_VLR_IPI",;
"B1_REDPIS"	,;
"B1_REDCOF"	,;
"B1_IRRF"	,;
"B1_ORIGEM"	,;
"B1_GRTRIB"	,;
"B1_CODISS" ,;
"B1_FECP"	,;
"B1_ALIQISS",;
"B1_PIS",;
"B1_COFINS",;
"B1_CSLL",;
"B1_PCSLL",;
"B1_ALFUMAC",;
"B1_FECPBA",;
"B1_ALFECRN",;
"B1_CNAE",;
"B1_CLASFIS",;
"B1_PPIS",;
"B1_PCOFINS",;
"B1_AFUNDES",;
"B1_TRIBMUN"}

DEFAULT lRetCp	:= .F.
DEFAULT aSx3	:= {}

If lRetCp
	For nX := 1 to len(aCpoSBZ)
		cRet += aCpoSBZ[nX] + "/"
	Next nX
	Return cRet
EndIf

aAreaSX3 := SX3->(GetArea())

dbSelectArea("SX3")
dbSetOrder(2)
For nX := 1 to len(aCpoSBZ)
	If SX3->(MsSeek(PadR(aCpoSBZ[nX],10)))
		AADD(aSX3,{	"SBZ"			,cOrdem			,StrTran(aCpoSBZ[nX],"B1","BZ"),;
		SX3->X3_TIPO	,SX3->X3_TAMANHO,SX3->X3_DECIMAL,;
		SX3->X3_TITULO 	,SX3->X3_TITSPA ,SX3->X3_TITENG ,;
		SX3->X3_DESCRIC	,SX3->X3_DESCSPA,SX3->X3_DESCENG,;
		SX3->X3_PICTURE	,StrTran(SX3->X3_VALID,"B1_","BZ_"),SX3->X3_USADO,;
		StrTran(SX3->X3_RELACAO,"B1_","BZ_"),SX3->X3_F3     ,SX3->X3_NIVEL,;
		SX3->X3_RESERV ,SX3->X3_CHECK  	,SX3->X3_TRIGGER,;
		SX3->X3_PROPRI ,SX3->X3_BROWSE	,SX3->X3_VISUAL,;
		SX3->X3_CONTEXT,SX3->X3_OBRIGAT	,StrTran(SX3->X3_VLDUSER,"B1_","BZ_"),;
		SX3->X3_CBOX   ,SX3->X3_CBOXSPA	,SX3->X3_CBOXENG,;
		SX3->X3_PICTVAR,SX3->X3_WHEN	,SX3->X3_INIBRW,;
		SX3->X3_GRPSXG ,"2"				,SX3->X3_PYME	}	)
		aHelp := {}
		cMensagem := Ap5GetHelp(aCpoSBZ[nX])
		For nY := 1 to MlCount(cMensagem)
			AADD(aHelp,MemoLine(cMensagem,,nY))
		Next nY
		PutHelp("P"+StrTran(aCpoSBZ[nX],"B1","BZ"),aHelp,aHelp,aHelp,.T.)
	EndIf
Next nX

RestArea(aAreaSX3)

Return Nil


/*/
MaFisOrdem - Edson Maricate - 01.02.99
Retorna a ordem utilizada pela rotina de calculo de impostos da referencia solicitada.
Uso: MATA461, Esta ordem e utilizada na rotina de Geracao de NF de Saida permitindo que os impostos informados no
SC6 atraves da Funcao MaFisGet() nao sejam recalculados pela Funcao Fiscal
*/
Function MaFisOrdem(cReferencia)

Local nOrdem := 10000
Local nPos   := 0

If aItemRef == Nil
	MaIniRef()
EndIf
If Substr(cReferencia,1,2) == "IT"
	nPos := aScan( aItemRef , {|x|x[1] == cReferencia } )
	If nPos > 0 .And. aItemRef[nPos][3] <> Nil
		nOrdem := aItemRef[nPos][3]
	EndIf
EndIf

Return nOrdem

/*
MaFisReprocess - Edson Maricate - 20.05.2000
Efetua o reprocessamento e gera o livro da Nota Fiscal.
*/
Function MaFisReprocess(nOpc)

Local nItem := 	0
DEFAULT nOpc:= 1

If MaFisFound("NF")
	For nItem := 1 to Len(aNfItem)
		If nOpc == 1
			MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
			MaNewFisTES(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
			MaFisIPI(nItem,"BSE",.T.)
			MaFisBSICM(nItem,.T.)
			MaFisLF(nItem)
		Else
			MaFisRecal(,nItem)
		EndIf
	Next nItem
	MaIt2Cab()
EndIf

Return

/*
MaFisGet - Edson Maricate - 01.02.99
Funcao utilizada no Pedido de Vendas ( Exclusivamente ) para
criar a referencia do campo no tratamento fiscal.
Obs.: nao executa o calculo do imposto, apenas utiliza o valor informado na preparacao da Nota Fiscal.
*/
Function MaFisGet(cReferencia)
Return .T.

/*AS FUNCOES ABAIXO FORAM REDIRECIONADAS PARA O FONTE IMPXFIS.PRW - 10/02/2015
  As chamadas originais foram mantidas para que nao fosse necessario alterar todos os
  fontes que as utilizam, gerando muitas dependencias desnecessarias. Desta forma, as
  funcoes foram transcritas para o IMPXFIS, com o prefixo "xFis" no lugar de "Ma" e as
  chamadas foram redirecionadas. Algumas funcoes sofreram pequenas alteracoes nos nomes
  devido ao nro. de caracteres
*/
/*/
MaFisAtuSF3 - Edson Maricate-21.02.2000
Esta rotina tem como objetivo atualizar os livros fiscais com base em uma nota fiscal de entrada ou saida.
/*/
Function MaFisAtuSF3(nCaso, cTpOper, nRecNF, cAlias, cPDV, cCNAE, cFunOrig, nCD2, cCodSef, cSerSat, cNfisCanc, cCodRet, cProtoc, cDescRet)
Return xFisAtuSF3(nCaso, cTpOper, nRecNF, cAlias, cPDV, cCNAE, cFunOrig, nCD2, cCodSef, cSerSat, cNfisCanc, aNFCab, aNFItem, cAliasPROD, aPE, aSX6, aDic, aPos, cCodRet, cProtoc, cDescRet, aFunc, aInfNat )

Function MaFisGetRF(cValid)
Return xFisGetRF(cValid)

Function MaSBCampo(cNome)
Return xFisSBCpo(cNome,aSX6,cAliasProd,cCpoSBZ)

//** MaAvalTes **
Function MaAvalTes(cOperacao,cTes)
Return xFisAvTes(cOperacao,cTes)

//** CodSitTri **
Function CodSitTri()
Return FISXSITTRI(aSX6,aPos)

//** RetComp **
Function RetComp(cAlOri,nRecOri)
Return xFisRtComp(cAlOri,nRecOri,aSX6)

//** MaFisRefLd **
Function MaFisRefLd(cAlias,cTipo)
Return xFisRefLd(cAlias,cTipo)

//** MaFisLdImp **
Function MaFisLdImp()
Return xFisLdImp()

//** MaFisImpLd **
Function MaFisImpLd(cAlias,cTipo,cCursor)
Return xFisImpLd(cAlias,cTipo,cCursor)

//** MaFisCDA **
Function MaFisCDA(nItem,nTipo,lExclui,cChaveSF,cFormul,cAlias,lReproc,jRegCDA)
Default lReproc := .F.
Default jRegCDA := Nil

Return xFisCDA(nItem,nTipo,lExclui,cChaveSF,cFormul,cAlias,aDic,aPos,aNfItem,lReproc,aFunc,@jRegCDA)


//** Decret5602 **
Function Decret5602(nVlItem,cNCM,cCodNat)
Return FISXDC5602(nVlItem,cNCM,cCodNat,aSX6)

//** MaFisRelImp **
Function MaFisRelImp(cProg,aAlias)

Local aRet		:= {}
Local nX        := 0
Local nY        := 0

Local aSX3Fields:= {}
Local cX3Valid	:= ""
Local cCpo      := ""

DEFAULT aRefSX3 := {}

	If Valtype(oRefSX3) <> 'J'
		oRefSX3 := JsonObject():new()
	Endif

	For nX := 1 to Len(aAlias)

		//If aScan(aRefSX3,{|x| x[1] == aAlias[nX]}) == 0 // Verifica se o alias solicitado esta no cache de memoria e adiciona as referencia ao cache de memoria
		IF !(oRefSX3:hasProperty(aAlias[nX])) // Verifica se o objeto json possui determinada chave cKey. Retorna verdadeiro se a chave existe, e falso caso contrário.
						
			aSX3Fields := FWSX3Util():GetAllFields( aAlias[nX] , .F. )

			For nY := 1 To Len( aSX3Fields )
				cCpo     := AllTrim(aSX3Fields[nY])
				cX3Valid := GetSx3Cache(cCpo,"X3_VALID")

				If lCpoUsrAFRMM .And. GetValidCpoUser(cCpo)
					cX3Valid := GetSx3Cache(cCpo,"X3_VLDUSER")
				EndIf

				If !EMPTY(cX3Valid) .and. "MAFISREF" $ AllTrim( UPPER( cX3Valid ) )
					If !( cCpo == "F1_II" .AND. ( "MAFISREF" $ cX3Valid ) .AND. fisGetParam('MV_EASY','') == "S" )
						aadd( aRefSX3 , { aAlias[nX] , cCpo , xFisGetRF(cX3Valid)[1] } )
					EndIf
				EndIf
			Next

			oRefSX3[aAlias[nX]] := .T.

		EndIf

		For nY := 1 To Len(aRefSX3) // Obtem as referencias do cache de memoria
			If aRefSx3[nY][1] == aAlias[nX]
				aadd( aRet , { aAlias[nX] , aRefSx3[nY][2] , aRefSx3[nY][3] } )
			EndIf
		Next nY

	Next nX


Return aRet

Return NIL

//** MaIniRef **
Function MaIniRef()
Return xFisIniRef(@aItemRef,@aCabRef,@aLFIs,@aResRef,aSX6,aPos,@aTGITRef,@aTGNFRef, aTGLFRef)

// DECLARACAO MANTIDA APENAS PARA EVITAR ERRO DE CHAMADA.
/*
MaFisAddIT - Marcelo Alexandre-01.03.2009
Carrega os valores de impostos de bases e item
*/
Function MaFisAddIT(cCampo,xValor,nItem,lZer)
Return .T.

/*/
MaNewFisTes - Joao Pellegrini-18/08/2015±±
Inicializa o codigo da TES utilizada no item
*/
Function MaNewFisTES(cTes,nRecnoSF4,nItem,lSeek)
Return xFisNewTes(@cTes,@nRecnoSF4,@nItem,@lSeek,@aSX6,@lHistorico,@cAlsItem,@aNfCab,@aNfItem,@aPos,@aDic,aFunc)

/*/{Protheus.doc} MaFisCPRB()
@description Contribuição Previdenciária Incidente sobre a Receita Bruta (CPRB)
@author Mauro A. Gonçalves

@history Vogas Júnior, 07/06/2018, (DSERFIS1-6133) alterada forma de obtensão da Base de cálculo CPRB.
/*/
Function MaFisCPRB(nItem )
FISXCPRB(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)
Return

Function ActItemNf(nItem,nCampo,aActItem,lNoret)

	Default lNoret := .F.

	nCampo := Iif(nCampo <> 0,nCampo,VerificanCampo(nCampo))

	If ALLTRIM(FUNNAME()) $ "MATA410/OFIXA018/OFIXA011/OFIXA100"
		If len (aNfItem) >= nItem
			aNfItem[nItem][IT_BASEIMP][nCampo]	:= aActItem[1]
			aNfItem[nItem][IT_ALIQIMP][nCampo]	:= aActItem[2]
			aNfItem[nItem][IT_VALIMP][nCampo]	:= IIF(aNfItem[nItem][IT_DELETED] .OR. lNoret = .T.,0,aNfItem[nItem][IT_VALIMP][nCampo])
			If cPaisLoc == "RUS"
				aNfItem[nItem][IT_BASEIMP_C1][nCampo]	:= xMoeda(aActItem[1],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
				aNfItem[nItem][IT_VALIMP_C1][nCampo]	:= IIF(aNfItem[nItem][IT_DELETED] .OR. lNoret = .T.,0,aNfItem[nItem][IT_VALIMP_C1][nCampo])
			EndIf
		EndIf
	Else
		If cPaisLoc == "ARG"
			aNfItem[nItem][IT_TOTAL] 	-= aNfItem[nItem][IT_VALIMP][nCampo]
			If aNfItem[nItem][IT_BASEDUP] <> 0
				aNfItem[nItem][IT_BASEDUP] 	-= aNfItem[nItem][IT_VALIMP][nCampo]
			EndIf
		EndIf
		aNfItem[nItem][IT_BASEIMP][nCampo]	:= aActItem[1]
		aNfItem[nItem][IT_ALIQIMP][nCampo]	:= aActItem[2]
		aNfItem[nItem][IT_VALIMP][nCampo]	:= IIF(aNfItem[nItem][IT_DELETED] .OR. lNoret = .T.,0,aNfItem[nItem][IT_VALIMP][nCampo])
		If cPaisLoc == "RUS"
			aNfItem[nItem][IT_BASEIMP_C1][nCampo]	:= xMoeda(aActItem[1],aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
			aNfItem[nItem][IT_VALIMP_C1][nCampo]	:= IIF(aNfItem[nItem][IT_DELETED] .OR. lNoret = .T.,0,aNfItem[nItem][IT_VALIMP_C1][nCampo])
		EndIf
	EndIf

Return

Function ActCabNf(nCampo,cImposto,nBase,nReten)
	DEFAULT cImposto  := ""
	If len(aNfCab[NF_IMPOSTOS2]) > 0
		nPosimp = Ascan(aNfCab[NF_IMPOSTOS2],{|x| x[1] == cImposto })	   //33
		If nPosimp > 0
			aNfCab[NF_IMPOSTOS2][nPosimp][3] := nBase
			aNfCab[NF_IMPOSTOS2][nPosimp][4] := nReten
			aNfCab[NF_BASEIMP][nCampo] := nBase
			aNfCab[NF_VALIMP][nCampo] := nReten
			aNfCab[NF_VLRORIG][nCampo] := nReten
			If cPaisLoc == "RUS"
				aNfCab[NF_BASEIMP_C1][nCampo] := xMoeda(nBase,aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
				aNfCab[NF_VALIMP_C1][nCampo] := xMoeda(nReten,aNfCab[NF_MOEDA],1,dDataBase,,aNfCab[NF_TXMOEDA])
			EndIf
		Endif
	Endif
	If len(aNfCab[NF_IMPOSTOS]) > 0
		nPosimp = Ascan(aNfCab[NF_IMPOSTOS],{|x| x[1] == cImposto })      //30
		If nPosimp > 0
			if nbase==0
				aNfCab[NF_IMPOSTOS]:=Adel(aNfCab[NF_IMPOSTOS],nPosimp)
				aNfCab[NF_IMPOSTOS]:=aSize(aNfCab[NF_IMPOSTOS],Len(aNfCab[NF_IMPOSTOS])-1)
			else
				aNfCab[NF_IMPOSTOS][nPosimp][3] := nBase
				aNfCab[NF_IMPOSTOS][nPosimp][4] := nReten
			endif
		endif
	endif
Return

/*/{Protheus.doc} MaFisDbST()
@description Esta funcao retorna se o valor do ICMS-ST deverá ou não
ser descontado da base do PIS/COFINS/CSLL (apuração e retenção).
Estão concentradas aqui as regras genéricas para o desconto. Regras
especificas deverão ser implementadas na função do próprio tributo.
@author joao.pellegrini
/*/
Function MaFisDbST(cImposto, nItem)
Return FISXDBST(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cImposto)

/*/
MaFisINSP - Diego Dias - 06/08/2016
Calcula o INSS Patronal.
/*/
Function MaFisINSP(nItem, cExecuta)
FISINSSPAT(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cExecuta)
Return

/*/{Protheus.doc} MaSeekCFC()
Função que trata posicionamento da tabela CFC (UF x UF)
/*/
Static Function MaSeekCFC(nOpc,nItem)
Return xFisPosCFC(@nOpc,@nItem, @aDic, @aPos, @aNfCab, @aSX6, @aNfitem)

/*/
MaFisPROT - Diego Dias - 19/01/2017
Calcula o PROTEGE-GO.
/*/
Function MaFisPROT(nItem)
FISXProteg(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)
Return

/*/
MaFisFEEF - Simone dos Santos Oliveira # 22/02/2017
Calcula o FEEF-RJ.
/*/
function MaFisFEEF(nItem)
FISXFEEF(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)
return

/*/{Protheus.doc} loadRefAlt()
@description Função responsável por efetuar a carga do array aRefAlt,
utilizado para controlar as referências que foram alteradas via MaFisAlt
ou MaFisLoad e, assim, evitar desfazer estas alterações durante os recálculos.
@author joao.pellegrini
/*/
Static Function loadRefAlt(nItem)

Local nX   := 0
Local nPos := 0

aAdd(aRefAlt, Array(Len(aNFItem[nItem])))
nPos := Len(aRefAlt)

For nX := 1 to Len(aNfItem[nItem])

	If ValType(aNfItem[nItem][nX]) == "A"
		aRefAlt[nPos, nX] := Array(Len(aNfItem[nItem][nX]))
		aFill(aRefAlt[nPos, nX], .F.)
	Else
		aRefAlt[nPos, nX] := .F.
	EndIf

Next nX

Return

/*/{Protheus.doc} MaCodDecl()
Função que fará enquadramento da tabela F3K para calcular Valores Declaratorios
@author Rafael.Soliveira
20/04/2018
/*/
Static function MaCodDecl(nItem)
Return xMaCodDecl(nItem, @aNfItem, @aNfCab, @aSX6, @aPos, @aDic, aPE)

/*±±³Funcao    ³MaFisISSBi ³ Autor ³ Caio Martins Data  ³19/10/2018³ ±±
±±³Descrio ³A funcao efetua o calculo do ISS BI Tributado (Cepom) ³±±*/
Function MaFisISSBi(nItem,cExecuta)
FISXISSBI(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, cExecuta, cMunForISS)
Return

/*±±³Funcao MaSeekCLI ³ Autor ³   Caio Martins     Data  ³19/10/2018³ ±±
±±³Descrio ³A funcao efetua o calculo do ISS BI Tributado (Cepom) ³±±*/

Function MaSeekCLI(nItem)
FISXSEEKCLI(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc,cMunForISS)
Return

/*/{Protheus.doc} MaFisTG()
@description Gravação/Exclusão dos tributos genéricos
@author erick.dias
/*/
Function MaFisTG(nOper, cAlias, nItem, cIdTrbGen)
Local cRet			:= ""
DEFAULT cAlias		:= ""
DEFAULT cIdTrbGen	:= ""
DEFAULT nOper 		:= 1

If fisExtTab('12.1.2310', .T., 'F2D')
	If nOper == 1 //Gravação dos tributos genéricos
		//Se já ter informações gravadas na F2d com este ID preciso deletar para refazer
		xFisDelTrbGen(aNfItem[nItem][IT_ID_TRBGEN],.F.)
		//Chamo função para gravação.
		cRet	:= xFisGrvTrbGen(aNfItem, nItem,cAlias, aDic)
	ElseIF nOper == 2 //Exclusão dos tributos genéricos
		xFisDelTrbGen(cIdTrbGen,.T.)
	EndIF
EndIf
Return cRet

/*/{Protheus.doc} MaFisBrwTG()
@description Função responsável por retornar o grid para visualização
ou alteração dos tributos genéricos por item.
@author joao.pellegrini
@version 12.1.17
/*/
Function MaFisBrwTG(oJanela, aPosicao, lVisual)

Local oGrid := NIL
Local aHdrTrbGen := xFisHdrTG()
Local aColTrbGen := MColTrbGen()

DEFAULT lVisual := .T.

oGrid := MsNewGetDados():New( aPosicao[1], aPosicao[2], aPosicao[4], aPosicao[3], Iif(lVisual,0,GD_UPDATE), "AllwaysTrue", "AllwaysTrue", "AllwaysTrue", {"F2D_BASE","F2D_ALIQ","F2D_VALOR"}, 0, 999, "AllwaysTrue", "", "AllwaysTrue", oJanela, aHdrTrbGen, aColTrbGen )

Return oGrid

/*/{Protheus.doc} MaFisLinTG()
@description Função responsável por efetuar a carga do browse
do componente de visualização/alteração dos tributos genéricos.
@author joao.pellegrini
@version 12.1.17
/*/
Function MaFisLinTG(oBrowse, nItem)

Local nTrbGen := 0
Local aColTrbGen := MColTrbGen()
Local lZero := .F.

oBrowse:aCols := {}

If MaFisFound("IT", nItem) .And. !aNfItem[nItem][IT_DELETED]

	If !Empty(aNfItem[nItem][IT_TRIBGEN])
		aColTrbGen	:= {}
		For nTrbGen := 1 to Len(aNfItem[nItem][IT_TRIBGEN])

			lZero := aNfItem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_VL_ZERO]

			IF aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_BASE] > 0 .Or. aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_VALOR] > 0 .Or. lZero
				aAdd(aColTrbGen, {})
				nPosTrbGen := Len(aColTrbGen)
				aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_ITEM])
				aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_SIGLA])
				aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_DESCRICAO])
				aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_BASE])
				aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_ALIQUOTA])
				aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_VALOR])

				//Colunas dos campos de escrituração no livro dos tributos genéricos
				If fisExtTab('12.1.2310', .T., 'CJ2')
					aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_LF][TG_LF_CST])
					aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_LF][TG_LF_VALTRIB])
					aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_LF][TG_LF_ISENTO])
					aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_LF][TG_LF_OUTROS])
					aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_LF][TG_LF_NAO_TRIBUTADO])
					aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_LF][TG_LF_DIFERIDO])
					aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_LF][TG_LF_MAJORADO])
				EndIf
				aAdd(aColTrbGen[nPosTrbGen], .F.)
			EndIf
		Next nTrbGen
	EndIf

EndIf

oBrowse:SetArray(aClone(aColTrbGen))
oBrowse:Refresh(.T.)

Return .T.

/*/{Protheus.doc} MaFisTGRef()
@description Função utilizada no folder dos tributos genéricos por item
para disparar os recálculos quando houver alguma alteração manual na
base, alíquota ou valor.
@author joao.pellegrini
@version 12.1.17
/*/
Function MaFisTGRef(cReferencia,xValor,aTrbGen,nItem)

Local lRet 		:= .F.
Local lCJ3		:= fisExtTab('12.1.2310', .T., "CJ3")
Local nX		:= 0

Local nPosBas   := aScan(aHeader, {|x| AllTrim(x[2]) == "F2D_BASE"})
Local nPosAlq   := aScan(aHeader, {|x| AllTrim(x[2]) == "F2D_ALIQ"})
Local nPosVal   := aScan(aHeader, {|x| AllTrim(x[2]) == "F2D_VALOR"})
Local nPosTrib  := aScan(aHeader, {|x| AllTrim(x[2]) == "F2D_TRIB"})
Local nPosItem	:= 1

Local nPosCST  	:= 0
Local nPosVlTrib:= 0
Local nPosVlIsen:= 0
Local nPosVlOutr:= 0
Local nPosVlNTri:= 0
Local nPosVlDife:= 0
Local nPosVlMajo:= 0

If MaFisFound("NF")

	If lRet := MaFisVldAlt(cReferencia)

		If lCJ3
			nPosCST  	:= aScan(aHeader, {|x| AllTrim(x[2]) == "CJ3_CST"})
			nPosVlTrib  := aScan(aHeader, {|x| AllTrim(x[2]) == "CJ3_VLTRIB"})
			nPosVlIsen  := aScan(aHeader, {|x| AllTrim(x[2]) == "CJ3_VLISEN"})
			nPosVlOutr  := aScan(aHeader, {|x| AllTrim(x[2]) == "CJ3_VLOUTR"})
			nPosVlNTri  := aScan(aHeader, {|x| AllTrim(x[2]) == "CJ3_VLNTRI"})
			nPosVlDife  := aScan(aHeader, {|x| AllTrim(x[2]) == "CJ3_VLDIFE"})
			nPosVlMajo  := aScan(aHeader, {|x| AllTrim(x[2]) == "CJ3_VLMAJO"})
		EndIf

		MaFisAlt(cReferencia,xValor,nItem,,,,,,,aTrbGen)
		
		//Atualizo todos os itens do acols dos tributos genéricos por item
		For nX	:= 1 to Len(aCols)
			
			//Verifico se é o mesmo item
			If nItem == Val(aCols[nX][nPosItem])
				aCols[nX][nPosBas]:= MaFisRet(nItem, cReferencia, {aCols[nX][nPosTrib], "TG_IT_BASE"})
				aCols[nX][nPosAlq]:= MaFisRet(nItem, cReferencia, {aCols[nX][nPosTrib], "TG_IT_ALIQUOTA"})
				aCols[nX][nPosVal]:= MaFisRet(nItem, cReferencia, {aCols[nX][nPosTrib], "TG_IT_VALOR"})
				
				If fisExtTab('12.1.2310', .T., 'CJ2')
					aCols[nX][nPosCST]:= MaFisRet(nItem, cReferencia, {aCols[nX][nPosTrib], "TG_LF_CST"})
					aCols[nX][nPosVlTrib]:= MaFisRet(nItem, cReferencia, {aCols[nX][nPosTrib], "TG_LF_VALTRIB"})
					aCols[nX][nPosVlIsen]:= MaFisRet(nItem, cReferencia, {aCols[nX][nPosTrib], "TG_LF_ISENTO"})
					aCols[nX][nPosVlOutr]:= MaFisRet(nItem, cReferencia, {aCols[nX][nPosTrib], "TG_LF_OUTROS"})
					aCols[nX][nPosVlNTri]:= MaFisRet(nItem, cReferencia, {aCols[nX][nPosTrib], "TG_LF_NAO_TRIBUTADO"})
					aCols[nX][nPosVlDife]:= MaFisRet(nItem, cReferencia, {aCols[nX][nPosTrib], "TG_LF_DIFERIDO"})
					aCols[nX][nPosVlMajo]:= MaFisRet(nItem, cReferencia, {aCols[nX][nPosTrib], "TG_LF_MAJORADO"})
				EndIf
			EndIF

		Next nX		

	EndIf

EndIf

Return lRet

/*/{Protheus.doc} MaFisItem()
@description Função que retorna a primeira ocorrencia nos itens de aNFItem
com o valor do campo pesquisado
@author leonardo.magalhaes
@version
/*/
Function MaFisItem(cCampo, xValor)

	Local nPosCampo := Val(MaFisScan(cCampo,.F.))
	Local nPosItem	:= 0

	If nPosCampo > 0
		nPosItem := aScan(aNFItem,{|a| a[nPosCampo] == xValor})
	EndIf

Return nPosItem

/*/{Protheus.doc} MaFisFinal()
Função que fara controle de exceção caso alguma função não exista
/*/
Function MaFisFinal(cMensagem)

Default cMensagem:= STR0045

If IsBlind()
	UserException(cMensagem)
Else
	MsgAlert(cMensagem)
	Final(cMensagem)
EndIf
Return

/*/{Protheus.doc} AtuTrbLeg()
//Função que atualiza o cálculo dos tributos legados após o cálculo dos tributos genéricos
//Aqui preciso chamar a função dos tributos legado para que sejam refeitos, agora com a lsita dos tributos genéricos calculados
//a função do tributo legado vai verificar se exsite um genérico com ID, se existir então os valores serão zerados
/*/
Static Function AtuTrbLeg(aTrbLegCalc, nItem, lLoad)
Local lRet	:= .F.
Local lDadosAdd := fisExtCmp('12.1.2410', .T.,'CK2','CK2_CODIGO') .AND. fisExtCmp('12.1.2410', .T.,'CK3','CK3_CODIGO') .AND. fisExtCmp('12.1.2410', .T.,'CK4','CK4_CODIGO') .AND. fisFindFunc("AtRefAdic")
Local nItemTG := Len(aNfItem[nItem][IT_TRIBGEN])

Default lLoad := .F.

If aTrbLegCalc[ICMSST][2] 
	MaFisBSSOL(nItem)
	MaAliqSoli(nItem)
	MaFisVSOL(nItem)
	lRet:= .T.
EndIf
If aTrbLegCalc[IPI][2]
	MaFisIPI(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[ICMS][2] .or. aTrbLegCalc[ESTICM][2] .Or. aTrbLegCalc[DZFICM][2]
	MaFisBSICM(nItem)
	MaAliqIcms(nItem)
	MaFisVICMS(nItem)
	lRet:= .T.
EndIf
If aTrbLegCalc[DIFAL][2] .Or. aTrbLegCalc[CMP][2] .Or. aTrbLegCalc[ANTEC][2]
	MaFisVComp(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[COF][2] .Or. aTrbLegCalc[COFST][2] .Or. aTrbLegCalc[COFRET][2] .Or. aTrbLegCalc[DZFCOF][2]
	MaFisCOFINS(nitem,"")
	lRet:= .T.
EndIF
If aTrbLegCalc[PIS][2] .Or. aTrbLegCalc[PISST][2] .Or. aTrbLegCalc[PISRET][2] .Or. aTrbLegCalc[DZFPIS][2] 
	MaFisPIS(nitem,"")
	lRet:= .T.
EndIF
If aTrbLegCalc[FUNRUR][2]
	MaFisRURAL(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[SENAR][2]
	MaFisSENAR(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[TPDP][2]
	MaFisTPDP(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[PROTEG][2]
	MaFisPROT(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[INSS][2]
	MaFisINSS(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[CSLL][2]
	MaFisCSLL(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[SEST][2]
	MaFisSEST(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[ISS][2] 
	MaFisISS(nItem)
	lRet:= .T.
EndIf
If aTrbLegCalc[ISSBI][2] 
	MaFisISSBi(nItem)
	lRet:= .T.
EndIf
If aTrbLegCalc[CIDE][2]
	MaFisCIDE(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[II][2]
	MaFisII(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[CPRB][2]
	MaFisCPRB(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[INSSPT][2]
	MaFisINSP(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[FEEF][2]
	MaFisFEEF(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[FECPIC][2] .or. aTrbLegCalc[FCPST][2] .or. aTrbLegCalc[FCPCMP][2]
	MaFisFECP(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[AFRMM][2]
	MaFisAFRMM(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[FABOV][2] .OR. aTrbLegCalc[FACS][2] .OR. aTrbLegCalc[FAMAD][2] .OR. aTrbLegCalc[FASEMT][2] .OR. aTrbLegCalc[FETHAB][2] .OR. aTrbLegCalc[FUNDESA][2] .OR. aTrbLegCalc[IMAMT][2]
	MaFisFFF(nItem)
	lRet:= .T.
EndIf
If aTrbLegCalc[IR][2]
	MaFisIR(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[FRTAUT][2] 
	MaFisICA(nItem)
	lRet:= .T.
EndIf
If aTrbLegCalc[FRTEMB][2] 
	MaFisTST(nItem)
	lRet:= .T.
EndIf
If aTrbLegCalc[FUNDERSUL][2]
	MaFisVSul(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[FUMIPQ][2]
	MaFisFMPEQ(nItem)
	lRet:= .T.
EndIF
If aTrbLegCalc[PRES_ICMS][2] .or. aTrbLegCalc[PRODEPE][2]
	FISXCRDPRE(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, ,"1", cAliasPROD)
	lRet:= .T.
EndIF
If aTrbLegCalc[PRES_ST][2]
	FISXCRDPRE(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, ,"2", cAliasPROD)
	lRet:= .T.
EndIF
If aTrbLegCalc[PRES_CARGA][2]
	FISXCRDPRE(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc, ,"3", cAliasPROD)
	lRet:= .T.
EndIF

If aTrbLegCalc[STMONO][2]	
	lRet:= .T.
EndIF

If lDadosAdd .AND. nItemTG > 0

	AtRefAdic(aNFItem, nItem , nItemTG)
EndIf

//Faço novamente o total, arred e o livro atualizando os valores dos tributos legado.
If lRet .AND. !lLoad
	MaFisVTot(nItem)
	MaItArred(nItem)
	MaFisLF(nItem)
EndIF

Return


/* {Protheus.doc} AtRefAdic
    Atualiza as referências da TES (legado) com o conteúdo dos dados adicionais das referências do configurador de tributos.
    Esta função verifica se existem dados adicionais nos tributos genéricos do configurador e, caso existam, preenche os campos correspondentes na TES do item legado, garantindo que as informações estejam sincronizadas entre o configurador e o legado.

    @param aNfItem, array, Array com os itens da nota fiscal
    @param nItem, numeric, Número do item que será atualizado
    @param nItemTG, numeric, Número do item que será atualizado com os tributos genéricos
    @type  Function
    @author rhuan.carvalho
    @since 27/08/2025
    @version 12.1.2410
    @return nil, nil, Não retorna valor, apenas atualiza as referências no item legado
    @example
        // Exemplo de uso:
        // AtRefAdic(aNfItem, nItem, nItemTG)
        // Após execução, os campos de referência da TES estarão atualizados com os dados adicionais dos tributos genéricos
    @see AddDataJson, SetAddRefs
*/
Static Function AtRefAdic(aNfItem, nItem, nItemTG)
	//Local cItem := cValToChar( nItem )
	Local nTrib := 0
	Local cMOTDESICM := ""
	Local cINDNATFRE := ""
	Local cREGIMESPE := ""

	For nTrib := 1 To nItemTG
		cMOTDESICM	:= aNfItem[nItem][IT_TRIBGEN][nTrib][TG_IT_REGRA_ESCR][RE_DADO_ADICIONAL][MOTDESICMS]
		If !Empty(cMOTDESICM)
			aNfItem[nItem][IT_LIVRO][LF_MOTICMS] := cMOTDESICM
			aNFItem[nItem][IT_TS][TS_MOTICMS]    := cMOTDESICM
		EndIf

		cINDNATFRE := aNfItem[nItem][IT_TRIBGEN][nTrib][TG_IT_PERFOP][OP_DADO_ADICIONAL][INDNATFRET]
		If !Empty(cINDNATFRE)
			aNfItem[nItem][IT_LIVRO][LF_INDNTFR] := cINDNATFRE
			aNFItem[nItem][IT_TS][TS_INDNTFR]    := cINDNATFRE
		EndIf

		cREGIMESPE := aNfItem[nItem][IT_TRIBGEN][nTrib][TG_IT_PERFOP][OP_DADO_ADICIONAL][REGIMESPEC]
		If !Empty(cREGIMESPE)
			aNfItem[nItem][IT_RGESPST]           := cREGIMESPE
			aNFItem[nItem][IT_TS][TS_RGESPST]    := cREGIMESPE
			aNfItem[nItem][IT_NORESPE]           := cREGIMESPE
			aNFItem[nItem][IT_TS][TS_NORESPE]    := cREGIMESPE
		EndIf
	Next nTrib
	
Return

/* {Protheus.doc} DifTrbAdd
	Verifica se os tributos genericos do cache são os mesmos do item
	@type  Static Function
	@param aCache Array com os tributos genericos do cache
	@param aTribG Array com os tributos genericos do item
	@author Douglas Dourado
	@since 03/07/2025
	@version 12.1.2410
	@return .L. se não tiver diferença, .T. se tiver diferença
*/
Static Function DifTrbAdd( aCache, aTribG )
	Local nx := 0
	Local cCodTrib := ""
	Local nTamTrib := Len(aTribG)
	Local lRet := .F.

	For nx := 1 To nTamTrib
		cCodTrib := aTribG[nx][TG_IT_SIGLA]
		If aScan(aCache, {|x| x == cCodTrib }) == 0 // Se o tributo generico do item não existir no cache
			lRet := .T. // Retorna que tem diferença, deve atualizar o cache ...
		EndIf
	Next

Return lRet

Function MaFisBCFun(nItem)
Return  FISXBCFUN(aNfCab, aNFItem, nItem, aPos, aInfNat, aPE, aSX6, aDic, aFunc)

/*/{Protheus.doc} MaVldFuncD()
Função utilizada para fazer verificação inicial da existência dos fontes dependentes
da matxfis, caso não exista a aplicação será abortada para não gravar a nota com valores
incorretos.

A mensagem exibirá qual o fonte está desatualizado, para que usuário possa entrar
em contato com suporte e providenciar a devida atualização de sistema.

@author Erick Dias
@since 15/05/2020

/*/
Static Function MaVldFuncD()

Local cMsg 	:= ""

cMsg += Iif( !fisFindFunc('FISXCOFINS')   , "FISXCOFINS.PRW."  + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXCRDPRE')   , "FISXCRDPRE.PRW."  + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXII')       , "FISXII.PRW."      + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXISS')      , "FISXISS.PRW."     + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXPIS')      , "FISXPIS.PRW."     + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXDC5602')   , "FISXPIS.PRW."     + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXAFRMM')    , "FISXAFRMM.PRW."   + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXCIDE')     , "FISXCIDE.PRW."    + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXCPRB')     , "FISXCPRB.PRW."    + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXCSLL')     , "FISXCSLL.PRW."    + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISVALDIFAL')  , "FISXDIFAL.PRW."   + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXFABOV')    , "FISXFABOV.PRW."   + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXFACS')     , "FISXFACS.PRW."    + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXFAMAD')    , "FISXFAMAD.PRW."   + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXFASE')     , "FISXFASE.PRW."    + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISFECP')      , "FISXFECP.PRW."    + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXFEEF')     , "FISXFEEF.PRW."    + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXFETHAB')   , "FISXFETHAB.PRW."  + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXFNDSUL')   , "FISXFNDSUL.PRW."  + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXFUMIPQ')   , "FISXFUMIPQ.PRW."  + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXFUNDESA')  , "FISXFUNDESA.PRW." + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXFUNRUR')   , "FISXFUNRUR.PRW."  + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXVICMS')    , "FISXICMS.PRW."    + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXDESCZF')   , "FISXICMS.PRW."    + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISBASSOL')    , "FISXICMSST.PRW."  + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXDBST')     , "FISXICMSST.PRW."  + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXIMA')      , "FISXIMA.PRW."     + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXINSS')     , "FISXINSS.PRW."    + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXIPI')      , "FISXIPI.PRW."     + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXIR')       , "FISXIR.PRW."      + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXPROTEG')   , "FISXPROTEG.PRW."  + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXSENAR')    , "FISXSENAR.PRW."   + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXSEST')     , "FISXSEST.PRW."    + CRLF , "" )
cMsg += Iif( !fisFindFunc('FISXTPDP')     , "FISXTPDP.PRW."    + CRLF , "" )

//Verifica se algum fonte não está disponível, e abortará a matxfis, exibindo o nome dos fontes
If !Empty(cMsg)
	MaFisFinal(STR0055 + CRLF + CRLF + cMsg) //"Erro - Função Não Localizada no RPO. Atualize o Fonte: "
EndIF

Return


/*/{Protheus.doc} MColTrbGen()
Função utilizada para montar o aCols do tributo genérico

@author Renato Rezende
@since 17/08/2020
/*/
Static Function MColTrbGen()

Local lCJ3 			:= fisExtTab('12.1.2310', .T., "CJ3")
Local aColTrbGen 	:= {{Space(4), CriaVar("F2D_TRIB"), CriaVar("F2B_DESC"), CriaVar("F2D_BASE"), CriaVar("F2D_ALIQ"), CriaVar("F2D_VALOR"), .F.}}

//Caso tenha a tebela CJ3 retiro a ultima posição e incluo as colunas novas
If lCJ3
	aColTrbGen := {{Space(4), CriaVar("F2D_TRIB"), CriaVar("F2B_DESC"), CriaVar("F2D_BASE"), CriaVar("F2D_ALIQ"), CriaVar("F2D_VALOR"),CriaVar("CJ3_CST"),;
				   CriaVar("CJ3_VLTRIB"),CriaVar("CJ3_VLISEN"),CriaVar("CJ3_VLOUTR"),CriaVar("CJ3_VLNTRI"),CriaVar("CJ3_VLDIFE"),CriaVar("CJ3_VLMAJO"), .F.}}
EndIf

Return aColTrbGen

//-----------------------------------------------------------------
/*/
Função criada pelo MI
https://jiraproducao.totvs.com.br/browse/DMICNS-9038
/*/
//----------------------------------------------------------------
Function MaRatBasT(cNumImp,nItem,nAliq,nBaseRat,nDecs,BaseIt)
Local nX	  		:= 0	//controle de loop
Local nFator		:= 0
Local nUltIt		:= 0
Local nBseRateado	:= 0
	
	aNFItem[nItem][IT_BASEIMP][cNumImp]	:= BaseIt //Asigna base actual al item
	aNFItem[nItem][IT_ALIQIMP][cNumImp]	:= nAliq  //Asigna la alicuota al item actual
	
	For nX := 1 To Len(aNFItem)
		If aNFItem[nX][IT_ALIQIMP][cNumImp] == nAliq
			nFator	:= aNFItem[nX][IT_BASEIMP][cNumImp] / nBaseRat
			aNFItem[nX][IT_BASEIMP][cNumImp] := NoRound( nFator * nBaseRat , nDecs )
			nBseRateado += aNFItem[nX][IT_BASEIMP][cNumImp]
			nUltIt	:= nX	//Guarda el ultimo item ajustado
		Endif
	Next nX
	
	//Si hay diferencia la ajusta en el ultimo item ajustado
	If nUltIt > 0 .and. nBaseRat <> nBseRateado
		aNfItem[nUltIt][IT_BASEIMP][cNumImp] += (nBaseRat-nBseRateado)
	EndIf

Return aNfItem[nItem][IT_BASEIMP][cNumImp]


/*/{Protheus.doc} AltTribLeg
	(Função responsavel por converter alteração de referencia legado em referencia do configurador)
	
	@author Rafael Oliveira
    @since 23/11/2020
    @version 12.1.27

	@param:	
	aNFItem-> Array com dados item da nota
	nItem  -> Item que esta sendo processado	
	ccampo -> Campo que esta sendo alterado
	aTrbGen -> Array com sigra e referencia a ser recalculada

	/*/
Static Function AltTribLeg(aNfItem,nItem,ccampo,aTrbGen)
Local cCampoConv:= ""
Local nPosGen	:= 0
Local aID		:={}
Local nX,nR		:= 0
Local aMVPPDIFAL := &(fisGetParam('MV_PPDIFAL',''))


//CIDE
IF ChkTribLeg(aNFItem, nItem, TRIB_ID_CIDE)
	cCampoConv := CIDEConvRf(aNfItem,nItem,ccampo)
	IF !EmpTy(cCampoConv)
		nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(TRIB_ID_CIDE)})	
	Endif
Endif
//IPI
IF EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, TRIB_ID_IPI)
	cCampoConv := IPIConvRf(aNfItem,nItem,ccampo)
	IF !EmpTy(cCampoConv)
		nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(TRIB_ID_IPI)})
	Endif
Endif
//FUMIPQ
IF EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, TRIB_ID_FUMIPQ)
	cCampoConv := FMPQConvRf(aNfItem,nItem,ccampo)
	IF !EmpTy(cCampoConv)
		nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(TRIB_ID_FUMIPQ)})
	Endif
Endif
//PROTEGE-GO
IF EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, TRIB_ID_PROTEG)
	cCampoConv := PROTConvRf(aNfItem,nItem,ccampo)
	IF !EmpTy(cCampoConv)
		nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(TRIB_ID_PROTEG)})
	Endif
Endif
//SENAR
IF EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, TRIB_ID_SENAR)
	cCampoConv := SNARConvRf(aNfItem,nItem,ccampo)
	IF !EmpTy(cCampoConv)
		nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(TRIB_ID_SENAR)})
	Endif
Endif
//FEEF
IF EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, TRIB_ID_FEEF)
	cCampoConv := FEEFConvRf(aNfItem,nItem,ccampo)
	IF !EmpTy(cCampoConv)
		nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(TRIB_ID_FEEF)})
	Endif
Endif
//CSLL
IF EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, TRIB_ID_CSLL)
	cCampoConv := CSLLConvRf(aNfItem,nItem,ccampo)
	IF !EmpTy(cCampoConv)
		nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(TRIB_ID_CSLL)})
	Endif
Endif
//CPRB
IF EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, TRIB_ID_CPRB)
	cCampoConv := CPRBConvRf(aNfItem,nItem,ccampo)
	IF !EmpTy(cCampoConv)
		nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(TRIB_ID_CPRB)})
	Endif
Endif

//IR
IF EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, TRIB_ID_IR)
	cCampoConv := IRConvRf(aNfItem,nItem,ccampo)
	IF !EmpTy(cCampoConv)
		nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(TRIB_ID_IR)})
	Endif
Endif

//INSS / Patronal / Aposentadoria Especial
aID:={TRIB_ID_INSS,TRIB_ID_INSSPT,TRIB_ID_SECP15,TRIB_ID_SECP20,TRIB_ID_SECP25}
For nR := 1 to 5
	If EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, aID[nR])
		cCampoConv := INSSConvRf(aNfItem, nItem, ccampo, nR)
		If !EmpTy(cCampoConv)
			nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(aID[nR])})
		EndIf
	EndIf
Next nR

//II
IF EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, TRIB_ID_II)
	cCampoConv := IIConvRf(aNfItem,nItem,ccampo)
	IF !EmpTy(cCampoConv)
		nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(TRIB_ID_II)})
	Endif
Endif

//Credito Presumido
aID := {TRIB_ID_PRES_ICMS,TRIB_ID_PRES_ST,TRIB_ID_PRES_CARGA,TRIB_ID_PRODEPE}
For nX := 1 to 4
	If EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, aID[nX])
		cCampoConv := CRDConvRf(aNfItem, nItem, ccampo, nX)
		If !EmpTy(cCampoConv)
			nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(aID[nX])})
		EndIf
	EndIf
Next

//FECP
aID := {TRIB_ID_FECPIC,TRIB_ID_FCPST,TRIB_ID_FCPCMP,TRIB_ID_FCPCMP}
For nX := 1 to 4
	If EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, aID[nX])
		cCampoConv := FCPConvRf(aNfItem, nItem, ccampo, nX, aNfCab ,aMVPPDIFAL)
		If !EmpTy(cCampoConv)
			nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(aID[nX])})
		EndIf
	EndIf
Next

//DIFAL
aID := {TRIB_ID_DIFAL,TRIB_ID_CMP,TRIB_ID_ANTEC}
For nX := 1 to 3
	If EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, aID[nX])
		cCampoConv := DifConvRf(aNfItem, nItem, ccampo, nX)
		If !EmpTy(cCampoConv)
			nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(aID[nX])})
		EndIf
	EndIf
Next

//PIS
aID := {TRIB_ID_PIS,TRIB_ID_PISST,TRIB_ID_PISRET,TRIB_ID_PISMAJ}
For nX := 1 to 4
	If EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, aID[nX])
		cCampoConv := PISConvRf(aNfItem, nItem, ccampo, nX)
		If !EmpTy(cCampoConv)
			nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(aID[nX])})
		EndIf
	EndIf
Next

//COFINS
aID := {TRIB_ID_COF,TRIB_ID_COFST,TRIB_ID_COFRET,TRIB_ID_COFMAJ}
For nX := 1 to 4
	If EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, aID[nX])
		cCampoConv := COFConvRf(aNfItem, nItem, ccampo, nX)
		If !EmpTy(cCampoConv)
			nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(aID[nX])})
		EndIf
	EndIf
Next

//ISS
aID := {TRIB_ID_ISS,TRIB_ID_ISSBI,TRIB_ID_DEDUCAO}
For nR := 1 to 3
	If EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, aID[nR])
		cCampoConv := ISSConvRf(aNfItem, nItem, ccampo, nR)
		If !EmpTy(cCampoConv)
			nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(aID[nR])})
		EndIf
	EndIf
Next

//ICMS, Frete Autonomo, Desoneração zona franca, diferimento, credito de apuração
aID := {TRIB_ID_ICMS,TRIB_ID_FRTAUT,TRIB_ID_ICMDES,TRIB_ID_ESTICM}
For nR := 1 to 4
	If EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, aID[nR])
		cCampoConv := ICMSConvRf(aNfItem, nItem, ccampo, nR, aNfCab)
		If !EmpTy(cCampoConv)
			nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(aID[nR])})
		EndIf
	EndIf
Next
//ICMS-ST
aID := {TRIB_ID_ICMSST,TRIB_ID_FRTEMB}
For nR := 1 to 2
	If EmpTy(cCampoConv) .and. ChkTribLeg(aNFItem, nItem, aID[nR])
		cCampoConv := ICSTConvRf(aNfItem, nItem, ccampo, nR)
		If !EmpTy(cCampoConv)
			nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_IDTRIB]) == AllTrim(aID[nR])})
		EndIf
	EndIf
Next


//Caso encontre A rereferencia e a converta, refaz configurador e legado
If nPosGen > 0
	aTrbGen := {aNfItem[nItem][IT_TRIBGEN][nPosGen][1],cCampoConv}		
	cCampo := "IT_TRIBGEN"		
Endif


Return ccampo


/*/
{Protheus.doc} GetPosTes
Função resposável por retornar a posição do campo da TES.
Criada para evitar redundância no código e para encapsular o ajuste feito por parceiro
Totvs conforme a seguinte ISSUE - https://jiraproducao.totvs.com.br/browse/DSERFISE-913
	
@author Anedino dos Santos
@since 17/06/2021
@version 12.1.27

@param:	
aHeader -> Array com os metadados dos campos do aCols

@return:
nPosTES -> Posição do campo que recebe a TES
/*/ 
Function GetPosTes(aHeader)

Local cAliasTs := IIF(len(aHeader)>0,SubStr(aHeader[1,2],1,AT("_",aHeader[1,2])) + "TES","")
Local nPosTES  := GdFieldPos(cAliasTs)

If nPosTES == 0 // Caso não encontre o campo, pesquisa o nome como ???_CODTES
	cAliasTs := IIF(len(aHeader)>0,SubStr(aHeader[1,2],1,AT("_",aHeader[1,2])) + "CODTES","")
	nPosTES  := GdFieldPos(cAliasTs)
EndIf

Return nPosTES

/*/{Protheus.doc} ZfDedBCofPis
	Função responsável por auxilizar o cálculo do pis e cofins desonerado Zona Franca de Manaus.

	
	@Rhuan Carvalho
	@since 04/03/2022
	@12.1.27
	
/*/
Static Function ZfDedBCofPis(nItem)

	If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"  ) .And. (fisGetParam('MV_DEDBPIS','') $ "S|I|P|D") .And. (fisGetParam('MV_DEDBCOF','') $ "S|I|P|D")
		If !(aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1")
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")

			// MV_DEDBPIS = D foi criado para trabalhar em conjunto com MV_DEDBCPR = D quando há configuração para CPRB
			// MV_CPRBNF  - Define se a CPRB deverá ser calculada através do Documento Fiscal. (.T. calcula .F. não calcula)
			// MV_DEDBPIS = D - será subtraído da base do PIS o valor do ICMS/PIS/COFINS Zona Franca de MANAUS.
			// MV_DEDBCPR = D - será subtraído da base da CPRB o valor do ICMS/PIS/COFINS Zona Franca de MANAUS
			if (fisGetParam('MV_DESCZF',.T.) .and. fisGetParam('MV_CPRBNF',.F.)) .AND. (fisGetParam('MV_DEDBPIS','') == "D" .AND. fisGetParam('MV_DEDBCPR','N') == "D");
				.AND.(aNfItem[nItem][IT_EMISNFORI] >= fisGetParam('MV_ICMDSDT','') .OR. Empty(aNfItem[nItem][IT_EMISNFORI])) .And. aNfItem[nItem][IT_DESCZF] > 0 
				
				//Nesse trecho é feito o cálculo da base de PIS e COFINS simultaneamente, para não haver o descasamento das bases do PIS e COFINS.			
				aNfItem[nItem][IT_BASEPS2] -= aNfItem[nItem][IT_DESCZF]
				aNfItem[nItem][IT_BASECF2] -= aNfItem[nItem][IT_DESCZF]

				aNfItem[nItem][IT_BASECF2] -= aNfItem[nItem][IT_VALICM]
				aNfItem[nItem][IT_BASEPS2] -= aNfItem[nItem][IT_VALICM]

				//Após o recálculo simultaneo das bases, é feito o recalculo do valor de PIS e COFINS.
				MaFisCOFINS(nItem,"CF2","VLR")
				MaFisPIS(nItem,"PS2","VLR")
				
			EndIf
		EndIf
	EndIf
	
Return

/*/{Protheus.doc} ZfCalcCofPis
	Realiza de forma simultânea os cálculos referentes à desoneração do Suframa para o PIS e COFINS, evitando que haja disparidades entre as bases de ambos.

	
	@leandro.faggyas
	@since 01/12/2022
	@12.1.27
	
/*/
Static Function ZfCalcCofPis(nItem)
Local lProdNac := .T.
Local lMVRPCBIZF := fisGetParam('MV_RPCBIZF',.F.) .And. aNfCab[NF_UFDEST]$fisGetParam('MV_RPCBIUF','')
	
	If (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) <> 0

		lProdNac := ChkProdNac(nItem)

		If !lProdNac .And. !(aNFCab[NF_TIPONF] $ "B|D") .And. !lMVRPCBIZF
			aNfItem[nItem][IT_VALMERC]-= (aNfItem[nItem][IT_DESCZFPIS] + aNfItem[nItem][IT_DESCZFCOF])
		EndIf
		
		//Após o recálculo simultaneo das bases, é feito o recalculo do valor de PIS e COFINS.
		MaFisCOFINS(nItem,"CF2","VLR")
		MaFisPIS(nItem,"PS2","VLR")
	EndIf

Return

/*/{Protheus.doc} ChkProdNac
	Verifica se o produto será considerado como nacional ou estrangeiro, observando de forma prioritária o parâmetro MV_IMPZFRC. Caso o parâmetro esteja em branco, será verificado o campo B1_IMPZFRC.

	
	@leandro.faggyas
	@since 20/12/2022
	@12.1.27
	
/*/
Static Function ChkProdNac(nItem)
Local lRet := IIF(!Empty(fisGetParam('MV_IMPZFRC','')),  !(SubStr( aNfItem[nItem][IT_CLASFIS],1,1 ) $ fisGetParam('MV_IMPZFRC','')) ,aNfItem[nItem][IT_PRD][SB_IMPZFRC] $ " N")
		
Return lRet

/*/{Protheus.doc} FisXTelem
	(Funão responsavel por controlar telemetria da MATXFIS e seus dependentes)
	
	@author Rafael Oliveira
	@since 25/04/2022
	
	@param cFunction Fonte que recebera relemetria
	@param nItem Item em processamento	
	
/*/
Static Function FisXTelem(cFunction, nItem)
DEFAULT nItem := 1

IF lMetrica
	
	Do Case	
		Case !lCFGTelemet .and. cFunction == "CONFXFIS" .and. ValType(aNFItem[nItem][IT_TRIBGEN]) == "A" .and. Len(aNFItem[nItem][IT_TRIBGEN]) > 0
			//Adiciona Telemetria quando calculado tributos pelo configurador
			
			FWLsPutAsyncInfo("LS006",RetCodUsr(),"09","CONFXFIS")
			lCFGTelemet := .T.		
			//Conout("FWLsPutAsyncInfo(LS006,RetCodUsr(),09,CONFXFIS)")


		Case  !lTelemetria .and. cFunction == "MATXFIS"
			//Adiciona Telemetria quando calculado tributos pelo configurador
					
			FWLsPutAsyncInfo("LS006",RetCodUsr(),"09","MATXFIS")
			lTelemetria := .T.
			//Conout("FWLsPutAsyncInfo(LS006,RetCodUsr(),09,MATXFIS)")
	Endcase
Endif

Return 

/*/{Protheus.doc} ValidCfg
	Função responsavel por verificar se utiliza o configurador de tributos
	
	@author Julia Mota, Rafael Oliveira
	@since 18/11/2022
	
/*/
Function ValidCfg(aNfCab,cCampo,aNfItem,nItem) //essa função valida se os operandos foram utilizados ou alterados
Local lret :=  aNfCab[NF_TEMF2B] .And. cCampo <> "IT_TRIBGEN" .AND. (Empty(aNfItem[nItem][IT_ID_LOAD_TRBGEN]) .Or. (!Empty(aNfItem[nItem][IT_ID_LOAD_TRBGEN]) .AND. IsInCallStack("VALIDGET")))

Return lret

//-------------------------------------------------------------------
/*/{Protheus.doc} AllCfops
Função que percorrerá todos os CFOPs da SX5 para realizar a carga automática
@author Julia Mota
@since 13/02/2023
@version 12.1.2210
/*/
//-------------------------------------------------------------------
Static Function AllCfops()

Local cCfop     := ""
Local nX        := 0
Local aDadosSX5 := FWGetSX5( "13" )

//Posiciono na SX5 a tabela 13 de CFOPs
For nX := 1 to Len(aDadosSX5)
    cCfop         := Alltrim(aDadosSX5[nX][3])
	oJCFOP[cCfop] := Alltrim(aDadosSX5[nX][4])
Next

ASize(aDadosSX5,0)

Return oJCFOP

/*/{Protheus.doc} TpCliFor
	
	Objetivo da função é converter o tipo do fornecedor para um tipo válido, evitando recalculo indevido dos impostos em caso de alteração de número de notas ou série. 

	@Rhuan Carvaho
	@since 27/11/2023
	@version version
	@tipoCliFor, Caracter, Tipo do cliente/fornecedor passado quando há o recebimento de NF_TPCLIFOR
	@cTipo, Caracter, tipo do cliente/fornecedor corrigido 
	
	/*/
Function TpCliFor(tipoCliFor)
	
	Local cTipo := tipoCliFor

	If cTipo == "J" .Or. cTipo == " "
		cTipo := "R"
	EndIF

Return cTipo
/*/{Protheus.doc} ChkDescCF
Essa verificação é feita para operações de venda para consumidor final com desconto no item. 
A depender de um conjunto de parâmetros, essa função pode retornar verdadeiro ou falso, com o intuito de definir se o desconto de PIS/COFINS desonerado será aplicado na base do ICMS.
Caso a operação não seja para um consumidor final, também retornará verdadeiro.

@author leandro.faggyas
@since 04/12/2023
@version 1.0
/*/
Static Function ChkDescCF( lMVRPCBIZF, nItem )
Local lRet := .F.

If !(aNFitem[nItem][IT_DESCONTO] > 0 .And.  aNFCab[NF_TPCLIFOR]  == "F") .Or. (lMVRPCBIZF .And. ChkProdNac(nItem) .And. fisGetParam('MV_RPCBICF',.F.) .And. aNFCab[NF_TPCLIFOR] =="F")
	lRet := .T.
EndIf

Return lRet

/*/{Protheus.doc} CrdPresAdd
 Função responsavel por gravar referencias com base no configurador

 	@author leandro.faggyas
    @since 10/01/2014
    @version 12.1.2410

	@param:	
	nItem  -> Item que esta sendo processado	
    aNFCab-> Array com dados do cabeçalho da nota
/*/
Static Function CrdPresAdd(nItem, lRecalc, lCrdCPRB, lCrdPisCof, nValPIS, nValPS2, nValPS3, nValCOF, nValCF2, nValCF3)

If lRecalc
	If lCrdPisCof //O crédito presumido é calculado somente na MaFisLF, portanto caso ele seja somado à base de PIS/COFINS esses tributos devem ser calculados novamente

		If nValPIS > 0
			MaFisPIS(nItem,"PIS")
		EndIf
		If nValCOF > 0
			MaFisCOFINS(nItem,"COF")
		EndIf

		If nValPS2 > 0
			MaFisPIS(nItem,"PS2")
		EndIf
		If nValCF2 > 0
			MaFisCOFINS(nItem,"CF2")
		EndIf

		If nValPS3 > 0
			MaFisPIS(nItem,"PS3")
		EndIf
		If nValCF3 > 0
			MaFisCOFINS(nItem,"CF3")
		EndIf

	EndIf

	If lCrdCPRB
		MaFisCPRB(nItem)
	EndIf
EndIf

Return


/*/{Protheus.doc} VerifItens
	Percorre o array aNfItems e verifica se os itens estão com os campos de tributos do configurador preenchidos
	e prepara um objeto json contendo a quantidade de vezes por tributos que foi utilizado do configurador.
	@type  Function
	@author Erich Buttner
	@since 12/01/2024
	@version 12.1.2310, 12.1.2210
	@param
	@return 
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function VerifItens()
Local nItem, nE := 0
Local jTributos := JsonObject():New()

For nItem := 1 To Len(aNfItem)

	If .not. Empty(aNFItem[nItem][IT_TRIBGEN])

		aTrbConfig := ListTLegTG(aNfItem,nItem)

		For nE := 1 To Len(aTrbConfig)

			If aTrbConfig[nE][2]

				If jTributos:hasProperty(aTrbConfig[nE][1])
					jTributos[aTrbConfig[nE][1]] += 1
				Else
					jTributos[aTrbConfig[nE][1]] := 1
				Endif				

			EndIf

		Next nE

		aSize(aTrbConfig,0)
		
	EndIf

Next nItem


XFSTELECFG(jTributos)

FreeObj(jTributos)
	
Return 

/*/{Protheus.doc} XFSTELECFG
	Telemetria de uso dos impostos calculados pelo configurador

	@type  Static Function
	@author Erich Buttner
	@since 11/01/2024
	@version 12.1.2310, 12.1.2210
	@param 
	@return
	@example
	(examples)
	@see 
	/*/
Static Function XFSTELECFG(jTributos)

Local nE := 0
Local aNames := jTributos:GetNames()

For nE := 1 To Len(aNames)

	FWCustomMetrics():setMetric("Impostos utilizados pelo configurador de tributos", "totvs-fiscal-tributos-configurador_total IDTRIB: "+aNames[nE], cValToChar(jTributos[aNames[nE]]), , , "CONFXFIS")

Next nE

Return

/*/{Protheus.doc} CargaConfig
	Faz carga dos tributos genéricos se o ID do tributo genérico for preenchido.

	@type  Static Function
	@author Rafael Oliveira
	@since 05/04/2024
	@version 12.1.2310
	@param aNFCab, array, array com os dados do cabeçalho da nota
	@param aNfItem, array, array com os itens da nota
	@param nItem, numeric, item que esta sendo processado
	@param aTGITRef, array, array com os tributos genéricos
	@param aPos, array, array com teste de existencia de campos
	@param aDic, array, array com teste de existencia de tabelas
	@param aHmFor, array, HashMap com o mapeamento dos operandos e formulas
	@param lReprocess, logical, flag de reprocessamento
	@return void	
/*/

Static function CargaTribGen(aNFCab, aNfItem, nItem, aTGITRef, aPos, aDic, aHmFor, lReprocess)

Local aTribLegA   := {}
Local aTrbLegCalc := {}

	If !Empty(aNfItem[nItem][IT_ID_LOAD_TRBGEN]) .AND. fisExtTab('12.1.2310', .T., 'F2D')
		xFisLoadTG(@aNfItem, nItem,, Len(aTGITRef) ,aNFCab, aPos, aDic, aHmFor, lReprocess)
		//Telemetrica Confxfis
		FisXTelem("CONFXFIS", nItem)
		
		//Obtem a lista dos tributos genéricos com ID de tributo legado
		aTribLegA	:= Iif(aNfCab[NF_CHKTRIBLEG] , ListTLegTG(aNFItem, nItem),{})

		//Atualiza Referencia Legado
		IF Len(aTribLegA) > 0
			//Obtem a lista de tributos legados que precisam ser atualizados
			aTrbLegCalc	:= Iif(aNfCab[NF_CHKTRIBLEG] , ChkCalcTLeg(aTribLegA, aTribLegA),{})

			//Refaz aqui o cálculo dos tributos legados se necessário
			If Len(aTrbLegCalc) > 0
				AtuTrbLeg(aTrbLegCalc, nItem, .T.)
			EndIf
		Endif
	EndIf

	aSize(aTribLegA,0)
	aSize(aTrbLegCalc,0)

Return

/*/{Protheus.doc} ReprocTribgen
	Aqui chama função para refazer o livro dos tributos genéricos no reprocessamento

	@type  Static Function
	@author Rafael Oliveira
	@since 05/04/2024
	@version 12.1.2310
	@param aNFItem, array, array com os itens da nota
	@param nItem, numeric, item que esta sendo processado
	@param aNFCab, array, array com os dados do cabeçalho da nota
	@param aHmFor, array, HashMap com o mapeamento dos operandos e formulas

	@return void
/*/
Static Function ReprocTribGen(aNFItem, nItem, aNFCab, aHmFor)

Local nTrbGen := 0

	For nTrbGen := 1 to Len(aNfItem[nItem][IT_TRIBGEN])
		FisLivroTG(aNfItem, nItem, nTrbGen, aNFCab, aHmFor, .F., .T.)
	Next nTrbGen

Return

/*/{Protheus.doc} fisExttab

	Objetivo da função é verificar se o alias existe no dicionário de dados

	@type  Function
	@author Rafael Oliveira
	@since 01/12/2023
	@version 12.1.2310
	@param cAlias, character, alias a ser verificado
	@param cRelease, character, release da inclusão do alias
	@param lValidRelease, logical, indica se a release será validada
	@return lRet, logical, retorna .T. caso o alias exista no dicionário de dados
	@example fisExtTab('12.1.2310', .T., 'SA1')
/*/
Function fisExtTab(cRelease, lValidRelease, cAlias)
	Local lRet := .F.

	Default cRelease := '12.1.2310'
	Default lValidRelease := .T.

	//Verifica se a release será validada
	//Se a release atual for maior que a release de inclusão do campo retorna .T.
	//O trecho comentado será tratado na issue https://jiraproducao.totvs.com.br/browse/DSERFISE-9735
	//If cPaisLoc == "BRA" .and. lValidRelease .and. cRpoRelease > cRelease
	//	lRet := .T.
	//Else 
	IF !Empty(cAlias)
		cAlias := AllTrim(cAlias)

		lRet := jAlias[cAlias]

		IF lRet == NIL // Caso não exista no cache do JSON pesquisa no dicionário de dados
			lRet := AliasIndic(cAlias)
			jAlias[cAlias] := lRet
		EndIF
	EndIF
	//Endif

Return lRet

/*/{Protheus.doc} fisFindFunc
	
	Objetivo da função é verificar se a função existe no repositório de funções

	@type  Function
	@author Rafael Oliveira
	@since 01/12/2023
	@version 12.1.2310
	@param cFuncao, character, função a ser verificado
	@return lRet, logical, retorna .T. caso a função exista no repositório de funções
	@example fisFindFunc('SA1')

/*/

Function fisFindFunc(cFuncao)
	Local lRet := .F.

	IF !Empty(cFuncao)
		cFuncao := AllTrim(cFuncao)

		lRet := jFunctions[cFuncao]

		IF lRet == NIL // Caso não exista no cache do JSON pesquisa no dicionário de dados
			lRet := FindFunction(cFuncao)
			jFunctions[cFuncao] := lRet
		EndIF
	EndIF

Return lRet

/*/{Protheus.doc} fisGetParam
	
	Objetivo da função é obter o valor do parametro, caso parametro não exista no dicionário de dados, setorá o valor default

	@type  Function
	@author Rafael Oliveira
	@since 01/12/2023
	@version 12.1.2310
	@param cParametro, character, parametro a ser verificado
	@param cDefault, character, valor default do parametro
	@return xContent, variant, retorna o valor do parametro ou o valor default
	
	@example 
		fisGetParam('MV_ALIQISS',0)
		@example fisGetParam('MV_ALINSB1',"")

/*/

Function fisGetParam(cParametro,cDefault)
	Local xRet := cDefault
	Local cChave := ""

	IF !Empty(cParametro)
		cChave := cEmpAnt + cFilAnt + '_' + ALLTRIM(cParametro)

		xRet := jParametro[cChave]

		IF xRet == NIL // Caso não exista no cache do JSON pesquisa no dicionário de dados	
			xRet := SUPERGETMV(cParametro, .F., cDefault)			
			jParametro[cChave] := xRet
		EndIF
	EndIF

Return xRet

/*/{Protheus.doc} fisExtPE
	
	Objetivo da função é verificar se o ponto de entrada existe no repositório

	@type  Function
	@author Rafael Oliveira
	@since 01/12/2023
	@version 12.1.2310
	@param cPE, character, ponto de entrada a ser verificado
	@return lRet, logical, retorna .T. caso o ponto de entrada exista no repositório
	@example fisExtPE('MaCCOFAPU')

/*/

Function fisExtPE(cPE)
	Local lRet := .F.

	IF !Empty(cPE)		

		lRet := jPE[cPE]

		//Se não existir no cache do JSON pesquisa no dicionário de dados
		IF lRet == NIL
			lRet := ExistBlock(cPE)
			jPE[cPE] := lRet
		EndIF
	EndIF

Return lRet

/*/{Protheus.doc} fisExtCmp

	Objetivo da função é verificar se o campo existe no dicionário de dados.

	@type  Function
	@author Rafael Oliveira
	@since 01/12/2023
	@version 12.1.2310
	@param cAlias, character, alias a ser verificado
	@param cCampo, character, campo a ser verificado
	@param cRelease, character, release da inclusão do campo
	@param lValidRelease, logical, indica se a release será validada
	@return lRet, logical, retorna .T. caso o campo exista no dicionário de dados
	@example fisExtCmp('12.1.2310', .T.,'SA1','A1_COD')

	fisExtCmp('12.1.2310', .T.,'SA1','A1_COD', '12.1.2310')
/*/
Function fisExtCmp(cRelease, lValidRelease, cAlias, cCampo)
	Local lRet := .F.
	Local cChave := ""
	Local aArea := {}
	Local aAreaSX3 := {}
	
	Default cRelease := '12.1.2310'
	Default lValidRelease := .T.

	//Verifica se a release será validada
	//Se a release atual for maior que a release de inclusão do campo retorna .T.
	//Trecho comentado por conta de erros encontrados na 2410, validaremos com mais calma posteriormente
	//If cPaisLoc == "BRA" .and. lValidRelease .and. cRpoRelease > cRelease
	//	lRet := .T.
	//Else 
	IF !Empty(cAlias) .and. !Empty(cCampo)

		cChave := ALLTRIM(cAlias) + '_' + ALLTRIM(cCampo)

		lRet := jCampos[cChave]

		//Se não existir no cache do JSON pesquisa no dicionário de dados
		IF lRet == NIL

			//Valida alias e campo
			IF fisExtTab(cRelease, .T., cAlias) 

				IF (cAlias)->(FieldPos(cCampo)) > 0 //checa no banco de dados
					lRet := .T.
				Elseif Len(FWSX3Util():GetFieldStruct(cCampo)) > 0
					aArea := GetArea()
					aAreaSX3 := SX3->(GetArea())
					If GetSx3Cache(cCampo,"X3_CONTEXT") == 'V' //checa se o campo possui contexto virtual no SX3
						lRet := .T.
					EndIf
					RestArea(aAreaSX3)
					RestArea(aArea)

                    aSize(aArea,0)
					aSize(aAreaSX3,0)
				Else
					lRet := .F.
				Endif

			Else
				lRet := .F.
			Endif

			jCampos[cChave] := lRet
		Endif
	EndIF
	//Endif

Return lRet

/*/{Protheus.doc} RetNumIDTRb
	Função Responsável por retornar a posição do ID do tributo do configurador
	de tributos.
	
	@type   Function
	@author carvalho.rhuan
	@since 11/06/2024
	@version 12.1.2410
	@return nPos, numero, Número da posição do tributo
	
/*/
Function RetNumIDTRb(aNfItem, nItem, TribGen, IDTRIB)
Return aScan(aNfItem[nItem][TribGen],{|x| Alltrim(x[12])==IDTRIB})

/*/{Protheus.doc} IDZFTRBGen
	Função Responsável por retornar se é um ID de tributo da zona Franca calculado 
	pelo configurador de tributos.
	
	@type  Function
	@author carvalho.rhuan
	@since 12/06/2024
	@version 12.1.2410
	
/*/
Function IDZFTRBGen(nITem)
Return (ChkTGItem(TRIB_ID_ICMDES, nItem) .and. PosICDesZF(aNfItem, nItem, IT_TRIBGEN, TRIB_ID_ICMDES) > 0) .or. ChkTGItem(TRIB_ID_DZFPIS, nItem) .or. ChkTGItem(TRIB_ID_DZFCOF, nItem)

//jTamSX3

/*/{Protheus.doc} FisTamSX3
	
	Função responsavel por retornar o tamanho do campo informado, através de consultada Tamsx3()

	@type  Function
	@author Rafael Oliveira
	@since 01/12/2023
	@version version
	@param cAlias, character, alias a ser verificado
	@param cCampo, character, campo a ser verificado
	@return aRet, array, retorna o tamanho do campo e decimais
	@example
		FisTamSX3('SA1','COD')		
	@see (links_or_references)
	/*/

Function FisTamSX3(cAlias as string, cCampo as string)	
	Local aDefault 	:= {0/*tamanho*/,0/*decimal*/,""/*tipo do campo*/} as array
	Local cChave 		:= ""	as string

	IF !Empty(cCampo)
		cChave := ALLTRIM(cAlias) + ALLTRIM(cCampo)
		aRet := jTamSX3[cChave]

		IF (Empty(aRet))
			//Valida se o campo existe no dicionário de dados
			if fisExtCmp('12.1.2310', .T.,cAlias, cCampo)
				aRet := TamSX3(cCampo)
			Else		
				//Caso não exista
				aRet := aDefault
			Endif

			jTamSX3[cChave] := aRet
		EndIF
	EndIF

Return aRet

/*/{Protheus.doc} fisExtCFOP
	
	Objetivo da função é verificar se o CFOP existe no dicionário de dados

	@type  Function
	@author Rafael Oliveira
	@since 01/12/2023
	@version version
	@param cCFOP, character, CFOP a ser verificado
	@return lRet, logical, retorna .T. caso o CFOP exista no dicionário de dados
	@example fisExtCFOP('5102')	
	
	/*/
Function fisExtCFOP(cCFOP)
Local lRet := .F.

	IF !lAllCfops
		AllCfops() //Carrega todos os CFOPs da SX5
		lAllCfops := .T. //Seta a variável para não carregar novamente
	EndIF

	IF !Empty(cCFOP)
		lRet := oJCFOP:hasProperty(AllTrim(cCFOP))		
	EndIF
	
Return lRet

/*/{Protheus.doc} Mafiscache

	Função responsavel por guardar em cache os valores de quelquer tipo para serem reutilizados no processamento dos calculos fiscais, evitando assim a necessidade de realizar validações desnecessárias.
	
	@type  Function
	@author Rafael Oliveira
	@since 07/12/2023
	@version version
	@param cChave, character, chave para identificar o valor
	@param xValue, variant, valor a ser guardado em cache
	@param lEmpresa, logical, indica se a chave deve ser prefixada com a empresa e filial
	@return xRetorno, variant, retorna o valor guardado em cache
	@example

		Mafiscache('MV_ALIQISS',0)
		Mafiscache('MaFisSomaIt_Valid_B1_AFETHAB',,{|| fisExtCmp('12.1.2310', .T.,'SB1','B1_AFETHAB') .And. fisExtCmp('12.1.2310', .T.,'SA2','A2_RECFET') .And. fisExtCmp('12.1.2310', .T.,'SA1','A1_RECFET') .And. fisExtCmp('12.1.2310', .T.,'SF4','F4_CALCFET')})
		Mafiscache('ExisteCDA_xFilial("CDA")+cChaveSF',,{|| CDA->(MsSeek(xFilial("CDA")+cChaveSF)) } ,.T.)
	
	
	/*/
Function Mafiscache(cChave ,xValue , bBloco, lEmpresa)	
	Local xRetorno := .F.
	
	DEFAULT lEmpresa := .F.	
	DEFAULT bBloco := nil
	DEFAULT xValue := nil

	IF !Empty(xValue) .or. !Empty(bBloco)
		If lEmpresa
			cChave := cEmpAnt + cFilAnt + "_" + cChave
		EndIF	

		xRetorno := jCache[cChave]

		IF xRetorno == NIL
			
			If !EMPTY(bBloco)				
				xRetorno := Eval(bBloco)
			Else
				xRetorno := xValue
			EndIF

			jCache[cChave] := xRetorno			
		EndIF
	EndIF
	
Return xRetorno

/*/{Protheus.doc} xFsVerExce
	Função de verificação de exceção fiscal, que verifica se ja possui exceção fiscal processada .
	@type  Static Function
	@author Erich Buttner
	@since 15/01/2024
	@version 12.1.2210, 12.1.2310
	@param 
	@return nScan
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function xFsVerExce(nItem, cCampo)

Local nScan := 0
Local lClasFis	:= Len( Alltrim(aNfItem[nItem][IT_CLASFIS]) ) == 3
Local bCompareF7:= Nil
Local nTamGRTrb := FisTamSX3('SF7','F7_GRTRIB')[1]
Local cGRTrib	:= ""

Default cCampo	:= ""

If Empty( cGrTrib := aNFItem[nItem,IT_GRPTRIB] )
	cGrTrib := PadR( aNfItem[nItem][IT_PRD][SB_GRTRIB], nTamGRTrb)
EndIf

If !Empty(cGrTrib)

	bCompareF7	:= {|x| !Empty(x[IT_EXCECAO]) .And. x[IT_EXCECAO,4]==cGRTrib}

	If fisExtCmp('12.1.2310', .T.,'SF7','F7_ORIGEM') .And. fisExtCmp('12.1.2310', .T.,'SF7','F7_SITTRIB')

		/* O trecho abaixo foi copiado da funcao MaFisPreCalc(), pois as pilhas de recalculo possuem a chamada da MaExcecao() antes
			da MaFisPreCalc() - onde eh definida a Classificacao Fiscal. Por este motivo, preciso garantir que a informacao do
			IT_CLASFIS esteja correta para utilizar nas comparacoes da Excecao Fiscal.
			Essa alteracao foi feita para que nao se faca necessario alterar todas as pilhas de recalculo, considerando a chamada da
			MaFisPreCalc() antes da MaExcecao(). Essa mudanca sera feita na re-estruturacao das pilhas da MATXFIS.
			*/
		If  cCampo $ "IT_PRODUTO/IT_TES" .Or. !lClasFis
			If fisGetParam('MV_STFRETE',.F.) .And. ( AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE/CTA/CTF" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE]) )
				aNfItem[nItem][IT_CLASFIS]:= "0" + aNFItem[nItem][IT_TS][TS_SITTRIB]
			Else
				If aNfitem[nItem][IT_TIPONF] == "D" .And. !Empty( aNFItem[nItem][IT_RECORI]) .And. aNFCab[NF_OPERNF] == "E"
					dbSelectArea("SD2")
					MsGoto(aNFItem[nItem][IT_RECORI])
					 aNfItem[nItem][IT_CLASFIS] := SD2->D2_CLASFIS
				Else
					 aNfItem[nItem][IT_CLASFIS] :=aNfItem[nItem][IT_PRD][SB_ORIGEM] + aNFItem[nItem][IT_TS][TS_SITTRIB]
				EndIf
			EndIf
		Endif
		/* Verifico a necessidade de utilizar os codigos de origem e situacao tributaria
			na comparacao junto ao Grupo Tributario, e que a cada item ocorra essa
			verificacao para consistir a utilizacao do correto registro da SF7
			*/
		cOrigem		:= Iif( lClasFis , SubStr(aNfItem[nItem][IT_CLASFIS],1,1) , aNfItem[nItem][IT_PRD][SB_ORIGEM] )
		cSitTrib	:= Iif( lClasFis , SubStr(aNfItem[nItem][IT_CLASFIS],2,2) , aNFItem[nItem][IT_TS][TS_SITTRIB] )

		bCompareF7	:= {|x| !Empty(x[IT_EXCECAO]) .And. x[IT_EXCECAO,4]+x[IT_EXCECAO,28]+x[IT_EXCECAO,29] == cGRTrib+cOrigem+cSitTrib }
	Endif

	nScan := aScan( aNfItem , bCompareF7 )

EndIf
	
Return nScan

/*/{Protheus.doc} GetValidCpoUser
	Função responsavel por retornar campos não padrão do sistema que poderão ter suas referências carregadas na função MaFisRelImp através
	       do conteúdo do campo de validação do usuário no dicionário de dados SX3 ( X3_VLDUSER )

	@type  Static Function
	@author Nilson César
	@since 10/06/2025
	@version version
	@param cField - campo a ser verificado
	@return .T. quando campo autorizado e .F. caso contrário
	@example
/*/
Static Function GetValidCpoUser(cField)

Return cField $ 'D1_AFRMIMP|FT_AFRMIMP'


//-------------------------------------------------------------------
/*/{Protheus.doc} xRecReforma
Refaz os calculos da reforma tributaria para garantir que os tributos legados componham a base de calculo desses tributos corretamente

@param aNfCab, array, Informações cabeçalho da nota fiscal
@param aNfItem, array, Informações do item da nota fiscal
@param aPos, array, Cache dos fieldpos
@param aDic, array, Cache de aliasindic
@param nTGITRef, numeric, Item do tributo generico
@param aMapForm, array, HashMap com o mapeamento dos operandos e formulas
@param aDepTrib, array, Dependencia dos tributos
@param aDepVlOrig, array, informa o order que sera feito o seek
@param aFunc, array, 
@param aUltPesqF2D, array, 
@return nil, nil, nil
@author Matheus Bispo
@since 04/06/2025
@type static function
@version P12.1.2410

/*/
//-------------------------------------------------------------------
static function xRecReforma(aNfCab, aNfItem, nItem, aPos, aDic, nTGITRef, aHmFor, aDepTrib, aDepVlOrig, aFunc, aUltPesqF2D)
	local cTributosProc := "000060/000061/000062" as character //CBS e IBS - referencia da FSA168F2C (F2C)
	local nTamTrib := Len(aNfItem[nItem][IT_TRIBGEN]) as numeric
	local nTrbGen := 1 as numeric

	for nTrbGen := 1 to nTamTrib
		if aNfItem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_IDTRIB] $ cTributosProc
			xFisTrbGen(aNfCab, @aNfItem, nItem, "IT_TRIBGEN", "BSE|ALQ|VLR", aNfItem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_SIGLA], aPos, aDic, nTGITRef, aHmFor, aDepTrib, aDepVlOrig, aFunc, aUltPesqF2D)
		endIf
	next nTrbGen
return

/*/{Protheus.doc} IRRProg
	Funcao que ajusta os valores do IR progressivo para CPF quando
	definido que GERA DIRF Sim e Código de Retenção esteja no Parametro MV_RETIRRT
	@type Static Function
	@author Ricardo Henrique de Mello Lima
	@since 12/06/2025
	@version 12.1.2410
	/*/
Static Function IRRProg(aCodR,nPosCodR)

	Local dDataIRR := ddatabase

	if nPosCodR > 0 .and. Alltrim(aCodR[nPosCodr,4]) == "IRR"
		If ValType(dNewVenc) == "D" .and. !Empty(dNewVenc)
			dDataIRR := dNewVenc
		elseif ValType(DDEMISSAO) == "D" .and. !Empty(DDEMISSAO)
			dDataIRR := DDEMISSAO
		endif
		MaRecIR(dDataIRR,aCodR,nPosCodR)
	endif	
Return 
