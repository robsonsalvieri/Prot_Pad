#define K_TAB VK_TAB
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FISXFUN.CH"
Static aCposSF3
STATIC cFisArq as character
Static __RpoRelease := GetRPORelease()
Static lRetTypeDoc := __RpoRelease <= "12.1.2410"

/*


Ŀ
FUNCAO     FISXFUN   Autor  Juan Jose Pereira      Data  29.05.98   
Ĵ
DESCRICAO  Funcoes do modulo SIGAFIS.                                   
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                       
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                     
Ĵ
 Marcos Simidu29/05/98XXXXXXAcertos na funcao XFIS_IMPTERM na monta-  
                      XXXXXXgem do array para o SX1.                  
 Viviani      05/01/9919004 Tratamento da excecao para exportaao     
 Andreia      18/01/99xxxxx Tratamento de excecao fiscal para pessoa  
                            Fisica.                                   
 Andreia      22/01/99xxxxx Correcao de Bound Error AliqIcms()        
 Andreia      22/01/9919477ATratamanto de aliq.ICMS para devolucao de 
                            vendas de outro estado.                   
Aline C. Vale 24/09/99xxxxxxConsiderar Excecao Fiscal p/ISS (AliqICMs)
Hanna C.      19/05/0581411 Em NFs de devolucao manter o ICMS da NF   
                            Original                                  
ٱ



Ŀ
Funo    MatXAfixos Autor  Juan Jose Pereira      Data  30/01/96   
Ĵ
Descrio  Gera array aFixo com extrutura do SF3                        
Ĵ
 Uso       Generico                                                     
ٱ


*/
Function MatXAfixos()

If FindFunction("xFisAFixos")
	Return xFisAFixos()
Else
	MsgAlert(STR0045) 
	Final(STR0045) 
EndIf

Return NIL    

/*/

Ŀ
Funo     XF3_Observ()  Autor  Juan Jose Pereira  Data  05/12/95 
Ĵ
Descrio  Define mensagem de observacao a ser gravada no F3_OBSERV   
Ĵ
 Uso       Generico                                                   
ٱ


*/
FUNCTION XF3_Observ(cMsg,cTipo,nBICMRet,cTipoCli,nDesconto,cNFOri,cSerOri,cCFO,nValFun)

Static aNotaDiv := {}

If !Empty(cMsg)
	Return(cMsg)
Endif

cTipo	:=IIf(Empty(cTipo)	,	'N',cTipo)
cTipoCli:=IIf(Empty(cTipoCli),	'R',cTipoCli)
nDesconto:=IIf(Empty(nDesconto),	0,nDesconto)
cNFOri	:=IIf(Empty(cNFOri)	,	"",cNFOri)
cSerOri	:=IIF(Empty(cSerOri),	"",cSerOri)
cCFO	:=IIF(Empty(cCFO),		"",cCFO)
nValFun	:=IIf(Empty(nValFun),	0,nValFun)

nAchou := ASCAN(aNotaDiv,cNFOri)
If nAchou == 0 .And. !Empty(cNFOri)
    AADD(aNotaDiv,cNfOri)
Endif

If aNotaDiv != NIL .And. Len(aNotaDiv) > 1 
	If cTipo=="D" 
		cMsg:="DEVOLUCAO N.F.: DIVERSAS"
	ElseIf cTipo=="C" .and. Substr(cCFO,2,1)!="6" 
		cMsg:="COMPL.N.F.: DIVERSAS"
	ElseIf cTipo=="B" .and. SF4->F4_PODER3!="R"
		cMsg:="N.F.ORIG.: DIVERSAS"
    ElseIf cTipo=="P"
        cMsg:="COMPL.IPI N.F.: DIVERSAS"
    ElseIf cTipo=="N" .and. SF4->F4_PODER3 == "D"
        cMsg:="N.F.ORIG.: DIVERSAS"
    EndIf   
Else
   Do Case
  	   Case cTipo=="D" 
		  cMsg:=if(!empty(cNFori),"DEVOLUCAO N.F.:"+cNFOri+"/"+Substr(cSerOri,1,3),"")
   	Case cTipo=="C" 
	   	  If Substr(cCFO,2,1)=="6" 
		     	  cMsg:="FRETE"
   		  Else
   			  cMsg:="COMPL.N.F.:"+cNFOri+"/"+Substr(cSerOri,1,3)
   		  EndIf
   	Case cTipo=="B" .and. SF4->F4_PODER3!="R"
		   cMsg:=if(!empty(cNFOri),"N.F.ORIG.:"+cNFOri+"/"+Substr(cSerOri,1,3),"")
		Case cTipo=="P"  
				cMsg:="COMPL.IPI N.F.:"+cNFOri+"/"+Substr(cSerOri,1,3) 
		Case cTipo=="I" 
				cMsg:="COMPL.ICMS N.F.:"+cNFOri+"/"+Substr(cSerOri,1,3)
		Case cTipoCli=="X"
				cMsg:="EXPORTACAO-GE No.: "+cNFOri
		Case SF4->F4_IPI=="R"
		     	cMsg:="AQUIS.COMERC.NAO-CONTRIB.IPI"
        Case cTipo=="N" .and. SF4->F4_PODER3 == "D"
                cMsg:="N.F.ORIG.:"+cNFOri+"/"+Substr(cSerOri,1,3)
        Case nValFun>0
				cMsg:="CONT.SEG.SOCIAL: "+Alltrim(Transform(nValFun,"@E 999,999,999.99"))
	EndCase
EndIf
Return (cMsg)

/*

Ŀ
Funo    AliqIcms() Autor  Juan Jose Pereira      Data  30/01/96 
Ĵ
Descrio  Retorna aliquota de Icms para a Operacao                   
Ĵ
 Uso       Generico                                                   
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                     
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                   
Ĵ
 Marcos Simidu26/11/9711808AConsiderar Tipo cliente na venda.       
 Marcelo Pime.22/12/9713811AAjuste na Aliquota de ICMS,qdo.cliente=F 
 Ben-Hur      21/01/9814128AAjuste na Aliquota de ICMS,qdo.cliente=F
 Edson   M.   27/01/98xxxxxxAcerto do Calculo do ICMS,qdo.cliente=F 
 Marcos Simidu27/04/98XXXXXXDesconsiderar tipo cliente F.           
ٱ


*/
FUNCTION AliqIcms(	cTpOper,; 	// Tipo de Operacao
					cTpNf,;		// Tipo de Nota ('E'ntrada/'S'aida)
					cTpCliFor,;	// Tipo do Cliente ou Fornecedor
					cTipoAliq,;	// Tipo da Aliquota ("S"olidario/"I"cms)
					nRecOri,;	// Numero do Registro caso seja devolucao
					lCupFis)	// Se eh cupom fiscal
//Ŀ
// Define variaveis 					                            
//
Local nAliquota:=0
Local cEstCliFor:='',cInscr:=''
Local nMV_ICMPAD:=SuperGetMv('MV_ICMPAD')
Local nMV_ALIQISS := SuperGetMv("MV_ALIQISS")
Local cGpTrib:=Iif(cModulo=="FRT", Padr(SBI->BI_GRTRIB, TamSX3("B1_GRTRIB")[1]), RetFldProd(SB1->B1_COD,"B1_GRTRIB","SB1")) 
Local nPerIcm:=Iif(cModulo=="FRT", SBI->BI_PICM, RetFldProd(SB1->B1_COD,"B1_PICM","SB1"))
Local nMargemLucro:=0
Local aExcecao:={},cGrpCli  
Local lCalcIss:= .F.
Local nNfOri		:= 0		// Posicao da Nf Original
Local nSerOri		:= 0		// Posicao da Serie Original
Local nItemOri		:= 0		// Posicao do Item Original
Local nProdOri		:= 0		// Posicao do Produto Original
Local nAliqFECP		:= 0		// Alquota FECP
Local lNaoContrib	:= .T.      // Nao-Contribuinte ICMS?
Local nFECPLoja		:= 0
Local lFECOPRN  	:= .F. 		// Verifica se a Aliquota ira ter calculo FECOP para o Estado do RN

Private cMV_NORTE:=SuperGetMv('MV_NORTE'),cMV_ESTADO:=SuperGetMv('MV_ESTADO')
DEFAULT nRecOri		:= 0		// Define o valor do registro
DEFAULT lCupFis		:= .F.		// Se eh cupom fiscal

// Verifica se a Aliquota ira ter calculo FECOP para o Estado do RN
lFECOPRN := Iif(cMV_ESTADO=="RN" .And. SB1->B1_ALFECRN > 0, .T., .F.)      

//Ŀ
// Busca dados do Cliente ou Fornecedor                        
//
If (cTpNf=='S' .and. !(cTpOper$'DB')) .or.;
	(cTpNf=='E' .and. (cTpOper$'DB'))
	cEstCliFor	:=SA1->A1_EST
	cInscr		:=SA1->A1_INSCR
	cTpCliFor  :=IIf(Empty(cTpCliFor),SA1->A1_TIPO,cTpCliFor)
	cGrpCli		:=SA1->A1_GRPTRIB
	lNaoContrib	:= IIf(Empty(SA1->A1_INSCR).Or."ISENT"$SA1->A1_INSCR.Or."RG"$SA1->A1_INSCR.Or.( SA1->A1_CONTRIB == "2"),.T.,.F.)
Else
	cEstCliFor	:=SA2->A2_EST
	cInscr		:=SA2->A2_INSCR
	cTpCliFor  :=IIf(Empty(cTpCliFor),SA2->A2_TIPO,cTpCliFor)
Endif
//Ŀ
// Calculo da Margem de Lucro para Icms Retido                 
//
If cModulo$'FAT/DIS'
	nMargemLucro:=IIF(SC6->C6_PICMRET==0,SB1->B1_PICMRET,SC6->C6_PICMRET) 
Else
    If cTpNF=='S'
    	If cModulo=="FRT" 
			nMargemLucro:=SBI->BI_PICMRET
		Else
			nMargemLucro:=RetFldProd(SB1->B1_COD,"B1_PICMRET","SB1")
		Endif	
	Else
		nMargemLucro:=0			    	
	Endif
Endif
//Ŀ
// Carrega Excessoes Fiscais (Somente no SIGAFAT/SIGALOJA/SIGATMK/SIGAFRT.  
//
If cTpNf=='S' .and. cModulo $ 'FAT/DIS/LOJ/TMK/FRT'
	aExcecao:=ExcecFis(cGpTrib,cGrpCli)
	If aExcecao[7]=="S"
		nMargemLucro:=aExcecao[3]
	Endif
Endif
//Ŀ
// Busca da aliquota de ICMS                                   
//
//Ŀ
//Se for NF de Devolucao
//
If  cTpOper=='D' .And. nRecOri <> 0 

	Do Case

	Case cTpNf == 'S' 
	
		SD1->(MsGoto(nRecOri))
		nAliquota	:= SD1->D1_PICM
		
	Case cTpNf == 'E'
	
		SD2->(MsGoto(nRecOri))
		nAliquota	:= SD2->D2_PICM

	EndCase		
Else
	While .t.
		//Ŀ
		// Para Servicos         
		//
		If ((!Empty(IIF(cModulo <> "FRT",RetFldProd(SB1->B1_COD,"B1_CODISS","SB1"),'')) .or. (!Empty(SBI->BI_CODISS) .And. cModulo=="FRT")) .Or. (cModulo$"FAT/DIS" .And. !Empty(SC6->C6_CODISS))) .and. SF4->F4_ISS=='S'
			lCalcIss := .T.
			nAliquota:=If(MaSBCampo("ALIQISS")==0,nMV_ALIQISS,MaSBCampo("ALIQISS"))
			If (Len(aExcecao) >= 9 .And. !aExcecao[9]=="S") .Or. Len(aExcecao) == 0 //ISS
				Exit
			EndIf
			If aExcecao[7]=="S"
				If cMV_ESTADO==cEstCliFor
					nAliquota:=aExcecao[1]  //Aliq. de ICMS Interna
				Else
					nAliquota:=IIf(aExcecao[8]>0,aExcecao[8],AliqDest(aExcecao,cEstCliFor))  //Aliq. de ICMS Destino
				Endif
			Else
				If cMV_ESTADO<>cEstCliFor
					If ( cTpOper$"DB" )
						nAliquota:=AliqDest(aExcecao,cMV_ESTADO)
					Else
						nAliquota:=AliqDest(aExcecao,cEstCliFor)
					EndIf
				Endif
			Endif
			Exit
		Endif
		//Ŀ
		// Nas Exportacoes,verifica se h exceo fiscal, se houver, respeita-a, caso
		// contrrio atribui 13% como valor default                                  
		//
		If (cTpCliFor == "X") .And. (((cTpNF == "S") .And. (cTpOper # "D")) .Or. ((cTpNF == "E") .And. (cTpOper == "D")))
			if len(aExcecao) >=7
				nAliquota := If( aExcecao[7] == "S",aExcecao[1],13) //Aliq. de ICMS Interna
				Exit
			Else
				nAliquota := 13
				Exit
			EndIf
		EndIf
		//Ŀ
		// Nas Importacoes       
		//
		If (cTpCliFor == "X") .And. (((cTpNF == "E") .And. (cTpOper # "D")) .Or. ((cTpNF == "S") .And. (cTpOper == "D")))
			nAliquota := If( Empty( nPerICM ),nMV_ICMPAD,nPerICM )
			Exit
		EndIf
		//Ŀ
		// Excessao Fiscal                          
		// Utilizado pelo SIGAFAT e SIGALOJA.       
		//
		If cTpNf=="S" .and. cModulo $ "FAT/DIS/LOJ/FRT" .and. nMargemLucro>0.and.cTpCliFor=="S".and.cTipoAliq=="S"
			If aExcecao[7]=="S"
				If cMV_ESTADO==cEstCliFor
					nAliquota:=aExcecao[1]  //Aliq. de ICMS Interna
				Else
					nAliquota:=IIf(aExcecao[8]>0,aExcecao[8],AliqDest(aExcecao,cEstCliFor))  //Aliq. de ICMS Destino
				Endif
			Else
				If ( cTpOper$"DB" )
					nAliquota:=AliqDest(aExcecao,cMV_ESTADO)
				Else
					nAliquota:=AliqDest(aExcecao,cEstCliFor)
				EndIf
				If cMV_ESTADO==cEstCliFor.and.nPerIcm>0
					nAliquota:=nPerIcm
				Endif
			Endif
			Exit
		Endif
		//Ŀ
		// Pessoa Fisica         
		//
		//Ŀ
		// Nota de Saida sem inscr. Estadual ou isento				   
		// Nota de Devolucao de Saida e cliente Pessoa Fisica 		   
		// Nota de Devolucao de Entrada sem inscr. Estadual ou Isenta 
		//
		If !lCalcIss
			If (cTpNf=='S' .and. (Empty(cInscr).Or."ISENT"$Upper(cInscr))) .or. ;
				(cTpNf=='S' .and. cTpOper=='D'  .and. cTpCliFor =='F') .Or. ;
				(cTpNf=='E' .and. cTpOper=='D'  .and. (Empty(cInscr).Or."ISENT"$Upper(cInscr)))
				If (Empty(cInscr).Or."ISENT"$Upper(cInscr))
					If cTpNF=='S'
						If cModulo $ "LOJ/FRT"  
							If ( (cTpNf=='S' .and. !(cTpOper$'DB')) .Or. (cTpNf=='E' .and. (cTpOper$'DB')) ) .And. ;
								cMV_ESTADO != cEstCliFor .And. ( !Empty(SA1->A1_INSCR) .And. !("ISENT" $ SA1->A1_INSCR) )
								If cMV_ESTADO $ cMV_NORTE
									nAliquota:=12
								Else
									nAliquota:=IIf( cEstCliFor $ cMV_NORTE , 7 , 12 )
								Endif
							Else     
								If (SF4->(FieldPos("F4_ISEFECP")) > 0 .AND. SF4->F4_ISEFECP == "2") .OR. (SF4->(FieldPos("F4_ISEFERN")) > 0 .AND. SF4->F4_ISEFERN == "2" .And. cEstCliFor == "RN")									
									nAliqFECP := Iif(cMV_ESTADO $"RJ|BA|RN|RS",Iif(SB1->(FieldPos("B1_FECP")) > 0 .And.SB1->B1_FECP > 0 .Or. lFECOPRN,;
									Iif ( !lFECOPRN, SB1->B1_FECP, SB1->B1_ALFECRN ),;
									Iif ( cMV_ESTADO == 'BA' .Or. ( cMV_ESTADO <> 'BA' .And. cMV_ESTADO <> 'RJ' .And. cTpNf == "S" .And. cEstCliFor == "BA" )  , 0 , 1 ) ) , 0 )																			
								EndIf

								If cModulo == "LOJ" .AND.  nPerIcm == 0 .AND. SB1->B1_PICM > 0  
									nPerIcm := SB1->B1_PICM 
								EndIf
								
								nAliquota:=IIf(nPerIcm>0,nPerIcm,nMV_ICMPAD) + nAliqFECP
							EndIf
	
							//Ŀ
							//Se for NF de Devolucao  
							//
							If (cTpNf=='S' .and. cTpOper=='D'  .and. cTpCliFor =='F')
								//Ŀ
								//Verifica o item na NF para pegar a mesma aliquota de ICMS nas devolucoes
								//
					 			nNfOri		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_NFORI"})
					 			nSerOri		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_SERIORI"})
					 			nItemOri	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_ITEMORI"})
								nProdOri	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_COD"})
								If !Empty(aCols[n][nNfOri])
									SD1->(DbSetOrder(1))
									If SD1->(DbSeek(xFilial("SD1")+aCols[n][nNfOri]+aCols[n][nSerOri]+SA2->A2_COD+SA2->A2_LOJA+aCols[n][nProdOri]+aCols[n][nItemOri]))
										nAliquota	:= SD1->D1_PICM
									Endif
								Endif
							EndIf
					 	Else
							if cModulo=="FRT"
								nAliqFECP := Iif(cMV_ESTADO $"RJ|BA|RS",Iif(SBI->(FieldPos("BI_FECP")) > 0 .And.SBI->BI_FECP > 0,SBI->BI_FECP,;
								Iif ( cMV_ESTADO == 'BA' .Or. ( cMV_ESTADO <> 'BA' .And. cMV_ESTADO <> 'RJ' .And. cTpNf == "S" .And. cEstCliFor == "BA" )  , 0 , 2 ) ) , 0 )
							Else 
								nAliqFECP := Iif(cMV_ESTADO $"RJ|BA|RN|RS",Iif(SB1->B1_FECP > 0 .Or. lFECOPRN,;
								Iif ( !lFECOPRN, SB1->B1_FECP, SB1->B1_ALFECRN ),;
								Iif ( cMV_ESTADO == 'BA' .Or. ( cMV_ESTADO <> 'BA' .And. cMV_ESTADO <> 'RJ' .And. cTpNf == "S" .And. cEstCliFor == "BA" )  , 0 , 1 ) ) , 0 )								
							Endif
							nAliquota:=IIf(nPerIcm>0,nPerIcm,nMV_ICMPAD) + nAliqFECP
						EndIf
					Else
						//Ŀ
						// Quando for devolucao de vendas a aliquota da entrada deve  
						// ser igual a aliquota da Sada.                     			
						//
						If cTpNf=='E' .and. cTpOper=='D'
							nAliquota := nMV_ICMPAD
						Else
							nAliquota:=If(nPerIcm>0,nPerIcm,AliqDest(aExcecao,cEstCliFor))
						EndIf
					Endif
				Else
					If cTpNf=='E' .and. cTpOper=='D'
						nAliquota := nMV_ICMPAD
					Else
                        If cModulo=="FRT"
							nAliqFECP := Iif(cMV_ESTADO $"RJ|BA|RS",Iif(SBI->(FieldPos("BI_FECP")) > 0 .And.SBI->BI_FECP > 0,SBI->BI_FECP,;
							Iif ( cMV_ESTADO == 'BA' .Or. ( cMV_ESTADO <> 'BA' .And. cMV_ESTADO <> 'RJ' .And. cTpNf == "S" .And. cEstCliFor == "BA" )  , 0 , 2 ) ) , 0 )
						Else
							nAliqFECP := Iif(cMV_ESTADO $"RJ|BA|RN|RS",Iif(SB1->B1_FECP > 0 .Or. lFECOPRN,;
							Iif ( !lFECOPRN, SB1->B1_FECP, SB1->B1_ALFECRN ),;
							Iif ( cMV_ESTADO == 'BA' .Or. ( cMV_ESTADO <> 'BA' .And. cMV_ESTADO <> 'RJ' .And. cTpNf == "S" .And. cEstCliFor == "BA" )  , 0 , 1 ) ) , 0 )
						Endif							
						nAliquota:=IIf(nPerIcm>0,nPerIcm,nMV_ICMPAD) + nAliqFECP
					EndIf
				Endif
				
				If cModulo $ "LOJ/FRT"  				
					nFECPLoja := nAliqFECP
				Else
					nFECPLoja := 0				
				EndIf

				If cEstCLiFor == cMV_ESTADO
					If ( Len(aExcecao) >= 1 )
						If ( aExcecao[1] ) != 0
							nAliquota := aExcecao[1]+nFECPLoja  //Aliq. de ICMS Interna
						EndIf	
					EndIf				
				Else
					If ( Len(aExcecao) >= 2 ).And.!(Empty(cInscr).Or."ISENT"$Upper(cInscr))
						If (aExcecao[2]) != 0
							nAliquota := aExcecao[2]+nFECPLoja //Aliq. de ICMS Externa
						EndIf	
					Else 
						if Len(aExcecao) >0
							If (aExcecao[1]) != 0
								nAliquota := aExcecao[1]+nFECPLoja  //Aliq. de ICMS Interna
							EndIf
						endif	
					EndIf				
				EndIf
				Exit
			Endif                       
		EndIf
		//Ŀ
		// Nas Operacoes         
		//
		IF cModulo $ "FAT/DIS" 
			IF cEstCLiFor == cMV_ESTADO
				If Len(aExcecao) >=1
				IF !Empty(aExcecao[1])
					nAliquota := aExcecao[1]  //Aliq. de ICMS Interna
					Exit
				Endif
				Endif
			Else
				If Len(aExcecao) >= 2
				IF !Empty(aExcecao[2])
					nAliquota := aExcecao[2] //Aliq. de ICMS Externa
					Exit
					Endif
				Endif
			Endif
		Endif
		If cEstCliFor==cMV_ESTADO.or.cTipoAliq=='S' .OR. ( cModulo $ 'LOJ/FRT' .AND. lNaoContrib ) .OR. lCupFis
			If cModulo=="FRT"
				nAliqFECP := Iif(cMV_ESTADO $"RJ|BA|RS",Iif(SBI->(FieldPos("BI_FECP")) > 0 .And.SBI->BI_FECP > 0,SBI->BI_FECP,;
				Iif ( cMV_ESTADO == 'BA' .Or. ( cMV_ESTADO <> 'BA' .And. cMV_ESTADO <> 'RJ' .And. cTpNf == "S" .And. cEstCliFor == "BA" )  , 0 , 1 ) ) , 0 )
			Else	
				nAliqFECP := Iif(cMV_ESTADO $"RJ|BA|RN|RS",Iif(SB1->B1_FECP > 0 .Or. lFECOPRN,;
				Iif ( !lFECOPRN, SB1->B1_FECP, SB1->B1_ALFECRN ),;
				Iif ( cMV_ESTADO == 'BA' .Or. ( cMV_ESTADO <> 'BA' .And. cMV_ESTADO <> 'RJ' .And. cTpNf == "S" .And. cEstCliFor == "BA" )  , 0 , 1 ) ) , 0 )			
			Endif	
            // Tratamento por exceo fiscal
            If cModulo $ 'LOJ/FRT'
                IF cEstCLiFor == cMV_ESTADO
                    If Len(aExcecao) >=1
						IF !Empty(aExcecao[1])
                            nAliquota := aExcecao[1] + nAliqFECP  //Aliq. de ICMS Interna + FECP
                            Exit
                        Endif
                    Endif
                Else
                    If Len(aExcecao) >= 2
                        IF !Empty(aExcecao[2])
                            nAliquota := aExcecao[2] + nAliqFECP  //Aliq. de ICMS Externa + FECP
                            Exit
                        Endif
                    Endif
                Endif
            EndIf
			nAliquota := IIf( nPerIcm > 0 , nPerIcm , nMV_ICMPAD ) + nAliqFECP
		Else
			If (cTpNF=='S' .and. !(cTpOper$'DB')) .or.;
				(cTpNF=='E' .and. cTpOper$'DB')
				If cMV_ESTADO $ cMV_NORTE
					nAliquota:=12
				Else
					nAliquota:=IIf( cEstCliFor $ cMV_NORTE , 7 , 12 )
				Endif
			Else
				If cMV_ESTADO $ cMV_NORTE
					nAliquota:=IIf( cEstCliFor $ cMV_NORTE , 12 , 7)
				Else
					nAliquota:=12
				Endif
			Endif	
		Endif
		Exit
	End
Endif
Return (nAliquota)

//Ŀ
// Fim da Funcao                                               
//

/*

Ŀ
Funo     AliqDest  Autor  Marcos Bregantim       Data  13.02.95 
Ĵ
Descrio  Funcao para calcular a aliquota no destino                 
Ĵ
Sintaxe    Expn1 := AliqDest()                                        
Ĵ
Uso        MATA460                                                    
ٱ


*/
Function AliqDest(aExcecao,cEstClifor)

LOCAL nPerIcm 

nPerIcm:=Val(Subs(SuperGetMV("MV_ESTICM"),AT(cEstCliFor,SuperGetMV("MV_ESTICM"))+2,2))
If Len(aExcecao)>=8 .And. aExcecao[8] > 0 .and. aExcecao[7] == "S"
    nPerIcm := aExcecao[8]
Endif

Return (nPerIcm)

/*


Ŀ
Funo    ExcecFis() Autor  Marcelo B. Abe         Data 05/05/1994
Ĵ
Descrio  Verifica excecoes de Tributacao                            
Ĵ
 Uso      Mata460                                                     
ٱ


*/
Function ExcecFis(cGrupo,cGrpCli,aExcecao)

LOCAL cAlia1:=Alias()
Local cFilBk:="" 

aExcecao:=IIf(Empty(aExcecao),{0,0,0," "," "," ","N",0,SF7->F7_ISS},aExcecao)

// Estrutura do Array aExcecao
//	[01] - Aliq. de ICMS Interna
//	[02] - Aliq. de ICMS Externa
//	[03] - Margem de Lucro Presumida
//	[04] - Grupo de Tributacao
//	[05] - Tipo de Cliente
//	[06] - Estado Destino
//	[07] - "S"
//	[08] - Aliq. de ICMS Destino
//	[09] - Refere-se ao ISS "S/N"

If Empty(cGrupo).or.cGrpCli==NIL 
    Return (aExcecao)
Endif	

If cGrupo == aExcecao[4] .And. IIf(cModulo $ "LOJ/FRT",SA1->A1_TIPO,SC5->C5_TIPOCLI) == aExcecao[5] .And.;
    SA1->A1_EST == aExcecao[6]
    aExcecao[7]:="S"
    Return(aExcecao) 
Endif

dbSelectArea("SF7")
If cModulo=="FRT"
	cFilBk	:= cFilial
	cFilial := xFilial("SF7") 
EndIf
dbSeek(cFilial+cGrupo+cGrpCli)
While !Eof() .And. F7_FILIAL+F7_GRTRIB+F7_GRPCLI == cFilial+cGrupo+cGrpCli
    If (SA1->A1_EST == F7_EST .Or. F7_EST == "**") .AND. ;
        (if(cModulo $ "LOJ/FRT",SA1->A1_TIPO,SC5->C5_TIPOCLI) == F7_TIPOCLI .Or. F7_TIPOCLI == "*")
        aExcecao[1]:=F7_ALIQINT
        aExcecao[2]:=F7_ALIQEXT
        aExcecao[3]:=F7_MARGEM
        aExcecao[4]:=F7_GRTRIB
        aExcecao[5]:=if(cModulo $ "LOJ/FRT",SA1->A1_TIPO,SC5->C5_TIPOCLI)
        aExcecao[6]:=SA1->A1_EST
        aExcecao[7]:="S"
        aExcecao[8]:=F7_ALIQDST     
	     aExcecao[9]:=F7_ISS
        Exit
    Endif
    dbSkip()
End
If cModulo=="FRT"
	cFilial := cFilBk
EndIf

DbSelectArea(cAlia1)

Return(aExcecao)

/*


Ŀ
Funo     NovaPg()  Autor  Juan Jose Pereira      Data 02/02/1996
Ĵ
Descrio  Controla numeracao de paginas dos livros fiscais           
ٱ


*/
FUNCTION NovaPg(nPagina,nQtdPag,lReiniPg)

Local lFeixe:=.f.

lReiniPg:=IIF(lReiniPg==NIL,.f.,lReiniPg)
nQtdPag:=IIf(Empty(nQtdPag) .or. nQtdPag<=0,500,nQtdPag)

nPagina++
If nPagina%nQtdPag==0
	If lReiniPg
		nPagina:=0
	Endif
	nPagina:=nPagina+2
	lFeixe:=.t.
Endif

Return (lFeixe)

/*/


Ŀ
Funo     MoveGauge()     Autor  Juan Jose Pereira  Data 23/10/95
Ĵ
Descrio  Movimenta regua de processamento                           
ٱ


*/
Function MoveGauge()

IncRegua()

Return 
//Ŀ
// Fim da Funcao                                                
//
/*/


Ŀ
Funo     SetGauge()      Autor  Juan Jose Pereira  Data 23/10/95
Ĵ
Descrio  Inicializa regua de processamento                          
ٱ


*/
Function SetGauge(Tamanho)

SetRegua(Tamanho)

Return (nil)

/*/


Ŀ
Funo     NFServ()  Autor  Juan Jose Pereira      Data  07/06/95 
Ĵ
Descrio  Avalia Impressao de Registro de Nota Fiscal de Servico     
Ĵ
 Uso       GENERICO DOS REGISTROS FISCAIS MOD 1 E MOD 2 (SAIDAS)      
ٱ


*/
Function NFServ()

LOCAL 	nSavReg:= Recno(),;
		cSavAlias:=Alias(),;	
		cNFInicial:= aSF3[_F3_NFISCAL],;
		cNFFinal:= aSF3[_F3_NFISCAL],;
		cNFSerie:= aSF3[_F3_SERIE],;
		aNFServ:={}

dbSelectArea("SF3")
dbSetOrder(5) // filial+serie+nota

While F3_TIPO=="S" 
	dbSkip()
	If Val(substr(F3_CFO,1,1))<5
		Loop
	Endif
	If (Val(F3_NFISCAL)==Val(cNFFinal)+1 .or. Val(F3_NFISCAL)==Val(cNFFinal)) .and. ;
		F3_SERIE==cNFSerie .and. F3_TIPO=="S"
		cNFFinal:=F3_NFISCAL
	Else
		Exit
	Endif
End	
	
AADD(aNfServ,{cNFInicial,cNFFinal,cNfSerie,"NF.SERVICO"})
	
dbSelectArea(cSavAlias)
dbSetOrder(1)
dbGoto(nSavReg)

Return(aNFServ)

/*/


Ŀ
Funo     MontaSF3()      Autor  Juan Jose Pereira  Data 04/09/95
Ĵ
Descrio  Acumula linhas de registro no SF3                          
ٱ


*/
Function MontaSF3(cNrLivro, lQuery)
//Ŀ
// Define variaveis                                             
//
Local lAtivaLoop:=.f., i:=1

Default lQuery	:=	.F.
//Ŀ
// Zera vetor do SF3                                            
//
aSF3:={}
//Ŀ
// Carrega vetor do SF3                                         
//
For i:=1 to _F3_CAMPOS
	AADD(aSF3,FieldGet(i))
Next
//Ŀ
// Consiste o numero do Livro                                   
//
If cNrLivro<>"*" .and. aSF3[_F3_NRLIVRO]<>cNrLivro
	lAtivaLoop:=.t.
Endif 
//Ŀ
// Acumula linhas do SF3 de mesma nota e livros diferentes      
//
While !Eof() .and. cNrLivro=="*" .and. !lAtivaLoop
	dbSkip()
	If aSF3[_F3_FILIAL]==F3_FILIAL .and.;
		aSF3[_F3_TIPO]==F3_TIPO .and. ;
		aSF3[_F3_NFISCAL]==F3_NFISCAL .and.;
		aSF3[_F3_SERIE]==F3_SERIE .and.;
		aSF3[_F3_CFO]==F3_CFO .and.;
		aSF3[_F3_ALIQICM]==F3_ALIQICM .and.;
		aSF3[_F3_CLIEFOR]==F3_CLIEFOR .and.;
		aSF3[_F3_LOJA]==F3_LOJA .and.;
		aSF3[_F3_OBSERV]==F3_OBSERV
		For i:=1 to _F3_CAMPOS
			If ValType(aSF3[i])=="N" .and. FieldName(i)<>"F3_ALIQICM"
				aSF3[i]+=FieldGet(i)
			Endif
		Next
	Else
		If !lQuery		
			dbSkip(-1)
		EndIf
		Exit
	Endif
End

Return (lAtivaLoop)

/*/


Ŀ
Funo     UltimoDia()     Autor  Juan Jose Pereira  Data 07/02/96
Ĵ
Descrio  Retorna Ultimo dia do mes                                  
ٱ


*/
FUNCTION UltimoDia(dDiaIni)

Local dDia:=dDiaIni

dDia:=dDia+30
While Month(dDiaIni)!=Month(dDia)
	dDia:=dDia-1
End

Return (dDia)
//Ŀ
// Fim da Funcao                                                
//

/*/


Ŀ
Funo     CriaLFiscal()   Autor  Juan Jose Pereira  Data 07/02/96
Ĵ
Descrio  Cria array aLivro, ou cria nova linha                      
ٱ


*/
FUNCTION CriaLFiscal(aLivro,cCFO,nAliquota,cTipoNf)

Local nPos	:=0
Local aFixos:=MatxAfixos()
Local i		:=0

If !Empty(aLivro)
	If cTipoNf=='N'
		nPos:=Ascan(aLivro,{|x|x[1]==cCFO .and. x[2]==nAliquota})
	Else
		nPos:=Ascan(aLivro,{|x|x[2]==nAliquota})
	Endif
Endif

If nPos==0
	AADD(aLivro, Array( Len(aFixos) ))
	For i:=1 to Len(aFixos)
		aLivro[1,i]:=aFixos[i,2]
	Next
	aLivro[1,1]:=cCFO
	aLivro[1,2]:=nAliquota
	nPos:=Len(aLivro)
Endif

Return (nPos)

/*/


Ŀ
Funo     PutLFiscal()    Autor  Juan Jose Pereira  Data 07/02/96
Ĵ
Descrio  Grava valores no array aLivro                              
ٱ


*/
FUNCTION PutLFiscal(aLivro,nElemento,cCampo,nValor,lAcumula)

Local aFixos:=Matxafixos()

lAcumula:=IIf(Empty(lAcumula),.t.,lAcumula)

nPos:=Ascan(aFixos,{|x|x[1]==Upper(cCampo)})
If nPos>0
	If lAcumula 
		aLivro[nElemento,nPos]+=nValor
	Else
		aLivro[nElemento,nPos]:=nValor
	Endif
Endif

Return (aLivro)
/*/


Ŀ
Funo     GravaLFiscal()  Autor  Juan Jose Pereira  Data 07/02/96
Ĵ
Descrio  Grava Livro Fiscal no SF3                                  
ٱ


*/
FUNCTION GravaLFiscal(aLivro)

Local cSvAlias:=Alias(), aFixos:=MatxAfixos(), i, j

dbSelectArea('SF3')
For i:=1 to Len(aLivro)
	RecLock('SF3',.t.)
	FieldPut(1,xFilial('SF3'))
	For j:=1 to Len(aFixos)
		FieldPut(FieldPos(aFixos[j,2]),aLivro[i,j])		
	Next			
	MSUnLock()
Next

dbSelectArea(cSvAlias)

Return (nil)
/*/


Ŀ
Funo     LeLFiscal()     Autor  Juan Jose Pereira  Data 07/02/96
Ĵ
Descrio  Le elemento do array aLivro                                
ٱ


*/
FUNCTION LeLFiscal(aLivro,nElemento,cCampo)

Local nPos:=0, aFixos:=MatxAfixos(), uValor

nPos:=Ascan(aFixos,{|x|x[1]==Upper(cCampo)})
If nPos>0
	uValor:=aLivro[nElemento,nPos]
Endif

Return (uValor)
/*/


Ŀ
Funo     ProxNrS()       Autor  Juan Jose Pereira  Data 07/02/96
Ĵ
Descrio  Retorna Proximo numero                                     
ٱ


*/
FUNCTION ProxNrS(cNumero)

Local nNumero, cNum, nTam1, nTam2, nPos1, nPos2 

nNumero:=Val(cNumero)

cNum:=Alltrim(Str(nNumero))
nTam1:=Len(cNum)
nPos1:=At(cNum,cNumero)

nNumero:=nNumero+1

cNum:=Alltrim(Str(nNumero))
nTam2:=Len(cNum)
nPos2:=IIf(nTam2>nTam1,nPos1-1,nPos1)
nPos2:=IIf(nPos2<0,1,nPos2)

cNumero:=Stuff(cNumero,nPos2,Len(cNum),cNum)

Return (cNumero)

/*/


Ŀ
Funo     NtCancel()   Autor  Juan Jose Pereira    Data 17/02/96 
Ĵ
Descrio  Cria Arquivo de Trabalho com numero de notas de saidas     
           canceladas ou utilizadas para entrada                      
Ĵ
 Uso       MATR930                                                    
ٱ


*/
FUNCTION NtCancel(cNrLivro,dDtIni,dDtFim,lEnd)

LOCAL cArqCanc, aEstrut:={}, aNotas:={}, i, j, cIndx,cIndx1, cNota, cSerie, nPos
LOCAL cChave, cFiltro 
LOCAL cStatus
LOCAL dDtIni2:=dDtIni-10
//Ŀ
// Cria arq trabalho para guarda notas canceladas               
//	
AADD(aEstrut,{'CAN_SERIE'	,'C',TamSX3("F2_SERIE")[1],0})
AADD(aEstrut,{'CAN_NOTA'	,'C',TamSX3("F2_DOC")[1],0}) 
AADD(aEstrut,{'CAN_STATUS'	,'C',2,0})

cArqCanc:=CriaTrab(aEstrut)
dbUseArea(.T.,,cArqCanc,'CAN',.T.,.F.)
//Ŀ
// Acumula numeros e series de notas de saidas                  
//	
dbSelectArea('SF3')
cIndx1:=CriaTrab(NIL,.F.)
cChave:="F3_SERIE+F3_NFISCAL"
cFiltro:="F3_FILIAL=='"+xFilial("SF3")
cFiltro+="' .AND. (substr(F3_CFO,1,1)>='5'.OR.F3_FORMUL=='S') .AND."
#IFNDEF TOP
	cFiltro+="DTOS(F3_ENTRADA)>='"+DTOS(dDtIni2)+"' .AND. "
	cFiltro+="DTOS(F3_ENTRADA)<='"+DTOS(dDtFim)+"'"
#ELSE
	cFiltro+="DTOS(F3_ENTRADA)>='"+DTOS(dDtIni2)+"' .AND. "
	cFiltro+="DTOS(F3_ENTRADA)<='"+DTOS(dDtFim)+"'"
#ENDIF
IndRegua('SF3',cIndx1,cChave,,cFiltro,'Filtrando registros...')
SET CURSOR OFF
#IFNDEF TOP
	dbClearIndex()
	dbSetIndex(cIndx1)
	dbSetOrder(1)
#ENDIF
SetRegua(LastRec())
While !Eof() 
	IncRegua()
	If Interrupcao(@lEnd)
		Exit
	Endif
	If Len(aNotas)==0 .or. Ascan(aNotas,{|x|x[1]==F3_SERIE})==0
		AAdd(aNotas,{F3_SERIE,F3_NFISCAL,F3_NFISCAL})
	Endif
	nPos:=Ascan(aNotas,{|x|x[1]==F3_SERIE})
	If Val(F3_NFISCAL)>Val(aNotas[nPos,3])
		aNotas[nPos,3]:=F3_NFISCAL
	Endif
	dbSkip()
End

If lEnd
	RETURN (cArqCanc+GetDBExtension())
Endif
//Ŀ
// Indice para pesquisar notas de saidas                        
//	
cIndx:=CriaTrab(NIL,.F.)
cChave:="F3_SERIE+F3_NFISCAL"
cFiltro:="F3_FILIAL=='"+xFilial("SF3")+"' .AND. (substr(F3_CFO,1,1)>='5' .OR. F3_FORMUL=='S')"
IndRegua('SF3',cIndx,cChave,,cFiltro,'Filtrando registros...')
SET CURSOR OFF
#IFNDEF TOP
	dbClearIndex()
	dbSetIndex(cIndx)
	dbSetOrder(1)
#ENDIF
//Ŀ
// busca notas canceladas                                       
//	
For i:=1 to Len(aNotas)
	cNota:=aNotas[i,2]
	cSerie:=aNotas[i,1]
	SetRegua(Val(aNotas[i,3])-Val(aNotas[i,2]))
	While Val(cNota)<Val(aNotas[i,3])
		If Interrupcao(@lEnd)
			Exit
		EndIf
		IncRegua()
		//Ŀ
		// Verifica se nota existe                                      
		//	
		cStatus:=NIL
		dbSeek(cSerie+cNota)
		If !Found()
			//Ŀ
			// Verifica se nota nao esta em um lote                         
			//
			dbSeek(cSerie+cNota,.t.)
			dbSkip(-1)
			If F3_TIPO=='L'.and.F3_SERIE==cSerie
				If !(VAL(F3_NFISCAL)<=VAL(cNota) .and. VAL(cNota)<=VAL(F3_DOCOR))
					cStatus:='CN'	
				EndIf
			Else
				cStatus:='CN'
			Endif
			dbSkip()
		Endif
		//Ŀ
		// Grava nota cancelada                                         
		//	
		If !Empty(cStatus)
			dbSelectArea('CAN')
			RecLock('CAN',.T.)
			Replace CAN_SERIE 	with cSerie
			Replace CAN_NOTA	with cNota
			Replace CAN_STATUS 	with cStatus
			MsUnlock()
		Endif
		//Ŀ
		// Incrementa para proxima nota da serie                        
		//	
		dbSelectArea('SF3')	
		cNota:=ProxNrS(cNota)
	End
	If lEnd
		Exit
	Endif
Next

dbSelectArea('SF3')
dbClearFilter()
RetIndex('SF3')
dbSetOrder(1)
#IFNDEF TOP
	Ferase(cIndx+OrdBagExt())
	Ferase(cIndx1+OrdBagExt())
#ENDIF
		
RETURN (cArqCanc+GetDBExtension())

/*/


Ŀ
Funo     RAcumula()   Autor  Juan Jose Pereira    Data 17/02/96 
Ĵ
Descrio  Acumulador de valores fiscais para o MATR930 e MATR931     
ٱ


*/
FUNCTION RAcumula(	aTotDia,;
				 	aTotPer,;
					aTotMes,;
					aTransp,;
					aResumo,;
					aResCFO)

LOCAL aSF3:=Array(13), i

aSF3[01]:=	SF3->F3_BASEICM
aSF3[02]:=	SF3->F3_VALICM
aSF3[03]:=	SF3->F3_ISENICM
aSF3[04]:=	SF3->F3_OUTRICM
aSF3[05]:=	SF3->F3_BASERET
aSF3[06]:=	SF3->F3_ICMSRET
aSF3[07]:=	SF3->F3_BASEIPI
aSF3[08]:=	SF3->F3_VALIPI
aSF3[09]:=	SF3->F3_ISENIPI
aSF3[10]:=	SF3->F3_OUTRIPI
aSF3[11]:=	SF3->F3_IPIOBS
aSF3[12]:=	SF3->F3_ICMAUTO 
aSF3[13]:=  SF3->F3_ICMSCOM

For i:=1 to Len(aSF3)
	aTotDia[i]+=aSF3[i]
	aTotPer[i]+=aSF3[i]
	aTotMes[i]+=aSF3[i]
	aTransp[i]+=aSF3[i]
Next
//Ŀ
// Acumula valores por CFOS                                                                    
//
nPos:=Ascan(aResCFO,{|x|x[1]==SF3->F3_CFO})
If nPos==0
	AADD(aResCFO,Array(15))
	nPos:=Len(aResCFO)
	aResCFO[nPos,1]:=SF3->F3_CFO
	For i:=2 to Len(aResCFO[nPos])
		aResCFO[nPos,i]:=0
	Next
Endif
For i:=1 to Len(aSF3)
	aResCFO[nPos,i+1]+=aSF3[i]
Next
aResCFO[nPos,15]+=SF3->F3_VALCONT
//Ŀ
// Acumula valores de ICMS Retido de Operacoes Interestaduais com ICMS Retido,apartir de 1/3/96
//
If SF3->F3_ESTADO!=cMV_ESTADO .and. SF3->F3_ENTRADA>=CTOD('01/03/96') .and. SF3->F3_ESTADO!="EX"
    cContrib:=IIf(SubStr(SF3->F3_CFO,1,3)$"618/619","NC","CO")
	If Len(aResumo)==0
		AADD(aResumo,{	cContrib,;			// 1.Flag de Contribuinte
						SF3->F3_ESTADO,;	// 2.Estado
						SF3->F3_VALCONT,;	// 3.Valor Contabil
						aSF3[1],;			// 4.Base de Calculo
						aSF3[4],;			// 6.ICMS outras
						aSF3[6]})			// 7.ICMS retido
	Else
		nPos:=Ascan(aResumo,{|x|x[1]==cContrib .and. x[2]==SF3->F3_ESTADO})
		If nPos==0
			AADD(aResumo,{cContrib,SF3->F3_ESTADO,SF3->F3_VALCONT,aSF3[1],aSF3[4],aSF3[6]})
		Else
			aResumo[nPos,3]+=SF3->F3_VALCONT
			aResumo[nPos,4]+=aSF3[1]
			aResumo[nPos,5]+=aSF3[4]
			aResumo[nPos,6]+=aSF3[6]
		Endif
	Endif
Endif

RETURN 
/*/


Ŀ
Funo     VERCFO    Autor  Juan Jose Pereira      Data  29/03/96 
Ĵ
Descrio  Verifica se CFO esta cadastrado na tabela "13" do SX5      
Ĵ
 Uso       Generico                                                   
ٱ


*/
FUNCTION VERCFO(CCFO)

If Empty(Alltrim(Tabela("13",CCFO,.F.)))
	CCFO:=if(len(CCFO)==3,CCFO+"*"+space(02),if(len(CCFO)==4,CCFO+"*"+space(1),CCFO+"*"))
Else
	CCFO:=if(len(CCFO)==3,CCFO+space(03),if(len(CCFO)==4,CCFO+space(2),CCFO+space(01)))
EndIf


RETURN (CCFO)

/*/


Ŀ
Funo     TotValRes Autor  Juan Jose Pereira      Data  11/05/96 
Ĵ
Descrio  Faz totalizacao de valores no resumo de CFO do MATA930/931 
Ĵ
 Uso       MATA930 E MATA931                                          
ٱ


/*/
FUNCTION TotValRes(aTotal,aTotGer,aResCFO,i)

Local nElementos:=11

If aTotal==NIL 
	aTotal:=Array(nElementos)
	Afill(aTotal,0)
Endif
If aTotGer==NIL
	aTotGer:=Array(nElementos)
	Afill(aTotGer,0)
Endif

aTotal[1]+=aResCfo[i,2]
aTotal[2]+=aResCfo[i,3]
aTotal[3]+=aResCfo[i,4]
aTotal[4]+=aResCfo[i,5]
aTotal[5]+=aResCfo[i,7] // icmsret

aTotal[6]+=aResCfo[i,8]
aTotal[7]+=aResCfo[i,9]
aTotal[8]+=aResCfo[i,10]
aTotal[9]+=aResCfo[i,11]
aTotal[10]+=aResCfo[i,14] // compl
aTotal[11]+=aResCfo[i,6] // baseret

aTotGer[1]+=aResCfo[i,2]
aTotGer[2]+=aResCfo[i,3]
aTotGer[3]+=aResCfo[i,4]
aTotGer[4]+=aResCfo[i,5]
aTotGer[5]+=aResCfo[i,7]

aTotGer[6]+=aResCfo[i,8]
aTotGer[7]+=aResCfo[i,9]
aTotGer[8]+=aResCfo[i,10]
aTotGer[9]+=aResCfo[i,11]
aTotGer[10]+=aResCfo[i,14] 
aTotGer[11]+=aResCfo[i,6]

RETURN (NIL)
/*


Ŀ
Funo     Mes       Autor  Juan Jose Pereira      Data  09/05/96 
Ĵ
Descrio  Retorna string do mes de uma data                          
ٱ


*/
FUNCTION Mes(dData)

LOCAL aMeses:={"Janeiro","Fevereiro","Marco","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"}
LOCAL nMes:=Month(dData)

RETURN (aMeses[nMes])
/*


Ŀ
Funo     WriteVer  Autor  Juan Jose Pereira      Data  09/05/96 
Ĵ
Descrio  Retorma string na vertical 1 a 1                           
ٱ


*/
FUNCTION WriteVer(cPalavra,nIndex)

Local cRet:=" "

If nIndex<=Len(cPalavra)
    cRet:=Substr(cPalavra,nIndex,1)
Endif

Return (cRet)
/*/


Ŀ
Funo     XFIS_IMPTERM Autor  Juan Jose Pereira   Data  17/05/96 
Ĵ
Descrio  Imprime termos de abertura e encerramento                  
Ĵ
 Uso       MATA951,MATA952                                            
ٱ


*/
FUNCTION XFIS_IMPTERM(cArqAbert,cArqEncer,cPerg,cDriver)

LOCAL cSvAlias:=Alias(), aVariaveis:={},i,uConteudo,cConteudo
aadd(aVariaveis,{"VAR_IXB",If(!(Type('VAR_IXB')=='U'),VAR_IXB,'')})
dbSelectArea("SM0")
For i:=1 to FCount()	
	If FieldName(i)=="M0_NOME"
		Loop
	ElseIf FieldName(i)=="M0_CGC"
		AADD(aVariaveis,{FieldName(i),Transform(FieldGet(i),"@R! NN.NNN.NNN/NNNN-99")})
	ElseIf FieldName(i)=="M0_INSC"
		AADD(aVariaveis,{FieldName(i),AllTrim(InscrEst())})		
	ElseIf FieldName(i)=="M0_DTRE"
		AADD(aVariaveis,{FieldName(i),Dtoc(FieldGet(i))})
	Else
		AADD(aVariaveis,{FieldName(i),AllTrim(FieldGet(i))})
	Endif
Next
dbSelectArea("SX1")
dbSeek( padr( cPerg , Len( X1_GRUPO ) , ' ' ) + "01" )
While ! Eof() .And. SX1->X1_GRUPO  == padr( cPerg , Len( X1_GRUPO ) , ' ' )
	uConteudo:=&(X1_VAR01)
	If Valtype(uConteudo)=="N"
		cConteudo:=Alltrim(Str(uConteudo))
	Else
		If Valtype(uConteudo)=="C"
			cConteudo:=Alltrim(uConteudo)
		Else
			cConteudo:=uConteudo
		EndIf
	Endif		
	AADD(aVariaveis,{Rtrim(Upper(X1_VAR01)),cConteudo})
	dbSkip()
End

dbSelectArea( "CVB" )
CVB->(dbSeek( xFilial( "CVB" ) ))
For i:=1 to FCount()
	If FieldName(i)=="CVB_CGC"
		AADD(aVariaveis,{FieldName(i),Transform(FieldGet(i),"@R! NN.NNN.NNN/NNNN-99")})
	ElseIf FieldName(i)=="CVB_CPF"
		AADD(aVariaveis,{FieldName(i),Transform(FieldGet(i),"@R 999.999.999-99")})
	Else
		AADD(aVariaveis,{FieldName(i),FieldGet(i)})
	Endif
Next

//Ŀ
// Inclusao de variaveis especificas                            
//
AADD(aVariaveis,{"M_DIA",StrZero(Day(dDataBase),2)})
AADD(aVariaveis,{"M_MES",MesExtenso()})
AADD(aVariaveis,{"M_ANO",StrZero(Year(dDataBase),4)})

If cArqAbert#NIL .and. File(cArqAbert)
	ImpTerm(cArqAbert,aVariaveis,&cDriver)
Endif
If cArqEncer#NIL .and. File(cArqEncer)
	ImpTerm(cArqEncer,aVariaveis,&cDriver)
Endif	 
    
RETURN (NIL)
/*/

Ŀ
Funo     ImpTerm() Autor  Juan Jose Pereira      Data  13/03/95 
Ĵ
Descrio  Imprime Termo de Abertura/Encerramento de Livro            
Ĵ
Sintaxe    ImpTerm(cArquivo,aVariavel,cImpCtrl)                       
           Parametros:                                                
           cArquivo=Nome do Arquivo que contem script a ser impresso  
                    XXXXXXXX.XXX                                      
           aVariavel=Array com                                        
                     {{Variavel no script,Conteudo a Substituir},...} 
           cImpCtrl=Caracter de Controle de Impressao                 
Ĵ
 Uso       FISXFUN                                                    
ٱ


*/
STATIC Function ImpTerm(cArquivo,aVariavel,cImpCtrl)

//Ŀ
// Define variaveis                                 
//

Local 	cTermo:="", aTermo:={""},i:=1, j:=1, nTamTerm:=0, aParametros:={},;
	nLinTermo:=0, nColTermo:=0

Local 	cAcentos:="\\\\\\\\\\\\\\\\\",;
	cAcSubst:="C,\c,\A~\A'\a`\a~\a~\a'\E'\e^\e`\e'\i'\o^\o~\o`\o'\U'",;
	nPosAc:=0
Local	cAux	:=	"", cAux2	:=	"", nY := 0
	
//Ŀ
// Verifica se arquivo existe                       
//

// Desloco a emissao do relatorio para funcao de integracao Com Word para termos

If cArquivo <> Nil .And. ".DOC" $ Upper(cArquivo) .And. File(cArquivo)

	TermoViaWord(cArquivo)	// Retorno falso pois nao eh impresso pelo sistema e sim pelo WORD
	Return .F.		// utilizando .TRM apos saida da funcao eh dado EJECT que nao deve
Endif				// ser feito

If Empty(cArquivo) .or. !File(cArquivo)
	Return .f.
Endif
	
//Ŀ
// Carrega arquivo                                  
//

cTermo:= Memoread(cArquivo)

nTamTerm:=Len(cTermo)
i:=1
j:=1

While i<=nTamTerm
    If Substr(cTermo,i,2) # CHR(13)+CHR(10)
        If Substr(cTermo,i,1)#";"
            nPosAc:=AT(Subst(cTermo,i,1),cAcentos)
            If nPosAc>0
                aTermo[j]:=aTermo[j]+Substr(cAcSubst,nPosAc,2)
            Else
                If Substr(cTermo,i,1)==Chr(K_TAB)
                    aTermo[j]:=aTermo[j]+Space(8)
                Else
                    aTermo[j]:=aTermo[j]+Substr(cTermo,i,1)
                Endif
            Endif
        Else
            AADD(aTermo,"")
            j++
        Endif
	Else 	
		AADD(aTermo,"")
        i++
        j++
	Endif
	i++
End
	
//Ŀ
// Substitui variaveis                              
//

nTamTerm:=Len(aTermo)

nNumPar:=0
aEval(aVariavel,{ |x| IIf(!Empty(x[1]),nNumPar:=nNumPar+1,)})

For i:=1 to nTamTerm
	For j:=1 to nNumPar
		cTipo:=Valtype(aVariavel[j,2])
		Do Case
			Case cTipo=="N"
				cValor:=LTrim(Str(aVariavel[j,2]))
			Case cTipo=="D"
				cValor:=DtoC(aVariavel[j,2])
			Case cTipo=="L"
				cValor:=IIF(aVariavel[j,2],"SIM","NAO")
			Case cTipo=="C"
				cValor:=aVariavel[j,2]
		EndCase	
		//Ŀ
		//Tratamento para substituir exatamente o campo requerido, pois estava     
		//   ocorrendo de existir um campo _CPF e _CPFRES na mesma tabela e        
		//   quando ele iria procurar o _CPF para substituir, alterava onde estava 
		//   o _CPFRES.                                                            
		//
		If At(aVariavel[j,1], aTermo[i])>0
			cAux	:=	SubStr(aTermo[i],At(aVariavel[j,1], aTermo[i]))
			cAux2	:=	""
			For nY := 1 To Len(cAux)
				If IsAlpha(SubStr(cAux,nY,1)) .Or. SubStr(cAux,nY,1)$"_1234567890"
					cAux2 += SubStr(cAux,nY,1)
				Else
					Exit
				EndIf
			Next nY

			//Somente quando for o mesmo campo entre a tabela e o exigido no layout do termo.
			If cAux2==aVariavel[j,1]
				aTermo[i]:=StrTran(aTermo[i],aVariavel[j,1],cValor)
			EndIf
		EndIf
	Next
Next

//Ŀ
// Imprime termo                                    
//

nLinTermo:=0
nColTermo:=0

@ nLinTermo, nColTermo PSAY cImpCtrl // Caracter de Controle de Impressao

For i:=1 to nTamTerm
	j:=1
	While j<=Len(aTermo[i])	
		If j<Len(aTermo[i]) .and. Substr(aTermo[i],j,2)$cAcSubst
			@ nLinTermo, nColTermo PSAY Substr(aTermo[i],j,1)
			@ nLinTermo, Pcol()-1  PSAY Substr(aTermo[i],j+1,1)
			nColTermo++ ; j++
		Else
			@ nLinTermo, nColTermo PSAY Substr(aTermo[i],j,1)
			nColTermo++
		Endif
		j++
	End
	nColTermo:=0
	nLinTermo++
Next

Return .t.

//Ŀ
// Fim da Funcao                                    
//
/*/


Ŀ
Funo     CkDrive     Autor  Juan Jose Pereira    Data  20/05/96 
Ĵ
Descrio  Verifica se drive esta disponivel para gravacao            
ٱ


*/
FUNCTION CkDrive(cDrive,lEnd)

LOCAL 	nOpc:=0, cMsg, cTitulo, cSvScr,	oDlg1

lEnd:=IIf(Empty(lEnd),.f.,lEnd)
If !IsAlpha(cDrive)
    lEnd:=.t.
	RETURN (lEnd)
Endif    	

While .t.

	SysRefresh()
	lEnd:=!IsDrive(cDrive)
    If lEnd
        cTitulo:="Ateno"
        cMsg:="Drive "+cDrive+": no est disponvel!"
		DEFINE MSDIALOG oDlg1 TITLE OemtoAnsi(cTitulo) FROM  165,145 TO 265,495 PIXEL OF oMainWnd 
				@ 03, 10 TO 30, 165 LABEL "" OF oDlg1  PIXEL
				@ 15, 30 Say OemToAnsi(cMsg) SIZE 80, 8 OF oDlg1 PIXEL
       			@ 35, 080 BUTTON "Abandona" 		SIZE 30,12 FONT oDlg1:oFont ACTION (nOpc:=1,oDlg1:End()) OF oDlg1 PIXEL
       			@ 35, 115 BUTTON "Tenta Novamente" 	SIZE 50,12 FONT oDlg1:oFont ACTION (nOpc:=2,oDlg1:End()) OF oDlg1 PIXEL
		ACTIVATE MSDIALOG oDlg1
        If nOpc==2
            Loop
		Endif            
    Endif
    Exit
End    

RETURN (lEnd)

/*/


Ŀ
Funo     CkSpace     Autor  Juan Jose Pereira    Data  01/06/96 
Ĵ
Descrio  Verifica se drive tem espaco disponivel necessario         
ٱ


*/
FUNCTION CkSpace(cDrive,lEnd,nSpace,lMsg)

LOCAL 	nOpc:=0, cMsg, cTitulo, cSvScr,oDlg1

lEnd:=IIf(Empty(lEnd),.f.,lEnd)
lMsg:=IIf(Empty(lMsg),.t.,lMsg)

If !IsAlpha(cDrive)
    lEnd:=.t.
	RETURN (lEnd)
Endif    	

While .t.
	CkDrive(cDrive,@lEnd)
	If lEnd ; Exit ; Endif
	lEnd:=(DiskSpace(nDrive)<nSpace)
    If lEnd .and. lMsg
        cTitulo:="Ateno"
        cMsg:="Drive "+cDrive+": no tem espao disponvel!"
		DEFINE MSDIALOG oDlg1 TITLE OemtoAnsi(cTitulo) FROM  165,145 TO 265,495 PIXEL OF oMainWnd 
				@ 03, 10 TO 30, 165 LABEL "" OF oDlg1  PIXEL
				@ 15, 30 Say OemToAnsi(cMsg) SIZE 80, 8 OF oDlg1 PIXEL
       			@ 35, 080 BUTTON "Abandona" 		SIZE 30,12 FONT oDlg1:oFont ACTION (nOpc:=1,oDlg1:End()) OF oDlg1 PIXEL
       			@ 35, 115 BUTTON "Tenta Novamente" 	SIZE 50,12 FONT oDlg1:oFont ACTION (nOpc:=2,oDlg1:End()) OF oDlg1 PIXEL
		ACTIVATE MSDIALOG oDlg1
        If nOpc==2
            Loop
		Endif            
    Endif
    Exit
End    

RETURN (lEnd)

/*/


Ŀ
Funo     IsDrive()   Autor  Juan Jose Pereira    Data  20/05/96 
Ĵ
Descrio  Retorna se Drive esta pronto para gravacao                 
ٱ


*/
FUNCTION IsDrive(cDrive) // [A,B,C...]

LOCAL cArqTemp, nHandle

cArqTemp:=IIf(Empty(cDrive),"C:\TESTEDRV.TMP",Upper(cDrive)+":\TESTEDRV.TMP")

nHandle:=MSFCREATE(cArqTemp)

If nHandle>0
	Ferase(cArqTemp)
	lRet:=.t.
Else
	lRet:=.f.
Endif

RETURN (lRet)
/*/


Ŀ
Funo    AvalFomentarAutor Juan Jose Pereira      Data  07/08/96 
Ĵ
Descrio  Avalia Legislacao fomentar p/Estado de Goias.              
Ĵ
 Uso       MATA930 E MATA931                                          
ٱ


/*/
FUNCTION AvalFomentar()

Local cTitLivro:=Space(9) 
Local cMV_ESTADO:=GetMv('MV_ESTADO',,"")

If SX6->(dbSeek(xFilial("SX6")+"MV_FOMENT")).and. Alltrim(SX6->X6_CONTEUD)=="S" .And. cMV_ESTADO == "GO"
	cTitLivro:=IIf(cNrLivro=="*",Space(9),"- LIVRO "+cNrLivro)
Endif

Return (cTitLivro)
/*

Ŀ
Funo     AvalCFO   Autor  Juan Jose Pereira      Data  04/09/96 
Ĵ
Descrio  Avalia CFO cadastrado para a operacao                      
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function AvalCFO(cAlias,cCFO) 

If !ExistCpo("SX5","13"+cCFO)
	Return(.f.)
Endif

If ((cAlias=="SD1".and.Val(substr(cCFO,1,1))>=5).or.;
	(cAlias$"SD2,SC6,SUB".and.Val(substr(cCFO,1,1))<5))
    HELP(" ",1,"CFOINVALID")
	Return(.f.)
Endif

Return (.t.)
/*

Ŀ
Funo     LFRound   Autor  Juan Jose Pereira      Data  08/07/96 
Ĵ
Descrio  Trunca valor, distribuindo diferenca de truncagem          
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function LFRound(nValor,nDecimais,nAcumDif,lUltimo,nDifMax)

nAcumDif:=IIf(nAcumDif==NIL,0,nAcumDif)
nDecimais:=IIf(nDecimais==NIL,2,nDecimais)
lUltimo:=IIF(lUltimo==NIL,.f.,lUltimo)
nDifMax:=IIF(nDifMax==NIL,8*10^(-1*(nDecimais+1)),nDifMax)

nValor:=Noround(nValor,nDecimais,@nAcumDif)
If Abs(nAcumDif)>=Round(10^(-1*nDecimais),nDecimais)
	nValor+=NoRound(nAcumDif,nDecimais)
	nAcumDif-=NoRound(nAcumDif,nDecimais)
Endif
//Ŀ
// Descarrega no ultimo item o resduo de arredondamento       
//
If lUltimo .and. nAcumDif>=nDifMax
	nValor+=Round(nAcumDif,nDecimais)		
Endif

Return (nValor)
/*/


Ŀ
Funo     R93xImpZer   Autor  Juan Jose Pereira    Data 03/12/96 
Ĵ
Descrio  Verifica se deve imprimir linhas sem valor                 
Ĵ
 Uso       MATR930,MATR931                                            
ٱ


*/
FUNCTION R93xImpZer(nValor)
Local lRet:=.T.
If !lImpZer.and.nValor==0
	lRet:=.F.
EndIf
Return (lRet)
/*/


Ŀ
Funo     R93xFillPage Autor  Juan Jose Pereira    Data 03/12/96 
Ĵ
Descrio  Preenche pagina sem movimento                              
Ĵ
 Uso       MATR930,MATR931                                            
ٱ


*/
FUNCTION R93xFillPage(cLayOut,cMsg,nLin,nLimPag)

Local nTamx,cFiller,j,cImprime

cImprime:=Stuff(cLayOut,2,Len(cMsg),cMsg)
FmtLin(,cImprime,,,@nLin)
nTamx:=Int(220/(nLimPag-nLin))
cFiller:=Replic("*",nTamx)
j:=5
while nLin<nLimPag
	cImprime:=Stuff(cLayOut,j,Len(cFiller),cFiller)
	FmtLin(,cImprime,,,@nLin)
	j:=j+nTamx
end

Return
/*/


Ŀ
Funo     InscrEst()   Autor  Juan Jose Pereira    Data 01/04/97 
Ĵ
Descrio  Retorna inscricao estadual da filial corrente formatada    
ٱ


*/
Function InscrEst()

Local cMask:=GetMv("MV_IEMASC"),cRet

If Empty(cMask)
	cRet:=Alltrim(SM0->M0_INSC)
Else
	cRet:=Alltrim(Transform(SM0->M0_INSC,"@R "+Alltrim(cMask)))
Endif

Return (cRet)

/*/


Ŀ
Funo     FisChkDt()   Autor     Marcos Simidu     Data 05/06/97 
Ĵ
Descrio  Compara database com MV_DTFIS                              
ٱ


*/
Function FisChkDt(dData,lHelp)

Local lRet:=.T.
Local lFISTMOV := ExistBlock("FISTMOV")

lHelp:=(IIf(lHelp==NIL,.T.,lHelp))

If lFISTMOV
	lRet :=	ExecBlock("FISTMOV",.F.,.F.,{dData})
ElseIf dData <= GetMV("MV_DATAFIS") 
	lRet := .F.
	If lHelp
		Help("",1,"MV_DATAFIS")
	Endif
Endif

Return(lRet)

/*/


Ŀ
Funo     FisChkExc()  Autor     Marcos Simidu     Data 05/06/97 
Ĵ
Descrio  Retorna data de Movimentacao Fiscal.                       
ٱ


*/
Function FisChkExc(cSerie,cNota,cClieFor,cLoja,lHelp,cTipo,cFormul)

Local aSav 		:= { Alias(), IndexOrd(), Recno() }
Local aSavF3 	:= {}
Local dData		:= cTod("//")
Local lRet		:= .T.
Local cQuery 	:= ""
Local cAliasSF3	:= "SF3"
Local lQuery 	:= .F. 

Default lHelp	:= .T.
Default cTipo	:= "" 
Default cFormul := Nil

dbSelectArea("SF3")
aSavF3 := { IndexOrd(), Recno() }
dbSetOrder(4)
#IFDEF TOP
	lQuery := .T.
	cAliasSF3 := "CHKSF3"
	cQuery := "SELECT F3_FILIAL, F3_CLIEFOR, F3_LOJA, F3_NFISCAL, F3_SERIE, F3_ENTRADA, F3_CFO, F3_EMISSAO, "
	cQuery += "SF3.R_E_C_N_O_ SF3RECNO FROM "+RetSqlName("SF3")+" SF3 "
	cQuery += "WHERE F3_FILIAL='"+xFilial("SF3")+"' AND F3_CLIEFOR='"+cClieFor+"' "
	cQuery += "AND F3_LOJA='"+cLoja+"' AND F3_NFISCAL='"+cNota+"' AND F3_SERIE='"+cSerie+"' "
	//Ŀ
	//Como podem existir documentos no SF3 de entrada/saida com mesma chave (filial+doc+serie+cliefor+loja),
	//verifica se o CFOP corresponde ao movimento de entrada/saida.                                         
	//
	If cTipo == "S"
		cQuery += "AND SUBSTRING(F3_CFO,1,1)>='5'"		
	ElseIf cTipo == "E"
		cQuery += "AND SUBSTRING(F3_CFO,1,1)<'5'"		
		If cFormul <> NIL
			cQuery += "AND F3_FORMUL='"+cFormul+"' "
		Endif
	Endif
	cQuery += "AND SF3.D_E_L_E_T_=' ' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSF3,.T.,.T.)
#ELSE
	dbSeek(xFilial("SF3")+cClieFor+cLoja+cNota+cSerie)
#ENDIF  

While (cAliasSF3)->F3_FILIAL+(cAliasSF3)->F3_CLIEFOR+(cAliasSF3)->F3_LOJA+(cAliasSF3)->F3_NFISCAL+(cAliasSF3)->F3_SERIE ==;
		(xFilial("SF3")+cClieFor+cLoja+cNota+cSerie) .And. !(cAliasSF3)->(Eof())

	If lQuery
		dbSelectArea("SF3")
		dbgoto((cAliasSF3)->(SF3RECNO))
	Else        
		//Ŀ
		//Como podem existir documentos no SF3 de entrada/saida com mesma chave (filial+doc+serie+cliefor+loja),
		//verifica se o CFOP corresponde ao movimento de entrada/saida.                                         
		//
		If (cTipo == "S" .And. !(SubStr((cAliasSF3)->F3_CFO,1,1) >= "5")) .Or. ;
			(cTipo == "E" .And. !(SubStr((cAliasSF3)->F3_CFO,1,1) < "5"))
			(cAliasSF3)->(dbSkip())
			Loop
		Endif
	EndIf
	
	If Val(substr(F3_CFO,1,1)) >= 5 .And. cTipo != "E"
		dData := F3_EMISSAO
	ElseIf (Val(substr(F3_CFO,1,1)) < 5 .And. cTipo != "S")
		dData := F3_ENTRADA
	EndIf
	
	If !Empty(dData) .And. !FisChkDt(dData,lHelp)
		lRet:=.F.
	Endif
	(cAliasSF3)->(dbSkip())
EndDo 

If !Empty(cQuery)
	dbSelectArea(cAliasSF3)
	dbCloseArea()
	dbSelectArea("SF3")
EndIf
dbSetOrder(aSavF3[1])
dbGoto(aSavF3[2])

dbSelectArea(aSav[1])
dbSetOrder(aSav[2])
dbGoto(aSav[3])

Return(lRet)
/*


Ŀ
Funo     VldAliqIcm() Autor     Marcos Simidu     Data 18/03/98 
Ĵ
Descrio  Valida aliquota de Icms.                                   
ٱ


*/
Function VldAliqIcm(nAliq,cIcm)
/*
Local lRet		:= .F.
Local aAliq		:= {}
Local cAliqs	:= GetMV("MV_ALIQICM") 
Local cParam	:= "MV_ALIQIC1/MV_ALIQIC2/MV_ALIQIC3/MV_ALIQIC4/MV_ALIQIC5/MV_ALIQIC6/MV_ALIQIC7/MV_ALIQIC8/MV_ALIQIC9/"

cIcm:=If(cIcm==NIL,"0/7/12/18/25/37",cIcm)

DbSelectArea("SX6")
SX6->(DbSetOrder(1))

//Leitura exclusiva
If SX6->(DbSeek (cFilAnt+"MV_ALIQIC1"))
	Do While !SX6->(Eof ()) .And. cFilAnt==SX6->X6_FIL .And. Alltrim(SX6->X6_VAR)$cParam
		If !Empty(SX6->X6_CONTEUD)
			cAliqs += "/" + AllTrim(SX6->X6_CONTEUD)
		EndIf
		SX6->(DbSkip ())
	EndDo
Endif
		
//Leitura Compartilhada
If SX6->(DbSeek (PadR("",FWGETTAMFILIAL)+"MV_ALIQIC1"))
	Do While !SX6->(Eof ()) .And. (SX6->X6_VAR$cParam) .And. Empty(SX6->X6_FIL)
		If !Empty(SX6->X6_CONTEUD)
			cAliqs += "/" + AllTrim(SX6->X6_CONTEUD)
		EndIf
		SX6->(DbSkip ())
	EndDo
Endif	

If Empty(cAliqs)
	aAliq:=StrTokArr(cIcm, "/")
Else
	aAliq:=StrTokArr(cAliqs, "/")
Endif

lRet:=(Ascan(aAliq,cValToChar(nAliq))>0)
*/
Return .T.
/*
/*


Ŀ
Funo       RetAliq()  Autor     Marcos Simidu     Data 18/03/98 
Ĵ
Descrio  Retorna array com aliquotas de ICM.                        
ٱ


*/
Function RetAliq(cString)
Local aRet:={},cVar:="",n:=0

For n:=1 To Len(cString)
	If !(Subs(cString,n,1)=="/").And.n!=Len(cString)
		cVar+=Subs(cString,n,1)
	Else
		If n==Len(cString)
			cVar+=Subs(cString,n,1)
		Endif
		AADD(aRet,Val(cVar))
		cVar:=""
	Endif
Next

Return(aRet)
/*/


Ŀ
Funo    Num2Chr  		Autor  Andreia dos Santos   Data  11/07/00 
Ĵ
Descrio Converte numerico para formato binario                      
ٱ


*/
Function Num2Chr(nValor,nTam,nDec)

Local nInteiro
LOCAL nDecimal
LOCAL cInteiro
LOCAL cDecimal
LOCAL cValor

nDec	:=	If(nDec==NIL,2,nDec)

nInteiro	:=	Int(nValor)
nDecimal	:=	Abs(nValor-nInteiro)

cInteiro	:=	StrZero(nInteiro,IIF(Len(AllTrim(Str(nInteiro))) <= nTam-nDec, nTam-nDec, nTam ))
cDecimal	:=	StrZero(nDecimal*(10^nDec),nDec)

cValor	:=	cInteiro+cDecimal

Return (cValor)

/*/


Ŀ
Funo    AModNot      Autor  Andreia dos Santos   Data  05/04/01 
Ĵ
Descrio Retorna codigo do modelo da nota fiscal  de acordo com o    
          Convenio 31/99.                                             
ٱ


*/

Function AModNot(cEspecie)
Local cCodigo:="01" // Default Nota Fiscal ou Nota Fiscal Fatura

//-----------------------------------------------------------------------------------------------------
//- Garante a compatibilidade de execuo da release 
//-----------------------------------------------------------------------------------------------------
If lRetTypeDoc
	Do Case
		Case Alltrim(cEspecie)=="CA"		
			cCodigo:="10" // Conh.Aereo
		Case Alltrim(cEspecie)=="CTA" 	
			cCodigo:="09" // Conh.Transp.Aquaviario
		Case Alltrim(cEspecie)=="CTF" 	
			cCodigo:="11" // Conh.Transp.Ferroviario
		Case Alltrim(cEspecie)=="CTR" 	
			cCodigo:="08" // Conh.Transp.Rodoviario
		Case Alltrim(cEspecie)=="NFCEE" 
			cCodigo:="06" // Conta de Energia Eletrica
		Case Alltrim(cEspecie)=="NFE" 	
			cCodigo:="01" // NF Entrada
		Case Alltrim(cEspecie)=="NFPS" 	
			cCodigo:="  " // NF Prestacao de Servico  
		Case Alltrim(cEspecie)=="NFS" 	
			cCodigo:="  " // NF Servico 
		Case Alltrim(cEspecie)=="NFSE"
			cCodigo:="  " // NF Servico Eletronica
		Case Alltrim(cEspecie)=="NFST" 	
			cCodigo:="07" // NF Servico de Transporte
		Case Alltrim(cEspecie)=="NFSC" 	
			cCodigo:="21" // NF Servico de Comunicacao
		Case Alltrim(cEspecie)=="NTSC" 	
			cCodigo:="21" // NF Servico de Comunicacao
		Case Alltrim(cEspecie)=="NTST" 	
			cCodigo:="22" // NF Servico de Telecomunicacoes
		Case Alltrim(cEspecie)=="NFCF" 	
			cCodigo:="02" // NF de venda a Consumidor Final
		Case Alltrim(cEspecie)=="NFP" 	
			cCodigo:="04" // NF de Produtor
		Case Alltrim(cEspecie)=="RMD" 	
			cCodigo:="18" // Resumo Movimento Diario		
		Case Alltrim(cEspecie)=="CTM" 	
			cCodigo:="26" // Conh.Transp.Multimodal
		Case Alltrim(cEspecie)=="CF" .OR. Alltrim(cEspecie)=="ECF"
			cCodigo:="02" // Cupon Fiscal gerado pelo SIGALOJA
		Case Alltrim(cEspecie)=="RPS" 
			cCodigo:="  " // Recibo Provisorio de Servicos - Nota Fiscal Eletronica de Sao Paulo 			
		Case Alltrim(cEspecie)=="SPED" 	
			cCodigo:="55" // Nota fiscal eletronica do SEFAZ.
		Case Alltrim(cEspecie)=="NFFA" 	
			cCodigo:="29" // Nota fiscal de fornecimento de agua
		Case Alltrim(cEspecie)=="NFCFG"
			cCodigo:="28" // Nota fiscal/conta de fornecimento de gas
		Case Alltrim(cEspecie)=="CTE"
			cCodigo:="57" // Conhecimento de Transporte Eletronico
		Case Alltrim(cEspecie)=="NFA"
			cCodigo:="1B" // Nota Fiscal Avulsa
			//+-------------------------------------------------------------------------------------------------------------------------+
			//| Conforme consulta realizada ao SEFAZ-MG (chamado TILOA6), Nota Fiscal Avulsa deve ter o modelo 01 e no 1B dessa forma  |
			//| executo o ponto de entrada MTMODNOT somente para a espcie NFA no estado de MG verificando se a chamada  do MATA940 .  |
			//+-------------------------------------------------------------------------------------------------------------------------+
			If IsInCallStack("MATA940") .And. SuperGetMV("MV_ESTADO") == "MG" .And. ExistBlock("MTMODNOT",,.T.)
				cCodigo:= Execblock("MTMODNOT",.F.,.F.,cEspecie)
			Endif	
		Case Alltrim(cEspecie)=="NFCE"
			cCodigo:="65" // Nota fiscal Eletronica ao Consumidor Final	
		Case Alltrim(cEspecie)=="SATCE"   //CUPOM FISCAL ELETRNICO  SAT
			cCodigo:="59" // SAT-CF-E
		Case Alltrim(cEspecie)=="CTEOS"   //Conhecimento de Transporte Eletrnico para Outros Servios - CT-e OS
			cCodigo:="67" // CT-e OS
		Case Alltrim(cEspecie)=="BPE"   //Bilhete de passagem eletrnico - BP-e
			cCodigo:="63" // BP-e
		Case Alltrim(cEspecie)=="BPR"   //Bilhete de passagem rodovirio
			cCodigo:="13"
		Case Alltrim(cEspecie)=="NF3E"//Nota fiscal Energia Eletrica Eletrnica
			cCodigo:="66"
		Case Alltrim(cEspecie)=="NFCOM"//Nota Fiscal Fatura de Servios de Comunicao
			cCodigo:="62"
		Case ExistBlock("MTMODNOT",,.T.)
			cCodigo:= Execblock("MTMODNOT",.F.,.F.,cEspecie)
	EndCase
		
	Return (cCodigo)
EndIf 
//-  importante atrealar a expedio da funo abaixo para todos os 
//- pacotes que so expedidos a fisxfun.
Return backoffice.fiscal.escrita.documentos.RetTypeDoc(cEspecie,3)

/*/


Ŀ
Funcao    ARETDIG	Autor  Andreia dos Santos      Data 05/04/01  
Ĵ
Descrio Retorna um valor numerico formatado.                        
Ĵ
Retorno   ExpC1: Valor formatado                                      
Ĵ
ParametrosExpC1: Valor a ser Formatado                                
          ExpC2: Inscricao Estadual                                   
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function ARETDIG(cValor,lInscr,cEstado)
Local cRet 	:= ""
Local nX	:=0

For nX := 1 To Len(cValor)
	If IsDigit(Substr(cValor,nX,1)) .or. (If(lInscr,IsAlpha(Substr(cValor,nX,1)),.f.))
		cRet	+=	Substr(cValor,nX,1)
	Endif
Next

If lInscr .and.( empty(cRet) .or. cEstado =="EX" .OR."ISENT"$upper(cRet)) 
	cRet := "ISENTO"
EndIf
	
Return(cRet)

/*


ͻ
Function  aFISFILL  Autor  Andreia dos Santos   Data   05/04/01   
͹
Desc.      Encaixa conteudo no espaco especificado.                   
͹
Uso        Mata940A                                                   
ͼ


*/
Function aFISFill(cConteudo,nTam)

cConteudo	:=	If(cConteudo==NIL,"",cConteudo)
If Len(cConteudo)>nTam
	cRetorno	:=	Substr(cConteudo,1,nTam)
Else
	cRetorno	:=	cConteudo+Space(nTam-Len(cConteudo))
Endif

Return (cRetorno)


/*


ͻ
Function  F3Filial  Autor  Denis Martins        Data   09/20/01   
͹
Desc.      Tratamento de Filiais - F3_MSFIL                           
͹
ParametrosExpC1: Filial Corrente                                      
			 ExpC2: Filial SF3                                           
͹
Uso        Generico - Fontes Livros Fiscais                           
ͼ


*/
Function F3Filial( cAlias,cSF3 )
Local cFil     := ""
Local cRetFil  := ""
Local lF3MsFil := .F.

Default cSF3 := "SF3"
cFil := "F3_MSFIL"
lF3MsFil := (cSF3)->(FieldPos(cFil))>0

If lF3MsFil 
	If FWModeAccess(cAlias,3)=="C"
		cRetFil := xFilial(cAlias)
	Else
		cRetFil := (cSF3)->(FieldGet(FieldPos(cFil)))
	Endif
Else 
	cRetFil := xFilial(cAlias)
Endif	                     
  
Return cRetFil
/*

Ŀ
Funo        FunRur Autor   Eduardo J Zanardo     Data 05.02.2002
Ĵ
Descrio  Retorna o array contendo os percentuais do FunRural.       
                                                                      
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function FunRur()
Local aPFunRur  := {}           
Local npRural   := GetMv("MV_CONTSOC")
Local nX 		:= len(npRural)
While nx > 0
    nX:=At("/",npRural)
	AADD(aPFunRur,IIf(nX > 0,Subs(npRural,1,nX-1),npRural)) 
	npRural:=Subs(npRural,nX+1,len(npRural))
End
//
//aPFunRur[1]  == "F"
//aPFunRur[2]  == "L"
//aPFunRur[3]  == "J"
//

Return (aPFunRur)
/*

Ŀ
Funo	 PicPesFJ  | Autor  Nereu Humberto Jr.     Data 25/04/2003
Ĵ
Descrio  Retorna a picture do CGC ou CPF                            
Ĵ
Sintaxe	  ExpL1 := PicPesFJ(cTipPes)                              	  
Ĵ
Parametros cTipPes - F-Fisica/J-Juridica                              
Ĵ
 Uso		  Generico 										    	  
ٱ

*/
Function PicPesFJ(cTipPes)
Local cPict := ""
If cTipPes == "F"
	cPict := "@R 999.999.999-99"
Else
	cPict := "@R! NN.NNN.NNN/NNNN-99"
Endif

Return cPict

/*/


Ŀ
Funcao    FisChkCfps     Autor Sergio S. Fuzinaka  Data  18/02/05 
Ĵ
Descricao Verifica na TES se o CFPS refere-se a Entrada ou Saida      
Ĵ
Uso       Generico                                                    
ٱ


*/
Function FisChkCfps(cTES,cCfop)

Local aArea		:= GetArea()
Local aSF4		:= SF4->(GetArea())
Local lRet		:= .F.
Static aCfps	:= {}

If Len(aCfps) == 0
	dbSelectArea("SF4")
	dbSetOrder(1)
	dbSeek(xFilial("SF4"))
	While !Eof() .And. SF4->F4_FILIAL==xFilial("SF4")
		If Left(Alltrim(SF4->F4_CF),1)=="9"
			AADD(aCfps,{SF4->F4_CF,SF4->F4_TIPO})
		Endif
		dbSkip()
	Enddo
Endif

If Ascan(aCfps,{|x| x[1]==cCfop .And. x[2]==cTES}) > 0
	lRet := .T.
Endif
	
RestArea(aSF4)
RestArea(aArea)

Return(lRet)

/*


ͻ
Programa  FisxLogo  Autor  Mary C. Hergert      Data  10/08/2006  
͹
Desc.     Retorna o arquivo com o logotipo padrao da empresa corrente.
                                                                      
͹
Uso       SigaFis                                                     
ͼ


*/
Function FisxLogo(cTipo)

Local cStartPath	:= GetSrvProfString("Startpath","")
Local cLogo 		:= ""

Default cTipo 	:= "1"

//Ŀ
//Seleciona o logotipo da filial posicionada
//
If cTipo =="1"
	cLogo := cStartPath + "LGRL"+allTrim(SM0->M0_CODIGO)+allTrim(SM0->M0_CODFIL)+".BMP" 	// Empresa+Filial
	If !File( cLogo )
		cLogo := cStartPath + "LGRL"+allTrim(SM0->M0_CODIGO)+".BMP" 				// Empresa
	endif
Else		
	//Ŀ
	//Seleciona o logotipo padrao da Microsiga
	//
	cLogo := cStartPath + "LogoSiga.bmp"
Endif

Return cLogo
/*/


Ŀ
Funo     NFisOrig()   Autor   Sueli C. Santos     Data 28/08/08 
Ĵ
Descrio  Retorna o doucmento Original da nota de Saida.             
ٱ


*/
Function RastroNFOr(cNota,cSerie,cCliente,cLoja)

Local aAreaSD2  := GetArea()
Local aRastro 	:= {}
Local cQuery 	:= ""
Local cAliasSD2	:= "SD2"
Local cAliasSD1	:= "SD1"
Local cAliasSD5 := "SD5"
Local cAliasSF1 := "SF1"
Local lQuery 	:= .F. 
Local nICM      := 0
Local nBse      := 0
Local aAreaSD2	:= {}

aAreaSD2	:= SD2->(GetArea())
RetIndex("SD2")

dbSelectArea("SD2")    
dbSelectArea("SD1")  
dbSelectArea("SD5")               

SD2->(DbSetOrder(3))
SD1->(DbSetOrder(4))
SD5->(DbSetOrder(2))

#IFDEF TOP

	lQuery := .T.
	cAliasSD2 := "CHKSD2"
	cQuery := "SELECT DISTINCT D1_DOC NF_ENTR, D1_SERIE SERIE_ENTR,D2_FILIAL,D2_COD,D2_LOCAL,D2_QUANT,D5_NUMSEQ,"
	cQuery += "D1_VUNIT VUNITE,D1_QUANT QTDENTR,D2_CLIENTE,D2_LOJA,D2_DOC,D2_SERIE,D1_DTDIGIT,D1_FORNECE,D2_TIPO,"
	cQuery += "D1_LOJA,D1_ITEM,D1_EMISSAO,D1_BASEICM,D1_VALICM,D1_PICM,D1_NUMSEQ,D1_CF,D1_BRICMS,D2_CF,D2_BRICMS,"
	cQuery += "D1_TOTAL,D1_VALFRE,D1_SEGURO,D1_DESPESA,D1_VALDESC,D1_ALIQSOL,D1_TIPO,F1_EST,D2_ITEM,D2_TES, D1_TES, D1_ICMSRET, "	
	cQuery += "D2_TOTAL, D2_VALFRE,D2_DESPESA, D2_VALIPI, D2_VALICM, D1_LOTECTL  " 
	cQuery += ", D1_ICMNDES "
	cQuery += ", D1_BASNDES "
	
	cQuery += "FROM "+RetSqlName("SD2")+" SD2, "  + RetSqlName("SD5")+ " SD5, "+ RetSqlName("SD1")+ " SD1, "+ RetSqlName("SF1")+ " SF1 "
	cQuery += "WHERE SD2.D2_FILIAL='"+xFilial("SD2")+"' AND SD2.D2_COD = SD5.D5_PRODUTO "    
	cQuery += "AND D2_LOJA='"+cLoja+"' AND D2_DOC='"+cNota+"' AND D2_SERIE='"+cSerie+"' "
   	cQuery += "AND SD2.D2_COD=SD5.D5_PRODUTO AND D2_CLIENTE='"+cCliente+"' " 
	cQuery += "AND SD2.D2_LOCAL=SD5.D5_LOCAL AND SD2.D2_LOTECTL=SD5.D5_LOTECTL "
	cQuery += "AND SD2.D2_NUMLOTE=SD5.D5_NUMLOTE "
	
	cQuery += "AND SD5.D5_FILIAL='" +xFilial("SD5")+"'"  
	cQuery += "AND SD5.D5_ORIGLAN<'501' "   
	cQuery += "AND SD5.D5_ESTORNO<>'S' "
	
	cQuery += "AND SD1.D1_FILIAL='"+xFilial("SD1")+"'"
	cQuery += "AND SD1.D1_DOC=SD5.D5_DOC "
	cQuery += "AND SD1.D1_SERIE=SD5.D5_SERIE "	
	cQuery += "AND SD1.D1_FORNECE=SD5.D5_CLIFOR "
	cQuery += "AND SD1.D1_LOJA=SD5.D5_LOJA "	
	cQuery += "AND SD1.D1_NUMSEQ=SD5.D5_NUMSEQ "
	
	cQuery += "AND SF1.F1_FILIAL='"+xFilial("SF1")+"'"
	cQuery += "AND SF1.F1_DOC=SD5.D5_DOC "
	cQuery += "AND SF1.F1_SERIE=SD5.D5_SERIE "	
	cQuery += "AND SF1.F1_FORNECE=SD5.D5_CLIFOR "
	cQuery += "AND SF1.F1_LOJA=SD5.D5_LOJA "
	cQuery += "AND SD2.D_E_L_E_T_=' ' "
	cQuery += "AND SD5.D_E_L_E_T_=' ' "
	cQuery += "AND SD1.D_E_L_E_T_=' ' "
	cQuery += "AND SF1.D_E_L_E_T_=' ' "

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD2,.T.,.T.)

#ELSE
	(cAliasSD2)->(dbSeek(xFilial("SD2")+cNota+cSerie+cCliente+cLoja))
#ENDIF

While (cAliasSD2)->D2_FILIAL+(cAliasSD2)->D2_CLIENTE+(cAliasSD2)->D2_LOJA+(cAliasSD2)->D2_DOC+(cAliasSD2)->D2_SERIE ==;
		(xFilial("SD2")+cCliente+cLoja+cNota+cSerie) .And. !(cAliasSD2)->(Eof())
         
		If !lQuery  								    			
            
            (cAliasSD5)->(dbSeek(xFilial("SD5")+(cAliasSD2)->D2_COD+(cAliasSD2)->D2_LOCAL+(cAliasSD2)->D2_LOTECTL))
			
			Do while (cAliasSD5)->D5_FILIAL  == (cAliasSD2)->D2_FILIAL .AND.;
				     (cAliasSD5)->D5_PRODUTO == (cAliasSD2)->D2_COD    .AND.;
				     (cAliasSD5)->D5_LOCAL   == (cAliasSD2)->D2_LOCAL  .AND.;
				     (cAliasSD5)->D5_LOTECTL == (cAliasSD2)->D2_LOTECTL .AND.;
				     (cAliasSD5)->D5_NUMLOTE == (cAliasSD2)->D2_NUMLOTE .AND.;				     
			         !(cAliasSD5)->(Eof())      
			         
			  if (cAliasSD5)->D5_ESTORNO == 'S' .or. (cAliasSD5)->D5_ORIGLAN >= '501'
			   	 (cAliasSD5)->(dbSkip())		
			  else
			     Exit
			  endif	     
            
            Enddo
            
			If (cAliasSD1)->(dbSeek(xFilial("SD1")+(cAliasSD5)->D5_NUMSEQ))
			
			nICM := (cAliasSD1)->D1_ICMNDES
			nBse := (cAliasSD1)->D1_BASNDES
			
			(cAliasSF1)->(dbSeek(xFilial("SF1")+(cAliasSD2)->D2_DOC+(cAliasSD2)->D2_SERIE+(cAliasSD2)->D2_CLIENTE+(cAliasSD2)->D2_LOJA+(cAliasSD2)->D2_TIPO))  			    
  			if (cAliasSD1)->D1_TIPO<>'D'      			    
			  AADD(aRastro,{(cAliasSD1)->D1_DOC,(cAliasSD1)->D1_SERIE,(cAliasSD2)->D2_COD,(cAliasSD2)->D2_QUANT,;
		   			      (cAliasSD1)->D1_VUNIT,(cAliasSD1)->D1_QUANT,(cAliasSD1)->D1_DTDIGIT,;
		   			      (cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,(cAliasSD1)->D1_ITEM,;
		   			      (cAliasSD1)->D1_EMISSAO,(cAliasSD1)->D1_BASEICM,(cAliasSD1)->D1_VALICM,;
		   			      (cAliasSD1)->D1_PICM,(cAliasSD1)->D1_NUMSEQ,(cAliasSF1)->F1_EST,nICM,nBse,;
			              (cAliasSD1)->D1_TOTAL,(cAliasSD1)->D1_VALFRE,(cAliasSD1)->D1_SEGURO,;
			              (cAliasSD1)->D1_DESPESA,(cAliasSD1)->D1_VALDESC,(cAliasSD1)->D1_ALIQSOL,;
			              (cAliasSD2)->D2_ITEM,(cAliasSD2)->D2_DOC,(cAliasSD2)->D2_SERIE,;
			              (cAliasSD2)->D2_CLIENTE,(cAliasSD2)->D2_LOJA,(cAliasSD2)->D2_TES,(cAliasSD1)->D1_CF,;
			              (cAliasSD1)->D1_TIPO,(cAliasSD1)->D1_BRICMS,(cAliasSD2)->D2_CF,(cAliasSD2)->D2_BRICMS,;
			              (cAliasSD2)->D2_TIPO,(cAliasSD1)->D1_TES,(cAliasSD1)->D1_ICMSRET,;
		                  (cAliasSD2)->D2_TOTAL,(cAliasSD2)->D2_VALFRE,(cAliasSD2)->D2_DESPESA,(cAliasSD2)->D2_VALIPI,(cAliasSD2)->D2_VALICM,,(cAliasSD1)->D1_LOTECTL})						              			            			              
			Endif
			              
			Endif
		
		Else

			nICM := (cAliasSD2)->D1_ICMNDES
			nBse :=(cAliasSD2)->D1_BASNDES  
			
            if (cAliasSD2)->D1_TIPO<>'D'
			  AADD(aRastro,{(cAliasSD2)->NF_ENTR,(cAliasSD2)->SERIE_ENTR,(cAliasSD2)->D2_COD,(cAliasSD2)->D2_QUANT,;
			                (cAliasSD2)->VUNITE,(cAliasSD2)-> QTDENTR,stod((cAliasSD2)->D1_DTDIGIT),;
			                (cAliasSD2)->D1_FORNECE,(cAliasSD2)->D1_LOJA,(cAliasSD2)->D1_ITEM,;
			                stod((cAliasSD2)->D1_EMISSAO),(cAliasSD2)->D1_BASEICM,(cAliasSD2)->D1_VALICM,;
			                (cAliasSD2)->D1_PICM,(cAliasSD2)->D1_NUMSEQ,(cAliasSD2)->F1_EST,;
			                nICM,nBse,(cAliasSD2)->D1_TOTAL,(cAliasSD2)->D1_VALFRE,(cAliasSD2)->D1_SEGURO,;
			                (cAliasSD2)->D1_DESPESA,(cAliasSD2)->D1_VALDESC,(cAliasSD2)->D1_ALIQSOL,;
			                (cAliasSD2)->D2_ITEM,(cAliasSD2)->D2_DOC,(cAliasSD2)->D2_SERIE,(cAliasSD2)->D2_CLIENTE,;
			                (cAliasSD2)->D2_LOJA,(cAliasSD2)->D2_TES,(cAliasSD2)->D1_CF,(cAliasSD2)->D1_TIPO,;
			                (cAliasSD2)->D1_BRICMS,(cAliasSD2)->D2_CF,(cAliasSD2)->D2_BRICMS,(cAliasSD2)->D2_TIPO,(cAliasSD2)->D1_TES,(cAliasSD2)->D1_ICMSRET,;
			                (cAliasSD2)->D2_TOTAL, (cAliasSD2)->D2_VALFRE,(cAliasSD2)->D2_DESPESA,(cAliasSD2)->D2_VALIPI,(cAliasSD2)->D2_VALICM, (cAliasSD2)->D1_LOTECTL})						              			             
            Endif			              
        EndIf
	    (cAliasSD2)->(dbSkip())
	
EndDo

If !Empty(cQuery)
	dbSelectArea(cAliasSD2)
	dbCloseArea()
Else             
	RetIndex("SD2")
	dbSelectArea(cAliasSD1)
	dbCloseArea()        
	dbSelectArea(cAliasSD5)
	dbCloseArea()
EndIf

RestArea(aAreaSD2)
Return(aRastro)                     
/*


Ŀ
Funo    RetDocOrig Autor Microsiga S/A           Data  03/04/09 
Ĵ
Descriao  Pesquisa os documentos de entrada referentes a um lote de  
           de producao. (Somente utilizado com controle de SubLotes)  
Ĵ
Sintaxe    RetDocOrig(ExpC1,ExpC2,ExpC3,ExpC4,ExpN1)                  
Ĵ
Parametros ExpC1 = Codigo do Produto                                  
           ExpC2 = Codigo do Armazem                                  
           ExpC3 = Codigo do Lote                                     
           ExpC4 = Codigo do SubLote                                  
           ExpN1 = Quantidade de producao                             
Ĵ
Retorno    Array Contendo as informacoes abaixo:                      
           aRet[nX,nY,1] = Numero do documento de entrada             
           aRet[nX,nY,1] = Serie do documento de entrada              
           aRet[nX,nY,1] = Fornecedor do documento de entrada         
           aRet[nX,nY,1] = Loja do documento de entrada 		      
           aRet[nX,nY,1] = NUMSEQ do item do documento de entrada 	  
           aRet[nX,nY,1] = Quantidade de materia-prima utilizada 	  
Ĵ
 Uso       FISCAL                                                     
ٱ


*/
Function RetDocOrig(cCod,cLocal,cLoteCtl,cNumLote,nQuant)

Local cAliasSD5:= 'SD5'
Local cIndSD5  := ''	
Local cDoc     := CriaVar("D5_DOC"     ,.F.)
Local cFornece := CriaVar("D5_CLIFOR" ,.F.)
Local cLoja    := CriaVar("D5_LOJA"    ,.F.)

Local nPos       := 0
Local nCnt       := 0
Local nTotalProd := 0

Local aProducao:= {}
Local aMatPrima:= {}
Local aDocto   := {}
Local aRet     := {}

Local aAreaAnt := GetArea()
Local aAreaSB8 := SB8->(GetArea())
Local aAreaSD5 := SD5->(GetArea())

#IFDEF TOP
	Local cQuery	:=	""
#ELSE
    Local cChave	:=	""
	Local cIndex    :=	""
	Local cFiltro 	:=	""
#ENDIF

Default cCod     := ''
Default cLocal   := ''
Default cLoteCtl := ''
Default cNumLote := ''
Default nQuant   := 1

//-- Somente processar produtos que possuem controle de rastreabilidade por Sub-Lote
If Rastro(cCod,'S')
	dbSelectArea("SD5")
	dbSetOrder(2)
	If dbSeek(xFilial("SD5")+cCod+cLocal+cLoteCtl+cNumLote)
		If !Empty(SD5->D5_OP)
		#IFDEF TOP  
			If TcSrvType()<>"AS/400"
				//-- Query para pesquisar o lote/sublote de producao
				cAliasSD5 := GetNextAlias()
				cQuery :=   "SELECT D5_FILIAL,D5_PRODUTO,D5_LOCAL,D5_LOTECTL,D5_NUMLOTE,D5_DOC,D5_ORIGLAN,D5_QUANT FROM "+RetSqlName("SD5")+" SD5 "
				cQuery +=    "WHERE D5_FILIAL  = '"+ xFilial("SD5") + "' "
				cQuery +=     " AND D5_DOC = '"    + SD5->D5_DOC    + "' "
				cQuery +=     " AND D5_SERIE = '"  + SD5->D5_SERIE  + "' "
				cQuery +=     " AND D5_OP = '"     + SD5->D5_OP     + "' "
				cQuery +=     " AND D5_ESTORNO = ' ' "
				cQuery +=     " AND D_E_L_E_T_ = ' ' "
				cQuery +=" ORDER BY D5_FILIAL,D5_PRODUTO,D5_LOCAL,D5_LOTECTL,D5_NUMLOTE "
				cQuery := ChangeQuery(cQuery)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD5,.T.,.T.)
			Else	
		#ENDIF
				cIndex  := CriaTrab(NIL,.F.)
				cChave	:=	IndexKey()
				cFiltro	:=	"SD5->D5_FILIAL == '" + xFilial("SD5") + "' .AND. D5_DOC == '"+SD5->D5_DOC+"' .AND. D5_SERIE == '"+SD5->D5_SERIE+"'"
				cFiltro	+=  " .AND. D5_OP == '"+SD5->D5_OP+"' .AND. D5_ESTORNO == ' ' "
				IndRegua(cAliasSD5,cIndex,cChave,,cFiltro)
				dbSelectArea(cAliasSD5)
				dbGoTop()
		#IFDEF TOP
			Endif
		#ENDIF
        Endif
        
		cIndSD5	:=	CriaTrab(NIL,.F.)
	
			Do While (cAliasSD5)->(!Eof())                                      	
				nPos := ASCAN(aProducao,{|x| x[1] == D5_PRODUTO .And. x[2] == D5_LOCAL .And. x[3] == D5_LOTECTL .And. x[4] == D5_NUMLOTE })
				If nPos == 0
					If cCod == (cAliasSD5)->D5_PRODUTO
						nTotalProd := (cAliasSD5)->D5_QUANT
					Else
						If (cAliasSD5)->D5_ORIGLAN > '500'
							aAdd(aProducao,{D5_PRODUTO,D5_LOCAL,D5_LOTECTL,D5_NUMLOTE,D5_QUANT})
						Else
							aAdd(aProducao,{D5_PRODUTO,D5_LOCAL,D5_LOTECTL,D5_NUMLOTE,D5_QUANT*(-1)})
						EndIf	
					EndIf	
				Else
					If (cAliasSD5)->D5_ORIGLAN > '500'
						aProducao[nPos,5] += D5_QUANT
					Else
						aProducao[nPos,5] -= D5_QUANT
					EndIf	
				EndIf	
				nPos := ASCAN(aMatPrima,{|x| x[1] == D5_PRODUTO .And. x[2] == D5_LOCAL })
				If nPos == 0
					If (cAliasSD5)->D5_ORIGLAN > '500'
						aAdd(aMatPrima,{D5_PRODUTO,D5_LOCAL,D5_QUANT})
					Else
						aAdd(aMatPrima,{D5_PRODUTO,D5_LOCAL,D5_QUANT*(-1)})
					EndIf	
				Else
					If (cAliasSD5)->D5_ORIGLAN > '500'
						aMatPrima[nPos,3] += D5_QUANT
					Else
						aMatPrima[nPos,3] -= D5_QUANT
					EndIf	
				EndIf	
				(cAliasSD5)->(dbSkip())
			EndDo
			
			#IFDEF TOP
				dbSelectArea(cAliasSD5)
				dbCloseArea()
			#ELSE
				dbSelectArea(cAliasSD5)
				RetIndex(cAliasSD5)
				Ferase(cIndSD5+OrdBagExt())
			#ENDIF

			//-- Descobre os documentos de origem das materias-primas utilizadas na linha de producao
		For nCnt := 1 to Len(aProducao)

		#IFDEF TOP  
			If TcSrvType()<>"AS/400"
				//-- Query para pesquisar o documento de origem
				cAliasSD5 := GetNextAlias()
				cQuery :=   "SELECT D5_FILIAL,D5_NUMSEQ, D5_DOC, D5_SERIE, D5_CLIFOR, D5_LOJA, D5_QUANT FROM "+RetSqlName("SD5")+" SD5 "
				cQuery +=    "WHERE D5_FILIAL = '"+xFilial("SD5")+"' "
				cQuery +=         " AND D5_PRODUTO = '"+aProducao[nCnt,1]+"' "
				cQuery +=         " AND D5_LOCAL   = '"+aProducao[nCnt,2]+"' "
				cQuery +=         " AND D5_LOTECTL = '"+aProducao[nCnt,3]+"' "
				cQuery +=         " AND D5_NUMLOTE = '"+aProducao[nCnt,4]+"' "
				cQuery +=         " AND D5_ORIGLAN <= '500' "
				cQuery +=         " AND D5_ESTORNO = ' ' "
				cQuery +=         " AND D5_DOC <> '"     + cDoc     + "' "
				cQuery +=         " AND D5_CLIFOR <> '"  + cFornece + "' "
				cQuery +=         " AND D5_LOJA <> '"    + cLoja    + "' "
				cQuery +=         " AND D_E_L_E_T_ = ' ' "
				cQuery +=" ORDER BY " + SqlOrder(SD5->(IndexKey()))
				cQuery := ChangeQuery(cQuery)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD5,.T.,.T.)
            Else
		#ENDIF
				cIndex  := CriaTrab(NIL,.F.)
				cChave	:=	IndexKey()
				cFiltro	:=	"SD5->D5_FILIAL == '" + xFilial("SD5") + "' .AND. D5_PRODUTO == '"+aProducao[nCnt,1]+"' .AND. D5_LOCAL == '"+aProducao[nCnt,2]+"'"
				cFiltro	+=  " .AND. D5_LOTECTL == '"+aProducao[nCnt,3]+"' .AND. D5_NUMLOTE == '"+aProducao[nCnt,4]+"'  .AND. D5_ORIGLAN <= '500' .AND. D5_ESTORNO == ' ' "
				cFiltro	+=	" .AND. D5_DOC <> '"+cDoc+"' .AND. D5_CLIFOR <> '"+cFornece+"' .AND. D5_LOJA <> '"+cLoja+"' "
				IndRegua(cAliasSD5,cIndex,cChave,,cFiltro)
				dbSelectArea(cAliasSD5)
				dbGoTop()
		#IFDEF TOP
			Endif
		#ENDIF
	
		cIndSD5	:=	CriaTrab(NIL,.F.)
    	        
			aDocto := {}
			Do While (cAliasSD5)->(!Eof())
				nPos := ASCAN(aMatPrima,{|x| x[1] == aProducao[nCnt,1] .And. x[2] == aProducao[nCnt,2] })
				If nPos > 0
					aAdd(aDocto,  {	(cAliasSD5)->D5_DOC,;
								 	(cAliasSD5)->D5_SERIE,;
								 	(cAliasSD5)->D5_CLIFOR,;
								 	(cAliasSD5)->D5_LOJA,;
								 	(cAliasSD5)->D5_NUMSEQ,;
								 	((aMatPrima[nPos,3]/nTotalProd)*IIf(nQuant==0,1,nQuant))})
				EndIf	
				(cAliasSD5)->(dbSkip())
			EndDo
							
			If Len(aDocto) > 0
				aAdd(aRet,aDocto)
			EndIf			
		Next nCnt
		
		#IFDEF TOP
			dbSelectArea(cAliasSD5)
			dbCloseArea()
		#ELSE
			dbSelectArea(cAliasSD5)
			RetIndex(cAliasSD5)
			Ferase(cIndSD5+OrdBagExt())
		#ENDIF
		
	EndIf
EndIf

RestArea(aAreaSB8)
RestArea(aAreaSD5)
RestArea(aAreaAnt)

Return aRet     

/*


ͻ
Funcao    FisxForm  Autor  Angelica A. Rabelo   Data   30/08/01   
͹
Desc.     Formatar uma string para ser utilizada no clausula IN do    
          comando SELECT em ambiente SQL.                             
          Exemplo:                                                    
          FisxForm("BA /AB-/CA-/XX+", "/")= "('BA','AB-','CA-','XX+')"
          Parametros:                                                 
          cString  -> String a ser formatada                          
          cSep     -> Separador das strings                           
          Retorno:                                                    
          cRet  -> String formatada, conforme exemplo                 
͹
Uso                                                                   
ͼ


*/
FUNCTION FisxForm( cString, cSep, nTam )
   LOCAL cRet := "('",; // array de string separadas
         nPoSep         // posicao do separador da string
	DEFAULT nTam := 0
   WHILE .T.
      // localiza a posicao do separador e separa a string encontrada
      If nTam > 0  
      	nPoSep := nTam
      Else
	      nPoSep := AT(cSep,cString)
	   Endif 
      cRet   += IF(nPoSep#0, LEFT(cString,nPoSep-If(nTam>0,0,1))+"','", cString)
      // verifica se existem mais separadores
      IF nPoSep#0 
      	If Len(cString) > nTam
         	cString := SUBSTR(cString,nPoSep+1)
         Else
         	cRet := Left(cRet,Len(cRet)-3)
     			cRet += "')"
   	      EXIT
   	   Endif	
      ELSE
			cRet += "')"
         EXIT
      ENDIF
   ENDDO

RETURN cRet
STATIC __aDePara := NIL

/*

FUNCAO PARA TESTAR O ALGORITIMO

User Function Cifra()
Local nTeste
Local aTeste := {}
Local nPos := 0
 
For nTeste := 1 to 99999999
	cNovoNum := GCifra(nTeste)
	conout( strzero(nTeste,9) +" CODE  "+cNovoNum )
 	nPos := ascan(aTeste,cNovoNum) 
 	if nPos > 0 
  		UserException("ERRO POS: "+str(nPos,6)+" CODE: "+cNovoNum)
 	Endif
 	aadd(aTeste,cNovoNum)
Next
 
Return  
*/
/*


ͻ
Programa  GCifra    Autor  Julio Wittwer        Data   10/05/09   
͹
Desc.     Gera um numero identificador unico de 9 digitos             
          |  a partir de um numero de 8 digitos, sem repeticao         
          Observacao : Criptografa apenas os 6 digitos apos os 2      
          | primeiros.                                                 
͹
Uso        AP                                                         
ͼ


*/
Function GCifra(nNum, nDig)
local cRet 		:= ""
local cDocChv
private aValid	:= {}

//Caso ja exista chave gerada para o documento, no gera nova chave. 

cDocChv := getDocChv()	
if( !empty(cDocChv) )
	cRet := substr(cDocChv, 36, 8)
else
	aValid := getRandom()
	if validRandom()
		cRet := aValid[2]
	endif
endif	

return ( cRet )

/*


ͻ
Programa  XFUNCFRec Autor  Demetrio De Los Rios Data   13/10/2011 
͹
Desc.      Funcao retorna array 3 posicoes onde,                      
           [01] - CFOPS que devem ser considerados como receita        
           [02] - CFOPS que NAO devem ser considerados como receita     
           [03] - CFOPS receitas nao operacionais                     
͹
Uso        SPEDPISCOF                                                   
ͼ


*/
Function XFUNCFRec()

Local alRet		:= {"","",""}       

//Ŀ
// CFOP's DE RECEITA            
//
alRet[1] :=" 5101,5102,5103,5104,5105,5106,5109,5110,5111,5112,5113,5114" 
alRet[1] +=",5115,5116,5117,5118,5119,5120,5122,5123,5124,5125,5251,5525"
alRet[1] +=",5253,5254,5255,5256,5257,5301,5302,5303,5304,5305,5306,5307"
alRet[1] +=",5351,5352,5353,5354,5305,5306,5307,5351,5352,5353,5354,5355"
alRet[1] +=",5356,5357,5359,5401,5402,5403,5405,5651,5652,5653,5654,5655"
alRet[1] +=",5656,6101,6102,6103,6104,6105,6106,6107,6108,6109,6110,6111" 
alRet[1] +=",6112,6113,6114,6115,6116,6117,6118,6119,6120,6122,6123,6124"
alRet[1] +=",6125,6251,6252,6253,6254,6255,6256,6257,6258,6301,6302,6303"
alRet[1] +=",6304,6305,6306,6307,6351,6352,6353,6354,6355,6356,6357,6359"
alRet[1] +=",6401,6402,6403,6404,6501,6502,6651,6652,6653,6654,6655,6656"
alRet[1] +=",7101,7102,7105,7106,7127,7251,7301,7358,7501,7651,7664,"     
                                       
//Ŀ
// CFOPs CONTIDAS NO PARAMETRO MV_CFAREC - CONSIDERADAS COMO RECEITA 
//
alRet[1] += AllTrim(SuperGetMv("MV_CFAREC",.F.,""))

//Ŀ
//CFOPs CONTIDAS NO PARAMETRO MV_CFEREC - NAO CONSIDERAR COMO RECEITA 
//
alRet[2] := LeParSeq("MV_CFEREC") 

//Ŀ
//CFOPs CONTIDAS NO PARAMETRO MV_CFNREC - RECEITA NAO OPERACIONAL     
//
// Por padro sero considerados os Cdigos abaixo, pois se referem a devoluo de compras,
// e as notas fiscais com esses CFOPs devem ser consideradas na gerao do arquivo, mas
// no podem ser consideradas como receita no registro 0111 do SPED/PIS-COFINS
alRet[3] := "5201,5202,5208,5209,5210,5410,5411,5503,5661,"
alRet[3] += "6201,6202,6208,6209,6210,6410,6411,6503,6661,"
alRet[3] += AllTrim(SuperGetMv("MV_CFNREC",.F.,""))	

Return alRet

/*/


Ŀ
Programa  LeParSeq	 Autor Microsiga                    30/09/2009 
Ĵ
Descrio Funcao para ler varios paramentros que se iniciam com o mesmo
           nome. Ex: MV_DCTF??? onde pode ser MV_DCTF000, MV_DCTF001, 
          etc...                                                      
Ĵ
ObservacaocPar -> Nome do parametro                                   
          cContPad -> Conteudo padrao a ser retornado caso o mesmo nao
           exista.                                                    
Ĵ
Retorno   cRet -> Conteudo do parametro                               
Ĵ


/*/
Function LeParSeq(cPar,cContPad)
Local	cRet	:=	""

Default	cPar	:=	""

cPar	:=	AllTrim(cPar)

//Leitura exclusiva
If SX6->(MsSeek (cFilAnt+cPar))
	Do While !SX6->(Eof ()) .And. (cPar$SX6->X6_VAR) .And. (cFilAnt==SX6->X6_FIL)
		If !Empty(SX6->X6_CONTEUD)
			cRet	+=	"/"+AllTrim (SX6->X6_CONTEUD)
		EndIf
		SX6->(DbSkip ())
	EndDo
EndIf	
	
//Leitura Compartilhada
If SX6->(MsSeek (PadR("",FWGETTAMFILIAL)+cPar))
	Do While !SX6->(Eof ()) .And. (cPar$SX6->X6_VAR) .And. Empty(SX6->X6_FIL)
		If !Empty(SX6->X6_CONTEUD)
			cRet	+=	"/"+AllTrim (SX6->X6_CONTEUD)
		EndIf
		SX6->(DbSkip ())
	EndDo
EndIf

If Empty(cRet)
	cRet	:=	Iif(cContPad<>Nil,cContPad,"")
EndIf

If cPar=="MV_SUBTRIB" .And. Empty(cRet) .And. FindFunction("GETSUBTRIB")
	cRet := GetSubTrib()
Endif

Return cRet

/*


Ŀ
Funo     RastroItem   Autor   Vitor Felipe	      Data 01/12/11 
Ĵ
Descrio  Rastro de Saidas, do Bem Ativo para calculo do IPI. 		  
			  Parametros:							  					  
			 	cCod	= Codigo do Produto							      
			 	cLote	= Lote do Produot							      
			 	cSLote	= Sub-Lote do Produto							  
ٱ


*/
Function RastroItem(cCod,cLote,cSLote)

Local cAliasSD2	:= "SD2"
Local lQuery 	:= .F. 

Local nQuant	:= 0
Local cIndex	:= ""
Local cFiltro	:= ""
Local aAreaSB8	:= SB8->(GetArea())
Local aAreaSD2	:= SD2->(GetArea())
Local aRet		:= {.F.,0}

Default cCod	:= ""
Default cLote	:= ""
Default cSLote	:= ""

dbSelectArea("SD2")    
SD2->(DbSetOrder(1))

#IFDEF TOP
	lQuery := .T.
	If (TcSrvType ()<>"AS/400")
	    cAliasSD2	:=	GetNextAlias()	
		BeginSql Alias cAliasSD2
			SELECT
				SUM(SD2.D2_QUANT) QUANT
			FROM 
				%Table:SD2% SD2 
			WHERE 					
				SD2.D2_FILIAL=%xFilial:SD2% AND 
				SD2.D2_COD = %Exp:cCod% AND
				SD2.D2_LOTECTL = %Exp:cLote% AND
				SD2.D2_NUMLOTE = %Exp:cSLote% AND					
				SD2.%NotDel%
		EndSql
	EndIF

#ENDIF

If !lQuery
    cIndex	:= CriaTrab(NIL,.F.)
	cFiltro	:= "D2_FILIAL=='"+xFilial("SD2")
	cFiltro	+= "'D2_COD ==  cCod .AND. D2_LOTECTL = cLote .AND. D2_NUMLOTE = cSLote"

    IndRegua (cAliasSD2, cIndex, cAliasSD2->(IndexKey ()),, cFiltro)
    nIndex := RetIndex(cAliasSD2)

	#IFNDEF TOP
		DbSetIndex (cIndex+OrdBagExt())
	#ENDIF
	
	DbSelectArea (cAliasSD2)
    DbSetOrder (nIndex+1)

	While (cAliasSD2)->(!Eof())
		nQuant += (cAliasSD2)->D2_QUANT
		(cAliasSD2)->(dbSkip())
	EndDo
	
	dbSelectArea(cAliasSD2)
	RetIndex(cAliasSD2)
	dbClearFilter()
	Ferase(cIndex+OrdBagExt())
Else
	nQuant := (cAliasSD2)->QUANT
	dbSelectArea(cAliasSD2)
	dbCloseArea()
EndIf

dbSelectArea("SB8")    
SB8->(DbSetOrder(5))
//Ŀ
//Tratamento verifica a quantidade na Tabela SB8 (Saldo por Lote) de acordo com alinhamento Marcos Vinicius 
//de Materiais se a quantidade de sadas for menor que o saldo do Lote/SubLote continua calculando IPI.     
//
If SB8->(MsSeek(xFilial("SB8")+cCod+cLote+cSLote))
	//VERIFICA SE HOUVE MOVIMENTACAO DO PRODUTO
	If nQuant > 0
		//SE A QUANTIDADE FOR MAIOR QUE A ORIGINAL DE ENTRADA JA DESCONSIDERA PARA TRIBUTACAO
		If nQuant >= SB8->B8_QTDORI
			aRet[1]	:= .F.						//Logico de utilizacao 
			aRet[2]	:= 0						//Qtd Liberada
		//RETORNA A QUANTIDADE DESCONTANDO AS MOVIMENTACOES.
		Else
			aRet[1]	:= .T.						//Logico de utilizacao 
			aRet[2]	:= SB8->B8_QTDORI - nQuant	//Qtd Liberada
		EndIf
	//NAO HOUVE MOVIMENTACOES ANTERIORES RETORNANDO O VALOR TOTAL PARA SER UTILIZADO.
	Else
		aRet[1]	:= .T.							//Logico de utilizacao 
		aRet[2]	:= SB8->B8_QTDORI				//Qtd Liberada	
	EndIf
EndIf

RestArea(aAreaSB8)
RestArea(aAreaSD2)

Return(aRet) 

/*


ͻ
Programa  RetSTRedf   Autor  Camila Janurio   Data   20/08/12    
͹
Desc.      Identifica a situao tributria de acordo com o CFOP      
                                                                      
͹
Uso        REDF - Sergipe											  
ͼ


*/
Function RetSTRedf(cCFOP,cST)

Local cRet    := "0"
Local lIseImu := .F.
Local lDifSusp:= .F.
Default cCFOP := "0000"
//P
//Formata o contedo da Sit. tributria caso esteja com mais caracteres
//P       
cST := Right(Alltrim(cST),2)
//Ŀ
//Define as condicoes de isencao e imunidade ou diferimento e suspensao
//
If cST $ "40|41"
	lIseImu := .T.
Elseif cST $ "50|51" 
    lDifSusp := .T.
Endif                       
//Ŀ
//Classifica o tipo de sit. tributria aceita pelo validador e retorna o tipo correspondente
//1 = Revenda de Mercadoria no sujeita a Substituio Tributria
//2 = Venda de Mercadoria Industrializada pelo Emitente	
//3 = Revenda de Mercadoria Sujeita a Substituio Tributria ou Antecipao com Encerramento de Fase 
//4 = Revenda de Mercadoria Isenta ou Imune
//5 = Revenda de Mercadoria com Diferimento e Suspenso
//
If Alltrim(cCFOP) $ "5102|5104|5106|5110|5112|5114|5115|5117|5119|5120|5123|6102|6104|6106|6110|6112|6114|6115|6117|6119|6120|6123|7102|7106"  
	If lIseImu                                               
		cRet := "4" 
	Elseif lDifSusp
		cRet := "5" 
	Else
		cRet := "1" 
	Endif	
Elseif Alltrim(cCFOP) $ "5101|5103|5105|5109|5111|5113|5116|5117|5118|5122|6101|6103|6105|6109|6111|6113|6116|6118|6122|7101|7105|7127"  
	cRet := "2" 
Elseif Alltrim(cCFOP) $ "5403|5405|6403|6404" 
	If lIseImu
		cRet := "4" 
	Elseif lDifSusp
		cRet := "5" 
	Else   		
		cRet := "3" 
	Endif	
Endif

Return cRet

/*


ͻ
Programa  a410PROISS		 Vitor Felipe        Data  29/06/2012  
͹
Desc.       Controle dos Abatimentos para o calculo do ISS.           
͹
Uso        MATA410                                                    
ͼ


*/
Function a410INCISS(lEnd)

Local _stru		:={}
Local aCpoBro 	:= {}
Local lDedMa	:= .F.
Local lDedSr	:= .F.
Local cAliasSD1	:= "SD1"
Local cAliasSD3	:= "SD3"
Local cCampos	:= ""
Local cWhere	:= ""
Local cAliasTRB	:= GetNextAlias()
Local cArq		:= ""
Local cMark		:= ""
Local nTotal	:= 0
Local nValISS	:= 0
Local nAbtISS	:= 0 
Local nAbtMAT	:= 0
Local aTitles	:= {}
Local aObjetos  := {0,0,0,0}
Local cIndex 	:= ""
Local cFiltro	:= ""
Local nIndex	:= 0
Local nProjeto	:= aScan(aHeader,{|x| AllTrim(x[2])=="C6_PROJPMS"})
Local nProduto	:= aScan(aHeader,{|x| AllTrim(x[2])=="C6_PRODUTO"})
Local nCodISS	:= aScan(aHeader,{|x| AllTrim(x[2])=="C6_CODISS"})
Local aButtons	:= {}
Local cIntPMS	:= SuperGetMv("MV_INTPMS",.F.,"N")
Local cJoin		:= ""
Local cQueryAlt	:= SuperGetMv("MV_TABABAT",.F.,"SD1")
Local nPerMat	:= 0
Local nPerSer	:= 0

Private lInverte := .F.
Private oMarISS
Private oFolISS
Private oDlgISS

Default lEnd 	:= .F.

cAliasSD1 := cQueryAlt

AADD(_stru,{"TRB_OKISS"		,"C"	,2							,0})
AADD(_stru,{"TRB_FILIAL"	,"C"	,TamSX3('D1_FILIAL')[1]		,0})
AADD(_stru,{"TRB_DOC"		,"C"	,TamSX3('D1_DOC')[1]		,0})
AADD(_stru,{"TRB_SERIE"		,"C"	,TamSX3('D1_SERIE')[1]		,0})
AADD(_stru,{"TRB_ITEM"		,"C"	,TamSX3('D1_ITEM')[1]		,0})
AADD(_stru,{"TRB_COD"		,"C"	,TamSX3('D1_COD')[1]		,0})
AADD(_stru,{"TRB_DESC"		,"C"	,TamSX3('B1_DESC')[1]		,0})
AADD(_stru,{"TRB_DTDIGT"	,"D"	,TamSX3('D1_DTDIGIT')[1]	,0})
AADD(_stru,{"TRB_TOTAL"		,"N"	,TamSX3('D1_TOTAL')[1]		,TamSX3('D1_TOTAL')[2]})
AADD(_stru,{"TRB_VALISS"	,"N"	,TamSX3('D1_VALISS')[1]		,TamSX3('D1_VALISS')[2]	})
AADD(_stru,{"TRB_ABTISS"	,"N"	,TamSX3('D1_ABATISS')[1]	,TamSX3('D1_ABATISS')[2]})
AADD(_stru,{"TRB_ABTMAT"	,"N"	,TamSX3('D1_ABATMAT')[1]	,TamSX3('D1_ABATMAT')[2]})
AADD(_stru,{"TRB_FORNEC"	,"C"	,TamSX3('D1_FORNECE')[1]	,0})
AADD(_stru,{"TRB_LOJA"		,"C"	,TamSX3('D1_LOJA')[1]		,0})
AADD(_stru,{"TRB_PROJET"	,"C"	,TamSX3('D2_PROJPMS')[1]	,0})
AADD(_stru,{"TRB_EDT"		,"C"	,TamSX3('D2_EDTPMS')[1]	,0})
AADD(_stru,{"TRB_TASK"		,"C"	,TamSX3('D2_TASKPMS')[1]	,0})
AADD(_stru,{"TRB_NUMSEQ"	,"C"	,TamSX3('D3_NUMSEQ')[1]	,0})
AADD(_stru,{"TRB_LOCAL"		,"C"	,TamSX3('D3_LOCAL')[1]	,0})

aAdd(aCpoBro,{"TRB_OKISS"	,,STR0011			,"@!"}) 					//"Mark"
aAdd(aCpoBro,{"TRB_FILIAL"	,,STR0012			,"@!"})						//"Filial"
aAdd(aCpoBro,{"TRB_DOC"		,,STR0013			,"@!"})						//"Nota Fiscal"
aAdd(aCpoBro,{"TRB_SERIE"	,,STR0014			,"!!!"})						//"Serie"
aAdd(aCpoBro,{"TRB_ITEM"	,,STR0015			,"@!"})						//"Item"
aAdd(aCpoBro,{"TRB_COD"		,,STR0016			,"@!"})						//"Produto"
aAdd(aCpoBro,{"TRB_DESC"	,,STR0017			,"@!"})						//"Descrio"
aAdd(aCpoBro,{"TRB_DTDIGT"	,,STR0018			,"@!"})						//"Dt. Digitao"
aAdd(aCpoBro,{"TRB_TOTAL"	,,STR0019			,"@E 99,999,999,999.99"})	//"Valor Total"
aAdd(aCpoBro,{"TRB_VALISS"	,,STR0020			,"@E 99,999,999,999.99"})	//"Valor ISS"
aAdd(aCpoBro,{"TRB_ABTISS"	,,STR0021			,"@E 99,999,999,999.99"})	//"Abat. Servio"
aAdd(aCpoBro,{"TRB_ABTMAT"	,,STR0022			,"@E 99,999,999,999.99"})	//"Abat. Material"
aAdd(aCpoBro,{"TRB_FORNEC"	,,STR0023			,"@!"})						//"Fornecedor"
aAdd(aCpoBro,{"TRB_LOJA"	,,STR0024			,"@!"})						//"Loja"
aAdd(aCpoBro,{"TRB_PROJET"	,,STR0025			,"@!"})						//"Projeto"
aAdd(aCpoBro,{"TRB_TASK"	,,STR0026			,"@!"})						//"Tarefa"
aAdd(aCpoBro,{"TRB_EDT"		,,STR0042			,"@!"})						//"EDT"
aAdd(aCpoBro,{"TRB_NUMSEQ"	,,STR0027			,"@!"})						//"Sequencial"
aAdd(aCpoBro,{"TRB_LOCAL"	,,STR0028			,"@!"})						//"Local"

aAdd(aTitles,"Total Apurado:") //"Total Apurado:"

cArq:=Criatrab(_stru,.T.)

DBUSEAREA(.t.,,carq,cAliasTRB)

If Len(aCols) > 0
	dbSelectArea("CC2")
	dbSetOrder(1)
	//BUSCA INFORMACOES NA TABELA DE MUNICIPIOS
	If CC2->(msSeek(xFilial("CC2")+M->C5_ESTPRES+M->C5_MUNPRES))
		If  CC2->CC2_MDEDMA == "1"
			lDedMa	:= .T.
		EndIf
		If CC2->CC2_MDEDSR == "1"
			lDedSr	:= .T.
		EndIf
		If CC2->CC2_PERMAT > 0
			nPerMat := CC2->CC2_PERMAT
		EndIf
		If CC2->CC2_PERSER > 0
		   	nPerSer := CC2->CC2_PERSER
		EndIf
	EndIf
	
	//PESQUISA TABELA CE1 (ALIQUOTA DO ISS) = FILIAL+CODISS(CFPS)+ESTADO+CODMUN+COD PRODUTO
	
	dbSelectArea("CE1")
	dbSetOrder(1)
	If CE1->(msSeek(xFilial("CE1")+aCols[N,nCodISS]+M->C5_ESTPRES+AllTrim(M->C5_MUNPRES)+aCols[N,nProduto]))
		//ALTERACAO DO MUNICIPIO					
		If CE1->CE1_RMUISS == "2"
	       	aCols[N,nCodISS] := CE1->CE1_CPRISS
		Else
			aCols[N,nCodISS] := CE1->CE1_CTOISS
		EndIf
		M->C5_FORNISS := CE1->CE1_FORISS
		MaFisAlt("IT_ALIQISS",CE1->CE1_ALQISS,N)
	EndIf
	CE1->(dbCloseArea())
EndIf

DbSelectArea (cAliasSD1)
(cAliasSD1)->(DbSetOrder(6))

DbSelectArea (cAliasSD3)
(cAliasSD3)->(DbSetOrder(1))

DbSelectArea ("CE2")
CE2->(DbSetOrder(1))

If cIntPMS == "S"
	DbSelectArea ("AFN")
	AFN->(DbSetOrder(2))
	
	DbSelectArea ("AF8")
	AF8->(DbSetOrder(1))
EndIf

If cQueryAlt == "SD1"
	//INICIO DA QUERY PRINCIPAL	COM SD1
	#IFDEF TOP
		If (TcSrvType ()<>"AS/400")	
			//BUSCA CAMPOS ADICIONAIS
			cCampos += "%"
			cCampos += ",B1_MEPLES"
			cCampos += ",D1_OKISS"							    	
			cCampos += ",CE2_NUMPV"							    	
			If cIntPMS == "S"
				cCampos += ",AFN_PROJET,AFN_TAREFA "
			EndIf
			cCampos += "%"
			//BUSCA WHERES ADICIONAIS			
			cWhere += "%"
			If cIntPMS == "S"
				cWhere += "AFN.AFN_PROJET='"+%Exp:aCols[n,nProjeto]%+"' AND "
				//RETIRADO POR RECOMENDACAO EQUIPE PMS/SOLUM.
				//cWhere += "AFN.AFN_TAREFA='"+%Exp:aCols[n,nTarefa]%+"' AND "	
			EndIf
			cWhere += "(SD1.D1_OKISS='' Or CE2.CE2_NUMPV <> '')"							    						
			cWhere += "%" 
			//BUSCA JOINS ADICIONAIS
			cJoin +="%"		
			If cIntPMS == "S"
				cJoin +="LEFT JOIN "+RetSQLName("AF8")+" AF8 ON(AF8.AF8_FILIAL='"+xFilial("AF8")+"' AND AF8.AF8_PROJET='"+aCols[n,nProjeto]+"' AND AF8.D_E_L_E_T_=' ')"
				cJoin +="LEFT JOIN "+RetSQLName("AFN")+" AFN ON(AFN.AFN_FILIAL='"+xFilial("AFN")+"' AND AFN.AFN_DOC=SD1.D1_DOC AND AFN.AFN_SERIE=SD1.D1_SERIE AND AFN.AFN_FORNEC=SD1.D1_FORNECE AND AFN.AFN_LOJA=SD1.D1_LOJA AND AFN.AFN_ITEM=SD1.D1_ITEM AND AFN.AFN_PROJET=AF8.AF8_PROJET AND AFN.AFN_REVISA=AF8.AF8_REVISA AND AFN.D_E_L_E_T_=' ')"
			EndIf
			cJoin +="%"
			cAliasSD1 := GetNextAlias()
			BeginSql Alias cAliasSD1
	
				column D1_DTDIGIT as Date    
				
				SELECT 
					D1_FILIAL,D1_DOC,D1_SERIE,D1_DTDIGIT,D1_FORNECE,D1_LOJA,D1_COD,D1_CC,D1_TOTAL,D1_VALDESC,D1_VALFRE,D1_SEGURO,
					D1_DESPESA,D1_VALIPI,D1_VALDEV,D1_VALISS,D1_ABATISS,D1_ABATMAT,D1_ITEM,D1_CODISS,
					A2_NOME,A2_EST,A2_MUN,A2_CGC,
					B1_DESC,B1_CODISS
					%Exp:cCampos%
				FROM
					%Table:SD1% SD1
					LEFT JOIN %Table:SB1% SB1 ON(SB1.B1_FILIAL=%xFilial:SB1%  AND SB1.B1_COD=SD1.D1_COD AND SB1.%NotDel%)
					LEFT JOIN %Table:SA2% SA2 ON(SA2.A2_FILIAL=%xFilial:SA2%  AND SA2.A2_COD=SD1.D1_FORNECE AND SA2.A2_LOJA=SD1.D1_LOJA AND SA2.%NotDel%)
					LEFT JOIN %Table:CE2% CE2 ON(CE2.CE2_FILIAL=%xFilial:CE2% AND CE2.CE2_NUMPV=%Exp:M->C5_NUM% AND CE2.CE2_PRODPV=SD1.D1_COD AND CE2.CE2_ITEMPV=SD1.D1_ITEM AND CE2.CE2_DOCNF=SD1.D1_DOC AND CE2.CE2_SERINF=SD1.D1_SERIE AND CE2.CE2_FORNNF=SD1.D1_FORNECE AND CE2.CE2_LOJANF=SD1.D1_LOJA AND CE2.CE2_ITEMNF=SD1.D1_ITEM AND CE2.%NotDel%)
					%Exp:cJoin%
				WHERE
					SD1.%NotDel% AND
					SD1.D1_FILIAL=%xFilial:SD1% AND
					SD1.D1_DTDIGIT>=%Exp:DToS(mv_par01)% AND
					SD1.D1_DTDIGIT<=%Exp:DToS(mv_par02)% AND
					SD1.D1_TIPO='N' AND
					%Exp:cWhere%					
			EndSql
	  	Else
	#ENDIF  
			cIndex	:= CriaTrab(NIL,.F.)
			cFiltro	:= 'SD1->D1_FILIAL=="'+xFilial ("SD1")+'" .And. '
			cFiltro += 'DToS (SD1->D1_DTDIGIT)>="'+DToS(mv_par01)+'".And.DToS (SD1->D1_DTDIGIT)<="'+DToS(mv_par02)+'" .And. '
			cFiltro += 'SD1->D1_TIPO=="N" .And. '
			cFiltro += '(SD1->D1_ABATISS > 0 Or SD1->D1_ABATMAT > 0)'
			
			IndRegua (cAliasSD1,cIndex,SD1->(IndexKey()),,cFiltro)
			nIndex := RetIndex(cAliasSD1) + 1
		
	#IFNDEF TOP
			DbSetIndex(cIndex+OrdBagExt())
	#ENDIF
				
	#IFDEF TOP
		Endif
	#ENDIF
Else
	//INICIO DA QUERY PRINCIPAL	COM SD3
	#IFDEF TOP
		If (TcSrvType ()<>"AS/400")	
			//BUSCA CAMPOS ADICIONAIS
			cCampos += "%"
			cCampos += ",B1_MEPLES"
			cCampos += ",D3_OKISS"							    	
			cCampos += ",CE2_NUMPV,CE2_NUMSEQ"							    	
			If cIntPMS == "S"
				cCampos += ",D3_PROJPMS,D3_TASKPMS "
			EndIf
			cCampos += "%"
			//BUSCA WHERES ADICIONAIS			
			cWhere += "%"
			If cIntPMS == "S"
				cWhere += "SD3.D3_PROJPMS='"+%Exp:aCols[n,nProjeto]%+"' AND "
				//RETIRADO POR RECOMENDACAO EQUIPE PMS/SOLUM.
				//cWhere += "SD3.D3_TASKPMS='"+%Exp:aCols[n,nTarefa]%+"' AND "	
			EndIf
			cWhere += "(SD3.D3_OKISS='' Or CE2.CE2_NUMPV <> '')"							    						
			cWhere += "%" 
			cAliasSD3 := GetNextAlias()
			BeginSql Alias cAliasSD3
				column D1_DTDIGIT as Date
				column D3_EMISSAO as Date        
				
				SELECT 
					D3_FILIAL,D3_TM,D3_COD,D3_LOCAL,D3_EMISSAO,D3_LOTECTL,D3_ESTORNO,D3_QUANT,D3_NUMSEQ,D3_DOC,D3_NUMSEQ,
					D1_FILIAL,D1_DOC,D1_SERIE,D1_DTDIGIT,D1_FORNECE,D1_LOJA,D1_COD,D1_CC,D1_TOTAL,D1_VALDESC,D1_VALFRE,D1_SEGURO,
					D1_DESPESA,D1_VALIPI,D1_VALDEV,D1_VALISS,D1_ABATISS,D1_ABATMAT,D1_ITEM,D1_CODISS,D1_QUANT,
					A2_NOME,A2_EST,A2_MUN,A2_CGC,
					B1_DESC,B1_CODISS
					%Exp:cCampos%
				FROM
					%Table:SD3% SD3
					LEFT JOIN %Table:SB1% SB1 ON(SB1.B1_FILIAL=%xFilial:SB1%  AND SB1.B1_COD=SD3.D3_COD AND SB1.%NotDel%)
					LEFT JOIN %Table:SD1% SD1 ON(SD1.D1_FILIAL=%xFilial:SD1% AND SD3.D3_COD = SD1.D1_COD AND SD1.D1_LOTECTL = SD3.D3_LOTECTL AND SD1.D1_LOCAL = SD3.D3_LOCAL AND SD3.%NotDel%) 
					LEFT JOIN %Table:SA2% SA2 ON(SA2.A2_FILIAL=%xFilial:SA2%  AND SA2.A2_COD=SD1.D1_FORNECE AND SA2.A2_LOJA=SD1.D1_LOJA AND SA2.%NotDel%)
					LEFT JOIN %Table:CE2% CE2 ON(CE2.CE2_FILIAL=%xFilial:CE2% AND CE2.CE2_NUMPV=%Exp:M->C5_NUM% AND CE2.CE2_PRODPV=SD1.D1_COD AND CE2.CE2_ITEMPV=SD1.D1_ITEM AND CE2.CE2_DOCNF=SD1.D1_DOC AND CE2.CE2_SERINF=SD1.D1_SERIE AND CE2.CE2_FORNNF=SD1.D1_FORNECE AND CE2.CE2_LOJANF=SD1.D1_LOJA AND CE2.CE2_ITEMNF=SD1.D1_ITEM AND CE2.CE2_NUMSEQ=SD3.D3_NUMSEQ AND CE2.%NotDel%)
				WHERE
					SD3.%NotDel% AND
					SD3.D3_FILIAL=%xFilial:SD3% AND
					SD3.D3_TM >= '500' AND
					SD3.D3_ESTORNO <> 'S' AND
					SD3.D3_EMISSAO>=%Exp:DToS(mv_par01)% AND
					SD3.D3_EMISSAO<=%Exp:DToS(mv_par02)% AND
					SD3.D3_LOTECTL <> ' ' AND					
					SD1.D1_TIPO='N' AND
					%Exp:cWhere%					
			EndSql
	  	Else
	#ENDIF  
			cIndex	:= CriaTrab(NIL,.F.)
			cFiltro	:= 'SD3->D3_FILIAL=="'+xFilial ("SD3")+'" .And. '
			cFiltro += 'DToS(SD3->D3_ESTORNO)>="'+DToS(mv_par01)+'" .And. DToS(SD3->D3_ESTORNO)<="'+DToS(mv_par02)+'" .And. '
			cFiltro += 'SD3->D3_TM >= "500" .And. '
			cFiltro += 'SD3->D3_ESTORNO <> "S"'
			IndRegua(cAliasSD3,cIndex,SD3->(IndexKey()),,cFiltro)
			nIndex := RetIndex(cAliasSD3) + 1
		
	#IFNDEF TOP
			DbSetIndex(cIndex+OrdBagExt())
	#ENDIF
				
	#IFDEF TOP
		Endif
	#ENDIF
EndIf
//FIM QUERY PRINCIPAL

If cQueryAlt == "SD3"
	DbSelectArea(cAliasTRB)    
	cMark := GetMark()
	ProcRegua ((cAliasSD3)->(RecCount()))
	If (cAliasSD3)->(!Eof())
		While (cAliasSD3)->(!Eof())
			RecLock(cAliasTRB,.T.)
				TRB_OKISS	:= cMark
				TRB_FILIAL	:= (cAliasSD3)->D1_FILIAL
				TRB_DOC	    := (cAliasSD3)->D1_DOC
				TRB_SERIE	:= (cAliasSD3)->D1_SERIE
				TRB_ITEM	:= (cAliasSD3)->D1_ITEM
				TRB_COD	    := (cAliasSD3)->D1_COD
				TRB_DESC	:= (cAliasSD3)->B1_DESC
				TRB_DTDIGT	:= (cAliasSD3)->D1_DTDIGIT	
				TRB_TOTAL	:= (cAliasSD3)->D1_TOTAL * (cAliasSD3)->(D3_QUANT/D1_QUANT)
				TRB_VALISS	:= (cAliasSD3)->D1_VALISS * (cAliasSD3)->(D3_QUANT/D1_QUANT)
				If !Empty((cAliasSD3)->B1_CODISS)
					If nPerSer > 0
						TRB_ABTISS	:= ((cAliasSD3)->D1_TOTAL * (cAliasSD3)->(D3_QUANT/D1_QUANT))*(nPerSer/100)
					Else
						TRB_ABTISS	:= (cAliasSD3)->D1_TOTAL * (cAliasSD3)->(D3_QUANT/D1_QUANT)
					EndIf
				Else
					If nPerMat > 0 
						TRB_ABTMAT	:= ((cAliasSD3)->D1_TOTAL * (cAliasSD3)->(D3_QUANT/D1_QUANT))*(nPerMat/100)
					Else
						TRB_ABTMAT	:= (cAliasSD3)->D1_TOTAL * (cAliasSD3)->(D3_QUANT/D1_QUANT)					
					EndIf
				EndIf
				TRB_FORNEC	:= (cAliasSD3)->D1_FORNECE
				TRB_LOJA	:= (cAliasSD3)->D1_LOJA
				If cIntPMS == "S"
					TRB_PROJET	:= (cAliasSD3)->D3_PROJPMS
					TRB_TASK	:= (cAliasSD3)->D3_TASKPMS
					TRB_EDT		:= ""
				EndIf
				TRB_NUMSEQ	:= (cAliasSD3)->D3_NUMSEQ
				TRB_LOCAL	:= (cAliasSD3)->D3_LOCAL
			(cAliasTRB)->(MsunLock())
			nTotal 	+=	(cAliasSD3)->D1_TOTAL * (cAliasSD3)->(D3_QUANT/D1_QUANT)		//1- VALOR TOTAL DAS NOTAS FISCAIS
			nValISS +=	(cAliasSD3)->D1_VALISS * (cAliasSD3)->(D3_QUANT/D1_QUANT)		//2- VALOR TOTAL DO ISS
			If !Empty((cAliasSD3)->B1_CODISS)
		   		//4- VALOR TOTAL DE ABATIMENTO DE SERVICOS
				If nPerSer > 0
					nAbtISS	+= ((cAliasSD3)->D1_TOTAL * (cAliasSD3)->(D3_QUANT/D1_QUANT))*(nPerSer/100)
				Else
					nAbtISS	+= (cAliasSD3)->D1_TOTAL * (cAliasSD3)->(D3_QUANT/D1_QUANT)
				EndIf
			Else
				//4- VALOR TOTAL DE ABATIMENTO DE MATERIAIS
				If nPerMat > 0
					nAbtMAT	+= ((cAliasSD3)->D1_TOTAL * (cAliasSD3)->(D3_QUANT/D1_QUANT))*(nPerMat/100)
				Else
					nAbtMAT	+= (cAliasSD3)->D1_TOTAL * (cAliasSD3)->(D3_QUANT/D1_QUANT)
				EndIf
			EndIf
			(cAliasSD3)->(DbSkip())
			IncProc(STR0030) //"Processando Notas de Entrada..."
		Enddo
	Else
		Alert(STR0031) //"Nao foram encontrados Registros para atribuir ao Pedido de Venda"
		Return()
	EndIf
Else
	DbSelectArea(cAliasTRB)    
	cMark := GetMark()
	ProcRegua ((cAliasSD1)->(RecCount()))
	If (cAliasSD1)->(!Eof())
		While (cAliasSD1)->(!Eof())
			RecLock(cAliasTRB,.T.)
		  		TRB_OKISS	:= cMark
				TRB_FILIAL	:= (cAliasSD1)->D1_FILIAL
				TRB_DOC	    := (cAliasSD1)->D1_DOC
				TRB_SERIE	:= (cAliasSD1)->D1_SERIE
				TRB_ITEM	:= (cAliasSD1)->D1_ITEM
				TRB_COD	    := (cAliasSD1)->D1_COD
				TRB_DESC	:= (cAliasSD1)->B1_DESC
				TRB_DTDIGT	:= (cAliasSD1)->D1_DTDIGIT
				TRB_TOTAL	:= (cAliasSD1)->D1_TOTAL
				TRB_VALISS	:= (cAliasSD1)->D1_VALISS
				If !Empty((cAliasSD1)->B1_CODISS)
					If nPerSer > 0
						TRB_ABTISS	:= (cAliasSD1)->D1_TOTAL * (nPerSer/100)
					Else
						TRB_ABTISS	:= (cAliasSD1)->D1_TOTAL
					EndIf
				Else
					If nPerMat > 0 
						TRB_ABTMAT	:= (cAliasSD1)->D1_TOTAL * (nPerMat/100)
					Else
						TRB_ABTMAT	:= (cAliasSD1)->D1_TOTAL
					EndIf
				EndIf
				TRB_FORNEC	:= (cAliasSD1)->D1_FORNECE
				TRB_LOJA	:= (cAliasSD1)->D1_LOJA
				If cIntPMS == "S"
					TRB_PROJET	:= (cAliasSD1)->AFN_PROJET
					TRB_TASK	:= (cAliasSD1)->AFN_TAREFA
					TRB_EDT		:= ""
				EndIf
			(cAliasTRB)->(MsunLock())
			nTotal 	+=	(cAliasSD1)->D1_TOTAL 	 	//1- VALOR TOTAL DAS NOTAS FISCAIS
			nValISS +=	(cAliasSD1)->D1_VALISS		//2- VALOR TOTAL DO ISS
			If !Empty((cAliasSD1)->B1_CODISS)			
				//3- VALOR TOTAL DE ABATIMENTO DE SERVICOS
				If nPerSer > 0
					nAbtISS	+= (cAliasSD1)->D1_TOTAL * (nPerSer/100)
				Else
					nAbtISS	+= (cAliasSD1)->D1_TOTAL
				EndIf
			Else
				//4- VALOR TOTAL DE ABATIMENTO DE MATERIAIS
				If nPerMat > 0
					nAbtMAT	+= (cAliasSD1)->D1_TOTAL * (nPerMat/100)
				Else
					nAbtMAT	+= (cAliasSD1)->D1_TOTAL
				EndIf
			EndIf
			(cAliasSD1)->(DbSkip())
			IncProc(STR0030) //"Processando Notas de Entrada..."
		Enddo
	Else
		Alert(STR0031) //"Nao foram encontrados Registros para atribuir ao Pedido de Venda"
		Return()
	EndIf
EndIf

AADD(aButtons,{"SelectAll",{||ISSBUMARK(cAliasTRB,.T.,cMark,@nTotal,@nValISS,@nAbtISS,@nAbtMAT,aObjetos)},STR0032}) //"Marcar"
AADD(aButtons,{"UnselectAll",{||ISSBUMARK(cAliasTRB,.F.,cMark,@nTotal,@nValISS,@nAbtISS,@nAbtMAT,aObjetos)},STR0033}) //"Desmarcar"

DEFINE MSDIALOG oDlgISS TITLE STR0034 From 9,0 To 500,800 PIXEL //"Notas Fiscais de Entrada"
DbSelectArea(cAliasTRB)
DbGotop()

oMarISS := MsSelect():New(cAliasTRB,"TRB_OKISS","",aCpoBro,@lInverte,@cMark,{15,1,200,400},,,,,)
oMarISS:bMark := {| | ISSDisp(cAliasTRB,cMark,@nTotal,@nValISS,@nAbtISS,@nAbtMAT,aObjetos)}

oFolISS := TFolder():New(210,001,aTitles,{"HEADER"},oDlgISS,,,,.T., .F.,400,035)

@ 010,005 SAY STR0035	SIZE 40,10 PIXEL OF oFolISS:aDialogs[1] //"Valor Total:"
@ 230,035 MSGET aObjetos[1] VAR nTotal PICTURE "@E 99,999,999,999.99" OF oDlgISS PIXEL WHEN .F. HASBUTTON 

@ 010,105 SAY STR0036	  	SIZE 40,10 PIXEL OF oFolISS:aDialogs[1] //"Total ISS:"
@ 230,130 MSGET aObjetos[2] VAR nValISS PICTURE "@E 99,999,999,999.99" OF oDlgISS PIXEL WHEN .F. HASBUTTON
	
@ 010,205 SAY STR0037		SIZE 40,10 PIXEL OF oFolISS:aDialogs[1] //"Servios:"
@ 230,230 MSGET aObjetos[3] VAR nAbtISS PICTURE "@E 99,999,999,999.99" OF oDlgISS PIXEL WHEN .F. HASBUTTON
	
@ 010,300 SAY STR0038		SIZE 40,10 PIXEL OF oFolISS:aDialogs[1] //"Materiais:"
@ 230,325 MSGET aObjetos[4] VAR nAbtMAT PICTURE "@E 99,999,999,999.99" OF oDlgISS PIXEL WHEN .F. HASBUTTON

ACTIVATE MSDIALOG oDlgISS CENTERED ON INIT EnchoiceBar(oDlgISS,{|| GrIISMUN(cAliasTRB,nAbtISS,nAbtMAT,cMark,.T.)},{|| ISSENDDLG()},.F.,aButtons)

(cAliasTRB)->(DbCloseArea())
Iif(File(cArq + GetDBExtension()),FErase(cArq  + GetDBExtension()) ,Nil)

#IFDEF TOP
	If (TcSrvType ()<>"AS/400")
		DbSelectArea(cAliasSD1)
		(cAliasSD1)->(DbCloseArea())
		(cAliasSD3)->(DbCloseArea())		
	Else
#ENDIF
   		RetIndex("SFT")
   		FErase(cIndex+OrdBagExt())
#IFDEF TOP
	EndIf
#ENDIF

lEnd := .T.

DbSelectArea ("CE2")
CE2->(dbCloseArea())

DbSelectArea ("AFN")
AFN->(dbCloseArea())

DbSelectArea ("AF8")
AF8->(dbCloseArea())

Return()

/*


ͻ
Programa   ISSDisp  Autor   Vitor Felipe        Data  29/06/2012  
͹
Desc.      Funcao de controle e Atualizacao dos Objetos:			  
           	MarkBrowse: Ao selecionar os itens.						  
           	aObjetos: Controle dos MSGETS para somar valores.         
͹
Uso        MATA410                                                    
ͼ


*/
Static Function ISSDisp(cAliasTRB,cMark,nTotal,nValISS,nAbtISS,nAbtMAT,aObjetos)

Local nX 			:= 0
Default cAliasTRB	:= "TRB"
Default cMark		:= ""
Default nTotal		:= 0
Default nValISS		:= 0
Default nAbtISS		:= 0
Default nAbtMAT		:= 0
Default aObjetos	:= 0

RecLock(cAliasTRB,.F.)
//VERIFICA SE O MARK ESTA MARCADO (.T. MARCADO E .F. DESMARCADO)
If Marked("TRB_OKISS")  
	nTotal	+= (cAliasTRB)->TRB_TOTAL
	nValISS	+= (cAliasTRB)->TRB_VALISS
	nAbtISS	+= (cAliasTRB)->TRB_ABTISS
	nAbtMAT	+= (cAliasTRB)->TRB_ABTMAT	
	(cAliasTRB)->TRB_OKISS := cMark	
Else
	nTotal  -= (cAliasTRB)->TRB_TOTAL
	nValISS	-= (cAliasTRB)->TRB_VALISS
	nAbtISS	-= (cAliasTRB)->TRB_ABTISS
	nAbtMAT	-= (cAliasTRB)->TRB_ABTMAT
	(cAliasTRB)->TRB_OKISS := ''
Endif
(cAliasTRB)->(MSUNLOCK())

oMarISS:oBrowse:Refresh()

For nX:=1 to Len(aObjetos)
	aObjetos[nX]:Refresh()
Next(nX)

Return()

/*


ͻ
Programa  GrIISMUN  Autor   Vitor Felipe        Data  29/06/2012  
͹
Desc.      Tratamento para a gravacao do FLAG na tabela SD1 (Itens	  
		     	da Nota Fiscal de Entrada) de acordo com o FLAG do TRB e  
			 	Gravacao das informacoes na tabela CE2. 				  
͹
Uso        MATA410                                                    
ͼ


*/
Static Function GrIISMUN(cAliasTRB,nAbtISS,nAbtMAT,cMark,lProc)

Local nAbatISS		:= aScan(aHeader,{|x| AllTrim(x[2])=="C6_ABATISS"})
Local nAbatMat		:= aScan(aHeader,{|x| AllTrim(x[2])=="C6_ABATMAT"})
Local nValor		:= aScan(aHeader,{|x| AllTrim(x[2])=="C6_VALOR"})
Local aAreaSD1		:= SD1->(GetArea())
Local nX			:= 0
Local lRet			:= .F.
Local cQueryAlt		:= SuperGetMv("MV_TABABAT",.F.,"SD1")

Default cAliasTRB	:= ""
Default nAbtISS		:= 0
Default nAbtMAT		:= 0
Default cMark		:= ""
Default lProc		:= .T.

(cAliasTRB)->(dbGoTop())

If !Empty(M->C5_NUM)
	dbSelectArea("SD1")
	dbSetOrder(1)
	dbSelectArea("SD3")
	dbSetOrder(3)		
	//ATUALIZA OS CAMPOS nAbatISS E nAbatMat NO ACOLS.
	If nAbtISS <= 0
		nAbtISS := 0
		MaFisGet("IT_ABVLISS")
	EndIf
	If nAbtMAT <= 0
		nAbtMAT := 0
		MaFisGet("IT_ABMATISS")
	EndIf
	For nX := 1 to Len(aCols)
		If Round((nAbtISS+nAbtMAT)/Len(aCols),2) <= aCols[nX,nValor]
			If nAbtISS > 0 .Or. aCols[nX,nAbatISS] <> Round(nAbtISS / Len(aCols),2) 
				aCols[nX,nAbatISS] := Round(nAbtISS / Len(aCols),2)
				MaFisGet("IT_ABVLISS")
			EndIf
			If nAbtMAT  > 0 .Or. aCols[nX,nAbatMat] <> Round(nAbtMAT / Len(aCols),2)
				aCols[nX,nAbatMat] := Round(nAbtMAT / Len(aCols),2)
				MaFisGet("IT_ABMATISS")
			EndIf
		Else
			Alert(STR0039) //"Total de Abatimentos Maior que o Total do Pedido, o valor no foi inserido."
			lProc := .F.
		EndIf
	Next(nX)
	//PROCESSAMENTO ALTERADO O FLAG NA TABELA SD1 E REALIZANDO A GRAVACAO DA TABELA CE2.
	If lProc
		While !(cAliasTRB)->(EOF())
			If !Empty((cAliasTRB)->TRB_OKISS)
				If cQueryAlt == "SD1"
					If SD1->(msSeek(xFilial("SD1")+(cAliasTRB)->TRB_DOC+(cAliasTRB)->TRB_SERIE+(cAliasTRB)->TRB_FORNEC+(cAliasTRB)->TRB_LOJA+;
							(cAliasTRB)->TRB_COD+(cAliasTRB)->TRB_ITEM))
						RecLock("SD1",.F.)
							SD1->D1_OKISS := cMark
						SD1->(MsunLock())
						lRet := .T.
					EndIf
				Else
					If SD3->(msSeek(xFilial("SD3")+(cAliasTRB)->TRB_COD+(cAliasTRB)->TRB_LOCAL+(cAliasTRB)->TRB_NUMSEQ))
						RecLock("SD3",.F.)
							SD3->D3_OKISS := cMark
						SD3->(MsunLock())
						lRet := .T.
					EndIf				
				EndIf
				If lRet 
					dbSelectArea("CE2")
					dbSetOrder(1)
					If CE2->(msSeek(xFilial("CE2")+M->C5_NUM+(cAliasTRB)->TRB_DOC+(cAliasTRB)->TRB_SERIE+(cAliasTRB)->TRB_ITEM+(cAliasTRB)->TRB_COD+;
						(cAliasTRB)->TRB_FORNEC+(cAliasTRB)->TRB_LOJA+(cAliasTRB)->TRB_NUMSEQ))
						RecLock("CE2",.F.)
							CE2->CE2_FILIAL	:= xFilial("CE2")				//01- Filial
							CE2->CE2_NUMPV	:= M->C5_NUM               		//02- Numero do Pedido de Venda
							CE2->CE2_PRODPV	:= (cAliasTRB)->TRB_COD			//03- Produto do Pedido de Venda
							CE2->CE2_ITEMPV	:= (cAliasTRB)->TRB_ITEM		//04- Item do Pedido de Venda
							CE2->CE2_PROJPV	:= (cAliasTRB)->TRB_PROJET		//05- Projeto do Pedido de Venda
							CE2->CE2_EDTPV	:= (cAliasTRB)->TRB_EDT		  	//06- EDT do Pedido de Venda
							CE2->CE2_TASKPV	:= (cAliasTRB)->TRB_TASK		//07- Tarefa do Pedido de Venda
							CE2->CE2_DOCNF	:= (cAliasTRB)->TRB_DOC			//08- Cod. Documento da NF						
							SerieNfId("CE2",1,"CE2_SERINF",,,,(cAliasTRB)->TRB_SERIE) //09- Serie da NF
							CE2->CE2_FORNNF	:= (cAliasTRB)->TRB_FORNEC		//10- Fornecedor da NF
							CE2->CE2_LOJANF	:= (cAliasTRB)->TRB_LOJA		//11- Loja da NF
							CE2->CE2_CODNF	:= (cAliasTRB)->TRB_COD			//12- Cod. do Produto da NF
							CE2->CE2_ITEMNF := (cAliasTRB)->TRB_ITEM		//13- Item da NF
							CE2->CE2_ABTSER := (cAliasTRB)->TRB_ABTISS		//14- Valor do Abatimento de Servicos
							CE2->CE2_ABTMAT := (cAliasTRB)->TRB_ABTMAT		//15- Valor do Abatimento de Materiais
							CE2->CE2_DTDIGT	:= (cAliasTRB)->TRB_DTDIGT		//16- Data de Digitacao
							CE2->CE2_MUNPRE	:= M->C5_MUNPRES				//17- Municipio de Prestacao.
							CE2->CE2_ESTPRE	:= M->C5_ESTPRES				//18- Estado de Prestacao.
							CE2->CE2_NUMSEQ := (cAliasTRB)->TRB_NUMSEQ		//19- Numero Sequencial.
						CE2->(MsunLock())
				Else
						RecLock("CE2",.T.)
							CE2->CE2_FILIAL	:= xFilial("CE2")				//01- Filial
							CE2->CE2_NUMPV	:= M->C5_NUM               		//02- Numero do Pedido de Venda
							CE2->CE2_PRODPV	:= (cAliasTRB)->TRB_COD			//03- Produto do Pedido de Venda
							CE2->CE2_ITEMPV	:= (cAliasTRB)->TRB_ITEM		//04- Item do Pedido de Venda
							CE2->CE2_PROJPV	:= (cAliasTRB)->TRB_PROJET		//05- Projeto do Pedido de Venda
							CE2->CE2_EDTPV	:= (cAliasTRB)->TRB_EDT		  	//06- EDT do Pedido de Venda
							CE2->CE2_TASKPV	:= (cAliasTRB)->TRB_TASK		//07- Tarefa do Pedido de Venda
							CE2->CE2_DOCNF	:= (cAliasTRB)->TRB_DOC			//08- Cod. Documento da NF
							SerieNfId("CE2",1,"CE2_SERINF",,,,(cAliasTRB)->TRB_SERIE)		//09- Serie da NF
							CE2->CE2_FORNNF	:= (cAliasTRB)->TRB_FORNEC		//10- Fornecedor da NF
							CE2->CE2_LOJANF	:= (cAliasTRB)->TRB_LOJA		//11- Loja da NF
							CE2->CE2_CODNF	:= (cAliasTRB)->TRB_COD			//12- Cod. do Produto da NF
							CE2->CE2_ITEMNF := (cAliasTRB)->TRB_ITEM		//13- Item da NF
							CE2->CE2_ABTSER := (cAliasTRB)->TRB_ABTISS		//14- Valor do Abatimento de Servicos
							CE2->CE2_ABTMAT := (cAliasTRB)->TRB_ABTMAT		//15- Valor do Abatimento de Materiais
							CE2->CE2_DTDIGT	:= (cAliasTRB)->TRB_DTDIGT		//16- Data de Digitacao
							CE2->CE2_MUNPRE	:= M->C5_MUNPRES				//17- Municipio de Prestacao.
							CE2->CE2_ESTPRE	:= M->C5_ESTPRES				//18- Estado de Prestacao.
							CE2->CE2_NUMSEQ := (cAliasTRB)->TRB_NUMSEQ		//19- Numero Sequencial.
						CE2->(MsunLock())
					EndIf
					CE2->(dbCloseArea())
				EndIf
			Else
				If cQueryAlt == "SD1"
					If SD1->(msSeek(xFilial("SD1")+(cAliasTRB)->TRB_DOC+(cAliasTRB)->TRB_SERIE+(cAliasTRB)->TRB_FORNEC+(cAliasTRB)->TRB_LOJA+;
						(cAliasTRB)->TRB_COD+(cAliasTRB)->TRB_ITEM))
						RecLock("SD1",.F.)
							SD1->D1_OKISS := ''
						SD1->(MsunLock())
					EndIf
				Else
					If SD3->(msSeek(xFilial("SD3")+(cAliasTRB)->TRB_COD+(cAliasTRB)->TRB_LOCAL+(cAliasTRB)->TRB_NUMSEQ))
						RecLock("SD3",.F.)
							SD3->D3_OKISS := ''
						SD3->(MsunLock())
					EndIf
				EndIf						
				dbSelectArea("CE2")
				dbSetOrder(1)
				If CE2->(msSeek(xFilial("CE2")+M->C5_NUM+(cAliasTRB)->TRB_DOC+(cAliasTRB)->TRB_SERIE+(cAliasTRB)->TRB_ITEM+(cAliasTRB)->TRB_COD+;
					(cAliasTRB)->TRB_FORNEC+(cAliasTRB)->TRB_LOJA+(cAliasTRB)->TRB_NUMSEQ))
					RecLock("CE2",.F.)
						CE2->(dbDelete())
					CE2->(MsUnLock())
				EndIf
				CE2->(dbCloseArea())
			EndIf
			(cAliasTRB)->(dbSkip())
			lRet := .F.
		EndDo
	EndIf			
	If lProc
		RestArea(aAreaSD1)	
		ISSENDDLG()
	EndIf
	dbSelectArea("SD1")
	SD1->(dbCloseArea())
	dbSelectArea("SD3")
	SD3->(dbCloseArea())
EndIf

Return() 

/*


ͻ
Programa  CrIISSX1  Autor   Vitor Felipe        Data  29/06/2012  
͹
Desc.      Cria Perguntas (SX1) para a rotina de Abatimentos ISS.     
͹
Uso        MATA410                                                    
ͼ


*/
Function CrIISSX1(cPerg)

Return()

/*


ͻ
Programa  ISSENDDLG Autor   Vitor Felipe        Data  29/06/2012  
͹
Desc.      Pergunte do MTA410 Evitando Erros.					      
͹
Uso        MATA410                                                    
ͼ


*/
Static Function ISSENDDLG()

Local nTamSX1   := Len(SX1->X1_GRUPO)
Local cPerg		:= PadR("MTA410",nTamSX1)

Pergunte(cPerg,.F.)
oDlgISS:End()

Return()

/*


ͻ
Programa  ISSBUMARK Autor   Vitor Felipe        Data  29/06/2012  
͹
Desc.      Marca ALL ou Desmarca ALL o MARK.					      
͹
Uso        MATA410                                                    
ͼ


*/
Static Function ISSBUMARK(cAliasTRB,lMark,cMark,nTotal,nValISS,nAbtISS,nAbtMAT,aObjetos)

Local nX			:= 0
Default cAliasTRB	:= "TRB"
Default lMark		:= .F.
Default cMark		:= ""
Default nTotal		:= 0
Default nValISS		:= 0
Default nAbtISS		:= 0
Default nAbtMAT		:= 0
Default aObjetos	:= {}

While !(cAliasTRB)->(EOF())
	RecLock(cAliasTRB,.F.)
	If lMark .And. !Marked("TRB_OKISS")
		nTotal	+= (cAliasTRB)->TRB_TOTAL
		nValISS	+= (cAliasTRB)->TRB_VALISS
		nAbtISS	+= (cAliasTRB)->TRB_ABTISS
		nAbtMAT	+= (cAliasTRB)->TRB_ABTMAT	
		(cAliasTRB)->TRB_OKISS := cMark	
	ElseIf !lMark .And. Marked("TRB_OKISS")
		nTotal  -= (cAliasTRB)->TRB_TOTAL
		nValISS	-= (cAliasTRB)->TRB_VALISS
		nAbtISS	-= (cAliasTRB)->TRB_ABTISS
		nAbtMAT	-= (cAliasTRB)->TRB_ABTMAT
		(cAliasTRB)->TRB_OKISS := ''
	EndIf
	(cAliasTRB)->(MSUNLOCK())
	(cAliasTRB)->(dbSkip())	
EndDo

(cAliasTRB)->(dbGoTop())	

oMarISS:oBrowse:Refresh()

For nX:=1 to Len(aObjetos)
	aObjetos[nX]:Refresh()
Next(nX)

Return()    

/*


ͻ
Programa  a410IncRem		 Rodrigo Aguilar     Data  30/06/2012  
͹
Desc.       Botao criado no pedido de venda para que o cliente possa  
		       amarrar as Notas Fiscais de Remessa com o pedido que      
		       esta sendo emitido, para geracao correta da GISSOLINE     
͹
Uso        MATA410                                                    
ͼ


*/
Function a410IncRem(lEnd)

Local _stru		:= {}
Local aCpoBro 	:= {} 
Local aNfDupl   := {}        
Local aButtons	:= {} 

Local cAliasSD2	:= "SD2"
Local cArq		:= ""
Local cMark		:= ""   
Local cCampos	:= ""
Local cWhere	:= ""   
Local cIndex 	:= ""
Local cFiltro	:= ""    
Local cJoinC5   := ""   
Local cSerNfS   := ""

Local cPerg     := "A410IncRem" 

Local cAliasTRB	:= GetNextAlias() 

Local nProjeto	:= aScan(aHeader,{|x| AllTrim(x[2])=="C6_PROJPMS"})
Local nEDT		:= aScan(aHeader,{|x| AllTrim(x[2])=="C6_EDTPMS"})
Local nTarefa	:= aScan(aHeader,{|x| AllTrim(x[2])=="C6_TASKPMS"})
Local nIndex	:= 0  
Local lMvIntPms := Iif(GetNewPar("MV_INTPMS","N")=="S",.T.,.F.)
 
Private lInverte := .F.   
Private oMarRem
Private oDlgRem

Default lEnd 	:= .F.   

//Ŀ
//Verifica o cdigo projeto da tarefa e obra.
//
If lMvIntPms .And. Empty(aCols[n,nProjeto]+aCols[n,nEDT]+aCols[n,nTarefa])
	Alert("Informe o cdigo do Projeto e da Tarefa!!!")
	Return Nil
ElseIf !lMvIntPms .And. Empty(M->C5_OBRA)
	Alert("Informe o Cdigo da Obra!!!")
	Return Nil
EndIf    

//Ŀ
//Cliente seleciona se deseja amarrar documentos de saida ou seja deseja
//excluir uma amarracao feita anteriormente                             
//
Pergunte(cPerg,.T.)  

cSerNfS   := Padr(MV_PAR02,TamSx3("F2_SERIE")[1])

//Ŀ
//Criando arquivo temporario para manipulacao das informacoes
//
AADD(_stru,{"TRB_OKISS"		,"C"	,2							,0})
AADD(_stru,{"TRB_FILIAL"	,"C"	,TamSX3('D2_FILIAL')[1]		,0})
AADD(_stru,{"TRB_DOC"		,"C"	,TamSX3('D2_DOC')[1]		,0})
AADD(_stru,{"TRB_SERIE"		,"C"	,TamSX3('D2_SERIE')[1]		,0})
AADD(_stru,{"TRB_DTEMIS"	,"D"	,TamSX3('D2_EMISSAO')[1]	,0})
AADD(_stru,{"TRB_CLIEN"		,"C"	,TamSX3('D2_CLIENTE')[1]	,0})
AADD(_stru,{"TRB_LOJA"		,"C"	,TamSX3('D2_LOJA')[1]		,0})

aAdd(aCpoBro,{"TRB_OKISS"	,,"Mark"			,"@!"})
aAdd(aCpoBro,{"TRB_FILIAL"	,,"Filial"			,"@!"})
aAdd(aCpoBro,{"TRB_DOC"		,,"Nota Fiscal"		,"@!"})
aAdd(aCpoBro,{"TRB_SERIE"	,,"Serie"			,"!!!"})
aAdd(aCpoBro,{"TRB_DTEMIS"	,,"Dt. Emissao"	,"@!"})
aAdd(aCpoBro,{"TRB_CLIEN"	,,"Cliente"		,"@!"})
aAdd(aCpoBro,{"TRB_LOJA"	,,"Loja"			,"@!"})

cArq:=Criatrab(_stru,.T.)
DbUseArea(.t.,,carq,cAliasTRB)

//Ŀ
//Setando SD2 para utilizacao tanto em base DBF quanto em base TOP
//
DbSelectArea(cAliasSD2)
(cAliasSD2)->(DbSetOrder(1))

#IFDEF TOP
	
	//Ŀ
	//Montando Query Principal para obter as notas fiscais de saida que 
	//se referem ao cliente/projeto informado no pedido de venda        
	//	
	If (TcSrvType ()<>"AS/400")	
        		
		//Ŀ
		//Campos a ser utilizados na query
		//
		cCampos += "%"
		cCampos += ",D2_OKISS"							    	
		cCampos += "%"
				
		//Ŀ
		//Condicoes que serao aplicadas na execucao da query
		//
		cWhere += "%"
		
		If lMvIntPms
			cWhere += "SD2.D2_PROJPMS='"+%Exp:aCols[n,nProjeto]%+"' AND "
			cWhere += "SD2.D2_EDTPMS='"+%Exp:aCols[n,nEDT]%+"' AND "
			cWhere += "SD2.D2_TASKPMS='"+%Exp:aCols[n,nTarefa]%+"' AND "		
		Else
			cWhere  += "SC5.C5_OBRA='"+%Exp:M->C5_OBRA%+"' AND "  
			cWhere  += "SC5.C5_MUNPRES='"+%Exp:M->C5_MUNPRES%+"' AND "  
		EndIf
						
		//Ŀ
		//Caso o cliente selecione a opcao incluir eu apenas listo no MsSelect as notas
		//fiscais que nao foram utilizadas anteriormente, caso contrario busco         
		//todas as notas fiscais que ja foram utilizadas                               
		//
		If Mv_Par01 == 1
			cWhere += "SD2.D2_OKISS=''"
		Else
			cWhere += "SD2.D2_OKISS<>''"
		EndIf

		If SerieNfId("SD2",3,"D2_SERIE") == "D2_SERIE"
			cWhere  += "AND SD2.D2_SERIE='"+%Exp:cSerNfS%+"'"
		Else
			cWhere  += "AND SD2.D2_SDOC='"+%Exp:cSerNfS%+"'" 
		EndIf
		
		cWhere += "%"
		
		cAliasSD2 := GetNextAlias()     
						
		If	!lMvIntPms
		  	cJoinC5	:=	"LEFT JOIN "+RetSqlName("SC5")+" SC5 ON(SC5.C5_FILIAL='"+xFilial("SC5")+"'  AND  SC5.C5_NUM=SD2.D2_PEDIDO AND SC5.D_E_L_E_T_=' ') "
		EndIf		
		cJoinC5 := "%" + cJoinC5 + "%"
		
		BeginSql Alias cAliasSD2
                                                                                             
			Column D2_DTDIGIT As Date    
			
			SELECT 
				D2_FILIAL,D2_DOC,D2_SERIE,D2_EMISSAO,D2_CLIENTE,D2_LOJA,D2_COD,D2_TOTAL,D2_VALFRE,D2_SEGURO,
				D2_DESPESA,D2_VALIPI,D2_VALDEV,D2_VALISS,D2_ABATISS,D2_ABATMAT,D2_ITEM,
				A1_NOME,A1_EST,A1_MUN,A1_CGC,
				B1_DESC
				%Exp:cCampos%
			FROM
				%Table:SD2% SD2
				LEFT JOIN %Table:SB1% SB1 ON(SB1.B1_FILIAL=%xFilial:SB1%  AND SB1.B1_COD=SD2.D2_COD AND SB1.%NotDel%)
				LEFT JOIN %Table:SA1% SA1 ON(SA1.A1_FILIAL=%xFilial:SA1%  AND SA1.A1_COD=SD2.D2_CLIENTE AND SA1.A1_LOJA=SD2.D2_LOJA AND SA1.%NotDel%)				
				%Exp:cJoinC5%
			WHERE  
				SD2.D2_FILIAL=%xFilial:SD2% AND
				SD2.D2_TIPO='N' AND   
				SD2.%NotDel% AND
				%Exp:cWhere%	   
		  	ORDER BY
				D2_DOC,D2_SERIE					
		EndSql
  	Else
#ENDIF  
		cIndex	:= CriaTrab(NIL,.F.)
		cFiltro	:= 'D2_FILIAL=="'+xFilial ("SD2")+'" .And. '
		cFiltro += 'D2_TIPO=="N"'
		
		IndRegua (cAliasSD2,cIndex,SD2->(IndexKey()),,cFiltro)
		nIndex := RetIndex(cAliasSD2)
	
#IFNDEF TOP
		DbSetIndex(cIndex+OrdBagExt())
#ENDIF
			
#IFDEF TOP
	Endif
#ENDIF

//Ŀ
//Iniciando processamento do resultado da query
//
DbSelectArea(cAliasTRB)    
cMark := GetMark()
ProcRegua ((cAliasSD2)->(RecCount()))

//Ŀ
//Verifica se foram encontrados resultados na consulta
//
If (cAliasSD2)->(!Eof())
	While (cAliasSD2)->(!Eof())
						    
		//Ŀ
		//Tratamento para que somente seja exibida uma numeracao de NF independente
		//da quantidade de itens que ela possua                                    
		//
		If aScan(aNfDupl,{ |x| x[1] == (cAliasSD2)->D2_FILIAL .And. ;
		                        x[2] == (cAliasSD2)->D2_DOC .And. ;
		                        x[3] == (cAliasSD2)->D2_SERIE .And. ;
		                        x[4] == (cAliasSD2)->D2_CLIENTE .And. ;
		                        x[5] == (cAliasSD2)->D2_LOJA}) <= 0
		    		    
			//Ŀ
			//Gravando nota fiscal na tabela temporaria
			//
			RecLock(cAliasTRB,.T.)
		  		TRB_OKISS	:= cMark
				TRB_FILIAL	:= (cAliasSD2)->D2_FILIAL
				TRB_DOC	    := (cAliasSD2)->D2_DOC
				TRB_SERIE	:= (cAliasSD2)->D2_SERIE
				TRB_DTEMIS	:= SToD((cAliasSD2)->D2_EMISSAO)
				TRB_CLIEN	:= (cAliasSD2)->D2_CLIENTE
				TRB_LOJA	:= (cAliasSD2)->D2_LOJA
			MsunLock()
						
			//Ŀ
			//Incluindo notas fiscais utilizadas no controle de duplicidade
			//
			Aadd(aNfDupl,{(cAliasSD2)->D2_FILIAL ,;
		      				(cAliasSD2)->D2_DOC,; 
	   	      				(cAliasSD2)->D2_SERIE,;
    		  				(cAliasSD2)->D2_CLIENTE,; 
    		  				(cAliasSD2)->D2_LOJA})		
		EndIf
		
		(cAliasSD2)->(DbSkip())
		IncProc("Processando Notas de Sada...")
	Enddo
Else   
	Alert("Nao foram encontrados Registros para Incluir/Excluir no Pedido de Venda")                                                                          
	Return Nil
EndIf

//Ŀ
//Incluo botao de Marcar / Desmarcar os itens do MsSelect
//
AADD(aButtons,{"SelectAll",{||ISSBMARK(cAliasTRB,.T.,cMark,Nil,Nil,Nil,Nil,Nil)},'Marcar'})
AADD(aButtons,{"UnselectAll",{||ISSBMARK(cAliasTRB,.F.,cMark,Nil,Nil,Nil,Nil,Nil)},'Desmarcar'})


//Ŀ
//Montando tela para que o usuario selecione as notas fiscais de 
//saida que deseja amarrar ao pedido de venda                    
//
Define MsDialog oDlgRem Title "Notas Fiscais de Sada" From 9,0 To 410,800 Pixel

	DbSelectArea(cAliasTRB)
	DbGotop()
	
	oMarRem := MsSelect():New(cAliasTRB,"TRB_OKISS","",aCpoBro,@lInverte,@cMark,{15,1,200,400},,,,,)

Activate MsDialog oDlgRem Centered On Init EnchoiceBar(oDlgRem,{|| GrRemMUN(cAliasTRB,Nil,Nil,cMark,.T.)},{|| IssEnd()},.F.,aButtons)

//Ŀ
//Apagando arquivo temporario
//
(cAliasTRB)->(DbCloseArea())
Iif(File(cArq + GetDBExtension()),FErase(cArq  + GetDBExtension()) ,Nil)

//Ŀ
//Finalizando Processamento
//
#IFDEF TOP
	If (TcSrvType ()<>"AS/400")
		DbSelectArea(cAliasSD2)
		(cAliasSD2)->(DbCloseArea())
	Else
#ENDIF
	RetIndex("SFT")
	FErase(cIndex+OrdBagExt())
#IFDEF TOP
	EndIf
#ENDIF

lEnd := .T.

Return Nil

/*


ͻ
Programa  GrRemMUN  Autor   Rodrigo Aguilar     Data  30/06/2012  
͹
Desc.      Tratamento para a gravacao do FLAG na tabela SD2 (Itens	  
		     	da Nota Fiscal de Saida) de acordo com o FLAG do TRB      
͹
Uso        MATA410                                                    
ͼ


*/
Static Function GrRemMUN(cAliasTRB,nAbtISS,nAbtMAT,cMark,lProc)

Local aAreaSD2		:= SD2->(GetArea())

Default cAliasTRB	:= ""
Default nAbtISS		:= 0
Default nAbtMAT		:= 0
Default cMark		:= ""
Default lProc		:= .T.

//Ŀ
//Posicionando no inicio do arquivo temporario
//
(cAliasTRB)->(dbGoTop())

//Ŀ
//Verifica se o numero do pedido de venda Foi informado
//
If !Empty(M->C5_NUM)
    	
	//Ŀ
	//Posiciono na tabela SD2
	//
	DbSelectArea("SD2") 
	DbSetOrder(3)	    
	SD2->(DbGotop())
	
	//Ŀ
	//Gravando as notas fiscais flegadas na tabela SD2, eh executado um While para
	//que todos os itens sa nota fiscal fiquem como utilizados                    
	//
	If lProc
		While !(cAliasTRB)->(EOF())
			If !Empty((cAliasTRB)->TRB_OKISS)
				If SD2->(msSeek(xFilial("SD2")+(cAliasTRB)->TRB_DOC+(cAliasTRB)->TRB_SERIE+(cAliasTRB)->TRB_CLIEN+(cAliasTRB)->TRB_LOJA))
					While SD2->(!Eof()) .And. SD2->(D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA) == ;							
											    xFilial("SD2")+(cAliasTRB)->TRB_DOC+(cAliasTRB)->TRB_SERIE+(cAliasTRB)->TRB_CLIEN+(cAliasTRB)->TRB_LOJA				
						RecLock("SD2",.F.)
							If Mv_Par01 == 1
								SD2->D2_OKISS := cMark
							Else
								SD2->D2_OKISS := ""
							EndIf
						MsunLock()   
						SD2->(DbSkip())
					EndDo
				EndIf
			EndIf
			(cAliasTRB)->(dbSkip())
		EndDo
	EndIf			
		
	//Ŀ
	//Restaurando area do sistema
	//
	If lProc
		RestArea(aAreaSD2)	
		IssEnd()
	EndIf
	
EndIf

Return Nil

/*


ͻ
Programa  IssEnd    Autor   Rodrigo Aguilar     Data  30/06/2012  
͹
Desc.      Pergunte do MTA410 Evitando Erros.					      
͹
Uso        MATA410                                                    
ͼ


*/
Static Function IssEnd()

Local nTamSX1   := Len(SX1->X1_GRUPO)
Local cPerg		:= PadR("MTA410",nTamSX1)
                    
Pergunte(cPerg,.F.)
oDlgRem:End()

Return Nil

/*


ͻ
Programa  ISSBMARK  Autor   Rodrigo Aguilar     Data  30/06/2012  
͹
Desc.      Marca ALL ou Desmarca ALL o MARK.					      
͹
Uso        MATA410                                                    
ͼ


*/
Static Function ISSBMARK(cAliasTRB,lMark,cMark,nTotal,nValISS,nAbtISS,nAbtMAT,aObjetos)

                             
Default cMark		:= ""   
Default cAliasTRB	:= "TRB"  
Default lMark		:= .F.    
Default nTotal		:= 0
Default nValISS		:= 0
Default nAbtISS		:= 0
Default nAbtMAT		:= 0    
Default aObjetos	:= {}

//Ŀ
//Atualizo todo o TRB com as informacoes incluidas pelo usuario
//
While !(cAliasTRB)->(Eof())
	
	RecLock(cAliasTRB,.F.)
	
	If lMark .And. !Marked("TRB_OKISS")
		(cAliasTRB)->TRB_OKISS := cMark	
	ElseIf !lMark .And. Marked("TRB_OKISS")
		(cAliasTRB)->TRB_OKISS := ''
	EndIf
	
	MsUnlock()
	(cAliasTRB)->(DbSkip())	
EndDo

(cAliasTRB)->(dbGoTop())	


//Ŀ
//Atualizo Objeto
//
oMarRem:oBrowse:Refresh()

Return Nil

//-----------------------------------------------------------------------
/*/{Protheus.doc} XFUNCodSef
Funcao que retorna codigos da Sefaz, dependendo do tipo de Status passado
como parametro

@param  aTipo  - Array com os status que deseja retornar os codigos 
		lQuery - Indica se a string de retorno devera ser tratada para query

@author Luccas Curcio
@since 26.11.2012
@version 1.00      

@Return	cRet - Codigos retornados para determinados status

/*/
//-----------------------------------------------------------------------
Function XFUNCodSef(aTipo,lQuery)
Local	cRet	:=	""
Local	nX		:=	0
Default aTipo	:=	{}
Default lQuery	:=	.F.	

For nX := 1 To Len(aTipo)
	
	//Codigos para status de nota denegada
	If aTipo[nX] == "D"
		cRet	+=	"'110', '204', '205', '301', '302', '303', '304', '305', '306', "
	
	//Codigos para status de nota inutilizada
	Elseif aTipo[nX] == "I"
		cRet	+=	"'102', "
		
	//Codigos para status de nota autorizada
	Elseif aTipo[nX] == "A"
		cRet	+=	"'100', "
	
	//Codigos para status de nota rejeitada	
	Elseif aTipo[nX] == "R"
		cRet	+=	"'234', "
		
	//Cancelamento de NF-e homologado fora de prazo.
	Elseif aTipo[nX] == "C"
		cRet	+=	"'155', "
	
	Endif
	
Next nX

//Exclui a virgula desnecessaria da string
cRet	:=	Substr(cRet,1,Len(cRet)-2)

If !lQuery
    //Retira as aspas nao necessarias para comparacoes feitas em ADVPL
	cRet	:=	StrTran( cRet , "'" , Space(1) )
Else
    //Mantem as aspas e adiciona parenteses no comeco/fim para comparacoes SQL
	cRet	:=	"( " + cRet + " )"
Endif
		
Return cRet
/*


ͻ
Programa  MATA995   Autor  Wemerson Randolfo    Data   02/07/2012 
͹
Desc.      Funcao para verificacao da existencia do controle de       
           Historico das Operacoes Fiscais                            
͹
Uso        Diversos                                                   
ͼ

*/

Function HistFiscal() 

Local lRet       := .F.
Local lHistFis   := GetNewPar("MV_HISTFIS", .F.)

If lHistFis .And. cPaisLoc=="BRA" 
	lRet := .T.
EndIf

Return lRet

/*

Ŀ
Funo     MSGrvCG2   Autor  Wemerson Randolfo      Data  12/06/2012           
Ĵ
Descriao  Grava historico de alteracoes/exclusoes das tabelas SF4/SF7/CC7/SFB     
Ĵ
Sintaxe    MsGrvHist(ExpC1,ExpC2,ExpC3,ExpC4,ExpC5,ExpC6,ExpU7,Expd8)	            
Ĵ
Parametros ExpC1  = Filial da tabela CG2                                           
           ExpC2  = Filial da tabela                                               
           ExpA3  = Array contendos os campos a serem gravados                     
           ExpC4  = De qual tabela est sendo gravada                              
           ExpC5  = Tipo do Registro(1-Alteracao;2-Exclusao)                       
           ExpC6  = Nome do campo que sofreu alteracao                             
           ExpU7  = Conteudo do campo antes da alteracao/exclusao                  
           ExpD8  = Data da alteracao (DD/MM/YYYY)                                 
           ExpC9  = Hora da alteracao (HH/MM/)                                     
Ĵ
Retorno    Nil                                                                     
Ĵ
 Uso                                                                               
ٱ

*/
Function GrvHistFis(cTabela, cTabHist, aCampos)

Local aArea 	  := GetArea()
Local nY,nX, nPosic, cCampo   	 
Local bCmpHist   := { |x|&(cTabHist)->(Field(x)) }     
Local cCampoId:=  Iif(Substr(cTabela,1,1)=="S",SubStr(cTabela,-2 ),SubStr(cTabela,1,3))  + "_IDHIST"
Local nPosic := Ascan(aCampos,{ |x| x[1] == cCampoId } )	
Local lAchou:=.T.              
Local cTypeCpo := ""
local xInfo := ""

dbSelectArea(cTabela)

dbSelectArea(cTabHist)
DbSetOrder(1)

If nPosic >0       .and.  !Empty(aCampos[nPosic][2])
	If  !Dbseek(xfilial(cTabHist)+ aCampos[nPosic][2]	 )
		lAchou:=.F.
	EndIf

    If  !lAchou
    	RecLock(cTabHist, .T.)
		For nY := 1 to FCount()				
	                                                          	
			cCampo := Iif(Substr(cTabela,1,1)=="S",SubStr(cTabela,-2 ),SubStr(cTabela,1,3)) + Substr(((cTabHist)->(eVal( bCmpHist, nY))),3,8 )						
			nPosic := Ascan(aCampos,{ |x| x[1] == cCampo  } )	
						
			If nPosic > 0		
 			
 				If "FILIAL" $ cCampo
 			    	&((cTabHist)->(eVal( bCmpHist, nY))) :=xfilial(cTabHist)
 			    Else
 
 			    	xInfo := aCampos[nPosic][2]
 			    	cTypeCpo := valtype(&((cTabHist)->(eVal( bCmpHist, nY))))
 			    	cTypeInf := valtype(xInfo)  
 
 			    	if !cTypeCpo == cTypeInf
 			    		
 			    		do case
 			    			case cTypeCpo == "C"
 			    				xInfo := cValtoChar(xInfo)
 			    			
 			    			case cTypeCpo == "N"
 			   					xInfo := val(xInfo)
 
 			    			case cTypeCpo == "D"
 			    				xInfo := ctod(xInfo) 
 			    			
 			    		endcase
 			    		
 			    		
 					endif
 					
 					&((cTabHist)->(eVal( bCmpHist, nY))) := xInfo
 					
 				EndIf	
			EndIf		
		
		Next nY                                                       	
		&(cTabHist)->(MsUnlock())
	EndIf	
EndIf
	
RestArea(aArea)
Return Nil



Function RetCmps(cTabela,bCampos)

Local aArea := GetArea()
Local aRet  := {}
Local nX    := 0

For nX :=  1 To &(cTabela)->(FCount())
	aAdd( aRet, { ((cTabela)->(eVal( bCampos, nX))), &(cTabela)->(&(eVal( bCampos, nX)))} )
Next nX

RestArea(aArea)

Return aRet
    

        
/*

Ŀ
Funo     MSGrvCG2   Autor  Wemerson Randolfo      Data  12/06/2012           
Ĵ
Descriao  Grava historico de alteracoes/exclusoes das tabelas SF4/SF7/CC7/SFB     
Ĵ
Sintaxe    MsGrvHist(ExpC1,ExpC2,ExpC3,ExpC4,ExpC5,ExpC6,ExpU7,Expd8)	            
Ĵ
Parametros ExpC1  = Filial da tabela CG2                                           
           ExpC2  = Filial da tabela                                               
           ExpA3  = Array contendos os campos a serem gravados                     
           ExpC4  = De qual tabela est sendo gravada                              
           ExpC5  = Tipo do Registro(1-Alteracao;2-Exclusao)                       
           ExpC6  = Nome do campo que sofreu alteracao                             
           ExpU7  = Conteudo do campo antes da alteracao/exclusao                  
           ExpD8  = Data da alteracao (DD/MM/YYYY)                                 
           ExpC9  = Hora da alteracao (HH/MM/)                                     
Ĵ
Retorno    Nil                                                                     
Ĵ
 Uso                                                                               
ٱ

*/
Function GrvHistFi2(cTabHist, aCampos, aHeader, aCols)

Local aArea   := GetArea()
Local nX, nY, nZ, cVar

DbSelectArea(cTabHist)
DbSetOrder(1)

For nY := 1 To Len(aCols)

	If .Not. aCols[nY][Len(aCols[nY])]			
	
		RecLock(cTabHist, .T.)					   

		//Ŀ
		//Grava os campos passados manualmente pelo aArray aCampos.
		//

      For nZ := 1 To Len(aCampos)
			cCampo  := Trim(aCampos[nZ][1])				
			&cCampo := aCampos[nZ][2]  
      Next

		//Ŀ
		//Grava os campos do aHeader                               
		//
				
		For nX := 1 to Len(aHeader)		
			cCampo  := Trim(aHeader[nX][2])				
			&cCampo := aCols[nY][nX]	
		Next nX		
	 
		MsUnlock()
			
	EndIf  
Next

	
	
RestArea(aArea)
Return Nil
/*

Ŀ
Funo     MSGrvCG2   Autor  Wemerson Randolfo      Data  14/08/2012           
Ĵ
Descriao  Monta o Id do Historico (Data + Hora )                                  
Ĵ
Sintaxe    IdHistFis()                                                             
Ĵ
Parametros                                                                         
Ĵ
Retorno    Id Historico                                                            
Ĵ
 Uso       Cadastros Diversos                                                      
ٱ

*/

Function IdHistfis()

Local cDt      := StrTran(DtoC(dDataBase), "/","")
Local cHr 	   := StrTran(Time(), ":","" )
Local lHistFis := GetNewPar("MV_HISTFIS", .F.)
Local cRet 		:= Iif(lHistFis, cDt+cHr, "")

Return cRet
/*


ͻ
Programa  MATA995   Autor  Wemerson Randolfo    Data   02/07/2012 
͹
Desc.      Funcao para visualizacao do Historico dos Cadastro         
                                                                      
͹
Uso        MATA995 MATA540 MATA080                                    
ͼ

*/
Function HistOperFis(cTab, cCodigo, cDesc, cCampoChv, lFil,aFiltro	) 

Local aArea	      := GetArea()
Local cCursor
Local cQuery
Local oBold
Local aViewTab    := {}
Local aViewBrowse := {}
Local cCmpFilial  := (SubStr(cTab,-2)+"_FILIAL")
Local nX          := 0
Local aCampos     := {}
Local aTitulos    := {}

#IFDEF TOP
	Local nLoop := 0
#ENDIF
DEFAULT lFil      := .T.
DEFAULT aFiltro	  := {}
//Ŀ
// Query na tabela de Historico                                           
//

dbSelectArea("SX3")
dbSetOrder(1)
MsSeek(cTab)
While ( !Eof() .And. SX3->X3_ARQUIVO == cTab )

	If  SX3->X3_CONTEXT<>"V" .and. Alltrim(SX3->X3_TIPO)<> "M"   //.And. cNivel >= SX3->X3_NIVEL ) .Or. AllTrim(SX3->X3_CAMPO) == "CE_NUMPRO"
		AADD(aTitulos, TRIM(X3Titulo()))
		AADD(aCampos,{ SX3->X3_CAMPO})								
	EndIf
	dbSelectArea("SX3")
	dbSkip()
EndDo


//Ŀ
// Query na tabela de Historico                                           
//
dbSelectArea(cTab)
dbSetOrder(1)

#IFDEF TOP
	If TcSrvType() != "AS/400"
		cCursor:= GetNextAlias()
		lQuery := .T.
		cQuery := ""
		cQuery += "SELECT * FROM "+RetSqlName(cTab)+" WHERE "
		If lFil		
			cQuery += cCmpFilial+"='"+xFilial(cTab)+"' AND "
		EndIf	
		If len(aFiltro) > 0
			For nX:= 1 to Len(aFiltro)
				cQuery += Alltrim(aFiltro[nX][2])+"='"+aFiltro[nX][1]+"' AND "										
			Next nX
		Else
			cQuery += Alltrim(cCampoChv)+"='"+cCodigo+"' AND "					
		EndIF	
				
		cQuery += "D_E_L_E_T_ <> '*' "

		cQuery := ChangeQuery(cQuery)
		(cTab)->(dbCommit())                                      
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor,.T.,.T.)
		aStruQuery	:= &(cTab)->(dbStruct())
		For nLoop := 1 To Len( aStruQuery )
			If aStruQuery[nLoop,2] <> "C"
				TCSetField(cCursor,AllTrim(aStruQuery[nLoop,1]),aStruQuery[nLoop,2],aStruQuery[nLoop,3],aStruQuery[nLoop,4])
			EndIf 										
		Next nLoop
		
		While ( !Eof() )			
			
			Aadd(aViewTab,Array(Len(aCampos)))			
			
			For nX := 1 To Len(aCampos)					
				aViewTab[Len(aViewTab)][nX] := &(aCampos[nX][1])				
			Next nX			
			
			dbSkip()					
		EndDo
	Else
#ENDIF
	//Ŀ
	// Seleciona os registros do CG2 - DBF / INDREGUA                         
	// Abre um novo Alias para evitar problemas com filtros ja existentes.    
	//
	Aviso(STR0009, STR0010,{'Opo no disponvel para DBF'},2) //"Atencao"###"Nao existe Historico para este registro."###"Sair"	
	
	dbSelectArea("TMP")
	dbClearFilter()
	dbCloseArea()
	Ferase(cIndex+OrdBagExt())
	#IFDEF TOP
	EndIf
	#ENDIF   
	
	aViewBrowse := aViewTab
	                                    
If !Empty(aViewBrowse)
	DEFINE FONT oBold NAME "Arial" SIZE 0, -12 BOLD
	DEFINE MSDIALOG oDlg FROM 0,0  TO 700,900 TITLE STR0007 Of oMainWnd PIXEL //"Historico das Operaes
	@ 13, 4 To 14,450 Label "" of oDlg PIXEL
	oListBox := TWBrowse():New( 20,2,450,310,,aTitulos,,oDlg,,,,,,,,,,,,.F.,,.T.,,.F.,,,) 
	oListBox:SetArray(aViewBrowse)
	oListBox:bLine := { || aViewBrowse[oListBox:nAT]}
	@ 4  ,10   SAY Alltrim(cCodigo)+ " - "+cDesc Of oDlg PIXEL SIZE 245 ,9 FONT oBold
	@ 335 ,400  BUTTON STR0008 SIZE 45 ,10  FONT oDlg:oFont ACTION (oDlg:End())  OF oDlg PIXEL  //"Sair"
	ACTIVATE MSDIALOG oDlg CENTERED
Else
	Aviso(STR0009, STR0010,{STR0008},2) //"Atencao"###"Nao existe Historico para este registro."###"Sair"
EndIf

	
RestArea(aArea)

Return .T.

//-----------------------------------------------------------------------
/*/{Protheus.doc} XFUNFiltNR
Funcao que retorna filtro de codigos de natureza da receita conforme CST
de Pis e Cofins selecionados

@param  Nil

@author Luccas Curcio
@since 01/03/2013
@version 1.00      

@Return	cRet - Filtro a ser executado pela consulta padrao
/*/
//-----------------------------------------------------------------------
Function XFUNFiltNR()
Local 	cRet	:=	""
Local 	cCstPis	:=	""
Local 	cCstCof	:=	""
Local 	cTes 	:=	""
Local	cCmpM	:=	ReadVar()
Local	cCmp	:=	Substr(cCmpM,4)
Local	cPrfxCp	:=	""
Local	cTab	:=	""

//Caso esteja fazendo a consulta pelo pedido de vendas, utilizo tratamento diferenciado, pois preciso buscar o codigo da TES
//atraves do aCols do pedido, para verificar CST de Pis e Cofins
If cCmp $ "C6_TNATREC" .And. aCols <> Nil
    
	//Verifico o codigo da TES
	cTes	:=	aCols[ n , aScan(aHeader,{|z| alltrim(z[2])=="C6_TES"}) ]

	If !(Select("SF4") > 0)
		DbSelectArea("SF4")
		DbSetOrder(1)
	Endif
	
	If SF4->(MsSeek(xFilial("SF4")+cTes))
		cCstPis	:= SF4->F4_CSTPIS
		cCstCof	:= SF4->F4_CSTCOF
	EndIf

//Para a consulta padrao originada de outras tabelas, verifico se o codigo do CST ja foi preenchido para filtrar os registros
Else
	 
	//Prefixo do campo. Ex.: "F4_"
	cPrfxCp	:=	Substr ( cCmp, 1, At("_",cCmp) )  
	
	if len(cPrfxCp)==5 //Verifica se existem os caracteres "->". Ex: "->B1_"
    	cTab:= substr(cCmp,3,2)
    	cTab := "S"+cTab
	Else
		//Tabela origem. Ex.: "SF4"
   		cTab	:=	Substr ( cCmp, 1, At("_",cCmp) - 1 ) 
	   	If At("_",cCmp) == 3
			cTab := "S"+cTab
		Endif
	EndIF   
		
	If !EmpTy(cTab) 
		If (cTab)->(FieldPos(cPrfxCp+"CSTPIS")) > 0
			cCstPis	:=	& (M->(cPrfxCp + "CSTPIS" ))
		Endif
		
		If (cTab)->(FieldPos(cPrfxCp+"CSTCOF")) > 0
			cCstCof	:=	& (M->(cPrfxCp + "CSTCOF" ))
		Endif	
	EndIF

	//Exce?o para tabela F3F que possui apenas 1 campo de CST
	If cTab == "F3F"
		If (cTab)->(FieldPos(cPrfxCp+"CST")) > 0
			cCstPis	:=  cCstCof	:=	& (M->(cPrfxCp + "CST" ))
		Endif
	EndIF
		
Endif
	
Do Case
	//CST 02 - Tabela 4.3.10
	Case (cCstPis = '02' .And. cCstCof = '02')
		cRet := '@#CCZ->CCZ_TABELA $ "4310|4311|4317"@#'
	
	//CST 03 - Tabela 4.3.11	
	Case (cCstPis = '03' .And. cCstCof = '03')
		cRet := '@#CCZ->CCZ_TABELA == "4311"@#'
	
	//CST 04 - Tabela 4.3.10 e 4.3.11	
	Case (cCstPis = '04' .And. cCstCof = '04')
		cRet := '@#CCZ->CCZ_TABELA $ "4310|4311"@#'
		
	//CST 05 - Tabela 4.3.12
	Case (cCstPis = '05' .And. cCstCof = '05')
		cRet := '@#CCZ->CCZ_TABELA == "4312"@#'
	
	//CST 06 - Tabela 4.3.13
	Case (cCstPis = '06' .And. cCstCof = '06')
		cRet := '@#CCZ->CCZ_TABELA == "4313"@#'
		
	//CST 07 - Tabela 4.3.14
	Case (cCstPis = '07' .And. cCstCof = '07')
		cRet := '@#CCZ->CCZ_TABELA == "4314"@#'
		
	//CST 08 - Tabela 4.3.15
	Case (cCstPis = '08' .And. cCstCof = '08')
		cRet := '@#CCZ->CCZ_TABELA == "4315"@#'
		
	//CST 09 - Tabela 4.3.16
	Case (cCstPis = '09' .And. cCstCof = '09')
		cRet := '@#CCZ->CCZ_TABELA == "4316"@#'
	
	OtherWise
		cRet := "@#.T.@#"
EndCase

Return cRet

//-----------------------------------------------------------------------
/*/{Protheus.doc} xFunGetDir
Funcao generica para geracao e leitura de arquivo texto, conforme 
propriedades do Server e Remote

@param	nOpc		->	Opcao que sera utilizada na funcao:
						1: Criacao do arquivo no Startpath
						2: Libera handle do arquivo atraves de FClose()
						3: Realiza copia do arquivo para diretorio especifico
						   ou realiza leitura de arquivo
		cFile		->	Path do arquivo a ser criado
		cArq		->	Arquivo criado pela CriaTrab()
		cStartPath	->	Startpath do ambiente
		nHandle		->	Acesso ao arquivo texto
		lReadFile	->	Indica leitura de arquivo
		cNewFile	->	Nome do arquivo gerado pela funcao

@author Luccas Curcio
@since 26/03/2013
@version 1.00      

@Return	lRet - Processo executado com sucesso
/*/
//-----------------------------------------------------------------------
Function xFunGetDir(nOpc,cFile,cArq,cStartPath,nHandle,lReadFile,cNewFile)
Local	cDrive		:=	""
Local	cPath		:=	""
Local	cExt		:=	""
Local	cLib		:=	""
Local	lRet		:=	.F.
Local	lStartExec	:=	.F.
Local	nRetType	:=	0
Default	cArq		:=	CriaTrab(,.F.)+".TXT"
Default	cNewFile	:=	""
//--------------------------------------------------------------------
//	GetSrvProfString
//--------------------------------------------------------------------
//Recupera o conteudo de uma chave de configurao do ambiente em uso
//no arquivo de configurao (.INI) do TOTVS Application Server.
//--------------------------------------------------------------------
Default	cStartPath 	:= 	AllTrim(GetSrvProfString("StartPath",""))
Default	nHandle		:=	0

//Criacao de arquivo
If nOpc == 1

	//Tratamento para Linux onde a barra e invertida
	If GetRemoteType()==2
		If (SubStr(cStartPath,1,1)<>"/") .And. (SubStr(cStartPath,1,1)<>"\")
			cStartPath	:=	"/"+cStartPath
		EndIf
		
		If (SubStr(cStartPath,Len(cStartPath),1)<>"/") .And. (SubStr(cStartPath,Len(cStartPath),1)<>"\")
			cStartPath	+=	"/"
		EndIf
	Else    
		If (SubStr(cStartPath,1,1)<>"\") .And. (SubStr(cStartPath,1,1)<>"/")
			cStartPath	:=	"\"+cStartPath
		EndIf
		If (SubStr(cStartPath,Len(cStartPath),1)<>"\") .And. (SubStr(cStartPath,Len(cStartPath),1)<>"/")
			cStartPath	+=	"\"
		EndIf	                
	EndIf
	
	//Tratamento para excluir arquivo caso ja exista com mesmo nome
	If (File(cArq))
		FErase (cArq)
	Endif
	
	nHandle	:=	MsFCreate(cArq)
	
	//FError() indica que nao houve erro na criacao do arquivo
	If FError() == 0
		lRet	:=	.T.
	Else
		MsgInfo("Erro na criao do arquivo texto: "+ cValToChar( FError() ) )	//"Erro na criao do arquivo texto: "
	Endif
	
//Liberacao de arquivo	
Elseif nOpc == 2

	If (nHandle>=0)
		FClose (nHandle)
		lRet	:=	.T.
	Endif

//Copia do arquivo para diretorio em disco/leitura de arquivo
Elseif nOpc == 3

	If lReadFile
		If (File(cFile))
			lStartExec := .T.
		Endif
	Else
		If (File(cFile))
			FErase (cFile)
		Endif
		lStartExec := .T.
	Endif

	If lStartExec
		//--------------------------------------------------------------------
		//	SplitPath
		//--------------------------------------------------------------------
		//Divide um diretorio completo em todas as suas subpartes
		//(drive, diretorio, nome e extensao).
		//--------------------------------------------------------------------
		SplitPath(	cFile,;			//-> cArquivo
					@cDrive,;		//-> cDrive
					@cPath,;		//-> cDiretorio
					@cNewFile,;		//-> cNome
					@cExt)			//-> cExtensao

		cNewFile	:=	cNewFile+cExt

		If Empty(cDrive) .and. File( cArq )
			//--------------------------------------------------------------------
			//	MsCopyFile
			//--------------------------------------------------------------------
			//Funcao que executa a copia binaria de um arquivo
			//para o destino especificado.
			//--------------------------------------------------------------------
			lRet := __CopyFile(	cArq,;					//-> cSource
								cDrive+cPath+cNewFile)	//-> cTarget
		Else
			//--------------------------------------------------------------------
			//						LEITURA DE ARQUIVO
			//--------------------------------------------------------------------
			//Funcao executa a leitura de arquivo texto, retornando acesso para
			//o mesmo atraves do nHandle.
			//--------------------------------------------------------------------
			If lReadFile
			    
				//Se o arquivo ja existir na StartPath, devo exclui-lo
				If File(cStartPath+cNewFile)
					FErase(cStartPath+cNewFile)
				Endif
		
                //--------------------------------------------------------------------
				//	CpyT2S
				//--------------------------------------------------------------------
				//Copia um arquivo (compactado ou no) do client (Remote) para Server
				//ou para System quando utilizado rotina automatica no Server. 
				//--------------------------------------------------------------------
				If Empty( cDrive )
					lRet := __CopyFile(	cFile, cStartPath+cNewFile)
				Else
					lRet := CpyT2S(cDrive+cPath+cNewFile,cStartPath,.F. )
				Endif

				If lRet
					nHandle	:=	FOpen(cStartPath+cNewFile)
				Endif
			
			//--------------------------------------------------------------------
			//						  COPIA DE ARQUIVO
			//--------------------------------------------------------------------
			//Funcao que executa a copia binaria de um arquivo 
			//para o destino especificado.
			//--------------------------------------------------------------------
			Else
				If Substr(cStartPath,Len(AllTrim(cStartPath)),1) <> "\"
					cStartPath := cStartPath + "\"
				EndIf

				nRetType := GetRemoteType( @cLib )
				If	nRetType == 5 //"HTML" $ cLib
					msg:= "Em funo do acesso ao sistema ser via SmartClient HTML, o caminho informado para salvar o arquivo ser desconsiderado, e ser processado conforme configurao do navegador."
					msgAlert(msg)
					If File(cStartPath+cArq)
						FRename(cStartPath+cArq,cNewFile)
					EndIf
					lRet := (CPYS2TW(cNewFile)) == 0
					If lRet
						FErase(cStartPath+cArq)
					EndIf
				Else
					//Se o drive nao existir, pergunto ao usuario se deseja cria-lo atraves da funcao LjDirect()
					If !ExistDir(cDrive+cPath)
						LjDirect(cDrive+cPath,.T.)
					Endif

					If ExistDir(cDrive+cPath)
						//--------------------------------------------------------------------
						//	CpyS2T
						//--------------------------------------------------------------------
						//Copia um arquivo (compactado ou no) do servidor 
						//para o client (Remote).
						//--------------------------------------------------------------------
						lRet := CpyS2T(	cStartPath+cArq,;	//-> cOrigem
										cDrive+cPath,;		//-> cDestino
										.F. )				//-> lCompacta
					//Se o usuario nao criar o diretorio, apresento mensagem de erro
					Else
						Alert("Erro ao copiar o arquivo magntico. Diretrio invlido","Erro de Diretrio")
					Endif
				Endif
			Endif
		EndIf

		If lRet .And. !lReadFile
			FErase (cArq)
			If File(cDrive+cPath+cArq)
				FRename(cDrive+cPath+cArq,cFile)
			EndIf
		EndIf
	Endif
Endif

Return lRet

//-----------------------------------------------------------------------
/*/{Protheus.doc} xGetSrvEnv
Funcao que retorna o Database em uso pelo ambiente. Possibilita a verificacao
de ambiente DBF

@param	Nil

@author Luccas Curcio
@since 02/04/2013
@version 1.00      

@Return	cRet	->	Descricao do banco de dados ou DBF
/*/
//-----------------------------------------------------------------------
Function xGetSrvEnv()
Local	cSGBD	:=	TCGetDb()
Local	cRpoDb	:=	Alltrim(GetSrvProfString("RpoDb","Top"))
Local	cRet	:=	""

If Empty(cSGBD) .And. Upper(cRpoDb) == "DBF"
	cRet	:=	"DBF"
Else
	cRet	:=	cSGBD
Endif

Return cRet
//-----------------------------------------------------------------------
/*/{Protheus.doc} AlqLeiTran
Funcao que retorna a aliquota do Imposto para que seja efetuado o 
clculo aproximado dos tributos, conforme Lei 12.741/2012-Transparecia

@param	cAliasB1 -> Alias da tabela SB1
			cAliasBZ -> Alias da tabela SBZ

@author Mauro A. Gonalves
@since 12/08/2013
@version 1.00      

@Return	[nValAlq,cFonte] 
			nValAlq -> Valor da Aliquota
			cFonte  -> Indica de onde a aliquota foi retirada
						  - Em branco, digitada pelo cliente
						  - IBPT, tabela CG9 ou SYD 
/*/
//-----------------------------------------------------------------------
Function AlqLeiTran(cAliasB1,cAliasBZ)

Local aArea			:=	GetArea()       
Local cCodLC116	    := ""
Local cCodExc		:= ""
Local cCodigo		:= ""
Local cFonte		:= ""
Local cQuery		:= ""
Local cAliasCLK	    := "CLK"
Local cNBS			:= ""
Local cNCM			:= ""
Local cUF	 		:= UPPER(Alltrim(SM0->M0_ESTENT))
Local cMvArqProd	:= SuperGetMV("MV_ARQPROD") 
Local dDataAtu	    := DTOS(Date())
Local lPOS			:= FindFunction("STFIsPOS") .AND.  STFIsPOS()
Local lMvArqProp	:= GetNewPar("MV_ARQPROP", .F.)
Local cAliasTrb	:= iif(!lPos .AND. nModulo==23,"SBI->BI_","SB1->B1_")
Local lAchouSB5	:=	SB5->(MsSeek(xFilial("SB5") + &(cAliasTrb + "COD")))
Local lMvEnteTrb	:= SuperGetMv("MV_ENTETRB",.F.,.F.)
Local nValAlq		:= 0
Local nAlqFed		:= 0
Local nAlqEst		:= 0
Local nAlqMun		:= 0
Local lRet 		    := .F.
Local cCodBusca	    := "" 

If lMvEnteTrb
	//Verifica se a tabela existe
	If !AliasInDic("CLK",.T.) 
		RestArea(aArea)
		Return {nValAlq,cFonte,nAlqFed,nAlqEst,nAlqMun}	
	Endif
	
	//Tratamento para os campos
	
	cCodExc	:= Alltrim( &(cAliasTrb + "EX_NCM"))
	cCodExc	+= Space(TamSX3("CLK_EX")[1]-Len(cCodExc)) 
	cUF			+= Space(TamSX3("CLK_UF")[1]-Len(cUF)) 
	
	//Verifico se  Servio ou produto	
	If lAchouSB5 .And. SB5->(FieldPos("B5_NBS"))>0 .AND. !Empty(SB5->B5_NBS) //Tratamento servio
		cNBS	:= Alltrim(SB5->B5_NBS) 	
		cNBS	+= Space(TamSX3("CLK_CODNBS")[1]-Len(cNBS))
	Else
		cNcm:= Alltrim( &(cAliasTrb + "POSIPI") ) 	
		cNCM+= Space(TamSX3("CLK_CODNCM")[1]-Len(cNCM))
	EndIf
	
	If !(Empty(cNBS) .And. Empty(cNcm))
	//Query para buscar valores na tabela CLK
	
		#IFDEF TOP  
			If TcSrvType()<>"AS/400"
				cAliasCLK := GetNextAlias()
				cQuery :=   "SELECT CLK_ALQNAC,CLK_ALQIMP,CLK_ALQEST,CLK_ALQMUN,CLK_FONTE,CLK_CODNCM,CLK_CODNBS FROM "+RetSqlName("CLK")+" CLK "
				cQuery +=    "WHERE CLK_FILIAL  = '"+ xFilial("CLK") + "' "
				If !Empty(cNBS)
					cQuery +=     " AND CLK_CODNBS  = '"    + cNBS    + "' "
				Else
					cQuery +=     " AND CLK_CODNCM  = '"    + cNCM    + "' "
				EndIf				
				cQuery +=     " AND CLK_EX	    = '"    + cCodExc    + "' "
				cQuery +=     " AND CLK_UF	    = '"    + cUF    + "' "
				cQuery +=     " AND CLK_DTINIV <= '"    + dDataAtu    + "' "
				cQuery +=     " AND CLK_DTFIMV >= '"  + dDataAtu + "' "
				cQuery +=     " AND D_E_L_E_T_ = ' ' "
				cQuery := ChangeQuery(cQuery)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasCLK,.T.,.T.)
			Else	
		#ENDIF
				//Tratamento para DBF
				dbSelectArea("CLK")
				If !Empty(cNBS)
					CLK->(dbSetOrder(1)) //CLK_FILIAL+CLK_CODNBS+CLK_EX+CLK_UF+DTOS(CLK_DTINIV)+DTOS(CLK_DTFIMV)
					cCodBusca := cNBS 
				ELse
					CLK->(dbSetOrder(2)) //CLK_FILIAL+CLK_CODNCM+CLK_EX+CLK_UF+DTOS(CLK_DTINIV)+DTOS(CLK_DTFIMV)
					cCodBusca := cNCM 
				EndIf
							
				lRet := CLK->(DbSeek(xFilial("CLK")+cCodBusca+cCodExc+cUF))
	
				If lRet	
					While xFilial("CLK")+cCodBusca+cCodExc+cUF == (CLK->CLK_FILIAL+cCodBusca+CLK->CLK_EX+CLK->CLK_UF)
						// se achar registro no range correto, sai da verificacao 
						If DTOS(CLK->CLK_DTINIV) <= dDataAtu .AND. DTOS(CLK->CLK_DTFIMV) >= dDataAtu
							Exit
						EndIf		
						CLK->(dbSkip())
					End
				EndIf	
								
		#IFDEF TOP
			Endif
		#ENDIF
		
		If !(cAliasCLK)->(Eof()) .And. !(Empty((cAliasCLK)->CLK_CODNCM) .AND. Empty((cAliasCLK)->CLK_CODNBS)) // caso esteja os dois vazios , retorna zerado
		//Preenchimento das variveis com os valores das aliquotas	
			If &(cAliasTrb + "ORIGEM")$"12678" // Importado
				nAlqFed := (cAliasCLK)->CLK_ALQIMP
			Else										
				nAlqFed := (cAliasCLK)->CLK_ALQNAC // Nacional
			Endif
		
			//Aliquotas Estaduais e Municipais
			nAlqEst := (cAliasCLK)->CLK_ALQEST
			nAlqMun := (cAliasCLK)->CLK_ALQMUN
		
			//Somo todas para ter o valor total das aliquotas
			nValAlq := nAlqFed+nAlqEst+nAlqMun
		
			cFonte := (cAliasCLK)->CLK_FONTE
		EndIf	
	EndIf
Else
	If !AliasInDic("CG9",.T.) .OR. !AliasIndic("SYD",.T.) 
		RestArea(aArea)
		Return {nValAlq,cFonte,nAlqFed,nAlqEst,nAlqMun}
	Endif
	
	//Verifica se a aliquota foi informada no cadastro pelo usuario
	If ((cAliasB1)->(FieldPos("B1_IMPNCM"))>0 .AND. (cAliasB1)->B1_IMPNCM>0) .OR. ((cAliasBZ)->(FieldPos("BZ_IMPNCM"))>0 .AND. (cAliasBZ)->BZ_IMPNCM>0)	
		If !lMvArqProp
			If AllTrim(cMvArqProd) == "SBZ"
				nValAlq := IIF((cAliasBZ)->BZ_IMPNCM > 0, (cAliasBZ)->BZ_IMPNCM, 0)
			ElseIf AllTrim(cMvArqProd) == "SB1"
				nValAlq := IIF((cAliasB1)->B1_IMPNCM > 0, (cAliasB1)->B1_IMPNCM, 0)
			EndIf		
		Else	
			nValAlq := IIF((cAliasB1)->B1_IMPNCM > 0, (cAliasB1)->B1_IMPNCM, (cAliasBZ)->BZ_IMPNCM)
		EndIF		
	Else	                 
		cFonte := "IBPT"
	   If Empty((cAliasB1)->B1_CODISS)   //Produto 
			cCodigo	:= (cAliasB1)->B1_POSIPI + (cAliasB1)->B1_EX_NCM
			SYD->(dbSetOrder(1))
			If SYD->(MSSeek(xFilial("SYD")+cCodigo))
				If (cAliasB1)->B1_ORIGEM$"0345" 		//Nacional
					nValAlq := IIf(SYD->(FieldPos("YD_ALIQIMP"))>0, SYD->YD_ALIQIMP, 0)
				Else											//Importado	
					nValAlq := IIf(SYD->(FieldPos("YD_ALIQIM2"))>0, SYD->YD_ALIQIM2, 0)
				Endif
			Endif                                      
		Elseif AliasIndic( "CDN" )       //Servico
			cCodigo	:= (cAliasB1)->B1_CODISS                               
			CDN->(DbSetOrder(1))
			If CDN->(MSSeek(xFilial("CDN")+cCodigo)) //Localiza codigo ISS para pegar o codigo LC116
				//Tratamento do tamanho
				cCodLC116	:= CDN->CDN_CODLST
				cCodLC116	+= Space(TamSX3("CG9_CODIGO")[1]-Len(cCodLC116))
				cCodExc		:= IIf(Val(cCodExc)>0 ,Alltrim(Str(Val(cCodExc))),'')
				cCodExc		+= Space(TamSX3("CG9_EX")[1]-Len(cCodExc))
				CG9->(DBSetOrder(1))
				If CG9->(MSSeek(xFilial("CG9") + cCodLC116 + cCodExc + DTOS(CTOD("  /  /    "))))
					If (cAliasB1)->B1_ORIGEM$"0345" 		//Nacional
						nValAlq := IIf(CG9->(FieldPos("CG9_ALQNAC"))>0, CG9->CG9_ALQNAC, 0)
					Else                             	//Importado	
						nValAlq := IIf(CG9->(FieldPos("CG9_ALQIMP"))>0, CG9->CG9_ALQIMP, 0)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf	
EndIf 

If !Empty(cQuery)
	dbSelectArea(cAliasCLK)
	dbCloseArea()
EndIf

RestArea(aArea)
aSize(aArea,0)
aArea := nil

Return {nValAlq,cFonte,nAlqFed,nAlqEst,nAlqMun}

//-------------------------------------------------------------------
/*/{Protheus.doc} Lei2741

@param	cNCM		-> Cdigo da NCM do produto
		cExNCM		-> Ex da NCM
		cCodISS		-> Cdigo do servio
		cUF			-> Unidade Federativa da operao
		cCodMun		-> Cdigo do municpio da operao
		cCodProd	-> Cdigo do Municpio da operao
		nItem		-> Nmero do item do documento fiscal.
		cNumLote	-> Nmero do Sublote utilizado no item
		cLoteCtl	-> Nmero do lote utilizado no item
		cMvFisCTrb  -> Contedo do parmetro MV_FisCTrb   
		cMvFisAlCT	-> Contedo do parmetro MV_FisAlCT
		lMvFisFRas	-> Contedo doparmetro MV_FISFRAS

		
@return Percentual referente a carga tributria do item.
 
@author Erick G. Dias
@since 30/09/2013
@version 11.90

/*/
//-------------------------------------------------------------------
Function AlqLei2741(cNCM,cExNCM,cCodISS,cUF,cCodMun,cCodProd,nItem,cNumLote,cLoteCtl,cMvFisCTrb,cMvFisAlCT,lMvFisFRas,cTipo)

Local aRetAlqNF		:={0,0,0,0,0,0,0,0}
Local aRetLegado	:={0,"",0,0,0}
Local cOper			:= Iif(MaFisRet(nItem,"IT_BASEISS")>0,"S","N")
Local lAchouSB1		:= .F.
Local lAchouSBI		:= .F.
Local lAchouSBZ		:= .F. 
Local lMvEnteTrb	:= SuperGetMv("MV_ENTETRB",.F.,.F.)
Local nPercentual	:= 0	//Percentual total  
Local nAliqFed		:= 0	//Percentual Aliquota Federal
Local nAliqEst		:= 0	//Percentual Aliquota Estadual
Local nAliqMun		:= 0	//Percentual Aliquota Municipal
Local nValPerc		:= 0	//Valor do Percentual Total
Local nValFed		:= 0	//Valor do Percentual Federal
Local nValEst		:= 0	//Valor do Percentual Estadual
Local nValMun		:= 0	//Valor do Percentual Municipal
Local xRet			:= 0 	//Variavel de Retorno - a funo tem 2 tipos de retorno Array e Numrico                                                                                      
Local jRetCGACGB	:= JsonObject():New()

DEFAULT cNCM		:= ""
DEFAULT cExNCM		:= ""
DEFAULT cCodISS		:= ""
DEFAULT cUF			:= "**" 
DEFAULT cCodMun		:= ""
DEFAULT cCodProd	:= ""  
DEFAULT cNumLote	:= ""       
DEFAULT cLoteCtl	:= ""
DEFAULT cMvFisCTrb	:= "1"                                      		
DEFAULT cMvFisAlCT	:= "3"
DEFAULT lMvFisFRas	:= .F.
DEFAULT cTipo		:= ""          

If cTipo $ "I/P"
	Return(aRetAlqNF)
EndIf

IF cMvFisCTrb == "1" //LEGADO
	lAchouSB1:=SB1->(MsSeek(xFilial("SB1") + cCodProd))
	lAchouSBI:=SBI->(MsSeek(xFilial("SBI") + cCodProd))	
	lAchouSBZ:=SBZ->(MsSeek(xFilial("SBZ") + cCodProd))	
	
    
	//Ŀ
	//Far tratamento para SIGALOJA
	//	
	If nModulo == 12 .AND. !lMvEnteTrb
		IF lAchouSB1
			nPercentual:= LjLeiLoj(cCodProd)    // SYD , somente legado 
		EndIF	
	//Ŀ
	//Far tratamento para o FRONTLOJA
	//
	ElseIF nModulo == 23 .AND. !lMvEnteTrb
		IF lAchouSBI
			nPercentual:= LjLeiFrt(cCodProd)    // SYD , somente legado// SYD , somente legado
		EndIF
	
	//Ŀ
	//Faturamento e/ou TSS
	//	
	ElseIf (lAchouSB1 .or. lAchouSBZ .OR. lAchouSBI) 
					
		//com parametro MV_ENTETRB = .T., busca da CLK , onde estao as aliquotas separadas, Federacao, UF e Mun. 
		aRetLegado := AlqLeiTran("SB1","SBZ")   
		
		nPercentual	:= aRetLegado[1]
		nAliqFed		:= aRetLegado[3]
		nAliqEst		:= aRetLegado[4]
		nAliqMun		:= aRetLegado[5]
	EndIF
		
ElseIF cMvFisCTrb == "2"
			//1 - Ir considerar as alquotas do documentos fiscal mais o percentual da tabela CGA
			//2 - Sistema ir considerar somente percentual informado na tabela CGA e CGB
	if cMvFisAlCT $ "1/2" 
		//Retorno CGA/CGB
		jRetCGACGB :=TotCGACGB(cNCM , cExNCM, cCodISS , cUF , cCodMun , cCodProd,cOper)
	endif

	aRetAlqNF:=TotAlqNF(nItem,cCodProd,lMvFisFRas,cNumLote,cLoteCtl,jRetCGACGB,cMvFisAlCT)
	FreeObj(jRetCGACGB)

	nPercentual	:= aRetAlqNF[1]
	nAliqFed	:= aRetAlqNF[2]
	nAliqEst	:= aRetAlqNF[3]
	nAliqMun	:= aRetAlqNF[4]
	nValPerc	:= aRetAlqNF[5]
	nValFed		:= aRetAlqNF[6]
	nValEst		:= aRetAlqNF[7]
	nValMun		:= aRetAlqNF[8]

EndIF

If (IsInCallStack("LJ7RECTRIB") .Or. IsInCallStack("LjGrvSF2") .Or. IsInCallStack("LjGrvTran") .Or. nModulo == 12 .Or. nModulo == 23) 
	If !lMvEnteTrb		
		xRet := {nPercentual,nValPerc,0,0}
	Else
		xRet := {nPercentual,nAliqFed,nAliqEst,nAliqMun, nValPerc,nValFed,nValEst,nValMun}
	EndIf
Else
	xRet := {nPercentual,nAliqFed,nAliqEst,nAliqMun, nValPerc,nValFed,nValEst,nValMun}
EndIf

Return xRet

//-------------------------------------------------------------------
/*/{Protheus.doc} TotAlqNF
Funo que retonar soma das alquotas utilizadas e calculadas atravs 
da MATXFIS

@param	nX		    -> Nmero do item para buscar as alquotas utilizadas
		cCodProd	-> Cdigo do produto
		lMvFisFRas	-> Contedo do parmetro MV_FISFRAS
		cNumLote	-> Nmero do sublote
		cLoteCtl	-> Nmero do lote
		
@return nAliquota -> Soma das alquotas utilizadas no documento fiscal

@author Erick G. Dias
@since 30/09/2013
@version 11.90

/*/
//-------------------------------------------------------------------
Static Function TotAlqNF(nX,cCodProd,lMvFisFRas,cNumLote,cLoteCtl,jAlqCGACGB,cMvFisAlCT)

Local cCstIPI		:= AllTrim(MaFisRet(nX,"LF_CTIPI"))
Local cCstICMS		:= Substr(MaFisRet(nX,"IT_CLASFIS"),2,2)
Local cCstPIS		:= AllTrim(MaFisRet(nX,"LF_CSTPIS"))
Local cCstCOF		:= AllTrim(MaFisRet(nX,"LF_CSTCOF"))
Local cQuant		:= MaFisRet(nX,"IT_QUANT")
Local nAliquota	:= 0
Local nAliqST		:= 0
Local nValST		:= 0
Local nAliqII		:= 0
Local nValII		:= 0
Local nAliqSTMe	:= 0
Local nValSTMe	:= 0
Local nFedAliq	:= 0
Local nEstAliq	:= 0
Local nMunAliq	:= 0
Local nPercVal	:= 0	//Valor do Percentual Total
Local nFedVal		:= 0	//Valor do Percentual Federal
Local nEstVal		:= 0	//Valor do Percentual Estadual
Local nMunVal		:= 0	//Valor do Percentual Municipal
Local nTotNota	:= MaFisRet(nX,"IT_TOTAL")
Local lMediaST	:= SuperGetMV("MV_STMEDIA",,.F.)
Local nPRedICM	:= MaFisRet(nX,"IT_PREDIC")
Local nPRedSOL	:= MaFisRet(nX,"IT_PREDST")
Local aAliqVal	:= {0,0}

Default jAlqCGACGB := JsonObject():New()
Default cMvFisAlCT	:= ""

//Ŀ
//Alquota do IPI
//
IF cCstIPI == "50" // verifica se CST de IPI  Tributado	
	aAliqVal := xFisF_LT(MaFisRet(nX,"IT_VALIPI"),MaFisRet(nX,"IT_BASEIPI"),RedcAlq(MaFisRet(nX,"IT_ALIQIPI"), MaFisRet(nX,"IT_PREDIPI")),jAlqCGACGB["IPI"],cMvFisAlCT)
	nFedAliq += aAliqVal[1]
	nFedVal  += aAliqVal[2]
EndIF 

//Ŀ
//Alquota de PIS
//
IF cCstPIS $ "01/02/03/05" //Verifica se CST de PIS tributado 
	aAliqVal := xFisF_LT(MaFisRet(nX,"IT_VALPS2"),MaFisRet(nX,"IT_BASEPS2"),MaFisRet(nX,"IT_ALIQPS2"),jAlqCGACGB["PIS"],cMvFisAlCT)
	nFedAliq += aAliqVal[1] //MaFisRet(nX,"IT_ALIQPS2") //Alquota de PIS via apurao	
	nFedVal  += aAliqVal[2] //MaFisRet(nX,"IT_VALPS2") //Valor de PIS via apurao	

	nFedAliq += MaFisRet(nX,"IT_ALIQPS3") //Alquota de PIS ST
	nFedVal  += MaFisRet(nX,"IT_VALPS3")  //Valor de PIS via apurao	
EndIF

//Ŀ
//Alquota da COFINS
//
If cCstCOF $ "01/02/03/05"//Verifica se CST da COFINS tributado
	aAliqVal := xFisF_LT(MaFisRet(nX,"IT_VALCF2"),MaFisRet(nX,"IT_BASECF2"),MaFisRet(nX,"IT_ALIQCF2"),jAlqCGACGB["COFINS"],cMvFisAlCT)
	nFedAliq += aAliqVal[1] //MaFisRet(nX,"IT_ALIQCF2") //Alquota de COFINS via apurao
	nFedVal  += aAliqVal[2] //MaFisRet(nX,"IT_VALCF2") //Valor de COFINS via apurao

	// nesse caso pego o valor direto das referncias pois no h como cadastrar
	// alquota de ST na FISA070 e por conta disso no chamo a funo xFisF_LT para avaliar qual alquota aplicar
	nFedAliq += MaFisRet(nX,"IT_ALIQCF3") //Alquota de Cofins ST
	nFedVal  += MaFisRet(nX,"IT_VALCF3")  //Valor de COFINS via apurao
EndIF

//Ŀ
//Alquota do ISS
// 
If MaFisRet(nX,"IT_VALISS") > 0
	aAliqVal := xFisF_LT(MaFisRet(nX,"IT_VALISS"),MaFisRet(nX,"IT_BASEISS"),MaFisRet(nX,"IT_ALIQISS"),jAlqCGACGB["ISS"],cMvFisAlCT)
	nMunAliq += aAliqVal[1] //MaFisRet(nX,"IT_ALIQISS") //Alquota do ISS
	nMunVal  += aAliqVal[2] //MaFisRet(nX,"IT_VALISS") //Alquota do ISS
EndIf

If lMvFisFRas //Chama SPEDRASTRO para buscar a alquota do ICMS utilizado no documento de entrada e o valor da alquota de II
	SpedRastro2(cNumLote,cLoteCtl,cCodProd,,0,.F.,,lMediaST,@nAliqST,@nAliqII,.T.,,cCstICMS,@nAliqSTMe,nTotNota,cQuant,@nValSTMe,@nValST,@nValII)	
EndIF

//Ŀ
//Alquota ICMS
//
IF cCstICMS $ "00/20" //Tributado integralmente ou com reduo da base de clculo
    If nAliqII = 0 // Nao pegara o Imposto pois sera calculado pela media das entradas  - Cunha
	    If cCstICMS =="20"
	    	aAliqVal := xFisF_LT(MaFisRet(nX,"IT_VALICM"),MaFisRet(nX,"IT_BASEICM"),RedcAlq(MaFisRet(nX,"IT_ALIQICM"), (100 - nPRedICM)),jAlqCGACGB["ICMS"],cMvFisAlCT)
			nEstAliq += aAliqVal[1] //RedcAlq(MaFisRet(nX,"IT_ALIQICM"), (100 - nPRedICM))
	    	nEstVal  += aAliqVal[2] //MaFisRet(nX,"IT_VALICM")
	    Else
	    	aAliqVal := xFisF_LT(MaFisRet(nX,"IT_VALICM"),MaFisRet(nX,"IT_BASEICM"),RedcAlq(MaFisRet(nX,"IT_ALIQICM"), nPRedICM),jAlqCGACGB["ICMS"],cMvFisAlCT)
			nEstAliq += aAliqVal[1] //RedcAlq(MaFisRet(nX,"IT_ALIQICM"), nPRedICM)
	    	nEstVal  += aAliqVal[2] //MaFisRet(nX,"IT_VALICM")
	    EndIf
	 Else 
	    nEstAliq += nAliqSTMe
	    nEstVal  += nValSTMe
	 Endif
ElseIF cCstICMS $ "10/30/70"
	If cCstICMS $ "10/70"
		If nPRedICM > 0 .And. nPRedSOL > 0
			aAliqVal := xFisF_LT(MaFisRet(nX,"IT_VALICM"),MaFisRet(nX,"IT_BASEICM"),RedcAlq(MaFisRet(nX,"IT_ALIQICM"), (100 - nPRedICM)),jAlqCGACGB["ICMS"],cMvFisAlCT)
			nEstAliq += aAliqVal[1] //RedcAlq(MaFisRet(nX,"IT_ALIQICM"), (100 - nPRedICM))
			nEstVal	 += aAliqVal[2] //MaFisRet(nX,"IT_VALICM")

			// nesse caso pego o valor direto das referncias pois no h como cadastrar
			// alquota de ST na FISA070 e por conta disso no chamo a funo xFisF_LT para avaliar qual alquota aplicar
			nEstAliq += RedcAlq(MaFisRet(nX,"IT_ALIQSOL"), (100 - nPRedSOL))
			nEstVal	 += MaFisRet(nX,"IT_VALSOL")

		ElseIf nPRedICM == 0 .And. nPRedSOL > 0 
			aAliqVal := xFisF_LT(MaFisRet(nX,"IT_VALICM"),MaFisRet(nX,"IT_BASEICM"),MaFisRet(nX,"IT_ALIQICM"),jAlqCGACGB["ICMS"],cMvFisAlCT)
			nEstAliq += aAliqVal[1]  //MaFisRet(nX,"IT_ALIQICM")
			nEstVal	 += aAliqVal[2] //MaFisRet(nX,"IT_VALICM")

			// nesse caso pego o valor direto das referncias pois no h como cadastrar
			// alquota de ST na FISA070 e por conta disso no chamo a funo xFisF_LT para avaliar qual alquota aplicar
			nEstAliq += RedcAlq(MaFisRet(nX,"IT_ALIQSOL"), (100 - nPRedSOL))
			nEstVal	 += MaFisRet(nX,"IT_VALSOL")

		ElseIf nPRedICM > 0 .And. nPRedSOL == 0
			aAliqVal := xFisF_LT(MaFisRet(nX,"IT_VALICM"),MaFisRet(nX,"IT_BASEICM"),RedcAlq(MaFisRet(nX,"IT_ALIQICM"), (100- nPRedICM)),jAlqCGACGB["ICMS"],cMvFisAlCT)
			nEstAliq += aAliqVal[1] //RedcAlq(MaFisRet(nX,"IT_ALIQICM"), (100- nPRedICM))
			nEstVal	 += aAliqVal[2] //MaFisRet(nX,"IT_VALICM")

			// nesse caso pego o valor direto das referncias pois no h como cadastrar
			// alquota de ST na FISA070 e por conta disso no chamo a funo xFisF_LT para avaliar qual alquota aplicar
			nEstAliq += MaFisRet(nX,"IT_ALIQSOL")
			nEstVal	 += MaFisRet(nX,"IT_VALSOL")

		Else
			aAliqVal := xFisF_LT(MaFisRet(nX,"IT_VALICM"),MaFisRet(nX,"IT_BASEICM"),MaFisRet(nX,"IT_ALIQICM"),jAlqCGACGB["ICMS"],cMvFisAlCT)
			nEstAliq += aAliqVal[1] //MaFisRet(nX,"IT_ALIQICM")
			nEstVal	 += aAliqVal[2] //MaFisRet(nX,"IT_VALICM")

			// nesse caso pego o valor direto das referncias pois no h como cadastrar
			// alquota de ST na FISA070 e por conta disso no chamo a funo xFisF_LT para avaliar qual alquota aplicar
			nEstAliq += MaFisRet(nX,"IT_ALIQSOL")
			nEstVal	 += MaFisRet(nX,"IT_VALSOL")

		EndIf
	Else
		nEstAliq += MaFisRet(nX,"IT_ALIQSOL")
		nEstVal	 += MaFisRet(nX,"IT_VALSOL")
	EndIf
ElseIF cCstICMS == "60" .and. nAliqSTMe = 0 //Cobrado via ST
	nEstAliq += nAliqST
	nEstVal  += nValST
ElseIF cCstICMS == "60" .and. nAliqSTMe > 0  // Quando a aliquota for calculada pela media DE ST (FUNCAO CALCMEDIA). 
	nEstAliq += nAliqSTMe
	nEstVal  += nValSTMe
Else
	aAliqVal := xFisF_LT(MaFisRet(nX,"IT_VALICM"),MaFisRet(nX,"IT_BASEICM"),RedcAlq(MaFisRet(nX,"IT_ALIQICM"), nPRedICM),jAlqCGACGB["ICMS"],cMvFisAlCT)
	nEstAliq += aAliqVal[1] //RedcAlq(MaFisRet(nX,"IT_ALIQICM"), nPRedICM)
	nEstVal  += aAliqVal[2] //MaFisRet(nX,"IT_VALICM")
EndIF

//Ŀ
//Alquota de Importao
//
If nAliqII = 0  //Nao pegara o Imposto pois sera calculado pela media das entradas - Cunha
   nFedAliq += nAliqII  // por cunha
   nFedVal  += nValII
Endif

//Total de todos tributos

nAliquota:= nFedAliq + nEstAliq + nMunAliq
nPercVal := nFedVal + nEstVal + nMunVal

FreeObj(jAlqCGACGB)

Return {nAliquota,nFedAliq,nEstAliq,nMunAliq, nPercVal,nFedVal,nEstVal,nMunVal} 

//-------------------------------------------------------------------
/*/{Protheus.doc} TotCGACGB     
Funo que retornar percentual de tributos cadastrados nas tabelas CGA e CGB.

@param	cNcm		-> Cdigo NCM
		cExNCM		-> Ex-NCM
		cCodISS		-> Cdigo do servio
		cUF			-> Unidade da federao de destino		
		cCodMun		-> Cdigo do municpio
		cCodProd	-> Cdigo do produto do item
		cOper		-> Tipo da operao ("s" servio "n" normal)
		
@return Percentual cadastrado na tabela CGA e CGB
		
@author Erick G. Dias
@since 30/09/2013
@version 11.90

/*/
//-------------------------------------------------------------------
Static Function TotCGACGB(cNCM, cExNCM, cCodISS, cUF, cCodMun, cCodProd, cOper)
	Local cAlias := ""
	Local jAlqCGACGB:= JsonObject():New()
	local nGrupo:= 0

	If AliasIndic( "CGA" ) .AND. AliasIndic("CGB")	
		cAlias := exQryCGBCGA(cOper, cCodISS, cNCM, cExNCM, cUF, cCodMun,cCodProd)

		if !Empty(cAlias)
			// pego GRUPO do primeiro registro pois todos os registros que quero
			// conforme o retorno da query, so aqueles que pertence ao grupo
			// do primeiro registro.
			nGrupo := (cAlias)->GRUPO
			jAlqCGACGB["TOTMUN"] := (cAlias)->ALIQMUN
			jAlqCGACGB["TOTEST"] := (cAlias)->ALIQEST
			jAlqCGACGB["TOTFED"] := (cAlias)->ALIQFED
			jAlqCGACGB["TOTPER"] := (cAlias)->ALIQTOT
			while !(cAlias)->(eof()) .AND. nGrupo == (cAlias)->GRUPO
				jAlqCGACGB[AllTrim((cAlias)->TRIBUTO)] := (cAlias)->ALIQUOTA
				(cAlias)->(DbSkip())
			Enddo
			(cAlias)->(dbCloseArea())
		endif
	EndIF
return jAlqCGACGB


/*/{Protheus.doc} QryCGBCGA
	Cria a query na CGB com join na CGA
	@type  Static Function
	@author anedino.santos
	@since 05/12/2023
	@version 12.1.2310
	@param cOper, String, qual o tipo de operao S = Servio; N = Normal
	@return cQry, String, query criada para CGB com join na CGA
/*/
static function QryCGBCGA(cOper)
	local cQry := ""
	local cCpmWhere := ""

	if cOper == "S"
		cCpmWhere := "CGB.CGB_CODISS = ?"
	else
		cCpmWhere := "CGB.CGB_NCM = ? AND CGB.CGB_EXNCM = ?"
	endif

	BEGINCONTENT var cQry
		SELECT
		CASE
			WHEN (CGB.CGB_UF = ? AND
				CGB.CGB_CODMUN = ? AND
				CGB.CGB_CODPRO = ?) THEN 1
			WHEN (CGB.CGB_UF = ? AND
				CGB.CGB_CODMUN = ? AND
				CGB.CGB_CODPRO = ' ') THEN 2
			WHEN (CGB.CGB_UF = ? AND
				CGB.CGB_CODMUN = ' ' AND
				CGB.CGB_CODPRO = ?) THEN 3
			WHEN (CGB.CGB_UF = ? AND
				CGB.CGB_CODMUN = ' ' AND
				CGB.CGB_CODPRO = ' ') THEN 4
			WHEN (CGB.CGB_UF = '**' AND
				CGB.CGB_CODMUN = ' ' AND
				CGB.CGB_CODPRO = ?) THEN 5
			WHEN (CGB.CGB_UF = '**' AND
				CGB.CGB_CODMUN = ' ' AND
				CGB.CGB_CODPRO = ' ') THEN 6
		END AS GRUPO,
		CGB.CGB_TPTRIB TRIBUTO,
		CGB.CGB_TOTPER ALIQUOTA,
		CGA.CGA_TOTPER ALIQTOT,
		CGA.CGA_TOTFED ALIQFED,
		CGA.CGA_TOTEST ALIQEST,
		CGA.CGA_TOTMUN ALIQMUN
		FROM ? CGB
		INNER JOIN ? CGA
			ON CGA_FILIAL = CGB_FILIAL
			AND CGA_CODPRO = CGB_CODPRO
			AND CGA_NCM = CGB_NCM
			AND CGA_EXNCM = CGB_EXNCM
			AND CGA_CODISS = CGB_CODISS
			AND CGA_UF = CGB_UF
			AND CGA_CODMUN = CGB_CODMUN
		WHERE CGA.CGA_FILIAL = ?
			AND CGA.D_E_L_E_T_ = ' '
			AND CGB.D_E_L_E_T_ = ' '
			AND (? < CGB.CGB_DTFIMV	OR CGB.CGB_DTFIMV = ' ')
			AND %Exp:cCpmWhere%
		ORDER BY GRUPO
	ENDCONTENT
return cQry

/*/{Protheus.doc} exQryCGBCGA
	Executa a query criada pela funo makeQryCGB
	@type  Static Function
	@author anedino.santos
	@since 05/12/2023
	@version 12.1.2310
	@param cOper,	String, Tipo da Operao S = Servio; N = Normal.
	@param cCodISS, String, Cdigo do servio
	@param cNCM,	String, Cdigo da NCM do produto
	@param cExNCM,	String, Ex da NCM
	@param cUF,		String, Unidade Federativa da operao
	@param cCodMun, String, Cdigo do municpio da operao
	@param cCodProd,String, Cdigo do produto da operao
	@return cAlias, String, Alias criado conforme a execuo da query
/*/
static function exQryCGBCGA(cOper, cCodISS, cNCM, cExNCM, cUF, cCodMun, cCodProd)
	local cAlias := ""
	local cQuery := ""
	Local oStatement

	cQuery := QryCGBCGA(cOper)
	oStatement := FWExecStatement():New(cQuery)
	oStatement:setString(1, cUf)
	oStatement:setString(2, cCodMun)
	oStatement:setString(3, cCodProd)
	oStatement:setString(4, cUf)
	oStatement:setString(5, cCodMun)
	oStatement:setString(6, cUf)
	oStatement:setString(7, cCodProd)
	oStatement:setString(8, cUf)
	oStatement:setString(9, cCodProd)
	oStatement:SetUnsafe(10, RetSqlName( 'CGB' ))
	oStatement:SetUnsafe(11, RetSqlName( 'CGA' ))
	oStatement:setString(12, xFilial( 'CGA' ))
	// dDataBase  uma varivel acessvel de todo o sistema e representa a data
	// definida no login do protheus.
	oStatement:setDate(13, dDataBase)
	if cOper == 'S'
		oStatement:setString( 14, cCodISS )
	else
		oStatement:setString( 14, cNCM )
		oStatement:setString( 15, cExNCM )
	endif

	cQuery := oStatement:getFixQuery()

	cAlias := oStatement:OpenAlias(GetNextAlias())
	FreeObj(oStatement)
return cAlias


//-------------------------------------------------------------------
/*/{Protheus.doc} RedcAlq     
Funo que verifica se existe percentual de reduo de base de clculo, se
existir aplica o percentual na alquota, caso contrrio retorna a
prpria alquota sem reduo.

@param	nAlquota		-> Alquota do tributo
		nPercRed		-> Percentual de reduo
		
@return Alquota aps reduo se houver
		
@author Erick G. Dias
@since 03/10/2013
@version 11.90

/*/
//-------------------------------------------------------------------
Static Function RedcAlq(nAliquota, nPercRed)

Local nRet	:= nAliquota

DEFAULT nAliquota	:= 0
DEFAULT nPercRed	:= 0

IF nPercRed > 0 .and. nAliquota > 0
	nPercRed	:= nPercRed/100
	nRet := nAliquota - (nAliquota*nPercRed)
EndIF

Return nRet  


//-------------------------------------------------------------------
/*/{Protheus.doc} LjLeiFrt     
Processamento para buscar carga tributria para o mdulo FRONTLOJA.

@param	cCodProd		-> Cdigo do Produto		
@return Carga tributria
		
@author Erick G. Dias
@since 03/10/2013
@version 11.90

/*/
//-------------------------------------------------------------------
Static Function LjLeiFrt(cCodProd)
Local lBuscaImp		:=  FindFunction("lj7BuscaImp")
Local nRet			:= 0
Local lPosIpi	  	:=	SBI->(FieldPos("BI_POSIPI")) > 0                                               
nRet :=  SBI->BI_IMPNCM                  

//Se na SBI estiver zerado, ento ir buscar atravs da funo lj7BuscaImp
If nRet == 0 .AND. lBuscaImp .AND. lPosIpi .AND. !Empty(SBI->BI_POSIPI)
	nRet  := lj7BuscaImp(SBI->BI_POSIPI,!Empty(SBI->BI_CODISS), .F. )
EndIf                     

Return nRet

//-------------------------------------------------------------------
/*/{Protheus.doc} LjLeiFrt     
Processamento para buscar carga tributria para o mdulo SIGALOJA.

@param	cCodProd		-> Cdigo do Produto		
@return Carga tributria
		
@author Erick G. Dias
@since 03/10/2013
@version 11.90

/*/
//-------------------------------------------------------------------
Static Function LjLeiLoj(cCodProd)
Local lBuscaImp		:= FindFunction("lj7BuscaImp")
Local lBImport		:= .F.
Local nRet			:= 0

	// Busca na SBZ
	nRet := LjRtFldPrd(SB1->B1_COD,"B1_IMPNCM","SB1")
	
	If  nRet ==0         
		nRet := SB1->B1_IMPNCM
	EndIf
                                                                                                              
    If nRet ==0 .AND.  lBuscaImp
        If Empty(SB1->B1_CODISS) // eh produto 
            If !Empty(SB1->B1_POSIPI)
                lBImport    := !(SB1->B1_ORIGEM $ ' 0345') // se nao for nacional ( Manual IBPT )
                nRet        := lj7BuscaImp(SB1->B1_POSIPI,.F.,lBImport,SB1->B1_EX_NCM)
            EndIf        
        Else //serviço
            If Empty(SB1->B1_POSIPI)
                lBImport    := !(SB1->B1_ORIGEM $ ' 0345') // se nao for nacional ( Manual IBPT )
                nRet        := lj7BuscaImp(,.T.,lBImport,,SB1->B1_COD)
            EndIf        
        
        EndIf
	EndIf	
//EndIf


Return nRet

//-------------------------------------------------------------------
/*/{Protheus.doc} LjRtFldPrd   
Retorna as informacoes do arquivo SB0 ou da tabela de dados acessorios do produto.

@param	cCodProd		-> Cdigo do Produto		
@param	cCampo         -> Nome do campo da tabela SB0
@param	cAliasTop 		-> Nome do alias top
@return Conteudo do campo da tabela SB0 ou SBZ 
@author Varejo
@since 11/09/14
@version 12

/*/
//-------------------------------------------------------------------
Function LjRtFldPrd(cCodPro,cCampo,cAliasTop)
Local cDadosProd:= SuperGetMV("MV_ARQPROD",.F.,"SB1") //Arquivo de dados de Produtos
Local aArea     := GetArea() //Workarea ativa
Local cRet      := ""		//Retorno
Local lDadosSBZ := .F.		//Dados SBZ

Default cAliasTop := "SB1"

//Ŀ
// Checa a existencia dos dados na tabela SBZ             
//
If cDadosProd == "SBZ"
	dbSelectArea("SBZ")
	lDadosSBZ:=!RetArqProd(cCodPro)
EndIf

//Ŀ
// Retorna o conteudo dos campos da tabela SBZ            
//
If lDadosSBZ
	// Lista de campos fixos - NAO USAR MACRO PARA GARANTIR PERFORMANCE IDEAL
	If cCampo == "B0_IMPNCM" 
		cRet:=SBZ->BZ_IMPNCM
	Else
		cRet:=Criavar(cCampo,.F.)
	EndIf
//Ŀ
// Retorna o conteudo dos campos da tabela SB1            
//
ElseIf (cAliasTop)->B1_COD == cCodPro 	
	If cCampo == "B1_IMPNCM" 
		cRet:=(cAliasTop)->B1_IMPNCM
	Else
		cRet:=Criavar(cCampo,.F.)
	EndIf	
EndIf

Restarea(aArea)
Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} RetUfIBGE
Funcao que retorna o codigo da UF do participante, de acordo com a 
tabela disponibilizada pelo IBGE.

@author Simone Oliveira
@since 05.03.2015
@version 11.80

@param  cUf    Sigla da UF do cliente/fornecedor

@return cCod   Codigo da UF

/*/
//-------------------------------------------------------------------
Function RetUfIBGE(cUf,lForceUF)
Local nX         := 0
Local cRetorno   := ""
Local aUF        := {}

DEFAULT lForceUF := .T.

aadd(aUF,{"RO","11"})
aadd(aUF,{"AC","12"})
aadd(aUF,{"AM","13"})
aadd(aUF,{"RR","14"})
aadd(aUF,{"PA","15"})
aadd(aUF,{"AP","16"})
aadd(aUF,{"TO","17"})
aadd(aUF,{"MA","21"})
aadd(aUF,{"PI","22"})
aadd(aUF,{"CE","23"})
aadd(aUF,{"RN","24"})
aadd(aUF,{"PB","25"})
aadd(aUF,{"PE","26"})
aadd(aUF,{"AL","27"})
aadd(aUF,{"SE","28"})
aadd(aUF,{"BA","29"})
aadd(aUF,{"MG","31"})
aadd(aUF,{"ES","32"})
aadd(aUF,{"RJ","33"})
aadd(aUF,{"SP","35"})
aadd(aUF,{"PR","41"})
aadd(aUF,{"SC","42"})
aadd(aUF,{"RS","43"})
aadd(aUF,{"MS","50"})
aadd(aUF,{"MT","51"})
aadd(aUF,{"GO","52"})
aadd(aUF,{"DF","53"})

If !Empty(cUF)
	nX := aScan(aUF,{|x| x[1] == cUF})
	If nX == 0
		nX := aScan(aUF,{|x| x[2] == cUF})
		If nX <> 0
			cRetorno := aUF[nX][1]
		EndIf
	Else
		cRetorno := aUF[nX][2]
	EndIf
Else
	cRetorno := IIF(lForceUF,"",aUF)
EndIf

Return(cRetorno)

//-------------------------------------------------------------------
/*/{Protheus.doc} GetSubTrib

	Retorna Numero da Inscricao Estadual do contribuinte em outro 
	estado 	quando 	houver Substituicao Tributaria
	Se o parametro MV_SUBTRIB estiver em branco, procura na tabela CLO

@param:	cUF - Unidade da Federao
@return:	cSubTrib - Conteudo da tabela ou parametro 

@author Mauro Afonso Gonalves
@since 23.02.2015
@version 1.0

/*/
//-------------------------------------------------------------------
Function GetSubTrib(cUF,lDifal)
Local cSubTrib	:= ""
Local cPar		:= "MV_SUBTRI"
Local lF0LCgc	:= F0L->(FieldPos("F0L_CGC"))>0

Default cUF := ""
Default lDifal:= .F.

If lDifal .And. !AliasInDic("F0L")
	lDifal:= .F.
endif
//Leitura exclusiva
If SX6->(DbSeek (cFilAnt+cPar))
	Do While !SX6->(Eof ()) .And. (cPar$SX6->X6_VAR) .And. (cFilAnt==SX6->X6_FIL)
		If !Empty(SX6->X6_CONTEUD)
			cSubTrib	+=	"/"+AllTrim (SX6->X6_CONTEUD)
		EndIf
		SX6->(DbSkip ())
	EndDo
EndIf	
	
//Leitura Compartilhada
If SX6->(DbSeek (PadR("",FWGETTAMFILIAL)+cPar))
	Do While !SX6->(Eof ()) .And. (cPar$SX6->X6_VAR) .And. Empty(SX6->X6_FIL)
		If !Empty(SX6->X6_CONTEUD)
			cSubTrib	+=	"/"+AllTrim (SX6->X6_CONTEUD)
		EndIf
		SX6->(DbSkip ())
	EndDo
EndIf

If !Empty(cSubTrib) .And. !lDifal
	Return AllTrim(cSubTrib) 
EndIf

If AliasInDic("CLO")
	If !Empty(cUF)
		If CLO->(DbSeek(xFilial("CLO")+cUF)) .and. !Empty(CLO->CLO_INSCR)
			Return AllTrim(CLO->CLO_INSCR) 
		Endif
	Else
		CLO->(DbSeek(xFilial("CLO")))
		cSubTrib += "/"
		Do While !CLO->(EOF()) .And. CLO->CLO_FILIAL == xFilial("CLO")
			If !Empty(CLO->CLO_INSCR)
				cSubTrib += CLO->CLO_UF+AllTrim(CLO->CLO_INSCR)+"/"
			Endif
			CLO->(DbSkip())			
		Enddo		
	Endif	
Endif	

//Tratamento para Estados que possuem IE exclusiva para Difal e no se aplicam ao ST
If lDifal 
	If AliasInDic("F0L")
		If !Empty(cUF)
			If F0L->(DbSeek(xFilial("F0L")+cUF)) .and. !Empty(F0L->F0L_INSCR)
				Return AllTrim(F0L->F0L_INSCR) 
			Endif
			If !(cUF $ cSubTrib)
				cSubTrib :=''
			Endif
			If At (cUf,cSubTrib) > 0
				nPosI	:=	At (cUf,cSubTrib)+2
				nPosF	:=	At ("/", SubStr (cSubTrib, nPosI))-1
				nPosF	:=	IIf(nPosF<=0,len(cSubTrib),nPosF)
				cSubTrib	:=	SubStr(cSubTrib,nPosI,nPosF)
			//Tratamento para clientes onde se utiliza o CNPJ ao invs da Inscrio Estadual para o recolhimento do DIFAL
			ElseIf lF0LCgc .AND. !Empty(F0L->F0L_CGC)
				cSubTrib := "ISENTO"
			Endif
		Else
			F0L->(DbSeek(xFilial("F0L")))
			Do While !F0L->(EOF()) .And. F0L->F0L_FILIAL == xFilial("F0L")
				If !Empty(F0L->F0L_INSCR)
					cSubTrib += F0L->F0L_UF+AllTrim(F0L->F0L_INSCR)+"/"
				//Tratamento para clientes onde se utiliza o CNPJ ao invs da Inscrio Estadual para o recolhimento do DIFAL
				ElseIf lF0LCgc .AND. !Empty(F0L->F0L_CGC)
					cSubTrib += F0L->F0L_UF+AllTrim(F0L->F0L_CGC)+"CNPJ/"
				Endif
				F0L->(DbSkip())
			Enddo			
		Endif	
	Endif	
Endif
Iif(cSubTrib == "" .Or. At('/', cSubTrib) = 0,cSubTrib,cSubTrib := Left(cSubTrib,Len(cSubTrib)-1))
Return AllTrim(cSubTrib) 

//-------------------------------------------------------------------
/*/{Protheus.doc} RetSIAFI
Funcao que retorna o codigo do SIAFI.

@author Simone Oliveira
@since 21.05.2015
@version 11.80

@param  cUf			Sigla da UF do cliente/fornecedor
@param  cCodMun		Cdigo do Municipio (A1_COD_MUN / A2_COD_MUN )

@return cCodSiaf	Codigo do SIAFI

/*/
//-------------------------------------------------------------------
Function RetSIAFI(cUf,cCodMun)

Local cCodSiaf	:= ""


Default cUf		:= ""
Default cCodMun	:= ""

If !Empty(cUf) .And. !Empty(cCodMun)

	CC2->(DbSetOrder(1))
	CC2->(DBSeek(xFilial("CC2")+cUf+cCodMun))
	IF CC2->(FieldPos("CC2_CDSIAF"))>0
		cCodSiaf:= CC2->CC2_CDSIAF
	EndIf
EndIf

Return cCodSiaf

//-------------------------------------------------------------------
/*/{Protheus.doc} xFisRetFCP

Componente para retornar a aliquota/valor de FECP sem a majoracao.
Deve ser utilizada no periodo de transicao entre os layouts 3.0 e
4.0 da NF-e.

@author joao.pellegrini
@since 15/09/2017
@version 1.0

@version 2.0
@since 20/11/2019
Adicionado tratamento para retornar os valores do ICMS e FECP quando possui diferimento total e parcial para RJ

/*/
//-------------------------------------------------------------------
Function xFisRetFCP(cVerNFE, cAls, cCampo, cArred, nCasasDec)

Local lCpoOk 	 := .F.
Local nRet 		 := 0 
Local cCst 		 := alltrim(iif((cAls)->(FieldPos("CD2_CST")) > 0, (cAls)->CD2_CST,iif((cAls)->(FieldPos("FT_CLASFIS")) > 0, SUBSTR((cAls)->FT_CLASFIS,2,2),"")))
Local cMV_ESTADO := alltrim(GetNewPar("MV_ESTADO",""))
Local lDifFCPRJ	 := iif(cMV_ESTADO=="RJ" .and. cCst=="51",.T.,.F.) //Diferimento com FECP para RJ
Local cArredICMS := iif( GetNewPar("MV_RNDICM",.F.),"2","3") //2 - Arredonda, 3-Trunca
Local cMvPstFCP  := alltrim(GetNewPar("MV_PSTFCP", ""))
Local nValAux1	 := 0 //Valor auxiliar 1
Local nValAux2	 := 0 //Valor auxiliar 2
Local nQtdCsDec	 := 2 //Quantidade de casas decimais

Default cArred	 := "0" // 1 - No arredonda, 2 - Arredonda, 3 - Trunca 
Default nCasasDec:=  0 //Quantidade de casas decimais

if valtype(cArred)=="N" //Tratamento caso tenha sido passado numrico para a varivel caracter
	cArred := cvaltochar(cArred)
endif

if valtype(nCasasDec)=="C" //Tratamento caso tenha sido passado caracter para a varivel numrica
	if IsDigit(nCasasDec)
		nCasasDec := val(nCasasDec) 
	endif
endif

nQtdCsDec	:= iif(nCasasDec>0,nCasasDec,2)
cArredICMS	:= iif(!empty(cArred) .and. cArred $ "123",cArred,cArredICMS)

If cVerNFE == "4.0"

	Do Case

		Case cCampo == "CD2_ALIQ"

			if lDifFCPRJ .and. (cAls)->(FieldPos("CD2_ALIQ")) > 0 .and. (cAls)->(FieldPos("CD2_PICMDF")) > 0 .and. (cAls)->(FieldPos("CD2_PFCP")) > 0;
				.and. (cAls)->CD2_ALIQ > 0 .and. (cAls)->CD2_PFCP > 0 .and. (cAls)->CD2_PICMDF == 100//100% DE DIFERIMENTO GRAVA O VALOR DO ICMS SEM O FECP AGLUTINADO
				If AjustaFecp()
					nRet := Max((cAls)->CD2_ALIQ - (cAls)->CD2_PFCP, 0)
				else
					nRet := Max((cAls)->CD2_ALIQ,0)
				EndIf
			elseIf (cAls)->(FieldPos("CD2_FCPAJT")) > 0 .and. !Empty((cAls)->CD2_FCPAJT) .and. (cAls)->CD2_FCPAJT == "2"
				nRet := Max((cAls)->CD2_ALIQ, 0)
			else
				lCpoOk := (cAls)->(FieldPos("CD2_PFCP")) > 0 .And. (cAls)->(FieldPos("CD2_VFCP")) > 0 .And. (cAls)->CD2_PFCP > 0 .And. (cAls)->CD2_VFCP > 0
				nRet := IIf(lCpoOk, Max((cAls)->CD2_ALIQ - (cAls)->CD2_PFCP, 0), (cAls)->CD2_ALIQ)
			endif

		Case cCampo == "CD2_VLTRIB" //Valor

			if lDifFCPRJ .and. (cAls)->(FieldPos("CD2_BC")) > 0 .and. (cAls)->(FieldPos("CD2_ALIQ")) > 0 .and. (cAls)->(FieldPos("CD2_PFCP")) > 0 .and. (cAls)->(FieldPos("CD2_PICMDF")) > 0;
				.and. (cAls)->CD2_BC > 0 .and. (cAls)->CD2_ALIQ > 0 .and. (cAls)->CD2_PFCP > 0 .and. (cAls)->CD2_PICMDF > 0

				nValAux1 := (((cAls)-> CD2_BC ) * (( (cAls)-> CD2_ALIQ - (cAls)-> CD2_PFCP ) )/100)
				nValAux2 := nValAux1 * ((cAls)-> CD2_PICMDF/100)
				nRet	 := ArredSOUN(cArredICMS,Max(nValAux1 - nValAux2,0),nQtdCsDec)

			elseIf (cAls)->(FieldPos("CD2_FCPAJT")) > 0 .and. !Empty((cAls)->CD2_FCPAJT) .and. (cAls)->CD2_FCPAJT == "2"
				nRet := Max((cAls)->CD2_VLTRIB, 0)

			else
				lCpoOk := (cAls)->(FieldPos("CD2_PFCP")) > 0 .And. (cAls)->(FieldPos("CD2_VFCP")) > 0 .And. (cAls)->CD2_PFCP > 0 .And. (cAls)->CD2_VFCP > 0
				nRet := IIf(lCpoOk, Max((cAls)->CD2_VLTRIB - (cAls)->CD2_VFCP, 0), (cAls)->CD2_VLTRIB)
			endif

		Case cCampo == "CD2_BFCP" //Base do FECP

			if lDifFCPRJ .and. (cAls)->(FieldPos("CD2_BFCP")) > 0 .and. (cAls)->(FieldPos("CD2_PICMDF")) > 0;
				.and. (cAls)->CD2_BFCP > 0 .and. (cAls)->CD2_PICMDF > 0

				nValAux1 := (cAls)->CD2_BFCP

				If (cAls)-> CD2_PICMDF == 100 .AND. cMV_ESTADO $ "RJ"
				//tratativa criada com base no parecer da consultoria tributria
				//apenas para emissao de notas fiscais com diferimento 100% no RJ
				//https://tdn.totvs.com/pages/releaseview.action?pageId=516211871
				//consultar a sessao 3.6 do parecer
					nValAux2 := 0
				Else
					nValAux2 := (cAls)->CD2_BFCP * ((cAls)-> CD2_PICMDF/100)
				EndIf
				nRet	 := ArredSOUN(cArredICMS,Max(nValAux1 - nValAux2,0),nQtdCsDec)
			else
				nRet := (cAls)->&cCampo
			endif

		Case cCampo == "CD2_PFCP" //% do FECP

			if lDifFCPRJ .and. (cAls)->(FieldPos("CD2_PFCP")) > 0 .and. (cAls)->(FieldPos("CD2_PICMDF")) > 0 ;
				.and. (cAls)->CD2_PFCP > 0 .and. (cAls)->CD2_PICMDF == 100
				If (cAls)-> CD2_PICMDF == 100 .AND. cMV_ESTADO $ "RJ"
				//tratativa criada com base no parecer da consultoria tributria
				//apenas para emissao de notas fiscais com diferimento 100% no RJ
				//https://tdn.totvs.com/pages/releaseview.action?pageId=516211871
				//consultar a sessao 3.6 do parecer
					nRet := (cAls)->&cCampo
				Else
					nRet := 0
				EndIf
			else
				nRet := (cAls)->&cCampo
			endif

		Case cCampo == "CD2_VFCP" //Valor do FECP

			if lDifFCPRJ .and. (cAls)->(FieldPos("CD2_VFCP")) > 0 .and. (cAls)->(FieldPos("CD2_PICMDF")) > 0 ;
				.and. (cAls)->CD2_VFCP > 0 .and. (cAls)->CD2_PICMDF > 0

				nValAux1 := (cAls)->CD2_VFCP
				nValAux2 := (cAls)->CD2_VFCP * ((cAls)-> CD2_PICMDF/100)
				nRet	 := ArredSOUN(cArredICMS,Max(nValAux1 - nValAux2,0),nQtdCsDec)

			else
				nRet := (cAls)->&cCampo
			endif

		Case cCampo == "FT_VOPDIF"

			if lDifFCPRJ .and. (cAls)->(FieldPos("FT_VOPDIF")) > 0;
				.and. (cAls)->FT_VOPDIF > 0
				if CD2->CD2_PICMDF == 100//100% DE DIFERIMENTO GRAVA O VALOR DO ICMS SEM O FECP AGLUTINADO
					If AjustaFecp()
						nRet := Max((cAls)->FT_VOPDIF - CD2->CD2_VFCP, 0)
					else
						nRet := (cAls)->FT_VOPDIF
					EndIf
				else
					lCpoOk := (cAls)->(FieldPos("FT_ALQFECP")) > 0 .And. CD2->(FieldPos("CD2_VFCP")) > 0 .And. (cAls)->FT_ALQFECP > 0 .And. CD2->CD2_VFCP > 0
					nRet := IIf(lCpoOk, Max((cAls)->FT_VOPDIF - CD2->CD2_VFCP, 0), (cAls)->FT_VOPDIF)
				endif

			else
				lCpoOk := (cAls)->(FieldPos("FT_ALQFECP")) > 0 .And. (cAls)->(FieldPos("FT_VALFECP")) > 0 .And. (cAls)->FT_ALQFECP > 0 .And. (cAls)->FT_VALFECP > 0
				nRet := IIf(lCpoOk, Max((cAls)->FT_VOPDIF - (cAls)->FT_VALFECP, 0), (cAls)->FT_VOPDIF)
			endif

		Case cCampo == "FT_VSTANT" // Retira o valor do FECP ST do clculo do ICMS ST
			lCpoOk := (cAls)->(FieldPos("FT_VFCANTS")) > 0 .And. (cAls)->(FieldPos("FT_PFCANTS")) > 0 .And. (cAls)->FT_VFCANTS > 0 .And. (cAls)->FT_PFCANTS > 0
			nRet := IIf(lCpoOk, Max((cAls)->FT_VSTANT - (cAls)->FT_VFCANTS, 0), (cAls)->FT_VSTANT)
		Case cCampo == "FT_PSTANT" .And. !( (cAls)->(FieldPos("FT_ESTADO")) > 0 .And. Alltrim((cAls)->FT_ESTADO) == 'RJ' .And. cCst == '60' .And. Alltrim((cAls)->FT_ESTADO) != cMV_ESTADO ) // Retira a alquota do FECP ST da alquota do ICMS ST
			lCpoOk := (cAls)->(FieldPos("FT_PFCANTS")) > 0 .And. (cAls)->FT_PFCANTS > 0
			If Alltrim((cAls)->FT_ESTADO)$cMvPstFCP
				nRet := (cAls)->FT_PSTANT
			Else
				nRet := IIf(lCpoOk, Max((cAls)->FT_PSTANT - (cAls)->FT_PFCANTS, 0), (cAls)->FT_PSTANT)
			Endif
		Case cCampo == "FT_ICMSDIF"
			lCpoOk := (cAls)->(FieldPos("FT_ICMSDIF")) > 0 .And. (cAls)->FT_ICMSDIF > 0
			If lDifFCPRJ .And. lCpoOk .and. CD2->CD2_PICMDF == 100; // Tratativa para ISSUE https://jiraproducao.totvs.com.br/browse/DSERFISE-3227
				//100% DE DIFERIMENTO GRAVA O VALOR DO ICMS SEM O FECP AGLUTINADO
				If AjustaFecp()
					nRet := Max((cAls)->FT_ICMSDIF - CD2->CD2_VFCP, 0)
				else
					nRet := (cAls)->FT_ICMSDIF
				EndIf
			Else
				nRet := IIf(lCpoOk, Max((cAls)->FT_ICMSDIF - IIf(CD2->(FieldPos("CD2_VFCPDI"))>0 .and. CD2->CD2_VFCPDI>0,CD2->CD2_VFCPDI,0), 0), (cAls)->FT_ICMSDIF)
			EndIf

		Case cCampo == "FT_VALICM"

			lCpoOk := (cAls)->(FieldPos("FT_VALICM")) > 0 .And. (cAls)->FT_VALICM > 0
			if lDifFCPRJ
				nRet := IIf(lCpoOk, Max((cAls)->FT_VALICM - IIf(CD2->(FieldPos("CD2_VFCPEF"))>0 .and. CD2->CD2_VFCPEF>0,CD2->CD2_VFCPEF,0),0), (cAls)->FT_VALICM)
			else
				nRet := IIf(lCpoOk, Max((cAls)->FT_VALICM - IIf(CD2->(FieldPos("CD2_VFCPDI"))>0 .and. CD2->CD2_VFCPDI>0,CD2->CD2_VFCPDI,0), 0), (cAls)->FT_VALICM)
			endIf

		Otherwise

			nRet := (cAls)->&cCampo

	EndCase
	
Else

	nRet := (cAls)->&cCampo

EndIf 

Return nRet

//-----------------------------------------------------------------------
/*/{Protheus.doc} getRandom
Funcao responsavel por retornar numeros randomicos a cada chamada.

Chamada das funcoes Pai
NFEIDE / U_XMLNFESEF		-> NfeSefaz.prw
U_XMLMDFESEF / MDFEREMES	-> SpedMdfe.prw
MDFEIDE						-> MDeSefaz.prw

@return 	lRet	Fonte que chamou podera obter o retorno desta funcao.
			cRet	Conteudo do numero randomico.

@author Douglas Parreja
@since 03/02/2019
@version 12.1.23
/*/
//-----------------------------------------------------------------------
static function getRandom()
	
	local lRet	:= .F.
	local cRet	:= ""
	Local cFunction := 'Random'

	if ( alltrim(upper(procName(1))) == "GCIFRA" )
		if ( alltrim(upper(procName(2))) == "INVERTE" )
			if ( (alltrim(upper(procName(3))) == "NFEIDE") .or. (alltrim(upper(procName(3))) == "MDFEIDE") .or. (alltrim(upper(procName(3))) == "PROCIDE"))  
				if ( (alltrim(upper(procName(4))) == "U_XMLNFESEF") .or. (alltrim(upper(procName(4))) == "U_XMLMDFESEF");
					 .or. (alltrim(upper(procName(4))) == "XMLNFESEF") .or. (alltrim(upper(procName(4))) == "XMLMDFESEF");
					 .or. (alltrim(upper(procName(4))) == "PROCESSXML" .and. (alltrim(upper(procName(5))) == "NFCOMSEFAZ" .or. alltrim(upper(procName(5))) == "U_NFCOMSEFAZ")) )
					lRet := .T.
				endif
			elseif (alltrim(upper(procName(3))) == "MDFEREMES")
				lRet := .T.				
			endif
		endif
	endif
	if ( lRet ) 
		cRet := iif(findFunction(cFunction ),alltrim(str(&cFunction.( 10000000, 99999999 ))),alltrim(str(Randomize( 10000000, 99999999 ))))
	endif

return { lRet, cRet }

//-----------------------------------------------------------------------
/*/{Protheus.doc} validRandom
Funcao responsavel por validar o array no retorno da funcao getRandom.

@return 	lRet	Esta Ok ou nao para continuar o processo.
			
@author Douglas Parreja
@since 03/02/2019
@version 12.1.23
/*/
//-----------------------------------------------------------------------
static function validRandom()
	local lRet := .F.
	if ( type("aValid") <> "U" )
		if ( type("aValid") == "A" )
			if ( len(aValid) > 0 )
				if ( type("aValid[1]") == "L" )
					if ( len(aValid) > 1 )
						if ( type("aValid[2]") == "C" )
							if ( aValid[1] )
								lRet := .T.
							endif
						endif
					endif
				endif
			endif
		endif
	endif
return ( lRet )

//-----------------------------------------------------------------------
/*/{Protheus.doc} ArredSOUN
Funcao para arredondar ou no arredondar de acordo com os parmetros passados.

Parametros:
cArred - 1 - No arredonda, 2 - Arredonda, 3 - Trunca 
nValor - Valor a ser arredondado
nQtd   - Quantidade de casas decimais para o arredondamento
			
@author Matheus Massarotto
@since 19/11/2019
@version 1.0
/*/
//-----------------------------------------------------------------------
Static Function ArredSOUN(cArred,nValor,nQtd)
Local nRet		:= 0

Default cArred	:= "1"
Default nValor	:= 0
Default nQtd	:= 0

if cArred == "2"
	nRet:= ROUND(nValor,nQtd)
elseif cArred == "3"
	nRet:= NOROUND(nValor,nQtd)
else
	nRet:=nValor
endif

Return(nRet)

//-----------------------------------------------------------------------
/*/{Protheus.doc} xFisF_LT
Funcao para retornar o valor do imposto de acordo com base, aliquota e opo passados

Parametros:
nVal -> valor do tributo
nBase -> base de calculo do tributo
nAliq1 -> Aliquota 1
nAliq2 -> Aliquota 2
cOpt - Opo baseado no parmetro MV_FISALCT

@author Matheus Massarotto
@since 25/03/2020
@version 2.0
@lastUpdate 24/11/20023
@updateBy anedino.santos
/*/
//-----------------------------------------------------------------------


Function xFisF_LT(nVal, nBase, nAliq1, nAliq2, cOpt)
Local nValor    := nVal
Local nAliquota := nAliq1

Default nVal    := 0
Default nBase   := 0
Default nAliq1  := 0
Default nAliq2  := 0
Default cOpt    := ""

	if cOpt=="1" //Soma a aliquota 1 e 2 e multiplica pela base
		nAliquota	:= nAliq1+nAliq2 //Somo as duas aliquotas utilizadas para devolver no retorno.
		nValor	:= (nAliquota/100) * nBase
	elseif cOpt=="2" //Usa somente a aliquota 2 e multiplica pela base
		nValor	:= ( nAliq2 /100) * nBase
		nAliquota	:= nAliq2
	endif

Return({nAliquota,nValor})

/*/{Protheus.doc} FisPath
	Abre a tela de seleo do diretorio no F3 do campo
	@type  Function
	@author Alexandre.Esteves
	@since 15/04/2024
	@version 12.1.2410
	@param Nil
	@return cFisArq, caractere, Retorna o caminho da pasta do servidor
/*/
Function FisPath()
Local cType    := "."

cFisArq   := cGetFile(cType, STR0046 ,,,,GETF_NETWORKDRIVE) // "Selecione arquivo "

Return !Empty(cFisArq)

/*/{Protheus.doc} FisArq
	Retorna o caminho da pasta que  utiliado na consulta padro
	@type  Function
	@author Alexandre.Esteves
	@since 15/04/2024
	@version 12.1.2410
	@param Nil
	@returnc FisArq, caractere, Retorna o caminho da pasta do servidor
	@example
	(examples)
	@see (links_or_references)
/*/
Function FisArq()
	
Return (cFisArq)

/*/{Protheus.doc} DlgRelVer
	Apresenta uma tela informando que a rotina sera descontinuada
	@type  Function
	@author Djalma Mathias
	@since 02/07/2024
	@version 1.0
	@param cDescrFunc, caracter, descricaod a rotina e nome da rotina que substitui a rotina descontinuada
	@param cTitFun, caracter, descrio do titulo da rotina que est sendo discontinuada
	@param cEndWeb, caracter, endere?o http referente a rotina que esta sendo descontinuada
/*/

Function DlgRelVer(cDescrFunc as character,  cTitFun as character, cEndWeb as character) 
local oSay1    as object
local oSay2    as object
local oSay3    as object
local oSay4    as object
local oSay5    as object
local oSay6    as object
local oSay7    as object
local oModal   as object
Local cMsg1    as character
Local cMsg2    as character  
Local cMsg3    as character
Local cMsg4    as character
Local cMsg5    as character
Local cMsg6    as character
Local cMsg7    as character
Local cRelease as character
Local cEndInst := "https://tdn.totvs.com/display/public/framework/Smart+View"

cRelease 	:= GetRPORelease() 

oModal := FWDialogModal():New() 
oModal:SetCloseButton( .F. )
oModal:SetEscClose( .F. )
oModal:setTitle(STR0047) //  "Comunicado Ciclo de Vida de Sofware - TOTVS Linha Protheus"

//define a altura e largura da janela em pixel 
oModal:setSize(180, 250) 

oModal:createDialog()

oModal:AddButton( "Confirma", {||oModal:DeActivate()}, STR0048, , .T., .F., .T., ) // "Confirma"

oContainer := TPanel():New( ,,, oModal:getPanelMain() )  
oContainer:Align := CONTROL_ALIGN_ALLCLIENT  


cMsg1 := i18n(STR0049) // "Prezado Cliente, "
oSay1 := TSay():New( 10,10,{||cMsg1 },oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

cMsg2 := i18n(STR0050+Alltrim(cDescrFunc)+STR0051 ) // "Comunicamos que esta rotina (" # ") ser descontinuada a partir de 31/10/2024, dessa forma no ser realizada manuteno ou evoluo neste programa."
oSay2 := TSay():New( 30,10,{||cMsg2 },oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

cMsg3 := STR0052 // "Para realizar a conferncia de dados e valores, esto disponveis novos relatrios no menu Livros Fiscais/Consultas/Smartview."
oSay3 := TSay():New(50,10,{||cMsg3},oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

cMsg4 := STR0053 // "Acesse a documentao e conhea todos os relatrios disponveis: "
oSay4 := TSay():New( 70,10,{||cMsg4 },oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

If !Empty(cEndWeb)  
	cMsg5 := "<b><a target='_blank' href='"+cEndWeb+"'> "
	cMsg5 += Alltrim(STR0054) // "clique aqui"
	cMsg5 += " </a></b>."
	cMsg5 += "<span style='font-family: Verdana; font-size: 12px; color: #565759;' >" + ' ' +"</span>"
	oSay5 := TSay():New(80,10,{||cMsg5},oContainer,,,,,,.T.,,,220,20,,,,,,.T.)
	oSay5:bLClicked := {|| MsgRun( STR0055, STR0056,{|| ShellExecute(STR0057,cEndWeb,"","",1) } ) } // "Abrindo o link... Aguarde..." # "URL" # "open" 
EndIf

cMsg6 := STR0058 // "Dvidas sobre como utilizar o Smartivew? Acesse: " 
oSay6 := TSay():New( 100,10,{||cMsg6 },oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

cMsg7 := "<b><a target='_blank' href='"+cEndInst+"'> "
cMsg7 += cEndInst 
cMsg7 += " </a></b>."
cMsg7 += "<span style='font-family: Verdana; font-size: 12px; color: #565759;' >" + ' ' +"</span>"
oSay7 := TSay():New(110,10,{||cMsg7},oContainer,,,,,,.T.,,,220,20,,,,,,.T.)
oSay7:bLClicked := {|| MsgRun( STR0055, STR0056,{|| ShellExecute(STR0057,cEndInst,"","",1) } ) } // "Abrindo o link... Aguarde..." # "URL" # "open" 

oModal:Activate() 

Freeobj(oSay1);oSay1 := nil;Fwfreevar(oSay1)
Freeobj(oSay2);oSay2 := nil;Fwfreevar(oSay2)
Freeobj(oSay3);oSay3 := nil;Fwfreevar(oSay3)
Freeobj(oSay4);oSay4 := nil;Fwfreevar(oSay4)
Freeobj(oSay5);oSay5 := nil;Fwfreevar(oSay5)
Freeobj(oSay6);oSay6 := nil;Fwfreevar(oSay6)
Freeobj(oSay7);oSay7 := nil;Fwfreevar(oSay7)
Freeobj(oModal);oModal := nil;Fwfreevar(oModal)

Return nil   

/*/{Protheus.doc} RetIPIRastro
	Retorna a base do IPI na revenda de produto recondicionado
	@type  Function
	@author Djalma Mathias
	@since 02/08/2024
	@version 1.0
	@param 
/*/

Function RetIPIRastro(cNumLote,cLoteCli,cCodProd,nQuant)

Local cArmazem 		:= ''
Local aRetRastro	:= {}
Local cNfiscal		:= ''
Local cSerie		:= ''
Local cCliFor		:= ''
Local cLoja			:= ''
Local cItem			:= ''
Local nBaseIPI		:= 0
Local nILote		:= 0	
Local aAreaAnt 		:= GetArea()

dbSelectArea("SB1")
dbSetOrder(1)
If MsSeek(xFilial("SB1")+cCodProd)
	cArmazem:= SB1->B1_LOCPAD 
EndIf

If Len(aRetRastro := RastroToNF(cLoteCli,cNumLote,cCodProd,cArmazem)) > 0 

	For nILote	:= 1 To Len(aRetRastro)

		If AllTrim(cNumLote)==AllTrim(aRetRastro[nILote][8])

			cNfiscal	:= aRetRastro[nILote][1]
			cSerie		:= aRetRastro[nILote][2] 
			cCliFor		:= aRetRastro[nILote][3]
			cLoja		:= aRetRastro[nILote][4]
			cItem		:= aRetRastro[nILote][5] 
		
		EndIf

	Next nILote     

	SD1->(DBSETORDER(1)) 
	IF SD1->(MSSEEK(XFILIAL('SD1')+cNfiscal+cSerie+cCliFor+cLoja+cCodProd+cItem)) 
			nBaseIPI   := (SD1->D1_BASEIPI / SD1->D1_QUANT) * nQuant
	ENDIF  

EndIf   

RestArea(aAreaAnt)

Return(nBaseIPI) 


/*/{Protheus.doc} AjustaFecp
	Analisa contedo do campo Ajusta FCP (CD2_FCPAJT), para deciso
	@type  Function
	@author Rhuan Carvalho
	@since 12/11/2024
	@version 1.0
	@param cDescrFunc, caracter, descricao da rotina e nome da rotina
	@param cTitFun, caracter, descrio do titulo da rotina
	@param cEndWeb, caracter, endereo http do TDN 
/*/
Function AjustaFecp()
	local lRet := .F.
	If CD2->(FieldPos("CD2_FCPAJT")) > 0
		If CD2->CD2_FCPAJT == "1"
			lRet := .T.
		EndIf
	EndIF
Return lRet
