#INCLUDE 'msobject.ch'
#INCLUDE 'tlpp-core.th'
#INCLUDE 'tlpp-rest.th'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.fis.FinancialSettlements_par.ch'

//-------------------------------------------------------------------------------
/*{Protheus.doc} FinancialSettlements_PARTReportsBusinessObject
Classe para criação do Objeto de Negocio de fiscal para SmartView
@author Leonardo Pereira
@since 24/08/2023
@version 1.0
*/ 
//-------------------------------------------------------------------------------
namespace custom.fiscal.FinancialSettlements_PAR.integratedprovider

// Annotation
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGAFIS', tables='SA1,SA2,SF1,SF2,SF3', name='Libro Fiscal de Ventas y Compras Paraguay', country='PAR', initialRelease='12.1.2410', customTables='SF1,SF2,SF3' )
class FinancialSettlements_PARTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} NEW
Método de instância da classe: Define a lista de importações que serão acessados no objeto de negocios
@return object: self
@author Leonardo Pereira
@since 24/08/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method new() class FinancialSettlements_PARTReportsBusinessObject

	Local aCpos as array

	aCpos := { }

	_Super:new()

	// Define o nome do Objeto de Negócio
	self:setDisplayName( STR0001 ) // 'Libro Fiscal de Ventas y Compras Paraguay'

	// Define a descrição do Objeto de Negócio
	self:setDescription( STR0001 ) // 'Libro Fiscal de Ventas y Compras Paraguay'

	// Define a Área
	self:appendArea( STR0025 ) // 'Fiscal' - Libros Fiscales

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatóri
	If !self:setPergunte( 'FISSV502' ) // Indica o pergunte que será utilizado
		IIf( !self:setErrorStatus( 400, STR0002, STR0003 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0004,,, ),'') //'Sin Preguntas' //'¡Verifique el grupo de preguntas dado!' //'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0005,,, ) /*'Grupo de preguntas no encontrado!'*/
	EndIf

	// Adiciona os campos virtuais/calculados
	aAdd( aCpos, { 'F3_ITEM'   , STR0006, 'string', STR0006 } ) // 'Item'
	aAdd( aCpos, { 'F3_TIPNOTA', STR0007, 'string', STR0008 } ) // 'Tipo Nota' ## 'Tipo'
	aAdd( aCpos, { 'F1_VALBRUT', STR0009, 'number', STR0010 } ) // 'Importe Total Facturado con IVA' ## 'Facturado con IVA'
	aAdd( aCpos, { 'F3_TOTIVA1', STR0011, 'number', STR0012 } ) // 'Importe Total Facturado sin IVA 10%'  ##  'Facturado sin IVA 10%'
	aAdd( aCpos, { 'F3_TOTIVA2', STR0013, 'number', STR0014 } ) // 'Importe Total Facturado sin IVA 5%' ## 'Facturado sin IVA 5%'
	aAdd( aCpos, { 'F3_CRED01' , STR0015, 'number', STR0015 } ) // 'Credito Fiscal 10%'
	aAdd( aCpos, { 'F3_CRED02' , STR0016, 'number', STR0016 } ) // 'Credito Fiscal 5%'
	aAdd( aCpos, { 'F3_EXENTAS', STR0017, 'number', STR0018 } ) // 'Importes No Gravados o Exentos' ## 'Exentos'
	aAdd( aCpos, { 'A2_NOME'   , STR0019, 'string', STR0019 } ) // 'Razon Social'
	aAdd( aCpos, { 'A2_CGC'    , STR0020, 'string', STR0021 } ) // 'R.U.C. del Proveedor/Cliente' ##  'R.U.C'
	aAdd( aCpos, { 'SV_RUC'    , STR0022, 'string', STR0022 } ) // 'R.U.C. Rep. Legal'
	aAdd( aCpos, { 'SV_DVR'    , STR0023, 'string', STR0023 } ) // 'D.V. Rep. Legal'
	aAdd( aCpos, { 'SV_NOM'    , STR0024, 'string', STR0024 } ) // 'Nome Rep. Legal'

	// Define os campos que serão retornados no objeto de negocios
	self:aFields := { "F3_ITEM", "F3_FILIAL", "F3_EMISSAO", "A2_CGC", "A2_NOME", "F3_ENTRADA", "F3_CLIEFOR", "F3_LOJA", "F3_TIPO", "F3_NFISCAL", "F3_SERIE", "F1_NUMDES", "F3_TIPNOTA", "F1_VALBRUT", "F3_TOTIVA1", "F3_CRED01", "F3_TOTIVA2", "F3_CRED02", "F3_EXENTAS", "F3_OBSERV", "SV_RUC", "SV_DVR", "SV_NOM" }

	self:aStruct := getStrutObj( self:aFields, aCpos )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura de campos 
@return object: self:oSchema 
@author Laura Medina
@since 20/04/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema( ) as object class FinancialSettlements_PARTReportsBusinessObject

	Local n1 as numeric
	// Adiciona as propriedades dos campos que serão retornados para o SMARTVIEW
	For n1 := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[n1][1], self:aStruct[n1][2], self:aStruct[n1][3], self:aStruct[n1][4], self:aStruct[n1][5] )
	Next

Return( self:oSchema )


//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os datos do objeto de negócios
@param nPage, numérico, indica a pagina atual
@param oFilter, objeto, contém o filtro do SmartView
@return object: self:oData
@author Leonardo Pereira
@since 24/08/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object) as object class FinancialSettlements_PARTReportsBusinessObject

	// Declaracao de variaveis
	Local jParams as json
	Local jItems as json

	Local cQuery as character
	Local cAliasA := GetNextAlias() as character
	Local cEspecie as character
	Local cCposSF3 as character
	Local cNomCliFor as character
	Local cFiltro as character

	Local nPos as numeric
	Local nPosExp as numeric
	Local nX as numeric
	Local nSinal as numeric
	Local nDecs as numeric
	Local nItem as numeric
	Local n1 as numeric
	Local nLivroI as numeric
	Local nListar as numeric

	Local aPDFields as array
	Local aFiltro as array
	Local aParam as array
	Local aStruSF3 as array
	Local aTotTrib as array
	Local aCustomFields as array

	Local lObfuscated as logical
	Local lCpo as logical

	Local oQueryA as object

	cEspecie 	:= ''
	cCposSF3 	:= ''
	cNomCliFor  := ''
	cCpoSF1P	:= ''
	cCpoSF3P	:= ''
	cCpoSF2P	:= ''
	cFiltro := ''

	nPos    := 0
	nCount  := 0
	nPosExp := 0
	nItem   := 0
	nDecs   := MsDecimais( 1 )
	nSinal  := 1

	aPDFields := { }
	aFiltro   := { }
	aParam    := { }
	aStruSF3  := { }
	aTotTrib  := { }

	lObfuscated := .F.
	lCpo := .T.

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	If oFilter:hasFilter()
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )

		aFiltro := getParamToArr( cFiltro )

		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )
	EndIf

	nLivroI := IIf( ( ValType( jParams['MV_PAR03'][1] ) == 'C' ), Val( jParams['MV_PAR03'][1] ), jParams['MV_PAR03'][1] )
	nListar := IIf( ( ValType( jParams['MV_PAR04'][1] ) == 'C' ), Val( jParams['MV_PAR04'][1] ), jParams['MV_PAR04'][1] )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	// Coleta os campos personalizados pra agregar na query
	cCpoSF1P := getCpoUser( aCustomFields, 'SF1', 'F1', ',' )
	cCpoSF3P := getCpoUser( aCustomFields, 'SF3', 'F3', ',' )
	cCpoSF2P := getCpoUser( aCustomFields, 'SF2', 'F2', ',' )

	// SF3 - Campos de impostos
	aStruSF3 := SF3->( DbStruct( ) )
	For nX := 1 To Len( aStruSF3 )
		cCposSF3 += AllTrim( aStruSF3[nX, 1] ) + ", "
	Next

	// Realiza a montagem da QUERY que será enviada para o banco de dados
	cQuery := "SELECT " + cCposSF3 + cCpoSF3P + cCpoSF1P + cCpoSF2P + IIf( nLivroI == 1, " F1_TIPNOTA", "F2_TIPNOTA" ) + ", CASE WHEN " + IIf( nLivroI == 1, " F1_TIPNOTA", "F2_TIPNOTA" ) + " = '14' THEN CONCAT(LTRIM(RTRIM(F3_ESPECIE)), 'RESIMPLE') ELSE F3_ESPECIE END AS F3_TIPNOTA," + IIf( nLivroI == 1, "F1_NUMDES, F1_VALBRUT, A2_NOME, A2_CGC ", "' ' AS F1_NUMDES, F2_VALBRUT AS F1_VALBRUT, A1_NOME AS A2_NOME, A1_CGC AS A2_CGC " )
	cQuery += " FROM " + RetSQLName( "SF3" ) + " SF3 "

	If ( nLivroI == 1 )
		cQuery += "INNER JOIN " + RetSQLName( "SF1" ) + " SF1 "
		cQuery += "   ON SF1.F1_DOC = SF3.F3_NFISCAL "
		cQuery += "      AND SF1.F1_SERIE = SF3.F3_SERIE "
		cQuery += "      AND SF1.F1_FORNECE = SF3.F3_CLIEFOR "
		cQuery += "      AND SF1.D_E_L_E_T_ = ? "
		cQuery += "INNER JOIN " + RetSQLName( "SA2" ) + " SA2 "
		cQuery += "   ON SA2.A2_COD = SF3.F3_CLIEFOR "
		cQuery += "      AND SA2.A2_LOJA = SF3.F3_LOJA "
		cQuery += "      AND SA2.D_E_L_E_T_ = ? "
	Else
		cQuery += "INNER JOIN " + RetSQLName( "SF2" ) + " SF2 "
		cQuery += "   ON SF2.F2_DOC = SF3.F3_NFISCAL "
		cQuery += "      AND SF2.F2_SERIE = SF3.F3_SERIE "
		cQuery += "      AND SF2.F2_CLIENTE = SF3.F3_CLIEFOR "
		cQuery += "      AND SF2.D_E_L_E_T_ = ? "
		cQuery += "INNER JOIN " + RetSQLName( "SA1" ) + " SA1 "
		cQuery += "   ON SA1.A1_COD = SF3.F3_CLIEFOR "
		cQuery += "      AND SA1.A1_LOJA = SF3.F3_LOJA "
		cQuery += "      AND SA1.D_E_L_E_T_ = ? "
	EndIf

	cQuery += "WHERE SF3.F3_ENTRADA BETWEEN ? AND ? "

	If ( nListar == 1 )
		cQuery += "   AND SF3.F3_DTCANC = ? "
	ElseIf ( nListar == 2 )
		cQuery += "   AND SF3.F3_DTCANC <> ? "
	EndIf

	If ( nLivroI == 1 )
		cQuery += "   AND (SF3.F3_ESPECIE IN(?) OR (SF3.F3_ESPECIE = ? AND SF3.F3_TIPOMOV = ?))"
	Else
		cQuery += "   AND (SF3.F3_ESPECIE IN(?) OR (SF3.F3_ESPECIE = ? AND SF3.F3_TIPOMOV = ?))"
	EndIf

	cQuery += "   AND SF3.D_E_L_E_T_ = ? "

	// Agrega os filtros do SMARTVIEW na QUERY
	For nX := 1 To Len( aFiltro )
		cQuery += "   AND " + aFiltro[nX, 1] + " " + aFiltro[nX, 2] + " " + aFiltro[nX, 3] + "' "
	Next

	cQuery += "ORDER BY ? "

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	oQueryA := FwExecStatement():New()

	//Define a consulta e os parâmetros
	oQueryA:SetQuery( cQuery )

	oQueryA:SetString( 1, ' ' )
	oQueryA:SetString( 2, ' ' )
	oQueryA:SetString( 3, DtoS( FwDateTimeToLocal( jParams['MV_PAR01'][1] )[1] ) )
	oQueryA:SetString( 4, DtoS( FwDateTimeToLocal( jParams['MV_PAR02'][1] )[1] ) )
	
	nSeq := 4

	If ( nListar == 1 ) .Or. ( nListar == 2 )
		oQueryA:SetString( ( nSeq += 1 ), ' ' )	
	EndIf

	If ( nLivroI == 1 )
		oQueryA:SetIn( ( nSeq += 1 ), { 'NDP','NDE','NCI','NCC' } )
		oQueryA:SetString( ( nSeq += 1 ), 'NF ' )
		oQueryA:SetString( ( nSeq += 1 ), 'C' )
	Else
		oQueryA:SetIn( ( nSeq += 1 ), { 'NDC','NCP','NDI','NCE' } )
		oQueryA:SetString( ( nSeq += 1 ), 'NF ' )
		oQueryA:SetString( ( nSeq += 1 ), 'V' )
	EndIf

	oQueryA:SetString( ( nSeq += 1 ), ' ' )
	oQueryA:SetUnsafe( ( nSeq += 1 ), 'SF3.F3_FILIAL, SF3.F3_ENTRADA, SF3.F3_NFISCAL, SF3.F3_SERIE, SF3.F3_CLIEFOR, SF3.F3_LOJA, SF3.F3_ESPECIE' )

	// cria alias
	cQuery := oQueryA:getFixQuery( )

	oQueryA:OpenAlias( cAliasA )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	DbSelectArea( cAliasA )
	While !( cAliasA )->( EOF( ) )
		nItem++
		jItems := JsonObject():new()

		aArea := ( cAliasA )->( GetArea( ) )

		aTotTrib := CalcTribs( nSinal, cAliasA, jParams )

		( cAliasA )->( RestArea( aArea ) )

		For nX := 1 To Len( self:aStruct )
			If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
				jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
			ElseIf ( self:aStruct[nX][3] == 'date' )
				jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
			Else
				If ( ( cAliasA )->F3_TIPOMOV == "C" )
					If !Empty( ( cAliasA )->F3_DTCANC )
						If ( self:aStruct[nx][5] == 'F3_OBSERV' )
							If Empty( ( cAliasA )->F3_OBSERV )
								jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->F3_DTCANC ) )
							Else
								jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
							EndIf
							lCpo := .F.
						EndIf
					Else
						If ( self:aStruct[nx][5] == 'A2_CGC' )
							If Empty( ( cAliasA )->&( self:aStruct[nX][5] ) )
								jItems[self:aStruct[nX][1]] := "XXX"
								lCpo := .F.
							Else
								jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
								lCpo := .F.
							EndIf
						EndIf
					EndIf
				Else
					If !Empty( ( cAliasA )->F3_DTCANC )
						If ( self:aStruct[nx][5] == 'F3_OBSERV' )
							If Empty( ( cAliasA )->F3_OBSERV )
								jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->F3_DTCANC ) )
							Else
								jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
							EndIf
							lCpo := .F.
						EndIf
					Else
						If ( self:aStruct[nx][5] == 'A2_CGC' )
							If Empty( ( cAliasA )->&( self:aStruct[nX][5] ) )
								jItems[self:aStruct[nX][1]] := "XXX"
								lCpo := .F.
							Else
								jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
								lCpo := .F.
							EndIf
						EndIf

						If ( self:aStruct[nx][5] == 'A2_NOME' )
							If ( "77777701" $ ( cAliasA )->A2_CGC )
								jItems[self:aStruct[nX][1]] := "VENTAS A AGENTES DIPLOMATICOS"
								lCpo := .F.
							ElseIf ( "44444401" $ ( cAliasA )->A2_CGC )
								jItems[self:aStruct[nX][1]] := "IMPORTES CONSOLIDADOS"
								lCpo := .F.
							ElseIf ( "88888801" $ ( cAliasA )->A2_CGC )
								jItems[self:aStruct[nX][1]] := "CLIENTES DEL EXTERIOR"
								lCpo := .F.
							Else
								jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
								lCpo := .F.
							EndIf
						EndIf
					EndIf
				EndIf

				If lCpo
					If ( self:aStruct[nx][5] == 'F3_ITEM' )
						jItems[self:aStruct[nX][1]] := StrZero( nItem, 3 )
					ElseIf ( self:aStruct[nx][5] == 'F3_TOTIVA1' )
						jItems[self:aStruct[nX][1]] := Round( aTotTrib[1], nDecs )
					ElseIf ( self:aStruct[nx][5] == 'F3_TOTIVA2' )
						jItems[self:aStruct[nX][1]] := Round( aTotTrib[2], nDecs )
					ElseIf ( self:aStruct[nx][5] == 'F3_CRED01' )
						jItems[self:aStruct[nX][1]] := Round( aTotTrib[3], nDecs )
					ElseIf ( self:aStruct[nx][5] == 'F3_CRED02' )
						jItems[self:aStruct[nX][1]] := Round( aTotTrib[4], nDecs )
					ElseIf ( self:aStruct[nx][5] == 'F3_EXENTAS' )
						jItems[self:aStruct[nX][1]] := Round( aTotTrib[5], nDecs )
					ElseIf ( self:aStruct[nx][5] == 'F3_OBSERV' )
						If Empty( ( cAliasA )->F3_OBSERV )
							jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->F3_DTCANC ) )
						Else
							jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
						EndIf
					ElseIf ( self:aStruct[nx][5] == 'SV_RUC' )
						jItems[self:aStruct[nX][1]] := jParams['MV_PAR05'][1]
					ElseIf ( self:aStruct[nx][5] == 'SV_DVR' )
						jItems[self:aStruct[nX][1]] := jParams['MV_PAR06'][1]
					ElseIf ( self:aStruct[nx][5] == 'SV_NOM' )
						jItems[self:aStruct[nX][1]] := jParams['MV_PAR07'][1]
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
					EndIf
				EndIf
			EndIf
			lCpo := .T.
		Next

		// Inclui os dados no objeto paea retorno ao SmartView
		self:oData:appendData( jItems )

		( cAliasA )->( DbSkip( ) )
	End

	( cAliasA )->( DbCloseArea( ) )

	// fecha objeto
	If ( oQueryA <> Nil )
		oQueryA:Destroy( )
		oQueryA := Nil
		FwFreeObj( oQueryA )
	EndIf

Return( self:oData )

//-------------------------------------------------------------------------------
/*{Protheus.doc} CALCTRIBS
@description Rotina para calcular os tributos do documento
@param nSinal, numérico, indica a um fator de multiplicação para tornar o valor positivo, caso seja negativo
@param cAlias, caracter, nome da tabela temporaria gerada pela consulta SQL
@param jParams, json, Array com os parametros/perguntas do objeto de negocios
@return aRet: array com os calculos realziados para o documento.
@author Leonardo Pereira
@since 16/09/2023
@version 1.0
*/
//-------------------------------------------------------------------------------
Static Function CalcTribs( nSinal, cAliasA, jParams )

	Local aRet := { 0, 0, 0, 0, 0 }

	Local cQry := ''
	Local cAliasB := GetNextAlias( )

	Local nTOTIVA1 := 0
	Local nTOTIVA2 := 0
	Local nCRED01 := 0
	Local nCRED02 := 0
	Local nEXENTAS := 0
	Local nLivroI := 0

	Default nSinal := 1
	Default cAliasA := ''
	Default jParams := { }

	nLivroI := IIf( ( ValType( jParams['MV_PAR03'][1] ) == 'C' ), Val( jParams['MV_PAR03'][1] ), jParams['MV_PAR03'][1] )

	If !Empty( cAliasA ) .And. ( ValType( jParams ) == 'J' )
		cQry := "SELECT ISNULL(SUM(F3_BASIMP1),0) AS TOTIVA, ISNULL(SUM(F3_VALIMP1),0) AS CRED, ISNULL(SUM(F3_EXENTAS),0) AS EXENTAS "
		cQry += "FROM " + RetSQLName( 'SF3') + " SF3 "
		cQry += "WHERE SF3.F3_FILIAL = ? "
		cQry += "   AND SF3.F3_ENTRADA BETWEEN ? AND ? "
		cQry += "   AND SF3.F3_ALQIMP1 = ? "
		cQry += "   AND SF3.F3_DTCANC = ? "

		If ( nLivroI == 1 )
			cQry += "AND (SF3.F3_ESPECIE IN(?) OR (SF3.F3_ESPECIE = ? AND SF3.F3_TIPOMOV = ?)) "
		ElseIf ( nLivroI == 2 )
			cQry += "AND (SF3.F3_ESPECIE IN(?) OR (SF3.F3_ESPECIE = ? AND SF3.F3_TIPOMOV = ?)) "
		EndIf
		cQry += "   AND SF3.F3_NFISCAL = ? "
		cQry += "   AND SF3.F3_SERIE = ? "
		cQry += "   AND SF3.F3_CLIEFOR = ? "
		cQry += "   AND SF3.F3_LOJA = ? "
		cQry += "   AND SF3.D_E_L_E_T_ = ? "

		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		oQueryB := FwExecStatement():New()

		//Define a consulta e os parâmetros
		oQueryB:SetQuery( cQry )

		oQueryB:SetString( 1, ( cAliasA )->F3_FILIAL )
		oQueryB:SetString( 2, ( cAliasA )->F3_ENTRADA )
		oQueryB:SetString( 3, ( cAliasA )->F3_ENTRADA )
		oQueryB:SetString( 4, AllTrim( Str( ( cAliasA )->F3_ALQIMP1 ) ) )
		oQueryB:SetString( 5, ( cAliasA )->F3_DTCANC )

		If ( nLivroI == 1 )
			oQueryB:SetIn( 6, { 'NDP','NDE','NCI','NCC' } )
			oQueryB:SetString( 7, ( cAliasA )->F3_ESPECIE )
			oQueryB:SetString( 8, ( cAliasA )->F3_TIPOMOV )
		ElseIf ( nLivroI == 2 )
			oQueryB:SetIn( 6, { 'NDC','NCP','NDI','NCE' } )
			oQueryB:SetString( 7, ( cAliasA )->F3_ESPECIE )
			oQueryB:SetString( 8, ( cAliasA )->F3_TIPOMOV )
		EndIf

		oQueryB:SetString( 9, ( cAliasA )->F3_NFISCAL )
		oQueryB:SetString( 10, ( cAliasA )->F3_SERIE )
		oQueryB:SetString( 11, ( cAliasA )->F3_CLIEFOR )
		oQueryB:SetString( 12, ( cAliasA )->F3_LOJA )
		oQueryB:SetString( 13, ' ' )

		// cria alias
		cQry := oQueryB:getFixQuery( )

		oQueryB:OpenAlias( cAliasB )

		If ( ( cAliasA )->F3_ALQIMP1 == 5 )
			nTOTIVA2 := ( ( cAliasB )->TOTIVA * nSinal )
			nCRED02 := ( ( cAliasB )->CRED * nSinal )
		ElseIf ( ( cAliasA )->F3_ALQIMP1 == 10 ) .Or. ( ( cAliasA )->F3_ALQIMP1 == 100 )
			nTOTIVA1 += ( ( cAliasB )->TOTIVA * nSinal )
			nCRED01 += ( cAliasB )->CRED * nSinal
		EndIf
		nEXENTAS += ( ( cAliasB )->EXENTAS * nSinal )

		aRet := { nTOTIVA1, nTOTIVA2, nCRED01, nCRED02, nEXENTAS }

		If ( SELECT( cAliasB ) > 0 )
			( cAliasB )->( DbCloseArea( ) )
		EndIf
	EndIf

Return( aRet )
