#INCLUDE 'msobject.ch'
#INCLUDE 'tlpp-core.th'
#INCLUDE 'tlpp-rest.th'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.fis.PurchasesSales.ch'

//-------------------------------------------------------------------------------
/*{Protheus.doc} libroventasTReportsBusinessObject
Classe para criação do Objeto de Negocio de fiscal para SmartView
@author Leonardo Pereira
@since 30/09/2023
@version 1.0
*/
//-------------------------------------------------------------------------------
namespace custom.fiscal.libroventas_ARG.integratedprovider

// Annotation
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGAFIS', tables='SA1,SA2,SF1,SF2,SF3', name='Libros Fiscal de ventas', country='ARG', initialRelease='12.1.2410' )
class libroventas_ARGTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} NEW
Método de instância da classe: Define a lista de importações que serão acessados no objeto de negocios
@return object: self
@author Leonardo Pereira
@since 30/09/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method new() class libroventas_ARGTReportsBusinessObject

	Local aCpos as array

	aCpos := { }

	_Super:new()

	// Define a Área
	self:appendArea( STR0017 ) // 'Fiscal' - Libros Fiscales

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0001 ) // 'Libros Fiscal de ventas'

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0001 ) // 'Libros Fiscal de ventas'

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'MATSV2B' ) // Indica o pergunte que será utilizado
		IIf(!self:setErrorStatus( 400, STR0001, STR0002 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0003,,, ),'') //'Sin Preguntas' //'¡Verifique el grupo de preguntas dado!' //'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0004 ,,, ) // 'Grupo de preguntas no encontrado!'
	EndIf

	// Adiciona os campos virtuais/calculados
	aAdd( aCpos, { 'F3_ALQIVA' , STR0006, 'number', STR0007 } ) // 'Alícuota IVA' ## '% IVA'
	aAdd( aCpos, { 'F3_BASIVA' , STR0008, 'number', STR0008 } ) // 'Base Cálculo IVA'
	aAdd( aCpos, { 'F3_EXENTAS', STR0009, 'number', STR0009 } ) // 'Exentos no Gravados'
	aAdd( aCpos, { 'F3_VLRIVA' , STR0010, 'number', STR0011 } ) // 'Impuesto IVA' ## 'IVA'
	aAdd( aCpos, { 'F3_VLRIVAP', STR0012, 'number', STR0013 } ) // 'Impuesto IVA Percep.' ## 'IVA Percep.'
	aAdd( aCpos, { 'F3_IIBB'   , STR0014, 'number', STR0014 } ) // 'IIBB Percep.'
	aAdd( aCpos, { 'F3_OUTRAS' , STR0015, 'number', STR0016 } ) // 'Otros Impuestos' ## 'Otros'
	aAdd( aCpos, { 'F3_STATUS' , STR0018, 'string', STR0018 } ) // 'Estatus'

	// Define os campos que serão retornados no objeto de negocios
	self:aFields := { "A1_COD", "A1_NOME", "A1_AFIP", "A1_CGC", "A1_TIPO", "F3_ENTRADA", "F3_ESPECIE", "F3_SERIE", "F3_NFISCAL", "F3_ALQIVA", "F3_VALCONT", "F3_BASIVA", "F3_EXENTAS", "F3_VLRIVA", "F3_VLRIVAP", "F3_IIBB", "F3_OUTRAS", "F3_STATUS" }

	self:aStruct := getStrutObj( self:aFields, aCpos, .T. )

Return( self )


//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura de campos 
@return object: self:oSchema 
@author Leonardo Pereira
@since 30/09/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema( ) as object class libroventas_ARGTReportsBusinessObject

	Local n1 as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTVIEW
	For n1 := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[n1][1], self:aStruct[n1][2], self:aStruct[n1][3], self:aStruct[n1][4], self:aStruct[n1][5] )
	Next

Return( self:oSchema )


//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os datos do objeto de negócios
@param nPage, numérico, indica a pagina atual
@param oFilter, objeto, contém o filtro do SmartView
@return object: self:oData
@author Leonardo Pereira
@since 30/09/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object) as object class libroventas_ARGTReportsBusinessObject

	// Declaracao de variaveis
	Local jParams as json
	Local jItems as json

	Local cQry as character
	Local cAliasA := GetNextAlias() as character
	Local cCposSF3 as character
	Local cFiltro as character

	Local nPos as numeric
	Local nX as numeric
	Local nY as numeric
	Local nItem as numeric
	Local nTotAliq as numeric
	Local nTotBase as numeric
	Local nTotTrib as numeric

	Local aPDFields as array
	Local aStruSF3 as array
	Local aTributos as array
	Local aFiltro as array

	Local lObfuscated as logical
	Local lCpo as logical

	Local oQueryA as object

	cCposSF3 := ''
	cFiltro := ''

	nX := 0
	nY := 0
	nPos := 0
	nTotAliq := 0
	nTotBase := 0
	nTotTrib := 0

	aPDFields := { }
	aStruSF3 := { }
	aTributos := ObtImpSFB( )
	aFiltro := { }

	lObfuscated := .F.
	lCpo := .T.

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	If oFilter:hasFilter()
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )

		aFiltro := getParamToArr( cFiltro )

		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )
	EndIf

	// SF3 - Campos de impostos
	aStruSF3 := SF3->( DbStruct( ) )
	For nX := 1 To Len( aStruSF3 )
		cCposSF3 += AllTrim( aStruSF3[nX, 1] ) + ", "
	Next
	cCposSF3 := SubStr( cCposSF3, 1, ( Len( cCposSF3 ) - 2 ) )

	// Realiza a montagem da QUERY que será enviada para o banco de dados
	cQry := "SELECT SA1.A1_COD, SA1.A1_NOME, SA1.A1_AFIP, SA1.A1_CGC, SA1.A1_TIPO, "
	cQry += "  CASE "
	cQry += "  WHEN F3_DTCANC  = '' THEN ? " // Activos
	cQry += "  WHEN F3_DTCANC <> '' THEN ? " // Anulados
	cQry += "  END AS F3_STATUS, " + cCposSF3 + " "
	cQry += "FROM " + RetSQLName( "SF3" ) + " SF3 "
	cQry += "INNER JOIN " + RetSqlName( "SA1" ) + " SA1 "
	cQry += "   ON SA1.A1_FILIAL = ? "
	cQry += "      AND SA1.A1_COD = SF3.F3_CLIEFOR "
	cQry += "      AND SA1.A1_LOJA = SF3.F3_LOJA "
	cQry += "      AND SA1.D_E_L_E_T_ = ? "
	cQry += " WHERE SF3.F3_FILIAL = ? "
	cQry += "   AND SF3.F3_ENTRADA BETWEEN ? AND ? "
	cQry += "   AND SF3.F3_TIPOMOV = ? "
	cQry += "   AND SF3.F3_ESPECIE IN(?) "
	cQry += "   AND SF3.D_E_L_E_T_ = ? "

	// Agrega os filtros do SMARTVIEW na QUERY
	For nX := 1 To Len( aFiltro )
		cQry += "AND " + aFiltro[nX, 1] + ' ' + aFiltro[nX, 2] + " " + aFiltro[nX, 3] + " "
	Next

	cQuery := ChangeQuery( cQry )

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	oQueryA := FwExecStatement():New()

	//Define a consulta e os parâmetros
	oQueryA:SetQuery( cQry )

	oQueryA:SetString( 1, STR0019 )
	oQueryA:SetString( 2, STR0020 )
	oQueryA:SetString( 3, FwxFilial( 'SA1' ) )
	oQueryA:SetString( 4, ' ' )
	oQueryA:SetString( 5, FwxFilial( 'SF3' ) )
	oQueryA:SetString( 6, DtoS( FwDateTimeToLocal( jParams['MV_PAR01'][1] )[1] ) )
	oQueryA:SetString( 7, DtoS( FwDateTimeToLocal( jParams['MV_PAR02'][1] )[1] ) )
	oQueryA:SetString( 8, 'V' )
	oQueryA:SetIn( 9, { 'NF','NDC','NCC','NCE','NDE','CF' } )
	oQueryA:SetString( 10, ' ' )

	cQry := oQueryA:getFixQuery( )

	// cria alias
	oQueryA:OpenAlias( cAliasA )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	DbSelectArea( cAliasA )
	While !( cAliasA )->( EOF( ) )
		nItem++
		jItems := JsonObject():new()
		nSinal := 1

		If ( AllTrim( ( cAliasA )->F3_ESPECIE ) $ 'NCC|NDE' )
			nSinal := -1
		EndIf

		For nX := 1 To Len( self:aStruct )
			If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
				jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
			ElseIf ( self:aStruct[nX][3] == 'date' )
				jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
			Else
				If ( self:aStruct[nx][5] == 'A1_AFIP' )
					If Empty( ( cAliasA )->&( self:aStruct[nX][5] ) )
						jItems[self:aStruct[nX][1]] := '80'
					Else
						jItems[self:aStruct[nX][1]] := StrZero( Val( ( cAliasA )->&( self:aStruct[nX][5] ) ), 2 )
					EndIf
				ElseIf ( self:aStruct[nx][5] == 'A1_COD' )
					jItems[self:aStruct[nX][1]] := IIf( !Empty( ( cAliasA )->F3_DTCANC ), 'ANULADA', ( cAliasA )->A1_COD )
				ElseIf ( self:aStruct[nx][5] == 'A1_NOME' )
					jItems[self:aStruct[nX][1]] := IIf( !Empty( ( cAliasA )->F3_DTCANC ), 'ANULADA', ( cAliasA )->A1_NOME )
				ElseIf ( self:aStruct[nx][5] == 'F3_VALCONT' )
					jItems[self:aStruct[nX][1]] := ( ( cAliasA )->&( self:aStruct[nX][5] ) * nSinal )
				ElseIf ( self:aStruct[nx][5] == 'F3_IIBB' )
					nTotTrib := 0
					For nY = 1 To Len( aTributos[1, 1] )
						If !Empty( ( cAliasA )->F3_DTCANC )
							nTotTrib += 0
						Else
							nTotTrib += ( cAliasA )->&( 'F3_VALIMP' + aTributos[1, 1, nY] )
						EndIf
					Next
					jItems[self:aStruct[nX][1]] := ( nTotTrib * nSinal )
				ElseIf ( self:aStruct[nx][5] == 'F3_ALQIVA' )
					nTotAliq := 0
					For nY = 1 To Len( aTributos[1, 2] )
						If !Empty( ( cAliasA )->F3_DTCANC )
							nTotAliq += 0
						Else
							nTotAliq += ( ( cAliasA )->&( 'F3_ALQIMP' + aTributos[1, 2, nY] ) )
						EndIf
					Next
					jItems[self:aStruct[nX][1]] := nTotAliq
				ElseIf ( self:aStruct[nx][5] == 'F3_BASIVA' )
					nTotBase := 0
					For nY = 1 To Len( aTributos[1, 2] )
						If !Empty( ( cAliasA )->F3_DTCANC )
							nTotBase += 0
						Else
							If ( ( cAliasA )->&( 'F3_ALQIMP' + aTributos[1, 2, nY] ) > 0 )
								nTotBase += ( cAliasA )->&( 'F3_BASIMP' + aTributos[1, 2, nY] )
								Exit
							EndIf
						EndIf
					Next
					jItems[self:aStruct[nX][1]] := ( nTotBase * nSinal )
				ElseIf ( self:aStruct[nx][5] == 'F3_EXENTAS' )
					If !Empty( ( cAliasA )->F3_DTCANC )
						jItems[self:aStruct[nX][1]] := 0
					Else
						jItems[self:aStruct[nX][1]] := ( ( cAliasA )->&( self:aStruct[nX][5] ) * nSinal )
					EndIf
				ElseIf ( self:aStruct[nx][5] == 'F3_VLRIVA' )
					nTotTrib := 0
					For nY = 1 To Len( aTributos[1, 2] )
						If !Empty( ( cAliasA )->F3_DTCANC )
							nTotTrib += 0
						Else
							nTotTrib += ( cAliasA )->&( 'F3_VALIMP' + aTributos[1, 2, nY] )
						EndIf
					Next
					jItems[self:aStruct[nX][1]] := ( nTotTrib * nSinal )
				ElseIf ( self:aStruct[nx][5] == 'F3_VLRIVAP' )
					nTotTrib := 0
					For nY = 1 To Len( aTributos[1, 3] )
						If !Empty( ( cAliasA )->F3_DTCANC )
							nTotTrib += 0
						Else
							nTotTrib += ( cAliasA )->&( 'F3_VALIMP' + aTributos[1, 3, nY] )
						EndIf
					Next
					jItems[self:aStruct[nX][1]] := ( nTotTrib * nSinal )
				ElseIf ( self:aStruct[nx][5] == 'F3_OUTRAS' )
					nTotTrib := 0
					For nY = 1 To Len( aTributos[1, 5] )
						If !Empty( ( cAliasA )->F3_DTCANC )
							nTotTrib += 0
						Else
							nTotTrib += ( cAliasA )->&( 'F3_VALIMP' + aTributos[1, 5, nY] )
						EndIf
					Next
					jItems[self:aStruct[nX][1]] := ( nTotTrib * nSinal )
				Else
					jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
				EndIf
			EndIf
		Next

		// Inclui os dados no objeto paea retorno ao SmartView
		self:oData:appendData( jItems )

		( cAliasA )->( DbSkip( ) )
	End

	( cAliasA )->( DbCloseArea( ) )

	// fecha objeto
	If ( oQueryA <> Nil )
		oQueryA:Destroy( )
		oQueryA := Nil
		FwFreeObj( oQueryA )
	EndIf

Return( self:oData )

//-------------------------------------------------------------------------------
/*{Protheus.doc} OBTIMPSFB
@description Rotina para identificar as colunas dos impostos na tabela SF3, conforme cadastrado na tabela SFB
@author Leonardo Pereira
@since 01/10/2023
@version 1.0
@return array - Colunas dos campos dos tributos na tabela SFB
aRet[1]
aRet[1][1] - IB
aRet[1][2] - IVA
aRet[1][3] - IVAP
aRet[1][4] - EXENTOS
aRet[1][5] - OUTROS
*/
//-------------------------------------------------------------------------------
Static Function ObtImpSFB( )

	Local cIIBB as character
	Local cIVA as character
	Local cIVAP as character
	Local cEXENTO as character
	Local cFilSFB as character

	Local aRet as array
	Local aIIBB as array
	Local aIVA as array
	Local aIVAP as array
	Local aEXENTO as array
	Local aOUTROS as array

	cIIBB := '1P'
	cIVA := '3I'
	cIVAP := '3P'
	cEXENTO := '2I'

	cFilSFB := FwFilial( 'SFB' )

	aRet := { }
	aIIBB := { }
	aIVA := { }
	aIVAP := { }
	aEXENTO := { }
	aOUTROS := { }

	DbSelectArea( 'SFB' )

	// 01 - Identifica as colunas do tributo IB
	SFB->( DbGoTop( ) )
	While !SFB->( EOF( ) )
		If ( SFB->FB_FILIAL + SFB->FB_CLASSIF + SFB->FB_CLASSE == cFilSFB + cIIBB )
			If ( SFB->FB_CLASSE != 'R' )
				If ( Len( aIIBB ) != 0 )
					If ( aScan( aIIBB, SFB->FB_CPOLVRO ) == 0 )
						aAdd( aIIBB, SFB->FB_CPOLVRO )
					EndIf
				Else
					aAdd( aIIBB, SFB->FB_CPOLVRO )
				EndIf
			EndIf
		EndIf
		SFB->( DbSkip( ) )
	End

	// 02 - Identifica as colunas do tributo IVA
	SFB->( DbGoTop( ) )
	While !SFB->( EOF( ) )
		If ( SFB->FB_FILIAL + SFB->FB_CLASSIF + SFB->FB_CLASSE == cFilSFB + cIVA )
			If ( SFB->FB_CLASSE == 'I' )
				If ( Len( aIVA ) != 0 )
					If ( aScan( aIVA, SFB->FB_CPOLVRO ) == 0 )
						aAdd( aIVA, SFB->FB_CPOLVRO )
					EndIf
				Else
					aAdd( aIVA, SFB->FB_CPOLVRO )
				EndIf
			EndIf
		EndIf
		SFB->( DbSkip( ) )
	End

	// 03 - Identifica as colunas do tributo IVAP
	SFB->( DbGoTop( ) )
	While !SFB->( EOF( ) )
		If ( SFB->FB_FILIAL + SFB->FB_CLASSIF + SFB->FB_CLASSE == cFilSFB + cIVAP )
			If ( SFB->FB_CLASSE == 'P' )
				If ( Len( aIVAP ) != 0 )
					If ( aScan( aIVAP, SFB->FB_CPOLVRO ) == 0 )
						aAdd( aIVAP, SFB->FB_CPOLVRO )
					EndIf
				Else
					aAdd( aIVAP, SFB->FB_CPOLVRO )
				EndIf
			EndIf
		EndIf
		SFB->( DbSkip( ) )
	End

	// 04 - Identifica as colunas do tributo EXENTOS
	SFB->( DbGoTop( ) )
	While !SFB->( EOF( ) )
		If ( SFB->FB_FILIAL + SFB->FB_CLASSIF + SFB->FB_CLASSE == cFilSFB + cEXENTO )
			If ( SFB->FB_CLASSE == 'I' )
				If ( Len( aEXENTO ) != 0 )
					If ( aScan( aEXENTO, SFB->FB_CPOLVRO ) == 0 )
						aAdd( aEXENTO, SFB->FB_CPOLVRO )
					EndIf
				Else
					aAdd( aEXENTO, SFB->FB_CPOLVRO )
				EndIf
			EndIf
		EndIf
		SFB->(DBSkip())
	End

	// 05 - Identifica as colunas de Outros Impostos
	// Alimenta o Array de Posicionamento das Colunas em SF3 para outros impostos adicionando as colunas não utilizadas para IB, IVA, IVAP e EXENTOS
	SFB->( DbGoTop( ) )
	While !SFB->( EOF( ) )
		If ( SFB->FB_CLASSE == 'R' )
			SFB->( DBSkip( ) )
			Loop
		EndIf

		If ( aScan( aEXENTO, SFB->FB_CPOLVRO ) != 0 ) .Or. ( aScan( aIVA, SFB->FB_CPOLVRO ) != 0 ) .Or. ( aScan( aIVAP, SFB->FB_CPOLVRO ) != 0 ) .Or. ( aScan( aIIBB, SFB->FB_CPOLVRO ) != 0 )
			SFB->( DbSkip( ) )
			Loop
		EndIf

		If ( aScan( aOUTROS, SFB->FB_CPOLVRO ) == 0 )
			aAdd( aOUTROS, SFB->FB_CPOLVRO )
		EndIf
		SFB->( DbSkip( ) )
	End

	// Alimenta array de retorno
	aAdd( aRet, { aIIBB, aIVA, aIVAP, aEXENTO, aOUTROS } )

Return( aRet )
