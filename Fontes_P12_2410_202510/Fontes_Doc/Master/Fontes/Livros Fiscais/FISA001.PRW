#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWMBROWSE.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "FISA001.CH"
//------------------------------------------------------------------
/*/{Protheus.doc} FISA001

Rotina da apuração da EFD Contribuições. 
@author Erick G. Dias
@since 02/04/2014 
@version 11.80
@description teste descrição

@history Vogas Júnior, 05/06/2018, (DSERFIS1-4280) imprimir relartório conforme período apurado.

/*/ 
//------------------------------------------------------------------
Function FISA001()

	Local lVerpesssen := Iif(FindFunction("Verpesssen"),Verpesssen(),.T.)

	Private EAI_MESSAGE_MVC := ""
	Private oBrowse
	Private oPanelBrw
	PRIVATE cMarca     	:= GetMark()
	PRIVATE CLIVROAPU	:= ""

	STATIC NAOCUMULAT	:= '1'
	STATIC CUMULAT 		:= '2'
	STATIC NFENTRADA	:= '1'
	STATIC NFSAIDA 		:= '2'
	STATIC PIS			:= '1'
	STATIC COFINS 		:= '2'
	STATIC REDUCAO 		:= '0'
	STATIC ACRESCIMO	:= '1'
	STATIC CREDITO 		:= '1'
	STATIC DEBITO 		:= '2'
	STATIC LVROFISCAL	:= '1'
	STATIC FISCALENT	:= '1'
	STATIC FISCALSAI	:= '2'
	STATIC TITENTRADA	:= '3'
	STATIC TITSAIDA		:= '4'
	STATIC ATIVOFIXO	:= '5'
	STATIC CUPOM		:= '6'
	STATIC CPRB			:= '7'
	STATIC OUTROS		:= '8'
	STATIC cCSTCRED		:= '50/51/52/53/54/55/56/60/61/62/63/64/65/66' //CSTs de PIS e Cofins que dão direito a crédito na apuração do bloco M
	STATIC cCstTrib		:= '01/02/03/05'  //CSts tributáveis
	STATIC cCstNTrib	:= '04/06/07/08/09/49/99' //CSts não tributáveis
	STATIC lSPDPIS10	:= ExistBlock("SPDPIS10") // PE para retornar Base de Calculo quando operação com Pauta

	If lVerpesssen
		If AliasINdic('CKR')
			FWExecView(STR0020,'FISA001', MODEL_OPERATION_INSERT,,, { || .T. } )//'Rotina de Apuração EFD Contribuições'
		Else
			Alert(STR0021)//'Tabelas não criadas, por favor processa compatibilizado UPDFIS'
		EndIF
	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
 
@author Erick G. Dias
@since 02/04/2014
@version 11.80

/*/
//-------------------------------------------------------------------
Static Function MenuDef()

	Local aRotina := {}

	ADD OPTION aRotina TITLE STR0024 ACTION 'A001Agrp()' OPERATION 3 ACCESS 0 //'Agrupar Filial -> Matriz'
	ADD OPTION aRotina TITLE STR0022 ACTION 'VisualApur' OPERATION 2 ACCESS 0 //"Visualizar"
	ADD OPTION aRotina TITLE STR0023 ACTION 'EditaApur' OPERATION 4 ACCESS 0 //'Editar'
	ADD OPTION aRotina TITLE 'Excluir' ACTION 'ExcluApur' OPERATION 5 ACCESS 0 //'Editar'
	ADD OPTION aRotina TITLE 'Visualizar Log' ACTION 'ProcLogView("","FISA001")' OPERATION 5 ACCESS 0 //'Editar'
	ADD OPTION aRotina TITLE 'Sobre' ACTION 'ISA001Data()' OPERATION 5 ACCESS 0 //'Editar'

	If FindFunction('FISR101') .And. GetRPORelease() <= "12.1.2310"
		ADD OPTION aRotina TITLE 'Relatório de Conferência EFD' ACTION 'FSA001REL' OPERATION 1 ACCESS 0 //'Editar'
	EndIF

Return ( aRotina )


//-------------------------------------------------------------------
/*/{Protheus.doc} ModelDef
 
@author Erick G. Dias
@since 02/04/2014
@version 11.80

/*/
//-------------------------------------------------------------------
Static Function ModelDef()

	Local oModel
	Local oStructABA := FWFormStruct( 1, 'CKR')

	oModel	:=	MPFormModel():New('MODEL_ABA')
	oModel:AddFields( 'MODEL_ABA' ,, oStructABA )
	oModel:SetPrimaryKey( { 'ABA_CMP1'} )
	oModel:SetDescription( 'TOTVS')

Return oModel

//-------------------------------------------------------------------
/*/{Protheus.doc} ViewDef
 
@author Erick G. Dias
@since 02/04/2014
@version 11.80

/*/
//-------------------------------------------------------------------
Static Function ViewDef()
	Local oModel    := FWLoadModel( 'FISA001' )
	Local oView     := FWFormView():New()
	Local oStruABA  := FWFormStruct( 2, 'CKR' )

	oView:SetModel( oModel )

	oView:AddField( 'VIEW_ABA', oStruABA, 'MODEL_ABA' )

	oView:AddOtherObject( 'PANEL_TREE',  { |oPanel| MONTATREE( oPanel ) } )
	oView:AddOtherObject( 'PANEL_EMPTY', { |oPanel| } )
	oView:AddOtherObject( 'PANEL_BROWSE',{ |oPanel| oPanelBrw := oPanel, FBrowseMon( oPanel ) } )

	oView:EnableTitleView('PANEL_TREE',STR0025)//'Rotinas Disponíveis'

	oView:CreateHorizontalBox( 'INFO_FUNC'	  	,00 )
	oView:CreateHorizontalBox( 'EVENTO_FUNC'	,98 )
	oView:CreateHorizontalBox( 'FIM_TELA'   	,02 )

	oView:CreateVerticalBox( 'INFO_FUNC_ESQ'		, 100	,'INFO_FUNC' )
	oView:CreateVerticalBox( 'EVENTO_FUNC_ESQ'		, 27	,'EVENTO_FUNC' )
	oView:CreateVerticalBox( 'EVENTO_FUNC_CENTER'	, 01	,'EVENTO_FUNC' )
	oView:CreateVerticalBox( 'EVENTO_FUNC_DIR'		, 72	,'EVENTO_FUNC' )
	oView:CreateVerticalBox( 'FIM_TELA_EMPTY'		, 100	, 'FIM_TELA' )

	oView:SetOwnerView( 'VIEW_ABA'		, 'INFO_FUNC_ESQ' )
	oView:SetOwnerView( 'PANEL_TREE'	, 'EVENTO_FUNC_ESQ' )
	oView:SetOwnerView( 'PANEL_EMPTY'	, 'EVENTO_FUNC_CENTER' )
	oView:SetOwnerView( 'PANEL_BROWSE'	, 'EVENTO_FUNC_DIR' )
	oView:SetOwnerView( 'PANEL_EMPTY'	, 'FIM_TELA_EMPTY' )

Return oView


//-------------------------------------------------------------------
/*/{Protheus.doc} MontaTree
Função que cria tree com as rotinas disponíveis
 
@author Erick G. Dias
@since 02/04/2014
@version 11.80

/*/
//-------------------------------------------------------------------

STATIC FUNCTION MontaTree(oPanel)

	Local oTree
	Local aCoors := {}
	Local bChange := { || FChgTree( oTree,oPanel )  }

	oSize := FwDefSize():New(.T.,,,.T.)
	oSize:AddObject('PANEL_TREE'  ,100,100,.T.,.T.)
	oSize:lProp 	:= .T. // Proporcional
	oSize:aMargins 	:= { 0, 0, 0, 0 } // Espaco ao lado dos objetos 0, entre eles 3
	oSize:Process()

	aAdd(aCoors,{oSize:GetDimension("PANEL_TREE", "COLINI"),oSize:GetDimension("PANEL_TREE", "LININI"),oSize:GetDimension("PANEL_TREE", "YSIZE")*0.97,oSize:GetDimension("PANEL_TREE", "COLEND")*0.26})

	oTree := DbTree():New( aCoors[1][2], aCoors[1][1], aCoors[1][3], aCoors[1][4], oPanel,bChange , , .T. )

	oTree:AddTree( Padr(STR0018,40), .T., "FOLDER5" ,"FOLDER6",,,"000" )
	oTree:TreeSeek( "000" )
	oTree:AddItem(STR0004,"001","PMSEDT3","",,,2) ////"Processar Apuração da EFD Contribuições"
	IF Findfunction('FISA076') .AND. ISA001NDIF()
		oTree:AddItem(STR0110,"003","PMSEDT3","",,,2)//"Informacões Adic. Diferimento"
	EndIf
	oTree:AddItem(STR0005,"004","PMSEDT3","",,,2)//"Demais Documentos PIS/COFINS"
	oTree:AddItem(STR0006,"005","PMSEDT3","",,,2)//"Exclusões de Sociedade Cooperativa"
	oTree:AddItem(STR0007,"006","PMSEDT3","",,,2) //"Deduções Diversas PIS COFINS"
	oTree:AddItem(STR0008,"007","PMSEDT3","",,,2) //"Ajuste de créditos PIS/COFINS/CPRB"

	IF FindFunction("FISA210") .AND. AliasIndic("F2Z")
		oTree:AddItem(STR0116 ,"008","PMSEDT3","",,,2) //"Ajustes da Base de Cálculo de PIS e COFINS"
	EndIF

	oTree:AddItem(STR0009,"009","PMSEDT3","",,,2)//"Controle de saldo de Crédito de PIS"
	oTree:AddItem(STR0010,"010","PMSEDT3","",,,2)//"Controle de saldo de Crédito da COFINS"

	IF SFV->(FieldPos("FV_RESSA")) > 0 .And. SFV->(FieldPos("FV_COMP")) > 0 .And. SFV->(FieldPos("FV_RESRET")) > 0 .And. ;
			FindFunction("FISA216") .And. FindFunction("FISA217")

		oTree:AddItem(STR0120,"023","PMSEDT3","",,,2)//"Controle de retencoes do PIS"
		oTree:AddItem(STR0121,"024","PMSEDT3","",,,2)//"Controle de retencoes da COFINS"
	EndIf

	oTree:AddItem(STR0012,"011","PMSEDT3","",,,2)//"Crédito Sobre Estoque de Abertura"
	oTree:AddItem(STR0013,"012","PMSEDT3","",,,2)//"Ressarcimento de crédito de PIS e COFINS"

	oTree:AddItem(STR0105,"014","PMSEDT3","",,,2)//Rotina de importação dos códigos da Receita Federal

	IF Findfunction('FISA006')
		oTree:AddItem(STR0106,"015","PMSEDT3","",,,2)//Rotina de Demais Retenções
	EndIF

	IF Findfunction('FISA124') .And. AliasINdic('F0X')
		oTree:AddItem(STR0107,"016","PMSEDT3","",,,2)//Rotina escrituração do F800
	EndIf

	IF Findfunction('FISA089')
		oTree:AddItem(STR0108,"017","PMSEDT3","",,,2)//Rotina Período Dispensado
	EndIf

	IF Findfunction('FISA009') .And. AliasINdic('F3F')
		oTree:AddItem(STR0111,"018","PMSEDT3","",,,2)//Bloco I X Contabilidade
	EndIf

	IF FindFunction("FISA211") .AND. AliasIndic("F3N")
		oTree:AddItem(STR0117 ,"019","PMSEDT3","",,,2) //"Recibos de Transmissão do SPED"
	EndIF

	//A rotina de cadastro somente será exibida na tela se a tabela existir e o parâmetro for configurado
	IF FindFunction("FISA212") .AND. AliasIndic("F3U") .AND. GetNewPar('MV_ESTCRDA',"") $ "1/2"
		oTree:AddItem(STR0118 ,"020","PMSEDT3","",,,2) //"Códigos de Créditos a Serem Estornados"
	EndIF

	//A rotina de cadastro somente será exibida na tela se a tabela existir e o parâmetro for configurado
	IF FindFunction("FISA213") .AND. AliasIndic("F3V") .AND. GetNewPar('MV_ESTCRDA',"") == "1"
		oTree:AddItem(STR0119 ,"021","PMSEDT3","",,,2) //"Percentuais de Estorno de Créditos"
	EndIF

	IF Findfunction('FISA008')
		oTree:AddItem(STR0109,"022","PMSEDT3","",,,2)//Rotina de geração do Arquivo
	EndIF

	IF Findfunction('FISA316') .AND. AliasIndic("CJT")
		oTree:AddItem(STR0126,"025","PMSEDT3","",,,2)//Rotina de Pré=Agendamento
	EndIF

return (nil)

//-------------------------------------------------------------------
/*/{Protheus.doc} FChgTree
 
@author Erick G. Dias
@since 02/04/2014
@version 11.80

/*/
//-------------------------------------------------------------------

Static Function FChgTree( oTree )

	Local cIdTreePos := ""

	Local aInfTree := {}

	//Busco a identificação de qual item da Tree estamos posicionadoss
	cIdTreePos := oTree:GetCargo()
	oPanelBrw:FreeChildren()
	oBrowse:DeActivate()
	aInfTree := FChcTpFunc( cIdTreePos ,oTree)
	FBrowseMon( oPanelBrw, aInfTree[1], aInfTree[2], aInfTree[3], aInfTree[4] )
	oBrowse:Refresh()

Return ( Nil )

//-------------------------------------------------------------------
/*/{Protheus.doc} FBrowseMon
 
@author Erick G. Dias
@since 02/04/2014
@version 11.80

/*/
//-------------------------------------------------------------------
Static Function FBrowseMon( oPanel, cFonteTree, cAliasTree, cFiltroBrw, cDescBrw )

	Local aInf := {}
	Local cFunc := "MethIsMemberOf"

	Default cFonteTree := ""
	Default cAliasTree := ""
	Default cFiltroBrw := ""
	Default cDescBrw   := ""

	oBrowse := FWmBrowse():New()

	If &cFunc.(oBrowse,"SetMainProc")
		oBrowse:SetMainProc(cFonteTree)
	EndIf


	If Empty( cFonteTree ) .And. Empty( cAliasTree )
		aInf := FChcTpFunc()

		cFonteTree := aInf[1]
		cAliasTree := aInf[2]
		cFiltroBrw := aInf[3]
		cDescBrw   := aInf[4]

		oBrowse:AddLegend( "CKR_STATUS=='1'", "RED"		, STR0026)//"Apuração não gerou título e não contabilizou."
		oBrowse:AddLegend( "CKR_STATUS=='2'", "YELLOW" 	, STR0027 )//"Apuração gerou gerou título"
		oBrowse:AddLegend( "CKR_STATUS=='3'", "GREEN" 	, STR0028 )//"Apuração gerou título e contabilizou"
		oBrowse:AddLegend( "CKR_STATUS=='4'", "BLUE" 		, STR0029 )//"Apuração Considerada para Consolidação na Matriz"

	ElseIf cAliasTree == "F3F"

		//Tratamento para legendas da tela filha do bloco I
		If F3F->(FieldPos("F3F_CTB")) > 0
			oBrowse:AddLegend( "F3F_CTB== '1'", "GREEN", "Realizou Integração com Contábil" ) // "Ajuste de Redução"
			oBrowse:AddLegend( "F3F_CTB<> '1' ", "RED", 	"Integração com Contábil pendente" ) // "Ajuste de Redução"
		EndIF

	ElseIf cAliasTree == "F2Z"

		oBrowse:AddLegend( "F2Z_TRIB == '1' .AND. F2Z_INDAJU == '0' ", "BR_AMARELO", STR0113 ) //"Ajuste de Acréscimo da Base de Cálculo do PIS"
		oBrowse:AddLegend( "F2Z_TRIB == '1' .AND. F2Z_INDAJU == '1' ", "BR_AZUL", STR0112 ) //"Ajuste de Redução da Base de Cálculo do PIS"
		oBrowse:AddLegend( "F2Z_TRIB == '2' .AND. F2Z_INDAJU == '0' ", "BR_BRANCO", STR0115 ) //"Ajuste de Acréscimo da Base de Cálculo da COFINS"
		oBrowse:AddLegend( "F2Z_TRIB == '2' .AND. F2Z_INDAJU == '1' ", "BR_VERDE", STR0114 ) //"Ajuste de Redução da Base de Cálculo da COFINS"

	ElseIf cAliasTree == "SFV"

		If SFV->(FieldPos("FV_RESRET")) > 0
			oBrowse:AddLegend( "FV_RESRET == '1' ", "RED"		, STR0122) //"Reserva de Retenção bloqueada."
			oBrowse:AddLegend( "FV_RESRET == '2' ", "GREEN" 	, STR0123)//"Reserva de Retenção disponível."
		EndIf

	ElseIf cAliasTree == "SFW"

		If SFW->(FieldPos("FW_RESRET")) > 0
			oBrowse:AddLegend( "FW_RESRET == '1' ", "RED"		, STR0122) //"Reserva de Retenção bloqueada."
			oBrowse:AddLegend( "FW_RESRET == '2' ", "GREEN" 	, STR0123)//"Reserva de Retenção disponível."
		EndIf

	EndIf

	oBrowse:SetOwner( oPanel )
	oBrowse:SetDescription( cDescBrw )
	oBrowse:SetAlias( cAliasTree )

	oBrowse:SetMenuDef( cFonteTree )
	oBrowse:DisableDetails()
	oBrowse:SetFilterDefault( cFiltroBrw )

	oBrowse:Activate()

Return ( Nil )


//-------------------------------------------------------------------
/*/{Protheus.doc} x001GetSX3
 
@author Erick G. Dias
@since 02/04/2014
@version 11.80

/*/
//-------------------------------------------------------------------
Function x001GetSX3( cAlias )


	Local aFields := {}

	DBSelectArea( "SX3" )
	SX3->( DBSetOrder( 1 ) )
	If SX3->( MsSeek( cAlias ) )
		While SX3->( !Eof() ) .and. SX3->X3_ARQUIVO == cAlias
			If X3Usado( SX3->X3_CAMPO ) .and. SX3->X3_CONTEXT <> "V"
				aAdd( aFields, { AllTrim( X3Titulo() ),;
					SX3->X3_CAMPO,;
					SX3->X3_TIPO,;
					SX3->X3_PICTURE,;
					SX3->X3_CBOX,;
					SX3->X3_TAMANHO,;
					SX3->X3_DECIMAL,;
					SX3->X3_WHEN,;
					SX3->X3_VALID} )
			EndIf
			SX3->( DBSkip() )
		EndDo
	EndIf

Return( aFields )


//-------------------------------------------------------------------
/*/{Protheus.doc} x001Struct
 
Função utilizada para criação das tabelas temporárias para as abas
da apuração, já que as tabelas não estão em dicionário, deverão ser 
criadas manualmente.
  
@param  	nOpcao  - indica se foi chamada na criação do Model ou da View.
			cTabela - Indica o alias da tabela temporária
@return	oStru  - Estrutura criada com os campos da tabela temporária qe será exibida na tela.			
@author Erick G. Dias
@since 07/04/2014
@version 11.80

/*/
//-------------------------------------------------------------------
Function x001Struct(nOpcao,cTabela)

	Local aCampos	:= {}
	Local nCont	:= 0
	Local oStru

	//Chama Função para criar os campos conforme tabela processada
	aCampos:= a002Tabs(cTabela)

	//Quando for chamada para criar Model
	If nOpcao == 1

		oStru :=  FWFormModelStruct():New()//	FWFormStruct( 1 , '')//
		oStru:AddTable("TRB",{},"TOTVS")
		For nCont := 1 to len (aCampos)
			oStru:AddField( ; 					// Ord. Tipo Desc.
			aCampos[nCont][1] , ;// [01] C Titulo do campo
			aCampos[nCont][1] , ;// [02] C ToolTip do campo
			aCampos[nCont][2] , ;// [03] C identificador (ID) do Field
			aCampos[nCont][3] , ;// [04] C Tipo do campo
			aCampos[nCont][4] , ;// [05] N Tamanho do campo
			aCampos[nCont][5] , ;	// [06] N Decimal do campo
			NIL				,;	// [07] B Code-block de validação do campo
			NIL 				, ;	// [08] B Code-block de validação When do campo
			{}					, ;	// [09] A Lista de valores permitido do campo
			NIL 				, ;	// [10] L Indica se o campo tem preenchimento obrigatório
			nil					, ;	// [11] B Code-block de inicializacao do campo
			NIL 				, ;	// [12] L Indica se trata de um campo chave
			.F. 				, ;	// [13] L Indica se o campo pode receber valor em uma operação de update.
			.F. ) 					// [14] L Indica se o campo é virtual
		Next nCont

		//Quando for chamada para criar a View
	ElseIF nOpcao == 2

		oStru := FWFormViewStruct():New()
		For nCont := 1 to len (aCampos)
			oStru:AddField( ;
				aCampos[nCont][2], ; // [01] C Nome do Campo
			aCampos[nCont][6], ;	// [02] C Ordem
			aCampos[nCont][1], ;	// [03] C Titulo do campo
			aCampos[nCont][1], ;	// [04] C Descrição do campo
			aCampos[nCont][7], ; // [05] A Array com Help
			aCampos[nCont][3], ; 	// [06] C Tipo do campo
			aCampos[nCont][8], ; // [07] C Picture
			NIL 			   , ;	// [08] B Bloco de Picture Var
			''                 , ; 	// [09] C Consulta F3
			aCampos[nCont][9]	, ; 	// [10] L Indica se o campo é evitável
			nil				   , ; 	// [11] C Pasta do campo
			NIL                , ;	// [12] C Agrupamento do campo
			{}                 , ; 	// [13] A Lista de valores permitido do campo
			NIL                , ;	// [14] N Tamanho Maximo da maior opção do combo
			NIL                , ; 	// [15] C Inicializador de Browse
			.F.                , ; 	// [16] L Indica se o campo é virtual
			NIL )
		Next nCont

	EndIF

Return oStru

//-------------------------------------------------------------------
/*/{Protheus.doc} FChcTpFunc
Função que identifica a opção selecionada pelo usuário e abre a rotina
pertinente a opção selecionada.

@author Erick G. Dias
@since 02/04/2014
@version 11.80

/*/
//-------------------------------------------------------------------
Function FChcTpFunc( cIdTreePos ,oTree, aReprocess, aAutoFil)

	Local aRet   			:= Array( 04 )
	local lReproc			:= .F.
	Local lProc			:= .F.
	local lLoad			:= .F.
	Local lProcessou		:= .F.
	Local aPergunta	:={}
	Local aFil			:={}
	Local lEnd			:= .F.
	Local oProcess
	Local lAutomato  	:= .F.
	Local cChkTabApu	:= ''
	Local lProcComp		:= .F. //Controle se deverá processar considerando o compartilhamento das tabelas
	Default aReprocess	:= {}
	Default aAutoFil	:= {{.T., cFilAnt}}
	Default cIdTreePos 	:= ""

	If Len(aReprocess) > 0
		lAutomato := .T.
	EndIf

	Do Case

	Case EmptY(cIdTreePos)
		aRet[1] := 'FISA001'
		aRet[2] := 'CKR'
		aRet[3] := ""
		aRet[4] := STR0030//"Rotina de Apuração da EFD Contribuições"
	Case cIdTreePos == "001"

		If lAutomato

			aPergunta	:= GuardaPerg()
			//-------------------------------
			//Verifica se apuração já existe
			//-------------------------------
			If CheckApur()
				//Aqui deseja reprocessar
				IF CheckDup(lAutomato) //Pergunta se quer excluir os títulos, se houve
					//Deseja excluir os títulos e reprocessar
					lReproc	:= .T.
					lProcComp  := .T.
				Else
					//Aqui quer somente carregar apuração, sem reprocessamento
					lLoad := .T.
				EndIF
			Else
				//Não existe apuração
				//Processar normalmente, pois será a primeira vez para esta filial e período
				lProc	:= .T.
				lProcComp  := .T.
			EndIF

		ElseIf Pergunte("ISA001",.T.)
			aPergunta	:= GuardaPerg()

			//Trecho abaixo realiza verificação das tabelas CCW, CCY, SFV, SFW, CF3, CF4 e CF5.
			//Para apuração agrupada estas tabelas devem estar com as tabelas compartilhadas.
			//Para apuração individualizada esta tabelas devem estar com compartilhamento exclusívo.
			//Rotina irá alertar usuário se houver inconsist~encia, mas se usuário desejar continuar ainda será permitido.
			lProcComp	:= .T.
			cChkTabApu:= CompTabEFD(MV_PAR15 == 2)
			IF !Empty(Alltrim(cChkTabApu))
				If ( ApMsgYesNo(cChkTabApu + CHR(10)+CHR(13) + 'Realmente deseja continuar?' ) )
					lProcComp	:= .T.
				Else
					lProcComp	:= .F.
				EndIF
			EndIF

			//-------------------------------
			//Verifica se apuração já existe
			//-------------------------------
			If lProcComp .AND. CheckApur()
				//Já existe apuração processada, deverá perguntar se o usuário quer reprocessatr
				cPerg	:= STR0031 + CRLF //'Já existe apuração processada para este período e filial.'
				cPerg	+= STR0032 + CRLF //'Deseja fazer o reprocessamento?'
				cPerg	+= STR0033			//'(Sim - Reprocessa / Não - Visualiza Apuração)'

				If ( ApMsgYesNo(cPerg ) )		//Irá apagar os títulos
					//Aqui deseja reprocessar
					IF CheckDup() //Pergunta se quer excluir os títulos, se houve
						//Deseja excluir os títulos e reprocessar
						lReproc	:= .T.
						//-------------------------------------------------------
						//Irá chamar função para verificar quais opções o usuário
						//deseja considerar no reprocessamento
						//-------------------------------------------------------
						aReprocess	:= ISA001PERG()
					Else
						//Não deseja excluir os títulos, irá somente carregar apuração
						lLoad := .T.
					EndIF

				Else
					//Aqui quer somente carregar apuração, sem reprocessamento
					lLoad := .T.
				EndIF

			Else
				//Não existe apuração
				//Processar normalmente, pois será a primeira vez para esta filial e período
				lProc	:= .T.
			EndIF
		EndIf

		IF lProcComp .AND. ( lReproc .OR. lProc)
			//Somente irá processar se apuração ainda não existe ou se deseja fazer reprocessamento.
			ProcLogIni({})
			ProcLogAtu("INICIO","#### --- Início da ápuração --- #### " + Time(),,upper('FISA001'))

			//aPergunta	:= GuardaPerg()
			aFil		:= GetFilial(lAutomato, aAutoFil)

			//Begin Transaction
			IF Len(aFil) > 0

				If lAutomato
					Processa({|lEnd|ProcEFD(oProcess,aReprocess,aPergunta,aFil,.T.,{},,@lProcessou)})
				Else

					oProcess := FISProgress():New({|lEnd| lEnd :=ProcEFD(oProcess,aReprocess,aPergunta,aFil,.T.,{},,@lProcessou)},STR0034)//'Processado Apuração EFD Contribuições'
					oProcess:Activate()
				EndIf

				IF !lProcessou
					//-------------------------
					//Não processou com sucesso, não vai fazer confirmar a gravação das informações
					//no banco de dados
					//-------------------------
					DisarmTransaction()

				EndIF

				//End Transaction
				ProcLogAtu("FIM","#### --- Final da apuração --- #### " + Time(),,upper('FISA001'))
			EndIF

		EndIF

		IF lProcessou //Somente carrega se processou com sucesso.

			Begin Transaction
				ProcLogIni({})
				ProcLogAtu("INICIO","Início do carregamento da Apuração - " + Time(),,upper('FISA001'))
				If MV_PAR15 == 1  .OR. (MV_PAR15==2 .AND. LEn(aFil) ==1)   //Somente irá exibir a apuração quando for consolidada. Se for individualizada o usuário terá que abrir pela tela

					aAreaSM0 := SM0->(GetArea())
					If MV_PAR15==2 .AND. LEn(aFil) ==1
						SM0->(DbGoTop ())
						SM0->(MsSeek (aFil[1][1]+aFil[1][2], .T.))	//Pego a filial mais proxima
						cFilAnt := FWGETCODFILIAL

					EndIF


					//Verifica condições de porcentagem da desoneração
					//Quando menor que 5% não havera bloco P
					//Quando superior ou igual a 95% utilzia 100% da receita bruta para desoneração
					ConsCPRB( aFil, aPergunta)

					FISA002(lLoad, .F.,MV_PAR06,lAutomato)
					RestArea (aAreaSM0)
					cFilAnt := FWGETCODFILIAL

				EndIF
				ProcLogAtu("FIM","Fim do carregamento da Apuração - " + Time(),,upper('FISA001'))
			End Transaction

		EndIF

		If !lAutomato
			oTree:TreeSeek('000')
		EndIf

	Case cIdTreePos == "003" .And. Findfunction('FISA076')  .AND. ISA001NDIF()
		aRet[1] := 'FISA076'
		aRet[2] := 'CFA'
		aRet[3] := ""
		aRet[4] := STR0110 // "Informacões Adic. Diferimento"
	Case cIdTreePos == "004"
		aRet[1] := 'FISA048'
		aRet[2] := 'CF8'
		aRet[3] := ""
		aRet[4] := STR0005
	Case cIdTreePos == "005"
		aRet[1] := 'FISA039'
		aRet[2] := 'CE9'
		aRet[3] := ""
		aRet[4] := STR0006
	Case cIdTreePos == "006"
		aRet[1] := 'FISA041'
		aRet[2] := 'CF2'
		aRet[3] := ""
		aRet[4] := STR0007
	Case cIdTreePos == "007"
		aRet[1] := 'FISA042'
		aRet[2] := 'CF5'
		aRet[3] := ""
		aRet[4] := STR0008

	Case cIdTreePos == "008"
		aRet[1] := 'FISA210'
		aRet[2] := 'F2Z'
		aRet[3] := "F2Z_ORIG == '1'"
		aRet[4] := STR0116//"Ajustes da Base de Cálculo de PIS e COFINS"

	Case cIdTreePos == "009"
		aRet[1] := 'FISA044'
		aRet[2] := 'CCY'
		aRet[3] := ""
		aRet[4] := STR0009
	Case cIdTreePos == "010"
		aRet[1] := 'FISA045'
		aRet[2] := 'CCW'
		aRet[3] := ""
		aRet[4] := STR0010
	Case cIdTreePos == "011"
		aRet[1] := 'FISA049'
		aRet[2] := 'CF9'
		aRet[3] := ""
		aRet[4] := STR0012
	Case cIdTreePos == "012"
		aRet[1] := 'FISA050'
		aRet[2] := 'CG4'
		aRet[3] := ""
		aRet[4] := STR0013

	Case cIdTreePos == "014"
		FISA005('CCZ')
		oTree:TreeSeek('000')

	Case cIdTreePos == "015"
		aRet[1] := 'FISA006'
		aRet[2] := 'CLG'
		aRet[3] := ""
		aRet[4] := STR0106
	Case cIdTreePos == "016" .And. Findfunction('FISA124') .And. AliasINdic('F0X')
		aRet[1] := 'FISA124'
		aRet[2] := 'F0X'
		aRet[3] := ""
		aRet[4] := STR0107
	Case cIdTreePos == "017"
		aRet[1] := 'FISA089'
		aRet[2] := 'CKN'
		aRet[3] := ""
		aRet[4] := STR0108
	Case cIdTreePos == "018"
		aRet[1] := 'FISA009'
		aRet[2] := 'F3F'
		aRet[3] := "F3F_TPREG=='1'"
		aRet[4] := STR0111
	Case cIdTreePos == "019"
		aRet[1] := 'FISa211'
		aRet[2] := 'F3N'
		aRet[3] := ""
		aRet[4] := "Recibos de Transmissão do SPED"
	Case cIdTreePos == "020"
		aRet[1] := 'FISA212'
		aRet[2] := 'F3U'
		aRet[3] := ""
		aRet[4] := STR0118
	Case cIdTreePos == "021"
		aRet[1] := 'FISA213'
		aRet[2] := 'F3V'
		aRet[3] := ""
		aRet[4] := STR0119
	Case cIdTreePos == "022"
		FISA008()
		oTree:TreeSeek('000')
	Case cIdTreePos == "023"
		aRet[1] := 'FISA216'
		aRet[2] := 'SFV'
		aRet[3] := ""
		aRet[4] := STR0124
	Case cIdTreePos == "024"
		aRet[1] := 'FISA217'
		aRet[2] := 'SFW'
		aRet[3] := ""
		aRet[4] := STR0125
	Case cIdTreePos == "025"
		aRet[1] := 'FISA316'
		aRet[2] := 'CJT'
		aRet[3] := ""
		aRet[4] := STR0126

	OtherWise
		aRet[1] := ""
		aRet[2] := ""
		aRet[3] := ""
		aRet[4] := ""
	EndCase

Return ( aRet )

//-------------------------------------------------------------------
/*/{Protheus.doc} ProcEFD()
Função que irá processar as informações da EFD Contribuições, irá chamar
as diversas funções, métodos, integrações para processamento de todas 
informações da EFD Contribuições.

@Param		oProcess - Objeto da classe FISXCLASS, que irá exibir a barra 
						de progresso da apuração
			aReprocess	- Array com informações das opções que deverá ser 
						  ou não reprocessadas.
@Return	lProcessou - Irá retornar se apuração foi processar corretamente,
						   sem erro ou cancelamento pelo usuário.							 
@author Erick G. Dias
@since 08/05/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function ProcEFD(oProcess,aReprocess,aParSX1,aSM0,lMain,aThread1,cNomeJob,lProcessou)

	Local lBlocI     := .F.
	Local lCPRB      := .F.
	Local lPisSal    := .F.
	Local lSocCoop   := .F.
	Local lProcCred  := .F.
	Local lDifer     := .F.
	Local lPFisEnt   := .T.
	Local lPFisSai   := .T.
	Local lPTitEnt   := .T.
	Local lPTitSai   := .T.
	Local lPATF      := .T.
	Local lPCupom    := .T.
	Local lPCPRB     := .T.
	Local lPOutros   := .T.
	Local lReprocess := .T.
	Local lCancel    := .F.
	Local lCupom     := .F.
	Local lindividu  := .F.
	Local lVendaFora := GetNewPar( 'MV_SPDGRNF' ,.F.)
	Local lTelSemLiv := GetNewPar( 'MV_ESTTELE' ,.F.)
	Local aAreaSM0   := {}
	Local aXFilial   := {}
	Local nMVM996TPR := GetNewPar( 'MV_M996TPR' ,.F.)
	Local nContFil   := 0
	Local nTotF100   := 0
	Local nBsConsorc := 0
	Local cRegime    := ''
	Local nContThr   := 0
	Local lErro      := .F.
	Local nX         := 0
	Local aDiaThread := {}
	Local nQtdThread := SuperGetMv("MV_QTDTAEC",.F.,0)
	Local aThread    := {}
	Local cFilialMat := FWGETCODFILIAL //Busca código da filial da filial logada, pois este código será gravado nas tabelas da apuração.
	Local lAjBase    := aParSX1[24]==2 // Dev./Canc. período anterior ?  1=Aju. Contribu. ,2=Aju. Base Calc.
	Local oAjustes
	Local oApurEnt
	local oApurSai
	local oCompCred
	Local oCPRB
	Local TimeInicio
	Local TimeFim
	Local oApurPIS
	Local oApurCOF
	Local mvAlqCprb  := GetNewPar( 'MV_CPRBALQ' , '' )
	Local cCodAtiviv := Substr(mvAlqCprb,1, At("/",mvAlqCprb)-1 )
	Local nAlqCprb   := val( Substr(mvAlqCprb,At("/",mvAlqCprb)+1, len(mvAlqCprb) ))
	Local aF100      := {}
	Local lCPRBNF    := GetNewPar( 'MV_CPRBNF' ,.F.) .And. SFT->(FieldPos("FT_VALCPB")) > 0 .And. SFT->(FieldPos("FT_BASECPB")) > 0 .And. SFT->(FieldPos("FT_ALIQCPB")) > 0
	Local cSPCBPSE   := GetNewPar("MV_SPCBPSE", '' )
	Local lCredPAgro := GetNewPar("MV_CPPCAGR",.F.)
	Local aMvSpcxCp1 := &( GetNewPar( "MV_SPCXCP1" , "{}" ) ) //NCM dos produtos adquiridos como insumos das receitas classificadas como crédito presumido.
	Local cMvEfdCP   := Substr(SpedPrSeq("MV_EFDCP","/{}"),2) //Utilizar quando não couber informações no parametro MV_SPCXCP1.
	Local aMvEfdCP   := {}
	Local aMvSpcxCp2 := &( GetNewPar( "MV_SPCXCP2" , "{}" ) ) //Alíquotas que serão utilizadas no cálculos dos ajustes de PIS e COFINS para crédito presumido.
	Local aMvSpcxCp3 := &( GetNewPar( "MV_SPCXCP3" , "{}" ) ) //NCM dos produtos classificados na tabela TIPI nos capítulos 2 a 4 e 15 a 16.
	Local cCtlDedRet := "" //Controle da função DeduzReten ("A" = processa Saldos e Retenção / "S" = Apenas saldos  /  "R" = Apenas retenções)
	Local IndF0X     := AliasINdic( 'F0X' )
	Local n          := 0
	Local cPrefixE1  := ''
	Local cCmpB1Dif  := ''
	Local cCmpA1Dif  := ''
	Local aParFiltr  := {}
	Local cAliasDIF  := ''
	Local cPerApur   := ''
	Local ObjF0T
	Local oDebBlcI
	Local nIcmsRec   := 0
	Local aICMS      := {}
	Local a1050      := {}
	Local aMVRLCSPD  := {}
	Local nReducao   := 0
	Local aRecBloco  := {}
	Local nTotRecCD  := 0
	Local nTotBlocos := 0
	Local nY         := 0
	Local cInfCompl  := "Ajuste de Base de Cálculo referente decisão judicial determinando a exclusão do ICMS a recolher."
	Local cInfComplA := ""
	Local nTotICMS   := 0
	Local lF2Z       := AliasIndic("F2Z")
	Local aAjuPISCOF := {}
	Local cCtaMx15   := GetNewPar("MV_CTAMX15","")
	Local lIntGTP    := FindFunction('GtpXFis') .And. GtpXFis(aParSX1[1], aParSX1[2])
	Local lCIE       := AliasIndic("CIE")
	Local dMVICMDSDT := StoD("")
	Local cTabDif    := "" // definir quais tabelas precessar no diferimento 1 - CFA / 2 - CFB / 3 ambos
	Local cSemaphore := 'AICMS' +Alltrim(Str(ThreadID()))
	Local aProcAICMS := {}
	Local lFirst	 := .T.
	Local oJSF100 	 := JsonObject():new()
	Local lDedIssBs  := GetNewPar("MV_DEISSBS",.F.) //Indica se o valor do ISS deve ser retirado da base de cálculo do PIS/COFINS/CSLL
	Local lDecPisCof := ("1" $ GetNewPar("MV_DECPSCF", "0"))
	Local lCtrl2Reg	 := .F.
	Local oNFSubs    := Nil as object
	Local oJSqlName  := Nil as object
	Local oJTamSX3   := Nil as object
	Local aFildF2Z as Array
	Local lF2ZALQ  as logical
	
	DEFAULT cNomeJob := cNomeJob
	DEFAULT lProcessou	:= .F.

	CLIVROAPU := aParSX1[3]

//Verifica se o processamento é com opção de gravação individualizada.
	lindividu	:= .F.
	If aParSX1[15] == 2
		lindividu	:= .T.
	EndIF
	If	"/" $ cMvEfdCP
		cMvEfdCP := STRTRAN(cMvEfdCP,"/{",",")
		cMvEfdCP := STRTRAN(cMvEfdCP,"},",",")
	Endif
	aMvEfdCP := &(cMvEfdCP)
	For n:=1 to len(aMvEfdCP)
		aadd(aMvSpcxCp1,aMvEfdCP[n])
	Next

	If nMVM996TPR == 3 .AND. aParSX1[6] == 4
		DbSelectArea ('SA1')
		If ! SA1->(FieldPos("A1_TPREG"))>0
			Alert(STR0036)//'O parâmetro MV_M996TPR está configurado para considerar o campo A1_TPREG, porém este campo não existe. Consulte Boletim técnico para consultar configurações.')
			Return
		EndIF
	EndIF

	IF Empty(aParSX1[1]) .OR. Empty(aParSX1[2])
		Alert(STR0035)//'Necessário informar datas do período a ser processado'
		Return
	EndIf

	//----------------------------------
	//VERIFICA O REGIME DE PIS E COFINS
	//----------------------------------
	If aParSX1[5] == 1 .OR. aParSX1[5] == 3
		IF aParSX1[6] == 1
			cRegime	:=	'1' //Não Cumulativo Competência
		ElseIF aParSX1[6] == 2
			cRegime	:=	'2' //Cumulativo Competência
		ElseIF aParSX1[6] == 3
			cRegime	:=	'3'	//Cumulativo Caixa
		ElseIF aParSX1[6] == 4
			cRegime	:=	'4'	//Cumulativo/Não Cumulativo
		EndIF
	EndIF

	lCtrl2Reg:= Ctrl2Reg(cRegime,nQtdThread)

	//----------------------------------------------------------
	//Se procesar PIS/COFINS +CPRB ou se processar somente CPRB
	//----------------------------------------------------------
	If aParSX1[5] == 2 .OR. aParSX1[5] == 3
		lCPRB	:= .T.	//Irá processar bloco P
	EndIF

	//-------------------------------------------------
	//Indica se irá processa PIS Sobre Folha de salário
	//-------------------------------------------------
	If aParSX1[7] == 1
		lPisSal	:= .T.
	EndIF

	//----------------------------------------------------------
	//Indica se irá processa PIS e COFINS Sociedade Cooperativa
	//----------------------------------------------------------
	If aParSX1[8] == 1
		lSocCoop	:= .T.
	EndIF

	//--------------------------------------------------------------------
	//Indica se irá processa PIS COFINS - Instituição Financeira - bloco I
	//--------------------------------------------------------------------
	If aParSX1[9] == 1
		lBlocI	:= .T.
	EndIF

	//--------------------------------------------------------------
	//Indica se irá processar valores de diferimento de PIS e COFINS
	//--------------------------------------------------------------
	If aParSX1[10] == 1
		lDifer	:= .T.
	EndIF

	//-----------------------------------------------
	//Indica se irá processar valores de cupom fiscal
	//-----------------------------------------------
	If aParSX1[11] == 1 .AND. cRegime <> '3'
		lCupom	:= .T.
	EndIF

	//---------------------------------------------------------------------------
	//Processa créditos se regime for Não Cumulativo ou Cumulativo/Não Cumulativo
	//---------------------------------------------------------------------------
	IF cRegime $ '1/4' .or. (!lBlocI .AND. cRegime <> '2')
		lProcCred	:= .T.
	EndIF

	If cRegime == '3'
		lProcCred	:= .F.
	EndIF
	aXFilial:= ASA001AFIL()

	//-----------------------------------------------------------------------------------
	//Verifica se aReprocess está preenchido, se não estiver então não se trata de reprocessamento.
	//Se estiver, então irá preencher as perguntas conforme as opções de reprocessamento
	//indicadas pelo usuário.
	//-----------------------------------------------------------------------------------
	If Len(aReprocess) > 0
		lReprocess	:= .T.
		lPFisEnt	:= Iif(aReprocess[1] == 1,.T.,.F.)
		lPFisSai	:= Iif(aReprocess[2] == 1,.T.,.F.)
		lPTitEnt	:= Iif(aReprocess[3] == 1,.T.,.F.)
		lPTitSai	:= Iif(aReprocess[4] == 1,.T.,.F.)
		lPATF		:= Iif(aReprocess[5] == 1,.T.,.F.)
		lPCupom		:= Iif(aReprocess[6] == 1,.T.,.F.)
		lPCPRB		:= Iif(aReprocess[7] == 1,.T.,.F.)
		lPOutros	:= .T.
	EndIF

	IF lMain

		//Chama função para limpar taela CF4 antes de popular
		ASA001DCF4(SubStr(DTos(aParSX1[1]),5,2)+SubStr(Dtos(aParSX1[1]),1,4))

		//Se for consolidado, então irá zerar aqui aqui todas as operações que foram
		//gravadas com xFilial da Matriz
		If !lindividu //Apuração Consolidada
			//Zera os créditos

			IniCred(aParSX1,aXFilial,cFilialMat)
			//Zera as deduções
			IniDeducao(aParSX1,aXFilial,cFilialMat)
			//Zera as retenções
			IniRetenca(aParSX1,aXFilial,cFilialMat)
			//Zera as tabelas da apuração
			IniTabApur(aParSX1,aXFilial,.T.,Len(aReprocess) > 0) //Limpa as tabelas de apuração e também as auxiliares

			If Len(aReprocess) >0
				If lMain .And. ValType(oProcess)=="O"
					oProcess:Inc2Progress('Reprocessando apuração')
					oProcess:Inc2Progress('Reprocessando apuração')
					If oProcess:Cancel()
						lCancel:=.T.
						//						Exit
					EndIf
				EndIF
				//Aqui chama as funções para realizar o reprocessamento
				ISA001CLA(aParSX1[1],aParSX1[2],,'2',aXFilial)
				ReprocEFD(aParSX1[1],aParSX1[2],'2',aReprocess,aXFilial)
			EndIF
		EndIF

	EndIF

	ProcLogAtu("MENSAGEM","Fim da Inicialização de Tabelas de Saldos - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

	//--------------------------------------------------------
	//AQUI IRÁ INICIAR AS DEMAIS THREADS CASO CONFIGURADO...
	//--------------------------------------------------------
	IF lMain .AND. nQtdThread > 0
		aDiaThread		:= A001DIATHR(nQtdThread+1,aParSX1[1], aParSX1[2])
		aThread		:= IniThread(aReprocess,aSM0,aParSX1,aDiaThread,nQtdThread)
		aParSX1[1]	:= aDiaThread[1][1]
		aParSX1[2]	:= aDiaThread[1][2]
	EndIF

	aAreaSM0 := SM0->(GetArea())
	DbSelectArea("SM0")
	//--------------------------------------------------------
	//Irá preencher aSM0 somente com as filiais selecionadas
	//pelo cliente
	//--------------------------------------------------------

	TimeInicio := Time()
	IF lMain .And. ValType(oProcess)=="O"
		oProcess:Set1Progress(len(aSM0)*2)
		oProcess:Set2Progress(1)
			/*"Inicio do processamento"*/
			/*"Fim do Processamento"*/
			/*"Tempo de processamento"*/
		oProcess:SetDetProgress(STR0037,TimeInicio,;
			STR0038,"" ,;
			STR0039,"" ,;
			"","")
	EndIF

	SM0->(RestArea(aAreaSM0))

	//--------------------------
	//Início do laçp das Filiais
	//--------------------------
	aAreaSM0 := SM0->(GetArea())

	//-----------------------------------------
	//Primeiro Bloco de Processamento:
	//- Inicialização das tabelas.
	//- Processamento das saídas/receitas.
	//-----------------------------------------
	For nContFil := 1 to Len(aSM0)

		IF lMain .And. ValType(oProcess)=="O"
			oProcess:Set2Progress(33)
		EndIF

		SM0->(DbGoTop ())
		SM0->(MsSeek (aSM0[nContFil][1]+aSM0[nContFil][2], .T.))	//Pego a filial mais proxima
		cFilAnt := FWGETCODFILIAL

		//--------------------------
		//Tratamento de SCP. Caso MV_PAR18 estiver preenchido como 03/04 então deverá processar somente sócia ostenciva
		//e desconsiderar sócia participante no processamento da apuração.
		//--------------------------
		IF mv_par18 $ '03/04' .AND. GetNewPar("MV_FILSCP",.F.)	//Sócia ostenciva
			//Aqui somente deverão ser gerados sócia ostenciva, ou seja, somente filial com parâmetro MV_FILSCP igual a .F.
			loop
		EndIF

		//Chama funcao para limpar a tabela CKX antes de popular caso exista o campo CKX_FILAPU
		If CKX->(FieldPos("CKX_FILAPU")) > 0
			ISA001CKX(aParSX1[1],aParSX1[2])
		EndIf

		If AliasIndic("F3Z")
			If F3Z->(FieldPos("F3Z_FILAPU")) > 0
				ISA001F3Z(aParSX1[1],aParSX1[2],aSM0)
			EndIf
		EndIf

		//Se for apuração individualizada, então irá atualizar array com o xFilial, para
		//que as informações sejam gravadas de maneira consolidada na matriz.
		IF lindividu
			aXFilial:= ASA001AFIL()

			//Chama função para limpar taela CF4 antes de popular
			ASA001DCF4(SubStr(DTos(aParSX1[1]),5,2)+SubStr(Dtos(aParSX1[1]),1,4))

			//Somente irá inicializar todas as tabelas se apuração for individualizada.
			//Se for consolidada a inicialização não será efetuada aqui.
			//Zera os créditos
			IniCred(aParSX1,aXFilial,cFilialMat)
			//Zera as deduções
			IniDeducao(aParSX1,aXFilial,cFilialMat)
			//Zera as retenções
			IniRetenca(aParSX1,aXFilial,cFilialMat)
			//Zera as tabelas da apuração
			IniTabApur(aParSX1,aXFilial,.T.,Len(aReprocess) > 0) //Limpa as tabelas de apuração e também as auxiliares

			If Len(aReprocess) >0
				If lMain .And. ValType(oProcess)=="O"
					oProcess:Inc2Progress('Reprocessando apuração')
					oProcess:Inc2Progress('Reprocessando apuração')
					If oProcess:Cancel()
						lCancel:=.T.
						Exit
					EndIf
				EndIF
				//Aqui chama as funções para realizar o reprocessamento
				ISA001CLA(aParSX1[1],aParSX1[2],,'2',aXFilial)
				ReprocEFD(aParSX1[1],aParSX1[2],'2',aReprocess,aXFilial)
			EndIF

		EndIF

		If lMain .And. ValType(oProcess)=="O"
			oProcess:Inc1Progress(STR0040 +FWGETCODFILIAL)//"Processando Filial"
			If oProcess:Cancel()
				lCancel:=.T.
				Exit
			EndIf
		EndIF

		//----------------------------------------------------
		//INICIA CLASSE DA APURAÇÃO E LIMPA TABELAS DO PERÍODO
		//----------------------------------------------------
		oApurSai := FISX001():New()
		oApurSai:SetDtIni(aParSX1[1])
		oApurSai:SetDtFin(aParSX1[2])
		oApurSai:SetLivro(aParSX1[3])
		oApurSai:SetRegApur(Str(aParSX1[6],1))
		oApurSai:SetFilial(aXFilial)
		oApurSai:SetPrcCPRB(lCPRB)
		oApurSai:SetFilApu(cFilialMat)
		oApurSai:SetRecBlc(aRecBloco)
		oApurSai:CargaNotaTecnica()

		nTotF100		:= 0
		nBsConsorc		:= 0

		//Se for consolidado, irá então inicializar/zerar as tabelas auxiliares
		If !lindividu //Consolidado
			oApurSai:ClearTab(TabAux(.T.))
		EndIF

		IF !Empty(cRegime) .AND. cRegime <> '3' .AND. !lBlocI

			//---------------------------------------------------------------------------
			//IRÁ PROCESSAR AS OPERAÇÕES DOS DOCUMENTOS DE SAÍDA GRAVADOS NO LIVRO FISCAL
			//---------------------------------------------------------------------------

			If lMain .And. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0043)//'Processando Notas Fiscais de Saída'
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EnDIF

			IF lPFisSai
				ProcLogAtu("MENSAGEM","Início do processamento Documento saídas - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001SFTSai(aParSX1[1], aParSX1[2], oApurSai, Iif(aParSX1[6] == 4, nMVM996TPR, 0), aParSX1[6], lCPRBNF, cSPCBPSE,IIf(valtype(MV_PAR20)=="N",MV_PAR20,2),aXFilial,cFilialMat,lindividu,aParSX1,lDecPisCof)
				ProcLogAtu("MENSAGEM","Fim do processamento Documento saídas - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			EndIF

			If lTelSemLiv .AND. lPFisSai

				If lMain .And. ValType(oProcess)=="O"
					oProcess:Inc2Progress(STR0103,STR0044)//'Processando Notas Fiscais Telecomunicação'
					If oProcess:Cancel()
						lCancel:=.T.
						Exit
					EndIf
				EndIf
				ProcLogAtu("MENSAGEM","Início do processamento Operações telecomunicações - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001TELECO(aParSX1[1], aParSX1[2], oApurSai,cRegime,nMVM996TPR,aParSX1[6])
				ProcLogAtu("MENSAGEM","Fim do processamento Operações telecomunicações - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

			EndIF

			If lVendaFora .AND. lPFisSai

				If lMain .And. ValType(oProcess)=="O"
					oProcess:Inc2Progress(STR0103,STR0045)//'Processando Vendas fora do Estabelecimento'
					If oProcess:Cancel()
						lCancel:=.T.
						Exit
					EndIf
				EndIF
				ProcLogAtu("MENSAGEM","Início processamento Vendas Fora do Estabelecimento - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001VFORA(aParSX1[1],aParSX1[2],oApurSai,cRegime,nMVM996TPR,aParSX1[6])
				ProcLogAtu("MENSAGEM","Fim processamento Vendas Fora do Estabelecimento - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

			EndIF
		EndIF

		//---------------------------------------------------------------------------
		//PROCESSA CUPOM FISCAL COM CÁLCULO DE PIS E COFINS
		//---------------------------------------------------------------------------
		If lCupom .AND. lPCupom

			If lMain .And. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0046)//'Processando Cupom Fiscal'
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF
			ProcLogAtu("MENSAGEM","Início processamento Cupom Fiscal - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			A001CUPOM(aParSX1[1],aParSX1[2],oApurSai,cRegime,aParSX1[3],aParSX1[6],nMVM996TPR)
			ProcLogAtu("MENSAGEM","Fim processamento Cupom Fiscal - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

		EndIF

		//---------------------------------------------------------------------------
		//PROCESSA BILHETES DE PASSAGEM SE INTEGRAÇÃO COM SIGAGTP ESTIVER ATIVA
		//---------------------------------------------------------------------------
		If lIntGTP

			If lMain .And. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,"Bilhetes de passagem - Integração GTP")//'Processando Cupom Fiscal'
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF

			ProcLogAtu("MENSAGEM","Início processamento bilhetes de passagem (GTP) - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			A001CUPOM(aParSX1[1],aParSX1[2],oApurSai,cRegime,aParSX1[3],aParSX1[6],nMVM996TPR, .T.)
			ProcLogAtu("MENSAGEM","Fim processamento bilhetes de passagem (GTP) - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

		EndIf

		If !Empty(cRegime) .AND. cRegime <> '3' .AND. !lBlocI

			If lMain .And. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0049)//'Processando Demais Documentos'
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF
			ProcLogAtu("MENSAGEM","Início processamento Demais Documentos - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			A001CF8(aParSX1,	oApurEnt,	oApurSai,lProcCred,@nTotF100,lPTitEnt,lPTitSai,"1",@nBsConsorc,lCPRBNF,cFilialMat)
			ProcLogAtu("MENSAGEM","Fim processamento Demais Documentos - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

		EndIF

		//Chama neste ponto o processamento dos títulos sem vínculo com documento fiscal?
		If lMain
			ProcLogAtu("MENSAGEM","Início pesquisa Títulos Financeiros - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			aF100:= FinSpdF100(Month(aParSX1[1]),Year(aParSX1[2]),,dtos(mv_par01),dtos(mv_par02),"F100")
			oJSF100[FWGETCODFILIAL]:=aF100
			ProcLogAtu("MENSAGEM","Início pesquisa Títulos Financeiros - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
		EndIF

		If !EmptY(cRegime) .AND. cRegime <> '3'  .AND. !lBlocI
			//----------------------------------------------------------
			//BUSCA INFORMAÇÕES DO FINANCEIRO REFERENTE AO REGISTRO F100
			//----------------------------------------------------------

			If lMain
				If ValType(oProcess)=="O"
					oProcess:Inc2Progress(STR0103,STR0048)//'Processando Títulos sem documento Fiscal'
					If oProcess:Cancel()
						lCancel:=.T.
						Exit
					EndIf
				EndIf
				ProcLogAtu("MENSAGEM","Início processamento Títulos Financeiros - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001F100Fi(aParSX1,	oApurEnt,	oApurSai,lProcCred,@nTotF100,lPTitEnt, lPTitSai,aParSX1[6],"1",aF100, lCPRBNF,cFilialMat)
				ProcLogAtu("MENSAGEM","Fim processamento Títulos Financeiros - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			EndIF
			If ExistBlock("SPDPIS09")
				ProcLogAtu("MENSAGEM","Início processamento SPDPIS09 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001PEF100(aParSX1,oApurSai,oApurEnt,lProcCred,lPTitEnt, lPTitSai,aParSX1[6],'1',cFilialMat)
				ProcLogAtu("MENSAGEM","Fim processamento SPDPIS09 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			Endif
		EndIF


		If lPisSal .and. lPOutros .AND. !lBlocI
			//--------------------------------------------------
			//PROCESSA VALORES REFERENTE AO PIS FOLHA DE SALÁRIO
			//--------------------------------------------------

			If lMain .And. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0056)//'Processando Pis Sobre Folha de Salário '
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF
			ProcLogAtu("MENSAGEM","Início processamento PIS Folha - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			A001FOLHA(aParSX1[1],aParSX1[2],oApurSai)
			ProcLogAtu("MENSAGEM","Fim processamento PIS Folha - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

		EndIF

		//-----------------------------
		//PROCESSA OPERAÇÕES DO BLOCO I
		//-----------------------------
		If lBlocI .AND. lMain

			If ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0041)//'Processando','Processando Operações de Instituições Financeiras'
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF

			ProcLogAtu("MENSAGEM","Início do processamento Instituição Financeira - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			A001BlocoI(aParSX1[1],aParSX1[2],oApurSai,aXFilial,cFilialMat)
			ProcLogAtu("MENSAGEM","Fim do processamento Instituição Financeira - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

		EndIF

		If ExistBlock("SPDPCIMOB") .and. lPOutros

			If lMain .And. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0055)//'Processando Ponto de Entrada SPDPCIMOB '

				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EnDIF

			ProcLogAtu("MENSAGEM","Início processamento SPDPCIMOB - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			A001IMOB(aParSX1[1],aParSX1[2],oApurSai,oApurEnt,lProcCred,aParSX1[6],.F.,.T.)
			ProcLogAtu("MENSAGEM","Fim processamento SPDPCIMOB - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

		EndIF

		IF cRegime == '3' .AND. !lBlocI

			If lMain

				If ValType(oProcess)=="O"
					oProcess:Inc2Progress(STR0103,STR0042) //'Processando Regime de Caixa'
					If oProcess:Cancel()
						lCancel:=.T.
						Exit
					EndIf
				EndIf

				dMVICMDSDT := GetNewPar('MV_ICMDSDT', StoD(""))

				ProcLogAtu("MENSAGEM","Início do processamento Regime de Caixa - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001CAIXA(aParSX1[1],aParSX1[2],oApurSai,aParSX1[3],aParSX1[12],aXFilial,lCPRBNF,cSPCBPSE,cFilialMat,lindividu,aParSX1, @aAjuPISCOF, dMVICMDSDT,lDedIssBs)
				ProcLogAtu("MENSAGEM","Fim do processamento Regime de Caixa - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

			EndIF

		EndIF

		aRecBloco	:= oApurSai:GetRecBlc()
		//------------------------------------------------------------------------------------------------
		//Aqui chamarei a função para buscar o valor do ICMS a recolher da apuração de ICMS desta filial
		//------------------------------------------------------------------------------------------------
		If (lMain) .And. ;
				!lindividu .AND. lF2Z .AND. aParSX1[22] == 2 .AND. Year(aParSX1[1]) >= 2019//DSERFIS1-15641 - tem que lançar nota no dia 20 e 3 threads configuradas retirada da variavel lmain, pois a função ICMSRecolher apesar de chamar o spedfiltro na CDH, nao passa data ate, so se baseia na data inicial trazendo todos os dados da apuração

			//Chama função para buscar icms a recolher da apuração do ICMS próprio
			nIcmsRec := ICMSRecolher(aParSX1[3], aParSX1[1], lastday(aParSX1[2]), "IC")

			//Busca os livros de sub apurações definidos no parâmetro MV_RLCSPD
			aMVRLCSPD:= &(GetNewPar('MV_RLCSPD',"{}"))
			For nX := 1 to Len(aMVRLCSPD)
				IF !Empty(aMVRLCSPD[nX,2])
					//Busca valores de ICMS a recolher das sub apurações
					nIcmsRec += ICMSRecolher(aMVRLCSPD[nX,2], aParSX1[1], lastday(aParSX1[2]), "IC")
				EndIF
			Next nX

			//Adiciona array com código da filial e seu respectivo valor de ICMS a recolher do período.
			aAdd(aICMS,{cFilAnt, nIcmsRec, SM0->M0_CGC, GetRecibo(aParSX1[1]), GetProcICMS(), 0 })

		EndIF


		//aRecBloco	:= oApurSai:GetRecBlc()
		//--------------------------
		//FINALIZA OBJETO DE SAÍDA
		//--------------------------
		oApurSai:Finaliza('1')

		if lCtrl2Reg
			SetR4RecB(cFilAnt,oApurSai)
		endif

	Next nContFil


	//-------------------------------------------------
	//FIM DO LAÇO DAS FILIAIS, RESTAURA A FILIAL LOGADA
	//-------------------------------------------------
	RestArea (aAreaSM0)
	cFilAnt := FWGETCODFILIAL


	//Obtem variavel Global para controde de AICMS
	//Caso não exista Cria variavel Global
	If nQtdThread > 0 .and. !lindividu .AND. lF2Z .AND. aParSX1[22] == 2 .AND. Year(aParSX1[1]) >= 2019
		IF lMain
			PutGlbVars("FISPROCICMS",aProcAICMS)

			For nX := 1 to Len(aICMS)
				nTotICMS += aICMS[nX][2]
			Next

			IF nTotICMS > 0
				PutGlbVars("FISAICMS",aICMS)
			Endif
		Else
			GetGlbVars("FISAICMS",@aICMS)
		Endif
	Endif

	//----------------------------------------------------------------------------------------------------------------------
	//Trecho que fará o rateio dos valores de ICMS a recolher, gerando ajsute de redução de base de cálculo de PIS e COFINS
	//----------------------------------------------------------------------------------------------------------------------
	If lF2Z .AND. aParSX1[22] == 2 .AND. Year(aParSX1[1]) >= 2019

		If lMain
			If ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,"Processando redução de base de cálculo de PIS e COFINS")//'Processando redução de base de cálculo de PIS e COFINS'
			EndIf
		Endif

		ProcLogAtu("MENSAGEM","Início do processamento redução de base de cálculo de PIS e COFINS - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

		//Totalizando as receitas dos blocos C e D (Receitas sujeitas ao ICMS)
		//Totalizando também a receita de todos os blocos A, C, D e F.
		aRecBloco	:= oApurSai:GetRecBlc()
		For nX := 1  to Len(aRecBloco)
			//Total das receitas sujeitas ao ICMS (blocos C e D)
			nTotRecCD	+= aRecBloco[nX][5] + aRecBloco[nX][6]

			//Total de todas as receitas (blocos A, C, D e F)
			nTotBlocos	+= aRecBloco[nX][4] + aRecBloco[nX][5] + aRecBloco[nX][6] + aRecBloco[nX][7]
		Next nX

		nPercRec	:= 100
		//Percorrer e obter os percentuais de rateio por CST e Regime
		For nX := 1  to Len(aRecBloco)

			//Para controlar eventuais diferenças de centavos, irei truncat os cálculos e descarregar eventuais diferenças no último item.
			//Desta forma a soma dos percentuais sempre bateram 100%
			IF aParSX1[23] == 1
				//Receita do CST dividido pelo total de todas as receitas
				aRecBloco[nx][8]	:= Round(((aRecBloco[nX][4] + aRecBloco[nX][5] + aRecBloco[nX][6] + aRecBloco[nX][7]) / nTotBlocos) * 100, 8)
			ElseIF aParSX1[23] == 2
				//Receita do CST dividido pelo total das receitas sujeitas ao ICMS
				aRecBloco[nx][8]	:= Round(((aRecBloco[nX][5] + aRecBloco[nX][6]) / nTotRecCD) * 100, 8)
			EndIF

			If aRecBloco[nx][8] < nPercRec
				nPercRec -= aRecBloco[nx][8]
			Else
				aRecBloco[nx][8] := nPercRec
				nPercRec	:= 0
			EndIF

		Next nX


		//Incluido pausa na thread quando utilizado Multthread
		//Esta pausa se ocorre pelo motivo do array aICMS não possuir valor equiparado a receita da Thread, gerando problema na redução da base
		//Array aICMS sempre possui valor total do ICMS no periodo, já a receita da Thread possui apenas dados de alguns dias.
		//Esta pausa visa atualizar aICMS conforme for sendo abatido nas Threads
		If  nQtdThread > 0

			IF Len(aICMS) > 0 .and. Iif(lMain, nTotICMS > 0, .T.)

				GetGlbVars("FISPROCICMS",@aProcAICMS)
				Aadd(aProcAICMS,{Threadid(),nTotRecCD,nTotBlocos,.F.})
				PutGlbVars("FISPROCICMS",aProcAICMS)

				While .T.
					IPCWaitEx( cSemaphore, 2000 )
					GetGlbVars("FISPROCICMS",@aProcAICMS)

					IF lMain .and. lFirst // Aguarda Todas as Threads estarem no array
						//verifica se Quantidade de Threads ativas no EFD é a mesma acumulada
						IF Len(CheckThread()) + 1 == Len(aProcAICMS)
							GetGlbVars("FISPROCICMS",@aProcAICMS)
							//conout(TIME() + ' SegunGetUserInfoArray( [ lShowMoreInfo* ] )dos: '+Str(Seconds())+ '- 1 Chegou na ultima Thread: '+Alltrim(Str(ThreadID())))
							nTotRecCD  := nTotBlocos := 0

							// Ordena as Threads para processar primeiro a de maior valor de receita
							IF aParSX1[23] == 1
								Asort(aProcAICMS,,,{|x,y|x[3]>y[3]})
							ElseIF aParSX1[23] == 2
								Asort(aProcAICMS,,,{|x,y|x[2]>y[2]})
							Endif

							//Soma todas as receitas
							For nX := 1  to Len(aProcAICMS)
								nTotRecCD  += aProcAICMS[nX][2]
								nTotBlocos += aProcAICMS[nX][3]
							Next nX

							//Atualiza todas as Threads com novo valor
							For nX := 1  to Len(aProcAICMS)
								aProcAICMS[nX] := {aProcAICMS[nX][1],nTotRecCD,nTotBlocos,.T.}
							Next nX

							PutGlbVars("FISPROCICMS",aProcAICMS)
							Sleep(1000)
							GetGlbVars("FISPROCICMS",@aProcAICMS)
							lFirst := .F.
						Else
							Sleep(5000)
						Endif
					Endif

					//Processa Primeira Thread da lista
					IF aProcAICMS[1][4] .and. aProcAICMS[1][1] == ThreadID()
						//Conout(TIME() + ' Segundos: '+Str(Seconds())+ '- 2 Thread Em processamento: '+Alltrim(Str(ThreadID())))
						GetGlbVars("FISAICMS",@aICMS)

						nPercRec	:= 100
						//Percorrer e obter os percentuais de rateio por CST e Regime
						For nX := 1  to Len(aRecBloco)

							//Para controlar eventuais diferenças de centavos, irei truncat os cálculos e descarregar eventuais diferenças no último item.
							//Desta forma a soma dos percentuais sempre bateram 100%
							IF aParSX1[23] == 1
								//Receita do CST dividido pelo total de todas as receitas
								aRecBloco[nx][8]	:= Round(((aRecBloco[nX][4] + aRecBloco[nX][5] + aRecBloco[nX][6] + aRecBloco[nX][7]) / aProcAICMS[1][3] /*nTotBlocos*/) * 100, 8)
							ElseIF aParSX1[23] == 2
								//Receita do CST dividido pelo total das receitas sujeitas ao ICMS
								aRecBloco[nx][8]	:= Round(((aRecBloco[nX][5] + aRecBloco[nX][6]) / aProcAICMS[1][2] /*nTotRecCD*/) * 100, 8)
							EndIF

							If aRecBloco[nx][8] < nPercRec
								nPercRec -= aRecBloco[nx][8]
							Else
								aRecBloco[nx][8] := nPercRec
								nPercRec	:= 0
							EndIF

						Next nX

						Exit
					Endif

					//conout(TIME() + ' Segundos: '+Str(Seconds())+ '- 0 Thread em Espera: '+Alltrim(Str(ThreadID())))
				Enddo
			Endif
		Endif

		IF Len(aRecBloco) > 0
			//Instancia classe de ajustes da EFD
			oAjustes 	:= AJUSTEEFD():New()
			oAjustes:SetFilial(aXFilial)
			oAjustes:SetFilApu(cFilialMat)
			oAjustes:SetDtIni(aParSX1[1])
			oAjustes:LoadCKS(.T.) // Chama a LoadCKS para montar os arrays considerando base de cálculo

			//Laço nos valores de ICMS obtidos por filial, valores que foram obtidos da apuração de ICMS de cada filial selecioanda
			For nX := 1 to Len(aICMS)

				//Força atualização da CKS quando valor houve ajuste de redução de base
				//para evitar problema de arredondamento, mesmo que em outra thread.
				IF (nQtdThread > 0 .and. aICMS[nX][6] > 0  .and. aICMS[nX][2] > 0 .and. Len(aRecBloco) > 0)
					oAjustes:SetAtuaCKS(.T.)
				Else
					oAjustes:SetAtuaCKS(.F.)
				Endif

				//Verifica se existe valor de ICMS a recolher no período.
				//Quando for MultThread e não possuir mais valor a descontar deve processar CKS para evitar problemas de arredondamento.
				If aICMS[nX][2] > 0

					nTotICMS	:= aICMS[nX][2] - aICMS[nX][6]

					//Precisamos percorrer os valores de receitas separados por CST e Regime, para obter os percentuais
					For nY := 1 to Len(aRecBloco)

						//Aplica percentual no valor total do ICMS da filial
						nReducao	:= Round((aICMS[nX][2] * aRecBloco[nY][8]) / 100, 2)

						If nReducao < nTotICMS
							nTotICMS -= nReducao
						Else
							nReducao := nTotICMS
							nTotICMS	:= 0
						EndIF

						//Se existe código da contribuição e se o CST for diferente de 03 então fará o ajuste
						IF !Empty(aRecBloco[nY][2]) .AND. aRecBloco[nY][1] <> "03"

							//Verifica se o código da contribuição é tributado, para estes casos será necessário fazer ajuste
							//de redução de base de cálculo.
							If aRecBloco[nY][2] $ "01/02/31/51/52"

								cInfComplA := cInfCompl

								//Recibo do SPED Fiscal
								IF !Empty(aICMS[nX][4])
									cInfComplA += " Número do Recibo do Sped Fiscal " + Alltrim(aICMS[nX][4]) + ". "
								EndIF

								//Número do Processo
								IF !Empty(aICMS[nX][5])
									cInfComplA += " Número do Processo " + Alltrim(aICMS[nX][5]) + ". "
								EndIF

								//Ajuste de redução de base de cálculo de PIS
								AjuBasICMS(oAjustes, DEBITO, aRecBloco[nY][2], REDUCAO, nReducao, ;
									"21", aICMS[nX][5], cInfComplA, aParSX1[1], cCtaMx15, ;
									aICMS[nX][3], cInfCompl, PIS, aRecBloco[nY][2],	aRecBloco[nY][1])

								//Ajuste de redução de base de cálculo de COFINS
								AjuBasICMS(oAjustes, DEBITO, aRecBloco[nY][2], REDUCAO, nReducao, ;
									"21", aICMS[nX][5], cInfComplA, aParSX1[1], cCtaMx15, ;
									aICMS[nX][3], cInfCompl, COFINS, aRecBloco[nY][2],	aRecBloco[nY][1])

							EndIF

						EndIF

						Proc1050(@a1050, aRecBloco[nY][1], nReducao, aICMS[nX][3], aICMS[nX][4], cInfCompl, aICMS[nX][2], aRecBloco[nY][3])

					Next nY

				EndIF

				//Atualiza variavel Global
				IF nQtdThread > 0 .and. GetGlbVars("FISAICMS",aICMS)
					//Guarda Valor do ajuste
					aICMS[nX][6] += oAjustes:GetVlAjGrv()
					PutGlbVars("FISAICMS",aICMS)
				Endif
				oAjustes:SetAtuaCKS(.F.)

			Next nX

			//-------------------------------------------------------------
			//Faz gravação dos informações do registro 1050 na tabela F3P
			//-------------------------------------------------------------
			//-------------------------------------------------------------------------
			//Faz gravação do detalhamento das receitas sujeitas e não sujeitas ao ICMS
			//-------------------------------------------------------------------------
			If Len(a1050) > 0 .AND. Len(aRecBloco) > 0
				X001GRVF3O(aRecBloco, FirstDate(aParSX1[1]), "2", cVAlToChar(aParSX1[23])) // As tabelas F3O e F3P responsaveis pelo reg1050 devem ser geradas com data inicial do periodo, pos na geração do arquivo é esperado o dia inicial. e nao as datas de cada thread.
				X001GRVF3P(a1050, FirstDate(aParSX1[1]), "2")
			EndIF

			//Destrói o objeto do ajuste
			FreeObj(oAjustes)
			oAjustes:= NIL
		Endif

		//Libera Função para uso
		IF nQtdThread > 0
			GetGlbVars("FISPROCICMS",@aProcAICMS)
			IF Len(aProcAICMS) > 0
				ADEL(aProcAICMS, 1)
				aSize(aProcAICMS,Len(aProcAICMS)-1)
				PutGlbVars("FISPROCICMS",aProcAICMS)
				//conout(TIME() + ' Segundos: '+Str(Seconds())+ '- 3 - Thread liberada: '+Alltrim(Str(ThreadID())))
			Endif
		Endif

		ProcLogAtu("MENSAGEM","Início do processamento redução de base de cálculo de PIS e COFINS - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
	EndIF

	IF !lMain .and. lCtrl2Reg
		PutGlbValue(cNomeJob,"4") //Finalizei o processamento da saída
		while !killapp()
			if IPCWaitEx( cNomeJob, 2000 )
				exit
			endif
		enddo
	Endif

	//Preciso fazer este laço nas filiais para processar as devoluções de compras e cancelamentos de períodos anteriores, para fazer
	//ajustes de base de cálculo. Preciso ajustar a base aqui antes de processar os créditos, a base da contribuição precisa ser
	//ajustada antes de processar os créditos, se não teria que refazer todos os créditos e retenções novamente a cada ajuste de base.
	IF lF2Z .AND. !lBlocI .AND. aParSX1[5] <> 2 .AND. Year(aParSX1[1])>= 2019

		If lAjBase //Se os estorno de cancelamentos e devoluções de períodos anteriores estiverem como ajuste de base, chamarei as funções abaixo

			For nContFil := 1 to Len(aSM0)

				IF lMain .And. ValType(oProcess)=="O"
					oProcess:Set2Progress(33)
				EndIF

				SM0->(DbGoTop ())
				SM0->(MsSeek (aSM0[nContFil][1]+aSM0[nContFil][2], .T.))	//Pego a filial mais proxima
				cFilAnt := FWGETCODFILIAL
				If lIndividu
					aXFilial:= ASA001AFIL()
				EndIf

				//Chamo a função para processar ajuste de base de cálculo, com exceção do CST 03
				ASA001CANC(aParSX1[1], aParSX1[2],cRegime,aParSX1[3],aXFilial,aParSX1[6], "3")
				//Devolução venda período anterior
				ASA001Devo(aParSX1[1], aParSX1[2],aParSX1[3],'S',nMVM996TPR,cRegime,.F.,aXFilial,FISCALENT,lCPRBNF,cSPCBPSE,"3",lAjBase) //Devolução de Venda

			Next nContFil
		EndIF
	EndIF

	if lMain .and. lCtrl2Reg
		WaitThre(aThread)
	endif
	//--------------------------------------------------------
	//Segundo Bloco de Processamento:
	//- Processamento dos creditos, ajustes, deducoes, etc...
	//--------------------------------------------------------
	For nContFil := 1 to Len(aSM0)

		IF lMain .And. ValType(oProcess)=="O"
			oProcess:Set2Progress(33)
		EndIF

		SM0->(DbGoTop ())
		SM0->(MsSeek (aSM0[nContFil][1]+aSM0[nContFil][2], .T.))	//Pego a filial mais proxima
		cFilAnt := FWGETCODFILIAL

		//-----------------------------------------------------------------
		//Se for apuracao individualizada refaço a carga das filiais pois
		//o conteudo do array aXFilial sera o da ultima filial processada
		//no bloco 1.
		//-----------------------------------------------------------------
		If lIndividu
			aXFilial:= ASA001AFIL()
		EndIf

		If lMain
			oApurPIS	:= APURPISCOF():New()
			oApurPIS:SetRegime(aParSX1[6])
			oApurPIS:SetFilial(aXFilial)
			oApurPIS:SetFilApu(cFilialMat)
			//Passa data inicial
			oApurPIS:SetDtIni(aParSX1[1])
			//Passa Data Final
			oApurPIS:SetDtFim(aParSx1[2])
			//Apura o PIS do período
			oApurPIS:Apurar(PIS)

			IF cRegime == '4' .AND. Len(aThread) > 0
				oApurPIS:RatBrut(aXFilial)
			EndIF

			//Carrega as informações no objeto
			//oApurPIS:LoadApurPC(PIS)

			//------------------------------------
			// CRIA OBJETO DA COFINS PARA APURAÇÃO
			//------------------------------------
			//Cria objeto da apuração para a COFINS

			oApurCof	:= APURPISCOF():New()
			oApurCof:SetRegime(aParSX1[6])
			oApurCof:SetFilial(aXFilial)
			oApurCof:SetFilaPU(cFilialMat)
			//Passa data inicial
			oApurCof:SetDtIni(aParSX1[1])
			//Passa Data Final
			oApurCof:SetDtFim(aParSx1[2])
			//Apura o PIS do período
			oApurCof:Apurar(COFINS)
		EndIf

		//--------------------------------------------------------------------------------------------------------------
		//Tratamento de SCP. Caso MV_PAR18 estiver preenchido como 03/04 então deverá processar somente sócia ostenciva
		//e desconsiderar sócia participante no processamento da apuração.
		//--------------------------------------------------------------------------------------------------------------
		IF mv_par18 $ '03/04' .AND. GetNewPar("MV_FILSCP",.F.)	//Sócia ostenciva
			//Aqui somente deverão ser gerados sócia ostenciva, ou seja, somente filial com parâmetro MV_FILSCP igual a .F.
			Loop
		EndIF

		If lMain .And. ValType(oProcess)=="O"
			oProcess:Inc1Progress(STR0040 +FWGETCODFILIAL)//"Processando Filial"
			If oProcess:Cancel()
				lCancel:=.T.
				Exit
			EndIf
		EndIF

		//Todo processamento da thread main deve ter a data inicial e final conforme a quantidade de threads configuradas, não pode ter o mês inteiro
		IF lMain .AND. nQtdThread > 0
			aParSX1[1]	:= aDiaThread[1][1]
			aParSX1[2]	:= aDiaThread[1][2]
		EndIF

		//--------------------------------------------
		//INICIALIZA CLASSE PARA APURAÇÃO DOS CRÉDITOS
		//--------------------------------------------
		oApurEnt := FISX001():New()
		oApurEnt:SetFilial(aXFilial)
		oApurEnt:SetDtIni(aParSX1[1])
		oApurEnt:SetDtFin(aParSX1[2])
		oApurEnt:SetLivro(aParSX1[3])
		oApurEnt:SetRegApur(Str(aParSX1[6],1))
		oApurEnt:SetFilApu(cFilialMat)

		mvAlqCprb	:= GetNewPar('MV_CPRBALQ','')
		cCodAtiviv 	:= Substr(mvAlqCprb,1,  At("/",mvAlqCprb)-1  )
		nAlqCprb 	:= val( Substr(mvAlqCprb,At("/",mvAlqCprb)+1,  len(mvAlqCprb)  ))

		//Aqui será efetuado a dedução da CPRB, referente a parcela de receitas de consórcios cadastrados na rotina demais documentos
		IF lCPRB .AND. !empty(cCodAtiviv) .AND. nBsConsorc >0 .AND. nAlqCprb > 0

			oCPRB	:= CPRBEFD():New()
			oCPRB:SetDtIni(aParSX1[1])
			oCPRB:SetFilApu(cFilialMat)

			oCPRB:DeduzBase(cCodAtiviv,nAlqCprb,nBsConsorc)
			FreeObj(oCPRB)
			oCPRB:= nil

		EndIF

		oApurEnt:LoadRecBru()
		oApurEnt:cfgParamPres( aMvSpcXCp1 )

		IF lProcCred
			if lCtrl2Reg
				oApurEnt:SetRecBTo(GetR4RecB(cFilAnt))
			endif
			//-----------------------------------------------------------------------------------
			//PROCESSA VALORES DE PIS E COFINS DOS DOCUMENTOS DE ENTRADA GRAVADOS NO LIVRO FISCAL
			//-----------------------------------------------------------------------------------

			If lMain .And. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0047)//'Processando Documentos de Entrada'
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF

			IF lPFisEnt
				ProcLogAtu("MENSAGEM","Início processamento Documentos de Entrada - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001SFTEnt(aParSX1[1], aParSX1[2],	oApurEnt,lCPRBNF,aXFilial,lDecPisCof)
				ProcLogAtu("MENSAGEM","Fim processamento Documentos de Entrada - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			EndIF
			If lMain .And. IndF0X
				A001Suced(aParSX1[1], aParSX1[1],	oApurEnt)
			EndIf

		EndIF

		//Chama neste ponto o processamento dos títulos sem vínculo com documento fiscal.
		If lMain
			ProcLogAtu("MENSAGEM","Início pesquisa Títulos Financeiros - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

			if !oJSF100:GetJsonValue(FWGETCODFILIAL, @aF100) //Se não encontrar a filial no JSON
				aF100:= FinSpdF100(Month(aParSX1[1]),Year(aParSX1[2]),,dtos(mv_par01),dtos(mv_par02),"F100")
			endif

			ProcLogAtu("MENSAGEM","Início pesquisa Títulos Financeiros - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
		EndIF

		If !EmptY(cRegime) .AND. cRegime <> '3' .AND. !lBlocI

			//----------------------------------------------------------
			//BUSCA INFORMAÇÕES DO FINANCEIRO REFERENTE AO REGISTRO F100
			//----------------------------------------------------------

			If lMain

				If ValType(oProcess)=="O"
					oProcess:Inc2Progress(STR0103,STR0048)//'Processando Títulos sem documento Fiscal'
					If oProcess:Cancel()
						lCancel:=.T.
						Exit
					EndIf
				EndIF

				ProcLogAtu("MENSAGEM","Início processamento Títulos Financeiros - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001F100Fi(aParSX1,	oApurEnt,	oApurSai,lProcCred,@nTotF100,lPTitEnt, lPTitSai,aParSX1[6],"2",aF100, lCPRBNF,cFilialMat)
				ProcLogAtu("MENSAGEM","Fim processamento Títulos Financeiros - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

			EndIF

		EndIF

		//--------------------------------------------------------
		//PROCESSA VALORES DOS CRÉDITOS E DÉBITOS DE PIS E COFINS
		//GRAVADOS NA TABELA CF8 - DEMAIS DOCUMENTOS
		//--------------------------------------------------------

		If !Empty(cRegime) .AND. cRegime <> '3' .AND. !lBlocI

			If lMain .And. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0049)//'Processando Demais Documentos'
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF

			ProcLogAtu("MENSAGEM","Início processamento Demais Documentos - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			A001CF8(aParSX1,	oApurEnt,	oApurSai,lProcCred,@nTotF100,lPTitEnt,lPTitSai,"2",@nBsConsorc,lCPRBNF,cFilialMat)
			ProcLogAtu("MENSAGEM","Fim processamento Demais Documentos - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

		EndIF

		IF lProcCred .AND. !lBlocI

			//------------------------------------------------------------------
			//PROCESSA OPERAÇÕES DE ABERTRA DE ESTOQUE COM DIREITO AO CRÉDITO
			//------------------------------------------------------------------

			If lMain

				If ValType(oProcess)=="O"
					oProcess:Inc2Progress(STR0103,STR0050)//'Processando Estoque de Abertura'
					If oProcess:Cancel()
						lCancel:=.T.
						Exit
					EndIf
				EndIF

				If lPOutros
					ProcLogAtu("MENSAGEM","Início processamento Estoque de Abertura - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
					A001AbeEst(aParSX1[1],aParSX1[2],oApurEnt)
					ProcLogAtu("MENSAGEM","Fim processamento Estoque de Abertura - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				EndIF

			EndIF

			//-------------------------------------------------------------------------
			//PROCESSA VALORES DOS CRÉDITOS DE PIS E COFINS DE ATIVO FIXO - DEPRECIAÇÃO
			//-------------------------------------------------------------------------

			If lMain .And. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0051)//'Processando Bens por Depreciação'
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF

			If lPATF .AND. lMain
				ProcLogAtu("MENSAGEM","Início processamento Bem Depreciação - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001F120(firstday(aParSX1[1]), LastDay(aParSX1[2]),	oApurEnt,(aParSX1[15]==2),cfilialMat,lDecPisCof)
				ProcLogAtu("MENSAGEM","Fim processamento Bem Depreciação - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			EndIF

			//-----------------------------------------------------------------------
			//PROCESSA VALORES DOS CRÉDITOS DE PIS E COFINS DE ATIVO FIXO - AQUISIÇÃO
			//-----------------------------------------------------------------------

			If lMain .And. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0052)//'Processando bens por aquisição'
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF

			If lPATF .and. lMain
				ProcLogAtu("MENSAGEM","Início processamento Bem Aquisição - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001F130(firstday(aParSX1[1]), LastDay(aParSX1[2]),	oApurEnt,(aParSX1[15]==2),cFilialMat,lDecPisCof)
				ProcLogAtu("MENSAGEM","Início processamento Bem Aquisição - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			EndIF

		EndIF

		//------------------------------------------------------------------------
		//PROCESSA VALORES DO PIS E COFINS COM ORIGEM DO PONTO DE ENTRADA SPDPIS09
		//------------------------------------------------------------------------
		If ExistBlock("SPDPIS09")

			If lMain .And. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0053)//'Processando Ponto de Entrada SPDPIS09 '
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF

			ProcLogAtu("MENSAGEM","Início processamento SPDPIS09 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			A001PEF100(aParSX1,oApurSai,oApurEnt,lProcCred,lPTitEnt, lPTitSai,aParSX1[6],'2',cFilialMat)
			ProcLogAtu("MENSAGEM","Fim processamento SPDPIS09 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

		EndIF

		//------------------------------------------------------------------------
		//PROCESSA VALORES DE DÉBITOS DE PIS E COFINS DO PONTO DE ENTRADA SPDPisTr
		//------------------------------------------------------------------------
		If ExistBlock("SPDPisTr") .and. lPOutros

			If lMain .And. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0054)//'Processando Ponto de Entrada SPDPisTr '
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF

			ProcLogAtu("MENSAGEM","Início processamento SPDPisTr - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			A001PISSTR(aParSX1[1],aParSX1[2],oApurSai,aParSX1[6])
			ProcLogAtu("MENSAGEM","Fim processamento SPDPisTr - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

		EndIF

		If ExistBlock("SPDPCIMOB") .and. lPOutros

			If lMain .And. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0055)//'Processando Ponto de Entrada SPDPCIMOB '

				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EnDIF

			ProcLogAtu("MENSAGEM","Início processamento SPDPCIMOB - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			A001IMOB(aParSX1[1],aParSX1[2],oApurSai,oApurEnt,lProcCred,aParSX1[6],.T.,.F.)
			ProcLogAtu("MENSAGEM","Fim processamento SPDPCIMOB - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

		EndIF

		//--------------------------------------------------
		//PROCESSA VALORES REFERENTE CRÉDITO PRESUMIDO
		//--------------------------------------------------
		If lCredPAgro .And. cRegime <> '3'
			ProcLogAtu("MENSAGEM","Início processamento crédito presumido conforme lei 12.058/2009 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			F100Presu(aParSX1[1],aParSX1[2],aParSX1[3],oApurEnt,nTotF100,cFilialMat,lindividu)
			ProcLogAtu("MENSAGEM","Fim processamento crédito presumido conforme lei 12.058/2009 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
		EndIf

		IF lMain .And. ValType(oProcess)=="O"
			oProcess:Inc2Progress(STR0103,STR0057)//'Finalizando operações de entradas e saídas'
			If oProcess:Cancel()
				lCancel:=.T.
				Exit
			EndIf
		EndIF

		//FreeObj(oApurSai)
		//oApurSai:= nil
		//--------------------------
		//FINALIZA OBJETO DE ENTRADA
		//--------------------------
		oApurEnt:Finaliza('2')
		//FreeObj(oApurent)
		//oApurent:= nil
		//Faz os estornos das devoluções do próprio período

		IF lMain .And. ValType(oProcess)=="O"
			oProcess:Inc2Progress(STR0103,STR0058 )//'Devoluções de venda período atual'
			If oProcess:Cancel()
				lCancel:=.T.
				Exit
			EndIf
		EndIF

		IF lPFisEnt .AND. !lBlocI
			ProcLogAtu("MENSAGEM","Início processamento Devolução Venda período atual - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			ASA001Devo(aParSX1[1], aParSX1[2],aParSX1[3],'S',nMVM996TPR,cRegime,.T.,aXFilial,FISCALENT,lCPRBNF,cSPCBPSE,,lAjBase) //Devolução de Venda
			ProcLogAtu("MENSAGEM","Fim processamento Devolução Venda período atual - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
		EndIF

		IF lMain .And. ValType(oProcess)=="O"
			oProcess:Inc2Progress(STR0103,STR0059)//'Devoluções de compra período atual'
			If oProcess:Cancel()
				lCancel:=.T.
				Exit
			EndIf
		EndIF

		IF lPFisSai .AND. !lBlocI
			ProcLogAtu("MENSAGEM","Início processamento Devolução Compra período atual - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			ASA001Devo(aParSX1[1], aParSX1[2],aParSX1[3],'E',nMVM996TPR,cRegime,.T.,aXFilial,FISCALSAI,lCPRBNF,cSPCBPSE,,lAjBase) //Devolução de COmpra
			ProcLogAtu("MENSAGEM","Fim processamento Devolução Compra período atual - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
		EndIF

		//---------------------------------------------------------------------
		//Irá processar ajustes de redução de contribuição vinda do Financeiro
		//---------------------------------------------------------------------
		If lMain .AND. cRegime <> '3' .AND. !lBlocI .AND. FindFunction("FinSpdM220")

			ProcLogAtu("MENSAGEM","Início processamento Ajuste de kredução Tìtulo Financeiro - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

			oAjustes 	:= AJUSTEEFD():New()
			oAjustes:SetFilial(aXFilial)
			oAjustes:SetFilApu(cFilialMat)
			oAjustes:SetDtIni(aParSX1[1])
			oAjustes:LoadCKS()
			oAjustes:SetCrdDeb(DEBITO)

			oApurSai:SetRegApur(cRegime)
			ProcAjuFin( MV_PAR01, MV_PAR02, oAjustes, oApurSai)

			FreeObj(oAjustes)
			oAjustes:= NIL
			ProcLogAtu("MENSAGEM","Fim processamento Ajuste de redução Tìtulo Financeiro - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
		EndiF

		IF lMain .And. ValType(oProcess)=="O"
			oProcess:Inc2Progress(STR0103,STR0060)//'Ajustes de créditos manuais'
			If oProcess:Cancel()
				lCancel:=.T.
				Exit
			EndIf
		EndIf

		IF lProcCred .AND. !lBlocI .AND. aParSX1[15] == 2
			//-------------------------------------------
			//PROCESSA VALORES DE AJUSTES DE PIS E COFINS
			//-------------------------------------------
			oAjustes 	:= AJUSTEEFD():New()
			oAjustes:SetFilial(aXFilial)
			oAjustes:SetDtIni(aParSX1[1])
			oAjustes:SetFilApu(cFilialMat)
			oAjustes:LoadCL8()
			ProcLogAtu("MENSAGEM","Início processamento Ajustes CF5 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			A001AjuCF5(aParSX1[1],aParSX1[2],oAjustes)
			ProcLogAtu("MENSAGEM","Fim processamento Ajustes CF5 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			FreeObj(oAjustes)
			oAjustes:= NIL
		EndIF

		//-------------------------------------------------------------------------------
		//PROCESSA VALORES DE DIFERIMENTO DE PIS E COFINS
		//-------------------------------------------------------------------------------
		IF lDifer .and. lMain .AND. !lBlocI

			If ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0061)//'Processando diferimento de PIS e COFINS'
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIf


			If ISA001NDIF() //Se habilitou parâmetro para processar o diferimento dentro da própria apuração.

				//Deverá processar a gravação da CFA e CFB
				cCmpB1Dif	:=	GetNewPar("MV_B1M996","")
				cCmpA1Dif	:=	GetNewPar("MV_A1M996","")
				cPrefixE1	:=	GetNewPar("MV_1DUPREF","SF2->F2_SERIE")
				aParFiltr	:=	{mv_par01,mv_par02,cCmpB1Dif,cCmpA1Dif,cPrefixE1}
				cPerApur	:=	Substr(DTOS(mv_par01),5,2)+Substr(DTOS(mv_par01),1,4)

				ObjF0T		:= TABELAF0T():New()
				//Executa filtro e chama funcao que ira gravar as Informacoes de Diferimento
				If FSA001QRYD(1,"SE1",@cAliasDIF,aParFiltr) //Chama função para realizar query de diferimento dos títulos

					FSA001PRCD(mv_par01,mv_par02,cPerApur,mv_par03,cAliasDIF,;
						cRegime,,,,,;
						,,cPrefixE1,cCmpB1Dif,cCmpA1Dif,;
						"SE1",.F.,mv_par18,ObjF0T,.F.,aXFilial,lDedIssBs)

				Endif

				//Fecha query
				FSA001QRYD(2,,cAliasDIF)

				//Mata objeto
				FreeObj(ObjF0T)
				ObjF0T	:= Nil

				ObjF0T		:= TABELAF0T():New()
				//Executa filtro e chama funcao que ira gravar as Informacoes de Diferimento
				If FSA001QRYD(1,"CF8",@cAliasDIF,aParFiltr) //Chama função para realizar query de diferimento dos demais documentos

					FSA001PRCD(mv_par01,mv_par02,cPerApur,mv_par03,cAliasDIF,;
						cRegime,,,,,;
						,,cPrefixE1,cCmpB1Dif,cCmpA1Dif,;
						"CF8",.F.,mv_par18,ObjF0T,.F.,aXFilial,lDedIssBs)

				Endif

				//Fecha alias
				FSA001QRYD(2,,cAliasDIF)

				//Mata objeto
				FreeObj(ObjF0T)
				ObjF0T	:= Nil

				cTabDif := IIf(lindividu, "3", "2") // T=Processa CFA e CFB, F=Processa só CFB

				ProcLogAtu("MENSAGEM","Início processamento Diferimento PIS COFINS - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001Difer(mv_par01,mv_par02,aXFilial,cTabDif)
				ProcLogAtu("MENSAGEM","Fim processamento Diferimento PIS COFINS - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)



				A001DifCPB(mv_par01, mv_par02, aXFilial, aParSX1)

			Else
				//Mantem processamento legado, ou seja, ainda o processamento realizado pela FISA054.
				ProcLogAtu("MENSAGEM","Início processamento Diferimento PIS COFINS - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001Difer(mv_par01,mv_par02,aXFilial,"3")
				ProcLogAtu("MENSAGEM","Fim processamento Diferimento PIS COFINS - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			EndIF



		EndIF

		//-------------------------------------------------------------------------------
		//PARA PROCESSAR ESTAS INFORMAÇÕES SERÁ NECESSÁRIO REALIZAR APURAÇÃO ANTES
		//-------------------------------------------------------------------------------

		IF lMain .and. ValType(oProcess)=="O"
			oProcess:Inc2Progress(STR0103,STR0063)//'Atualizando apuração'
			If oProcess:Cancel()
				lCancel:=.T.
				Exit
			EndIf
		EndIF

		//ATÉ AQUI SÃO OPERAÇÕES SEM CONCORRÊNCIA
		//A PARTIR DESTE PONTO A THREAD PRINCIPAL IRÁ FINALIZAR

		If lMain
			For nX := 1 to Len(aThread)

				If ValType(oProcess)=="O"
					oProcess:Set2Progress(100)
					nContThr	:= 0
					oProcess:Inc1Progress('Finalizando a Thread '+ aThread[nX][1],)//'Apuração Finalizada com Sucesso'
				EndIf
				While .T.
					IF nContThr == 100
						If ValType(oProcess)=="O"
							oProcess:Set2Progress(100)
							nContThr	:= 0
						EndIF
					EndIF
					IF GetGlbValue( aThread[nX][1] ) == '0'
						If ValType(oProcess)=="O"
							//conout('Thread ' + aThread[nX][1] + ' ainda processando')
							oProcess:Inc2Progress('Processando...','')//'Apuração Finalizada com Sucesso'
						EndIf
					ElseIF GetGlbValue( aThread[nX][1] ) == '1'
						ProcLogAtu("MENSAGEM","Thread " + aThread[nX][1]  + " Finalizada com Sucesso! " + Time(),,cNomeJob)
						Exit
					ElseIF GetGlbValue( aThread[nX][1] ) == '2'
						ProcLogAtu("ERRO","Ocorreu erro na Thread " + aThread[nX][1] +" "   + Time(),,cNomeJob)
						lErro	:= .T.
						Exit
					EndIF
					nContThr++
					Sleep(500)
				EndDo

			Next nX

			//Consolidação das Threads
			IF  Len(aThread) > 0
				AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'CKZ')
				AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'CKS')
				AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'CL8')
				AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'CL9')
				//AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'CLA')
				AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'CKR')
				AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'CKT')
				AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'CKU')
				AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'CL0')
				AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'CL3')
				//Agrupa CPRB quando for processado por nota.
				IF lCPRBNF
					AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'CKX')
					AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'CKV')
				Endif
				IF AliasINdic('F3J')
					//Se a tabela F3J existir, então deverá ser consolidada também
					AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'F3J')
				EndIF
				IF AliasINdic('CIC')
					//Verifico se a tabela CIC existe antes de realizar a consolidação
					AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'CIC')
				EndIF
				IF AliasINdic('F2Z')
					//Verifico se a tabela F2Z existe antes de realizar a consolidação
					AgrupaThr(MV_PAR01+1, MV_PAR02, MV_PAR01,'2', 'F2Z')
				EndIF
			EndIf

			aParSX1[1]	:= MV_PAR01
			aParSX1[2]	:= MV_PAR02

		EndIF

		If lMain

			IF lMain .AND. !lBlocI .AND. aParSX1[5] <> 2

				If ValType(oProcess)=="O"
					oProcess:Inc2Progress(STR0103,STR0064)//'Processando Cancelamentos períodos anteriores'
					If oProcess:Cancel()
						lCancel:=.T.
						Exit
					EndIf
				EndIF

				//---------------------------------------------------------------------------------
				//PROCESSA AS NOTAS CANCELADAS NO PERÍODO QUE FORAM EMITIDAS EM PERÍODOS ANTERIORES
				//---------------------------------------------------------------------------------
				ProcLogAtu("MENSAGEM","Início processamento Notas Canceladas período anterior - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

				If lF2Z .AND. aParSX1[24] == 2 .AND. Year(aParSX1[1])>= 2019
					//Neste caso somente deo chamar esta função para processar eventuais ajustes do CST 03
					ASA001CANC(aParSX1[1], aParSX1[2],cRegime,aParSX1[3],aXFilial,aParSX1[6], '2')
				Else
					//Aqui mantem todos ajustes da contribuição normal
					ASA001CANC(aParSX1[1], aParSX1[2],cRegime,aParSX1[3],aXFilial,aParSX1[6], '1')
				EndIF

				ProcLogAtu("MENSAGEM","Fim processamento Notas Canceladas período anterior - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

			EndIF

			IF lMain .AND. !lBlocI .And. aParSX1[15] == 2
				//-------------------------------------------
				//PROCESSA VALORES DE AJUSTES DE PIS E COFINS
				//-------------------------------------------
				oAjustes 	:= AJUSTEEFD():New()
				oAjustes:SetFilial(aXFilial)
				oAjustes:SetFilApu(cFilialMat)
				oAjustes:SetDtIni(aParSX1[1])
				oAjustes:LoadCKS()
				ProcLogAtu("MENSAGEM","Início processamento Ajustes de Débito CF5 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001AjuCF5(aParSX1[1],aParSX1[2],oAjustes,.T.)
				ProcLogAtu("MENSAGEM","Fim processamento Ajustes de Débito CF5 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				FreeObj(oAjustes)
				oAjustes:= NIL
			EndIF
			IF lMain .and. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0065)//'Processando devoluççoes de venda período anterior'
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF

			IF lPFisEnt .AND. !lBlocI
				//---------------------------------------------------
				//PROCESSA AS DEVOLUÇÕES DE VENDA DE PERÍODO ANTERIOR
				//---------------------------------------------------
				ProcLogAtu("MENSAGEM","Início processamento Devoluções de Venda período anterior  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				If lF2Z .And. aParSX1[24] == 2 .AND. Year(aParSX1[1])>= 2019
					ASA001Devo(aParSX1[1], aParSX1[2],aParSX1[3],'S',nMVM996TPR,cRegime,.F.,aXFilial,FISCALENT,lCPRBNF,cSPCBPSE,"2",lAjBase) //Devolução de Venda
				Else
					ASA001Devo(aParSX1[1], aParSX1[2],aParSX1[3],'S',nMVM996TPR,cRegime,.F.,aXFilial,FISCALENT,lCPRBNF,cSPCBPSE,"1",lAjBase) //Devolução de Venda
				EndIF

				ProcLogAtu("MENSAGEM","Fim processamento Devoluções de Venda período anterior  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			ElseIf lBlocI

				oDebBlcI:= COMPDEBITO():New()
				oDebBlcI:SetFilial(aXFilial)
				oDebBlcI:SetDtIni(aParSX1[1])
				oDebBlcI:AtuDebito(CUMULAT,PIS)
				oDebBlcI:AtuDebito(CUMULAT,COFINS)
				FreeObj(oDebBlcI)
				oDebBlcI	:= nil

			EndIF

			IF lMain .and. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0066)//'Processando devoluççoes de compra período anterior'
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF

			IF lPFisSai .AND. !lBlocI .And. aParSX1[15] == 2
				//---------------------------------------------------
				//PROCESSA AS DEVOLUÇÕES DE COMPRA DE PERÍODO ANTERIOR
				//---------------------------------------------------
				ProcLogAtu("MENSAGEM","Início processamento Devoluções de Compra período anterior  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				ASA001Devo(aParSX1[1], aParSX1[2],aParSX1[3],'E',nMVM996TPR,cRegime,.F.,aXFilial,FISCALSAI,lCPRBNF,cSPCBPSE,,lAjBase) //Devolução de COmpra
				ProcLogAtu("MENSAGEM","Início processamento Devoluções de Compra período anterior  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			EndIF

			If  EmpTy(alltrim(GetNewPar('MV_CPRBALQ',''))) .AND. lCPRB .AND. lPCPRB .AND. lMain
				//------------------------
				//PROCESSA VALORES DA CPRB
				//------------------------
				If ValType(oProcess)=="O"
					oProcess:Inc2Progress(STR0103,STR0071)//'Buscando Informações da CPRB'
					oProcess:Inc2Progress('Processando Informações da CPRB',STR0072)//'Processando Informações da CPRB'
					oProcess:Inc2Progress(STR0103,STR0071)//'Buscando Informações da CPRB'
					oProcess:Inc2Progress('Processando Informações da CPRB',STR0072)//'Processando Informações da CPRB'
					If oProcess:Cancel()
						lCancel:=.T.
						Exit
					EndIf
				EndIf
				If !lCPRBNF
					ProcLogAtu("MENSAGEM","Início Processamento da CPRB  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
					A001CPRB(aParSX1[1],aParSX1[2],aXFilial,nTotF100,cFilialMat,lindividu)
					ProcLogAtu("MENSAGEM","Fim Processamento da CPRB  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				Endif
			EndIF

			IF lMain .and. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0073)//'Encerrando processamento da filial'
				If oProcess:Cancel()
					lCancel:=.T.
					Exit
				EndIf
			EndIF

			IF lProcCred .AND. aParSX1[15] == 2 //Se for geração individualizada, então deverá processar para cada filial.
				//---------------------------------------------------------------------------------
				//APÓS TODOS AJUSTES/REDUÇÃO/DIFERIMENTO DOS CRÉDITOS E DÉBITOS, PROCESSAR CRÉDITOS
				//---------------------------------------------------------------------------------
				ProcLogAtu("MENSAGEM","Início Apuração de PIS  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				IF lMain .and. ValType(oProcess)=="O"
					oProcess:Inc2Progress(STR0103,STR0069)//'Finalizando apuração de PIS'
					If oProcess:Cancel()
						lCancel:=.T.
						Exit
					EndIf
				EndIF

				oCompCred	:= CMPCREDITO():New()
				oCompCred:SetFilial(aXFilial)
				oCompCred:SetFilApu(cFilialMat)
				oCompCred:SetDtIni(aParSX1[1])
				oCompCred:DedCred('1')
				ProcLogAtu("MENSAGEM","Fim Apuração de PIS  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

				ProcLogAtu("MENSAGEM","Início Apuração de COFINS  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				IF lMain .and. ValType(oProcess)=="O"
					oProcess:Inc2Progress(STR0103,STR0070)//'Finalizando apuração de COFINS'
					If oProcess:Cancel()
						lCancel:=.T.
						Exit
					EndIf
				EndIF
				oCompCred	:= CMPCREDITO():New()
				oCompCred:SetFilial(aXFilial)
				oCompCred:SetDtIni(aParSX1[1])
				oCompCred:SetFilApu(cFilialMat)
				oCompCred:DedCred('2')
				ProcLogAtu("MENSAGEM","Fim Apuração de COFINS  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			EndIF

			IF aParSX1[15] == 2
				//Indic aqui se deverá buscar valores de créditos para próimo período
				oApurPIS:setPCrdFut(lProcCred)
				oApurCof:setPCrdFut(lProcCred)

				//Carrega as informações atualizadas da apuração
				oApurPIS:LoadApurPC(PIS)

				//Carrega as informações atualizadas da apuração
				oApurCof:LoadApurPC(COFINS)
			EndIF

			//-------------------------------------------------------------------------------
			//PROCESSA VALORES DE RETENÇÃO NA FONTE DE PIS E DA COFINS
			//-------------------------------------------------------------------------------
			IF lMain .And. IIf(!Empty(mv_par19), mv_par19 == 1, .T.)
				If ValType(oProcess)=="O"
					oProcess:Inc2Progress(STR0103,STR0067)//'Processando Retenções na fonte de PIS e COFINS'
					If oProcess:Cancel()
						lCancel:=.T.
						Exit
					EndIf
				EndIf
				//-----------------------------------------
				//PROCESSA OS VALORES DE RETENÇÃO NA FONTE.
				//-----------------------------------------
				ProcLogAtu("MENSAGEM","Início processamento Retenções na Fonte PIS COFINS  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001F600(aParSX1[1],oApurPis,oApurCof,aXFilial,cFilialMat,lIndividu)
				ProcLogAtu("MENSAGEM","Fim processamento Retenções na Fonte PIS COFINS  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

				FSA001CLG(aParSX1[1], aParSX1[2])

				IF aParSX1[15] == 2
					cCtlDedRet := "A" // Processa saldo e retenção
					DeduzReten(aParSX1[1],aParSX1[2],aXFilial,oApurPis,oApurCof,cCtlDedRet)
				EndIF

			EndIF

			//Chama função que processará as informações da exigibilidade suspensa
			If lCIE .AND. Year(aParSX1[1]) >= 2020 .and. !cRegime == '3'

				//Processa exigibilidade suspensa para as notas fiscais
				ExigibSusp(oApurSai, nMVM996TPR,aParSX1[1],aParSX1[2], "NF", .F.,aParSX1[3])

				If lCupom .AND. lPCupom
					//Processa a exigibilidade suspensa para os cupons fiscais
					ExigibSusp(oApurSai, nMVM996TPR,aParSX1[1],aParSX1[2], "CUPOM", .F.,aParSX1[3])
				EndIF

				If lIntGTP
					//Processa a exigibilidade suspensa para as movimentações de intergração com SIGAGTP
					ExigibSusp(oApurSai, nMVM996TPR,aParSX1[1],aParSX1[2], "CUPOM", .T.,aParSX1[3])
				EndIF

			EndIF

		EndIF

	Next nContFil

//Mata objeto
	FreeObj(oJSF100)
	oJSF100	:= Nil

	//--------------------------------------------------------
	//Terceiro Bloco de Processamento:
	//- Processamentos adicionais
	//--------------------------------------------------------
	For nContFil := 1 to Len(aSM0)

		IF lMain .And. ValType(oProcess)=="O"
			oProcess:Set2Progress(33)
		EndIF

		SM0->(DbGoTop ())
		SM0->(MsSeek (aSM0[nContFil][1]+aSM0[nContFil][2], .T.))	//Pego a filial mais proxima
		cFilAnt := FWGETCODFILIAL

		IF lPFisSai .AND. !lBlocI .And. aParSX1[15] == 1 .And. lMain
			//--------------------------------------------------------------------------------------
			//PROCESSA AS DEVOLUÇÕES DE COMPRA DE PERÍODO ANTERIOR PARA GERAÇÃO DE FORMA CONSOLIDADA
			//--------------------------------------------------------------------------------------
			ProcLogAtu("MENSAGEM","Início processamento Devoluções de Compra período anterior  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			ASA001Devo(aParSX1[1], aParSX1[2],aParSX1[3],'E',nMVM996TPR,cRegime,.F.,aXFilial,FISCALSAI,lCPRBNF,cSPCBPSE,,lAjBase) //Devolução de COmpra
			ProcLogAtu("MENSAGEM","Início processamento Devoluções de Compra período anterior  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
		EndIF

	Next nContFil

	//-------------------------------------------------
	//FIM DO LAÇO DAS FILIAIS, RESTAURA A FILIAL LOGADA
	//-------------------------------------------------
	RestArea (aAreaSM0)
	cFilAnt := FWGETCODFILIAL

	If lMain


		//-------------------------------------------------------------------------------
		//PROCESSA VALORES DE DIFERIMENTO DE PIS E COFINS
		//-------------------------------------------------------------------------------
		IF ISA001NDIF() .AND. !lindividu .AND. lDifer .and. lMain .AND. !lBlocI
			cTabDif := "1" // Processa CFA

			ProcLogAtu("MENSAGEM","Início processamento Diferimento PIS COFINS - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			A001Difer(mv_par01,mv_par02,aXFilial,cTabDif)
			ProcLogAtu("MENSAGEM","Fim processamento Diferimento PIS COFINS - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

		EndIF

		IF lSocCoop .AND. lMain .AND. !lBlocI

			If ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0062)//'Processando Sociedade Cooperativa'
			EndIF

			//-------------------------------------------------------------------------------
			//PROCESSA AS INFORMAÇÕES DE SOCIEDADE COOPERATIVA GRAVADAS NA TABELA CE9 PARA
			//REDUZIR A BASE DE CÁLCULO DA CONTRIBUIÇÃO
			//-------------------------------------------------------------------------------
			ProcLogAtu("MENSAGEM","Início processamento Sociedade Cooperativa - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			oDebito:= COMPDEBITO():New() 	//Cria Objeto da Classe COMPDEBITO
			oDebito:SetFilial(aXFilial)
			oDebito:SetDtIni(aParSX1[1])   	//Passa data de referência
			oDebito:SetFilApu(cFilialMat)
			oDebito:AtuSocCoop('1') //atualiza os valores de sociedade cooeprativa para regime não cumulatico
			oDebito:AtuSocCoop('2') //atualiza os valores de sociedade cooeprativa para regime  cumulatico
			FreeObj(oDebito)
			oDebito:= NIL
			ProcLogAtu("MENSAGEM","Fim processamento Sociedade Cooperativa - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

		EndIF

		//Ajustes de redução da contribuição no regime de caixa.
		IF cRegime == '3' .AND. !lBlocI
			//Faz chamada de ajustes de redução da contribuição nas situações de alteração de regime de competência para caixa
			AjuAltRegCx(aAjuPISCOF, aXFilial, aParSX1[1], DEBITO)
		EndIF

		IF lMain .AND. !lBlocI .And. aParSX1[15] == 1
			//-------------------------------------------
			//PROCESSA VALORES DE AJUSTES DE PIS E COFINS
			//-------------------------------------------
			oAjustes 	:= AJUSTEEFD():New()
			oAjustes:SetFilial(aXFilial)
			oAjustes:SetFilApu(cFilialMat)
			oAjustes:SetDtIni(aParSX1[1])
			oAjustes:LoadCKS()
			ProcLogAtu("MENSAGEM","Início processamento Ajustes de Débito CF5 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			A001AjuCF5(aParSX1[1],aParSX1[2],oAjustes,.T.)
			ProcLogAtu("MENSAGEM","Fim processamento Ajustes de Débito CF5 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			FreeObj(oAjustes)
			oAjustes:= NIL
		EndIF

		//Preciso fazer este laço nas filiais para processar as devoluções de compras e cancelamentos de períodos anteriores, para fazer
		//ajustes de base de cálculo. Preciso ajustar a base aqui antes de processar os créditos, a base da contribuição precisa ser
		//ajustada antes de processar os créditos, se não teria que refazer todos os créditos e retenções novamente a cada ajuste de base.
		IF lF2Z .And. lMain .AND. !lBlocI .AND. aParSX1[5] <> 2 .AND. Year(aParSX1[1])>= 2019

			//Aqui irá processar os ajustes da base de cálculo de PIS e COFINS
			oAjustes := AJUSTEEFD():New()
			oAjustes:SetFilial(aXFilial)
			oAjustes:SetFilApu(cFilialMat)
			oAjustes:SetDtIni(aParSX1[1])
			oAjustes:LoadCKS(.T.) // Chama a LoadCKS para montar os arrays considerando base de cálculo

			//Chama função para buscar informações de eventuais saldos da CF3
			ASA001DANT(aParSX1[1],oAjustes,oAjustes,"S",aXFilial,"3")

			aAreaSM0 := SM0->(GetArea())
			aFildF2Z := FildF2Z(@lF2ZALQ)
			For nContFil := 1 to Len(aSM0)

				SM0->(DbGoTop ())
				SM0->(MsSeek (aSM0[nContFil][1]+aSM0[nContFil][2], .T.))	//Pego a filial mais proxima
				cFilAnt := FWGETCODFILIAL

				ProcLogAtu("MENSAGEM","Início processamento Lctos. Ajustes Base de Calculo PIS e COFINS - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				ASA001SUBS(aParSX1, aXFilial, oApurSai, nMVM996TPR, @oNFSubs, @oJSqlName, @oJTamSX3, aFildF2Z, lF2ZALQ)
				A001CTESUBS(aParSX1, aXFilial, oApurEnt, oApurSai, nMVM996TPR, @oJSqlName, @oJTamSX3, aFildF2Z, lF2ZALQ)
				ProcLogAtu("MENSAGEM","Fim processamento Lctos. Ajustes Base de Calculo PIS e COFINS - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

			Next nContFil

			FwFreeArray( aFildF2Z )
			FreeObj( oNFSubs )
			FreeObj( oJSqlName )
			FreeObj( oJTamSX3 )

			RestArea (aAreaSM0)
			cFilAnt := FWGETCODFILIAL

			AjBaseCalc(aParSX1[1], aParSX1[2], oAjustes)
			oAjustes:AtuCKR("1")
			oAjustes:AtuCKR("2")
			FreeObj(oAjustes)
			oAjustes:= NIL

		EndIF

		IF lProcCred .AND. aParSX1[15] == 1 //Se for geração de forma consolidada, então irá processar apuração somente uma vez.
			//---------------------------------------------------------------------------------
			//APÓS TODOS AJUSTES/REDUÇÃO/DIFERIMENTO DOS CRÉDITOS E DÉBITOS, PROCESSAR CRÉDITOS
			//---------------------------------------------------------------------------------
			IF lMain .and. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0074)//'Finalizando apuração de PIS'
				If oProcess:Cancel()
					lCancel:=.T.
					return .F.
				EndIf
			EndIF

			IF lProcCred .AND. !lBlocI
				//-------------------------------------------
				//PROCESSA VALORES DE AJUSTES DE PIS E COFINS
				//-------------------------------------------
				oAjustes 	:= AJUSTEEFD():New()
				oAjustes:SetFilial(aXFilial)
				oAjustes:SetFilApu(cFilialMat)
				oAjustes:SetDtIni(aParSX1[1])
				oAjustes:LoadCL8()

				//Processamento do estorno de créditos da Agro Indústria
				IF GetNewPar('MV_ESTCRDA',"") $ "1/2" .AND. AliasIndic("F3U") .AND. AliasIndic("F3V")
					EstCrdAgro( Year2Str(aParSX1[1]) + Month2Str(aParSX1[1]) , oAjustes, aParSX1[2])
				EndIF

				ProcLogAtu("MENSAGEM","Início processamento Ajustes CF5 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001AjuCF5(aParSX1[1],aParSX1[2],oAjustes)
				ProcLogAtu("MENSAGEM","Fim processamento Ajustes CF5 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				FreeObj(oAjustes)
				oAjustes:= NIL
			EndIF

			IF lProcCred .and. len( aMvSpcXCp1 ) > 0 .and. len( aMvSpcXCp2 ) > 0
				//-------------------------------------------
				//PROCESSA VALORES DE AJUSTES DE PIS E COFINS
				//-------------------------------------------
				oAjustes 	:= AJUSTEEFD():New()
				oAjustes:SetFilial(aXFilial)
				oAjustes:SetFilaPU(cFilialMat)
				oAjustes:SetDtIni(aParSX1[1])
				oAjustes:SetDtRefer(aParSX1[1])
				oAjustes:LoadCL8()

				ProcLogAtu("MENSAGEM","Início processamento Presumido - Lei 12.350/2010 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

				A001AjuPresumido( aParSX1 , oAjustes , aMvSpcXCp1 , aMvSpcXCp2 , aMvSpcXCp3 , cRegime , aXFilial , cFilialMat )

				ProcLogAtu("MENSAGEM","Fim processamento Presumido - Lei 12.350/2010 - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

				FreeObj(oAjustes)
				oAjustes:= NIL
			EndIF

		EndIF

		If aParSX1[15] == 1 .And. (lProcCred .Or. (!lBlocI .And. cRegime == '2')) //DSERFIS1-14706

			ProcLogAtu("MENSAGEM","Início atualização valor de PIS  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			oCompCred	:= CMPCREDITO():New()
			oCompCred:SetFilial(aXFilial)
			oCompCred:SetFilApu(cFilialMat)
			oCompCred:SetDtIni(aParSX1[1])
			oCompCred:DedCred('1')
			ProcLogAtu("MENSAGEM","Fim atualização valor de PIS  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			IF lMain .and. ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0075)//'Processando' - 'Finalizando apuração de COFINS'
				If oProcess:Cancel()
					lCancel:=.T.
					return .F.
				EndIf
			EndIF
			ProcLogAtu("MENSAGEM","Início atualização valor de COFINS - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			oCompCred	:= CMPCREDITO():New()
			oCompCred:SetFilial(aXFilial)
			oCompCred:SetFilApu(cFilialMat)
			oCompCred:SetDtIni(aParSX1[1])
			oCompCred:DedCred('2')
			ProcLogAtu("MENSAGEM","Início atualização valor de COFINS  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

			//Indic aqui se deverá buscar valores de créditos para próimo período
			oApurPIS:setPCrdFut(lProcCred)
			oApurCof:setPCrdFut(lProcCred)
		EndIf

		IF !lCancel


			//Carrega as informações atualizadas da apuração
			oApurPIS:LoadApurPC(PIS)

			//Carrega as informações atualizadas da apuração
			oApurCof:LoadApurPC(COFINS)

			// Processa saldos
			IF aParSX1[15] <> 2
				cCtlDedRet := "S" // S = Processa saldos
				DeduzReten(aParSX1[1],aParSX1[2],aXFilial,oApurPis,oApurCof,cCtlDedRet)
			EndIF

			If lProcCred
				FreeObj(oCompCred)
				oCompCred:= Nil
			EndIF

		EndIF

		IF lMain
			aAreaSM0 := SM0->(GetArea())

			If ValType(oProcess)=="O"
				oProcess:Inc2Progress(STR0103,STR0068)//'Processando Outras Deduções'
			EndIf

			For nContFil := 1 to Len(aSM0)

				SM0->(DbGoTop ())
				SM0->(MsSeek (aSM0[nContFil][1]+aSM0[nContFil][2], .T.))	//Pego a filial mais proxima
				cFilAnt := FWGETCODFILIAL

				ProcLogAtu("MENSAGEM","Início processamento Outros Débitos PIS COFINS  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
				A001F700(aParSX1[1],str(aParSX1[6],1),oApurPIS,oApurCof,aXFilial,cFilialMat)
				ProcLogAtu("MENSAGEM","Fim processamento Outros Débitos PIS COFINS  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)

				// Processa retenções
				IF aParSX1[15] <> 2
					cCtlDedRet := "R" // R = Processa rentenções
					DeduzReten(aParSX1[1],aParSX1[2],aXFilial,oApurPis,oApurCof,cCtlDedRet)
				EndIF

			Next nContFil
			RestArea (aAreaSM0)
			cFilAnt := FWGETCODFILIAL
		EndIF

		IF !lCancel
			FreeObj(oApurPIS)
			oApurPIS:= Nil
			FreeObj(oApurCOF)
			oApurCOF:= Nil
		EndIF

		//---------------------------
		//PROCESSA OS AJUSTES DA CPRB
		//---------------------------
		IF lCPRB .AND.  lPCPRB .AND. lMain
			ProcLogAtu("MENSAGEM","Início do Processamento dos Ajustes da CPRB  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
			AjusteCPRB(aParSX1[1],aParSX1[2],aSM0,cFilialMat,lindividu)
			ProcLogAtu("MENSAGEM","Fim do Processamento dos Ajustes da CPRB  - Filial " + FWGETCODFILIAL + " " + Time(),,cNomeJob)
		EndIF

		//Atuliza Percentuais De ICMS na F3O
		IF  lMain .and. nQtdThread > 0
			X001ATUF3O(aParSX1)
		Endif

		IF lMain .and. ValType(oProcess)=="O"
			oProcess:Set2Progress(1)
			oProcess:Inc2Progress('Concluindo.','')//'Apuração Finalizada com Sucesso'
			oProcess:Set1Progress(Len(aThread)+1)
			oProcess:Inc1Progress('Finalizando as demais Threads iniciadas',)//Apuração Finalizada com Sucesso'
		EndIF

		IF lMain .and. ValType(oProcess)=="O"
			//Fim da consolidação das Threads
			oProcess:Set1Progress(1)
			oProcess:Inc1Progress(STR0076,)//'Apuração Finalizada com Sucesso'
			oProcess:Set2Progress(1)
			oProcess:Inc2Progress("","")
		EndIf

		IF lCancel .Or. lErro
			DisarmTransaction()
			Alert(Iif(lCancel,"Operação Cancelada!" ,"Verifique o Log de processamento, houveram erros no processamento de Thread." )  ) //'Apuração Finalizada com Sucesso'
		Else
			lProcessou	:= .T.
			TimeFim := Time()
			IF lMain .and. ValType(oProcess)=="O"
				oProcess:Set2Progress(1)
			/*"Inicio do processamento"*/
			/*"Fim do Processamento"*/
			/*"Tempo de processamento"*/
				oProcess:SetDetProgress(STR0037,TimeInicio,;
					STR0038,TimeFim ,;
					STR0039,ELAPTIME(TimeInicio,TimeFim) ,;
					"","")
			EndIF

			MsgInfo(Iif( lReprocess,"Apuração Processada com Sucesso",STR0077)) //'Apuração Finalizada com Sucesso'

		EndIF
	EndIF

//Limpa variaveis globais
	IF lMain
		IF GetGlbVars("FISAICMS")
			ClearGlbValue("FISAICMS")
		Endif
		IF  GetGlbVars("FISPROCICMS")
			ClearGlbValue("FISPROCICMS")
		Endif
		if lCtrl2Reg
			aAreaSM0 := SM0->(GetArea())
			For nContFil := 1 to Len(aSM0)

				SM0->(DbGoTop ())
				SM0->(MsSeek (aSM0[nContFil][1]+aSM0[nContFil][2], .T.))	//Pego a filial mais proxima
				cFilAnt := FWGETCODFILIAL

				ClearGlbValue("FISRECBRUTA"+cFilAnt)

			Next nContFil
			RestArea (aAreaSM0)
			cFilAnt := FWGETCODFILIAL
		endif


	Endif

Return lProcessou

//-------------------------------------------------------------------
/*/{Protheus.doc} A001AbeEst()
Função que irá buscar valores de abertura de estoque para gerar os créditos
de PIS e COFINS 

@param	dDataDe	- Data inicial do período de apuração
		oApurEnt	-Objeto já criado para apurar os valores dos créditos

@author Erick G. Dias
@since 14/04/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001AbeEst(dDataDe,dDataAte,oApurEnt)

	local cAliasCF9	:= ''
	Local cSlctCF9	:= ''
	Local cMesIng		:= ''
	Local dDtIng		:= firstday(dDataDe)
	Local nCont		:= 0
	Local nQtdMesAnt	:= 12
	Local dDtLimite  := LastDay(dDataAte)

	For nCont := 1 to nQtdMesAnt
		dDtIng	:=firstday(dDtIng)-1
	Next nCont
	dDtIng	:=firstday(dDtIng)
	cMesIng := month(dDtIng)

	DbSelectArea ('CF9')

	cSlctCF9 :='%'
	cSlctCF9 += 'CF9.CF9_CODBCC,		CF9.CF9_PERING,	CF9.CF9_BASMES,	CF9.CF9_CSTPIS,'
	cSlctCF9 += 'CF9.CF9_ALQPIS,		CF9.CF9_VALPIS,	CF9.CF9_CSTCOF,	CF9.CF9_ALQCOF,	CF9.CF9_VALCOF'
	cSlctCF9 +='%'

	cAliasCF9	:=	GetNextAlias()

	BeginSql Alias cAliasCF9
	COLUMN CF9_PERING AS DATE
	SELECT			    
		%Exp:cSlctCF9%
	FROM 
		%Table:CF9% CF9
	WHERE
		CF9.CF9_FILIAL = %xFilial:CF9% AND
		CF9.CF9_PERING > %Exp:DToS(dDtIng)% AND 
		CF9.CF9_PERING <= %Exp:DToS(dDtLimite)% AND  
		CF9.%NotDel%	
	EndSql

	DbSelectArea (cAliasCF9)
	(cAliasCF9)->(DbGoTop ())
	Do While !(cAliasCF9)->(Eof ())

		//------------------------------------------
		//Não considera o 13 mes.
		//------------------------------------------
		If Month((cAliasCF9)->CF9_PERING) = cMesIng .And. Year(dDataDe) > Year((cAliasCF9)->CF9_PERING)
			(cAliasCF9)->(dbSkip())
			Loop
		Endif

		oApurEnt:SetRegime(NAOCUMULAT)
		oApurEnt:SetOrigem(OUTROS)
		oApurEnt:SetReceita((cAliasCF9)->CF9_BASMES)
		oApurEnt:SetCodBcc((cAliasCF9)->CF9_CODBCC)
		oApurEnt:SetCFOP(	'')

		//---------------------
		//Informações de PIS
		//---------------------
		oApurEnt:SetTributo(PIS)
		oApurEnt:SetCST((cAliasCF9)->CF9_CSTPIS)
		oApurEnt:SetAlqTrib((cAliasCF9)->CF9_ALQPIS)
		oApurEnt:SetBcTrib((cAliasCF9)->CF9_BASMES)
		oApurEnt:SetValTrib((cAliasCF9)->CF9_VALPIS)
		oApurEnt:AgrpCred()

		//---------------------
		//Informações da COFINS
		//---------------------
		oApurEnt:SetTributo(COFINS)
		oApurEnt:SetCST((cAliasCF9)->CF9_CSTCOF)
		oApurEnt:SetAlqTrib((cAliasCF9)->CF9_ALQCOF)
		oApurEnt:SetBcTrib((cAliasCF9)->CF9_BASMES)
		oApurEnt:SetValTrib((cAliasCF9)->CF9_VALCOF)
		oApurEnt:AgrpCred()

		//----------------------------------
		//Agrupa valores para resumo de CST
		//----------------------------------
		oApurEnt:GrvResCST()

		(cAliasCF9)->(DbSkip ())
	EndDo

	oApurEnt:FechaAlias(cAliasCF9)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001AjuCF5(dDataDe,dDataAte,oAjustes)
Função que irá buscar as movimentações gravadas na tabela CF5 de ajustes
de créditos de PIS e COFINS, e irá processar para que sejam efetuados
os devidos ajustes

@param	dDataDe	- Data inicial do período de apuração
		dDataAte	-Data final do período de apuração
		oAjustes	-Objeto de ajuste já criado para processamento

@author Erick G. Dias
@since 14/04/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001AjuCF5(dDataDe,dDataAte,oAjustes,lDebito)

	Local cAliasCF5	:= ''
	Local cSelect	:= ''
	Local cWhere	:= ''
	Local CREDITO 	:= '1'
	Local cDebito	:= '2'
	Local lDetAju	:= CF5->(FieldPos('CF5_CST')) > 0
	Local lCF5Ativ	:= CF5->(FieldPos('CF5_TIPATV')) > 0
	Local lProcDeb	:= CF5->(FieldPos("CF5_TPAJST"))>0 .And. CF5->(FieldPos("CF5_CODCON"))>0
	Local cRegime	:= ''
	Local aStruCF5	:= CF5->(DBStruct())
	Local nCF5		:= 0
	Local nTamCF5	:= Len(aStruCF5)
	Local cCmpMemo  := ""

	Default lDebito := .F.

//Indica para objeto que os ajustes serão referentes aos créditos ou debitos
	If lProcDeb .And. lDebito
		oAjustes:SetCrdDeb(cDebito)
	ElseIF lDebito .And. !lProcDeb
		Return()
	Else
		//Indica para objeto que os ajustes serão referentes aos créditos
		oAjustes:SetCrdDeb(CREDITO)
		lDebito := .F.
	Endif

	For nCF5 := 1 To nTamCF5
		IF aStruCF5[nCF5][2] <> 'M' //Campos Memo devem ser ultimos campos
			IF nCF5 == 1
				cSelect += "CF5."+aStruCF5[nCF5][1]
			Else
				cSelect += ", CF5."+aStruCF5[nCF5][1]
			Endif
		Else
			cCmpMemo += ", CF5."+aStruCF5[nCF5][1]
		Endif

	Next (nCF5)

	cAliasCF5	:=	GetNextAlias()
	cSelect :=	'%' + (cSelect + cCmpMemo) + '%' //"%CF5.*%"
	cWhere	:=	"%CF5.CF5_FILIAL='"+xFilial("CF5")+"' AND "
	cWhere	+=	"CF5.CF5_DTREF>='"+DTOS(dDataDe)+"' AND "
	cWhere	+=	"CF5.CF5_DTREF<='"+DTOS(dDataAte)+"' AND "
	cWhere	+=	"CF5.CF5_PISCOF<>'2' AND "

//Caso seja debido considera campo informativo debito ou credito
	If lDebito
		cWhere	+=	"CF5.CF5_TPAJST = '2' AND "
	ElseIf lProcDeb //caso campo não exista, significa que somente existe ajuste de credito no cadastro
		cWhere	+=	"CF5.CF5_TPAJST <> '2' AND "
	Endif

	cWhere	+= "%"

	BeginSql Alias cAliasCF5
    COLUMN CF5_DTREF AS DATE	
	SELECT			    	 
		%Exp:cSelect%		
	FROM 
		%Table:CF5% CF5													
	WHERE
		%Exp:cWhere%
		CF5.%NotDel%
	EndSql

	DbSelectArea (cAliasCF5)
	(cAliasCF5)->(DbGoTop ())
	Do While !(cAliasCF5)->(Eof ())

		//Definie regime pelo codigo
		IF lDebito
			//Guarda regime
			cRegime :=  oAjustes:cRegime
			IF (cAliasCF5)->CF5_CODCON $ "01|02|03|04|71" //codigos não cumulativos
				oAjustes:SetRegime('1') //Não cumulativo
			Else
				oAjustes:SetRegime('2') //Cumulativo
			Endif
		Endif

		//Passa as informações do ajuste para a classe
		oAjustes:SetTributo(Iif((cAliasCF5)->CF5_PISCOF=='0',PIS,COFINS))
		oAjustes:SetTpAjust((cAliasCF5)->CF5_INDAJU)
		oAjustes:SetCodAju((cAliasCF5)->CF5_CODAJU)
		oAjustes:SetNumDoc((cAliasCF5)->CF5_NUMDOC)
		oAjustes:SetDescAju((cAliasCF5)->CF5_DESAJU)
		oAjustes:SetVlAju((cAliasCF5)->CF5_VALAJU)
		oAjustes:SetCodDC(Iif(lDebito,(cAliasCF5)->CF5_CODCON,(cAliasCF5)->CF5_CODCRE))

		If lCF5Ativ
			oAjustes:SetTipAtiv((cAliasCF5)->CF5_TIPATV)
		EndIF

		//Passa novas informações para classe de ajuste
		If lDetAju
			oAjustes:SetCst((cAliasCF5)->CF5_CST)
			oAjustes:SetConta((cAliasCF5)->CF5_CONTA)
			oAjustes:SetInfComp(Iif(Type("(cAliasCF5)->CF5_INFCOM")<> "U"  ,(cAliasCF5)->CF5_INFCOM  ,(cAliasCF5)->CF5_DESAJU  )  )
			oAjustes:SetBase((cAliasCF5)->CF5_BASE)
			oAjustes:SetAlq((cAliasCF5)->CF5_ALQ)
		EndIF

		oAjustes:SetDtRefer((cAliasCF5)->CF5_DTREF)

		//Realiza o Ajuste
		oAjustes:Ajustar()

		//Restaura Regime
		IF lDebito
			oAjustes:SetRegime(cRegime)
		Endif

		(cAliasCF5)->(DbSkip ())
	EndDo

	oAjustes:FechaAlias(cAliasCF5)
	FwFreeArray(aStruCF5)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001AjuPresumido


@param	dDataDe	- Data inicial do período de apuração
		dDataAte	-Data final do período de apuração
		oAjustes	-Objeto de ajuste já criado para processamento

@author Erick G. Dias
@since 14/04/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001AjuPresumido( aSX1 ,oAjustes , aMvSpcXCp1 , aMvSpcXCp2 , aMvSpcXCp3 , cRegime , aXFilial ,cFilialMat  )

	Local	aCredPres	:=	{}

	Local	cAliasSFT	:=	""
	Local	cFiltro		:=	""
	Local	cWhere		:=	""
	Local	cCampos		:=	""
	Local 	dDataDe		:= aSX1[1]
	Local 	dDataAte	:= aSX1[2]
	Local 	cNrLivro	:= aSX1[3]
	Local	nX			:=	0
	Local	nReceita	:=	0
	Local	nPercRecMI	:=	0
	Local	nPercRecEX	:=	0
	Local	nBcCpMI		:=	0
	Local	nBcCpEX		:=	0
	Local	nDifOutPrd	:=	0
	Local	nEntrada	:=	0
	Local 	cConta		:= ""
	Local 	nLencXCp1	:= len(aMvSpcXCp1)

	Local	oApurEFD	:=	nil

// -----------------------------------------------------------------------------------------------------------------------------
//totaliza o valor de receita para proporcionalizar o calculo do credito presumido

	cAliasSFT	:=	GetNextAlias()

	cFiltro := "%"

	If (cNrLivro<>"*")
		cFiltro += " SFT.FT_NRLIVRO = '" + cNrLivro + "' "
	EndiF

	if len( aMvSpcXCp3 ) > 0
		cFiltro	+=	" ("
		for nX := 1 to len( aMvSpcXCp3 )
			cFiltro	+= " SB1.B1_POSIPI LIKE '" + aMvSpcXCp3[ nX ] + "%' OR "
		next nX
		cFiltro	:=	substr( cFiltro , 1 , Len( cFiltro ) - 3 ) + ") AND "
	endif

	cFiltro	+=	"%"

	BeginSql Alias cAliasSFT

	COLUMN FT_EMISSAO AS DATE
	COLUMN FT_ENTRADA AS DATE
	COLUMN FT_DTCANC AS DATE

	SELECT
		SUM(SFT.FT_VALCONT) FT_VALCONT
		
	FROM
		%Table:SFT% SFT
		LEFT JOIN %Table:SB1% SB1 ON(SB1.B1_FILIAL=%xFilial:SB1%  AND SB1.B1_COD=SFT.FT_PRODUTO AND SB1.%NotDel%)
		
	WHERE
		SFT.FT_FILIAL=%xFilial:SFT% AND
		SFT.FT_TIPOMOV = 'S' AND
		SFT.FT_ENTRADA>=%Exp:DToS (dDataDe)% AND
		SFT.FT_ENTRADA<=%Exp:DToS (dDataAte)% AND
		(SFT.FT_DTCANC = ' ' OR SFT.FT_DTCANC > %Exp:DToS (dDataAte)% )  AND
		SFT.FT_TIPO <> 'D' AND
		SFT.FT_CFOP NOT LIKE ( '7%' ) AND
		SFT.FT_CSTPIS = '01' AND SFT.FT_CSTCOF = '01' AND
		%Exp:cFiltro%
		SFT.%NotDel%	

	EndSql

	if ( cAliasSFT )->FT_VALCONT > 0
		nReceita	:=	( cAliasSFT )->FT_VALCONT
	endif

	DbSelectArea( cAliasSFT )
	( cAliasSFT )->( dbCloseArea () )
// -----------------------------------------------------------------------------------------------------------------------------

// -----------------------------------------------------------------------------------------------------------------------------

	cAliasSFT2	:=	GetNextAlias()

	cWhere := "%"

	cWhere += "SFT.FT_FILIAL = '" + xFilial('SFT') + "' AND "
	cWhere += "SFT.FT_TIPOMOV = 'E' AND "
	cWhere += "SFT.FT_ENTRADA >= '" + DToS (dDataDe) + "' AND "
	cWhere += "SFT.FT_ENTRADA <= '" + DToS (dDataAte) + "' AND "
	cWhere += "(SFT.FT_DTCANC = ' ' OR SFT.FT_DTCANC > '" + DToS (dDataAte) + "' ) AND "
	cWhere += "SFT.D_E_L_E_T_ = '' AND "

	cCampos := "%"

// para o calculo do credito presumido proporcional, sempre utilizar o CST 64 ou CST 66
	cWhere	+=	" ((SFT.FT_CSTPIS = '64'AND SFT.FT_CSTCOF = '64') OR (SFT.FT_CSTPIS = '66'AND SFT.FT_CSTCOF = '66')) AND "

//cWhere	+=	" "
	if nLencXCp1>0
		cWhere	+= " ("
		for nX := 1 to nLencXCp1
			cWhere	+= "( SB1.B1_POSIPI LIKE '" + aMvSpcXCp1[ nX ] + "%' ) "
			if nX == nLencXCp1
				cWhere	+= ")"
			endif
			cWhere	+= " OR "
		next nX
	endif

	cWhere	:=	substr( cWhere , 1 , Len( cWhere ) - 3 )

	If (cNrLivro<>"*")
		cWhere += " AND SFT.FT_NRLIVRO = '" + cNrLivro + "' "
	EndiF

	cWhere += "%"

	BeginSql Alias cAliasSFT2

	COLUMN FT_EMISSAO AS DATE
	COLUMN FT_ENTRADA AS DATE
	COLUMN FT_DTCANC AS DATE

	SELECT
		SUM(SFT.FT_BASEPIS) FT_BASEPIS, FT_CSTPIS, MAX(SFT.FT_CONTA) FT_CONTA
		%Exp:cCampos%
	FROM
		%Table:SFT% SFT
		LEFT JOIN %Table:SB1% SB1 ON(SB1.B1_FILIAL=%xFilial:SB1%  AND SB1.B1_COD=SFT.FT_PRODUTO AND SB1.%NotDel%)
	WHERE
		%Exp:cWhere%
	GROUP BY FT_CSTPIS
		
	EndSql

	DbSelectArea( cAliasSFT2 )
	( cAliasSFT2 )->( DbGoTop( ) )

// -----------------------------------------------------------------------------------------------------------------------------

// carrega receita bruta do periodo
	oApurEFD := FISX001():New()
	oApurEFD:SetFilial(aXFilial)
	oApurEFD:SetFilApu(cfilialMat)
	oApurEFD:SetRegApur(cRegime)
	oApurEFD:SetDtIni(dDataDe)
	oApurEFD:SetDtFin(dDataAte)
	aRecBruta	:=	oApurEFD:LoadRecBru()

	nPercRecMI	:=	( nReceita / ( aRecBruta[ 1 , 1 ] +  aRecBruta[ 1 , 3 ] )  ) //Rec.Trib.NCM / Rec.Bruta Trib. + Rec.Bruta Exp

	nPercRecEX	:=	( aRecBruta[ 1 , 3 ] / ( aRecBruta[ 1 , 3 ] +  aRecBruta[ 1 , 2 ] )  ) // Rec.Exp / Rec.Trib.NCM + Rec.Exp

	nDifOutPrd	:=	( nReceita * 100 ) / aRecBruta[ 1 , 1 ]

// -----------------------------------------------------------------------------------------------------------------------------

	While !( cAliasSFT2 )->( Eof() )
		if ( cAliasSFT2 )->( FT_BASEPIS ) > 0
			nEntrada	:=	( cAliasSFT2 )->( FT_BASEPIS )
		endif

		cConta		:= ( cAliasSFT2 )->FT_CONTA

		nBcCpMI		:=	nEntrada * nPercRecMI
		nBcCpEX		:=	nEntrada * nPercRecEX
		aCredPres	:=	{ { 0 , 0 } , { 0 , 0 } , { 0 , 0 } }

		//o calculo abaixo eh utilizado para definir os valores de credito presumido de pis e cofins

		//apenas dos produtos informados no parametro MV_SPCXCP3, pois possuem aliquota diferente das demais vendas internas
		//para o calculo do presumido para mercado interno deve ser deduzido o calculo do presumido para exportacao
		if aMvSpcXCp2[ 1 , 1 ] > 0 .and. aMvSpcXCp2[ 3 , 1 ] > 0
			aCredPres[ 1 , 1 ]	:=	( nBcCpMI * ( nDifOutPrd / 100 ) ) * ( aMvSpcXCp2[ 1 , 1 ] / 100 ) - ( nBcCpMI ) * ( aMvSpcXCp2[ 3 , 1 ] / 100 )	//pis para venda nacional dos produtos do parametro MV_SPCXCP3
			aCredPres[ 1 , 2 ]	:=	( nBcCpMI * ( nDifOutPrd / 100 ) ) * ( aMvSpcXCp2[ 1 , 2 ] / 100 ) - ( nBcCpMI ) * ( aMvSpcXCp2[ 3 , 2 ] / 100 )	//cofins para venda nacional dos produtos do parametro MV_SPCXCP3
		endif

		//o calculo abaixo eh utilizado para o credito presumido das vendas internas, com excecao dos produtos que
		//ja foram calculados acima
		if aMvSpcXCp2[ 2 , 1 ] > 0
			aCredPres[ 2 , 1 ]	:=	( nBcCpMI * ( ( ( nDifOutPrd / 100 ) - 1 ) *-1 ) ) * ( aMvSpcXCp2[ 2 , 1 ] / 100 )	//pis para venda nacional
			aCredPres[ 2 , 2 ]	:=	( nBcCpMI * ( ( ( nDifOutPrd / 100 ) - 1 ) *-1 ) ) * ( aMvSpcXCp2[ 2 , 2 ] / 100 )	//cofins para venda nacional
		endif

		if aMvSpcXCp2[ 3 , 1 ] > 0
			aCredPres[ 3 , 1 ]	:=	nBcCpEX * ( aMvSpcXCp2[ 3 , 1 ] / 100 )	//pis exportacao
			aCredPres[ 3 , 2 ]	:=	nBcCpEX * ( aMvSpcXCp2[ 3 , 2 ] / 100 )	//cofins exportacao
		endif

		// -----------------------------------------------------------------------------------------------------------------------------

		for nx := 1 to len(  aCredPres )

			if aCredPres[ nX , 1 ] > 0

				//Passa as informações do ajuste para a classe
				oAjustes:SetTributo( PIS )
				oAjustes:SetTpAjust( ACRESCIMO )
				oAjustes:SetCodAju( GetNewPar( "MV_CAJCPPC" , "03" ) )
				oAjustes:SetDescAju( "Credito Presumido Lei 12.350/2010,10.925/2004" )
				oAjustes:SetVlAju( aCredPres[ nx , 1 ] )
				oAjustes:SetCodDC( Iif(( cAliasSFT2 )->FT_CSTPIS == '66', "306", "106") ) // Caso a CST seja 66 Foi definido para que o ajuste seja feito no 306 ao invés do 106

				oAjustes:SetCst( ( cAliasSFT2 )->FT_CSTPIS )
				oAjustes:SetBase( 0 )
				oAjustes:SetAlq( aMvSpcXCp2[ nX , 1 ] ) // Seta a CST com base na query

				oAjustes:SetMsmCod(.T.)
				oAjustes:SetConta(cConta)
				oAjustes:SetCrdDeb('1')

				//Realiza o Ajuste
				oAjustes:Ajustar()

				oAjustes:SetTributo( COFINS )
				oAjustes:SetTpAjust( ACRESCIMO )
				oAjustes:SetCodAju( GetNewPar( "MV_CAJCPPC" , "03" ) )
				oAjustes:SetDescAju( "Credito Presumido Lei 12.350/2010,10.925/2004" )
				oAjustes:SetVlAju( aCredPres[ nX , 2 ] )
				oAjustes:SetCodDC( Iif(( cAliasSFT2 )->FT_CSTPIS == '66', "306", "106") )

				oAjustes:SetCst( ( cAliasSFT2 )->FT_CSTPIS )
				oAjustes:SetBase( 0 )
				oAjustes:SetAlq( aMvSpcXCp2[ nX , 2 ] )
				oAjustes:SetConta(cConta)
				oAjustes:SetMsmCod(.T.)

				oAjustes:SetCrdDeb('1')

				//Realiza o Ajuste
				oAjustes:Ajustar()

				//o ajuste deve ser feito apenas para uma situacao, caso seja efetuado ajuste nao continua para os demais
				exit

			endif

		next nX

		( cAliasSFT2 )->( DbSkip() )
	EndDo

	DbSelectArea( cAliasSFT2 )
	( cAliasSFT2 )->( DbCloseArea( ) )

Return
//-------------------------------------------------------------------
/*/{Protheus.doc} A001F130()
Função que irá buscar valores de créditos do Ativo Fixo por aquisição,
e irá processar estes ´créditos de PIS e COFINS através da integração 
da função _AtfRegF130, localizada no fonte FISXATF.

@param		dDataDe	- Data inicial do período de apuração
			dDadaAte	-Data Final do período de apuração
			oApurEnt	-Objeto já criado para apurar os valores dos créditos

@author Erick G. Dias
@since 14/04/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001F130(dDataDe, dDadaAte,	oApurEnt,lIndividu,cFilApu,lDecPisCof)

	Local cF130Aux	  := ''
	Local cArqDestino := ''
	Local cAliasF130  := ''
	Local aResult	  := {}
	Local aFisTipos	  := {"01", "03"}
	Local oF130		  := TABELACL2():New()
	Local nVTribPis   := 0
	Local nVTribCof   := 0

	cF130Aux 		:= GetNextAlias()
	cArqDestino 	:= "APUREFD"+GetDbExtension()
	aResult 		:= _AtfRegF130(cFilAnt,dDataDe,dDadaAte,"0000000","ZZZZZZZZZ",cF130Aux,.T.,"10", aFisTipos)

	If Len(aResult) > 0
		cAliasF130	:= aResult[1,2]

		DbSelectArea(cAliasF130)
		(cAliasF130)->(DbGoTop())
		Do While !(cAliasF130)->(Eof ())

			nVTribPis := (cAliasF130)->VL_PIS
			nVTribCof := (cAliasF130)->VL_COFINS

			If lDecPisCof
				nVTribPis := ((cAliasF130)->VL_BC_PIS *(cAliasF130)->ALIQ_PIS / 100)
				nVTribCof := ((cAliasF130)->VL_BC_COFIN *(cAliasF130)->ALIQ_COFIN / 100)
			EndIf

			oApurEnt:SetRegime('1') //observação : Ajustar para verificar o regime da nota fiscal
			oApurEnt:SetOrigem(ATIVOFIXO)
			oApurEnt:SetReceita((cAliasF130)->VL_BC_PIS)
			oApurEnt:SetCodBcc((cAliasF130)->NAT_BC_CRE)
			oApurEnt:SetCFOP(	'')
			oApurEnt:SetImport(IIF(cvaltochar((cAliasF130)->IND_ORIG_C) == '1' ,.T.,.F.))

			//--------------------
			//Informações de PIS
			//--------------------
			oApurEnt:SetTributo(PIS)
			oApurEnt:SetCST(padl(cvaltochar((cAliasF130)->CST_PIS),2,'0'))
			oApurEnt:SetAlqTrib((cAliasF130)->ALIQ_PIS)
			oApurEnt:SetBcTrib((cAliasF130)->VL_BC_PIS)
			oApurEnt:SetValTrib(nVTribPis)
			oApurEnt:AgrpCred()

			//-----------------------
			//Informações da COFINS
			//-----------------------
			oApurEnt:SetTributo(COFINS)
			oApurEnt:SetCST(padl(cvaltochar((cAliasF130)->CST_COFINS),2,'0'))
			oApurEnt:SetAlqTrib((cAliasF130)->ALIQ_COFIN)
			oApurEnt:SetBcTrib((cAliasF130)->VL_BC_COFIN)
			oApurEnt:SetValTrib(nVTribCof)
			oApurEnt:AgrpCred()

			//----------------------------------
			//Agrupa valores para resumo de CST
			//----------------------------------
			oApurEnt:GrvResCST()

			//-----------------------------------------
			//ABAIXO GRAVA OS VALORES DO REGISTRO F130
			//----------------------------------------
			oF130:SetParam('CL2_PER',dDataDe)
			oF130:SetParam('CL2_REG','F130')
			oF130:SetParam('CL2_CODBCC',(cAliasF130)->NAT_BC_CRE)
			oF130:SetParam('CL2_IDBEM',strzero((cAliasF130)->IDENT_BEM,2))
			oF130:SetParam('CL2_MESANO',cvaltochar(strzero((cAliasF130)->MES_OPER_A,6)))
			oF130:SetParam('CL2_VLAQUI',(cAliasF130)->VL_OPER_AQ)
			oF130:SetParam('CL2_VLEXCL',(cAliasF130)->PARC_OPER)
			oF130:SetParam('CL2_INDPAC',cvaltochar((cAliasF130)->IND_NR_PAR))
			oF130:SetParam('CL2_CSTPIS',cvaltochar((cAliasF130)->CST_PIS))
			oF130:SetParam('CL2_BCPIS',(cAliasF130)->VL_BC_PIS)
			oF130:SetParam('CL2_ALQPIS',(cAliasF130)->ALIQ_PIS)
			oF130:SetParam('CL2_VLPIS',(cAliasF130)->VL_PIS)
			oF130:SetParam('CL2_CSTCOF',cvaltochar((cAliasF130)->CST_COFINS))
			oF130:SetParam('CL2_BCCOF',(cAliasF130)->VL_BC_COFIN)
			oF130:SetParam('CL2_ALQCOF',(cAliasF130)->ALIQ_COFIN)
			oF130:SetParam('CL2_VLCOF',(cAliasF130)->VL_COFINS)
			oF130:SetParam('CL2_CTA',(cAliasF130)->COD_CTA)
			oF130:SetParam('CL2_CCUS',(cAliasF130)->COD_CCUS)
			oF130:SetParam('CL2_DESCR',(cAliasF130)->DESC_BEM_I)
			oF130:SetParam('CL2_ORICRD',cvaltochar((cAliasF130)->IND_ORIG_C))
			oF130:SetParam('CL2_IDUTI',cvaltochar((cAliasF130)->IND_UTIL_B))
			oF130:SetParam('CL2_INDPRO',(cAliasF130)->INDPRO)
			oF130:SetParam('CL2_NUMPRO',(cAliasF130)->NUMPRO)
			oF130:SetParam('CL2_FILAPU',IIf(lIndividu,oF130:BuscaxFil('CL2'),cFilApu))
			oF130:SetParam('CL2_CODATF',(cAliasF130)->BEM)
			oF130:SetParam('CL2_ITATF',(cAliasF130)->ITEM)
			oF130:SetParam('CL2_DESATF',(cAliasF130)->DESCRI)
			oF130:SetParam('CL2_CRTCRD','1')//Aquisição
			oF130:Save()
			//PARA TRATAMENTO DE ALÍQUOTA MAJORADA DEVERÁ SER SOLICITADA ALTERAÇÃO
			//NA FUNÇÃO DE INTEGRAÇÃO DO FINANCEIRO, NÃO DEVERÁ SER TRATADO AQUI.

			(cAliasF130)->(DBSKIP())
		EndDo

		//Fechar os arquivos do ativo depois de finalizado o processamento
		(cAliasF130)->(DbCloseArea ())
		FERASE(ARESULT[1,1]+GetDbExtension())
		FERASE(ARESULT[1,1]+OrdBagExt())

	EndIf

	FreeObj(oF130)
	oF130	:= Nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001F120()
Função que irá buscar valores de créditos do Ativo Fixo por depreciação,
e irá processar estes ´créditos de PIS e COFINS através da integração 
da função _DeprecAtivo, localizada no fonte FISXATF.

@param		dDataDe	- Data inicial do período de apuração
			dDadaAte	-Data Final do período de apuração
			oApurEnt	-Objeto já criado para apurar os valores dos créditos

@author Erick G. Dias
@since 14/04/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001F120(dDataDe, dDadaAte,	oApurEnt,lIndividu,cFilialMat,lDecPisCof)

	Local aProcItem	 := {}
	Local oF120		 :=	TABELACL2():New()
	lOCAL cAliasF120 := ''
	Local lVlrBcExc	 := .F.
	Local nVTribPis  := 0
	Local nVTribCof  := 0

	aAdd(aProcItem,"") 			//Ativo Inicial
	aAdd(aProcItem,"zz") 		//Ativo Final
	aAdd(aProcItem,CToD("")) 	//Data Inicial da aquisição
	aAdd(aProcItem,dDadaAte) 	//Data Final da aquisição
	aAdd(aProcItem,"ATI")      	//Tabela Temporaria
	aF120Aux := _DeprecAtivo(dDataDe,dDadaAte,.T.,.F.,aProcItem,,.F.,"09/11",SM0->M0_CODFIL,.F.)

	DbSelectArea("ATI")
	ATI->(DbSetOrder(1))
	ATI->(dbGoTop())
	cAliasF120:= aF120Aux[1,2]

	lVlrBcExc	:= (cAliasF120)->(FieldPos("VLRBCEXC"))>0

	Do While !(cAliasF120)->(Eof ())

		nVTribPis := (cAliasF120)->VLRPIS
		nVTribCof := (cAliasF120)->VLRCOFINS

		If lDecPisCof
			nVTribPis := ((cAliasF120)->VLRBCPIS *(cAliasF120)->ALIQPIS / 100)
			nVTribCof := ((cAliasF120)->VLRBCCOFIN *(cAliasF120)->ALIQCOFINS / 100)
		EndIf

		oApurEnt:SetRegime('1') //observação : Ajustar para verificar o regime da nota fiscal
		oApurEnt:SetOrigem(ATIVOFIXO)
		oApurEnt:SetReceita((cAliasF120)->VLRBCPIS)
		oApurEnt:SetCodBcc((cAliasF120)->NATBCCRED)
		oApurEnt:SetCFOP(	'')
		oApurEnt:SetlDeprAtv(.T.)
		oApurEnt:SetImport(IIF((cAliasF120)->INDORIGCRD == '1' ,.T.,.F.))

		//---------------------
		//Informações de PIS
		//---------------------
		oApurEnt:SetTributo(PIS)
		oApurEnt:SetCST((cAliasF120)->CSTPIS)
		oApurEnt:SetAlqTrib((cAliasF120)->ALIQPIS)
		oApurEnt:SetBcTrib((cAliasF120)->VLRBCPIS)
		oApurEnt:SetValTrib(nVTribPis)
		oApurEnt:AgrpCred()

		//----------------------
		//Informações da COFINS
		//----------------------
		oApurEnt:SetTributo(COFINS)
		oApurEnt:SetCST((cAliasF120)->CSTCOFINS)
		oApurEnt:SetAlqTrib((cAliasF120)->ALIQCOFINS)
		oApurEnt:SetBcTrib((cAliasF120)->VLRBCCOFIN)
		oApurEnt:SetValTrib(nVTribCof)
		oApurEnt:AgrpCred()

		//-------------------------------------------------------------------
		//Agrupa valores para resumo de CST
		//-------------------------------------------------------------------
		oApurEnt:GrvResCST()

		//------------------------------------------
		//ABAIXO IRÁ GRAVAR A OPERAÇÃO NA TABELA CL2
		//------------------------------------------
		oF120:SetParam('CL2_PER',dDataDe)
		oF120:SetParam('CL2_REG','F120')
		oF120:SetParam('CL2_VLOPER',(cAliasF120)->VRET)
		oF120:SetParam('CL2_CODBCC',(cAliasF120)->NATBCCRED)
		oF120:SetParam('CL2_IDBEM',(cAliasF120)->INDBEMIMOB)
		oF120:SetParam('CL2_ORICRD',(cAliasF120)->INDORIGCRD)
		oF120:SetParam('CL2_IDUTI',(cAliasF120)->INDUTILBEM)
		oF120:SetParam('CL2_CSTPIS',(cAliasF120)->CSTPIS)
		oF120:SetParam('CL2_BCPIS',(cAliasF120)->VLRBCPIS)
		oF120:SetParam('CL2_ALQPIS',(cAliasF120)->ALIQPIS)
		oF120:SetParam('CL2_VLPIS',(cAliasF120)->VLRPIS)
		oF120:SetParam('CL2_CSTCOF',(cAliasF120)->CSTCOFINS)
		oF120:SetParam('CL2_BCCOF',(cAliasF120)->VLRBCCOFIN)
		oF120:SetParam('CL2_ALQCOF',(cAliasF120)->ALIQCOFINS)
		oF120:SetParam('CL2_VLCOF',(cAliasF120)->VLRCOFINS)
		oF120:SetParam('CL2_CTA',(cAliasF120)->CODCONTA)
		oF120:SetParam('CL2_CCUS',(cAliasF120)->CODCCUSTO)
		oF120:SetParam('CL2_DESCR',(cAliasF120)->DESCBEMIMO)
		oF120:SetParam('CL2_INDPRO',(cAliasF120)->INDPRO)
		oF120:SetParam('CL2_NUMPRO',(cAliasF120)->NUMPRO)
		oF120:SetParam('CL2_FILAPU',IIf(lIndividu,oF120:BuscaxFil('CL2'),cFilialMat) )
		oF120:SetParam('CL2_CODATF',(cAliasF120)->BEM)
		oF120:SetParam('CL2_ITATF',(cAliasF120)->ITEM)
		oF120:SetParam('CL2_DESATF',(cAliasF120)->DESCRI)
		oF120:SetParam('CL2_CRTCRD','2')//Depreciação

		IF lVlrBcExc
			oF120:SetParam('CL2_VLEXCL',(cAliasF120)->VLRBCEXC)
		EndIF

		oF120:Save()

		(cAliasF120)->(DbSkip())
	EndDo
	oApurEnt:SetlDeprAtv(.F.)
	DbSelectArea(aF120Aux[1,2])
	dbCloseArea()
	Ferase(aF120Aux[1,1]+GetDBExtension())
	Ferase(aF120Aux[1,1]+OrdBagExt())

	FreeObj(oF120)
	oF120:=Nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001CF8()
Função que irá buscar valores de créditos do Ativo Fixo por depreciação,
e irá processar estes ´créditos de PIS e COFINS através da integração 
da função _DeprecAtivo, localizada no fonte FISXATF.

@param		dDataDe	-Data inicial do período de apuração
			dDadaAte	-Data Final do período de apuração
			oApurEnt	-Objeto para as operações com créditos já criado 
						 para apurar os valores dos créditos
			oApurSai	-Objeto para as operações com débitos já criado 
						 para apurar os valores dos créditos			
			lProcCred	-Indica se irá processar operações de crédito			 
			nTotF100	-Campos com somatório das receitas utilizadas 
						 para o F100			
			lPTitEnt	-Indica se irá processar as operações de entrada
			lPTitSai	-Indica se irá processar as operações de saída						

@author Erick G. Dias
@since 14/04/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001CF8(aSX1,oApurEnt,oApurSai,lProcCred,nTotF100,lPTitEnt,lPTitSai,cDebito,nBsConsorc,lCPRBNF,cFilialMat)
	Local dDataDe	:= aSX1[1]
	Local dDadaAte	:= aSX1[2]
	Local cReg		:= aSX1[6]
	Local lIndividu:= (aSX1[15] == 2)
	Local cAliasCF8	:= ''
	Local cCodPart	:= ''
	Local cLoja		:= ''
	Local cDtOperCF8	:= ''
	Local lCF8EXCPRB	:= CF8->(FIELDPOS("CF8_EXCPRB")) > 0
	Local oF100		:=	TABELACL2():New() //Cria objeto para gravação do F100
	Local lEntDeb	:=	.F.
	Local lPart	:= CF8->(FieldPos("CF8_PART")) > 0
	Local cPart	:= ""
	Local cTab := ""

	cAliasCF8	:=	GetNextAlias()

	cSelect	:=	'%CF8.*%'

	cWhere		:=	"% CF8.CF8_FILIAL= '" +xFilial("CF8")+ "' AND  "
	cWhere		+=	"CF8.CF8_DTOPER>='"+DTOS(dDataDe)+"' AND "
	cWhere		+=	"CF8.CF8_DTOPER<='"+DTOS(dDadaAte)+"' AND "
	If cDebito=="1" // Débito
		cWhere	+= "CF8.CF8_CSTPIS IN ('01','02','03','04','05','06','07','08','09','49','99')  AND %"
	ElseIf cDebito=="2" //Crédito
		cWhere	+= "CF8.CF8_CSTPIS IN ('50','51','52','53','54','55','56','60','61','62','63','64','65','66')  AND %"
	EndIF

	BeginSql Alias cAliasCF8
    COLUMN CF8_DTOPER AS DATE	
    COLUMN CF8_DTFIMN AS DATE    
	SELECT			    	 
		%Exp:cSelect%		

	FROM 
		%Table:CF8% CF8													
	WHERE
		%Exp:cWhere%
		CF8.%NotDel%
	
	EndSql

	DbSelectArea('SA1')
	dbSetOrder(01)

	DbSelectArea('SA2')
	dbSetOrder(01)

	DbSelectArea(cAliasCF8)
	(cAliasCF8)->(DbGoTop())
	Do While !(cAliasCF8)->(Eof())

		cCodPart	:= 	''
		cLoja		:= 	''
		cDtOperCF8	:=	''
		cCodPart 	:=  Padr((cAliasCF8)->CF8_CLIFOR,TamSx3("A1_COD")[1])+PADR((cAliasCF8)->CF8_LOJA,TamSx3("A1_LOJA")[1])
		cDtOperCF8	:=	Substr(DTOS((cAliasCF8)->CF8_DTOPER),7,2)+Substr(DTOS((cAliasCF8)->CF8_DTOPER),5,2)+Substr(DTOS((cAliasCF8)->CF8_DTOPER),1,4)
		cDescCF8	:=	Formula((cAliasCF8)->CF8_DESCPR)
		//Tratamento para debito de piscof em notas de doação que geram receita
		lEntDeb 	:= CF8->(FieldPos("CF8_DOC"))>0 .And. !Empty((cAliasCF8)->CF8_DOC) .And. (cAliasCF8)->CF8_PART == '2' .And. Alltrim((cAliasCF8)->CF8_INDOPE)$"1/2"

		//Se o campo CF8_PART existir, pego seu conteúdo
		If lPart
			cPart:= ((cAliasCF8)->CF8_PART)
		EndiF

		If (cAliasCF8)->CF8_CSTPIS $ cCstCred //Processa objeto de crédito caso tenha CST de crédito
			IF lProcCred
				If lPTitEnt
					oApurEnt:SetRegime(Iif((cAliasCF8)->CF8_TPREG == '2',NAOCUMULAT,CUMULAT))
					oApurEnt:SetOrigem(TITENTRADA)
					oApurEnt:SetReceita((cAliasCF8)->CF8_VLOPER)
					oApurEnt:SetCodBcc((cAliasCF8)->CF8_CODBCC)
					oApurEnt:SetTNatRec((cAliasCF8)->CF8_TNATRE)
					oApurEnt:SetCNatRec((cAliasCF8)->CF8_CNATRE)
					oApurEnt:SetGNatRec((cAliasCF8)->CF8_GRPNC)
					oApurEnt:SetDNatRec((cAliasCF8)->CF8_DTFIMN)
					oApurEnt:SetCFOP(	'')
					oApurEnt:SetImport(IIF((cAliasCF8)->CF8_INDORI== '0' ,.F.,.T. ))
					oApurEnt:SetConta((cAliasCF8)->CF8_CODCTA)

					//--------------------
					//Informações de PIS
					//--------------------
					oApurEnt:SetTributo(PIS)
					oApurEnt:SetCST((cAliasCF8)->CF8_CSTPIS)
					oApurEnt:SetAlqTrib((cAliasCF8)->CF8_ALQPIS)
					oApurEnt:SetBcTrib((cAliasCF8)->CF8_BASPIS)
					oApurEnt:SetValTrib((cAliasCF8)->CF8_VALPIS)
					oApurEnt:AgrpCred()

					//-----------------------
					//Informações da COFINS
					//-----------------------
					oApurEnt:SetTributo(COFINS)
					oApurEnt:SetCST((cAliasCF8)->CF8_CSTCOF)
					oApurEnt:SetAlqTrib((cAliasCF8)->CF8_ALQCOF)
					oApurEnt:SetBcTrib((cAliasCF8)->CF8_BASCOF)
					oApurEnt:SetValTrib((cAliasCF8)->CF8_VALCOF)
					oApurEnt:AgrpCred()

					//----------------------------------
					//Agrupa valores para resumo de CST
					//----------------------------------
					oApurEnt:GrvResCST()
					oApurEnt:SetImport(.F.)
				EndIF

			EndIF

		ElseIF lPTitSai
			//----------------------
			//OPERAÇÕES DE SAÍDAS
			//----------------------

			If Alltrim((cAliasCF8)->CF8_INDOPE)$"1/2"
				nTotF100	+= (cAliasCF8)->CF8_VLOPER
			EndIf
			oApurSai:SetRegime(Iif((cAliasCF8)->CF8_TPREG == '2',NAOCUMULAT,CUMULAT))
			oApurSai:SetOrigem(Iif(lEntDeb,TITENTRADA,TITSAIDA))
			oApurSai:SetReceita((cAliasCF8)->CF8_VLOPER)
			oApurSai:SetTNatRec((cAliasCF8)->CF8_TNATRE)
			oApurSai:SetCNatRec((cAliasCF8)->CF8_CNATRE)
			oApurSai:SetGNatRec((cAliasCF8)->CF8_GRPNC)
			oApurSai:SetDNatRec((cAliasCF8)->CF8_DTFIMN)
			oApurSai:SetCFOP(	'')
			oApurSai:SetConta((cAliasCF8)->CF8_CODCTA)
			If cReg== 4
				oApurSai:SetTpReg(Iif((cAliasCF8)->CF8_TPREG == '2',NAOCUMULAT,CUMULAT))
			EndIF

			//-------------------------------------------------------------------
			//Informações do PIS
			//-------------------------------------------------------------------
			oApurSai:SetTributo(PIS)
			oApurSai:SetCST((cAliasCF8)->CF8_CSTPIS)
			oApurSai:SetAlqTrib((cAliasCF8)->CF8_ALQPIS)
			oApurSai:SetBcTrib((cAliasCF8)->CF8_BASPIS)
			oApurSai:SetValTrib((cAliasCF8)->CF8_VALPIS)
			oApurSai:AgrpContr()

			//-------------------------------------------------------------------
			//Informações da COFINS
			//-------------------------------------------------------------------
			oApurSai:SetTributo(COFINS)
			oApurSai:SetCST((cAliasCF8)->CF8_CSTCOF)
			oApurSai:SetAlqTrib((cAliasCF8)->CF8_ALQCOF)
			oApurSai:SetBcTrib((cAliasCF8)->CF8_BASCOF)
			oApurSai:SetValTrib((cAliasCF8)->CF8_VALCOF)
			oApurSai:AgrpContr()

			cTab	:= ""
			If lPart .AND. !Empty(cPart)
				cTab := Iif(cPart == "1" , "SA1" ,"SA2" )
			Else
				cTab := Iif(Alltrim((cAliasCF8)->CF8_INDOPE) == "0" , "SA2" ,"SA1" )
			EndIF

			oApurSai:SetExport(.F.)
			IF cTab == "SA1"
				If SA1->(dbSeek(xFilial("SA1") + (cAliasCF8)->CF8_CLIFOR + (cAliasCF8)->CF8_LOJA)) .AND. SA1->A1_EST == 'EX'
					oApurSai:SetExport(.T.)
				EndIf
			ElseIf cTab == "SA2"
				IF SA2->(dbSeek(xFilial("SA2") + (cAliasCF8)->CF8_CLIFOR + (cAliasCF8)->CF8_LOJA)) .AND. SA2->A2_EST == 'EX'
					oApurSai:SetExport(.T.)
				EndIf
			EndIF
			//oApurSai:SetExport(.F.)

			//Aqui somente será gerado bloco F, por exte motivo método abaixo com bloco fixo.
			oApurSai:RecBlocos("F")

			oApurSai:GrvResCST(Iif((cAliasCF8)->CF8_RECBRU <> '2' ,.T. ,.F.), "F")

			If lCF8EXCPRB .AND. (cAliasCF8)->CF8_EXCPRB == '1'
				nBsConsorc += (cAliasCF8)->CF8_BASPIS
			EndIF

		EndIF
		//-----------------------------------------
		//ABAIXO GRAVA OS VALORES DO REGISTRO F100
		//-----------------------------------------
		oF100:SetParam('CL2_PER',dDataDe)
		oF100:SetParam('CL2_REG','F100')
		oF100:SetParam('CL2_INDOP',(cAliasCF8)->CF8_INDOPE)
		oF100:SetParam('CL2_PARTI',cCodPart)
		oF100:SetParam('CL2_ITEM',(cAliasCF8)->CF8_ITEM)
		oF100:SetParam('CL2_DTOPER',(cAliasCF8)->CF8_DTOPER)
		oF100:SetParam('CL2_VLOPER',(cAliasCF8)->CF8_VLOPER)
		oF100:SetParam('CL2_CSTPIS',(cAliasCF8)->CF8_CSTPIS)
		oF100:SetParam('CL2_BCPIS',(cAliasCF8)->CF8_BASPIS)
		oF100:SetParam('CL2_ALQPIS',(cAliasCF8)->CF8_ALQPIS)
		oF100:SetParam('CL2_VLPIS',(cAliasCF8)->CF8_VALPIS)
		oF100:SetParam('CL2_CSTCOF',(cAliasCF8)->CF8_CSTCOF)
		oF100:SetParam('CL2_BCCOF',(cAliasCF8)->CF8_BASCOF)
		oF100:SetParam('CL2_ALQCOF',(cAliasCF8)->CF8_ALQCOF)
		oF100:SetParam('CL2_VLCOF',(cAliasCF8)->CF8_VALCOF)
		oF100:SetParam('CL2_CODBCC',(cAliasCF8)->CF8_CODBCC)
		oF100:SetParam('CL2_INDCRD',(cAliasCF8)->CF8_INDORI)
		oF100:SetParam('CL2_CTA',(cAliasCF8)->CF8_CODCTA)
		oF100:SetParam('CL2_CCUS',(cAliasCF8)->CF8_CODCCS)
		oF100:SetParam('CL2_DESCR',Iif(cDescCF8<>Nil,cDescCF8,(cAliasCF8)->CF8_DESCPR))
		oF100:SetParam('CL2_PART',(cAliasCF8)->CF8_PART)
		oF100:SetParam('CL2_FILAPU',IIf(lIndividu,oF100:BuscaxFil('CL2'),cFilialMat) )
		oF100:SetParam('CL2_IDCF8',(cAliasCF8)->CF8_CODIGO)
		oF100:SetParam('CL2_REGIME',Iif((cAliasCF8)->CF8_TPREG == '2',NAOCUMULAT,CUMULAT))
		oF100:SetParam('CL2_CLIFOR',(cAliasCF8)->CF8_CLIFOR)
		oF100:SetParam('CL2_LOJA',(cAliasCF8)->CF8_LOJA)
		oF100:Save()

		(cAliasCF8)->(DbSkip ())
	EndDo

	oF100:FechaAlias(cAliasCF8)
	FreeObj(oF100)
	oF100:= Nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001F100Fi()
Função que irá processar valores de PIS e COFINS de títulos sem vínculo
com documento fiscal gravado no Financeiro, através da função FinSpdF100
no fonte MATXATU.

@param		dDataDe	-Data inicial do período de apuração
			dDadaAte	-Data Final do período de apuração
			oApurEnt	-Objeto para as operações com créditos já criado 
						 para apurar os valores dos créditos
			oApurSai	-Objeto para as operações com débitos já criado 
						 para apurar os valores dos créditos	
			lProcCred	-Indica se irá processar operações de crédito			 
			nTotF100	-Campos com somatório das receitas utilizadas 
						 para o F100			
			lPTitEnt	-Indica se irá processar as operações de entrada
			lPTitSai	-Indica se irá processar as operações de saída							 		

@author Erick G. Dias
@since 14/04/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001F100Fi(aSX1,oApurEnt,oApurSai,lProcCred,nTotF100,lPTitEnt,lPTitSai,cReg,cDeb,aF100,lCPRBNF,cFilialMat)

	Local nPos			:= 0
	Local dDataDe 		:= aSX1[1]
	Local lIndividu		:= (aSX1[15] == 2)
	Local oF100			:=	TABELACL2():New()
	Local cIndOper		:= ''
	Local lGravaF100	:= .F.
	Local cIndOrig		:= ''
	Local cNumTit		:= ''
	Local cPrefixo		:= ''
	Local cParcela		:= ''
	Local cInfComp		:= ''
	Local cDescr		:= ''
	Local cAlsSA		:= ''
	Local lAliasPart	:= Cl2->(FIELDPOS('CL2_ALIAS')) > 0
	Local cConta		:= ""
	Local lEFDCON03		:= ExistBlock("EFDCON03")

	For nPos	:= 1 To Len (aF100)

		lGravaF100	:= .F.
		cIndOper	:= ''
		If aF100[nPos][3] $ cCstCred
			cIndOper := "0"
		ElseIf aF100[nPos][3] $ cCstTrib
			cIndOper := "1"
		ElseIf aF100[nPos][3] $ cCstNTrib
			cIndOper := "2"
		EndIF
		cCodPart	:= aF100[nPos][17]	//Aqui o Financeiro já retorna código do cliente + loja, prontos para fazer seek

		lCumulativ	:=	Iif ( aF100[nPos][14] == "0", .T. , .F. )
		cIndOrig	:= ''
		cDescr		:= ''
		cInfComp	:= ''

		If aF100[nPos][3] $ cCstCred //Se tiver CST com direito ao crédito irá processar objeto de crédito
			IF lProcCred .AND. cDeb == '2'
				If lPTitEnt
					//-----------------------
					//Informações do título
					//-----------------------
					//Executa ponto de entrada que altera conta contábil do registro F100
					If lEFDCON03
						//Chamar ponto de entrada
						cConta	:= ExEFDCON03( aF100[nPos][15], aF100[nPos][16] )
					Else
						cConta	:= Iif( Len( aF100[nPos] ) > 22, aF100[nPos][23] , "" )
					EndIF

					lGravaF100	:= .T.
					If SA2->(MsSeek(xFilial("SA2")+ cCodPart))
						cIndOrig:= Iif(SA2->A2_CODPAIS=="01058","0","1")
					EndIF
					oApurEnt:SetRegime(Iif(lCumulativ,CUMULAT ,NAOCUMULAT )) //observação : Ajustar para verificar o regime da nota fiscal
					oApurEnt:SetOrigem(TITENTRADA)
					oApurEnt:SetReceita(aF100[nPos][2])
					oApurEnt:SetCodBcc(aF100[nPos][11])
					oApurEnt:SetTNatRec(aF100[nPos][18])
					oApurEnt:SetCNatRec(aF100[nPos][19])
					oApurEnt:SetGNatRec(aF100[nPos][20])
					oApurEnt:SetDNatRec(cTod(aF100[nPos][21]))
					oApurEnt:SetCFOP(	'')
					oApurEnt:SetImport(IIF(cIndOrig == '0' ,.F.,.T. ))

					//--------------------
					//Informações de PIS
					//--------------------
					oApurEnt:SetTributo(PIS)
					oApurEnt:SetCST(aF100[nPos][3])
					oApurEnt:SetAlqTrib(aF100[nPos][5])
					oApurEnt:SetBcTrib(aF100[nPos][4])
					oApurEnt:SetValTrib(aF100[nPos][4]*aF100[nPos][5]/100)
					//oApurEnt:SetValTrib(aF100[nPos][6])
					oApurEnt:AgrpCred()

					//-----------------------
					//Informações da COFINS
					//-----------------------
					oApurEnt:SetTributo(COFINS)
					oApurEnt:SetCST(aF100[nPos][7])
					oApurEnt:SetAlqTrib(aF100[nPos][9])
					oApurEnt:SetBcTrib(aF100[nPos][8])
					oApurEnt:SetValTrib(((aF100[nPos][8] * aF100[nPos][9]) / 100))
					oApurEnt:AgrpCred()

					//----------------------------------
					//Agrupa valores para resumo de CST
					//----------------------------------
					oApurEnt:GrvResCST()
					oApurEnt:SetImport(.F.)

					cNumTit  := ''
					cInfComp := ''
					IF aF100[nPos][15] == "SE2"
						SE2->(dbGoto(aF100[nPos][16]))
						cNumTit := "referente o Título :" + SE2->E2_NUM
					EndIf
					If !Empty(Alltrim(cNumTit))
						cInfComp := "Operação " + cNumTit
					EndIf

				EndIF

			EndIF

		ElseIf lPTitSai .AND. cDeb == '1'

			//--------------------
			//OPERAÇÕES DE SAÍDAS
			//--------------------
			lGravaF100	:= .T.

			//Executa ponto de entrada que altera conta contábil do registro F100
			If lEFDCON03
				//Chamar ponto de entrada
				cConta	:= ExEFDCON03( aF100[nPos][15], aF100[nPos][16] )
			Else
				cConta	:= Iif( Len( aF100[nPos] ) > 22, aF100[nPos][23] , "" )
			EndIF

			nTotF100 += Iif(Len(aF100[nPos]) >= 34 .And. aF100[nPos][34] <> "2", aF100[nPos][2], 0)
			oApurSai:SetRegime(Iif(lCumulativ,CUMULAT ,NAOCUMULAT )) //observação : Ajustar para verificar o regime da nota fiscal
			oApurSai:SetOrigem(TITSAIDA)
			oApurSai:SetReceita(aF100[nPos][2])
			oApurSai:SetTNatRec(aF100[nPos][18])
			oApurSai:SetCNatRec(aF100[nPos][19])
			oApurSai:SetGNatRec(aF100[nPos][20])
			oApurSai:SetDNatRec(cTod(aF100[nPos][21]))
			oApurSai:SetQtde(1)
			oApurSai:SetCFOP(	'')
			If cReg== 4
				oApurSai:SetTpReg(Iif(lCumulativ,CUMULAT ,NAOCUMULAT ))
			EndIF

			oApurSai:SetConta( cConta )

			//-------------------
			//Informações do PIS
			//-------------------
			oApurSai:SetTributo(PIS)
			oApurSai:SetCST(aF100[nPos][3])
			oApurSai:SetAlqTrib(aF100[nPos][5])
			oApurSai:SetBcTrib(aF100[nPos][4])
			oApurSai:SetValTrib(aF100[nPos][4]*aF100[nPos][5]/100)//aF100[nPos][6])
			oApurSai:AgrpContr()

			//----------------------
			//Informações da COFINS
			//----------------------
			oApurSai:SetTributo(COFINS)
			oApurSai:SetCST(aF100[nPos][7])
			oApurSai:SetAlqTrib(aF100[nPos][9])
			oApurSai:SetBcTrib(aF100[nPos][8])
			oApurSai:SetValTrib(aF100[nPos][8]*aF100[nPos][9]/100)//aF100[nPos][10])
			oApurSai:AgrpContr()

			//Aqui também somente será gerado informações do bloco F.
			oApurSai:RecBlocos("F")

			oApurSai:GrvResCST(Iif(Len(aF100[nPos])>=33,Iif(aF100[nPos][33] <> '2' ,.T. ,.F.),.T.), "F")

			cNumTit	 := ''
			cInfComp	:= ''
			IF aF100[nPos][15] == "SE1"
				SE1->(dbGoto( aF100[nPos][16]))
				If IntTms () .AND. DT6->(MsSeek (xFilial("DT6")+SE1->E1_CLIENTE+SE1->E1_LOJA+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_TIPO))
					cNumTit := "referente o CTe : " + DT6->DT6_DOC
				Else
					cNumTit 	:="referente o Título :" + SE1->E1_NUM
				EndIF
			ElseIF aF100[nPos][15] == "SE5"
				SE5->(dbGoto( aF100[nPos][16]))
				cNumTit 	:="referente o Título :" + SE5->E5_NUMERO
			ElseIF aF100[nPos][15] == "SEI"
				SEI->(dbGoto( aF100[nPos][16]))
				cNumTit 	:="referente a Aplicação :" + SEI->EI_NUMERO
			EndIF
			If !Empty(Alltrim(cNumTit))
				cInfComp	:= "Operação " + cNumTit
			EndIf

		EndIF
		IF lGravaF100
			//---------------------------------------------------
			//ABAIXO GRAVA OS VALORES DO REGISTRO F100 COM DÉBITO
			//---------------------------------------------------
			oF100:SetParam('CL2_PER',dDataDe)
			oF100:SetParam('CL2_REG','F100')
			oF100:SetParam('CL2_INDOP',cIndOper)
			oF100:SetParam('CL2_PARTI',cCodPart)
			oF100:SetParam('CL2_ITEM','')//Títulos sem documento fiscal não tem código de produto
			oF100:SetParam('CL2_DTOPER',CTOD(Substr( aF100[nPos][1],7,2)  + '/'+ Substr( aF100[nPos][1],5,2) + '/' + Substr( aF100[nPos][1],1,4)))
			oF100:SetParam('CL2_VLOPER',aF100[nPos][2])
			oF100:SetParam('CL2_CSTPIS',aF100[nPos][3])
			oF100:SetParam('CL2_BCPIS',aF100[nPos][4])
			oF100:SetParam('CL2_ALQPIS',aF100[nPos][5])
			oF100:SetParam('CL2_VLPIS',aF100[nPos][6])
			oF100:SetParam('CL2_CSTCOF',aF100[nPos][7])
			oF100:SetParam('CL2_BCCOF',aF100[nPos][8])
			oF100:SetParam('CL2_ALQCOF',aF100[nPos][9])
			oF100:SetParam('CL2_VLCOF',aF100[nPos][10])
			oF100:SetParam('CL2_CODBCC',aF100[nPos][11])
			oF100:SetParam('CL2_INDCRD',cIndOrig)
			oF100:SetParam('CL2_CTA', cConta )
			oF100:SetParam('CL2_CCUS',Iif(Len(aF100[nPos])>23, aF100[nPos][24], ""))
			//oF100:SetParam('CL2_DESCR',Iif(len(aF100[nPos]) >=29,aF100[nPos][29],"" ))
			oF100:SetParam('CL2_INDPRO',aF100[nPos][28])
			oF100:SetParam('CL2_NUMPRO',aF100[nPos][27])
			oF100:SetParam('CL2_ORICRD','0')
			oF100:SetParam('CL2_FILAPU',IIf(lIndividu,oF100:BuscaxFil('CL2'),cFilialMat) )
			oF100:SetParam('CL2_CLIFOR' , Substr(aF100[nPos][17] , 1                       , TamSx3("A1_COD")[1])  )
			oF100:SetParam('CL2_LOJA'   , Substr(aF100[nPos][17] , TamSx3("A1_COD")[1] + 1 , TamSx3("A1_LOJA")[1]) )

			cNumTit	:= ''
			cPrefixo	:= ''
			cParcela	:= ''
			IF aF100[nPos][15] == "SE1"

				SE1->(dbGoto( aF100[nPos][16]))
				cNumTit	:= SE1->E1_NUM
				cPrefixo	:= SE1->E1_PREFIXO
				cParcela	:= SE1->E1_PARCELA

			ElseIF aF100[nPos][15] == "SE2"

				SE2->(dbGoto( aF100[nPos][16]))
				cNumTit	:= SE2->E2_NUM
				cPrefixo	:= SE2->E2_PREFIXO
				cParcela	:= SE2->E2_PARCELA

			ElseIF aF100[nPos][15] == "SE5"

				SE5->(dbGoto( aF100[nPos][16]))
				cNumTit	:= SE5->E5_NUMERO
				cPrefixo	:= SE5->E5_PREFIXO
				cParcela	:= SE5->E5_PARCELA

			EndIF

			oF100:SetParam('CL2_NUMTIT', cNumTit)
			oF100:SetParam('CL2_PREFIX', cPrefixo)
			oF100:SetParam('CL2_PARC', cParcela)
			oF100:SetParam('CL2_REGIME', Iif(lCumulativ,CUMULAT ,NAOCUMULAT ))

			IF len(aF100[nPos]) >=29
				cDescr	:= aF100[nPos][29]
			EndIF

			If !Empty(cInfComp)
				cDescr	:= cDescr + Iif(!Empty(cDescr),' - ','')  +  cInfComp
			EndIF

			oF100:SetParam('CL2_DESCR',cDescr)
			IF Len(aF100[nPos])>=32 .and. aF100[nPos][32] == "P"
				cAlsSA   := "SA2"
			Elseif Len(aF100[nPos])>=32 .and. aF100[nPos][32] == "R"
				cAlsSA   := "SA1"
			Else
				IF cIndOper == "0" // Movimentação de entrada, irei buscar na SA2 - Fornecedor
					cAlsSA   := "SA2"
				Else // Se for venda, irei buscar cliente na SA1
					cAlsSA   := "SA1"
				EndIF
			Endif
			If lAliasPart
				oF100:SetParam('CL2_ALIAS',cAlsSA)
			EndIF
			oF100:Save()
		EndIF

	Next nPos

	FreeObj(oF100)
	oF100:= Nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001SFTEnt()
Função que irá processar operações de entradas gravadas no livro fiscal

@param		dDataDe	-Data inicial do período de apuração
			dDadaAte	-Data Final do período de apuração
			oApurEFD	-Objeto para as operações com créditos já criado 
						 para apurar os valores dos créditos

@author Erick G. Dias
@since 14/04/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001SFTEnt(dDataDe, dDadaAte,oApurEFD,lCPRBNF,aXFilial,lDecPisCof)

	local cAliasSFT := 'SFT'
	local cSlctSFT	:= ''
	Local cFiltro	:= ''
	local cGroupBy	:= ''
	Local cFrom		:= ''
	Local oCPRB     := Nil
	Local lAtuCPRB  := .F.
	Local nVTribPis := 0
	Local nVTribCof := 0

	If lCPRBNF
		oCPRB:=CPRBEFD():New()
		oCPRB:SetDtIni(dDataDe)
		oCPRB:SetFilial(aXFilial)
	Endif

	cAliasSFT	:=	GetNextAlias()
	oApurEFD:SetOrigem(FISCALENT)

	cFrom	:= oApurEFD:GetJoinFrm(0,.F.,NFENTRADA)

	//Chama método para retornar campos de forma agrupada
	cSlctSFT   :=	oApurEFD:GetCmpSFT()
	//Chama método para voltar filtro das operações de saídas
	cFiltro 	:= oApurEFD:GetWhrSFT(NFENTRADA)
	//Chama método para retornar group by de saída
	cGroupBy	:=	oApurEFD:GetGrpSFT()

	cFiltro:= '%' + cFiltro + '%'
	cGroupBy := '%' + cGroupBy +'%'

	BeginSql Alias cAliasSFT
    COLUMN FT_DTFIMNT AS DATE	
	SELECT			    	 
		%Exp:cSlctSFT%		

	FROM	
		%Exp:cFrom%													
	WHERE
		%Exp:cFiltro%
		SFT.%NotDel% 
        
	%Exp:cGroupBy%	
	EndSql

	ProcRegua ((cAliasSFT)->(RecCount ()))
	DbSelectArea (cAliasSFT)
	(cAliasSFT)->(DbGoTop ())
	Do While !(cAliasSFT)->(Eof ())
		If oApurEFD:ChkRegraNf((cAliasSFT)->FT_ESPECIE,(cAliasSFT)->FT_CFOP,NFENTRADA,,,(cAliasSFT)->FT_CSTPIS)

			nVTribPis := (cAliasSFT)->FT_VALPIS
			nVTribCof := (cAliasSFT)->FT_VALCOF

			If lDecPisCof
				nVTribPis := ((cAliasSFT)->FT_BASEPIS *(cAliasSFT)->FT_ALIQPIS / 100)
				nVTribCof := ((cAliasSFT)->FT_BASECOF *(cAliasSFT)->FT_ALIQCOF / 100)
			EndIf

			//-------------------------------------------------------------------
			//Informações da Nota Fiscal
			//-------------------------------------------------------------------
			oApurEFD:SetOrigem(FISCALENT)
			oApurEFD:SetRegime(NAOCUMULAT)
			oApurEFD:SetCFOP((cAliasSFT)->FT_CFOP)
			oApurEFD:SetReceita((cAliasSFT)->FT_VALCONT)
			oApurEFD:SetCodBcc((cAliasSFT)->FT_CODBCC)
			oApurEFD:SetTNatRec((cAliasSFT)->ft_tnatrec)
			oApurEFD:SetCNatRec((cAliasSFT)->ft_cnatrec)
			oApurEFD:SetGNatRec((cAliasSFT)->ft_gruponc)
			oApurEFD:SetDNatRec((cAliasSFT)->FT_DTFIMNT)
			oApurEFD:SetImport(IIF(SubStr((cAliasSFT)->FT_CFOP,1,1) == '3' ,.T.,.F. ))
			oApurEFD:SetQtde((cAliasSFT)->FT_QUANT)

			//-------------------------------------------------------------------
			//Informações de PIS
			//-------------------------------------------------------------------
			oApurEFD:SetTributo(PIS)
			oApurEFD:SetCST((cAliasSFT)->FT_CSTPIS)
			oApurEFD:SetAlqTrib((cAliasSFT)->FT_ALIQPIS)
			oApurEFD:SetBcTrib((cAliasSFT)->FT_BASEPIS)
			oApurEFD:SetValTrib(nVTribPis)
			oApurEFD:SetBaseST((cAliasSFT)->FT_BASEPS3)
			oApurEFD:SetValST((cAliasSFT)->FT_VALPS3)
			oApurEFD:SetAlqSt((cAliasSFT)->FT_ALIQPS3)
			oApurEFD:SetAlqMaj((cAliasSFT)->FT_MALQPIS)
			oApurEFD:SetValMaj((cAliasSFT)->FT_MVALPIS)
			oApurEFD:SetVlPauta((cAliasSFT)->ft_pautPIS)
			oApurEFD:SetAgrIndust(oApurEFD:isAgrIndust())
			oApurEFD:OperPauta(lSPDPIS10,cAliasSFT)
			oApurEFD:AgrpCred()

			//-------------------------------------------------------------------
			//Informações da COFINS
			//-------------------------------------------------------------------
			oApurEFD:SetTributo(COFINS)
			oApurEFD:SetCST((cAliasSFT)->FT_CSTcof)
			oApurEFD:SetAlqTrib((cAliasSFT)->FT_ALIQCOF)
			oApurEFD:SetBcTrib((cAliasSFT)->FT_BASECOF)
			oApurEFD:SetValTrib(nVTribCof)
			oApurEFD:SetBaseST((cAliasSFT)->FT_BASECF3)
			oApurEFD:SetValST((cAliasSFT)->FT_VALCF3)
			oApurEFD:SetAlqSt((cAliasSFT)->FT_ALIQCF3)
			oApurEFD:SetAlqMaj((cAliasSFT)->FT_MALQCOF)
			oApurEFD:SetValMaj((cAliasSFT)->FT_MVALCOF)
			oApurEFD:SetVlPauta((cAliasSFT)->ft_pautCOF)
			oApurEFD:SetAgrIndust(oApurEFD:isAgrIndust())
			oApurEFD:OperPauta(lSPDPIS10,cAliasSFT)
			oApurEFD:AgrpCred()

			//Agrupa valores para resumo de CST
			oApurEFD:GrvResCST()
			oApurEFD:SetImport(.F.)

		/* Retirada dedução de base do CPRB neste local, pois esta rotina ja é executada na função ASA001Devo, que causava dedução de base duplicada para notas de devolução
		If lCPRBNF .and. (cAliasSFT)->FT_TIPO == 'D' .And. !Empty((cAliasSFT)->FT_ATIVCPB)
			lAtuCPRB := .T.
			oCPRB:SetDtRefer(dDataDe)
			oCPRB:SetCodAtiv((cAliasSFT)->FT_ATIVCPB)
			oCPRB:DeduzBase((cAliasSFT)->FT_ATIVCPB,(cAliasSFT)->FT_ALIQCPB,(cAliasSFT)->FT_BASECPB,(cAliasSFT)->FT_VALCONT)
			oCPRB:DetalhCPRB()
		Endif
		*/
		EndIF

		(cAliasSFT)->(DbSkip ())
	EndDo

	If lCPRBNF .And. lAtuCPRB
		//Grava os valores alterados.
		oCPRB:GravaCPRB()
	Endif

	oApurEFD:FechaAlias(cAliasSFT)

	//Finaliza operações de entrada
	oApurEFD:Finaliza('2')

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001SFTSai()
Função que irá processar operações de saídas gravadas no livro fiscal

@param		dDataDe	-Data inicial do período de apuração
			dDadaAte	-Data Final do período de apuração
			oApurEFD	-Objeto para as operações com débito já criado 
						 para apurar os valores das notas de saídas
			nM996Tpr	- Conteúdo do parâmetro MV_M996TPR
			cReg		- Define valor receita
			lCPRBNF	- CPRB calculado no documento fiscal	

@author Erick G. Dias
@since 14/04/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001SFTSai(dDataDe,dDadaAte,oApurEFD,nM996Tpr,cReg,lCPRBNF,cSPCBPSE,cReg2,aXFilial,cFilialMat,lindividu,aParSX1,lDecPisCof)

	local cAliasSFT		:= 'SFT'
	local cSlctSFT		:= ''
	Local cFiltro		:= ''
	local cGroupBy		:= ''
	Local cFrom			:= ''
	Local lPeWhere		:= ExistBlock("EFDCON01")
	Local lPeBase		:= ExistBlock("EFDCON02")
	Local lPeCTB		:= ExistBlock("SPDPIS07")
	Local nBaseCalc		:= 0
	Local lValdAux		:= .F.
	Local lAtuCPRB		:= .F.
	Local cModNF		:= ''
	Local lMoto			:= .F.
	Local nReceita		:= 0
	Local cRegime		:= ""
	Local cOutRec		:= SuperGetMv("MV_CODGEN",.F.,"")
	Local lNTrib 		:= CKX->(FieldPos('CKX_NTRIB'))>0 .And. !EmpTy(cOutRec)
	Local cMVEstado	 	:= GetNewPar("MV_ESTADO","")
	Local cMVSUBTRIB    := GetSubTrib("",.T.)
	Local cMVCFE210	 	:= LeParSeq("MV_CFE210","1410,1411,1414,1415,1660,1661,1662,2410,2411,2414,2415,2660,2661,2662")
	Local cStUfs		:= GetNewPar("MV_STUFS","")
	Local cStUf			:= GetNewPar("MV_STUF","")
	Local lRESF3FT		:= GetNewPar("MV_RESF3FT",.F.)
	Local lDSTRB 		:= GetNewPar("MV_DSTRB",.F.)
	Local lIPIRB    	:= GetNewPar("MV_DIPIRB",.F.)
	Local cSTNIEUF		:= GetNewPar("MV_STNIEUF","")
	Local cMV_EXPIND 	:= GetNewPar("MV_EXPIND","") //"5501", "5502", "6501", "6502"
	Local nValST		:= 0
	Local nValExport	:= 0
	Local cConta 		:= ""
	Local lDFSRVAC		:= GetNewPar("MV_DFSRVAC",.F.)
	Local cBloco		:= ""
	Local cAliasSON		:= ""
	Local nValipi   	:= 0
	Local nDescZFR		:= 0
	Local lVenSTZFM		:= .F.
	
	DbSelectArea(cAliasSFT)
	(cAliasSFT)->(DbSetOrder(2))
	cAliasSFT	:=	GetNextAlias()

	//traz campos para fazer from e join
	cFrom    := oApurEFD:GetJoinFrm(nM996Tpr,lPeWhere,NFSAIDA)
	//Chama método para retornar campos de forma agrupada
	lGroup := Iif(lPeWhere .Or. lPeCTB .Or. lPeBase , .F.,.T.)
	cSlctSFT := oApurEFD:GetCmpSFT(nM996Tpr,lGroup,lPeWhere)
	//Chama método para voltar filtro das operações de saídas
	cFiltro  := oApurEFD:GetWhrSFT(NFSAIDA)

	cFiltro := '%' + cFiltro + '%'

	//Chama método para retornar group by de saída
	If !lPeWhere .And. !lPeBase .And. !lPeCTB
		//Caso seja efetuado join com SC5, não deverá realizar group by
		cGroupBy	:=	oApurEFD:GetGrpSFT(nM996Tpr)
	EndIF
	cGroupBy := '%' + cGroupBy + '%'
	BeginSql Alias cAliasSFT
	COLUMN FT_DTFIMNT AS DATE
	SELECT
		%Exp:cSlctSFT%

	FROM
		%Exp:cFrom%

	WHERE
		%Exp:cFiltro%
		SFT.%NotDel%

	%Exp:cGroupBy%

	EndSql

	DbSelectArea (cAliasSFT)
	(cAliasSFT)->(DbGoTop ())
	ProcRegua ((cAliasSFT)->(RecCount ()))

	If lCPRBNF
		oCPRB:=CPRBEFD():New()
		oCPRB:SetDtIni(dDataDe)
		oCPRB:SetFilial(aXFilial)
	Endif

	Do While !(cAliasSFT)->(Eof ())

		nBaseCalc  := (cAliasSFT)->FT_BASEPIS
		lValdAux   := .T.
		nValExport := 0
		If lPeBase
			nBaseCalc := 0
			nBaseCalc := ExecBlock("EFDCON02",.F.,.F.,{(cAliasSFT)})
			//Processa ponto de entrada passando chave da nota
			//Se retornar valor zero, deverá pular a geração desta nota
			If nBaseCalc == 0
				lValdAux := .F.
			EndIf
		EndIF
		cModNF := ''
		If oApurEFD:ChkRegraNf((cAliasSFT)->FT_ESPECIE,(cAliasSFT)->FT_CFOP,NFSAIDA,,@cModNF,(cAliasSFT)->FT_CSTPIS) .AND. lValdAux

			If lPeCTB
				cConta := ""
				cConta	:=	ExecBlock("SPDPIS07", .F., .F., {	(cAliasSFT)->FT_FILIAL,;
					(cAliasSFT)->FT_TIPOMOV,;
					(cAliasSFT)->FT_SERIE,;
					(cAliasSFT)->FT_NFISCAL,;
					(cAliasSFT)->FT_CLIEFOR,;
					(cAliasSFT)->FT_LOJA,;
					(cAliasSFT)->FT_ITEM,;
					(cAliasSFT)->FT_PRODUTO,;
					(cAliasSFT)->FT_CONTA})
			Endif

			//---------------------
			//Informações da nota
			//---------------------
			//Busca valor de ICMS ST para abater do registro 0111 caso o parâmetro MV_DSTRB esteja habilitado
			IF lDSTRB
				nValST	:= FSA008VLST(cAliasSFT,'2',cMVEstado,cMVSUBTRIB,cMVCFE210, cStUfs , cStUf , lRESF3FT, cSTNIEUF)
				oApurEFD:setIcmsSt( nValST )
			EndIF
			//Busca valor dO IPI para abater do registro 0111 caso o parâmetro MV_DIPIRB esteja habilitado
			IF lIPIRB
				nValipi :=(cAliasSFT)->FT_VALIPI
				oApurEFD:setValIpi( nValipi )
			Endif

			nDescZFR := Iif((cAliasSFT)->FT_TIPO <> "D",(cAliasSFT)->FT_DESCZFR,0)

			oApurEFD:SetOrigem(FISCALSAI)
			oApurEFD:SetCFOP(	(cAliasSFT)->FT_CFOP)
			If cModNF $'07/08/09/10/11/26/27/57/63/67/8B' //Alteração realizada para que gere a partir do FT_VALCONT na Apuração e no arquivo magnético para as especies identificadas.
				nReceita:= (cAliasSFT)->FT_VALCONT
				oApurEFD:SetReceita(nReceita)
			Else
				nReceita:= Iif(cReg == 2 .And. cReg2 == 1,(cAliasSFT)->FT_VALCONT + (cAliasSFT)->FT_DESCONT -(nValipi + nValST),(cAliasSFT)->FT_TOTAL + nDescZFR)
				oApurEFD:SetReceita(nReceita)
			Endif

			oApurEFD:SetEspecie((cAliasSFT)->FT_ESPECIE)
			oApurEFD:SetTNatRec((cAliasSFT)->FT_TNATREC)
			oApurEFD:SetCNatRec((cAliasSFT)->FT_CNATREC)
			oApurEFD:SetGNatRec((cAliasSFT)->FT_GRUPONC)
			oApurEFD:SetDNatRec((cAliasSFT)->FT_DTFIMNT)
			oApurEFD:SetQtde((cAliasSFT)->FT_QUANT)
			If cReg == 4
				oApurEFD:SetTpReg(DefRegime(nM996Tpr,cAliasSFT))
			EndIF

			//Verifica se operação de motocicleta
			lMoto	:= Iif((cAliasSFT)->ft_tnatrec  == '4312' .AND. SubStr((cAliasSFT)->ft_cnatrec,1,2) $ '20/30',.T.,.F.)

			//Verifica se operação de Venda á ZFM de produtos da natureza de receita 4312 grupo 400 e com as CFOP's especificas para operação para de venda para ZFM.
			//Legislação Issue DSERFIS1-30893
			If (cAliasSFT)->FT_TNATREC  == '4312' .And. SubStr((cAliasSFT)->FT_CNATREC,1,2) =='40';
					.And. (cAliasSFT)->FT_CSTPIS == '05' .And. Alltrim((cAliasSFT)->FT_CFOP) $ '5109/5110/6109/6110'
				lVenSTZFM := .T.
			Endif

			//--------------------
			//Informações do PIS
			//--------------------
			oApurEFD:SetTributo(PIS)
			oApurEFD:SetCST((cAliasSFT)->FT_CSTPIS)
			oApurEFD:SetAlqTrib((cAliasSFT)->FT_ALIQPIS)
			oApurEFD:SetBcTrib((cAliasSFT)->FT_BASEPIS)
			oApurEFD:SetValTrib((cAliasSFT)->FT_VALPIS)
			oApurEFD:SetBaseST((cAliasSFT)->FT_BASEPS3)
			oApurEFD:SetValST((cAliasSFT)->FT_VALPS3)
			oApurEFD:SetAlqSt((cAliasSFT)->FT_ALIQPS3)
			oApurEFD:SetVlPauta((cAliasSFT)->FT_PAUTPIS)
			oApurEFD:SetConta((cAliasSFT)->FT_CONTA)

			If !lPeCTB
				oApurEFD:SetConta((cAliasSFT)->FT_CONTA)
			Else
				oApurEFD:SetConta(cConta)
			EndIf

			IF lPeBase .Or. lDecPisCof
				oApurEFD:SetBcTrib(nBaseCalc)
				oApurEFD:SetValTrib(nBaseCalc *(cAliasSFT)->FT_ALIQPIS / 100)
			EndIF

			oApurEFD:AgrpContr(lSPDPIS10,cAliasSFT)

			//----------------------
			//Informações da COFINS
			//----------------------
			oApurEFD:SetTributo(COFINS)
			oApurEFD:SetCST((cAliasSFT)->FT_CSTCOF)
			oApurEFD:SetAlqTrib((cAliasSFT)->FT_ALIQCOF)
			oApurEFD:SetBcTrib((cAliasSFT)->FT_BASECOF)
			oApurEFD:SetValTrib((cAliasSFT)->FT_VALCOF)
			oApurEFD:SetBaseST((cAliasSFT)->FT_BASECF3)
			oApurEFD:SetValST((cAliasSFT)->FT_VALCF3)
			oApurEFD:SetAlqSt((cAliasSFT)->FT_ALIQCF3)
			oApurEFD:SetVlPauta((cAliasSFT)->FT_PAUTCOF)
			oApurEFD:SetConta((cAliasSFT)->FT_CONTA)

			If !lPeCTB
				oApurEFD:SetConta((cAliasSFT)->FT_CONTA)
			Else
				oApurEFD:SetConta(cConta)
			EndIf

			IF lPeBase .Or. lDecPisCof
				oApurEFD:SetBcTrib(nBaseCalc)
				oApurEFD:SetValTrib(nBaseCalc *(cAliasSFT)->FT_ALIQCOF / 100)
			EndIF

			oApurEFD:AgrpContr(lSPDPIS10,cAliasSFT)

			//---------------------------------------------------------
			//Identificar qual bloco esta receita pertence, A, C ou D.
			//---------------------------------------------------------
			IF Empty(cModNF) .OR. (!lDFSRVAC .AND. cModNF == '55' .AND. cMVEstado == 'DF')
				//Bloco A
				cBloco	:= "A"
			ElseIf cModNF $ '07/08/09/10/11/26/27/57/63/67/8B/13/18/21/22' .or. oApurEFD:ValidModTeleCom(cModNF, Alltrim((cAliasSFT)->FT_CFOP), .T.)
				//Bloco D
				cBloco	:= "D"
			Else
				//BLoco C
				cBloco	:= "C"
			EndIF

			//Método que acumula as receitas por blocos A, C, D e F.
			oApurEFD:RecBlocos(cBloco)

			//Grava CST PIS COFINS ST
			IF lMoto
				oApurEFD:SetCST((cAliasSFT)->FT_CSTCOF)
				oApurEFD:SetBcTrib((cAliasSFT)->FT_BASECF3)
				oApurEFD:SetReceita(0)
				cRegime := oApurEFD:GetRegOpe()
				oApurEFD:SetRegOpe('2') //Quando for PIS COFINS ST Sempre grava como cumulativo Aliq: 0.65 e 3
				oApurEFD:GrvResCST(,cBloco)

				//Restaura valores
				oApurEFD:SetRegOpe(cRegime)
				oApurEFD:SetCST('01') //processa substituição tributária de motocicleta adicionando cst 01
				oApurEFD:SetBcTrib((cAliasSFT)->FT_BASECOF)
				oApurEFD:SetReceita(nReceita)
			Endif

			//Grava CST adicional para operações de Venda para ZFM - DSERFIS1-30893
			If lVenSTZFM
				oApurEFD:SetCST((cAliasSFT)->FT_CSTCOF)
				oApurEFD:SetBcTrib((cAliasSFT)->FT_BASECF3)
				oApurEFD:SetReceita(0)
				oApurEFD:SetRecBrut((cAliasSFT)->FT_VALCONT + (cAliasSFT)->FT_DESCONT + nDescZFR)
				cRegime := oApurEFD:GetRegOpe()
				oApurEFD:GrvResCST(,cBloco)

				//Restaura valores para mais abaixo gravar com o CST06
				oApurEFD:SetCST('06')
				oApurEFD:SetBcTrib((cAliasSFT)->FT_BASECOF)
			Endif

			//Tratativa de base de calculo para CST 05 assim como existe na tratativa do bloco C170 e C180 - DSERFIS1-30893
			If (cAliasSFT)->FT_CSTCOF == '05' .And. !lmoto .And. !lVenStZFM
				oApurEFD:SetBcTrib((cAliasSFT)->FT_BASECF3)
				oApurEFD:SetAlqTrib((cAliasSFT)->FT_ALIQCF3)
				oApurEFD:SetValTrib((cAliasSFT)->FT_VALCF3)
			Endif

			//--------------------
			//Informações da CPRB
			//--------------------
			If lCPRBNF
				//Verifica parâmetro para definir se utilizará código de serviço ou de outros serviços.
				lAtuCPRB := .T.
				oCPRB:SetDtRefer(dDataDe)
				oCPRB:SetCodAtiv((cAliasSFT)->FT_ATIVCPB)
				oCPRB:SetVlBrut((cAliasSFT)->FT_VALCONT + (cAliasSFT)->FT_DESCONT - nValipi -nValST)

				If SubStr((cAliasSFT)->FT_CFOP,1,1) == "7" .Or. Alltrim((cAliasSFT)->FT_CFOP)$cMV_EXPIND //Acumula valor de receita exportação
					nValExport := (cAliasSFT)->FT_VALCONT
				EndIf

				If !Empty((cAliasSFT)->FT_ATIVCPB)
					nExclusao = (cAliasSFT)->FT_DESCONT + nValExport

					If !lIPIRB
						nExclusao += (cAliasSFT)->FT_VALIPI
					EndIF

					If !lDSTRB .And.  oCPRB:GetVlBrut() - (cAliasSFT)->FT_ICMSRET >= Max((cAliasSFT)->FT_BASECPB - nValExport, 0)
						nExclusao += (cAliasSFT)->FT_ICMSRET
					EndIF
				Else
					nExclusao = 0

				EndIF
				oCPRB:SetVlExcl(nExclusao)
				oCPRB:SetVlCPRB(IIF(nValExport > 0, 0, (cAliasSFT)->FT_VALCPB))
				oCPRB:SetAliq((cAliasSFT)->FT_ALIQCPB)
				oCPRB:SetBase(Max((cAliasSFT)->FT_BASECPB - nValExport, 0))// Aqui devo retirar o valor da base e validar para nao gerar valor negativo pois quando exportação o matxfis ainda nao gera o valor da base do CPRB zerada.
				oCPRB:SetVlAtiv((cAliasSFT)->FT_VALCONT + (cAliasSFT)->FT_DESCONT - nValipi -nValST)
				oCPRB:SetVlAtiv(Iif((cAliasSFT)->FT_VALCPB > 0,(cAliasSFT)->FT_VALCONT + (cAliasSFT)->FT_DESCONT - nValipi -nValST,0))
				oCPRB:SetConta((cAliasSFT)->FT_CONTA)
				oCPRB:SetCodRec(Iif(AllTrim((cAliasSFT)->FT_ATIVCPB)$cSPCBPSE,aParSX1[16],aParSX1[17]))
				oCPRB:SetFilApu(IIf(lIndividu,oCPRB:BuscaxFil('CKY'),cFilialMat))
				// Verifica se codigo é não desonerado
				If lNTrib
					IF (cAliasSFT)->FT_ATIVCPB $ cOutRec
						oCPRB:SetNTrib(.T.)
					Endif
				Endif

				oCPRB:AgrupaCPRB()

				If !Empty((cAliasSFT)->FT_ATIVCPB) .And. AliasIndic('F2S')
					If (cAliasSFT)->FT_VALIPI > 0
						oCPRB:SetDetExcl('07', (cAliasSFT)->FT_VALIPI, 'IPI')
						oCPRB:DetalhCPRB()
					EndIf
					If(cAliasSFT)->FT_ICMSRET > 0
						oCPRB:SetDetExcl('08', (cAliasSFT)->FT_ICMSRET,'ICMS-ST')
						oCPRB:DetalhCPRB()
					EndIf
				EndIf

			Endif

			//Conforme consultoria tributária o campo 06 do registro 0111, o campo 03 do registro 0145 e o campo 04 do registro P100 devem possuir o mesmo valor de receita bruta
			oApurEFD:SetReceita((cAliasSFT)->FT_TOTAL + nDescZFR)
			oApurEFD:SetRecBrut((cAliasSFT)->FT_VALCONT + (cAliasSFT)->FT_DESCONT + nDescZFR)
			oApurEFD:AcumRecBru()
			//Passo FT_VALCONT neste trecho somente para que a primeira aba da apuração o valor da receita seja o valor contábil, considerando
			//valores de despesas acessórias, frete,seguro, desconto etc...
			If cModNF $'07/08/09/10/11/26/27/57/63/67/8B'
				oApurEFD:SetReceita(nReceita)
			else
				oApurEFD:SetReceita((cAliasSFT)->FT_VALCONT + (cAliasSFT)->FT_DESCONT - nValipi - nValST)
			Endif
			oApurEFD:GrvResCST(.F.,"P")
			oApurEFD:setIcmsSt(0)

		EndIF

		(cAliasSFT)->(DbSkip ())
	EndDo

	If AliasIndic("F3Z") .AND. lCPRBNF
		cAliasSON	:=	GetNextAlias()
		CPRBxCNO(@cAliasSON, oApurEFD)

		Do While !(cAliasSON)->(Eof())

			cModNF := ''
			If oApurEFD:ChkRegraNf((cAliasSON)->FT_ESPECIE,(cAliasSON)->FT_CFOP,NFSAIDA,,@cModNF,(cAliasSFT)->FT_CSTPIS)
				oCPRB:SetDtRefer(dDataDe)
				oCPRB:SetCodAtiv((cAliasSON)->FT_ATIVCPB)
				oCPRB:SetVlBrut((cAliasSON)->FT_VALCONT + (cAliasSON)->FT_DESCONT - nValipi -nValST)
				If !Empty((cAliasSON)->FT_ATIVCPB)
					nExclusao = (cAliasSON)->FT_DESCONT + nValExport

					If !lIPIRB
						nExclusao += (cAliasSON)->FT_VALIPI
					EndIF

					If !lDSTRB
						nExclusao += (cAliasSON)->FT_ICMSRET
					EndIF
				Else
					nExclusao = 0
				EndIF
				oCPRB:SetVlExcl(nExclusao)
				oCPRB:SetVlCPRB((cAliasSON)->FT_VALCPB)
				oCPRB:SetAliq((cAliasSON)->FT_ALIQCPB)
				oCPRB:SetBase((cAliasSON)->FT_BASECPB)
				oCPRB:SetVlAtiv((cAliasSON)->FT_VALCONT + (cAliasSON)->FT_DESCONT - nValipi -nValST)
				oCPRB:SetVlAtiv(Iif((cAliasSON)->FT_VALCPB > 0,(cAliasSON)->FT_VALCONT + (cAliasSON)->FT_DESCONT - nValipi -nValST,0))
				oCPRB:SetConta((cAliasSON)->FT_CONTA)
				oCPRB:SetFilApu(IIf(lIndividu,oCPRB:BuscaxFil('F3Z'),cFilialMat))
				oCPRB:SetCNO((cAliasSON)->ON_CNO)

				oCPRB:CNOxCPRB()
			EndIf

			(cAliasSON)->(DbSkip())
		EndDo

		(cAliasSON)->(DbCloseArea())
	EndIf

	If lCPRBNF .And. lAtuCPRB
		//Grava os valores alterados.
		oCPRB:GravaCPRB()
	Endif

	oApurEFD:FechaAlias(cAliasSFT)

	//FINALIZA GRAVAÇÃO DAS RECEITAS.
	oApurEFD:Finaliza('1')

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001Difer()
Função que irá buscar valores de diferimento dos débitos para serem processados
na apuração

@param		dDataDe	-Data inicial do período de apuração
			dDataAte	-Data final do período de apuração
			aXFilial	-Array com conteúdo do xFilial das tabelas da apuração			

@author Erick G. Dias
@since 14/04/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001Difer(dDataDe,dDataAte,aXFilial,cTabDif)
	Local cAliasCFA		:= 'CFA'
	Local cAliasCFB		:= 'CFB'
	Local	aTpContr		:=	{"PIS","COF"}
	Local cSelect			:= ''
	Local cWhere			:= ''
	Local	cPeriod		:=	Substr(DTOS(dDataDe),5,2)+Substr(DTOS(dDataDe),1,4)
	Local nCont			:= 0
	Local oDifer
	Local lNewProc		:= ISA001NDIF()
	Local aRegM300		:={}
	Local aRegM700		:={}

	Default cTabDif := "3"

	//Cria objeto para tratar os valores da apuração
	oDifer 	:= DIFPISCOF():New()
	oDifer:SetFilial(aXFilial)
	oDifer:SetDtIni(dDataDe)
	oDifer:LoadDebito()
	oDifer:LoadCredit()

	For nCont := 1 to Len(aTpContr)

		If cTabDif $"1|3"

			cAliasCFA	:=	GetNextAlias()
			cSelect		:=	"%CFA.CFA_CODCON, CFA.CFA_TPCON, CFA.CFA_CNPJ, CFA.CFA_TOTVEN, CFA.CFA_VLNREC, CFA.CFA_CONDIF, "
			cSelect		+=	"CFA.CFA_PERAPU, CFA.CFA_ALIQ, CFA_CREDIF, CFA_CODCRE%"
			cWhere		:=	"%CFA.CFA_FILIAL='"+xFilial("CFA")+"' AND "
			cWhere		+=	"CFA.CFA_PERAPU='"+cPeriod+"' AND "
			cWhere		+=	"CFA.CFA_TPCON='"+aTpContr[nCont]+"' AND "

			IF lNewProc
				cWhere		+=	"CFA.CFA_CONSOL= '2' AND "
			EndIF

			cWhere		+= "%"

			BeginSql Alias cAliasCFA
			
			SELECT			    	 
				%Exp:cSelect%		
		
			FROM 
				%Table:CFA% CFA													
			WHERE
				%Exp:cWhere%
				CFA.%NotDel%	
			EndSql

			DbSelectArea (cAliasCFA)
			(cAliasCFA)->(DbGoTop ())
			Do While !(cAliasCFA)->(Eof ())
				//-------------------------------------------------------------------------------
				//Processa informações da tabela CFA, referente ao diferimento do próprio período
				//-------------------------------------------------------------------------------

				oDifer:SetTributo(Iif(nCont == 1,PIS,COFINS))
				oDifer:SetTpDif('1') //Indica diferimento de valores do período de débito
				oDifer:SetCodigo((cAliasCFA)->CFA_CODCON)
				oDifer:SetAliq((cAliasCFA)->CFA_ALIQ)
				oDifer:SetVlDif((cAliasCFA)->CFA_CONDIF)
				oDifer:Diferir()

				//Faz diferimento dos valores dos créditos
				oDifer:SetTributo(Iif(nCont == 1,PIS,COFINS))
				oDifer:SetTpDif('1') //Indica diferimento de valores do período
				oDifer:SetCodigo((cAliasCFA)->CFA_CODCRE)
				oDifer:SetVlDif((cAliasCFA)->CFA_CREDIF)
				oDifer:Diferir()

				(cAliasCFA)->(DbSkip())
			EndDo

			oDifer:FechaAlias(cAliasCFA)

		EndIf

		If cTabDif $"2|3"

			cAliasCFB	:=	GetNextAlias()
			cSelect		:=	"%CFB.CFB_CODCON, CFB.CFB_TPCON, CFB.CFB_DTPGTO, CFB.CFB_PERDIF, CFB.CFB_CONREC, "
			cSelect		+=	"CFB.CFB_VLRREC,CFB.CFB_PERAPU, CFB.CFB_ALIQ,CFB.CFB_NATCRE, CFB.CFB_CREDES%"
			cWhere		:=	"%CFB.CFB_FILIAL='"+xFilial("CFB")+"' AND "
			cWhere		+=	"CFB.CFB_PERAPU='"+cPeriod+"' AND "
			cWhere		+=	"CFB.CFB_TPCON='"+aTpContr[nCont]+"' AND "

			IF lNewProc
				cWhere		+=	"CFB.CFB_CONSOL='2' AND "
			EndIF

			cWhere		+= "%"

			BeginSql Alias cAliasCFB
			
			SELECT			    	 
				%Exp:cSelect%		
		
			FROM 
				%Table:CFB% CFB													
			WHERE
				%Exp:cWhere%
				CFB.%NotDel%	
			EndSql

			DbSelectArea (cAliasCFB)
			(cAliasCFB)->(DbGoTop ())
			Do While !(cAliasCFB)->(Eof ())

				//-------------------------------------------------------------------------------
				//Processa informações da tabela CFA, referente ao diferimento de período anterior
				//-------------------------------------------------------------------------------

				oDifer:SetTributo(Iif(nCont == 1,PIS,COFINS))
				oDifer:SetTpDif('2') //Indica diferimento de período anterior
				oDifer:SetCodigo((cAliasCFB)->CFB_CODCON)
				oDifer:SetAliq((cAliasCFB)->CFB_ALIQ)
				oDifer:SetVlDif((cAliasCFB)->CFB_CONREC - (cAliasCFB)->CFB_CREDES )
				oDifer:Diferir()

				(cAliasCFB)->(DbSkip())
			EndDo



			//********************************************************************************************************************************
			// Criando Array valores diferidos em períodos anteriores


			aAdd(aRegM300, {})
			nPos := Len(aRegM300)
			aAdd (aRegM300[npos],"M300")									//01 - REG
			aAdd (aRegM300[nPos],(cAliasCFB)->CFB_CODCON)				   	//02 - COD. CONTRIBUICAO (preencher conforme tabela descrita no layout)
			aAdd (aRegM300[nPos],(cAliasCFB)->CFB_VLRREC)					//03 - VALOR APURADO
			aAdd (aRegM300[nPos],(cAliasCFB)->CFB_NATCRE)					//04 - NAT. CREDITO DIFERIDO
			aAdd (aRegM300[nPos],(cAliasCFB)->CFB_CREDES)					//05 - VALRO CRED. DESCONTAR
			aAdd (aRegM300[nPos],(cAliasCFB)->CFB_CONREC)			 		//06 - VALOR CONTRIBUICAO A RECOLHER
			aAdd (aRegM300[nPos],(cAliasCFB)->CFB_PERAPU)					//07 - PERIODO DA APURACAO (MMAAAA)
			aAdd (aRegM300[nPos],(cAliasCFB)->CFB_PERDIF)					//08 - DATA RECEBIMENTO


			aAdd(aRegM700, {})
			nPos := Len(aRegM700)
			aAdd (aRegM700[npos],"M700")									//01 - REG
			aAdd (aRegM700[nPos],(cAliasCFB)->CFB_CODCON)					//02 - COD. CONTRIBUICAO (preencher conforme tabela descrita no layout)
			aAdd (aRegM700[nPos],(cAliasCFB)->CFB_VLRREC)					//03 - VALOR APURADO
			aAdd (aRegM700[nPos],(cAliasCFB)->CFB_NATCRE)					//04 - NAT. CREDITO DIFERIDO
			aAdd (aRegM700[nPos],(cAliasCFB)->CFB_CREDES)					//05 - VALRO CRED. DESCONTAR
			aAdd (aRegM700[nPos],(cAliasCFB)->CFB_CONREC)			 		//06 - VALOR CONTRIBUICAO A RECOLHER
			aAdd (aRegM700[nPos],(cAliasCFB)->CFB_PERAPU)					//07 - PERIODO DA APURACAO (MMAAAA)
			aAdd (aRegM700[nPos],(cAliasCFB)->CFB_PERDIF)					//08 - DATA RECEBIMENTO

			//*************************************************************************************************************************************

			oDifer:FechaAlias(cAliasCFB)

		EndIf

	Next nCont


	//-------------------------------------------------------------------------------
	//CHAMA FUNÇÃO PARA PROCESSAR OS VALORES DE DIFERIMENTO DE PERÍODOS ATUAL
	//-------------------------------------------------------------------------------
	If ExistBlock("SPDPCD")
		A001PEDFAT(dDataDe,dDataAte,oDifer)
	EndIF

	//-------------------------------------------------------------------------------
	//CHAMA FUNÇÃO PARA PROCESSAR OS VALORES DE DIFERIMENTO DE PERÍODOS ANTERIORES
	//-------------------------------------------------------------------------------
	If ExistBlock("SPDPCANT")
		A001PEDFAN(dDataDe,dDataAte,oDifer,aRegM300,aRegM700)
	EndIF

	FreeObj(oDifer)
	oDifer:= nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001F700()
Função que ir[a buscar os valores de Outras Deduções de PIS e COFINS,
Irá fazer a dedução ou gravar no saldo de deduções.

@param		dDataDe	-Data inicial do período de apuração
			cRegime	-Regime da Apuração escolhido pelo usuário			
			oApurPIS	-Objeto da apuração de PIS
			oApurCof	-Objeto da Apuração da COFINS			
			aXFilial	-Array com conteúdo do xFilial das tabelas de apuração

@author Erick G. Dias
@since 14/04/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001F700(dDataDe,cRegime,oApurPIS,oApurCof,aXFilial,cFilialMat)

	Local cSelect			:= ''
	Local cWhere			:= ''
	Local cAliasCF2			:= ''
	Local cIndNat			:= ''
	Local cPerido			:= strzero(Month(dDataDe),2)+str(Year(dDataDe),4)
	Local oOutDed
	Local lConta			:= CF2->(FieldPos("CF2_CONTA") > 0)

	oOutDed := DEDUCAOPC():New()
	oOutDed:SetFilial(aXFilial)
	oOutDed:SetDtIni(dDataDe)
	oOutDed:SetTpDed('1') // Indica que será realizado dedução referente a outras deduções.
	oOutDed:SetFilApu(cFilialMat) // Indica que será realizado dedução referente a outras deduções.

	If cRegime == '1'
		//Exclusivo não cumulativo
		cIndNat	:= '0'
	ElseIF cRegime $ '2/3/'
		//Exclusivo Cumulativo
		cIndNat	:= '1'
	EndIF

	cAliasCF2	:=	GetNextAlias()
	cSelect	:=	"%CF2.*%"
	cWhere	:=	"%CF2.CF2_FILIAL='"+xFilial("CF2")+"' AND "
	cWhere	+=	"CF2.CF2_PER='"+cPerido+"' AND "
	If !Empty(cIndNat)
		cWhere	+=	"CF2.CF2_INDNAT='"+cIndNat+"' AND "
	Endif
	cWhere	+= '%'

	BeginSql Alias cAliasCF2
    
	SELECT			    	 
		%Exp:cSelect%		

	FROM 
		%Table:CF2% CF2													
	WHERE
		%Exp:cWhere%
		CF2.%NotDel%	
	EndSql

	DbSelectArea (cAliasCF2)
	(cAliasCF2)->(DbGoTop ())

	If !(cAliasCF2)->(Eof ())

		//Carrega as informações atualizadas da apuração
		oApurPIS:LoadApurPC(PIS)

		//Carrega as informações atualizadas da apuração
		oApurCof:LoadApurPC(COFINS)
	EndIF


	Do While !(cAliasCF2)->(Eof ())

		//---------------------
		//FAZ A DEDUÇÃO DO PIS
		//---------------------
		oOutDed:SetTributo(PIS)
		oOutDed:SetValDed((cAliasCF2)->CF2_DEDPIS)
		oOutDed:SetRegime(IiF((cAliasCF2)->CF2_INDNAT=='0',NAOCUMULAT,CUMULAT))
		oOutDed:SetConta(Iif(lConta,(cAliasCF2)->CF2_CONTA,""))
		oOutDed:Deduz(oApurPIS)

		//------------------------
		//FAZ A DEDUÇÃO DA COFINS
		//------------------------
		oOutDed:SetTributo(COFINS)
		oOutDed:SetValDed((cAliasCF2)->CF2_DEDCOF)
		oOutDed:SetRegime(IiF((cAliasCF2)->CF2_INDNAT=='0',NAOCUMULAT,CUMULAT))
		oOutDed:SetConta(Iif(lConta,(cAliasCF2)->CF2_CONTA,""))
		oOutDed:Deduz(oApurCof)

		(cAliasCF2)->(DBSKIP())
	EndDo

	oOutDed:FechaAlias(cAliasCF2)

	FreeObj(oOutDed)
	oOutDed:= NIL

Return

Static Function GetRetCKY(dDataDe,dDataAte,aXFilial)

	Local cAliasCKY	:= ''
	Local cSlct		:= ''
	Local cFiltro	:= ''
	Local cGroupBy	:= ''
	Local oEFDGen	:= EFDGEN():New()

	oEFDGen:SetFilial(aXFilial)

	cSlct	:= "%SUM(CKY.CKY_PISRET) CKY_PISRET , SUM(CKY.CKY_COFRET) CKY_COFRET, CKY_INDRET , CKY_INDREC%"
	cFiltro += "%CKY.CKY_FILIAL= '"+ oEFDGen:BuscaxFil('CKY') + "' AND "
	cFiltro += "CKY.CKY_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
	cFiltro += "CKY.CKY_PER<= '" + %Exp:DToS (dDataAte)% + "' AND %"

	cGroupBy	:=	"%GROUP BY CKY.CKY_INDRET,	CKY_INDREC %"

	cAliasCKY	:=	GetNextAlias()

	BeginSql Alias cAliasCKY
	SELECT			    	 
		%Exp:cSlct%		

	FROM 
		%Table:CKY% CKY													
	WHERE
		%Exp:cFiltro%
		CKY.%NotDel% 
        
	%Exp:cGroupBy%	
	EndSql

Return cAliasCKY

Static Function DeduzReten(dDataDe,dDataAte,aXFilial,oApurPis,oApurCof,cCtlDedRet,cFilialMat)

	Local nCont		:= 0
	Local dDtAnt	:= firstday(dDataDe) - 1
	Local nContAnt	:= 0
	Local cPerAnt	:= Strzero(Month(dDtAnt),2)+cvaltochar(Year(dDtAnt))
	Local cPerAtu	:= Strzero(Month(dDataDe),2)+cvaltochar(Year(dDataDe))
	Local oOutRet
	Local cAliasCKY	:= ''
	Local lSaldo	:= .F.

	If cCtlDedRet $ "S|A"  // Controle para execução do bloco de saldos.

		For nContAnt := 1 to 2
			oOutRet := DEDUCAOPC():New()
			oOutRet:SetFilial(aXFilial)
			oOutRet:SetDtIni(dDataDe)
			oOutRet:SetPergrva(cPerAnt)
			oOutRet:SetTpDed('2') // Indica que será realizado dedução referente a retenção na fonte
			oOutRet:SetTributo(Alltrim(str(nContAnt)))
			oOutRet:LoadSaldo()
			aSaldo	:= oOutRet:GetSldRet()
			oOutRet:SetPergrva(cPerAtu)
			oOutRet:SetProcAnt('1')
			For nCont:= 1 to Len(aSaldo)

				//---------------------------
				//FAZ A DEDUÇÃO DO PIS/COFINS
				//---------------------------
				lSaldo := .T.
				oOutRet:SetTributo(Alltrim(str(nContAnt)))

				//Quando saldo desbloqueado é necessario decrescer o valor de (Ressarcimento+Compensacao) do valor da dedução(VLDISP) a ser realizada(gravada) na CKR.
				oOutRet:SetValDed(aSaldo[nCont][6] - IIF(aSaldo[nCont][10] $ "2", (aSaldo[nCont][8] + aSaldo[nCont][9]), 0))

				oOutRet:SetVlDisp(aSaldo[nCont][6])  //aSaldo,(cAlias)->VLDISP  6
				oOutRet:SetApurPer(cPerAtu)

				oOutRet:SetTotRet(aSaldo[nCont][5])  //aSaldo,(cAlias)->TOTRET  5
				oOutRet:SetRessar(aSaldo[nCont][8])  //aSaldo,(cAlias)->RESSA   8
				oOutRet:SetCompen(aSaldo[nCont][9])  //aSaldo,(cAlias)->COMP    9
				oOutRet:SetBloque(aSaldo[nCont][10]) //aSaldo,(cAlias)->RESRET  10

				oOutRet:SetRegime(aSaldo[nCont][4])
				oOutRet:SetNatRet(aSaldo[nCont][1])
				oOutRet:SetMesAno(aSaldo[nCont][3])
				oOutRet:SetPergrva(cPerAtu)

				//Quando somatoria de Ressarcimento e Compensação ja forem iguais ao Valor Disponivel, significa que neste mes o valor das retencoes ja foram consumidos.
				If aSaldo[nCont][6] > (aSaldo[nCont][8] + aSaldo[nCont][9]) .Or. aSaldo[nCont][10] $ " 2"

					//Quando periodos anteriores seto o parametro /*lPerAnt*/ para que o metodo Deduz, analise a tabela SFV|SFW
					//de forma a analisar e incluir dados de historico de retencoes
					oOutRet:Deduz(Iif (nContAnt==1 ,oApurPIS ,oApurCOF  ), lSaldo, /*lPerAnt*/ .T.)
				EndIf

			Next nCont
			FreeObj(oOutRet)
			oOutRet:= nil
		Next nContAnt

	EndIf
	If cCtlDedRet $ "R|A" // Controle para execução do bloco de retenção.
		oOutRet := DEDUCAOPC():New()
		oOutRet:SetFilial(aXFilial)
		oOutRet:SetDtIni(dDataDe)

		oOutRet:SetTpDed('2') // Indica que será realizado dedução referente a retenção na fonte

		oOutRet:SetPergrva(cPerAtu)
		oOutRet:SetMesAno(cPerAtu)
		oOutRet:SetProcAnt('2')

		cAliasCKY:= GetRetCKY(dDataDe,dDataAte,aXFilial)

		lSaldo := .F.

		if !(cAliasCKY)->(EOF())
			//Carrega as informações atualizadas da apuração
			oApurPIS:LoadApurPC(PIS)

			//Carrega as informações atualizadas da apuração
			oApurCof:LoadApurPC(COFINS)
		endif

		While !(cAliasCKY)->(EOF())

			//---------------------
			//FAZ A DEDUÇÃO DO PIS
			//---------------------
			oOutRet:SetTributo(PIS)
			oOutRet:SetValDed((cAliasCKY)->CKY_PISRET)
			oOutRet:SetRegime((cAliasCKY)->CKY_INDREC)
			oOutRet:SetNatRet((cAliasCKY)->CKY_INDRET)

			oOutRet:Deduz(oApurPIS, lSaldo)

			//------------------------
			//FAZ A DEDUÇÃO DA COFINS
			//------------------------
			oOutRet:SetTributo(COFINS)
			oOutRet:SetValDed((cAliasCKY)->CKY_COFRET)
			oOutRet:SetRegime((cAliasCKY)->CKY_INDREC)
			oOutRet:SetNatRet((cAliasCKY)->CKY_INDRET)

			oOutRet:Deduz(oApurCof, lSaldo)

			(cAliasCKY)->(DbSkip())

		EndDo
		oOutRet:FechaAlias(cAliasCKY)
	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001F600()
Função que irá chamar integração com Financeiro para buscar as informações
de retenções na fonte de PIS e COFINS

@param		dDataDe	-Data inicial do período de apuração
			oApurPIS	-Objeto da apuração de PIS
			oApurCof	-Objeto da Apuração da COFINS			
			aXFilial	-Array com conteúdo do xFilial das tabelas de apuração

@author Erick G. Dias
@since 15/04/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001F600(dDataDe,oApurPIS,oApurCof,aXFilial,cFilialMat,lIndividu)

	Local aF600Aux	:= {}
	Local nCont		:= 0
	Local cRegime		:= ''
	Local dDtAnt		:= firstday(dDataDe) - 1
	Local nContAnt	:= 0
	Local cPerAnt		:= Strzero(Month(dDtAnt),2)+cvaltochar(Year(dDtAnt))
	Local cPerAtu		:= Strzero(Month(dDataDe),2)+cvaltochar(Year(dDataDe))
	Local oOutRet
	Local oF600		:=	TABELACKY():New() //Cria objeto para gravação do F100

	aF600Aux:= FinSpdF600(Month(dDataDe),Year(dDataDe))

	For nCont:= 1 To Len(aF600Aux)
		cRegime :=""
		If aF600Aux[nCont][5] == "0"
			cRegime := '2' //cumulativo
		ElseIf aF600Aux[nCont][5] == "1"
			cRegime := '1' //nao cumulativo
		EndIF
		oF600:SetParam('CKY_PER',dDataDe)
		oF600:SetParam('CKY_INDRET',aF600Aux[nCont][1])
		oF600:SetParam('CKY_DTRET',cTod(SubStr(aF600Aux[nCont][2],7,2)+"/"+SubStr(aF600Aux[nCont][2],5,2)+"/"+SubStr(aF600Aux[nCont][2],1,4)))
		oF600:SetParam('CKY_CODREC',Iif(Len(aF600Aux[nCont])>11,aF600Aux[nCont][12],""))
		oF600:SetParam('CKY_INDREC',cRegime)
		oF600:SetParam('CKY_CNPJ',aF600Aux[nCont][6])
		oF600:SetParam('CKY_BASE',aF600Aux[nCont][3])
		oF600:SetParam('CKY_TOTRET',aF600Aux[nCont][4])
		oF600:SetParam('CKY_PISRET',aF600Aux[nCont][7])
		oF600:SetParam('CKY_COFRET',aF600Aux[nCont][8])
		oF600:SetParam('CKY_INDCON',aF600Aux[nCont][9])
		oF600:SetParam('CKY_FILAPU',IIf(lIndividu,oF600:BuscaxFil('CKY'),cFilialMat))
		If aF600Aux[nCont][10] == 'SE5'
			SE5->(dbGoto( aF600Aux[nCont][11]))
			oF600:SetParam('CKY_NUMTIT'	,SE5->E5_NUMERO)
			oF600:SetParam('CKY_PREFIX'	,SE5->E5_PREFIXO)
			oF600:SetParam('CKY_PARC'	,SE5->E5_PARCELA)
			oF600:SetParam('CKY_DTEMIS'	,SE5->E5_DTDIGIT)
			oF600:SetParam('CKY_ORIG'	,SE5->E5_ORIGEM)
		EndIF
		oF600:Save()

	Next nCont

	FreeObj(oF600)
	oF600:= nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001PEF100()
Função que irá chamar o ponto de entrada SPDPIS09 e gravar esta informações
na apuração

@param		dDataDe	-Data inicial do período de apuração
			dDadaAte	-Data Final do período de apuração
			oApurSai	-Objeto para as operações com débitos já criado 
						 para apurar os valores dos créditos
			oApurEnt	-Objeto para as operações com créditos já criado 
						 para apurar os valores dos créditos						 	
			lProcCred	-Indica se irá processar operações de crédito			 
			nTotF100	-Campos com somatório das receitas utilizadas 
						 para o F100			
			lPTitEnt	-Indica se irá processar as operações de entrada
			lPTitSai	-Indica se irá processar as operações de saída		

@author Erick G. Dias
@since 21/04/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001PEF100(aSX1,oApurSai,oApurEnt,lProcCred,lPTitEnt, lPTitSai,cReg, cCredDeb,cFilialMat)
	Local dDataDe := aSX1[1]
	Local dDataAte:= aSX1[2]
	Local lIndividu:=(aSX1[15]==2)
	Local aPEF100		:= {}
	Local x			:= 0
	Local oF100		:=	TABELACL2():New() //Cria objeto para gravação do F100
	Local lGravaF100	:= .F.
	local cAlsPart	:= ''
	Local lAliasPart	:= Cl2->(FIELDPOS('CL2_ALIAS')) > 0

	aPEF100 := ExecBlock("SPDPIS09",.F.,.F.,{FWGETCODFILIAL,dDataDe,dDataAte})
	For x := 1 To Len(aPEF100)
		lGravaF100	:= .F.
		If aPEF100[x][2] == "0"  //Entradas
			If lProcCred
				If lPTitEnt .AND. cCredDeb == '2'
					//----------------------------
					//Informações da Nota Fiscal
					//----------------------------
					oApurEnt:SetRegime(NAOCUMULAT)
					oApurEnt:SetReceita(aPEF100[x][6])
					oApurEnt:SetCodBcc(aPEF100[x][15])

					//-------------------------
					//Informações de PIS
					//-------------------------
					oApurEnt:SetOrigem(TITENTRADA)
					oApurEnt:SetTributo(PIS)
					oApurEnt:SetCST(aPEF100[x][7])
					oApurEnt:SetAlqTrib(aPEF100[x][9])
					oApurEnt:SetBcTrib(aPEF100[x][8])
					oApurEnt:SetValTrib(aPEF100[x][10])
					oApurEnt:SetBaseST(aPEF100[x][8])
					oApurEnt:SetValST(aPEF100[x][10])
					oApurEnt:SetAlqSt(aPEF100[x][9])
					oApurEnt:AgrpCred()
					//----------------------------
					//Informações da COFINS
					//----------------------------
					oApurEnt:SetTributo(COFINS)
					oApurEnt:SetCST(aPEF100[x][11])
					oApurEnt:SetAlqTrib(aPEF100[x][13])
					oApurEnt:SetBcTrib(aPEF100[x][12])
					oApurEnt:SetValTrib(aPEF100[x][14])
					oApurEnt:SetBaseST(aPEF100[x][12])
					oApurEnt:SetValST(aPEF100[x][14])
					oApurEnt:SetAlqSt(aPEF100[x][13])
					oApurEnt:AgrpCred()

					//Agrupa valores para resumo de CST
					oApurEnt:GrvResCST()
					lGravaF100	:= .T.
				EndIF
			EndIF

		ElseIf lPTitSai .AND. cCredDeb == '1'
			//---------------------
			//Informações da nota
			//---------------------
			oApurSai:SetOrigem(TITSAIDA)
			oApurSai:SetReceita(aPEF100[x][6])
			oApurSai:SetTNatRec(aPEF100[x][42])
			oApurSai:SetCNatRec(aPEF100[x][43])
			oApurSai:SetGNatRec(aPEF100[x][44])
			oApurSai:SetDNatRec(aPEF100[x][45])
			If cReg == 4
				oApurSai:SetTpReg(Iif(aPEF100[x][21] == "0",CUMULAT,NAOCUMULAT))
			EndIF

			//--------------------
			//Informações do PIS
			//--------------------
			oApurSai:SetTributo(PIS)
			oApurSai:SetCST(aPEF100[x][7])
			oApurSai:SetAlqTrib(aPEF100[x][9])
			oApurSai:SetBcTrib(aPEF100[x][8])
			oApurSai:SetValTrib(aPEF100[x][10])
			oApurSai:SetBaseST(aPEF100[x][8])
			oApurSai:SetValST(aPEF100[x][10])
			oApurSai:SetAlqSt(aPEF100[x][9])
			oApurSai:AgrpContr()

			//----------------------
			//Informações da COFINS
			//----------------------
			oApurSai:SetTributo(COFINS)
			oApurSai:SetCST(aPEF100[x][11])
			oApurSai:SetAlqTrib(aPEF100[x][13])
			oApurSai:SetBcTrib(aPEF100[x][12])
			oApurSai:SetValTrib(aPEF100[x][14])
			oApurSai:SetBaseST(aPEF100[x][12])
			oApurSai:SetValST(aPEF100[x][14])
			oApurSai:SetAlqSt(aPEF100[x][13])
			oApurSai:AgrpContr()

			//Bloco fixo, pois este ponto de entrada somente gera receita no bloco F.
			oApurSai:RecBlocos("F")

			oApurSai:GrvResCST(,"F")
			lGravaF100	:= .T.

		EndIF

		//gravar cl2

		//ABAIXO GRAVA OS VALORES DO REGISTRO F100 COM DÉBITO
		//---------------------------------------------------
		If lGravaF100
			oF100:SetParam('CL2_PER',dDataDe)
			oF100:SetParam('CL2_REG','F100')
			oF100:SetParam('CL2_INDOP',aPEF100[x][2]) //ok
			oF100:SetParam('CL2_PARTI',aPEF100[x][3]+aPEF100[x][20])//ok
			oF100:SetParam('CL2_ITEM',aPEF100[x][4])//OK
			If Valtype(aPEF100[x][5]) == 'C'
				oF100:SetParam('CL2_DTOPER',ctod(SubStr(aPEF100[x][5],1,2)+"/"+SubStr(aPEF100[x][5],3,2)+"/"+SubStr(aPEF100[x][5],5,4))) //OK
			ElseIf Valtype(aPEF100[x][5]) == 'D'
				oF100:SetParam('CL2_DTOPER',aPEF100[x][5]) //OK
			EndIF
			oF100:SetParam('CL2_VLOPER',aPEF100[x][6]) //ok
			oF100:SetParam('CL2_CSTPIS',aPEF100[x][7])//ok
			oF100:SetParam('CL2_BCPIS',aPEF100[x][8])		 //ok
			oF100:SetParam('CL2_ALQPIS',aPEF100[x][9])	//ok
			oF100:SetParam('CL2_VLPIS',aPEF100[x][10])	//ok
			oF100:SetParam('CL2_CSTCOF',aPEF100[x][11])	//ok
			oF100:SetParam('CL2_BCCOF',aPEF100[x][12])		//ok
			oF100:SetParam('CL2_ALQCOF',aPEF100[x][13])	//ok
			oF100:SetParam('CL2_VLCOF',aPEF100[x][14])	//ok
			oF100:SetParam('CL2_CODBCC',aPEF100[x][15]) //ok
			oF100:SetParam('CL2_INDCRD',aPEF100[x][16]) //verificar
			oF100:SetParam('CL2_CTA',aPEF100[x][17]) //ok
			oF100:SetParam('CL2_CCUS',aPEF100[x][18])		//ok
			oF100:SetParam('CL2_DESCR',aPEF100[x][19])
			oF100:SetParam('CL2_FILAPU',IIf(lIndividu,oF100:BuscaxFil('CL2'),cFilialMat) )
			oF100:SetParam('CL2_CLIFOR' , aPEF100[x][3]  )
			oF100:SetParam('CL2_LOJA'   , aPEF100[x][20] )


			IF lAliasPart
				If Len(aPEF100[x]) >= 49
					cAlsPart	:= 	aPEF100[x][49]
				ElseIF aPEF100[x][2] == "0"
					cAlsPart	:= 	'SA2'
				Else
					cAlsPart	:= 	'SA1'
				EndIF
				oF100:SetParam('CL2_ALIAS',cAlsPart)
			EndIF

			oF100:Save()
		EndIF
	Next x
	FreeObj(oF100)
	oF100:= Nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001PISSTR()
Função que irá processar as informações de débito do ponto de entrada SPDPISTR

@param		dDataDe 	- Data de início da apuração
			dDataAte 	- Data final da apuração
			oApurSai 	- Objeto de apuração que irá tratar os valores dos débitos
			 	
@author Erick G. Dias
@since 21/05/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001PISSTR(dDataDe,dDataAte,oApurSai,cReg)

	Local aSPDPisTR	:= {}
	Local nCont		:= 0

	aSPDPisTR := ExecBlock("SPDPISTR",.F.,.F.,{FWGETCODFILIAL,dDataDe,dDataAte})

	If Len(aSPDPisTR)>0 .AND. !Empty(aSPDPisTR[1])
		For nCont:=1 to Len(aSPDPisTR[01])

			//Se não tiver todas as posições no arra não irá processar valores do D350
			If Len(aSPDPisTR[1,nCont]) >= 23
				//---------------------
				//Informações da nota
				//---------------------
				oApurSai:Setorigem(OUTROS)
				oApurSai:SetReceita(aSPDPisTR[1,nCont,10])
				oApurSai:SetTNatRec(aSPDPisTR[1,nCont,24])
				oApurSai:SetCNatRec(aSPDPisTR[1,nCont,25])
				oApurSai:SetGNatRec(aSPDPisTR[1,nCont,26])
				oApurSai:SetDNatRec(aSPDPisTR[1,nCont,27])
				If cReg== 4
					//-------------------------------------------------------------------------------------------------------------
					//NESTA SITUAÇÃO NA EXISTE NENHUMA INFORMAÇÃO NO PONTO DE ENTRADA PARA DEFINIR QUAL O REGIME
					//SEMPRE FOI PROCESSADO DE FORMA ERRADA QUANDO O REGIME DA APURAÇÃO FOR CUMULATIVO E NÃO CUMULATIVO
					//O LEGAL ESTÁ ERRADO. PARA NÃO TER QUE REALIZAR ALTERAÇÃO NO PONTO DE ENTRADA, IREI UTILIZAR COMO
					//CRITÉRIO AS ALÍQUOTA, JÁ QUE ESTE REGISTRO ACEITA SOMENTE ALÍQUOTA BÁSICA CUMULATIVA OU BÁSICA NÃO CUMULATIVA
					//--------------------------------------------------------------------------------------------------------------
					oApurSai:SetTpReg(Iif(aSPDPisTR[1,nCont,13] == 0.65,CUMULAT,NAOCUMULAT))

				EndIF


				//--------------------
				//Informações do PIS
				//--------------------
				oApurSai:SetTributo(PIS)
				oApurSai:SetCST(aSPDPisTR[1,nCont,11])
				oApurSai:SetAlqTrib(aSPDPisTR[1,nCont,13])
				oApurSai:SetBcTrib(aSPDPisTR[1,nCont,12])
				oApurSai:SetValTrib(aSPDPisTR[1,nCont,16])
				oApurSai:SetBaseST(aSPDPisTR[1,nCont,12])
				oApurSai:SetValST(aSPDPisTR[1,nCont,16])
				oApurSai:SetAlqSt(aSPDPisTR[1,nCont,13])
				oApurSai:AgrpContr()

				//----------------------
				//Informações da COFINS
				//----------------------
				oApurSai:SetTributo(COFINS)
				oApurSai:SetCST(aSPDPisTR[1,nCont,17])
				oApurSai:SetAlqTrib(aSPDPisTR[1,nCont,19])
				oApurSai:SetBcTrib(aSPDPisTR[1,nCont,18])
				oApurSai:SetValTrib(aSPDPisTR[1,nCont,22])
				oApurSai:SetBaseST(aSPDPisTR[1,nCont,18])
				oApurSai:SetValST(aSPDPisTR[1,nCont,22])
				oApurSai:SetAlqSt(aSPDPisTR[1,nCont,19])
				oApurSai:AgrpContr()

				oApurSai:GrvResCST(,"D")

			EndIF

		Next nCont
	EndIF

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001PEDFAN()
Função que irá processar os valores de difermento de períodos anteriores
tratando os valores de origem do ponto de entrada SPDPCANT

@param		dDataDe 	- Data de início da apuração
			dDataAte 	- Data final da apuração
			oDifer	 	- Objeto de apuração que irá tratar os valores de diferimento
			 	
@author Erick G. Dias
@since 21/05/2014
@version 11.80
/*/
//-------------------------------------------------------------------

Static Function A001PEDFAN(dDataDe,dDataAte,oDifer,aRegM300,aRegM700)

	Local aSPDPCAnt	:= {}
	Local aRegMX00	:= {}
	Local nCont		:= 0

	Default aRegM300 	:= {}
	Default aRegM700 	:= {}


	//-----------------------------------------------------------------------------------
	//FAZ CHAMADA PARA O PONTO DE ENTRADA DE CONTRIBUIÇÃO DIFERIDA EM PERÍODOS ANTERIORES
	//-----------------------------------------------------------------------------------
	aSPDPCAnt := ExecBlock("SPDPCANT", .F., .F., {aRegM300,aRegM700,dDataDe,dDataAte } )

	//------------------------------------------------------------------
	//PROCESSA OS VALORES DE PIS DIFERIDO COM ORIGEM DO PONTO DE ENTRADA
	//------------------------------------------------------------------
	aRegMX00	:= aSPDPCAnt[1]	//Valores de PIS
	For nCont:= 1 to len(aRegMX00)
		oDifer:SetTributo(PIS)	//PIS
		oDifer:SetTpDif('2') 		//Indica diferimento de período anterior
		oDifer:SetCodigo(aRegMX00[nCont][2])
		oDifer:SetVlDif(aRegMX00[nCont][6])
		oDifer:Diferir()
	Next nCont

	//---------------------------------------------------------------------
	//PROCESSA OS VALORES DE COFINS DIFERIDO COM ORIGEM DO PONTO DE ENTRADA
	//---------------------------------------------------------------------
	aRegMX00	:= aSPDPCAnt[2] //Valores da COFINS
	For nCont:= 1 to len(aRegMX00)
		oDifer:SetTributo(COFINS)	//COFINS
		oDifer:SetTpDif('2') 		//Indica diferimento de período anterior
		oDifer:SetCodigo(aRegMX00[nCont][2])
		oDifer:SetVlDif(aRegMX00[nCont][6])
		oDifer:Diferir()
	Next nCont

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001PEDFAT()
Função que irá processar os valores de difermento do período atual

@param		dDataDe 	- Data de início da apuração
			dDataAte 	- Data final da apuração
			oDifer	 	- Objeto de apuração que irá tratar os valores de diferimento
			 	
@author Erick G. Dias
@since 21/05/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001PEDFAT(dDataDe,dDataAte,oDifer)

	Local aSPDDif	:= {}
	Local nX		:= 0

	aSPDDif := ExecBlock("SPDPCD", .F., .F., { dDataDe, dDataAte } )

	If Len(aSPDDif) > 0 .And. Len(aSPDDif[1])>0

		//-----------------------
		//PROCESSA VALORES DE PIS
		//-----------------------
		For nX:=1 to Len(aSPDDif[1])
			oDifer:SetTributo(PIS) //PIS
			oDifer:SetTpDif('1') //Indica diferimento de valores do período de débito
			oDifer:SetCodigo(aSPDDif[1][nX][1])
			oDifer:SetAliq(aSPDDif[1][nX][3])
			oDifer:SetVlDif(aSPDDif[1][nX][7])
			oDifer:Diferir()

		Next nX

		//--------------------------
		//PROCESSA VALORES DA COFINS
		//--------------------------
		For nX:=1 to Len(aSPDDif[2])

			oDifer:SetTributo(COFINS) //COFINS
			oDifer:SetTpDif('1') //Indica diferimento de valores do período de débito
			oDifer:SetCodigo(aSPDDif[2][nX][1])
			oDifer:SetAliq(aSPDDif[2][nX][3])
			oDifer:SetVlDif(aSPDDif[2][nX][7])
			oDifer:Diferir()

		Next nX

	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001IMOB()
Função que irá tratar sobre os valores de débitos do registro F200
e dos créditos dos registros F205 e F210.
Foi mantido o legado da rotina spedpiscof, por este motivo estãá sendo
tratado com diversos arrays e loops.

@param		dDataDe 	- Data de início da apuração
			dDataAte 	- Data final da apuração
			oApurSai  - Objeto de apuração do débito
			oApurEnt  - Objeto de apuração do crédito
			lProcCred - Indica se os créditos deverão ser processados
			 	
@author Erick G. Dias
@since 22/05/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001IMOB(dDataDe,dDataAte,oApurSai,oApurEnt,lProcCred,cReg,lEntrada,lSaida)

	Local aRetImob		:= {}
	Local nX			:= 0
	Local nY			:= 0
	Local cCumulat   	:= '1'
	Local aRegF200		:= {}
	Local aRegF205		:= {}
	Local aRegF210		:= {}
	Local nPost			:= 0

	aRetImob :=ExecBlock("SPDPCIMOB",.F.,.F.,{{},dDataDe,dDataAte})

	If Len(aRetImob)>0 .And. ValType(aRetImob[1]) == "A"

		For nX:=1 To Len(aRetImob[1])

			//-------------------------------------------------------------------
			//Processa primeiro informações do F200 que são referente aos débitos
			//-------------------------------------------------------------------
			aRegF200	:= aRetImob[1][nX]
			//---------------------
			//Informações da nota
			//---------------------
			cCumulat	:= '1'
			If aRegF200[Len(aRegF200)] == "0" //Regime Cumulativo
				cCumulat	:= '2'
			EndIf

			If lSaida
				oApurSai:SetReceita(aRegF200[11])
				If cReg == 4
					oApurSai:SetTpReg(Iif(aRegF200[23] == "0",CUMULAT,NAOCUMULAT))
				EndIF
				oApurSai:SetAtvImob(.T.)

				//--------------------
				//Informações do PIS
				//--------------------
				oApurSai:Setorigem(OUTROS)
				oApurSai:SetTributo(PIS)
				oApurSai:SetCST(aRegF200[12])
				oApurSai:SetAlqTrib(aRegF200[14])
				oApurSai:SetBcTrib(aRegF200[13])
				oApurSai:SetValTrib(aRegF200[15])
				oApurSai:AgrpContr()

				//---------------------
				//Informações DA COFINS
				//---------------------
				oApurSai:SetTributo(COFINS)
				oApurSai:SetCST(aRegF200[16])
				oApurSai:SetAlqTrib(aRegF200[18])
				oApurSai:SetBcTrib(aRegF200[17])
				oApurSai:SetValTrib(aRegF200[19])
				oApurSai:AgrpContr()
				oApurSai:setImob(.T.)
				oApurSai:GrvResCST(,"F")

				//Receitas com origem do bloco F.
				oApurSai:RecBlocos("F")

			Endif

			IF lProcCred .And. lEntrada // .And. cCumulat == '1' //Não cumulativo

				oApurEnt:SetAtvImob(.T.)
				//---------------------------------------------------------------------------------------
				//Processa primeiro informações do F205 que são referente aos créditos de custo incorrido
				//---------------------------------------------------------------------------------------
				If Len(aRetImob)>1 .And. ValType(aRetImob[2]) == "A" .And. Len(aRetImob[2])>=nX .And. ValType(aRetImob[2][nX])=="A" .And. Len(aRetImob[2][nX])>18 .And. aRetImob[2][nX][2]=="F205"
					aRegF205	:= aRetImob[2][nX]

					//-------------------------------------------------------------------
					//Informações da Nota Fiscal
					//-------------------------------------------------------------------
					oApurEnt:Setorigem(OUTROS)
					oApurEnt:SetRegime(NAOCUMULAT)  //observação : Ajustar para verificar o regime da nota fiscal
					oApurEnt:SetReceita(aRegF205[7])
					oApurEnt:SetCodBcc('15') //Código exclusivo para crédito de custo incorrido na unidade imobiliária

					//-------------------------------------------------------------------
					//Informações de PIS
					//-------------------------------------------------------------------
					oApurEnt:SetTributo(PIS)
					oApurEnt:SetCST(aRegF205[8])
					oApurEnt:SetAlqTrib(aRegF205[9])
					oApurEnt:SetBcTrib(aRegF205[7])
					oApurEnt:SetValTrib(aRegF205[12])
					oApurEnt:AgrpCred()

					//-------------------------------------------------------------------
					//Informações da COFINS
					//-------------------------------------------------------------------
					oApurEnt:SetTributo(COFINS)
					oApurEnt:SetCST(aRegF205[14])
					oApurEnt:SetAlqTrib(aRegF205[15])
					oApurEnt:SetBcTrib(aRegF205[7])
					oApurEnt:SetValTrib(aRegF205[18])
					oApurEnt:AgrpCred()

					//Agrupa valores para resumo de CST
					oApurEnt:GrvResCST()

				EndIf

				//---------------------------------------------------------------------------------------
				//Processa primeiro informações do F205 que são referente aos créditos de custo orçado
				//---------------------------------------------------------------------------------------
				If Len(aRetImob)>2 .And. ValType(aRetImob[3]) == "A"
					aRegF210	:= aRetImob[3]

					nPost := aScan(aRegF210,{|x| x[1] == nX})

					If Len(aRegF210) > 0 .AND. nPost > 0

						For nY:=nPost To Len(aRegF210)
							If ValType(aRegF210[nY])=="A" .AND. Len(aRegF210[nY]) > 11 .AND. aRegF210[nY][1] == nX .AND. aRegF210[nY][2] == "F210"

								//-------------------------------------------------------------------
								//Informações da Nota Fiscal
								//-------------------------------------------------------------------
								oApurEnt:Setorigem(OUTROS)
								oApurEnt:SetRegime(NAOCUMULAT)
								oApurEnt:SetReceita(aRegF210[nY][6])
								oApurEnt:SetCodBcc('16') //Código exclusivo para crédito de custo incorrido na unidade imobiliária

								//-------------------------------------------------------------------
								//Informações de PIS
								//-------------------------------------------------------------------
								oApurEnt:SetTributo(PIS)
								oApurEnt:SetCST(aRegF210[nY][7])
								oApurEnt:SetAlqTrib(aRegF210[nY][8])
								oApurEnt:SetBcTrib(aRegF210[nY][6])
								oApurEnt:SetValTrib(aRegF210[nY][9])
								oApurEnt:AgrpCred()

								//-------------------------------------------------------------------
								//Informações da COFINS
								//-------------------------------------------------------------------
								oApurEnt:SetTributo(COFINS)
								oApurEnt:SetCST(aRegF210[nY][10])
								oApurEnt:SetAlqTrib(aRegF210[nY][11])
								oApurEnt:SetBcTrib(aRegF210[nY][6])
								oApurEnt:SetValTrib(aRegF210[nY][12])
								oApurEnt:AgrpCred()

								//Agrupa valores para resumo de CST
								oApurEnt:GrvResCST()

							EndIf
						Next

					EndIF

				EndIf
			EndIF
		Next nX
	EndIF

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001FOLHA()
Função que irá gravar os valores referente ao PIS Folha de Salário,
gerado através da integração com módulo de RH.

@param		dDataDe 	- Data de início da apuração
			dDataAte 	- Data final da apuração
			oApurEFD	- Objeto de apuração

			 	
@author Erick G. Dias
@since 23/05/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001FOLHA(dDataDe,dDataAte,oApurEFD)

	Local aM350Aux	:= {}
	Local nVlTotSal := 0	// Valor Total da Folha de Salários
	Local nVlTotExc := 0	// Valor Total das Exclusões à Base de Cálculo
	Local nVlTotBas := 0	// Valor Total da Base de Cálculo
	Local nVlAliPis := 0	// Alíquota do PIS/PASEP  Folha de Salários
	Local nVlTotPis := 0	// Valor Total da Contribuição Social sobre a Folha de Salários

	If ExistBlock('SPEDM350')
		aM350Aux := ExecBlock("SPEDM350", .F., .F.,{FWGETCODFILIAL, dDataDe, dDataAte})

		nVlTotSal := aM350Aux[1]
		nVlTotExc := aM350Aux[2]
		nVlTotBas := aM350Aux[3]
		nVlAliPis := aM350Aux[4]
		nVlTotPis := aM350Aux[5]
	ElseIf FindFunction("fM350VlPis")
		aM350Aux:=fM350VlPis( FWGETCODFILIAL, FWGETCODFILIAL, dDataDe, dDataAte)

		nVlTotSal := aM350Aux[1,2]
		nVlTotExc := aM350Aux[1,3]
		nVlTotBas := aM350Aux[1,4]
		nVlAliPis := aM350Aux[1,5]
		nVlTotPis := aM350Aux[1,6]
	EndIf

	IF Len(aM350Aux) > 0 .AND. nVlTotPis > 0
		oApurEFD:SetOrigem(OUTROS)
		oApurEFD:SetReceita(nVlTotSal)
		oApurEFD:SetTributo(PIS)
		oApurEFD:SetCST('')
		oApurEFD:SetAlqTrib(nVlAliPis)
		oApurEFD:SetBcTrib(nVlTotBas)
		oApurEFD:SetValTrib(nVlTotPis)
		oApurEFD:SetExclPis(nVlTotExc)
		oApurEFD:SetPisFolh('1')
		oApurEFD:AgrpContr()
		oApurEFD:SetExclPis(0)
		oApurEFD:SetTpReg(' ')
	EndIF

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001BlocoI()
Função que irá processar as informações referente ao Bloco I
Instituições Financeiras

@param		dDataDe 	- Data de início da apuração
			dDataAte 	- Data final da apuração
			oApurSai	- Objeto de apuração
			aXFilial	-Array com conteúdo xFilial das tabelas de apuração
				
@author Erick G. Dias
@since 17/06/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001BlocoI(dDataDe,dDataAte,oApurSai,aXFilial,cFilialMat)
	Local cIntegra	:= SuperGetMv("MV_INTBLCI",.F.,"")
	Local nCont		:= 0
	Local cAliasI		:= ''
	Local lProc		:= .F.
	Local lI300		:= .F.
	Local oI100		:= TABELACL5():New()
	Local oI200I300	:= TABELACL6():New()
	Local oRecNTrib	:= TABELACKT():New()
	Local lF07				:= AliasINdic('F07')
	Local lRecnoTit	:= .F.
	Local cNumTit		:= ''
	Local cPrefixo	:= ''
	Local cParcela	:= ''
	Local lCanDelTmp:=.T.

	oI100:SetFilial(aXFilial)
	oI200I300:SetFilial(aXFilial)
	oRecNTrib:SetFilial(aXFilial)
	If lF07
		ObjF0T	:= TABELAF0T():New()
	EndIf
	dbSelectArea("CCZ")
	dbSetOrder(1)

	For nCont :=1 to 3
		cAliasI	:= GetNextAlias()
		lProc	:= .F.
		If nCont ==1 .and. cIntegra $ "1/3" .AND. FindFunction("FinSpdBlcI")
			//Função do Financeiro
			cAliasI:=FinSpdBlcI(Month(dDataDe),Year(dDataDe),cAliasI)
			lProc	:= .T.
		ElseIF nCont ==2 .and. cIntegra $ "2/3" .AND. FindFunction("PLSPISCOF")
			//Função de Saúde
			lProc:=PLSPISCOF(dDataDe,dDataAte,cAliasI)
		ElseIF nCont ==3 .and. cIntegra $ "4" .AND. AliasINdic('F3F') .AND. FindFunction("FisCtbBlcI")
			//Função Fiscal x Contabilidade
			lProc:= FisCtbBlcI(dDataDe,dDataAte,cAliasI)
		EndIF

		If lProc
			(cAliasI)->(dbGoTop())
			lRecnoTit	:= .F.
			lRecnoTit	:=  nCont ==1 .AND. (cAliasI)->(FieldPos('RECNO')) > 0 .AND. (cAliasI)->(FieldPos('ALIAS')) > 0
			While !(cAliasI)->(EOF())

				aParNaoTri	:= {}
				nValRec	:= 0
				cExclGer	:= 0
				cExclEsp	:= 0
				nAlqPis	:= 0
				nAlqCof 	:= 0
				n713714	:= 0
				cCst		:= ""
				cInf		:= ""
				cCampo		:= ""
				c711712	:= ""
				c713714	:= ""
				cConta		:= ""
				cNota		:= ""
				cSerie		:= ""
				cClieFor	:= ""
				cLoja		:= ""
				lI300		:= .F.
				cIndProc	:= ''
				cProcRef	:= ''
				cNumTit		:= ''
				cPrefixo	:= ''
				cParcela	:= ''

				If nCont ==1	//Valores Financeiro
					nValRec	:= (cAliasI)->VALOR
					cCst		:= (cAliasI)->CSTPIS
					nAlqPis	:= (cAliasI)->ALIQPIS
					nAlqCof	:= (cAliasI)->ALIQCOF
					cConta		:= (cAliasI)->CONTA
					IF !Empty((cAliasI)->CDRECA)
						c711712	:= Substr((cAliasI)->CDRECA,1,5)
						c713714	:= (cAliasI)->CDRECA
						IF Len(Alltrim((cAliasI)->CDRECA)) == 8
							lI300 := .T.
						EndIF
					Elseif !Empty((cAliasI)->CDDEDA)
						c711712	:= Substr((cAliasI)->CDDEDA,1,5)
						c713714	:= (cAliasI)->CDDEDA
						IF Len(Alltrim((cAliasI)->CDDEDA)) == 8
							lI300 := .T.
						EndIF
					EndIF
					cProcRef	:= (cAliasI)->NUMPRO
					cIndProc	:= (cAliasI)->INDPRO
					cTnatRec	:= (cAliasI)->TABCCZ
					cCnatRec	:= (cAliasI)->CODCCZ
					cGrpRec	:= (cAliasI)->GRUCCZ
					dDtNatRec	:= (cAliasI)->DTFCCZ
				ElseIF nCont ==2  //Valores Saúde
					nValRec	:= (cAliasI)->VALOR
					cCst		:= (cAliasI)->CSTPIS
					nAlqPis	:= (cAliasI)->ALIQPIS
					nAlqCof	:= (cAliasI)->ALIQCOF
					c711712	:=	SubStr((cAliasI)->CLASSE,1,5)
					c713714	:= (cAliasI)->CLASSE
					IF Len(Alltrim((cAliasI)->CLASSE)) == 8
						lI300 := .T.
					EndIF
					cNota		:= (cAliasI)->NOTA
					cSerie		:= (cAliasI)->SERIE
					cClieFor	:= (cAliasI)->CLIENTE
					cLoja		:= (cAliasI)->LOJA
					cTnatRec	:= (cAliasI)->NATREC
					cCnatRec	:= (cAliasI)->CNATREC
					cGrpRec	:= (cAliasI)->GRUPONC
					dDtNatRec	:= (cAliasI)->DTFIMNT
					//Comentei a utilização dos campos CONTA e INFO, pois na versão 12 estes campos não são tratados ainda na função PLSPISCOF no PLSXFUN.PRW
					/*cConta		:= (cAliasI)->CONTA
					cInf		:= (cAliasI)->INFO*/
				ElseIF nCont ==3  //Fiscal x Contabilidade
					nValRec	:= (cAliasI)->VALOR
					cCst		:= (cAliasI)->CSTPIS
					nAlqPis	:= (cAliasI)->ALIQPIS
					nAlqCof	:= (cAliasI)->ALIQCOF
					c711712	:=	SubStr((cAliasI)->CLASSE,1,5) 
					c713714	:= (cAliasI)->CLASSE
					IF Len(Alltrim((cAliasI)->CLASSE)) == 8
						lI300 := .T.
					EndIF
					cNota		:= (cAliasI)->NOTA
					cSerie		:= (cAliasI)->SERIE
					cClieFor	:= (cAliasI)->CLIENTE
					cLoja		:= (cAliasI)->LOJA	
					cTnatRec	:= (cAliasI)->NATREC
					cCnatRec	:= (cAliasI)->CNATREC
					cGrpRec		:= (cAliasI)->GRUPONC
					dDtNatRec	:= (cAliasI)->DTFIMNT
					cConta		:= (cAliasI)->CONTA
					cInf		:= (cAliasI)->INFO	
				EndIF
			
				IF !Empty(c711712)		

					If SubStr(c711712,1,1) == "D" //Deduções/Exclusões
						If SubStr(c711712,1,4) == "D000" //Exclusções e Deduções de caráter Geral
							cExclGer	:= nValRec
							nValRec	:= 0	
						Else
							cExclEsp	:= nValRec
							nValRec	:= 0			
						EndIF
					EndIF
					
					If SubStr(c711712 ,1,1) == "R"	//Receita
						cCampo		:= "02"
						n713714	:= nValRec
					ElseIf SubStr(c711712 ,1,4) == "D000" //Dedução Geral
						cCampo		:= "04"
						n713714	:=	cExclGer			
					Else	//Dedução Específica
						cCampo		:= "05"
						n713714	:=	cExclEsp			
					EndIF

					// Ajustes Negativos de Receita e/ou Dedução (Nesses casos o valor fica invertido , subtraindo a receita ou estornando a Dedução)
					// Todos os codigos na qual a posição 4 e 5 como "98" é referente a ajuste Negativo
					// Deduções Gerais não tem codigo de ajuste negativo, mantendo o processo padrão.
					If SubStr(c711712 ,4,2) == '98'
						If SubStr(c711712 ,1,1) == "R"
					 		nValRec := nValRec * -1
						ElseIf SubStr(c711712 ,1,1) == "D" 
							cExclEsp := cExclEsp * -1
						Endif
					Endif
					//------------------------------------------------
					//Processa valores para gravar informações do I100
					//------------------------------------------------
					oI100:SetParam('CL5_PER'		,dDataDe)
					oI100:SetParam('CL5_ID'		,'')
					oI100:SetParam('CL5_CST'		,cCst)				
					oI100:SetParam('CL5_ALQPIS'	,nAlqPis)
					oI100:SetParam('CL5_ALQCOF'	,nAlqCof)
					oI100:SetParam('CL5_VLFAT'	,nValRec)
					oI100:SetParam('CL5_NUMNF'	,cNota)
					oI100:SetParam('CL5_SER'		,cSerie)
					oI100:SetParam('CL5_CLIFOR'	,cClieFor)
					oI100:SetParam('CL5_LOJA'	,cLoja)
					oI100:SetParam('CL5_DEDG'	,cExclGer)
					oI100:SetParam('CL5_DEDESP'	,cExclEsp)
					oI100:SetParam('CL5_INDPRO'	,cIndProc)
					oI100:SetParam('CL5_NUMPRO'	,cProcRef)				
					oI100:SetParam('CL5_INFCOM'	,'')				
					oI100:Insert()
									
					//------------------------------------------------
					//Processa valores para gravar informações do I200
					//------------------------------------------------
					oI200I300:SetParam('CL6_PER'		,dDataDe)
					oI200I300:SetParam('CL6_CST'		,cCst)
					oI200I300:SetParam('CL6_ALQPIS'		,nAlqPis)
					oI200I300:SetParam('CL6_ALQCOF'		,nAlqCof)
					oI200I300:SetParam('CL6_REG'		,"I200")
					oI200I300:SetParam('CL6_NUMCPO'		,cCampo)
					oI200I300:SetParam('CL6_CODIGO'		,c711712)
					oI200I300:SetParam('CL6_VALOR'		,n713714)
					oI200I300:SetParam('CL6_CONTA'		,cConta)				
					oI200I300:Insert()
					
					If lI300				
						//------------------------------------------------
						//Processa valores para gravar informações do I300
						//------------------------------------------------
						oI200I300:SetParam('CL6_PER'		,dDataDe)
						oI200I300:SetParam('CL6_CST'		,cCst)
						oI200I300:SetParam('CL6_ALQPIS'		,nAlqPis)
						oI200I300:SetParam('CL6_ALQCOF'		,nAlqCof)
						oI200I300:SetParam('CL6_REG'		,"I300")
						oI200I300:SetParam('CL6_CODIGO'		,c713714)
						oI200I300:SetParam('CL6_VALOR'		,n713714)
						oI200I300:SetParam('CL6_CONTA'		,cConta)
						oI200I300:SetParam('CL6_INFCOM'		,cInf)
						oI200I300:Insert()
					EndIF				
					
					IF cCst $ "04/06/07/08/09"
						
						If CCZ->(MsSeek(xFilial("CCZ")+ cTnatRec + cCnatRec + cGrpRec  + dDtNatRec))
							//Processa valores não tributados do PIS
							oRecNTrib:SetParam('CKT_ORIGEM'	,OUTROS)
							oRecNTrib:SetParam('CKT_PER'	,dDataDe)
							oRecNTrib:SetParam('CKT_TRIB'	,'1')					
							oRecNTrib:SetParam('CKT_CST'	,cCst)					
							oRecNTrib:SetParam('CKT_CODNAT'	,cCnatRec)					
							oRecNTrib:SetParam('CKT_VLREC'	,nValRec)					
							oRecNTrib:SetParam('CKT_CONTA'	,cConta)					
							oRecNTrib:SetParam('CKT_DESCR'	,CCZ->CCZ_DESC)					
							oRecNTrib:Insert()

							//Processa valores não tributados da COFINS						
							oRecNTrib:SetParam('CKT_ORIGEM'	,OUTROS)
							oRecNTrib:SetParam('CKT_PER'	,dDataDe)
							oRecNTrib:SetParam('CKT_TRIB'	,'2')					
							oRecNTrib:SetParam('CKT_CST'	,cCst)					
							oRecNTrib:SetParam('CKT_CODNAT'	,cCnatRec)					
							oRecNTrib:SetParam('CKT_VLREC'	,nValRec)					
							oRecNTrib:SetParam('CKT_CONTA'	,cConta)					
							oRecNTrib:SetParam('CKT_DESCR'	,CCZ->CCZ_DESC)					
							oRecNTrib:Insert()						
												
						EndIF
						
					EndIF
					
					//se for integração financeiro e s existir novo campo d financeiro, posicionar no títulos e grava F0T
					If lF07 .AND. lRecnoTit
						IF (cAliasI)->ALIAS == "SE1"							
							SE1->(dbGoto( (cAliasI)->RECNO)	)		
							cNumTit	:= SE1->E1_NUM    
							cPrefixo	:= SE1->E1_PREFIXO
							cParcela	:= SE1->E1_PARCELA
							
						ElseIF (cAliasI)->ALIAS == "SE2"
						
							SE2->(dbGoto( (cAliasI)->RECNO)	)		
							cNumTit	:= SE2->E2_NUM    
							cPrefixo	:= SE2->E2_PREFIXO
							cParcela	:= SE2->E2_PARCELA
										
						ElseIF (cAliasI)->ALIAS == "SE5"
						
							SE5->(dbGoto( (cAliasI)->RECNO)	)		
							cNumTit	:= SE5->E5_NUMERO
							cPrefixo	:= SE5->E5_PREFIXO
							cParcela	:= SE5->E5_PARCELA
							
							
						EndIF			
						ObjF0T:Clear()
						ObjF0T:SetValue("F0T_PER",dDataDe)
						ObjF0T:SetValue("F0T_FILAPU",cFilialMat)
						ObjF0T:SetValue("F0T_TIPO",'8') //Bloco I
						ObjF0T:SetValue("F0T_NUMTIT",cNumTit)
						ObjF0T:SetValue("F0T_PREFIX",cPrefixo)
						ObjF0T:SetValue("F0T_PARC",cParcela)
						ObjF0T:SetValue("F0T_VLCONT",nValRec)
						ObjF0T:SetValue("F0T_IFEXCL",cExclGer + cExclEsp)
						ObjF0T:SetValue("F0T_CDBLCI",c713714)											
						ObjF0T:SetValue("F0T_CSTPIS",cCst)
						ObjF0T:SetValue("F0T_CSTCOF",cCst)
						
						
						ObjF0T:Grava()
					EndIF
					
				EndIF
				(cAliasI)->(dbSkip())
			EndDo

			// [ nCont==1 ] controle da temporaria do Financeiro em FinSpdBlcI()
			lCanDelTmp:=Iif( nCont==1 , Iif(FindFunction('FinSpdDel'),FinSpdDel(3),.T.) , .T. )//Verifica se pode fechar a area da tabela temporaria
			IF lCanDelTmp
				DbSelectArea(cAliasI)
				dbCloseArea()
			EndIf
			Ferase(cAliasI+GetDBExtension())
			Ferase(cAliasI+OrdBagExt())	

		EndIF

	Next nCont

	//------------------------------------------------
	//Irá processar os valores de I100 considerando as 
	//deduções e irá gravar nas tabelas de débitos detalhados
	//e consolidados
	//------------------------------------------------
	oI100:ApurarI100(oApurSai) 
	oI100:Save()
	FreeObj(oI100)
	oI100:= nil

	//------------------------------------------------
	//Grava informações de I200 e I300 na base de dados
	//------------------------------------------------
	oI200I300:Save()
	FreeObj(oI200I300)
	oI200I300:= nil

	//-------------------------------------------------------------
	//Grava os valores das receitas não tributadas na base de dados
	//-------------------------------------------------------------
	oRecNTrib:Save()
	FreeObj(oRecNTrib)
	oRecNTrib:= nil

	oApurSai:Finaliza('1')

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001CPRB()
Função que irá realizar a integração módulos de Faturamento, RH ou o Documento Fiscal 
para processamento das informações da  CPRB.

@param		dDataDe 	- Data de início da apuração
			dDataAte 	- Data final da apuração
			aXFilial	- Array com conteúdo xFilial das tabelas de apuração
			nTotF100	- Valor total utilizado na geração do registro F100
			 	
@author Erick G. Dias
@since 18/06/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001CPRB(dDataDe,dDataAte,aXFilial,nTotF100,cFilialMat,lindividu)

	Local nTotal		:= 0
	Local nAliq		:= 0
	Local nContrib	:= 0
	Local nExclusao	:= 0
	Local nExcluAnt	:= 0
	Local nBase		:= 0
	Local nDiferenca	:= 0
	Local nPos		:= 0
	Local cAliasP		:= ''
	Local lProcRH 	:= GetNewPar("MV_SPCBPRH",.F.)
	Local cSPCBPSE	:= GetNewPar("MV_SPCBPSE",'')
	Local oCPRB		:= CPRBEFD():New()
	local oCKX		:= TABELACKX():New()
	Local aSldExc		:= {}
	Local cCodRec		:= ''
	Local lProcessou	:= .F.
	Local cOutRec	:= SuperGetMv("MV_CODGEN",.F.,"")
	Local lNTrib 	:= CKX->(FieldPos('CKX_NTRIB'))>0 .And. !EmpTy(cOutRec)
	Local lTmpFAt	:= FindFunction("CloseTRBDF")
	Local lCONTARECE	:= .F.

	oCPRB:SetDtRefer(dDataDe)
	oCPRB:SetFilial(aXFilial)

	//Traz saldo de exclusão de período anterior.
	aSldExc:=oCPRB:GetSldExcl()

	If lProcRH		// IRÁ PROCESSAR ATRAVÉS DO MÓDULO DE RH
		cAliasP:= fS033Sped(Alltrim(StrZero(Month(dDataDe),2))+Alltrim(Str(Year(dDataDe))) )
	Else			// IRÁ PROCESSAR ATRAVÉS DO MÓDULO DE FATURAMENTO
		cAliasP:= RhInssPat(Alltrim(StrZero(Month(dDataDe),2))+Alltrim(Str(Year(dDataDe))),,,,.T.)
	EndIf

	DbSelectArea(cAliasP)
	(cAliasP)->(DbSetOrder(1))
	(cAliasP)->(dbGoTop())

	lCONTARECE	:= (cAliasP)->(FieldPos("CONTARECE"))>0

	Do While !(cAliasP)->(Eof ())
		lProcessou	:= .T.
		nExclusao	:= 0
		nDiferenca	:= 0
		nBase		:= 0 
		nExcluAnt	:= 0

		If lProcRH
			nTotal		:= (cAliasP)->TOTAL
			nAliq		:= (cAliasP)->ALIQ
			nContrib	:= (cAliasP)->TOTCONTR
			nExclusao	:= (cAliasP)->(TOTCODAT-TCDEVEXP)
			nBase		:= (cAliasP)->TCDEVEXP
		Else		
			
			//Verifica se existe para este código de atividade saldo de exclusão de período a		
			nPos := aScan(aSldExc,{|x| x[1] == AllTrim((cAliasP)->CODATV)})
			IF nPos > 0
				nExcluAnt	:= aSldExc[nPos][2] //Pega o valor de exclusão de período anterior
				aSldExc[nPos][2] := 0
			EndIF

			//Aqui teremos as exclusões de período anterior com as do período atual.
			nExcluAnt +=	(cAliasP)->(TOTCODAT-TCDEVEXP)
			
			If nExcluAnt> (cAliasP)->TOTCODAT
				//Exclusão é maior que o valor da receita do mês, neste caso teriamos valores negativos
				nExclusao := (cAliasP)->TOTCODAT
				//Guardo a diferença de exclusão para que possa ser transportado para próximo mês.
				nDiferenca	:= nExcluAnt - (cAliasP)->TOTCODAT
			Else
				//A exclusão é menor que o valor da contribuição
				nExclusao	:= nExcluAnt
			EndIF

			nTotal		:= (cAliasP)->TOTAL + nTotF100 
			nAliq		:= SpedPCCG1((cAliasP)->CODATV,dDataAte)
			nBase		:= (cAliasP)->TOTCODAT - nExclusao
			nContrib	:= (nBase *(nAliq/100))
		EndIf

		//Verifica parâmetro para definir se utilizará código de serviço ou de outros serviços.
		cCodRec	:= Iif(AllTrim((cAliasP)->CODATV)$ cSPCBPSE  ,mv_par16  ,mv_par17  )
		
		//Popula objeto para gravar a CPRB
		oCPRB:SetDtRefer(dDataDe)	
		oCPRB:SetCodAtiv(AllTrim((cAliasP)->CODATV))
		oCPRB:SetVlBrut(nTotal)
		oCPRB:SetVlExcl(nExclusao)	
		oCPRB:SetVlCPRB(nContrib)
		oCPRB:SetAliq(nAliq)	
		oCPRB:SetBase(nBase)	
		oCPRB:SetVlAtiv((cAliasP)->TOTCODAT)
		
		//Verifica a existência do campo CONTARECE, caso cliente não tenha o FATXFUN atualizado.
		IF lCONTARECE
			oCPRB:SetConta((cAliasP)->CONTARECE)
		Else
			oCPRB:SetConta("")
		EndIF
		
		oCPRB:SetInform('')
		oCPRB:SetCodRec(cCodRec)
		oCPRB:SetFilApu(IIf(lIndividu,oCPRB:BuscaxFil('CKR'),cFilialMat)) 
		// Verifica se codigo é não desonerado
		If lNTrib
			IF (cAliasP)->CODATV $ cOutRec
				oCPRB:SetNTrib(.T.)
			Endif
		Endif
		//Grava valores de CPRB
		oCPRB:AgrupaCPRB()
		

		
		If nDiferenca > 0
			//Se houver valor de diferença, quer dizer que existe valor de exclusão maior
			//que a receita do período, e deverá ser gravada e transportada para próximo 
			//período.
			//Irei gravar somente a chave do registro com valor de exclusão. 
					
			oCKX:SetConsol('2')
			oCKX:SetParam('CKX_PER'			,dDataDe)
			oCKX:SetParam('CKX_CODATI'		,AllTrim((cAliasP)->CODATV)	)
			oCKX:SetParam('CKX_CODREC'		,cCodRec)
			oCKX:SetParam('CKX_VLBRUT'		,0)
			oCKX:SetParam('CKX_VLATI'		,0)
			oCKX:SetParam('CKX_EXCLU'		,nDiferenca)
			oCKX:SetParam('CKX_BASE'			,0)
			oCKX:SetParam('CKX_ALIQ'			,0)
			oCKX:SetParam('CKX_VLCPRB'		,0)
			oCKX:SetParam('CKX_CONTA'		,'')
			oCKX:SetParam('CKX_INFORM'		,'')
			oCKX:SetParam('CKX_SALDO'		,'1') //INdica que trata de saldo de exclusão
			oCKX:Insert()
			
		EndIF	

		(cAliasP)->(DbSkip ())
	EndDo

	If lProcessou .AND. AliasINdic('F0T')
		DetCPRB(dDataDe,dDataAte,cFilialMat,lProcRH)
	EndIF

	IF lTmpFAt
		CloseTRBDF()
	Else
		oCPRB:FechaAlias(cAliasP)
	EndIF

	oCPRB:GravaCPRB()
	FreeObj(oCPRB)
	oCPRB:= Nil

	oCKX:Save()
	FreeObj(oCKX)
	oCKX:= Nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001TELECO()
Função que irá tratar as operações de telecomunicação a faturar, estas
operações não são gravadas no Livro Fiscal, pois não existe a nota, já que
se trata de serviço pré-pago, a nota fiscal será emitida em período posterior
quando o serviço for faturado.

@param		dDataDe 	- Data de início da apuração
			dDataAte 	- Data final da apuração
			oApurSai	- Objeto de processamento das operações de débito
			cRegime	- Indica qual o regime de PIS e COFINS indicado pelo usuário
			nM996Tpr   - Conteúdo do parâmetro M996TPR			
			 	
@author Erick G. Dias
@since 24/06/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001TELECO(dDataDe,dDataAte,oApurSai,cRegime,nM996Tpr,cReg)

	Local cSlct			:= ""
	Local cSlctSD2		:= ""
	Local cSlctSF2		:= ""
	Local cSlctSF4		:= ""
	Local cSlctSFX		:= ""
	Local cJoinSD2		:= ""
	Local cJoinSF4		:= ""
	Local cJoin			:= ""
	Local cFiltro			:= ""
	Local cAliasSD2		:= "SD2"
	Local cAliasSF2		:= "SF2"
	Local aFieldDt		:= {}
	LOcal lB1Tpreg		:= SB1->(FieldPos("B1_TPREG"))>0
	Local cCfoTele		:= GetNewPar("MV_CFOTELE",'')  
								
	DbSelectArea (cAliasSD2)
	(cAliasSD2)->(DbSetOrder (3))

	//Campos da tabela SF2
	cSlctSF2:= "SF2.F2_ESPECIE,		SF2.F2_SERIE,		SF2.F2_TIPO, 		SF2.F2_CLIENTE,		SF2.F2_LOJA "

	If lB1Tpreg	
		cSlctSF2+= ", 	SB1.B1_TPREG "		
	EndIF    	

	//Campos da tabela SD2
	cSlctSD2 := ",SD2.D2_CONTA,		SD2.D2_SERIE,		SD2.D2_VALIMP5,		SD2.D2_BASIMP5 ,	SD2.D2_ALQIMP5,		"
	cSlctSD2 +=	"SD2.D2_VALIMP6,	SD2.D2_BASIMP6,		SD2.D2_ALQIMP6,		SD2.D2_DTFIMNT,		SD2.D2_DESC,		"	
	cSlctSD2 +=	"SD2.D2_TNATREC,	SD2.D2_CNATREC,		SD2.D2_GRUPONC,		SD2.D2_TOTAL,		SD2.D2_DESPESA,		"	
	cSlctSD2 +=	"SD2.D2_SEGURO,	SD2.D2_BASEICM,		SD2.D2_VALICM,		SD2.D2_CLIENTE,		SD2.D2_LOJA,	SD2.D2_CF"


			
	//Campos da TES
	cSlctSf4:= ",SF4.F4_CSTPIS, 	SF4.F4_CSTCOF, 		SF4.F4_TPREG "    	

	//Campos do complemento de telecomunicacao
	cSlctSFX:= ",SFX.FX_TIPOREC, 	SFX.FX_VALTERC,		SFX.FX_GRPCLAS,		SFX.FX_GRPCLAS,		SFX.FX_CLASSIF "    					

	//Join com SD2, SF4 e SFX
	cJoinSD2	:=	"LEFT JOIN "+RetSqlName("SD2")+" SD2 ON(SD2.D2_FILIAL='"+xFilial("SD2")+"' AND SD2.D2_DOC=SF2.F2_DOC AND SD2.D2_SERIE=SF2.F2_SERIE AND SD2.D2_CLIENTE=SF2.F2_CLIENTE AND SD2.D2_LOJA=SF2.F2_LOJA AND  SD2.D_E_L_E_T_=' ') "		
	cJoinSF4	:=	"LEFT JOIN "+RetSqlName("SF4")+" SF4 ON(SF4.F4_FILIAL='"+xFilial("SF4")+"' AND SF4.F4_CODIGO=SD2.D2_TES AND SF4.D_E_L_E_T_=' ') "				
	cJoinSFX	:=	"LEFT JOIN "+RetSqlName("SFX")+" SFX ON(SFX.FX_FILIAL='"+xFilial("SFX")+"' AND SFX.FX_TIPOMOV = 'S' AND SFX.FX_SERIE = SD2.D2_SERIE AND SFX.FX_DOC = SD2.D2_DOC AND SFX.FX_CLIFOR = SD2.D2_CLIENTE AND SFX.FX_LOJA = SD2.D2_LOJA AND SFX.FX_ITEM = SD2.D2_ITEM  AND SFX.D_E_L_E_T_=' ') "								

	cJoin	:=  cJoinSD2 + cJoinSF4 + cJoinSFX   	
	cJoin := "%" + cJoin + "%"

	cSlct := cSlctSF2+cSlctSD2+cSlctSf4+cSlctSFX

	cSlct := "%" + cSlct + "%"											

	cFiltro 	:= "%"		
	cFiltro		+= "(SF2.F2_ESPECIE = 'NFSC' OR SF2.F2_ESPECIE = 'NTSC' or SF2.F2_ESPECIE = 'NTST') AND SFX.FX_TIPOREC = '6' AND "
	cFiltro		+= "SF4.F4_LFICM = 'N' and  SF4.F4_LFIPI = 'N' and  SF4.F4_ISS = 'N'"
	cFiltro 	+= "%"
					
	aAdd(aFieldDt,"D2_DTFIMNT")
	aAdd(aFieldDt,"D2_ENTRADA")
			
	cAliasSF2	:=	GetNextAlias()    	 			
			
	BeginSql Alias cAliasSF2
		
		SELECT			    
			%Exp:cSlct%
		FROM 
			%Table:SF2% SF2
			%Exp:cJoin%
			LEFT JOIN %Table:SB1% SB1 ON(SB1.B1_FILIAL=%xFilial:SB1%  AND SB1.B1_COD=SD2.D2_COD AND SB1.%NotDel%)
			LEFT JOIN %Table:SA1% SA1 ON(SA1.A1_FILIAL=%xFilial:SA1%  AND SA1.A1_COD=SD2.D2_CLIENTE AND SA1.A1_LOJA = SD2.D2_LOJA AND SA1.%NotDel%)						
		WHERE

			SF2.F2_FILIAL=%xFilial:SF2% AND 
			SF2.F2_EMISSAO>=%Exp:DToS (dDataDe)% AND 
			SF2.F2_EMISSAO<=%Exp:DToS (dDataAte)% AND
			%Exp:cFiltro% AND
			SF2.%NotDel% 				
	EndSql
		
	DbSelectArea (cAliasSF2)
	(cAliasSF2)->(DbGoTop ())
	ProcRegua ((cAliasSF2)->(RecCount ()))
	Do While !(cAliasSF2)->(Eof ())										
		If AllTrim((cAliasSD2)->D2_CF) $ cCfoTele

			//---------------------
			//Informações da nota
			//---------------------
			oApurSai:SetReceita((cAliasSF2)->D2_TOTAL)
			oApurSai:SetOrigem(FISCALSAI)
			oApurSai:SetTNatRec((cAliasSF2)->D2_TNATREC)
			oApurSai:SetCNatRec((cAliasSF2)->D2_CNATREC)		
			oApurSai:SetGNatRec((cAliasSF2)->D2_GRUPONC)
			oApurSai:SetDNatRec((cAliasSF2)->D2_DTFIMNT)			
			If cReg == 4
				oApurSai:SetTpReg(DefRegime(nM996Tpr,cAliasSF2))
			EndIF
		
			//--------------------
			//Informações do PIS
			//--------------------		
			oApurSai:SetTributo(PIS)
			oApurSai:SetCST((cAliasSF2)->F4_CSTPIS)		
			oApurSai:SetAlqTrib((cAliasSF2)->D2_ALQIMP6)
			oApurSai:SetBcTrib((cAliasSF2)->D2_BASIMP6)
			oApurSai:SetValTrib((cAliasSF2)->D2_VALIMP6)
			oApurSai:AgrpContr()	
		
			//----------------------
			//Informações da COFINS
			//----------------------
			oApurSai:SetTributo(COFINS)
			oApurSai:SetCST((cAliasSF2)->F4_CSTCOF)		
			oApurSai:SetAlqTrib((cAliasSF2)->D2_ALQIMP5)
			oApurSai:SetBcTrib((cAliasSF2)->D2_BASIMP5)
			oApurSai:SetValTrib((cAliasSF2)->D2_VALIMP5)
			oApurSai:AgrpContr()	

			//Método que acumula as receitas por blocos A, C, D e F.
			//Operações de telecomunicação são escrituradas todas no bloco D, por este motivo chamei o método abaixo com o bloco D fixo.
			oApurSai:RecBlocos("D")		

			oApurSai:GrvResCST(,"D")
		EndIF

		(cAliasSF2)->(dbSkip())
	EndDo		

	oApurSai:FechaAlias(cAliasSF2)

	//FINALIZA GRAVAÇÃO DAS RECEITAS.
	oApurSai:Finaliza('1')
	
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001VFORA()
Função que irá processar as operações de venda fora do estabelecimento,
esta operações não estão gravadas no Livro Fiscal, por este motivo será
lido diretamente da SD2.

@param		dDataDe 	- Data de início da apuração
			dDataAte 	- Data final da apuração
			oApurSai	- Objeto de processamento das operações de débito
			cRegime	- Indica qual o regime de PIS e COFINS indicado pelo usuário
			nM996Tpr   - Conteúdo do parâmetro M996TPR			
			 	
@author Erick G. Dias
@since 24/06/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001VFORA(dDataDe,dDataAte,oApurSai,cRegime,nM996Tpr,cReg)

	Local cAliasSD2	:= 'SD2'
	Local cAliasSF4	:= 'SF4'
	Local cAliasSB1	:= 'SB1'
	Local cAliasSF2	:= 'SF2'
	Local cSlct		:= ''
	Local cSlctSF2	:= ''
	Local cJoin		:= ''
	Local cJoinSD2	:= ''
	Local cJoinSF4 	:= ''
	Local cFiltro		:= ''
	Local lAchouCCZ	:= .F.
	Local lB1TPREG	:= SB1->(FieldPos("B1_TPREG")) > 0
	Local lA1TPREG	:= SB1->(FieldPos("A1_TPREG")) > 0

	DbSelectArea (cAliasSD2)
	(cAliasSD2)->(DbSetOrder (3))

	//Campos da tabela SF2
	cSlctSF2 := "SF2.F2_FILIAL,SF2.F2_ESPECIE,SF2.F2_SERIE,SF2.F2_TIPO,SF2.F2_CLIENTE,SF2.F2_LOJA,SF2.F2_DOC,SF2.F2_CHVNFE,SF2.F2_EMISSAO,"
	cSlctSF2 += "SF2.F2_VALBRUT,SF2.F2_DESCONT,SF2.F2_FRETE,SF2.F2_SEGURO,SF2.F2_DESPESA,SF2.F2_BASEICM,"
	cSlctSF2 += "SF2.F2_VALICM,SF2.F2_BRICMS,SF2.F2_ICMSRET,SF2.F2_VALIPI,SF2.F2_VALIMP6,SF2.F2_VALIMP5,"
	cSlctSF2 += "SB1.B1_COD,SB1.B1_DESC,SB1.B1_POSIPI,SB1.B1_EX_NCM,SB1.B1_TNATREC,SB1.B1_CNATREC,"    	
	cSlctSF2 += "SB1.B1_TIPO,SB1.B1_CODISS,SB1.B1_CODBAR,SB1.B1_CODANT,SB1.B1_UM,SB1.B1_PICM,SB1.B1_FECP,SB1.B1_DATREF,"
	cSlctSF2 += "SB1.B1_TNATREC,SB1.B1_CNATREC,SB1.B1_GRPNATR,SB1.B1_DTFIMNT"

	IF lB1TPREG
		cSlctSF2 += ",SB1.B1_TPREG"
	EndIF

	IF lA1TPREG
		cSlctSF2 += ",SA1.A1_TPREG"
	EndIF

	//Campos da tabela SD2
	cSlctSF2 += ",SD2.D2_CONTA,SD2.D2_SERIE,SD2.D2_VALIMP5,SD2.D2_BASIMP5,SD2.D2_ALQIMP5,SD2.D2_VALIMP6,SD2.D2_BASIMP6,SD2.D2_ALQIMP6,"
	cSlctSF2 += "SD2.D2_DTFIMNT,SD2.D2_DESC,SD2.D2_TNATREC,SD2.D2_CNATREC,SD2.D2_GRUPONC,SD2.D2_TOTAL,SD2.D2_DESPESA,SD2.D2_SEGURO,"
	cSlctSF2 += "SD2.D2_BASEICM,SD2.D2_VALICM,SD2.D2_CLIENTE,SD2.D2_LOJA,SD2.D2_CF,SD2.D2_QUANT,SD2.D2_UM,SD2.D2_CLASFIS,SD2.D2_DESCON,
	cSlctSF2 += "SD2.D2_PICM,SD2.D2_BRICMS,SD2.D2_BASEIPI,SD2.D2_IPI,SD2.D2_VALIPI,SD2.D2_ICMSRET,SD2.D2_COD,SD2.D2_PEDIDO"

	//colocar join da tabela SA1 caso o campo A1_TPREG exista   
			
	//Campos da TES
	cSlctSF2 += ",SF4.F4_CSTPIS,SF4.F4_CSTCOF,SF4.F4_TPREG,SF4.F4_PISCOF,SF4.F4_ESTOQUE,SF4.F4_CTIPI,SF4.F4_TEXTO,"
	cSlctSF2 += "SF4.F4_TNATREC,SF4.F4_CNATREC,SF4.F4_GRPNATR,SF4.F4_DTFIMNT"
	//Join com SD2, SF4
	cJoinSD2	:=	"LEFT JOIN "+RetSqlName("SD2")+" SD2 ON(SD2.D2_FILIAL='"+xFilial("SD2")+"' AND SD2.D2_DOC=SF2.F2_DOC AND SD2.D2_SERIE=SF2.F2_SERIE AND SD2.D2_CLIENTE=SF2.F2_CLIENTE AND SD2.D2_LOJA=SF2.F2_LOJA AND  SD2.D_E_L_E_T_=' ') "		
	cJoinSF4	:=	"LEFT JOIN "+RetSqlName("SF4")+" SF4 ON(SF4.F4_FILIAL='"+xFilial("SF4")+"' AND SF4.F4_CODIGO=SD2.D2_TES AND SF4.D_E_L_E_T_=' ') "				

	cJoin	:=  cJoinSD2 + cJoinSF4
	cJoin := "%" + cJoin + "%"

	cSlct := cSlctSF2

	cSlct := "%" + cSlct + "%"											

	cFiltro 	:= "%"		
	cFiltro	+= "SD2.D2_CF IN ('5103','5104','6103','6104') AND SF4.F4_LFICM = 'N' AND  SF4.F4_LFIPI = 'N' AND SF4.F4_ISS = 'N' AND "
	cFiltro	+= "SF4.F4_CSTPIS <> ' ' AND SF4.F4_CSTCOF <> ' ' AND SF4.F4_PISCOF <> '4'"
	cFiltro 	+= "%"
			
	cAliasSF2	:=	GetNextAlias()    	 			
			
	BeginSql Alias cAliasSF2
		
		SELECT			    
			%Exp:cSlct%
		FROM 
			%Table:SF2% SF2
			%Exp:cJoin%
			LEFT JOIN %Table:SB1% SB1 ON(SB1.B1_FILIAL=%xFilial:SB1%  AND SB1.B1_COD=SD2.D2_COD AND SB1.%NotDel%)						
			LEFT JOIN %Table:SA1% SA1 ON(SA1.A1_FILIAL=%xFilial:SA1%  AND SA1.A1_COD=SD2.D2_CLIENTE AND SA1.A1_LOJA = SD2.D2_LOJA AND SA1.%NotDel%)		

		WHERE
			SF2.F2_FILIAL=%xFilial:SF2% AND 
			SF2.F2_EMISSAO>=%Exp:DToS (dDataDe)% AND 
			SF2.F2_EMISSAO<=%Exp:DToS (dDataAte)% AND
			%Exp:cFiltro% AND
			SF2.%NotDel%
		ORDER BY SF2.F2_SERIE, SF2.F2_DOC, SF2.F2_CLIENTE, SF2.F2_LOJA				
	EndSql
	
	cAliasSD2	:= cAliasSF2
	cAliasSF4	:= cAliasSF2
	cAliasSB1	:= cAliasSF2

	DbSelectArea (cAliasSF2)
	(cAliasSF2)->(DbGoTop ())

	Do While !(cAliasSF2)->(Eof ())
		
		If AModNot((cAliasSF2)->F2_ESPECIE) $ "01/04/1B/55"  
			If (cAliasSF4)->F4_CSTPIS $ "04/05/06/07/08/09" .Or. (cAliasSF4)->F4_CSTCOF $ "04/05/06/07/08/09"
				dbSelectArea("CCZ")
				dbSetOrder(1)
				If CCZ->(MsSeek(xFilial("CCZ")+ (cAliasSB1)->B1_TNATREC + (cAliasSB1)->B1_CNATREC + (cAliasSB1)->B1_GRPNATR  + (cAliasSB1)->B1_DTFIMNT))		
					lAchouCCZ := .T.
				ElseIf !lAchouCCZ .And. CCZ->(MsSeek(xFilial("CCZ")+ (cAliasSF4)->F4_TNATREC + (cAliasSF4)->F4_CNATREC + (cAliasSF4)->F4_GRPNATR  + (cAliasSF4)->F4_DTFIMNT))		
					lAchouCCZ := .T.	
				EndIf  
			EndIf
			//---------------------
			//Informações da nota
			//---------------------
			oApurSai:SetReceita((cAliasSD2)->D2_TOTAL)
			oApurSai:SetOrigem(FISCALSAI)
			If cReg == 4
				oApurSai:SetTpReg(DefRegime(nM996Tpr,cAliasSF2))
			EndIF
			
			IF lAchouCCZ
				oApurSai:SetTNatRec(CCZ->CCZ_TABELA)
				oApurSai:SetCNatRec(CCZ->CCZ_COD)		
				oApurSai:SetGNatRec(CCZ->CCZ_GRUPO )
				oApurSai:SetDNatRec(CCZ->CCZ_DTFIM )
			EndIF
		
			//--------------------
			//Informações do PIS
			//--------------------		
			oApurSai:SetTributo(PIS)
			oApurSai:SetCST((cAliasSF2)->F4_CSTPIS)		
			oApurSai:SetAlqTrib((cAliasSD2)->D2_ALQIMP6)
			oApurSai:SetBcTrib((cAliasSD2)->D2_BASIMP6)
			oApurSai:SetValTrib((cAliasSD2)->D2_VALIMP6)
			oApurSai:AgrpContr()	
		
			//----------------------
			//Informações da COFINS
			//----------------------
			oApurSai:SetTributo(COFINS)
			oApurSai:SetCST((cAliasSF2)->F4_CSTCOF)		
			oApurSai:SetAlqTrib((cAliasSD2)->D2_ALQIMP5)
			oApurSai:SetBcTrib((cAliasSD2)->D2_BASIMP5)
			oApurSai:SetValTrib((cAliasSD2)->D2_VALIMP5)
			oApurSai:AgrpContr()	

			//Venda fora do estabelecimento que não foram escirturads no livro, somente serão geradas para os modelos 01/04/1B/55, 
			//estes modelos pertencem ao bloco C., por este motivo está fixo no método abaixo
			oApurSai:RecBlocos("C")
		
			oApurSai:GrvResCST(,"C")

		EndIf

		(cAliasSF2)->(dbSkip())
	EndDo		

	oApurSai:FechaAlias(cAliasSF2)

	//FINALIZA GRAVAÇÃO DAS RECEITAS.
	oApurSai:Finaliza('1')

Return 

//-------------------------------------------------------------------
/*/{Protheus.doc} A001CUPOM()
Função que irá processar as operações de cupom fiscal com PIS e COFINS
gravadas através do módulo SIGALOJA. 

@param		dDataDe 	- Data de início da apuração
			dDataAte 	- Data final da apuração
			oApurSai	- Objeto de processamento das operações de débito
			cRegime	- Indica qual o regime de PIS e COFINS indicado pelo usuário
			cNrLivro	- Número do Livro Processado.			
			 	
@author Erick G. Dias
@since 25/06/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001CUPOM(dDataDe,dDataAte,oApurSai,cRegime,cNrLivro,cReg,nMVM996TPR,lBilhete)
     
	Local cAliasSFT	:= "SFT"
	Local lProcessou	:= .F.
	Local lPeCTB := ExistBlock("SPDPIS07")
	Local cConta := ""
	Local cBloco := ""

	DEFAULT lBilhete := .F.

	cAliasSFT	:= FSA001QECF(!lPeCTB,cNrLivro,dDataDe,dDataAte,lBilhete)
										
	// Processa Registros.
	Do While !(cAliasSFT)->(Eof())
		lProcessou	:= .T.
		lCumulativ := .F. 
		IF cRegime == '1'
			//Não Cumulativo
			lCumulativ	:= .F.				
		Elseif cRegime =='2'
			//Cumulativo
			lCumulativ	:= .T.
		ElseIF cRegime == '4'
			//Cumulativo/Nao Cumulativo
			IF nMVM996TPR == 1 //TES
				If (cAliasSFT)->F4_TPREG == "2"	//Cumulativo
					lCumulativ := .T.				
				ElseIF (cAliasSFT)->F4_TPREG == "3"	//Ambos, neste caso irei no produto para definir qual o regime				
					IF (cAliasSFT)->B1_TPREG == "2" //Cumulativo 
						lCumulativ := .T. 
					EndIF  				                        	
				EndIF
			Elseif nMVM996TPR == 2 //PRODUTO
				IF (cAliasSFT)->B1_TPREG == "2" //Cumulativo
					lCumulativ := .T.   
				EndIF									
			Elseif nMVM996TPR == 3 //CLIENTE
				If SPEDSeek("SA1",1,xFilial("SA1")+(cAliasSFT)->(FT_CLIEFOR+FT_LOJA))
					IF SA1->A1_TPREG == "2" //Cumulativo
						lCumulativ := .T.   
					EndIF
				Endif											
			EndIF  				
			
		EndIF

		If lPeCTB
			cConta := ""
			cConta	:=	ExecBlock("SPDPIS07", .F., .F., {	(cAliasSFT)->FT_FILIAL,;
				(cAliasSFT)->FT_TIPOMOV,;
				(cAliasSFT)->FT_SERIE,;
				(cAliasSFT)->FT_NFISCAL,;
				(cAliasSFT)->FT_CLIEFOR,;
				(cAliasSFT)->FT_LOJA,;
				(cAliasSFT)->FT_ITEM,;
				(cAliasSFT)->FT_PRODUTO,;
				(cAliasSFT)->FT_CONTA})
		Endif


		oApurSai:SetOrigem(CUPOM)			
		oApurSai:SetCFOP(	(cAliasSFT)->FT_CFOP)				
		oApurSai:SetReceita((cAliasSFT)->FT_TOTAL)
		oApurSai:SetTNatRec((cAliasSFT)->FT_TNATREC)
		oApurSai:SetCNatRec((cAliasSFT)->FT_CNATREC)		
		oApurSai:SetGNatRec((cAliasSFT)->FT_GRUPONC)
		oApurSai:SetDNatRec((cAliasSFT)->FT_DTFIMNT)
		oApurSai:SetQtde((cAliasSFT)->FT_QUANT)				
		If !lPeCTB
			oApurSai:SetConta((cAliasSFT)->FT_CONTA)
		Else
			oApurSai:SetConta(cConta)
		EndIf

		If cReg == 4
			oApurSai:SetTpReg(Iif (lCumulativ ,CUMULAT ,NAOCUMULAT ))
		EndIF

		//-------------------------------------------------------------------
		//Informações de PIS
		//-------------------------------------------------------------------			
		oApurSai:SetTributo(PIS)
		oApurSai:SetCST((cAliasSFT)->FT_CSTPIS)		
		oApurSai:SetAlqTrib((cAliasSFT)->FT_ALIQPIS)
		oApurSai:SetBcTrib((cAliasSFT)->FT_BASEPIS)
		oApurSai:SetValTrib((cAliasSFT)->FT_VALPIS)
		oApurSai:SetBaseST((cAliasSFT)->FT_BASEPS3)
		oApurSai:SetValST((cAliasSFT)->FT_VALPS3)
		oApurSai:SetAlqSt((cAliasSFT)->FT_ALIQPS3)		
		oApurSai:SetVlPauta((cAliasSFT)->FT_PAUTPIS)
		oApurSai:AgrpContr()			

		//-------------------------------------------------------------------
		//Informações da COFINS
		//-------------------------------------------------------------------		
		oApurSai:SetTributo(COFINS)		
		oApurSai:SetCST((cAliasSFT)->FT_CSTCOF)
		oApurSai:SetAlqTrib((cAliasSFT)->FT_ALIQCOF)
		oApurSai:SetBcTrib((cAliasSFT)->FT_BASECOF)
		oApurSai:SetValTrib((cAliasSFT)->FT_VALCOF)
		oApurSai:SetBaseST((cAliasSFT)->FT_BASECF3)
		oApurSai:SetValST((cAliasSFT)->FT_VALCF3)
		oApurSai:SetAlqSt((cAliasSFT)->FT_ALIQCF3)
		oApurSai:SetVlPauta((cAliasSFT)->FT_PAUTCOF)
		oApurSai:AgrpContr()	
		
		If lBilhete
			//As receitas de cupom fiscal são escrituradas na famíla do bloco D, no registro D350, por este motivo chamei o método abaixo com bloc fixo.
			cBloco	:= "D"		
		Else
			//As receitas de cupom fiscal são escrituradas na famíla do bloco C, nos registro C400 ou C490, por este motivo chamei o método abaixo com bloc fixo.		
			cBloco	:= "C"
		EndIf
		oApurSai:RecBlocos(cBloco)

		//Passo FT_VALCONT neste trecho somente para que a primeira aba da apuração o valor da receita seja o valor contábil, considerando
		//valores de despesas acessórias, frete,seguro, desconto etc...
		oApurSai:SetReceita((cAliasSFT)->FT_VALCONT)
		oApurSai:SetRecBrut((cAliasSFT)->FT_VALCONT)
		oApurSai:setIcmsSt(0)
		oApurSai:setValIpi(0)
		oApurSai:GrvResCST(,cBloco)

		(cAliasSFT)->(dbSkip())
					
	EndDo

	oApurSai:FechaAlias(cAliasSFT)

	If lProcessou
		//FINALIZA GRAVAÇÃO DAS RECEITAS.
		oApurSai:Finaliza('1')
	EndIF

Return

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funao    ³SPEDFSFT| Autor Bruce Mello  			   ³    Data ³29.01.2020     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descriao ³Funcao que efetua filtro na Tabela SFT para gerar CPRB Regime Caixa³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := SPEDFSFT(nPar,cPar,cPar,aPar)                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³nPar - Parametro que define se criara o filtro ou feche um filtro  ³±±
±±³          ³       jah criado. 1=Criar, 2=Fechar.                              ³±±
±±³          ³cPar - Se trata de um flag atraves do nome da tabela a ser criada o³±±
±±³          ³       o filtro. No caso de haver mais de um filtro para a mesma   ³±±
±±³          ³       tabela em situacoes diferentes, basta acrescentar um identi-³±±
±±³          ³       ficador na quarta posicao do nome. Ex: SFT, SFT1, SF2, etc..³±±
±±³          ³cPar - Variavel passada por referencia para retornar o alias criado³±±
±±³          ³       para a tabela em questao.                                   ³±±
±±³          ³aPar - Parametros para execucao dos filtros                        ³±±
±±³          ³nPar - Se esta variavel for passada diferente de NIL, significa que³±±
±±³          ³       a query deve retornar a quantidade de registros. Utilizado  ³±±
±±³          ³       para montar a regua de processamento mais precisa. O retorno³±±
±±³          ³       serah nesta mesma variavel que deve ser passada como        ³±±
±±³          ³       referencia. O retorno da funcao ainda continua sendo .T.    ³±±
±±³          ³       quando tiver registros ou .F. quando nao tiver.             ³±±
±±³          ³nPar - Indica o indice a ser usado (base Codebase)                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS - SPED EFD Contribuições                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function SPEDFSFT(nOpc,cTabela,cAlias,aPar,nRecCount,nOrdDBF)

	Local	ApeF500		:=	{}
	Local	cFiltro		:=	""
	Local	cIndex		:=	""
	Local	cSelect		:= 	""
	Local	cFrom		:= 	""
	Local	cWhere		:=	""
	Local	lRet		:=	.F.
	Local	lCountReg	:=	nRecCount<>Nil
	Local	nIndex		:=	0

	STATIC lNotAs400 := (TcSrvType()<>"AS/400")
	STATIC aExistBloc	:= {	ExistBlock("SPDFIS02"),;		// 01
								ExistBlock("SPDFIS06"),;		// 02
								ExistBlock("SPEDRTMS"),;		// 03
								ExistBlock("SPDFIS08"),;		// 04
								ExistBlock("SPEDPROD"),;		// 05
								ExistBlock("SPEDPTMS"),;		// 06
								ExistBlock("SPED1300"),;		// 07
								ExistBlock("SPED1390"),;		// 08
								ExistBlock("SPEDREGD"),;		// 09
								ExistBlock("SPDFIS001",,.T.),;	// 10
								ExistBlock("SPDFIS05"),;		// 11
								ExistBlock("SPDFIS04"),;		// 12
								ExistBlock("SPEDR450"),;		// 13
								ExistBlock("SPEDR460"),;		// 14
								ExistBlock("SPEDG126"),;		// 15
								ExistBlock("SPDFIS07"),;		// 16
								ExistBlock("SPDFIS10",,.T.),;	// 17
								ExistBlock("SPDPISIC"),;		// 18
								ExistBlock("SPDFIS09"),;		// 19
								ExistBlock("SPED0205"),;		// 20
								ExistBlock("SPED0150"),;		// 21
								ExistBlock("SPDFIS03"),;		// 22
								ExistBlock("SPDPINFO"),;		// 23
								ExistBlock("SPDFISBLCK"),;		// 24
								ExistBlock("SPEDFANT"),;		// 25
								ExistBlock("SPEDH020"),;		// 26
								ExistBlock("SPDFIS27"),;		// 27
								ExistBlock("SPDF500A"),;		// 28
								ExistBlock("SPDF500C"),;		// 29
								ExistBlock("SPED1400"),;		// 30
								ExistBlock("SPEDALTH"),;		// 31
								ExistBlock("SPDFIS11")}			// 32


	#IFDEF TOP
		Local	aSetField	:=	{}
		Local	nI			:=	0
		Local	cOrderBy	:=	""
	#ENDIF
	Default nOrdDBF := 0

	If nOpc==1
		If cTabela=="SFT4" // Uso do SPEDPISCOF
		
			#IFDEF TOP
				If lNotAs400
					cSelect :=	"SFT.FT_FILIAL,SFT.FT_VALCONT,SFT.FT_CSTPIS,SFT.FT_BASEPIS,SFT.FT_ALIQPIS,SFT.FT_CSTCOF,SFT.FT_BASECOF,SFT.FT_ALIQCOF,SFT.FT_TIPO,"
					cSelect	+=	"SFT.FT_ESPECIE,SFT.FT_CFOP ,SFT.FT_CONTA,SFT.FT_TNATREC,SFT.FT_CNATREC,SFT.FT_GRUPONC, SFT.FT_DTFIMNT,SFT.FT_PAUTPIS,SFT.FT_PAUTCOF,"
					cSelect	+=  "SFT.FT_NFISCAL,SFT.FT_CLIEFOR,SFT.FT_PRODUTO,SFT.FT_TIPOMOV,SFT.FT_SERIE,SFT.FT_LOJA,SFT.FT_ENTRADA,SFT.FT_QUANT,SFT.FT_VALPIS,SFT.FT_VALCOF,"    			
					cSelect	+=  "SFT.FT_SERORI,SFT.FT_NFORI,SFT.FT_ITEMORI,SFT.FT_ITEM,SFT.FT_VALIPI,SFT.FT_ICMSRET,SFT.FT_EMISSAO,SFT.FT_VALICM,SFT.FT_DESCONT, " 
					cSelect	+=	"SB1.B1_COD, SB1.B1_TIPO, SB1.B1_CODISS, SB1.B1_POSIPI, SB1.B1_DESC, SB1.B1_CODBAR,SB1.B1_CODGTIN, "
					cSelect	+=	"SB1.B1_CODANT, SB1.B1_UM, SB1.B1_EX_NCM,SB1.B1_PICM, SB1.B1_FECP, SB1.B1_DATREF, SB1.B1_VLR_PIS, SB1.B1_VLR_COF, SB1.B1_TNATREC, "
					cSelect	+=	"SB1.B1_CNATREC, SB1.B1_GRPNATR, SF2.F2_VALBRUT, SF2.F2_VALFAT "
					cSelect	+=	", SFT.FT_ATIVCPB, SFT.FT_VALCPB, SFT.FT_ALIQCPB, SFT.FT_BASECPB "

					cFrom	:=	""+RetSqlName("SFT")+" SFT "
					cFrom	+=	" LEFT JOIN "+RetSqlName("SB1")+" SB1 ON SB1.B1_FILIAL='"+xFilial("SB1")+"' AND SB1.B1_COD=SFT.FT_PRODUTO AND SB1.D_E_L_E_T_=''"   
					cFrom	+=	" LEFT JOIN "+RetSqlName("SF2")+" SF2 ON(SF2.F2_FILIAL='"+xFilial("SF2")+"'  AND SF2.F2_DOC=SFT.FT_NFISCAL AND SF2.F2_SERIE=SFT.FT_SERIE AND SF2.F2_CLIENTE=SFT.FT_CLIEFOR AND SF2.F2_LOJA=SFT.FT_LOJA AND SF2.D_E_L_E_T_=' ') "
					IF aPar[7]=="01"
						cSelect	+= " ,SA1.A1_CGC "
						cFrom += " LEFT JOIN "+RetSqlName("SA1")+" SA1 ON SA1.A1_FILIAL='"+xFilial("SA1")+"' AND SA1.A1_COD=SFT.FT_CLIEFOR AND "
						cFrom += " SA1.A1_LOJA=SFT.FT_LOJA AND SA1.D_E_L_E_T_=''"
					EndIF
					
					cWhere	:=	"SFT.FT_FILIAL='"+xFilial("SFT")+"' AND "
					cWhere	+=	"SFT.FT_TIPOMOV='S' AND "
					cWhere	+=	"SFT.FT_ENTRADA='"+aPar[1]+"' AND "
					cWhere	+=	"SFT.FT_SERIE='"+aPar[2]+"' AND "
					cWhere	+=	"SFT.FT_NFISCAL='"+aPar[3]+"' AND "
					cWhere	+=	"SFT.FT_CLIEFOR='"+aPar[4]+"' AND "
					cWhere	+=	"SFT.FT_LOJA='"+aPar[5]+"' AND "
					cWhere	+=	"(SFT.FT_BASEPIS > 0 OR SFT.FT_BASEPS3 > 0 OR  SFT.FT_BASECOF > 0 OR SFT.FT_BASECF3 > 0 OR SFT.FT_CSTPIS IN ('07','08','09','49') OR SFT.FT_CSTCOF IN ('07','08','09','49')) AND "
					If (aPar[6]<>"*")
						cWhere += " SFT.FT_NRLIVRO = '" +aPar[6]+"' AND "
					EndiF
					cWhere	+=	"SFT.D_E_L_E_T_=''"

					If aExistBloc[28] // PE para SCP com Filial unica - TTUXH9
						ApeF500 := ExecBlock("SPDF500A", .F. , .F. , {cFrom,cWhere})
						cFrom 	:= ApeF500[1]
						cWhere	:= ApeF500[2]
					Endif
					
					cSelect	:= "%"+cSelect+"%"
					cFrom 	:= "%"+cFrom+"%"
					cWhere	:= "%"+cWhere+"%"
						
					aAdd(aSetField,{"FT_EMISSAO","D",8,0})
					aAdd(aSetField,{"FT_ENTRADA","D",8,0})
					aAdd(aSetField,{"FT_DTCANC","D",8,0})
			Else
			#ENDIF
				cFiltro	:= 'FT_FILIAL=="'+xFilial ("SFT")+'" .And. '
				cFiltro += ' FT_TIPOMOV = "S" .AND. DTOS(FT_ENTRADA)="'+aPar[1]+'" .And. FT_SERIE == "' + aPar[2]  + '" .AND.  '
				cFiltro += 'FT_NFISCAL =="'+aPar[3]+'" .And. FT_CLIEFOR =="'+aPar[4]+'"  .AND. FT_LOJA =="'+aPar[5] + '" .AND.  '
				cFiltro	+= '(FT_BASEPIS > 0 .OR. FT_BASEPS3 > 0 .OR. FT_VALCOF > 0 .OR. FT_BASECF3 > 0 .OR. FT_CSTPIS $"07#08#09#49" .OR. FT_CSTCOF $"07#08#09#49")'
					If (aPar[6]<>"*")
						cFiltro	+=	'.And. FT_NRLIVRO ="'+aPar[6]+'" '
					EndIf
			#IFDEF TOP
				EndIf
			#ENDIF
		EndiF

		#IFDEF TOP
			If lNotAs400
				cAlias	:=	SPEDGetAlias(cTabela)
				BeginSql Alias cAlias
					SELECT
						%Exp:cSelect%

					FROM
						%Exp:cFrom%

					WHERE
						%Exp:cWhere+cOrderBy%

					//%Exp:cOrderBy%
				EndSql

				If !lCountReg
					For nI := 1 To Len(aSetField)
						TcSetField(cAlias,aSetField[nI,1],aSetField[nI,2],aSetField[nI,3],aSetField[nI,4])
					Next
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se o retorno deve ser a quantidade de registros, armazeno em uma variavel para retornar³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lCountReg
					nRecCount := (cAlias)->COUNTREG
				EndIf
			Else
		#ENDIF	
				cIndex  := CriaTrab(Nil,.F.)
				cTabela := SubStr(cTabela,1,3)
				IndRegua(cAlias,cIndex,(cTabela)->(IndexKey (nOrdDBF)),,cFiltro,,.F.)
				nIndex  := RetIndex(cAlias)
				#IFNDEF TOP
					DbSetIndex(cIndex+OrdBagExt())
				#ENDIF
				DbSelectArea(cAlias)
				DbSetOrder(nIndex+1)
				(cAlias)->(DbGoTop())
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se o retorno deve ser a quantidade de registros, armazeno em uma variavel para retornar³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lCountReg
					nRecCount := (cAlias)->(RecCount())
				EndIf
		#IFDEF TOP
			EndIf
		#ENDIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Como jah armazenei em uma variavel o valor da quantidade de registros, ³
		//³  posso fechar a area. O retorno da quantidade eh atraves de um        ³
		//³  parametro passado por referencia. O retorno da funcao ainda continua ³
		//³  sendo .T. quando tiver registros ou .F. quando nao tiver.            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lCountReg
			SPEDFFiltro(2,"",cAlias)
			lRet := nRecCount>0
		ElseIf !(cAlias)->(Eof())
			lRet := .T.
		Else
			SPEDFFiltro(2,"",cAlias)
		EndIf

	Else
		#IFDEF TOP
			If lNotAs400
				If Select(cAlias)<>0
					(cAlias)->(DbCloseArea())
				EndIf
			Else
		#ENDIF
				RetIndex(cAlias)
		#IFDEF TOP
			EndIf
		#ENDIF
	EndIf
Return lRet
//-------------------------------------------------------------------
/*/{Protheus.doc} A001CAIXA()
Função que irá processar as operações de PIS e COFINS através do regime de
Caixa, utilizando a função disponibilizada através de equipe de Financeiro

@param		dDataDe 	- Data de início da apuração
			dDataAte 	- Data final da apuração
			oApurSai	- Objeto de processamento das operações de débito
			cNrLivro	- Livro a ser processado
			cIndCompRe	- Indicador da composição da receita
			aXFilial	- Conteúdo do xFilial das tabelas da apuração.									

@author Erick G. Dias
@since 25/06/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001CAIXA(dDataDe,dDataAte,oApurSai,cNrLivro,cIndCompRe,aXFilial,lCPRBNF,cSPCBPSE,cFilialMat,lindividu,aParSX1, aAjuPISCOF, dMVICMDSDT,lDedIssBs)

	Local cAliasF500	:= 'F500'
	Local aParFil		:= {}
	Local lPauta		:= .F.
	Local lProcFin		:= .F.
	Local lCmpVrDes		:= .F.
	Local lValIcms      := .F.
	Local cAliasSFT		:= 'SFT'
	Local cCnpj			:= ''
	Local nPerReceb		:= 0
	Local nDesconto		:= 0
	Local cChaveCl1		:= ''
	Local lF07			:= AliasINdic('F07')
	Local lF0T			:= AliasINdic('F0T')
	Local cAliasCDG		:= "CDG"	
	Local aParCDG		:= {}
	Local oCaixa					
	Local oProcRef	
	Local lAtuCPRB		:= .F.
	Local ObjF0T
	Local cNome			:= ""
	Local cOutRec		:= SuperGetMv("MV_CODGEN",.F.,"")
	Local lNTrib 		:= CKX->(FieldPos('CKX_NTRIB'))>0 .And. !EmpTy(cOutRec)
	Local dDtMudReg 	:= SuperGetMV("MV_DTMREG",.F.,cToD("//"))
	Local nPosAj 		:= 0
	Local cDescAj 		:= 'Ajuste de redução da contribuição em função de mudança de regime de competência para caixa ocorrida em ' + DtoC(dDtMudReg)
	Local cInfCompAj 	:= ""
	Local dEmisTit 		:= cToD("//")
	Local cCodCon 		:= ""
	Local cChvNF 		:= ""
	Local cChvTit 		:= ""
	Local cDedbpis 		:= SuperGetMv("MV_DEDBPIS")
	Local cDedbcof 		:= SuperGetMv("MV_DEDBCOF")
	Local cTipoNf  		:= ''
	Local cEspecie		:= ''
	Local lDFSRVAC		:= GetNewPar("MV_DFSRVAC",.F.)
	Local cMVEstado	 	:= GetNewPar("MV_ESTADO","") 
	Local nValReceita	:= 0
	Local lSF2ValFat 	:= .F.
	Local aCFOPs     	:= XFUNCFRec()
	Local cCfop      	:= ''
	Local lTabCID		:= aliasindic("CID") .AND. Year(dDataDe) >= 2020
	Local aExigiSusp	:= {}
	Local lDSTRB 		:= GetNewPar("MV_DSTRB",.F.) 
	Local lIPIRB    	:= GetNewPar("MV_DIPIRB",.F.) 
	Local nExclusao 	:= 0 // Grava os valores de receita para os registros de exclusão, caso o cliente opte em deixar os MV_DSTRB e MV_DIPIRB, .F., por que caso um deles fique falso tenho que gravar no registro de exclusão
	Local nValST		:= 0
	Local nValipi		:= 0
	Local nExcluRB  	:= 0 // Somo IPI e ST de acordo com os parametros para subtrai do FT_VALCONT para compor o nReceita.
	Local lMudReg 		:= .F.
	Local lIntPFS   	:= SuperGetMv("MV_JESCJUR",,.F.) // Integração PFS Juridico
	Local nVlDesBas		:= 0
	Local lTpDesc		:= .F.

	Private oHExigSusp	:= HMNew() //Cria o Hash para apoio ao array aExigiSusp

	IF FindFunction('FinSpdF500')	
		If !Empty(dDtMudReg) 
			lMudReg := .T.  // controle de ratreio função do financeiro para posicionar o TITULO PAI e EMISSAO do TITULO PAI
		Endif
		
		//Chama função de integração com Financeiro
		cNome := FinSpdF500(Month(dDataDe),Year(dDataDe),cAliasF500,lMudReg)
		
		//Quando retornar F500 possui dados para processamento
		IF 	Empty(cNome) 
			If !ChkFile(cAliasF500)
				Return
			Else
				If Iif(FindFunction('FinSpdDel'),FinSpdDel(2),.T.)//Verifica se pode fechar a area da tabela temporaria
					DbSelectArea(cAliasF500)
					dbCloseArea()
				EndIf
				Ferase(cAliasF500+GetDBExtension())
				Ferase(cAliasF500+OrdBagExt()) 
				Return
			Endif	
		Endif

		If lF0T
			ObjF0T	:= TABELAF0T():New()
		EndIF
		
		//Cria objeto para gravação das informações na tabela CL1
		oCaixa	:= TABELACL1():New()
		oCaixa:SetPer(dDataDe)
		oCaixa:SetFilial(aXFilial)
		oCaixa:SetFilApu(cFilialMat)
		
		oProcRef	:= TABELAF07():New()
		oProcRef:SetPer(dDataDe)
		oProcRef:SetFilial(aXFilial)	
		
		//Cria objeto para gravação da CPRB
		If lCPRBNF
			oCPRB	:= CPRBEFD():New()
			oCPRB:SetDtIni(dDataDe)
		Endif
		
		// Instancia o objeto de apuração
		oApurEFD := FISX001():New()
		oApurEFD:SetFilial(aXFilial)
		oApurEFD:SetRegApur(CUMULAT)
		oApurEFD:SetDtIni(dDataDe)
		oApurEFD:SetDtFin(dDataAte)
		oApurEFD:DefRegime()
		oApurSai:DefRegime()
		
		//Chama função de integração com Financeiro
		(cAliasF500)->( DBGOTOP())
		lProcFin  := (cAliasF500)->(FieldPos('NUMPRO')) > 0 .AND.(cAliasF500)->(FieldPos('INDPRO')) > 0
		lCmpVrDes := (cAliasF500)->(FieldPos('VRDESCON')) > 0
		lDtTitPai := (cAliasF500)->(FieldPos('DTPAI')) > 0
		lTitPai   := (cAliasF500)->(FieldPos('RASTRO')) > 0
		lTpDesc   := (cAliasF500)->(FieldPos('E5_TPDESC')) > 0

		Do While !(cAliasF500)->( EOF())

			cChaveCl1	:= ''
			cChvNF      := ''
			cChvTit     := ''
			nVlDesBas	:= 0
			// se não houver valor de receita, ignora o registro DSERFIS1-31748
			If (cAliasF500)->VALOR == 0
				(cAliasF500)->(DbSkip())
				Loop
			EndIf
			
			IF !(cAliasF500)->ORIFIN
		
				aParFil	:=	{}
				aAdd(aParFil,(cAliasF500)->EMISSAO)
				aAdd(aParFil,(cAliasF500)->SERIE)
				aAdd(aParFil,(cAliasF500)->NUMERO)
				aAdd(aParFil,(cAliasF500)->CLIENTE)
				aAdd(aParFil,(cAliasF500)->LOJA)
				aAdd(aParFil,cNrLivro)
				aAdd(aParFil,'01')
				
				//³Considera o percentual de baixa enviado pelo financeiro³
				nPerReceb	:= (cAliasF500)->PERC / 100
				
				IF nPerReceb > 0

					//³Irá buscar os itens da nota fiscal referente a baixa que o Financeiro enviou³
					If SPEDFSFT(1,"SFT4",@cAliasSFT,aParFil)//SPEDFFiltro(1,"SFT3",@cAliasSFT,aParFil)		
						lValIcms	:= (cAliasSFT)->(FieldPos('FT_VALICM')) > 0
						lSF2ValFat  := (cAliasSFT)->(FieldPos('F2_VALFAT')) > 0
						Do While !(cAliasSFT)->( EOF())
							cCfop := AllTrim((cAliasSFT)->FT_CFOP)

							//---Verificar os CFOPs de receita para poder gerar os registros---//
							If (cCfop$aCFOPs[01] .Or. cCfop$aCFOPs[03]) .AND. !(cCfop$aCFOPs[02])
								lPauta	  := .F.
								nDesconto := Iif(lCmpVrDes .And. nPerReceb > 0,(cAliasF500)->VRDESCON,0) //DSERFIS1-16353
								nPerReceb := ((cAliasF500)->VALOR + nDesconto)  / Iif(lSF2ValFat .And. !lIntPFS,(cAliasSFT)->F2_VALFAT,(cAliasSFT)->F2_VALBRUT)							
								cCodCon   := ""
								nValICMS  := Iif(lValIcms,(cAliasSFT)->FT_VALICM,0)
								cTipoNf   := (cAliasSFT)->FT_TIPO
								nValDesco := DedPisCof(cDedbpis,cDedbcof,'2',nValICMS,'',cTipoNf, dMVICMDSDT,,lDedIssBs) 						

								If (cAliasSFT)->FT_PAUTPIS > 0 .OR. (cAliasSFT)->FT_PAUTCOF > 0
									lPauta 		:= .T.
								EndIF

								cEspecie	:= AModNot((cAliasSFT)->FT_ESPECIE)

								// Verifico se o percentual é diferente de 100%, pois caso seja maior, significa que as deduções estão sendo consideradas no título, porém não forma consideradas no F2_VALFAT
								// E caso o percentual seja menor, significa que foi realizada uma baixa parcial, portanto deve ser realizado o cálculo com base no valor total
								// Essa verificação será somente para Notas de Serviço (NFPS, NFS, NFSE, RPS), onde a cEspecie estará vazia
								IF nPerReceb <> 1 .And. Empty(cEspecie)
									nPerReceb := ((cAliasF500)->VALOR + nDesconto)  / (cAliasSFT)->F2_VALBRUT
								EndIf

								// Nessa variavel vai receber os valores de IPI e ICMS ST para diminuir do valor contabil , com isso caso o cliente optar em tirar o IPI ou ST consigo controlar.
								If lIPIRB
									nExcluRB := (cAliasSFT)->FT_VALIPI 
								EndIF

								If lDSTRB
									nExcluRB +=  (cAliasSFT)->FT_ICMSRET
								Endif
	
								// removido a variavel nDesconto do calculo abaixo pois segundo parecer da consultoria o valor de desconto incondicional ou condicional aplicado no financeiro
								// não deve ser subtraido do valor de receita para o regime caixa, pois no campo 2 do F500 deve ser apresentando o valor cheio da mesma na apuração.
								//https://tdn.totvs.com.br/pages/releaseview.action?pageId=853906235
								nValReceita	:= ((cAliasSFT)->FT_VALCONT + (cAliasSFT)->FT_DESCONT - nExcluRB) * nPerReceb 

								oCaixa:SetCstPis((cAliasSFT)->FT_CSTPIS)
								oCaixa:SetCstCof((cAliasSFT)->FT_CSTCOF)
								oCaixa:SetModelo(Iif(!Empty(cEspecie),cEspecie,"98"))
								oCaixa:SetCfop((cAliasSFT)->FT_CFOP)	
								oCaixa:SetValRec(nValReceita)
								
								If lTpDesc .And. !Empty((cAliasF500)->E5_TPDESC)// trecho adicionado para quando houver desconto incondicional também seja adicionado o valor de desconto dado em nota 
									nVlDesBas := nDesconto                      // variavel criada para que quando houver disconto incondicional aplicado no financeiro se faz necessário para subtrair da base 
									nDesconto += (((cAliasSFT)->FT_DESCONT * nPerReceb)) // tratativa necessaria para que quando tiver desconto na nota e/ou no financeiro o mesmo seja somado
								Endif 
								if !empty((cAliasF500)->PARCELA) .OR. Empty(cEspecie) .Or. (cAliasF500)->PERC <> 100//Issue DSERFIS1-32523, discutimos que será necessário reavaliar a parte da parcela e da baixa parical que estão errados
									oCaixa:SetDescPis(nDesconto + (((cAliasSFT)->FT_VALIPI + nValDesco) * nPerReceb) )
									oCaixa:SetBasePis(((cAliasSFT)->FT_BASEPIS * nPerReceb) - nVlDesBas)
									oCaixa:SetDescCof(nDesconto + (((cAliasSFT)->FT_VALIPI + nValDesco) * nPerReceb) )
									oCaixa:SetBaseCof(((cAliasSFT)->FT_BASECOF * nPerReceb) - nVlDesBas)

								else
									oCaixa:SetDescPis(nDesconto + (((cAliasSFT)->FT_VALIPI ) * nPerReceb) + nValDesco )
									oCaixa:SetBasePis(((((cAliasSFT)->FT_BASEPIS + nValDesco) * nPerReceb) - nValDesco) - nVlDesBas )
									oCaixa:SetDescCof(nDesconto + (((cAliasSFT)->FT_VALIPI ) * nPerReceb) + nValDesco )
									oCaixa:SetBaseCof(((((cAliasSFT)->FT_BASECOF + nValDesco) * nPerReceb) - nValDesco) - nVlDesBas )
								endif
								oCaixa:SetConta((cAliasSFT)->FT_CONTA)
								oCaixa:SetNumDoc((cAliasSFT)->FT_NFISCAL)
								oCaixa:SetSerie((cAliasSFT)->FT_SERIE)
								oCaixa:SetClieFor((cAliasSFT)->FT_CLIEFOR)
								oCaixa:SetLoja((cAliasSFT)->FT_LOJA)
								oCaixa:SetTNatRec((cAliasSFT)->FT_TNATREC)
								oCaixa:SetCNatRec((cAliasSFT)->FT_CNATREC)
								oCaixa:SetGrupo((cAliasSFT)->FT_GRUPONCA)
								oCaixa:SetDtFim((cAliasSFT)->FT_DTFIMNT)
								oCaixa:SetQuantid((cAliasSFT)->FT_QUANT)

								IF lPauta
									oCaixa:SetPauta('1')
									oCaixa:SetAlqPis((cAliasSFT)->FT_PAUTPIS)
									oCaixa:setAlqCof((cAliasSFT)->FT_PAUTCOF)							
								Else
									oCaixa:SetPauta('0')
									oCaixa:SetAlqPis((cAliasSFT)->FT_ALIQPIS)
									oCaixa:setAlqCof((cAliasSFT)->FT_ALIQCOF)						
								EndIF
			
								oCaixa:SetIndRec(cIndCompRe)
			
								If cIndCompRe == 1	//Agrupa por CNPJ de Cliente
									oCaixa:SetCnPj((cAliasSFT)->A1_CGC									)					
								Elseif cIndCompRe == 2	//Agrupar por número do título
									oCaixa:SetNfTit((cAliasF500)->NUMERO								)
								Elseif cIndCompRe == 3	//Agrupar por número do título
									oCaixa:SetNfTit((cAliasSFT)->FT_NFISCAL)
								Elseif cIndCompRe == 4 //agrupa por código de produto
									oCaixa:SetItem((cAliasSFT)->B1_COD									)					
								EndIF
			
								cChaveCl1	:= oCaixa:Save()	
								
								//Método que acumula as receitas por blocos A, C, D e F.						
								oApurSai:SetCST(oCaixa:getCST(PIS))
								oApurSai:SetReceita(nValReceita)
								oApurSai:CodCon()
								IF Empty(cEspecie) .OR. (!lDFSRVAC .AND. cEspecie == '55' .AND. cMVEstado == 'DF')
									oApurSai:RecBlocos("A")
								Else
									oApurSai:RecBlocos("C")
								EndIF
								
								IF !Empty(cChaveCL1) .AND. lF07

									//³Preenche array para pesquisar os processos referenciados vinculados a nota fiscal³
									aParCDG	:= {}
									aAdd(aParCDG,(cAliasSFT)->FT_TIPOMOV)
									aAdd(aParCDG,(cAliasSFT)->FT_NFISCAL)
									aAdd(aParCDG,(cAliasSFT)->FT_SERIE)
									aAdd(aParCDG,(cAliasSFT)->FT_CLIEFOR)
									aAdd(aParCDG,(cAliasSFT)->FT_LOJA)
									aAdd(aParCDG,(cAliasSFT)->FT_ITEM)
																	
									cAliasCDG	:= QryCDGCaixa(aParCDG, lTabCID)
									Do while !(cAliasCDG)->(EOF())
										oProcRef:SetId(cChaveCL1)
										oProcRef:SetPer(dDataDe)
										oProcRef:SetNumPro((cAliasCDG)->CDG_PROCES)
										oProcRef:SetIndPro((cAliasCDG)->CDG_TPPROC)
										oProcRef:SetIndAut((cAliasCDG)->CCF_INDAUT)
										oProcRef:SetIdItem((cAliasCDG)->CCF_IDITEM)

										oProcRef:Save()

										//Verifica se terá que processar informações da exigibilidade suspensa
										If lTabCID .AND. (cAliasCDG)->CCF_TRIB $ ("7#8") .AND. (cAliasCDG)->CCF_NATJU $ "12#13#14#15#16#17#19" .AND. (cAliasCDG)->CCF_TPCOMP $ "1#2"
											//Processa informações da exigibilidade suspensa										
											ProcExigi(@aExigiSusp, cAliasCDG, cAliasCDG, cAliasSFT, dDataDe, dDataAte, nPerReceb, cChaveCL1,.T.)
										EndIF

										(cAliasCDG)->(DBSKIP())
									EndDo
									DbSelectArea (cAliasCDG)
									(cAliasCDG)->(DbCloseArea())
									
								EndIF

								//Grava aqui as informações da nota
								ObjF0T:Clear()
								ObjF0T:SetValue("F0T_PER",dDataDe)
								ObjF0T:SetValue("F0T_FILAPU",cFilialMat)
								ObjF0T:SetValue("F0T_TIPO",'1')
								ObjF0T:SetValue("F0T_NUMNF",(cAliasSFT)->FT_NFISCAL)
								ObjF0T:SetValue("F0T_SER",(cAliasSFT)->FT_SERIE)
								ObjF0T:SetValue("F0T_DTEMI",(cAliasSFT)->FT_ENTRADA)
								ObjF0T:SetValue("F0T_DTRECB",ctod(substr((cAliasF500)->DTMOV,7,2) + "/" + substr((cAliasF500)->DTMOV,5,2) + "/" + substr((cAliasF500)->DTMOV,1,4)))
								ObjF0T:SetValue("F0T_CFOP",(cAliasSFT)->FT_CFOP)
								ObjF0T:SetValue("F0T_ITEM",(cAliasSFT)->FT_ITEM)
								ObjF0T:SetValue("F0T_MODELO",AModNot ((cAliasSFT)->FT_ESPECIE)	)
								ObjF0T:SetValue("F0T_PERREC",nPerReceb*100)
								ObjF0T:SetValue("F0T_VLCONT",(cAliasSFT)->FT_VALCONT)
								ObjF0T:SetValue("F0T_CSTPIS",oCaixa:getCST(PIS))
								ObjF0T:SetValue("F0T_BASPIS",oCaixa:getBase(PIS))
								ObjF0T:SetValue("F0T_ALQPIS",oCaixa:getAliq(PIS))
								ObjF0T:SetValue("F0T_VALPIS",Round(oCaixa:getBase(PIS)*oCaixa:getAliq(PIS)/Iif(lPauta,1,100),2))
								ObjF0T:SetValue("F0T_CSTCOF",oCaixa:getCST(COFINS))
								ObjF0T:SetValue("F0T_BASCOF",oCaixa:getBase(COFINS))
								ObjF0T:SetValue("F0T_ALQCOF",oCaixa:getAliq(COFINS))
								ObjF0T:SetValue("F0T_VALCOF",Round(oCaixa:getBase(COFINS)*oCaixa:getAliq(COFINS)/Iif(lPauta,1,100),2))
								ObjF0T:Grava()						

								//Busca valor de ICMS ST para abater do registro 0111 e na composição de Receita Bruta caso o parâmetro MV_DSTRB esteja habilitado 
								IF lDSTRB
									nValST	:= (cAliasSFT)->FT_ICMSRET
								EndIF
								//Busca valor dO IPI para abater do registro 0111 e na composição de Receita Bruta caso o parâmetro MV_DIPIRB esteja habilitado
								IF lIPIRB 
									nValipi :=(cAliasSFT)->FT_VALIPI
								Endif	

								//--------------------
								//Informações da CPRB
								//--------------------
								If lCPRBNF
									//Verifica parâmetro para definir se utilizará código de serviço ou de outros serviços.
									lAtuCPRB := .T.
									oCPRB:SetDtRefer(dDataDe)
									oCPRB:SetCodAtiv((cAliasSFT)->FT_ATIVCPB)
									oCPRB:SetVlBrut(((cAliasSFT)->FT_VALCONT + (cAliasSFT)->FT_DESCONT - nValipi - nValST ) * nPerReceb) 
									
									// Grava os valores de receita para os registros de exclusão, caso o cliente opte em deixar os MV_DSTRB e MV_DIPIRB, .F., por que caso um deles fique falso tenho que gravar no registro de exclusão
									If !Empty((cAliasSFT)->FT_ATIVCPB)               
										nExclusao = 0

										If !lIPIRB
											nExclusao += (cAliasSFT)->FT_VALIPI * nPerReceb
										EndIF

										If !lDSTRB
											nExclusao += (cAliasSFT)->FT_ICMSRET * nPerReceb
										EndIF
									Else
										nExclusao = 0
									EndIF 
											
									oCPRB:SetVlExcl((cAliasSFT)->FT_DESCONT + nExclusao) 
									oCPRB:SetVlCPRB((cAliasSFT)->FT_VALCPB * nPerReceb)
									oCPRB:SetAliq((cAliasSFT)->FT_ALIQCPB)
									oCPRB:SetBase((cAliasSFT)->FT_BASECPB * nPerReceb) 
									oCPRB:SetVlAtiv(((cAliasSFT)->FT_VALCONT + (cAliasSFT)->FT_DESCONT - nValipi -nValST) * nPerReceb) 
									oCPRB:SetConta((cAliasSFT)->FT_CONTA)
									oCPRB:SetCodRec(Iif(AllTrim((cAliasSFT)->FT_ATIVCPB)$cSPCBPSE,aParSX1[16],aParSX1[17])) 
									oCPRB:SetFilApu(IIf(lIndividu,oCPRB:BuscaxFil('CKY'),cFilialMat)) 
									// Verifica se codigo é não desonerado
									If lNTrib
										IF (cAliasSFT)->FT_ATIVCPB $ cOutRec
											oCPRB:SetNTrib(.T.)
										Endif
									Endif
									
									oCPRB:AgrupaCPRB()
									
									If !Empty((cAliasSFT)->FT_ATIVCPB) .And. AliasIndic('F2S')
										If ((cAliasSFT)->FT_VALIPI * nPerReceb) > 0
											oCPRB:SetDetExcl('07', (cAliasSFT)->FT_VALIPI * nPerReceb,'IPI')
										EndIf
										If((cAliasSFT)->FT_ICMSRET * nPerReceb) > 0
											oCPRB:SetDetExcl('08', (cAliasSFT)->FT_ICMSRET * nPerReceb,'ICMS-ST')
										EndIf
									EndIf

									//Grava o detalhamento da nota fiscal
									ObjF0T:Clear()
									ObjF0T:SetValue("F0T_PER",dDataDe)
									ObjF0T:SetValue("F0T_FILAPU",cFilialMat)
									ObjF0T:SetValue("F0T_TIPO",'3') //CPRB Regime de Caixa							
									ObjF0T:SetValue("F0T_NUMNF",(cAliasSFT)->FT_NFISCAL)
									ObjF0T:SetValue("F0T_SER",(cAliasSFT)->FT_SERIE)
									ObjF0T:SetValue("F0T_DTEMI",(cAliasSFT)->FT_ENTRADA)							
									ObjF0T:SetValue("F0T_CFOP",(cAliasSFT)->FT_CFOP)
									ObjF0T:SetValue("F0T_ITEM",(cAliasSFT)->FT_ITEM)
									ObjF0T:SetValue("F0T_MODELO",AModNot ((cAliasSFT)->FT_ESPECIE)	)
									ObjF0T:SetValue("F0T_VLCONT",(cAliasSFT)->FT_VALCONT)
									ObjF0T:SetValue("F0T_EXCPRB",If(EmpTy((cAliasSFT)->FT_ATIVCPB),0,(cAliasSFT)->FT_VALIPI * nPerReceb + (cAliasSFT)->FT_ICMSRET * nPerReceb))							
									ObjF0T:SetValue("F0T_CODATV",(cAliasSFT)->FT_ATIVCPB)
									ObjF0T:SetValue("F0T_BCCPRB",(cAliasSFT)->FT_BASECPB * nPerReceb)
									ObjF0T:SetValue("F0T_AQCPRB",(cAliasSFT)->FT_ALIQCPB)
									ObjF0T:SetValue("F0T_VLCPRB",(cAliasSFT)->FT_VALCPB * nPerReceb)							
									ObjF0T:Grava()						
								Endif			
													
								// Caso tenha ocorrido mudança de regime - de competência para caixa - 
								// Neste caso não posso tributar novamente a receita decorrente da baixa do título pois a 
								// mesma já foi tributada no período da emissão (competência). 
								// Devo, então, gerar um ajuste de redução para "zerar" os valores referentes à baixa.
								// Aqui só adiciono as informações no array aAjuPISCOF, depois do processamento do regime de caixa
								// vou efetivar os ajustes.
								If !Empty(dDtMudReg) .And. (cAliasSFT)->FT_EMISSAO < dDtMudReg

									// Define descrição do ajuste.
									cInfCompAj := "Doc.:" + AllTrim((cAliasSFT)->FT_NFISCAL) +;
												",Série:" + AllTrim((cAliasSFT)->FT_SERIE) +;
												",Cli/Loja:" + AllTrim((cAliasSFT)->FT_CLIEFOR + (cAliasSFT)->FT_LOJA) +; 
												",Emis.:" + DtoC((cAliasSFT)->FT_EMISSAO)

									// Chave da NF p/ agrupamento
									cChvNF := oCaixa:getNumDoc() + oCaixa:getSerie() + oCaixa:getClieFor() + oCaixa:getLoja()

									// PIS

									//Passa CST de PIS para classe
									oApurEFD:SetCST(oCaixa:getCST(PIS))
									cCodCon := oApurEFD:CodCon()

									// Verifica se trata-se de uma receita tributada p/ fazer o ajuste.
									If AllTrim(cCodCon) $ "51|52|53|54"
										If (nPosAj := aScan(aAjuPISCOF, { |x| x[1] == PIS .And. x[18] == cChvNF  .And. x[7] == cCodCon .And. Str(x[15]) == Str(oCaixa:getAliq(PIS)) })) == 0
											aAdd(aAjuPISCOF, {})
											nPosAj := Len(aAjuPISCOF)                            
											aAdd(aAjuPISCOF[nPosAj], PIS)						// 01 - TRIBUTO
											aAdd(aAjuPISCOF[nPosAj], REDUCAO)					// 02 - INDICADOR DO TIPO DE AJUSTE
											aAdd(aAjuPISCOF[nPosAj], '05')						// 03 - CÓDIGO DO AJUSTE (Ajuste Oriundo de Outras Situações)
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getNumDoc())		// 04 - NUMERO DO DOCUMENTO
											aAdd(aAjuPISCOF[nPosAj], cDescAj + " - " + cInfCompAj)		// 05 - DESCRIÇÃO DO AJUSTE
											aAdd(aAjuPISCOF[nPosAj], (cAliasSFT)->FT_EMISSAO)	// 06 - DATA DE REFERÊNCIA DO AJUSTE
											aAdd(aAjuPISCOF[nPosAj], cCodCon)					// 07 - CÓDIGO DA CONTRIBUIÇÃO
											aAdd(aAjuPISCOF[nPosAj], CUMULAT)					// 08 - REGIME
											aAdd(aAjuPISCOF[nPosAj], '4')						// 09 - ORIGEM (4 - FINANCEIRO)
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getBase(PIS) * oCaixa:getAliq(PIS) / Iif(lPauta,1,100)) // 10 - VALOR DO AJUSTE
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getCST(PIS))		// 11 - CST
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getConta())			// 12 - CONTA
											aAdd(aAjuPISCOF[nPosAj], cInfCompAj)				// 13 - INFOS. COMPLEMENTARES (M225)
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getBase(PIS))		// 14 - BASE
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getAliq(PIS))		// 15 - ALIQUOTA
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getTNatRec())		// 16 - TABELA - NATUREZA DA RECEITA
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getCNatRec())		// 17 - CODIGO - NATUREZA DA RECEITA
											aAdd(aAjuPISCOF[nPosAj], cChvNF)					// 18 - CHAVE DA NOTA (Não vai no ajuste - Só p/ agrupar)

										Else
											aAjuPISCOF[nPosAj, 10] += oCaixa:getBase(PIS) * oCaixa:getAliq(PIS) / Iif(lPauta,1,100) // 10 - VALOR DO AJUSTE
											aAjuPISCOF[nPosAj, 14] += oCaixa:getBase(PIS)											// 14 - BASE
										EndIf
										
									EndIf

									// COFINS

									//Passa CST de COFINS para classe
									oApurEFD:SetCST(oCaixa:getCST(COFINS))
									cCodCon := oApurEFD:CodCon()

									// Verifica se trata-se de uma receita tributada p/ fazer o ajuste.
									If AllTrim(cCodCon) $ "51|52|53|54"
										If (nPosAj := aScan(aAjuPISCOF, { |x| x[1] == COFINS .And. x[18] == cChvNF  .And. x[7] == cCodCon .And. Str(x[15]) == Str(oCaixa:getAliq(COFINS)) })) == 0
											aAdd(aAjuPISCOF, {})
											nPosAj := Len(aAjuPISCOF)
											aAdd(aAjuPISCOF[nPosAj], COFINS)					// 01 - TRIBUTO
											aAdd(aAjuPISCOF[nPosAj], REDUCAO)					// 02 - INDICADOR DO TIPO DE AJUSTE
											aAdd(aAjuPISCOF[nPosAj], '05')						// 03 - CÓDIGO DO AJUSTE (Ajuste Oriundo de Outras Situações)
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getNumDoc())		// 04 - NUMERO DO DOCUMENTO
											aAdd(aAjuPISCOF[nPosAj], cDescAj + " - " + cInfCompAj) // 05 - DESCRIÇÃO DO AJUSTE
											aAdd(aAjuPISCOF[nPosAj], (cAliasSFT)->FT_EMISSAO)	// 06 - DATA DE REFERÊNCIA DO AJUSTE
											aAdd(aAjuPISCOF[nPosAj], cCodCon)					// 07 - CÓDIGO DA CONTRIBUIÇÃO
											aAdd(aAjuPISCOF[nPosAj], CUMULAT)					// 08 - REGIME
											aAdd(aAjuPISCOF[nPosAj], '4')						// 09 - ORIGEM (4 - FINANCEIRO)
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getBase(COFINS) * oCaixa:getAliq(COFINS) / Iif(lPauta,1,100)) // 10 - VALOR DO AJUSTE
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getCST(COFINS))		// 11 - CST
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getConta())			// 12 - CONTA
											aAdd(aAjuPISCOF[nPosAj], cInfCompAj)				// 13 - INFOS. COMPLEMENTARES (M225)
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getBase(COFINS))	// 14 - BASE
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getAliq(COFINS))	// 15 - ALIQUOTA
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getTNatRec())		// 16 - TABELA - NATUREZA DA RECEITA
											aAdd(aAjuPISCOF[nPosAj], oCaixa:getCNatRec())		// 17 - CODIGO - NATUREZA DA RECEITA
											aAdd(aAjuPISCOF[nPosAj], cChvNF)					// 18 - CHAVE DA NOTA (Não vai no ajuste - Só p/ agrupar)
										Else
											aAjuPISCOF[nPosAj, 10] += oCaixa:getBase(COFINS) * oCaixa:getAliq(COFINS) / Iif(lPauta,1,100)  // 10 - VALOR DO AJUSTE
											aAjuPISCOF[nPosAj, 14] += oCaixa:getBase(COFINS)											   // 14 - BASE	
										EndIf
									EndIf
								EndIf

								oCaixa:Clear()
												
							EndIf
							(cAliasSFT)->( DBSKIP())						
						EndDo	                 
						//³Fecha alias dos itens da nota fiscal³
						SPEDFFiltro(2,,cAliasSFT)

						//Aqui verifica se existem informações de exigibilidade suspensa processados no laço das notas, se sim gravará as informações
						If Len(aExigiSusp) > 0
							x001GrvCIE(aExigiSusp, dDataDe)
							aSize(aExigiSusp,0) //Limpo o array que não era limpo
							aExigiSusp:=Nil
						EndIf					

					EndIF 
				EndIF
			Else
				//Se (cAliasF500)->ORIFIN igual a .T. indica que o titulo nao possui vinculo com documento fiscal	
				//Se tiver valor no campo VRDESC, foi baixa que não caracteriza um recebimento
			
				IF (cAliasF500)->VRDESC == 0
		
					cInfCompl		:= ''
					cCnpj			:= ''
					nDesconto		:= Iif(lCmpVrDes,(cAliasF500)->VRDESCON,0)
					// Quando temos uma Reliquidação de uma liquidação, o Financeiro tem o controle na TABELA Fi7, na função FinSpdF500 eles criaram outras 2 funções para rastrear o TITULO Principal quando temos mudança de regime Competencia para CAIXA.
					// Dessa forma iremos buscar no (cAliasF500)->DTPAI a data do TITULO PAI que foi gerando as liquidações e Re-Liquidações.
					// Essa situação é somente quanto tenho LIquidação e Reliquidação; Verifico se DTPAI e RASTRO tem conteudo.
					If lDtTitPai .And. lTitPai .And. (cAliasF500)->DTPAI <> " " .And.  (cAliasF500)->RASTRO <> " "
						dEmisTit    	:= cToD((cAliasF500)->DTPAI)
					Else
						dEmisTit    	:= cToD(SubStr((cAliasF500)->EMISSAO,7,2) + "/" + SubStr((cAliasF500)->EMISSAO,5,2) + "/" + SubStr((cAliasF500)->EMISSAO,1,4))
					Endif
					cCodCon         := ""

					If nDesconto > 0 .And. ;
					(Max((cAliasF500)->BASEPIS - nDesconto, 0) == 0 .Or.;
						Max((cAliasF500)->BASECOF - nDesconto, 0) == 0)   //Verifico se o valor de desconto é maior que zero e se este é maior que as bases de PIS e Cofins evitando valores negativos na apuração
						nDesconto := 0
					EndiF
					
					If SPEDSeek("SA1",1,xFilial("SA1")+(cAliasF500)->CHVCLIENTE)				
						cCnpj	:= SA1->A1_CGC
					EndIF
		
					IF (cAliasF500)->TABELA=="SEI" .AND. cIndCompRe <> 2
						cIndCompRe:= 9
						cInfCompl:= STR0078 + (cAliasF500)->CHVCLIENTE //"Juros Referente Aplicação Financeira - (Banco + Agência + Conta) :  "			
					EndIF

					oCaixa:SetCstPis((cAliasF500)->CSTPIS					)
					oCaixa:SetCstCof((cAliasF500)->CSTCOF					)
					oCaixa:SetValRec((cAliasF500)->VALOR + nDesconto		)  // acrescido o valor de desconto, pois segundo retorno da consultoria tributária o valor de receita não pode ser subtraido valor de desconto para fins tributários 
					oCaixa:SetDescPis(nDesconto								)
					oCaixa:SetBasePis((cAliasF500)->BASEPIS - nDesconto	)
					oCaixa:SetDescCof(nDesconto								)
					oCaixa:SetBaseCof((cAliasF500)->BASECOF - nDesconto	)
					oCaixa:SetConta((cAliasF500)->CONTA					)
					oCaixa:SetNumDoc((cAliasF500)->NUMERO					)
					oCaixa:SetTNatRec((cAliasF500)->ED_TABCCZ				)
					oCaixa:SetCNatRec((cAliasF500)->ED_CODCCZ				)
					oCaixa:SetGrupo((cAliasF500)->ED_GRUCCZ				)
					oCaixa:SetDtFim((cAliasF500)->ED_DTFCCZ				)
					oCaixa:SetPauta('0'										)//Não existe tratamento de conversão de puata para operações do módulo Financeiro
					oCaixa:SetAlqPis((cAliasF500)->ALIQPIS					)
					oCaixa:setAlqCof((cAliasF500)->ALIQCOF					)
					oCaixa:SetInfCom(cInfCompl								)
					oCaixa:SetIndRec(cIndCompRe								)
		
					IF lProcFin .AND. !Empty((cAliasF500)->NUMPRO) .AND. !Empty((cAliasF500)->INDPRO)
						oCaixa:SetIndPro((cAliasF500)->INDPRO)
						oCaixa:SetNumPro((cAliasF500)->NUMPRO)
					EndIF
		
					If cIndCompRe == 1	//Agrupa por CNPJ de Cliente
						oCaixa:SetCnPj(cCnpj)					
					Elseif cIndCompRe == 2 .OR. cIndCompRe == 3 .OR. cIndCompRe == 4 //Agrupar por número do título
						oCaixa:SetNfTit((cAliasF500)->NUMERO)
					EndIF
		
					cChaveCL1	:= oCaixa:Save()

					oApurSai:SetCST(oCaixa:getCST(PIS))
					oApurSai:SetReceita((cAliasF500)->VALOR)
					oApurSai:CodCon()
					oApurSai:RecBlocos("F")				
					
					//Grava aqui as informações da nota	
					ObjF0T:Clear()
					ObjF0T:SetValue("F0T_PER",dDataDe)
					ObjF0T:SetValue("F0T_FILAPU",cFilialMat)
					ObjF0T:SetValue("F0T_TIPO",'2')				
					ObjF0T:SetValue("F0T_NUMTIT",(cAliasF500)->NUMERO)
					ObjF0T:SetValue("F0T_PREFIX",(cAliasF500)->PREFIXO)
					ObjF0T:SetValue("F0T_PARC",(cAliasF500)->PARCELA)
					ObjF0T:SetValue("F0T_DTEMI",dEmisTit)
					ObjF0T:SetValue("F0T_DTRECB",ctod(substr((cAliasF500)->DTMOV,7,2) + "/" + substr((cAliasF500)->DTMOV,5,2) + "/" + substr((cAliasF500)->DTMOV,1,4)))
					ObjF0T:SetValue("F0T_PERREC",(cAliasF500)->PERC)
					ObjF0T:SetValue("F0T_VLCONT",(cAliasF500)->VALOR)
					ObjF0T:SetValue("F0T_CSTPIS",oCaixa:getCST(PIS))
					ObjF0T:SetValue("F0T_BASPIS",oCaixa:getBase(PIS))
					ObjF0T:SetValue("F0T_ALQPIS",oCaixa:getAliq(PIS))
					ObjF0T:SetValue("F0T_VALPIS",Round(oCaixa:getBase(PIS)*oCaixa:getAliq(PIS)/Iif(lPauta,1,100),2))
					ObjF0T:SetValue("F0T_CSTCOF",oCaixa:getCST(COFINS))
					ObjF0T:SetValue("F0T_BASCOF",oCaixa:getBase(COFINS))
					ObjF0T:SetValue("F0T_ALQCOF",oCaixa:getAliq(COFINS))
					ObjF0T:SetValue("F0T_VALCOF",Round(oCaixa:getBase(COFINS)*oCaixa:getAliq(COFINS)/Iif(lPauta,1,100),2))				
					ObjF0T:Grava()
				
					// Caso tenha ocorrido mudança de regime - de competência para caixa - 
					// Neste caso não posso tributar novamente a receita decorrente da baixa do título pois a 
					// mesma já foi tributada no período da emissão (competência). 
					// Devo, então, gerar um ajuste de redução para "zerar" os valores referentes à baixa.
					// Aqui só adiciono as informações no array aAjuPISCOF, depois do processamento do regime de caixa
					// vou efetivar os ajustes.
					If !Empty(dDtMudReg) .And. dEmisTit < dDtMudReg
						
						cInfCompAj := "Tit.:" + AllTrim((cAliasF500)->NUMERO) +;
									",Pref.:" + AllTrim((cAliasF500)->PREFIXO) +; 
									",Parc.:" + AllTrim((cAliasF500)->PARCELA) +;
									",Tipo:" + AllTrim((cAliasF500)->TIPO) +;
									",Cli/Loja:" + AllTrim((cAliasF500)->CHVCLIENTE) +;
									",Emis.:" + DtoC(dEmisTit)

						cChvTit    := (cAliasF500)->PREFIXO + (cAliasF500)->NUMERO + (cAliasF500)->PARCELA + (cAliasF500)->TIPO + (cAliasF500)->CHVCLIENTE

						// PIS

						//Passa CST de PIS para classe
						oApurEFD:SetCST(oCaixa:getCST(PIS))
						cCodCon := oApurEFD:CodCon()

						// Verifica se trata-se de uma receita tributada p/ fazer o ajuste.
						If AllTrim(cCodCon) $ "51|52|53|54"
							If (nPosAj := aScan(aAjuPISCOF, { |x| x[1] == PIS .And. x[18] == cChvTit  .And. x[7] == cCodCon .And. Str(x[15]) == Str(oCaixa:getAliq(PIS)) })) == 0
								aAdd(aAjuPISCOF, {})
								nPosAj := Len(aAjuPISCOF)                            
								aAdd(aAjuPISCOF[nPosAj], PIS)						// 01 - TRIBUTO
								aAdd(aAjuPISCOF[nPosAj], REDUCAO)					// 02 - INDICADOR DO TIPO DE AJUSTE
								aAdd(aAjuPISCOF[nPosAj], '05')						// 03 - CÓDIGO DO AJUSTE (Ajuste Oriundo de Outras Situações)
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getNumDoc())		// 04 - NUMERO DO DOCUMENTO
								aAdd(aAjuPISCOF[nPosAj], cDescAj + " - " +cInfCompAj)// 05 - DESCRIÇÃO DO AJUSTE
								aAdd(aAjuPISCOF[nPosAj], dEmisTit)					// 06 - DATA DE REFERÊNCIA DO AJUSTE
								aAdd(aAjuPISCOF[nPosAj], cCodCon)					// 07 - CÓDIGO DA CONTRIBUIÇÃO
								aAdd(aAjuPISCOF[nPosAj], CUMULAT)					// 08 - REGIME
								aAdd(aAjuPISCOF[nPosAj], '4')						// 09 - ORIGEM (4 - FINANCEIRO)
								aAdd(aAjuPISCOF[nPosAj], (oCaixa:getBase(PIS) * (oCaixa:getAliq(PIS) / 100))) // 10 - VALOR DO AJUSTE
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getCST(PIS))		// 11 - CST
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getConta())			// 12 - CONTA
								aAdd(aAjuPISCOF[nPosAj], cInfCompAj)				// 13 - INFOS. COMPLEMENTARES (M225)
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getBase(PIS))		// 14 - BASE
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getAliq(PIS))		// 15 - ALIQUOTA
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getTNatRec())		// 16 - TABELA - NATUREZA DA RECEITA
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getCNatRec())		// 17 - CODIGO - NATUREZA DA RECEITA
								aAdd(aAjuPISCOF[nPosAj], cChvTit)					// 18 - CHAVE DO TITULO (Não vai no ajuste - Só p/ agrupar)
							Else
								aAjuPISCOF[nPosAj, 10] += (oCaixa:getBase(PIS) * (oCaixa:getAliq(PIS) / 100))	// 10 - VALOR DO AJUSTE
								aAjuPISCOF[nPosAj, 14] += oCaixa:getBase(PIS)									// 14 - BASE
							EndIf
						EndIf

						// COFINS

						//Passa CST de COFINS para classe
						oApurEFD:SetCST(oCaixa:getCST(COFINS))
						cCodCon := oApurEFD:CodCon()

						// Verifica se trata-se de uma receita tributada p/ fazer o ajuste.
						If AllTrim(cCodCon) $ "51|52|53|54"
							If (nPosAj := aScan(aAjuPISCOF, { |x| x[1] == COFINS .And. x[18] == cChvTit  .And. x[7] == cCodCon .And. Str(x[15]) == Str(oCaixa:getAliq(COFINS)) })) == 0
								aAdd(aAjuPISCOF, {})
								nPosAj := Len(aAjuPISCOF)
								aAdd(aAjuPISCOF[nPosAj], COFINS)					// 01 - TRIBUTO
								aAdd(aAjuPISCOF[nPosAj], REDUCAO)					// 02 - INDICADOR DO TIPO DE AJUSTE
								aAdd(aAjuPISCOF[nPosAj], '05')						// 03 - CÓDIGO DO AJUSTE (Ajuste Oriundo de Outras Situações)
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getNumDoc())		// 04 - NUMERO DO DOCUMENTO
								aAdd(aAjuPISCOF[nPosAj], cDescAj + " - " +cInfCompAj)// 05 - DESCRIÇÃO DO AJUSTE
								aAdd(aAjuPISCOF[nPosAj], dEmisTit)					// 06 - DATA DE REFERÊNCIA DO AJUSTE
								aAdd(aAjuPISCOF[nPosAj], cCodCon)					// 07 - CÓDIGO DA CONTRIBUIÇÃO
								aAdd(aAjuPISCOF[nPosAj], CUMULAT)					// 08 - REGIME
								aAdd(aAjuPISCOF[nPosAj], '4')						// 09 - ORIGEM (4 - FINANCEIRO)
								aAdd(aAjuPISCOF[nPosAj], (oCaixa:getBase(COFINS) * (oCaixa:getAliq(COFINS) / 100))) // 10 - VALOR DO AJUSTE
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getCST(COFINS))		// 11 - CST
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getConta())			// 12 - CONTA
								aAdd(aAjuPISCOF[nPosAj], cInfCompAj)				// 13 - INFOS. COMPLEMENTARES (M225)
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getBase(COFINS))	// 14 - BASE
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getAliq(COFINS))	// 15 - ALIQUOTA
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getTNatRec())		// 16 - TABELA - NATUREZA DA RECEITA
								aAdd(aAjuPISCOF[nPosAj], oCaixa:getCNatRec())		// 17 - CODIGO - NATUREZA DA RECEITA
								aAdd(aAjuPISCOF[nPosAj], cChvTit)					// 18 - CHAVE DO TITULO (Não vai no ajuste - Só p/ agrupar)							
							Else
								aAjuPISCOF[nPosAj, 10] += (oCaixa:getBase(COFINS) * (oCaixa:getAliq(COFINS) / 100)) // 10 - VALOR DO AJUSTE
								aAjuPISCOF[nPosAj, 14] += oCaixa:getBase(COFINS)									// 14 - BASE
							EndIf
						EndIf

					EndIf

					oCaixa:Clear()
					
					IF !Empty(cChaveCL1) .AND. lF07
						oProcRef:SetId(cChaveCL1)
						oProcRef:SetPer(dDataDe)
						oProcRef:SetNumPro((cAliasF500)->NUMPRO)
						oProcRef:SetIndPro((cAliasF500)->INDPRO)
						oProcRef:Save()
					EndIF
					
				EndIF	
			EndIF
							
			(cAliasF500)->( DBSKIP())	
		EndDo	
		
		oCaixa:CalcCaixa(oApurSai)

		If Iif(FindFunction('FinSpdDel'),FinSpdDel(2),.T.)//Verifica se pode fechar a area da tabela temporaria
			oCaixa:FechaAlias(cAliasF500)
		EndIF	
		
		If lF07
			oProcRef:GravaF07()
		EndIF

		If lCPRBNF .And. lAtuCPRB				
			//Grava os valores alterados.
			oCPRB:GravaCPRB()
		Endif
		
		FreeObj(oCaixa)
		oCaixa	:= Nil
		
		FreeObj(oProcRef)
		oProcRef	:= Nil
		
		If lCPRBNF				
			FreeObj(oCPRB)
			oCPRB	:= Nil
		Endif
		
		FERASE(cAliasF500)

		// Limpa os dados do HashMap
		HMClean(oHExigSusp)
		// Libera o objeto de HashMap
		FreeObj(oHExigSusp)
		oHExigSusp := Nil

		
	EndIF

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} DefRegime()
Função que define o regime da operação. Somente deverá ser utilizada quando
no alias houver os campos F4_TPREG, B1_TPREG e/ou A1_TPREG.

@param		nM996Tpr 	- Conteúdo do parâmetro MV_M996TPR
			cAlias 	- Alias da query realizada com os campos F4_TPREG, B1_TPREG e A1_TPREG.

@author Erick G. Dias
@since 07/07/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function DefRegime(nM996Tpr,cAlias)

	Local cRegime	:= ''

	If nM996Tpr == 1
		If Empty((cAlias)->F4_TPREG) .And. (cAlias)->(FieldPos("FT_TES"))>0 .And. !Empty((cAlias)->FT_TES) .And. SPEDSeek("SF4",1,xFilial("SF4")+(cAlias)->FT_TES)		
			If SF4->F4_TPREG $ '1/2'
				cRegime	:= SF4->F4_TPREG
			ElseIf SF4->F4_TPREG == '3'
				cRegime	:= (cAlias)->B1_TPREG
			Else
				cRegime	:= NAOCUMULAT //O legado será mantido, nesta situação onde o TES não resolve é adotado regime Não Cumulativo
			EndIf
		Else	
			//TES
			//Se o regime definido no TES for igual a ambos ou por algum motivo não encontrar o TES, o produto irá definir o regime
			If (cAlias)->F4_TPREG $ '1/2'
				cRegime	:= (cAlias)->F4_TPREG
			ElseIf (cAlias)->F4_TPREG == '3'
				cRegime	:= (cAlias)->B1_TPREG
			Else
				cRegime	:= NAOCUMULAT //O legado será mantido, nesta situação onde o TES não resolve é adotado regime Não Cumulativo
			EndIf
		Endif
	ElseIf nM996Tpr == 2
		//PRODUTO
		cRegime	:= (cAlias)->B1_TPREG
	ElseIf nM996Tpr == 3
		//CLIENTE
		cRegime	:= (cAlias)->A1_TPREG
	EndIf

Return cRegime

//-------------------------------------------------------------------
/*/{Protheus.doc} ASA001CANC()
Função que irá buscar as notas canceladas e gravar na tabela CF4 para 
que possa ser utilizada no estorno da contribuição.
Estas informações gravadas na CF4 serão utilizadas posteriormente na geração
do arquivo texto.

@param		dDataDe 	- Data inicial do processamento
			dDataAte 	- Data Final do processamento
			cRegime 	- Regime da apuração escolhido pelo usuário
			cNrLivro 	- Livro de processamento
			aXFilial 	- Array conteúdo xFilial das tabelas de apuração									

@author Erick G. Dias
@since 08/07/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function ASA001CANC(dDataDe, dDataAte,cRegime,cNrLivro,aXFilial,cReg, cOpAju)

	Local nQtdMesAnt	:=	SuperGetMv("MV_NMCSPC",.F.,12)
	Local nMVM996TPR	:=  SuperGetMv("MV_M996TPR",.F.,1)
	Local cMvDCODRSE	:= 	SuperGetMv("MV_DCODRSE", .F., "'110'") 
	Local dDtCanc		:=	Firstday(dDataDe)
	Local cDtAlt		:= 	SubStr(DTos(dDataDe),5,2)+SubStr(Dtos(dDataDe),1,4)
	Local nX			:=  0
	Local cAliasSFT		:= GetNextAlias()
	local cSelect		:= ''
	Local cFrom			:= ''
	Local cWhere		:= ''
	Local cChvSFT		:= ''
	Local cCdCtPis		:= '' 
	Local cCdCtCof		:= ''
	Local oApurSai 
	Local lCF4FLORIG	:= .F.
	Local lCF4FIL		:= CF4->(FieldPos("CF4_FLORIG"))>0
	Local cVersao 		:= GetVersao(.F.)

	Default cOpAju		:= "1" //Ajuste da contribuição
	cMvDCODRSE  := IIF(Empty(cMvDCODRSE), "'110'", cMvDCODRSE)

	/*1-Ajuste da contribuição normal
	2-Ajuste da contribuição somente do cst 03
	3-Ajuste da base de cálculo
	*/
					//Verificação se existe o 4 índice na CF4
					DbSelectArea("SIX")
					DbSetOrder(1)
					IF cVersao <> '12'
						If MsSeek("CF4" + "3")
							lCF4FLORIG	:= .T.
						EndIF
					Else
						If MsSeek("CF4" + "4")
							lCF4FLORIG	:= .T.
						EndIF
					EndIF

					dbSelectArea("CF4")
					IF lCF4FLORIG
						IF cVersao <> '12'
							dbSetOrder(3)
						Else
							dbSetOrder(4)
						EndIF
					Else
						dbSetOrder(1)
					EndIF
					//Verifica qual será o mês inicial a ser considerado
					For nX := 1 to nQtdMesAnt
						dDtCanc	:= Firstday(dDtCanc)-1
					Next nX

					dDtCanc	:= Firstday(dDtCanc)

					oApurSai := FISX001():New()
					//Passa o regime da apuração para a classe.
					oApurSai:SetFilial(aXFilial)
					oApurSai:SetRegApur(Str(cReg,1))
					oApurSai:SetDtIni(dDataDe)
					oApurSai:SetDtFin(dDataDe)					

					cSelect	:=	'SFT.FT_FILIAL,	SFT.FT_ENTRADA,	SFT.FT_DTCANC,	SFT.FT_CFOP,		SFT.FT_TIPO,		SFT.FT_BASEPIS,'
					cSelect	+=	'SFT.FT_CSTPIS,	SFT.FT_BASECOF,	SFT.FT_CSTCOF,	SFT.FT_ESPECIE,	SFT.FT_NRLIVRO,	SFT.FT_NFISCAL,'
					cSelect	+=	'SFT.FT_SERIE,	SFT.FT_ITEM,		SFT.FT_CLIEFOR,	SFT.FT_LOJA,		SFT.FT_TIPOMOV,	SFT.FT_VALPIS,'
					cSelect	+=	'SFT.FT_BASEPIS,	SFT.FT_VALCOF,	SFT.FT_BASECOF,	SFT.FT_EMISSAO,	SFT.FT_ALIQPIS,	SFT.FT_ALIQCOF,'
					cSelect	+=	'SFT.FT_CFOP,		SFT.FT_CSTPIS,	SFT.FT_CSTCOF,	SFT.FT_PAUTPIS,	SFT.FT_PAUTCOF, 	SFT.FT_MVALCOF,'
					cSelect	+=	'SFT.FT_MALQCOF,'
					cSelect	+=	'SF3.F3_CODRSEF'

					cFrom		:=	RetSqlName("SFT")+" SFT "

					cFrom		+= "INNER JOIN "+RetSqlName("SF3")+" SF3 ON SF3.F3_FILIAL='"+xFilial("SF3")+"' AND SFT.FT_NFISCAL=SF3.F3_NFISCAL AND SFT.FT_SERIE=SF3.F3_SERIE AND SFT.FT_ESPECIE=SF3.F3_ESPECIE AND SFT.FT_CLIEFOR=SF3.F3_CLIEFOR AND SFT.FT_LOJA=SF3.F3_LOJA AND SFT.FT_IDENTF3=SF3.F3_IDENTFT AND SFT.FT_ENTRADA=SF3.F3_ENTRADA "

					cWhere		:=	"SFT.FT_FILIAL='"+xFilial("SFT")+"' AND "
					cWhere		+=	"SFT.FT_TIPOMOV='S' AND "
					cWhere		+=	"SFT.FT_ENTRADA<'"+DTOS(dDataDe)+"' AND "
					cWhere		+=	"SFT.FT_ENTRADA>='"+DTOS(dDtCanc)+"' AND "
					cWhere		+=	"SFT.FT_DTCANC>='"+DTOS(dDataDe)+"' AND "
					cWhere		+=	"SFT.FT_DTCANC<='"+DTOS(dDataAte)+"' AND "
					cWhere		+=	"((SFT.FT_CFOP NOT LIKE '000' AND SFT.FT_CFOP NOT LIKE '999') OR SFT.FT_TIPO='S') AND "
					cWhere		+=	"(SFT.FT_BASEPIS > 0   OR  SFT.FT_BASECOF > 0  OR SFT.FT_CFOP LIKE '7') AND SFT.FT_ESPECIE <> 'CF' AND "
					If (cNrLivro<>"*")
						cWhere += " SFT.FT_NRLIVRO = '" +cNrLivro+"' AND "
					EndiF

					cWhere	+=	"SF3.F3_CODRSEF NOT IN(" + cMvDCODRSE + ") AND "

					cWhere		+=	"SFT.D_E_L_E_T_=' ' AND "
					cWhere		+=	"SF3.D_E_L_E_T_=' '"

					If cRegime $'4' //Cumulativo e não cumulativo
						If nMVM996TPR==1  .And. SF4->(FieldPos("F4_TPREG"))>0 .And. SB1->(FieldPos("B1_TPREG"))>0
							If	SFT->(FieldPos("FT_TES"))>0
								cSelect += ",SFT.FT_TES"
							Endif
							cSelect	+=	" ,SF4.F4_TPREG,SB1.B1_TPREG"
							cFrom		+=	" LEFT JOIN "+RetSqlName("SD2")+" SD2 ON SD2.D2_FILIAL='"+xFilial("SD2")+"' AND SD2.D2_DOC=SFT.FT_NFISCAL AND SD2.D2_SERIE=SFT.FT_SERIE AND "
							cFrom		+=	" SD2.D2_CLIENTE=SFT.FT_CLIEFOR AND SD2.D2_LOJA=SFT.FT_LOJA AND SD2.D2_ITEM=SFT.FT_ITEM AND SD2.D_E_L_E_T_=' ' "
							cFrom		+=	" LEFT JOIN "+RetSqlName("SF4")+" SF4 ON SF4.F4_FILIAL='"+xFilial("SF4")+"' AND SF4.F4_CODIGO=SD2.D2_TES AND SF4.D_E_L_E_T_=' ' "
							cFrom		+=	" LEFT JOIN "+RetSqlName("SB1")+" SB1 ON SB1.B1_FILIAL='"+xFilial("SB1")+"' AND SB1.B1_COD=SFT.FT_PRODUTO AND SB1.D_E_L_E_T_=' '"
						Elseif nMVM996TPR==2 .And. SB1->(FieldPos("B1_TPREG"))>0
							cSelect	+=	" ,SB1.B1_TPREG"
							cFrom		+=	" LEFT JOIN "+RetSqlName("SB1")+" SB1 ON SB1.B1_FILIAL='"+xFilial("SB1")+"' AND SB1.B1_COD=SFT.FT_PRODUTO AND SB1.D_E_L_E_T_=' '"
						Elseif nMVM996TPR==3 .And. SA1->(FieldPos("A1_TPREG")) > 0
							cSelect	+=	" ,SA1.A1_TPREG"
							cFrom		+=	" LEFT JOIN "+RetSqlName("SA1")+" SA1 ON SA1.A1_FILIAL='"+xFilial("SA1")+"' AND SA1.A1_COD=SFT.FT_CLIEFOR AND "
							cFrom		+=	" SA1.A1_LOJA=SFT.FT_LOJA AND SA1.D_E_L_E_T_=' '"
						Endif
					Endif

					cSelect	:= '%'+cSelect+'%'
					cFrom		:= '%'+cFrom+'%'
					cWhere		:= '%'+cWhere+'%'

					BeginSql Alias cAliasSFT
	COLUMN FT_ENTRADA AS DATE
	COLUMN FT_DTCANC AS DATE
	COLUMN FT_EMISSAO AS DATE
	SELECT			    
		%Exp:cSelect%
	FROM 
		%Exp:cFrom%
	WHERE
		%Exp:cWhere%
					EndSql

					DbSelectArea (cAliasSFT)
					(cAliasSFT)->(DbGoTop ())
					Do While !(cAliasSFT)->(Eof ())

						If cOpAju == '3' .AND. (cAliasSFT)->FT_CSTPIS == '03'
							(cAliasSFT)->(DbSkip())
							Loop
						EndIF

						If cOpAju == '2' .AND. (cAliasSFT)->FT_CSTPIS <> '03'
							(cAliasSFT)->(DbSkip())
							Loop
						EndIF

						IF lCF4FLORIG
							cChvSFT	:=	(cAliasSFT)->FT_FILIAL+DTOS((cAliasSFT)->FT_EMISSAO)+(cAliasSFT)->(FT_TIPOMOV+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA+FT_ITEM)
						Else
							cChvSFT	:=	(cAliasSFT)->(FT_TIPOMOV+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA+FT_ITEM)
						EndIF

						//Passa o regime da operação
						If cReg == 4
							oApurSai:SetTpReg(DefRegime(nMVM996TPR,cAliasSFT))
						EndIF
						//Chama método para classe definir o regime
						oApurSai:DefRegime()
						//Passa CST de PIS para classe
						oApurSai:SetCST((cAliasSFT)->FT_CSTPIS)
						//Pega código da contribuição processada pela classe
						cCdCtPis:=oApurSai:CodCon()
						//Processa código da ~contribuição da COFINS
						oApurSai:SetCST((cAliasSFT)->FT_CSTCOF)
						//Pega código da contribuição processada pela classe
						cCdCtCof:=oApurSai:CodCon()

						If !CF4->(MsSeek(xFilial("CF4")+cChvSFT))
							RecLock ("CF4", .T.)
							CF4->CF4_FILIAL	:= xFilial("CF4")
							CF4->CF4_NOTA 		:=(cAliasSFT)->FT_NFISCAL 										// 01- NOTA FISCAL
							CF4->CF4_SERIE 	:=(cAliasSFT)->FT_SERIE  										// 02- SERIE DA NOTA FISCAL
							CF4->CF4_ITEM 		:=(cAliasSFT)->FT_ITEM  											// 03- ITEM DA NOTA FISCAL
							CF4->CF4_CLIFOR 	:=(cAliasSFT)->FT_CLIEFOR  										// 04- CLIENTE OU FORNECEDOR
							CF4->CF4_LOJA 		:=(cAliasSFT)->FT_LOJA	  										// 05- LOJA
							CF4->CF4_TIPMOV 	:=(cAliasSFT)->FT_TIPOMOV  										// 06- TIPO DE MOVIMENTO
							CF4->CF4_VALPIS 	:=(cAliasSFT)->FT_VALPIS								  			// 07- VALOR DO PIS
							CF4->CF4_ALIPIS 	:=(cAliasSFT)->FT_ALIQPIS  										// 08- ALIQUOTA DO PIS
							CF4->CF4_BASPIS 	:=(cAliasSFT)->FT_BASEPIS  										// 09- BASE DE CALCULO DO PIS
							CF4->CF4_VALCOF 	:=(cAliasSFT)->FT_VALCOF - (cAliasSFT)->FT_MVALCOF			// 10- VALOR COFINS
							CF4->CF4_ALICOF 	:=(cAliasSFT)->FT_ALIQCOF - (cAliasSFT)->FT_MALQCOF			// 11- ALIQUOTA COFINS
							CF4->CF4_BASCOF 	:=(cAliasSFT)->FT_BASECOF  										// 12- BASE COFINS
							CF4->CF4_DATAE 	:=(cAliasSFT)->FT_ENTRADA  										// 13- DATA DE ENTRADA
							CF4->CF4_CFOP 		:=(cAliasSFT)->FT_CFOP	  										// 14- CFOP DA NOTA FISCAL
							CF4->CF4_CSTPIS 	:=(cAliasSFT)->FT_CSTPIS  										// 15- SIT. TRIBUTARIA PIS
							CF4->CF4_CSTCOF 	:=(cAliasSFT)->FT_CSTCOF 							 			// 16- SIT. TRIBUTARIA COFINS
							CF4->CF4_CONPIS 	:= cCdCtPis														// 17- COD. CONTRIBUICAO PIS
							CF4->CF4_CONCOF 	:= cCdCtCof														// 18- COD. CONTRIBUICAO COFINS
							CF4->CF4_PATPIS 	:=Iif((cAliasSFT)->FT_PAUTPIS==0,0,(cAliasSFT)->FT_PAUTPIS) // 19- VALOR PAUTA PIS
							CF4->CF4_PATCOF 	:=Iif((cAliasSFT)->FT_PAUTCOF==0,0,(cAliasSFT)->FT_PAUTCOF)	// 20- VALOR PAUTA COFINS
							CF4->CF4_ORIPIS	:=(cAliasSFT)->FT_VALPIS 										// 21- VALOR DO PIS ORIGINAL
							CF4->CF4_ORICOF	:=(cAliasSFT)->FT_VALCOF 										// 22- VALOR DO PIS ORIGINAL
							CF4->CF4_DTALT 	:= cDtAlt
							If lCF4FIL
								CF4->CF4_FLORIG 	:= (cAliasSFT)->FT_FILIAL
							EndIF
							MsUnLock ()
						Else
							RecLock ("CF4", .F.)
							CF4->CF4_VALPIS		+=(cAliasSFT)->FT_VALPIS 									// 01- VALOR DO PIS
							CF4->CF4_ORIPIS		+=(cAliasSFT)->FT_VALPIS 									// 02- VALOR DO PIS ORIGINAL
							CF4->CF4_VALCOF		+=(cAliasSFT)->FT_VALCOF										// 03- VALOR COFINS
							CF4->CF4_ORICOF		+=(cAliasSFT)->FT_VALCOF 									// 04- VALOR DO PIS ORIGINAL
							MsUnLock ()
						EndIF

						(cAliasSFT)->(DbSkip ())
					EndDo


					oApurSai:FechaAlias(cAliasSFT)

					oApurSai:EstornCanc(NAOCUMULAT,cOpAju)
					oApurSai:EstornCanc(CUMULAT, cOpAju)

					FreeObj(oApurSai)
					oApurSai	:= Nil

					Return

//-------------------------------------------------------------------
/*/{Protheus.doc} ASA001DCF4()
Função que irá limpar a tabela CF4 antes de popular com as operações de
cancelamentos efetuadas no período, porém com emissão em períodos anteriores.

@author Erick G. Dias
@since 10/07/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function ASA001DCF4(cDtAlt)

	If !Empty(cDtAlt)
		DbSelectArea ("CF4")
		CF4->(DbSetOrder (2))
		CF4->(DbGoTop ())
		If CF4->( MsSeek(xFilial("CF4")+cDtAlt) )
			Do While CF4->( !Eof() .And. CF4_FILIAL==xFilial("CF4") .And. CF4_DTALT==cDtAlt )
				RecLock("CF4",.F.)
				CF4->(dbDelete())
				MsUnLock()
				CF4->(FKCommit())

				CF4->(DbSkip ())
			EndDo
		EndIf
	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} ASA001Devo()
Esta função irá realizar tratamento das devoluções de venda e compra, 
do período atual ou de período anterior.

Devoluções de Compras Regime Não Cumulativo: 
	Estas devoluções no próprio período, deverão estornar a base de cálculo
	do crédito. Se a devolução ocorrer em período posterior, então
	deverá ser efetuado ajuste de redução de crédito na apuração.
	A devolução de compra somente terá tratamento no regime Não Cumualtivo,
	já que no regime Cumulativo não dão direito ao crédito.

Devoluções de Compras Regime Cumulativo:
	Não existem, pois as compras não dão direito ao crédito.	

Devoluções de Vendas Regime Não Cumulativo:
	As devoluções de venda neste regime sempre dão direito ao crédito, ão 
	deverá proceder com ajuste de redução da contribuição.
	A única exceção é quando a devolução de venda é feita com formulário próprio,
	ai neste caso deverá proceder com ajuste de redução do débito.
	
Devolução de vendas Regime Cumulativo:
	Neste caso se for devolução no mesmo período, deverá realizar ajuste de redução
	de base de cálculo, se for em período posterior, deverá então gerar ajuste
	de redução da contribuição.


@param 	dDataDe 	 - Data inicial do processamento
			dDataAte	 - Data Final do processamento
			cNrLivro    - Livro que deverá ser processado.
			cTpMov   	 - Tipo de movimento Entrada/Saída
			nMVM996TPR - Conteúdo do parâmetro MV_M996TPR
			cRegime    - Regime da apuração escolhido pelo usuário
			lPerAtu 	- Indica se o processamento é do período atual
			aXFilial 	- Array com conteúdo do xFilial das tabelas da apuração
			cOrigem 	- Data Final do processamento						
			lCPRBNF	- Indica que é operação CPRB
			cSPCBPSE	- Parâmetro referente ao código de recolhimento 																								
																		
@author Erick G. Dias
@since 10/07/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function ASA001Devo(dDataDe,dDataAte,cNrLivro,cTpMov,nMVM996TPR,cRegime,lPerAtu,aXFilial,cOrigem,lCPRBNF,cSPCBPSE, cOpAju,lAjBase)

	Local cAliasSFT		:= 'SFT'
	Local cSerOri		:= ''
	Local cNotaOri		:= ''
	Local cIteOri		:= ''
	Local cRegDev		:= ''
	Local cCodCon		:= ''
	Local cDescr		:= ''
	Local cCodCred		:= ''
	Local cChave		:= ''
	Local cDtAlt		:= 	SubStr(DTos(dDataDe),5,2)+SubStr(Dtos(dDataDe),1,4)
	Local aAreaSFT		:= {}
	Local cTpMovQry		:= Iif(cTpMov=="S","E","S")
	Local lGravaCF4		:= .F.
	Local oAjuCred		:= Nil
	Local oAjuDeb		:= Nil
	Local oApurEFD		:= Nil
	Local lCF4FLORIG	:= .F. //Se existe o indice na CF4 correcriado corretamente
	Local lCF4FIL		:= CF4->(FieldPos("CF4_FLORIG"))>0 //Se existe o campo criado
	Local lAtuCPRB		:= .F.
	Local nBaseCalc		:= 0
	Local nAlq			:= 0
	Local lBlocoD 		:= .F.
	Local nBseTot 		:= 0
	Local nValCrd 		:= 0
	Local nBseProp 		:= 0
	Local cVersao 		:= GetVersao(.F.)
	Local cCodRec 		:= ''
	Local nBsReduz 		:= 0 //Tratativa para CST 05 com relação a Base de redução ReduzBase()
	Local nVlReduz		:= 0 //Tratativa para CST 05 com relação ao valor de Redução para o Metodo ReduzBase()
	Local nValorAj		:= 0 //Tratativa para CST 05 com relação ao valor de PIS ou Cofins no calculo de valor de Ajuste de Base pelas devoluções
	Local ojQntDevol	:= JsonObject():New() //Variável para fazer o controle da quantidade de itens devolvidos no mesmo período 
	Local cChvDevol		:= ""
	Local cLoja 		:= ""

	Default cOpAju		:= "1"
//Verificação se existe o 4 índice na CF4
	DbSelectArea("SIX")
	DbSetOrder(1)
	IF cVersao <> '12'
		If MsSeek("CF4" + "3")
			lCF4FLORIG	:= .T.
		EndIF
	Else
		If MsSeek("CF4" + "4")
			lCF4FLORIG	:= .T.
		EndIF
	EndIF

	oAjuCred := AJUSTEEFD():New()
	oAjuCred:SetFilial(aXFilial)
	oAjuCred:SetDtIni(dDataDe)
	oAjuCred:SetCrdDeb(CREDITO) //crédito
	oAjuCred:LoadCL8()

	oApurEFD := FISX001():New()
	//Passa o regime da apuração para a classe.
	oApurEFD:SetFilial(aXFilial)
	oApurEFD:SetRegApur(cRegime)
	oApurEFD:SetDtIni(dDataDe)
	oApurEFD:SetDtFin(dDataAte)
	oApurEFD:LoadRecBru()

	oAjuDeb	:= AJUSTEEFD():New()
	oAjuDeb:SetFilial(aXFilial)
	oAjuDeb:SetDtIni(dDataDe)
	oAjuDeb:SetCrdDeb(DEBITO) //débito
	oAjuDeb:LoadCKS( Iif(cOpAju == '3', .T., .F.))

	If lCPRBNF
		oCPRB	:= CPRBEFD():New()
		oCPRB:SetDtIni(dDataDe)
	Endif

	dbSelectArea("CF4")
	IF lCF4FLORIG // Se existe o campo CF4_FLORIG e se
		IF cVersao <> '12'
			dbSetOrder(3)
		Else
			dbSetOrder(4)
		EndIF
	Else
		dbSetOrder(1)
	EndIF


	//CHAMA FUNÇÃO QUE FAZ QUERY PARA BUSCAR AS DEVOLUÇÕES
	cAliasSFT	:= QRYDEVOL(dDataDe,dDataAte,cTpMovQry,cNrLivro,cRegime,nMVM996TPR)

	Do While !(cAliasSFT)->(Eof ())
		cClie := (cAliasSFT)->FT_CLIEFOR
		cLoja := (cAliasSFT)->FT_LOJA		
		SFT->(DbSetOrder(6))
		//FT_FILIAL+FT_TIPOMOV+FT_NFISCAL+FT_SERIE
		IF SFT->(MsSeek(xFilial("SFT")+cTpMov+Alltrim((cAliasSFT)->FT_NFORI+(cAliasSFT)->FT_SERORI))) .And. cTpMov == "S"
			//Busca o código do cliente, pois existem casos nas devoluções de cupom fiscal onde o
			//código do fornecedor não é o mesmo da venda, por isso busca da nota original.
			cClie := SFT->FT_CLIEFOR
			cLoja := SFT->FT_LOJA
		EndIF		

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Para as devolucoes de venda, preciso verificar qual o regime da operacao  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cTpMov == "S"

			IF cRegime == "4"
				cRegDev := DefRegime(nMVM996TPR,cAliasSFT)
			Elseif cRegime == "2"
				cRegDev := "2"
			Else
				cRegDev := "1"
			Endif
		Endif

		SFT->(DbSetOrder(1))
		aAreaSFT 	:= SFT->(GetArea())
		cNotaOri 	:= (cAliasSFT)->FT_NFISCAL
		cIteOri		:= (cAliasSFT)->FT_ITEM
		cSerOri		:= (cAliasSFT)->FT_SERIE
		cChvDevol 	:= xFilial("SFT")+cTpMov+(cAliasSFT)->(FT_SERORI+FT_NFORI+cClie+cLoja+FT_ITEMORI+FT_PRODUTO)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciono na nota fiscal original, para calcular a porcentagem de devolucao³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SFT->(MsSeek(cChvDevol)) .And. SFT->FT_VALPIS > 0 .OR. SFT->FT_VALCOF  > 0

			IF (cAliasSFT)->FT_BASEPIS > 0 .AND. (cAliasSFT)->FT_BASEPIS <= SFT->FT_BASEPIS
				nPercDevP :=	(cAliasSFT)->FT_BASEPIS / SFT->FT_BASEPIS
			Else
				nPercDevP := (((cAliasSFT)->FT_QUANT * 100) / SFT->FT_QUANT ) / 100
			EndIF

			IF (cAliasSFT)->FT_BASECOF > 0 .AND. (cAliasSFT)->FT_BASECOF <= SFT->FT_BASECOF
				nPercDevC := (cAliasSFT)->FT_BASECOF / SFT->FT_BASECOF
			Else
				nPercDevC := (((cAliasSFT)->FT_QUANT * 100) / SFT->FT_QUANT ) / 100
			EndIF

			lBlocoD := If(aModNot(Alltrim(SFT->FT_ESPECIE)) $ '07|08|8B|09|10|11|26|27|57|67', .T., .F.)
			lMoto	:= Iif(SFT->FT_TNATREC == '4312' .AND. SubStr(SFT->FT_CNATREC,1,2) $ '20/30',.T.,.F.)
			nBseTot := 0
			nValCrd := 0
			nBseProp := 0			

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Devolucao no proprio periodo³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If DTOS(SFT->FT_ENTRADA) >= DTOS(FirstDay(dDataDe)) .And. DTOS(SFT->FT_ENTRADA) <= DTOS(LastDay(dDataAte)) .And. !lBlocoD

				//Somente irá gravar a nota de devolução na tabela CF4 se a nota original realmente foi considerada
				//para apuração de PIS e COFINS, para poder efetuar a redução da base de cálculo, caso contrário
				//não fará redução e não grava CF4.
				lGravaCF4	:= .F.

				If cTpMov == 'S' .AND. oApurEFD:ChkRegraNf(SFT->FT_ESPECIE,SFT->FT_CFOP,NFSAIDA,,,(cAliasSFT)->FT_CSTPIS)

					lGravaCF4	:= IIF(SFT->FT_CSTPIS  $ cCstTrib,.T. ,.F.  )
				ElseIF cTpMov == 'E' .AND. oApurEFD:ChkEspecie(AModNot(SFT->FT_ESPECIE))

					lGravaCF4	:= IIF(SFT->FT_CSTPIS  $ cCSTCRED,.T. ,.F.  )
				EndIF

				If lGravaCF4 .AND. lPerAtu

					If lCF4FLORIG
						//CF4_FLORIG+DTOS(CF4_DATAE)+CF4_TIPMOV+CF4_SERIE+CF4_NOTA+CF4_CLIFOR+CF4_LOJA+CF4_ITEM
						cChvSFT	:=	SFT->FT_FILIAL+DTOS(SFT->FT_EMISSAO)+SFT->(FT_TIPOMOV+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA+FT_ITEM)
					Else
						//CF4_TIPMOV+CF4_SERIE+CF4_NOTA+CF4_CLIFOR+CF4_LOJA+CF4_ITEM
						cChvSFT	:=	SFT->(FT_TIPOMOV+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA+FT_ITEM)
					EndIF

					If ojQntDevol[cChvDevol] == Nil // Caso não tenha a chave do Json, atribuo a quantidade
						ojQntDevol[cChvDevol] := (cAliasSFT)->FT_QUANT
					Else
						ojQntDevol[cChvDevol] += (cAliasSFT)->FT_QUANT //Acrescento a quantidade de itens devolvidos no mesmo periódo
					EndIf

					If !CF4->(MsSeek(xFilial("CF4")+cChvSFT))
						RecLock ("CF4", .T.)
						CF4->CF4_FILIAL		:= xFilial("CF4")
						CF4->CF4_NOTA 		:= SFT->FT_NFISCAL 								// 01- NOTA FISCAL
						CF4->CF4_SERIE 		:= SFT->FT_SERIE  								// 02- SERIE DA NOTA FISCAL
						CF4->CF4_ITEM 		:= SFT->FT_ITEM  								// 03- ITEM DA NOTA FISCAL
						CF4->CF4_CLIFOR 	:= SFT->FT_CLIEFOR  							// 04- CLIENTE OU FORNECEDOR
						CF4->CF4_LOJA 		:= SFT->FT_LOJA	  								// 05- LOJA
						CF4->CF4_TIPMOV 	:= SFT->FT_TIPOMOV  							// 06- TIPO DE MOVIMENTO
						CF4->CF4_VALPIS 	:= Round(SFT->FT_VALPIS*nPercDevP,2)			// 07- VALOR DO PIS
						CF4->CF4_ALIPIS 	:= SFT->FT_ALIQPIS  							// 08- ALIQUOTA DO PIS
						CF4->CF4_VALCOF 	:= Round(SFT->FT_VALCOF*nPercDevC,2)			// 10- VALOR COFINS
						CF4->CF4_ALICOF 	:= SFT->FT_ALIQCOF								// 11- ALIQUOTA COFINS
						CF4->CF4_DATAE 		:= SFT->FT_EMISSAO  							// 13- DATA DE ENTRADA
						CF4->CF4_CSTPIS 	:= SFT->FT_CSTPIS  								// 15- SIT. TRIBUTARIA PIS
						CF4->CF4_CSTCOF 	:= SFT->FT_CSTCOF 							 	// 16- SIT. TRIBUTARIA COFINS
						CF4->CF4_PATPIS 	:= Iif(SFT->FT_PAUTPIS==0,0,SFT->FT_PAUTPIS) 	// 19- VALOR PAUTA PIS
						CF4->CF4_PATCOF 	:= Iif(SFT->FT_PAUTCOF==0,0,SFT->FT_PAUTCOF)	// 20- VALOR PAUTA COFINS
						CF4->CF4_BASPIS		:= Round(SFT->FT_BASEPIS*nPercDevP,2)
						CF4->CF4_BASCOF		:= Round(SFT->FT_BASECOF*nPercDevP,2)
						CF4->CF4_TIPO		:= 'D'
						CF4->CF4_DTALT 		:= cDtAlt

						IF lCF4FIL
							CF4->CF4_FLORIG	:= SFT->FT_FILIAL
						EndIF

						CF4->(MsUnLock())
					Else
						RecLock ("CF4", .F.)
						CF4->CF4_VALPIS		+= Round(SFT->FT_VALPIS*nPercDevP,2)
						CF4->CF4_VALCOF		+= Round(SFT->FT_VALCOF*nPercDevC,2)
						CF4->CF4_BASPIS		+= Round(SFT->FT_BASEPIS*nPercDevP,2)
						CF4->CF4_BASCOF		+= Round(SFT->FT_BASECOF*nPercDevP,2)

						// Caso a quantidade de itens devolvidos seja igual à quantidade da nota original, eu pego o valor da nota sem arredondar
						// Assim os valores vão se abater e vai dar o valor de 0 no arquivo
						// Pois há casos onde existe devoluções totais em notas diferentes, isso ocasiona problemas de arredondamento de 0,01 para cima ou para baixo
						// Caso o parâmetro MV_RNDSOBR esteja .T. na escrituração
						If ojQntDevol[cChvDevol] == SFT->FT_QUANT
							CF4->CF4_VALPIS := SFT->FT_VALPIS
							CF4->CF4_VALCOF := SFT->FT_VALCOF
						EndIf

						CF4->(MsUnLock())
					EndIF

					If cTpMov == 'S' .and. (cRegime $ '2/4' .OR.	(cAliasSFT)->FT_FORMUL == 'S')
						oApurEFD:Clear()
						//Realiza o estorno da contribuição considerando as devoluções de venda no próprio período.

						//PROCESSA ESTORNO DE PIS
						oApurEFD:SetTributo(PIS)
						oApurEFD:SetAlqTrib(SFT->FT_ALIQPIS)
						oApurEFD:SetAlqSt(SFT->FT_ALIQPS3)
						oApurEFD:SetCST(SFT->FT_CSTPIS)
						oApurEFD:SetTNatRec(SFT->FT_TNATREC)
						oApurEFD:SetCNatRec(SFT->FT_CNATREC)

						//Verifica se documento original é Cupom Fiscal
						If !Empty(SFT->FT_PDV) .AND. AllTrim(SFT->FT_ESPECIE)$"CF/ECF"
							oApurEFD:SetOrigem(CUPOM)
						Else
							oApurEFD:SetOrigem(FISCALSAI)
						EndIF
						oApurEFD:SetTpReg(cRegDev)
						oApurEFD:DefRegime()
						oApurEFD:SetCodDC(oApurEFD:CodCon())
						cChave	 :=	oApurEFD:BuscaChave()
						nBsReduz := Iif(SFT->FT_CSTPIS=='05',Round(SFT->FT_BASEPS3*nPercDevP,2),Round(SFT->FT_BASEPIS*nPercDevP,2))
						nVlReduz := Iif(SFT->FT_CSTPIS=='05',Round(SFT->FT_VALPS3*nPercDevP,2),Round(SFT->FT_VALPIS*nPercDevP,2))
						oApurEFD:ReduzBase(nBsReduz,nVlReduz,DEBITO,cChave, SFT->FT_CSTPIS,SFT->FT_CODBCC,Iif(SFT->FT_PAUTPIS > 0,'1','2'))
						oApurEFD:ReduzCL0(nBsReduz,Round(SFT->FT_VALCONT*nPercDevP,2))

						If lMoto
							oApurEFD:SetCST("01")
							oApurEFD:SetCodDC(oApurEFD:CodCon())
							cChave	:=	oApurEFD:BuscaChave()
							oApurEFD:ReduzBase(Round(SFT->FT_BASEPIS*nPercDevP,2),Round(SFT->FT_VALPIS*nPercDevP,2),DEBITO,cChave, '01',SFT->FT_CODBCC,Iif(SFT->FT_PAUTPIS > 0,'1','2'))
							oApurEFD:ReduzCL0(Round(SFT->FT_BASEPIS*nPercDevP,2),Round(SFT->FT_VALCONT*nPercDevP,2))
						EndIf

						//PROCESSA ESTORNO DA COFINS
						oApurEFD:SetTributo(COFINS)
						oApurEFD:SetAlqTrib(SFT->FT_ALIQCOF)
						oApurEFD:SetAlqSt(SFT->FT_ALIQCF3)
						oApurEFD:SetCST(SFT->FT_CSTCOF)
						//Verifica se documento original é Cupom Fiscal
						If !Empty(SFT->FT_PDV) .AND. AllTrim(SFT->FT_ESPECIE)$"CF/ECF"
							oApurEFD:SetOrigem(CUPOM)
						Else
							oApurEFD:SetOrigem(FISCALSAI)
						EndIF
						oApurEFD:SetTpReg(cRegDev)
						oApurEFD:DefRegime()
						oApurEFD:SetCodDC(oApurEFD:CodCon())
						cChave	:=	oApurEFD:BuscaChave()
						nBsReduz := Iif(SFT->FT_CSTCOF=='05',Round(SFT->FT_BASECF3*nPercDevP,2),Round(SFT->FT_BASECOF*nPercDevP,2))
						nVlReduz := Iif(SFT->FT_CSTCOF=='05',Round(SFT->FT_VALCF3*nPercDevP,2),Round(SFT->FT_VALCOF*nPercDevP,2))
						oApurEFD:ReduzBase(nBsReduz,nVlReduz,DEBITO,cChave,  SFT->FT_CSTCOF ,SFT->FT_CODBCC,Iif(SFT->FT_PAUTCOF > 0,'1','2'))
						//oApurEFD:ReduzCL0(Round(SFT->FT_BASECOF*nPercDevP,2),Round(SFT->FT_VALCONT*nPercDevP,2))

						If lMoto
							oApurEFD:SetCST("01")
							oApurEFD:SetCodDC(oApurEFD:CodCon())
							cChave	:=	oApurEFD:BuscaChave()
							oApurEFD:ReduzBase(Round(SFT->FT_BASECOF*nPercDevP,2),Round(SFT->FT_VALCOF*nPercDevP,2),DEBITO,cChave, '01' ,SFT->FT_CODBCC,Iif(SFT->FT_PAUTCOF > 0,'1','2'))
						EndIf

						//Aqui será efetuado a dedução da CPRB, referente a parcela de receitas de consórcios cadastrados na rotina demais documentos
						IF lCPRBNF .AND. !Empty((cAliasSFT)->FT_ATIVCPB) .AND. (cAliasSFT)->FT_BASECPB >0 .AND. (cAliasSFT)->FT_ALIQCPB > 0

							//Verifica parâmetro para definir se utilizará código de serviço ou de outros serviços.
							cCodRec := Iif(AllTrim((cAliasSFT)->FT_ATIVCPB)$ cSPCBPSE ,mv_par16 ,mv_par17 )

							oCPRB:= CPRBEFD():New()
							oCPRB:SetCodRec(cCodRec)
							oCPRB:SetDtIni(dDataDe)
							oCPRB:SetFilApu(FWGETCODFILIAL)
							//Preciso passar a somatoria do valor do ipi e St para que a dedução de base de CPRB nao fique com valores incorretos no tocante as tabelas CKV e CKX.
							oCPRB:DeduzBase((cAliasSFT)->FT_ATIVCPB,(cAliasSFT)->FT_ALIQCPB,(cAliasSFT)->FT_BASECPB,(cAliasSFT)->FT_VALCONT, (cAliasSFT)->FT_VALIPI + (cAliasSFT)->FT_ICMSRET )
							FreeObj(oCPRB)
							oCPRB:= nil

						EndIF

					ElseIf cTpMov == 'E' .AND. cRegime $ '1/4'

						oApurEFD:Clear()

						oApurEFD:SetTributo(PIS)
						oApurEFD:SetAlqTrib(SFT->FT_ALIQPIS-SFT->FT_MALQPIS)
						oApurEFD:SetOrigem(FISCALENT)
						oApurEFD:SetTpReg(NAOCUMULAT)
						oApurEFD:SetCST(SFT->FT_CSTPIS)
						oApurEFD:SetCodBcc(SFT->FT_CODBCC)
						oApurEFD:SetPauta(Iif(SFT->FT_PAUTPIS > 0 ,'1' ,'' ))
						oApurEFD:SetImport(IIF(SubStr(SFT->FT_CFOP,1,1) == '3' ,.T.,.F. ))
						oApurEFD:SetAlqBas(Iif(SFT->FT_ALIQPIS == 0.65 .OR. SFT->FT_ALIQPIS == 1.65 ,'1' ,'2'))
						oApurEFD:SetTNatRec(SFT->FT_TNATREC)
						oApurEFD:SetCNatRec(SFT->FT_CNATREC)
						oApurEFD:SetGNatRec(SFT->FT_GRUPONC)
						oApurEFD:SetDNatRec(SFT->FT_DTFIMNT)
						oApurEFD:DefRegime()

						oApurEFD:ReduzCL0(Round(SFT->FT_BASEPIS*nPercDevP,2),Round(SFT->FT_VALCONT*nPercDevP,2))

						// Tributado no mercado interno 
						If SFT->FT_CSTPIS $ '50|60|53|63|54|64|56|66'
							oApurEFD:SetCodDC('1' + oApurEFD:CodCred())
							cChave	:=	oApurEFD:BuscaChave()
							nBseTot := Round(SFT->FT_BASEPIS * nPercDevP, 2)
							nValCrd := Round((SFT->FT_VALPIS-SFT->FT_MVALPIS) * nPercDevP * oApurEFD:CalcBAseRC('1'), 2)
							nBseProp := Round(SFT->FT_BASEPIS * nPercDevP * oApurEFD:CalcBAseRC('1'), 2) // Base proporcional vinculada ao tipo de credito.
							oApurEFD:ReduzBase(nBseTot,nValCrd,CREDITO,cChave,SFT->FT_CSTPIS,SFT->FT_CODBCC,Iif(SFT->FT_PAUTPIS > 0,'1','2'),nBseProp)
						EndIF

						// Não Tributado no mercado interno
						If SFT->FT_CSTPIS $ '51|61|53|63|55|65|56|66'
							oApurEFD:SetCodDC('2' + oApurEFD:CodCred())
							cChave	:=	oApurEFD:BuscaChave()
							nBseTot := Round(SFT->FT_BASEPIS * nPercDevP, 2)
							nValCrd := Round((SFT->FT_VALPIS-SFT->FT_MVALPIS) * nPercDevP * oApurEFD:CalcBAseRC('2'), 2)
							nBseProp := Round(SFT->FT_BASEPIS * nPercDevP * oApurEFD:CalcBAseRC('2'), 2) // Base proporcional vinculada ao tipo de credito.
							oApurEFD:ReduzBase(nBseTot,nValCrd,CREDITO,cChave,SFT->FT_CSTPIS,SFT->FT_CODBCC,Iif(SFT->FT_PAUTPIS > 0,'1','2'),nBseProp)
						EndIF

						// Exportacao
						If SFT->FT_CSTPIS $ '52|62|54|64|55|65|56|66'
							oApurEFD:SetCodDC('3' + oApurEFD:CodCred())
							cChave	:=	oApurEFD:BuscaChave()
							nBseTot := Round(SFT->FT_BASEPIS * nPercDevP, 2)
							nValCrd := Round((SFT->FT_VALPIS-SFT->FT_MVALPIS) * nPercDevP * oApurEFD:CalcBAseRC('3'), 2)
							nBseProp := Round(SFT->FT_BASEPIS * nPercDevP * oApurEFD:CalcBAseRC('3'), 2) // Base proporcional vinculada ao tipo de credito.
							oApurEFD:ReduzBase(nBseTot,nValCrd,CREDITO,cChave,SFT->FT_CSTPIS,SFT->FT_CODBCC,Iif(SFT->FT_PAUTPIS > 0,'1','2'),nBseProp)
						EndIF

						oApurEFD:SetTributo(COFINS)
						oApurEFD:SetAlqTrib(SFT->FT_ALIQCOF-SFT->FT_MALQCOF)
						oApurEFD:SetOrigem(FISCALENT)
						oApurEFD:SetTpReg(NAOCUMULAT)
						oApurEFD:SetCST(SFT->FT_CSTCOF)
						oApurEFD:SetCodBcc(SFT->FT_CODBCC)
						oApurEFD:SetPauta(Iif(SFT->FT_PAUTCOF > 0 ,'1' ,'' ))
						oApurEFD:SetImport(IIF(SubStr(SFT->FT_CFOP,1,1) == '3' ,.T.,.F. ))
						oApurEFD:SetAlqBas(Iif(SFT->FT_ALIQCOF == 3 .OR. SFT->FT_ALIQCOF == 7.6 ,'1' ,'2'))
						oApurEFD:SetTNatRec(SFT->FT_TNATREC)
						oApurEFD:SetCNatRec(SFT->FT_CNATREC)
						oApurEFD:SetGNatRec(SFT->FT_GRUPONC)
						oApurEFD:SetDNatRec(SFT->FT_DTFIMNT)
						oApurEFD:DefRegime()

						//oApurEFD:ReduzCL0(Round(SFT->FT_BASECOF*nPercDevP,2),Round(SFT->FT_VALCONT*nPercDevP,2))

						// Tributado no mercado interno
						If SFT->FT_CSTCOF $ '50|60|53|63|54|64|56|66'
							oApurEFD:SetCodDC('1' + oApurEFD:CodCred())
							cChave	:=	oApurEFD:BuscaChave()
							nBseTot := Round(SFT->FT_BASECOF * nPercDevP, 2)
							nValCrd := Round((SFT->FT_VALCOF-SFT->FT_MVALCOF) * nPercDevP * oApurEFD:CalcBAseRC('1'), 2)
							nBseProp := Round(SFT->FT_BASECOF * nPercDevP * oApurEFD:CalcBAseRC('1'), 2) // Base proporcional vinculada ao tipo de credito.
							oApurEFD:ReduzBase(nBseTot,nValCrd,CREDITO,cChave,SFT->FT_CSTCOF,SFT->FT_CODBCC,Iif(SFT->FT_PAUTCOF > 0,'1','2'),nBseProp)
						EndIF

						// Não Tributado no mercado interno
						If SFT->FT_CSTCOF $ '51|61|53|63|55|65|56|66'
							oApurEFD:SetCodDC('2' + oApurEFD:CodCred())
							cChave	:=	oApurEFD:BuscaChave()
							nBseTot := Round(SFT->FT_BASECOF * nPercDevP, 2)
							nValCrd := Round((SFT->FT_VALCOF-SFT->FT_MVALCOF) * nPercDevP * oApurEFD:CalcBAseRC('2'), 2)
							nBseProp := Round(SFT->FT_BASECOF * nPercDevP * oApurEFD:CalcBAseRC('2'), 2) // Base proporcional vinculada ao tipo de credito.
							oApurEFD:ReduzBase(nBseTot,nValCrd,CREDITO,cChave,SFT->FT_CSTCOF,SFT->FT_CODBCC,Iif(SFT->FT_PAUTCOF > 0,'1','2'),nBseProp)
						EndIF

						// Exportacao
						If SFT->FT_CSTCOF $ '52|62|54|64|55|65|56|66'
							oApurEFD:SetCodDC('3' + oApurEFD:CodCred())
							cChave	:=	oApurEFD:BuscaChave()
							nBseTot := Round(SFT->FT_BASECOF * nPercDevP, 2)
							nValCrd := Round((SFT->FT_VALCOF-SFT->FT_MVALCOF) * nPercDevP * oApurEFD:CalcBAseRC('3'), 2)
							nBseProp := Round(SFT->FT_BASECOF * nPercDevP * oApurEFD:CalcBAseRC('3'), 2) // Base proporcional vinculada ao tipo de credito.
							oApurEFD:ReduzBase(nBseTot,nValCrd,CREDITO,cChave,SFT->FT_CSTCOF,SFT->FT_CODBCC,Iif(SFT->FT_PAUTCOF > 0,'1','2'),nBseProp)
						EndIF

						oApurEFD:SetImport(.F.)

					EndIF

				EndIF

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Devolucao em outro periodo  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Else
				If cTpMov == "E" .AND. !lPerAtu

					cDescr	:=  "Dev. comp. ref. doc.:" + AllTrim(SFT->FT_NFISCAL) + ",série:" + AllTrim(SFT->FT_SERIE)
					cDescr +=  ",item:" + AllTrim(SFT->FT_ITEM) + ", Filial:" + SFT->FT_FILIAL  +",Doc. Dev.:" + AllTrim((cAliasSFT)->FT_NFISCAL)
					cDescr +=  ",série:" + AllTrim((cAliasSFT)->FT_SERIE) + ", item:" + Alltrim((cAliasSFT)->FT_ITEM)

					//------------------------------------------------
					//PASSA INFORMAÇÕES PARA OBTER O CÓDIGO DO CRÉDITO
					//------------------------------------------------
					oApurEFD:SetCST(SFT->FT_CSTPIS)
					oApurEFD:SetCodBcc(SFT->FT_CODBCC)
					oApurEFD:SetPauta(Iif(SFT->FT_PAUTPIS > 0 ,'1' ,'' ))
					oApurEFD:SetImport(IIF(SubStr(SFT->FT_CFOP,1,1) == '3' ,.T.,.F. ))
					oApurEFD:SetAlqBas(Iif(SFT->FT_ALIQPIS == 0.65 .OR. SFT->FT_ALIQPIS == 1.65 ,'1' ,'2'))
					oApurEFD:SetTNatRec(SFT->FT_TNATREC)
					oApurEFD:SetCNatRec(SFT->FT_CNATREC)
					oApurEFD:SetGNatRec(SFT->FT_GRUPONC)
					oApurEFD:SetDNatRec(SFT->FT_DTFIMNT)
					oApurEFD:SetQtde(SFT->FT_QUANT)
					oApurEFD:SetVlPauta(SFT->FT_PAUTPIS)

					//Considera alíquota e base de cálculo considerando cálculo alíquota com percentual
					nBaseCalc	:= SFT->FT_BASEPIS
					nAlq		:= SFT->FT_ALIQPIS

					If oApurEFD:OperPauta(lSPDPIS10,cAliasSFT)
						//Busca a base de cálculo e alíquota em quantidade convertida em quantidade e em reais respectivamente
						nBaseCalc	:= oApurEFD:GetBcTrib()
						nAlq		:= oApurEFD:GetAlqTrib()
					EndIF
					cCodCred := oApurEFD:CodCred()

					//---------------------
					//FAZ OS AJUSTES DE PIS
					//---------------------
					oAjuCred:SetTributo(PIS)
					oAjuCred:SetTpAjust(REDUCAO)
					oAjuCred:SetCodAju('06')
					oAjuCred:SetNumDoc(SFT->FT_NFISCAL)
					oAjuCred:SetDescAju(cDescr)
					oAjuCred:SetDtRefer((cAliasSFT)->FT_ENTRADA)
					oAjuCred:SetOrigem('C') //Devolução de compra de período anterior		 //ok
					oAjuCred:SetNumDev((cAliasSFT)->FT_NFISCAL)
					oAjuCred:SetNumOri(SFT->FT_NFISCAL)
					oAjuCred:SetCst(SFT->FT_CSTPIS)
					oAjuCred:SetCodBcc(SFT->FT_CODBCC)
					oAjuCred:SetConta(SFT->FT_CONTA)
					oAjuCred:SetInfComp('Ajuste de redução de crédito de PIS em função da devolução de compra de período anterior')
					oAjuCred:SetAlq(nAlq)

					//-----------------------------------------------------
					//FAZ AJUSTE COM CÓDIGO DE TRIBUTADO NO MERCADO INTERNO
					//-----------------------------------------------------
					If SFT->FT_CSTPIS $ '50|60|53|63|54|64|56|66'
						oAjuCred:SetCodDC('1'+cCodCred)
						oAjuCred:SetVlAju( Round(SFT->FT_VALPIS*nPercDevP * oApurEFD:CalcBAseRC('1'),2))
						oAjuCred:SetBase(Round(nBaseCalc * nPercDevP * oApurEFD:CalcBAseRC('1'),2))
						oAjuCred:Ajustar()
					EndIF

					//---------------------------------------------------------
					//FAZ AJUSTE COM CÓDIGO DE NÃO TRIBUTADO NO MERCADO INTERNO
					//---------------------------------------------------------
					If SFT->FT_CSTPIS $ '51|61|53|63|55|65|56|66'
						oAjuCred:SetCodDC('2'+cCodCred)
						oAjuCred:SetVlAju( Round(SFT->FT_VALPIS*nPercDevP * oApurEFD:CalcBAseRC('2'),2))
						oAjuCred:SetBase(Round(nBaseCalc * nPercDevP * oApurEFD:CalcBAseRC('2'),2))
						oAjuCred:Ajustar()
					EndIF

					//--------------------------------
					//FAZ AJUSTE COM CÓDIGO EXPORTAÇÃO
					//--------------------------------
					If SFT->FT_CSTPIS $ '52|62|54|64|55|65|56|66'
						oAjuCred:SetCodDC('3'+cCodCred)
						oAjuCred:SetVlAju( Round(SFT->FT_VALPIS*nPercDevP * oApurEFD:CalcBAseRC('3'),2))
						oAjuCred:SetBase(Round(nBaseCalc * nPercDevP * oApurEFD:CalcBAseRC('3'),2))
						oAjuCred:Ajustar()
					EndIF

					//--------------------------------------------------------
					//PASSA INFORMAÇÕES PARA OBTER CÓDIGO DE CRÉDITO DA COFINS
					//--------------------------------------------------------
					oApurEFD:SetCST(SFT->FT_CSTCOF)
					oApurEFD:SetCodBcc(SFT->FT_CODBCC)
					oApurEFD:SetPauta(Iif(SFT->FT_PAUTCOF > 0 ,'1' ,'' ))
					oApurEFD:SetImport(IIF(SubStr(SFT->FT_CFOP,1,1) == '3' ,.T.,.F. ))
					oApurEFD:SetAlqBas(Iif(SFT->FT_ALIQCOF == 3 .OR. SFT->FT_ALIQCOF == 7.6 ,'1' ,'2'))
					oApurEFD:SetTNatRec(SFT->FT_TNATREC)
					oApurEFD:SetCNatRec(SFT->FT_CNATREC)
					oApurEFD:SetGNatRec(SFT->FT_GRUPONC)
					oApurEFD:SetDNatRec(SFT->FT_DTFIMNT)
					oApurEFD:SetQtde(SFT->FT_QUANT)
					oApurEFD:SetVlPauta(SFT->FT_PAUTCOF)

					//Considera alíquota e base de cálculo considerando cálculo alíquota com percentual
					nBaseCalc	:= SFT->FT_BASECOF
					nAlq		:= SFT->FT_ALIQCOF

					If oApurEFD:OperPauta(lSPDPIS10,cAliasSFT)
						//Busca a base de cálculo e alíquota em quantidade convertida em quantidade e em reais respectivamente
						nBaseCalc	:= oApurEFD:GetBcTrib()
						nAlq		:= oApurEFD:GetAlqTrib()
					EndIF
					cCodCred := oApurEFD:CodCred()

					//------------------------
					//REALIZA AJUSTE DA COFINS
					//------------------------
					oAjuCred:SetTributo(COFINS)
					oAjuCred:SetTpAjust(REDUCAO)
					oAjuCred:SetCodAju('06')
					oAjuCred:SetNumDoc(SFT->FT_NFISCAL)
					oAjuCred:SetDescAju(cDescr)
					oAjuCred:SetDtRefer((cAliasSFT)->FT_ENTRADA)
					oAjuCred:SetOrigem('C') //Devolução de compra de período anterior		 //ok
					oAjuCred:SetNumDev((cAliasSFT)->FT_NFISCAL)
					oAjuCred:SetNumOri(SFT->FT_NFISCAL)

					//---------------------------------------------------------
					//DETALHAMENTO DOS AJUSTES COM INFORMAÇÕES DA NOTA ORIGINAL
					//---------------------------------------------------------
					oAjuCred:SetCst(SFT->FT_CSTCOF)
					oAjuCred:SetCodBcc(SFT->FT_CODBCC)
					oAjuCred:SetConta(SFT->FT_CONTA)
					oAjuCred:SetInfComp('Ajuste de redução de crédito de COFINS em função de devolução de compra de período anterior')
					oAjuCred:SetAlq(nAlq)

					//-----------------------------------------------------
					//FAZ AJUSTE COM CÓDIGO DE TRIBUTADO NO MERCADO INTERNO
					//-----------------------------------------------------
					If SFT->FT_CSTCOF $ '50|60|53|63|54|64|56|66'
						oAjuCred:SetCodDC('1'+cCodCred)
						oAjuCred:SetVlAju( Round(SFT->FT_VALCOF*nPercDevP * oApurEFD:CalcBAseRC('1'),2))
						oAjuCred:SetBase(Round(nBaseCalc * nPercDevP * oApurEFD:CalcBAseRC('1'),2))
						oAjuCred:Ajustar()
					EndIF

					//---------------------------------------------------------
					//FAZ AJUSTE COM CÓDIGO DE NÃO TRIBUTADO NO MERCADO INTERNO
					//---------------------------------------------------------
					If SFT->FT_CSTCOF $ '51|61|53|63|55|65|56|66'
						oAjuCred:SetCodDC('2'+cCodCred)
						oAjuCred:SetVlAju( Round(SFT->FT_VALCOF*nPercDevP * oApurEFD:CalcBAseRC('2'),2))
						oAjuCred:SetBase(Round(nBaseCalc * nPercDevP * oApurEFD:CalcBAseRC('2'),2))
						oAjuCred:Ajustar()
					EndIF

					//--------------------------------
					//FAZ AJUSTE COM CÓDIGO EXPORTAÇÃO
					//--------------------------------
					If SFT->FT_CSTCOF $ '52|62|54|64|55|65|56|66'
						oAjuCred:SetCodDC('3'+cCodCred)
						oAjuCred:SetVlAju( Round(SFT->FT_VALCOF*nPercDevP * oApurEFD:CalcBAseRC('3'),2))
						oAjuCred:SetBase(Round(nBaseCalc * nPercDevP * oApurEFD:CalcBAseRC('3'),2))
						oAjuCred:Ajustar()
					EndIF

					oApurEFD:SetImport(.F.)

				ElseIf cTpMov == 'S' .AND. !lPerAtu .AND. ;
						(cOpAju == "1" .Or. (cOpAju == "2" .AND. SFT->FT_CSTCOF == "03")  .Or. (cOpAju == "3" .AND. SFT->FT_CSTCOF <> "03"))

					cDescr	:=  "Dev. venda. ref. doc.:" + AllTrim(SFT->FT_NFISCAL) + ",série:" + AllTrim(SFT->FT_SERIE)
					cDescr +=  ",item:" + AllTrim(SFT->FT_ITEM) + ", Filial:" + SFT->FT_FILIAL  +",Doc. Dev.:" + AllTrim((cAliasSFT)->FT_NFISCAL)
					cDescr +=  ",série:" + AllTrim((cAliasSFT)->FT_SERIE) + ", item:" + Alltrim((cAliasSFT)->FT_ITEM)

					//Passa o regime da operação
					oApurEFD:SetTpReg(cRegDev)
					//Chama método para classe definir o regime
					oApurEFD:DefRegime()

					//Passa CSTde PIS para classe
					oApurEFD:SetCST(SFT->FT_CSTPIS)
					//Pega código da contribuição processada pela classe
					oApurEFD:SetAlqSt(SFT->FT_ALIQPS3)
					cCodCon:=oApurEFD:CodCon()
					oApurEFD:SetTNatRec(SFT->FT_TNATREC)
					oApurEFD:SetCNatRec(SFT->FT_CNATREC)
					oApurEFD:SetGNatRec(SFT->FT_GRUPONC)
					oApurEFD:SetDNatRec(SFT->FT_DTFIMNT)
					oApurEFD:SetQtde(SFT->FT_QUANT)
					oApurEFD:SetVlPauta(SFT->FT_PAUTPIS)

					//Considera alíquota e base de cálculo considerando cálculo alíquota com percentual
					nBaseCalc	:= Iif(SFT->FT_CSTPIS=='05',SFT->FT_BASEPS3,SFT->FT_BASEPIS)
					nAlq		:= Iif(SFT->FT_CSTPIS=='05',SFT->FT_ALIQPS3,SFT->FT_ALIQPIS)
					nValorAj	:= Iif(SFT->FT_CSTPIS=='05',SFT->FT_VALPS3,SFT->FT_VALPIS)

					If oApurEFD:OperPauta(lSPDPIS10,cAliasSFT)
						//Busca a base de cálculo e alíquota em quantidade convertida em quantidade e em reais respectivamente
						nBaseCalc	:= oApurEFD:GetBcTrib()
						nAlq		:= oApurEFD:GetAlqTrib()
					EndIF

					If cRegime == "3"
						//Caso seja regime de caixa, eu mudo a base de cálculo para o valor baixado do título
						nBaseCalc	:= (cAliasSFT)->E5_VALOR
						nValorAj	:= (((cAliasSFT)->E5_VALOR * nAlq) / 100)
					EndIf

					//Realiza Ajuste para o PIS
					oAjuDeb:SetTributo(PIS)
					oAjuDeb:SetTpAjust(REDUCAO)
					oAjuDeb:SetCodAju('06')
					oAjuDeb:SetNumDoc((cAliasSFT)->FT_NFISCAL)
					oAjuDeb:SetDescAju(cDescr)
					oAjuDeb:SetDtRefer((cAliasSFT)->FT_ENTRADA)
					oAjuDeb:SetCodDC(cCodCon)
					oAjuDeb:SetRegime(cRegDev)
					oAjuDeb:SetOrigem(cOrigem)
					If lAjBase
						oAjuDeb:SetVlAju(IIf(SFT->FT_QUANT==(cAliasSFT)->FT_QUANT, nBaseCalc, (cAliasSFT)->FT_QUANT * (nBaseCalc/SFT->FT_QUANT)))
					Else
						oAjuDeb:SetVlAju(IIf(SFT->FT_QUANT==(cAliasSFT)->FT_QUANT, nValorAj, (cAliasSFT)->FT_QUANT*nValorAj/SFT->FT_QUANT))
					EndIf

					oAjuDeb:SetNumDev((cAliasSFT)->FT_NFISCAL)
					oAjuDeb:SetNumOri(SFT->FT_NFISCAL)
					oAjuDeb:SetCst(SFT->FT_CSTCOF)
					oAjuDeb:SetConta(SFT->FT_CONTA)
					oAjuDeb:SetInfComp('Ajuste de redução de débito de PIS em função de retorno de mercadoria vendida em período anterior')
					oAjuDeb:SetBase(Round(nBaseCalc*nPercDevP,2))
					oAjuDeb:SetAlq(nAlq)
					oAjuDeb:SetTNatRec(SFT->FT_TNATREC)
					oAjuDeb:SetCNatRec(SFT->FT_CNATREC)
					oAjuDeb:SetAjuBase(.F.)

					If cOpAju == "3"
						//Ajustes de base de cálculo
						oAjuCred:SetOrigem('A') //Ajuste de base de cálculo
						oAjuDeb:SetCNPJ(SM0->M0_CGC)
						oAjuDeb:SetCodAju('02')
						oAjuDeb:SetAjuBase(.T.)
					EndIF

					oAjuDeb:Ajustar()

					If lMoto
						oApurEFD:SetCST("01")
						cCodCon:=oApurEFD:CodCon()
						oAjuDeb:SetVlAju(IIf(SFT->FT_QUANT==(cAliasSFT)->FT_QUANT, SFT->FT_VALPIS, (cAliasSFT)->FT_QUANT*(SFT->FT_VALPIS)/SFT->FT_QUANT))
						oAjuDeb:SetBase(Round(SFT->FT_BASEPIS*nPercDevP,2))
						oAjuDeb:SetCst('01')
						oAjuDeb:SetCodDC(cCodCon)
						oAjuDeb:Ajustar()
					EndIf

					//Processa código da ~contribuição da COFINS
					oApurEFD:SetCST(SFT->FT_CSTCOF)
					//Pega código da contribuição processada pela classe
					oApurEFD:SetAlqSt(SFT->FT_ALIQCF3)
					cCodCon:=oApurEFD:CodCon()
					oApurEFD:SetTNatRec(SFT->FT_TNATREC)
					oApurEFD:SetCNatRec(SFT->FT_CNATREC)
					oApurEFD:SetGNatRec(SFT->FT_GRUPONC)
					oApurEFD:SetDNatRec(SFT->FT_DTFIMNT)
					oApurEFD:SetQtde(SFT->FT_QUANT)
					oApurEFD:SetVlPauta(SFT->FT_PAUTCOF)

					//Considera alíquota e base de cálculo considerando cálculo alíquota com percentual
					nBaseCalc	:= Iif(SFT->FT_CSTPIS=='05',SFT->FT_BASECF3,SFT->FT_BASECOF)
					nAlq		:= Iif(SFT->FT_CSTPIS=='05',SFT->FT_ALIQCF3,SFT->FT_ALIQCOF)
					nValorAj	:= Iif(SFT->FT_CSTPIS=='05',SFT->FT_VALCF3,SFT->FT_VALCOF)


					If oApurEFD:OperPauta(lSPDPIS10,cAliasSFT)
						//Busca a base de cálculo e alíquota em quantidade convertida em quantidade e em reais respectivamente
						nBaseCalc	:= oApurEFD:GetBcTrib()
						nAlq		:= oApurEFD:GetAlqTrib()
					EndIF

					If cRegime == "3"
						//Caso seja regime de caixa, eu mudo a base de cálculo para o valor baixado do título
						nBaseCalc	:= (cAliasSFT)->E5_VALOR
						nValorAj	:= (((cAliasSFT)->E5_VALOR * nAlq) / 100)
					EndIf

					//todo ajuste da base de cálculo

					//Realiza Ajuste para a COFINS
					oAjuDeb:SetTributo(COFINS)
					oAjuDeb:SetTpAjust(REDUCAO)
					oAjuDeb:SetCodAju('06')
					oAjuDeb:SetNumDoc((cAliasSFT)->FT_NFISCAL)
					oAjuDeb:SetDescAju(cDescr)
					oAjuDeb:SetDtRefer((cAliasSFT)->FT_ENTRADA)
					oAjuDeb:SetCodDC(cCodCon)
					oAjuDeb:SetRegime(cRegDev)
					oAjuDeb:SetOrigem(cOrigem)
					If lAjBase
						oAjuDeb:SetVlAju(IIf(SFT->FT_QUANT==(cAliasSFT)->FT_QUANT, nBaseCalc, (cAliasSFT)->FT_QUANT * (nBaseCalc/SFT->FT_QUANT)))
					Else
						oAjuDeb:SetVlAju(IIf(SFT->FT_QUANT==(cAliasSFT)->FT_QUANT, nValorAj, (cAliasSFT)->FT_QUANT*nValorAj/SFT->FT_QUANT))
					EndIf

					oAjuDeb:SetNumDev((cAliasSFT)->FT_NFISCAL)
					oAjuDeb:SetNumOri(SFT->FT_NFISCAL)
					oAjuDeb:SetCst(SFT->FT_CSTCOF)
					oAjuDeb:SetConta(SFT->FT_CONTA)
					oAjuDeb:SetInfComp('Ajuste de redução de débito de COFINS em função de retorno de mercadoria vendida em período anterior')
					oAjuDeb:SetBase(Round(nBaseCalc*nPercDevP,2))
					oAjuDeb:SetAlq(nAlq)
					oAjuDeb:SetTNatRec(SFT->FT_TNATREC)
					oAjuDeb:SetCNatRec(SFT->FT_CNATREC)
					oAjuDeb:SetAjuBase(.F.)

					If cOpAju == "3"
						//Ajustes de base de cálculo
						oAjuDeb:SetCNPJ(SM0->M0_CGC)
						oAjuDeb:SetCodAju('02')
						oAjuDeb:SetAjuBase(.T.)
					EndIF

					oAjuDeb:Ajustar()

					If lMoto
						oApurEFD:SetCST("01")
						cCodCon:=oApurEFD:CodCon()
						oAjuDeb:SetVlAju(IIf(SFT->FT_QUANT==(cAliasSFT)->FT_QUANT,SFT->FT_VALCOF, (cAliasSFT)->FT_QUANT*(SFT->FT_VALCOF)/SFT->FT_QUANT))
						oAjuDeb:SetBase(Round(SFT->FT_BASECOF*nPercDevP,2))
						oAjuDeb:SetCst('01')
						oAjuDeb:SetCodDC(cCodCon)
						oAjuDeb:Ajustar()
					EndIf

					//Realiza Ajustes da CPRB
					If lCPRBNF .And. SFT->FT_VALCPB > 0
						lAtuCPRB	:= .T.
						oCPRB:SetCodRec(Iif(AllTrim((cAliasSFT)->FT_ATIVCPB)$cSPCBPSE,mv_par16,mv_par17))
						oCPRB:SetTpAju(REDUCAO)
						oCPRB:SetValAju(IIf(SFT->FT_QUANT==(cAliasSFT)->FT_QUANT,SFT->FT_VALCPB,(cAliasSFT)->FT_QUANT*SFT->FT_VALCPB/SFT->FT_QUANT))
						oCPRB:SetCodAjus('06')
						oCPRB:SetNumero((cAliasSFT)->FT_NFISCAL)
						oCPRB:SetDescr("Devolução da nota fiscal " + SFT->FT_NFISCAL)
						oCPRB:SetDtRefer((cAliasSFT)->FT_ENTRADA)
						oCPRB:GravaAju()
						oCPRB:AtualizaCPRB()
						oCPRB:Clear()
					Endif
				Endif
			Endif
		Endif
		RestArea (aAreaSFT)
		(cAliasSFT)->(DbSkip())
	EndDo

	oAjuDeb:FechaAlias(cAliasSFT)
	//Chama função para poder buscar possíveis saldos de deduções
	//de período anterior para deduzir o débito do período atual.

	If !lPerAtu .AND. cOpAju <> "3"
		ASA001DANT(dDataDe,oAjuDeb,oAjuCred,cTpMov,aXFilial,cOpAju)
	EndIf

	FreeObj(oAjuDeb)
	FreeObj(oApurEFD)
	FreeObj(oAjuCred)
	FreeObj(ojQntDevol)	
	oAjuDeb 	:= Nil
	oApurEFD	:= Nil
	oAjuCred	:= Nil
	ojQntDevol	:= Nil

	If lCPRBNF
		FreeObj(oCPRB)
		oCPRB := Nil
	Endif

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} ASA001DANT()
Função que irá buscar na tabela CF3 saldos de duções ou ajustes
de períodos anteriores, e fazer o devido ajuste no processamento
atual.

As SALDODED irá fazer o controle se o saldo foi totalmente consumido ou
não, e irá automaticamente atualizar a tabela de saldo com os valores
atualizados.

@param	 	dDataDe 	 - Data inicial do processamento
			oAjuDeb	 - Objeto de ajuste de débito
			oAjuCred    - Objeto de ajuste de crédito
			cTpMov   	 - Tipo de movimento entrada/saída
			aXFilial 	 - Conteúdo xFilial das tabelas de apuração. 
		
@author Erick G. Dias
@since 10/07/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function ASA001DANT(dDataDe,oAjuDeb,oAjuCred,cTpMov,aXFilial,cOpAju)

	Local oSaldoDed
	Local cAliasCF3	:= ''
	Local cDescr	:= ''
	Local cDescPis := ''
	Local cDescCof := ''
	Local oDebito
	Local lConta := Iif(('CF3')->(FieldPos("CF3_CONTA")) > 0, .T., .F.)

	oSaldoDed	:= 	SALDODED():New()
	oSaldoDed:SetFilial(aXFilial)
	oSaldoDed:SetDtIni(dDataDe)
	oSaldoDed:SetPerOri(dDataDe)

	If cTpMov == 'S' .AND. cOpAju $ "1/2"
		//CARREGA as deduções de débito de período anterior
		cAliasCF3	:= oSaldoDed:LoadDedAnt('E')

		DbSelectArea (cAliasCF3)
		(cAliasCF3)->(DbGoTop ())
		Do While !(cAliasCF3)->(Eof ())

			//Realiza os ajustes de redução do débito.
			//Realizado somente para as operações Exclusivamente CUmulativas, pois no regime Não Cumulativo
			//As devoluções de venda dão direito ao crédito.
			cDescr	:= STR0079 +  (cAliasCF3)->CF3_NFORI // "Devolução da nota fiscal "
			oAjuDeb:SetTributo(PIS)
			oAjuDeb:SetTpAjust(REDUCAO)
			oAjuDeb:SetCodAju('06')
			oAjuDeb:SetNumDoc((cAliasCF3)->CF3_NFDEV)
			oAjuDeb:SetDescAju(cDescr)
			oAjuDeb:SetDtRefer((cAliasCF3)->CF3_PERORI)
			oAjuDeb:SetMsmCod(.F.) // Com este parâmetro com .F. não irá efetuar o ajuste exatamente no mesmo código
			oAjuDeb:SetRegime(CUMULAT)
			oAjuDeb:SetOrigem('E')
			oAjuDeb:SetVlAju((cAliasCF3)->CF3_VLRPIS)
			oAjuDeb:SetNumDev((cAliasCF3)->CF3_NFDEV)
			oAjuDeb:SetNumOri((cAliasCF3)->CF3_NFORI)
			If lConta
				oAjuDeb:SetConta((cAliasCF3)->CF3_CONTA)
			EndIf
			oAjuDeb:SetInfComp('Ajuste de Redução da Contribuição, referente a Redução de período anterior não realizado, em função de não ter Contribuição suficiente para ser reduzido.')
			oAjuDeb:Ajustar()

			//Realiza Ajuste para a COFINS
			oAjuDeb:SetTributo(COFINS)
			oAjuDeb:SetTpAjust(REDUCAO)
			oAjuDeb:SetCodAju('06')
			oAjuDeb:SetNumDoc((cAliasCF3)->CF3_NFDEV)
			oAjuDeb:SetDescAju(cDescr)
			oAjuDeb:SetDtRefer((cAliasCF3)->CF3_PERORI)
			oAjuDeb:SetMsmCod(.F.) // Com este parâmetro com .F. não irá efetuar o ajuste exatamente no mesmo código
			oAjuDeb:SetRegime(CUMULAT)
			oAjuDeb:SetOrigem('E')
			oAjuDeb:SetVlAju((cAliasCF3)->CF3_VLRCOF)
			oAjuDeb:SetNumDev((cAliasCF3)->CF3_NFDEV)
			oAjuDeb:SetNumOri((cAliasCF3)->CF3_NFORI)
			If lConta
				oAjuDeb:SetConta((cAliasCF3)->CF3_CONTA)
			EndIf
			oAjuDeb:SetInfComp('Ajuste de Redução da Contribuição, referente a Redução de período anterior não realizado, em função de não ter Contribuição suficiente para ser reduzido.')
			oAjuDeb:Ajustar()

			(cAliasCF3)->(DbSkip ())
		EndDo

		oAjuDeb:FechaAlias(cAliasCF3)

		oDebito:= COMPDEBITO():New()
		oDebito:SetFilial(aXFilial)
		oDebito:SetDtIni(dDataDe)
		oDebito:AtuDebito(CUMULAT,PIS)
		oDebito:AtuDebito(CUMULAT,COFINS)
		FreeObj(oDebito)
		oDebito	:= nil
	EndIf

	If cTpMov == 'S' .AND. cOpAju $ "1/2"
		//CARREGA as deduções de débito de período anterior
		cAliasCF3	:= oSaldoDed:LoadDedAnt('D')

		DbSelectArea (cAliasCF3)
		(cAliasCF3)->(DbGoTop ())
		Do While !(cAliasCF3)->(Eof ())

			//Realiza os ajustes de redução do débito.
			//Realizado somente para as operações Exclusivamente CUmulativas, pois no regime Não Cumulativo
			//As devoluções de venda dão direito ao crédito.
			cDescPis	:= "Saldo de Dedução de PIS referênte ao período anterior, proveniente do registro F700"
			oAjuDeb:SetTributo(PIS)
			oAjuDeb:SetTpAjust(REDUCAO)
			oAjuDeb:SetCodAju('05')
			oAjuDeb:SetDescAju(cDescPis)
			oAjuDeb:SetDtRefer((cAliasCF3)->CF3_PERORI)
			oAjuDeb:SetMsmCod(.F.) // Com este parâmetro com .F. não irá efetuar o ajuste exatamente no mesmo código
			oAjuDeb:SetRegime((cAliasCF3)->CF3_REGIME)
			oAjuDeb:SetOrigem('D')
			oAjuDeb:SetVlAju((cAliasCF3)->CF3_VLRPIS)
			If lConta
				oAjuDeb:SetConta((cAliasCF3)->CF3_CONTA)
			EndIf
			oAjuDeb:SetInfComp('Ajuste de Redução da Contribuição, referente a Redução de período anterior não realizado, em função de não ter Contribuição suficiente para ser reduzido.')
			oAjuDeb:Ajustar()

			//Realiza Ajuste para a COFINS
			cDescCof	:= "Saldo de Dedução de Cofins referênte ao período anterior, proveniente do registro F700"
			oAjuDeb:SetTributo(COFINS)
			oAjuDeb:SetTpAjust(REDUCAO)
			oAjuDeb:SetCodAju('05')
			oAjuDeb:SetDescAju(cDescCof)
			oAjuDeb:SetDtRefer((cAliasCF3)->CF3_PERORI)
			oAjuDeb:SetMsmCod(.F.) // Com este parâmetro com .F. não irá efetuar o ajuste exatamente no mesmo código
			oAjuDeb:SetRegime((cAliasCF3)->CF3_REGIME)
			oAjuDeb:SetOrigem('D')
			oAjuDeb:SetVlAju((cAliasCF3)->CF3_VLRCOF)
			If lConta
				oAjuDeb:SetConta((cAliasCF3)->CF3_CONTA)
			EndIf
			oAjuDeb:SetInfComp('Ajuste de Redução da Contribuição, referente a Redução de período anterior não realizado, em função de não ter Contribuição suficiente para ser reduzido.')
			oAjuDeb:Ajustar()

			(cAliasCF3)->(DbSkip ())
		EndDo
		oAjuDeb:FechaAlias(cAliasCF3)

		oDebito:= COMPDEBITO():New()
		oDebito:SetFilial(aXFilial)
		oDebito:SetDtIni(dDataDe)
		oDebito:AtuDebito(CUMULAT,PIS)
		oDebito:AtuDebito(CUMULAT,COFINS)
		FreeObj(oDebito)
		oDebito	:= nil

	Endif

	//Aqui deverá processar somente os ajustes de base de cálculo
	If cTpMov == 'S' .AND. cOpAju == "3"

		//CARREGA as deduções de ajustes de base de cálculo de período anterior
		cAliasCF3	:= oSaldoDed:LoadDedAnt('A')

		DbSelectArea (cAliasCF3)
		(cAliasCF3)->(DbGoTop ())
		Do While !(cAliasCF3)->(Eof ())

			//Realiza os ajustes de redução do débito.
			//Realizado somente para as operações Exclusivamente CUmulativas, pois no regime Não Cumulativo
			//As devoluções de venda dão direito ao crédito.

			cDescPis	:= "Saldo de Redução de Base de Cálculo de PIS referênte ao período anterior, proveniente do registro M215."
			oAjuDeb:SetCNPJ(SM0->M0_CGC)
			oAjuDeb:SetCrdDeb("2")
			oAjuDeb:SetTributo(PIS)
			oAjuDeb:SetTpAjust(REDUCAO)
			oAjuDeb:SetCodAju('42')
			oAjuDeb:SetDescAju(cDescPis)
			oAjuDeb:SetDtRefer(dDataDe)
			oAjuDeb:SetMsmCod(.F.) // Com este parâmetro com .F. não irá efetuar o ajuste exatamente no mesmo código
			oAjuDeb:SetRegime((cAliasCF3)->CF3_REGIME)
			oAjuDeb:SetOrigem('A')
			oAjuDeb:SetVlAju((cAliasCF3)->CF3_VLRPIS)
			If lConta
				oAjuDeb:SetConta((cAliasCF3)->CF3_CONTA)
			EndIf
			oAjuDeb:SetInfComp('Ajuste de Redução da Base de Cálculo, referente ao ajuste de período anterior não realizado, em função de não ter Contribuição suficiente para ser reduzido.')
			oAjuDeb:SetAjuBase(.T.)
			oAjuDeb:Ajustar()

			//Realiza Ajuste para a COFINS
			cDescCof	:= "Saldo de Redução de Base de Cálculo de COFINS referênte ao período anterior, proveniente do registro M615."
			oAjuDeb:SetCNPJ(SM0->M0_CGC)
			oAjuDeb:SetCrdDeb("2")
			oAjuDeb:SetTributo(COFINS)
			oAjuDeb:SetTpAjust(REDUCAO)
			oAjuDeb:SetCodAju('42')
			oAjuDeb:SetDescAju(cDescCof)
			oAjuDeb:SetDtRefer(dDataDe)
			oAjuDeb:SetMsmCod(.F.) // Com este parâmetro com .F. não irá efetuar o ajuste exatamente no mesmo código
			oAjuDeb:SetRegime((cAliasCF3)->CF3_REGIME)
			oAjuDeb:SetOrigem('A')
			oAjuDeb:SetVlAju((cAliasCF3)->CF3_VLRCOF)
			If lConta
				oAjuDeb:SetConta((cAliasCF3)->CF3_CONTA)
			EndIf
			oAjuDeb:SetInfComp('Ajuste de Redução da Base de Cálculo, referente ao ajuste de período anterior não realizado, em função de não ter Contribuição suficiente para ser reduzido.')
			oAjuDeb:SetAjuBase(.T.)
			oAjuDeb:Ajustar()

			(cAliasCF3)->(DbSkip ())
		EndDo
		oAjuDeb:FechaAlias(cAliasCF3)

		oDebito:= COMPDEBITO():New()
		oDebito:SetFilial(aXFilial)
		oDebito:SetDtIni(dDataDe)
		oDebito:AtuDebito(CUMULAT,PIS)
		oDebito:AtuDebito(CUMULAT,COFINS)
		FreeObj(oDebito)
		oDebito	:= nil

	EndIF

	If cTpMov == 'E'
		//Carrega saldo de dedução de crédito de período anterior
		cAliasCF3	:= oSaldoDed:LoadDedAnt('C')

		DbSelectArea (cAliasCF3)
		(cAliasCF3)->(DbGoTop ())
		Do While !(cAliasCF3)->(Eof ())

			//Realiza os ajustes de redução do débito.
			//Realizado somente para as operações Exclusivamente CUmulativas, pois no regime Não Cumulativo
			//As devoluções de venda dão direito ao crédito.
			cDescr	:= STR0080 + (cAliasCF3)->CF3_NFORI // 'Estorno referente a devolução, documento fiscal: '
			oAjuCred:SetTributo(PIS)
			oAjuCred:SetTpAjust(REDUCAO)
			oAjuCred:SetCodAju('06')
			oAjuCred:SetNumDoc("")
			oAjuCred:SetDescAju(cDescr)
			oAjuCred:SetDtRefer((cAliasCF3)->CF3_PERORI)
			oAjuCred:SetMsmCod(.F.) // Com este parâmetro com .F. não irá efetuar o ajuste exatamente no mesmo código
			oAjuCred:SetRegime(NAOCUMULAT)
			oAjuCred:SetOrigem('C')
			oAjuCred:SetVlAju((cAliasCF3)->CF3_VLRPIS)
			oAjuCred:SetNumDev((cAliasCF3)->CF3_NFDEV)
			oAjuCred:SetNumOri((cAliasCF3)->CF3_NFORI)
			If lConta
				oAjuCred:SetConta((cAliasCF3)->CF3_CONTA)
			EndIf
			oAjuCred:SetInfComp('Ajuste de Redução do Crédito, referente a Redução de período anterior não realizado, em função de não ter Crédito suficiente para ser reduzido.')
			oAjuCred:Ajustar()

			//Realiza Ajuste para a COFINS
			oAjuCred:SetTributo(COFINS)
			oAjuCred:SetTpAjust(REDUCAO)
			oAjuCred:SetCodAju('06')
			oAjuCred:SetNumDoc("")
			oAjuCred:SetDescAju(cDescr)
			oAjuCred:SetDtRefer((cAliasCF3)->CF3_PERORI)
			oAjuCred:SetMsmCod(.F.) // Com este parâmetro com .F. não irá efetuar o ajuste exatamente no mesmo código
			oAjuCred:SetRegime(NAOCUMULAT)
			oAjuCred:SetOrigem('C')
			oAjuCred:SetVlAju((cAliasCF3)->CF3_VLRCOF)
			oAjuCred:SetNumDev((cAliasCF3)->CF3_NFDEV)
			oAjuCred:SetNumOri((cAliasCF3)->CF3_NFORI)
			If lConta
				oAjuCred:SetConta((cAliasCF3)->CF3_CONTA)
			EndIf
			oAjuCred:SetInfComp('Ajuste de Redução do Crédito, referente a Redução de período anterior não realizado, em função de não ter Crédito suficiente para ser reduzido.')
			oAjuCred:Ajustar()

			(cAliasCF3)->(DbSkip ())
		EndDo

		oAjuCred:FechaAlias(cAliasCF3)

	EndIF
	FreeObj(oSaldoDed)
	oSaldoDed:= Nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} QRYDEVOL()
Função que monta query para buscar os documentos de devoluções e devolve
o alias com query já efetuada.

@param	 	dDataDe 	 - Data Inicial de Processamento
			dDataAte	 - Data Final de processamento
			cTpMovQry   - Tipo do movimento a ser considerado na query Entrada/Saída
			cNrLivro    - Número do Livro a ser processado
			cRegime 	 - regime escolhido pelo usuário na apuração 
			nMVM996TPR  - Conteúdo do `parâmetro MV_M996TPR	
@return	Alias da STF com as devoluções conforme parâmetros passados		
@author Erick G. Dias
@since 10/07/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function QRYDEVOL(dDataDe,dDataAte,cTpMovQry,cNrLivro,cRegime,nMVM996TPR)

	Local cSelect 	:= ''
	Local cFrom 	:= ''
	Local cWhere 	:= ''
	Local cAliasSFT	:= 'SFT'
	Local lCooperat	:= SA1->(FieldPos((SuperGetMv("MV_COOPERA",.F.,""))))>0
	Local cCooperat	:= IIF(lCooperat,SuperGetMv("MV_COOPERA",.F.,""),"")

	cSelect :=	"SFT.FT_FILIAL,SFT.FT_TIPOMOV,SFT.FT_NFORI,SFT.FT_SERORI,SFT.FT_ITEMORI,SFT.FT_NFISCAL,SFT.FT_CLIEFOR,"
	cSelect +=	"SFT.FT_LOJA,SFT.FT_ITEM,SFT.FT_VALCOF,SFT.FT_VALPIS,SFT.FT_PRODUTO,SFT.FT_QUANT,SFT.FT_BASEPIS,SFT.FT_BASECOF, SFT.FT_ENTRADA,"
	cSelect +=	"SFT.FT_CSTPIS,SFT.FT_CSTCOF,SFT.FT_FORMUL,SFT.FT_SERIE,SFT.FT_VALCONT, SFT.FT_ICMSRET, SFT.FT_VALIPI "

	If	SFT->(FieldPos("FT_TES"))>0
		cSelect += ",SFT.FT_TES "
	Endif

	If SFT->(FieldPos('FT_VALCPB')) > 0 .AND. SFT->(FieldPos('FT_ATIVCPB')) > 0
		cSelect += ",SFT.FT_ATIVCPB,SFT.FT_VALCPB,SFT.FT_BASECPB,SFT.FT_ALIQCPB "
	EndIf

	cFrom	:=	""+RetSqlName("SFT")+" SFT "
	cWhere	:=	"SFT.FT_FILIAL='"+xFilial("SFT")+"' AND "
	cWhere	+=	"SFT.FT_TIPOMOV='"+cTpMovQry+"' AND "
	cWhere	+=	"SFT.FT_ENTRADA>='"+DTOS(dDataDe)+"' AND "
	cWhere	+=	"SFT.FT_ENTRADA<='"+DTOS(dDataAte)+"' AND "
	cWhere	+=	"SFT.FT_DTCANC='' AND "
	cWhere	+=	"SFT.FT_TIPO='D' AND "
	If cNrLivro<>"*"
		cWhere += " SFT.FT_NRLIVRO = '"+cNrLivro+"' AND "
	Endif
	cWhere	+=	"SFT.D_E_L_E_T_=''"

	If cRegime$"4"
		//Regime Cumulativo e Não Cumulativo
		If nMVM996TPR==1
			//PARÂMETRO INDICA QUE DEVERÁ VER F4_TPREG PARA DEFINIR O REGIME
			If cTpMovQry=="E"
				//DEVOLUÇÃO DE VENDA
				cSelect	+=	" ,SF4.F4_TPREG ,SB1.B1_TPREG"
				cFrom	+=	" LEFT JOIN "+RetSqlName("SD1")+" SD1 ON SD1.D1_FILIAL='"+xFilial("SD1")+"' AND SD1.D1_DOC=SFT.FT_NFISCAL AND SD1.D1_SERIE=SFT.FT_SERIE AND "
				cFrom	+=	" SD1.D1_FORNECE=SFT.FT_CLIEFOR AND SD1.D1_LOJA=SFT.FT_LOJA AND SD1.D1_ITEM=SFT.FT_ITEM AND SD1.D_E_L_E_T_='' "
				cFrom	+=	" LEFT JOIN "+RetSqlName("SF4")+" SF4 ON SF4.F4_FILIAL='"+xFilial("SF4")+"' AND SF4.F4_CODIGO=SD1.D1_TES AND SF4.D_E_L_E_T_='' "
				cFrom	+=	" LEFT JOIN "+RetSqlName("SA1")+" SA1 ON SA1.A1_FILIAL='"+xFilial("SA1")+"' AND SA1.A1_COD=SFT.FT_CLIEFOR AND SA1.A1_LOJA=SFT.FT_LOJA AND SA1.D_E_L_E_T_='' "
				cWhere	+=	" AND ((SF4.F4_TPREG='2') OR (SF4.F4_TPREG='3' AND SB1.B1_TPREG='2') OR (SFT.FT_FORMUL='S' AND (SFT.FT_CSTPIS IN ('98','99') OR SFT.FT_CSTCOF IN ('98','99')) ) )"
				If lCooperat .And. !Empty(cCooperat)
					cWhere += " AND SA1."+cCooperat+" <> '1' "
				EndIf
			Else
				//DEVOLUÇÃO DE COMPRA
				cSelect	+=	" ,SF4.F4_TPREG ,SB1.B1_TPREG"
				cFrom	+=	" LEFT JOIN "+RetSqlName("SD2")+" SD2 ON SD2.D2_FILIAL='"+xFilial("SD2")+"' AND SD2.D2_DOC=SFT.FT_NFISCAL AND SD2.D2_SERIE=SFT.FT_SERIE AND "
				cFrom	+=	" SD2.D2_CLIENTE=SFT.FT_CLIEFOR AND SD2.D2_LOJA=SFT.FT_LOJA AND SD2.D2_ITEM=SFT.FT_ITEM  AND SD2.D_E_L_E_T_='' "
				cFrom	+=	" LEFT JOIN "+RetSqlName("SF4")+" SF4 ON SF4.F4_FILIAL='"+xFilial("SF4")+"' AND SF4.F4_CODIGO=SD2.D2_TES AND SF4.D_E_L_E_T_='' "
				cWhere	+=	" AND ((SF4.F4_TPREG='1') OR (SF4.F4_TPREG='3' AND SB1.B1_TPREG='1'))"
			Endif

			cFrom	+=	" LEFT JOIN "+RetSqlName("SB1")+" SB1 ON SB1.B1_FILIAL='"+xFilial("SB1")+"' AND SB1.B1_COD=SFT.FT_PRODUTO AND SB1.D_E_L_E_T_=''"

		Elseif nMVM996TPR==2
			//PARÂMETRO INDICA QUE DEVERÁ VER B1_TPREG PARA DEFINIR O REGIME
			cSelect	+=	" ,SB1.B1_TPREG"
			cFrom	+=	" LEFT JOIN "+RetSqlName("SB1")+" SB1 ON SB1.B1_FILIAL='"+xFilial("SB1")+"' AND SB1.B1_COD=SFT.FT_PRODUTO AND SB1.D_E_L_E_T_=''"

			If cTpMovQry=="E"
				IF lCooperat .And. !Empty(cCooperat)
					cFrom	+=	" LEFT JOIN "+RetSqlName("SA1")+" SA1 ON SA1.A1_FILIAL='"+xFilial("SA1")+"' AND SA1.A1_COD=SFT.FT_CLIEFOR AND SA1.A1_LOJA=SFT.FT_LOJA AND SA1.D_E_L_E_T_='' "
				EndIf
				cWhere	+=	" AND ((SB1.B1_TPREG='2') OR (SFT.FT_FORMUL='S' AND (SFT.FT_CSTPIS IN ('98','99') OR SFT.FT_CSTCOF IN ('98','99')) )  )"
				If lCooperat .And. !Empty(cCooperat)
					cWhere += " AND SA1."+cCooperat+" <> '1' "
				EndIf
			Else
				cWhere	+=	" AND SB1.B1_TPREG='1'"
			Endif

		Elseif nMVM996TPR==3
			//PARÂMETRO INDICA QUE DEVERÁ VER a1_TPREG PARA DEFINIR O REGIME
			If cTpMovQry=="E" .And. SA1->(FieldPos("A1_TPREG"))>0
				cSelect	+=	" ,SA1.A1_TPREG"
				cFrom	+=	" LEFT JOIN "+RetSqlName("SA1")+" SA1 ON SA1.A1_FILIAL='"+xFilial("SA1")+"' AND SA1.A1_COD=SFT.FT_CLIEFOR AND "
				cFrom	+=	" SA1.A1_LOJA=SFT.FT_LOJA AND SA1.D_E_L_E_T_=''"
				cWhere	+=	" AND ((SA1.A1_TPREG='2') OR (SFT.FT_FORMUL='S' AND (SFT.FT_CSTPIS IN ('98','99') OR SFT.FT_CSTCOF IN ('98','99')) )  ) AND SA1.A1_LOJA=SFT.FT_LOJA AND SA1.D_E_L_E_T_=''"
				If lCooperat .And. !Empty(cCooperat)
					cWhere += " AND SA1."+cCooperat+" <> '1' "
				EndIf
			Elseif SA2->(FieldPos("A2_TPREG"))>0
				cSelect	+=	" ,SA2.A2_TPREG"
				cFrom	+=	" LEFT JOIN "+RetSqlName("SA2")+" SA2 ON SA2.A2_FILIAL='"+xFilial("SA2")+"' AND SA2.A2_COD=SFT.FT_CLIEFOR AND "
				cFrom	+=	" SA2.A2_LOJA=SFT.FT_LOJA AND SA2.D_E_L_E_T_=''"
				cWhere	+=	" AND SA2.A2_TPREG='1'"
			Endif
		Endif
	ElseIf cRegime$"1" .And. cTpMovQry=="E"
		//Regime Não Cumulativo
		If SF4->(FieldPos("F4_OPERGAR"))>0
			cFrom		+=	" LEFT JOIN "+RetSqlName("SD1")+" SD1 ON SD1.D1_FILIAL='"+xFilial("SD1")+"' AND SD1.D1_DOC=SFT.FT_NFISCAL AND SD1.D1_SERIE=SFT.FT_SERIE AND "
			cFrom		+=	" SD1.D1_FORNECE=SFT.FT_CLIEFOR AND SD1.D1_LOJA=SFT.FT_LOJA AND SD1.D1_ITEM=SFT.FT_ITEM AND SD1.D_E_L_E_T_='' "
			cFrom		+=	" LEFT JOIN "+RetSqlName("SF4")+" SF4 ON SF4.F4_FILIAL='"+xFilial("SF4")+"' AND SF4.F4_CODIGO=SD1.D1_TES AND SF4.D_E_L_E_T_='' "
			cFrom		+=	" LEFT JOIN "+RetSqlName("SA1")+" SA1 ON SA1.A1_FILIAL='"+xFilial("SA1")+"' AND SA1.A1_COD=SFT.FT_CLIEFOR AND "
			cFrom		+=	" SA1.A1_LOJA=SFT.FT_LOJA AND SA1.D_E_L_E_T_='' "
			cWhere		+=	" AND (SFT.FT_FORMUL='S' AND SF4.F4_OPERGAR<>'1' ) AND (SFT.FT_CSTPIS IN ('98','99') OR SFT.FT_CSTCOF IN ('98','99')) "
			If lCooperat .And. !Empty(cCooperat)
				cWhere += " AND SA1."+cCooperat+" <> '1' "
			EndIf
		Else
			cFrom		+=	" LEFT JOIN "+RetSqlName("SA1")+" SA1 ON SA1.A1_FILIAL='"+xFilial("SA1")+"' AND SA1.A1_COD=SFT.FT_CLIEFOR AND "
			cFrom		+=	" SA1.A1_LOJA=SFT.FT_LOJA AND SA1.D_E_L_E_T_='' "
			cWhere	+=	" AND SFT.FT_FORMUL='S' AND (SFT.FT_CSTPIS IN ('98','99') OR SFT.FT_CSTCOF IN ('98','99')) "
			If lCooperat .And. !Empty(cCooperat)
				cWhere += " AND SA1."+cCooperat+" <> '1' "
			EndIf
		Endif
	ElseIf cRegime$"3" .And. cTpMovQry=="E" //Tratamento para contempletar a issue DSERFIS1-31469 - Regime de Caixa
		//Pego o valor que foi baixado da tabela SE5
		cSelect		+=	" , SE5.E5_VALOR"
		//Faço um INNER JOIN para garantir que só deverá ser realizada a redução da base de cálculo caso haja baixa no Regime de Caixa
		cFrom		+=	" INNER JOIN "+RetSqlName("SE5")+" SE5 ON SE5.E5_FILIAL ='"+xFilial("SE5")+"' AND SE5.E5_PREFIXO = SFT.FT_SERIE AND "
		cFrom		+=	" SE5.E5_NUMERO = SFT.FT_NFISCAL AND SE5.E5_CLIFOR = SFT.FT_CLIEFOR AND  SE5.E5_LOJA = SFT.FT_LOJA AND "
		cFrom		+=	" SE5.E5_DTCANBX = '' AND SE5.E5_DATA BETWEEN '" + DTOS(dDataDe) + "' AND '" + DTOS(dDataAte) + "' AND "
		cFrom		+=	" SE5.E5_SITUACA != 'C' AND SE5.E5_TIPODOC != 'ES' AND SE5.E5_MOTBX != 'CMP' AND SE5.D_E_L_E_T_ = '' "
	EndIF

	cSelect := '%'+cSelect+'%
	cFrom	:= '%'+cFrom+'%'
	cWhere	:= '%'+cWhere+'%'

	cAliasSFT	:=	GetNextAlias()
	BeginSql Alias cAliasSFT
	COLUMN FT_ENTRADA AS DATE
	SELECT 
		%Exp:cSelect%

	FROM 
		%Exp:cFrom%

	WHERE 
		%Exp:cWhere%

	EndSql

Return cAliasSFT

//-------------------------------------------------------------------
/*/{Protheus.doc} QryCL3()
Função que faz query na CL3 para verificar se algum título foi gerado
		
@author Erick G. Dias
@since 09/05/17
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function QryCL3(dData)

	Local cAliasCL3	:= "CL3"
	Local cSlctCL3	:= ''

	cSlctCL3 :='%'
	cSlctCL3 += 'CL3.* '
	cSlctCL3 +='%'

	cAliasCL3	:=	GetNextAlias()

	BeginSql Alias cAliasCL3
	SELECT			    
		%Exp:cSlctCL3%
	FROM 
		%Table:CL3% CL3
	WHERE
		CL3.CL3_FILIAL=%xFilial:CL3% AND		
		CL3.CL3_PER=%Exp:DToS(dData)% and
		CL3.CL3_VALOR > 0 AND
		CL3.CL3_NUMTIT <> ' ' AND
		CL3.%NotDel%	
	EndSql

Return cAliasCl3

//-------------------------------------------------------------------
/*/{Protheus.doc} CheckDup()
Função que verifica se já existem títulos a pagar de PIS e COFINS
gerados pela apuração. Deleta o título se necessário conforme interação do usuário

@return	indica se deletou ou não o título,
		
@author Erick G. Dias
@since 10/07/2014
@version 11.80
/*/
//-------------------------------------------------------------------

Static Function CheckDup(lAutomato)

	Local cPerg			:= ''
	Local cCodLp		:= ''
	Local cNumTitAux	:= ''
	Local cAliasCL3		:= ''
	local lDeletou		:= .F.
	Local lContinua		:= .T.
	Local lExistTit		:= .F.
	Local lProcessa  	:= .F.
	Local lContab		:= MV_PAR14==1
	Local oTitulo		:= TITPAGAR():New()
	Local oEstDifer
	Local cCodTrib		:= ''
	Default lAutomato := .F.

	Begin Transaction
	/*
	'Existem títulos gravados no Financeiro para este período e filial.'
	'Deseja prosseguir com reprocessamento e apagar os títulos?'
	'(Sim - Reprocessa / Não - Visualiza Apuração)'
	*/

		cPerg	:= STR0081 + CRLF
		cPerg	+= STR0082 + CRLF
		cPerg	+= STR0083

		If  CL3->(FieldPos("CL3_NUMTIT"))>0

			cAliasCL3	:= QryCL3(MV_PAR01)

			Do While !(cAliasCL3)->(Eof ())

				lExistTit	:= .T.
				//Códigos de lançamento padrão para estorno.
				cCodLp := Iif((cAliasCL3)->CL3_TPTIT=='PIS','611','608')
				//Passa informações para a classe poder deletar o título
				//e fazer a contabilização de estorno.
				oTitulo:SetPrefixo((cAliasCL3)->CL3_PRETIT)
				oTitulo:SetNumTit((cAliasCL3)->CL3_NUMTIT)
				oTitulo:SetParcela((cAliasCL3)->CL3_PARTIT)
				oTitulo:SetTipo((cAliasCL3)->CL3_TPTIT)
				oTitulo:SetFornece((cAliasCL3)->CL3_FORTIT)
				oTitulo:SetLoja((cAliasCL3)->CL3_LOJTIT)
				oTitulo:SetOrigem('FISA001')
				oTitulo:SetContab(lContab)
				oTitulo:SetCodLp(cCodLp)
				If !oTitulo:ChkDelTit()
					cNumTitAux	+= 'Número: '+ (cAliasCL3)->CL3_NUMTIT +' Prefixo: ' +(cAliasCL3)->CL3_PRETIT + ' Tipo: ' + (cAliasCL3)->CL3_TPTIT + CRLF
					lContinua	:= .F.
				EndIF

				(cAliasCL3)->(DbSkip ())
			EndDo

			If lContinua

				If lAutomato .And. lExistTit
					lProcessa := .T.
				Else
					If lExistTit .AND. ( ApMsgYesNo(cPerg ) )
						lProcessa := .T.
					EndIf
				EndIf

				If lProcessa

					(cAliasCL3)->(DBGOTOP ())
					Do While !(cAliasCL3)->(Eof ())
						//Verificar antes se existe algum título já baixado. Caso existir, então
						//exibir para o cliente os títulos que já possuem baixa no Financeiro, e não
						//permitir que prossiga com apuração.

						//Códigos de lançamento padrão para estorno.
						cCodLp := ''
						if alltrim( (cAliasCL3)->CL3_TPTIT ) =='PIS'
							cCodLp := '611'
						elseif alltrim( (cAliasCL3)->CL3_TPTIT ) =='COF'
							cCodLp := '608'
						elseif alltrim( (cAliasCL3)->CL3_TPTIT ) == 'CPR'
							cCodLp := '766'
						endif

						// se contabiliza o estorno, posiciona na CKS para o correto funcionamento da LP de estorno
						If lContab .AND. (cAliasCL3)->CL3_TPTIT $ "PIS||COF"

							Do Case
							Case (cAliasCL3)->CL3_TPTIT == "PIS"; cCodTrib := "1"
							Case (cAliasCL3)->CL3_TPTIT == "COF"; cCodTrib := "2"
							Endcase

							If !Empty(cCodTrib)
								CKS->(DbSetOrder(2))
								CKS->(MsSeek(xFilial("CKS") + (cAliasCL3)->CL3_PER + cCodTrib + (cAliasCL3)->CL3_CONSOL))

		                        CKR->(DbSetOrder(1))
								CKR->(MsSeek(xFilial("CKR") + (cAliasCL3)->CL3_PER + (cAliasCL3)->CL3_CONSOL + cCodTrib))
							EndIf

						EndIf

						//Passa informações para a classe poder deletar o título
						//e fazer a contabilização de estorno.
						oTitulo:SetPrefixo((cAliasCL3)->CL3_PRETIT)
						oTitulo:SetNumTit((cAliasCL3)->CL3_NUMTIT)
						oTitulo:SetParcela((cAliasCL3)->CL3_PARTIT)
						oTitulo:SetTipo((cAliasCL3)->CL3_TPTIT)
						oTitulo:SetFornece((cAliasCL3)->CL3_FORTIT)
						oTitulo:SetLoja((cAliasCL3)->CL3_LOJTIT)
						oTitulo:SetOrigem('FISA001')
						oTitulo:SetContab(lContab)
						oTitulo:SetCodLp(cCodLp)
						oTitulo:SetExibCtb(.t.)
						oTitulo:DelTitulo()
						lDeletou	:= .T.

						(cAliasCL3)->(DbSkip ())
					EndDo

					FreeObj(oTitulo)
					oTitulo:= Nil

					// Tratamento para gerar lançamento contábil para Diferimento de PIS / COFINS ( dentro do mesmo período e período anterior )
					//Validação para verifiar se foi deletado algum titulo e se está solicitando para contabilizar
					if lDeletou .and. lContab

						DBSelectArea( 'CKS' )
						CKS->( DBSetOrder( 1 ) )
						if CKS->( MsSeek(xFilial("CKS")+ dTos(MV_PAR01)))

							oEstDifer:= TITPAGAR():New()

							do while !CKS->( eof () ) .and. CKS->CKS_FILIAL == xFilial('CKS') .and. CKS->CKS_PER == MV_PAR01

								//ESTORNO DIFERIMENTO PIS/COFINS NO MÊS (Período)
								if CKS->CKS_DIF > 0
									cCodLp	:= 	iif(CKS->CKS_TRIB == '1','761','762')
									CtbDifer(oEstDifer, cCodLp, lContab)
								endif

								//ESTORNO DIFERIMENTO PIS/COFINS MESES ANTERIORES
								if CKS->CKS_DIFANT > 0
									cCodLp	:= 	iif(CKS->CKS_TRIB == '1','763','764')
									CtbDifer(oEstDifer, cCodLp, lContab)
								endif

								CKS->(dbSkip())
							enddo

							FreeObj(oEstDifer)
							oEstDifer:= Nil
						endif
					endif
				Else
					lContinua := .F.
				EndIF
			Else
				//Exibe aqui a mensagem orientando o usuário a verificar os seguintes títulos
				//e apuração não irá prosseguir.

				Alert("Os seguintes títulos no Contas a Pagar " +CRLF+CRLF+ cNumTitAux + CRLF+"Não podem ser apagados,verificar se existem baixas para estes títulos no Financeiro."+CRLF+"O Reprocessamento será interrompido.")

			EndIF
			DbSelectArea (cAliasCL3)
			(cAliasCL3)->(DbCloseArea())
		EndIF
	End Transaction

Return lContinua .OR. !lExistTit

//-------------------------------------------------------------------
/*/{Protheus.doc} CheckApur()
Verifica se já existe apuração processada para este período

@return	Indica se existe ou não apuração gravada para filial e período
		
@author Erick G. Dias
@since 10/07/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function CheckApur()

	Local lApurado	:= .F.

	DbSelectArea ('CKR')
	CKR->(DbSetOrder(1))
	If CKR->(MSSEEK(xFilial('CKR')+dTos(MV_PAR01)))
		lApurado := .T.
	EndIF

Return lApurado

//-------------------------------------------------------------------
/*/{Protheus.doc} ASA001AFIL()
Função que popula array com xFilial das tabelas de apuração.
Estas informações são utilizadas quando apuração for processada
com mais de uma filial e de forma consolidada, já que todas as informações
deverá ser gravadas na matriz, por este motivo guardo o xFilial da Matriz.

@return	aRet - Array com xFilial das tabelas de apuração conforme Matriz.
		
@author Erick G. Dias
@since 10/07/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function ASA001AFIL()

	Local aRet	:= {}

	AADD(aRet,{'CL8',xFilial('CL8')})
	AADD(aRet,{'CL9',xFilial('CL9')})
	AADD(aRet,{'CLA',xFilial('CLA')})
	AADD(aRet,{'CKR',xFilial('CKR')})
	AADD(aRet,{'CKS',xFilial('CKS')})
	AADD(aRet,{'CKT',xFilial('CKT')})
	AADD(aRet,{'CKU',xFilial('CKU')})
	AADD(aRet,{'CKV',xFilial('CKV')})
	AADD(aRet,{'CKW',xFilial('CKW')})
	AADD(aRet,{'CKZ',xFilial('CKZ')})
	AADD(aRet,{'CL0',xFilial('CL0')})
	AADD(aRet,{'CL3',xFilial('CL3')})
	AADD(aRet,{'CL4',xFilial('CL4')})
	AADD(aRet,{'CCY',xFilial('CCY')})
	AADD(aRet,{'CCW',xFilial('CCW')})
	AADD(aRet,{'SFV',xFilial('SFV')})
	AADD(aRet,{'SFW',xFilial('SFW')})
	If AliasINdic('F3G')
		AADD(aRet,{'F3G',xFilial('F3G')})
	EndIF

	If AliasINdic('F2Z')
		AADD(aRet,{'F2Z',xFilial('F2Z')})
	EndIF

	If AliasINdic('F3P')
		AADD(aRet,{'F3P',xFilial('F3P')})
	EndIF

	If AliasINdic('F3O')
		AADD(aRet,{'F3O',xFilial('F3O')})
	EndIF

	If AliasINdic('F3J')
		AADD(aRet,{'F3J',xFilial('F3J')})
	EndIF

	If AliasINdic('CIC')
		AADD(aRet,{'CIC',xFilial('CIC')})
	EndIF

	If ISA001NDIF()
		AADD(aRet,{'CFA',xFilial('CFA')})
		AADD(aRet,{'CFB',xFilial('CFB')})
	EndIF

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} VisualApur()
Esta função irá carregar a apuração já processada em modo de visualização,
considerando a filial selecionada no grid pelo usuário.
		
@author Erick G. Dias
@since 
@version 11.80
/*/
//-------------------------------------------------------------------
Function VisualApur()

	MV_PAR01 :=  CKR->CKR_PER
	MV_PAR02 :=  LASTDAY(CKR->CKR_PER)
	MV_PAR06 := CKR->CKR_REGIME
	MV_PAR13 := 2
	MV_PAR14 := 2

	FISA002(.T.,CKR->CKR_CONSOL == '1',CKR->CKR_REGIME)

Return


//Chama rotina de relatório
Function FSA001REL()
	Local cCKRLiv := ""
	Local dDtIni  := IIf( CKR->(FieldPos('CKR_DTINI')) > 0, CKR->CKR_DTINI, CtoD(''))//IIf( CKR->(FieldPos('CKR_DTINI')) > 0, CKR->CKR_DTINI, CtoD(''))
	Local dDtFim  := IIf( CKR->(FieldPos('CKR_DTFIM')) > 0, CKR->CKR_DTFIM, CtoD(''))//IIf( CKR->(FieldPos('CKR_DTFIM')) > 0, LASTDAY(CKR->CKR_PER), CtoD(''))

	If CKR->(Fieldpos("CKR_LIVRO")) > 0
		cCKRLiv:= CKR->CKR_LIVRO
	Endif

	//Chama rotina de relatório
	FISR101(CKR->CKR_PER,alltrim(str(CKR->CKR_REGIME)),cCKRLiv, dDtINi, dDtFim )

Return
//-------------------------------------------------------------------
/*/{Protheus.doc} ExcluApur()
Está função realiza a exclusão da apuração, limpando as tabelas.
Somente irá fazer exclusão de apuração que não gerou título e/ou não contabilizou
Para as outras apurações deverá realizar reprocessamento.
		
@author Erick G. Dias
@since 
@version 11.80
/*/
//-------------------------------------------------------------------
Function ExcluApur()
	Local oApurSai
	Local lConsolid	:= CKR_CONSOL == '1'
	Local aParSX1
	Local aXFilial

	IF CKR->CKR_STATUS == '1'

		//If CKR_CONSOL <> '1'

		//Aqui apuração não teve geração de títulos ou contabilização, irá permitir edição
		MV_PAR01 :=  CKR->CKR_PER
		MV_PAR02 :=  LASTDAY(CKR->CKR_PER)
		MV_PAR06 := CKR->CKR_REGIME
		MV_PAR13 := 3 //Irá pedir solicitação do usuário para gerar ou não os títulos
		MV_PAR14 := 3	//Irá pedir solicitação do usuário para contabilizar
		If ( ApMsgYesNo('Deseja realmente excluir apuração da filial: ' + FWGETCODFILIAL + ' do período de ' + MesExtenso(mv_par01) + '/' +  Str(year(mv_par01),4) + ' ?') )		//Irá apagar os títulos
			Begin Transaction

				aParSX1 := {MV_PAR01}
				axFilial:= ASA001AFIL()

				oApurSai := FISX001():New()
				oApurSai:SetFilial(axFilial)
				oApurSai:SetFilApu(FWGETCODFILIAL)
				oApurSai:SetDtIni(MV_PAR01)
				oApurSai:SetDtFin(MV_PAR02)
				Processa({|lEnd| IniCred(aParSX1,axFilial, ,lConsolid),;
					IniDeducao(aParSX1,aXFilial),;
					IniRetenca(aParSX1,aXFilial),;
					oApurSai:ClearTab(ALIASREPRO(Iif(lConsolid,'3' ,'2' )),lConsolid) },"Excluindo Apuração",,,.T.)

				oApurSai	:= Nil

			End Transaction

			//Deverá percorrer SM0 buscando CKR e tirando o STATUS de consolidada.
			IF lConsolid
				DesfazCon()
			EndIF

			MsgInfo('Apuração Excluída com Sucesso')
		EndIF
	/*Else
		Alert('Esta é uma apuração concolidada na visão da Matriz, não poderá ser excluída.')
	EndIF*/


Else
	//Aqui apuração já teve geração de título ou lançamento padrão, não irá permitir
	//'Foram gerados títulos e/ou contabilizações para esta apuração, para edição será necessário efetuar o reprocessamento desta filial e período.'
	Alert('Apuração já gravou título ou já realizou contabilização ou foi considerada em uma consolidação, não poderá ser excluída!')

EndIF


return

//-------------------------------------------------------------------
/*/{Protheus.doc} EditaApur()
Esta função carrega apuração em modo de edição
		
@author Erick G. Dias
@since 
@version 11.80
/*/
//-------------------------------------------------------------------
Function EditaApur()

	IF CKR->CKR_STATUS == '1'
		
		//Aqui apuração não teve geração de títulos ou contabilização, irá permitir edição
		MV_PAR01 :=  FIRSTDAY(CKR->CKR_PER)
		MV_PAR02 :=  LASTDAY(CKR->CKR_PER)
		MV_PAR06 := CKR->CKR_REGIME
		MV_PAR13 := 5 	//Irá pedir solicitação do usuário para gerar ou não os títulos	
		MV_PAR14 := 3	//Irá pedir solicitação do usuário para contabilizar
		
		Begin Transaction
			FISA002(.F.,CKR->CKR_CONSOL == '1',CKR->CKR_REGIME)	
		End Transaction

	Else
		//Aqui apuração já teve geração de título ou lançamento padrão, não irá permitir
		//'Foram gerados títulos e/ou contabilizações para esta apuração, para edição será necessário efetuar o reprocessamento desta filial e período.'
		Alert(STR0084)

	EndIF

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001Agrp()
Esta função é responsável por realiza o agrupamento das apurações
já processadas nas filiais individualizadas na matriz. Irá somar todos os 
valores nas tabelas de apuração e criar na matriz(empresa logada) novas linhas
nas tabelas de forma consolidada.
		
@author Erick G. Dias
@since 
@version 11.80
/*/
//-------------------------------------------------------------------
Function A001Agrp()

Local aFil	:= {}
Local nFil	:= 0
Local aSM0	:= {}
Local cFilLog	:= AllTrim(SM0->M0_CODFIL)
Local oProcess
			
ProcLogIni({})
ProcLogAtu("INICIO","Início da Consolidação na Visão da Matriz - " + Time(),,upper('FISA001'))
IF ApMsgYesNo(STR0085)//'Esta opção irá consolidar apurações já processadas das filiais na apuração da Matriz. Deseja Continuar?'
	If Pergunte("ISA002",.T.)
		Begin Transaction
			oProcess := FISProgress():New({|lEnd| IniciaCon(oProcess)},STR0086)//'Processado Consolidação Filial->Matriz'
			oProcess:Activate()
		End Transaction		
	EndIF
EndIF
ProcLogAtu("INICIO","Fim da Consolidação na Visão da Matriz - " + Time(),,upper('FISA001'))


Return

//-------------------------------------------------------------------
/*/{Protheus.doc} IniciaCon()
Esta função irá tratar as filiais que deverão fazer parte do agrupamento
e tualizar a barra de progresso.
		
@param oProcess  - Objeto da classe FISXCLASS para barra de progressão.
@author Erick G. Dias
@since 
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function IniciaCon(oProcess)

Local aFil	:= {}
Local nFil	:= 0
Local aSM0	:= {}
Local aCKR	:= {}
Local cREgime	:= ''
Local cFilLog	:= AllTrim(SM0->M0_CODFIL)
Local aXFilial	:= {}
Local lCancel	:= 	.F.
Local TimeInicio
Local TimeFim
Local lConsolid	:= .F.

aXFilial:= ASA001AFIL()

aFil:= MatFilCalc( .T. )
aAreaSM0 := SM0->(GetArea())
aCKR	  := CKR->(GetArea())
DbSelectArea("SM0")

aAreaSM0 := SM0->(GetArea())

DbSelectArea ('CKR')
CKR->(DbSetOrder(1))


SM0->(DbGoTop())
If SM0->(MsSeek(cEmpAnt))
	Do While !SM0->(Eof()) 
		nFil := Ascan(aFil,{|x|AllTrim(x[2])==Alltrim(SM0->M0_CODFIL) .And. x[4] == SM0->M0_CGC})
		If nFil > 0 .And. aFil[nFil][1] 			
			Aadd(aSM0,{SM0->M0_CODIGO,SM0->M0_CODFIL,SM0->M0_FILIAL,SM0->M0_NOME,SM0->M0_CGC})			
			//Busca linha de apuração para filial, na data de processamento, não consolidada e tributo igual a pis
			//CKR_FILIAL+dTos(CKR_PER)+CKR_CONSOL+CKR_TRIB
			nFil := Len(aSM0)
			SM0->(DbGoTop ())
			SM0->(MsSeek (aSM0[nFil][1]+aSM0[nFil][2], .T.))	//Pego a filial mais proxima
			cFilAnt := FWGETCODFILIAL
			If CKR->(MSSEEK(xFilial('CKR')+dTos(MV_PAR01)+'21'))
				IF	CKR->CKR_STATUS <> '1'
					//Verifica aqui se apuração gerou título/contabilizou, se sim deverá abortar
					//Apuração gerou título e/ou contabilização, não poderá continua
					If CKR->CKR_STATUS == '4'
						lConsolid	:= .T. //Indica que apuração já foi consolidada
					EndIF
					lCancel	:= .T.
				EndIF
				
				If !Empty(cRegime)
					IF CKR->CKR_REGIME <> cRegime
						//Todos os regimes deverão ser o mesmo, se algum diferente deverá abortar
						//Não poderá ser regime diferente para consolidação, não poderá continuar.
						lCancel	:= .T.	
					EndIF
				Else
					cRegime	:= CKR->CKR_REGIME
				EndIF				
			EndIF		
		EndIf
		SM0->(dbSkip())
	Enddo
EndIf
RestArea (aAreaSM0)
cFilAnt := FWGETCODFILIAL

SM0->(RestArea(aAreaSM0))
aAreaSM0 := SM0->(GetArea())

If lConsolid
	Alert('Esta apuração já foi considerada em uma consolidação. Por favor, exclua a apuração consolidada antes de prosseguir.')
ElseIF lCancel
	Alert('Não poderão ser consolidadas apurações que já tenham gerado título/contabilização ou apurações com regimes diferentes'+CHR(10)+CHR(13)+'Verifique estas informações para poder prosseguir com a consolidação')
Else
	TimeInicio :=Time()
	oProcess:Set1Progress(len(aSM0))
	oProcess:Set2Progress(1)
			oProcess:SetDetProgress("Inicio do processamento",TimeInicio,;
				"Fim do Processamento","" ,;
				"Tempo de processamento","" ,;
				"","")		

	For nFil := 1 to Len(aSM0)
	
		SM0->(DbGoTop ())
		SM0->(MsSeek(aSM0[nFil][1]+aSM0[nFil][2], .T.))	//Pego a filial mais proxima
		cFilAnt := FWGETCODFILIAL
		oProcess:Inc1Progress('Processando Filial'+FWGETCODFILIAL)//"Processando Filial"
		ProcConFil(oProcess,aXFilial,cFilLog,lConsolid)
	
	Next nFil	
	
	RestArea (aAreaSM0)
	cFilAnt := FWGETCODFILIAL
	
	CKR->(RestArea(aCKR))
	
	TimeFim := Time()
	oProcess:Set2Progress(1)
			oProcess:SetDetProgress("Inicio do processamento",TimeInicio,;
				"Fim do Processamento",TimeFim ,;
				"Tempo de processamento",ELAPTIME(TimeInicio,TimeFim) ,;
				"","")
	MsgInfo(STR0087)//'Consolidação Concluída com Sucesso'
EndIF

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001QRYCON()
Função que irá realizar query para consolidar as filiais na matriz.
		
@param 	cTab  		- Tabela que será pesquisada
			cCmpoFil   -Nome do campo filial da tabela 
			cCmpPer    -Nome do Campo Período da tabela
			cCmpConsol -Nome do campos de consolidação da tabela 
			lData     - Indica se deverá fazer comparação com data menor/maior e igual ou somente igual
						
@return Alias já processado.
@author Erick G. Dias
@since 
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function A001QRYCON(cTab,cCmpoFil,cCmpPer,cCmpConsol,lData)

Local cAlias			:= ''
Local 		cSlct		:= ''
Local 		cFiltro	:= ''
Local 		cFrom		:= ''
Local 		cPerAtu	:= Strzero(Month(MV_PAR01),2)+cvaltochar(Year(MV_PAR01))
Default	lData 		:= .T.

DbSelectArea (cTab)

cSlct:= cTab+'.*'

cFiltro := cCmpoFil + "= '"+ xFilial(cTAb)+ "' AND "

IF lData
	cFiltro += cCmpPer + " >= '" +  %Exp:DToS (MV_PAR01)% + "' AND "
	cFiltro += cCmpPer + " <= '" +  %Exp:DToS (MV_PAR02)% + "' AND "
Else
	cFiltro += cCmpPer + " = '" +  cPerAtu + "' AND "
EndIF

cFiltro += cCmpConsol + " = '2' AND " //somente irá trazer os individualizados.

cFiltro+=	cTab+".D_E_L_E_T_=''"

cFrom	:=	RetSqlName(cTab)+" " + cTab

cSlct := '%'+cSlct+'%'
cFiltro := '%'+cFiltro+'%'
cFrom := '%'+cFrom+'%'

cAlias	:=	GetNextAlias()
BeginSql Alias cAlias	
	
	SELECT
	%Exp:cSlct%

	FROM
	%Exp:cFrom%
	WHERE
	%Exp:cFiltro%

EndSql
Return cAlias

//-------------------------------------------------------------------
/*/{Protheus.doc} ProcConFil()

@return Alias já processado.
@author Erick G. Dias
@since 
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function ProcConFil(oProcess,aXFilial,cFilialMat,lIndividu)

Local cAliasRet	:= ''
Local aTab		:= {}
Local lContinue	:= .F.
Local nContTab	:= 0


AADD(aTab,{'CL8','CL8.CL8_FILIAL','CL8.CL8_PER','CL8.CL8_CONSOL'		,STR0088,.T.})//'Créditos'
AADD(aTab,{'CL9','CL9.CL9_FILIAL','CL9.CL9_PER','CL9.CL9_CONSOL'		,STR0089,.T.})//'Créditos Detalhados'
AADD(aTab,{'CLA','CLA.CLA_FILIAL','CLA.CLA_DTREF','CLA.CLA_CONSOL'		,STR0090,.T.})//'Ajustes'
AADD(aTab,{'CKS','CKS.CKS_FILIAL','CKS.CKS_PER','CKS.CKS_CONSOL'		,STR0091,.T.})//'Débitos'
AADD(aTab,{'CKT','CKT.CKT_FILIAL','CKT.CKT_PER','CKT.CKT_CONSOL'		,STR0092,.T.})//'Receitas Não Tributadas'
AADD(aTab,{'CKU','CKU.CKU_FILIAL','CKU.CKU_PER','CKU.CKU_CONSOL'		,STR0093,.T.})//'Totais de Receitas'
AADD(aTab,{'CKV','CKV.CKV_FILIAL','CKV.CKV_PER','CKV.CKV_CONSOL'		,STR0094,.T.})//'CPRB Consolidado'
AADD(aTab,{'CKW','CKW.CKW_FILIAL','CKW.CKW_PER','CKW.CKW_CONSOL'		,STR0095,.T.})//'Ajustes CPRB'
AADD(aTab,{'CKZ','CKZ.CKZ_FILIAL','CKZ.CKZ_PER','CKZ.CKZ_CONSOL'		,'',.T.})
AADD(aTab,{'CL0','CL0.CL0_FILIAL','CL0.CL0_PER','CL0.CL0_CONSOL'		,STR0096,.T.})//'Resumo CST/REgime'
AADD(aTab,{'CL3','CL3.CL3_FILIAL','CL3.CL3_PER','CL3.CL3_CONSOL'		,STR0097,.T.})//'Receita x Vl. Recolher'
AADD(aTab,{'CCY','CCY.CCY_FILIAL','CCY.CCY_PERIOD','CCY.CCY_CONSOL'	,STR0098,.F.})//'Saldo de crédito de PIS'
AADD(aTab,{'CCW','CCW.CCW_FILIAL','CCW.CCW_PERIOD','CCW.CCW_CONSOL'	,STR0099,.F.})
AADD(aTab,{'SFV','SFV.FV_FILIAL','SFV.FV_PER','SFV.FV_CONSOL'			,STR0100,.F.})//'Saldo de retenção de PIS'
AADD(aTab,{'SFW','SFW.FW_FILIAL','SFW.FW_PER','SFW.FW_CONSOL'			,STR0101,.F.}) //'Saldo de retenção da COFINS'
AADD(aTab,{'F2Z','F2Z.F2Z_FILIAL','F2Z.F2Z_PERAPU','F2Z.F2Z_CONSOL'		,STR0094,.T.})//'F2Z Ajuste de redução de PIS e COFINS'

IF ISA001NDIF()
	AADD(aTab,{'CFA','CFA.CFA_FILIAL','CFA.CFA_PERAPU','CFA.CFA_CONSOL'			,'Diferimento do Período',.F.}) //'Diferimento do Período'
	AADD(aTab,{'CFB','CFB.CFB_FILIAL','CFB.CFB_PERAPU','CFB.CFB_CONSOL'			,'Diferimento de Período Anterior',.F.}) //'Diferimento de Período Anterior'
EndIF
If AliasIndic("CIC")
	AADD(aTab,{'CIC','CIC.CIC_FILIAL','CIC.CIC_PER','CIC.CIC_CONSOL'			,"Totais de Receitas",.F.}) //"Totais de Receitas"
EndIF

oProcess:Set2Progress(Len(aTab)+1)

oProcess:Inc2Progress(STR0103,STR0102)//'Consolidação de Apuracao'
cAliasRet	:= A001QRYCON('CKR','CKR.CKR_FILIAL','CKR.CKR_PER','CKR.CKR_CONSOL')
lContinue:= ConsCKR(cAliasRet,aXFilial)

DbSelectArea (cAliasRet)
(cAliasRet)->(DbCloseArea ())

IF lContinue

	For nContTab := 1 to Len(aTab)
		oProcess:Inc2Progress(STR0103, STR0104+ aTab[nContTab][5])//'Consolidação de'
		cAliasRet	:= A001QRYCON(aTab[nContTab][1],aTab[nContTab][2],aTab[nContTab][3],aTab[nContTab][4],aTab[nContTab][6])

		Do case	
			Case aTab[nContTab][1] == 'CL8'
				ConsCL8(cAliasRet,aXFilial)
				
			Case aTab[nContTab][1] == 'CL9'
				ConsCL9(cAliasRet,aXFilial)	

			Case aTab[nContTab][1] == 'CLA'
				ConsCLA(cAliasRet,aXFilial)


			Case aTab[nContTab][1] == 'CKS'
				ConsCKS(cAliasRet,aXFilial)
				
			Case aTab[nContTab][1] == 'CKT'
				ConsCKT(cAliasRet,aXFilial)

			Case aTab[nContTab][1] == 'CIC'
				ConsCIC(cAliasRet,aXFilial)

			Case aTab[nContTab][1] == 'CKU'
				ConsCKU(cAliasRet,aXFilial)
				
			Case aTab[nContTab][1] == 'CKV'
				ConsCKV(cAliasRet,aXFilial,cFilialMat,lIndividu)

			Case aTab[nContTab][1] == 'CKX'
				ConsCKX(cAliasRet,aXFilial)

			Case aTab[nContTab][1] == 'CKZ'
				ConsCKZ(cAliasRet,aXFilial)
				
			Case aTab[nContTab][1] == 'CL0'
				ConsCL0(cAliasRet,aXFilial)

			Case aTab[nContTab][1] == 'CL3'
				ConsCL3(cAliasRet,aXFilial)
				
			Case aTab[nContTab][1] == 'CCY'
				ConsCCY(cAliasRet,aXFilial)	


			Case aTab[nContTab][1] == 'CCW'
				ConsCCW(cAliasRet,aXFilial)	


			Case aTab[nContTab][1] == 'SFV'
				ConsSFV(cAliasRet,aXFilial)	

			Case aTab[nContTab][1] == 'SFW'
				ConsSFW(cAliasRet,aXFilial)
					
			Case aTab[nContTab][1] == 'CFA'
				ConsCFA(cAliasRet,aXFilial)														

			Case aTab[nContTab][1] == 'CFB'
				ConsCFB(cAliasRet,aXFilial)
				
			Case aTab[nContTab][1] == 'F2Z'
				ConsF2Z(cAliasRet,aXFilial)														
		EndCase
			
		DbSelectArea (cAliasRet)
		(cAliasRet)->(DbCloseArea ())
	
	Next nContTab

EndIF

Return

Static Function ConsCKR(cAlias,aXFilial,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabCKR	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cFilMatriz	:= ''
Local cConsol		:= '1'
Local lRet	:= .F.
Local lLivro	:= .F.
Local dtAux		:= CTod("  /  /    ")

DEFAULT dtNewPer	:= CTod("  /  /    ")
DEFAULT lAgrupaT	:= .F.


oTabCKR:setIndice(1)
oTabCKR:setAlias('CKR')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CKR')
TcSetField(cAlias,"CKR_PER","D",8,0)

If CKR->(Fieldpos("CKR_LIVRO")) > 0
	lLivro := .T.
Endif

Do While !(cAlias)->(Eof ())
	
	dtAux		:= (cAlias)->CKR_PER
	If lAgrupaT		
		cConsol		:= '2'
		dtAux	:= dtNewPer		
	EndIF

	If (cAlias)->CKR_STATUS <> '4' .AND. (cAlias)->CKR_CONSOL <> '1'
		//Não irá considerar apurações já consideradas para consolidação e apurações que já são é a consolidada
		lREt	:= .T.
		cChave:= cFilMatriz+DTOS(dtAux) +cConsol+(cAlias)->CKR_TRIB 
	
		oTabCKR:setChave(cChave)
		oTabCKR:Inclui()	
		//Somente passa campos de valores a serem acumulados

		oTabCKR:SetCampo('CKR_FILIAL'  	,cFilMatriz)
		oTabCKR:SetCampo('CKR_PER'  		,dtAux)
		oTabCKR:SetCampo('CKR_TRIB' 		,(cAlias)->CKR_TRIB)
		oTabCKR:SetCampo('CKR_STATUS'   ,(cAlias)->CKR_STATUS)
		oTabCKR:SetCampo('CKR_REGIME'   ,(cAlias)->CKR_REGIME)
		oTabCKR:SetCampo('CKR_CONNC' 	,(cAlias)->CKR_CONNC,lAcumula)	
		oTabCKR:SetCampo('CKR_CRDANT'	,(cAlias)->CKR_CRDANT,lAcumula)	
		oTabCKR:SetCampo('CKR_CRDATU'	,(cAlias)->CKR_CRDATU,lAcumula)	
		oTabCKR:SetCampo('CKR_RTANTN'	,(cAlias)->CKR_RTANTN,lAcumula)	
		oTabCKR:SetCampo('CKR_RTATUN'	,(cAlias)->CKR_RTATUN,lAcumula)	
		oTabCKR:SetCampo('CKR_OUTDNC'	,(cAlias)->CKR_OUTDNC,lAcumula)	
		oTabCKR:SetCampo('CKR_NCREC' 	,(cAlias)->CKR_NCREC,lAcumula)	
		oTabCKR:SetCampo('CKR_CONC'  	,(cAlias)->CKR_CONC,lAcumula)	
		oTabCKR:SetCampo('CKR_RTANTC'	,(cAlias)->CKR_RTANTC,lAcumula)	
		oTabCKR:SetCampo('CKR_RTATUC'	,(cAlias)->CKR_RTATUC,lAcumula)	
		oTabCKR:SetCampo('CKR_OUTDC' 	,(cAlias)->CKR_OUTDC,lAcumula)		
		oTabCKR:SetCampo('CKR_CREC'  	,(cAlias)->CKR_CREC,lAcumula)
		oTabCKR:SetCampo('CKR_CONSOL'   ,cConsol)
		If lLivro
			oTabCKR:SetCampo('CKR_LIVRO'    ,(cAlias)->CKR_LIVRO)
		Endif
		oTabCKR:SetCampo('CKR_DTFIM' ,mv_par02)
	
		oTabCKR:Finaliza()
	
		IF !lAgrupaT .AND. CKR->(MSSEEK( xFilial('CKR')+DTOS((cAlias)->CKR_PER) +'2'+(cAlias)->CKR_TRIB))
			RecLock('CKR',.F.)
			CKR->CKR_STATUS = '4' // Utilizada para consolidação
			MsUnLock()		
		EndIF
	EndIF

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCKR )
oTabCKR:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
	
Return lRet

Static Function ConsCL8(cAlias,aXFilial,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabCL8	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cConsol		:= '1'
Local cFilMatriz	:= ''
Local cChv			:= ''
Local dtAux		:= CTod("  /  /    ")

DEFAULT dtNewPer	:= CTod("  /  /    ")
DEFAULT lAgrupaT	:= .F.

oTabCL8:setIndice(1)
oTabCL8:setAlias('CL8')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CL8')
TcSetField(cAlias,"CL8_PER","D",8,0)

Do While !(cAlias)->(Eof ())

	cChv		:= (cAlias)->CL8_CHV
	dtAux		:= (cAlias)->CL8_PER
	If lAgrupaT
		cChv	:= DTOS(dtNewPer)+ SubStr((cAlias)->CL8_CHV,9)
		dtAux	:= dtNewPer
		cConsol	:= '2'		
	EndIF

	cChave:= cFilMatriz+DTOS(dtAux)+cChv+(cAlias)->CL8_INDCRE+(cAlias)->CL8_CODBCC+(cAlias)->CL8_CST+cConsol

	oTabCL8:setChave(cChave)
	oTabCL8:Inclui()
	
	oTabCL8:SetCampo('CL8_FILIAL' 	,cFilMatriz)	
	oTabCL8:SetCampo('CL8_PER' 		,dtAux)	
	oTabCL8:SetCampo('CL8_CHV' 		,cChv)
	oTabCL8:SetCampo('CL8_CODBCC'	 ,(cAlias)->CL8_CODBCC)	
	oTabCL8:SetCampo('CL8_CST' 		,(cAlias)->CL8_CST)	
	oTabCL8:SetCampo('CL8_TRIB' 		,(cAlias)->CL8_TRIB)
	oTabCL8:SetCampo('CL8_INDCRE'	 ,(cAlias)->CL8_INDCRE)	
	oTabCL8:SetCampo('CL8_BSCALC' 	,(cAlias)->CL8_BSCALC,lAcumula)
	oTabCL8:SetCampo('CL8_VLCRED' 	,(cAlias)->CL8_VLCRED,lAcumula)	
	oTabCL8:SetCampo('CL8_AJAC' 	,(cAlias)->CL8_AJAC,lAcumula)
	oTabCL8:SetCampo('CL8_AJRD' 		,(cAlias)->CL8_AJRD,lAcumula)
	oTabCL8:SetCampo('CL8_DIF' 		,(cAlias)->CL8_DIF,lAcumula)
	oTabCL8:SetCampo('CL8_TOTCRD' ,(cAlias)->CL8_TOTCRD,lAcumula)
	oTabCL8:SetCampo('CL8_CRDUTI' ,(cAlias)->CL8_CRDUTI,lAcumula)
	oTabCL8:SetCampo('CL8_CRDFUT' ,(cAlias)->CL8_CRDFUT,lAcumula)
	oTabCL8:SetCampo('CL8_CONSOL'   ,cConsol)						

	oTabCL8:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCL8 )
oTabCL8:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil

Return

Static Function ConsCLA(cAlias,aXFilial,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabCLA	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cConsol		:= '1'
Local cFilMatriz	:= ''
Local cChv			:= ''
Local dtAux		:= CTod("  /  /    ")

DEFAULT dtNewPer	:= CTod("  /  /    ")
DEFAULT lAgrupaT	:= .F.

oTabCLA:setIndice(1)
oTabCLA:setAlias('CLA')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CLA')
TcSetField(cAlias,"CLA_DTREF","D",8,0)
//TcSetField(cAlias,"CLA_PERUTI","D",8,0)

Do While !(cAlias)->(Eof ())

	cChv		:= (cAlias)->CLA_CHV
	dtAux		:= (cAlias)->CLA_DTREF
	If lAgrupaT
		cChv	:= DTOS(dtNewPer)+ SubStr((cAlias)->CLA_CHV,9)
		dtAux	:= dtNewPer	
		cConsol		:= '2'	
	EndIF

	cChave:= cFilMatriz+cChv+(cAlias)->CLA_TPAJU+(cAlias)->CLA_COD+PAdr((cAlias)->CLA_NUM,50)+DTOS(dtAux)+cConsol+(cAlias)->CLA_DESCR

	oTabCLA:setChave(cChave)
	oTabCLA:Inclui()	
	//Somente passa campos de valores a serem acumulados
	oTabCLA:SetCampo('CLA_FILIAL'		,cFilMatriz)	
	oTabCLA:SetCampo('CLA_CHV'			,cChv)
	oTabCLA:SetCampo('CLA_ID'			,(cAlias)->CLA_ID)
	oTabCLA:SetCampo('CLA_TPAJU'		,(cAlias)->CLA_TPAJU)
	oTabCLA:SetCampo('CLA_VLAJU'		,(cAlias)->CLA_VLAJU,lAcumula)			
	oTabCLA:SetCampo('CLA_COD'			,(cAlias)->CLA_COD)	
	oTabCLA:SetCampo('CLA_NUM'			,(cAlias)->CLA_NUM)
	oTabCLA:SetCampo('CLA_DESCR'		,(cAlias)->CLA_DESCR)
	oTabCLA:SetCampo('CLA_DTREF'		,dtAux)
	oTabCLA:SetCampo('CLA_CTA'			,(cAlias)->CLA_CTA)
	oTabCLA:SetCampo('CLA_PERUTI'		,(cAlias)->CLA_PERUTI)
	If CLA->(FieldPos("CLA_FILORI"))>0
		oTabCLA:SetCampo('CLA_FILORI'	,(cAlias)->CLA_FILORI)
	EndIf
	oTabCLA:SetCampo('CLA_CONSOL'   	,cConsol)	
	
	oTabCLA:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCLA )
oTabCLA:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil



Return

Static Function ConsCKS(cAlias,aXFilial,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabCKS	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cConsol		:= '1'
Local cFilMatriz	:= ''
Local cChv			:= ''
Local dtAux		:= CTod("  /  /    ")
Local lCmpAjuBas := CKS->(FieldPos("CKS_BCAJUS"))>0 

DEFAULT dtNewPer	:= CTod("  /  /    ")
DEFAULT lAgrupaT	:= .F.

oTabCKS:setIndice(1)
oTabCKS:setAlias('CKS')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CKS')
TcSetField(cAlias,"CKS_PER","D",8,0)

Do While !(cAlias)->(Eof ())

	cChv		:= (cAlias)->CKS_CHV
	dtAux		:= (cAlias)->CKS_PER
	If lAgrupaT
		cChv	:= DTOS(dtNewPer)+ SubStr((cAlias)->CKS_CHV,9)
		dtAux	:= dtNewPer
		cConsol		:= '2'		
	EndIF

	cChave:= cFilMatriz+DTOS(dtAux)+cChv+cConsol
	oTabCKS:setChave(cChave)

	oTabCKS:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabCKS:SetCampo('CKS_FILIAL'	 	,cFilMatriz)	
	oTabCKS:SetCampo('CKS_PER'			,dtAux)
	oTabCKS:SetCampo('CKS_CHV' 			,cChv)
	oTabCKS:SetCampo('CKS_TRIB'			,(cAlias)->CKS_TRIB)
	oTabCKS:SetCampo('CKS_PAUTA'		,(cAlias)->CKS_PAUTA)			
	oTabCKS:SetCampo('CKS_VLREC'		,(cAlias)->CKS_VLREC,lAcumula)	
	oTabCKS:SetCampo('CKS_BASE'			,(cAlias)->CKS_BASE,lAcumula)

	If lCmpAjuBas
		oTabCKS:SetCampo('CKS_AJBCA'	,(cAlias)->CKS_AJBCA,lAcumula)
		oTabCKS:SetCampo('CKS_AJBCR'	,(cAlias)->CKS_AJBCR,lAcumula)
		oTabCKS:SetCampo('CKS_BCAJUS'	,(cAlias)->CKS_BCAJUS,lAcumula)
	EndIf

	oTabCKS:SetCampo('CKS_VLTRIB' 		,(cAlias)->CKS_VLTRIB,lAcumula)
	oTabCKS:SetCampo('CKS_AJAC' 		,(cAlias)->CKS_AJAC,lAcumula)
	oTabCKS:SetCampo('CKS_AJRD' 	   	,(cAlias)->CKS_AJRD,lAcumula)
	oTabCKS:SetCampo('CKS_DIF'		    ,(cAlias)->CKS_DIF,lAcumula)
	oTabCKS:SetCampo('CKS_DIFANT'		,(cAlias)->CKS_DIFANT,lAcumula)
	oTabCKS:SetCampo('CKS_VLDISP'		,(cAlias)->CKS_VLDISP,lAcumula)
	oTabCKS:SetCampo('CKS_CONSOL'   	,cConsol)	

	oTabCKS:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCKS )
oTabCKS:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil

Return

Static Function ConsCKU(cAlias,aXFilial,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabCKU	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cConsol		:= '1'
Local cFilMatriz	:= ''
Local dtAux		:= CTod("  /  /    ")

DEFAULT dtNewPer	:= CTod("  /  /    ")
DEFAULT lAgrupaT	:= .F.

oTabCKU:setIndice(1)
oTabCKU:setAlias('CKU')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CKU')
TcSetField(cAlias,"CKU_PER","D",8,0)

Do While !(cAlias)->(Eof ())
	
	dtAux		:= (cAlias)->CKU_PER
	If lAgrupaT	
		dtAux	:= dtNewPer	
		cConsol		:= '2'	
	EndIF


	cChave:= cFilMatriz+DTOS(dtAux)+cConsol
	oTabCKU:setChave(cChave)

	oTabCKU:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabCKU:SetCampo('CKU_FILIAL'	 	,cFilMatriz)	
	oTabCKU:SetCampo('CKU_PER'			,dtAux)
	oTabCKU:SetCampo('CKU_RTNC' 		,(cAlias)->CKU_RTNC,lAcumula)
	oTabCKU:SetCampo('CKU_RNTNC'		,(cAlias)->CKU_RNTNC,lAcumula)
	oTabCKU:SetCampo('CKU_EXP'			,(cAlias)->CKU_EXP,lAcumula)			
	oTabCKU:SetCampo('CKU_RTC'			,(cAlias)->CKU_RTC,lAcumula)
	oTabCKU:SetCampo('CKU_CONSOL'   	,cConsol)		


	oTabCKU:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCKU )
oTabCKU:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return

Static Function ConsCIC(cAlias,aXFilial,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabCIC	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cConsol		:= '1'
Local cFilMatriz	:= ''
Local dtAux		:= CTod("  /  /    ")

DEFAULT dtNewPer	:= CTod("  /  /    ")
DEFAULT lAgrupaT	:= .F.

oTabCIC:setIndice(1)
oTabCIC:setAlias('CIC')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CIC')
TcSetField(cAlias,"CIC_PER","D",8,0)

Do While !(cAlias)->(Eof ())
	
	dtAux		:= (cAlias)->CIC_PER
	If lAgrupaT	
		dtAux	:= dtNewPer	
		cConsol		:= '2'	
	EndIF


	cChave:= cFilMatriz+DTOS(dtAux)+cConsol+(cAlias)->CIC_BLOCO
	oTabCIC:setChave(cChave)

	oTabCIC:Inclui()	
	
	//Somente passa campos de valores a serem acumulados
	oTabCIC:SetCampo('CIC_FILIAL'	,cFilMatriz)
	oTabCIC:SetCampo('CIC_PER'		,dtAux)
	oTabCIC:SetCampo('CIC_CONSOL' 	,cConsol)
	oTabCIC:SetCampo('CIC_BLOCO'	,(cAlias)->CIC_BLOCO)
	oTabCIC:SetCampo('CIC_REC'		,(cAlias)->CIC_REC,lAcumula)
	oTabCIC:SetCampo('CIC_RECNB'   	,(cAlias)->CIC_RECNB,lAcumula)


	oTabCIC:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCIC )
oTabCIC:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return

//
Static Function ConsCKT(cAlias,aXFilial,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabCKT	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cConsol		:= '1'
Local cFilMatriz	:= ''
Local dtAux		:= CTod("  /  /    ")
Local nTamCONTA	:= TamSx3("CKT_CONTA")[1]

DEFAULT dtNewPer	:= CTod("  /  /    ")
DEFAULT lAgrupaT	:= .F.

oTabCKT:setIndice(1)
oTabCKT:setAlias('CKT')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CKT')
TcSetField(cAlias,"CKT_PER","D",8,0)

Do While !(cAlias)->(Eof ())
	
	dtAux		:= (cAlias)->CKT_PER
	If lAgrupaT	
		dtAux	:= dtNewPer
		cConsol		:= '2'		
	EndIF	

	cChave:= cFilMatriz+dTos(dtAux)+(cAlias)->CKT_TRIB+(cAlias)->CKT_CST+(cAlias)->CKT_CODNAT+PADR((cAlias)->CKT_CONTA,nTamCONTA)+cConsol+(cAlias)->CKT_ORIGEM
	oTabCKT:setChave(cChave)

	oTabCKT:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabCKT:SetCampo('CKT_FILIAL'	 	,cFilMatriz)	
	oTabCKT:SetCampo('CKT_PER'			,dtAux)
	oTabCKT:SetCampo('CKT_TRIB' 		,(cAlias)->CKT_TRIB)
	oTabCKT:SetCampo('CKT_CST'			,(cAlias)->CKT_CST)
	oTabCKT:SetCampo('CKT_CODNAT'		,(cAlias)->CKT_CODNAT)			
	oTabCKT:SetCampo('CKT_VLREC'		,(cAlias)->CKT_VLREC,lAcumula)
	oTabCKT:SetCampo('CKT_CONTA'       ,(cAlias)->CKT_CONTA)
	oTabCKT:SetCampo('CKT_DESCR'		,(cAlias)->CKT_DESCR)	
	oTabCKT:SetCampo('CKT_CONSOL'		,cConsol)
	oTabCKT:SetCampo('CKT_ORIGEM'		,(cAlias)->CKT_ORIGEM)
	
	oTabCKT:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCKT )
oTabCKT:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return
//
Static Function ConsCL9(cAlias,aXFilial,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabCL9	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cConsol		:= '1'
Local cFilMatriz	:= ''
Local dtAux		:= CTod("  /  /    ")
Local cChv			:= ''
DEFAULT dtNewPer	:= CTod("  /  /    ")
DEFAULT lAgrupaT	:= .F.

oTabCL9:setIndice(1)
oTabCL9:setAlias('CL9')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CL9')
TcSetField(cAlias,"CL9_PER","D",8,0)

Do While !(cAlias)->(Eof ())
	
	cChv		:= (cAlias)->CL9_CHV
	dtAux		:= (cAlias)->CL9_PER
	If lAgrupaT
		cChv	:= DTOS(dtNewPer)+ SubStr((cAlias)->CL9_CHV,9)
		dtAux	:= dtNewPer
		cConsol	:= '2'			
	EndIF	
	
	cChave:= cFilMatriz+dTos(dtAux)+cChv+(cAlias)->CL9_CODBCC+(cAlias)->CL9_CST+(cAlias)->CL9_PAUTA+cConsol
	oTabCL9:setChave(cChave)

	oTabCL9:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabCL9:SetCampo('CL9_FILIAL'	 	,cFilMatriz)	
	oTabCL9:SetCampo('CL9_PER'			,dtAux)
	oTabCL9:SetCampo('CL9_CHV' 			,cChv)
	oTabCL9:SetCampo('CL9_CODBCC' 		,(cAlias)->CL9_CODBCC)
	oTabCL9:SetCampo('CL9_CST' 			,(cAlias)->CL9_CST)	
	oTabCL9:SetCampo('CL9_PAUTA' 		,(cAlias)->CL9_PAUTA)	
	oTabCL9:SetCampo('CL9_TOTBSE' 		,(cAlias)->CL9_TOTBSE,lAcumula)	
	oTabCL9:SetCampo('CL9_BSCUM' 		,(cAlias)->CL9_BSCUM,lAcumula)	
	oTabCL9:SetCampo('CL9_BSNCUM' 		,(cAlias)->CL9_BSNCUM,lAcumula)	
	oTabCL9:SetCampo('CL9_BSTCRD' 		,(cAlias)->CL9_BSTCRD,lAcumula)
	oTabCL9:SetCampo('CL9_DESCR' 		,(cAlias)->CL9_DESCR)
	oTabCL9:SetCampo('CL9_CONSOL' 		,cConsol)	
	
	oTabCL9:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCL9 )
oTabCL9:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return

Static Function ConsCKV(cAlias,aXFilial,cFilialMat,lIndividu,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabCKV	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cConsol		:= '1'
Local cFilMatriz	:= ''
Local dtAux			:= CTod("  /  /    ")
Local lFilApu		:= CKV->(FieldPos('CKV_FILAPU')) > 0

DEFAULT lAgrupaT := .F.
DEFAULT dtNewPer := CTod("  /  /    ")
DEFAULT cFilialMat := ""
DEFAULT lIndividu := .F.

oTabCKV:setIndice(1)
oTabCKV:setAlias('CKV')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CKV')
TcSetField(cAlias,"CKV_PER","D",8,0)

Do While !(cAlias)->(Eof ())
	
	
	dtAux	:= (cAlias)->CKV_PER
	
	If lAgrupaT		
		dtAux	:= dtNewPer
		cConsol	:= '2'			
	EndIF	
	
	cChave:= cFilMatriz+DTOS(dtAux)+(cAlias)->CKV_COD+cConsol
	oTabCKV:setChave(cChave)

	oTabCKV:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabCKV:SetCampo('CKV_FILIAL'	 	,cFilMatriz)	
	oTabCKV:SetCampo('CKV_PER'			,dtAux)
	oTabCKV:SetCampo('CKV_COD' 			,(cAlias)->CKV_COD)
	oTabCKV:SetCampo('CKV_TOTAP'		,(cAlias)->CKV_TOTAP,lAcumula)
	oTabCKV:SetCampo('CKV_AJAC'			,(cAlias)->CKV_AJAC,lAcumula)			
	oTabCKV:SetCampo('CKV_AJRD'			,(cAlias)->CKV_AJRD,lAcumula)
	oTabCKV:SetCampo('CKV_VLREC' 		,(cAlias)->CKV_VLREC,lAcumula)
	oTabCKV:SetCampo('CKV_RECBRU' 		,(cAlias)->CKV_RECBRU,lAcumula)
	oTabCKV:SetCampo('CKV_RECATI' 		,(cAlias)->CKV_RECATI,lAcumula)
	oTabCKV:SetCampo('CKV_EXCLU' 		,(cAlias)->CKV_EXCLU,lAcumula)
	oTabCKV:SetCampo('CKV_BASE' 		,(cAlias)->CKV_BASE,lAcumula)
	oTabCKV:SetCampo('CKV_CONSOL'   	,cConsol)
	If lFilApu
		oTabCKV:SetCampo('CKV_FILAPU'   	,IIf(lIndividu,oEFDGen:BuscaxFil('CKV'),cFilialMat)) 
	Endif
	
	oTabCKV:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCKV )
oTabCKV:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return


//ckx
Static Function ConsCKX(cAlias,aXFilial,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabCKX	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cFilMatriz	:= ''
Local dtAux		:= CTod("  /  /    ")
Local lNTrib 	:= CKX->(FieldPos('CKX_NTRIB'))>0 

DEFAULT lAgrupaT := .F.
DEFAULT dtNewPer := CTod("  /  /    ")

oTabCKX:setIndice(1)
oTabCKX:setAlias('CKX')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CKX')
TcSetField(cAlias,"CKX_PER","D",8,0)

Do While !(cAlias)->(Eof ())

	dtAux	:= (cAlias)->CKX_PER
	
	If lAgrupaT		
		dtAux	:= dtNewPer		
	EndIF	

	cChave:= cFilMatriz+DTOS(dtAux)+(cAlias)->CKX_CODATI+(cAlias)->CKX_CODREC+STR((cAlias)->CKX_ALIQ,8,4)
	oTabCKX:setChave(cChave)

	oTabCKX:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabCKX:SetCampo('CKX_FILIAL'	 	,cFilMatriz)	
	oTabCKX:SetCampo('CKX_PER'			,dtAux)
	oTabCKX:SetCampo('CKX_CODATI' 		,(cAlias)->CKX_CODATI)
	oTabCKX:SetCampo('CKX_CODREC'		,(cAlias)->CKX_CODREC)
	oTabCKX:SetCampo('CKX_VLBRUT'		,(cAlias)->CKX_VLBRUT,lAcumula)			
	oTabCKX:SetCampo('CKX_VLATI'		,(cAlias)->CKX_VLATI,lAcumula)
	oTabCKX:SetCampo('CKX_EXCLU' 		,(cAlias)->CKX_EXCLU,lAcumula)
	oTabCKX:SetCampo('CKX_BASE' 			,(cAlias)->CKX_BASE,lAcumula)
	oTabCKX:SetCampo('CKX_ALIQ'			,(cAlias)->CKX_ALIQ)
	oTabCKX:SetCampo('CKX_VLCPRB'		,(cAlias)->CKX_VLCPRB,lAcumula)			
	oTabCKX:SetCampo('CKX_CONTA'		,(cAlias)->CKX_CONTA)
	oTabCKX:SetCampo('CKX_INFORM' 		,(cAlias)->CKX_INFORM)	
	
	If lNTrib
		oTabCKX:SetCampo('CKX_NTRIB'   	,(cAlias)->CKX_NTRIB)
	Endif

	oTabCKX:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCKX )
oTabCKX:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return


Static Function ConsCKZ(cAlias,aXFilial,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabCKZ	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cConsol		:= '1'
Local cFilMatriz	:= ''
Local cID			:= ''
Local dtAux		:= CTod("  /  /    ")

DEFAULT dtNewPer	:= CTod("  /  /    ")
DEFAULT lAgrupaT	:= .F.
oTabCKZ:setIndice(1)
oTabCKZ:setAlias('CKZ')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CKZ')
TcSetField(cAlias,"CKZ_PER","D",8,0)

Do While !(cAlias)->(Eof ())
	
	
	cID		:= (cAlias)->CKZ_ID
	dtAux	:=(cAlias)->CKZ_PER
	If lAgrupaT
		cID		:= DTOS(dtNewPer)+ SubStr((cAlias)->CKZ_ID,9)
		dtAux	:= dtNewPer
		cConsol		:= '2'
		
	EndIF	
	 	 	
	cChave:= cFilMatriz+DTOS(dtAux)+(cAlias)->CKZ_REGIME+cID+cConsol
	oTabCKZ:setChave(cChave)

	oTabCKZ:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabCKZ:SetCampo('CKZ_FILIAL'	 	,cFilMatriz)	
	oTabCKZ:SetCampo('CKZ_PER'			,dtAux)
	oTabCKZ:SetCampo('CKZ_TRIB' 		,(cAlias)->CKZ_TRIB)
	oTabCKZ:SetCampo('CKZ_ALIQ'			,(cAlias)->CKZ_ALIQ)
	oTabCKZ:SetCampo('CKZ_COD'			,(cAlias)->CKZ_COD)			
	oTabCKZ:SetCampo('CKZ_ORIGEM'		,(cAlias)->CKZ_ORIGEM)
	oTabCKZ:SetCampo('CKZ_REGIME' 		,(cAlias)->CKZ_REGIME)
	oTabCKZ:SetCampo('CKZ_DEBCRD' 		,(cAlias)->CKZ_DEBCRD)
	oTabCKZ:SetCampo('CKZ_ID'			,cID)
	oTabCKZ:SetCampo('CKZ_CONSOL'   	,cConsol)	

	oTabCKZ:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCKZ )
oTabCKZ:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return

Static Function ConsCL0(cAlias,aXFilial,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabCL0	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cFilMatriz	:= ''
Local cConsol		:= '1'
Local dtAux		:= CTod("  /  /    ")

DEFAULT dtNewPer	:= CTod("  /  /    ")
DEFAULT lAgrupaT	:= .F.

oTabCL0:setIndice(1)
oTabCL0:setAlias('CL0')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CL0')
TcSetField(cAlias,"CL0_PER","D",8,0)

Do While !(cAlias)->(Eof ())
	
	dtAux		:= (cAlias)->CL0_PER
	If lAgrupaT
		dtAux	:= dtNewPer	
		cConsol		:= '2'
	EndIF

	cChave:= cFilMatriz+DTOS(dtAux)+(cAlias)->CL0_CST+cConsol+(cAlias)->CL0_ORIGEM
	oTabCL0:setChave(cChave)

	oTabCL0:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabCL0:SetCampo('CL0_FILIAL'	 	,cFilMatriz)	
	oTabCL0:SetCampo('CL0_PER'			,dtAux)
	oTabCL0:SetCampo('CL0_CST' 			,(cAlias)->CL0_CST)
	oTabCL0:SetCampo('CL0_BASENC'		,(cAlias)->CL0_BASENC,lAcumula)
	oTabCL0:SetCampo('CL0_VLOPNC'		,(cAlias)->CL0_VLOPNC,lAcumula)			
	oTabCL0:SetCampo('CL0_BASEC'		,(cAlias)->CL0_BASEC,lAcumula)
	oTabCL0:SetCampo('CL0_VLOPC' 		,(cAlias)->CL0_VLOPC,lAcumula)
	oTabCL0:SetCampo('CL0_ORIGEM' 		,(cAlias)->CL0_ORIGEM)	
	oTabCL0:SetCampo('CL0_CONSOL'   	,cConsol)	

	oTabCL0:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCL0 )
oTabCL0:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return

Static Function ConsCL3(cAlias,aXFilial,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabCL3	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cFilMatriz	:= ''
Local cConsol		:= '1'
Local dtAux		:= CTod("  /  /    ")

DEFAULT dtNewPer	:= CTod("  /  /    ")
DEFAULT lAgrupaT	:= .F.

TcSetField(cAlias,"CL3_PER","D",8,0)
TcSetField(cAlias,"CL3_DTVENC","D",8,0)

oTabCL3:setIndice(1)
oTabCL3:setAlias('CL3')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CL3')

Do While !(cAlias)->(Eof ())
	
	dtAux		:= (cAlias)->CL3_PER
	If lAgrupaT		
		dtAux	:= dtNewPer
		cConsol		:= '2'		
	EndIF

	cChave:= cFilMatriz+DTOS(dtAux)+(cAlias)->CL3_TRIB+cConsol+(cAlias)->CL3_CODREC

	oTabCL3:setChave(cChave)

	oTabCL3:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabCL3:SetCampo('CL3_FILIAL'	 	,cFilMatriz)	
	oTabCL3:SetCampo('CL3_PER'			,dtAux)
	oTabCL3:SetCampo('CL3_TRIB' 		,(cAlias)->CL3_TRIB)
	oTabCL3:SetCampo('CL3_CODREC'		,(cAlias)->CL3_CODREC)
	oTabCL3:SetCampo('CL3_VALOR'		,(cAlias)->CL3_VALOR,lAcumula)			
	oTabCL3:SetCampo('CL3_DTVENC'		,(cAlias)->CL3_DTVENC)
	oTabCL3:SetCampo('CL3_CONSOL'   	,cConsol)	

	oTabCL3:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCL3 )
oTabCL3:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} ConsF3J()

@Description Função que realiza a consolidação da tabela F3J quando processada
por multithread
@author Erick G. Dias
@since 09/05/17
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function ConsF3J(cAlias,aXFilial,lAgrupaT,dtNewPer)

Local cChave	:=''
Local oTabF3J	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cFilMatriz	:= ''
Local cConsol		:= '1'
Local dtAux		:= CTod("  /  /    ")

DEFAULT dtNewPer	:= CTod("  /  /    ")
DEFAULT lAgrupaT	:= .F.

TcSetField(cAlias,"F3J_PER","D",8,0)

oTabF3J:setIndice(1)
oTabF3J:setAlias('F3J')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('F3J')

Do While !(cAlias)->(Eof ())
	
	dtAux		:= (cAlias)->F3J_PER
	If lAgrupaT		
		dtAux	:= dtNewPer
		cConsol		:= '2'		
	EndIF	

	cChave:= cFilMatriz+DTOS(dtAux)+(cAlias)->F3J_CODREC+cConsol

	oTabF3J:setChave(cChave)

	oTabF3J:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabF3J:SetCampo('F3J_FILIAL'	 	,cFilMatriz)	
	oTabF3J:SetCampo('F3J_PER'			,dtAux)
	oTabF3J:SetCampo('F3J_CODREC' 		,(cAlias)->F3J_CODREC)
	oTabF3J:SetCampo('F3J_VLTRIB'		,(cAlias)->F3J_VLTRIB,lAcumula)
	oTabF3J:SetCampo('F3J_CONSOL'		,cConsol)			
		

	oTabF3J:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabF3J )
oTabF3J:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return

Static Function ConsCCY(cAlias,aXFilial)

Local cChave	:=''
Local oTabCCY	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cFilMatriz	:= ''
Local cConsol		:= '1'
lOCAL oSaldoCred	
 
oSaldoCred:= SALDOCRED():New()
oSaldoCred:SetConsol(cConsol)
oSaldoCred:SetFilial(aXFilial)
oSaldoCred:SetDtIni(mv_par01)
oSaldoCred:SetTributo(PIS)
oSaldoCred:SetPer(Strzero(Month(mv_par01),2)+cvaltochar(Year(mv_par01)))

//Função inibida pois ao chamar a LimpaSaldo quando se esta agrupando filiais a Matriz, no momento que eu vou processar a 2º filial do array aSM0 ele deleta o registro da 1º filial  
//fazendo com que os valores não sejam aglutinados.
//oSaldoCred:LimpaSaldo() //Limpa tabela de saldos somente do período  

oSaldoCred:= Nil

oTabCCY:setIndice(5)
oTabCCY:setAlias('CCY')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CCY')

Do While !(cAlias)->(Eof ())

	cChave:= cFilMatriz+(cAlias)->CCY_PERIOD+(cAlias)->CCY_ANO+(cAlias)->CCY_MES+(cAlias)->CCY_ORICRE+(cAlias)->CCY_CNPJ+(cAlias)->CCY_COD+cConsol

	oTabCCY:setChave(cChave)

	oTabCCY:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabCCY:SetCampo('CCY_FILIAL'	 	,cFilMatriz)	
	oTabCCY:SetCampo('CCY_PERIOD'		,(cAlias)->CCY_PERIOD)
	oTabCCY:SetCampo('CCY_REFER ' 		,(cAlias)->CCY_REFER)
	oTabCCY:SetCampo('CCY_COD'			,(cAlias)->CCY_COD)
	oTabCCY:SetCampo('CCY_UTIANT'		,(cAlias)->CCY_UTIANT,lAcumula)			
	oTabCCY:SetCampo('CCY_TOTCRD'		,(cAlias)->CCY_TOTCRD,lAcumula)
	oTabCCY:SetCampo('CCY_CREDUT'   	,(cAlias)->CCY_CREDUT,lAcumula)
	oTabCCY:SetCampo('CCY_CRDISP'   	,(cAlias)->CCY_CRDISP,lAcumula)
	oTabCCY:SetCampo('CCY_LEXTEM'   	,(cAlias)->CCY_LEXTEM,lAcumula)
	oTabCCY:SetCampo('CCY_ANO'		   	,(cAlias)->CCY_ANO)
	oTabCCY:SetCampo('CCY_MES'   		,(cAlias)->CCY_MES)
	oTabCCY:SetCampo('CCY_REANTE'   	,(cAlias)->CCY_REANTE,lAcumula)
	oTabCCY:SetCampo('CCY_COANTE'   	,(cAlias)->CCY_COANTE,lAcumula)
	oTabCCY:SetCampo('CCY_RESSA'	   	,(cAlias)->CCY_RESSA,lAcumula)
	oTabCCY:SetCampo('CCY_COMP'	   		,(cAlias)->CCY_COMP,lAcumula)
	oTabCCY:SetCampo('CCY_CNPJ' 		  	,(cAlias)->CCY_CNPJ)
	oTabCCY:SetCampo('CCY_ORICRE'   	,(cAlias)->CCY_ORICRE)					
	oTabCCY:SetCampo('CCY_CONSOL'   	,cConsol)	
	oTabCCY:SetCampo('CCY_FILAPU'	 	,cFilMatriz)
	oTabCCY:SetCampo('CCY_RESCRE'	 	,IIf(CCY->(FieldPos('CCY_RESCRE'))>0,(cAlias)->CCY_RESCRE,"2"))

	oTabCCY:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCCY )
oTabCCY:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return

Static Function ConsCCW(cAlias,aXFilial)

Local cChave	:=''
Local oTabCCW	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cFilMatriz	:= ''
Local cConsol		:= '1'

Local oSaldoCred	
 
oSaldoCred:= SALDOCRED():New()
oSaldoCred:SetConsol(cConsol)
oSaldoCred:SetFilial(aXFilial)
oSaldoCred:SetDtIni(mv_par01)
oSaldoCred:SetTributo(COFINS)
oSaldoCred:SetPer(Strzero(Month(mv_par01),2)+cvaltochar(Year(mv_par01)))

//Função inibida pois ao chamar a LimpaSaldo quando se esta agrupando filiais a Matriz, no momento que eu vou processar a 2º filial do array aSM0 ele deleta o registro da 1º filial  
//fazendo com que os valores não sejam aglutinados.se
//oSaldoCred:LimpaSaldo() //Limpa tabela de saldos somente do período

oSaldoCred:= Nil

oTabCCW:setIndice(5)
oTabCCW:setAlias('CCW')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CCW')

Do While !(cAlias)->(Eof ())

	cChave:= cFilMatriz+(cAlias)->CCW_PERIOD+(cAlias)->CCW_ANO+(cAlias)->CCW_MES+(cAlias)->CCW_ORICRE+(cAlias)->CCW_CNPJ+(cAlias)->CCW_COD+cConsol

	oTabCCW:setChave(cChave)

	oTabCCW:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabCCW:SetCampo('CCW_FILIAL'	 	,cFilMatriz)	
	oTabCCW:SetCampo('CCW_PERIOD'		,(cAlias)->CCW_PERIOD)
	oTabCCW:SetCampo('CCW_REFER ' 		,(cAlias)->CCW_REFER)
	oTabCCW:SetCampo('CCW_COD'			,(cAlias)->CCW_COD)
	oTabCCW:SetCampo('CCW_UTIANT'		,(cAlias)->CCW_UTIANT,lAcumula)			
	oTabCCW:SetCampo('CCW_TOTCRD'		,(cAlias)->CCW_TOTCRD,lAcumula)
	oTabCCW:SetCampo('CCW_CREDUT'   	,(cAlias)->CCW_CREDUT,lAcumula)
	oTabCCW:SetCampo('CCW_CRDISP'   	,(cAlias)->CCW_CRDISP,lAcumula)
	oTabCCW:SetCampo('CCW_LEXTEM'   	,(cAlias)->CCW_LEXTEM,lAcumula)
	oTabCCW:SetCampo('CCW_ANO'		   	,(cAlias)->CCW_ANO)
	oTabCCW:SetCampo('CCW_MES'   		,(cAlias)->CCW_MES)
	oTabCCW:SetCampo('CCW_REANTE'   	,(cAlias)->CCW_REANTE,lAcumula)
	oTabCCW:SetCampo('CCW_COANTE'   	,(cAlias)->CCW_COANTE,lAcumula)
	oTabCCW:SetCampo('CCW_RESSA'	   	,(cAlias)->CCW_RESSA,lAcumula)
	oTabCCW:SetCampo('CCW_COMP'	   		,(cAlias)->CCW_COMP,lAcumula)
	oTabCCW:SetCampo('CCW_CNPJ' 		  	,(cAlias)->CCW_CNPJ)
	oTabCCW:SetCampo('CCW_ORICRE'   	,(cAlias)->CCW_ORICRE)					
	oTabCCW:SetCampo('CCW_CONSOL'   	,cConsol)
	oTabCCW:SetCampo('CCW_RESCRE'	 	,IIf(CCW->(Fieldpos('CCW_RESCRE'))>0,(cAlias)->CCW_RESCRE,"2"))	

	oTabCCW:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCCW )
oTabCCW:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return

Static Function ConsSFV(cAlias,aXFilial)

Local cChave	:=''
Local oTabSFV	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cFilMatriz	:= ''
Local cConsol		:= '1'
Local lFV_RESSA		:=	SFV->( FieldPos( "FV_RESSA"  ) ) > 0
Local lFV_COMP		:=	SFV->( FieldPos( "FV_COMP"   ) ) > 0
Local lFV_RESRET	:=	SFV->( FieldPos( "FV_RESRET" ) ) > 0

oTabSFV:setIndice(2)
oTabSFV:setAlias('SFV')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('SFV')

Do While !(cAlias)->(Eof ())
	
	cChave:= cFilMatriz+(cAlias)->FV_NATRET+(cAlias)->FV_TPREG+(cAlias)->FV_PER+(cAlias)->FV_MESANO+cConsol

	oTabSFV:setChave(cChave)

	oTabSFV:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabSFV:SetCampo('FV_FILIAL'	 	,cFilMatriz)	
	oTabSFV:SetCampo('FV_NATRET'		,(cAlias)->FV_NATRET)
	oTabSFV:SetCampo('FV_PER' 			,(cAlias)->FV_PER)
	oTabSFV:SetCampo('FV_TOTRET'		,(cAlias)->FV_TOTRET,lAcumula)
	oTabSFV:SetCampo('FV_VLDISP'		,(cAlias)->FV_VLDISP,lAcumula)			
	oTabSFV:SetCampo('FV_TPREG'			,(cAlias)->FV_TPREG)
	oTabSFV:SetCampo('FV_MESANO'   		,(cAlias)->FV_MESANO)
	oTabSFV:SetCampo('FV_APURPER'   	,(cAlias)->FV_APURPER,lAcumula)
	oTabSFV:SetCampo('FV_CONSOL'   		,cConsol)	

	If lFV_RESSA .And. lFV_COMP .And. lFV_RESRET
		oTabSFV:SetCampo('FV_RESSA'		,(cAlias)->FV_RESSA,lAcumula)
		oTabSFV:SetCampo('FV_COMP'		,(cAlias)->FV_COMP,lAcumula)
		oTabSFV:SetCampo('FV_RESRET'	,(cAlias)->FV_RESRET)
	EndIf

	oTabSFV:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabSFV )
oTabSFV:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return

Static Function ConsSFW(cAlias,aXFilial)

Local cChave	:=''
Local oTabSFW	:= TABELAEFD():New()
Local oEFDGen	:= EFDGEN():New()
Local lAcumula	:= .T.
Local cFilMatriz	:= ''
Local cConsol		:= '1'
Local lFW_RESSA		:=	SFW->( FieldPos( "FW_RESSA"  ) ) > 0
Local lFW_COMP		:=	SFW->( FieldPos( "FW_COMP"   ) ) > 0
Local lFW_RESRET	:=	SFW->( FieldPos( "FW_RESRET" ) ) > 0

oTabSFW:setIndice(2)
oTabSFW:setAlias('SFW')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('SFW')

Do While !(cAlias)->(Eof ())
	
	cChave:= cFilMatriz+(cAlias)->FW_NATRET+(cAlias)->FW_TPREG+(cAlias)->FW_PER+(cAlias)->FW_MESANO+cConsol

	oTabSFW:setChave(cChave)

	oTabSFW:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabSFW:SetCampo('FW_FILIAL'	 	,cFilMatriz)	
	oTabSFW:SetCampo('FW_NATRET'		,(cAlias)->FW_NATRET)
	oTabSFW:SetCampo('FW_PER' 			,(cAlias)->FW_PER)
	oTabSFW:SetCampo('FW_TOTRET'		,(cAlias)->FW_TOTRET,lAcumula)
	oTabSFW:SetCampo('FW_VLDISP'		,(cAlias)->FW_VLDISP,lAcumula)			
	oTabSFW:SetCampo('FW_TPREG'			,(cAlias)->FW_TPREG)
	oTabSFW:SetCampo('FW_MESANO'   		,(cAlias)->FW_MESANO)
	oTabSFW:SetCampo('FW_APURPER'   	,(cAlias)->FW_APURPER,lAcumula)
	oTabSFW:SetCampo('FW_CONSOL'   		,cConsol)	

	If lFW_RESSA .And. lFW_COMP .And. lFW_RESRET
		oTabSFW:SetCampo('FW_RESSA'		,(cAlias)->FW_RESSA,lAcumula)
		oTabSFW:SetCampo('FW_COMP'		,(cAlias)->FW_COMP,lAcumula)
		oTabSFW:SetCampo('FW_RESRET'	,(cAlias)->FW_RESRET)
	EndIf

	oTabSFW:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabSFW )
oTabSFW:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return


//CFA
Static Function ConsCFA(cAlias,aXFilial)

Local cChave		:=''
Local oTabCFA		:= TABELAEFD():New()
Local oEFDGen		:= EFDGEN():New()
Local lAcumula		:= .T.
Local cFilMatriz	:= ''
Local cConsol		:= '1'

oTabCFA:setIndice(1)
oTabCFA:setAlias('CFA')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CFA')

Do While !(cAlias)->(Eof ())                                                            
	
	cChave:= cFilMatriz+(cAlias)->CFA_PERAPU+(cAlias)->CFA_TPCON+(cAlias)->CFA_CODCON+(cAlias)->CFA_CNPJ+STR((cAlias)->CFA_ALIQ,5,2)+(cAlias)->CFA_CODCRE+cConsol

	oTabCFA:setChave(cChave)

	oTabCFA:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabCFA:SetCampo('CFA_FILIAL'	 	,cFilMatriz)		
	oTabCFA:SetCampo('CFA_CODCON'		,(cAlias)->CFA_CODCON)
	oTabCFA:SetCampo('CFA_TPCON ' 		,(cAlias)->CFA_TPCON)
	oTabCFA:SetCampo('CFA_CNPJ  '		,(cAlias)->CFA_CNPJ)
	oTabCFA:SetCampo('CFA_TOTVEN'		,(cAlias)->CFA_TOTVEN,lAcumula)			
	oTabCFA:SetCampo('CFA_TOTDIF'		,(cAlias)->CFA_TOTDIF,lAcumula)
	oTabCFA:SetCampo('CFA_CONDIF'   	,(cAlias)->CFA_CONDIF,lAcumula)
	oTabCFA:SetCampo('CFA_CREDIF'   	,(cAlias)->CFA_CREDIF,lAcumula)	
	oTabCFA:SetCampo('CFA_ALIQ  '   	,(cAlias)->CFA_ALIQ)
	oTabCFA:SetCampo('CFA_CODCRE'   	,(cAlias)->CFA_CODCRE)
	oTabCFA:SetCampo('CFA_CONREC'   	,(cAlias)->CFA_CONREC,lAcumula)
	oTabCFA:SetCampo('CFA_VLRREC'   	,(cAlias)->CFA_VLRREC,lAcumula)
	oTabCFA:SetCampo('CFA_VLNREC'   	,(cAlias)->CFA_VLNREC,lAcumula)
	oTabCFA:SetCampo('CFA_PERAPU'   	,(cAlias)->CFA_PERAPU)
	oTabCFA:SetCampo('CFA_CONSOL'   	,cConsol)	

	oTabCFA:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCFA )
oTabCFA:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return

//CFB
Static Function ConsCFB(cAlias,aXFilial)

Local cChave		:=''
Local oTabCFB		:= TABELAEFD():New()
Local oEFDGen		:= EFDGEN():New()
Local lAcumula		:= .T.
Local cFilMatriz	:= ''
Local cConsol		:= '1'

oTabCFB:setIndice(1)
oTabCFB:setAlias('CFB')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('CFB')
TcSetField(cAlias,"CFB_DTPGTO","D",8,0)
Do While !(cAlias)->(Eof ())
	                                                                 
	cChave:= cFilMatriz+(cAlias)->CFB_PERAPU+(cAlias)->CFB_TPCON+(cAlias)->CFB_CODCON+(cAlias)->CFB_PERDIF+ DTOS((cAlias)->CFB_DTPGTO )+ STR((cAlias)->CFB_ALIQ,5,2)+(cAlias)->CFB_NATCRE +cConsol

	oTabCFB:setChave(cChave)

	oTabCFB:Inclui()	

	//Somente passa campos de valores a serem acumulados
	oTabCFB:SetCampo('CFB_FILIAL'	 	,cFilMatriz)		
	oTabCFB:SetCampo('CFB_CODCON'		,(cAlias)->CFB_CODCON)
	oTabCFB:SetCampo('CFB_TPCON' 		,(cAlias)->CFB_TPCON)
	oTabCFB:SetCampo('CFB_VLRREC'		,(cAlias)->CFB_VLRREC,lAcumula)
	oTabCFB:SetCampo('CFB_CONREC'		,(cAlias)->CFB_CONREC,lAcumula)			
	oTabCFB:SetCampo('CFB_PERDIF'		,(cAlias)->CFB_PERDIF)
	oTabCFB:SetCampo('CFB_DTPGTO'   	,(cAlias)->CFB_DTPGTO)
	oTabCFB:SetCampo('CFB_NATCRE'   	,(cAlias)->CFB_NATCRE)	
	oTabCFB:SetCampo('CFB_CREDES'   	,(cAlias)->CFB_CREDES,lAcumula)
	oTabCFB:SetCampo('CFB_PERAPU'   	,(cAlias)->CFB_PERAPU)
	oTabCFB:SetCampo('CFB_ALIQ  '   	,(cAlias)->CFB_ALIQ)
	oTabCFB:SetCampo('CFB_CONSOL'  		,cConsol)	

	oTabCFB:Finaliza()

	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabCFB )
oTabCFB:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return

Static Function ConsF2Z(cAlias,aXFilial,cFilialMat,lIndividu,lAgrupaT,dtNewPer)

Local cChave     := ''
Local lAcumula   := .T.
Local cFilMatriz := ''
Local cConsol    := '1'
Local oTabF2Z    := TABELAEFD():New()
Local oEFDGen    := EFDGEN()   :New()
Local dtAux      := CtoD("  /  /    ")

DEFAULT dtNewPer	:= CTod("  /  /    ")
DEFAULT lAgrupaT	:= .F.

oTabF2Z:setIndice(1) // F2Z_FILIAL+DTOS(F2Z_PERAPU)+F2Z_TRIB+F2Z_INDAJU+F2Z_CHV+F2Z_ID
oTabF2Z:setAlias('F2Z')
oEFDGen:SetFilial(aXFilial) 
cFilMatriz := oEFDGen:BuscaxFil('F2Z')
TcSetField(cAlias,"F2Z_DTREF","D",8,0)
TcSetField(cAlias,"F2Z_PERAPU","D",8,0)

Do While !(cAlias)->(Eof ())
	
	IF (cAlias)->F2Z_ORIG == '2' //Indica a origem automática do sistema/apuração		
		
		If Empty(dtNewPer) 
			dtNewPer := (cAlias)->F2Z_PERAPU
		EndIf
		cID			:= DTOS(dtNewPer)+ SubStr((cAlias)->F2Z_ID,9)
		cChv		:= (cAlias)->F2Z_CHV
		dtAux		:= (cAlias)->F2Z_DTREF

		If lAgrupaT	
			cID		:= DTOS(dtNewPer)+ SubStr((cAlias)->F2Z_ID,9)
			cChv	:= DTOS(dtNewPer)+ SubStr((cAlias)->F2Z_CHV,9)
			dtAux	:= dtNewPer
			cConsol	:= '2'		
		EndIF	
         
		cChave:= cFilMatriz+dTos(dtAux)+(cAlias)->F2Z_TRIB+(cAlias)->F2Z_INDAJU
		
		F2Z->(DbSetOrder(1) ) //F2Z_FILIAL+DTOS(F2Z_PERAPU)+F2Z_TRIB+F2Z_INDAJU+F2Z_CHV+F2Z_ID
		//se ja existir não gravo novamente para não duplicar o registro M215 e M615
		If !F2Z->(DbSeek(cFilMatriz + DTOS((cAlias)->F2Z_PERAPU)+(cAlias)->F2Z_TRIB+(cAlias)->F2Z_INDAJU+(cAlias)->F2Z_CHV )) .OR. cFilMatriz <> (cAlias)->F2Z_FILIAL
			
			If (cAlias)->F2Z_CODAJU <> F2Z->F2Z_CODAJU 
				cChave := cChv  // Se for codigo de ajuste e tiver a mesma chave não deve somar
			EndIf		
			oTabF2Z:setChave(cChave)

			oTabF2Z:Inclui()	

			//Somente passa campos de valores a serem acumulados
			oTabF2Z:SetCampo('F2Z_FILIAL'	, cFilMatriz)
			oTabF2Z:SetCampo('F2Z_CHV'		, cChv)
			oTabF2Z:SetCampo('F2Z_ID'		, cID)
			oTabF2Z:SetCampo('F2Z_INDAJU'	, (cAlias)->F2Z_INDAJU)		
			oTabF2Z:SetCampo('F2Z_VALAJU'	, (cAlias)->F2Z_VALAJU, lAcumula)
			oTabF2Z:SetCampo('F2Z_CODAJU'	, (cAlias)->F2Z_CODAJU)		
			oTabF2Z:SetCampo('F2Z_NUM'		, (cAlias)->F2Z_NUM)		
			oTabF2Z:SetCampo('F2Z_DESCR'	, (cAlias)->F2Z_DESCR)		
			oTabF2Z:SetCampo('F2Z_DTREF'	, dtAux)		
			oTabF2Z:SetCampo('F2Z_PERAPU'	, (cAlias)->F2Z_PERAPU)		
			oTabF2Z:SetCampo('F2Z_CONTA'	, (cAlias)->F2Z_CONTA)		
			oTabF2Z:SetCampo('F2Z_CNPJ'		, (cAlias)->F2Z_CNPJ)		
			oTabF2Z:SetCampo('F2Z_COMPL'	, (cAlias)->F2Z_COMPL)		
			oTabF2Z:SetCampo('F2Z_TRIB'		, (cAlias)->F2Z_TRIB)		
			oTabF2Z:SetCampo('F2Z_CODCON'	, (cAlias)->F2Z_CODCON)		
			oTabF2Z:SetCampo('F2Z_ORIG'		, '2')		
			oTabF2Z:SetCampo('F2Z_CONSOL'	, cConsol)
			
			oTabF2Z:Finaliza()

		EndIf	
			
	Endif
	(cAlias)->(DbSkip ())			
EndDo

FreeObj( oTabF2Z )
oTabF2Z:= Nil

FreeObj( oEFDGen )
oEFDGen:= Nil
Return


//-------------------------------------------------------------------
/*/{Protheus.doc} AjusteCPRB
 
 Função que irá chamar o ponto de entrada SPEDCP210 e trazer os valores 
 de ajustes da CPRB. Estes valores erão excluídos da tabela de CPRB consolidada CKX,
 e deverá ser chamada somente quando apuração for processada de maneira consolidada.
 
@author Erick G. Dias
@since 30/07/2014
@version 11.80

/*/
//-------------------------------------------------------------------

Static Function AjusteCPRB(dDataDe,dDataAte,aSM0,cFilialMat,lindividu)

Local aAreaSM0 	:= SM0->(GetArea())
Local aRegPE210 	:= {}
Local nP210	   	:= 0	
Local oCPRB		:= CPRBEFD():New()

If ExistBlock('SPEDCP210')
	aRegPE210 := ExecBlock("SPEDCP210", .F., .F.,{ dDataDe, dDataAte, aSm0,mv_par16  ,mv_par17 }  )
ElseIf CF5->(FieldPos('CF5_TIPATV')) > 0	
	aRegPE210 := FSA001CPRB(dDataDe,dDataAte)
Endif	

RestArea (aAreaSM0)

For nP210 := 1 to Len(aRegPE210)
	oCPRB:SetConsol('2')
	oCPRB:SetDtIni(MV_PAR01)
	oCPRB:SetCodRec(aRegPE210[nP210][7])
	oCPRB:SetTpAju(Iif(aRegPE210[nP210][1] == '0',REDUCAO ,ACRESCIMO ))
	oCPRB:SetValAju(aRegPE210[nP210][2])
	oCPRB:SetCodAjus(aRegPE210[nP210][3])
	oCPRB:SetNumero(aRegPE210[nP210][4])
	oCPRB:SetDescr(aRegPE210[nP210][5])		
	oCPRB:SetDtRefer(ctod(substr(aRegPE210[nP210][6],1,2) +'/'+ substr(aRegPE210[nP210][6],3,2) +'/'+ substr(aRegPE210[nP210][6],5,4)))		
	oCPRB:SetFilApu(IIf(lIndividu,oCPRB:BuscaxFil('CKR'),cFilialMat))  
	oCPRB:GravaAju()
	oCPRB:AtualizaCPRB()
	oCPRB:Clear()
Next nP210


Return

//-------------------------------------------------------------------
/*/{Protheus.doc} ReprocEFD
 
Função que irá realizar o reprocessamento da EFD, conforme opções
selecionadas pelo usuário na tela inicial da apuração.
 
@author Erick G. Dias
@since 30/07/2014
@version 11.80

/*/
//-------------------------------------------------------------------
Static Function ReprocEFD(dDataDe,dDataAte,cConsl,aReprocess,aXFilialRe)

	Local aReproc	:= {}
	Local nCont
	Local oEFDGen	:= EFDGEN():New()
	oEFDGen:SetFilApu(FWGETCODFILIAL)

	oEFDGen:SetFilial(aXFilialRe)

	Aadd(aReproc,{FISCALENT		,Iif(aReprocess[1] == 1,.T.,.F.)})
	Aadd(aReproc,{FISCALSAI		,Iif(aReprocess[2] == 1,.T.,.F.)})
	Aadd(aReproc,{TITENTRADA	,Iif(aReprocess[3] == 1,.T.,.F.)})
	Aadd(aReproc,{TITSAIDA		,Iif(aReprocess[4] == 1,.T.,.F.)})
	Aadd(aReproc,{ATIVOFIXO		,Iif(aReprocess[5] == 1,.T.,.F.)})
	Aadd(aReproc,{CUPOM			,Iif(aReprocess[6] == 1,.T.,.F.)})
	Aadd(aReproc,{CPRB			,Iif(aReprocess[7] == 1,.T.,.F.)})
	Aadd(aReproc,{OUTROS			,.T.})

	For nCont := 1 to len(aReproc)		
		Do Case
		
			Case aReproc[nCont][2] .AND. aReproc[nCont][1] == FISCALENT
				ISA001CL8(dDataDe,dDataAte,FISCALENT,cConsl,oEFDGen)
							
			Case aReproc[nCont][2] .AND. aReproc[nCont][1] == FISCALSAI
				ISA001CKS(dDataDe,dDataAte,FISCALSAI,cConsl,oEFDGen)			

			Case aReproc[nCont][2] .AND. aReproc[nCont][1] == TITENTRADA
				ISA001CL8(dDataDe,dDataAte,TITENTRADA,cConsl,oEFDGen)	
				ISA001CL2(dDataDe,dDataAte,TITENTRADA,cConsl,'F100',oEFDGen)

			Case aReproc[nCont][2] .AND. aReproc[nCont][1] == TITSAIDA
				ISA001CKS(dDataDe,dDataAte,TITSAIDA,cConsl,oEFDGen)	
				ISA001CL2(dDataDe,dDataAte,TITSAIDA,cConsl,'F100',oEFDGen)			
				
			Case aReproc[nCont][2] .AND. aReproc[nCont][1] == ATIVOFIXO
				ISA001CL8(dDataDe,dDataAte,ATIVOFIXO,cConsl,oEFDGen)
				ISA001CL2(dDataDe,dDataAte,ATIVOFIXO,cConsl,'F120',oEFDGen)
				ISA001CL2(dDataDe,dDataAte,ATIVOFIXO,cConsl,'F130',oEFDGen)
				
			Case aReproc[nCont][2] .AND. aReproc[nCont][1] == CUPOM
				ISA001CKS(dDataDe,dDataAte,CUPOM,cConsl,oEFDGen)
				
			Case aReproc[nCont][2] .AND. aReproc[nCont][1] == OUTROS
				ISA001CL8(dDataDe,dDataAte,OUTROS,cConsl,oEFDGen)
				ISA001CKS(dDataDe,dDataAte,OUTROS,cConsl,oEFDGen)			
				
			Case aReproc[nCont][2] .AND. aReproc[nCont][1] == CPRB
				ISA001CKV(dDataDe,dDataAte,CPRB,cConsl,oEFDGen)
						
		EndCase
		
	Next nCont

	ZeraCKS(dDataDe,dDataAte,cConsl,oEFDGen)
	ZeraCL8(dDataDe,dDataAte,cConsl,oEFDGen)

	FreeObj( oEFDGen )
	oEFDGen:= Nil

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} ISA001CKZ
 
Função que irá buscar os valores da tabela CKZ, para que a partir da chave
desta tabela possa ir reprocessando somente as informações solicitadas
pelo usuário na tela de reprocessamento.
 

@author Erick G. Dias
@return	cAliasCKZ  - Resultado da query da CKZ.
@since 05/08/2014
@version 11.80

/*/
//-------------------------------------------------------------------

Static Function ISA001CKZ(dDataDe,dDataAte,cFilCKZ,cConsl,cOrigem)

Local cAliasCKZ	:= 'CKZ'
Local cSlctCKZ	:= ''
Local cFiltro		:= ''

cSlctCKZ:= '%CKZ.CKZ_ID%'

cFiltro := "%"
cFiltro += "CKZ.CKZ_FILIAL= '"+ cFilCKZ+ "' AND "
cFiltro += "CKZ.CKZ_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
cFiltro += "CKZ.CKZ_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "
cFiltro += "CKZ.CKZ_ORIGEM = '" +cOrigem + "' AND "
cFiltro += "CKZ.CKZ_CONSOL = '" +cConsl + "' AND "
cFiltro += "%"

cAliasCKZ	:=	GetNextAlias()
BeginSql Alias cAliasCKZ
    	
	SELECT
	%Exp:cSlctCKZ%

	FROM
	%Table:CKZ% CKZ	
	WHERE
	%Exp:cFiltro%
	CKZ.%NotDel%

EndSql

Return cAliasCKZ



Static Function ISA001CL8(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)


Local cAliasCL8	:= ''
Local cCampos	:= ''
Local cFiltro	:= ''

Local cSubQuery	:= ''

cSubQuery := "select CKZ.CKZ_ID FROM " +  RetSqlName('CKZ')+ " CKZ WHERE "
cSubQuery += "(CKZ_ORIGEM = '" + cOrigem + "' OR CKZ_ORIGEM = ' ') AND CKZ_PER >= '" + dTos(dDataDe) + "' "
cSubQuery += " AND CKZ_PER <=  '" + dTos(dDataAte) + "' AND CKZ.CKZ_CONSOL = '" +cConsl + "' AND D_E_L_E_T_ <> '*'"

cCampos	:= '%CL8.CL8_CHV ,CL8.R_E_C_N_O_ as NRECNO%'

cFiltro := "%"
cFiltro += "CL8.CL8_FILIAL= '"+ oEFDGen:BuscaxFil('CL8')+ "' AND "
cFiltro += "CL8.CL8_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
cFiltro += "CL8.CL8_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "
cFiltro += ' CL8.CL8_CHV IN  (' + cSubQuery + ') AND '
cFiltro += "CL8.CL8_CONSOL = '" +cConsl + "' AND "

cFiltro += "%"
cAliasCL8	:=	GetNextAlias()

BeginSql Alias cAliasCL8
    	
	SELECT
	%Exp:cCampos%

	FROM
	%Table:CL8% CL8	
	WHERE
	%Exp:cFiltro%
	CL8.%NotDel%

EndSql

Do While !(cAliasCL8)->(EOF())
	CL8->(dbGoto((cAliasCL8)->NRECNO))		
	RecLock("CL8",.F.)
	CL8->(dbDelete())
	MsUnLock()
	CL8->(FKCommit())
	(cAliasCL8)->(DBSKIP())
EndDo		


DbSelectArea (cAliasCL8)
(cAliasCL8)->(DbCloseArea ())

ISA001CL9(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)
ISA001CL0(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)

Return




Static Function ISA001CKS(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)


Local cAliasCKS	:= ''
Local cCampos	:= ''
Local cFiltro	:= ''

Local cSubQuery	:= ''

cSubQuery := "select CKZ.CKZ_ID FROM " +  RetSqlName('CKZ')+ " CKZ WHERE "
cSubQuery += "(CKZ_ORIGEM = '" + cOrigem + "' OR CKZ_ORIGEM = ' ' )AND CKZ_PER >= '" + dTos(dDataDe) + "' "
cSubQuery += " AND CKZ_PER <=  '" + dTos(dDataAte) + "' AND CKZ.CKZ_CONSOL = '" +cConsl + "' AND D_E_L_E_T_ <> '*'"

cCampos	:= '%CKS.CKS_CHV ,CKS.R_E_C_N_O_ as NRECNO%'

cFiltro := "%"
cFiltro += "CKS.CKS_FILIAL= '"+ oEFDGen:BuscaxFil('CKS')+ "' AND "
cFiltro += "CKS.CKS_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
cFiltro += "CKS.CKS_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "
cFiltro += ' CKS.CKS_CHV IN  (' + cSubQuery + ') AND '
cFiltro += "CKS.CKS_CONSOL = '" +cConsl + "' AND "

cFiltro += "%"
cAliasCKS	:=	GetNextAlias()

BeginSql Alias cAliasCKS
    	
	SELECT
	%Exp:cCampos%

	FROM
	%Table:CKS% CKS	
	WHERE
	%Exp:cFiltro%
	CKS.%NotDel%

EndSql

Do While !(cAliasCKS)->(EOF())
	CKS->(dbGoto((cAliasCKS)->NRECNO))		
	RecLock("CKS",.F.)
	CKS->(dbDelete())
	MsUnLock()
	CKS->(FKCommit())
	(cAliasCKS)->(DBSKIP())
EndDo		


DbSelectArea (cAliasCKS)
(cAliasCKS)->(DbCloseArea ())


ISA001CL9(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)
ISA001CL0(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)
ISA001CKU(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)
ISA001CKT(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)

Return


Static Function ISA001CL9(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)


Local cAliasCL9	:= ''
Local cCampos	:= ''
Local cFiltro	:= ''

Local cSubQuery	:= ''

cSubQuery := "select CKZ.CKZ_ID FROM " +  RetSqlName('CKZ')+ " CKZ WHERE "
cSubQuery += "(CKZ_ORIGEM = '" + cOrigem + "' OR CKZ_ORIGEM = ' ' )AND CKZ_PER >= '" + dTos(dDataDe) + "' "
cSubQuery += " AND CKZ_PER <=  '" + dTos(dDataAte) + "' AND CKZ.CKZ_CONSOL = '" +cConsl + "' AND D_E_L_E_T_ <> '*'"

cCampos	:= '%CL9.CL9_CHV ,CL9.R_E_C_N_O_ as NRECNO%'

cFiltro := "%"
cFiltro += "CL9.CL9_FILIAL= '"+ oEFDGen:BuscaxFil('CL9')+ "' AND "
cFiltro += "CL9.CL9_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
cFiltro += "CL9.CL9_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "
cFiltro += ' CL9.CL9_CHV IN  (' + cSubQuery + ') AND '
cFiltro += "CL9.CL9_CONSOL = '" +cConsl + "' AND "

cFiltro += "%"
cAliasCL9	:=	GetNextAlias()

BeginSql Alias cAliasCL9
    	
	SELECT
	%Exp:cCampos%

	FROM
	%Table:CL9% CL9	
	WHERE
	%Exp:cFiltro%
	CL9.%NotDel%

EndSql

Do While !(cAliasCL9)->(EOF())
	CL9->(dbGoto((cAliasCL9)->NRECNO))		
	RecLock("CL9",.F.)
	CL9->(dbDelete())
	MsUnLock()
	CL9->(FKCommit())
	(cAliasCL9)->(DBSKIP())
EndDo		


DbSelectArea (cAliasCL9)
(cAliasCL9)->(DbCloseArea ())

Return

Static Function ISA001CLA(dDataDe,dDataAte,cOrigem,cConsl,aXFilial)


Local cAliasCLA	:= ''
Local cCampos	:= ''
Local cFiltro	:= ''

Local cSubQuery	:= ''
Local oEFDGen	:= EFDGEN():New()
oEFDGen:SetFilial(aXFilial)


cSubQuery := "select CKZ.CKZ_ID FROM " +  RetSqlName('CKZ')+ " CKZ WHERE "
cSubQuery += "CKZ_PER >= '" + dTos(dDataDe) + "' "
cSubQuery += " AND CKZ_PER <=  '" + dTos(dDataAte) + "' AND CKZ.CKZ_CONSOL = '" +cConsl + "' AND D_E_L_E_T_ <> '*'"

cCampos	:= '%CLA.CLA_CHV ,CLA.R_E_C_N_O_ as NRECNO%'

cFiltro := "%"
cFiltro += "CLA.CLA_FILIAL= '"+ oEFDGen:BuscaxFil('CLA')+ "' AND "
cFiltro += ' CLA.CLA_CHV IN  (' + cSubQuery + ') AND '
cFiltro += "CLA.CLA_CONSOL = '" +cConsl + "' AND "

cFiltro += "%"
cAliasCLA	:=	GetNextAlias()

BeginSql Alias cAliasCLA
    	
	SELECT
	%Exp:cCampos%

	FROM
	%Table:CLA% CLA	
	WHERE
	%Exp:cFiltro%
	CLA.%NotDel%

EndSql

Do While !(cAliasCLA)->(EOF())
	CLA->(dbGoto((cAliasCLA)->NRECNO))		
	RecLock("CLA",.F.)
	CLA->(dbDelete())
	MsUnLock()
	CLA->(FKCommit())
	(cAliasCLA)->(DBSKIP())
EndDo		

DbSelectArea (cAliasCLA)
(cAliasCLA)->(DbCloseArea ())

ISA001CL4(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)

Return

Static Function ISA001CL4(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)


Local cAliasCL4	:= ''
Local cCampos	:= ''
Local cFiltro	:= ''

Local cSubQuery	:= ''

cSubQuery := "select CKZ.CKZ_ID FROM " +  RetSqlName('CKZ')+ " CKZ WHERE "
cSubQuery += " CKZ_PER >= '" + dTos(dDataDe) + "' "
cSubQuery += " AND CKZ_PER <=  '" + dTos(dDataAte) + "' AND CKZ.CKZ_CONSOL = '" +cConsl + "' AND D_E_L_E_T_ <> '*'"

cCampos	:= '%CL4.CL4_CHV ,CL4.R_E_C_N_O_ as NRECNO%'

cFiltro := "%"
cFiltro += "CL4.CL4_FILIAL= '"+ oEFDGen:BuscaxFil('CL4')+ "' AND "
cFiltro += ' CL4.CL4_CHV IN  (' + cSubQuery + ') AND '

cFiltro += "%"
cAliasCL4	:=	GetNextAlias()

BeginSql Alias cAliasCL4
    	
	SELECT
	%Exp:cCampos%

	FROM
	%Table:CL4% CL4	
	WHERE
	%Exp:cFiltro%
	CL4.%NotDel%

EndSql

Do While !(cAliasCL4)->(EOF())
	CL4->(dbGoto((cAliasCL4)->NRECNO))		
	RecLock("CL4",.F.)
	CL4->(dbDelete())
	MsUnLock()
	CL4->(FKCommit())
	(cAliasCL4)->(DBSKIP())
EndDo		


DbSelectArea (cAliasCL4)
(cAliasCL4)->(DbCloseArea ())

Return

Static Function ISA001CKV(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)

Local cAliasCKV	:= ''
Local cCampos		:= ''
Local cFiltro		:= ''

ISA001CKW(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)


cCampos	:= '%CKV.CKV_COD ,CKV.R_E_C_N_O_ as NRECNO%'

cFiltro := "%"
cFiltro += "CKV.CKV_FILIAL= '"+ oEFDGen:BuscaxFil('CKV')+ "' AND "
cFiltro += "CKV.CKV_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
cFiltro += "CKV.CKV_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "

cFiltro += "%"
cAliasCKV	:=	GetNextAlias()

BeginSql Alias cAliasCKV
    	
	SELECT
	%Exp:cCampos%

	FROM
	%Table:CKV% CKV	
	WHERE
	%Exp:cFiltro%
	CKV.%NotDel%

EndSql

Do While !(cAliasCKV)->(EOF())
	CKV->(dbGoto((cAliasCKV)->NRECNO))		
	RecLock("CKV",.F.)
	CKV->(dbDelete())
	MsUnLock()
	CKV->(FKCommit())
	(cAliasCKV)->(DBSKIP())
EndDo		


DbSelectArea (cAliasCKV)
(cAliasCKV)->(DbCloseArea ())

Return

Static Function ISA001CKW(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)

Local cAliasCKW	:= ''
Local cCampos		:= ''
Local cFiltro		:= ''

Local cSubQuery	:= ''

cSubQuery := "select CKV.CKV_COD FROM " +  RetSqlName('CKV')+ " CKV WHERE "
cSubQuery += "CKV_PER >= '" + dTos(dDataDe) + "' "
cSubQuery += "AND CKV_PER <=  '" + dTos(dDataAte) + "' AND D_E_L_E_T_ <> '*'"

cCampos	:= '%CKW.CKW_CODREC ,CKW.R_E_C_N_O_ as NRECNO%'

cFiltro := "%"
cFiltro += "CKW.CKW_FILIAL= '"+ oEFDGen:BuscaxFil('CKW')+ "' AND "
cFiltro += "CKW.CKW_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
cFiltro += "CKW.CKW_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "
cFiltro += 'CKW.CKW_CODREC IN  (' + cSubQuery + ') AND '
cFiltro += "CKW.CKW_CONSOL = '" +cConsl + "' AND "

cFiltro += "%"
cAliasCKW	:=	GetNextAlias()

BeginSql Alias cAliasCKW
    	
	SELECT
	%Exp:cCampos%

	FROM
	%Table:CKW% CKW	
	WHERE
	%Exp:cFiltro%
	CKW.%NotDel%

EndSql

Do While !(cAliasCKW)->(EOF())
	CKW->(dbGoto((cAliasCKW)->NRECNO))		
	RecLock("CKW",.F.)
	CKW->(dbDelete())
	MsUnLock()
	CKW->(FKCommit())
	(cAliasCKW)->(DBSKIP())
EndDo		


DbSelectArea (cAliasCKW)
(cAliasCKW)->(DbCloseArea ())

Return

Static Function ISA001CKX(dDataDe,dDataAte)

Local cAliasCKX	:= ''
Local cCampos		:= ''
Local cFiltro		:= ''

cCampos := '%CKX.R_E_C_N_O_ as NRECNO%'
cFiltro := "%"
cFiltro += "CKX.CKX_FILIAL= '"+ xFilial("CKX") + "' AND "
cFiltro += "CKX.CKX_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
cFiltro += "CKX.CKX_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "
cFiltro += "CKX.CKX_FILAPU = ' ' AND "
cFiltro += "%"

cAliasCKX	:=	GetNextAlias()

BeginSql Alias cAliasCKX
    	
	SELECT
	%Exp:cCampos%

	FROM
	%Table:CKX% CKX	
	WHERE
	%Exp:cFiltro%
	CKX.%NotDel%

EndSql

Do While !(cAliasCKX)->(EOF())
	CKX->(dbGoto((cAliasCKX)->NRECNO))		
	RecLock("CKX",.F.)
	CKX->(dbDelete())
	MsUnLock()
	CKX->(FKCommit())
	(cAliasCKX)->(DBSKIP())
EndDo		


DbSelectArea (cAliasCKX)
(cAliasCKX)->(DbCloseArea ())

Return

Static Function ISA001F3Z(dDataDe,dDataAte,aSM0)

Local cAliasF3Z		:= ''
Local cCampos		:= ''
Local cFiltro		:= ''
Local cIn			:= ''
Local x				:= 0

DEFAULT aSM0		:= {} 

For x:=1 to Len(aSM0)

	cIn += "'"+SubStr(aSM0[x][2], 1, TamSX3("F3Z_FILIAL")[1])+"'"
	
	If x != Len(aSM0)
		cIn += ', '
	EndIf
Next

cIn := '('+cIn+')'

cCampos := '%F3Z.R_E_C_N_O_ as NRECNO%'
cFiltro := "%"
cFiltro += "F3Z.F3Z_FILIAL= '"+ xFilial("F3Z") + "' AND "
cFiltro += "F3Z.F3Z_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
cFiltro += "F3Z.F3Z_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "
cFiltro += "F3Z.F3Z_FILAPU IN "+cIn+" AND "
cFiltro += "%"

cAliasF3Z	:=	GetNextAlias()

BeginSql Alias cAliasF3Z
    	
	SELECT
	%Exp:cCampos%

	FROM
	%Table:F3Z% F3Z	
	WHERE
	%Exp:cFiltro%
	F3Z.%NotDel%

EndSql

Do While !(cAliasF3Z)->(EOF())
	F3Z->(dbGoto((cAliasF3Z)->NRECNO))		
	RecLock("F3Z",.F.)
	F3Z->(dbDelete())
	MsUnLock()
	F3Z->(FKCommit())
	(cAliasF3Z)->(DBSKIP())
EndDo		


DbSelectArea (cAliasF3Z)
(cAliasF3Z)->(DbCloseArea ())

Return

Static Function ISA001CL2(dDataDe,dDataAte,cOrigem,cConsl,cReg,oEFDGen) 

Local cAliasCL2	:= ''
Local cCampos		:= ''
Local cFiltro		:= ''

cCampos	:= '%CL2.R_E_C_N_O_ as NRECNO%'

cFiltro := "%"
cFiltro += "CL2.CL2_FILAPU = '"+  xFilial("CL2")+ "' AND " //cFiltro += "CL2.CL2_FILIAL = '"+ oEFDGen:BuscaxFil('CL2')+ "' AND " , Nesse momento sempre vou recuperar a FILIAL que estou posicionado com isso preciso selecionar somente a FILAPU da selecionada e deletar para gerar novamente.
cFiltro += "CL2.CL2_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
cFiltro += "CL2.CL2_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "
cFiltro += "CL2.CL2_REG = '" + cReg + "' AND "
cFiltro += "%"

cAliasCL2	:=	GetNextAlias()

BeginSql Alias cAliasCL2
    	
	SELECT
	%Exp:cCampos%

	FROM
	%Table:CL2% CL2	
	WHERE
	%Exp:cFiltro%
	CL2.%NotDel%

EndSql

Do While !(cAliasCL2)->(EOF())
	CL2->(dbGoto((cAliasCL2)->NRECNO))		
	RecLock("CL2",.F.)
	CL2->(dbDelete())
	MsUnLock()
	CL2->(FKCommit())
	(cAliasCL2)->(DBSKIP())
EndDo		


DbSelectArea (cAliasCL2)
(cAliasCL2)->(DbCloseArea ())

ISA001CL0(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)
ISA001CKU(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)
ISA001CKT(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)

Return


Static Function ISA001CKT(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)

Local cAliasCKT	:= ''
Local cCampos		:= ''
Local cFiltro		:= ''

cCampos	:= '%CKT.R_E_C_N_O_ as NRECNO%'

cFiltro := "%"
cFiltro += "CKT.CKT_FILIAL= '"+ oEFDGen:BuscaxFil('CKT')+ "' AND "
cFiltro += "CKT.CKT_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
cFiltro += "CKT.CKT_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "
cFiltro += "CKT.CKT_ORIGEM= '" + cOrigem + "' AND "

cFiltro += "%"
cAliasCKT	:=	GetNextAlias()

BeginSql Alias cAliasCKT
    	
	SELECT
	%Exp:cCampos%

	FROM
	%Table:CKT% CKT	
	WHERE
	%Exp:cFiltro%
	CKT.%NotDel%

EndSql

Do While !(cAliasCKT)->(EOF())
	CKT->(dbGoto((cAliasCKT)->NRECNO))		
	RecLock("CKT",.F.)
	CKT->(dbDelete())
	MsUnLock()
	CKT->(FKCommit())
	(cAliasCKT)->(DBSKIP())
EndDo		


DbSelectArea (cAliasCKT)
(cAliasCKT)->(DbCloseArea ())

Return

Static Function ISA001CKU(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)

Local cAliasCKU	:= ''
Local cCampos		:= ''
Local cFiltro		:= ''

cCampos	:= '%CKU.R_E_C_N_O_ as NRECNO%'

cFiltro := "%"
cFiltro += "CKU.CKU_FILIAL= '"+ oEFDGen:BuscaxFil('CKU')+ "' AND "
cFiltro += "CKU.CKU_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
cFiltro += "CKU.CKU_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "
cFiltro += "(CKU.CKU_ORIGEM= '" + cOrigem + "' OR CKU.CKU_ORIGEM = ' ') AND "

cFiltro += "%"
cAliasCKU	:=	GetNextAlias()

BeginSql Alias cAliasCKU
    	
	SELECT
	%Exp:cCampos%

	FROM
	%Table:CKU% CKU	
	WHERE
	%Exp:cFiltro%
	CKU.%NotDel%

EndSql

Do While !(cAliasCKU)->(EOF())
	CKU->(dbGoto((cAliasCKU)->NRECNO))		
	RecLock("CKU",.F.)
	CKU->(dbDelete())
	MsUnLock()
	CKU->(FKCommit())
	(cAliasCKU)->(DBSKIP())
EndDo		


DbSelectArea (cAliasCKU)
(cAliasCKU)->(DbCloseArea ())

Return



Static Function ISA001CL0(dDataDe,dDataAte,cOrigem,cConsl,oEFDGen)

Local cAliasCL0	:= ''
Local cCampos		:= ''
Local cFiltro		:= ''

cCampos	:= '%CL0.R_E_C_N_O_ as NRECNO%'

cFiltro := "%"
cFiltro += "CL0.CL0_FILIAL= '"+ oEFDGen:BuscaxFil('CL0')+ "' AND "
cFiltro += "CL0.CL0_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
cFiltro += "CL0.CL0_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "
cFiltro += "(CL0.CL0_ORIGEM= '" + cOrigem + "' or CL0.CL0_ORIGEM = ' '  ) AND "

cFiltro += "%"
cAliasCL0	:=	GetNextAlias()

BeginSql Alias cAliasCL0
    	
	SELECT
	%Exp:cCampos%

	FROM
	%Table:CL0% CL0	
	WHERE
	%Exp:cFiltro%
	CL0.%NotDel%

EndSql

Do While !(cAliasCL0)->(EOF())
	CL0->(dbGoto((cAliasCL0)->NRECNO))		
	RecLock("CL0",.F.)
	CL0->(dbDelete())
	MsUnLock()
	CL0->(FKCommit())
	(cAliasCL0)->(DBSKIP())
EndDo		


DbSelectArea (cAliasCL0)
(cAliasCL0)->(DbCloseArea ())

Return


Static Function ALIASREPRO(cOpcao)

Local aAlias	:= {}

IF cOpcao == '1'
	//Reprocessamento
	AAdd(aAlias,{'CKR',.T.	 })//apaga
	AAdd(aAlias,{'CL1',.T.    })//apaga	
	If AliasINdic('F07')
		AAdd(aAlias,{'F07',.T.    })//apaga
	EndIF
	AAdd(aAlias,{'CL2',.T.    })//apaga
	AAdd(aAlias,{'CL3',.T.    })//apaga
	AAdd(aAlias,{'CL5',.T.    })//apaga	
	AAdd(aAlias,{'CL6',.T.    })//apaga
	AAdd(aAlias,{'CL7',.T.    })//apaga
	AAdd(aAlias,{'CKY',.T.    })//apaga
	If AliasINdic('F0T')
		AAdd(aAlias,{'F0T',.T. })//apaga
	EndIF	
	If AliasINdic('F3J')
		AAdd(aAlias,{'F3J',.T. })//apaga
	EndIF			
	IF ISA001NDIF()
		AAdd(aAlias,{'CFA',.T.    })//apaga
		AAdd(aAlias,{'CFB',.T.    })//apaga
	EndIf
	If AliasINdic('F2Z')
		AAdd(aAlias,{'F2Z',.T. })//apaga
	EndIF
	If AliasINdic('F3P')
		AAdd(aAlias,{'F3P',.T. })//apaga
	EndIF
	If AliasINdic('F3O')
		AAdd(aAlias,{'F3O',.T. })//apaga
	EndIF
	If AliasINdic('F2S')
		AAdd(aAlias,{'F2S',.T. })//apaga
	EndIF
	If AliasINdic('CIE')
		AAdd(aAlias,{'CIE',.T. })//apaga
	EndIF	
ElseIF cOpcao == '2'
	//Primeiro processamento
	AAdd(aAlias,{'CL8',.T.})//reprocessa    C
	AAdd(aAlias,{'CL9',.T.})//reprocessa    c
	AAdd(aAlias,{'CKR',.T.	 })//apaga      c
	AAdd(aAlias,{'CKS',.T.})//reprocessa	  c
	AAdd(aAlias,{'CKT',.T.})//reprocessa    c
	AAdd(aAlias,{'CKU',.T.})//reprocessa    c
	AAdd(aAlias,{'CKV',.T.})//reprocessa    c
	AAdd(aAlias,{'CKW',.T.})//reprocessa    c
	AAdd(aAlias,{'CKX',.T.})//reprocessa
	AAdd(aAlias,{'CKZ',.T.})//reprocessa    c
	AAdd(aAlias,{'CL0',.T.})//reprocessa    c
	AAdd(aAlias,{'CL1',.T. })//apaga
	If AliasINdic('F07')
		AAdd(aAlias,{'F07',.T. })//apaga
	EndIF
	If AliasINdic('F0T')
		AAdd(aAlias,{'F0T',.T. })//apaga
	EndIF
	If AliasINdic('CIC')
		AAdd(aAlias,{'CIC',.T. })//apaga
	EndIF	
	AAdd(aAlias,{'CL2',.T.})//reprocessa
	AAdd(aAlias,{'CL3',.T. })//apaga        c
	AAdd(aAlias,{'CL4',.T.})//reprocessa
	AAdd(aAlias,{'CL5',.T. })//apaga	
	AAdd(aAlias,{'CL6',.T. })//apaga
	AAdd(aAlias,{'CL7',.T. })//apaga
	AAdd(aAlias,{'CKY',.T. })//apaga
	If AliasINdic('F3J')
		AAdd(aAlias,{'F3J',.T. })//apaga
	EndIF

	If AliasINdic('F2Z')
		AAdd(aAlias,{'F2Z',.T. })//apaga
	EndIF
	
	If AliasINdic('F3P')
		AAdd(aAlias,{'F3P',.T. })//apaga
	EndIF	
	If AliasINdic('F3O')
		AAdd(aAlias,{'F3O',.T. })//apaga
	EndIF		

	IF ISA001NDIF()
		AAdd(aAlias,{'CFA',.T.    })//apaga
		AAdd(aAlias,{'CFB',.T.    })//apaga
	EndIF
	If AliasINdic('F2S')
		AAdd(aAlias,{'F2S',.T. })//apaga
	EndIF
	If AliasINdic('CIE')
		AAdd(aAlias,{'CIE',.T. })//apaga
	EndIF	

ElseIF cOpcao == '3' //Exclusão da apuração agrupada

	AAdd(aAlias,{'CL8',.T.})//reprocessa    C
	AAdd(aAlias,{'CL9',.T.})//reprocessa    c
	AAdd(aAlias,{'CKR',.T. })//apaga        c
	AAdd(aAlias,{'CKS',.T.})//reprocessa	  c
	AAdd(aAlias,{'CKT',.T.})//reprocessa    c
	AAdd(aAlias,{'CKU',.T.})//reprocessa    c
	AAdd(aAlias,{'CKV',.T.})//reprocessa    c
	AAdd(aAlias,{'CKW',.T.})//reprocessa    c	
	AAdd(aAlias,{'CKZ',.T.})//reprocessa    c
	AAdd(aAlias,{'CL0',.T.})//reprocessa    c	
	AAdd(aAlias,{'CL3',.T. })//apaga        c
	If AliasINdic('F3J')
		AAdd(aAlias,{'F3J',.T. })//apaga
	EndIF
	If AliasINdic('CIC')
		AAdd(aAlias,{'CIC',.T. })//apaga
	EndIF	
	If AliasINdic('F2Z')
		AAdd(aAlias,{'F2Z',.T. })//apaga
	EndIF	
	If AliasINdic('F3P')
		AAdd(aAlias,{'F3P',.T. })//apaga
	EndIF		
	If AliasINdic('F3O')
		AAdd(aAlias,{'F3O',.T. })//apaga
	EndIF			
	IF ISA001NDIF()
		AAdd(aAlias,{'CFA',.T.    })//apaga
		AAdd(aAlias,{'CFB',.T.    })//apaga
	EndiF	
	If AliasINdic('F2S')
		AAdd(aAlias,{'F2S',.T. })//apaga
	EndIF
EndIF	

Return aAlias



Static Function ISA001PERG()

	Local mvpar01	:= MV_par01
	Local mvpar02	:= MV_par02
	Local mvpar03	:= MV_par03
	Local mvpar04	:= MV_par04
	Local mvpar05	:= MV_par05
	Local mvpar06	:= MV_par06
	Local mvpar07	:= MV_par07
	Local mvpar08	:= MV_par08
	Local mvpar09	:= MV_par09
	Local mvpar10	:= MV_par10
	Local mvpar11	:= MV_par11
	Local mvpar12	:= MV_par12
	Local mvpar13	:= MV_par13
	Local mvpar14	:= MV_par14
	Local mvpar15	:= MV_par15

	Local aRet	:= {}

	If Pergunte ('ISA003',.T.,'Selecione opções que deseja reprocessar')

		aAdd(aRet,MV_par01) //NF ENTRADA
		aAdd(aRet,MV_par02) //NF SAÍDA
		aAdd(aRet,MV_par03) //TITULO ENTRADA
		aAdd(aRet,MV_par04) //TITULO SAÍDA
		aAdd(aRet,MV_par05) //ATIVO FIXO
		aAdd(aRet,MV_par06) //CUPOM FISCALK
		aAdd(aRet,MV_par07) //CPRB			
	EndIF

	MV_PAR01 := mvpar01
	MV_PAR02 := mvpar02
	MV_PAR03 := mvpar03
	MV_PAR04 := mvpar04
	MV_PAR05 := mvpar05
	MV_PAR06 := mvpar06
	MV_PAR07 := mvpar07
	MV_PAR08 := mvpar08
	MV_PAR09 := mvpar09
	MV_PAR10 := mvpar10
	MV_PAR11 := mvpar11
	MV_PAR12 := mvpar12
	MV_PAR13 := mvpar13
	MV_PAR14 := mvpar14
	MV_PAR15 := mvpar15	

Return aRet

Static Function ZeraCKS(dDataDe,dDataAte,cConsl,oEFDGen)

	Local cCampos		:= ''
	Local cFiltro		:= ''

	cCampos	:= '%CKS.R_E_C_N_O_ as NRECNO%'

	cFiltro := "%"
	cFiltro += "CKS.CKS_FILIAL= '"+ oEFDGen:BuscaxFil('CKS')+ "' AND "
	cFiltro += "CKS.CKS_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
	cFiltro += "CKS.CKS_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "
	cFiltro += "CKS.CKS_CONSOL = '" +cConsl + "' AND "

	cFiltro += "%"
	cAliasCKS	:=	GetNextAlias()

	BeginSql Alias cAliasCKS
			
		SELECT
		%Exp:cCampos%

		FROM
		%Table:CKS% CKS	
		WHERE
		%Exp:cFiltro%
		CKS.%NotDel%

	EndSql

	Do While !(cAliasCKS)->(EOF())
		CKS->(dbGoto((cAliasCKS)->NRECNO))		
		RecLock("CKS",.F.)
		CKS->CKS_AJAC 		:= 0
		CKS->CKS_AJRD 		:= 0
		CKS->CKS_DIF 		:= 0	
		CKS->CKS_DIFANT 	:= 0	
		CKS->CKS_VLDISP 	:=CKS->CKS_VLTRIB	
		
		MsUnLock()
		CKS->(FKCommit())
		(cAliasCKS)->(DBSKIP())
	EndDo		


	DbSelectArea (cAliasCKS)
	(cAliasCKS)->(DbCloseArea ())

Return


Static Function ZeraCL8(dDataDe,dDataAte,cConsl,oEFDGen)

	Local cCampos		:= ''
	Local cFiltro		:= ''

	cCampos	:= '%CL8.R_E_C_N_O_ as NRECNO%'

	cFiltro := "%"
	cFiltro += "CL8.CL8_FILIAL= '"+ oEFDGen:BuscaxFil('CL8')+ "' AND "
	cFiltro += "CL8.CL8_PER>= '" + %Exp:DToS (dDataDe)% + "' AND "
	cFiltro += "CL8.CL8_PER<= '" + %Exp:DToS (dDataAte)% + "' AND "
	cFiltro += "CL8.CL8_CONSOL = '" +cConsl + "' AND "

	cFiltro += "%"
	cAliasCL8	:=	GetNextAlias()

	BeginSql Alias cAliasCL8
			
		SELECT
		%Exp:cCampos%

		FROM
		%Table:CL8% CL8	
		WHERE
		%Exp:cFiltro%
		CL8.%NotDel%

	EndSql

	Do While !(cAliasCL8)->(EOF())
		CL8->(dbGoto((cAliasCL8)->NRECNO))		
		RecLock("CL8",.F.)
		CL8->CL8_AJAC 		:= 0
		CL8->CL8_AJRD 		:= 0
		CL8->CL8_DIF 		:= 0	
		CL8->CL8_TOTCRD 	:= 0	
		CL8->CL8_CRDUTI 	:= CL8->CL8_VLCRED	
		CL8->CL8_CRDFUT 	:= 0	
		
		MsUnLock()
		CL8->(FKCommit())
		(cAliasCL8)->(DBSKIP())
	EndDo		

	DbSelectArea(cAliasCL8)
	(cAliasCL8)->(DbCloseArea ())

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} IniThread
 
Função que irá iniciar as Threads para processamento.

@author Erick G. Dias
@return aThread,Array,Retorna os nomes de todas as Threads iniciadas.
@since 11/08/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function IniThread(aReprocess,aFil,aPergunta,aDiaThread,nLimite)

Local aThread		:= {} //Array com os nomes das Threads Iniciadas
Local nCont		:= 0
Local cNomeJob	:= ''

If nLimite >= Len(aDiaThread)
	nLimite	:=  Len(aDiaThread)-1
EndIF

//Chama função para guardar as informações de parâmetros da pergunta inicial da rotina.
//Deverá passar array com as perguntas para função ProcEFD
For nCont := 1 to nLimite 	
	aPergunta[1] :=aDiaThread[nCont+1][1]
	aPergunta[2] :=aDiaThread[nCont+1][2]
		
	// Cada Thread terá uma identificação
	cNomeJob	:=	"FISA001"+ strZERO(nCont+1,2) 
	PutGlbValue( cNomeJob , "0" )
	GlbUnLock()
	
	// Adiciona o nome do arquivo de Job no array aJobAux
	aAdd( aThread ,{ cNomeJob } )
	StartJob('PreProcEFD',GetEnvServer(),.F.,cEmpAnt,cFilAnt,cNomeJob,aReprocess,aPergunta,aFil,.F.)
Next nCont

Return aThread

//-------------------------------------------------------------------
/*/{Protheus.doc} PreProcEFD
 
Função que será chamada quando iniciar uma nova Thread. 

@author Erick G. Dias
@since 11/08/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Function PreProcEFD(cEmp,cFil,cNomeJob,aReprocess,aParSX1,aFil)

Local cError		:= ''
Local lErro		:= .F.
Local bError      := { |e| oError := e , Break(e) }
Local bErrorBlock := ErrorBlock( bError )
Local oError
Local n := 0
Local lEnd	:= .F.
Local oProcess 

PutGlbValue( cNomeJob , "0" ) //Iniciou
GlbUnLock()

//ABRE NOVO AMBIENTE

RpcSetType(3)
RpcSetEnv(cEmp,cFil)

BEGIN SEQUENCE
	//TRY
	//EXECUTA FUNÇÃO DO SPED
	ProcEFD(,aReprocess,aParSX1,aFil,.F.,,cNomeJob)
  
  	//CATCH e as IdxException
		//ConOut( ProcName() + " " + Str(ProcLine()) + " Erro na geração no processamento - " +SM0->M0_CODFIL+" / "+AllTrim(SM0->M0_FILIAL) + " - "   + oError:Description )
  	//END TRY
RECOVER

lErro	:= .T. 

END SEQUENCE 
ErrorBlock( bErrorBlock )

IF lErro
	PutGlbValue( cNomeJob , '2' )//Ocorreu algum erro
	ConOut(" Erro na geração no processamento - " +SM0->M0_CODFIL+" / "+AllTrim(SM0->M0_FILIAL) + " - "   + oError:Description )
	ProcLogAtu("ERRO",oError:Description +"- Filial " + FWGETCODFILIAL + " " + Time(),oError:ErrorStack,cNomeJob)	
Else
	PutGlbValue( cNomeJob , '1' )//Finalizado sem erro
EndIF
GlbUnLock()
//Somente fecha ambiente se não houve nenhum erro.
RpcClearEnv()

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} GuardaPerg
 
Função que guarda as informações do parâmetro em array 

@return array com informações da pergunta MV_PARXX
@author Erick G. Dias
@since 11/08/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function GuardaPerg()

Local aRet	:= {}

aAdd(aRet,MV_PAR01) 
aAdd(aRet,MV_PAR02)
aAdd(aRet,MV_PAR03)
aAdd(aRet,MV_PAR04)
aAdd(aRet,MV_PAR05)
aAdd(aRet,MV_PAR06)
aAdd(aRet,MV_PAR07)
aAdd(aRet,MV_PAR08)
aAdd(aRet,MV_PAR09)
aAdd(aRet,MV_PAR10)
aAdd(aRet,MV_PAR11)
aAdd(aRet,MV_PAR12)
aAdd(aRet,MV_PAR13)
aAdd(aRet,MV_PAR14)
aAdd(aRet,MV_PAR15)
aAdd(aRet,MV_PAR16)
aAdd(aRet,MV_PAR17)
aAdd(aRet,MV_PAR18)
aAdd(aRet,MV_PAR19)
aAdd(aRet,MV_PAR20)
aAdd(aRet,MV_PAR21)
aAdd(aRet,MV_PAR22)
aAdd(aRet,MV_PAR23)
aAdd(aRet,MV_PAR24)

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} GetFilial
 
Esta função retorna um array com as filiais selecionadas pelo
usuário através da MatFilCacl. 

@return array com informações da pergunta MV_PARXX
@author Erick G. Dias
@since 11/08/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function GetFilial(lAutomato, aAutoFil)

Local aFil	:= {}
Local aSM0	:= {}
Local aAreaSM0	:= {}
Local nFil	:= 0

If MV_PAR04 == 1
	If lAutomato
		aFil:= MatFilCalc( .F., aAutoFil )
	Else
		//chama função para usuário escolher filial
		aFil:= MatFilCalc( .T. )
		If len(aFil) ==0
				MsgAlert('Nenhuma filial foi selecionada, o processamento não será realizado.')
		EndiF
	EndIf	
EndIF

If MV_PAR15 == 1 .AND. Len(aFil) > 0
	nFil	:= Ascan(aFil,{|x|AllTrim(x[2])==Alltrim(SM0->M0_CODFIL) .And. x[4] == SM0->M0_CGC})
	
	If nFil > 0 .AND. !aFil[nFil,1]
		MsgAlert('Apuração no modo agrupado necessita ter a filial logada no processamento. A filial logada não foi selecionada porém será considerada automaticamente no processamento')
		aFil[nFil,1]:= .T.			
	EndIF	
EndIF


IF MV_PAR04 <> 1  
	//Adiciona filial logada para realizar o processamento
	AADD(aFil,{.T.,SM0->M0_CODFIL,SM0->M0_FILIAL,SM0->M0_CGC})
EndIF
IF  Len(aFil) > 0

	aAreaSM0 := SM0->(GetArea())
	DbSelectArea("SM0")
	//--------------------------------------------------------
	//Irá preencher aSM0 somente com as filiais selecionadas
	//pelo cliente  
	//--------------------------------------------------------
	
	SM0->(DbGoTop())
	If SM0->(MsSeek(cEmpAnt))
		Do While !SM0->(Eof()) 
			nFil := Ascan(aFil,{|x|AllTrim(x[2])==Alltrim(SM0->M0_CODFIL) .And. x[4] == SM0->M0_CGC})
			If nFil > 0 .And. aFil[nFil][1] .AND. cEmpAnt == SM0->M0_CODIGO
				Aadd(aSM0,{SM0->M0_CODIGO,SM0->M0_CODFIL,SM0->M0_FILIAL,SM0->M0_NOME,SM0->M0_CGC})
			EndIf
			SM0->(dbSkip())
		Enddo
	EndIf
	
	SM0->(RestArea(aAreaSM0))
EndIF

Return  aSM0


Static Function ThreadOK(oProcess,aThread)
Local nX	:= 0
Local lErro	:= .F.
oProcess:Set1Progress(len(aThread))

For nX := 1 to Len(aThread)
	oProcess:Inc1Progress('Finalizando Thread ' + Str(nX,2))					
	While .T.

		IF GetGlbValue( aThread[nX][1] ) == '0' 
			
		ElseIF GetGlbValue( aThread[nX][1] ) == '1'
			
			Exit
		ElseIF GetGlbValue( aThread[nX][1] ) == '2'
			lErro	:= .T.
			Exit
		EndIF
		
		Sleep(3000)
	EndDo

Next nX	

IF lErro
	Alert("Threads finalizadas. Verifique o log para verificação de erro(s)!")
Else
	MsgInfo("Threads Finalizadas com Sucesso!")
EndIF
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} AgrupaThr
 
Função que irá agrupar as informações processadas separadamente pelas Threads
em uma única apuração.
@param dDtIni - Data inicial que as informações deverão ser buscadas
@param dDtFin - Data final que as informações deverão ser buscadas
@param dtGrava - Data que as informações deverão ser agrupadas.
@param cConsl - Indica se apuração é agrupada ou não
@param cTab - Tabela que deverá ser agrupada.

@author Erick G. Dias
@since 13/08/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function AgrupaThr(dDtIni, dDtFin, dtGrava,cConsl, cTab)

Local cAlias		:= ''
Local cFrom		:= ''
Local cSlct		:= ''
local cFiltro		:= ''
Local aQry			:= {}
Local aXFilial	:= ASA001AFIL()
Local oEFDGen		:= EFDGEN():New()

oEFDGen:SetFilial(aXFilial)
//CHAMA FUNÇÃO QUE RETORNA STRING DA QUERY REFERENTE A TABELA PROCESSADA
aQry	:= QryAgrupa(cTab,dDtIni,dDtFin,cConsl,oEFDGen)

cSlct		:= aQry[1][1]
cFrom		:= aQry[1][2]
cFiltro		:= aQry[1][3]

cAlias	:=	GetNextAlias()
BeginSql Alias cAlias
    	
	SELECT
		%Exp:cSlct%

	FROM
		%Exp:cFrom%
	WHERE
		%Exp:cFiltro%
	
EndSql

Do case
	Case cTab == 'CKZ'
		ConsCKZ(cAlias,aXFilial,.T.,dtGrava)
	Case ctab == 'CKS'
		ConsCKS(cAlias,aXFilial,.T.,dtGrava)		
	Case ctab == 'CL8'
		ConsCL8(cAlias,aXFilial,.T.,dtGrava)
	Case ctab == 'CL9'
		ConsCL9(cAlias,aXFilial,.T.,dtGrava)		
	Case ctab == 'CLA'
		ConsCLA(cAlias,aXFilial,.T.,dtGrava)			
	Case ctab == 'CKR'
		ConsCKR(cAlias,aXFilial,.T.,dtGrava)
	Case ctab == 'CKT'
		ConsCKT(cAlias,aXFilial,.T.,dtGrava)		
	Case ctab == 'CKU'
		ConsCKU(cAlias,aXFilial,.T.,dtGrava)		
	Case ctab = "CIC"		
		ConsCIC(cAlias,aXFilial,.T.,dtGrava)							
	Case ctab == 'CL0'
		ConsCL0(cAlias,aXFilial,.T.,dtGrava)		
	Case ctab == 'CL3'
		ConsCL3(cAlias,aXFilial,.T.,dtGrava)		
	Case ctab == 'F3J'
		ConsF3J(cAlias,aXFilial,.T.,dtGrava)
	Case ctab == 'CKX'
		ConsCKX(cAlias,aXFilial,.T.,dtGrava)
	Case ctab == 'CKV'
		ConsCKV(cAlias,aXFilial,,.F.,.T.,dtGrava)
	Case ctab == 'F2Z'
		ConsF2Z(cAlias,aXFilial,,.F.,.T.,dtGrava)		
EndCase

(cAlias)->(DbGoTop ())
Do While !(cAlias)->(Eof ())
	
	(cTab)->(dbGoto((cAlias)->R_E_C_N_O_))	
	RecLock(cTab,.F.)
	(cTab)->(dbDelete())
	MsUnLock()
	(cTab)->(FKCommit())
	(cAlias)->(DbSkip())
	
Enddo
	
DbSelectArea (cAlias)
(cAlias)->(DbCloseArea())

Return


Static Function QryAgrupa(cAlias,dDtIni,dDtFin,cConsl,oEFDGen)

Local aRet			:= {}
Local cSlct		:= ''
Local cFiltro 	:= ''
Local cFrom	 	:= ''

Do case
	Case cAlias == 'CKZ'

		cSlct	 := "%CKZ.*%"	
		cFrom	   := '%'+ RetSqlName('CKZ')+' CKZ %
		cFiltro += "%CKZ.CKZ_FILIAL= '"+ oEFDGen:BuscaxFil('CKZ') + "' AND "
		cFiltro += "CKZ.CKZ_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "CKZ.CKZ_PER<= '" + %Exp:DToS (dDtFin)% + "' AND "
		cFiltro += "CKZ.CKZ_CONSOL = '" +cConsl + "' AND "
		cFiltro += "CKZ.D_E_L_E_T_=' ' "	
		cFiltro += "%"
	Case cAlias == 'CKS'

		cSlct	 := "%CKS.*%"	
		cFrom	   := '%'+ RetSqlName('CKS')+' CKS %
		cFiltro += "%CKS.CKS_FILIAL= '"+ oEFDGen:BuscaxFil('CKS') + "' AND "
		cFiltro += "CKS.CKS_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "CKS.CKS_PER<= '" + %Exp:DToS (dDtFin)% + "' AND "
		cFiltro += "CKS.CKS_CONSOL = '" +cConsl + "' AND "
		cFiltro += "CKS.D_E_L_E_T_=' ' "	
		cFiltro += "%"

	Case cAlias == 'CL8'

		cSlct	 := "%CL8.*%"	
		cFrom	   := '%'+ RetSqlName('CL8')+' CL8 %
		cFiltro += "%CL8.CL8_FILIAL= '"+ oEFDGen:BuscaxFil('CL8') + "' AND "
		cFiltro += "CL8.CL8_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "CL8.CL8_PER<= '" + %Exp:DToS (dDtFin)% + "' AND "
		cFiltro += "CL8.CL8_CONSOL = '" +cConsl + "' AND "
		cFiltro += "CL8.D_E_L_E_T_=' ' "	
		cFiltro += "%"

	Case cAlias == 'CL9'	

		cSlct	 := "%CL9.*%"	
		cFrom	   := '%'+ RetSqlName('CL9')+' CL9 %
		cFiltro += "%CL9.CL9_FILIAL= '"+ oEFDGen:BuscaxFil('CL9') + "' AND "
		cFiltro += "CL9.CL9_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "CL9.CL9_PER<= '" + %Exp:DToS (dDtFin)% + "' AND "
		cFiltro += "CL9.CL9_CONSOL = '" +cConsl + "' AND "
		cFiltro += "CL9.D_E_L_E_T_=' ' "	
		cFiltro += "%"

	Case cAlias == 'CLA'
		cSlct	 := "%CLA.*%"	
		cFrom	   := '%'+ RetSqlName('CLA')+' CLA %
		cFiltro += "%CLA.CLA_FILIAL= '"+ oEFDGen:BuscaxFil('CLA') + "' AND "
		cFiltro += "CLA.CLA_DTREF>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "CLA.CLA_DTREF<= '" + %Exp:DToS (dDtFin)% + "' AND "
		cFiltro += "CLA.CLA_CONSOL = '" +cConsl + "' AND "
		cFiltro += "CLA.D_E_L_E_T_=' ' "	
		cFiltro += "%"
	Case cAlias == 'CKR'
		cSlct	 := "%CKR.*%"	
		cFrom	   := '%'+ RetSqlName('CKR')+' CKR %
		cFiltro += "%CKR.CKR_FILIAL= '"+ oEFDGen:BuscaxFil('CKR') + "' AND "
		cFiltro += "CKR.CKR_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "CKR.CKR_PER<= '" + %Exp:DToS (dDtFin)% + "' AND "
		cFiltro += "CKR.CKR_CONSOL = '" +cConsl + "' AND "
		cFiltro += "CKR.D_E_L_E_T_=' ' "	
		cFiltro += "%"	
	
	Case cAlias == 'CKT'
		cSlct	 := "%CKT.*%"	
		cFrom	   := '%'+ RetSqlName('CKT')+' CKT %
		cFiltro += "%CKT.CKT_FILIAL= '"+ oEFDGen:BuscaxFil('CKT') + "' AND "
		cFiltro += "CKT.CKT_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "CKT.CKT_PER<= '" + %Exp:DToS (dDtFin)% + "' AND "
		cFiltro += "CKT.CKT_CONSOL = '" +cConsl + "' AND "
		cFiltro += "CKT.D_E_L_E_T_=' ' "	
		cFiltro += "%"	

	
	Case cAlias == 'CKU'
	
		cSlct	 := "%CKU.*%"	
		cFrom	   := '%'+ RetSqlName('CKU')+' CKU %
		cFiltro += "%CKU.CKU_FILIAL= '"+ oEFDGen:BuscaxFil('CKU') + "' AND "
		cFiltro += "CKU.CKU_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "CKU.CKU_PER<= '" + %Exp:DToS (dDtFin)% + "' AND "
		cFiltro += "CKU.CKU_CONSOL = '" +cConsl + "' AND "
		cFiltro += "CKU.D_E_L_E_T_=' ' "	
		cFiltro += "%"		

	Case cAlias == 'CIC'
	
		cSlct	 := "%CIC.*%"	
		cFrom	   := '%'+ RetSqlName('CIC')+' CIC %
		cFiltro += "%CIC.CIC_FILIAL= '"+ oEFDGen:BuscaxFil('CIC') + "' AND "
		cFiltro += "CIC.CIC_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "CIC.CIC_PER<= '" + %Exp:DToS (dDtFin)% + "' AND "
		cFiltro += "CIC.CIC_CONSOL = '" +cConsl + "' AND "
		cFiltro += "CIC.D_E_L_E_T_=' ' "	
		cFiltro += "%"		

	
	Case cAlias == 'CL0'

		cSlct	 := "%CL0.*%"	
		cFrom	   := '%'+ RetSqlName('CL0')+' CL0 %
		cFiltro += "%CL0.CL0_FILIAL= '"+ oEFDGen:BuscaxFil('CL0') + "' AND "
		cFiltro += "CL0.CL0_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "CL0.CL0_PER<= '" + %Exp:DToS (dDtFin)% + "' AND "
		cFiltro += "CL0.CL0_CONSOL = '" +cConsl + "' AND "
		cFiltro += "CL0.D_E_L_E_T_=' ' "	
		cFiltro += "%"		

	
	Case cAlias == 'CL3'	
		cSlct	 := "%CL3.*%"	
		cFrom	   := '%'+ RetSqlName('CL3')+' CL3 %
		cFiltro += "%CL3.CL3_FILIAL= '"+ oEFDGen:BuscaxFil('CL3') + "' AND "
		cFiltro += "CL3.CL3_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "CL3.CL3_PER<= '" + %Exp:DToS (dDtFin)% + "' AND "
		cFiltro += "CL3.CL3_CONSOL = '" +cConsl + "' AND "
		cFiltro += "CL3.D_E_L_E_T_=' ' "	
		cFiltro += "%"			
	
	Case cAlias == 'F3J'	
		cSlct	 := "%F3J.*%"	
		cFrom	   := '%'+ RetSqlName('F3J')+' F3J %
		cFiltro += "%F3J.F3J_FILIAL= '"+ oEFDGen:BuscaxFil('F3J') + "' AND "
		cFiltro += "F3J.F3J_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "F3J.F3J_PER<= '" + %Exp:DToS (dDtFin)% + "' AND "
		cFiltro += "F3J.F3J_CONSOL = '" +cConsl + "' AND "
		cFiltro += "F3J.D_E_L_E_T_=' ' "	
		cFiltro += "%"
	Case cAlias == 'CKV'	
		cSlct	 := "%CKV.*%"	
		cFrom	   := '%'+ RetSqlName('CKV')+' CKV %
		cFiltro += "%CKV.CKV_FILIAL= '"+ oEFDGen:BuscaxFil('CKV') + "' AND "
		cFiltro += "CKV.CKV_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "CKV.CKV_PER<= '" + %Exp:DToS (dDtFin)% + "' AND "
		cFiltro += "CKV.CKV_CONSOL = '" +cConsl + "' AND "
		cFiltro += "CKV.D_E_L_E_T_=' ' "	
		cFiltro += "%"
	Case cAlias == 'CKX'	
		cSlct	 := "%CKX.*%"	
		cFrom	   := '%'+ RetSqlName('CKX')+' CKX %
		cFiltro += "%CKX.CKX_FILIAL= '"+ oEFDGen:BuscaxFil('CKX') + "' AND "
		cFiltro += "CKX.CKX_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
		cFiltro += "CKX.CKX_PER<= '" + %Exp:DToS (dDtFin)% + "' AND "		
		cFiltro += "CKX.D_E_L_E_T_=' ' "	
		cFiltro += "%"	
	Case cAlias == 'F2Z'

		cSlct	:= "%F2Z.*%"	
		cFrom	:= '%'+ RetSqlName('F2Z')+' F2Z %'
		cFiltro	+= "%F2Z.F2Z_FILIAL='"+oEFDGen:BuscaxFil('F2Z')+"' AND "
		cFiltro	+= "F2Z.F2Z_DTREF>='"+%Exp:DToS (dDtIni)%+"' AND "
		cFiltro	+= "F2Z.F2Z_DTREF<='"+%Exp:DToS (dDtFin)%+"' AND "
		cFiltro += "F2Z.F2Z_CONSOL = '" +cConsl + "' AND "
		cFiltro	+= "F2Z.F2Z_ORIG IN ('2','3') AND "
		cFiltro += "F2Z.D_E_L_E_T_ = ' '"
		cFiltro += "%"
EndCase

AADD(aRet,{cSlct,cFrom,cFiltro})

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} IniCred
 
Função que irá inicializar/zerar os valores de créditos

@author Erick G. Dias
@since 04/09/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function IniCred(aParSX1,aXFilial,cFilialMat,lConsolid)

local oSaldoCred
DEFAULT lConsolid := .F.

oSaldoCred:= SALDOCRED():New()
oSaldoCred:SetFilial(aXFilial)
oSaldoCred:SetFilApu(cFilialMat)
If lConsolid 
	oSaldoCred:SetConsol('1') //Quando se tratar de uma apuração agrupadora será setado o CONSOL = 1 para que seja apagado o registro correto na CCW e CCY
Endif
oSaldoCred:SetTributo(PIS)
oSaldoCred:SetPer(Strzero(Month(aParSX1[1]),2)+cvaltochar(Year(aParSX1[1])))
oSaldoCred:LimpaSaldo() //Limpa tabela de saldos somente do período

oSaldoCred:SetTributo(COFINS)
oSaldoCred:LimpaSaldo() //Limpa tabela de saldos somente do período
FreeObj(oSaldoCred)
oSaldoCred:= Nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} IniDeducao
 
Função que irá inicializar/zerar os valores de dedução

@author Erick G. Dias
@since 04/09/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function IniDeducao(aParSX1,aXFilial,cFilialMat)

Local dUltDia		:= LastDay (aParSX1[1]) + 1
Local cProxPer	:=	cvaltochar(strzero(month(dUltDia ) ,2)) + cvaltochar(year(dUltDia ))
Local oSaldoDed
oSaldoDed	:= 	SALDODED():New()
oSaldoDed:SetFilial(aXFilial)
oSaldoDed:SetFilApu(cFilialMat)
oSaldoDed:LimpaSaldo(cProxPer)
FreeObj(oSaldoDed)
oSaldoDed	:= Nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} IniRetenca
 
Função que irá inicializar/zerar os valores de retenções

@author Erick G. Dias
@since 04/09/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function IniRetenca(aParSX1,aXFilial,cFilialMat)

oOutRet := DEDUCAOPC():New() 
oOutRet:SetFilial(aXFilial)
oOutRet:SetFilApu(cFilialMat)
oOutRet:SetPergrva(Strzero(Month(aParSX1[1]),2)+cvaltochar(Year(aParSX1[1])))
oOutRet:SetTributo(PIS)
oOutRet:LimpaSaldo()
oOutRet:SetTributo(COFINS)
oOutRet:LimpaSaldo()
FreeObj( oOutRet ) 
oOutRet:= Nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} IniTabApur
 
Função que irá inicializar/zerar as tabelas da apuração

@author Erick G. Dias
@since 04/09/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function IniTabApur (aParSX1,aXFilial,lTabAux,lReproc,lTabCPRB)

Local oApurSai

default lTabCPRB := .f.

oApurSai := FISX001():New()
oApurSai:SetFilial(aXFilial)
oApurSai:SetDtIni(aParSX1[1])
oApurSai:SetDtFin(aParSX1[2])
oApurSai:SetLivro(aParSX1[3])
oApurSai:SetRegApur(Str(aParSX1[6],1))

if !lTabCPRB
	oApurSai:ClearTab(TabApur(lReproc))
else 
	oApurSai:ClearTab(TabCPRB())
endif

If lTabAux
	oApurSai:ClearTab(TabAux())//BRUCE
EndIF
	
oApurSai	:= Nil

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} TabApur
 
Função que irá retornar os alias das tabelas da apuração.

@author Erick G. Dias
@since 04/09/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function TabApur(lReproc)

Local aAlias	:= {}


If lReproc
	AAdd(aAlias,{'CKR',.T.})
	AAdd(aAlias,{'CL3',.T.})
	AAdd(aAlias,{'CKS',.T.})
	If AliasIndic('F2S')
		AAdd(aAlias,{'F2S',.T.}) 	
	EndIf
	If AliasINdic('F2Z')
		AAdd(aAlias,{'F2Z',.T. })
	EndIF	
	If AliasINdic('F3P')
		AAdd(aAlias,{'F3P',.T. })
	EndIF		
	If AliasINdic('F3O')
		AAdd(aAlias,{'F3O',.T. })
	EndIF		

	IF ISA001NDIF()
		AAdd(aAlias,{'CFA',.T.})
		AAdd(aAlias,{'CFB',.T.})
	EndIF
	If AliasINdic('CIC')
		AAdd(aAlias,{'CIC',.T. })
	EndIF		
Else
	AAdd(aAlias,{'CKR',.T.})
	AAdd(aAlias,{'CL3',.T.})	
	AAdd(aAlias,{'CL8',.T.})
	AAdd(aAlias,{'CL9',.T.})
	AAdd(aAlias,{'CKS',.T.})	
	AAdd(aAlias,{'CKT',.T.})
	AAdd(aAlias,{'CKU',.T.})
	AAdd(aAlias,{'CKV',.T.})
	AAdd(aAlias,{'CKW',.T.})
	AAdd(aAlias,{'CKX',.T.})
	AAdd(aAlias,{'CKZ',.T.})
	AAdd(aAlias,{'CL0',.T.})
	AAdd(aAlias,{'CL4',.T.})
	IF ISA001NDIF()
		AAdd(aAlias,{'CFA',.T.})
		AAdd(aAlias,{'CFB',.T.})
	EndIF
	If AliasINdic('F2Z')
		AAdd(aAlias,{'F2Z',.T. })
	EndIF	
	If AliasINdic('F3P')
		AAdd(aAlias,{'F3P',.T. })
	EndIF		
	If AliasINdic('F3O')
		AAdd(aAlias,{'F3O',.T. })
	EndIF
	If AliasINdic('CIC')
		AAdd(aAlias,{'CIC',.T. })
	EndIF						
	//AAdd(aAlias,{'CLA',.T.})

EndIF
	

Return aAlias

//-------------------------------------------------------------------
/*/{Protheus.doc} TabAux
 
Função que irá retornar os alias das tabelas auxiliares.

@author Erick G. Dias
@since 04/09/2014
@version 11.80
/*/
//-------------------------------------------------------------------

Static Function TabAux(lExcFil)

Local aAlias	:= {}
Default lExcFil	:= .F.

If AliasINdic('F07')
	AAdd(aAlias,{'F07',.T.})
EndIF
If AliasINdic('F0T')
	AAdd(aAlias,{'F0T',.T. })//apaga
EndIF	
AAdd(aAlias,{'CL1',.T.})

If !lExcFil .AND. CL2->(FieldPos('CL2_FILAPU'))>0 // se lExcFil == F ele deleta a CL2 //BRUCE
	//Na exclusão das informações por filial, a CL2 não será adicionada, já que a exclusão ocorrerá de uma vez devio ao campo CL2_FILAPU.
	AAdd(aAlias,{'CL2',.T.})
EndIF

AAdd(aAlias,{'CL3',.T.})
AAdd(aAlias,{'CL5',.T.})
AAdd(aAlias,{'CL6',.T.})
AAdd(aAlias,{'CL7',.T.})
AAdd(aAlias,{'CKY',.T.})
If !lExcFil .AND. CKX->(FieldPos('CKX_FILAPU'))>0
	//Na exclusão das informações por filial, a CKX não será adicionada, já que a exclusão ocorrerá de uma vez devio ao campo CKX_FILAPU.
	AAdd(aAlias,{'CKX',.T.})
EndIF

If AliasINdic('F3J')
	AAdd(aAlias,{'F3J',.T.})
EndIF
If ISA001NDIF()
	AAdd(aAlias,{'CFA',.T.    })//apaga
	AAdd(aAlias,{'CFB',.T.    })//apaga
EndIF
If AliasINdic('F2S')
	AAdd(aAlias,{'F2S',.T. })//apaga
EndIF
If AliasINdic('CIE')
	AAdd(aAlias,{'CIE',.T. })//apaga
EndIF

Return aAlias

//-------------------------------------------------------------------
/*/{Protheus.doc} TabCPRB
 
Função que irá retornar os alias das tabelas CPRB.

@author Simone Oliveira
@since 29/04/2016
@version 11.80
/*/
//-------------------------------------------------------------------

static function TabCPRB()

local aAlias	:= {}

aadd(aAlias,{'CKV',.T.})
aadd(aAlias,{'CKW',.T.})
aadd(aAlias,{'CKX',.T.})
If AliasIndic('F2S')
	aadd(aAlias,{'F2S',.T.})
EndIf
return aAlias


Static Function DesfazCon()

Local nFil	:= 0
Local aFil:= MatFilCalc( .F. )
Local aAreaSM0 := SM0->(GetArea())

SM0->(DbGoTop ())
For nFil := 1 to Len(aFil)

	SM0->(MsSeek (FWGrpCompany()+aFil[nFil][2], .T.))	//Pego a filial mais proxima
	cFilAnt := FWGETCODFILIAL	
	
	IF CKR->(MSSEEK( xFilial('CKR')+dTos(MV_PAR01)+'2'+'1')) //PIS
		RecLock('CKR',.F.)
		CKR->CKR_STATUS = '1' // Volta Status para normal
		MsUnLock()		
	EndIF
	
	If CKR->(MSSEEK( xFilial('CKR')+dTos(MV_PAR01)+'2'+'2')) //COFINS 
		RecLock('CKR',.F.)
		CKR->CKR_STATUS = '1' // Volta Status para normal
		MsUnLock()		
	EndIF	
	
	
Next nFil

RestArea (aAreaSM0)
cFilAnt := FWGETCODFILIAL

Return



//-------------------------------------------------------------------
/*/{Protheus.doc} FSA001CLG
 
@description Função que irá buscar os lançamentos na tabela CLG referente
				registro F600 incluídos manualmente, e irá considerar na geração
				da retenção. Esta situação se deve ao motivo de existirem retenções
				de operações de consórcios, onde não existe documento fiscal
				e nem título, desta maneira a receita é incluída na rodina FISA048,
				porém estas receitas estão sujeitas a retenção, que por suas vez
				são inerídas na rotina FISA006.

@param dDtIni,Date,Data Inicial do processamento
@param dDtFin,Date,Data final do processamento

@author Erick G. Dias
@since 04/09/2014
@version 11.80
/*/
//-------------------------------------------------------------------
Static Function FSA001CLG(dDtIni, dDtFin)

Local cSlct		:= ''
Local cAliasCLG	:= GetNextAlias()
Local cGroup		:= ''
Local cRegime		:= ''
Local oF600		

If AliasINdic('CLG') .AND.  CLG->(FieldPos("CLG_NATRET"))>0
	oF600		:=	TABELACKY():New() 
	DbSelectArea ('CLG')
	
	cSlct :='%'
	cSlct += 'CLG.CLG_FILIAL, CLG.CLG_DTRET, CLG.CLG_NATRET, CLG.CLG_CODREC, CLG.CLG_REGIME, CLG.CLG_CNPJ, CLG.CLG_INDRET,'
	cSlct += 'SUM(CLG.CLG_BSRET) AS CLG_BSRET, SUM(CLG.CLG_VLTOTR) AS CLG_VLTOTR, SUM(CLG.CLG_PISRET) AS CLG_PISRET,'
	cSlct += 'SUM(CLG.CLG_COFRET) AS CLG_COFRET'
	cSlct +='%'
	   
	cGroup := '%group by CLG_FILIAL,CLG_DTRET,CLG_NATRET,CLG_CODREC,CLG_REGIME,CLG_CNPJ,CLG_INDRET%'
	   	
	BeginSql Alias cAliasCLG
		COLUMN CLG_DTRET AS DATE
		
		SELECT			    
			%Exp:cSlct%
		FROM 
			%Table:CLG% CLG
		WHERE
			CLG.CLG_FILIAL=%xFilial:CLG% AND
			CLG.CLG_DTRET>=%Exp:DToS (dDtIni)% AND
			CLG.CLG_DTRET<=%Exp:DToS (dDtFin)% AND
			CLG.%NotDel%	
		%Exp:cGroup%
	EndSql
	
	DbSelectArea (cAliasCLG)
	(cAliasCLG)->(DbGoTop ())
	Do While !(cAliasCLG)->(Eof ())	
	 
		cRegime :=""
		If (cAliasCLG)->CLG_REGIME == "0"
			cRegime := '2' //cumulativo
		ElseIf (cAliasCLG)->CLG_REGIME == "1"
			cRegime := '1' //nao cumulativo
		EndIF	
		oF600:SetParam('CKY_PER',dDtIni)
		oF600:SetParam('CKY_INDRET',(cAliasCLG)->CLG_NATRET)
		oF600:SetParam('CKY_DTRET',(cAliasCLG)->CLG_DTRET)
		oF600:SetParam('CKY_CODREC',(cAliasCLG)->CLG_CODREC)
		oF600:SetParam('CKY_INDREC',cRegime) 				
		oF600:SetParam('CKY_CNPJ',(cAliasCLG)->CLG_CNPJ)		
		oF600:SetParam('CKY_BASE',(cAliasCLG)->CLG_BSRET)		
		oF600:SetParam('CKY_TOTRET',(cAliasCLG)->CLG_VLTOTR)	
		oF600:SetParam('CKY_PISRET',(cAliasCLG)->CLG_PISRET)	
		oF600:SetParam('CKY_COFRET',(cAliasCLG)->CLG_COFRET)	
		oF600:SetParam('CKY_INDCON',(cAliasCLG)->CLG_INDRET)	
		If CKY->(FIELDPOS("CKY_FILAPU")) > 0
			oF600:SetParam('CKY_FILAPU',(cAliasCLG)->CLG_FILIAL)  
		Endif		
		oF600:Save()		
	 
		(cAliasCLG)->(DbSkip ())			
	EndDo
	
	oF600:FechaAlias(cAliasCLG)
EndIF
 
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} FSA001CPRB
 
Função que irá realizar o reprocessamento da EFD, conforme opções
selecionadas pelo usuário na tela inicial da apuração.
 
@author Mauro A. Gonçalves
@since 27/08/2015
@version 11.80

/*/
//-------------------------------------------------------------------
Static Function FSA001CPRB(dDataDe,dDataAte)
Local cAliasCF5		:= ''
Local cSelect		:= ''
Local cWhere		:= ''
Local aReg			:= {}
Local lTIPATV		:= CF5->(fieldpos("CF5_TIPATV")) > 0
Local aStruCF5		:= CF5->(DBStruct())
Local nCF5			:= 0
Local nTamCF5		:= Len(aStruCF5)
Local cCmpMemo 		:= ""

For nCF5 := 1 To nTamCF5	
	IF aStruCF5[nCF5][2] <> 'M' //Campos Memo devem ser ultimos campos
		IF nCF5 == 1
			cSelect += "CF5."+aStruCF5[nCF5][1]	
		Else
			cSelect += ", CF5."+aStruCF5[nCF5][1]	
		Endif
	Else
		cCmpMemo += ", CF5."+aStruCF5[nCF5][1]	
	Endif
	
Next (nCF5)

cAliasCF5	:=	GetNextAlias()
cSelect :=	'%' + (cSelect + cCmpMemo) + '%' //"%CF5.*%"
cWhere	:=	"%CF5.CF5_FILIAL='"+xFilial("CF5")+"' AND "
cWhere	+=	"CF5.CF5_DTREF>='"+DTOS(dDataDe)+"' AND "
cWhere	+=	"CF5.CF5_DTREF<='"+DTOS(dDataAte)+"' AND "
cWhere	+=	"CF5.CF5_PISCOF='2' AND %"

BeginSql Alias cAliasCF5    	
    COLUMN CF5_DTREF AS DATE	
	SELECT			    	 
		%Exp:cSelect%
	FROM 
		%Table:CF5% CF5													
	WHERE
		%Exp:cWhere%
		CF5.%NotDel%	
EndSql

Do While !(cAliasCF5)->(Eof ())
	aAdd(aReg,{(cAliasCF5)->CF5_INDAJU,;
			    (cAliasCF5)->CF5_VALAJU,;
			    (cAliasCF5)->CF5_CODAJU,;
			    (cAliasCF5)->CF5_NUMDOC,;
			    (cAliasCF5)->CF5_DESAJU,;
			    STRTRAN(DTOC((cAliasCF5)->CF5_DTREF),"/",""),;
				 IIf(lTIPATV,IIf((cAliasCF5)->CF5_TIPATV=="0",mv_par16,mv_par17),"")})
	(cAliasCF5)->(DbSkip())			
EndDo
dbSelectArea(cAliasCF5)
FwFreeArray(aStruCF5)

Return aReg


//-------------------------------------------------------------------
/*/{Protheus.doc} F100Presu
 
Função que irá processar o cálculo do crédito presumido conforme lei 12.058/2009
para escrituração do F100
 
@author Henrique Pereira
@since 27/01/2016
@version 11.80

/*/
//-------------------------------------------------------------------

Static Function F100Presu(dDataDe,dDataAte,cNrLivro,oApurEnt,nTotF100,cFilialMat,lIndividu)
Local nX         := 0
Local oF100	   :=	TABELACL2():New() //Cria objeto para gravação do F100
Local aTotSai    := {}
Local aTotEnt    := {}
Local aCrePresu  := {}
Local cCstPres   := GetNewPar("MV_CSTPRES","62")

aTotSai   := F100PreTSai(dDataDe,dDataAte,cNrLivro)
aTotEnt   := F100PreTEnt(dDataDe,dDataAte,cNrLivro)
 
//Somente irá processar crédito presumido se houver valor de base de cálculo/Exportação. Caso contrário não deverá gerar F100 na apuração e na CL2.
If aTotSai[1] > 0
        
         For nX := 1 to Len(aTotEnt)
          If !Empty(aTotEnt[nX,3])
             aCrePresu := F100CrePreG(aTotSai,aTotEnt,dDataAte, nX)  
     					
              lGravaF100	:= .T.
				oApurEnt:SetRegime(NAOCUMULAT) 
			    oApurEnt:SetOrigem(OUTROS)			
				oApurEnt:SetReceita(aCrePresu[8])
				oApurEnt:SetCodBcc('13')
				oApurEnt:SetTNatRec("")
				oApurEnt:SetCNatRec("")		
				oApurEnt:SetGNatRec("")
				oApurEnt:SetDNatRec("")	
				oApurEnt:SetCFOP(	'')	
		
				//--------------------
				//Informações de PIS
				//--------------------			
				oApurEnt:SetTributo(PIS)
				oApurEnt:SetCST(cCstPres)		
				oApurEnt:SetAlqTrib(aCrePresu[9])
				oApurEnt:SetBcTrib(aCrePresu[8])
				oApurEnt:SetValTrib(aCrePresu[1])				
				oApurEnt:AgrpCred()
		
				//-----------------------
				//Informações da COFINS
				//-----------------------		
				oApurEnt:SetTributo(COFINS)		
				oApurEnt:SetCST(cCstPres)		
				oApurEnt:SetAlqTrib(aCrePresu[10])
				oApurEnt:SetBcTrib(aCrePresu[8])
				oApurEnt:SetValTrib(aCrePresu[2])
				oApurEnt:AgrpCred()		
				
				//----------------------------------
				//Agrupa valores para resumo de CST
				//----------------------------------
				oApurEnt:GrvResCST()	
				
				//-----------------------------------------
				//ABAIXO GRAVA OS VALORES DO REGISTRO F100 
				//-----------------------------------------
				oF100:SetParam('CL2_PER',dDataDe)
				oF100:SetParam('CL2_REG','F100')
				oF100:SetParam('CL2_INDOP','0')
				oF100:SetParam('CL2_PARTI',aCrePresu[11])
				oF100:SetParam('CL2_ITEM', aCrePresu[12])		
				oF100:SetParam('CL2_DTOPER',dDataAte)		
				oF100:SetParam('CL2_VLOPER',aCrePresu[8])
				oF100:SetParam('CL2_CSTPIS',cCstPres)		
				oF100:SetParam('CL2_BCPIS',aCrePresu[8])		
				oF100:SetParam('CL2_ALQPIS',aCrePresu[9])		
				oF100:SetParam('CL2_VLPIS',aCrePresu[1])		
				oF100:SetParam('CL2_CSTCOF',cCstPres)		
				oF100:SetParam('CL2_BCCOF',aCrePresu[8])		
				oF100:SetParam('CL2_ALQCOF',aCrePresu[10])		
				oF100:SetParam('CL2_VLCOF',aCrePresu[2])		
				oF100:SetParam('CL2_CODBCC','13')		
				oF100:SetParam('CL2_INDCRD',aCrePresu[13])		
				oF100:SetParam('CL2_CTA','')		
				oF100:SetParam('CL2_CCUS','')		
				oF100:SetParam('CL2_DESCR',aCrePresu[14]+aCrePresu[15]+aCrePresu[5])
				oF100:SetParam('CL2_FILAPU',IIf(lIndividu,oF100:BuscaxFil('CL2'),cFilialMat) )				
				oF100:SetParam('CL2_CLIFOR' , aCrePresu[16] )
				oF100:SetParam('CL2_LOJA'   , aCrePresu[17] )
				
				oF100:Save()
			EndIf
		Next nX
		 //MATO O OBJETO oF100
       FreeObj(oF100)
		oF100:= nil 
         
EndIf

Return
//-------------------------------------------------------------------
/*/{Protheus.doc} F100PreTEnt
 
Função que irá retornar as entrada para  cálculo do crédito 
presumidoconforme lei 12.058/2009
 
@author Henrique Pereira
@since 27/01/2016
@version 11.80

/*/
//-------------------------------------------------------------------
Static Function F100PreTSai(dDataDe,dDataAte,cNrLivro)
Local cAliasSFT 	:= "SFT"
Local aRetorno 	:= {0,0}
Local cFiltro 	:= ""
Local cCampos 	:= ""
Local aCFOPs     := XFUNCFRec() // Funcao que retorna array com CFOPS / [1]-Considera Receita / [2]-NAO considera como Receita
Local aNCMS   := GetNewPar('MV_NCMCPPC',{""}) // Saída - Exportação 

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Monta um array com os códigos NCMs que serão considerados como exportação para percentual do cálculo da base de cálculo de crédito Presumido.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	aNCMS   			:= Iif (Len(aNCMS) > 1,&(aNCMS),aNCMS)


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄV¿
	//³Irá trazer valores de receitas para totalizar percentual de receita de exportação, para calcular crédito presumido.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄVÙ
	DbSelectArea (cAliasSFT)
	(cAliasSFT)->(DbSetOrder (2))
	
	    If (TcSrvType ()<>"AS/400")
	    	cAliasSFT	:=	GetNextAlias()

			cFiltro := "%"

			If (cNrLivro<>"*")
        		cFiltro += " SFT.FT_NRLIVRO = '" +%Exp:cNrLivro% +"' AND "
      		EndiF

			cFiltro += "%"
			cCampos := "%"

	    	BeginSql Alias cAliasSFT

				COLUMN FT_EMISSAO AS DATE
		    	COLUMN FT_ENTRADA AS DATE
		    	COLUMN FT_DTCANC AS DATE

				SELECT
					SUM(SFT.FT_VALCONT) FT_VALCONT , SFT.FT_ESPECIE, SFT.FT_CFOP , SFT.FT_PRODUTO, SFT.FT_CSTPIS, SFT.FT_CSTCOF, SB1.B1_POSIPI
					%Exp:cCampos%
				FROM
					%Table:SFT% SFT
					LEFT JOIN %Table:SB1% SB1 ON(SB1.B1_FILIAL=%xFilial:SB1%  AND SB1.B1_COD=SFT.FT_PRODUTO AND SB1.%NotDel%)
				WHERE
					SFT.FT_FILIAL=%xFilial:SFT% AND
					SFT.FT_TIPOMOV = 'S' AND
					SFT.FT_ENTRADA>=%Exp:DToS (dDataDe)% AND
					SFT.FT_ENTRADA<=%Exp:DToS (dDataAte)% AND
					(SFT.FT_DTCANC = ' ' OR SFT.FT_DTCANC > %Exp:DToS (dDataAte)% )  AND
					SFT.FT_TIPO NOT IN ('D','B') AND
					%Exp:cFiltro%
					SFT.%NotDel%

				GROUP BY SFT.FT_ESPECIE, SFT.FT_CFOP, SFT.FT_PRODUTO, SB1.B1_POSIPI, SFT.FT_CSTPIS, SFT.FT_CSTCOF

				ORDER BY SFT.FT_CFOP

			EndSql
		EndIf
	
	DbSelectArea (cAliasSFT)
	(cAliasSFT)->(DbGoTop ())
	ProcRegua ((cAliasSFT)->(RecCount ()))

	
	Do While !(cAliasSFT)->(Eof ())

		cEspecie	:=	AModNot ((cAliasSFT)->FT_ESPECIE)		//Modelo NF

		If cEspecie$"  " .Or. ( (AllTrim((cAliasSFT)->FT_CFOP)$aCFOPs[01])	.AND. !(AllTrim((cAliasSFT)->FT_CFOP)$aCFOPs[02]) ).And. NCMCPPC((cAliasSFT)->B1_POSIPI, aNCMS)// Verifica se o CFOP é gerador de receita
      
				If SubStr((cAliasSFT)->FT_CFOP,1,1) == "7" 
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Acumula valor de receita exportação³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					
					 aRetorno[1] += (cAliasSFT)->FT_VALCONT
					 
				EndIf
	
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Acumula valor de receita total³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				    aRetorno[2] += (cAliasSFT)->FT_VALCONT		   
			
		EndIf
   
		(cAliasSFT)->(DbSkip ())
	EndDo

		If (TcSrvType ()<>"AS/400")
			DbSelectArea (cAliasSFT)
			(cAliasSFT)->(DbCloseArea ())
		EndIf
	

	cAliasSFT	:=	"SFT"


Return aRetorno
//-------------------------------------------------------------------
/*/{Protheus.doc} F100PreTEnt
 
Função que irá retornar as entrada para  cálculo do crédito 
presumidoconforme lei 12.058/2009
 
@author Henrique Pereira
@since 27/01/2016
@version 11.80

/*/
//-------------------------------------------------------------------
Static Function F100PreTEnt(dDataDe,dDataAte,cNrLivro)
Local cAliasSFT 	:= "SFT"
Local aRetorno 	:= {}
Local cFiltro 	:= ""
Local cCampos 	:= ""
Local nPos			:= 0
Local aNCME		:= GetNewPar('MV_NCMCREP',"{}")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Monta um array com os códigos NCMs que serão considerados como exportação para percentual do cálculo da base de cálculo de crédito Presumido.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	aNCME   			:= Iif (Len(aNCME) > 1,&(aNCME),aNCME)

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³A querry irá trazer o valor de compra de gado para montar a base de cálculo, para gerar valor de crédito presumido.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea (cAliasSFT)
	(cAliasSFT)->(DbSetOrder (2))
	
	    If (TcSrvType ()<>"AS/400")
	    	cAliasSFT	:=	GetNextAlias()

			cFiltro := "%"

			If (cNrLivro<>"*")
        		cFiltro += " SFT.FT_NRLIVRO = '" +%Exp:cNrLivro% +"' AND "
      		EndiF

			cFiltro += "%"
			cCampos := "%"

	    	BeginSql Alias cAliasSFT

				COLUMN FT_EMISSAO AS DATE
		    	COLUMN FT_ENTRADA AS DATE
		    	COLUMN FT_DTCANC AS DATE

				SELECT
					SUM(SFT.FT_VALCONT) FT_VALCONT , SFT.FT_CLIEFOR, SFT.FT_LOJA, SFT.FT_PRODUTO, SB1.B1_POSIPI, SFT.FT_CFOP, SFT.FT_NFISCAL, SFT.FT_SERIE
					%Exp:cCampos%
				FROM
					%Table:SFT% SFT
					LEFT JOIN %Table:SB1% SB1 ON(SB1.B1_FILIAL=%xFilial:SB1%  AND SB1.B1_COD=SFT.FT_PRODUTO AND SB1.%NotDel%)
				WHERE
					SFT.FT_FILIAL=%xFilial:SFT% AND
					SFT.FT_TIPOMOV = 'E' AND
					SFT.FT_ENTRADA>=%Exp:DToS (dDataDe)% AND
					SFT.FT_ENTRADA<=%Exp:DToS (dDataAte)% AND
					SFT.FT_TIPO NOT IN ('D','B') AND
					(SFT.FT_DTCANC = ' ' OR SFT.FT_DTCANC > %Exp:DToS (dDataAte)% )  AND
					%Exp:cFiltro%
					SFT.%NotDel%

				GROUP BY SFT.FT_NFISCAL, SFT.FT_SERIE, SFT.FT_CLIEFOR,SFT.FT_LOJA, SFT.FT_PRODUTO, SB1.B1_POSIPI,FT_CFOP

				ORDER BY SFT.FT_NFISCAL

			EndSql
		EndIf
	

	DbSelectArea (cAliasSFT)
	(cAliasSFT)->(DbGoTop ())
	ProcRegua ((cAliasSFT)->(RecCount ()))

	Do While !(cAliasSFT)->(Eof ()) .And. NCMCPPC((cAliasSFT)->B1_POSIPI, aNCME)

			If !ASCAN(aRetorno,{|X|X[3]== (cAliasSFT)->FT_PRODUTO .And. X[2] == (cAliasSFT)->FT_CLIEFOR+(cAliasSFT)->FT_LOJA .AND.;
				                            X[5] == (cAliasSFT)->FT_NFISCAL .AND. X[6] == (cAliasSFT)->FT_SERIE }) > 0

					AADD(aRetorno,{})
					nPos := Len(aRetorno)
					AADD(aRetorno[nPos], (cAliasSFT)->FT_VALCONT)  
					AADD(aRetorno[nPos], (cAliasSFT)->FT_CLIEFOR+(cAliasSFT)->FT_LOJA) 
					AADD(aRetorno[nPos], (cAliasSFT)->FT_PRODUTO)
					If SubStr((cAliasSFT)->FT_CFOP,1,1) > '2'
					    AADD(aRetorno[nPos], '1') // Crédito originário do Mercado externo
					Else
					    AADD(aRetorno[nPos], '0') // Crédito originário do Mercado interno
					EndIf
					AADD(aRetorno[nPos], (cAliasSFT)->FT_NFISCAL)
					AADD(aRetorno[nPos], (cAliasSFT)->FT_SERIE)					 
					AADD(aRetorno[nPos], (cAliasSFT)->FT_CLIEFOR)
					AADD(aRetorno[nPos], (cAliasSFT)->FT_LOJA)
					
			Else
			       aRetorno[LEN(aRetorno), 1] += (cAliasSFT)->FT_VALCONT
					
			EndIf
					
		
        
		(cAliasSFT)->(DbSkip ())
	EndDo

	
		If (TcSrvType ()<>"AS/400")
			DbSelectArea (cAliasSFT)
			(cAliasSFT)->(DbCloseArea ())
		EndIf
	


Return aRetorno
//-------------------------------------------------------------------
/*/{Protheus.doc} F100CrePreG
 
Função que irá realizar o cálculo do crédito presumidoconforme lei 12.058/2009
 
@author Henrique Pereira
@since 27/01/2016
@version 11.80

/*/
//-------------------------------------------------------------------

Static Function F100CrePreG(aVlrRec,aVlrCompra,dDataAte,nX)
Local nAlqPis		:= 0
Local nAlqCof		:= 0
Local nValPis		:= 0
Local nValCof		:= 0
Local nPerExport	:= 0
Local nBaseCalc	:= 0
Local nValRec1	:= 0
Local nValRec2	:= 0
Local nValComp	:= 0
Local aRetorno		:= {0,0,"","","","","",0,0,0,"","","","","","",""}
Local cCodAjust		:= GetNewPar("MV_CAJCPPC","03")
Local cNumProc		:= GetNewPar("MV_DAPCCPA",	"Crédito presumido conforme lei 12.058/2009 e IN Instrução Normativa RFB nº 977, de 14 de dezembro de 2009")
local cDescr			:= cNumProc
Local aAliquota		:= GetNewPar("MV_ACPPCAG",	{{0.495,2.28}})



aAliquota   		:= Iif (Len(aAliquota) > 1,&(aAliquota),aAliquota)
nAlqPis				:= aAliquota[1]
nAlqCof				:= aAliquota[2]

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Faz regra de 3 para descobrir o percentual de exportação³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nPerExport	:= (aVlrRec[1] * 100) / aVlrRec[2]

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Aplica o percentual no total de compra de gado, para saber qual a base de cálculo³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nBaseCalc	:= Round((aVlrCompra[nX,1] * nPerExport) /100,2)


//³Cálculo dos valores de créditos.³

nValPis		:= Round((nBaseCalc * nAlqPis ) /100,2)
nValCof 	:= Round((nBaseCalc * nAlqCof ) /100,2)

aRetorno[1]  := nValPis  		//Valor de crédito de PIS
aRetorno[2]  := nValCof  	 	//Valor de crédito de Cofins
aRetorno[3]  := "1" 				//Indicador de ajuste de acréscimo
aRetorno[4]  := cCodAjust	 	//Código do Ajuste
aRetorno[5]  := cNumProc 		//Número do processo
aRetorno[6]  := cDescr    		//Descrição
aRetorno[7]  := dDataAte  		//Data
aRetorno[8]  := nBaseCalc
aRetorno[9]  := nAlqPis
aRetorno[10] := nAlqCof
aRetorno[11] := aVlrCompra[nX,2] // Código do fornecedor
aRetorno[12] := aVlrCompra[nX,3] //Código do produto  
aRetorno[13] := aVlrCompra[nX,4] //Origem do crédito
aRetorno[14] := aVlrCompra[nX,5] //Codigo Nota fiscal
aRetorno[15] := aVlrCompra[nX,6] //Serie Nota Fiscal    
aRetorno[16] := aVlrCompra[nX,7] //Código do cliente/fornecedor
aRetorno[17] := aVlrCompra[nX,8] //Loja do cliente fornecedor

Return aRetorno

//-------------------------------------------------------------------
/*/{Protheus.doc} F100Presu
 
Função que retorna verifica o NCM válido para o álculo do crédito presumidoconforme lei 12.058/2009
 
@author Henrique Pereira
@since 27/01/2016
@version 11.80

/*/
//-------------------------------------------------------------------
Static Function NCMCPPC(cNcm, aNCM)

Local nPos		:= 0
local lRet		:= .F.

Default cNcm  := ""
Default aNCM  := {}
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Irá fazer for para verificar todos NCMs³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nPos := 1 to len(aNCM)

	IF aNCM[nPos] $ Alltrim(cNcm)
		lRet := .T.
		exit
	EndIf
Next nPos
Return(lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} ConsCPRB
 
Função que verifica se a receita desonerada é superior a 5%. Caso não seja, as informações serão apagadas das devidas tabelas da apuração.
 
@author Simone Oliveira
@since 26/04/2016
@version 11.80

/*/
//-------------------------------------------------------------------
static function ConsCPRB( aFil, aPergunta )
local aAreaSM0 		:= SM0->(GetArea())
local aXFilial		:= {}
local oCPRB			:= nil
local nValBrut		:= 0
local nVlAtiv		:= 0
local nPerc			:= 0
local nX			:= 0
Local cOutRec	:= SuperGetMv("MV_CODGEN",.F.,"")
Local lNTrib 	:= CKX->(FieldPos('CKX_NTRIB'))>0 .And. !EmpTy(cOutRec)
local lTabCPRB		:= .f.	
local lIndividu		:= .f.
Local lCPRBNF		:= GetNewPar('MV_CPRBNF',.F.)

default aFil		:= {}
default aPergunta	:= {}

//Verifico se é Individualizado ou Consolidado
if aPergunta[15] == 2
	lIndividu	:= .t.
endif	

// Se for consolidado já busco filial
if !lIndividu
	aXFilial:= ASA001AFIL()
endif

//Cria Objeto da CPRB
oCPRB:= CPRBEFD():New()	
oCPRB:SetConsol(.f.)
oCPRB:SetDtIni(MV_PAR01)

// Quando Apuração ocorrer por Nota, deve consolidar tabela CKX e CKV com valor final da receita bruta
IF lCPRBNF
	oCPRB:ConsolCPRB(aFil)
Endif

oCPRB:LoadCPRB()



//Atribui os valores nas devidas variáveis para realizar o cálculo e verificar se 
nValBrut	:= oCPRB:GetVlBrut()
nVlAtiv	:= oCPRB:GetVlAtiv()

//Realiza o cálculo para descobrir o percentual de Desoneração
nPerc := (nVlAtiv/nValBrut)*100

//Se menor/igual a 5% Zera as tabelas da apuração
if nPerc <= 5
	lTabCPRB := .t.
	
	for nX:=1 to len( aFil ) //Processamento por Filial
		
		SM0->(DbGoTop ())
		SM0->(MsSeek (aFil[nX][1]+aFil[nX][2], .T.))
		cFilAnt := FWGETCODFILIAL	
		
		
		//Se for individualizado, busco a devida filial
		if lIndividu
			aXFilial:= ASA001AFIL()
		endif
		
		IniTabApur(aPergunta,aXFilial,.f.,.f., lTabCPRB) //Limpa as tabelas de apuração
	 
	 next nX
endif


//Quando a receita bruta decorrente de atividades desoneradas for igual ou superior a 95% da receita bruta total aplicar-se-á a desoneração sobre o valor total das operações.
If lNTrib // Verifica se parametro esta diferente de branco
	
	IF nPerc > 5 .And. nPerc < 95
		for nX:=1 to len( aFil ) //Processamento por Filial
			
			SM0->(DbGoTop ())
			SM0->(MsSeek (aFil[nX][1]+aFil[nX][2], .T.))
			cFilAnt := FWGETCODFILIAL			
			
			//Se for individualizado, busco a devida filial
			if lIndividu
				aXFilial:= ASA001AFIL()
			endif			
			
			//Limpa tabela CKX com Flag
			oCPRB:ClrNtrib()		
		 
		 next nX		 
	Endif

	IF nPerc >= 95		
		
		for nX:=1 to len( aFil ) //Processamento por Filial
			
			SM0->(DbGoTop ())
			SM0->(MsSeek (aFil[nX][1]+aFil[nX][2], .T.))
			cFilAnt := FWGETCODFILIAL			
			
			//Se for individualizado, busco a devida filial
			if lIndividu
				aXFilial:= ASA001AFIL()
			endif
			
			//Acumula valores e codigos existente na tabela CKX com flag não desenerados
			//Carrega CKX com Flag
			oCPRB:LoadNTrib()		
		 
		 next nX	
	Endif
Endif

RestArea (aAreaSM0)
cFilAnt := FWGETCODFILIAL

return

Static Function DetCPRB(dDataDe,dDataAte,cFilialMat,lProcRH)
Local cPreNome	:= ''
Local cNomeReal	:= ''
Local cAliasTMP	:= ''
Local cArqRh		:= "13Sal" 
Local cExtDBF		:= GetDBExtension()
Local cPeriodo	:= Alltrim(StrZero(Month(dDataDe),2))+Alltrim(Str(Year(dDataDe)))
Local nCont		:= 0
Local ObjF0T	:= TABELAF0T():New()
Local nAlq		:= 0
Local nPos		:= 0
Local aAliqAtv	:= {}
Local lTabSv5	:=  AliasINdic('SV5') .AND. FindFunction("NewDesFol")
Local lProcSV5	:= .F.
Local cFilSV5	:= ''

//Verifica se exiete a tabela SV5 e se existem informações a serem processadas
//se existir então o relatório será gerado com as informações desta tabela, pois o faturamento não irá mais gerar o arquivo temporário em DBF, foi subistituído por TemporaryTable
If lTabSv5 
	DbSelectArea('SV5')
	DbSetOrder(1)
	cFilSV5		:= 	xFilial('SV5')
	IF SV5->(MsSeek(cFilSV5+cPeriodo))
		lProcSV5	:= .T.
	EndIF
EndIF	
	
If lProcSV5	
	Do While !SV5->(Eof ())	.AND. SV5->V5_FILIAL == cFilSV5 .AND. SV5->V5_PERIODO == 	cPeriodo
	
		If SV5->V5_TIPO $ 'N/C/P' 
				
			nPos := aScan (aAliqAtv, {|aX| aX[1] ==  Alltrim(SV5->V5_CODATIV)})
			//Guardo as alíquotas e códigos de atividades processados para não chamar a SpedPCCG1 para todos os itens
			IF nPos == 0		
				nAlq	:= SpedPCCG1(SV5->V5_CODATIV,dDataAte)
				aAdd(aAliqAtv, {})
				nPos := Len(aAliqAtv)
				aAdd (aAliqAtv[nPos], Alltrim(SV5->V5_CODATIV))
				aAdd (aAliqAtv[nPos], nAlq)
			Else
				nAlq	:= aAliqAtv[nPos][2]
			EndIF

			ObjF0T:Clear()
			ObjF0T:SetValue("F0T_PER",dDataDe)
			ObjF0T:SetValue("F0T_FILAPU",cFilialMat)
			ObjF0T:SetValue("F0T_TIPO",Iif(lProcRH,'7' ,'6' )) //CPRB Regime de Caixa							
			ObjF0T:SetValue("F0T_NUMNF", SV5->V5_NUMNF)
			ObjF0T:SetValue("F0T_SER",SV5->V5_SERIE)
			ObjF0T:SetValue("F0T_DTEMI",SV5->V5_DATANF )										
			ObjF0T:SetValue("F0T_CFOP",SV5->V5_CFOP)
			ObjF0T:SetValue("F0T_VLCONT",SV5->V5_TOTAL)
			
			//-------------------------------
			//Campos abaixo serão adicionados pela equipe de Faturamento
			ObjF0T:SetValue("F0T_ITEM",SV5->V5_ITEMNF)
			ObjF0T:SetValue("F0T_MODELO",SV5->V5_ESPECNF)
			ObjF0T:SetValue("F0T_EXCPRB",Iif(SubStr(SV5->V5_CFOP,1,1)=="7",SV5->V5_TOTAL,SV5->V5_TOTBRUT-SV5->V5_TOTAL))					
			ObjF0T:SetValue("F0T_CODATV",SV5->V5_CODATIV)
			//-------------------------------			
			//Campos abaixo serão calculados por nós, considerando alíquota do código de atividade
			ObjF0T:SetValue("F0T_BCCPRB",Iif(SubStr(SV5->V5_CFOP,1,1)=="7",SV5->V5_TOTBRUT-SV5->V5_TOTAL,SV5->V5_TOTAL))					
			ObjF0T:SetValue("F0T_AQCPRB",nAlq)
			ObjF0T:SetValue("F0T_VLCPRB",Iif(SubStr(SV5->V5_CFOP,1,1)=="7",Round((SV5->(V5_TOTBRUT-V5_TOTAL)* nAlq)/100 ,2),Round((SV5->V5_TOTAL * nAlq)/100 ,2)))							
			
			ObjF0T:Grava()
		
		EndIF
		
		SV5->(DBSKIP())
	Enddo
	
Else
	cPreNome	:= 'FAT'+cFilAnt+'DES'+ Iif(lProcRH,cArqRh,cPeriodo)
	
	//O trecho abaixo está seguindo a mesma lógica que na função da INSSPAT no FATXFUN, para definição do nome do arquivo com log das notas
	If File(cPreNome+cExtDBF) // verifico se já existe um arquivo com o nome a ser gerado para criar com outro nome
		cNomeReal	:= cPreNome+cExtDBF //Considera este nome como último arquivo temporário criado
		cAliasTMP	:= cPreNome
		For nCont 	:= 1 to 100
			If File(cPreNome+"_"+AllTrim(Str(nCont))+cExtDBF)
				cNomeReal	:= cPreNome+"_"+AllTrim(Str(nCont))+cExtDBF
				cAliasTMP	:= cPreNome+"_"+AllTrim(Str(nCont))
			Else
				Exit
			EndIF
		Next nCont
		If nCont > 100
			cNomeReal	:= cPreNome+cExtDBF
			cAliasTMP	:= cPreNome
		EndIF
		//Abrir o arquivo
		//o Alias urilizado no FATXFUN é informação correspondente na cAliasTMP
		
		DbUseArea(.T., __LocalDriver, cAliasTMP, cAliasTMP,.T.,.T.)
		DbSelectArea(cAliasTMP)
		//cAliasTMP->(DbSetOrder(1))
		(cAliasTMP)->(dbGoTop()) 	
		If (cAliasTMP)->(FieldPos('ITEMNF')) > 0 
		
			Do While !(cAliasTMP)->(Eof ())
				If (cAliasTMP)->TIPO $ 'N/C/P' 
				
					nPos := aScan (aAliqAtv, {|aX| aX[1] ==  Alltrim((cAliasTMP)->CODATIV)})
					//Guardo as alíquotas e códigos de atividades processados para não chamar a SpedPCCG1 para todos os itens
					IF nPos == 0		
						nAlq	:= SpedPCCG1((cAliasTMP)->CODATIV,dDataAte)
						aAdd(aAliqAtv, {})
						nPos := Len(aAliqAtv)
						aAdd (aAliqAtv[nPos], Alltrim((cAliasTMP)->CODATIV))
						aAdd (aAliqAtv[nPos], nAlq)
					Else
						nAlq	:= aAliqAtv[nPos][2]
					EndIF
					
					ObjF0T:Clear()
					ObjF0T:SetValue("F0T_PER",dDataDe)
					ObjF0T:SetValue("F0T_FILAPU",cFilialMat)
					ObjF0T:SetValue("F0T_TIPO",Iif(lProcRH,'7' ,'6' )) //CPRB Regime de Caixa							
					ObjF0T:SetValue("F0T_NUMNF",(cAliasTMP)->NUMNF)
					ObjF0T:SetValue("F0T_SER",(cAliasTMP)->SERIE)
					ObjF0T:SetValue("F0T_DTEMI",CTOD(Substr( (cAliasTMP)->DATANF,7,2)  + '/'+ Substr( (cAliasTMP)->DATANF,5,2) + '/' + Substr( (cAliasTMP)->DATANF,1,4)))										
					ObjF0T:SetValue("F0T_CFOP",(cAliasTMP)->CFOP)
					ObjF0T:SetValue("F0T_VLCONT",(cAliasTMP)->TOTAL)
					
					//-------------------------------
					//Campos abaixo serão adicionados pela equipe de Faturamento
					ObjF0T:SetValue("F0T_ITEM",(cAliasTMP)->ITEMNF)
					ObjF0T:SetValue("F0T_MODELO",(cAliasTMP)->ESPECNF)
					ObjF0T:SetValue("F0T_EXCPRB",Iif(SubStr((cAliasTMP)->CFOP,1,1)=="7",(cAliasTMP)->TOTAL,(cAliasTMP)->TOTBRUTO-(cAliasTMP)->TOTAL))			
					ObjF0T:SetValue("F0T_CODATV",(cAliasTMP)->CODATIV)
					//-------------------------------			
					//Campos abaixo serão calculados por nós, considerando alíquota do código de atividade
					ObjF0T:SetValue("F0T_BCCPRB",Iif(SubStr((cAliasTMP)->CFOP,1,1)=="7",(cAliasTMP)->TOTBRUTO-(cAliasTMP)->TOTAL,(cAliasTMP)->TOTAL))			
					ObjF0T:SetValue("F0T_AQCPRB",nAlq)
					ObjF0T:SetValue("F0T_VLCPRB",Iif(SubStr((cAliasTMP)->CFOP,1,1)=="7",Round(((cAliasTMP)->(TOTBRUTO-(cAliasTMP)->TOTAL)* nAlq)/100 ,2),Round(((cAliasTMP)->TOTAL * nAlq)/100 ,2)))							
					
					ObjF0T:Grava()
				EndIf											
				(cAliasTMP)->(DBSKIP())
			Enddo
		EndIF
		
		DbSelectArea(cAliasTMP)
		dbCloseArea()		
		
	EndIF
	
EndIF

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A001Suced
 
Função de geração dos valores do F800 para o objeto
 
@author Henrique Pereira
@since 23/06/2016
@version 11.80

/*/
//-------------------------------------------------------------------
Static Function A001Suced(dDataDe, dDataAte,	oApurEFD)
Local cAliasF0X	:= 'F0X'
Local oGetF0X    := FISX001():New()

cAliasF0X	:=	GetNextAlias()
oGetF0X:GetF0X(dDataDe)

//Shiny acerto para evitar error.log
BeginSql Alias cAliasF0X

	SELECT
		%Exp:oGetF0X:GetcSlctF0X()%

	FROM
		%Exp:oGetF0X:GetcFromF0X()%
	WHERE
		%Exp:oGetF0X:GetcWhereF0X()%
EndSql

ProcRegua ((cAliasF0X)->(RecCount ()))	
DbSelectArea (cAliasF0X)
(cAliasF0X)->(DbGoTop ())
Do While !(cAliasF0X)->(Eof ())	
	
		oApurEFD:SetRegime(NAOCUMULAT)
		oApurEFD:SetOrigem(OUTROS)		
		oApurEFD:SetCodBcc('13')
		oApurEFD:SetDNatRec((cAliasF0X)->F0X_DTEVEN)
		oApurEFD:setCredSBse(.T.) // F800	
		oApurEFD:setIndCre('1')	
		//-------------------------------------------------------------------
		//Informações de PIS
		//-------------------------------------------------------------------			
		oApurEFD:SetTributo(PIS)
		oApurEFD:SetCST('  ')		
		oApurEFD:SetAlqTrib(0)
		oApurEFD:SetBcTrib(0)
		oApurEFD:SetValTrib((cAliasF0X)->F0X_VALPIS)
		oApurEFD:SetCodDC((cAliasF0X)->F0X_CODCRE)		
		oApurEFD:AgrpCred()
		

		//-------------------------------------------------------------------
		//Informações da COFINS
		//-------------------------------------------------------------------		
		oApurEFD:SetTributo(COFINS)		
		oApurEFD:SetCST('  ')
		oApurEFD:SetAlqTrib(0)
		oApurEFD:SetBcTrib(0)
		oApurEFD:SetValTrib((cAliasF0X)->F0X_VALCOF)
		oApurEFD:SetCodDC((cAliasF0X)->F0X_CODCRE)
		oApurEFD:AgrpCred()
		
		
		//Agrupa valores para resumo de CST
		oApurEFD:GrvResCST()		
		oApurEFD:SetImport(.F.)		
		
	(cAliasF0X)->(DbSkip ())			
EndDo

	DbSelectArea(cAliasF0X)
	dbCloseArea()
	oApurEFD:setCredSBse(.F.)
	oApurEFD:setIndCre('0')	

return

//-------------------------------------------------------------------
/*/{Protheus.doc} FSA001QECF
 
Função que irá montar a query para extrair as movimentações de cupom fiscal
do SigaLoja gravados na SFT. Esta query é utilizando de forma agrupada na apuração ou
então de forma individualizada no relatório de conferência FISR101.
 
@param lGroup 		- Booleano - Indica se é agrupado ou individualizado
@param cNrLivro 	- Caracter - Número do Livro
@param dDataDe 	- Date 		- Data inicial de processamento
@param dDataAte 	- Date 		- Data final de processamento

@author Erick G Dias
@since 29/08/2016
@version 11.80

/*/
//-------------------------------------------------------------------
Function FSA001QECF(lGroup,cNrLivro,dDataDe,dDataAte,lBilhete,lExigSusp)
     
Local cAliasSFT	:= "SFT"
Local cSlctSFT	:= ""
Local cFiltro		:= "" 
Local cOrderBy	:= ""
Local cExpIN := ""
Local cFrom	:= ""

Default lGroup	:= .T.
Default lBilhete := .F.
Default lExigSusp	:= .F.
// Definição da clausula IN do WHERE p/ bilhetes e cupons normais, conforme a chamada da função.
cExpIN := IIf(lBilhete, FormatIn('BPR',"|") , FormatIn('CF|ECF',"|"))
					

// ==============================================
// Query Principal - ECF
// ==============================================  

cSlctSFT := "SFT.FT_CLIEFOR,	SFT.FT_LOJA,		SFT.FT_ALIQPIS,		SFT.FT_ALIQCOF,"
cSlctSFT += "SFT.FT_CSTPIS,		SFT.FT_CSTCOF,		SFT.FT_ALIQCF3,		SFT.FT_ALIQPS3,"
cSlctSFT += "SFT.FT_TNATREC,	SFT.FT_CNATREC,		SFT.FT_GRUPONC,		SFT.FT_DTFIMNT,"
cSlctSFT += "SFT.FT_CFOP,		SFT.FT_PAUTPIS,		SFT.FT_PAUTCOF,		SF4.F4_TPREG,"
cSlctSFT += "SB1.B1_TPREG, 		SFT.FT_CONTA,		SFT.FT_FILIAL,		SFT.FT_TIPOMOV,"
cSlctSFT += "SFT.FT_SERIE,		SFT.FT_NFISCAL,		SFT.FT_NFELETR,		SFT.FT_ITEM,"
cSlctSFT +=	"SFT.FT_PRODUTO,	SFT.FT_ENTRADA,		SFT.FT_DTCANC, 		SFT.FT_OBSERV, 		SFT.FT_TIPO, "

If lGroup
	cSlctSFT +="SUM(SFT.FT_VALPIS)	AS	FT_VALPIS, 	SUM(SFT.FT_VALCOF)	 AS	FT_VALCOF,		SUM(SFT.FT_TOTAL)	AS	FT_TOTAL,"
	cSlctSFT +="SUM(SFT.FT_BASEPIS) AS	FT_BASEPIS,	SUM(SFT.FT_BASECOF)  AS	FT_BASECOF,	    SUM(SFT.FT_VALCF3)  AS	FT_VALCF3,"
	cSlctSFT +="SUM(SFT.FT_BASEPS3) AS	FT_BASEPS3,	SUM(SFT.FT_VALPS3)   AS	FT_VALPS3,		SUM(SFT.FT_BASECF3) AS	FT_BASECF3,"
	cSlctSFT +="SUM(SFT.FT_QUANT)   AS	FT_QUANT,	SUM(SFT.FT_VALCONT)	 AS	FT_VALCONT"
Else
	cSlctSFT +="SFT.FT_VALPIS,	SFT.FT_VALCOF,	SFT.FT_TOTAL,	SFT.FT_BASEPIS,"
	cSlctSFT +="SFT.FT_BASECOF,	SFT.FT_VALCF3,	SFT.FT_QUANT,	SFT.FT_VALCONT,"
	cSlctSFT +="SFT.FT_BASEPS3,	SFT.FT_VALPS3,	SFT.FT_BASECF3"
EndIF

If lExigSusp
	cSlctSFT += " , SFT.FT_ESPECIE  , SFT.FT_EMISSAO, SFT.FT_VALICM, SFT.FT_VALICM, SFT.FT_CHVNFE, CCF.CCF_NUMERO, CCF.CCF_IDITEM, CCF.CCF_INDAUT, CCF.CCF_NATJU, CCF.CCF_TIPO, CCF.CCF_TRIB, CID.CID_CST, CID.CID_REDUC, CID.CID_ICMS, CID.CID_ISS, CID.CID_ALIQ, CID.CID_CODREC"
EndIF

cSlctSFT	:=	'%'+cSlctSFT+'%'

cFrom	:= RetSqlName('SFT')+' SFT '
cFrom	+= " INNER JOIN "+RetSqlName("SFI")+" SFI ON (SFI.FI_FILIAL = '" + xFilial("SFI") + "' AND SFI.FI_PDV=SFT.FT_PDV AND SFI.FI_DTMOVTO=SFT.FT_ENTRADA AND SFI.D_E_L_E_T_=' ')"
cFrom	+= " INNER JOIN "+RetSqlName("SLG")+" SLG ON (SLG.LG_FILIAL = '" + xFilial("SLG") + "' AND SLG.LG_PDV=SFT.FT_PDV AND SLG.D_E_L_E_T_=' ' )"
cFrom	+= " INNER JOIN "+RetSqlName("SB1")+" SB1 ON(SB1.B1_FILIAL  = '" + xFilial("SB1") + "' AND SB1.B1_COD=SFT.FT_PRODUTO AND SB1.D_E_L_E_T_=' ')"
cFrom	+= " INNER JOIN "+RetSqlName("SD2")+" SD2 ON(SD2.D2_FILIAL  = '" + xFilial("SD2") + "' AND SD2.D2_DOC=SFT.FT_NFISCAL AND SD2.D2_SERIE=SFT.FT_SERIE AND SD2.D2_CLIENTE=SFT.FT_CLIEFOR AND SD2.D2_LOJA=SFT.FT_LOJA AND SD2.D2_COD=SFT.FT_PRODUTO AND SD2.D2_ITEM=SFT.FT_ITEM AND SD2.D_E_L_E_T_=' ')"
cFrom	+= " INNER JOIN "+RetSqlName("SF4")+" SF4 ON(SF4.F4_FILIAL  = '" + xFilial("SF4") + "' AND SF4.F4_CODIGO=SD2.D2_TES AND SF4.D_E_L_E_T_=' ')" 				

If lExigSusp
	//Aqui faço join com as tabelas CDG e CCF
	cFrom	   +="INNER JOIN "+RetSqlName("CDG")+" CDG ON(CDG.CDG_FILIAL='"+xFilial("CDG")+"'  AND CDG.CDG_TPMOV=SFT.FT_TIPOMOV  AND CDG.CDG_DOC=SFT.FT_NFISCAL AND CDG.CDG_SERIE=SFT.FT_SERIE AND CDG.CDG_CLIFOR=SFT.FT_CLIEFOR AND CDG.CDG_LOJA=SFT.FT_LOJA AND CDG.D_E_L_E_T_=' ') "		
	cFrom	   +="INNER JOIN "+RetSqlName("CCF")+" CCF ON(CCF.CCF_FILIAL='"+xFilial("CCF")+"'  AND CCF.CCF_NUMERO=CDG.CDG_PROCES  AND CCF.CCF_TIPO=CDG.CDG_TPPROC AND CCF.CCF_IDITEM=CDG.CDG_ITPROC AND CCF.CCF_TRIB IN('7','8') AND CCF.CCF_NATJU IN('12','13','14','15','16','17','19') AND CCF.CCF_TPCOMP IN ('1','2') AND CCF.D_E_L_E_T_=' ') "
	cFrom	   +="INNER JOIN "+RetSqlName("CID")+" CID ON(CID.CID_FILIAL='"+xFilial("CID")+"'  AND CID.CID_NUMERO=CCF.CCF_NUMERO  AND CID.CID_TIPO=CCF.CCF_TIPO AND CID.CID_INDAUT=CCF.CCF_INDAUT AND CID.CID_IDITEM = CCF.CCF_IDITEM AND CID.D_E_L_E_T_=' ') "
EndIF

cFrom	:=	'%'+cFrom+'%'

cAliasSFT	:=	GetNextAlias()

cFiltro	:= "%SFT.FT_FILIAL= '" + xFilial("SFT") + "'        AND "
cFiltro	+= "SFT.FT_TIPOMOV= 'S'                            AND "
cFiltro += "SFT.FT_ENTRADA>= '" + %Exp:DToS(dDataDe)% + "' AND "
cFiltro += "SFT.FT_ENTRADA<= '" + %Exp:DToS(dDataAte)% + "'AND "
cFiltro	+= "SFT.FT_DTCANC = ' '                            AND "
cFiltro	+= "SFT.FT_ESPECIE IN " + %Exp:cExpIN% + "       AND"
cFiltro	+= "((SFT.FT_BASEPIS > 0 OR SFT.FT_CSTPIS IN ('07','08','09','49' ))  OR (SFT.FT_BASECOF > 0 OR SFT.FT_CSTCOF IN ('07','08','09','49'))) AND "

If (cNrLivro <> "*")
	cFiltro += " SFT.FT_NRLIVRO = '" +%Exp:cNrLivro% +"' AND "
EndiF  

cFiltro += " SFT.D_E_L_E_T_=' '"

If lGroup
	cOrderBy += " GROUP BY "
	cOrderBy += "SFT.FT_CLIEFOR,		SFT.FT_LOJA,		SFT.FT_ALIQPIS,		SFT.FT_ALIQCOF,"
	cOrderBy += "SFT.FT_CSTPIS,			SFT.FT_CSTCOF,		SFT.FT_ALIQCF3,		SFT.FT_ALIQPS3, 	SFT.FT_CFOP,"
	cOrderBy += "SFT.FT_TNATREC,		SFT.FT_CNATREC,		SFT.FT_GRUPONC,		SFT.FT_DTFIMNT,"
	cOrderBy += "SFT.FT_PAUTPIS,		SFT.FT_PAUTCOF,		SF4.F4_TPREG,		SB1.B1_TPREG,"
	cOrderBy += "SFT.FT_FILIAL,			SFT.FT_TIPOMOV,		SFT.FT_SERIE,		SFT.FT_NFISCAL,		SFT.FT_NFELETR,"
	cOrderBy += "SFT.FT_CONTA,			SFT.FT_ITEM,		SFT.FT_PRODUTO, 	SFT.FT_ENTRADA, 	SFT.FT_DTCANC,	SFT.FT_OBSERV, SFT.FT_TIPO%"
Else
	cFiltro += "%"
EndIF


BeginSql Alias cAliasSFT
	COLUMN FT_DTFIMNT AS DATE
	COLUMN FT_ENTRADA As DATE
	COLUMN FT_DTCANC  AS DATE
	
	SELECT			    
		%Exp:cSlctSFT%
	FROM 
		%Exp:cFrom%

	WHERE 		
		%Exp:cFiltro+cOrderBy%	
						
EndSql  

Return cAliasSFT
//-------------------------------------------------------------------
/*/{Protheus.doc} FSA001QRYD
Funcao que efetua filtros em tabelas. Ela deve ser chamada como 1 para criar, 2 para fechar a area
criada e 3 para deletar registros
	
@param	nOpc -> Parametro que define se criara o filtro, fecha um filtro jah criado ou 
				deleta registros. 1=Criar, 2=Fechar, 3=Deletar
		cCompon -> 	Se trata de um flag atraves do componente a ser criado o filtro. 
					No caso de haver mais de um filtro para a mesma tabela em situacoes diferentes, 
					basta acrescentar um identificador na quarta posicao do nome. Ex: SFT, SFT1, SF2, etc..
		cAlias -> Variavel passada por referencia para retornar o alias criado para o componente em questao.
		aPar -> Parametros para execucao dos filtros
		nRecCount ->Se esta variavel for passada diferente de NIL,significa que a query deve retornar a 
					quantidade de registros. Utilizado para montar a regua de processamento mais precisa.
					O retorno serah nesta mesma variavel que deve ser passada como referencia. O retorno 
					da funcao ainda continua sendo .T. quando tiver registros ou .F. quando nao tiver.
	
@return lRet -> Booleano para identificar se a tabela possui registros ou nao. No caso de retornar .F., 
				nao eh necessário chamar a funcao com o primeiro parametro igual a 2, pois se nao houver 
				movimento, ela fecha o alias automaticamente.
		

@author Luccas Curcio
@since 10/09/2012
@version 1.0
/*/
//-------------------------------------------------------------------

Function FSA001QRYD(nOpc,cCompon,cAlias,aPar,nRecCount,dDataDe)
Local	cSelect		:=	""
Local	cFrom		:=	""
Local	cWhere		:=	""
Local	cOrderBy	:=	""
Local	cIndex		:=	""
Local	lCountReg	:=	nRecCount<>Nil
Local   lB1TPREG    := SB1->(FieldPos("B1_TPREG")) > 0
Local	lRet		:=	.F.
Local	aSetField	:=	{}
Local	nI			:=	0
Local   lF0T		:= AliasINdic('F0T')
Local   cChaveF0T	:= ''
Local   lCPRBNF		:= GetNewPar('MV_CPRBNF',.T.) .And. SFT->(FieldPos("FT_VALCPB")) > 0 .And. SFT->(FieldPos("FT_BASECPB")) > 0 .And. SFT->(FieldPos("FT_ALIQCPB")) > 0  
Local 	lSe1MsFil	:= SE1->(FieldPos("E1_MSFIL")) > 0
Local 	lSe5MsFil	:= SE5->(FieldPos("E5_MSFIL")) > 0
Local 	lUnidNeg 	:= FWSizeFilial() > 2	// Indica se usa Gestao Corporativa
Local 	cFilSe1		:= xFilial("SE1")
Local 	cFilSe5		:= xFilial("SE5")
Local 	cCpoFilSE5  := ""
Local 	dDataMaior	:= cTod('  /  /    ')

DEFAULT dDataDe	    := cTod('  /  /    ')

If nOpc == 1

	If cCompon == "SE1"

		//SELECT
		If lCountReg
			cSelect	:=	"%COUNT(*) COUNTREG%"
		Else
			//Como o left join do SE5 filtra somente o mês processado, preciso pegar a próxima data do aPar[2] - Data Até
			//para ajustar o SE5 nulo do filtro da query.
			dDataMaior	:= IIf(Len(aPar)>1, DaySum(aPar[2],1), dDataMaior) 

			//Campos que utilizarao Alias no Processamento
			cSelect	:=	"%SE1.E1_EMISSAO EMISSAO, SE1.E1_NUM DOC, SE1.E1_SALDO SALDO, SE1.E1_VALOR VALOR, "
			cSelect	+=	"SED.ED_CSTPIS CSTPIS, SED.ED_CSTCOF CSTCOF, CASE WHEN SED.ED_TPREG=' ' THEN SED.ED_INDCMLT ELSE (CASE WHEN SED.ED_TPREG='1' THEN '2' WHEN SED.ED_TPREG='2' THEN '1' ELSE '' END) END TPREG, SED.ED_PCAPPIS ALIQPIS, "
			cSelect	+=	"SED.ED_PCAPCOF ALIQCOF, SA1.A1_CGC CNPJCLI, SE5.E5_DATA DATABX, SE5.E5_TIPODOC TIPODOC, "
			cSelect	+=	"(SE5.E5_VALOR + SE5.E5_VLDESCO) VALORBX, SFT.FT_NFISCAL NFISCAL, SFT.FT_ENTRADA  , SFT.FT_NRLIVRO NRLIVRO, SB1.B1_COD CODPROD, SD2.D2_PROJPMS PROJETO, "            
			
			//Outros campos
			cSelect	+=	"SE1.E1_FILIAL,	SE1.E1_PREFIXO,  SE1.E1_PARCELA,SE1.E1_TIPO, SE1.E1_PARCELA, SE1.R_E_C_N_O_, SE1.E1_CLIENTE, SE1.E1_LOJA, "
			cSelect	+=	"SFT.FT_VALCONT, SFT.FT_ALIQPIS, SFT.FT_ALIQCOF, SFT.FT_CSTPIS, SFT.FT_CSTCOF, SFT.FT_VALPIS, SFT.FT_VALCOF, SFT.FT_BASEPIS, SFT.FT_BASECOF, SFT.FT_SERIE, SFT.FT_CLIEFOR, SFT.FT_LOJA, SFT.FT_ITEM, "
			cSelect	+=	"SF4.F4_TPREG, "
			cSelect	+=	"SB1.B1_PPIS, SB1.B1_PCOFINS, SB1.B1_PCSLL, SE6.E6_FILDEB, SF2.F2_VALBRUT, SFT.FT_TIPO, SFT.FT_TIPOMOV, SFT.FT_VALIPI, SFT.FT_VALICM,"

			If lCPRBNF
				cSelect	+=	"SFT.FT_VALCPB, SFT.FT_BASECPB, SFT.FT_ALIQCPB, SFT.FT_ATIVCPB, "
			EndIf
			
			If SB1->(FieldPos(aPar[3])) > 0
				cSelect	+=	"SB1."+aPar[3]+", " 
			Endif
			
			IF lB1TPREG
				cSelect	+=	"SB1.B1_TPREG, "			
			EndIF
						
			cSelect	+=	"SA1.A1_COD, SA1.A1_LOJA, "
			
			If SA1->(FieldPos(aPar[4])) > 0
				cSelect	+=	"SA1."+aPar[4]+", "
			Endif
			
			If SA1->(FieldPos("A1_IRBAX"))>0
				cSelect	+=	"SA1.A1_IRBAX, "
			Endif

			If SA1->(FieldPos("A1_TPREG"))>0 //Adicionado o Fieldpos pois esse campo eh criado pelo usuario.
				cSelect	+=	"SA1.A1_TPREG, "
			Endif

			cSelect	+= "SA1.A1_CGC CNPJCLI, "
			
			cSelect	+=	"SED.ED_CODIGO,	SED.ED_PERCPIS,	SED.ED_PERCCOF,	SED.ED_PERCCSL, "
			cSelect	+=	"SE5.E5_MOTBX,SE5.E5_NUMERO,	SE5.E5_PREFIXO,	SE5.E5_MOEDA,	SE5.E5_PARCELA,	SE5.E5_VRETPIS, SE5.E5_VRETCOF,	SE5.E5_VRETCSL,	E5_VRETISS,	E5_VRETIRF,	SE5.E5_VLJUROS, SE5.E5_VLMULTA,	SE5.E5_VLDESCO, SE5.E5_TIPO, SE5.E5_SEQ, SE5.E5_DATA%"
		Endif
	    
	    //FROM
		//Tabela Principal: SE1
		//Joins: 	SE1->SFT->SB1 / SE1->SF2->SFT->SB1
		//			SE1->SFT->SD2->SF4 / SE1->SF2->SFT->SD2->SF4
		//			SE1->SE5
		//			SE1->SED
		//			SE1->SA1
		If lUnidNeg
			cFilSe5 := SM0->M0_CODFIL
			cFilSe1 := SM0->M0_CODFIL
		EndIF

		cFrom	:=	"%"+RetSqlName("SE1")+" SE1 "
		
		// -- JOIN SA1 --
		cFrom	+=	"JOIN "+RetSqlName("SA1")+" SA1 ON SA1.A1_FILIAL='"+xFilial("SA1")+"' AND SA1.A1_COD=SE1.E1_CLIENTE AND SA1.A1_LOJA=SE1.E1_LOJA AND SA1.D_E_L_E_T_ = '' "

		// -- LEFT JOIN SED --
		cFrom	+=	"LEFT JOIN "+RetSqlName("SED")+" SED ON SED.ED_FILIAL='"+xFilial("SED")+"' AND SED.ED_CODIGO=SE1.E1_NATUREZ AND "
		//Cadastro indica que utiliza Pis/Cofins
		cFrom	+=	"(SED.ED_APURCOF<>'' OR SED.ED_APURPIS<>'') AND SED.D_E_L_E_T_ = '' "

		// -- LEFT JOIN SE6 --
		cFrom	+=	"LEFT JOIN "+RetSqlName("SE6")+" SE6 ON SE6.E6_FILORIG= '"+xFilial("SE6")+"' AND SE6.E6_PREFIXO=SE1.E1_PREFIXO AND SE6.E6_NUM=SE1.E1_NUM and SE6.E6_PARCELA=SE1.E1_PARCELA  and SE6.E6_TIPO=SE1.E1_TIPO AND SE6.D_E_L_E_T_ = '' "
		
		// -- LEFT JOIN SE5 --
		// Tratamento de Filiais quando SE5 Compartilhada/Exclusiva
		If !Empty( Iif( lUnidNeg, FWFilial("SE5") , xFilial("SE5") ) )
			cCpoFilSE5 	:= "SE5.E5_FILIAL = '"  +   xFilial("SE5") + "'"
		Else
			If lSe5MsFil
				cCpoFilSE5 	:= "SE5.E5_MSFIL = '" + Iif(lUnidNeg, cFilSe5, cFilAnt) + "' "
			Else
				cCpoFilSE5 	:= "SE5.E5_FILORIG = '" + Iif(lUnidNeg, cFilSe5, cFilAnt) + "' "
			Endif
		EndIf
		cFrom	+=	"LEFT JOIN "+RetSqlName("SE5")+" SE5 ON (" + cCpoFilSE5 + " AND SE5.E5_TIPODOC NOT IN ('DC','JR','MT') AND SE5.E5_PREFIXO=SE1.E1_PREFIXO AND SE5.E5_NUMERO=SE1.E1_NUM AND SE5.E5_PARCELA=SE1.E1_PARCELA AND SE5.E5_TIPO=SE1.E1_TIPO AND "
		cFrom	+=	"SE5.E5_DATA>='"+DTOS(aPar[1])+"' AND SE5.E5_DATA<='"+DTOS(aPar[2])+"' AND "
		cFrom	+=	"SE5.E5_CLIFOR=SE1.E1_CLIENTE AND SE5.E5_LOJA=SE1.E1_LOJA AND "		


		//Subquery utilizada para eliminar sequencias que possuem estorno de baixas
		cFrom	+=	"SE5.E5_SEQ NOT IN (SELECT SE5SEQ.E5_SEQ " 
		cFrom	+=	"FROM "+RetSqlName("SE5")+" SE5SEQ " 
		cFrom	+=	"WHERE SE5SEQ.E5_FILIAL	=	SE5.E5_FILIAL AND " 
		cFrom	+=	"SE5SEQ.E5_PREFIXO	=	SE5.E5_PREFIXO AND "
		cFrom	+=	"SE5SEQ.E5_NUMERO	=	SE5.E5_NUMERO AND "
		cFrom	+=	"SE5SEQ.E5_PARCELA	=	SE5.E5_PARCELA AND "
		cFrom	+=	"SE5SEQ.E5_TIPO		= 	SE5.E5_TIPO AND "
		cFrom	+=	"SE5SEQ.E5_CLIFOR	= 	SE5.E5_CLIFOR AND "
		cFrom	+=	"SE5SEQ.E5_LOJA		= 	SE5.E5_LOJA AND "
		cFrom	+=	"SE5SEQ.E5_TIPODOC	=	'ES' AND "
		cFrom	+=	"SE5SEQ.D_E_L_E_T_	= ' ') AND "

		//Elimina estorno, Motivos de Baixa, Situacao de Documento 
		cFrom	+=	"SE5.E5_TIPODOC	<> 'ES' AND "
		cFrom	+=	"SE5.E5_MOTBX NOT IN ('LIQ','CEC') AND "
		cFrom	+=	"SE5.E5_SITUACA <> 'C' AND "	
		cFrom	+=	"SE5.D_E_L_E_T_ =  ' ') "
		
		// -- LEFT JOIN SFT/SF2 --
		//Verifico conteudo do parametro MV_1DUPREF, pois se utilizar o padrao (SF2->F2_SERIE), o prefixo do titulo eh gravado
		//com a serie da nota fiscal. Porem se utilizar outro conteudo, devera utilizar o campo F2_PREFIXO para encontrar a nota
		//vinculada ao titulo, entao precisa utilizar a tabela SF2 no JOIN antes da SFT.
		// Comentei e deixei sempre buscando da SF2, pois necessitaremos do F2_valbrut para fazer a proporção do item em relação ao total
//		If aPar[5] <> "SF2->F2_SERIE"
			cFrom	+=	"LEFT JOIN "+RetSqlName("SF2")+" SF2 ON SF2.F2_FILIAL='"+xFilial("SF2")+"' AND SF2.F2_DOC=SE1.E1_NUM AND SF2.F2_PREFIXO=SE1.E1_PREFIXO AND SF2.F2_CLIENT=SE1.E1_CLIENTE AND SF2.F2_LOJA=SE1.E1_LOJA AND SF2.D_E_L_E_T_ = '' "
			cFrom	+=	"LEFT JOIN "+RetSqlName("SFT")+" SFT ON SFT.FT_FILIAL='"+xFilial("SFT")+"' AND SFT.FT_SERIE=SF2.F2_SERIE AND SFT.FT_NFISCAL=SF2.F2_DOC AND SFT.FT_CLIEFOR=SF2.F2_CLIENT AND SFT.FT_LOJA=SF2.F2_LOJA AND " 
//		Else
//			cFrom	+=	"LEFT JOIN "+RetSqlName("SFT")+" SFT ON SFT.FT_FILIAL='"+xFilial("SFT")+"' AND SFT.FT_SERIE=SE1.E1_PREFIXO AND SFT.FT_NFISCAL=SE1.E1_NUM AND SFT.FT_CLIEFOR=SE1.E1_CLIENTE AND SFT.FT_LOJA=SE1.E1_LOJA AND "
//		Endif
		//Condicoes do SPED Contribuicoes
	    cFrom	+=	"(((SFT.FT_BASEPIS>0 OR SFT.FT_BASEPS3>0) OR SFT.FT_CSTPIS IN ('07','08','09','49')) OR ((SFT.FT_BASECOF>0 OR SFT.FT_BASECF3>0) OR SFT.FT_CSTCOF IN ('07','08','09','49'))) AND "
	    cFrom	+=	"SFT.D_E_L_E_T_ = '' "
		
		// -- LEFT JOIN SD2 --
		cFrom	+=	"LEFT JOIN "+RetSqlName("SD2")+" SD2 ON SD2.D2_FILIAL='"+xFilial("SD2")+"' AND SD2.D2_DOC=SFT.FT_NFISCAL AND SD2.D2_SERIE=SFT.FT_SERIE AND SD2.D2_CLIENTE=SFT.FT_CLIEFOR AND SD2.D2_LOJA=SFT.FT_LOJA AND SD2.D2_COD=SFT.FT_PRODUTO AND SD2.D2_ITEM=SFT.FT_ITEM  AND SD2.D_E_L_E_T_='' "
		
		// -- LEFT JOIN SF4 --
		cFrom	+=	"LEFT JOIN "+RetSqlName("SF4")+" SF4 ON SF4.F4_FILIAL='"+xFilial("SF4")+"' AND SF4.F4_CODIGO=SD2.D2_TES AND SF4.D_E_L_E_T_='' "
		
		// -- LEFT JOIN SB1 --		
		cFrom	+=	"LEFT JOIN "+RetSqlName("SB1")+" SB1 ON SB1.B1_FILIAL='"+xFilial("SB1")+"' AND SB1.B1_COD=SFT.FT_PRODUTO AND SB1.D_E_L_E_T_ = ''%"
		
	    //WHERE
	    //Filial
		// Tratamento de Filiais quando SE1 Compartilhada/Exclusiva
		If !Empty( Iif( lUnidNeg , FWFilial("SE1") , xFilial("SE1") ) )
			cWhere 	+= "%SE1.E1_FILIAL = '"  +   xFilial("SE1") + "' AND "
		Else
			If lSe1MsFil
				cWhere 	+= "%SE1.E1_MSFIL = '" + Iif(lUnidNeg, cFilSe1, cFilAnt) + "' AND "
			Else
				cWhere 	+= "%SE1.E1_FILORIG = '" + Iif(lUnidNeg, cFilSe1, cFilAnt) + "' AND "
			Endif
		EndIf
	
		//Titulos emitido dentro do periodo ou Titulos emitidos anteriormente com baixa no periodo e baixa depois do periodo
		cWhere	+=	"((SE1.E1_EMISSAO>='"+DTOS(aPar[1])+"' AND SE1.E1_EMISSAO<='"+DTOS(aPar[2])+"' AND SE1.E1_SALDO>0 ) OR "
		cWhere	+=	"(SE1.E1_EMISSAO<'"+DTOS(aPar[1])+"' AND (SE5.E5_DATA>='"+DTOS(aPar[1])+"' AND SE5.E5_DATA<='"+DTOS(aPar[2])+"') )  OR " 
		cWhere	+=	"(SE1.E1_EMISSAO>='"+DTOS(aPar[1])+"' AND SE1.E1_EMISSAO<='"+DTOS(aPar[2])+"' AND (COALESCE(SE5.E5_DATA,'"+DTOS(dDataMaior)+"')>'"+DTOS(aPar[2])+"' AND SE1.E1_SALDO=0) ) ) AND "
		
		//Titulos emitidos para Orgao Publico
		cWhere	+=	"SE1.E1_SCORGP='1' AND "
		cWhere	+=	"SE1.E1_TIPO NOT IN ('PR ','PRE') AND " 
		cWhere	+=	"SE1.E1_ORIGEM NOT IN ('FINA460 ','FINA280') AND " 
		cWhere	+=	"SE1.E1_FATURA	= ' ' AND "
		cWhere	+=	"SE1.D_E_L_E_T_ = ' ' "
		
		//ORDER BY
		If !lCountReg
			cOrderBy	:=	"ORDER BY SE5.E5_NUMERO, SE5.E5_PREFIXO%"
		Else
			cOrderBy	:=	"%"
		Endif
		
		aAdd(aSetField,{"EMISSAO","D",8,0})
		aAdd(aSetField,{"DATABX","D",8,0})
		aAdd(aSetField,{"FT_ENTRADA","D",8,0})
	
	
	Elseif cCompon == "CF8"
	    
		//SELECT
		If lCountReg
			cSelect	:=	"%COUNT(*) COUNTREG%"
		Else
			cSelect	:=	"%SA1.A1_CGC CNPJCLI, CF8.CF8_DTOPER EMISSAO, CF0.CF0_DATA DATABX, CF8.CF8_CODIGO DOC, "
			cSelect	+=	"CF8.CF8_ITEM CODPROD, CF8.CF8_SALDO SALDO, CF0.CF0_RECBAS VALORBX, CF8.CF8_BASPIS VALOR, "
			cSelect	+=	"CF8.CF8_CSTPIS CSTPIS, CF8.CF8_CSTCOF CSTCOF, CF8.CF8_TPREG TPREG, CF8.CF8_ALQPIS ALIQPIS, CF8.CF8_ALQCOF ALIQCOF%"
		Endif
		
		//FROM
		//Tabela Principal: CF8
		//Joins: 	CF8->CF0
		//			CF8->SA1
		//			CF8->SB1
		cFrom	:=	"%"+RetSqlName("CF8")+" CF8 "
		
		// -- LEFT JOIN CF0 --
		cFrom	+=	"LEFT JOIN "+RetSqlName("CF0")+" CF0 ON CF0.CF0_FILIAL='"+xFilial("CF0")+"' AND CF0.CF0_CODIGO=CF8.CF8_CODIGO AND CF0.CF0_DATA >= '"+DTOS(aPar[1])+"' AND CF0.CF0_DATA <= '"+DTOS(aPar[2])+"' AND CF0.D_E_L_E_T_='' "
		
        // -- LEFT JOIN SB1 --
		cFrom	+=	"LEFT JOIN "+RetSqlName("SB1")+" SB1 ON SB1.B1_FILIAL='"+xFilial("SB1")+"' AND SB1.B1_COD=CF8.CF8_ITEM AND SB1.D_E_L_E_T_ = '' "
		
		// -- LEFT JOIN SA1 --
		cFrom	+=	"LEFT JOIN "+RetSqlName("SA1")+" SA1 ON SA1.A1_FILIAL='"+xFilial("SA1")+"' AND SA1.A1_COD=CF8.CF8_CLIFOR AND SA1.A1_LOJA=CF8.CF8_LOJA AND SA1.D_E_L_E_T_=''%"
		
		//WHERE
		//Filial
		cWhere	+=	"%CF8.CF8_FILIAL	= '"+xFilial("CF8")+"' AND "
		
		//Documentos emitidos para Orgao Publico
		cWhere	+=	"CF8.CF8_SCORGP='1' AND "
		
		//Documentos emitido dentro do periodo ou Documentos emitidos anteriormente com baixa no periodo
		cWhere	+=	"( (CF8.CF8_DTOPER>='"+DTOS(aPar[1])+"' AND CF8.CF8_DTOPER<='"+DTOS(aPar[2])+"' AND CF8.CF8_SALDO>0 ) OR "
		cWhere	+=	"(CF8.CF8_DTOPER<'"+DTOS(aPar[1])+"' AND (CF0.CF0_DATA >= '"+DTOS(aPar[1])+"' AND CF0.CF0_DATA <= '"+DTOS(aPar[2])+"') ) ) AND "
		cWhere	+=	"CF8.D_E_L_E_T_ = '' "
		
		If !lCountReg
			cOrderBy	:=	"ORDER BY CF8.CF8_CODIGO%"
		Else
			cOrderBy	:=	"%"
		Endif
		
		aAdd(aSetField,{"EMISSAO","D",8,0})
		aAdd(aSetField,{"DATABX","D",8,0})
		
	Endif
	If (TcSrvType ()<>"AS/400")
		cAlias	:=	SPEDGetAlias(cCompon)
		BeginSql Alias cAlias
		COLUMN EMISSAO AS DATE
		COLUMN DATABX  AS DATE
		COLUMN E5_DATA AS DATE
			SELECT 
				%Exp:cSelect%
		
			FROM 
				%Exp:cFrom%
		
			WHERE 
				%Exp:cWhere+cOrderBy%
		
		EndSql
			
		If !lCountReg
			For nI := 1 To Len(aSetField)
				TcSetField(cAlias,aSetField[nI,1],aSetField[nI,2],aSetField[nI,3],aSetField[nI,4])
			Next
		Else
			//Se o retorno deve ser a quantidade de registros, armazeno em uma variavel para retornar
			nRecCount	:=	(cAlias)->COUNTREG
		EndIf
	Else

		DbSetIndex(cIndex+OrdBagExt())
		
	EndIf

	//Como jah armazenei em uma variavel o valor da quantidade de registros, posso fechar a area. 
	//O retorno da quantidade eh atraves de um parametro passado por referencia. O retorno da funcao ainda continua
	//sendo .T. quando tiver registros ou .F. quando nao tiver.
	If lCountReg
		FSA001QRYD(2,"",cAlias)	
		
		lRet	:=	nRecCount>0

	ElseIf !(cAlias)->(Eof())
		lRet	:=	.T.
		
	Else
		FSA001QRYD(2,"",cAlias)
	EndIf
	
Elseif nOpc == 2

		If (TcSrvType ()<>"AS/400")
			If Select(cAlias)<>0
				(cAlias)->(DbCloseArea())
			EndIf
		Else
			RetIndex(cAlias)
		EndIf

Elseif nOpc == 3
	
	//DIFERIMENTO
	If aPar[1] == "CFA" .Or. aPar[1] == "CFB" 
        
		If SPEDSeek("CFA",aPar[2],aPar[3])
			Do While CFA->(CFA_FILIAL+CFA_PERAPU) == aPar[3]
			    RecLock("CFA",.F.)
				CFA->(DbDelete())
				MsUnLock()
				CFA->(DbSkip())
			Enddo
		Endif
		
		If SPEDSeek("CFB",aPar[2],aPar[3])
			Do While CFB->(CFB_FILIAL+CFB_PERAPU) == aPar[3]
			    RecLock("CFB",.F.)
				CFB->(DbDelete())
				MsUnLock()
				CFB->(DbSkip())
			Enddo
		Endif
		
		IF lF0T
			DbSelectArea('F0T')
			DbSetOrder(2)
			cChaveF0T	:= xFilial('F0T') +dTos(dDataDe)
		EndIF
		
		If lF0T  .AND. F0T->(MsSeek(cChaveF0T+'4'))
			//Deleta F0T do tipo 4
			Do While F0T->(F0T_FILIAL+DTOS(F0T_PER)+F0T_TIPO) == cChaveF0T+'4'
			   RecLock("F0T",.F.)
				F0T->(DbDelete())
				MsUnLock()
				F0T->(DbSkip())
			Enddo		
		EndIf
		
		IF lF0T  .AND. F0T->(MsSeek(cChaveF0T+'5'))
			Do While F0T->(F0T_FILIAL+DTOS(F0T_PER)+F0T_TIPO) == cChaveF0T+'5'
			   RecLock("F0T",.F.)
				F0T->(DbDelete())
				MsUnLock()
				F0T->(DbSkip())
			Enddo				
		EndIF 
		
	Endif
	
Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} PrcInfDif
Funcao que ira processar os registros referente ao Diferimento de Orgao Publico. 
Serao alimentadas as tabelas CFA e CFB, que apos processamento do Arquivo magnetico, 
irao gerar os registro M230, M630, M300 e M700.
	
@param	dDataDe -> Data Inicial de Processamento
		dDataAte -> Data Final de Processamento
		cPerApur -> Periodo do processamento
		cNrLivro -> Numero do Livro fiscal
		cAlias -> Alias da query que esta sendo processada
		cRegime -> Regime selecionado nas perguntas da rotina (1,2,3)
		lEnd -> Flag de cancelamento do processamento
		aColsCFAP -> Informacoes que serao mostradas na Dialog
		aColsCFAC -> Informacoes que serao mostradas na Dialog
		aColsCFBP -> Informacoes que serao mostradas na Dialog
		aColsCFBC -> Informacoes que serao mostradas na Dialog
		nRecCount -> Numero de registros do processamento, para montagem da regua
		cPrefixE1 -> Conteudo do parametro MV_1DUPREF
		cCmpB1Dif -> Campo da tabela SB1 que indica Diferimento de Org. Publico
		cCmpA1Dif -> Campo da tabela SA1 que indica Diferimento de Org. Publico
		cOrigem -> Origem do processamento (SE1 ou CF8)
		lProcDfCrd	-> Indica se ira realizar o processamento de Diferimento dos créditos de PIS e COFINS
		cIndNatPJ	-> Indicador da Natureza da Pessoa Juridica
		ObjF0T	-> Objeto da tabela F0T, para gravação do detalhamento do diferimento analítico
		
@return	Nil
		
@author Luccas Curcio
@since 10/09/2012
@version 1.0
/*/
//-------------------------------------------------------------------
Function FSA001PRCD(dDataDe,dDataAte,cPerApur,cNrLivro,cAlias,; //5
					cRegime,lEnd,aColsCFAP,aColsCFAC,aColsCFBP,;//10
					aColsCFBC,nRecCount,cPrefixE1,cCmpB1Dif,cCmpA1Dif,;//15
					cOrigem,lProcDfCrd,cIndNatPJ,ObjF0T,LFISA054,aXFilial,lDedIssBs,lAuto)//23					
							 
	Local	cNtFiscal	:= ""
	Local	cCSTPis		:= ""
	Local	cCSTCof		:= ""
	Local	cTpReg		:= ""
	Local	cTimeDocs	:= ""
	Local	cMsgProcess	:= ""
	Local	cChvDoc		:= ""
	Local  	cCodBCPIS	:= ""
	Local  	cCodBCCOF	:= ""
	Local	nAlqPis		:= 0
	Local	nAlqCof		:= 0
	Local	nPisDifer	:= 0
	Local	nPisPago	:= 0
	Local	nCofDifer	:= 0
	Local	nCofPago	:= 0

	//CPRB
	Local  	cCodBCCPB	:= ""
	Local	nAlqCpb		:= 0
	Local	nCpbPago	:= 0
	Local  	nCredCpbDf	:= 0
	Local   cCodAtvCPB	:= ""
	Local 	lCPRBNF		:= GetNewPar('MV_CPRBNF',.T.) .And. SFT->(FieldPos("FT_VALCPB")) > 0 .And. SFT->(FieldPos("FT_BASECPB")) > 0 .And. SFT->(FieldPos("FT_ALIQCPB")) > 0  
	Local 	nValIPI		:= 0

	Local	nPercVlrNt	:= 0
	Local	nPercRec	:= 0
	Local	nTotDifer	:= 0
	Local	nTotVend	:= 0
	Local	nVlrReten	:= 0
	Local	nDocsXTime	:= 0
	Local	nRegsProc	:= 0
	Local	nTotTit		:= 0
	Local	nTranStat	:= 0
	Local	cPerEmis	:= 0
	Local	nPerBx		:= 0
	Local	nPos		:= 0
	Local  	nCredPisDf	:= 0
	Local	aValores	:= {}
	Local	aDocs		:= {}
	Local	lBxCanc		:= .F.
	Local	lBxPerPos	:= .F.
	Local 	lIsBlind	:= IsBlind()
	Local   cNatCre		:= ""
	Local	lTransfere	:= .F.
	Local 	lF0T		:= AliasINdic('F0T')
	Local 	nCredCOFDf	:= 0
	Local 	aSldCrdDif	:= {}
	Local 	nSomaAbat	:= 0
	Local 	nTotNF		:= 0
	Local 	nDiferenca	:= 0
	Local 	nRRecebida	:= 0
	Local 	aF0T		:= {}
	Local 	nF0T		:= 0
	Local 	cF0T 		:= ""
	Local	nValISS 	:= 0
	Local   l12_1_2610  := GetRpoRelease() >= "12.1.2610"
	Local   lClFinMove  := FindClass('totvs.protheus.backoffice.fin.movements.Movements')
	Local   oJSqlName   := QrySqlName()
	Default	cPrefixE1	:= ""
	Default	cCmpB1Dif	:= ""
	Default	cCmpA1Dif	:= ""
	DEFAULT LFISA054	:= .F.
	DEFAULT aColsCFAP	:= {}
	DEFAULT aColsCFAC	:= {}
	DEFAULT aColsCFBP	:= {}
	Default aColsCFBC	:= {}
	DEFAULT nRecCount	:= 0
	DEfault lEnd		:= .F.
	Default aXFilial	:= {}
	Default lAuto       := .F.

	dbSelectArea("SE6")
	SE6->(dbSetOrder(5))
	Do While !(cAlias)->(Eof())

		nTotRec		:= 0
		nVlrReten	:= 0
		lBxCanc		:= .F.
		lBxPerPos	:= .F.
		cPerEmis	:= Substr(DTOS((cAlias)->EMISSAO),5,2)+Substr(DTOS((cAlias)->EMISSAO),1,4)
		nPerBx		:= Substr(DTOS((cAlias)->DATABX),5,2)+Substr(DTOS((cAlias)->DATABX),1,4)
		lTransfere	:= .F.	
		nSomaAbat	:= 0
		nTotNF		:= 0
		nTotTit		:= 0
		nDiferenca	:= 0
		nRRecebida	:= 0
		
		// --------------------------------------> INCREMENTO DA REGUA <--------------------------------------
		//Definindo o segundo incremento da regua e seu controle de detalhes
		IF LFISA054 
			If Type("oProcess")=="O"
				oProcess:Inc2Progress("Processando Documento: "+(cAlias)->DOC+" emitido em: "+DTOC((cAlias)->EMISSAO),StrZero(nRegsProc,6)+"/"+StrZero(nRecCount,6))//"Processando Documento: "###" emitido em: "###
		
				//Condicao implementada para controlar os numeros apresentadas na tela de processamento da rotina, os detalhes.
				If cTimeDocs<>Time()
					oProcess:SetDetProgress("Total de registros do periodo solicitado",nRecCount,;//"Total de registros do periodo solicitado"
							"Total de registros processados por segundo",nDocsXTime,;//"Total de registros processados por segundo"
							"Total de registros pendentes para processamento",nRecCount-nRegsProc,;//"Total de registros pendentes para processamento"
							"Tempo estimado para termino do processamento (Seg.)",Round((nRecCount-nRegsProc)/nDocsXTime,0))//"Tempo estimado para termino do processamento (Seg.)"
							
					cTimeDocs	:=	Time()
					nDocsXTime	:=	1
				Else
					nDocsXTime	+=	1
				EndIf
				
				//Controle do cancelamento da rotina
				If oProcess:Cancel()
					Exit
				EndIf
			Else
		
				aEval(aSM0,{|x| cMsgProcess := Iif(x[SM0_GRPEMP]==cEmpAnt .And. x[SM0_CODFIL]==cFilAnt .And. x[SM0_USEROK] .And. (x[SM0_EMPOK] .Or. lIsBlind),x[SM0_CODFIL]+"/"+x[SM0_FILIAL],"")})
				cMsgProcess	:=	AllTrim(cMsgProcess)
			
				IncProc("Processando Filial: "+cMsgProcess)//"Processando Filial: "
				
				//Controle do cancelamento da rotina
				If Interrupcao(@lEnd)
					Exit
				EndIf
			EndIf
		EndIF
		// --------------------------------------> ------------------- <--------------------------------------
		
		If cOrigem == "SE1"
			If cCmpB1Dif <> "" .And. !Empty((cAlias)->NFISCAL) .And. (cAlias)->(&(cCmpB1Dif)) <> "1"
				(cAlias)->(DbSkip())
				Loop
			Endif

			If cNrLivro <> "*"
				If !Empty((cAlias)->NFISCAL) .And. !(cAlias)->NRLIVRO==cNrLivro
					(cAlias)->(DbSkip())
					Loop
				Endif
			Endif
			
			//Se o título estiver gravado na SE6 com a filial de origem diferente da filial corrente processada, deverá desconsiderar esta operação			
			//E6_FILDEB+E6_PREFIXO+E6_NUM+E6_PARCELA+E6_TIPO                                                                                                                  
			If SE6->(MsSeek(xFilial("SE6")+(cAlias)->E1_PREFIXO+(cAlias)->DOC+(cAlias)->E1_PARCELA+(cAlias)->E1_TIPO)) .AND. SE6->E6_FILORIG <> xFilial('SE6')
				(cAlias)->(DbSkip())
				Loop
			EndIF		

			//Verificar aqui se o título foi transferido. Se foi, teremos aqui no campo E5_MOTBX a informação 'TRF'. Neste caso não deverá ser considerado

			If (cAlias)->E5_MOTBX == 'TRF'	//verificar o quanto foi baixado na matriz	
				lTransfere	:= .T.		
			Endif
			// TRATAMENTO ABAIXO RETIRADO, POIS ABATIMENTOS NA BAIXA E NA EMISSÃO PODEM OCORRER SIMULTANEAMENTE, CONSIDETANDO QUE SÃO N TRIBUTOS.
			/*
			//Calcula valores de retencao. Verifica o parametro MV_BR10925.
			//Se feito na Emissao (MV_BR10925 = 2), verifico os titulos de abatimento e posteriormente calculo a proporcao da baixa
			//Se feito na Baixa (MV_BR10925 = 1), utilizo os campos da tabela SE5, pois ja estarao preenchidos com abatimento correto.
			If !lBxCanc .And. !lBxPerPos
				If cTpReten == "2"
					DbSelectArea("SE1")				
					nVlrReten	:=	SomaAbat((cAlias)->E5_PREFIXO,(cAlias)->E5_NUMERO,(cAlias)->E5_PARCELA,"R",Val((cAlias)->E5_MOEDA),(cAlias)->E5_DATA,(cAlias)->A1_COD,(cAlias)->A1_LOJA,,dDataAte,(cAlias)->E1_TIPO)
				Else			
					//Se calculo IR na baixa, pego seu valor da SE5, caso seja na emissão, tenha baixa parcial e seu saldo seja zeros 
					//devo obte-lo a partir da função SomaAbat.				
					If lA1IRBAX .And. (cAlias)->A1_IRBAX == "2"
						nVlrReten	:=	(cAlias)->E5_VRETPIS+(cAlias)->E5_VRETCOF+(cAlias)->E5_VRETCSL+(cAlias)->E5_VRETISS				
						lUltBx :=	IsLastBx((cAlias)->E1_PREFIXO,(cAlias)->DOC,(cAlias)->E1_PARCELA,(cAlias)->E1_TIPO,(cAlias)->E1_CLIENTE,(cAlias)->E1_LOJA,(cAlias)->E5_SEQ) 
						If lUltBx .And. (cAlias)->SALDO == 0
							DbSelectArea("SE1")
							nVlrReten	+= SomaAbat((cAlias)->E5_PREFIXO,(cAlias)->E5_NUMERO,(cAlias)->E5_PARCELA,"R",Val((cAlias)->E5_MOEDA),(cAlias)->E5_DATA,(cAlias)->A1_COD,(cAlias)->A1_LOJA,,dDataAte,(cAlias)->E1_TIPO)
						Endif
					Else
						nVlrReten	:=	(cAlias)->E5_VRETPIS+(cAlias)->E5_VRETCOF+(cAlias)->E5_VRETCSL+(cAlias)->E5_VRETISS+(cAlias)->E5_VRETIRF
					EndIF
				Endif
			Endif
			*/
		If !lBxCanc .And. !lBxPerPos
			// Valor Retido na emissão, posso sempre subtrair do valor principal do titulo para encontrar o percentual de BX
			nSomaAbat 	:= SomaAbat((cAlias)->E5_PREFIXO,(cAlias)->E5_NUMERO,(cAlias)->E5_PARCELA,"R",Val((cAlias)->E5_MOEDA),(cAlias)->E5_DATA,(cAlias)->A1_COD,(cAlias)->A1_LOJA,,dDataAte,(cAlias)->E1_TIPO)
			//Valor Retido na baixa, posso somar ao valor baixado para comparar com o valor principal esperado  (Não trata INSS nesse ponto pois INSS é sempre na emissão)
			nVlrReten	:=	(cAlias)->E5_VRETPIS+(cAlias)->E5_VRETCOF+(cAlias)->E5_VRETCSL+(cAlias)->E5_VRETISS+(cAlias)->E5_VRETIRF
		EndIf

	Endif

	//Calculo do valor Total Recebido no Periodo: (- Juros e Multa) + Desconto
	If !lBxCanc .And. !lBxPerPos .And. Iif(cOrigem=="SE1",(cAlias)->E5_DATA >= dDataDe .And. (cAlias)->E5_DATA <= dDataAte,.T.)
		If lTransfere//Transfereicna
			nTotRec := A054PTit(dDataDe,dDataAte,(cAlias)->E6_FILDEB,(cAlias)->E1_PREFIXO,(cAlias)->DOC,(cAlias)->E1_PARCELA,(cAlias)->E1_TIPO,(cAlias)->E1_CLIENTE,(cAlias)->E1_LOJA,lAuto,l12_1_2610,lClFinMove,oJSqlName)
		Else // Sem transferência
			nTotRec	:=	((cAlias)->VALORBX - (Iif(cOrigem=="SE1",(cAlias)->E5_VLJUROS - (cAlias)->E5_VLMULTA,0)) )
		EndIF
	Endif

	//obter valor da receita recebida (Valor da baixa + impostos na baixa proporcionais)
	nRRecebida	:=  nTotRec + nVlrReten

	//obter percentual do recebimento (Receita Recebida * 100 / (Total do Tìtulo - Impostos na emissão))
	nPercRec	:= ( nRRecebida * 100 / ( (cAlias)->VALOR - nSomaAbat ) ) / 100

	/*
		//Percentual do valor da baixa sobre o valor total do titulo
		//Esse trecho teve o conceito alterado em Fev/2018. Vide histórico
		nPercRec	:=	nTotRec / ( (cAlias)->VALOR - nSomaAbat - nVlrReten ) // Aqui estou retirando os abatimentos gerados na emissão do total esperado a receber
	*/
	If cOrigem == "SE1"
		//A funcao Fa620Stat() verifica transferencia de titulos. Se o retorno for 2, significa que o titulo eh originado de
		//outra filial, portanto devo procurar a nota na filial de origem, atraves da funcao CkTranTit()
		If (nTranStat := Fa620Stat((cAlias)->R_E_C_N_O_)) == 2
			// CkTranTit() --> Retorna .T. se processou diferimento, faco loop para nao processar novamente
			If CkTranTit(cPrefixE1,cCmpB1Dif,cCmpA1Dif,nTotRec,cAlias,cRegime,cPerApur,@aColsCFAP,@aColsCFAC,@aColsCFBP,@aColsCFBC,dDataDe,aXFilial,@aSldCrdDif,cIndNatPJ)
				(cAlias)->(DbSkip())
				Loop
			Endif
		Elseif nTranStat == 1
			(cAlias)->(DbSkip())
			Loop
		Endif

		If Alltrim((cAlias)->FT_TIPOMOV) == 'S' .And. !((cAlias)->FT_TIPO $ 'D|B')
			nValipi := (cAlias)->FT_VALIPI
		Else
			nValipi := 0
		EndIf
	Endif

	//Se o titulo possui vinculo com nota fiscal, devo calcular proporcionalmente o valor do item com o valor
	//total do titulo financeiro. Utilizo todos os dados da tabela SFT (Aliquota, CST, Valor)
	DbSelectArea("SFT")
	If cOrigem == "SE1" .And. !Empty((cAlias)->NFISCAL)

		//Somatorio das parcelas do titulo, para calcular percentual real do registro que esta sendo processado
		If !Empty((cAlias)->E1_PARCELA)
			nTotTit 	:=	SumParcE1( (cAlias)->E1_FILIAL, (cAlias)->E1_CLIENTE, (cAlias)->E1_LOJA, (cAlias)->E1_PREFIXO, (cAlias)->DOC, dDataAte ) // Utiliza o SomaAbat
		Else
			nTotTit		:=	(cAlias)->VALOR - nSomaAbat
		Endif

		//Mudei para o VAlBRUT, assim posso comparar com FT_VALCONT
		nTotNF		:= (cAlias)->F2_VALBRUT
		cNtFiscal	:= (cAlias)->NFISCAL
		cCSTPis		:= (cAlias)->FT_CSTPIS
		cCSTCof		:= (cAlias)->FT_CSTCOF

		If !cRegime $ "3/4"
			cTpReg		:=	cRegime
		Else
			If SPEDRegime(cRegime,cAlias,cAlias,cAlias) == "C"
				cTpReg		:=	"2"
			Else
				cTpReg		:=	"1"
			Endif
		Endif

		//Aliquotas - PIS e COFINS e CPRB
		nAlqPis		:=	(cAlias)->FT_ALIQPIS
		nAlqCof		:=	(cAlias)->FT_ALIQCOF

		If lCPRBNF
			nAlqCpb		:=	(cAlias)->FT_ALIQCPB
		EndIf

		// avalia se deduz o valor do ISS da base de calculo do PIS e COF para não considerar como diferença
		nValISS := 0
		If !lDedIssBs .AND. (cAlias)->FT_TIPO == "S"
			nValISS := (cAlias)->FT_VALICM
		EndIf

		// Preparando o valor que recebi, precisamos transformar no valor bruto
		nDiferenca	:= (nTotNF - nTotTit) - nValISS	// Diferença do valor da NF para o valor que posso receber
		nTotRec		+= (nDiferenca * nPercRec)
		nTotRec		+= nVlrReten // O valor das Retenções gravadas na SE5 já são proporcionais a baixa, por isso não preciso fazer a mesma regra acima.

		//Valor total da venda do item
		nTotVend	:=	(cAlias)->FT_VALCONT

		//Percentual do valor deste item em relacao ao valor total da NF
		nPercVlrNt	:=	((cAlias)->FT_VALCONT / nTotNF)
		nPercVlrNt	:= 	Iif(nPercVlrNt>1,1,nPercVlrNt)

		//Calculo do valor Total Recebido no Periodo com a proporcao sobre o item da nota fiscal
		nTotRec		:=	nTotRec * nPercVlrNt

		// Calculo do valor Total Diferido no Periodo
		nTotDifer	:=	nTotVend - nTotRec - nValipi //Necessario descontar o valor do IPI da base de calculo, pois este nao deve compor a base novamente

		// Ajustando o percentual recebido, considerando agora os abatimentos
		nPercRec 	:=  nTotRec / nTotVend

		// Caso não tenha sido realizado baixa e o valor Diferido cálculado seja maior da Base do PIS/COF, eu forço para pegar a base do PIS
		If nTotRec == 0 .And. nTotDifer > (cAlias)->FT_BASEPIS
			nTotDifer := (cAlias)->FT_BASEPIS
		EndIf

		// Realiza abatimento do valor do IPI proporcional ao valor da baixa para compor valor da contribuição diferida em período anterior
		if 	(cAlias)->EMISSAO < dDataDe
			nTotRec	 -= (nValIpi * nPercRec)
		endif

		cChvDoc		:=	(cAlias)->(NFISCAL+FT_SERIE+FT_CLIEFOR+FT_LOJA+FT_ITEM)

	Else

		cCSTPis		:=	(cAlias)->CSTPIS
		cCSTCof		:=	(cAlias)->CSTCOF

		If !cRegime $ "3/4"
			cTpReg		:=	cRegime
		Else
			If (cAlias)->TPREG == "1" // TPREG - 1=Cumulativo;2=Não Cumulativo
				cTpReg := "2" // Cumulativo
			Else
				cTpReg := "1" // Não Cumulativo
			Endif
		Endif

		//Aliquotas - PIS e COFINS
		nAlqPis		:=	(cAlias)->ALIQPIS
		nAlqCof		:=	(cAlias)->ALIQCOF

		If lCPRBNF
			nAlqCpb		:=	(cAlias)->FT_ALIQCPB
		EndIf

		// Preparando o valor que recebi, precisamos transformar no valor bruto
		nTotRec		+= (nSomaAbat * nPercRec) 	// Preciso proporcionalizar os abatimentos em relação ao valor da baixa
		nTotRec		+= nVlrReten				// O valor das retenções da SE5 já estão proporcionalizados pela baixa
		//Valor total do titulo
		nTotVend	:=	(cAlias)->VALOR

		//Calculo do valor Total Diferido no Periodo
		nTotDifer	:=	((cAlias)->VALOR - nTotRec) - nValipi //Necessario descontar o valor do IPI da base de calculo, pois este nao deve compor a base novamente
		// Ajustando o percentual recebido, considerando agora os abatimentos
		nPercRec 	:=  nTotRec / (cAlias)->VALOR

		cChvDoc		:=	Iif(cOrigem == "CF8",(cAlias)->DOC,(cAlias)->(DOC+E1_PREFIXO+E1_CLIENTE+E1_LOJA))

	Endif

	//Calcula valores da Contribuicao Diferida/Paga no periodo
	nPisDifer	:=	(nTotDifer * nAlqPis) / 100
	nCofDifer	:=	(nTotDifer * nAlqCof) / 100
	nPisPago	:=	(nTotRec * nAlqPis) / 100
	nCofPago	:=	(nTotRec * nAlqCof) / 100

	//Calcula valores da Contribuicao Diferida/Paga no periodo de CPRB
	nCpbDifer	:=	(nTotDifer * nAlqCpb) / 100
	nCpbPago	:=	(nTotRec * nAlqCpb) / 100

	If lCPRBNF
		cCodAtvCPB	:= 	(cAlias)->FT_ATIVCPB
	EndIf

	//Titulos emitidos no mesmo periodo do Processamento.
	//Serao gerados para a tabela CFA - Informacoes Adicionais de Diferimento (Registros M230 e M630)
	If cPerEmis == cPerApur

		//aDocs -> utilizado para aglutinar os documentos, para que as tabelas do diferimento nao tenham valores duplicados
		//lNewDoc -> Indica se o documento esta sendo gravado pela primeira vez. Tratamento para nao duplicar valores
		If (nPos := aScan(aDocs,{|x| x[1]==cChvDoc})) == 0
			aAdd(aDocs,{})
			nPos := Len(aDocs)
			aAdd(aDocs[nPos],cChvDoc)					//CHAVE DO DOCUMENTO      1
			aAdd(aDocs[nPos],nTotVend)					//TOTAL VENDIDO           2
			aAdd(aDocs[nPos],nTotVend - nTotRec)		//TOTAL NAO RECEBIDO      3
			aAdd(aDocs[nPos],nTotDifer)					//TOTAL DIFERIDO          4
			aAdd(aDocs[nPos],nPisDifer)					//PIS DIFERIDO            5
			aAdd(aDocs[nPos],nCofDifer)					//COFINS DIFERIDO         6
			aAdd(aDocs[nPos],.T.)						//NOVO DOCUMENTO	      7
			aAdd(aDocs[nPos],cCodBCPIS)					//CÓDIGO CRÉDITO PIS      8
			aAdd(aDocs[nPos],nCredPisDf)				//CRÉDITO PIS DIFERIDO    9
			aAdd(aDocs[nPos],cCodBCCOF)					//CÓDIGO CRÉDITO COFINS   10
			aAdd(aDocs[nPos],nCredCOFDf)				//CRÉDITO COFINS DIFERIDO 11

			//CPRB
			aAdd(aDocs[nPos],nCpbDifer)					//CPRB DIFERIDO		      12
			aAdd(aDocs[nPos],cCodBCCPB)					//CÓDIGO CRÉDITO CPRB     13
			aAdd(aDocs[nPos],nCredCpbDf)				//CRÉDITO CPRB DIFERIDO   14
			aAdd(aDocs[nPos],cCodAtvCPB)				//CODIGO ATIVIDADE CPRB   15
		Else
			aDocs[nPos][3] -= nTotRec					//TOTAL NAO RECEBIDO
			aDocs[nPos][4] -= nTotRec					//TOTAL DIFERIDO
			aDocs[nPos][5] -= nPisPago					//PIS DIFERIDO
			aDocs[nPos][6] -= nCofPago					//COFINS DIFERIDO
			aDocs[nPos][7] := .F.						//NOVO DOCUMENTO

			//CPRB
			aDocs[nPos][12] -= nCpbPago					//CPRB DIFERIDO

		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³aValores[1] -> Total Diferido	³
		//³aValores[2] -> Total Vendido     ³
		//³aValores[3] -> Total Recebido	³
		//³aValores[4] -> Aliquota PIS		³
		//³aValores[5] -> Aliquota COFINS	³
		//³aValores[6] -> PIS Diferido		³
		//³aValores[7] -> COFINS Diferido	³
		//³aValores[8] -> PIS Recolhido		³
		//³aValores[9] -> COFINS Recolhido	³
		//³aValores[10] -> Total N Recebido	³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aValores	:=	{	aDocs[nPos][4],aDocs[nPos][2],nTotRec,nAlqPis,nAlqCof,;//5
		aDocs[nPos][5],aDocs[nPos][6],nPisPago,nCofPago,aDocs[nPos][3],;//10
		aDocs[nPos][9],aDocs[nPos][11],aDocs[nPos][8],aDocs[nPos][10],;//14
		nAlqCpb, aDocs[nPos][12], nCpbPago, aDocs[nPos][14], aDocs[nPos][13], aDocs[nPos][15]}

		lNewDoc	:=	aDocs[nPos][7]

		GrvInfDif(1,cAlias,cNtFiscal,cCSTPis,cCSTCof,aValores,cTpReg,cRegime,cPerApur,@aColsCFAP,@aColsCFAC,lNewDoc,cIndNatPJ,aXFilial,,lF0T,cOrigem,ObjF0T,, .T.)

		IF lF0T
			//Trecho abaixo irá agrupar as informações do mesmo título, para que nas situações onde existam diversas baixas o título não seja repetido
			nF0T			:= 0
			cF0T			:= dtos( dDataDe ) + cFilAnt

			IF cOrigem == "SE1"
				cF0T	+= ( cAlias )->NFISCAL + (cAlias)->NFISCAL +  DTOS(Iif( empty((cAlias)->FT_ENTRADA),(cAlias)->EMISSAO,(cAlias)->FT_ENTRADA )) + (cAlias)->FT_ITEM + (cAlias)->DOC + (cAlias)->E1_PREFIXO + (cAlias)->E1_PARCELA
			ElseIF cOrigem == "CF8"
				cF0T	+= DTos( (cAlias)->EMISSAO ) + (cAlias)->DOC
			EndIF

			If Len(aF0T) > 0
				nF0T :=	aScan(aF0T	,{|aX| aX[1]==cF0T})
			EndIf

			If nF0T == 0
				IF cOrigem == "SE1"
					aAdd(aF0T,{})
					nF0T := Len(aF0T)

					aAdd(aF0T[nF0T], cF0T )											//1-CHAVE DO DOCUMENTO
					aAdd(aF0T[nF0T],dDataDe )										//2-EMISSAO
					aAdd(aF0T[nF0T],cFilAnt )										//3-FILIAL
					aAdd(aF0T[nF0T],(cAlias)->NFISCAL)								//4-NUMERO DOCUMENTO
					aAdd(aF0T[nF0T],(cAlias)->FT_SERIE)								//5-SERIE
					aAdd(aF0T[nF0T],Iif(empty((cAlias)->FT_ENTRADA),(cAlias)->EMISSAO,(cAlias)->FT_ENTRADA) )//6-COFINS DIFERIDO
					aAdd(aF0T[nF0T],(cAlias)->FT_ITEM)								//7-ITEM NF
					aAdd(aF0T[nF0T],(cAlias)->DOC)									//8-NUMERO DO TÍTULO
					aAdd(aF0T[nF0T],(cAlias)->E1_PREFIXO)							//9-PREFIXO TÍTULO
					aAdd(aF0T[nF0T],(cAlias)->E1_PARCELA)							//10-PARCELA TÍTULO
					aAdd(aF0T[nF0T],aValores[2])									//11-Valor da  Operação
					aAdd(aF0T[nF0T],aValores[3])									//12-Valor recebido
					aAdd(aF0T[nF0T],aValores[1])									//13-Receita Diferida
					aAdd(aF0T[nF0T],aValores[6])									//14-PIS DIferido
					aAdd(aF0T[nF0T],aValores[7])									//15-Cofins Diferida
					aAdd(aF0T[nF0T],CTOD("  /  /    "))								//16-Emissão CF8
					aAdd(aF0T[nF0T],"")											    //17-ID CF8
					aAdd(aF0T[nF0T],(cAlias)->CNPJCLI)								//18-CNPJ Órgão Público
					//CPRB
					aAdd(aF0T[nF0T],aValores[16])									//19-CPRB DIferido

				ElseIf cOrigem == "CF8"
					aAdd(aF0T,{})
					nF0T := Len(aF0T)

					aAdd(aF0T[nF0T], cF0T )											//1-CHAVE DO DOCUMENTO
					aAdd(aF0T[nF0T],dDataDe )										//2-EMISSAO
					aAdd(aF0T[nF0T],cFilAnt )										//3-FILIAL
					aAdd(aF0T[nF0T], "" )											//4-NUMERO DOCUMENTO
					aAdd(aF0T[nF0T], "" )											//5-SERIE
					aAdd(aF0T[nF0T],CTOD( "  /  /    " ) )							//6-COFINS DIFERIDO
					aAdd(aF0T[nF0T], "" )											//7-ITEM NF
					aAdd(aF0T[nF0T], "" )											//8-NUMERO DO TÍTULO
					aAdd(aF0T[nF0T], "" )											//9-PREFIXO TÍTULO
					aAdd(aF0T[nF0T], "" )											//10-PARCELA TÍTULO
					aAdd(aF0T[nF0T],aValores[2])									//11-Valor da  Operação
					aAdd(aF0T[nF0T],aValores[3])									//12-Valor recebido
					aAdd(aF0T[nF0T],aValores[1])									//13-Receita Diferida
					aAdd(aF0T[nF0T],aValores[6])									//14-PIS DIferido
					aAdd(aF0T[nF0T],aValores[7])									//15-Cofins Diferida
					aAdd(aF0T[nF0T],(cAlias)->EMISSAO)								//16-Emissão CF8
					aAdd(aF0T[nF0T],(cAlias)->DOC)									//17-ID CF8
					aAdd(aF0T[nF0T],(cAlias)->CNPJCLI)								//18-CNPJ Órgão Público
					//CPRB
					aAdd(aF0T[nF0T],aValores[16])									//19-CPRB DIferido

				EndIF
			Else
				//O valor recebido irei acumular
				aF0T[nF0T][12] += aValores[3]

				//Os valores abaixo preciso sempre refazer, pois deverá exibir o status atual do título.
				aF0T[nF0T][11] := aValores[2]
				aF0T[nF0T][13] := aValores[1]
				aF0T[nF0T][14] := aValores[6]
				aF0T[nF0T][15] := aValores[7]
			EndIF

		EndIF

		//Titulos emitidos em periodo anterior ao Processamento.
		//Serao gerados para a tabela CFB - Contribuicao Diferida em Periodos Anteriores (Registros M300 e M700)
	ElseIf  (cAlias)->EMISSAO < dDataDe

		//Buscar informações na CFA considerando CNPJ, CODCON, TRIB e período de emissão.

		aValores	:=	{nTotDifer,nTotVend,nTotRec,nAlqPis,nAlqCof,nPisDifer,nCofDifer,nPisPago,nCofPago,nCredPisDf,nCredCOFDf,cNatCre,;//12
		"", "", nAlqCpb, nCpbDifer, nCpbPago, nCredCpbDf, "", cCodAtvCPB}

		GrvInfDif(2,cAlias,cNtFiscal,cCSTPis,cCSTCof,aValores,cTpReg,cRegime,cPerApur,@aColsCFBP,@aColsCFBC,,cIndNatPJ,aXFilial,nPercRec,lF0T,cOrigem,ObjF0T,@aSldCrdDif, .T.)

		IF lF0T
			ObjF0T:Clear()
			ObjF0T:SetValue("F0T_PER"		,dDataDe)
			ObjF0T:SetValue("F0T_FILAPU"	,cFilAnt)
			ObjF0T:SetValue("F0T_TIPO"		,'5') //Diferimento período anterior
			IF cOrigem == "SE1"
				//Possui somente título ou  título + nota fiscal
				ObjF0T:SetValue("F0T_NUMNF"		,(cAlias)->NFISCAL)
				ObjF0T:SetValue("F0T_SER"		,(cAlias)->FT_SERIE)
				ObjF0T:SetValue("F0T_DTEMI"		,Iif(empty((cAlias)->FT_ENTRADA),(cAlias)->EMISSAO,(cAlias)->FT_ENTRADA)  )
				ObjF0T:SetValue("F0T_ITEM"		,(cAlias)->FT_ITEM)
				ObjF0T:SetValue("F0T_NUMTIT"	,(cAlias)->DOC)
				ObjF0T:SetValue("F0T_PREFIX"	,(cAlias)->E1_PREFIXO)
				ObjF0T:SetValue("F0T_PARC"		,(cAlias)->E1_PARCELA)

			ElseIF cOrigem == "CF8"
				//Operações em Demais Documentos
				ObjF0T:SetValue("F0T_DTEMI"		,(cAlias)->EMISSAO)
				ObjF0T:SetValue("F0T_IDCF8"		,(cAlias)->DOC)

			EndIF
			ObjF0T:SetValue("F0T_CNPJ"	    ,(cAlias)->CNPJCLI)
			ObjF0T:SetValue("F0T_DTRECB"	,(cAlias)->DATABX)
			ObjF0T:SetValue("F0T_VALREC"	,nTotRec)
			ObjF0T:SetValue("F0T_VALPIS"	,nPisPago)
			ObjF0T:SetValue("F0T_VALCOF"	,nCofPago)

			//CPRB
			ObjF0T:SetValue("F0T_VLCPRB"	,nCpbPago)

			ObjF0T:Grava()
		EndIF

	Endif

	nRegsProc	+=	1
	(cAlias)->(DbSkip())
Enddo

(DbCloseArea())


//Laço para gravar informações na F0T referente os títulos com diferimento no período.
For nF0T:= 1 to Len(aF0T)

	ObjF0T:Clear()
	ObjF0T:SetValue("F0T_PER"		,aF0T[nF0T][2])
	ObjF0T:SetValue("F0T_FILAPU"	,aF0T[nF0T][3])
	ObjF0T:SetValue("F0T_TIPO"		,'4') //Diferimento período atual
	//Possui somente título ou  título + nota fiscal
	ObjF0T:SetValue("F0T_NUMNF"		,aF0T[nF0T][4])
	ObjF0T:SetValue("F0T_SER"		,aF0T[nF0T][5])
	ObjF0T:SetValue("F0T_DTEMI"		,aF0T[nF0T][6])
	ObjF0T:SetValue("F0T_ITEM"		,aF0T[nF0T][7])
	ObjF0T:SetValue("F0T_NUMTIT"	,aF0T[nF0T][8])
	ObjF0T:SetValue("F0T_PREFIX"	,aF0T[nF0T][9])
	ObjF0T:SetValue("F0T_PARC"		,aF0T[nF0T][10])
	ObjF0T:SetValue("F0T_VLCONT"	,aF0T[nF0T][11])
	ObjF0T:SetValue("F0T_VALREC"	,aF0T[nF0T][12])
	ObjF0T:SetValue("F0T_RECDIF"	,aF0T[nF0T][13])
	ObjF0T:SetValue("F0T_VALPIS"	,aF0T[nF0T][14])
	ObjF0T:SetValue("F0T_VALCOF"	,aF0T[nF0T][15])
	//Operações em Demais Documentos
	ObjF0T:SetValue("F0T_DTEMI"		,aF0T[nF0T][16])
	ObjF0T:SetValue("F0T_IDCF8"		,aF0T[nF0T][17])
	ObjF0T:SetValue("F0T_CNPJ"		,aF0T[nF0T][18])

	//CPRB
	ObjF0T:SetValue("F0T_VLCPRB"	,aF0T[nF0T][19])

	ObjF0T:Grava()

Next nF0T

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} CkTranTit
Funcao que processa os titulos que foram transferidos entre filiais e verifica 
se existe nota fiscal relacionada ao titulo na filial de origem.

	
@param	cPrefixE1 -> Conteudo do parametro MV_1DUPREF
		cCmpB1Dif -> Campo da tabela SB1 que indica Diferimento de Org. Publico
		cCmpA1Dif -> Campo da tabela SA1 que indica Diferimento de Org. Publico
		nTotRecE5 -> Total Recebido no registro de baixa
		cAliasOri -> Alias da query de origem
		cRegime -> Regime selecionado nas perguntas da rotina (1,2,3)
		cPerApur -> Periodo do processamento
		aColsCFAP -> Informacoes que serao mostradas na Dialog
		aColsCFAC -> Informacoes que serao mostradas na Dialog
		aColsCFBP -> Informacoes que serao mostradas na Dialog
		aColsCFBC -> Informacoes que serao mostradas na Dialog
		dDataDe -> Data Inicial de Processamento
					
@return	lAchouNota -> 	Indica que foi encontrada nota na filial de origem, portanto
						aborta processamento do registro no retorno desta funcao (loop)		
		
@author Luccas Curcio
@since 10/09/2012
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function CkTranTit(cPrefixE1,cCmpB1Dif,cCmpA1Dif,nTotRecE5,cAliasOri,cRegime,cPerApur,aColsCFAP,aColsCFAC,aColsCFBP,aColsCFBC,dDataDe,aXFilial,aSldCrdDif,cIndNatPJ)
	Local	lNewDoc	:=	.F.
	Local	lAchouNota	:=	.F.
	Local  lB1TPREG	:= SB1->(FieldPos("B1_TPREG")) > 0
	Local	cSelect	:=	""
	Local	cFrom		:=	""
	Local	cWhere		:=	""
	Local	cAliasSFT	:=	"SFT"
	Local	cAliasSB1	:=	"SB1"
	Local	cAliasSA1	:=	"SA1"
	Local	cAliasSF4	:=	"SF4"
	Local	cAliasSF2	:=	"SF2"
	Local	cTpReg		:=	""
	Local	cFilOrig	:=	SE6->E6_FILORIG
	Local	cChvSF		:=	""
	Local	nPercVlrNt	:=	0
	Local	nTotDifer	:=	0
	Local	nPisDifer	:=	0
	Local	nCofDifer	:=	0
	Local	nPisPago	:=	0
	Local	nCofPago	:=	0
	Local	nTotRec		:=	0
	Local	nPos		:=	0
	Local	nMVM996TPR	:=	GetNewPar("MV_M996TPR",1)
	Local	aValores	:=	{}
	Local	aDocs		:=	{}
	Default aXFilial	:= {}
	Default aSldCrdDif	:= {}

	//Verifica conteudo do paramentro na filial de origem
	cPrefixE1 := ChkX6Orig(cFilOrig,"MV_1DUPREF",cPrefixE1)

	//Se o conteudo do parametro MV_1DUPREF for diferente do default(SF2->F2_SERIE), preciso fazer uma query a partir da
	//tabela SF2, utilizando o campo F2_PREFIXO como relacao do titulo e nota fiscal, pois o conteudo dos campo E1_PREFIXO,
	//E6_PREFIXO e F2_SERIE estara diferente.
	If cPrefixE1<>"SF2->F2_SERIE"

		//Select na nota fiscal pela filial de origem
		cSelect	+=	"%SFT.FT_FILIAL,	SFT.FT_TIPOMOV,	SFT.FT_NFISCAL,	SFT.FT_VALCONT,	SFT.FT_ALIQPIS,	SFT.FT_ALIQCOF,	SFT.FT_CSTPIS, "
		cSelect	+=	"SFT.FT_CSTCOF,		SFT.FT_VALPIS,	SFT.FT_VALCOF, 	SFT.FT_BASEPIS,	SFT.FT_BASECOF,	SFT.FT_SERIE,	SFT.FT_CLIEFOR, "
		cSelect	+=	"SFT.FT_LOJA,		SFT.FT_ITEM, "

		cSelect	+=	"SF2.F2_PREFIXO,"

		cSelect	+=	"SF4.F4_TPREG, "

		cSelect	+=	"SD2.D2_PROJPMS, "

		cSelect	+=	"SB1.B1_COD,		SB1.B1_PPIS,	SB1.B1_PCOFINS,	SB1.B1_PCSLL,	SA1.A1_COD,	SA1.A1_LOJA"

		IF lB1TPREG
			cSelect	+=	", SB1.B1_TPREG"
		EndIF

		If SB1->(FieldPos(cCmpB1Dif)) > 0
			cSelect	+=	", SB1."+cCmpB1Dif+""
		Endif

		If SA1->(FieldPos("A1_TPREG"))>0
			cSelect	+=	", SA1.A1_TPREG"
		Endif

		If SA1->(FieldPos(cCmpA1Dif)) > 0
			cSelect	+=	", SA1."+cCmpA1Dif+""
		Endif

		cSelect	+=	"%"

		//From tabela SF2
		cFrom	:=	"%"+RetSqlName("SF2")+" SF2 "
		// JOIN SFT
		cFrom	+=	"LEFT JOIN "+RetSqlName("SFT")+" SFT ON SFT.FT_FILIAL='"+Iif(!Empty(xFilial("SFT")),cFilOrig,xFilial("SFT"))+"' AND SFT.FT_NFISCAL=SF2.F2_DOC AND SFT.FT_SERIE=SF2.F2_SERIE AND SFT.FT_CLIEFOR=SF2.F2_CLIENT AND SFT.FT_LOJA=SF2.F2_LOJA AND SFT.D_E_L_E_T_ = '' "
		//JOIN SD2
		cFrom	+=	"LEFT JOIN "+RetSqlName("SD2")+" SD2 ON SD2.D2_FILIAL='"+Iif(!Empty(xFilial("SD2")),cFilOrig,xFilial("SD2"))+"' AND SD2.D2_DOC=SFT.FT_NFISCAL AND SD2.D2_SERIE=SFT.FT_SERIE AND SD2.D2_CLIENTE=SFT.FT_CLIEFOR AND SD2.D2_LOJA=SFT.FT_LOJA AND SD2.D2_ITEM=SFT.FT_ITEM  AND SD2.D_E_L_E_T_='' "
		//JOIN SF4
		cFrom	+=	"LEFT JOIN "+RetSqlName("SF4")+" SF4 ON SF4.F4_FILIAL='"+Iif(!Empty(xFilial("SF4")),cFilOrig,xFilial("SF4"))+"' AND SF4.F4_CODIGO=SD2.D2_TES AND SF4.D_E_L_E_T_='' "

		//JOIN SB1
		cFrom	+=	"LEFT JOIN "+RetSqlName("SB1")+" SB1 ON SB1.B1_FILIAL='"+Iif(!Empty(xFilial("SB1")),cFilOrig,xFilial("SB1"))+"' AND SB1.B1_COD=SFT.FT_PRODUTO AND "
		cFrom	+=	"SB1.D_E_L_E_T_ = '' "

		//JOIN SA1
		cFrom	+=	"LEFT JOIN "+RetSqlName("SA1")+" SA1 ON SA1.A1_FILIAL='"+Iif(!Empty(xFilial("SA1")),cFilOrig,xFilial("SA1"))+"' AND SA1.A1_COD=SFT.FT_CLIEFOR AND SA1.A1_LOJA=SFT.FT_LOJA AND "

		cFrom	+=	"SA1.D_E_L_E_T_ = ''%"
		cWhere	:=	"%SF2.F2_FILIAL	=	'"+SE6->E6_FILORIG+"'		AND "
		cWhere	+=	"SF2.F2_DOC		=	'"+SE6->E6_NUM+"' 			AND "
		cWhere	+=	"SF2.F2_PREFIXO	=	'"+SE6->E6_PREFIXO+"'		AND "
		//cWhere	+=	"SF2.F2_CLIENTE	=	'"+SE6->E6_CLIENTE+"'		AND "
		cWhere	+=	"SF2.F2_LOJA	=	'"+SE6->E6_LOJA+"'"

		If SB1->(FieldPos(cCmpB1Dif)) > 0
			cWhere	+=	" AND SB1."+cCmpB1Dif+"='1' "
		Endif

		If SA1->(FieldPos(cCmpA1Dif)) > 0
			cWhere	+=	" AND SA1."+cCmpA1Dif+"='1' "
		Endif
		cWhere	+= "%"

		cAlias := SPEDGetAlias("SF2")
		BeginSql Alias cAlias
				
		SELECT 
			%Exp:cSelect%
	
		FROM 
			%Exp:cFrom%
	
		WHERE 
			%Exp:cWhere%
		EndSql

		If !(cAlias)->(Eof())
			lAchouNota	:=	.T.
			cAliasSFT	:=	cAlias

			cAliasSB1	:=	cAlias
			cAliasSA1	:=	cAlias
			cAliasSF4	:=	cAlias
			cAliasSF2	:=	cAlias
		Endif
		cChvSF	:=cFilOrig+"S"+SE6->E6_PREFIXO+SE6->E6_NUM //+SE6->E6_CLIENTE+SE6->E6_LOJA

		//Se utilizar o default para o parametro MV_1DUPREF, utilizo Seek para acelerar o processamento
	Else
		DbSelectArea("SFT")
		SFT->(DbSetOrder(1))

		cChvSF	:=cFilOrig+"S"+SE6->E6_PREFIXO+SE6->E6_NUM

		If SFT->(MsSeek(cChvSF))

			SPEDSeek("SF2",2,Iif(!Empty(xFilial("SF2")),cFilOrig,xFilial("SF2"))+SFT->(FT_CLIEFOR+FT_LOJA+FT_NFISCAL+FT_SERIE))
			SPEDSeek("SB1",1,Iif(!Empty(xFilial("SB1")),cFilOrig,xFilial("SB1"))+SFT->FT_PRODUTO)

			//Verifica conteudo do parametro MV_M996TPR para que posicione as tabelas abaixo apenas se necessario
			If nMVM996TPR == 1
				SPEDSeek("SD2",1,Iif(!Empty(xFilial("SD2")),cFilOrig,xFilial("SD2"))+SFT->(FT_NFISCAL+FT_SERIE+FT_CLIEFOR+FT_LOJA+FT_PRODUTO+FT_ITEM))
				SPEDSeek("SF4",1,Iif(!Empty(xFilial("SF4")),cFilOrig,xFilial("SF4"))+SD2->D2_TES)

			Elseif nMVM996TPR == 3
				SPEDSeek("SA1",1,Iif(!Empty(xFilial("SA1")),cFilOrig,xFilial("SA1"))+SFT->(FT_CLIEFOR+FT_LOJA))
			Endif

			lAchouNota	:=	.T.
		Endif
	Endif

	If lAchouNota

		//Se encontrou nota fiscal, usa os valores da SFT e o retorno da funcao eh TRUE, para que nao continue o processamento
		//Se nao encontrar nota fiscal, o retorno da funcao eh FALSE e mantem o processamento atraves do titulo financeiro
		//Do While !(cAliasSFT)->(Eof()) .And. (cAliasSFT)->(FT_FILIAL+FT_TIPOMOV)+(cAliasSF2)->F2_PREFIXO+(cAliasSFT)->(FT_NFISCAL+FT_CLIEFOR+FT_LOJA) == cChvSF
		Do While !(cAliasSFT)->(Eof()) .And. (cAliasSFT)->(FT_FILIAL+FT_TIPOMOV)+(cAliasSF2)->F2_PREFIXO+(cAliasSFT)->FT_NFISCAL == cChvSF

			If !Empty((cAliasSFT)->FT_NFISCAL) .And. Empty((cAliasSB1)->B1_COD)
				(cAliasSFT)->(DbSkip())
				Loop
			Endif

			If !cRegime $ "3/4"
				cTpReg		:=	cRegime
			Else
				//TODO analisar como substituir a função SPEDREGIME
				If SPEDRegime(cRegime,cAliasSF4,cAliasSB1,cAliasSA1,nMVM996TPR) == "C"
					cTpReg		:=	"2"
				Else
					cTpReg		:=	"1"
				Endif
			Endif

			//Valor total da venda do item
			nTotVend	:=	(cAliasSFT)->FT_VALCONT

			//Percentual do valor deste item em relacao ao valor total do titulo
			nPercVlrNt	:=	(cAliasSFT)->FT_VALCONT / (cAliasOri)->VALOR

			//Calculo do valor Total Recebido no Periodo com a proporcao sobre a nota fiscal
			nTotRec		:=	nTotRecE5 * nPercVlrNt

			//Calculo do valor Total Diferido no Periodo
			nTotDifer	:=	((cAliasOri)->VALOR - nTotRec)

			nPisDifer	:=	(nTotDifer * (cAliasSFT)->FT_ALIQPIS) / 100
			nCofDifer	:=	(nTotDifer * (cAliasSFT)->FT_ALIQCOF) / 100
			nPisPago	:=	(nTotRec * (cAliasSFT)->FT_ALIQPIS) / 100
			nCofPago	:=	(nTotRec * (cAliasSFT)->FT_ALIQCOF) / 100

			//Buscar aqui os valores de crpedito de PIS e COFINS que fora diferidos e adicionar do aDocs
			// depois adicionar no avalores


			//Titulos emitidos no mesmo periodo do Processamento.
			//Serao gerados para a tabela CFA - Informacoes Adicionais de Diferimento (Registros M230 e M630)
			If Substr(DTOS((cAliasOri)->EMISSAO),5,2)+Substr(DTOS((cAliasOri)->EMISSAO),1,4) == cPerApur

				//aDocs -> utilizado para aglutinar os documentos, para que as tabelas do diferimento nao tenham valores duplicados
				//lNewDoc -> Indica se o documento esta sendo gravado pela primeira vez. Tratamento para nao duplicar valores
				If (nPos := aScan(aDocs,{|x| x[1]==(cAliasSFT)->(FT_NFISCAL+FT_SERIE+FT_CLIEFOR+FT_LOJA+FT_ITEM)})) == 0
					aAdd(aDocs,{})
					nPos := Len(aDocs)
					aAdd(aDocs[nPos],(cAliasSFT)->(FT_NFISCAL+FT_SERIE+FT_CLIEFOR+FT_LOJA+FT_ITEM))	//CHAVE DO DOCUMENTO
					aAdd(aDocs[nPos],nTotVend)													//TOTAL VENDIDO
					aAdd(aDocs[nPos],nTotVend - nTotRec)										//TOTAL NAO RECEBIDO
					aAdd(aDocs[nPos],nTotDifer)													//TOTAL DIFERIDO
					aAdd(aDocs[nPos],nPisDifer)													//PIS DIFERIDO
					aAdd(aDocs[nPos],nCofDifer)													//COFINS DIFERIDO
					aAdd(aDocs[nPos],.T.)														//NOVO DOCUMENTO
				Else
					aDocs[nPos][3] -= nTotRec													//TOTAL NAO RECEBIDO
					aDocs[nPos][4] -= nTotRec													//TOTAL DIFERIDO
					aDocs[nPos][5] -= nPisPago													//PIS DIFERIDO
					aDocs[nPos][6] -= nCofPago													//COFINS DIFERIDO
					aDocs[nPos][7] := .F.														//NOVO DOCUMENTO
				Endif

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³aValores[1] -> Total Diferido	³
				//³aValores[2] -> Total Vendido     ³
				//³aValores[3] -> Total Recebido	³
				//³aValores[4] -> Aliquota PIS		³
				//³aValores[5] -> Aliquota COFINS	³
				//³aValores[6] -> PIS Diferido		³
				//³aValores[7] -> COFINS Diferido	³
				//³aValores[8] -> PIS Recolhido		³
				//³aValores[9] -> COFINS Recolhido	³
				//³aValores[10] -> Total N Recebido	³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

				aValores	:=	{	aDocs[nPos][4],aDocs[nPos][2],nTotRec,(cAliasSFT)->FT_ALIQPIS,(cAliasSFT)->FT_ALIQCOF,;
					aDocs[nPos][5],aDocs[nPos][6],nPisPago,nCofPago,aDocs[nPos][3],;
					0,"","","",;
					0, 0, 0, 0, "", ""}


				lNewDoc	:=	aDocs[nPos][7]


				GrvInfDif(1,cAliasOri,(cAliasSFT)->FT_NFISCAL,(cAliasSFT)->FT_CSTPIS,(cAliasSFT)->FT_CSTCOF,aValores,cTpReg,cRegime,cPerApur,@aColsCFAP,@aColsCFAC,lNewDoc,cIndNatPJ,aXFilial)

				//Titulos emitidos em periodo anterior ao Processamento.
				//Serao gerados para a tabela CFB - Contribuicao Diferida em Periodos Anteriores (Registros M300 e M700)
			Elseif (cAliasOri)->EMISSAO < dDataDe

				aValores	:=	{nTotDifer,nTotVend,nTotRec,(cAliasSFT)->FT_ALIQPIS,(cAliasSFT)->FT_ALIQCOF,nPisDifer,nCofDifer,nPisPago,nCofPago,0,0,"","","",;
					0, 0, 0, 0, "", ""}

				GrvInfDif(2,cAliasOri,(cAliasSFT)->FT_NFISCAL,(cAliasSFT)->FT_CSTPIS,(cAliasSFT)->FT_CSTCOF,aValores,cTpReg,cRegime,cPerApur,@aColsCFBP,@aColsCFBC,,cIndNatPJ,aXFilial,,,,,@aSldCrdDif)
			Endif

			(cAliasSFT)->(DbSkip())
		Enddo
	Endif

	//So fecha a tabela se for processamento da query
	If cPrefixE1<>"SF2->F2_SERIE"
		(cAliasSFT)->(DbCloseArea())
	Endif

Return lAchouNota

//-------------------------------------------------------------------
/*/{Protheus.doc} ChkX6Orig
Funcao que busca conteudo de determinado paramentro na filial de origem

	
@param	cFilOrig -> Filial de Origem
		cParam -> Parametro a ser verificado
		cContAtu -> Conteudo utilizado na filial corrente (default)
					
@return	cConteud -> Conteudo do parametro na filial de origem, se existir
					ou o conteudo default, passado como parametro na funcao.
		
@author Luccas Curcio
@since 10/09/2012
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function ChkX6Orig(cFilOrig,cParam,cContAtu)
	Local	cConteud	:=	cContAtu

	If SX6->(MsSeek(cFilOrig+cParam))
		cConteud	:=	Alltrim(SX6->X6_CONTEUD)
	Endif

Return cConteud


//-------------------------------------------------------------------
/*/{Protheus.doc} GrvInfDif
Funcao que grava as tabelas relacionadas ao Diferimento. Passar o primeiro parametro, 
indicando qual o tipo de registro: 1 - Diferimento de emissao no proprio Periodo. 2 - Diferimento de Periodos anteriores
	
@param	nOpc -> Opcao de processamento (1 - Diferimento de emissao no proprio 
				Periodo. 2 - Diferimento de Periodos anteriores)
		cAlias -> Alias da query que esta sendo processada
		cNtFiscal -> Numero da nota fiscal, se existir
		cCSTPis -> CST de Pis
		cCSTCof -> CST de Cofins
		aValores -> Valores que serao gravados
		cTpReg -> Tipo do regime do documento
		cRegime -> Regime selecionado nas perguntas da rotina
		cPerApur -> Periodo do processamento
		aColsPis -> Valores de PIS que serao apresentados na tela
		aColsCof -> Valores de Cofins que serao apresentados na tela
		lNewDoc -> 	Indica se eh um novo documento, ou documento ja foi processado 1 vez
					afim de evitar duplicidade de valores
		cIndNatPJ-> Indicador da Natureza da Pessoa Juridica
					
@return	Nil
		
@author Luccas Curcio
@since 10/09/2012
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function GrvInfDif(nOpc,cAlias,cNtFiscal,cCSTPis,cCSTCof,aValores,cTpReg,cRegime,cPerApur,aColsPis,aColsCof,lNewDoc,cIndNatPJ,aXFilial,nPercRec,lF0T,cOrigem,ObjF0T,aSldCrdDif, lAjuCPRB)
	Local	cCNPJ		:=	""
	Local	cCodCont	:=	""
	Local	cChvCFA		:=	""
	Local	cDtPgto		:=	""
	Local	cChvCFB		:=	""
	Local	cPerDif		:=	""
	Local	nPos		:=	0
	Local   lScp		:= GetNewPar("MV_FILSCP",.F.)
	Local   cFilCFA		:= BuscaFil(aXFilial,'CFA')
	Local   cFilCFB		:= BuscaFil(aXFilial,'CFB')
	Local 	aRetCrdDif	:= {}
	Local 	nPosCrd		:= 0
	Local   lNewProc	:= ISA001NDIF()
	Default	lNewDoc		:=	.F.
	DEFAULT nPercRec	:= 0
	DEFAULT lF0T		:= .F.
	DEFAULT cOrigem		:= ''
	DEFAULT ObjF0T		:= NIL
	Default aSldCrdDif	:= {}
	DEFAULT lAjuCPRB	:= .F.
	If cIndNatPJ$"03#04#05"
		lScp:= .F.
	EndIf



//Registro M230 e M630 - Tabela CFA
	If nOpc == 1

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³aValores[1] -> Total Diferido			  ³
		//³aValores[2] -> Total Vendido     		  ³
		//³aValores[3] -> Total Recebido			  ³
		//³aValores[4] -> Aliquota PIS				  ³
		//³aValores[5] -> Aliquota COFINS			  ³
		//³aValores[6] -> PIS Diferido				  ³
		//³aValores[7] -> COFINS Diferido			  ³
		//³aValores[8] -> PIS Recolhido				  ³
		//³aValores[9] -> COFINS Recolhido			  ³
		//³aValores[10] -> Total N Recebido	          ³
		//³aValores[11] -> Crédito de PIS Diferido	  ³
		//³aValores[12] -> Crédito de COFINS Diferido ³
		//³aValores[13] -> Código do Crédito de PIS	  ³
		//³aValores[14] -> Código do Crédito da COFINS³
		//³aValores[15] -> Natureza do Credito        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		cCNPJ		:=	(cAlias)->CNPJCLI

		//Registro para Contribuicao de PIS
		cCodCont	:=	SPDCodCont("PIS",Empty(cNtFiscal),cCSTPis,aValores[4],cTpReg=="2",, Iif(cRegime $ '4/3' ,'3' ,cRegime ) ,lScp)
		cChvCFA		:=	cFilCFA+cPerApur+"PIS"+cCodCont+cCNPJ+str(aValores[4],5,2)

		If SPEDSeek("CFA",1,cChvCFA)
			RecLock("CFA",.F.)

			CFA->CFA_CONREC	+=	aValores[8]
			CFA->CFA_VLRREC	+=	aValores[3]
			If lNewDoc
				CFA->CFA_CONDIF	+=	aValores[6]
				CFA->CFA_TOTVEN	+=	aValores[2]
				CFA->CFA_TOTDIF	+=	aValores[1]
				CFA->CFA_VLNREC	+=	aValores[10]
			Else
				CFA->CFA_CONDIF	-=	aValores[8]
				CFA->CFA_TOTDIF	-=	aValores[3]
				CFA->CFA_VLNREC	-=	aValores[3]
			Endif
			MsUnLock()
		Else
			RecLock("CFA",.T.)
			CFA->CFA_FILIAL	:=	cFilCFA
			CFA->CFA_CODCON	:=	cCodCont
			CFA->CFA_TPCON	:=	"PIS"
			CFA->CFA_CNPJ	:=	cCNPJ
			CFA->CFA_TOTVEN	:=	aValores[2]
			CFA->CFA_TOTDIF	:=	aValores[1]
			CFA->CFA_CONDIF	:=	aValores[6]
			CFA->CFA_CREDIF	:=	aValores[11]
			CFA->CFA_CODCRE	:=	aValores[13]
			CFA->CFA_ALIQ	:=	aValores[4]
			CFA->CFA_CONREC	:=	aValores[8]
			CFA->CFA_VLRREC	:=	aValores[3]
			CFA->CFA_VLNREC	:=	aValores[10]
			CFA->CFA_PERAPU	:=	cPerApur
			IF lNewProc
				CFA->CFA_CONSOL	:=	'2' //Gravo indicando que não é consolidado, pois veio da movimentação
			EndIF
			MsUnLock()
		Endif

		//Adiciona conteudo para aColsPis, onde as informacoes serao mostradas na Dialog apos o processamento
		If (nPos := aScan(aColsPis, {|x| x[1] == cCNPJ .And. x[2]==cCodCont .And. x[4]==aValores[4]})) > 0

			If lNewDoc
				aColsPis[nPos][3]	+=	aValores[2]
				aColsPis[nPos][5]	+=	aValores[1]
				aColsPis[nPos][6]	+=	aValores[6]
			Else
				aColsPis[nPos][5]	-=	aValores[3]
				aColsPis[nPos][6]	-=	aValores[8]
			Endif

		Else
			aAdd(aColsPis,{cCNPJ,;
				cCodCont,;
				aValores[2],;
				aValores[4],;
				aValores[1],;
				aValores[6],;
				aValores[11],;
				aValores[13],;
				.F.})
		Endif

		//Registro para Contribuicao de COFINS
		cCodCont	:=	SPDCodCont("COF",Empty(cNtFiscal),cCSTCof,aValores[5],cTpReg=="2",,Iif(cRegime $ '3/4' ,'3' ,cRegime ),lScp)
		cChvCFA		:=	cFilCFA+cPerApur+"COF"+cCodCont+cCNPJ+str(aValores[5],5,2)

		If SPEDSeek("CFA",1,cChvCFA)
			RecLock("CFA",.F.)

			CFA->CFA_CONREC	+=	aValores[9]
			CFA->CFA_VLRREC	+=	aValores[3]
			If lNewDoc
				CFA->CFA_CONDIF	+=	aValores[7]
				CFA->CFA_TOTVEN	+=	aValores[2]
				CFA->CFA_TOTDIF	+=	aValores[1]
				CFA->CFA_VLNREC	+=	aValores[10]
			Else
				CFA->CFA_CONDIF	-=	aValores[9]
				CFA->CFA_TOTDIF	-=	aValores[3]
				CFA->CFA_VLNREC	-=	aValores[3]
			Endif
			MsUnLock()
		Else
			RecLock("CFA",.T.)
			CFA->CFA_FILIAL	:=	cFilCFA
			CFA->CFA_CODCON	:=	cCodCont
			CFA->CFA_TPCON	:=	"COF"
			CFA->CFA_CNPJ	:=	cCNPJ
			CFA->CFA_TOTVEN	:=	aValores[2]
			CFA->CFA_TOTDIF	:=	aValores[1]
			CFA->CFA_CONDIF	:=	aValores[7]
			CFA->CFA_CREDIF	:=	0 //aValores[12]
			CFA->CFA_CODCRE	:=	aValores[14]
			CFA->CFA_ALIQ	:=	aValores[5]
			CFA->CFA_CONREC	:=	aValores[9]
			CFA->CFA_VLRREC	:=	aValores[3]
			CFA->CFA_VLNREC	:=	aValores[10]
			CFA->CFA_PERAPU	:=	cPerApur
			IF lNewProc
				CFA->CFA_CONSOL	:=	'2' //Gravo indicando que não é consolidado, pois veio da movimentação
			EndIF
			MsUnLock()
		Endif

		//Adiciona conteudo para aColsCof, onde as informacoes serao mostradas na Dialog apos o processamento
		If (nPos := aScan(aColsCof, {|x| x[1] == cCNPJ .And. x[2]==cCodCont .And. x[4]==aValores[5]})) > 0

			If lNewDoc
				aColsCof[nPos][3]	+=	aValores[2]
				aColsCof[nPos][5]	+=	aValores[1]
				aColsCof[nPos][6]	+=	aValores[7]
			Else
				aColsCof[nPos][5]	-=	aValores[3]
				aColsCof[nPos][6]	-=	aValores[9]
			Endif

		Else
			aAdd(aColsCof,{cCNPJ,;
				cCodCont,;
				aValores[2],;
				aValores[5],;
				aValores[1],;
				aValores[7],;
				aValores[12],;
				aValores[14],;
				.F.})
		Endif

		If lAjuCPRB
			//Registro para Contribuicao de CPRB
			cCodCont	:=	'  '
			cChvCFA		:=	cFilCFA+cPerApur+"CPR"+cCodCont+cCNPJ+str(aValores[15],5,2)

			If SPEDSeek("CFA",1,cChvCFA)
				RecLock("CFA",.F.)

				CFA->CFA_CONREC	+=	aValores[17]
				CFA->CFA_VLRREC	+=	aValores[3]
				If lNewDoc
					CFA->CFA_CONDIF	+=	aValores[16]
					CFA->CFA_TOTVEN	+=	aValores[2]
					CFA->CFA_TOTDIF	+=	aValores[1]
					CFA->CFA_VLNREC	+=	aValores[10]
				Else
					CFA->CFA_CONDIF	-=	aValores[17]
					CFA->CFA_TOTDIF	-=	aValores[3]
					CFA->CFA_VLNREC	-=	aValores[3]
				Endif
				MsUnLock()
			Else
				RecLock("CFA",.T.)
				CFA->CFA_FILIAL	:=	cFilCFA
				CFA->CFA_CODCON	:=	cCodCont
				CFA->CFA_TPCON	:=	"CPR"
				CFA->CFA_CNPJ	:=	cCNPJ
				CFA->CFA_TOTVEN	:=	aValores[2]
				CFA->CFA_TOTDIF	:=	aValores[1]
				CFA->CFA_CONDIF	:=	aValores[16]
				CFA->CFA_CREDIF	:=	aValores[18]
				CFA->CFA_CODCRE	:=	aValores[19]
				CFA->CFA_ALIQ	:=	aValores[15]
				CFA->CFA_CONREC	:=	aValores[17]
				CFA->CFA_VLRREC	:=	aValores[3]
				CFA->CFA_VLNREC	:=	aValores[10]
				CFA->CFA_PERAPU	:=	cPerApur

				IF lNewProc
					CFA->CFA_CONSOL	:=	'2' //Gravo indicando que não é consolidado, pois veio da movimentação
				EndIF
				MsUnLock()
			Endif
		EndIf

//Registro M300 e M700 - Tabela CFB
	Else


		cDtPgto		:=	DTOS((cAlias)->DATABX)
		cPerDif		:=	Substr(DTOS((cAlias)->EMISSAO),5,2)+Substr(DTOS((cAlias)->EMISSAO),1,4)
		//Registro para Contribuicao de PIS
		cCodCont	:=	SPDCodCont("PIS",Empty(cNtFiscal),cCSTPis,aValores[4],cTpReg=="2",,Iif(cRegime $ '3/4' ,'3' ,cRegime ),lScp)

		IF lNewProc
			nPosCrd		:= 0

			aRetCrdDif	:= CrdDifAnt(cFilCFA,cPerDif,"PIS",cCodCont,(cAlias)->CNPJCLI,aValores[4], nPercRec,@aSldCrdDif, aValores[3],cPerApur)
		EndIF

		If Len(aRetCrdDif) == 0
			cChvCFB		:=	cFilCFB+cPerApur+"PIS"+cCodCont+cPerDif+cDtPgto+str(aValores[4],5,2)+'  2'
			If SPEDSeek("CFB",1,cChvCFB)
				RecLock("CFB",.F.)
				CFB->CFB_VLRREC	+=	aValores[3]
				CFB->CFB_CONREC	+=	aValores[8]
				CFB->CFB_CREDES	+=	0
				MsUnLock()
			Else
				RecLock("CFB",.T.)
				CFB->CFB_FILIAL	:=	cFilCFB
				CFB->CFB_CODCON	:=	cCodCont
				CFB->CFB_TPCON	:=	"PIS"
				CFB->CFB_VLRREC	:=	aValores[3]
				CFB->CFB_CONREC	:=	aValores[8]
				CFB->CFB_PERDIF	:=	cPerDif
				CFB->CFB_DTPGTO	:=	STOD(cDtPgto)
				CFB->CFB_NATCRE	:=	''
				CFB->CFB_CREDES	:=	0
				CFB->CFB_PERAPU	:=	cPerApur
				CFB->CFB_ALIQ	:=	aValores[4]
				IF lNewProc
					CFB->CFB_CONSOL	:=	'2'
				EndIF
				MsUnLock()
			Endif
		Else

			For nPosCrd	:= 1 to len(aRetCrdDif)
				cChvCFB		:=	cFilCFB+cPerApur+"PIS"+cCodCont+cPerDif+cDtPgto+str(aValores[4],5,2)+aRetCrdDif[nPosCrd][1]+'2'
				If SPEDSeek("CFB",1,cChvCFB)
					RecLock("CFB",.F.)
					CFB->CFB_VLRREC	+= 	Iif(aRetCrdDif[nPosCrd][3] > 0 , Round(aValores[3] * aRetCrdDif[nPosCrd][3] / 100,2), aValores[3])
					CFB->CFB_CONREC	+=	Iif(aRetCrdDif[nPosCrd][3] > 0 , Round(aValores[8] * aRetCrdDif[nPosCrd][3] / 100,2), aValores[8])
					CFB->CFB_CREDES	+=	aRetCrdDif[nPosCrd][2]
					MsUnLock()
				Else
					RecLock("CFB",.T.)
					CFB->CFB_FILIAL	:=	cFilCFB
					CFB->CFB_CODCON	:=	cCodCont
					CFB->CFB_TPCON	:=	"PIS"
					CFB->CFB_DTPGTO	:=	STOD(cDtPgto)
					CFB->CFB_PERDIF	:=	cPerDif
					CFB->CFB_NATCRE	:=	aRetCrdDif[nPosCrd][1]
					CFB->CFB_PERAPU	:=	cPerApur
					CFB->CFB_ALIQ	:=	aValores[4]
					CFB->CFB_CREDES	:=	aRetCrdDif[nPosCrd][2]

					CFB->CFB_VLRREC	:=	IIf(aRetCrdDif[nPosCrd][3] > 0 , Round(aValores[3] * aRetCrdDif[nPosCrd][3] / 100,2) , aValores[3])
					CFB->CFB_CONREC	:=	Iif(aRetCrdDif[nPosCrd][3] > 0 , Round(aValores[8] * aRetCrdDif[nPosCrd][3] / 100,2) , aValores[8])

					IF lNewProc
						CFB->CFB_CONSOL	:=	'2'
					EndIF

					MsUnLock()
				Endif

				//Gravat F0T com opção A

				IF lF0T .AND. aRetCrdDif[nPosCrd][2] > 0
					ObjF0T:Clear()
					ObjF0T:SetValue("F0T_FILIAL"	,cFilCFB)
					ObjF0T:SetValue("F0T_PER"		,firstday(STOD(cDtPgto)))
					ObjF0T:SetValue("F0T_FILAPU"	,cFilAnt)
					ObjF0T:SetValue("F0T_TIPO"		,'A') //Diferimento de créditos de PIS de período anterior
					ObjF0T:SetValue("F0T_DTEMI"		,STOD(cDtPgto) )
					ObjF0T:SetValue("F0T_DTRECB"	,(cAlias)->EMISSAO)
					ObjF0T:SetValue("F0T_VLCONT"	,(cAlias)->VALOR)
					ObjF0T:SetValue("F0T_VALREC"	,(cAlias)->VALORBX)
					ObjF0T:SetValue("F0T_CNPJ"	    ,(cAlias)->CNPJCLI)
					IF cOrigem == "SE1"
						//Possui somente título ou  título + nota fiscal
						ObjF0T:SetValue("F0T_NUMNF"		,(cAlias)->NFISCAL)
						ObjF0T:SetValue("F0T_SER"		,(cAlias)->FT_SERIE)

						ObjF0T:SetValue("F0T_ITEM"		,(cAlias)->FT_ITEM)
						ObjF0T:SetValue("F0T_NUMTIT"	,(cAlias)->DOC)
						ObjF0T:SetValue("F0T_PREFIX"	,(cAlias)->E1_PREFIXO)
						ObjF0T:SetValue("F0T_PARC"		,(cAlias)->E1_PARCELA)

					ElseIF cOrigem == "CF8"
						//Operações em Demais Documentos
						ObjF0T:SetValue("F0T_IDCF8"		,(cAlias)->DOC)

					EndIF

					ObjF0T:SetValue("F0T_PERREC"	,nPercRec * 100 ) //Percentual recebido do título
					ObjF0T:SetValue("F0T_VALCOF"	,aRetCrdDif[nPosCrd][5] * 100 ) //Percentual recebido
					ObjF0T:SetValue("F0T_MODELO"	,aRetCrdDif[nPosCrd][1]) //Natureza do crédito
					ObjF0T:SetValue("F0T_BASPIS"	,aRetCrdDif[nPosCrd][4]) //VAlor de PIS diferido anteriormente
					ObjF0T:SetValue("F0T_VALPIS"	,aRetCrdDif[nPosCrd][2]) //VAlor de PIS a descontar no período atual
					ObjF0T:Grava()

				EndIF

			Next nPosCrd

		EndIF

		//Adiciona conteudo para aColsPis, onde as informacoes serao mostradas na Dialog apos o processamento
		If (nPos := aScan(aColsPis, {|x| x[1]==cCodCont .And. x[3]==aValores[4] .And. x[4]==aValores[12] .And. x[6]==cPerDif .And. x[7]==STOD(cDtPgto)})) > 0

			aColsPis[nPos][2]	+=	aValores[8]
			aColsPis[nPos][5]	+=	aValores[10]

		Else
			aAdd(aColsPis,{cCodCont,;
				aValores[8],;
				aValores[4],;
				aValores[12],;
				aValores[10],;
				cPerDif,;
				STOD(cDtPgto),;
				.F.})
		Endif

		//Registro para Contribuicao de COFINS
		cCodCont	:=	SPDCodCont("COF",Empty(cNtFiscal),cCSTCof,aValores[5],cTpReg=="2",,Iif(cRegime $ '3/4' ,'3' ,cRegime ),lScp)

		IF lNewProc
			nPosCrd		:= 0

			aRetCrdDif	:= CrdDifAnt(cFilCFA,cPerDif,"COF",cCodCont,(cAlias)->CNPJCLI,aValores[5], nPercRec,@aSldCrdDif, aValores[3],cPerApur)
		EndiF

		If Len(aRetCrdDif) == 0
			cChvCFB		:=	cFilCFB+cPerApur+"COF"+cCodCont+cPerDif+cDtPgto+str(aValores[5],5,2)+'  2'
			If SPEDSeek("CFB",1,cChvCFB)
				RecLock("CFB",.F.)
				CFB->CFB_VLRREC	+=	aValores[3]
				CFB->CFB_CONREC	+=	aValores[9]
				CFB->CFB_CREDES	+=	0
				MsUnLock()
			Else
				RecLock("CFB",.T.)
				CFB->CFB_FILIAL	:=	cFilCFB
				CFB->CFB_CODCON	:=	cCodCont
				CFB->CFB_TPCON	:=	"COF"
				CFB->CFB_VLRREC	:=	aValores[3]
				CFB->CFB_CONREC	:=	aValores[9]
				CFB->CFB_PERDIF	:=	cPerDif
				CFB->CFB_DTPGTO	:=	STOD(cDtPgto)
				CFB->CFB_NATCRE	:=	''
				CFB->CFB_CREDES	:=	0
				CFB->CFB_PERAPU	:=	cPerApur
				CFB->CFB_ALIQ	:=	aValores[5]
				IF lNewProc
					CFB->CFB_CONSOL	:=	'2'
				EndIF
				MsUnLock()
			Endif
		Else
			For nPosCrd	:= 1 to len(aRetCrdDif)
				cChvCFB		:=	cFilCFB+cPerApur+"COF"+cCodCont+cPerDif+cDtPgto+str(aValores[5],5,2)+aRetCrdDif[nPosCrd][1]+'2'
				If SPEDSeek("CFB",1,cChvCFB)
					RecLock("CFB",.F.)
					CFB->CFB_VLRREC	+=	Iif(aRetCrdDif[nPosCrd][3] > 0 , Round(aValores[3] * aRetCrdDif[nPosCrd][3] / 100,2), aValores[3])
					CFB->CFB_CONREC	+=	Iif(aRetCrdDif[nPosCrd][3] > 0 , Round(aValores[9] * aRetCrdDif[nPosCrd][3] / 100,2), aValores[9])
					CFB->CFB_CREDES	+=	aRetCrdDif[nPosCrd][2]
					MsUnLock()
				Else
					RecLock("CFB",.T.)
					CFB->CFB_FILIAL	:=	cFilCFB
					CFB->CFB_CODCON	:=	cCodCont
					CFB->CFB_TPCON	:=	"COF"
					CFB->CFB_DTPGTO	:=	STOD(cDtPgto)
					CFB->CFB_PERDIF	:=	cPerDif
					CFB->CFB_NATCRE	:=	aRetCrdDif[nPosCrd][1]
					CFB->CFB_PERAPU	:=	cPerApur
					CFB->CFB_ALIQ	:=	aValores[5]
					CFB->CFB_CREDES	:=	aRetCrdDif[nPosCrd][2]

					CFB->CFB_VLRREC	:=	Iif(aRetCrdDif[nPosCrd][3] > 0 , Round(aValores[3] * aRetCrdDif[nPosCrd][3] / 100,2), aValores[3])
					CFB->CFB_CONREC	:=	Iif(aRetCrdDif[nPosCrd][3] > 0 , Round(aValores[9] * aRetCrdDif[nPosCrd][3] / 100,2), aValores[9])
					IF lNewProc
						CFB->CFB_CONSOL	:=	'2'
					EndIF
					MsUnLock()
				Endif

				//Gravat F0T com opção B

				IF lF0T .AND. aRetCrdDif[nPosCrd][2] > 0
					ObjF0T:Clear()
					ObjF0T:SetValue("F0T_FILIAL"	,cFilCFB)
					ObjF0T:SetValue("F0T_PER"		,firstday(STOD(cDtPgto)))
					ObjF0T:SetValue("F0T_FILAPU"	,cFilAnt)
					ObjF0T:SetValue("F0T_TIPO"		,'B') //Diferimento de créditos de PIS de período anterior
					ObjF0T:SetValue("F0T_DTEMI"		,STOD(cDtPgto) )
					ObjF0T:SetValue("F0T_DTRECB"	,(cAlias)->EMISSAO)
					ObjF0T:SetValue("F0T_VLCONT"	,(cAlias)->VALOR)
					ObjF0T:SetValue("F0T_VALREC"	,(cAlias)->VALORBX)
					ObjF0T:SetValue("F0T_CNPJ"	    ,(cAlias)->CNPJCLI)
					IF cOrigem == "SE1"
						//Possui somente título ou  título + nota fiscal
						ObjF0T:SetValue("F0T_NUMNF"		,(cAlias)->NFISCAL)
						ObjF0T:SetValue("F0T_SER"		,(cAlias)->FT_SERIE)

						ObjF0T:SetValue("F0T_ITEM"		,(cAlias)->FT_ITEM)
						ObjF0T:SetValue("F0T_NUMTIT"	,(cAlias)->DOC)
						ObjF0T:SetValue("F0T_PREFIX"	,(cAlias)->E1_PREFIXO)
						ObjF0T:SetValue("F0T_PARC"		,(cAlias)->E1_PARCELA)

					ElseIF cOrigem == "CF8"
						//Operações em Demais Documentos
						ObjF0T:SetValue("F0T_IDCF8"		,(cAlias)->DOC)

					EndIF

					ObjF0T:SetValue("F0T_PERREC"	,nPercRec * 100 ) //Percentual recebido do título
					ObjF0T:SetValue("F0T_VALCOF"	,aRetCrdDif[nPosCrd][5] * 100 ) //Percentual recebido
					ObjF0T:SetValue("F0T_MODELO"	,aRetCrdDif[nPosCrd][1]) //Natureza do crédito
					ObjF0T:SetValue("F0T_BASPIS"	,aRetCrdDif[nPosCrd][4]) //VAlor de PIS diferido anteriormente
					ObjF0T:SetValue("F0T_VALPIS"	,aRetCrdDif[nPosCrd][2]) //VAlor de PIS a descontar no período atual
					ObjF0T:Grava()

				EndIF
			Next nPosCrd
		EndIF

		//Adiciona conteudo para aColsCof, onde as informacoes serao mostradas na Dialog apos o processamento
		If (nPos := aScan(aColsCof, {|x| x[1]==cCodCont .And. x[3]==aValores[5] .And. x[4]==aValores[12] .And. x[6]==cPerDif .And. x[7]==STOD(cDtPgto)})) > 0

			aColsCof[nPos][2]	+=	aValores[9]
			aColsCof[nPos][5]	+=	aValores[11]

		Else
			aAdd(aColsCof,{cCodCont,;
				aValores[9],;
				aValores[5],;
				aValores[12],;
				aValores[11],;
				cPerDif,;
				STOD(cDtPgto),;
				.F.})
		Endif


		If lAjuCPRB

			cDtPgto		:=	DTOS((cAlias)->DATABX)
			cPerDif		:=	Substr(DTOS((cAlias)->EMISSAO),5,2)+Substr(DTOS((cAlias)->EMISSAO),1,4)
			//Registro para Contribuicao de CPRB
			cCodCont	:=	"  "

			IF lNewProc
				nPosCrd		:= 0

				aRetCrdDif	:= CrdDifAnt(cFilCFA,cPerDif,"CPR",cCodCont,(cAlias)->CNPJCLI,aValores[15], nPercRec,@aSldCrdDif, aValores[3],cPerApur) //Analisar Shiny
			EndIF

			If Len(aRetCrdDif) == 0
				cChvCFB		:=	cFilCFB+cPerApur+"CPR"+cCodCont+cPerDif+cDtPgto+str(aValores[15],5,2)+'  2'
				If SPEDSeek("CFB",1,cChvCFB)
					RecLock("CFB",.F.)
					CFB->CFB_VLRREC	+=	aValores[3]
					CFB->CFB_CONREC	+=	aValores[17]
					CFB->CFB_CREDES	+=	0
					MsUnLock()
				Else
					RecLock("CFB",.T.)
					CFB->CFB_FILIAL	:=	cFilCFB
					CFB->CFB_CODCON	:=	cCodCont
					CFB->CFB_TPCON	:=	"CPR"
					CFB->CFB_VLRREC	:=	aValores[3]
					CFB->CFB_CONREC	:=	aValores[17]
					CFB->CFB_PERDIF	:=	cPerDif
					CFB->CFB_DTPGTO	:=	STOD(cDtPgto)
					CFB->CFB_NATCRE	:=	''
					CFB->CFB_CREDES	:=	0
					CFB->CFB_PERAPU	:=	cPerApur
					CFB->CFB_ALIQ	:=	aValores[15]

					IF lNewProc
						CFB->CFB_CONSOL	:=	'2'
					EndIF
					MsUnLock()
				Endif
			Else

				For nPosCrd	:= 1 to len(aRetCrdDif)
					cChvCFB		:=	cFilCFB+cPerApur+"CPRB"+cCodCont+cPerDif+cDtPgto+str(aValores[15],5,2)+aRetCrdDif[nPosCrd][1]+'2'
					If SPEDSeek("CFB",1,cChvCFB)
						RecLock("CFB",.F.)
						CFB->CFB_VLRREC	+= 	Iif(aRetCrdDif[nPosCrd][3] > 0 , Round(aValores[3] * aRetCrdDif[nPosCrd][3] / 100,2), aValores[3])
						CFB->CFB_CONREC	+=	Iif(aRetCrdDif[nPosCrd][3] > 0 , Round(aValores[17] * aRetCrdDif[nPosCrd][3] / 100,2), aValores[17])
						CFB->CFB_CREDES	+=	aRetCrdDif[nPosCrd][2]
						MsUnLock()
					Else
						RecLock("CFB",.T.)
						CFB->CFB_FILIAL	:=	cFilCFB
						CFB->CFB_CODCON	:=	cCodCont
						CFB->CFB_TPCON	:=	"CPRB"
						CFB->CFB_DTPGTO	:=	STOD(cDtPgto)
						CFB->CFB_PERDIF	:=	cPerDif
						CFB->CFB_NATCRE	:=	aRetCrdDif[nPosCrd][1]
						CFB->CFB_PERAPU	:=	cPerApur
						CFB->CFB_ALIQ	:=	aValores[15]
						CFB->CFB_CREDES	:=	aRetCrdDif[nPosCrd][2]

						CFB->CFB_VLRREC	:=	IIf(aRetCrdDif[nPosCrd][3] > 0 , Round(aValores[3] * aRetCrdDif[nPosCrd][3] / 100,2) , aValores[3])
						CFB->CFB_CONREC	:=	Iif(aRetCrdDif[nPosCrd][3] > 0 , Round(aValores[17] * aRetCrdDif[nPosCrd][3] / 100,2) , aValores[17])
						//CFB->CFB_ATVCPB	:=	aValores[20]

						IF lNewProc
							CFB->CFB_CONSOL	:=	'2'
						EndIF

						MsUnLock()
					Endif

					//Gravat F0T com opção A

					IF lF0T .AND. aRetCrdDif[nPosCrd][2] > 0
						ObjF0T:Clear()
						ObjF0T:SetValue("F0T_FILIAL"	,cFilCFB)
						ObjF0T:SetValue("F0T_PER"		,firstday(STOD(cDtPgto)))
						ObjF0T:SetValue("F0T_FILAPU"	,cFilAnt)
						ObjF0T:SetValue("F0T_TIPO"		,'C') //Diferimento de créditos de PIS de período anterior
						ObjF0T:SetValue("F0T_DTEMI"		,STOD(cDtPgto) )
						ObjF0T:SetValue("F0T_DTRECB"	,(cAlias)->EMISSAO)
						ObjF0T:SetValue("F0T_VLCONT"	,(cAlias)->VALOR)
						ObjF0T:SetValue("F0T_VALREC"	,(cAlias)->VALORBX)
						ObjF0T:SetValue("F0T_CNPJ"	    ,(cAlias)->CNPJCLI)
						IF cOrigem == "SE1"
							//Possui somente título ou  título + nota fiscal
							ObjF0T:SetValue("F0T_NUMNF"		,(cAlias)->NFISCAL)
							ObjF0T:SetValue("F0T_SER"		,(cAlias)->FT_SERIE)

							ObjF0T:SetValue("F0T_ITEM"		,(cAlias)->FT_ITEM)
							ObjF0T:SetValue("F0T_NUMTIT"	,(cAlias)->DOC)
							ObjF0T:SetValue("F0T_PREFIX"	,(cAlias)->E1_PREFIXO)
							ObjF0T:SetValue("F0T_PARC"		,(cAlias)->E1_PARCELA)

						ElseIF cOrigem == "CF8"
							//Operações em Demais Documentos
							ObjF0T:SetValue("F0T_IDCF8"		,(cAlias)->DOC)

						EndIF

						ObjF0T:SetValue("F0T_PERREC"	,nPercRec * 100 ) //Percentual recebido do título
						//ObjF0T:SetValue("F0T_VALCOF"	,aRetCrdDif[nPosCrd][5] * 100 ) //Percentual recebido
						ObjF0T:SetValue("F0T_MODELO"	,aRetCrdDif[nPosCrd][1]) //Natureza do crédito
						ObjF0T:SetValue("F0T_BCCPRB"	,aRetCrdDif[nPosCrd][4]) //VAlor de PIS diferido anteriormente
						ObjF0T:SetValue("F0T_VLCPRB"	,aRetCrdDif[nPosCrd][2]) //VAlor de PIS a descontar no período atual
						ObjF0T:Grava()

					EndIF

				Next nPosCrd

			EndIF
		EndIf


	Endif

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} SumParcE1
Funcao que busca conteudo de determinado paramentro na filial de origem

	
@param	cFilE1 -> Filial do Titulo
		cCliente -> Codigo do cliente
		cLoja -> Loja do cliente
		cPrefixo -> Prefixo do titulo
		cDoc -> Numero do titulo
		dDataAte -> dATA FINALIZAÇÃO DE PROCESSAMENTO
					
@return	nVlrTot -> Valor total de todas as parcelas somadas do titulo que esta
					sendo processado
		
@author Luccas Curcio
@since 19/10/2012
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function SumParcE1(cFilE1,cCliente,cLoja,cPrefixo,cDoc, dDataAte)
	Local	nVlrTot	:=	0
	Local	nSomaAbat := 0

	DbSelectArea("SE1")
	SE1->(DbSetOrder(2))

	If SE1->(MsSeek(cFilE1+cCliente+cLoja+cPrefixo+cDoc))
		While !SE1->(Eof()) .And. SE1->(E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM) == cFilE1+cCliente+cLoja+cPrefixo+cDoc
			If !(SE1->E1_TIPO $ MVABATIM)
				nSomaAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA, SE1->E1_EMISSAO, SE1->E1_CLIENTE, SE1->E1_LOJA,,dDataAte,SE1->E1_TIPO)
				nVlrTot += SE1->E1_VALOR - nSomaAbat
			Endif
			SE1->(DbSkip())
		End
	Endif

Return nVlrTot


//-------------------------------------------------------------------
/*/{Protheus.doc} A054PTit
Função que irá realizar verificação de recebimentos dos títulos transferidos
entre as filiais, gravados na tabela SE6. Se o título foi transferido, para 
efeitos de diferimento, o valor recebido na filial de transferência 
será considerado na filial de origem.
	
@param	dDataDe 	  -> Data inicial do processamento
		dDataAte  	  -> Data Final do Processamento
		cFili     	 -> Filial de Origem
		cPrefixo	  -> Prefixo do Título processado
		cNumero	  -> Número do Título Processado
		cParcela	  -> Parcela do título processado
		cCliFor	  -> Cliente do Título Processado
		cLoja		  -> Loja do Título Processado
					
@return nValLiq - Valor de recebimento líquido do Título
		
@author Erick Dias
@since 18/09/2014
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function A054PTit(dDataDe,dDataAte,cFili,cPrefixo,cNumero,cParcela,cTipo,cCliFor,cLoja,lAuto,l12_1_2610,lClFinMove,oJSqlName)

	Local jParam     as json
	Local jReturn    as json
	Local jTitulo    as json
	Local cChaveFK7  as character
	Local cQuery     as character
	Local cAliasSE5  as character
	Local oFin       as object
	Local nI         as numeric
	Local nValLiq	 as numeric
	Local lConsCmp	 as logical
	Local nTamTit	 as numeric
	Local oPrepare   as object

	cChaveFK7 := ""
	cQuery    := ""
	cAliasSE5 := ""
	nI 		  := 0
	nValLiq   := 0
	lConsCmp  := .F.

	if (l12_1_2610 .and.lClFinMove) .or. lAuto

		jParam := JsonObject():new()
		jParam['branch']             := cFili
		jParam['initialDate']        := dDataDe
		jParam['finalDate']          := dDataAte
		jParam['filterOrigBranch']   := .F.
		jParam['removeReversed']     := .F.
		jParam['lcompensated']       := .F.
		jParam['addFilterQuery']     := " AND FK1.FK1_TPDOC IN ('BA','CP','VL','V2','LJ','ES','DC') AND FK1.FK1_MOTBX <> 'FAT'"

		cChaveFK7 := cFili + cPrefixo + cNumero + cParcela + cTipo + cCliFor + cLoja

		oFin := totvs.protheus.backoffice.fin.movements.Movements():New(jParam)
		oFin:setIdDocKey(cChaveFK7, "R")

		jReturn := JsonObject():New()
		jReturn := oFin:getWriteOffsByBill()

		For nI := 1 To Len(jReturn['document'])
			lConsCmp := .F.
			If TemBxCanc(jReturn['document'][nI]['FK7_PREFIX']+jReturn['document'][nI]['FK7_NUM']+jReturn['document'][nI]['FK7_PARCEL']+jReturn['document'][nI]['FK7_TIPO']+cCliFor+jReturn['document'][nI]['FK7_LOJA']+jReturn['document'][nI]['E5_SEQ'])
				Loop
			EndIf
			//Compensacao com NCC nao deve ser considerada para calculo do PIS/Cofins
			//MV_CRNEG --> inversao do calculo para titulo a receber
			jTitulo := JsonObject():New()
			jTitulo := oFin:getCompDocumentJson(jReturn['document'][nI]['FK_IDFK'], "R")
			If (jReturn['document'][nI]['E5_MOTBX'] == "CMP" .And. jTitulo['document'][1]['FK7_TIPO'] $ MV_CRNEG).Or.(jReturn['document'][nI]['FK7_TIPO'] $ MV_CRNEG) //NCC
				Loop
			Endif
			//Compensacao com RA deve ser considerada para calculo do PIS/Cofins e Liquidacao
			If ((jReturn['document'][nI]['E5_MOTBX'] == "CMP" .And. jTitulo['document'][1]['FK7_TIPO'] $ MVRECANT)) .Or. (jReturn['document'][nI]['E5_MOTBX'] == "LIQ") //MVRECANT = RA
				lConsCmp :=.T.
			Endif
			//Desconsidera Baixa por Dacao
			If !(jReturn['document'][nI]['E5_MOTBX'] == "CEC") // Compensacao entre Carteiras considera na apuracao
				If !lConsCmp .And. !MovBcoBx(jReturn['document'][nI]['E5_MOTBX'],.T.)
					Loop
				Endif
			Endif

			nValLiq += jReturn['document'][nI]['E5_VALOR']

		Next

		FreeObj(oFin)

	Else

		nTamTit	  := GetSX3Cache("E1_PREFIXO", "X3_TAMANHO")+GetSX3Cache("E1_NUM", "X3_TAMANHO")+GetSX3Cache("E1_PARCELA", "X3_TAMANHO")+1

		cQuery := " SELECT SE5.E5_DATA, SE5.E5_PREFIXO, SE5.E5_NUMERO, SE5.E5_PARCELA, SE5.E5_TIPO, SE5.E5_CLIFOR, SE5.E5_LOJA, "
		cQuery += " SE5.E5_VALOR, SE5.E5_MOTBX, SE5.E5_SEQ, SE5.E5_DOCUMEN "
		cQuery += " FROM " + oJSqlName["SE5"] + " SE5 "
		cQuery += " WHERE SE5.E5_FILIAL = ? "
		cQuery += " AND SE5.E5_DATA BETWEEN ? AND ? "
		cQuery += " AND SE5.E5_PREFIXO = ? AND SE5.E5_NUMERO = ? AND SE5.E5_PARCELA = ? "
		cQuery += " AND SE5.E5_CLIFOR = ?  AND SE5.E5_LOJA = ? "
		cQuery += " AND SE5.E5_TIPODOC IN (?) AND SE5.E5_MOTBX <> ? "
		cQuery += " AND SE5.D_E_L_E_T_ = ? "
		cQuery += " ORDER BY SE5.E5_DATA,SE5.E5_SEQ "

		oPrepare := FwExecStatement():New(cQuery)

		oPrepare:setString( 1, cFili    )
		oPrepare:setDate(   2, dDataDe  )
		oPrepare:setDate(   3, dDataAte )
		oPrepare:setString( 4, cPrefixo )
		oPrepare:setString( 5, cNumero  )
		oPrepare:setString( 6, cParcela )
		oPrepare:setString( 7, cCliFor  )
		oPrepare:setString( 8, cLoja    )
		oPrepare:setIn(     9, {'BA','CP','VL','V2','LJ','ES','DC'} )
		oPrepare:setString(10, 'FAT' )
		oPrepare:setString(11, ' '   )

		cAliasSE5 := oPrepare:OpenAlias()

		While !(cAliasSE5)->(Eof())
			lConsCmp  := .F.
			//Verifica se tem baixa cancelada
			If TemBxCanc((cAliasSE5)->E5_PREFIXO+(cAliasSE5)->E5_NUMERO+(cAliasSE5)->E5_PARCELA+(cAliasSE5)->E5_TIPO+(cAliasSE5)->E5_CLIFOR+(cAliasSE5)->E5_LOJA+(cAliasSE5)->E5_SEQ)
				(cAliasSE5)->(dbskip())
				Loop
			EndIf
			//Compensacao com NCC nao deve ser considerada para calculo do PIS/Cofins
			//MV_CRNEG --> inversao do calculo para titulo a receber
			If ((cAliasSE5)->E5_MOTBX == "CMP" .And. SUBSTR((cAliasSE5)->E5_DOCUMEN,nTamTit,3)$MV_CRNEG).Or.((cAliasSE5)->E5_TIPO$MV_CRNEG) //NCC
				(cAliasSE5)->(dbskip())
				Loop
			Endif
			//Compensacao com RA deve ser considerada para calculo do PIS/Cofins e Liquidacao
			If (((cAliasSE5)->E5_MOTBX == "CMP" .And. SUBSTR((cAliasSE5)->E5_DOCUMEN,nTamTit,3)$MVRECANT)) .Or. ((cAliasSE5)->E5_MOTBX == "LIQ") //MVRECANT = RA
				lConsCmp :=.T.
			Endif
			//Desconsidera Baixa por Dacao
			If !(cAliasSE5)->E5_MOTBX == "CEC" // Compensacao entre Carteiras considera na apuracao
				If !lConsCmp .And. !MovBcoBx((cAliasSE5)->E5_MOTBX,.T.)
					(cAliasSE5)->(dbskip())
					Loop
				Endif
			Endif
			//Adiciona o valor baixado + os Abatimentos - Juros e Multa + Desconto.
			// Retirei, pois queremos a baixa líquida, e ao chamar o somaabat estamos somando com TODOS abatimentos da SE1
			/*If cBR10925 == "2"
			nValLiq += (cAliasSE5)->E5_VALOR + SomaAbat((cAliasSE5)->E5_PREFIXO,(cAliasSE5)->E5_NUMERO,(cAliasSE5)->E5_PARCELA,"R",Val((cAliasSE5)->E5_MOEDA),dDataBase,(cAliasSE5)->E5_CLIFOR, (cAliasSE5)->E5_LOJA,,dDataAte) - (cAliasSE5)->E5_VLJUROS - (cAliasSE5)->E5_VLMULTA + (cAliasSE5)->E5_VLDESCO
			ElseIF FindFunction('SumPCC130') // essa parte foi retirada só pq não entendemos o sentido mesmo....
			nValLiq += (cAliasSE5)->E5_VALOR + SumPCC130((cAliasSE5)->E5_PREFIXO,(cAliasSE5)->E5_NUMERO,(cAliasSE5)->E5_PARCELA,(cAliasSE5)->E5_DATA,(cAliasSE5)->E5_CLIFOR,(cAliasSE5)->E5_LOJA,Val((cAliasSE5)->E5_MOEDA)) - (cAliasSE5)->E5_VLJUROS - (cAliasSE5)->E5_VLMULTA + (cAliasSE5)->E5_VLDESCO
			EndIf */

			nValLiq += (cAliasSE5)->E5_VALOR

			(cAliasSE5)->(dbSkip())
		EndDo   

		(cAliasSE5)->(DbCloseArea())       

		If oPrepare != Nil
			oPrepare:Destroy()
			oPrepare := nil
		EndIf
	EndIf

Return(nValLiq)

Static Function BuscaFil(aXFilial,cTAb)

	Local nPos	:= 0
	Local cRet	:= ''

	nPos:=	aScan(aXFilial	,{|aX| aX[1]==cTAb}) 
	If nPos > 0	
		cRet := aXFilial[nPos][2]
	Else
		cRet := xFilial(cTab)
	EndIF
			 

Return cRet
		
		
		
Static Function CrdDifAnt(cFilCFA,cPerDif,cTrib,cCodCon,cCnpj,nAliq, nPerc,aSldCrdDif, nTotBaixa, cPerApur)

	Local cChave	:= cFilCFA +  cPerDif + cTrib + cCodCon + cCnpj + STR(nAliq,5,2)   
	Local aRet		:= {}
	Local nPos		:= 0
	Local cNatCred	:= ''
	Local nTotCrd	:= 0
	Local nValCrd	:= 0
	Local nCont		:= 0
	Local nPosSld	:= 0

	Default aSldCrdDif	:= {}

	If cCodCon $ '01/02/03/04/71' .AND. CFA->(MSSEEK(cChave))

		Do While !CFA->(Eof ()) .AND. CFA->(CFA_FILIAL+CFA_PERAPU+CFA_TPCON+CFA_CODCON+CFA_CNPJ+STR(CFA_ALIQ,5,2)) == cChave
			
			//Deverá aqui aplicar ércentual de recebimento nos códigos
			If CFA->CFA_CONSOL == '2' .AND. CFA->CFA_CREDIF > 0 
				
				cNatCred	:=  substr(CFA->CFA_CODCRE,2,2) 			
				
				//Para as naturezas de créditos 01, 02 e 03 é exatamente o final do código de crédito, porém natureza da agro industria é 06, por este motivo
				//altero de 06 para 04, que é o código exigido no layout do M300/M700
				If cNatCred == '06'
					cNatCred	:= '04'
				EndIF
				
				nPos:=aScan(aRet,{|aX| aX[1]==cNatCred})
				
				//Porporcionaliza o total da recebido do título em quetão em função do total da base do diferimento gravado na CFA do período
				//Pois o total de vendas da CFA pode contemplar diversos títulos no período para o mesmo CNPJ.
				nPerc := nTotBaixa/ CFA->CFA_TOTDIF
							
				nValCrd	:= Round(CFA->CFA_CREDIF * nPerc,2)
				
				nPosSld:=aScan(aSldCrdDif,{|aX| aX[1]==cChave})

				If nPosSld == 0	
					aRetVlDif := SldCredDif(cPerApur,cPerDif,Iif(cTrib == 'PIS', 'A',Iif(cTrib == 'COF', 'B', 'C')),cCnpj,cNatCred)

					aAdd(aSldCrdDif, {})
					nPosSld := Len(aSldCrdDif)
					aAdd (aSldCrdDif[nPosSld], cChave)//Chave																
					aAdd (aSldCrdDif[nPosSld], CFA->CFA_CREDIF - aRetVlDif[1])//Total do Crédito Disponível da chave
					aAdd (aSldCrdDif[nPosSld], CFA->CFA_TOTDIF - aRetVlDif[2])//SALDO A RECEBER ATÉ O MOMENTO

				EndIF

				
				If nValCrd < aSldCrdDif[nPosSld][2] .AND. nTotBaixa < aSldCrdDif[nPosSld][3]
					//Se o valor do crédito desta baixa não for superior ao total do crédito diferido ou o valor baixado não é superior ao saldo a receber, então pode utilizar de forma integral
					aSldCrdDif[nPosSld][2] -= nValCrd
					aSldCrdDif[nPosSld][3] -= nTotBaixa
				Else
					//Caso o valor da baixa do crédito seja maior que o crédito diferido inicialmente ou o Valor de Baixa for maior que o saldo a receber, então irá considerar somente a diferença
					nValCrd	:= aSldCrdDif[nPosSld][2] 
					aSldCrdDif[nPosSld][2]	:= 0
					aSldCrdDif[nPosSld][3]  := 0				
				EndIF
				
				IF nPos == 0
					aAdd(aRet, {})
					nPos := Len(aRet)
					aAdd (aRet[nPos], cNatCred)
					aAdd (aRet[nPos], nValCrd)
					aAdd (aRet[nPos], 0)												
					aAdd (aRet[nPos], CFA->CFA_CREDIF)
					aAdd (aRet[nPos], nPerc)
				Else
					aRet[nPos][2] += nValCrd
					aRet[nPos][5] += nPerc
					
				EndIF
				nTotCrd += nValCrd			
							
			EndIf
		
			CFA->(DbSkip ())
		EndDo
		
		For nCont	:= 1 to Len(aRet)
			aRet[nCont][3] := aRet[nCont][2] * 100 / nTotCrd
		Next nCont


EndIF

Return aRet

//Função que irá definir se novo processamento de diferimento está ou não habilitado.
Function ISA001NDIF()

Return GetNewPar('MV_DIFCRD1','1') == '2' .AND. CFA->(FieldPos( 'CFA_CONSOL' )) > 0 .AND. CFB->(FieldPos( 'CFB_CONSOL' )) > 0


Function ISA001Data()

	Local cMsg	:= ''

	cMsg	+= 'FISA001 - ' 	+ dtoc(GetAPOInfo("FISA001.prw")[4]) + ' - ' 	+  GetAPOInfo("FISA001.prw")[5] 	+ '  |  '   
	cMsg	+= 'FISA002 - ' 	+ dtoc(GetAPOInfo("FISA002.prw")[4]) + ' - ' 	+  GetAPOInfo("FISA002.prw")[5]  	+ CHR(10)+CHR(13)
	cMsg	+= 'FISA003 - ' 	+ dtoc(GetAPOInfo("FISA003.prw")[4]) + ' - ' 	+  GetAPOInfo("FISA003.prw")[5]  	+ '  |  '
	cMsg	+= 'FISA004 - ' 	+ dtoc(GetAPOInfo("FISA004.prw")[4]) + ' - ' 	+  GetAPOInfo("FISA004.prw")[5]  	+ CHR(10)+CHR(13)
	cMsg	+= 'FISA005 - ' 	+ dtoc(GetAPOInfo("FISA005.prw")[4]) + ' - ' 	+  GetAPOInfo("FISA005.prw")[5]  	+ '  |  '
	cMsg	+= 'FISA006 - ' 	+ dtoc(GetAPOInfo("FISA006.prw")[4]) + ' - ' 	+  GetAPOInfo("FISA006.prw")[5]  	+ CHR(10)+CHR(13)
	cMsg	+= 'FISA007 - ' 	+ dtoc(GetAPOInfo("FISA007.prw")[4]) + ' - ' 	+  GetAPOInfo("FISA007.prw")[5]  	+ '  |  '
	cMsg	+= 'FISA008 - ' 	+ dtoc(GetAPOInfo("FISA008.prw")[4]) + ' - ' 	+  GetAPOInfo("FISA008.prw")[5]  	+ CHR(10)+CHR(13)
	cMsg	+= 'EFDBLOCO0 - ' 	+ dtoc(GetAPOInfo("EFDBLOCO0.prw")[4]) + ' - ' 	+  GetAPOInfo("EFDBLOCO0.prw")[5]  	+ '  |  '
	cMsg	+= 'EFDBLOCO1 - ' 	+ dtoc(GetAPOInfo("EFDBLOCO1.prw")[4]) + ' - ' 	+  GetAPOInfo("EFDBLOCO1.prw")[5]  	+ CHR(10)+CHR(13)
	cMsg	+= 'EFDBLOCOA - ' 	+ dtoc(GetAPOInfo("EFDBLOCOA.prw")[4]) + ' - ' 	+  GetAPOInfo("EFDBLOCOA.prw")[5]  	+ '  |  '
	cMsg	+= 'EFDBLOCOC - ' 	+ dtoc(GetAPOInfo("EFDBLOCOC.prw")[4]) + ' - ' 	+  GetAPOInfo("EFDBLOCOC.prw")[5]  	+ CHR(10)+CHR(13)
	cMsg	+= 'EFDBLOCOD - ' 	+ dtoc(GetAPOInfo("EFDBLOCOD.prw")[4]) + ' - ' 	+  GetAPOInfo("EFDBLOCOD.prw")[5] 	+ '  |  '
	cMsg	+= 'EFDBLOCOF - ' 	+ dtoc(GetAPOInfo("EFDBLOCOF.prw")[4]) + ' - ' 	+  GetAPOInfo("EFDBLOCOF.prw")[5] 	+ CHR(10)+CHR(13)
	cMsg	+= 'EFDBLOCOI - ' 	+ dtoc(GetAPOInfo("EFDBLOCOI.prw")[4]) + ' - ' 	+  GetAPOInfo("EFDBLOCOI.prw")[5]  	+ '  |  '
	cMsg	+= 'EFDBLOCOM - '	+ dtoc(GetAPOInfo("EFDBLOCOM.prw")[4]) + ' - ' 	+  GetAPOInfo("EFDBLOCOM.prw")[5]  	+ CHR(10)+CHR(13)
	cMsg	+= 'EFDBLOCOP - ' 	+ dtoc(GetAPOInfo("EFDBLOCOP.prw")[4]) + ' - ' 	+  GetAPOInfo("EFDBLOCOP.prw")[5]  	+ '  |  '
	If FindFunction('FISR101') .And. GetRPORelease() <= "12.1.2310"
		cMsg	+= 'FISR101 - ' 	+ dtoc(GetAPOInfo("FISR101.prw")[4]) + ' - ' 	+  GetAPOInfo("FISR101.prw")[5] + CHR(10)+CHR(13)
	EndIf
	cMsg	+= 'FISX001 - ' 	+ dtoc(GetAPOInfo("FISX001.prw")[4]) + ' - ' 	+  GetAPOInfo("FISX001.prw")[5]  	+ '  |  '
	cMsg	+= 'FISX002 - ' 	+ dtoc(GetAPOInfo("FISX002.prw")[4]) + ' - ' 	+  GetAPOInfo("FISX002.prw")[5]  


	
	MSGINFO(cMsg)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} IsLastBx
Funcão que retorna a baixa que está sendo processada é a ultima do titulo.
	
@param	cPrefixo -> Prefixo do titulo baixado
		cNum -> Número do titulo baixado
		cParcela -> Parcela do titulo
		cTipo -> Tipo do titulo
		cFornece -> Cliente/Fornecedor
		cLoja -> Loja
		Seq -> Sequencia da baixa
				
@return	lRet
		
@author Marsaulo Dias de Souza
@since 16/02/2017
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function IsLastBx(cPrefixo,cNum,cParcela,cTipo,cFornece,cLoja,Seq)
	Local lRet := .F.
	Local cSeq := Seq
	Local cQuery
	Local cSeqMax := ""

	If !Empty(Alltrim(cNum)) 

		cQuery := "SELECT MAX(SE5.E5_SEQ) SEQMAX"
		cQuery += " FROM " + RetSqlName("SE5") +" SE5 "
		cQuery += " WHERE SE5.E5_FILIAL = '" + xFilial("SE5") + "' AND"
		cQuery += "    	SE5.E5_RECPAG = 'R' AND "
		cQuery += "    	SE5.E5_SITUACA != 'C' AND "
		cQuery += "    	SE5.D_E_L_E_T_ = ' ' AND "
		cQuery += "       SE5.E5_PREFIXO = '" + cPrefixo + "' AND"
		cQuery += "       SE5.E5_NUMERO  = '" + cNum + "' AND"
		cQuery += "       SE5.E5_PARCELA = '" + cParcela + "' AND"
		cQuery += "       SE5.E5_TIPO = '" + cTipo + "' AND"
		cQuery += "       SE5.E5_CLIFOR = '" + cFornece + "' AND"
		cQuery += "       SE5.E5_LOJA = '" + cLoja + "' "
		
		cQuery := ChangeQuery(cQuery)
		
		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"SEQUEN",.F.,.T.)
		
		/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se a maior sequencia de baixa desse título for igual  ³
		//³a sequencia que está sendo tratada, significa que é a ³
		//³ultima baixa que ocorreu no título.                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
		If SEQUEN->SEQMAX == cSeq
			lRet := .T.
		EndIf
		
		SEQUEN->(dbCloseArea())
	Endif

Return lRet

Static Function CompTabEFD(lIndivid)

	Local lErro		:= .F.
	Local aAlias	:= {}
	Local nCont		:= 0
	Local cTit		:= 'Atenção, o compartilhamento das tabelas abaixo não condizem com o modo de apuração selecionado (' + Iif(lIndivid,'Individualizada','Agrupada') + '):'
	Local cMsg		:= ''
	Local cRet		:= ''

	AADD(aAlias,{'CCY'})
	AADD(aAlias,{'CCW'})
	AADD(aAlias,{'SFV'})
	AADD(aAlias,{'SFW'})
	AADD(aAlias,{'CF5'})
	AADD(aAlias,{'CF4'})
	AADD(aAlias,{'CF3'})

	//Verifica compatibilidade das tabelas de acordo com opção de apuração consolidada ou individualizada.	
	For nCont	:=1 to Len(aAlias)
		
		IF FWModeAccess( aAlias[nCont][1] , 3 ) == Iif(lIndivid,'C' ,'E' )		
			cMsg +=aAlias[nCont][1] + Iif( nCont == Len(aAlias),'' ,',' )
			lErro	:= .T. 
		EndIf
		
	Next nCont

	If lErro
		cRet :=  cTit  + CHR(10)+CHR(13) + cMsg + CHR(10)+CHR(13) + 'Isso poderá ocasionar incosistências na apuração.' 
	EndIF

Return cRet 

//-------------------------------------------------------------------
/*/{Protheus.doc} ProcAjuFin
Função que fará ajuste de redução da contribuição, nas situações onde
existem títulos emitidos em período anterior que foram excluídos em 
período posterior, gerando assim registros M220 e M620 estornando 
a contribuição. Utiliza função do Financeiro FinSpdM220 que está no finxspd.prx

	
@param	dDtIni -> Data inicial de processamento'
		dDtFim -> Data final de processamento
		oAjustes -> Objeto para tratar os ajustes na apuração
		oApurSai -> Objeto para tratar a composição do código da contribuição
		
@author Erick G Dias
@since 19/01/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function ProcAjuFin( dDtIni, dDtFim, oAjustes, oApurSai)

	Local	aTitulo		:=	{}
	Local	nX			:=	0

	//Alimenta o array aTitulo com o conteudo retornado da funcao do Financeiro
	aTitulo	:=	FinSpdM220(Month(dDtIni),Year(dDtFim))

	For nX := 1 To Len(aTitulo)

		//Se tem valor de PIS fará o ajuste
		If aTitulo[nX][6] > 0 
			
			//Define o regime dos objetos oAjustes e oApursai
			IF aTitulo[nX][12] == '0' //Cumulativo
				oAjustes:SetRegime( CUMULAT )
				oApurSai:SetTpReg( CUMULAT )
			ElseIF aTitulo[nX][12] == '1' //Não Cumulativo
				oAjustes:SetRegime( NAOCUMULAT )
				oApurSai:SetTpReg( NAOCUMULAT )
			EndIF
					
			oApurSai:SetCST( aTitulo[nX][8] ) //CST de PIS		
			oApurSai:DefRegime()
			//----------------------
			//AJUSTE DE REDUÇÃO PIS
			//----------------------
			oAjustes:SetTributo( PIS ) 
			oAjustes:SetTpAjust( REDUCAO )
			oAjustes:SetCodAju( aTitulo[nX][2] )
			oAjustes:SetNumDoc( aTitulo[nX][3] )
			oAjustes:SetDescAju( aTitulo[nX][4] )
			oAjustes:SetVlAju( aTitulo[nX][6] )
			oAjustes:SetCodDC( oApurSai:CodCon() )
			oAjustes:SetCst(aTitulo[nX][8])			
			oAjustes:SetInfComp(aTitulo[nX][4])			
			oAjustes:SetAlq(aTitulo[nX][10])					
			oAjustes:SetDtRefer(stod(aTitulo[nX][5]))			
			//Tratamento para a base de PIS
			If len(aTitulo[nX]) >= 14
				oAjustes:SetBase(aTitulo[nX][13])
			Else
				oAjustes:SetBase(0)
			EndIf

			If Len(aTitulo[nX]) >= 15 
				oAjustes:SetConta(aTitulo[nX][15])
			EndIf 

			oAjustes:Ajustar()		
		EndIF

		//Se tem valor de COFINS fará o ajuste
		IF aTitulo[nX][7] > 0
			//-----------------
			//Ajustes de COFINS
			//-----------------
			//Define o regime dos objetos oAjustes e oApursai
			IF aTitulo[nX][12] == '0' //Cumulativo
				oAjustes:SetRegime( CUMULAT )
				oApurSai:SetTpReg( CUMULAT )
			ElseIF aTitulo[nX][12] == '1' //Não Cumulativo
				oAjustes:SetRegime( NAOCUMULAT )
				oApurSai:SetTpReg( NAOCUMULAT )
			EndIF		
			oApurSai:SetCST( aTitulo[nX][8] ) //CST de PIS		
			oApurSai:DefRegime()
			
			oAjustes:SetTributo(COFINS) 
			oAjustes:SetTpAjust(REDUCAO)
			oAjustes:SetCodAju(aTitulo[nX][2])
			oAjustes:SetNumDoc(aTitulo[nX][3])
			oAjustes:SetDescAju(aTitulo[nX][4])
			oAjustes:SetVlAju(aTitulo[nX][7])
			oAjustes:SetCodDC(oApurSai:CodCon() )
			oAjustes:SetCst(aTitulo[nX][9]) 			
			oAjustes:SetInfComp(aTitulo[nX][4])			
			oAjustes:SetAlq(aTitulo[nX][11])					
			oAjustes:SetDtRefer( stod(aTitulo[nX][5]) )			 		
			//Tratamento para base da COFINS
			If len(aTitulo[nX]) >= 14
				oAjustes:SetBase(aTitulo[nX][14])
			Else
				oAjustes:SetBase(0)
			EndIf
			
			If Len(aTitulo[nX]) >= 15 
				oAjustes:SetConta(aTitulo[nX][15])
			EndIf
			
			oAjustes:Ajustar()				
			
		Endif
		
	Next nX

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} ExEFDCON03
Função que executará o ponto de entrada EFDCON03, que altera a conta
contábil do registro F100. Como o registro F100 pode ser gerado através
da SE1, SE2 ou SE5, verifico o alias, posiciono na tabela através do DBGOTOP()
e envio as informações para o ponto de entrada. 
A conta retornada pelo ponto de entrada será gerada no registro F100.

	
@param	cAlias - Caracter - Alias do título SE1/SE2/SE5
		nReco  - Numerico - Recno do título processado		

@return - Conta contábil retornada pelo ponto de entrada EFDCON03		

@author Erick G Dias
@since 24/04/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function ExEFDCON03( cAlias, nReco )

	Local cConta	:= ""

	//Posiciona na tabela do título, e envia as informações para o ponto de entrada.
	If cAlias == "SE1"
		SE1->(dbGoto( nReco ))
		cConta	:= ExecBlock("EFDCON03",.F.,.F.,{ cAlias, SE1->E1_NUM, SE1->E1_PREFIXO, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_NATUREZ, nReco })
	ElseIF cAlias == "SE2"
		SE2->(dbGoto( nReco ))
		cConta	:= ExecBlock("EFDCON03",.F.,.F.,{ cAlias, SE2->E2_NUM, SE2->E2_PREFIXO, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ, nReco })
	ElseIF cAlias == "SE5"
		SE5->(dbGoto( nReco ))
		cConta	:= ExecBlock("EFDCON03",.F.,.F.,{ cAlias, SE5->E5_NUMERO, SE5->E5_PREFIXO, SE5->E5_PARCELA, SE5->E5_TIPO, Iif( !Empty( Alltrim( SE5->E5_CLIENTE ) ) , SE5->E5_CLIENTE , SE5->E5_FORNECE ) , SE5->E5_LOJA, SE5->E5_NATUREZ, nReco })
	ElseIF cAlias == "SEI"	//Considerar registros da SEI(Aplicações Financeiras) - DSERFIS1-35302
		SEI->(dbGoto( nReco ))
		cConta	:= ExecBlock("EFDCON03",.F.,.F.,{ cAlias, SEI->EI_NUMERO, "", "", "", "", "", SEI->EI_NATUREZ, nReco })
	EndIF

Return cConta

//-------------------------------------------------------------------
/*/{Protheus.doc} AjBaseCalc
Função que fará leitura das informações da tabela F2Z para processar
os ajustes da base de cálculo de PIS e COFINS, buscando sempre as 
informações gravadas manualmente pelo usuário

@author Erick G. Dias
@since 31/10/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
 Static Function AjBaseCalc(dDataDe,dDataAte, oAjustes)

	Local cAliasF2Z	:= GetNextAlias()
	Local cSelect	:= ''
	Local cWhere	:= ''
	Local cFrom		:= ""
	Local lF2ZALQ	:= F2Z->(FieldPos("F2Z_ALIQ")) > 0

	//Seção do select com os campos necessários
	cSelect :=	"F2Z.F2Z_INDAJU, F2Z.F2Z_VALAJU , F2Z.F2Z_CODAJU , F2Z.F2Z_NUM    , F2Z.F2Z_DESCR,"
	cSelect +=	"F2Z.F2Z_DTREF , F2Z.F2Z_CONTA  , F2Z.F2Z_CNPJ   , F2Z.F2Z_COMPL   , F2Z.F2Z_TRIB  ,F2Z.F2Z_CODCON "

	If lF2ZALQ
		cSelect +=	" ,F2Z.F2Z_ALIQ "
	EndIF

	//Seção do FROM e dos eventuais JOINS
	cFrom := RetSqlName("F2Z") + " F2Z "

	//Seção do Where da query
	cWhere	:= "F2Z.F2Z_FILIAL='"+xFilial("F2Z")+"' AND "
	cWhere	+= "F2Z.F2Z_DTREF>='"+DTOS(dDataDe)+"' AND "
	cWhere	+= "F2Z.F2Z_DTREF<='"+DTOS(dDataAte)+"' AND "
	cWhere	+= "F2Z.F2Z_ORIG IN ('1','3') AND "
	cWhere  += "F2Z.D_E_L_E_T_ = ' '"

	//Seção de Order By e eventual Group By
	cOrder	:= " ORDER BY F2Z.F2Z_DTREF, F2Z.F2Z_TRIB, F2Z.F2Z_INDAJU"

	// Preparação da query para execução do BeginSQL
	cSelect := "%" + cSelect + "%"
	cFrom   := "%" + cFrom   + "%"
	cWhere  := "%" + cWhere  + cOrder + "%"

	//Executa a query
	BeginSql Alias cAliasF2Z
		COLUMN F2Z_DTREF AS DATE
		SELECT
			%Exp:cSelect%
		FROM
			%Exp:cFrom%
		WHERE
			%Exp:cWhere%

	EndSql

	//Processamento do resultado da query.
	DbSelectArea (cAliasF2Z)
	(cAliasF2Z)->(DbGoTop ())
	Do While !(cAliasF2Z)->(Eof ())

		oAjustes:SetCrdDeb("2") //ajustes da base de débitos de PIS e COFINS
		
		//Definição do regime
		IF (cAliasF2Z)->F2Z_CODCON $ "01|02|03|04|71" //codigos não cumulativos
			oAjustes:SetRegime('1') //Não cumulativo
		Else
			oAjustes:SetRegime('2') //Cumulativo
		Endif

		oAjustes:SetTpAjust((cAliasF2Z)->F2Z_INDAJU) 
		oAjustes:SetVlAju((cAliasF2Z)->F2Z_VALAJU)
		oAjustes:SetCodAju((cAliasF2Z)->F2Z_CODAJU)
		oAjustes:SetNumDoc((cAliasF2Z)->F2Z_NUM)
		oAjustes:SetDescAju((cAliasF2Z)->F2Z_DESCR)
		oAjustes:SetDtRefer((cAliasF2Z)->F2Z_DTREF)
		oAjustes:SetConta((cAliasF2Z)->F2Z_CONTA)	
		oAjustes:SetCNPJ((cAliasF2Z)->F2Z_CNPJ)
		oAjustes:SetOrigem("A")//Origem de redução de base de cálculo
		oAjustes:SetInfComp((cAliasF2Z)->F2Z_COMPL)
		oAjustes:SetTributo((cAliasF2Z)->F2Z_TRIB)
		oAjustes:SetCodDC((cAliasF2Z)->F2Z_CODCON)
		
		//Se o campo de alíquota existir e estiver preenchido será enviado para a classe de ajustes
		If lF2ZALQ .AND. !Empty((cAliasF2Z)->F2Z_ALIQ)
			oAjustes:SetAlq((cAliasF2Z)->F2Z_ALIQ)
		EndIF 
		
		oAjustes:SetAjuBase(.T.)   
		oAjustes:SetAjuCKR(.T.)
		oAjustes:SetAjuF2Z(.T.)

		//Realiza o Ajuste
		oAjustes:Ajustar(,lF2ZALQ .AND. !Empty((cAliasF2Z)->F2Z_ALIQ))

		(cAliasF2Z)->(DbSkip ())			
	EndDo

	oAjustes:FechaAlias(cAliasF2Z)
 
Return

//-------------------------------------------------------------------
/*/
@description Função para tratar o valor o FT_VALICM para compor
@description no campo setiVaDesc - FT_DESCONT + FT_VALICM   
@description Com base na Regra do MV_DEDBPIS e DEDBCOF e A2_DEDBSPC
@author Bruce Mello
@since 01/11/2018
@version 12.17
/*/
//-------------------------------------------------------------------
Function DedPisCof(cDedbpis,cDedbcof,cEntSai,nValICMS,cDedbspc,cTipoNf,dEmissao, dMVICMDSDT, lDedIssBs)

	Local nValDesco	 := 0	
					// Opcoes do aNFCab[NF_DEDBSPC]:
					// 1 - Legado - Considera as regras dos parâmetros MV_DEDBPIS e MV_DEDBCOF.
					// 2 - Deduz ICMS e IPI.
					// 3 - Deduz Apenas ICMS.
					// 4 - Deduz Apenas IPI.
					// 5 - Não Deduz Nenhum.
					// 6 - Soma IP					
	DEFAULT dEmissao 	:= StoD("")
	DEFAULT dMVICMDSDT 	:= StoD("")
	DEFAULT lDedIssBS 	:= .F.

	If (cEntSai =='2' .And. (Empty(dEmissao) .Or. Iif(Empty(dMVICMDSDT), .T., dEmissao >= dMVICMDSDT))) .Or. (cEntSai =='1' .And. cTipoNf =='D')
		If (cDedbPis $ "S,I" .and. cDedbcof $ "S,I") 
			nValDesco := nValICMS
			if lDedIssBS .AND. cTipoNf == 'S' 
				nValDesco := 0			
			endif
		endif
	ElseIf cEntSai == '1' .or. (cEntSai =='2' .And. cTipoNf =='D' )
		If cDedbspc == '1' .and. (cDedbPis $ "S,I" .and. cDedbcof $ "S,I") 
			nValDesco := nValICMS
		Elseif cDedbspc $ ('23')
			nValDesco := nValICMS
		ElseIf cDedbspc $ ('456')
			nValDesco := 0
		Endif
	Endif

Return nValDesco

//-------------------------------------------------------------------
/*/{Protheus.doc} ICMSRecolher
Função que busca os valores da apuração de ICMS, retornando o valor do 
ICMS a recolher e o valor de Débito Especial

@author Erick G. Dias
@since 12/12/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Function ICMSRecolher(cLivro, dDataDe, dDataAte, cImp)

	Local nValIcms		:= 0
	Local aApICM		:= {}
	Local cMVEstado	 	:= GetNewPar("MV_ESTADO","")
	Local aParametros	:= {}
	Local cAliasCDH		:= "CDH"

	aAdd(aParametros,cImp)
	aAdd(aParametros,"3")
	aAdd(aParametros,"1")
	//aAdd(aParametros,DTOS(dDataDe))
	aAdd(aParametros,Dtos(FirstDate(dDataDe)))//DSERFIS1-15641 - tem que lançar nota no dia 20 e 3 threads configuradas retirada da variavel lmain, pois a função ICMSRecolher apesar de chamar o spedfiltro na CDH, nao passa data ate, so se baseia na data inicial trazendo todos os dados da apuração			
	aAdd(aParametros,cLivro)

	//Faço consulta na tabela CDH
	If SPEDFFiltro(1,"CDH",@cAliasCDH,aParametros)
		While !(cAliasCDH)->(Eof())
			
			If (cAliasCDH)->CDH_LINHA == "013"
				
				//Valor do ICMS
				nValIcms += (cAliasCDH)->CDH_VALOR
			
			ElseIf (cAliasCDH)->CDH_LINHA$"900" .And. Alltrim((cAliasCDH)->CDH_SUBITE)<>"900.00" .And. !Empty((cAliasCDH)->CDH_CODLAN)
				
				//Considera valores do débito especial
				If Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10 .OR.(SubStr((cAliasCDH)->CDH_CODLAN,3,1)=="0" .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)=="5")		
					nValIcms += (cAliasCDH)->CDH_VALOR
				EndIf

			EndIF

			(cAliasCDH)->(dbSkip())
		EndDo
		SPEDFFiltro(2,,cAliasCDH)
	EndIF

Return nValIcms

//-------------------------------------------------------------------
/*/{Protheus.doc} AjuBasICMS
Função para auxiliar a geração dos ajustes da base de cálculo, excluindo o 
valor do ICMS a recolher.

@author Erick G. Dias
@since 13//12/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function AjuBasICMS(oAjustes, cCredDeb, cReg, cTpAju, nVlAju, cCodAju, cNumDoc, cDesc, dDrRefer, cConta, cCnpj, cInfComp, cTrib, cCodCon, cCst)

	oAjustes:SetCrdDeb(cCredDeb)
	oAjustes:SetRegime(cReg)
	oAjustes:SetTpAjust(cTpAju)
	oAjustes:SetVlAju(nVlAju)
	oAjustes:SetCodAju(cCodAju)
	oAjustes:SetNumDoc(cNumDoc)
	oAjustes:SetDescAju(cDesc)
	oAjustes:SetDtRefer(dDrRefer)
	oAjustes:SetConta(cConta)
	oAjustes:SetCNPJ(cCnpj) 
	oAjustes:SetInfComp(cInfComp)
	oAjustes:SetTributo(cTrib)
	oAjustes:SetCst(cCst)
	oAjustes:SetCodDC(cCodCon)
	oAjustes:SetOrigem("A") //Origem de redução de base de cálculo
	oAjustes:SetAjuBase(.T.)
	oAjustes:Ajustar(.F.)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} Proc1050
Função que fará processamento das ifnormações do registro 1050.

@author Erick G. Dias
@since 14/12/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function Proc1050(a1050, cCst, nReducao, cCnpj, cRecibo, cInfCompl, nValICMS, cRegime)

	//Verifica se já existe informação do registro 1050
	nPos := aScan(a1050,{|x| x[2] == cCnpj .ANd. x[16] == cRecibo .AND. x[19] == cRegime  })

	IF nPos == 0
		//Adicionar informações no array
		aAdd(a1050, {})
		nPos := Len(a1050)
		aAdd (a1050[npos],"21")//Código de ajuste 4.3.18
		aAdd (a1050[npos],cCnpj)//CNPJ do estabelecimento
		aAdd (a1050[npos],nReducao)//Valor total do ajuste
		aAdd (a1050[npos],RetValAju('01', cCst, nReducao))//Parcela do CST 01
		aAdd (a1050[npos],RetValAju('02', cCst, nReducao))//Parcela do CST 02
		aAdd (a1050[npos],RetValAju('03', cCst, nReducao))//Parcela do CST 03
		aAdd (a1050[npos],RetValAju('04', cCst, nReducao))//Parcela do CST 04
		aAdd (a1050[npos],RetValAju('05', cCst, nReducao))//Parcela do CST 05
		aAdd (a1050[npos],RetValAju('06', cCst, nReducao))//Parcela do CST 06
		aAdd (a1050[npos],RetValAju('07', cCst, nReducao))//Parcela do CST 07
		aAdd (a1050[npos],RetValAju('08', cCst, nReducao))//Parcela do CST 08
		aAdd (a1050[npos],RetValAju('09', cCst, nReducao))//Parcela do CST 09
		aAdd (a1050[npos],RetValAju('49', cCst, nReducao))//Parcela do CST 49
		aAdd (a1050[npos],RetValAju('99', cCst, nReducao))//Parcela do CST 99
		aAdd (a1050[npos],"01")//Inddicador Apropriação				
		aAdd (a1050[npos],cRecibo)//Número do recibo do SPED Fiscal
		aAdd (a1050[npos],cInfCompl)//Informação Complementar
		aAdd (a1050[npos],nValICMS)//Valor do ICMS a recolher da filial
		aAdd (a1050[npos],cRegime)//Regime

	Else
		a1050[nPos][3] += nReducao //Total do Ajuste
		a1050[nPos][4] += RetValAju('01', cCst, nReducao) //CST 01
		a1050[nPos][5] += RetValAju('02', cCst, nReducao) //CST 02
		a1050[nPos][6] += RetValAju('03', cCst, nReducao) //CST 03
		a1050[nPos][7] += RetValAju('04', cCst, nReducao) //CST 04
		a1050[nPos][8] += RetValAju('05', cCst, nReducao) //CST 05
		a1050[nPos][9] += RetValAju('06', cCst, nReducao) //CST 06
		a1050[nPos][10] += RetValAju('07', cCst, nReducao) //CST 07
		a1050[nPos][11] += RetValAju('08', cCst, nReducao) //CST 08
		a1050[nPos][12] += RetValAju('09', cCst, nReducao) //CST 09
		a1050[nPos][13] += RetValAju('49', cCst, nReducao) //CST 49
		a1050[nPos][14] += RetValAju('99', cCst, nReducao) //CST 99	

	EndIF	

Return

//--------------------------------------------------
/*/{Protheus.doc} RetValAju
Função que retorna o valor de ajuste conforme o CST.

@author Erick G. Dias
@since 14/12/2018
@version 12.1.17
/*/
//--------------------------------------------------
Static Function RetValAju(cCstCmp, cCstAju, nValAju)

	Local nVlrReten:= 0

	IF cCstCmp == cCstAju
		nVlrReten	:= nValAju
	EndIF

Return nVlrReten

//--------------------------------------------------
/*/{Protheus.doc} GetRecibo
Função que buscará o número do recibo de transmissão 
do SPED Fiscal.

@author Erick G. Dias
@since 14/12/2018
@version 12.1.17
/*/
//--------------------------------------------------
Static Function GetRecibo(dDataIni)

	Local cRecibo	:= ""

	If AliasIndic("F3N") .And. F3N->(MsSeek( xFilial("F3N") + Year2Str(dDataIni) + Month2Str(dDataIni)))
		cRecibo	:= F3N->F3N_RECIBO
	EndIF

Return cRecibo

//--------------------------------------------------
/*/{Protheus.doc} GetProcICMS
Função que busca o número de processo da exclusão do ICMS
da base de cálculo de PIS e COFINS

@author Erick G. Dias
@since 20/12/2018
@version 12.1.17
/*/
//--------------------------------------------------
Static Function GetProcICMS()

	Local cNProcICMS	:= ''
	Local aProcICMS		:= StrTokArr2(GetNewPar("MV_PRICMS",''), "|" ,.T.)

	If Len(aProcICMS) >= 4
		cNProcICMS	:= aProcICMS[1]
	EndIF

Return cNProcICMS

//--------------------------------------------------
/*/{Protheus.doc} AjuAltRegCx
Função que fará as chamadas de ajuste da contribuição na 
hipótese de alteração de regime de competência para regime de
caixa.

@author Erick G. Dias
@since 21/12/2018
@version 12.1.17
/*/
//--------------------------------------------------
Static Function AjuAltRegCx(aAjuPISCOF, aXFilial, dDataDe, DEBITO)

	Local oAjuDeb	:= Nil
	Local nX		:= 0

	// Se houverem ajustes p/ gerar - mudança de regime -
	If Len(aAjuPISCOF) > 0

		oAjuDeb	:= AJUSTEEFD():New()
		oAjuDeb:SetFilial(aXFilial)
		oAjuDeb:SetDtIni(dDataDe)
		oAjuDeb:SetCrdDeb(DEBITO)
		oAjuDeb:LoadCKS()

		For nX := 1 to Len(aAjuPISCOF)
			oAjuDeb:SetTributo(aAjuPISCOF[nX, 1])
			oAjuDeb:SetTpAjust(aAjuPISCOF[nX, 2])
			oAjuDeb:SetCodAju(aAjuPISCOF[nX, 3])
			oAjuDeb:SetNumDoc(aAjuPISCOF[nX, 4])
			oAjuDeb:SetDescAju(aAjuPISCOF[nX, 5])
			oAjuDeb:SetDtRefer(aAjuPISCOF[nX, 6])
			oAjuDeb:SetCodDC(aAjuPISCOF[nX, 7])
			oAjuDeb:SetRegime(aAjuPISCOF[nX, 8])
			oAjuDeb:SetOrigem(aAjuPISCOF[nX, 9])
			oAjuDeb:SetVlAju(Round(aAjuPISCOF[nX, 10], 2))
			oAjuDeb:SetCst(aAjuPISCOF[nX, 11])
			oAjuDeb:SetConta(aAjuPISCOF[nX, 12])
			oAjuDeb:SetInfComp(aAjuPISCOF[nX, 13])
			oAjuDeb:SetBase(aAjuPISCOF[nX, 14])
			oAjuDeb:SetAlq(aAjuPISCOF[nX, 15])
			oAjuDeb:SetTNatRec(aAjuPISCOF[nX, 16])
			oAjuDeb:SetCNatRec(aAjuPISCOF[nX, 17])
			oAjuDeb:Ajustar()
		Next nX

	EndIf

Return

//--------------------------------------------------
/*/{Protheus.doc} EstCrdAgro
Função que buscará as informações das tabelas F3U e F3V 
para realizar os estornos de créditos, referente ao benefício
da agro indústria.

@author Erick G. Dias
@since 06/02/2019
@version 12.1.17
/*/
//--------------------------------------------------
Static Function EstCrdAgro(cPerApu, oAjustes, dDtRef)

	Local aVlrCL8 		:= {}
	Local aEstCrd		:= {}
	Local nX			:= 0
	Local nPos			:= 0
	Local nValAjuste	:= 0
	Local nPercDet		:= 0
	Local cDescHP		:= ""
	Local cCodCta		:= ""
	Local cCodAju		:= ""

	//Busca os percentuais dos estornos calculados no período
	cAliasF3V	:= QryEstCred("F3V", cPerApu)

	//Somente prosseguirá se houver algum percentual de estorno para este período
	IF !(cAliasF3V)->(Eof())	

		//Carrega os valores dos créditos processados no período
		aVlrCL8 := oAjustes:GetVlrCL8()		

		//Laço dos valores de créditos calculados no período
		For nX:= 1 to Len(aVlrCL8)
			//Busca o código de crédito + COD BCC na tabela F3U	
			If F3U->(MsSeek( xFilial("F3U") + aVlrCL8[nX][2] + aVlrCL8[nX][8] ))		
				
				//Monto no array aEstCrd os valores de créditos passíveis de estorno por código de crédito e tributo
				nPos:= aScan(aEstCrd,{|x| x[1] == aVlrCL8[nX][1] .AND. x[2] == aVlrCL8[nX][2] })
				
				//Aqui estou acumulando os valores de créditos do período que são passíveis de estorno, por códgo de crédito, para ser utilizado posteriormente no ajustes
				IF nPos > 0
					aEstCrd[npos][3] += aVlrCL8[nX][4]
				Else
					aAdd(aEstCrd,{})
					nPos := Len(aEstCrd)
					aAdd(aEstCrd[npos], aVlrCL8[nX][1])
					aAdd(aEstCrd[npos], aVlrCL8[nX][2])
					aAdd(aEstCrd[npos], aVlrCL8[nX][4])
					aAdd(aEstCrd[npos], 0)
				EndIF

			EndIF

		Next nx

		//Aqui estou atualizando o valor que deverá ser ajustado, aplicando o percentual total do ajuste
		For nX	:= 1 to Len(aEstCrd)
			aEstCrd[nX][3] :=  Round(aEstCrd[nX][3] * (cAliasF3V)->F3V_PEREST  / 100, 2)
			aEstCrd[nX][4] :=  aEstCrd[nX][3] //Esta posição será utilizada como "saldo", para evitar problema de arredondamento.
		Next nX
		
		//Faz laço nos percentuais para disparar os valores de ajustes de redução do crédito de PIS e COFINS
		Do While !(cAliasF3V)->(Eof())		
			
			//Informações da F3V que serão utilizadas para realizar ajuste.
			cDescHP		:= (cAliasF3V)->F3V_DESCHP
			nPercDet	:= (cAliasF3V)->F3V_PERDET
			cCodCta		:= (cAliasF3V)->F3V_CODCTA
			cCodAju		:= (cAliasF3V)->F3V_CODAJU
			
			(cAliasF3V)->(DbSkip())
			
			//Laço nos créditos que foram acumulados por código de crédito
			For nX:= 1 to Len(aEstCrd)
				
				nValAjuste	:= 0
				If (cAliasF3V)->(Eof())
					//Se for o último percentual de detalhamento, então o ajuste será o valor restante no saldo do array , para evitar problema de arredondamento
					nValAjuste	:= aEstCrd[nX][4]
				Else
					//O valor do ajuste será calculado com percentual do detalhamento
					nValAjuste	:= Round(aEstCrd[nX][3] * nPercDet / 100, 2)
					
					//Atualiza controle para evitar eventual erro de arredondamento
					aEstCrd[nX][4] -= nValAjuste
				EndIF			

				//Chama função auxiliar para geração dos ajustes
				AjustePC(oAjustes, CREDITO, aEstCrd[nX][1], REDUCAO, cCodAju, "", cDescHP, nValAjuste, aEstCrd[nX][2], "", cCodCta, "", 0, 0, dDtRef)

			Next nX
			
		EndDo
		
	EndIF

	(cAliasF3V)->(dbCloseArea())

Return

//--------------------------------------------------
/*/{Protheus.doc} QryEstCred
Função que terá as queries para processar os valores de 
estornos da agro indústria

@author Erick G. Dias
@since 06/02/2019
@version 12.1.17
/*/
//--------------------------------------------------
Static Function QryEstCred(cTab, cPerApu)

	Local cAliasRet	:= GetNextAlias()
	Local cSelect	:= ""

	IF cTab == "F3V"	
		//Tabela com os percentuais de estorno do período	
		cSelect :=	"F3V.F3V_PEREST, F3V.F3V_DESCHP, F3V.F3V_PERDET, F3V.F3V_CODCTA, F3V.F3V_CODAJU"
		
		cFrom := RetSqlName("F3V") + " F3V "

		//Seção do Where da query
		cWhere	:= "F3V.F3V_FILIAL=" + valToSql(xFilial("F3V")) + " AND "
		cWhere  += "F3V.F3V_PERAPU = " + valToSql(cPerApu) + " AND "
		cWhere  += "F3V.D_E_L_E_T_ = ' '"

		//Seção de Order By e eventual Group By
		cOrder	:= " ORDER BY F3V_DESCHP"

		// Preparação da query para execução do BeginSQL
		cSelect := "%" + cSelect + "%"
		cFrom   := "%" + cFrom   + "%"
		cWhere  := "%" + cWhere  + cOrder + "%"	

	EndIF

	//Executa a query
	BeginSql Alias cAliasRet	
		SELECT
			%Exp:cSelect%
		FROM
			%Exp:cFrom%
		WHERE
			%Exp:cWhere%
	EndSql

Return cAliasRet

//--------------------------------------------------
/*/{Protheus.doc} AjustePC
Função auxiliar para realizar os ajustes de PIS e COFINS

@author Erick G. Dias
@since 06/02/2019
@version 12.1.17
/*/
//--------------------------------------------------
Static Function AjustePC(oAjustes, cCrdDeb, cTrib, cTpAju, cCodAju, cNumDoc, cDescAju, nValAju, cCodDC, cCST, cConta, cInfComp, nBase, nAlq, dDtRef)

	oAjustes:SetCrdDeb(cCrdDeb)
	oAjustes:SetTributo(cTrib)
	oAjustes:SetTpAjust(cTpAju)
	oAjustes:SetCodAju(cCodAju)
	oAjustes:SetNumDoc(cNumDoc)
	oAjustes:SetDescAju(cDescAju)
	oAjustes:SetVlAju(nValAju)
	oAjustes:SetCodDC(cCodDC)			
	oAjustes:SetCst(cCST)
	oAjustes:SetConta(cConta)
	oAjustes:SetInfComp(cInfComp)
	oAjustes:SetBase(nBase)
	oAjustes:SetAlq(nAlq)
	oAjustes:SetDtRefer(dDtRef)		
	oAjustes:Ajustar()

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} SldCredDif()
Função retorna o valor do crédito diferido usado até o momento. cOpc = 1
       retorna o valor recebido até o momento do que foi diferido cOpc =2
@author ricardo.cavalcante
@since 12/09/2019
@version 12.1.25
/*/
//-------------------------------------------------------------------
Static Function SldCredDif(cPerApur,cPerDif,cTipo,cCNPJ,cNatCred)

	Local cFiltro	:= ''
	Local cSelect	:= ''
	Local aRetDif	:= {0,0}	
	Local dData     := CtoD("01/"+SUBSTR(cPerApur,1,2)+"/"+ SUBSTR(cPerApur,3,4))-1
	Local dDtDifde	:= CtoD("01/"+SUBSTR(cPerDif,1,2)+"/"+ SUBSTR(cPerApur,3,4))
	Local dDtDifAte := MonthSum(CtoD("01/"+SUBSTR(cPerDif,1,2)+"/"+ SUBSTR(cPerApur,3,4)),1)-1
	Local cQuery	:= GetNextAlias()

	If cTipo == 'C'
		cSelect	:= " SUM(F0T.F0T_VLCPRB) VLCRED ,"
	Else
		cSelect	:= " SUM(F0T.F0T_VALPIS) VLCRED ," //PARA O F0T.F0T_TIPO  A CRÉDITO DIFERIDO PIS E B CRÉDITO DIFERIDO COFINS O CAMPO F0T.F0T_VALPIS É O VALOR DE CRÉDITO DIFERIDO, E O CAMPO F0T.F0T_VALCOFINS É O PERCENTUAL QUE ESSE CRÉDITO REPRESENTA DA TABELA CFA, POR ESSE MOTIVO USA SEMPRE O CAMPO F0T.F0T_VALPIS NÃO LEVAR EM CNTA O NOME DO CAMPO.
	EndIf
	cSelect	+= " SUM(SF2.F2_VALBRUT * (F0T.F0T_PERREC / 100))  VLRECEB" // RETORNA O VALOR RECEBIDO ATÉ O MOMENTO DOS TITULOS DIFERIDOS

	cFrom   := RetSqlName("F0T") + " F0T "

	cInner	:= RetSqlName("SA1") + " SA1 ON(SA1.A1_FILIAL = '" + xFilial("SA1") + "' AND F0T.F0T_CNPJ = SA1.A1_CGC AND SA1.D_E_L_E_T_ = ' '  )"

	cInner2	:= RetSqlName("SF2") + " SF2 ON(SF2.F2_FILIAL = '" + xFilial("SF2") + "' AND SA1.A1_COD = SF2.F2_CLIENTE AND SA1.A1_LOJA = SF2.F2_LOJA AND" +;
			" F0T.F0T_NUMNF = SF2.F2_DOC AND F0T.F0T_SER = SF2.F2_SERIE AND SF2.F2_EMISSAO >= '" + %Exp:DToS (dDtDifde)% + "' AND SF2.F2_EMISSAO <= '" +;
			%Exp:DToS (dDtDifate)% + "' AND SF2.D_E_L_E_T_ = ' ') "

	cSelect	:= "%" + cSelect 	+ "%"
	cFrom	:= "%" + cFrom		+ "%"
	cInner	:= "%" + cInner		+ "%"
	cInner2	:= "%" + cInner2	+ "%"

	cFiltro = "%"
	cFiltro += "F0T.F0T_CNPJ			=   '"	+ cCNPJ    					+ "' AND "
	cFiltro += "F0T.F0T_FILIAL			=   '"	+ xFilial('F0T')			+ "' AND "
	cFiltro += "F0T.F0T_PER				>=  	  SF2.F2_EMISSAO 			     AND "
	cFiltro += "F0T.F0T_PER				<=  '" 	+ %Exp:DToS (dData)%	+     "' AND "	
	cFiltro += "F0T.F0T_TIPO 			=   '"	+ cTipo						+ "' AND "
	cFiltro += "F0T.F0T_MODELO 			=   '"	+ cNatCred					+ "' AND "
	cFiltro += "F0T.D_E_L_E_T_			= ' '"
	cFiltro += "%"

	BeginSql Alias cQuery
		SELECT			    	 
			%Exp:cSelect%	
		
		FROM   
			%Exp:cFrom%
		
		INNER JOIN
			%Exp:cInner%

		INNER JOIN
			%Exp:cInner2% 
							
		WHERE
			%Exp:cFiltro%	
		
	EndSql

	aRetDif := Iif(!(cQuery)->(Eof()),{(cQuery)->VLCRED,(cQuery)->VLRECEB},{0,0})

	( cQuery )->( dbCloseArea () )

Return aRetDif

//-------------------------------------------------------------------
/*/{Protheus.doc} CPRBxCNO()
Função que executa a query para retornar os valores da apuração de 
CPRB quebrados por CNO
@author Matheus Prada
@since 04/10/2019
@version 12.1.25
/*/
//-------------------------------------------------------------------
Static Function CPRBxCNO(cAliasSON, oApurEFD)

	Local cSelect	:= ""
	Local cFrom		:= ""
	Local cWhere	:= ""
	Local cGroupBy	:= ""
	Local nM996Tpr	:= SuperGetMv("MV_M996TPR",.F.,1)  
	Local lCNO		:= .T.

	Default cAliasSON := ""

	cSelect	:= oApurEFD:GetCmpSFT(nM996Tpr, , , lCNO)

	cFrom	:= oApurEFD:GetJoinFrm(nM996Tpr, , , lCNO)

	cWhere  := oApurEFD:GetWhrSFT(NFSAIDA)

	cGroupBy	:= oApurEFD:GetGrpSFT(nM996Tpr, lCNO)

	cWhere := '%' + cWhere + '%'
	cGroupBy := '%' + cGroupBy + '%'

	BeginSql Alias cAliasSON
		COLUMN FT_DTFIMNT AS DATE
		SELECT
			%Exp:cSelect%

		FROM
			%Exp:cFrom%

		WHERE
			%Exp:cWhere%
			SFT.%NotDel%

		%Exp:cGroupBy%

	EndSql

	DbSelectArea (cAliasSON) 
	(cAliasSON)->(DbGoTop ())

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} ExigibSusp()

Função que buscará as notas fiscais que possuem processo referenciado no
complemento da nota fiscal, com exigibilidade suspensa, e para os tributos
de PIS e COFINS.

@author Erick G Dias
@since 22/10/2019
@version 12.1.25
/*/
//-------------------------------------------------------------------
Static Function ExigibSusp(oApurEFD, nM996Tpr,dDataDe, dDataAte, cOpc,lBilhete,cNrLivro)

	Local cFrom			:= ""
	Local cSlctSFT		:= ""
	Local cFiltro		:= ""
	Local cAliasSFT		:= GetNextAlias()
	Local lPeWhere  	:= ExistBlock("EFDCON01")
	Local aExigiSusp 	:= {}

	Private oHExigSusp	:= HMNew() //Cria o Hash para apoio ao array aExigiSusp

	Default lBilhete 	:= .F.
	Default cNrLivro	:= ""

	If cOpc == "NF"
		cFrom    := oApurEFD:GetJoinFrm(nM996Tpr,lPeWhere,NFSAIDA,, .T.)
		cSlctSFT := oApurEFD:GetCmpSFT(nM996Tpr,.F.,lPeWhere, ,.T.)
		cFiltro  := oApurEFD:GetWhrSFT(NFSAIDA,,,,, .T.)
		cFiltro  := '%' + cFiltro + '%'

		BeginSql Alias cAliasSFT	
			COLUMN FT_EMISSAO AS DATE	
			SELECT
				%Exp:cSlctSFT%

			FROM
				%Exp:cFrom%

			WHERE
				%Exp:cFiltro%
				SFT.%NotDel%	

		EndSql
	ElseIf cOpc = "CUPOM"	//Cupom 
		
		cAliasSFT	:= FSA001QECF(.F.,cNrLivro,dDataDe,dDataAte,lBilhete, .T.)

	EndIF

	//Processando notas que possuem processo referenciado com exigibilidade suspensa sem transito em julgado.
	(cAliasSFT)->(DbGoTop ())
	Do While !(cAliasSFT)->(Eof ())		
		If !Empty((cAliasSFT)->CID_CST) .AND. !Empty((cAliasSFT)->CCF_TRIB) .AND. ( cOpc = "CUPOM" .OR. oApurEFD:ChkRegraNf((cAliasSFT)->FT_ESPECIE,(cAliasSFT)->FT_CFOP,NFSAIDA,,,(cAliasSFT)->FT_CSTPIS) )

			//Processo informações das regras informadas na tabela CDI		
			ProcExigi(@aExigiSusp, cAliasSFT, cAliasSFT, cAliasSFT, dDataDe, dDataAte, 1, "",.F.,.T.)

		EndiF

		(cAliasSFT)->(DbSkip ())			
	EndDo

	DbSelectArea( cAliasSFT )
	( cAliasSFT )->( dbCloseArea () )

	//Função para gravação da tabewla CIE
	If Len(aExigiSusp) > 0
		x001GrvCIE(aExigiSusp, dDataDe)
		aSize(aExigiSusp,0) //Limpo o array que não era limpo
		aExigiSusp:=Nil
	EndIf

	// Limpa os dados do HashMap
	HMClean(oHExigSusp)
	// Libera o objeto de HashMap
	FreeObj(oHExigSusp)
	oHExigSusp := Nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} AddExigSusp()

Função que trata os valores de cabeçalho do registro 1011

@author Erick G Dias
@since 22/10/2019
@version 12.1.25
/*/
//-------------------------------------------------------------------
Static Function AddExigSusp(aExigiSusp, cAliasSFT, cAliasCCF, cCstSusp, nBaseSusp, nAliqSusp, nValSusp, cTrib, cCodRec, nPerc, cChaveCL1)

	Local cKey		:= (cAliasSFT)->FT_NFISCAL+(cAliasSFT)->FT_SERIE+(cAliasSFT)->FT_CLIEFOR+(cAliasSFT)->FT_LOJA+;
								(cAliasSFT)->FT_ITEM+(cAliasCCF)->CCF_NUMERO+(cAliasCCF)->CCF_TIPO+(cAliasCCF)->CCF_INDAUT+;
								(cAliasCCF)->CCF_IDITEM+(cAliasCCF)->CCF_NATJU
	Local nPosCab	:= 0
	Local lRet	:=.F.							
	//Verifica se a combinação abaixo já existe no array/hash
	lRet := HMGet(oHExigSusp, cKey, @nPosCab)
									
	If !lRet
		aAdd(aExigiSusp, {})
		nPosCab := Len(aExigiSusp)
		HMSet(oHExigSusp, cKey, nPosCab) //adiciono a chave e a posição 

		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_NFISCAL)	//01
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_SERIE)  
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_CLIEFOR)
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_LOJA)	
		aAdd(aExigiSusp[nPosCab], (cAliasCCF)->CCF_NUMERO)	//05
		aAdd(aExigiSusp[nPosCab], (cAliasCCF)->CCF_TIPO)		
		aAdd(aExigiSusp[nPosCab], (cAliasCCF)->CCF_NATJU)	
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_ITEM)		
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_EMISSAO)	
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_VALCONT * iif(empty(nPerc),1,nPerc))	//10
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_CSTPIS)
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_BASEPIS * nPerc)
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_ALIQPIS)
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_VALPIS * nPerc)	
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_CSTCOF)	//15
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_BASECOF * nPerc)
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_ALIQCOF)
		aAdd(aExigiSusp[nPosCab], (cAliasSFT)->FT_VALCOF * nPerc)
		aAdd(aExigiSusp[nPosCab], cCstSusp)
		aAdd(aExigiSusp[nPosCab], 0)	//20
		aAdd(aExigiSusp[nPosCab], 0)
		aAdd(aExigiSusp[nPosCab], 0)	
		aAdd(aExigiSusp[nPosCab], cCstSusp)	                      
		aAdd(aExigiSusp[nPosCab], 0)	
		aAdd(aExigiSusp[nPosCab], 0)	//25
		aAdd(aExigiSusp[nPosCab], 0)		
		aAdd(aExigiSusp[nPosCab], "")		
		aAdd(aExigiSusp[nPosCab], "")		
		aAdd(aExigiSusp[nPosCab], (cAliasCCF)->CCF_IDITEM)		
		aAdd(aExigiSusp[nPosCab], cChaveCL1)	//30
		aAdd(aExigiSusp[nPosCab], (cAliasCCF)->CCF_INDAUT)

	EndiF

	If cTrib == "PIS"
		//Atualizo os valores da exigibilidade suspenso
		aExigiSusp[nPosCab][20] += nBaseSusp
		aExigiSusp[nPosCab][21] := nAliqSusp
		aExigiSusp[nPosCab][22] += nValSusp
		aExigiSusp[nPosCab][27] := cCodRec
	ElseIf cTrib == "COFINS"
		//Atualizo os valores da exigibilidade suspenso
		aExigiSusp[nPosCab][24] += nBaseSusp
		aExigiSusp[nPosCab][25] := nAliqSusp
		aExigiSusp[nPosCab][26] += nValSusp
		aExigiSusp[nPosCab][28] := cCodRec
	EndIF

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} QryCDGCaixa()

Função que realiza que buscará os processos referenciados informados na CDG 
no complemento do documento fiscal por item, bem como informações da tabela CID 
para exigibilidade suspensa

@author Erick G Dias
@since 29/10/2019
@version 12.1.25
/*/
//-------------------------------------------------------------------
Static Function QryCDGCaixa(aPar, lTabCID)

	Local cSelect		:= ""
	Local cFrom			:= ""
	Local cWhere		:= ""
	Local ApeF500		:= {}
	Local cAliasCDG		:= GetNextAlias()

	cSelect	:=	"%CDG.CDG_FILIAL,CDG.CDG_TPMOV,CDG.CDG_DOC,CDG.CDG_SERIE,CDG.CDG_CLIFOR,CDG.CDG_LOJA,CDG.CDG_PROCES,CDG.CDG_TPPROC,CDG.CDG_IFCOMP,CDG.CDG_PROCES,CDG.CDG_TPPROC,"
	cSelect +=  "CCF.CCF_NUMERO, CCF.CCF_IDSEJU,CCF.CCF_IDVARA, CCF.CCF_NATJU,CCF.CCF_DESCJU, CCF.CCF_DTSENT,CCF.CCF_NATAC, CCF.CCF_DTADM,CCF.CCF_TPCOMP, CCF.CCF_TRIB, CCF.CCF_TIPO, CCF.CCF_IDITEM, CCF.CCF_INDAUT"

	If lTabCID
		//Adiciona os campos da tabela CID
		cSelect +=  ",CID.CID_CST, CID.CID_ICMS, CID.CID_ISS, CID.CID_REDUC, CID.CID_ALIQ, CID.CID_CODREC"
	EndIf

	cSelect += "%"

	cFrom	:=	""+RetSqlName("CDG")+" CDG "
	cFrom	+=	"INNER JOIN "+RetSqlName("CCF")+" CCF ON CCF.CCF_FILIAL='"+xFilial("CCF")+"' AND CDG.CDG_PROCES=CCF.CCF_NUMERO AND CDG.CDG_TPPROC=CCF.CCF_TIPO AND CCF.CCF_IDITEM=CDG.CDG_ITPROC AND CCF.D_E_L_E_T_=' '"

	If lTabCID
		//Adiciona left join com tabela CID
		cFrom	   +="LEFT JOIN "+RetSqlName("CID")+" CID ON(CID.CID_FILIAL='"+xFilial("CID")+"'  AND CID.CID_NUMERO=CCF.CCF_NUMERO  AND CID.CID_TIPO=CCF.CCF_TIPO AND CID.CID_INDAUT=CCF.CCF_INDAUT AND CID.CID_IDITEM = CCF.CCF_IDITEM AND CID.D_E_L_E_T_=' ') "	
	EndIF


	cWhere	:=	"CDG.CDG_FILIAL='"+xFilial("CDG")+"' AND "
	cWhere	+=	"CDG.CDG_TPMOV   ='"+aPar[1]+"' AND "
	cWhere	+=	"CDG.CDG_DOC     ='"+aPar[2]+"' AND "
	cWhere	+=	"CDG.CDG_SERIE   ='"+aPar[3]+"' AND "
	cWhere	+=	"CDG.CDG_CLIFOR  ='"+aPar[4]+"' AND "
	cWhere	+=	"CDG.CDG_LOJA    ='"+aPar[5]+"' AND "
	cWhere	+=	"CDG.CDG_ITEM    ='"+aPar[6]+"' AND "
	cWhere	+=	"CDG.D_E_L_E_T_=' '"

	If ExistBlock("SPDF500C")  // PE para SCP com Filial unica - TTUXH9
		ApeF500 := ExecBlock("SPDF500C", .F. , .F. , {cFrom,cWhere})
		cFrom 	:= ApeF500[1]
		cWhere	:= ApeF500[2]
	Endif

	cFrom 	:= "%"+cFrom+"%"
	cWhere	:= "%"+cWhere+"%"

	BeginSql Alias cAliasCDG    	    
		SELECT			    	 
			%Exp:cSelect%		
		FROM 
			%Exp:cFrom%
		WHERE
			%Exp:cWhere%		
	EndSql

Return cAliasCDG

//-------------------------------------------------------------------
/*/{Protheus.doc} ProcExigi()

Função que fará o processamento dos valores da Exigibilidade suspensa, interpretando as regras
definidas na tabela CID, conforme determinação do processo judicial

@author Erick G Dias
@since 30/10/2019
@version 12.1.25
/*/
//-------------------------------------------------------------------
Static Function ProcExigi(aExigiSusp, cAliasCID, cAliasCCF, cAliasSFT, dDataDe, dDataAte, nPercCaixa, cChaveCL1, lCaixa, lExigSusp)

	Local cCstSusp		:= ""
	Local cCstOri		:= ""
	Local cTrib			:= ""
	Local nBCSusp		:= 0
	Local nAliqSusp		:= 0
	Local nValorSusp	:= 0
	Local nPercDev 		:= 1
	Local nPercExig		:= 1

	Default nPercCaixa	:= 1
	Default cChaveCL1	:= ""
	Default lCaixa		:= .F.
	Default lExigSusp	:= .F.

	cTrib		:= Iif((cAliasCCF)->CCF_TRIB == "7","PIS","COFINS")
	cCstSusp    := (cAliasCID)->CID_CST
	cCstOri		:= Iif(cTrib == "PIS",(cAliasSFT)->FT_CSTPIS,(cAliasSFT)->FT_CSTCOF)
	nBCSusp		:= Iif(cTrib == "PIS",(cAliasSFT)->FT_BASEPIS,(cAliasSFT)->FT_BASECOF)
	nAliqSusp	:= Iif(cTrib == "PIS",(cAliasSFT)->FT_ALIQPIS,(cAliasSFT)->FT_ALIQCOF)
	nValorSusp	:= Iif(cTrib == "PIS",(cAliasSFT)->FT_VALPIS,(cAliasSFT)->FT_VALCOF)

	If !lCaixa
		//Verifica se a nota foi devolvida dentro do período
		if !lExigSusp .or. (lExigSusp .and. (cAliasSFT)->FTTEMDEV == "D") //quando for Exigibilidade suspensa, o alias ja terá se aquela nota possui devoluções para entrar
			nPercDev -= FindDev({(cAliasSFT)->FT_NFISCAL, ;
									(cAliasSFT)->FT_SERIE, ;
									(cAliasSFT)->FT_CLIEFOR, ;
									(cAliasSFT)->FT_LOJA, ;
									(cAliasSFT)->FT_ITEM, ;
									(cAliasSFT)->FT_QUANT, ;
									dDataDe, ;
									dDataAte })
		endif
		nPercExig	:= nPercDev

		//Deduzo o valor da devolução na base e valor
		nBCSusp 	*= nPercDev
		nValorSusp  *= nPercDev
	EndIF

	If !Empty(cCstSusp)

		//Alíquota zero, valor zero e mesma base de cálculo, aqui a exigibilidade é integral				
		//Aqui foi suspenso integralmente, terá base, alíquota e valor zerado, uma vez que a exigibilidade também é integral
		//Para os CSTs 04/05/06/07/08/09/49, por se tratar de suspensão integral não farei nenhum cálculo.			
		If cCstSusp $ "01/02" .AND. cCstOri <> "03" //Aqui como possui CST tributado, significa que a exigibilidade é parcial. Não se aplica para operações com Pauta, já que a base é em quantidade e não daria para reduzir base ou mesmo subtrair o ICMS/ISS
			//Subtrair ICMS/ da base de cálculo
			If (cAliasCID)->CID_ICMS == "2" .AND. (cAliasSFT)->FT_TIPO <> "S"
				nBCSusp -= ( (cAliasSFT)->FT_VALICM * nPercDev )
			Endif

			//Subtrair ISS da base de cálculo
			If (cAliasCID)->CID_ISS == "2" .AND. (cAliasSFT)->FT_TIPO == "S"
				nBCSusp -= ( (cAliasSFT)->FT_VALICM * nPercDev )
			Endif

			// Percentual de redução de base de cálculo
			If (cAliasCID)->CID_REDUC > 0
				nBCSusp *= (1 - ((cAliasCID)->CID_REDUC/100))
			EndIf

			//Alíquota será informada no cadastro. Somente considera da cadastro se estiver preenchida.
			If (cAliasCID)->CID_ALIQ > 0
				nAliqSusp	:= (cAliasCID)->CID_ALIQ
			EndIF

			//Cálculo do valor da exigibilidade suspensa
			nValorSusp	:= Round(nBCSusp * nAliqSusp / 100,2)

		EndIf

		//Aqui aplica percentual de baixa caso seja processo no regime de caixa
		If lCaixa
			nPercExig	:= nPercCaixa 
			nBCSusp     *= nPercCaixa 
			nValorSusp  *= nPercCaixa 	
		EndIF

		//Adiciona valores calculados da exigibilidade suspensa
		AddExigSusp(@aExigiSusp, cAliasSFT, cAliasCCF, cCstSusp, nBCSusp, nAliqSusp, nValorSusp, cTrib, (cAliasCID)->CID_CODREC, nPercExig, cChaveCL1)
	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} FindDev()

Função que verifica se a nota foi devolvida dentro do período, e retorna
o percentual de devolução.

@author Erick G Dias
@since 31/10/2019
@version 12.1.25
/*/
//-------------------------------------------------------------------
Static Function FindDev(aPar )

	Local nPerc			:= 0
	Local cSelect		:= ""
	Local cFrom			:= ""
	Local cWhere		:= ""
	Local cAliasSFT		:= GetNextAlias()

	cSelect	:=	"%SUM(SFT.FT_QUANT) FT_QUANT%"
	cFrom	:=	""+RetSqlName("SFT")+" SFT "

	cWhere	:=	"SFT.FT_FILIAL		= '"+xFilial("SFT")+"' AND "
	cWhere	+=	"SFT.FT_NFORI   	='"+aPar[1]+"'         AND "
	cWhere	+=	"SFT.FT_SERORI  	='"+aPar[2]+"'         AND "
	cWhere	+=	"SFT.FT_CLIEFOR     ='"+aPar[3]+"'         AND "
	cWhere	+=	"SFT.FT_LOJA     	='"+aPar[4]+"'         AND "
	cWhere	+=	"SFT.FT_ITEMORI   	='"+aPar[5]+"'         AND "
	cWhere	+=	"SFT.FT_ENTRADA     >='"+DTOS(aPar[7])+"'  AND "
	cWhere	+=	"SFT.FT_ENTRADA     <='"+DTOS(aPar[8])+"'  AND "
	cWhere	+=	"SFT.FT_DTCANC      =' '                   AND "
	cWhere	+=	"SFT.FT_TIPO        ='D'                   AND "
	cWhere	+=	"SFT.D_E_L_E_T_		=' '"

	cFrom 	:= "%"+cFrom+"%"
	cWhere	:= "%"+cWhere+"%"

	BeginSql Alias cAliasSFT    	    
		SELECT			    	 
			%Exp:cSelect%		
		FROM 
			%Exp:cFrom%
		WHERE
			%Exp:cWhere%		
	EndSql

	If !(cAliasSFT)->(Eof ())
		//Obtenho o percentual de devolução através da quantidade da nota original e da nota de devolução
		nPerc := ( ( (cAliasSFT)->FT_QUANT * 100 ) / aPar[6] ) / 100
	EndIF

	DbSelectArea( cAliasSFT )
	( cAliasSFT )->( dbCloseArea () )

Return nPerc


//-------------------------------------------------------------------
/*/{Protheus.doc} A001DifCPB()
Função que irá buscar valores de diferimento dos débitos para serem processados
na apuração

@param		dDataDe	-Data inicial do período de apuração
			dDataAte	-Data final do período de apuração
			aXFilial	-Array com conteúdo do xFilial das tabelas da apuração			

@author Thiago Y.M.N - Shiny
@since 26/03/2020
@version 12.1.27
/*/
//-------------------------------------------------------------------
Static Function A001DifCPB(dDataDe,dDataAte,aXFilial, aParSX1)
	Local cAliasCFA	:= 'CFA'
	Local cAliasCFB	:= 'CFB'
	Local aTpContr	:=	{"CPR"}
	Local cSelect	:= ''
	Local cWhere	:= ''
	Local cPeriod	:= Substr(DTOS(dDataDe),5,2)+Substr(DTOS(dDataDe),1,4)
	Local nCont		:= 0
	Local lNewProc	:= ISA001NDIF()   
	Local oCPRB		:= CPRBEFD():New()

	For nCont := 1 to Len(aTpContr)
		
		cAliasCFA	:=	GetNextAlias()
		
		cSelect		:=	"%CFA.CFA_CODCON, CFA.CFA_TPCON, CFA.CFA_CNPJ, CFA.CFA_TOTVEN, CFA.CFA_VLNREC, CFA.CFA_CONDIF, "
		cSelect		+=	"CFA.CFA_PERAPU, CFA.CFA_ALIQ, CFA_CREDIF, CFA_CODCRE%"
		
		cWhere		:=	"%CFA.CFA_FILIAL = '"+xFilial("CFA")+"' AND "
		cWhere		+=	"CFA.CFA_PERAPU  = '"+cPeriod+"' AND "
		cWhere		+=	"CFA.CFA_TPCON   = '"+aTpContr[nCont]+"' AND "
		
		IF lNewProc
			cWhere		+=	"CFA.CFA_CONSOL= '2' AND "
		EndIF
		
		cWhere		+= "%"
		
		BeginSql Alias cAliasCFA   	
			
			SELECT			    	 
				%Exp:cSelect%		
		
			FROM 
				%Table:CFA% CFA													
			WHERE
				%Exp:cWhere%
				CFA.%NotDel%	
		EndSql
			
		DbSelectArea (cAliasCFA)
		(cAliasCFA)->(DbGoTop ())
		Do While !(cAliasCFA)->(Eof ())	
			//-------------------------------------------------------------------------------
			//Processa informações da tabela CFA, referente ao diferimento do próprio período
			//-------------------------------------------------------------------------------		
			oCPRB:SetDtIni(dDataDe)
			oCPRB:SetFilial(aXFilial)					

			oCPRB:SetCodRec(aParSX1[16]) 
			oCPRB:SetTpAju(REDUCAO)
			oCPRB:SetValAju((cAliasCFA)->CFA_CONDIF)
			oCPRB:SetCodAjus('08')
			oCPRB:SetNumero("")
			oCPRB:SetDescr("Diferimento da CPRB ")		
			oCPRB:SetDtRefer(lastDay(dDataDe))
			oCPRB:GravaAju()	
			oCPRB:AtualizaCPRB()
			oCPRB:Clear()				
			
			(cAliasCFA)->(DbSkip())
		EndDo
		
		oCPRB:FechaAlias(cAliasCFA)
		
		cAliasCFB	:=	GetNextAlias()
		cSelect		:=	"%CFB.CFB_CODCON, CFB.CFB_TPCON, CFB.CFB_DTPGTO, CFB.CFB_PERDIF, CFB.CFB_CONREC, "
		cSelect		+=	"CFB.CFB_VLRREC,CFB.CFB_PERAPU, CFB.CFB_ALIQ,CFB.CFB_NATCRE, CFB.CFB_CREDES%"
		cWhere		:=	"%CFB.CFB_FILIAL = '"+xFilial("CFB")+"' AND "
		cWhere		+=	"CFB.CFB_PERAPU  = '"+cPeriod+"' AND "
		cWhere		+=	"CFB.CFB_TPCON   = '"+aTpContr[nCont]+"' AND "

		IF lNewProc
			cWhere		+=	"CFB.CFB_CONSOL='2' AND "
		EndIF
		
		cWhere		+= "%"
			
		BeginSql Alias cAliasCFB   	
			
			SELECT			    	 
				%Exp:cSelect%		
		
			FROM 
				%Table:CFB% CFB													
			WHERE
				%Exp:cWhere%
				CFB.%NotDel%	
		EndSql
		
		DbSelectArea (cAliasCFB)
		(cAliasCFB)->(DbGoTop ())
		Do While !(cAliasCFB)->(Eof ())	

			//-------------------------------------------------------------------------------
			//Processa informações da tabela CFA, referente ao diferimento de período anterior
			//-------------------------------------------------------------------------------		
			
			oCPRB:SetDtIni(dDataDe)
			oCPRB:SetFilial(aXFilial)					
			
			oCPRB:SetCodRec(aParSX1[16]) 
			oCPRB:SetTpAju(ACRESCIMO)
			oCPRB:SetValAju((cAliasCFB)->CFB_CONREC)
			oCPRB:SetCodAjus('09')
			oCPRB:SetNumero("")
			oCPRB:SetDescr("Diferimento da CPRB do periodo anterior")		
			oCPRB:SetDtRefer(lastDay(dDataDe))
			oCPRB:GravaAju()	
			oCPRB:AtualizaCPRB()
			oCPRB:Clear()				
			
			(cAliasCFB)->(DbSkip())
		EndDo
		
		oCPRB:FechaAlias(cAliasCFB)

	Next nCont

	FreeObj(oCPRB)
	oCPRB := nil

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} CheckThread()
Função que irá Checar quantras Threads estão ativas para "PREPROCEFD"



@author Rafael Oliveira
@since 10/06/2021
@version 12.1.27
/*/
//-------------------------------------------------------------------

Static Function CheckThread()
	Local aUserInfo := {}
	Local aThreads	:= {}
	Local nX		:= 0

	// Retorna um array multidimensional com as informações de cada um do processos em execução
	aUserInfo := GetUserInfoArray()
	
	//Adiciona no Array quando for Thread do EFD Contribuições
	For nX := 1 to Len(aUserInfo)
		IF Upper(aUserInfo[nX][5]) == Upper("PREPROCEFD")
			Aadd(aThreads,aUserInfo[nX][3])
		Endif
	Next

	aSize(aUserInfo,0)	
Return aThreads


//-------------------------------------------------------------------
/*/{Protheus.doc} WaitThre()
Função para controle de Threads, irá liberar o processamento 
de todas assim que todas estiverem com o STATUS 4 / 1 / 2 


@author Matheus Massarotto
@since 30/08/2023
@version 12.1.2210
/*/
//-------------------------------------------------------------------

Static Function WaitThre(aThread)
Local nX	:= 1

	For nX := 1 to Len(aThread)

		While !killapp()

			If GetGlbValue( aThread[nX][1] ) $ '4|1|2' //se as threads terminou as saídas, foi finalizado ou com erro libero a main.
				if GetGlbValue( aThread[nX][1] ) == '4'
					PutGlbValue( aThread[nX][1],'0' )
				endif
				Exit
			EndIf
			
			Sleep(500)

		EndDo

	Next

	For nX := 1 to Len(aThread)
		IPCGo(aThread[nX][1])
	Next nX

Return
//-------------------------------------------------------------------
/*/{Protheus.doc} SetR4RecB()
Função para alimentar a globar var de receita bruta


@author Matheus Massarotto
@since 30/08/2023
@version 12.1.2210
/*/
//-------------------------------------------------------------------

Static Function SetR4RecB(cFilAnt,oApursai) 
Local aRet	 	:= {}
Local aValor 	:= oApursai:GetRBrAcu()

	GetGlbVars("FISRECBRUTA"+cFilAnt,aRet)

	if !empty(aRet)

		aValor[1][1]+=aRet[1][1]
		aValor[1][2]+=aRet[1][2]
		aValor[1][3]+=aRet[1][3]
		aValor[1][4]+=aRet[1][4]
		aValor[1][5]+=aRet[1][5]

	endif
	
	PutGlbVars("FISRECBRUTA"+cFilAnt,aValor) 

aValor[1]:=Nil
aValor:=Nil

Return
//-------------------------------------------------------------------
/*/{Protheus.doc} GetR4RecB()
Função para retornar a receita bruta da global var


@author Matheus Massarotto
@since 30/08/2023
@version 12.1.2210
/*/
//-------------------------------------------------------------------
Static Function GetR4RecB(cFilAnt) 
Local aRet	 := {}
Local aRetRec:= {{0,0,0,0,0}}

	GetGlbVars("FISRECBRUTA"+cFilAnt,aRet)

	if !empty(aRet)
		aRetRec:= aRet
	endif
Return(aRetRec)
//-------------------------------------------------------------------
/*/{Protheus.doc} Ctrl2Reg()
Função que diz ser regime misto (cumulativo e não cumulativo) e ser multithread


@author Matheus Massarotto
@since 30/08/2023
@version 12.1.2210
/*/
//-------------------------------------------------------------------
Static Function Ctrl2Reg(cRegime,nQtdThread)
Local lRet:=.F.	
	if cRegime == '4' .and. nQtdThread > 0
		lRet:=.T.
	endif
Return(lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} ASA001SUBS
	(Busca os documentos BPE com substituição para serem lançados 
	como ajuste de base de calculo PIS/COFINS no período de apuração.
	Os campos FT_NFORI, FT_SERORI, FT_ITEMORI ficam preenchidos para buscar o bilhete origem e fazer os lançamentos.
	No periodo corrente o sistema busca as bases do mes ou de meses anteriores.)
	@type  Static Function
	@author Delleon Fernandes
	@since 19/08/2024
	@version 12.1.2310
	@param aParSX1, Array, Parametros da apuração
	@param aXFilial, Array, Array com xFilial das tabelas de apuração.
	@param oApurSai, Objeto, Classe da apuração para utilziar alguns metodos.
	@param nM996Tpr, numerico, Quando a apuração é Regime misto (Cumulativo/Não Cumulativo)
	@return Nil, Nil, Nil
	@see (links_or_references)
/*/
Static Function ASA001SUBS(aParSX1 as array, aXFilial as array, oApurSai as object, nM996Tpr as numeric, oNFSubs as object,;
							oJSqlName as object, oJTamSX3 as object, aFildF2Z as array, lF2ZALQ as logical)

	Local oBulk      := Nil as object
	Local oTabF2Z    := Nil as object
	Local oEFDGen    := Nil as object
	Local aDadosF2Z  := {} as array
	Local cM0CGC     := FWSM0Util():GetSM0Data(,, { "M0_CGC" } )[1][2] as character
	Local cPerApu    := DToS(FirstDay(aParSX1[1])) as character
	Local cAliascTMP := GetNextAlias() as character
	Local cChave     := "" as character
	Local cChvNum    := "" as character
	Local cFilMatriz := "" as character
	Local cCodCon    := "" as character
	Local cTRIB      := "" as character
	Local cINDAJU    := "0" as character // Ajuste de Redução
	Local cORI_NFORI := "" as character
	Local cORI_SERORI  := "" as character
	Local cORI_CLIEFOR := "" as character
	Local cORI_LOJA    := "" as character
	Local cORI_ITEMORI := "" as character
	Local cFTFILIAL    := "" as character
	Local cQuery	   := "" as character
	Local cMsg         := "" as character
	Local nX         := 0 as numeric
	Local nALIQ      := 0 as numeric
	Local nVALAJU    := 0 as numeric
	Local lGravaF2Z  := .F. as logical
	
	If oNFSubs == Nil
		// Chamada de funcoes de cache na inicializacao.
		oJSqlName := QrySqlName()
		oJTamSX3 := TaCacheSX3()

		cQuery := "	SELECT "
		cQuery += "	SFT.FT_FILIAL, SFT.FT_NFISCAL, SFT.FT_SERIE, SFT.FT_ITEM, SFT.FT_CLIEFOR, SFT.FT_LOJA, SFT.FT_EMISSAO "
		cQuery += "	,SFTORI.FT_NFISCAL ORI_NFORI , SFTORI.FT_SERIE ORI_SERORI, SFTORI.FT_ITEM ORI_ITEMORI, SFTORI.FT_CONTA ORI_CONTA "
		cQuery += "	,SFTORI.FT_BASEPIS ORI_BASEPIS, SFTORI.FT_BASECOF ORI_BASECOF, SFTORI.FT_ALIQPIS ORI_ALIQPIS, SFTORI.FT_ALIQCOF ORI_ALIQCOF "
		cQuery += "	,SFTORI.FT_CSTPIS ORI_CSTPIS, SFTORI.FT_CSTCOF ORI_CSTCOF, SFTORI.FT_CLIEFOR ORI_CLIEFOR, SFTORI.FT_LOJA ORI_LOJA "
		cQuery += "	,SFTORI.B1_TPREG, SFTORI.A1_TPREG, SFTORI.F4_TPREG "
		cQuery += "	FROM "+oJSqlName["SFT"]+" SFT "
		cQuery += "	INNER JOIN (SELECT SFT2.FT_FILIAL, SFT2.FT_TIPOMOV, SFT2.FT_NFISCAL, SFT2.FT_SERIE, SFT2.FT_ITEM, SFT2.FT_CLIEFOR , SFT2.FT_LOJA , SFT2.FT_BASEPIS "
		cQuery += "		,SFT2.FT_BASECOF , SFT2.FT_ALIQPIS , SFT2.FT_ALIQCOF, SFT2.FT_CSTPIS, SFT2.FT_CSTCOF, SFT2.FT_CONTA, SB1.B1_TPREG, SA1.A1_TPREG, SF4.F4_TPREG "
		cQuery += "		FROM "+oJSqlName["SFT"]+" SFT2 "
		cQuery += "		INNER JOIN "+oJSqlName["SB1"]+" SB1 ON (SB1.B1_FILIAL = ? AND SB1.B1_COD = SFT2.FT_PRODUTO AND SB1.D_E_L_E_T_ = ? ) "
		cQuery += "		INNER JOIN "+oJSqlName["SA1"]+" SA1 ON (SA1.A1_FILIAL = ? AND SA1.A1_COD = SFT2.FT_CLIEFOR AND SA1.A1_LOJA = SFT2.FT_LOJA AND SA1.D_E_L_E_T_ = ? ) "
		cQuery += "		LEFT JOIN  "+oJSqlName["SF4"]+" SF4 ON (SF4.F4_FILIAL = ? AND SF4.F4_CODIGO = SFT2.FT_TES AND SF4.D_E_L_E_T_ = ? ) "
		cQuery += "		WHERE SFT2.FT_FILIAL = ? AND SFT2.FT_TIPOMOV = ? AND SFT2.FT_ESPECIE = ? AND SFT2.FT_ENTRADA >= ? AND SFT2.FT_ENTRADA <= ? AND SFT2.D_E_L_E_T_ = ? "
		cQuery += "		AND ( SFT2.FT_BASEPIS > ? OR SFT2.FT_BASECOF > ? ) ) "
		cQuery += "		SFTORI ON ( SFTORI.FT_FILIAL = SFT.FT_FILIAL AND SFTORI.FT_TIPOMOV = SFT.FT_TIPOMOV AND SFTORI.FT_NFISCAL = SFT.FT_NFORI AND SFTORI.FT_SERIE = SFT.FT_SERORI AND SFTORI.FT_ITEM = SFT.FT_ITEMORI ) "
		cQuery += "	WHERE SFT.FT_FILIAL = ? "
		cQuery += "	AND SFT.FT_TIPOMOV = ? "
		cQuery += "	AND SFT.FT_ENTRADA >= ? "
		cQuery += "	AND SFT.FT_ENTRADA <= ? "
		cQuery += "	AND SFT.FT_ESPECIE = ? "
		cQuery += "	AND SFT.FT_NFORI  <> ? "
		cQuery += "	AND SFT.FT_SERORI <> ? "
		cQuery += "	AND SFT.FT_ITEMORI <> ? "
		cQuery += "	AND SFT.FT_DTCANC = ? "
		cQuery += "	AND SFT.FT_TIPO = ? "
		cQuery += "	AND ( SFT.FT_BASEPIS > ? OR SFT.FT_BASECOF > ? ) "
		cQuery += "	AND SFT.D_E_L_E_T_ = ? "
	
		cQuery := ChangeQuery(cQuery)

		oNFSubs := FwExecStatement():New( cQuery )
	EndIf

	oNFSubs:setString( 1, xFilial("SB1") )
	oNFSubs:setString( 2, " " )
	oNFSubs:setString( 3, xFilial("SA1") )
	oNFSubs:setString( 4, " " )
	oNFSubs:setString( 5, xFilial("SF4") )
	oNFSubs:setString( 6, " " )
	oNFSubs:setString( 7, xFilial("SFT") )
	oNFSubs:setString( 8, "S" )
	oNFSubs:setString( 9, 'BPE' )
	oNFSubs:setDate(   10, YearSub(aParSX1[1], 1) ) // O Bilhete tem validade de um ano conforme https://www.planalto.gov.br/ccivil_03/_ato2007-2010/2009/lei/l11975.htm
	oNFSubs:setDate(   11, aParSX1[2] )
	oNFSubs:setString( 12, " " )
	oNFSubs:setNumeric(13, 0 )
	oNFSubs:setNumeric(14, 0 )
	oNFSubs:setString( 15, xFilial("SFT") )
	oNFSubs:setString( 16, "S" )
	oNFSubs:setDate(   17, aParSX1[1] )
	oNFSubs:setDate(   18, aParSX1[2] )
	oNFSubs:setString( 19, 'BPE' )
	oNFSubs:setString( 20, " " )
	oNFSubs:setString( 21, " " )
	oNFSubs:setString( 22, " " )
	oNFSubs:setString( 23, " " )
	oNFSubs:setString( 24, " " )
	oNFSubs:setNumeric(25, 0 )
	oNFSubs:setNumeric(26, 0 )
	oNFSubs:setString( 27, " " )

	cAliascTMP := oNFSubs:OpenAlias()

	If !(cAliascTMP)->(Eof())
	
		oEFDGen := EFDGEN():New()
		oEFDGen:SetFilial(aXFilial)
		cFilMatriz := oEFDGen:BuscaxFil('F2Z')
		oApurSai:Clear()
		oApurSai:ClsItem()
		oApurSai:SetRegApur(Str(aParSX1[6],1))

		oBulk := FwBulk():New(RetSqlName("F2Z"),600)
		oBulk:setFields(aFildF2Z)

		Do While !(cAliascTMP)->(Eof())

			If aParSX1[6] == 4 // Regime de apuração Cumulativo/Não Cumulativo, Analisa com base no parametro MV_M996TPR
				oApurSai:SetRegApur(DefRegime(nM996Tpr, cAliascTMP))
				oApurSai:SetTpReg(DefRegime(nM996Tpr, cAliascTMP))
			EndIf
			oApurSai:DefRegime() //Chama método para classe definir o regime

			For nX:=1 To 2 // Duas vezes uma para PIS segunda para COFINS
				lGravaF2Z := .F.
				aDadosF2Z := {}
				If nX==1 .And. (cAliascTMP)->ORI_BASEPIS > 0
					lGravaF2Z := .T.
					oApurSai:SetCST((cAliascTMP)->ORI_CSTPIS)
					cCodCon := oApurSai:CodCon()
					cTRIB   := "1"
					nALIQ   := (cAliascTMP)->ORI_ALIQPIS
					nVALAJU := (cAliascTMP)->ORI_BASEPIS
				ElseIf nX==2 .And. (cAliascTMP)->ORI_BASECOF > 0
					lGravaF2Z := .T.
					oApurSai:SetCST((cAliascTMP)->ORI_CSTCOF)
					cCodCon := oApurSai:CodCon()
					cTRIB   := "2"
					nALIQ   := (cAliascTMP)->ORI_ALIQCOF
					nVALAJU := (cAliascTMP)->ORI_BASECOF
				EndIf

				If lGravaF2Z

					cORI_NFORI   := Alltrim((cAliascTMP)->ORI_NFORI)
					cORI_SERORI  := Alltrim((cAliascTMP)->ORI_SERORI)
					cORI_CLIEFOR := Alltrim((cAliascTMP)->ORI_CLIEFOR)
					cORI_LOJA    := Alltrim((cAliascTMP)->ORI_LOJA)
					cORI_ITEMORI := Alltrim((cAliascTMP)->ORI_ITEMORI)
					cFTFILIAL    := Alltrim((cAliascTMP)->FT_FILIAL)

					cChvNum := cORI_NFORI+cORI_SERORI+cORI_CLIEFOR+cORI_LOJA+cORI_ITEMORI
					cChave  := cFilMatriz+cPerApu+cTRIB+cINDAJU+PadR(cPerApu+cTRIB+cINDAJU, oJTamSX3["F2Z_CHV"])+PadR(cChvNum, oJTamSX3["F2Z_ID"])

					/*F2Z_FILIAL*/ aAdd(aDadosF2Z, cFilMatriz )
					/*F2Z_CHV*/    aAdd(aDadosF2Z, cPerApu+cTRIB+cINDAJU )
					/*F2Z_ID*/     aAdd(aDadosF2Z, cChvNum )
					/*F2Z_CODAJU*/ aAdd(aDadosF2Z, '01' ) // 01=Vendas Canceladas de Receitas Tributadas em períodos anteriores
					/*F2Z_NUM*/    aAdd(aDadosF2Z, cORI_NFORI+"-"+cORI_SERORI+"-"+cORI_CLIEFOR+"-"+cORI_LOJA+"-"+cORI_ITEMORI )
					/*F2Z_DESCR*/  aAdd(aDadosF2Z, (cAliascTMP)->("BPE Substituído Nr.:"+cORI_NFORI+",Série:"+cORI_SERORI+",Item:"+cORI_ITEMORI+", Filial:"+cFTFILIAL+" ,BPE Substituto Nr.:"+FT_NFISCAL+",Série:"+FT_SERIE+",Item:"+FT_ITEM) )
					/*F2Z_DTREF*/  aAdd(aDadosF2Z, StoD((cAliascTMP)->FT_EMISSAO) )
					/*F2Z_CONTA*/  aAdd(aDadosF2Z, (cAliascTMP)->ORI_CONTA )
					/*F2Z_CNPJ*/   aAdd(aDadosF2Z, cM0CGC )
					/*F2Z_TRIB*/   aAdd(aDadosF2Z, cTRIB )
					If lF2ZALQ
						/*F2Z_ALIQ*/   aAdd(aDadosF2Z, nALIQ )
					EndIf
					/*F2Z_VALAJU*/ aAdd(aDadosF2Z, nVALAJU )
					/*F2Z_PERAPU*/ aAdd(aDadosF2Z, StoD(cPerApu) )
					/*F2Z_CODCON*/ aAdd(aDadosF2Z, cCodCon )
					/*F2Z_ORIG*/   aAdd(aDadosF2Z, '3' ) // 1-Usuario;2-Sistema;3-Lcto Ajuste Sistema // Indica a origem automática do sistema/apuração
					/*F2Z_CONSOL*/ aAdd(aDadosF2Z, '2' ) // 2-Não
					/*F2Z_INDAJU*/ aAdd(aDadosF2Z, cINDAJU )
					
					oBulk:addData(aDadosF2Z)
					cMsg := oBulk:getError()

				EndIf
			FwFreeArray(aDadosF2Z)
			Next nX

			(cAliascTMP)->(DbSkip())

		EndDo

		oBulk:Close() //Se os dados estiverem corretos, faz o Close do FwBulk para inserir possíveis registros não inseridos e finalizar o bulk.
		cMsg += oBulk:getError()
		FwLogMsg("INFO", , "FISA001", "FISA001", "", "Ocorrencia Bulk", cMsg, , , )

		//Limpa objeto do FwBulk para reutilizar com outra tabela.
		oBulk:Destroy()
		oBulk := Nil

	EndIf

	(cAliascTMP)->(DbCloseArea())

	FreeObj( oTabF2Z )
	FreeObj( oEFDGen )

Return

/*/{Protheus.doc} A001CTESUBS()
    Faz o processamento e realização dos ajustes das bases de calculos de CTEs substituidos
	@param 		aParSX1, array, array contendo as perguntas do ISA001
	@param 		aXFilial, array, array contendo as filiais
	@param 		oApurEnt, object, instancia do FISX001 referente as Entrada
	@param 		oApurSai, object, instancia do FISX001 referente as Saida
	@param 		nM996Tpr, numeric, informa o conteudo do parametro MV_M996TPR
	@param 		oJSqlName, object, json contendo o cache dos RetSqlName
	@param 		oJTamSX3, character, json contendo o cache se os campos existem
	@param 		aFildF2Z, array, array contendo a estrutura dos campos da F2Z
	@param 		lF2ZALQ, logical, Indica se existe ou não o campo na base de dados
	@return		nil, nil, nil
	@type		Static Function
	@author 	Matheus Bispo
    @since 		23/04/2025
    @version 	12.1.2410
/*/
Static Function A001CTESUBS(aParSX1 as array, aXFilial as array, oApurEnt as object, oApurSai as object, nM996Tpr as numeric, ;
							oJSqlName as object, oJTamSX3 as object, aFildF2Z as array, lF2ZALQ as logical)

	Local oQryCTE := Nil as object
	Local oEFDGen := Nil as object
	Local oApur := oApurEnt as object
	Local oBulk := Nil as object
	Local aDadosF2Z := {} as array
	Local aBind := {} as array
	Local cM0CGC := FWSM0Util():GetSM0Data(,, { "M0_CGC" } )[1][2] as character
	Local cPerApu := DToS(FirstDay(aParSX1[1])) as character
	Local cAliasTMP := GetNextAlias() as character	
	Local cQuery := "" as character
	Local cFilMatriz := "" as character
	Local cMsg := "" as character
	Local nTpMov := 0 as numeric
	Local nTamBind := 0 as numeric
	Local nX := 0 as numeric

	If oJTamSX3 == Nil
		oJTamSX3 := TaCacheSX3()
	Endif

	If oJSqlName == Nil
		oJSqlName := QrySqlName()
	EndIf

	For nTpMov := 1 To 2

		cQuery := A001QRYCTE(nTpMov, @aBind, oJSqlName, aParSX1[1], aParSX1[2])

		cQuery := ChangeQuery(cQuery)

		oQryCTE := FwExecStatement():New(cQuery)

		nTamBind := Len(aBind)

		If nTpMov == 2
			oApur := oApurSai
		EndIf

		For nX := 1 to nTamBind
			If aBind[nX][1] == "C"
				oQryCTE:setString(nX, aBind[nX][2])
			ElseIf aBind[nX][1] == "D"
				oQryCTE:setDate(nX, aBind[nX][2])
			ElseIf aBind[nX][1] == "N"
				oQryCTE:setNumeric(nX, aBind[nX][2])
			EndIf
		Next

		FwFreeArray(aBind)
		aBind := {}
	
		cAliasTMP := oQryCTE:OpenAlias()

		If !(cAliasTMP)->(Eof())
		
			oEFDGen := EFDGEN():New()
			oEFDGen:SetFilial(aXFilial)

			oApur:Clear()
			oApur:ClsItem()
			oApur:SetRegApur(Str(aParSX1[6],1))

			oBulk := FwBulk():New(RetSqlName("F2Z"), 600)
			oBulk:setFields(aFildF2Z)

			cFilMatriz := oEFDGen:BuscaxFil('F2Z')

			Do While !(cAliasTMP)->(Eof())

				aDadosF2Z := F2ZAjusteSub(nTpMov, cAliasTMP, oApur, aParSX1[6], nM996Tpr, cFilMatriz, cPerApu, cM0CGC, lF2ZALQ)
				
				oBulk:addData(aDadosF2Z[1])
				oBulk:addData(aDadosF2Z[2])
				cMsg := oBulk:getError()

				(cAliasTMP)->(DbSkip())

			EndDo

			oBulk:Close() //Se os dados estiverem corretos, faz o Close do FwBulk para inserir possíveis registros não inseridos e finalizar o bulk.
			cMsg += oBulk:getError()
			FwLogMsg("INFO", , "FISA001", "FISA001", "", "Ocorrencia Bulk", cMsg, , , )

			//Limpa objeto do FwBulk para reutilizar com outra tabela.
			oBulk:Destroy()
			oBulk := Nil

		EndIf

		(cAliasTMP)->(DbCloseArea())

		oQryCTE:Destroy()
		FreeObj(oQryCTE)
		FreeObj(oEFDGen)

	Next

Return

/*/{Protheus.doc} A001QRYCTE()
    Processa a query para validação se a nota CTE é uma substituição ou não
	@param 		nTpMov, numeric, informa se ira processar entrara ou saida (1 = Entrada / 2 = Saida)
	@param 		aBind, array, array contendo os binds que serão usadas na query (ExecStatement)
	@param 		oJSqlName, json, json contendo o cache dos RetSqlName
	@param		dDataDe, date, data inicial do processamento
	@param		dDataAte, date, data final do processamento
	@return		cQuery, character, retorna a query de entrada ou saida para abertura do alias
	@type		Static Function
	@author 	Matheus Bispo
    @since 		23/04/2025
    @version 	12.1.2410
/*/
Static Function A001QRYCTE(nTpMov as numeric, aBind as array, oJSqlName as json, dDataDe as date, dDataAte as date)
	Local cQuery := "" as character

	If nTpMov == 1
		
		cQuery := "	SELECT SFT.FT_FILIAL SUB_FILIAL, SFT.FT_NFISCAL SUB_NOTA, SFT.FT_SERIE SUB_SERIE, SFT.FT_EMISSAO SUB_EMISSAO, "
		cQuery += 		" SFT.FT_ITEM, SFT.FT_CLIEFOR, SFT.FT_LOJA, "
		cQuery += 		" SFTORI.FT_NFISCAL ORI_NFORI , SFTORI.FT_SERIE ORI_SERORI, SFTORI.FT_ITEM ORI_ITEMORI, SFTORI.FT_CONTA ORI_CONTA, "
		cQuery += 		" SFTORI.FT_BASEPIS ORI_BASEPIS, SFTORI.FT_BASECOF ORI_BASECOF, SFTORI.FT_ALIQPIS ORI_ALIQPIS, SFTORI.FT_ALIQCOF ORI_ALIQCOF, "
		cQuery += 		" SFTORI.FT_CSTPIS ORI_CSTPIS, SFTORI.FT_CSTCOF ORI_CSTCOF, SFTORI.FT_CLIEFOR ORI_CLIEFOR, SFTORI.FT_LOJA ORI_LOJA, "
		cQuery += 		" SFTORI.B1_TPREG, SFTORI.A1_TPREG, SFTORI.F4_TPREG "
		cQuery += " FROM " +oJSqlName["SFT"]+ " SFT "
		cQuery += "	INNER JOIN " +oJSqlName["SF1"]+ " SF1 "
		cQuery += 	" ON ( 
		cQuery += 		" SF1.F1_FILIAL = ? "	//1
		cQuery += 		" AND SF1.F1_DOC = SFT.FT_NFISCAL "
		cQuery += 		" AND SF1.F1_SERIE = SFT.FT_SERIE "
		cQuery += 		" AND SF1.F1_FORNECE = SFT.FT_CLIEFOR "
		cQuery += 		" AND SF1.F1_LOJA = SFT.FT_LOJA "
		cQuery += 		" AND SF1.D_E_L_E_T_ = ? " //2
		cQuery += 	" ) "
		cQuery += " INNER JOIN "
		cQuery += 	" ( "
		cQuery += 		" SELECT SFT2.FT_FILIAL, SFT2.FT_TIPOMOV, SFT2.FT_NFISCAL, SFT2.FT_SERIE, SFT2.FT_ITEM, SFT2.FT_CLIEFOR , SFT2.FT_LOJA , SFT2.FT_BASEPIS, "
		cQuery += 			" SFT2.FT_BASECOF, SFT2.FT_ALIQPIS, SFT2.FT_ALIQCOF, SFT2.FT_CSTPIS, SFT2.FT_CSTCOF, SFT2.FT_CONTA, SB1.B1_TPREG, SA1.A1_TPREG, SF4.F4_TPREG "
		cQuery += 		" FROM " +oJSqlName["SFT"]+ " SFT2 "
		cQuery += 		" INNER JOIN " +oJSqlName["SB1"]+ " SB1 ON (SB1.B1_FILIAL = ? AND SB1.B1_COD = SFT2.FT_PRODUTO AND SB1.D_E_L_E_T_ = ? ) " //3 e 4
		cQuery += 		" INNER JOIN " +oJSqlName["SA1"]+ " SA1 ON (SA1.A1_FILIAL = ? AND SA1.A1_COD = SFT2.FT_CLIEFOR AND SA1.A1_LOJA = SFT2.FT_LOJA AND SA1.D_E_L_E_T_ = ? ) " //5 e 6
		cQuery += 		" LEFT JOIN  " +oJSqlName["SF4"]+ " SF4 ON (SF4.F4_FILIAL = ? AND SF4.F4_CODIGO = SFT2.FT_TES AND SF4.D_E_L_E_T_ = ? ) " //7 e 8
		cQuery += 		" WHERE SFT2.FT_FILIAL = ? " //9
		cQuery += 			" AND SFT2.FT_TIPOMOV = ? " //10
		cQuery += 			" AND SFT2.FT_ENTRADA BETWEEN ? AND ? " //11 e 12
		cQuery += 			" AND SFT2.FT_ESPECIE = ? " //13
		cQuery += 			" AND SFT2.D_E_L_E_T_ = ? " //14
		cQuery += 			" AND ( SFT2.FT_BASEPIS > ? OR SFT2.FT_BASECOF > ? ) " //15 e 16
		cQuery += 	" ) "
		cQuery += 	" SFTORI ON ( SFTORI.FT_FILIAL = SFT.FT_FILIAL AND SFTORI.FT_TIPOMOV = SFT.FT_TIPOMOV AND SFTORI.FT_SERIE = SFT.FT_SERORI AND SFTORI.FT_NFISCAL = SFT.FT_NFORI AND SFTORI.FT_CLIEFOR = SFT.FT_CLIEFOR AND SFTORI.FT_LOJA = SFT.FT_LOJA AND SFTORI.FT_ITEM = SFT.FT_ITEMORI ) "
		cQuery += "	WHERE SFT.FT_FILIAL = ? " //17
		cQuery += 	" AND SFT.FT_TIPOMOV = ? " //18
		cQuery += 	" AND SFT.FT_ENTRADA BETWEEN ? AND ? " //19 e 20
		cQuery += 	" AND SFT.FT_ESPECIE = ? " //21
		cQuery += 	" AND SFT.FT_NFORI  <> ? " //22
		cQuery += 	" AND SFT.FT_SERORI <> ? " //23
		cQuery += 	" AND SFT.FT_ITEMORI <> ? " //24
		cQuery += 	" AND SFT.FT_DTCANC = ? " //25
		cQuery += 	" AND SFT.FT_TIPO = ? " //26
		cQuery += 	" AND ( SFT.FT_BASEPIS > ? OR SFT.FT_BASECOF > ? ) " //27 e 28
		cQuery += 	" AND SF1.F1_TPCTE = ? " //29
		cQuery += 	" AND SFT.D_E_L_E_T_ = ? " //30
		
		aAdd(aBind, {"C", xFilial("SF1")})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"C", xFilial("SB1")})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"C", xFilial("SA1")})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"C", xFilial("SF4")})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"C", xFilial("SFT")})
		aAdd(aBind, {"C", "E"})
		aAdd(aBind, {"D", dDataDe})
		aAdd(aBind, {"D", dDataAte})
		aAdd(aBind, {"C", "CTE"})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"N", 0})
		aAdd(aBind, {"N", 0})
		aAdd(aBind, {"C", xFilial("SFT")})
		aAdd(aBind, {"C", "E"})
		aAdd(aBind, {"D", dDataDe})
		aAdd(aBind, {"D", dDataAte})
		aAdd(aBind, {"C", "CTE"})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"N", 0})
		aAdd(aBind, {"N", 0})
		aAdd(aBind, {"C", "S"})
		aAdd(aBind, {"C", " "})

	ElseIf nTpMov == 2
		
		cQuery := " SELECT F3_FILIAL SUB_FILIAL, F3_NFISCAL SUB_NOTA, F3_SERIE SUB_SERIE, F3_EMISSAO SUB_EMISSAO, "
		cQuery += 		" SFTORI.FT_NFISCAL ORI_NFORI, SFTORI.FT_SERIE ORI_SERORI, SFTORI.FT_ITEM ORI_ITEMORI, "
		cQuery += 		" SFTORI.FT_BASEPIS ORI_BASEPIS, SFTORI.FT_BASECOF ORI_BASECOF, SFTORI.FT_ALIQPIS ORI_ALIQPIS, SFTORI.FT_ALIQCOF ORI_ALIQCOF, "
		cQuery += 		" SFTORI.FT_CSTPIS ORI_CSTPIS, SFTORI.FT_CSTCOF ORI_CSTCOF, "
		cQuery += 		" SFTORI.FT_CLIEFOR ORI_CLIEFOR, SFTORI.FT_LOJA ORI_LOJA, SFTORI.FT_CONTA ORI_CONTA, "
		cQuery += 		" SFTORI.B1_TPREG, SFTORI.A1_TPREG, SFTORI.F4_TPREG "
		cQuery += " FROM " +oJSqlName["SF3"]+ " SF3 "
		cQuery += "	INNER JOIN " +oJSqlName["DT6"]+ " DT6 "
		cQuery += 	" ON ( 
		cQuery += 		" DT6.DT6_FILIAL = ? " //1
		cQuery += 		" AND DT6.DT6_FILDOC = SF3.F3_FILIAL "
		cQuery += 		" AND DT6.DT6_DOC = SF3.F3_NFISCAL "
		cQuery += 		" AND DT6.DT6_SERIE = SF3.F3_SERIE "
		cQuery += 		" AND DT6.D_E_L_E_T_ = ? " //2
		cQuery += 	" ) "
		cQuery += " INNER JOIN "
		cQuery += 	" ( "
		cQuery += 		" SELECT SFT2.FT_FILIAL, SFT2.FT_TIPOMOV, SFT2.FT_NFISCAL, SFT2.FT_SERIE, SFT2.FT_ITEM, SFT2.FT_CLIEFOR, SFT2.FT_LOJA, "
		cQuery += 			" SFT2.FT_BASEPIS, SFT2.FT_BASECOF, SFT2.FT_ALIQPIS, SFT2.FT_ALIQCOF, SFT2.FT_CSTPIS, SFT2.FT_CSTCOF, SFT2.FT_CONTA, SFT2.FT_DTCANC, SFT2.FT_TIPO, "
		cQuery += 			" SB1.B1_TPREG, SA1.A1_TPREG, SF4.F4_TPREG "
		cQuery += 		" FROM " +oJSqlName["SFT"]+ " SFT2 "
		cQuery += 		" INNER JOIN " +oJSqlName["SB1"]+ " SB1 ON (SB1.B1_FILIAL = ? AND SB1.B1_COD = SFT2.FT_PRODUTO AND SB1.D_E_L_E_T_ = ? ) " //3 e 4
		cQuery += 		" INNER JOIN " +oJSqlName["SA1"]+ " SA1 ON (SA1.A1_FILIAL = ? AND SA1.A1_COD = SFT2.FT_CLIEFOR AND SA1.A1_LOJA = SFT2.FT_LOJA AND SA1.D_E_L_E_T_ = ? ) " //5 e 6
		cQuery += 		" LEFT JOIN  " +oJSqlName["SF4"]+ " SF4 ON (SF4.F4_FILIAL = ? AND SF4.F4_CODIGO = SFT2.FT_TES AND SF4.D_E_L_E_T_ = ? ) " //7 e 8
		cQuery += 		" WHERE SFT2.FT_FILIAL = ? " //9
		cQuery += 			" AND SFT2.FT_TIPOMOV = ? " //10		
		cQuery += 			" AND SFT2.FT_ENTRADA BETWEEN ? AND ? " //11 e 12
		cQuery += 			" AND SFT2.FT_ESPECIE = ? " //13
		cQuery += 			" AND SFT2.D_E_L_E_T_ = ? " //14
		cQuery += 			" AND ( SFT2.FT_BASEPIS > ? OR SFT2.FT_BASECOF > ? ) " //15 e 16
		cQuery += 	" ) "
		cQuery += 	" SFTORI ON ( SFTORI.FT_FILIAL = DT6.DT6_FILDOC AND SFTORI.FT_TIPOMOV = ? AND SFTORI.FT_NFISCAL = DT6.DT6_DOCDCO AND SFTORI.FT_SERIE = DT6.DT6_SERDCO ) " //17
		cQuery += "	WHERE SF3.F3_FILIAL = ? " //18
		cQuery += 	" AND SF3.F3_ENTRADA BETWEEN ? AND ? " //19 e 20
		cQuery += 	" AND SFTORI.FT_TIPOMOV = ? " //21
		cQuery += 	" AND SF3.F3_ESPECIE = ? " //22
		cQuery += 	" AND SF3.F3_DTCANC = ? " //23
		cQuery += 	" AND SF3.F3_TIPO = ? " //24
		cQuery += 	" AND ( SFTORI.FT_BASEPIS > ? OR SFTORI.FT_BASECOF > ? ) " //25 e 26
		cQuery += 	" AND DT6.DT6_DOCTMS = ? " //27
		cQuery += 	" AND SF3.D_E_L_E_T_ = ? " //28

		aAdd(aBind, {"C", xFilial("DT6")})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"C", xFilial("SB1")})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"C", xFilial("SA1")})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"C", xFilial("SF4")})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"C", xFilial("SFT")})
		aAdd(aBind, {"C", "S"})
		aAdd(aBind, {"D", dDataDe})
		aAdd(aBind, {"D", dDataAte})
		aAdd(aBind, {"C", "CTE"})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"N", 0})
		aAdd(aBind, {"N", 0})
		aAdd(aBind, {"C", "S"})
		aAdd(aBind, {"C", xFilial("SF3")})
		aAdd(aBind, {"D", dDataDe})
		aAdd(aBind, {"D", dDataAte})
		aAdd(aBind, {"C", "S"})
		aAdd(aBind, {"C", "CTE"})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"C", " "})
		aAdd(aBind, {"N", 0})
		aAdd(aBind, {"N", 0})
		aAdd(aBind, {"C", "P"})
		aAdd(aBind, {"C", " "})
	EndIf

Return cQuery

/*/{Protheus.doc} F2ZAjusteSub()
    Recebe um Alias e processa os ajustes de acordo com ele, retornando um array com a estrutura da F2Z para processamento e gravação na tabela
	@param 		nTpMov, numeric, informa se ira processar entrara ou saida (1 = Entrada / 2 = Saida)
	@param 		cAliasTMP, character, alias da query que ira filtrar os ajustes de base de calculo que devem ser realizados
	@param 		oApur, object, passado o objeto do FISX001 referente as entradas ou a saidas (oApurSai ou oApurEnt)
	@param 		cRegime, character, informa o regime de apuração e arquivo (nao cumulativo/cumulativo/misto)
	@param 		nM996Tpr, numeric, informa o conteudo do parametro MV_M996TPR
	@param 		cFilMatriz, character, Filial matriz do processamento
	@param 		cPerApu, character, periodo que esta sendo realizada a apuração
	@param 		cM0CGC, character, CNPJ da empresa
	@param 		lF2ZALQ, logical, Indica se existe ou não o campo na base de dados
	@return		aDadosF2Z, array, retorna um array (matriz [n][2]) com os dados de ajuste para o F2Z, onde a primeira posicao [n][1] contera os dados do pis e o [n][2] do cofins
	@type		Static Function
	@author 	Matheus Bispo
    @since 		23/04/2025
    @version 	12.1.2410
/*/
Static Function F2ZAjusteSub(nTpMov as numeric, cAliasTMP as character, oApur as object, cRegime as character, nM996Tpr as numeric, cFilMatriz as character, cPerApu as character, cM0CGC as character, lF2ZALQ as logical)
	Local aDadosF2Z := {} as array
	Local cORI_NFORI := "" as character
	Local cORI_SERORI := "" as character
	Local cORI_CLIEFOR := "" as character
	Local cORI_LOJA := "" as character
	Local cORI_ITEMORI := "" as character
	Local cFTFILIAL := "" as character
	Local cF2ZMsg := "" as character
	Local cItemF2ZMsg := "" as character
	Local cCodCon := "" as character
	Local cTrib := "" as character
	Local cCST := "" as character
	Local cChvNum := "" as character
	Local cIndAju := "0" as character
	Local nPosF2Z := 0 as numeric
	Local nAliq := 0 as numeric
	Local nValAju := 0 as numeric
	Local nX := 0 as numeric
	
	If cRegime // Regime de apuração Cumulativo/Não Cumulativo, Analisa com base no parametro MV_M996TPR
		oApur:SetRegApur(DefRegime(nM996Tpr, cAliasTMP))
		oApur:SetTpReg(DefRegime(nM996Tpr, cAliasTMP))
	EndIf

	oApur:DefRegime() //Chama método para classe definir o regime
	
	For nX := 1 To 2 // Duas vezes uma para PIS segunda para COFINS
		aAdd(aDadosF2Z, {})
		nPosF2Z := Len(aDadosF2Z)

		If nX == 1
			cTrib 	:= "1"
			cCST 	:= (cAliasTMP)->ORI_CSTPIS
			nValAju := (cAliasTMP)->ORI_BASEPIS
			nAliq 	:= (cAliasTMP)->ORI_ALIQPIS
		ElseIf nX == 2
			cTrib 	:= "2"
			cCST 	:= (cAliasTMP)->ORI_CSTCOF
			nValAju := (cAliasTMP)->ORI_BASECOF
			nAliq 	:= (cAliasTMP)->ORI_ALIQCOF
		EndIf

		oApur:SetCST(cCST)
		
		If nTpMov == 1 //ENTRADA
			cItemF2ZMsg := ",Item:"+(cAliasTMP)->(FT_ITEM)

			oApur:SetAlqTrib(nAliq)
			oApur:cAlqBas := oApur:VldAlqBasic()
			cCodCon := oApur:CodCred()
		ElseIf nTpMov == 2 //SAIDA
			cCodCon := oApur:CodCon()
		EndIf

		cORI_NFORI   := Alltrim((cAliasTMP)->ORI_NFORI)
		cORI_SERORI  := Alltrim((cAliasTMP)->ORI_SERORI)
		cORI_CLIEFOR := Alltrim((cAliasTMP)->ORI_CLIEFOR)
		cORI_LOJA    := Alltrim((cAliasTMP)->ORI_LOJA)
		cORI_ITEMORI := Alltrim((cAliasTMP)->ORI_ITEMORI)
		cFTFILIAL    := Alltrim((cAliasTMP)->SUB_FILIAL)
		
		cChvNum := cORI_NFORI+cORI_SERORI+cORI_CLIEFOR+cORI_LOJA+cORI_ITEMORI
		
		cF2ZMsg := "CTE Substituído Nr.:"+cORI_NFORI+",Série:"+cORI_SERORI+",Item:"+cORI_ITEMORI+", Filial:"+cFTFILIAL+" ,"
		cF2ZMsg += "CTE Substituto Nr.:"+(cAliasTMP)->(SUB_NOTA)+",Série:"+(cAliasTMP)->(SUB_SERIE)+cItemF2ZMsg

		aAdd(aDadosF2Z[nPosF2Z], cFilMatriz) /*F2Z_FILIAL*/
		aAdd(aDadosF2Z[nPosF2Z], cPerApu+cTrib+cIndAju) /*F2Z_CHV*/
		aAdd(aDadosF2Z[nPosF2Z], cChvNum) /*F2Z_ID*/
		aAdd(aDadosF2Z[nPosF2Z], '01') /*F2Z_CODAJU*/ // 01=Vendas Canceladas de Receitas Tributadas em períodos anteriores
		aAdd(aDadosF2Z[nPosF2Z], cORI_NFORI+"-"+cORI_SERORI+"-"+cORI_CLIEFOR+"-"+cORI_LOJA+"-"+cORI_ITEMORI) /*F2Z_NUM*/
		aAdd(aDadosF2Z[nPosF2Z], cF2ZMsg) /*F2Z_DESCR*/
		aAdd(aDadosF2Z[nPosF2Z], StoD((cAliasTMP)->SUB_EMISSAO)) /*F2Z_DTREF*/
		aAdd(aDadosF2Z[nPosF2Z], (cAliasTMP)->ORI_CONTA) /*F2Z_CONTA*/
		aAdd(aDadosF2Z[nPosF2Z], cM0CGC) /*F2Z_CNPJ*/
		aAdd(aDadosF2Z[nPosF2Z], cTrib) /*F2Z_TRIB*/
		If lF2ZALQ
			aAdd(aDadosF2Z[nPosF2Z], nAliq) /*F2Z_ALIQ*/
		EndIf
		aAdd(aDadosF2Z[nPosF2Z], nValAju) /*F2Z_VALAJU*/
		aAdd(aDadosF2Z[nPosF2Z], StoD(cPerApu)) /*F2Z_PERAPU*/
		aAdd(aDadosF2Z[nPosF2Z], cCodCon) /*F2Z_CODCON*/
		aAdd(aDadosF2Z[nPosF2Z], '3') /*F2Z_ORIG*/ // 1-Usuario;2-Sistema;3-Lcto Ajuste Sistema // Indica a origem automática do sistema/apuração
		aAdd(aDadosF2Z[nPosF2Z], '2') /*F2Z_CONSOL*/ // 2-Não
		aAdd(aDadosF2Z[nPosF2Z], cIndAju) /*F2Z_INDAJU*/

	Next nX
Return aDadosF2Z

/*/{Protheus.doc} QrySqlName
	(Monta cache do RetSQLName dos alias para utilizar em querys)
	@type  Static Function
	@author Delleon Fernandes
	@since 12/09/2024
	@version 12.1.2310
	@return oRet, Objeto, Objeto com cache do nome da tabela no banco de dados
/*/
Static Function QrySqlName()
	Local oJRet  := JsonObject():new()

	oJRet["SF3"] := RetSqlName("SF3")
	oJRet["SFT"] := RetSqlName("SFT")
	oJRet["SB1"] := RetSqlName("SB1")
	oJRet["SA1"] := RetSqlName("SA1")
	oJRet["SF4"] := RetSqlName("SF4")
	oJRet["SF1"] := RetSqlName("SF1")
	oJRet["DT6"] := RetSqlName("DT6")
	oJRet["SE5"] := RetSqlName("SE5")

Return oJRet

/*/{Protheus.doc} TaCacheSX3
	(Monta cache do FwSX3Util():GetFieldStruct somente com o tamanho dos campos)
	@type  Static Function
	@author Delleon Fernandes
	@since 12/09/2024
	@version 12.1.2310
	@return oRet, Objeto, Objeto com cache do tamanho dos campos
/*/
Static Function TaCacheSX3()
	Local oJRet := JsonObject():new()

	oJRet["F2Z_CHV"] := FwSX3Util():GetFieldStruct( "F2Z_CHV" )[3]
	oJRet["F2Z_ID"] := FwSX3Util():GetFieldStruct( "F2Z_ID" )[3]

Return oJRet

/*/{Protheus.doc} FildF2Z
	(Define campos para ser utilizado no FWBulk da tabela F2Z)
	@type  Static Function
	@author Delleon Fernandes
	@since 19/09/2024
	@version 12.1.2310
	@param lF2ZALQ, Logico, Indica se existe ou não o campo na base de dados
	@return aFildF2Z, Array, Campos para criar a estutura do bulk
/*/
Static Function FildF2Z(lF2ZALQ)
Local aFildF2Z := {} as Array

	lF2ZALQ	:= F2Z->(FieldPos("F2Z_ALIQ")) > 0

	AaDd(aFildF2Z, {"F2Z_FILIAL"} )
	AaDd(aFildF2Z, {"F2Z_CHV"} )
	AaDd(aFildF2Z, {"F2Z_ID"} )
	AaDd(aFildF2Z, {"F2Z_CODAJU"} )
	AaDd(aFildF2Z, {"F2Z_NUM"} )
	AaDd(aFildF2Z, {"F2Z_DESCR"} )
	AaDd(aFildF2Z, {"F2Z_DTREF"} )
	AaDd(aFildF2Z, {"F2Z_CONTA"} )
	AaDd(aFildF2Z, {"F2Z_CNPJ"} )
	AaDd(aFildF2Z, {"F2Z_TRIB"} )
	If lF2ZALQ
		AaDd(aFildF2Z, {"F2Z_ALIQ"} )
	EndIf
	AaDd(aFildF2Z, {"F2Z_VALAJU"} )
	AaDd(aFildF2Z, {"F2Z_PERAPU"} )
	AaDd(aFildF2Z, {"F2Z_CODCON"} )
	AaDd(aFildF2Z, {"F2Z_ORIG"} )
	AaDd(aFildF2Z, {"F2Z_CONSOL"} )
	AaDd(aFildF2Z, {"F2Z_INDAJU"} )

Return aFildF2Z
