#Include "Protheus.ch"
#Include "RwMake.ch"
#Include "FwBrowse.ch"
#Include "FwMvcDef.ch"
#Include "TOPCONN.ch"
#INCLUDE "TBICONN.CH"
#include 'tlpp-core.th'
#include 'tlpp-rest.th'
#include 'classificadorfiscal.ch'

Namespace totvs.protheus.backoffice.fiscal.Classifier

//Chamando a classe framework.types.json
Using Namespace framework.types.json

//----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FISGetRegrasClassificador
Classe que contém as operações para chamada de Get e Post das regras retornadas pela Systax

@author  Yuri Gimenes
@since   10.08.2022
@version 1.0
/*/
//-----------------------------------------------------------------------------------------------------
Class FISGetRegrasClassificador

    data url as character

    data rest_client as object
    data rToken as character
	data lIsRest as logical
	data oStatementRegraAnterior as object

	public method new() constructor

    @Get("/GetRegras")    
    public method GetRegras()

	@Post("/PostRegras")    
    public method IntegraRegras(jIntegrConf)

	@Post("PostMultiplasRegras")
	public method IntegraMultiplasRegras()

	@Post("PostRejeitaRegras")
	public method RejeitaRegras(jBody)

	@Post("PostRejeitaMultiplasRegras")
	public method RejeitaMultiplasRegras()

	method GetIntegra(jIntegra,cParm1,cParm2)

	method RegraPost(jIntegrConfig)

	public method IntegrConfig(cMockServer)

	public method prepareQuery(cDB) as character

    method setUrl(url)

	private method AtualizaJsonAprovacao()

	@Post('regras/estornar')
	public method Estornar()	

	private method ValidaParametros() as logical

	private method ValidaRegra() as logical

	public method ProcessaEstorno() as logical

	private method GetStatus() as character

	private method AtualizaRegraAnterior(cIdCenario,cProduto,cOrigem,cPonteiroRegraAtualizacao,cDB,jRetornoSystax,cMockServer) as logical
	public method PrepareQueryRegraAnterior(cDB) as character
	private method BuscaTributosAtualizados(jRetornoSystax) as character

	public method ValidNCM(cErro,jRetorno,cIDCenario) as logical

End Class

//-------------------------------------------------------------------
/*/{Protheus.doc} New()
Método construtor da classe

@author  Yuri Gimenes
@since   10.08.2022
@version 1.0
/*/
//-------------------------------------------------------------------
method new() class FISGetRegrasClassificador

	Local aParam as array
	Local cParametro as character
	Local oParametro as object

	if ( AliasIndic('CJE') )
		aParam := {"URLREGRA2"}
		cParametro := GetConfigClassif(aParam)
		oParametro := JsonObject():New()

		If oParametro:FromJson(cParametro) == Nil
			self:seturl(oParametro:URLREGRA2)
		EndIf

		FreeObj(oParametro)

		FWFreeArray(aParam)

		self:lIsRest := FWIsInCallStack('HttpCall')
	endif

return SELF

//-------------------------------------------------------------------
/*/{Protheus.doc} GetRegras()
Método para chamada de função de Get de regras disponíveis no Protheus

Recno utilizado como ponteiro de paginação
        
@author  Yuri Gimenes
@since   10.08.2022
@version 1.0
/*/
//-------------------------------------------------------------------
method GetRegras() class FISGetRegrasClassificador

Local cQry          := ""
Local oJBody        := JsonObject():New()
Local oJBodyDt      := JsonObject():New()
Local jQuery		:= JsonObject():New()
Local oJsonRegra	:= Nil
Local oJsRegraNw	:= Nil
Local nReg			as integer
Local cJson			as character
Local nRegIni		as integer
Local nRegFim		:= 0
Local filGroup		as character
Local cStatus		as character
Local oStatement	as object
Local cAliasRegr	as character
Local nPage			as integer
Local nPageSize		as integer
Local nCount        as integer
Local lIntegAuto	as logical
Local lJsApro		as logical

DbSelectArea('CJB')
lJsApro := CJB->(FieldPos('CJB_JSAPRO')) > 0
CJB->(DbCloseArea())

If ( self:lIsRest )
	jQuery := oRest:GetQueryRequest()

	nPage       := IIF(jQuery['page'] <> Nil,Val(jQuery['page']), 1 )
	nPageSize   := IIF(jQuery['pageSize'] <> Nil,Val(jQuery['pageSize']), 15 )
	filGroup    := IIF(jQuery['filGroup'] <> Nil .and. !('*' $ jQuery['filGroup']) , jQuery['filGroup'], '')

	nRegIni := ( ( nPage - 1 ) * nPageSize ) + 1
	nRegFim := nPage * nPageSize
EndIf

cQry := self:prepareQuery(Upper(TCGetDB())) 

If ( !Empty(filGroup) .And. 'status: ' $ filGroup) 

    If ('status: ' + Lower(STR0110) $ filGroup) //"Recusada"
        cStatus += "R,"
	EndIf

    If ('status: ' + Lower(STR0112) $ filGroup) //"Inativa"
        cStatus += "I,"
    EndIf

    If ('status: ' + Lower(STR0111) $ filGroup) //"Suspensa"
        cStatus += "S,"
    EndIf

    If ('status: ' + Lower(STR0109) $ filGroup) //"Aprovada"
        cStatus += "AP,"
    EndIf

    If ('status: ' + NoAcento(Lower(STR0113)) $ filGroup) //"Aguardando Aprovação"
        cStatus += "AA,"
    EndIf

    If ('status: ' + Lower(STR0161) $ filGroup) //"Rejeitada"
        cStatus += "RE,"
    EndIf

	cStatus := Substr(cStatus, 1, Len(cStatus) - 1)

	cQry += " AND CJB_STATUS IN " + FormatIn(cStatus,",") + " "

ElseIf (!Empty(filGroup) .And. !('status: ' $ filGroup))

	cQry += " AND ( "
	cQry += " 	UPPER(CJB_IDCENA) LIKE '%" + Upper(filGroup) + "%' OR " 
	cQry += " 	UPPER(CJB_DTAPRO) LIKE '%" + Upper(filGroup) + "%' OR " 
	cQry += " 	UPPER(CJB_HRAPRO) LIKE '%" + Upper(filGroup) + "%' OR " 
	cQry += " 	UPPER(CJB_PRODUT) LIKE '%" + Upper(filGroup) + "%' OR " 
	cQry += " 	UPPER(CJB_ORIGEM) LIKE '%" + Upper(filGroup) + "%' "
	cQry += " ) "

ElseIf ( !self:lIsRest )
	cQry += " AND CJB_STATUS NOT IN ('AP') "
EndIf

cQry += " ) CJB "

If nRegIni > 0 .And. nRegFim > 0
	cQry += " WHERE LINE_NUMBER BETWEEN " + cValTochar(nRegIni) + " AND " + cValTochar(nRegFim + 1) + "	" //Soma mais um registro para retorno do HasNext
EndIf


oStatement := FWPreparedStatement():New( ChangeQuery(cQry) )

oStatement:setString(1, xFilial("CJB"))

cQry := oStatement:getFixQuery()

cAliasRegr := MPSysOpenQuery(cQry)

oJBody["regras"] := {}

lIntegAuto := FWIsInCallStack('IntegrConfig') // Integração automática executada ao abrir o programa da Classificação Tributária by Systax

While (cAliasRegr)->(!EoF()) .And. ( nCount < nPageSize .Or. lIntegAuto )
	nCount++

	oJsonRegra 	:= JsonObject():New()
	oJsRegraNw 	:= JsonObject():New()
	oJBodyDt	:= JsonObject():New()

	oJBodyDt['recno'] 		:= (cAliasRegr)->Recno
	oJBodyDt['filial'] 		:= AllTrim((cAliasRegr)->CJB_FILIAL)
	oJBodyDt['cenario'] 	:= AllTrim((cAliasRegr)->CJB_IDCENA)
	oJBodyDt['dta_apro']	:= DtoC(StoD(AllTrim((cAliasRegr)->CJB_DTAPRO)))
	oJBodyDt['hra_apro'] 	:= AllTrim((cAliasRegr)->CJB_HRAPRO)
	oJBodyDt['produto'] 	:= AllTrim((cAliasRegr)->CJB_PRODUT)
	oJBodyDt['origem'] 		:= AllTrim((cAliasRegr)->CJB_ORIGEM)
	oJBodyDt['ponteiro']	:= AllTrim((cAliasRegr)->CJB_PTSYS)
	oJBodyDt['jsapro'] 		:= ''

	if ( lJsApro )
		oJBodyDt['jsapro']	:= AllTrim((cAliasRegr)->JSON_APRO)
	endif

	If Empty((cAliasRegr)->CJB_STSRET)
		oJBodyDt['regra_atualizada']	:= STR0319 //"Não"
	Else
		oJBodyDt['regra_atualizada']	:= STR0318 // "Sim
	EndIf

	//------------------------------+
	// Status da regra no Protheus  |
	// CJB_STATUS                   |
	// R = Recusada                 |
	// I = Inativa                  |
	// S = Suspensa                 |
	// AP = Aprovada                |
	// AA = Aguardando Aprovação    |
	// RE = Rejeitada			    |
	//------------------------------+
	oJBodyDt['status'] := AllTrim((cAliasRegr)->CJB_STATUS)
	oJBodyDt['jsregra'] := {}
	cJson := AllTrim((cAliasRegr)->JSON)
	oJsonRegra:FromJSON( cJson )
	aadd(oJBodyDt['jsregra'],oJsonRegra['cenario'][1])

	If !Empty((cAliasRegr)->JSON_NEW)

		oJBodyDt['jsnew'] := {}
		cJson := AllTrim((cAliasRegr)->JSON_NEW)
		oJsRegraNw:FromJSON( cJson )
		aadd(oJBodyDt['jsnew'],oJsRegraNw['cenario'][1])

	EndIf

	nReg++
	
	If nReg == 100
		oJBody['registros'] := nReg
	EndIf
    
    (cAliasRegr)->(DbSkip())

	aadd(oJBody["regras"],oJBodyDt)

	FREEOBJ( oJBodyDt )
	FREEOBJ( oJsonRegra )
	FREEOBJ( oJsRegraNw )

End

FreeObj(oStatement)

If len(oJBody["regras"]) > 0
    oJBody["success"] :=.T.
else
    oJBody["success"] := .F.
EndIF

oJBody["hasNext"] := !(cAliasRegr)->(EoF())

(cAliasRegr)->( DBCloseArea() )

If ( self:lIsRest )
	Return oRest:SetResponse( oJBody )
EndIf

Return oJBody

//-------------------------------------------------------------------
/*/{Protheus.doc} IntegraRegras()
Método para chamada de função de Post para integração de Regras
        
@author  Yuri Gimenes
@since   10.08.2022
@version 1.0
/*/
//-------------------------------------------------------------------
method IntegraRegras(jIntegrConf) class FISGetRegrasClassificador

Local oBody     		:= JsonObject():New() as json
Local oJBody    		:= JsonObject():New() as json
Local jIntegra			:= JsonObject():New() as json
Local oRegra			:= JsonObject():New() as json
Local oJsonRegra		:= JsonObject():New() as json
Local aIpiEsc			:= {} as array
Local aIpiAli			:= {} as array
Local aIpiBas			:= {} as array
Local nTamCJBIDCena		as numeric
Local nTamCJBProdut		as numeric
Local nTamCJBOrigem		as numeric
Local nTamCJBStatus		as numeric
Local nTamCJBPtSys		as numeric
Local cCenario  		as character
Local cProduto  		as character
Local cOrigem   		as character
Local cStatus   		as character
Local cPonteiro   		as character
Local cDB   			:= Upper(TCGetDB()) as character
Local cJson     		as character
Local cHrApro			as character
Local lIntIPI			as Logical
Local lAutomacao		as logical
Local jQuery        	as json
Local jBody         	as character
Local dDtApro			as date
Local cMockServer		as character
Local aJsonEscr			as array
Local aJsonAliq			as array
Local aJsonBase			as array
Local oRetCST			as object
Local oRetAli			as object
Local oRetBas			as object
Local oRetReg			as object
Local cPathAliqZero		as character
Local aRegisterAliquot 	as array
Local aRegisterBase    	as array
Local oNCM             	as object
Local jAprovacao		as json
Local lOk				:= .T. as logical
Local cRelease      	:= GetRpoRelease() as character

if ( self:lIsRest .And. Valtype(jIntegrConf) == 'U' )
	
	jBody 	:= oRest:getBodyRequest()
	jQuery  := oRest:GetQueryRequest()

	If Valtype(jQuery['mockserver']) == 'C'
		cMockServer := jQuery['mockserver']
	EndIf

	If Valtype(jQuery['endpoint']) == 'C'
		cPathAliqZero := jQuery['endpoint']
	EndIf

	oBody:FromJSON(jBody)

Else

	if ( self:lIsRest )
		jQuery := oRest:GetQueryRequest()

		If Valtype(jQuery['mockserver']) == 'C'
			cMockServer := jQuery['mockserver']
		EndIf	
	endif

	oBody := jIntegrConf

	if ( oBody:HasProperty('mockserver') )
		cMockServer := oBody['mockserver']
	endif

EndIf	

self:GetIntegra(@jIntegra,"INTEGRAREGRA","INTEGRANCM")

lAutomacao := oBody:hasProperty("automacao")

nTamCJBIDCena := FWSX3Util():GetFieldStruct('CJB_IDCENA')[3]
nTamCJBProdut := FWSX3Util():GetFieldStruct('CJB_PRODUT')[3]
nTamCJBOrigem := FWSX3Util():GetFieldStruct('CJB_ORIGEM')[3]
nTamCJBStatus := FWSX3Util():GetFieldStruct('CJB_STATUS')[3]
nTamCJBPtSys  := FWSX3Util():GetFieldStruct('CJB_PTSYS')[3]

If ( oBody:hasProperty("cenario") )
	cCenario := PadR(oBody:GetJsonText("cenario"), nTamCJBIDCena)
EndIf

If ( oBody:hasProperty("produto") )
	cProduto := PadR(oBody:GetJsonText("produto"), nTamCJBProdut)
EndIf

If ( oBody:hasProperty("origem") )
	cOrigem := PadR(oBody:GetJsonText("origem"), nTamCJBOrigem)
EndIf

If ( oBody:hasProperty("status") )
	cStatus := PadR(oBody:GetJsonText("status"), nTamCJBStatus)
EndIf

If ( oBody:hasProperty("ponteiro") )
	cPonteiro := PadR(oBody:GetJsonText("ponteiro"), nTamCJBPtSys)
EndIf

If !Empty(cCenario) .and. !Empty(cProduto) .and. !Empty(cOrigem) .and. !Empty(cPonteiro) .and. !Empty(cStatus)
	
	DbSelectArea("CJB")
	CJB->(DbSetOrder(1)) // CJB_FILIAL+CJB_IDCENA+CJB_PRODUT+CJB_ORIGEM+CJB_PTSYS
	If CJB->(MsSeek(FWxFilial('CJB') + cCenario + cProduto + cOrigem + cPonteiro))

		If !(CJB->CJB_STATUS == "AP")

			jAprovacao := JsonObject():New()
			jAprovacao['regrasPorNCM'] := {}
			jAprovacao['regrasDeBase'] := {}
			jAprovacao['regrasDeAliquota'] := {}
			jAprovacao['regrasDeEscrituracao'] := {}
			jAprovacao['regrasDeCalculo'] := {}
			jAprovacao['perfisDeOrigemEDestino'] := {}
			jAprovacao['perfisDeOperacao'] := {}

			If !Empty(CJB->CJB_STSRET)
				oRegra:FromJson(CJB->CJB_JSRGNW)

				if ( cRelease > '12.1.2310' )
					lOk := .F.
					oJBody['success'] := .F.
					oJBody['message'] := STR0320 // "Erro ao aprovar a regra de atualização."

					if ( self:AtualizaRegraAnterior(cCenario, cProduto, cOrigem, cPonteiro, cDB, oRegra['cenario'][1]['retorno'][1], cMockServer) )
						lOk := .T.
					endif
				endif
			else
				oRegra:FromJson(CJB->CJB_JSREGR)
			EndIf

			//------------------------------+
			// Status da regra no Protheus  |
			// CJB_STATUS                   |
			// R = Recusada                 |
			// I = Inativa                  |
			// S = Suspensa                 |
			// AP = Aprovada                |
			// AA = Aguardando Aprovação    |
			// RE = Rejeitada    			|
			//------------------------------+

			If lOk .And. oRegra["cenario"][1]["retorno"][1]:hasProperty("ipi") .and. cStatus == "AP" .and. oRegra["cenario"][1]["retorno"][1]['ipi']:hasProperty('aliquota')
				//Se for Aprovada, a regra baixada da systax será integrada ao sistema

				// Grava a Regra de Escrituração
				oRetCST := FISGravaCST():New()
				aIpiEsc := oRetCST:FISGetDados(oRegra,.T.)
				self:AtualizaJsonAprovacao('regrasDeEscrituracao', @jAprovacao, oRetCST:aEscrituracoes)
				FreeObj(oRetCST)

				// Grava a Regra de Aliquota
				oRetAli := FISGravAliquota():New()		
				aIpiAli := oRetAli:FISGetDados(oRegra,&(jIntegra:GetJsonText("integrancm")),.T.,cMockServer,cPathAliqZero)
				self:AtualizaJsonAprovacao('regrasDeAliquota', @jAprovacao, oRetAli:aAliquotas)
				FreeObj(oRetAli)

				// Grava a regra de base de calculo
				oRetBas := FISGravaBase():New()
				aIpiBas := oRetBas:FISGetDados(oRegra,.T.,,aIpiAli,cMockServer) 
				self:AtualizaJsonAprovacao('regrasDeBase', @jAprovacao, oRetBas:aBases)
				FreeObj(oRetBas)

				If (Len(aIpiEsc) > 0 .and. Len(aIpiAli) > 0 .and. Len(aIpiBas) > 0)

					oRetReg := FISGravaRegra():New()
					oJsonRegra := oRetReg:FISGetDados(oRegra,aIpiAli,aIpiBas,aIpiEsc,.T.)
					self:AtualizaJsonAprovacao('regrasDeCalculo', @jAprovacao, oRetReg:aRegras)
					self:AtualizaJsonAprovacao('perfisDeOrigemEDestino', @jAprovacao, oRetReg:aOrigensEDestinos)
					self:AtualizaJsonAprovacao('perfisDeOperacao', @jAprovacao, oRetReg:aOperacoes)

					FreeObj(oRetReg)

					lIntIPI := .T.

				EndIf

			EndIf

			If lOk .And. cStatus == "AP" 
				//Se for Aprovada, a regra baixada da systax será integrada ao sistema
				//Realiza cadastro de NCM
				oNCM := IntegrativeClassifierSystax():New()				
				If lIntIPI
					If oJsonRegra:HasProperty("retorno") .And. !Empty(oJsonRegra["retorno"]) .And. oJsonRegra["retorno"][1]:HasProperty("codigo") .And. oJsonRegra["retorno"][1]['codigo'] != Nil
						oNCM:setCodeTaxIPI(oJsonRegra["retorno"][1]['codigo'])
					Endif
				Endif
				oNCM:setMockServer(cMockServer)
				oNCM:setData(oRegra:toJson())

				// Verifica se houve algum erro na pré-validação que monta os dados para a gravação da Regra por NCM
				lOk := self:ValidNCM(oNCM:getError(), @oJBody, cCenario)

				If ( lOk )
					oNCM:recordTaxes()

					// Verifica se houve algum erro na gravação dos dados na Regra por NCM
					lOk := self:ValidNCM(oNCM:getError(), @oJBody, cCenario)

					If ( lOk )															
						aRegisterAliquot := oNCM:getRegisterAliquot()
						aRegisterBase := oNCM:getRegisterBase()
						self:AtualizaJsonAprovacao('regrasPorNCM', @jAprovacao, oNCM:aNCMs)
						self:AtualizaJsonAprovacao('regrasDeBase', @jAprovacao, oNCM:aBases)
						self:AtualizaJsonAprovacao('regrasDeAliquota', @jAprovacao, oNCM:aAliquotas)

						// Grava a Regra de Escrituração
						oRetCST := FISGravaCST():New()
						aJsonEscr := oRetCST:FISGetDados(oRegra)
						self:AtualizaJsonAprovacao('regrasDeEscrituracao', @jAprovacao, oRetCST:aEscrituracoes)

						// Grava a Regra de Aliquota
						oRetAli := FISGravAliquota():New()
						aJsonAliq := oRetAli:FISGetDados(oRegra,&(jIntegra:GetJsonText("integrancm")),,cMockServer,cPathAliqZero) 
						self:AtualizaJsonAprovacao('regrasDeAliquota', @jAprovacao, oRetAli:aAliquotas)

						// Grava a regra de base de calculo
						oRetBas := FISGravaBase():New()
						IF !lIntIPI
							aJsonBase := oRetBas:FISGetDados(oRegra,,,,cMockServer)
						Else
							If oJsonRegra:HasProperty("retorno") .And. !Empty(oJsonRegra["retorno"]) .And. oJsonRegra["retorno"][1]:HasProperty("codigo") .And. oJsonRegra["retorno"][1]['codigo'] != Nil
								aJsonBase := oRetBas:FISGetDados(oRegra,.F.,oJsonRegra["retorno"][1]['codigo'],,cMockServer) 
							EndIF
						EndIF

						self:AtualizaJsonAprovacao('regrasDeBase', @jAprovacao, oRetBas:aBases)

						If ((!Empty(aJsonAliq) .And. !Empty(aJsonBase) .And. !Empty(aJsonEscr)) .Or. (lAutomacao))

							oRetReg := FISGravaRegra():New()
							oJsonRegra := oRetReg:FISGetDados(oRegra,aJsonAliq,aJsonBase,aJsonEscr,,aRegisterAliquot, aRegisterBase)
							self:AtualizaJsonAprovacao('regrasDeCalculo', @jAprovacao, oRetReg:aRegras)
							self:AtualizaJsonAprovacao('perfisDeOrigemEDestino', @jAprovacao, oRetReg:aOrigensEDestinos)
							self:AtualizaJsonAprovacao('perfisDeOperacao', @jAprovacao, oRetReg:aOperacoes)

							If (len(oJsonRegra['retorno']) > 0) .Or. (lAutomacao)

								//-------------------------------------------+
								//Atualizo a tabela CJB
								//-------------------------------------------+
								RecLock("CJB", .F.)

									CJB->CJB_STATUS := cStatus
									IF CJB->CJB_STSRET == "2" //"RA"
										CJB->CJB_JSREGR := CJB->CJB_JSRGNW
									EndIF

									dDtApro := dDataBase
									cHrApro := TIME()

									If (lAutomacao)
										dDtApro := CToD("22/09/2023")
										cHrApro := "12:00:00"
									EndIf

									CJB->CJB_DTAPRO := dDtApro
									CJB->CJB_HRAPRO	:= cHrApro

									if ( CJB->(FieldPos('CJB_JSAPRO')) > 0 )
										CJB->CJB_JSAPRO := jAprovacao:ToJson()
									endif

								CJB->(MsUnlock())
								//-------------------------------------------+

								oJBody['success'] := .T.
								oJBody['message'] := STR0162 //"Regras aprovadas com sucesso"

							EndIf

							FreeObj(oJsonRegra)

						Else
							oJBody['success'] := .F.
							oJBody['message'] := STR0195 //"Não foi possível criar a regra selecionada"
						EndIf
					EndIf
				EndIf

				oNCM:destroy()				
				FWFreeVar(oNCM)
				FWFreeVar(oRegra)				

			ElseIf lOk .And. AllTrim(cStatus) $ "R|I|S"
			//Se for recusada, Inativada ou Suspensa a regra baixada da systax não será integrada ao sistema.
			//Caso a regra esteja suspensa ou inativada, essa não poderá mais receber atualizações

				RecLock("CJB", .F.)
				
					CJB->CJB_STSRET := ""
					CJB->CJB_STATUS := cStatus
					CJB->CJB_JSRGNW := trim("")

				CJB->(MsUnlock())

				oJBody['success'] := .T.
				oJBody['message'] := STR0196 //"Regra atualizada com sucesso!"

			ElseIf lOk .And. !(&(jIntegra:GetJsonText("integraregra"))) 

				oJBody['success'] := .F.
				oJBody['message'] := STR0167 //"Verifique os parâmetros enviados"

			EndIf

			FWFreeVar(jAprovacao)
		
		Else

			oJBody['success'] := .F.
			oJBody['message'] := STR0172 //"A regra selecionada está aprovada"

		EndIf

	Else

		oJBody['success'] := .F.
		oJBody['message'] := STR0166 //"Regra não encontrada"

	EndIf
else
	oJBody['success'] := .F.
	oJBody['message'] := STR0197 //"Json inválido"
EndIf

CJB->(DbCloseArea())

cJson := oJBody:toJson()

FreeObj(oBody)
FreeObj(oJBody)
FreeObj(jIntegra)
FreeObj(oRetCST)
FreeObj(oRetAli)
FreeObj(oRetBas)
FreeObj(oRetReg)

FWFreeArray(aIpiEsc)
FWFreeArray(aIpiAli)
FWFreeArray(aIpiBas)
FWFreeArray(aJsonEscr)
FWFreeArray(aJsonAliq)
FWFreeArray(aJsonBase)

If ( ValType(self:oStatementRegraAnterior) == 'O' )
	If ( !FWIsInCallStack('AtualizaRegraAnterior') )
		self:oStatementRegraAnterior:Destroy()
		self:oStatementRegraAnterior := nil
	EndIf
EndIf

If ( self:lIsRest .And. ValType(jIntegrConf) == "U" )
	Return oRest:SetResponse( cJson )
EndIf

Return cJson

//-------------------------------------------------------------------
/*/{Protheus.doc} GetIntegra()
Methodo que irá validar os parâmetros da tabela CJE para integração
com o Configurador de Tributos
        
@author  Yuri Gimenes
@since   10.08.2022
@version 1.0
/*/
//-------------------------------------------------------------------

METHOD GetIntegra(jIntegra,cParm1,cParm2) class FISGetRegrasClassificador

Local cQry 			:= ""
Local oStatement	as object
Local cAliasParam	as character

cQry += " SELECT CJE_PARAM, CJE_CONTEU FROM "+ RetSqlName("CJE") +" CJE "
cQry += " WHERE CJE_FILIAL = ? "
cQry += " AND CJE_PARAM IN (?,?) "
cQry += " AND CJE_TIPO = '1' "
cQry += " AND D_E_L_E_T_ = ' ' "

oStatement := FWPreparedStatement():New( ChangeQuery(cQry) )

oStatement:setString(1, xFilial("CJE"))
oStatement:setString(2, cParm1)
oStatement:setString(3, cParm2)

cQry := oStatement:getFixQuery()

cAliasParam := MPSysOpenQuery(cQry)

While !(cAliasParam)->(Eof())

	IF AllTrim((cAliasParam)->CJE_PARAM) == "INTEGRAREGRA"

		jIntegra['integraregra'] := AllTrim((cAliasParam)->CJE_CONTEU)

	elseif AllTrim((cAliasParam)->CJE_PARAM) == "INTEGRANCM"

		jIntegra['integrancm'] := AllTrim((cAliasParam)->CJE_CONTEU)

	EndIf

	(cAliasParam)->(DbSkip())

End

(cAliasParam)->(DbCloseArea())
FreeObj(oStatement)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} IntegrConfig()
Metodo que irá integrar multiplas regras com o Configurador de Tributos

@author  Erich Buttner
@since   29.08.2023
@version 1.0
@param cMockServer, character, Indica o mockserver a ser utilizado
/*/
//-------------------------------------------------------------------
METHOD IntegrConfig(cMockServer as character) class FISGetRegrasClassificador

Local jRegras		:= self:GetRegras() as json
Local nE			:= 0 as numeric
Local jIntegrConfig	:= JsonObject():New() as json
Local jInteg		as json
Local lAutomato		as logical

Default cMockServer := ''

lAutomato := !Empty(cMockServer)

jIntegrConfig['cenarios'] := {}

For nE := 1 to Len(jRegras['regras'])

	If !(jRegras['regras'][nE] == Nil)
		
		jInteg := JsonObject():New()
		jInteg['empresa'] := cEmpant
		jInteg['filial'] := jRegras['regras'][nE]['filial']
		jInteg['produto'] := jRegras['regras'][nE]['produto']
		jInteg['cenario'] := jRegras['regras'][nE]['cenario']
		jInteg['origem'] := jRegras['regras'][nE]['origem']
		jInteg['status'] := 'AP'
		jInteg['ponteiro'] := jRegras['regras'][nE]['ponteiro']

		If ( lAutomato )
			jInteg['filial'] := 'XIFIS26'
			jInteg['produto'] := 'MP0000000000000000000000000001'
			jInteg['cenario'] := '2925108'
			jInteg['origem'] := '0'
			jInteg['ponteiro'] := '20250225081039'
			jInteg['mockserver'] := cMockServer
		EndIf

		aadd(jIntegrConfig['cenarios'],jInteg)

		FreeObj(jInteg)

		// Desvio para processar apenas um único registro na automação
		// Antes estava processando todos os registros da tabela CJB, gerando lentidão na automação
		If ( lAutomato )
			Exit
		EndIf
	EndIf

Next nE

self:RegraPost(jIntegrConfig)

FreeObj(jIntegrConfig)
FreeObj(jRegras)

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} RegraPost()
Methodo que irá integrar multiplas regras com o Configurador de Tributos

        
@author  Erich Buttner
@since   29.08.2023
@version 1.0
/*/
//-------------------------------------------------------------------

METHOD RegraPost(jIntegrConfig, aResponses) class FISGetRegrasClassificador

Local nE			as integer
Local cJsonResponse	as character

Default aResponses	:= {}

For nE := 1 to Len(jIntegrConfig['cenarios'])

	If (jIntegrConfig['cenarios'][nE] != Nil)

		cJsonResponse := ::IntegraRegras(jIntegrConfig['cenarios'][nE])

		Aadd(aResponses, cJsonResponse)

	EndIf

Next nE

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} IntegraMultiplasRegras()
Método que irá integrar multiplas regras com o Configurador de Tributos
@author  Juliano Fernandes
@since   11.09.2023
@version 1.0
/*/
//-------------------------------------------------------------------
Method IntegraMultiplasRegras() Class FISGetRegrasClassificador

	Local oBody			:= JsonObject():New()
	Local oJBody		:= JsonObject():New()
	Local jQuery		as json
	Local nE 			as integer
	Local aResponses	:= {} as array
	Local lSuccess		:= .T. as logical
	Local oResponse		as object
	Local cJson			as character

	jQuery := oRest:GetBodyRequest()

	oBody:FromJSON(jQuery)

	::RegraPost(oBody, @aResponses)

	For nE := 1 To Len(aResponses)
		oResponse := JsonObject():New()

		oResponse:FromJSON(aResponses[nE])

		If (!oResponse["success"])
			lSuccess := .F.
			FreeObj(oResponse)
			Exit
		EndIf

		FreeObj(oResponse)
	Next nE

	oJBody["success"] := lSuccess
	oJBody["message"] := IIf(lSuccess, STR0162, STR0163) // "Regras aprovadas com sucesso" "Erro na aprovação de uma ou mais regras"

	cJson := oJBody:toJson()

	FreeObj(oBody)
	FreeObj(oJBody)


	FWFreeArray(aResponses)

Return oRest:SetResponse(cJson)				 

//-------------------------------------------------------------------
/*/{Protheus.doc} setUrl
Método para passar a senha do usuário que irá utilizar a api.
@author  Juliano Fernandes
@since   13.09.2023
@version 1.0
/*/
//-------------------------------------------------------------------
Method setUrl(Url) Class FISGetRegrasClassificador

    Self:Url := Url

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} RejeitaRegras()
Método que irá rejeitar regras com o Configurador de Tributos
@author  Juliano Fernandes
@since   13.09.2023
@version 1.0
/*/
//-------------------------------------------------------------------
Method RejeitaRegras(jBody) Class FISGetRegrasClassificador

	Local oBody				:= JsonObject():New()
	Local oRegra			:= JsonObject():New()
	Local oResult			:= Nil
	Local oResponse			:= JsonObject():New()		
	Local oData				:= Nil
	Local oItens			:= Nil
	Local aHeader			:= {}
	Local jQuery			as json
	Local jQueryParams		:= oRest:GetQueryRequest()
	Local cCenario			as character
	Local cProduto			as character
	Local cOrigem			as character
	Local cPonteiro			as character
	Local cIdCenario		as character
	Local cNatureza			as character
	Local cUfOrigem			as character
	Local cUfDestino		as character
	Local cCodProduto		as character
	Local cOrigemProduto	as character
	Local cNCM				as character
	Local cResult			as character
	Local cResponse			as character
	Local nI				as integer
	Local nJ				as integer
	Local nTamCJBIDCena		as integer
	Local nTamCJBProdut		as integer
	Local nTamCJBOrigem		as integer
	Local nTamCJBPtSys		as integer
	Local cUrl				:= ::url
	Local cMockServer		:= ""
	Local cPath				:= "/api/regras/validar"

	If ( self:lIsRest .And. ValType(jBody) == "U" )
		jQuery := oRest:GetBodyRequest()

		oBody:FromJSON(jQuery)

		FreeObj(jQuery)
	Else
		oBody := jBody
	EndIf

	If (ValType(jQueryParams['mockserver']) == "C")
		cMockServer := jQueryParams['mockserver']
		cUrl := cMockServer
	EndIf

	If (ValType(jQueryParams['endpoint']) == "C")
		cPath := jQueryParams['endpoint']
	EndIf

	::rest_client := FwRest():New(cUrl)
	::rest_client:setPath(cPath)
	::rToken := AllTrim(ConsultTok(cUserName,cMockServer))

	If ( !Empty(::rToken) )
		Aadd(aHeader, "Content-Type: application/json; charset=UTF-8")
		Aadd(aHeader, "Content-Length: <calculated when request is sent>")
		Aadd(aHeader, "Accept: */*")
		Aadd(aHeader, "User-Agent: Chrome/65.0 (compatible; Protheus " + GetBuild() + ")")
		Aadd(aHeader, "Authorization: Bearer " + ::rToken)

		nTamCJBIDCena := FWSX3Util():GetFieldStruct('CJB_IDCENA')[3]
		nTamCJBProdut := FWSX3Util():GetFieldStruct('CJB_PRODUT')[3]
		nTamCJBOrigem := FWSX3Util():GetFieldStruct('CJB_ORIGEM')[3]
		nTamCJBPtSys  := FWSX3Util():GetFieldStruct('CJB_PTSYS')[3]

		If ( oBody:hasProperty("cenario") )
			cCenario := PadR(oBody:GetJsonText("cenario"), nTamCJBIDCena)
		EndIf
		
		If ( oBody:hasProperty("produto") )
			cProduto := PadR(oBody:GetJsonText("produto"), nTamCJBProdut)
		EndIf
		
		If ( oBody:hasProperty("origem") )
			cOrigem := PadR(oBody:GetJsonText("origem"), nTamCJBOrigem)
		EndIf

		If ( oBody:hasProperty("ponteiro") )
			cPonteiro := PadR(oBody:GetJsonText("ponteiro"), nTamCJBPtSys)
		EndIf		
	
		If (!Empty(cCenario) .And. !Empty(cProduto) .And. !Empty(cOrigem) .And. !Empty(cPonteiro))
			
			DbSelectArea("CJB")
			CJB->(DbSetOrder(1)) // CJB_FILIAL+CJB_IDCENA+CJB_PRODUT+CJB_ORIGEM+CJB_PTSYS
			If (CJB->(MsSeek(FWxFilial('CJB') + cCenario + cProduto + cOrigem + cPonteiro)))
				oRegra:FromJson(CJB->CJB_JSREGR)

				oData := JsonObject():New()
				oData["itens"] := {}

				For nI := 1 To Len(oRegra["cenario"])
					cIdCenario	:= oRegra["cenario"][nI]["id_cenario"]
					cNatureza	:= oRegra["cenario"][nI]["cod_natureza_operacao"]
					cUfOrigem	:= oRegra["cenario"][nI]["uf_origem"]
					cUfDestino	:= oRegra["cenario"][nI]["uf_destino"]

					For nJ := 1 To Len(oRegra["cenario"][nI]["retorno"])
						cCodProduto		:= oRegra["cenario"][nI]["retorno"][nJ]["cod_prod"]
						cOrigemProduto	:= oRegra["cenario"][nI]["retorno"][nJ]["origem_produto"]
						cNCM			:= oRegra["cenario"][nI]["retorno"][nJ]["ncm"]

						oItens 					:= JsonObject():New()
						oItens["id"]			:= 0
						oItens["acao"]			:= "R"
						oItens["cenario"]		:= cIdCenario
						oItens["natureza"]		:= cNatureza
						oItens["ufOrigem"]		:= cUfOrigem
						oItens["ufDestino"]		:= cUfDestino
						oItens["perfilOrigem"]	:= ""
						oItens["perfilDestino"]	:= ""
						oItens["munOrigem"]		:= ""
						oItens["munDestino"]	:= ""
						oItens["finalidade"]	:= ""
						oItens["codProduto"]	:= cCodProduto
						oItens["origemProduto"]	:= cOrigemProduto
						oItens["ncm"]			:= cNCM
						oItens["extipi"]		:= ""
						oItens["ean"]			:= ""
						oItens["data"]			:= ""

						Aadd(oData["itens"],oItens)

						FreeObj(oItens)
					Next nJ
				Next nI

				FreeObj(oRegra)

				::rest_client:SetPostParams(oData:ToJson())

				If (::rest_client:Post(aHeader))
					cResult := ::rest_client:GetResult()
					oResult := JsonObject():New()

					If (oResult:FromJson(cResult) == Nil)
						RecLock("CJB", .F.)

						CJB->CJB_STATUS := "RE"

						CJB->(MsUnlock())

						oResponse["success"] := .T.
						oResponse["message"] := STR0164 //"Regra rejeitada com sucesso"
					EndIf

					FreeObj(oResult)
				Else
					oResponse["success"] := .F.
					oResponse["message"] := STR0165 //"Erro no envio de informações para Systax"
				EndIf

				FreeObj(oData)

				FWFreeArray(aHeader)
			Else
				oResponse["success"] := .F.
				oResponse["message"] := STR0166 //"Regra não encontrada"	
			EndIf

			CJB->(DbCloseArea())
		Else
			oResponse["success"] := .F.
			oResponse["message"] := STR0167 //"Verifique os parâmetros enviados"
		EndIf
	EndIf

	cResponse := oResponse:ToJson()

	FreeObj(oBody)
	FreeObj(oResponse)
	FreeObj(jQueryParams)

	If ( self:lIsRest .And. ValType(jBody) == "U" )
		Return oRest:SetResponse(cResponse)
	EndIf

Return cResponse

//-------------------------------------------------------------------
/*/{Protheus.doc} RejeitaMultiplasRegras()
Método que irá rejeitar multiplas regras com o Configurador de Tributos
@author  Juliano Fernandes
@since   14.09.2023
@version 1.0
/*/
//-------------------------------------------------------------------
Method RejeitaMultiplasRegras() Class FISGetRegrasClassificador

	Local oBody			:= JsonObject():New()
	Local oJBody		:= JsonObject():New()
	Local oResponse		:= JsonObject():New()
	Local jQuery		as json
	Local cJsonResponse	as character
	Local cResponse		as character
	Local nI 			as integer
	Local lSuccess		:= .T.

	jQuery := oRest:GetBodyRequest()

	oBody:FromJSON(jQuery)

	For nI := 1 To Len(oBody["cenarios"])
		If (!(oBody["cenarios"][nI] == Nil))
			cJsonResponse := ::RejeitaRegras(oBody["cenarios"][nI])

			oResponse := JsonObject():New()

			oResponse:FromJSON(cJsonResponse)

			If (!oResponse["success"])
				lSuccess := .F.
			EndIf

			FreeObj(oResponse)
		EndIf
	Next nI

	oJBody["success"] := lSuccess
	oJBody["message"] := IIf(lSuccess, STR0168, STR0169) //"Regras rejeitadas com sucesso" "Erro na rejeição de uma ou mais regras"

	cResponse := oJBody:ToJson()

	FreeObj(oBody)
	FreeObj(oJBody)
	FreeObj(jQuery)

Return oRest:SetResponse(cResponse)				 

/*/{Protheus.doc} prepareQuery
	(long_description)
	@author user
	@since 29/12/2023
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	/*/
Method prepareQuery(cDB as character) as character class FISGetRegrasClassificador
	Local cQry as character
	Local lJsApro as logical

	DbSelectArea('CJB')
	lJsApro := CJB->(FieldPos('CJB_JSAPRO')) > 0
	CJB->(DbCloseArea())

	cQry += " SELECT CJB_FILIAL, CJB_IDCENA, CJB_DTAPRO, CJB_HRAPRO, CJB_STSRET, CJB_STATUS, CJB_PRODUT, CJB_ORIGEM, CJB.RECNO, CJB_PTSYS "

	If "ORACLE" $ cDB
		cQry += " ,UTL_RAW.CAST_TO_VARCHAR2(DBMS_LOB.SUBSTR(CJB_JSREGR, 4000,1)) JSON  "
		cQry += " ,UTL_RAW.CAST_TO_VARCHAR2(DBMS_LOB.SUBSTR(CJB_JSRGNW, 4000,1)) JSON_NEW  "

		if ( lJsApro )
			cQry += " ,UTL_RAW.CAST_TO_VARCHAR2(DBMS_LOB.SUBSTR(CJB_JSAPRO, 4000,1)) JSON_APRO  "
		endif
    ElseIf "POSTGRES" $ cDB
		cQry += " ,encode(CJB_JSREGR,'escape') JSON  "
		cQry += " ,encode(CJB_JSRGNW,'escape') JSON_NEW  "

		if ( lJsApro )
			cQry += " ,encode(CJB_JSAPRO,'escape') JSON_APRO  "
		endif
    Else
		cQry += " ,ISNULL(CAST(CAST(CJB_JSREGR AS VARBINARY(8000)) AS VARCHAR(8000)),'') AS [JSON] "
		cQry += " ,ISNULL(CAST(CAST(CJB_JSRGNW AS VARBINARY(8000)) AS VARCHAR(8000)),'') AS [JSON_NEW] "

		if ( lJsApro )
			cQry += " ,ISNULL(CAST(CAST(CJB_JSAPRO AS VARBINARY(8000)) AS VARCHAR(8000)),'') AS [JSON_APRO] "
		endif
    EndIf 

	cQry += " FROM (" 
	cQry += " SELECT ROW_NUMBER() OVER( ORDER BY CJB.R_E_C_N_O_ ) LINE_NUMBER, " 
	cQry += " R_E_C_N_O_ as Recno, CJB_FILIAL, CJB_IDCENA, CJB_DTAPRO, CJB_HRAPRO, CJB_STSRET, CJB_STATUS, CJB_PRODUT, CJB_ORIGEM, CJB_PTSYS,"
	cQry += " CJB_JSREGR, CJB_JSRGNW"
	
	if ( lJsApro )
		cQry += ", CJB_JSAPRO "
	endif
	
	cQry += " FROM " + RetSqlName("CJB") + " CJB "
	cQry += " WHERE CJB.D_E_L_E_T_ = ' ' "
	cQry += " AND CJB_FILIAL = ? "


Return cQry

/*/{Protheus.doc} AtualizaJsonAprovacao
Método responsável por atualizar o Json que contém todas as informações cadastradas ou utilizadas na aprovação da regra
@author Juliano Fernandes
@since 28/05/2024
@version 12.1.2310
/*/
method AtualizaJsonAprovacao(cChave as character, jAprovacao as json, aDados as array) class FISGetRegrasClassificador

	local i as numeric
	local j as numeric
	local lInclui as logical

	for i := 1 to Len(aDados)
		lInclui := .T.

		// Tratamento para não incluir itens duplicados
		if ( !aDados[i]['incluido'] )
			for j := 1 to Len(jAprovacao[cChave])
				if ( aDados[i]['codigo'] == jAprovacao[cChave][j]['codigo'] )
					lInclui := .F.
					exit
				endif
			next j
		endif

		if ( lInclui )
			Aadd(jAprovacao[cChave], aDados[i])
		endif
	next i

	ASize(aDados, 0)

return

/*/{Protheus.doc} Estornar

Método responsável por Estornar a aprovação da regra

@author Juliano Fernandes
@since 18/06/2024
@version 12.1.2310
/*/
method Estornar() class FISGetRegrasClassificador

	local jBody as json
	local aRegras as array
	local aRegrasEstornadas as array
	local aRegrasComErro as array
	local jHeaderResponse as json
	local jResponse as json
	local cErro as character
	local i as numeric
	local jRegra as json

	jHeaderResponse := JsonObject():New()
	jHeaderResponse['Content-Type'] := 'application/json;charset=cp1252'
	oRest:SetHeaderResponse(jHeaderResponse)

	FreeObj(jHeaderResponse)

	if ( !self:ValidaParametros(@cErro) )
		jResponse := JsonObject():New()
		jResponse['success'] := .F.
		jResponse['message'] := cErro

		oRest:SetResponse(jResponse)

		return
	endif

	jBody := JsonObject():New()
	jBody:FromJson( oRest:GetBodyRequest() )

	aRegras := jBody['regras']

	FreeObj(jBody)

	ASort(aRegras,,,{|x,y| x['cenario'] + x['produto'] + x['origem'] + x['ponteiro'] > y['cenario'] + y['produto'] + y['origem'] + y['ponteiro']})

	aRegrasEstornadas := {}
	aRegrasComErro := {}

	for i := 1 to Len(aRegras)
		jRegra := aRegras[i]

		if ( self:ValidaRegra(jRegra) )
			if ( self:ProcessaEstorno(jRegra) )
				Aadd(aRegrasEstornadas, jRegra)
			else
				Aadd(aRegrasComErro, jRegra)
			endif
		else
			Aadd(aRegrasComErro, jRegra)
		endif

		FreeObj(jRegra)
	next i

	jResponse := JsonObject():New()
	jResponse['regras'] := JsonObject():New()	

	if ( !Empty(aRegrasEstornadas) )
		jResponse['success'] := .T.

		ASort(aRegrasEstornadas,,,{|x,y| x['cenario'] + x['produto'] + x['origem'] < y['cenario'] + y['produto'] + y['origem']})

		jResponse['regras']['sucesso'] := aRegrasEstornadas
		jResponse['message'] := STR0241 //'Regra estornada com sucesso'

		if ( Len(aRegras) > 1 )
			jResponse['message'] := STR0240 //'Regras estornadas com sucesso'
		endif
	endif

	if ( !Empty(aRegrasComErro) )
		jResponse['success'] := .F.

		ASort(aRegrasComErro,,,{|x,y| x['cenario'] + x['produto'] + x['origem'] < y['cenario'] + y['produto'] + y['origem']})

		jResponse['regras']['erro'] := aRegrasComErro
		jResponse['message'] := STR0243 //'Erro ao estornar a regra'

		if ( Len(aRegras) > 1 )
			jResponse['message'] := STR0242 //'Erro ao estornar uma ou mais regras'
		endif		
	endif

	oRest:SetResponse(jResponse)
	
	FreeObj(jResponse)
	ASize(aRegrasEstornadas, 0)
	ASize(aRegrasComErro, 0)
	ASize(aRegras, 0)

return

/*/{Protheus.doc} ValidaParametros

Método responsável por validar os parâmetros enviados para estornar a aprovação da regra

@author Juliano Fernandes
@since 18/06/2024
@version 12.1.2310
/*/
method ValidaParametros(cErro as character) as logical class FISGetRegrasClassificador

	local jBody as json
	local lValid as logical
	local lAutomato as logical

	lValid := .T.
	lAutomato := IsBlind()
	jBody := JsonObject():New()

	if ( jBody:FromJson( oRest:GetBodyRequest() ) != nil )
		cErro := STR0244 //'Erro ao converter json da requisição'
		lValid := .F.
	endif
	
	if ( lValid .and. !jBody:HasProperty('regras') )
		cErro := STR0245 //'Regras não informadas'
		lValid := .F.
	endif

	if ( lValid .and. ValType(jBody['regras']) != 'A' )
		cErro := STR0245 //'Regras não informadas'
		lValid := .F.
	endif

	if ( lValid .and. Len(jBody['regras']) == 0 )
		cErro := STR0245 //'Regras não informadas'
		lValid := .F.
	endif

	DbSelectArea('CJB')
	if ( lValid .and. ( CJB->(FieldPos('CJB_JSAPRO')) == 0 .or. ( lAutomato .and. jBody:HasProperty('validaCampoJsonCJB') ) ) )
		cErro := STR0246 //'Dicionário desatualizado. Verifique as atualizações da Classificação Tributária'
		lValid := .F.
	endif
	CJB->(DbCloseArea())

	FreeObj(jBody)
	
return lValid

/*/{Protheus.doc} ValidaRegra

Método responsável por validar a regra enviada para estornar a aprovação

@author Juliano Fernandes
@since 18/06/2024
@version 12.1.2310
/*/
method ValidaRegra(jRegra as json) as logical class FISGetRegrasClassificador

	local cCenario as character
	local cProduto as character
	local cOrigem as character
	local cPonteiro as character
	local jAprovacao as json
	local lValid as logical

	lValid := .T.

	cCenario := PadR(jRegra['cenario'], FWSX3Util():GetFieldStruct('CJB_IDCENA')[3])
	cProduto := PadR(jRegra['produto'], FWSX3Util():GetFieldStruct('CJB_PRODUT')[3])
	cOrigem := PadR(jRegra['origem'], FWSX3Util():GetFieldStruct('CJB_ORIGEM')[3])
	cPonteiro := PadR(jRegra['ponteiro'], FWSX3Util():GetFieldStruct('CJB_PTSYS')[3])

	DbSelectArea('CJB')
	CJB->(DbSetOrder(1)) // CJB_FILIAL+CJB_IDCENA+CJB_PRODUT+CJB_ORIGEM+CJB_PTSYS
	
	if ( !CJB->( DbSeek( FWxFilial('CJB') + cCenario + cProduto + cOrigem + cPonteiro ) ) )
		jRegra['detalheDoErro'] := STR0166 //"Regra não encontrada"
		lValid := .F.
	endif

	if ( lValid .and. CJB->CJB_STATUS != 'AP' )
		jRegra['detalheDoErro'] := STR0247 + self:GetStatus(CJB->CJB_STATUS) //'Regra com status inválido para estorno. Status: '
		lValid := .F.
	endif		

	if ( lValid .and. Empty(CJB->CJB_JSAPRO) )
		jRegra['detalheDoErro'] := STR0248 //'O campo que contém os dados gerados na Aprovação da Regra não está preenchido. O estorno não pode ser realizado.'
		lValid := .F.		
	endif

	jAprovacao := JsonObject():New()
	if ( lValid .and. jAprovacao:FromJson(CJB->CJB_JSAPRO) != nil )
		jRegra['detalheDoErro'] := STR0249 //'Erro ao converter em json o campo que contém os dados da aprovação'
		lValid := .F.	
	endif

	if ( lValid )
		jRegra['aprovacao'] := jAprovacao
	else
		jRegra['mensagemDoErro'] := STR0250 //'A regra contém erros'
		jRegra['codigoDoRegistro'] := jRegra['cenario']
	endif

	CJB->(DbCloseArea())

	FreeObj(jAprovacao)

return lValid

/*/{Protheus.doc} ProcessaEstorno

Método responsável por processar o estorno da aprovação da regra

@author Juliano Fernandes
@since 18/06/2024
@version 12.1.2310
/*/
method ProcessaEstorno(jRegra as json) as logical class FISGetRegrasClassificador

	local i as numeric
	local jAprovacao as json
	local aRegrasPorNCM as array
	local aRegrasDeBase as array
	local aRegrasDeAliquota as array
	local aRegrasDeEscrituracao as array
	local aRegrasDeCalculo as array
	local aPerfisDeOrigemEDestino as array
	local aPerfisDeOperacao as array
	local cCenario as character
	local cProduto as character
	local cOrigem as character
	local cPonteiro as character
	local lOk as logical
	local oRegraDeCalculo as object
	local oPerfilDeOrigemEDestino as object
	local oRegraDeBase as object
	local oRegraDeAliquota as object
	local oRegraDeEscrituracao as object
	local oRegrasPorNCM as object

	begin transaction

		lOk := .T.

		jAprovacao := jRegra['aprovacao']

		aRegrasPorNCM := jAprovacao['regrasPorNCM']
		aRegrasDeBase := jAprovacao['regrasDeBase']
		aRegrasDeAliquota := jAprovacao['regrasDeAliquota']
		aRegrasDeEscrituracao := jAprovacao['regrasDeEscrituracao']
		aRegrasDeCalculo := jAprovacao['regrasDeCalculo']
		aPerfisDeOrigemEDestino := jAprovacao['perfisDeOrigemEDestino']
		aPerfisDeOperacao := jAprovacao['perfisDeOperacao']

		jRegra:DelName("aprovacao")

		FreeObj(jAprovacao)

		oRegraDeCalculo := FISGravaRegra():New()

		for i := Len(aRegrasDeCalculo) to 1 step -1
			if ( lOk .and. aRegrasDeCalculo[i]['incluido'] .and. !aRegrasDeCalculo[i]:HasProperty('erro') )
				lOk := oRegraDeCalculo:ExcluiRegraDeCalculo(aRegrasDeCalculo[i], @jRegra)
			endif
		next i

		FreeObj(oRegraDeCalculo)

		ASize(aRegrasDeCalculo, 0)

		if ( lOk )
			oRegraDeCalculo := FISGravaRegra():New()

			for i := Len(aPerfisDeOperacao) to 1 step -1
				if ( lOk .and. aPerfisDeOperacao[i]['incluido'] .and. !aPerfisDeOperacao[i]:HasProperty('erro') )
					lOk := oRegraDeCalculo:ExcluiPerfilDeOperacao(aPerfisDeOperacao[i], @jRegra)				
				endif
			next i

			FreeObj(oRegraDeCalculo)
		endif

		ASize(aPerfisDeOperacao, 0)

		if ( lOk )
			oPerfilDeOrigemEDestino := OriginAndDestinationProfile():New()

			for i := Len(aPerfisDeOrigemEDestino) to 1 step -1
				if ( lOk .and. aPerfisDeOrigemEDestino[i]['incluido'] .and. !aPerfisDeOrigemEDestino[i]:HasProperty('erro') )
					lOk := oPerfilDeOrigemEDestino:Delete(aPerfisDeOrigemEDestino[i], @jRegra)						
				endif
			next i

			FreeObj(oPerfilDeOrigemEDestino)
		endif

		ASize(aPerfisDeOrigemEDestino, 0)

		if ( lOk )
			oRegraDeBase := FISGravaBase():New()

			for i := Len(aRegrasDeBase) to 1 step -1
				if ( lOk .and. aRegrasDeBase[i]['incluido'] .and. !aRegrasDeBase[i]:HasProperty('erro') )
					lOk := oRegraDeBase:ExcluiRegraDeBase(aRegrasDeBase[i], @jRegra)							
				endif
			next i

			FreeObj(oRegraDeBase)
		endif

		ASize(aRegrasDeBase, 0)

		if ( lOk )
			oRegraDeAliquota := FISGravAliquota():New()

			for i := Len(aRegrasDeAliquota) to 1 step -1
				if ( lOk .and. aRegrasDeAliquota[i]['incluido'] .and. !aRegrasDeAliquota[i]:HasProperty('erro') )
					lOk := oRegraDeAliquota:ExcluiRegraDeAliquota(aRegrasDeAliquota[i], @jRegra)						
				endif
			next i

			FreeObj(oRegraDeAliquota)
		endif

		ASize(aRegrasDeAliquota, 0)

		if ( lOk )
			oRegraDeEscrituracao := FISGravaCST():New()

			for i := Len(aRegrasDeEscrituracao) to 1 step -1
				if ( lOk .and. aRegrasDeEscrituracao[i]['incluido'] .and. !aRegrasDeEscrituracao[i]:HasProperty('erro') )
					lOk := oRegraDeEscrituracao:ExcluiRegraDeEscrituracao(aRegrasDeEscrituracao[i], @jRegra)							
				endif
			next i

			FreeObj(oRegraDeEscrituracao)
		endif

		ASize(aRegrasDeEscrituracao, 0)

		if ( lOk )
			oRegrasPorNCM := RecordTaxesNCM():New()

			for i := Len(aRegrasPorNCM) to 1 step -1				
				if ( lOk .and. aRegrasPorNCM[i]['incluido'] .and. !aRegrasPorNCM[i]:HasProperty('erro') )
					lOk := oRegrasPorNCM:Delete(aRegrasPorNCM[i], @jRegra)						
				endif
			next i

			FreeObj(oRegrasPorNCM)
		endif

		ASize(aRegrasPorNCM, 0)

		if ( lOk )
			cCenario := PadR(jRegra['cenario'], FWSX3Util():GetFieldStruct('CJB_IDCENA')[3])
			cProduto := PadR(jRegra['produto'], FWSX3Util():GetFieldStruct('CJB_PRODUT')[3])
			cOrigem := PadR(jRegra['origem'], FWSX3Util():GetFieldStruct('CJB_ORIGEM')[3])
			cPonteiro := PadR(jRegra['ponteiro'], FWSX3Util():GetFieldStruct('CJB_PTSYS')[3])

			DbSelectArea('CJB')
			CJB->(DbSetOrder(1)) // CJB_FILIAL+CJB_IDCENA+CJB_PRODUT+CJB_ORIGEM+CJB_PTSYS
			if ( CJB->( DbSeek( FWxFilial('CJB') + cCenario + cProduto + cOrigem + cPonteiro ) ) )

				CJB->(Reclock('CJB', .F.))
					CJB->CJB_JSAPRO := ''
					CJB->CJB_DTAPRO := SToD('')
					CJB->CJB_HRAPRO := ''
					CJB->CJB_STATUS := 'AA'
				CJB->(MsUnlock())

			endif

			CJB->(DbCloseArea())
		else
			DisarmTransaction()
		endif

	end transaction

return lOk

/*/{Protheus.doc} GetStatus

Método responsável por retornar o status da regra

@author Juliano Fernandes
@since 18/06/2024
@version 12.1.2310
/*/
method GetStatus(cSigla) as character class FISGetRegrasClassificador

	local jStatus as json
	local cStatus as character

	jStatus := JsonObject():New()
	jStatus['AA'] := STR0109 // Aprovada
	jStatus['R'] :=  STR0110 // Recusada
	jStatus['S'] :=  STR0111 // Suspensa
	jStatus['I'] :=  STR0112 // Inativa
	jStatus['AA'] := STR0113 // Pendente
	jStatus['RE'] := STR0161 // Rejeitada

	cStatus := jStatus[cSigla]

	FreeObj(jStatus)

return cStatus

/*/{Protheus.doc} AtualizaRegraAnterior
Método responsável por realizar a atualização da regra anterior
@author Juliano Fernandes
@since 13/03/2025
@version 12.1.2410
@param cIdCenario, character, ID do cenário
@param cProduto, character, Código do produto
@param cOrigem, character, Código da origem do produto
@param cPonteiroRegraAtualizacao, character, Ponteiro da regra de atualização
@param cDB, character, Tipo do banco de dados
@param jRetornoSystax, json, Json retornado pela Systax contendo os tributos
@param cMockServer, character, URL do servidor mock
@return logical, Se .T. indica se executou o processo corretamente
/*/
method AtualizaRegraAnterior(cIdCenario as character, cProduto as character, cOrigem as character, cPonteiroRegraAtualizacao as character, cDB as character, jRetornoSystax as json, cMockServer as character) as logical class FISGetRegrasClassificador

	local aAreaCJB := CJB->(FWGetArea()) as array
	local cQry as character
	local cAlias as character
	local jDadosAprovacaoRegraAnterior as json
	local jRegraDeCalculo as json
	local jRegraAnterior as json
	local cJsonAprovacao as character
	local cTributos as character
	local i as integer
	local oRegra as object
	local cStatus as character
	local lOk as logical

	// Buscar a regra anterior
	if ( self:oStatementRegraAnterior == nil )
		cQry := self:PrepareQueryRegraAnterior(cDB)

		self:oStatementRegraAnterior := FwExecStatement():New( ChangeQuery(cQry) )
	endif

    self:oStatementRegraAnterior:SetString(1, FWxFilial('CJB'))
    self:oStatementRegraAnterior:SetString(2, cIdCenario)
    self:oStatementRegraAnterior:SetString(3, cProduto)
    self:oStatementRegraAnterior:SetString(4, cOrigem)
    self:oStatementRegraAnterior:SetString(5, cPonteiroRegraAtualizacao)
    self:oStatementRegraAnterior:SetString(6, ' ')

    cAlias := self:oStatementRegraAnterior:OpenAlias(GetNextAlias())

	if ( !(cAlias)->(EoF()) )
		cStatus := (cAlias)->CJB_STATUS

		if ( cStatus $ 'AA|AP' ) // Pendente | Aprovada
			lOk := .T.

			if ( cStatus == 'AA' )
				lOk := .F.

				jRegraAnterior := JsonObject():New()

				jRegraAnterior['cenario'] := cIdCenario
				jRegraAnterior['produto'] := cProduto
				jRegraAnterior['origem'] := cOrigem
				jRegraAnterior['ponteiro'] := (cAlias)->CJB_PTSYS
				jRegraAnterior['status'] := 'AP'

				if ( !Empty(cMockServer) )
					jRegraAnterior['mockserver'] := cMockServer
				endif

				dDataBase := DaySub(dDataBase, 1)

				cJsonAprovacao := self:IntegraRegras(jRegraAnterior)

				dDataBase := DaySum(dDataBase, 1)
				
				if ( '"success":true' $ cJsonAprovacao )
					lOk := .T.
					cStatus := 'AP'

					// Atualiza os dados da campo CJB_JSAPRO gerados na aprovação da regra anterior
					(cAlias)->(DbCloseArea())
					cAlias := self:oStatementRegraAnterior:OpenAlias(GetNextAlias())

					// Reabre a CJB que foi fechada na aprovaçao da regra anteior
					DbSelectArea('CJB')
				endif

				FWFreeObj(jRegraAnterior)
				jRegraAnterior := nil
			endif

			if ( lOk .and. cStatus == 'AP' )
				jRegraAnterior := JsonObject():New()

				if ( jRegraAnterior:FromJson((cAlias)->CJB_JSREGR) == nil )
					// Buscar os Tributos em que houveram atualização
					cTributos := self:BuscaTributosAtualizados(jRetornoSystax)

					jDadosAprovacaoRegraAnterior := JsonObject():New()

					if ( jDadosAprovacaoRegraAnterior:FromJson((cAlias)->CJB_JSAPRO) == nil )

						if ( jDadosAprovacaoRegraAnterior:hasProperty('regrasDeCalculo') )
							oRegra := FISGravaRegra():New()

							for i := 1 to Len(jDadosAprovacaoRegraAnterior['regrasDeCalculo'])
								// 	Se os Tributos encontrados foram incluídos pela regra anterior				
								// 		Gravar o fim da vigência na regra de cálculo dos tributos	
								// 	Se os Tributos encontrados não foram incluídos pela regra anterior				
								// 		Seguir com a aprovação da regra						
								jRegraDeCalculo := jDadosAprovacaoRegraAnterior['regrasDeCalculo'][i]

								if ( jRegraDeCalculo['incluido'] )
									oRegra:InativaRegraDeCalculo(jRegraDeCalculo, cTributos)
								endif
							next i

							FWFreeObj(oRegra)
						endif
					endif

					FWFreeObj(jDadosAprovacaoRegraAnterior)
					jDadosAprovacaoRegraAnterior := nil
				endif

				FWFreeObj(jRegraAnterior)
				jRegraAnterior := nil				
			endif
		endif
	endif

	(cAlias)->(DbCloseArea())

	FWRestArea(aAreaCJB)

return lOk

/*/{Protheus.doc} PrepareQueryRegraAnterior
Método responsável por realizar a montagem da query que busca a regra anterior
@author Juliano Fernandes
@since 13/03/2025
@version 12.1.2410
@param cIdCenario, character, ID do cenário
@param cProduto, character, Código do produto
@param cOrigem, character, Código da origem do produto
@param cPonteiroRegraAtualizacao, character, Ponteiro da regra de atualização
@param cDB, character, Tipo do banco de dados
@param jRetornoSystax, json, Json retornado pela Systax contendo os tributos
@return logical, Se .T. indica se executou o processo corretamente
/*/
method PrepareQueryRegraAnterior(cDB as character) as character class FISGetRegrasClassificador

	local cQry as character

	cQry += " SELECT CJB_STATUS, CJB_PTSYS, "

    if ( 'ORACLE' $ cDB )
        cQry += " UTL_RAW.CAST_TO_VARCHAR2(DBMS_LOB.SUBSTR(CJB_JSAPRO, 4000,1)) CJB_JSAPRO, "
        cQry += " UTL_RAW.CAST_TO_VARCHAR2(DBMS_LOB.SUBSTR(CJB_JSREGR, 4000,1)) CJB_JSREGR "
    elseif ( 'POSTGRES' $ cDB )
        cQry += " encode(CJB_JSAPRO,'escape') CJB_JSAPRO, "
        cQry += " encode(CJB_JSREGR,'escape') CJB_JSREGR "
	else
		cQry += " ISNULL(CAST(CAST(CJB_JSAPRO AS VARBINARY(8000)) AS VARCHAR(8000)),'') AS [CJB_JSAPRO], "
		cQry += " ISNULL(CAST(CAST(CJB_JSREGR AS VARBINARY(8000)) AS VARCHAR(8000)),'') AS [CJB_JSREGR] "
    endif

	cQry += " FROM " + RetSqlName('CJB')
	cQry += " WHERE CJB_FILIAL = ? "
	cQry += " 	AND CJB_IDCENA = ? "
	cQry += " 	AND CJB_PRODUT = ? "
	cQry += " 	AND CJB_ORIGEM = ? "
	cQry += " 	AND CJB_PTSYS < ? "
	cQry += " 	AND D_E_L_E_T_ = ? "
	cQry += " ORDER BY CJB_PTSYS DESC "

return cQry

/*/{Protheus.doc} BuscaTributosAtualizados
Método responsável por verificar se existe atualização de uma regra por meio do 
campo estatística que é enviado pela Systax nos tributos do json de retorno
@author Juliano Fernandes
@since  20/02/2025
@version 1.0
@param  jRetornoSystax, json, Json retornado pela API da Systax
@return character, Tributos que tiveram atualização
/*/
method BuscaTributosAtualizados(jRetornoSystax as json) as character class FISGetRegrasClassificador

    local cTributos as character
    local aChaves := jRetornoSystax:GetNames() as array
    local cChave as character
	local cTributo as character
    local i as integer

    for i := 1 to Len(aChaves)
        cChave := aChaves[i]
		cTributo := Upper(cChave)

		if ( cChave == 'cofins' )
			cTributo := 'COF'
		endif		

        if ( ValType(jRetornoSystax[cChave]) == 'J' .and. ;
             jRetornoSystax[cChave]:HasProperty('estatistica') .and. ;
             !Empty(jRetornoSystax[cChave]['estatistica']) )
            
			cTributos += cTributo + '|'
        endif
    next i

    ASize(aChaves, 0)
    aChaves := nil

return cTributos

/*/{Protheus.doc} ValidNCM
Método responsável por validar se ocorreu algum erro na na classe que gera a 
Regra por NCM e montar as mensagens que serão exibidas ao usuário.
@author Juliano Fernandes
@since  01/04/2025
@version 1.0
@param  cErro, character, Mensagem de erro da classe que gera a regra por NCM
@param  jRetorno, json, Json que irá ser retornado para o usuário na aprovação da regra, em caso de erro na regra por NCM
@param  cIDCenario, character, ID do cenário
@return logical, Se .T. indica que não ocorreu erro na geração da regra por NCM
/*/
method ValidNCM(cErro as character, jRetorno as json, cIDCenario as character) as logical class FISGetRegrasClassificador

	local lValid := .T. as logical
	local aErro as array
	local nI as numeric
	local cMensagemDoErro as character

	if ( !Empty(cErro) )
		cMensagemDoErro := cErro

		if ( 'mensagem do erro:' $ cErro )
			aErro := StrTokArr2(cErro, ',')

			for nI := 1 to Len(aErro)
				if ( 'mensagem do erro:' $ aErro[nI] )
					cMensagemDoErro := AllTrim(StrTran(aErro[nI], 'mensagem do erro:', ''))
					exit
				endif
			next nI

			ASize(aErro, 0)
			aErro := nil			
		endif

		lValid := .F.
		jRetorno['success'] := .F.
		jRetorno['message'] := STR0230 + ' ' + cIDCenario // "Erro na integração da regra com o Configurador de Tributos. ID:"
		jRetorno['erro'] := JSONObject():New()
		jRetorno['erro']['codigoDoRegistro'] := cIDCenario
		jRetorno['erro']['mensagemDoErro'] := cMensagemDoErro
		jRetorno['erro']['detalheDoErro'] := cMensagemDoErro
	endif

return lValid
