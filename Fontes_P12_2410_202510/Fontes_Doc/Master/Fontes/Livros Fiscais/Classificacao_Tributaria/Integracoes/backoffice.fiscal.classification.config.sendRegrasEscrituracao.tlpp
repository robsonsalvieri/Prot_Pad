#Include "Protheus.ch"
#Include "RwMake.ch"
#Include "FwBrowse.ch"
#Include "FwMvcDef.ch"
#Include "TOPCONN.ch"
#INCLUDE "TBICONN.CH"
#include 'tlpp-core.th'
#include 'tlpp-rest.th'
#include 'classificadorfiscal.ch'

static jEscrituracoesCache := JsonObject():New()

Namespace totvs.protheus.backoffice.fiscal.Classifier

//-------------------------------------------------------------------
/*/{Protheus.doc} FISGravaCST
Classe que contém as operações para gravar as regras de escrituração vindo das regras da Systax.

@author  leandro.faggyas
@since   06.06.2022
@version 1.0
/*/
//-------------------------------------------------------------------
CLASS FISGravaCST

    data cSetCod as character
    data username as character
    data senha as character

    data rest_client as object
    data rToken as character
    data error as numeric
    data error_description as character
    data JSONResult as json
    data cIdCenario as character
    data cCodProd as character
    data nOriProd as numeric
    data cPontAtu as character
    data jSValid as json
    data oJsonRet as object
    data oStatementEscrituracao as object

    public data aEscrituracoes as array
 
    Public METHOD New() CONSTRUCTOR
    Public METHOD FisGrvCST( cCST, cTabCST, cDesc )
    Public METHOD FISGetDados(oJsonCST,lIpi)
    METHOD SetCod(cSetCod)
    Method AtuCJE(lGrava, cCJECod)
    Method GetIdTrib(cImposto)
    Method GetTabCST(cIdTrib, cCST)
    Method GetIncidencia( cCST )
    Public METHOD ExcluiRegraDeEscrituracao() as logical

END CLASS

//-------------------------------------------------------------------
/*/{Protheus.doc} New()
Método construtor da classe.

@author  leandro.faggyas
@since   11.05.2022
@version 1.0
/*/
//-------------------------------------------------------------------
METHOD New() CLASS FISGravaCST

Local aParam := {"CODREGCST"}
Local cParametro := GetConfigClassif(aParam)
Local oParametro := JsonObject():New()

If oParametro:FromJson(cParametro) == Nil
    ::SetCod(oParametro:CODREGCST) //Por ora, mantive o comportamento de usar a CJE para controle de numeração, porém o registro CODREGCST deverá ser criado na CJE.
    
    FreeObj(oParametro)

    FWFreeArray(aParam)
EndIf

self:aEscrituracoes := {}

Return

//-----------------------------------------------------------------
 /*/{Protheus.doc} FISGetDados()
Método para obter os dados dos impostos no Json

@author 	Yuri Gimenes
@since 		11.05.2022
@version 	1.0
/*/
//-----------------------------------------------------------------
METHOD FISGetDados(oJsonCST,lIpi) CLASS FISGravaCST

    Local nY            as numeric
    Local nYB           as numeric
    Local nYC           as numeric
    Local cDesc         as character
    Local cCST          as character
    Local cStrJson      as character
    Local cImposto      as character
    Local cIdTrib       as character
    Local cCodCST       as character
    Local aJson         as array
    Local aRet          as array
    Local aCST          as array
    Local aJsonRet      := {} as array
    Local lPcRed        as logical

    Default lIpi        := .F.

    BEGIN TRANSACTION

    For nYB := 1 to Len(oJsonCST["cenario"])

        For nYC := 1 to Len(oJsonCST["cenario"][nYB]["retorno"])

            aJson := oJsonCST["cenario"][nYB]["retorno"][nYC]:GetNames()
            
            For nY := 1 to Len(aJson)                

                cStrJson := aJson[nY]

                If lIPI
                    If ( cStrJson != "ipi" )
                        loop
                    EndIf
                EndIf

                If ValType(oJsonCST["cenario"][nYB]["retorno"][nYC][cStrJson]) == "J"

                    //lCred := .F.

                    //Obtem os CST de Entrada ou Saída, além de obter o nome do imposto.
                    cCST := oJsonCST["cenario"][nYB]["retorno"][nYC][cStrJson]["cst"]
                    If "credito_" $ cStrJson
                        //lCred := .T.
                        cImposto := Upper(SubStr(cStrJson,9))
                        cCST := oJsonCST["cenario"][nYB]["retorno"][nYC][cStrJson]["cst_entrada"]
                    else
                        cImposto := Upper(cStrJson)
                    EndIf

                    If !Empty(cCST)
                        cCodCST := ''
                        cDesc   := oJsonCST["cenario"][nYB]["retorno"][nYC][cStrJson]["dispositivo_legal"]
                        If !Empty(cDesc)
                            cDesc := Upper(cStrJson)+" - "+cDesc
                        Else
                            cDesc := Upper(cStrJson) + " - CST " + cCST
                        EndIf

                        If oJsonCST["cenario"][nYB]["retorno"][nYC][cStrJson]:hasProperty("p_red_bc")
                            lPcRed := .T.
                        Else
                            lPcRed := .F.
                        EndIf

                        //Obtem o ID do Tributo, fazendo um de/para com o imposto informado pela Systax
                        cIdTrib := ::GetIdTrib(cImposto)

                        //Com base no Tributo informado, retorna a tabela de CST que será gravada na Regra de Escrituração
                        aCST := ::GetTabCST(cIdTrib, cCST)

                        //Efetua a gravação das informações vindas da Sytax nas tabelas do Configurador
                        aRet := ::FisGrvCST( cCST, aCST, cDesc,@cCodCST,lPcRed )

                        If aRet[1]

                            aadd(aJsonRet,{cStrJson, upper(cCodCST)})

                            ::cSetCod := ::AtuCJE(aRet[2] , AllTrim(::cSetCod))                            
                        
                        EndIf                       

                    EndIf

                EndIf
                
            Next nY

            FWFreeArray(aJson)

        Next nYC

    Next nYB

    END TRANSACTION

Return aJsonRet

//-----------------------------------------------------------------
 /*/{Protheus.doc} FisGrvCST()
Método para gravar a alíquota no configurador de tributos

@author 	Yuri Gimenes
@since 		09.06.2022
@version 	1.0
/*/
//-----------------------------------------------------------------
METHOD FisGrvCST( cCST, aCST, cDescricao, cCodCST, lPcRed) CLASS FISGravaCST

Local oModel	            as object
Local lExist                as Logical
Local lGrava                as Logical
Local cTabCST               as Character
Local cDesc                 as Character
Local aRet                  := {lExist,.F.}
Local cIRedBs               as character
Local cChaveMD5             as character
Local oMd5Classification    as object
Local jMd5Find              as json
Local jChave                as json
Local aErro                 := {} as array
Local jEscrituracao         as json

Default cCST        := ""
Default aCST        := {}
Default cDescricao  := ""

If Len(aCST) > 0
    if ( Empty(cCodCST) )
        cCodCST := "SYS" + AllTrim(::cSetCod)
    endif

    cDesc := SubStr(cDescricao,1,TamSX3('CJ2_DESCR')[1])

    cTabCST := aCST[1]

    If lPcRed
        cIRedBs := '2'

        If aCST[2] == '1' .Or. aCST[2] == '3'
            cIRedBs := '1'
        EndIf    
    EndIf
EndIf

oModel := FWLoadModel('FISA160J')
oModel:SetOperation(MODEL_OPERATION_INSERT)
oModel:Activate()

oModel:SetValue('FISA160J','CJ2_CODIGO', cCodCST)
oModel:SetValue('FISA160J','CJ2_CSTCAB', cTabCST)
oModel:SetValue('FISA160J','CJ2_CST'   , cCST)
oModel:SetValue('FISA160J','CJ2_DESCR' , cDesc)
oModel:SetValue('FISA160J','CJ2_INCIDE', aCST[2])  
oModel:SetValue('FISA160J','CJ2_IREDBS', cIRedBs)
oModel:SetValue('FISA160J','CJ2_STOTNF', '1')     // TO DO: Determinar como preencher esse campo.

jChave := JsonObject():New()
jChave['CJ2_INCIDE'] := oModel:GetValue('FISA160J', 'CJ2_INCIDE')
jChave['CJ2_STOTNF'] := oModel:GetValue('FISA160J', 'CJ2_STOTNF')
jChave['CJ2_PERDIF'] := oModel:GetValue('FISA160J', 'CJ2_PERDIF')
jChave['CJ2_IREDBS'] := oModel:GetValue('FISA160J', 'CJ2_IREDBS')
jChave['CJ2_CSTCAB'] := oModel:GetValue('FISA160J', 'CJ2_CSTCAB')
jChave['CJ2_CST'] := oModel:GetValue('FISA160J', 'CJ2_CST')
jChave['CJ2_CSTDEV'] := oModel:GetValue('FISA160J', 'CJ2_CSTDEV')

jMd5Find := JsonObject():New()
jMd5Find['cache'] := jEscrituracoesCache
jMd5Find['table'] := 'CJ2'
jMd5Find['index'] := 5
jMd5Find['codeField'] := 'CJ2_CODIGO'
jMd5Find['key'] := jChave
jMd5Find['ruleTypes'] := ''

oMd5Classification := Md5Classification():New()
oMd5Classification:Find(jMd5Find)
lExist := oMd5Classification:GetFound()
cChaveMD5 := oMd5Classification:GetMd5Key()

if ( lExist )
    cCodCST := oMd5Classification:GetCode()
endif

aRet := { lExist, .F. }

lGrava := !Empty(cCodCST) .And. !Empty(cTabCST) .And. !Empty(cCST) .And. !Empty(cDesc)

If !lExist .And. lGrava
    If oModel:Activate()
        If oModel:VldData()
            oModel:CommitData()
            oModel:DeActivate()
            aRet[1] := .T.
            aRet[2] := .T.
        Else
            aErro := oModel:GetErrorMessage()
        EndIf
    EndIf

EndIf

oModel:DeActivate()
oModel:Destroy()		
FwFreevar( oModel )
FreeObj(oModel)

oMd5Classification:Destroy()
FwFreevar(oMd5Classification)
FwFreevar(jMd5Find)
FwFreevar(jChave)

if ( aRet[1] )
    jEscrituracoesCache[cChaveMD5] := cCodCST
endif

jEscrituracao := JsonObject():New()
jEscrituracao['codigo'] := cCodCST
jEscrituracao['incluido'] := aRet[2]
jEscrituracao['md5'] := cChaveMD5

if ( Len(aErro) > 0 )
    jEscrituracao['erro'] := JsonObject():New()
    jEscrituracao['erro']['formularioDeOrigem'] := AllToChar(aErro[1]) 
    jEscrituracao['erro']['campoDeOrigem'] := AllToChar(aErro[2])
    jEscrituracao['erro']['formularioDeErro'] := AllToChar(aErro[3])
    jEscrituracao['erro']['campoDeErro'] := AllToChar(aErro[4])
    jEscrituracao['erro']['erro'] := AllToChar(aErro[5])
    jEscrituracao['erro']['mensagemDoErro'] := AllToChar(aErro[6])
    jEscrituracao['erro']['mensagemDaSolucao'] := AllToChar(aErro[7])
    jEscrituracao['erro']['valorAtribuido'] := AllToChar(aErro[8])
    jEscrituracao['erro']['valorAnterior'] := AllToChar(aErro[9])
endif

Aadd(self:aEscrituracoes, jEscrituracao)

ASize(aErro, 0)

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} SetCod
Método para passar o código da regra de alíquota no Configurador.

@author  Yuri Gimenes
@since   11.05.2022
@version 1.0
/*/
//-------------------------------------------------------------------
Method SetCod(cSetCod) Class FISGravaCST

    Self:cSetCod := cSetCod

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} AtuCJE
Controle de numeração automatica dos códigos de CST.

@author  Yuri Gimenes
@since   11.05.2022
@version 1.0
/*/
//-------------------------------------------------------------------
Method AtuCJE(lGrava, cCJECod) Class FISGravaCST

If lGrava
    DbSelectArea("CJE")
    CJE->(DbSetOrder(1))

    If CJE->(MsSeek(xFilial("CJE")+"CODREGCST"))
        RecLock("CJE", .F.)
            ::cSetCod := Padl(Soma1(cCJECod),3,"0")
            CJE->CJE_CONTEU := ::cSetCod
        CJE->(MsUnlock())
    EndIF

    CJE->(DbCloseArea())
Endif

Return ::cSetCod

//-------------------------------------------------------------------
/*/{Protheus.doc} GetIdTrib
Retorna o ID do imposto, fazendo um de/para com o imposto retornado pela API da Systax.

@author  leandro.faggyas
@since   08.06.2022
@version 1.0
/*/
//-------------------------------------------------------------------
Method GetIdTrib(cImposto) Class FISGravaCST
Local cCodTrib as Character
Local cRet     as Character

Default cImposto := ""

Do Case
    Case cImposto == "COFINS"
        cCodTrib := "COF"
    Otherwise
        cCodTrib := AllTrim(cImposto)
EndCase

DbSelectArea("F2E")
F2E->(DbSetOrder(2)) //F2E_FILIAL+F2E_TRIB

If F2E->(MsSeek(xFilial("F2E")+cCodTrib))
    cRet := F2E->F2E_IDTRIB
EndIf

F2E->(DbCloseArea())

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} GetTabCST
Realiza uma busca no cadastro de CST do Configurador, retornando o código da tabela do CST e a incidência

@author  leandro.faggyas
@since   08.06.2022
@return  aRet - Array - aRet[1] ID da tabela de CST, aRet[2] Incidência (1=Tributado, 2=Isento e 3=Outros)
@version 1.0
/*/
//-------------------------------------------------------------------
Method GetTabCST(cIdTrib, cCST) Class FISGravaCST
Local aRet          as Array
Local cQry          as Character
Local cAlias        as Character
Local cIncide       as Character
Local oStatement    as object

Default cCST := ""

aRet := {}

cQry := " SELECT CJ0_CODIGO "
cQry += " FROM "+RetSqlName("CJ0") + " CJ0 "

cQry += " JOIN "+RetSqlName("CJ1") + " CJ1 "
cQry += " ON    CJ1.CJ1_FILIAL = ? "
cQry += " AND   CJ1.CJ1_CODCAB = CJ0.CJ0_CODIGO "
cQry += " AND   CJ1.CJ1_CST    = ? "
cQry += " AND   CJ1.D_E_L_E_T_ = ' ' "

cQry += " WHERE CJ0.CJ0_FILIAL  = ? " 
cQry += " AND   CJ0.CJ0_IDTRIB  = ? "

cQry += " AND   ( ? >= CJ0.CJ0_VIGINI AND CJ0.CJ0_VIGFIM = ' '  "
cQry += " OR      ? >= CJ0.CJ0_VIGINI AND ? <= CJ0.CJ0_VIGFIM ) "
cQry += " AND   CJ0.D_E_L_E_T_ = ' ' "

oStatement := FwExecStatement():New( ChangeQuery(cQry) )

oStatement:SetString(1, xFilial("CJ1"))
oStatement:SetString(2, cCST)
oStatement:SetString(3, xFilial("CJ0"))
oStatement:SetString(4, cIdTrib)
oStatement:SetDate(5, dDataBase)
oStatement:SetDate(6, dDataBase)
oStatement:SetDate(7, dDataBase)

cAlias := oStatement:OpenAlias(GetNextAlias())

If (cAlias)->(!EoF())
    aAdd(aRet, (cAlias)->CJ0_CODIGO )
    cIncide := FIS160Inci(cCST, cIdTrib) //Caso o campo CJ1_INCIDE não exista ou esteja em branco, será chamada a função que retorna a incidência utilizada na carga da tabela CJ1.
    aAdd( aRet, cIncide )
EndIf

(cAlias)->(DbCloseArea())

FreeObj(oStatement)

Return aRet

/*/{Protheus.doc} ExcluiRegraDeEscrituracao

Método responsável por excluir uma Regra de Escrituracao

@author Juliano Fernandes
@since 18/06/2024
@version 12.1.2310
/*/
method ExcluiRegraDeEscrituracao(jRegraDeEscrituracao as json, jRegra as json) as logical class FISGravaCST
 
	local lOk as logical
	local oModel as object
	local aErro as array

    lOk := .T.

    DbSelectArea('CJ2')
    CJ2->(DbSetOrder(1)) // CJ2_FILIAL+CJ2_CODIGO+CJ2_ALTERA
    if ( !CJ2->( DbSeek( FWxFilial('CJ2') + jRegraDeEscrituracao['codigo'] + '2' ) ) )
        lOk := .F.

        jRegra['mensagemDoErro'] := STR0253 //'Regra de Escrituração não pode ser excluída'
        jRegra['codigoDoRegistro'] := jRegraDeEscrituracao['codigo']
        jRegra['detalheDoErro'] := STR0237 //'Registro não encontrado'
    endif

    if ( lOk )
        oModel := FWLoadModel('FISA160J')
        oModel:SetOperation(MODEL_OPERATION_DELETE)
        oModel:Activate()

        if ( oModel:VldData() )
            jEscrituracoesCache:DelName(CJ2->CJ2_CHVMD5)
            oModel:CommitData()
        else
            lOk := .F.

            aErro := oModel:GetErrorMessage()

            jRegra['mensagemDoErro'] := STR0253 //'Regra de Escrituração não pode ser excluída'
            jRegra['codigoDoRegistro'] := jRegraDeEscrituracao['codigo']
            jRegra['detalheDoErro'] := AllToChar(aErro[6])

            ASize(aErro, 0)
        endif

        oModel:Deactivate()

        oModel:Destroy()

        FreeObj(oModel) 
    endif

    CJ2->(DbCloseArea())

return lOk
