#INCLUDE "tlpp-core.th"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FISCAL.CONFIGURADOR.TAX.CLASSIFICATION.REGISTRATION.IMPORT.CH"
#INCLUDE "FILEIO.CH"

Namespace totvs.protheus.backoffice.fiscal.configurador.tax.classification.registration.import

Static nElemArq	:= 5 as numeric

//-------------------------------------------------------------------
/*/{Protheus.doc} ImpClassTribIbsCbs
Importacao da Tabela para o CST/ClassTrib do IBS e CBS 

@author Eduardo Nunes Cirqueira
@since 02/06/2025

@version 1.0
/*/
//-------------------------------------------------------------------
Function ImpClassTribIbsCbs(cArquivo as character)

	Local cFile	:= ""  as character
	Local lRet  := .T. as logical

	Default cArquivo   := Nil

	ChangeFile(.T.,@cFile,cArquivo)

	If ! Empty(cFile)
		Processa({|| lRet := AtuCKB(cFile)},STR0001) //'Processando...'
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} AtuCKB
Importacao da Tabela para o CST/ClassTrib do IBS e CBS 

@author Eduardo Nunes Cirqueira
@since 02/06/2025
@version 1.0
@parâmetros de entrada
cFile - arquivo .CSV que será utilizado para importar os dados
@return
lRet - Lógico, indicando se concluiu o processamento corretamente (.T.).
/*/
//-------------------------------------------------------------------
Static Function AtuCKB(cFile as character) as logical

	Local aCSVFile 	:= {}                 as array
	Local aFile     := {}                 as array
	Local aAux      := {}                 as array
	Local aCampos   := {}                 as array
	Local dDtIniV	:= CtoD("  /  /    ") as date
	Local dDtFimV	:= CtoD("  /  /    ") as date
	Local nRegs		:= 0                  as numeric
	Local nX 		:= 0                  as numeric
	Local nX2		:= 0                  as numeric
	Local nCont		:= 0                  as numeric
	Local lRet 		:= .F.                as logical
	Local lInclui	:= .F.                as logical
	Local lEmptyIni := .F.                as logical
	Local cTexto                          as character

	// aCampos[x][1] := Campo na CKB
	// aCampos[x][2] := Campo no arquivo ".csv"
	// aCampos[x][3] := Se está ou não no For..Next de gravação
	// aCampos[x][4] := Se é um campo exigido no arquivo ".csv". Uma forma de validar o arquivo ".csv"
	// aCampos[x][5] := Elemento correspondente no array gerado na leitura do arquivo ".csv"
    Aadd( aCampos , { 'CKB_CST'   , 'CST-IBS/CBS'          , .T., .T., 0 } )
    Aadd( aCampos , { 'CKB_DESCST', 'Descrição CST-IBS/CBS', .T., .T., 0 } )
    Aadd( aCampos , { 'CKB_CSTCCT', 'cClassTrib'           , .F., .T., 0 } )
    Aadd( aCampos , { 'CKB_DESCRI', 'Descrição cClassTrib' , .T., .T., 0 } )
    Aadd( aCampos , { 'CKB_EC'    , 'EC'                   , .T., .F., 0 } )
    Aadd( aCampos , { 'CKB_LCTXT' , 'LC Redação'           , .T., .F., 0 } )
    Aadd( aCampos , { 'CKB_LCREF' , 'LC 214/25'            , .T., .F., 0 } )
    Aadd( aCampos , { 'CKB_DTINI' , 'dIniVig'              , .F., .F., 0 } )
    Aadd( aCampos , { 'CKB_DTFIM' , 'dFimVig'              , .F., .F., 0 } )

	If VerAliasDic("CKB")

		//Grava o arquivo CSV em array
		aCSVFile := LerCSV(cFile,@aCampos)

		For nX := 1 to Len(aCSVFile)

			aAux   := {}
			cTexto := ''

			For nX2 := 1 to Len(aCSVFile[nX])
				cTexto += aCSVFile[nX][nX2]
				If Left( cTexto , 1 ) <> '"' .Or. Right( cTexto , 1 ) == '"'
					Aadd( aAux,cTexto )
					cTexto := ''
				EndIf
			Next

			For nX2 := ( Len(aAux)+1 ) To Len(aCSVFile[1])
				Aadd( aAux,'' )
			Next

			Aadd( aFile,aAux )
		Next

		nRegs := Len(aFile)
		lRet  := (nRegs > 0)

		If lRet

			nElemCstCCT := aScan(aCampos, {|x| x[1] == 'CKB_CSTCCT'})
			nElemDtIni  := aScan(aCampos, {|x| x[1] == 'CKB_DTINI' })
			nElemDtFim  := aScan(aCampos, {|x| x[1] == 'CKB_DTFIM' })

			ProcRegua(nRegs)

			//Processa arquivo

			For nX := 2 to  Len(aFile)     // comeca em 2 porque 1a linha eh cabecalho

				cCstCct     := Alltrim(aFile[nX][ aCampos[nElemCstCCT][nElemArq] ]) // Cod Sit Trib e Class Fiscal [3]
				If nElemDtIni > 0
					dDtIniV := CtoD(aFile[nX][ aCampos[nElemDtIni][nElemArq] ])
				EndIf
				If nElemDtFim > 0
					dDtFimV := CtoD(aFile[nX][ aCampos[nElemDtFim][nElemArq] ])
				EndIf
				lEmptyIni   := Empty(dDtIniV)

				If lEmptyIni
					dDtIniV := dDataBase
				EndIf

				IncProc(STR0005 + alltrim(str(nX)) + ' / ' + alltrim(str(nRegs)) + STR0006 + cFile)

				If Len(cCstCct) == 6

					CKB->(DbSetOrder(1))
					lInclui := ( ! CKB->(dbSeek(xFilial("CKB") + cCstCct)) )

					RecLock('CKB',lInclui)
					If lInclui
						CKB->CKB_FILIAL	:= xFilial("CKB")
						CKB->CKB_CSTCCT	:= cCstCct
					Else
						If lEmptyIni .And. CKB->CKB_DTINI < dDtIniV
							dDtIniV := CKB->CKB_DTINI
						EndIf
					EndIf
					CKB->CKB_DTINI 	:= dDtIniV
					CKB->CKB_DTFIM 	:= dDtFimV
					CKB->CKB_CCT   	:= Right(cCstCct,3)
					For nCont := 1 To Len(aCampos)
						If aCampos[nCont][3] .And. aCampos[nCont][nElemArq] > 0
							CKB->&(aCampos[nCont][1]) := Alltrim(aFile[nX][aCampos[nCont][nElemArq]])
						EndIf
					Next
					CKB->(MsUnlock())

				Endif
			Next
			MSGINFO(STR0007 , STR0003 )

		EndIf
	EndIf

	// limpando Array
	aCSVFile := aSize(aCSVFile,0)
	aCSVFile := Nil

	aFile := aSize(aFile,0)
	aFile := Nil

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} ChangeFile
Apresentar tela de seleção do arquivo .csv para importação da Classificação Tributária do IBS/CBS

@author Eduardo Nunes Cirqueira
@since 02/06/2025
@version 1.0
@parâmetros de entrada
lOpen - indica se é "open dialog" (.T.) ou "save dialog" (.F.)
cFile - variavel enviada por referência, que conterá o nome do arquivo para importação dos dados.
cFileChg - arquivo a ser processado (atender à automação). Abaixo segue descrição das opções do 6º parâmetro da função cGetFile(),
           o qual indica as opções de funcionamento:
		   GETF_LOCALHARD   : Apresenta a unidade de disco local 
		   GETF_NETWORKDRIVE: Apresenta as unidades de rede (mapeamento). Ao executar o SmartClient com um usuário diferente do  
		                      usuário logado na sessão no Windows, os drives de Rede não serão apresentados.
@return
nenhum
/*/
//-------------------------------------------------------------------
Static Function ChangeFile(lOpen as logical, cFile as character, cFileChg as character)

	Local cType      := OemToAnsi("CSV|")+'*.CSV' as character

	Default lOpen    := .T.
	Default cFileChg := cGetFile(cType, OemToAnsi(STR0003), 1,, lOpen, GETF_LOCALHARD + GETF_NETWORKDRIVE, .T.)

	If ! Empty(cFileChg)
		If "." $ cFileChg
			cFileChg := Substr(cFileChg,1,rat(".", cFileChg)-1)
		Endif

		cFileChg := alltrim(cFileChg)
		cFile    := Alltrim(cFileChg+Right(cType,4))
	Endif

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} LerCSV
Abrir e ler o arquivo passado por parâmetro e retornar um arrary multidimensional, onde cada elemento
representa uma linha do arquivo e cada elemento possui uma dimensão com os campos

@author Eduardo Nunes Cirqueira
@since 13/06/2025
@version 1.0
@parâmetros de entrada
cFileCSV - variavel enviada que conterá o nome do arquivo para leitura dos dados.
@return
aRet - array com as linhas do arquivo lido
/*/
//-------------------------------------------------------------------
Static Function LerCSV(cFileCSV,aCampos)

	Local cMemo             as character
	Local cBuffer           as character
	Local cBufGet           as character
	Local cChrSepFil        as character
	Local cTarget           as character
	Local cReplace          as character
	Local aLinha            as array
	Local aRet       := {}  as array
	Local nTamArq           as numeric
	Local nBytes            as numeric
	Local nQtdBytes  := 512 as numeric
	Local nBcoHdl           as numeric
	Local nI                as numeric
	Local lArqOK     := .T. as logical

	Default aCampos := {}

	cChrSepFil := ";"
	cTarget    := cChrSepFil+cChrSepFil
	cReplace   := cChrSepFil + Space( 3 ) + cChrSepFil

	If VerArqTxt(cFileCSV,@nBcoHdl)

		nTamArq := FSEEK( nBcoHdl, 0, FS_END )

		FSEEK( nBcoHdl, 0, FS_SET )

		aRet	:= {}
		cBuffer := ""

		While lArqOK .And. nBytes < nTamArq

			FREAD( nBcoHdl, @cBufGet, nQtdBytes ) 
			cBuffer += cBufGet

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Execute ate encontrar os caracteres de final de linha ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Do While lArqOK .And. ( nI := AT( CHR(13)+CHR(10), cBuffer ) ) > 0

				cMemo := SubStr( cBuffer, 1, nI+1 )

				If !Empty( SubStr( cMemo, 1, Len( cMemo ) - 2 ) )

					Do While AT( cTarget, cMemo ) > 0
						cMemo := StrTran( cMemo, cTarget, cReplace)
					EndDo

					If Len(aRet) == 0         // 1ª linha do arquivo (nomes dos campos)
						cMemo := UPPER(cMemo) // deixar em maiúscula
					EndIf

					aLinha := StrTokArr( StrTran( SubStr( cMemo, 1, Len( cMemo ) - 2 ), cTarget, cReplace), cChrSepFil )

					aAdd( aRet, aLinha )

					If Len(aRet) == 1 .And. Len(aCampos) > 0
						lArqOK := VerCampos(aRet[1],@aCampos)
					Endif

				EndIf

				cBuffer	:= SubStr( cBuffer, nI + 2 )

			EndDo

			nBytes += nQtdBytes
		EndDo
		fClose( nBcoHdl )

	EndIf

If ! lArqOK
	aRet := {}
	MSGStop(STR0009,STR0003)
EndIf

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} VerCampos
Fazer a relação dos campos da CKB com os campos do arquivo que está sendo lido, além de validar se o arquivo
é válido exigindo a existência de 4 campos específicos (códigos e descrição da Classificação Tributária)

@author Eduardo Nunes Cirqueira
@since 04/07/2025
@version 1.0
@parâmetros de entrada
aRet - array com os campos na 1ª linha do arquivo
aCampos - campos da CKB e os respectivos campos do arquivo
@return
lRet - Lógico, indicando se o arquivo possui os campos exigidos
/*/
//-------------------------------------------------------------------
Static Function VerCampos(aRet,aCampos)

Local nX          as numeric
Local lRet := .T. as logical

For nX := 1 To Len (aCampos)
	aCampos[nX][nElemArq] := aScan( aRet, UPPER(aCampos[nX][2]) )

	lRet := aCampos[nX][nElemArq] > 0 .Or. (! aCampos[nX][4])
	If ! lRet
		Exit
	EndIf
Next

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} VerAliasDic
Verifica se o alias recebido existe no dicionário

@author Eduardo Nunes Cirqueira
@since 18/06/2025
@version 1.0
@parâmetros de entrada
cAlias - alias da tabela para verificar se existe no dicionário
@return
lRet - Lógico, indicando se realizou o procedimento com sucesso
/*/
//-------------------------------------------------------------------
Function VerAliasDic(cAlias)

	Local lRet as logical

	lRet := AliasInDic(cAlias)

	If ! lRet
		MSGStop(STR0002,STR0003)
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} VerArqTxt
Verifica se o alias recebido existe no dicionário

@author Eduardo Nunes Cirqueira
@since 18/06/2025
@version 1.0
@parâmetros de entrada
cArquivo - arquivo texto para ser aberto
nHandle - resultado da abertura do arquivo recebido. Deve ser passado por referência para ser fechado 
          na rotina que solicitou
@return
lRet - Lógico, indicando se realizou o procedimento com sucesso
/*/
//-------------------------------------------------------------------
Function VerArqTxt(cArquivo,nHandle)

	Local lRet as logical

	Default nHandle := -1

	nHandle := FOpen(cArquivo,FO_READ+FO_COMPAT)
	lRet    := (nHandle >= 0)

	If ! lRet
		MSGStop(STR0004,STR0003)
	EndIf

Return lRet
