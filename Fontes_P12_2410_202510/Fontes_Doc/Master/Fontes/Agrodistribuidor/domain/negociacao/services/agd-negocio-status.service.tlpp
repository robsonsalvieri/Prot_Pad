#include "totvs.ch"
#include 'tlpp-core.th'
#include 'agd.negocio.status.service.ch'
#INCLUDE "FWMVCDEF.CH"

#DEFINE ST_ABERTO "1"
#DEFINE ST_ANDAMENTO "2"
#DEFINE ST_CANCELADO "3"
#DEFINE ST_FINALIZADO "4"
#DEFINE ST_VERSIONADO "6"
#DEFINE ST_CONCLUIDO "8"
#DEFINE SAUT_NAO_LIBERADO "1"
#DEFINE SAUT_LIBERADO "2"
#DEFINE SAUT_RECUSADA "3"
#DEFINE ST_R_E_FINALIZADO "3"

namespace agd.negocioStatusService
using namespace agd.negocioRepository /*shortCurt de funcao*/
using namespace agd.utilsService
using namespace agd.instrucaoEmbarqueItemRepository
using namespace agd.contratoAclRepository
using namespace agd.negocioInsumoService
using namespace agd.negocioService

/*/{Protheus.doc} agdNegocioStatusService
Serviço de Máquina de Estado do Negócio
@type class
@version 12
@author jean.schulze
@since 14/01/2025
/*/ 
class agdNegocioStatusService FROM agdUtilsService
	public Data cIdNegocioBarter  As Character

	public method new()

	public method liberar()
	public method recusar()
	public method cancelar()
	public method informarPedidoVenda()
	public method informarInstrucaoEmbarque()
	public method reabrir()
	public method versionar()
	public method concluirNegocio()
	public method atualizarStRecebNegocio()
	public method atualizarStExpedNegocio()
	public method getAutorizacao() as Character
	public method getStatusMessage() as character
	public method getStatusAtual() as Character
	
	private method getTotalInstrucaoEmbarque() as numeric
	private method hasSaldoAinstruir() as logical
	

	private method getStatus() as Array
	private method validaProximoStatus() as Logical

endclass

/*/{Protheus.doc} agdNegocioStatusService::new
Constructor
@type method
@version 12
@author jean.schulze
@since 14/01/2025
@param pcIdNegocioBarter, Character, passar a chave unica da negociação, sendo NEA_FILIAL+NEA_CODIGO+NEA_VERSAO
/*/
method new(pcIdNegocioBarter) class agdNegocioStatusService
	Self:cIdNegocioBarter := pcIdNegocioBarter
	_Super:New()
return Self

/*/{Protheus.doc} Liberar
Aprova Negócio Barter
@type method
@version 12
@author jean.schulze
@since 16/01/2025
@return variant, nil
/*/
method liberar(lUsaTela as Logical, cMsgHist as Character) class agdNegocioStatusService
	Local oRepository As Object
	Default lUsaTela := .T.
	Default cMsgHist := STR0001

	//verifica se ja nao está no estado correto
	if Self:validaProximoStatus(ST_ABERTO) .and. Self:getAutorizacao() != SAUT_LIBERADO

		if lUsaTela
			if !AGDGRAVAHIS("","NEA",Self:cIdNegocioBarter, STR0001,.T.) //LIBERADO
				return nil
			endif
		endif

		oRepository := agdNegocioRepository():New(Self:cIdNegocioBarter)
		oRepository:updateRepository({{'NEA_STSAUT', SAUT_LIBERADO}})
		
		If oRepository:isSuccess()
			oRepository:setsuccess(STR0026)//"Negociação aprovada com Sucesso"
		EndIf
		Self:setFullResponse(oRepository)
		
		if oRepository:isSuccess() .and. !lUsaTela
			AGDGRAVAHIS("","NEA",Self:cIdNegocioBarter,STR0001,.F., cMsgHist) //LIBERADO
		endif

		oRepository:DeActivate()

	elseIf Self:getAutorizacao() == SAUT_LIBERADO
		Self:setError(STR0022) //"Esta negociação já encontra-se aprovada!"
	endif
	
	FreeObj(oRepository)

return nil

/*/{Protheus.doc} Recusar
Recusa negócio Barter, cancelando o mesmo
@type method
@version 12
@author jean.schulze
@since 16/01/2025
@return variant, nil
/*/
method recusar(lUsaTela as Logical, cMsgHist as Character) class agdNegocioStatusService
	Local oRepository As Object
	Default lUsaTela := .T.
	Default cMsgHist := STR0002

	//verifica se ja nao está no estado correto
	if Self:validaProximoStatus(ST_ABERTO) .and. Self:getAutorizacao() != SAUT_RECUSADA .and. Self:getAutorizacao() != SAUT_LIBERADO

		if lUsaTela
			if !AGDGRAVAHIS("","NEA",Self:cIdNegocioBarter,STR0002,.T.) //RECUSADO
				return nil
			endif
		endif

		oRepository := agdNegocioRepository():New(Self:cIdNegocioBarter)
		oRepository:updateRepository({{'NEA_STSAUT', SAUT_RECUSADA}})
		
		If oRepository:isSuccess()
			oRepository:setsuccess(STR0025)//"Negociação recusada com Sucesso"
		EndIf
		Self:setFullResponse(oRepository)

		if oRepository:isSuccess() .and. !lUsaTela
			AGDGRAVAHIS("","NEA",Self:cIdNegocioBarter,STR0002,.F.,cMsgHist) //RECUSADO
		endif

		oRepository:DeActivate()

	elseif Self:getAutorizacao() == SAUT_RECUSADA
		self:setError(STR0024) //"Esta negociação já encontra-se reprovada!"
	elseif  Self:getAutorizacao() == SAUT_LIBERADO
		self:setError(STR0023) //"Esta negociação já encontra-se aprovada, não é possivel reprovar!"
	endif
	
	FreeObj(oRepository)
return nil


/*/{Protheus.doc} Recusar
cancelamento de barter
@type method
@version 12
@author lindembergson.pacheco
@since 20/02/2025
@return variant, nil
/*/
method cancelar(lUsaTela as Logical, cMsgHist as Character ) class agdNegocioStatusService
	Local oRepository As Object
	Local oRepositoryIE := agdInstrucaoEmbarqueItemRepository():New()
	Local oRepositoryACL := agdContratoAclRepository():New()
	Local cBarter :=   SUBSTR(Self:cIdNegocioBarter, 1 , (LEN(Self:cIdNegocioBarter) - TAMSX3("NEA_VERSAO")[1]))

	Default lUsaTela := .T.
	Default cMsgHist := ""

	if Empty(oRepositoryIE:findByNegociacaoBarter(cBarter))  //busca pelo id da negociacao barter
		if (oRepositoryACL:allContratoExternoCancelado(cBarter))
			//verifica se ja nao está no estado correto
			if Self:getStatusAtual() $ "1|2|7"

				if lUsaTela
					if !AGDGRAVAHIS(STR0009,"NEA",Self:cIdNegocioBarter,Self:getStatusMessage(ST_CANCELADO),.T.) //Deseja realmente cancelar essa Negociacao? //CANCELADO
						return nil
					endif
				endif

				oRepository := agdNegocioRepository():New(Self:cIdNegocioBarter)
				oRepository:updateRepository({{'NEA_STATUS', ST_CANCELADO}})
				if oRepository:isSuccess()
					oRepository:setSuccess(STR0027)//"Negociação cancelada com sucesso"
				EndIf
				Self:setFullResponse(oRepository)

				if oRepository:isSuccess() .and. !lUsaTela
					AGDGRAVAHIS(STR0009,"NEA",Self:cIdNegocioBarter,Self:getStatusMessage(ST_CANCELADO),.F.,cMsgHist) //Deseja realmente cancelar essa Negociacao? //CANCELADO
				endif

				oRepository:DeActivate()

			elseif Self:getStatusAtual() == ST_CANCELADO
				Self:setError(STR0028, 404) //"Esta negociação já encontra-se cancelada."
			else
				Self:setError(STR0029, 404) //#O status da negociação não permite realizar o processo de cancelamento. Status permitidos: 1 - Aberto, 2 - Em Andamento ou 7 - Reprovado.
			endif
		else
			Self:setError(STR0020, 404) //#Cancelar Contrato de OG  vinculados a Negociacao
		endif
	else
		Self:setError(STR0021, 404) //#Cancelar Instrucoes de Embarque vinculadas a Negociacao
	endif

	FreeObj(oRepository)
	FreeObj(oRepositoryIE)
	FreeObj(oRepositoryACL)
return nil

/*/{Protheus.doc} informarPedidoVenda
Informa que foi gerado pedido de venda para o Negócio
@type method
@version 12
@author jean.schulze
@since 16/01/2025
@return variant, nil
/*/
method informarPedidoVenda() class agdNegocioStatusService
	Local oRepository As Object

	//verifica se ja nao está no estado correto
	if Self:validaProximoStatus(ST_ANDAMENTO) .and. Self:getStatusAtual() != ST_ANDAMENTO

		oRepository := agdNegocioRepository():New(Self:cIdNegocioBarter)
		oRepository:updateRepository({{'NEA_STATUS', ST_ANDAMENTO}})

		Self:setFullResponse(oRepository)

		if oRepository:isSuccess()
			AGDGRAVAHIS("","NEA",Self:cIdNegocioBarter, STR0003,.F., STR0003) //em andamento
		endif

		oRepository:DeActivate()

	endif

	FreeObj(oRepository)

return nil

/*/{Protheus.doc} agdNegocioStatusService::informarInstrucaoEmbarque
Informa operação de Instrução de Embarque para o Negocio.
@type method
@version 12
@author jc.maldonado
@since 18/02/2025
@param nOperation, numeric, MODEL_OPERATION_INSERT MODEL_OPERATION_UPDATE MODEL_OPERATION_DELETE
@return variant, nil
/*/
method informarInstrucaoEmbarque() class agdNegocioStatusService
	local oRepository as Object
	local cStatus     as character

	//if nOperation == MODEL_OPERATION_INSERT .or. nOperation == MODEL_OPERATION_UPDATE
	//	cStatus := iif(Self:hasSaldoAinstruir(), ST_ANDAMENTO, ST_FINALIZADO)

	//elseIf nOperation == MODEL_OPERATION_DELETE
	//	cStatus := iif(Self:getTotalInstrucaoEmbarque() > 0, ST_ANDAMENTO, ST_ABERTO)
	//endif
	if !self:hasSaldoAinstruir()
		cStatus := ST_FINALIZADO
	elseif Self:getTotalInstrucaoEmbarque() == 0
		cStatus := ST_ABERTO
	elseif Self:getTotalInstrucaoEmbarque() > 0
		cStatus := ST_ANDAMENTO
	endif


	//verifica se ja nao está no estado correto
	if Self:validaProximoStatus(cStatus) .and. Self:getStatusAtual() != cStatus
		oRepository := agdNegocioRepository():New(Self:cIdNegocioBarter)
		oRepository:updateRepository({{'NEA_STATUS', cStatus}})

		Self:setFullResponse(oRepository)

		if oRepository:isSuccess()
			AGDGRAVAHIS("","NEA",Self:cIdNegocioBarter, Self:getStatusMessage(cStatus),.F., Self:getStatusMessage(cStatus))
		endif

		oRepository:DeActivate()
	endif
return

/*/{Protheus.doc} reabrir
Reabre o negócio, voltando para pendente
@type method
@version 12
@author jean.schulze
@since 16/01/2025
@return variant, nil
/*/
method reabrir() class agdNegocioStatusService
	Local oRepository As Object

	//verifica se ja nao está no estado correto
	if Self:validaProximoStatus(ST_ABERTO) .and. Self:getStatusAtual() != ST_ABERTO

		oRepository := agdNegocioRepository():New(Self:cIdNegocioBarter)
		oRepository:updateRepository({{'NEA_STATUS', ST_ABERTO}})

		Self:setFullResponse(oRepository)

		if oRepository:isSuccess()
			AGDGRAVAHIS("","NEA",Self:cIdNegocioBarter, STR0004,.F.,STR0004) //"REABERTO"
		endif

		oRepository:DeActivate()

	endif

	FreeObj(oRepository)
return nil


/*/{Protheus.doc} versionar
Versiona a negociação, alterando o status(NEA_STATUS) da negociação para Versionado
@type method
@version P12
@author claudineia.reinert
@since 14/02/2025
@param lUsaTela, logical, se é via tela de negociação, default = .T.
/*/
method versionar(lUsaTela as Logical, cMsgHist as Character) class agdNegocioStatusService
	Local oRepository As Object

	Default lUsaTela := .T.
	Default cMsgHist := ""

	//verifica se ja nao está no estado correto
	if Self:validaProximoStatus(ST_VERSIONADO) .and. Self:getAutorizacao() == SAUT_LIBERADO .and. Self:getStatusAtual() != ST_VERSIONADO
		if lUsaTela
			If !FwAlertNoYes(STR0010+Chr(13)+Chr(10);//#"Esta ação ira gerar uma nova versão da negociação, deixando a versão atual como versionada."
				+STR0011+Chr(13)+Chr(10)+Chr(13)+Chr(10);//#"Será necessário executar as aprovações/liberações na nova versão gerada."
				+STR0012,STR0013)//"Deseja prosseguir?" #"Atenção - Versionar Negociação"
				Self:setError(STR0014) //#"Operação cancelada!"
				Return nil
			EndIf

			if !AGDGRAVAHIS("","NEA",Self:cIdNegocioBarter, Self:getStatusMessage(ST_VERSIONADO),.T.) //#"VERSIONADO"
				Self:setError(STR0014) //#"Operação cancelada!"
				return nil
			endif
		Endif

		oRepository := agdNegocioRepository():New(Self:cIdNegocioBarter)
		If oRepository:isRegistroUnico()
			oRepository:updateRepository({{'NEA_STATUS', ST_VERSIONADO}})

			Self:setFullResponse(oRepository)

			if oRepository:isSuccess() .and. !lUsaTela
				cMsgHist := IIF(Empty(cMsgHist),Self:getStatusMessage(ST_VERSIONADO),cMsgHist)
				AGDGRAVAHIS("","NEA",Self:cIdNegocioBarter,Self:getStatusMessage(ST_VERSIONADO),.F.,cMsgHist) //#"VERSIONADO"
			endif

		Else
			Self:setError(STR0016,404) //#"Registro não encontrado."
		EndIf

		oRepository:DeActivate()

	Else
		Self:setError(STR0017 + UPPER(Alltrim(X3CboxDesc( "NEA_STSAUT", SAUT_LIBERADO))) + STR0018 + UPPER(Alltrim(X3CboxDesc( "NEA_STATUS", ST_ABERTO))) + "/" + UPPER(Alltrim(X3CboxDesc( "NEA_STATUS", ST_ANDAMENTO))) + "/" + UPPER(Alltrim(X3CboxDesc( "NEA_STATUS", ST_FINALIZADO))) + STR0019,404) //#"Operação não permitida! Status da negociação não permite versionamento. Somente negociação "#" e com status "#" pode ser versionada."
	endif

	FreeObj(oRepository)

return nil

/*/{Protheus.doc} atualizarStRecebNegocio
Atualiza o status do recebimento do negócio
@type method
@version 12
@since 01/10/2025
@author Gilson.Venturi
@return variant, nil
*/
method atualizarStRecebNegocio() class agdNegocioStatusService
	Local cStRecAtual	:= POSICIONE( "NEA", 1, Self:cIdNegocioBarter, "NEA_STSREC" )

	oNegocioService := agdNegocioService():New()
	cStatusRec := oNegocioService:buscarStatusRecebimento(Self:cIdNegocioBarter)
	FreeObj(oNegocioService)

	If cStRecAtual != cStatusRec
		oRepository := agdNegocioRepository():New(Self:cIdNegocioBarter)
		oRepository:updateRepository({{'NEA_STSREC', cStatusRec}})
		Self:setFullResponse(oRepository)
		oRepository:DeActivate()
		FreeObj(oRepository)
	EndIf

return nil

/*/{Protheus.doc} atualizarStExpedNegocio
Atualiza o status da Expedição do negócio
@type method
@version 12
@since 01/10/2025
@author Gilson.Venturi
@return variant, nil
*/
method atualizarStExpedNegocio() class agdNegocioStatusService
	Local cStExpAtual	:= POSICIONE( "NEA", 1, Self:cIdNegocioBarter, "NEA_STSEXP" )

	oNegocioService := agdNegocioService():New()
	cStatusExp := oNegocioService:getStExpedBarter(Self:cIdNegocioBarter)
	FreeObj(oNegocioService)

	If cStExpAtual != cStatusExp
		oRepository := agdNegocioRepository():New(Self:cIdNegocioBarter)
		oRepository:updateRepository({{'NEA_STSEXP', cStatusExp}})
		Self:setFullResponse(oRepository)
		oRepository:DeActivate()
		FreeObj(oRepository)
	EndIf

return nil

/*/{Protheus.doc} concluirNegocio
Atualiza o status do negócio para CONCLUIDO ou retrocede para FINALIZADO
@type method
@version 12
@since 01/10/2025
@author Gilson.Venturi
@return variant, nil
*/
method concluirNegocio() class agdNegocioStatusService
	Local cStRecAtual	:= POSICIONE( "NEA", 1, Self:cIdNegocioBarter, "NEA_STSREC" )
	Local cStExpAtual	:= POSICIONE( "NEA", 1, Self:cIdNegocioBarter, "NEA_STSEXP" )
	Local cStNegoc	:= ''

    If Self:getStatusAtual() != ST_CONCLUIDO
		If  cStRecAtual == ST_R_E_FINALIZADO .and. cStExpAtual == ST_R_E_FINALIZADO
			cStNegoc := ST_CONCLUIDO
		EndIf
	else
		If cStExpAtual != ST_R_E_FINALIZADO
			cStNegoc := ST_ANDAMENTO
		elseif cStRecAtual != ST_R_E_FINALIZADO
			cStNegoc := ST_FINALIZADO
		Endif
	Endif

	If cStNegoc $ ('2|4|8')
		oRepository := agdNegocioRepository():New(Self:cIdNegocioBarter)
		oRepository:updateRepository({{'NEA_STATUS', cStNegoc}})
		Self:setFullResponse(oRepository)
		oRepository:DeActivate()
		FreeObj(oRepository)
	Endif

return nil

/*/{Protheus.doc} getStatus
Retorna a lista de status + status possíveis a partir de cada status
@type method
@version 12
@author jean.schulze
@since 16/01/2025
@return array, lista de status
/*/
method getStatus() as Array class agdNegocioStatusService
	Local aStatus := {} /*STATUS, LISTA DE OPCOES*/

	aAdd(aStatus, {ST_ABERTO  	, {ST_ABERTO, ST_ANDAMENTO, ST_CANCELADO, ST_FINALIZADO, ST_VERSIONADO}})
	aAdd(aStatus, {ST_CANCELADO , {ST_CANCELADO}})
	aAdd(aStatus, {ST_ANDAMENTO , {ST_ANDAMENTO, ST_ABERTO, ST_CANCELADO, ST_FINALIZADO, ST_VERSIONADO}})
	aAdd(aStatus, {ST_FINALIZADO, {ST_FINALIZADO, ST_VERSIONADO, ST_ABERTO, ST_ANDAMENTO}})

return aStatus

/*/{Protheus.doc} agdNegocioStatusService::getStatusMessage
Retorna a mensagem de acordo com o status informado.
@type method
@version 12
@author jc.maldonado
@since 19/02/2025
@param cCodStatus, character, codigo do status
@return character, mensagem do status
/*/
method getStatusMessage(cCodStatus as character) as character class agdNegocioStatusService
	local cMessage as character

	do case
	case cCodStatus == ST_ANDAMENTO
		cMessage := STR0003 //EM ANDAMENTO
	case cCodStatus == ST_FINALIZADO
		cMessage := STR0006 //FINALIZADO
	case cCodStatus == ST_ABERTO
		cMessage := STR0007 //EM ABERTO
	case cCodStatus == ST_CANCELADO
		cMessage := STR0008 //CANCELADO
	case cCodStatus == ST_VERSIONADO
		cMessage := STR0015 //VERSIONADO
	case cCodStatus == ST_CONCLUIDO
		cMessage := STR0030 //VERSIONADO
	endcase
return cMessage

/*/{Protheus.doc} getStatusAtual
Retorna o Status Atual do Registro
@type method
@version 12
@author jean.schulze
@since 16/01/2025
@return variant, status atual
/*/
method getStatusAtual() as Character class agdNegocioStatusService
return POSICIONE( "NEA", 1, Self:cIdNegocioBarter, "NEA_STATUS" )

/*/{Protheus.doc} validaProximoStatus
Verifica se o status de destino está disponível, conforme o status atual
@type method
@version 12
@author jean.schulze
@since 16/01/2025
@param nProximoStatus, numeric, status de destino
@return logical, se pode executar a ação
/*/
method validaProximoStatus(nProximoStatus) as Logical class agdNegocioStatusService
	Local aStatus := Self:getStatus()
	Local nPosStatus := aScan(aStatus, {|x| x[1] == Self:getStatusAtual() })

	if nPosStatus == 0 .OR. !aScan(aStatus[nPosStatus][2], {|x| x == nProximoStatus })
		Self:setError(STR0005)
		return .F.
	endif

return .T.

/*/{Protheus.doc} agdNegocioStatusService::getAutorizacao
Retorna o status da autorização
@type method
@version 12
@author jc.maldonado
@since 18/02/2025
@return character, "1"=Nao Liberado;"2"=Liberado 
/*/
method getAutorizacao() as character class  agdNegocioStatusService
return POSICIONE( "NEA", 1, Self:cIdNegocioBarter, "NEA_STSAUT" )

/*/{Protheus.doc} agdNegocioStatusService::getTotalInstrucaoEmbarque
Retorna o total de Instruções de Embarque que o Negocio possui.
@type method
@version 12
@author jc.maldonado
@since 19/02/2025
@return numeric, total de Instruções de Embarque
/*/
method getTotalInstrucaoEmbarque() as numeric class agdNegocioStatusService
	local cQuery as character
	local cAlias as character
	local nTotal as numeric
	Local oStatement 	:= nil

	dbSelectArea('NEA')
	NEA->(dbSetOrder(1))
	NEA->(dbSeek(Self:cIdNegocioBarter))

	If Self:cIdNegocioBarter  == NEA->(NEA_FILIAL+NEA_CODIGO+NEA_VERSAO)

		cQuery := " SELECT SUM(NED_QTDIEB - NED_QTDDEV) AS TOTAL "
		cQuery += " FROM "+ retSqlName('NED') +" NED "
		cQuery += " WHERE NED_FILIAL = ? "
		cQuery += " AND NED_CODBRT = ? "
		cQuery += " AND NED.D_E_L_E_T_ = '' "

		cQuery := changeQuery(cQuery)
		cAlias := getNextAlias()

		oStatement := FWPreparedStatement():New()
		oStatement:SetQuery(cQuery)
		oStatement:SetString(1, FWxFilial('NED'))
		oStatement:SetString(2, NEA->NEA_CODIGO)
		cQuery := oStatement:GetFixQuery()

		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAlias, .T., .T.)

		nTotal := (cAlias)->TOTAL

		(cAlias)->(dbCloseArea())

	endif

return nTotal

/*/{Protheus.doc} agdNegocioStatusService::hasSaldoAinstruir
Verifica se o Negocio possui saldo a instruir.
@type method
@version 12
@author jc.maldonado
@since 18/02/2025
@return logical, .t. or .f.
/*/
method hasSaldoAinstruir() as logical class agdNegocioStatusService
	local aArea 				:= fwGetArea()
	local aAreaNEB 				:= NEB->(FwGetArea())
	local oNegocioInsumoService	:= nil
	local nSaldo      			:= 0
	local lReturn 				:= .f.

	dbSelectArea("NEB")
	NEB->(dbSetOrder(1)) //NEB_FILIAL+NEB_CODBRT+NEB_VERSAO+NEB_ITEM
	if NEB->(DBSeek(Self:cIdNegocioBarter))

		while NEB->(!EOF()) .And. (NEB->NEB_FILIAL + NEB->NEB_CODBRT +  NEB->NEB_VERSAO) == Self:cIdNegocioBarter
			oNegocioInsumoService := agdNegocioInsumoService():New(NEB->NEB_CODBRT, NEB->NEB_VERSAO, NEB->NEB_ITEM)
			nSaldo := oNegocioInsumoService:getSaldo()

			If nSaldo > 0
				lReturn := .T.
				exit
			endif

			NEB->(dbSkip())
			freeObj(oNegocioInsumoService)
		enddo
	endif

	fwRestArea(aArea)
	fwRestArea(aAreaNEB)

return lReturn
